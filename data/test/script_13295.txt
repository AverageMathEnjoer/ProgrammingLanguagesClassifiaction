b'{-# LANGUAGE AllowAmbiguousTypes #-}\n{-# LANGUAGE UndecidableInstances #-}\n{-# LANGUAGE CPP #-}\n\nmodule Database.Beam.Query.CTE where\n\nimport Database.Beam.Backend.SQL\nimport Database.Beam.Query.Internal\nimport Database.Beam.Query.Types\n\nimport Control.Monad.Free.Church\nimport Control.Monad.Writer hiding ((<>))\nimport Control.Monad.State.Strict\n\nimport Data.Kind (Type)\nimport Data.Proxy (Proxy(Proxy))\nimport Data.String\nimport Data.Text (Text)\n\ndata Recursiveness be where\n    Nonrecursive :: Recursiveness be\n    Recursive    :: IsSql99RecursiveCommonTableExpressionSelectSyntax (BeamSqlBackendSelectSyntax be)\n                 => Recursiveness be\n\ninstance Monoid (Recursiveness be) where\n    mempty = Nonrecursive\n    mappend = (<>)\n\ninstance Semigroup (Recursiveness be) where\n    Recursive <> _ = Recursive\n    _ <> Recursive = Recursive\n    _ <> _ = Nonrecursive\n\n-- | Monad in which @SELECT@ statements can be made (via \'selecting\')\n-- and bound to result names for re-use later. This has the advantage\n-- of only computing each result once. In SQL, this is translated to a\n-- common table expression.\n--\n-- Once introduced, results can be re-used in future queries with \'reuse\'.\n--\n-- \'With\' is also a member of \'MonadFix\' for backends that support\n-- recursive CTEs. In this case, you can use @mdo@ or @rec@ notation\n-- (with @RecursiveDo@ enabled) to bind result values (again, using\n-- \'reuse\') even /before/ they\'re introduced.\n--\n-- See further documentation <https://haskell-beam.github.io/beam/user-guide/queries/common-table-expressions/ here>.\nnewtype With be (db :: (Type -> Type) -> Type) a\n    = With { runWith :: WriterT (Recursiveness be, [ BeamSql99BackendCTESyntax be ])\n                                (State Int) a }\n    deriving (Monad, Applicative, Functor)\n\ninstance IsSql99RecursiveCommonTableExpressionSelectSyntax (BeamSqlBackendSelectSyntax be)\n    => MonadFix (With be db) where\n    mfix f = With (tell (Recursive, mempty) >> mfix (runWith . f))\n\ndata QAnyScope\n\n-- | Query results that have been introduced into a common table\n-- expression via \'selecting\' that can be used in future queries with\n-- \'reuse\'.\ndata ReusableQ be db res where\n    ReusableQ :: Proxy res -> (forall s. Proxy s -> Q be db s (WithRewrittenThread QAnyScope s res)) -> ReusableQ be db res\n\nreusableForCTE :: forall be res db\n                . ( ThreadRewritable QAnyScope res\n                  , Projectible be res\n                  , BeamSqlBackend be )\n               => Text -> ReusableQ be db res\nreusableForCTE tblNm =\n    ReusableQ (Proxy @res)\n              (\\proxyS ->\n                 Q $ liftF (QAll (\\_ -> fromTable (tableNamed (tableName Nothing tblNm)) . Just . (, Nothing))\n                                 (\\tblNm\' -> fst $ mkFieldNames @be @res (qualifiedField tblNm\'))\n                                 (\\_ -> Nothing)\n                                 (rewriteThread @QAnyScope @res proxyS . snd)))\n\n-- | Introduce the result of a query as a result in a common table\n-- expression. The returned value can be used in future queries by\n-- applying \'reuse\'.\nselecting :: forall res be db\n           . ( BeamSql99CommonTableExpressionBackend be, HasQBuilder be\n             , Projectible be res\n             , ThreadRewritable QAnyScope res )\n          => Q be db QAnyScope res -> With be db (ReusableQ be db res)\nselecting q =\n  With $ do\n    cteId <- get\n    put (cteId + 1)\n\n    let tblNm = fromString ("cte" ++ show cteId)\n\n        (_ :: res, fieldNames) = mkFieldNames @be (qualifiedField tblNm)\n    tell (Nonrecursive, [ cteSubquerySyntax tblNm fieldNames (buildSqlQuery (tblNm <> "_") q) ])\n\n    pure (reusableForCTE tblNm)\n\n-- | Introduces the result of a previous \'selecting\' (a CTE) into a new query\nreuse :: forall s be db res\n       . ReusableQ be db res -> Q be db s (WithRewrittenThread QAnyScope s res)\nreuse (ReusableQ _ q) = q (Proxy @s)\n\n'