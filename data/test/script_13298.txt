b'import Test.Tasty\nimport Test.Tasty.Options\nimport Test.Tasty.HUnit\nimport Data.Typeable\nimport System.Random\nimport Control.Monad (replicateM)\nimport Control.Monad.State (State, state, evalState)\n\nnewtype Seed = Seed Int\n  deriving Typeable\n\ninstance IsOption Seed where\n  defaultValue = Seed 0\n  parseValue = fmap Seed . safeRead\n  optionName = pure "seed"\n  optionHelp = pure "A random seed to generate random tests"\n\nmain :: IO ()\nmain =\n  defaultMainWithIngredients\n    (includingOptions [Option (Proxy :: Proxy Seed)] : defaultIngredients) $\n    askOption genTestsFromSeed\n\ngenTestsFromSeed :: Seed -> TestTree\ngenTestsFromSeed (Seed seed) = evalState (genTests 0) (mkStdGen seed)\n\ngenTests :: Int -> State StdGen TestTree\ngenTests current_depth = do\n  r1 :: Int <- state $ uniformR (1,5)\n  let is_group = current_depth == 0 || (current_depth < 10 && r1 == 5)\n  name <- genName\n  if is_group\n    then do\n      n_tests <- state $ uniformR (1,10)\n      testGroup name <$> replicateM n_tests (genTests (current_depth+1))\n    else\n      pure $ testCase name (assertFailure "")\n\ngenName :: State StdGen String\ngenName = do\n  len <- state $ uniformR (1,30)\n  replicateM len $ do\n    r1 :: Int <- state $ uniformR (1,10)\n    case r1 of\n      1 -> pure \'\\\\\'\n      2 -> pure \'\\\'\'\n      3 -> pure \' \'\n      4 -> pure \'.\'\n      5 -> pure \'\\t\'\n      _ -> state $ uniformR (\'a\',\'z\')\n'