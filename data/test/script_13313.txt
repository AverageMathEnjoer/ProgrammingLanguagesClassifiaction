b'#include <cinttypes>\n#include <sys/mman.h>\n#include <set>\n#include <string_view>\n#include <pmparser.h>\n#include "logging.h"\n\n/**\n * Magic to hide from /proc/###/maps, the idea is from Haruue Icymoon (https://github.com/haruue)\n */\n\n#define EXPORT __attribute__((visibility("default"))) __attribute__((used))\n\nextern "C" {\nint riru_hide(const std::set<std::string_view> &) EXPORT;\n}\n\n#ifdef __LP64__\n#define LIB_PATH "/system/lib64/"\n#else\n#define LIB_PATH "/system/lib/"\n#endif\n\nstruct hide_struct {\n    procmaps_struct *original;\n    uintptr_t backup_address;\n};\n\nstatic int get_prot(const procmaps_struct *procstruct) {\n    int prot = 0;\n    if (procstruct->is_r) {\n        prot |= PROT_READ;\n    }\n    if (procstruct->is_w) {\n        prot |= PROT_WRITE;\n    }\n    if (procstruct->is_x) {\n        prot |= PROT_EXEC;\n    }\n    return prot;\n}\n\n#define FAILURE_RETURN(exp, failure_value) ({   \\\n    __typeof__(exp) _rc;                    \\\n    _rc = (exp);                            \\\n    if (_rc == failure_value) {             \\\n        PLOGE(#exp);                        \\\n        return 1;                           \\\n    }                                       \\\n    _rc; })\n\nstatic int do_hide(hide_struct *data) {\n    auto procstruct = data->original;\n    auto start = (uintptr_t) procstruct->addr_start;\n    auto end = (uintptr_t) procstruct->addr_end;\n    auto length = end - start;\n    int prot = get_prot(procstruct);\n\n    // backup\n    data->backup_address = (uintptr_t) FAILURE_RETURN(\n            mmap(nullptr, length, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE, -1, 0),\n            MAP_FAILED);\n    LOGD("%" PRIxPTR"-%" PRIxPTR" %s %ld %s is backup to %" PRIxPTR, start, end, procstruct->perm,\n         procstruct->offset,\n         procstruct->pathname, data->backup_address);\n\n    if (!procstruct->is_r) {\n        LOGD("mprotect +r");\n        FAILURE_RETURN(mprotect((void *) start, length, prot | PROT_READ), -1);\n    }\n    LOGD("memcpy -> backup");\n    memcpy((void *) data->backup_address, (void *) start, length);\n\n    // munmap original\n    LOGD("munmap original");\n    FAILURE_RETURN(munmap((void *) start, length), -1);\n\n    // restore\n    LOGD("mmap original");\n    FAILURE_RETURN(mmap((void *) start, length, prot, MAP_ANONYMOUS | MAP_PRIVATE, -1, 0),\n                   MAP_FAILED);\n    LOGD("mprotect +w");\n    FAILURE_RETURN(mprotect((void *) start, length, prot | PROT_WRITE), -1);\n    LOGD("memcpy -> original");\n    memcpy((void *) start, (void *) data->backup_address, length);\n    if (!procstruct->is_w) {\n        LOGD("mprotect -w");\n        FAILURE_RETURN(mprotect((void *) start, length, prot), -1);\n    }\n    return 0;\n}\n\nint riru_hide(const std::set<std::string_view> &names) {\n    procmaps_iterator *maps = pmparser_parse(-1);\n    if (maps == nullptr) {\n        LOGE("cannot parse the memory map");\n        return false;\n    }\n\n    char buf[PATH_MAX];\n    hide_struct *data = nullptr;\n    size_t data_count = 0;\n    procmaps_struct *maps_tmp;\n    while ((maps_tmp = pmparser_next(maps)) != nullptr) {\n        bool matched = false;\n#ifdef DEBUG_APP\n        matched = strstr(maps_tmp->pathname, "libriru.so");\n#endif\n        matched = names.count(maps_tmp->pathname);\n\n        if (!matched) continue;\n\n        auto start = (uintptr_t) maps_tmp->addr_start;\n        auto end = (uintptr_t) maps_tmp->addr_end;\n        if (maps_tmp->is_r) {\n            if (data) {\n                data = (hide_struct *) realloc(data, sizeof(hide_struct) * (data_count + 1));\n            } else {\n                data = (hide_struct *) malloc(sizeof(hide_struct));\n            }\n            data[data_count].original = maps_tmp;\n            data_count += 1;\n        }\n        LOGD("%" PRIxPTR"-%" PRIxPTR" %s %ld %s", start, end, maps_tmp->perm, maps_tmp->offset,\n             maps_tmp->pathname);\n    }\n\n    for (int i = 0; i < data_count; ++i) {\n        do_hide(&data[i]);\n    }\n\n    if (data) free(data);\n    pmparser_free(maps);\n    return 0;\n}\n'