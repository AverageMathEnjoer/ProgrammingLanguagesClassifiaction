b'using System;\nusing System.Diagnostics;\nusing System.Text;\n\nusing i64 = System.Int64;\nusing u8 = System.Byte;\nusing u16 = System.UInt16;\nusing u64 = System.UInt64;\n\nnamespace CS_SQLite3\n{\n  using Op = CSSQLite.VdbeOp;\n  using sqlite3_value = CSSQLite.Mem;\n  using sqlite3_stmt = CSSQLite.Vdbe;\n  using sqlite_int64 = System.Int64;\n\n  public partial class CSSQLite\n  {\n    /*\n    ** 2004 May 26\n    **\n    ** The author disclaims copyright to this source code.  In place of\n    ** a legal notice, here is a blessing:\n    **\n    **    May you do good and not evil.\n    **    May you find forgiveness for yourself and forgive others.\n    **    May you share freely, never taking more than you give.\n    **\n    *************************************************************************\n    **\n    ** This file contains code use to implement APIs that are part of the\n    ** VDBE.\n    **\n    ** $Id: vdbeapi.c,v 1.167 2009/06/25 01:47:12 drh Exp $\n    **\n    *************************************************************************\n    **  Included in SQLite3 port to C#-SQLite;  2008 Noah B Hart\n    **  C#-SQLite is an independent reimplementation of the SQLite software library\n    **\n    **  $Header$\n    *************************************************************************\n    */\n    //#include "sqliteInt.h"\n    //#include "vdbeInt.h"\n\n#if !SQLITE_OMIT_DEPRECATED\n    /*\n** Return TRUE (non-zero) of the statement supplied as an argument needs\n** to be recompiled.  A statement needs to be recompiled whenever the\n** execution environment changes in a way that would alter the program\n** that sqlite3_prepare() generates.  For example, if new functions or\n** collating sequences are registered or if an authorizer function is\n** added or changed.\n*/\n    static int sqlite3_expired( sqlite3_stmt pStmt )\n    {\n      Vdbe p = (Vdbe)pStmt;\n      return ( p == null || p.expired ) ? 1 : 0;\n    }\n#endif\n    /*\n** The following routine destroys a virtual machine that is created by\n** the sqlite3_compile() routine. The integer returned is an SQLITE_\n** success/failure code that describes the result of executing the virtual\n** machine.\n**\n** This routine sets the error code and string returned by\n** sqlite3_errcode(), sqlite3_errmsg() and sqlite3_errmsg16().\n*/\n    public static int sqlite3_finalize( ref sqlite3_stmt pStmt )\n    {\n      int rc;\n      if ( pStmt == null )\n      {\n        rc = SQLITE_OK;\n      }\n      else\n      {\n        Vdbe v = pStmt;\n        sqlite3 db = v.db;\n#if  SQLITE_THREADSAFE\nsqlite3_mutex mutex = v.db.mutex;\n#endif\n        sqlite3_mutex_enter( mutex );\n        rc = sqlite3VdbeFinalize( v );\n        rc = sqlite3ApiExit( db, rc );\n        sqlite3_mutex_leave( mutex );\n      }\n      return rc;\n    }\n\n    /*\n    ** Terminate the current execution of an SQL statement and reset it\n    ** back to its starting state so that it can be reused. A success code from\n    ** the prior execution is returned.\n    **\n    ** This routine sets the error code and string returned by\n    ** sqlite3_errcode(), sqlite3_errmsg() and sqlite3_errmsg16().\n    */\n    public static int sqlite3_reset( sqlite3_stmt pStmt )\n    {\n      int rc;\n      if ( pStmt == null )\n      {\n        rc = SQLITE_OK;\n      }\n      else\n      {\n        Vdbe v = (Vdbe)pStmt;\n        sqlite3_mutex_enter( v.db.mutex );\n        rc = sqlite3VdbeReset( v );\n        sqlite3VdbeMakeReady( v, -1, 0, 0, 0 );\n        Debug.Assert( ( rc & ( v.db.errMask ) ) == rc );\n        rc = sqlite3ApiExit( v.db, rc );\n        sqlite3_mutex_leave( v.db.mutex );\n      }\n      return rc;\n    }\n\n    /*\n    ** Set all the parameters in the compiled SQL statement to NULL.\n    */\n    static int sqlite3_clear_bindings( sqlite3_stmt pStmt )\n    {\n      int i;\n      int rc = SQLITE_OK;\n      Vdbe p = (Vdbe)pStmt;\n#if  SQLITE_THREADSAFE\nsqlite3_mutex mutex = ( (Vdbe)pStmt ).db.mutex;\n#endif\n      sqlite3_mutex_enter( mutex );\n      for ( i = 0 ; i < p.nVar ; i++ )\n      {\n        sqlite3VdbeMemRelease( p.aVar[i] );\n        p.aVar[i].flags = MEM_Null;\n      }\n      sqlite3_mutex_leave( mutex );\n      return rc;\n    }\n\n\n    /**************************** sqlite3_value_  *******************************\n    ** The following routines extract information from a Mem or sqlite3_value\n    ** structure.\n    */\n    public static byte[] sqlite3_value_blob( sqlite3_value pVal )\n    {\n      Mem p = pVal;\n      if ( ( p.flags & ( MEM_Blob | MEM_Str ) ) != 0 )\n      {\n        sqlite3VdbeMemExpandBlob( p );\n        if ( p.zBLOB == null && p.z != null )\n        {\n          if ( p.z.Length == 0 ) p.zBLOB = new byte[1];\n          else\n          {\n            p.zBLOB = new byte[p.z.Length];\n            for ( int i = 0 ; i < p.zBLOB.Length ; i++ ) p.zBLOB[i] = (u8)p.z[i];\n          } p.z = null;\n        }\n        p.flags = (u16)( p.flags & ~MEM_Str );\n        p.flags |= MEM_Blob;\n        return p.zBLOB;\n      }\n      else\n      {\n        return sqlite3_value_text( pVal ) == null ? null : Encoding.UTF8.GetBytes( sqlite3_value_text( pVal ) );\n      }\n    }\n    public static int sqlite3_value_bytes( sqlite3_value pVal )\n    {\n      return sqlite3ValueBytes( pVal, SQLITE_UTF8 );\n    }\n    public static int sqlite3_value_bytes16( sqlite3_value pVal )\n    {\n      return sqlite3ValueBytes( pVal, SQLITE_UTF16NATIVE );\n    }\n    public static double sqlite3_value_double( sqlite3_value pVal )\n    {\n      return sqlite3VdbeRealValue( pVal );\n    }\n    public static int sqlite3_value_int( sqlite3_value pVal )\n    {\n      return (int)sqlite3VdbeIntValue( pVal );\n    }\n    public static sqlite_int64 sqlite3_value_int64( sqlite3_value pVal )\n    {\n      return sqlite3VdbeIntValue( pVal );\n    }\n    public static string sqlite3_value_text( sqlite3_value pVal )\n    {\n      return sqlite3ValueText( pVal, SQLITE_UTF8 );\n    }\n#if  !SQLITE_OMIT_UTF16\nstatic string sqlite3_value_text16(sqlite3_value pVal){\nreturn sqlite3ValueText(pVal, SQLITE_UTF16NATIVE);\n}\nstatic string  sqlite3_value_text16be(sqlite3_value pVal){\nreturn sqlite3ValueText(pVal, SQLITE_UTF16BE);\n}\nstatic string sqlite3_value_text16le(sqlite3_value pVal){\nreturn sqlite3ValueText(pVal, SQLITE_UTF16LE);\n}\n#endif // * SQLITE_OMIT_UTF16 */\n    public static int sqlite3_value_type( sqlite3_value pval )\n    {\n      return pval.type;\n    }\n\n    /**************************** sqlite3_result_  *******************************\n    ** The following routines are used by user-defined functions to specify\n    ** the function result.\n    **\n    ** The setStrOrError() funtion calls sqlite3VdbeMemSetStr() to store the\n    ** result as a string or blob but if the string or blob is too large, it\n    ** then sets the error code to SQLITE_TOOBIG\n    */\n    static void setResultStrOrError(\n    sqlite3_context pCtx,   /* Function context */\n    string z,               /* String pointer */\n    int n,                  /* Bytes in string, or negative */\n    u8 enc,                 /* Encoding of z.  0 for BLOBs */\n    dxDel xDel //void (*xDel)(void*)     /* Destructor function */\n    )\n    {\n      if ( sqlite3VdbeMemSetStr( pCtx.s, z, n, enc, xDel ) == SQLITE_TOOBIG )\n      {\n        sqlite3_result_error_toobig( pCtx );\n      }\n    }\n    public static void sqlite3_result_blob(\n    sqlite3_context pCtx,\n    string z,\n    int n,\n    dxDel xDel\n    )\n    {\n      Debug.Assert( n >= 0 );\n      Debug.Assert( sqlite3_mutex_held( pCtx.s.db.mutex ) );\n      setResultStrOrError( pCtx, z, n, 0, xDel );\n    }\n    public static void sqlite3_result_double( sqlite3_context pCtx, double rVal )\n    {\n      Debug.Assert( sqlite3_mutex_held( pCtx.s.db.mutex ) );\n      sqlite3VdbeMemSetDouble( pCtx.s, rVal );\n    }\n    public static void sqlite3_result_error( sqlite3_context pCtx, string z, int n )\n    {\n      Debug.Assert( sqlite3_mutex_held( pCtx.s.db.mutex ) );\n      setResultStrOrError( pCtx, z, n, SQLITE_UTF8, SQLITE_TRANSIENT );\n      pCtx.isError = SQLITE_ERROR;\n    }\n#if  !SQLITE_OMIT_UTF16\n//void sqlite3_result_error16(sqlite3_context pCtx, const void *z, int n){\n//  Debug.Assert( sqlite3_mutex_held(pCtx.s.db.mutex) );\n//  pCtx.isError = SQLITE_ERROR;\n//  sqlite3VdbeMemSetStr(pCtx.s, z, n, SQLITE_UTF16NATIVE, SQLITE_TRANSIENT);\n//}\n#endif\n    static void sqlite3_result_int( sqlite3_context pCtx, int iVal )\n    {\n      Debug.Assert( sqlite3_mutex_held( pCtx.s.db.mutex ) );\n      sqlite3VdbeMemSetInt64( pCtx.s, (i64)iVal );\n    }\n    static void sqlite3_result_int64( sqlite3_context pCtx, i64 iVal )\n    {\n      Debug.Assert( sqlite3_mutex_held( pCtx.s.db.mutex ) );\n      sqlite3VdbeMemSetInt64( pCtx.s, iVal );\n    }\n    static void sqlite3_result_null( sqlite3_context pCtx )\n    {\n      Debug.Assert( sqlite3_mutex_held( pCtx.s.db.mutex ) );\n      sqlite3VdbeMemSetNull( pCtx.s );\n    }\n\n    public static void sqlite3_result_text(\n    sqlite3_context pCtx,\n    string z,\n    int n,\n    dxDel xDel\n    )\n    {\n      Debug.Assert( sqlite3_mutex_held( pCtx.s.db.mutex ) );\n      setResultStrOrError( pCtx, z, n, SQLITE_UTF8, xDel );\n    }\n#if  !SQLITE_OMIT_UTF16\nvoid sqlite3_result_text16(\nsqlite3_context pCtx,\nstring z,\nint n,\ndxDel xDel\n){\nDebug.Assert( sqlite3_mutex_held(pCtx.s.db.mutex) );\nsqlite3VdbeMemSetStr(pCtx.s, z, n, SQLITE_UTF16NATIVE, xDel);\n}\nvoid sqlite3_result_text16be(\nsqlite3_context pCtx,\nstring z,\nint n,\ndxDel xDel\n){\nDebug.Assert( sqlite3_mutex_held(pCtx.s.db.mutex) );\nsqlite3VdbeMemSetStr(pCtx.s, z, n, SQLITE_UTF16BE, xDel);\n}\nvoid sqlite3_result_text16le(\nsqlite3_context pCtx,\nstring z,\nint n,\ndxDel xDel\n){\nDebug.Assert( sqlite3_mutex_held(pCtx.s.db.mutex) );\nsqlite3VdbeMemSetStr(pCtx.s, z, n, SQLITE_UTF16LE, xDel);\n}\n#endif // * SQLITE_OMIT_UTF16 */\n    static void sqlite3_result_value( sqlite3_context pCtx, sqlite3_value pValue )\n    {\n      Debug.Assert( sqlite3_mutex_held( pCtx.s.db.mutex ) );\n      sqlite3VdbeMemCopy( pCtx.s, pValue );\n    }\n    static void sqlite3_result_zeroblob( sqlite3_context pCtx, int n )\n    {\n      Debug.Assert( sqlite3_mutex_held( pCtx.s.db.mutex ) );\n      sqlite3VdbeMemSetZeroBlob( pCtx.s, n );\n    }\n    static void sqlite3_result_error_code( sqlite3_context pCtx, int errCode )\n    {\n      pCtx.isError = errCode;\n      if ( ( pCtx.s.flags & MEM_Null ) != 0 )\n      {\n        setResultStrOrError( pCtx, sqlite3ErrStr( errCode ), -1,\n           SQLITE_UTF8, SQLITE_STATIC );\n      }\n    }\n\n    /* Force an SQLITE_TOOBIG error. */\n    static void sqlite3_result_error_toobig( sqlite3_context pCtx )\n    {\n      Debug.Assert( sqlite3_mutex_held( pCtx.s.db.mutex ) );\n      pCtx.isError = SQLITE_ERROR;\n      setResultStrOrError( pCtx, "string or blob too big", -1,\n      SQLITE_UTF8, SQLITE_STATIC );\n    }\n\n    /* An SQLITE_NOMEM error. */\n    static void sqlite3_result_error_nomem( sqlite3_context pCtx )\n    {\n      Debug.Assert( sqlite3_mutex_held( pCtx.s.db.mutex ) );\n      sqlite3VdbeMemSetNull( pCtx.s );\n      pCtx.isError = SQLITE_NOMEM;\n      //pCtx.s.db.mallocFailed = 1;\n    }\n\n    /*\n    ** Execute the statement pStmt, either until a row of data is ready, the\n    ** statement is completely executed or an error occurs.\n    **\n    ** This routine implements the bulk of the logic behind the sqlite_step()\n    ** API.  The only thing omitted is the automatic recompile if a\n    ** schema change has occurred.  That detail is handled by the\n    ** outer sqlite3_step() wrapper procedure.\n    */\n    static int sqlite3Step( Vdbe p )\n    {\n      sqlite3 db;\n      int rc;\n\n      Debug.Assert( p != null );\n      if ( p.magic != VDBE_MAGIC_RUN )\n      {\n        return SQLITE_MISUSE;\n      }\n\n      /* Assert that malloc() has not failed */\n      db = p.db;\n      //if ( db.mallocFailed != 0 )\n      //{\n      //  return SQLITE_NOMEM;\n      //}\n\n      if ( p.pc <= 0 && p.expired )\n      {\n        if ( ALWAYS( p.rc == SQLITE_OK ) )\n        {\n          p.rc = SQLITE_SCHEMA;\n        }\n        rc = SQLITE_ERROR;\n        goto end_of_step;\n      }\n      if ( sqlite3SafetyOn( db ) )\n      {\n        p.rc = SQLITE_MISUSE;\n        return SQLITE_MISUSE;\n      }\n      if ( p.pc < 0 )\n      {\n        /* If there are no other statements currently running, then\n        ** reset the interrupt flag.  This prevents a call to sqlite3_interrupt\n        ** from interrupting a statement that has not yet started.\n        */\n        if ( db.activeVdbeCnt == 0 )\n        {\n          db.u1.isInterrupted = false;\n        }\n\n#if  !SQLITE_OMIT_TRACE\n        if ( db.xProfile != null && 0 == db.init.busy )\n        {\n          double rNow = 0;\n          sqlite3OsCurrentTime( db.pVfs, ref rNow );\n          p.startTime = (u64)( ( rNow - (int)rNow ) * 3600.0 * 24.0 * 1000000000.0 );\n        }\n#endif\n\n        db.activeVdbeCnt++;\n        if ( p.readOnly == false ) db.writeVdbeCnt++;\n        p.pc = 0;\n      }\n#if  !SQLITE_OMIT_EXPLAIN\n      if ( p.explain != 0 )\n      {\n        rc = sqlite3VdbeList( p );\n      }\n      else\n#endif // * SQLITE_OMIT_EXPLAIN */\n      {\n\n        rc = sqlite3VdbeExec( p );\n      }\n\n      if ( sqlite3SafetyOff( db ) )\n      {\n        rc = SQLITE_MISUSE;\n      }\n\n#if  !SQLITE_OMIT_TRACE\n      /* Invoke the profile callback if there is one\n*/\n      if ( rc != SQLITE_ROW && db.xProfile != null && 0 == db.init.busy && p.zSql != null )\n      {\n        double rNow = 0;\n        u64 elapseTime;\n\n        sqlite3OsCurrentTime( db.pVfs, ref rNow );\n        elapseTime = (u64)( ( rNow - (int)rNow ) * 3600.0 * 24.0 * 1000000000.0 );\n        elapseTime -= p.startTime;\n        db.xProfile( db.pProfileArg, p.zSql, elapseTime );\n      }\n#endif\n\n      db.errCode = rc;\n      if ( SQLITE_NOMEM == sqlite3ApiExit( p.db, p.rc ) )\n      {\n        p.rc = SQLITE_NOMEM;\n      }\nend_of_step:\n      /* At this point local variable rc holds the value that should be\n      ** returned if this statement was compiled using the legacy\n      ** sqlite3_prepare() interface. According to the docs, this can only\n      ** be one of the values in the first Debug.Assert() below. Variable p.rc\n      ** contains the value that would be returned if sqlite3_finalize()\n      ** were called on statement p.\n      */\n      Debug.Assert( rc == SQLITE_ROW || rc == SQLITE_DONE || rc == SQLITE_ERROR\n      || rc == SQLITE_BUSY || rc == SQLITE_MISUSE\n      );\n      Debug.Assert( p.rc != SQLITE_ROW && p.rc != SQLITE_DONE );\n      if ( p.isPrepareV2 && rc != SQLITE_ROW && rc != SQLITE_DONE )\n      {\n        /* If this statement was prepared using sqlite3_prepare_v2(), and an\n        ** error has occured, then return the error code in p.rc to the\n        ** caller. Set the error code in the database handle to the same value.\n        */\n        rc = db.errCode = p.rc;\n      }\n      return ( rc & db.errMask );\n    }\n\n    /*\n    ** This is the top-level implementation of sqlite3_step().  Call\n    ** sqlite3Step() to do most of the work.  If a schema error occurs,\n    ** call sqlite3Reprepare() and try again.\n    */\n    public static int sqlite3_step( sqlite3_stmt pStmt )\n    {\n      int rc = SQLITE_MISUSE;\n      if ( pStmt != null )\n      {\n        int cnt = 0;\n        Vdbe v = (Vdbe)pStmt;\n        sqlite3 db = v.db;\n        sqlite3_mutex_enter( db.mutex );\n        while ( ( rc = sqlite3Step( v ) ) == SQLITE_SCHEMA\n        && cnt++ < 5\n        && ( rc = sqlite3Reprepare( v ) ) == SQLITE_OK )\n        {\n          sqlite3_reset( pStmt );\n          v.expired = false;\n        }\n        if ( rc == SQLITE_SCHEMA && ALWAYS( v.isPrepareV2 ) && ALWAYS( db.pErr != null ) )\n        {\n          /* This case occurs after failing to recompile an sql statement.\n          ** The error message from the SQL compiler has already been loaded\n          ** into the database handle. This block copies the error message\n          ** from the database handle into the statement and sets the statement\n          ** program counter to 0 to ensure that when the statement is\n          ** finalized or reset the parser error message is available via\n          ** sqlite3_errmsg() and sqlite3_errcode().\n          */\n          string zErr = sqlite3_value_text( db.pErr );\n          //sqlite3DbFree( db, ref v.zErrMsg );\n          //if ( 0 == db.mallocFailed )\n          {\n            v.zErrMsg = zErr;// sqlite3DbStrDup(db, zErr);\n          }\n          //else\n          //{\n          //  v.zErrMsg = "";\n          //  v.rc = SQLITE_NOMEM;\n          //}\n        }\n        rc = sqlite3ApiExit( db, rc );\n        sqlite3_mutex_leave( db.mutex );\n      }\n      return rc;\n    }\n\n    /*\n    ** Extract the user data from a sqlite3_context structure and return a\n    ** pointer to it.\n    */\n    static object sqlite3_user_data( sqlite3_context p )\n    {\n      Debug.Assert( p != null && p.pFunc != null );\n      return p.pFunc.pUserData;\n    }\n\n    /*\n    ** Extract the user data from a sqlite3_context structure and return a\n    ** pointer to it.\n    */\n    static sqlite3 sqlite3_context_db_handle( sqlite3_context p )\n    {\n      Debug.Assert( p != null && p.pFunc != null );\n      return p.s.db;\n    }\n\n    /*\n    ** The following is the implementation of an SQL function that always\n    ** fails with an error message stating that the function is used in the\n    ** wrong context.  The sqlite3_overload_function() API might construct\n    ** SQL function that use this routine so that the functions will exist\n    ** for name resolution but are actually overloaded by the xFindFunction\n    ** method of virtual tables.\n    */\n    static void sqlite3InvalidFunction(\n    sqlite3_context context, /* The function calling context */\n    int NotUsed,                /* Number of arguments to the function */\n    sqlite3_value[] NotUsed2       /* Value of each argument */\n    )\n    {\n      string zName = context.pFunc.zName;\n      string zErr;\n      UNUSED_PARAMETER2( NotUsed, NotUsed2 );\n      zErr = sqlite3_mprintf(\n      "unable to use function %s in the requested context", zName );\n      sqlite3_result_error( context, zErr, -1 );\n      //sqlite3_free( ref zErr );\n    }\n\n    /*\n    ** Allocate or return the aggregate context for a user function.  A new\n    ** context is allocated on the first call.  Subsequent calls return the\n    ** same context that was returned on prior calls.\n    */\n    public static Mem sqlite3_aggregate_context( sqlite3_context p, int nByte )\n    {\n      Mem pMem;\n      Debug.Assert( p != null && p.pFunc != null && p.pFunc.xStep != null );\n      Debug.Assert( sqlite3_mutex_held( p.s.db.mutex ) );\n      pMem = p.pMem;\n      if ( ( pMem.flags & MEM_Agg ) == 0 )\n      {\n        if ( nByte == 0 )\n        {\n          sqlite3VdbeMemReleaseExternal( pMem );\n          pMem.flags = MEM_Null;\n          pMem.z = null;\n        }\n        else\n        {\n          sqlite3VdbeMemGrow( pMem, nByte, 0 );\n          pMem.flags = MEM_Agg;\n          pMem.u.pDef = p.pFunc;\n          if ( pMem.z != null )\n          {\n            pMem.z = null;\n          }\n          pMem._Mem = new Mem();\n          pMem._Mem.flags = 0;\n          pMem._SumCtx = new SumCtx();\n        }\n      }\n      return pMem._Mem;\n    }\n\n    /*\n    ** Return the auxillary data pointer, if any, for the iArg\'th argument to\n    ** the user-function defined by pCtx.\n    */\n    static string sqlite3_get_auxdata( sqlite3_context pCtx, int iArg )\n    {\n      VdbeFunc pVdbeFunc;\n\n      Debug.Assert( sqlite3_mutex_held( pCtx.s.db.mutex ) );\n      pVdbeFunc = pCtx.pVdbeFunc;\n      if ( null == pVdbeFunc || iArg >= pVdbeFunc.nAux || iArg < 0 )\n      {\n        return null;\n      }\n      return pVdbeFunc.apAux[iArg].pAux;\n    }\n\n    /*\n    ** Set the auxillary data pointer and delete function, for the iArg\'th\n    ** argument to the user-function defined by pCtx. Any previous value is\n    ** deleted by calling the delete function specified when it was set.\n    */\n    static void sqlite3_set_auxdata(\n    sqlite3_context pCtx,\n    int iArg,\n    string pAux,\n    dxDel xDelete//void (*xDelete)(void*)\n    )\n    {\n      AuxData pAuxData;\n      VdbeFunc pVdbeFunc;\n      if ( iArg < 0 ) goto failed;\n\n      Debug.Assert( sqlite3_mutex_held( pCtx.s.db.mutex ) );\n      pVdbeFunc = pCtx.pVdbeFunc;\n      if ( null == pVdbeFunc || pVdbeFunc.nAux <= iArg )\n      {\n        int nAux = ( pVdbeFunc != null ? pVdbeFunc.nAux : 0 );\n        int nMalloc = iArg; ;//VdbeFunc+ sizeof(struct AuxData)*iArg;\n        if ( pVdbeFunc == null )\n        {\n          //pVdbeFunc = (VdbeFunc)sqlite3DbRealloc( pCtx.s.db, pVdbeFunc, nMalloc );\n          pVdbeFunc = new VdbeFunc();\n          if ( null == pVdbeFunc )\n          {\n            goto failed;\n          }\n          pCtx.pVdbeFunc = pVdbeFunc;\n        }\n        pVdbeFunc.apAux[nAux] = new AuxData();//memset(pVdbeFunc.apAux[nAux], 0, sizeof(struct AuxData)*(iArg+1-nAux));\n        pVdbeFunc.nAux = iArg + 1;\n        pVdbeFunc.pFunc = pCtx.pFunc;\n      }\n\n      pAuxData = pVdbeFunc.apAux[iArg];\n      if ( pAuxData.pAux != null && pAuxData.xDelete != null )\n      {\n        pAuxData.xDelete( ref pAuxData.pAux );\n      }\n      pAuxData.pAux = pAux;\n      pAuxData.xDelete = xDelete;\n      return;\n\nfailed:\n      if ( xDelete != null )\n      {\n        xDelete( ref pAux );\n      }\n    }\n\n#if !SQLITE_OMIT_DEPRECATED\n    /*\n** Return the number of times the Step function of a aggregate has been\n** called.\n**\n** This function is deprecated.  Do not use it for new code.  It is\n** provide only to avoid breaking legacy code.  New aggregate function\n** implementations should keep their own counts within their aggregate\n** context.\n*/\n    static int sqlite3_aggregate_count( sqlite3_context p )\n    {\n      Debug.Assert( p != null && p.pMem != null && p.pFunc != null && p.pFunc.xStep != null );\n      return p.pMem.n;\n    }\n#endif\n\n    /*\n** Return the number of columns in the result set for the statement pStmt.\n*/\n    public static int sqlite3_column_count( sqlite3_stmt pStmt )\n    {\n      Vdbe pVm = pStmt;\n      return pVm != null ? (int)pVm.nResColumn : 0;\n    }\n\n    /*\n    ** Return the number of values available from the current row of the\n    ** currently executing statement pStmt.\n    */\n    public static int sqlite3_data_count( sqlite3_stmt pStmt )\n    {\n      Vdbe pVm = pStmt;\n      if ( pVm == null || pVm.pResultSet == null ) return 0;\n      return pVm.nResColumn;\n    }\n\n\n    /*\n    ** Check to see if column iCol of the given statement is valid.  If\n    ** it is, return a pointer to the Mem for the value of that column.\n    ** If iCol is not valid, return a pointer to a Mem which has a value\n    ** of NULL.\n    */\n    static Mem columnMem( sqlite3_stmt pStmt, int i )\n    {\n      Vdbe pVm;\n      int vals;\n      Mem pOut;\n\n      pVm = (Vdbe)pStmt;\n      if ( pVm != null && pVm.pResultSet != null && i < pVm.nResColumn && i >= 0 )\n      {\n        sqlite3_mutex_enter( pVm.db.mutex );\n        vals = sqlite3_data_count( pStmt );\n        pOut = pVm.pResultSet[i];\n      }\n      else\n      {\n        /* If the value passed as the second argument is out of range, return\n        ** a pointer to the following static Mem object which contains the\n        ** value SQL NULL. Even though the Mem structure contains an element\n        ** of type i64, on certain architecture (x86) with certain compiler\n        ** switches (-Os), gcc may align this Mem object on a 4-byte boundary\n        ** instead of an 8-byte one. This all works fine, except that when\n        ** running with SQLITE_DEBUG defined the SQLite code sometimes assert()s\n        ** that a Mem structure is located on an 8-byte boundary. To prevent\n        ** this assert() from failing, when building with SQLITE_DEBUG defined\n        ** using gcc, force nullMem to be 8-byte aligned using the magical\n        ** __attribute__((aligned(8))) macro.  */\n        //    Mem nullMem\n#if (SQLITE_DEBUG) && (__GNUC__)\n__attribute__((aligned(8)))\n#endif\n        //\n        Mem nullMem = new Mem();//    static const Mem nullMem = {{0}, (double)0, 0, "", 0, MEM_Null, SQLITE_NULL, 0, 0, 0 };\n\n        if ( pVm != null && ALWAYS( pVm.db != null ) )\n        {\n          sqlite3_mutex_enter( pVm.db.mutex );\n          sqlite3Error( pVm.db, SQLITE_RANGE, 0 );\n        }\n        pOut = (Mem)nullMem;\n      }\n      return pOut;\n    }\n\n    /*\n    ** This function is called after invoking an sqlite3_value_XXX function on a\n    ** column value (i.e. a value returned by evaluating an SQL expression in the\n    ** select list of a SELECT statement) that may cause a malloc() failure. If\n    ** malloc() has failed, the threads mallocFailed flag is cleared and the result\n    ** code of statement pStmt set to SQLITE_NOMEM.\n    **\n    ** Specifically, this is called from within:\n    **\n    **     sqlite3_column_int()\n    **     sqlite3_column_int64()\n    **     sqlite3_column_text()\n    **     sqlite3_column_text16()\n    **     sqlite3_column_real()\n    **     sqlite3_column_bytes()\n    **     sqlite3_column_bytes16()\n    **\n    ** But not for sqlite3_column_blob(), which never calls malloc().\n    */\n    static void columnMallocFailure( sqlite3_stmt pStmt )\n    {\n      /* If malloc() failed during an encoding conversion within an\n      ** sqlite3_column_XXX API, then set the return code of the statement to\n      ** SQLITE_NOMEM. The next call to _step() (if any) will return SQLITE_ERROR\n      ** and _finalize() will return NOMEM.\n      */\n      Vdbe p = pStmt;\n      if ( p != null )\n      {\n        p.rc = sqlite3ApiExit( p.db, p.rc );\n        sqlite3_mutex_leave( p.db.mutex );\n      }\n    }\n\n    /**************************** sqlite3_column_  *******************************\n    ** The following routines are used to access elements of the current row\n    ** in the result set.\n    */\n    public static byte[] sqlite3_column_blob( sqlite3_stmt pStmt, int i )\n    {\n      byte[] val;\n      val = sqlite3_value_blob( columnMem( pStmt, i ) );\n      /* Even though there is no encoding conversion, value_blob() might\n      ** need to call malloc() to expand the result of a zeroblob()\n      ** expression.\n      */\n      columnMallocFailure( pStmt );\n      return val;\n    }\n    static int sqlite3_column_bytes( sqlite3_stmt pStmt, int i )\n    {\n      int val = sqlite3_value_bytes( columnMem( pStmt, i ) );\n      columnMallocFailure( pStmt );\n      return val;\n    }\n    static int sqlite3_column_bytes16( sqlite3_stmt pStmt, int i )\n    {\n      int val = sqlite3_value_bytes16( columnMem( pStmt, i ) );\n      columnMallocFailure( pStmt );\n      return val;\n    }\n    public static double sqlite3_column_double(sqlite3_stmt pStmt, int i)\n    {\n      double val = sqlite3_value_double( columnMem( pStmt, i ) );\n      columnMallocFailure( pStmt );\n      return val;\n    }\n    public static int sqlite3_column_int( sqlite3_stmt pStmt, int i )\n    {\n      int val = sqlite3_value_int( columnMem( pStmt, i ) );\n      columnMallocFailure( pStmt );\n      return val;\n    }\n    public static sqlite_int64 sqlite3_column_int64( sqlite3_stmt pStmt, int i )\n    {\n      sqlite_int64 val = sqlite3_value_int64( columnMem( pStmt, i ) );\n      columnMallocFailure( pStmt );\n      return val;\n    }\n    public static string sqlite3_column_text( sqlite3_stmt pStmt, int i )\n    {\n      string val = sqlite3_value_text( columnMem( pStmt, i ) );\n      columnMallocFailure( pStmt );\n      if ( String.IsNullOrEmpty( val ) ) return null; return val;\n    }\n    static sqlite3_value sqlite3_column_value( sqlite3_stmt pStmt, int i )\n    {\n      Mem pOut = columnMem( pStmt, i );\n      if ( ( pOut.flags & MEM_Static ) != 0 )\n      {\n        pOut.flags = (u16)( pOut.flags & ~MEM_Static );\n        pOut.flags |= MEM_Ephem;\n      }\n      columnMallocFailure( pStmt );\n      return (sqlite3_value)pOut;\n    }\n#if  !SQLITE_OMIT_UTF16\n//const void *sqlite3_column_text16(sqlite3_stmt pStmt, int i){\n//  const void *val = sqlite3_value_text16( columnMem(pStmt,i) );\n//  columnMallocFailure(pStmt);\n//  return val;\n//}\n#endif // * SQLITE_OMIT_UTF16 */\n    public static int sqlite3_column_type( sqlite3_stmt pStmt, int i )\n    {\n      int iType = sqlite3_value_type( columnMem( pStmt, i ) );\n      columnMallocFailure( pStmt );\n      return iType;\n    }\n\n    /* The following function is experimental and subject to change or\n    ** removal */\n    /*int sqlite3_column_numeric_type(sqlite3_stmt pStmt, int i){\n    **  return sqlite3_value_numeric_type( columnMem(pStmt,i) );\n    **}\n    */\n\n    /*\n    ** Convert the N-th element of pStmt.pColName[] into a string using\n    ** xFunc() then return that string.  If N is out of range, return 0.\n    **\n    ** There are up to 5 names for each column.  useType determines which\n    ** name is returned.  Here are the names:\n    **\n    **    0      The column name as it should be displayed for output\n    **    1      The datatype name for the column\n    **    2      The name of the database that the column derives from\n    **    3      The name of the table that the column derives from\n    **    4      The name of the table column that the result column derives from\n    **\n    ** If the result is not a simple column reference (if it is an expression\n    ** or a constant) then useTypes 2, 3, and 4 return NULL.\n    */\n    static string columnName(\n    sqlite3_stmt pStmt,\n    int N,\n    dxColname xFunc,\n    int useType\n    )\n    {\n      string ret = null;\n      Vdbe p = pStmt;\n      int n;\n      sqlite3 db = p.db;\n\n      Debug.Assert( db != null );\n\n      n = sqlite3_column_count( pStmt );\n      if ( N < n && N >= 0 )\n      {\n        N += useType * n;\n        sqlite3_mutex_enter( db.mutex );\n        //Debug.Assert( db.mallocFailed == 0 );\n        ret = xFunc( p.aColName[N] );\n\n        /* A malloc may have failed inside of the xFunc() call. If this\n        ** is the case, clear the mallocFailed flag and return NULL.\n        */\n        //if ( db.mallocFailed != 0 )\n        //{\n        //  //db.mallocFailed = 0;\n        //  ret = null;\n        //}\n        sqlite3_mutex_leave( db.mutex );\n      }\n      return ret;\n    }\n\n    /*\n    ** Return the name of the Nth column of the result set returned by SQL\n    ** statement pStmt.\n    */\n    public static string sqlite3_column_name( sqlite3_stmt pStmt, int N )\n    {\n      return columnName(\n      pStmt, N, sqlite3_value_text, COLNAME_NAME );\n    }\n#if  !SQLITE_OMIT_UTF16\npublic static string sqlite3_column_name16(sqlite3_stmt pStmt, int N){\nreturn columnName(\npStmt, N,  sqlite3_value_text16, COLNAME_NAME);\n}\n#endif\n\n    /*\n** Constraint:  If you have ENABLE_COLUMN_METADATA then you must\n** not define OMIT_DECLTYPE.\n*/\n#if SQLITE_OMIT_DECLTYPE && SQLITE_ENABLE_COLUMN_METADATA\n# error "Must not define both SQLITE_OMIT_DECLTYPE and SQLITE_ENABLE_COLUMN_METADATA"\n#endif\n\n#if !SQLITE_OMIT_DECLTYPE\n    /*\n** Return the column declaration type (if applicable) of the \'i\'th column\n** of the result set of SQL statement pStmt.\n*/\n    public static string sqlite3_column_decltype( sqlite3_stmt pStmt, int N )\n    {\n      return columnName(\n      pStmt, N, sqlite3_value_text, COLNAME_DECLTYPE );\n    }\n#if  !SQLITE_OMIT_UTF16\n//const void *sqlite3_column_decltype16(sqlite3_stmt pStmt, int N){\n//  return columnName(\n//      pStmt, N, (const void*(*)(Mem*))sqlite3_value_text16, COLNAME_DECLTYPE);\n//}\n#endif // * SQLITE_OMIT_UTF16 */\n#endif // * SQLITE_OMIT_DECLTYPE */\n\n#if  SQLITE_ENABLE_COLUMN_METADATA\n\n/*\n** Return the name of the database from which a result column derives.\n** NULL is returned if the result column is an expression or constant or\n** anything else which is not an unabiguous reference to a database column.\n*/\nstatic byte[] sqlite3_column_database_name(sqlite3_stmt pStmt, int N){\nreturn columnName(\npStmt, N, sqlite3_value_text, COLNAME_DATABASE);\n}\n#if !SQLITE_OMIT_UTF16\nconst void *sqlite3_column_database_name16(sqlite3_stmt pStmt, int N){\nreturn columnName(\npStmt, N, (const void*(*)(Mem*))sqlite3_value_text16, COLNAME_DATABASE);\n}\n#endif //* SQLITE_OMIT_UTF16 */\n\n/*\n** Return the name of the table from which a result column derives.\n** NULL is returned if the result column is an expression or constant or\n** anything else which is not an unabiguous reference to a database column.\n*/\nstatic byte[] qlite3_column_table_name(sqlite3_stmt pStmt, int N){\nreturn columnName(\npStmt, N, sqlite3_value_text, COLNAME_TABLE);\n}\n#if !SQLITE_OMIT_UTF16\nconst void *sqlite3_column_table_name16(sqlite3_stmt pStmt, int N){\nreturn columnName(\npStmt, N, (const void*(*)(Mem*))sqlite3_value_text16, COLNAME_TABLE);\n}\n#endif //* SQLITE_OMIT_UTF16 */\n\n/*\n** Return the name of the table column from which a result column derives.\n** NULL is returned if the result column is an expression or constant or\n** anything else which is not an unabiguous reference to a database column.\n*/\nstatic byte[] sqlite3_column_origin_name(sqlite3_stmt pStmt, int N){\nreturn columnName(\npStmt, N, sqlite3_value_text, COLNAME_COLUMN);\n}\n#if !SQLITE_OMIT_UTF16\nconst void *sqlite3_column_origin_name16(sqlite3_stmt pStmt, int N){\nreturn columnName(\npStmt, N, (const void*(*)(Mem*))sqlite3_value_text16, COLNAME_COLUMN);\n}\n#endif ///* SQLITE_OMIT_UTF16 */\n#endif // * SQLITE_ENABLE_COLUMN_METADATA */\n\n\n    /******************************* sqlite3_bind_  ***************************\n**\n** Routines used to attach values to wildcards in a compiled SQL statement.\n*/\n    /*\n    ** Unbind the value bound to variable i in virtual machine p. This is the\n    ** the same as binding a NULL value to the column. If the "i" parameter is\n    ** out of range, then SQLITE_RANGE is returned. Othewise SQLITE_OK.\n    **\n    ** A successful evaluation of this routine acquires the mutex on p.\n    ** the mutex is released if any kind of error occurs.\n    **\n    ** The error code stored in database p.db is overwritten with the return\n    ** value in any case.\n    */\n    static int vdbeUnbind( Vdbe p, int i )\n    {\n      Mem pVar;\n      if ( p == null ) return SQLITE_MISUSE;\n      sqlite3_mutex_enter( p.db.mutex );\n      if ( p.magic != VDBE_MAGIC_RUN || p.pc >= 0 )\n      {\n        sqlite3Error( p.db, SQLITE_MISUSE, 0 );\n        sqlite3_mutex_leave( p.db.mutex );\n        return SQLITE_MISUSE;\n      }\n      if ( i < 1 || i > p.nVar )\n      {\n        sqlite3Error( p.db, SQLITE_RANGE, 0 );\n        sqlite3_mutex_leave( p.db.mutex );\n        return SQLITE_RANGE;\n      }\n      i--;\n      pVar = p.aVar[i];\n      sqlite3VdbeMemRelease( pVar );\n      pVar.flags = MEM_Null;\n      sqlite3Error( p.db, SQLITE_OK, 0 );\n      return SQLITE_OK;\n    }\n\n    /*\n    ** Bind a text or BLOB value.\n    */\n    static int bindText(\n    sqlite3_stmt pStmt,   /* The statement to bind against */\n    int i,                /* Index of the parameter to bind */\n    string zData,         /* Pointer to the data to be bound */\n    int nData,            /* Number of bytes of data to be bound */\n    dxDel xDel,           /* Destructor for the data */\n    u8 encoding          /* Encoding for the data */\n    )\n    {\n      Vdbe p = pStmt;\n      Mem pVar;\n      int rc;\n\n      rc = vdbeUnbind( p, i );\n      if ( rc == SQLITE_OK )\n      {\n        if ( zData != null )\n        {\n          pVar = p.aVar[i - 1];\n          rc = sqlite3VdbeMemSetStr( pVar, zData, nData, encoding, xDel );\n          if ( rc == SQLITE_OK && encoding != 0 )\n          {\n            rc = sqlite3VdbeChangeEncoding( pVar, ENC( p.db ) );\n          }\n          sqlite3Error( p.db, rc, 0 );\n          rc = sqlite3ApiExit( p.db, rc );\n        }\n        sqlite3_mutex_leave( p.db.mutex );\n      }\n      return rc;\n    }\n\n\n    /*\n    ** Bind a blob value to an SQL statement variable.\n    */\n    public static int sqlite3_bind_blob(\n    sqlite3_stmt pStmt,\n    int i,\n    string zData,\n    int nData,\n    dxDel xDel\n    )\n    {\n      return bindText( pStmt, i, zData, nData, xDel, 0 );\n    }\n\n    public static int sqlite3_bind_double( sqlite3_stmt pStmt, int i, double rValue )\n    {\n      int rc;\n      Vdbe p = pStmt;\n      rc = vdbeUnbind( p, i );\n      if ( rc == SQLITE_OK )\n      {\n        sqlite3VdbeMemSetDouble( p.aVar[i - 1], rValue );\n        sqlite3_mutex_leave( p.db.mutex );\n      }\n      return rc;\n    }\n\n    public static int sqlite3_bind_int( sqlite3_stmt p, int i, int iValue )\n    {\n      return sqlite3_bind_int64( p, i, (i64)iValue );\n    }\n\n    public static int sqlite3_bind_int64( sqlite3_stmt pStmt, int i, sqlite_int64 iValue )\n    {\n      int rc;\n      Vdbe p = pStmt;\n      rc = vdbeUnbind( p, i );\n      if ( rc == SQLITE_OK )\n      {\n        sqlite3VdbeMemSetInt64( p.aVar[i - 1], iValue );\n        sqlite3_mutex_leave( p.db.mutex );\n      }\n      return rc;\n    }\n    public static int sqlite3_bind_null( sqlite3_stmt pStmt, int i )\n    {\n      int rc;\n      Vdbe p = (Vdbe)pStmt;\n      rc = vdbeUnbind( p, i );\n      if ( rc == SQLITE_OK )\n      {\n        sqlite3_mutex_leave( p.db.mutex );\n      } return rc;\n    }\n\n    public static int sqlite3_bind_text(\n    sqlite3_stmt pStmt,\n    int i,\n    string zData,\n    int nData,\n    dxDel xDel\n    )\n    {\n      return bindText( pStmt, i, zData, nData, xDel, SQLITE_UTF8 );\n    }\n#if  !SQLITE_OMIT_UTF16\nstatic int sqlite3_bind_text16(\nsqlite3_stmt pStmt,\nint i,\nstring zData,\nint nData,\ndxDel xDel\n){\nreturn bindText(pStmt, i, zData, nData, xDel, SQLITE_UTF16NATIVE);\n}\n#endif // * SQLITE_OMIT_UTF16 */\n    static int sqlite3_bind_value( sqlite3_stmt pStmt, int i, sqlite3_value pValue )\n    {\n      int rc;\n      switch ( pValue.type )\n      {\n        case SQLITE_INTEGER:\n          {\n            rc = sqlite3_bind_int64( pStmt, i, pValue.u.i );\n            break;\n          }\n        case SQLITE_FLOAT:\n          {\n            rc = sqlite3_bind_double( pStmt, i, pValue.r );\n            break;\n          }\n        case SQLITE_BLOB:\n          {\n            if ( ( pValue.flags & MEM_Zero ) != 0 )\n            {\n              rc = sqlite3_bind_zeroblob( pStmt, i, pValue.u.nZero );\n            }\n            else\n            {\n              rc = sqlite3_bind_blob( pStmt, i, pValue.z, pValue.n, SQLITE_TRANSIENT );\n            }\n            break;\n          }\n        case SQLITE_TEXT:\n          {\n            rc = bindText( pStmt, i, pValue.z, pValue.n, SQLITE_TRANSIENT,\n                      pValue.enc );\n            break;\n          }\n        default:\n          {\n            rc = sqlite3_bind_null( pStmt, i );\n            break;\n          }\n      }\n      return rc;\n    }\n\n    static int sqlite3_bind_zeroblob( sqlite3_stmt pStmt, int i, int n )\n    {\n      int rc;\n      Vdbe p = pStmt;\n      rc = vdbeUnbind( p, i );\n      if ( rc == SQLITE_OK )\n      {\n        sqlite3VdbeMemSetZeroBlob( p.aVar[i - 1], n );\n        sqlite3_mutex_leave( p.db.mutex );\n      }\n      return rc;\n    }\n\n    /*\n    ** Return the number of wildcards that can be potentially bound to.\n    ** This routine is added to support DBD::SQLite.\n    */\n    static int sqlite3_bind_parameter_count( sqlite3_stmt pStmt )\n    {\n      Vdbe p = (Vdbe)pStmt;\n      return ( p != null ) ? (int)p.nVar : 0;\n    }\n\n    /*\n    ** Create a mapping from variable numbers to variable names\n    ** in the Vdbe.azVar[] array, if such a mapping does not already\n    ** exist.\n    */\n    static void createVarMap( Vdbe p )\n    {\n      if ( 0 == p.okVar )\n      {\n        int j;\n        Op pOp;\n        sqlite3_mutex_enter( p.db.mutex );\n        /* The race condition here is harmless.  If two threads call this\n        ** routine on the same Vdbe at the same time, they both might end\n        ** up initializing the Vdbe.azVar[] array.  That is a little extra\n        ** work but it results in the same answer.\n        */\n        p.azVar = new string[p.nOp];\n        for ( j = 0 ; j < p.nOp ; j++ )//, pOp++ )\n        {\n          pOp = p.aOp[j];\n          if ( pOp.opcode == OP_Variable )\n          {\n            Debug.Assert( pOp.p1 > 0 && pOp.p1 <= p.nVar );\n            p.azVar[pOp.p1 - 1] = pOp.p4.z != null ? pOp.p4.z : "";\n          }\n        }\n        p.okVar = 1;\n        sqlite3_mutex_leave( p.db.mutex );\n      }\n    }\n\n    /*\n    ** Return the name of a wildcard parameter.  Return NULL if the index\n    ** is out of range or if the wildcard is unnamed.\n    **\n    ** The result is always UTF-8.\n    */\n    static string sqlite3_bind_parameter_name( sqlite3_stmt pStmt, int i )\n    {\n      Vdbe p = (Vdbe)pStmt;\n      if ( p == null || i < 1 || i > p.nVar )\n      {\n        return "";\n      }\n      createVarMap( p );\n      return p.azVar[i - 1];\n    }\n\n    /*\n    ** Given a wildcard parameter name, return the index of the variable\n    ** with that name.  If there is no variable with the given name,\n    ** return 0.\n    */\n    public static int sqlite3_bind_parameter_index( sqlite3_stmt pStmt, string zName )\n    {\n      Vdbe p = (Vdbe)pStmt;\n      int i;\n      if ( p == null )\n      {\n        return 0;\n      }\n      createVarMap( p );\n      if ( zName != null && zName != "" )\n      {\n        for ( i = 0 ; i < p.nVar ; i++ )\n        {\n          string z = p.azVar[i];\n          if ( z != null && z == zName )//&& strcmp(z, zName) == 0)\n          {\n            return i + 1;\n          }\n        }\n      }\n      return 0;\n    }\n\n    /*\n    ** Transfer all bindings from the first statement over to the second.\n    */\n    static int sqlite3TransferBindings( sqlite3_stmt pFromStmt, sqlite3_stmt pToStmt )\n    {\n      Vdbe pFrom = (Vdbe)pFromStmt;\n      Vdbe pTo = (Vdbe)pToStmt;\n      int i;\n      Debug.Assert( pTo.db == pFrom.db );\n      Debug.Assert( pTo.nVar == pFrom.nVar );\n      sqlite3_mutex_enter( pTo.db.mutex );\n      for ( i = 0 ; i < pFrom.nVar ; i++ )\n      {\n        sqlite3VdbeMemMove( pTo.aVar[i], pFrom.aVar[i] );\n      }\n      sqlite3_mutex_leave( pTo.db.mutex );\n      return SQLITE_OK;\n    }\n\n#if !SQLITE_OMIT_DEPRECATED\n    /*\n** Deprecated external interface.  Internal/core SQLite code\n** should call sqlite3TransferBindings.\n**\n** Is is misuse to call this routine with statements from different\n** database connections.  But as this is a deprecated interface, we\n** will not bother to check for that condition.\n**\n** If the two statements contain a different number of bindings, then\n** an SQLITE_ERROR is returned.  Nothing else can go wrong, so otherwise\n** SQLITE_OK is returned.\n*/\n    static int sqlite3_transfer_bindings( sqlite3_stmt pFromStmt, sqlite3_stmt pToStmt )\n    {\n      Vdbe pFrom = (Vdbe)pFromStmt;\n      Vdbe pTo = (Vdbe)pToStmt;\n      if ( pFrom.nVar != pTo.nVar )\n      {\n        return SQLITE_ERROR;\n      }\n      return sqlite3TransferBindings( pFromStmt, pToStmt );\n    }\n#endif\n\n    /*\n** Return the sqlite3* database handle to which the prepared statement given\n** in the argument belongs.  This is the same database handle that was\n** the first argument to the sqlite3_prepare() that was used to create\n** the statement in the first place.\n*/\n    static sqlite3 sqlite3_db_handle( sqlite3_stmt pStmt )\n    {\n      return pStmt != null ? ( (Vdbe)pStmt ).db : null;\n    }\n\n    /*\n    ** Return a pointer to the next prepared statement after pStmt associated\n    ** with database connection pDb.  If pStmt is NULL, return the first\n    ** prepared statement for the database connection.  Return NULL if there\n    ** are no more.\n    */\n    static sqlite3_stmt sqlite3_next_stmt( sqlite3 pDb, sqlite3_stmt pStmt )\n    {\n      sqlite3_stmt pNext;\n      sqlite3_mutex_enter( pDb.mutex );\n      if ( pStmt == null )\n      {\n        pNext = (sqlite3_stmt)pDb.pVdbe;\n      }\n      else\n      {\n        pNext = (sqlite3_stmt)( (Vdbe)pStmt ).pNext;\n      }\n      sqlite3_mutex_leave( pDb.mutex );\n      return pNext;\n    }\n    /*\n    ** Return the value of a status counter for a prepared statement\n    */\n    static int sqlite3_stmt_status( sqlite3_stmt pStmt, int op, int resetFlag )\n    {\n      Vdbe pVdbe = (Vdbe)pStmt;\n      int v = pVdbe.aCounter[op - 1];\n      if ( resetFlag != 0 ) pVdbe.aCounter[op - 1] = 0;\n      return v;\n    }\n  }\n}\n'