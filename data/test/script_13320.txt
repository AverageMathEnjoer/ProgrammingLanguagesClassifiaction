b'/*\n * Copyright 2013 - 2016 Mario Arias\n *\n * Licensed under the Apache License, Version 2.0 (the "License");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * \thttp://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an "AS IS" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.funktionale.playground.ds\n\n/**\n * Created by IntelliJ IDEA.\n * @author Mario Arias\n * Date: 4/05/15\n * Time: 2:37 PM\n */\n\ninterface FList<out T> {\n    companion object {\n        fun sum(ints: FList<Int>): Int {\n            /*return when (ints) {\n                is Nil -> 0\n                is Cons -> ints.head + sum(ints.tail)\n                else -> throw IllegalArgumentException()\n            }*/\n            return foldRight(ints, 0) { x, y ->\n                x + y\n            }\n        }\n\n        fun product(ds: FList<Double>): Double {\n            /*return when (ds) {\n                is Nil -> 1.0\n                is Cons -> if (ds.head == 0.0) 0.0 else ds.head * product(ds.tail)\n                else -> throw IllegalArgumentException()\n            }*/\n            return foldRight(ds, 1.0) { x, y ->\n                x * y\n            }\n        }\n\n        fun <T, R> foldRight(l: FList<T>, z: R, f: (T, R) -> R): R {\n            return when (l) {\n                is Nil -> z\n                is Cons -> f(l.head, foldRight(l.tail, z, f))\n                else -> throw IllegalArgumentException()\n            }\n        }\n\n\n\n        /*fun invoke<T>(vararg members: T): FList<T> {\n            return if (members.isEmpty()) {\n                Nil\n            } else {\n                Cons(members.first(), invoke(*members.drop(1)))\n            }\n        }*/\n    }\n}\n\n\nobject Nil : FList<Nothing>\n\ndata class Cons<out T>(val head: T, val tail: FList<T>) : FList<T>\n\ninterface FTree<out T> {\n    fun size(): Int = when (this) {\n        is Leaf -> 1\n        is Branch -> 1 + left.size() + right.size()\n        else -> throw IllegalStateException()\n    }\n\n    fun depth(): Int = when (this) {\n        is Leaf -> 0\n        is Branch -> 1 + (Math.max(left.depth(), right.depth()))\n        else -> throw IllegalStateException()\n    }\n\n    fun <R> map(f: (T) -> R): FTree<R> = when (this) {\n        is Leaf -> Leaf(f(value))\n        is Branch -> Branch(left.map(f), right.map(f))\n        else -> throw IllegalStateException()\n    }\n\n    fun <R> fold(f: (T) -> R, g: (R, R) -> R): R = when (this) {\n        is Leaf -> f(value)\n        is Branch -> g(left.fold(f, g), right.fold(f, g))\n        else -> throw IllegalStateException()\n    }\n\n    fun sizeViaFold(): Int = fold({ 1 }) { l, f ->\n        1 + l + f\n    }\n\n    fun depthViaFold(): Int = fold({ 0 }) { l, r ->\n        1 + (Math.max(l, r))\n    }\n\n\n    fun <R> mapViaFold(f: (T) -> R): FTree<R> = fold({ Leaf(f(it)) }) { l: FTree<R>, r: FTree<R> ->\n        Branch(l, r)\n    }\n\n\n}\n\nfun FTree<Int>.maximun(): Int = when (this) {\n    is Leaf -> value\n    is Branch -> Math.max(left.maximun(), right.maximun())\n    else -> throw IllegalStateException()\n}\n\nfun FTree<Int>.maximunViaFold(): Int = this.fold({ it }) { l, r ->\n    Math.max(l, r)\n}\n\ndata class Leaf<T>(val value: T) : FTree<T>\ndata class Branch<T>(val left: FTree<T>, val right: FTree<T>) : FTree<T>\n\nopen class Foo\nopen class Bar\n\n\n'