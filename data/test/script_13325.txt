b'    /*\n    *************************************************************************\n    **  $Header$\n    *************************************************************************\n    */\nusing System;\nusing System.Collections.Specialized;\nusing System.Diagnostics;\nusing System.IO;\nusing System.Management;\nusing System.Runtime.InteropServices;\nusing System.Text;\n\nusing i64 = System.Int64;\n\nusing u8 = System.Byte;\nusing u32 = System.UInt32;\nusing u64 = System.UInt64;\nusing time_t = System.Int64;\n\nnamespace CS_SQLite3\n{\n  using sqlite3_value = CSSQLite.Mem;\n  using sqlite_int64 = System.Int64;\n\n  public partial class CSSQLite\n  {\n\n    static int atoi( byte[] inStr )\n    { return atoi( Encoding.UTF8.GetString( inStr ) ); }\n\n    static int atoi( string inStr )\n    {\n      int i;\n      for ( i = 0 ; i < inStr.Length ; i++ )\n      {\n        if ( !sqlite3Isdigit( inStr[i] ) && inStr[i] != \'-\' ) break;\n      }\n      int result = 0;\n\n      return ( Int32.TryParse( inStr.Substring( 0, i ), out result ) ? result : 0 );\n    }\n\n    static void fprintf( TextWriter tw, string zFormat, params object[] ap ) { tw.Write( sqlite3_mprintf( zFormat, ap ) ); }\n    static void printf( string zFormat, params object[] ap ) { Console.Out.Write( sqlite3_mprintf( zFormat, ap ) ); }\n\n\n    //Byte Buffer Testing\n\n    static int memcmp( byte[] bA, byte[] bB, int Limit )\n    {\n      if ( bA.Length < Limit ) return ( bA.Length < bB.Length ) ? -1 : +1;\n      if ( bB.Length < Limit ) return +1;\n      for ( int i = 0 ; i < Limit ; i++ )\n      {\n        if ( bA[i] != bB[i] ) return ( bA[i] < bB[i] ) ? -1 : 1;\n      }\n      return 0;\n    }\n\n    //Byte Buffer  & String Testing\n    static int memcmp( byte[] bA, string B, int Limit )\n    {\n      if ( bA.Length < Limit ) return ( bA.Length < B.Length ) ? -1 : +1;\n      if ( B.Length < Limit ) return +1;\n      for ( int i = 0 ; i < Limit ; i++ )\n      {\n        if ( bA[i] != B[i] ) return ( bA[i] < B[i] ) ? -1 : 1;\n      }\n      return 0;\n    }\n\n    //Byte Buffer  & String Testing\n    static int memcmp( string A, byte[] bB, int Limit )\n    {\n      if ( A.Length < Limit ) return ( A.Length < bB.Length ) ? -1 : +1;\n      if ( bB.Length < Limit ) return +1;\n      for ( int i = 0 ; i < Limit ; i++ )\n      {\n        if ( A[i] != bB[i] ) return ( A[i] < bB[i] ) ? -1 : 1;\n      }\n      return 0;\n    }\n\n    //String with Offset & String Testing\n    static int memcmp( byte[] a, int Offset, byte[] b, int Limit )\n    {\n      if ( a.Length < Offset + Limit ) return ( a.Length - Offset < b.Length ) ? -1 : +1;\n      if ( b.Length < Limit ) return +1;\n      for ( int i = 0 ; i < Limit ; i++ )\n      {\n        if ( a[i + Offset] != b[i] ) return ( a[i + Offset] < b[i] ) ? -1 : 1;\n      }\n      return 0;\n    }\n\n    static int memcmp( string a, int Offset, byte[] b, int Limit )\n    {\n      if ( a.Length < Offset + Limit ) return ( a.Length - Offset < b.Length ) ? -1 : +1;\n      if ( b.Length < Limit ) return +1;\n      for ( int i = 0 ; i < Limit ; i++ )\n      {\n        if ( a[i + Offset] != b[i] ) return ( a[i + Offset] < b[i] ) ? -1 : 1;\n      }\n      return 0;\n    }\n\n    static int memcmp( byte[] a, int Offset, string b, int Limit )\n    {\n      if ( a.Length < Offset + Limit ) return ( a.Length - Offset < b.Length ) ? -1 : +1;\n      if ( b.Length < Limit ) return +1;\n      for ( int i = 0 ; i < Limit ; i++ )\n      {\n        if ( a[i + Offset] != b[i] ) return ( a[i + Offset] < b[i] ) ? -1 : 1;\n      }\n      return 0;\n    }\n\n\n    //String Testing\n    static int memcmp( string A, string B, int Limit )\n    {\n      if ( A.Length < Limit ) return ( A.Length < B.Length ) ? -1 : +1;\n      if ( B.Length < Limit ) return +1;\n      for ( int i = 0 ; i < Limit ; i++ )\n      {\n        if ( A[i] != B[i] ) return ( A[i] < B[i] ) ? -1 : 1;\n      }\n      return 0;\n    }\n\n    // ----------------------------\n    // ** Convertion routines\n    // ----------------------------\n    static string vaFORMAT;\n    static int vaNEXT;\n\n    static void va_start( object[] ap, string zFormat )\n    {\n      vaFORMAT = zFormat;\n      vaNEXT = 0;\n    }\n\n    static object va_arg( object[] ap, string sysType )\n    {\n      vaNEXT += 1;\n      if ( ap == null || ap.Length == 0 )\n        return "";\n      switch ( sysType )\n      {\n        case "double":\n          return Convert.ToDouble( ap[vaNEXT - 1] );\n        case "long":\n        case "long int":\n        case "longlong int":\n        case "i64":\n          if ( ap[vaNEXT - 1].GetType().BaseType.Name == "Object" ) return (i64)( ap[vaNEXT - 1].GetHashCode() ); ;\n          return Convert.ToInt64( ap[vaNEXT - 1] );\n        case "int":\n          if ( Convert.ToInt64( ap[vaNEXT - 1] ) > 0 && ( Convert.ToUInt32( ap[vaNEXT - 1] ) > Int32.MaxValue ) ) return (Int32)( Convert.ToUInt32( ap[vaNEXT - 1] ) - System.UInt32.MaxValue - 1 );\n          else return (Int32)Convert.ToInt32( ap[vaNEXT - 1] );\n        case "SrcList":\n          return (SrcList)ap[vaNEXT - 1];\n        case "char":\n          if ( ap[vaNEXT - 1].GetType().Name == "Int32" && (int)ap[vaNEXT - 1] == 0 )\n          {\n            return (char)\'0\';\n          }\n          else\n          {\n            if ( ap[vaNEXT - 1].GetType().Name == "Int64" )\n              if ( (i64)ap[vaNEXT - 1] == 0 )\n              {\n                return (char)\'0\';\n              }\n              else return (char)( (i64)ap[vaNEXT - 1] );\n            else\n              return (char)ap[vaNEXT - 1];\n          }\n        case "char*":\n        case "string":\n          if ( ap[vaNEXT - 1] == null )\n          {\n            return "NULL";\n          }\n          else\n          {\n            if ( ap[vaNEXT - 1].GetType().Name == "Byte[]" )\n              if ( Encoding.UTF8.GetString( (byte[])ap[vaNEXT - 1] ) == "\\0" )\n                return "";\n              else\n                return Encoding.UTF8.GetString( (byte[])ap[vaNEXT - 1] );\n            else if ( ap[vaNEXT - 1].GetType().Name == "Int32" )\n              return null;\n            else if ( ap[vaNEXT - 1].GetType().Name == "StringBuilder" )\n              return (string)ap[vaNEXT - 1].ToString();\n            else return (string)ap[vaNEXT - 1];\n          }\n        case "byte[]":\n          if ( ap[vaNEXT - 1] == null )\n          {\n            return null;\n          }\n          else\n          {\n            return (byte[])ap[vaNEXT - 1];\n          }\n        case "int[]":\n          if ( ap[vaNEXT - 1] == null )\n          {\n            return "NULL";\n          }\n          else\n          {\n            return (int[])ap[vaNEXT - 1];\n          }\n        case "Token":\n          return (Token)ap[vaNEXT - 1];\n        case "u3216":\n          return Convert.ToUInt16( ap[vaNEXT - 1] );\n        case "u32":\n        case "unsigned int":\n          if ( ap[vaNEXT - 1].GetType().IsClass )\n          {\n            return ap[vaNEXT - 1].GetHashCode();\n          }\n          else\n          {\n            return Convert.ToUInt32( ap[vaNEXT - 1] );\n          }\n        case "u64":\n        case "unsigned long":\n        case "unsigned long int":\n          if ( ap[vaNEXT - 1].GetType().IsClass )\n            return Convert.ToUInt64( ap[vaNEXT - 1].GetHashCode() );\n          else\n            return Convert.ToUInt64( ap[vaNEXT - 1] );\n        case "sqlite3_mem_methods":\n          return (sqlite3_mem_methods)ap[vaNEXT - 1];\n        case "void_function":\n          return (void_function)ap[vaNEXT - 1];\n        case "MemPage":\n          return (MemPage)ap[vaNEXT - 1];\n        default:\n          Debugger.Break();\n          return ap[vaNEXT - 1];\n      }\n    }\n    static void va_end( object[] ap )\n    {\n      ap = null;\n      vaFORMAT = "";\n    }\n\n\n    public static tm localtime( time_t baseTime )\n    {\n      System.DateTime RefTime = new System.DateTime( 1970, 1, 1, 0, 0, 0, 0 );\n      RefTime = RefTime.AddSeconds( Convert.ToDouble( baseTime ) ).ToLocalTime();\n      tm tm = new tm();\n      tm.tm_sec = RefTime.Second;\n      tm.tm_min = RefTime.Minute;\n      tm.tm_hour = RefTime.Hour;\n      tm.tm_mday = RefTime.Day;\n      tm.tm_mon = RefTime.Month;\n      tm.tm_year = RefTime.Year;\n      tm.tm_wday = (int)RefTime.DayOfWeek;\n      tm.tm_yday = RefTime.DayOfYear;\n      tm.tm_isdst = RefTime.IsDaylightSavingTime() ? 1 : 0;\n      return tm;\n    }\n\n    public static long ToUnixtime( System.DateTime date )\n    {\n      System.DateTime unixStartTime = new System.DateTime( 1970, 1, 1, 0, 0, 0, 0 );\n      System.TimeSpan timeSpan = date - unixStartTime;\n      return Convert.ToInt64( timeSpan.TotalSeconds );\n    }\n\n    public static System.DateTime ToCSharpTime( long unixTime )\n    {\n      System.DateTime unixStartTime = new System.DateTime( 1970, 1, 1, 0, 0, 0, 0 );\n      return unixStartTime.AddSeconds( Convert.ToDouble( unixTime ) );\n    }\n\n    public struct tm\n    {\n      public int tm_sec;     /* seconds after the minute - [0,59] */\n      public int tm_min;     /* minutes after the hour - [0,59] */\n      public int tm_hour;    /* hours since midnight - [0,23] */\n      public int tm_mday;    /* day of the month - [1,31] */\n      public int tm_mon;     /* months since January - [0,11] */\n      public int tm_year;    /* years since 1900 */\n      public int tm_wday;    /* days since Sunday - [0,6] */\n      public int tm_yday;    /* days since January 1 - [0,365] */\n      public int tm_isdst;   /* daylight savings time flag */\n    };\n\n    public struct FILETIME\n    {\n      public u32 dwLowDateTime;\n      public u32 dwHighDateTime;\n    }\n\n    // Example (C#)\n    public static int GetbytesPerSector( StringBuilder diskPath )\n    {\n      ManagementObjectSearcher mosLogicalDisks = new ManagementObjectSearcher( "select * from Win32_LogicalDisk where DeviceID = \'" + diskPath.ToString().Remove( diskPath.Length - 1, 1 ) + "\'");\n      try\n      {\n        foreach ( ManagementObject moLogDisk in mosLogicalDisks.Get() )\n        {\n          ManagementObjectSearcher mosDiskDrives = new ManagementObjectSearcher( "select * from Win32_DiskDrive where SystemName = \'" + moLogDisk["SystemName"] + "\'" );\n          foreach ( ManagementObject moPDisk in mosDiskDrives.Get() )\n          {\n            return int.Parse( moPDisk["BytesPerSector"].ToString() );\n          }\n        }\n      }\n      catch { }\n      return 0;\n    }\n    \n    [DllImport( "kernel32.dll" )]\n    public static extern bool GetSystemTimeAsFileTime( ref FILETIME sysfiletime );\n\n    static void SWAP<T>( ref T A, ref T B ) { T t = A; A = B; B = t; }\n\n    static void x_CountStep(\n    sqlite3_context context,\n    int argc,\n    sqlite3_value[] argv\n    )\n    {\n      SumCtx p;\n\n      int type;\n      Debug.Assert( argc <= 1 );\n      Mem pMem = sqlite3_aggregate_context( context, -1 );//sizeof(*p));\n      if ( pMem._SumCtx == null ) pMem._SumCtx = new SumCtx();\n      p = pMem._SumCtx;\n      if ( p.Context == null ) p.Context = pMem;\n      if ( argc == 0 || SQLITE_NULL == sqlite3_value_type( argv[0] ) )\n      {\n        p.cnt++;\n        p.iSum += 1;\n      }\n      else\n      {\n        type = sqlite3_value_numeric_type( argv[0] );\n        if ( p != null && type != SQLITE_NULL )\n        {\n          p.cnt++;\n          if ( type == SQLITE_INTEGER )\n          {\n            i64 v = sqlite3_value_int64( argv[0] );\n            if ( v == 40 || v == 41 )\n            {\n              sqlite3_result_error( context, "value of " + v + " handed to x_count", -1 );\n              return;\n            }\n            else\n            {\n              p.iSum += v;\n              if ( !( p.approx | p.overflow != 0 ) )\n              {\n                i64 iNewSum = p.iSum + v;\n                int s1 = (int)( p.iSum >> ( sizeof( i64 ) * 8 - 1 ) );\n                int s2 = (int)( v >> ( sizeof( i64 ) * 8 - 1 ) );\n                int s3 = (int)( iNewSum >> ( sizeof( i64 ) * 8 - 1 ) );\n                p.overflow = ( ( s1 & s2 & ~s3 ) | ( ~s1 & ~s2 & s3 ) ) != 0 ? 1 : 0;\n                p.iSum = iNewSum;\n              }\n            }\n          }\n          else\n          {\n            p.rSum += sqlite3_value_double( argv[0] );\n            p.approx = true;\n          }\n        }\n      }\n    }\n    static void x_CountFinalize( sqlite3_context context )\n    {\n      SumCtx p;\n      Mem pMem = sqlite3_aggregate_context( context, 0 );\n      p = pMem._SumCtx;\n      if ( p != null && p.cnt > 0 )\n      {\n        if ( p.overflow != 0 )\n        {\n          sqlite3_result_error( context, "integer overflow", -1 );\n        }\n        else if ( p.approx )\n        {\n          sqlite3_result_double( context, p.rSum );\n        }\n        else if ( p.iSum == 42 )\n        {\n          sqlite3_result_error( context, "x_count totals to 42", -1 );\n        }\n        else\n        {\n          sqlite3_result_int64( context, p.iSum );\n        }\n      }\n    }\n#if SQLITE_MUTEX_W32\n//---------------------WIN32 Definitions\nstatic int GetCurrentThreadId()\n{\nreturn Thread.CurrentThread.ManagedThreadId;\n}\nstatic long InterlockedIncrement(long location)\n{\nInterlocked.Increment(ref  location);\nreturn location;\n}\n\nstatic void EnterCriticalSection(Mutex mtx)\n{\nMonitor.Enter(mtx);\n}\nstatic void InitializeCriticalSection(Mutex mtx)\n{\nMonitor.Enter(mtx);\n}\nstatic void DeleteCriticalSection(Mutex mtx)\n{\nMonitor.Exit(mtx);\n}\nstatic void LeaveCriticalSection(Mutex mtx)\n{\nMonitor.Exit(mtx);\n}\n\n}\n#endif\n  }\n}\n'