b'{-# LANGUAGE\n    CPP\n  , GADTs\n  , KindSignatures\n  , NoImplicitPrelude\n  #-}\n#if MIN_VERSION_base(4,9,0)\n{-# OPTIONS_GHC -Wno-redundant-constraints #-}\n#endif\n-- | This module allows you to combine \'Resource\'s into an \'Api\'. This\n-- can then be served using \'rest-happstack\' or \'rest-snap\', or used\n-- to generate clients or documentation using \'rest-gen\'.\nmodule Rest.Api\n  ( -- * Api data types.\n    Api (..)\n  , VersionSet\n  , Router (..)\n  , Some1 (..)\n\n    -- * Defining routes.\n  , route\n  , compose\n  , (     -/)\n  , (    --/)\n  , (   ---/)\n  , (  ----/)\n  , ( -----/)\n  , (------/)\n  , root\n\n    -- * Api versioning.\n  , Version (..)\n  , mkVersion\n  , latest\n  , parseVersion\n  , lookupVersion\n  , lookupVersion\'\n  , withVersion\n  ) where\n\nimport Prelude.Compat\n\nimport Data.Char\nimport Data.Function (on)\nimport Data.List (sortBy)\nimport Data.List.Split\nimport Data.Ord (comparing)\n\nimport Rest.Resource\nimport Rest.Schema (named, singleton)\n\n\nimport Safe\n\n-------------------------------------------------------------------------------\n-- A routing table of REST resources.\n\n-- | An existential where the second argument has kind @(* -> *)@.\n\ndata Some1 f where Some1 :: f (a :: * -> *) -> Some1 f\n\n-- | A \'Router\' is a \'Resource\' and a list of subresources.\n\ndata Router m s where\n  Embed :: Resource m s sid mid aid -> [Some1 (Router s)] -> Router m s\n\n-- | Convenience constructor constructing a route without any\n-- subresource.\n\nroute :: Monad s => Resource m s sid mid aid -> Router m s\nroute = flip Embed []\n\n-- | Add the second router as a subresource to the first.\n\ncompose :: Router m s -> Router s t -> Router m s\ncompose (Embed r xs) b = Embed r (xs ++ [Some1 b])\n\ninfixl 4 -/\ninfixl 5 --/\ninfixl 6 ---/\ninfixl 7 ----/\ninfixl 8 -----/\ninfixl 9 ------/\n\n-- | Operators with the right fixities to allow you to define routes\n-- without using parentheses. Start with the shortest near the root.\n\n(-/), (--/), (---/), (----/), (-----/), (------/) :: Router m s -> Router s t -> Router m s\n\n(     -/) = compose\n(    --/) = compose\n(   ---/) = compose\n(  ----/) = compose\n( -----/) = compose\n(------/) = compose\n\n-- | An empty router to use as the root for your API.\n\nroot :: (Applicative m, Monad m) => Router m m\nroot = route $ mkResourceId { schema = singleton () $ named [] }\n\n-------------------------------------------------------------------------------\n\n-- | An API version has three parts. The first is two are used for API\n-- breaking changes, the last for non-API breaking changes.\n\ndata Version = Version\n  { full  :: Int\n  , major :: Int\n  , minor :: Maybe Int\n  } deriving (Eq, Ord)\n\n-- | Smart constructor for \'Version\'.\n\nmkVersion :: Int -> Int -> Int -> Version\nmkVersion f m l = Version f m (Just l)\n\ninstance Show Version where\n  show v = show (full v) ++ "." ++ show (major v) ++ maybe "" (\\x -> "." ++ show x) (minor v)\n\n-- | A version set is a list of versioned routers.\n\ntype VersionSet m = [(Version, Some1 (Router m))]\n\n-- | An API can be versioned or unversioned.\n-- A versioned API is a set of versioned routers.\n-- An unversioned API is just a single router.\n\ndata Api m where\n    Unversioned :: Some1 (Router m) -> Api m\n    Versioned   :: VersionSet m -> Api m\n\n-- | Get the latest version of an API.\n\nlatest :: VersionSet m -> Maybe (Version, Some1 (Router m))\nlatest = headMay . sortBy (flip compare `on` fst)\n\n-- | Parse a \'String\' as a \'Version\'. The string should contain two or\n-- three numbers separated by dots, e.g. @1.12.3@.\n\nparseVersion :: String -> Maybe Version\nparseVersion s =\n  case map readMay . splitOn "." . filter (\\c -> isDigit c || c == \'.\') $ s of\n    [ Just a, Just b, Just c ] -> Just (Version a b (Just c))\n    [ Just a, Just b         ] -> Just (Version a b Nothing)\n    _                          -> Nothing\n\n-- | Look up a version in an API. The string can either be a valid\n-- version according to \'parseVersion\', or "latest".\n\nlookupVersion :: String -> VersionSet m -> Maybe (Some1 (Router m))\nlookupVersion "latest" = fmap snd . latest\nlookupVersion str      = (parseVersion str >>=) . flip lookupVersion\'\n\n-- | Look up a version in the API.\n\nlookupVersion\' :: Version -> VersionSet m -> Maybe (Some1 (Router m))\nlookupVersion\' v versions = best (filter (matches v . fst) versions)\n  where best = fmap snd . headMay . sortBy (flip (comparing fst))\n        matches :: Version -> Version -> Bool\n        matches (Version a b c) (Version x y z)\n          | a == x && b == y && c <= z = True\n          | otherwise                  = False\n\n-- | Given a version string, an API and a fallback, do the following:\n--\n-- * Parse the version number or "latest".\n--\n-- * Look up this version.\n--\n-- * If ok, run the given function on it.\n--\n-- * If not parsed or found, return the fallback.\n\nwithVersion :: String -> Api m -> r -> (Version -> Some1 (Router m) -> r) -> r\nwithVersion ver (Versioned vrs) err ok =\n  maybe err (uncurry ok) $\n    case ver of\n      "latest" -> latest vrs\n      _        -> do pv <- parseVersion ver\n                     r <- lookupVersion\' pv vrs\n                     return (pv, r)\nwithVersion ver (Unversioned r) err ok =\n  maybe err (uncurry ok) $\n    case ver of\n      "latest" -> return (mkVersion 1 0 0, r)\n      _        -> Nothing\n'