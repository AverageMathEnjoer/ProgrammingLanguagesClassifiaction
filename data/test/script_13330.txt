b'module Network.Server.Common.Line where\n\nimport Data.Char(isSpace, toLower)\nimport Data.Function(on)\nimport Control.Monad.Trans(MonadIO(..))\nimport Control.Exception(IOException)\n\n-- |\n--\n-- >>> trimPrefixThen "ABC" "AB"\n-- Nothing\n--\n-- >>> trimPrefixThen "ABC" "ABC"\n-- Just ""\n--\n-- >>> trimPrefixThen "ABC" "ABCDEF"\n-- Just "DEF"\n--\n-- >>> trimPrefixThen "ABC" "Ab"\n-- Nothing\n--\n-- >>> trimPrefixThen "ABC" "Abc"\n-- Just ""\n--\n-- >>> trimPrefixThen "ABC" "Abcdef"\n-- Just "def"\n--\n-- >>> trimPrefixThen "ABC" "Abcdef   ghi  "\n-- Just "def   ghi"\ntrimPrefixThen ::\n  String\n  -> String\n  -> Maybe String\ntrimPrefixThen l z =\n  fmap (reverse . dropWhile isSpace . reverse . dropWhile isSpace) (prefixThen ((==) `on` toLower) l z)\n\n-- |\n--\n-- >>> prefixThen (==) "ABC" "AB"\n-- Nothing\n--\n-- >>> prefixThen (==) "ABC" "ABC"\n-- Just ""\n--\n-- >>> prefixThen (==) "ABC" "ABCDEF"\n-- Just "DEF"\nprefixThen ::\n  (a -> a -> Bool)\n  -> [a]\n  -> [a]\n  -> Maybe [a]\nprefixThen _ [] r =\n  Just r\nprefixThen _ _ [] =\n  Nothing\nprefixThen e (a:b) (c:d) =\n  if e a c\n    then\n      prefixThen e b d\n    else\n      Nothing\n\nxprint ::\n  MonadIO m =>\n  IOException\n  -> m ()\nxprint =\n  liftIO . print\n'