b'class UnionFind{\n\t//1-based indexing\n\tint n, m;\n\tint *p, *z;\n\tpublic:\n\t\tUnionFind(int no){\n\t\t\tn = no;\n\t\t\tp = new int[n+10];\n\t\t\tz = new int[n+10];\n\t\t\tint i;\n\t\t\tFo(i, 1, n+1) \n\t\t\t\tp[i] = i, z[i] = 0;\n\t\t}\n\t\t//Returns 1 if u and v are in different regions\n\t\t//0 otherwise\n\t\tbool addEdge(int u, int v){\n\t\t\tu = get(u);\n\t\t\tv = get(v);\n\t\t\tif (u == v) return 0;\n\t\t\tif (z[u] < z[v]) p[u] = v;\n\t\t\telse if (z[u] > z[v]) p[v] = u;\n\t\t\telse p[u] = v, z[v]++;\n\t\t\treturn 1;\n\t\t}\n\t\t\n\t\tint get(int v){\n\t\t\tif (v == p[v]) return v;\n\t\t\treturn p[v] = get(p[v]);\n\t\t}\n\t\tint com(){\n\t\t\tint i;\n\t\t\tint ans = 0;\n\t\t\tFo(i, 1, n+1) ans += p[i] == i;\n\t\t\treturn ans;\n\t\t}\n};\n'