b'\xef\xbb\xbf// UVa753 A Plug for UNIX\n// Rujia Liu\n// \xe7\xae\x97\xe6\xb3\x95\xe4\xba\x8c\xef\xbc\x9a\xe7\x9b\xb4\xe6\x8e\xa5\xe6\x9e\x84\xe5\x9b\xbe\n#include<iostream>\n#include<map>\n#include<string>\n#include<vector>\n#include<cstring>\n#include<queue>\nusing namespace std;\n\nvector<string> names;\nint ID(const string& s) {\n  for(int i = 0; i < names.size(); i++)\n    if(names[i] == s) return i;\n  names.push_back(s);\n  return names.size() - 1;\n}\n\nconst int maxn = 400 + 5; \n\nint n, m, k;       // \xe6\x8f\x92\xe5\xba\xa7\xe4\xb8\xaa\xe6\x95\xb0\xef\xbc\x8c\xe8\xae\xbe\xe5\xa4\x87\xe4\xb8\xaa\xe6\x95\xb0\xef\xbc\x8c\xe8\xbd\xac\xe6\x8d\xa2\xe5\x99\xa8\xe4\xb8\xaa\xe6\x95\xb0\nint target[maxn];  // \xe5\x90\x84\xe4\xb8\xaa\xe6\x8f\x92\xe5\xba\xa7\xe7\x9a\x84\xe7\xb1\xbb\xe5\x9e\x8b\nint device[maxn];  // \xe5\x90\x84\xe4\xb8\xaa\xe8\xae\xbe\xe5\xa4\x87\xe7\x9a\x84\xe7\xb1\xbb\xe5\x9e\x8b\nint from[maxn], to[maxn]; // \xe5\x90\x84\xe4\xb8\xaa\xe8\xbd\xac\xe6\x8d\xa2\xe5\x99\xa8\n\nconst int INF = 1000000000;\n\nstruct Edge {\n  int from, to, cap, flow;\n  Edge(int u, int v, int c, int f):from(u),to(v),cap(c),flow(f) {}\n};\n\nstruct EdmondsKarp {\n  int n, m;\n  vector<Edge> edges;    // \xe8\xbe\xb9\xe6\x95\xb0\xe7\x9a\x84\xe4\xb8\xa4\xe5\x80\x8d\n  vector<int> G[maxn];   // \xe9\x82\xbb\xe6\x8e\xa5\xe8\xa1\xa8\xef\xbc\x8cG[i][j]\xe8\xa1\xa8\xe7\xa4\xba\xe7\xbb\x93\xe7\x82\xb9i\xe7\x9a\x84\xe7\xac\xacj\xe6\x9d\xa1\xe8\xbe\xb9\xe5\x9c\xa8e\xe6\x95\xb0\xe7\xbb\x84\xe4\xb8\xad\xe7\x9a\x84\xe5\xba\x8f\xe5\x8f\xb7\n  int a[maxn];           // \xe5\xbd\x93\xe8\xb5\xb7\xe7\x82\xb9\xe5\x88\xb0i\xe7\x9a\x84\xe5\x8f\xaf\xe6\x94\xb9\xe8\xbf\x9b\xe9\x87\x8f\n  int p[maxn];           // \xe6\x9c\x80\xe7\x9f\xad\xe8\xb7\xaf\xe6\xa0\x91\xe4\xb8\x8ap\xe7\x9a\x84\xe5\x85\xa5\xe5\xbc\xa7\xe7\xbc\x96\xe5\x8f\xb7\n\n  void init(int n) {\n    for(int i = 0; i < n; i++) G[i].clear();\n    edges.clear();\n  }\n\n  void AddEdge(int from, int to, int cap) {\n    edges.push_back(Edge(from, to, cap, 0));\n    edges.push_back(Edge(to, from, 0, 0));\n    m = edges.size();\n    G[from].push_back(m-2);\n    G[to].push_back(m-1);\n  }\n\n  int Maxflow(int s, int t) {\n    int flow = 0;\n    for(;;) {\n      memset(a, 0, sizeof(a));\n      queue<int> Q;\n      Q.push(s);\n      a[s] = INF;\n      while(!Q.empty()) {\n        int x = Q.front(); Q.pop();\n        for(int i = 0; i < G[x].size(); i++) {\n          Edge& e = edges[G[x][i]];\n          if(!a[e.to] && e.cap > e.flow) {\n            p[e.to] = G[x][i];\n            a[e.to] = min(a[x], e.cap-e.flow);\n            Q.push(e.to);\n          }\n        }\n        if(a[t]) break;\n      }\n      if(!a[t]) break;\n      for(int u = t; u != s; u = edges[p[u]].from) {\n        edges[p[u]].flow += a[t];\n        edges[p[u]^1].flow -= a[t];\n      }\n      flow += a[t];\n    }\n    return flow;\n  }\n};\n\nEdmondsKarp g;\n\nint main() {\n  int T;\n  cin >> T;\n  while(T--) {\n    names.clear();\n    string s1, s2;\n    cin >> n;\n    for(int i = 0; i < n; i++) {\n      cin >> s1;\n      target[i] = ID(s1);\n    }\n    cin >> m;\n    for(int i = 0; i < m; i++) {\n      cin >> s1 >> s2;\n      device[i] = ID(s2);\n    }\n    cin >> k;\n    for(int i = 0; i < k; i++) {\n      cin >> s1 >> s2;\n      from[i] = ID(s1); to[i] = ID(s2);\n    }\n    \n    int V = names.size();\n    g.init(V+2);\n    for(int i = 0; i < m; i++)\n      g.AddEdge(V, device[i], 1); // \xe6\xba\x90\xe7\x82\xb9->\xe8\xae\xbe\xe5\xa4\x87\n    for(int i = 0; i < n; i++)\n      g.AddEdge(target[i], V+1, 1); // \xe6\x8f\x92\xe5\xba\xa7->\xe6\xb1\x87\xe7\x82\xb9\n    for(int i = 0; i < k; i++)\n      g.AddEdge(from[i], to[i], INF); // \xe6\x8f\x92\xe5\xa4\xb4->\xe6\x8f\x92\xe5\xa4\xb4\n    int r = g.Maxflow(V, V+1);\n    cout << m-r << "\\n";\n    if(T) cout << "\\n";\n  }\n  return 0;\n}\n'