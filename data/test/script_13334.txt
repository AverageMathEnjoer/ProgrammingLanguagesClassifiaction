b'-- | Parsing options supplied on the command line\nmodule Test.Tasty.CmdLine\n  ( optionParser\n  , suiteOptions\n  , suiteOptionParser\n  , parseOptions\n  , defaultMainWithIngredients\n  ) where\n\nimport Control.Arrow\nimport Control.Monad\nimport Data.Maybe\nimport Data.Proxy\nimport Data.Typeable (typeRep)\nimport Options.Applicative\nimport Options.Applicative.Common (evalParser)\nimport qualified Options.Applicative.Types as Applicative (Option(..))\nimport Options.Applicative.Types (Parser(..), OptProperties(..))\nimport Prelude  -- Silence AMP and FTP import warnings\nimport System.Exit\nimport System.IO\n#if !MIN_VERSION_base(4,11,0)\nimport Data.Monoid\nimport Data.Foldable (foldMap)\n#endif\n\nimport Test.Tasty.Core\nimport Test.Tasty.Runners.Utils\nimport Test.Tasty.Ingredients\nimport Test.Tasty.Options\nimport Test.Tasty.Options.Env\nimport Test.Tasty.Runners.Reducers\n\n-- | Generate a command line parser from a list of option descriptions,\n-- alongside any related warning messages.\n--\n-- @since 1.3\noptionParser :: [OptionDescription] -> ([String], Parser OptionSet)\noptionParser = second getApp . foldMap toSet where\n  toSet :: OptionDescription -> ([String], Ap Parser OptionSet)\n  toSet (Option p) = second\n    (\\parser -> Ap $ (singleOption <$> parser) <|> pure mempty)\n    (finalizeCLParser p optionCLParser)\n\n-- Do two things:\n--\n-- 1. Replace an `optionCLParser`\'s \'propShowDefault\' with \'showDefaultValue\'\n--    from the \'IsOption\' class.\n-- 2. Generate warning messages if the \'optionCLParser\' does anything\n--    suspicious. Currently, the only suspicious things we check for are\n--    (a) if the \'Parser\' defines multiple options and, (b) if the \'Parser\'\n--    assigns a default value outside of \'defaultValue\'.\nfinalizeCLParser :: forall proxy v . IsOption v\n                 => proxy v -> Parser v -> ([String], Parser v)\nfinalizeCLParser _ p = (warnings, setCLParserShowDefaultValue mbDef p)\n  where\n    mbDef :: Maybe String\n    mbDef = showDefaultValue (defaultValue :: v)\n\n    warnings :: [String]\n    warnings = catMaybes [multipleOptPsWarning, badDefaultWarning]\n\n    -- Warn if a Parser defines multiple options, as this breaks an assumption\n    -- that setCLParserShowDefaultValue relies on.\n    multipleOptPsWarning :: Maybe String\n    multipleOptPsWarning\n      | numOptPs p > 1\n      = Just $ unlines\n        [ prov\n        , "optionCLParser defines multiple options. Consider only defining"\n        , "a single option here, as defining multiple options does not play"\n        , "well with how tasty displays default values."\n        ]\n      | otherwise\n      = Nothing\n\n    -- Warning if a Parser has a default value (outside of IsOption\'s\n    -- defaultValue method, that is), as this interferes with tasty\'s ability\n    -- to read arguments from environment variables. For more on this point,\n    -- see the Haddocks for optionCLParser.\n    badDefaultWarning :: Maybe String\n    badDefaultWarning\n      -- evalParser will only return Just if has a default value declared with\n      -- e.g. the Options.Applicative.value function.\n      | isJust (evalParser p)\n      = Just $ unlines\n        [ prov\n        , "Using default values (e.g., with Options.Applicative.value) in"\n        , "optionCLParser is prohibited, as it interferes with tasty\'s ability"\n        , "to read environment variable options properly. Moreover, assigning"\n        , "default values is unnecessary, as their functionality is subsumed"\n        , "by the defaultValue method of IsOption."\n        ]\n      | otherwise\n      = Nothing\n\n    prov :: String\n    prov = "WARNING (in the IsOption instance for "\n             ++ show (typeRep (Proxy :: Proxy v)) ++ "):"\n\n-- Replace an `optionCLParser`\'s \'propShowDefault\' with \'showDefaultValue\' from\n-- the \'IsOption\' class. It\'s tempting to try doing this when constructing the\n-- \'Parser\' itself using \'optionMod\', but @optparse-applicative@\'s \'mkParser\'\n-- function always overrides the result of \'optionMod\'. Ugh.\nsetCLParserShowDefaultValue :: Maybe String -> Parser a -> Parser a\nsetCLParserShowDefaultValue mbDef = go\n  where\n    go :: Parser a -> Parser a\n    -- Note that we /always/ replace the Option\'s optProps, regardless of\n    -- what type it may have. This can produce unexpected results if an\n    -- optionCLParser defines multiple options, which is why we emit a warning\n    -- (in finalizeCLParser) if a Parser does this.\n    go (OptP o)      = OptP o{Applicative.optProps =\n                              modifyDefault (Applicative.optProps o)}\n    go p@NilP{}      = p\n    go (MultP p1 p2) = MultP (go p1) (go p2)\n    go (AltP  p1 p2) = AltP  (go p1) (go p2)\n    go (BindP p1 p2) = BindP (go p1) (fmap go p2)\n\n    modifyDefault :: OptProperties -> OptProperties\n    modifyDefault op = op{propShowDefault = mbDef}\n\n-- Note: this is a conservative estimate, since we cannot count the number\n-- of OptPs in the continuation argument of BindP. But BindP is really only\n-- used for ParserM purposes, and since ParserM is an internal\n-- optparse-applicative definition, most optionCLParser instances are\n-- unlikely to use it in practice.\nnumOptPs :: Parser a -> Int\nnumOptPs OptP{} = 1\nnumOptPs NilP{} = 0\nnumOptPs (MultP p1  p2) = numOptPs p1 + numOptPs p2\nnumOptPs (AltP  p1  p2) = numOptPs p1 + numOptPs p2\nnumOptPs (BindP p1 _p2) = numOptPs p1\n\n-- | The command line parser for the test suite, alongside any related\n-- warnings.\n--\n-- @since 1.3\nsuiteOptionParser :: [Ingredient] -> TestTree -> ([String], Parser OptionSet)\nsuiteOptionParser ins tree = optionParser $ suiteOptions ins tree\n\n-- | Parse the command-line and environment options passed to tasty.\n--\n-- Useful if you need to get the options before \'Test.Tasty.defaultMain\' is called.\n--\n-- Once within the test tree, \'Test.Tasty.askOption\' should be used instead.\n--\n-- The arguments to this function should be the same as for\n-- \'defaultMainWithIngredients\'. If you don\'t use any custom ingredients,\n-- pass \'Test.Tasty.defaultIngredients\'.\n--\n-- @since 1.2.2\nparseOptions :: [Ingredient] -> TestTree -> IO OptionSet\nparseOptions ins tree = do\n  let (warnings, parser) = suiteOptionParser ins tree\n  mapM_ (hPutStrLn stderr) warnings\n  cmdlineOpts <- execParser $\n    info (helper <*> parser)\n    ( fullDesc <>\n      header "Mmm... tasty test suite"\n    )\n  envOpts <- suiteEnvOptions ins tree\n  return $ envOpts <> cmdlineOpts\n\n-- | Parse the command line arguments and run the tests using the provided\n-- ingredient list.\n--\n-- When the tests finish, this function calls \'System.Exit.exitWith\' with the exit code\n-- that indicates whether any tests have failed. See \'Test.Tasty.defaultMain\' for\n-- details.\n--\n-- @since 0.4\ndefaultMainWithIngredients :: [Ingredient] -> TestTree -> IO ()\ndefaultMainWithIngredients ins testTree = do\n  installSignalHandlers\n  opts <- parseOptions ins testTree\n\n  case tryIngredients ins opts testTree of\n    Nothing -> do\n      hPutStrLn stderr\n        "No ingredients agreed to run. Something is wrong either with your ingredient set or the options."\n      exitFailure\n    Just act -> do\n      ok <- act\n      if ok then exitSuccess else exitFailure\n'