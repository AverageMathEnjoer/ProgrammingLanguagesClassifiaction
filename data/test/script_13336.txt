b'#include "Mesh.h"\n#undef max\n#undef min\n#include "../inc/half.hpp"\n\nfloat HalfFloat::toFloat()\n{\n\treturn half_float::detail::half2float(half);\n}\nvoid Vector2hf::ToVector2f(Vector2f &out)\n{\n\tout.x = x.toFloat();\n\tout.y = y.toFloat();\n}\nvoid Vector3hf::ToVector3f(Vector3f &out)\n{\n\tout.x = x.toFloat();\n\tout.y = y.toFloat();\n\tout.z = z.toFloat();\n}\nbool Vector3f::Read(AssetTypeValueField *pField)\n{\n\tAssetTypeValueField *pXField = (*pField)["x"];\n\tAssetTypeValueField *pYField = (*pField)["y"];\n\tAssetTypeValueField *pZField = (*pField)["z"];\n\tif (!pXField->IsDummy() && !pYField->IsDummy() && !pZField->IsDummy())\n\t{\n\t\tx = pXField->GetValue()->AsFloat();\n\t\ty = pYField->GetValue()->AsFloat();\n\t\tz = pZField->GetValue()->AsFloat();\n\t\treturn true;\n\t}\n\treturn false;\n}\nbool AABB::Read(AssetTypeValueField *pField)\n{\n\tAssetTypeValueField *pCenterField = (*pField)["m_Center"];\n\tAssetTypeValueField *pExtentField = (*pField)["m_Extent"];\n\tif (!pCenterField->IsDummy() && !pExtentField->IsDummy())\n\t{\n\t\treturn m_Center.Read(pCenterField) && m_Extent.Read(pExtentField);\n\t}\n\treturn false;\n}\nbool MinMaxAABB::Read(AssetTypeValueField *pField)\n{\n\tAssetTypeValueField *pMinField = (*pField)["m_Min"];\n\tAssetTypeValueField *pMaxField = (*pField)["m_Max"];\n\tif (!pMinField->IsDummy() && !pMaxField->IsDummy())\n\t{\n\t\treturn m_Min.Read(pMinField) && m_Max.Read(pMaxField);\n\t}\n\treturn false;\n}\nbool Quaternionf::Read(AssetTypeValueField *pField)\n{\n\tAssetTypeValueField *pXField = (*pField)["x"];\n\tAssetTypeValueField *pYField = (*pField)["y"];\n\tAssetTypeValueField *pZField = (*pField)["z"];\n\tAssetTypeValueField *pWField = (*pField)["w"];\n\tif (!pXField->IsDummy() && !pYField->IsDummy() && !pZField->IsDummy() && !pWField->IsDummy())\n\t{\n\t\tx = pXField->GetValue()->AsFloat();\n\t\ty = pYField->GetValue()->AsFloat();\n\t\tz = pZField->GetValue()->AsFloat();\n\t\tw = pWField->GetValue()->AsFloat();\n\t\treturn true;\n\t}\n\treturn false;\n}\nbool Matrix4x4f::Read(AssetTypeValueField *pField)\n{\n\tif (pField->GetChildrenCount() == 4*4)\n\t{\n\t\tfor (unsigned int i = 0; i < 16; i++)\n\t\t{\n\t\t\tAssetTypeValueField *pNumField = pField->Get(i);\n\t\t\tAssetTypeValue *pValue = pNumField->GetValue();\n\t\t\tif (pValue == NULL || pValue->GetType() != ValueType_Float)\n\t\t\t\treturn false;\n\t\t\te[i >> 2][i & 3]  = pValue->AsFloat();\n\t\t}\n\t\treturn true;\n\t}\n\treturn false;\n}\nbool SubMesh::Read(AssetTypeValueField *pField)\n{\n\tAssetTypeValueField *pFirstByteField = (*pField)["firstByte"];\n\tAssetTypeValueField *pIndexCountField = (*pField)["indexCount"];\n\tAssetTypeValueField *pTopologyField = (*pField)["topology"];\n\tAssetTypeValueField *pBaseVertexField = (*pField)["baseVertex"];\n\tAssetTypeValueField *pFirstVertexField = (*pField)["firstVertex"];\n\tAssetTypeValueField *pVertexCountField = (*pField)["vertexCount"];\n\tAssetTypeValueField *pAABBField = (*pField)["localAABB"];\n\tif (!pFirstByteField->IsDummy() && !pIndexCountField->IsDummy() && !pTopologyField->IsDummy() && !pFirstVertexField->IsDummy()\n\t\t\t&& !pVertexCountField->IsDummy() && !pAABBField->IsDummy())\n\t{\n\t\tfirstByte = pFirstByteField->GetValue()->AsUInt();\n\t\tindexCount = pIndexCountField->GetValue()->AsUInt();\n\t\ttopology = pTopologyField->GetValue()->AsInt();\n\t\tif (!pBaseVertexField->IsDummy())\n\t\t\tbaseVertex = pBaseVertexField->GetValue()->AsUInt();\n\t\telse\n\t\t\tbaseVertex = 0; \n\t\tfirstVertex = pFirstVertexField->GetValue()->AsUInt();\n\t\tvertexCount = pVertexCountField->GetValue()->AsUInt();\n\t\treturn localAABB.Read(pAABBField);\n\t}\n\treturn false;\n}\nbool ChannelInfo::Read(AssetTypeValueField *pField)\n{\n\tAssetTypeValueField *pStreamField = (*pField)["stream"];\n\tAssetTypeValueField *pOffsetField = (*pField)["offset"];\n\tAssetTypeValueField *pFormatField = (*pField)["format"];\n\tAssetTypeValueField *pDimensionField = (*pField)["dimension"];\n\tif (!pStreamField->IsDummy() && !pOffsetField->IsDummy() && !pFormatField->IsDummy() && !pDimensionField->IsDummy())\n\t{\n\t\tstream = (unsigned char)pStreamField->GetValue()->AsUInt();\n\t\toffset = (unsigned char)pOffsetField->GetValue()->AsUInt();\n\t\tformat = (unsigned char)pFormatField->GetValue()->AsUInt();\n\t\tdimension = (unsigned char)pDimensionField->GetValue()->AsUInt();\n\t\tdimension_flags = (dimension & 0xF0) >> 4;\n\t\tdimension = dimension & 0x0F;\n\t\treturn true;\n\t}\n\treturn false;\n}\nbool StreamInfo::Read(AssetTypeValueField *pField)\n{\n\tAssetTypeValueField *pChannelMaskField = (*pField)["channelMask"];\n\tAssetTypeValueField *pOffsetField = (*pField)["offset"];\n\tAssetTypeValueField *pStrideField = (*pField)["stride"];\n\tAssetTypeValueField *pDividerOpField = (*pField)["dividerOp"];\n\tAssetTypeValueField *pFrequencyField = (*pField)["frequency"];\n\tif (!pChannelMaskField->IsDummy() && !pOffsetField->IsDummy() && !pStrideField->IsDummy()\n\t\t&& !pDividerOpField->IsDummy() && !pFrequencyField->IsDummy())\n\t{\n\t\tchannelMask = pChannelMaskField->GetValue()->AsUInt();\n\t\toffset = pOffsetField->GetValue()->AsUInt();\n\t\tstride = (unsigned char)pStrideField->GetValue()->AsUInt();\n\t\tdividerOp = (unsigned char)pDividerOpField->GetValue()->AsUInt();\n\t\tfrequency = (unsigned short)pFrequencyField->GetValue()->AsUInt();\n\t\treturn true;\n\t}\n\treturn false;\n}\nVertexData::VertexData()\n{\n\twasAbleToRead = false;\n\t_hasOwnData = false;\n\tm_CurrentChannels = -1;\n\tm_VertexCount = 0;\n\tm_Channels = std::vector<ChannelInfo>();\n\tm_Streams = std::vector<StreamInfo>();\n\tdataByteCount = 0;\n\tm_DataSize = NULL;\n}\nVertexData::~VertexData()\n{\n\tif (_hasOwnData && m_DataSize != nullptr)\n\t{\n\t\tdelete[] ((uint8_t*)m_DataSize);\n\t\tdataByteCount = 0;\n\t\tm_DataSize = nullptr;\n\t\t_hasOwnData = false;\n\t}\n}\nVertexData& VertexData::operator=(const VertexData& src)\n{\n\twasAbleToRead = src.wasAbleToRead;\n\tm_CurrentChannels = src.m_CurrentChannels;\n\tm_VertexCount = src.m_VertexCount;\n\tm_Channels.assign(src.m_Channels.begin(), src.m_Channels.end());\n\tm_Streams.assign(src.m_Streams.begin(), src.m_Streams.end());\n\tdataByteCount = src.dataByteCount;\n\tm_DataSize = src.m_DataSize;\n\tif (src._hasOwnData && m_DataSize != nullptr)\n\t{\n\t\tm_DataSize = new uint8_t[dataByteCount];\n\t\tmemcpy(m_DataSize, src.m_DataSize, dataByteCount);\n\t\t_hasOwnData = true;\n\t}\n\telse\n\t\t_hasOwnData = false;\n\treturn *this;\n}\nVertexData& VertexData::operator=(VertexData&& src)\n{\n\twasAbleToRead = src.wasAbleToRead;\n\tm_CurrentChannels = src.m_CurrentChannels;\n\tm_VertexCount = src.m_VertexCount;\n\tm_Channels = std::move(src.m_Channels);\n\tm_Streams = std::move(src.m_Streams);\n\tdataByteCount = src.dataByteCount;\n\tm_DataSize = src.m_DataSize;\n\t_hasOwnData = src._hasOwnData;\n\tsrc._hasOwnData = false;\n\tsrc.m_DataSize = nullptr;\n\treturn *this;\n}\nVertexData::VertexData(AssetTypeValueField* pField,\n\tAppContext& appContext, class StreamingInfo& streamInfo, AssetIdentifier &meshAsset,\n\tstd::vector<struct BoneInfluence>& boneWeights, bool unity5OrNewer)\n{\n\tconst uint8_t formatCount = unity5OrNewer ? 12 : 4;\n\tm_Channels = std::vector<ChannelInfo>();\n\twasAbleToRead = false;\n\t_hasOwnData = false;\n\tAssetTypeValueField *pCurrentChannelsField = (*pField)["m_CurrentChannels"];\n\tAssetTypeValueField *pVertexCountField = (*pField)["m_VertexCount"];\n\tAssetTypeValueField *pChannelsField = (*(*pField)["m_Channels"])["Array"];\n\tAssetTypeValueField *pDataField = (*pField)["m_DataSize"];\n\tif (!pVertexCountField->IsDummy() && !pChannelsField->IsDummy() && !pDataField->IsDummy())\n\t{\n\t\twasAbleToRead = true;\n\t\tdataByteCount = pDataField->GetValue()->AsByteArray()->size;\n\t\tm_DataSize = pDataField->GetValue()->AsByteArray()->data;\n\t\tif (!pCurrentChannelsField->IsDummy())\n\t\t\tm_CurrentChannels = pCurrentChannelsField->GetValue()->AsInt();\n\t\telse\n\t\t\tm_CurrentChannels = -1;\n\t\tm_VertexCount = pVertexCountField->GetValue()->AsUInt();\n\t\tint channelCount = pChannelsField->GetValue()->AsArray()->size;\n\t\tfor (int i = 0; i < channelCount; i++)\n\t\t{\n\t\t\tChannelInfo channel;\n\t\t\tif (!channel.Read((*pChannelsField)[i]))\n\t\t\t\twasAbleToRead = false;\n\t\t\telse\n\t\t\t\tm_Channels.push_back(channel);\n\t\t}\n\t\tAssetTypeValueField *pStreamsField = (*(*pField)["m_Streams"])["Array"];\n\t\tif (!pStreamsField->IsDummy() && pStreamsField->GetValue())\n\t\t{\n\t\t\tuint32_t streamCount = pStreamsField->GetValue()->AsArray()->size;\n\t\t\tfor (uint32_t i = 0; i < streamCount; i++)\n\t\t\t{\n\t\t\t\tStreamInfo curStream;\n\t\t\t\tif (!curStream.Read(pStreamsField->Get(i)))\n\t\t\t\t\twasAbleToRead = false;\n\t\t\t\telse\n\t\t\t\t\tm_Streams.push_back(curStream);\n\t\t\t}\n\t\t\t{\n\t\t\t\tuint32_t maxStream = streamCount - 1;\n\t\t\t\tfor (size_t i = 0; i < m_Channels.size(); i++)\n\t\t\t\t\tif (m_Channels[i].stream > maxStream)\n\t\t\t\t\t\tmaxStream = m_Channels[i].stream;\n\t\t\t\tStreamInfo tmpStream = {};\n\t\t\t\tfor (uint32_t i = streamCount; i <= maxStream; i++)\n\t\t\t\t\tm_Streams.push_back(tmpStream);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tuint32_t maxStream = 0;\n\t\t\tfor (size_t i = 0; i < m_Channels.size(); i++)\n\t\t\t\tif (m_Channels[i].stream > maxStream)\n\t\t\t\t\tmaxStream = m_Channels[i].stream;\n\t\t\tStreamInfo tmpStream = {};\n\t\t\tfor (uint32_t i = 0; i <= maxStream; i++)\n\t\t\t\tm_Streams.push_back(tmpStream);\n\t\t\tfor (size_t i = 0; i < m_Channels.size(); i++)\n\t\t\t{\n\t\t\t\tChannelInfo &channel = m_Channels[i];\n\t\t\t\tm_Streams[channel.stream].channelMask |= (1 << (int)(uint8_t)i);\n\t\t\t\tunsigned int curSize = channel.offset + channel.dimension * ChannelElementSize(channel.format, unity5OrNewer);\n\t\t\t\tif (curSize > m_Streams[channel.stream].stride)\n\t\t\t\t\tm_Streams[channel.stream].stride = curSize;\n\n\t\t\t\tif (channel.stream >= m_Streams.size() && m_VertexCount > 0)\n\t\t\t\t\twasAbleToRead = false;\n\t\t\t\tif (channel.format >= formatCount)\n\t\t\t\t\twasAbleToRead = false;\n\t\t\t}\n\t\t\tunsigned int curOffset = 0;\n\t\t\tfor (size_t i = 0; i < m_Streams.size(); i++)\n\t\t\t{\n\t\t\t\t//no idea if there is any alignment\n\t\t\t\t//m_Streams[i].stride = (m_Streams[i].stride + 3) & (~3)\n\t\t\t\tm_Streams[i].offset = curOffset;\n\t\t\t\t//m_Streams[i].offset = curOffset;\n\t\t\t\tcurOffset += m_Streams[i].stride * m_VertexCount;\n\t\t\t}\n\t\t\tif (curOffset > dataByteCount && curOffset > streamInfo.size)\n\t\t\t\twasAbleToRead = false;\n\t\t\tif (m_Streams.size() == 2) //sometimes there are additional 8 bytes between both streams\n\t\t\t\tm_Streams[1].offset = (dataByteCount ? dataByteCount : streamInfo.size) - (m_Streams[1].stride * m_VertexCount);\n\t\t}\n\n\t\tif (wasAbleToRead && (streamInfo.size > 0))\n\t\t{\n\t\t\tstd::shared_ptr<ResourcesFileContextInfo> pResourcesFile = nullptr;\n\t\t\tstd::shared_ptr<IAssetsReader> pStreamReader = nullptr;\n\t\t\ttry {\n\t\t\t\tpResourcesFile = FindResourcesFile(appContext, streamInfo.path, meshAsset, {});\n\t\t\t\tpStreamReader = pResourcesFile->getResource(pResourcesFile,\n\t\t\t\t\tstreamInfo.offset,\n\t\t\t\t\tstreamInfo.size);\n\t\t\t\tif (pStreamReader == nullptr)\n\t\t\t\t\tthrow AssetUtilError("Unable to locate the texture resource.");\n\t\t\t}\n\t\t\tcatch (AssetUtilError e)\n\t\t\t{\n\t\t\t\t//TODO: Proper error reporting\n\t\t\t\t// Have to make all allocations RAII to prevent leaks with thrown exceptions.\n\t\t\t\twasAbleToRead = false;\n\t\t\t}\n\t\t\tif (pStreamReader != nullptr)\n\t\t\t{\n\t\t\t\tm_DataSize = new uint32_t[streamInfo.size];\n\t\t\t\tdataByteCount = pStreamReader->Read(streamInfo.size, m_DataSize);\n\n\t\t\t\tif (dataByteCount != streamInfo.size)\n\t\t\t\t{\n\t\t\t\t\twasAbleToRead = false;\n\t\t\t\t\tdelete[] ((uint32_t*)m_DataSize);\n\t\t\t\t\tm_DataSize = nullptr;\n\t\t\t\t\tdataByteCount = 0;\n\t\t\t\t}\n\t\t\t\t_hasOwnData = true;\n\t\t\t}\n\t\t\telse\n\t\t\t\twasAbleToRead = false;\n\t\t}\n\n\t\tif (wasAbleToRead && m_Channels.size() >= 14\n\t\t\t&& m_Channels[12].dimension == 4 && IsFloatFormat(m_Channels[12].format, unity5OrNewer)\n\t\t\t&& m_Channels[13].dimension == 4 && IsUIntFormat(m_Channels[13].format, unity5OrNewer))\n\t\t{\n\t\t\tChannelInfo &weightChannel = m_Channels[12];\n\t\t\tChannelInfo &indexChannel = m_Channels[13];\n\t\t\tStreamInfo &weightStream = m_Streams[weightChannel.stream];\n\t\t\tStreamInfo &indexStream = m_Streams[indexChannel.stream];\n\t\t\tuint32_t weightVertexSize = 4 * ChannelElementSize(weightChannel.format, unity5OrNewer);\n\t\t\tuint32_t indexVertexSize = 4 * ChannelElementSize(indexChannel.format, unity5OrNewer);\n\t\t\tboneWeights.resize(m_VertexCount);\n\t\t\tfor (unsigned int i = 0; i < m_VertexCount; i++)\n\t\t\t{\n\t\t\t\tvoid* pCurWeightVertex = &((uint8_t*)m_DataSize)[weightStream.offset + i * weightStream.stride + weightChannel.offset];\n\t\t\t\tvoid* pCurIndexVertex = &((uint8_t*)m_DataSize)[indexStream.offset + i * indexStream.stride + indexChannel.offset];\n\t\t\t\tif ((weightStream.offset + i * weightStream.stride + weightChannel.offset + weightVertexSize) <= dataByteCount\n\t\t\t\t\t&& (indexStream.offset + i * indexStream.stride + indexChannel.offset + indexVertexSize) <= dataByteCount)\n\t\t\t\t{\n\t\t\t\t\tConvertChannelFloat(pCurWeightVertex, weightChannel.format, 4, boneWeights[i].weight, unity5OrNewer);\n\t\t\t\t\tConvertChannelUInt32(pCurIndexVertex, indexChannel.format, 4, boneWeights[i].boneIndex, unity5OrNewer);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tboneWeights.clear();\n\t\t\t\t\twasAbleToRead = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nbool VertexData::ConvertChannelFloat(const void *inData, uint8_t inFormat, uint8_t dimension, float *outData, bool unity5OrNewer)\n{\n\tif (!unity5OrNewer)\n\t{\n\t\tif (inFormat == 2) //uint32\n\t\t\treturn false;\n\t\tif (inFormat == 3) //snorm8\n\t\t\tinFormat = 4;\n\t}\n\tswitch (inFormat)\n\t{\n\tcase 0: //float32\n\t\t{\n\t\t\tconst float *fInData = (const float*)inData;\n\t\t\tmemcpy(outData, fInData, 4*dimension);\n\t\t}\n\t\treturn true;\n\tcase 1: //float16\n\t\t{\n\t\t\tconst HalfFloat *hfInData = (const HalfFloat*)inData;\n\t\t\tfor (uint8_t i = 0; i < dimension; i++)\n\t\t\t{\n\t\t\t\tHalfFloat curHF = {hfInData[i].half};\n\t\t\t\toutData[i] = curHF.toFloat();\n\t\t\t}\n\t\t}\n\t\treturn true;\n\tcase 2: //unorm8\n\tcase 3: //unorm8\n\t\t{\n\t\t\tconst unsigned __int8 *bInData = (const unsigned __int8*)inData;\n\t\t\tfor (uint8_t i = 0; i < dimension; i++)\n\t\t\t\toutData[i] = (((float)bInData[i]) / 255.0);\n\t\t}\n\t\treturn true;\n\tcase 4: //snorm8\n\t\t{\n\t\t\tconst __int8 *bInData = (const __int8*)inData;\n\t\t\tfor (uint8_t i = 0; i < dimension; i++)\n\t\t\t\toutData[i] = (bInData[i] == -128) ? -1.0f : (((float)bInData[i]) / 127.0);\n\t\t}\n\t\treturn true;\n\tcase 5: //unorm16\n\t\t{\n\t\t\tconst unsigned __int16 *bInData = (const unsigned __int16*)inData;\n\t\t\tfor (uint8_t i = 0; i < dimension; i++)\n\t\t\t\toutData[i] = (((float)bInData[i]) / 65535.0);\n\t\t}\n\t\treturn true;\n\tcase 6: //snorm16\n\t\t{\n\t\t\tconst __int16 *bInData = (const __int16*)inData;\n\t\t\tfor (uint8_t i = 0; i < dimension; i++)\n\t\t\t\toutData[i] = (bInData[i] == -32768) ? -1.0f : (((float)bInData[i]) / 32767.0);\n\t\t}\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\nbool VertexData::ConvertChannelInt32(const void *inData, uint8_t inFormat, uint8_t dimension, int *outData, bool unity5OrNewer)\n{\n\tif (!unity5OrNewer)\n\t{\n\t\treturn false;\n\t}\n\tswitch (inFormat)\n\t{\n\tcase 8: //int8\n\t\t{\n\t\t\tconst __int8 *bInData = (const __int8*)inData;\n\t\t\tfor (uint8_t i = 0; i < dimension; i++)\n\t\t\t\toutData[i] = (int)bInData[i];\n\t\t}\n\t\treturn true;\n\tcase 10: //int16\n\t\t{\n\t\t\tconst __int16 *sInData = (const __int16*)inData;\n\t\t\tfor (uint8_t i = 0; i < dimension; i++)\n\t\t\t\toutData[i] = (int)sInData[i];\n\t\t}\n\t\treturn true;\n\tcase 12: //int32\n\t\t{\n\t\t\tconst __int32 *iInData = (const __int32*)inData;\n\t\t\tmemcpy(outData, iInData, 4 * dimension);\n\t\t}\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\nbool VertexData::ConvertChannelUInt32(const void *inData, uint8_t inFormat, uint8_t dimension, unsigned int *outData, bool unity5OrNewer)\n{\n\tif (!unity5OrNewer)\n\t{\n\t\tif (inFormat == 2)\n\t\t\tinFormat = 11;\n\t\telse\n\t\t\treturn false;\n\t}\n\tswitch (inFormat)\n\t{\n\tcase 7: //uint8\n\tcase 8: //int8\n\t\t{\n\t\t\tconst unsigned __int8 *bInData = (const unsigned __int8*)inData;\n\t\t\tfor (uint8_t i = 0; i < dimension; i++)\n\t\t\t\toutData[i] = (unsigned int)bInData[i];\n\t\t}\n\t\treturn true;\n\tcase 9: //uint16\n\tcase 10: //int16\n\t\t{\n\t\t\tconst unsigned __int16 *sInData = (const unsigned __int16*)inData;\n\t\t\tfor (uint8_t i = 0; i < dimension; i++)\n\t\t\t\toutData[i] = (unsigned int)sInData[i];\n\t\t}\n\t\treturn true;\n\tcase 11: //uint32\n\tcase 12: //int32\n\t\t{\n\t\t\tconst unsigned __int32 *iInData = (const unsigned __int32*)inData;\n\t\t\tmemcpy(outData, iInData, 4 * dimension);\n\t\t}\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nPackedBitVector::PackedBitVector()\n{\n\twasAbleToRead = false;\n\thasRangeAndStart = false;\n}\nbool PackedBitVector::Read(AssetTypeValueField *pField)\n{\n\tAssetTypeValueField *pNumItems = (*pField)["m_NumItems"];\n\tAssetTypeValueField *pRange = (*pField)["m_Range"];\n\tAssetTypeValueField *pStart = (*pField)["m_Start"];\n\tAssetTypeValueField *pData = ((*pField)["m_Data"])->Get("Array");\n\tAssetTypeValueField *pBitSize = (*pField)["m_BitSize"];\n\tif ((!pNumItems->IsDummy() && pNumItems->GetValue() && pNumItems->GetValue()->GetType() == ValueType_UInt32) && \n\t\t(!pData->IsDummy() && pData->GetValue() && pData->GetValue()->GetType() == ValueType_Array &&\n\t\t\tpData->GetTemplateField()->children.size() == 2 && pData->GetTemplateField()->children[1].valueType == ValueType_UInt8) &&\n\t\t(!pBitSize->IsDummy() && pBitSize->GetValue() && pBitSize->GetValue()->GetType() == ValueType_UInt8))\n\t{\n\t\twasAbleToRead = true;\n\t\tm_NumItems = pNumItems->GetValue()->AsUInt();\n\t\tm_Data.clear();\n\t\tm_Data.reserve(pData->GetChildrenCount());\n\t\tfor (unsigned int i = 0; i < pData->GetChildrenCount(); i++)\n\t\t{\n\t\t\tAssetTypeValueField *pCur = pData->Get(i);\n\t\t\tif (!pCur->GetValue())\n\t\t\t{\n\t\t\t\twasAbleToRead = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tm_Data.push_back((unsigned char)pCur->GetValue()->AsUInt());\n\t\t}\n\t\tm_BitSize = (unsigned char)pBitSize->GetValue()->AsUInt();\n\t\tif (!m_BitSize && m_NumItems)\n\t\t\tbitSize = (unsigned char)((m_Data.size() * 8) / m_NumItems);\n\t\telse\n\t\t\tbitSize = m_BitSize;\n\t\tif (bitSize > 32)\n\t\t\twasAbleToRead = false;\n\t\tif ((!pRange->IsDummy() && pRange->GetValue() && pRange->GetValue()->GetType() == ValueType_Float) &&\n\t\t\t(!pStart->IsDummy() && pStart->GetValue() && pStart->GetValue()->GetType() == ValueType_Float))\n\t\t{\n\t\t\thasRangeAndStart = true;\n\t\t\tm_Range = pRange->GetValue()->AsFloat();\n\t\t\tm_Start = pStart->GetValue()->AsFloat();\n\t\t}\n\t\telse\n\t\t\thasRangeAndStart = false;\n\t}\n\telse\n\t\twasAbleToRead = false;\n\treturn wasAbleToRead;\n}\nunsigned char PackedBitVector::MakeByteMask(unsigned int bitOffset)\n{\n\treturn (unsigned char)(0xFF << bitOffset);\n}\nbool PackedBitVector::ReadValue(unsigned int index, unsigned int &out)\n{\n\tout = 0;\n\tif (bitSize == 0)\n\t\treturn true;\n\tif (index >= m_NumItems)\n\t\treturn false;\n\tunsigned int bitIndex = index * bitSize; //let\'s just assume that one compressed buffer doesn\'t use more than 512 MB\n\tif (bitIndex >= (0UL - bitSize))\n\t\treturn false;\n\tunsigned int curByteIndex = bitIndex >> 3;\n\tunsigned int curBitOffset = bitIndex & 7;\n\t//Bounds checks; The start check is just there to prevent integer overflows.\n\tif ((curByteIndex >= m_Data.size()) || (((bitIndex + bitSize) >> 3) > m_Data.size()))\n\t\treturn false;\n\t//Copy the potentially not byte-aligned data first.\n\tout = ((m_Data[curByteIndex] & MakeByteMask(curBitOffset)) >> curBitOffset);\n\tunsigned int curOutBitOffset = 8 - curBitOffset;\n\tcurBitOffset = 0;\n\tcurByteIndex++;\n\t//Copy the byte-aligned data.\n\twhile (curOutBitOffset < bitSize)\n\t{\n\t\tout |= m_Data[curByteIndex] << curOutBitOffset;\n\t\tcurOutBitOffset += 8;\n\t\tcurByteIndex++;\n\t}\n\t//Limit the data bits as the previous copies always read until the end of the current byte, while the actual value might end a couple of bits before.\n\tout &= (1 << bitSize) - 1; //Even works when bitSize == 32.\n\treturn true;\n}\nbool PackedBitVector::ReadValueFloat(unsigned int index, float &out)\n{\n\tif (!hasRangeAndStart)\n\t\treturn false;\n\tunsigned int raw;\n\tif (!ReadValue(index, raw))\n\t\treturn false;\n\t//Use double for the first step to reduce the overall error (there could be up to 32 bits representing a number between 0.0 and 1.0).\n\tout = (float)((((double)raw) / ((1 << bitSize) - 1)) * m_Range + m_Start);\n\treturn true;\n}\nCompressedMesh::CompressedMesh()\n{\n\twasAbleToRead = false;\n}\nbool CompressedMesh::Read(AssetTypeValueField *pField)\n{\n\t//If not stated otherwise, the following fields are present in U3.4 until (at least) U5.6.\n\tAssetTypeValueField *pVertices = (*pField)["m_Vertices"];\n\tAssetTypeValueField *pUV = (*pField)["m_UV"];\n\tAssetTypeValueField *pBindPoses = (*pField)["m_BindPoses"]; //Present starting with U3.5 until U4.7\n\tAssetTypeValueField *pNormals = (*pField)["m_Normals"];\n\tAssetTypeValueField *pTangents = (*pField)["m_Tangents"];\n\tAssetTypeValueField *pWeights = (*pField)["m_Weights"];\n\tAssetTypeValueField *pNormalSigns = (*pField)["m_NormalSigns"];\n\tAssetTypeValueField *pTangentSigns = (*pField)["m_TangentSigns"];\n\tAssetTypeValueField *pFloatColors = (*pField)["m_FloatColors"]; //Present starting with U5.0\n\tAssetTypeValueField *pBoneIndices = (*pField)["m_BoneIndices"];\n\tAssetTypeValueField *pTriangles = (*pField)["m_Triangles"];\n\tAssetTypeValueField *pColors = (*pField)["m_Colors"]; //Present starting with U3.5 until U4.7\n\tAssetTypeValueField *pUVInfo = (*pField)["m_UVInfo"]; //Present starting with U5.0\n\tif (!pVertices->IsDummy() && !pUV->IsDummy()/* && !pBindPoses->IsDummy()*/ && \n\t\t!pNormals->IsDummy() && !pTangents->IsDummy() && !pWeights->IsDummy() && \n\t\t!pNormalSigns->IsDummy() && !pTangentSigns->IsDummy() && !pBoneIndices->IsDummy() && \n\t\t!pTriangles->IsDummy())\n\t{\n\t\twasAbleToRead = true;\n\t\twasAbleToRead &= m_Vertices.Read(pVertices);\n\t\twasAbleToRead &= m_UV.Read(pUV);\n\t\tif (!pBindPoses->IsDummy())\n\t\t\twasAbleToRead &= m_BindPoses.Read(pBindPoses);\n\t\twasAbleToRead &= m_Normals.Read(pNormals);\n\t\twasAbleToRead &= m_Tangents.Read(pTangents);\n\t\twasAbleToRead &= m_Weights.Read(pWeights);\n\t\twasAbleToRead &= m_NormalSigns.Read(pNormalSigns);\n\t\twasAbleToRead &= m_TangentSigns.Read(pTangentSigns);\n\t\tif (!pFloatColors->IsDummy())\n\t\t\twasAbleToRead &= m_FloatColors.Read(pFloatColors);\n\t\twasAbleToRead &= m_BoneIndices.Read(pBoneIndices);\n\t\twasAbleToRead &= m_Triangles.Read(pTriangles);\n\t\tif (!pColors->IsDummy())\n\t\t\twasAbleToRead &= m_Colors.Read(pColors);\n\t\tif (!pUVInfo->IsDummy() && pUVInfo->GetValue() && pUVInfo->GetValue()->GetType() == ValueType_UInt32)\n\t\t\tm_UVInfo = pUVInfo->GetValue()->AsUInt();\n\t\telse\n\t\t\tm_UVInfo = 0;\n\t}\n\telse\n\t\twasAbleToRead = false;\n\treturn wasAbleToRead;\n}\nbool BlendShapeVertex::Read(AssetTypeValueField *pField)\n{\n\tAssetTypeValueField *pVertex = (*pField)["vertex"];\n\tAssetTypeValueField *pNormal = (*pField)["normal"];\n\tAssetTypeValueField *pTangent = (*pField)["tangent"];\n\tAssetTypeValueField *pIndex = (*pField)["index"];\n\tif (!pVertex->IsDummy() && !pNormal->IsDummy() && \n\t\t!pTangent->IsDummy() && !pIndex->IsDummy())\n\t{\n\t\tif (!vertex.Read(pVertex))\n\t\t\treturn false;\n\t\tif (!normal.Read(pNormal))\n\t\t\treturn false;\n\t\tif (!tangent.Read(pTangent))\n\t\t\treturn false;\n\t\tif (!pIndex->GetValue())\n\t\t\treturn false;\n\t\tindex = pIndex->GetValue()->AsUInt();\n\t\treturn true;\n\t}\n\treturn false;\n}\nbool MeshBlendShape::Read(AssetTypeValueField *pField)\n{\n\tAssetTypeValueField *pFirstVertex = (*pField)["firstVertex"];\n\tAssetTypeValueField *pVertexCount = (*pField)["vertexCount"];\n\tAssetTypeValueField *pHasNormals = (*pField)["hasNormals"];\n\tAssetTypeValueField *pHasTangents = (*pField)["hasTangents"];\n\tif (!pFirstVertex->IsDummy() && !pVertexCount->IsDummy() && \n\t\t!pHasNormals->IsDummy() && !pHasTangents->IsDummy())\n\t{\n\t\tif (!pFirstVertex->GetValue())\n\t\t\treturn false;\n\t\tfirstVertex = pFirstVertex->GetValue()->AsUInt();\n\t\tif (!pVertexCount->GetValue())\n\t\t\treturn false;\n\t\tvertexCount = pVertexCount->GetValue()->AsUInt();\n\t\tif (!pHasNormals->GetValue())\n\t\t\treturn false;\n\t\thasNormals = pHasNormals->GetValue()->AsBool();\n\t\tif (!pHasTangents->GetValue())\n\t\t\treturn false;\n\t\thasTangents = pHasTangents->GetValue()->AsBool();\n\t\treturn true;\n\t}\n\treturn false;\n}\nbool MeshBlendShapeChannel::Read(AssetTypeValueField *pField)\n{\n\tAssetTypeValueField *pName = (*pField)["name"];\n\tAssetTypeValueField *pNameHash = (*pField)["nameHash"];\n\tAssetTypeValueField *pFrameIndex = (*pField)["frameIndex"];\n\tAssetTypeValueField *pFrameCount = (*pField)["frameCount"];\n\tif (!pName->IsDummy() && !pNameHash->IsDummy() && \n\t\t!pFrameIndex->IsDummy() && !pFrameCount->IsDummy())\n\t{\n\t\tif (!pName->GetValue())\n\t\t\treturn false;\n\t\tname = pName->GetValue()->AsString();\n\t\tif (!pNameHash->GetValue())\n\t\t\treturn false;\n\t\tnameHash = pNameHash->GetValue()->AsUInt();\n\t\tif (!pFrameIndex->GetValue())\n\t\t\treturn false;\n\t\tframeIndex = pFrameIndex->GetValue()->AsInt();\n\t\tif (!pFrameCount->GetValue())\n\t\t\treturn false;\n\t\tframeCount = pFrameCount->GetValue()->AsInt();\n\t\treturn true;\n\t}\n\treturn false;\n}\nBlendShapeData::BlendShapeData(){}\nbool BlendShapeData::Read(AssetTypeValueField *pField)\n{\n\twasAbleToRead = false;\n\tAssetTypeValueField *pVertices = (*pField)["vertices"]->Get("Array");\n\tAssetTypeValueField *pShapes = (*pField)["shapes"]->Get("Array");\n\tAssetTypeValueField *pChannels = (*pField)["channels"]->Get("Array");\n\tAssetTypeValueField *pFullWeights = (*pField)["fullWeights"]->Get("Array");\n\tif (!pVertices->IsDummy() && !pShapes->IsDummy() && \n\t\t!pChannels->IsDummy() && !pFullWeights->IsDummy())\n\t{\n\t\tvertices.resize(pVertices->GetChildrenCount());\n\t\tfor (unsigned int i = 0; i < pVertices->GetChildrenCount(); i++)\n\t\t{\n\t\t\tif (!vertices[i].Read(pVertices->Get(i)))\n\t\t\t{\n\t\t\t\tvertices.clear();\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\t\n\t\tshapes.resize(pShapes->GetChildrenCount());\n\t\tfor (unsigned int i = 0; i < pShapes->GetChildrenCount(); i++)\n\t\t{\n\t\t\tif (!shapes[i].Read(pShapes->Get(i)))\n\t\t\t{\n\t\t\t\tvertices.clear();\n\t\t\t\tshapes.clear();\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\t\n\t\tchannels.resize(pChannels->GetChildrenCount());\n\t\tfor (unsigned int i = 0; i < pChannels->GetChildrenCount(); i++)\n\t\t{\n\t\t\tif (!channels[i].Read(pChannels->Get(i)))\n\t\t\t{\n\t\t\t\tvertices.clear();\n\t\t\t\tshapes.clear();\n\t\t\t\tchannels.clear();\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfullWeights.resize(pFullWeights->GetChildrenCount());\n\t\tfor (unsigned int i = 0; i < pFullWeights->GetChildrenCount(); i++)\n\t\t{\n\t\t\tAssetTypeValueField *pEntry = pFullWeights->Get(i);\n\t\t\tif (!pEntry->GetValue() || pEntry->GetValue()->GetType() != ValueType_Float)\n\t\t\t{\n\t\t\t\tvertices.clear();\n\t\t\t\tshapes.clear();\n\t\t\t\tchannels.clear();\n\t\t\t\tfullWeights.clear();\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tfullWeights[i] = pEntry->GetValue()->AsFloat();\n\t\t}\n\t\twasAbleToRead = true;\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nbool BoneInfluence::Read(AssetTypeValueField *pField)\n{\n\tAssetTypeValueField *pWeight[4] = {\n\t\t(*pField)["weight[0]"], (*pField)["weight[1]"], (*pField)["weight[2]"], (*pField)["weight[3]"]\n\t};\n\tAssetTypeValueField *pBoneIndex[4] = {\n\t\t(*pField)["boneIndex[0]"], (*pField)["boneIndex[1]"], (*pField)["boneIndex[2]"], (*pField)["boneIndex[3]"]\n\t};\n\tfor (int i = 0; i < 4; i++)\n\t{\n\t\tif (pWeight[i]->GetValue() == NULL || pBoneIndex[i]->GetValue() == NULL || pWeight[i]->GetValue()->GetType() != ValueType_Float)\n\t\t\treturn false;\n\t\tweight[i] = pWeight[i]->GetValue()->AsFloat();\n\t\tboneIndex[i] = pBoneIndex[i]->GetValue()->AsUInt();\n\t}\n\treturn true;\n}\n\nVariableBoneCountWeights::VariableBoneCountWeights() {}\nbool VariableBoneCountWeights::Read(AssetTypeValueField *pField)\n{\n\tAssetTypeValueField *pDataArray = (*(*pField)["m_Data"])["Array"];\n\tif (!pDataArray->IsDummy())\n\t{\n\t\tm_Data.resize(pDataArray->GetChildrenCount());\n\t\tfor (unsigned int i = 0; i < pDataArray->GetChildrenCount(); i++)\n\t\t{\n\t\t\tAssetTypeValue *pValue = pDataArray->Get(i)->GetValue();\n\t\t\tif (!pValue || pValue->GetType() != ValueType_UInt32)\n\t\t\t\treturn false;\n\t\t\tm_Data[i] = pValue->AsUInt();\n\t\t}\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nStreamingInfo::StreamingInfo()\n{\n\tthis->wasAbleToRead = false;\n\tthis->size = 0;\n\tthis->offset = 0;\n}\nbool StreamingInfo::Read(AssetTypeValueField *pField)\n{\n\tthis->wasAbleToRead = false;\n\tAssetTypeValueField *pOffset = (*pField)["offset"];\n\tAssetTypeValueField *pSize = (*pField)["size"];\n\tAssetTypeValueField *pPath = (*pField)["path"];\n\tif (pOffset->GetValue() && pOffset->GetValue()->GetType() == ValueType_UInt32 &&\n\t\tpSize->GetValue() && pSize->GetValue()->GetType() == ValueType_UInt32 &&\n\t\tpPath->GetValue() && pPath->GetValue()->GetType() == ValueType_String && pPath->GetValue()->AsString())\n\t{\n\t\tthis->offset = pOffset->GetValue()->AsUInt64();\n\t\tthis->size = pSize->GetValue()->AsUInt();\n\t\tthis->path = std::string(pPath->GetValue()->AsString());\n\t\tthis->wasAbleToRead = true;\n\t}\n\treturn this->wasAbleToRead;\n}\n\nMesh::Mesh(AssetTypeValueField *pField, bool unity5OrNewer, AppContext &appContext, AssetIdentifier &asset)\n{\n\tm_SubMeshes = std::vector<SubMesh>();\n\tm_IndexBuffer = std::vector<unsigned int>();\n\tm_VertexData = VertexData();\n\twasAbleToRead = false;\n\tAssetTypeValueField *pNameField = (*pField)["m_Name"];\n\tAssetTypeValueField *pSubMeshesField = (*(*pField)["m_SubMeshes"])["Array"];\n\tAssetTypeValueField *pShapesField = (*pField)["m_Shapes"];\n\tAssetTypeValueField *pBindPoseField = (*(*pField)["m_BindPose"])["Array"];\n\tAssetTypeValueField *pBoneNameHashesField = (*(*pField)["m_BoneNameHashes"])["Array"];\n\tAssetTypeValueField *pRootBoneNameHashField = (*pField)["m_RootBoneNameHash"];\n\tAssetTypeValueField *pBonesAABBField = (*(*pField)["m_BonesAABB"])["Array"];\n\tAssetTypeValueField *pVariableBoneCountWeightsField = (*pField)["m_VariableBoneCountWeights"];\n\tAssetTypeValueField *pMeshCompressionField = (*pField)["m_MeshCompression"];\n\tAssetTypeValueField *pIndexFormatField = (*pField)["m_IndexFormat"];\n\tAssetTypeValueField *pIndexBufferField = (*(*pField)["m_IndexBuffer"])["Array"];\n\tAssetTypeValueField *pSkinField = (*(*pField)["m_Skin"])["Array"];\n\tAssetTypeValueField *pVertexDataField = (*pField)["m_VertexData"];\n\tAssetTypeValueField *pCompressedMeshField = (*pField)["m_CompressedMesh"];\n\tAssetTypeValueField *pLocalAABBField = (*pField)["m_LocalAABB"];\n\tAssetTypeValueField *pStreamDataField = (*pField)["m_StreamData"];\n\tif (!pNameField->IsDummy() && !pSubMeshesField->IsDummy() && !pMeshCompressionField->IsDummy() && !pIndexBufferField->IsDummy()\n\t\t\t&& !pVertexDataField->IsDummy() && !pLocalAABBField->IsDummy())\n\t{\n\t\twasAbleToRead = true;\n\t\tm_Name = pNameField->GetValue()->AsString();\n\t\tif (!m_Name)\n\t\t\twasAbleToRead = false; //to prevent access violations\n\t\tuint32_t subMeshCount = pSubMeshesField->GetValue()->AsArray()->size;\n\t\tm_SubMeshes.reserve(subMeshCount);\n\t\tfor (uint32_t i = 0; i < subMeshCount; i++)\n\t\t{\n\t\t\tSubMesh subMesh;\n\t\t\tif (!subMesh.Read((*pSubMeshesField)[i]))\n\t\t\t\twasAbleToRead = false;\n\t\t\telse\n\t\t\t\tm_SubMeshes.push_back(subMesh);\n\t\t}\n\n\t\tif (!pShapesField->IsDummy())\n\t\t\tm_Shapes.Read(pShapesField);\n\t\telse\n\t\t\tm_Shapes.wasAbleToRead = false;\n\t\tif (!pBindPoseField->IsDummy())\n\t\t{\n\t\t\tm_BindPose.resize(pBindPoseField->GetChildrenCount());\n\t\t\tfor (unsigned int i = 0; i < pBindPoseField->GetChildrenCount(); i++)\n\t\t\t{\n\t\t\t\tif (!m_BindPose[i].Read(pBindPoseField->Get(i)))\n\t\t\t\t{\n\t\t\t\t\tm_BindPose.clear();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (!pBoneNameHashesField->IsDummy())\n\t\t{\n\t\t\tm_BoneNameHashes.resize(pBoneNameHashesField->GetChildrenCount());\n\t\t\tfor (unsigned int i = 0; i < pBindPoseField->GetChildrenCount(); i++)\n\t\t\t{\n\t\t\t\tAssetTypeValue *pValue = pBoneNameHashesField->Get(i)->GetValue();\n\t\t\t\tif (!pValue)\n\t\t\t\t{\n\t\t\t\t\tm_BoneNameHashes.clear();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tm_BoneNameHashes[i] = pValue->AsUInt();\n\t\t\t}\n\t\t}\n\t\tif (pRootBoneNameHashField->GetValue())\n\t\t\tm_RootBoneNameHash = pRootBoneNameHashField->GetValue()->AsUInt();\n\t\telse\n\t\t\tm_RootBoneNameHash = 0;\n\n\t\tif (!pBonesAABBField->IsDummy())\n\t\t{\n\t\t\tm_BonesAABB.resize(pBonesAABBField->GetChildrenCount());\n\t\t\tfor (unsigned int i = 0; i < pBonesAABBField->GetChildrenCount(); i++)\n\t\t\t{\n\t\t\t\tif (!m_BonesAABB[i].Read(pBonesAABBField->Get(i)))\n\t\t\t\t{\n\t\t\t\t\tm_BonesAABB.clear();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (!pVariableBoneCountWeightsField->IsDummy())\n\t\t{\n\t\t\tm_VariableBoneCountWeights.Read(pVariableBoneCountWeightsField);\n\t\t}\n\n\t\tm_MeshCompression = (unsigned char)pMeshCompressionField->GetValue()->AsUInt();\n\n\t\tif (!pIndexFormatField->IsDummy())\n\t\t\tm_IndexFormat = pIndexFormatField->GetValue()->AsInt();\n\t\telse\n\t\t\tm_IndexFormat = 0; //16 bit is default.\n\n\t\tint indexCount = pIndexBufferField->GetValue()->AsArray()->size;\n\t\tswitch (m_IndexFormat)\n\t\t{\n\t\tcase 0: //UInt16\n\t\t\tif (indexCount & 1)\n\t\t\t\twasAbleToRead = false; //the indices obviously are no shorts\n\t\t\telse\n\t\t\t{\n\t\t\t\tm_IndexBuffer.reserve(indexCount/2); //index array is a byte array; the indices always(?) are shorts\n\t\t\t\tfor (int i = 0; i < (indexCount-1); i+=2)\n\t\t\t\t{\n\t\t\t\t\tm_IndexBuffer.push_back((unsigned short)(*pIndexBufferField)[i]->GetValue()->AsInt() | ((unsigned short)(*pIndexBufferField)[i+1]->GetValue()->AsInt() << 8));\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 1: //UInt32\n\t\t\tif (indexCount & 3)\n\t\t\t\twasAbleToRead = false; //the indices obviously are no ints\n\t\t\telse\n\t\t\t{\n\t\t\t\tm_IndexBuffer.reserve(indexCount/4); //index array is a byte array; the indices always are ints\n\t\t\t\tfor (int i = 0; i < (indexCount-3); i+=4)\n\t\t\t\t{\n\t\t\t\t\tm_IndexBuffer.push_back(\n\t\t\t\t\t\t\t(unsigned int)(*pIndexBufferField)[i]->GetValue()->AsInt() \n\t\t\t\t\t\t| ((unsigned int)(*pIndexBufferField)[i+1]->GetValue()->AsInt() << 8)\n\t\t\t\t\t\t| ((unsigned int)(*pIndexBufferField)[i+2]->GetValue()->AsInt() << 16)\n\t\t\t\t\t\t| ((unsigned int)(*pIndexBufferField)[i+3]->GetValue()->AsInt() << 24)\n\t\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\twasAbleToRead = false;\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tif (!pSkinField->IsDummy())\n\t\t{\n\t\t\tm_Skin.resize(pSkinField->GetChildrenCount());\n\t\t\tfor (unsigned int i = 0; i < pSkinField->GetChildrenCount(); i++)\n\t\t\t{\n\t\t\t\tif (!m_Skin[i].Read(pSkinField->Get(i)))\n\t\t\t\t{\n\t\t\t\t\tm_Skin.clear();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (!pStreamDataField->IsDummy())\n\t\t\tm_StreamData.Read(pStreamDataField);\n\n\t\tm_VertexData = VertexData(pVertexDataField, appContext, m_StreamData, asset, m_Skin, unity5OrNewer);\n\t\tif (!m_VertexData.wasAbleToRead)\n\t\t\twasAbleToRead = false;\n\t\tif (!pCompressedMeshField->IsDummy())\n\t\t\tm_CompressedMesh.Read(pCompressedMeshField);\n\t\tif (!m_LocalAABB.Read(pLocalAABBField))\n\t\t\twasAbleToRead = false;\n\t}\n}'