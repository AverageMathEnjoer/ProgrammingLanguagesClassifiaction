b'using System;\nusing System.Diagnostics;\nusing System.Text;\n\nusing u32 = System.UInt32;\nusing Pgno = System.UInt32;\n\nnamespace CS_SQLite3\n{\n  using sqlite3_value = CSSQLite.Mem;\n  using sqlite3_pcache = CSSQLite.PCache1;\n\n  public partial class CSSQLite\n  {\n    /*\n    ** 2008 August 05\n    **\n    ** The author disclaims copyright to this source code.  In place of\n    ** a legal notice, here is a blessing:\n    **\n    **    May you do good and not evil.\n    **    May you find forgiveness for yourself and forgive others.\n    **    May you share freely, never taking more than you give.\n    **\n    *************************************************************************\n    ** This file implements that page cache.\n    **\n    ** @(#) $Id: pcache.c,v 1.47 2009/07/25 11:46:49 danielk1977 Exp $\n    **\n    *************************************************************************\n    **  Included in SQLite3 port to C#-SQLite;  2008 Noah B Hart\n    **  C#-SQLite is an independent reimplementation of the SQLite software library\n    **\n    **  $Header$\n    *************************************************************************\n    */\n    //#include "sqliteInt.h"\n\n    /*\n    ** A complete page cache is an instance of this structure.\n    */\n    public class PCache\n    {\n      public PgHdr pDirty, pDirtyTail;           /* List of dirty pages in LRU order */\n      public PgHdr pSynced;                      /* Last synced page in dirty page list */\n      public int nRef;                           /* Number of referenced pages */\n      public int nMax;                           /* Configured cache size */\n      public int szPage;                         /* Size of every page in this cache */\n      public int szExtra;                        /* Size of extra space for each page */\n      public bool bPurgeable;                    /* True if pages are on backing store */\n      public dxStress xStress; //int (*xStress)(void*,PgHdr*);       /* Call to try make a page clean */\n      public object pStress;                     /* Argument to xStress */\n      public sqlite3_pcache pCache;              /* Pluggable cache module */\n      public PgHdr pPage1;                       /* Reference to page 1 */\n\n      public void Clear()\n      {\n        pDirty = null;\n        pDirtyTail = null;\n        pSynced = null;\n        nRef = 0;\n      }\n    };\n\n    /*\n    ** Some of the Debug.Assert() macros in this code are too expensive to run\n    ** even during normal debugging.  Use them only rarely on long-running\n    ** tests.  Enable the expensive asserts using the\n    ** -DSQLITE_ENABLE_EXPENSIVE_ASSERT=1 compile-time option.\n    */\n#if SQLITE_ENABLE_EXPENSIVE_ASSERT\n//# define expensive_assert(X)  Debug.Assert(X)\nstatic void expensive_assert( bool x ) { Debug.Assert( x ); }\n#else\n    //# define expensive_assert(X)\n#endif\n\n    /********************************** Linked List Management ********************/\n\n#if !NDEBUG &&  SQLITE_ENABLE_EXPENSIVE_ASSERT\n/*\n** Check that the pCache.pSynced variable is set correctly. If it\n** is not, either fail an Debug.Assert or return zero. Otherwise, return\n** non-zero. This is only used in debugging builds, as follows:\n**\n**   expensive_assert( pcacheCheckSynced(pCache) );\n*/\nstatic int pcacheCheckSynced(PCache pCache){\nPgHdr p ;\nfor(p=pCache.pDirtyTail; p!=pCache.pSynced; p=p.pDirtyPrev){\nDebug.Assert( p.nRef !=0|| (p.flags&PGHDR_NEED_SYNC) !=0);\n}\nreturn (p==null || p.nRef!=0 || (p.flags&PGHDR_NEED_SYNC)==0)?1:0;\n}\n#endif //* !NDEBUG && SQLITE_ENABLE_EXPENSIVE_ASSERT */\n\n    /*\n** Remove page pPage from the list of dirty pages.\n*/\n    static void pcacheRemoveFromDirtyList( PgHdr pPage )\n    {\n      PCache p = pPage.pCache;\n\n      Debug.Assert( pPage.pDirtyNext != null || pPage == p.pDirtyTail );\n      Debug.Assert( pPage.pDirtyPrev != null || pPage == p.pDirty );\n\n      /* Update the PCache1.pSynced variable if necessary. */\n      if ( p.pSynced == pPage )\n      {\n        PgHdr pSynced = pPage.pDirtyPrev;\n        while ( pSynced != null && ( pSynced.flags & PGHDR_NEED_SYNC ) != 0 )\n        {\n          pSynced = pSynced.pDirtyPrev;\n        }\n        p.pSynced = pSynced;\n      }\n\n      if ( pPage.pDirtyNext != null )\n      {\n        pPage.pDirtyNext.pDirtyPrev = pPage.pDirtyPrev;\n      }\n      else\n      {\n        Debug.Assert( pPage == p.pDirtyTail );\n        p.pDirtyTail = pPage.pDirtyPrev;\n      }\n      if ( pPage.pDirtyPrev != null )\n      {\n        pPage.pDirtyPrev.pDirtyNext = pPage.pDirtyNext;\n      }\n      else\n      {\n        Debug.Assert( pPage == p.pDirty );\n        p.pDirty = pPage.pDirtyNext;\n      }\n      pPage.pDirtyNext = null;\n      pPage.pDirtyPrev = null;\n\n#if SQLITE_ENABLE_EXPENSIVE_ASSERT\nexpensive_assert( pcacheCheckSynced(p) );\n#endif\n    }\n\n    /*\n    ** Add page pPage to the head of the dirty list (PCache1.pDirty is set to\n    ** pPage).\n    */\n    static void pcacheAddToDirtyList( PgHdr pPage )\n    {\n      PCache p = pPage.pCache;\n\n      Debug.Assert( pPage.pDirtyNext == null && pPage.pDirtyPrev == null && p.pDirty != pPage );\n\n      pPage.pDirtyNext = p.pDirty;\n      if ( pPage.pDirtyNext != null )\n      {\n        Debug.Assert( pPage.pDirtyNext.pDirtyPrev == null );\n        pPage.pDirtyNext.pDirtyPrev = pPage;\n      }\n      p.pDirty = pPage;\n      if ( null == p.pDirtyTail )\n      {\n        p.pDirtyTail = pPage;\n      }\n      if ( null == p.pSynced && 0 == ( pPage.flags & PGHDR_NEED_SYNC ) )\n      {\n        p.pSynced = pPage;\n      }\n#if SQLITE_ENABLE_EXPENSIVE_ASSERT\nexpensive_assert( pcacheCheckSynced(p) );\n#endif\n    }\n\n    /*\n    ** Wrapper around the pluggable caches xUnpin method. If the cache is\n    ** being used for an in-memory database, this function is a no-op.\n    */\n    static void pcacheUnpin( PgHdr p )\n    {\n      PCache pCache = p.pCache;\n      if ( pCache.bPurgeable )\n      {\n        if ( p.pgno == 1 )\n        {\n          pCache.pPage1 = null;\n        }\n        sqlite3GlobalConfig.pcache.xUnpin( pCache.pCache, p, 0 );\n      }\n    }\n\n    /*************************************************** General Interfaces ******\n    **\n    ** Initialize and shutdown the page cache subsystem. Neither of these\n    ** functions are threadsafe.\n    */\n    static int sqlite3PcacheInitialize()\n    {\n      if ( sqlite3GlobalConfig.pcache.xInit == null )\n      {\n        sqlite3PCacheSetDefault();\n      }\n      return sqlite3GlobalConfig.pcache.xInit( sqlite3GlobalConfig.pcache.pArg );\n    }\n    static void sqlite3PcacheShutdown()\n    {\n      if ( sqlite3GlobalConfig.pcache.xShutdown != null )\n      {\n        sqlite3GlobalConfig.pcache.xShutdown( sqlite3GlobalConfig.pcache.pArg );\n      }\n    }\n\n    /*\n    ** Return the size in bytes of a PCache object.\n    */\n    static int sqlite3PcacheSize() { return 4; }// sizeof( PCache ); }\n\n    /*\n    ** Create a new PCache object. Storage space to hold the object\n    ** has already been allocated and is passed in as the p pointer.\n    ** The caller discovers how much space needs to be allocated by\n    ** calling sqlite3PcacheSize().\n    */\n    static void sqlite3PcacheOpen(\n    int szPage,                  /* Size of every page */\n    int szExtra,                 /* Extra space associated with each page */\n    bool bPurgeable,             /* True if pages are on backing store */\n    dxStress xStress,//int (*xStress)(void*,PgHdr*),/* Call to try to make pages clean */\n    object pStress,              /* Argument to xStress */\n    PCache p                     /* Preallocated space for the PCache */\n    )\n    {\n      p.Clear();//memset(p, 0, sizeof(PCache));\n      p.szPage = szPage;\n      p.szExtra = szExtra;\n      p.bPurgeable = bPurgeable;\n      p.xStress = xStress;\n      p.pStress = pStress;\n      p.nMax = 100;\n    }\n\n    /*\n    ** Change the page size for PCache object. The caller must ensure that there\n    ** are no outstanding page references when this function is called.\n    */\n    static void sqlite3PcacheSetPageSize( PCache pCache, int szPage )\n    {\n      Debug.Assert( pCache.nRef == 0 && pCache.pDirty == null );\n      if ( pCache.pCache != null )\n      {\n        sqlite3GlobalConfig.pcache.xDestroy( ref pCache.pCache );\n        pCache.pCache = null;\n      }\n      pCache.szPage = szPage;\n    }\n\n    /*\n    ** Try to obtain a page from the cache.\n    */\n    static int sqlite3PcacheFetch(\n    PCache pCache,       /* Obtain the page from this cache */\n    u32 pgno,            /* Page number to obtain */\n    int createFlag,      /* If true, create page if it does not exist already */\n    ref PgHdr ppPage     /* Write the page here */\n    )\n    {\n      PgHdr pPage = null;\n      int eCreate;\n\n      Debug.Assert( pCache != null );\n      Debug.Assert( createFlag == 1 || createFlag == 0 );\n      Debug.Assert( pgno > 0 );\n\n      /* If the pluggable cache (sqlite3_pcache*) has not been allocated,\n      ** allocate it now.\n      */\n      if ( null == pCache.pCache && createFlag != 0 )\n      {\n        sqlite3_pcache p;\n        int nByte;\n        nByte = pCache.szPage + pCache.szExtra + 0;// sizeof( PgHdr );\n        p = sqlite3GlobalConfig.pcache.xCreate( nByte, pCache.bPurgeable ? 1 : 0 );\n        if ( null == p )\n        {\n          return SQLITE_NOMEM;\n        }\n        sqlite3GlobalConfig.pcache.xCachesize( p, pCache.nMax );\n        pCache.pCache = p;\n      }\n\n      eCreate = createFlag * ( 1 + ( ( !pCache.bPurgeable || null == pCache.pDirty ) ? 1 : 0 ) );\n\n      if ( pCache.pCache != null )\n      {\n        pPage = sqlite3GlobalConfig.pcache.xFetch( pCache.pCache, pgno, eCreate );\n      }\n\n      if ( null == pPage && eCreate == 1 )\n      {\n        PgHdr pPg;\n\n        /* Find a dirty page to write-out and recycle. First try to find a\n        ** page that does not require a journal-sync (one with PGHDR_NEED_SYNC\n        ** cleared), but if that is not possible settle for any other\n        ** unreferenced dirty page.\n        */\n#if SQLITE_ENABLE_EXPENSIVE_ASSERT\nexpensive_assert( pcacheCheckSynced(pCache) );\n#endif\n        for ( pPg = pCache.pSynced ;\n        pPg != null && ( pPg.nRef != 0 || ( pPg.flags & PGHDR_NEED_SYNC ) != 0 ) ;\n        pPg = pPg.pDirtyPrev\n        ) ;\n        if ( null == pPg )\n        {\n          for ( pPg = pCache.pDirtyTail ; pPg != null && pPg.nRef != 0 ; pPg = pPg.pDirtyPrev ) ;\n        }\n        if ( pPg != null )\n        {\n          int rc;\n          rc = pCache.xStress( pCache.pStress, pPg );\n          if ( rc != SQLITE_OK && rc != SQLITE_BUSY )\n          {\n            return rc;\n          }\n        }\n\n        pPage = sqlite3GlobalConfig.pcache.xFetch( pCache.pCache, pgno, 2 );\n      }\n\n      if ( pPage != null )\n      {\n        if ( null == pPage.pData )\n        {\n          pPage.pData = new byte[pCache.szPage];//memset( pPage, 0, sizeof( PgHdr ) + pCache.szExtra );\n          //pPage.pExtra = (void*)&pPage[1];\n          //pPage.pData = (void*)&( (char*)pPage )[sizeof( PgHdr ) + pCache.szExtra];\n          pPage.pCache = pCache;\n          pPage.pgno = pgno;\n        }\n        Debug.Assert( pPage.pCache == pCache );\n        Debug.Assert( pPage.pgno == pgno );\n        //Debug.Assert( pPage.pExtra == (void*)&pPage[1] );\n        if ( 0 == pPage.nRef )\n        {\n          pCache.nRef++;\n        }\n        pPage.nRef++;\n        if ( pgno == 1 )\n        {\n          pCache.pPage1 = pPage;\n        }\n      }\n      ppPage = pPage;\n      return ( pPage == null && eCreate != 0 ) ? SQLITE_NOMEM : SQLITE_OK;\n    }\n\n    /*\n    ** Decrement the reference count on a page. If the page is clean and the\n    ** reference count drops to 0, then it is made elible for recycling.\n    */\n    static void sqlite3PcacheRelease( PgHdr p )\n    {\n      Debug.Assert( p.nRef > 0 );\n      p.nRef--;\n      if ( p.nRef == 0 )\n      {\n        PCache pCache = p.pCache;\n        pCache.nRef--;\n        if ( ( p.flags & PGHDR_DIRTY ) == 0 )\n        {\n          pcacheUnpin( p );\n        }\n        else\n        {\n          /* Move the page to the head of the dirty list. */\n          pcacheRemoveFromDirtyList( p );\n          pcacheAddToDirtyList( p );\n        }\n      }\n    }\n\n    /*\n    ** Increase the reference count of a supplied page by 1.\n    */\n    static void sqlite3PcacheRef( PgHdr p )\n    {\n      Debug.Assert( p.nRef > 0 );\n      p.nRef++;\n    }\n\n    /*\n    ** Drop a page from the cache. There must be exactly one reference to the\n    ** page. This function deletes that reference, so after it returns the\n    ** page pointed to by p is invalid.\n    */\n    static void sqlite3PcacheDrop( PgHdr p )\n    {\n      PCache pCache;\n      Debug.Assert( p.nRef == 1 );\n      if ( ( p.flags & PGHDR_DIRTY ) != 0 )\n      {\n        pcacheRemoveFromDirtyList( p );\n      }\n      pCache = p.pCache;\n      pCache.nRef--;\n      if ( p.pgno == 1 )\n      {\n        pCache.pPage1 = null;\n      }\n      sqlite3GlobalConfig.pcache.xUnpin( pCache.pCache, p, 1 );\n    }\n\n    /*\n    ** Make sure the page is marked as dirty. If it isn\'t dirty already,\n    ** make it so.\n    */\n    static void sqlite3PcacheMakeDirty( PgHdr p )\n    {\n      p.flags &= ~PGHDR_DONT_WRITE;\n      Debug.Assert( p.nRef > 0 );\n      if ( 0 == ( p.flags & PGHDR_DIRTY ) )\n      {\n        p.flags |= PGHDR_DIRTY;\n        pcacheAddToDirtyList( p );\n      }\n    }\n\n    /*\n    ** Make sure the page is marked as clean. If it isn\'t clean already,\n    ** make it so.\n    */\n    static void sqlite3PcacheMakeClean( PgHdr p )\n    {\n      if ( ( p.flags & PGHDR_DIRTY ) != 0 )\n      {\n        pcacheRemoveFromDirtyList( p );\n        p.flags &= ~( PGHDR_DIRTY | PGHDR_NEED_SYNC );\n        if ( p.nRef == 0 )\n        {\n          pcacheUnpin( p );\n        }\n      }\n    }\n\n    /*\n    ** Make every page in the cache clean.\n    */\n    static void sqlite3PcacheCleanAll( PCache pCache )\n    {\n      PgHdr p;\n      while ( ( p = pCache.pDirty ) != null )\n      {\n        sqlite3PcacheMakeClean( p );\n      }\n    }\n\n    /*\n    ** Clear the PGHDR_NEED_SYNC flag from all dirty pages.\n    */\n    static void sqlite3PcacheClearSyncFlags( PCache pCache )\n    {\n      PgHdr p;\n      for ( p = pCache.pDirty ; p != null ; p = p.pDirtyNext )\n      {\n        p.flags &= ~PGHDR_NEED_SYNC;\n      }\n      pCache.pSynced = pCache.pDirtyTail;\n    }\n\n    /*\n    ** Change the page number of page p to newPgno.\n    */\n    static void sqlite3PcacheMove( PgHdr p, Pgno newPgno )\n    {\n      PCache pCache = p.pCache;\n      Debug.Assert( p.nRef > 0 );\n      Debug.Assert( newPgno > 0 );\n      sqlite3GlobalConfig.pcache.xRekey( pCache.pCache, p, p.pgno, newPgno );\n      p.pgno = newPgno;\n      if ( ( p.flags & PGHDR_DIRTY ) != 0 && ( p.flags & PGHDR_NEED_SYNC ) != 0 )\n      {\n        pcacheRemoveFromDirtyList( p );\n        pcacheAddToDirtyList( p );\n      }\n    }\n\n    /*\n    ** Drop every cache entry whose page number is greater than "pgno". The\n    ** caller must ensure that there are no outstanding references to any pages\n    ** other than page 1 with a page number greater than pgno.\n    **\n    ** If there is a reference to page 1 and the pgno parameter passed to this\n    ** function is 0, then the data area associated with page 1 is zeroed, but\n    ** the page object is not dropped.\n    */\n    static void sqlite3PcacheTruncate( PCache pCache, u32 pgno )\n    {\n      if ( pCache.pCache != null )\n      {\n        PgHdr p;\n        PgHdr pNext;\n        for ( p = pCache.pDirty ; p != null ; p = pNext )\n        {\n          pNext = p.pDirtyNext;\n          if ( p.pgno > pgno )\n          {\n            Debug.Assert( ( p.flags & PGHDR_DIRTY ) != 0 );\n            sqlite3PcacheMakeClean( p );\n          }\n        }\n        if ( pgno == 0 && pCache.pPage1 != null )\n        {\n          pCache.pPage1.pData = new byte[pCache.szPage];// memset( pCache.pPage1.pData, 0, pCache.szPage );\n          pgno = 1;\n        }\n        sqlite3GlobalConfig.pcache.xTruncate( pCache.pCache, pgno + 1 );\n      }\n    }\n\n    /*\n    ** Close a cache.\n    */\n    static void sqlite3PcacheClose( PCache pCache )\n    {\n      if ( pCache.pCache != null )\n      {\n        sqlite3GlobalConfig.pcache.xDestroy( ref pCache.pCache );\n      }\n    }\n\n    /*\n    ** Discard the contents of the cache.\n    */\n    static void sqlite3PcacheClear( PCache pCache )\n    {\n      sqlite3PcacheTruncate( pCache, 0 );\n    }\n\n\n    /*\n    ** Merge two lists of pages connected by pDirty and in pgno order.\n    ** Do not both fixing the pDirtyPrev pointers.\n    */\n    static PgHdr pcacheMergeDirtyList( PgHdr pA, PgHdr pB )\n    {\n      PgHdr result = new PgHdr();\n      PgHdr pTail = result;\n      while ( pA != null && pB != null )\n      {\n        if ( pA.pgno < pB.pgno )\n        {\n          pTail.pDirty = pA;\n          pTail = pA;\n          pA = pA.pDirty;\n        }\n        else\n        {\n          pTail.pDirty = pB;\n          pTail = pB;\n          pB = pB.pDirty;\n        }\n      }\n      if ( pA != null )\n      {\n        pTail.pDirty = pA;\n      }\n      else if ( pB != null )\n      {\n        pTail.pDirty = pB;\n      }\n      else\n      {\n        pTail.pDirty = null;\n      }\n      return result.pDirty;\n    }\n\n    /*\n    ** Sort the list of pages in accending order by pgno.  Pages are\n    ** connected by pDirty pointers.  The pDirtyPrev pointers are\n    ** corrupted by this sort.\n    **\n    ** Since there cannot be more than 2^31 distinct pages in a database,\n    ** there cannot be more than 31 buckets required by the merge sorter.\n    ** One extra bucket is added to catch overflow in case something\n    ** ever changes to make the previous sentence incorrect.\n    */\n    //#define N_SORT_BUCKET  32\n    const int N_SORT_BUCKET = 32;\n\n    static PgHdr pcacheSortDirtyList( PgHdr pIn )\n    {\n      PgHdr[] a; PgHdr p;//a[N_SORT_BUCKET], p;\n      int i;\n      a = new PgHdr[N_SORT_BUCKET];//memset(a, 0, sizeof(a));\n      while ( pIn != null )\n      {\n        p = pIn;\n        pIn = p.pDirty;\n        p.pDirty = null;\n        for ( i = 0 ; ALWAYS(i <N_SORT_BUCKET - 1) ; i++ )\n        {\n          if ( a[i] == null )\n          {\n            a[i] = p;\n            break;\n          }\n          else\n          {\n            p = pcacheMergeDirtyList( a[i], p );\n            a[i] = null;\n          }\n        }\n        if ( NEVER(i ==N_SORT_BUCKET - 1 ))\n        {\n          /* To get here, there need to be 2^(N_SORT_BUCKET) elements in\n          ** the input list.  But that is impossible.\n          */\n          a[i] = pcacheMergeDirtyList( a[i], p );\n        }\n      }\n      p = a[0];\n      for ( i = 1 ; i <N_SORT_BUCKET ; i++ )\n      {\n        p = pcacheMergeDirtyList( p, a[i] );\n      }\n      return p;\n    }\n\n    /*\n    ** Return a list of all dirty pages in the cache, sorted by page number.\n    */\n    static PgHdr sqlite3PcacheDirtyList( PCache pCache )\n    {\n      PgHdr p;\n      for ( p = pCache.pDirty ; p != null ; p = p.pDirtyNext )\n      {\n        p.pDirty = p.pDirtyNext;\n      }\n      return pcacheSortDirtyList( pCache.pDirty );\n    }\n\n    /*\n    ** Return the total number of referenced pages held by the cache.\n    */\n    static int sqlite3PcacheRefCount( PCache pCache )\n    {\n      return pCache.nRef;\n    }\n\n    /*\n    ** Return the number of references to the page supplied as an argument.\n    */\n    static int sqlite3PcachePageRefcount( PgHdr p )\n    {\n      return p.nRef;\n    }\n\n    /*\n    ** Return the total number of pages in the cache.\n    */\n    static int sqlite3PcachePagecount( PCache pCache )\n    {\n      int nPage = 0;\n      if ( pCache.pCache != null )\n      {\n        nPage = sqlite3GlobalConfig.pcache.xPagecount( pCache.pCache );\n      }\n      return nPage;\n    }\n\n#if SQLITE_TEST\n    /*\n** Get the suggested cache-size value.\n*/\n    static int sqlite3PcacheGetCachesize( PCache pCache )\n    {\n      return pCache.nMax;\n    }\n#endif\n\n    /*\n** Set the suggested cache-size value.\n*/\n    static void sqlite3PcacheSetCachesize( PCache pCache, int mxPage )\n    {\n      pCache.nMax = mxPage;\n      if ( pCache.pCache != null )\n      {\n        sqlite3GlobalConfig.pcache.xCachesize( pCache.pCache, mxPage );\n      }\n    }\n\n#if SQLITE_CHECK_PAGES  || (SQLITE_DEBUG)\n/*\n** For all dirty pages currently in the cache, invoke the specified\n** callback. This is only used if the SQLITE_CHECK_PAGES macro is\n** defined.\n*/\n    static void sqlite3PcacheIterateDirty( PCache pCache, dxIter xIter )\n    {\n      PgHdr pDirty;\n      for ( pDirty = pCache.pDirty ; pDirty != null ; pDirty = pDirty.pDirtyNext )\n      {\n        xIter( pDirty );\n      }\n    }\n#endif\n  }\n}\n'