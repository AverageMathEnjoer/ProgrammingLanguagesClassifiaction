b'\xef\xbb\xbf// Chapter 14 covers SVD (Singular Value Decomposition),\n// and how to use it for a Collaborative Recommendation Engine\n \n#r @"..\\..\\MachineLearningInAction\\packages\\MathNet.Numerics.2.5.0\\lib\\net40\\MathNet.Numerics.dll"\n#r @"..\\..\\MachineLearningInAction\\packages\\MathNet.Numerics.FSharp.2.5.0\\lib\\net40\\MathNet.Numerics.FSharp.dll"\n\nopen System\nopen MathNet.Numerics.LinearAlgebra\nopen MathNet.Numerics.LinearAlgebra.Generic\nopen MathNet.Numerics.LinearAlgebra.Double\nopen MathNet.Numerics.Statistics\n\n// Imagine we have users, with a database of movie ratings\n\ntype UserId = int\ntype MovieId = int\ntype Rating = { UserId:UserId; MovieId:MovieId; Rating:int }\n\n// Let\'s imagine that we have 3 types of movies:\n// Action, Romance, Documentary\n// and 3 types of viewers, who only like 1 type of Movie.\n// Let\'s imagine that \n// movies 0 to 3 are Action, \n// movies 4 to 7 are Romance, and \n// movies 8 to 11 are Documentary\n\n// "User Templates":\n//                Action .... Romance ... Documentary . \nlet profile1 = [| 5; 4; 5; 4; 1; 1; 2; 1; 2; 1; 1; 1 |]\nlet profile2 = [| 1; 2; 1; 1; 4; 5; 5; 4; 1; 1; 1; 2 |]\nlet profile3 = [| 1; 1; 1; 2; 2; 2; 1; 1; 4; 5; 5; 5 |]\nlet profiles = [ profile1; profile2; profile3 ]\n\n// Let\'s create a fake "synthetic dataset" from these 3 profiles\nlet rng = Random()\nlet proba = 0.4 // probability a movie was rated\n// create fake ratings for a fake user,\n// using the profile and id supplied\nlet createFrom profile userId =\n    profile \n    |> Array.mapi (fun movieId rating -> \n        if rng.NextDouble() < proba \n        then Some({ UserId=userId; MovieId=movieId; Rating=rating }) \n        else None)\n    |> Array.choose id\n\n// Example: create ratings for user 42, who likes Romance\nlet romanceUser = createFrom profile2 42\n\n// We generate 100 "fake" users and their ratings\nlet sampleSize = 100\nlet ratings = [\n    for i in 0 .. (sampleSize - 1) do \n        yield! createFrom (profiles.[rng.Next(0, 3)]) i \n    ]\n\nlet movies = 12\nlet movieIds = [ 0 .. (movies - 1) ]\n\n// We are set - let\'s start working\n// and pull this sample into a data Matrix\nlet data = DenseMatrix(sampleSize, movies) \nfor rating in ratings do\n    data.[rating.UserId, rating.MovieId] <- Convert.ToDouble(rating.Rating)\n\n// user 3 is now in row 3:\nlet fakeUser3 = data.Row(3)\nprintfn "User 3 ratings: %A" (fakeUser3 |> Seq.toList)\n\n// To compute recommendations for a user\n// we will need to know the rating (if it exists) \n// a user gave a movie, and\n// how "similar" 2 movies are. \ntype userRating = UserId -> MovieId -> float option\ntype movieSimilarity = MovieId -> MovieId -> float\n\n/// Compute weighted average of a sequence of (value, weight)\nlet weightedAverage (data: (float * float) seq) = \n    let weightedTotal, totalWeights = \n        Seq.fold (fun (R,S) (r, s) -> \n            (R + r * s, S + s)) (0., 0.) data\n    if (totalWeights <= 0.) \n    then None \n    else Some(weightedTotal/totalWeights)\n\n/// Estimate the rating for an unrated movie:\n/// by averaging known ratings, weighted by\n/// how similar they are to the movie.\nlet estimate (similarity:movieSimilarity) \n             (rating:userRating) \n             (sample:MovieId seq) \n             (userId:UserId) \n             (movieId:MovieId) = \n    match (rating userId movieId) with\n    | Some(_) -> None // already rated\n    | None ->\n        sample\n        // for all rated movies, get rating\n        // and similarity\n        |> Seq.choose (fun id -> \n            let r = rating userId id\n            match r with\n            | None -> None\n            | Some(value) -> Some(value, (similarity movieId id)))\n        |> weightedAverage\n\n/// Recommend movies: estimate rating for\n/// all unrated movies and sort them \n/// by decreasing rating.\nlet recommend (similarity:movieSimilarity) \n              (rating:userRating) \n              (sample:MovieId seq) \n              (userId:UserId) =\n    sample\n    |> Seq.map (fun movieId -> \n        movieId, estimate similarity rating sample userId movieId)\n    |> Seq.choose (fun (movieId, r) -> \n        match r with | None -> None | Some(value) -> Some(movieId, value))\n    |> Seq.sortBy (fun (movieId, rating) -> - rating)\n    |> Seq.toList\n\n// Now let\'s build a naive recommender\n\n// To make recommendations we need a similarity measure\ntype similarity = Vector<float> -> Vector<float> -> float\n\n// Larger distances imply lower similarity\nlet euclideanSimilarity (v1: Vector<float>) (v2: Vector<float>) =\n    1. / (1. + (v1 - v2).Norm(2.))\n\n// Similarity based on the angle\nlet cosineSimilarity (v1: Vector<float>) v2 =\n    v1.DotProduct(v2) / (v1.Norm(2.) * v2.Norm(2.))\n\n// Similarity based on the Pearson correlation\nlet pearsonSimilarity (v1: Vector<float>) v2 =\n    if v1.Count > 2 \n    then 0.5 + 0.5 * Correlation.Pearson(v1, v2)\n    else 1.\n\n// Reduce 2 vectors to their non-zero pairs\nlet nonZeroes (v1:Vector<float>) \n              (v2:Vector<float>) =\n    // Grab non-zero pairs of ratings \n    let size = v1.Count\n    let overlap =\n        [| for i in 0 .. (size - 1) do\n            if v1.[i] > 0. && v2.[i] > 0. \n            then yield (v1.[i], v2.[i]) |]\n    // Recompose vectors if there is something left\n    if overlap.Length = 0\n    then None\n    else \n        let v1\', v2\' = Array.unzip overlap\n        Some(DenseVector(v1\'), DenseVector(v2\'))\n\n// "Simple" similarity: keep only users that\n// have rated both movies, and compare.\nlet simpleSimilarity (s:similarity) =\n    fun (movie1:MovieId) (movie2:MovieId) ->\n        let v1, v2 = data.Column(movie1), data.Column(movie2)\n        let overlap = nonZeroes v1 v2\n        match overlap with\n        | None -> 0.\n        | Some(v1\', v2\') -> s v1\' v2\'\n\n// Return rating from data matrix, captured in closure\nlet simpleRating (userId:UserId) (movieId:MovieId) =\n    let rating = data.[userId, movieId]\n    if rating = 0. then None else Some(rating)\n\n// Wire everything together: return a function\n// that will produce a recommendation, based\n// on whatever similarity function it is given\nlet simpleRecommender (s:similarity) =\n    fun (userId:UserId) -> \n        recommend (simpleSimilarity s)\n                  simpleRating\n                  movieIds \n                  userId\n\n// Illustration / usage\nlet simpleEuclidean = simpleRecommender euclideanSimilarity\nlet simpleCosine = simpleRecommender cosineSimilarity\nlet simplePearson = simpleRecommender pearsonSimilarity\n\nlet someUser = 42 // random user\nlet hisProfile = data.Row(someUser) |> Seq.toList\nprintfn "User ratings: %A" hisProfile\nprintfn "Simple recommendation"\nprintfn "Recommendation, Euclidean: %A" (simpleEuclidean someUser)\nprintfn "Recommendation, Cosine: %A" (simpleCosine someUser)\nprintfn "Recommendation, Pearson: %A" (simplePearson someUser)\n\n// SVD based approach\n\n// We\'ll retain only the largest values in the Sigma vector,\n// (the diagonal of the S-matrix), which capture more than\n// a given percentage of the "energy". \nlet valuesForEnergy (min:float) (sigmas:Vector<float>) =\n    let totalEnergy = sigmas.DotProduct(sigmas)\n    let rec search i accEnergy =\n        let x = sigmas.[i]\n        let energy = x * x\n        let percent = (accEnergy + energy)/totalEnergy\n        match (percent >= min) with\n        | true -> i\n        | false -> search (i + 1) (accEnergy + energy)\n    search 0 0.\n\nlet energy = 0.9 // arbitrary threshold\n\n// Instead of comparing the columns / movies,\n// we\'ll compare their projection using SVD,\n// removing the less significant criteria\nlet data\' =\n    let svd = data.Svd(true)\n    let U, sigmas = svd.U(), svd.S()\n    let subset = valuesForEnergy energy sigmas\n    let U\' = U.SubMatrix(0, U.RowCount, 0, subset)\n    let S\' = DiagonalMatrix(subset, subset, sigmas.SubVector(0, (subset)).ToArray())\n\n    (data.Transpose() * U\' * S\').Transpose()\n\n// We can now compare similarity directly\n// off the data\' matrix computed by SVD\nlet svdSimilarity (s:similarity) =\n    fun (movie1:MovieId) (movie2:MovieId) ->\n        let v1, v2 = data\'.Column(movie1), data\'.Column(movie2)\n        s v1 v2\n\n// We can now create a recommender based off SVD similarity\nlet svdRecommender (s:similarity) =\n    fun (userId:UserId) -> \n        recommend (svdSimilarity s)\n                  simpleRating\n                  movieIds \n                  userId\n\n// Illustration, on same user profile as before\nlet svdEuclidean = svdRecommender euclideanSimilarity\nlet svdCosine = svdRecommender cosineSimilarity\nlet svdPearson = svdRecommender pearsonSimilarity\n\nlet sameUser = someUser\nlet sameProfile = data.Row(sameUser)\nprintfn "SVD-based recommendation"\nprintfn "Recommendation, Euclidean: %A" (svdEuclidean someUser)\nprintfn "Recommendation, Cosine: %A" (svdCosine someUser)\nprintfn "Recommendation, Pearson: %A" (svdPearson someUser)'