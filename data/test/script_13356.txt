b'// I2Cdev library collection - L3GD20H I2C device class\n// Based on STMicroelectronics L3GD20H datasheet rev. 2, 3/2013\n// 3/05/2015 by Nate Costello <natecostello at gmail dot com>\n// Updates should (hopefully) always be available at https://github.com/jrowberg/i2cdevlib\n//\n// Changelog:\n//     2015-03-05 - initial release\n\n/* ============================================\nI2Cdev device library code is placed under the MIT license\nCopyright (c) 2011 Jonathan Arnett, Jeff Rowberg\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the "Software"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n===============================================\n*/\n\n#include "L3GD20H.h"\n\n/** Default constructor, uses default I2C address.\n * @see L3GD20H_DEFAULT_ADDRESS\n */\nL3GD20H::L3GD20H() {\n    devAddr = L3GD20H_DEFAULT_ADDRESS;\n    endianMode = 0;\n}\n\n/** Specific address constructor.\n * @param address I2C address\n * @see L3GD20H_DEFAULT_ADDRESS\n * @see L3GD20H_ADDRESS\n */\nL3GD20H::L3GD20H(uint8_t address) {\n    devAddr = address;\n    endianMode = 0;\n}\n\n/** Power on and prepare for general usage.\n * All values are defaults except for the power on bit in CTRL_1\n * @see L3GD20H_RA_CTRL1\n * @see L3GD20H_RA_CTRL2\n * @see L3GD20H_RA_CTRL3\n * @see L3GD20H_RA_CTRL4\n * @see L3GD20H_RA_CTRL5\n */\nvoid L3GD20H::initialize() {\n\tI2Cdev::writeByte(devAddr, L3GD20H_RA_CTRL1, 0b00001111);\n    I2Cdev::writeByte(devAddr, L3GD20H_RA_CTRL2, 0b00000000);\n    I2Cdev::writeByte(devAddr, L3GD20H_RA_CTRL3, 0b00000000);\n    I2Cdev::writeByte(devAddr, L3GD20H_RA_CTRL4, 0b00000000);\n    I2Cdev::writeByte(devAddr, L3GD20H_RA_CTRL5, 0b00000000);\n}\n\n/** Verify the I2C connection.\n * Make sure the device is connected and responds as expected.\n * @return True if connection is valid, false otherwise\n */\nbool L3GD20H::testConnection() {\n    return getDeviceID() == 0b11010111;\n}\n\n// WHO_AM_I register, read-only\n\n/** Get the Device ID.\n * The WHO_AM_I register holds the device\'s id\n * @return Device ID (should be 0b11010011, 109, 0x69)\n * @see L3GD20H_RA_WHO_AM_I\n */\nuint8_t L3GD20H::getDeviceID() {\n    I2Cdev::readByte(devAddr, L3GD20H_RA_WHO_AM_I, buffer);\n    return buffer[0];\n}\n\n// CTRL1 register, r/w\n\n/** Set the output data rate.  Makes use of the setLowODREnabled function.\n * @param rate The new data output rate (can be 12, 25, 50, 100, 200, 400, or 800)\n * @see L3GD20H_RA_CTRL1\n * @see L3GD20H_ODR_BIT\n * @see L3GD20H_ODR_LENGTH\n * @see L3GD20H_RATE_100_12\n * @see L3GD20H_RATE_200_25\n * @see L3GD20H_RATE_400_50\n * @see L3GD20H_RATE_800_50\n * @see L3GD20H_RA_LOW_ODR\n * @see L3GD20H_LOW_ODR_BIT\n */\nvoid L3GD20H::setOutputDataRate(uint16_t rate) {\n\tuint8_t writeVal;\n\tbool lowODRwriteVal;\n\n\tif (rate ==12) {\n\t\twriteVal = L3GD20H_RATE_100_12;\n\t\tsetLowODREnabled(true);\n\t} else if (rate == 25) {\n\t\twriteVal = L3GD20H_RATE_200_25;\n\t\tsetLowODREnabled(true);\n\t} else if (rate == 50) {\n\t\twriteVal = L3GD20H_RATE_400_50;\n\t\tsetLowODREnabled(true);\n\t} else if (rate == 100) {\n\t\twriteVal = L3GD20H_RATE_100_12;\n\t\tsetLowODREnabled(false);\n\t} else if (rate == 200) {\n\t\twriteVal = L3GD20H_RATE_200_25;\n\t\tsetLowODREnabled(false);\n\t} else if (rate == 400) {\n\t\twriteVal = L3GD20H_RATE_400_50;\n\t\tsetLowODREnabled(false);\n\t} else {\n\t\twriteVal = L3GD20H_RATE_800_50;\n\t\tsetLowODREnabled(false);\n\t}\n\t\n\tI2Cdev::writeBits(devAddr, L3GD20H_RA_CTRL1, L3GD20H_ODR_BIT,\n\t\tL3GD20H_ODR_LENGTH, writeVal); \n}\n\n/** Get the current output data rate\n * @return Current data output rate\n * @see L3GD20H_RA_CTRL1\n * @see L3GD20H_ODR_BIT\n * @see L3GD20H_ODR_LENGTH\n * @see L3GD20H_RATE_100_12\n * @see L3GD20H_RATE_200_25\n * @see L3GD20H_RATE_400_50\n * @see L3GD20H_RATE_800_50\n * @see L3GD20H_RA_LOW_ODR\n * @see L3GD20H_LOW_ODR_BIT\n */\nuint16_t L3GD20H::getOutputDataRate() {\n\tI2Cdev::readBits(devAddr, L3GD20H_RA_CTRL1, L3GD20H_ODR_BIT, \n\t\tL3GD20H_ODR_LENGTH, buffer);\n\tuint8_t rate = buffer[0];\n\n\tif (rate == L3GD20H_RATE_100_12) {\n\t\tif (getLowODREnabled() == true) {\n\t\t\treturn 12;\n\t\t} else {\n\t\t\treturn 100;\t\n\t\t}\n\t} else if (rate == L3GD20H_RATE_200_25) {\n\t\tif (getLowODREnabled() == true) {\n\t\t\treturn 25;\n\t\t} else {\n\t\t\treturn 200;\n\t\t}\n\t} else if (rate == L3GD20H_RATE_400_50) {\n\t\tif (getLowODREnabled() == true) {\n\t\t\treturn 50;\n\t\t} else {\n\t\t\treturn 400;\n\t\t}\n\t} else if (rate == L3GD20H_RATE_800_50) {\n\t\tif (getLowODREnabled() == true) {\n\t\t\treturn 50;\n\t\t} else {\n\t\t\treturn 800;\n\t\t}\n\t}\n\treturn 800;\n}\n\n/** Set the bandwidth cut-off mode\n * @param mode The new bandwidth cut-off mode\n * @see L3GD20H_RA_CTRL1\n * @see L3GD20H_BW_BIT\n * @see L3GD20H_BW_LENGTH\n * @see L3GD20H_BW_LOW\n * @see L3GD20H_BW_MED_LOW\n * @see L3GD20H_BW_MED_HIGH\n * @see L3GD20H_BW_HIGH\n */\nvoid L3GD20H::setBandwidthCutOffMode(uint8_t mode) {\n\tI2Cdev::writeBits(devAddr, L3GD20H_RA_CTRL1, L3GD20H_BW_BIT, \n\t\tL3GD20H_BW_LENGTH, mode);\n}\n\n/** Get the current bandwidth cut-off mode\n * @return Current bandwidth cut off mode\n * @see L3GD20H_RA_CTRL1\n * @see L3GD20H_BW_BIT\n * @see L3GD20H_BW_LENGTH\n * @see L3GD20H_BW_LOW\n * @see L3GD20H_BW_MED_LOW\n * @see L3GD20H_BW_MED_HIGH\n * @see L3GD20H_BW_HIGH\n */\nuint8_t L3GD20H::getBandwidthCutOffMode() {\n\tI2Cdev::readBits(devAddr, L3GD20H_RA_CTRL1, L3GD20H_BW_BIT, \n\t\tL3GD20H_BW_LENGTH, buffer);\n\treturn buffer[0];\n}\n\n// /** Gets the current bandwidth cutoff based on ODR and BW\n//  * @return Float value of the bandwidth cut off\n//  * @see L3GD20H_RA_CTRL1\n//  * @see L3GD20H_ODR_BIT\n//  * @see L3GD20H_ODR_LENGTH\n//  * @see L3GD20H_RATE_100_12\n//  * @see L3GD20H_RATE_200_25\n//  * @see L3GD20H_RATE_400_50\n//  * @see L3GD20H_RATE_800_50\n//  * @see L3GD20H_BW_BIT\n//  * @see L3GD20H_BW_LENGTH\n//  * @see L3GD20H_BW_LOW\n//  * @see L3GD20H_BW_MED_LOW\n//  * @see L3GD20H_BW_MED_HIGH\n//  * @see L3GD20H_BW_HIGH\n//  */\n// float L3GD20H::getBandwidthCutOff() {\n// \tuint16_t dataRate = getOutputDataRate();\n// \tuint8_t bandwidthMode = getBandwidthCutOffMode();\n\n// \tif (dataRate == 50) {\n// \t\treturn 16.6;\n// \t} else if (dataRate == 100) {\n// \t\tif (bandwidthMode == L3GD20H_BW_LOW) {\n// \t\t\treturn 12.5;\n// \t\t} else {\n// \t\t\treturn 25.0;\n// \t\t}\n// \t} else if (dataRate == 200) {\n// \t\tif (bandwidthMode == L3GD20H_BW_LOW) {\n// \t\t\treturn 12.5;\n// \t\t} else if (bandwidthMode == L3GD20H_BW_MED_LOW) {\n// \t\t\treturn 0.0;\n// \t\t} else if (bandwidthMode == L3GD20H_BW_MED_HIGH) {\n// \t\t\treturn 0.0;\n// \t\t} else {\n// \t\t\treturn 70.0;\n// \t\t}\n// \t} else if (dataRate == 400) {\n// \t\tif (bandwidthMode == L3GD20H_BW_LOW) {\n// \t\t\treturn 20.0;\n// \t\t} else if (bandwidthMode == L3GD20H_BW_MED_LOW) {\n// \t\t\treturn 25.0;\n// \t\t} else if (bandwidthMode == L3GD20H_BW_MED_HIGH) {\n// \t\t\treturn 50.0;\n// \t\t} else {\n// \t\t\treturn 110.0;\n// \t\t}\n// \t} else if (dataRate == 800) {\n// \t\tif (bandwidthMode == L3GD20H_BW_LOW) {\n// \t\t\treturn 30.0;\n// \t\t} else if (bandwidthMode == L3GD20H_BW_MED_LOW) {\n// \t\t\treturn 35.0;\n// \t\t} else if (bandwidthMode == L3GD20H_BW_MED_HIGH) {\n// \t\t\treturn 0.0;\n// \t\t} else {\n// \t\t\treturn 110.0;\n// \t\t}\n// \t} else {\n// \t\treturn 0.0\n// \t}\n// }\n\n/** Set power on or off\n * @param enabled The new power setting (true for on, false for off)\n * @see L3GD20H_RA_CTRL1\n * @see L3GD20H_PD_BIT\n */\nvoid L3GD20H::setPowerOn(bool on) {\n\tI2Cdev::writeBit(devAddr, L3GD20H_RA_CTRL1, L3GD20H_PD_BIT, on);\n}\n\n/** Get the current power state\n * @return Powered on state (true for on, false for off)\n * @see L3GD20H_RA_CTRL1\n * @see L3GD20H_PD_BIT\n */\nbool L3GD20H::getPowerOn() {\n\tI2Cdev::readBit(devAddr, L3GD20H_RA_CTRL1, L3GD20H_PD_BIT, buffer);\n\treturn buffer[0];\n}\n\n/** Enables or disables the ability to get Z data\n * @param enabled The new enabled state of the Z axis\n * @see L3GD20H_RA_CTRL1\n * @see L3GD20H_ZEN_BIT\n */\nvoid L3GD20H::setZEnabled(bool enabled) {\n\tI2Cdev::writeBit(devAddr, L3GD20H_RA_CTRL1, L3GD20H_ZEN_BIT, enabled);\n}\n\n/** Get whether Z axis data is enabled\n * @return True if the Z axis is enabled, false otherwise\n * @see L3GD20H_RA_CTRL1\n * @see L3GD20H_ZEN_BIT\n */\nbool L3GD20H::getZEnabled() {\n\tI2Cdev::readBit(devAddr, L3GD20H_RA_CTRL1, L3GD20H_ZEN_BIT, buffer);\n\treturn buffer[0];\n}\n\n/** Enables or disables the ability to get Y data\n * @param enabled The new enabled state of the Y axis\n * @see L3GD20H_RA_CTRL1\n * @see L3GD20H_YEN_BIT\n */\nvoid L3GD20H::setYEnabled(bool enabled) {\n\tI2Cdev::writeBit(devAddr, L3GD20H_RA_CTRL1, L3GD20H_YEN_BIT, enabled);\n}\n\n/** Get whether Y axis data is enabled\n * @return True if the Y axis is enabled, false otherwise\n * @see L3GD20H_RA_CTRL1\n * @see L3GD20H_YEN_BIT\n */\nbool L3GD20H::getYEnabled() {\n\tI2Cdev::readBit(devAddr, L3GD20H_RA_CTRL1, L3GD20H_YEN_BIT, buffer);\n\treturn buffer[0];\n}\n\n/** Enables or disables the ability to get X data\n * @param enabled The new enabled state of the X axis\n * @see L3GD20H_RA_CTRL1\n * @see L3GD20H_XEN_BIT\n */\nvoid L3GD20H::setXEnabled(bool enabled) {\n\tI2Cdev::writeBit(devAddr, L3GD20H_RA_CTRL1, L3GD20H_XEN_BIT, enabled);\n}\n\n/** Get whether X axis data is enabled\n * @return True if the X axis is enabled, false otherwise\n * @see L3GD20H_RA_CTRL1\n * @see L3GD20H_XEN_BIT\n */\nbool L3GD20H::getXEnabled() {\n\tI2Cdev::readBit(devAddr, L3GD20H_RA_CTRL1, L3GD20H_XEN_BIT, buffer);\n\treturn buffer[0];\n}\n\n// CTRL2 register, r/w\n\n/** Set the high pass mode\n * @param mode The new high pass mode\n * @see L3GD20H_RA_CTRL2\n * @see L3GD20H_HPM_BIT\n * @see L3GD20H_HPM_LENGTH\n * @see L3GD20H_HPM_HRF\n * @see L3GD20H_HPM_REFERENCE\n * @see L3GD20H_HPM_NORMAL\n * @see L3GD20H_HPM_AUTORESET\n */\nvoid L3GD20H::setHighPassMode(uint8_t mode) {\n\tI2Cdev::writeBits(devAddr, L3GD20H_RA_CTRL2, L3GD20H_HPM_BIT, \n\t\tL3GD20H_HPM_LENGTH, mode);\n}\n\n/** Get the high pass mode\n * @return High pass mode\n * @see L3GD20H_RA_CTRL2\n * @see L3GD20H_HPM_BIT\n * @see L3GD20H_HPM_LENGTH\n * @see L3GD20H_HPM_HRF\n * @see L3GD20H_HPM_REFERENCE\n * @see L3GD20H_HPM_NORMAL\n * @see L3GD20H_HPM_AUTORESET\n */\nuint8_t L3GD20H::getHighPassMode() {\n\tI2Cdev::readBits(devAddr, L3GD20H_RA_CTRL2, L3GD20H_HPM_BIT, \n\t\tL3GD20H_HPM_LENGTH, buffer);\n\treturn buffer[0];\n}\n\n/** Set the high pass filter cut off frequency level (1 - 10)\n * @param level The new level for the hpcf, using one of the defined levels\n * @see L3GD20H_RA_CTRL2\n * @see L3GD20H_HPCF_BIT\n * @see L3GD20H_HPCF_LENGTH\n * @see L3GD20H_HPCF1\n * @see L3GD20H_HPCF2\n * @see L3GD20H_HPCF3\n * @see L3GD20H_HPCF4\n * @see L3GD20H_HPCF5\n * @see L3GD20H_HPCF6\n * @see L3GD20H_HPCF7\n * @see L3GD20H_HPCF8\n * @see L3GD20H_HPCF9\n * @see L3GD20H_HPCF10\n */\nvoid L3GD20H::setHighPassFilterCutOffFrequencyLevel(uint8_t level) {\n\tI2Cdev::writeBits(devAddr, L3GD20H_RA_CTRL2, L3GD20H_HPCF_BIT, \n\t\tL3GD20H_HPCF_LENGTH, level);\n}\n\n/** Get the high pass filter cut off frequency level (1 - 10)\n * @return High pass filter cut off frequency level\n * @see L3GD20H_RA_CTRL2\n * @see L3GD20H_HPCF_BIT\n * @see L3GD20H_HPCF_LENGTH\n * @see L3GD20H_HPCF1\n * @see L3GD20H_HPCF2\n * @see L3GD20H_HPCF3\n * @see L3GD20H_HPCF4\n * @see L3GD20H_HPCF5\n * @see L3GD20H_HPCF6\n * @see L3GD20H_HPCF7\n * @see L3GD20H_HPCF8\n * @see L3GD20H_HPCF9\n * @see L3GD20H_HPCF10\n */\nuint8_t L3GD20H::getHighPassFilterCutOffFrequencyLevel() {\n\tI2Cdev::readBits(devAddr, L3GD20H_RA_CTRL2, L3GD20H_HPCF_BIT, \n\t\tL3GD20H_HPCF_LENGTH, buffer);\n\treturn buffer[0];\n}\n\n// CTRL3 register, r/w\n\n/** Set the INT1 interrupt enabled state\n * @param enabled New enabled state for the INT1 interrupt\n * @see L3GD20H_RA_CTRL3\n * @see L3GD20H_INT1_IG_BIT\n */\nvoid L3GD20H::setINT1InterruptEnabled(bool enabled) {\n\tI2Cdev::writeBit(devAddr, L3GD20H_RA_CTRL3, L3GD20H_INT1_IG_BIT, \n\t\tenabled);\n}\n\n/** Get the INT1 interrupt enabled state\n * @return True if the INT1 interrupt is enabled, false otherwise\n * @see L3GD20H_RA_CTRL3\n * @see L3GD20H_INT1_IG_BIT\n */\nbool L3GD20H::getINT1InterruptEnabled() {\n\tI2Cdev::readBit(devAddr, L3GD20H_RA_CTRL3, L3GD20H_INT1_IG_BIT, \n\t\tbuffer);\n\treturn buffer[0];\n}\n\n/** Set the INT1 boot status enabled state\n * @param enabled New enabled state for the INT1 boot status\n * @see L3GD20H_RA_CTRL3\n * @see L3GD20H_INT1_BOOT_BIT\n */\nvoid L3GD20H::setINT1BootStatusEnabled(bool enabled) {\n\tI2Cdev::writeBit(devAddr, L3GD20H_RA_CTRL3, L3GD20H_INT1_BOOT_BIT, \n\t\tenabled);\n}\n\n/** Get the INT1 boot status enabled state\n * @return INT1 boot status status\n * @see L3GD20H_RA_CTRL3\n * @see L3GD20H_INT1_BOOT_BIT\n */\nbool L3GD20H::getINT1BootStatusEnabled() {\n\tI2Cdev::readBit(devAddr, L3GD20H_RA_CTRL3, L3GD20H_INT1_BOOT_BIT, \n\t\tbuffer);\n\treturn buffer[0];\n}\n\n/** Interrupts the active INT1 configuration\n * @see L3GD20H_RA_CTRL3\n * @see L3GD20H_H_LACTIVE_BIT\n */\nvoid L3GD20H::interruptActiveINT1Config() {\n\tI2Cdev::writeBit(devAddr, L3GD20H_RA_CTRL3, L3GD20H_H_LACTIVE_BIT, 1);\n}\n\n/** Set output mode to push-pull or open-drain\n * @param mode New output mode\n * @see L3GD20H_RA_CTRL3\n * @see L3GD20H_PP_OD_BIT\n * @see L3GD20H_PUSH_PULL\n * @see L3GD20H_OPEN_DRAIN\n */\nvoid L3GD20H::setOutputMode(bool mode) {\n\tI2Cdev::writeBit(devAddr, L3GD20H_RA_CTRL3, L3GD20H_PP_OD_BIT, \n\t\tmode);\n}\n\n/** Get whether mode is push-pull or open drain\n * @return Output mode (TRUE for open-drain, FALSE for push-pull)\n * @see L3GD20H_RA_CTRL3\n * @see L3GD20H_PP_OD_BIT\n * @see L3GD20H_PUSH_PULL\n * @see L3GD20H_OPEN_DRAIN\n */\nbool L3GD20H::getOutputMode() {\n\tI2Cdev::readBit(devAddr, L3GD20H_RA_CTRL3, L3GD20H_PP_OD_BIT, \n\t\tbuffer);\n\treturn buffer[0];\n}\n\n/** Set data ready interrupt enabled state on INT2 pin\n * @param enabled New INT2 data ready interrupt enabled state\n * @see L3GD20H_RA_CTRL3\n * @see L3GD20H_INT2_DRDY_BIT\n */\nvoid L3GD20H::setINT2DataReadyEnabled(bool enabled) {\n\tI2Cdev::writeBit(devAddr, L3GD20H_RA_CTRL3, L3GD20H_INT2_DRDY_BIT, \n\t\tenabled);\n}\n\n/** Get whether the data ready interrupt is enabled on the INT2 pin\n * @return True if the INT2 data ready interrupt is enabled, false otherwise\n * @see L3GD20H_RA_CTRL3\n * @see L3GD20H_INT2_DRDY_BIT\n */\nbool L3GD20H::getINT2DataReadyEnabled() {\n\tI2Cdev::readBit(devAddr, L3GD20H_RA_CTRL3, L3GD20H_INT2_DRDY_BIT, \n\t\tbuffer);\n\treturn buffer[0];\n}\n\n/** Set whether the INT2 FIFO threshold (watermark) interrupt is enabled\n * The sensor contains a 32-slot FIFO buffer for storing data so that it may be \n * read later. If enabled, the sensor will generate an interrupt on the \n * INT2/DRDY pin when the threshold has been reached. The threshold can be \n * configured through the setFIFOWatermark function.\n * @param enabled New enabled state of the INT2 FIFO threshold (watermark)\n * @see L3GD20H_RA_CTRL3\n * @see L3GD20H_I2_WTM_BIT\n */\nvoid L3GD20H::setINT2FIFOWatermarkInterruptEnabled(bool enabled) {\n\tI2Cdev::writeBit(devAddr, L3GD20H_RA_CTRL3, L3GD20H_INT2_FTH_BIT, \n\t\tenabled);\n}\n\n/** Get the INT2 FIFO threshold (watermark) interrupt enabled state\n * @return true if the FIFO watermark is enabled, false otherwise\n * @see L3GD20H_RA_CTRL3\n * @see L3GD20H_INT2_FTH_BIT\n */ \nbool L3GD20H::getINT2FIFOWatermarkInterruptEnabled() {\n\tI2Cdev::readBit(devAddr, L3GD20H_RA_CTRL3, L3GD20H_INT2_FTH_BIT, \n\t\tbuffer);\n\treturn buffer[0];\n}\n\n/** Set whether an interrupt is triggered on INT2 when the FIFO is overrun\n * @param enabled New FIFO overrun interrupt enabled state\n * @see L3GD20H_RA_CTRL3\n * @see L3GD20H_INT2_ORUN_BIT\n */\nvoid L3GD20H::setINT2FIFOOverrunInterruptEnabled(bool enabled) {\n\tI2Cdev::writeBit(devAddr, L3GD20H_RA_CTRL3, L3GD20H_INT2_ORUN_BIT, \n\t\tenabled);\n}\n\n/** Get whether an interrupt is triggered on INT2 when the FIFO is overrun\n * @return True if the INT2 FIFO overrun interrupt is enabled, false otherwise\n * @see L3GD20H_RA_CTRL3\n * @see L3GD20H_INT2_ORUN_BIT\n */\nbool L3GD20H::getINT2FIFOOverrunInterruptEnabled() {\n\tI2Cdev::readBit(devAddr, L3GD20H_RA_CTRL3, L3GD20H_INT2_ORUN_BIT,\n\t\tbuffer);\n\treturn buffer[0];\n}\n\n/** Set whether an interrupt is triggered on INT2 when the FIFO buffer is empty\n * @param enabled New INT2 FIFO empty interrupt state\n * @see L3GD20H_RA_CTRL3\n * @see L3GD20H_INT2_EMPTY_BIT\n */\nvoid L3GD20H::setINT2FIFOEmptyInterruptEnabled(bool enabled) {\n\tI2Cdev::writeBit(devAddr, L3GD20H_RA_CTRL3, L3GD20H_INT2_EMPTY_BIT, \n\t\tenabled);\n}\n\n/** Get whether the INT2 FIFO empty interrupt is enabled\n * @returns True if the INT2 FIFO empty interrupt is enabled, false otherwise\n * @see L3GD20H_RA_CTRL3\n * @see L3GD20H_INT2_EMPTY_BIT\n */\nbool L3GD20H::getINT2FIFOEmptyInterruptEnabled() {\n\tI2Cdev::readBit(devAddr, L3GD20H_RA_CTRL3, L3GD20H_INT2_EMPTY_BIT, \n\t\tbuffer);\n\treturn buffer[0];\n}\n\n// CTRL4 register, r/w\n\n/** Set the Block Data Update (BDU) enabled state\n * @param enabled New BDU enabled state\n * @see L3GD20H_RA_CTRL4\n * @see L3GD20H_BDU_BIT\n */\nvoid L3GD20H::setBlockDataUpdateEnabled(bool enabled) {\n\tI2Cdev::writeBit(devAddr, L3GD20H_RA_CTRL4, L3GD20H_BDU_BIT, enabled);\n}\n\n/** Get the BDU enabled state\n * @return True if Block Data Update is enabled, false otherwise\n * @see L3GD20H_RA_CTRL4\n * @see L3GD20H_BDU_BIT\n */\nbool L3GD20H::getBlockDataUpdateEnabled() {\n\tI2Cdev::readBit(devAddr, L3GD20H_RA_CTRL4, L3GD20H_BDU_BIT, buffer);\n\treturn buffer[0];\n}\n\n/** Set the data endian modes\n * In Big Endian mode, the Most Significat Byte (MSB) is on the lower address, \n * and the Least Significant Byte (LSB) is on the higher address. Little Endian \n * mode reverses this order. Little Endian is the default mode.\n * @param endianness New endian mode\n * @see L3GD20H_RA_CTRL4\n * @see L3GD20H_BLE_BIT\n * @see L3GD20H_BIG_ENDIAN\n * @see L3GD20H_LITTLE_ENDIAN\n */\nvoid L3GD20H::setEndianMode(bool endianness) {\n\tI2Cdev::writeBit(devAddr, L3GD20H_RA_CTRL4, L3GD20H_BLE_BIT, \n\t\tendianness);\n\tendianMode = getEndianMode();\n}\n\n/** Get the data endian mode\n * @return Current endian mode\n * @see L3GD20H_RA_CTRL4\n * @see L3GD20H_BLE_BIT\n * @see L3GD20H_BIG_ENDIAN\n * @see L3GD20H_LITTLE_ENDIAN\n */\nbool L3GD20H::getEndianMode() {\n\tI2Cdev::readBit(devAddr, L3GD20H_RA_CTRL4, L3GD20H_BLE_BIT,\n\t\tbuffer);\n\treturn buffer[0];\n}\n\n/** Set the full scale of the data output (in dps)\n * @param scale The new scale of the data output (250 [actual 245], 500, 2000)\n * @see L3GD20H_RA_CTRL4\n * @see L3GD20H_FS_BIT\n * @see L3GD20H_FS_LENGTH\n * @see L3GD20H_FS_250\n * @see L3GD20H_FS_500\n * @see L3GD20H_FS_2000\n */\nvoid L3GD20H::setFullScale(uint16_t scale) {\n\tuint8_t writeBits;\n\t\n\tif (scale == 250) {\n\t\twriteBits = L3GD20H_FS_250;\n\t} else if (scale == 500) {\n\t\twriteBits = L3GD20H_FS_500;\n\t} else {\n\t\twriteBits = L3GD20H_FS_2000;\n\t}\n\n\tI2Cdev::writeBits(devAddr, L3GD20H_RA_CTRL4, L3GD20H_FS_BIT, \n\t\tL3GD20H_FS_LENGTH, writeBits);\n}\n\n/** Get the current full scale of the output data (in dps)\n * @return Current scale of the output data\n * @see L3GD20H_RA_CTRL4\n * @see L3GD20H_FS_BIT\n * @see L3GD20H_FS_LENGTH\n * @see L3GD20H_FS_250\n * @see L3GD20H_FS_500\n * @see L3GD20H_FS_2000\n */\nuint16_t L3GD20H::getFullScale() {\n\tI2Cdev::readBits(devAddr, L3GD20H_RA_CTRL4, \n\t\tL3GD20H_FS_BIT, L3GD20H_FS_LENGTH, buffer);\n\tuint8_t readBits = buffer[0];\n\t\n\tif (readBits == L3GD20H_FS_250) {\n\t\treturn 250;\n\t} else if (readBits == L3GD20H_FS_500) {\n\t\treturn 500;\n\t} else {\n\t\treturn 2000;\n\t}\n}\n\n//TODO\n//Implement \n//L3GD20H::setLevelSensitiveLatchedEnabled() and\n//L3GD20H::getLevelSensitiveLatchedEnabled()\n//\n\n/** Set the self test mode\n * @param mode New self test mode (Normal, 0, 1)\n * @see L3GD20H_RA_CTRL4\n * @see L3GD20H_ST_BIT\n * @see L3GD20H_ST_LENGTH\n * @see L3GD20H_SELF_TEST_NORMAL\n * @see L3GD20H_SELF_TEST_0\n * @see L3GD20H_SELF_TEST_1\n */\nvoid L3GD20H::setSelfTestMode(uint8_t mode) {\n\tI2Cdev::writeBits(devAddr, L3GD20H_RA_CTRL4, L3GD20H_ST_BIT, \n\t\tL3GD20H_ST_LENGTH, mode);\n}\n\n/** Get the current self test mode\n * @return Current self test mode\n * @see L3GD20H_RA_CTRL4\n * @see L3GD20H_ST_BIT\n * @see L3GD20H_ST_LENGTH\n * @see L3GD20H_SELF_TEST_NORMAL\n * @see L3GD20H_SELF_TEST_0\n * @see L3GD20H_SELF_TEST_1\n */\nuint8_t L3GD20H::getSelfTestMode() {\n\tI2Cdev::readBits(devAddr, L3GD20H_RA_CTRL4, L3GD20H_ST_BIT, \n\t\tL3GD20H_ST_LENGTH, buffer);\n\treturn buffer[0];\n}\n\n/** Set the SPI mode\n * @param mode New SPI mode\n * @see L3GD20H_RA_CTRL4\n * @see L3GD20H_SIM_BIT\n * @see L3GD20H_SPI_4_WIRE\n * @see L3GD20H_SPI_3_WIRE\n */\nvoid L3GD20H::setSPIMode(bool mode) {\n\tI2Cdev::writeBit(devAddr, L3GD20H_RA_CTRL4, L3GD20H_SIM_BIT, mode);\n}\n\n/** Get the SPI mode\n * @return Current SPI mode\n * @see L3GD20H_RA_CTRL4\n * @see L3GD20H_SIM_BIT\n * @see L3GD20H_SPI_4_WIRE\n * @see L3GD20H_SPI_3_WIRE\n */\nbool L3GD20H::getSPIMode() {\n\tI2Cdev::readBit(devAddr, L3GD20H_RA_CTRL4, L3GD20H_SIM_BIT, \n\t\tbuffer);\n \treturn buffer[0];\n}\n\n// CTRL5 register, r/w\n\n/** Reboots the FIFO memory content\n * @see L3GD20H_RA_CTRL5\n * @see L3GD20H_BOOT_BIT\n */\nvoid L3GD20H::rebootMemoryContent() {\n\tI2Cdev::writeBit(devAddr, L3GD20H_RA_CTRL5, L3GD20H_BOOT_BIT, true);\n}\n\n/** Set whether the FIFO buffer is enabled\n * @param enabled New enabled state of the FIFO buffer\n * @see L3GD20H_RA_CTRL5\n * @see L3GD20H_FIFO_EN_BIT\n */\nvoid L3GD20H::setFIFOEnabled(bool enabled) {\n\tI2Cdev::writeBit(devAddr, L3GD20H_RA_CTRL5, L3GD20H_FIFO_EN_BIT, \n\t\tenabled);\n}\n\n/** Get whether the FIFO buffer is enabled\n * @return True if the FIFO buffer is enabled, false otherwise\n * @see L3GD20H_RA_CTRL5\n * @see L3GD20H_FIFO_EN_BIT\n */\nbool L3GD20H::getFIFOEnabled() {\n\tI2Cdev::readBit(devAddr, L3GD20H_RA_CTRL5, L3GD20H_FIFO_EN_BIT, \n\t\tbuffer);\n\treturn buffer[0];\n}\n\n/** Set whether the sensing chain FIFO stops writing new values once\n * the FIFO Threshold (watermark) is reached\n * @param enabled New state of the StopOnFTH bit\n * @see L3GD20H_RA_CTRL5\n * @see L3GD20H_FIFO_STOPONFTH_BIT\n */\nvoid L3GD20H::setStopOnFIFOThresholdEnabled(bool enabled) {\n\tI2Cdev::writeBit(devAddr, L3GD20H_RA_CTRL5, L3GD20H_STOPONFTH_BIT, \n\t\tenabled);\n}\n\n/** Get whether the sensing chain FIFO stopping writing new values once\n * the FIFO Threshold (watermark) is enabled\n * @return True if the state of the StopOnFTH bit is high (enabled)\n * @see L3GD20H_RA_CTRL5\n * @see L3GD20H_FIFO_STOPONFTH_BIT\n */\nbool L3GD20H::getStopOnFIFOThresholdEnabled() {\n\tI2Cdev::readBit(devAddr, L3GD20H_RA_CTRL5, L3GD20H_STOPONFTH_BIT, \n\t\tbuffer);\n\treturn buffer[0];\n}\n\n\n/** Set the high pass filter enabled state\n * @param enabled New high pass filter enabled state\n * @see L3GD20H_RA_CTRL5\n * @see L3GD20H_HPEN_BIT\n */\nvoid L3GD20H::setHighPassFilterEnabled(bool enabled) {\n\tI2Cdev::writeBit(devAddr, L3GD20H_RA_CTRL5, L3GD20H_HPEN_BIT, \n\t\tenabled);\n}\n\n/** Get whether the high pass filter is enabled\n * @return True if the high pass filter is enabled, false otherwise\n * @see L3GD20H_RA_CTRL5\n * @see L3GD20H_HPEN_BIT\n */\nbool L3GD20H::getHighPassFilterEnabled() {\n\tI2Cdev::readBit(devAddr, L3GD20H_RA_CTRL5, L3GD20H_HPEN_BIT,\n\t\tbuffer);\n\treturn buffer[0];\n}\n\n/** Sets the filter mode to one of the four provided.\n * This function also uses the setHighPassFilterEnabled function in order to set\n * the mode. That function does not have to be called in addition to this one. \n * In addition to setting the filter for the data in the FIFO buffer \n * (controlled by the bits written to OUT_SEL), this function also sets the\n * filter used for interrupt generation (the bits written to IG_SEL) to be the\n * same as the filter used for the FIFO buffer.  The filter used for interrupt\n * generation can be set separately with the setInterruptFilter function.\n * @param filter New method to be used when filtering data\n * @see L3GD20H_RA_CTRL5\n * @see L3GD20H_IG_SEL_BIT\n * @see L3GD20H_IG_SEL_LENGTH\n * @see L3GD20H_OUT_SEL_BIT\n * @see L3GD20H_OUT_SEL_LENGTH\n * @see L3GD20H_NON_HIGH_PASS\n * @see L3GD20H_HIGH_PASS\n * @see L3GD20H_LOW_PASS\n * @see L3GD20H_LOW_HIGH_PASS\n */\nvoid L3GD20H::setDataFilter(uint8_t filter) {\n\tif (filter == L3GD20H_HIGH_PASS || filter == L3GD20H_LOW_HIGH_PASS) {\n\t\tsetHighPassFilterEnabled(true);\n\t} else {\n\t\tsetHighPassFilterEnabled(false);\n\t}\n\t\n\tI2Cdev::writeBits(devAddr, L3GD20H_RA_CTRL5, L3GD20H_OUT_SEL_BIT, \n\t\tL3GD20H_OUT_SEL_LENGTH, filter);\n\tI2Cdev::writeBits(devAddr, L3GD20H_RA_CTRL5, L3GD20H_IG_SEL_BIT, \n\t\tL3GD20H_IG_SEL_LENGTH, filter);\n}\n\n/** Gets the data filter currently in use\n * @return Defined value that represents the filter in use\n * @see L3GD20H_RA_CTRL5\n * @see L3GD20H_OUT_SEL_BIT\n * @see L3GD20H_OUT_SEL_LENGTH\n * @see L3GD20H_NON_HIGH_PASS\n * @see L3GD20H_HIGH_PASS\n * @see L3GD20H_LOW_PASS\n * @see L3GD20H_LOW_HIGH_PASS\n */\nuint8_t L3GD20H::getDataFilter() {\n\tI2Cdev::readBits(devAddr, L3GD20H_RA_CTRL5, L3GD20H_OUT_SEL_BIT, \n\t\tL3GD20H_OUT_SEL_LENGTH, buffer);\n\tuint8_t outBits = buffer[0];\n\n\tif (outBits == L3GD20H_NON_HIGH_PASS || outBits == L3GD20H_HIGH_PASS) {\n\t\treturn outBits;\n\t}\n\n\tif (getHighPassFilterEnabled()) {\n\t\treturn L3GD20H_LOW_HIGH_PASS;\n\t} else {\n\t\treturn L3GD20H_LOW_PASS;\n\t}\n}\n\n//ToDo:\n//setInterruptFilter\n//getInterruptFilter\n\n// REFERENCE register, r/w\n\n/** Set the reference value for the high pass filter\n * @param reference New 8-bit digital high pass filter reference value\n * @see L3GD20H_RA_REFERENCE\n */\nvoid L3GD20H::setHighPassFilterReference(uint8_t reference) {\n\tI2Cdev::writeByte(devAddr, L3GD20H_RA_REFERENCE, reference);\n}\n\n/** Get the 8-bit reference value for the high pass filter\n * @return 8-bit reference value for the high pass filter\n * @see L3GD20H_RA_REFERENCE\n */\nuint8_t L3GD20H::getHighPassFilterReference() {\n\tI2Cdev::readByte(devAddr, L3GD20H_RA_REFERENCE, buffer);\n\treturn buffer[0];\n}\n\n// void L3GD20H::setInterruptReference(uint8_t reference) {\n// \tI2Cdev::writeByte(devAddr, L3GD20H_RA_REFERENCE, reference);\n// }\n\n// uint8_t L3GD20H::getInterruptReference() {\n// \tI2Cdev::readByte(devAddr, L3GD20H_RA_REFERENCE, buffer);\n// \treturn buffer[0];\n// }\n\n// OUT_TEMP register, read-only\n\n/** Gets the current temperature reading from the sensor\n * @return Current temperature\n * @see L3GD20H_RA_OUT_TEMP\n */\nuint8_t L3GD20H::getTemperature() {\n\tI2Cdev::readByte(devAddr, L3GD20H_RA_OUT_TEMP, buffer);\n\treturn buffer[0];\n}\n\n// STATUS register, read-only\n\n/** Get whether new data overwrote the last set of data before it was read\n * @return True if the last set of data was overwritten before being read, false\n * otherwise\n * @see L3GD20H_RA_STATUS\n * @see L3GD20H_ZYXOR_BIT\n */\nbool L3GD20H::getXYZOverrun() {\n\tI2Cdev::readBit(devAddr, L3GD20H_RA_STATUS, L3GD20H_ZYXOR_BIT, \n\t\tbuffer);\n\treturn buffer[0];\n}\n\n/** Get whether new Z data overwrote the last set of data before it was read\n * @return True if the last set of Z data was overwritten before being read,\n * false otherwise\n * @see L3GD20H_RA_STATUS\n * @see L3GD20H_ZOR_BIT\n */\nbool L3GD20H::getZOverrun() {\n\tI2Cdev::readBit(devAddr, L3GD20H_RA_STATUS, L3GD20H_ZOR_BIT, \n\t\tbuffer);\n\treturn buffer[0];\n}\n\n/** Get whether new Y data overwrote the last set of data before it was read\n * @return True if the last set of Y data was overwritten before being read, \n * false otherwise\n * @see L3GD20H_RA_STATUS\n * @see L3GD20H_YOR_BIT\n */\nbool L3GD20H::getYOverrun() {\n\tI2Cdev::readBit(devAddr, L3GD20H_RA_STATUS, L3GD20H_YOR_BIT, \n\t\tbuffer);\n\treturn buffer[0];\n}\n\n/** Get whether new X data overwrote the last set of data before it was read\n * @return True if the last set of X data was overwritten before being read, \n * false otherwise\n * @see L3GD20H_RA_STATUS\n * @see L3GD20H_XOR_BIT\n */\nbool L3GD20H::getXOverrun() {\n\tI2Cdev::readBit(devAddr, L3GD20H_RA_STATUS, L3GD20H_XOR_BIT, \n\t\tbuffer);\n\treturn buffer[0];\n}\n\n/** Get whether there is new data avaialable\n * @return True if there is new data available, false otherwise\n * @see L3GD20H_RA_STATUS\n * @see L3GD20H_ZYXDA_BIT\n */\nbool L3GD20H::getXYZDataAvailable() {\n\tI2Cdev::readBit(devAddr, L3GD20H_RA_STATUS, L3GD20H_ZYXDA_BIT, \n\t\tbuffer);\n\treturn buffer[0];\n}\n\n/** Get whether there is new Z data avaialable\n * @return True if there is new Z data available, false otherwise\n * @see L3GD20H_RA_STATUS\n * @see L3GD20H_ZDA_BIT\n */\nbool L3GD20H::getZDataAvailable() {\n\tI2Cdev::readBit(devAddr, L3GD20H_RA_STATUS, L3GD20H_ZDA_BIT, \n\t\tbuffer);\n\treturn buffer[0];\n}\n\n/** Get whether there is new Y data avaialable\n * @return True if there is new Y data available, false otherwise\n * @see L3GD20H_RA_STATUS\n * @see L3GD20H_YDA_BIT\n */\nbool L3GD20H::getYDataAvailable() {\n\tI2Cdev::readBit(devAddr, L3GD20H_RA_STATUS, L3GD20H_YDA_BIT, \n\t\tbuffer);\n\treturn buffer[0];\n}\n\n/** Get whether there is new X data avaialable\n * @return True if there is new X data available, false otherwise\n * @see L3GD20H_RA_STATUS\n * @see L3GD20H_XDA_BIT\n */\nbool L3GD20H::getXDataAvailable() {\n\tI2Cdev::readBit(devAddr, L3GD20H_RA_STATUS, L3GD20H_XDA_BIT, \n\t\tbuffer);\n\treturn buffer[0];\n}\n\n// OUT_* registers, read-only\n\n/** Get the angular velocity for all 3 axes\n * Due to the fact that this device supports two difference Endian modes, both \n * must be accounted for when reading data. In Little Endian mode, the first \n * byte (lowest address) is the least significant and in Big Endian mode the \n * first byte is the most significant.\n * @param x 16-bit integer container for the X-axis angular velocity\n * @param y 16-bit integer container for the Y-axis angular velocity\n * @param z 16-bit integer container for the Z-axis angular velocity\n */\nvoid L3GD20H::getAngularVelocity(int16_t* x, int16_t* y, int16_t* z) {\n\tI2Cdev::readBytes(devAddr, L3GD20H_RA_OUT_X_L | 0x80, 6, buffer);\n\tif (endianMode == L3GD20H_LITTLE_ENDIAN) {\n\t\t*x = (((int16_t)buffer[1]) << 8) | buffer[0];\n\t\t*y = (((int16_t)buffer[3]) << 8) | buffer[2];\n\t\t*z = (((int16_t)buffer[5]) << 8) | buffer[4];\n\t} else {\n\t\t*x = (((int16_t)buffer[0]) << 8) | buffer[1];\n\t\t*y = (((int16_t)buffer[2]) << 8) | buffer[3];\n\t\t*z = (((int16_t)buffer[4]) << 8) | buffer[5];\n\t}\n}\n\n/** Get the angular velocity about the X-axis\n * @return Angular velocity about the X-axis\n * @see L3GD20H_RA_OUT_X_L\n * @see L3GD20H_RA_OUT_X_H\n */\nint16_t L3GD20H::getAngularVelocityX() {\n\tI2Cdev::readBytes(devAddr, L3GD20H_RA_OUT_X_L | 0x80, 2, buffer);\n\tif (endianMode == L3GD20H_LITTLE_ENDIAN) {\n\t\treturn (((int16_t)buffer[1]) << 8) | buffer[0];\n\t} else {\n\t\treturn (((int16_t)buffer[0]) << 8) | buffer[1];\n\t}\n}\n\t\n/** Get the angular velocity about the Y-axis\n * @return Angular velocity about the Y-axis\n * @see L3GD20H_RA_OUT_Y_L\n * @see L3GD20H_RA_OUT_Y_H\n */\nint16_t L3GD20H::getAngularVelocityY() {\n\tI2Cdev::readBytes(devAddr, L3GD20H_RA_OUT_Y_L | 0x80, 2, buffer);\n\tif (endianMode == L3GD20H_LITTLE_ENDIAN) {\n\t\treturn (((int16_t)buffer[1]) << 8) | buffer[0];\n\t} else {\n\t\treturn (((int16_t)buffer[0]) << 8) | buffer[1];\n\t}\n}\n\n/** Get the angular velocity about the Z-axis\n * @return Angular velocity about the Z-axis\n * @see L3GD20H_RA_OUT_Z_L\n * @see L3GD20H_RA_OUT_Z_H\n */\nint16_t L3GD20H::getAngularVelocityZ() {\n\tI2Cdev::readBytes(devAddr, L3GD20H_RA_OUT_Z_L | 0x80, 2, buffer);\n\tif (endianMode == L3GD20H_LITTLE_ENDIAN) {\n\t\treturn (((int16_t)buffer[1]) << 8) | buffer[0];\n\t} else {\n\t\treturn (((int16_t)buffer[0]) << 8) | buffer[1];\n\t}\n}\n\n// FIFO_CTRL register, r/w\n\n/** Set the FIFO mode to one of the defined modes\n * @param mode New FIFO mode\n * @see L3GD20H_RA_FIFO_CTRL\n * @see L3GD20H_FIFO_MODE_BIT\n * @see L3GD20H_FIFO_MODE_LENGTH\n * @see L3GD20H_FM_BYPASS\n * @see L3GD20H_FM_FIFO\n * @see L3GD20H_FM_STREAM\n * @see L3GD20H_FM_STREAM_FIFO\n * @see L3GD20H_FM_BYPASS_STREAM\n * @see L3GD20H_FM_DYNAMIC_STREAM\n * @see L3GD20H_FM_BYPASS_FIFO\n */\nvoid L3GD20H::setFIFOMode(uint8_t mode) {\n\tI2Cdev::writeBits(devAddr, L3GD20H_RA_FIFO_CTRL, L3GD20H_FIFO_MODE_BIT, \n\t\tL3GD20H_FIFO_MODE_LENGTH, mode);\n}\n\n/** Get the FIFO mode to one of the defined modes\n * @return Current FIFO mode\n * @see L3GD20H_RA_FIFO_CTRL\n * @see L3GD20H_FIFO_MODE_BIT\n * @see L3GD20H_FIFO_MODE_LENGTH\n * @see L3GD20H_FM_BYPASS\n * @see L3GD20H_FM_FIFO\n * @see L3GD20H_FM_STREAM\n * @see L3GD20H_FM_STREAM_FIFO\n * @see L3GD20H_FM_BYPASS_STREAM\n * @see L3GD20H_FM_DYNAMIC_STREAM\n * @see L3GD20H_FM_BYPASS_FIFO\n */\nuint8_t L3GD20H::getFIFOMode() {\n\tI2Cdev::readBits(devAddr, L3GD20H_RA_FIFO_CTRL, \n\t\tL3GD20H_FIFO_MODE_BIT, L3GD20H_FIFO_MODE_LENGTH, buffer);\n\treturn buffer[0];\n}\n\n/** Set the 5-bit FIFO (watermark) threshold\n * @param fth New 5-bit FIFO (watermark) threshold\n * @see L3GD20H_RA_FIFO_CTRL\n * @see L3GD20H_FIFO_TH_BIT\n * @see L3GD20H_FIFO_TH_LENGTH\n */\nvoid L3GD20H::setFIFOThreshold(uint8_t fth) {\n    I2Cdev::writeBits(devAddr, L3GD20H_RA_FIFO_CTRL, L3GD20H_FIFO_TH_BIT, \n        L3GD20H_FIFO_TH_LENGTH, fth);\n}\n\n/** Get the FIFO watermark threshold\n * @return FIFO watermark threshold\n * @see L3GD20H_RA_FIFO_CTRL\n * @see L3GD20H_FIFO_TH_BIT\n * @see L3GD20H_FIFO_TH_LENGTH\n */\nuint8_t L3GD20H::getFIFOThreshold() {\n    I2Cdev::readBits(devAddr, L3GD20H_RA_FIFO_CTRL, L3GD20H_FIFO_TH_BIT,\n        L3GD20H_FIFO_TH_LENGTH, buffer);\n    return buffer[0];\n}\n\n// FIFO_SRC register, read-only\n\n/** Get whether the number of data sets in the FIFO buffer is less than the \n * watermark\n * @return True if the number of data sets in the FIFO buffer is more than or \n * equal to the watermark, false otherwise.\n * @see L3GD20H_RA_FIFO_SRC\n * @see L3GD20H_FIFO_TH_STATUS_BIT\n */\nbool L3GD20H::getFIFOAtWatermark() {\n   \tI2Cdev::readBit(devAddr, L3GD20H_RA_FIFO_SRC, L3GD20H_FIFO_TH_STATUS_BIT, \n        buffer);\n   \treturn buffer[0];\n}\n\n/** Get whether the FIFO buffer is full\n * @return True if the FIFO buffer is full, false otherwise\n * @see L3GD20H_RA_FIFO_SRC\n * @see L3GD20H_FIFO_OVRN_BIT\n */\nbool L3GD20H::getFIFOOverrun() {\n    I2Cdev::readBit(devAddr, L3GD20H_RA_FIFO_SRC, \n        L3GD20H_OVRN_BIT, buffer);\n    return buffer[0];\n}\n\n/** Get whether the FIFO buffer is empty\n * @return True if the FIFO buffer is empty, false otherwise\n * @see L3GD20H_RA_FIFO_SRC\n * @see L3GD20H_FIFO_EMPTY_BIT\n */\nbool L3GD20H::getFIFOEmpty() {\n    I2Cdev::readBit(devAddr, L3GD20H_RA_FIFO_SRC,\n        L3GD20H_EMPTY_BIT, buffer);\n    return buffer[0];\n}\n\n/** Get the number of filled FIFO buffer slots\n * @return Number of filled slots in the FIFO buffer\n * @see L3GD20H_RA_FIFO_SRC\n * @see L3GD20H_FIFO_FSS_BIT\n * @see L3GD20H_FIFO_FSS_LENGTH\n */ \nuint8_t L3GD20H::getFIFOStoredDataLevel() {\n    I2Cdev::readBits(devAddr, L3GD20H_RA_FIFO_SRC, \n        L3GD20H_FIFO_FSS_BIT, L3GD20H_FIFO_FSS_LENGTH, buffer);\n    return buffer[0];\n}\n\n// IG_CFG register, r/w\n\n/** Set the combination mode for interrupt events\n * @param combination New combination mode for interrupt events. \n * L3GD20H_AND_OR_OR for OR and L3GD20H_AND_OR_AND for AND\n * @see L3GD20H_RA_IG_CFG\n * @see L3GD20H_AND_OR_BIT\n * @see L3GD20H_AND_OR_OR\n * @see L3GD20H_AND_OR_AND\n */\nvoid L3GD20H::setInterruptCombination(bool combination) {\n    I2Cdev::writeBit(devAddr, L3GD20H_RA_IG_CFG, L3GD20H_AND_OR_BIT,\n        combination);\n}\n\n/** Get the combination mode for interrupt events\n * @return Combination mode for interrupt events. L3GD20H_AND_OR_OR for OR and \n * L3GD20H_AND_OR_AND for AND\n * @see L3GD20H_RA_IG_CFG\n * @see L3GD20H_AND_OR_BIT\n * @see L3GD20H_AND_OR_OR\n * @see L3GD20H_AND_OR_AND\n */\nbool L3GD20H::getInterruptCombination() {\n    I2Cdev::readBit(devAddr, L3GD20H_RA_IG_CFG, L3GD20H_AND_OR_BIT,\n        buffer);\n    return buffer[0];\n}\n\n/** Set whether an interrupt request is latched\n * This bit is cleared when the IG_SRC register is read\n * @param latched New status of the latched request\n * @see L3GD20H_RA_IG_CFG\n * @see L3GD20H_LIR_BIT\n */\nvoid L3GD20H::setInterruptRequestLatched(bool latched) {\n    I2Cdev::writeBit(devAddr, L3GD20H_RA_IG_CFG, L3GD20H_LIR_BIT, latched);\n}\n\n/** Get whether an interrupt request is latched\n * @return True if an interrupt request is latched, false otherwise\n * @see L3GD20H_RA_IG_CFG\n * @see L3GD20H_LIR_BIT\n */\nbool L3GD20H::getInterruptRequestLatched() {\n    I2Cdev::readBit(devAddr, L3GD20H_RA_IG_CFG, L3GD20H_LIR_BIT, \n        buffer); \n    return buffer[0];\n};\n\n/** Set whether the interrupt for Z high is enabled\n * @param enabled New enabled state for Z high interrupt.\n * @see L3GD20H_IG_CFG\n * @see L3GD20H_ZHIE_BIT\n */\nvoid L3GD20H::setZHighInterruptEnabled(bool enabled) {\n    I2Cdev::writeBit(devAddr, L3GD20H_RA_IG_CFG, L3GD20H_ZHIE_BIT, enabled);\n}\n\n/** Get whether the interrupt for Z high is enabled\n * @return True if the interrupt for Z high is enabled, false otherwise \n * @see L3GD20H_IG_CFG\n * @see L3GD20H_ZHIE_BIT\n */\nbool L3GD20H::getZHighInterruptEnabled() {\n    I2Cdev::readBit(devAddr, L3GD20H_RA_IG_CFG, L3GD20H_ZHIE_BIT, \n        buffer);\n    return buffer[0];\n}\n\n/** Set whether the interrupt for Z low is enabled\n * @param enabled New enabled state for Z low interrupt.\n * @see L3GD20H_IG_CFG\n * @see L3GD20H_ZLIE_BIT\n */\nvoid L3GD20H::setZLowInterruptEnabled(bool enabled) {\n    I2Cdev::writeBit(devAddr, L3GD20H_RA_IG_CFG, L3GD20H_ZLIE_BIT, enabled);\n}\n\n/** Get whether the interrupt for Z low is enabled\n * @return True if the interrupt for Z low is enabled, false otherwise\n * @see L3GD20H_IG_CFG\n * @see L3GD20H_ZLIE_BIT\n */\nbool L3GD20H::getZLowInterruptEnabled() {\n    I2Cdev::readBit(devAddr, L3GD20H_RA_IG_CFG, L3GD20H_ZLIE_BIT, \n        buffer);\n    return buffer[0];\n}\n\n/** Set whether the interrupt for Y high is enabled\n * @param enabled New enabled state for Y high interrupt.\n * @see L3GD20H_IG_CFG\n * @see L3GD20H_YHIE_BIT\n */\nvoid L3GD20H::setYHighInterruptEnabled(bool enabled) {\n    I2Cdev::writeBit(devAddr, L3GD20H_RA_IG_CFG, L3GD20H_YHIE_BIT, enabled);\n}\n\n/** Get whether the interrupt for Y high is enabled\n * @return True if the interrupt for Y high is enabled, false otherwise\n * @see L3GD20H_IG_CFG\n * @see L3GD20H_YHIE_BIT\n */\nbool L3GD20H::getYHighInterruptEnabled() {\n    I2Cdev::readBit(devAddr, L3GD20H_RA_IG_CFG, L3GD20H_YHIE_BIT, \n        buffer);\n    return buffer[0];\n}\n\n/** Set whether the interrupt for Y low is enabled\n * @param enabled New enabled state for Y low interrupt.\n * @see L3GD20H_IG_CFG\n * @see L3GD20H_YLIE_BIT\n */\nvoid L3GD20H::setYLowInterruptEnabled(bool enabled) {\n    I2Cdev::writeBit(devAddr, L3GD20H_RA_IG_CFG, L3GD20H_YLIE_BIT, enabled);\n}\n\n/** Get whether the interrupt for Y low is enabled\n * @return True if the interrupt for Y low is enabled, false otherwise \n * @see L3GD20H_IG_CFG\n * @see L3GD20H_YLIE_BIT\n */\nbool L3GD20H::getYLowInterruptEnabled() {\n    I2Cdev::readBit(devAddr, L3GD20H_RA_IG_CFG, L3GD20H_YLIE_BIT, \n        buffer);\n    return buffer[0];\n}\n\n/** Set whether the interrupt for X high is enabled\n * @param enabled New enabled state for X high interrupt.\n * @see L3GD20H_IG_CFG\n * @see L3GD20H_XHIE_BIT\n */\nvoid L3GD20H::setXHighInterruptEnabled(bool enabled) {\n    I2Cdev::writeBit(devAddr, L3GD20H_RA_IG_CFG, L3GD20H_XHIE_BIT, enabled);\n}\n\n/** Get whether the interrupt for X high is enabled\n * @return True if the interrupt for X high is enabled, false otherwise\n * @see L3GD20H_IG_CFG\n * @see L3GD20H_XHIE_BIT\n */\nbool L3GD20H::getXHighInterruptEnabled() {\n    I2Cdev::readBit(devAddr, L3GD20H_RA_IG_CFG, L3GD20H_XHIE_BIT, \n        buffer);\n    return buffer[0];\n}\n\n/** Set whether the interrupt for X low is enabled\n * @param enabled New enabled state for X low interrupt.\n * @see L3GD20H_IG_CFG\n * @see L3GD20H_XLIE_BIT\n */\nvoid L3GD20H::setXLowInterruptEnabled(bool enabled) {\n    I2Cdev::writeBit(devAddr, L3GD20H_RA_IG_CFG, L3GD20H_XLIE_BIT, enabled);\n}\n\n/** Get whether the interrupt for X low is enabled\n * @return True if the interrupt for X low is enabled, false otherwise\n * @see L3GD20H_IG_CFG\n * @see L3GD20H_XLIE_BIT\n */\nbool L3GD20H::getXLowInterruptEnabled() {\n    I2Cdev::readBit(devAddr, L3GD20H_RA_IG_CFG, L3GD20H_XLIE_BIT, \n        buffer);\n    return buffer[0];\n}\n\n// IG_SRC register, read-only\n\n/** Get whether an interrupt has been generated\n * @return True if one or more interrupts has been generated, false otherwise\n * @see L3GD20H_RA_IG_SRC\n * @see L3GD20H_IA_BIT\n */\nbool L3GD20H::getInterruptActive() {\n    I2Cdev::readBit(devAddr, L3GD20H_RA_IG_SRC, L3GD20H_IA_BIT,\n        buffer);\n    return buffer[0];\n}\n\n/** Get whether a Z high event has occurred\n * @return True if a Z high event has occurred, false otherwise\n * @see L3GD20H_RA_IG_SRC\n * @see L3GD20H_ZH_BIT\n */\nbool L3GD20H::getZHigh() {\n    I2Cdev::readBit(devAddr, L3GD20H_RA_IG_SRC, L3GD20H_ZH_BIT,\n        buffer);\n    return buffer[0];\n}\n\n/** Get whether a Z low event has occurred\n * @return True if a Z low event has occurred, false otherwise\n * @see L3GD20H_RA_IG_SRC\n * @see L3GD20H_ZL_BIT\n */\nbool L3GD20H::getZLow() {\n    I2Cdev::readBit(devAddr, L3GD20H_RA_IG_SRC, L3GD20H_ZL_BIT,\n        buffer);\n    return buffer[0];\n}\n\n/** Get whether a Y high event has occurred\n * @return True if a Y high event has occurred, false otherwise\n * @see L3GD20H_RA_IG_SRC\n * @see L3GD20H_YH_BIT\n */\nbool L3GD20H::getYHigh() {\n    I2Cdev::readBit(devAddr, L3GD20H_RA_IG_SRC, L3GD20H_YH_BIT,\n        buffer);\n    return buffer[0];\n}\n\n/** Get whether a Y low event has occurred\n * @return True if a Y low event has occurred, false otherwise\n * @see L3GD20H_RA_IG_SRC\n * @see L3GD20H_YL_BIT\n */\nbool L3GD20H::getYLow() {\n   \tI2Cdev::readBit(devAddr, L3GD20H_RA_IG_SRC, L3GD20H_YL_BIT,\n        buffer);\n    return buffer[0];\n}\n\n/** Get whether a X high event has occurred\n * @return True if a X high event has occurred, false otherwise\n * @see L3GD20H_RA_IG_SRC\n * @see L3GD20H_XH_BIT\n */\nbool L3GD20H::getXHigh() {\n    I2Cdev::readBit(devAddr, L3GD20H_RA_IG_SRC, L3GD20H_XH_BIT,\n        buffer);\n    return buffer[0];\n}\n\n/** Get whether a X low event has occurred\n * @return True if a X low event has occurred, false otherwise\n * @see L3GD20H_RA_IG_SRC\n * @see L3GD20H_XL_BIT\n */\nbool L3GD20H::getXLow() {\n    I2Cdev::readBit(devAddr, L3GD20H_RA_IG_SRC, L3GD20H_XL_BIT,\n        buffer);\n    return buffer[0];\n}\n\n// IG_THS_* registers, r/w\n\n/** Set the interrupt generation counter mode selection.\n * @param enabled New enabled state for X low interrupt.\n * @see L3GD20H_IG_THS_XH\n * @see L3GD20H_DCRM_BIT\n * @see L3GD20H_DCRM_RESET\n * @see L3GD20H_DCRM_DEC\n */\nvoid L3GD20H::setDecrementMode(bool mode) {\n    I2Cdev::writeBit(devAddr, L3GD20H_RA_IG_THS_XH, L3GD20H_DCRM_BIT, mode);\n}\n\n/** Get the interrupt generation counter mode selection.\n * @return Mode Interrupt generation counter mode\n * @see L3GD20H_IG_THS_XH\n * @see L3GD20H_DCRM_BIT\n * @see L3GD20H_DCRM_RESET\n * @see L3GD20H_DCRM_DEC\n */\nbool L3GD20H::getDecrementMode() {\n    I2Cdev::readBit(devAddr, L3GD20H_RA_IG_THS_XH, L3GD20H_DCRM_BIT, \n        buffer);\n    return buffer[0];\n}\n\n/** Set the 7-bit threshold for a high interrupt on the X axis\n * @param threshold New 7-bit threshold for a high interrupt on the X axis\n * @see L3GD20H_IG_THS_XH\n */\nvoid L3GD20H::setXHighThreshold(uint8_t threshold) {\n    I2Cdev::writeByte(devAddr, L3GD20H_RA_IG_THS_XH, threshold);\n}\n\n/** Retrieve the threshold for a high interrupt on the X axis\n * @return X high interrupt threshold\n * @see L3GD20H_IG_THS_XH\n */\nuint8_t L3GD20H::getXHighThreshold() {\n\tI2Cdev::readByte(devAddr, L3GD20H_RA_IG_THS_XH, buffer);\n\treturn buffer[0];\n}\n\n/** Set the 8-bit threshold for a low interrupt on the X axis\n * @param threshold New 8-bit threshold for a low interrupt on the X axis\n * @see L3GD20H_IG_THS_XL\n */\nvoid L3GD20H::setXLowThreshold(uint8_t threshold) {\n    I2Cdev::writeByte(devAddr, L3GD20H_RA_IG_THS_XL, threshold);\n}\n\n/** Retrieve the threshold for a low interrupt on the X axis\n * @return X low interrupt threshold\n * @see L3GD20H_IG_THS_XL\n */\nuint8_t L3GD20H::getXLowThreshold() {\n\tI2Cdev::readByte(devAddr, L3GD20H_RA_IG_THS_XL, buffer);\n\treturn buffer[0];\n}\n\n/** Set the 7-bit threshold for a high interrupt on the Y axis\n * @param threshold New 7-bit threshold for a high interrupt on the Y axis\n * @see L3GD20H_IG_THS_YH\n */\nvoid L3GD20H::setYHighThreshold(uint8_t threshold) {\n    I2Cdev::writeByte(devAddr, L3GD20H_RA_IG_THS_YH, threshold);\n}\n\n/** Retrieve the threshold for a high interrupt on the Y axis\n * @return Y high interrupt threshold\n * @see L3GD20H_IG_THS_YH\n */\nuint8_t L3GD20H::getYHighThreshold() {\n\tI2Cdev::readByte(devAddr, L3GD20H_RA_IG_THS_YH, buffer);\n\treturn buffer[0];\n}\n\n/** Set the 8-bit threshold for a low interrupt on the Y axis\n * @param threshold New 8-bit threshold for a low interrupt on the Y axis\n * @see L3GD20H_IG_THS_YL\n */\nvoid L3GD20H::setYLowThreshold(uint8_t threshold) {\n    I2Cdev::writeByte(devAddr, L3GD20H_RA_IG_THS_YL, threshold);\n}\n\n/** Retrieve the threshold for a low interrupt on the Y axis\n * @return Y low interrupt threshold\n * @see L3GD20H_IG_THS_YL\n */\nuint8_t L3GD20H::getYLowThreshold() {\n\tI2Cdev::readByte(devAddr, L3GD20H_RA_IG_THS_YL, buffer);\n\treturn buffer[0];\n}\n\n/** Set the 7-bit threshold for a high interrupt on the Z axis\n * @param threshold New 7-bit threshold for a high interrupt on the Z axis\n * @see L3GD20H_IG_THS_ZH\n */\nvoid L3GD20H::setZHighThreshold(uint8_t threshold) {\n    I2Cdev::writeByte(devAddr, L3GD20H_RA_IG_THS_ZH, threshold);\n}\n\n/** Retrieve the threshold for a high interrupt on the Z axis\n * @return Z high interrupt threshold\n * @see L3GD20H_IG_THS_ZH\n */\nuint8_t L3GD20H::getZHighThreshold() {\n\tI2Cdev::readByte(devAddr, L3GD20H_RA_IG_THS_ZH, buffer);\n\treturn buffer[0];\n}\n\n/** Set the 8-bit threshold for a low interrupt on the Z axis\n * @param threshold New 8-bit threshold for a low interrupt on the Z axis\n * @see L3GD20H_RA_IG_THS_ZL\n */\nvoid L3GD20H::setZLowThreshold(uint8_t threshold) {\n    I2Cdev::writeByte(devAddr, L3GD20H_RA_IG_THS_ZL, threshold);\n}\n\n/** Retrieve the threshold for a low interrupt on the Z axis\n * @return Z low interrupt threshold\n * @see L3GD20H_IG_THS_ZL\n */\nuint8_t L3GD20H::getZLowThreshold() {\n\tI2Cdev::readByte(devAddr, L3GD20H_RA_IG_THS_ZL, buffer);\n\treturn buffer[0];\n}\n\n// IG_DURATION register, r/w\n\n/* Set the minimum duration for an interrupt event to be recognized\n * This depends on the chosen output data rate\n * @param duration New 7-bit duration value necessary for an interrupt event to be \n * recognized\n * @see L3GD20H_RA_IG_DURATION\n * @see L3GD20H_DUR_BIT\n * @see L3GD20H_DUR_LENGTH\n */\nvoid L3GD20H::setDuration(uint8_t duration) {\n\tI2Cdev::writeBits(devAddr, L3GD20H_RA_IG_DURATION, L3GD20H_DUR_BIT,\n\t\tL3GD20H_DUR_LENGTH, duration);\n}\n\n/** Get the minimum duration for an interrupt event to be recognized\n * @return Duration value necessary for an interrupt event to be recognized\n * @see L3GD20H_RA_IG_DURATION\n * @see L3GD20H_DUR_BIT\n * @see L3GD20H_DUR_LENGTH\n */\nuint8_t L3GD20H::getDuration() {\n\tI2Cdev::readBits(devAddr, L3GD20H_RA_IG_DURATION, \n\t\tL3GD20H_DUR_BIT, L3GD20H_DUR_LENGTH, buffer);\n\treturn buffer[0];\n}\n\n/** Set whether the interrupt wait feature is enabled\n * If false, the interrupt falls immediately if signal crosses the selected \n * threshold. Otherwise, if signal crosses the selected threshold, the interrupt\n * falls only after the duration has counted number of samples at the selected \n * data rate, written into the duration counter register.\n * @param enabled New enabled state of the interrupt wait\n * @see L3GD20H_RA_IG_DURATION\n * @see L3GD20H_WAIT_BIT\n */\nvoid L3GD20H::setWaitEnabled(bool enabled) {\n\tI2Cdev::writeBit(devAddr, L3GD20H_RA_IG_DURATION, L3GD20H_WAIT_BIT,\n\t\tenabled);\n}\n\n/** Get whether the interrupt wait feature is enabled\n * @return True if the wait feature is enabled, false otherwise\n * @see L3GD20H_RA_IG_DURATION\n * @see L3GD20H_WAIT_BIT\n */\nbool L3GD20H::getWaitEnabled() {\n\tI2Cdev::readBit(devAddr, L3GD20H_RA_IG_DURATION, \n\t\tL3GD20H_WAIT_BIT, buffer);\n\treturn buffer[0];\n}\n\n// LOW_ODR register, r/w\n\n/** Set whether the DRDY/INT2 pin is active low. If enabled is true then the  \n * DRDY/INT2 pin will be active low.\n * @param enabled New enabled DRDY/INT2 active low configuration\n * @see L3GD20H_RA_LOW_ODR\n * @see L3GD20H_DRDY_HL_BIT\n */\nvoid L3GD20H::setINT2DataReadyActiveLowEnabled(bool enabled){\n\tI2Cdev::writeBit(devAddr, L3GD20H_RA_LOW_ODR, L3GD20H_DRDY_HL_BIT,\n\t\tenabled);\n}\n\n/** Get whether the DRDY/INT2 pin is active low. If true then the  \n * DRDY/INT2 pin IS active low.\n * @see L3GD20H_RA_LOW_ODR\n * @see L3GD20H_I2C_DIS_BIT\n */\nbool L3GD20H::getINT2DataReadyActiveLowEnabled(){\n\tI2Cdev::readBit(devAddr, L3GD20H_RA_LOW_ODR, \n\t\tL3GD20H_DRDY_HL_BIT, buffer);\n\treturn buffer[0];\n}\n\n/** Set whether only the SPI interface is enabled (i.e., I2C interface disabled)\n * @param enabled New SPI interface only enabled\n * @see L3GD20H_RA_LOW_ODR\n * @see L3GD20H_I2C_DIS_BIT\n */\nvoid L3GD20H::setSPIOnlyEnabled(bool enabled){\n\tI2Cdev::writeBit(devAddr, L3GD20H_RA_LOW_ODR, L3GD20H_I2C_DIS_BIT,\n\t\tenabled);\n}\n\n/** Get whether only the SPI interface is enabled (i.e., I2C interface disabled)\n * @see L3GD20H_RA_LOW_ODR\n * @see L3GD20H_I2C_DIS_BIT\n */\nbool L3GD20H::getSPIOnlyEnabled(){\n\tI2Cdev::readBit(devAddr, L3GD20H_RA_LOW_ODR, \n\t\tL3GD20H_I2C_DIS_BIT, buffer);\n\treturn buffer[0];\n}\n\n/** Reset the device.  Sets a software reset flag which is auto cleared upon boot.\n * @param reset Value that resets the device if true\n * @see L3GD20H_RA_LOW_ODR\n * @see L3GD20H_SW_RESET_BIT\n */\nvoid L3GD20H::setSoftwareReset(bool reset){\n\tI2Cdev::writeBit(devAddr, L3GD20H_RA_LOW_ODR, L3GD20H_SW_RESET_BIT,\n\t\treset);\n}\n\n/** Set whether the low output data rate is enabled.\n * @param enabled New low output data rate enabled\n * @see L3GD20H_RA_LOW_ODR\n * @see L3GD20H_LOW_ODR_BIT\n */\nvoid L3GD20H::setLowODREnabled(bool enabled){\n\tI2Cdev::writeBit(devAddr, L3GD20H_RA_LOW_ODR, L3GD20H_LOW_ODR_BIT,\n\t\tenabled);\n}\n\n/** Get whether the low output data rate is enabled.\n * @see L3GD20H_RA_LOW_ODR\n * @see L3GD20H_LOW_ODR_BIT\n */\nbool L3GD20H::getLowODREnabled(){\n\tI2Cdev::readBit(devAddr, L3GD20H_RA_LOW_ODR, \n\t\tL3GD20H_LOW_ODR_BIT, buffer);\n\treturn buffer[0];\n}\n'