b'{-# OPTIONS_GHC -fno-warn-type-defaults #-}\n{-# LANGUAGE NoImplicitPrelude #-}\n\nmodule Course.ListZipperSpec where\n\n\nimport qualified Prelude                  as P (fromIntegral, (<$>))\nimport           Test.Hspec               (Spec, describe, it, shouldBe)\nimport           Test.Hspec.QuickCheck    (prop)\nimport           Test.QuickCheck          ((===))\nimport           Test.QuickCheck.Function (Fun (..))\n\nimport           Course.Applicative       (pure, (<*>))\nimport           Course.Comonad           (copure)\nimport           Course.Core\nimport           Course.Extend            ((<<=))\nimport           Course.Functor           ((<$>))\nimport           Course.List              (List (..), all, isEmpty, take)\nimport           Course.ListZipper        (ListZipper, MaybeListZipper (..),\n                                           deletePullLeft, deletePullRight,\n                                           dropLefts, dropRights, end, findLeft,\n                                           findRight, fromList, hasLeft,\n                                           hasRight, index, insertPushLeft,\n                                           insertPushRight, lefts, moveLeft,\n                                           moveLeftLoop, moveLeftN, moveLeftN\',\n                                           moveRight, moveRightLoop, moveRightN,\n                                           moveRightN\', nth, rights, setFocus,\n                                           start, swapLeft, swapRight, toList,\n                                           toListZ, toOptional, withFocus,\n                                           zipper, (-<<))\nimport           Course.Optional          (Optional (Empty, Full))\nimport           Course.Traversable       (traverse)\n\nimport           Course.Gens              (forAllListZipper,\n                                           forAllListZipperWithInt, forAllLists,\n                                           forAllListsAndBool)\nspec :: Spec\nspec = do\n  describe "Functor" $ do\n    it "ListZipper (<$>)" $\n      (+1) <$> zipper [3,2,1] 4 [5,6,7] `shouldBe` zipper [4,3,2] 5 [6,7,8]\n\n  describe "Functor Maybe" $ do\n    it "MaybeListZipper (<$>)" $\n      (+1) <$> IsZ (zipper [3,2,1] 4 [5,6,7]) `shouldBe` IsZ (zipper [4,3,2] 5 [6,7,8])\n\n  describe "toList" $ do\n    it "Optional empty list" $\n      toList <$> Empty `shouldBe` (Empty :: Optional (List Int))\n    it "empty left" $\n      toList (zipper [] 1 [2,3,4]) `shouldBe` (1:.2:.3:.4:.Nil)\n    it "lefts and rights" $\n      toList (zipper [3,2,1] 4 [5,6,7]) `shouldBe` (1:.2:.3:.4:.5:.6:.7:.Nil)\n\n  describe "fromList" $ do\n    it "non-empty" $ fromList (1 :. 2 :. 3 :. Nil) `shouldBe` IsZ (zipper [] 1 [2,3])\n    it "empty" $ fromList Nil `shouldBe` (IsNotZ :: MaybeListZipper Integer)\n    prop "round trip" $\n      forAllLists (\\xs -> toListZ (fromList xs) === xs)\n\n  describe "toOptional" $ do\n    prop "empty" $\n      forAllLists $ \\xs ->\n        isEmpty xs === (toOptional (fromList xs) == Empty)\n\n  describe "withFocus" $ do\n    it "empty left" $\n      withFocus (+1) (zipper [] 0 [1]) `shouldBe` zipper [] 1 [1]\n    it "left and right" $\n      withFocus (+1) (zipper [1,0] 2 [3,4]) `shouldBe` zipper [1,0] 3 [3,4]\n\n  describe "setFocus" $ do\n    it "empty left" $\n      setFocus 1 (zipper [] 0 [1]) `shouldBe` zipper [] 1 [1]\n    it "left and right" $\n      setFocus 1 (zipper [1,0] 2 [3,4]) `shouldBe` zipper [1,0] 1 [3,4]\n\n  describe "hasLeft" $ do\n    it "left and right" $ hasLeft (zipper [1,0] 2 [3,4]) `shouldBe` True\n    it "empty left" $ hasLeft (zipper [] 0 [1,2]) `shouldBe` False\n\n  describe "hasRight" $ do\n    it "left and right" $ hasRight (zipper [1,0] 2 [3,4]) `shouldBe` True\n    it "empty right" $ hasRight (zipper [1,0] 2 []) `shouldBe` False\n\n  describe "findLeft" $ do\n    prop "missing element returns IsNotZ" $\n      forAllListsAndBool (\\(xs, p) -> findLeft (const p) -<< fromList xs === IsNotZ)\n    it "found in left" $\n      findLeft (== 1) (zipper [2,1] 3 [4,5]) `shouldBe` IsZ (zipper [] 1 [2,3,4,5])\n    it "not found" $\n      findLeft (== 6) (zipper [2,1] 3 [4,5]) `shouldBe` IsNotZ\n    it "one match in left" $\n      findLeft (== 1) (zipper [2,1] 1 [4,5]) `shouldBe` IsZ (zipper [] 1 [2,1,4,5])\n    it "multiple matches in left" $\n      findLeft (== 1) (zipper [1,2,1] 3 [4,5]) `shouldBe` IsZ (zipper [2,1] 1 [3,4,5])\n    it "elements shifted to right correctly" $\n      findLeft (== 1) (zipper [3,4,1,5] 9 [2,7]) `shouldBe` IsZ (zipper [5] 1 [4,3,9,2,7])\n\n  describe "findRight" $ do\n    prop "missing element returns IsNotZ" $\n      forAllLists (\\xs -> findRight (const False) -<< fromList xs === IsNotZ)\n    it "found in right" $\n      findRight (== 5) (zipper [2,1] 3 [4,5]) `shouldBe` IsZ (zipper [4,3,2,1] 5 [])\n    it "not found" $\n      findRight (== 6) (zipper [2,1] 3 [4,5]) `shouldBe` IsNotZ\n    it "one match in right" $\n      findRight (== 1) (zipper [2,3] 1 [4,5,1]) `shouldBe` IsZ (zipper [5,4,1,2,3] 1 [])\n    it "multiple matches in right" $\n      findRight (== 1) (zipper [2,3] 1 [1,4,5,1]) `shouldBe` IsZ (zipper [1,2,3] 1 [4,5,1])\n\n  describe "moveLeftLoop" $ do\n    it "with left" $\n      moveLeftLoop (zipper [3,2,1] 4 [5,6,7]) `shouldBe` zipper [2,1] 3 [4,5,6,7]\n    it "empty left" $\n      moveLeftLoop (zipper [] 1 [2,3,4]) `shouldBe` zipper [3,2,1] 4 []\n\n  describe "moveRightLoop" $ do\n    it "with right" $\n      moveRightLoop (zipper [3,2,1] 4 [5,6,7]) `shouldBe` zipper [4,3,2,1] 5 [6,7]\n    it "empty right" $\n      moveRightLoop (zipper [3,2,1] 4 []) `shouldBe` zipper [] 1 [2,3,4]\n\n  describe "moveLeft" $ do\n    it "with left" $\n      moveLeft (zipper [3,2,1] 4 [5,6,7]) `shouldBe` IsZ (zipper [2,1] 3 [4,5,6,7])\n    it "empty left" $\n      moveLeft (zipper [] 1 [2,3,4]) `shouldBe` IsNotZ\n\n  describe "moveRight" $ do\n    it "with right" $\n      moveRight (zipper [3,2,1] 4 [5,6,7]) `shouldBe` IsZ (zipper [4,3,2,1] 5 [6,7])\n    it "empty right" $\n      moveRight (zipper [3,2,1] 4 []) `shouldBe` IsNotZ\n\n  describe "swapLeft" $ do\n    it "with left" $\n      swapLeft (zipper [3,2,1] 4 [5,6,7]) `shouldBe` IsZ (zipper [4,2,1] 3 [5,6,7])\n    it "empty left" $\n      swapLeft (zipper [] 1 [2,3,4]) `shouldBe` IsNotZ\n\n  describe "swapRight" $ do\n    it "with right" $\n      swapRight (zipper [3,2,1] 4 [5,6,7]) `shouldBe` IsZ (zipper [3,2,1] 5 [4,6,7])\n    it "empty right" $\n      swapRight (zipper [3,2,1] 4 []) `shouldBe` IsNotZ\n\n  describe "dropLeft" $ do\n    it "with left" $\n      dropLefts (zipper [3,2,1] 4 [5,6,7]) `shouldBe` zipper [] 4 [5,6,7]\n    it "empty left" $\n      dropLefts (zipper [] 1 [2,3,4]) `shouldBe` zipper [] 1 [2,3,4]\n    prop "dropLefts empties left of zipper"\n      (\\l x r -> dropLefts (zipper l x r) === (zipper [] x r :: ListZipper Integer))\n\n  describe "dropRights" $ do\n    it "with right" $\n      dropRights (zipper [3,2,1] 4 [5,6,7]) `shouldBe` zipper [3,2,1] 4 []\n    it "empty right" $\n      dropRights (zipper [3,2,1] 4 []) `shouldBe` zipper [3,2,1] 4 []\n    prop "dropRights empties right of zipper"\n      (\\l x r -> dropRights (zipper l x r) === (zipper l x [] :: ListZipper Integer))\n\n  describe "moveLeftN" $ do\n    it "positive moves" $\n      moveLeftN 2 (zipper [2,1,0] 3 [4,5,6]) `shouldBe` IsZ (zipper [0] 1 [2,3,4,5,6])\n    it "negative moves" $\n      moveLeftN (-1) (zipper [2,1,0] 3 [4,5,6]) `shouldBe` IsZ (zipper [3,2,1,0] 4 [5,6])\n\n  describe "moveRightN" $ do\n    it "positive moves" $\n      moveRightN 1 (zipper [2,1,0] 3 [4,5,6]) `shouldBe` IsZ (zipper [3,2,1,0] 4 [5,6])\n    it "negative moves" $\n      moveRightN (-1) (zipper [2,1,0] 3 [4,5,6]) `shouldBe` IsZ (zipper [1,0] 2 [3,4,5,6])\n\n  describe "moveLeftN\'" $ do\n    it "positive - out of bounds both sides" $\n      moveLeftN\' 4 (zipper [3,2,1] 4 [5,6,7]) `shouldBe` Left 3\n    it "positive in range" $\n      moveLeftN\' 1 (zipper [3,2,1] 4 [5,6,7]) `shouldBe` Right (zipper [2,1] 3 [4,5,6,7])\n    prop "moving zero is `Right . id`"\n      (\\l x r -> let lz = zipper l x r :: ListZipper Integer\n                  in moveLeftN\' 0 lz === (Right . id $ lz))\n    it "negative in range" $\n      moveLeftN\' (-2) (zipper [3,2,1] 4 [5,6,7]) `shouldBe` Right (zipper [5,4,3,2,1] 6 [7])\n    it "negative out of bounds" $\n      moveLeftN\' (-4 ) (zipper [3,2,1] 4 [5,6,7]) `shouldBe` Left 3\n    it "positive - out of bounds on left only" $\n      moveLeftN\' 4 (zipper [3,2,1] 4 [5,6,7,8,9]) `shouldBe` Left 3\n    it "negative - out of bounds on right only" $\n      moveLeftN\' (-4) (zipper [5,4,3,2,1] 6 [7,8,9]) `shouldBe` Left 3\n\n  describe "moveRightN\'" $ do\n    it "positive - out of bounds both sides" $\n      moveRightN\' 4 (zipper [3,2,1] 4 [5,6,7]) `shouldBe` Left 3\n    it "positive in range" $\n      moveRightN\' 1 (zipper [3,2,1] 4 [5,6,7]) `shouldBe` Right (zipper [4,3,2,1] 5 [6,7])\n    prop "moving zero is `Right . id`"\n      (\\l x r -> let lz = (zipper l x r :: ListZipper Integer) in moveRightN\' 0 lz === (Right . id $ lz))\n    it "negative in range" $\n      moveRightN\' (-2) (zipper [3,2,1] 4 [5,6,7]) `shouldBe` Right (zipper [1] 2 [3,4,5,6,7])\n    it "negative - out of bounds both sides" $\n      moveRightN\' (-4) (zipper [3,2,1] 4 [5,6,7]) `shouldBe` Left 3\n\n  describe "nth" $ do\n    it "have 1"    $ nth 1 (zipper [3,2,1] 4 [5,6,7]) `shouldBe` IsZ (zipper [1] 2 [3,4,5,6,7])\n    it "have 5"    $ nth 5 (zipper [3,2,1] 4 [5,6,7]) `shouldBe` IsZ (zipper [5,4,3,2,1] 6 [7])\n    it "missing 8" $ nth 8 (zipper [3,2,1] 4 [5,6,7]) `shouldBe` IsNotZ\n\n  describe "index" $ do\n    it "index works" $ index (zipper [3,2,1] 4 [5,6,7]) `shouldBe` 3\n    prop "Always returns the index on a valid zipper" $\n      forAllListZipperWithInt $ \\(z,i) ->\n        optional True (\\z\' -> index z\' == i) (toOptional (nth i z))\n\n  describe "end" $ do\n    it "end" $ end (zipper [3,2,1] 4 [5,6,7]) `shouldBe` zipper [6,5,4,3,2,1] 7 []\n    prop "end never changes the zipper\'s contents" $\n      forAllListZipper (\\z -> toList z === toList (end z))\n    prop "never have rights after calling end" $\n      forAllListZipper (\\z -> rights (end z) === Nil)\n\n  describe "start" $ do\n    it "start" $ start (zipper [3,2,1] 4 [5,6,7]) `shouldBe` zipper [] 1 [2,3,4,5,6,7]\n    prop "start never changes the zipper\'s contents" $\n      forAllListZipper (\\z -> toList z === toList (start z))\n    prop "never have lefts after calling start" $\n      forAllListZipper (\\z -> lefts (start z) === Nil)\n\n  describe "deletePullLeft" $ do\n    it "non-empty lefts" $ deletePullLeft (zipper [3,2,1] 4 [5,6,7]) `shouldBe` IsZ (zipper [2,1] 3 [5,6,7])\n    it "empty lefts" $ deletePullLeft (zipper [] 1 [2,3,4]) `shouldBe` IsNotZ\n\n  describe "deletePullRight" $ do\n    it "non-empty rights" $ deletePullRight (zipper [3,2,1] 4 [5,6,7]) `shouldBe` IsZ (zipper [3,2,1] 5 [6,7])\n    it "empty rights" $ deletePullRight (zipper [3,2,1] 4 []) `shouldBe` IsNotZ\n\n  describe "insertPushLeft" $ do\n    it "non-empty lefts" $\n      insertPushLeft 15 (zipper [3,2,1] 4 [5,6,7]) `shouldBe` zipper [4,3,2,1] 15 [5,6,7]\n    it "empty lefts" $\n      insertPushLeft 15 (zipper [] 1 [2,3,4]) `shouldBe` zipper [1] 15 [2,3,4]\n    prop "deletePullLeft . insertPushLeft === id" $\n      forAllListZipperWithInt $ \\(z,i) ->\n        optional\n          False\n          (== z)\n          (toOptional (deletePullLeft (insertPushLeft (P.fromIntegral i) z)))\n\n  describe "insertPushRight" $ do\n    it "non-empty rights" $\n      insertPushRight 15 (zipper [3,2,1] 4 [5,6,7]) `shouldBe` zipper [3,2,1] 15 [4,5,6,7]\n    it "empty rights" $\n      insertPushRight 15 (zipper [3,2,1] 4 []) `shouldBe` zipper [3,2,1] 15 [4]\n    prop "deletePullRight . insertPushRight === id" $\n      forAllListZipperWithInt $ \\(z,i) ->\n        optional\n          False\n          (== z)\n          (toOptional (deletePullRight (insertPushRight (P.fromIntegral i) z)))\n\n  describe "Applicative" $ do\n    prop "pure produces infinite lefts"\n      (\\a n -> (all . (==) <*> take (n :: Int) . lefts . pure) (a :: Integer))\n    prop "pure produces infinite rights"\n      (\\a n -> (all . (==) <*> take (n :: Int) . rights . pure) (a :: Integer))\n    it "<*> applies functions to corresponding elements in zipper" $\n      zipper [(+2), (+10)] (*2) [(*3), (4*), (5+)] <*> zipper [3,2,1] 4 [5,6,7] `shouldBe` zipper [5,12] 8 [15,24,12]\n\n  let\n    is (IsZ z) = z\n    is _       = error "MaybeListZipper\'s Applicative instances is busted"\n    notZ       = IsNotZ :: MaybeListZipper Integer\n\n  describe "Applicative (MaybeListZipper)" $ do\n    prop "pure produces infinite lefts"\n      (\\a n -> (all . (==) <*> take (n :: Int) . lefts . is . pure) (a :: Integer))\n    prop "pure produces infinite rights"\n      (\\a n -> (all . (==) <*> take (n :: Int) . rights . is . pure) (a :: Integer))\n    it "IsZ <*> IsZ" $\n      let z = IsZ (zipper [(+2), (+10)] (*2) [(*3), (4*), (5+)]) <*> IsZ (zipper [3,2,1] 4 [5,6,7])\n       in z `shouldBe` IsZ (zipper [5,12] 8 [15,24,12])\n    prop "IsNotZ <*> IsZ" $\n      let fs = (IsNotZ :: MaybeListZipper (Integer -> Integer))\n       in forAllListZipper (\\z -> (fs <*> IsZ z) === IsNotZ)\n    prop "IsZ <*> IsNotZ"\n      (\\(Fun _ f) -> (IsZ (pure f) <*> notZ) === notZ)\n    it "IsNotZ <*> IsNotZ" $\n      IsNotZ <*> notZ `shouldBe` notZ\n\n  describe "Extend" $ do\n    it "zipper o\' zippers" $ do\n      let\n        z = zipper [2,1] 3 [4,5]\n        l = [zipper [1] 2 [3,4,5], zipper [] 1 [2,3,4,5]]\n        r = [zipper [3,2,1] 4 [5], zipper [4,3,2,1] 5 []]\n      (id <<= z) `shouldBe` zipper l z r\n\n  describe "Extend (MaybeListZipper)" $ do\n    it "IsNotZ" $\n      (id <<= IsNotZ) `shouldBe` (IsNotZ :: MaybeListZipper (MaybeListZipper Integer))\n    it "IsZ" $ do\n      let\n        z = IsZ (zipper [2,1] 3 [4,5])\n        l = IsZ P.<$> [zipper [1] 2 [3,4,5], zipper [] 1 [2,3,4,5]]\n        r = IsZ P.<$> [zipper [3,2,1] 4 [5], zipper [4,3,2,1] 5 []]\n      (id <<= z) `shouldBe` IsZ (zipper l z r)\n\n  describe "Comonad" $ do\n    it "copure" $ copure (zipper [2,1] 3 [4,5]) `shouldBe` 3\n\n  describe "Traversable" $ do\n    prop "All Full" $\n      forAllListZipper (\\z -> traverse id (Full <$> z) === Full z)\n    it "One Empty" $\n      traverse id (zipper [Full 1, Full 2, Full 3] (Full 4) [Empty, Full 6, Full 7])\n        `shouldBe`\n          Empty\n\n  describe "Traversable (MaybeListZipper)" $ do\n    it "IsNotZ" $\n      traverse id IsNotZ `shouldBe` (Full IsNotZ :: Optional (MaybeListZipper Integer))\n    prop "IsZ Full" $\n      forAllListZipper (\\z -> traverse id (Full <$> IsZ z) === Full (IsZ z))\n\noptional :: b -> (a -> b) -> Optional a -> b\noptional e _ Empty    = e\noptional _ f (Full a) = f a\n'