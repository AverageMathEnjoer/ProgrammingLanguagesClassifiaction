b'#\' nameReweight\n#\'\n#\' Reweights posterior probabilities to account for observed frequency\n#\' of names. Downweights posterior probability of match if first name is common,\n#\' upweights if first name is uncommon.\n#\'\n#\' @usage nameReweight(dfA, dfB, EM, gammalist, matchesLink,\n#\' varnames, firstname.field, patterns, threshold.match, n.cores)\n#\' @param dfA The full version of dataset A that is being matched.\n#\' @param dfB The full version of dataset B that is being matched.\n#\' @param EM The EM object from \\code{emlinkMARmov()}\n#\' @param gammalist The list of gamma objects calculated on the full\n#\' dataset that indicate matching patterns, which is fed into \\code{tableCounts()}\n#\' and \\code{matchesLink()}.\n#\' @param matchesLink The output from \\code{matchesLink()}.\n#\' @param varnames A vector of variable names to use for matching.\n#\' Must be present in both matchesA and matchesB.\n#\' @param firstname.field A vector of booleans, indicating whether each field indicates\n#\' first name. TRUE if so, otherwise FALSE.\n#\' @param patterns The output from \\code{getPatterns()}.\n#\' @param threshold.match A number between 0 and 1 indicating either the lower bound (if only one number provided) or the range of certainty that the\n#\' user wants to declare a match. For instance, threshold.match = .85 will return all pairs with posterior probability greater than .85 as matches,\n#\' while threshold.match = c(.85, .95) will return all pairs with posterior probability between .85 and .95 as matches.\n#\' @param n.cores Number of cores to parallelize over. Default is NULL.\n#\'\n#\' @return \\code{nameReweight()} returns a list containing the following elements:\n#\' \\item{zetaA}{The reweighted zeta estimates for each matched element in dataset A.}\n#\' \\item{zetaB}{The reweighted zeta estimates for each matched element in dataset B.}\n#\' @author Ted Enamorado <ted.enamorado@gmail.com> and Ben Fifield <benfifield@gmail.com>\n#\' @export\nnameReweight <- function(dfA, dfB, EM, gammalist, matchesLink,\n                         varnames, firstname.field, patterns,\n                         threshold.match, n.cores = NULL){\n\n    if(sum(firstname.field) == 0){\n        stop("You have not indicated which field represents first name.")\n    }\n    \n    ## Get cores\n    if(is.null(n.cores)) {\n        n.cores <- detectCores() - 1\n    }\n    \n    ## Clean up EM object\n    resultsEM <- EM\n    EM <- data.frame(cbind(resultsEM$patterns.w))\n    EM$zeta.j <- resultsEM$zeta.j\t\t\t\n    EM <- EM[order(EM[, "weights"]), ] \n    EM$cumsum.m <- cumsum(EM[, "p.gamma.j.m"])\n    EM$cumsum.u <- 1 - cumsum(EM[, "p.gamma.j.u"])\n\n    ## Subset down to perfect matches on first name\n    firstname.field <- which(firstname.field == TRUE)\n    EM.names <- as.matrix(EM[EM$zeta.j >= 1e-9 & EM[,firstname.field] == 2,])\n    EM.names2 <- EM.names[, c(1:ncol(resultsEM$patterns.w))]\n    resultsEM2 <- resultsEM\n    if(ncol(as.matrix(EM.names2)) == 1){\n        resultsEM2$patterns.w <- t(as.matrix(EM.names2))\n    }else{\n        resultsEM2$patterns.w <- as.matrix(EM.names2)\n    }\n    resultsEM2$zeta.j <- as.matrix(EM$zeta.j[EM$zeta.j > 1e-9 & EM[,firstname.field] == 2,])\n    match.ut <- min(resultsEM2$patterns.w[, "weights"]) - 0.01\n\n    ## We recover all the pairs that match on name:\n    list.m <- matchesLink(gammalist, nobs.a = nrow(dfA), nobs.b = nrow(dfB), em = resultsEM2, thresh = threshold.match, n.cores = n.cores)\n\n    ## Datasets with such matches\n    dfA$ind.orig <- 1:nrow(dfA)\n    dfB$ind.orig <- 1:nrow(dfB)\n    matchesA.f <- dfA[ matchesLink$inds.a, ]\n    matchesB.f <- dfB[ matchesLink$inds.b, ]\n\n    fn.field <- varnames[firstname.field]\n\n    ## Gammalist\n    gammalist <- patterns\n\n    ## Merge gammalist\n    namevec <- names(patterns)\n    matchesA.f <- cbind(matchesA.f, gammalist)\n    matchesA.f <- merge(matchesA.f, EM, by = namevec, all.x = T)\n    matchesB.f <- cbind(matchesB.f, gammalist)\n    matchesB.f <- merge(matchesB.f, EM, by = namevec, all.x = T)\n\n    matchesA <- matchesA.f[ matchesA.f$ind.orig %in%\n                            intersect(matchesLink$inds.a, list.m$inds.a), ]\n    matchesB <- matchesB.f[ matchesB.f$ind.orig %in%\n                            intersect(matchesLink$inds.b, list.m$inds.b), ]\n\n    ## ---------------------\n    ## Start name adjustment\n    ## ---------------------\n    ## Factors to adjust names:\n    fn.1 <- tapply(matchesA$zeta.j, matchesA[,fn.field], sum)\n    fn.2 <- tapply(1 - matchesA$zeta.j, matchesA[,fn.field], sum)\n\n    fcto <- data.frame(cbind(fn.1, fn.2))\n    fcto$first.name <- rownames(fcto)\n    names(fcto)[3] <- fn.field\n\n    matchesA.f$id.o <- 1:nrow(matchesA.f)\n    matchesB.f$id.o <- 1:nrow(matchesB.f)\n    matches.names.A <- merge(matchesA.f, fcto, by = fn.field, all.x = T)\n    matches.names.B <- merge(matchesB.f, fcto, by = fn.field, all.x = T)\n    matches.names.A <- matches.names.A[order(matches.names.A$id.o), ]\n    matches.names.B <- matches.names.B[order(matches.names.B$id.o), ]\n\n    matches.names.A$zeta.j.names <- (matches.names.A$fn.1 * matches.names.A$p.gamma.j.m) /\n        (matches.names.A$fn.1 * matches.names.A$p.gamma.j.m + matches.names.A$fn.2 * matches.names.A$p.gamma.j.u)\n    matches.names.B$zeta.j.names <- (matches.names.B$fn.1 * matches.names.B$p.gamma.j.m) /\n        (matches.names.B$fn.1 * matches.names.B$p.gamma.j.m + matches.names.B$fn.2 * matches.names.B$p.gamma.j.u)\n\n    ind <- paste0("gamma.", firstname.field)\n    matches.names.A$zeta.j.names[matches.names.A[,ind] != 2] <- NA\n    matches.names.B$zeta.j.names[matches.names.B[,ind] != 2] <- NA\n\n    ## ----------------------------------\n    ## Output reweighted matched data set\n    ## ----------------------------------\n    return(matches.names.A$zeta.j.names)\n\n}\n\n'