b'{-# OPTIONS_GHC -fno-warn-unused-do-bind #-}\n{-# LANGUAGE TupleSections #-}\n\n-- | Migrations support for SQLite databases\nmodule Database.Beam.Sqlite.Migrate\n  ( -- * @beam-migrate@ CLI support\n    migrationBackend, SqliteCommandSyntax\n\n    -- * @beam-migrate@ utility functions\n  , migrateScript, writeMigrationScript\n  , sqlitePredConverter, sqliteTypeToHs\n  , getDbConstraints\n\n    -- * SQLite-specific data types\n  , sqliteText, sqliteBlob, sqliteBigInt\n  ) where\n\nimport qualified Database.Beam.Migrate as Db\nimport qualified Database.Beam.Migrate.Backend as Tool\nimport qualified Database.Beam.Migrate.Serialization as Db\nimport           Database.Beam.Migrate.Types (QualifiedName(..))\nimport qualified Database.Beam.Query.DataTypes as Db\n\nimport           Database.Beam.Backend.SQL\nimport           Database.Beam.Haskell.Syntax\nimport           Database.Beam.Sqlite.Connection\nimport           Database.Beam.Sqlite.Syntax\n\nimport           Control.Applicative\nimport           Control.Exception\nimport           Control.Monad.Reader\n\nimport           Database.SQLite.Simple (open, close, query_)\n\nimport           Data.Aeson\nimport           Data.Attoparsec.Text (asciiCI, skipSpace)\nimport qualified Data.Attoparsec.Text as A\nimport           Data.ByteString (ByteString)\nimport qualified Data.ByteString.Lazy.Char8 as BL\nimport           Data.Char (isSpace)\nimport           Data.Int (Int64)\nimport           Data.List (sortBy)\nimport           Data.Maybe (mapMaybe, isJust)\nimport           Data.Monoid (Endo(..))\nimport           Data.Ord (comparing)\nimport           Data.String (fromString)\nimport qualified Data.Text as T\nimport qualified Data.Text.Encoding as TE\n\n-- | Top-level \'Tool.BeamMigrationBackend\' loaded dynamically by the\n-- @beam-migrate@ CLI tool.\nmigrationBackend :: Tool.BeamMigrationBackend Sqlite SqliteM\nmigrationBackend = Tool.BeamMigrationBackend\n                       "sqlite"\n                       "For beam-sqlite, this is the path to a sqlite3 file"\n                       getDbConstraints\n                       (Db.sql92Deserializers <> sqliteDataTypeDeserializers <>\n                        Db.beamCheckDeserializers)\n                       (BL.unpack . (<> ";") . sqliteRenderSyntaxScript . fromSqliteCommand)\n                       "sqlite.sql"\n                       sqlitePredConverter Db.defaultActionProvider\n                       (\\fp action ->\n                            bracket (open fp) close $ \\conn ->\n                              catch (Right <$> runReaderT (runSqliteM action)\n                                                          (\\_ -> pure (), conn))\n                                    (\\e -> pure (Left (show (e :: SomeException)))))\n\n-- | \'Db.BeamDeserializers\' or SQLite specific types. Specifically,\n-- \'sqliteBlob\', \'sqliteText\', and \'sqliteBigInt\'. These are compatible with the\n-- "typical" serialized versions of the standard \'Db.binaryLargeObject\',\n-- \'Db.characterLargeObject\', and \'Db.bigint\' types.\nsqliteDataTypeDeserializers :: Db.BeamDeserializers Sqlite\nsqliteDataTypeDeserializers =\n  Db.beamDeserializer $ \\_ v ->\n  fmap (id @SqliteDataTypeSyntax) $\n  case v of\n    "blob" -> pure sqliteBlobType\n    "clob" -> pure sqliteTextType\n    "bigint" -> pure sqliteBigIntType\n    Object o ->\n       (fmap (\\(_ :: Maybe Word) -> sqliteBlobType) (o .: "binary")) <|>\n       (fmap (\\(_ :: Maybe Word) -> sqliteBlobType) (o .: "varbinary"))\n    _ -> fail "Could not parse sqlite-specific data type"\n\n-- | Render a series of \'Db.MigrationSteps\' in the \'SqliteCommandSyntax\' into a\n-- line-by-line list of lazy \'BL\'ByteString\'s. The output is suitable for\n-- inclusion in a migration script. Comments are generated giving a description\n-- of each migration step.\nmigrateScript :: Db.MigrationSteps Sqlite () a -> [BL.ByteString]\nmigrateScript steps =\n  "-- Generated by beam-sqlite beam-migrate backend\\n" :\n  "\\n" :\n  appEndo (Db.migrateScript renderHeader renderCommand steps) []\n  where\n    renderHeader nm =\n      Endo (("-- " <> BL.fromStrict (TE.encodeUtf8 nm) <> "\\n"):)\n    renderCommand cmd =\n      Endo ((sqliteRenderSyntaxScript (fromSqliteCommand cmd) <> ";\\n"):)\n\n-- | Write the output of \'migrateScript\' to a file\nwriteMigrationScript :: FilePath -> Db.MigrationSteps Sqlite () a -> IO ()\nwriteMigrationScript fp steps =\n  let stepBs = migrateScript steps\n  in BL.writeFile fp (BL.concat stepBs)\n\n-- | \'Tool.HaskellPredicateConverter\' that can convert all constraints generated\n-- by \'getDbConstaints\' into their equivalent in the @beam-migrate@ haskell\n-- syntax. Suitable for auto-generation of a haskell migration.\nsqlitePredConverter :: Tool.HaskellPredicateConverter\nsqlitePredConverter = Tool.sql92HsPredicateConverters @Sqlite sqliteTypeToHs <>\n                      Tool.hsPredicateConverter sqliteHasColumnConstraint\n  where\n    sqliteHasColumnConstraint (Db.TableColumnHasConstraint tblNm colNm c ::\n                                  Db.TableColumnHasConstraint Sqlite)\n      | c == Db.constraintDefinitionSyntax Nothing Db.notNullConstraintSyntax Nothing =\n        Just (Db.SomeDatabasePredicate (Db.TableColumnHasConstraint tblNm colNm (Db.constraintDefinitionSyntax Nothing Db.notNullConstraintSyntax Nothing) ::\n                                           Db.TableColumnHasConstraint HsMigrateBackend))\n      | otherwise = Nothing\n\n-- | Convert a SQLite data type to the corresponding Haskell one\nsqliteTypeToHs :: SqliteDataTypeSyntax\n               -> Maybe HsDataType\nsqliteTypeToHs = Just . sqliteDataTypeToHs\n\nparseSqliteDataType :: T.Text -> SqliteDataTypeSyntax\nparseSqliteDataType txt =\n  case A.parseOnly dtParser txt of\n    Left {} -> SqliteDataTypeSyntax (emit (TE.encodeUtf8 txt))\n                                    (hsErrorType ("Unknown SQLite datatype \'" ++ T.unpack txt ++ "\'"))\n                                    (Db.BeamSerializedDataType $\n                                     Db.beamSerializeJSON "sqlite"\n                                       (toJSON txt))\n                                    False\n    Right x -> x\n  where\n    dtParser = charP <|> varcharP <|>\n               ncharP <|> nvarcharP <|>\n               bitP <|> varbitP <|> numericP <|> decimalP <|>\n               doubleP <|> integerP <|>\n               smallIntP <|> bigIntP <|> floatP <|>\n               doubleP <|> realP <|> dateP <|>\n               timestampP <|> timeP <|> textP <|>\n               blobP <|> booleanP\n\n    ws = A.many1 A.space\n\n    characterP = asciiCI "CHARACTER" <|> asciiCI "CHAR"\n    characterVaryingP = characterP >> ws >> asciiCI "VARYING"\n    charP = do\n      characterP\n      charType <$> precP <*> charSetP\n    varcharP = do\n      asciiCI "VARCHAR" <|> characterVaryingP\n      varCharType <$> precP <*> charSetP\n    ncharP = do\n      asciiCI "NATIONAL"\n      ws\n      characterP\n      nationalCharType <$> precP\n    nvarcharP = do\n      asciiCI "NVARCHAR" <|> (asciiCI "NATIONAL" >> ws >> characterVaryingP)\n      nationalVarCharType <$> precP\n    bitP = do\n      asciiCI "BIT"\n      bitType <$> precP\n    varbitP = do\n      asciiCI "VARBIT" <|> (asciiCI "BIT" >> ws >> asciiCI "VARYING")\n      varBitType <$> precP\n\n    numericP = do\n      asciiCI "NUMERIC"\n      numericType <$> numericPrecP\n    decimalP = do\n      asciiCI "DECIMAL"\n      decimalType <$> numericPrecP\n    floatP = do\n      asciiCI "FLOAT"\n      floatType <$> precP\n    doubleP = do\n      asciiCI "DOUBLE"\n      optional $ skipSpace >> asciiCI "PRECISION"\n      pure doubleType\n    realP = realType <$ asciiCI "REAL"\n\n    intTypeP =\n      asciiCI "INT" <|> asciiCI "INTEGER"\n    integerP = do\n      intTypeP\n      pure intType\n    smallIntP = do\n      asciiCI "INT2" <|> (asciiCI "SMALL" >> optional ws >> intTypeP)\n      pure smallIntType\n    bigIntP = do\n      asciiCI "INT8" <|> (asciiCI "BIG" >> optional ws >> intTypeP)\n      pure sqliteBigIntType\n    dateP = dateType <$ asciiCI "DATE"\n    timeP = do\n      asciiCI "TIME"\n      timeType <$> precP <*> timezoneP\n    timestampP = do\n      asciiCI "TIMESTAMP"\n      timestampType <$> precP <*> timezoneP\n    textP = sqliteTextType <$ asciiCI "TEXT"\n    blobP = sqliteBlobType <$ asciiCI "BLOB"\n\n    booleanP = booleanType <$ (asciiCI "BOOL" <|> asciiCI "BOOLEAN")\n\n    timezoneP = (skipSpace *>\n                 asciiCI "WITH" *> ws *>\n                 (asciiCI "TIMEZONE" <|>\n                  (asciiCI "TIME" >> ws >>\n                   asciiCI "ZONE")) *>\n                 pure True) <|>\n                pure False\n\n    precP = optional (skipSpace *> A.char \'(\' *>\n                      A.decimal <* A.char \')\')\n    numericPrecP = optional ((,) <$> (skipSpace *> A.char \'(\' *>\n                                      A.decimal)\n                                 <*> (skipSpace *>\n                                      optional (A.char \',\' *> skipSpace *>\n                                                 A.decimal) <*\n                                      skipSpace <* A.char \')\'))\n\n    charSetP = optional (skipSpace *>\n                         asciiCI "CHARACTER" *> ws *>\n                         asciiCI "SET" *> ws *>\n                         A.takeWhile (not . isSpace))\n\n-- TODO constraints and foreign keys\n\n-- | Get a list of database predicates for the current database. This is beam\'s\n-- best guess at providing a schema for the current database. Note that SQLite\n-- type names are not standardized, and the so-called column "affinities" are\n-- too broad to be of use. This function attemps to guess a good enough type\n-- based on the exact type supplied in the @CREATE TABLE@ commands. It will\n-- correctly parse any type generated by beam and most SQL compliant types, but\n-- it may falter on databases created or managed by tools that do not follow\n-- these standards.\ngetDbConstraints :: SqliteM [Db.SomeDatabasePredicate]\ngetDbConstraints =\n  SqliteM . ReaderT $ \\(_, conn) -> do\n    tblNames <- query_ conn "SELECT name, sql from sqlite_master where type=\'table\'"\n    tblPreds <-\n      fmap mconcat . forM tblNames $ \\(tblNameStr, sql) -> do\n        let tblName = QualifiedName Nothing tblNameStr\n        columns <- fmap (sortBy (comparing (\\(cid, _, _, _, _, _) -> cid :: Int))) $\n                   query_ conn (fromString ("PRAGMA table_info(\'" <> T.unpack tblNameStr <> "\')"))\n\n        let columnPreds =\n              foldMap\n                (\\(_ ::Int, nm, typStr, notNull, _, _) ->\n                     let dtType = if isAutoincrement then sqliteSerialType else parseSqliteDataType typStr\n                         isAutoincrement = isJust (A.maybeResult (A.parse autoincrementParser sql))\n\n                         autoincrementParser = do\n                           A.manyTill A.anyChar $ do\n                             hadQuote <- optional (A.char \'"\')\n                             A.string nm\n                             maybe (pure ()) (\\_ -> void $ A.char \'"\') hadQuote\n                             A.many1 A.space\n                             asciiCI "INTEGER"\n                             A.many1 A.space\n                             asciiCI "PRIMARY"\n                             A.many1 A.space\n                             asciiCI "KEY"\n                             A.many1 A.space\n                             asciiCI "AUTOINCREMENT"\n\n                         notNullPred =\n                           if notNull\n                           then [ Db.SomeDatabasePredicate\n                                    (Db.TableColumnHasConstraint tblName nm\n                                       (Db.constraintDefinitionSyntax Nothing Db.notNullConstraintSyntax Nothing)\n                                         :: Db.TableColumnHasConstraint Sqlite) ]\n                           else []\n\n                     in [ Db.SomeDatabasePredicate\n                            (Db.TableHasColumn tblName nm dtType ::\n                               Db.TableHasColumn Sqlite) ] ++\n                        notNullPred\n                )\n                columns\n\n            pkColumns = map fst $ sortBy (comparing snd) $\n                        mapMaybe (\\(_, nm, _, _, _ :: Maybe T.Text, pk) ->\n                                      (nm,) <$> (pk <$ guard (pk > (0 :: Int)))) columns\n            pkPred = case pkColumns of\n                       [] -> []\n                       _  -> [ Db.SomeDatabasePredicate (Db.TableHasPrimaryKey tblName pkColumns) ]\n        pure ( [ Db.SomeDatabasePredicate (Db.TableExistsPredicate tblName) ]\n             ++ pkPred ++ columnPreds )\n\n    pure tblPreds\n\nsqliteText :: Db.DataType Sqlite T.Text\nsqliteText = Db.DataType sqliteTextType\n\nsqliteBlob :: Db.DataType Sqlite ByteString\nsqliteBlob = Db.DataType sqliteBlobType\n\nsqliteBigInt :: Db.DataType Sqlite Int64\nsqliteBigInt = Db.DataType sqliteBigIntType\n\n'