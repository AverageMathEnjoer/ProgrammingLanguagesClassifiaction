b'{-# LANGUAGE NoImplicitPrelude #-}\nmodule Api.User (resource) where\n\nimport Prelude.Compat\n\nimport Control.Concurrent.STM (atomically, modifyTVar, readTVar)\nimport Control.Monad.Error.Class (throwError)\nimport Control.Monad.Reader (ReaderT, asks)\nimport Control.Monad.Trans (liftIO)\nimport Control.Monad.Trans.Except (ExceptT)\nimport Data.Set (Set)\nimport qualified Data.Foldable as F\nimport qualified Data.Set      as Set\nimport qualified Data.Text     as T\n\nimport Rest\nimport qualified Rest.Resource as R\n\nimport ApiTypes (BlogApi, ServerData (..))\nimport Type.User (User)\nimport Type.UserInfo (UserInfo (..))\nimport Type.UserSignupError (UserSignupError (..))\nimport qualified Type.User     as User\nimport qualified Type.UserInfo as UserInfo\n\n-- | User extends the root of the API with a reader containing the ways to identify a user in our URLs.\n-- Currently only by the user name.\ntype WithUser = ReaderT User.Name BlogApi\n\n-- | Defines the /user api end-point.\nresource :: Resource BlogApi WithUser User.Name () Void\nresource = mkResourceReader\n  { R.name   = "user" -- Name of the HTTP path segment.\n  , R.schema = withListing () $ named [("name", singleBy T.pack)]\n  , R.list   = const list -- requested by GET /user, gives a paginated listing of users.\n  , R.create = Just create -- PUT /user creates a new user\n  }\n\nlist :: ListHandler BlogApi\nlist = mkListing xmlJsonO handler\n  where\n    handler :: Range -> ExceptT Reason_ BlogApi [UserInfo]\n    handler r = do\n      usrs <- liftIO . atomically . readTVar =<< asks users\n      return . map toUserInfo . take (count r) . drop (offset r) . Set.toList $ usrs\n\n-- | Convert a User into a representation that is safe to show to the public.\ntoUserInfo :: User -> UserInfo\ntoUserInfo u = UserInfo { UserInfo.name = User.name u }\n\ncreate :: Handler BlogApi\ncreate = mkInputHandler (xmlJsonE . xmlJsonO . xmlJsonI) handler\n  where\n    handler :: User -> ExceptT (Reason UserSignupError) BlogApi UserInfo\n    handler usr = do\n      usrs <- asks users\n      merr <- liftIO . atomically $ do\n        vu <- validUserName usr <$> readTVar usrs\n        if not (validPassword usr)\n          then return . Just $ domainReason InvalidPassword\n          else if not vu\n            then return . Just $ domainReason InvalidUserName\n            else modifyTVar usrs (Set.insert usr) >> return Nothing\n      maybe (return $ toUserInfo usr) throwError merr\n\nvalidPassword :: User.User -> Bool\nvalidPassword = (> 1) . T.length . User.password\n\nvalidUserName :: User -> Set User -> Bool\nvalidUserName u usrs =\n  let un        = User.name u\n      available = F.all ((un /=). User.name) usrs\n      nonEmpty  = (> 1) . T.length $ un\n  in available && nonEmpty\n'