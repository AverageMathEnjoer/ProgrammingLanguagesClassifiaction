b"{-# LANGUAGE Arrows #-}\n\nimport           Control.Applicative\nimport           Control.Concurrent\nimport           Control.Monad\nimport           Control.Monad.Identity\nimport           Control.Monad.Trans.Reader\nimport           Data.MonadicStreamFunction hiding (reactimate, switch, trace)\nimport           Data.MonadicStreamFunction.InternalCore (MSF(..))\nimport qualified Data.MonadicStreamFunction as MSF\nimport           Debug.Trace\nimport           FRP.Yampa                  as Yampa\nimport           Graphics.UI.SDL            as SDL\nimport           Graphics.UI.SDL.Primitives as SDL\nimport           ListT                      as L\n\nmain = do\n   SDL.init [InitEverything]\n   SDL.setVideoMode 800 600 32 [SWSurface]\n   reactimate (getMouse)\n              (\\_ -> getMouse >>= (\\p -> return (0.02, Just p)))\n              (\\_ e -> render e >> return False)\n              bouncingBalls\n\nbouncingBalls = proc (mp@(mx, my, ml, mr)) -> do\n  b   <- bouncingBall (100.0 :: Float) (0.0) -< () -- Just to be sure the game is running\n\n  -- More balls, started on clicks\n  ml' <- isEvent ^<< edge -< ml\n  bs  <- fireballs        -< (ml', (my, 0))\n  returnA -< (b : bs)\n\nfireballs :: SF (Bool, (Float, Float)) [(Float, Float)]\nfireballs = switch\n  (arr (const []) &&& arr (\\(mp, pos) -> if mp then Event pos else Yampa.NoEvent))\n\n  (\\(p, v) -> let oldfb = voidI $ runListMSF (liftTransS (bouncingBall p v))\n                  newfb = fireballs\n              in (oldfb &&& newfb) >>> arr2 (++)\n  )\n\nbouncingBall :: Float -> Float -> SF () (Float, Float)\nbouncingBall p0 v0 =\n  switch (proc (_) -> do\n            (p,v)  <- fallingBall p0 v0  -< ()\n            bounce <- edge               -< (p <= 0 && v < 0)\n            returnA -< ((p,v), bounce `tag` (p, v))\n         )\n         (\\(p,v) -> bouncingBall 0 (flippedVel p0 v0 (-99.8)))\n\n-- Calculates the flipped velocity in terms of total energy instead of flipping\n-- the current velocity. This produces collisions without energy loss. I do not\n-- know how to generalise this for all collisions.\nflippedVel p0 v0 acc = sqrt (2 * (ike + ipe))\n  where ike = abs (acc * p0)\n        ipe = (v0**2)/2\n\nfallingBall :: Float -> Float -> SF () (Float, Float)\nfallingBall p0 v0 = proc () -> do\n  v <- (v0 +) ^<< integral -< (-99.8)\n  p <- (p0 +) ^<< integral -< v\n  returnA -< (p, v)\n\n-- Input\ngetMouse :: IO (Float, Float, Bool, Bool)\ngetMouse = do\n  pumpEvents\n  (x,y,btns) <- SDL.getMouseState\n  let left  = ButtonLeft  `elem` btns\n      right = ButtonRight `elem` btns\n  return (fromIntegral x, fromIntegral y, left, right)\n\n-- Output\nrender ps = do\n  screen <- SDL.getVideoSurface\n\n  white <- SDL.mapRGB (SDL.surfaceGetPixelFormat screen) 0xFF 0xFF 0xFF\n  SDL.fillRect screen Nothing white\n\n  mapM_ (\\((p,_),xi) ->\n     SDL.filledCircle screen (100 + xi * 100) (600 - 100 - round p) 30 (Pixel 0xFF0000FF))\n     (zip ps [1..])\n\n  SDL.flip screen\n\n  threadDelay 1000\n\n-- Auxiliary MSF functions\napplyMSF :: Monad m => (a -> MSF m b c) -> MSF m (a, b) c\napplyMSF f = MSF $ \\(a,b) -> do\n  (c, msf') <- unMSF (f a) b\n  return (c, arr snd >>> msf')\n\nrunListMSF :: (Functor m, Monad m) => MSF (ListT m) a b -> MSF m a [b]\nrunListMSF msf = runListMSF' [msf]\n  where\n    runListMSF' msfs = MSF $ \\a -> do\n        (bs, msfs') <- unzip . concat <$> mapM (toList . (`unMSF` a)) msfs\n        return (bs, runListMSF' msfs')\n\n-- Auxiliary Arrow functions\nvoidI :: Arrow a => a () c -> a b c\nvoidI =  (>>>) (arr (const ()))\n\narr2 :: Arrow a => (b -> c -> d) -> a (b,c) d\narr2 f = arr (uncurry f)\n"