b'module Database.Beam.Query.Aggregate\n  ( -- * Aggregates\n    -- | See the corresponding\n    --   <https://haskell-beam.github.io/beam/user-guide/queries/aggregates.md manual section>\n    --   for more detail\n\n    aggregate_\n  , filterWhere_, filterWhere_\'\n\n  , QGroupable(..)\n\n    -- ** General-purpose aggregate functions #gp-agg-funcs#\n  , sum_, avg_, min_, max_, count_, countAll_\n  , rank_, cumeDist_, percentRank_, denseRank_\n  , rowNumber_\n\n  , every_, any_, some_\n\n    -- ** Quantified aggregate functions\n    -- | These functions correspond one-to-one with the <#gp-agg-funcs\n    --   general-purpose aggregate functions>. However, they each take a\n    --   mandatory "set quantifier", which is any of the\n    --   <#set-quantifiers set quantifier> values.\n  , sumOver_, avgOver_, minOver_, maxOver_, countOver_\n  , everyOver_, anyOver_, someOver_\n\n    -- *** Set quantifiers #set-quantifiers#\n  , distinctInGroup_, allInGroup_, allInGroupExplicitly_\n  ) where\n\nimport Database.Beam.Query.Internal\nimport Database.Beam.Query.Operator\nimport Database.Beam.Query.Ord\n\nimport Database.Beam.Backend.SQL\nimport Database.Beam.Schema.Tables\n\nimport Control.Applicative\nimport Control.Monad.Writer\nimport Control.Monad.Free\n\nimport Data.Typeable\n\ntype Aggregable be a =\n  ProjectibleWithPredicate AggregateContext be (WithExprContext (BeamSqlBackendExpressionSyntax\' be)) a\n\n-- | Compute an aggregate over a query.\n--\n--   The supplied aggregate projection should return an aggregate expression (an\n--   expression containing an aggregate function such as \'count_\', \'sum_\',\n--   \'countAll_\', etc), a grouping key (specified with the \'group_\' function),\n--   or a combination of tuples of the above.\n--\n--   Appropriate instances are provided up to 8-tuples.\n--\n--   Semantically, all grouping expressions in the projection will be added to a\n--   SQL @GROUP BY@ clause and all aggregate expressions will be computed.\n--\n--   The return value will be the type of the aggregate projection, but\n--   transformed to be in the normal value context (i.e., everything will become\n--   \'QExpr\'s).\n--\n--   For usage examples, see\n--   <https://haskell-beam.github.io/beam/user-guide/queries/aggregates/ the manual>.\naggregate_ :: forall be a r db s.\n              ( BeamSqlBackend be\n              , Aggregable be a, Projectible be r, Projectible be a\n\n              , ContextRewritable a\n              , ThreadRewritable (QNested s) (WithRewrittenContext a QValueContext)\n              )\n           => (r -> a)                  -- ^ Aggregate projection\n           -> Q be db (QNested s) r -- ^ Query to aggregate over\n           -> Q be db s (WithRewrittenThread (QNested s) s (WithRewrittenContext a QValueContext))\naggregate_ mkAggregation (Q aggregating) =\n  Q (liftF (QAggregate mkAggregation\' aggregating (rewriteThread (Proxy @s) . rewriteContext (Proxy @QValueContext))))\n  where\n    mkAggregation\' x tblPfx =\n      let agg = mkAggregation x\n          doProject :: AggregateContext c\n                    => Proxy c -> Proxy be\n                    -> WithExprContext (BeamSqlBackendExpressionSyntax\' be)\n                    -> Writer [WithExprContext (BeamSqlBackendExpressionSyntax\' be)]\n                              (WithExprContext (BeamSqlBackendExpressionSyntax\' be))\n          doProject p _ expr =\n            case cast p of\n              Just (Proxy :: Proxy QGroupingContext) ->\n                tell [ expr ] >> pure expr\n              Nothing ->\n                case cast p of\n                  Just (Proxy :: Proxy QAggregateContext) ->\n                    pure expr\n                  Nothing -> error "aggregate_: impossible"\n\n          groupingExprs =\n            fmap (fmap fromBeamSqlBackendExpressionSyntax) $\n            execWriter (project\' (Proxy @AggregateContext) (Proxy @(be, WithExprContext (BeamSqlBackendExpressionSyntax\' be))) doProject agg)\n      in case groupingExprs of\n           [] -> (Nothing, agg)\n           _ -> (Just (groupByExpressions (sequenceA groupingExprs tblPfx)), agg)\n\n-- | Type class for grouping keys. \'expr\' is the type of the grouping key after\n--   projection. \'grouped\' is the type of the grouping key in the aggregate\n--   expression (usually something that contains \'QGenExpr\'s in the\n--   \'QGroupingContext\').\nclass QGroupable expr grouped | expr -> grouped, grouped -> expr where\n  group_ :: expr -> grouped\n\n-- | \'group_\' for simple value expressions.\ninstance QGroupable (QExpr be s a) (QGroupExpr be s a) where\n  group_ (QExpr a) = QExpr a\n\n-- | \'group_\' for any \'Beamable\' type. Adds every field in the type to the\n--   grouping key. This is the equivalent of including the grouping expression\n--   of each field in the type as part of the aggregate projection\ninstance Beamable tbl =>\n  QGroupable (tbl (QExpr be s)) (tbl (QGroupExpr be s)) where\n  group_ = changeBeamRep (\\(Columnar\' (QExpr x)) -> Columnar\' (QExpr x))\n\n-- | \'group_\' for any \'Beamable\' type. Adds every field in the type to the\n--   grouping key. This is the equivalent of including the grouping expression\n--   of each field in the type as part of the aggregate projection\ninstance Beamable tbl =>\n  QGroupable (tbl (Nullable (QExpr be s))) (tbl (Nullable (QGroupExpr be s))) where\n  group_ = changeBeamRep (\\(Columnar\' (QExpr x)) -> Columnar\' (QExpr x))\n\n-- | Compute an aggregate over all values in a group. Corresponds semantically\n--   to the @AGG(ALL ..)@ syntax, but doesn\'t produce an explicit @ALL@. To\n--   produce @ALL@ expicitly, see \'allInGroupExplicitly_\'.\nallInGroup_ :: IsSql92AggregationSetQuantifierSyntax s\n            => Maybe s\nallInGroup_ = Nothing\n\n-- | Compute an aggregate only over distinct values in a group. Corresponds to\n--   the @AGG(DISTINCT ..)@ syntax.\ndistinctInGroup_ :: IsSql92AggregationSetQuantifierSyntax s\n                 => Maybe s\ndistinctInGroup_ = Just setQuantifierDistinct\n\n-- | Compute an aggregate over all values in a group. Corresponds to the\n--   @AGG(ALL ..)@ syntax. Note that @ALL@ is the default for most aggregations,\n--   so you don\'t normally explicitly specify @ALL@. However, if you need to,\n--   you can use this function. To be explicit about quantification in the beam\n--   query DSL, but not produce an explicit @ALL@, use \'allInGroup_\'.\n--   \'allInGroup_\' has the same semantic meaning, but does not produce an\n--   explicit @ALL@.\nallInGroupExplicitly_ :: IsSql92AggregationSetQuantifierSyntax s\n                      => Maybe s\nallInGroupExplicitly_ = Just setQuantifierAll\n\n-- ** Aggregations\n--\n--    These functions all return \'Maybe\' (except for `count_` and\n--    `countAll_`) because empty aggregates return SQL @NULL@ values.\n\n-- | SQL @MIN(ALL ..)@ function (but without the explicit ALL)\nmin_ :: BeamSqlBackend be\n     => QExpr be s a -> QAgg be s (Maybe a)\nmin_ = minOver_ allInGroup_\n\n-- | SQL @MAX(ALL ..)@ function (but without the explicit ALL)\nmax_ :: BeamSqlBackend be\n     => QExpr be s a -> QAgg be s (Maybe a)\nmax_ = maxOver_ allInGroup_\n\n-- | SQL @AVG(ALL ..)@ function (but without the explicit ALL)\navg_ :: ( BeamSqlBackend be, Num a )\n     => QExpr be s a -> QAgg be s (Maybe a)\navg_ = avgOver_ allInGroup_\n\n-- | SQL @SUM(ALL ..)@ function (but without the explicit ALL)\nsum_ :: ( BeamSqlBackend be, Num a )\n     => QExpr be s a -> QAgg be s (Maybe a)\nsum_ = sumOver_ allInGroup_\n\n-- | SQL @COUNT(*)@ function\ncountAll_ :: ( BeamSqlBackend be, Integral a ) => QAgg be s a\ncountAll_ = QExpr (pure countAllE)\n\n-- | SQL @COUNT(ALL ..)@ function (but without the explicit ALL)\ncount_ :: ( BeamSqlBackend be, Integral b )\n       => QExpr be s a -> QAgg be s b\ncount_ (QExpr over) = QExpr (countE Nothing <$> over)\n\n-- | SQL2003 @CUME_DIST@ function (Requires T612 Advanced OLAP operations support)\ncumeDist_ :: BeamSqlT612Backend be\n          => QAgg be s Double\ncumeDist_ = QExpr (pure cumeDistAggE)\n\n-- | SQL2003 @PERCENT_RANK@ function (Requires T612 Advanced OLAP operations support)\npercentRank_ :: BeamSqlT612Backend be\n             => QAgg be s Double\npercentRank_ = QExpr (pure percentRankAggE)\n\n-- | SQL2003 @DENSE_RANK@ function (Requires T612 Advanced OLAP operations support)\ndenseRank_ :: ( BeamSqlT612Backend be, Integral a )\n           => QAgg be s a\ndenseRank_ = QExpr (pure denseRankAggE)\n\n-- | SQL2003 @ROW_NUMBER@ function\nrowNumber_ :: ( BeamSql2003ExpressionBackend be, Integral a )\n           =>  QAgg be s a\nrowNumber_ = QExpr (pure rowNumberE)\n\n-- | SQL2003 @RANK@ function (Requires T611 Elementary OLAP operations support)\nrank_ :: ( BeamSqlT611Backend be, Integral a )\n      => QAgg be s a\nrank_ = QExpr (pure rankAggE)\n\nminOver_, maxOver_\n  :: BeamSqlBackend be\n  => Maybe (BeamSqlBackendAggregationQuantifierSyntax be)\n  -> QExpr be s a -> QAgg be s (Maybe a)\nminOver_ q (QExpr a) = QExpr (minE q <$> a)\nmaxOver_ q (QExpr a) = QExpr (maxE q <$> a)\n\navgOver_, sumOver_\n  :: ( BeamSqlBackend be, Num a )\n  => Maybe (BeamSqlBackendAggregationQuantifierSyntax be)\n  -> QExpr be s a -> QAgg be s (Maybe a)\navgOver_ q (QExpr a) = QExpr (avgE q <$> a)\nsumOver_ q (QExpr a) = QExpr (sumE q <$> a)\n\ncountOver_\n  :: ( BeamSqlBackend be, Integral b )\n  => Maybe (BeamSqlBackendAggregationQuantifierSyntax be)\n  -> QExpr be s a -> QAgg be s b\ncountOver_ q (QExpr a) = QExpr (countE q <$> a)\n\n-- | SQL @EVERY@, @SOME@, and @ANY@ aggregates. Operates over\n-- \'SqlBool\' only, as the result can be @NULL@, even if all inputs are\n-- known (no input rows).\neveryOver_, someOver_, anyOver_\n  :: BeamSql99AggregationBackend be\n  => Maybe (BeamSqlBackendAggregationQuantifierSyntax be)\n  -> QExpr be s SqlBool -> QAgg be s SqlBool\neveryOver_ q (QExpr a) = QExpr (everyE q <$> a)\nsomeOver_  q (QExpr a) = QExpr (someE  q <$> a)\nanyOver_   q (QExpr a) = QExpr (anyE   q <$> a)\n\n-- | Support for FILTER (WHERE ...) syntax for aggregates.\n--   Part of SQL2003 Elementary OLAP operations feature (T611).\n--\n-- See \'filterWhere_\'\' for a version that accepts \'SqlBool\'.\nfilterWhere_ :: BeamSqlT611Backend be\n             => QAgg be s a -> QExpr be s Bool -> QAgg be s a\nfilterWhere_ agg cond = filterWhere_\' agg (sqlBool_ cond)\n\n-- | Like \'filterWhere_\' but accepting \'SqlBool\'.\nfilterWhere_\' :: BeamSqlT611Backend be\n              => QAgg be s a -> QExpr be s SqlBool -> QAgg be s a\nfilterWhere_\' (QExpr agg) (QExpr cond) = QExpr (liftA2 filterAggE agg cond)\n\n-- | SQL99 @EVERY(ALL ..)@ function (but without the explicit ALL)\nevery_ :: BeamSql99AggregationBackend be\n       => QExpr be s SqlBool -> QAgg be s SqlBool\nevery_ = everyOver_ allInGroup_\n\n-- | SQL99 @SOME(ALL ..)@ function (but without the explicit ALL)\nsome_ :: BeamSql99AggregationBackend be\n      => QExpr be s SqlBool -> QAgg be s SqlBool\nsome_  = someOver_  allInGroup_\n\n-- | SQL99 @ANY(ALL ..)@ function (but without the explicit ALL)\nany_ :: BeamSql99AggregationBackend be\n     => QExpr be s SqlBool -> QAgg be s SqlBool\nany_   = anyOver_   allInGroup_\n'