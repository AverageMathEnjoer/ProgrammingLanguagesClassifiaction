b'{-# LANGUAGE TypeOperators #-}\n\nmodule App where\n\nimport           Control.Concurrent\nimport           Control.Monad.IO.Class\nimport           Data.Map\nimport           Network.Wai\nimport           Network.Wai.MakeAssets\nimport           Servant\n\nimport           Api\n\ntype WithAssets = Api :<|> Raw\n\nwithAssets :: Proxy WithAssets\nwithAssets = Proxy\n\noptions :: Options\noptions = Options "client"\n\napp :: IO Application\napp = serve withAssets <$> server\n\nserver :: IO (Server WithAssets)\nserver = do\n  assets <- serveAssets options\n  db     <- mkDB\n  return (apiServer db :<|> Tagged assets)\n\napiServer :: DB -> Server Api\napiServer db = listItems db :<|> getItem db :<|> postItem db :<|> deleteItem db\n\nlistItems :: DB -> Handler [ItemId]\nlistItems db = liftIO $ allItemIds db\n\ngetItem :: DB -> ItemId -> Handler Item\ngetItem db n = maybe (throwError err404) return =<< liftIO (lookupItem db n)\n\npostItem :: DB -> String -> Handler ItemId\npostItem db new = liftIO $ insertItem db new\n\n-- fake DB\n\nnewtype DB = DB (MVar (Map ItemId String))\n\ndebug :: DB -> IO ()\ndebug (DB mvar) = readMVar mvar >>= print\n\nmkDB :: IO DB\nmkDB = DB <$> newMVar empty\n\ninsertItem :: DB -> String -> IO ItemId\ninsertItem (DB mvar) new = modifyMVar mvar $ \\m -> do\n  let newKey = case keys m of\n        [] -> ItemId 0\n        ks -> succ (maximum ks)\n  return (insert newKey new m, newKey)\n\nlookupItem :: DB -> ItemId -> IO (Maybe Item)\nlookupItem (DB mvar) i = fmap (Item i) . Data.Map.lookup i <$> readMVar mvar\n\nallItemIds :: DB -> IO [ItemId]\nallItemIds (DB mvar) = keys <$> readMVar mvar\n\ndeleteItem :: MonadIO m => DB -> ItemId -> m ()\ndeleteItem (DB mvar) i = liftIO $ do\n  modifyMVar_ mvar $ \\m -> return (delete i m)\n  return ()\n\n'