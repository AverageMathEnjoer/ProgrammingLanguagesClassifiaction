b'{-# LANGUAGE GADTs #-}\n{-# LANGUAGE LambdaCase #-}\n{-# LANGUAGE OverloadedStrings #-}\n{-# LANGUAGE RankNTypes #-}\n{-# LANGUAGE RecordWildCards #-}\n{-# LANGUAGE TupleSections #-}\n\nmodule Hoodle.Coroutine.Link where\n\nimport Control.Applicative\nimport Control.Lens (at, set, view, (^.), _2)\nimport Control.Monad hiding (forM_)\nimport Control.Monad.State (get, gets, liftIO)\nimport Control.Monad.Trans.Maybe\nimport qualified Data.ByteString.Char8 as B\nimport Data.Foldable (forM_)\nimport Data.Hoodle.BBox\nimport Data.Hoodle.Generic\nimport Data.Hoodle.Simple\nimport Data.Hoodle.Zipper\nimport qualified Data.IntMap as IM\nimport qualified Data.Map as M\nimport Data.Maybe (mapMaybe)\nimport qualified Data.Text as T\nimport qualified Data.Text.Encoding as TE\nimport Data.UUID.V4 (nextRandom)\nimport Graphics.Hoodle.Render.Item\nimport Graphics.Hoodle.Render.Type\nimport Graphics.Hoodle.Render.Type.HitTest\nimport Graphics.Hoodle.Render.Util.HitTest\nimport qualified Graphics.UI.Gtk as Gtk\nimport Hoodle.Accessor\nimport Hoodle.Coroutine.Dialog\nimport Hoodle.Coroutine.Draw\nimport Hoodle.Coroutine.Page (changePage)\nimport Hoodle.Coroutine.Select.Clipboard\nimport Hoodle.Coroutine.TextInput\nimport Hoodle.Coroutine.Window\nimport Hoodle.Device\nimport Hoodle.ModelAction.ContextMenu\nimport Hoodle.ModelAction.File (makeNewItemImage)\nimport Hoodle.ModelAction.Select\nimport Hoodle.Type.Canvas\nimport Hoodle.Type.Coroutine\nimport Hoodle.Type.Enum\nimport Hoodle.Type.Event\nimport Hoodle.Type.HoodleState\nimport Hoodle.Type.PageArrangement\nimport Hoodle.Util\nimport Hoodle.View.Coordinate\nimport System.Directory\nimport System.FilePath\nimport System.Process (createProcess, proc)\n--\nimport Prelude hiding (mapM_)\n\n-- |\nopenLinkAction ::\n  UrlPath ->\n  -- | (docid,anchorid)\n  Maybe (T.Text, T.Text) ->\n  MainCoroutine ()\nopenLinkAction urlpath mid = do\n  case urlpath of\n    FileUrl fp -> do\n      mk <- liftIO . checkPreviouslyOpenedFile fp =<< get\n      case mk of\n        Just k -> switchTab k >> forM_ mid (uncurry goToAnchorPos)\n        Nothing ->\n          addTab (LocalDir (Just fp))\n            >> forM_ mid (uncurry goToAnchorPos)\n    HttpUrl url -> liftIO $ void $ createProcess (proc "xdg-open" [url])\n\n-- |\ncheckPreviouslyOpenedFile :: FilePath -> HoodleState -> IO (Maybe Int)\ncheckPreviouslyOpenedFile fp xst = do\n  cfp <- canonicalizePath fp\n  lst <- filterM (checker cfp . snd) (IM.assocs (xst ^. unitHoodles . _2))\n  case lst of\n    x : _ -> return (Just (fst x))\n    _ -> return Nothing\n  where\n    checker cfp uhdl = getHoodleFilePath uhdl\n      # maybe (return False)\n      $ \\fp\' -> do\n        cfp\' <- canonicalizePath fp\'\n        return (cfp == cfp\')\n\nmakeTextSVGFromStringAt ::\n  String ->\n  CanvasId ->\n  UnitHoodle ->\n  CanvasCoordinate ->\n  IO (B.ByteString, BBox)\nmakeTextSVGFromStringAt str cid uhdl ccoord = do\n  rdr <- makePangoTextSVG (0, 0) (T.pack str) -- for the time being, I use string\n  geometry <- getCanvasGeometryCvsId cid uhdl\n  let mpgcoord = (desktop2Page geometry . canvas2Desktop geometry) ccoord\n  return $ case mpgcoord of\n    Nothing -> rdr\n    Just (_, PageCoord (x\', y\')) ->\n      let bbox\' = moveBBoxULCornerTo (x\', y\') (snd rdr)\n       in (fst rdr, bbox\')\n\n-- |\nnotifyLink :: CanvasId -> PointerCoord -> MainCoroutine ()\nnotifyLink cid pcoord = do\n  uhdl <- gets (view (unitHoodles . currentUnit))\n  forBoth\' unboxBiAct (f uhdl) (getCanvasInfo cid uhdl)\n  where\n    f :: forall b. UnitHoodle -> CanvasInfo b -> MainCoroutine ()\n    f uhdl cvsInfo = do\n      let cpn = PageNum . view currentPageNum $ cvsInfo\n          arr = view (viewInfo . pageArrangement) cvsInfo\n          mnotifyitem = view notifiedItem cvsInfo\n          canvas = view drawArea cvsInfo\n      geometry <- liftIO $ makeCanvasGeometry cpn arr canvas\n      mresult <-\n        case (desktop2Page geometry . device2Desktop geometry) pcoord of\n          Nothing -> return Nothing\n          Just (pnum, PageCoord (x, y)) -> do\n            let hdl = getHoodle uhdl\n                mpage = view (gpages . at (unPageNum pnum)) hdl\n            case mpage of\n              Nothing -> return Nothing\n              Just page -> do\n                let itms = (view gitems . current . view glayers) page\n                    lnks = filter isLinkInRItem itms\n                    hlnks = hltFilteredBy (\\itm -> isPointInBBox (getBBox itm) (x, y)) lnks\n                    hitted = takeHitted hlnks\n                case mnotifyitem of\n                  Nothing ->\n                    if (not . null) hitted\n                      then Just <$> newNotify geometry pnum (head hitted) Nothing\n                      else return Nothing\n                  Just (opnum, obbx, _) -> do\n                    let obbx_desk = xformBBox (unDeskCoord . page2Desktop geometry . (opnum,) . PageCoord) obbx\n                    if pnum == opnum && isPointInBBox obbx (x, y)\n                      then return Nothing\n                      else\n                        if (not . null) hitted\n                          then Just <$> newNotify geometry pnum (head hitted) (Just obbx_desk)\n                          else return (Just (Nothing, obbx_desk))\n      forM_\n        mresult\n        ( \\(mnewnotified, bbx_desk) -> do\n            let ncinfobox = (set (unboxLens notifiedItem) mnewnotified . getCanvasInfo cid) uhdl\n            pureUpdateUhdl $ setCanvasInfo (cid, ncinfobox)\n            invalidateInBBox (Just bbx_desk) Efficient cid\n        )\n    ----\n    newNotify ::\n      CanvasGeometry ->\n      PageNum ->\n      RItem ->\n      Maybe BBox ->\n      MainCoroutine (Maybe (PageNum, BBox, RItem), BBox)\n    newNotify geometry pnum lnk mobbx_desk = do\n      let bbx = getBBox lnk\n          bbx_desk = xformBBox (unDeskCoord . page2Desktop geometry . (pnum,) . PageCoord) bbx\n          nbbx_desk = maybe bbx_desk (unionBBox bbx_desk) mobbx_desk\n      return (Just (pnum, bbx, lnk), nbbx_desk)\n\n-- | got a link address (or embedded image) from drag and drop\ngotLink :: Maybe String -> (Int, Int) -> MainCoroutine ()\ngotLink mstr (x, y) = do\n  xst <- get\n  cache <- renderCache\n  let uhdl = view (unitHoodles . currentUnit) xst\n      cid = getCurrentCanvasId uhdl\n  mr <- runMaybeT $ do\n    str <- (MaybeT . return) mstr\n    let (str1, rem1) = break (== \',\') str\n    guard ((not . null) rem1)\n    return (B.pack str1, tail rem1)\n  case mr of\n    Nothing -> do\n      mr2 <- runMaybeT $ do\n        str <- (MaybeT . return) mstr\n        (MaybeT . return) (urlParse str)\n      case mr2 of\n        Nothing -> return ()\n        Just (FileUrl file) -> do\n          let ext = takeExtension file\n          when (ext == ".png" || ext == ".PNG" || ext == ".jpg" || ext == ".JPG") $ do\n            let isembedded = view (settings . doesEmbedImage) xst\n            callRenderer $\n              GotRItem\n                <$> (cnstrctRItem =<< liftIO (makeNewItemImage isembedded file))\n            RenderEv (GotRItem nitm) <-\n              waitSomeEvent (\\case RenderEv (GotRItem _) -> True; _ -> False)\n            geometry <- liftIO $ getCanvasGeometryCvsId cid uhdl\n            let ccoord = CvsCoord (fromIntegral x, fromIntegral y)\n                mpgcoord = (desktop2Page geometry . canvas2Desktop geometry) ccoord\n            insertItemAt mpgcoord nitm\n        Just (HttpUrl url) -> do\n          case getSelectedItmsFromUnitHoodle uhdl of\n            Nothing -> do\n              uuidbstr <- liftIO $ B.pack . show <$> nextRandom\n              rdrbbx <- liftIO $ makeTextSVGFromStringAt url cid uhdl (CvsCoord (fromIntegral x, fromIntegral y))\n              linkInsert "simple" (uuidbstr, url) url rdrbbx\n            Just hititms -> do\n              b <- okCancelMessageBox ("replace selected item with link to " ++ url ++ "?")\n              when b $ do\n                let ulbbox = (unUnion . mconcat . fmap (Union . Middle . getBBox)) hititms\n                case ulbbox of\n                  Middle bbox -> do\n                    svg <- liftIO $ makeSVGFromSelection cache cid hititms bbox\n                    uuidbstr <- liftIO $ B.pack . show <$> nextRandom\n                    deleteSelection\n                    linkInsert "simple" (uuidbstr, url) url (svg_render svg, bbox)\n                  _ -> return ()\n    Just (uuidbstr, fp) -> do\n      let fn = takeFileName fp\n      case getSelectedItmsFromUnitHoodle uhdl of\n        Nothing -> do\n          rdr <- liftIO (makePangoTextSVG (0, 0) (T.pack fn))\n          geometry <- liftIO $ getCanvasGeometryCvsId cid uhdl\n          let ccoord = CvsCoord (fromIntegral x, fromIntegral y)\n              mpgcoord = (desktop2Page geometry . canvas2Desktop geometry) ccoord\n              rdr\' = case mpgcoord of\n                Nothing -> rdr\n                Just (_, PageCoord (x\', y\')) ->\n                  let bbox\' = moveBBoxULCornerTo (x\', y\') (snd rdr) in (fst rdr, bbox\')\n          linkInsert "simple" (uuidbstr, fp) fn rdr\'\n        Just hititms -> do\n          b <- okCancelMessageBox ("replace selected item with link to " ++ fn ++ "?")\n          when b $ do\n            let ulbbox = (unUnion . mconcat . fmap (Union . Middle . getBBox)) hititms\n            case ulbbox of\n              Middle bbox -> do\n                svg <- liftIO $ makeSVGFromSelection cache cid hititms bbox\n                uuid <- liftIO nextRandom\n                let uuidbstr\' = B.pack (show uuid)\n                deleteSelection\n                linkInsert "simple" (uuidbstr\', fp) fn (svg_render svg, bbox)\n              _ -> return ()\n\n-- |\naddLink :: MainCoroutine ()\naddLink = do\n  mfilename <- fileChooser Gtk.FileChooserActionOpen Nothing\n  doIOaction $ const (action mfilename)\n  AddLink minput <- waitSomeEvent (\\case AddLink _ -> True; _ -> False)\n  case minput of\n    Nothing -> return ()\n    Just (str, fname) -> do\n      uuid <- liftIO nextRandom\n      let uuidbstr = B.pack (show uuid)\n      rdr <- liftIO (makePangoTextSVG (0, 0) (T.pack str))\n      linkInsert "simple" (uuidbstr, fname) str rdr\n  where\n    action mfn = do\n      dialog <-\n        Gtk.messageDialogNew\n          Nothing\n          [Gtk.DialogModal]\n          Gtk.MessageQuestion\n          Gtk.ButtonsOkCancel\n          ("add link" :: String)\n      upper <- fmap Gtk.castToContainer (Gtk.dialogGetContentArea dialog)\n      vbox <- Gtk.vBoxNew False 0\n      Gtk.containerAdd upper vbox\n      txtvw <- Gtk.textViewNew\n      Gtk.boxPackStart vbox txtvw Gtk.PackGrow 0\n      Gtk.widgetShowAll dialog\n      res <- Gtk.dialogRun dialog\n      case res of\n        Gtk.ResponseOk -> do\n          buf <- Gtk.textViewGetBuffer txtvw\n          (istart, iend) <-\n            (,) <$> Gtk.textBufferGetStartIter buf\n              <*> Gtk.textBufferGetEndIter buf\n          l <- Gtk.textBufferGetText buf istart iend True\n          Gtk.widgetDestroy dialog\n          return (UsrEv (AddLink ((l,) <$> mfn)))\n        _ -> Gtk.widgetDestroy dialog >> return (UsrEv (AddLink Nothing))\n\n-- |\nlistAnchors :: MainCoroutine ()\nlistAnchors = msgShout . show . getAnchorMap . rHoodle2Hoodle . getHoodle . view (unitHoodles . currentUnit) =<< get\n\ngetAnchorMap :: Hoodle -> M.Map T.Text (Int, (Double, Double))\ngetAnchorMap hdl =\n  let pgs = view pages hdl\n      itemsInPage pg = [i | l <- view layers pg, i <- view items l]\n      anchorsWithPageNum :: [(Int, [Anchor])]\n      anchorsWithPageNum = zip [0 ..] (map (mapMaybe lookupAnchor . itemsInPage) pgs)\n   in foldr (\\(p, ys) m -> foldr (insertAnchor p) m ys) M.empty anchorsWithPageNum\n  where\n    lookupAnchor (ItemAnchor a) = Just a\n    lookupAnchor _ = Nothing\n    insertAnchor pgnum Anchor {..} = M.insert (TE.decodeUtf8 anchor_id) (pgnum, anchor_pos)\n\n-- |\ngoToAnchorPos :: T.Text -> T.Text -> MainCoroutine ()\ngoToAnchorPos docid anchorid = do\n  rhdl <- gets (getHoodle . view (unitHoodles . currentUnit))\n  let hdl = rHoodle2Hoodle rhdl\n  when (docid == (TE.decodeUtf8 . view ghoodleID) rhdl) $ do\n    let anchormap = getAnchorMap hdl\n    forM_ (M.lookup anchorid anchormap) $ \\(pgnum, _) -> changePage (const pgnum)\n'