b'{-# LANGUAGE OverloadedStrings #-}\n\nmodule Hoodle.Web.Util\n  ( arrayBufferToByteString,\n    bytestringToArrayBuffer,\n    pathBBox,\n    intersectingStrokes,\n    enclosedStrokes,\n    putStrLnAndFlush,\n    sendBinary,\n    stringifyStrokeId,\n    transformPathFromCanvasToSVG,\n  )\nwhere\n\nimport Data.Binary (Binary, encode)\nimport Data.ByteString (ByteString)\nimport qualified Data.ByteString.Lazy as BL\nimport Data.Foldable (toList)\nimport Data.Sequence (Seq)\nimport Data.String (IsString (..))\nimport qualified GHCJS.Buffer as Buffer\nimport GHCJS.Marshal (FromJSVal (..), ToJSVal (..))\nimport GHCJS.Types (JSVal)\nimport Hoodle.HitTest (do2BBoxIntersect, doesLineHitStrk, hitLassoPoint)\nimport Hoodle.HitTest.Type (BBox (..), BBoxed (..), GetBBoxable (getBBox))\nimport qualified Hoodle.Web.ForeignJS as J\nimport Hoodle.Web.Type.State (RStroke, rstrokeCommitId, rstrokePath)\nimport JavaScript.TypedArray.ArrayBuffer (ArrayBuffer)\nimport qualified JavaScript.Web.WebSocket as WS\nimport Lens.Micro ((^.))\nimport Message (CommitId (..))\nimport System.IO (hFlush, hPutStrLn, stdout)\n\nforeign import javascript unsafe "$3.slice($1, $1 + $2)"\n  js_bufferSlice :: Int -> Int -> ArrayBuffer -> ArrayBuffer\n\nbytestringToArrayBuffer :: ByteString -> ArrayBuffer\nbytestringToArrayBuffer bs = js_bufferSlice offset len $ Buffer.getArrayBuffer buffer\n  where\n    (buffer, offset, len) = Buffer.fromByteString bs\n\narrayBufferToByteString :: ArrayBuffer -> ByteString\narrayBufferToByteString =\n  Buffer.toByteString 0 Nothing . Buffer.createFromArrayBuffer\n\nsendBinary :: (Binary a) => WS.WebSocket -> a -> IO ()\nsendBinary sock msg =\n  let bs = BL.toStrict $ encode msg\n      arrbuf = bytestringToArrayBuffer bs\n   in WS.sendArrayBuffer arrbuf sock\n\nputStrLnAndFlush :: String -> IO ()\nputStrLnAndFlush s = do\n  hPutStrLn stdout s\n  hFlush stdout\n\ntransformPathFromCanvasToSVG :: JSVal -> [(Double, Double)] -> IO [(Double, Double)]\ntransformPathFromCanvasToSVG svg cxys = do\n  path_arr <-\n    J.js_to_svg_point_array svg =<< toJSValListOf (toList cxys)\n  fromJSValUncheckedListOf path_arr\n\n-- | find bbox surrounding a path\npathBBox :: [(Double, Double)] -> BBox\npathBBox path =\n  let xs = map fst path\n      ys = map snd path\n   in BBox\n        { bbox_upperleft = (minimum xs, minimum ys),\n          bbox_lowerright = (maximum xs, maximum ys)\n        }\n\nintersectingStrokes ::\n  [(Double, Double)] ->\n  [BBoxed RStroke] ->\n  [CommitId]\nintersectingStrokes xys strks =\n  let bbox1 = pathBBox xys\n      pairs = zip xys (tail xys)\n      hitstrks = flip concatMap pairs $ \\((x0, y0), (x, y)) ->\n        map (^. rstrokeCommitId) $\n          filter (doesLineHitStrk ((x0, y0), (x, y)) . (^. rstrokePath)) $\n            map bbxed_content $\n              filter (do2BBoxIntersect bbox1 . getBBox) $\n                strks\n   in hitstrks\n\npathEnclosedByLasso :: [(Double, Double)] -> Seq (Double, Double) -> Bool\npathEnclosedByLasso path lasso =\n  all (hitLassoPoint lasso) path\n\nenclosedStrokes ::\n  Seq (Double, Double) ->\n  [BBoxed RStroke] ->\n  [CommitId]\nenclosedStrokes lasso strks =\n  let bbox1 = pathBBox (toList lasso)\n   in map (^. rstrokeCommitId) $\n        filter ((`pathEnclosedByLasso` lasso) . (^. rstrokePath)) $\n          map bbxed_content $\n            filter (do2BBoxIntersect bbox1 . getBBox) $\n              strks\n\nstringifyStrokeId :: (IsString s, Semigroup s) => CommitId -> s\nstringifyStrokeId (CommitId i) = "stroke" <> fromString (show i)\n'