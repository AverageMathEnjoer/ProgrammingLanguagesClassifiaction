b'#include "stdafx.h"\n#include "AssetsFileReader.h"\n#include "../libStringConverter/convert.h"\n#include <vector>\n#include <tchar.h>\n#include <mutex>\n\nvoid AssetsVerifyLoggerToConsole(const char *message)\n{\n\tprintf("%s\\n", message);\n}\n\nstd::vector<IAssetsReopenable*> reopenableInstances;\nstd::mutex reopenableInstancesMutex;\nvoid AddReopenable(IAssetsReopenable *pReopenable)\n{\n\tstd::scoped_lock<std::mutex> reopenableInstancesLock(reopenableInstancesMutex);\n\treopenableInstances.push_back(pReopenable);\n}\nvoid RemoveReopenable(IAssetsReopenable *pReopenable)\n{\n\tstd::scoped_lock<std::mutex> reopenableInstancesLock(reopenableInstancesMutex);\n\tfor (size_t i = 1; i <= reopenableInstances.size(); i++)\n\t{\n\t\tif (reopenableInstances[i-1] == pReopenable)\n\t\t{\n\t\t\treopenableInstances.erase(reopenableInstances.begin() + (i-1));\n\t\t\ti--;\n\t\t}\n\t}\n}\nbool GarbageCollectReopenables(int nMax = 16)\n{\n\tbool collected = false;\n\tstd::scoped_lock<std::mutex> reopenableInstancesLock(reopenableInstancesMutex);\n\tfor (size_t i = 0; i < reopenableInstances.size(); i++)\n\t{\n\t\tif (!nMax)\n\t\t\tbreak;\n\t\tif (reopenableInstances[i]->IsOpen() && reopenableInstances[i]->Close())\n\t\t{\n\t\t\tcollected = true;\n\t\t\tnMax--;\n\t\t}\n\t}\n\treturn collected;\n}\n\nvoid Free_AssetsReopenable(IAssetsReopenable *pObject)\n{\n\tdelete pObject;\n}\n\nIAssetsReopenable::~IAssetsReopenable() {}\n\nclass AssetsReaderFromFile : public IAssetsReader\n{\n\tAssetsRWOpenFlags flags;\nprotected:\n\tbool binary;\n\tTCHAR *filePath;\n\n\tbool wasOpened;\n\tQWORD lastFilePos;\n\n\tFILE *pFile;\n\tstd::recursive_mutex fileOperationMutex;\npublic:\n\tAssetsReaderFromFile(const TCHAR *filePath, bool binary, AssetsRWOpenFlags flags)\n\t{\n\t\tthis->flags = flags;\n\t\tthis->binary = binary;\n\n\t\tsize_t pathLen = wcslen(filePath) + 1;\n\t\tthis->filePath = new TCHAR[pathLen];\n\t\tmemcpy(this->filePath, filePath, pathLen * sizeof(TCHAR));\n\n\t\tthis->wasOpened = false;\n\t\tthis->pFile = NULL;\n\t\tthis->lastFilePos = 0;\n\t}\n\tAssetsReaderFromFile(FILE *pFile)\n\t{\n\t\tthis->pFile = pFile;\n\n\t\tthis->flags = RWOpenFlags_Immediately | RWOpenFlags_Unclosable;\n\t\tthis->binary = true;\n\n\t\tthis->filePath = NULL;\n\t\t\n\t\tthis->wasOpened = true;\n\t\tthis->lastFilePos = 0;\n\t}\n\t~AssetsReaderFromFile()\n\t{\n\t\tRemoveReopenable(this);\n\t\tif (filePath)\n\t\t{\n\t\t\tfree(filePath);\n\t\t\tfilePath = NULL;\n\t\t\tflags = RWOpenFlags_None; //RWOpenFlags_Unclosable could otherwise prevent closing the file.\n\t\t\tClose();\n\t\t}\n\t}\n\tbool Reopen()\n\t{\n\t\tbool ret = true;\n\t\tstd::scoped_lock<std::recursive_mutex> fileOperationLock(fileOperationMutex);\n\t\tif (IsOpen())\n\t\t\tret = true;\n\t\telse if (filePath == NULL)\n\t\t\tret = false;\n\t\telse\n\t\t{\n\t\t\tFILE *pTempFile = NULL;\n\t\t\tTCHAR mode[3] = {_T(\'r\'), binary ? _T(\'b\') : 0, 0};\n\t\t\terrno_t err = _tfopen_s(&pTempFile, filePath, mode);\n\t\t\tif (err != 0)\n\t\t\t{\n\t\t\t\tif (err == ENFILE || err == EMFILE)\n\t\t\t\t{\n\t\t\t\t\tGarbageCollectReopenables();\n\t\t\t\t\terr = _tfopen_s(&pTempFile, filePath, mode);\n\t\t\t\t\tif (err != 0)\n\t\t\t\t\t\tret = false;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tret = false;\n\t\t\t}\n\t\t\tif (ret)\n\t\t\t{\n\t\t\t\tpFile = pTempFile;\n\t\t\t\tif (wasOpened && !SetPosition(lastFilePos))\n\t\t\t\t{\n\t\t\t\t\tfclose(pTempFile);\n\t\t\t\t\tret = false;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\twasOpened = true;\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n\tbool IsOpen()\n\t{\n\t\treturn pFile != NULL;\n\t}\n\tbool Close()\n\t{\n\t\tbool ret;\n\t\tstd::unique_lock<std::recursive_mutex> fileOperationLock(fileOperationMutex, std::defer_lock);\n\t\tif (filePath != NULL)\n\t\t\tfileOperationLock.lock();\n\t\tif (IsOpen())\n\t\t{\n\t\t\tif (flags & RWOpenFlags_Unclosable)\n\t\t\t\tret = false;\n\t\t\telse if (!Tell(lastFilePos))\n\t\t\t\tret = false;\n\t\t\telse\n\t\t\t{\n\t\t\t\tfclose(pFile);\n\t\t\t\tpFile = NULL;\n\t\t\t\tret = true;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\tret = true;\n\t\treturn ret;\n\t}\n\n\tAssetsRWTypes GetType() { return AssetsRWType_Reader; }\n\tAssetsRWClasses GetClass() { return AssetsRWClass_ReaderFromFile; }\n\tbool IsView() { return false; }\n\n\tbool Tell(QWORD &pos)\n\t{\n\t\tstd::scoped_lock<std::recursive_mutex> fileOperationLock(fileOperationMutex);\n\t\tbool ret;\n\t\tif (IsOpen())\n\t\t{\n\t\t\tlong long posv = _ftelli64(pFile);\n\t\t\tif (posv < 0)\n\t\t\t{\n\t\t\t\tpos = 0;\n\t\t\t\tret = false;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tpos = (QWORD)posv;\n\t\t\t\tret = true;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpos = lastFilePos;\n\t\t\tret = true;\n\t\t}\n\t\treturn ret;\n\t}\n\tbool Seek(AssetsSeekTypes origin, long long offset)\n\t{\n\t\tstd::scoped_lock<std::recursive_mutex> fileOperationLock(fileOperationMutex);\n\t\tbool ret;\n\t\tif (!IsOpen() && !Reopen())\n\t\t\tret = false;\n\t\telse\n\t\t\tret = _fseeki64(pFile, offset, (int)origin) == 0;\n\t\treturn ret;\n\t}\n\tbool SetPosition(QWORD pos)\n\t{\n\t\tstd::scoped_lock<std::recursive_mutex> fileOperationLock(fileOperationMutex);\n\t\tbool ret;\n\t\tif (((long long)pos) < 0) //fpos_t is signed\n\t\t\tret = false;\n\t\telse if (!IsOpen() && !Reopen())\n\t\t\tret = false;\n\t\telse\n\t\t\tret = _fseeki64(pFile, (long long)pos, SEEK_SET) == 0;\n\t\treturn ret;\n\t}\n\n\tQWORD Read(QWORD pos, QWORD size, void *outBuffer, bool nullUnread)\n\t{\n\t\tstd::unique_lock<std::recursive_mutex> fileOperationLock(fileOperationMutex);\n\t\tQWORD ret;\n\t\tif (!IsOpen() && !Reopen())\n\t\t\tret = 0;\n\t\telse if ((pos != (QWORD)-1) && !SetPosition(pos))\n\t\t\tret = 0;\n\t\telse\n\t\t\tret = fread(outBuffer, 1, size, pFile);\n\t\tfileOperationLock.unlock();\n\t\tif (nullUnread && (ret < size))\n\t\t\tmemset(&((uint8_t*)outBuffer)[ret], 0, size - ret);\n\t\treturn ret;\n\t}\n\t\n\tIAssetsReader *CreateView();\n\tfriend class AssetsReaderFromFile_View;\n};\nclass AssetsReaderFromFile_View : public IAssetsReader\n{\n\tAssetsReaderFromFile *pBaseReader;\n\tQWORD filePos;\npublic:\n\tAssetsReaderFromFile_View(AssetsReaderFromFile *pBaseReader)\n\t\t: pBaseReader(pBaseReader), filePos(0)\n\t{}\n\t\n\t~AssetsReaderFromFile_View(){}\n\n\tbool Reopen() { return pBaseReader->Reopen(); }\n\tbool IsOpen() { return pBaseReader->IsOpen();}\n\tbool Close() { return false; }\n\n\tAssetsRWTypes GetType() { return AssetsRWType_Reader; }\n\tAssetsRWClasses GetClass() { return AssetsRWClass_ReaderFromFile; }\n\tbool IsView() { return true; }\n\n\tbool Tell(QWORD &pos) { pos = filePos; return true; }\n\tbool Seek(AssetsSeekTypes origin, long long offset)\n\t{\n\t\tbool ret = false;\n\t\tQWORD newPos = filePos;\n\t\tswitch (origin)\n\t\t{\n\t\tcase AssetsSeek_Begin:\n\t\t\tif (offset < 0) return false;\n\t\t\tnewPos = offset;\n\t\t\t//Seek the base reader to determine whether the operation is valid.\n\t\t\tret = pBaseReader->Seek(AssetsSeek_Begin, offset);\n\t\t\tbreak;\n\t\tcase AssetsSeek_Cur:\n\t\t\tif (offset < 0)\n\t\t\t{\n\t\t\t\toffset = -offset;\n\t\t\t\tif (offset < 0) return false; //INT64_MIN\n\t\t\t\tif ((unsigned long long)offset > newPos) return false;\n\t\t\t\tnewPos -= (unsigned long long)offset;\n\t\t\t}\n\t\t\telse\n\t\t\t\tnewPos += offset;\n\t\t\t//Seek the base reader to determine whether the operation is valid.\n\t\t\tret = pBaseReader->Seek(AssetsSeek_Begin, newPos);\n\t\t\tbreak;\n\t\tcase AssetsSeek_End:\n\t\t\tif (offset > 0) return false;\n\t\t\tstd::scoped_lock<std::recursive_mutex> fileOperationLock(pBaseReader->fileOperationMutex);\n\t\t\tret = pBaseReader->Seek(AssetsSeek_End, offset)\n\t\t\t\t&& pBaseReader->Tell(newPos);\n\t\t\tbreak;\n\t\t}\n\t\tif (ret)\n\t\t\tfilePos = newPos;\n\t\treturn ret;\n\t}\n\tbool SetPosition(QWORD pos)\n\t{\n\t\t//Seek the base reader to determine whether the operation is valid.\n\t\tif (pBaseReader->SetPosition(pos))\n\t\t{\n\t\t\tfilePos = pos;\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\t\n\tQWORD Read(QWORD pos, QWORD size, void *outBuffer, bool nullUnread)\n\t{\n\t\tif (pos == (QWORD)-1)\n\t\t\tpos = filePos;\n\t\telse\n\t\t\tfilePos = pos;\n\t\tQWORD result = pBaseReader->Read(pos, size, outBuffer, nullUnread);\n\t\tfilePos += result;\n\t\treturn result;\n\t}\n\t\n\tIAssetsReader *CreateView() { return pBaseReader->CreateView(); }\n};\nIAssetsReader *AssetsReaderFromFile::CreateView()\n{\n\treturn new AssetsReaderFromFile_View(this);\n}\n\nIAssetsReader *Create_AssetsReaderFromFile(const wchar_t *filePath, bool binary, AssetsRWOpenFlags openFlags)\n{\n\tif (filePath == NULL) return NULL;\n\n\tAssetsReaderFromFile *pReader = new AssetsReaderFromFile(filePath, binary, openFlags);\n\n\tif (openFlags & RWOpenFlags_Immediately)\n\t{\n\t\tif (!pReader->Reopen())\n\t\t{\n\t\t\tdelete pReader;\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\tAddReopenable(pReader);\n\treturn pReader;\n}\nIAssetsReader *Create_AssetsReaderFromFile(const char *filePath, bool binary, AssetsRWOpenFlags openFlags)\n{\n\tif (filePath == NULL) return NULL;\n\n\tsize_t tcLen = 0;\n\tTCHAR *tcPath = _MultiByteToWide(filePath, tcLen);\n\n\tIAssetsReader *pReader = Create_AssetsReaderFromFile(tcPath, binary, openFlags);\n\n\t_FreeWCHAR(tcPath);\n\n\treturn pReader;\n}\nIAssetsReader *Create_AssetsReaderFromFile(FILE *pFile)\n{\n\tif (pFile == NULL) return NULL;\n\n\tIAssetsReader *pReader = new AssetsReaderFromFile(pFile);\n\n\treturn pReader;\n}\n\n\nclass AssetsReaderFromSplitFile : public AssetsReaderFromFile\n{\n\tAssetsRWOpenFlags flags;\nprotected:\n\tstruct FileSizeEntry\n\t{\n\t\tQWORD absolutePos;\n\t\tQWORD size;\n\t\tFILE *pFile;\n\t};\n\tstd::vector<FileSizeEntry> splitSizes;\n\tQWORD totalFileSize;\n\n\t//Used for fast seek while the file is opened.\n\tsize_t curSplitIndex; QWORD curSplitPos;\n\t//Used to find the absolute file position when reopening.\n\tQWORD absoluteSplitFilePos;\n\n\tbool allowUpdate;\n\n\tbool findSplitFile(QWORD absolutePos, size_t &splitFileIndex, QWORD &splitFileOffset)\n\t{\n\t\tif (curSplitIndex < splitSizes.size()\n\t\t\t&& splitSizes[curSplitIndex].absolutePos <= absolutePos\n\t\t\t&& splitSizes[curSplitIndex].absolutePos + splitSizes[curSplitIndex].size > absolutePos)\n\t\t{\n\t\t\tsplitFileIndex = curSplitIndex;\n\t\t\tsplitFileOffset = absolutePos - splitSizes[curSplitIndex].absolutePos;\n\t\t\treturn true;\n\t\t}\n\t\tsplitFileIndex = splitSizes.size() / 2;\n\t\t//Binary search.\n\t\tsize_t left = 0, right = splitSizes.size();\n\t\twhile (true)\n\t\t{\n\t\t\tQWORD startPos = splitSizes[splitFileIndex].absolutePos;\n\t\t\tQWORD endPos = startPos + splitSizes[splitFileIndex].size;\n\t\t\tif (endPos < startPos) //Overflow\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (startPos > absolutePos)\n\t\t\t\tright = splitFileIndex;\n\t\t\telse if (endPos <= absolutePos)\n\t\t\t\tleft = splitFileIndex + 1;\n\t\t\telse\n\t\t\t\tbreak;\n\t\t\tif (left == right) //Did not find the correct split\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tsplitFileIndex = left + (right - left) / 2;\n\t\t}\n\t\tsplitFileOffset = absolutePos - splitSizes[splitFileIndex].absolutePos;\n\t\treturn true;\n\t}\npublic:\n\tAssetsReaderFromSplitFile(const TCHAR *filePath, bool binary, bool allowUpdate, AssetsRWOpenFlags flags)\n\t\t: AssetsReaderFromFile(filePath, binary, flags & (~RWOpenFlags_Unclosable))\n\t{\n\t\tthis->allowUpdate = allowUpdate;\n\t\tthis->flags = flags;\n\t\tthis->totalFileSize = 0;\n\t\tthis->curSplitIndex = 0;\n\t\tthis->curSplitPos = 0;\n\t\tthis->absoluteSplitFilePos = 0;\n\t}\n\t~AssetsReaderFromSplitFile()\n\t{\n\t\tClose();\n\t}\n\tbool Reopen()\n\t{\n\t\tbool ret = true;\n\t\tbool wasOpened = this->wasOpened;\n\t\tsize_t filePathLen = 0;\n\n\t\tstd::scoped_lock<std::recursive_mutex> fileOperationLock(fileOperationMutex);\n\n\t\tif (IsOpen())\n\t\t\tret = true;\n\t\telse if (filePath == NULL || (filePathLen = _tcslen(filePath)) == 0)\n\t\t\tret = false;\n\t\telse if (filePathLen < 5 || _tcscmp(&filePath[filePathLen - 4], _T("0000")))\n\t\t\tret = false;\n\t\telse\n\t\t{\n\t\t\tfilePath[filePathLen - 3] = 0; //the actual first name is .split0, the four additional nulls are just reserved space.\n\t\t\tif (!AssetsReaderFromFile::Reopen())\n\t\t\t\tret = false;\n\t\t\telse if (!wasOpened || allowUpdate)\n\t\t\t{\n\t\t\t\tsplitSizes.clear(); totalFileSize = 0;\n\t\t\t\tQWORD oldBasePos = 0;\n\t\t\t\tAssetsReaderFromFile::Tell(oldBasePos);\n\t\t\t\tif (!AssetsReaderFromFile::Seek(AssetsSeek_End, 0) || !AssetsReaderFromFile::Tell(totalFileSize))\n\t\t\t\t{\n\t\t\t\t\tret = false;\n\t\t\t\t\tAssetsReaderFromFile::Close();\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tAssetsReaderFromFile::SetPosition(oldBasePos);\n\t\t\t\t\tFileSizeEntry entry = {0, totalFileSize, this->pFile};\n\t\t\t\t\tsplitSizes.push_back(entry);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (ret && splitSizes.size() > 0)\n\t\t\t{\n\t\t\t\tint curOpenSplitIndex = 0;\n\t\t\t\twhile ((++curOpenSplitIndex) < 10000)\n\t\t\t\t{\n\t\t\t\t\tif ((wasOpened && !allowUpdate) && curOpenSplitIndex >= splitSizes.size())\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tFILE *pTempFile = NULL;\n\n\t\t\t\t\t_stprintf_p(&filePath[filePathLen - 4], 5, _T("%d"), curOpenSplitIndex);\n\t\t\t\t\tfilePath[filePathLen] = 0;\n\n\t\t\t\t\tTCHAR mode[3] = {_T(\'r\'), binary ? _T(\'b\') : 0, 0};\n\n\t\t\t\t\terrno_t err = _tfopen_s(&pTempFile, filePath, mode);\n\t\t\t\t\tif (err != 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tpTempFile = NULL;\n\t\t\t\t\t\tif (err == ENFILE || err == EMFILE)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tGarbageCollectReopenables(128);\n\t\t\t\t\t\t\terr = _tfopen_s(&pTempFile, filePath, mode);\n\t\t\t\t\t\t\tif (err != 0)\n\t\t\t\t\t\t\t\tpTempFile = NULL;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (pTempFile != NULL)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (fseek(pTempFile, 0, SEEK_END) == 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tlong long tempSize = _ftelli64(pTempFile);\n\t\t\t\t\t\t\tif (tempSize > 0)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tfseek(pTempFile, 0, SEEK_SET);\n\t\t\t\t\t\t\t\tif (!wasOpened || allowUpdate)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tsize_t lastIndex = splitSizes.size() - 1;\n\t\t\t\t\t\t\t\t\tFileSizeEntry entry = {splitSizes[lastIndex].absolutePos + splitSizes[lastIndex].size, (QWORD)tempSize, pTempFile};\n\t\t\t\t\t\t\t\t\ttotalFileSize = entry.absolutePos + entry.size;\n\t\t\t\t\t\t\t\t\tsplitSizes.push_back(entry);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse if ((QWORD)tempSize != splitSizes[curOpenSplitIndex].size)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tfclose(pTempFile);\n\t\t\t\t\t\t\t\t\tpTempFile = NULL;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tfclose(pTempFile);\n\t\t\t\t\t\t\t\tpTempFile = NULL;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfclose(pTempFile);\n\t\t\t\t\t\t\tpTempFile = NULL;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (pTempFile == NULL)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (wasOpened && !allowUpdate)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t//Split file not fully openable anymore; failed reopening\n\t\t\t\t\t\t\tAssetsReaderFromFile::Close();\n\t\t\t\t\t\t\tsplitSizes[0].pFile = NULL;\n\t\t\t\t\t\t\tfor (size_t i = 1; i < splitSizes.size(); i++)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif (splitSizes[i].pFile != NULL)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tfclose(splitSizes[i].pFile);\n\t\t\t\t\t\t\t\t\tsplitSizes[i].pFile = NULL;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tret = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t\tsplitSizes[curOpenSplitIndex].pFile = pTempFile;\n\t\t\t\t}\n\t\t\t}\n\t\t\t_tcscpy(&filePath[filePathLen - 4], _T("0000"));\n\t\t\tif (wasOpened)\n\t\t\t{\n\t\t\t\tif (splitSizes.size() > 0)\n\t\t\t\t{\n\t\t\t\t\t//Go to the previous position.\n\t\t\t\t\tif (!findSplitFile(absoluteSplitFilePos, curSplitIndex, curSplitPos)\n\t\t\t\t\t\t|| (_fseeki64(splitSizes[curSplitIndex].pFile, (long long)curSplitPos, SEEK_SET) != 0))\n\t\t\t\t\t{\n\t\t\t\t\t\tClose();\n\t\t\t\t\t\tret = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tClose();\n\t\t\t\t\tret = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n\tbool IsOpen()\n\t{\n\t\treturn AssetsReaderFromFile::IsOpen();\n\t}\n\tbool Close()\n\t{\n\t\tbool ret;\n\t\tstd::unique_lock<std::recursive_mutex> fileOperationLock(fileOperationMutex, std::defer_lock);\n\t\tif (filePath != NULL)\n\t\t\tfileOperationLock.lock();\n\t\tif (IsOpen())\n\t\t{\n\t\t\tif (flags & RWOpenFlags_Unclosable)\n\t\t\t\tret = false;\n\t\t\telse if (!Tell(absoluteSplitFilePos))\n\t\t\t\tret = false;\n\t\t\telse if (splitSizes.size() == 0)\n\t\t\t\tret = false;\n\t\t\telse if (!AssetsReaderFromFile::Close())\n\t\t\t\tret = false;\n\t\t\telse\n\t\t\t{\n\t\t\t\tthis->lastFilePos = 0;\n\t\t\t\tsplitSizes[0].pFile = NULL;\n\t\t\t\tfor (size_t i = 1; i < splitSizes.size(); i++)\n\t\t\t\t{\n\t\t\t\t\tif (splitSizes[i].pFile != NULL)\n\t\t\t\t\t{\n\t\t\t\t\t\tfclose(splitSizes[i].pFile);\n\t\t\t\t\t\tsplitSizes[i].pFile = NULL;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tret = true;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\tret = true;\n\t\treturn ret;\n\t}\n\n\tAssetsRWTypes GetType() { return AssetsRWType_Reader; }\n\tAssetsRWClasses GetClass() { return AssetsRWClass_ReaderFromSplitFile; }\n\tbool IsView() { return false; }\n\n\tbool Tell(QWORD &pos)\n\t{\n\t\tstd::scoped_lock<std::recursive_mutex> fileOperationLock(fileOperationMutex);\n\t\tbool ret;\n\t\tif (IsOpen())\n\t\t{\n\t\t\tpos = 0;\n\t\t\tif (splitSizes.size() <= curSplitIndex)\n\t\t\t{\n\t\t\t\tret = false;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tpos = splitSizes[curSplitIndex].absolutePos + curSplitPos;\n\t\t\t\tret = true;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpos = absoluteSplitFilePos;\n\t\t\tret = true;\n\t\t}\n\t\treturn ret;\n\t}\n\tbool Seek(AssetsSeekTypes origin, long long offset)\n\t{\n\t\tstd::scoped_lock<std::recursive_mutex> fileOperationLock(fileOperationMutex);\n\t\tbool ret;\n\t\tif (offset < 0)\n\t\t\tret = false;\n\t\telse if (!IsOpen() && !Reopen())\n\t\t\tret = false;\n\t\telse\n\t\t{\n\t\t\tswitch (origin)\n\t\t\t{\n\t\t\t\tcase AssetsSeek_Begin:\n\t\t\t\t\t{\n\t\t\t\t\t\tif (offset < 0)\n\t\t\t\t\t\t\tret = false;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tret = SetPosition((QWORD)offset);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\tcase AssetsSeek_End:\n\t\t\t\t\t{\n\t\t\t\t\t\tif (offset > 0)\n\t\t\t\t\t\t\tret = false;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tlong long tempAbsOffset = -offset;\n\t\t\t\t\t\t\tif (tempAbsOffset < 0) //if offset is the minimum signed long long\n\t\t\t\t\t\t\t\tret = false;\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif (splitSizes.size() > 0)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tQWORD endPos = splitSizes[splitSizes.size() - 1].absolutePos + splitSizes[splitSizes.size() - 1].size;\n\t\t\t\t\t\t\t\t\tif ((QWORD)tempAbsOffset > endPos)\n\t\t\t\t\t\t\t\t\t\tret = false;\n\t\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tret = SetPosition(endPos - (QWORD)tempAbsOffset);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse if (tempAbsOffset > 0)\n\t\t\t\t\t\t\t\t\tret = false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\tcase AssetsSeek_Cur:\n\t\t\t\t\t{\n\t\t\t\t\t\tif (offset == 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tret = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (curSplitIndex >= splitSizes.size())\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tret = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (offset > 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tQWORD curAbsolutePos = splitSizes[curSplitIndex].absolutePos + curSplitPos;\n\t\t\t\t\t\t\tQWORD targetPos = curAbsolutePos + offset;\n\t\t\t\t\t\t\tif (targetPos < curAbsolutePos) //Overflow\n\t\t\t\t\t\t\t\tret = false;\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tret = SetPosition(targetPos);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse //if (offset < 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tlong long tempRemainingOffset = -offset;\n\t\t\t\t\t\t\tif (tempRemainingOffset < 0) //if offset is the minimum signed long long\n\t\t\t\t\t\t\t\tret = false;\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tQWORD curAbsolutePos = splitSizes[curSplitIndex].absolutePos + curSplitPos;\n\t\t\t\t\t\t\t\tif ((QWORD)tempRemainingOffset > curAbsolutePos)\n\t\t\t\t\t\t\t\t\tret = false;\n\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tret = SetPosition(curAbsolutePos - (QWORD)tempRemainingOffset);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n\tbool SetPosition(QWORD pos)\n\t{\n\t\tstd::scoped_lock<std::recursive_mutex> fileOperationLock(fileOperationMutex);\n\t\tbool ret;\n\t\tif (((long long)pos) < 0) //_fseeki64 uses a signed offset\n\t\t\tret = false;\n\t\telse if (!IsOpen() && !Reopen())\n\t\t\tret = false;\n\t\telse\n\t\t{\n\t\t\tif (findSplitFile(pos, curSplitIndex, curSplitPos)\n\t\t\t\t&& (_fseeki64(splitSizes[curSplitIndex].pFile, (long long)curSplitPos, SEEK_SET) == 0))\n\t\t\t\tret = true;\n\t\t\telse\n\t\t\t\tret = false;\n\t\t}\n\t\treturn ret;\n\t}\n\n\tQWORD Read(QWORD pos, QWORD size, void *outBuffer, bool nullUnread)\n\t{\n\t\tstd::unique_lock<std::recursive_mutex> fileOperationLock(fileOperationMutex);\n\t\tQWORD ret;\n\t\tif (!IsOpen() && !Reopen())\n\t\t\tret = 0;\n\t\telse if ((pos != (QWORD)-1) && !SetPosition(pos))\n\t\t\tret = 0;\n\t\telse if ((curSplitIndex >= splitSizes.size()) || (curSplitPos > splitSizes[curSplitIndex].size))\n\t\t\tret = 0;\n\t\telse\n\t\t{\n\t\t\tQWORD remainingSize = size;\n\t\t\twhile (remainingSize > 0)\n\t\t\t{\n\t\t\t\tQWORD curReadSize = splitSizes[curSplitIndex].size - curSplitPos;\n\t\t\t\tif (curReadSize > remainingSize) curReadSize = remainingSize;\n\t\t\t\tif (curReadSize > 0)\n\t\t\t\t{\n\t\t\t\t\tif (splitSizes[curSplitIndex].pFile == NULL)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tQWORD read = fread(&((uint8_t*)outBuffer)[size - remainingSize], 1, curReadSize, splitSizes[curSplitIndex].pFile);\n\t\t\t\t\tcurSplitPos += read;\n\t\t\t\t\tremainingSize -= read;\n\t\t\t\t\tif (read < curReadSize) //curSplitPos is also allowed to be equal to the current split size.\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (curSplitPos >= splitSizes[curSplitIndex].size)\n\t\t\t\t{\n\t\t\t\t\tif (splitSizes.size() > (curSplitIndex + 1))\n\t\t\t\t\t{\n\t\t\t\t\t\tcurSplitIndex++;\n\t\t\t\t\t\tcurSplitPos = 0;\n\t\t\t\t\t\tif (splitSizes[curSplitIndex].pFile) fseek(splitSizes[curSplitIndex].pFile, 0, SEEK_SET);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tret = size - remainingSize;\n\t\t}\n\t\tfileOperationLock.unlock();\n\t\tif (nullUnread && (ret < size))\n\t\t\tmemset(&((uint8_t*)outBuffer)[ret], 0, size - ret);\n\t\treturn ret;\n\t}\n\tIAssetsReader *CreateView();\n\tfriend class AssetsReaderFromSplitFile_View;\n};\nclass AssetsReaderFromSplitFile_View : public IAssetsReader\n{\n\tAssetsReaderFromSplitFile *pBaseReader;\n\tQWORD filePos;\n\tsize_t splitFileIndex;\n\tQWORD splitFilePos;\npublic:\n\tAssetsReaderFromSplitFile_View(AssetsReaderFromSplitFile *pBaseReader)\n\t\t: pBaseReader(pBaseReader), filePos(0), splitFileIndex(0), splitFilePos(0)\n\t{}\n\t\n\t~AssetsReaderFromSplitFile_View(){}\n\n\tbool Reopen() { return pBaseReader->SetPosition(filePos); }\n\tbool IsOpen() { return pBaseReader->IsOpen(); }\n\tbool Close() { return false; }\n\n\tAssetsRWTypes GetType() { return AssetsRWType_Reader; }\n\tAssetsRWClasses GetClass() { return AssetsRWClass_ReaderFromSplitFile; }\n\tbool IsView() { return true; }\n\n\tbool Tell(QWORD &pos) { pos = filePos; return true; }\n\tbool Seek(AssetsSeekTypes origin, long long offset)\n\t{\n\t\tbool ret = false;\n\t\tQWORD newPos = filePos;\n\t\tswitch (origin)\n\t\t{\n\t\tcase AssetsSeek_Begin:\n\t\t\tif (offset < 0) return false;\n\t\t\tnewPos = offset;\n\t\t\tbreak;\n\t\tcase AssetsSeek_Cur:\n\t\t\tif (offset < 0)\n\t\t\t{\n\t\t\t\toffset = -offset;\n\t\t\t\tif (offset < 0) return false; //INT64_MIN\n\t\t\t\tif ((unsigned long long)offset > newPos) return false;\n\t\t\t\tnewPos -= (unsigned long long)offset;\n\t\t\t}\n\t\t\telse\n\t\t\t\tnewPos += (unsigned long long)offset;\n\t\t\tbreak;\n\t\tcase AssetsSeek_End:\n\t\t\tif (offset > 0) return false;\n\t\t\toffset = -offset;\n\t\t\tif (offset < 0) return false; //INT64_MIN\n\t\t\tif ((unsigned long long)offset > pBaseReader->totalFileSize) return false;\n\t\t\tnewPos = pBaseReader->totalFileSize - (unsigned long long)offset;\n\t\t\tbreak;\n\t\t}\n\t\tstd::scoped_lock<std::recursive_mutex> fileOperationLock(pBaseReader->fileOperationMutex);\n\t\tret = pBaseReader->Seek(AssetsSeek_Begin, newPos);\n\t\tsize_t newSplitIndex = pBaseReader->curSplitIndex;\n\t\tQWORD newSplitPos = pBaseReader->curSplitPos;\n\t\tif (ret)\n\t\t{\n\t\t\tfilePos = newPos;\n\t\t\tsplitFileIndex = newSplitIndex;\n\t\t\tsplitFilePos = newSplitPos;\n\t\t}\n\t\treturn ret;\n\t}\n\tbool SetPosition(QWORD pos)\n\t{\n\t\tstd::scoped_lock<std::recursive_mutex> fileOperationLock(pBaseReader->fileOperationMutex);\n\t\tbool ret = pBaseReader->SetPosition(pos);\n\t\tif (ret)\n\t\t{\n\t\t\tfilePos = pos;\n\t\t\tsplitFileIndex = pBaseReader->curSplitIndex;\n\t\t\tsplitFilePos = pBaseReader->curSplitPos;\n\t\t}\n\t\treturn ret;\n\t}\n\t\n\tQWORD Read(QWORD pos, QWORD size, void *outBuffer, bool nullUnread)\n\t{\n\t\tstd::scoped_lock<std::recursive_mutex> fileOperationLock(pBaseReader->fileOperationMutex);\n\t\tif (pos == (QWORD)-1)\n\t\t{\n\t\t\tpos = filePos;\n\t\t\t//Give the base reader a hint where the data is located.\n\t\t\tpBaseReader->curSplitIndex = splitFileIndex;\n\t\t\tpBaseReader->curSplitPos = splitFilePos;\n\t\t}\n\t\telse\n\t\t\tfilePos = pos;\n\t\tQWORD result = pBaseReader->Read(pos, size, outBuffer, nullUnread);\n\t\tsplitFileIndex = pBaseReader->curSplitIndex;\n\t\tsplitFilePos = pBaseReader->curSplitPos;\n\t\tfilePos += result;\n\t\treturn result;\n\t}\n\t\n\tIAssetsReader *CreateView() { return pBaseReader->CreateView(); }\n};\nIAssetsReader *AssetsReaderFromSplitFile::CreateView()\n{\n\treturn new AssetsReaderFromSplitFile_View(this);\n}\n\nIAssetsReader *Create_AssetsReaderFromSplitFile(const wchar_t *filePath, bool binary, bool allowUpdate, AssetsRWOpenFlags openFlags)\n{\n\tif (filePath == NULL) return NULL;\n\tsize_t filePathLen = wcslen(filePath);\n\tif ((filePathLen < 7) || wcscmp(&filePath[filePathLen - 7], L".split0"))\n\t\treturn NULL;\n\n\tstd::wstring tempFilePath = std::wstring(filePath) + L"000";\n\n\tAssetsReaderFromSplitFile *pReader = new AssetsReaderFromSplitFile(tempFilePath.c_str(), binary, allowUpdate, openFlags);\n\n\tif (openFlags & RWOpenFlags_Immediately)\n\t{\n\t\tif (!pReader->Reopen())\n\t\t{\n\t\t\tdelete pReader;\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\tAddReopenable(pReader);\n\treturn pReader;\n}\nIAssetsReader *Create_AssetsReaderFromSplitFile(const char *filePath, bool binary, bool allowUpdate, AssetsRWOpenFlags openFlags)\n{\n\tif (filePath == NULL) return NULL;\n\n\tsize_t tcLen = 0;\n\tTCHAR *tcPath = _MultiByteToWide(filePath, tcLen);\n\n\tIAssetsReader *pReader = Create_AssetsReaderFromSplitFile(tcPath, binary, allowUpdate, openFlags);\n\n\t_FreeWCHAR(tcPath);\n\n\treturn pReader;\n}\n\nclass AssetsReaderFromMemory : public IAssetsReader\n{\nprotected:\n\tconst void *buf;\n\tsize_t bufLen;\n\tcbFreeMemoryResource freeBufCallback;\n\n\tvoid *ownBuf; //null if copyBuf was passed as false\n\n\tsize_t readerPos;\npublic:\n\tAssetsReaderFromMemory(const void *buf, size_t bufLen, bool copyBuf, cbFreeMemoryResource freeBufCallback)\n\t\t: freeBufCallback(freeBufCallback)\n\t{\n\t\tthis->readerPos = 0;\n\t\tif (copyBuf)\n\t\t{\n\t\t\tthis->buf = this->ownBuf = malloc(bufLen);\n\t\t\tif (this->ownBuf == nullptr)\n\t\t\t\tthis->bufLen = 0;\n\t\t\telse\n\t\t\t{\n\t\t\t\tmemcpy(this->ownBuf, buf, bufLen);\n\t\t\t\tthis->bufLen = bufLen;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\townBuf = nullptr;\n\t\t\tthis->buf = buf;\n\t\t\tthis->bufLen = bufLen;\n\t\t}\n\t}\n\t~AssetsReaderFromMemory()\n\t{\n\t\tif (ownBuf != nullptr)\n\t\t{\n\t\t\tfree(ownBuf);\n\t\t\townBuf = nullptr;\n\t\t}\n\t\telse if (buf != nullptr)\n\t\t{\n\t\t\tif (freeBufCallback)\n\t\t\t\tfreeBufCallback(const_cast<void*>(buf));\n\t\t}\n\t\tbuf = nullptr; bufLen = 0; readerPos = 0;\n\t}\n\tbool Reopen()\n\t{\n\t\treturn true;\n\t}\n\tbool IsOpen()\n\t{\n\t\treturn true;\n\t}\n\tbool Close()\n\t{\n\t\treturn false;\n\t}\n\n\tAssetsRWTypes GetType() { return AssetsRWType_Reader; }\n\tAssetsRWClasses GetClass() { return AssetsRWClass_ReaderFromMemory; }\n\tbool IsView() { return false; }\n\n\tbool Tell(QWORD &pos)\n\t{\n\t\tpos = readerPos;\n\t\treturn true;\n\t}\n\tbool Seek(AssetsSeekTypes origin, long long offset)\n\t{\n\t\tbool ret;\n\t\tswitch (origin)\n\t\t{\n\t\t\tcase AssetsSeek_Begin:\n\t\t\t{\n\t\t\t\tif (offset < 0)\n\t\t\t\t\tret = false;\n\t\t\t\telse if ((unsigned long long)offset > this->bufLen)\n\t\t\t\t\tret = false;\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tthis->readerPos = (size_t)offset;\n\t\t\t\t\tret = true;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase AssetsSeek_Cur:\n\t\t\t{\n\t\t\t\tif (offset < 0)\n\t\t\t\t{\n\t\t\t\t\toffset = -offset;\n\t\t\t\t\tif (offset < 0) //=> offset is the minimum signed long long\n\t\t\t\t\t\tret = false;\n\t\t\t\t\telse if ((unsigned long long)offset > this->readerPos)\n\t\t\t\t\t\tret = false;\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tthis->readerPos -= (unsigned long long)offset;\n\t\t\t\t\t\tret = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if ((unsigned long long)offset > (this->bufLen - this->readerPos))\n\t\t\t\t\tret = false;\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tthis->readerPos += (unsigned long long)offset;\n\t\t\t\t\tret = true;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase AssetsSeek_End:\n\t\t\t{\n\t\t\t\tif (offset > 0)\n\t\t\t\t\tret = false;\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\toffset = -offset;\n\t\t\t\t\tif (offset < 0) //=> offset is the minimum signed long long\n\t\t\t\t\t\tret = false;\n\t\t\t\t\telse if ((unsigned long long)offset > this->bufLen)\n\t\t\t\t\t\tret = false;\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tthis->readerPos = this->bufLen - (unsigned long long)offset;\n\t\t\t\t\t\tret = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdefault: ret = false;\n\t\t}\n\t\treturn ret;\n\t}\n\tbool SetPosition(QWORD pos)\n\t{\n\t\tbool ret;\n\t\tif (pos > this->bufLen)\n\t\t\tret = false;\n\t\telse\n\t\t{\n\t\t\tthis->readerPos = pos;\n\t\t\tret = true;\n\t\t}\n\t\treturn ret;\n\t}\n\n\tQWORD Read(QWORD pos, QWORD size, void *outBuffer, bool nullUnread)\n\t{\n\t\tQWORD ret;\n\t\tif ((pos != (QWORD)-1) && !SetPosition(pos))\n\t\t\tret = 0;\n\t\telse\n\t\t{\n\t\t\tQWORD actualSize = size;\n\t\t\tif (actualSize > (this->bufLen - this->readerPos))\n\t\t\t{\n\t\t\t\tactualSize = this->bufLen - this->readerPos;\n\t\t\t}\n\t\t\tmemcpy(outBuffer, &((uint8_t*)this->buf)[this->readerPos], (size_t)actualSize);\n\t\t\tret = actualSize;\n\t\t\tthis->readerPos += ret;\n\t\t}\n\t\tif (nullUnread && (ret < size))\n\t\t\tmemset(&((uint8_t*)outBuffer)[ret], 0, size - ret);\n\t\treturn ret;\n\t}\n\n\tbool HasBuffer()\n\t{\n\t\treturn buf != NULL || bufLen == 0;\n\t}\n\n\tIAssetsReader *CreateView();\n\tfriend class AssetsReaderFromMemory_View;\n};\nclass AssetsReaderFromMemory_View : public IAssetsReader\n{\n\tAssetsReaderFromMemory *pBaseReader;\n\tsize_t pos;\npublic:\n\tAssetsReaderFromMemory_View(AssetsReaderFromMemory *pBaseReader)\n\t\t: pBaseReader(pBaseReader), pos(0)\n\t{}\n\t\n\t~AssetsReaderFromMemory_View(){}\n\n\tbool Reopen() { return true; }\n\tbool IsOpen() { return true; }\n\tbool Close() { return false; }\n\n\tAssetsRWTypes GetType() { return AssetsRWType_Reader; }\n\tAssetsRWClasses GetClass() { return AssetsRWClass_ReaderFromMemory; }\n\tbool IsView() { return true; }\n\n\tbool Tell(QWORD &pos) { pos = this->pos; return true; }\n\tbool Seek(AssetsSeekTypes origin, long long offset)\n\t{\n\t\tbool ret = false;\n\t\tQWORD newPos = pos;\n\t\tswitch (origin)\n\t\t{\n\t\tcase AssetsSeek_Begin:\n\t\t\tif (offset < 0) return false;\n\t\t\tnewPos = offset;\n\t\t\tbreak;\n\t\tcase AssetsSeek_Cur:\n\t\t\tif (offset < 0)\n\t\t\t{\n\t\t\t\toffset = -offset;\n\t\t\t\tif (offset < 0) return false; //INT64_MIN\n\t\t\t\tif ((unsigned long long)offset > newPos) return false;\n\t\t\t\tnewPos -= (unsigned long long)offset;\n\t\t\t}\n\t\t\telse\n\t\t\t\tnewPos += offset;\n\t\t\tbreak;\n\t\tcase AssetsSeek_End:\n\t\t\tif (offset > 0) return false;\n\t\t\toffset = -offset;\n\t\t\tif (offset < 0) return false; //INT64_MIN\n\t\t\tif ((unsigned long long)offset > pBaseReader->bufLen) return false;\n\t\t\tnewPos = pBaseReader->bufLen - (unsigned long long)offset;\n\t\t\tbreak;\n\t\t}\n\t\tif (newPos <= (QWORD)pBaseReader->bufLen)\n\t\t{\n\t\t\tpos = newPos;\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\tbool SetPosition(QWORD pos)\n\t{\n\t\tif (pos <= (QWORD)pBaseReader->bufLen)\n\t\t{\n\t\t\tthis->pos = pos;\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\t\n\tQWORD Read(QWORD pos, QWORD size, void *outBuffer, bool nullUnread)\n\t{\n\t\tQWORD result = pBaseReader->Read(pos, size, outBuffer, nullUnread);\n\t\tpos += result;\n\t\treturn result;\n\t}\n\t\n\tIAssetsReader *CreateView() { return pBaseReader->CreateView(); }\n};\nIAssetsReader *AssetsReaderFromMemory::CreateView()\n{\n\treturn new AssetsReaderFromMemory_View(this);\n}\n\nIAssetsReader *Create_AssetsReaderFromMemory(const void *buf, size_t bufLen, bool copyBuf, cbFreeMemoryResource freeBufCallback)\n{\n\tif (buf == NULL && bufLen > 0) return NULL;\n\t\n\tAssetsReaderFromMemory *pReader = new AssetsReaderFromMemory(buf, bufLen, copyBuf, freeBufCallback);\n\tif (copyBuf && !pReader->HasBuffer())\n\t{\n\t\tdelete pReader;\n\t\tpReader = NULL;\n\t}\n\t//AssetsReaderFromMemory isn\'t garbage collectable\n\t//else\n\t//\tAddReopenable(pReader);\n\treturn pReader;\n}\n\nclass AssetsReaderFromReaderRange : public IAssetsReaderFromReaderRange\n{\nprotected:\n\tIAssetsReader *pChild;\n\tQWORD rangeStart; QWORD rangeSize;\n\tQWORD readerPos;\n\tbool doSeek; bool alwaysSeek;\npublic:\n\tAssetsReaderFromReaderRange(IAssetsReader *pChild, QWORD rangeStart, QWORD rangeSize, bool alwaysSeekChild)\n\t{\n\t\tthis->pChild = pChild;\n\t\tthis->rangeStart = rangeStart;\n\t\tthis->rangeSize = rangeSize;\n\t\tthis->alwaysSeek = alwaysSeekChild;\n\t\tthis->readerPos = 0;\n\t\tthis->doSeek = false;\n\t}\n\t~AssetsReaderFromReaderRange()\n\t{\n\t\tthis->pChild = NULL;\n\t\tthis->rangeStart = 0;\n\t\tthis->rangeSize = 0;\n\t\tthis->readerPos = 0;\n\t}\n\tbool Reopen()\n\t{\n\t\tbool ret = false;\n\t\tif (pChild != NULL)\n\t\t\tret = pChild->Reopen();\n\t\treturn ret;\n\t}\n\tbool IsOpen()\n\t{\n\t\tbool ret = false;\n\t\tif (pChild != NULL)\n\t\t\tret = pChild->IsOpen();\n\t\treturn ret;\n\t}\n\tbool Close()\n\t{\n\t\tbool ret = false;\n\t\tif (pChild != NULL)\n\t\t{\n\t\t\tret = pChild->Close();\n\t\t\tif (ret)\n\t\t\t\tthis->doSeek = true;\n\t\t}\n\t\treturn ret;\n\t}\n\n\tAssetsRWTypes GetType() { return AssetsRWType_Reader; }\n\tAssetsRWClasses GetClass() { return AssetsRWClass_ReaderFromReaderRange; }\n\tbool IsView() { return false; }\n\n\tbool Tell(QWORD &pos)\n\t{\n\t\tpos = readerPos;\n\t\treturn true;\n\t}\n\tbool Seek(AssetsSeekTypes origin, long long offset, QWORD &newPos)\n\t{\n\t\tbool ret;\n\t\tswitch (origin)\n\t\t{\n\t\t\tcase AssetsSeek_Begin:\n\t\t\t{\n\t\t\t\tif (offset < 0)\n\t\t\t\t\tret = false;\n\t\t\t\telse if ((unsigned long long)offset > rangeSize)\n\t\t\t\t\tret = false;\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tthis->readerPos = newPos = (size_t)offset;\n\t\t\t\t\tthis->doSeek = true;\n\t\t\t\t\tret = true;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase AssetsSeek_Cur:\n\t\t\t{\n\t\t\t\tif (offset < 0)\n\t\t\t\t{\n\t\t\t\t\toffset = -offset;\n\t\t\t\t\tif (offset < 0) //=> offset is the minimum signed long long\n\t\t\t\t\t\tret = false;\n\t\t\t\t\telse if ((unsigned long long)offset > this->readerPos)\n\t\t\t\t\t\tret = false;\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tthis->readerPos -= (unsigned long long)offset;\n\t\t\t\t\t\tthis->doSeek = true;\n\t\t\t\t\t\tret = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if ((unsigned long long)offset > (this->rangeSize - this->readerPos))\n\t\t\t\t\tret = false;\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tthis->readerPos += (unsigned long long)offset;\n\t\t\t\t\tthis->doSeek = true;\n\t\t\t\t\tret = true;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase AssetsSeek_End:\n\t\t\t{\n\t\t\t\tif (offset > 0)\n\t\t\t\t\tret = false;\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\toffset = -offset;\n\t\t\t\t\tif (offset < 0) //=> offset is the minimum signed long long\n\t\t\t\t\t\tret = false;\n\t\t\t\t\telse if ((unsigned long long)offset > this->rangeSize)\n\t\t\t\t\t\tret = false;\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tthis->readerPos = this->rangeSize - (unsigned long long)offset;\n\t\t\t\t\t\tthis->doSeek = true;\n\t\t\t\t\t\tret = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdefault: ret = false;\n\t\t}\n\t\treturn ret;\n\t}\n\tbool Seek(AssetsSeekTypes origin, long long offset)\n\t{\n\t\tQWORD newPos;\n\t\treturn Seek(origin, offset, newPos);\n\t}\n\tbool SetPosition(QWORD pos)\n\t{\n\t\tbool ret;\n\t\tif (pos > this->rangeSize)\n\t\t\tret = false;\n\t\telse\n\t\t{\n\t\t\tthis->readerPos = pos;\n\t\t\tthis->doSeek = true;\n\t\t\tret = true;\n\t\t}\n\t\treturn ret;\n\t}\n\n\tQWORD Read(QWORD pos, QWORD size, void *outBuffer, bool nullUnread)\n\t{\n\t\tQWORD ret;\n\t\tif (pChild == NULL)\n\t\t\tret = 0;\n\t\telse if ((pos != (QWORD)-1) && !SetPosition(pos))\n\t\t\tret = 0;\n\t\t//else if ((doSeek || alwaysSeek) && !pChild->SetPosition(this->rangeStart + this->readerPos))\n\t\t//\tret = 0;\n\t\telse\n\t\t{\n\t\t\tif (pos == (QWORD)-1)\n\t\t\t\tpos = this->readerPos;\n\t\t\tQWORD actualSize = size;\n\t\t\tif (actualSize > (this->rangeSize - pos))\n\t\t\t{\n\t\t\t\tactualSize = this->rangeSize - pos;\n\t\t\t}\n\t\t\tQWORD readPos = (doSeek || alwaysSeek) ? (this->rangeStart + pos) : ((QWORD)-1);\n\t\t\tret = pChild->Read(readPos, actualSize, outBuffer, false);\n\t\t\tthis->readerPos = pos + ret;\n\t\t\tdoSeek = false;\n\t\t}\n\t\tif (nullUnread && (ret < size))\n\t\t\tmemset(&((uint8_t*)outBuffer)[ret], 0, size - ret);\n\t\treturn ret;\n\t}\n\n\tbool GetChild(IAssetsReader *&pReader)\n\t{\n\t\tpReader = pChild;\n\t\treturn (pChild != NULL);\n\t}\n\tIAssetsReader *CreateView()\n\t{\n\t\t//This reader type qualifies as a view already.\n\t\talwaysSeek = true;\n\t\treturn Create_AssetsReaderFromReaderRange(pChild, rangeStart, rangeSize, true);\n\t}\n};\n\nIAssetsReaderFromReaderRange *Create_AssetsReaderFromReaderRange(IAssetsReader *pChild, QWORD rangeStart, QWORD rangeSize, bool alwaysSeek)\n{\n\tif (pChild == NULL) return NULL;\n\t\n\tAssetsReaderFromReaderRange *pReader = new AssetsReaderFromReaderRange(pChild, rangeStart, rangeSize, alwaysSeek);\n\n\t//AssetsReaderFromReaderRange isn\'t garbage collectable\n\t//AddReopenable(pReader);\n\treturn pReader;\n}\n\nclass AssetsWriterToFile : public IAssetsWriter\n{\n\tAssetsRWOpenFlags flags;\nprotected:\n\tbool discard;\n\tbool binary;\n\tTCHAR *filePath;\n\n\tbool wasOpened;\n\tQWORD lastFilePos;\n\n\tFILE *pFile;\n\tstd::recursive_mutex fileOperationMutex;\npublic:\n\tAssetsWriterToFile(const TCHAR *filePath, bool discard, bool binary, AssetsRWOpenFlags flags)\n\t{\n\t\tthis->flags = flags;\n\t\t\n\t\tthis->discard = discard;\n\t\tthis->binary = binary;\n\n\t\tsize_t pathLen = wcslen(filePath) + 1;\n\t\tthis->filePath = new TCHAR[pathLen];\n\t\tmemcpy(this->filePath, filePath, pathLen * sizeof(TCHAR));\n\n\t\tthis->wasOpened = false;\n\t\tthis->pFile = NULL;\n\t\tthis->lastFilePos = 0;\n\t}\n\tAssetsWriterToFile(FILE *pFile)\n\t{\n\t\tthis->pFile = pFile;\n\n\t\tthis->flags = RWOpenFlags_Unclosable;\n\t\t\n\t\tthis->discard = this->binary = true;\n\t\tthis->filePath = NULL;\n\t\tthis->wasOpened = true;\n\t\tthis->lastFilePos = 0;\n\t}\n\t~AssetsWriterToFile()\n\t{\n\t\tRemoveReopenable(this);\n\t\tif (filePath)\n\t\t{\n\t\t\tfree(filePath);\n\t\t\tfilePath = NULL;\n\t\t\tflags = RWOpenFlags_None; //RWOpenFlags_Unclosable could otherwise prevent closing the file.\n\t\t\tClose();\n\t\t}\n\t}\n\tbool Reopen()\n\t{\n\t\tbool ret = true;\n\t\tstd::scoped_lock<std::recursive_mutex> fileOperationLock(fileOperationMutex);\n\t\tif (IsOpen())\n\t\t\tret = true;\n\t\telse if (filePath == NULL)\n\t\t\tret = false;\n\t\telse\n\t\t{\n\t\t\tFILE *pTempFile = NULL;\n\t\t\tTCHAR mode[4] = {0,0,0,0};\n\t\t\tif (discard)\n\t\t\t{\n\t\t\t\tmode[0] = _T(\'w\');\n\t\t\t\tmode[1] = binary ? _T(\'b\') : 0;\n\t\t\t\t//Further reopens must not discard the contents again.\n\t\t\t\t//Without this, unpredictable behaviour would occur since a Close() call can be issued by garbage collection at any time.\n\t\t\t\tdiscard = false;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tmode[0] = _T(\'r\');\n\t\t\t\tmode[1] = _T(\'+\');\n\t\t\t\tmode[2] = binary ? _T(\'b\') : 0;\n\t\t\t}\n\t\t\t\n\t\t\terrno_t err = _tfopen_s(&pTempFile, filePath, mode);\n\t\t\tif (err != 0)\n\t\t\t{\n\t\t\t\tif (err == ENFILE || err == EMFILE)\n\t\t\t\t{\n\t\t\t\t\tGarbageCollectReopenables();\n\t\t\t\t\terr = _tfopen_s(&pTempFile, filePath, mode);\n\t\t\t\t\tif (err != 0)\n\t\t\t\t\t\tret = false;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tret = false;\n\t\t\t}\n\t\t\tif (ret)\n\t\t\t{\n\t\t\t\tpFile = pTempFile;\n\t\t\t\tif (wasOpened && !SetPosition(lastFilePos))\n\t\t\t\t{\n\t\t\t\t\tfclose(pTempFile);\n\t\t\t\t\tret = false;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\twasOpened = true;\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n\tbool IsOpen()\n\t{\n\t\treturn pFile != NULL;\n\t}\n\tbool Close()\n\t{\n\t\tbool ret;\n\t\tstd::unique_lock<std::recursive_mutex> fileOperationLock(fileOperationMutex, std::defer_lock);\n\t\tif (filePath != NULL)\n\t\t\tfileOperationLock.lock();\n\t\tif (IsOpen())\n\t\t{\n\t\t\tif (flags & RWOpenFlags_Unclosable)\n\t\t\t\tret = false;\n\t\t\telse if (!Tell(lastFilePos))\n\t\t\t\tret = false;\n\t\t\telse\n\t\t\t{\n\t\t\t\tfclose(pFile);\n\t\t\t\tpFile = NULL;\n\t\t\t\tret = true;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\tret = true;\n\t\treturn ret;\n\t}\n\n\tAssetsRWTypes GetType() { return AssetsRWType_Writer; }\n\tAssetsRWClasses GetClass() { return AssetsRWClass_WriterToFile; }\n\tbool IsView() { return false; }\n\n\tbool Tell(QWORD &pos)\n\t{\n\t\tstd::scoped_lock<std::recursive_mutex> fileOperationLock(fileOperationMutex);\n\t\tbool ret;\n\t\tif (IsOpen())\n\t\t{\n\t\t\tlong long posv = _ftelli64(pFile);\n\t\t\tif (posv < 0)\n\t\t\t{\n\t\t\t\tpos = 0;\n\t\t\t\tret = false;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tpos = (QWORD)posv;\n\t\t\t\tret = true;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpos = lastFilePos;\n\t\t\tret = true;\n\t\t}\n\t\treturn ret;\n\t}\n\tbool Seek(AssetsSeekTypes origin, long long offset)\n\t{\n\t\tstd::scoped_lock<std::recursive_mutex> fileOperationLock(fileOperationMutex);\n\t\tbool ret;\n\t\tif (!IsOpen() && !Reopen())\n\t\t\tret = false;\n\t\telse\n\t\t\tret = _fseeki64(pFile, offset, (int)origin) == 0;\n\t\treturn ret;\n\t}\n\tbool SetPosition(QWORD pos)\n\t{\n\t\tstd::scoped_lock<std::recursive_mutex> fileOperationLock(fileOperationMutex);\n\t\tbool ret;\n\t\tif (((long long)pos) < 0) //fpos_t is signed\n\t\t\tret = false;\n\t\telse if (!IsOpen() && !Reopen())\n\t\t\tret = false;\n\t\telse\n\t\t\tret = _fseeki64(pFile, (long long)pos, SEEK_SET) == 0;\n\t\treturn ret;\n\t}\n\n\tQWORD Write(QWORD pos, QWORD size, const void *inBuffer)\n\t{\n\t\tstd::scoped_lock<std::recursive_mutex> fileOperationLock(fileOperationMutex);\n\t\tQWORD ret;\n\t\tif (!IsOpen() && !Reopen())\n\t\t\tret = 0;\n\t\telse if ((pos != (QWORD)-1) && !SetPosition(pos))\n\t\t\tret = 0;\n\t\telse\n\t\t\tret = fwrite(inBuffer, 1, size, pFile);\n\t\treturn ret;\n\t}\n\n\tbool Flush()\n\t{\n\t\tstd::scoped_lock<std::recursive_mutex> fileOperationLock(fileOperationMutex);\n\t\tbool ret;\n\t\tif (!IsOpen())\n\t\t\tret = true;\n\t\telse\n\t\t\tret = fflush(pFile) == 0;\n\t\treturn ret;\n\t}\n};\n\nIAssetsWriter *Create_AssetsWriterToFile(const wchar_t *filePath, bool discard, bool binary, AssetsRWOpenFlags openFlags)\n{\n\tif (filePath == NULL) return NULL;\n\n\tAssetsWriterToFile *pWriter = new AssetsWriterToFile(filePath, discard, binary, openFlags);\n\n\tif (openFlags & RWOpenFlags_Immediately)\n\t{\n\t\tif (!pWriter->Reopen())\n\t\t{\n\t\t\tdelete pWriter;\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\tAddReopenable(pWriter);\n\treturn pWriter;\n}\nIAssetsWriter *Create_AssetsWriterToFile(const char *filePath, bool discard, bool binary, AssetsRWOpenFlags openFlags)\n{\n\tif (filePath == NULL) return NULL;\n\n\tsize_t tcLen = 0;\n\tTCHAR *tcPath = _MultiByteToWide(filePath, tcLen);\n\n\tIAssetsWriter *pWriter = Create_AssetsWriterToFile(tcPath, discard, binary, openFlags);\n\n\t_FreeWCHAR(tcPath);\n\n\treturn pWriter;\n}\nIAssetsWriter *Create_AssetsWriterToFile(FILE *pFile)\n{\n\tif (pFile == NULL) return NULL;\n\n\tAssetsWriterToFile *pWriter = new AssetsWriterToFile(pFile);\n\n\treturn pWriter;\n}\n\n\nclass AssetsWriterToMemory : public IAssetsWriterToMemory\n{\nprotected:\n\tvoid *data;\n\tsize_t dataLen;\n\tsize_t dataBufLen;\n\n\tvoid *ownBuf; //NULL if the caller passed a buffer through the constructor\n\tsize_t ownBufMaxLen;\n\n\tsize_t writerPos;\n\n\tbool isDynamic; bool freeOnClose;\npublic:\n\tAssetsWriterToMemory(void *buf, size_t bufLen, size_t initialDataLen)\n\t{\n\t\tthis->data = buf;\n\t\tthis->dataLen = initialDataLen;\n\t\tthis->dataBufLen = bufLen;\n\t\tthis->ownBuf = NULL;\n\t\tthis->ownBufMaxLen = 0;\n\t\tthis->writerPos = 0;\n\t\tthis->isDynamic = false;\n\t\tthis->freeOnClose = false;\n\t\tmemset(&((uint8_t*)buf)[initialDataLen], 0, bufLen - initialDataLen);\n\t}\n\tAssetsWriterToMemory(size_t maximumLen, size_t initialLen)\n\t{\n\t\tthis->ownBuf = initialLen ? malloc(initialLen) : 0;\n\t\tif (this->ownBuf == NULL)\n\t\t\tinitialLen = 0;\n\t\telse\n\t\t\tmemset(this->ownBuf, 0, initialLen);\n\t\tthis->dataBufLen = initialLen;\n\n\t\tthis->data = this->ownBuf;\n\t\tthis->dataLen = 0;\n\n\t\tthis->ownBufMaxLen = maximumLen;\n\t\tthis->writerPos = 0;\n\n\t\tthis->isDynamic = true;\n\t\tthis->freeOnClose = true;\n\t}\n\t~AssetsWriterToMemory()\n\t{\n\t\tif (ownBuf != NULL)\n\t\t{\n\t\t\tif (freeOnClose)\n\t\t\t\tfree(ownBuf);\n\t\t\townBuf = NULL;\n\t\t}\n\t\tdataBufLen = 0;\n\t\tdata = NULL; dataLen = 0;\n\t\twriterPos = 0;\n\t}\n\tbool Reopen()\n\t{\n\t\treturn true;\n\t}\n\tbool IsOpen()\n\t{\n\t\treturn true;\n\t}\n\tbool Close()\n\t{\n\t\treturn false;\n\t}\n\n\n\tAssetsRWTypes GetType() { return AssetsRWType_Writer; }\n\tAssetsRWClasses GetClass() { return AssetsRWClass_WriterToMemory; }\n\tbool IsView() { return false; }\n\n\tbool Tell(QWORD &pos)\n\t{\n\t\tpos = writerPos;\n\t\treturn true;\n\t}\n\tbool Seek(AssetsSeekTypes origin, long long offset)\n\t{\n\t\tbool ret;\n\t\tswitch (origin)\n\t\t{\n\t\t\tcase AssetsSeek_Begin:\n\t\t\t{\n\t\t\t\tif (offset < 0)\n\t\t\t\t\tret = false;\n\t\t\t\telse \n\t\t\t\t{\n\t\t\t\t\tif ((unsigned long long)offset > this->dataBufLen)\n\t\t\t\t\t\tResize((size_t)std::min<unsigned long long>(offset, SIZE_MAX));\n\t\t\t\t\tif ((unsigned long long)offset > this->dataBufLen)\n\t\t\t\t\t\tret = false;\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tif ((unsigned long long)offset > this->dataLen)\n\t\t\t\t\t\t\tthis->dataLen = (size_t)offset;\n\t\t\t\t\t\tthis->writerPos = (size_t)offset;\n\t\t\t\t\t\tret = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase AssetsSeek_Cur:\n\t\t\t{\n\t\t\t\tif (offset < 0)\n\t\t\t\t{\n\t\t\t\t\toffset = -offset;\n\t\t\t\t\tif (offset < 0) //=> offset is the minimum signed long long\n\t\t\t\t\t\tret = false;\n\t\t\t\t\telse if ((unsigned long long)offset > this->writerPos)\n\t\t\t\t\t\tret = false;\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tthis->writerPos -= (unsigned long long)offset;\n\t\t\t\t\t\tret = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tunsigned long long _offset = (unsigned long long)offset + this->writerPos;\n\t\t\t\t\tif (_offset > this->dataBufLen)\n\t\t\t\t\t\tResize(std::min<unsigned long long>(_offset, SIZE_MAX));\n\t\t\t\t\tif (_offset > this->dataBufLen)\n\t\t\t\t\t\tret = false;\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tif (_offset > this->dataLen)\n\t\t\t\t\t\t\tthis->dataLen = (size_t)_offset;\n\t\t\t\t\t\tthis->writerPos = (size_t)_offset;\n\t\t\t\t\t\tret = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase AssetsSeek_End:\n\t\t\t{\n\t\t\t\tif (offset > 0)\n\t\t\t\t{\n\t\t\t\t\tunsigned long long _offset = offset + this->dataLen;\n\t\t\t\t\tif (_offset > this->dataBufLen)\n\t\t\t\t\t\tResize((size_t)std::min<unsigned long long>(_offset, SIZE_MAX));\n\t\t\t\t\tif (_offset > this->dataBufLen)\n\t\t\t\t\t\tret = false;\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tif (_offset > this->dataLen)\n\t\t\t\t\t\t\tthis->dataLen = (size_t)offset;\n\t\t\t\t\t\tthis->writerPos = (size_t)offset;\n\t\t\t\t\t\tret = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\toffset = -offset;\n\t\t\t\t\tif (offset < 0) //=> offset is the minimum signed long long\n\t\t\t\t\t\tret = false;\n\t\t\t\t\telse if ((unsigned long long)offset > this->dataLen)\n\t\t\t\t\t\tret = false;\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tthis->writerPos = this->dataLen - (unsigned long long)offset;\n\t\t\t\t\t\tret = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdefault: ret = false;\n\t\t}\n\t\treturn ret;\n\t}\n\tbool SetPosition(QWORD pos)\n\t{\n\t\tbool ret;\n\t\tif (pos > this->dataBufLen)\n\t\t\tResize(pos);\n\t\tif (pos > this->dataBufLen)\n\t\t\tret = false;\n\t\telse\n\t\t{\n\t\t\tif (pos > this->dataLen)\n\t\t\t\tthis->dataLen = (size_t)pos;\n\t\t\tthis->writerPos = pos;\n\t\t\tret = true;\n\t\t}\n\t\treturn ret;\n\t}\n\n\tQWORD Write(QWORD pos, QWORD size, const void *inBuffer)\n\t{\n\t\tQWORD ret;\n\t\tif ((pos != (QWORD)-1) && !SetPosition(pos))\n\t\t\tret = 0;\n\t\telse\n\t\t{\n\t\t\tif (this->writerPos > this->dataBufLen)\n\t\t\t\treturn 0;\n\t\t\tQWORD actualSize = size;\n\t\t\tif (actualSize > (this->dataBufLen - this->writerPos))\n\t\t\t{\n\t\t\t\tif (isDynamic && !Resize(this->writerPos + actualSize))\n\t\t\t\t\treturn 0;\n\t\t\t\tif (actualSize > (this->dataBufLen - this->writerPos))\n\t\t\t\t\tactualSize = this->dataBufLen - this->writerPos;\n\t\t\t}\n\t\t\tmemcpy(&((uint8_t*)data)[writerPos], inBuffer, (size_t)actualSize);\n\t\t\tret = actualSize;\n\t\t\tthis->writerPos += ret;\n\t\t\tif (this->writerPos > this->dataLen)\n\t\t\t\tthis->dataLen = this->writerPos;\n\t\t}\n\t\treturn ret;\n\t}\n\n\tbool Flush()\n\t{\n\t\treturn true;\n\t}\n\n\tbool GetBuffer(void *&buffer, size_t &dataSize)\n\t{\n\t\tbuffer = data;\n\t\tdataSize = dataLen;\n\t\treturn true;\n\t}\n\n\tbool IsDynamicBuffer()\n\t{\n\t\treturn isDynamic;\n\t}\n\n\tbool SetFreeBuffer(bool doFree)\n\t{\n\t\tif (!isDynamic && doFree)\n\t\t\treturn false;\n\t\tthis->freeOnClose = doFree;\n\t\treturn true;\n\t}\n\n\tbool Resize(size_t targetLen)\n\t{\n\t\tif (!isDynamic)\n\t\t\treturn false;\n\n\t\ttargetLen = (targetLen + 2047) & ~(2047);\n\t\tif (targetLen > ownBufMaxLen)\n\t\t\ttargetLen = ownBufMaxLen;\n\t\t\n\t\tvoid *newBuf = realloc(ownBuf, targetLen);\n\t\tif (newBuf == NULL)\n\t\t\treturn false;\n\n\t\townBuf = newBuf;\n\t\tdata = newBuf;\n\t\tif (targetLen > dataBufLen)\n\t\t\tmemset(&((uint8_t*)newBuf)[dataBufLen], 0, targetLen - dataBufLen);\n\t\tdataBufLen = targetLen;\n\t\tif (dataLen > targetLen)\n\t\t\tdataLen = targetLen;\n\t\treturn true;\n\t}\n};\n\nIAssetsWriterToMemory *Create_AssetsWriterToMemory(void *buf, size_t bufLen, size_t initialDataLen)\n{\n\tif (buf == NULL && bufLen > 0) return NULL;\n\tif (initialDataLen > bufLen) return NULL;\n\n\tAssetsWriterToMemory *pWriter = new AssetsWriterToMemory(buf, bufLen, initialDataLen);\n\n\t//AssetsWriterToMemory isn\'t garbage collectable\n\t//AddReopenable(pWriter);\n\treturn pWriter;\n}\nIAssetsWriterToMemory *Create_AssetsWriterToMemory(size_t initialLen, size_t maximumLen)\n{\n\tif (initialLen > maximumLen) return NULL;\n\n\tAssetsWriterToMemory *pWriter = new AssetsWriterToMemory(maximumLen, initialLen);\n\n\t//AssetsWriterToMemory isn\'t garbage collectable\n\t//AddReopenable(pWriter);\n\treturn pWriter;\n}\nvoid Free_AssetsWriterToMemory_DynBuf(void *buffer)\n{\n\tif (buffer)\n\t\tfree(buffer);\n}\n\nclass AssetsWriterToWriterOffset : public IAssetsWriterToWriterOffset\n{\nprotected:\n\tIAssetsWriter *pChild;\n\tQWORD childOffset;\n\tQWORD writerPos;\n\tbool doSeek; bool alwaysSeek;\npublic:\n\tAssetsWriterToWriterOffset(IAssetsWriter *pChild, QWORD offset, bool alwaysSeekChild)\n\t{\n\t\tthis->pChild = pChild;\n\t\tthis->childOffset = offset;\n\t\tthis->alwaysSeek = alwaysSeekChild;\n\t\tthis->writerPos = 0;\n\t\tthis->doSeek = false;\n\t}\n\t~AssetsWriterToWriterOffset()\n\t{\n\t\tthis->pChild = NULL;\n\t\tthis->childOffset = 0;\n\t\tthis->writerPos = 0;\n\t}\n\tbool Reopen()\n\t{\n\t\tbool ret = false;\n\t\tif (pChild != NULL)\n\t\t\tret = pChild->Reopen();\n\t\treturn ret;\n\t}\n\tbool IsOpen()\n\t{\n\t\tbool ret = false;\n\t\tif (pChild != NULL)\n\t\t\tret = pChild->IsOpen();\n\t\treturn ret;\n\t}\n\tbool Close()\n\t{\n\t\tbool ret = false;\n\t\tif (pChild != NULL)\n\t\t{\n\t\t\tret = pChild->Close();\n\t\t\tif (ret)\n\t\t\t\tthis->doSeek = true;\n\t\t}\n\t\treturn ret;\n\t}\n\n\tAssetsRWTypes GetType() { return AssetsRWType_Writer; }\n\tAssetsRWClasses GetClass() { return AssetsRWClass_WriterToWriterOffset; }\n\tbool IsView() { return false; }\n\n\tbool Tell(QWORD &pos)\n\t{\n\t\tpos = writerPos;\n\t\treturn true;\n\t}\n\tbool Seek(AssetsSeekTypes origin, long long offset)\n\t{\n\t\tbool ret;\n\t\tif (pChild == NULL)\n\t\t\tret = false;\n\t\telse\n\t\t{\n\t\t\tswitch (origin)\n\t\t\t{\n\t\t\t\tcase AssetsSeek_Begin:\n\t\t\t\t{\n\t\t\t\t\tif (offset < 0)\n\t\t\t\t\t\tret = false;\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tif (ret = pChild->Seek(AssetsSeek_Begin, this->childOffset + offset))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tQWORD tempPos = this->childOffset + (size_t)offset;\n\t\t\t\t\t\t\tif (pChild->Tell(tempPos) && ((tempPos - this->childOffset) != (size_t)offset))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tthis->doSeek = true;\n\t\t\t\t\t\t\t\tret = false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tthis->writerPos = (size_t)offset;\n\t\t\t\t\t\t\t\tthis->doSeek = false;\n\t\t\t\t\t\t\t\tret = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tret = false;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase AssetsSeek_Cur:\n\t\t\t\t{\n\t\t\t\t\tif (offset < 0)\n\t\t\t\t\t{\n\t\t\t\t\t\toffset = -offset;\n\t\t\t\t\t\tif (offset < 0) //=> offset is the minimum signed long long\n\t\t\t\t\t\t\tret = false;\n\t\t\t\t\t\telse if ((unsigned long long)offset > this->writerPos)\n\t\t\t\t\t\t\tret = false;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tthis->writerPos -= (unsigned long long)offset;\n\t\t\t\t\t\t\tthis->doSeek = true;\n\t\t\t\t\t\t\tret = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tif (ret = pChild->Seek(AssetsSeek_Cur, offset))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tQWORD tempPos = this->childOffset + (unsigned long long)offset;\n\t\t\t\t\t\t\tif (pChild->Tell(tempPos) && ((tempPos - this->childOffset) != this->writerPos))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tthis->doSeek = true;\n\t\t\t\t\t\t\t\tret = false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tthis->writerPos += (unsigned long long)offset;\n\t\t\t\t\t\t\t\tthis->doSeek = false;\n\t\t\t\t\t\t\t\tret = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tret = false;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase AssetsSeek_End:\n\t\t\t\t{\n\t\t\t\t\tif (offset > 0)\n\t\t\t\t\t\tret = false;\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\toffset = -offset;\n\t\t\t\t\t\tif (offset < 0) //=> offset is the minimum signed long long\n\t\t\t\t\t\t\tret = false;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (ret = pChild->Seek(AssetsSeek_End, -offset))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tQWORD tempPos = 0;\n\t\t\t\t\t\t\t\tif (!pChild->Tell(tempPos) || (tempPos < this->childOffset))\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tthis->doSeek = true;\n\t\t\t\t\t\t\t\t\tret = false;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tthis->writerPos = tempPos - this->childOffset;\n\t\t\t\t\t\t\t\t\tthis->doSeek = false;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tret = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tdefault: ret = false;\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n\tbool SetPosition(QWORD pos)\n\t{\n\t\tbool ret;\n\t\tif (pChild == NULL)\n\t\t\tret = false;\n\t\telse if (pChild->SetPosition(pos + this->childOffset))\n\t\t{\n\t\t\tQWORD tempPos = pos + this->childOffset;\n\t\t\tpChild->Tell(tempPos);\n\t\t\tif (tempPos != (pos + this->childOffset))\n\t\t\t{\n\t\t\t\tthis->doSeek = true;\n\t\t\t\tret = false;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tthis->writerPos = pos;\n\t\t\t\tthis->doSeek = false;\n\t\t\t\tret = true;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\tret = false;\n\t\treturn ret;\n\t}\n\n\tQWORD Write(QWORD pos, QWORD size, const void *inBuffer)\n\t{\n\t\tQWORD ret;\n\t\tif (pChild == NULL)\n\t\t\tret = 0;\n\t\telse if ((pos != (QWORD)-1) && !SetPosition(pos))\n\t\t\tret = 0;\n\t\telse\n\t\t{\n\t\t\tQWORD writePos = (doSeek || alwaysSeek) ? (this->childOffset + this->writerPos) : ((QWORD)-1);\n\t\t\tret = pChild->Write(writePos, size, inBuffer);\n\t\t\tthis->writerPos += ret;\n\t\t\tdoSeek = false;\n\t\t}\n\t\treturn ret;\n\t}\n\n\tbool Flush()\n\t{\n\t\treturn (pChild != NULL) && pChild->Flush();\n\t}\n\n\tbool GetChild(IAssetsWriter *&pWriter)\n\t{\n\t\tpWriter = pChild;\n\t\treturn (pChild != NULL);\n\t}\n};\n\nIAssetsWriterToWriterOffset *Create_AssetsWriterToWriterOffset(IAssetsWriter *pChild, QWORD offset, bool alwaysSeek)\n{\n\tif (pChild == NULL) return NULL;\n\t\n\tAssetsWriterToWriterOffset *pWriter = new AssetsWriterToWriterOffset(pChild, offset, alwaysSeek);\n\n\t//AssetsWriterToWriterOffset isn\'t garbage collectable\n\t//AddReopenable(pReader);\n\treturn pWriter;\n}'