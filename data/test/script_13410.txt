b'{-# OPTIONS_GHC -fno-warn-orphans #-}\n{-# LANGUAGE BangPatterns #-}\n{-# LANGUAGE CPP #-}\n{-# LANGUAGE DataKinds #-}\n{-# LANGUAGE InstanceSigs #-}\n{-# LANGUAGE UndecidableInstances #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n\nmodule Database.Beam.Sqlite.Connection\n  ( Sqlite(..), SqliteM(..)\n  , sqliteUriSyntax\n\n  , runBeamSqlite, runBeamSqliteDebug\n\n    -- * Emulated @INSERT RETURNING@ support\n  , insertReturning, runInsertReturningList\n  ) where\n\nimport           Prelude hiding (fail)\n\nimport           Database.Beam.Backend\nimport           Database.Beam.Backend.Internal.Compat\nimport qualified Database.Beam.Backend.SQL.BeamExtensions as Beam\nimport           Database.Beam.Backend.URI\nimport           Database.Beam.Migrate.Generics\nimport           Database.Beam.Migrate.SQL ( BeamMigrateOnlySqlBackend, FieldReturnType(..) )\nimport qualified Database.Beam.Migrate.SQL as Beam\nimport           Database.Beam.Migrate.SQL.BeamExtensions\nimport           Database.Beam.Query ( SqlInsert(..), SqlInsertValues(..)\n                                     , HasQBuilder(..), HasSqlEqualityCheck\n                                     , HasSqlQuantifiedEqualityCheck\n                                     , DataType(..)\n                                     , HasSqlInTable(..)\n                                     , insert, current_ )\nimport           Database.Beam.Query.Internal\nimport           Database.Beam.Query.SQL92\nimport           Database.Beam.Schema.Tables ( Beamable\n                                             , Columnar\'(..)\n                                             , DatabaseEntity(..)\n                                             , DatabaseEntityDescriptor(..)\n                                             , TableEntity\n                                             , TableField(..)\n                                             , allBeamValues\n                                             , changeBeamRep )\nimport           Database.Beam.Sqlite.Syntax\n\nimport           Database.SQLite.Simple ( Connection, ToRow(..), FromRow(..)\n                                        , Query(..), SQLData(..), field\n                                        , execute, execute_\n                                        , withStatement, bind, nextRow\n                                        , query_, open, close )\nimport           Database.SQLite.Simple.FromField ( FromField(..), ResultError(..)\n                                                  , returnError, fieldData)\nimport           Database.SQLite.Simple.Internal (RowParser(RP), unRP)\nimport           Database.SQLite.Simple.Ok (Ok(..))\nimport           Database.SQLite.Simple.Types (Null)\n\nimport           Control.Exception (SomeException(..), bracket_, onException, mask)\nimport           Control.Monad (forM_)\nimport           Control.Monad.Base (MonadBase)\nimport           Control.Monad.Fail (MonadFail(..))\nimport           Control.Monad.Free.Church\nimport           Control.Monad.IO.Class (MonadIO(..))\nimport           Control.Monad.Identity (Identity)\nimport           Control.Monad.Reader (ReaderT(..), MonadReader(..), runReaderT)\nimport           Control.Monad.State.Strict (MonadState(..), StateT(..), runStateT)\nimport           Control.Monad.Trans (lift)\nimport           Control.Monad.Trans.Control (MonadBaseControl)\nimport           Control.Monad.Writer (tell, execWriter)\n\nimport           Data.ByteString.Builder (toLazyByteString)\nimport qualified Data.ByteString.Char8 as BS\nimport qualified Data.ByteString.Lazy.Char8 as BL\nimport qualified Data.DList as D\nimport           Data.Int\nimport           Data.Maybe (mapMaybe)\nimport           Data.Proxy (Proxy(..))\nimport           Data.Scientific (Scientific)\nimport           Data.String (fromString)\nimport qualified Data.Text as T\nimport qualified Data.Text.Encoding as T (decodeUtf8)\nimport qualified Data.Text.Lazy as TL\nimport qualified Data.Text.Lazy.Encoding as TL (decodeUtf8)\nimport           Data.Time ( LocalTime, UTCTime, Day\n                           , ZonedTime, utc, utcToLocalTime )\nimport           Data.Typeable (cast)\nimport           Data.Word\nimport           GHC.TypeLits\n\nimport           Network.URI\n\n#ifdef UNIX\nimport           System.Posix.Process (getProcessID)\n#elif defined(WINDOWS)\nimport           System.Win32.Process (getCurrentProcessId)\n#else\n#error Need either POSIX or Win32 API for MonadBeamInsertReturning\n#endif\n\nimport           Text.Read (readMaybe)\n\n-- | The SQLite backend. Used to parameterize \'MonadBeam\' and \'FromBackendRow\'\n-- to provide support for SQLite databases. See the documentation for\n-- \'MonadBeam\' and the <https://haskell-beam.github.io/beam/ user guide> for more\n-- information on how to use this backend.\ndata Sqlite = Sqlite\n\ninstance BeamBackend Sqlite where\n  type BackendFromField Sqlite = FromField\n\ninstance HasQBuilder Sqlite where\n  buildSqlQuery = buildSql92Query\' False -- SQLite does not support arbitrarily nesting UNION, INTERSECT, and EXCEPT\n\ninstance HasSqlInTable Sqlite where\n  inRowValuesE Proxy e es = SqliteExpressionSyntax $ mconcat\n    [ parens $ fromSqliteExpression e\n    , emit " IN "\n    , parens $ emit "VALUES " <> commas (map fromSqliteExpression es)\n    ]\n\ninstance BeamSqlBackendIsString Sqlite T.Text\ninstance BeamSqlBackendIsString Sqlite String\n\ninstance FromBackendRow Sqlite Bool\ninstance FromBackendRow Sqlite Double\ninstance FromBackendRow Sqlite Float\ninstance FromBackendRow Sqlite Int8\ninstance FromBackendRow Sqlite Int16\ninstance FromBackendRow Sqlite Int32\ninstance FromBackendRow Sqlite Int64\ninstance FromBackendRow Sqlite Integer\ninstance FromBackendRow Sqlite Word8\ninstance FromBackendRow Sqlite Word16\ninstance FromBackendRow Sqlite Word32\ninstance FromBackendRow Sqlite Word64\ninstance FromBackendRow Sqlite BS.ByteString\ninstance FromBackendRow Sqlite BL.ByteString\ninstance FromBackendRow Sqlite T.Text\ninstance FromBackendRow Sqlite TL.Text\ninstance FromBackendRow Sqlite UTCTime\ninstance FromBackendRow Sqlite Day\ninstance FromBackendRow Sqlite Null\ninstance FromBackendRow Sqlite Char where\n  fromBackendRow = do\n    t <- fromBackendRow\n    case T.uncons t of\n      Just (c, _) -> pure c\n      _ -> fail "Need string of size one to parse Char"\ninstance FromBackendRow Sqlite SqlNull where\n  fromBackendRow =\n    SqlNull <$ (fromBackendRow :: FromBackendRowM Sqlite Null)\ninstance FromBackendRow Sqlite LocalTime where\n  fromBackendRow = utcToLocalTime utc <$> fromBackendRow\ninstance FromBackendRow Sqlite Scientific where\n  fromBackendRow = unSqliteScientific <$> fromBackendRow\ninstance FromBackendRow Sqlite SqliteScientific\n\ninstance TypeError (PreferExplicitSize Int Int32) => FromBackendRow Sqlite Int\ninstance TypeError (PreferExplicitSize Word Word32) => FromBackendRow Sqlite Word\n\nnewtype SqliteScientific = SqliteScientific { unSqliteScientific :: Scientific }\ninstance FromField SqliteScientific where\n  fromField f =\n    SqliteScientific <$>\n    case fieldData f of\n      SQLInteger i -> pure (fromIntegral i)\n      SQLFloat d -> pure . fromRational . toRational $ d\n      SQLText t -> tryRead (T.unpack t)\n      SQLBlob b -> tryRead (BS.unpack b)\n      SQLNull -> returnError UnexpectedNull f "null"\n    where\n      tryRead s =\n        case readMaybe s of\n          Nothing -> returnError ConversionFailed f $\n                     "No conversion to Scientific for \'" <> s <> "\'"\n          Just s\'  -> pure s\'\n\ninstance BeamSqlBackend Sqlite\ninstance BeamMigrateOnlySqlBackend Sqlite\ntype instance BeamSqlBackendSyntax Sqlite = SqliteCommandSyntax\n\ndata SqliteHasDefault = SqliteHasDefault\ninstance FieldReturnType \'True \'False Sqlite resTy a =>\n         FieldReturnType \'False \'False Sqlite resTy (SqliteHasDefault -> a) where\n  field\' _ _ nm ty _ collation constraints SqliteHasDefault =\n    field\' (Proxy @\'True) (Proxy @\'False) nm ty Nothing collation constraints\n\ninstance BeamSqlBackendHasSerial Sqlite where\n  genericSerial nm = Beam.field nm (DataType sqliteSerialType) SqliteHasDefault\n\n-- | \'MonadBeam\' instance inside which SQLite queries are run. See the\n-- <https://haskell-beam.github.io/beam/ user guide> for more information\nnewtype SqliteM a\n  = SqliteM\n  { runSqliteM :: ReaderT (String -> IO (), Connection) IO a\n    -- ^ Run an IO action with access to a SQLite connection and a debug logging\n    -- function, called or each query submitted on the connection.\n  } deriving (Monad, Functor, Applicative, MonadIO, MonadFail)\n    deriving newtype (MonadBase IO, MonadBaseControl IO)\n\nnewtype BeamSqliteParams = BeamSqliteParams [SQLData]\ninstance ToRow BeamSqliteParams where\n  toRow (BeamSqliteParams x) = x\n\nnewtype BeamSqliteRow a = BeamSqliteRow a\ninstance FromBackendRow Sqlite a => FromRow (BeamSqliteRow a) where\n  fromRow = BeamSqliteRow <$> runF fromBackendRow\' finish step\n      where\n        FromBackendRowM fromBackendRow\' = fromBackendRow :: FromBackendRowM Sqlite a\n\n        translateErrors :: Maybe Int -> SomeException -> Maybe SomeException\n        translateErrors col (SomeException e) =\n          case cast e of\n            Just (ConversionFailed { errSQLType     = typeString\n                                   , errHaskellType = hsString\n                                   , errMessage     = msg }) ->\n              Just (SomeException (BeamRowReadError col (ColumnTypeMismatch hsString typeString ("conversion failed: " ++ msg))))\n            Just (UnexpectedNull {}) ->\n              Just (SomeException (BeamRowReadError col ColumnUnexpectedNull))\n            Just (Incompatible { errSQLType     = typeString\n                               , errHaskellType = hsString\n                               , errMessage     = msg }) ->\n              Just (SomeException (BeamRowReadError col (ColumnTypeMismatch hsString typeString ("incompatible: " ++ msg))))\n            Nothing -> Nothing\n\n        finish = pure\n\n        step :: forall a\'. FromBackendRowF Sqlite (RowParser a\') -> RowParser a\'\n        step (ParseOneField next) =\n            RP $ ReaderT $ \\ro -> StateT $ \\st@(col, _) ->\n            case runStateT (runReaderT (unRP field) ro) st of\n              Ok (x, st\') -> runStateT (runReaderT (unRP (next x)) ro) st\'\n              Errors errs -> Errors (mapMaybe (translateErrors (Just col)) errs)\n        step (Alt (FromBackendRowM a) (FromBackendRowM b) next) = do\n          RP $ do\n            let RP a\' = runF a finish step\n                RP b\' = runF b finish step\n\n            st <- get\n            ro <- ask\n            case runStateT (runReaderT a\' ro) st of\n              Ok (ra, st\') -> do\n                put st\'\n                unRP (next ra)\n              Errors aErrs ->\n                case runStateT (runReaderT b\' ro) st of\n                  Ok (rb, st\') -> do\n                    put st\'\n                    unRP (next rb)\n                  Errors bErrs ->\n                    lift (lift (Errors (aErrs ++ bErrs)))\n        step (FailParseWith err) = RP (lift (lift (Errors [SomeException err])))\n\n-- * Equality checks\n#define HAS_SQLITE_EQUALITY_CHECK(ty)                       \\\n  instance HasSqlEqualityCheck Sqlite (ty); \\\n  instance HasSqlQuantifiedEqualityCheck Sqlite (ty);\n\nHAS_SQLITE_EQUALITY_CHECK(Int8)\nHAS_SQLITE_EQUALITY_CHECK(Int16)\nHAS_SQLITE_EQUALITY_CHECK(Int32)\nHAS_SQLITE_EQUALITY_CHECK(Int64)\nHAS_SQLITE_EQUALITY_CHECK(Word8)\nHAS_SQLITE_EQUALITY_CHECK(Word16)\nHAS_SQLITE_EQUALITY_CHECK(Word32)\nHAS_SQLITE_EQUALITY_CHECK(Word64)\nHAS_SQLITE_EQUALITY_CHECK(Double)\nHAS_SQLITE_EQUALITY_CHECK(Float)\nHAS_SQLITE_EQUALITY_CHECK(Bool)\nHAS_SQLITE_EQUALITY_CHECK(String)\nHAS_SQLITE_EQUALITY_CHECK(T.Text)\nHAS_SQLITE_EQUALITY_CHECK(TL.Text)\nHAS_SQLITE_EQUALITY_CHECK(BS.ByteString)\nHAS_SQLITE_EQUALITY_CHECK(BL.ByteString)\nHAS_SQLITE_EQUALITY_CHECK(UTCTime)\nHAS_SQLITE_EQUALITY_CHECK(LocalTime)\nHAS_SQLITE_EQUALITY_CHECK(ZonedTime)\nHAS_SQLITE_EQUALITY_CHECK(Char)\nHAS_SQLITE_EQUALITY_CHECK(Integer)\nHAS_SQLITE_EQUALITY_CHECK(Scientific)\n\ninstance TypeError (PreferExplicitSize Int Int32) => HasSqlEqualityCheck Sqlite Int\ninstance TypeError (PreferExplicitSize Int Int32) => HasSqlQuantifiedEqualityCheck Sqlite Int\ninstance TypeError (PreferExplicitSize Word Word32) => HasSqlEqualityCheck Sqlite Word\ninstance TypeError (PreferExplicitSize Word Word32) => HasSqlQuantifiedEqualityCheck Sqlite Word\n\nclass HasDefaultSqlDataType Sqlite a => IsSqliteSerialIntegerType a\ninstance IsSqliteSerialIntegerType Int32\ninstance IsSqliteSerialIntegerType Int64\ninstance TypeError (PreferExplicitSize Int Int32) => IsSqliteSerialIntegerType Int\n\ninstance IsSqliteSerialIntegerType a => HasDefaultSqlDataType Sqlite (SqlSerial a) where\n  defaultSqlDataType _ _ False = sqliteSerialType\n  defaultSqlDataType _ _ True = intType\n\ninstance HasDefaultSqlDataType Sqlite BS.ByteString where\n  -- TODO we should somehow allow contsraints based on backend\n  defaultSqlDataType _ _ _ = sqliteBlobType\n\ninstance HasDefaultSqlDataType Sqlite LocalTime where\n  defaultSqlDataType _ _ _ = timestampType Nothing False\n\n-- | URI syntax for use with \'withDbConnection\'. See documentation for\n-- \'BeamURIOpeners\' for more information.\nsqliteUriSyntax :: c Sqlite Connection SqliteM\n                -> BeamURIOpeners c\nsqliteUriSyntax =\n  mkUriOpener runBeamSqlite "sqlite:"\n    (\\uri -> do\n        let sqliteName = if null (uriPath uri) then ":memory:" else uriPath uri\n        hdl <- open sqliteName\n        pure (hdl, close hdl))\n\nrunBeamSqliteDebug :: (String -> IO ()) -> Connection -> SqliteM a -> IO a\nrunBeamSqliteDebug debugStmt conn x = runReaderT (runSqliteM x) (debugStmt, conn)\n\nrunBeamSqlite :: Connection -> SqliteM a -> IO a\nrunBeamSqlite = runBeamSqliteDebug (\\_ -> pure ())\n\ninstance MonadBeam Sqlite SqliteM where\n  runNoReturn (SqliteCommandSyntax (SqliteSyntax cmd vals)) =\n    SqliteM $ do\n      (logger, conn) <- ask\n      let cmdString = BL.unpack (toLazyByteString (withPlaceholders cmd))\n      liftIO (logger (cmdString ++ ";\\n-- With values: " ++ show (D.toList vals)))\n      liftIO (execute conn (fromString cmdString) (D.toList vals))\n  runNoReturn (SqliteCommandInsert insertStmt_) =\n    SqliteM $ do\n      (logger, conn) <- ask\n      liftIO (runSqliteInsert logger conn insertStmt_)\n\n  runReturningMany (SqliteCommandSyntax (SqliteSyntax cmd vals)) action =\n      SqliteM $ do\n        (logger, conn) <- ask\n        let cmdString = BL.unpack (toLazyByteString (withPlaceholders cmd))\n        liftIO $ do\n          logger (cmdString ++ ";\\n-- With values: " ++ show (D.toList vals))\n          withStatement conn (fromString cmdString) $ \\stmt ->\n            do bind stmt (BeamSqliteParams (D.toList vals))\n               let nextRow\' = liftIO (nextRow stmt) >>= \\x ->\n                              case x of\n                                Nothing -> pure Nothing\n                                Just (BeamSqliteRow row) -> pure row\n               runReaderT (runSqliteM (action nextRow\')) (logger, conn)\n  runReturningMany SqliteCommandInsert {} _ =\n      fail . mconcat $\n      [ "runReturningMany{Sqlite}: sqlite does not support returning "\n      , "rows from an insert, use Database.Beam.Sqlite.insertReturning "\n      , "for emulation" ]\n\ninstance Beam.MonadBeamInsertReturning Sqlite SqliteM where\n  runInsertReturningList = runInsertReturningList\n\nrunSqliteInsert :: (String -> IO ()) -> Connection -> SqliteInsertSyntax -> IO ()\nrunSqliteInsert logger conn (SqliteInsertSyntax tbl fields vs onConflict)\n    -- If all expressions are simple expressions (no default), then just\n\n  | SqliteInsertExpressions es <- vs, any (any (== SqliteExpressionDefault)) es =\n      forM_ es $ \\row -> do\n        let (fields\', row\') = unzip $ filter ((/= SqliteExpressionDefault) . snd) $ zip fields row\n            SqliteSyntax cmd vals = formatSqliteInsertOnConflict tbl fields\' (SqliteInsertExpressions [ row\' ]) onConflict\n            cmdString = BL.unpack (toLazyByteString (withPlaceholders cmd))\n        logger (cmdString ++ ";\\n-- With values: " ++ show (D.toList vals))\n        execute conn (fromString cmdString) (D.toList vals)\n  | otherwise = do\n      let SqliteSyntax cmd vals = formatSqliteInsertOnConflict tbl fields vs onConflict\n          cmdString = BL.unpack (toLazyByteString (withPlaceholders cmd))\n      logger (cmdString ++ ";\\n-- With values: " ++ show (D.toList vals))\n      execute conn (fromString cmdString) (D.toList vals)\n\n-- * emulated INSERT returning support\n\n-- | Build a \'SqliteInsertReturning\' representing inserting the given values\n-- into the given table. Use \'runInsertReturningList\'\ninsertReturning :: Beamable table\n                => DatabaseEntity Sqlite db (TableEntity table)\n                -> SqlInsertValues Sqlite (table (QExpr Sqlite s))\n                -> SqlInsert Sqlite table\ninsertReturning = insert\n\n-- | Runs a \'SqliteInsertReturning\' statement and returns a result for each\n-- inserted row.\nrunInsertReturningList :: (Beamable table, FromBackendRow Sqlite (table Identity))\n                       => SqlInsert Sqlite table\n                       -> SqliteM [ table Identity ]\nrunInsertReturningList SqlInsertNoRows = pure []\nrunInsertReturningList (SqlInsert tblSettings insertStmt_@(SqliteInsertSyntax nm _ _ _)) =\n  do (logger, conn) <- SqliteM ask\n     SqliteM . liftIO $ do\n\n#ifdef UNIX\n       processId <- fromString . show <$> getProcessID\n#elif defined(WINDOWS)\n       processId <- fromString . show <$> getCurrentProcessId\n#else\n#error Need either POSIX or Win32 API for MonadBeamInsertReturning\n#endif\n\n       let tableNameTxt = T.decodeUtf8 (BL.toStrict (sqliteRenderSyntaxScript (fromSqliteTableName nm)))\n\n           startSavepoint =\n             execute_ conn (Query ("SAVEPOINT insert_savepoint_" <> processId))\n           rollbackToSavepoint =\n             execute_ conn (Query ("ROLLBACK TRANSACTION TO SAVEPOINT insert_savepoint_" <> processId))\n           releaseSavepoint =\n             execute_ conn (Query ("RELEASE SAVEPOINT insert_savepoint_" <> processId))\n\n           createInsertedValuesTable =\n             execute_ conn (Query ("CREATE TEMPORARY TABLE inserted_values_" <> processId <> " AS SELECT * FROM " <> tableNameTxt <> " LIMIT 0"))\n           dropInsertedValuesTable =\n             execute_ conn (Query ("DROP TABLE inserted_values_" <> processId))\n\n           createInsertTrigger =\n             execute_ conn (Query ("CREATE TEMPORARY TRIGGER insert_trigger_" <> processId <> " AFTER INSERT ON " <> tableNameTxt <> " BEGIN " <>\n                                   "INSERT INTO inserted_values_" <> processId <> " SELECT * FROM " <> tableNameTxt <> " WHERE ROWID=last_insert_rowid(); END" ))\n           dropInsertTrigger =\n             execute_ conn (Query ("DROP TRIGGER insert_trigger_" <> processId))\n\n\n       mask $ \\restore -> do\n         startSavepoint\n         flip onException rollbackToSavepoint . restore $ do\n           x <- bracket_ createInsertedValuesTable dropInsertedValuesTable $\n                bracket_ createInsertTrigger dropInsertTrigger $ do\n                runSqliteInsert logger conn insertStmt_\n\n                let columns = TL.toStrict $ TL.decodeUtf8 $\n                              sqliteRenderSyntaxScript $ commas $\n                              allBeamValues (\\(Columnar\' projField) -> quotedIdentifier (_fieldName projField)) $\n                              tblSettings\n\n                fmap (\\(BeamSqliteRow r) -> r) <$> query_ conn (Query ("SELECT " <> columns <> " FROM inserted_values_" <> processId))\n           releaseSavepoint\n           return x\n\ninstance Beam.BeamHasInsertOnConflict Sqlite where\n  newtype SqlConflictTarget Sqlite table = SqliteConflictTarget\n    { unSqliteConflictTarget :: table (QExpr Sqlite QInternal) -> SqliteSyntax }\n  newtype SqlConflictAction Sqlite table = SqliteConflictAction\n    { unSqliteConflictAction :: forall s. table (QField s) -> SqliteSyntax }\n\n  insertOnConflict\n    :: forall db table s. Beamable table\n    => DatabaseEntity Sqlite db (TableEntity table)\n    -> SqlInsertValues Sqlite (table (QExpr Sqlite s))\n    -> Beam.SqlConflictTarget Sqlite table\n    -> Beam.SqlConflictAction Sqlite table\n    -> SqlInsert Sqlite table\n  insertOnConflict (DatabaseEntity dt) values target action = case values of\n    SqlInsertValuesEmpty -> SqlInsertNoRows\n    SqlInsertValues vs -> SqlInsert (dbTableSettings dt) $\n      let getFieldName\n            :: forall a\n            .  Columnar\' (TableField table) a\n            -> Columnar\' (QField QInternal) a\n          getFieldName (Columnar\' fd) =\n            Columnar\' $ QField False (dbTableCurrentName dt) $ _fieldName fd\n          tableFields = changeBeamRep getFieldName $ dbTableSettings dt\n          tellFieldName _ _ f = tell [f] >> pure f\n          fieldNames = execWriter $\n            project\' (Proxy @AnyType) (Proxy @((), T.Text)) tellFieldName tableFields\n          currentField\n            :: forall a\n            .  Columnar\' (QField QInternal) a\n            -> Columnar\' (QExpr Sqlite QInternal) a\n          currentField (Columnar\' f) = Columnar\' $ current_ f\n          tableCurrent = changeBeamRep currentField tableFields\n      in SqliteInsertSyntax (tableNameFromEntity dt) fieldNames vs $ Just $\n           SqliteOnConflictSyntax $ mconcat\n             [ emit "ON CONFLICT "\n             , unSqliteConflictTarget target tableCurrent\n             , emit " DO "\n             , unSqliteConflictAction action tableFields\n             ]\n\n  anyConflict = SqliteConflictTarget $ const mempty\n  conflictingFields makeProjection = SqliteConflictTarget $ \\table ->\n    parens $ commas $ map fromSqliteExpression $\n      project (Proxy @Sqlite) (makeProjection table) "t"\n  conflictingFieldsWhere makeProjection makeWhere =\n    SqliteConflictTarget $ \\table -> mconcat\n      [ unSqliteConflictTarget (Beam.conflictingFields makeProjection) table\n      , emit " WHERE "\n      , let QExpr mkE = makeWhere table\n        in fromSqliteExpression $ mkE "t"\n      ]\n\n  onConflictDoNothing = SqliteConflictAction $ const $ emit "NOTHING"\n  onConflictUpdateSet makeAssignments = SqliteConflictAction $ \\table -> mconcat\n    [ emit "UPDATE SET "\n    , let QAssignment assignments = makeAssignments table $ excluded table\n          emitAssignment (fieldName, expr) = mconcat\n            [ fromSqliteFieldNameSyntax fieldName\n            , emit " = "\n            , fromSqliteExpression expr\n            ]\n      in commas $ map emitAssignment assignments\n    ]\n  onConflictUpdateSetWhere makeAssignments makeWhere =\n    SqliteConflictAction $ \\table -> mconcat\n      [ unSqliteConflictAction (Beam.onConflictUpdateSet makeAssignments) table\n      , emit " WHERE "\n      , let QExpr mkE = makeWhere table $ excluded table\n        in fromSqliteExpression $ mkE "t"\n      ]\n\nexcluded\n  :: forall table s\n  .  Beamable table\n  => table (QField s)\n  -> table (QExpr Sqlite s)\nexcluded table = changeBeamRep excludedField table\n  where excludedField (Columnar\' (QField _ _ name)) =\n          Columnar\' $ QExpr $ const $ fieldE $ qualifiedField "excluded" name\n'