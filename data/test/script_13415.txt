b"package effectivejava.chapter11.item81;\nimport java.util.concurrent.*;\n\n// Simple framework for timing concurrent execution 327\npublic class ConcurrentTimer {\n    private ConcurrentTimer() { } // Noninstantiable\n\n    public static long time(Executor executor, int concurrency,\n                            Runnable action) throws InterruptedException {\n        CountDownLatch ready = new CountDownLatch(concurrency);\n        CountDownLatch start = new CountDownLatch(1);\n        CountDownLatch done  = new CountDownLatch(concurrency);\n\n        for (int i = 0; i < concurrency; i++) {\n            executor.execute(() -> {\n                ready.countDown(); // Tell timer we're ready\n                try {\n                    start.await(); // Wait till peers are ready\n                    action.run();\n                } catch (InterruptedException e) {\n                    Thread.currentThread().interrupt();\n                } finally {\n                    done.countDown();  // Tell timer we're done\n                }\n            });\n        }\n\n        ready.await();     // Wait for all workers to be ready\n        long startNanos = System.nanoTime();\n        start.countDown(); // And they're off!\n        done.await();      // Wait for all workers to finish\n        return System.nanoTime() - startNanos;\n    }\n}\n"