b'#include <dirent.h>\n#include <unistd.h>\n#include <dlfcn.h>\n#include <sys/mman.h>\n#include <android_prop.h>\n#include <memory>\n#include "buff_string.h"\n#include <rirud.h>\n#include "module.h"\n#include "logging.h"\n#include "config.h"\n#include "hide_utils.h"\n#include "magisk.h"\n#include "dl.h"\n\nusing namespace std::string_literals;\nusing namespace std::string_view_literals;\n\nconstexpr uint8_t is64bit = sizeof(void *) == 8;\n\nstd::list<RiruModule> &modules::Get() {\n    static std::list<RiruModule> kModules;\n    return kModules;\n}\n\nstatic void Cleanup(void *handle) {\n    if (dlclose(handle) != 0) {\n        LOGE("dlclose failed: %s", dlerror());\n        return;\n    }\n}\n\nstatic void LoadModule(std::string_view id, std::string_view path, std::string_view magisk_module_path) {\n    if (access(path.data(), F_OK) != 0) {\n        PLOGE("access %s", path.data());\n        return;\n    }\n\n    auto *handle = DlopenExt(path.data(), 0);\n    if (!handle) {\n        LOGE("dlopen %s failed: %s", path.data(), dlerror());\n        return;\n    }\n\n    auto init = reinterpret_cast<RiruInit_t *>(dlsym(handle, "init"));\n    if (!init) {\n        LOGW("%s does not export init", path.data());\n        Cleanup(handle);\n        return;\n    }\n\n    auto allow_unload = std::make_unique<int>();\n    auto riru = std::make_unique<Riru>(Riru{\n            .riruApiVersion = riru::apiVersion,\n            .unused = nullptr,\n            .magiskModulePath = magisk_module_path.data(),\n            .allowUnload = allow_unload.get()\n    });\n\n    auto *module_info = init(riru.get());\n    if (module_info == nullptr) {\n        LOGE("%s requires higher Riru version (or its broken)", path.data());\n        Cleanup(handle);\n        return;\n    }\n\n    auto api_version = module_info->moduleApiVersion;\n    if (api_version < riru::minApiVersion || api_version > riru::apiVersion) {\n        LOGW("unsupported API %s: %d", id.data(), api_version);\n        Cleanup(handle);\n        return;\n    }\n\n    LOGI("module loaded: %s (api %d)", id.data(), api_version);\n\n    modules::Get().emplace_back(id, path, magisk_module_path, api_version, module_info->moduleInfo,\n                                handle,\n                                std::move(allow_unload));\n}\n\nstatic void WriteModules(const RirudSocket &rirud) {\n    auto &modules = modules::Get();\n    uint32_t count = modules.size();\n    if (!rirud.Write(RirudSocket::Action::WRITE_STATUS) || !rirud.Write(is64bit) ||\n        !rirud.Write(count)) {\n        PLOGE("write %s", SOCKET_ADDRESS);\n        return;\n    }\n\n    for (const auto &module : modules) {\n        rirud.Write(module.id);\n        rirud.Write<int32_t>(module.apiVersion);\n        rirud.Write<int32_t>(module.version);\n        rirud.Write(module.versionName);\n        rirud.Write<int8_t>(module.supportHide);\n    }\n}\n\nvoid modules::Load(const RirudSocket &rirud) {\n    uint32_t num_modules;\n    auto &modules = modules::Get();\n    if (!rirud.Write(RirudSocket::Action::READ_MODULES) ||\n        !rirud.Write(is64bit) || !rirud.Read(num_modules)) {\n        LOGE("Faild to load modules");\n        return;\n    }\n    std::string magisk_module_path;\n    std::string path;\n    std::string id;\n    uint32_t num_libs;\n    while (num_modules-- > 0) {\n        if (!rirud.Read(magisk_module_path) || !rirud.Read(num_libs)) {\n            LOGE("Faild to read module\'s magisk path");\n            return;\n        }\n        while (num_libs-- > 0) {\n            if (!rirud.Read(id) || !rirud.Read(path)) {\n                LOGE("Faild to read module\'s lib path");\n                return;\n            }\n            LoadModule(id, path, magisk_module_path);\n        }\n    }\n\n    // On Android 10+, zygote has "execmem" permission, we can use "riru hide" here\n    if (android_prop::GetApiLevel() >= __ANDROID_API_Q__) {\n        hide::HideFromMaps();\n    }\n\n    for (const auto &module : modules::Get()) {\n        if (module.hasOnModuleLoaded()) {\n            LOGV("%s: onModuleLoaded", module.id.data());\n            module.onModuleLoaded();\n        }\n    }\n\n    WriteModules(rirud);\n}\n'