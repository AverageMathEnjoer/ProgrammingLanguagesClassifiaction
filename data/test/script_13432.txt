b'{-# OPTIONS_GHC -fno-warn-orphans #-}\n\n{-# LANGUAGE LambdaCase #-}\n{-# LANGUAGE UndecidableInstances #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE TypeApplications #-}\n{-# LANGUAGE TypeFamilies #-}\n{-# LANGUAGE OverloadedStrings #-}\n{-# LANGUAGE PolyKinds #-}\n\nmodule Database.Beam.Postgres.Types\n  ( Postgres(..)\n  , fromPgIntegral\n  , fromPgScientificOrIntegral\n  ) where\n\nimport           Database.Beam\nimport           Database.Beam.Backend\nimport           Database.Beam.Backend.Internal.Compat\nimport           Database.Beam.Migrate.Generics\nimport           Database.Beam.Migrate.SQL (BeamMigrateOnlySqlBackend)\nimport           Database.Beam.Postgres.Syntax\nimport           Database.Beam.Query.SQL92\n\nimport qualified Database.PostgreSQL.Simple.FromField as Pg\nimport qualified Database.PostgreSQL.Simple.HStore as Pg (HStoreMap, HStoreList)\nimport qualified Database.PostgreSQL.Simple.Types as Pg\nimport qualified Database.PostgreSQL.Simple.Range as Pg (PGRange)\nimport qualified Database.PostgreSQL.Simple.Time as Pg (Date, UTCTimestamp, ZonedTimestamp, LocalTimestamp)\n\nimport           Data.Aeson (Value)\nimport           Data.ByteString (ByteString)\nimport qualified Data.ByteString.Lazy as BL\nimport           Data.CaseInsensitive (CI)\nimport           Data.Int\nimport           Data.Proxy\nimport           Data.Ratio (Ratio)\nimport           Data.Scientific (Scientific, toBoundedInteger)\nimport           Data.Tagged\nimport           Data.Text (Text)\nimport qualified Data.Text.Lazy as TL\nimport           Data.Time (UTCTime, Day, TimeOfDay, LocalTime, NominalDiffTime, ZonedTime(..))\nimport           Data.UUID.Types (UUID)\nimport           Data.Vector (Vector)\nimport           Data.Word\nimport           GHC.TypeLits\n\n-- | The Postgres backend type, used to parameterize \'MonadBeam\'. See the\n-- definitions there for more information. The corresponding query monad is\n-- \'Pg\'. See documentation for \'MonadBeam\' and the\n-- <https://haskell-beam.github/beam/ user guide> for more information on using\n-- this backend.\ndata Postgres\n  = Postgres\n\ninstance BeamBackend Postgres where\n  type BackendFromField Postgres = Pg.FromField\n\ninstance HasSqlInTable Postgres where\n\ninstance Pg.FromField SqlNull where\n  fromField field d = fmap (\\Pg.Null -> SqlNull) (Pg.fromField field d)\n\n-- | Deserialize integral fields, possibly downcasting from a larger numeric type\n-- via \'Scientific\' if we won\'t lose data, and then falling back to any integral\n-- type via \'Integer\'\nfromPgScientificOrIntegral :: (Bounded a, Integral a) => FromBackendRowM Postgres a\nfromPgScientificOrIntegral = do\n  sciVal <- fmap (toBoundedInteger =<<) peekField\n  case sciVal of\n    Just sciVal\' -> do\n      pure sciVal\'\n    Nothing -> fromIntegral <$> fromBackendRow @Postgres @Integer\n\n-- | Deserialize integral fields, possibly downcasting from a larger integral\n-- type, but only if we won\'t lose data\nfromPgIntegral :: forall a\n                . (Pg.FromField a, Integral a, Typeable a)\n               => FromBackendRowM Postgres a\nfromPgIntegral = do\n  val <- peekField\n  case val of\n    Just val\' -> do\n      pure val\'\n    Nothing -> do\n      val\' <- parseOneField @Postgres @Integer\n      let val\'\' = fromIntegral val\'\n      if fromIntegral val\'\' == val\'\n        then pure val\'\'\n        else fail (concat [ "Data loss while downsizing Integral type. "\n                          , "Make sure your Haskell types are wide enough for your data" ])\n\n-- Default FromBackendRow instances for all postgresql-simple FromField instances\ninstance FromBackendRow Postgres SqlNull\ninstance FromBackendRow Postgres Bool\ninstance FromBackendRow Postgres Char\ninstance FromBackendRow Postgres Double\ninstance FromBackendRow Postgres Int16 where\n  fromBackendRow = fromPgIntegral\ninstance FromBackendRow Postgres Int32 where\n  fromBackendRow = fromPgIntegral\ninstance FromBackendRow Postgres Int64 where\n  fromBackendRow = fromPgIntegral\n\ninstance TypeError (PreferExplicitSize Int Int32) => FromBackendRow Postgres Int where\n  fromBackendRow = fromPgIntegral\n\n-- Word values are serialized as SQL @NUMBER@ types to guarantee full domain coverage.\n-- However, we want them te be serialized/deserialized as whichever type makes sense\ninstance FromBackendRow Postgres Word16 where\n  fromBackendRow = fromPgScientificOrIntegral\ninstance FromBackendRow Postgres Word32 where\n  fromBackendRow = fromPgScientificOrIntegral\ninstance FromBackendRow Postgres Word64 where\n  fromBackendRow = fromPgScientificOrIntegral\n\ninstance TypeError (PreferExplicitSize Word Word32) => FromBackendRow Postgres Word where\n  fromBackendRow = fromPgScientificOrIntegral\n\ninstance FromBackendRow Postgres Integer\ninstance FromBackendRow Postgres ByteString\ninstance FromBackendRow Postgres Scientific\ninstance FromBackendRow Postgres BL.ByteString\ninstance FromBackendRow Postgres Text\ninstance FromBackendRow Postgres UTCTime\ninstance FromBackendRow Postgres Value\ninstance FromBackendRow Postgres TL.Text\ninstance FromBackendRow Postgres Pg.Oid\ninstance FromBackendRow Postgres LocalTime where\n  fromBackendRow =\n    peekField >>=\n    \\case\n      Just (x :: LocalTime) -> pure x\n\n      -- Also accept \'TIMESTAMP WITH TIME ZONE\'. Considered as\n      -- \'LocalTime\', because postgres always returns times in the\n      -- server timezone, regardless of type.\n      Nothing ->\n        peekField >>=\n        \\case\n          Just (x :: ZonedTime) -> pure (zonedTimeToLocalTime x)\n          Nothing -> fail "\'TIMESTAMP WITH TIME ZONE\' or \'TIMESTAMP WITHOUT TIME ZONE\' required for LocalTime"\ninstance FromBackendRow Postgres TimeOfDay\ninstance FromBackendRow Postgres Day\ninstance FromBackendRow Postgres UUID\ninstance FromBackendRow Postgres Pg.Null\ninstance FromBackendRow Postgres Pg.Date\ninstance FromBackendRow Postgres Pg.ZonedTimestamp\ninstance FromBackendRow Postgres Pg.UTCTimestamp\ninstance FromBackendRow Postgres Pg.LocalTimestamp\ninstance FromBackendRow Postgres Pg.HStoreMap\ninstance FromBackendRow Postgres Pg.HStoreList\ninstance FromBackendRow Postgres [Char]\ninstance FromBackendRow Postgres (Ratio Integer)\ninstance FromBackendRow Postgres (CI Text)\ninstance FromBackendRow Postgres (CI TL.Text)\ninstance (Pg.FromField a, Typeable a) => FromBackendRow Postgres (Vector a) where\n  fromBackendRow = do\n      isNull <- peekField\n      case isNull of\n        Just SqlNull -> pure mempty\n        Nothing -> parseOneField @Postgres @(Vector a)\ninstance (Pg.FromField a, Typeable a) => FromBackendRow Postgres (Pg.PGArray a)\ninstance FromBackendRow Postgres (Pg.Binary ByteString)\ninstance FromBackendRow Postgres (Pg.Binary BL.ByteString)\ninstance (Pg.FromField a, Typeable a) => FromBackendRow Postgres (Pg.PGRange a)\ninstance (Pg.FromField a, Pg.FromField b, Typeable a, Typeable b) => FromBackendRow Postgres (Either a b)\n\ninstance BeamSqlBackend Postgres\ninstance BeamMigrateOnlySqlBackend Postgres\ntype instance BeamSqlBackendSyntax Postgres = PgCommandSyntax\n\ninstance BeamSqlBackendIsString Postgres String\ninstance BeamSqlBackendIsString Postgres Text\n\ninstance HasQBuilder Postgres where\n  buildSqlQuery = buildSql92Query\' True\n\n-- * Instances for \'HasDefaultSqlDataType\'\n\ninstance HasDefaultSqlDataType Postgres ByteString where\n  defaultSqlDataType _ _ _ = pgByteaType\n\ninstance HasDefaultSqlDataType Postgres LocalTime where\n  defaultSqlDataType _ _ _ = timestampType Nothing False\n\ninstance HasDefaultSqlDataType Postgres UTCTime where\n  defaultSqlDataType _ _ _ = timestampType Nothing True\n\ninstance HasDefaultSqlDataType Postgres (SqlSerial Int16) where\n  defaultSqlDataType _ _ False = pgSmallSerialType\n  defaultSqlDataType _ _ _ = smallIntType\n\ninstance HasDefaultSqlDataType Postgres (SqlSerial Int32) where\n  defaultSqlDataType _ _ False = pgSerialType\n  defaultSqlDataType _ _ _ = intType\n\ninstance HasDefaultSqlDataType Postgres (SqlSerial Int64) where\n  defaultSqlDataType _ _ False = pgBigSerialType\n  defaultSqlDataType _ _ _ = bigIntType\n\ninstance TypeError (PreferExplicitSize Int Int32) => HasDefaultSqlDataType Postgres (SqlSerial Int) where\n  defaultSqlDataType _ = defaultSqlDataType (Proxy @(SqlSerial Int32))\n\ninstance HasDefaultSqlDataType Postgres UUID where\n  defaultSqlDataType _ _ _ = pgUuidType\n\n-- * Instances for \'HasSqlEqualityCheck\'\n\n#define PG_HAS_EQUALITY_CHECK(ty)                                 \\\n  instance HasSqlEqualityCheck Postgres (ty);           \\\n  instance HasSqlQuantifiedEqualityCheck Postgres (ty);\n\nPG_HAS_EQUALITY_CHECK(Bool)\nPG_HAS_EQUALITY_CHECK(Double)\nPG_HAS_EQUALITY_CHECK(Float)\nPG_HAS_EQUALITY_CHECK(Int8)\nPG_HAS_EQUALITY_CHECK(Int16)\nPG_HAS_EQUALITY_CHECK(Int32)\nPG_HAS_EQUALITY_CHECK(Int64)\nPG_HAS_EQUALITY_CHECK(Integer)\nPG_HAS_EQUALITY_CHECK(Word8)\nPG_HAS_EQUALITY_CHECK(Word16)\nPG_HAS_EQUALITY_CHECK(Word32)\nPG_HAS_EQUALITY_CHECK(Word64)\nPG_HAS_EQUALITY_CHECK(Text)\nPG_HAS_EQUALITY_CHECK(TL.Text)\nPG_HAS_EQUALITY_CHECK(UTCTime)\nPG_HAS_EQUALITY_CHECK(Value)\nPG_HAS_EQUALITY_CHECK(Pg.Oid)\nPG_HAS_EQUALITY_CHECK(LocalTime)\nPG_HAS_EQUALITY_CHECK(ZonedTime)\nPG_HAS_EQUALITY_CHECK(TimeOfDay)\nPG_HAS_EQUALITY_CHECK(NominalDiffTime)\nPG_HAS_EQUALITY_CHECK(Day)\nPG_HAS_EQUALITY_CHECK(UUID)\nPG_HAS_EQUALITY_CHECK([Char])\nPG_HAS_EQUALITY_CHECK(Pg.HStoreMap)\nPG_HAS_EQUALITY_CHECK(Pg.HStoreList)\nPG_HAS_EQUALITY_CHECK(Pg.Date)\nPG_HAS_EQUALITY_CHECK(Pg.ZonedTimestamp)\nPG_HAS_EQUALITY_CHECK(Pg.LocalTimestamp)\nPG_HAS_EQUALITY_CHECK(Pg.UTCTimestamp)\nPG_HAS_EQUALITY_CHECK(Scientific)\nPG_HAS_EQUALITY_CHECK(ByteString)\nPG_HAS_EQUALITY_CHECK(BL.ByteString)\nPG_HAS_EQUALITY_CHECK(Vector a)\nPG_HAS_EQUALITY_CHECK(CI Text)\nPG_HAS_EQUALITY_CHECK(CI TL.Text)\n\ninstance TypeError (PreferExplicitSize Int Int32) => HasSqlEqualityCheck Postgres Int\ninstance TypeError (PreferExplicitSize Int Int32) => HasSqlQuantifiedEqualityCheck Postgres Int\ninstance TypeError (PreferExplicitSize Word Word32) => HasSqlEqualityCheck Postgres Word\ninstance TypeError (PreferExplicitSize Word Word32) => HasSqlQuantifiedEqualityCheck Postgres Word\n\ninstance HasSqlEqualityCheck Postgres a =>\n  HasSqlEqualityCheck Postgres (Tagged t a)\ninstance HasSqlQuantifiedEqualityCheck Postgres a =>\n  HasSqlQuantifiedEqualityCheck Postgres (Tagged t a)\n'