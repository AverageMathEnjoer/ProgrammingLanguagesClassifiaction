b'type Expression = [Term]\ntype Term = [Factor] \ntype Factor = [Digit] \ntype Digit = Int\n\ndigits :: Factor\ndigits = [1 .. 9]\n\nvalExpr :: Expression -> Int \nvalExpr = sum . map valTerm\n\nvalTerm :: Term -> Int\nvalTerm = product . map valFact \n\nvalFact :: Factor -> Int\nvalFact = foldl1 (\\n d -> 10 * n + d)\n\nexpressions :: [Digit] -> [Expression] \nexpressions = foldr extend [ ]\n\nextend :: Digit -> [Expression] -> [Expression] \nextend x [] = [[[[x]]]]\nextend x es = concatMap (glue x) es\n\nglue :: Digit -> Expression -> [Expression] \nglue x ((xs:xss):xsss) = [((x:xs):xss):xsss,\n                          ([x] : xs : xss) : xsss, \n                          [[x]] : (xs : xss) : xsss]\n\ngood :: Int -> Bool\ngood v = v == 100\n\ngoodOnes :: [Digit] -> [Expression]\ngoodOnes = filter (good . valExpr) . expressions\n\n'