b'#include "stdafx.h"\n#include "ModInstallerEditor2.h"\n#include "resource.h"\n#include "../ModInstaller/InstallerDataFormat.h"\n#include "../ModInstaller/ModInstaller.h"\n#include "../AssetsTools/InternalAssetsReplacer.h"\n#include "../AssetsTools/InternalBundleReplacer.h"\n#include "../libStringConverter/convert.h"\n#include "FileDialog.h"\n#include <Shlwapi.h>\n#include <WindowsX.h>\n#include <algorithm>\n\nvoid Win32ModInstallerEditor::UpdateDisplayedRelPaths()\n{\n\tHWND hEditBaseFolder = GetDlgItem(hDlg, IDC_EBASEFOLDER);\n\tHWND hTreeChanges = GetDlgItem(hDlg, IDC_TREECHANGES);\n\tif (!hEditBaseFolder || !hTreeChanges)\n\t\treturn;\n\tsize_t baseDirLen = (size_t)Edit_GetTextLength(hEditBaseFolder);\n\tstd::vector<TCHAR> tBaseDir(baseDirLen + 1);\n\tEdit_GetText(hEditBaseFolder, tBaseDir.data(), (int)(baseDirLen + 1));\n\ttBaseDir[baseDirLen] = 0;\n\n\t//PathRelativePathTo https://msdn.microsoft.com/en-us/library/bb773740(VS.85).aspx\n\tfor (size_t i = 0; i < visibleFiles.size(); i++)\n\t{\n\t\tassert(visibleFiles[i].treeViewEntry != NULL);\n\t\tsize_t filePathLen = 0;\n\t\tauto tcFilePath = unique_MultiByteToTCHAR(visibleFiles[i].pathOrName.c_str(), filePathLen);\n\t\tsize_t newPathLen = baseDirLen + filePathLen + 1; if (newPathLen <= MAX_PATH) newPathLen = MAX_PATH + 1;\n\t\tstd::vector<TCHAR> newPath(newPathLen);\n\t\tif (!PathRelativePathTo(newPath.data(), tBaseDir.data(), FILE_ATTRIBUTE_DIRECTORY, tcFilePath.get(), FILE_ATTRIBUTE_NORMAL))\n\t\t\tmemcpy(newPath.data(), tcFilePath.get(), (filePathLen + 1) * sizeof(TCHAR));\n\t\t\t\t\t\t\t\n\t\tTVITEMEX itemex;\n\t\titemex.hItem = (HTREEITEM)visibleFiles[i].treeViewEntry;\n\t\titemex.mask = TVIF_HANDLE | TVIF_TEXT;\n\t\titemex.pszText = newPath.data();\n\t\titemex.cchTextMax = (int)_tcslen(newPath.data());\n\t\tTreeView_SetItem(hTreeChanges, &itemex);\n\t}\n}\nvoid Win32ModInstallerEditor::SelectAndLoadIcon()\n{\n\tstatic const GUID UABE_FILEDIALOG_ICON_GUID = { 0x6ac81505, 0xed13, 0xdca2, 0x14, 0xf5, 0x70, 0xf2, 0x14, 0xab, 0xf6, 0x73 };\n\tHWND hIIcon = GetDlgItem(hDlg, IDC_IICON);\n\tif (!hIIcon)\n\t\treturn;\n\tWCHAR *pakPath = NULL;\n\tif (SUCCEEDED(ShowFileOpenDialog(hDlg, &pakPath, L"*.ico|Icon file:",\n\t\tnullptr, nullptr, nullptr, UABE_FILEDIALOG_ICON_GUID)))\n\t{\n\t\tIAssetsReader *pFileReader = Create_AssetsReaderFromFile(pakPath, true, RWOpenFlags_Immediately);\n\t\tif (pFileReader)\n\t\t{\n\t\t\tpFileReader->Seek(AssetsSeek_End, 0);\n\t\t\tQWORD _size = 0;\n\t\t\tpFileReader->Tell(_size);\n\t\t\tsize_t size = (size_t)_size;\n\t\t\tpFileReader->Seek(AssetsSeek_Begin, 0);\n\t\t\tstd::vector<uint8_t> fileData(size, 0);\n\t\t\tpFileReader->Read(size, fileData.data());\n\t\t\tFree_AssetsReader(pFileReader);\n\n\t\t\tHICON hIcon = (HICON)LoadImage(NULL, pakPath, IMAGE_ICON, 32, 32, LR_LOADFROMFILE);\n\t\t\tFreeCOMFilePathBuf(&pakPath);\n\t\t\tif (hIcon)\n\t\t\t{\n\t\t\t\tHICON hOldIcon = (HICON)SendMessage(hIIcon, STM_GETIMAGE, IMAGE_ICON, NULL);\n\t\t\t\tSendMessage(hIIcon, STM_SETIMAGE, IMAGE_ICON, (LPARAM)hIcon);\n\t\t\t\tif (hOldIcon)\n\t\t\t\t\tDestroyIcon(hOldIcon);\n\t\t\t\tthis->iconData.swap(fileData);\n\t\t\t}\n\t\t}\n\t\tFreeCOMFilePathBuf(&pakPath);\n\t}\n}\n\nvoid Win32ModInstallerEditor::SelectAndImportPackage()\n{\n\tHWND hTreeChanges = GetDlgItem(hDlg, IDC_TREECHANGES);\n\tHWND hEModName = GetDlgItem(hDlg, IDC_EMODNAME);\n\tHWND hEAuthors = GetDlgItem(hDlg, IDC_EAUTHORS);\n\tHWND hEDescription = GetDlgItem(hDlg, IDC_EDESCRIPTION);\n\tif (!hTreeChanges || !hEModName || !hEAuthors || !hEDescription)\n\t\treturn;\n\tWCHAR *pakPath = NULL;\n\tif (FAILED(ShowFileOpenDialog(hDlg, &pakPath, L"*.emip|UABE Mod Installer Package:*.exe|UABE Installer:",\n\t\tnullptr, nullptr, nullptr, UABE_FILEDIALOG_FILE_GUID)))\n\t\treturn;\n\tstd::shared_ptr<IAssetsReader> pReader(Create_AssetsReaderFromFile(pakPath, true, RWOpenFlags_Immediately), Free_AssetsReader);\n\tFreeCOMFilePathBuf(&pakPath);\n\tif (!pReader)\n\t\treturn;\n\tInstallerPackageFile loadedPackage = InstallerPackageFile();\n\tQWORD readPos = 0;\n\tbool success = loadedPackage.Read(readPos, pReader);\n\tif (!success)\n\t{\n\t\tsize_t overlayOffset = GetPEOverlayOffset(pReader.get());\n\t\tif (overlayOffset != 0)\n\t\t{\n\t\t\treadPos = overlayOffset;\n\t\t\tsuccess = loadedPackage.Read(readPos, pReader);\n\t\t}\n\t}\n\tif (!success)\n\t{\n\t\tMessageBox(appContext.getMainWindow().getWindow(), TEXT("Unable to understand the package file!\\n")\\\n\t\t\tTEXT("Make sure the selected file actually is a valid package file."), TEXT("ERROR"), 16);\n\t\treturn;\n\t}\n\tWCHAR *newBasePath = NULL;\n\tif (ShowFolderSelectDialog(hDlg, &newBasePath, L"Select the base path", UABE_FILEDIALOG_FILE_GUID))\n\t{\n\t\tsize_t wBasePathLen = wcslen(newBasePath);\n\t\tInstallerPackageAssetsDesc tempDesc;\n\t\tfor (size_t i = 0; i < loadedPackage.affectedAssets.size(); i++)\n\t\t{\n\t\t\tsize_t wPathLen = 0;\n\t\t\tWCHAR *wPath = _MultiByteToWide(loadedPackage.affectedAssets[i].path.c_str(), wPathLen);\n\t\t\tstd::vector<WCHAR> combinedPathBuf(std::max<size_t>(wBasePathLen + wPathLen + 16, MAX_PATH));\n\t\t\tbool changePath = PathCombine(combinedPathBuf.data(), newBasePath, wPath) != NULL;\n\t\t\t_FreeWCHAR(wPath);\n\t\t\tif (changePath)\n\t\t\t{\n\t\t\t\ttempDesc.type = loadedPackage.affectedAssets[i].type;\n\t\t\t\ttempDesc.replacers.assign(loadedPackage.affectedAssets[i].replacers.begin(), \n\t\t\t\t\tloadedPackage.affectedAssets[i].replacers.end());\n\t\t\t\tsize_t mbCombinedPathLen = 0;\n\t\t\t\ttempDesc.path = _WideToMultiByte(combinedPathBuf.data(), mbCombinedPathLen);\n\t\t\t\tloadedPackage.affectedAssets[i] = tempDesc;\n\t\t\t}\n\t\t}\n\t\tFreeCOMFilePathBuf(&newBasePath);\n\t}\n\tif (Edit_GetTextLength(hEModName) == 0)\n\t{\n\t\tauto tcTemp = unique_MultiByteToTCHAR(loadedPackage.modName.c_str());\n\t\tEdit_SetText(hEModName, tcTemp.get());\n\t}\n\tif (Edit_GetTextLength(hEAuthors) == 0)\n\t{\n\t\tauto tcTemp = unique_MultiByteToTCHAR(loadedPackage.modCreators.c_str());\n\t\tEdit_SetText(hEAuthors, tcTemp.get());\n\t}\n\tif (Edit_GetTextLength(hEDescription) == 0)\n\t{\n\t\tauto tcTemp = unique_MultiByteToTCHAR(loadedPackage.modDescription.c_str());\n\t\tEdit_SetText(hEDescription, tcTemp.get());\n\t}\n\t\n\tMergeInstallerData(loadedPackage);\n\tUpdateModsTree();\n\t//UpdateDisplayedRelPaths();\n}\n\n\nvoid Win32ModInstallerEditor::MergeInstallerData(InstallerPackageFile &newFile)\n{\n\t//Note: Is O(n\xb2), but should be fine since the amount of types n is relatively small.\n\tfor (size_t i = 0; i < newFile.addedTypes.classes.size(); i++)\n\t{\n\t\tbool alreadyExists = false;\n\t\tfor (size_t k = 0; k < typesToExport.classes.size(); k++)\n\t\t{\n\t\t\tif (newFile.addedTypes.classes[i].classId == typesToExport.classes[k].classId)\n\t\t\t{\n\t\t\t\talreadyExists = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!alreadyExists)\n\t\t{\n\t\t\ttypesToExport.InsertFrom(&newFile.addedTypes, &newFile.addedTypes.classes[i]);\n\t\t}\n\t}\n\tif (!newFile.affectedAssets.empty())\n\t\tthis->changedFlag = true;\n\tfor (size_t i = newFile.affectedAssets.size(); i > 0; i--)\n\t{\n\t\tInstallerPackageAssetsDesc &newDesc = newFile.affectedAssets[i-1];\n\t\tVisibleFileEntry newEntry(this->appContext, newDesc);\n\t\tbool merged = false;\n\t\tfor (size_t k = visibleFiles.size(); k > 0; k--)\n\t\t{\n\t\t\tVisibleFileEntry &existingEntry = visibleFiles[k-1];\n\t\t\t//TODO: Use C++17 std::filesystem::equivalent instead of string comparison.\n\t\t\tif (newEntry.fileType == existingEntry.fileType && !newEntry.pathNull && newEntry.pathOrName == existingEntry.pathOrName)\n\t\t\t{\n\t\t\t\tauto resolveConflict = [&newEntry, this](VisibleReplacerEntry& existing, const VisibleReplacerEntry& other)\n\t\t\t\t{\n\t\t\t\t\tstd::string message;\n\t\t\t\t\tif (dynamic_cast<BundleEntryModifierByResources*>(existing.pReplacer.get()) != nullptr)\n\t\t\t\t\t{\n\t\t\t\t\t\tauto* pExistingReplacer = reinterpret_cast<BundleEntryModifierByResources*>(existing.pReplacer.get());\n\t\t\t\t\t\tassert(dynamic_cast<const BundleEntryModifierByResources*>(other.pReplacer.get()) != nullptr);\n\t\t\t\t\t\tmessage = "There\'s a conflict between the resource replacers for " + newEntry.pathOrName +\n\t\t\t\t\t\t\t".\\nShould the new replacer be used and the old one be removed?";\n\t\t\t\t\t}\n\t\t\t\t\telse if (dynamic_cast<BundleReplacer*>(existing.pReplacer.get()) != nullptr)\n\t\t\t\t\t{\n\t\t\t\t\t\tBundleReplacer* pExistingReplacer = reinterpret_cast<BundleReplacer*>(existing.pReplacer.get());\n\t\t\t\t\t\tconst char* name = pExistingReplacer->GetOriginalEntryName();\n\t\t\t\t\t\tif (name == nullptr) name = pExistingReplacer->GetEntryName();\n\t\t\t\t\t\tif (name == nullptr) name = "";\n\t\t\t\t\t\tassert(dynamic_cast<const BundleReplacer*>(other.pReplacer.get()) != nullptr);\n\t\t\t\t\t\tmessage = "There\'s a conflict between the bundle entry replacers for " + newEntry.pathOrName +\n\t\t\t\t\t\t\t"/<...>/" + name + ".\\nShould the new replacer be used and the old one be removed?";\n\t\t\t\t\t}\n\t\t\t\t\telse if (dynamic_cast<AssetsEntryReplacer*>(existing.pReplacer.get()) != nullptr)\n\t\t\t\t\t{\n\t\t\t\t\t\tassert(dynamic_cast<const AssetsEntryReplacer*>(other.pReplacer.get()) != nullptr);\n\t\t\t\t\t\tassert(reinterpret_cast<AssetsEntryReplacer*>(existing.pReplacer.get())->GetPathID()\n\t\t\t\t\t\t\t== reinterpret_cast<const AssetsEntryReplacer*>(other.pReplacer.get())->GetPathID());\n\t\t\t\t\t\tmessage = "There\'s a conflict between the asset replacers for " + newEntry.pathOrName\n\t\t\t\t\t\t\t+ "/<...>/Path ID "\n\t\t\t\t\t\t\t+ std::to_string((int64_t)reinterpret_cast<AssetsEntryReplacer*>(existing.pReplacer.get())->GetPathID())\n\t\t\t\t\t\t\t+ ".\\nShould the new replacer be used and the old one be removed?";\n\t\t\t\t\t}\n\t\t\t\t\telse if (dynamic_cast<AssetsDependenciesReplacer*>(existing.pReplacer.get()) != nullptr)\n\t\t\t\t\t{\n\t\t\t\t\t\tassert(dynamic_cast<const AssetsDependenciesReplacer*>(other.pReplacer.get()) != nullptr);\n\t\t\t\t\t\tmessage = "There\'s a conflict between the dependency replacers for " + newEntry.pathOrName\n\t\t\t\t\t\t\t+ ".\\nShould the new replacer be used and the old one be removed?";\n\t\t\t\t\t}\n\t\t\t\t\telse if (dynamic_cast<AssetsReplacer*>(existing.pReplacer.get()) != nullptr)\n\t\t\t\t\t{\n\t\t\t\t\t\tassert(dynamic_cast<const AssetsReplacer*>(other.pReplacer.get()) != nullptr);\n\t\t\t\t\t\tmessage = "There\'s a conflict between the replacers for " + newEntry.pathOrName\n\t\t\t\t\t\t\t+ ".\\nShould the new replacer be used and the old one be removed?";\n\t\t\t\t\t}\n\t\t\t\t\tassert(!message.empty());\n\t\t\t\t\tif (message.empty())\n\t\t\t\t\t\treturn false;\n\t\t\t\t\tauto tMessage = unique_MultiByteToTCHAR(message.c_str());\n\t\t\t\t\tif (IDYES == MessageBox(hDlg, tMessage.get(), TEXT("Mod Installer Editor"), MB_YESNO))\n\t\t\t\t\t{\n\t\t\t\t\t\tHWND hTreeModifications = GetDlgItem(hDlg, IDC_TREECHANGES);\n\t\t\t\t\t\tif (existing.treeItem != NULL && hTreeModifications != NULL)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tTreeView_DeleteItem(hTreeModifications, existing.treeItem);\n\t\t\t\t\t\t}\n\t\t\t\t\t\texisting.treeItem = NULL;\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t\treturn false;\n\t\t\t\t};\n\t\t\t\texistingEntry.mergeWith(newEntry, resolveConflict);\n\t\t\t\tmerged = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!merged)\n\t\t{\n\t\t\tthis->visibleFiles.push_back(std::move(newEntry));\n\t\t}\n\t}\n}\n\nbool Win32ModInstallerEditor::removeChangesBy(VisibleFileEntry &file, HTREEITEM treeItem)\n{\n\tfor (size_t i = 0; i < file.replacers.size(); i++)\n\t{\n\t\tif ((HTREEITEM)file.replacers[i].treeItem == treeItem)\n\t\t{\n\t\t\t//Delete a single replacer.\n\t\t\tTreeView_DeleteItem(hTreeModifications, treeItem);\n\t\t\tfile.replacers.erase(file.replacers.begin() + i);\n\t\t\treturn true;\n\t\t}\n\t}\n\tfor (size_t i = 0; i < file.subFiles.size(); ++i)\n\t{\n\t\tif ((HTREEITEM)file.subFiles[i].treeViewEntry == treeItem)\n\t\t{\n\t\t\t//Delete all changes in a sub file.\n\t\t\tTreeView_DeleteItem(hTreeModifications, file.subFiles[i].treeViewEntry);\n\t\t\tfile.subFiles.erase(file.subFiles.begin() + i);\n\t\t\treturn true;\n\t\t}\n\t}\n\t//Try in deeper levels.\n\tfor (size_t i = 0; i < file.subFiles.size(); ++i)\n\t{\n\t\tif (file.subFiles[i].treeViewEntry != NULL && removeChangesBy(file.subFiles[i], treeItem))\n\t\t\treturn true;\n\t}\n\treturn false;\n}\nvoid Win32ModInstallerEditor::RemoveChange(HTREEITEM treeItem)\n{\n\tif (treeItem == NULL)\n\t\treturn;\n\tif (treeItem == bundleBaseEntry || treeItem == assetsBaseEntry || treeItem == resourcesBaseEntry)\n\t{\n\t\t//Delete all changes in bundles / assets.\n\t\tauto targetType = \n\t\t\t   (treeItem == bundleBaseEntry) ? FileContext_Bundle\n\t\t\t: ((treeItem == assetsBaseEntry) ? FileContext_Assets : FileContext_Resources);\n\t\tfor (size_t _i = this->visibleFiles.size(); _i > 0; --_i)\n\t\t{\n\t\t\tsize_t i = _i - 1;\n\t\t\tif (this->visibleFiles[i].fileType == targetType\n\t\t\t\t&& this->visibleFiles[i].treeViewEntry != NULL)\n\t\t\t{\n\t\t\t\tthis->changedFlag = true;\n\t\t\t\tTreeView_DeleteItem(hTreeModifications, this->visibleFiles[i].treeViewEntry);\n\t\t\t\tthis->visibleFiles.erase(this->visibleFiles.begin() + i);\n\t\t\t}\n\t\t}\n\t\treturn;\n\t}\n\tfor (size_t i = 0; i < this->visibleFiles.size(); ++i)\n\t{\n\t\t//Delete all changes in a base file.\n\t\tif ((HTREEITEM)this->visibleFiles[i].treeViewEntry == treeItem)\n\t\t{\n\t\t\tthis->changedFlag = true;\n\t\t\tTreeView_DeleteItem(hTreeModifications, this->visibleFiles[i].treeViewEntry);\n\t\t\tthis->visibleFiles.erase(this->visibleFiles.begin() + i);\n\t\t\treturn;\n\t\t}\n\t}\n\t//Look in all non-top levels (recursively).\n\tfor (size_t i = 0; i < this->visibleFiles.size(); ++i)\n\t{\n\t\tif (this->visibleFiles[i].treeViewEntry != NULL && removeChangesBy(this->visibleFiles[i], treeItem))\n\t\t{\n\t\t\tthis->changedFlag = true;\n\t\t\treturn;\n\t\t}\n\t}\n\t//Tree item was not found, even though we were passed a non-NULL handle.\n\tassert(false);\n}\n\n//ModInstaller.dll\n__declspec(dllimport) bool MakeInstaller(const TCHAR *installerDllPath, InstallerPackageFile *installerData, const TCHAR *outPath, const std::vector<uint8_t> &iconData);\n\nstatic bool GenerateInstaller(HWND hDlg, InstallerPackageFile &packageFile, const std::wstring &filePath,\n\tconst std::vector<uint8_t> &iconData)\n{\n\tHMODULE hModInstaller = GetModuleHandle(TEXT("ModInstaller.dll"));\n\tif (!hModInstaller)\n\t\tMessageBox(hDlg, TEXT("Unable to locate ModInstaller.dll!"), TEXT("ERROR"), 16);\n\telse\n\t{\n\t\tstd::vector<TCHAR> moduleFileNameBuf(257);\n\t\tSetLastError(ERROR_SUCCESS);\n\t\twhile (true)\n\t\t{\n\t\t\tmoduleFileNameBuf[moduleFileNameBuf.size() - 1] = 0;\n\t\t\tDWORD written = GetModuleFileName(hModInstaller, moduleFileNameBuf.data(), (DWORD)(moduleFileNameBuf.size() - 1));\n\t\t\t//How too small buffer sizes are indicated : \n\t\t\t//Win XP : wrote partial string without null-terminator\n\t\t\t//Win Vista+ : ERROR_INSUFFICIENT_BUFFER set\n\t\t\tif ((written > moduleFileNameBuf.size()) || \n\t\t\t\t(GetLastError() == ERROR_INSUFFICIENT_BUFFER) || moduleFileNameBuf[written] != 0)\n\t\t\t{\n\t\t\t\tmoduleFileNameBuf.resize(moduleFileNameBuf.size() + 1024);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tmoduleFileNameBuf.resize(written + 1);\n\t\t\t\tmoduleFileNameBuf[written] = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tbool result = MakeInstaller(&moduleFileNameBuf[0], &packageFile, filePath.c_str(), iconData);\n\t\treturn result;\n\t}\n\treturn false;\n}\n\nbool Win32ModInstallerEditor::SaveChanges()\n{\n\tInstallerPackageFile packageFile;\n\tpackageFile.addedTypes = this->typesToExport;\n\n\tHWND hEditModName = GetDlgItem(hDlg, IDC_EMODNAME);\n\tHWND hEditAuthors = GetDlgItem(hDlg, IDC_EAUTHORS);\n\tHWND hEditDescription = GetDlgItem(hDlg, IDC_EDESCRIPTION);\n\n\t{\n\t\tsize_t modNameLen = (size_t)Edit_GetTextLength(hEditModName);\n\t\tstd::vector<TCHAR> tModName(modNameLen + 1);\n\t\tEdit_GetText(hEditModName, tModName.data(), (int)(tModName.size()));\n\t\ttModName[modNameLen] = 0;\n\t\tauto mb = unique_TCHARToMultiByte(tModName.data());\n\t\tpackageFile.modName = mb.get();\n\t}\n\t{\n\t\tsize_t authorsLen = (size_t)Edit_GetTextLength(hEditAuthors);\n\t\tstd::vector<TCHAR> tAuthors(authorsLen + 1);\n\t\tEdit_GetText(hEditAuthors, tAuthors.data(), (int)(tAuthors.size()));\n\t\ttAuthors[authorsLen] = 0;\n\t\tauto mb = unique_TCHARToMultiByte(tAuthors.data());\n\t\tpackageFile.modCreators = mb.get();\n\t}\n\t{\n\t\tsize_t descriptionLen = (size_t)Edit_GetTextLength(hEditDescription);\n\t\tstd::vector<TCHAR> tDescriptions(descriptionLen + 1);\n\t\tEdit_GetText(hEditDescription, tDescriptions.data(), (int)(tDescriptions.size()));\n\t\ttDescriptions[descriptionLen] = 0;\n\t\tauto mb = unique_TCHARToMultiByte(tDescriptions.data());\n\t\tpackageFile.modDescription = mb.get();\n\t}\n\t//#ifdef __X64\n\t//if (this->saveType == ModDataSaveType_Installer)\n\t//{\n\t//\tDWORD result = MessageBox(\n\t//\t\thDlg, \n\t//\t\tTEXT("The installer will only be usable on 64bit systems. The 32bit release of UABE creates installers that work on both.\\n")\\\n\t//\t\tTEXT("Do you want to proceed? Press \\"No\\" to create an installer package that can be opened to create a 32bit installer."), \n\t//\t\tTEXT("Asset Bundle Extractor"), \n\t//\t\tMB_YESNOCANCEL);\n\t//\tswitch (result)\n\t//\t{\n\t//\tcase IDYES:\n\t//\t\tbreak;\n\t//\tcase IDNO:\n\t//\t\tthis->saveType = ModDataSaveType_PackageFile;\n\t//\t\tbreak;\n\t//\tcase IDCANCEL:\n\t//\tdefault:\n\t//\t\treturn false;\n\t//\t}\n\t//}\n\t//#endif\n\tWCHAR *filePathW = NULL;\n\tif (FAILED(ShowFileSaveDialog(hDlg, &filePathW, \n\t\t(this->saveType == ModDataSaveType_Installer) ? L"*.exe|Standalone Mod Installer:"\n\t\t: L"*.emip|UABE Mod Installer Package:",\n\t\tnullptr, nullptr, nullptr, UABE_FILEDIALOG_FILE_GUID)))\n\t\treturn false;\n\n\tstd::wstring filePath = std::wstring(filePathW);\n\tstd::wstring fileExtension = (this->saveType == ModDataSaveType_Installer) ? L".exe" : L".emip";\n\tif (filePath.size() >= fileExtension.size()\n\t\t&& 0==filePath.compare(filePath.size() - fileExtension.size(), fileExtension.size(), fileExtension))\n\t{}\n\telse\n\t\tfilePath += fileExtension;\n\tFreeCOMFilePathBuf(&filePathW);\n\n\tHWND hEditBaseFolder = GetDlgItem(hDlg, IDC_EBASEFOLDER);\n\tHWND hTreeChanges = GetDlgItem(hDlg, IDC_TREECHANGES);\n\tif (!hEditBaseFolder || !hTreeChanges)\n\t\treturn false;\n\tsize_t baseDirLen = (size_t)Edit_GetTextLength(hEditBaseFolder);\n\tpackageFile.affectedAssets.resize(this->visibleFiles.size());\n\tstd::vector<TCHAR> pathBuffer;\n\n\t//Fill in the relative paths.\n\tfor (size_t i = 0; i < this->visibleFiles.size(); i++)\n\t{\n\t\tassert(!this->visibleFiles[i].pathOrName.empty() && !this->visibleFiles[i].pathNull);\n\t\tassert(this->visibleFiles[i].treeViewEntry != NULL);\n\t\tif (this->visibleFiles[i].pathOrName.empty() || this->visibleFiles[i].pathNull || this->visibleFiles[i].treeViewEntry == NULL)\n\t\t\tcontinue;\n\t\tsize_t newPathLen = baseDirLen + this->visibleFiles[i].pathOrName.size() + 1;\n\t\tif (newPathLen <= MAX_PATH) newPathLen = MAX_PATH + 1;\n\t\t\t\n\t\t//Retrieve the relative paths from the TreeView.\n\t\tTVITEMEX itemex;\n\t\tdo {\n\t\t\tif (newPathLen >= INT_MAX-1) newPathLen = INT_MAX-2;\n\t\t\tif (pathBuffer.size() < newPathLen) pathBuffer.resize(newPathLen);\n\t\t\titemex.hItem = (HTREEITEM)this->visibleFiles[i].treeViewEntry;\n\t\t\titemex.mask = TVIF_HANDLE | TVIF_TEXT;\n\t\t\titemex.pszText = pathBuffer.data();\n\t\t\titemex.cchTextMax = (int)pathBuffer.size();\n\t\t\tTreeView_GetItem(hTreeChanges, &itemex);\n\t\t\tpathBuffer[pathBuffer.size() - 1] = 0;\n\t\t\tnewPathLen += MAX_PATH;\n\t\t} while (newPathLen < INT_MAX-2 && _tcslen(itemex.pszText) >= pathBuffer.size() - 1);\n\n\t\tauto newPath8 = unique_TCHARToMultiByte(pathBuffer.data());\n\t\tpackageFile.affectedAssets[i].path = newPath8.get();\n\t}\n\t//Set the replacers.\n\tfor (size_t i = 0; i < this->visibleFiles.size(); i++)\n\t{\n\t\tInstallerPackageAssetsDesc &packageFileDesc = packageFile.affectedAssets[i];\n\t\tVisibleFileEntry &visibleFileDesc = this->visibleFiles[i];\n\n\t\tpackageFileDesc.replacers.reserve(visibleFileDesc.replacers.size() + visibleFileDesc.subFiles.size());\n\t\tfor (size_t i = 0; i < visibleFileDesc.replacers.size(); ++i)\n\t\t\tpackageFileDesc.replacers.push_back(visibleFileDesc.replacers[i].pReplacer);\n\n\t\tswitch (visibleFileDesc.fileType)\n\t\t{\n\t\tcase FileContext_Assets:\n\t\t\tpackageFileDesc.type = InstallerPackageAssetsType::Assets;\n\t\t\tassert(visibleFileDesc.subFiles.empty());\n\t\t\tbreak;\n\t\tcase FileContext_Bundle:\n\t\t\tpackageFileDesc.type = InstallerPackageAssetsType::Bundle;\n\t\t\tfor (size_t i = 0; i < visibleFileDesc.subFiles.size(); ++i)\n\t\t\t\tpackageFileDesc.replacers.push_back(visibleFileDesc.subFiles[i].produceBundleReplacer());\n\t\t\tbreak;\n\t\tcase FileContext_Resources:\n\t\t\tpackageFileDesc.type = InstallerPackageAssetsType::Resources;\n\t\t\tassert(visibleFileDesc.subFiles.empty());\n\t\t\tassert(packageFileDesc.replacers.size() == 1);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tassert(false);\n\t\t}\n\t}\n\t//Free invalid file entries.\n\tfor (size_t _i = packageFile.affectedAssets.size(); _i > 0; --_i)\n\t{\n\t\tsize_t i = _i - 1;\n\t\tif (packageFile.affectedAssets[i].path.empty())\n\t\t\tpackageFile.affectedAssets.erase(packageFile.affectedAssets.begin() + i);\n\t}\n\n\tif (this->saveType == ModDataSaveType_Installer)\n\t{\n\t\treturn GenerateInstaller(hDlg, packageFile, filePath, this->iconData);\n\t}\n\telse\n\t{\n\t\tbool success = false;\n\t\tIAssetsWriter *pOutputWriter = Create_AssetsWriterToFile(filePath.c_str(), true, true, RWOpenFlags_Immediately);\n\n\t\tif (pOutputWriter)\n\t\t{\n\t\t\tQWORD filePos = 0;\n\t\t\tif (!packageFile.Write(filePos, pOutputWriter))\n\t\t\t\tMessageBox(hDlg, TEXT("An error occured while writing the package file!"), TEXT("Asset Bundle Extractor"), MB_ICONERROR);\n\t\t\telse\n\t\t\t\tsuccess = true;\n\t\t\tFree_AssetsWriter(pOutputWriter);\n\t\t}\n\t\telse\n\t\t\tMessageBox(hDlg, TEXT("Unable to open the output file!"), TEXT("Asset Bundle Extractor"), MB_ICONERROR);\n\t\treturn success;\n\t}\n}\n\nstatic void FreePostDialogProc(HWND hDlg)\n{\n\tHWND hIIcon = GetDlgItem(hDlg, IDC_IICON);\n\tif (hIIcon)\n\t{\n\t\tHICON hOldIcon = (HICON)SendMessage(hIIcon, STM_GETIMAGE, IMAGE_ICON, NULL);\n\t\tif (hOldIcon)\n\t\t\tDestroyIcon(hOldIcon);\n\t}\n}\n\nvoid Win32ModInstallerEditor::AskSave()\n{\n\tif ((this->visibleFiles.empty() || !this->changedFlag)\n\t\t&& Edit_GetTextLength(GetDlgItem(hDlg, IDC_EMODNAME)) == 0\n\t\t&& Edit_GetTextLength(GetDlgItem(hDlg, IDC_EAUTHORS)) == 0\n\t\t&& Edit_GetTextLength(GetDlgItem(hDlg, IDC_EDESCRIPTION)) == 0)\n\t{\n\t\tEndDialog(hDlg, 0);\n\t\tFreePostDialogProc(hDlg);\n\t}\n\telse if (this->saveType == ModDataSaveType_PackageFile //No question for saving to a package file needed.\n\t\t|| this->visibleFiles.empty() || !this->changedFlag) //Text fields changed.\n\t{\n\t\tswitch (MessageBox(hDlg, \n\t\t\t\tTEXT("Are you sure you want to discard the progress?"),\n\t\t\t\tTEXT("Asset Bundle Extractor"),\n\t\t\t\tMB_YESNO))\n\t\t{\n\t\tcase IDNO:\n\t\t\tbreak;\n\t\tcase IDYES:\n\t\tdefault:\n\t\t\tEndDialog(hDlg, 0);\n\t\t\tFreePostDialogProc(hDlg);\n\t\t\tbreak;\n\t\t}\n\t}\n\telse\n\t{\n\t\tswitch (MessageBox(hDlg, \n\t\t\t\tTEXT("Are you sure you want to discard the progress?\\n")\\\n\t\t\t\tTEXT("To use the changes inside UABE, you need to save them to an installer package first. Press \\"No\\" to do that."), \n\t\t\t\tTEXT("Asset Bundle Extractor"), \n\t\t\t\tMB_YESNOCANCEL))\n\t\t{\n\t\tcase IDNO:\n\t\t\tthis->saveType = ModDataSaveType_PackageFile;\n\t\t\tif (!this->SaveChanges())\n\t\t\t\tbreak;\n\t\tcase IDYES:\n\t\t\tEndDialog(hDlg, 0);\n\t\t\tFreePostDialogProc(hDlg);\n\t\tcase IDCANCEL:\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nINT_PTR CALLBACK Win32ModInstallerEditor::DialogProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)\n{\n\tWin32ModInstallerEditor *pThis = reinterpret_cast<Win32ModInstallerEditor*>(GetWindowLongPtr(hDlg, GWLP_USERDATA));\n\tint wmId, wmEvent;\n\tUNREFERENCED_PARAMETER(lParam);\n\tswitch (message)\n\t{\n\t\tcase WM_INITDIALOG:\n\t\t\t{\n\t\t\t\tSetWindowLongPtr(hDlg, GWLP_USERDATA, lParam);\n\t\t\t\tpThis = reinterpret_cast<Win32ModInstallerEditor*>(lParam);\n\t\t\t\tpThis->hDlg = hDlg;\n\t\t\t\tpThis->hTreeModifications = GetDlgItem(hDlg, IDC_TREECHANGES);\n\t\t\t\tif (pThis->hTreeModifications == NULL)\n\t\t\t\t{\n\t\t\t\t\tEndDialog(hDlg, (INT_PTR)0);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tpThis->UpdateModsTree();\n\t\t\t\tSetWindowPos(hDlg, NULL, 0, 0, 510, 390, SWP_NOMOVE | SWP_NOZORDER | SWP_NOACTIVATE);\n\t\t\t\tpThis->iconData.clear();\n\t\t\t\tswitch (pThis->saveType)\n\t\t\t\t{\n\t\t\t\t\tcase ModDataSaveType_PackageFile:\n\t\t\t\t\t\tShowWindow(GetDlgItem(hDlg, IDC_SICON), SW_HIDE);\n\t\t\t\t\t\tShowWindow(GetDlgItem(hDlg, IDC_IICON), SW_HIDE);\n\t\t\t\t\t\tShowWindow(GetDlgItem(hDlg, IDC_BTNLOADICON), SW_HIDE);\n\t\t\t\t\t\tSetWindowText(hDlg, TEXT("Create an installer package"));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase ModDataSaveType_Installer:\n\t\t\t\t\t{\n\t\t\t\t\t\tHMODULE hModule = GetModuleHandle(NULL);\n\t\t\t\t\t\tHRSRC hResource = FindResource(hModule, MAKEINTRESOURCE(IDI_ASSETBUNDLEEXTRACTOR), MAKEINTRESOURCE(3));\n\t\t\t\t\t\tif (hResource)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tDWORD resourceSize = SizeofResource(hModule, hResource);\n\t\t\t\t\t\t\tHGLOBAL resourceHandle = LoadResource(hModule, hResource);\n\t\t\t\t\t\t\tif (resourceHandle)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tPVOID pResource = LockResource(resourceHandle);\n\t\t\t\t\t\t\t\tuint8_t *pBuf = reinterpret_cast<uint8_t*>(pResource);\n\t\t\t\t\t\t\t\tsize_t size = resourceSize;\n\t\t\t\t\t\t\t\tpThis->iconData.assign(pBuf, pBuf + size);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tHICON hIcon = (HICON)LoadIcon(GetModuleHandle(NULL), MAKEINTRESOURCE(IDI_ASSETBUNDLEEXTRACTOR));\n\t\t\t\t\t\tHWND hIIcon = GetDlgItem(hDlg, IDC_IICON);\n\t\t\t\t\t\tSendMessage(hIIcon, STM_SETIMAGE, IMAGE_ICON, (LPARAM)hIcon);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn (INT_PTR)TRUE;\n\t\tcase WM_SIZE:\n\t\t\t{\n\t\t\t\tint width = LOWORD(lParam); int height = HIWORD(lParam);\n\t\t\t\tSetWindowPos(GetDlgItem(hDlg, IDC_EMODNAME), NULL, 90, 23, width / 2 - 95, 23, SWP_NOZORDER | SWP_NOACTIVATE);\n\t\t\t\tSetWindowPos(GetDlgItem(hDlg, IDC_EAUTHORS), NULL, 90, 54, width / 2 - 95, 23, SWP_NOZORDER | SWP_NOACTIVATE);\n\t\t\t\tSetWindowPos(GetDlgItem(hDlg, IDC_EDESCRIPTION), NULL, 90, 93, width / 2 - 95, height - 146, SWP_NOZORDER | SWP_NOACTIVATE);\n\t\t\t\t//if (userData->saveType != ModDataSaveType_Installer)\n\t\t\t\t{\n\t\t\t\t\tSetWindowPos(GetDlgItem(hDlg, IDC_IICON), NULL, 90, height - 50, 32, 32, SWP_NOZORDER | SWP_NOACTIVATE); \n\t\t\t\t\tSetWindowPos(GetDlgItem(hDlg, IDC_BTNLOADICON), NULL, 130, height - 45, (width / 2) - 135, 21, SWP_NOZORDER | SWP_NOACTIVATE); \n\t\t\t\t\tSetWindowPos(GetDlgItem(hDlg, IDC_SICON), NULL, 9, height - 55, 0, 0, SWP_NOSIZE | SWP_NOZORDER | SWP_NOACTIVATE); \n\t\t\t\t}\n\t\t\t\tSetWindowPos(GetDlgItem(hDlg, IDC_SBASEFOLDER), NULL, width / 2 + 5, 23, 0, 0, SWP_NOSIZE | SWP_NOZORDER | SWP_NOACTIVATE);\n\t\t\t\tSetWindowPos(GetDlgItem(hDlg, IDC_EBASEFOLDER), NULL, width / 2 + 5, 54, (int)((float)(width / 2 - 22) * 0.64), 23, SWP_NOZORDER | SWP_NOACTIVATE);\n\t\t\t\tSetWindowPos(GetDlgItem(hDlg, IDC_BTNBASEFOLDER), NULL, (int)((float)width / 2.0 * 1.64), 55, (int)((float)(width / 2 - 22) * 0.36), 21, SWP_NOZORDER | SWP_NOACTIVATE);\n\t\t\t\tSetWindowPos(GetDlgItem(hDlg, IDC_SCHANGES), NULL, width / 2 + 5, 84, 0, 0, SWP_NOSIZE | SWP_NOZORDER | SWP_NOACTIVATE);\n\t\t\t\tSetWindowPos(GetDlgItem(hDlg, IDC_TREECHANGES), NULL, width / 2 + 5, 102, width / 2 - 13, height - 168, SWP_NOZORDER | SWP_NOACTIVATE);\n\t\t\t\tSetWindowPos(GetDlgItem(hDlg, IDC_BTNIMPORTPAK), NULL, width / 2 + 5, height - 64, (int)(((float)width / 2.0 - 25.0) / 2.0), 21, SWP_NOZORDER | SWP_NOACTIVATE);\n\t\t\t\tSetWindowPos(GetDlgItem(hDlg, IDC_BTNREMCHANGE), NULL, (int)((float)width * 0.75), height - 64, (int)(((float)width / 2.0 - 25.0) / 2.0), 21, SWP_NOZORDER | SWP_NOACTIVATE);\n\t\t\t\tSetWindowPos(GetDlgItem(hDlg, IDOK), NULL, width / 2 + 5, height - 33, (int)(((float)width / 2.0 - 74.0) / 2.0), 21, SWP_NOZORDER | SWP_NOACTIVATE);\n\t\t\t\tSetWindowPos(GetDlgItem(hDlg, IDCANCEL), NULL, (int)((float)width * 0.75 + 24.0), height - 33, (int)(((float)width / 2.0 - 74.0) / 2.0), 21, SWP_NOZORDER | SWP_NOACTIVATE);\n\t\t\t}\n\t\t\treturn (INT_PTR)TRUE;\n\t\tcase WM_CLOSE:\n\t\t\tpThis->AskSave();\n\t\t\treturn (INT_PTR)TRUE;\n\t\tcase WM_DESTROY:\n\t\t\tEndDialog(hDlg, LOWORD(wParam));\n\t\t\tFreePostDialogProc(hDlg);\n\t\t\tbreak;\n\t\tcase WM_COMMAND:\n\t\t\twmId    = LOWORD(wParam);\n\t\t\twmEvent = HIWORD(wParam);\n\t\t\tswitch (wmId)\n\t\t\t{\n\t\t\t\tcase IDC_EBASEFOLDER:\n\t\t\t\t\tif (!pThis)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tpThis->UpdateDisplayedRelPaths();\n\t\t\t\t\treturn (INT_PTR)TRUE;\n\t\t\t\tcase IDC_BTNBASEFOLDER:\n\t\t\t\t\tif (!pThis)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t{\n\t\t\t\t\t\tHWND hEditBaseFolder = GetDlgItem(hDlg, IDC_EBASEFOLDER);\n\t\t\t\t\t\tWCHAR *folderPath = NULL;\n\t\t\t\t\t\tif (hEditBaseFolder && ShowFolderSelectDialog(hDlg, &folderPath, L"Select a base directory", UABE_FILEDIALOG_FILE_GUID))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tSetWindowTextW(hEditBaseFolder, folderPath);\n\t\t\t\t\t\t\tFreeCOMFilePathBuf(&folderPath);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn (INT_PTR)TRUE;\n\t\t\t\t\t}\n\t\t\t\tcase IDC_BTNLOADICON:\n\t\t\t\t\tif (!pThis)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tpThis->SelectAndLoadIcon();\n\t\t\t\t\treturn (INT_PTR)TRUE;\n\t\t\t\tcase IDC_BTNIMPORTPAK:\n\t\t\t\t\tif (!pThis)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tpThis->SelectAndImportPackage();\n\t\t\t\t\treturn (INT_PTR)TRUE;\n\t\t\t\tcase IDC_BTNREMCHANGE:\n\t\t\t\t\tif (!pThis)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t{\n\t\t\t\t\t\tHWND hTreeChanges = GetDlgItem(hDlg, IDC_TREECHANGES);\n\t\t\t\t\t\tif (!hTreeChanges)\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tHTREEITEM selection = TreeView_GetSelection(hTreeChanges);\n\t\t\t\t\t\tpThis->RemoveChange(selection);\n\t\t\t\t\t\treturn (INT_PTR)TRUE;\n\t\t\t\t\t}\n\t\t\t\tcase IDOK:\n\t\t\t\t\tif (!pThis)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tif (pThis->SaveChanges())\n\t\t\t\t\t{\n\t\t\t\t\t\tEndDialog(hDlg, LOWORD(wParam));\n\t\t\t\t\t\tFreePostDialogProc(hDlg);\n\t\t\t\t\t}\n\t\t\t\t\treturn (INT_PTR)TRUE;\n\t\t\t\tcase IDCANCEL:\n\t\t\t\t\tif (!pThis)\n\t\t\t\t\t{\n\t\t\t\t\t\tEndDialog(hDlg, LOWORD(wParam));\n\t\t\t\t\t\tFreePostDialogProc(hDlg);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tpThis->AskSave();\n\t\t\t\t\treturn (INT_PTR)TRUE;\n\t\t\t}\n\t\t\tbreak;\n\t}\n\treturn (INT_PTR)FALSE;\n}\n\nWin32ModInstallerEditor::Win32ModInstallerEditor(Win32AppContext &appContext,\n\tstd::vector<std::shared_ptr<FileContextInfo>> &contextInfo,\n\tEModDataSaveType saveType)\n\t: Win32ModTreeDialogBase(appContext), saveType(saveType), changedFlag(false)\n{\n\tfor (size_t i = 0; i < contextInfo.size(); ++i)\n\t{\n\t\tif (contextInfo[i] != nullptr && contextInfo[i]->getFileContext() != nullptr && contextInfo[i]->getParentFileID() == 0\n\t\t\t&& contextInfo[i]->hasAnyChanges(appContext))\n\t\t\tthis->visibleFiles.push_back(VisibleFileEntry(appContext, contextInfo[i]));\n\t}\n\n\t//Copy relevant Unity basic types, assuming that we only have one class database across all files.\n\t//-> Assumption is not always correct.\n\tstruct {\n\t\tvoid operator()(VisibleFileEntry &file, std::unordered_set<int> &classIDs, std::shared_ptr<ClassDatabaseFile> &pFoundClassDatabase)\n\t\t{\n\t\t\tif (file.fileType == FileContext_Assets && file.pContextInfo != nullptr)\n\t\t\t{\n\t\t\t\tif (!pFoundClassDatabase)\n\t\t\t\t\tpFoundClassDatabase = reinterpret_cast<AssetsFileContextInfo*>(file.pContextInfo.get())->GetClassDatabase();\n\t\t\t\tfor (size_t i = 0; i < file.replacers.size(); ++i)\n\t\t\t\t{\n\t\t\t\t\tauto *pReplacer = reinterpret_cast<AssetsReplacer*>(file.replacers[i].pReplacer.get());\n\t\t\t\t\tstd::shared_ptr<ClassDatabaseFile> typeDbFile; ClassDatabaseType *pType;\n\t\t\t\t\tif (pReplacer != nullptr\n\t\t\t\t\t\t&& pReplacer->GetType() == AssetsReplacement_AddOrModify)\n\t\t\t\t\t{\n\t\t\t\t\t\tAssetsEntryReplacer* pEntryReplacer = reinterpret_cast<AssetsEntryReplacer*>(pReplacer);\n\t\t\t\t\t\tif (pEntryReplacer->GetClassID() >= 0 && !pEntryReplacer->GetTypeInfo(typeDbFile, pType))\n\t\t\t\t\t\t\tclassIDs.insert(pEntryReplacer->GetClassID());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (size_t i = 0; i < file.subFiles.size(); ++i)\n\t\t\t\t(*this)(file.subFiles[i], classIDs, pFoundClassDatabase);\n\t\t}\n\t} enumerateClassIDs;\n\tstd::shared_ptr<ClassDatabaseFile> pFoundClassDatabase;\n\tstd::unordered_set<int> classIDs;\n\tfor (size_t i = 0; i < visibleFiles.size(); ++i)\n\t\tenumerateClassIDs(visibleFiles[i], classIDs, pFoundClassDatabase);\n\tif (pFoundClassDatabase != nullptr)\n\t{\n\t\tfor (size_t i = 0; i < pFoundClassDatabase->classes.size(); i++)\n\t\t{\n\t\t\tif (classIDs.find(pFoundClassDatabase->classes[i].classId) != classIDs.end())\n\t\t\t{\n\t\t\t\ttypesToExport.InsertFrom(pFoundClassDatabase.get(), &pFoundClassDatabase->classes[i]);\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid Win32ModInstallerEditor::open()\n{\n\tDialogBoxParam(appContext.getMainWindow().getHInstance(),\n\t\tMAKEINTRESOURCE(IDD_MAKEINSTALLER), appContext.getMainWindow().getWindow(),\n\t\tDialogProc,\n\t\t(LPARAM)this);\n}\n\n'