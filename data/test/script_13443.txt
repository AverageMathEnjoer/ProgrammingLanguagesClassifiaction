b'#include <bits/stdc++.h>\nusing namespace std;\n\nint getCurrentTimeStamp(){\n\treturn 0; //assume this is a system function that returns the current timestamp\t\n}\n\n//Implement a CacheStore that can store key values with some TTL info as well\ntemplate <typename K, typename V>\nclass CacheStore\n{\n\t//mapping key to value as well as a timestamp till its valid\n\tunordered_map<K, pair<V, int>> _mep;\n\tpublic:\n\tvoid Add(K key, V value, int ttl) {\n\t\tif(_mep.find(key) == _mep.end()) {\n\t\t\tint expirationTime = getCurrentTimeStamp() + ttl;\n\t\t\t_mep[key] = {value, expirationTime};\n\t\t}\n\t\telse {\n\t\t\t//depends on business logic how to handle this case\n\t\t\t//one approach is we can overwrite the value\n\t\t}\n\t}\n\t\n\t//returns true if key existed and also alive\n\tbool Get(K key, V* out) {\n\t\tint currentTime = getCurrentTimeStamp();\n\t\tif(_mep.find(key) == _mep.end()) {\n\t\t\tout = NULL;\n\t\t\treturn 0;\n\t\t}\n\t\telse {\n\t\t\tpair<V, int> cur = _mep[key];\n\t\t\tif (cur.second < currentTime) {\n\t\t\t\t//expired\n\t\t\t\tout = NULL;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t*out = cur.first;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n};\n\nint main() {\n\tCacheStore<string, int> M;\n\tM.Add("rachit", 1, 10);\n\tM.Add("Uber", 2, 100);\n\tint* res = new int;\n\tif(M.Get("rachit", res)) cout << *res << endl;\n\tif(M.Get("Uber", res)) cout << *res << endl;\n\t\n\treturn 0;\n}\n'