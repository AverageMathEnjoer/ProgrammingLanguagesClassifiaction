b'/*\n    SPDX-FileCopyrightText: 2014-2017 Milian Wolff <mail@milianw.de>\n\n    SPDX-License-Identifier: LGPL-2.1-or-later\n*/\n\n/**\n * @file libheaptrack.cpp\n *\n * @brief Collect raw heaptrack data by overloading heap allocation functions.\n */\n\n#include "libheaptrack.h"\n\n#include <cstdio>\n#include <cstdlib>\n#include <fcntl.h>\n#include <link.h>\n#include <pthread.h>\n#include <signal.h>\n#ifdef __linux__\n#include <stdio_ext.h>\n#include <syscall.h>\n#endif\n#ifdef __FreeBSD__\n#include <pthread_np.h>\n#include <sys/types.h>\n#include <sys/sysctl.h>\n#include <sys/user.h>\n#include <libutil.h>\n#endif\n#include <sys/file.h>\n\n#include <atomic>\n#include <cinttypes>\n#include <memory>\n#include <mutex>\n#include <sstream>\n#include <string>\n#include <thread>\n\n#include "tracetree.h"\n#include "util/config.h"\n#include "util/libunwind_config.h"\n#include "util/linewriter.h"\n\nextern "C" {\n// see upstream "documentation" at:\n// https://github.com/llvm-mirror/compiler-rt/blob/master/include/sanitizer/lsan_interface.h#L76\n__attribute__((weak)) const char* __lsan_default_suppressions();\n}\nnamespace __gnu_cxx {\n__attribute__((weak)) extern void __freeres();\n}\n\n/**\n * uncomment this to get extended debug code for known pointers\n * there are still some malloc functions I\'m missing apparently,\n * related to TLS and such I guess\n */\n// #define DEBUG_MALLOC_PTRS\n\n#ifdef DEBUG_MALLOC_PTRS\n#include <tsl/robin_set.h>\n#endif\n\nusing namespace std;\n\nnamespace {\n\nusing clock = chrono::steady_clock;\nchrono::time_point<clock> startTime()\n{\n    static const chrono::time_point<clock> s_start = clock::now();\n    return s_start;\n}\n\nchrono::milliseconds elapsedTime()\n{\n    return chrono::duration_cast<chrono::milliseconds>(clock::now() - startTime());\n}\n\npid_t gettid()\n{\n#ifdef __linux__\n    return syscall(SYS_gettid);\n#elif defined(__FreeBSD__)\n    return pthread_getthreadid_np();\n#endif\n}\n\n/**\n * A per-thread handle guard to prevent infinite recursion, which should be\n * acquired before doing any special symbol handling.\n */\nstruct RecursionGuard\n{\n    RecursionGuard()\n        : wasLocked(isActive)\n    {\n        isActive = true;\n    }\n\n    ~RecursionGuard()\n    {\n        isActive = wasLocked;\n    }\n\n    const bool wasLocked;\n    static thread_local bool isActive;\n};\n\nthread_local bool RecursionGuard::isActive = false;\n\nenum DebugVerbosity\n{\n    WarningOutput,\n    NoDebugOutput,\n    MinimalOutput,\n    VerboseOutput,\n    VeryVerboseOutput,\n};\n\n// change this to add more debug output to stderr\nconstexpr const DebugVerbosity s_debugVerbosity = NoDebugOutput;\n\n/**\n * Call this to optionally show debug information but give the compiler\n * a hand in removing it all if debug output is disabled.\n */\ntemplate <DebugVerbosity debugLevel, typename Callback>\ninline void debugLog(Callback callback)\n{\n    if (debugLevel <= s_debugVerbosity) {\n        RecursionGuard guard;\n        flockfile(stderr);\n        if (debugLevel == WarningOutput) {\n            fprintf(stderr, "heaptrack warning [%d:%d]@%" PRIu64 " ", getpid(), gettid(), elapsedTime().count());\n        } else {\n            fprintf(stderr, "heaptrack debug(%d) [%d:%d]@%" PRIu64 " ", debugLevel, getpid(), gettid(),\n                    elapsedTime().count());\n        }\n        callback(stderr);\n        fputc(\'\\n\', stderr);\n        funlockfile(stderr);\n    }\n}\n\n/**\n * Call this to optionally show debug information but give the compiler\n * a hand in removing it all if debug output is disabled.\n */\ntemplate <DebugVerbosity debugLevel, typename... Args>\ninline void debugLog(const char fmt[], Args... args)\n{\n    debugLog<debugLevel>([&](FILE* out) { fprintf(out, fmt, args...); });\n}\n\nvoid printBacktrace()\n{\n    if (s_debugVerbosity == NoDebugOutput)\n        return;\n\n    RecursionGuard guard;\n\n    Trace::print();\n}\n\n/**\n * Set to true in an atexit handler. In such conditions, the stop callback\n * will not be called.\n */\natomic<bool> s_atexit{false};\n\n/**\n * Set to true in heaptrack_stop, when s_atexit was not yet set. In such conditions,\n * we always fully unload and cleanup behind ourselves\n */\natomic<bool> s_forceCleanup{false};\n\n// based on: https://stackoverflow.com/a/24315631/35250\nvoid replaceAll(string& str, const string& search, const string& replace)\n{\n    size_t start_pos = 0;\n    while ((start_pos = str.find(search, start_pos)) != string::npos) {\n        str.replace(start_pos, search.length(), replace);\n        start_pos += replace.length();\n    }\n}\n\n// see https://bugs.kde.org/show_bug.cgi?id=408547\n// apparently sometimes flock can return EAGAIN, despite that not being a documented return value\nstatic int lockFile(int fd)\n{\n    int ret = -1;\n    while ((ret = flock(fd, LOCK_EX | LOCK_NB)) == EAGAIN) {\n        // try again\n    }\n    return ret;\n}\n\nint createFile(const char* fileName)\n{\n    string outputFileName;\n    if (fileName) {\n        outputFileName.assign(fileName);\n    }\n\n    if (outputFileName == "-" || outputFileName == "stdout") {\n        debugLog<VerboseOutput>("%s", "will write to stdout");\n        return fileno(stdout);\n    } else if (outputFileName == "stderr") {\n        debugLog<VerboseOutput>("%s", "will write to stderr");\n        return fileno(stderr);\n    }\n\n    if (outputFileName.empty()) {\n        // env var might not be set when linked directly into an executable\n        outputFileName = "heaptrack.$$";\n    }\n\n    replaceAll(outputFileName, "$$", to_string(getpid()));\n\n    auto out = open(outputFileName.c_str(), O_CREAT | O_WRONLY | O_CLOEXEC, 0644);\n    debugLog<VerboseOutput>("will write to %s/%p\\n", outputFileName.c_str(), out);\n    // we do our own locking, this speeds up the writing significantly\n    if (out == -1) {\n        fprintf(stderr, "ERROR: failed to open heaptrack output file %s: %s (%d)\\n", outputFileName.c_str(),\n                strerror(errno), errno);\n    } else if (lockFile(out) != 0) {\n#ifdef __FreeBSD__\n        // pipes do not support flock, create a regular file\n        auto lockpath = outputFileName + ".lock";\n        auto lockfile = open(lockpath.c_str(), O_CREAT | O_WRONLY | O_CLOEXEC, 0644);\n        debugLog<VerboseOutput>("will lock %s/%p\\n", lockpath.c_str(), lockfile);\n        if (lockFile(lockfile) == 0) {\n            // leaking the fd seems fine\n            return out;\n        }\n#endif\n        fprintf(stderr, "ERROR: failed to lock heaptrack output file %s: %s (%d)\\n", outputFileName.c_str(),\n                strerror(errno), errno);\n        close(out);\n        return -1;\n    }\n\n    return out;\n}\n\n/**\n * Thread-Safe heaptrack API\n *\n * The only critical section in libheaptrack is the output of the data,\n * dl_iterate_phdr calls, as well as initialization and shutdown.\n */\nclass HeapTrack\n{\npublic:\n    HeapTrack(const RecursionGuard& /*recursionGuard*/)\n    {\n        debugLog<VeryVerboseOutput>("%s", "acquiring lock");\n        s_lock.lock();\n        debugLog<VeryVerboseOutput>("%s", "lock acquired");\n    }\n\n    ~HeapTrack()\n    {\n        debugLog<VeryVerboseOutput>("%s", "releasing lock");\n        s_lock.unlock();\n    }\n\n    void initialize(const char* fileName, heaptrack_callback_t initBeforeCallback,\n                    heaptrack_callback_initialized_t initAfterCallback, heaptrack_callback_t stopCallback)\n    {\n        debugLog<MinimalOutput>("initializing: %s", fileName);\n        if (s_data) {\n            debugLog<MinimalOutput>("%s", "already initialized");\n            return;\n        }\n\n        if (initBeforeCallback) {\n            debugLog<MinimalOutput>("%s", "calling initBeforeCallback");\n            initBeforeCallback();\n            debugLog<MinimalOutput>("%s", "done calling initBeforeCallback");\n        }\n\n        // do some once-only initializations\n        static once_flag once;\n        call_once(once, [] {\n            debugLog<MinimalOutput>("%s", "doing once-only initialization");\n\n            Trace::setup();\n\n            // do not trace forked child processes\n            // TODO: make this configurable\n            pthread_atfork(&prepare_fork, &parent_fork, &child_fork);\n\n            atexit([]() {\n                if (s_forceCleanup) {\n                    return;\n                }\n                debugLog<MinimalOutput>("%s", "atexit()");\n\n                // free internal libstdc++ resources\n                // see also Valgrind\'s `--run-cxx-freeres` option\n                if (&__gnu_cxx::__freeres) {\n                    __gnu_cxx::__freeres();\n                }\n\n                s_atexit.store(true);\n                heaptrack_stop();\n            });\n        });\n\n        const auto out = createFile(fileName);\n\n        if (out == -1) {\n            if (stopCallback) {\n                stopCallback();\n            }\n            return;\n        }\n\n        s_data = new LockedData(out, stopCallback);\n\n        writeVersion();\n        writeExe();\n        writeCommandLine();\n        writeSystemInfo();\n        writeSuppressions();\n\n        if (initAfterCallback) {\n            debugLog<MinimalOutput>("%s", "calling initAfterCallback");\n            initAfterCallback(s_data->out);\n            debugLog<MinimalOutput>("%s", "calling initAfterCallback done");\n        }\n\n        debugLog<MinimalOutput>("%s", "initialization done");\n    }\n\n    void shutdown()\n    {\n        if (!s_data) {\n            return;\n        }\n\n        debugLog<MinimalOutput>("%s", "shutdown()");\n\n        writeTimestamp();\n        writeRSS();\n\n        s_data->out.flush();\n        s_data->out.close();\n\n        // NOTE: we leak heaptrack data on exit, intentionally\n        // This way, we can be sure to get all static deallocations.\n        if (!s_atexit || s_forceCleanup) {\n            delete s_data;\n            s_data = nullptr;\n        }\n\n        debugLog<MinimalOutput>("%s", "shutdown() done");\n    }\n\n    void invalidateModuleCache()\n    {\n        if (!s_data) {\n            return;\n        }\n        s_data->moduleCacheDirty = true;\n    }\n\n    void writeTimestamp()\n    {\n        if (!s_data || !s_data->out.canWrite()) {\n            return;\n        }\n\n        auto elapsed = elapsedTime();\n\n        debugLog<VeryVerboseOutput>("writeTimestamp(%" PRIx64 ")", elapsed.count());\n\n        s_data->out.writeHexLine(\'c\', static_cast<size_t>(elapsed.count()));\n    }\n\n    void writeRSS()\n    {\n        if (!s_data || !s_data->out.canWrite()) {\n            return;\n        }\n\n        size_t rss = 0;\n\n#ifdef __linux__\n        if (s_data->procStatm == -1) {\n            return;\n        }\n        // read RSS in pages from statm, then rewind for next read\n        // NOTE: don\'t use fscanf here, it could potentially deadlock us\n        const int BUF_SIZE = 512;\n        char buf[BUF_SIZE + 1];\n        if (read(s_data->procStatm, buf, BUF_SIZE) <= 0) {\n            fprintf(stderr, "WARNING: Failed to read RSS value from /proc/self/statm.\\n");\n            close(s_data->procStatm);\n            s_data->procStatm = -1;\n            return;\n        }\n        lseek(s_data->procStatm, 0, SEEK_SET);\n\n        if (sscanf(buf, "%*u %zu", &rss) != 1) {\n            fprintf(stderr, "WARNING: Failed to read RSS value from /proc/self/statm.\\n");\n            close(s_data->procStatm);\n            s_data->procStatm = -1;\n            return;\n        }\n#elif defined(__FreeBSD__)\n        auto proc_info = kinfo_getproc(getpid());\n        if (proc_info == nullptr) {\n            return;\n        }\n\n        rss = proc_info->ki_rssize;\n\n        free(proc_info);\n#endif\n\n        // TODO: compare to rusage.ru_maxrss (getrusage) to find "real" peak?\n        // TODO: use custom allocators with known page sizes to prevent tainting\n        //       the RSS numbers with heaptrack-internal data\n\n        s_data->out.writeHexLine(\'R\', rss);\n    }\n\n    void writeVersion()\n    {\n        s_data->out.writeHexLine(\'v\', static_cast<size_t>(HEAPTRACK_VERSION),\n                                 static_cast<size_t>(HEAPTRACK_FILE_FORMAT_VERSION));\n    }\n\n    void writeExe()\n    {\n        const int BUF_SIZE = 1023;\n        char buf[BUF_SIZE + 1];\n\n#ifdef __linux__\n        ssize_t size = readlink("/proc/self/exe", buf, BUF_SIZE);\n#elif defined(__FreeBSD__)\n        int mib[4] = { CTL_KERN, KERN_PROC, KERN_PROC_PATHNAME, -1 };\n        size_t size = BUF_SIZE;\n        sysctl(mib, 4, buf, &size, NULL, 0);\n#endif\n\n        if (size > 0 && size < BUF_SIZE) {\n            buf[size] = 0;\n            s_data->out.write("x %x %s\\n", size, buf);\n        }\n    }\n\n    void writeCommandLine()\n    {\n        s_data->out.write("X");\n        const int BUF_SIZE = 4096;\n        char buf[BUF_SIZE + 1] = {0};\n\n#ifdef __linux__\n        auto fd = open("/proc/self/cmdline", O_RDONLY);\n        int bytesRead = read(fd, buf, BUF_SIZE);\n        close(fd);\n#elif defined(__FreeBSD__)\n        int mib[4] = { CTL_KERN, KERN_PROC, KERN_PROC_ARGS, getpid() };\n        size_t bytesRead = BUF_SIZE;\n        sysctl(mib, 4, buf, &bytesRead, NULL, 0);\n#endif\n\n        char* end = buf + bytesRead;\n        for (char* p = buf; p < end;) {\n            s_data->out.write(" %s", p);\n            while (*p++)\n                ; // skip until start of next 0-terminated section\n        }\n\n        s_data->out.write("\\n");\n    }\n\n    void writeSystemInfo()\n    {\n        s_data->out.writeHexLine(\'I\', static_cast<size_t>(sysconf(_SC_PAGESIZE)),\n                                 static_cast<size_t>(sysconf(_SC_PHYS_PAGES)));\n    }\n\n    void writeSuppressions()\n    {\n        if (!__lsan_default_suppressions)\n            return;\n\n        const char* suppressions = __lsan_default_suppressions();\n        if (!suppressions)\n            return;\n\n        std::istringstream stream(suppressions);\n        std::string line;\n        while (std::getline(stream, line)) {\n            s_data->out.write("S ");\n            s_data->out.write(line);\n            s_data->out.write("\\n");\n        }\n    }\n\n    void handleMalloc(void* ptr, size_t size, const Trace& trace)\n    {\n        if (!s_data || !s_data->out.canWrite()) {\n            return;\n        }\n        updateModuleCache();\n\n        const auto index = s_data->traceTree.index(trace, [](uintptr_t ip, uint32_t index) {\n            // decrement addresses by one - otherwise we misattribute the cost to the wrong instruction\n            // for some reason, it seems like we always get the instruction _after_ the one we are interested in\n            // see also: https://github.com/libunwind/libunwind/issues/287\n            // and https://bugs.kde.org/show_bug.cgi?id=439897\n            --ip;\n\n            return s_data->out.writeHexLine(\'t\', ip, index);\n        });\n\n#ifdef DEBUG_MALLOC_PTRS\n        auto it = s_data->known.find(ptr);\n        assert(it == s_data->known.end());\n        s_data->known.insert(ptr);\n#endif\n\n        s_data->out.writeHexLine(\'+\', size, index, reinterpret_cast<uintptr_t>(ptr));\n    }\n\n    void handleFree(void* ptr)\n    {\n        if (!s_data || !s_data->out.canWrite()) {\n            return;\n        }\n\n#ifdef DEBUG_MALLOC_PTRS\n        auto it = s_data->known.find(ptr);\n        assert(it != s_data->known.end());\n        s_data->known.erase(it);\n#endif\n\n        s_data->out.writeHexLine(\'-\', reinterpret_cast<uintptr_t>(ptr));\n    }\n\n    static bool isPaused()\n    {\n        return s_paused;\n    }\n\n    static void setPaused(bool state)\n    {\n        s_paused = state;\n    }\n\nprivate:\n    static int dl_iterate_phdr_callback(struct dl_phdr_info* info, size_t /*size*/, void* data)\n    {\n        auto heaptrack = reinterpret_cast<HeapTrack*>(data);\n        const char* fileName = info->dlpi_name;\n        if (!fileName || !fileName[0]) {\n            fileName = "x";\n        }\n\n        debugLog<VerboseOutput>("dlopen_notify_callback: %s %zx", fileName, info->dlpi_addr);\n\n        if (!heaptrack->s_data->out.write("m %x %s %zx", strlen(fileName), fileName, info->dlpi_addr)) {\n            return 1;\n        }\n\n        for (int i = 0; i < info->dlpi_phnum; i++) {\n            const auto& phdr = info->dlpi_phdr[i];\n            if (phdr.p_type == PT_LOAD) {\n                if (!heaptrack->s_data->out.write(" %zx %zx", phdr.p_vaddr, phdr.p_memsz)) {\n                    return 1;\n                }\n            }\n        }\n\n        if (!heaptrack->s_data->out.write("\\n")) {\n            return 1;\n        }\n\n        return 0;\n    }\n\n    static void prepare_fork()\n    {\n        debugLog<MinimalOutput>("%s", "prepare_fork()");\n        // don\'t do any custom malloc handling while inside fork\n        RecursionGuard::isActive = true;\n    }\n\n    static void parent_fork()\n    {\n        debugLog<MinimalOutput>("%s", "parent_fork()");\n        // the parent process can now continue its custom malloc tracking\n        RecursionGuard::isActive = false;\n    }\n\n    static void child_fork()\n    {\n        debugLog<MinimalOutput>("%s", "child_fork()");\n        // but the forked child process cleans up itself\n        // this is important to prevent two processes writing to the same file\n        s_data = nullptr;\n        RecursionGuard::isActive = true;\n    }\n\n    void updateModuleCache()\n    {\n        if (!s_data || !s_data->out.canWrite() || !s_data->moduleCacheDirty) {\n            return;\n        }\n        debugLog<MinimalOutput>("%s", "updateModuleCache()");\n        if (!s_data->out.write("m 1 -\\n")) {\n            return;\n        }\n        dl_iterate_phdr(&dl_iterate_phdr_callback, this);\n        s_data->moduleCacheDirty = false;\n    }\n\n    void writeError()\n    {\n        debugLog<MinimalOutput>("write error %d/%s", errno, strerror(errno));\n        printBacktrace();\n        shutdown();\n    }\n\n    struct LockCheckFailed{};\n\n    /**\n     * To prevent deadlocks on shutdown, we try to lock from the timer thread\n     * and throw an LockCheckFailed exception otherwise.\n     */\n    template <typename AdditionalLockCheck>\n    HeapTrack(AdditionalLockCheck lockCheck)\n    {\n        debugLog<VeryVerboseOutput>("%s", "trying to acquire lock");\n        while (!s_lock.try_lock()) {\n            if (!lockCheck())\n                throw LockCheckFailed();\n            this_thread::sleep_for(chrono::microseconds(1));\n        }\n        debugLog<VeryVerboseOutput>("%s", "lock acquired");\n    }\n\n    struct LockedData\n    {\n        LockedData(int out, heaptrack_callback_t stopCallback)\n            : out(out)\n            , stopCallback(stopCallback)\n        {\n\n            debugLog<MinimalOutput>("%s", "constructing LockedData");\n#ifdef __linux__\n            procStatm = open("/proc/self/statm", O_RDONLY);\n            if (procStatm == -1) {\n                fprintf(stderr, "WARNING: Failed to open /proc/self/statm for reading: %s.\\n", strerror(errno));\n            }\n#endif\n\n            // ensure this utility thread is not handling any signals\n            // our host application may assume only one specific thread\n            // will handle the threads, if that\'s not the case things\n            // seemingly break in non-obvious ways.\n            // see also: https://bugs.kde.org/show_bug.cgi?id=378494\n            sigset_t previousMask;\n            sigset_t newMask;\n            sigfillset(&newMask);\n            if (pthread_sigmask(SIG_SETMASK, &newMask, &previousMask) != 0) {\n                fprintf(stderr, "WARNING: Failed to block signals, disabling timer thread.\\n");\n                return;\n            }\n\n            // the mask we set above will be inherited by the thread that we spawn below\n            timerThread = std::thread([&]() {\n                RecursionGuard::isActive = true;\n                debugLog<MinimalOutput>("%s", "timer thread started");\n\n                // HACK: throw the exception once and directly catch it\n                //       without this, tst_inject reproducibly calls\n                //       std::terminate instead of catching the exception\n                //       in the loop below\n                //       I suspect it\'s some strange side-effect of heaptrack\n                //       intercepting the memory allocations that happen when\n                //       an exception is thrown?\n                try {\n                    throw LockCheckFailed {};\n                } catch (LockCheckFailed) {\n                }\n\n                // now loop and repeatedly print the timestamp and RSS usage to the data stream\n                while (!stopTimerThread) {\n                    // TODO: make interval customizable\n                    this_thread::sleep_for(chrono::milliseconds(10));\n\n                    try {\n                        HeapTrack heaptrack([&] { return !stopTimerThread.load(); });\n                        heaptrack.writeTimestamp();\n                        heaptrack.writeRSS();\n                    } catch (LockCheckFailed) {\n                        break;\n                    }\n                }\n            });\n\n            // now restore the previous mask as if nothing ever happened\n            if (pthread_sigmask(SIG_SETMASK, &previousMask, nullptr) != 0) {\n                fprintf(stderr, "WARNING: Failed to restore the signal mask.\\n");\n            }\n        }\n\n        ~LockedData()\n        {\n            debugLog<MinimalOutput>("%s", "destroying LockedData");\n            stopTimerThread = true;\n            if (timerThread.joinable()) {\n                try {\n                    timerThread.join();\n                } catch (const std::system_error&) {\n                }\n            }\n\n            out.close();\n\n            if (procStatm != -1) {\n                close(procStatm);\n            }\n\n            if (stopCallback && (!s_atexit || s_forceCleanup)) {\n                stopCallback();\n            }\n            debugLog<MinimalOutput>("%s", "done destroying LockedData");\n        }\n\n        LineWriter out;\n\n        /// /proc/self/statm file descriptor to read RSS value from\n        int procStatm = -1;\n\n        /**\n         * Calls to dlopen/dlclose mark the cache as dirty.\n         * When this happened, all modules and their section addresses\n         * must be found again via dl_iterate_phdr before we output the\n         * next instruction pointer. Otherwise, heaptrack_interpret might\n         * encounter IPs of an unknown/invalid module.\n         */\n        bool moduleCacheDirty = true;\n\n        TraceTree traceTree;\n\n        atomic<bool> stopTimerThread{false};\n        std::thread timerThread;\n\n        heaptrack_callback_t stopCallback = nullptr;\n\n#ifdef DEBUG_MALLOC_PTRS\n        tsl::robin_set<void*> known;\n#endif\n    };\n\n    static std::mutex s_lock;\n    static LockedData* s_data;\n\nprivate:\n    static std::atomic<bool> s_paused;\n};\n\nstd::mutex HeapTrack::s_lock;\nHeapTrack::LockedData* HeapTrack::s_data{nullptr};\nstd::atomic<bool> HeapTrack::s_paused{false};\n}\n\nstatic void heaptrack_realloc_impl(void* ptr_in, size_t size, void* ptr_out)\n{\n    if (!HeapTrack::isPaused() && ptr_out && !RecursionGuard::isActive) {\n        RecursionGuard guard;\n\n        debugLog<VeryVerboseOutput>("heaptrack_realloc(%p, %zu, %p)", ptr_in, size, ptr_out);\n\n        Trace trace;\n        trace.fill(2 + HEAPTRACK_DEBUG_BUILD * 3);\n\n        HeapTrack heaptrack(guard);\n        if (ptr_in) {\n            heaptrack.handleFree(ptr_in);\n        }\n        heaptrack.handleMalloc(ptr_out, size, trace);\n    }\n}\n\nextern "C" {\n\nvoid heaptrack_init(const char* outputFileName, heaptrack_callback_t initBeforeCallback,\n                    heaptrack_callback_initialized_t initAfterCallback, heaptrack_callback_t stopCallback)\n{\n    RecursionGuard guard;\n    // initialize\n    startTime();\n\n    debugLog<MinimalOutput>("heaptrack_init(%s)", outputFileName);\n\n    HeapTrack heaptrack(guard);\n    heaptrack.initialize(outputFileName, initBeforeCallback, initAfterCallback, stopCallback);\n}\n\nvoid heaptrack_stop()\n{\n    RecursionGuard guard;\n\n    debugLog<MinimalOutput>("%s", "heaptrack_stop()");\n\n    HeapTrack heaptrack(guard);\n\n    if (!s_atexit) {\n        s_forceCleanup.store(true);\n    }\n\n    heaptrack.shutdown();\n}\n\nvoid heaptrack_pause()\n{\n    HeapTrack::setPaused(true);\n}\n\nvoid heaptrack_resume()\n{\n    HeapTrack::setPaused(false);\n}\n\nvoid heaptrack_malloc(void* ptr, size_t size)\n{\n    if (!HeapTrack::isPaused() && ptr && !RecursionGuard::isActive) {\n        RecursionGuard guard;\n\n        debugLog<VeryVerboseOutput>("heaptrack_malloc(%p, %zu)", ptr, size);\n\n        Trace trace;\n        trace.fill(2 + HEAPTRACK_DEBUG_BUILD * 2);\n\n        HeapTrack heaptrack(guard);\n        heaptrack.handleMalloc(ptr, size, trace);\n    }\n}\n\nvoid heaptrack_free(void* ptr)\n{\n    if (!HeapTrack::isPaused() && ptr && !RecursionGuard::isActive) {\n        RecursionGuard guard;\n\n        debugLog<VeryVerboseOutput>("heaptrack_free(%p)", ptr);\n\n        HeapTrack heaptrack(guard);\n        heaptrack.handleFree(ptr);\n    }\n}\n\nvoid heaptrack_realloc(void* ptr_in, size_t size, void* ptr_out)\n{\n    heaptrack_realloc_impl(ptr_in, size, ptr_out);\n}\n\nvoid heaptrack_realloc2(uintptr_t ptr_in, size_t size, uintptr_t ptr_out)\n{\n    heaptrack_realloc_impl(reinterpret_cast<void*>(ptr_in), size, reinterpret_cast<void*>(ptr_out));\n}\n\nvoid heaptrack_invalidate_module_cache()\n{\n    RecursionGuard guard;\n\n    debugLog<VerboseOutput>("%s", "heaptrack_invalidate_module_cache()");\n\n    HeapTrack heaptrack(guard);\n    heaptrack.invalidateModuleCache();\n}\n\nvoid heaptrack_warning(heaptrack_warning_callback_t callback)\n{\n    RecursionGuard guard;\n\n    debugLog<WarningOutput>(callback);\n}\n}\n'