b'#include "stdafx.h"\n#include "FileDialog.h"\n#include "../libStringConverter/convert.h"\n#include <CommDlg.h>\n#include <ShlObj.h>\n#pragma comment(lib, "Shell32.lib")\n\n//for Windows XP\nbool testedFileDialog = false;\nbool useLegacyFileDialog = false;\n\nint GetFileTypeFilterCount(const wchar_t *filter)\n{\n\tint ret = 1;\n\tsize_t filterStringLen = wcslen(filter);\n\tfor (size_t i = 1; i < filterStringLen; i++)\n\t{\n\t\tif (filter[i] == L\':\')\n\t\t{\n\t\t\tif (filter[i-1] == L\'\\\\\') //allow usage of \':\' in text if a backslash prepends it\n\t\t\t\tcontinue;\n\t\t\tif ((i+1) < filterStringLen)\n\t\t\t\tret++;\n\t\t}\n\t}\n\treturn ret;\n}\n//also modifies the filter string for backslashes\nvoid GetNextFileFilterIndices(\n\twchar_t *filter,\n\tsize_t *pFilterStringLen, //don\'t always run wcslen(filter)\n\tsize_t curSpecStart, \n\tbool &hasName, bool &hasNextSpec,\n\tsize_t &curNameStart, size_t &nextSpecStart)\n{\n\tsize_t filterStringLen = *pFilterStringLen;\n\thasName = false; hasNextSpec = false;\n\tnextSpecStart = filterStringLen;\n\tfor (size_t _ch = curSpecStart; _ch < filterStringLen; _ch++)\n\t{\n\t\tif (!hasName && filter[_ch] == L\'|\')\n\t\t{\n\t\t\tcurNameStart = _ch+1;\n\t\t\thasName = true;\n\t\t}\n\t\tif (filter[_ch] == L\':\')\n\t\t{\n\t\t\tif (filter[_ch-1] != L\'\\\\\')\n\t\t\t{\n\t\t\t\tnextSpecStart = _ch;\n\t\t\t\thasNextSpec = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tfor (size_t _tmpch = _ch; _tmpch <= filterStringLen; _tmpch++)\n\t\t\t\t{\n\t\t\t\t\tfilter[_tmpch-1] = filter[_tmpch];\n\t\t\t\t}\n\t\t\t\t(*pFilterStringLen)--; //\n\t\t\t\tfilterStringLen--; //\n\t\t\t\tnextSpecStart--; //\n\t\t\t}\n\t\t}\n\t}\n}\n\n#pragma region Fallback\nstruct LegacyFileFilter\n{\n\twchar_t *name;\n\twchar_t *spec;\n};\ntypedef BOOL(WINAPI *prot_GetOpenFileNameW)(LPOPENFILENAMEW lpofn);\nprot_GetOpenFileNameW pGetOpenFileNameW = NULL;\ntypedef BOOL(WINAPI *prot_GetSaveFileNameW)(LPOPENFILENAMEW lpofn);\nprot_GetSaveFileNameW pGetSaveFileNameW = NULL;\n\ntypedef PIDLIST_ABSOLUTE(__stdcall *prot_SHBrowseForFolderW)(LPBROWSEINFOW lpbi);\nprot_SHBrowseForFolderW pSHBrowseForFolderW = NULL;\ntypedef BOOL(__stdcall *prot_SHGetPathFromIDListW)(PCIDLIST_ABSOLUTE pidl, LPWSTR pszPath);\nprot_SHGetPathFromIDListW pSHGetPathFromIDListW = NULL;\nvoid InitFileDialogFallback()\n{\n\tHMODULE hComdlg = GetModuleHandle(TEXT("Comdlg32.dll"));\n\tHMODULE hShell32 = GetModuleHandle(TEXT("Shell32.dll"));\n\tif (hComdlg == nullptr || hShell32 == nullptr)\n\t\treturn;\n\tpGetOpenFileNameW = (prot_GetOpenFileNameW)GetProcAddress(hComdlg, "GetOpenFileNameW");\n\tpGetSaveFileNameW = (prot_GetSaveFileNameW)GetProcAddress(hComdlg, "GetSaveFileNameW");\n\tpSHBrowseForFolderW = (prot_SHBrowseForFolderW)GetProcAddress(hShell32, "SHBrowseForFolderW");\n\tpSHGetPathFromIDListW = (prot_SHGetPathFromIDListW)GetProcAddress(hShell32, "SHGetPathFromIDListW");\n\tuseLegacyFileDialog = true;\n}\n\nbool MakeFileTypeFilterFallback(const wchar_t *_filter, wchar_t **_buf, int *_filterCount)\n{\n\tsize_t filterStringLen = wcslen(_filter);\n\n\twchar_t *filter = (wchar_t*)malloc(sizeof(wchar_t) * (filterStringLen+1));\n\tif (filter == NULL)\n\t\treturn false;\n\twcscpy_s(filter, filterStringLen+1, _filter);\n\n\tif (filterStringLen == 0 || filter[0] == L\':\')\n\t{\n\t\t*_buf = NULL;\n\t\t*_filterCount = 0;\n\t\treturn true;\n\t}\n\tint filterCount = GetFileTypeFilterCount(filter);\n\n\twchar_t *stringMap = (wchar_t*)malloc(sizeof(wchar_t) * (filterStringLen + 2 + filterCount));\n\tif (stringMap == NULL)\n\t{\n\t\tfree(filter);\n\t\treturn false;\n\t}\n\n\tsize_t curStrMapIndex = 0;\n\n\tsize_t curSpecStart = 0;\n\tsize_t curNameStart = 0;\n\tfor (int i = 0; i < filterCount; i++)\n\t{\n\t\tbool hasName = false; bool hasNextSpec = false;\n\t\tsize_t nextSpecStart = filterStringLen;\n\n\t\tGetNextFileFilterIndices(filter, &filterStringLen, curSpecStart, hasName, hasNextSpec, curNameStart, nextSpecStart);\n\t\t\n\t\tif (!hasName) curNameStart = curSpecStart;\n\n\t\tsize_t specSize = (hasName ? (curNameStart-1) : nextSpecStart) - curSpecStart;\n\t\tsize_t nameSize = nextSpecStart - curNameStart;\n\t\t\n\t\tif (hasName)\n\t\t{\n\t\t\twcsncpy_s(&stringMap[curStrMapIndex], nameSize+1, &filter[curNameStart], nameSize);\n\t\t\tstringMap[curStrMapIndex+nameSize] = 0;\n\t\t\tcurStrMapIndex += (nameSize + 1);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tstringMap[curStrMapIndex] = L\' \';\n\t\t\tstringMap[curStrMapIndex+1] = 0;\n\t\t\tcurStrMapIndex += 2;\n\t\t}\n\n\t\twcsncpy_s(&stringMap[curStrMapIndex], specSize+1, &filter[curSpecStart], specSize);\n\t\tstringMap[curStrMapIndex+specSize] = 0;\n\t\tcurStrMapIndex += (specSize + 1);\n\n\t\tif ((i+1) < filterCount && !hasNextSpec)\n\t\t\tfilterCount = i+1;\n\t\tif (!hasNextSpec)\n\t\t\tbreak;\n\t\tcurSpecStart = nextSpecStart + 1;\n\t}\n\tstringMap[curStrMapIndex] = stringMap[curStrMapIndex+1] = 0;\n\t\n\tfree(filter);\n\t*_buf = stringMap;\n\t*_filterCount = filterCount;\n\treturn true;\n}\nvoid FreeFileTypeFilterFallback(wchar_t **buf)\n{\n\tif (buf != NULL && *buf != NULL)\n\t{\n\t\tfree(*buf);\n\t\t*buf = NULL;\n\t}\n}\n\nHRESULT MakeFileDialogStructureFallback(OPENFILENAMEW *out, \n\tHWND hOwner, wchar_t **filePathBuf, wchar_t *pFilters, int filterCount, LPCWSTR defaultFile,\n\tsize_t pathBufferLen = MAX_PATH+1)\n{\n\tsize_t defaultFileNameLen = (defaultFile != NULL) ? (wcslen(defaultFile)+1) : 1;\n\tif (pathBufferLen < defaultFileNameLen)\n\t\tpathBufferLen = defaultFileNameLen;\n\t*filePathBuf = (wchar_t*)malloc(sizeof(wchar_t) * pathBufferLen);\n\tif (*filePathBuf == NULL)\n\t\treturn E_OUTOFMEMORY;\n\n\tif (defaultFile)\n\t\tmemcpy(*filePathBuf, defaultFile, defaultFileNameLen * sizeof(wchar_t));\n\telse\n\t\tmemset(*filePathBuf, 0, sizeof(wchar_t) * pathBufferLen);//(*filePathBuf)[0] = 0;\n\n\tZeroMemory(out, sizeof(OPENFILENAMEW));\n\tout->lStructSize = sizeof(OPENFILENAMEW);\n\tout->hwndOwner = hOwner;\n\tout->lpstrFilter = pFilters;\n\tout->nFilterIndex = 1;\n\tout->lpstrFile = *filePathBuf;\n\tout->nMaxFile = (DWORD)pathBufferLen;\n\tout->Flags = OFN_EXPLORER | OFN_HIDEREADONLY;\n\t//out->lpstrInitialDir = &fallback_nullChar;\n\n\treturn NOERROR;\n}\n#define FNERR_BUFFERTOOSMALL 0x3003\nHRESULT ShowFileOpenDialogFallback(HWND hOwner, wchar_t **filePathBuf, const wchar_t *fileTypeFilter, UINT *pOutSelFilter, LPCTSTR defaultFile, LPCTSTR windowTitle)\n{\n\tif (pGetOpenFileNameW == NULL)\n\t{\n\t\tMessageBox(hOwner, TEXT("Unable to open a file dialog (fallback method failed)!"), TEXT("Error"), MB_ICONERROR);\n\t\treturn E_NOTIMPL;\n\t}\n\tif (pOutSelFilter)\n\t\t*pOutSelFilter = (UINT)-1;\n\twchar_t *pFilters; int filterCount;\n\tif (!MakeFileTypeFilterFallback(fileTypeFilter, &pFilters, &filterCount))\n\t\treturn E_OUTOFMEMORY;\n\tOPENFILENAMEW fileNameStruct;\n\n\tHRESULT ret = NOERROR;\n\tsize_t pathBufferLen = MAX_PATH+1;\n\twhile ((ret = MakeFileDialogStructureFallback(&fileNameStruct, hOwner, filePathBuf, \n\t\tpFilters, filterCount, defaultFile, pathBufferLen)) != E_OUTOFMEMORY)\n\t{\n\t\tfileNameStruct.Flags |= OFN_FILEMUSTEXIST;\n\t\tif (windowTitle != NULL)\n\t\t\tfileNameStruct.lpstrTitle = windowTitle;\n\t\tif (!pGetOpenFileNameW(&fileNameStruct))\n\t\t{\n\t\t\tfree(*filePathBuf);\n\t\t\t*filePathBuf = NULL;\n\t\t\tDWORD error = CommDlgExtendedError();\n\t\t\tif (error == FNERR_BUFFERTOOSMALL)\n\t\t\t{\n\t\t\t\tpathBufferLen = *(unsigned short*)fileNameStruct.lpstrFile;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tret = E_FAIL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (pOutSelFilter)\n\t\t\t\t*pOutSelFilter = fileNameStruct.nFilterIndex;\n\t\t\tbreak;\n\t\t}\n\t}\n\tFreeFileTypeFilterFallback(&pFilters);\n\treturn ret;\n}\n\nHRESULT ShowFileSaveDialogFallback(HWND hOwner, wchar_t **filePathBuf, const wchar_t *fileTypeFilter, UINT *pOutSelFilter, LPCWSTR defaultFile, LPCTSTR windowTitle)\n{\n\tif (pGetSaveFileNameW == NULL)\n\t{\n\t\tMessageBox(hOwner, TEXT("Unable to open a file dialog (fallback method failed)!"), TEXT("Error"), MB_ICONERROR);\n\t\treturn E_NOTIMPL;\n\t}\n\tif (pOutSelFilter)\n\t\t*pOutSelFilter = (UINT)-1;\n\twchar_t *pFilters; int filterCount;\n\tif (!MakeFileTypeFilterFallback(fileTypeFilter, &pFilters, &filterCount))\n\t\treturn E_OUTOFMEMORY;\n\tOPENFILENAMEW fileNameStruct;\n\n\tHRESULT ret = NOERROR;\n\tsize_t pathBufferLen = MAX_PATH+1;\n\twhile ((ret = MakeFileDialogStructureFallback(&fileNameStruct, hOwner, filePathBuf,\n\t\tpFilters, filterCount, defaultFile, pathBufferLen)) != E_OUTOFMEMORY)\n\t{\n\t\tfileNameStruct.Flags |= OFN_CREATEPROMPT;\n\t\tif (windowTitle != NULL)\n\t\t\tfileNameStruct.lpstrTitle = windowTitle;\n\t\tif (!pGetSaveFileNameW(&fileNameStruct))\n\t\t{\n\t\t\tfree(*filePathBuf);\n\t\t\t*filePathBuf = NULL;\n\t\t\tDWORD error = CommDlgExtendedError();\n\t\t\tif (error == FNERR_BUFFERTOOSMALL)\n\t\t\t{\n\t\t\t\tpathBufferLen = *(unsigned short*)fileNameStruct.lpstrFile;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tret = E_FAIL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (pOutSelFilter)\n\t\t\t\t*pOutSelFilter = fileNameStruct.nFilterIndex;\n\t\t\tbreak;\n\t\t}\n\t}\n\tFreeFileTypeFilterFallback(&pFilters);\n\treturn ret;\n}\nHRESULT ShowFileOpenDialogMultiSelectFallback(HWND hOwner, WCHAR **filePathsBuf, const wchar_t *fileTypeFilter, UINT *pOutSelFilter, LPCTSTR defaultFile, LPCTSTR windowTitle)\n{\n\tif (pGetOpenFileNameW == NULL)\n\t{\n\t\tMessageBox(hOwner, TEXT("Unable to open a file dialog (fallback method failed)!"), TEXT("Error"), MB_ICONERROR);\n\t\treturn E_NOTIMPL;\n\t}\n\tif (pOutSelFilter)\n\t\t*pOutSelFilter = (UINT)-1;\n\twchar_t *pFilters; int filterCount;\n\tif (!MakeFileTypeFilterFallback(fileTypeFilter, &pFilters, &filterCount))\n\t\treturn E_OUTOFMEMORY;\n\tOPENFILENAMEW fileNameStruct;\n\n\tHRESULT ret = NOERROR;\n\tsize_t pathBufferLen = (MAX_PATH+1)*16+1;\n\twhile ((ret = MakeFileDialogStructureFallback(&fileNameStruct, hOwner, filePathsBuf, pFilters, \n\t\tfilterCount, defaultFile, pathBufferLen)) != E_OUTOFMEMORY)\n\t{\n\t\tfileNameStruct.Flags |= OFN_FILEMUSTEXIST | OFN_ALLOWMULTISELECT;\n\t\tif (windowTitle != NULL)\n\t\t\tfileNameStruct.lpstrTitle = windowTitle;\n\t\tif (!pGetOpenFileNameW(&fileNameStruct))\n\t\t{\n\t\t\tfree(*filePathsBuf);\n\t\t\t*filePathsBuf = NULL;\n\t\t\tDWORD error = CommDlgExtendedError();\n\t\t\tif (error == FNERR_BUFFERTOOSMALL)\n\t\t\t{\n\t\t\t\tif (pathBufferLen > *(unsigned short*)fileNameStruct.lpstrFile)\n\t\t\t\t\tpathBufferLen += (MAX_PATH+1)*16;\n\t\t\t\telse\n\t\t\t\t\tpathBufferLen = *(unsigned short*)fileNameStruct.lpstrFile;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tret = E_FAIL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (pOutSelFilter)\n\t\t\t\t*pOutSelFilter = fileNameStruct.nFilterIndex;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (ret == NOERROR && *filePathsBuf)\n\t{\n\t\tsize_t requiredLen = 0;\n\t\tsize_t directoryLen = wcslen(*filePathsBuf);\n\t\tif (directoryLen)\n\t\t{\n\t\t\tsize_t curStrIndex = 0; size_t curStrLen;\n\t\t\twhile ((curStrLen = wcslen(&(*filePathsBuf)[directoryLen+1+curStrIndex])))\n\t\t\t{\n\t\t\t\tcurStrIndex += curStrLen + 1;\n\t\t\t\trequiredLen += directoryLen + 1 + curStrLen + 1;\n\t\t\t}\n\t\t\tif (curStrIndex == 0)\n\t\t\t{\n\t\t\t\tFreeFileTypeFilterFallback(&pFilters);\n\t\t\t\treturn NOERROR;\n\t\t\t}\n\t\t}\n\t\tWCHAR *wFilePathsList = (WCHAR*)malloc((requiredLen+1) * sizeof(WCHAR)); size_t curOutStrIndex = 0;\n\t\tif (!wFilePathsList)\n\t\t{\n\t\t\tfree(*filePathsBuf);\n\t\t\tFreeFileTypeFilterFallback(&pFilters);\n\t\t\treturn E_OUTOFMEMORY;\n\t\t}\n\t\tsize_t curStrIndex = 0; size_t curStrLen;\n\t\twhile ((curStrLen = wcslen(&(*filePathsBuf)[directoryLen+1+curStrIndex])))\n\t\t{\n\t\t\tmemcpy(&wFilePathsList[curOutStrIndex], *filePathsBuf, directoryLen * sizeof(WCHAR));\n\t\t\twFilePathsList[curOutStrIndex + directoryLen] = L\'\\\\\';\n\t\t\tmemcpy(&wFilePathsList[curOutStrIndex + directoryLen + 1], \n\t\t\t\t&(*filePathsBuf)[directoryLen+1+curStrIndex], curStrLen * sizeof(WCHAR));\n\t\t\twFilePathsList[curOutStrIndex + directoryLen + 1 + curStrLen] = L\';\';\n\t\t\tcurStrIndex += curStrLen + 1;\n\t\t\tcurOutStrIndex += directoryLen + 1 + curStrLen + 1;\n\t\t}\n\t\tif (!curOutStrIndex)\n\t\t\twFilePathsList[0] = 0;\n\t\telse\n\t\t\twFilePathsList[curOutStrIndex - 1] = 0;\n\t\tfree(*filePathsBuf);\n\t\t*filePathsBuf = wFilePathsList;\n\t}\n\tFreeFileTypeFilterFallback(&pFilters);\n\treturn ret;\n}\n\nBOOL ShowFolderSelectDialogFallback(HWND hOwner, WCHAR **folderPathBuf, LPCWSTR windowTitle)\n{\n\tif (pSHBrowseForFolderW == NULL\n\t\t|| pSHGetPathFromIDListW == NULL)\n\t{\n\t\tMessageBox(hOwner, TEXT("Unable to open a file dialog (fallback method failed)!"), TEXT("Error"), MB_ICONERROR);\n\t\treturn FALSE;\n\t}\n\tLPITEMIDLIST pItemIDList = NULL;\n\tBROWSEINFOW bi; memset(&bi, 0, sizeof(BROWSEINFOW));\n\tBOOL ret = FALSE;\n\n\tWCHAR *folderPath = (WCHAR*)malloc(MAX_PATH * sizeof(WCHAR));\n\tif (folderPath == NULL)\n\t\treturn FALSE;\n\t*folderPathBuf = folderPath;\n\tfolderPath[0] = 0;\n\n\tbi.hwndOwner = hOwner;\n\tbi.pszDisplayName = folderPath;\n\tbi.pidlRoot = NULL;\n\tbi.lpszTitle = windowTitle;\n\tbi.ulFlags = BIF_RETURNONLYFSDIRS | BIF_USENEWUI;\n\t\n\tif ((pItemIDList = pSHBrowseForFolderW(&bi)) != NULL)\n\t{\n\t\tret = pSHGetPathFromIDListW(pItemIDList, folderPath);\n\t\tCoTaskMemFree(pItemIDList);\n\t}\n\tif (!ret)\n\t{\n\t\t*folderPathBuf = NULL;\n\t\tfree(folderPath);\n\t}\n\n\treturn ret;\n}\n#pragma endregion\n\nbool MakeFileTypeFilter(const wchar_t *_filter, COMDLG_FILTERSPEC **_buf, int *_filterCount)\n{\n\tsize_t filterStringLen = wcslen(_filter);\n\n\twchar_t *filter = (wchar_t*)malloc(sizeof(wchar_t) * (filterStringLen+1));\n\tif (filter == NULL)\n\t\treturn false;\n\twcscpy_s(filter, filterStringLen+1, _filter);\n\n\tif (filterStringLen == 0 || filter[0] == L\':\')\n\t{\n\t\t*_buf = NULL;\n\t\t*_filterCount = 0;\n\t\treturn true;\n\t}\n\tint filterCount = GetFileTypeFilterCount(filter);\n\n\t//create a buffer that can at least hold all filterspecs + all strings\n\tuint8_t *filterMem = (uint8_t*)malloc(sizeof(COMDLG_FILTERSPEC) * (size_t)filterCount + 2 * (sizeof(wchar_t) * filterStringLen) + (size_t)filterCount);\n\tif (filterMem == NULL)\n\t{\n\t\tfree(filter);\n\t\treturn false;\n\t}\n\n\tCOMDLG_FILTERSPEC *filterArray = (COMDLG_FILTERSPEC*)filterMem;\n\twchar_t *stringMap = (wchar_t*)&filterMem[sizeof(COMDLG_FILTERSPEC) * (size_t)filterCount]; \n\n\tsize_t curStrMapIndex = 0;\n\n\tsize_t curSpecStart = 0;\n\tsize_t curNameStart = 0;\n\tfor (int i = 0; i < filterCount; i++)\n\t{\n\t\tbool hasName = false; bool hasNextSpec = false;\n\t\tsize_t nextSpecStart = filterStringLen;\n\n\t\tGetNextFileFilterIndices(filter, &filterStringLen, curSpecStart, hasName, hasNextSpec, curNameStart, nextSpecStart);\n\t\t\n\t\tif (!hasName) curNameStart = curSpecStart;\n\n\t\tsize_t specSize = (hasName ? (curNameStart-1) : nextSpecStart) - curSpecStart;\n\t\tsize_t nameSize = nextSpecStart - curNameStart;\n\t\t\n\t\tfilterArray[i].pszSpec = &stringMap[curStrMapIndex];\n\t\twcsncpy_s(&stringMap[curStrMapIndex], specSize+1, &filter[curSpecStart], specSize);\n\t\tstringMap[curStrMapIndex+specSize] = 0;\n\t\tcurStrMapIndex += (specSize + 1);\n\n\t\tif (hasName)\n\t\t{\n\t\t\tfilterArray[i].pszName = &stringMap[curStrMapIndex];\n\t\t\twcsncpy_s(&stringMap[curStrMapIndex], nameSize+1, &filter[curNameStart], nameSize);\n\t\t\tstringMap[curStrMapIndex+nameSize] = 0;\n\t\t\tcurStrMapIndex += (nameSize + 1);\n\t\t}\n\t\telse\n\t\t\tfilterArray[i].pszName = filterArray[i].pszSpec;\n\n\t\tif ((i+1) < filterCount && !hasNextSpec)\n\t\t\tfilterCount = i+1;\n\t\tif (!hasNextSpec)\n\t\t\tbreak;\n\t\tcurSpecStart = nextSpecStart + 1;\n\t}\n\t\n\tfree(filter);\n\t*_buf = filterArray;\n\t*_filterCount = filterCount;\n\treturn true;\n}\nvoid FreeFileTypeFilter(COMDLG_FILTERSPEC **buf)\n{\n\tif (buf != NULL && *buf != NULL)\n\t{\n\t\tfree(*buf);\n\t\t*buf = NULL;\n\t}\n}\n\nbool TestFileDialogCompatible()\n{\n\tif (!testedFileDialog)\n\t{\n\t\tIFileDialog *pfd = NULL;\n\t\tHRESULT hr = CoCreateInstance(CLSID_FileSaveDialog, \n\t\t\tNULL, \n\t\t\tCLSCTX_INPROC_SERVER, \n\t\t\tIID_PPV_ARGS(&pfd));\n\t\tif (!SUCCEEDED(hr))\n\t\t\tInitFileDialogFallback();\n\t\telse\n\t\t\tpfd->Release();\n\t\ttestedFileDialog = true;\n\t}\n\treturn !useLegacyFileDialog;\n}\n\nHRESULT ShowFileOpenDialog(HWND hOwner, wchar_t **filePathBuf, const wchar_t *fileTypeFilter,\n\tUINT *pOutSelFilter, LPCTSTR defaultFile, LPCTSTR windowTitle,\n\tconst GUID& guid)\n{\n\tif (!TestFileDialogCompatible())\n\t\treturn ShowFileOpenDialogFallback(hOwner, filePathBuf, fileTypeFilter, pOutSelFilter, defaultFile, windowTitle);\n\tCOMDLG_FILTERSPEC *pFilters; int filterCount;\n\tif (!MakeFileTypeFilter(fileTypeFilter, &pFilters, &filterCount))\n\t\treturn E_OUTOFMEMORY;\n\tHRESULT ret = ShowFileDialog(hOwner, filePathBuf, CLSID_FileOpenDialog, pFilters, filterCount, pOutSelFilter, defaultFile, windowTitle, guid);\n\tFreeFileTypeFilter(&pFilters);\n\treturn ret;\n}\n\nHRESULT ShowFileOpenDialogMultiSelect(HWND hOwner,\n\tWCHAR ***filePathsBuf, size_t *filePathCountBuf,\n\tconst wchar_t *fileTypeFilter, UINT *pOutSelFilter,\n\tLPCTSTR defaultFile, LPCTSTR windowTitle,\n\tconst GUID& guid);\nHRESULT ShowFileOpenDialogMultiSelect(HWND hOwner, std::vector<char*> &filePathsBuf,\n\tconst char *fileTypeFilter, UINT *pOutSelFilter,\n\tconst char* defaultFile, const char* windowTitle,\n\tconst GUID& guid)\n{\n\tsize_t strLenW;\n\tTCHAR *defaultFileT = _MultiByteToTCHAR(defaultFile, strLenW);\n\tTCHAR *windowTitleT = _MultiByteToTCHAR(windowTitle, strLenW);\n\tTCHAR *fileTypeFilterW = _MultiByteToWide(fileTypeFilter, strLenW);\n\tHRESULT result;\n\tif (!TestFileDialogCompatible())\n\t{\n\t\tWCHAR *filePathsW = nullptr;\n\t\tresult = ShowFileOpenDialogMultiSelectFallback(hOwner, &filePathsW, fileTypeFilterW, pOutSelFilter, defaultFileT, windowTitleT);\n\t\tif (SUCCEEDED(result) && filePathsW[0] != 0)\n\t\t{\n\t\t\tsize_t filePathsLenW = wcslen(filePathsW);\n\t\t\tsize_t filePathsLen = (size_t)WideCharToMultiByte(CP_UTF8, 0, filePathsW, (int)filePathsLenW, NULL, 0, NULL, NULL);\n\t\t\tchar *filePaths = new char[filePathsLen + 1];\n\t\t\tWideCharToMultiByte(CP_UTF8, 0, filePathsW, (int)filePathsLenW, filePaths, (int)filePathsLen, NULL, NULL);\n\t\t\tfilePaths[filePathsLen] = 0;\n\t\t\tfor (size_t i = 0, start = 0; i <= filePathsLen; i++)\n\t\t\t{\n\t\t\t\tif (filePaths[i] == L\';\' || filePaths[i] == 0)\n\t\t\t\t{\n\t\t\t\t\tfilePaths[i] = 0;\n\t\t\t\t\tfilePathsBuf.push_back(&filePaths[start]);\n\t\t\t\t\tstart = i + 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (filePathsBuf.size() == 0)\n\t\t\t\tdelete[] filePaths;\n\t\t}\n\t}\n\telse\n\t{\n\t\tWCHAR **filePathsArray; size_t filePathsCount;\n\t\tresult = ShowFileOpenDialogMultiSelect(hOwner, &filePathsArray, &filePathsCount, fileTypeFilterW, pOutSelFilter, defaultFileT, windowTitleT, guid);\n\t\tif (SUCCEEDED(result) && filePathsCount > 0)\n\t\t{\n\t\t\tsize_t totalLen = 0;\n\t\t\tfilePathsBuf.resize(filePathsCount + 1);\n\t\t\tfor (size_t i = 0; i < filePathsCount; i++)\n\t\t\t{\n\t\t\t\tsize_t pathLenW = wcslen(filePathsArray[i]);\n\t\t\t\tif (pathLenW > INT_MAX) pathLenW = INT_MAX;\n\t\t\t\tsize_t curBufferLen = (size_t)(WideCharToMultiByte(CP_UTF8, 0, filePathsArray[i], (int)pathLenW, NULL, 0, NULL, NULL) + 1) * sizeof(char);\n\t\t\t\tfilePathsBuf[i] = (char*)totalLen;\n\t\t\t\ttotalLen += curBufferLen;\n\t\t\t}\n\t\t\tfilePathsBuf[filePathsCount] = (char*)totalLen;\n\t\t\tchar *filePaths = new char[totalLen + 1];\n\t\t\tfor (size_t i = 0; i < filePathsCount; i++)\n\t\t\t{\n\t\t\t\tsize_t pathLenW = wcslen(filePathsArray[i]);\n\t\t\t\tif (pathLenW > INT_MAX) pathLenW = INT_MAX;\n\n\t\t\t\tint outLen = (int)(filePathsBuf[i+1] - filePathsBuf[i]);\n\t\t\t\tfilePathsBuf[i] = &filePaths[(size_t)filePathsBuf[i]];\n\t\t\t\tWideCharToMultiByte(CP_UTF8, 0, filePathsArray[i], (int)pathLenW, filePathsBuf[i], outLen - 1, NULL, NULL);\n\t\t\t\tfilePathsBuf[i][outLen - 1] = 0;\n\t\t\t}\n\t\t\tfilePathsBuf.resize(filePathsCount);\n\t\t\tfor (size_t i = 0; i < filePathsCount; i++)\n\t\t\t\tFreeCOMFilePathBuf(&filePathsArray[i]);\n\t\t\tdelete[] filePathsArray;\n\t\t}\n\t}\n\t_FreeWCHAR(fileTypeFilterW);\n\t_FreeTCHAR(windowTitleT);\n\t_FreeTCHAR(defaultFileT);\n\treturn result;\n}\nvoid FreeFilePathsMultiSelect(std::vector<char*> &filePathsBuf)\n{\n\tif (filePathsBuf.size() > 0)\n\t\tdelete[] filePathsBuf[0];\n\tfilePathsBuf.clear();\n}\nHRESULT ShowFileOpenDialogMultiSelect(HWND hOwner, WCHAR **filePathsBuf,\n\tconst wchar_t *fileTypeFilter, UINT *pOutSelFilter,\n\tLPCTSTR defaultFile, LPCTSTR windowTitle,\n\tconst GUID &guid)\n{\n\tif (!TestFileDialogCompatible())\n\t\treturn ShowFileOpenDialogMultiSelectFallback(hOwner, filePathsBuf, fileTypeFilter, pOutSelFilter, defaultFile, windowTitle);\n\tWCHAR **filePathsArray; size_t filePathsCount;\n\t*filePathsBuf = NULL;\n\tHRESULT ret = ShowFileOpenDialogMultiSelect(hOwner, &filePathsArray, &filePathsCount, fileTypeFilter, pOutSelFilter, defaultFile, windowTitle, guid);\n\tif (!SUCCEEDED(ret))\n\t\treturn ret;\n\tsize_t resultSize = 0;\n\tfor (size_t i = 0; i < filePathsCount; i++)\n\t\tresultSize += wcslen(filePathsArray[i]) + 1;\n\tif (!resultSize) resultSize = 1;\n\t*filePathsBuf = new WCHAR[resultSize];\n\tsize_t resultOffset = 0;\n\tfor (size_t i = 0; i < filePathsCount; i++)\n\t{\n\t\tsize_t curSize = (filePathsArray[i] != NULL) ? wcslen(filePathsArray[i]) : 0;\n\t\tmemcpy(&(*filePathsBuf)[resultOffset], filePathsArray[i], curSize * sizeof(WCHAR));\n\t\t(*filePathsBuf)[resultOffset + curSize] = L\';\';\n\t\tresultOffset += curSize + 1;\n\t}\n\t(*filePathsBuf)[resultSize - 1] = 0;\n\tfor (size_t i = 0; i < filePathsCount; i++)\n\t\tFreeCOMFilePathBuf(&filePathsArray[i]);\n\tdelete[] filePathsArray;\n\treturn ret;\n}\nHRESULT ShowFileOpenDialogMultiSelect(HWND hOwner,\n\tWCHAR ***filePathsBuf, size_t *filePathCountBuf,\n\tconst wchar_t *fileTypeFilter, UINT *pOutSelFilter,\n\tLPCTSTR defaultFile, LPCTSTR windowTitle,\n\tconst GUID& guid)\n{\n\tif (pOutSelFilter)\n\t\t*pOutSelFilter = (UINT)-1;\n\tCOMDLG_FILTERSPEC *pFilters; int filterCount;\n\tif (!MakeFileTypeFilter(fileTypeFilter, &pFilters, &filterCount))\n\t\treturn E_OUTOFMEMORY;\n\t*filePathsBuf = NULL; *filePathCountBuf = 0;\n\tIFileOpenDialog *pfd = NULL;\n\tHRESULT hr = CoCreateInstance(CLSID_FileOpenDialog, \n\t\tNULL, \n\t\tCLSCTX_INPROC_SERVER, \n\t\tIID_PPV_ARGS(&pfd));\n\tif (SUCCEEDED(hr))\n\t{\n\t\tpfd->SetClientGuid(guid);\n\t\tDWORD dwOptions;\n\t\thr = pfd->GetOptions(&dwOptions);\n\t\tif (SUCCEEDED(hr) && SUCCEEDED((hr = pfd->SetOptions(dwOptions | FOS_ALLOWMULTISELECT))))\n\t\t{\n\t\t\tif (windowTitle != NULL)\n\t\t\t\tpfd->SetTitle(windowTitle);\n\t\t\thr = pfd->SetFileTypes(filterCount, pFilters);\n\t\t\tif (SUCCEEDED(hr))\n\t\t\t{\n\t\t\t\thr = pfd->SetFileTypeIndex(0);\n\t\t\t\tif (defaultFile != NULL)\n\t\t\t\t\tpfd->SetFileName(defaultFile);\n\t\t\t\tif (SUCCEEDED(hr))\n\t\t\t\t{\n\t\t\t\t\thr = pfd->Show(hOwner);\n\t\t\t\t\tif (SUCCEEDED(hr))\n\t\t\t\t\t{\n\t\t\t\t\t\tIShellItemArray *pFileItems;\n\t\t\t\t\t\thr = pfd->GetResults(&pFileItems);\n\t\t\t\t\t\tif (SUCCEEDED(hr))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tDWORD numItems;\n\t\t\t\t\t\t\thr = pFileItems->GetCount(&numItems);\n\t\t\t\t\t\t\tif (SUCCEEDED(hr))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif (pOutSelFilter)\n\t\t\t\t\t\t\t\t\tpfd->GetFileTypeIndex(pOutSelFilter);\n\t\t\t\t\t\t\t\t*filePathsBuf = new WCHAR*[numItems](); *filePathCountBuf = numItems;\n\t\t\t\t\t\t\t\tfor (DWORD i = 0; i < numItems; i++)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t(*filePathsBuf)[i] = NULL;\n\t\t\t\t\t\t\t\t\tIShellItem *pFileItem = NULL;\n\t\t\t\t\t\t\t\t\tif (SUCCEEDED(pFileItems->GetItemAt(i, &pFileItem)))\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tWCHAR *filePath;\n\t\t\t\t\t\t\t\t\t\thr = pFileItem->GetDisplayName(SIGDN_FILESYSPATH, &filePath);\n\t\t\t\t\t\t\t\t\t\tif (SUCCEEDED(hr))\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t(*filePathsBuf)[i] = filePath;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tpFileItem->Release();\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\thr = 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tpFileItems->Release();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tpfd->Release();\n\t}\n\tFreeFileTypeFilter(&pFilters);\n\treturn hr;\n}\n\nHRESULT ShowFileSaveDialog(HWND hOwner, wchar_t **filePathBuf,\n\tconst wchar_t *fileTypeFilter, UINT *pOutSelFilter,\n\tLPCTSTR defaultFile, LPCTSTR windowTitle,\n\tconst GUID &guid)\n{\n\tif (!TestFileDialogCompatible())\n\t\treturn ShowFileSaveDialogFallback(hOwner, filePathBuf, fileTypeFilter, pOutSelFilter, defaultFile, windowTitle);\n\tCOMDLG_FILTERSPEC *pFilters; int filterCount;\n\tif (!MakeFileTypeFilter(fileTypeFilter, &pFilters, &filterCount))\n\t\treturn E_OUTOFMEMORY;\n\tHRESULT ret = ShowFileDialog(hOwner, filePathBuf, CLSID_FileSaveDialog, pFilters, filterCount, pOutSelFilter, defaultFile, windowTitle, guid);\n\tFreeFileTypeFilter(&pFilters);\n\treturn ret;\n}\n\nHRESULT ShowFileDialog(HWND hOwner, wchar_t **filePathBuf,\n\tCLSID dialogClass,\n\tconst COMDLG_FILTERSPEC *pFilters, int filtersCount, UINT *pOutSelFilter,\n\tLPCTSTR defaultFile, LPCTSTR windowTitle,\n\tconst GUID& guid)\n{\n\tif (pOutSelFilter)\n\t\t*pOutSelFilter = (UINT)-1;\n\tif (!TestFileDialogCompatible())\n\t\treturn E_NOTIMPL;\n\t*filePathBuf = NULL;\n\tIFileDialog *pfd = NULL;\n\tHRESULT hr = CoCreateInstance(dialogClass, \n\t\tNULL, \n\t\tCLSCTX_INPROC_SERVER, \n\t\tIID_PPV_ARGS(&pfd));\n\tif (SUCCEEDED(hr))\n\t{\n\t\tpfd->SetClientGuid(guid);\n\t\tif (windowTitle != NULL)\n\t\t\tpfd->SetTitle(windowTitle);\n\t\thr = pfd->SetFileTypes(filtersCount, pFilters);\n\t\tif (SUCCEEDED(hr))\n\t\t{\n\t\t\thr = pfd->SetFileTypeIndex(0);\n\t\t\tif (defaultFile != NULL)\n\t\t\t\tpfd->SetFileName(defaultFile);\n\t\t\tif (SUCCEEDED(hr))\n\t\t\t{\n\t\t\t\thr = pfd->Show(hOwner);\n\t\t\t\tif (SUCCEEDED(hr))\n\t\t\t\t{\n\t\t\t\t\tIShellItem *pFileItem;\n\t\t\t\t\thr = pfd->GetResult(&pFileItem);\n\t\t\t\t\tif (SUCCEEDED(hr))\n\t\t\t\t\t{\n\t\t\t\t\t\tWCHAR *filePath;\n\t\t\t\t\t\thr = pFileItem->GetDisplayName(SIGDN_FILESYSPATH, &filePath);\n\t\t\t\t\t\tif (SUCCEEDED(hr))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (pOutSelFilter)\n\t\t\t\t\t\t\t\tpfd->GetFileTypeIndex(pOutSelFilter);\n\t\t\t\t\t\t\t*filePathBuf = filePath;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tpFileItem->Release();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tpfd->Release();\n\t}\n\treturn hr;\n}\nHRESULT ShowPickFolderDialog(HWND hOwner, wchar_t **folderPathBuf, CLSID dialogClass, LPCWSTR windowTitle,\n\tconst GUID& guid)\n{\n\tif (!TestFileDialogCompatible())\n\t\treturn E_NOTIMPL;\n\t*folderPathBuf = NULL;\n\tIFileDialog *pfd = NULL;\n\tHRESULT hr = CoCreateInstance(dialogClass, \n\t\tNULL, \n\t\tCLSCTX_INPROC_SERVER, \n\t\tIID_PPV_ARGS(&pfd));\n\tif (SUCCEEDED(hr))\n\t{\n\t\tpfd->SetClientGuid(guid);\n\t\tDWORD dwOptions;\n\t\tif (SUCCEEDED(pfd->GetOptions(&dwOptions)))\n\t\t{\n\t\t\tpfd->SetOptions(dwOptions | FOS_PICKFOLDERS);\n\t\t}\n\t\tif (windowTitle != NULL)\n\t\t\tpfd->SetTitle(windowTitle);\n\t\thr = pfd->Show(hOwner);\n\t\tif (SUCCEEDED(hr))\n\t\t{\n\t\t\tIShellItem *pFileItem;\n\t\t\thr = pfd->GetResult(&pFileItem);\n\t\t\tif (SUCCEEDED(hr))\n\t\t\t{\n\t\t\t\tWCHAR *filePath;\n\t\t\t\thr = pFileItem->GetDisplayName(SIGDN_FILESYSPATH, &filePath);\n\t\t\t\tif (SUCCEEDED(hr))\n\t\t\t\t{\n\t\t\t\t\t*folderPathBuf = filePath;\n\t\t\t\t}\n\t\t\t\tpFileItem->Release();\n\t\t\t}\n\t\t}\n\t\tpfd->Release();\n\t}\n\treturn hr;\n}\n\nBOOL ShowFolderSelectDialog(HWND hOwner, WCHAR **folderPathBuf, LPCWSTR windowTitle, const GUID &guid)\n{\n\tif (!TestFileDialogCompatible())\n\t\treturn ShowFolderSelectDialogFallback(hOwner, folderPathBuf, windowTitle);\n\treturn SUCCEEDED(ShowPickFolderDialog(hOwner, folderPathBuf, CLSID_FileOpenDialog, windowTitle, guid));\n}\n\nvoid FreeCOMFilePathBuf(WCHAR **filePath)\n{\n\tif (useLegacyFileDialog)\n\t{\n\t\tif (filePath != NULL && *filePath != NULL)\n\t\t{\n\t\t\tfree(*filePath);\n\t\t\t*filePath = NULL;\n\t\t}\n\t}\n\telse if (filePath != NULL && *filePath != NULL)\n\t{\n\t\tCoTaskMemFree(*filePath);\n\t\t*filePath = NULL;\n\t}\n}'