b'import Data.List\r\n\r\nmaxtail :: Ord a => [a] -> [a]\r\nmaxtail = foldl op []\r\n\r\nop :: Ord a => [a] -> a -> [a]\r\nop ys x = maximum [zs ++ [x] | zs <- borders ys]\r\n\r\n-- Borders\r\n\r\nborders :: Ord a => [a] -> [[a]]\r\nborders [] = [[]]\r\nborders xs = xs : borders (border xs)\r\n\r\n-- Border\r\n\r\nafter :: Eq a => [a] -> [a] -> [a]\r\nafter [] ys = ys\r\nafter xs [] = xs\r\nafter (x:xs) (y:ys) \r\n    | x == y = after xs ys\r\n    | otherwise = (x:xs)\r\n\r\nbefore :: Eq a => [a] -> [a] -> [a]\r\nbefore xs ys = reverse $ after (reverse xs) (reverse ys)\r\n\r\nborder :: Ord a => [a] -> [a]\r\nborder xs\r\n    | xs == []                  = []\r\n    | length(xs) == 1           = []\r\n    | ys_after_zs == []         = []\r\n    | head(ys_after_zs) < x     = border (zs ++ [x])\r\n    | head(ys_after_zs) == x    = (zs ++ [x])\r\n    | head(ys_after_zs) > x     = border (zs ++ [x])\r\n  where \r\n    ys = init xs \r\n    x = last xs \r\n    zs = border ys \r\n    ys_after_zs = (ys `after` zs) \r\n\r\n'