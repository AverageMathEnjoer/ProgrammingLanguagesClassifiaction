b'using System.Diagnostics;\nusing System.Text;\n\nusing FILE = System.IO.TextWriter;\n\nusing i32 = System.Int32;\nusing i64 = System.Int64;\n\nusing u8 = System.Byte;\nusing u16 = System.UInt16;\nusing u32 = System.UInt32;\nusing u64 = System.UInt64;\n\nusing sqlite3_int64 = System.Int64;\n\nusing Pgno = System.UInt32;\n\n\nnamespace CS_SQLite3\n{\n  using sqlite3_value = CSSQLite.Mem;\n  using Op = CSSQLite.VdbeOp;\n  using System;\n\n  public partial class CSSQLite\n  {\n    /*\n    ** 2001 September 15\n    **\n    ** The author disclaims copyright to this source code.  In place of\n    ** a legal notice, here is a blessing:\n    **\n    **    May you do good and not evil.\n    **    May you find forgiveness for yourself and forgive others.\n    **    May you share freely, never taking more than you give.\n    **\n    *************************************************************************\n    ** The code in this file implements execution method of the\n    ** Virtual Database Engine (VDBE).  A separate file ("vdbeaux.c")\n    ** handles housekeeping details such as creating and deleting\n    ** VDBE instances.  This file is solely interested in executing\n    ** the VDBE program.\n    **\n    ** In the external interface, an "sqlite3_stmt*" is an opaque pointer\n    ** to a VDBE.\n    **\n    ** The SQL parser generates a program which is then executed by\n    ** the VDBE to do the work of the SQL statement.  VDBE programs are\n    ** similar in form to assembly language.  The program consists of\n    ** a linear sequence of operations.  Each operation has an opcode\n    ** and 5 operands.  Operands P1, P2, and P3 are integers.  Operand P4\n    ** is a null-terminated string.  Operand P5 is an unsigned character.\n    ** Few opcodes use all 5 operands.\n    **\n    ** Computation results are stored on a set of registers numbered beginning\n    ** with 1 and going up to Vdbe.nMem.  Each register can store\n    ** either an integer, a null-terminated string, a floating point\n    ** number, or the SQL "NULL" value.  An implicit conversion from one\n    ** type to the other occurs as necessary.\n    **\n    ** Most of the code in this file is taken up by the sqlite3VdbeExec()\n    ** function which does the work of interpreting a VDBE program.\n    ** But other routines are also provided to help in building up\n    ** a program instruction by instruction.\n    **\n    ** Various scripts scan this source file in order to generate HTML\n    ** documentation, headers files, or other derived files.  The formatting\n    ** of the code in this file is, therefore, important.  See other comments\n    ** in this file for details.  If in doubt, do not deviate from existing\n    ** commenting and indentation practices when changing or adding code.\n    **\n    ** $Id: vdbe.c,v 1.874 2009/07/24 17:58:53 danielk1977 Exp $\n    **\n    *************************************************************************\n    **  Included in SQLite3 port to C#-SQLite;  2008 Noah B Hart\n    **  C#-SQLite is an independent reimplementation of the SQLite software library\n    **\n    **  $Header$\n    *************************************************************************\n    */\n    //#include "sqliteInt.h"\n    //#include "vdbeInt.h"\n\n    /*\n    ** The following global variable is incremented every time a cursor\n    ** moves, either by the OP_SeekXX, OP_Next, or OP_Prev opcodes.  The test\n    ** procedures use this information to make sure that indices are\n    ** working correctly.  This variable has no function other than to\n    ** help verify the correct operation of the library.\n    */\n#if  SQLITE_TEST\n    // use SQLITE3_LINK_INT version static int sqlite3_search_count = 0;\n#endif\n\n    /*\n** When this global variable is positive, it gets decremented once before\n** each instruction in the VDBE.  When reaches zero, the u1.isInterrupted\n** field of the sqlite3 structure is set in order to simulate and interrupt.\n**\n** This facility is used for testing purposes only.  It does not function\n** in an ordinary build.\n*/\n#if SQLITE_TEST\n    static int sqlite3_interrupt_count = 0;\n#endif\n\n    /*\n** The next global variable is incremented each type the OP_Sort opcode\n** is executed.  The test procedures use this information to make sure that\n** sorting is occurring or not occurring at appropriate times.   This variable\n** has no function other than to help verify the correct operation of the\n** library.\n*/\n#if SQLITE_TEST\n    // use SQLITE3_LINK_INT version static sqlite3_sort_count = 0;\n#endif\n\n    /*\n** The next global variable records the size of the largest MEM_Blob\n** or MEM_Str that has been used by a VDBE opcode.  The test procedures\n** use this information to make sure that the zero-blob functionality\n** is working correctly.   This variable has no function other than to\n** help verify the correct operation of the library.\n*/\n#if SQLITE_TEST\n    //    static int sqlite3_max_blobsize = 0;\n    static void updateMaxBlobsize( Mem p )\n    {\n      if ( ( p.flags & ( MEM_Str | MEM_Blob ) ) != 0 && p.n > sqlite3_max_blobsize.iValue )\n      {\n        sqlite3_max_blobsize.iValue = p.n;\n      }\n    }\n#endif\n\n    /*\n** Test a register to see if it exceeds the current maximum blob size.\n** If it does, record the new maximum blob size.\n*/\n#if SQLITE_TEST && !SQLITE_OMIT_BUILTIN_TEST\n    static void UPDATE_MAX_BLOBSIZE( Mem P ) { updateMaxBlobsize( P ); }\n#else\n//# define UPDATE_MAX_BLOBSIZE(P)\n#endif\n\n    /*\n** Convert the given register into a string if it isn\'t one\n** already. Return non-zero if a malloc() fails.\n*/\n    //#define Stringify(P, enc) \\\n    //   if(((P).flags&(MEM_Str|MEM_Blob))==0 && sqlite3VdbeMemStringify(P,enc)) \\\n    //     { goto no_mem; }\n\n    /*\n    ** An ephemeral string value (signified by the MEM_Ephem flag) contains\n    ** a pointer to a dynamically allocated string where some other entity\n    ** is responsible for deallocating that string.  Because the register\n    ** does not control the string, it might be deleted without the register\n    ** knowing it.\n    **\n    ** This routine converts an ephemeral string into a dynamically allocated\n    ** string that the register itself controls.  In other words, it\n    ** converts an MEM_Ephem string into an MEM_Dyn string.\n    */\n    //#define Deephemeralize(P) \\\n    //   if( ((P).flags&MEM_Ephem)!=0 \\\n    //       && sqlite3VdbeMemMakeWriteable(P) ){ goto no_mem;}\n\n    /*\n    ** Call sqlite3VdbeMemExpandBlob() on the supplied value (type Mem*)\n    ** P if required.\n    */\n    //#define ExpandBlob(P) (((P).flags&MEM_Zero)?sqlite3VdbeMemExpandBlob(P):0)\n    static int ExpandBlob( Mem P ) { return ( P.flags & MEM_Zero ) != 0 ? sqlite3VdbeMemExpandBlob( P ) : 0; }\n\n    /*\n    ** Argument pMem points at a register that will be passed to a\n    ** user-defined function or returned to the user as the result of a query.\n    ** The second argument, \'db_enc\' is the text encoding used by the vdbe for\n    ** register variables.  This routine sets the pMem.enc and pMem.type\n    ** variables used by the sqlite3_value_*() routines.\n    */\n    static void storeTypeInfo( Mem A, int B )\n    {\n      _storeTypeInfo( A );\n    }\n    static void _storeTypeInfo( Mem pMem )\n    {\n      int flags = pMem.flags;\n      if ( ( flags & MEM_Null ) != 0 )\n      {\n        pMem.type = SQLITE_NULL;\n      }\n      else if ( ( flags & MEM_Int ) != 0 )\n      {\n        pMem.type = SQLITE_INTEGER;\n      }\n      else if ( ( flags & MEM_Real ) != 0 )\n      {\n        pMem.type = SQLITE_FLOAT;\n      }\n      else if ( ( flags & MEM_Str ) != 0 )\n      {\n        pMem.type = SQLITE_TEXT;\n      }\n      else\n      {\n        pMem.type = SQLITE_BLOB;\n      }\n    }\n\n    /*\n    ** Properties of opcodes.  The OPFLG_INITIALIZER macro is\n    ** created by mkopcodeh.awk during compilation.  Data is obtained\n    ** from the comments following the "case OP_xxxx:" statements in\n    ** this file.\n    */\n    static int[] opcodeProperty = OPFLG_INITIALIZER;\n\n    /*\n    ** Return true if an opcode has any of the OPFLG_xxx properties\n    ** specified by mask.\n    */\n    static bool sqlite3VdbeOpcodeHasProperty( int opcode, int mask )\n    {\n      Debug.Assert( opcode > 0 && opcode < opcodeProperty.Length );//opcodeProperty).Length;\n      return ( opcodeProperty[opcode] & mask ) != 0;\n    }\n\n    /*\n    ** Allocate VdbeCursor number iCur.  Return a pointer to it.  Return NULL\n    ** if we run out of memory.\n    */\n    static VdbeCursor allocateCursor(\n    Vdbe p,               /* The virtual machine */\n    int iCur,             /* Index of the new VdbeCursor */\n    int nField,           /* Number of fields in the table or index */\n    int iDb,              /* When database the cursor belongs to, or -1 */\n    int isBtreeCursor     /* True for B-Tree vs. pseudo-table or vtab */\n    )\n    {\n      /* Find the memory cell that will be used to store the blob of memory\n      ** required for this VdbeCursor structure. It is convenient to use a\n      ** vdbe memory cell to manage the memory allocation required for a\n      ** VdbeCursor structure for the following reasons:\n      **\n      **   * Sometimes cursor numbers are used for a couple of different\n      **     purposes in a vdbe program. The different uses might require\n      **     different sized allocations. Memory cells provide growable\n      **     allocations.\n      **\n      **   * When using ENABLE_MEMORY_MANAGEMENT, memory cell buffers can\n      **     be freed lazily via the sqlite3_release_memory() API. This\n      **     minimizes the number of malloc calls made by the system.\n      **\n      ** Memory cells for cursors are allocated at the top of the address\n      ** space. Memory cell (p.nMem) corresponds to cursor 0. Space for\n      ** cursor 1 is managed by memory cell (p.nMem-1), etc.\n      */\n      Mem pMem = p.aMem[p.nMem - iCur];\n\n      int nByte;\n      VdbeCursor pCx = null;\n      nByte = -1;\n      //sizeof( VdbeCursor ) +\n      //( isBtreeCursor ? sqlite3BtreeCursorSize() : 0 ) +\n      //2 * nField * sizeof( u32 );\n\n      Debug.Assert( iCur < p.nCursor );\n      if ( p.apCsr[iCur] != null )\n      {\n        sqlite3VdbeFreeCursor( p, p.apCsr[iCur] );\n        p.apCsr[iCur] = null;\n      }\n      if ( SQLITE_OK == sqlite3VdbeMemGrow( pMem, nByte, 0 ) )\n      {\n        p.apCsr[iCur] = pCx = new VdbeCursor();// (VdbeCursor*)pMem.z;\n        //memset( pMem.z, 0, nByte );\n        pCx.iDb = iDb;\n        pCx.nField = nField;\n        if ( nField != 0 )\n        {\n          pCx.aType = new u32[nField];// (u32*)&pMem.z[sizeof( VdbeCursor )];\n        }\n        if ( isBtreeCursor != 0 )\n        {\n          pCx.pCursor = new BtCursor();// (BtCursor*)&pMem.z[sizeof( VdbeCursor ) + 2 * nField * sizeof( u32 )];\n        }\n      }\n      return pCx;\n    }\n\n    /*\n    ** Try to convert a value into a numeric representation if we can\n    ** do so without loss of information.  In other words, if the string\n    ** looks like a number, convert it into a number.  If it does not\n    ** look like a number, leave it alone.\n    */\n    static void applyNumericAffinity( Mem pRec )\n    {\n      if ( ( pRec.flags & ( MEM_Real | MEM_Int ) ) == 0 )\n      {\n        int realnum = 0;\n        sqlite3VdbeMemNulTerminate( pRec );\n        if ( ( pRec.flags & MEM_Str ) != 0\n        && sqlite3IsNumber( pRec.z, ref realnum, pRec.enc ) != 0 )\n        {\n          i64 value = 0;\n          sqlite3VdbeChangeEncoding( pRec, SQLITE_UTF8 );\n          if ( realnum == 0 && sqlite3Atoi64( pRec.z, ref value ) )\n          {\n            pRec.u.i = value;\n            MemSetTypeFlag( pRec, MEM_Int );\n          }\n          else\n          {\n            sqlite3VdbeMemRealify( pRec );\n          }\n        }\n      }\n    }\n\n    /*\n    ** Processing is determine by the affinity parameter:\n    **\n    ** SQLITE_AFF_INTEGER:\n    ** SQLITE_AFF_REAL:\n    ** SQLITE_AFF_NUMERIC:\n    **    Try to convert pRec to an integer representation or a\n    **    floating-point representation if an integer representation\n    **    is not possible.  Note that the integer representation is\n    **    always preferred, even if the affinity is REAL, because\n    **    an integer representation is more space efficient on disk.\n    **\n    ** SQLITE_AFF_TEXT:\n    **    Convert pRec to a text representation.\n    **\n    ** SQLITE_AFF_NONE:\n    **    No-op.  pRec is unchanged.\n    */\n    static void applyAffinity(\n    Mem pRec,          /* The value to apply affinity to */\n    char affinity,      /* The affinity to be applied */\n    int enc              /* Use this text encoding */\n    )\n    {\n      if ( affinity == SQLITE_AFF_TEXT )\n      {\n        /* Only attempt the conversion to TEXT if there is an integer or real\n        ** representation (blob and NULL do not get converted) but no string\n        ** representation.\n        */\n        if ( 0 == ( pRec.flags & MEM_Str ) && ( pRec.flags & ( MEM_Real | MEM_Int ) ) != 0 )\n        {\n          sqlite3VdbeMemStringify( pRec, enc );\n        }\n        if ( ( pRec.flags & ( MEM_Blob | MEM_Str ) ) == ( MEM_Blob | MEM_Str ) )\n        {\n          StringBuilder sb = new StringBuilder( pRec.zBLOB.Length );\n          for ( int i = 0 ; i < pRec.zBLOB.Length ; i++ ) sb.Append( (char)pRec.zBLOB[i] );\n          pRec.z = sb.ToString();\n          pRec.zBLOB = null;\n          pRec.flags = (u16)( pRec.flags & ~MEM_Blob );\n        }\n        pRec.flags = (u16)( pRec.flags & ~( MEM_Real | MEM_Int ) );\n      }\n      else if ( affinity != SQLITE_AFF_NONE )\n      {\n        Debug.Assert( affinity == SQLITE_AFF_INTEGER || affinity == SQLITE_AFF_REAL\n        || affinity == SQLITE_AFF_NUMERIC );\n        applyNumericAffinity( pRec );\n        if ( ( pRec.flags & MEM_Real ) != 0 )\n        {\n          sqlite3VdbeIntegerAffinity( pRec );\n        }\n      }\n    }\n\n    /*\n    ** Try to convert the type of a function argument or a result column\n    ** into a numeric representation.  Use either INTEGER or REAL whichever\n    ** is appropriate.  But only do the conversion if it is possible without\n    ** loss of information and return the revised type of the argument.\n    **\n    ** This is an EXPERIMENTAL api and is subject to change or removal.\n    */\n    static int sqlite3_value_numeric_type( sqlite3_value pVal )\n    {\n      Mem pMem = (Mem)pVal;\n      applyNumericAffinity( pMem );\n      storeTypeInfo( pMem, 0 );\n      return pMem.type;\n    }\n\n    /*\n    ** Exported version of applyAffinity(). This one works on sqlite3_value*,\n    ** not the internal Mem type.\n    */\n    static void sqlite3ValueApplyAffinity(\n    sqlite3_value pVal,\n    char affinity,\n    int enc\n    )\n    {\n      applyAffinity( (Mem)pVal, affinity, enc );\n    }\n\n#if SQLITE_DEBUG\n    /*\n** Write a nice string representation of the contents of cell pMem\n** into buffer zBuf, length nBuf.\n*/\n    static void sqlite3VdbeMemPrettyPrint( Mem pMem, StringBuilder zBuf )\n    {\n      zBuf.Length = 0;\n      string zCsr = "";\n      int f = pMem.flags;\n\n      string[] encnames = new string[] { "(X)", "(8)", "(16LE)", "(16BE)" };\n\n      if ( ( f & MEM_Blob ) != 0 )\n      {\n        int i;\n        char c;\n        if ( ( f & MEM_Dyn ) != 0 )\n        {\n          c = \'z\';\n          Debug.Assert( ( f & ( MEM_Static | MEM_Ephem ) ) == 0 );\n        }\n        else if ( ( f & MEM_Static ) != 0 )\n        {\n          c = \'t\';\n          Debug.Assert( ( f & ( MEM_Dyn | MEM_Ephem ) ) == 0 );\n        }\n        else if ( ( f & MEM_Ephem ) != 0 )\n        {\n          c = \'e\';\n          Debug.Assert( ( f & ( MEM_Static | MEM_Dyn ) ) == 0 );\n        }\n        else\n        {\n          c = \'s\';\n        }\n\n        sqlite3_snprintf( 100, ref zCsr, "%c", c );\n        zBuf.Append( zCsr );//zCsr += sqlite3Strlen30(zCsr);\n        sqlite3_snprintf( 100, ref  zCsr, "%d[", pMem.n );\n        zBuf.Append( zCsr );//zCsr += sqlite3Strlen30(zCsr);\n        for ( i = 0 ; i < 16 && i < pMem.n ; i++ )\n        {\n          sqlite3_snprintf( 100, ref zCsr, "%02X", ( (int)pMem.zBLOB[i] & 0xFF ) );\n          zBuf.Append( zCsr );//zCsr += sqlite3Strlen30(zCsr);\n        }\n        for ( i = 0 ; i < 16 && i < pMem.n ; i++ )\n        {\n          char z = (char)pMem.zBLOB[i];\n          if ( z < 32 || z > 126 ) zBuf.Append( \'.\' );//*zCsr++ = \'.\';\n          else zBuf.Append( z );//*zCsr++ = z;\n        }\n\n        sqlite3_snprintf( 100, ref zCsr, "]%s", encnames[pMem.enc] );\n        zBuf.Append( zCsr );//zCsr += sqlite3Strlen30(zCsr);\n        if ( ( f & MEM_Zero ) != 0 )\n        {\n          sqlite3_snprintf( 100, ref zCsr, "+%dz", pMem.u.nZero );\n          zBuf.Append( zCsr );//zCsr += sqlite3Strlen30(zCsr);\n        }\n        //*zCsr = \'\\0\';\n      }\n      else if ( ( f & MEM_Str ) != 0 )\n      {\n        int j, k;\n        zBuf.Append( \' \' );\n        if ( ( f & MEM_Dyn ) != 0 )\n        {\n          zBuf.Append( \'z\' );\n          Debug.Assert( ( f & ( MEM_Static | MEM_Ephem ) ) == 0 );\n        }\n        else if ( ( f & MEM_Static ) != 0 )\n        {\n          zBuf.Append( \'t\' );\n          Debug.Assert( ( f & ( MEM_Dyn | MEM_Ephem ) ) == 0 );\n        }\n        else if ( ( f & MEM_Ephem ) != 0 )\n        {\n          zBuf.Append( \'s\' ); //zBuf.Append( \'e\' );\n          Debug.Assert( ( f & ( MEM_Static | MEM_Dyn ) ) == 0 );\n        }\n        else\n        {\n          zBuf.Append( \'s\' );\n        }\n        k = 2;\n        sqlite3_snprintf( 100, ref zCsr, "%d", pMem.n );//zBuf[k], "%d", pMem.n );\n        zBuf.Append( zCsr );\n        //k += sqlite3Strlen30( &zBuf[k] );\n        zBuf.Append( \'[\' );// zBuf[k++] = \'[\';\n        for ( j = 0 ; j < 15 && j < pMem.n ; j++ )\n        {\n          u8 c = pMem.z != null ? (u8)pMem.z[j] : pMem.zBLOB[j];\n          if ( c >= 0x20 && c < 0x7f )\n          {\n            zBuf.Append( (char)c );//zBuf[k++] = c;\n          }\n          else\n          {\n            zBuf.Append( \'.\' );//zBuf[k++] = \'.\';\n          }\n        }\n        zBuf.Append( \']\' );//zBuf[k++] = \']\';\n        sqlite3_snprintf( 100, ref zCsr, encnames[pMem.enc] );//& zBuf[k], encnames[pMem.enc] );\n        zBuf.Append( zCsr );\n        //k += sqlite3Strlen30( &zBuf[k] );\n        //zBuf[k++] = 0;\n      }\n    }\n#endif\n\n#if SQLITE_DEBUG\n    /*\n** Print the value of a register for tracing purposes:\n*/\n    static void memTracePrint( FILE _out, Mem p )\n    {\n      if ( ( p.flags & MEM_Null ) != 0 )\n      {\n        fprintf( _out, " NULL" );\n      }\n      else if ( ( p.flags & ( MEM_Int | MEM_Str ) ) == ( MEM_Int | MEM_Str ) )\n      {\n        fprintf( _out, " si:%lld", p.u.i );\n#if !SQLITE_OMIT_FLOATING_POINT\n      }\n      else if ( ( p.flags & MEM_Int ) != 0 )\n      {\n        fprintf( _out, " i:%lld", p.u.i );\n#endif\n      }\n      else if ( ( p.flags & MEM_Real ) != 0 )\n      {\n        fprintf( _out, " r:%g", p.r );\n      }\n      else if ( ( p.flags & MEM_RowSet ) != 0 )\n      {\n        fprintf( _out, " (rowset)" );\n      }\n      else\n      {\n        StringBuilder zBuf = new StringBuilder( 200 );\n        sqlite3VdbeMemPrettyPrint( p, zBuf );\n        fprintf( _out, " " );\n        fprintf( _out, "%s", zBuf );\n      }\n    }\n    static void registerTrace( FILE _out, int iReg, Mem p )\n    {\n      fprintf( _out, "reg[%d] = ", iReg );\n      memTracePrint( _out, p );\n      fprintf( _out, "\\n" );\n    }\n#endif\n\n#if SQLITE_DEBUG\n    //#  define REGISTER_TRACE(R,M) if(p.trace)registerTrace(p.trace,R,M)\n    static void REGISTER_TRACE( Vdbe p, int R, Mem M )\n    {\n      if ( p.trace != null ) registerTrace( p.trace, R, M );\n    }\n#else\n//#  define REGISTER_TRACE(R,M)\nstatic void REGISTER_TRACE( Vdbe p, int R, Mem M ) { }\n#endif\n\n\n#if VDBE_PROFILE\n\n/*\n** hwtime.h contains inline assembler code for implementing\n** high-performance timing routines.\n*/\n//#include "hwtime.h"\n\n#endif\n\n    /*\n** The CHECK_FOR_INTERRUPT macro defined here looks to see if the\n** sqlite3_interrupt() routine has been called.  If it has been, then\n** processing of the VDBE program is interrupted.\n**\n** This macro added to every instruction that does a jump in order to\n** implement a loop.  This test used to be on every single instruction,\n** but that meant we more testing that we needed.  By only testing the\n** flag on jump instructions, we get a (small) speed improvement.\n*/\n    //#define CHECK_FOR_INTERRUPT \\\n    //   if( db.u1.isInterrupted ) goto abort_due_to_interrupt;\n\n\n#if SQLITE_DEBUG\n    static int fileExists( sqlite3 db, string zFile )\n    {\n      int res = 0;\n      int rc = SQLITE_OK;\n#if SQLITE_TEST\n      /* If we are currently testing IO errors, then do not call OsAccess() to\n** test for the presence of zFile. This is because any IO error that\n** occurs here will not be reported, causing the test to fail.\n*/\n      //extern int sqlite3_io_error_pending;\n      if ( sqlite3_io_error_pending.iValue <= 0 )\n#endif\n        rc = sqlite3OsAccess( db.pVfs, zFile, SQLITE_ACCESS_EXISTS, ref res );\n      return ( res != 0 && rc == SQLITE_OK ) ? 1 : 0;\n    }\n#endif\n\n#if !NDEBUG\n    /*\n** This function is only called from within an assert() expression. It\n** checks that the sqlite3.nTransaction variable is correctly set to\n** the number of non-transaction savepoints currently in the\n** linked list starting at sqlite3.pSavepoint.\n**\n** Usage:\n**\n**     assert( checkSavepointCount(db) );\n*/\n    static int checkSavepointCount( sqlite3 db )\n    {\n      int n = 0;\n      Savepoint p;\n      for ( p = db.pSavepoint ; p != null ; p = p.pNext ) n++;\n      Debug.Assert( n == ( db.nSavepoint + db.isTransactionSavepoint ) );\n      return 1;\n    }\n#else\nstatic int checkSavepointCount( sqlite3 db ) { return 1; }\n#endif\n\n    /*\n** Execute as much of a VDBE program as we can then return.\n**\n** sqlite3VdbeMakeReady() must be called before this routine in order to\n** close the program with a final OP_Halt and to set up the callbacks\n** and the error message pointer.\n**\n** Whenever a row or result data is available, this routine will either\n** invoke the result callback (if there is one) or return with\n** SQLITE_ROW.\n**\n** If an attempt is made to open a locked database, then this routine\n** will either invoke the busy callback (if there is one) or it will\n** return SQLITE_BUSY.\n**\n** If an error occurs, an error message is written to memory obtained\n** from sqlite3Malloc() and p.zErrMsg is made to point to that memory.\n** The error code is stored in p.rc and this routine returns SQLITE_ERROR.\n**\n** If the callback ever returns non-zero, then the program exits\n** immediately.  There will be no error message but the p.rc field is\n** set to SQLITE_ABORT and this routine will return SQLITE_ERROR.\n**\n** A memory allocation error causes p.rc to be set to SQLITE_NOMEM and this\n** routine to return SQLITE_ERROR.\n**\n** Other fatal errors return SQLITE_ERROR.\n**\n** After this routine has finished, sqlite3VdbeFinalize() should be\n** used to clean up the mess that was left behind.\n*/\n    static int sqlite3VdbeExec(\n    Vdbe p                         /* The VDBE */\n    )\n    {\n      int pc;                      /* The program counter */\n      Op pOp;                      /* Current operation */\n      int rc = SQLITE_OK;          /* Value to return */\n      sqlite3 db = p.db;           /* The database */\n      u8 encoding = ENC( db );       /* The database encoding */\n      Mem pIn1 = null;             /* 1st input operand */\n      Mem pIn2 = null;             /* 2nd input operand */\n      Mem pIn3 = null;             /* 3rd input operand */\n      Mem pOut = null;             /* Output operand */\n      int opProperty;\n      int iCompare = 0;            /* Result of last OP_Compare operation */\n      int[] aPermute = null;       /* Permutation of columns for OP_Compare */\n#if VDBE_PROFILE\nu64 start;                   /* CPU clock count at start of opcode */\nint origPc;                  /* Program counter at start of opcode */\n#endif\n#if !SQLITE_OMIT_PROGRESS_CALLBACK\n      int nProgressOps = 0;      /* Opcodes executed since progress callback. */\n#endif\n      /*** INSERT STACK UNION HERE ***/\n\n      Debug.Assert( p.magic == VDBE_MAGIC_RUN );  /* sqlite3_step() verifies this */\n#if SQLITE_DEBUG\n      Debug.Assert( db.magic == SQLITE_MAGIC_BUSY );\n#endif\n      sqlite3VdbeMutexArrayEnter( p );\n      if ( p.rc == SQLITE_NOMEM )\n      {\n        /* This happens if a malloc() inside a call to sqlite3_column_text() or\n        ** sqlite3_column_text16() failed.  */\n        goto no_mem;\n      }\n      Debug.Assert( p.rc == SQLITE_OK || p.rc == SQLITE_BUSY );\n      p.rc = SQLITE_OK;\n      Debug.Assert( p.explain == 0 );\n      p.pResultSet = null;\n      db.busyHandler.nBusy = 0;\n      if ( db.u1.isInterrupted ) goto abort_due_to_interrupt; //CHECK_FOR_INTERRUPT;\n#if TRACE\n      sqlite3VdbeIOTraceSql( p );\n#endif\n#if SQLITE_DEBUG\n      sqlite3BeginBenignMalloc();\n      if ( p.pc == 0\n      && ( ( p.db.flags & SQLITE_VdbeListing ) != 0 || fileExists( db, "vdbe_explain" ) != 0 )\n      )\n      {\n        int i;\n        Console.Write( "VDBE Program Listing:\\n" );\n        sqlite3VdbePrintSql( p );\n        for ( i = 0 ; i < p.nOp ; i++ )\n        {\n          sqlite3VdbePrintOp( Console.Out, i, p.aOp[i] );\n        }\n      }\n      if ( fileExists( db, "vdbe_trace" ) != 0 )\n      {\n        p.trace = Console.Out;\n      }\n      sqlite3EndBenignMalloc();\n#endif\n      for ( pc = p.pc ; rc == SQLITE_OK ; pc++ )\n      {\n        Debug.Assert( pc >= 0 && pc < p.nOp );\n  //      if ( db.mallocFailed != 0 ) goto no_mem;\n#if VDBE_PROFILE\norigPc = pc;\nstart = sqlite3Hwtime();\n#endif\n        pOp = p.aOp[pc];\n\n        /* Only allow tracing if SQLITE_DEBUG is defined.\n        */\n#if SQLITE_DEBUG\n        if ( p.trace != null )\n        {\n          if ( pc == 0 )\n          {\n            printf( "VDBE Execution Trace:\\n" );\n            sqlite3VdbePrintSql( p );\n          }\n          sqlite3VdbePrintOp( p.trace, pc, pOp );\n        }\n        if ( p.trace == null && pc == 0 )\n        {\n          sqlite3BeginBenignMalloc();\n          if ( fileExists( db, "vdbe_sqltrace" ) != 0 )\n          {\n            sqlite3VdbePrintSql( p );\n          }\n          sqlite3EndBenignMalloc();\n        }\n#endif\n\n\n        /* Check to see if we need to simulate an interrupt.  This only happens\n** if we have a special test build.\n*/\n#if SQLITE_TEST\n        if ( sqlite3_interrupt_count > 0 )\n        {\n          sqlite3_interrupt_count--;\n          if ( sqlite3_interrupt_count == 0 )\n          {\n            sqlite3_interrupt( db );\n          }\n        }\n#endif\n\n#if !SQLITE_OMIT_PROGRESS_CALLBACK\n        /* Call the progress callback if it is configured and the required number\n** of VDBE ops have been executed (either since this invocation of\n** sqlite3VdbeExec() or since last time the progress callback was called).\n** If the progress callback returns non-zero, exit the virtual machine with\n** a return code SQLITE_ABORT.\n*/\n        if ( db.xProgress != null )\n        {\n          if ( db.nProgressOps == nProgressOps )\n          {\n            int prc;\n#if SQLITE_DEBUG\n            if ( sqlite3SafetyOff( db ) ) goto abort_due_to_misuse;\n#endif\n            prc = db.xProgress( db.pProgressArg );\n#if SQLITE_DEBUG\n            if ( sqlite3SafetyOn( db ) ) goto abort_due_to_misuse;\n#endif\n            if ( prc != 0 )\n            {\n              rc = SQLITE_INTERRUPT;\n              goto vdbe_error_halt;\n            }\n            nProgressOps = 0;\n          }\n          nProgressOps++;\n        }\n#endif\n\n        /* Do common setup processing for any opcode that is marked\n** with the "out2-prerelease" tag.  Such opcodes have a single\n** output which is specified by the P2 parameter.  The P2 register\n** is initialized to a NULL.\n*/\n        opProperty = opcodeProperty[pOp.opcode];\n        if ( ( opProperty & OPFLG_OUT2_PRERELEASE ) != 0 )\n        {\n          Debug.Assert( pOp.p2 > 0 );\n          Debug.Assert( pOp.p2 <= p.nMem );\n          pOut = p.aMem[pOp.p2];\n          sqlite3VdbeMemReleaseExternal( pOut );\n          pOut.flags = MEM_Null;\n          pOut.n = 0;\n        }\n        else\n\n          /* Do common setup for opcodes marked with one of the following\n          ** combinations of properties.\n          **\n          **           in1\n          **           in1 in2\n          **           in1 in2 out3\n          **           in1 in3\n          **\n          ** Variables pIn1, pIn2, and pIn3 are made to point to appropriate\n          ** registers for inputs.  Variable pOut points to the output register.\n          */\n          if ( ( opProperty & OPFLG_IN1 ) != 0 )\n          {\n            Debug.Assert( pOp.p1 > 0 );\n            Debug.Assert( pOp.p1 <= p.nMem );\n            pIn1 = p.aMem[pOp.p1];\n            REGISTER_TRACE( p, pOp.p1, pIn1 );\n            if ( ( opProperty & OPFLG_IN2 ) != 0 )\n            {\n              Debug.Assert( pOp.p2 > 0 );\n              Debug.Assert( pOp.p2 <= p.nMem );\n              pIn2 = p.aMem[pOp.p2];\n              REGISTER_TRACE( p, pOp.p2, pIn2 );\n              if ( ( opProperty & OPFLG_OUT3 ) != 0 )\n              {\n                Debug.Assert( pOp.p3 > 0 );\n                Debug.Assert( pOp.p3 <= p.nMem );\n                pOut = p.aMem[pOp.p3];\n              }\n            }\n            else if ( ( opProperty & OPFLG_IN3 ) != 0 )\n            {\n              Debug.Assert( pOp.p3 > 0 );\n              Debug.Assert( pOp.p3 <= p.nMem );\n              pIn3 = p.aMem[pOp.p3];\n#if SQLITE_DEBUG\n              REGISTER_TRACE( p, pOp.p3, pIn3 );\n#endif\n            }\n          }\n          else if ( ( opProperty & OPFLG_IN2 ) != 0 )\n          {\n            Debug.Assert( pOp.p2 > 0 );\n            Debug.Assert( pOp.p2 <= p.nMem );\n            pIn2 = p.aMem[pOp.p2];\n#if SQLITE_DEBUG\n            REGISTER_TRACE( p, pOp.p2, pIn2 );\n#endif\n          }\n          else if ( ( opProperty & OPFLG_IN3 ) != 0 )\n          {\n            Debug.Assert( pOp.p3 > 0 );\n            Debug.Assert( pOp.p3 <= p.nMem );\n            pIn3 = p.aMem[pOp.p3];\n#if SQLITE_DEBUG\n            REGISTER_TRACE( p, pOp.p3, pIn3 );\n#endif\n          }\n\n        switch ( pOp.opcode )\n        {\n\n          /*****************************************************************************\n          ** What follows is a massive switch statement where each case implements a\n          ** separate instruction in the virtual machine.  If we follow the usual\n          ** indentation conventions, each case should be indented by 6 spaces.  But\n          ** that is a lot of wasted space on the left margin.  So the code within\n          ** the switch statement will break with convention and be flush-left. Another\n          ** big comment (similar to this one) will mark the point in the code where\n          ** we transition back to normal indentation.\n          **\n          ** The formatting of each case is important.  The makefile for SQLite\n          ** generates two C files "opcodes.h" and "opcodes.c" by scanning this\n          ** file looking for lines that begin with "case OP_".  The opcodes.h files\n          ** will be filled with #defines that give unique integer values to each\n          ** opcode and the opcodes.c file is filled with an array of strings where\n          ** each string is the symbolic name for the corresponding opcode.  If the\n          ** case statement is followed by a comment of the form "/# same as ... #/"\n          ** that comment is used to determine the particular value of the opcode.\n          **\n          ** Other keywords in the comment that follows each case are used to\n          ** construct the OPFLG_INITIALIZER value that initializes opcodeProperty[].\n          ** Keywords include: in1, in2, in3, out2_prerelease, out2, out3.  See\n          ** the mkopcodeh.awk script for additional information.\n          **\n          ** Documentation about VDBE opcodes is generated by scanning this file\n          ** for lines of that contain "Opcode:".  That line and all subsequent\n          ** comment lines are used in the generation of the opcode.html documentation\n          ** file.\n          **\n          ** SUMMARY:\n          **\n          **     Formatting is important to scripts that scan this file.\n          **     Do not deviate from the formatting style currently in use.\n          **\n          *****************************************************************************/\n\n          /* Opcode:  Goto * P2 * * *\n          **\n          ** An unconditional jump to address P2.\n          ** The next instruction executed will be\n          ** the one at index P2 from the beginning of\n          ** the program.\n          */\n          case OP_Goto:\n            {             /* jump */\n              if ( db.u1.isInterrupted ) goto abort_due_to_interrupt; //CHECK_FOR_INTERRUPT;\n              pc = pOp.p2 - 1;\n              break;\n            }\n\n          /* Opcode:  Gosub P1 P2 * * *\n          **\n          ** Write the current address onto register P1\n          ** and then jump to address P2.\n          */\n          case OP_Gosub:\n            {            /* jump */\n              Debug.Assert( pOp.p1 > 0 );\n              Debug.Assert( pOp.p1 <= p.nMem );\n              pIn1 = p.aMem[pOp.p1];\n              Debug.Assert( ( pIn1.flags & MEM_Dyn ) == 0 );\n              pIn1.flags = MEM_Int;\n              pIn1.u.i = pc;\n              REGISTER_TRACE( p, pOp.p1, pIn1 );\n              pc = pOp.p2 - 1;\n              break;\n            }\n\n          /* Opcode:  Return P1 * * * *\n          **\n          ** Jump to the next instruction after the address in register P1.\n          */\n          case OP_Return:\n            {           /* in1 */\n              Debug.Assert( ( pIn1.flags & MEM_Int ) != 0 );\n              pc = (int)pIn1.u.i;\n              break;\n            }\n\n          /* Opcode:  Yield P1 * * * *\n          **\n          ** Swap the program counter with the value in register P1.\n          */\n          case OP_Yield:\n            {            /* in1 */\n              int pcDest;\n              Debug.Assert( ( pIn1.flags & MEM_Dyn ) == 0 );\n              pIn1.flags = MEM_Int;\n              pcDest = (int)pIn1.u.i;\n              pIn1.u.i = pc;\n              REGISTER_TRACE( p, pOp.p1, pIn1 );\n              pc = pcDest;\n              break;\n            }\n\n          /* Opcode:  HaltIfNull  P1 P2 P3 P4 *\n          **\n          ** Check the value in register P3.  If is is NULL then Halt using\n          ** parameter P1, P2, and P4 as if this were a Halt instruction.  If the\n          ** value in register P3 is not NULL, then this routine is a no-op.\n          */\n          case OP_HaltIfNull:\n            {      /* in3 */\n              if ( ( pIn3.flags & MEM_Null ) == 0 ) break;\n              /* Fall through into OP_Halt */\n              goto case OP_Halt;\n            }\n\n          /* Opcode:  Halt P1 P2 * P4 *\n          **\n          ** Exit immediately.  All open cursors, etc are closed\n          ** automatically.\n          **\n          ** P1 is the result code returned by sqlite3_exec(), sqlite3_reset(),\n          ** or sqlite3_finalize().  For a normal halt, this should be SQLITE_OK (0).\n          ** For errors, it can be some other value.  If P1!=0 then P2 will determine\n          ** whether or not to rollback the current transaction.  Do not rollback\n          ** if P2==OE_Fail. Do the rollback if P2==OE_Rollback.  If P2==OE_Abort,\n          ** then back out all changes that have occurred during this execution of the\n          ** VDBE, but do not rollback the transaction.\n          **\n          ** If P4 is not null then it is an error message string.\n          **\n          ** There is an implied "Halt 0 0 0" instruction inserted at the very end of\n          ** every program.  So a jump past the last instruction of the program\n          ** is the same as executing Halt.\n          */\n          case OP_Halt:\n            {\n              p.rc = pOp.p1;\n              p.pc = pc;\n              p.errorAction = (u8)pOp.p2;\n              if ( pOp.p4.z != null )\n              {\n                sqlite3SetString( ref p.zErrMsg, db, "%s", pOp.p4.z );\n              }\n              rc = sqlite3VdbeHalt( p );\n              Debug.Assert( rc == SQLITE_BUSY || rc == SQLITE_OK );\n              if ( rc == SQLITE_BUSY )\n              {\n                p.rc = rc = SQLITE_BUSY;\n              }\n              else\n              {\n                rc = p.rc != 0 ? SQLITE_ERROR : SQLITE_DONE;\n              }\n              goto vdbe_return;\n            }\n\n          /* Opcode: Integer P1 P2 * * *\n          **\n          ** The 32-bit integer value P1 is written into register P2.\n          */\n          case OP_Integer:\n            {         /* out2-prerelease */\n              pOut.flags = MEM_Int;\n              pOut.u.i = pOp.p1;\n              break;\n            }\n\n          /* Opcode: Int64 * P2 * P4 *\n          **\n          ** P4 is a pointer to a 64-bit integer value.\n          ** Write that value into register P2.\n          */\n          case OP_Int64:\n            {           /* out2-prerelease */\n              // Integer pointer always exists Debug.Assert( pOp.p4.pI64 != 0 );\n              pOut.flags = MEM_Int;\n              pOut.u.i = pOp.p4.pI64;\n              break;\n            }\n\n          /* Opcode: Real * P2 * P4 *\n          **\n          ** P4 is a pointer to a 64-bit floating point value.\n          ** Write that value into register P2.\n          */\n          case OP_Real:\n            {            /* same as TK_FLOAT, out2-prerelease */\n              pOut.flags = MEM_Real;\n              Debug.Assert( !sqlite3IsNaN( pOp.p4.pReal ) );\n              pOut.r = pOp.p4.pReal;\n              break;\n            }\n\n          /* Opcode: String8 * P2 * P4 *\n          **\n          ** P4 points to a nul terminated UTF-8 string. This opcode is transformed\n          ** into an OP_String before it is executed for the first time.\n          */\n          case OP_String8:\n            {         /* same as TK_STRING, out2-prerelease */\n              Debug.Assert( pOp.p4.z != null );\n              pOp.opcode = OP_String;\n              pOp.p1 = sqlite3Strlen30( pOp.p4.z );\n\n#if !SQLITE_OMIT_UTF16\nif( encoding!=SQLITE_UTF8 ){\nrc = sqlite3VdbeMemSetStr(pOut, pOp->p4.z, -1, SQLITE_UTF8, SQLITE_STATIC);\nif( rc==SQLITE_TOOBIG ) goto too_big;\nif( SQLITE_OK!=sqlite3VdbeChangeEncoding(pOut, encoding) ) goto no_mem;\nassert( pOut->zMalloc==pOut->z );\nassert( pOut->flags & MEM_Dyn );\npOut->zMalloc = 0;\npOut->flags |= MEM_Static;\npOut->flags &= ~MEM_Dyn;\nif( pOp->p4type==P4_DYNAMIC ){\n//sqlite3DbFree(db, pOp->p4.z);\n}\npOp->p4type = P4_DYNAMIC;\npOp->p4.z = pOut->z;\npOp->p1 = pOut->n;\n}\n#endif\n              if ( pOp.p1 > db.aLimit[SQLITE_LIMIT_LENGTH] )\n              {\n                goto too_big;\n              }\n              /* Fall through to the next case, OP_String */\n              goto case OP_String;\n            }\n\n          /* Opcode: String P1 P2 * P4 *\n          **\n          ** The string value P4 of length P1 (bytes) is stored in register P2.\n          */\n          case OP_String:\n            {          /* out2-prerelease */\n              Debug.Assert( pOp.p4.z != null );\n              pOut.flags = MEM_Str | MEM_Static | MEM_Term;\n              pOut.zBLOB = null;\n              pOut.z = pOp.p4.z;\n              pOut.n = pOp.p1;\n              pOut.enc = encoding;\n#if SQLITE_TEST\n              UPDATE_MAX_BLOBSIZE( pOut );\n#endif\n              break;\n            }\n\n          /* Opcode: Null * P2 * * *\n          **\n          ** Write a NULL into register P2.\n          */\n          case OP_Null:\n            {           /* out2-prerelease */\n              break;\n            }\n\n\n          /* Opcode: Blob P1 P2 * P4\n          **\n          ** P4 points to a blob of data P1 bytes long.  Store this\n          ** blob in register P2. This instruction is not coded directly\n          ** by the compiler. Instead, the compiler layer specifies\n          ** an OP_HexBlob opcode, with the hex string representation of\n          ** the blob as P4. This opcode is transformed to an OP_Blob\n          ** the first time it is executed.\n          */\n          case OP_Blob:\n            {                /* out2-prerelease */\n              Debug.Assert( pOp.p1 <= db.aLimit[SQLITE_LIMIT_LENGTH] );\n              sqlite3VdbeMemSetStr( pOut, pOp.p4.z, pOp.p1, 0, null );\n              pOut.enc = encoding;\n#if SQLITE_TEST\n              UPDATE_MAX_BLOBSIZE( pOut );\n#endif\n              break;\n            }\n\n          /* Opcode: Variable P1 P2 P3 P4 *\n          **\n          ** Transfer the values of bound parameters P1..P1+P3-1 into registers\n          ** P2..P2+P3-1.\n          **\n          ** If the parameter is named, then its name appears in P4 and P3==1.\n          ** The P4 value is used by sqlite3_bind_parameter_name().\n          */\n          case OP_Variable:\n            {\n              int p1;          /* Variable to copy from */\n              int p2;          /* Register to copy to */\n              int n;           /* Number of values left to copy */\n              Mem pVar;        /* Value being transferred */\n\n              p1 = pOp.p1 - 1;\n              p2 = pOp.p2;\n              n = pOp.p3;\n              Debug.Assert( p1 >= 0 && p1 + n <= p.nVar );\n              Debug.Assert( p2 >= 1 && p2 + n - 1 <= p.nMem );\n              Debug.Assert( pOp.p4.z == null || pOp.p3 == 1 );\n\n              while ( n-- > 0 )\n              {\n                pVar = p.aVar[p1++];\n                if ( sqlite3VdbeMemTooBig( pVar ) )\n                {\n                  goto too_big;\n                }\n                pOut = p.aMem[p2++];\n                sqlite3VdbeMemReleaseExternal( pOut );\n                pOut.flags = MEM_Null;\n                sqlite3VdbeMemShallowCopy( pOut, pVar, MEM_Static );\n#if SQLITE_TEST\n                UPDATE_MAX_BLOBSIZE( pOut );\n#endif\n              }\n              break;\n            }\n\n          /* Opcode: Move P1 P2 P3 * *\n          **\n          ** Move the values in register P1..P1+P3-1 over into\n          ** registers P2..P2+P3-1.  Registers P1..P1+P1-1 are\n          ** left holding a NULL.  It is an error for register ranges\n          ** P1..P1+P3-1 and P2..P2+P3-1 to overlap.\n          */\n          case OP_Move:\n            {\n              //char* zMalloc;   /* Holding variable for allocated memory */\n              int n;           /* Number of registers left to copy */\n              int p1;          /* Register to copy from */\n              int p2;          /* Register to copy to */\n\n              n = pOp.p3;\n              p1 = pOp.p1;\n              p2 = pOp.p2;\n              Debug.Assert( n > 0 && p1 > 0 && p2 > 0 );\n              Debug.Assert( p1 + n <= p2 || p2 + n <= p1 );\n              //pIn1 = p.aMem[p1];\n              //pOut = p.aMem[p2];\n              while ( n-- != 0 )\n              {\n                pIn1 = p.aMem[p1 + pOp.p3 - n - 1];\n                pOut = p.aMem[p2];\n                //assert( pOut<=&p->aMem[p->nMem] );\n                //assert( pIn1<=&p->aMem[p->nMem] );\n                //zMalloc = pOut.zMalloc;\n                //pOut.zMalloc = null;\n                sqlite3VdbeMemMove( pOut, pIn1 );\n                //pIn1.zMalloc = zMalloc;\n                REGISTER_TRACE( p, p2++, pOut );\n                //pIn1++;\n                //pOut++;\n              }\n              break;\n            }\n\n          /* Opcode: Copy P1 P2 * * *\n          **\n          ** Make a copy of register P1 into register P2.\n          **\n          ** This instruction makes a deep copy of the value.  A duplicate\n          ** is made of any string or blob constant.  See also OP_SCopy.\n          */\n          case OP_Copy:\n            {             /* in1 */\n              Debug.Assert( pOp.p2 > 0 );\n              Debug.Assert( pOp.p2 <= p.nMem );\n              pOut = p.aMem[pOp.p2];\n              Debug.Assert( pOut != pIn1 );\n              sqlite3VdbeMemShallowCopy( pOut, pIn1, MEM_Ephem );\n              if ( ( pOut.flags & MEM_Ephem ) != 0 && sqlite3VdbeMemMakeWriteable( pOut ) != 0 ) { goto no_mem; }//Deephemeralize( pOut );\n#if SQLITE_DEBUG\n              REGISTER_TRACE( p, pOp.p2, pOut );\n#endif\n              break;\n            }\n\n          /* Opcode: SCopy P1 P2 * * *\n          **\n          ** Make a shallow copy of register P1 into register P2.\n          **\n          ** This instruction makes a shallow copy of the value.  If the value\n          ** is a string or blob, then the copy is only a pointer to the\n          ** original and hence if the original changes so will the copy.\n          ** Worse, if the original is deallocated, the copy becomes invalid.\n          ** Thus the program must guarantee that the original will not change\n          ** during the lifetime of the copy.  Use OP_Copy to make a complete\n          ** copy.\n          */\n          case OP_SCopy:\n            {            /* in1 */\n#if SQLITE_DEBUG\n              REGISTER_TRACE( p, pOp.p1, pIn1 );\n#endif\n              Debug.Assert( pOp.p2 > 0 );\n              Debug.Assert( pOp.p2 <= p.nMem );\n              pOut = p.aMem[pOp.p2];\n              Debug.Assert( pOut != pIn1 );\n              sqlite3VdbeMemShallowCopy( pOut, pIn1, MEM_Ephem );\n#if SQLITE_DEBUG\n              REGISTER_TRACE( p, pOp.p2, pOut );\n#endif\n              break;\n            }\n\n          /* Opcode: ResultRow P1 P2 * * *\n          **\n          ** The registers P1 through P1+P2-1 contain a single row of\n          ** results. This opcode causes the sqlite3_step() call to terminate\n          ** with an SQLITE_ROW return code and it sets up the sqlite3_stmt\n          ** structure to provide access to the top P1 values as the result\n          ** row.\n          */\n          case OP_ResultRow:\n            {\n              //Mem[] pMem;\n              int i;\n              Debug.Assert( p.nResColumn == pOp.p2 );\n              Debug.Assert( pOp.p1 > 0 );\n              Debug.Assert( pOp.p1 + pOp.p2 <= p.nMem + 1 );\n\n              /* If the SQLITE_CountRows flag is set in sqlite3.flags mask, then\n              ** DML statements invoke this opcode to return the number of rows\n              ** modified to the user. This is the only way that a VM that\n              ** opens a statement transaction may invoke this opcode.\n              **\n              ** In case this is such a statement, close any statement transaction\n              ** opened by this VM before returning control to the user. This is to\n              ** ensure that statement-transactions are always nested, not overlapping.\n              ** If the open statement-transaction is not closed here, then the user\n              ** may step another VM that opens its own statement transaction. This\n              ** may lead to overlapping statement transactions.\n              **\n              ** The statement transaction is never a top-level transaction.  Hence\n              ** the RELEASE call below can never fail.\n              */\n              Debug.Assert( p.iStatement == 0 || ( db.flags & SQLITE_CountRows ) != 0 );\n              rc = sqlite3VdbeCloseStatement( p, SAVEPOINT_RELEASE );\n              if ( NEVER( rc != SQLITE_OK ) )\n              {\n                break;\n              }\n\n              /* Invalidate all ephemeral cursor row caches */\n              p.cacheCtr = ( p.cacheCtr + 2 ) | 1;\n\n              /* Make sure the results of the current row are \\000 terminated\n              ** and have an assigned type.  The results are de-ephemeralized as\n              ** as side effect.\n              */\n              //pMem = p.pResultSet = p.aMem[pOp.p1];\n              p.pResultSet = new Mem[pOp.p2];\n              for ( i = 0 ; i < pOp.p2 ; i++ )\n              {\n                p.pResultSet[i] = p.aMem[pOp.p1 + i];\n                sqlite3VdbeMemNulTerminate( p.pResultSet[i] ); //sqlite3VdbeMemNulTerminate(pMem[i]);\n                storeTypeInfo( p.pResultSet[i], encoding ); //storeTypeInfo(pMem[i], encoding);\n                REGISTER_TRACE( p, pOp.p1 + i, p.pResultSet[i] );\n              }\n        //      if ( db.mallocFailed != 0 ) goto no_mem;\n\n              /* Return SQLITE_ROW\n              */\n              p.pc = pc + 1;\n              rc = SQLITE_ROW;\n              goto vdbe_return;\n            }\n\n          /* Opcode: Concat P1 P2 P3 * *\n          **\n          ** Add the text in register P1 onto the end of the text in\n          ** register P2 and store the result in register P3.\n          ** If either the P1 or P2 text are NULL then store NULL in P3.\n          **\n          **   P3 = P2 || P1\n          **\n          ** It is illegal for P1 and P3 to be the same register. Sometimes,\n          ** if P3 is the same register as P2, the implementation is able\n          ** to avoid a memcpy().\n          */\n          case OP_Concat:\n            {           /* same as TK_CONCAT, in1, in2, out3 */\n              int nByte;\n\n              Debug.Assert( pIn1 != pOut );\n              if ( ( ( pIn1.flags | pIn2.flags ) & MEM_Null ) != 0 )\n              {\n                sqlite3VdbeMemSetNull( pOut );\n                break;\n              }\n              if ( ExpandBlob( pIn1 ) != 0 || ExpandBlob( pIn2 ) != 0 ) goto no_mem;\n              if ( ( ( pIn1.flags & ( MEM_Str | MEM_Blob ) ) == 0 ) && sqlite3VdbeMemStringify( pIn1, encoding ) != 0 ) { goto no_mem; }// Stringify(pIn1, encoding);\n              if ( ( ( pIn2.flags & ( MEM_Str | MEM_Blob ) ) == 0 ) && sqlite3VdbeMemStringify( pIn2, encoding ) != 0 ) { goto no_mem; }// Stringify(pIn2, encoding);\n              nByte = pIn1.n + pIn2.n;\n              if ( nByte > db.aLimit[SQLITE_LIMIT_LENGTH] )\n              {\n                goto too_big;\n              }\n              MemSetTypeFlag( pOut, MEM_Str );\n              //if ( sqlite3VdbeMemGrow( pOut, (int)nByte + 2, ( pOut == pIn2 ) ? 1 : 0 ) != 0 )\n              //{\n              //  goto no_mem;\n              //}\n              //if ( pOut != pIn2 )\n              //{\n              //  memcpy( pOut.z, pIn2.z, pIn2.n );\n              //}\n              //memcpy( &pOut.z[pIn2.n], pIn1.z, pIn1.n );\n              if ( pIn2.z != null ) pOut.z = pIn2.z.Substring( 0, pIn2.n ) + pIn1.z.Substring( 0, pIn1.n );\n              else\n              {\n                pOut.zBLOB = new byte[pIn1.n + pIn2.n];\n                Buffer.BlockCopy( pIn2.zBLOB, 0, pOut.zBLOB, 0, pIn2.n );\n                Buffer.BlockCopy( pIn1.zBLOB, 0, pOut.zBLOB, pIn2.n, pIn1.n );\n              }              //pOut.z[nByte] = 0;\n              //pOut.z[nByte + 1] = 0;\n              pOut.flags |= MEM_Term;\n              pOut.n = (int)nByte;\n              pOut.enc = encoding;\n#if SQLITE_TEST\n              UPDATE_MAX_BLOBSIZE( pOut );\n#endif\n              break;\n            }\n\n          /* Opcode: Add P1 P2 P3 * *\n          **\n          ** Add the value in register P1 to the value in register P2\n          ** and store the result in register P3.\n          ** If either input is NULL, the result is NULL.\n          */\n          /* Opcode: Multiply P1 P2 P3 * *\n          **\n          **\n          ** Multiply the value in register P1 by the value in register P2\n          ** and store the result in register P3.\n          ** If either input is NULL, the result is NULL.\n          */\n          /* Opcode: Subtract P1 P2 P3 * *\n          **\n          ** Subtract the value in register P1 from the value in register P2\n          ** and store the result in register P3.\n          ** If either input is NULL, the result is NULL.\n          */\n          /* Opcode: Divide P1 P2 P3 * *\n          **\n          ** Divide the value in register P1 by the value in register P2\n          ** and store the result in register P3.  If the value in register P2\n          ** is zero, then the result is NULL.\n          ** If either input is NULL, the result is NULL.\n          */\n          /* Opcode: Remainder P1 P2 P3 * *\n          **\n          ** Compute the remainder after integer division of the value in\n          ** register P1 by the value in register P2 and store the result in P3.\n          ** If the value in register P2 is zero the result is NULL.\n          ** If either operand is NULL, the result is NULL.\n          */\n          case OP_Add:                   /* same as TK_PLUS, in1, in2, out3 */\n          case OP_Subtract:              /* same as TK_MINUS, in1, in2, out3 */\n          case OP_Multiply:              /* same as TK_STAR, in1, in2, out3 */\n          case OP_Divide:                /* same as TK_SLASH, in1, in2, out3 */\n          case OP_Remainder:\n            {           /* same as TK_REM, in1, in2, out3 */\n              int flags;      /* Combined MEM_* flags from both inputs */\n              i64 iA;         /* Integer value of left operand */\n              i64 iB;         /* Integer value of right operand */\n              double rA;      /* Real value of left operand */\n              double rB;      /* Real value of right operand */\n\n              applyNumericAffinity( pIn1 );\n              applyNumericAffinity( pIn2 );\n              flags = pIn1.flags | pIn2.flags;\n              if ( ( flags & MEM_Null ) != 0 ) goto arithmetic_result_is_null;\n              if ( ( pIn1.flags & pIn2.flags & MEM_Int ) == MEM_Int )\n              {\n                iA = pIn1.u.i;\n                iB = pIn2.u.i;\n                switch ( pOp.opcode )\n                {\n                  case OP_Add: iB += iA; break;\n                  case OP_Subtract: iB -= iA; break;\n                  case OP_Multiply: iB *= iA; break;\n                  case OP_Divide:\n                    {\n                      if ( iA == 0 ) goto arithmetic_result_is_null;\n                      /* Dividing the largest possible negative 64-bit integer (1<<63) by\n                      ** -1 returns an integer too large to store in a 64-bit data-type. On\n                      ** some architectures, the value overflows to (1<<63). On others,\n                      ** a SIGFPE is issued. The following statement normalizes this\n                      ** behavior so that all architectures behave as if integer\n                      ** overflow occurred.\n                      */\n                      if ( iA == -1 && iB == SMALLEST_INT64 ) iA = 1;\n                      iB /= iA;\n                      break;\n                    }\n                  default:\n                    {\n                      if ( iA == 0 ) goto arithmetic_result_is_null;\n                      if ( iA == -1 ) iA = 1;\n                      iB %= iA;\n                      break;\n                    }\n                }\n                pOut.u.i = iB;\n                MemSetTypeFlag( pOut, MEM_Int );\n              }\n              else\n              {\n                rA = sqlite3VdbeRealValue( pIn1 );\n                rB = sqlite3VdbeRealValue( pIn2 );\n                switch ( pOp.opcode )\n                {\n                  case OP_Add: rB += rA; break;\n                  case OP_Subtract: rB -= rA; break;\n                  case OP_Multiply: rB *= rA; break;\n                  case OP_Divide:\n                    {\n                      /* (double)0 In case of SQLITE_OMIT_FLOATING_POINT... */\n                      if ( rA == (double)0 ) goto arithmetic_result_is_null;\n                      rB /= rA;\n                      break;\n                    }\n                  default:\n                    {\n                      iA = (i64)rA;\n                      iB = (i64)rB;\n                      if ( iA == 0 ) goto arithmetic_result_is_null;\n                      if ( iA == -1 ) iA = 1;\n                      rB = (double)( iB % iA );\n                      break;\n                    }\n                }\n                if ( sqlite3IsNaN( rB ) )\n                {\n                  goto arithmetic_result_is_null;\n                }\n                pOut.r = rB;\n                MemSetTypeFlag( pOut, MEM_Real );\n                if ( ( flags & MEM_Real ) == 0 )\n                {\n                  sqlite3VdbeIntegerAffinity( pOut );\n                }\n              }\n              break;\n\narithmetic_result_is_null:\n              sqlite3VdbeMemSetNull( pOut );\n              break;\n            }\n\n          /* Opcode: CollSeq * * P4\n          **\n          ** P4 is a pointer to a CollSeq struct. If the next call to a user function\n          ** or aggregate calls sqlite3GetFuncCollSeq(), this collation sequence will\n          ** be returned. This is used by the built-in min(), max() and nullif()\n          ** functions.\n          **\n          ** The interface used by the implementation of the aforementioned functions\n          ** to retrieve the collation sequence set by this opcode is not available\n          ** publicly, only to user functions defined in func.c.\n          */\n          case OP_CollSeq:\n            {\n              Debug.Assert( pOp.p4type == P4_COLLSEQ );\n              break;\n            }\n\n          /* Opcode: Function P1 P2 P3 P4 P5\n          **\n          ** Invoke a user function (P4 is a pointer to a Function structure that\n          ** defines the function) with P5 arguments taken from register P2 and\n          ** successors.  The result of the function is stored in register P3.\n          ** Register P3 must not be one of the function inputs.\n          **\n          ** P1 is a 32-bit bitmask indicating whether or not each argument to the\n          ** function was determined to be constant at compile time. If the first\n          ** argument was constant then bit 0 of P1 is set. This is used to determine\n          ** whether meta data associated with a user function argument using the\n          ** sqlite3_set_auxdata() API may be safely retained until the next\n          ** invocation of this opcode.\n          **\n          ** See also: AggStep and AggFinal\n          */\n          case OP_Function:\n            {\n              int i;\n              Mem pArg;\n              sqlite3_context ctx = new sqlite3_context();\n              sqlite3_value[] apVal;\n              int n;\n\n              n = pOp.p5;\n              apVal = p.apArg;\n              Debug.Assert( apVal != null || n == 0 );\n\n              Debug.Assert( n == 0 || ( pOp.p2 > 0 && pOp.p2 + n <= p.nMem + 1 ) );\n              Debug.Assert( pOp.p3 < pOp.p2 || pOp.p3 >= pOp.p2 + n );\n              //pArg = p.aMem[pOp.p2];\n              for ( i = 0 ; i < n ; i++ )//, pArg++)\n              {\n                pArg = p.aMem[pOp.p2 + i];\n                apVal[i] = pArg;\n                storeTypeInfo( pArg, encoding );\n#if SQLITE_DEBUG\n                REGISTER_TRACE( p, pOp.p2, pArg );\n#endif\n              }\n\n              Debug.Assert( pOp.p4type == P4_FUNCDEF || pOp.p4type == P4_VDBEFUNC );\n              if ( pOp.p4type == P4_FUNCDEF )\n              {\n                ctx.pFunc = pOp.p4.pFunc;\n                ctx.pVdbeFunc = null;\n              }\n              else\n              {\n                ctx.pVdbeFunc = (VdbeFunc)pOp.p4.pVdbeFunc;\n                ctx.pFunc = ctx.pVdbeFunc.pFunc;\n              }\n\n              Debug.Assert( pOp.p3 > 0 && pOp.p3 <= p.nMem );\n              pOut = p.aMem[pOp.p3];\n              ctx.s.flags = MEM_Null;\n              ctx.s.db = db;\n              ctx.s.xDel = null;\n              //ctx.s.zMalloc = null;\n\n              /* The output cell may already have a buffer allocated. Move\n              ** the pointer to ctx.s so in case the user-function can use\n              ** the already allocated buffer instead of allocating a new one.\n              */\n              sqlite3VdbeMemMove( ctx.s, pOut );\n              MemSetTypeFlag( ctx.s, MEM_Null );\n\n              ctx.isError = 0;\n              if ( ( ctx.pFunc.flags & SQLITE_FUNC_NEEDCOLL ) != 0 )\n              {\n                Debug.Assert( pc > 1 );//Debug.Assert(pOp > p.aOp);\n                Debug.Assert( p.aOp[pc - 1].p4type == P4_COLLSEQ );//Debug.Assert(pOp[-1].p4type == P4_COLLSEQ);\n                Debug.Assert( p.aOp[pc - 1].opcode == OP_CollSeq );//Debug.Assert(pOp[-1].opcode == OP_CollSeq);\n                ctx.pColl = p.aOp[pc - 1].p4.pColl;//ctx.pColl = pOp[-1].p4.pColl;\n              }\n#if SQLITE_DEBUG\n              if ( sqlite3SafetyOff( db ) )\n              {\n                sqlite3VdbeMemRelease( ctx.s );\n                goto abort_due_to_misuse;\n              }\n#endif\n              ctx.pFunc.xFunc( ctx, n, apVal );\n#if SQLITE_DEBUG\n              if ( sqlite3SafetyOn( db ) ) goto abort_due_to_misuse;\n#endif\n              //if ( db.mallocFailed != 0 )\n              //{\n              //  /* Even though a malloc() has failed, the implementation of the\n              //  ** user function may have called an sqlite3_result_XXX() function\n              //  ** to return a value. The following call releases any resources\n              //  ** associated with such a value.\n              //  **\n              //  ** Note: Maybe MemRelease() should be called if sqlite3SafetyOn()\n              //  ** fails also (the if(...) statement above). But if people are\n              //  ** misusing sqlite, they have bigger problems than a leaked value.\n              //  */\n              //  sqlite3VdbeMemRelease( ctx.s );\n              //  goto no_mem;\n              //}\n\n              /* If any auxillary data functions have been called by this user function,\n              ** immediately call the destructor for any non-static values.\n              */\n              if ( ctx.pVdbeFunc != null )\n              {\n                sqlite3VdbeDeleteAuxData( ctx.pVdbeFunc, pOp.p1 );\n                pOp.p4.pVdbeFunc = ctx.pVdbeFunc;\n                pOp.p4type = P4_VDBEFUNC;\n              }\n\n              /* If the function returned an error, throw an exception */\n              if ( ctx.isError != 0 )\n              {\n                sqlite3SetString( ref p.zErrMsg, db, sqlite3_value_text( ctx.s ) );\n                rc = ctx.isError;\n              }\n\n              /* Copy the result of the function into register P3 */\n              sqlite3VdbeChangeEncoding( ctx.s, encoding );\n              sqlite3VdbeMemMove( pOut, ctx.s );\n              if ( sqlite3VdbeMemTooBig( pOut ) )\n              {\n                goto too_big;\n              }\n#if SQLITE_DEBUG\n              REGISTER_TRACE( p, pOp.p3, pOut );\n#endif\n#if SQLITE_TEST\n              UPDATE_MAX_BLOBSIZE( pOut );\n#endif\n              break;\n            }\n\n          /* Opcode: BitAnd P1 P2 P3 * *\n          **\n          ** Take the bit-wise AND of the values in register P1 and P2 and\n          ** store the result in register P3.\n          ** If either input is NULL, the result is NULL.\n          */\n          /* Opcode: BitOr P1 P2 P3 * *\n          **\n          ** Take the bit-wise OR of the values in register P1 and P2 and\n          ** store the result in register P3.\n          ** If either input is NULL, the result is NULL.\n          */\n          /* Opcode: ShiftLeft P1 P2 P3 * *\n          **\n          ** Shift the integer value in register P2 to the left by the\n          ** number of bits specified by the integer in register P1.\n          ** Store the result in register P3.\n          ** If either input is NULL, the result is NULL.\n          */\n          /* Opcode: ShiftRight P1 P2 P3 * *\n          **\n          ** Shift the integer value in register P2 to the right by the\n          ** number of bits specified by the integer in register P1.\n          ** Store the result in register P3.\n          ** If either input is NULL, the result is NULL.\n          */\n          case OP_BitAnd:                 /* same as TK_BITAND, in1, in2, out3 */\n          case OP_BitOr:                  /* same as TK_BITOR, in1, in2, out3 */\n          case OP_ShiftLeft:              /* same as TK_LSHIFT, in1, in2, out3 */\n          case OP_ShiftRight:\n            {           /* same as TK_RSHIFT, in1, in2, out3 */\n              i64 a;\n              i64 b;\n\n              if ( ( ( pIn1.flags | pIn2.flags ) & MEM_Null ) != 0 )\n              {\n                sqlite3VdbeMemSetNull( pOut );\n                break;\n              }\n              a = sqlite3VdbeIntValue( pIn2 );\n              b = sqlite3VdbeIntValue( pIn1 );\n              switch ( pOp.opcode )\n              {\n                case OP_BitAnd: a &= b; break;\n                case OP_BitOr: a |= b; break;\n                case OP_ShiftLeft: a <<= (int)b; break;\n                default: Debug.Assert( pOp.opcode == OP_ShiftRight );\n                  a >>= (int)b; break;\n              }\n              pOut.u.i = a;\n              MemSetTypeFlag( pOut, MEM_Int );\n              break;\n            }\n\n          /* Opcode: AddImm  P1 P2 * * *\n          **\n          ** Add the constant P2 to the value in register P1.\n          ** The result is always an integer.\n          **\n          ** To force any register to be an integer, just add 0.\n          */\n          case OP_AddImm:\n            {            /* in1 */\n              sqlite3VdbeMemIntegerify( pIn1 );\n              pIn1.u.i += pOp.p2;\n              break;\n            }\n\n          /* Opcode: MustBeInt P1 P2 * * *\n          **\n          ** Force the value in register P1 to be an integer.  If the value\n          ** in P1 is not an integer and cannot be converted into an integer\n          ** without data loss, then jump immediately to P2, or if P2==0\n          ** raise an SQLITE_MISMATCH exception.\n          */\n          case OP_MustBeInt:\n            {            /* jump, in1 */\n              applyAffinity( pIn1, SQLITE_AFF_NUMERIC, encoding );\n              if ( ( pIn1.flags & MEM_Int ) == 0 )\n              {\n                if ( pOp.p2 == 0 )\n                {\n                  rc = SQLITE_MISMATCH;\n                  goto abort_due_to_error;\n                }\n                else\n                {\n                  pc = pOp.p2 - 1;\n                }\n              }\n              else\n              {\n                MemSetTypeFlag( pIn1, MEM_Int );\n              }\n              break;\n            }\n\n          /* Opcode: RealAffinity P1 * * * *\n          **\n          ** If register P1 holds an integer convert it to a real value.\n          **\n          ** This opcode is used when extracting information from a column that\n          ** has REAL affinity.  Such column values may still be stored as\n          ** integers, for space efficiency, but after extraction we want them\n          ** to have only a real value.\n          */\n          case OP_RealAffinity:\n            {                  /* in1 */\n              if ( ( pIn1.flags & MEM_Int ) != 0 )\n              {\n                sqlite3VdbeMemRealify( pIn1 );\n              }\n              break;\n            }\n\n#if !SQLITE_OMIT_CAST\n          /* Opcode: ToText P1 * * * *\n**\n** Force the value in register P1 to be text.\n** If the value is numeric, convert it to a string using the\n** equivalent of printf().  Blob values are unchanged and\n** are afterwards simply interpreted as text.\n**\n** A NULL value is not changed by this routine.  It remains NULL.\n*/\n          case OP_ToText:\n            {                  /* same as TK_TO_TEXT, in1 */\n              if ( ( pIn1.flags & MEM_Null ) != 0 ) break;\n              Debug.Assert( MEM_Str == ( MEM_Blob >> 3 ) );\n              pIn1.flags |= (u16)( ( pIn1.flags & MEM_Blob ) >> 3 );\n              applyAffinity( pIn1, SQLITE_AFF_TEXT, encoding );\n              rc = ExpandBlob( pIn1 );\n              Debug.Assert( ( pIn1.flags & MEM_Str ) != 0 /*|| db.mallocFailed != 0 */ );\n              pIn1.flags = (u16)( pIn1.flags & ~( MEM_Int | MEM_Real | MEM_Blob | MEM_Zero ) );\n#if SQLITE_TEST\n              UPDATE_MAX_BLOBSIZE( pIn1 );\n#endif\n              break;\n            }\n\n          /* Opcode: ToBlob P1 * * * *\n          **\n          ** Force the value in register P1 to be a BLOB.\n          ** If the value is numeric, convert it to a string first.\n          ** Strings are simply reinterpreted as blobs with no change\n          ** to the underlying data.\n          **\n          ** A NULL value is not changed by this routine.  It remains NULL.\n          */\n          case OP_ToBlob:\n            {                  /* same as TK_TO_BLOB, in1 */\n              if ( ( pIn1.flags & MEM_Null ) != 0 ) break;\n              if ( ( pIn1.flags & MEM_Blob ) == 0 )\n              {\n                applyAffinity( pIn1, SQLITE_AFF_TEXT, encoding );\n                Debug.Assert( ( pIn1.flags & MEM_Str ) != 0 /*|| db.mallocFailed != 0 */ );\n                MemSetTypeFlag( pIn1, MEM_Blob );\n              }\n              else\n              {\n                pIn1.flags = (ushort)( pIn1.flags & ~( MEM_TypeMask & ~MEM_Blob ) );\n              }\n#if SQLITE_TEST\n              UPDATE_MAX_BLOBSIZE( pIn1 );\n#endif\n              break;\n            }\n\n          /* Opcode: ToNumeric P1 * * * *\n          **\n          ** Force the value in register P1 to be numeric (either an\n          ** integer or a floating-point number.)\n          ** If the value is text or blob, try to convert it to an using the\n          ** equivalent of atoi() or atof() and store 0 if no such conversion\n          ** is possible.\n          **\n          ** A NULL value is not changed by this routine.  It remains NULL.\n          */\n          case OP_ToNumeric:\n            {                  /* same as TK_TO_NUMERIC, in1 */\n              if ( ( pIn1.flags & ( MEM_Null | MEM_Int | MEM_Real ) ) == 0 )\n              {\n                sqlite3VdbeMemNumerify( pIn1 );\n              }\n              break;\n            }\n#endif // * SQLITE_OMIT_CAST */\n\n          /* Opcode: ToInt P1 * * * *\n**\n** Force the value in register P1 be an integer.  If\n** The value is currently a real number, drop its fractional part.\n** If the value is text or blob, try to convert it to an integer using the\n** equivalent of atoi() and store 0 if no such conversion is possible.\n**\n** A NULL value is not changed by this routine.  It remains NULL.\n*/\n          case OP_ToInt:\n            {                  /* same as TK_TO_INT, in1 */\n              if ( ( pIn1.flags & MEM_Null ) == 0 )\n              {\n                sqlite3VdbeMemIntegerify( pIn1 );\n              }\n              break;\n            }\n\n#if !SQLITE_OMIT_CAST\n          /* Opcode: ToReal P1 * * * *\n**\n** Force the value in register P1 to be a floating point number.\n** If The value is currently an integer, convert it.\n** If the value is text or blob, try to convert it to an integer using the\n** equivalent of atoi() and store 0.0 if no such conversion is possible.\n**\n** A NULL value is not changed by this routine.  It remains NULL.\n*/\n          case OP_ToReal:\n            {                  /* same as TK_TO_REAL, in1 */\n              if ( ( pIn1.flags & MEM_Null ) == 0 )\n              {\n                sqlite3VdbeMemRealify( pIn1 );\n              }\n              break;\n            }\n#endif // * SQLITE_OMIT_CAST */\n\n          /* Opcode: Lt P1 P2 P3 P4 P5\n**\n** Compare the values in register P1 and P3.  If reg(P3)<reg(P1) then\n** jump to address P2.\n**\n** If the SQLITE_JUMPIFNULL bit of P5 is set and either reg(P1) or\n** reg(P3) is NULL then take the jump.  If the SQLITE_JUMPIFNULL\n** bit is clear then fall thru if either operand is NULL.\n**\n** The SQLITE_AFF_MASK portion of P5 must be an affinity character -\n** SQLITE_AFF_TEXT, SQLITE_AFF_INTEGER, and so forth. An attempt is made\n** to coerce both inputs according to this affinity before the\n** comparison is made. If the SQLITE_AFF_MASK is 0x00, then numeric\n** affinity is used. Note that the affinity conversions are stored\n** back into the input registers P1 and P3.  So this opcode can cause\n** persistent changes to registers P1 and P3.\n**\n** Once any conversions have taken place, and neither value is NULL,\n** the values are compared. If both values are blobs then memcmp() is\n** used to determine the results of the comparison.  If both values\n** are text, then the appropriate collating function specified in\n** P4 is  used to do the comparison.  If P4 is not specified then\n** memcmp() is used to compare text string.  If both values are\n** numeric, then a numeric comparison is used. If the two values\n** are of different types, then numbers are considered less than\n** strings and strings are considered less than blobs.\n**\n** If the SQLITE_STOREP2 bit of P5 is set, then do not jump.  Instead,\n** store a boolean result (either 0, or 1, or NULL) in register P2.\n*/\n          /* Opcode: Ne P1 P2 P3 P4 P5\n          **\n          ** This works just like the Lt opcode except that the jump is taken if\n          ** the operands in registers P1 and P3 are not equal.  See the Lt opcode for\n          ** additional information.\n          */\n          /* Opcode: Eq P1 P2 P3 P4 P5\n          **\n          ** This works just like the Lt opcode except that the jump is taken if\n          ** the operands in registers P1 and P3 are equal.\n          ** See the Lt opcode for additional information.\n          */\n          /* Opcode: Le P1 P2 P3 P4 P5\n          **\n          ** This works just like the Lt opcode except that the jump is taken if\n          ** the content of register P3 is less than or equal to the content of\n          ** register P1.  See the Lt opcode for additional information.\n          */\n          /* Opcode: Gt P1 P2 P3 P4 P5\n          **\n          ** This works just like the Lt opcode except that the jump is taken if\n          ** the content of register P3 is greater than the content of\n          ** register P1.  See the Lt opcode for additional information.\n          */\n          /* Opcode: Ge P1 P2 P3 P4 P5\n          **\n          ** This works just like the Lt opcode except that the jump is taken if\n          ** the content of register P3 is greater than or equal to the content of\n          ** register P1.  See the Lt opcode for additional information.\n          */\n          case OP_Eq:               /* same as TK_EQ, jump, in1, in3 */\n          case OP_Ne:               /* same as TK_NE, jump, in1, in3 */\n          case OP_Lt:               /* same as TK_LT, jump, in1, in3 */\n          case OP_Le:               /* same as TK_LE, jump, in1, in3 */\n          case OP_Gt:               /* same as TK_GT, jump, in1, in3 */\n          case OP_Ge:\n            {             /* same as TK_GE, jump, in1, in3 */\n              int flags;\n              int res = 0;\n              char affinity;\n\n              flags = pIn1.flags | pIn3.flags;\n\n              if ( ( flags & MEM_Null ) != 0 )\n              {\n                /* If either operand is NULL then the result is always NULL.\n                ** The jump is taken if the SQLITE_JUMPIFNULL bit is set.\n                */\n                if ( ( pOp.p5 & SQLITE_STOREP2 ) != 0 )\n                {\n                  pOut = p.aMem[pOp.p2];\n                  MemSetTypeFlag( pOut, MEM_Null );\n                  REGISTER_TRACE( p, pOp.p2, pOut );\n                }\n                else if ( ( pOp.p5 & SQLITE_JUMPIFNULL ) != 0 )\n                {\n                  pc = pOp.p2 - 1;\n                }\n                break;\n              }\n\n              affinity = (char)( pOp.p5 & SQLITE_AFF_MASK );\n              if ( affinity != \'\\0\' )\n              {\n                applyAffinity( pIn1, affinity, encoding );\n                applyAffinity( pIn3, affinity, encoding );\n          //      if ( db.mallocFailed != 0 ) goto no_mem;\n              }\n\n              Debug.Assert( pOp.p4type == P4_COLLSEQ || pOp.p4.pColl == null );\n              ExpandBlob( pIn1 );\n              ExpandBlob( pIn3 );\n              res = sqlite3MemCompare( pIn3, pIn1, pOp.p4.pColl );\n              switch ( pOp.opcode )\n              {\n                case OP_Eq: res = ( res == 0 ) ? 1 : 0; break;\n                case OP_Ne: res = ( res != 0 ) ? 1 : 0; break;\n                case OP_Lt: res = ( res < 0 ) ? 1 : 0; break;\n                case OP_Le: res = ( res <= 0 ) ? 1 : 0; break;\n                case OP_Gt: res = ( res > 0 ) ? 1 : 0; break;\n                default: res = ( res >= 0 ) ? 1 : 0; break;\n              }\n\n              if ( ( pOp.p5 & SQLITE_STOREP2 ) != 0 )\n              {\n                pOut = p.aMem[pOp.p2];\n                MemSetTypeFlag( pOut, MEM_Int );\n                pOut.u.i = res;\n#if SQLITE_DEBUG\n                REGISTER_TRACE( p, pOp.p2, pOut );\n#endif\n              }\n              else if ( res != 0 )\n              {\n                pc = pOp.p2 - 1;\n              }\n              break;\n            }\n\n          /* Opcode: Permutation * * * P4 *\n          **\n          ** Set the permutation used by the OP_Compare operator to be the array\n          ** of integers in P4.\n          **\n          ** The permutation is only valid until the next OP_Permutation, OP_Compare,\n          ** OP_Halt, or OP_ResultRow.  Typically the OP_Permutation should occur\n          ** immediately prior to the OP_Compare.\n          */\n          case OP_Permutation:\n            {\n              Debug.Assert( pOp.p4type == P4_INTARRAY );\n              Debug.Assert( pOp.p4.ai != null );\n              aPermute = pOp.p4.ai;\n              break;\n            }\n\n          /* Opcode: Compare P1 P2 P3 P4 *\n          **\n          ** Compare to vectors of registers in reg(P1)..reg(P1+P3-1) (all this\n          ** one "A") and in reg(P2)..reg(P2+P3-1) ("B").  Save the result of\n          ** the comparison for use by the next OP_Jump instruct.\n          **\n          ** P4 is a KeyInfo structure that defines collating sequences and sort\n          ** orders for the comparison.  The permutation applies to registers\n          ** only.  The KeyInfo elements are used sequentially.\n          **\n          ** The comparison is a sort comparison, so NULLs compare equal,\n          ** NULLs are less than numbers, numbers are less than strings,\n          ** and strings are less than blobs.\n          */\n          case OP_Compare:\n            {\n              int n;\n              int i;\n              int p1;\n              int p2;\n              KeyInfo pKeyInfo;\n              int idx;\n              CollSeq pColl;    /* Collating sequence to use on this term */\n              int bRev;          /* True for DESCENDING sort order */\n\n              n = pOp.p3;\n              pKeyInfo = pOp.p4.pKeyInfo;\n              Debug.Assert( n > 0 );\n              Debug.Assert( pKeyInfo != null );\n              p1 = pOp.p1;\n              Debug.Assert( p1 > 0 && p1 + n <= p.nMem + 1 );\n              p2 = pOp.p2;\n              Debug.Assert( p2 > 0 && p2 + n <= p.nMem + 1 );\n              for ( i = 0 ; i < n ; i++ )\n              {\n                idx = aPermute != null ? aPermute[i] : i;\n                REGISTER_TRACE( p, p1 + idx, p.aMem[p1 + idx] );\n                REGISTER_TRACE( p, p2 + idx, p.aMem[p2 + idx] );\n                Debug.Assert( i < pKeyInfo.nField );\n                pColl = pKeyInfo.aColl[i];\n                bRev = pKeyInfo.aSortOrder[i];\n                iCompare = sqlite3MemCompare( p.aMem[p1 + idx], p.aMem[p2 + idx], pColl );\n                if ( iCompare != 0 )\n                {\n                  if ( bRev != 0 ) iCompare = -iCompare;\n                  break;\n                }\n              }\n              aPermute = null;\n              break;\n            }\n\n          /* Opcode: Jump P1 P2 P3 * *\n          **\n          ** Jump to the instruction at address P1, P2, or P3 depending on whether\n          ** in the most recent OP_Compare instruction the P1 vector was less than\n          ** equal to, or greater than the P2 vector, respectively.\n          */\n          case OP_Jump:\n            {             /* jump */\n              if ( iCompare < 0 )\n              {\n                pc = pOp.p1 - 1;\n              }\n              else if ( iCompare == 0 )\n              {\n                pc = pOp.p2 - 1;\n              }\n              else\n              {\n                pc = pOp.p3 - 1;\n              }\n              break;\n            }\n          /* Opcode: And P1 P2 P3 * *\n          **\n          ** Take the logical AND of the values in registers P1 and P2 and\n          ** write the result into register P3.\n          **\n          ** If either P1 or P2 is 0 (false) then the result is 0 even if\n          ** the other input is NULL.  A NULL and true or two NULLs give\n          ** a NULL output.\n          */\n          /* Opcode: Or P1 P2 P3 * *\n          **\n          ** Take the logical OR of the values in register P1 and P2 and\n          ** store the answer in register P3.\n          **\n          ** If either P1 or P2 is nonzero (true) then the result is 1 (true)\n          ** even if the other input is NULL.  A NULL and false or two NULLs\n          ** give a NULL output.\n          */\n          case OP_And:              /* same as TK_AND, in1, in2, out3 */\n          case OP_Or:\n            {             /* same as TK_OR, in1, in2, out3 */\n              int v1;    /* Left operand:  0==FALSE, 1==TRUE, 2==UNKNOWN or NULL */\n              int v2;    /* Right operand: 0==FALSE, 1==TRUE, 2==UNKNOWN or NULL */\n\n              if ( ( pIn1.flags & MEM_Null ) != 0 )\n              {\n                v1 = 2;\n              }\n              else\n              {\n                v1 = ( sqlite3VdbeIntValue( pIn1 ) != 0 ) ? 1 : 0;\n              }\n              if ( ( pIn2.flags & MEM_Null ) != 0 )\n              {\n                v2 = 2;\n              }\n              else\n              {\n                v2 = ( sqlite3VdbeIntValue( pIn2 ) != 0 ) ? 1 : 0;\n              }\n              if ( pOp.opcode == OP_And )\n              {\n                byte[] and_logic = new byte[] { 0, 0, 0, 0, 1, 2, 0, 2, 2 };\n                v1 = and_logic[v1 * 3 + v2];\n              }\n              else\n              {\n                byte[] or_logic = new byte[] { 0, 1, 2, 1, 1, 1, 2, 1, 2 };\n                v1 = or_logic[v1 * 3 + v2];\n              }\n              if ( v1 == 2 )\n              {\n                MemSetTypeFlag( pOut, MEM_Null );\n              }\n              else\n              {\n                pOut.u.i = v1;\n                MemSetTypeFlag( pOut, MEM_Int );\n              }\n              break;\n            }\n\n          /* Opcode: Not P1 P2 * * *\n          **\n          ** Interpret the value in register P1 as a boolean value.  Store the\n          ** boolean complement in register P2.  If the value in register P1 is\n          ** NULL, then a NULL is stored in P2.\n          */\n          case OP_Not:\n            {                /* same as TK_NOT, in1 */\n              pOut = p.aMem[pOp.p2];\n              if ( ( pIn1.flags & MEM_Null ) != 0 )\n              {\n                sqlite3VdbeMemSetNull( pOut );\n              }\n              else\n              {\n                sqlite3VdbeMemSetInt64( pOut, sqlite3VdbeIntValue( pIn1 ) == 0 ? 1 : 0 );\n              }\n              break;\n            }\n\n          /* Opcode: BitNot P1 P2 * * *\n          **\n          ** Interpret the content of register P1 as an integer.  Store the\n          ** ones-complement of the P1 value into register P2.  If P1 holds\n          ** a NULL then store a NULL in P2.\n          */\n          case OP_BitNot:\n            {             /* same as TK_BITNOT, in1 */\n              pOut = p.aMem[pOp.p2];\n              if ( ( pIn1.flags & MEM_Null ) != 0 )\n              {\n                sqlite3VdbeMemSetNull( pOut );\n              }\n              else\n              {\n                sqlite3VdbeMemSetInt64( pOut, ~sqlite3VdbeIntValue( pIn1 ) );\n              }\n              break;\n            }\n\n          /* Opcode: If P1 P2 P3 * *\n          **\n          ** Jump to P2 if the value in register P1 is true.  The value is\n          ** is considered true if it is numeric and non-zero.  If the value\n          ** in P1 is NULL then take the jump if P3 is true.\n          */\n          /* Opcode: IfNot P1 P2 P3 * *\n          **\n          ** Jump to P2 if the value in register P1 is False.  The value is\n          ** is considered true if it has a numeric value of zero.  If the value\n          ** in P1 is NULL then take the jump if P3 is true.\n          */\n          case OP_If:                 /* jump, in1 */\n          case OP_IfNot:\n            {            /* jump, in1 */\n              int c;\n              if ( ( pIn1.flags & MEM_Null ) != 0 )\n              {\n                c = pOp.p3;\n              }\n              else\n              {\n#if SQLITE_OMIT_FLOATING_POINT\nc = sqlite3VdbeIntValue(pIn1)!=0;\n#else\n                c = ( sqlite3VdbeRealValue( pIn1 ) != 0.0 ) ? 1 : 0;\n#endif\n                if ( pOp.opcode == OP_IfNot ) c = ( c == 0 ) ? 1 : 0;\n              }\n              if ( c != 0 )\n              {\n                pc = pOp.p2 - 1;\n              }\n              break;\n            }\n\n          /* Opcode: IsNull P1 P2 * * *\n          **\n          ** Jump to P2 if the value in register P1 is NULL.\n          */\n          case OP_IsNull:\n            {            /* same as TK_ISNULL, jump, in1 */\n              if ( ( pIn1.flags & MEM_Null ) != 0 )\n              {\n                pc = pOp.p2 - 1;\n              }\n              break;\n            }\n\n          /* Opcode: NotNull P1 P2 * * *\n          **\n          ** Jump to P2 if the value in register P1 is not NULL.\n          */\n          case OP_NotNull:\n            {            /* same as TK_NOTNULL, jump, in1 */\n              if ( ( pIn1.flags & MEM_Null ) == 0 )\n              {\n                pc = pOp.p2 - 1;\n              }\n              break;\n            }\n\n          /* Opcode: SetNumColumns * P2 * * *\n          **\n          ** This opcode sets the number of columns for the cursor opened by the\n          ** following instruction to P2.\n          **\n          ** An OP_SetNumColumns is only useful if it occurs immediately before\n          ** one of the following opcodes:\n          **\n          **     OpenRead\n          **     OpenWrite\n          **     OpenPseudo\n          **\n          ** If the OP_Column opcode is to be executed on a cursor, then\n          ** this opcode must be present immediately before the opcode that\n          ** opens the cursor.\n          */\n#if FALSE\ncase OP_SetNumColumns:\n{\nbreak;\n}\n#endif\n\n          /* Opcode: Column P1 P2 P3 P4 *\n**\n** Interpret the data that cursor P1 points to as a structure built using\n** the MakeRecord instruction.  (See the MakeRecord opcode for additional\n** information about the format of the data.)  Extract the P2-th column\n** from this record.  If there are less that (P2+1)\n** values in the record, extract a NULL.\n**\n** The value extracted is stored in register P3.\n**\n** If the column contains fewer than P2 fields, then extract a NULL.  Or,\n** if the P4 argument is a P4_MEM use the value of the P4 argument as\n** the result.\n*/\n          case OP_Column:\n            {\n              u32 payloadSize;   /* Number of bytes in the record */\n              i64 payloadSize64; /* Number of bytes in the record */\n              int p1;            /* P1 value of the opcode */\n              int p2;            /* column number to retrieve */\n              VdbeCursor pC;     /* The VDBE cursor */\n              byte[] zRec;       /* Pointer to complete record-data */\n              BtCursor pCrsr;    /* The BTree cursor */\n              u32[] aType;       /* aType[i] holds the numeric type of the i-th column */\n              u32[] aOffset;     /* aOffset[i] is offset to start of data for i-th column */\n              int nField;        /* number of fields in the record */\n              int len;           /* The length of the serialized data for the column */\n              int i;             /* Loop counter */\n              byte[] zData;      /* Part of the record being decoded */\n              Mem pDest;         /* Where to write the extracted value */\n              Mem sMem;          /* For storing the record being decoded */\n              int zIdx;          /* Index into header */\n              int zEndHdr;       /* Pointer to first byte after the header */\n              u32 offset;        /* Offset into the data */\n              u64 offset64;      /* 64-bit offset.  64 bits needed to catch overflow */\n              int szHdr;         /* Size of the header size field at start of record */\n              int avail;         /* Number of bytes of available data */\n\n\n              p1 = pOp.p1;\n              p2 = pOp.p2;\n              pC = null;\n\n              payloadSize = 0;\n              payloadSize64 = 0;\n              offset = 0;\n\n              sMem = new Mem();//  memset(&sMem, 0, sizeof(sMem));\n              Debug.Assert( p1 < p.nCursor );\n              Debug.Assert( pOp.p3 > 0 && pOp.p3 <= p.nMem );\n              pDest = p.aMem[pOp.p3];\n              MemSetTypeFlag( pDest, MEM_Null );\n              zRec = null;\n\n              /* This block sets the variable payloadSize to be the total number of\n              ** bytes in the record.\n              **\n              ** zRec is set to be the complete text of the record if it is available.\n              ** The complete record text is always available for pseudo-tables\n              ** If the record is stored in a cursor, the complete record text\n              ** might be available in the  pC.aRow cache.  Or it might not be.\n              ** If the data is unavailable,  zRec is set to NULL.\n              **\n              ** We also compute the number of columns in the record.  For cursors,\n              ** the number of columns is stored in the VdbeCursor.nField element.\n              */\n              pC = p.apCsr[p1];\n              Debug.Assert( pC != null );\n#if !SQLITE_OMIT_VIRTUALTABLE\nDebug.Assert( pC.pVtabCursor==0 );\n#endif\n              pCrsr = pC.pCursor;\n              if ( pCrsr != null )\n              {\n                /* The record is stored in a B-Tree */\n                rc = sqlite3VdbeCursorMoveto( pC );\n                if ( rc != 0 ) goto abort_due_to_error;\n                if ( pC.nullRow )\n                {\n                  payloadSize = 0;\n                }\n                else if ( ( pC.cacheStatus == p.cacheCtr ) && ( pC.aRow != -1 ) )\n                {\n                  payloadSize = pC.payloadSize;\n                  zRec = new byte[payloadSize];\n                  Buffer.BlockCopy( pCrsr.info.pCell, pC.aRow, zRec, 0, (int)payloadSize );\n                }\n                else if ( pC.isIndex )\n                {\n                  Debug.Assert( sqlite3BtreeCursorIsValid( pCrsr ) );\n                  rc=sqlite3BtreeKeySize( pCrsr, ref payloadSize64 );\n                  Debug.Assert( rc == SQLITE_OK );   /* True because of CursorMoveto() call above */\n                  /* sqlite3BtreeParseCellPtr() uses getVarint32() to extract the\n                  ** payload size, so it is impossible for payloadSize64 to be\n                  ** larger than 32 bits. */\n                  Debug.Assert( ( (u64)payloadSize64 & SQLITE_MAX_U32 ) == (u64)payloadSize64 );\n                  payloadSize = (u32)payloadSize64;\n                }\n                else\n                {\n                  Debug.Assert( sqlite3BtreeCursorIsValid( pCrsr ) );\n                  rc = sqlite3BtreeDataSize(pCrsr, ref payloadSize);\n                  Debug.Assert( rc == SQLITE_OK );   /* DataSize() cannot fail */\n                }\n              }\n              else if ( pC.pseudoTable )\n              {\n                /* The record is the sole entry of a pseudo-table */\n                payloadSize = (Pgno)pC.nData;\n                zRec = pC.pData;\n                pC.cacheStatus = CACHE_STALE;\n                Debug.Assert( payloadSize == 0 || zRec != null );\n              }\n              else\n              {\n                /* Consider the row to be NULL */\n                payloadSize = 0;\n              }\n\n              /* If payloadSize is 0, then just store a NULL */\n              if ( payloadSize == 0 )\n              {\n                Debug.Assert( ( pDest.flags & MEM_Null ) != 0 );\n                goto op_column_out;\n              }\n              Debug.Assert( db.aLimit[SQLITE_LIMIT_LENGTH] >= 0 );\n              if ( payloadSize > (u32)db.aLimit[SQLITE_LIMIT_LENGTH] )\n              {\n                goto too_big;\n              }\n\n              nField = pC.nField;\n              Debug.Assert( p2 < nField );\n\n              /* Read and parse the table header.  Store the results of the parse\n              ** into the record header cache fields of the cursor.\n              */\n              aType = pC.aType;\n              if ( pC.cacheStatus == p.cacheCtr )\n              {\n                aOffset = pC.aOffset;\n              }\n              else\n              {\n                Debug.Assert( aType != null );\n                avail = 0;\n                //pC.aOffset = aOffset = aType[nField];\n                aOffset = new u32[nField];\n                pC.aOffset = aOffset;\n                pC.payloadSize = payloadSize;\n                pC.cacheStatus = p.cacheCtr;\n\n                /* Figure out how many bytes are in the header */\n                if ( zRec != null )\n                {\n                  zData = zRec;\n                }\n                else\n                {\n                  if ( pC.isIndex )\n                  {\n                    zData = sqlite3BtreeKeyFetch( pCrsr, ref avail, ref pC.aRow );\n                  }\n                  else\n                  {\n                    zData = sqlite3BtreeDataFetch( pCrsr, ref avail, ref pC.aRow );\n                  }\n                  /* If KeyFetch()/DataFetch() managed to get the entire payload,\n** save the payload in the pC.aRow cache.  That will save us from\n** having to make additional calls to fetch the content portion of\n** the record.\n*/\n                  Debug.Assert( avail >= 0 );\n                  if ( payloadSize <= (u32)avail )\n                  {\n                    zRec = zData;\n                    //pC.aRow = zData;\n                  }\n                  else\n                  {\n                    pC.aRow = -1; //pC.aRow = null;\n                  }\n                }\n                /* The following Debug.Assert is true in all cases accept when\n                ** the database file has been corrupted externally.\n                **    Debug.Assert( zRec!=0 || avail>=payloadSize || avail>=9 ); */\n                szHdr = getVarint32( zData, ref  offset );\n\n                /* Make sure a corrupt database has not given us an oversize header.\n                ** Do this now to avoid an oversize memory allocation.\n                **\n                ** Type entries can be between 1 and 5 bytes each.  But 4 and 5 byte\n                ** types use so much data space that there can only be 4096 and 32 of\n                ** them, respectively.  So the maximum header length results from a\n                ** 3-byte type for each of the maximum of 32768 columns plus three\n                ** extra bytes for the header length itself.  32768*3 + 3 = 98307.\n                */\n                if ( offset > 98307 )\n                {\n#if SQLITE_DEBUG\n                  rc = SQLITE_CORRUPT_BKPT();\n#else\nrc = SQLITE_CORRUPT_BKPT;\n#endif\n                  goto op_column_out;\n                }\n\n                /* Compute in len the number of bytes of data we need to read in order\n                ** to get nField type values.  offset is an upper bound on this.  But\n                ** nField might be significantly less than the true number of columns\n                ** in the table, and in that case, 5*nField+3 might be smaller than offset.\n                ** We want to minimize len in order to limit the size of the memory\n                ** allocation, especially if a corrupt database file has caused offset\n                ** to be oversized. Offset is limited to 98307 above.  But 98307 might\n                ** still exceed Robson memory allocation limits on some configurations.\n                ** On systems that cannot tolerate large memory allocations, nField*5+3\n                ** will likely be much smaller since nField will likely be less than\n                ** 20 or so.  This insures that Robson memory allocation limits are\n                ** not exceeded even for corrupt database files.\n                */\n                len = nField * 5 + 3;\n                if ( len > (int)offset ) len = (int)offset;\n\n                /* The KeyFetch() or DataFetch() above are fast and will get the entire\n                ** record header in most cases.  But they will fail to get the complete\n                ** record header if the record header does not fit on a single page\n                ** in the B-Tree.  When that happens, use sqlite3VdbeMemFromBtree() to\n                ** acquire the complete header text.\n                */\n                if ( zRec == null && avail < len )\n                {\n                  sMem.db = null;\n                  sMem.flags = 0;\n                  rc = sqlite3VdbeMemFromBtree( pCrsr, 0, len, pC.isIndex, sMem );\n                  if ( rc != SQLITE_OK )\n                  {\n                    goto op_column_out;\n                  }\n                  zData = sMem.zBLOB;\n                }\n                zEndHdr = len;// zData[len];\n                zIdx = szHdr;// zData[szHdr];\n\n                /* Scan the header and use it to fill in the aType[] and aOffset[]\n                ** arrays.  aType[i] will contain the type integer for the i-th\n                ** column and aOffset[i] will contain the offset from the beginning\n                ** of the record to the start of the data for the i-th column\n                */\n                offset64 = offset;\n                for ( i = 0 ; i < nField ; i++ )\n                {\n                  if ( zIdx < zEndHdr )\n                  {\n                    aOffset[i] = (u32)offset64;\n                    zIdx += getVarint32( zData, zIdx, ref aType[i] );//getVarint32(zIdx, aType[i]);\n                    offset64 += sqlite3VdbeSerialTypeLen( aType[i] );\n                  }\n                  else\n                  {\n                    /* If i is less that nField, then there are less fields in this\n                    ** record than SetNumColumns indicated there are columns in the\n                    ** table. Set the offset for any extra columns not present in\n                    ** the record to 0. This tells code below to store a NULL\n                    ** instead of deserializing a value from the record.\n                    */\n                    aOffset[i] = 0;\n                  }\n                }\n                sqlite3VdbeMemRelease( sMem );\n                sMem.flags = MEM_Null;\n\n                /* If we have read more header data than was contained in the header,\n                ** or if the end of the last field appears to be past the end of the\n                ** record, or if the end of the last field appears to be before the end\n                ** of the record (when all fields present), then we must be dealing\n                ** with a corrupt database.\n                */\n                if ( zIdx > zEndHdr || offset64 > payloadSize\n                || ( zIdx == zEndHdr && offset64 != (u64)payloadSize ) )\n                {\n#if SQLITE_DEBUG\n                  rc = SQLITE_CORRUPT_BKPT();\n#else\nrc = SQLITE_CORRUPT_BKPT;\n#endif\n                  goto op_column_out;\n                }\n              }\n\n              /* Get the column information. If aOffset[p2] is non-zero, then\n              ** deserialize the value from the record. If aOffset[p2] is zero,\n              ** then there are not enough fields in the record to satisfy the\n              ** request.  In this case, set the value NULL or to P4 if P4 is\n              ** a pointer to a Mem object.\n              */\n              if ( aOffset[p2] != 0 )\n              {\n                Debug.Assert( rc == SQLITE_OK );\n                if ( zRec != null )\n                {\n                  sqlite3VdbeMemReleaseExternal( pDest );\n                  sqlite3VdbeSerialGet( zRec, (int)aOffset[p2], aType[p2], pDest );\n                }\n                else\n                {\n                  len = (int)sqlite3VdbeSerialTypeLen( aType[p2] );\n                  sqlite3VdbeMemMove( sMem, pDest );\n                  rc = sqlite3VdbeMemFromBtree( pCrsr, (int)aOffset[p2], len, pC.isIndex, sMem );\n                  if ( rc != SQLITE_OK )\n                  {\n                    goto op_column_out;\n                  }\n                  zData = (byte[])sMem.zBLOB.Clone();\n                  sqlite3VdbeSerialGet( zData, aType[p2], pDest );\n                }\n                pDest.enc = encoding;\n              }\n              else\n              {\n                if ( pOp.p4type == P4_MEM )\n                {\n                  sqlite3VdbeMemShallowCopy( pDest, pOp.p4.pMem, MEM_Static );\n                }\n                else\n                {\n                  Debug.Assert( ( pDest.flags & MEM_Null ) != 0 );\n                }\n              }\n\n              /* If we dynamically allocated space to hold the data (in the\n              ** sqlite3VdbeMemFromBtree() call above) then transfer control of that\n              ** dynamically allocated space over to the pDest structure.\n              ** This prevents a memory copy.\n              */\n              //if ( sMem.zMalloc != null )\n              //{\n              //  //Debug.Assert( sMem.z == sMem.zMalloc);\n              //  Debug.Assert( sMem.xDel == null );\n              //  Debug.Assert( ( pDest.flags & MEM_Dyn ) == 0 );\n              //  Debug.Assert( ( pDest.flags & ( MEM_Blob | MEM_Str ) ) == 0 || pDest.z == sMem.z );\n              //  pDest.flags &= ~( MEM_Ephem | MEM_Static );\n              //  pDest.flags |= MEM_Term;\n              //  pDest.z = sMem.z;\n              //  pDest.zMalloc = sMem.zMalloc;\n              //}\n\n              rc = sqlite3VdbeMemMakeWriteable( pDest );\n\nop_column_out:\n#if SQLITE_TEST\n              UPDATE_MAX_BLOBSIZE( pDest );\n#endif\n#if SQLITE_DEBUG\n              REGISTER_TRACE( p, pOp.p3, pDest );\n#endif\n              break;\n            }\n\n          /* Opcode: Affinity P1 P2 * P4 *\n          **\n          ** Apply affinities to a range of P2 registers starting with P1.\n          **\n          ** P4 is a string that is P2 characters long. The nth character of the\n          ** string indicates the column affinity that should be used for the nth\n          ** memory cell in the range.\n          */\n          case OP_Affinity:\n            {\n              string zAffinity;   /* The affinity to be applied */\n              //Mem pData0;       /* First register to which to apply affinity */\n              //Mem pLast;        /* Last register to which to apply affinity */\n              Mem pRec;           /* Current register */\n\n              zAffinity = pOp.p4.z;\n              //pData0 = &p->aMem[pOp->p1];\n              //pLast = &pData0[pOp->p2 - 1];\n              //for ( pRec = pData0 ; pRec <= pLast ; pRec++ )\n              for ( int pD0 = pOp.p1 ; pD0 <= pOp.p1 + pOp.p2 - 1 ; pD0++ )\n              {\n                pRec = p.aMem[pD0];\n                ExpandBlob( pRec );\n                applyAffinity( pRec, (char)zAffinity[pD0 - pOp.p1], encoding );\n              }\n              break;\n            }\n\n          /* Opcode: MakeRecord P1 P2 P3 P4 *\n          **\n          ** Convert P2 registers beginning with P1 into a single entry\n          ** suitable for use as a data record in a database table or as a key\n          ** in an index.  The details of the format are irrelevant as long as\n          ** the OP_Column opcode can decode the record later.\n          ** Refer to source code comments for the details of the record\n          ** format.\n          **\n          ** P4 may be a string that is P2 characters long.  The nth character of the\n          ** string indicates the column affinity that should be used for the nth\n          ** field of the index key.\n          **\n          ** The mapping from character to affinity is given by the SQLITE_AFF_\n          ** macros defined in sqliteInt.h.\n          **\n          ** If P4 is NULL then all index fields have the affinity NONE.\n          */\n          case OP_MakeRecord:\n            {\n              byte[] zNewRecord;     /* A buffer to hold the data for the new record */\n              Mem pRec;              /* The new record */\n              u64 nData;             /* Number of bytes of data space */\n              int nHdr;              /* Number of bytes of header space */\n              i64 nByte;             /* Data space required for this record */\n              int nZero;             /* Number of zero bytes at the end of the record */\n              int nVarint;           /* Number of bytes in a varint */\n              u32 serial_type;       /* Type field */\n              //Mem pData0;            /* First field to be combined into the record */\n              //Mem pLast;             /* Last field of the record */\n              int nField;            /* Number of fields in the record */\n              string zAffinity;      /* The affinity string for the record */\n              int file_format;       /* File format to use for encoding */\n              int i;                 /* Space used in zNewRecord[] */\n              int len;               /* Length of a field */\n              /* Assuming the record contains N fields, the record format looks\n              ** like this:\n              **\n              ** ------------------------------------------------------------------------\n              ** | hdr-size | type 0 | type 1 | ... | type N-1 | data0 | ... | data N-1 |\n              ** ------------------------------------------------------------------------\n              **\n              ** Data(0) is taken from register P1.  Data(1) comes from register P1+1\n              ** and so froth.\n              **\n              ** Each type field is a varint representing the serial type of the\n              ** corresponding data element (see sqlite3VdbeSerialType()). The\n              ** hdr-size field is also a varint which is the offset from the beginning\n              ** of the record to data0.\n              */\n\n              nData = 0;         /* Number of bytes of data space */\n              nHdr = 0;          /* Number of bytes of header space */\n              nByte = 0;         /* Data space required for this record */\n              nZero = 0;         /* Number of zero bytes at the end of the record */\n              nField = pOp.p1;\n              zAffinity = ( pOp.p4.z == null || pOp.p4.z.Length == 0 ) ? "" : pOp.p4.z;\n              Debug.Assert( nField > 0 && pOp.p2 > 0 && pOp.p2 + nField <= p.nMem + 1 );\n              //pData0 = p.aMem[nField];\n              nField = pOp.p2;\n              //pLast =  pData0[nField - 1];\n              file_format = p.minWriteFileFormat;\n\n              /* Loop through the elements that will make up the record to figure\n              ** out how much space is required for the new record.\n              */\n              //for (pRec = pData0; pRec <= pLast; pRec++)\n              for ( int pD0 = 0 ; pD0 < nField ; pD0++ )\n              {\n                pRec = p.aMem[pOp.p1 + pD0];\n                if ( pD0 < zAffinity.Length && zAffinity[pD0] != \'\\0\' )\n                {\n                  applyAffinity( pRec, (char)zAffinity[pD0], encoding );\n                }\n                if ( ( pRec.flags & MEM_Zero ) != 0 && pRec.n > 0 )\n                {\n                  sqlite3VdbeMemExpandBlob( pRec );\n                }\n                serial_type = sqlite3VdbeSerialType( pRec, file_format );\n                len = (int)sqlite3VdbeSerialTypeLen( serial_type );\n                nData += (u64)len;\n                nHdr += sqlite3VarintLen( serial_type );\n                if ( ( pRec.flags & MEM_Zero ) != 0 )\n                {\n                  /* Only pure zero-filled BLOBs can be input to this Opcode.\n                  ** We do not allow blobs with a prefix and a zero-filled tail. */\n                  nZero += pRec.u.nZero;\n                }\n                else if ( len != 0 )\n                {\n                  nZero = 0;\n                }\n              }\n\n              /* Add the initial header varint and total the size */\n              nHdr += nVarint = sqlite3VarintLen( (u64)nHdr );\n              if ( nVarint < sqlite3VarintLen( (u64)nHdr ) )\n              {\n                nHdr++;\n              }\n              nByte = (i64)( (u64)nHdr + nData - (u64)nZero );\n              if ( nByte > db.aLimit[SQLITE_LIMIT_LENGTH] )\n              {\n                goto too_big;\n              }\n\n              /* Make sure the output register has a buffer large enough to store\n              ** the new record. The output register (pOp.p3) is not allowed to\n              ** be one of the input registers (because the following call to\n              ** sqlite3VdbeMemGrow() could clobber the value before it is used).\n              */\n              Debug.Assert( pOp.p3 < pOp.p1 || pOp.p3 >= pOp.p1 + pOp.p2 );\n              pOut = p.aMem[pOp.p3];\n              //if ( sqlite3VdbeMemGrow( pOut, (int)nByte, 0 ) != 0 )\n              //{\n              //  goto no_mem;\n              //}\n              zNewRecord = new byte[nByte];// (u8 *)pOut.z;\n\n              /* Write the record */\n              i = putVarint32( zNewRecord, nHdr );\n              for ( int pD0 = 0 ; pD0 < nField ; pD0++ )//for (pRec = pData0; pRec <= pLast; pRec++)\n              {\n                pRec = p.aMem[pOp.p1 + pD0];\n                serial_type = sqlite3VdbeSerialType( pRec, file_format );\n                i += putVarint32( zNewRecord, i, (int)serial_type );      /* serial type */\n              }\n              for ( int pD0 = 0 ; pD0 < nField ; pD0++ )//for (pRec = pData0; pRec <= pLast; pRec++)\n              {  /* serial data */\n                pRec = p.aMem[pOp.p1 + pD0];\n                i += (int)sqlite3VdbeSerialPut( zNewRecord, i, (int)nByte - i, pRec, file_format );\n              }\n              Debug.Assert( i == nByte );\n\n              Debug.Assert( pOp.p3 > 0 && pOp.p3 <= p.nMem );\n              pOut.zBLOB = (byte[])zNewRecord.Clone();\n              pOut.z = null;\n              pOut.n = (int)nByte;\n              pOut.flags = MEM_Blob | MEM_Dyn;\n              pOut.xDel = null;\n              if ( nZero != 0 )\n              {\n                pOut.u.nZero = nZero;\n                pOut.flags |= MEM_Zero;\n              }\n              pOut.enc = SQLITE_UTF8;  /* In case the blob is ever converted to text */\n#if SQLITE_DEBUG\n              REGISTER_TRACE( p, pOp.p3, pOut );\n#endif\n#if SQLITE_TEST\n              UPDATE_MAX_BLOBSIZE( pOut );\n#endif\n              break;\n            }\n\n          /* Opcode: Count P1 P2 * * *\n          **\n          ** Store the number of entries (an integer value) in the table or index\n          ** opened by cursor P1 in register P2\n          */\n#if !SQLITE_OMIT_BTREECOUNT\n          case OP_Count:\n            {         /* out2-prerelease */\n              i64 nEntry = 0;\n              BtCursor pCrsr;\n              pCrsr = p.apCsr[pOp.p1].pCursor;\n              if ( pCrsr != null )\n              {\n                rc = sqlite3BtreeCount( pCrsr, ref nEntry );\n              }\n              else\n              {\n                nEntry = 0;\n              }\n              pOut.flags = MEM_Int;\n              pOut.u.i = nEntry;\n              break;\n            }\n#endif\n\n          /* Opcode: Statement P1 * * * *\n**\n** Begin an individual statement transaction which is part of a larger\n** transaction.  This is needed so that the statement\n** can be rolled back after an error without having to roll back the\n** entire transaction.  The statement transaction will automatically\n** commit when the VDBE halts.\n**\n** If the database connection is currently in autocommit mode (that\n** is to say, if it is in between BEGIN and COMMIT)\n** and if there are no other active statements on the same database\n** connection, then this operation is a no-op.  No statement transaction\n** is needed since any error can use the normal ROLLBACK process to\n** undo changes.\n**\n** If a statement transaction is started, then a statement journal file\n** will be allocated and initialized.\n**\n** The statement is begun on the database file with index P1.  The main\n** database file has an index of 0 and the file used for temporary tables\n** has an index of 1.\n*/\n          case OP_Statement:\n            {\n              Btree pBt;\n              if ( db.autoCommit == 0 || db.activeVdbeCnt > 1 )\n              {\n                Debug.Assert( pOp.p1 >= 0 && pOp.p1 < db.nDb );\n                Debug.Assert( db.aDb[pOp.p1].pBt != null );\n                pBt = db.aDb[pOp.p1].pBt;\n                Debug.Assert( sqlite3BtreeIsInTrans( pBt ) );\n                Debug.Assert( ( p.btreeMask & ( 1 << pOp.p1 ) ) != 0 );\n                if ( p.iStatement == 0 )\n                {\n                  Debug.Assert( db.nStatement >= 0 && db.nSavepoint >= 0 );\n                  db.nStatement++;\n                  p.iStatement = db.nSavepoint + db.nStatement;\n                }\n                rc = sqlite3BtreeBeginStmt( pBt, p.iStatement );\n              }\n              break;\n            }\n\n          /* Opcode: Savepoint P1 * * P4 *\n          **\n          ** Open, release or rollback the savepoint named by parameter P4, depending\n          ** on the value of P1. To open a new savepoint, P1==0. To release (commit) an\n          ** existing savepoint, P1==1, or to rollback an existing savepoint P1==2.\n          */\n          case OP_Savepoint:\n            {\n              int p1;                         /* Value of P1 operand */\n              string zName;                   /* Name of savepoint */\n              int nName;\n              Savepoint pNew;\n              Savepoint pSavepoint;\n              Savepoint pTmp;\n              int iSavepoint;\n              int ii;\n\n              p1 = pOp.p1;\n              zName = pOp.p4.z;\n\n              /* Assert that the p1 parameter is valid. Also that if there is no open\n              ** transaction, then there cannot be any savepoints.\n              */\n              Debug.Assert( db.pSavepoint == null || db.autoCommit == 0 );\n              Debug.Assert( p1 == SAVEPOINT_BEGIN || p1 == SAVEPOINT_RELEASE || p1 == SAVEPOINT_ROLLBACK );\n              Debug.Assert( db.pSavepoint != null || db.isTransactionSavepoint == 0 );\n              Debug.Assert( checkSavepointCount( db ) != 0 );\n\n              if ( p1 == SAVEPOINT_BEGIN )\n              {\n                if ( db.writeVdbeCnt > 0 )\n                {\n                  /* A new savepoint cannot be created if there are active write\n                  ** statements (i.e. open read/write incremental blob handles).\n                  */\n                  sqlite3SetString( ref p.zErrMsg, db, "cannot open savepoint - ",\n                  "SQL statements in progress" );\n                  rc = SQLITE_BUSY;\n                }\n                else\n                {\n                  nName = sqlite3Strlen30( zName );\n\n                  /* Create a new savepoint structure. */\n                  pNew = new Savepoint();// sqlite3DbMallocRaw( db, sizeof( Savepoint ) + nName + 1 );\n                  if ( pNew != null )\n                  {\n                    //pNew.zName = (char *)&pNew[1];\n                    //memcpy(pNew.zName, zName, nName+1);\n                    pNew.zName = zName;\n\n                    /* If there is no open transaction, then mark this as a special\n                    ** "transaction savepoint". */\n                    if ( db.autoCommit != 0 )\n                    {\n                      db.autoCommit = 0;\n                      db.isTransactionSavepoint = 1;\n                    }\n                    else\n                    {\n                      db.nSavepoint++;\n                    }\n\n                    /* Link the new savepoint into the database handle\'s list. */\n                    pNew.pNext = db.pSavepoint;\n                    db.pSavepoint = pNew;\n                  }\n                }\n              }\n              else\n              {\n                iSavepoint = 0;\n\n                /* Find the named savepoint. If there is no such savepoint, then an\n                ** an error is returned to the user.  */\n                for (\n                pSavepoint = db.pSavepoint ;\n                pSavepoint != null && sqlite3StrICmp( pSavepoint.zName, zName ) != 0 ;\n                pSavepoint = pSavepoint.pNext\n                )\n                {\n                  iSavepoint++;\n                }\n                if ( null == pSavepoint )\n                {\n                  sqlite3SetString( ref p.zErrMsg, db, "no such savepoint: %s", zName );\n                  rc = SQLITE_ERROR;\n                }\n                else if (\n                db.writeVdbeCnt > 0 || ( p1 == SAVEPOINT_ROLLBACK && db.activeVdbeCnt > 1 )\n                )\n                {\n                  /* It is not possible to release (commit) a savepoint if there are\n                  ** active write statements. It is not possible to rollback a savepoint\n                  ** if there are any active statements at all.\n                  */\n                  sqlite3SetString( ref p.zErrMsg, db,\n                  "cannot %s savepoint - SQL statements in progress",\n                  ( p1 == SAVEPOINT_ROLLBACK ? "rollback" : "release" )\n                  );\n                  rc = SQLITE_BUSY;\n                }\n                else\n                {\n\n                  /* Determine whether or not this is a transaction savepoint. If so,\n                  ** and this is a RELEASE command, then the current transaction\n                  ** is committed.\n                  */\n                  int isTransaction = ( pSavepoint.pNext == null && db.isTransactionSavepoint != 0 ) ? 1 : 0;\n                  if ( isTransaction != 0 && p1 == SAVEPOINT_RELEASE )\n                  {\n                    db.autoCommit = 1;\n                    if ( sqlite3VdbeHalt( p ) == SQLITE_BUSY )\n                    {\n                      p.pc = pc;\n                      db.autoCommit = 0;\n                      p.rc = rc = SQLITE_BUSY;\n                      goto vdbe_return;\n                    }\n                    db.isTransactionSavepoint = 0;\n                    rc = p.rc;\n                  }\n                  else\n                  {\n                    iSavepoint = db.nSavepoint - iSavepoint - 1;\n                    for ( ii = 0 ; ii < db.nDb ; ii++ )\n                    {\n                      rc = sqlite3BtreeSavepoint( db.aDb[ii].pBt, p1, iSavepoint );\n                      if ( rc != SQLITE_OK )\n                      {\n                        goto abort_due_to_error;\n                      }\n                    }\n                    if ( p1 == SAVEPOINT_ROLLBACK && ( db.flags & SQLITE_InternChanges ) != 0 )\n                    {\n                      sqlite3ExpirePreparedStatements( db );\n                      sqlite3ResetInternalSchema( db, 0 );\n                    }\n                  }\n\n                  /* Regardless of whether this is a RELEASE or ROLLBACK, destroy all\n                  ** savepoints nested inside of the savepoint being operated on. */\n                  while ( db.pSavepoint != pSavepoint )\n                  {\n                    pTmp = db.pSavepoint;\n                    db.pSavepoint = pTmp.pNext;\n                    //sqlite3DbFree( db, pTmp );\n                    db.nSavepoint--;\n                  }\n\n                  /* If it is a RELEASE, then destroy the savepoint being operated on too */\n                  if ( p1 == SAVEPOINT_RELEASE )\n                  {\n                    Debug.Assert( pSavepoint == db.pSavepoint );\n                    db.pSavepoint = pSavepoint.pNext;\n                    //sqlite3DbFree( db, pSavepoint );\n                    if ( 0 == isTransaction )\n                    {\n                      db.nSavepoint--;\n                    }\n                  }\n                }\n              }\n\n              break;\n            }\n\n          /* Opcode: AutoCommit P1 P2 * * *\n          **\n          ** Set the database auto-commit flag to P1 (1 or 0). If P2 is true, roll\n          ** back any currently active btree transactions. If there are any active\n          ** VMs (apart from this one), then the COMMIT or ROLLBACK statement fails.\n          **\n          ** This instruction causes the VM to halt.\n          */\n          case OP_AutoCommit:\n            {\n              int desiredAutoCommit;\n              int iRollback;\n              int turnOnAC;\n\n              desiredAutoCommit = (u8)pOp.p1;\n              iRollback = pOp.p2;\n              turnOnAC = ( desiredAutoCommit != 0 && 0 == db.autoCommit ) ? 1 : 0;\n\n              Debug.Assert( desiredAutoCommit != 0 || 0 == desiredAutoCommit );\n              Debug.Assert( desiredAutoCommit != 0 || 0 == iRollback );\n\n              Debug.Assert( db.activeVdbeCnt > 0 );  /* At least this one VM is active */\n\n              if ( turnOnAC != 0 && iRollback != 0 && db.activeVdbeCnt > 1 )\n              {\n                /* If this instruction implements a ROLLBACK and other VMs are\n                ** still running, and a transaction is active, return an error indicating\n                ** that the other VMs must complete first.\n                */\n                sqlite3SetString( ref p.zErrMsg, db, "cannot rollback transaction - " +\n                "SQL statements in progress" );\n                rc = SQLITE_BUSY;\n              }\n              else if ( turnOnAC != 0 && 0 == iRollback && db.writeVdbeCnt > 0 )\n              {\n                /* If this instruction implements a COMMIT and other VMs are writing\n                ** return an error indicating that the other VMs must complete first.\n                */\n                sqlite3SetString( ref p.zErrMsg, db, "cannot commit transaction - " +\n                "SQL statements in progress" );\n                rc = SQLITE_BUSY;\n              }\n              else if ( desiredAutoCommit != db.autoCommit )\n              {\n                if ( iRollback != 0 )\n                {\n                  Debug.Assert( desiredAutoCommit != 0 );\n                  sqlite3RollbackAll( db );\n                  db.autoCommit = 1;\n                }\n                else\n                {\n                  db.autoCommit = (u8)desiredAutoCommit;\n                  if ( sqlite3VdbeHalt( p ) == SQLITE_BUSY )\n                  {\n                    p.pc = pc;\n                    db.autoCommit = (u8)( desiredAutoCommit == 0 ? 1 : 0 );\n                    p.rc = rc = SQLITE_BUSY;\n                    goto vdbe_return;\n                  }\n                }\n                Debug.Assert( db.nStatement == 0 );\n                sqlite3CloseSavepoints( db );\n                if ( p.rc == SQLITE_OK )\n                {\n                  rc = SQLITE_DONE;\n                }\n                else\n                {\n                  rc = SQLITE_ERROR;\n                }\n                goto vdbe_return;\n              }\n              else\n              {\n                sqlite3SetString( ref p.zErrMsg, db,\n                ( 0 == desiredAutoCommit ) ? "cannot start a transaction within a transaction" : (\n                ( iRollback != 0 ) ? "cannot rollback - no transaction is active" :\n                "cannot commit - no transaction is active" ) );\n                rc = SQLITE_ERROR;\n              }\n              break;\n            }\n\n          /* Opcode: Transaction P1 P2 * * *\n          **\n          ** Begin a transaction.  The transaction ends when a Commit or Rollback\n          ** opcode is encountered.  Depending on the ON CONFLICT setting, the\n          ** transaction might also be rolled back if an error is encountered.\n          **\n          ** P1 is the index of the database file on which the transaction is\n          ** started.  Index 0 is the main database file and index 1 is the\n          ** file used for temporary tables.  Indices of 2 or more are used for\n          ** attached databases.\n          **\n          ** If P2 is non-zero, then a write-transaction is started.  A RESERVED lock is\n          ** obtained on the database file when a write-transaction is started.  No\n          ** other process can start another write transaction while this transaction is\n          ** underway.  Starting a write transaction also creates a rollback journal. A\n          ** write transaction must be started before any changes can be made to the\n          ** database.  If P2 is 2 or greater then an EXCLUSIVE lock is also obtained\n          ** on the file.\n          **\n          ** If P2 is zero, then a read-lock is obtained on the database file.\n          */\n          case OP_Transaction:\n            {\n              Btree pBt;\n\n              Debug.Assert( pOp.p1 >= 0 && pOp.p1 < db.nDb );\n              Debug.Assert( ( p.btreeMask & ( 1 << pOp.p1 ) ) != 0 );\n              pBt = db.aDb[pOp.p1].pBt;\n\n              if ( pBt != null )\n              {\n                rc = sqlite3BtreeBeginTrans( pBt, pOp.p2 );\n                if ( rc == SQLITE_BUSY )\n                {\n                  p.pc = pc;\n                  p.rc = rc = SQLITE_BUSY;\n                  goto vdbe_return;\n                }\n                if ( rc != SQLITE_OK && rc != SQLITE_READONLY /* && rc!=SQLITE_BUSY */ )\n                {\n                  goto abort_due_to_error;\n                }\n              }\n              break;\n            }\n\n          /* Opcode: ReadCookie P1 P2 P3 * *\n          **\n          ** Read cookie number P3 from database P1 and write it into register P2.\n          ** P3==1 is the schema version.  P3==2 is the database format.\n          ** P3==3 is the recommended pager cache size, and so forth.  P1==0 is\n          ** the main database file and P1==1 is the database file used to store\n          ** temporary tables.\n          **\n          ** There must be a read-lock on the database (either a transaction\n          ** must be started or there must be an open cursor) before\n          ** executing this instruction.\n          */\n          case OP_ReadCookie:\n            {               /* out2-prerelease */\n              u32 iMeta;\n              int iDb;\n              int iCookie;\n\n              iMeta = 0;\n              iDb = pOp.p1;\n              iCookie = pOp.p3;\n\n              Debug.Assert( pOp.p3 < SQLITE_N_BTREE_META );\n              Debug.Assert( iDb >= 0 && iDb < db.nDb );\n              Debug.Assert( db.aDb[iDb].pBt != null );\n              Debug.Assert( ( p.btreeMask & ( 1 << iDb ) ) != 0 );\n              sqlite3BtreeGetMeta( db.aDb[iDb].pBt, iCookie, ref iMeta );\n              pOut.u.i = (int)iMeta;\n              MemSetTypeFlag( pOut, MEM_Int );\n              break;\n            }\n\n          /* Opcode: SetCookie P1 P2 P3 * *\n          **\n          ** Write the content of register P3 (interpreted as an integer)\n          ** into cookie number P2 of database P1.  P2==1 is the schema version.\n          ** P2==2 is the database format. P2==3 is the recommended pager cache\n          ** size, and so forth.  P1==0 is the main database file and P1==1 is the\n          ** database file used to store temporary tables.\n          **\n          ** A transaction must be started before executing this opcode.\n          */\n          case OP_SetCookie:\n            {       /* in3 */\n              Db pDb;\n              Debug.Assert( pOp.p2 < SQLITE_N_BTREE_META );\n              Debug.Assert( pOp.p1 >= 0 && pOp.p1 < db.nDb );\n              Debug.Assert( ( p.btreeMask & ( 1 << pOp.p1 ) ) != 0 );\n              pDb = db.aDb[pOp.p1];\n              Debug.Assert( pDb.pBt != null );\n              sqlite3VdbeMemIntegerify( pIn3 );\n              /* See note about index shifting on OP_ReadCookie */\n              rc = sqlite3BtreeUpdateMeta( pDb.pBt, pOp.p2, (u32)pIn3.u.i );\n              if ( pOp.p2 == BTREE_SCHEMA_VERSION )\n              {\n                /* When the schema cookie changes, record the new cookie internally */\n                pDb.pSchema.schema_cookie = (int)pIn3.u.i;\n                db.flags |= SQLITE_InternChanges;\n              }\n              else if ( pOp.p2 == BTREE_FILE_FORMAT )\n              {\n                /* Record changes in the file format */\n                pDb.pSchema.file_format = (u8)pIn3.u.i;\n              }\n              if ( pOp.p1 == 1 )\n              {\n                /* Invalidate all prepared statements whenever the TEMP database\n                ** schema is changed.  Ticket #1644 */\n                sqlite3ExpirePreparedStatements( db );\n              }\n              break;\n            }\n\n          /* Opcode: VerifyCookie P1 P2 *\n          **\n          ** Check the value of global database parameter number 0 (the\n          ** schema version) and make sure it is equal to P2.\n          ** P1 is the database number which is 0 for the main database file\n          ** and 1 for the file holding temporary tables and some higher number\n          ** for auxiliary databases.\n          **\n          ** The cookie changes its value whenever the database schema changes.\n          ** This operation is used to detect when that the cookie has changed\n          ** and that the current process needs to reread the schema.\n          **\n          ** Either a transaction needs to have been started or an OP_Open needs\n          ** to be executed (to establish a read lock) before this opcode is\n          ** invoked.\n          */\n          case OP_VerifyCookie:\n            {\n              u32 iMeta = 0;\n              Btree pBt;\n              Debug.Assert( pOp.p1 >= 0 && pOp.p1 < db.nDb );\n              Debug.Assert( ( p.btreeMask & ( 1 << pOp.p1 ) ) != 0 );\n              pBt = db.aDb[pOp.p1].pBt;\n              if ( pBt != null )\n              {\n                sqlite3BtreeGetMeta( pBt, BTREE_SCHEMA_VERSION, ref iMeta );\n              }\n              else\n              {\n                iMeta = 0;\n              }\n              if ( iMeta != pOp.p2 )\n              {\n                //sqlite3DbFree(db,ref p.zErrMsg);\n                p.zErrMsg = "database schema has changed";// sqlite3DbStrDup(db, "database schema has changed");\n                /* If the schema-cookie from the database file matches the cookie\n                ** stored with the in-memory representation of the schema, do\n                ** not reload the schema from the database file.\n                **\n                ** If virtual-tables are in use, this is not just an optimization.\n                ** Often, v-tables store their data in other SQLite tables, which\n                ** are queried from within xNext() and other v-table methods using\n                ** prepared queries. If such a query is out-of-date, we do not want to\n                ** discard the database schema, as the user code implementing the\n                ** v-table would have to be ready for the sqlite3_vtab structure itself\n                ** to be invalidated whenever sqlite3_step() is called from within\n                ** a v-table method.\n                */\n                if ( db.aDb[pOp.p1].pSchema.schema_cookie != iMeta )\n                {\n                  sqlite3ResetInternalSchema( db, pOp.p1 );\n                }\n\n                sqlite3ExpirePreparedStatements( db );\n                rc = SQLITE_SCHEMA;\n              }\n              break;\n            }\n\n          /* Opcode: OpenRead P1 P2 P3 P4 P5\n          **\n          ** Open a read-only cursor for the database table whose root page is\n          ** P2 in a database file.  The database file is determined by P3.\n          ** P3==0 means the main database, P3==1 means the database used for\n          ** temporary tables, and P3>1 means used the corresponding attached\n          ** database.  Give the new cursor an identifier of P1.  The P1\n          ** values need not be contiguous but all P1 values should be small integers.\n          ** It is an error for P1 to be negative.\n          **\n          ** If P5!=0 then use the content of register P2 as the root page, not\n          ** the value of P2 itself.\n          **\n          ** There will be a read lock on the database whenever there is an\n          ** open cursor.  If the database was unlocked prior to this instruction\n          ** then a read lock is acquired as part of this instruction.  A read\n          ** lock allows other processes to read the database but prohibits\n          ** any other process from modifying the database.  The read lock is\n          ** released when all cursors are closed.  If this instruction attempts\n          ** to get a read lock but fails, the script terminates with an\n          ** SQLITE_BUSY error code.\n          **\n          ** The P4 value may be either an integer (P4_INT32) or a pointer to\n          ** a KeyInfo structure (P4_KEYINFO). If it is a pointer to a KeyInfo\n          ** structure, then said structure defines the content and collating\n          ** sequence of the index being opened. Otherwise, if P4 is an integer\n          ** value, it is set to the number of columns in the table.\n          **\n          ** See also OpenWrite.\n          */\n          /* Opcode: OpenWrite P1 P2 P3 P4 P5\n          **\n          ** Open a read/write cursor named P1 on the table or index whose root\n          ** page is P2.  Or if P5!=0 use the content of register P2 to find the\n          ** root page.\n          **\n          ** The P4 value may be either an integer (P4_INT32) or a pointer to\n          ** a KeyInfo structure (P4_KEYINFO). If it is a pointer to a KeyInfo\n          ** structure, then said structure defines the content and collating\n          ** sequence of the index being opened. Otherwise, if P4 is an integer\n          ** value, it is set to the number of columns in the table, or to the\n          ** largest index of any column of the table that is actually used.\n          **\n          ** This instruction works just like OpenRead except that it opens the cursor\n          ** in read/write mode.  For a given table, there can be one or more read-only\n          ** cursors or a single read/write cursor but not both.\n          **\n          ** See also OpenRead.\n          */\n          case OP_OpenRead:\n          case OP_OpenWrite:\n            {\n              int nField;\n              KeyInfo pKeyInfo;\n              int p2;\n              int iDb;\n              int wrFlag;\n              Btree pX;\n              VdbeCursor pCur;\n              Db pDb;\n\n              nField = 0;\n              pKeyInfo = null;\n              p2 = pOp.p2;\n              iDb = pOp.p3;\n              Debug.Assert( iDb >= 0 && iDb < db.nDb );\n              Debug.Assert( ( p.btreeMask & ( 1 << iDb ) ) != 0 );\n              pDb = db.aDb[iDb];\n              pX = pDb.pBt;\n              Debug.Assert( pX != null );\n              if ( pOp.opcode == OP_OpenWrite )\n              {\n                wrFlag = 1;\n                if ( pDb.pSchema.file_format < p.minWriteFileFormat )\n                {\n                  p.minWriteFileFormat = pDb.pSchema.file_format;\n                }\n              }\n              else\n              {\n                wrFlag = 0;\n              }\n              if ( pOp.p5 != 0 )\n              {\n                Debug.Assert( p2 > 0 );\n                Debug.Assert( p2 <= p.nMem );\n                pIn2 = p.aMem[p2];\n                sqlite3VdbeMemIntegerify( pIn2 );\n                p2 = (int)pIn2.u.i;\n                /* The p2 value always comes from a prior OP_CreateTable opcode and\n                ** that opcode will always set the p2 value to 2 or more or else fail.\n                ** If there were a failure, the prepared statement would have halted\n                ** before reaching this instruction. */\n                if ( NEVER( p2 < 2 ) )\n                {\n#if SQLITE_DEBUG\n                  rc = SQLITE_CORRUPT_BKPT();\n#else\nrc = SQLITE_CORRUPT_BKPT;\n#endif\n                  goto abort_due_to_error;\n                }\n              }\n              if ( pOp.p4type == P4_KEYINFO )\n              {\n                pKeyInfo = pOp.p4.pKeyInfo;\n                pKeyInfo.enc = ENC( p.db );\n                nField = pKeyInfo.nField + 1;\n              }\n              else if ( pOp.p4type == P4_INT32 )\n              {\n                nField = pOp.p4.i;\n              }\n              Debug.Assert( pOp.p1 >= 0 );\n              pCur = allocateCursor( p, pOp.p1, nField, iDb, 1 );\n              if ( pCur == null ) goto no_mem;\n              pCur.nullRow = true;\n              rc = sqlite3BtreeCursor( pX, p2, wrFlag, pKeyInfo, pCur.pCursor );\n              pCur.pKeyInfo = pKeyInfo;\n              /* Since it performs no memory allocation or IO, the only values that\n              ** sqlite3BtreeCursor() may return are SQLITE_EMPTY and SQLITE_OK. \n              ** SQLITE_EMPTY is only returned when attempting to open the table\n              ** rooted at page 1 of a zero-byte database.  */\n              Debug.Assert( rc==SQLITE_EMPTY || rc==SQLITE_OK );\n              if ( rc == SQLITE_EMPTY )\n              {\n                pCur.pCursor = null;\n                rc = SQLITE_OK;\n              }\n              /* Set the VdbeCursor.isTable and isIndex variables. Previous versions of\n              ** SQLite used to check if the root-page flags were sane at this point\n              ** and report database corruption if they were not, but this check has\n              ** since moved into the btree layer.  */\n                    pCur.isTable = pOp.p4type != P4_KEYINFO;\n                    pCur.isIndex = !pCur.isTable;\n              break;\n            }\n\n          /* Opcode: OpenEphemeral P1 P2 * P4 *\n          **\n          ** Open a new cursor P1 to a transient table.\n          ** The cursor is always opened read/write even if\n          ** the main database is read-only.  The transient or virtual\n          ** table is deleted automatically when the cursor is closed.\n          **\n          ** P2 is the number of columns in the virtual table.\n          ** The cursor points to a BTree table if P4==0 and to a BTree index\n          ** if P4 is not 0.  If P4 is not NULL, it points to a KeyInfo structure\n          ** that defines the format of keys in the index.\n          **\n          ** This opcode was once called OpenTemp.  But that created\n          ** confusion because the term "temp table", might refer either\n          ** to a TEMP table at the SQL level, or to a table opened by\n          ** this opcode.  Then this opcode was call OpenVirtual.  But\n          ** that created confusion with the whole virtual-table idea.\n          */\n          case OP_OpenEphemeral:\n            {\n              VdbeCursor pCx;\n              const int openFlags =\n              SQLITE_OPEN_READWRITE |\n              SQLITE_OPEN_CREATE |\n              SQLITE_OPEN_EXCLUSIVE |\n              SQLITE_OPEN_DELETEONCLOSE |\n              SQLITE_OPEN_TRANSIENT_DB;\n\n              Debug.Assert( pOp.p1 >= 0 );\n              pCx = allocateCursor( p, pOp.p1, pOp.p2, -1, 1 );\n              if ( pCx == null ) goto no_mem;\n              pCx.nullRow = true;\n              rc = sqlite3BtreeFactory( db, null, true, SQLITE_DEFAULT_TEMP_CACHE_SIZE, openFlags,\n              ref pCx.pBt );\n              if ( rc == SQLITE_OK )\n              {\n                rc = sqlite3BtreeBeginTrans( pCx.pBt, 1 );\n              }\n              if ( rc == SQLITE_OK )\n              {\n                /* If a transient index is required, create it by calling\n                ** sqlite3BtreeCreateTable() with the BTREE_ZERODATA flag before\n                ** opening it. If a transient table is required, just use the\n                ** automatically created table with root-page 1 (an INTKEY table).\n                */\n                if ( pOp.p4.pKeyInfo != null )\n                {\n                  int pgno = 0;\n                  Debug.Assert( pOp.p4type == P4_KEYINFO );\n                  rc = sqlite3BtreeCreateTable( pCx.pBt, ref pgno, BTREE_ZERODATA );\n                  if ( rc == SQLITE_OK )\n                  {\n                    Debug.Assert( pgno == MASTER_ROOT + 1 );\n                    rc = sqlite3BtreeCursor( pCx.pBt, pgno, 1,\n                    pOp.p4.pKeyInfo, pCx.pCursor );\n                    pCx.pKeyInfo = pOp.p4.pKeyInfo;\n                    pCx.pKeyInfo.enc = ENC( p.db );\n                  }\n                  pCx.isTable = false;\n                }\n                else\n                {\n                  rc = sqlite3BtreeCursor( pCx.pBt, MASTER_ROOT, 1, null, pCx.pCursor );\n                  pCx.isTable = true;\n                }\n              }\n              pCx.isIndex = !pCx.isTable;\n              break;\n            }\n\n          /* Opcode: OpenPseudo P1 P2 P3 * *\n          **\n          ** Open a new cursor that points to a fake table that contains a single\n          ** row of data.  Any attempt to write a second row of data causes the\n          ** first row to be deleted.  All data is deleted when the cursor is\n          ** closed.\n          **\n          ** A pseudo-table created by this opcode is useful for holding the\n          ** NEW or OLD tables in a trigger.  Also used to hold the a single\n          ** row output from the sorter so that the row can be decomposed into\n          ** individual columns using the OP_Column opcode.\n          **\n          ** When OP_Insert is executed to insert a row in to the pseudo table,\n          ** the pseudo-table cursor may or may not make it\'s own copy of the\n          ** original row data. If P2 is 0, then the pseudo-table will copy the\n          ** original row data. Otherwise, a pointer to the original memory cell\n          ** is stored. In this case, the vdbe program must ensure that the\n          ** memory cell containing the row data is not overwritten until the\n          ** pseudo table is closed (or a new row is inserted into it).\n          **\n          ** P3 is the number of fields in the records that will be stored by\n          ** the pseudo-table.\n          */\n          case OP_OpenPseudo:\n            {\n              VdbeCursor pCx;\n              Debug.Assert( pOp.p1 >= 0 );\n              pCx = allocateCursor( p, pOp.p1, pOp.p3, -1, 0 );\n              if ( pCx == null ) goto no_mem;\n              pCx.nullRow = true;\n              pCx.pseudoTable = true;\n              pCx.ephemPseudoTable = pOp.p2 != 0 ? true : false;\n              pCx.isTable = true;\n              pCx.isIndex = false;\n              break;\n            }\n\n          /* Opcode: Close P1 * * * *\n          **\n          ** Close a cursor previously opened as P1.  If P1 is not\n          ** currently open, this instruction is a no-op.\n          */\n          case OP_Close:\n            {\n              Debug.Assert( pOp.p1 >= 0 && pOp.p1 < p.nCursor );\n              sqlite3VdbeFreeCursor( p, p.apCsr[pOp.p1] );\n              p.apCsr[pOp.p1] = null;\n              break;\n            }\n\n          /* Opcode: SeekGe P1 P2 P3 P4 *\n          **\n          ** If cursor P1 refers to an SQL table (B-Tree that uses integer keys),\n          ** use the value in register P3 as the key.  If cursor P1 refers\n          ** to an SQL index, then P3 is the first in an array of P4 registers\n          ** that are used as an unpacked index key.\n          **\n          ** Reposition cursor P1 so that  it points to the smallest entry that\n          ** is greater than or equal to the key value. If there are no records\n          ** greater than or equal to the key and P2 is not zero, then jump to P2.\n          **\n          ** See also: Found, NotFound, Distinct, SeekLt, SeekGt, SeekLe\n          */\n          /* Opcode: SeekGt P1 P2 P3 P4 *\n          **\n          ** If cursor P1 refers to an SQL table (B-Tree that uses integer keys),\n          ** use the value in register P3 as a key. If cursor P1 refers\n          ** to an SQL index, then P3 is the first in an array of P4 registers\n          ** that are used as an unpacked index key.\n          **\n          ** Reposition cursor P1 so that  it points to the smallest entry that\n          ** is greater than the key value. If there are no records greater than\n          ** the key and P2 is not zero, then jump to P2.\n          **\n          ** See also: Found, NotFound, Distinct, SeekLt, SeekGe, SeekLe\n          */\n          /* Opcode: SeekLt P1 P2 P3 P4 *\n          **\n          ** If cursor P1 refers to an SQL table (B-Tree that uses integer keys),\n          ** use the value in register P3 as a key. If cursor P1 refers\n          ** to an SQL index, then P3 is the first in an array of P4 registers\n          ** that are used as an unpacked index key.\n          **\n          ** Reposition cursor P1 so that  it points to the largest entry that\n          ** is less than the key value. If there are no records less than\n          ** the key and P2 is not zero, then jump to P2.\n          **\n          ** See also: Found, NotFound, Distinct, SeekGt, SeekGe, SeekLe\n          */\n          /* Opcode: SeekLe P1 P2 P3 P4 *\n          **\n          ** If cursor P1 refers to an SQL table (B-Tree that uses integer keys),\n          ** use the value in register P3 as a key. If cursor P1 refers\n          ** to an SQL index, then P3 is the first in an array of P4 registers\n          ** that are used as an unpacked index key.\n          **\n          ** Reposition cursor P1 so that it points to the largest entry that\n          ** is less than or equal to the key value. If there are no records\n          ** less than or equal to the key and P2 is not zero, then jump to P2.\n          **\n          ** See also: Found, NotFound, Distinct, SeekGt, SeekGe, SeekLt\n          */\n          case OP_SeekLt:         /* jump, in3 */\n          case OP_SeekLe:         /* jump, in3 */\n          case OP_SeekGe:         /* jump, in3 */\n          case OP_SeekGt:\n            {       /* jump, in3 */\n              int res;\n              int oc;\n              VdbeCursor pC;\n              UnpackedRecord r;\n              int nField;\n              i64 iKey;      /* The rowid we are to seek to */\n\n              res = 0;\n              r = new UnpackedRecord();\n\n              Debug.Assert( pOp.p1 >= 0 && pOp.p1 < p.nCursor );\n              Debug.Assert( pOp.p2 != 0 );\n              pC = p.apCsr[pOp.p1];\n              Debug.Assert( pC != null );\n              if ( pC.pCursor != null )\n              {\n                oc = pOp.opcode;\n                pC.nullRow = false;\n                if ( pC.isTable )\n                {\n                  /* The input value in P3 might be of any type: integer, real, string,\n                  ** blob, or NULL.  But it needs to be an integer before we can do\n                  ** the seek, so covert it. */\n                  applyNumericAffinity( pIn3 );\n                  iKey = sqlite3VdbeIntValue( pIn3 );\n                  pC.rowidIsValid = false;\n\n                  /* If the P3 value could not be converted into an integer without\n                  ** loss of information, then special processing is required... */\n                  if ( ( pIn3.flags & MEM_Int ) == 0 )\n                  {\n                    if ( ( pIn3.flags & MEM_Real ) == 0 )\n                    {\n                      /* If the P3 value cannot be converted into any kind of a number,\n                      ** then the seek is not possible, so jump to P2 */\n                      pc = pOp.p2 - 1;\n                      break;\n                    }\n                    /* If we reach this point, then the P3 value must be a floating\n                    ** point number. */\n                    Debug.Assert( ( pIn3.flags & MEM_Real ) != 0 );\n\n                    if ( iKey == SMALLEST_INT64 && ( pIn3.r < (double)iKey || pIn3.r > 0 ) )\n                    {\n                      /* The P3 value is too large in magnitude to be expressed as an\n                      ** integer. */\n                      res = 1;\n                      if ( pIn3.r < 0 )\n                      {\n                        if ( oc == OP_SeekGt || oc == OP_SeekGe )\n                        {\n                          rc = sqlite3BtreeFirst( pC.pCursor, ref res );\n                          if ( rc != SQLITE_OK ) goto abort_due_to_error;\n                        }\n                      }\n                      else\n                      {\n                        if ( oc == OP_SeekLt || oc == OP_SeekLe )\n                        {\n                          rc = sqlite3BtreeLast( pC.pCursor, ref res );\n                          if ( rc != SQLITE_OK ) goto abort_due_to_error;\n                        }\n                      }\n                      if ( res != 0 )\n                      {\n                        pc = pOp.p2 - 1;\n                      }\n                      break;\n                    }\n                    else if ( oc == OP_SeekLt || oc == OP_SeekGe )\n                    {\n                      /* Use the ceiling() function to convert real->int */\n                      if ( pIn3.r > (double)iKey ) iKey++;\n                    }\n                    else\n                    {\n                      /* Use the floor() function to convert real->int */\n                      Debug.Assert( oc == OP_SeekLe || oc == OP_SeekGt );\n                      if ( pIn3.r < (double)iKey ) iKey--;\n                    }\n                  }\n                  rc = sqlite3BtreeMovetoUnpacked( pC.pCursor, null, iKey, 0, ref res );\n                  if ( rc != SQLITE_OK )\n                  {\n                    goto abort_due_to_error;\n                  }\n                  if ( res == 0 )\n                  {\n                    pC.rowidIsValid = true;\n                    pC.lastRowid = iKey;\n                  }\n                }\n                else\n                {\n                  nField = pOp.p4.i;\n                  Debug.Assert( pOp.p4type == P4_INT32 );\n                  Debug.Assert( nField > 0 );\n                  r.pKeyInfo = pC.pKeyInfo;\n                  r.nField = (u16)nField;\n                  if ( oc == OP_SeekGt || oc == OP_SeekLe )\n                  {\n                    r.flags = UNPACKED_INCRKEY;\n                  }\n                  else\n                  {\n                    r.flags = 0;\n                  }\n                  r.aMem = new Mem[r.nField];\n                  for ( int rI = 0 ; rI < r.nField ; rI++ ) r.aMem[rI] = p.aMem[pOp.p3 + rI];// r.aMem = p.aMem[pOp.p3];\n                  rc = sqlite3BtreeMovetoUnpacked( pC.pCursor, r, 0, 0, ref res );\n                  if ( rc != SQLITE_OK )\n                  {\n                    goto abort_due_to_error;\n                  }\n                  pC.rowidIsValid = false;\n                }\n                pC.deferredMoveto = false;\n                pC.cacheStatus = CACHE_STALE;\n#if SQLITE_TEST\n                sqlite3_search_count.iValue++;\n#endif\n                if ( oc == OP_SeekGe || oc == OP_SeekGt )\n                {\n                  if ( res < 0 || ( res == 0 && oc == OP_SeekGt ) )\n                  {\n                    rc = sqlite3BtreeNext( pC.pCursor, ref res );\n                    if ( rc != SQLITE_OK ) goto abort_due_to_error;\n                    pC.rowidIsValid = false;\n                  }\n                  else\n                  {\n                    res = 0;\n                  }\n                }\n                else\n                {\n                  Debug.Assert( oc == OP_SeekLt || oc == OP_SeekLe );\n                  if ( res > 0 || ( res == 0 && oc == OP_SeekLt ) )\n                  {\n                    rc = sqlite3BtreePrevious( pC.pCursor, ref res );\n                    if ( rc != SQLITE_OK ) goto abort_due_to_error;\n                    pC.rowidIsValid = false;\n                  }\n                  else\n                  {\n                    /* res might be negative because the table is empty.  Check to\n                    ** see if this is the case.\n                    */\n                    res = sqlite3BtreeEof( pC.pCursor ) ? 1 : 0;\n                  }\n                }\n                Debug.Assert( pOp.p2 > 0 );\n                if ( res != 0 )\n                {\n                  pc = pOp.p2 - 1;\n                }\n              }\n              else\n              {\n                /* This happens when attempting to open the sqlite3_master table\n                ** for read access returns SQLITE_EMPTY. In this case always\n                ** take the jump (since there are no records in the table).\n                */\n                Debug.Assert( pC.pseudoTable == false );\n                pc = pOp.p2 - 1;\n              }\n              break;\n            }\n\n          /* Opcode: Seek P1 P2 * * *\n          **\n          ** P1 is an open table cursor and P2 is a rowid integer.  Arrange\n          ** for P1 to move so that it points to the rowid given by P2.\n          **\n          ** This is actually a deferred seek.  Nothing actually happens until\n          ** the cursor is used to read a record.  That way, if no reads\n          ** occur, no unnecessary I/O happens.\n          */\n          case OP_Seek:\n            {    /* in2 */\n              VdbeCursor pC;\n\n              Debug.Assert( pOp.p1 >= 0 && pOp.p1 < p.nCursor );\n              pC = p.apCsr[pOp.p1];\n              Debug.Assert( ALWAYS( pC != null ) );\n              if ( pC.pCursor != null )\n              {\n                Debug.Assert( pC.isTable );\n                pC.nullRow = false;\n                pC.movetoTarget = sqlite3VdbeIntValue( pIn2 );\n                pC.rowidIsValid = false;\n                pC.deferredMoveto = true;\n              }\n              break;\n            }\n\n          /* Opcode: Found P1 P2 P3 * *\n          **\n          ** Register P3 holds a blob constructed by MakeRecord.  P1 is an index.\n          ** If an entry that matches the value in register p3 exists in P1 then\n          ** jump to P2.  If the P3 value does not match any entry in P1\n          ** then fall thru.  The P1 cursor is left pointing at the matching entry\n          ** if it exists.\n          **\n          ** This instruction is used to implement the IN operator where the\n          ** left-hand side is a SELECT statement.  P1 may be a true index, or it\n          ** may be a temporary index that holds the results of the SELECT\n          ** statement.   This instruction is also used to implement the\n          ** DISTINCT keyword in SELECT statements.\n          **\n          ** This instruction checks if index P1 contains a record for which\n          ** the first N serialized values exactly match the N serialised values\n          ** in the record in register P3, where N is the total number of values in\n          ** the P3 record (the P3 record is a prefix of the P1 record).\n          **\n          ** See also: NotFound, IsUnique, NotExists\n          */\n          /* Opcode: NotFound P1 P2 P3 * *\n          **\n          ** Register P3 holds a blob constructed by MakeRecord.  P1 is\n          ** an index.  If no entry exists in P1 that matches the blob then jump\n          ** to P2.  If an entry does existing, fall through.  The cursor is left\n          ** pointing to the entry that matches.\n          **\n          ** See also: Found, NotExists, IsUnique\n          */\n          case OP_NotFound:       /* jump, in3 */\n          case OP_Found:\n            {        /* jump, in3 */\n              int alreadyExists;\n              VdbeCursor pC;\n              int res;\n              UnpackedRecord pIdxKey;\n              UnpackedRecord aTempRec = new UnpackedRecord();//char aTempRec[ROUND8(sizeof(UnpackedRecord)) + sizeof(Mem)*3 + 7];\n\n              res = 0;\n\n              alreadyExists = 0;\n              Debug.Assert( pOp.p1 >= 0 && pOp.p1 < p.nCursor );\n              pC = p.apCsr[pOp.p1];\n              Debug.Assert( pC != null );\n              if ( ALWAYS( pC.pCursor != null ) )\n              {\n\n                Debug.Assert( !pC.isTable );\n                Debug.Assert( ( pIn3.flags & MEM_Blob ) != 0 );\n                ExpandBlob( pIn3 );\n                pIdxKey = sqlite3VdbeRecordUnpack( pC.pKeyInfo, pIn3.n, pIn3.zBLOB,\n                   aTempRec, 0 );//sizeof( aTempRec ) );\n                if ( pIdxKey == null )\n                {\n                  goto no_mem;\n                }\n                if ( pOp.opcode == OP_Found )\n                {\n                  pIdxKey.flags |= UNPACKED_PREFIX_MATCH;\n                }\n                rc = sqlite3BtreeMovetoUnpacked( pC.pCursor, pIdxKey, 0, 0, ref res );\n                sqlite3VdbeDeleteUnpackedRecord( pIdxKey );\n                if ( rc != SQLITE_OK )\n                {\n                  break;\n                }\n                alreadyExists = ( res == 0 ) ? 1 : 0;\n                pC.deferredMoveto = false;\n                pC.cacheStatus = CACHE_STALE;\n              }\n              if ( pOp.opcode == OP_Found )\n              {\n                if ( alreadyExists != 0 ) pc = pOp.p2 - 1;\n              }\n              else\n              {\n                if ( 0 == alreadyExists ) pc = pOp.p2 - 1;\n              }\n              break;\n            }\n\n          /* Opcode: IsUnique P1 P2 P3 P4 *\n          **\n          ** Cursor P1 is open on an index.  So it has no data and its key consists\n          ** of a record generated by OP_MakeRecord where the last field is the\n          ** rowid of the entry that the index refers to.\n          **\n          ** The P3 register contains an integer record number. Call this record\n          ** number R. Register P4 is the first in a set of N contiguous registers\n          ** that make up an unpacked index key that can be used with cursor P1.\n          ** The value of N can be inferred from the cursor. N includes the rowid\n          ** value appended to the end of the index record. This rowid value may\n          ** or may not be the same as R.\n          **\n          ** If any of the N registers beginning with register P4 contains a NULL\n          ** value, jump immediately to P2.\n          **\n          ** Otherwise, this instruction checks if cursor P1 contains an entry\n          ** where the first (N-1) fields match but the rowid value at the end\n          ** of the index entry is not R. If there is no such entry, control jumps\n          ** to instruction P2. Otherwise, the rowid of the conflicting index\n          ** entry is copied to register P3 and control falls through to the next\n          ** instruction.\n          **\n          ** See also: NotFound, NotExists, Found\n          */\n          case OP_IsUnique:\n            {        /* jump, in3 */\n              u16 ii;\n              VdbeCursor pCx = new VdbeCursor();\n              BtCursor pCrsr;\n              u16 nField;\n              Mem[] aMem;\n              UnpackedRecord r;                  /* B-Tree index search key */\n              i64 R;                             /* Rowid stored in register P3 */\n\n              r = new UnpackedRecord();\n\n              //  aMem = &p->aMem[pOp->p4.i];\n              /* Assert that the values of parameters P1 and P4 are in range. */\n              Debug.Assert( pOp.p4type == P4_INT32 );\n              Debug.Assert( pOp.p4.i > 0 && pOp.p4.i <= p.nMem );\n              Debug.Assert( pOp.p1 >= 0 && pOp.p1 < p.nCursor );\n\n              /* Find the index cursor. */\n              pCx = p.apCsr[pOp.p1];\n              Debug.Assert( !pCx.deferredMoveto );\n              pCx.seekResult = 0;\n              pCx.cacheStatus = CACHE_STALE;\n              pCrsr = pCx.pCursor;\n\n              /* If any of the values are NULL, take the jump. */\n              nField = pCx.pKeyInfo.nField;\n              aMem = new Mem[nField + 1];\n              for ( ii = 0 ; ii < nField ; ii++ )\n              {\n                aMem[ii] = p.aMem[pOp.p4.i + ii];\n                if ( ( aMem[ii].flags & MEM_Null ) != 0 )\n                {\n                  pc = pOp.p2 - 1;\n                  pCrsr = null;\n                  break;\n                }\n              }\n              aMem[nField] = new Mem();\n              //Debug.Assert( ( aMem[nField].flags & MEM_Null ) == 0 );\n\n              if ( pCrsr != null )\n              {\n                /* Populate the index search key. */\n                r.pKeyInfo = pCx.pKeyInfo;\n                r.nField = (ushort)( nField + 1 );\n                r.flags = UNPACKED_PREFIX_SEARCH;\n                r.aMem = aMem;\n\n                /* Extract the value of R from register P3. */\n                sqlite3VdbeMemIntegerify( pIn3 );\n                R = pIn3.u.i;\n\n                /* Search the B-Tree index. If no conflicting record is found, jump\n                ** to P2. Otherwise, copy the rowid of the conflicting record to\n                ** register P3 and fall through to the next instruction.  */\n                rc = sqlite3BtreeMovetoUnpacked( pCrsr, r, 0, 0, ref pCx.seekResult );\n                if ( ( r.flags & UNPACKED_PREFIX_SEARCH ) != 0 || r.rowid == R )\n                {\n                  pc = pOp.p2 - 1;\n                }\n                else\n                {\n                  pIn3.u.i = r.rowid;\n                }\n              }\n              break;\n            }\n\n\n          /* Opcode: NotExists P1 P2 P3 * *\n          **\n          ** Use the content of register P3 as a integer key.  If a record\n          ** with that key does not exist in table of P1, then jump to P2.\n          ** If the record does exist, then fall thru.  The cursor is left\n          ** pointing to the record if it exists.\n          **\n          ** The difference between this operation and NotFound is that this\n          ** operation assumes the key is an integer and that P1 is a table whereas\n          ** NotFound assumes key is a blob constructed from MakeRecord and\n          ** P1 is an index.\n          **\n          ** See also: Found, NotFound, IsUnique\n          */\n          case OP_NotExists:\n            {        /* jump, in3 */\n              VdbeCursor pC;\n              BtCursor pCrsr;\n              int res;\n              i64 iKey;\n\n              Debug.Assert( ( pIn3.flags & MEM_Int ) != 0 );\n              Debug.Assert( pOp.p1 >= 0 && pOp.p1 < p.nCursor );\n              pC = p.apCsr[pOp.p1];\n              Debug.Assert( pC != null );\n              Debug.Assert( pC.isTable );\n              pCrsr = pC.pCursor;\n              if ( pCrsr != null )\n              {\n                res = 0;\n                iKey = pIn3.u.i;\n                rc = sqlite3BtreeMovetoUnpacked( pCrsr, null, (long)iKey, 0, ref res );\n                pC.lastRowid = pIn3.u.i;\n                pC.rowidIsValid = res == 0 ? true : false;\n                pC.nullRow = false;\n                pC.cacheStatus = CACHE_STALE;\n                pC.deferredMoveto = false;\n                if ( res != 0 )\n                {\n                  pc = pOp.p2 - 1;\n                  Debug.Assert( !pC.rowidIsValid );\n                }\n                pC.seekResult = res;\n              }\n              else\n              {\n                /* This happens when an attempt to open a read cursor on the\n                ** sqlite_master table returns SQLITE_EMPTY.\n                */\n                Debug.Assert( !pC.pseudoTable );\n                Debug.Assert( pC.isTable );\n                pc = pOp.p2 - 1;\n                Debug.Assert( !pC.rowidIsValid );\n                pC.seekResult = 0;\n              }\n              break;\n            }\n\n          /* Opcode: Sequence P1 P2 * * *\n          **\n          ** Find the next available sequence number for cursor P1.\n          ** Write the sequence number into register P2.\n          ** The sequence number on the cursor is incremented after this\n          ** instruction.\n          */\n          case OP_Sequence:\n            {           /* out2-prerelease */\n              Debug.Assert( pOp.p1 >= 0 && pOp.p1 < p.nCursor );\n              Debug.Assert( p.apCsr[pOp.p1] != null );\n              pOut.u.i = (long)p.apCsr[pOp.p1].seqCount++;\n              MemSetTypeFlag( pOut, MEM_Int );\n              break;\n            }\n\n\n          /* Opcode: NewRowid P1 P2 P3 * *\n          **\n          ** Get a new integer record number (a.k.a "rowid") used as the key to a table.\n          ** The record number is not previously used as a key in the database\n          ** table that cursor P1 points to.  The new record number is written\n          ** written to register P2.\n          **\n          ** If P3>0 then P3 is a register that holds the largest previously\n          ** generated record number.  No new record numbers are allowed to be less\n          ** than this value.  When this value reaches its maximum, a SQLITE_FULL\n          ** error is generated.  The P3 register is updated with the generated\n          ** record number.  This P3 mechanism is used to help implement the\n          ** AUTOINCREMENT feature.\n          */\n          case OP_NewRowid:\n            {           /* out2-prerelease */\n              i64 v;                 /* The new rowid */\n              VdbeCursor pC;         /* Cursor of table to get the new rowid */\n              int res;               /* Result of an sqlite3BtreeLast() */\n              int cnt;               /* Counter to limit the number of searches */\n              Mem pMem;              /* Register holding largest rowid for AUTOINCREMENT */\n\n              v = 0;\n              res = 0;\n              Debug.Assert( pOp.p1 >= 0 && pOp.p1 < p.nCursor );\n              pC = p.apCsr[pOp.p1];\n              Debug.Assert( pC != null );\n              if ( NEVER( pC.pCursor == null ) )\n              {\n                /* The zero initialization above is all that is needed */\n              }\n              else\n              {\n                /* The next rowid or record number (different terms for the same\n                ** thing) is obtained in a two-step algorithm.\n                **\n                ** First we attempt to find the largest existing rowid and add one\n                ** to that.  But if the largest existing rowid is already the maximum\n                ** positive integer, we have to fall through to the second\n                ** probabilistic algorithm\n                **\n                ** The second algorithm is to select a rowid at random and see if\n                ** it already exists in the table.  If it does not exist, we have\n                ** succeeded.  If the random rowid does exist, we select a new one\n                ** and try again, up to 100 times.\n                */\n                Debug.Assert( pC.isTable );\n                cnt = 0;\n\n#if SQLITE_32BIT_ROWID\nconst int MAX_ROWID = i32.MaxValue;//#   define MAX_ROWID 0x7fffffff\n#else\n                /* Some compilers complain about constants of the form 0x7fffffffffffffff.\n** Others complain about 0x7ffffffffffffffffLL.  The following macro seems\n** to provide the constant while making all compilers happy.\n*/\n                const long MAX_ROWID = i64.MaxValue;// (i64)( (((u64)0x7fffffff)<<32) | (u64)0xffffffff )\n#endif\n\n                if ( !pC.useRandomRowid )\n                {\n                  v = sqlite3BtreeGetCachedRowid( pC.pCursor );\n                  if ( v == 0 )\n                  {\n                    rc = sqlite3BtreeLast( pC.pCursor, ref res );\n                    if ( rc != SQLITE_OK )\n                    {\n                      goto abort_due_to_error;\n                    }\n                    if ( res != 0 )\n                    {\n                      v = 1;\n                    }\n                    else\n                    {\n                      Debug.Assert( sqlite3BtreeCursorIsValid( pC.pCursor ) );\n                      rc = sqlite3BtreeKeySize( pC.pCursor, ref v );\n                      Debug.Assert( rc == SQLITE_OK );   /* Cannot fail following BtreeLast() */\n                      if ( v == MAX_ROWID )\n                      {\n                        pC.useRandomRowid = true;\n                      }\n                      else\n                      {\n                        v++;\n                      }\n                    }\n                  }\n\n#if !SQLITE_OMIT_AUTOINCREMENT\n                  if ( pOp.p3 != 0 )\n                  {\n                    Debug.Assert( pOp.p3 > 0 && pOp.p3 <= p.nMem ); /* P3 is a valid memory cell */\n                    pMem = p.aMem[pOp.p3];\n#if SQLITE_DEBUG\n                    REGISTER_TRACE( p, pOp.p3, pMem );\n#endif\n                    sqlite3VdbeMemIntegerify( pMem );\n                    Debug.Assert( ( pMem.flags & MEM_Int ) != 0 );  /* mem(P3) holds an integer */\n                    if ( pMem.u.i == MAX_ROWID || pC.useRandomRowid )\n                    {\n                      rc = SQLITE_FULL;\n                      goto abort_due_to_error;\n                    }\n                    if ( v < ( pMem.u.i + 1 ) )\n                    {\n                      v = (int)( pMem.u.i + 1 );\n                    }\n                    pMem.u.i = (long)v;\n                  }\n#endif\n\n                  sqlite3BtreeSetCachedRowid( pC.pCursor, v < MAX_ROWID ? v + 1 : 0 );\n                }\n                if ( pC.useRandomRowid )\n                {\n                  Debug.Assert( pOp.p3 == 0 );  /* We cannot be in random rowid mode if this is\n** an AUTOINCREMENT table. */\n                  v = db.lastRowid;\n                  cnt = 0;\n                  do\n                  {\n                    if ( cnt == 0 && ( v & 0xffffff ) == v )\n                    {\n                      v++;\n                    }\n                    else\n                    {\n                      sqlite3_randomness( sizeof( i64 ), ref v );\n                      if ( cnt < 5 ) v &= 0xffffff;\n                    }\n                    rc = sqlite3BtreeMovetoUnpacked( pC.pCursor, null, v, 0, ref res );\n                    cnt++;\n                  } while ( cnt < 100 && rc == SQLITE_OK && res == 0 );\n                  if ( rc == SQLITE_OK && res == 0 )\n                  {\n                    rc = SQLITE_FULL;\n                    goto abort_due_to_error;\n                  }\n                }\n                pC.rowidIsValid = false;\n                pC.deferredMoveto = false;\n                pC.cacheStatus = CACHE_STALE;\n              }\n              MemSetTypeFlag( pOut, MEM_Int );\n              pOut.u.i = (long)v;\n              break;\n            }\n\n          /* Opcode: Insert P1 P2 P3 P4 P5\n          **\n          ** Write an entry into the table of cursor P1.  A new entry is\n          ** created if it doesn\'t already exist or the data for an existing\n          ** entry is overwritten.  The data is the value stored register\n          ** number P2. The key is stored in register P3. The key must\n          ** be an integer.\n          **\n          ** If the OPFLAG_NCHANGE flag of P5 is set, then the row change count is\n          ** incremented (otherwise not).  If the OPFLAG_LASTROWID flag of P5 is set,\n          ** then rowid is stored for subsequent return by the\n          ** sqlite3_last_insert_rowid() function (otherwise it is unmodified).\n          **\n          ** Parameter P4 may point to a string containing the table-name, or\n          ** may be NULL. If it is not NULL, then the update-hook\n          ** (sqlite3.xUpdateCallback) is invoked following a successful insert.\n          **\n          ** (WARNING/TODO: If P1 is a pseudo-cursor and P2 is dynamically\n          ** allocated, then ownership of P2 is transferred to the pseudo-cursor\n          ** and register P2 becomes ephemeral.  If the cursor is changed, the\n          ** value of register P2 will then change.  Make sure this does not\n          ** cause any problems.)\n          **\n          ** This instruction only works on tables.  The equivalent instruction\n          ** for indices is OP_IdxInsert.\n          */\n          case OP_Insert:\n            {\n              Mem pData;\n              Mem pKey;\n\n              i64 iKey;   /* The integer ROWID or key for the record to be inserted */\n\n              VdbeCursor pC;\n              int nZero;\n              int seekResult;\n              string zDb;\n              string zTbl;\n              int op;\n\n              pData = p.aMem[pOp.p2];\n              pKey = p.aMem[pOp.p3];\n              Debug.Assert( pOp.p1 >= 0 && pOp.p1 < p.nCursor );\n              pC = p.apCsr[pOp.p1];\n              Debug.Assert( pC != null );\n              Debug.Assert( pC.pCursor != null || pC.pseudoTable );\n              Debug.Assert( ( pKey.flags & MEM_Int ) != 0 );\n              Debug.Assert( pC.isTable );\n#if SQLITE_DEBUG\n              REGISTER_TRACE( p, pOp.p2, pData );\n              REGISTER_TRACE( p, pOp.p3, pKey );\n#endif\n              iKey = pKey.u.i;\n              if ( ( pOp.p5 & OPFLAG_NCHANGE ) != 0 ) p.nChange++;\n              if ( ( pOp.p5 & OPFLAG_LASTROWID ) != 0 ) db.lastRowid = pKey.u.i;\n              if ( ( pData.flags & MEM_Null ) != 0 )\n              {\n                pData.zBLOB = null;\n                pData.z = null;\n                pData.n = 0;\n              }\n              else\n              {\n                Debug.Assert( ( pData.flags & ( MEM_Blob | MEM_Str ) ) != 0 );\n              }\n              if ( pC.pseudoTable )\n              {\n                if ( !pC.ephemPseudoTable )\n                {\n                  //sqlite3DbFree( db, ref pC.pData );\n                }\n                pC.iKey = iKey;\n                pC.nData = pData.n;\n                if ( pC.ephemPseudoTable )//|| pData->z==pData->zMalloc )\n                {\n                  if ( pData.zBLOB != null )\n                  {\n                    pC.pData = new byte[pC.nData + 2];// sqlite3Malloc(pC.nData + 2);\n                    Buffer.BlockCopy( pData.zBLOB, 0, pC.pData, 0, pC.nData );\n                  }\n                  else\n                    pC.pData = Encoding.UTF8.GetBytes( pData.z );\n                  //if ( !pC.ephemPseudoTable )\n                  //{\n                  //  pData.flags &= ~MEM_Dyn;\n                  //  pData.flags |= MEM_Ephem;\n                  //  pData.zMalloc = null;\n                  //}\n                }\n                else\n                {\n                  pC.pData = new byte[pC.nData + 2];// sqlite3Malloc(pC.nData + 2);\n                  if ( pC.pData == null ) goto no_mem;\n                  if ( pC.nData > 0 ) Buffer.BlockCopy( pData.zBLOB, 0, pC.pData, 0, pC.nData );// memcpy(pC.pData, pData.z, pC.nData);\n                  //pC.pData[pC.nData] = 0;\n                  //pC.pData[pC.nData + 1] = 0;\n                }\n                pC.nullRow = false;\n              }\n              else\n              {\n                seekResult = ( ( pOp.p5 & OPFLAG_USESEEKRESULT ) != 0 ? pC.seekResult : 0 );\n                if ( ( pData.flags & MEM_Zero ) != 0 )\n                {\n                  nZero = pData.u.nZero;\n                }\n                else\n                {\n                  nZero = 0;\n                }\n                rc = sqlite3BtreeInsert( pC.pCursor, null, iKey,\n                pData.zBLOB\n                , pData.n, nZero,\n                ( pOp.p5 & OPFLAG_APPEND ) != 0?1:0, seekResult\n                );\n              }\n\n              pC.rowidIsValid = false;\n              pC.deferredMoveto = false;\n              pC.cacheStatus = CACHE_STALE;\n\n              /* Invoke the update-hook if required. */\n              if ( rc == SQLITE_OK && db.xUpdateCallback != null && pOp.p4.z != null )\n              {\n                zDb = db.aDb[pC.iDb].zName;\n                zTbl = pOp.p4.z;\n                op = ( ( pOp.p5 & OPFLAG_ISUPDATE ) != 0 ? SQLITE_UPDATE : SQLITE_INSERT );\n                Debug.Assert( pC.isTable );\n                db.xUpdateCallback( db.pUpdateArg, op, zDb, zTbl, iKey );\n                Debug.Assert( pC.iDb >= 0 );\n              }\n              break;\n            }\n\n          /* Opcode: Delete P1 P2 * P4 *\n          **\n          ** Delete the record at which the P1 cursor is currently pointing.\n          **\n          ** The cursor will be left pointing at either the next or the previous\n          ** record in the table. If it is left pointing at the next record, then\n          ** the next Next instruction will be a no-op.  Hence it is OK to delete\n          ** a record from within an Next loop.\n          **\n          ** If the OPFLAG_NCHANGE flag of P2 is set, then the row change count is\n          ** incremented (otherwise not).\n          **\n          ** P1 must not be pseudo-table.  It has to be a real table with\n          ** multiple rows.\n          **\n          ** If P4 is not NULL, then it is the name of the table that P1 is\n          ** pointing to.  The update hook will be invoked, if it exists.\n          ** If P4 is not NULL then the P1 cursor must have been positioned\n          ** using OP_NotFound prior to invoking this opcode.\n          */\n          case OP_Delete:\n            {\n              i64 iKey;\n              VdbeCursor pC;\n\n              iKey = 0;\n              Debug.Assert( pOp.p1 >= 0 && pOp.p1 < p.nCursor );\n              pC = p.apCsr[pOp.p1];\n              Debug.Assert( pC != null );\n              Debug.Assert( pC.pCursor != null );  /* Only valid for real tables, no pseudotables */\n\n              /* If the update-hook will be invoked, set iKey to the rowid of the\n              ** row being deleted.\n              */\n              if ( db.xUpdateCallback != null && pOp.p4.z != null )\n              {\n                Debug.Assert( pC.isTable );\n                Debug.Assert( pC.rowidIsValid );  /* lastRowid set by previous OP_NotFound */\n                iKey = pC.lastRowid;\n              }\n\n              /* The OP_Delete opcode always follows an OP_NotExists or OP_Last or\n              ** OP_Column on the same table without any intervening operations that\n              ** might move or invalidate the cursor.  Hence cursor pC is always pointing\n              ** to the row to be deleted and the sqlite3VdbeCursorMoveto() operation\n              ** below is always a no-op and cannot fail.  We will run it anyhow, though,\n              ** to guard against future changes to the code generator.\n              **/\n              Debug.Assert( pC.deferredMoveto == false );\n              rc = sqlite3VdbeCursorMoveto( pC );\n              if ( NEVER( rc != SQLITE_OK ) ) goto abort_due_to_error;\n              sqlite3BtreeSetCachedRowid( pC.pCursor, 0 );\n              rc = sqlite3BtreeDelete( pC.pCursor );\n              pC.cacheStatus = CACHE_STALE;\n\n              /* Invoke the update-hook if required. */\n              if ( rc == SQLITE_OK && db.xUpdateCallback != null && pOp.p4.z != null )\n              {\n                string zDb = db.aDb[pC.iDb].zName;\n                string zTbl = pOp.p4.z;\n                db.xUpdateCallback( db.pUpdateArg, SQLITE_DELETE, zDb, zTbl, iKey );\n                Debug.Assert( pC.iDb >= 0 );\n              }\n              if ( ( pOp.p2 & OPFLAG_NCHANGE ) != 0 ) p.nChange++;\n              break;\n            }\n\n          /* Opcode: ResetCount P1 * *\n          **\n          ** This opcode resets the VMs internal change counter to 0. If P1 is true,\n          ** then the value of the change counter is copied to the database handle\n          ** change counter (returned by subsequent calls to sqlite3_changes())\n          ** before it is reset. This is used by trigger programs.\n          */\n          case OP_ResetCount:\n            {\n              if ( pOp.p1 != 0 )\n              {\n                sqlite3VdbeSetChanges( db, p.nChange );\n              }\n              p.nChange = 0;\n              break;\n            }\n\n          /* Opcode: RowData P1 P2 * * *\n          **\n          ** Write into register P2 the complete row data for cursor P1.\n          ** There is no interpretation of the data.\n          ** It is just copied onto the P2 register exactly as\n          ** it is found in the database file.\n          **\n          ** If the P1 cursor must be pointing to a valid row (not a NULL row)\n          ** of a real table, not a pseudo-table.\n          */\n          /* Opcode: RowKey P1 P2 * * *\n          **\n          ** Write into register P2 the complete row key for cursor P1.\n          ** There is no interpretation of the data.\n          ** The key is copied onto the P3 register exactly as\n          ** it is found in the database file.\n          **\n          ** If the P1 cursor must be pointing to a valid row (not a NULL row)\n          ** of a real table, not a pseudo-table.\n          */\n          case OP_RowKey:\n          case OP_RowData:\n            {\n              VdbeCursor pC;\n              BtCursor pCrsr;\n              u32 n;\n              i64 n64;\n\n              n = 0;\n              n64 = 0;\n\n              pOut = p.aMem[pOp.p2];\n\n              /* Note that RowKey and RowData are really exactly the same instruction */\n              Debug.Assert( pOp.p1 >= 0 && pOp.p1 < p.nCursor );\n              pC = p.apCsr[pOp.p1];\n              Debug.Assert( pC.isTable || pOp.opcode == OP_RowKey );\n              Debug.Assert( pC.isIndex || pOp.opcode == OP_RowData );\n              Debug.Assert( pC != null );\n              Debug.Assert( !pC.nullRow );\n              Debug.Assert( !pC.pseudoTable );\n              Debug.Assert( pC.pCursor != null );\n              pCrsr = pC.pCursor;\n              Debug.Assert( sqlite3BtreeCursorIsValid( pCrsr ) );\n\n              /* The OP_RowKey and OP_RowData opcodes always follow OP_NotExists or\n              ** OP_Rewind/Op_Next with no intervening instructions that might invalidate\n              ** the cursor.  Hence the following sqlite3VdbeCursorMoveto() call is always\n              ** a no-op and can never fail.  But we leave it in place as a safety.\n              */\n              Debug.Assert( pC.deferredMoveto == false );\n              rc = sqlite3VdbeCursorMoveto( pC );\n              if ( NEVER( rc != SQLITE_OK ) ) goto abort_due_to_error;\n              if ( pC.isIndex )\n              {\n                Debug.Assert( !pC.isTable );\n                rc=sqlite3BtreeKeySize( pCrsr, ref n64 );\n                Debug.Assert( rc == SQLITE_OK );    /* True because of CursorMoveto() call above */\n                if ( n64 > db.aLimit[SQLITE_LIMIT_LENGTH] )\n                {\n                  goto too_big;\n                }\n                n = (u32)n64;\n              }\n              else\n              {\n                rc = sqlite3BtreeDataSize( pCrsr, ref n );\n                Debug.Assert( rc == SQLITE_OK );    /* DataSize() cannot fail */\n                if ( n > (u32)db.aLimit[SQLITE_LIMIT_LENGTH] )\n                {\n                  goto too_big;\n                }\n                if ( sqlite3VdbeMemGrow( pOut, (int)n, 0 ) != 0 )\n                {\n                  goto no_mem;\n                }\n              }\n              pOut.n = (int)n;\n              if ( pC.isIndex )\n              {\n                pOut.zBLOB = new byte[n];\n                rc = sqlite3BtreeKey( pCrsr, 0, n, pOut.zBLOB );\n              }\n              else\n              {\n                pOut.zBLOB = new byte[pCrsr.info.nData];\n                rc = sqlite3BtreeData( pCrsr, 0, (u32)n, pOut.zBLOB );\n              }\n              MemSetTypeFlag( pOut, MEM_Blob );\n              pOut.enc = SQLITE_UTF8;  /* In case the blob is ever cast to text */\n#if SQLITE_TEST\n              UPDATE_MAX_BLOBSIZE( pOut );\n#endif\n              break;\n            }\n\n          /* Opcode: Rowid P1 P2 * * *\n          **\n          ** Store in register P2 an integer which is the key of the table entry that\n          ** P1 is currently point to.\n          **\n          ** P1 can be either an ordinary table or a virtual table.  There used to\n          ** be a separate OP_VRowid opcode for use with virtual tables, but this\n          ** one opcode now works for both table types.\n          */\n          case OP_Rowid:\n            {                 /* out2-prerelease */\n              VdbeCursor pC;\n              i64 v;\n              sqlite3_vtab pVtab;\n              sqlite3_module pModule;\n\n              v = 0;\n\n              Debug.Assert( pOp.p1 >= 0 && pOp.p1 < p.nCursor );\n              pC = p.apCsr[pOp.p1];\n              Debug.Assert( pC != null );\n              if ( pC.nullRow )\n              {\n                /* Do nothing so that reg[P2] remains NULL */\n                break;\n              }\n              else if ( pC.deferredMoveto )\n              {\n                v = pC.movetoTarget;\n              }\n              else if ( pC.pseudoTable )\n              {\n                v = pC.iKey;\n#if !SQLITE_OMIT_VIRTUALTABLE\n}else if( pC.pVtabCursor ){\npVtab = pC.pVtabCursor.pVtab;\npModule = pVtab.pModule;\nassert( pModule.xRowid );\nif( sqlite3SafetyOff(db) ) goto abort_due_to_misuse;\nrc = pModule.xRowid(pC.pVtabCursor, &v);\n//sqlite3DbFree(db, p.zErrMsg);\np.zErrMsg = pVtab.zErrMsg;\npVtab.zErrMsg = 0;\nif( sqlite3SafetyOn(db) ) goto abort_due_to_misuse;\n#endif //* SQLITE_OMIT_VIRTUALTABLE */\n              }\n              else\n              {\n                Debug.Assert( pC.pCursor != null );\n                rc = sqlite3VdbeCursorMoveto( pC );\n                if ( rc != 0 ) goto abort_due_to_error;\n                if ( pC.rowidIsValid )\n                {\n                  v = pC.lastRowid;\n                }\n                else\n                {\n                  rc = sqlite3BtreeKeySize( pC.pCursor, ref v );\n                  Debug.Assert( rc == SQLITE_OK );  /* Always so because of CursorMoveto() above */\n                }\n              }\n              pOut.u.i = (long)v;\n              MemSetTypeFlag( pOut, MEM_Int );\n              break;\n            }\n\n          /* Opcode: NullRow P1 * * * *\n          **\n          ** Move the cursor P1 to a null row.  Any OP_Column operations\n          ** that occur while the cursor is on the null row will always\n          ** write a NULL.\n          */\n          case OP_NullRow:\n            {\n              VdbeCursor pC;\n\n              Debug.Assert( pOp.p1 >= 0 && pOp.p1 < p.nCursor );\n              pC = p.apCsr[pOp.p1];\n              Debug.Assert( pC != null );\n              pC.nullRow = true;\n              pC.rowidIsValid = false;\n              if ( pC.pCursor != null )\n              {\n                sqlite3BtreeClearCursor( pC.pCursor );\n              }\n              break;\n            }\n\n          /* Opcode: Last P1 P2 * * *\n          **\n          ** The next use of the Rowid or Column or Next instruction for P1\n          ** will refer to the last entry in the database table or index.\n          ** If the table or index is empty and P2>0, then jump immediately to P2.\n          ** If P2 is 0 or if the table or index is not empty, fall through\n          ** to the following instruction.\n          */\n          case OP_Last:\n            {        /* jump */\n              VdbeCursor pC;\n              BtCursor pCrsr;\n              int res = 0;\n\n              Debug.Assert( pOp.p1 >= 0 && pOp.p1 < p.nCursor );\n              pC = p.apCsr[pOp.p1];\n              Debug.Assert( pC != null );\n              pCrsr = pC.pCursor;\n              if ( pCrsr == null )\n              {\n                res = 1;\n              }\n              else\n              {\n                rc = sqlite3BtreeLast( pCrsr, ref res );\n              }\n              pC.nullRow = res == 1 ? true : false;\n              pC.deferredMoveto = false;\n              pC.rowidIsValid = false;\n              pC.cacheStatus = CACHE_STALE;\n              if ( pOp.p2 > 0 && res != 0 )\n              {\n                pc = pOp.p2 - 1;\n              }\n              break;\n            }\n\n\n          /* Opcode: Sort P1 P2 * * *\n          **\n          ** This opcode does exactly the same thing as OP_Rewind except that\n          ** it increments an undocumented global variable used for testing.\n          **\n          ** Sorting is accomplished by writing records into a sorting index,\n          ** then rewinding that index and playing it back from beginning to\n          ** end.  We use the OP_Sort opcode instead of OP_Rewind to do the\n          ** rewinding so that the global variable will be incremented and\n          ** regression tests can determine whether or not the optimizer is\n          ** correctly optimizing out sorts.\n          */\n          case OP_Sort:\n            {        /* jump */\n#if SQLITE_TEST\n              sqlite3_sort_count.iValue++;\n              sqlite3_search_count.iValue--;\n#endif\n              p.aCounter[SQLITE_STMTSTATUS_SORT - 1]++;\n              /* Fall through into OP_Rewind */\n              goto case OP_Rewind;\n            }\n          /* Opcode: Rewind P1 P2 * * *\n          **\n          ** The next use of the Rowid or Column or Next instruction for P1\n          ** will refer to the first entry in the database table or index.\n          ** If the table or index is empty and P2>0, then jump immediately to P2.\n          ** If P2 is 0 or if the table or index is not empty, fall through\n          ** to the following instruction.\n          */\n          case OP_Rewind:\n            {        /* jump */\n              VdbeCursor pC;\n              BtCursor pCrsr;\n              int res = 0;\n\n              Debug.Assert( pOp.p1 >= 0 && pOp.p1 < p.nCursor );\n              pC = p.apCsr[pOp.p1];\n              Debug.Assert( pC != null );\n              if ( ( pCrsr = pC.pCursor ) != null )\n              {\n                rc = sqlite3BtreeFirst( pCrsr, ref res );\n                pC.atFirst = res == 0 ? true : false;\n                pC.deferredMoveto = false;\n                pC.cacheStatus = CACHE_STALE;\n                pC.rowidIsValid = false;\n              }\n              else\n              {\n                res = 1;\n              }\n              pC.nullRow = res == 1 ? true : false;\n              Debug.Assert( pOp.p2 > 0 && pOp.p2 < p.nOp );\n              if ( res != 0 )\n              {\n                pc = pOp.p2 - 1;\n              }\n              break;\n            }\n\n          /* Opcode: Next P1 P2 * * *\n          **\n          ** Advance cursor P1 so that it points to the next key/data pair in its\n          ** table or index.  If there are no more key/value pairs then fall through\n          ** to the following instruction.  But if the cursor advance was successful,\n          ** jump immediately to P2.\n          **\n          ** The P1 cursor must be for a real table, not a pseudo-table.\n          **\n          ** See also: Prev\n          */\n          /* Opcode: Prev P1 P2 * * *\n          **\n          ** Back up cursor P1 so that it points to the previous key/data pair in its\n          ** table or index.  If there is no previous key/value pairs then fall through\n          ** to the following instruction.  But if the cursor backup was successful,\n          ** jump immediately to P2.\n          **\n          ** The P1 cursor must be for a real table, not a pseudo-table.\n          */\n          case OP_Prev:          /* jump */\n          case OP_Next:\n            {        /* jump */\n              VdbeCursor pC;\n              BtCursor pCrsr;\n              int res;\n\n              if ( db.u1.isInterrupted ) goto abort_due_to_interrupt; //CHECK_FOR_INTERRUPT;\n              Debug.Assert( pOp.p1 >= 0 && pOp.p1 < p.nCursor );\n              pC = p.apCsr[pOp.p1];\n              if ( pC == null )\n              {\n                break;  /* See ticket #2273 */\n              }\n              pCrsr = pC.pCursor;\n              if ( pCrsr == null )\n              {\n                pC.nullRow = true;\n                break;\n              }\n              res = 1;\n              Debug.Assert( !pC.deferredMoveto );\n              rc = pOp.opcode == OP_Next ? sqlite3BtreeNext( pCrsr, ref res ) :\n              sqlite3BtreePrevious( pCrsr, ref res );\n              pC.nullRow = res == 1 ? true : false;\n              pC.cacheStatus = CACHE_STALE;\n              if ( res == 0 )\n              {\n                pc = pOp.p2 - 1;\n                if ( pOp.p5 != 0 ) p.aCounter[pOp.p5 - 1]++;\n#if SQLITE_TEST\n                sqlite3_search_count.iValue++;\n#endif\n              }\n              pC.rowidIsValid = false;\n              break;\n            }\n\n          /* Opcode: IdxInsert P1 P2 P3 * P5\n          **\n          ** Register P2 holds a SQL index key made using the\n          ** MakeRecord instructions.  This opcode writes that key\n          ** into the index P1.  Data for the entry is nil.\n          **\n          ** P3 is a flag that provides a hint to the b-tree layer that this\n          ** insert is likely to be an append.\n          **\n          ** This instruction only works for indices.  The equivalent instruction\n          ** for tables is OP_Insert.\n          */\n          case OP_IdxInsert:\n            {        /* in2 */\n              VdbeCursor pC;\n              BtCursor pCrsr;\n              int nKey;\n              byte[] zKey;\n              Debug.Assert( pOp.p1 >= 0 && pOp.p1 < p.nCursor );\n              pC = p.apCsr[pOp.p1];\n              Debug.Assert( pC != null );\n              Debug.Assert( ( pIn2.flags & MEM_Blob ) != 0 );\n              pCrsr = pC.pCursor;\n              if ( ALWAYS( pCrsr != null ) )\n              {\n                Debug.Assert( !pC.isTable );\n                ExpandBlob( pIn2 );\n                if ( rc == SQLITE_OK )\n                {\n                  nKey = pIn2.n;\n                  zKey = ( pIn2.flags & MEM_Blob ) != 0 ? pIn2.zBLOB : Encoding.UTF8.GetBytes( pIn2.z );\n                  rc = sqlite3BtreeInsert( pCrsr, zKey, nKey, new byte[1], 0, 0, (pOp.p3 != 0)?1:0,\n                  ( ( pOp.p5 & OPFLAG_USESEEKRESULT ) != 0 ? pC.seekResult : 0 )\n                  );\n                  Debug.Assert( !pC.deferredMoveto );\n                  pC.cacheStatus = CACHE_STALE;\n                }\n              }\n              break;\n            }\n\n\n          /* Opcode: IdxDelete P1 P2 P3 * *\n          **\n          ** The content of P3 registers starting at register P2 form\n          ** an unpacked index key. This opcode removes that entry from the\n          ** index opened by cursor P1.\n          */\n          case OP_IdxDelete:\n            {\n              VdbeCursor pC;\n              BtCursor pCrsr;\n              int res;\n              UnpackedRecord r;\n\n              res = 0;\n              r = new UnpackedRecord();\n\n              Debug.Assert( pOp.p3 > 0 );\n              Debug.Assert( pOp.p2 > 0 && pOp.p2 + pOp.p3 <= p.nMem + 1 );\n              Debug.Assert( pOp.p1 >= 0 && pOp.p1 < p.nCursor );\n              pC = p.apCsr[pOp.p1];\n              Debug.Assert( pC != null );\n              pCrsr = pC.pCursor;\n              if ( ALWAYS( pCrsr != null ) )\n              {\n                r.pKeyInfo = pC.pKeyInfo;\n                r.nField = (u16)pOp.p3;\n                r.flags = 0;\n                r.aMem = new Mem[r.nField];\n                for ( int ra = 0 ; ra < r.nField ; ra++ ) r.aMem[ra] = p.aMem[pOp.p2 + ra];\n                rc = sqlite3BtreeMovetoUnpacked( pCrsr, r, 0, 0, ref res );\n                if ( rc == SQLITE_OK && res == 0 )\n                {\n                  rc = sqlite3BtreeDelete( pCrsr );\n                }\n                Debug.Assert( !pC.deferredMoveto );\n                pC.cacheStatus = CACHE_STALE;\n              }\n              break;\n            }\n\n          /* Opcode: IdxRowid P1 P2 * * *\n          **\n          ** Write into register P2 an integer which is the last entry in the record at\n          ** the end of the index key pointed to by cursor P1.  This integer should be\n          ** the rowid of the table entry to which this index entry points.\n          **\n          ** See also: Rowid, MakeRecord.\n          */\n          case OP_IdxRowid:\n            {              /* out2-prerelease */\n              BtCursor pCrsr;\n              VdbeCursor pC;\n              i64 rowid;\n\n              rowid = 0;\n\n              Debug.Assert( pOp.p1 >= 0 && pOp.p1 < p.nCursor );\n              pC = p.apCsr[pOp.p1];\n              Debug.Assert( pC != null );\n              pCrsr = pC.pCursor;\n              if ( ALWAYS( pCrsr != null ) )\n              {\n                rc = sqlite3VdbeCursorMoveto( pC );\n                if ( NEVER( rc != 0 ) ) goto abort_due_to_error;\n                Debug.Assert( !pC.deferredMoveto );\n                Debug.Assert( !pC.isTable );\n                if ( !pC.nullRow )\n                {\n                  rc = sqlite3VdbeIdxRowid( db, pCrsr, ref rowid );\n                  if ( rc != SQLITE_OK )\n                  {\n                    goto abort_due_to_error;\n                  }\n                  MemSetTypeFlag( pOut, MEM_Int );\n                  pOut.u.i = (long)rowid;\n                }\n              }\n              break;\n            }\n\n          /* Opcode: IdxGE P1 P2 P3 P4 P5\n          **\n          ** The P4 register values beginning with P3 form an unpacked index\n          ** key that omits the ROWID.  Compare this key value against the index\n          ** that P1 is currently pointing to, ignoring the ROWID on the P1 index.\n          **\n          ** If the P1 index entry is greater than or equal to the key value\n          ** then jump to P2.  Otherwise fall through to the next instruction.\n          **\n          ** If P5 is non-zero then the key value is increased by an epsilon\n          ** prior to the comparison.  This make the opcode work like IdxGT except\n          ** that if the key from register P3 is a prefix of the key in the cursor,\n          ** the result is false whereas it would be true with IdxGT.\n          */\n          /* Opcode: IdxLT P1 P2 P3 * P5\n          **\n          ** The P4 register values beginning with P3 form an unpacked index\n          ** key that omits the ROWID.  Compare this key value against the index\n          ** that P1 is currently pointing to, ignoring the ROWID on the P1 index.\n          **\n          ** If the P1 index entry is less than the key value then jump to P2.\n          ** Otherwise fall through to the next instruction.\n          **\n          ** If P5 is non-zero then the key value is increased by an epsilon prior\n          ** to the comparison.  This makes the opcode work like IdxLE.\n          */\n          case OP_IdxLT:          /* jump, in3 */\n          case OP_IdxGE:\n            {        /* jump, in3 */\n              VdbeCursor pC;\n              int res;\n              UnpackedRecord r;\n\n              res = 0;\n              r = new UnpackedRecord();\n\n              Debug.Assert( pOp.p1 >= 0 && pOp.p1 < p.nCursor );\n              pC = p.apCsr[pOp.p1];\n              Debug.Assert( pC != null );\n              if ( ALWAYS( pC.pCursor != null ) )\n              {\n                Debug.Assert( pC.deferredMoveto == false );\n                Debug.Assert( pOp.p5 == 0 || pOp.p5 == 1 );\n                Debug.Assert( pOp.p4type == P4_INT32 );\n                r.pKeyInfo = pC.pKeyInfo;\n                r.nField = (u16)pOp.p4.i;\n                if ( pOp.p5 != 0 )\n                {\n                  r.flags = UNPACKED_INCRKEY | UNPACKED_IGNORE_ROWID;\n                }\n                else\n                {\n                  r.flags = UNPACKED_IGNORE_ROWID;\n                }\n                r.aMem = new Mem[r.nField];\n                for ( int rI = 0 ; rI < r.nField ; rI++ ) r.aMem[rI] = p.aMem[pOp.p3 + rI];// r.aMem = p.aMem[pOp.p3];\n                rc = sqlite3VdbeIdxKeyCompare( pC, r, ref res );\n                if ( pOp.opcode == OP_IdxLT )\n                {\n                  res = -res;\n                }\n                else\n                {\n                  Debug.Assert( pOp.opcode == OP_IdxGE );\n                  res++;\n                }\n                if ( res > 0 )\n                {\n                  pc = pOp.p2 - 1;\n                }\n              }\n              break;\n            }\n\n          /* Opcode: Destroy P1 P2 P3 * *\n          **\n          ** Delete an entire database table or index whose root page in the database\n          ** file is given by P1.\n          **\n          ** The table being destroyed is in the main database file if P3==0.  If\n          ** P3==1 then the table to be clear is in the auxiliary database file\n          ** that is used to store tables create using CREATE TEMPORARY TABLE.\n          **\n          ** If AUTOVACUUM is enabled then it is possible that another root page\n          ** might be moved into the newly deleted root page in order to keep all\n          ** root pages contiguous at the beginning of the database.  The former\n          ** value of the root page that moved - its value before the move occurred -\n          ** is stored in register P2.  If no page\n          ** movement was required (because the table being dropped was already\n          ** the last one in the database) then a zero is stored in register P2.\n          ** If AUTOVACUUM is disabled then a zero is stored in register P2.\n          **\n          ** See also: Clear\n          */\n          case OP_Destroy:\n            {     /* out2-prerelease */\n              int iMoved = 0;\n              int iCnt;\n              Vdbe pVdbe;\n              int iDb;\n\n#if !SQLITE_OMIT_VIRTUALTABLE\niCnt = 0;\nfor(pVdbe=db.pVdbe; pVdbe; pVdbe=pVdbe.pNext){\nif( pVdbe.magic==VDBE_MAGIC_RUN && pVdbe.inVtabMethod<2 && pVdbe.pc>=0 ){\niCnt++;\n}\n}\n#else\n              iCnt = db.activeVdbeCnt;\n#endif\n              if ( iCnt > 1 )\n              {\n                rc = SQLITE_LOCKED;\n                p.errorAction = OE_Abort;\n              }\n              else\n              {\n                iDb = pOp.p3;\n                Debug.Assert( iCnt == 1 );\n                Debug.Assert( ( p.btreeMask & ( 1 << iDb ) ) != 0 );\n                rc = sqlite3BtreeDropTable( db.aDb[iDb].pBt,pOp.p1, ref iMoved );\n                MemSetTypeFlag( pOut, MEM_Int );\n                pOut.u.i = iMoved;\n#if !SQLITE_OMIT_AUTOVACUUM\n                if ( rc == SQLITE_OK && iMoved != 0 )\n                {\n                  sqlite3RootPageMoved( db.aDb[iDb], iMoved, pOp.p1 );\n                }\n#endif\n              }\n              break;\n            }\n\n          /* Opcode: Clear P1 P2 P3\n          **\n          ** Delete all contents of the database table or index whose root page\n          ** in the database file is given by P1.  But, unlike Destroy, do not\n          ** remove the table or index from the database file.\n          **\n          ** The table being clear is in the main database file if P2==0.  If\n          ** P2==1 then the table to be clear is in the auxiliary database file\n          ** that is used to store tables create using CREATE TEMPORARY TABLE.\n          **\n          ** If the P3 value is non-zero, then the table referred to must be an\n          ** intkey table (an SQL table, not an index). In this case the row change\n          ** count is incremented by the number of rows in the table being cleared.\n          ** If P3 is greater than zero, then the value stored in register P3 is\n          ** also incremented by the number of rows in the table being cleared.\n          **\n          ** See also: Destroy\n          */\n          case OP_Clear:\n            {\n              int nChange;\n\n              nChange = 0;\n              Debug.Assert( ( p.btreeMask & ( 1 << pOp.p2 ) ) != 0 );\n              int iDummy0 = 0;\n              if ( pOp.p3 != 0 ) rc = sqlite3BtreeClearTable( db.aDb[pOp.p2].pBt, pOp.p1, ref nChange );\n              else rc = sqlite3BtreeClearTable( db.aDb[pOp.p2].pBt, pOp.p1, ref iDummy0 );\n              if ( pOp.p3 != 0 )\n              {\n                p.nChange += nChange;\n                if ( pOp.p3 > 0 )\n                {\n                  p.aMem[pOp.p3].u.i += nChange;\n                }\n              }\n              break;\n            }\n\n          /* Opcode: CreateTable P1 P2 * * *\n          **\n          ** Allocate a new table in the main database file if P1==0 or in the\n          ** auxiliary database file if P1==1 or in an attached database if\n          ** P1>1.  Write the root page number of the new table into\n          ** register P2\n          **\n          ** The difference between a table and an index is this:  A table must\n          ** have a 4-byte integer key and can have arbitrary data.  An index\n          ** has an arbitrary key but no data.\n          **\n          ** See also: CreateIndex\n          */\n          /* Opcode: CreateIndex P1 P2 * * *\n          **\n          ** Allocate a new index in the main database file if P1==0 or in the\n          ** auxiliary database file if P1==1 or in an attached database if\n          ** P1>1.  Write the root page number of the new table into\n          ** register P2.\n          **\n          ** See documentation on OP_CreateTable for additional information.\n          */\n          case OP_CreateIndex:            /* out2-prerelease */\n          case OP_CreateTable:\n            {          /* out2-prerelease */\n              int pgno;\n              int flags;\n              Db pDb;\n\n              pgno = 0;\n              Debug.Assert( pOp.p1 >= 0 && pOp.p1 < db.nDb );\n              Debug.Assert( ( p.btreeMask & ( 1 << pOp.p1 ) ) != 0 );\n              pDb = db.aDb[pOp.p1];\n              Debug.Assert( pDb.pBt != null );\n              if ( pOp.opcode == OP_CreateTable )\n              {\n                /* flags = BTREE_INTKEY; */\n                flags = BTREE_LEAFDATA | BTREE_INTKEY;\n              }\n              else\n              {\n                flags = BTREE_ZERODATA;\n              }\n              rc = sqlite3BtreeCreateTable( pDb.pBt, ref pgno, flags );\n              pOut.u.i = pgno;\n              MemSetTypeFlag( pOut, MEM_Int );\n              break;\n            }\n\n          /* Opcode: ParseSchema P1 P2 * P4 *\n          **\n          ** Read and parse all entries from the SQLITE_MASTER table of database P1\n          ** that match the WHERE clause P4.  P2 is the "force" flag.   Always do\n          ** the parsing if P2 is true.  If P2 is false, then this routine is a\n          ** no-op if the schema is not currently loaded.  In other words, if P2\n          ** is false, the SQLITE_MASTER table is only parsed if the rest of the\n          ** schema is already loaded into the symbol table.\n          **\n          ** This opcode invokes the parser to create a new virtual machine,\n          ** then runs the new virtual machine.  It is thus a re-entrant opcode.\n          */\n          case OP_ParseSchema:\n            {\n              int iDb;\n              string zMaster;\n              string zSql;\n              InitData initData;\n\n\n              iDb = pOp.p1;\n              Debug.Assert( iDb >= 0 && iDb < db.nDb );\n\n              /* If pOp->p2 is 0, then this opcode is being executed to read a\n              ** single row, for example the row corresponding to a new index\n              ** created by this VDBE, from the sqlite_master table. It only\n              ** does this if the corresponding in-memory schema is currently\n              ** loaded. Otherwise, the new index definition can be loaded along\n              ** with the rest of the schema when it is required.\n              **\n              ** Although the mutex on the BtShared object that corresponds to\n              ** database iDb (the database containing the sqlite_master table\n              ** read by this instruction) is currently held, it is necessary to\n              ** obtain the mutexes on all attached databases before checking if\n              ** the schema of iDb is loaded. This is because, at the start of\n              ** the sqlite3_exec() call below, SQLite will invoke\n              ** sqlite3BtreeEnterAll(). If all mutexes are not already held, the\n              ** iDb mutex may be temporarily released to avoid deadlock. If\n              ** this happens, then some other thread may delete the in-memory\n              ** schema of database iDb before the SQL statement runs. The schema\n              ** will not be reloaded becuase the db->init.busy flag is set. This\n              ** can result in a "no such table: sqlite_master" or "malformed\n              ** database schema" error being returned to the user.\n              */\n              Debug.Assert( sqlite3BtreeHoldsMutex( db.aDb[iDb].pBt ) );\n              sqlite3BtreeEnterAll( db );\n              if ( pOp.p2 != 0 || DbHasProperty( db, iDb, DB_SchemaLoaded ) )\n              {\n                zMaster = SCHEMA_TABLE( iDb );\n                initData = new InitData();\n                initData.db = db;\n                initData.iDb = pOp.p1;\n                initData.pzErrMsg = p.zErrMsg;\n                zSql = sqlite3MPrintf( db,\n                "SELECT name, rootpage, sql FROM \'%q\'.%s WHERE %s",\n                db.aDb[iDb].zName, zMaster, pOp.p4.z );\n                if ( String.IsNullOrEmpty( zSql ) )\n                {\n                  rc = SQLITE_NOMEM;\n                }\n                else\n                {\n#if SQLITE_DEBUG\n                  sqlite3SafetyOff( db );\n#endif\n                  Debug.Assert( 0 == db.init.busy );\n                  db.init.busy = 1;\n                  initData.rc = SQLITE_OK;\n                  //Debug.Assert( 0 == db.mallocFailed );\n                  rc = sqlite3_exec( db, zSql, (dxCallback)sqlite3InitCallback, (object)initData, 0 );\n                  if ( rc == SQLITE_OK ) rc = initData.rc;\n                  //sqlite3DbFree( db, ref zSql );\n                  db.init.busy = 0;\n#if SQLITE_DEBUG\n                  sqlite3SafetyOn( db );\n#endif\n                }\n              }\n              sqlite3BtreeLeaveAll( db );\n              if ( rc == SQLITE_NOMEM )\n              {\n                goto no_mem;\n              }\n              break;\n            }\n\n#if  !SQLITE_OMIT_ANALYZE\n          /* Opcode: LoadAnalysis P1 * * * *\n**\n** Read the sqlite_stat1 table for database P1 and load the content\n** of that table into the internal index hash table.  This will cause\n** the analysis to be used when preparing all subsequent queries.\n*/\n          case OP_LoadAnalysis:\n            {\n              Debug.Assert( pOp.p1 >= 0 && pOp.p1 < db.nDb );\n              rc = sqlite3AnalysisLoad( db, pOp.p1 );\n              break;\n            }\n#endif // * !SQLITE_OMIT_ANALYZE) */\n\n          /* Opcode: DropTable P1 * * P4 *\n**\n** Remove the internal (in-memory) data structures that describe\n** the table named P4 in database P1.  This is called after a table\n** is dropped in order to keep the internal representation of the\n** schema consistent with what is on disk.\n*/\n          case OP_DropTable:\n            {\n              sqlite3UnlinkAndDeleteTable( db, pOp.p1, pOp.p4.z );\n              break;\n            }\n\n          /* Opcode: DropIndex P1 * * P4 *\n          **\n          ** Remove the internal (in-memory) data structures that describe\n          ** the index named P4 in database P1.  This is called after an index\n          ** is dropped in order to keep the internal representation of the\n          ** schema consistent with what is on disk.\n          */\n          case OP_DropIndex:\n            {\n              sqlite3UnlinkAndDeleteIndex( db, pOp.p1, pOp.p4.z );\n              break;\n            }\n\n          /* Opcode: DropTrigger P1 * * P4 *\n          **\n          ** Remove the internal (in-memory) data structures that describe\n          ** the trigger named P4 in database P1.  This is called after a trigger\n          ** is dropped in order to keep the internal representation of the\n          ** schema consistent with what is on disk.\n          */\n          case OP_DropTrigger:\n            {\n              sqlite3UnlinkAndDeleteTrigger( db, pOp.p1, pOp.p4.z );\n              break;\n            }\n\n\n#if !SQLITE_OMIT_INTEGRITY_CHECK\n          /* Opcode: IntegrityCk P1 P2 P3 * P5\n**\n** Do an analysis of the currently open database.  Store in\n** register P1 the text of an error message describing any problems.\n** If no problems are found, store a NULL in register P1.\n**\n** The register P3 contains the maximum number of allowed errors.\n** At most reg(P3) errors will be reported.\n** In other words, the analysis stops as soon as reg(P1) errors are\n** seen.  Reg(P1) is updated with the number of errors remaining.\n**\n** The root page numbers of all tables in the database are integer\n** stored in reg(P1), reg(P1+1), reg(P1+2), ....  There are P2 tables\n** total.\n**\n** If P5 is not zero, the check is done on the auxiliary database\n** file, not the main database file.\n**\n** This opcode is used to implement the integrity_check pragma.\n*/\n          case OP_IntegrityCk:\n            {\n              int nRoot;       /* Number of tables to check.  (Number of root pages.) */\n              int[] aRoot;     /* Array of rootpage numbers for tables to be checked */\n              int j;           /* Loop counter */\n              int nErr = 0;    /* Number of errors reported */\n              string z;        /* Text of the error report */\n              Mem pnErr;       /* Register keeping track of errors remaining */\n\n              nRoot = pOp.p2;\n              Debug.Assert( nRoot > 0 );\n              aRoot = new int[nRoot + 1];// sqlite3DbMallocRaw(db, sizeof(int) * (nRoot + 1));\n              if ( aRoot == null ) goto no_mem;\n              Debug.Assert( pOp.p3 > 0 && pOp.p3 <= p.nMem );\n              pnErr = p.aMem[pOp.p3];\n              Debug.Assert( ( pnErr.flags & MEM_Int ) != 0 );\n              Debug.Assert( ( pnErr.flags & ( MEM_Str | MEM_Blob ) ) == 0 );\n              pIn1 = p.aMem[pOp.p1];\n              for ( j = 0 ; j < nRoot ; j++ )\n              {\n                aRoot[j] = (int)sqlite3VdbeIntValue( p.aMem[pOp.p1 + j] ); // pIn1[j]);\n              }\n              aRoot[j] = 0;\n              Debug.Assert( pOp.p5 < db.nDb );\n              Debug.Assert( ( p.btreeMask & ( 1 << pOp.p5 ) ) != 0 );\n              z = sqlite3BtreeIntegrityCheck( db.aDb[pOp.p5].pBt, aRoot, nRoot,\n              (int)pnErr.u.i, ref nErr );\n              //sqlite3DbFree( db, ref aRoot );\n              pnErr.u.i -= nErr;\n              sqlite3VdbeMemSetNull( pIn1 );\n              if ( nErr == 0 )\n              {\n                Debug.Assert( z == "" );\n              }\n              else if ( String.IsNullOrEmpty( z ) )\n              {\n                goto no_mem;\n              }\n              else\n              {\n                sqlite3VdbeMemSetStr(pIn1, z, -1, SQLITE_UTF8, null); //sqlite3_free );\n              }\n#if SQLITE_TEST\n              UPDATE_MAX_BLOBSIZE( pIn1 );\n#endif\n              sqlite3VdbeChangeEncoding( pIn1, encoding );\n              break;\n            }\n#endif // * SQLITE_OMIT_INTEGRITY_CHECK */\n\n          /* Opcode: RowSetAdd P1 P2 * * *\n**\n** Insert the integer value held by register P2 into a boolean index\n** held in register P1.\n**\n** An assertion fails if P2 is not an integer.\n*/\n          case OP_RowSetAdd:\n            {       /* in2 */\n              Mem pIdx;\n              Mem pVal;\n              Debug.Assert( pOp.p1 > 0 && pOp.p1 <= p.nMem );\n              pIdx = p.aMem[pOp.p1];\n              Debug.Assert( pOp.p2 > 0 && pOp.p2 <= p.nMem );\n              pVal = p.aMem[pOp.p2];\n              Debug.Assert( ( pVal.flags & MEM_Int ) != 0 );\n              if ( ( pIdx.flags & MEM_RowSet ) == 0 )\n              {\n                sqlite3VdbeMemSetRowSet( pIdx );\n                if ( ( pIdx.flags & MEM_RowSet ) == 0 ) goto no_mem;\n              }\n              sqlite3RowSetInsert( pIdx.u.pRowSet, pVal.u.i );\n              break;\n            }\n\n          /* Opcode: RowSetRead P1 P2 P3 * *\n          **\n          ** Extract the smallest value from boolean index P1 and put that value into\n          ** register P3.  Or, if boolean index P1 is initially empty, leave P3\n          ** unchanged and jump to instruction P2.\n          */\n          case OP_RowSetRead:\n            {       /* jump, out3 */\n              Mem pIdx;\n              i64 val = 0;\n              Debug.Assert( pOp.p1 > 0 && pOp.p1 <= p.nMem );\n              if ( db.u1.isInterrupted ) goto abort_due_to_interrupt; //CHECK_FOR_INTERRUPT;\n              pIdx = p.aMem[pOp.p1];\n              pOut = p.aMem[pOp.p3];\n              if ( ( pIdx.flags & MEM_RowSet ) == 0\n              || sqlite3RowSetNext( pIdx.u.pRowSet, ref val ) == 0\n              )\n              {\n                /* The boolean index is empty */\n                sqlite3VdbeMemSetNull( pIdx );\n                pc = pOp.p2 - 1;\n              }\n              else\n              {\n                /* A value was pulled from the index */\n                Debug.Assert( pOp.p3 > 0 && pOp.p3 <= p.nMem );\n                sqlite3VdbeMemSetInt64( pOut, val );\n              }\n              break;\n            }\n\n          /* Opcode: RowSetTest P1 P2 P3 P4\n          **\n          ** Register P3 is assumed to hold a 64-bit integer value. If register P1\n          ** contains a RowSet object and that RowSet object contains\n          ** the value held in P3, jump to register P2. Otherwise, insert the\n          ** integer in P3 into the RowSet and continue on to the\n          ** next opcode.\n          **\n          ** The RowSet object is optimized for the case where successive sets\n          ** of integers, where each set contains no duplicates. Each set\n          ** of values is identified by a unique P4 value. The first set\n          ** must have P4==0, the final set P4=-1.  P4 must be either -1 or\n          ** non-negative.  For non-negative values of P4 only the lower 4\n          ** bits are significant.\n          **\n          ** This allows optimizations: (a) when P4==0 there is no need to test\n          ** the rowset object for P3, as it is guaranteed not to contain it,\n          ** (b) when P4==-1 there is no need to insert the value, as it will\n          ** never be tested for, and (c) when a value that is part of set X is\n          ** inserted, there is no need to search to see if the same value was\n          ** previously inserted as part of set X (only if it was previously\n          ** inserted as part of some other set).\n          */\n          case OP_RowSetTest:\n            {                     /* jump, in1, in3 */\n              int iSet;\n              int exists;\n\n              iSet = pOp.p4.i;\n              Debug.Assert( ( pIn3.flags & MEM_Int ) != 0 );\n\n              /* If there is anything other than a rowset object in memory cell P1,\n              ** delete it now and initialize P1 with an empty rowset\n              */\n              if ( ( pIn1.flags & MEM_RowSet ) == 0 )\n              {\n                sqlite3VdbeMemSetRowSet( pIn1 );\n                if ( ( pIn1.flags & MEM_RowSet ) == 0 ) goto no_mem;\n              }\n\n              Debug.Assert( pOp.p4type == P4_INT32 );\n              Debug.Assert( iSet == -1 || iSet >= 0 );\n              if ( iSet != 0 )\n              {\n                exists = sqlite3RowSetTest( pIn1.u.pRowSet,\n                (u8)( iSet >= 0 ? iSet & 0xf : 0xff ),\n                pIn3.u.i );\n                if ( exists != 0 )\n                {\n                  pc = pOp.p2 - 1;\n                  break;\n                }\n              }\n              if ( iSet >= 0 )\n              {\n                sqlite3RowSetInsert( pIn1.u.pRowSet, pIn3.u.i );\n              }\n              break;\n            }\n\n#if !SQLITE_OMIT_TRIGGER\n          /* Opcode: ContextPush * * *\n**\n** Save the current Vdbe context such that it can be restored by a ContextPop\n** opcode. The context stores the last insert row id, the last statement change\n** count, and the current statement change count.\n*/\n          case OP_ContextPush:\n            {\n              int i;\n              Context pContext;\n\n              i = p.contextStackTop++;\n              Debug.Assert( i >= 0 );\n              /* FIX ME: This should be allocated as part of the vdbe at compile-time */\n              if ( i >= p.contextStackDepth )\n              {\n                p.contextStackDepth = i + 1;\n                if ( i == 0 )\n                  p.contextStack = new Context[i + 1];// sqlite3DbReallocOrFree( db, p.contextStack,\n                //        sizeof(Context) * ( i + 1 ) );\n                else\n                  Array.Resize( ref p.contextStack, i + 1 );\n                if ( p.contextStack == null ) goto no_mem;\n              }\n              p.contextStack[i] = new Context();\n              pContext = p.contextStack[i];\n              pContext.lastRowid = db.lastRowid;\n              pContext.nChange = p.nChange;\n              break;\n            }\n\n          /* Opcode: ContextPop * * *\n          **\n          ** Restore the Vdbe context to the state it was in when contextPush was last\n          ** executed. The context stores the last insert row id, the last statement\n          ** change count, and the current statement change count.\n          */\n          case OP_ContextPop:\n            {\n              Context pContext;\n\n              pContext = p.contextStack[--p.contextStackTop];\n              Debug.Assert( p.contextStackTop >= 0 );\n              db.lastRowid = pContext.lastRowid;\n              p.nChange = pContext.nChange;\n              break;\n            }\n#endif // * #if !SQLITE_OMIT_TRIGGER */\n\n#if !SQLITE_OMIT_AUTOINCREMENT\n          /* Opcode: MemMax P1 P2 * * *\n**\n** Set the value of register P1 to the maximum of its current value\n** and the value in register P2.\n**\n** This instruction throws an error if the memory cell is not initially\n** an integer.\n*/\n          case OP_MemMax:\n            {        /* in1, in2 */\n              sqlite3VdbeMemIntegerify( pIn1 );\n              sqlite3VdbeMemIntegerify( pIn2 );\n              if ( pIn1.u.i < pIn2.u.i )\n              {\n                pIn1.u.i = pIn2.u.i;\n              }\n              break;\n            }\n#endif // * SQLITE_OMIT_AUTOINCREMENT */\n\n          /* Opcode: IfPos P1 P2 * * *\n**\n** If the value of register P1 is 1 or greater, jump to P2.\n**\n** It is illegal to use this instruction on a register that does\n** not contain an integer.  An Debug.Assertion fault will result if you try.\n*/\n          case OP_IfPos:\n            {        /* jump, in1 */\n              Debug.Assert( ( pIn1.flags & MEM_Int ) != 0 );\n              if ( pIn1.u.i > 0 )\n              {\n                pc = pOp.p2 - 1;\n              }\n              break;\n            }\n\n          /* Opcode: IfNeg P1 P2 * * *\n          **\n          ** If the value of register P1 is less than zero, jump to P2.\n          **\n          ** It is illegal to use this instruction on a register that does\n          ** not contain an integer.  An Debug.Assertion fault will result if you try.\n          */\n          case OP_IfNeg:\n            {        /* jump, in1 */\n              Debug.Assert( ( pIn1.flags & MEM_Int ) != 0 );\n              if ( pIn1.u.i < 0 )\n              {\n                pc = pOp.p2 - 1;\n              }\n              break;\n            }\n\n          /* Opcode: IfZero P1 P2 * * *\n          **\n          ** If the value of register P1 is exactly 0, jump to P2.\n          **\n          ** It is illegal to use this instruction on a register that does\n          ** not contain an integer.  An Debug.Assertion fault will result if you try.\n          */\n          case OP_IfZero:\n            {        /* jump, in1 */\n              Debug.Assert( ( pIn1.flags & MEM_Int ) != 0 );\n              if ( pIn1.u.i == 0 )\n              {\n                pc = pOp.p2 - 1;\n              }\n              break;\n            }\n\n          /* Opcode: AggStep * P2 P3 P4 P5\n          **\n          ** Execute the step function for an aggregate.  The\n          ** function has P5 arguments.   P4 is a pointer to the FuncDef\n          ** structure that specifies the function.  Use register\n          ** P3 as the accumulator.\n          **\n          ** The P5 arguments are taken from register P2 and its\n          ** successors.\n          */\n          case OP_AggStep:\n            {\n              int n;\n              int i;\n              Mem pMem;\n              Mem pRec;\n              sqlite3_context ctx = new sqlite3_context();\n              sqlite3_value[] apVal;\n\n              n = pOp.p5;\n              Debug.Assert( n >= 0 );\n              //pRec = p.aMem[pOp.p2];\n              apVal = p.apArg;\n              Debug.Assert( apVal != null || n == 0 );\n              for ( i = 0 ; i < n ; i++ )//, pRec++)\n              {\n                pRec = p.aMem[pOp.p2 + i];\n                apVal[i] = pRec;\n                storeTypeInfo( pRec, encoding );\n              }\n              ctx.pFunc = pOp.p4.pFunc;\n              Debug.Assert( pOp.p3 > 0 && pOp.p3 <= p.nMem );\n              ctx.pMem = pMem = p.aMem[pOp.p3];\n              pMem.n++;\n              ctx.s.flags = MEM_Null;\n              ctx.s.z = null;\n              //ctx.s.zMalloc = null;\n              ctx.s.xDel = null;\n              ctx.s.db = db;\n              ctx.isError = 0;\n              ctx.pColl = null;\n              if ( ( ctx.pFunc.flags & SQLITE_FUNC_NEEDCOLL ) != 0 )\n              {\n                Debug.Assert( pc > 0 );//pOp > p.aOp );\n                Debug.Assert( p.aOp[pc - 1].p4type == P4_COLLSEQ ); //pOp[-1].p4type == P4_COLLSEQ );\n                Debug.Assert( p.aOp[pc - 1].opcode == OP_CollSeq ); // pOp[-1].opcode == OP_CollSeq );\n                ctx.pColl = p.aOp[pc - 1].p4.pColl; ;// pOp[-1].p4.pColl;\n              }\n              ctx.pFunc.xStep( ctx, n, apVal );\n              if ( ctx.isError != 0 )\n              {\n                sqlite3SetString( ref p.zErrMsg, db, sqlite3_value_text( ctx.s ) );\n                rc = ctx.isError;\n              }\n              sqlite3VdbeMemRelease( ctx.s );\n              break;\n            }\n\n          /* Opcode: AggFinal P1 P2 * P4 *\n          **\n          ** Execute the finalizer function for an aggregate.  P1 is\n          ** the memory location that is the accumulator for the aggregate.\n          **\n          ** P2 is the number of arguments that the step function takes and\n          ** P4 is a pointer to the FuncDef for this function.  The P2\n          ** argument is not used by this opcode.  It is only there to disambiguate\n          ** functions that can take varying numbers of arguments.  The\n          ** P4 argument is only needed for the degenerate case where\n          ** the step function was not previously called.\n          */\n          case OP_AggFinal:\n            {\n              Mem pMem;\n              Debug.Assert( pOp.p1 > 0 && pOp.p1 <= p.nMem );\n              pMem = p.aMem[pOp.p1];\n              Debug.Assert( ( pMem.flags & ~( MEM_Null | MEM_Agg ) ) == 0 );\n              rc = sqlite3VdbeMemFinalize( pMem, pOp.p4.pFunc );\n              p.aMem[pOp.p1] = pMem;\n              if ( rc != 0 )\n              {\n                sqlite3SetString( ref p.zErrMsg, db, sqlite3_value_text( pMem ) );\n              }\n              sqlite3VdbeChangeEncoding( pMem, encoding );\n#if SQLITE_TEST\n              UPDATE_MAX_BLOBSIZE( pMem );\n#endif\n              if ( sqlite3VdbeMemTooBig( pMem ) )\n              {\n                goto too_big;\n              }\n              break;\n            }\n\n\n#if  !SQLITE_OMIT_VACUUM && !SQLITE_OMIT_ATTACH\n          /* Opcode: Vacuum * * * * *\n**\n** Vacuum the entire database.  This opcode will cause other virtual\n** machines to be created and run.  It may not be called from within\n** a transaction.\n*/\n          case OP_Vacuum:\n            {\n#if SQLITE_DEBUG\n              if ( sqlite3SafetyOff( db ) ) goto abort_due_to_misuse;\n#endif\n              rc = sqlite3RunVacuum( ref p.zErrMsg, db );\n#if SQLITE_DEBUG\n              if ( sqlite3SafetyOn( db ) ) goto abort_due_to_misuse;\n#endif\n              break;\n            }\n#endif\n\n#if  !SQLITE_OMIT_AUTOVACUUM\n          /* Opcode: IncrVacuum P1 P2 * * *\n**\n** Perform a single step of the incremental vacuum procedure on\n** the P1 database. If the vacuum has finished, jump to instruction\n** P2. Otherwise, fall through to the next instruction.\n*/\n          case OP_IncrVacuum:\n            {        /* jump */\n              Btree pBt;\n\n              Debug.Assert( pOp.p1 >= 0 && pOp.p1 < db.nDb );\n              Debug.Assert( ( p.btreeMask & ( 1 << pOp.p1 ) ) != 0 );\n              pBt = db.aDb[pOp.p1].pBt;\n              rc = sqlite3BtreeIncrVacuum( pBt );\n              if ( rc == SQLITE_DONE )\n              {\n                pc = pOp.p2 - 1;\n                rc = SQLITE_OK;\n              }\n              break;\n            }\n#endif\n\n          /* Opcode: Expire P1 * * * *\n**\n** Cause precompiled statements to become expired. An expired statement\n** fails with an error code of SQLITE_SCHEMA if it is ever executed\n** (via sqlite3_step()).\n**\n** If P1 is 0, then all SQL statements become expired. If P1 is non-zero,\n** then only the currently executing statement is affected.\n*/\n          case OP_Expire:\n            {\n              if ( pOp.p1 == 0 )\n              {\n                sqlite3ExpirePreparedStatements( db );\n              }\n              else\n              {\n                p.expired = true;\n              }\n              break;\n            }\n\n#if !SQLITE_OMIT_SHARED_CACHE\n/* Opcode: TableLock P1 P2 P3 P4 *\n**\n** Obtain a lock on a particular table. This instruction is only used when\n** the shared-cache feature is enabled.\n**\n** P1 is the index of the database in sqlite3.aDb[] of the database\n** on which the lock is acquired.  A readlock is obtained if P3==0 or\n** a write lock if P3==1.\n**\n** P2 contains the root-page of the table to lock.\n**\n** P4 contains a pointer to the name of the table being locked. This is only\n** used to generate an error message if the lock cannot be obtained.\n*/\ncase OP_TableLock:\n{\nu8 isWriteLock = (u8)pOp.p3;\nif( isWriteLock || 0==(db.flags&SQLITE_ReadUncommitted) ){\nint p1 = pOp.p1; \nDebug.Assert( p1 >= 0 && p1 < db.nDb );\nDebug.Assert( ( p.btreeMask & ( 1 << p1 ) ) != 0 );\nDebug.Assert( isWriteLock == 0 || isWriteLock == 1 );\nrc = sqlite3BtreeLockTable( db.aDb[p1].pBt, pOp.p2, isWriteLock );\nif ( ( rc & 0xFF ) == SQLITE_LOCKED )\n{\nstring z = pOp.p4.z;\nsqlite3SetString( ref p.zErrMsg, db, "database table is locked: ", z );\n}\n}\nbreak;\n}\n#endif // * SQLITE_OMIT_SHARED_CACHE */\n\n#if ! SQLITE_OMIT_VIRTUALTABLE\n/* Opcode: VBegin * * * P4 *\n**\n** P4 may be a pointer to an sqlite3_vtab structure. If so, call the\n** xBegin method for that table.\n**\n** Also, whether or not P4 is set, check that this is not being called from\n** within a callback to a virtual table xSync() method. If it is, the error\n** code will be set to SQLITE_LOCKED.\n*/\ncase OP_VBegin: {\nVTable pVTab;\npVTab = pOp.p4.pVtab;\nrc = sqlite3VtabBegin(db, pVTab);\nif( pVTab !=null){\nsqlite3DbFree(db, p.zErrMsg);\np.zErrMsg = pVTab.pVtab.zErrMsg;\npVTab.pVtab.zErrMsg = null;\n}\nbreak;\n}\n#endif //* SQLITE_OMIT_VIRTUALTABLE */\n\n#if ! SQLITE_OMIT_VIRTUALTABLE\n/* Opcode: VCreate P1 * * P4 *\n**\n** P4 is the name of a virtual table in database P1. Call the xCreate method\n** for that table.\n*/\ncase OP_VCreate: {\nrc = sqlite3VtabCallCreate(db, pOp.p1, pOp.p4.z, p.zErrMsg);\nbreak;\n}\n#endif //* SQLITE_OMIT_VIRTUALTABLE */\n\n#if ! SQLITE_OMIT_VIRTUALTABLE\n/* Opcode: VDestroy P1 * * P4 *\n**\n** P4 is the name of a virtual table in database P1.  Call the xDestroy method\n** of that table.\n*/\ncase OP_VDestroy: {\np.inVtabMethod = 2;\nrc = sqlite3VtabCallDestroy(db, pOp.p1, pOp.p4.z);\np.inVtabMethod = 0;\nbreak;\n}\n#endif //* SQLITE_OMIT_VIRTUALTABLE */\n\n#if ! SQLITE_OMIT_VIRTUALTABLE\n/* Opcode: VOpen P1 * * P4 *\n**\n** P4 is a pointer to a virtual table object, an sqlite3_vtab structure.\n** P1 is a cursor number.  This opcode opens a cursor to the virtual\n** table and stores that cursor in P1.\n*/\ncase OP_VOpen: {\nVdbeCursor *pCur;\nsqlite3_vtab_cursor *pVtabCursor;\nsqlite3_vtab *pVtab;\nsqlite3_module *pModule;\n\npCur = 0;\npVtabCursor = 0;\npVtab = pOp.p4.pVtab.pVtab;\npModule = (sqlite3_module *)pVtab.pModule;\nDebug.Assert(pVtab && pModule);\nif( sqlite3SafetyOff(db) ) goto abort_due_to_misuse;\nrc = pModulE.xOpen(pVtab, pVtabCursor);\n//sqlite3DbFree(db, p.zErrMsg);\np.zErrMsg = pVtab.zErrMsg;\npVtab.zErrMsg = 0;\nif( sqlite3SafetyOn(db) ) goto abort_due_to_misuse;\nif( SQLITE_OK==rc ){\n/* Initialize sqlite3_vtab_cursor base class */\npVtabCursor.pVtab = pVtab;\n\n/* Initialise vdbe cursor object */\npCur = allocateCursor(p, pOp.p1, 0, -1, 0);\nif( pCur ){\npCur.pVtabCursor = pVtabCursor;\npCur.pModule = pVtabCursor.pVtab.pModule;\n}else{\ndb.mallocFailed = 1;\npModulE.xClose(pVtabCursor);\n}\n}\nbreak;\n}\n#endif //* SQLITE_OMIT_VIRTUALTABLE */\n\n#if ! SQLITE_OMIT_VIRTUALTABLE\n/* Opcode: VFilter P1 P2 P3 P4 *\n**\n** P1 is a cursor opened using VOpen.  P2 is an address to jump to if\n** the filtered result set is empty.\n**\n** P4 is either NULL or a string that was generated by the xBestIndex\n** method of the module.  The interpretation of the P4 string is left\n** to the module implementation.\n**\n** This opcode invokes the xFilter method on the virtual table specified\n** by P1.  The integer query plan parameter to xFilter is stored in register\n** P3. Register P3+1 stores the argc parameter to be passed to the\n** xFilter method. Registers P3+2..P3+1+argc are the argc\n** additional parameters which are passed to\n** xFilter as argv. Register P3+2 becomes argv[0] when passed to xFilter.\n**\n** A jump is made to P2 if the result set after filtering would be empty.\n*/\ncase OP_VFilter: {   /* jump */\nint nArg;\nint iQuery;\nconst sqlite3_module *pModule;\nMem *pQuery;\nMem *pArgc;\nsqlite3_vtab_cursor *pVtabCursor;\nsqlite3_vtab *pVtab;\nVdbeCursor *pCur;\nint res;\nint i;\nMem **apArg;\n\npQuery = &p.aMem[pOp.p3];\npArgc = &pQuery[1];\npCur = p.apCsr[pOp.p1];\nREGISTER_TRACE(pOp.p3, pQuery);\nDebug.Assert(pCur.pVtabCursor );\npVtabCursor = pCur.pVtabCursor;\npVtab = pVtabCursor.pVtab;\npModule = pVtab.pModule;\n\n/* Grab the index number and argc parameters */\nDebug.Assert((pQuery.flags&MEM_Int)!=0 && pArgc.flags==MEM_Int );\nnArg = (int)pArgc.u.i;\niQuery = (int)pQuery.u.i;\n\n/* Invoke th  /\n{\nres = 0;\napArg = p.apArg;\nfor(i = 0; i<nArg; i++){\napArg[i] = pArgc[i+1];\nstoreTypeInfo(apArg[i], 0);\n}\n\nif( sqlite3SafetyOff(db) ) goto abort_due_to_misuse;\np.inVtabMethod = 1;\nrc = pModulE.xFilter(pVtabCursor, iQuery, pOp.p4.z, nArg, apArg);\np.inVtabMethod = 0;\n//sqlite3DbFree(db, p.zErrMsg);\np.zErrMsg = pVtab.zErrMsg;\npVtab.zErrMsg = 0;\nif( rc==SQLITE_OK ){\nres = pModulE.xEof(pVtabCursor);\n}\nif( sqlite3SafetyOn(db) ) goto abort_due_to_misuse;\n\nif( res ){\npc = pOp.p2 - 1;\n}\n}\npCur.nullRow = 0;\nbreak;\n}\n#endif //* SQLITE_OMIT_VIRTUALTABLE */\n\n#if ! SQLITE_OMIT_VIRTUALTABLE\n/* Opcode: VColumn P1 P2 P3 * *\n**\n** Store the value of the P2-th column of\n** the row of the virtual-table that the\n** P1 cursor is pointing to into register P3.\n*/\ncase OP_VColumn: {\nsqlite3_vtab pVtab;\nconst sqlite3_module pModule;\nMem pDest;\nsqlite3_context sContext;\n\nVdbeCursor pCur = p.apCsr[pOp.p1];\nDebug.Assert(pCur.pVtabCursor );\nDebug.Assert(pOp.p3>0 && pOp.p3<=p.nMem );\npDest = p.aMem[pOp.p3];\nif( pCur.nullRow ){\nsqlite3VdbeMemSetNull(pDest);\nbreak;\n}\npVtab = pCur.pVtabCursor.pVtab;\npModule = pVtab.pModule;\nDebug.Assert(pModulE.xColumn );\nmemset(&sContext, 0, sizeof(sContext));\n\n/* The output cell may already have a buffer allocated. Move\n** the current contents to sContext.s so in case the user-function\n** can use the already allocated buffer instead of allocating a\n** new one.\n*/\nsqlite3VdbeMemMove(&sContext.s, pDest);\nMemSetTypeFlag(&sContext.s, MEM_Null);\n\nif( sqlite3SafetyOff(db) ) goto abort_due_to_misuse;\nrc = pModulE.xColumn(pCur.pVtabCursor, sContext, pOp.p2);\n//sqlite3DbFree(db, p.zErrMsg);\np.zErrMsg = pVtab.zErrMsg;\npVtab.zErrMsg = 0;\nif( sContext.isError ){\nrc = sContext.isError;\n}\n\n/* Copy the result of the function to the P3 register. We\n** do this regardless of whether or not an error occurred to ensure any\n** dynamic allocation in sContext.s (a Mem struct) is  released.\n*/\nsqlite3VdbeChangeEncoding(&sContext.s, encoding);\nREGISTER_TRACE(pOp.p3, pDest);\nsqlite3VdbeMemMove(pDest, sContext.s);\nUPDATE_MAX_BLOBSIZE(pDest);\n\nif( sqlite3SafetyOn(db) ){\ngoto abort_due_to_misuse;\n}\nif( sqlite3VdbeMemTooBig(pDest) ){\ngoto too_big;\n}\nbreak;\n}\n#endif //* SQLITE_OMIT_VIRTUALTABLE */\n\n#if ! SQLITE_OMIT_VIRTUALTABLE\n/* Opcode: VNext P1 P2 * * *\n**\n** Advance virtual table P1 to the next row in its result set and\n** jump to instruction P2.  Or, if the virtual table has reached\n** the end of its result set, then fall through to the next instruction.\n*/\ncase OP_VNext: {   /* jump */\nsqlite3_vtab *pVtab;\nconst sqlite3_module *pModule;\nint res;\nVdbeCursor *pCur;\n\nres = 0;\npCur = p.apCsr[pOp.p1];\nDebug.Assert( pCur.pVtabCursor );\nif( pCur.nullRow ){\nbreak;\n}\npVtab = pCur.pVtabCursor.pVtab;\npModule = pVtab.pModule;\nDebug.Assert(pModulE.xNext );\n\n/* Invoke the xNext() method of the module. There is no way for the\n** underlying implementation to return an error if one occurs during\n** xNext(). Instead, if an error occurs, true is returned (indicating that\n** data is available) and the error code returned when xColumn or\n** some other method is next invoked on the save virtual table cursor.\n*/\nif( sqlite3SafetyOff(db) ) goto abort_due_to_misuse;\np.inVtabMethod = 1;\nrc = pModulE.xNext(pCur.pVtabCursor);\np.inVtabMethod = 0;\n//sqlite3DbFree(db, p.zErrMsg);\np.zErrMsg = pVtab.zErrMsg;\npVtab.zErrMsg = 0;\nif( rc==SQLITE_OK ){\nres = pModulE.xEof(pCur.pVtabCursor);\n}\nif( sqlite3SafetyOn(db) ) goto abort_due_to_misuse;\n\nif( !res ){\n/* If there is data, jump to P2 */\npc = pOp.p2 - 1;\n}\nbreak;\n}\n#endif //* SQLITE_OMIT_VIRTUALTABLE */\n\n#if ! SQLITE_OMIT_VIRTUALTABLE\n/* Opcode: VRename P1 * * P4 *\n**\n** P4 is a pointer to a virtual table object, an sqlite3_vtab structure.\n** This opcode invokes the corresponding xRename method. The value\n** in register P1 is passed as the zName argument to the xRename method.\n*/\ncase OP_VRename: {\nsqlite3_vtab *pVtab;\nMem *pName;\n\npVtab = pOp.p4.pVtab.pVtab;\npName = &p.aMem[pOp.p1];\nDebug.Assert( pVtab.pModule.xRename );\nREGISTER_TRACE(pOp.p1, pName);\nDebug.Assert( pName.flags & MEM_Str );\nif( sqlite3SafetyOff(db) ) goto abort_due_to_misuse;\nrc = pVtab.pModulE.xRename(pVtab, pName.z);\n//sqlite3DbFree(db, p.zErrMsg);\np.zErrMsg = pVtab.zErrMsg;\npVtab.zErrMsg = 0;\nif( sqlite3SafetyOn(db) ) goto abort_due_to_misuse;\n\nbreak;\n}\n#endif\n\n#if ! SQLITE_OMIT_VIRTUALTABLE\n/* Opcode: VUpdate P1 P2 P3 P4 *\n**\n** P4 is a pointer to a virtual table object, an sqlite3_vtab structure.\n** This opcode invokes the corresponding xUpdate method. P2 values\n** are contiguous memory cells starting at P3 to pass to the xUpdate\n** invocation. The value in register (P3+P2-1) corresponds to the\n** p2th element of the argv array passed to xUpdate.\n**\n** The xUpdate method will do a DELETE or an INSERT or both.\n** The argv[0] element (which corresponds to memory cell P3)\n** is the rowid of a row to delete.  If argv[0] is NULL then no\n** deletion occurs.  The argv[1] element is the rowid of the new\n** row.  This can be NULL to have the virtual table select the new\n** rowid for itself.  The subsequent elements in the array are\n** the values of columns in the new row.\n**\n** If P2==1 then no insert is performed.  argv[0] is the rowid of\n** a row to delete.\n**\n** P1 is a boolean flag. If it is set to true and the xUpdate call\n** is successful, then the value returned by sqlite3_last_insert_rowid()\n** is set to the value of the rowid for the row just inserted.\n*/\ncase OP_VUpdate: {\nsqlite3_vtab *pVtab;\nsqlite3_module *pModule;\nint nArg;\nint i;\nsqlite_int64 rowid;\nMem **apArg;\nMem *pX;\n\npVtab = pOp.p4.pVtab.pVtab;\npModule = (sqlite3_module *)pVtab.pModule;\nnArg = pOp.p2;\nDebug.Assert( pOp.p4type==P4_VTAB );\nif( ALWAYS(pModule.xUpdate) ){\napArg = p.apArg;\npX = &p.aMem[pOp.p3];\nfor(i=0; i<nArg; i++){\nstoreTypeInfo(pX, 0);\napArg[i] = pX;\npX++;\n}\nif( sqlite3SafetyOff(db) ) goto abort_due_to_misuse;\nrc = pModule.xUpdate(pVtab, nArg, apArg, &rowid);\n//sqlite3DbFree(db, p.zErrMsg);\np.zErrMsg = pVtab.zErrMsg;\npVtab.zErrMsg = 0;\nif( sqlite3SafetyOn(db) ) goto abort_due_to_misuse;\nif( rc==SQLITE_OK && pOp.p1 ){\nDebug.Assert( nArg>1 && apArg[0] && (apArg[0].flags&MEM_Null) );\ndb.lastRowid = rowid;\n}\np.nChange++;\n}\nbreak;\n}\n#endif //* SQLITE_OMIT_VIRTUALTABLE */\n\n#if !SQLITE_OMIT_PAGER_PRAGMAS\n          /* Opcode: Pagecount P1 P2 * * *\n**\n** Write the current number of pages in database P1 to memory cell P2.\n*/\n          case OP_Pagecount:\n            {            /* out2-prerelease */\n              int p1;\n              int nPage = 0;\n              Pager pPager;\n\n              p1 = pOp.p1;\n              pPager = sqlite3BtreePager( db.aDb[p1].pBt );\n              rc = sqlite3PagerPagecount( pPager, ref nPage );\n              /* OP_Pagecount is always called from within a read transaction.  The\n              ** page count has already been successfully read and cached.  So the\n              ** sqlite3PagerPagecount() call above cannot fail. */\n              if ( ALWAYS( rc == SQLITE_OK ) )\n              {\n                pOut.flags = MEM_Int;\n                pOut.u.i = nPage;\n              }\n              break;\n            }\n#endif\n\n\n#if !SQLITE_OMIT_TRACE\n          /* Opcode: Trace * * * P4 *\n**\n** If tracing is enabled (by the sqlite3_trace()) interface, then\n** the UTF-8 string contained in P4 is emitted on the trace callback.\n*/\n          case OP_Trace:\n            {\n              string zTrace;\n\n              zTrace = ( pOp.p4.z != null ? pOp.p4.z : p.zSql );\n              if ( !String.IsNullOrEmpty( zTrace ) )\n              {\n                if ( db.xTrace != null )\n                {\n                  db.xTrace( db.pTraceArg, zTrace );\n                }\n#if SQLITE_DEBUG\n                if ( ( db.flags & SQLITE_SqlTrace ) != 0 )\n                {\n                  sqlite3DebugPrintf( "SQL-trace: %s\\n", zTrace );\n                }\n#endif // * SQLITE_DEBUG */\n              }\n              break;\n            }\n#endif\n\n\n          /* Opcode: Noop * * * * *\n**\n** Do nothing.  This instruction is often useful as a jump\n** destination.\n*/\n          /*\n          ** The magic Explain opcode are only inserted when explain==2 (which\n          ** is to say when the EXPLAIN QUERY PLAN syntax is used.)\n          ** This opcode records information from the optimizer.  It is the\n          ** the same as a no-op.  This opcodesnever appears in a real VM program.\n          */\n          default:\n            {          /* This is really OP_Noop and OP_Explain */\n              break;\n            }\n\n          /*****************************************************************************\n          ** The cases of the switch statement above this line should all be indented\n          ** by 6 spaces.  But the left-most 6 spaces have been removed to improve the\n          ** readability.  From this point on down, the normal indentation rules are\n          ** restored.\n          *****************************************************************************/\n        }\n\n#if VDBE_PROFILE\n{\nu64 elapsed = sqlite3Hwtime() - start;\npOp.cycles += elapsed;\npOp.cnt++;\n#if  FALSE\nfprintf(stdout, "%10llu ", elapsed);\nsqlite3VdbePrintOp(stdout, origPc, p.aOp[origPc]);\n#endif\n}\n#endif\n\n        /* The following code adds nothing to the actual functionality\n** of the program.  It is only here for testing and debugging.\n** On the other hand, it does burn CPU cycles every time through\n** the evaluator loop.  So we can leave it out when NDEBUG is defined.\n*/\n#if !NDEBUG\n        Debug.Assert( pc >= -1 && pc < p.nOp );\n\n#if SQLITE_DEBUG\n        if ( p.trace != null )\n        {\n          if ( rc != 0 ) fprintf( p.trace, "rc=%d\\n", rc );\n          if ( ( opProperty & OPFLG_OUT2_PRERELEASE ) != 0 )\n          {\n            registerTrace( p.trace, pOp.p2, pOut );\n          }\n          if ( ( opProperty & OPFLG_OUT3 ) != 0 )\n          {\n            registerTrace( p.trace, pOp.p3, pOut );\n          }\n        }\n#endif  // * SQLITE_DEBUG */\n#endif  // * NDEBUG */\n      }  /* The end of the for(;;) loop the loops through opcodes */\n\n            /* If we reach this point, it means that execution is finished with\n            ** an error of some kind.\n            */\nvdbe_error_halt:\n      Debug.Assert( rc != 0 );\n      p.rc = rc;\n      sqlite3VdbeHalt( p );\n      //if ( rc == SQLITE_IOERR_NOMEM ) db.mallocFailed = 1;\n      rc = SQLITE_ERROR;\n\n      /* This is the only way out of this procedure.  We have to\n      ** release the mutexes on btrees that were acquired at the\n      ** top. */\nvdbe_return:\n      sqlite3BtreeMutexArrayLeave( p.aMutex );\n      return rc;\n\n      /* Jump to here if a string or blob larger than db.aLimit[SQLITE_LIMIT_LENGTH]\n      ** is encountered.\n      */\ntoo_big:\n      sqlite3SetString( ref p.zErrMsg, db, "string or blob too big" );\n      rc = SQLITE_TOOBIG;\n      goto vdbe_error_halt;\n\n      /* Jump to here if a malloc() fails.\n      */\nno_mem:\n      //db.mallocFailed = 1;\n      sqlite3SetString( ref p.zErrMsg, db, "out of memory" );\n      rc = SQLITE_NOMEM;\n      goto vdbe_error_halt;\n\n#if SQLITE_DEBUG\n/* Jump to here for an SQLITE_MISUSE error.\n*/\nabort_due_to_misuse:\n      rc = SQLITE_MISUSE;\n#endif\n\n/* Fall thru into abort_due_to_error */\n\n      /* Jump to here for any other kind of fatal error.  The "rc" variable\n      ** should hold the error number.\n      */\nabort_due_to_error:\n      //Debug.Assert( p.zErrMsg); /// Not needed in C#\n      //if ( db.mallocFailed != 0 ) rc = SQLITE_NOMEM;\n      if ( rc != SQLITE_IOERR_NOMEM )\n      {\n        sqlite3SetString( ref p.zErrMsg, db, "%s", sqlite3ErrStr( rc ) );\n      }\n      goto vdbe_error_halt;\n\n      /* Jump to here if the sqlite3_interrupt() API sets the interrupt\n      ** flag.\n      */\nabort_due_to_interrupt:\n      Debug.Assert( db.u1.isInterrupted );\n      rc = SQLITE_INTERRUPT;\n      p.rc = rc;\n      sqlite3SetString( ref p.zErrMsg, db, sqlite3ErrStr( rc ) );\n      goto vdbe_error_halt;\n    }\n  }\n}\n'