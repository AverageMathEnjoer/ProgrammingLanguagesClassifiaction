b'{- Implements a queue with the following properties:\n\n- waits for the queue to be fully pushed when exiting using ctrl-c (SIGINT)\n- allows stopping the producer\n- avoids pushing duplicate store paths\n\nUse SIGINT to safely exit on demand.\n-}\nmodule Cachix.Client.PushQueue\n  ( startWorkers,\n    Queue,\n  )\nwhere\n\nimport Cachix.Client.CNix (filterInvalidStorePath)\nimport qualified Cachix.Client.Push as Push\nimport Cachix.Client.Retry (retryAll)\nimport Control.Concurrent.Async\nimport Control.Concurrent.Extra (once)\nimport Control.Concurrent.STM (TVar, modifyTVar\', newTVarIO, readTVar)\nimport qualified Control.Concurrent.STM.Lock as Lock\nimport qualified Control.Concurrent.STM.TBQueue as TBQueue\nimport qualified Data.Set as S\nimport Hercules.CNix.Store (StorePath)\nimport Protolude\nimport qualified System.Posix.Signals as Signals\nimport qualified System.Systemd.Daemon as Systemd\n\ntype Queue = TBQueue.TBQueue StorePath\n\ndata PushWorkerState = PushWorkerState\n  { pushQueue :: Queue,\n    inProgress :: TVar Int\n  }\n\ndata QueryWorkerState = QueryWorkerState\n  { queryQueue :: Queue,\n    alreadyQueued :: S.Set StorePath,\n    lock :: Lock.Lock\n  }\n\nworker :: Push.PushParams IO () -> PushWorkerState -> IO ()\nworker pushParams workerState = forever $ do\n  storePath <- atomically $ TBQueue.readTBQueue $ pushQueue workerState\n  bracket_ (inProgressModify (+ 1)) (inProgressModify (\\x -> x - 1)) $\n    retryAll $\n      \\retrystatus -> do\n        maybeStorePath <- filterInvalidStorePath (Push.pushParamsStore pushParams) storePath\n        for_ maybeStorePath $ \\validatedStorePath ->\n          Push.uploadStorePath pushParams validatedStorePath retrystatus\n  where\n    inProgressModify f =\n      atomically $ modifyTVar\' (inProgress workerState) f\n\n-- NOTE: producer is responsible for signaling SIGINT upon termination\n-- NOTE: producer should return an `IO ()` that should be a blocking operation for terminating it\nstartWorkers :: Int -> (Queue -> IO (IO ())) -> Push.PushParams IO () -> IO ()\nstartWorkers numWorkers mkProducer pushParams = do\n  -- start query worker\n  (newQueryQueue, newPushQueue, newLock) <-\n    atomically $\n      (,,) <$> TBQueue.newTBQueue 10000 <*> TBQueue.newTBQueue 10000 <*> Lock.new\n  let queryWorkerState = QueryWorkerState newQueryQueue S.empty newLock\n  queryWorker <- async $ queryLoop queryWorkerState newPushQueue pushParams\n\n  -- start push workers\n  stopProducerCallback <- mkProducer newQueryQueue\n  progress <- newTVarIO 0\n  let pushWorkerState = PushWorkerState newPushQueue progress\n  pushWorker <- async $ replicateConcurrently_ numWorkers $ worker pushParams pushWorkerState\n\n  -- Gracefully shutdown the workers on interrupt\n  let handler =\n        Signals.CatchOnce $\n          exitOnceQueueIsEmpty stopProducerCallback pushWorker queryWorker queryWorkerState pushWorkerState\n  for_ [Signals.sigINT, Signals.sigTERM] $ \\signal ->\n    Signals.installHandler signal handler Nothing\n\n  (_, eitherException) <- waitAnyCatchCancel [pushWorker, queryWorker]\n  case eitherException of\n    Left exc | fromException exc == Just StopWorker -> return ()\n    Left exc -> throwIO exc\n    Right () -> return ()\n\ndata StopWorker = StopWorker\n  deriving (Eq, Show)\n\ninstance Exception StopWorker\n\nqueryLoop :: QueryWorkerState -> Queue -> Push.PushParams IO () -> IO ()\nqueryLoop workerState pushqueue pushParams = do\n  -- this blocks until item is available and doesn\'t remove it from the queue\n  _ <- atomically $ TBQueue.peekTBQueue (queryQueue workerState)\n  (missingStorePathsSet, alreadyQueuedSet) <- Lock.with (lock workerState) $ do\n    storePaths <- atomically $ TBQueue.flushTBQueue (queryQueue workerState)\n    -- if push queue is empty we can our store path cache here as getClosure will do its job\n    alreadyQueuedSet <- atomically $ do\n      isEmpty <- TBQueue.isEmptyTBQueue pushqueue\n      if isEmpty\n        then return S.empty\n        else return $ alreadyQueued workerState\n    missingStorePaths <- Push.getMissingPathsForClosure pushParams storePaths\n    let missingStorePathsSet = S.fromList missingStorePaths\n        uncachedMissingStorePaths = S.difference missingStorePathsSet alreadyQueuedSet\n    atomically $ for_ uncachedMissingStorePaths $ TBQueue.writeTBQueue pushqueue\n    return (missingStorePathsSet, alreadyQueuedSet)\n  queryLoop (workerState {alreadyQueued = S.union missingStorePathsSet alreadyQueuedSet}) pushqueue pushParams\n\n-- | Stop watching the store and push all pending store paths.\nexitOnceQueueIsEmpty :: IO () -> Async () -> Async () -> QueryWorkerState -> PushWorkerState -> IO ()\nexitOnceQueueIsEmpty stopProducerCallback pushWorker queryWorker queryWorkerState pushWorkerState =\n  join . once $ do\n    putTextError "Stopped watching /nix/store and waiting for queue to empty ..."\n\n    -- Skip uploading the remaining paths when run in an interruptible mask to avoid hanging on IO.\n    getMaskingState >>= \\case\n      MaskedUninterruptible -> stopWorkers\n      _ -> do\n        void Systemd.notifyStopping\n        stopProducerCallback\n        go\n  where\n    -- We can safely skip calling the interrupt handler on Nix and\n    -- avoid seeing the generic interrupt message.\n    -- Nix only uses it to cancel file transfers, which we don\'t use.\n    stopWorkers = do\n      cancelWith queryWorker StopWorker\n      cancelWith pushWorker StopWorker\n\n    go = do\n      (isDone, inprogress, queueLength) <- atomically $ do\n        pushQueueLength <- TBQueue.lengthTBQueue $ pushQueue pushWorkerState\n        queryQueueLength <- TBQueue.lengthTBQueue $ queryQueue queryWorkerState\n        inprogress <- readTVar $ inProgress pushWorkerState\n        isLocked <- Lock.locked (lock queryWorkerState)\n        let isDone = pushQueueLength == 0 && queryQueueLength == 0 && inprogress == 0 && not isLocked\n        return (isDone, inprogress, pushQueueLength)\n      if isDone\n        then do\n          stopWorkers\n          putTextError "Done."\n        else do\n          -- extend shutdown for another 90s\n          void $ Systemd.notify False $ "EXTEND_TIMEOUT_USEC=" <> show (90 * 1000 * 1000 :: Int)\n          putTextError $ "Waiting to finish: " <> show inprogress <> " pushing, " <> show queueLength <> " in queue"\n          threadDelay (1000 * 1000)\n          go\n\nputTextError :: Text -> IO ()\nputTextError = hPutStrLn stderr\n'