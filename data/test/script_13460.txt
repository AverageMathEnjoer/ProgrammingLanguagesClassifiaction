b'#include "FileModTree.h"\n#include "AppContext.h"\n#include "../ModInstaller/InstallerDataFormat.h"\n#include "../AssetsTools/InternalAssetsReplacer.h"\n#include "../AssetsTools/InternalBundleReplacer.h"\n#include <algorithm>\n\nVisibleFileEntry::VisibleFileEntry(AppContext &appContext, std::shared_ptr<FileContextInfo> pContextInfo)\n\t\t\t: treeViewEntry(0), pathNull(false)\n{\n\tassert(pContextInfo->getFileContext() != nullptr);\n\n\tthis->pathOrName.assign(pContextInfo->getFileContext()->getFilePath());\n\tthis->fileType = pContextInfo->getFileContext()->getType();\n\tstd::vector<unsigned int> childFileIDs;\n\tpContextInfo->getChildFileIDs(childFileIDs);\n\tswitch (pContextInfo->getFileContext()->getType())\n\t{\n\tcase FileContext_Bundle:\n\t\t{\n\t\t\tstd::unique_ptr<BundleReplacer> bundleReplacer = pContextInfo->makeBundleReplacer(appContext, "", "", 0, false);\n\t\t\tassert(dynamic_cast<BundleEntryModifierFromBundle*>(bundleReplacer.get()) != nullptr);\n\t\t\tif (BundleEntryModifierFromBundle *pBundleModifier = dynamic_cast<BundleEntryModifierFromBundle*>(bundleReplacer.get()))\n\t\t\t{\n\t\t\t\tstruct {\n\t\t\t\t\tstd::shared_ptr<FileContextInfo> pContextInfo;\n\t\t\t\t\tvoid operator()(BundleReplacer *pBundleReplacer) { FreeBundleReplacer(pBundleReplacer); pContextInfo.reset(); }\n\t\t\t\t} replacerOwnerDeleter;\n\t\t\t\tstd::shared_ptr<BundleReplacer> bundleReplacerShared(bundleReplacer.release(), replacerOwnerDeleter);\n\t\t\t\tconstructFromReplacer(appContext, bundleReplacerShared, BundleReplacer_BundleEntryModifierFromBundle);\n\t\t\t\tthis->pathOrName.assign(pContextInfo->getFileContext()->getFilePath());\n\t\t\t\tthis->pContextInfo = std::move(pContextInfo);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase FileContext_Assets:\n\t\tassert(childFileIDs.empty());\n\t\t{\n\t\t\tauto *pAssetsContextInfo = reinterpret_cast<AssetsFileContextInfo*>(pContextInfo.get());\n\t\t\tAssetsFileContext *pAssetsContext = pAssetsContextInfo->getAssetsFileContext();\n\t\t\tauto replacersVec = pAssetsContextInfo->getAllReplacers();\n\n\t\t\tstd::sort(replacersVec.begin(), replacersVec.end(),\n\t\t\t\t[](const std::shared_ptr<AssetsReplacer>& a, const std::shared_ptr<AssetsReplacer>& b) {\n\t\t\t\t\tbool aIsEntryModifier = (a->GetType() == AssetsReplacement_AddOrModify || a->GetType() == AssetsReplacement_Remove);\n\t\t\t\t\tbool bIsEntryModifier = (b->GetType() == AssetsReplacement_AddOrModify || b->GetType() == AssetsReplacement_Remove);\n\t\t\t\t\tif (!aIsEntryModifier && bIsEntryModifier)\n\t\t\t\t\t\treturn true; //Put non-entry modifiers before entry modifiers.\n\t\t\t\t\telse if (!aIsEntryModifier || !bIsEntryModifier)\n\t\t\t\t\t\treturn false; //No particular order between non-entry modifiers.\n\t\t\t\t\treturn reinterpret_cast<AssetsEntryReplacer*>(a.get())->GetPathID()\n\t\t\t\t\t\t< reinterpret_cast<AssetsEntryReplacer*>(b.get())->GetPathID();\n\t\t\t\t});\n\n\t\t\treplacers.resize(replacersVec.size());\n\t\t\tfor (size_t i = 0; i < replacersVec.size(); ++i)\n\t\t\t\treplacers[i].pReplacer = std::move(replacersVec[i]);\n\t\t}\n\t\tbreak;\n\tcase FileContext_Resources:\n\t\tassert(childFileIDs.empty());\n\t\t{\n\t\t\tstd::unique_ptr<BundleReplacer> bundleReplacer = pContextInfo->makeBundleReplacer(appContext, "", "", (uint32_t)-1, false);\n\t\t\tassert(dynamic_cast<BundleEntryModifierByResources*>(bundleReplacer.get()) != nullptr);\n\t\t\tif (BundleEntryModifierByResources* pBundleModifier = dynamic_cast<BundleEntryModifierByResources*>(bundleReplacer.get()))\n\t\t\t{\n\t\t\t\treplacers.resize(1);\n\t\t\t\treplacers[0].pReplacer.reset(bundleReplacer.release());\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tthrow std::invalid_argument("VisibleFileEntry: Bundle replacer generated from a ResourcesFileContextInfo is null or has an unexpected type!");\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase FileContext_Generic:\n\t\tassert(childFileIDs.empty());\n\t\tthrow std::domain_error("VisibleFileEntry: FileContext_Generic is not supported as a base file!");\n\t\tbreak;\n\tdefault:\n\t\tthrow std::domain_error("VisibleFileEntry constructed with an unknown file type!");\n\t}\n\tthis->pContextInfo = std::move(pContextInfo);\n}\n//shared_ptr<BundleReplacer> deleter that keeps a shared_ptr reference\n// on a parent BundleEntryModifierFromBundle or BundleEntryModifierFromAssets,\n// which in turn frees all child replacers on destruction.\nstruct GenericReplacerOwnershipWrapper\n{\n\tstd::shared_ptr<GenericReplacer> memoryOwner;\n\tGenericReplacerOwnershipWrapper(std::shared_ptr<GenericReplacer> owner)\n\t\t: memoryOwner(std::move(owner)) {}\n\tvoid operator()(GenericReplacer* pReplacer) {memoryOwner.reset();}\n};\n//Generate a VisibleFileEntry from a BundleEntryModifierFromAssets, BundleEntryModifierFromBundle or BundleEntryModifierByResources.\n//-> type: EBundleReplacers (InternalBundleReplacer.h)\nVisibleFileEntry::VisibleFileEntry(class AppContext &appContext, std::shared_ptr<BundleReplacer> &fromReplacer, unsigned int type)\n\t\t\t: treeViewEntry(0), pathNull(true)\n{\n\tconstructFromReplacer(appContext, fromReplacer, type);\n}\nvoid VisibleFileEntry::constructFromReplacer(class AppContext &appContext, std::shared_ptr<BundleReplacer> &fromReplacer, unsigned int type)\n{\n\tconst char *_origEntryName = fromReplacer->GetOriginalEntryName();\n\tthis->pathOrName = (_origEntryName == nullptr) ? "" : _origEntryName;\n\tthis->pathNull = (_origEntryName == nullptr);\n\tconst char *_newEntryName = fromReplacer->GetEntryName();\n\tthis->newName = (_newEntryName == nullptr) ? "" : _newEntryName;\n\tswitch ((EBundleReplacers)type)\n\t{\n\tcase BundleReplacer_BundleEntryModifierFromAssets:\n\t\t{\n\t\t\tthis->fileType = FileContext_Assets;\n\t\t\tBundleEntryModifierFromAssets *pAssetsFileReplacer = reinterpret_cast<BundleEntryModifierFromAssets*>(fromReplacer.get());\n\t\t\tsize_t nReplacers = 0;\n\t\t\tAssetsReplacer **ppReplacers = pAssetsFileReplacer->GetReplacers(nReplacers);\n\t\t\tthis->replacers.resize(nReplacers);\n\t\t\tfor (size_t i = 0; i < nReplacers; ++i)\n\t\t\t\tthis->replacers[i].pReplacer = std::shared_ptr<AssetsReplacer>(ppReplacers[i], GenericReplacerOwnershipWrapper(fromReplacer));\n\t\t}\n\t\tbreak;\n\tcase BundleReplacer_BundleEntryModifierFromBundle:\n\t\t{\n\t\t\tthis->fileType = FileContext_Bundle;\n\t\t\tBundleEntryModifierFromBundle *pBundleFileReplacer = reinterpret_cast<BundleEntryModifierFromBundle*>(fromReplacer.get());\n\t\t\tsize_t nReplacers = 0;\n\t\t\tBundleReplacer **ppReplacers = pBundleFileReplacer->GetReplacers(nReplacers);\n\t\t\tfor (size_t i = 0; i < nReplacers; ++i)\n\t\t\t{\n\t\t\t\tauto pChildReplacer = std::shared_ptr<BundleReplacer>(ppReplacers[i], GenericReplacerOwnershipWrapper(fromReplacer));\n\t\t\t\tif (ppReplacers[i]->GetType() == BundleReplacement_AddOrModify)\n\t\t\t\t{\n\t\t\t\t\tif (dynamic_cast<BundleEntryModifierFromAssets*>(ppReplacers[i]) != nullptr)\n\t\t\t\t\t{\n\t\t\t\t\t\tBundleEntryModifierFromAssets* pBundleModifierFromAssets = reinterpret_cast<BundleEntryModifierFromAssets*>(ppReplacers[i]);\n\t\t\t\t\t\tuint32_t subFileID = pBundleModifierFromAssets->GetFileID();\n\t\t\t\t\t\tthis->subFiles.push_back(VisibleFileEntry(appContext, pChildReplacer, BundleReplacer_BundleEntryModifierFromAssets));\n\t\t\t\t\t\tif (subFileID != (uint32_t)-1)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tFileContextInfo_ptr pChildContextInfo = appContext.getContextInfo(subFileID);\n\t\t\t\t\t\t\tif (pChildContextInfo != nullptr)\n\t\t\t\t\t\t\t\tthis->subFiles.back().pContextInfo = pChildContextInfo;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse if (dynamic_cast<BundleEntryModifierFromBundle*>(ppReplacers[i]) != nullptr)\n\t\t\t\t\t{\n\t\t\t\t\t\tthis->subFiles.push_back(VisibleFileEntry(appContext, pChildReplacer, BundleReplacer_BundleEntryModifierFromBundle));\n\t\t\t\t\t}\n\t\t\t\t\telse if (dynamic_cast<BundleEntryModifierByResources*>(ppReplacers[i]) != nullptr\n\t\t\t\t\t\t&& ppReplacers[i]->RequiresEntryReader())\n\t\t\t\t\t{\n\t\t\t\t\t\t//This resources replacer is based on an existing bundle entry, i.e. requires the original file reader to work.\n\t\t\t\t\t\t// If !ppReplacers[i]->RequiresEntryReader(), the file may not exist (but it could, e.g. if all resources are replaced).\n\t\t\t\t\t\tthis->subFiles.push_back(VisibleFileEntry(appContext, pChildReplacer, BundleReplacer_BundleEntryModifierByResources));\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t\tthis->replacers.push_back(VisibleReplacerEntry(pChildReplacer));\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tthis->replacers.push_back(VisibleReplacerEntry(pChildReplacer));\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase BundleReplacer_BundleEntryModifierByResources:\n\t\t{\n\t\t\t//Modified resource files just store the bundle replacer inside.\n\t\t\t//-> Top-level resource files have a bundle replacer with empty names.\n\t\t\tthis->fileType = FileContext_Resources;\n\t\t\t//BundleEntryModifierByResources* pResourcesReplacer = reinterpret_cast<BundleEntryModifierByResources*>(fromReplacer.get());\n\t\t\tthis->replacers.resize(1);\n\t\t\tthis->replacers[0].pReplacer = fromReplacer;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tthrow std::domain_error("VisibleFileEntry constructed with an unknown/unsupported replacer type!");\n\t}\n}\nVisibleFileEntry::VisibleFileEntry(class AppContext &appContext, InstallerPackageAssetsDesc &installerPackageDesc)\n\t\t\t: treeViewEntry(0), pathNull(false)\n{\n\tthis->pathOrName.assign(installerPackageDesc.path);\n\tswitch (installerPackageDesc.type)\n\t{\n\t\tcase InstallerPackageAssetsType::Assets:\n\t\t{\n\t\t\tthis->fileType = FileContext_Assets;\n\t\t\tthis->replacers.resize(installerPackageDesc.replacers.size());\n\t\t\tfor (size_t i = 0; i < installerPackageDesc.replacers.size(); ++i)\n\t\t\t\tthis->replacers[i].pReplacer = installerPackageDesc.replacers[i];\n\t\t}\n\t\tbreak;\n\t\tcase InstallerPackageAssetsType::Bundle:\n\t\t{\n\t\t\tthis->fileType = FileContext_Bundle;\n\t\t\tfor (size_t i = 0; i < installerPackageDesc.replacers.size(); ++i)\n\t\t\t{\n\t\t\t\tstd::shared_ptr<BundleReplacer> pReplacer = std::reinterpret_pointer_cast<BundleReplacer>(installerPackageDesc.replacers[i]);\n\t\t\t\tif (pReplacer->GetType() == BundleReplacement_AddOrModify)\n\t\t\t\t{\n\t\t\t\t\tif (dynamic_cast<BundleEntryModifierFromAssets*>(pReplacer.get()) != nullptr)\n\t\t\t\t\t{\n\t\t\t\t\t\tthis->subFiles.push_back(VisibleFileEntry(appContext, pReplacer, BundleReplacer_BundleEntryModifierFromAssets));\n\t\t\t\t\t}\n\t\t\t\t\telse if (dynamic_cast<BundleEntryModifierFromBundle*>(pReplacer.get()) != nullptr)\n\t\t\t\t\t{\n\t\t\t\t\t\tthis->subFiles.push_back(VisibleFileEntry(appContext, pReplacer, BundleReplacer_BundleEntryModifierFromBundle));\n\t\t\t\t\t}\n\t\t\t\t\telse if (dynamic_cast<BundleEntryModifierByResources*>(pReplacer.get()) != nullptr\n\t\t\t\t\t\t&& pReplacer->RequiresEntryReader())\n\t\t\t\t\t{\n\t\t\t\t\t\tthis->subFiles.push_back(VisibleFileEntry(appContext, pReplacer, BundleReplacer_BundleEntryModifierByResources));\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t\tthis->replacers.push_back(VisibleReplacerEntry(std::move(pReplacer)));\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tthis->replacers.push_back(VisibleReplacerEntry(std::move(pReplacer)));\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t\tcase InstallerPackageAssetsType::Resources:\n\t\t{\n\t\t\tthis->fileType = FileContext_Resources;\n\t\t\tif (installerPackageDesc.replacers.size() != 1\n\t\t\t\t|| dynamic_cast<BundleEntryModifierByResources*>(installerPackageDesc.replacers[0].get()) == nullptr)\n\t\t\t{\n\t\t\t\tthrow std::invalid_argument("VisibleFileEntry: Resources installer package entry does not consist of a singular resources bundle replacer!");\n\t\t\t}\n\t\t\tthis->replacers.resize(1);\n\t\t\tthis->replacers[0].pReplacer = installerPackageDesc.replacers[0];\n\t\t}\n\t\tbreak;\n\t\tdefault:\n\t\t\tthrow std::domain_error("VisibleFileEntry constructed with an unknown/unsupported installer package entry type!");\n\t}\n}\n\nstd::shared_ptr<BundleReplacer> VisibleFileEntry::produceBundleReplacer()\n{\n\tstruct {\n\t\tstd::vector<std::shared_ptr<GenericReplacer>> subOwnerships;\n\t\tvoid operator()(AssetsReplacer *del)\n\t\t{\n\t\t\tFreeAssetsReplacer(del);\n\t\t\tsubOwnerships.clear();\n\t\t}\n\t\tvoid operator()(BundleReplacer *del)\n\t\t{\n\t\t\tFreeBundleReplacer(del);\n\t\t\tsubOwnerships.clear();\n\t\t}\n\t} bundleModifierDeleter;\n\tswitch (this->fileType)\n\t{\n\tcase FileContext_Bundle:\n\t\t{\n\t\t\tstd::vector<BundleReplacer*> childReplacers;\n\t\t\tfor (size_t i = 0; i < this->replacers.size(); ++i)\n\t\t\t{\n\t\t\t\tbundleModifierDeleter.subOwnerships.push_back(this->replacers[i].pReplacer);\n\t\t\t\tchildReplacers.push_back(reinterpret_cast<BundleReplacer*>(this->replacers[i].pReplacer.get()));\n\t\t\t}\n\t\t\tfor (size_t i = 0; i < this->subFiles.size(); ++i)\n\t\t\t{\n\t\t\t\tstd::shared_ptr<BundleReplacer> pChildReplacer = this->subFiles[i].produceBundleReplacer();\n\t\t\t\tchildReplacers.push_back(pChildReplacer.get());\n\t\t\t\tbundleModifierDeleter.subOwnerships.push_back(std::move(pChildReplacer));\n\t\t\t}\n\t\t\treturn std::shared_ptr<BundleReplacer>(\n\t\t\t\tMakeBundleEntryModifierFromBundle(this->pathNull ? nullptr : this->pathOrName.c_str(),\n\t\t\t\t    this->newName.c_str(), childReplacers.data(), childReplacers.size(),\n\t\t\t\t\t(unsigned int)-1), bundleModifierDeleter);\n\t\t}\n\t\tbreak;\n\tcase FileContext_Assets:\n\t\t{\n\t\t\tstd::vector<AssetsReplacer*> childReplacers;\n\t\t\tfor (size_t i = 0; i < this->replacers.size(); ++i)\n\t\t\t{\n\t\t\t\tbundleModifierDeleter.subOwnerships.push_back(this->replacers[i].pReplacer);\n\t\t\t\tchildReplacers.push_back(reinterpret_cast<AssetsReplacer*>(this->replacers[i].pReplacer.get()));\n\t\t\t}\n\t\t\treturn std::shared_ptr<BundleReplacer>(\n\t\t\t\tMakeBundleEntryModifierFromAssets(this->pathNull ? nullptr : this->pathOrName.c_str(),\n\t\t\t\t    this->newName.c_str(), nullptr,\n\t\t\t\t\tchildReplacers.data(), childReplacers.size(), 0), bundleModifierDeleter);\n\t\t}\n\t\tbreak;\n\tcase FileContext_Resources:\n\t\t{\n\t\t\tif (this->replacers.size() != 1\n\t\t\t\t|| dynamic_cast<BundleEntryModifierByResources*>(this->replacers[0].pReplacer.get()) == nullptr)\n\t\t\t{\n\t\t\t\tthrow std::invalid_argument("VisibleFileEntry: Resources file entry does not consist of a singular resources bundle replacer!");\n\t\t\t}\n\t\t\treturn std::reinterpret_pointer_cast<BundleReplacer>(this->replacers[0].pReplacer);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tthrow std::domain_error("VisibleFileEntry::produceBundleReplacer - unsupported file type!");\n\t}\n}\n\n'