b'#include "stdafx.h"\n#include "AssetBundleFileFormat.h"\n#include "AssetsFileReader.h"\n#include "AssetsFileFormat.h"\n#include "../inc/LZMA/LzmaDec.h"\n#include "../inc/LZMA/LzmaEnc.h"\n#include "../libCompression/lz4.h"\n#include "../libCompression/lz4dec.h"\n#include "../libCompression/lz4enc.h"\n#include <assert.h>\n#include <unordered_map>\n#include <future>\n\nASSETSTOOLS_API bool AssetBundleBlockAndDirectoryList06::Read(QWORD filePos, IAssetsReader *pReader, AssetsFileVerifyLogger errorLogger)\n{\n\t/*uint8_t *dataBuf = (uint8_t*)malloc(sizeComp);\n\tif (!dataBuf)\n\t\tgoto __goto_allocerror;\n\tif (!reader(filePos, sizeComp, dataBuf, lPar))\n\t\tgoto __goto_readerror;\n\tswitch (compressionType)\n\t{\n\tcase 2:\n\tcase 3:\n\t\t//LZ4\n\t\tuint8_t *outBuf = (uint8_t*)malloc(sizeUncomp);\n\t\tif (!outBuf)\n\t\t\tgoto __goto_allocerror;\n\t\tif (LZ4_decompress_safe((char*)dataBuf, (char*)outBuf, (int)sizeComp & 0x7FFFFFFF, (int)sizeUncomp & 0x7FFFFFFF) != sizeUncomp)\n\t\t{\n\t\t\tfree(dataBuf);\n\t\t\tfree(outBuf);\n\t\t\tgoto __goto_decomperror;\n\t\t}\n\t\tfree(dataBuf);\n\t\tdataBuf = outBuf;\n\t\tbreak;\n\tcase 1:\n\t\t//LZMA\n\t\t//maybe support this, maybe don\'t (reading this structure isn\'t really required in our case if the bundle is compressed)\n\t\tfree(dataBuf);\n\t\treturn false;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}*/\n\tif (!pReader->Read(filePos, 8, &this->checksumLow))\n\t\tgoto __goto_readerror;\n\tfilePos += 8;\n\tif (!pReader->Read(-1, 8, &this->checksumHigh))\n\t\tgoto __goto_readerror;\n\tfilePos += 8;\n\n\tif (!pReader->Read(-1, 4, &this->blockCount))\n\t\tgoto __goto_readerror;\n\tfilePos += 4;\n\tSwapEndians_(this->blockCount);\n\tblockInf = (AssetBundleBlockInfo06*)malloc(this->blockCount * sizeof(AssetBundleBlockInfo06));\n\tif (!blockInf)\n\t\tgoto __goto_allocerror;\n\tfor (uint32_t i = 0; i < this->blockCount; i++)\n\t{\n\t\tif (!pReader->Read(-1, 4, &blockInf[i].decompressedSize))\n\t\t\tgoto __goto_readerror;\n\t\tSwapEndians_(blockInf[i].decompressedSize);\n\t\tif (!pReader->Read(-1, 4, &blockInf[i].compressedSize))\n\t\t\tgoto __goto_readerror;\n\t\tSwapEndians_(blockInf[i].compressedSize);\n\t\tif (!pReader->Read(-1, 2, &blockInf[i].flags))\n\t\t\tgoto __goto_readerror;\n\t\tSwapEndians_(blockInf[i].flags);\n\t\tfilePos += 10;\n\t}\n\n\tif (!pReader->Read(-1, 4, &this->directoryCount))\n\t\tgoto __goto_readerror;\n\tfilePos += 4;\n\tSwapEndians_(this->directoryCount);\n\tdirInf = (AssetBundleDirectoryInfo06*)malloc(this->directoryCount * sizeof(AssetBundleDirectoryInfo06));\n\tif (!dirInf)\n\t\tgoto __goto_allocerror;\n\tfor (uint32_t i = 0; i < this->directoryCount; i++)\n\t{\n\t\tif (!pReader->Read(-1, 8, &dirInf[i].offset))\n\t\t\tgoto __goto_readerror;\n\t\tSwapEndians_(dirInf[i].offset);\n\t\tif (!pReader->Read(-1, 8, &dirInf[i].decompressedSize))\n\t\t\tgoto __goto_readerror;\n\t\tSwapEndians_(dirInf[i].decompressedSize);\n\t\tif (!pReader->Read(-1, 4, &dirInf[i].flags))\n\t\t\tgoto __goto_readerror;\n\t\tSwapEndians_(dirInf[i].flags);\n\t\tfilePos += 20;\n\n\t\tchar nameBuffer[40];\n\t\tbool eosFound = false; size_t strLen = 0;\n\t\twhile (!eosFound)\n\t\t{\n\t\t\tQWORD nRead = pReader->Read(-1, 40, &nameBuffer);\n\t\t\tif (!nRead)\n\t\t\t\tgoto __goto_readerror;\n\t\t\tfor (size_t i = 0; i < (size_t)nRead; i++)\n\t\t\t{\n\t\t\t\tif (nameBuffer[i] == 0)\n\t\t\t\t{\n\t\t\t\t\teosFound = true;\n\t\t\t\t\tstrLen += (i+1);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!eosFound)\n\t\t\t\tstrLen += (size_t)nRead;\n\t\t}\n\t\tdirInf[i].name = (char*)malloc(strLen);\n\t\tif (dirInf[i].name == NULL)\n\t\t\tgoto __goto_allocerror;\n\t\tif (pReader->Read(filePos, strLen, const_cast<char*>(dirInf[i].name)) != strLen)\n\t\t\tgoto __goto_readerror;\n\t\tconst_cast<char*>(dirInf[i].name)[strLen-1] = 0;\n\t\tfilePos += strLen;\n\t}\n\treturn true;\n\t__goto_allocerror:\n\tif (errorLogger) errorLogger("AssetBundleBlockAndDirectoryList06 : Out of memory!");\n\treturn false;\n\t__goto_readerror:\n\tif (errorLogger) errorLogger("AssetBundleBlockAndDirectoryList06 : A file read error occured!");\n\treturn false;\n\t/*__goto_decomperror:\n\tif (errorLogger) errorLogger("AssetBundleBlockAndDirectoryList06 : A decompress error occured!");\n\treturn false;*/\n}\nASSETSTOOLS_API void AssetBundleBlockAndDirectoryList06::Free()\n{\n\tif (this->blockInf)\n\t\tfree(this->blockInf);\n\tif (this->dirInf)\n\t{\n\t\tfor (uint32_t i = 0; i < this->directoryCount; i++)\n\t\t{\n\t\t\tif (this->dirInf[i].name)\n\t\t\t\tfree(const_cast<char*>(this->dirInf[i].name));\n\t\t}\n\t\tfree(this->dirInf);\n\t}\n\tmemset(this, 0, sizeof(AssetBundleBlockAndDirectoryList06));\n}\n//Write doesn\'t compress\nASSETSTOOLS_API bool AssetBundleBlockAndDirectoryList06::Write(IAssetsWriter *pWriter, QWORD &curFilePos, AssetsFileVerifyLogger errorLogger)\n{\n\tuint32_t dwTmp;\n\tif (!pWriter->Write(curFilePos, 8, &this->checksumLow))\n\t\tgoto __goto_writeerror;\n\tcurFilePos += 8;\n\tif (!pWriter->Write(-1, 8, &this->checksumHigh))\n\t\tgoto __goto_writeerror;\n\tcurFilePos += 8;\n\n\tdwTmp = SwapEndians(this->blockCount);\n\tif (!pWriter->Write(-1, 4, &dwTmp))\n\t\tgoto __goto_writeerror;\n\tcurFilePos += 4;\n\tfor (uint32_t i = 0; i < this->blockCount; i++)\n\t{\n\t\tdwTmp = SwapEndians(this->blockInf[i].decompressedSize);\n\t\tif (!pWriter->Write(-1, 4, &dwTmp))\n\t\t\tgoto __goto_writeerror;\n\t\tcurFilePos += 4;\n\t\tdwTmp = SwapEndians(this->blockInf[i].compressedSize);\n\t\tif (!pWriter->Write(-1, 4, &dwTmp))\n\t\t\tgoto __goto_writeerror;\n\t\tcurFilePos += 4;\n\t\tuint16_t wTmp = SwapEndians(this->blockInf[i].flags);\n\t\tif (!pWriter->Write(-1, 2, &wTmp))\n\t\t\tgoto __goto_writeerror;\n\t\tcurFilePos += 2;\n\t}\n\n\tdwTmp = SwapEndians(this->directoryCount);\n\tif (!pWriter->Write(-1, 4, &dwTmp))\n\t\tgoto __goto_writeerror;\n\tcurFilePos += 4;\n\t\n\tfor (uint32_t i = 0; i < this->directoryCount; i++)\n\t{\n\t\tQWORD qwTmp = SwapEndians(this->dirInf[i].offset);\n\t\tif (!pWriter->Write(-1, 8, &qwTmp))\n\t\t\tgoto __goto_writeerror;\n\t\tcurFilePos += 8;\n\t\tqwTmp = SwapEndians(this->dirInf[i].decompressedSize);\n\t\tif (!pWriter->Write(-1, 8, &qwTmp))\n\t\t\tgoto __goto_writeerror;\n\t\tcurFilePos += 8;\n\t\tdwTmp = SwapEndians(this->dirInf[i].flags);\n\t\tif (!pWriter->Write(-1, 4, &dwTmp))\n\t\t\tgoto __goto_writeerror;\n\t\tcurFilePos += 4;\n\n\t\tsize_t curStrLen = strlen(this->dirInf[i].name)+1;\n\t\tcurFilePos += curStrLen;\n\t\tif (!pWriter->Write(-1, curStrLen, this->dirInf[i].name))\n\t\t\tgoto __goto_writeerror;\n\t}\n\n\treturn true;\n\t__goto_writeerror:\n\tif (errorLogger) errorLogger("AssetBundleHeader06 : A file write error occured!");\n\treturn false;\n}\nASSETSTOOLS_API bool AssetBundleHeader06::ReadInitial(IAssetsReader *pReader, AssetsFileVerifyLogger errorLogger)\n{\n\tQWORD curFilePos = 0;\n\tchar curChar;\n\tfor (unsigned int i = 0;; i++)\n\t{\n\t\tif (!pReader->Read(curFilePos, 1, &curChar))\n\t\t\tgoto __goto_readerror;\n\t\tcurFilePos++;\n\t\tif (i < 13) signature[i] = curChar;\n\t\tif (curChar == 0) break;\n\t}\n\tsignature[12] = 0;\n\t\n\tif (!strcmp(signature, "UnityArchive"))\n\t\tthis->fileVersion = 6;\n\telse\n\t{\n\t\tif (!pReader->Read(-1, 4, &this->fileVersion))\n\t\t\tgoto __goto_readerror;\n\t\tSwapEndians_(this->fileVersion);\n\t}\n\n\treturn true;\n\t__goto_readerror:\n\tif (errorLogger) errorLogger("AssetBundleHeader06 : A file read error occured!");\n\treturn false;\n}\nASSETSTOOLS_API bool AssetBundleHeader06::Read(IAssetsReader *pReader, AssetsFileVerifyLogger errorLogger)\n{\n\tQWORD curPos = 0;\n\tchar curChar;\n\tfor (unsigned int i = 0;; i++)\n\t{\n\t\tif (!pReader->Read(curPos, 1, &curChar))\n\t\t\tgoto __goto_readerror;\n\t\tcurPos++;\n\t\tif (i < 13) signature[i] = curChar;\n\t\tif (curChar == 0) break;\n\t}\n\tsignature[12] = 0;\n\t\n\tif (!strcmp(signature, "UnityArchive"))\n\t\tthis->fileVersion = 6;\n\telse\n\t{\n\t\tif (!pReader->Read(-1, 4, &this->fileVersion))\n\t\t\tgoto __goto_readerror;\n\t\tSwapEndians_(this->fileVersion);\n\t\tif (this->fileVersion != 6 && this->fileVersion != 7)\n\t\t{\n\t\t\tif (errorLogger) errorLogger("That file version is unknown!");\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tfor (unsigned int i = 0;; i++)\n\t{\n\t\tif (!pReader->Read(-1, 1, &curChar))\n\t\t\tgoto __goto_readerror;\n\t\tif (i < sizeof(minPlayerVersion)) minPlayerVersion[i] = curChar;\n\t\tif (curChar == 0) break;\n\t}\n\tminPlayerVersion[sizeof(minPlayerVersion) - 1] = 0;\n\n\tfor (unsigned int i = 0;; i++)\n\t{\n\t\tif (!pReader->Read(-1, 1, &curChar))\n\t\t\tgoto __goto_readerror;\n\t\tif (i < sizeof(fileEngineVersion)) fileEngineVersion[i] = curChar;\n\t\tif (curChar == 0) break;\n\t}\n\tfileEngineVersion[sizeof(fileEngineVersion) - 1] = 0;\n\t\n\tif (!pReader->Read(-1, 8, &this->totalFileSize))\n\t\tgoto __goto_readerror;\n\tSwapEndians_(this->totalFileSize);\n\t\n\tif (!pReader->Read(-1, 4, &this->compressedSize))\n\t\tgoto __goto_readerror;\n\tSwapEndians_(this->compressedSize);\n\tif (!pReader->Read(-1, 4, &this->decompressedSize))\n\t\tgoto __goto_readerror;\n\tSwapEndians_(this->decompressedSize);\n\n\tif (!pReader->Read(-1, 4, &this->flags))\n\t\tgoto __goto_readerror;\n\tSwapEndians_(this->flags);\n\t\n\treturn true;\n\t__goto_readerror:\n\tif (errorLogger) errorLogger("AssetBundleHeader06 : A file read error occured!");\n\treturn false;\n}\nASSETSTOOLS_API bool AssetBundleHeader06::Write(IAssetsWriter *pWriter, QWORD &curFilePos, AssetsFileVerifyLogger errorLogger)\n{\n\tuint32_t dwTmp;\n\tQWORD qwTmp;\n\tQWORD startPos = curFilePos;\n\tsize_t curStrLen = strlen(this->signature)+1;\n\tif (!pWriter->Write(curFilePos, curStrLen, &this->signature))\n\t\tgoto __goto_writeerror;\n\tcurFilePos += curStrLen;\n\n\tdwTmp = SwapEndians(this->fileVersion);\n\tif (!pWriter->Write(-1, 4, &dwTmp))\n\t\tgoto __goto_writeerror;\n\tcurFilePos += 4;\n\n\tcurStrLen = strlen(this->minPlayerVersion)+1;\n\tcurFilePos += curStrLen;\n\tif (!pWriter->Write(-1, curStrLen, &this->minPlayerVersion))\n\t\tgoto __goto_writeerror;\n\n\tcurStrLen = strlen(this->fileEngineVersion)+1;\n\tcurFilePos += curStrLen;\n\tif (!pWriter->Write(-1, curStrLen, &this->fileEngineVersion))\n\t\tgoto __goto_writeerror;\n\n\tqwTmp = SwapEndians(this->totalFileSize);\n\tif (!pWriter->Write(-1, 8, &qwTmp))\n\t\tgoto __goto_writeerror;\n\tcurFilePos += 8;\n\n\tdwTmp = SwapEndians(this->compressedSize);\n\tif (!pWriter->Write(-1, 4, &dwTmp))\n\t\tgoto __goto_writeerror;\n\tcurFilePos += 4;\n\n\tdwTmp = SwapEndians(this->decompressedSize);\n\tif (!pWriter->Write(-1, 4, &dwTmp))\n\t\tgoto __goto_writeerror;\n\tcurFilePos += 4;\n\n\tdwTmp = SwapEndians(this->flags);\n\tif (!pWriter->Write(-1, 4, &dwTmp))\n\t\tgoto __goto_writeerror;\n\tcurFilePos += 4;\n\n\tif (!strcmp(signature, "UnityWeb") || !strcmp(signature, "UnityRaw"))\n\t{\n\t\tdwTmp = 0;\n\t\tif (!pWriter->Write(-1, 1, &dwTmp))\n\t\t\tgoto __goto_writeerror;\n\t\tcurFilePos ++;\n\t}\n\tif (this->fileVersion >= 7)\n\t{\n\t\tQWORD alignmentLen = (((curFilePos - startPos) + 15) & ~15) - (curFilePos - startPos);\n\t\tuint64_t alignment[2] = {0,0};\n\t\tif (!pWriter->Write(-1, alignmentLen, &alignment[0]))\n\t\t\tgoto __goto_writeerror;\n\t\tcurFilePos += alignmentLen;\n\t}\n\n\treturn true;\n\t__goto_writeerror:\n\tif (errorLogger) errorLogger("AssetBundleHeader06 : A file write error occured!");\n\treturn false;\n}\n\nASSETSTOOLS_API bool AssetBundleHeader03::Read(IAssetsReader *pReader, AssetsFileVerifyLogger errorLogger)\n{\n\tif (!pReader->Read(0, 9, &this->signature))\n\t\tgoto __goto_readerror;\n\tif (_strnicmp(this->signature, "UnityRaw", 9) && _strnicmp(this->signature, "UnityWeb", 9))\n\t{\n\t\t/*if (!_strnicmp(this->signature, "UnityWeb", 9))\n\t\t{\n\t\t\tif (errorLogger) errorLogger("AssetBundleHeader : I can\'t decompress compressed files!");\n\t\t\treturn false;\n\t\t}*/\n\t\tif (errorLogger) errorLogger("AssetBundleHeader : Unknown file type!");\n\t\treturn false;\n\t}\n\n\tif (!pReader->Read(-1, 4, &this->fileVersion))\n\t\tgoto __goto_readerror;\n\tSwapEndians_(this->fileVersion);\n\tif (this->fileVersion != 3)\n\t{\n\t\tif (errorLogger) errorLogger("AssetBundleHeader : Either that file is invalid or it uses an unknown file version!");\n\t\treturn false;\n\t}\n\n\tchar curChar;\n\tfor (unsigned int i = 0;; i++)\n\t{\n\t\tif (!pReader->Read(-1, 1, &curChar))\n\t\t\tgoto __goto_readerror;\n\t\tif (i < sizeof(minPlayerVersion)) minPlayerVersion[i] = curChar;\n\t\tif (curChar == 0) break;\n\t}\n\tminPlayerVersion[sizeof(minPlayerVersion)-1] = 0;\n\n\tfor (unsigned int i = 0;; i++)\n\t{\n\t\tif (!pReader->Read(-1, 1, &curChar))\n\t\t\tgoto __goto_readerror;\n\t\tif (i < sizeof(fileEngineVersion)) fileEngineVersion[i] = curChar;\n\t\tif (curChar == 0) break;\n\t}\n\tfileEngineVersion[sizeof(fileEngineVersion)-1] = 0;\n\n\tif (!pReader->Read(-1, 4, &this->minimumStreamedBytes))\n\t\tgoto __goto_readerror;\n\tSwapEndians_(this->minimumStreamedBytes);\n\tif (!pReader->Read(-1, 4, &this->bundleDataOffs))\n\t\tgoto __goto_readerror;\n\tSwapEndians_(this->bundleDataOffs);\n\tif (!pReader->Read(-1, 4, &this->numberOfAssetsToDownload))\n\t\tgoto __goto_readerror;\n\tSwapEndians_(this->numberOfAssetsToDownload);\n\tif (!pReader->Read(-1, 4, &this->blockCount))\n\t\tgoto __goto_readerror;\n\tSwapEndians_(this->blockCount);\n\tif (this->pBlockList != NULL) free(this->pBlockList);\n\tthis->pBlockList = (AssetBundleOffsetPair*)malloc(sizeof(AssetBundleOffsetPair) * blockCount);\n\tif (this->pBlockList == NULL) //out of memory\n\t\tgoto __goto_outofmemory;\n\tfor (uint32_t i = 0; i < blockCount; i++)\n\t{\n\t\tif (!pReader->Read(-1, 4, &this->pBlockList[i].compressed))\n\t\t\tgoto __goto_readerror;\n\t\tthis->pBlockList[i].compressed = SwapEndians(this->pBlockList[i].compressed);\n\t\tif (!pReader->Read(-1, 4, &this->pBlockList[i].uncompressed))\n\t\t\tgoto __goto_readerror;\n\t\tthis->pBlockList[i].uncompressed = SwapEndians(this->pBlockList[i].uncompressed);\n\t}\n\tif (this->fileVersion >= 2)\n\t{\n\t\tif (!pReader->Read(-1, 4, &this->fileSize2))\n\t\t\tgoto __goto_readerror;\n\t\tSwapEndians_(this->fileSize2);\n\t}\n\tif (this->fileVersion >= 3)\n\t{\n\t\tif (!pReader->Read(-1, 4, &this->unknown2))\n\t\t\tgoto __goto_readerror;\n\t\tthis->unknown2 = SwapEndians(this->unknown2);\n\t}\n\tif (!pReader->Read(-1, 1, &this->unknown3))\n\t\tgoto __goto_readerror;\n\treturn true;\n\n\t__goto_readerror:\n\tif (errorLogger) errorLogger("AssetBundleHeader : A file read error occured!");\n\treturn false;\n\n\t__goto_outofmemory:\n\tif (errorLogger) errorLogger("AssetBundleHeader : Out of memory!");\n\treturn false;\n}\nASSETSTOOLS_API bool AssetBundleHeader03::Write(IAssetsWriter *pWriter, QWORD &curFilePos, AssetsFileVerifyLogger errorLogger)\n{\n\tuint32_t dwTmp;\n\tsize_t curStrLen;\n\tif (!pWriter->Write(curFilePos, 9, &this->signature))\n\t\tgoto __goto_writeerror;\n\tcurFilePos += 9;\n\tdwTmp = SwapEndians(this->fileVersion);\n\tif (!pWriter->Write(-1, 4, &dwTmp))\n\t\tgoto __goto_writeerror;\n\tcurFilePos += 4;\n\n\tcurStrLen = strlen(this->minPlayerVersion)+1;\n\tcurFilePos += curStrLen;\n\tif (!pWriter->Write(-1, curStrLen, &this->minPlayerVersion))\n\t\tgoto __goto_writeerror;\n\tcurFilePos += curStrLen;\n\tcurStrLen = strlen(this->fileEngineVersion)+1;\n\tif (!pWriter->Write(-1, curStrLen, &this->fileEngineVersion))\n\t\tgoto __goto_writeerror;\n\n\tdwTmp = SwapEndians(this->minimumStreamedBytes);\n\tif (!pWriter->Write(-1, 4, &dwTmp))\n\t\tgoto __goto_writeerror;\n\tcurFilePos += 4;\n\tdwTmp = SwapEndians(this->bundleDataOffs);\n\tif (!pWriter->Write(-1, 4, &dwTmp))\n\t\tgoto __goto_writeerror;\n\tcurFilePos += 4;\n\tdwTmp = SwapEndians(this->numberOfAssetsToDownload);\n\tif (!pWriter->Write(-1, 4, &dwTmp))\n\t\tgoto __goto_writeerror;\n\tcurFilePos += 4;\n\tdwTmp = SwapEndians(this->blockCount);\n\tif (!pWriter->Write(-1, 4, &dwTmp))\n\t\tgoto __goto_writeerror;\n\tcurFilePos += 4;\n\tfor (uint32_t i = 0; i < blockCount; i++)\n\t{\n\t\tdwTmp = SwapEndians(this->pBlockList[i].compressed);\n\t\tif (!pWriter->Write(-1, 4, &dwTmp))\n\t\t\tgoto __goto_writeerror;\n\t\tcurFilePos += 4;\n\t\tdwTmp = SwapEndians(this->pBlockList[i].uncompressed);\n\t\tif (!pWriter->Write(-1, 4, &dwTmp))\n\t\t\tgoto __goto_writeerror;\n\t\tcurFilePos += 4;\n\t}\n\tif (this->fileVersion >= 2)\n\t{\n\t\tdwTmp = SwapEndians(this->fileSize2);\n\t\tif (!pWriter->Write(-1, 4, &dwTmp))\n\t\t\tgoto __goto_writeerror;\n\t\tcurFilePos += 4;\n\t}\n\tif (this->fileVersion >= 3)\n\t{\n\t\tdwTmp = SwapEndians(this->unknown2);\n\t\tif (!pWriter->Write(-1, 4, &dwTmp))\n\t\t\tgoto __goto_writeerror;\n\t\tcurFilePos += 4;\n\t}\n\tif (!pWriter->Write(-1, 1, &this->unknown3))\n\t\tgoto __goto_writeerror;\n\tcurFilePos++;\n\treturn true;\n\t__goto_writeerror:\n\tif (errorLogger) errorLogger("AssetBundleHeader : A file write error occured!");\n\treturn false;\n}\n\nASSETSTOOLS_API QWORD AssetBundleDirectoryInfo06::GetAbsolutePos(AssetBundleHeader06 *pHeader)\n{\n\treturn (this->offset + pHeader->GetFileDataOffset());\n}\nASSETSTOOLS_API QWORD AssetBundleDirectoryInfo06::GetAbsolutePos(class AssetBundleFile *pFile)\n{\n\treturn GetAbsolutePos(&pFile->bundleHeader6);\n}\n\nASSETSTOOLS_API unsigned int AssetBundleEntry::GetAbsolutePos(AssetBundleHeader03 *pHeader)//, uint32_t listIndex)\n{\n\tunsigned int ret = (offset + pHeader->bundleDataOffs);\n\t/*for (uint32_t i = 0; i < listIndex; i++)\n\t{\n\t\tret += pHeader->pLevelList[i].uncompressed;\n\t}*/\n\treturn ret;\n}\nASSETSTOOLS_API unsigned int AssetBundleEntry::GetAbsolutePos(class AssetBundleFile *pFile)//, uint32_t listIndex)\n{\n\treturn GetAbsolutePos(&pFile->bundleHeader3);//, listIndex);\n}\nASSETSTOOLS_API bool AssetsList::Read(IAssetsReader *pReader, QWORD &curFilePos, AssetsFileVerifyLogger errorLogger)\n{\n\tthis->pos = (uint32_t)curFilePos;\n\tuint32_t dwTmp;\n\tif (!pReader->Read(curFilePos, 4, &dwTmp))\n\t\tgoto __goto_readerror;\n\tcurFilePos += 4;\n\tthis->count = SwapEndians(dwTmp);\n\t\n\tfor (uint32_t i = this->count; i < allocatedCount; i++)\n\t{\n\t\tfree(ppEntries[i]);\n\t}\n\tppEntries = (AssetBundleEntry**)realloc(ppEntries, this->count * sizeof(AssetBundleEntry*));\n\tif (ppEntries == NULL)\n\t\tgoto __goto_outofmemory;\n\tfor (uint32_t i = allocatedCount; i < this->count; i++)\n\t\tppEntries[i] = NULL;\n\n\tfor (unsigned int i = 0; i < this->count; i++)\n\t{\n\t\tchar nameBuffer[40];\n\t\tbool eosFound = false; size_t strLen = 0;\n\t\twhile (!eosFound)\n\t\t{\n\t\t\tQWORD nRead = pReader->Read(-1, 40, &nameBuffer);\n\t\t\tif (!nRead)\n\t\t\t\tgoto __goto_readerror;\n\t\t\tfor (size_t i = 0; i < (size_t)nRead; i++)\n\t\t\t{\n\t\t\t\tif (nameBuffer[i] == 0)\n\t\t\t\t{\n\t\t\t\t\teosFound = true;\n\t\t\t\t\tstrLen += (i+1);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!eosFound)\n\t\t\t\tstrLen += (size_t)nRead;\n\t\t}\n\t\tppEntries[i] = (AssetBundleEntry*)realloc(ppEntries[i], sizeof(AssetBundleEntry) - 1 + strLen);\n\t\tif (ppEntries[i] == NULL)\n\t\t\tgoto __goto_outofmemory;\n\t\tif (pReader->Read(curFilePos, strLen, ppEntries[i]->name) != strLen)\n\t\t\tgoto __goto_readerror;\n\t\tppEntries[i]->name[strLen-1] = 0;\n\t\tif (!pReader->Read(-1, 4, &ppEntries[i]->offset))\n\t\t\tgoto __goto_readerror;\n\t\tSwapEndians_(ppEntries[i]->offset);\n\t\tif (!pReader->Read(-1, 4, &ppEntries[i]->length))\n\t\t\tgoto __goto_readerror;\n\t\tSwapEndians_(ppEntries[i]->length);\n\t\tcurFilePos += (strLen + 4 + 4);\n\t}\n\tallocatedCount = this->count;\n\treturn true;\n\n\t__goto_readerror:\n\tif (errorLogger) errorLogger("AssetsList : A file read error occured!");\n\treturn false;\n\t__goto_outofmemory:\n\tif (errorLogger) errorLogger("AssetsList : Out of memory!");\n\treturn false;\n}\nASSETSTOOLS_API void AssetsList::Free()\n{\n\tfor (uint32_t i = 0; i < allocatedCount; i++)\n\t{\n\t\tfree(ppEntries[i]);\n\t}\n\tif (ppEntries)\n\t\tfree(ppEntries);\n\tppEntries = NULL;\n\tallocatedCount = 0;\n}\n\nASSETSTOOLS_API bool AssetsList::Write(IAssetsWriter *pWriter, QWORD &curFilePos, AssetsFileVerifyLogger errorLogger)\n{\n\tuint32_t dwTmp;\n\tdwTmp = SwapEndians(this->count);\n\tif (!pWriter->Write(curFilePos, 4, &dwTmp))\n\t\tgoto __goto_writeerror;\n\tcurFilePos += 4;\n\n\tfor (unsigned int i = 0; i < this->count; i++)\n\t{\n\t\tuint32_t nameStringLen = (uint32_t)strlen(ppEntries[i]->name)+1;\n\t\tif (!pWriter->Write(-1, nameStringLen, &ppEntries[i]->name))\n\t\t\tgoto __goto_writeerror;\t\n\t\tcurFilePos += nameStringLen;\n\t\tdwTmp = SwapEndians(ppEntries[i]->offset);\n\t\tif (!pWriter->Write(-1, 4, &dwTmp))\n\t\t\tgoto __goto_writeerror;\n\t\tdwTmp = SwapEndians(ppEntries[i]->length);\n\t\tif (!pWriter->Write(-1, 4, &dwTmp))\n\t\t\tgoto __goto_writeerror;\n\t\tcurFilePos += 8;\n\t}\n\n\t__goto_writeerror:\n\tif (errorLogger) errorLogger("AssetsList : A file write error occured!");\n\treturn false;\n}\nASSETSTOOLS_API bool AssetsList::Write(IAssetsReader *pReader, \n\tIAssetsWriter *pWriter, bool doWriteAssets, QWORD &curFilePos, QWORD *curWritePos,\n\tAssetsFileVerifyLogger errorLogger)\n{\n\tuint32_t estimatedBeginOffs, curEstimatedOffset;\n\tQWORD writePos = curWritePos ? (*curWritePos) : (QWORD)-1;\n\tuint32_t dwTmp;\n\tdwTmp = SwapEndians(this->count);\n\tif (!pWriter->Write(writePos, 4, &dwTmp))\n\t\tgoto __goto_writeerror;\n\testimatedBeginOffs = 4;\n\tfor (unsigned int i = 0; i < this->count; i++)\n\t{\n\t\testimatedBeginOffs += (uint32_t)strlen(ppEntries[i]->name)+1 + 8;\n\t}\n\tcurEstimatedOffset = estimatedBeginOffs;\n\tif (curWritePos)\n\t\t*curWritePos += curEstimatedOffset;\n\n\tfor (unsigned int i = 0; i < this->count; i++)\n\t{\n\t\tuint32_t nameStringLen = (uint32_t)strlen(ppEntries[i]->name)+1;\n\t\tif (!pWriter->Write(-1, nameStringLen, &ppEntries[i]->name))\n\t\t\tgoto __goto_writeerror;\t\n\t\tcurEstimatedOffset = (curEstimatedOffset + 3) & (~3);\n\t\tdwTmp = SwapEndians(curEstimatedOffset/*ppEntries[i]->offset*/);\n\t\tif (!pWriter->Write(-1, 4, &dwTmp))\n\t\t\tgoto __goto_writeerror;\n\t\tdwTmp = SwapEndians(ppEntries[i]->length);\n\t\tif (!pWriter->Write(-1, 4, &dwTmp))\n\t\t\tgoto __goto_writeerror;\n\t\tcurEstimatedOffset += ppEntries[i]->length;\n\t}\n\n\tif (doWriteAssets)\n\t{\n\t\tuint8_t _stackTransferBuffer[256];\n\t\tuint32_t transferBufferLen = 256;\n\t\tuint8_t *pTransferBuffer = (uint8_t*)malloc(1024 * 1024);\n\t\tif (!pTransferBuffer)\n\t\t\tpTransferBuffer = _stackTransferBuffer;\n\t\telse\n\t\t\ttransferBufferLen = 1024 * 1024;\n\n\t\tQWORD relPos = estimatedBeginOffs;\n\n\t\tfor (unsigned int i = 0; i < this->count; i++)\n\t\t{\n\t\t\tuint32_t nullCount = 3 - (((relPos & 3) - 1) & 3);\n\t\t\tdwTmp = 0;\n\t\t\tpWriter->Write(-1, nullCount, &dwTmp);\n\t\t\tuint32_t remaining = ppEntries[i]->length;\n\t\t\tbool setReadPos = false;\n\t\t\twhile (remaining > transferBufferLen)\n\t\t\t{\n\t\t\t\tpReader->Read(setReadPos ? -1 : (this->pos + ppEntries[i]->offset), transferBufferLen, pTransferBuffer);\n\t\t\t\tpWriter->Write(-1, transferBufferLen, pTransferBuffer);\n\t\t\t\tsetReadPos = true;\n\t\t\t}\n\t\t\tif (remaining)\n\t\t\t{\n\t\t\t\tpReader->Read(setReadPos ? -1 : (this->pos + ppEntries[i]->offset), remaining, pTransferBuffer);\n\t\t\t\tpWriter->Write(-1, remaining, pTransferBuffer);\n\t\t\t}\n\t\t\trelPos += nullCount + ppEntries[i]->length;\n\t\t}\n\t\tif (pTransferBuffer != _stackTransferBuffer)\n\t\t\tfree(pTransferBuffer);\n\n\t\tcurFilePos += relPos;\n\t}\n\treturn true;\n\n\t__goto_writeerror:\n\tif (errorLogger) errorLogger("AssetsList : A file write error occured!");\n\treturn false;\n}\n\nASSETSTOOLS_API AssetBundleFile::AssetBundleFile()\n{\n\tbundleHeader3.blockCount = 0;\n\tbundleHeader3.pBlockList = NULL;\n\tassetsLists3 = NULL;\n}\nASSETSTOOLS_API AssetBundleFile::~AssetBundleFile()\n{\n\tthis->Close();\n}\nASSETSTOOLS_API void AssetBundleFile::Close()\n{\n\tif (bundleHeader3.fileVersion < 6)\n\t{\n\t\tif (bundleHeader3.blockCount > 0)\n\t\t{\n\t\t\tfree(bundleHeader3.pBlockList);\n\t\t\tbundleHeader3.pBlockList = NULL;\n\t\t}\n\t\tif (assetsLists3)\n\t\t{\n\t\t\tbundleHeader3.blockCount = 0;\n\t\t\tassetsLists3->Free();\n\t\t\tfree(assetsLists3);\n\t\t}\n\t\tassetsLists3 = NULL;\n\t}\n\telse\n\t{\n\t\tif (bundleInf6)\n\t\t{\n\t\t\tbundleInf6->Free();\n\t\t\tfree(bundleInf6);\n\t\t}\n\t\tbundleInf6 = NULL;\n\t}\n}\nstatic void *SzAlloc(void *p, size_t size) { (p); return malloc(size); }\nstatic void SzFree(void *p, void *address) {  (p); free(address); }\nstatic ISzAlloc g_Alloc = { SzAlloc, SzFree };\n\nstatic SRes LZMADecompressBlock(QWORD *fileInPos, QWORD *fileOutPos, QWORD compressedSize, IAssetsReader *pReader, IAssetsWriter *pWriter)\n{\n\t#define SizePerBuffer (1024*1024)\n\tunsigned char header[LZMA_PROPS_SIZE/* + 8*/];\n\tif (pReader->Read(*fileInPos, sizeof(header), header) < sizeof(header))\n\t{\n\t\treturn SZ_ERROR_FAIL;\n\t}\n\tCLzmaDec dec;\n\tLzmaDec_Construct(&dec);\n\tSRes res = LzmaDec_Allocate(&dec, header, LZMA_PROPS_SIZE, &g_Alloc);\n\tif (res != SZ_OK)\n\t{\n\t\treturn SZ_ERROR_FAIL;\n\t}\n\tLzmaDec_Init(&dec);\n\tQWORD compProcessCount = sizeof(header);\n\tQWORD decompCount = 0;\n\tvoid *pCompBuf = malloc((compressedSize > SizePerBuffer) ? SizePerBuffer : compressedSize);\n\tif (!pCompBuf)\n\t{\n\t\tLzmaDec_Free(&dec, &g_Alloc);\n\t\treturn SZ_ERROR_MEM;\n\t}\n\tvoid *pDecompBuf = malloc(SizePerBuffer);\n\tif (!pDecompBuf)\n\t{\n\t\tLzmaDec_Free(&dec, &g_Alloc);\n\t\tfree(pCompBuf);\n\t\treturn SZ_ERROR_MEM;\n\t}\n\n\twhile (compProcessCount < compressedSize)\n\t{\n\t\tQWORD bytesToProcess = compressedSize - compProcessCount;\n\t\tbytesToProcess = bytesToProcess > SizePerBuffer ? SizePerBuffer : bytesToProcess;\n\t\tQWORD bytesAvailable = pReader->Read(*fileInPos + compProcessCount, bytesToProcess, pCompBuf);\n\t\tif (bytesAvailable != bytesToProcess)\n\t\t{\n\t\t\tLzmaDec_Free(&dec, &g_Alloc);\n\t\t\tfree(pCompBuf);\n\t\t\tfree(pDecompBuf);\n\t\t\treturn SZ_ERROR_INPUT_EOF;\n\t\t}\n\t\t\n\t\tSizeT compLen = bytesAvailable;\n\t\tSizeT decompLen = SizePerBuffer;\n\t\tELzmaStatus stat = LZMA_STATUS_NOT_SPECIFIED;\n\t\tres = LzmaDec_DecodeToBuf(&dec, (Byte*)pDecompBuf, &decompLen, (Byte*)pCompBuf, &compLen, \n\t\t\tLZMA_FINISH_ANY, &stat);\n\t\t//if ((res == SZ_OK) && !decompLen)\n\t\t//\tres = SZ_ERROR_FAIL;\n\t\tif (res != SZ_OK)\n\t\t{\n\t\t\tLzmaDec_Free(&dec, &g_Alloc);\n\t\t\tfree(pCompBuf);\n\t\t\tfree(pDecompBuf);\n\t\t\treturn res;\n\t\t}\n\t\tcompProcessCount += compLen;\n\t\tif (pWriter->Write(*fileOutPos + decompCount, decompLen, pDecompBuf) < decompLen)\n\t\t{\n\t\t\tLzmaDec_Free(&dec, &g_Alloc);\n\t\t\tfree(pCompBuf);\n\t\t\tfree(pDecompBuf);\n\t\t\treturn SZ_ERROR_OUTPUT_EOF;\n\t\t}\n\t\tdecompCount += decompLen;\n\t}\n\tLzmaDec_Free(&dec, &g_Alloc);\n\tfree(pCompBuf);\n\tfree(pDecompBuf);\n\t*fileInPos += compProcessCount;\n\t*fileOutPos += decompCount;\n\treturn SZ_OK;\n}\nstruct LZ4DecompressBlock_Read_User_t\n{\n\tQWORD dataPos;\n\tQWORD dataSize;\n\tIAssetsReader *pReader;\n};\nstatic int LZ4DecompressBlock_Read(void *buffer, int size, LZ4e_instream_t *stream)\n{\n\tif (size <= 0) return 0;\n\tLZ4DecompressBlock_Read_User_t *user = (LZ4DecompressBlock_Read_User_t*)stream->user;\n\n\tQWORD readSize = (QWORD)size;\n\tif (stream->pos >= user->dataSize) return 0;\n\tif ((stream->pos + size) > user->dataSize)\n\t\treadSize = user->dataSize - stream->pos;\n\n\treturn (int) user->pReader->Read(stream->pos + user->dataPos, readSize, buffer, false);\n}\nstatic int LZ4DecompressBlock_Write(const void *buffer, int size, LZ4e_outstream_t *stream)\n{\n\tif (size <= 0) return 0;\n\tconst uint8_t *pCur = (const uint8_t*)buffer; int remaining = size; int lastRead;\n\twhile (remaining && (lastRead = (int) ((IAssetsWriter*)stream->user)->Write((QWORD)size, buffer)) > 0)\n\t{\n\t\tpCur += lastRead;\n\t\tremaining -= lastRead;\n\t}\n\treturn size - remaining;//(int) ((IAssetsWriter*)stream->user)->Write((QWORD)size, buffer);\n}\nstatic bool LZ4DecompressBlock(QWORD *fileInPos, QWORD *fileOutPos, QWORD compressedSize, IAssetsReader *pReader, IAssetsWriter *pWriter)\n{\n\tstatic const size_t compBufferSize = (1*1024*1024);\n\tstatic const size_t decompBufferSize = (1*1024*1024);\n\tLZ4DecompressBlock_Read_User_t inuser;\n\tLZ4e_instream_t instream;\n\tLZ4e_outstream_t outstream;\n\tvoid *pCompBuf = malloc(compBufferSize + decompBufferSize);\n\tif (!pCompBuf)\n\t\treturn false;\n\tvoid *pDecompBuf = ((uint8_t*)pCompBuf) + compBufferSize;\n\n\tinstream.pos = 0;\n\tinstream.callback = LZ4DecompressBlock_Read;\n\tinstream.user = &inuser;\n\tinuser.dataPos = *fileInPos;\n\tinuser.dataSize = compressedSize;\n\tinuser.pReader = pReader;\n\n\toutstream.callback = LZ4DecompressBlock_Write;\n\toutstream.user = pWriter;\n\n\tQWORD oldWriterPos = *fileOutPos;\n\tpWriter->Tell(oldWriterPos);\n\n\tbool ret = LZ4e_decompress_safe((char*)pCompBuf, (char*)pDecompBuf, compBufferSize, decompBufferSize, &instream, &outstream) > 0;\n\n\tQWORD newWriterPos = oldWriterPos;\n\tpWriter->Tell(newWriterPos);\n\t*fileOutPos += (newWriterPos - oldWriterPos);\n\n\t*fileInPos += compressedSize;\n\n\tfree(pCompBuf);\n\treturn ret;\n}\nstatic bool LZ4CompressBlock(QWORD *fileInPos, QWORD *fileOutPos, QWORD decompressedSize, IAssetsReader *pReader, IAssetsWriter *pWriter)\n{\n\tif (decompressedSize > 0x7FFFFFFF)\n\t\treturn false;\n\tLZ4DecompressBlock_Read_User_t inuser;\n\tLZ4e_instream_t instream;\n\tLZ4e_outstream_t outstream;\n\n\tinstream.pos = 0;\n\tinstream.callback = LZ4DecompressBlock_Read;\n\tinstream.user = &inuser;\n\tinuser.dataPos = *fileInPos;\n\tinuser.dataSize = decompressedSize;\n\tinuser.pReader = pReader;\n\n\toutstream.callback = LZ4DecompressBlock_Write;\n\toutstream.user = pWriter;\n\n\tQWORD oldWriterPos = *fileOutPos;\n\tpWriter->Tell(oldWriterPos);\n\n\tbool ret = LZ4e_compress_fast(&instream, &outstream, 1, (unsigned int)decompressedSize) > 0;\n\n\tQWORD newWriterPos = oldWriterPos;\n\tpWriter->Tell(newWriterPos);\n\t*fileOutPos += (newWriterPos - oldWriterPos);\n\n\t*fileInPos += decompressedSize;\n\treturn ret;\n}\n\nASSETSTOOLS_API bool AssetBundleFile::Unpack(IAssetsReader *pReader, IAssetsWriter *pWriter)\n{\n\tif (!Read(pReader, NULL, true))\n\t\treturn false;\n\t//bundleHeader6.fileVersion == bundleHeader3.fileVersion\n\tif (bundleHeader6.fileVersion >= 6)\n\t{\n\t\tuint8_t compressionType = (bundleHeader6.flags & 0x3F);\n\t\tif (compressionType < 4)\n\t\t{\n\t\t\tQWORD curFilePos = 0;\n\t\t\tQWORD curUpFilePos = 0;\n\t\t\tif (bundleHeader6.flags & 0x100) //originally was UnityWeb\n\t\t\t\tstrcpy(bundleHeader6.signature, "UnityWeb");\n\t\t\tbundleHeader6.Write(pWriter, curFilePos);\n\t\t\tif (bundleHeader6.flags & 0x100) //originally was UnityWeb\n\t\t\t\tstrcpy(bundleHeader6.signature, "UnityFS");\n\t\t\tcurFilePos = bundleHeader6.GetBundleInfoOffset();\n\t\t\tcurUpFilePos = curFilePos;\n\t\t\t\n\t\t\tvoid *fileTableBuf = malloc(bundleHeader6.decompressedSize);\n\t\t\tif (!fileTableBuf)\n\t\t\t\treturn false;\n\t\t\tIAssetsWriter *pTempWriter = Create_AssetsWriterToMemory(fileTableBuf, bundleHeader6.decompressedSize);\n\t\t\tif (!pTempWriter)\n\t\t\t{\n\t\t\t\tfree(fileTableBuf);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tcurUpFilePos = 0;\n\t\t\tbool decompressSuccess = false;\n\t\t\tswitch (compressionType)\n\t\t\t{\n\t\t\tcase 0:\n\t\t\t\tif (bundleHeader6.compressedSize == bundleHeader6.decompressedSize\n\t\t\t\t\t&& pReader->Read(curFilePos, bundleHeader6.compressedSize, fileTableBuf) == bundleHeader6.decompressedSize)\n\t\t\t\t\tdecompressSuccess = true;\n\t\t\t\tbreak;\n\t\t\tcase 1: //LZMA\n\t\t\t\tif (LZMADecompressBlock(&curFilePos, &curUpFilePos, bundleHeader6.compressedSize, pReader, pTempWriter) == SZ_OK)\n\t\t\t\t\tdecompressSuccess = true;\n\t\t\t\tbreak;\n\t\t\tcase 2: case 3: //LZ4\n\t\t\t\tif (LZ4DecompressBlock(&curFilePos, &curUpFilePos, bundleHeader6.compressedSize, pReader, pTempWriter))\n\t\t\t\t\tdecompressSuccess = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tFree_AssetsWriter(pTempWriter);\n\t\t\tif (!decompressSuccess || curUpFilePos != bundleHeader6.decompressedSize)\n\t\t\t{\n\t\t\t\tfree(fileTableBuf);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t\n\t\t\tIAssetsReader *pTempReader = Create_AssetsReaderFromMemory(fileTableBuf, bundleHeader6.decompressedSize, false);\n\t\t\tif (!pTempReader)\n\t\t\t{\n\t\t\t\tfree(fileTableBuf);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tAssetBundleBlockAndDirectoryList06 list = {0};\n\t\t\tbool res = list.Read(0, pTempReader);\n\t\t\tFree_AssetsReader(pTempReader);\n\t\t\tfree(fileTableBuf);\n\t\t\tcurFilePos = bundleHeader6.GetFileDataOffset();\n\t\t\tif (bundleHeader6.flags & 0x80)\n\t\t\t\tcurUpFilePos = bundleHeader6.GetFileDataOffset();\n\t\t\telse\n\t\t\t{\n\t\t\t\tcurUpFilePos = bundleHeader6.GetBundleInfoOffset();\n\t\t\t\tQWORD oldUpFilePos = curUpFilePos;\n\t\t\t\tlist.Write(pWriter, curUpFilePos);\n\t\t\t\tbundleHeader6.decompressedSize = (uint32_t)(curUpFilePos - oldUpFilePos);\n\t\t\t}\n\n\t\t\tif (!res)\n\t\t\t{\n\t\t\t\tfree(fileTableBuf);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tfor (uint32_t i = 0; i < list.blockCount; i++)\n\t\t\t{\n\t\t\t\t//QWORD oldUpFilePos = curUpFilePos;\n\t\t\t\tswitch (list.blockInf[i].GetCompressionType())\n\t\t\t\t{\n\t\t\t\tcase 0: //none\n\t\t\t\t\tif (list.blockInf[i].compressedSize == list.blockInf[i].decompressedSize)\n\t\t\t\t\t{\n\t\t\t\t\t\tuint32_t copiedCount = 0;\n\t\t\t\t\t\tuint32_t copyBufLen = 1024 * 1024;\n\t\t\t\t\t\tvoid *copyBuf = malloc(1024 * 1024); uint8_t tmp[256];\n\t\t\t\t\t\tif (!copyBuf)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcopyBuf = tmp; copyBufLen = 256;\n\t\t\t\t\t\t}\n\t\t\t\t\t\twhile (copiedCount < list.blockInf[i].compressedSize)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tuint32_t bytesToCopy = copyBufLen;\n\t\t\t\t\t\t\tif (bytesToCopy > (list.blockInf[i].compressedSize - copiedCount))\n\t\t\t\t\t\t\t\tbytesToCopy = (list.blockInf[i].compressedSize - copiedCount);\n\t\t\t\t\t\t\tuint32_t bytesRead = (uint32_t)pReader->Read(curFilePos, bytesToCopy, copyBuf);\n\t\t\t\t\t\t\tuint32_t bytesWritten = (uint32_t)pWriter->Write(curUpFilePos, bytesRead, copyBuf);\n\t\t\t\t\t\t\tcurFilePos += bytesRead;\n\t\t\t\t\t\t\tcurUpFilePos += bytesWritten;\n\t\t\t\t\t\t\tif (bytesRead != bytesToCopy || bytesWritten != bytesRead)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif (copyBuf != tmp)\n\t\t\t\t\t\t\t\t\tfree(copyBuf);\n\t\t\t\t\t\t\t\tlist.Free();\n\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t\t//break;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcopiedCount += bytesRead;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (copyBuf != tmp)\n\t\t\t\t\t\t\tfree(copyBuf);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tlist.Free();\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 1: //LZMA\n\t\t\t\t\tif (LZMADecompressBlock(&curFilePos, &curUpFilePos, list.blockInf[i].compressedSize, pReader, pWriter) != SZ_OK)\n\t\t\t\t\t{\n\t\t\t\t\t\tlist.Free();\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\n\t\t\t\tcase 3:\n\t\t\t\t\tif (!LZ4DecompressBlock(&curFilePos, &curUpFilePos, list.blockInf[i].compressedSize, pReader, pWriter))\n\t\t\t\t\t{\n\t\t\t\t\t\tlist.Free();\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\t{\n\t\t\t\t\t\tlist.Free();\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tlist.blockInf[i].compressedSize = list.blockInf[i].decompressedSize;\n\t\t\t\tlist.blockInf[i].flags &= ~(0x3F); //compression = 0\n\t\t\t\t//list.blockInf[i].decompressedSize = curUpFilePos - oldUpFilePos;\n\t\t\t}\n\t\t\tif (bundleHeader6.flags & 0x80)\n\t\t\t{\n\t\t\t\tQWORD oldUpFilePos = curUpFilePos;\n\t\t\t\tlist.Write(pWriter, curUpFilePos);\n\t\t\t\tbundleHeader6.decompressedSize = (uint32_t)(curUpFilePos - oldUpFilePos);\n\t\t\t}\n\t\t\tbundleHeader6.totalFileSize = curUpFilePos;\n\t\t\tbundleHeader6.compressedSize = bundleHeader6.decompressedSize;\n\t\t\tcurUpFilePos = 0;\n\t\t\tbundleHeader6.flags &= ~(0x3F);\n\t\t\tbundleHeader6.flags &= ~(0x200); //No additional 16 byte data alignment.\n\n\t\t\tif (bundleHeader6.flags & 0x100) //originally was UnityWeb\n\t\t\t\tstrcpy(bundleHeader6.signature, "UnityWeb");\n\t\t\tbundleHeader6.Write(pWriter, curUpFilePos);\n\t\t\tif (bundleHeader6.flags & 0x100) //originally was UnityWeb\n\t\t\t\tstrcpy(bundleHeader6.signature, "UnityFS");\n\t\t\tif (bundleHeader6.flags & 0x80)\n\t\t\t\tcurUpFilePos = bundleHeader6.GetBundleInfoOffset();\n\t\t\tlist.Write(pWriter, curUpFilePos);\n\t\t\tlist.Free();\n\t\t\treturn true;\n\t\t}\n\t}\n\telse if (bundleHeader3.fileVersion == 3)\n\t{\n\t\tif (!strcmp(bundleHeader3.signature, "UnityWeb"))\n\t\t{\n\t\t\tif ((bundleHeader3.blockCount == 0) || (bundleHeader3.pBlockList[0].compressed < (LZMA_PROPS_SIZE+8)))\n\t\t\t\treturn false;\n\t#define SizePerBuffer (1024*1024)\n\t\t\tvoid *buffers = malloc(2 * SizePerBuffer);\n\t\t\tif (!buffers)\n\t\t\t\treturn false;\n\t\t\tuint8_t *compBuffer = (uint8_t*)buffers;\n\t\t\tuint8_t *decompBuffer = &compBuffer[SizePerBuffer];\n\t\t\tQWORD curFilePos = 0;\n\t\t\tQWORD curUpFilePos = 0;\n\t\t\tbundleHeader3.Write(pWriter, curFilePos);\n\t\t\tcurFilePos = bundleHeader3.bundleDataOffs;\n\t\t\tcurUpFilePos = bundleHeader3.bundleDataOffs;\n\n\t\t\t/*QWORD compressedSize = 0;\n\t\t\tQWORD decompressedSize = 0;\n\t\t\tfor (uint32_t i = 0; i < bundleHeader.levelCount; i++)\n\t\t\t{\n\t\t\t\tif (bundleHeader.pLevelList[i].uncompressed > decompressedSize)\n\t\t\t\t{\n\t\t\t\t\tcompressedSize = bundleHeader.pLevelList[i].compressed;\n\t\t\t\t\tdecompressedSize = bundleHeader.pLevelList[i].uncompressed;\n\t\t\t\t}\n\t\t\t}*/\n\t\t\tQWORD decompCount = 0;\n\t\t\t//for (uint32_t i = 0; i < bundleHeader.bundleCount; i++)\n\t\t\t{\n\t\t\t\tunsigned char header[LZMA_PROPS_SIZE + 8];\n\t\t\t\tif (!pReader->Read(curFilePos, sizeof(header), header))\n\t\t\t\t{\n\t\t\t\t\tfree(buffers);\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tCLzmaDec dec;\n\t\t\t\tLzmaDec_Construct(&dec);\n\t\t\t\tSRes res = LzmaDec_Allocate(&dec, header, LZMA_PROPS_SIZE, &g_Alloc);\n\t\t\t\tif (res != SZ_OK)\n\t\t\t\t{\n\t\t\t\t\tfree(buffers);\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tLzmaDec_Init(&dec);\n\t\t\t\tQWORD compProcessCount = 0;\n\t\t\t\n\t\t\t\tAssetsList decompEntryList; ZeroMemory(&decompEntryList, sizeof(AssetsList));\n\t\t\t\t{\n\t\t\t\t\t//read the entry list\n\t\t\t\t\tQWORD bytesToProcess = bundleHeader3.pBlockList[0].compressed - compProcessCount;\n\t\t\t\t\tbytesToProcess = bytesToProcess > SizePerBuffer ? SizePerBuffer : bytesToProcess;\n\t\t\t\t\tpReader->Read(curFilePos + sizeof(header) + compProcessCount, bytesToProcess, compBuffer);\n\t\t\t\t\tSizeT compLen = bytesToProcess;\n\t\t\t\t\tSizeT decompLen = SizePerBuffer;\n\t\t\t\t\tELzmaStatus stat = LZMA_STATUS_NOT_SPECIFIED;\n\t\t\t\t\tres = LzmaDec_DecodeToBuf(&dec, decompBuffer, &decompLen, compBuffer, &compLen, \n\t\t\t\t\t\tLZMA_FINISH_ANY, &stat);\n\t\t\t\t\tif ((compLen == 0) || (res != SZ_OK))\n\t\t\t\t\t{\n\t\t\t\t\t\tLzmaDec_Free(&dec, &g_Alloc);\n\t\t\t\t\t\tfree(buffers);\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\tIAssetsReader *pMemoryReader = Create_AssetsReaderFromMemory(decompBuffer, decompLen, false);\n\t\t\t\t\tif (pMemoryReader == NULL)\n\t\t\t\t\t{\n\t\t\t\t\t\tLzmaDec_Free(&dec, &g_Alloc);\n\t\t\t\t\t\tfree(buffers);\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\tQWORD _qwTmp = 0;\n\t\t\t\t\tdecompEntryList.Read(pMemoryReader, _qwTmp);\n\t\t\t\t\tFree_AssetsReader(pMemoryReader);\n\t\t\t\t\n\t\t\t\t\t//sort the entries (this one is slow but the entry lists aren\'t that large\n\t\t\t\t\tbool repeat = false;\n\t\t\t\t\tfor (uint32_t i = 0; i < decompEntryList.count; i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (repeat)\n\t\t\t\t\t\t\ti--;\n\t\t\t\t\t\trepeat = false;\n\t\t\t\t\t\tfor (uint32_t k = i+1; k < decompEntryList.count; k++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (decompEntryList.ppEntries[k]->offset < decompEntryList.ppEntries[i]->offset)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tAssetBundleEntry *pEntry = decompEntryList.ppEntries[k];\n\t\t\t\t\t\t\t\tmemcpy(&decompEntryList.ppEntries[i+1], &decompEntryList.ppEntries[i], (k - i) * sizeof(void*));\n\t\t\t\t\t\t\t\tdecompEntryList.ppEntries[i] = pEntry;\n\t\t\t\t\t\t\t\t//repeat = true;\n\t\t\t\t\t\t\t\t//firstFileOffs = decompEntryList.ppEntries[i]->offset;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tpWriter->Write(curUpFilePos, decompEntryList.ppEntries[0]->offset, decompBuffer);\n\t\t\t\t\n\t\t\t\t\t//get the exact amount of compressed bytes to the first file\n\t\t\t\t\t//reset the decoder (it possibly isn\'t able to revert its position)\n\t\t\t\t\tLzmaDec_Free(&dec, &g_Alloc);\n\t\t\t\t\tLzmaDec_Construct(&dec);\n\t\t\t\t\tLzmaDec_Allocate(&dec, header, LZMA_PROPS_SIZE, &g_Alloc);\n\t\t\t\t\tLzmaDec_Init(&dec);\n\n\t\t\t\t\tcompLen = bytesToProcess;\n\t\t\t\t\tdecompLen = decompEntryList.ppEntries[0]->offset;\n\t\t\t\t\tstat = LZMA_STATUS_NOT_SPECIFIED;\n\t\t\t\t\tres = LzmaDec_DecodeToBuf(&dec, decompBuffer, &decompLen, compBuffer, &compLen, \n\t\t\t\t\t\tLZMA_FINISH_ANY, &stat);\n\n\t\t\t\t\tcompProcessCount += compLen;\n\t\t\t\t\tdecompCount += decompLen;\n\t\t\t\t}\n\t\t\t\n\t\t\t\tuint32_t levelIndex = 0;\n\t\t\t\tfor (uint32_t i = 0; i < decompEntryList.count; i++)\n\t\t\t\t{\n\t\t\t\t\tQWORD decompressBytes = decompEntryList.ppEntries[i]->length;\n\t\t\t\t\tif ((i+1) < decompEntryList.count)\n\t\t\t\t\t{\n\t\t\t\t\t\t//add empty bytes to read in between (if there are any)\n\t\t\t\t\t\tdecompressBytes += decompEntryList.ppEntries[i+1]->offset - \n\t\t\t\t\t\t\t\t(decompEntryList.ppEntries[i]->offset + decompEntryList.ppEntries[i]->length);\n\t\t\t\t\t}\n\t\t\t\t\tdo\n\t\t\t\t\t{\n\t\t\t\t\t\tZeroMemory(buffers, 2 * SizePerBuffer);\n\t\t\t\t\t\t//QWORD bytesToProcess = compressedSize - compProcessCount;\n\t\t\t\t\t\t//bytesToProcess = bytesToProcess > SizePerBuffer ? SizePerBuffer : bytesToProcess;\n\t\t\t\t\t\tQWORD bytesToDecompress = (decompEntryList.ppEntries[i]->offset + decompressBytes) - decompCount;\n\t\t\t\t\t\tbytesToDecompress = bytesToDecompress > SizePerBuffer ? SizePerBuffer : bytesToDecompress;\n\t\t\t\t\t\tpReader->Read(curFilePos + sizeof(header) + compProcessCount, SizePerBuffer, compBuffer);\n\t\t\t\t\t\tSizeT compLen = SizePerBuffer;//bytesToProcess;\n\t\t\t\t\t\tSizeT decompLen = bytesToDecompress;\n\t\t\t\t\t\tELzmaStatus stat = LZMA_STATUS_NOT_SPECIFIED;\n\t\t\t\t\t\tres = LzmaDec_DecodeToBuf(&dec, decompBuffer, &decompLen, compBuffer, &compLen, \n\t\t\t\t\t\t\tLZMA_FINISH_ANY, &stat);\n\t\t\t\t\t\tif (compLen == 0 || res != SZ_OK)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tLzmaDec_Free(&dec, &g_Alloc);\n\t\t\t\t\t\t\tfree(buffers);\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tpWriter->Write(curUpFilePos + decompCount, decompLen, decompBuffer);\n\t\t\t\t\t\tcompProcessCount += compLen;\n\t\t\t\t\t\tdecompCount += decompLen;\n\t\t\t\t\t} while (decompCount < (decompEntryList.ppEntries[i]->offset + decompressBytes));\n\t\t\t\t\tif ((1 == decompEntryList.count || \n\t\t\t\t\t\t!strcmp(decompEntryList.ppEntries[i]->name, "mainData") || \n\t\t\t\t\t\t!strncmp(decompEntryList.ppEntries[i]->name, "level", 5)) && \n\t\t\t\t\t\t(levelIndex < this->bundleHeader3.blockCount))\n\t\t\t\t\t{\n\t\t\t\t\t\tthis->bundleHeader3.pBlockList[levelIndex].compressed = \n\t\t\t\t\t\t\tthis->bundleHeader3.pBlockList[levelIndex].uncompressed =\n\t\t\t\t\t\t\t(decompEntryList.ppEntries[i]->offset + decompEntryList.ppEntries[i]->length);\n\t\t\t\t\t\tlevelIndex++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tLzmaDec_Free(&dec, &g_Alloc);\n\t\t\t\tdecompEntryList.Free();\n\t\t\t\t//curFilePos += bundleHeader.pBundleList[i].compressed;\n\t\t\t\t//curUpFilePos += bundleHeader.pBundleList[i].uncompressed;\n\t\t\t}\n\t\t\tfree(buffers);\n\t\t\tAssetBundleHeader03 headerCopy;\n\t\t\tmemcpy(&headerCopy, &this->bundleHeader3, sizeof(AssetBundleHeader03));\n\t\t\tstrcpy(headerCopy.signature, "UnityRaw");\n\t\t\theaderCopy.minimumStreamedBytes = headerCopy.fileSize2 = headerCopy.bundleDataOffs + (uint32_t)decompCount;\n\t\t\t/*for (uint32_t i = 0; i < bundleHeader.bundleCount; i++)\n\t\t\t{\n\t\t\t\theaderCopy.pBundleList[i].compressed = headerCopy.pBundleList[i].uncompressed;\n\t\t\t}*/\n\t\t\t/*if (bundleHeader.bundleCount)\n\t\t\t{\n\t\t\t\tbundleHeader.bundleCount = 1;\n\t\t\t\theaderCopy.pBundleList[0].compressed = headerCopy.pBundleList[0].uncompressed = decompressedSize;\n\t\t\t}*/\n\t\t\tcurFilePos = 0;\n\t\t\theaderCopy.Write(pWriter, curFilePos);\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\ntypedef struct\n{\n\tISeqInStream SeqInStream;\n\tstd::mutex critSect;\n\tstd::mutex critSectReading; //To sync freeing the stream.\n\tHANDLE hDataEvent; HANDLE hRequestDataEvent; //TODO: Replace by some std mechanism.\n\tbool isDone;\n\tsize_t bufferSize;\n\tuint8_t *dataBuffer;\n} LZMAInStream;\nstatic SRes LZMAInStream_Read(void *p, void *buf, size_t *size)\n{\n\tLZMAInStream *ctx = (LZMAInStream*)p;\n\tif (ctx->isDone)\n\t{\n\t\t*size = 0;\n\t\treturn SZ_OK;\n\t}\n\tsize_t readSize = 0;\n\t\n\tstd::scoped_lock critSectReadingLock(ctx->critSectReading);\n\t{\n\t\tstd::unique_lock critSectLock(ctx->critSect);\n\t\tResetEvent(ctx->hDataEvent);\n\t\tsize_t toCopy = std::min<size_t>(ctx->bufferSize, (*size) - readSize);\n\t\tmemcpy(&((uint8_t*)buf)[readSize], ctx->dataBuffer, toCopy);\n\t\treadSize += toCopy;\n\n\t\tuint8_t *bufferTemp = new uint8_t[ctx->bufferSize - toCopy];\n\t\tmemcpy(bufferTemp, &ctx->dataBuffer[toCopy], ctx->bufferSize - toCopy);\n\t\tif (ctx->dataBuffer) delete[] ctx->dataBuffer;\n\t\tctx->dataBuffer = bufferTemp;\n\t\tctx->bufferSize -= toCopy;\n\t\tcritSectLock.unlock();\n\t\tif (readSize == 0)//< (*size))\n\t\t{\n\t\t\tSetEvent(ctx->hRequestDataEvent);\n\t\t\tif ((WaitForSingleObjectEx(ctx->hDataEvent, INFINITE, FALSE) != WAIT_OBJECT_0) || ctx->isDone)\n\t\t\t{\n\t\t\t\t*size = readSize;\n\t\t\t\treturn SZ_OK;\n\t\t\t}\n\t\t\tcritSectLock.lock();\n\t\t\tsize_t toCopy = std::min<size_t>(ctx->bufferSize, (*size) - readSize);\n\t\t\tmemcpy(&((uint8_t*)buf)[readSize], ctx->dataBuffer, toCopy);\n\t\t\treadSize += toCopy;\n\n\t\t\tuint8_t *bufferTemp = new uint8_t[ctx->bufferSize - toCopy];\n\t\t\tmemcpy(bufferTemp, &ctx->dataBuffer[toCopy], ctx->bufferSize - toCopy);\n\t\t\tif (ctx->dataBuffer) delete[] ctx->dataBuffer;\n\t\t\tctx->dataBuffer = bufferTemp;\n\t\t\tctx->bufferSize -= toCopy;\n\t\t}\n\t}\n\t*size = readSize;\n\treturn SZ_OK;\n}\nstatic void LZMAInStream_Init(LZMAInStream *pStream)\n{\n\tpStream->SeqInStream.Read = LZMAInStream_Read;\n\tpStream->hDataEvent = CreateEvent(NULL, FALSE, FALSE, NULL);\n\tpStream->hRequestDataEvent = CreateEvent(NULL, FALSE, FALSE, NULL);\n\tpStream->isDone = false;\n\tpStream->bufferSize = 0;\n\tpStream->dataBuffer = NULL;\n}\nstatic void LZMAInStream_Free(LZMAInStream *pStream)\n{\n\tpStream->isDone = true;\n\tSetEvent(pStream->hDataEvent);\n\tSetEvent(pStream->hRequestDataEvent);\n\tSleep(0); //Prevent entering the critical section between LZMAInStream_Read\'s isDone check and its EnterCriticalSection.\n\tpStream->critSectReading.lock();\n\tpStream->critSectReading.unlock();\n\tCloseHandle(pStream->hDataEvent);\n\tCloseHandle(pStream->hRequestDataEvent);\n\tif (pStream->dataBuffer)\n\t{\n\t\tdelete[] pStream->dataBuffer;\n\t\tpStream->dataBuffer = NULL;\n\t}\n\tpStream->bufferSize = 0;\n}\nstatic void LZMAInStream_Put(LZMAInStream *pStream, void *data, size_t size, bool waitForData)\n{\n\tif (pStream->isDone)\n\t\treturn;\n\tstd::unique_lock critSectLock(pStream->critSect);\n\tuint8_t *bufferTemp = new uint8_t[pStream->bufferSize + size];\n\tmemcpy(bufferTemp, pStream->dataBuffer, pStream->bufferSize);\n\tmemcpy(&bufferTemp[pStream->bufferSize], data, size);\n\tif (pStream->dataBuffer) delete[] pStream->dataBuffer;\n\tpStream->dataBuffer = bufferTemp;\n\tpStream->bufferSize += size;\n\tSetEvent(pStream->hDataEvent);\n\tcritSectLock.unlock();\n\tif (waitForData)\n\t\tWaitForSingleObject(pStream->hRequestDataEvent, INFINITE);\n}\n\ntypedef struct\n{\n\tISeqOutStream SeqOutStream;\n\tIAssetsWriter *pWriter;\n\tQWORD writeOffset;\n\tQWORD writeCount;\n} LZMAOutStream;\nstatic size_t LZMAOutStream_Write(void *p, const void *buf, size_t size)\n{\n\tLZMAOutStream *ctx = (LZMAOutStream*)p;\n\tctx->pWriter->Write(ctx->writeOffset + ctx->writeCount, size, buf);\n\tctx->writeCount += size;\n\treturn size;\n}\n\nstruct LZMACompressThreadData\n{\n\tLZMAInStream *pIn;\n\tLZMAOutStream *pOut;\n\tCLzmaEncHandle enc;\n\tSRes result;\n};\nstatic void LZMACompressThread(void *pData)\n{\n\tLZMACompressThreadData *pThreadData = (LZMACompressThreadData*)pData;\n\tpThreadData->result = LzmaEnc_Encode(pThreadData->enc, &pThreadData->pOut->SeqOutStream, &pThreadData->pIn->SeqInStream, NULL, &g_Alloc, &g_Alloc);\n\t//LZMAInStream_Free(pThreadData->pIn);\n\tpThreadData->pIn->isDone = true;\n\tSetEvent(pThreadData->pIn->hRequestDataEvent);\n}\n\n\nstatic SRes LZMACompressBlock(QWORD *fileInPos, QWORD *fileOutPos, QWORD decompressedSize, uint32_t alignmentBytes, IAssetsReader *pReader, IAssetsWriter *pWriter)\n{\n\t#define SizePerBuffer (1024*1024)\n\tCLzmaEncHandle enc = LzmaEnc_Create(&g_Alloc);\n\tif (!enc)\n\t{\n\t\treturn SZ_ERROR_FAIL;\n\t}\n\n\tCLzmaEncProps props;\n\tLzmaEncProps_Init(&props);\n\tprops.level = 0;\n\tprops.writeEndMark = 1;\n#ifdef _DEBUG\n\tprops.dictSize = 4096;\n#else\n\tprops.dictSize = 524288;\n#endif\n\tprops.numThreads = 2;\n\n\tSRes res = LzmaEnc_SetProps(enc, &props);\n\tif (res != SZ_OK)\n\t{\n\t\tLzmaEnc_Destroy(enc, &g_Alloc, &g_Alloc);\n\t\treturn res;\n\t}\n\n\tsize_t headerSize = LZMA_PROPS_SIZE;\n\tunsigned char header[LZMA_PROPS_SIZE];\n\tLzmaEnc_WriteProperties(enc, header, &headerSize);\n\tif (res != SZ_OK || headerSize != LZMA_PROPS_SIZE)\n\t{\n\t\tLzmaEnc_Destroy(enc, &g_Alloc, &g_Alloc);\n\t\treturn SZ_ERROR_FAIL;\n\t}\n\tpWriter->Write(*fileOutPos, headerSize, header);\n\tQWORD decompProcessCount = 0;\n\tvoid *pDecompBuf = malloc((decompressedSize > SizePerBuffer) ? SizePerBuffer : decompressedSize);\n\tif (!pDecompBuf)\n\t{\n\t\tLzmaEnc_Destroy(enc, &g_Alloc, &g_Alloc);\n\t\treturn SZ_ERROR_MEM;\n\t}\n\n\tLZMAInStream seqInStream; LZMAInStream_Init(&seqInStream);\n\tLZMAOutStream seqOutStream = {&LZMAOutStream_Write, pWriter, *fileOutPos, headerSize};\n\tLZMACompressThreadData threadData;\n\tthreadData.pIn = &seqInStream;\n\tthreadData.pOut = &seqOutStream;\n\tthreadData.enc = enc;\n\tthreadData.result = SZ_OK;\n\t\n\tstd::future<void> compressFuture = std::async(LZMACompressThread, &threadData);\n\n\tif (alignmentBytes > 0)\n\t{\n\t\tuint8_t *alignment = new uint8_t[alignmentBytes];\n\t\tmemset(alignment, 0, alignmentBytes);\n\t\tLZMAInStream_Put(&seqInStream, alignment, alignmentBytes, true);\n\t\tdelete[] alignment;\n\t}\n\n\tSRes ret = SZ_OK;\n\twhile (decompProcessCount < decompressedSize)\n\t{\n\t\tQWORD bytesToProcess = decompressedSize - decompProcessCount;\n\t\tbytesToProcess = bytesToProcess > SizePerBuffer ? SizePerBuffer : bytesToProcess;\n\t\tQWORD bytesAvailable = pReader->Read(*fileInPos + decompProcessCount, bytesToProcess, pDecompBuf);\n\t\tif (bytesAvailable != bytesToProcess)\n\t\t{\n\t\t\tret = SZ_ERROR_INPUT_EOF;\n\t\t\tgoto _GOTO_DO_RETURN;\n\t\t}\n\t\t\n\t\tLZMAInStream_Put(&seqInStream, pDecompBuf, bytesToProcess, true);\n\n\t\tdecompProcessCount += bytesToProcess;\n\t}\n_GOTO_DO_RETURN:\n\tfree(pDecompBuf);\n\tLZMAInStream_Free(&seqInStream);\n\tassert(compressFuture.valid());\n\tcompressFuture.wait();\n\tLzmaEnc_Destroy(enc, &g_Alloc, &g_Alloc);\n\t*fileOutPos += threadData.pOut->writeCount;\n\t*fileInPos += decompProcessCount;\n\treturn ret;\n}\n/*static bool LZ4CompressBlocks(QWORD *fileInPos, QWORD *fileOutPos, QWORD decompressedSize, IAssetsReader *pReader, IAssetsWriter *pWriter,\n\tstd::vector<AssetBundleOffsetPair> &blockSizes)\n{\n\t#define SizePerBuffer (2*1024*1024)\n\tLZ4_stream_t *pStream = LZ4_createStream();\n\tif (!pStream)\n\t\treturn false;\n\tmemset(pStream, 0, sizeof(LZ4_stream_t));\n\tQWORD decompProcessCount = 0;\n\tQWORD compCount = 0;\n\t//pDecompBuf is a ring buffer with <decompBufCount> elements. LZ4 uses the previous buffers as a dictionary, except the one to be compressed at a time.\n\tsize_t decompSizePerBuffer = (decompressedSize > SizePerBuffer) ? SizePerBuffer : decompressedSize;\n#define decompBufCount 2\n\tuint8_t *pDecompBuf = (uint8_t*)malloc(decompBufCount * decompSizePerBuffer);\n\tif (!pDecompBuf)\n\t{\n\t\tLZ4_freeStream(pStream);\n\t\treturn false;\n\t}\n\tsize_t decompBufIndex = 0;\n\tvoid *pCompBuf = malloc(LZ4_COMPRESSBOUND(SizePerBuffer));\n\tif (!pCompBuf)\n\t{\n\t\tLZ4_freeStream(pStream);\n\t\tfree(pDecompBuf);\n\t\treturn false;\n\t}\n\twhile (decompProcessCount < decompressedSize)\n\t{\n\t\tQWORD bytesToProcess = decompressedSize - decompProcessCount;\n\t\tbytesToProcess = bytesToProcess > SizePerBuffer ? SizePerBuffer : bytesToProcess;\n\t\tQWORD bytesAvailable = pReader->Read(*fileInPos + decompProcessCount, bytesToProcess, &pDecompBuf[decompBufIndex*decompSizePerBuffer]);\n\t\tif (bytesAvailable != bytesToProcess)\n\t\t{\n\t\t\tLZ4_freeStream(pStream);\n\t\t\tfree(pCompBuf);\n\t\t\tfree(pDecompBuf);\n\t\t\treturn false;\n\t\t}\n\n\t\tSizeT decompLen = bytesAvailable;\n\t\tSizeT compLen = LZ4_COMPRESSBOUND(SizePerBuffer);\n\t\tcompLen = LZ4_compress_fast_continue(pStream, (char*)&pDecompBuf[decompBufIndex*decompSizePerBuffer], (char*)pCompBuf, decompLen, compLen, 1);\n\t\tif (compLen == 0)\n\t\t{\n\t\t\tLZ4_freeStream(pStream);\n\t\t\tfree(pCompBuf);\n\t\t\tfree(pDecompBuf);\n\t\t\treturn false;\n\t\t}\n\t\tAssetBundleOffsetPair sizePair; sizePair.compressed = (uint32_t)compLen; sizePair.uncompressed = (uint32_t)decompLen;\n\t\tblockSizes.push_back(sizePair);\n\t\tdecompProcessCount += decompLen;\n\t\tdecompBufIndex++;\n\t\tif (decompBufIndex > decompBufCount)\n\t\t\tdecompBufIndex = 0;\n\t\tif (pWriter->Write(*fileOutPos + compCount, compLen, pCompBuf) < compLen)\n\t\t{\n\t\t\tLZ4_freeStream(pStream);\n\t\t\tfree(pCompBuf);\n\t\t\tfree(pDecompBuf);\n\t\t\treturn false;\n\t\t}\n\t\tcompCount += compLen;\n\t}\n\tLZ4_freeStream(pStream);\n\tfree(pCompBuf);\n\tfree(pDecompBuf);\n\t*fileInPos += decompProcessCount;\n\t*fileOutPos += compCount;\n\treturn true;\n}*/\n\nstatic bool CopyBlock(QWORD *fileInPos, QWORD *fileOutPos, QWORD totalSize, IAssetsReader *pReader, IAssetsWriter *pWriter)\n{\n\t#define SizePerBuffer (1024*1024)\n\tQWORD processedSize = 0;\n\tvoid *pDecompBuf = malloc((totalSize > SizePerBuffer) ? SizePerBuffer : totalSize);\n\tif (!pDecompBuf)\n\t{\n\t\treturn false;\n\t}\n\n\tbool ret = true;\n\twhile (processedSize < totalSize)\n\t{\n\t\tQWORD bytesToProcess = totalSize - processedSize;\n\t\tbytesToProcess = bytesToProcess > SizePerBuffer ? SizePerBuffer : bytesToProcess;\n\t\tQWORD bytesAvailable = pReader->Read(*fileInPos + processedSize, bytesToProcess, pDecompBuf);\n\t\tif (bytesAvailable != bytesToProcess)\n\t\t{\n\t\t\tret = false;\n\t\t\tgoto _GOTO_DO_RETURN;\n\t\t}\n\t\t\n\t\tQWORD bytesProcessed = pWriter->Write(*fileOutPos + processedSize, bytesToProcess, pDecompBuf);\n\t\tprocessedSize += bytesProcessed;\n\n\t\tif (bytesProcessed != bytesToProcess)\n\t\t{\n\t\t\tret = false;\n\t\t\tgoto _GOTO_DO_RETURN;\n\t\t}\n\t}\n_GOTO_DO_RETURN:\n\tfree(pDecompBuf);\n\t*fileOutPos += processedSize;\n\t*fileInPos += processedSize;\n\treturn ret;\n}\n\nASSETSTOOLS_API bool AssetBundleFile::Pack(IAssetsReader *pReader, IAssetsWriter *pWriter, ECompressionTypes *settings, ECompressionTypes fileTableSettings)\n{\n\tif (!Read(pReader, NULL, false))\n\t\treturn false;\n\tif (bundleHeader3.fileVersion == 3)\n\t{\n\t\tif (!strcmp(bundleHeader3.signature, "UnityRaw"))\n\t\t{\n\t\t\t//sort the entries (this one is slow but the entry lists aren\'t that large)\n\t\t\tbool repeat = false;\n\t\t\tfor (uint32_t i = 0; i < this->assetsLists3[0].count; i++)\n\t\t\t{\n\t\t\t\tif (repeat)\n\t\t\t\t\ti--;\n\t\t\t\trepeat = false;\n\t\t\t\tfor (uint32_t k = i+1; k < this->assetsLists3[0].count; k++)\n\t\t\t\t{\n\t\t\t\t\tif (this->assetsLists3[0].ppEntries[k]->offset < this->assetsLists3[0].ppEntries[i]->offset)\n\t\t\t\t\t{\n\t\t\t\t\t\tAssetBundleEntry *pEntry = this->assetsLists3[0].ppEntries[k];\n\t\t\t\t\t\tmemcpy(&this->assetsLists3[0].ppEntries[i+1], &this->assetsLists3[0].ppEntries[i], (k - i) * sizeof(void*));\n\t\t\t\t\t\tthis->assetsLists3[0].ppEntries[i] = pEntry;\n\t\t\t\t\t\t//repeat = true;\n\t\t\t\t\t\t//firstFileOffs = decompEntryList.ppEntries[i]->offset;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t#define SizePerBuffer (1024*1024)\n\t\t\tvoid *buffers = malloc(/*11 * */SizePerBuffer);\n\t\t\tif (!buffers)\n\t\t\t\treturn false;\n\t\t\tstd::vector<AssetBundleOffsetPair> pairs;\n\n\t\t\tuint8_t *decompBuffer = (uint8_t*)buffers;\n\t\t\t//uint8_t *compBuffer = &decompBuffer[SizePerBuffer];\n\t\t\tQWORD curFilePos = 0;\n\t\t\tQWORD curCompFilePos = 0;\n\t\t\tbundleHeader3.Write(pWriter, curFilePos);\n\t\t\tcurFilePos = bundleHeader3.bundleDataOffs;\n\t\t\tcurCompFilePos = bundleHeader3.bundleDataOffs;\n\n\t\t\tQWORD curCompressOffs = 0;\n\t\t\t//for (uint32_t i = 0; i < bundleHeader.bundleCount; i++)\n\t\t\t{\n\t\t\t\tCLzmaEncHandle enc = LzmaEnc_Create(&g_Alloc);\n\t\t\t\tif (!enc)\n\t\t\t\t{\n\t\t\t\t\tfree(buffers);\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\tCLzmaEncProps props;\n\t\t\t\tLzmaEncProps_Init(&props);\n\t\t\t\tprops.level = 0;\n\t\t\t\tprops.writeEndMark = 1;\n\t\t\t\tprops.dictSize = 524288;\n\t\t\t\tprops.numThreads = 2;\n\n\t\t\t\tSRes res = LzmaEnc_SetProps(enc, &props);\n\t\t\t\tif (res != SZ_OK)\n\t\t\t\t{\n\t\t\t\t\tfree(buffers);\n\t\t\t\t\tLzmaEnc_Destroy(enc, &g_Alloc, &g_Alloc);\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tunsigned char header[LZMA_PROPS_SIZE+8];\n\t\t\t\tsize_t headerSize = LZMA_PROPS_SIZE;\n\t\t\t\tLzmaEnc_WriteProperties(enc, header, &headerSize);\n\t\t\t\tif (res != SZ_OK || headerSize != LZMA_PROPS_SIZE)\n\t\t\t\t{\n\t\t\t\t\tfree(buffers);\n\t\t\t\t\tLzmaEnc_Destroy(enc, &g_Alloc, &g_Alloc);\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\theaderSize = LZMA_PROPS_SIZE+8;\n\t\t\t\t*(QWORD*)&header[LZMA_PROPS_SIZE] = 0;\n\t\t\t\tQWORD lzmaHeaderFilePos = curFilePos;\n\t\t\t\tpWriter->Write(curFilePos, headerSize, header);\n\t\t\t\tcurCompressOffs += headerSize; //?\n\n\t\t\t\tLZMAInStream seqInStream; LZMAInStream_Init(&seqInStream);\n\t\t\t\tLZMAOutStream seqOutStream = {&LZMAOutStream_Write, pWriter, lzmaHeaderFilePos, headerSize};\n\t\t\t\tLZMACompressThreadData threadData;\n\t\t\t\tthreadData.pIn = &seqInStream;\n\t\t\t\tthreadData.pOut = &seqOutStream;\n\t\t\t\tthreadData.enc = enc;\n\t\t\t\tthreadData.result = SZ_OK;\n\t\t\t\tstd::future<void> compressFuture = std::async(LZMACompressThread, &threadData);\n\n\t\t\t\tQWORD curUncompressOffs = 0;\n\t\t\t\tuint32_t levelIndex = 0;\n\t\t\t\t{\n\t\t\t\t\tsize_t destLen = SizePerBuffer;\n\t\t\t\t\tsize_t srcLen;\n\t\t\t\t\tif (this->assetsLists3->count > 0)\n\t\t\t\t\t\tsrcLen = this->assetsLists3->ppEntries[0]->offset;\n\t\t\t\t\telse\n\t\t\t\t\t\tsrcLen = 4; //count dword (= 0)\n\t\t\t\t\tQWORD oldWriteCount = seqOutStream.writeCount;\n\t\t\t\t\tpReader->Read(curFilePos, srcLen, decompBuffer);\n\t\t\t\t\tLZMAInStream_Put(&seqInStream, decompBuffer, srcLen, true);\n\t\t\t\t\tdestLen = seqOutStream.writeCount - oldWriteCount;\n\t\t\t\t\t/*SRes result = LzmaEnc_MemEncode(enc, compBuffer, &destLen, decompBuffer, srcLen, (this->assetsLists3->count > 0) ? 0 : 1, \n\t\t\t\t\t\tNULL, &g_Alloc, &g_Alloc);\n\t\t\t\t\tif ((destLen == 0) || (result != SZ_OK))\n\t\t\t\t\t{\n\t\t\t\t\t\tfree(buffers);\n\t\t\t\t\t\tLzmaEnc_Destroy(enc, &g_Alloc, &g_Alloc);\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\twriter(-1, destLen, compBuffer, writerPar);*/\n\t\t\t\t\tcurCompressOffs += destLen;\n\t\t\t\t\tcurUncompressOffs += srcLen;\n\t\t\t\t\tif (this->assetsLists3->count == 0 && this->bundleHeader3.blockCount > 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tthis->bundleHeader3.pBlockList[levelIndex].compressed = (uint32_t)curCompressOffs;\n\t\t\t\t\t\tthis->bundleHeader3.pBlockList[levelIndex].uncompressed = (uint32_t)curUncompressOffs;\n\t\t\t\t\t\tlevelIndex++;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfor (uint32_t i = 0; i < this->assetsLists3->count; i++)\n\t\t\t\t{\n\t\t\t\t\tQWORD compressBytes = this->assetsLists3->ppEntries[i]->length;\n\t\t\t\t\tif ((i+1) < this->assetsLists3->count)\n\t\t\t\t\t{\n\t\t\t\t\t\t//add empty bytes to compress in between (if there are any)\n\t\t\t\t\t\tcompressBytes += this->assetsLists3->ppEntries[i+1]->offset - \n\t\t\t\t\t\t\t\t(this->assetsLists3->ppEntries[i]->offset + this->assetsLists3->ppEntries[i]->length);\n\t\t\t\t\t}\n\t\t\t\t\tQWORD curBytesProcessed = 0;\n\t\t\t\t\twhile (curBytesProcessed < compressBytes)\n\t\t\t\t\t{\n\t\t\t\t\t\tsize_t writeLen = compressBytes - curBytesProcessed;\n\t\t\t\t\t\tsize_t destLen;// = 10*SizePerBuffer;\n\t\t\t\t\t\tsize_t srcLen = writeLen > SizePerBuffer ? SizePerBuffer : writeLen;\n\t\t\t\t\t\tQWORD oldWriteCount = seqOutStream.writeCount;\n\t\t\t\t\t\tpReader->Read(curFilePos + this->assetsLists3->ppEntries[i]->offset + curBytesProcessed, srcLen, decompBuffer);\n\t\t\t\t\t\tif (srcLen > 0)\n\t\t\t\t\t\t\tLZMAInStream_Put(&seqInStream, decompBuffer, srcLen, true);\n\t\t\t\t\t\tdestLen = seqOutStream.writeCount - oldWriteCount;\n\t\t\t\t\t\t/*SRes result = LzmaEnc_MemEncode(enc, compBuffer, &destLen, decompBuffer, srcLen,\n\t\t\t\t\t\t\t(((i+1) >= this->assetsLists3->count) && (srcLen >= writeLen)) ? 1 : 0, \n\t\t\t\t\t\t\tNULL, &g_Alloc, &g_Alloc);\n\t\t\t\t\t\tif ((destLen == 0) || (result != SZ_OK))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfree(buffers);\n\t\t\t\t\t\t\tLzmaEnc_Destroy(enc, &g_Alloc, &g_Alloc);\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\twriter(-1, destLen, compBuffer, writerPar);*/\n\t\t\t\t\t\tcurCompressOffs += destLen;\n\t\t\t\t\t\tcurBytesProcessed += srcLen;\n\t\t\t\t\t\tcurUncompressOffs += srcLen;\n\t\t\t\t\t}\n\t\t\t\t\tif ((1 == this->assetsLists3->count || \n\t\t\t\t\t\t\t!strcmp(this->assetsLists3->ppEntries[i]->name, "mainData") || \n\t\t\t\t\t\t\t!strncmp(this->assetsLists3->ppEntries[i]->name, "level", 5)) && \n\t\t\t\t\t\t\t(levelIndex < this->bundleHeader3.blockCount))\n\t\t\t\t\t{\n\t\t\t\t\t\tthis->bundleHeader3.pBlockList[levelIndex].compressed = (uint32_t)curCompressOffs;\n\t\t\t\t\t\tthis->bundleHeader3.pBlockList[levelIndex].uncompressed = (uint32_t)curUncompressOffs;\n\t\t\t\t\t\tlevelIndex++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tLZMAInStream_Free(&seqInStream);\n\t\t\t\tassert(compressFuture.valid());\n\t\t\t\tcompressFuture.wait();\n\t\t\t\tcurCompressOffs = threadData.pOut->writeCount;\n\t\t\t\tLzmaEnc_Destroy(enc, &g_Alloc, &g_Alloc);\n\t\t\t\t*(QWORD*)&header[LZMA_PROPS_SIZE] = curUncompressOffs;\n\t\t\t\tpWriter->Write(lzmaHeaderFilePos, headerSize, header);\n\t\t\t}\n\t\t\tfree(buffers);\n\t\t\tAssetBundleHeader03 headerCopy;\n\t\t\tmemcpy(&headerCopy, &this->bundleHeader3, sizeof(AssetBundleHeader03));\n\t\t\tstrcpy(headerCopy.signature, "UnityWeb");\n\t\t\theaderCopy.minimumStreamedBytes = headerCopy.fileSize2 = headerCopy.bundleDataOffs + (uint32_t)curCompressOffs;\n\t\t\tcurFilePos = 0;\n\t\t\theaderCopy.Write(pWriter, curFilePos);\n\t\t\treturn true;\n\t\t}\n\t}\n\telse if (bundleHeader3.fileVersion >= 6)\n\t{\n\t\t//sort the entries (this one is slow but the entry lists aren\'t that large)\n\t\tbool repeat = false;\n\t\tfor (uint32_t i = 0; i < this->bundleInf6->directoryCount; i++)\n\t\t{\n\t\t\tif (repeat)\n\t\t\t\ti--;\n\t\t\trepeat = false;\n\t\t\tfor (uint32_t k = i+1; k < this->bundleInf6->directoryCount; k++)\n\t\t\t{\n\t\t\t\tif (this->bundleInf6->dirInf[k].offset < this->bundleInf6->dirInf[i].offset)\n\t\t\t\t{\n\t\t\t\t\tAssetBundleDirectoryInfo06 entry = this->bundleInf6->dirInf[k];\n\t\t\t\t\tmemcpy(&this->bundleInf6->dirInf[i+1], &this->bundleInf6->dirInf[i], (k - i) * sizeof(AssetBundleDirectoryInfo06));\n\t\t\t\t\tthis->bundleInf6->dirInf[i] = entry;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tstd::vector<AssetBundleBlockInfo06> newBlockInfo;\n\t\tstd::vector<AssetBundleDirectoryInfo06> newDirectory;\n\n\t\tQWORD curFilePos = 0;\n\t\tQWORD curCompFilePos = 0;\n\n\t\tAssetBundleHeader06 headerCopy;\n\t\tmemcpy(&headerCopy, &this->bundleHeader6, sizeof(AssetBundleHeader06));\n\t\tstrcpy(headerCopy.signature, "UnityFS");\n\t\t//strcpy(headerCopy.fileEngineVersion, "5.3.4p10");\n\t\theaderCopy.flags = 0x80 | 0x40; //Don\'t know the block sizes before having written everything, so let\'s simply append the block info.\n\t\theaderCopy.Write(pWriter, curFilePos);\n\t\tcurFilePos = bundleHeader6.GetFileDataOffset();\n\t\tcurCompFilePos = headerCopy.GetFileDataOffset();\n\n\t\tQWORD curCompressOffs = 0;\n\t\tQWORD curAbsOffs = curCompFilePos; //"cleaned" file pointer to the new file, as if it was uncompressed.\n\t\tuint8_t nullBuf[16] = {};\n\t\tfor (uint32_t i = 0; i < bundleInf6->directoryCount; i++)\n\t\t{\n\t\t\tAssetBundleDirectoryInfo06 *pDir = &bundleInf6->dirInf[i];\n\t\t\tcurFilePos = bundleHeader6.GetFileDataOffset() + pDir->offset;\n\t\t\t\n\t\t\tAssetBundleBlockInfo06 newBlock;\n\t\t\tAssetBundleDirectoryInfo06 newDir;\n\t\t\tnewDir.decompressedSize = pDir->decompressedSize;\n\t\t\tnewDir.flags = pDir->flags;\n\t\t\tnewDir.name = pDir->name;\n\t\t\tnewDir.offset = curAbsOffs - headerCopy.GetFileDataOffset();\n\t\t\tnewDirectory.push_back(newDir);\n\t\t\tsize_t nameLen = strlen(pDir->name);\n\t\t\tuint32_t curType = COMPRESS_LZ4;\n\t\t\tif (!settings)\n\t\t\t{\n\t\t\t\tif ((nameLen > 9 && !strnicmp(&pDir->name[nameLen - 9], ".resource", 9))\n\t\t\t\t\t|| (nameLen > 10 && !strnicmp(&pDir->name[nameLen - 10], ".resources", 10))\n\t\t\t\t\t|| (nameLen > 5 && !strnicmp(&pDir->name[nameLen - 5], ".resS", 5)))\n\t\t\t\t\tcurType = COMPRESS_NONE;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tcurType = settings[i];\n\t\t\t\tif (curType > (uint32_t)COMPRESS_LZ4) curType = COMPRESS_NONE;\n\t\t\t}\n\t\t\tQWORD entryBytesProcessed = 0;\n\t\t\tQWORD blockLimit = ((uint32_t)std::numeric_limits<int32_t>::max()) & ~15; //0x7FFFFFF0\n\t\t\twhile (entryBytesProcessed < pDir->decompressedSize)\n\t\t\t{\n\t\t\t\tQWORD bytesToProcess = pDir->decompressedSize;\n\t\t\t\tbytesToProcess = std::min<QWORD>(bytesToProcess, blockLimit);\n\t\t\t\tQWORD preFileCompPos = curCompFilePos;\n\t\t\t\tswitch (curType)\n\t\t\t\t{\n\t\t\t\tcase COMPRESS_NONE:\n\t\t\t\t\tif (!CopyBlock(&curFilePos, &curCompFilePos, bytesToProcess, pReader, pWriter))\n\t\t\t\t\t\treturn false;\n\t\t\t\t\tnewBlock.flags = 0; //uncompressed\n\t\t\t\t\tbreak;\n\t\t\t\tcase COMPRESS_LZMA:\n\t\t\t\t\tif (LZMACompressBlock(&curFilePos, &curCompFilePos, bytesToProcess, 0, pReader, pWriter) != SZ_OK)\n\t\t\t\t\t\treturn false;\n\t\t\t\t\tnewBlock.flags = 1; //LZMA, not streamed\n\t\t\t\t\tbreak;\n\t\t\t\tcase COMPRESS_LZ4:\n\t\t\t\t\tif (!LZ4CompressBlock(&curFilePos, &curCompFilePos, bytesToProcess, pReader, pWriter))\n\t\t\t\t\t\treturn false;\n\t\t\t\t\tnewBlock.flags = 2; //LZ4, not streamed\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tnewBlock.compressedSize = (uint32_t)(curCompFilePos - preFileCompPos);\n\t\t\t\tnewBlock.decompressedSize = (uint32_t)bytesToProcess;\n\t\t\t\tnewBlockInfo.push_back(newBlock);\n\t\t\t\tcurAbsOffs += newBlock.decompressedSize;\n\t\t\t}\n\t\t}\n\t\tAssetBundleBlockAndDirectoryList06 listCopy;\n\t\tlistCopy.checksumLow = 0;\n\t\tlistCopy.checksumHigh = 0;\n\t\tlistCopy.blockCount = (uint32_t)newBlockInfo.size();\n\t\tlistCopy.blockInf = newBlockInfo.data();\n\t\tlistCopy.directoryCount = (uint32_t)newDirectory.size();\n\t\tlistCopy.dirInf = newDirectory.data();\n\t\tQWORD listBeginPos = curCompFilePos;\n\n\t\tIAssetsWriterToMemory *pListWriter = Create_AssetsWriterToMemory(); QWORD listWriterPos = 0;\n\t\tlistCopy.Write(pListWriter, listWriterPos);\n\t\tpListWriter->SetFreeBuffer(true);\n\t\tvoid *pListRaw = nullptr; size_t listRawSize = 0;\n\t\tif (!pListWriter->GetBuffer(pListRaw, listRawSize))\n\t\t{\n\t\t\tFree_AssetsWriter(pListWriter);\n\t\t\treturn false;\n\t\t}\n\t\tswitch (fileTableSettings)\n\t\t{\n\t\t\tdefault:\n\t\t\tcase COMPRESS_NONE:\n\t\t\t\tif (pWriter->Write(curCompFilePos, listRawSize, pListRaw) < listRawSize)\n\t\t\t\t{\n\t\t\t\t\tFree_AssetsWriter(pListWriter);\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tcurCompFilePos += listRawSize;\n\t\t\t\theaderCopy.flags = (headerCopy.flags & ~0x3F) | 0;\n\t\t\t\tbreak;\n\t\t\tcase COMPRESS_LZMA:\n\t\t\t\t{\n\t\t\t\t\tQWORD listReaderPos = 0;\n\t\t\t\t\tIAssetsReader *pListReader = Create_AssetsReaderFromMemory(pListRaw, listRawSize, false);\n\t\t\t\t\tif (LZMACompressBlock(&listReaderPos, &curCompFilePos, listRawSize, 0, pListReader, pWriter) != SZ_OK)\n\t\t\t\t\t{\n\t\t\t\t\t\tFree_AssetsReader(pListReader);\n\t\t\t\t\t\tFree_AssetsWriter(pListWriter);\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\theaderCopy.flags = (headerCopy.flags & ~0x3F) | 1;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase COMPRESS_LZ4:\n\t\t\t\t{\n\t\t\t\t\tQWORD listReaderPos = 0;\n\t\t\t\t\tIAssetsReader *pListReader = Create_AssetsReaderFromMemory(pListRaw, listRawSize, false);\n\t\t\t\t\tif (!LZ4CompressBlock(&listReaderPos, &curCompFilePos, listRawSize, pListReader, pWriter))\n\t\t\t\t\t{\n\t\t\t\t\t\tFree_AssetsReader(pListReader);\n\t\t\t\t\t\tFree_AssetsWriter(pListWriter);\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\theaderCopy.flags = (headerCopy.flags & ~0x3F) | 2;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t}\n\t\tFree_AssetsWriter(pListWriter);\n\t\t//listCopy.Write(pWriter, curCompFilePos);\n\t\theaderCopy.totalFileSize = curCompFilePos;\n\t\theaderCopy.decompressedSize = (uint32_t)listRawSize;\n\t\theaderCopy.compressedSize = (uint32_t)(curCompFilePos - listBeginPos);\n\n\t\tcurCompFilePos = 0;\n\t\theaderCopy.Write(pWriter, curCompFilePos);\n\t\treturn true;\n\t}\n\telse\n\t\treturn false;\n\treturn true;\n}\nASSETSTOOLS_API bool AssetBundleFile::Write(IAssetsReader *pReader, \n\tIAssetsWriter *pWriter, \n\tBundleReplacer **pReplacers, size_t replacerCount, \n\tAssetsFileVerifyLogger errorLogger, ClassDatabaseFile *typeMeta)\n{\n\tif (!this->bundleInf6)\n\t{\n\t\tif (errorLogger) errorLogger("ERROR : Invalid bundle file!");\n\t\treturn false;\n\t}\n\tstruct BundleReplacerInfo\n\t{\n\t\tBundleReplacer *pReplacer;\n\t\tsize_t predecessorIndex; //Currently used for fileVersion >= 6 only\n\t\tunsigned int bundleEntryIndex;\n\t\tbool skipFlag; //Currently used for fileVersion >= 6 only\n\t\tBundleReplacerInfo()\n\t\t\t: pReplacer(nullptr), predecessorIndex((size_t)-1),\n\t\t\tbundleEntryIndex((unsigned int)-1), skipFlag(false)\n\t\t{}\n\t};\n\tstd::vector<std::unique_ptr<BundleReplacer, void(*)(BundleReplacer*)>> replacersToDelete;\n\tstd::vector<BundleReplacerInfo> replacers;\n\t//Internal directory: Removed entries are still counted (no shifting of higher indices).\n\t//                    -> The first <this->bundleInf6[0].directoryCount> indices represent original directory entries.\n\t//Output directory: Removed entries are no longer listed.\n\t//Maps entry names to internal directory indices.\n\tstd::unordered_map<std::string, unsigned int> internalDirectoryIndexByName;\n\t//Maps internal directory indices to output directory indices.\n\tstd::vector<size_t> internalToOutputDirectoryMap;\n\t//Maps internal directory indices to the latest replacer index for that entry.\n\tstd::vector<size_t> internalDirectoryLatestReplacerMap;\n\tsize_t numOutputDirectories = 0;\n\tuint32_t numOriginalDirectories = 0;\n\tstd::vector<std::string> outputDirectoryNames;\n\tif (bundleHeader3.fileVersion >= 6)\n\t{\n\t\tnumOriginalDirectories = this->bundleInf6->directoryCount;\n\t\tinternalToOutputDirectoryMap.resize(numOriginalDirectories);\n\t\tinternalDirectoryLatestReplacerMap.resize(numOriginalDirectories);\n\t\tnumOutputDirectories = numOriginalDirectories;\n\t\toutputDirectoryNames.resize(numOriginalDirectories);\n\t\tfor (uint32_t k = 0; k < numOriginalDirectories; k++)\n\t\t{\n\t\t\tinternalDirectoryIndexByName[this->bundleInf6->dirInf[k].name] = k;\n\t\t\toutputDirectoryNames[k] = this->bundleInf6->dirInf[k].name;\n\t\t\tinternalToOutputDirectoryMap[k] = k;\n\t\t\tinternalDirectoryLatestReplacerMap[k] = (size_t)-1;\n\t\t}\n\t}\n\telse if (bundleHeader3.fileVersion == 3)\n\t{\n\t\tnumOriginalDirectories = this->assetsLists3->count;\n\t\tinternalToOutputDirectoryMap.resize(numOriginalDirectories);\n\t\tinternalDirectoryLatestReplacerMap.resize(numOriginalDirectories);\n\t\tnumOutputDirectories = numOriginalDirectories;\n\t\toutputDirectoryNames.resize(numOriginalDirectories);\n\t\tfor (uint32_t k = 0; k < numOriginalDirectories; k++)\n\t\t{\n\t\t\tinternalDirectoryIndexByName[this->assetsLists3->ppEntries[k]->name] = k;\n\t\t\toutputDirectoryNames[k] = this->assetsLists3->ppEntries[k]->name;\n\t\t\tinternalToOutputDirectoryMap[k] = k;\n\t\t\tinternalDirectoryLatestReplacerMap[k] = (size_t)-1;\n\t\t}\n\t}\n\telse\n\t\treturn false;\n\t\t\n\t//Generate the directory mappings and internal replacer list.\n\treplacers.resize(replacerCount);\n\tfor (size_t i = 0; i < replacerCount; i++)\n\t{\n\t\treplacers[i].pReplacer = pReplacers[i];\n\t\treplacers[i].pReplacer->Uninit();\n\t\tunsigned int bundleListIndex = pReplacers[i]->GetBundleListIndex();\n\t\tconst char *entryName = pReplacers[i]->GetOriginalEntryName();\n\t\tif (bundleListIndex == (unsigned int)-1 && entryName != NULL)\n\t\t{\n\t\t\t//Find the internal directory index by the entry name.\n\t\t\tauto entryNameIt = internalDirectoryIndexByName.find(entryName);\n\t\t\tif (entryNameIt != internalDirectoryIndexByName.end())\n\t\t\t\tbundleListIndex = entryNameIt->second;\n\t\t}\n\t\tif (bundleListIndex == (unsigned int)-1\n\t\t\t&& (entryName != NULL || (entryName = pReplacers[i]->GetEntryName()) != NULL)\n\t\t\t&& pReplacers[i]->GetType() == BundleReplacement_AddOrModify\n\t\t\t&& !pReplacers[i]->RequiresEntryReader())\n\t\t{\n\t\t\t//New entry adder.\n\t\t\t//-> Add it to the directory mappings.\n\t\t\tbundleListIndex = (unsigned int)internalToOutputDirectoryMap.size();\n\t\t\tinternalDirectoryIndexByName[entryName] = bundleListIndex;\n\t\t\t\t\n\t\t\tassert(outputDirectoryNames.size() == numOutputDirectories);\n\t\t\toutputDirectoryNames.push_back(entryName);\n\t\t\tinternalToOutputDirectoryMap.push_back(numOutputDirectories);\n\t\t\tinternalDirectoryLatestReplacerMap.push_back(i);\n\t\t\t++numOutputDirectories;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t//Evaluate the effect on the directory and name mappings.\n\t\t\tswitch (pReplacers[i]->GetType())\n\t\t\t{\n\t\t\tcase BundleReplacement_Remove:\n\t\t\t\tif (entryName != NULL && bundleListIndex != (unsigned int)-1)\n\t\t\t\t{\n\t\t\t\t\tassert(numOutputDirectories > 0);\n\t\t\t\t\tassert(internalToOutputDirectoryMap[bundleListIndex] != -1);\n\t\t\t\t\tif (internalToOutputDirectoryMap[bundleListIndex] != -1)\n\t\t\t\t\t\toutputDirectoryNames.erase(outputDirectoryNames.begin() + internalToOutputDirectoryMap[bundleListIndex]);\n\t\t\t\t\tinternalToOutputDirectoryMap[bundleListIndex] = (size_t)-1;\n\t\t\t\t\tfor (size_t k = bundleListIndex + 1; k < internalToOutputDirectoryMap.size(); ++k)\n\t\t\t\t\t{\n\t\t\t\t\t\t--internalToOutputDirectoryMap[k];\n\t\t\t\t\t}\n\n\t\t\t\t\t--numOutputDirectories;\n\t\t\t\t\tinternalDirectoryIndexByName.erase(entryName);\n\t\t\t\t\tassert(outputDirectoryNames.size() == numOutputDirectories);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase BundleReplacement_Rename:\n\t\t\tcase BundleReplacement_AddOrModify:\n\t\t\t\t{\n\t\t\t\t\tconst char *newEntryName = pReplacers[i]->GetEntryName();\n\t\t\t\t\tif (entryName != NULL && bundleListIndex != (unsigned int)-1 && newEntryName != nullptr)\n\t\t\t\t\t{\n\t\t\t\t\t\tinternalDirectoryIndexByName.erase(entryName);\n\t\t\t\t\t\tinternalDirectoryIndexByName[newEntryName] = bundleListIndex;\n\t\t\t\t\t\tassert(internalToOutputDirectoryMap[bundleListIndex] != -1);\n\t\t\t\t\t\tif (internalToOutputDirectoryMap[bundleListIndex] != -1)\n\t\t\t\t\t\t\toutputDirectoryNames[internalToOutputDirectoryMap[bundleListIndex]] = newEntryName;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (bundleListIndex != (unsigned int)-1)\n\t\t{\n\t\t\t//Link the replacer in the by-directoryIndex mapping.\n\t\t\tif (internalDirectoryLatestReplacerMap[bundleListIndex] != (size_t)-1\n\t\t\t\t&& internalDirectoryLatestReplacerMap[bundleListIndex] != i)\n\t\t\t{\n\t\t\t\treplacers[i].predecessorIndex = internalDirectoryLatestReplacerMap[bundleListIndex];\n\t\t\t}\n\t\t\tinternalDirectoryLatestReplacerMap[bundleListIndex] = i;\n\t\t}\n\t\tif (!replacers[i].pReplacer->RequiresEntryReader())\n\t\t{\n\t\t\tif (pReplacers[i]->GetType() != BundleReplacement_Rename)\n\t\t\t{\n\t\t\t\t//Any previous replacer result is not required.\n\t\t\t\t//-> Mark the predecessors as skippable.\n\t\t\t\tsize_t k = replacers[i].predecessorIndex;\n\t\t\t\twhile (k != (size_t)-1)\n\t\t\t\t{\n\t\t\t\t\treplacers[k].skipFlag = true;\n\t\t\t\t\tk = replacers[k].predecessorIndex;\n\t\t\t\t}\n\t\t\t\treplacers[i].predecessorIndex = (size_t) -1;\n\t\t\t}\n\t\t}\n\t\telse if (bundleListIndex >= numOriginalDirectories && replacers[i].predecessorIndex == (size_t)-1)\n\t\t{\n\t\t\t//The replacer cannot be applied, as it is based on previous entry data that doesn\'t exist.\n\t\t\t//Shouldn\'t happen, unless an invalid replacers file is read in.\n\t\t\tassert(false);\n\t\t\treplacers[i].skipFlag = true; //Invalid replacer.\n\t\t\tif (bundleListIndex != (unsigned int)-1)\n\t\t\t{\n\t\t\t\t//Unlink the replacer and remove its generated directory entry.\n\t\t\t\tassert(internalToOutputDirectoryMap[bundleListIndex] != -1);\n\t\t\t\tif (internalToOutputDirectoryMap[bundleListIndex] != -1)\n\t\t\t\t\toutputDirectoryNames.erase(outputDirectoryNames.begin() + internalToOutputDirectoryMap[bundleListIndex]);\n\t\t\t\tinternalToOutputDirectoryMap[bundleListIndex] = (size_t)-1;\n\t\t\t\tfor (size_t k = bundleListIndex + 1; k < internalToOutputDirectoryMap.size(); ++k)\n\t\t\t\t{\n\t\t\t\t\t--internalToOutputDirectoryMap[k];\n\t\t\t\t}\n\t\t\t\t--numOutputDirectories;\n\t\t\t\tinternalDirectoryIndexByName.erase(entryName);\n\t\t\t\tassert(outputDirectoryNames.size() == numOutputDirectories);\n\t\t\t}\n\t\t}\n\t\tif (bundleListIndex == (unsigned int)-1)\n\t\t{\n\t\t\t//Shouldn\'t happen, unless an invalid replacers file is read in.\n\t\t\tassert(false);\n\t\t\treplacers[i].skipFlag = true; //Invalid replacer.\n\t\t}\n\t\treplacers[i].bundleEntryIndex = bundleListIndex;\n\t}\n\t//Prepare the replacers for each output directory entry.\n\tstd::vector<std::shared_ptr<IAssetsReader>> tempReaderReferences;\n\tfor (size_t i = 0; i < internalToOutputDirectoryMap.size(); i++)\n\t{\n\t\tif (internalToOutputDirectoryMap[i] == (size_t)-1)\n\t\t\tcontinue; //Entry was removed.\n\t\tstd::vector<size_t> replacerReverseOrder;\n\t\tsize_t k = internalDirectoryLatestReplacerMap[i];\n\t\twhile (k != (size_t)-1 && !replacers[k].skipFlag)\n\t\t{\n\t\t\tif (replacers[k].pReplacer->GetType() != BundleReplacement_Rename) //Skip renamers here.\n\t\t\t\treplacerReverseOrder.push_back(k);\n\t\t\tk = replacers[k].predecessorIndex;\n\t\t}\n\t\tbool error = false;\n\t\tif (replacerReverseOrder.empty())\n\t\t{\n\t\t\tsize_t outputIndex = internalToOutputDirectoryMap[i];\n\t\t\tif (i >= numOriginalDirectories)\n\t\t\t\terror = true;\n\t\t\telse\n\t\t\t{\n\t\t\t\tassert(outputDirectoryNames.size() > outputIndex);\n\t\t\t\tBundleReplacerInfo newReplacer;\n\t\t\t\tQWORD decompressedSize = 0;\n\t\t\t\tQWORD absolutePos = 0;\n\t\t\t\tif (this->bundleHeader3.fileVersion >= 6)\n\t\t\t\t{\n\t\t\t\t\tdecompressedSize = this->bundleInf6->dirInf[i].decompressedSize;\n\t\t\t\t\tabsolutePos = this->bundleInf6->dirInf[i].GetAbsolutePos(this);\n\t\t\t\t}\n\t\t\t\telse if (this->bundleHeader3.fileVersion == 3)\n\t\t\t\t{\n\t\t\t\t\tdecompressedSize = this->assetsLists3->ppEntries[i]->length;\n\t\t\t\t\tabsolutePos = this->assetsLists3->ppEntries[i]->GetAbsolutePos(this);\n\t\t\t\t}\n\t\t\t\tbool hasSerializedData = this->IsAssetsFile(pReader, i);\n\t\t\t\tnewReplacer.pReplacer = MakeBundleEntryModifier(this->GetEntryName(i), outputDirectoryNames[outputIndex].c_str(), \n\t\t\t\t\thasSerializedData, pReader, NULL, decompressedSize, absolutePos, 16384, (unsigned int)outputIndex);\n\t\t\t\treplacersToDelete.push_back(std::unique_ptr<BundleReplacer, void(*)(BundleReplacer*)>(newReplacer.pReplacer, FreeBundleReplacer));\n\t\t\t\tnewReplacer.bundleEntryIndex = (unsigned int)i;\n\t\t\t\treplacers.push_back(newReplacer);\n\t\t\t\tinternalDirectoryLatestReplacerMap[i] = replacers.size() - 1;\n\t\t\t\treplacerReverseOrder.push_back(replacers.size() - 1);\n\t\t\t}\n\t\t}\n\t\tstd::shared_ptr<IAssetsReader> pInitReader_refholder;\n\t\tIAssetsReader *pInitReader = nullptr;\n\t\tQWORD initSize = 0;\n\t\tQWORD initPos = 0;\n\t\tif (i < numOriginalDirectories && replacers[replacerReverseOrder.back()].pReplacer->RequiresEntryReader())\n\t\t{\n\t\t\tpInitReader = pReader;\n\t\t\tif (this->bundleHeader3.fileVersion >= 6)\n\t\t\t{\n\t\t\t\tinitSize = this->bundleInf6->dirInf[i].decompressedSize;\n\t\t\t\tinitPos = this->bundleInf6->dirInf[i].GetAbsolutePos(this);\n\t\t\t}\n\t\t\telse if (this->bundleHeader3.fileVersion == 3)\n\t\t\t{\n\t\t\t\tinitSize = this->assetsLists3->ppEntries[i]->length;\n\t\t\t\tinitPos = this->assetsLists3->ppEntries[i]->GetAbsolutePos(this);\n\t\t\t}\n\t\t}\n\t\t//Iterate through the replacers (first to last) to initialize them.\n\t\tfor (auto it = replacerReverseOrder.rbegin(); !error && it != replacerReverseOrder.rend(); ++it)\n\t\t{\n\t\t\tsize_t curReplacerIdx = *it;\n\t\t\tBundleReplacerInfo &curReplacer = replacers[curReplacerIdx];\n\t\t\tif (!curReplacer.pReplacer->Init(this, pInitReader, initPos, initSize, typeMeta))\n\t\t\t{\n\t\t\t\terror = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tauto next_it = it; ++next_it;\n\t\t\tif (next_it == replacerReverseOrder.rend())\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tstruct { void operator()(BundleReplacer*){} } dummyDeleter;\n\t\t\tauto pNextReader = MakeReaderFromBundleEntryModifier(std::shared_ptr<BundleReplacer>(curReplacer.pReplacer, dummyDeleter));\n\t\t\tif (pNextReader != nullptr)\n\t\t\t{\n\t\t\t\t//If this is a simple file/memory-based replacer, we can use its internal resource to generate a reader.\n\t\t\t\tcurReplacer.pReplacer->Uninit();\n\t\t\t\tpInitReader_refholder = pNextReader;\n\t\t\t\tpInitReader = pNextReader.get();\n\t\t\t\tif (!pNextReader->Seek(AssetsSeek_End, 0) || !pNextReader->Tell(initSize) || !pNextReader->Seek(AssetsSeek_Begin, 0))\n\t\t\t\t{\n\t\t\t\t\terror = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tinitPos = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t//The replacer appears to be a more complex one, i.e. FromBundle or FromAssets.\n\t\t\t//Write the replaced file to a memory buffer, and proceed using that buffer as input for the next replacer.\n\t\t\tIAssetsWriterToMemory *pTempWriter = Create_AssetsWriterToMemory();\n\t\t\tinitSize = curReplacer.pReplacer->Write(0, pTempWriter);\n\t\t\tcurReplacer.pReplacer->Uninit();\n\t\t\tif (initSize == 0)\n\t\t\t{\n\t\t\t\t//Assume this is an error, as the output should always have a header.\n\t\t\t\tFree_AssetsWriter(pTempWriter);\n\t\t\t\terror = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tvoid *memBuffer = nullptr; size_t memBufferSize = 0;\n\t\t\tif (!pTempWriter->GetBuffer(memBuffer, memBufferSize) || memBufferSize < initSize || !pTempWriter->SetFreeBuffer(false))\n\t\t\t{\n\t\t\t\t//This really shouldn\'t happen.\n\t\t\t\tassert(false);\n\t\t\t\tFree_AssetsWriter(pTempWriter);\n\t\t\t\terror = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tFree_AssetsWriter(pTempWriter);\n\t\t\tinitPos = 0;\n\t\t\tpNextReader.reset(Create_AssetsReaderFromMemory(memBuffer, memBufferSize, false, Free_AssetsWriterToMemory_DynBuf), Free_AssetsReader);\n\t\t\tpInitReader_refholder = pNextReader;\n\t\t\tpInitReader = pNextReader.get();\n\t\t}\n\t\tif (error)\n\t\t{\n\t\t\t//Remove the current directory entry.\n\t\t\tsize_t outputIndex = internalToOutputDirectoryMap[i];\n\t\t\tstd::string entryName = std::move(outputDirectoryNames[outputIndex]);\n\t\t\toutputDirectoryNames.erase(outputDirectoryNames.begin() + outputIndex);\n\t\t\tinternalToOutputDirectoryMap[i] = (size_t)-1;\n\t\t\tfor (size_t k = i + 1; k < internalToOutputDirectoryMap.size(); ++k)\n\t\t\t{\n\t\t\t\t--internalToOutputDirectoryMap[k];\n\t\t\t}\n\t\t\t--numOutputDirectories;\n\t\t\tinternalDirectoryIndexByName.erase(entryName);\n\t\t\tassert(outputDirectoryNames.size() == numOutputDirectories);\n\n\t\t\tstd::string warningMessage = std::string("Error : Unable to prepare the entry modification for entry ") + entryName + ".";\n\t\t\tif (errorLogger) errorLogger(warningMessage.c_str());\n\t\t\tcontinue;\n\t\t}\n\t\t// Unlink any Renamers in front of the last true modifier.\n\t\tinternalDirectoryLatestReplacerMap[i] = replacerReverseOrder.front();\n\t\tif (pInitReader_refholder != nullptr)\n\t\t\ttempReaderReferences.push_back(pInitReader_refholder);\n\t}\n\tstruct _Lambda_FreeReplacers {\n\t\tstd::vector<BundleReplacerInfo> &replacers;\n\t\t_Lambda_FreeReplacers(std::vector<BundleReplacerInfo> &replacers) : replacers(replacers) {}\n\t\tvoid operator()()\n\t\t{\n\t\t\tfor (size_t i = 0; i < replacers.size(); ++i)\n\t\t\t\tif (replacers[i].pReplacer != nullptr) replacers[i].pReplacer->Uninit();\n\t\t}\n\t} lambda_uninitReplacers(replacers);\n\tassert(outputDirectoryNames.size() == numOutputDirectories);\n\tassert(numOutputDirectories <= UINT_MAX);\n\tif (numOutputDirectories > UINT_MAX)\n\t{\n\t\tlambda_uninitReplacers();\n\t\treturn false;\n\t}\n\tif (bundleHeader3.fileVersion >= 6)\n\t{\n\t\t//std::vector<BundleReplacerInfo> orderedReplacers;\n\t\tstd::vector<AssetBundleDirectoryInfo06> directories(numOutputDirectories);\n\t\tstd::vector<AssetBundleBlockInfo06> blocks;\n\t\tQWORD curFilePos = 0;\n\t\tAssetBundleHeader06 header = this->bundleHeader6;\n\t\tif ((header.flags & 0x100) && header.fileVersion == 6)\n\t\t\tstrcpy(header.signature, "UnityWeb"); //Is this accurate for all versions?\n\t\theader.flags &= ~0x3F; //No directory/block list compression.\n\t\theader.flags &= ~0x200; //No alignment of first block.\n\t\theader.flags |= 0x40; //Has directory info.\n\t\theader.Write(pWriter, curFilePos);\n\t\t//Create dummy block info (we don\'t have exact sizes but have to assume that <= or > 4 GiB can be differentiated).\n\t\t//Also assign directory names.\n\t\tfor (size_t i = 0; i < internalToOutputDirectoryMap.size(); i++)\n\t\t{\n\t\t\tsize_t outputDirectoryIdx = internalToOutputDirectoryMap[i];\n\t\t\tif (outputDirectoryIdx == (size_t)-1)\n\t\t\t\tcontinue; //Entry was removed.\n\t\t\tassert(outputDirectoryIdx < numOutputDirectories);\n\t\t\tif (outputDirectoryIdx >= numOutputDirectories)\n\t\t\t{\n\t\t\t\tlambda_uninitReplacers();\n\t\t\t\treturn false;  //Shouldn\'t happen\n\t\t\t}\n\t\t\tdirectories[outputDirectoryIdx].name = outputDirectoryNames[outputDirectoryIdx].c_str();\n\t\t\tsize_t replacerIdx = internalDirectoryLatestReplacerMap[i];\n\t\t\tassert(replacerIdx != (size_t)-1 && !replacers[replacerIdx].skipFlag);\n\t\t\tif (replacerIdx == (size_t)-1 || replacers[replacerIdx].skipFlag)\n\t\t\t{\n\t\t\t\tlambda_uninitReplacers();\n\t\t\t\treturn false;  //Shouldn\'t happen\n\t\t\t}\n\t\t\tBundleReplacerInfo &replacer = replacers[replacerIdx];\n\t\t\tif (replacer.pReplacer->GetType() == BundleReplacement_AddOrModify)\n\t\t\t{\n\t\t\t\tQWORD estimatedSize = replacer.pReplacer->GetSize();\n\t\t\t\twhile (estimatedSize >= 0xFFFFFFFFULL)\n\t\t\t\t{\n\t\t\t\t\tAssetBundleBlockInfo06 dummyBlock = {};\n\t\t\t\t\tblocks.push_back(dummyBlock);\n\t\t\t\t\testimatedSize -= 0xFFFFFFFFULL;\n\t\t\t\t}\n\t\t\t\tif (estimatedSize)\n\t\t\t\t{\n\t\t\t\t\tAssetBundleBlockInfo06 dummyBlock = {};\n\t\t\t\t\tblocks.push_back(dummyBlock);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tQWORD blockAndDirListPos = curFilePos;\n\t\tAssetBundleBlockAndDirectoryList06 blockAndDirList = {};\n\t\tblockAndDirList.blockCount = (uint32_t)blocks.size();\n\t\tblockAndDirList.blockInf = blocks.data();\n\t\tblockAndDirList.directoryCount = (uint32_t)numOutputDirectories;\n\t\tblockAndDirList.dirInf = directories.data();\n\t\tblockAndDirList.Write(pWriter, curFilePos);\n\t\tQWORD bundleDataPos = curFilePos;\n\t\t//Fix the sizes\n\t\theader.compressedSize = header.decompressedSize = (uint32_t)(curFilePos - blockAndDirListPos);\n\t\theader.flags &= ~(0x80);\n\t\tsize_t blockIndex = 0;\n\t\tfor (size_t i = 0; i < internalToOutputDirectoryMap.size(); i++)\n\t\t{\n\t\t\tsize_t outputDirectoryIdx = internalToOutputDirectoryMap[i];\n\t\t\tif (outputDirectoryIdx == (size_t)-1)\n\t\t\t\tcontinue; //Entry was removed.\n\t\t\tsize_t replacerIdx = internalDirectoryLatestReplacerMap[i];\n\t\t\tBundleReplacerInfo &replacer = replacers[replacerIdx];\n\t\t\tif (replacer.pReplacer->GetType() == BundleReplacement_AddOrModify)\n\t\t\t{\n\t\t\t\t//fix the sizes in the directory info\n\t\t\t\tQWORD beginFilePos = curFilePos;\n\t\t\t\tcurFilePos = replacer.pReplacer->Write(curFilePos, pWriter);\n\t\t\t\tif (replacer.pReplacer->HasSerializedData())\n\t\t\t\t\tdirectories[outputDirectoryIdx].flags |= 4;\n\t\t\t\treplacer.pReplacer->Uninit();\n\t\t\t\tdirectories[outputDirectoryIdx].decompressedSize = curFilePos - beginFilePos;\n\t\t\t\tdirectories[outputDirectoryIdx].offset = beginFilePos - header.GetFileDataOffset();\n\t\t\t\t//fix the sizes in the block info\n\t\t\t\tQWORD remainingSize = curFilePos - beginFilePos;\n\t\t\t\twhile (remainingSize >= 0xFFFFFFFFULL)\n\t\t\t\t{\n\t\t\t\t\tif (blocks.size() <= blockIndex)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tblocks[blockIndex].compressedSize = blocks[blockIndex].decompressedSize = 0xFFFFFFFFULL;\n\t\t\t\t\tblocks[blockIndex].flags = 0x40; //TODO: Check if the \'streamed\' flag was set before, because it isn\'t always.\n\t\t\t\t\tblockIndex++;\n\t\t\t\t\tremainingSize -= 0xFFFFFFFFULL;\n\t\t\t\t}\n\t\t\t\tif (remainingSize && (blocks.size() > blockIndex))\n\t\t\t\t{\n\t\t\t\t\tblocks[blockIndex].compressedSize = blocks[blockIndex].decompressedSize = (uint32_t)remainingSize;\n\t\t\t\t\tblocks[blockIndex].flags = 0x40;\n\t\t\t\t\tblockIndex++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\theader.totalFileSize = curFilePos;\n\t\tcurFilePos = 0;\n\t\theader.Write(pWriter, curFilePos);\n\t\tblockAndDirList.blockInf = blocks.data();\n\t\tblockAndDirList.dirInf = directories.data();\n\t\tcurFilePos = blockAndDirListPos;\n\t\tblockAndDirList.Write(pWriter, curFilePos);\n\t\tpWriter->SetPosition(header.totalFileSize);\n\t\treturn true;\n\t}\n\telse if (bundleHeader3.fileVersion == 3)\n\t{\n\t\tstd::vector<AssetBundleEntry*> directories;\n\t\tstd::vector<AssetBundleOffsetPair> blocks;\n\t\t//Create dummy block info\n\t\t//-> The file table gets its own block\n\t\t{\n\t\t\tAssetBundleOffsetPair dummyBlock = {};\n\t\t\tblocks.push_back(dummyBlock);\n\t\t}\n\t\tbool error = false;\n\t\t//Create dummy block info for replacers and also assign directory names.\n\t\tfor (size_t i = 0; i < internalToOutputDirectoryMap.size(); i++)\n\t\t{\n\t\t\tsize_t outputDirectoryIdx = internalToOutputDirectoryMap[i];\n\t\t\tif (outputDirectoryIdx == (size_t)-1)\n\t\t\t\tcontinue; //Entry was removed.\n\t\t\tassert(outputDirectoryIdx < numOutputDirectories);\n\t\t\tif (outputDirectoryIdx >= numOutputDirectories)\n\t\t\t{\n\t\t\t\terror = true;  //Shouldn\'t happen\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tsize_t replacerIdx = internalDirectoryLatestReplacerMap[i];\n\t\t\tassert(replacerIdx != (size_t)-1 && !replacers[replacerIdx].skipFlag);\n\t\t\tif (replacerIdx == (size_t)-1 || replacers[replacerIdx].skipFlag)\n\t\t\t{\n\t\t\t\terror = true;  //Shouldn\'t happen\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tassert(directories.size() == outputDirectoryIdx);\n\n\t\t\tAssetBundleEntry *newDirectory = (AssetBundleEntry*)new uint8_t[8 + sizeof(char) * (outputDirectoryNames[outputDirectoryIdx].size() + 1)];\n\t\t\tnewDirectory->length = newDirectory->offset = 0;\n\t\t\tmemcpy(newDirectory->name, outputDirectoryNames[outputDirectoryIdx].data(), sizeof(char) * (outputDirectoryNames[outputDirectoryIdx].size() + 1));\n\t\t\tdirectories.push_back(newDirectory);\n\t\t\tBundleReplacerInfo &replacer = replacers[replacerIdx];\n\t\t\tif (replacer.pReplacer->GetType() == BundleReplacement_AddOrModify)\n\t\t\t{\n\t\t\t\tQWORD estimatedSize = replacer.pReplacer->GetSize();\n\t\t\t\twhile (estimatedSize >= 0xFFFFFFFFULL)\n\t\t\t\t{\n\t\t\t\t\tAssetBundleOffsetPair dummyBlock = {};\n\t\t\t\t\tblocks.push_back(dummyBlock);\n\t\t\t\t\testimatedSize -= 0xFFFFFFFFULL;\n\t\t\t\t}\n\t\t\t\tif (estimatedSize)\n\t\t\t\t{\n\t\t\t\t\tAssetBundleOffsetPair dummyBlock = {};\n\t\t\t\t\tblocks.push_back(dummyBlock);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (error)\n\t\t{\n\t\t\tfor (size_t i = 0; i < directories.size(); i++)\n\t\t\t{\n\t\t\t\tdelete[] ((uint8_t*)directories[i]);\n\t\t\t}\n\t\t\tlambda_uninitReplacers();\n\t\t\treturn false;\n\t\t}\n\t\tAssetBundleHeader03 header = this->bundleHeader3;\n\t\tQWORD curFilePos = 0;\n\t\theader.blockCount = (uint32_t)blocks.size();\n\t\theader.pBlockList = blocks.data();\n\t\theader.Write(pWriter, curFilePos);\n\n\t\tuint32_t alignBytes = (uint32_t)(((curFilePos + 3) & (~3)) - curFilePos);\n\t\tuint32_t dwNull = 0;\n\t\tpWriter->Write(curFilePos, alignBytes, &dwNull);\n\t\tcurFilePos += alignBytes;\n\n\t\tQWORD assetsListPos = curFilePos;\n\t\tAssetsList assetsList = {};\n\t\tassetsList.allocatedCount = assetsList.count = (uint32_t)directories.size();\n\t\tassetsList.pos = (uint32_t)curFilePos;\n\t\tassetsList.ppEntries = directories.data();\n\t\tassetsList.Write(pWriter, curFilePos);\n\t\t//fix the sizes\n\t\theader.bundleDataOffs = (uint32_t)assetsListPos;\n\t\theader.unknown2 = (uint32_t)(curFilePos - assetsListPos); //not sure if this is right\n\t\tblocks[0].compressed = blocks[0].uncompressed = header.unknown2;\n\t\tsize_t blockIndex = 1;\n\t\tfor (size_t i = 0; i < internalToOutputDirectoryMap.size(); i++)\n\t\t{\n\t\t\tsize_t outputDirectoryIdx = internalToOutputDirectoryMap[i];\n\t\t\tif (outputDirectoryIdx == (size_t)-1)\n\t\t\t\tcontinue; //Entry was removed.\n\t\t\tsize_t replacerIdx = internalDirectoryLatestReplacerMap[i];\n\t\t\tBundleReplacerInfo &replacer = replacers[replacerIdx];\n\t\t\tif (replacer.pReplacer->GetType() == BundleReplacement_AddOrModify)\n\t\t\t{\n\t\t\t\t//align to 4 bytes\n\t\t\t\tuint32_t alignBytes = (uint32_t)(((curFilePos + 3) & (~3)) - curFilePos);\n\t\t\t\tuint32_t dwNull = 0;\n\t\t\t\tpWriter->Write(curFilePos, alignBytes, &dwNull);\n\t\t\t\tcurFilePos += alignBytes;\n\n\t\t\t\tQWORD beginFilePos = curFilePos;\n\t\t\t\tcurFilePos = replacer.pReplacer->Write(curFilePos, pWriter);\n\t\t\t\treplacer.pReplacer->Uninit();\n\t\t\t\t//fix the sizes in the directory info\n\t\t\t\tdirectories[replacer.bundleEntryIndex]->length = (uint32_t)(curFilePos - beginFilePos);\n\t\t\t\tdirectories[replacer.bundleEntryIndex]->offset = (uint32_t)(beginFilePos - header.bundleDataOffs);\n\t\t\t\t//fix the sizes in the block info\n\t\t\t\tQWORD remainingSize = curFilePos - beginFilePos;\n\t\t\t\twhile (remainingSize >= 0xFFFFFFFFULL)\n\t\t\t\t{\n\t\t\t\t\tif (blocks.size() <= blockIndex)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tblocks[blockIndex].compressed = blocks[blockIndex].uncompressed = 0xFFFFFFFFULL;\n\t\t\t\t\tblockIndex++;\n\t\t\t\t\tremainingSize -= 0xFFFFFFFFULL;\n\t\t\t\t}\n\t\t\t\tif (remainingSize && (blocks.size() > blockIndex))\n\t\t\t\t{\n\t\t\t\t\tblocks[blockIndex].compressed = blocks[blockIndex].uncompressed = (uint32_t)((remainingSize + 3) & (~3));\n\t\t\t\t\tblockIndex++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\theader.minimumStreamedBytes = (uint32_t)curFilePos;\n\t\theader.fileSize2 = (uint32_t)curFilePos;\n\t\tcurFilePos = 0;\n\t\theader.pBlockList = blocks.data();\n\t\theader.Write(pWriter, curFilePos);\n\t\tcurFilePos = assetsListPos;\n\t\tassetsList.ppEntries = directories.data();\n\t\tassetsList.Write(pWriter, curFilePos);\n\t\tpWriter->SetPosition(header.fileSize2);\n\t\tfor (size_t i = 0; i < directories.size(); i++)\n\t\t{\n\t\t\tdelete[] ((uint8_t*)directories[i]);\n\t\t}\n\t\treturn true;\n\t}\n\telse //unknown bundle file format\n\t\treturn false;\n}\nASSETSTOOLS_API bool AssetBundleFile::Read(IAssetsReader *pReader, AssetsFileVerifyLogger errorLogger, bool allowCompressed, uint32_t maxFileTableLen)\n{\n\tClose();\n\t//this->reader = reader;\n\tif (!bundleHeader6.ReadInitial(pReader, errorLogger))\n\t\treturn false;\n\tIAssetsReader *pTempReader = nullptr;\n\tif (bundleHeader6.fileVersion >= 6)\n\t{\n\t\tmemset(&bundleHeader6, 0, sizeof(AssetBundleHeader06));\n\t\tif (!bundleHeader6.Read(pReader, errorLogger))\n\t\t\treturn false;\n\t\tif (!strcmp(bundleHeader6.signature, "UnityArchive"))\n\t\t{\n\t\t\t//bundleHeader6.flags &= 0xFFFFFFC0;\n\t\t\tbundleHeader6.flags |= 0x40;\n\t\t}\n\t\telse if (!strcmp(bundleHeader6.signature, "UnityWeb"))\n\t\t{\n\t\t\tstrcpy(bundleHeader6.signature, "UnityFS");\n\t\t\t//bundleHeader6.flags &= 0xFFFFFF80;\n\t\t\tbundleHeader6.flags |= 0x100;\n\t\t\t//bundleHeader6.flags &= ~0x100;\n\t\t}\n\t\telse if (!strcmp(bundleHeader6.signature, "UnityRaw"))\n\t\t{\n\t\t\t//bundleHeader6.flags &= 0xFFFFFFC0;\n\t\t\tbundleHeader6.flags |= 0x40;\n\t\t}\n\n\t\tvoid *fileTableBuf = nullptr;\n\t\tQWORD fileTablePos = bundleHeader6.GetBundleInfoOffset();\n\t\tIAssetsReader *pFileTableReader = pReader;\n\t\tif ((bundleHeader6.flags & 0x3F) != 0)\n\t\t{\n\t\t\tuint8_t compressionType = (bundleHeader6.flags & 0x3F);\n\t\t\tif (compressionType < 4)\n\t\t\t{\n\t\t\t\tfileTableBuf = malloc(bundleHeader6.decompressedSize);\n\t\t\t\tif (!fileTableBuf)\n\t\t\t\t\tgoto __goto_outofmemory;\n\t\t\t\tIAssetsWriter *pTempWriter = Create_AssetsWriterToMemory(fileTableBuf, bundleHeader6.decompressedSize);\n\t\t\t\tif (!pTempWriter)\n\t\t\t\t{\n\t\t\t\t\tfree(fileTableBuf);\n\t\t\t\t\tgoto __goto_outofmemory;\n\t\t\t\t}\n\t\t\t\tpTempReader = Create_AssetsReaderFromMemory(fileTableBuf, bundleHeader6.decompressedSize, false);\n\t\t\t\tif (!pTempReader)\n\t\t\t\t{\n\t\t\t\t\tFree_AssetsWriter(pTempWriter);\n\t\t\t\t\tfree(fileTableBuf);\n\t\t\t\t\tgoto __goto_outofmemory;\n\t\t\t\t}\n\t\t\t\tbool decompressSuccess = false;\n\t\t\t\tQWORD curInPos = fileTablePos;\n\t\t\t\tQWORD curOutPos = 0;\n\t\t\t\tswitch (compressionType)\n\t\t\t\t{\n\t\t\t\tcase 1: //LZMA\n\t\t\t\t\tif (LZMADecompressBlock(&curInPos, &curOutPos, bundleHeader6.compressedSize, pReader, pTempWriter) == SZ_OK)\n\t\t\t\t\t\tdecompressSuccess = true;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2: case 3: //LZ4\n\t\t\t\t\tif (LZ4DecompressBlock(&curInPos, &curOutPos, bundleHeader6.compressedSize, pReader, pTempWriter))\n\t\t\t\t\t\tdecompressSuccess = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tFree_AssetsWriter(pTempWriter);\n\t\t\t\tif (!decompressSuccess || curOutPos != bundleHeader6.decompressedSize)\n\t\t\t\t{\n\t\t\t\t\tFree_AssetsReader(pTempReader);\n\t\t\t\t\tfree(fileTableBuf);\n\t\t\t\t\tif (errorLogger) errorLogger("AssetBundleFile.Read : Failed to decompress the directory!");\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tpFileTableReader = pTempReader;\n\t\t\t\tfileTablePos = 0;\n\t\t\t}\n\t\t}\n\t\tif (fileTableBuf || (bundleHeader6.flags & 0x3F) == 0)\n\t\t{\n\t\t\tbundleInf6 = (AssetBundleBlockAndDirectoryList06*)malloc(sizeof(AssetBundleBlockAndDirectoryList06));\n\t\t\tif (!bundleInf6)\n\t\t\t\tgoto __goto_outofmemory;\n\t\t\tmemset(bundleInf6, 0, sizeof(AssetBundleBlockAndDirectoryList06));\n\t\t\tif (!bundleInf6->Read(fileTablePos, pFileTableReader))\n\t\t\t\tgoto __goto_readerror;\n\t\t\tif (pTempReader)\n\t\t\t{\n\t\t\t\tFree_AssetsReader(pTempReader);\n\t\t\t\tpTempReader = nullptr;\n\t\t\t}\n\t\t\tif (fileTableBuf)\n\t\t\t\tfree(fileTableBuf);\n\t\t}\n\t\telse if (!allowCompressed)\n\t\t{\n\t\t\tClose();\n\t\t\treturn false;\n\t\t}\n\t}\n\telse if (bundleHeader6.fileVersion == 3)\n\t{\n\t\tmemset(&bundleHeader3, 0, sizeof(AssetBundleHeader03));\n\t\tif (!bundleHeader3.Read(pReader, errorLogger))\n\t\t\treturn false;\n\t\tif (!strcmp(bundleHeader3.signature, "UnityRaw")) //compressed bundles only have an uncompressed header\n\t\t{\n\t\t\tQWORD curFilePos = bundleHeader3.bundleDataOffs;\n\t\t\tassetsLists3 = (AssetsList*)malloc(sizeof(AssetsList));\n\t\t\tif (!assetsLists3)\n\t\t\t\tgoto __goto_outofmemory;\n\t\t\tZeroMemory(assetsLists3, sizeof(AssetsList));\n\n\t\t\tQWORD tmpFilePos = curFilePos;\n\t\t\tif (!assetsLists3->Read(pReader, tmpFilePos, errorLogger))\n\t\t\t\tgoto __goto_readerror;\n\t\t\tfor (uint32_t i = 0; i < bundleHeader3.blockCount; i++)\n\t\t\t\tcurFilePos += (bundleHeader3.pBlockList[i].uncompressed + 3) & (~3);\n\t\t}\n\t\telse if (!allowCompressed)\n\t\t{\n\t\t\tClose();\n\t\t\treturn false;\n\t\t}\n\t}\n\telse\n\t{\n\t\tif (errorLogger) errorLogger("AssetBundleFile.Read : Unknown file version!");\n\t\treturn false;\n\t}\n\treturn true;\n\n\t__goto_readerror:\n\tif (errorLogger) errorLogger("AssetBundleFile.Read : A file read error occured!");\n\tgoto __goto_errfreebuffers;\n\t__goto_outofmemory:\n\tif (errorLogger) errorLogger("AssetBundleFile.Read : Out of memory!");\n\tgoto __goto_errfreebuffers;\n\t__goto_errfreebuffers:\n\tif (bundleHeader6.fileVersion == 3)\n\t{\n\t\tif (assetsLists3 != NULL)\n\t\t{\n\t\t\tassetsLists3->Free();\n\t\t\tfree(assetsLists3);\n\t\t}\n\t\tassetsLists3 = NULL;\n\t}\n\telse if (bundleHeader6.fileVersion >= 6)\n\t{\n\t\tif (bundleInf6 != NULL)\n\t\t{\n\t\t\tbundleInf6->Free();\n\t\t\tfree(bundleInf6);\n\t\t}\n\t\tbundleInf6 = NULL;\n\t}\n\tif (pTempReader != nullptr)\n\t{\n\t\tFree_AssetsReader(pTempReader);\n\t}\n\treturn false;\n}\nASSETSTOOLS_API bool AssetBundleFile::IsCompressed()\n{\n\tif (assetsLists3 == NULL || bundleInf6 == NULL) return true;\n\tif (bundleHeader6.fileVersion >= 6)\n\t{\n\t\tfor (uint32_t i = 0; i < bundleInf6->blockCount; i++)\n\t\t{\n\t\t\tif ((bundleInf6->blockInf[i].flags & 0x3F) != 0)\n\t\t\t\treturn true;\n\t\t}\n\t}\n\t//Version 3 bundles are compressed in a single block.\n\treturn false;\n}\nASSETSTOOLS_API bool AssetBundleFile::IsAssetsFile(IAssetsReader *pReader, AssetBundleDirectoryInfo06 *pEntry)\n{\n\tif (pEntry->name)\n\t{\n\t\tsize_t entryNameLen = strlen(pEntry->name);\n\t\tif (entryNameLen >= 5 && !stricmp(&pEntry->name[entryNameLen - 5], ".resS"))\n\t\t\treturn false;\n\t\tif (entryNameLen >= 9 && !stricmp(&pEntry->name[entryNameLen - 9], ".resource"))\n\t\t\treturn false;\n\t}\n\tQWORD pos = pEntry->GetAbsolutePos(this);\n\tchar buf[8];\n\tpReader->Read(pos, 8, buf);\n\t//mdb, sound bank, dll\n\tif (((*(QWORD*)&buf[0]) == 0x45E82623FD7FA614ULL) || !strncmp(buf, "FSB5", 4) || !strncmp(buf, "MZ", 2))\n\t\treturn false;\n\tIAssetsReaderFromReaderRange *pReaderRange = Create_AssetsReaderFromReaderRange(pReader, pos, pEntry->decompressedSize);\n\tif (pReaderRange)\n\t{\n\t\tAssetsFile testAssetsFile(pReaderRange);\n\t\tbool ret = testAssetsFile.VerifyAssetsFile();\n\t\tFree_AssetsReader(pReaderRange);\n\t\treturn ret;\n\t}\n\treturn true;\n}\nASSETSTOOLS_API bool AssetBundleFile::IsAssetsFile(IAssetsReader *pReader, AssetBundleEntry *pEntry)\n{\n\tunsigned int pos = pEntry->GetAbsolutePos(this);\n\tchar buf[8];\n\tpReader->Read(pos, 8, buf);\n\tif (((*(QWORD*)&buf[0]) == 0x45E82623FD7FA614ULL) || !strncmp(buf, "FSB5", 4) || !strncmp(buf, "MZ", 2))\n\t\treturn false;\n\treturn true;\n}\nASSETSTOOLS_API bool AssetBundleFile::IsAssetsFile(IAssetsReader *pReader, size_t entryIdx)\n{\n\tif (bundleHeader6.fileVersion >= 6)\n\t\treturn this->bundleInf6 && this->bundleInf6->directoryCount > entryIdx && IsAssetsFile(pReader, &this->bundleInf6->dirInf[entryIdx]);\n\telse if (bundleHeader6.fileVersion == 3)\n\t\treturn this->assetsLists3 && this->assetsLists3->count > entryIdx && IsAssetsFile(pReader, this->assetsLists3->ppEntries[entryIdx]);\n\treturn false;\n}\nASSETSTOOLS_API IAssetsReader *AssetBundleFile::MakeAssetsFileReader(IAssetsReader *pReader, AssetBundleDirectoryInfo06 *pEntry)\n{\n\tQWORD absoluteEntryPos = pEntry->GetAbsolutePos(this);\n\tQWORD entryLength = pEntry->decompressedSize;\n\treturn Create_AssetsReaderFromReaderRange(pReader, absoluteEntryPos, entryLength);\n}\nASSETSTOOLS_API IAssetsReader *AssetBundleFile::MakeAssetsFileReader(IAssetsReader *pReader, AssetBundleEntry *pEntry)\n{\n\tfor (uint32_t i = 0; i < this->assetsLists3->count; i++)\n\t{\n\t\tif (this->assetsLists3->ppEntries[i] == pEntry)\n\t\t{\n\t\t\tgoto __goto_break;\n\t\t}\n\t}\n\treturn NULL;\n__goto_break:\n\tQWORD absoluteEntryPos = pEntry->GetAbsolutePos(this);\n\tQWORD entryLength = pEntry->length;\n\treturn Create_AssetsReaderFromReaderRange(pReader, absoluteEntryPos, entryLength);\n}\nASSETSTOOLS_API void FreeAssetBundle_FileReader(IAssetsReader *pReader)\n{\n\tFree_AssetsReader(pReader);\n}'