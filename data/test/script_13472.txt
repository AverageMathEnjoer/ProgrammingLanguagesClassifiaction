b'\nimport Data.Maybe (fromJust)\nimport Data.HashMap.Lazy (HashMap)\nimport qualified Data.HashMap.Lazy as M\nimport Control.Monad.State\n\nprepare :: State (HashMap String Double) ()\nprepare = do                                              -- def prepare(d):\n  put M.empty                                             --     d.clear()\n  modify (M.insert "a" 10.33)                             --     d[\'a\'] = 10.33\n  modify (M.insert "c" 20.23)                             --     d[\'c\'] = 20.23\n  one <- gets (M.lookup "a")                              --     one = d.get(\'a\')\n  two <- gets (M.lookup "c")                              --     two = d.get(\'c\')\n  let val = fromJust one + fromJust two                   --     val = one + two\n  modify (M.insert "item" val)                            --     d[\'item\'] = val\n  return ()                                               --     return\n\n\nmethod :: String -> State (HashMap String Double) String\nmethod msg = do                                           -- def method(d, msg):\n  prepare                                                 --     prepare(d)\n  item <- gets (M.lookup "item")                          --     item = d.get(\'item\')\n  return (msg ++ show item)                               --     return msg + repr(item)\n  \n\nmain :: IO ()\nmain = do                                                 -- def main():\n  putStrLn "Enter a message:"                             --     print(\'Enter a message:\')\n  text <- getLine                                         --     text = input()\n  let res = evalState (method text) M.empty               --     res = method(dict(), text)\n  putStrLn ("Result: " ++ res)                            --     print(\'Result: \' + res)\n\n'