b"{-# LANGUAGE Arrows #-}\n{-# LANGUAGE CPP    #-}\n\n#ifdef BEARRIVER\nimport FRP.BearRiver as Yampa\n#else\nimport FRP.Yampa     as Yampa\n#endif\n\nimport Control.Concurrent\nimport Graphics.UI.SDL            as SDL\nimport Graphics.UI.SDL.Primitives as SDL\n\nmain = do\n   SDL.init [InitEverything]\n   SDL.setVideoMode 800 600 32 [SWSurface]\n   reactimate (return ())\n              (\\_ -> return (0.01, Just ()))\n              (\\_ e -> render e >> return False)\n              sf\n\nsf = bouncingBall (100.0 :: Float) 0.0\n\n\nbouncingBall p0 v0 =\n  switch (proc (_) -> do\n            (p,v)  <- fallingBall p0 v0  -< ()\n            bounce <- edge               -< (p <= 0 && v < 0)\n            returnA -< ((p,v), bounce `tag` (p,v))\n         )\n         (\\(p,v) -> bouncingBall p (-v))\n\nfallingBall p0 v0 = proc () -> do\n  v <- (v0 +) ^<< integral          -< (-99.8)\n  p <- (p0 +) ^<< integralLinear v0 -< v\n  returnA -< (p, v)\n\n-- bouncingBall p0 v0 =\n--   switch (fallingBall p0 v0 >>> (arr id &&& whenS (\\(p,v) -> p <= 0 && v < 0)))\n--          (\\(p,v) -> bouncingBall p (-v))\n--\n-- fallingBall p0 v0 = proc () -> do\n--   v <- (v0 +) ^<< integral -< (-9.8)\n--   p <- (p0 +) ^<< integral -< v\n--   returnA -< (p, v)\n--\n-- whenS :: (a -> Bool) -> SF a (Yampa.Event a)\n-- whenS p = (((arr p >>> edge) &&& arr id) >>> (arr (uncurry tag)))\n\nrender (p,_) = do\n  screen <- SDL.getVideoSurface\n\n  white <- SDL.mapRGB (SDL.surfaceGetPixelFormat screen) 0xFF 0xFF 0xFF\n  SDL.fillRect screen Nothing white\n\n  SDL.filledCircle screen 100 (600 - 100 - round p) 30 (Pixel 0xFF0000FF)\n\n  SDL.flip screen\n\n  threadDelay 1000\n\n-- * Auxiliary functions\n\n-- | Integrate a linearly changing input.\n--\n-- Alternative to 'integrate' that is numerically more accurate when\n-- integrating linearly changing inputs. Uses the average between the last\n-- input and the current input as the value to integrate.\n#ifdef BEARRIVER\nintegralLinear :: (Monad m, Fractional s, VectorSpace a s) => a -> SF m a a\n#else\nintegralLinear :: (Fractional s, VectorSpace a s) => a -> SF a a\n#endif\nintegralLinear initial = average >>> integral\n  where\n    -- Average of the current and the last values\n    average = (arr id &&& iPre initial) >>^ (\\(x, y) -> (x ^+^ y) ^/ 2)\n"