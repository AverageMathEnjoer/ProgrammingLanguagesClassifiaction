b'{-# LANGUAGE BangPatterns, CPP #-}\nimport System.Environment\nimport Control.Monad\nimport Control.Seq\n#ifdef NEW_GENERIC\nimport qualified Data.Par as C\n#else\nimport qualified Control.Monad.Par.Combinator as C\n#endif\n\n#ifdef PARSCHED\nimport PARSCHED\n#else\nimport Control.Monad.Par\n#endif\n\nnqueens :: Int -> Par [[Int]]\nnqueens nq = step 0 []\n  where\n    threshold = 5\n\n    step :: Int -> [Int] -> Par [[Int]]\n    step !n b\n       | n >= threshold = return (iterate gen [b] !! (nq - n))\n       | otherwise = do\n          rs <- C.parMapM (step (n+1)) (gen [b])\n          return (concat rs)\n\n    safe :: Int -> Int -> [Int] -> Bool\n    safe x d []    = True\n    safe x d (q:l) = x /= q && x /= q+d && x /= q-d && safe x (d+1) l\n\n    gen :: [[Int]] -> [[Int]]\n    gen bs = [ (q:b) | b <- bs, q <- [1..nq], safe q 1 b ]\n\nnqueensNested :: Int -> [[Int]]\nnqueensNested nq = step 0 []\n  where\n    threshold = 5\n\n    step :: Int -> [Int] -> [[Int]]\n    step !n b\n       | n >= threshold = iterate gen [b] !! (nq - n)\n       | otherwise = \n          let rs = runPar $ C.parMap (step (n+1)) (gen [b])\n          in concat rs\n\n    safe :: Int -> Int -> [Int] -> Bool\n    safe x d []    = True\n    safe x d (q:l) = x /= q && x /= q+d && x /= q-d && safe x (d+1) l\n\n    gen :: [[Int]] -> [[Int]]\n    gen bs = [ (q:b) | b <- bs, q <- [1..nq], safe q 1 b ]\n\n\nmain = do\n    args <- getArgs\t  \n    let (version,n) = case args of \n            []    -> ("monad",8)\n            [v,n] -> (v,read n)\n\n    case version of \n        "nested" -> do \n                putStrLn "Monad-par nested version:"\n                print (length (nqueensNested n))\n        "monad"  -> do \n                putStrLn "Monad-par based version:"\n                print (length (runPar (nqueens n)))\n        _        -> error$ "unknown version: "++version\n\n'