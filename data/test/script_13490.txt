b'/*\n    SPDX-FileCopyrightText: 2019 David Faure <david.faure@kdab.com>\n\n    SPDX-License-Identifier: LGPL-2.1-or-later\n*/\n\n#include "3rdparty/catch.hpp"\n\n#include "analyze/suppressions.h"\n#include "locationdata.h"\n#include "parser.h"\n#include "treemodel.h"\n#include "tst_config.h" // for SRC_DIR\n\n#include <QDebug>\n#include <QSignalSpy>\n\nstd::ostream& operator<<(std::ostream& os, const QString& value)\n{\n    os << value.toStdString();\n    return os;\n}\n\nstruct TestParser\n{\n    TestParser()\n        : spySummary(&parser, &Parser::summaryAvailable)\n        , spyCCD(&parser, &Parser::callerCalleeDataAvailable)\n        , spyBottomUp(&parser, &Parser::bottomUpDataAvailable)\n        , spyTopDown(&parser, &Parser::topDownDataAvailable)\n        , spyFinished(&parser, &Parser::finished)\n    {\n        QObject::connect(&parser, &Parser::bottomUpDataAvailable, &parser,\n                         [this](const auto& data) { resultData = data.resultData; });\n    }\n\n    ~TestParser()\n    {\n        if (spyFinished.isEmpty())\n            REQUIRE(spyFinished.wait(10000));\n    }\n\n    CallerCalleeResults awaitCallerCallee()\n    {\n        if (spyCCD.isEmpty())\n            REQUIRE(spyCCD.wait());\n\n        auto ccr = spyCCD.at(0).at(0).value<CallerCalleeResults>();\n        REQUIRE(ccr.resultData);\n        REQUIRE(ccr.resultData == resultData);\n        return ccr;\n    }\n\n    TreeData awaitBottomUp()\n    {\n        if (spyBottomUp.isEmpty())\n            REQUIRE(spyBottomUp.wait(10000));\n\n        auto bottomUpData = spyBottomUp.at(0).at(0).value<TreeData>();\n        REQUIRE(bottomUpData.resultData);\n        REQUIRE(bottomUpData.resultData == resultData);\n\n        if (qEnvironmentVariableIntValue("HEAPTRACK_DEBUG")) {\n            qDebug() << "Bottom Up Data:";\n            for (const RowData& row : bottomUpData.rows) {\n                qDebug() << symbolToString(row.symbol);\n            }\n        }\n\n        return bottomUpData;\n    }\n\n    TreeData awaitTopDown()\n    {\n        if (spyTopDown.isEmpty())\n            REQUIRE(spyTopDown.wait(10000));\n\n        auto topDownData = spyTopDown.at(0).at(0).value<TreeData>();\n        REQUIRE(topDownData.resultData);\n        REQUIRE(topDownData.resultData == resultData);\n\n        if (qEnvironmentVariableIntValue("HEAPTRACK_DEBUG")) {\n            qDebug() << "Top Down Data:";\n            for (const RowData& row : topDownData.rows) {\n                qDebug() << symbolToString(row.symbol);\n            }\n        }\n\n        return topDownData;\n    }\n\n    SummaryData awaitSummary()\n    {\n        if (spySummary.isEmpty())\n            REQUIRE(spySummary.wait(10000));\n\n        return spySummary.at(0).at(0).value<SummaryData>();\n    }\n\n    Parser parser;\n    std::shared_ptr<const ResultData> resultData;\n\n    QString symbolToString(const Symbol& sym) const\n    {\n        const auto module = resultData->string(sym.moduleId);\n        return resultData->string(sym.functionId) + \'|\' + Util::basename(module) + \'|\' + module;\n    }\n\n    QList<Symbol> sortedSymbols(const CallerCalleeResults& ccr) const\n    {\n        auto ccrSymbolList = ccr.entries.keys();\n        std::sort(ccrSymbolList.begin(), ccrSymbolList.end(), [&](const Symbol& lhs, const Symbol& rhs) {\n            // keep unresolved functions up front\n            auto sortable = [&](const Symbol& symbol) {\n                auto str = [&](StringIndex stringId) { return ccr.resultData->string(stringId); };\n                return std::make_tuple(str(symbol.functionId), str(symbol.moduleId));\n            };\n            return sortable(lhs) < sortable(rhs);\n        });\n        if (qEnvironmentVariableIntValue("HEAPTRACK_DEBUG")) {\n            qDebug() << "Sorted Symbols";\n            int i = 0;\n            for (const Symbol& sym : ccrSymbolList) {\n                qDebug() << i++ << symbolToString(sym);\n            }\n        }\n        return ccrSymbolList;\n    }\n\nprivate:\n    QSignalSpy spySummary;\n    QSignalSpy spyCCD;\n    QSignalSpy spyBottomUp;\n    QSignalSpy spyTopDown;\n    QSignalSpy spyFinished;\n};\n\nTEST_CASE ("heaptrack.david.18594.gz", "[parser]") {\n    TestParser parser;\n\n    FilterParameters params;\n    bool parsedSuppressions = false;\n    params.suppressions = parseSuppressions(SRC_DIR "/suppressions.txt", &parsedSuppressions);\n    REQUIRE(parsedSuppressions);\n\n    parser.parser.parse(SRC_DIR "/heaptrack.david.18594.gz", QString(), params);\n\n    // ---- Check Caller Callee Data\n\n    const auto ccr = parser.awaitCallerCallee();\n    const auto ccrSymbolList = parser.sortedSymbols(ccr);\n\n    // Let\'s check a few items\n    REQUIRE(parser.symbolToString(ccrSymbolList.at(0)) == "<unresolved function>||");\n    REQUIRE(parser.symbolToString(ccrSymbolList.at(1))\n            == "<unresolved function>|ld-linux-x86-64.so.2|/lib64/ld-linux-x86-64.so.2");\n    REQUIRE(parser.symbolToString(ccrSymbolList.at(25))\n            == "QByteArray::constData() const|libQt5Core.so.5|/d/qt/5/kde/build/qtbase/lib/libQt5Core.so.5");\n    const int lastIndx = ccrSymbolList.size() - 1;\n    REQUIRE(parser.symbolToString(ccrSymbolList.at(lastIndx))\n            == "~QVarLengthArray|libQt5Core.so.5|/d/qt/5/kde/build/qtbase/lib/libQt5Core.so.5");\n\n    REQUIRE(ccr.entries.count() == 365);\n    REQUIRE(ccr.resultData->totalCosts().allocations == 2896);\n\n    // ---- Check Bottom Up Data\n\n    const auto bottomUpData = parser.awaitBottomUp();\n\n    REQUIRE(bottomUpData.rows.size() == 54);\n    REQUIRE(parser.symbolToString(bottomUpData.rows.at(3).symbol)\n            == "<unresolved function>|libglib-2.0.so.0|/usr/lib64/libglib-2.0.so.0");\n    REQUIRE(bottomUpData.rows.at(3).children.size() == 2);\n    REQUIRE(bottomUpData.rows.at(3).cost.allocations == 17);\n    REQUIRE(bottomUpData.rows.at(3).cost.peak == 2020);\n    REQUIRE(parser.symbolToString(bottomUpData.rows.at(53).symbol)\n            == "QThreadPool::QThreadPool(QObject*)|libQt5Core.so.5|/d/qt/5/kde/build/qtbase/lib/libQt5Core.so.5");\n\n    // ---- Check Top Down Data\n\n    const auto topDownData = parser.awaitTopDown();\n    REQUIRE(topDownData.rows.size() == 5);\n    REQUIRE(parser.symbolToString(topDownData.rows.at(2).symbol)\n            == "<unresolved function>|ld-linux-x86-64.so.2|/lib64/ld-linux-x86-64.so.2");\n    REQUIRE(topDownData.rows.at(2).children.size() == 1);\n    REQUIRE(topDownData.rows.at(2).cost.allocations == 15);\n    REQUIRE(topDownData.rows.at(2).cost.peak == 94496);\n\n    // ---- Check Summary\n\n    const auto summary = parser.awaitSummary();\n    REQUIRE(summary.debuggee == "./david");\n    REQUIRE(summary.cost.allocations == 2896);\n    REQUIRE(summary.cost.temporary == 729);\n    REQUIRE(summary.cost.leaked == 0);\n    REQUIRE(summary.totalLeakedSuppressed == 30463);\n    REQUIRE(summary.cost.peak == 996970);\n    REQUIRE(summary.totalTime == 80);\n    REQUIRE(summary.peakRSS == 76042240);\n    REQUIRE(summary.peakTime == 0);\n    REQUIRE(summary.totalSystemMemory == 16715239424);\n    REQUIRE(summary.fromAttached == false);\n}\n\nTEST_CASE ("heaptrack.embedded_lsan_suppressions.84207.zst", "[parser]") {\n    TestParser parser;\n\n    parser.parser.parse(SRC_DIR "/heaptrack.embedded_lsan_suppressions.84207.zst", QString(), {});\n\n    const auto summary = parser.awaitSummary();\n    REQUIRE(summary.debuggee == "./tests/manual/embedded_lsan_suppressions");\n    REQUIRE(summary.cost.allocations == 5);\n    REQUIRE(summary.cost.temporary == 0);\n    REQUIRE(summary.cost.leaked == 5);\n    REQUIRE(summary.totalLeakedSuppressed == 5);\n    REQUIRE(summary.cost.peak == 72714);\n    REQUIRE(summary.totalSystemMemory == 33643876352);\n}\n\nTEST_CASE ("heaptrack.embedded_lsan_suppressions.84207.zst without suppressions", "[parser]") {\n    TestParser parser;\n\n    FilterParameters params;\n    params.disableEmbeddedSuppressions = true;\n    parser.parser.parse(SRC_DIR "/heaptrack.embedded_lsan_suppressions.84207.zst", QString(), params);\n\n    const auto summary = parser.awaitSummary();\n    REQUIRE(summary.debuggee == "./tests/manual/embedded_lsan_suppressions");\n    REQUIRE(summary.cost.allocations == 5);\n    REQUIRE(summary.cost.leaked == 10);\n    REQUIRE(summary.totalLeakedSuppressed == 0);\n}\n\nTEST_CASE ("heaptrack.heaptrack_gui.99454.zst", "[parser]") {\n    TestParser parser;\n\n    FilterParameters params;\n    params.disableBuiltinSuppressions = true;\n\n    parser.parser.parse(SRC_DIR "/heaptrack.heaptrack_gui.99454.zst", QString(), params);\n\n    const auto summary = parser.awaitSummary();\n    REQUIRE(summary.debuggee == "heaptrack_gui heaptrack.trest_c.78689.zst");\n    REQUIRE(summary.cost.allocations == 278534);\n    REQUIRE(summary.cost.temporary == 35481);\n    REQUIRE(summary.cost.leaked == 1047379);\n    REQUIRE(summary.cost.peak == 12222213);\n\n    const auto ccr = parser.awaitCallerCallee();\n    const auto sortedSymbols = parser.sortedSymbols(ccr);\n\n    const auto& sym = sortedSymbols[994];\n    REQUIRE(parser.symbolToString(sym) == "QHashData::allocateNode(int)|libQt5Core.so.5|/usr/lib/libQt5Core.so.5");\n    const auto& cost = ccr.entries[sym];\n    CHECK(cost.inclusiveCost.allocations == 5214);\n    CHECK(cost.inclusiveCost.temporary == 0);\n    CHECK(cost.inclusiveCost.leaked == 32);\n    CHECK(cost.inclusiveCost.peak == 56152);\n    CHECK(cost.selfCost.allocations == 5214);\n    CHECK(cost.selfCost.temporary == 0);\n    CHECK(cost.selfCost.leaked == 32);\n    CHECK(cost.selfCost.peak == 56152);\n}\n\nTEST_CASE ("heaptrack.heaptrack_gui.99529.zst", "[parser]") {\n    TestParser parser;\n\n    FilterParameters params;\n    params.disableBuiltinSuppressions = true;\n\n    parser.parser.parse(SRC_DIR "/heaptrack.heaptrack_gui.99529.zst", QString(), params);\n\n    const auto summary = parser.awaitSummary();\n    REQUIRE(summary.debuggee == "heaptrack_gui heaptrack.test_c.78689.zst");\n    REQUIRE(summary.cost.allocations == 315255);\n    REQUIRE(summary.cost.temporary == 40771);\n    REQUIRE(summary.cost.leaked == 1046377);\n    REQUIRE(summary.cost.peak == 64840134);\n\n    const auto ccr = parser.awaitCallerCallee();\n    const auto sortedSymbols = parser.sortedSymbols(ccr);\n\n    const auto& sym = sortedSymbols[1103];\n    REQUIRE(parser.symbolToString(sym) == "QHashData::allocateNode(int)|libQt5Core.so.5|/usr/lib/libQt5Core.so.5");\n    const auto& cost = ccr.entries[sym];\n    CHECK(cost.inclusiveCost.allocations == 5559);\n    CHECK(cost.inclusiveCost.temporary == 0);\n    CHECK(cost.inclusiveCost.leaked == 32);\n    CHECK(cost.inclusiveCost.peak == 68952);\n    CHECK(cost.selfCost.allocations == 5559);\n    CHECK(cost.selfCost.temporary == 0);\n    CHECK(cost.selfCost.leaked == 32);\n    CHECK(cost.selfCost.peak == 68952);\n}\n\nTEST_CASE ("heaptrack.heaptrack_gui.{99454,99529}.zst diff", "[parser]") {\n    TestParser parser;\n\n    parser.parser.parse(SRC_DIR "/heaptrack.heaptrack_gui.99529.zst", SRC_DIR "/heaptrack.heaptrack_gui.99454.zst", {});\n\n    const auto summary = parser.awaitSummary();\n    REQUIRE(summary.debuggee == "heaptrack_gui heaptrack.test_c.78689.zst");\n    REQUIRE(summary.cost.allocations == 36721);\n    REQUIRE(summary.cost.temporary == 5290);\n    REQUIRE(summary.cost.leaked == -1002);\n    REQUIRE(summary.cost.peak == 52617921);\n\n    const auto ccr = parser.awaitCallerCallee();\n    const auto sortedSymbols = parser.sortedSymbols(ccr);\n\n    const auto& sym = sortedSymbols[545];\n    REQUIRE(parser.symbolToString(sym) == "QHashData::allocateNode(int)|libQt5Core.so.5|/usr/lib/libQt5Core.so.5");\n    const auto& cost = ccr.entries[sym];\n    CHECK(cost.inclusiveCost.allocations == (5559 - 5214));\n    CHECK(cost.inclusiveCost.temporary == 0);\n    CHECK(cost.inclusiveCost.leaked == 0);\n    CHECK(cost.inclusiveCost.peak == (68952 - 56152));\n    CHECK(cost.selfCost.allocations == (5559 - 5214));\n    CHECK(cost.selfCost.temporary == 0);\n    CHECK(cost.selfCost.leaked == 0);\n    CHECK(cost.selfCost.peak == ((68952 - 56152)));\n}\n\nint main(int argc, char** argv)\n{\n    QCoreApplication app(argc, argv);\n\n    qRegisterMetaType<CallerCalleeResults>();\n\n    const int res = Catch::Session().run(argc, argv);\n    return (res < 0xff ? res : 0xff);\n}\n'