b'{-# LANGUAGE NoImplicitPrelude #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n\nmodule Course.ListZipper where\n\nimport Course.Core\nimport Course.List\nimport Course.Optional\nimport Course.Functor\nimport Course.Applicative\nimport Course.Extend\nimport Course.Comonad\nimport Course.Traversable\nimport qualified Prelude as P\n\n-- $setup\n-- >>> import Test.QuickCheck\n-- >>> import Data.Maybe(maybe)\n-- >>> import Course.Core\n-- >>> import qualified Prelude as P\n-- >>> let optional e _ Empty = e; optional _ f (Full a) = f a\n-- >>> instance Arbitrary a => Arbitrary (Optional a) where arbitrary = P.fmap (maybe Empty Full) arbitrary\n-- >>> instance Arbitrary a => Arbitrary (List a) where arbitrary = P.fmap (P.foldr (:.) Nil :: ([a] -> List a)) arbitrary\n-- >>> instance Arbitrary a => Arbitrary (ListZipper a) where arbitrary = do l <- arbitrary; x <- arbitrary; r <- arbitrary; P.return (ListZipper l x r)\n\n-- A `ListZipper` is a focussed position, with a list of values to the left and to the right.\n--\n-- For example, taking the list [0,1,2,3,4,5,6], the moving focus to the third position, the zipper looks like:\n-- ListZipper [2,1,0] 3 [4,5,6]\n--\n-- Supposing then we move left on this zipper:\n-- ListZipper [1,0] 2 [3,4,5,6]\n--\n-- then suppose we add 17 to the focus of this zipper:\n-- ListZipper [1,0] 19 [3,4,5,6]\ndata ListZipper a =\n  ListZipper (List a) a (List a)\n  deriving Eq\n\nlefts ::\n  ListZipper a\n  -> List a\nlefts (ListZipper l _ _) =\n  l\n\nrights ::\n  ListZipper a\n  -> List a\nrights (ListZipper _ _ r) =\n  r\n\n-- A `MaybeListZipper` is a data structure that allows us to "fail" zipper operations.\n-- e.g. Moving left when there are no values to the left.\n--\n-- We then overload operations polymorphically to operate on both `ListZipper` and `MaybeListZipper`\n-- using the `ListZipper\'` type-class below.\ndata MaybeListZipper a =\n  IsZ (ListZipper a)\n  | IsNotZ\n  deriving Eq\n\n-- | Implement the `Functor` instance for `ListZipper`.\n--\n-- >>> (+1) <$> (zipper [3,2,1] 4 [5,6,7])\n-- [4,3,2] >5< [6,7,8]\ninstance Functor ListZipper where\n  (<$>) =\n    error "todo: Course.ListZipper (<$>)#instance ListZipper"\n\n-- | Implement the `Functor` instance for `MaybeListZipper`.\n--\n-- >>> (+1) <$> (IsZ (zipper [3,2,1] 4 [5,6,7]))\n-- [4,3,2] >5< [6,7,8]\ninstance Functor MaybeListZipper where\n  (<$>) =\n    error "todo: Course.ListZipper (<$>)#instance MaybeListZipper"\n\n-- | Convert the given zipper back to a list.\n--\n-- >>> toList <$> toOptional (fromList Nil)\n-- Empty\n--\n-- >>> toList (ListZipper Nil 1 (2:.3:.4:.Nil))\n-- [1,2,3,4]\n--\n-- >>> toList (ListZipper (3:.2:.1:.Nil) 4 (5:.6:.7:.Nil))\n-- [1,2,3,4,5,6,7]\ntoList ::\n  ListZipper a\n  -> List a\ntoList =\n  error "todo: Course.ListZipper#toList"\n\n-- | Convert the given (maybe) zipper back to a list.\ntoListZ ::\n  MaybeListZipper a\n  -> List a\ntoListZ IsNotZ =\n  Nil\ntoListZ (IsZ z) =\n  toList z\n\n-- | Create a `MaybeListZipper` positioning the focus at the head.\n--\n-- ->>> fromList (1 :. 2 :. 3 :. Nil)\n-- [] >1< [2,3]\n--\n-- >>> fromList Nil\n-- ><\n--\n-- prop> \\xs -> xs == toListZ (fromList xs)\nfromList ::\n  List a\n  -> MaybeListZipper a\nfromList =\n  error "todo: Course.ListZipper#fromList"\n\n-- | Retrieve the `ListZipper` from the `MaybeListZipper` if there is one.\n--\n-- prop> \\xs -> isEmpty xs == (toOptional (fromList xs) == Empty)\n--\n-- prop> \\z -> toOptional (fromOptional z) == z\ntoOptional ::\n  MaybeListZipper a\n  -> Optional (ListZipper a)\ntoOptional =\n  error "todo: Course.ListZipper#toOptional"\n\nzipper ::\n  [a]\n  -> a\n  -> [a]\n  -> ListZipper a\nzipper l x r =\n  ListZipper (listh l) x (listh r)\n\nfromOptional ::\n  Optional (ListZipper a)\n  -> MaybeListZipper a\nfromOptional Empty =\n  IsNotZ\nfromOptional (Full z) =\n  IsZ z\n\nasZipper ::\n  (ListZipper a -> ListZipper a)\n  -> MaybeListZipper a\n  -> MaybeListZipper a\nasZipper f =\n  asMaybeZipper (IsZ . f)\n\n(>$>)::\n  (ListZipper a -> ListZipper a)\n  -> MaybeListZipper a\n  -> MaybeListZipper a\n(>$>) =\n  asZipper\n\nasMaybeZipper ::\n  (ListZipper a -> MaybeListZipper a)\n  -> MaybeListZipper a\n  -> MaybeListZipper a\nasMaybeZipper _ IsNotZ =\n  IsNotZ\nasMaybeZipper f (IsZ z) =\n  f z\n\n(-<<) ::\n  (ListZipper a -> MaybeListZipper a)\n  -> MaybeListZipper a\n  -> MaybeListZipper a\n(-<<) =\n  asMaybeZipper\n\n-- | Update the focus of the zipper with the given function on the current focus.\n--\n-- >>> withFocus (+1) (zipper [] 0 [1])\n-- [] >1< [1]\n--\n-- >>> withFocus (+1) (zipper [1,0] 2 [3,4])\n-- [1,0] >3< [3,4]\nwithFocus ::\n  (a -> a)\n  -> ListZipper a\n  -> ListZipper a\nwithFocus =\n  error "todo: Course.ListZipper#withFocus"\n\n-- | Set the focus of the zipper to the given value.\n-- /Tip:/ Use `withFocus`.\n--\n-- >>> setFocus 1 (zipper [] 0 [1])\n-- [] >1< [1]\n--\n-- >>> setFocus 1 (zipper [1,0] 2 [3,4])\n-- [1,0] >1< [3,4]\nsetFocus ::\n  a\n  -> ListZipper a\n  -> ListZipper a\nsetFocus =\n  error "todo: Course.ListZipper#setFocus"\n\n-- A flipped infix alias for `setFocus`. This allows:\n--\n-- z .= "abc" -- sets the focus on the zipper z to the value "abc".\n(.=) ::\n  ListZipper a\n  -> a\n  -> ListZipper a\n(.=) =\n  flip setFocus\n\n-- | Returns whether there are values to the left of focus.\n--\n-- >>> hasLeft (zipper [1,0] 2 [3,4])\n-- True\n--\n-- >>> hasLeft (zipper [] 0 [1,2])\n-- False\nhasLeft ::\n  ListZipper a\n  -> Bool\nhasLeft =\n  error "todo: Course.ListZipper#hasLeft"\n\n-- | Returns whether there are values to the right of focus.\n--\n-- >>> hasRight (zipper [1,0] 2 [3,4])\n-- True\n--\n-- >>> hasRight (zipper [1,0] 2 [])\n-- False\nhasRight ::\n  ListZipper a\n  -> Bool\nhasRight =\n  error "todo: Course.ListZipper#hasRight"\n\n-- | Seek to the left for a location matching a predicate, starting from the\n-- current one.\n--\n-- /Tip:/ Use `break`\n--\n-- prop> \\xs p -> findLeft (const p) -<< fromList xs == IsNotZ\n--\n-- >>> findLeft (== 1) (zipper [2, 1] 3 [4, 5])\n-- [] >1< [2,3,4,5]\n--\n-- >>> findLeft (== 6) (zipper [2, 1] 3 [4, 5])\n-- ><\n--\n-- >>> findLeft (== 1) (zipper [2, 1] 1 [4, 5])\n-- [] >1< [2,1,4,5]\n--\n-- >>> findLeft (== 1) (zipper [1, 2, 1] 3 [4, 5])\n-- [2,1] >1< [3,4,5]\n--\n-- >>> findLeft (== 1) (zipper [3, 4, 1, 5] 9 [2, 7])\n-- [5] >1< [4,3,9,2,7]\nfindLeft ::\n  (a -> Bool)\n  -> ListZipper a\n  -> MaybeListZipper a\nfindLeft =\n  error "todo: Course.ListZipper#findLeft"\n    \n-- | Seek to the right for a location matching a predicate, starting from the\n-- current one.\n--\n-- /Tip:/ Use `break`\n--\n-- prop> \\xs -> findRight (const False) -<< fromList xs == IsNotZ\n--\n-- >>> findRight (== 5) (zipper [2, 1] 3 [4, 5])\n-- [4,3,2,1] >5< []\n--\n-- >>> findRight (== 6) (zipper [2, 1] 3 [4, 5])\n-- ><\n--\n-- >>> findRight (== 1) (zipper [2, 3] 1 [4, 5, 1])\n-- [5,4,1,2,3] >1< []\n--\n-- >>> findRight (== 1) (zipper [2, 3] 1 [1, 4, 5, 1])\n-- [1,2,3] >1< [4,5,1]\nfindRight ::\n  (a -> Bool)\n  -> ListZipper a\n  -> MaybeListZipper a\nfindRight =\n  error "todo: Course.ListZipper#findRight"\n\n-- | Move the zipper left, or if there are no elements to the left, go to the far right.\n--\n-- >>> moveLeftLoop (zipper [3,2,1] 4 [5,6,7])\n-- [2,1] >3< [4,5,6,7]\n--\n-- >>> moveLeftLoop (zipper [] 1 [2,3,4])\n-- [3,2,1] >4< []\nmoveLeftLoop ::\n  ListZipper a\n  -> ListZipper a\nmoveLeftLoop =\n  error "todo: Course.ListZipper#moveLeftLoop"\n\n-- | Move the zipper right, or if there are no elements to the right, go to the far left.\n--\n-- >>> moveRightLoop (zipper [3,2,1] 4 [5,6,7])\n-- [4,3,2,1] >5< [6,7]\n--\n-- >>> moveRightLoop (zipper [3,2,1] 4 [])\n-- [] >1< [2,3,4]\nmoveRightLoop ::\n  ListZipper a\n  -> ListZipper a\nmoveRightLoop =\n  error "todo: Course.ListZipper#moveRightLoop"\n\n-- | Move the zipper one position to the left.\n--\n-- >>> moveLeft (zipper [3,2,1] 4 [5,6,7])\n-- [2,1] >3< [4,5,6,7]\n--\n-- >>> moveLeft (zipper [] 1 [2,3,4])\n-- ><\nmoveLeft ::\n  ListZipper a\n  -> MaybeListZipper a\nmoveLeft =\n  error "todo: Course.ListZipper#moveLeft"\n\n-- | Move the zipper one position to the right.\n--\n-- >>> moveRight (zipper [3,2,1] 4 [5,6,7])\n-- [4,3,2,1] >5< [6,7]\n--\n-- >>> moveRight (zipper [3,2,1] 4 [])\n-- ><\nmoveRight ::\n  ListZipper a\n  -> MaybeListZipper a\nmoveRight =\n  error "todo: Course.ListZipper#moveRight"\n\n-- | Swap the current focus with the value to the left of focus.\n--\n-- >>> swapLeft (zipper [3,2,1] 4 [5,6,7])\n-- [4,2,1] >3< [5,6,7]\n--\n-- >>> swapLeft (zipper [] 1 [2,3,4])\n-- ><\nswapLeft ::\n  ListZipper a\n  -> MaybeListZipper a\nswapLeft =\n  error "todo: Course.ListZipper#swapLeft"\n\n-- | Swap the current focus with the value to the right of focus.\n--\n-- >>> swapRight (zipper [3,2,1] 4 [5,6,7])\n-- [3,2,1] >5< [4,6,7]\n--\n-- >>> swapRight (zipper [3,2,1] 4 [])\n-- ><\nswapRight ::\n  ListZipper a\n  -> MaybeListZipper a\nswapRight =\n  error "todo: Course.ListZipper#swapRight"\n\n-- | Drop all values to the left of the focus.\n--\n-- >>> dropLefts (zipper [3,2,1] 4 [5,6,7])\n-- [] >4< [5,6,7]\n--\n-- >>> dropLefts (zipper [] 1 [2,3,4])\n-- [] >1< [2,3,4]\n--\n-- prop> \\l x r -> dropLefts (zipper l x r) == zipper [] x r\ndropLefts ::\n  ListZipper a\n  -> ListZipper a\ndropLefts =\n  error "todo: Course.ListZipper#dropLefts"\n\n-- | Drop all values to the right of the focus.\n--\n-- >>> dropRights (zipper [3,2,1] 4 [5,6,7])\n-- [3,2,1] >4< []\n--\n-- >>> dropRights (zipper [3,2,1] 4 [])\n-- [3,2,1] >4< []\n--\n-- prop> \\l x r -> dropRights (zipper l x r) == zipper l x []\ndropRights ::\n  ListZipper a\n  -> ListZipper a\ndropRights =\n  error "todo: Course.ListZipper#dropRights"\n\n-- | Move the focus left the given number of positions. If the value is negative, move right instead.\n--\n-- >>> moveLeftN 2 (zipper [2,1,0] 3 [4,5,6])\n-- [0] >1< [2,3,4,5,6]\n--\n-- >>> moveLeftN (-1) $ zipper [2,1,0] 3 [4,5,6]\n-- [3,2,1,0] >4< [5,6]\nmoveLeftN ::\n  Int\n  -> ListZipper a\n  -> MaybeListZipper a\nmoveLeftN =\n  error "todo: Course.ListZipper#moveLeftN"\n\n-- | Move the focus right the given number of positions. If the value is negative, move left instead.\n--\n-- >>> moveRightN 1 (zipper [2,1,0] 3 [4,5,6])\n-- [3,2,1,0] >4< [5,6]\n--\n-- >>> moveRightN (-1) $ zipper [2,1,0] 3 [4,5,6]\n-- [1,0] >2< [3,4,5,6]\nmoveRightN ::\n  Int\n  -> ListZipper a\n  -> MaybeListZipper a\nmoveRightN =\n  error "todo: Course.ListZipper#moveRightN"\n\n-- | Move the focus left the given number of positions. If the value is negative, move right instead.\n-- If the focus cannot be moved, the given number of times, return the value by which it can be moved instead.\n--\n-- >>> moveLeftN\' 4 (zipper [3,2,1] 4 [5,6,7])\n-- Left 3\n--\n-- >>> moveLeftN\' 1 (zipper [3,2,1] 4 [5,6,7])\n-- Right [2,1] >3< [4,5,6,7]\n--\n-- >>> moveLeftN\' 0 (zipper [3,2,1] 4 [5,6,7])\n-- Right [3,2,1] >4< [5,6,7]\n--\n-- >>> moveLeftN\' (-2) (zipper [3,2,1] 4 [5,6,7])\n-- Right [5,4,3,2,1] >6< [7]\n--\n-- >>> moveLeftN\' (-4) (zipper [3,2,1] 4 [5,6,7])\n-- Left 3\n--\n-- >>> moveLeftN\' 4 (zipper [3,2,1] 4 [5,6,7,8,9])\n-- Left 3\n--\n-- >>> moveLeftN\' (-4) (zipper [5,4,3,2,1] 6 [7,8,9])\n-- Left 3\nmoveLeftN\' ::\n  Int\n  -> ListZipper a\n  -> Either Int (ListZipper a)\nmoveLeftN\' =\n  error "todo: Course.ListZipper#moveLeftN\'"\n\n-- | Move the focus right the given number of positions. If the value is negative, move left instead.\n-- If the focus cannot be moved, the given number of times, return the value by which it can be moved instead.\n--\n-- >>> moveRightN\' 4 (zipper [3,2,1] 4 [5,6,7])\n-- Left 3\n--\n-- >>> moveRightN\' 1 (zipper [3,2,1] 4 [5,6,7])\n-- Right [4,3,2,1] >5< [6,7]\n--\n-- >>> moveRightN\' 0 (zipper [3,2,1] 4 [5,6,7])\n-- Right [3,2,1] >4< [5,6,7]\n--\n-- >>> moveRightN\' (-2) (zipper [3,2,1] 4 [5,6,7])\n-- Right [1] >2< [3,4,5,6,7]\n--\n-- >>> moveRightN\' (-4) (zipper [3,2,1] 4 [5,6,7])\n-- Left 3\nmoveRightN\' ::\n  Int\n  -> ListZipper a\n  -> Either Int (ListZipper a)\nmoveRightN\' =\n  error "todo: Course.ListZipper#moveRightN\'"\n\n-- | Move the focus to the given absolute position in the zipper. Traverse the zipper only to the extent required.\n--\n-- >>> nth 1 (zipper [3,2,1] 4 [5,6,7])\n-- [1] >2< [3,4,5,6,7]\n--\n-- >>> nth 5 (zipper [3,2,1] 4 [5,6,7])\n-- [5,4,3,2,1] >6< [7]\n--\n-- >>> nth 8 (zipper [3,2,1] 4 [5,6,7])\n-- ><\nnth ::\n  Int\n  -> ListZipper a\n  -> MaybeListZipper a\nnth =\n  error "todo: Course.ListZipper#nth"\n\n-- | Return the absolute position of the current focus in the zipper.\n--\n-- >>> index (zipper [3,2,1] 4 [5,6,7])\n-- 3\n--\n-- prop> \\i z z\' -> optional True (\\z\' -> index z\' == i) (toOptional (nth i z))\nindex ::\n  ListZipper a\n  -> Int\nindex =\n  error "todo: Course.ListZipper#index"\n\n-- | Move the focus to the end of the zipper.\n--\n-- >>> end (zipper [3,2,1] 4 [5,6,7])\n-- [6,5,4,3,2,1] >7< []\n--\n-- prop> \\lz -> toList lz == toList (end lz)\n--\n-- prop> \\lz -> rights (end lz) == Nil\nend ::\n  ListZipper a\n  -> ListZipper a\nend =\n  error "todo: Course.ListZipper#end"\n\n-- | Move the focus to the start of the zipper.\n--\n-- >>> start (zipper [3,2,1] 4 [5,6,7])\n-- [] >1< [2,3,4,5,6,7]\n--\n-- prop> \\lz -> toList lz == toList (start lz)\n--\n-- prop> \\lz -> lefts (start lz) == Nil\nstart ::\n  ListZipper a\n  -> ListZipper a\nstart =\n  error "todo: Course.ListZipper#start"\n\n-- | Delete the current focus and pull the left values to take the empty position.\n--\n-- >>> deletePullLeft (zipper [3,2,1] 4 [5,6,7])\n-- [2,1] >3< [5,6,7]\n--\n-- >>> deletePullLeft (zipper [] 1 [2,3,4])\n-- ><\ndeletePullLeft ::\n  ListZipper a\n  -> MaybeListZipper a\ndeletePullLeft =\n  error "todo: Course.ListZipper#deletePullLeft"\n\n-- | Delete the current focus and pull the right values to take the empty position.\n--\n-- >>> deletePullRight (zipper [3,2,1] 4 [5,6,7])\n-- [3,2,1] >5< [6,7]\n--\n-- >>> deletePullRight (zipper [3,2,1] 4 [])\n-- ><\ndeletePullRight ::\n  ListZipper a\n  -> MaybeListZipper a\ndeletePullRight =\n  error "todo: Course.ListZipper#deletePullRight"\n\n-- | Insert at the current focus and push the left values to make way for the new position.\n--\n-- >>> insertPushLeft 15 (zipper [3,2,1] 4 [5,6,7])\n-- [4,3,2,1] >15< [5,6,7]\n--\n-- >>> insertPushLeft 15 (zipper [] 1 [2,3,4])\n-- [1] >15< [2,3,4]\n--\n-- prop> \\i z -> optional False (==z) (toOptional (deletePullLeft (insertPushLeft i z)))\ninsertPushLeft ::\n  a\n  -> ListZipper a\n  -> ListZipper a\ninsertPushLeft =\n  error "todo: Course.ListZipper#insertPushLeft"\n\n-- | Insert at the current focus and push the right values to make way for the new position.\n--\n-- >>> insertPushRight 15 (zipper [3,2,1] 4 [5,6,7])\n-- [3,2,1] >15< [4,5,6,7]\n--\n-- >>> insertPushRight 15 (zipper [3,2,1] 4 [])\n-- [3,2,1] >15< [4]\n--\n-- prop> \\i z -> optional False (==z) (toOptional (deletePullRight (insertPushRight i z)))\ninsertPushRight ::\n  a\n  -> ListZipper a\n  -> ListZipper a\ninsertPushRight =\n  error "todo: Course.ListZipper#insertPushRight"\n\n-- | Implement the `Applicative` instance for `ListZipper`.\n-- `pure` produces an infinite list zipper (to both left and right).\n-- (<*>) zips functions with values by function application.\n--\n-- prop> \\n -> all . (==) <*> take n . lefts . pure\n--\n-- prop> \\n -> all . (==) <*> take n . rights . pure\n--\n-- >>> zipper [(+2), (+10)] (*2) [(*3), (4*), (5+)] <*> zipper [3,2,1] 4 [5,6,7]\n-- [5,12] >8< [15,24,12]\ninstance Applicative ListZipper where\n-- /Tip:/ Use @List#repeat@.\n  pure =\n    error "todo: Course.ListZipper pure#instance ListZipper"\n-- /Tip:/ Use `zipWith`\n  (<*>) =\n    error "todo: Course.ListZipper (<*>)#instance ListZipper"\n\n-- | Implement the `Applicative` instance for `MaybeListZipper`.\n--\n-- /Tip:/ Use @pure@ for `ListZipper`.\n-- /Tip:/ Use `<*>` for `ListZipper`.\n--\n-- prop> \\z n -> let is (IsZ z) = z in all . (==) <*> take n . lefts . is . pure\n--\n-- prop> \\z n -> let is (IsZ z) = z in all . (==) <*> take n . rights . is . pure\n--\n-- >>> IsZ (zipper [(+2), (+10)] (*2) [(*3), (4*), (5+)]) <*> IsZ (zipper [3,2,1] 4 [5,6,7])\n-- [5,12] >8< [15,24,12]\n--\n-- >>> IsNotZ <*> IsZ (zipper [3,2,1] 4 [5,6,7])\n-- ><\n--\n-- >>> IsZ (zipper [(+2), (+10)] (*2) [(*3), (4*), (5+)]) <*> IsNotZ\n-- ><\n--\n-- >>> IsNotZ <*> IsNotZ\n-- ><\ninstance Applicative MaybeListZipper where\n  pure =\n    error "todo: Course.ListZipper pure#instance MaybeListZipper"\n  (<*>) =\n    error "todo: Course.ListZipper (<*>)#instance MaybeListZipper"\n\n-- | Implement the `Extend` instance for `ListZipper`.\n-- This implementation "visits" every possible zipper value derivable from a given zipper (i.e. all zippers to the left and right).\n--\n-- /Tip:/ Use @List#unfoldr@.\n--\n-- >>> id <<= (zipper [2,1] 3 [4,5])\n-- [[1] >2< [3,4,5],[] >1< [2,3,4,5]] >[2,1] >3< [4,5]< [[3,2,1] >4< [5],[4,3,2,1] >5< []]\ninstance Extend ListZipper where\n  (<<=) =\n    error "todo: Course.ListZipper (<<=)#instance ListZipper"\n\n-- | Implement the `Extend` instance for `MaybeListZipper`.\n-- This instance will use the `Extend` instance for `ListZipper`.\n--\n--\n-- id <<= IsNotZ\n-- ><\n--\n-- >>> id <<= (IsZ (zipper [2,1] 3 [4,5]))\n-- [[1] >2< [3,4,5],[] >1< [2,3,4,5]] >[2,1] >3< [4,5]< [[3,2,1] >4< [5],[4,3,2,1] >5< []]\ninstance Extend MaybeListZipper where\n  (<<=) =\n    error "todo: Course.ListZipper (<<=)#instance MaybeListZipper"\n\n-- | Implement the `Comonad` instance for `ListZipper`.\n-- This implementation returns the current focus of the zipper.\n--\n-- >>> copure (zipper [2,1] 3 [4,5])\n-- 3\ninstance Comonad ListZipper where\n  copure =\n    error "todo: Course.ListZipper copure#instance ListZipper"\n\n-- | Implement the `Traversable` instance for `ListZipper`.\n-- This implementation traverses a zipper while running some `Applicative` effect through the zipper.\n-- An effectful zipper is returned.\n--\n-- >>> traverse id (zipper [Full 1, Full 2, Full 3] (Full 4) [Full 5, Full 6, Full 7])\n-- Full [1,2,3] >4< [5,6,7]\n--\n-- >>> traverse id (zipper [Full 1, Full 2, Full 3] (Full 4) [Empty, Full 6, Full 7])\n-- Empty\ninstance Traversable ListZipper where\n  traverse =\n    error "todo: Course.ListZipper traverse#instance ListZipper"\n\n-- | Implement the `Traversable` instance for `MaybeListZipper`.\n--\n-- /Tip:/ Use `traverse` for `ListZipper`.\n--\n-- >>> traverse id IsNotZ\n-- ><\n--\n-- >>> traverse id (IsZ (zipper [Full 1, Full 2, Full 3] (Full 4) [Full 5, Full 6, Full 7]))\n-- Full [1,2,3] >4< [5,6,7]\ninstance Traversable MaybeListZipper where\n  traverse =\n    error "todo: Course.ListZipper traverse#instance MaybeListZipper"\n\n-----------------------\n-- SUPPORT LIBRARIES --\n-----------------------\n\ninstance Show a => Show (ListZipper a) where\n  show (ListZipper l x r) =\n    stringconcat [show l, " >", show x, "< ", show r]\n\ninstance Show a => Show (MaybeListZipper a) where\n  show (IsZ z) = show z\n  show IsNotZ = "><"\n'