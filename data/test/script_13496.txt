b'\xef\xbb\xbfusing System;\nusing Asn1;\nusing System.Text;\nusing System.Collections.Generic;\n\nnamespace Rubeus\n{\n    public class KDCReqBody\n    {\n        //KDC-REQ-BODY::= SEQUENCE {\n        //    kdc-options[0] KDCOptions,\n        //    cname[1] PrincipalName OPTIONAL\n        //                                -- Used only in AS-REQ --,\n        //    realm[2] Realm\n        //                                -- Server\'s realm\n        //                                -- Also client\'s in AS-REQ --,\n        //    sname[3] PrincipalName OPTIONAL,\n        //    from[4] KerberosTime OPTIONAL,\n        //    till[5] KerberosTime,\n        //    rtime[6] KerberosTime OPTIONAL,\n        //    nonce[7] UInt32,\n        //            etype[8] SEQUENCE OF Int32 -- EncryptionType\n        //                                        -- in preference order --,\n        //            addresses[9] HostAddresses OPTIONAL,\n        //    enc-authorization-data[10] EncryptedData OPTIONAL\n        //                                        -- AuthorizationData --,\n        //            additional-tickets[11] SEQUENCE OF Ticket OPTIONAL\n        //                                            -- NOTE: not empty\n        //}\n\n        public KDCReqBody(bool c = true, bool r = false)\n        {\n            // defaults for creation\n            kdcOptions = Interop.KdcOptions.FORWARDABLE | Interop.KdcOptions.RENEWABLE | Interop.KdcOptions.RENEWABLEOK;\n\n            // added ability to remove cname from request\n            // seems to be useful for cross domain stuff\n            // didn\'t see a cname in "real" S4U request traffic\n            if (c)\n            {\n                cname = new PrincipalName();\n            }\n\n            sname = new PrincipalName();\n\n            // date time from kekeo ;) HAI 2037!\n            till = DateTime.ParseExact("20370913024805Z", "yyyyMMddHHmmssZ", System.Globalization.CultureInfo.InvariantCulture);\n\n            // add rtime for AS-REQs\n            if (r)\n            {\n                rtime = DateTime.ParseExact("20370913024805Z", "yyyyMMddHHmmssZ", System.Globalization.CultureInfo.InvariantCulture);\n            }\n\n            var rand = new Random();\n            nonce = (UInt32)rand.Next(1, Int32.MaxValue);\n\n            additional_tickets = new List<Ticket>();\n\n            etypes = new List<Interop.KERB_ETYPE>();\n        }\n\n        public KDCReqBody(AsnElt body)\n        {\n            foreach (AsnElt s in body.Sub)\n            {\n                switch (s.TagValue)\n                {\n                    case 0:\n                        UInt32 temp = Convert.ToUInt32(s.Sub[0].GetInteger());\n                        byte[] tempBytes = BitConverter.GetBytes(temp);\n                        kdcOptions = (Interop.KdcOptions)BitConverter.ToInt32(tempBytes, 0);\n                        break;\n                    case 1:\n                        // optional\n                        cname = new PrincipalName(s.Sub[0]);\n                        break;\n                    case 2:\n                        realm = Encoding.ASCII.GetString(s.Sub[0].GetOctetString());\n                        break;\n                    case 3:\n                        // optional\n                        sname = new PrincipalName(s.Sub[0]);\n                        break;\n                    case 4:\n                        // optional\n                        from = s.Sub[0].GetTime();\n                        break;\n                    case 5:\n                        till = s.Sub[0].GetTime();\n                        break;\n                    case 6:\n                        // optional\n                        rtime = s.Sub[0].GetTime();\n                        break;\n                    case 7:\n                        nonce = Convert.ToUInt32(s.Sub[0].GetInteger());\n                        break;\n                    case 8:\n                        //etypes = new Enums.KERB_ETYPE[s.Sub[0].Sub.Length];\n                        etypes = new List<Interop.KERB_ETYPE>();\n                        for (int i = 0; i < s.Sub[0].Sub.Length; i++)\n                        {\n                            //etypes[i] = (Enums.KERB_ETYPE)Convert.ToUInt32(s.Sub[0].Sub[i].GetInteger());\n                            etypes.Add((Interop.KERB_ETYPE)Convert.ToUInt32(s.Sub[0].Sub[i].GetInteger()));\n                        }\n                        break;\n                    case 9:\n                        // addresses (optional)\n                        addresses = new List<HostAddress>();\n                        addresses.Add(new HostAddress(s.Sub[0]));\n                        break;\n                    case 10:\n                        // enc authorization-data (optional)\n                        break;\n                    case 11:\n                        // additional-tickets (optional)\n                        break;\n                    default:\n                        break;\n                }\n            }\n        }\n\n        public AsnElt Encode()\n        {\n            // TODO: error-checking!\n\n            List<AsnElt> allNodes = new List<AsnElt>();\n\n            // kdc-options             [0] KDCOptions\n            byte[] kdcOptionsBytes = BitConverter.GetBytes((UInt32)kdcOptions);\n            if (BitConverter.IsLittleEndian)\n            {\n                Array.Reverse(kdcOptionsBytes);\n            }\n            AsnElt kdcOptionsAsn = AsnElt.MakeBitString(kdcOptionsBytes);\n            AsnElt kdcOptionsSeq = AsnElt.Make(AsnElt.SEQUENCE, new[] { kdcOptionsAsn });\n            kdcOptionsSeq = AsnElt.MakeImplicit(AsnElt.CONTEXT, 0, kdcOptionsSeq);\n            allNodes.Add(kdcOptionsSeq);\n\n\n            // cname                   [1] PrincipalName\n            if (cname != null)\n            {\n                AsnElt cnameElt = cname.Encode();\n                cnameElt = AsnElt.MakeImplicit(AsnElt.CONTEXT, 1, cnameElt);\n                allNodes.Add(cnameElt);\n            }\n\n\n            // realm                   [2] Realm\n            //                          --Server\'s realm\n            //                          -- Also client\'s in AS-REQ --\n            AsnElt realmAsn = AsnElt.MakeString(AsnElt.IA5String, realm);\n            realmAsn = AsnElt.MakeImplicit(AsnElt.UNIVERSAL, AsnElt.GeneralString, realmAsn);\n            AsnElt realmSeq = AsnElt.Make(AsnElt.SEQUENCE, new[] { realmAsn });\n            realmSeq = AsnElt.MakeImplicit(AsnElt.CONTEXT, 2, realmSeq);\n            allNodes.Add(realmSeq);\n\n\n            // sname                   [3] PrincipalName OPTIONAL\n            AsnElt snameElt = sname.Encode();\n            snameElt = AsnElt.MakeImplicit(AsnElt.CONTEXT, 3, snameElt);\n            allNodes.Add(snameElt);\n\n\n            // from                    [4] KerberosTime OPTIONAL\n\n\n            // till                    [5] KerberosTime\n            AsnElt tillAsn = AsnElt.MakeString(AsnElt.GeneralizedTime, till.ToString("yyyyMMddHHmmssZ"));\n            AsnElt tillSeq = AsnElt.Make(AsnElt.SEQUENCE, new[] { tillAsn });\n            tillSeq = AsnElt.MakeImplicit(AsnElt.CONTEXT, 5, tillSeq);\n            allNodes.Add(tillSeq);\n\n\n            // rtime                   [6] KerberosTime\n            if (rtime.Year > 0001)\n            {\n                AsnElt rtimeAsn = AsnElt.MakeString(AsnElt.GeneralizedTime, rtime.ToString("yyyyMMddHHmmssZ"));\n                AsnElt rtimeSeq = AsnElt.Make(AsnElt.SEQUENCE, new[] { rtimeAsn });\n                rtimeSeq = AsnElt.MakeImplicit(AsnElt.CONTEXT, 6, rtimeSeq);\n                allNodes.Add(rtimeSeq);\n            }\n\n            // nonce                   [7] UInt32\n            AsnElt nonceAsn = AsnElt.MakeInteger(nonce);\n            AsnElt nonceSeq = AsnElt.Make(AsnElt.SEQUENCE, new[] { nonceAsn });\n            nonceSeq = AsnElt.MakeImplicit(AsnElt.CONTEXT, 7, nonceSeq);\n            allNodes.Add(nonceSeq);\n\n\n            // etype                   [8] SEQUENCE OF Int32 -- EncryptionType -- in preference order --\n            List <AsnElt> etypeList = new List<AsnElt>();\n            foreach (Interop.KERB_ETYPE etype in etypes)\n            {\n                AsnElt etypeAsn = AsnElt.MakeInteger((Int32)etype);\n                //AsnElt etypeSeq = AsnElt.Make(AsnElt.SEQUENCE, new[] { etypeAsn });\n                etypeList.Add(etypeAsn);\n            }\n            AsnElt etypeSeq = AsnElt.Make(AsnElt.SEQUENCE, etypeList.ToArray());\n            AsnElt etypeSeqTotal1 = AsnElt.Make(AsnElt.SEQUENCE, etypeList.ToArray());\n            AsnElt etypeSeqTotal2 = AsnElt.Make(AsnElt.SEQUENCE, etypeSeqTotal1);\n            etypeSeqTotal2 = AsnElt.MakeImplicit(AsnElt.CONTEXT, 8, etypeSeqTotal2);\n            allNodes.Add(etypeSeqTotal2);\n\n\n            // addresses               [9] HostAddresses OPTIONAL\n            if (addresses != null)\n            {\n                List<AsnElt> addrList = new List<AsnElt>();\n                foreach (HostAddress addr in addresses)\n                {\n                    AsnElt addrElt = addr.Encode();\n                    addrList.Add(addrElt);\n                }\n                AsnElt addrSeqTotal1 = AsnElt.Make(AsnElt.SEQUENCE, addrList.ToArray());\n                AsnElt addrSeqTotal2 = AsnElt.Make(AsnElt.SEQUENCE, addrSeqTotal1);\n                addrSeqTotal2 = AsnElt.MakeImplicit(AsnElt.CONTEXT, 9, addrSeqTotal2);\n                allNodes.Add(addrSeqTotal2);\n            }\n\n            // enc-authorization-data  [10] EncryptedData OPTIONAL\n            if (enc_authorization_data != null)\n            {\n                AsnElt authorizationEncryptedDataASN = enc_authorization_data.Encode();\n                AsnElt authorizationEncryptedDataSeq = AsnElt.Make(AsnElt.SEQUENCE, new[] { authorizationEncryptedDataASN });\n                authorizationEncryptedDataSeq = AsnElt.MakeImplicit(AsnElt.CONTEXT, 10, authorizationEncryptedDataSeq);\n                allNodes.Add(authorizationEncryptedDataSeq);\n            }\n\n            // additional-tickets      [11] SEQUENCE OF Ticket OPTIONAL\n            if (additional_tickets.Count > 0) {\n                AsnElt ticketAsn = additional_tickets[0].Encode();\n                AsnElt ticketSeq = AsnElt.Make(AsnElt.SEQUENCE, new AsnElt[] { ticketAsn });\n                AsnElt ticketSeq2 = AsnElt.Make(AsnElt.SEQUENCE, new AsnElt[] { ticketSeq });\n                ticketSeq2 = AsnElt.MakeImplicit(AsnElt.CONTEXT, 11, ticketSeq2);\n                allNodes.Add(ticketSeq2);\n            }\n\n            AsnElt seq = AsnElt.Make(AsnElt.SEQUENCE, allNodes.ToArray());\n\n            return seq;\n        }\n\n\n        public Interop.KdcOptions kdcOptions { get; set; }\n\n        public PrincipalName cname { get; set; }\n\n        public string realm { get; set; }\n\n        public PrincipalName sname { get; set; }\n\n        public DateTime from { get; set; }\n\n        public DateTime till { get; set; }\n\n        public DateTime rtime { get; set; }\n\n        public UInt32 nonce { get; set; }\n\n        public List<Interop.KERB_ETYPE> etypes { get; set; }\n\n        public List<HostAddress> addresses { get; set; }\n\n        public EncryptedData enc_authorization_data { get; set; }\n\n        public List<Ticket> additional_tickets { get; set; }\n    }\n}\n'