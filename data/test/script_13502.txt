b'using System;\nusing System.Diagnostics;\nusing System.Text;\n\nusing u8 = System.Byte;\nusing u32 = System.UInt32;\nnamespace CS_SQLite3\n{\n  public partial class CSSQLite\n  {\n    /*\n    **\n    ** The author disclaims copyright to this source code.  In place of\n    ** a legal notice, here is a blessing:\n    **\n    **    May you do good and not evil.\n    **    May you find forgiveness for yourself and forgive others.\n    **    May you share freely, never taking more than you give.\n    **\n    *************************************************************************\n    **\n    **\n    ** $Id: trigger.c,v 1.143 2009/08/10 03:57:58 shane Exp $\n    **\n    *************************************************************************\n    **  Included in SQLite3 port to C#-SQLite;  2008 Noah B Hart\n    **  C#-SQLite is an independent reimplementation of the SQLite software library\n    **\n    **  $Header$\n    *************************************************************************\n    */\n    //#include "sqliteInt.h"\n\n#if !SQLITE_OMIT_TRIGGER\n    /*\n** Delete a linked list of TriggerStep structures.\n*/\n    static void sqlite3DeleteTriggerStep( sqlite3 db, ref TriggerStep pTriggerStep )\n    {\n      while ( pTriggerStep != null )\n      {\n        TriggerStep pTmp = pTriggerStep;\n        pTriggerStep = pTriggerStep.pNext;\n\n        sqlite3ExprDelete( db, ref pTmp.pWhere );\n        sqlite3ExprListDelete( db, ref pTmp.pExprList );\n        sqlite3SelectDelete( db, ref pTmp.pSelect );\n        sqlite3IdListDelete( db, ref pTmp.pIdList );\n\n        pTriggerStep = null;//sqlite3DbFree( db, ref pTmp );\n      }\n    }\n\n    /*\n    ** Given table pTab, return a list of all the triggers attached to\n    ** the table. The list is connected by Trigger.pNext pointers.\n    **\n    ** All of the triggers on pTab that are in the same database as pTab\n    ** are already attached to pTab->pTrigger.  But there might be additional\n    ** triggers on pTab in the TEMP schema.  This routine prepends all\n    ** TEMP triggers on pTab to the beginning of the pTab->pTrigger list\n    ** and returns the combined list.\n    **\n    ** To state it another way:  This routine returns a list of all triggers\n    ** that fire off of pTab.  The list will include any TEMP triggers on\n    ** pTab as well as the triggers lised in pTab->pTrigger.\n    */\n    static Trigger sqlite3TriggerList( Parse pParse, Table pTab )\n    {\n      Schema pTmpSchema = pParse.db.aDb[1].pSchema;\n      Trigger pList = null;                  /* List of triggers to return */\n\n      if ( pTmpSchema != pTab.pSchema )\n      {\n        HashElem p;\n        for ( p = sqliteHashFirst( pTmpSchema.trigHash ) ; p != null ; p = sqliteHashNext( p ) )\n        {\n          Trigger pTrig = (Trigger)sqliteHashData( p );\n          if ( pTrig.pTabSchema == pTab.pSchema\n          && 0 == sqlite3StrICmp( pTrig.table, pTab.zName )\n          )\n          {\n            pTrig.pNext = ( pList != null ? pList : pTab.pTrigger );\n            pList = pTrig;\n          }\n        }\n      }\n\n      return ( pList != null ? pList : pTab.pTrigger );\n    }\n\n    /*\n    ** This is called by the parser when it sees a CREATE TRIGGER statement\n    ** up to the point of the BEGIN before the trigger actions.  A Trigger\n    ** structure is generated based on the information available and stored\n    ** in pParse.pNewTrigger.  After the trigger actions have been parsed, the\n    ** sqlite3FinishTrigger() function is called to complete the trigger\n    ** construction process.\n    */\n    static void sqlite3BeginTrigger(\n    Parse pParse,      /* The parse context of the CREATE TRIGGER statement */\n    Token pName1,      /* The name of the trigger */\n    Token pName2,      /* The name of the trigger */\n    int tr_tm,         /* One of TK_BEFORE, TK_AFTER, TK_INSTEAD */\n    int op,             /* One of TK_INSERT, TK_UPDATE, TK_DELETE */\n    IdList pColumns,   /* column list if this is an UPDATE OF trigger */\n    SrcList pTableName,/* The name of the table/view the trigger applies to */\n    Expr pWhen,        /* WHEN clause */\n    int isTemp,        /* True if the TEMPORARY keyword is present */\n    int noErr          /* Suppress errors if the trigger already exists */\n    )\n    {\n      Trigger pTrigger = null;      /* The new trigger */\n      Table pTab;                   /* Table that the trigger fires off of */\n      string zName = null;          /* Name of the trigger */\n      sqlite3 db = pParse.db;       /* The database connection */\n      int iDb;                      /* The database to store the trigger in */\n      Token pName = null;           /* The unqualified db name */\n      DbFixer sFix = new DbFixer(); /* State vector for the DB fixer */\n      int iTabDb;                   /* Index of the database holding pTab */\n\n      Debug.Assert( pName1 != null );   /* pName1.z might be NULL, but not pName1 itself */\n      Debug.Assert( pName2 != null );\n      Debug.Assert( op == TK_INSERT || op == TK_UPDATE || op == TK_DELETE );\n      Debug.Assert( op > 0 && op < 0xff );\n      if ( isTemp != 0 )\n      {\n        /* If TEMP was specified, then the trigger name may not be qualified. */\n        if ( pName2.n > 0 )\n        {\n          sqlite3ErrorMsg( pParse, "temporary trigger may not have qualified name" );\n          goto trigger_cleanup;\n        }\n        iDb = 1;\n        pName = pName1;\n      }\n      else\n      {\n        /* Figure out the db that the the trigger will be created in */\n        iDb = sqlite3TwoPartName( pParse, pName1, pName2, ref  pName );\n        if ( iDb < 0 )\n        {\n          goto trigger_cleanup;\n        }\n      }\n\n      /* If the trigger name was unqualified, and the table is a temp table,\n      ** then set iDb to 1 to create the trigger in the temporary database.\n      ** If sqlite3SrcListLookup() returns 0, indicating the table does not\n      ** exist, the error is caught by the block below.\n      */\n      if ( pTableName == null /*|| db.mallocFailed != 0 */ )\n      {\n        goto trigger_cleanup;\n      }\n      pTab = sqlite3SrcListLookup( pParse, pTableName );\n      if ( pName2.n == 0 && pTab != null && pTab.pSchema == db.aDb[1].pSchema )\n      {\n        iDb = 1;\n      }\n\n      /* Ensure the table name matches database name and that the table exists */\n//      if ( db.mallocFailed != 0 ) goto trigger_cleanup;\n      Debug.Assert( pTableName.nSrc == 1 );\n      if ( sqlite3FixInit( sFix, pParse, iDb, "trigger", pName ) != 0 &&\n      sqlite3FixSrcList( sFix, pTableName ) != 0 )\n      {\n        goto trigger_cleanup;\n      }\n      pTab = sqlite3SrcListLookup( pParse, pTableName );\n      if ( pTab == null )\n      {\n        /* The table does not exist. */\n        if ( db.init.iDb == 1 )\n        {\n          /* Ticket #3810.\n          ** Normally, whenever a table is dropped, all associated triggers are\n          ** dropped too.  But if a TEMP trigger is created on a non-TEMP table\n          ** and the table is dropped by a different database connection, the\n          ** trigger is not visible to the database connection that does the\n          ** drop so the trigger cannot be dropped.  This results in an\n          ** "orphaned trigger" - a trigger whose associated table is missing.\n          */\n          db.init.orphanTrigger = 1;\n        }\n        goto trigger_cleanup;\n      }\n      if ( IsVirtual( pTab ) )\n      {\n        sqlite3ErrorMsg( pParse, "cannot create triggers on virtual tables" );\n        goto trigger_cleanup;\n      }\n\n      /* Check that the trigger name is not reserved and that no trigger of the\n      ** specified name exists */\n      zName = sqlite3NameFromToken( db, pName );\n      if ( zName == null || SQLITE_OK != sqlite3CheckObjectName( pParse, zName ) )\n      {\n        goto trigger_cleanup;\n      }\n      if ( sqlite3HashFind( ( db.aDb[iDb].pSchema.trigHash ),\n      zName, sqlite3Strlen30( zName ) ) != null )\n      {\n        if ( noErr == 0 )\n        {\n          sqlite3ErrorMsg( pParse, "trigger %T already exists", pName );\n        }\n        goto trigger_cleanup;\n      }\n\n      /* Do not create a trigger on a system table */\n      if ( sqlite3StrNICmp( pTab.zName, "sqlite_", 7 ) == 0 )\n      {\n        sqlite3ErrorMsg( pParse, "cannot create trigger on system table" );\n        pParse.nErr++;\n        goto trigger_cleanup;\n      }\n\n      /* INSTEAD of triggers are only for views and views only support INSTEAD\n      ** of triggers.\n      */\n      if ( pTab.pSelect != null && tr_tm != TK_INSTEAD )\n      {\n        sqlite3ErrorMsg( pParse, "cannot create %s trigger on view: %S",\n        ( tr_tm == TK_BEFORE ) ? "BEFORE" : "AFTER", pTableName, 0 );\n        goto trigger_cleanup;\n      }\n      if ( pTab.pSelect == null && tr_tm == TK_INSTEAD )\n      {\n        sqlite3ErrorMsg( pParse, "cannot create INSTEAD OF" +\n        " trigger on table: %S", pTableName, 0 );\n        goto trigger_cleanup;\n      }\n      iTabDb = sqlite3SchemaToIndex( db, pTab.pSchema );\n\n#if !SQLITE_OMIT_AUTHORIZATION\n{\nint code = SQLITE_CREATE_TRIGGER;\nstring zDb = db.aDb[iTabDb].zName;\nstring zDbTrig = isTemp ? db.aDb[1].zName : zDb;\nif( iTabDb==1 || isTemp ) code = SQLITE_CREATE_TEMP_TRIGGER;\nif( sqlite3AuthCheck(pParse, code, zName, pTab.zName, zDbTrig) ){\ngoto trigger_cleanup;\n}\nif( sqlite3AuthCheck(pParse, SQLITE_INSERT, SCHEMA_TABLE(iTabDb),0,zDb)){\ngoto trigger_cleanup;\n}\n}\n#endif\n\n      /* INSTEAD OF triggers can only appear on views and BEFORE triggers\n** cannot appear on views.  So we might as well translate every\n** INSTEAD OF trigger into a BEFORE trigger.  It simplifies code\n** elsewhere.\n*/\n      if ( tr_tm == TK_INSTEAD )\n      {\n        tr_tm = TK_BEFORE;\n      }\n\n      /* Build the Trigger object */\n      pTrigger = new Trigger();// (Trigger*)sqlite3DbMallocZero( db, sizeof(Trigger ))\n      if ( pTrigger == null ) goto trigger_cleanup;\n      pTrigger.name = zName;\n      pTrigger.table = pTableName.a[0].zName;// sqlite3DbStrDup( db, pTableName.a[0].zName );\n      pTrigger.pSchema = db.aDb[iDb].pSchema;\n      pTrigger.pTabSchema = pTab.pSchema;\n      pTrigger.op = (u8)op;\n      pTrigger.tr_tm = tr_tm == TK_BEFORE ? TRIGGER_BEFORE : TRIGGER_AFTER;\n      pTrigger.pWhen = sqlite3ExprDup( db, pWhen, EXPRDUP_REDUCE );\n      pTrigger.pColumns = sqlite3IdListDup( db, pColumns );\n      Debug.Assert( pParse.pNewTrigger == null );\n      pParse.pNewTrigger = pTrigger;\n\ntrigger_cleanup:\n      //sqlite3DbFree( db, ref zName );\n      sqlite3SrcListDelete( db, ref pTableName );\n      sqlite3IdListDelete( db, ref pColumns );\n      sqlite3ExprDelete( db, ref pWhen );\n      if ( pParse.pNewTrigger == null )\n      {\n        sqlite3DeleteTrigger( db, ref pTrigger );\n      }\n      else\n      {\n        Debug.Assert( pParse.pNewTrigger == pTrigger );\n      }\n    }\n\n    /*\n    ** This routine is called after all of the trigger actions have been parsed\n    ** in order to complete the process of building the trigger.\n    */\n    static void sqlite3FinishTrigger(\n    Parse pParse,          /* Parser context */\n    TriggerStep pStepList, /* The triggered program */\n    Token pAll             /* Token that describes the complete CREATE TRIGGER */\n    )\n    {\n      Trigger pTrig = pParse.pNewTrigger; /* Trigger being finished */\n      string zName;                       /* Name of trigger */\n\n      sqlite3 db = pParse.db;             /* The database */\n      DbFixer sFix = new DbFixer();\n      int iDb;                        /* Database containing the trigger */\n      Token nameToken = new Token();  /* Trigger name for error reporting */\n\n      pTrig = pParse.pNewTrigger;\n      pParse.pNewTrigger = null;\n      if ( NEVER( pParse.nErr != 0 ) || pTrig == null ) goto triggerfinish_cleanup;\n      zName = pTrig.name;\n      iDb = sqlite3SchemaToIndex( pParse.db, pTrig.pSchema );\n      pTrig.step_list = pStepList;\n      while ( pStepList != null )\n      {\n        pStepList.pTrig = pTrig;\n        pStepList = pStepList.pNext;\n      }\n      nameToken.z = pTrig.name;\n      nameToken.n = sqlite3Strlen30( nameToken.z );\n      if ( sqlite3FixInit( sFix, pParse, iDb, "trigger", nameToken ) != 0\n      && sqlite3FixTriggerStep( sFix, pTrig.step_list ) != 0 )\n      {\n        goto triggerfinish_cleanup;\n      }\n\n      /* if we are not initializing, and this trigger is not on a TEMP table,\n      ** build the sqlite_master entry\n      */\n      if ( 0 == db.init.busy )\n      {\n        Vdbe v;\n        string z;\n\n        /* Make an entry in the sqlite_master table */\n        v = sqlite3GetVdbe( pParse );\n        if ( v == null ) goto triggerfinish_cleanup;\n        sqlite3BeginWriteOperation( pParse, 0, iDb );\n        z = pAll.z.Substring( 0, pAll.n );//sqlite3DbStrNDup( db, (char*)pAll.z, pAll.n );\n        sqlite3NestedParse( pParse,\n        "INSERT INTO %Q.%s VALUES(\'trigger\',%Q,%Q,0,\'CREATE TRIGGER %q\')",\n        db.aDb[iDb].zName, SCHEMA_TABLE( iDb ), zName,\n        pTrig.table, z );\n        //sqlite3DbFree( db, ref z );\n        sqlite3ChangeCookie( pParse, iDb );\n        sqlite3VdbeAddOp4( v, OP_ParseSchema, iDb, 0, 0, sqlite3MPrintf(\n        db, "type=\'trigger\' AND name=\'%q\'", zName ), P4_DYNAMIC\n        );\n      }\n\n      if ( db.init.busy != 0 )\n      {\n        Trigger pLink = pTrig;\n        Hash pHash = db.aDb[iDb].pSchema.trigHash;\n        pTrig = (Trigger)sqlite3HashInsert( ref pHash, zName, sqlite3Strlen30( zName ), pTrig );\n        if ( pTrig != null )\n        {\n          //db.mallocFailed = 1;\n        }\n        else if ( pLink.pSchema == pLink.pTabSchema )\n        {\n          Table pTab;\n          int n = sqlite3Strlen30( pLink.table );\n          pTab = (Table)sqlite3HashFind( pLink.pTabSchema.tblHash, pLink.table, n );\n          Debug.Assert( pTab != null );\n          pLink.pNext = pTab.pTrigger;\n          pTab.pTrigger = pLink;\n        }\n      }\n\ntriggerfinish_cleanup:\n      sqlite3DeleteTrigger( db, ref pTrig );\n      Debug.Assert( pParse.pNewTrigger == null );\n      sqlite3DeleteTriggerStep( db, ref pStepList );\n    }\n\n    /*\n    ** Turn a SELECT statement (that the pSelect parameter points to) into\n    ** a trigger step.  Return a pointer to a TriggerStep structure.\n    **\n    ** The parser calls this routine when it finds a SELECT statement in\n    ** body of a TRIGGER.\n    */\n    static TriggerStep sqlite3TriggerSelectStep( sqlite3 db, Select pSelect )\n    {\n      TriggerStep pTriggerStep = new TriggerStep();// sqlite3DbMallocZero( db, sizeof(TriggerStep ))\n      if ( pTriggerStep == null )\n      {\n        sqlite3SelectDelete( db, ref pSelect );\n        return null;\n      }\n\n      pTriggerStep.op = TK_SELECT;\n      pTriggerStep.pSelect = pSelect;\n      pTriggerStep.orconf = OE_Default;\n      return pTriggerStep;\n    }\n\n    /*\n    ** Allocate space to hold a new trigger step.  The allocated space\n    ** holds both the TriggerStep object and the TriggerStep.target.z string.\n    **\n    ** If an OOM error occurs, NULL is returned and db->mallocFailed is set.\n    */\n    static TriggerStep triggerStepAllocate(\n    sqlite3 db,                /* Database connection */\n    u8 op,                     /* Trigger opcode */\n    Token pName                /* The target name */\n    )\n    {\n      TriggerStep pTriggerStep;\n\n      pTriggerStep = new TriggerStep();// sqlite3DbMallocZero( db, sizeof( TriggerStep ) + pName.n );\n      //if ( pTriggerStep != null )\n      //{\n        string z;// = (char*)&pTriggerStep[1];\n        z = pName.z;// memcpy( z, pName.z, pName.n );\n        pTriggerStep.target.z = z;\n        pTriggerStep.target.n = pName.n;\n        pTriggerStep.op = op;\n      //}\n      return pTriggerStep;\n    }\n\n    /*\n    ** Build a trigger step out of an INSERT statement.  Return a pointer\n    ** to the new trigger step.\n    **\n    ** The parser calls this routine when it sees an INSERT inside the\n    ** body of a trigger.\n    */\n    // OVERLOADS, so I don\'t need to rewrite parse.c\n    static TriggerStep sqlite3TriggerInsertStep( sqlite3 db, Token pTableName, IdList pColumn, int null_4, int null_5, u8 orconf )\n    { return sqlite3TriggerInsertStep( db, pTableName, pColumn, null, null, orconf ); }\n    static TriggerStep sqlite3TriggerInsertStep( sqlite3 db, Token pTableName, IdList pColumn, ExprList pEList, int null_5, u8 orconf )\n    { return sqlite3TriggerInsertStep( db, pTableName, pColumn, pEList, null, orconf ); }\n    static TriggerStep sqlite3TriggerInsertStep( sqlite3 db, Token pTableName, IdList pColumn, int null_4, Select pSelect, u8 orconf )\n    { return sqlite3TriggerInsertStep( db, pTableName, pColumn, null, pSelect, orconf ); }\n    static TriggerStep sqlite3TriggerInsertStep(\n    sqlite3 db,        /* The database connection */\n    Token pTableName,  /* Name of the table into which we insert */\n    IdList pColumn,    /* List of columns in pTableName to insert into */\n    ExprList pEList,   /* The VALUE clause: a list of values to be inserted */\n    Select pSelect,    /* A SELECT statement that supplies values */\n    u8 orconf          /* The conflict algorithm (OE_Abort, OE_Replace, etc.) */\n    )\n    {\n      TriggerStep pTriggerStep;\n\n      Debug.Assert( pEList == null || pSelect == null );\n      Debug.Assert( pEList != null || pSelect != null /*|| db.mallocFailed != 0 */ );\n\n      pTriggerStep = triggerStepAllocate( db, TK_INSERT, pTableName );\n      //if ( pTriggerStep != null )\n      //{\n        pTriggerStep.pSelect = sqlite3SelectDup( db, pSelect, EXPRDUP_REDUCE );\n        pTriggerStep.pIdList = pColumn;\n        pTriggerStep.pExprList = sqlite3ExprListDup( db, pEList, EXPRDUP_REDUCE );\n        pTriggerStep.orconf = orconf;\n      //}\n      //else\n      //{\n      //  sqlite3IdListDelete( db, ref pColumn );\n      //}\n      sqlite3ExprListDelete( db, ref pEList );\n      sqlite3SelectDelete( db, ref pSelect );\n\n      return pTriggerStep;\n    }\n\n    /*\n    ** Construct a trigger step that implements an UPDATE statement and return\n    ** a pointer to that trigger step.  The parser calls this routine when it\n    ** sees an UPDATE statement inside the body of a CREATE TRIGGER.\n    */\n    static TriggerStep sqlite3TriggerUpdateStep(\n    sqlite3 db,         /* The database connection */\n    Token pTableName,   /* Name of the table to be updated */\n    ExprList pEList,    /* The SET clause: list of column and new values */\n    Expr pWhere,        /* The WHERE clause */\n    u8 orconf           /* The conflict algorithm. (OE_Abort, OE_Ignore, etc) */\n    )\n    {\n      TriggerStep pTriggerStep;\n\n      pTriggerStep = triggerStepAllocate( db, TK_UPDATE, pTableName );\n      //if ( pTriggerStep != null )\n      //{\n        pTriggerStep.pExprList = sqlite3ExprListDup( db, pEList, EXPRDUP_REDUCE );\n        pTriggerStep.pWhere = sqlite3ExprDup( db, pWhere, EXPRDUP_REDUCE );\n        pTriggerStep.orconf = orconf;\n      //}\n      sqlite3ExprListDelete( db, ref pEList );\n      sqlite3ExprDelete( db, ref pWhere );\n      return pTriggerStep;\n    }\n\n    /*\n    ** Construct a trigger step that implements a DELETE statement and return\n    ** a pointer to that trigger step.  The parser calls this routine when it\n    ** sees a DELETE statement inside the body of a CREATE TRIGGER.\n    */\n    static TriggerStep sqlite3TriggerDeleteStep(\n    sqlite3 db,            /* Database connection */\n    Token pTableName,      /* The table from which rows are deleted */\n    Expr pWhere            /* The WHERE clause */\n    )\n    {\n      TriggerStep pTriggerStep;\n\n      pTriggerStep = triggerStepAllocate( db, TK_DELETE, pTableName );\n      //if ( pTriggerStep != null )\n      //{\n        pTriggerStep.pWhere = sqlite3ExprDup( db, pWhere, EXPRDUP_REDUCE );\n        pTriggerStep.orconf = OE_Default;\n      //}\n      sqlite3ExprDelete( db, ref pWhere );\n      return pTriggerStep;\n    }\n\n\n\n    /*\n    ** Recursively delete a Trigger structure\n    */\n    static void sqlite3DeleteTrigger( sqlite3 db, ref Trigger pTrigger )\n    {\n      if ( pTrigger == null ) return;\n      sqlite3DeleteTriggerStep( db, ref pTrigger.step_list );\n      //sqlite3DbFree(db,ref pTrigger.name);\n      //sqlite3DbFree( db, ref pTrigger.table );\n      sqlite3ExprDelete( db, ref pTrigger.pWhen );\n      sqlite3IdListDelete( db, ref pTrigger.pColumns );\n      pTrigger = null;//sqlite3DbFree( db, ref pTrigger );\n    }\n\n    /*\n    ** This function is called to drop a trigger from the database schema.\n    **\n    ** This may be called directly from the parser and therefore identifies\n    ** the trigger by name.  The sqlite3DropTriggerPtr() routine does the\n    ** same job as this routine except it takes a pointer to the trigger\n    ** instead of the trigger name.\n    **/\n    static void sqlite3DropTrigger( Parse pParse, SrcList pName, int noErr )\n    {\n      Trigger pTrigger = null;\n      int i;\n      string zDb;\n      string zName;\n      int nName;\n      sqlite3 db = pParse.db;\n\n//      if ( db.mallocFailed != 0 ) goto drop_trigger_cleanup;\n      if ( SQLITE_OK != sqlite3ReadSchema( pParse ) )\n      {\n        goto drop_trigger_cleanup;\n      }\n\n      Debug.Assert( pName.nSrc == 1 );\n      zDb = pName.a[0].zDatabase;\n      zName = pName.a[0].zName;\n      nName = sqlite3Strlen30( zName );\n      for ( i = OMIT_TEMPDB ; i < db.nDb ; i++ )\n      {\n        int j = ( i < 2 ) ? i ^ 1 : i;  /* Search TEMP before MAIN */\n        if ( zDb != null && sqlite3StrICmp( db.aDb[j].zName, zDb ) != 0 ) continue;\n        pTrigger = (Trigger)sqlite3HashFind( ( db.aDb[j].pSchema.trigHash ), zName, nName );\n        if ( pTrigger != null ) break;\n      }\n      if ( pTrigger == null )\n      {\n        if ( noErr == 0 )\n        {\n          sqlite3ErrorMsg( pParse, "no such trigger: %S", pName, 0 );\n        }\n        goto drop_trigger_cleanup;\n      }\n      sqlite3DropTriggerPtr( pParse, pTrigger );\n\ndrop_trigger_cleanup:\n      sqlite3SrcListDelete( db, ref pName );\n    }\n\n    /*\n    ** Return a pointer to the Table structure for the table that a trigger\n    ** is set on.\n    */\n    static Table tableOfTrigger( Trigger pTrigger )\n    {\n      int n = sqlite3Strlen30( pTrigger.table );\n      return (Table)sqlite3HashFind( pTrigger.pTabSchema.tblHash, pTrigger.table, n );\n    }\n\n\n    /*\n    ** Drop a trigger given a pointer to that trigger.\n    */\n    static void sqlite3DropTriggerPtr( Parse pParse, Trigger pTrigger )\n    {\n      Table pTable;\n      Vdbe v;\n      sqlite3 db = pParse.db;\n      int iDb;\n\n      iDb = sqlite3SchemaToIndex( pParse.db, pTrigger.pSchema );\n      Debug.Assert( iDb >= 0 && iDb < db.nDb );\n      pTable = tableOfTrigger( pTrigger );\n      Debug.Assert( pTable != null );\n      Debug.Assert( pTable.pSchema == pTrigger.pSchema || iDb == 1 );\n#if !SQLITE_OMIT_AUTHORIZATION\n{\nint code = SQLITE_DROP_TRIGGER;\nstring zDb = db.aDb[iDb].zName;\nstring zTab = SCHEMA_TABLE(iDb);\nif( iDb==1 ) code = SQLITE_DROP_TEMP_TRIGGER;\nif( sqlite3AuthCheck(pParse, code, pTrigger.name, pTable.zName, zDb) ||\nsqlite3AuthCheck(pParse, SQLITE_DELETE, zTab, 0, zDb) ){\nreturn;\n}\n}\n#endif\n\n      /* Generate code to destroy the database record of the trigger.\n*/\n      Debug.Assert( pTable != null );\n      if ( ( v = sqlite3GetVdbe( pParse ) ) != null )\n      {\n        int _base;\n        VdbeOpList[] dropTrigger = new VdbeOpList[]  {\nnew VdbeOpList( OP_Rewind,     0, ADDR(9),  0),\nnew VdbeOpList( OP_String8,    0, 1,        0), /* 1 */\nnew VdbeOpList( OP_Column,     0, 1,        2),\nnew VdbeOpList( OP_Ne,         2, ADDR(8),  1),\nnew VdbeOpList( OP_String8,    0, 1,        0), /* 4: "trigger" */\nnew VdbeOpList( OP_Column,     0, 0,        2),\nnew VdbeOpList( OP_Ne,         2, ADDR(8),  1),\nnew VdbeOpList( OP_Delete,     0, 0,        0),\nnew VdbeOpList( OP_Next,       0, ADDR(1),  0), /* 8 */\n};\n\n        sqlite3BeginWriteOperation( pParse, 0, iDb );\n        sqlite3OpenMasterTable( pParse, iDb );\n        _base = sqlite3VdbeAddOpList( v, dropTrigger.Length, dropTrigger );\n        sqlite3VdbeChangeP4( v, _base + 1, pTrigger.name, 0 );\n        sqlite3VdbeChangeP4( v, _base + 4, "trigger", P4_STATIC );\n        sqlite3ChangeCookie( pParse, iDb );\n        sqlite3VdbeAddOp2( v, OP_Close, 0, 0 );\n        sqlite3VdbeAddOp4( v, OP_DropTrigger, iDb, 0, 0, pTrigger.name, 0 );\n        if ( pParse.nMem < 3 )\n        {\n          pParse.nMem = 3;\n        }\n      }\n    }\n\n    /*\n    ** Remove a trigger from the hash tables of the sqlite* pointer.\n    */\n    static void sqlite3UnlinkAndDeleteTrigger( sqlite3 db, int iDb, string zName )\n    {\n      Hash pHash = db.aDb[iDb].pSchema.trigHash;\n      Trigger pTrigger;\n      pTrigger = (Trigger)sqlite3HashInsert( ref pHash, zName, sqlite3Strlen30( zName ), null );\n      if ( ALWAYS( pTrigger != null ) )\n      {\n        if ( pTrigger.pSchema == pTrigger.pTabSchema )\n        {\n          Table pTab = tableOfTrigger( pTrigger );\n          //Trigger** pp;\n          //for ( pp = &pTab->pTrigger ; *pp != pTrigger ; pp = &( (*pp)->pNext ) ) ;\n          //*pp = (*pp)->pNext;\n          if ( pTab.pTrigger == pTrigger )\n          {\n            pTab.pTrigger = pTrigger.pNext;\n          }\n          else\n          {\n            Trigger cc = pTab.pTrigger;\n            while ( cc != null )\n            {\n              if ( cc.pNext == pTrigger )\n              {\n                cc.pNext = cc.pNext.pNext;\n                break;\n              }\n              cc = cc.pNext;\n            }\n            Debug.Assert( cc != null );\n          }\n        }\n        sqlite3DeleteTrigger( db, ref pTrigger );\n        db.flags |= SQLITE_InternChanges;\n      }\n    }\n\n    /*\n    ** pEList is the SET clause of an UPDATE statement.  Each entry\n    ** in pEList is of the format <id>=<expr>.  If any of the entries\n    ** in pEList have an <id> which matches an identifier in pIdList,\n    ** then return TRUE.  If pIdList==NULL, then it is considered a\n    ** wildcard that matches anything.  Likewise if pEList==NULL then\n    ** it matches anything so always return true.  Return false only\n    ** if there is no match.\n    */\n    static int checkColumnOverlap( IdList pIdList, ExprList pEList )\n    {\n      int e;\n      if ( pIdList == null || NEVER( pEList == null ) ) return 1;\n      for ( e = 0 ; e < pEList.nExpr ; e++ )\n      {\n        if ( sqlite3IdListIndex( pIdList, pEList.a[e].zName ) >= 0 ) return 1;\n      }\n      return 0;\n    }\n\n    /*\n    ** Return a list of all triggers on table pTab if there exists at least\n    ** one trigger that must be fired when an operation of type \'op\' is\n    ** performed on the table, and, if that operation is an UPDATE, if at\n    ** least one of the columns in pChanges is being modified.\n    */\n    static Trigger sqlite3TriggersExist(\n    Parse pParse,          /* Parse context */\n    Table pTab,            /* The table the contains the triggers */\n    int op,                /* one of TK_DELETE, TK_INSERT, TK_UPDATE */\n    ExprList pChanges,     /* Columns that change in an UPDATE statement */\n    ref int pMask          /* OUT: Mask of TRIGGER_BEFORE|TRIGGER_AFTER */\n    )\n    {\n      int mask = 0;\n      Trigger pList = sqlite3TriggerList( pParse, pTab );\n      Trigger p;\n      Debug.Assert( pList == null || IsVirtual( pTab ) == false );\n      for ( p = pList ; p != null ; p = p.pNext )\n      {\n        if ( p.op == op && checkColumnOverlap( p.pColumns, pChanges ) != 0 )\n        {\n          mask |= p.tr_tm;\n        }\n      }\n      //if ( pMask != 0 )\n      {\n        pMask = mask;\n      }\n      return ( mask != 0 ? pList : null );\n    }\n\n\n    /*\n    ** Convert the pStep.target token into a SrcList and return a pointer\n    ** to that SrcList.\n    **\n    ** This routine adds a specific database name, if needed, to the target when\n    ** forming the SrcList.  This prevents a trigger in one database from\n    ** referring to a target in another database.  An exception is when the\n    ** trigger is in TEMP in which case it can refer to any other database it\n    ** wants.\n    */\n    static SrcList targetSrcList(\n    Parse pParse,       /* The parsing context */\n    TriggerStep pStep   /* The trigger containing the target token */\n    )\n    {\n      int iDb;             /* Index of the database to use */\n      SrcList pSrc;        /* SrcList to be returned */\n\n      pSrc = sqlite3SrcListAppend( pParse.db, 0, pStep.target, 0 );\n      //if ( pSrc != null )\n      //{\n        Debug.Assert( pSrc.nSrc > 0 );\n        Debug.Assert( pSrc.a != null );\n        iDb = sqlite3SchemaToIndex( pParse.db, pStep.pTrig.pSchema );\n        if ( iDb == 0 || iDb >= 2 )\n        {\n          sqlite3 db = pParse.db;\n          Debug.Assert( iDb < pParse.db.nDb );\n          pSrc.a[pSrc.nSrc - 1].zDatabase = db.aDb[iDb].zName;// sqlite3DbStrDup( db, db.aDb[iDb].zName );\n        }\n      //}\n      return pSrc;\n    }\n\n    /*\n    ** Generate VDBE code for zero or more statements inside the body of a\n    ** trigger.\n    */\n    static int codeTriggerProgram(\n    Parse pParse,            /* The parser context */\n    TriggerStep pStepList,   /* List of statements inside the trigger body */\n    int orconfin              /* Conflict algorithm. (OE_Abort, etc) */\n    )\n    {\n      TriggerStep pTriggerStep = pStepList;\n      int orconf;\n      Vdbe v = pParse.pVdbe;\n      sqlite3 db = pParse.db;\n\n      Debug.Assert( pTriggerStep != null );\n      Debug.Assert( v != null );\n      sqlite3VdbeAddOp2( v, OP_ContextPush, 0, 0 );\n#if SQLITE_DEBUG\n      VdbeComment( v, "begin trigger %s", pStepList.pTrig.name );\n#endif\n      while ( pTriggerStep != null )\n      {\n        sqlite3ExprCacheClear( pParse );\n        orconf = ( orconfin == OE_Default ) ? pTriggerStep.orconf : orconfin;\n        pParse.trigStack.orconf = orconf;\n        switch ( pTriggerStep.op )\n        {\n          case TK_UPDATE:\n            {\n              SrcList pSrc;\n              pSrc = targetSrcList( pParse, pTriggerStep );\n              sqlite3VdbeAddOp2( v, OP_ResetCount, 0, 0 );\n              sqlite3Update( pParse, pSrc,\n              sqlite3ExprListDup( db, pTriggerStep.pExprList, 0 ),\n              sqlite3ExprDup( db, pTriggerStep.pWhere, 0 ), orconf );\n              sqlite3VdbeAddOp2( v, OP_ResetCount, 1, 0 );\n              break;\n            }\n          case TK_INSERT:\n            {\n              SrcList pSrc;\n              pSrc = targetSrcList( pParse, pTriggerStep );\n              sqlite3VdbeAddOp2( v, OP_ResetCount, 0, 0 );\n              sqlite3Insert( pParse, pSrc,\n              sqlite3ExprListDup( db, pTriggerStep.pExprList, 0 ),\n              sqlite3SelectDup( db, pTriggerStep.pSelect, 0 ),\n              sqlite3IdListDup( db, pTriggerStep.pIdList ), orconf );\n              sqlite3VdbeAddOp2( v, OP_ResetCount, 1, 0 );\n              break;\n            }\n          case TK_DELETE:\n            {\n              SrcList pSrc;\n              sqlite3VdbeAddOp2( v, OP_ResetCount, 0, 0 );\n              pSrc = targetSrcList( pParse, pTriggerStep );\n              sqlite3DeleteFrom( pParse, pSrc,\n              sqlite3ExprDup( db, pTriggerStep.pWhere, 0 ) );\n              sqlite3VdbeAddOp2( v, OP_ResetCount, 1, 0 );\n              break;\n            }\n          default: Debug.Assert( pTriggerStep.op == TK_SELECT );\n            {\n              Select ss = sqlite3SelectDup( db, pTriggerStep.pSelect, 0 );\n              if ( ss != null )\n              {\n                SelectDest dest = new SelectDest();\n\n                sqlite3SelectDestInit( dest, SRT_Discard, 0 );\n                sqlite3Select( pParse, ss, ref dest );\n                sqlite3SelectDelete( db, ref ss );\n              }\n              break;\n            }\n        }\n        pTriggerStep = pTriggerStep.pNext;\n      }\n      sqlite3VdbeAddOp2( v, OP_ContextPop, 0, 0 );\n#if SQLITE_DEBUG\n      VdbeComment( v, "end trigger %s", pStepList.pTrig.name );\n#endif\n      return 0;\n    }\n\n    /*\n    ** This is called to code FOR EACH ROW triggers.\n    **\n    ** When the code that this function generates is executed, the following\n    ** must be true:\n    **\n    ** 1. No cursors may be open in the main database.  (But newIdx and oldIdx\n    **    can be indices of cursors in temporary tables.  See below.)\n    **\n    ** 2. If the triggers being coded are ON INSERT or ON UPDATE triggers, then\n    **    a temporary vdbe cursor (index newIdx) must be open and pointing at\n    **    a row containing values to be substituted for new.* expressions in the\n    **    trigger program(s).\n    **\n    ** 3. If the triggers being coded are ON DELETE or ON UPDATE triggers, then\n    **    a temporary vdbe cursor (index oldIdx) must be open and pointing at\n    **    a row containing values to be substituted for old.* expressions in the\n    **    trigger program(s).\n    **\n    ** If they are not NULL, the piOldColMask and piNewColMask output variables\n    ** are set to values that describe the columns used by the trigger program\n    ** in the OLD.* and NEW.* tables respectively. If column N of the\n    ** pseudo-table is read at least once, the corresponding bit of the output\n    ** mask is set. If a column with an index greater than 32 is read, the\n    ** output mask is set to the special value 0xffffffff.\n    **\n    */\n    static int sqlite3CodeRowTrigger(\n    Parse pParse,        /* Parse context */\n    Trigger pTrigger,    /* List of triggers on table pTab */\n    int op,              /* One of TK_UPDATE, TK_INSERT, TK_DELETE */\n    ExprList pChanges,   /* Changes list for any UPDATE OF triggers */\n    int tr_tm,           /* One of TRIGGER_BEFORE, TRIGGER_AFTER */\n    Table pTab,          /* The table to code triggers from */\n    int newIdx,          /* The indice of the "new" row to access */\n    int oldIdx,          /* The indice of the "old" row to access */\n    int orconf,          /* ON CONFLICT policy */\n    int ignoreJump,      /* Instruction to jump to for RAISE(IGNORE) */\n    ref u32 piOldColMask,/* OUT: Mask of columns used from the OLD.* table */\n    ref u32 piNewColMask /* OUT: Mask of columns used from the NEW.* table */\n    )\n    {\n      Trigger p;\n      sqlite3 db = pParse.db;\n      TriggerStack trigStackEntry = new TriggerStack();\n\n      trigStackEntry.oldColMask = 0;\n      trigStackEntry.newColMask = 0;\n\n      Debug.Assert( op == TK_UPDATE || op == TK_INSERT || op == TK_DELETE );\n      Debug.Assert( tr_tm == TRIGGER_BEFORE || tr_tm == TRIGGER_AFTER );\n\n      Debug.Assert( newIdx != -1 || oldIdx != -1 );\n\n      for ( p = pTrigger ; p != null ; p = p.pNext )\n      {\n        bool fire_this = false;\n\n        /* Sanity checking:  The schema for the trigger and for the table are\n        ** always defined.  The trigger must be in the same schema as the table\n        ** or else it must be a TEMP trigger. */\n        Debug.Assert( p.pSchema != null );\n        Debug.Assert( p.pTabSchema != null );\n        Debug.Assert( p.pSchema == p.pTabSchema || p.pSchema == db.aDb[1].pSchema );\n\n        /* Determine whether we should code this trigger */\n        if (\n        p.op == op &&\n        p.tr_tm == tr_tm &&\n        checkColumnOverlap( p.pColumns, pChanges ) != 0 )\n        {\n          TriggerStack pS;      /* Pointer to trigger-stack entry */\n          for ( pS = pParse.trigStack ; pS != null && p != pS.pTrigger ; pS = pS.pNext ) { }\n          if ( pS == null )\n          {\n            fire_this = true;\n          }\n#if FALSE   // * Give no warning for recursive triggers.  Just do not do them */\nelse{\nsqlite3ErrorMsg(pParse, "recursive triggers not supported (%s)",\np.name);\nreturn SQLITE_ERROR;\n}\n#endif\n        }\n\n        if ( fire_this )\n        {\n          int endTrigger;\n          Expr whenExpr;\n          AuthContext sContext;\n          NameContext sNC;\n\n#if !SQLITE_OMIT_TRACE\n          sqlite3VdbeAddOp4( pParse.pVdbe, OP_Trace, 0, 0, 0,\n          sqlite3MPrintf( db, "-- TRIGGER %s", p.name ),\n          P4_DYNAMIC );\n#endif\n          sNC = new NameContext();// memset( &sNC, 0, sizeof(sNC) )\n          sNC.pParse = pParse;\n\n          /* Push an entry on to the trigger stack */\n          trigStackEntry.pTrigger = p;\n          trigStackEntry.newIdx = newIdx;\n          trigStackEntry.oldIdx = oldIdx;\n          trigStackEntry.pTab = pTab;\n          trigStackEntry.pNext = pParse.trigStack;\n          trigStackEntry.ignoreJump = ignoreJump;\n          pParse.trigStack = trigStackEntry;\n#if !SQLITE_OMIT_AUTHORIZATION\nsqlite3AuthContextPush( pParse, sContext, p.name );\n#endif\n\n          /* code the WHEN clause */\n          endTrigger = sqlite3VdbeMakeLabel( pParse.pVdbe );\n          whenExpr = sqlite3ExprDup( db, p.pWhen, 0 );\n          if ( /* db.mallocFailed != 0 || */ sqlite3ResolveExprNames( sNC, ref whenExpr ) != 0 )\n          {\n            pParse.trigStack = trigStackEntry.pNext;\n            sqlite3ExprDelete( db, ref whenExpr );\n            return 1;\n          }\n          sqlite3ExprIfFalse( pParse, whenExpr, endTrigger, SQLITE_JUMPIFNULL );\n          sqlite3ExprDelete( db, ref whenExpr );\n\n          codeTriggerProgram( pParse, p.step_list, orconf );\n\n          /* Pop the entry off the trigger stack */\n          pParse.trigStack = trigStackEntry.pNext;\n#if !SQLITE_OMIT_AUTHORIZATION\nsqlite3AuthContextPop( sContext );\n#endif\n          sqlite3VdbeResolveLabel( pParse.pVdbe, endTrigger );\n        }\n      }\n      piOldColMask |= trigStackEntry.oldColMask; // if ( piOldColMask != 0 ) piOldColMask |= trigStackEntry.oldColMask;\n      piNewColMask |= trigStackEntry.newColMask; // if ( piNewColMask != 0 ) piNewColMask |= trigStackEntry.newColMask;\n      return 0;\n    }\n#endif // * !SQLITE_OMIT_TRIGGER) */\n\n  }\n}\n'