b'{-# LANGUAGE OverloadedStrings #-}\n\n-- | Unicode CMap defines mapping from glyphs to text\n\nmodule Pdf.Content.UnicodeCMap\n(\n  UnicodeCMap(..),\n  parseUnicodeCMap,\n  unicodeCMapNextGlyph,\n  unicodeCMapDecodeGlyph\n)\nwhere\n\nimport Data.Char\nimport qualified Data.List as List\nimport Data.Map (Map)\nimport qualified Data.Map as Map\nimport Data.ByteString (ByteString)\nimport qualified Data.ByteString as ByteString\nimport qualified Data.ByteString.Base16 as Base16\nimport Data.Text (Text)\nimport qualified Data.Text as Text\nimport qualified Data.Text.Encoding as Text\nimport Data.Attoparsec.ByteString.Char8 (Parser, parseOnly)\nimport qualified Data.Attoparsec.ByteString.Char8 as P\nimport Control.Monad\nimport qualified Control.Monad.Fail as Fail\n\n-- | Unicode character map\n--\n-- Font dictionary can contain \\"ToUnicode\\" key -- reference\n-- to a stream with unicode CMap\ndata UnicodeCMap = UnicodeCMap {\n  unicodeCMapCodeRanges :: [(ByteString, ByteString)],\n  unicodeCMapChars :: Map Int Text,\n  unicodeCMapRanges :: [(Int, Int, Char)]\n  }\n  deriving (Show)\n\n-- | Parse content of unicode CMap\nparseUnicodeCMap :: ByteString -> Either String UnicodeCMap\nparseUnicodeCMap cmap =\n  case (codeRanges, chars, ranges) of\n    (Right cr, Right cs, Right (rs, crs)) -> Right $ UnicodeCMap {\n      unicodeCMapCodeRanges = cr,\n      unicodeCMapChars = cs <> crs,\n      unicodeCMapRanges = rs\n      }\n    (Left err, _, _) -> Left $ "CMap code ranges: " ++ err\n    (_, Left err, _) -> Left $ "CMap chars: " ++ err\n    (_, _, Left err) -> Left $ "CMap ranges: " ++ err\n  where\n  codeRanges = parseOnly codeRangesParser cmap\n  chars = parseOnly charsParser cmap\n  ranges = parseOnly rangesParser cmap\n\n-- | Take the next glyph code from string, also returns the rest of the string\nunicodeCMapNextGlyph :: UnicodeCMap -> ByteString -> Maybe (Int, ByteString)\nunicodeCMapNextGlyph cmap = go 1\n  where\n  go 5 _ = Nothing\n  go n str =\n    let glyph = ByteString.take n str in\n    if ByteString.length glyph /= n\n      then Nothing\n      else if any (inRange glyph) (unicodeCMapCodeRanges cmap)\n             then Just (toCode glyph, ByteString.drop n str)\n             else go (n + 1) str\n  inRange glyph (start, end)\n    = ByteString.length glyph == ByteString.length start\n    && glyph >= start && glyph <= end\n\ntoCode :: ByteString -> Int\ntoCode bs = fst $ ByteString.foldr (\\b (sm, i) ->\n                    (sm + fromIntegral b * i, i * 256)) (0, 1) bs\n\n-- | Convert glyph to text\n--\n-- Note: one glyph can represent more then one char, e.g. for ligatures\nunicodeCMapDecodeGlyph :: UnicodeCMap -> Int -> Maybe Text\nunicodeCMapDecodeGlyph cmap glyph =\n  case Map.lookup glyph (unicodeCMapChars cmap) of\n    Just txt -> Just txt\n    Nothing ->\n      case filter inRange (unicodeCMapRanges cmap) of\n        [(start, _, char)] -> Just (Text.singleton $ toEnum\n                                    $ (fromEnum char) + (glyph - start))\n        _ -> Nothing\n  where\n  inRange (start, end, _) = glyph >= start && glyph <= end\n\ncharsParser :: Parser (Map Int Text)\ncharsParser =\n  combineChars <$> P.many\' charsParser\'\n  where\n  combineChars = List.foldl\' Map.union Map.empty\n\ncharsParser\' :: Parser (Map Int Text)\ncharsParser\' = do\n  n <- skipTillParser $ do\n    n <- P.decimal\n    P.skipSpace\n    _ <- P.string "beginbfchar"\n    return n\n\n  chars <- replicateM n $ do\n    P.skipSpace\n    i <- parseHex\n    P.skipSpace\n    j <- parseHex\n    return (toCode i, Text.decodeUtf16BE j)\n\n  return $ Map.fromList chars\n\n-- | It returns regular ranges and char map\n--\n-- Array ranges are converted to char map\nrangesParser :: Parser ([(Int, Int, Char)], Map Int Text)\nrangesParser =\n  combineRanges <$> P.many\' rangesParser\'\n  where\n  combineRanges = List.foldl\' combineRange ([], Map.empty)\n  combineRange (ranges, rmap) (ranges\', rmap\') =\n    (ranges ++ ranges\', Map.union rmap rmap\')\n\nrangesParser\' :: Parser ([(Int, Int, Char)], Map Int Text)\nrangesParser\' = do\n  n <- skipTillParser $ do\n    n <- P.decimal\n    P.skipSpace\n    void $ P.string "beginbfrange"\n    return (n :: Int)\n\n  let go 0 rs cs = return (rs, cs)\n      go count rs cs = do\n        P.skipSpace\n        i <- toCode <$> parseHex\n        P.skipSpace\n        j <- toCode <$> parseHex\n        P.skipSpace\n        k <- P.eitherP parseHex parseHexArray\n        case k of\n          Left h -> do\n            c <- case Text.uncons $ Text.decodeUtf16BE h of\n                   Nothing -> fail "Can\'t decode range"\n                   Just (v, _) -> return v\n            go (pred count) ((i, j, c) : rs) cs\n          Right hs -> do\n            let cs\' = zip [i..j] . map Text.decodeUtf16BE $ hs\n            go (pred count) rs (cs <> Map.fromList cs\')\n\n  go n mempty mempty\n\ncodeRangesParser :: Parser [(ByteString, ByteString)]\ncodeRangesParser = do\n  n <- skipTillParser $ do\n    n <- P.decimal\n    P.skipSpace\n    void $ P.string "begincodespacerange"\n    return n\n\n  replicateM n $ do\n    P.skipSpace\n    i <- parseHex\n    P.skipSpace\n    j <- parseHex\n    return (i, j)\n\nparseHex :: Parser ByteString\nparseHex = do\n  void $ P.char \'<\'\n  -- hex can contain spaces, lets filter them out\n  res <- P.takeTill (== \'>\') >>= fromHex . ByteString.filter (/= 32)\n  void $ P.char \'>\'\n  return res\n\nparseHexArray :: Parser [ByteString]\nparseHexArray = do\n  void $ P.char \'[\'\n  res <- P.many\' $ do\n    P.skipSpace\n    parseHex\n  P.skipSpace\n  void $ P.char \']\'\n  return res\n\n-- XXX: wtf?!\nfromHex :: Fail.MonadFail m => ByteString -> m ByteString\nfromHex hex = do\n  case Base16.decode (bsToLower hex) of\n    Left err -> fail err\n    Right str -> return str\n  where\n  bsToLower = ByteString.map $ fromIntegral\n                     . fromEnum\n                     . toLower\n                     . toEnum\n                     . fromIntegral\n\nskipTillParser :: Parser a -> Parser a\nskipTillParser p = P.choice [\n  p,\n  P.anyChar >> skipTillParser p\n  ]\n'