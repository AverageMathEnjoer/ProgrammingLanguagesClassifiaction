b'package com.bennyhuo.kotlin.tailrec\n\nimport kotlin.time.ExperimentalTime\nimport kotlin.time.measureTime\n\n\n/**\n * Created by benny.\n */\n@OptIn(ExperimentalTime::class)\nfun main() {\n//    timeCost { factorial(10u) }\n//    timeCost { factorialTR(10u) }\n//    timeCost { factorialLoop(10u) }\n//\n//    timeCost { fibonacciTR(1000u) }\n//    timeCost { fibonacciLoop(1000u) }\n    timeCost { fibonacci(50u) }\n}\n\n@OptIn(ExperimentalTime::class)\ninline fun timeCost(block: () -> Unit) {\n    measureTime {\n        block()\n    }.let {\n        println(it.inWholeMilliseconds)\n    }\n}\n\n//region factorial\nfun factorial(n: UInt): UInt {\n    if (n == 0u) return 1u\n    return n * factorial(n - 1u)\n}\n\nfun factorialTR(n: UInt): UInt {\n    tailrec fun factorialInner(n: UInt, result: UInt): UInt {\n        if (n <= 1u) return result\n        return factorialInner(n - 1u, result * n)\n    }\n    return factorialInner(n, 1u)\n}\n\nfun factorialLoop(n: UInt): UInt {\n    var result = 1u\n    for (i in 1u..n) {\n        result *= i\n    }\n    return result\n}\n//endregion\n\n//region fibonacci\nfun fibonacci(n: UInt): UInt {\n    if (n < 2u) return n\n    return fibonacci(n - 1u) + fibonacci(n - 2u)\n}\n\nfun fibonacciTR(n: UInt): UInt {\n    if (n < 2u) return n\n\n    tailrec fun fibonacciInner(n: UInt, a: UInt, b: UInt): UInt {\n        if (n < 2u) return b\n        return fibonacciInner(n - 1u, b, a + b)\n    }\n    return fibonacciInner(n, 0u, 1u)\n}\n\nfun fibonacciLoop(n: UInt): UInt {\n    if (n < 2u) return n\n\n    var a = 0u\n    var b = 1u\n    for (i in 2u..n) {\n        val tmp = b\n        b = a + b\n        a = tmp\n\n        //region same but confusing\n        // b = a + b\n        // a = b - a\n        //endregion\n    }\n    return b\n}\n//endregion\n\n//region List\nsealed class List<out T> {\n    object Nil : List<Nothing?>()\n    class Cons<T>(val value: T, val next: List<T>) : List<T>()\n}\n\ntailrec fun <T> List<T>.forEach(block: (T) -> Unit) {\n    when (this) {\n        List.Nil -> return\n        is List.Cons<T> -> {\n            block(value)\n            next.forEach(block)\n        }\n    }\n}\n\nfun <T> listOf(vararg values: T): List<T> {\n    return values.reversedArray().fold(List.Nil as List<T>) { acc, t ->\n        List.Cons(t, acc)\n    }\n}\n//endregion'