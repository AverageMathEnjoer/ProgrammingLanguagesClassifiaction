b'#include "stdafx.h"\n#include "resource.h"\n#include "MainWindow2.h"\n#include "AssetDependDialog.h"\n#include "../libStringConverter/convert.h"\n#include <WindowsX.h>\n\n/*\nTODO\n- Add/Remove dependencies - should be possible with the existing AssetsFileContextInfo and replacers infrastructure.\n*/\n\nAssetDependDialog::~AssetDependDialog()\n{\n\tpContext->getMainWindow().unregisterEventHandler(eventHandlerHandle);\n}\nAssetDependDialog::AssetDependDialog(class Win32AppContext *pContext, HWND hParentWnd)\n\t: pContext(pContext), hParentWnd(hParentWnd), hDialog(NULL),\n\thCurEditPopup(NULL), iEditPopupItem(0), iEditPopupSubItem(0),\n\tpCurFileEntry(nullptr)\n{\n\teventHandlerHandle = pContext->getMainWindow().registerEventHandler(this);\n}\n\nvoid AssetDependDialog::addFileContext(const std::pair<FileEntryUIInfo*,uintptr_t> &fileContext)\n{\n\tFileContextInfo *pContextInfo = fileContext.first->getContextInfoPtr();\n\tif (AssetsFileContextInfo *pAssetsInfo = dynamic_cast<AssetsFileContextInfo*>(pContextInfo))\n\t{\n\t\tunsigned int fileID = pAssetsInfo->getFileID();\n\t\tauto entryIt = fileEntries.find(fileID);\n\t\tassert(entryIt == fileEntries.end());\n\t\tif (entryIt == fileEntries.end())\n\t\t{\n\t\t\tfileEntries.insert(std::make_pair(fileID, fileContext.first));\n\t\t\tif (pCurFileEntry == nullptr || pCurFileEntry->getContextInfoPtr() == nullptr\n\t\t\t\t|| pAssetsInfo->getFileID() < pCurFileEntry->getContextInfoPtr()->getFileID())\n\t\t\t{\n\t\t\t\tpCurFileEntry = fileContext.first;\n\t\t\t\tonUpdateCurrentFile();\n\t\t\t}\n\t\t}\n\t}\n\n}\nvoid AssetDependDialog::removeFileContext(FileEntryUIInfo *pContext)\n{\n\tFileContextInfo *pContextInfo = pContext->getContextInfoPtr();\n\tif (AssetsFileContextInfo *pAssetsInfo = dynamic_cast<AssetsFileContextInfo*>(pContextInfo))\n\t{\n\t\tunsigned int fileID = pAssetsInfo->getFileID();\n\t\tauto entryIt = fileEntries.find(fileID);\n\t\tassert(entryIt != fileEntries.end());\n\t\tassert(entryIt->second == pContext);\n\t\tif (entryIt != fileEntries.end())\n\t\t\tfileEntries.erase(entryIt);\n\t}\n\telse\n\t{\n\t\tfor (auto it = fileEntries.begin(); it != fileEntries.end(); ++it)\n\t\t{\n\t\t\tif (it->second == pContext)\n\t\t\t{\n\t\t\t\tfileEntries.erase(it);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif (pContext == pCurFileEntry)\n\t{\n\t\tif (!fileEntries.empty())\n\t\t\tpCurFileEntry = fileEntries.begin()->second;\n\t\telse\n\t\t\tpCurFileEntry = nullptr;\n\t\tonUpdateCurrentFile();\n\t}\n}\nEFileManipulateDialogType AssetDependDialog::getType()\n{\n\treturn FileManipulateDialog_AssetsDependencies;\n}\nHWND AssetDependDialog::getWindowHandle()\n{\n\treturn hDialog;\n}\nvoid AssetDependDialog::onHotkey(ULONG message, DWORD keyCode) //message : currently only WM_KEYDOWN; keyCode : VK_F3 for instance\n{\n\n}\nbool AssetDependDialog::onCommand(WPARAM wParam, LPARAM lParam) //Called for unhandled WM_COMMAND messages. Returns true if this dialog has handled the request, false otherwise.\n{\n\treturn false;\n}\nvoid AssetDependDialog::onShow()\n{\n\tif (!this->hDialog)\n\t{\n\t\tthis->hDialog = CreateDialogParam(pContext->getMainWindow().getHInstance(), MAKEINTRESOURCE(IDD_ASSETSDEPEND2), hParentWnd, AssetDependProc, (LPARAM)this);\n\t\tonUpdateCurrentFile();\n\t}\n}\nvoid AssetDependDialog::onHide()\n{\n\tif (this->hDialog)\n\t{\n\t\tif (this->hCurEditPopup != NULL)\n\t\t\tdoCloseEditPopup();\n\t\tSendMessage(this->hDialog, WM_CLOSE, 0, 0);\n\t}\n}\nbool AssetDependDialog::hasUnappliedChanges(bool *applyable)\n{\n\treturn false;\n}\nbool AssetDependDialog::applyChanges()\n{\n\treturn true;\n}\nbool AssetDependDialog::doesPreferNoAutoclose()\n{\n\treturn false;\n}\n\nvoid AssetDependDialog::list_updateAssetPath(HWND hList, int iItem, const AssetsFileDependency *pDependency)\n{\n\tauto upText = unique_MultiByteToTCHAR(pDependency->assetPath);\n\tLVITEM item;\n\titem.mask = LVIF_TEXT;\n\titem.pszText = upText.get();\n\titem.cchTextMax = 256;\n\titem.iItem = iItem;\n\titem.iSubItem = 1;\n\tListView_SetItem(hList, &item);\n}\nvoid AssetDependDialog::list_updateTargetAsset(HWND hList, int iItem, unsigned int reference)\n{\n\tLVITEM item;\n\titem.mask = LVIF_TEXT;\n\titem.cchTextMax = 256;\n\titem.pszText = const_cast<TCHAR*>(TEXT("None"));\n\tTCHAR *resolvedToText = nullptr;\n\tif (reference != 0)\n\t{\n\t\tif (FileContextInfo_ptr pReferencedInfo = this->pContext->getContextInfo(reference))\n\t\t{\n\t\t\tchar referenceFileIDTmp[32];\n\t\t\tsprintf_s(referenceFileIDTmp, "%u - ", reference);\n\t\t\tstd::string resolvedToText8 = std::string(referenceFileIDTmp) + pReferencedInfo->getFileName();\n\n\t\t\tsize_t tmp;\n\t\t\tresolvedToText = _MultiByteToTCHAR(resolvedToText8.c_str(), tmp);\n\t\t\titem.pszText = resolvedToText;\n\t\t}\n\t}\n\titem.iItem = iItem;\n\titem.iSubItem = 2;\n\tListView_SetItem(hList, &item);\n\tif (resolvedToText)\n\t\t_FreeTCHAR(resolvedToText);\n}\n\nvoid AssetDependDialog::onUpdateCurrentFile()\n{\n\tHWND hList = GetDlgItem(hDialog, IDC_DEPENDLIST);\n\tListView_DeleteAllItems(hList);\n\tif (pCurFileEntry != nullptr && pCurFileEntry->getContextInfoPtr() != nullptr)\n\t{\n\t\tauto* pContextInfo = static_cast<AssetsFileContextInfo*>(pCurFileEntry->getContextInfoPtr());\n\t\tauto refLock = pContextInfo->lockReferencesRead();\n\t\tconst std::vector<unsigned int> &references = pContextInfo->getReferencesRead(refLock);\n\t\tconst std::vector<AssetsFileDependency> &dependencies = pContextInfo->getDependenciesRead(refLock);\n\n\t\tint listViewCount = 0;\n\t\tfor (size_t i = 0; i < dependencies.size(); i++)\n\t\t{\n\t\t\tconst AssetsFileDependency &dependency = dependencies[i];\n\t\t\tif (dependency.type != 0)\n\t\t\t\tcontinue;\n\t\t\tTCHAR fileIDTmp[32];\n\t\t\t_stprintf_s(fileIDTmp, TEXT("%u"), i + 1);\n\t\t\tLVITEM item;\n\t\t\titem.mask = LVIF_TEXT | LVIF_PARAM;\n\t\t\titem.lParam = (LPARAM)i;\n\t\t\titem.iItem = listViewCount;\n\t\t\titem.iSubItem = 0;\n\t\t\titem.pszText = fileIDTmp;\n\t\t\tListView_InsertItem(hList, &item);\n\t\t\t\t\t\n\t\t\tlist_updateAssetPath(hList, listViewCount, &dependency);\n\t\t\t\t\t\n\t\t\tlist_updateTargetAsset(hList, listViewCount, references[i]);\n\n\t\t\tassert(listViewCount < INT_MAX);\n\t\t\tlistViewCount++;\n\t\t}\n\t}\n}\n\ninline void doMoveWindow(HDWP &deferCtx, bool &retry, HWND hWnd, int x, int y, int w, int h)\n{\n\tif (deferCtx)\n\t{\n\t\tdeferCtx = DeferWindowPos(deferCtx, hWnd, HWND_TOP, x, y, w, h, SWP_NOACTIVATE | SWP_NOOWNERZORDER | SWP_NOZORDER);\n\t\tif (!deferCtx)\n\t\t\tretry = true;\n\t}\n\telse\n\t\tSetWindowPos(hWnd, HWND_TOP, x, y, w, h, SWP_NOACTIVATE | SWP_NOOWNERZORDER | SWP_NOZORDER);\n}\nstatic void onResize(HWND hDlg, bool defer = true)\n{\n\t//Add/Remove is not implemented\n\tShowWindow(GetDlgItem(hDlg, IDC_BTNADD), SW_HIDE);\n\tShowWindow(GetDlgItem(hDlg, IDC_BTNREMOVE), SW_HIDE);\n\n\tHDWP deferCtx = defer ? BeginDeferWindowPos(12) : NULL;\n\tbool retry = false;\n\n\tRECT client = {};\n\tGetClientRect(hDlg, &client);\n\tLONG clientWidth = client.right-client.left;\n\tLONG clientHeight = client.bottom-client.top;\n\tLONG x = 19;\n\tLONG w = clientWidth - 16;\n\n\tdoMoveWindow(deferCtx, retry, GetDlgItem(hDlg, IDC_STATICTITLE),     x + 2,       10,                w - 4,  15);\n\tdoMoveWindow(deferCtx, retry, GetDlgItem(hDlg, IDC_DEPENDLIST), x,           30,                w - 15, clientHeight - 60 - 7);\n\tdoMoveWindow(deferCtx, retry, GetDlgItem(hDlg, IDC_BTNADD),     x + 5,       clientHeight - 30, 125,    25);\n\tdoMoveWindow(deferCtx, retry, GetDlgItem(hDlg, IDC_BTNREMOVE),  x + 5 + 145, clientHeight - 30, 125,    25);\n\n\tif (defer)\n\t{\n\t\tif (retry || !EndDeferWindowPos(deferCtx))\n\t\t\tonResize(hDlg, false);\n\t\telse\n\t\t\tUpdateWindow(hDlg);\n\t\tdeferCtx = NULL;\n\t}\n\telse\n\t\tUpdateWindow(hDlg);\n\n}\n\nvoid AssetDependDialog::doCloseEditPopup(bool applyChanges)\n{\n\tif (applyChanges)\n\t{\n\t\tif (pCurFileEntry == nullptr || pCurFileEntry->getContextInfoPtr() == nullptr)\n\t\t{\n\t\t\tdoCloseEditPopup(false);\n\t\t\treturn;\n\t\t}\n\t\tAssetsFileContextInfo *pAssetsFileInfo = static_cast<AssetsFileContextInfo*>(pCurFileEntry->getContextInfoPtr());\n\n\t\tHWND hList = GetDlgItem(hDialog, IDC_DEPENDLIST);\n\t\tLVITEM item;\n\t\titem.mask = LVIF_PARAM;\n\t\titem.lParam = (LPARAM)-1;\n\t\titem.iItem = iEditPopupItem;\n\t\titem.iSubItem = 0;\n\t\tListView_GetItem(hList, &item);\n\n\t\tsize_t dependencyIdx = item.lParam;\n\t\tauto refLock = pAssetsFileInfo->lockReferencesWrite();\n\t\tstd::vector<unsigned int> &references = pAssetsFileInfo->getReferencesWrite(refLock);\n\t\tstd::vector<AssetsFileDependency>& dependencies = pAssetsFileInfo->getDependenciesWrite(refLock);\n\n\t\tassert(dependencyIdx < dependencies.size());\n\t\tassert(dependencies.size() == references.size());\n\t\tif (dependencyIdx >= dependencies.size()\n\t\t\t|| dependencyIdx >= references.size())\n\t\t{\n\t\t\trefLock.unlock();\n\t\t\tdoCloseEditPopup(false);\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tswitch (iEditPopupSubItem)\n\t\t{\n\t\t\tcase 1: //Dependency name/text\n\t\t\t\t{\n\t\t\t\t\tint nameLen = Edit_GetTextLength(hCurEditPopup);\n\t\t\t\t\tif (nameLen > 0 && nameLen < INT_MAX - 2)\n\t\t\t\t\t{\n\t\t\t\t\t\tstd::unique_ptr<TCHAR[]> nameT(new TCHAR[nameLen + 2]);\n\t\t\t\t\t\tnameT[0] = 0;\n\t\t\t\t\t\tnameT[nameLen + 1] = 0;\n\t\t\t\t\t\tEdit_GetText(hCurEditPopup, nameT.get(), nameLen + 1);\n\t\t\t\t\t\tsize_t name8Len = 0;\n\t\t\t\t\t\tauto name8 = unique_TCHARToMultiByte(nameT.get(), name8Len);\n\t\t\t\t\t\tAssetsFileDependency *pDependencyEntry = &dependencies[dependencyIdx];\n\t\t\t\t\t\tif (name8Len < sizeof(pDependencyEntry->assetPath) / sizeof(char))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tmemcpy_s(pDependencyEntry->assetPath, sizeof(pDependencyEntry->assetPath),\n\t\t\t\t\t\t\t\tname8.get(), (name8Len + 1) * sizeof(char));\n\t\t\t\t\t\t\tpAssetsFileInfo->setDependenciesChanged();\n\t\t\t\t\t\t\tlist_updateAssetPath(hList, iEditPopupItem, pDependencyEntry);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\trefLock.unlock();\n\t\t\t\t\tpContext->OnUpdateDependencies(pAssetsFileInfo, dependencyIdx, dependencyIdx);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 2: //Dependency target\n\t\t\t\t{\n\t\t\t\t\tint iSelection = ComboBox_GetCurSel(hCurEditPopup);\n\t\t\t\t\tif (iSelection < 0)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tunsigned int newReferenceTarget = 0;\n\t\t\t\t\tif (iSelection == 0)\n\t\t\t\t\t\tnewReferenceTarget = 0;\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tsize_t iComboBoxItem = 1;\n\t\t\t\t\t\tauto &fileEntries = pContext->getMainWindow().getFileEntries();\n\t\t\t\t\t\t//Slightly janky. A mapping from combo box index to file ID would be better.\n\t\t\t\t\t\tfor (auto fileIt = fileEntries.begin(); fileIt != fileEntries.end(); ++fileIt)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (fileIt->pContextInfo != pCurFileEntry->pContextInfo &&\n\t\t\t\t\t\t\t\tfileIt->pContextInfo && \n\t\t\t\t\t\t\t\tfileIt->pContextInfo->getFileContext() && \n\t\t\t\t\t\t\t\tfileIt->pContextInfo->getFileContext()->getType() == FileContext_Assets)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif (iComboBoxItem == iSelection)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tnewReferenceTarget = fileIt->pContextInfo->getFileID();\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tiComboBoxItem++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tunsigned int prevReferenceTarget = references[dependencyIdx];\n\t\t\t\t\treferences[dependencyIdx] = newReferenceTarget;\n\n\t\t\t\t\trefLock.unlock();\n\n\t\t\t\t\tif (prevReferenceTarget != 0 && newReferenceTarget != prevReferenceTarget)\n\t\t\t\t\t{\n\t\t\t\t\t\t//Remove the containerSources entry in the previously referenced AssetsFileContextInfo, if it exists.\n\t\t\t\t\t\tFileContextInfo_ptr pOldTargetFileInfo = pContext->getContextInfo(prevReferenceTarget);\n\t\t\t\t\t\t//May be null (if the referenced file was closed).\n\t\t\t\t\t\tif (pOldTargetFileInfo &&\n\t\t\t\t\t\t\tpOldTargetFileInfo->getFileContext() &&\n\t\t\t\t\t\t\tpOldTargetFileInfo->getFileContext()->getType() == FileContext_Assets)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tAssetsFileContextInfo *pTargetAssetsInfo = static_cast<AssetsFileContextInfo*>(pOldTargetFileInfo.get());\n\t\t\t\t\t\t\tstd::vector<unsigned int> &containerSources = pTargetAssetsInfo->getContainerSources();\n\t\t\t\t\t\t\tfor (size_t i = 0; i < containerSources.size(); i++)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif (containerSources[i] == pAssetsFileInfo->getFileID())\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tcontainerSources.erase(containerSources.begin() + i);\n\t\t\t\t\t\t\t\t\tpContext->OnUpdateContainers(pTargetAssetsInfo);\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbool hasContainers;\n\t\t\t\t\t{\n\t\t\t\t\t\tAssetContainerList &containers = pAssetsFileInfo->lockContainersRead();\n\t\t\t\t\t\thasContainers = (containers.getContainerCount() > 0);\n\t\t\t\t\t\tpAssetsFileInfo->unlockContainersRead();\n\t\t\t\t\t}\n\t\t\t\t\tif (newReferenceTarget != 0 && hasContainers)\n\t\t\t\t\t{\n\t\t\t\t\t\t//Add a containerSources entry in the newly referenced AssetsFileContextInfo, if there is a need for it.\n\t\t\t\t\t\tFileContextInfo_ptr pNewTargetFileInfo = pContext->getContextInfo(newReferenceTarget);\n\t\t\t\t\t\tassert(pNewTargetFileInfo &&\n\t\t\t\t\t\t\tpNewTargetFileInfo->getFileContext() &&\n\t\t\t\t\t\t\tpNewTargetFileInfo->getFileContext()->getType() == FileContext_Assets);\n\t\t\t\t\t\tif (pNewTargetFileInfo &&\n\t\t\t\t\t\t\tpNewTargetFileInfo->getFileContext() &&\n\t\t\t\t\t\t\tpNewTargetFileInfo->getFileContext()->getType() == FileContext_Assets)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tAssetsFileContextInfo *pTargetAssetsInfo = static_cast<AssetsFileContextInfo*>(pNewTargetFileInfo.get());\n\t\t\t\t\t\t\tstd::vector<unsigned int> &containerSources = pTargetAssetsInfo->getContainerSources();\n\t\t\t\t\t\t\tbool alreadyExists = false;\n\t\t\t\t\t\t\tfor (size_t i = 0; i < containerSources.size(); i++)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif (containerSources[i] == pAssetsFileInfo->getFileID())\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\talreadyExists = true;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (!alreadyExists)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tcontainerSources.push_back(pAssetsFileInfo->getFileID());\n\t\t\t\t\t\t\t\tpContext->OnUpdateContainers(pTargetAssetsInfo);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tlist_updateTargetAsset(hList, iEditPopupItem, newReferenceTarget);\n\t\t\t\t\tpContext->OnUpdateDependencies(pAssetsFileInfo, dependencyIdx, dependencyIdx);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tassert(false);\n\t\t}\n\t}\n\tDestroyWindow(hCurEditPopup);\n\thCurEditPopup = NULL;\n\tiEditPopupItem = iEditPopupSubItem = 0;\n}\n\nvoid AssetDependDialog::onOpenEditPopup()\n{\n\tif (pCurFileEntry == nullptr || pCurFileEntry->getContextInfoPtr() == nullptr)\n\t{\n\t\tdoCloseEditPopup(false);\n\t\treturn;\n\t}\n\tauto pContextInfo = static_cast<AssetsFileContextInfo*>(pCurFileEntry->getContextInfoPtr());\n\tauto refLock = pContextInfo->lockReferencesRead();\n\tconst std::vector<unsigned int>& references = pContextInfo->getReferencesRead(refLock);\n\tconst std::vector<AssetsFileDependency>& dependencies = pContextInfo->getDependenciesRead(refLock);\n\n\tHWND hList = GetDlgItem(hDialog, IDC_DEPENDLIST);\n\tLVITEM item;\n\titem.mask = LVIF_PARAM;\n\titem.lParam = (LPARAM)-1;\n\titem.iItem = iEditPopupItem;\n\titem.iSubItem = 0;\n\tListView_GetItem(hList, &item);\n\n\tsize_t dependencyIdx = item.lParam;\n\tassert(dependencyIdx < dependencies.size());\n\tassert(dependencies.size() == references.size());\n\tif (dependencyIdx >= dependencies.size()\n\t\t|| dependencyIdx >= references.size())\n\t{\n\t\tdoCloseEditPopup(false);\n\t\treturn;\n\t}\n\n\tswitch (iEditPopupSubItem)\n\t{\n\t\tcase 1: //Dependency name/text\n\t\t\t{\n\t\t\t\tauto pText = unique_MultiByteToTCHAR(dependencies[dependencyIdx].assetPath);\n\t\t\t\tEdit_SetText(hCurEditPopup, pText.get());\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 2: //Dependency target\n\t\t\t{\n\t\t\t\tComboBox_AddString(hCurEditPopup, TEXT("None"));\n\t\t\t\tsize_t iComboBoxItem = 1;\n\t\t\t\tsize_t iSelComboBoxItem = 0;\n\t\t\t\tauto &fileEntries = pContext->getMainWindow().getFileEntries();\n\t\t\t\tfor (auto fileIt = fileEntries.begin(); fileIt != fileEntries.end(); ++fileIt)\n\t\t\t\t{\n\t\t\t\t\t//Do not list the current .assets file in the combo box. However, circular references are allowed.\n\t\t\t\t\tif (fileIt->pContextInfo != pCurFileEntry->pContextInfo &&\n\t\t\t\t\t\tfileIt->pContextInfo && \n\t\t\t\t\t\tfileIt->pContextInfo->getFileContext() && \n\t\t\t\t\t\tfileIt->pContextInfo->getFileContext()->getType() == FileContext_Assets)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (fileIt->pContextInfo->getFileID() == references[dependencyIdx])\n\t\t\t\t\t\t\tiSelComboBoxItem = iComboBoxItem; //Mark the currently set dependency as the selection of the combo box.\n\t\t\t\t\t\tchar referenceFileIDTmp[32];\n\t\t\t\t\t\tsprintf_s(referenceFileIDTmp, "%u - ", fileIt->pContextInfo->getFileID());\n\t\t\t\t\t\tstd::string targetName8 = std::string(referenceFileIDTmp) + fileIt->pContextInfo->getFileName();\n\t\t\t\t\t\tauto upTargetNameT = unique_MultiByteToTCHAR(targetName8.c_str());\n\t\t\t\t\t\tComboBox_AddString(hCurEditPopup, upTargetNameT.get());\n\t\t\t\t\t\tiComboBoxItem++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tComboBox_SetCurSel(hCurEditPopup, iSelComboBoxItem);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tassert(false);\n\t}\n\t//Failure\n\tdoCloseEditPopup(false);\n}\n\n\nINT_PTR CALLBACK AssetDependDialog::AssetDependProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)\n{\n\tINT_PTR ret = (INT_PTR)FALSE;\n\tAssetDependDialog *pThis = (AssetDependDialog*)GetWindowLongPtr(hDlg, GWLP_USERDATA);\n\tswitch (message)\n\t{\n\tcase WM_DESTROY:\n\t\tbreak;\n\tcase WM_NCDESTROY:\n\t\tbreak;\n\tcase WM_CLOSE:\n\t\tif (pThis)\n\t\t\tpThis->hDialog = NULL;\n\t\tDestroyWindow(hDlg);\n\t\tret = (INT_PTR)TRUE;\n\t\tbreak;\n\tcase WM_INITDIALOG:\n\t\t{\n\t\t\tSetWindowLongPtr(hDlg, GWLP_USERDATA, lParam);\n\t\t\tpThis = (AssetDependDialog*)lParam;\n\n\t\t\t//List control columns : Rel File ID; Dependency path; Chosen target file ID (for UABE)\n\t\t\tHWND hList = GetDlgItem(hDlg, IDC_DEPENDLIST);\n\t\t\t//Subclass the ListView to support item edit popups (via double click).\n\t\t\tSetWindowSubclass(hList, AssetDependListViewProc, 0, reinterpret_cast<DWORD_PTR>(pThis));\n\t\t\tListView_SetExtendedListViewStyle(hList, LVS_EX_FULLROWSELECT | LVS_EX_DOUBLEBUFFER);\n\t\t\tLVCOLUMN column;\n\t\t\tZeroMemory(&column, sizeof(LVCOLUMN));\n\t\t\tcolumn.mask = LVCF_TEXT | LVCF_WIDTH | LVCF_SUBITEM;\n\t\t\tcolumn.cx = 70;\n\t\t\tcolumn.pszText = const_cast<TCHAR*>(TEXT("Rel. File ID"));\n\t\t\tcolumn.iSubItem = 0;\n\t\t\tListView_InsertColumn(hList, 0, &column);\n\t\t\tcolumn.cx = 250;\n\t\t\tcolumn.pszText = const_cast<TCHAR*>(TEXT("File Path"));\n\t\t\t//column.iSubItem = 1;\n\t\t\tListView_InsertColumn(hList, 1, &column);\n\t\t\tcolumn.cx = 250;\n\t\t\tcolumn.pszText = const_cast<TCHAR*>(TEXT("Resolved to"));\n\t\t\t//column.iSubItem = 2;\n\t\t\tListView_InsertColumn(hList, 2, &column);\n\n\t\t\tShowWindow(hDlg, SW_SHOW);\n\t\t\tPostMessage(hDlg, WM_SIZE, 0, 0);\n\t\t\tret = (INT_PTR)TRUE;\n\t\t}\n\t\tbreak;\n\tcase WM_SIZE:\n\t\tonResize(hDlg);\n\t\tbreak;\n\t}\n\treturn ret;\n}\nLRESULT CALLBACK AssetDependDialog::AssetDependListViewProc(HWND hWnd, UINT message, \n\tWPARAM wParam, LPARAM lParam, \n\tuintptr_t uIdSubclass, DWORD_PTR dwRefData)\n{\n\tAssetDependDialog *pThis = (AssetDependDialog*)dwRefData;\n\tswitch (message)\n\t{\n\tcase WM_LBUTTONDBLCLK:\n\t\t{\n\t\t\tLVHITTESTINFO hitTestInfo = {};\n\t\t\thitTestInfo.pt.x = GET_X_LPARAM(lParam);\n\t\t\thitTestInfo.pt.y = GET_Y_LPARAM(lParam);\n\t\t\tif (ListView_SubItemHitTest(hWnd, &hitTestInfo) != -1 && hitTestInfo.iSubItem >= 1)\n\t\t\t{\n\t\t\t\tif (pThis->hCurEditPopup != NULL)\n\t\t\t\t\tpThis->doCloseEditPopup();\n\t\t\t\tpThis->iEditPopupItem = hitTestInfo.iItem;\n\t\t\t\tpThis->iEditPopupSubItem = hitTestInfo.iSubItem;\n\t\t\t\t\n\t\t\t\tRECT targetRect = {};\n\t\t\t\tListView_GetSubItemRect(hWnd, hitTestInfo.iItem, hitTestInfo.iSubItem, LVIR_BOUNDS, &targetRect);\n\t\t\t\tif (hitTestInfo.iSubItem == 2)\n\t\t\t\t{\n\t\t\t\t\tpThis->hCurEditPopup = \n\t\t\t\t\t\tCreateWindow(WC_COMBOBOX, TEXT(""), CBS_DROPDOWNLIST | WS_VSCROLL | WS_CHILD | WS_VISIBLE, \n\t\t\t\t\t\t\ttargetRect.left, targetRect.top, targetRect.right - targetRect.left, targetRect.bottom - targetRect.top,\n\t\t\t\t\t\t\thWnd, GetMenu(hWnd), pThis->pContext->getMainWindow().getHInstance(), NULL);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tpThis->hCurEditPopup = \n\t\t\t\t\t\tCreateWindow(WC_EDIT, TEXT(""), ES_AUTOHSCROLL | WS_CHILD | WS_VISIBLE, \n\t\t\t\t\t\t\ttargetRect.left, targetRect.top, targetRect.right - targetRect.left, targetRect.bottom - targetRect.top,\n\t\t\t\t\t\t\thWnd, GetMenu(hWnd), pThis->pContext->getMainWindow().getHInstance(), NULL);\n\t\t\t\t\tSendMessage(pThis->hCurEditPopup, EM_SETLIMITTEXT, sizeof(((AssetsFileDependency*)nullptr)->assetPath) / sizeof(char) - 1, 0);\n\t\t\t\t}\n\t\t\t\tSetWindowSubclass(pThis->hCurEditPopup, EditPopupProc, 0, reinterpret_cast<DWORD_PTR>(pThis));\n\t\t\t\tSendMessage(pThis->hCurEditPopup, WM_SETFONT, (WPARAM)(HFONT)SendMessage(hWnd, WM_GETFONT, 0, 0), FALSE);\n\t\t\t\tSetFocus(pThis->hCurEditPopup);\n\t\t\t\tpThis->onOpenEditPopup();\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase WM_NCDESTROY:\n\t\tRemoveWindowSubclass(hWnd, AssetDependListViewProc, uIdSubclass);\n\t\tbreak;\n\t}\n    return DefSubclassProc(hWnd, message, wParam, lParam);\n}\nLRESULT CALLBACK AssetDependDialog::EditPopupProc(HWND hWnd, UINT message, \n\tWPARAM wParam, LPARAM lParam, \n\tuintptr_t uIdSubclass, DWORD_PTR dwRefData)\n{\n\tAssetDependDialog *pThis = (AssetDependDialog*)dwRefData;\n\tswitch (message)\n\t{\n\tcase WM_KILLFOCUS:\n\t\t//if (wParam == WA_INACTIVE)\n\t\t{\n\t\t\tif (pThis->hCurEditPopup != NULL)\n\t\t\t\tpThis->doCloseEditPopup();\n\t\t}\n\t\tbreak;\n\tcase WM_KEYDOWN:\n\t\tif (LOWORD(wParam) == VK_ESCAPE || (pThis->iEditPopupSubItem != 2 && LOWORD(wParam) == VK_RETURN))\n\t\t{\n\t\t\tif (pThis->hCurEditPopup != NULL)\n\t\t\t\tpThis->doCloseEditPopup();\n\t\t}\n\t\tbreak;\n\tcase WM_NCDESTROY:\n\t\tRemoveWindowSubclass(hWnd, EditPopupProc, uIdSubclass);\n\t\tbreak;\n\t}\n    return DefSubclassProc(hWnd, message, wParam, lParam);\n}\n\nvoid AssetDependDialog::onUpdateDependencies(AssetsFileContextInfo * pContextInfo, size_t from, size_t to)\n{\n\tif (this->hDialog == NULL || this->pCurFileEntry == nullptr || pContextInfo != this->pCurFileEntry->getContextInfoPtr()\n\t\t|| pContextInfo == nullptr || from > UINT32_MAX)\n\t\treturn;\n\tHWND hList = GetDlgItem(hDialog, IDC_DEPENDLIST);\n\tauto refLock = pContextInfo->lockReferencesRead();\n\tconst std::vector<unsigned int> &references = pContextInfo->getReferencesRead(refLock);\n\tconst std::vector<AssetsFileDependency> &dependencies = pContextInfo->getDependenciesRead(refLock);\n\n\tint nListItems = ListView_GetItemCount(hList);\n\t\n\t//Retrieve a list of all dependencies in range that are already in the list.\n\tint iFirstAffectedItem = -1;\n\tstd::vector<size_t> dependenciesInRange;\n\tfor (int i = 0; i < nListItems; i++)\n\t{\n\t\tLVITEM item;\n\t\titem.mask = LVIF_PARAM;\n\t\titem.lParam = (LPARAM)-1;\n\t\titem.iItem = i;\n\t\titem.iSubItem = 0;\n\t\tListView_GetItem(hList, &item);\n\t\tif ((size_t)item.lParam > to)\n\t\t\tbreak;\n\t\telse if ((size_t)item.lParam >= from)\n\t\t{\n\t\t\tdependenciesInRange.push_back(item.lParam);\n\t\t\tif (iFirstAffectedItem == -1)\n\t\t\t\tiFirstAffectedItem = i;\n\t\t}\n\t}\n\tbool requiresListRebuild = false;\n\t{\n\t\t//Check whether the dependencies that would now be put into the list already existed before.\n\t\t//If not, a rebuild of the list will be required.\n\t\tsize_t iChangedItem = 0;\n\t\tfor (size_t i = from; i <= to && i < dependencies.size(); i++)\n\t\t{\n\t\t\tconst AssetsFileDependency &dependency = dependencies[i];\n\t\t\tif (dependency.type != 0)\n\t\t\t\tcontinue;\n\t\t\tif (iChangedItem >= dependenciesInRange.size()\n\t\t\t\t|| dependenciesInRange[iChangedItem++] != i)\n\t\t\t{\n\t\t\t\trequiresListRebuild = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (iChangedItem != dependenciesInRange.size())\n\t\t\trequiresListRebuild = true;\n\t}\n\tif (this->hCurEditPopup != NULL)\n\t{\n\t\t//Retrieve the dependency index for the edit popup.\n\t\tLVITEM item;\n\t\titem.mask = LVIF_PARAM;\n\t\titem.lParam = (LPARAM)-1;\n\t\titem.iItem = iEditPopupItem;\n\t\titem.iSubItem = 0;\n\t\tListView_GetItem(hList, &item);\n\n\t\tsize_t dependencyIdx = item.lParam;\n\t\tif (dependencyIdx >= from && (requiresListRebuild || dependencyIdx <= to))\n\t\t{\n\t\t\t//Reset the popup since the contents to be edited may have changed (if !requiresListRebuild)\n\t\t\t// or the list indices have shuffled (if requiresListRebuild).\n\t\t\tdoCloseEditPopup(false);\n\t\t}\n\t}\n\tif (requiresListRebuild)\n\t{\n\t\t//Regenerate the whole list for simplicity.\n\t\tonUpdateCurrentFile();\n\t}\n\telse\n\t{\n\t\t//Update the asset paths and selected targets only, since no dependencies were added/removed.\n\t\t//This is essential so the UI keeps being usable while dependencies are loading.\n\t\tint iItem = iFirstAffectedItem;\n\t\tfor (DWORD i = static_cast<DWORD>(from); i <= to && i < dependencies.size(); i++)\n\t\t{\n\t\t\tconst AssetsFileDependency &dependency = dependencies[i];\n\t\t\tif (dependency.type != 0)\n\t\t\t\tcontinue;\n\n\t\t\tlist_updateAssetPath(hList, iItem, &dependency);\n\t\t\t\n\t\t\tlist_updateTargetAsset(hList, iItem, references[i]);\n\n\t\t\tassert(iItem < INT_MAX);\n\t\t\tiItem++;\n\t\t}\t\t\t\n\t}\n}\n\nvoid AssetDependDialog::onUpdateContainers(AssetsFileContextInfo *pFile) {}\nvoid AssetDependDialog::onChangeAsset(AssetsFileContextInfo *pFile, pathid_t pathID, bool wasRemoved) {}'