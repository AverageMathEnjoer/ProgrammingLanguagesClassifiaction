b'using System;\nusing System.Diagnostics;\nusing System.Text;\n\nusing u8 = System.Byte;\nusing u32 = System.UInt32;\n\nnamespace CS_SQLite3\n{\n  public partial class CSSQLite\n  {\n    /*\n    ** 2001 September 15\n    **\n    ** The author disclaims copyright to this source code.  In place of\n    ** a legal notice, here is a blessing:\n    **\n    **    May you do good and not evil.\n    **    May you find forgiveness for yourself and forgive others.\n    **    May you share freely, never taking more than you give.\n    **\n    *************************************************************************\n    ** This file contains C code routines that are called by the parser\n    ** in order to generate code for DELETE FROM statements.\n    **\n    ** $Id: delete.c,v 1.207 2009/08/08 18:01:08 drh Exp $\n    **\n    *************************************************************************\n    **  Included in SQLite3 port to C#-SQLite;  2008 Noah B Hart\n    **  C#-SQLite is an independent reimplementation of the SQLite software library\n    **\n    **  $Header$\n    *************************************************************************\n    */\n    //#include "sqliteInt.h"\n\n    /*\n    ** Look up every table that is named in pSrc.  If any table is not found,\n    ** add an error message to pParse.zErrMsg and return NULL.  If all tables\n    ** are found, return a pointer to the last table.\n    */\n    static Table sqlite3SrcListLookup( Parse pParse, SrcList pSrc )\n    {\n      SrcList_item pItem = pSrc.a[0];\n      Table pTab;\n      Debug.Assert( pItem != null && pSrc.nSrc == 1 );\n      pTab = sqlite3LocateTable( pParse, 0, pItem.zName, pItem.zDatabase );\n      sqlite3DeleteTable( ref pItem.pTab );\n      pItem.pTab = pTab;\n      if ( pTab != null )\n      {\n        pTab.nRef++;\n      }\n      if ( sqlite3IndexedByLookup( pParse, pItem ) != 0 )\n      {\n        pTab = null;\n      }\n      return pTab;\n    }\n\n    /*\n    ** Check to make sure the given table is writable.  If it is not\n    ** writable, generate an error message and return 1.  If it is\n    ** writable return 0;\n    */\n    static bool sqlite3IsReadOnly( Parse pParse, Table pTab, int viewOk )\n    {\n      /* A table is not writable under the following circumstances:\n      **\n      **   1) It is a virtual table and no implementation of the xUpdate method\n      **      has been provided, or\n      **   2) It is a system table (i.e. sqlite_master), this call is not\n      **      part of a nested parse and writable_schema pragma has not\n      **      been specified.\n      **\n      ** In either case leave an error message in pParse and return non-zero.\n      */\n      if (\n         ( IsVirtual( pTab )\n          && sqlite3GetVTable( pParse.db, pTab ).pMod.pModule.xUpdate == null )\n        || ( ( pTab.tabFlags & TF_Readonly ) != 0\n      && ( pParse.db.flags & SQLITE_WriteSchema ) == 0\n      && pParse.nested == 0 )\n      )\n      {\n        sqlite3ErrorMsg( pParse, "table %s may not be modified", pTab.zName );\n        return true;\n      }\n\n#if !SQLITE_OMIT_VIEW\n      if ( viewOk == 0 && pTab.pSelect != null )\n      {\n        sqlite3ErrorMsg( pParse, "cannot modify %s because it is a view", pTab.zName );\n        return true;\n      }\n#endif\n      return false;\n    }\n\n\n#if !SQLITE_OMIT_VIEW && !SQLITE_OMIT_TRIGGER\n    /*\n** Evaluate a view and store its result in an ephemeral table.  The\n** pWhere argument is an optional WHERE clause that restricts the\n** set of rows in the view that are to be added to the ephemeral table.\n*/\n    static void sqlite3MaterializeView(\n    Parse pParse,      /* Parsing context */\n    Table pView,       /* View definition */\n    Expr pWhere,       /* Optional WHERE clause to be added */\n    int iCur           /* VdbeCursor number for ephemerial table */\n    )\n    {\n      SelectDest dest = new SelectDest();\n      Select pDup;\n      sqlite3 db = pParse.db;\n\n      pDup = sqlite3SelectDup( db, pView.pSelect, 0 );\n      if ( pWhere != null )\n      {\n        SrcList pFrom;\n\n        pWhere = sqlite3ExprDup( db, pWhere, 0 );\n        pFrom = sqlite3SrcListAppend( db, null, null, null );\n        //if ( pFrom != null )\n        //{\n          Debug.Assert( pFrom.nSrc == 1 );\n          pFrom.a[0].zAlias = pView.zName;// sqlite3DbStrDup( db, pView.zName );\n          pFrom.a[0].pSelect = pDup;\n          Debug.Assert( pFrom.a[0].pOn == null );\n          Debug.Assert( pFrom.a[0].pUsing == null );\n        //}\n        //else\n        //{\n        //  sqlite3SelectDelete( db, ref pDup );\n        //}\n        pDup = sqlite3SelectNew( pParse, null, pFrom, pWhere, null, null, null, 0, null, null );\n      }\n      sqlite3SelectDestInit( dest, SRT_EphemTab, iCur );\n      sqlite3Select( pParse, pDup, ref dest );\n      sqlite3SelectDelete( db, ref pDup );\n    }\n#endif //* !SQLITE_OMIT_VIEW) && !SQLITE_OMIT_TRIGGER) */\n\n#if (SQLITE_ENABLE_UPDATE_DELETE_LIMIT) && !(SQLITE_OMIT_SUBQUERY)\n/*\n** Generate an expression tree to implement the WHERE, ORDER BY,\n** and LIMIT/OFFSET portion of DELETE and UPDATE statements.\n**\n**     DELETE FROM table_wxyz WHERE a<5 ORDER BY a LIMIT 1;\n**                            \\__________________________/\n**                               pLimitWhere (pInClause)\n*/\nExpr sqlite3LimitWhere(\nParse pParse,               /* The parser context */\nSrcList pSrc,               /* the FROM clause -- which tables to scan */\nExpr pWhere,                /* The WHERE clause.  May be null */\nExprList pOrderBy,          /* The ORDER BY clause.  May be null */\nExpr pLimit,                /* The LIMIT clause.  May be null */\nExpr pOffset,               /* The OFFSET clause.  May be null */\nchar zStmtType              /* Either DELETE or UPDATE.  For error messages. */\n){\nExpr pWhereRowid = null;    /* WHERE rowid .. */\nExpr pInClause = null;      /* WHERE rowid IN ( select ) */\nExpr pSelectRowid = null;   /* SELECT rowid ... */\nExprList pEList = null;     /* Expression list contaning only pSelectRowid */\nSrcList pSelectSrc = null;  /* SELECT rowid FROM x ... (dup of pSrc) */\nSelect pSelect = null;      /* Complete SELECT tree */\n\n/* Check that there isn\'t an ORDER BY without a LIMIT clause.\n*/\nif( pOrderBy!=null && (pLimit == null) ) {\nsqlite3ErrorMsg(pParse, "ORDER BY without LIMIT on %s", zStmtType);\npParse.parseError = 1;\ngoto limit_where_cleanup_2;\n}\n\n/* We only need to generate a select expression if there\n** is a limit/offset term to enforce.\n*/\nif ( pLimit == null )\n{\n/* if pLimit is null, pOffset will always be null as well. */\nDebug.Assert( pOffset == null );\nreturn pWhere;\n}\n\n/* Generate a select expression tree to enforce the limit/offset\n** term for the DELETE or UPDATE statement.  For example:\n**   DELETE FROM table_a WHERE col1=1 ORDER BY col2 LIMIT 1 OFFSET 1\n** becomes:\n**   DELETE FROM table_a WHERE rowid IN (\n**     SELECT rowid FROM table_a WHERE col1=1 ORDER BY col2 LIMIT 1 OFFSET 1\n**   );\n*/\n\npSelectRowid = sqlite3PExpr( pParse, TK_ROW, null, null, null );\nif( pSelectRowid == null ) goto limit_where_cleanup_2;\npEList = sqlite3ExprListAppend( pParse, null, pSelectRowid);\nif( pEList == null ) goto limit_where_cleanup_2;\n\n/* duplicate the FROM clause as it is needed by both the DELETE/UPDATE tree\n** and the SELECT subtree. */\npSelectSrc = sqlite3SrcListDup(pParse.db, pSrc,0);\nif( pSelectSrc == null ) {\nsqlite3ExprListDelete(pParse.db, pEList);\ngoto limit_where_cleanup_2;\n}\n\n/* generate the SELECT expression tree. */\npSelect = sqlite3SelectNew( pParse, pEList, pSelectSrc, pWhere, null, null,\npOrderBy, 0, pLimit, pOffset );\nif( pSelect == null ) return null;\n\n/* now generate the new WHERE rowid IN clause for the DELETE/UDPATE */\npWhereRowid = sqlite3PExpr( pParse, TK_ROW, null, null, null );\nif( pWhereRowid == null ) goto limit_where_cleanup_1;\npInClause = sqlite3PExpr( pParse, TK_IN, pWhereRowid, null, null );\nif( pInClause == null ) goto limit_where_cleanup_1;\n\npInClause->x.pSelect = pSelect;\npInClause->flags |= EP_xIsSelect;\nsqlite3ExprSetHeight(pParse, pInClause);\nreturn pInClause;\n\n/* something went wrong. clean up anything allocated. */\nlimit_where_cleanup_1:\nsqlite3SelectDelete(pParse.db, pSelect);\nreturn null;\n\nlimit_where_cleanup_2:\nsqlite3ExprDelete(pParse.db, ref pWhere);\nsqlite3ExprListDelete(pParse.db, pOrderBy);\nsqlite3ExprDelete(pParse.db, ref pLimit);\nsqlite3ExprDelete(pParse.db, ref pOffset);\nreturn null;\n}\n#endif //* defined(SQLITE_ENABLE_UPDATE_DELETE_LIMIT) && !defined(SQLITE_OMIT_SUBQUERY) */\n\n    /*\n** Generate code for a DELETE FROM statement.\n**\n**     DELETE FROM table_wxyz WHERE a<5 AND b NOT NULL;\n**                 \\________/       \\________________/\n**                  pTabList              pWhere\n*/\n    static void sqlite3DeleteFrom(\n    Parse pParse,          /* The parser context */\n    SrcList pTabList,      /* The table from which we should delete things */\n    Expr pWhere            /* The WHERE clause.  May be null */\n    )\n    {\n      Vdbe v;                /* The virtual database engine */\n      Table pTab;            /* The table from which records will be deleted */\n      string zDb;            /* Name of database holding pTab */\n      int end, addr = 0;     /* A couple addresses of generated code */\n      int i;                 /* Loop counter */\n      WhereInfo pWInfo;      /* Information about the WHERE clause */\n      Index pIdx;            /* For looping over indices of the table */\n      int iCur;              /* VDBE VdbeCursor number for pTab */\n      sqlite3 db;            /* Main database structure */\n      AuthContext sContext;  /* Authorization context */\n      int oldIdx = -1;       /* VdbeCursor for the OLD table of AFTER triggers */\n      NameContext sNC;       /* Name context to resolve expressions in */\n      int iDb;               /* Database number */\n      int memCnt = -1;        /* Memory cell used for change counting */\n      int rcauth;            /* Value returned by authorization callback */\n\n#if !SQLITE_OMIT_TRIGGER\n      bool isView;                 /* True if attempting to delete from a view */\n      Trigger pTrigger;            /* List of table triggers, if required */\n#endif\n      int iBeginAfterTrigger = 0;      /* Address of after trigger program */\n      int iEndAfterTrigger = 0;        /* Exit of after trigger program */\n      int iBeginBeforeTrigger = 0;     /* Address of before trigger program */\n      int iEndBeforeTrigger = 0;       /* Exit of before trigger program */\n      u32 old_col_mask = 0;        /* Mask of OLD.* columns in use */\n\n      sContext = new AuthContext();//memset(&sContext, 0, sizeof(sContext));\n\n      db = pParse.db;\n      if ( pParse.nErr != 0 /*|| db.mallocFailed != 0 */ )\n      {\n        goto delete_from_cleanup;\n      }\n      Debug.Assert( pTabList.nSrc == 1 );\n\n      /* Locate the table which we want to delete.  This table has to be\n      ** put in an SrcList structure because some of the subroutines we\n      ** will be calling are designed to work with multiple tables and expect\n      ** an SrcList* parameter instead of just a Table* parameter.\n      */\n      pTab = sqlite3SrcListLookup( pParse, pTabList );\n      if ( pTab == null ) goto delete_from_cleanup;\n\n      /* Figure out if we have any triggers and if the table being\n      ** deleted from is a view\n      */\n#if !SQLITE_OMIT_TRIGGER\n      int iDummy = 0;\n      pTrigger = sqlite3TriggersExist( pParse, pTab, TK_DELETE, null, ref iDummy );\n      isView = pTab.pSelect != null;\n#else\nconst Trigger pTrigger = null;\nisView = false;\n#endif\n#if SQLITE_OMIT_VIEW\n//# undef isView\nisView = false;\n#endif\n\n      /* If pTab is really a view, make sure it has been initialized.\n*/\n      if ( sqlite3ViewGetColumnNames( pParse, pTab ) != 0 )\n      {\n        goto delete_from_cleanup;\n      }\n\n      if ( sqlite3IsReadOnly( pParse, pTab, ( pTrigger != null ? 1 : 0 ) ) )\n      {\n        goto delete_from_cleanup;\n      }\n      iDb = sqlite3SchemaToIndex( db, pTab.pSchema );\n      Debug.Assert( iDb < db.nDb );\n      zDb = db.aDb[iDb].zName;\n#if !SQLITE_OMIT_AUTHORIZATION\nrcauth = sqlite3AuthCheck(pParse, SQLITE_DELETE, pTab->zName, 0, zDb);\n#else\n      rcauth = SQLITE_OK;\n#endif\n      Debug.Assert( rcauth == SQLITE_OK || rcauth == SQLITE_DENY || rcauth == SQLITE_IGNORE );\n      if ( rcauth == SQLITE_DENY )\n      {\n        goto delete_from_cleanup;\n      }\n      Debug.Assert( !isView || pTrigger != null );\n\n      /* Allocate a cursor used to store the old.* data for a trigger.\n      */\n      if ( pTrigger != null )\n      {\n        oldIdx = pParse.nTab++;\n      }\n\n      /* Assign  cursor number to the table and all its indices.\n      */\n      Debug.Assert( pTabList.nSrc == 1 );\n      iCur = pTabList.a[0].iCursor = pParse.nTab++;\n      for ( pIdx = pTab.pIndex ; pIdx != null ; pIdx = pIdx.pNext )\n      {\n        pParse.nTab++;\n      }\n\n#if !SQLITE_OMIT_AUTHORIZATION\n/* Start the view context\n*/\nif( isView ){\nsqlite3AuthContextPush(pParse, sContext, pTab.zName);\n}\n#endif\n      /* Begin generating code.\n*/\n      v = sqlite3GetVdbe( pParse );\n      if ( v == null )\n      {\n        goto delete_from_cleanup;\n      }\n      if ( pParse.nested == 0 ) sqlite3VdbeCountChanges( v );\n      sqlite3BeginWriteOperation( pParse, pTrigger != null ? 1 : 0, iDb );\n\n#if !SQLITE_OMIT_TRIGGER\n      if ( pTrigger != null )\n      {\n        int orconf = ( ( pParse.trigStack != null ) ? pParse.trigStack.orconf : OE_Default );\n        int iGoto = sqlite3VdbeAddOp0( v, OP_Goto );\n        addr = sqlite3VdbeMakeLabel( v );\n\n        iBeginBeforeTrigger = sqlite3VdbeCurrentAddr( v );\n        u32 Ref_0 = 0;\n        sqlite3CodeRowTrigger( pParse, pTrigger, TK_DELETE, null,\n        TRIGGER_BEFORE, pTab, -1, oldIdx, orconf, addr, ref old_col_mask, ref Ref_0 );\n        iEndBeforeTrigger = sqlite3VdbeAddOp0( v, OP_Goto );\n\n        iBeginAfterTrigger = sqlite3VdbeCurrentAddr( v );\n        Ref_0 = 0;\n        sqlite3CodeRowTrigger( pParse, pTrigger, TK_DELETE, null,\n        TRIGGER_AFTER, pTab, -1, oldIdx, orconf, addr, ref old_col_mask, ref Ref_0 );\n        iEndAfterTrigger = sqlite3VdbeAddOp0( v, OP_Goto );\n\n        sqlite3VdbeJumpHere( v, iGoto );\n      }\n#endif\n\n      /* If we are trying to delete from a view, realize that view into\n** a ephemeral table.\n*/\n#if !(SQLITE_OMIT_VIEW) && !(SQLITE_OMIT_TRIGGER)\n      if ( isView )\n      {\n        sqlite3MaterializeView( pParse, pTab, pWhere, iCur );\n      }\n\n      /* Resolve the column names in the WHERE clause.\n      */\n      sNC = new NameContext();// memset( &sNC, 0, sizeof( sNC ) );\n      sNC.pParse = pParse;\n      sNC.pSrcList = pTabList;\n      if ( sqlite3ResolveExprNames( sNC, ref pWhere ) != 0 )\n      {\n        goto delete_from_cleanup;\n      }\n#endif\n\n      /* Initialize the counter of the number of rows deleted, if\n** we are counting rows.\n*/\n      if ( ( db.flags & SQLITE_CountRows ) != 0 )\n      {\n        memCnt = ++pParse.nMem;\n        sqlite3VdbeAddOp2( v, OP_Integer, 0, memCnt );\n      }\n\n#if !SQLITE_OMIT_TRUNCATE_OPTIMIZATION\n      /* Special case: A DELETE without a WHERE clause deletes everything.\n** It is easier just to erase the whole table.  Note, however, that\n** this means that the row change count will be incorrect.\n*/\n      if ( rcauth == SQLITE_OK && pWhere == null && null == pTrigger && !IsVirtual( pTab ) )\n      {\n        Debug.Assert( !isView );\n        sqlite3VdbeAddOp4( v, OP_Clear, pTab.tnum, iDb, memCnt,\n              pTab.zName, P4_STATIC );\n        for ( pIdx = pTab.pIndex ; pIdx != null ; pIdx = pIdx.pNext )\n        {\n          Debug.Assert( pIdx.pSchema == pTab.pSchema );\n          sqlite3VdbeAddOp2( v, OP_Clear, pIdx.tnum, iDb );\n        }\n      }\n      else\n#endif //* SQLITE_OMIT_TRUNCATE_OPTIMIZATION */\n      /* The usual case: There is a WHERE clause so we have to scan through\n** the table and pick which records to delete.\n*/\n      {\n        int iRowid = ++pParse.nMem;     /* Used for storing rowid values. */\n        int iRowSet = ++pParse.nMem;    /* Register for rowset of rows to delete */\n        int regRowid;                   /* Actual register containing rowids */\n\n        /* Collect rowids of every row to be deleted.\n        */\n        sqlite3VdbeAddOp2( v, OP_Null, 0, iRowSet );\n        ExprList elDummy = null;\n        pWInfo = sqlite3WhereBegin( pParse, pTabList, pWhere, ref elDummy, WHERE_DUPLICATES_OK );\n        if ( pWInfo == null ) goto delete_from_cleanup;\n        regRowid = sqlite3ExprCodeGetColumn( pParse, pTab, -1, iCur, iRowid, false );\n        sqlite3VdbeAddOp2( v, OP_RowSetAdd, iRowSet, regRowid );\n        if ( ( db.flags & SQLITE_CountRows ) != 0 )\n        {\n          sqlite3VdbeAddOp2( v, OP_AddImm, memCnt, 1 );\n        }\n\n        sqlite3WhereEnd( pWInfo );\n\n        /* Open the pseudo-table used to store OLD if there are triggers.\n        */\n        if ( pTrigger != null )\n        {\n          sqlite3VdbeAddOp3( v, OP_OpenPseudo, oldIdx, 0, pTab.nCol );\n        }\n\n        /* Delete every item whose key was written to the list during the\n        ** database scan.  We have to delete items after the scan is complete\n        ** because deleting an item can change the scan order.\n        */\n        end = sqlite3VdbeMakeLabel( v );\n\n        if ( !isView )\n        {\n          /* Open cursors for the table we are deleting from and\n          ** all its indices.\n          */\n          sqlite3OpenTableAndIndices( pParse, pTab, iCur, OP_OpenWrite );\n        }\n\n        /* This is the beginning of the delete loop. If a trigger encounters\n        ** an IGNORE constraint, it jumps back to here.\n        */\n        if ( pTrigger != null )\n        {\n          sqlite3VdbeResolveLabel( v, addr );\n        }\n        addr = sqlite3VdbeAddOp3( v, OP_RowSetRead, iRowSet, end, iRowid );\n\n        if ( pTrigger != null )\n        {\n          int iData = ++pParse.nMem;   /* For storing row data of OLD table */\n\n          /* If the record is no longer present in the table, jump to the\n          ** next iteration of the loop through the contents of the fifo.\n          */\n          sqlite3VdbeAddOp3( v, OP_NotExists, iCur, addr, iRowid );\n\n          /* Populate the OLD.* pseudo-table */\n          if ( old_col_mask != 0 )\n          {\n            sqlite3VdbeAddOp2( v, OP_RowData, iCur, iData );\n          }\n          else\n          {\n            sqlite3VdbeAddOp2( v, OP_Null, 0, iData );\n          }\n          sqlite3VdbeAddOp3( v, OP_Insert, oldIdx, iData, iRowid );\n\n          /* Jump back and run the BEFORE triggers */\n          sqlite3VdbeAddOp2( v, OP_Goto, 0, iBeginBeforeTrigger );\n          sqlite3VdbeJumpHere( v, iEndBeforeTrigger );\n        }\n\n        if ( !isView )\n        {\n          /* Delete the row */\n#if !SQLITE_OMIT_VIRTUALTABLE\nif( IsVirtual(pTab) ){\nconst char *pVTab = (const char *)sqlite3GetVTable(db, pTab);\nsqlite3VtabMakeWritable(pParse, pTab);\nsqlite3VdbeAddOp4(v, OP_VUpdate, 0, 1, iRowid, pVTab, P4_VTAB);\n}else\n\n#endif\n          {\n            sqlite3GenerateRowDelete( pParse, pTab, iCur, iRowid, pParse.nested == 0 ? 1 : 0 );\n          }\n        }\n\n        /* If there are row triggers, close all cursors then invoke\n        ** the AFTER triggers\n        */\n        if ( pTrigger != null )\n        {\n          /* Jump back and run the AFTER triggers */\n          sqlite3VdbeAddOp2( v, OP_Goto, 0, iBeginAfterTrigger );\n          sqlite3VdbeJumpHere( v, iEndAfterTrigger );\n        }\n\n        /* End of the delete loop */\n        sqlite3VdbeAddOp2( v, OP_Goto, 0, addr );\n        sqlite3VdbeResolveLabel( v, end );\n\n        /* Close the cursors after the loop if there are no row triggers */\n        if ( !isView && !IsVirtual( pTab ) )\n        {\n          for ( i = 1, pIdx = pTab.pIndex ; pIdx != null ; i++, pIdx = pIdx.pNext )\n          {\n            sqlite3VdbeAddOp2( v, OP_Close, iCur + i, pIdx.tnum );\n          }\n          sqlite3VdbeAddOp1( v, OP_Close, iCur );\n        }\n      }\n\n      /* Update the sqlite_sequence table by storing the content of the\n      ** maximum rowid counter values recorded while inserting into\n      ** autoincrement tables.\n      */\n      if ( pParse.nested == 0 && pParse.trigStack == null )\n      {\n        sqlite3AutoincrementEnd( pParse );\n      }\n\n      /*\n      ** Return the number of rows that were deleted. If this routine is\n      ** generating code because of a call to sqlite3NestedParse(), do not\n      ** invoke the callback function.\n      */\n      if ( ( db.flags & SQLITE_CountRows ) != 0 && pParse.nested == 0 && pParse.trigStack == null )\n      {\n        sqlite3VdbeAddOp2( v, OP_ResultRow, memCnt, 1 );\n        sqlite3VdbeSetNumCols( v, 1 );\n        sqlite3VdbeSetColName( v, 0, COLNAME_NAME, "rows deleted", SQLITE_STATIC );\n      }\n\ndelete_from_cleanup:\n#if !SQLITE_OMIT_AUTHORIZATION\nsqlite3AuthContextPop(sContext);\n#endif\n      sqlite3SrcListDelete( db, ref pTabList );\n      sqlite3ExprDelete( db, ref pWhere );\n      return;\n    }\n\n    /*\n    ** This routine generates VDBE code that causes a single row of a\n    ** single table to be deleted.\n    **\n    ** The VDBE must be in a particular state when this routine is called.\n    ** These are the requirements:\n    **\n    **   1.  A read/write cursor pointing to pTab, the table containing the row\n    **       to be deleted, must be opened as cursor number "base".\n    **\n    **   2.  Read/write cursors for all indices of pTab must be open as\n    **       cursor number base+i for the i-th index.\n    **\n    **   3.  The record number of the row to be deleted must be stored in\n    **       memory cell iRowid.\n    **\n    ** This routine pops the top of the stack to remove the record number\n    ** and then generates code to remove both the table record and all index\n    ** entries that point to that record.\n    */\n    static void sqlite3GenerateRowDelete(\n    Parse pParse,     /* Parsing context */\n    Table pTab,       /* Table containing the row to be deleted */\n    int iCur,          /* VdbeCursor number for the table */\n    int iRowid,        /* Memory cell that contains the rowid to delete */\n    int count          /* Increment the row change counter */\n    )\n    {\n      int addr;\n      Vdbe v;\n\n      v = pParse.pVdbe;\n      addr = sqlite3VdbeAddOp3( v, OP_NotExists, iCur, 0, iRowid );\n      sqlite3GenerateRowIndexDelete( pParse, pTab, iCur, 0 );\n      sqlite3VdbeAddOp2( v, OP_Delete, iCur, ( count > 0 ? (int)OPFLAG_NCHANGE : 0 ) );\n      if ( count > 0 )\n      {\n        sqlite3VdbeChangeP4( v, -1, pTab.zName, P4_STATIC );\n      }\n      sqlite3VdbeJumpHere( v, addr );\n    }\n\n    /*\n    ** This routine generates VDBE code that causes the deletion of all\n    ** index entries associated with a single row of a single table.\n    **\n    ** The VDBE must be in a particular state when this routine is called.\n    ** These are the requirements:\n    **\n    **   1.  A read/write cursor pointing to pTab, the table containing the row\n    **       to be deleted, must be opened as cursor number "iCur".\n    **\n    **   2.  Read/write cursors for all indices of pTab must be open as\n    **       cursor number iCur+i for the i-th index.\n    **\n    **   3.  The "iCur" cursor must be pointing to the row that is to be\n    **       deleted.\n    */\n    static void sqlite3GenerateRowIndexDelete(\n    Parse pParse,     /* Parsing and code generating context */\n    Table pTab,       /* Table containing the row to be deleted */\n    int iCur,         /* VdbeCursor number for the table */\n    int nothing       /* Only delete if aRegIdx!=0 && aRegIdx[i]>0 */\n    )\n    {\n      int[] aRegIdx = null;\n      sqlite3GenerateRowIndexDelete( pParse, pTab, iCur, aRegIdx );\n    }\n    static void sqlite3GenerateRowIndexDelete(\n    Parse pParse,     /* Parsing and code generating context */\n    Table pTab,       /* Table containing the row to be deleted */\n    int iCur,          /* VdbeCursor number for the table */\n    int[] aRegIdx       /* Only delete if aRegIdx!=0 && aRegIdx[i]>0 */\n    )\n    {\n      int i;\n      Index pIdx;\n      int r1;\n\n      for ( i = 1, pIdx = pTab.pIndex ; pIdx != null ; i++, pIdx = pIdx.pNext )\n      {\n        if ( aRegIdx != null && aRegIdx[i - 1] == 0 ) continue;\n        r1 = sqlite3GenerateIndexKey( pParse, pIdx, iCur, 0, false );\n        sqlite3VdbeAddOp3( pParse.pVdbe, OP_IdxDelete, iCur + i, r1, pIdx.nColumn + 1 );\n      }\n    }\n\n    /*\n    ** Generate code that will assemble an index key and put it in register\n    ** regOut.  The key with be for index pIdx which is an index on pTab.\n    ** iCur is the index of a cursor open on the pTab table and pointing to\n    ** the entry that needs indexing.\n    **\n    ** Return a register number which is the first in a block of\n    ** registers that holds the elements of the index key.  The\n    ** block of registers has already been deallocated by the time\n    ** this routine returns.\n    */\n    static int sqlite3GenerateIndexKey(\n    Parse pParse,     /* Parsing context */\n    Index pIdx,       /* The index for which to generate a key */\n    int iCur,         /* VdbeCursor number for the pIdx.pTable table */\n    int regOut,       /* Write the new index key to this register */\n    bool doMakeRec    /* Run the OP_MakeRecord instruction if true */\n    )\n    {\n      Vdbe v = pParse.pVdbe;\n      int j;\n      Table pTab = pIdx.pTable;\n      int regBase;\n      int nCol;\n\n      nCol = pIdx.nColumn;\n      regBase = sqlite3GetTempRange( pParse, nCol + 1 );\n      sqlite3VdbeAddOp2( v, OP_Rowid, iCur, regBase + nCol );\n      for ( j = 0 ; j < nCol ; j++ )\n      {\n        int idx = pIdx.aiColumn[j];\n        if ( idx == pTab.iPKey )\n        {\n          sqlite3VdbeAddOp2( v, OP_SCopy, regBase + nCol, regBase + j );\n        }\n        else\n        {\n          sqlite3VdbeAddOp3( v, OP_Column, iCur, idx, regBase + j );\n          sqlite3ColumnDefault( v, pTab, idx, -1 );\n        }\n      }\n      if ( doMakeRec )\n      {\n        sqlite3VdbeAddOp3( v, OP_MakeRecord, regBase, nCol + 1, regOut );\n        sqlite3IndexAffinityStr( v, pIdx );\n        sqlite3ExprCacheAffinityChange( pParse, regBase, nCol + 1 );\n      }\n      sqlite3ReleaseTempRange( pParse, regBase, nCol + 1 );\n      return regBase;\n    }\n    /* Make sure "isView" gets undefined in case this file becomes part of\n    ** the amalgamation - so that subsequent files do not see isView as a\n    ** macro. */\n    //#undef isView\n  }\n}\n'