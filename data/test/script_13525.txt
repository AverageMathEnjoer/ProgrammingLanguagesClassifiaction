b'#include "stdafx.h"\n#include "resource.h"\n#include "ProgressDialog.h"\n\n#include "../libStringConverter/convert.h"\n\n#include <vector>\n\n#include <WindowsX.h>\n\nCProgressIndicator::CProgressIndicator(HINSTANCE hInstance)\n\t: hInstance(hInstance)\n{\n\tstarted = false;\n\tdialogHasFocus = false;\n\tdialogIsActive = false;\n\tdontCloseIfLog = false;\n\tlogWasCalled = false;\n\ttotalRange = 0;\n\tcurStepBasePos = 0;\n\tcurStep = 0;\n\tcurStepProgress = 0;\n\thStartEvent = NULL;\n\thEndEvent = NULL;\n}\nCProgressIndicator::~CProgressIndicator()\n{\n\tif (this->hStartEvent != NULL)\n\t\tCloseHandle(this->hStartEvent);\n\tif (this->hEndEvent != NULL)\n\t\tCloseHandle(this->hEndEvent);\n}\nINT_PTR CALLBACK CProgressIndicator::WindowHandler(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)\n{\n\tint wmId, wmEvent;\n\tUNREFERENCED_PARAMETER(lParam);\n\tINT_PTR ret = (INT_PTR)FALSE;\n\tswitch (message)\n\t{\n\tcase WM_DESTROY:\n\t\t{\n\t\t\tCProgressIndicator *pThis = (CProgressIndicator*)GetWindowLongPtr(hDlg, GWLP_USERDATA);\n\t\t\tstd::scoped_lock endLock(pThis->endMutex);\n\t\t\tSetEvent(pThis->hEndEvent);\n\t\t\tSetWindowLongPtr(hDlg, GWLP_USERDATA, 0);\n\t\t\tpThis->selfRef.reset();\n\n\t\t\tPostQuitMessage(0);\n\t\t}\n\t\tbreak;\n\tcase WM_TIMER:\n\t\t{\n\t\t\tCProgressIndicator *pThis = (CProgressIndicator*)GetWindowLongPtr(hDlg, GWLP_USERDATA);\n\t\t\tif (wParam == (WPARAM)pThis)\n\t\t\t{\n\t\t\t\tpThis->showDelayElapsed = true;\n\t\t\t\tKillTimer(hDlg, wParam);\n\t\t\t\tShowWindow(hDlg, SW_SHOW);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase WM_INITDIALOG:\n\t\t{\n\t\t\tSetWindowLongPtr(hDlg, GWLP_USERDATA, lParam);\n\t\t\tCProgressIndicator *pThis = (CProgressIndicator*)lParam;\n\n\t\t\tHWND hWndOptions = GetDlgItem(hDlg, IDC_COMBOOPTIONLIST);\n\t\t\tpThis->hDialog = hDlg;\n\n\t\t\tpThis->dialogHasFocus = (hDlg == GetFocus());\n\n\t\t\tSetEvent(pThis->hStartEvent);\n\n\t\t\tif (pThis->showDelay > 0)\n\t\t\t{\n\t\t\t\tpThis->showDelayElapsed = false;\n\t\t\t\tShowWindow(hDlg, SW_HIDE);\n\t\t\t\tSetTimer(hDlg, (uintptr_t)pThis, pThis->showDelay, NULL);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tpThis->showDelayElapsed = true;\n\t\t\t\tShowWindow(hDlg, SW_SHOW);\n\t\t\t}\n\n\t\t\tHWND hCancelButton = GetDlgItem(hDlg, IDCANCEL);\n\t\t\tHWND hOKButton = GetDlgItem(hDlg, IDOK);\n\t\t\tShowWindow(hCancelButton, SW_SHOW);\n\t\t\tShowWindow(hOKButton, SW_HIDE);\n\n\t\t\tHWND hWndProgress = GetDlgItem(hDlg, IDC_PROG);\n\t\t\tEnableWindow(hWndProgress, TRUE);\n\t\t}\n\t\treturn (INT_PTR)TRUE;\n\tcase WM_COMMAND:\n\t\twmId    = LOWORD(wParam);\n\t\twmEvent = HIWORD(wParam);\n\t\tswitch (wmId)\n\t\t{\n\t\t\tcase IDOK:\n\t\t\t\t{\n\t\t\t\t\tCProgressIndicator *pThis = (CProgressIndicator*)GetWindowLongPtr(hDlg, GWLP_USERDATA);\n\t\t\t\t\tif (pThis->IsCancelled())\n\t\t\t\t\t{\n\t\t\t\t\t\tSendMessage(hDlg, WM_APP+0, 0, 0);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn (INT_PTR)TRUE;\n\t\t\tcase IDCANCEL:\n\t\t\t\t{\n\t\t\t\t\tCProgressIndicator *pThis = (CProgressIndicator*)GetWindowLongPtr(hDlg, GWLP_USERDATA);\n\t\t\t\t\tif (pThis->cancellable)\n\t\t\t\t\t{\n\t\t\t\t\t\tpThis->SetCancellable(false);\n\t\t\t\t\t\tpThis->forceUncancellable = false;\n\t\t\t\t\t\tpThis->SetCancelled(true);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn (INT_PTR)TRUE;\n\t\t}\n\t\tbreak;\n\tcase WM_SETFOCUS:\n\t\t{\n\t\t\tCProgressIndicator *pThis = (CProgressIndicator*)GetWindowLongPtr(hDlg, GWLP_USERDATA);\n\t\t\tpThis->dialogHasFocus = true;\n\t\t}\n\t\tbreak;\n\tcase WM_KILLFOCUS:\n\t\t{\n\t\t\tCProgressIndicator *pThis = (CProgressIndicator*)GetWindowLongPtr(hDlg, GWLP_USERDATA);\n\t\t\tpThis->dialogHasFocus = false;\n\t\t}\n\t\tbreak;\n\tcase WM_ACTIVATE:\n\t\t{\n\t\t\tCProgressIndicator *pThis = (CProgressIndicator*)GetWindowLongPtr(hDlg, GWLP_USERDATA);\n\t\t\tpThis->dialogIsActive = (LOWORD(wParam) != WA_INACTIVE);\n\t\t}\n\t\tbreak;\n\tcase WM_CLOSE:\n\t\t{\n\t\t\tCProgressIndicator *pThis = (CProgressIndicator*)GetWindowLongPtr(hDlg, GWLP_USERDATA);\n\t\t\tif (pThis->cancellable)\n\t\t\t\tpThis->SetCancelled(true);\n\t\t}\n\t\tbreak;\n\tcase WM_APP+0:\n\t\t{\n\t\t\tCProgressIndicator *pThis = (CProgressIndicator*)GetWindowLongPtr(hDlg, GWLP_USERDATA);\n\t\t\tif ((!pThis->showDelayElapsed || pThis->dialogHasFocus || pThis->dialogIsActive) && pThis->hParentWindow != NULL)\n\t\t\t\tSetForegroundWindow(pThis->hParentWindow);\n\t\t}\n\t\tDestroyWindow(hDlg);\n\t\t//EndDialog(hDlg, wParam);\n\t\treturn (INT_PTR)TRUE;\n\tcase WM_APP+1: //Cancelled/Ended but show an OK button first.\n\t\t{\n\t\t\tCProgressIndicator *pThis = (CProgressIndicator*)GetWindowLongPtr(hDlg, GWLP_USERDATA);\n\n\t\t\tHWND hCancelButton = GetDlgItem(hDlg, IDCANCEL);\n\t\t\tHWND hOKButton = GetDlgItem(hDlg, IDOK);\n\t\t\tShowWindow(hCancelButton, SW_HIDE);\n\t\t\tShowWindow(hOKButton, SW_SHOW);\n\n\t\t\tHWND hWndProgress = GetDlgItem(hDlg, IDC_PROG);\n\t\t\tEnableWindow(hWndProgress, FALSE);\n\t\t}\n\t\tbreak;\n\t}\n\treturn (INT_PTR)FALSE;\n}\nbool GetTargetWindowRect(IN HWND hParentWnd, IN HINSTANCE hInstance, IN LPCWSTR lpTemplateName, OUT RECT *pRect)\n{\n\tstruct _DLGTEMPLATEEX_HEADER{\n\t\tuint16_t dlgVer;\n\t\tuint16_t signature;\n\t\tDWORD helpID;\n\t\tDWORD exStyle;\n\t\tDWORD style;\n\t\tuint16_t cDlgItems;\n\t\tshort x;\n\t\tshort y;\n\t\tshort cx;\n\t\tshort cy;\n\t};\n\tTCHAR tempClassName[32];\n\t_stprintf_s(tempClassName, TEXT("UABE_PROGIND_TEMP%u"), GetCurrentThreadId());\n\n\tHRSRC hResource = FindResourceExW(hInstance, RT_DIALOG, lpTemplateName, 0);\n\tif (hResource == NULL)\n\t\treturn false;\n\tHGLOBAL hLoadedResource = LoadResource(hInstance, hResource);\n\tif (hLoadedResource == NULL)\n\t\treturn false;\n\tbool ret = false;\n\tLPVOID pResourceData = LockResource(hLoadedResource);\n\tif (pResourceData != NULL)\n\t{\n\t\tDWORD size = SizeofResource(hInstance, hResource);\n\t\tif (size >= sizeof(_DLGTEMPLATEEX_HEADER))\n\t\t{\n\t\t\t_DLGTEMPLATEEX_HEADER *pTmpl = (_DLGTEMPLATEEX_HEADER*)pResourceData;\n\t\t\t{\n\t\t\t\tWNDCLASSW wc = {};\n\t\t\t\twc.lpfnWndProc = DefWindowProcW;\n\t\t\t\twc.hInstance = hInstance;\n\t\t\t\twc.lpszClassName = tempClassName;\n\t\t\t\tRegisterClass(&wc);\n\t\t\t\tHWND hWnd = CreateWindowExW(WS_EX_NOPARENTNOTIFY, tempClassName, L"", hParentWnd ? WS_CHILD : WS_POPUP, \n\t\t\t\t\thParentWnd ? pTmpl->x : CW_USEDEFAULT, hParentWnd ? pTmpl->y : SW_HIDE, \n\t\t\t\t\tpTmpl->cx, pTmpl->cy, hParentWnd, NULL, hInstance, NULL);\n\t\t\t\tif (hWnd != NULL)\n\t\t\t\t{\n\t\t\t\t\tret = GetWindowRect(hWnd, pRect) != FALSE;\n\t\t\t\t\tDestroyWindow(hWnd);\n\t\t\t\t}\n\t\t\t\tUnregisterClass(tempClassName, hInstance);\n\t\t\t}\n\t\t}\n\t\tUnlockResource(hLoadedResource);\n\t}\n\tFreeResource(hLoadedResource);\n\treturn ret;\n}\nDWORD WINAPI CProgressIndicator::WindowHandlerThread(PVOID param)\n{\n\tCProgressIndicator *pThis = (CProgressIndicator*)param;\n\n\tRECT targetWindowRect = {};\n\tbool doSetTargetRect = GetTargetWindowRect(pThis->hParentWindow, pThis->hInstance, MAKEINTRESOURCE(IDD_PROGRESS), &targetWindowRect);\n\n\tpThis->dialogHasFocus = false;\n\tpThis->dialogIsActive = false;\n\n\tHWND hDialog = CreateDialogParam(pThis->hInstance, MAKEINTRESOURCE(IDD_PROGRESS), NULL, WindowHandler, (LPARAM)pThis);\n\tif (doSetTargetRect)\n\t{\n\t\tSetWindowPos(hDialog, NULL, \n\t\t\ttargetWindowRect.left, targetWindowRect.top, 0, 0, \n\t\t\tSWP_NOOWNERZORDER | SWP_NOSIZE);\n\t}\n\tMSG msg; \n\twhile (GetMessage(&msg, NULL, 0, 0))\n\t{\n\t\tDispatchMessage(&msg);\n\t}\n\treturn 0;\n}\nbool CProgressIndicator::Start(HWND hParentWindow, std::shared_ptr<IProgressIndicator> _selfRef, unsigned int showDelay)\n{\n\tif (!started)\n\t{\n\t\tif (!(this->hStartEvent = CreateEvent(NULL, TRUE, FALSE, NULL)))\n\t\t\treturn false;\n\t\tif (!(this->hEndEvent = CreateEvent(NULL, TRUE, FALSE, NULL)))\n\t\t{\n\t\t\tCloseHandle(this->hStartEvent);\n\t\t\treturn false;\n\t\t}\n\t\tthis->selfRef = std::move(_selfRef);\n\t\tbool status = true;\n\t\tthis->hParentWindow = hParentWindow;\n\t\tthis->showDelay = showDelay;\n\t\tthis->logWasCalled = false;\n\t\tHANDLE hThread = CreateThread(NULL, 0, WindowHandlerThread, this, 0, NULL);\n\t\tif (hThread)\n\t\t{\n\t\t\tif (WaitForSingleObject(this->hStartEvent, INFINITE) != WAIT_OBJECT_0)\n\t\t\t{\n\t\t\t\tTerminateThread(hThread, 0);\n\t\t\t\tSetEvent(this->hEndEvent);\n\t\t\t\tstatus = false;\n\t\t\t}\n\t\t\tCloseHandle(hThread);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tSetEvent(this->hEndEvent);\n\t\t\tstatus = false;\n\t\t}\n\t\tCloseHandle(this->hStartEvent);\n\t\tthis->hStartEvent = NULL;\n\t\tif (status)\n\t\t{\n\t\t\tif (this->stepRanges.size() == 0)\n\t\t\t\tthis->stepRanges.push_back(0);\n\t\t\tUpdateRange();\n\t\t\t\n\t\t\tcancelled = false;\n\t\t\tcancellable = true;\n\t\t\tforceUncancellable = false;\n\n\t\t\tstarted = true;\n\t\t}\n\t\treturn status;\n\t}\n\treturn true;\n}\nvoid CProgressIndicator::End()\n{\n\tif (started)\n\t{\n\t\tif (!logWasCalled || !dontCloseIfLog)\n\t\t{\n\t\t\tstarted = false;\n\n\t\t\tHANDLE hEndEvent = this->hEndEvent;\n\t\t\tSendMessage(this->hDialog, WM_APP+0, 0, 0);\n\t\t\tWaitForSingleObject(hEndEvent, 100);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcancelled = true;\n\t\t\tSendMessage(this->hDialog, WM_APP+1, 0, 0);\n\t\t}\n\t}\n}\nvoid CProgressIndicator::Free()\n{\n\tstd::unique_lock endLock(this->endMutex, std::defer_lock);\n\tif (this->hEndEvent)\n\t\tendLock.lock();\n\tif (!dontCloseIfLog || !logWasCalled || !started)\n\t{\n\t\tif (endLock.owns_lock())\n\t\t\tendLock.unlock();\n\t\tEnd();\n\t}\n}\nvoid CProgressIndicator::UpdateRange()\n{\n\tHWND hWndProgress = GetDlgItem(this->hDialog, IDC_PROG);\n\tif (totalRange == 0)\n\t{\n\t\tSetWindowLongPtr(hWndProgress, GWL_STYLE, \n\t\t\t(GetWindowLongPtr(hWndProgress, GWL_STYLE) & (~(PBS_SMOOTH | PBS_SMOOTHREVERSE))) | PBS_MARQUEE);\n\t\tSendMessage(hWndProgress, PBM_SETMARQUEE, (WPARAM)1, 0);\n\t}\n\telse\n\t{\n\t\t//Don\'t set the style if it\'s not necessary since setting the style resets the progress animation back to 0.\n\t\tLONG_PTR oldStyle = GetWindowLongPtr(hWndProgress, GWL_STYLE);\n\t\tif (oldStyle & PBS_MARQUEE || !(oldStyle & (PBS_SMOOTH | PBS_SMOOTHREVERSE)))\n\t\t{\n\t\t\tSetWindowLongPtr(hWndProgress, GWL_STYLE, (oldStyle & (~PBS_MARQUEE)) | PBS_SMOOTH | PBS_SMOOTHREVERSE);\n\t\t}\n\n\t\tSendMessage(hWndProgress, PBM_SETRANGE32, (WPARAM)0, (LPARAM)totalRange);\n\t\t\n\t\tUpdateProgress();\n\t}\n}\nvoid CProgressIndicator::UpdateProgress()\n{\n\tif (totalRange > 0)\n\t{\n\t\tHWND hWndProgress = GetDlgItem(this->hDialog, IDC_PROG);\n\t\tSendMessage(hWndProgress, PBM_SETPOS, (WPARAM)(curStepBasePos + curStepProgress), 0);\n\t}\n}\nvoid CProgressIndicator::SetDontCloseIfLog(bool dontclose)\n{\n\tthis->dontCloseIfLog = dontclose;\n}\nsize_t CProgressIndicator::AddStep(unsigned int range)\n{\n\tif (started)\n\t{\n\t\tsize_t ret = stepRanges.size();\n\t\tstepRanges.push_back(range);\n\t\ttotalRange += range;\n\t\t\n\t\tUpdateRange();\n\t\treturn ret;\n\t}\n\treturn 0;\n}\nbool CProgressIndicator::SetStepRange(size_t idx, unsigned int range)\n{\n\tif (started)\n\t{\n\t\tif (stepRanges.size() > idx)\n\t\t{\n\t\t\tunsigned int offset = range - stepRanges[idx];\n\t\t\ttotalRange += offset;\n\t\t\tstepRanges[idx] = range;\n\n\t\t\tUpdateRange();\n\t\t\tif (curStep > idx)\n\t\t\t{\n\t\t\t\tcurStepBasePos += offset;\n\t\t\t\tUpdateProgress();\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\nbool CProgressIndicator::SetStepStatus(unsigned int progress)\n{\n\tif (started)\n\t{\n\t\tif (progress > stepRanges[curStep])\n\t\t\tprogress = stepRanges[curStep];\n\t\tcurStepProgress = progress;\n\t\tUpdateProgress();\n\t\treturn true;\n\t}\n\treturn false;\n}\nbool CProgressIndicator::JumpToStep(size_t idx, unsigned int progress)\n{\n\tif (started)\n\t{\n\t\tif (idx >= stepRanges.size())\n\t\t\treturn false;\n\t\tif (idx >= curStep)\n\t\t{\n\t\t\tfor (size_t i = curStep; i < idx; i++)\n\t\t\t\tcurStepBasePos += stepRanges[i];\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfor (size_t i = idx; i < curStep; i++)\n\t\t\t\tcurStepBasePos -= stepRanges[i];\n\t\t}\n\t\tcurStep = idx;\n\t\tSetStepStatus(progress);\n\t\treturn true;\n\t}\n\treturn false;\n}\nsize_t CProgressIndicator::GoToNextStep()\n{\n\tif (JumpToStep(curStep + 1))\n\t\treturn curStep;\n\telse\n\t\treturn (size_t)-1;\n}\n\nbool CProgressIndicator::SetTitle(const std::string &title)\n{\n\tif (started)\n\t{\n\t\tsize_t strLen = 0;\n\t\twchar_t *wTitle = _MultiByteToWide(title.c_str(), strLen);\n\t\tif (wTitle != nullptr)\n\t\t{\n\t\t\tSetWindowTextW(this->hDialog, wTitle);\n\t\t\t_FreeWCHAR(wTitle);\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\nbool CProgressIndicator::SetTitle(const std::wstring &title)\n{\n\tif (started)\n\t{\n\t\tSetWindowTextW(this->hDialog, title.c_str());\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nbool CProgressIndicator::SetDescription(const std::string &desc)\n{\n\tif (started)\n\t{\n\t\tsize_t strLen = 0;\n\t\twchar_t *wDesc = _MultiByteToWide(desc.c_str(), strLen);\n\t\tif (wDesc != nullptr)\n\t\t{\n\t\t\tHWND hWndDesc = GetDlgItem(this->hDialog, IDC_SDESC);\n\t\t\tStatic_SetText(hWndDesc, wDesc);\n\t\t\t_FreeWCHAR(wDesc);\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\nbool CProgressIndicator::SetDescription(const std::wstring &desc)\n{\n\tif (started)\n\t{\n\t\tHWND hWndDesc = GetDlgItem(this->hDialog, IDC_SDESC);\n\t\tStatic_SetText(hWndDesc, desc.c_str());\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nbool CProgressIndicator::AddLogText(const std::string &text)\n{\n\tif (started)\n\t{\n\t\tsize_t strLen = 0;\n\t\twchar_t *wText = _MultiByteToWide(text.c_str(), strLen);\n\t\tif (wText != nullptr)\n\t\t{\n\t\t\tbool ret = AddLogText(std::wstring(wText));\n\t\t\t_FreeWCHAR(wText);\n\t\t\treturn ret;\n\t\t}\n\t}\n\treturn false;\n}\nbool CProgressIndicator::AddLogText(const std::wstring &text)\n{\n\tif (started)\n\t{\n\t\tHWND hWndStatus = GetDlgItem(this->hDialog, IDC_EDITSTATUS);\n\n\t\tint editLen = Edit_GetTextLength(hWndStatus);\n\t\tint oldSelStart = editLen;\n\t\tint oldSelEnd = editLen;\n\t\tSendMessage(hWndStatus, EM_GETSEL, (WPARAM)&oldSelStart, (LPARAM)&oldSelEnd);\n\n\t\tEdit_SetSel(hWndStatus, editLen, editLen);\n\t\tEdit_ReplaceSel(hWndStatus, text.c_str());\n\n\t\tif ((oldSelEnd != editLen) || (oldSelStart != oldSelEnd))\n\t\t\tEdit_SetSel(hWndStatus, oldSelStart, oldSelEnd);\n\t\telse\n\t\t\tEdit_SetSel(hWndStatus, editLen + text.size(), editLen + text.size());\n\t\t\n\t\tthis->logWasCalled = true;\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nbool CProgressIndicator::SetCancellable(bool cancellable)\n{\n\tif (started)\n\t{\n\t\tHWND hWndCancel = GetDlgItem(this->hDialog, IDCANCEL);\n\t\tButton_Enable(hWndCancel, cancellable ? TRUE : FALSE);\n\t\tthis->cancellable = cancellable;\n\t\tthis->forceUncancellable = true;\n\t\treturn true;\n\t}\n\treturn false;\n}\nbool CProgressIndicator::AddCancelCallback(std::unique_ptr<ICancelCallback> pCallback)\n{\n\tif (started)\n\t{\n\t\tcancelCallbacks.push_back(std::move(pCallback));\n\t\treturn true;\n\t}\n\treturn false;\n}\nbool CProgressIndicator::IsCancelled()\n{\n\tif (started)\n\t{\n\t\treturn cancelled;\n\t}\n\treturn false;\n}\nbool CProgressIndicator::SetCancelled(bool cancelled)\n{\n\tif (started)\n\t{\n\t\tbool prevCancelled = this->cancelled;\n\t\tthis->cancelled = cancelled;\n\t\tfor (size_t i = 0; i < cancelCallbacks.size(); i++)\n\t\t{\n\t\t\tcancelCallbacks[i]->OnCancelEvent(cancelled);\n\t\t}\n\t\tif (prevCancelled && !cancelled && !cancellable && !forceUncancellable)\n\t\t{\n\t\t\tSetCancellable(true); //Reenable the button, which will get disabled when the user presses cancel.\n\t\t}\n\t\treturn true;\n\t}\n\treturn false;\n}'