b'//Problem Link: https://codingcompetitions.withgoogle.com/codejam/round/0000000000051705/000000000008830b\n#include<bits/stdc++.h>\n#define ll bigint\nusing namespace std;\nconst int base = 1000000000;\nconst int base_digits = 9;\n \nstruct bigint {\n    vector<int> a;\n    int sign;\n \n    bigint() :\n        sign(1) {\n    }\n \n    bigint(long long v) {\n        *this = v;\n    }\n \n    bigint(const string &s) {\n        read(s);\n    }\n \n    void operator=(const bigint &v) {\n        sign = v.sign;\n        a = v.a;\n    }\n \n    void operator=(long long v) {\n        sign = 1;\n        if (v < 0)\n            sign = -1, v = -v;\n        for (; v > 0; v = v / base)\n            a.push_back(v % base);\n    }\n \n    bigint operator+(const bigint &v) const {\n        if (sign == v.sign) {\n            bigint res = v;\n \n            for (int i = 0, carry = 0; i < (int) max(a.size(), v.a.size()) || carry; ++i) {\n                if (i == (int) res.a.size())\n                    res.a.push_back(0);\n                res.a[i] += carry + (i < (int) a.size() ? a[i] : 0);\n                carry = res.a[i] >= base;\n                if (carry)\n                    res.a[i] -= base;\n            }\n            return res;\n        }\n        return *this - (-v);\n    }\n \n    bigint operator-(const bigint &v) const {\n        if (sign == v.sign) {\n            if (abs() >= v.abs()) {\n                bigint res = *this;\n                for (int i = 0, carry = 0; i < (int) v.a.size() || carry; ++i) {\n                    res.a[i] -= carry + (i < (int) v.a.size() ? v.a[i] : 0);\n                    carry = res.a[i] < 0;\n                    if (carry)\n                        res.a[i] += base;\n                }\n                res.trim();\n                return res;\n            }\n            return -(v - *this);\n        }\n        return *this + (-v);\n    }\n \n    void operator*=(int v) {\n        if (v < 0)\n            sign = -sign, v = -v;\n        for (int i = 0, carry = 0; i < (int) a.size() || carry; ++i) {\n            if (i == (int) a.size())\n                a.push_back(0);\n            long long cur = a[i] * (long long) v + carry;\n            carry = (int) (cur / base);\n            a[i] = (int) (cur % base);\n            //asm("divl %%ecx" : "=a"(carry), "=d"(a[i]) : "A"(cur), "c"(base));\n        }\n        trim();\n    }\n \n    bigint operator*(int v) const {\n        bigint res = *this;\n        res *= v;\n        return res;\n    }\n \n    friend pair<bigint, bigint> divmod(const bigint &a1, const bigint &b1) {\n        int norm = base / (b1.a.back() + 1);\n        bigint a = a1.abs() * norm;\n        bigint b = b1.abs() * norm;\n        bigint q, r;\n        q.a.resize(a.a.size());\n \n        for (int i = a.a.size() - 1; i >= 0; i--) {\n            r *= base;\n            r += a.a[i];\n            int s1 = r.a.size() <= b.a.size() ? 0 : r.a[b.a.size()];\n            int s2 = r.a.size() <= b.a.size() - 1 ? 0 : r.a[b.a.size() - 1];\n            int d = ((long long) base * s1 + s2) / b.a.back();\n            r -= b * d;\n            while (r < 0)\n                r += b, --d;\n            q.a[i] = d;\n        }\n \n        q.sign = a1.sign * b1.sign;\n        r.sign = a1.sign;\n        q.trim();\n        r.trim();\n        return make_pair(q, r / norm);\n    }\n \n    bigint operator/(const bigint &v) const {\n        return divmod(*this, v).first;\n    }\n \n    bigint operator%(const bigint &v) const {\n        return divmod(*this, v).second;\n    }\n \n    void operator/=(int v) {\n        if (v < 0)\n            sign = -sign, v = -v;\n        for (int i = (int) a.size() - 1, rem = 0; i >= 0; --i) {\n            long long cur = a[i] + rem * (long long) base;\n            a[i] = (int) (cur / v);\n            rem = (int) (cur % v);\n        }\n        trim();\n    }\n \n    bigint operator/(int v) const {\n        bigint res = *this;\n        res /= v;\n        return res;\n    }\n \n    int operator%(int v) const {\n        if (v < 0)\n            v = -v;\n        int m = 0;\n        for (int i = a.size() - 1; i >= 0; --i)\n            m = (a[i] + m * (long long) base) % v;\n        return m * sign;\n    }\n \n    void operator+=(const bigint &v) {\n        *this = *this + v;\n    }\n    void operator-=(const bigint &v) {\n        *this = *this - v;\n    }\n    void operator*=(const bigint &v) {\n        *this = *this * v;\n    }\n    void operator/=(const bigint &v) {\n        *this = *this / v;\n    }\n \n    bool operator<(const bigint &v) const {\n        if (sign != v.sign)\n            return sign < v.sign;\n        if (a.size() != v.a.size())\n            return a.size() * sign < v.a.size() * v.sign;\n        for (int i = a.size() - 1; i >= 0; i--)\n            if (a[i] != v.a[i])\n                return a[i] * sign < v.a[i] * sign;\n        return false;\n    }\n \n    bool operator>(const bigint &v) const {\n        return v < *this;\n    }\n    bool operator<=(const bigint &v) const {\n        return !(v < *this);\n    }\n    bool operator>=(const bigint &v) const {\n        return !(*this < v);\n    }\n    bool operator==(const bigint &v) const {\n        return !(*this < v) && !(v < *this);\n    }\n    bool operator!=(const bigint &v) const {\n        return *this < v || v < *this;\n    }\n \n    void trim() {\n        while (!a.empty() && !a.back())\n            a.pop_back();\n        if (a.empty())\n            sign = 1;\n    }\n \n    bool isZero() const {\n        return a.empty() || (a.size() == 1 && !a[0]);\n    }\n \n    bigint operator-() const {\n        bigint res = *this;\n        res.sign = -sign;\n        return res;\n    }\n \n    bigint abs() const {\n        bigint res = *this;\n        res.sign *= res.sign;\n        return res;\n    }\n \n    long long longValue() const {\n        long long res = 0;\n        for (int i = a.size() - 1; i >= 0; i--)\n            res = res * base + a[i];\n        return res * sign;\n    }\n \n    friend bigint gcd(const bigint &a, const bigint &b) {\n        return b.isZero() ? a : gcd(b, a % b);\n    }\n    friend bigint lcm(const bigint &a, const bigint &b) {\n        return a / gcd(a, b) * b;\n    }\n \n    void read(const string &s) {\n        sign = 1;\n        a.clear();\n        int pos = 0;\n        while (pos < (int) s.size() && (s[pos] == \'-\' || s[pos] == \'+\')) {\n            if (s[pos] == \'-\')\n                sign = -sign;\n            ++pos;\n        }\n        for (int i = s.size() - 1; i >= pos; i -= base_digits) {\n            int x = 0;\n            for (int j = max(pos, i - base_digits + 1); j <= i; j++)\n                x = x * 10 + s[j] - \'0\';\n            a.push_back(x);\n        }\n        trim();\n    }\n \n    friend istream& operator>>(istream &stream, bigint &v) {\n        string s;\n        stream >> s;\n        v.read(s);\n        return stream;\n    }\n \n    friend ostream& operator<<(ostream &stream, const bigint &v) {\n        if (v.sign == -1)\n            stream << \'-\';\n        stream << (v.a.empty() ? 0 : v.a.back());\n        for (int i = (int) v.a.size() - 2; i >= 0; --i)\n            stream << setw(base_digits) << setfill(\'0\') << v.a[i];\n        return stream;\n    }\n \n    static vector<int> convert_base(const vector<int> &a, int old_digits, int new_digits) {\n        vector<long long> p(max(old_digits, new_digits) + 1);\n        p[0] = 1;\n        for (int i = 1; i < (int) p.size(); i++)\n            p[i] = p[i - 1] * 10;\n        vector<int> res;\n        long long cur = 0;\n        int cur_digits = 0;\n        for (int i = 0; i < (int) a.size(); i++) {\n            cur += a[i] * p[cur_digits];\n            cur_digits += old_digits;\n            while (cur_digits >= new_digits) {\n                res.push_back(int(cur % p[new_digits]));\n                cur /= p[new_digits];\n                cur_digits -= new_digits;\n            }\n        }\n        res.push_back((int) cur);\n        while (!res.empty() && !res.back())\n            res.pop_back();\n        return res;\n    }\n \n    typedef vector<long long> vll;\n \n    static vll karatsubaMultiply(const vll &a, const vll &b) {\n        int n = a.size();\n        vll res(n + n);\n        if (n <= 32) {\n            for (int i = 0; i < n; i++)\n                for (int j = 0; j < n; j++)\n                    res[i + j] += a[i] * b[j];\n            return res;\n        }\n \n        int k = n >> 1;\n        vll a1(a.begin(), a.begin() + k);\n        vll a2(a.begin() + k, a.end());\n        vll b1(b.begin(), b.begin() + k);\n        vll b2(b.begin() + k, b.end());\n \n        vll a1b1 = karatsubaMultiply(a1, b1);\n        vll a2b2 = karatsubaMultiply(a2, b2);\n \n        for (int i = 0; i < k; i++)\n            a2[i] += a1[i];\n        for (int i = 0; i < k; i++)\n            b2[i] += b1[i];\n \n        vll r = karatsubaMultiply(a2, b2);\n        for (int i = 0; i < (int) a1b1.size(); i++)\n            r[i] -= a1b1[i];\n        for (int i = 0; i < (int) a2b2.size(); i++)\n            r[i] -= a2b2[i];\n \n        for (int i = 0; i < (int) r.size(); i++)\n            res[i + k] += r[i];\n        for (int i = 0; i < (int) a1b1.size(); i++)\n            res[i] += a1b1[i];\n        for (int i = 0; i < (int) a2b2.size(); i++)\n            res[i + n] += a2b2[i];\n        return res;\n    }\n \n    bigint operator*(const bigint &v) const {\n        vector<int> a6 = convert_base(this->a, base_digits, 6);\n        vector<int> b6 = convert_base(v.a, base_digits, 6);\n        vll a(a6.begin(), a6.end());\n        vll b(b6.begin(), b6.end());\n        while (a.size() < b.size())\n            a.push_back(0);\n        while (b.size() < a.size())\n            b.push_back(0);\n        while (a.size() & (a.size() - 1))\n            a.push_back(0), b.push_back(0);\n        vll c = karatsubaMultiply(a, b);\n        bigint res;\n        res.sign = sign * v.sign;\n        for (int i = 0, carry = 0; i < (int) c.size(); i++) {\n            long long cur = c[i] + carry;\n            res.a.push_back((int) (cur % 1000000));\n            carry = (int) (cur / 1000000);\n        }\n        res.a = convert_base(res.a, 6, base_digits);\n        res.trim();\n        return res;\n    }\n};\nvector<bigint> a;\nbigint g(bigint a, bigint b)\n{\n\tbigint rem = a%b;\n\tif(rem == 0) return b;\n\treturn g(b, rem);\n}\n\nint main()\n{\n\tint i, l, t;\n\tbigint n, x;\n\tcin >> t;\n\t\n\tfor(int tt = 1; tt <= t; tt++)\n\t{\n\t\tcout << "Case #" << tt << ": ";\n\t\tcin >> n >> l;\n\t\ta = {};\n\t\tfor(int i = 0; i < l; i++) {\n\t\t\tcin >> x;\n\t\t\ta.push_back(x);\n\t\t}\n\t\t\n\t\tint ptr;\n\t\tfor(ptr = 0; a[ptr] == a[ptr+1]; ptr++) ;\n\t\t\n\t\tbigint xb = g(a[ptr], a[ptr+1]);\n\t\t\n\t\tbigint xa = a[ptr]/xb;  // a[i] = a*b, b*c\n\t\tset<bigint> s = {xa, xb};\n\t\t\n\t\tvector<bigint> fh = {xa};\n\t\tfor(int i = ptr-1; i >= 0; i--) {\n\t\t\tll xz = a[i]/xa;\n\t\t\tfh.push_back(xz);\n\t\t\ts.insert(xz);\n\t\t\txa = xz;\n\t\t}\n\t\treverse(fh.begin(), fh.end());\n\t\t\n\t\tfh.push_back(xb);\n\t\t\n\t\tfor(int i = ptr+1; i < l; i++) {\n\t\t\tll xz = a[i]/xb;\n\t\t\tfh.push_back(xz);\n\t\t\ts.insert(xz);\n\t\t\txb = xz;\n\t\t}\n\t\t\n\t\tmap<bigint, int> h;\n\t\tint ctr = 0;\n\t\tfor(bigint xx: s) h[xx] = ++ctr;\n\t\t\n\t\tfor(bigint xx: fh) cout << char(h[xx]+64);\n\t\tcout << endl;\n\t\t\n\t\t\n\t}\n\t\n\treturn 0;\n}\n'