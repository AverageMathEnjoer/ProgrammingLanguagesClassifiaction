b'{-# OPTIONS_GHC -fno-warn-type-defaults #-}\n{-# LANGUAGE NoImplicitPrelude   #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n\nmodule Course.ApplicativeSpec where\n\nimport           Test.Hspec            (describe, it, Spec, shouldBe)\nimport           Test.Hspec.QuickCheck (prop)\nimport           Test.QuickCheck       ((===))\n\nimport           Course.Applicative    (filtering, lift1, lift2, lift3, lift4,\n                                        pure, replicateA, sequence, (*>), (<*),\n                                        (<*>))\nimport           Course.Core\nimport           Course.ExactlyOne     (ExactlyOne (..))\nimport           Course.Functor        ((<$>))\nimport           Course.List           (List (..), filter, length, listh,\n                                        product, sum)\nimport           Course.Optional       (Optional (..))\n\nspec :: Spec\nspec = do\n  describe "ExactlyOne instance" $ do\n    prop "pure == ExactlyOne" $ \\(x :: Integer) ->\n      pure x === ExactlyOne x\n    it "Applying within ExactlyOne" $\n      ExactlyOne (+ 10) <*> ExactlyOne 8\n        `shouldBe`\n          ExactlyOne 18\n\n  describe "List instance" $ do\n    prop "pure" $\n      \\x -> pure x === (x :. Nil :: List Integer)\n    it "<*>" $\n      (+1) :. (*2) :. Nil <*> listh [1,2,3]\n        `shouldBe`\n          listh [2,3,4,2,4,6]\n\n  describe "lift1" $ do\n    it "ExactlyOne" $\n      lift1 (+ 1) (ExactlyOne 2)\n        `shouldBe`\n          ExactlyOne (3 :: Integer)\n    it "empty List" $\n      lift1 (+ 1) Nil\n        `shouldBe`\n          Nil\n    it "List" $\n      lift1 (+ 1) (listh [1,2,3])\n        `shouldBe`\n          listh [2,3,4]\n\n  describe "Optional instance" $ do\n    prop "pure" $\n      \\(x :: Integer) -> pure x === Full x\n    it "Full <*> Full" $\n      Full (+8) <*> Full 7\n        `shouldBe`\n          Full 15\n    it "Empty <*> Full" $\n      Empty <*> Full "tilt"\n        `shouldBe`\n          (Empty :: Optional Integer)\n    it "Full <*> Empty" $\n      Full (+8) <*> Empty\n        `shouldBe`\n          Empty\n\n  describe "Function instance" $ do\n    it "addition" $\n      ((+) <*> (+10)) 3\n        `shouldBe`\n          16\n    it "more addition" $\n      ((+) <*> (+5)) 3\n        `shouldBe`\n          11\n    it "even more addition" $\n      ((+) <*> (+5)) 1\n        `shouldBe`\n          7\n    it "addition and multiplication" $\n      ((*) <*> (+10)) 3\n        `shouldBe`\n          39\n    it "more addition and multiplcation" $\n      ((*) <*> (+2)) 3\n        `shouldBe`\n          15\n    prop "pure" $\n      \\(x :: Integer) (y :: Integer) -> pure x y == x\n\n  describe "lift2" $ do\n    it "+ over ExactlyOne" $\n      lift2 (+) (ExactlyOne 7) (ExactlyOne 8)\n        `shouldBe`\n          ExactlyOne 15\n    it "+ over List" $\n      lift2 (+) (listh [1,2,3]) (listh [4,5])\n        `shouldBe`\n          listh [5,6,6,7,7,8]\n    it "+ over Optional - all full" $\n      lift2 (+) (Full 7) (Full 8)\n        `shouldBe`\n          Full 15\n    it "+ over Optional - first Empty" $\n      lift2 (+) Empty (Full 8)\n        `shouldBe`\n          Empty\n    it "+ over Optional - second Empty" $\n      lift2 (+) (Full 7) Empty\n        `shouldBe`\n          Empty\n    it "+ over functions" $\n      lift2 (+) length sum (listh [4,5,6])\n        `shouldBe`\n          18\n\n  describe "lift3" $ do\n    it "+ over ExactlyOne" $\n      lift3 (\\a b c -> a + b + c) (ExactlyOne 7) (ExactlyOne 8) (ExactlyOne 9)\n        `shouldBe`\n          ExactlyOne 24\n    it "+ over List" $\n      lift3 (\\a b c -> a + b + c) (listh [1,2,3]) (listh [4,5]) (listh [6,7,8])\n        `shouldBe`\n\n        listh [11,12,13,12,13,14,12,13,14,13,14,15,13,14,15,14,15,16]\n    it "+ over Optional" $\n      lift3 (\\a b c -> a + b + c) (Full 7) (Full 8) (Full 9)\n        `shouldBe`\n          Full 24\n    it "+ over Optional - third Empty" $\n      lift3 (\\a b c -> a + b + c) (Full 7) (Full 8) Empty\n        `shouldBe`\n          Empty\n    it "+ over Optional - first Empty" $\n      lift3 (\\a b c -> a + b + c) Empty (Full 8) (Full 9)\n        `shouldBe`\n          Empty\n    it "+ over Optional - first and second Empty" $\n      lift3 (\\a b c -> a + b + c) Empty Empty (Full 9)\n        `shouldBe`\n          Empty\n    it "+ over functions" $\n      lift3 (\\a b c -> a + b + c) length sum product (listh [4,5,6])\n        `shouldBe`\n          138\n\n  describe "lift4" $ do\n    it "+ over ExactlyOne" $\n      lift4 (\\a b c d -> a + b + c + d) (ExactlyOne 7) (ExactlyOne 8) (ExactlyOne 9) (ExactlyOne 10)\n        `shouldBe`\n          ExactlyOne 34\n    it "+ over List" $\n      lift4 (\\a b c d -> a + b + c + d) (listh [1, 2, 3]) (listh [4, 5]) (listh [6, 7, 8]) (listh [9, 10])\n        `shouldBe`\n\n        (listh [20,21,21,22,22,23,21,22,22,23,23,24,21,22,22,23,23,24,22,23,23,24,24,25,22,23,23,24,24,25,23,24,24,25,25,26])\n    it "+ over Optional" $\n      lift4 (\\a b c d -> a + b + c + d) (Full 7) (Full 8) (Full 9) (Full 10)\n        `shouldBe`\n          Full 34\n    it "+ over Optional - third Empty" $\n      lift4 (\\a b c d -> a + b + c + d) (Full 7) (Full 8) Empty  (Full 10)\n        `shouldBe`\n          Empty\n    it "+ over Optional - first Empty" $\n      lift4 (\\a b c d -> a + b + c + d) Empty (Full 8) (Full 9) (Full 10)\n        `shouldBe`\n          Empty\n    it "+ over Optional - first and second Empty" $\n      lift4 (\\a b c d -> a + b + c + d) Empty Empty (Full 9) (Full 10)\n        `shouldBe`\n          Empty\n    it "+ over functions" $\n      lift4 (\\a b c d -> a + b + c + d) length sum product (sum . filter even) (listh [4,5,6])\n        `shouldBe`\n          148\n\n  describe "rightApply" $ do\n    it "*> over List" $\n      listh [1,  2,  3] *> listh [4,  5,  6]\n        `shouldBe`\n          listh [4,5,6,4,5,6,4,5,6]\n    it "*> over List" $\n      listh [1,  2] *> listh [4,  5,  6]\n        `shouldBe`\n          listh [4,5,6,4,5,6]\n    it "another *> over List" $\n      listh [1,  2,  3] *> listh [4,  5]\n        `shouldBe`\n          listh [4,5,4,5,4,5]\n    it "*> over Optional" $\n      Full 7 *> Full 8\n        `shouldBe`\n          Full 8\n    prop "*> over List property" $\n      \\a b c x y z ->\n        let l1 = (listh [a,  b,  c] :: List Integer)\n            l2 = (listh [x,  y,  z] :: List Integer)\n         in l1 *> l2 == listh [x,  y,  z,  x,  y,  z,  x,  y,  z]\n    prop "*> over Optional property" $\n      \\x y -> (Full x :: Optional Integer) *> (Full y :: Optional Integer) == Full y\n\n  describe "leftApply" $ do\n    it "<* over List" $\n      (1 :. 2 :. 3 :. Nil) <* (4 :. 5 :. 6 :. Nil)\n        `shouldBe`\n          listh [1,1,1,2,2,2,3,3,3]\n    it "another <* over List" $\n      (1 :. 2 :. Nil) <* (4 :. 5 :. 6 :. Nil)\n        `shouldBe`\n          listh [1,1,1,2,2,2]\n    it "Yet another <* over List" $\n      (1 :. 2 :. 3 :. Nil) <* (4 :. 5 :. Nil)\n        `shouldBe`\n          listh [1,1,2,2,3,3]\n    it "<* over Optional" $\n      Full 7 <* Full 8\n        `shouldBe`\n          Full 7\n    prop "<* over List property" $\n      \\x y z a b c ->\n        let l1 = (x :. y :. z :. Nil) :: List Integer\n            l2 = (a :. b :. c :. Nil) :: List Integer\n         in l1 <* l2 == listh [x,  x,  x,  y,  y,  y,  z,  z,  z]\n    prop "<* over Optional property" $\n      \\x y -> Full (x :: Integer) <* Full (y :: Integer) == Full x\n\n  describe "sequence" $ do\n    it "ExactlyOne" $\n      sequence (listh [ExactlyOne 7, ExactlyOne 8, ExactlyOne 9])\n        `shouldBe`\n          ExactlyOne (listh [7,8,9])\n    it "List" $\n      sequence ((1 :. 2 :. 3 :. Nil) :. (1 :. 2 :. Nil) :. Nil)\n        `shouldBe`\n          (listh <$> (listh [[1,1],[1,2],[2,1],[2,2],[3,1],[3,2]]))\n    it "Optional with an empty" $\n      sequence (Full 7 :. Empty :. Nil)\n        `shouldBe`\n          Empty\n    it "Optional" $\n      sequence (Full 7 :. Full 8 :. Nil)\n        `shouldBe`\n          Full (listh [7,8])\n    it "(->)" $\n      sequence ((*10) :. (+2) :. Nil) 6\n        `shouldBe`\n          (listh [60,8])\n\n  describe "replicateA" $ do\n    it "ExactlyOne" $\n      replicateA 4 (ExactlyOne "hi")\n        `shouldBe`\n          ExactlyOne (listh ["hi","hi","hi","hi"])\n    it "Optional - Full" $\n      replicateA 4 (Full "hi")\n        `shouldBe`\n          Full (listh ["hi","hi","hi","hi"])\n    it "Optional - Empty" $\n      replicateA 4 Empty\n        `shouldBe`\n          (Empty :: Optional (List Integer))\n    it "(->)" $\n      replicateA 4 (*2) 5\n        `shouldBe`\n          (listh [10,10,10,10])\n    it "List" $ do\n      let\n        expected =\n          listh <$> listh\n            [ "aaa","aab","aac","aba","abb","abc","aca","acb","acc"\n            , "baa","bab","bac","bba","bbb","bbc","bca","bcb","bcc"\n            , "caa","cab","cac","cba","cbb","cbc","cca","ccb","ccc"\n            ]\n      replicateA 3 (\'a\' :. \'b\' :. \'c\' :. Nil)\n        `shouldBe`\n          expected\n\n  describe "filtering" $ do\n    it "ExactlyOne" $\n      filtering (ExactlyOne . even) (4 :. 5 :. 6 :. Nil)\n        `shouldBe`\n          ExactlyOne (listh [4,6])\n    it "Optional - all true" $ do\n      let\n        predicate a =\n          if a > 13\n          then Empty\n          else Full (a <= 7)\n      filtering predicate (4 :. 5 :. 6 :. Nil)\n        `shouldBe`\n          Full (listh [4,5,6])\n    it "Optional - some false" $ do\n      let\n        predicate a =\n          if a > 13\n          then Empty\n          else Full (a <= 7)\n      filtering predicate (4 :. 5 :. 6 :. 7 :. 8 :. 9 :. Nil)\n        `shouldBe`\n          Full (listh [4,5,6,7])\n    it "Optional - some empty" $ do\n      let\n        predicate a =\n          if a > 13\n          then Empty\n          else Full (a <= 7)\n      filtering predicate (4 :. 5 :. 6 :. 13 :. 14 :. Nil)\n        `shouldBe`\n          Empty\n    it "(->)" $ do\n      filtering (>) (4 :. 5 :. 6 :. 7 :. 8 :. 9 :. 10 :. 11 :. 12 :. Nil) 8\n        `shouldBe`\n          listh [9,10,11,12]\n    it "List" $ do\n      let\n        expected =\n          listh <$> listh\n            [ [1,2,3], [1,2,3], [1,2,3]\n            , [1,2,3], [1,2,3], [1,2,3]\n            , [1,2,3], [1,2,3]\n            ]\n      filtering (const $ True :. True :.  Nil) (1 :. 2 :. 3 :. Nil)\n        `shouldBe`\n          expected\n'