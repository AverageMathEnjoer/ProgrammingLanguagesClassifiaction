b'{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{-# LANGUAGE DeriveGeneric #-}\nmodule Database.Beam.Migrate.Tool.CmdLine where\n\n#if !MIN_VERSION_base(4, 11, 0)\nimport Data.Monoid\n#endif\nimport Data.Aeson\nimport Data.Hashable\nimport Data.Text (Text)\nimport Data.String (fromString)\n\nimport GHC.Generics\n\nimport Options.Applicative\n\ndata MigrationFormat = MigrationFormatHaskell | MigrationFormatBackend String\n  deriving (Show, Eq, Ord, Generic)\ninstance Hashable MigrationFormat\n\nnewtype ModuleName = ModuleName { unModuleName :: String }\n  deriving (Show, Eq, Ord, ToJSON, FromJSON)\nnewtype DatabaseName = DatabaseName { unDatabaseName :: String }\n  deriving (Show, Eq, Ord, ToJSONKey, FromJSONKey, Hashable)\n\ndata InitCommand\n  = InitCommand\n  { initBackend          :: Maybe ModuleName\n  , initConnectionString :: Maybe String\n  , initModule           :: ModuleName\n  , initModulePath       :: FilePath\n\n  , initInteractive      :: Bool\n  , initCreateSchema     :: Bool\n  } deriving Show\n\ndata CleanCommand\n  = CleanCommand\n  { cleanForce :: Bool\n  } deriving Show\n\ndata DatabaseCommand\n  = DatabaseCommandList\n  | DatabaseCommandAdd DatabaseName ModuleName String\n  | DatabaseCommandShow DatabaseName\n  | DatabaseCommandRename DatabaseName DatabaseName\n  deriving Show\n\ndata SchemaKind\n    = HsSchema | YamlSchema | BackendSchema\n      deriving Show\n\ndata SimpleCommand\n  = SimpleCommandSchema ModuleName String SchemaKind\n  deriving Show\n\ndata BranchCommand\n  = BranchCommandList\n  | BranchCommandDelete Text\n  | BranchCommandNew    Bool {-^ Don\'t switch -} Text\n  deriving Show\n\ndata SchemaCommand\n  = SchemaCommandImport !Bool DatabaseName (Maybe Text) !Bool {-^ Commit in database -} !Bool {-^ Do auto migrate -}\n    -- ^ Create a haskell migration for the given database\n\n  | SchemaCommandNew Text {-^ The schema to iterate on -}\n                     FilePath     {-^ The temporary file to use -}\n\n  | SchemaCommandCommit Bool {-^ Force creation of new schema -}\n                        Bool {-^ Overwrite old schema if nothing has changed -}\n                        (Maybe Text) {-^ Commit message -}\n  deriving Show\n\ndata MigrationCommand\n    = MigrationCommandNew Text {-^ The schema to come from (default DB) -}\n                          Text {-^ The schema to go to (default HEAD) -}\n                          Bool {-^ Attempt to automatically generate a migration -}\n                          Bool {-^ Leave migrations open for editing -}\n                          [ MigrationFormat ] {-^ Formats to generate in. If empty, defaults to every backend registered for schemas + Haskell -}\n    deriving Show\n\ndata MigrateCommand\n  = MigrateCommandInit InitCommand   -- ^ Initialize a new beam migrate registry\n  | MigrateCommandClean CleanCommand -- ^ Remove beam-migrate tables from a database\n\n  | MigrateCommandLog\n  | MigrateCommandStatus\n\n  | MigrateCommandDatabases DatabaseCommand\n  | MigrateCommandBranch    BranchCommand\n\n  | MigrateCommandSchema SchemaCommand\n  | MigrateCommandMigration MigrationCommand\n\n  | MigrateCommandAbort !Bool\n\n  | MigrateCommandDiff Bool (Maybe (Text, Maybe Text))\n\n  | MigrateCommandMigrate\n\n  | MigrateCommandSimple SimpleCommand\n  deriving Show\n\ndata MigrateCmdLine\n  = MigrateCmdLine\n  { migrateRegistryPath :: Maybe FilePath\n  , migratePackagePath  :: [ FilePath ]\n  , migrateDatabase     :: Maybe DatabaseName\n\n  , migrateSubcommand   :: MigrateCommand\n  } deriving Show\n\nmigrationArgParser :: Parser MigrateCmdLine\nmigrationArgParser =\n  MigrateCmdLine <$> optional (strOption (long "registry" <> short \'r\' <> metavar "REGISTRY" <> help "Path to beam-migrate registry"))\n                 <*> many (strOption (long "package-path" <> metavar "PACKAGE-PATH" <> help "Additional GHC package paths to search for backends"))\n                 <*> optional (DatabaseName <$> strOption (long "database" <> short \'d\' <> metavar "DATABASE" <> help "Name of database to use"))\n                 <*> (subparser $ mconcat [ command "init" initCommand, command "clean" cleanCommand\n\n                                          , command "log" logCommand, command "status" statusCommand\n\n                                          , command "diff" diffCommand\n\n                                          , command "database" databaseCommand\n                                          , command "branch" branchCommand\n                                          , command "simple" simpleCommand\n\n                                          , command "schema" schemaCommand\n                                          , command "migration" migrationCommand\n\n                                          , command "abort" abortCommand\n\n                                          , command "migrate" migrateCommand ])\n  where\n    initCommand = info (initParser <**> helper) (fullDesc <> progDesc "Initialize a beam-migrate registry in this directory, or in the given registration file")\n    cleanCommand = info (cleanParser <**> helper) (fullDesc <> progDesc "Remove all beam-migrate tables from the database")\n\n    logCommand = info (pure MigrateCommandLog <**> helper) (fullDesc <> progDesc "Display migration history of the given database")\n    statusCommand = info (pure MigrateCommandStatus <**> helper) (fullDesc <> progDesc "Show status of beam migrations")\n    diffCommand = info (diffParser <**> helper) (fullDesc <> progDesc "Show diff between revisions")\n    databaseCommand = info (databasesParser <**> helper) (fullDesc <> progDesc "Create, update, list databases in the registry")\n    branchCommand = info (branchParser <**> helper) (fullDesc <> progDesc "Create, update, list branches in the registry")\n    schemaCommand = info (schemaParser <**> helper) (fullDesc <> progDesc "Create, update, import, and list schemas")\n    migrationCommand = info (migrationParser <**> helper) (fullDesc <> progDesc "Create, update, and list migrations")\n    simpleCommand = info (simpleParser <**> helper) (fullDesc <> progDesc "Simple utilities that do not require a full beam-migrate setup")\n    migrateCommand = info (migrateParser <**> helper) (fullDesc <> progDesc "Bring the given database up-to-date with the current branch")\n    abortCommand = info (abortParser <**> helper) (fullDesc <> progDesc "Abort any edits taking place")\n\n    initParser = MigrateCommandInit <$>\n                 (InitCommand <$> optional (ModuleName <$> strOption (long "backend" <> metavar "BACKEND" <> help "Backend module to use"))\n                              <*> optional (strOption (long "connection" <> metavar "CONNECTION" <> help "Connection string for backend"))\n                              <*> (ModuleName <$> strOption (long "module" <> metavar "MODULE" <> help "Module to use"))\n                              <*> strOption (long "src-dir" <> metavar "SOURCEDIR" <> help "Directory containing source files" <> value ".")\n                              <*> flag True False (long "no-prompt" <> help "Do not prompt; fail instead")\n                              <*> flag True False (long "no-create" <> help "Do not create the beam-migrate schema in the database"))\n\n    cleanParser = MigrateCommandClean <$> (CleanCommand <$> switch (long "force" <> short \'f\' <> help "Do not prompt"))\n\n    diffParser = MigrateCommandDiff <$> flag False True (long "auto-script" <> help "Display migration as an auto-generated script, if possible")\n                                    <*> optional ((,) <$> (fromString <$> strArgument (metavar "ACTUAL" <> help "Reference to use as actual predicate source (default: DB!)"))\n                                                      <*> optional (fromString <$> strArgument (metavar "EXPECTED" <> help "Reference to use as correct predicate source (default: HEAD)")))\n\n    databasesParser = MigrateCommandDatabases <$> subparser (mconcat [ command "add"    databasesAddCommand\n                                                                     , command "list"   databasesListCommand\n                                                                     , command "show"   databasesShowCommand\n                                                                     , command "rename" databasesRenameCommand ])\n    databasesAddCommand =\n      info (databasesAddParser <**> helper) (fullDesc <> progDesc "Add a new database to the registry")\n      where databasesAddParser = DatabaseCommandAdd <$> (DatabaseName <$> strArgument (metavar "NAME" <> help "Name of new database"))\n                                                    <*> (ModuleName <$> strArgument (metavar "BACKEND" <> help "Backend Haskell module"))\n                                                    <*> strArgument (metavar "CONN" <> help "Connection string")\n    databasesListCommand =\n      info (databasesListParser <**> helper) (fullDesc <> progDesc "List databases in the registry")\n      where databasesListParser = pure DatabaseCommandList\n    databasesShowCommand =\n      info (databasesShowParser <**> helper) (fullDesc <> progDesc "Show database with given name")\n      where databasesShowParser = DatabaseCommandShow <$> (DatabaseName <$> strArgument (metavar "DATABASE" <> help "Database to show"))\n    databasesRenameCommand =\n      info (databasesRenameParser <**> helper) (fullDesc <> progDesc "Rename a database from OLDNAME to NEWNAME")\n      where databasesRenameParser = DatabaseCommandRename <$> (DatabaseName <$> strArgument (metavar "OLDNAME" <> help "Database to rename"))\n                                                          <*> (DatabaseName <$> strArgument (metavar "NEWNAME" <> help "New name for database"))\n\n    branchParser = MigrateCommandBranch <$> subparser (mconcat [ command "list" branchListCommand\n                                                               , command "delete" branchDeleteCommand\n                                                               , command "new" branchNewCommand ])\n\n    branchListCommand =\n      info (branchListParser <**> helper) (fullDesc <> progDesc "List branches in registry")\n      where branchListParser = pure BranchCommandList\n    branchDeleteCommand =\n      info (branchDeleteParser <**> helper) (fullDesc <> progDesc "Delete branch from registry")\n      where branchDeleteParser = BranchCommandDelete <$> (fromString <$> strArgument (metavar "BRANCH" <> help "Branch to delete"))\n    branchNewCommand =\n      info (branchNewParser <**> helper) (fullDesc <> progDesc "Create new branch starting from current HEAD")\n      where branchNewParser = BranchCommandNew <$> flag False True (long "dont-switch" <> help "Do not switch to the new branch")\n                                               <*> (fromString <$> strArgument (metavar "BRANCH" <> help "Name of new branch"))\n\n    schemaParser = MigrateCommandSchema <$> subparser (mconcat [ command "import" schemaImportCommand\n                                                               , command "new" schemaNewCommand\n                                                               , command "commit" schemaCommitCommand ])\n\n    schemaImportCommand = info (importParser <**> helper) (fullDesc <> progDesc "Import a database schema into haskell")\n      where\n        importParser = SchemaCommandImport <$> flag True False (long "interactive" <> short \'i\' <> help "Run in interactive mode")\n                                           <*> (DatabaseName <$> strArgument (metavar "DATABASE" <> help "Database to import from"))\n                                           <*> optional (fromString <$> strArgument (metavar "BRANCHNAME" <> help "Branch to import into"))\n                                           <*> flag True False (long "no-commit" <> help "Do not record commit in local change log")\n                                           <*> flag True False (long "no-migrate" <> help "Do not generate an automatic migration")\n\n    schemaNewCommand = info (newParser <**> helper) (fullDesc <> progDesc "Create a new schema")\n      where\n        newParser = SchemaCommandNew <$> (fromString <$> strArgument (metavar "FROM" <> help "Schema to iterate on" <> value "HEAD"))\n                                     <*> strOption (long "tmp-file" <> metavar "TMPFILE" <> help "Temporary file to edit schema" <> value "BeamMigrateSchema.hs")\n\n\n    schemaCommitCommand = info (commitParser <**> helper) (fullDesc <> progDesc "Commit the schema currently being edited")\n      where\n        commitParser = SchemaCommandCommit <$> flag False True (long "force" <> short \'f\' <> help "Force the creation of a new schema, even if nothing has changed")\n                                           <*> flag False True (long "overwrite" <> help "Overwrite the existing schema, only if nothing meaningful has changed")\n                                           <*> optional (fromString <$> strOption (short \'m\' <> metavar "MESSAGE" <> help "Commit message"))\n\n    migrationParser = MigrateCommandMigration <$> subparser (mconcat [ command "new" migrationNewCommand ])\n\n    migrationNewCommand = info (newParser <**> helper) (fullDesc <> progDesc "Create a new migration")\n        where\n          newParser = MigrationCommandNew <$> (fromString <$> strArgument (metavar "FROM" <> help "Schema to migrate from" <> value "DB"))\n                                          <*> (fromString <$> strArgument (metavar "TO" <> help "Schema to migrate to" <> value "HEAD"))\n                                          <*> flag False True (long "auto" <> help "Attempt to automatically generate appropriate migrations")\n                                          <*> flag True False (long "edit" <> short \'e\' <> help "Leave the migration files available for editing before committing them to the registry")\n                                          <*> (many (option (eitherReader migrationFormatReader) (long "format" <> short \'f\' <> help "Specify a list of formats desired for the given migration")))\n\n    simpleParser = MigrateCommandSimple <$> subparser (mconcat [ command "schema" simpleSchemaCommand ])\n\n    backendOption = ModuleName <$> strOption (long "backend" <> metavar "BACKEND" <> help "Backend module to use")\n    connectionOption = strOption (long "connection" <> metavar "CONNECTION" <> help "Connection string for backend")\n\n    simpleSchemaCommand =\n      info (simpleSchemaParser <**> helper) (fullDesc <> progDesc "Extract a haskell schema from the given database")\n      where simpleSchemaParser = SimpleCommandSchema <$> backendOption\n                                                     <*> connectionOption\n                                                     <*> ( flag\' YamlSchema\n                                                                 (long "yaml-schema" <> help "Dump schema in yaml format") <|>\n                                                           flag\' BackendSchema\n                                                                 (long "native-schema" <> help "Dump the schema in the native backend format") <|>\n                                                           flag HsSchema HsSchema\n                                                                 (long "haskell-schema" <> help "Dump schema in Haskell format"))\n\n    migrateParser = pure MigrateCommandMigrate\n\n    abortParser = MigrateCommandAbort <$> flag False True (long "force" <> short \'f\' <> help "Force this abort, even if the file has local changes")\n\nmigrationCliOptions :: ParserInfo MigrateCmdLine\nmigrationCliOptions =\n  info (migrationArgParser <**> helper)\n       (fullDesc <> progDesc "Beam migrate command-line interface" <>\n        header "beam-migrate -- migrate database schemas for various beam backends")\n\nmigrationFormatReader :: String -> Either String MigrationFormat\nmigrationFormatReader "hs" = pure MigrationFormatHaskell\nmigrationFormatReader backend = pure (MigrationFormatBackend backend)\n'