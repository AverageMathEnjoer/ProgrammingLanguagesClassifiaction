b'\xef\xbb\xbf//\n// BigInteger.cs - Big Integer implementation\n//\n// Authors:\n//\tBen Maurer\n//\tChew Keong TAN\n//\tSebastien Pouliot <sebastien@ximian.com>\n//\tPieter Philippaerts <Pieter@mentalis.org>\n//\n// Copyright (c) 2003 Ben Maurer\n// All rights reserved\n//\n// Copyright (c) 2002 Chew Keong TAN\n// All rights reserved.\n//\n// Copyright (C) 2004, 2007 Novell, Inc (http://www.novell.com)\n//\n// Permission is hereby granted, free of charge, to any person obtaining\n// a copy of this software and associated documentation files (the\n// "Software"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to\n// permit persons to whom the Software is furnished to do so, subject to\n// the following conditions:\n// \n// The above copyright notice and this permission notice shall be\n// included in all copies or substantial portions of the Software.\n// \n// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,\n// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n//\n\nusing System;\nusing System.Security.Cryptography;\nusing Mono.Math.Prime.Generator;\nusing Mono.Math.Prime;\nusing Mono.Math.Generator;\n\nnamespace Mono.Math {\n\n#if INSIDE_CORLIB\n\tinternal\n#else\n\tpublic\n#endif\n\tclass BigInteger {\n\n\t\t#region Data Storage\n\n\t\t/// <summary>\n\t\t/// The Length of this BigInteger\n\t\t/// </summary>\n\t\tuint length = 1;\n\n\t\t/// <summary>\n\t\t/// The data for this BigInteger\n\t\t/// </summary>\n\t\tuint[] data;\n\n\t\t#endregion\n\n\t\t#region Constants\n\n\t\t/// <summary>\n\t\t/// Default length of a BigInteger in bytes\n\t\t/// </summary>\n\t\tconst uint DEFAULT_LEN = 20;\n\n\t\t/// <summary>\n\t\t///\t\tTable of primes below 2000.\n\t\t/// </summary>\n\t\t/// <remarks>\n\t\t///\t\t<para>\n\t\t///\t\tThis table was generated using Mathematica 4.1 using the following function:\n\t\t///\t\t</para>\n\t\t///\t\t<para>\n\t\t///\t\t\t<code>\n\t\t///\t\t\tPrimeTable [x_] := Prime [Range [1, PrimePi [x]]]\n\t\t///\t\t\tPrimeTable [6000]\n\t\t///\t\t\t</code>\n\t\t///\t\t</para>\n\t\t/// </remarks>\n\t\tinternal static readonly uint[] smallPrimes = {\n\t\t\t2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71,\n\t\t\t73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151,\n\t\t\t157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233,\n\t\t\t239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317,\n\t\t\t331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419,\n\t\t\t421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503,\n\t\t\t509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607,\n\t\t\t613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701,\n\t\t\t709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811,\n\t\t\t821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911,\n\t\t\t919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997,\n\n\t\t\t1009, 1013, 1019, 1021, 1031, 1033, 1039, 1049, 1051, 1061, 1063, 1069, 1087,\n\t\t\t1091, 1093, 1097, 1103, 1109, 1117, 1123, 1129, 1151, 1153, 1163, 1171, 1181,\n\t\t\t1187, 1193, 1201, 1213, 1217, 1223, 1229, 1231, 1237, 1249, 1259, 1277, 1279,\n\t\t\t1283, 1289, 1291, 1297, 1301, 1303, 1307, 1319, 1321, 1327, 1361, 1367, 1373,\n\t\t\t1381, 1399, 1409, 1423, 1427, 1429, 1433, 1439, 1447, 1451, 1453, 1459, 1471,\n\t\t\t1481, 1483, 1487, 1489, 1493, 1499, 1511, 1523, 1531, 1543, 1549, 1553, 1559,\n\t\t\t1567, 1571, 1579, 1583, 1597, 1601, 1607, 1609, 1613, 1619, 1621, 1627, 1637,\n\t\t\t1657, 1663, 1667, 1669, 1693, 1697, 1699, 1709, 1721, 1723, 1733, 1741, 1747,\n\t\t\t1753, 1759, 1777, 1783, 1787, 1789, 1801, 1811, 1823, 1831, 1847, 1861, 1867,\n\t\t\t1871, 1873, 1877, 1879, 1889, 1901, 1907, 1913, 1931, 1933, 1949, 1951, 1973,\n\t\t\t1979, 1987, 1993, 1997, 1999,\n\n\t\t\t2003, 2011, 2017, 2027, 2029, 2039, 2053, 2063, 2069, 2081, 2083, 2087, 2089,\n\t\t\t2099, 2111, 2113, 2129, 2131, 2137, 2141, 2143, 2153, 2161, 2179, 2203, 2207,\n\t\t\t2213, 2221, 2237, 2239, 2243, 2251, 2267, 2269, 2273, 2281, 2287, 2293, 2297,\n\t\t\t2309, 2311, 2333, 2339, 2341, 2347, 2351, 2357, 2371, 2377, 2381, 2383, 2389,\n\t\t\t2393, 2399, 2411, 2417, 2423, 2437, 2441, 2447, 2459, 2467, 2473, 2477, 2503,\n\t\t\t2521, 2531, 2539, 2543, 2549, 2551, 2557, 2579, 2591, 2593, 2609, 2617, 2621,\n\t\t\t2633, 2647, 2657, 2659, 2663, 2671, 2677, 2683, 2687, 2689, 2693, 2699, 2707,\n\t\t\t2711, 2713, 2719, 2729, 2731, 2741, 2749, 2753, 2767, 2777, 2789, 2791, 2797,\n\t\t\t2801, 2803, 2819, 2833, 2837, 2843, 2851, 2857, 2861, 2879, 2887, 2897, 2903,\n\t\t\t2909, 2917, 2927, 2939, 2953, 2957, 2963, 2969, 2971, 2999,\n\n\t\t\t3001, 3011, 3019, 3023, 3037, 3041, 3049, 3061, 3067, 3079, 3083, 3089, 3109,\n\t\t\t3119, 3121, 3137, 3163, 3167, 3169, 3181, 3187, 3191, 3203, 3209, 3217, 3221,\n\t\t\t3229, 3251, 3253, 3257, 3259, 3271, 3299, 3301, 3307, 3313, 3319, 3323, 3329,\n\t\t\t3331, 3343, 3347, 3359, 3361, 3371, 3373, 3389, 3391, 3407, 3413, 3433, 3449,\n\t\t\t3457, 3461, 3463, 3467, 3469, 3491, 3499, 3511, 3517, 3527, 3529, 3533, 3539,\n\t\t\t3541, 3547, 3557, 3559, 3571, 3581, 3583, 3593, 3607, 3613, 3617, 3623, 3631,\n\t\t\t3637, 3643, 3659, 3671, 3673, 3677, 3691, 3697, 3701, 3709, 3719, 3727, 3733,\n\t\t\t3739, 3761, 3767, 3769, 3779, 3793, 3797, 3803, 3821, 3823, 3833, 3847, 3851,\n\t\t\t3853, 3863, 3877, 3881, 3889, 3907, 3911, 3917, 3919, 3923, 3929, 3931, 3943,\n\t\t\t3947, 3967, 3989,\n\n\t\t\t4001, 4003, 4007, 4013, 4019, 4021, 4027, 4049, 4051, 4057, 4073, 4079, 4091,\n\t\t\t4093, 4099, 4111, 4127, 4129, 4133, 4139, 4153, 4157, 4159, 4177, 4201, 4211,\n\t\t\t4217, 4219, 4229, 4231, 4241, 4243, 4253, 4259, 4261, 4271, 4273, 4283, 4289,\n\t\t\t4297, 4327, 4337, 4339, 4349, 4357, 4363, 4373, 4391, 4397, 4409, 4421, 4423,\n\t\t\t4441, 4447, 4451, 4457, 4463, 4481, 4483, 4493, 4507, 4513, 4517, 4519, 4523,\n\t\t\t4547, 4549, 4561, 4567, 4583, 4591, 4597, 4603, 4621, 4637, 4639, 4643, 4649,\n\t\t\t4651, 4657, 4663, 4673, 4679, 4691, 4703, 4721, 4723, 4729, 4733, 4751, 4759,\n\t\t\t4783, 4787, 4789, 4793, 4799, 4801, 4813, 4817, 4831, 4861, 4871, 4877, 4889,\n\t\t\t4903, 4909, 4919, 4931, 4933, 4937, 4943, 4951, 4957, 4967, 4969, 4973, 4987,\n\t\t\t4993, 4999,\n\n\t\t\t5003, 5009, 5011, 5021, 5023, 5039, 5051, 5059, 5077, 5081, 5087, 5099, 5101,\n\t\t\t5107, 5113, 5119, 5147, 5153, 5167, 5171, 5179, 5189, 5197, 5209, 5227, 5231,\n\t\t\t5233, 5237, 5261, 5273, 5279, 5281, 5297, 5303, 5309, 5323, 5333, 5347, 5351,\n\t\t\t5381, 5387, 5393, 5399, 5407, 5413, 5417, 5419, 5431, 5437, 5441, 5443, 5449,\n\t\t\t5471, 5477, 5479, 5483, 5501, 5503, 5507, 5519, 5521, 5527, 5531, 5557, 5563,\n\t\t\t5569, 5573, 5581, 5591, 5623, 5639, 5641, 5647, 5651, 5653, 5657, 5659, 5669,\n\t\t\t5683, 5689, 5693, 5701, 5711, 5717, 5737, 5741, 5743, 5749, 5779, 5783, 5791,\n\t\t\t5801, 5807, 5813, 5821, 5827, 5839, 5843, 5849, 5851, 5857, 5861, 5867, 5869,\n\t\t\t5879, 5881, 5897, 5903, 5923, 5927, 5939, 5953, 5981, 5987\n\t\t};\n\n\t\tpublic enum Sign : int {\n\t\t\tNegative = -1,\n\t\t\tZero = 0,\n\t\t\tPositive = 1\n\t\t};\n\n\t\t#region Exception Messages\n\t\tconst string WouldReturnNegVal = "Operation would return a negative value";\n\t\t#endregion\n\n\t\t#endregion\n\n\t\t#region Constructors\n\n\t\tpublic BigInteger() {\n\t\t\tdata = new uint[DEFAULT_LEN];\n\t\t\tthis.length = DEFAULT_LEN;\n\t\t}\n\n\t\tpublic BigInteger(Sign sign, uint len) {\n\t\t\tthis.data = new uint[len];\n\t\t\tthis.length = len;\n\t\t}\n\n\t\tpublic BigInteger(BigInteger bi) {\n\t\t\tthis.data = (uint[])bi.data.Clone();\n\t\t\tthis.length = bi.length;\n\t\t}\n\n\t\tpublic BigInteger(BigInteger bi, uint len) {\n\n\t\t\tthis.data = new uint[len];\n\n\t\t\tfor (uint i = 0; i < bi.length; i++)\n\t\t\t\tthis.data[i] = bi.data[i];\n\n\t\t\tthis.length = bi.length;\n\t\t}\n\n\t\t#endregion\n\n\t\t#region Conversions\n\n\t\tpublic BigInteger(byte[] inData) {\n\t\t\tif (inData.Length == 0)\n\t\t\t\tinData = new byte[1];\n\t\t\tlength = (uint)inData.Length >> 2;\n\t\t\tint leftOver = inData.Length & 0x3;\n\n\t\t\t// length not multiples of 4\n\t\t\tif (leftOver != 0) length++;\n\n\t\t\tdata = new uint[length];\n\n\t\t\tfor (int i = inData.Length - 1, j = 0; i >= 3; i -= 4, j++) {\n\t\t\t\tdata[j] = (uint)(\n\t\t\t\t\t(inData[i - 3] << (3 * 8)) |\n\t\t\t\t\t(inData[i - 2] << (2 * 8)) |\n\t\t\t\t\t(inData[i - 1] << (1 * 8)) |\n\t\t\t\t\t(inData[i])\n\t\t\t\t\t);\n\t\t\t}\n\n\t\t\tswitch (leftOver) {\n\t\t\t\tcase 1: data[length - 1] = (uint)inData[0]; break;\n\t\t\t\tcase 2: data[length - 1] = (uint)((inData[0] << 8) | inData[1]); break;\n\t\t\t\tcase 3: data[length - 1] = (uint)((inData[0] << 16) | (inData[1] << 8) | inData[2]); break;\n\t\t\t}\n\n\t\t\tthis.Normalize();\n\t\t}\n\n\t\tpublic BigInteger(uint[] inData) {\n\t\t\tif (inData.Length == 0)\n\t\t\t\tinData = new uint[1];\n\t\t\tlength = (uint)inData.Length;\n\n\t\t\tdata = new uint[length];\n\n\t\t\tfor (int i = (int)length - 1, j = 0; i >= 0; i--, j++)\n\t\t\t\tdata[j] = inData[i];\n\n\t\t\tthis.Normalize();\n\t\t}\n\n\t\tpublic BigInteger(uint ui) {\n\t\t\tdata = new uint[] { ui };\n\t\t}\n\n\t\tpublic BigInteger(ulong ul) {\n\t\t\tdata = new uint[2] { (uint)ul, (uint)(ul >> 32) };\n\t\t\tlength = 2;\n\n\t\t\tthis.Normalize();\n\t\t}\n\n\t\tpublic static implicit operator BigInteger(uint value) {\n\t\t\treturn (new BigInteger(value));\n\t\t}\n\n\t\tpublic static implicit operator BigInteger(int value) {\n\t\t\tif (value < 0) throw new ArgumentOutOfRangeException("value");\n\t\t\treturn (new BigInteger((uint)value));\n\t\t}\n\n\t\tpublic static implicit operator BigInteger(ulong value) {\n\t\t\treturn (new BigInteger(value));\n\t\t}\n\n\t\t/* This is the BigInteger.Parse method I use. This method works\n\t\tbecause BigInteger.ToString returns the input I gave to Parse. */\n\t\tpublic static BigInteger Parse(string number) {\n\t\t\tif (number == null)\n\t\t\t\tthrow new ArgumentNullException("number");\n\n\t\t\tint i = 0, len = number.Length;\n\t\t\tchar c;\n\t\t\tbool digits_seen = false;\n\t\t\tBigInteger val = new BigInteger(0);\n\t\t\tif (number[i] == \'+\') {\n\t\t\t\ti++;\n\t\t\t} else if (number[i] == \'-\') {\n\t\t\t\tthrow new FormatException(WouldReturnNegVal);\n\t\t\t}\n\n\t\t\tfor (; i < len; i++) {\n\t\t\t\tc = number[i];\n\t\t\t\tif (c == \'\\0\') {\n\t\t\t\t\ti = len;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (c >= \'0\' && c <= \'9\') {\n\t\t\t\t\tval = val * 10 + (c - \'0\');\n\t\t\t\t\tdigits_seen = true;\n\t\t\t\t} else {\n\t\t\t\t\tif (Char.IsWhiteSpace(c)) {\n\t\t\t\t\t\tfor (i++; i < len; i++) {\n\t\t\t\t\t\t\tif (!Char.IsWhiteSpace(number[i]))\n\t\t\t\t\t\t\t\tthrow new FormatException();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else\n\t\t\t\t\t\tthrow new FormatException();\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!digits_seen)\n\t\t\t\tthrow new FormatException();\n\t\t\treturn val;\n\t\t}\n\n\t\t#endregion\n\n\t\t#region Operators\n\n\t\tpublic static BigInteger operator +(BigInteger bi1, BigInteger bi2) {\n\t\t\tif (bi1 == 0)\n\t\t\t\treturn new BigInteger(bi2);\n\t\t\telse if (bi2 == 0)\n\t\t\t\treturn new BigInteger(bi1);\n\t\t\telse\n\t\t\t\treturn Kernel.AddSameSign(bi1, bi2);\n\t\t}\n\n\t\tpublic static BigInteger operator -(BigInteger bi1, BigInteger bi2) {\n\t\t\tif (bi2 == 0)\n\t\t\t\treturn new BigInteger(bi1);\n\n\t\t\tif (bi1 == 0)\n\t\t\t\tthrow new ArithmeticException(WouldReturnNegVal);\n\n\t\t\tswitch (Kernel.Compare(bi1, bi2)) {\n\n\t\t\t\tcase Sign.Zero:\n\t\t\t\t\treturn 0;\n\n\t\t\t\tcase Sign.Positive:\n\t\t\t\t\treturn Kernel.Subtract(bi1, bi2);\n\n\t\t\t\tcase Sign.Negative:\n\t\t\t\t\tthrow new ArithmeticException(WouldReturnNegVal);\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new Exception();\n\t\t\t}\n\t\t}\n\n\t\tpublic static int operator %(BigInteger bi, int i) {\n\t\t\tif (i > 0)\n\t\t\t\treturn (int)Kernel.DwordMod(bi, (uint)i);\n\t\t\telse\n\t\t\t\treturn -(int)Kernel.DwordMod(bi, (uint)-i);\n\t\t}\n\n\t\tpublic static uint operator %(BigInteger bi, uint ui) {\n\t\t\treturn Kernel.DwordMod(bi, (uint)ui);\n\t\t}\n\n\t\tpublic static BigInteger operator %(BigInteger bi1, BigInteger bi2) {\n\t\t\treturn Kernel.multiByteDivide(bi1, bi2)[1];\n\t\t}\n\n\t\tpublic static BigInteger operator /(BigInteger bi, int i) {\n\t\t\tif (i > 0)\n\t\t\t\treturn Kernel.DwordDiv(bi, (uint)i);\n\n\t\t\tthrow new ArithmeticException(WouldReturnNegVal);\n\t\t}\n\n\t\tpublic static BigInteger operator /(BigInteger bi1, BigInteger bi2) {\n\t\t\treturn Kernel.multiByteDivide(bi1, bi2)[0];\n\t\t}\n\n\t\tpublic static BigInteger operator *(BigInteger bi1, BigInteger bi2) {\n\t\t\tif (bi1 == 0 || bi2 == 0) return 0;\n\n\t\t\t//\n\t\t\t// Validate pointers\n\t\t\t//\n\t\t\tif (bi1.data.Length < bi1.length) throw new IndexOutOfRangeException("bi1 out of range");\n\t\t\tif (bi2.data.Length < bi2.length) throw new IndexOutOfRangeException("bi2 out of range");\n\n\t\t\tBigInteger ret = new BigInteger(Sign.Positive, bi1.length + bi2.length);\n\n\t\t\tKernel.Multiply(bi1.data, 0, bi1.length, bi2.data, 0, bi2.length, ret.data, 0);\n\n\t\t\tret.Normalize();\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic static BigInteger operator *(BigInteger bi, int i) {\n\t\t\tif (i < 0) throw new ArithmeticException(WouldReturnNegVal);\n\t\t\tif (i == 0) return 0;\n\t\t\tif (i == 1) return new BigInteger(bi);\n\n\t\t\treturn Kernel.MultiplyByDword(bi, (uint)i);\n\t\t}\n\n\t\tpublic static BigInteger operator <<(BigInteger bi1, int shiftVal) {\n\t\t\treturn Kernel.LeftShift(bi1, shiftVal);\n\t\t}\n\n\t\tpublic static BigInteger operator >>(BigInteger bi1, int shiftVal) {\n\t\t\treturn Kernel.RightShift(bi1, shiftVal);\n\t\t}\n\n\t\t#endregion\n\n\t\t#region Friendly names for operators\n\n\t\t// with names suggested by FxCop 1.30\n\n\t\tpublic static BigInteger Add(BigInteger bi1, BigInteger bi2) {\n\t\t\treturn (bi1 + bi2);\n\t\t}\n\n\t\tpublic static BigInteger Subtract(BigInteger bi1, BigInteger bi2) {\n\t\t\treturn (bi1 - bi2);\n\t\t}\n\n\t\tpublic static int Modulus(BigInteger bi, int i) {\n\t\t\treturn (bi % i);\n\t\t}\n\n\t\tpublic static uint Modulus(BigInteger bi, uint ui) {\n\t\t\treturn (bi % ui);\n\t\t}\n\n\t\tpublic static BigInteger Modulus(BigInteger bi1, BigInteger bi2) {\n\t\t\treturn (bi1 % bi2);\n\t\t}\n\n\t\tpublic static BigInteger Divid(BigInteger bi, int i) {\n\t\t\treturn (bi / i);\n\t\t}\n\n\t\tpublic static BigInteger Divid(BigInteger bi1, BigInteger bi2) {\n\t\t\treturn (bi1 / bi2);\n\t\t}\n\n\t\tpublic static BigInteger Multiply(BigInteger bi1, BigInteger bi2) {\n\t\t\treturn (bi1 * bi2);\n\t\t}\n\n\t\tpublic static BigInteger Multiply(BigInteger bi, int i) {\n\t\t\treturn (bi * i);\n\t\t}\n\n\t\t#endregion\n\n\t\t#region Random\n\t\tprivate static RandomNumberGenerator rng;\n\t\tprivate static RandomNumberGenerator Rng {\n\t\t\tget {\n\t\t\t\tif (rng == null)\n\t\t\t\t\trng = RandomNumberGenerator.Create();\n\t\t\t\treturn rng;\n\t\t\t}\n\t\t}\n\n\t\t/// <summary>\n\t\t/// Generates a new, random BigInteger of the specified length.\n\t\t/// </summary>\n\t\t/// <param name="bits">The number of bits for the new number.</param>\n\t\t/// <param name="rng">A random number generator to use to obtain the bits.</param>\n\t\t/// <returns>A random number of the specified length.</returns>\n\t\tpublic static BigInteger GenerateRandom(int bits, RandomNumberGenerator rng) {\n\t\t\tint dwords = bits >> 5;\n\t\t\tint remBits = bits & 0x1F;\n\n\t\t\tif (remBits != 0)\n\t\t\t\tdwords++;\n\n\t\t\tBigInteger ret = new BigInteger(Sign.Positive, (uint)dwords + 1);\n\t\t\tbyte[] random = new byte[dwords << 2];\n\n\t\t\trng.GetBytes(random);\n\t\t\tBuffer.BlockCopy(random, 0, ret.data, 0, (int)dwords << 2);\n\n\t\t\tif (remBits != 0) {\n\t\t\t\tuint mask = (uint)(0x01 << (remBits - 1));\n\t\t\t\tret.data[dwords - 1] |= mask;\n\n\t\t\t\tmask = (uint)(0xFFFFFFFF >> (32 - remBits));\n\t\t\t\tret.data[dwords - 1] &= mask;\n\t\t\t} else\n\t\t\t\tret.data[dwords - 1] |= 0x80000000;\n\n\t\t\tret.Normalize();\n\t\t\treturn ret;\n\t\t}\n\n\t\t/// <summary>\n\t\t/// Generates a new, random BigInteger of the specified length using the default RNG crypto service provider.\n\t\t/// </summary>\n\t\t/// <param name="bits">The number of bits for the new number.</param>\n\t\t/// <returns>A random number of the specified length.</returns>\n\t\tpublic static BigInteger GenerateRandom(int bits) {\n\t\t\treturn GenerateRandom(bits, Rng);\n\t\t}\n\n\t\t/// <summary>\n\t\t/// Randomizes the bits in "this" from the specified RNG.\n\t\t/// </summary>\n\t\t/// <param name="rng">A RNG.</param>\n\t\tpublic void Randomize(RandomNumberGenerator rng) {\n\t\t\tif (this == 0)\n\t\t\t\treturn;\n\n\t\t\tint bits = this.BitCount();\n\t\t\tint dwords = bits >> 5;\n\t\t\tint remBits = bits & 0x1F;\n\n\t\t\tif (remBits != 0)\n\t\t\t\tdwords++;\n\n\t\t\tbyte[] random = new byte[dwords << 2];\n\n\t\t\trng.GetBytes(random);\n\t\t\tBuffer.BlockCopy(random, 0, data, 0, (int)dwords << 2);\n\n\t\t\tif (remBits != 0) {\n\t\t\t\tuint mask = (uint)(0x01 << (remBits - 1));\n\t\t\t\tdata[dwords - 1] |= mask;\n\n\t\t\t\tmask = (uint)(0xFFFFFFFF >> (32 - remBits));\n\t\t\t\tdata[dwords - 1] &= mask;\n\t\t\t} else\n\t\t\t\tdata[dwords - 1] |= 0x80000000;\n\n\t\t\tNormalize();\n\t\t}\n\n\t\t/// <summary>\n\t\t/// Randomizes the bits in "this" from the default RNG.\n\t\t/// </summary>\n\t\tpublic void Randomize() {\n\t\t\tRandomize(Rng);\n\t\t}\n\n\t\t#endregion\n\n\t\t#region Bitwise\n\n\t\tpublic int BitCount() {\n\t\t\tthis.Normalize();\n\n\t\t\tuint value = data[length - 1];\n\t\t\tuint mask = 0x80000000;\n\t\t\tuint bits = 32;\n\n\t\t\twhile (bits > 0 && (value & mask) == 0) {\n\t\t\t\tbits--;\n\t\t\t\tmask >>= 1;\n\t\t\t}\n\t\t\tbits += ((length - 1) << 5);\n\n\t\t\treturn (int)bits;\n\t\t}\n\n\t\t/// <summary>\n\t\t/// Tests if the specified bit is 1.\n\t\t/// </summary>\n\t\t/// <param name="bitNum">The bit to test. The least significant bit is 0.</param>\n\t\t/// <returns>True if bitNum is set to 1, else false.</returns>\n\t\tpublic bool TestBit(uint bitNum) {\n\t\t\tuint bytePos = bitNum >> 5;             // divide by 32\n\t\t\tbyte bitPos = (byte)(bitNum & 0x1F);    // get the lowest 5 bits\n\n\t\t\tuint mask = (uint)1 << bitPos;\n\t\t\treturn ((this.data[bytePos] & mask) != 0);\n\t\t}\n\n\t\tpublic bool TestBit(int bitNum) {\n\t\t\tif (bitNum < 0) throw new IndexOutOfRangeException("bitNum out of range");\n\n\t\t\tuint bytePos = (uint)bitNum >> 5;             // divide by 32\n\t\t\tbyte bitPos = (byte)(bitNum & 0x1F);    // get the lowest 5 bits\n\n\t\t\tuint mask = (uint)1 << bitPos;\n\t\t\treturn ((this.data[bytePos] | mask) == this.data[bytePos]);\n\t\t}\n\n\t\tpublic void SetBit(uint bitNum) {\n\t\t\tSetBit(bitNum, true);\n\t\t}\n\n\t\tpublic void ClearBit(uint bitNum) {\n\t\t\tSetBit(bitNum, false);\n\t\t}\n\n\t\tpublic void SetBit(uint bitNum, bool value) {\n\t\t\tuint bytePos = bitNum >> 5;             // divide by 32\n\n\t\t\tif (bytePos < this.length) {\n\t\t\t\tuint mask = (uint)1 << (int)(bitNum & 0x1F);\n\t\t\t\tif (value)\n\t\t\t\t\tthis.data[bytePos] |= mask;\n\t\t\t\telse\n\t\t\t\t\tthis.data[bytePos] &= ~mask;\n\t\t\t}\n\t\t}\n\n\t\tpublic int LowestSetBit() {\n\t\t\tif (this == 0) return -1;\n\t\t\tint i = 0;\n\t\t\twhile (!TestBit(i)) i++;\n\t\t\treturn i;\n\t\t}\n\n\t\tpublic byte[] GetBytes() {\n\t\t\tif (this == 0) return new byte[1];\n\n\t\t\tint numBits = BitCount();\n\t\t\tint numBytes = numBits >> 3;\n\t\t\tif ((numBits & 0x7) != 0)\n\t\t\t\tnumBytes++;\n\n\t\t\tbyte[] result = new byte[numBytes];\n\n\t\t\tint numBytesInWord = numBytes & 0x3;\n\t\t\tif (numBytesInWord == 0) numBytesInWord = 4;\n\n\t\t\tint pos = 0;\n\t\t\tfor (int i = (int)length - 1; i >= 0; i--) {\n\t\t\t\tuint val = data[i];\n\t\t\t\tfor (int j = numBytesInWord - 1; j >= 0; j--) {\n\t\t\t\t\tresult[pos + j] = (byte)(val & 0xFF);\n\t\t\t\t\tval >>= 8;\n\t\t\t\t}\n\t\t\t\tpos += numBytesInWord;\n\t\t\t\tnumBytesInWord = 4;\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\n\t\t#endregion\n\n\t\t#region Compare\n\n\t\tpublic static bool operator ==(BigInteger bi1, uint ui) {\n\t\t\tif (bi1.length != 1) bi1.Normalize();\n\t\t\treturn bi1.length == 1 && bi1.data[0] == ui;\n\t\t}\n\n\t\tpublic static bool operator !=(BigInteger bi1, uint ui) {\n\t\t\tif (bi1.length != 1) bi1.Normalize();\n\t\t\treturn !(bi1.length == 1 && bi1.data[0] == ui);\n\t\t}\n\n\t\tpublic static bool operator ==(BigInteger bi1, BigInteger bi2) {\n\t\t\t// we need to compare with null\n\t\t\tif ((bi1 as object) == (bi2 as object))\n\t\t\t\treturn true;\n\t\t\tif (null == bi1 || null == bi2)\n\t\t\t\treturn false;\n\t\t\treturn Kernel.Compare(bi1, bi2) == 0;\n\t\t}\n\n\t\tpublic static bool operator !=(BigInteger bi1, BigInteger bi2) {\n\t\t\t// we need to compare with null\n\t\t\tif ((bi1 as object) == (bi2 as object))\n\t\t\t\treturn false;\n\t\t\tif (null == bi1 || null == bi2)\n\t\t\t\treturn true;\n\t\t\treturn Kernel.Compare(bi1, bi2) != 0;\n\t\t}\n\n\t\tpublic static bool operator >(BigInteger bi1, BigInteger bi2) {\n\t\t\treturn Kernel.Compare(bi1, bi2) > 0;\n\t\t}\n\n\t\tpublic static bool operator <(BigInteger bi1, BigInteger bi2) {\n\t\t\treturn Kernel.Compare(bi1, bi2) < 0;\n\t\t}\n\n\t\tpublic static bool operator >=(BigInteger bi1, BigInteger bi2) {\n\t\t\treturn Kernel.Compare(bi1, bi2) >= 0;\n\t\t}\n\n\t\tpublic static bool operator <=(BigInteger bi1, BigInteger bi2) {\n\t\t\treturn Kernel.Compare(bi1, bi2) <= 0;\n\t\t}\n\n\t\tpublic Sign Compare(BigInteger bi) {\n\t\t\treturn Kernel.Compare(this, bi);\n\t\t}\n\n\t\t#endregion\n\n\t\t#region Formatting\n\n\t\tpublic string ToString(uint radix) {\n\t\t\treturn ToString(radix, "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ");\n\t\t}\n\n\t\tpublic string ToString(uint radix, string characterSet) {\n\t\t\tif (characterSet.Length < radix)\n\t\t\t\tthrow new ArgumentException("charSet length less than radix", "characterSet");\n\t\t\tif (radix == 1)\n\t\t\t\tthrow new ArgumentException("There is no such thing as radix one notation", "radix");\n\n\t\t\tif (this == 0) return "0";\n\t\t\tif (this == 1) return "1";\n\n\t\t\tstring result = "";\n\n\t\t\tBigInteger a = new BigInteger(this);\n\n\t\t\twhile (a != 0) {\n\t\t\t\tuint rem = Kernel.SingleByteDivideInPlace(a, radix);\n\t\t\t\tresult = characterSet[(int)rem] + result;\n\t\t\t}\n\n\t\t\treturn result;\n\t\t}\n\n\t\t#endregion\n\n\t\t#region Misc\n\n\t\t/// <summary>\n\t\t///     Normalizes this by setting the length to the actual number of\n\t\t///     uints used in data and by setting the sign to Sign.Zero if the\n\t\t///     value of this is 0.\n\t\t/// </summary>\n\t\tprivate void Normalize() {\n\t\t\t// Normalize length\n\t\t\twhile (length > 0 && data[length - 1] == 0) length--;\n\n\t\t\t// Check for zero\n\t\t\tif (length == 0)\n\t\t\t\tlength++;\n\t\t}\n\n\t\tpublic void Clear() {\n\t\t\tfor (int i = 0; i < length; i++)\n\t\t\t\tdata[i] = 0x00;\n\t\t}\n\n\t\t#endregion\n\n\t\t#region Object Impl\n\n\t\tpublic override int GetHashCode() {\n\t\t\tuint val = 0;\n\n\t\t\tfor (uint i = 0; i < this.length; i++)\n\t\t\t\tval ^= this.data[i];\n\n\t\t\treturn (int)val;\n\t\t}\n\n\t\tpublic override string ToString() {\n\t\t\treturn ToString(10);\n\t\t}\n\n\t\tpublic override bool Equals(object o) {\n\t\t\tif (o == null)\n\t\t\t\treturn false;\n\t\t\tif (o is int)\n\t\t\t\treturn (int)o >= 0 && this == (uint)o;\n\n\t\t\tBigInteger bi = o as BigInteger;\n\t\t\tif (bi == null)\n\t\t\t\treturn false;\n\n\t\t\treturn Kernel.Compare(this, bi) == 0;\n\t\t}\n\n\t\t#endregion\n\n\t\t#region Number Theory\n\n\t\tpublic BigInteger GCD(BigInteger bi) {\n\t\t\treturn Kernel.gcd(this, bi);\n\t\t}\n\n\t\tpublic BigInteger ModInverse(BigInteger modulus) {\n\t\t\treturn Kernel.modInverse(this, modulus);\n\t\t}\n\n\t\tpublic BigInteger ModPow(BigInteger exp, BigInteger n) {\n\t\t\tModulusRing mr = new ModulusRing(n);\n\t\t\treturn mr.Pow(this, exp);\n\t\t}\n\n\t\t#endregion\n\n\t\t#region Prime Testing\n\n\t\tpublic bool IsProbablePrime() {\n\t\t\t// can we use our small-prime table ?\n\t\t\tif (this <= smallPrimes[smallPrimes.Length - 1]) {\n\t\t\t\tfor (int p = 0; p < smallPrimes.Length; p++) {\n\t\t\t\t\tif (this == smallPrimes[p])\n\t\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\t// the list is complete, so it\'s not a prime\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t// otherwise check if we can divide by one of the small primes\n\t\t\tfor (int p = 0; p < smallPrimes.Length; p++) {\n\t\t\t\tif (this % smallPrimes[p] == 0)\n\t\t\t\t\treturn false;\n\t\t\t}\n\t\t\t// the last step is to confirm the "large" prime with the SPP or Miller-Rabin test\n\t\t\treturn PrimalityTests.Test(this, Prime.ConfidenceFactor.Medium);\n\t\t}\n\n\t\t#endregion\n\n\t\t#region Prime Number Generation\n\n\t\t/// <summary>\n\t\t/// Generates the smallest prime >= bi\n\t\t/// </summary>\n\t\t/// <param name="bi">A BigInteger</param>\n\t\t/// <returns>The smallest prime >= bi. More mathematically, if bi is prime: bi, else Prime [PrimePi [bi] + 1].</returns>\n\t\tpublic static BigInteger NextHighestPrime(BigInteger bi) {\n\t\t\tNextPrimeFinder npf = new NextPrimeFinder();\n\t\t\treturn npf.GenerateNewPrime(0, bi);\n\t\t}\n\n\t\tpublic static BigInteger GeneratePseudoPrime(int bits) {\n\t\t\tSequentialSearchPrimeGeneratorBase sspg = new SequentialSearchPrimeGeneratorBase();\n\t\t\treturn sspg.GenerateNewPrime(bits);\n\t\t}\n\n\t\t/// <summary>\n\t\t/// Increments this by two\n\t\t/// </summary>\n\t\tpublic void Incr2() {\n\t\t\tint i = 0;\n\n\t\t\tdata[0] += 2;\n\n\t\t\t// If there was no carry, nothing to do\n\t\t\tif (data[0] < 2) {\n\n\t\t\t\t// Account for the first carry\n\t\t\t\tdata[++i]++;\n\n\t\t\t\t// Keep adding until no carry\n\t\t\t\twhile (data[i++] == 0x0)\n\t\t\t\t\tdata[i]++;\n\n\t\t\t\t// See if we increased the data length\n\t\t\t\tif (length == (uint)i)\n\t\t\t\t\tlength++;\n\t\t\t}\n\t\t}\n\n\t\t#endregion\n\n#if INSIDE_CORLIB\n\t\tinternal\n#else\n\t\tpublic\n#endif\n\t\tsealed class ModulusRing {\n\n\t\t\tBigInteger mod, constant;\n\n\t\t\tpublic ModulusRing(BigInteger modulus) {\n\t\t\t\tthis.mod = modulus;\n\n\t\t\t\t// calculate constant = b^ (2k) / m\n\t\t\t\tuint i = mod.length << 1;\n\n\t\t\t\tconstant = new BigInteger(Sign.Positive, i + 1);\n\t\t\t\tconstant.data[i] = 0x00000001;\n\n\t\t\t\tconstant = constant / mod;\n\t\t\t}\n\n\t\t\tpublic void BarrettReduction(BigInteger x) {\n\t\t\t\tBigInteger n = mod;\n\t\t\t\tuint k = n.length,\n\t\t\t\t\tkPlusOne = k + 1,\n\t\t\t\t\tkMinusOne = k - 1;\n\n\t\t\t\t// x < mod, so nothing to do.\n\t\t\t\tif (x.length < k) return;\n\n\t\t\t\tBigInteger q3;\n\n\t\t\t\t//\n\t\t\t\t// Validate pointers\n\t\t\t\t//\n\t\t\t\tif (x.data.Length < x.length) throw new IndexOutOfRangeException("x out of range");\n\n\t\t\t\t// q1 = x / b^ (k-1)\n\t\t\t\t// q2 = q1 * constant\n\t\t\t\t// q3 = q2 / b^ (k+1), Needs to be accessed with an offset of kPlusOne\n\n\t\t\t\t// TODO: We should the method in HAC p 604 to do this (14.45)\n\t\t\t\tq3 = new BigInteger(Sign.Positive, x.length - kMinusOne + constant.length);\n\t\t\t\tKernel.Multiply(x.data, kMinusOne, x.length - kMinusOne, constant.data, 0, constant.length, q3.data, 0);\n\n\t\t\t\t// r1 = x mod b^ (k+1)\n\t\t\t\t// i.e. keep the lowest (k+1) words\n\n\t\t\t\tuint lengthToCopy = (x.length > kPlusOne) ? kPlusOne : x.length;\n\n\t\t\t\tx.length = lengthToCopy;\n\t\t\t\tx.Normalize();\n\n\t\t\t\t// r2 = (q3 * n) mod b^ (k+1)\n\t\t\t\t// partial multiplication of q3 and n\n\n\t\t\t\tBigInteger r2 = new BigInteger(Sign.Positive, kPlusOne);\n\t\t\t\tKernel.MultiplyMod2p32pmod(q3.data, (int)kPlusOne, (int)q3.length - (int)kPlusOne, n.data, 0, (int)n.length, r2.data, 0, (int)kPlusOne);\n\n\t\t\t\tr2.Normalize();\n\n\t\t\t\tif (r2 <= x) {\n\t\t\t\t\tKernel.MinusEq(x, r2);\n\t\t\t\t} else {\n\t\t\t\t\tBigInteger val = new BigInteger(Sign.Positive, kPlusOne + 1);\n\t\t\t\t\tval.data[kPlusOne] = 0x00000001;\n\n\t\t\t\t\tKernel.MinusEq(val, r2);\n\t\t\t\t\tKernel.PlusEq(x, val);\n\t\t\t\t}\n\n\t\t\t\twhile (x >= n)\n\t\t\t\t\tKernel.MinusEq(x, n);\n\t\t\t}\n\n\t\t\tpublic BigInteger Multiply(BigInteger a, BigInteger b) {\n\t\t\t\tif (a == 0 || b == 0) return 0;\n\n\t\t\t\tif (a > mod)\n\t\t\t\t\ta %= mod;\n\n\t\t\t\tif (b > mod)\n\t\t\t\t\tb %= mod;\n\n\t\t\t\tBigInteger ret = a * b;\n\t\t\t\tBarrettReduction(ret);\n\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\tpublic BigInteger Difference(BigInteger a, BigInteger b) {\n\t\t\t\tSign cmp = Kernel.Compare(a, b);\n\t\t\t\tBigInteger diff;\n\n\t\t\t\tswitch (cmp) {\n\t\t\t\t\tcase Sign.Zero:\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\tcase Sign.Positive:\n\t\t\t\t\t\tdiff = a - b; break;\n\t\t\t\t\tcase Sign.Negative:\n\t\t\t\t\t\tdiff = b - a; break;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tthrow new Exception();\n\t\t\t\t}\n\n\t\t\t\tif (diff >= mod) {\n\t\t\t\t\tif (diff.length >= mod.length << 1)\n\t\t\t\t\t\tdiff %= mod;\n\t\t\t\t\telse\n\t\t\t\t\t\tBarrettReduction(diff);\n\t\t\t\t}\n\t\t\t\tif (cmp == Sign.Negative)\n\t\t\t\t\tdiff = mod - diff;\n\t\t\t\treturn diff;\n\t\t\t}\n#if true\n\t\t\tpublic BigInteger Pow(BigInteger a, BigInteger k) {\n\t\t\t\tBigInteger b = new BigInteger(1);\n\t\t\t\tif (k == 0)\n\t\t\t\t\treturn b;\n\n\t\t\t\tBigInteger A = a;\n\t\t\t\tif (k.TestBit(0))\n\t\t\t\t\tb = a;\n\n\t\t\t\tfor (int i = 1; i < k.BitCount(); i++) {\n\t\t\t\t\tA = Multiply(A, A);\n\t\t\t\t\tif (k.TestBit(i))\n\t\t\t\t\t\tb = Multiply(A, b);\n\t\t\t\t}\n\t\t\t\treturn b;\n\t\t\t}\n#else\n\t\t\tpublic BigInteger Pow (BigInteger b, BigInteger exp)\n\t\t\t{\n\t\t\t\tif ((mod.data [0] & 1) == 1) return OddPow (b, exp);\n\t\t\t\telse return EvenPow (b, exp);\n\t\t\t}\n\t\t\t\n\t\t\tpublic BigInteger EvenPow (BigInteger b, BigInteger exp)\n\t\t\t{\n\t\t\t\tBigInteger resultNum = new BigInteger ((BigInteger)1, mod.length << 1);\n\t\t\t\tBigInteger tempNum = new BigInteger (b % mod, mod.length << 1);  // ensures (tempNum * tempNum) < b^ (2k)\n\n\t\t\t\tuint totalBits = (uint)exp.BitCount ();\n\n\t\t\t\tuint [] wkspace = new uint [mod.length << 1];\n\n\t\t\t\t// perform squaring and multiply exponentiation\n\t\t\t\tfor (uint pos = 0; pos < totalBits; pos++) {\n\t\t\t\t\tif (exp.TestBit (pos)) {\n\n\t\t\t\t\t\tArray.Clear (wkspace, 0, wkspace.Length);\n\t\t\t\t\t\tKernel.Multiply (resultNum.data, 0, resultNum.length, tempNum.data, 0, tempNum.length, wkspace, 0);\n\t\t\t\t\t\tresultNum.length += tempNum.length;\n\t\t\t\t\t\tuint [] t = wkspace;\n\t\t\t\t\t\twkspace = resultNum.data;\n\t\t\t\t\t\tresultNum.data = t;\n\n\t\t\t\t\t\tBarrettReduction (resultNum);\n\t\t\t\t\t}\n\n\t\t\t\t\tKernel.SquarePositive (tempNum, ref wkspace);\n\t\t\t\t\tBarrettReduction (tempNum);\n\n\t\t\t\t\tif (tempNum == 1) {\n\t\t\t\t\t\treturn resultNum;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn resultNum;\n\t\t\t}\n\n\t\t\tprivate BigInteger OddPow (BigInteger b, BigInteger exp)\n\t\t\t{\n\t\t\t\tBigInteger resultNum = new BigInteger (Montgomery.ToMont (1, mod), mod.length << 1);\n\t\t\t\tBigInteger tempNum = new BigInteger (Montgomery.ToMont (b, mod), mod.length << 1);  // ensures (tempNum * tempNum) < b^ (2k)\n\t\t\t\tuint mPrime = Montgomery.Inverse (mod.data [0]);\n\t\t\t\tuint totalBits = (uint)exp.BitCount ();\n\n\t\t\t\tuint [] wkspace = new uint [mod.length << 1];\n\n\t\t\t\t// perform squaring and multiply exponentiation\n\t\t\t\tfor (uint pos = 0; pos < totalBits; pos++) {\n\t\t\t\t\tif (exp.TestBit (pos)) {\n\n\t\t\t\t\t\tArray.Clear (wkspace, 0, wkspace.Length);\n\t\t\t\t\t\tKernel.Multiply (resultNum.data, 0, resultNum.length, tempNum.data, 0, tempNum.length, wkspace, 0);\n\t\t\t\t\t\tresultNum.length += tempNum.length;\n\t\t\t\t\t\tuint [] t = wkspace;\n\t\t\t\t\t\twkspace = resultNum.data;\n\t\t\t\t\t\tresultNum.data = t;\n\n\t\t\t\t\t\tMontgomery.Reduce (resultNum, mod, mPrime);\n\t\t\t\t\t}\n\n\t\t\t\t\t// the value of tempNum is required in the last loop\n\t\t\t\t\tif (pos < totalBits - 1) {\n\t\t\t\t\t\tKernel.SquarePositive (tempNum, ref wkspace);\n\t\t\t\t\t\tMontgomery.Reduce (tempNum, mod, mPrime);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tMontgomery.Reduce (resultNum, mod, mPrime);\n\t\t\t\treturn resultNum;\n\t\t\t}\n#endif\n\t\t\t#region Pow Small Base\n\n\t\t\t// TODO: Make tests for this, not really needed b/c prime stuff\n\t\t\t// checks it, but still would be nice\n#if true\n\t\t\tpublic BigInteger Pow(uint b, BigInteger exp) {\n\t\t\t\treturn Pow(new BigInteger(b), exp);\n\t\t\t}\n#else\n\t\t\tpublic BigInteger Pow (uint b, BigInteger exp)\n\t\t\t{\n//\t\t\t\tif (b != 2) {\n\t\t\t\t\tif ((mod.data [0] & 1) == 1)\n\t\t\t\t\t\treturn OddPow (b, exp);\n\t\t\t\t\telse\n\t\t\t\t\t\treturn EvenPow (b, exp);\n/* buggy in some cases (like the well tested primes) \n\t\t\t\t} else {\n\t\t\t\t\tif ((mod.data [0] & 1) == 1)\n\t\t\t\t\t\treturn OddModTwoPow (exp);\n\t\t\t\t\telse \n\t\t\t\t\t\treturn EvenModTwoPow (exp);\n\t\t\t\t}*/\n\t\t\t}\n\n\t\t\tprivate unsafe BigInteger OddPow (uint b, BigInteger exp)\n\t\t\t{\n\t\t\t\texp.Normalize ();\n\t\t\t\tuint [] wkspace = new uint [mod.length << 1 + 1];\n\n\t\t\t\tBigInteger resultNum = Montgomery.ToMont ((BigInteger)b, this.mod);\n\t\t\t\tresultNum = new BigInteger (resultNum, mod.length << 1 +1);\n\n\t\t\t\tuint mPrime = Montgomery.Inverse (mod.data [0]);\n\n\t\t\t\tint bc = exp.BitCount () - 2;\n\t\t\t\tuint pos = (bc > 1 ? (uint) bc : 1);\n\n\t\t\t\t//\n\t\t\t\t// We know that the first itr will make the val b\n\t\t\t\t//\n\n\t\t\t\tdo {\n\t\t\t\t\t//\n\t\t\t\t\t// r = r ^ 2 % m\n\t\t\t\t\t//\n\t\t\t\t\tKernel.SquarePositive (resultNum, ref wkspace);\n\t\t\t\t\tresultNum = Montgomery.Reduce (resultNum, mod, mPrime);\n\n\t\t\t\t\tif (exp.TestBit (pos)) {\n\n\t\t\t\t\t\t//\n\t\t\t\t\t\t// r = r * b % m\n\t\t\t\t\t\t//\n\n\t\t\t\t\t\t// TODO: Is Unsafe really speeding things up?\n\t\t\t\t\t\tfixed (uint* u = resultNum.data) {\n\n\t\t\t\t\t\t\tuint i = 0;\n\t\t\t\t\t\t\tulong mc = 0;\n\n\t\t\t\t\t\t\tdo {\n\t\t\t\t\t\t\t\tmc += (ulong)u [i] * (ulong)b;\n\t\t\t\t\t\t\t\tu [i] = (uint)mc;\n\t\t\t\t\t\t\t\tmc >>= 32;\n\t\t\t\t\t\t\t} while (++i < resultNum.length);\n\n\t\t\t\t\t\t\tif (resultNum.length < mod.length) {\n\t\t\t\t\t\t\t\tif (mc != 0) {\n\t\t\t\t\t\t\t\t\tu [i] = (uint)mc;\n\t\t\t\t\t\t\t\t\tresultNum.length++;\n\t\t\t\t\t\t\t\t\twhile (resultNum >= mod)\n\t\t\t\t\t\t\t\t\t\tKernel.MinusEq (resultNum, mod);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else if (mc != 0) {\n\n\t\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t\t// First, we estimate the quotient by dividing\n\t\t\t\t\t\t\t\t// the first part of each of the numbers. Then\n\t\t\t\t\t\t\t\t// we correct this, if necessary, with a subtraction.\n\t\t\t\t\t\t\t\t//\n\n\t\t\t\t\t\t\t\tuint cc = (uint)mc;\n\n\t\t\t\t\t\t\t\t// We would rather have this estimate overshoot,\n\t\t\t\t\t\t\t\t// so we add one to the divisor\n\t\t\t\t\t\t\t\tuint divEstimate;\n\t\t\t\t\t\t\t\tif (mod.data [mod.length - 1] < UInt32.MaxValue) {\n\t\t\t\t\t\t\t\t\tdivEstimate = (uint) ((((ulong)cc << 32) | (ulong) u [i -1]) /\n\t\t\t\t\t\t\t\t\t\t(mod.data [mod.length-1] + 1));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t// guess but don\'t divide by 0\n\t\t\t\t\t\t\t\t\tdivEstimate = (uint) ((((ulong)cc << 32) | (ulong) u [i -1]) /\n\t\t\t\t\t\t\t\t\t\t(mod.data [mod.length-1]));\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tuint t;\n\n\t\t\t\t\t\t\t\ti = 0;\n\t\t\t\t\t\t\t\tmc = 0;\n\t\t\t\t\t\t\t\tdo {\n\t\t\t\t\t\t\t\t\tmc += (ulong)mod.data [i] * (ulong)divEstimate;\n\t\t\t\t\t\t\t\t\tt = u [i];\n\t\t\t\t\t\t\t\t\tu [i] -= (uint)mc;\n\t\t\t\t\t\t\t\t\tmc >>= 32;\n\t\t\t\t\t\t\t\t\tif (u [i] > t) mc++;\n\t\t\t\t\t\t\t\t\ti++;\n\t\t\t\t\t\t\t\t} while (i < resultNum.length);\n\t\t\t\t\t\t\t\tcc -= (uint)mc;\n\n\t\t\t\t\t\t\t\tif (cc != 0) {\n\n\t\t\t\t\t\t\t\t\tuint sc = 0, j = 0;\n\t\t\t\t\t\t\t\t\tuint [] s = mod.data;\n\t\t\t\t\t\t\t\t\tdo {\n\t\t\t\t\t\t\t\t\t\tuint a = s [j];\n\t\t\t\t\t\t\t\t\t\tif (((a += sc) < sc) | ((u [j] -= a) > ~a)) sc = 1;\n\t\t\t\t\t\t\t\t\t\telse sc = 0;\n\t\t\t\t\t\t\t\t\t\tj++;\n\t\t\t\t\t\t\t\t\t} while (j < resultNum.length);\n\t\t\t\t\t\t\t\t\tcc -= sc;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\twhile (resultNum >= mod)\n\t\t\t\t\t\t\t\t\tKernel.MinusEq (resultNum, mod);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\twhile (resultNum >= mod)\n\t\t\t\t\t\t\t\t\tKernel.MinusEq (resultNum, mod);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} while (pos-- > 0);\n\n\t\t\t\tresultNum = Montgomery.Reduce (resultNum, mod, mPrime);\n\t\t\t\treturn resultNum;\n\n\t\t\t}\n\t\t\t\n\t\t\tprivate unsafe BigInteger EvenPow (uint b, BigInteger exp)\n\t\t\t{\n\t\t\t\texp.Normalize ();\n\t\t\t\tuint [] wkspace = new uint [mod.length << 1 + 1];\n\t\t\t\tBigInteger resultNum = new BigInteger ((BigInteger)b, mod.length << 1 + 1);\n\n\t\t\t\tuint pos = (uint)exp.BitCount () - 2;\n\n\t\t\t\t//\n\t\t\t\t// We know that the first itr will make the val b\n\t\t\t\t//\n\n\t\t\t\tdo {\n\t\t\t\t\t//\n\t\t\t\t\t// r = r ^ 2 % m\n\t\t\t\t\t//\n\t\t\t\t\tKernel.SquarePositive (resultNum, ref wkspace);\n\t\t\t\t\tif (!(resultNum.length < mod.length))\n\t\t\t\t\t\tBarrettReduction (resultNum);\n\n\t\t\t\t\tif (exp.TestBit (pos)) {\n\n\t\t\t\t\t\t//\n\t\t\t\t\t\t// r = r * b % m\n\t\t\t\t\t\t//\n\n\t\t\t\t\t\t// TODO: Is Unsafe really speeding things up?\n\t\t\t\t\t\tfixed (uint* u = resultNum.data) {\n\n\t\t\t\t\t\t\tuint i = 0;\n\t\t\t\t\t\t\tulong mc = 0;\n\n\t\t\t\t\t\t\tdo {\n\t\t\t\t\t\t\t\tmc += (ulong)u [i] * (ulong)b;\n\t\t\t\t\t\t\t\tu [i] = (uint)mc;\n\t\t\t\t\t\t\t\tmc >>= 32;\n\t\t\t\t\t\t\t} while (++i < resultNum.length);\n\n\t\t\t\t\t\t\tif (resultNum.length < mod.length) {\n\t\t\t\t\t\t\t\tif (mc != 0) {\n\t\t\t\t\t\t\t\t\tu [i] = (uint)mc;\n\t\t\t\t\t\t\t\t\tresultNum.length++;\n\t\t\t\t\t\t\t\t\twhile (resultNum >= mod)\n\t\t\t\t\t\t\t\t\t\tKernel.MinusEq (resultNum, mod);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else if (mc != 0) {\n\n\t\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t\t// First, we estimate the quotient by dividing\n\t\t\t\t\t\t\t\t// the first part of each of the numbers. Then\n\t\t\t\t\t\t\t\t// we correct this, if necessary, with a subtraction.\n\t\t\t\t\t\t\t\t//\n\n\t\t\t\t\t\t\t\tuint cc = (uint)mc;\n\n\t\t\t\t\t\t\t\t// We would rather have this estimate overshoot,\n\t\t\t\t\t\t\t\t// so we add one to the divisor\n\t\t\t\t\t\t\t\tuint divEstimate = (uint) ((((ulong)cc << 32) | (ulong) u [i -1]) /\n\t\t\t\t\t\t\t\t\t(mod.data [mod.length-1] + 1));\n\n\t\t\t\t\t\t\t\tuint t;\n\n\t\t\t\t\t\t\t\ti = 0;\n\t\t\t\t\t\t\t\tmc = 0;\n\t\t\t\t\t\t\t\tdo {\n\t\t\t\t\t\t\t\t\tmc += (ulong)mod.data [i] * (ulong)divEstimate;\n\t\t\t\t\t\t\t\t\tt = u [i];\n\t\t\t\t\t\t\t\t\tu [i] -= (uint)mc;\n\t\t\t\t\t\t\t\t\tmc >>= 32;\n\t\t\t\t\t\t\t\t\tif (u [i] > t) mc++;\n\t\t\t\t\t\t\t\t\ti++;\n\t\t\t\t\t\t\t\t} while (i < resultNum.length);\n\t\t\t\t\t\t\t\tcc -= (uint)mc;\n\n\t\t\t\t\t\t\t\tif (cc != 0) {\n\n\t\t\t\t\t\t\t\t\tuint sc = 0, j = 0;\n\t\t\t\t\t\t\t\t\tuint [] s = mod.data;\n\t\t\t\t\t\t\t\t\tdo {\n\t\t\t\t\t\t\t\t\t\tuint a = s [j];\n\t\t\t\t\t\t\t\t\t\tif (((a += sc) < sc) | ((u [j] -= a) > ~a)) sc = 1;\n\t\t\t\t\t\t\t\t\t\telse sc = 0;\n\t\t\t\t\t\t\t\t\t\tj++;\n\t\t\t\t\t\t\t\t\t} while (j < resultNum.length);\n\t\t\t\t\t\t\t\t\tcc -= sc;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\twhile (resultNum >= mod)\n\t\t\t\t\t\t\t\t\tKernel.MinusEq (resultNum, mod);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\twhile (resultNum >= mod)\n\t\t\t\t\t\t\t\t\tKernel.MinusEq (resultNum, mod);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} while (pos-- > 0);\n\n\t\t\t\treturn resultNum;\n\t\t\t}\n#endif\n\t\t\t/* known to be buggy in some cases */\n#if false\n\t\t\tprivate unsafe BigInteger EvenModTwoPow (BigInteger exp)\n\t\t\t{\n\t\t\t\texp.Normalize ();\n\t\t\t\tuint [] wkspace = new uint [mod.length << 1 + 1];\n\n\t\t\t\tBigInteger resultNum = new BigInteger (2, mod.length << 1 +1);\n\n\t\t\t\tuint value = exp.data [exp.length - 1];\n\t\t\t\tuint mask = 0x80000000;\n\n\t\t\t\t// Find the first bit of the exponent\n\t\t\t\twhile ((value & mask) == 0)\n\t\t\t\t\tmask >>= 1;\n\n\t\t\t\t//\n\t\t\t\t// We know that the first itr will make the val 2,\n\t\t\t\t// so eat one bit of the exponent\n\t\t\t\t//\n\t\t\t\tmask >>= 1;\n\n\t\t\t\tuint wPos = exp.length - 1;\n\n\t\t\t\tdo {\n\t\t\t\t\tvalue = exp.data [wPos];\n\t\t\t\t\tdo {\n\t\t\t\t\t\tKernel.SquarePositive (resultNum, ref wkspace);\n\t\t\t\t\t\tif (resultNum.length >= mod.length)\n\t\t\t\t\t\t\tBarrettReduction (resultNum);\n\n\t\t\t\t\t\tif ((value & mask) != 0) {\n\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t// resultNum = (resultNum * 2) % mod\n\t\t\t\t\t\t\t//\n\n\t\t\t\t\t\t\tfixed (uint* u = resultNum.data) {\n\t\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t\t// Double\n\t\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t\tuint* uu = u;\n\t\t\t\t\t\t\t\tuint* uuE = u + resultNum.length;\n\t\t\t\t\t\t\t\tuint x, carry = 0;\n\t\t\t\t\t\t\t\twhile (uu < uuE) {\n\t\t\t\t\t\t\t\t\tx = *uu;\n\t\t\t\t\t\t\t\t\t*uu = (x << 1) | carry;\n\t\t\t\t\t\t\t\t\tcarry = x >> (32 - 1);\n\t\t\t\t\t\t\t\t\tuu++;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t// subtraction inlined because we know it is square\n\t\t\t\t\t\t\t\tif (carry != 0 || resultNum >= mod) {\n\t\t\t\t\t\t\t\t\tuu = u;\n\t\t\t\t\t\t\t\t\tuint c = 0;\n\t\t\t\t\t\t\t\t\tuint [] s = mod.data;\n\t\t\t\t\t\t\t\t\tuint i = 0;\n\t\t\t\t\t\t\t\t\tdo {\n\t\t\t\t\t\t\t\t\t\tuint a = s [i];\n\t\t\t\t\t\t\t\t\t\tif (((a += c) < c) | ((* (uu++) -= a) > ~a))\n\t\t\t\t\t\t\t\t\t\t\tc = 1;\n\t\t\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\t\t\tc = 0;\n\t\t\t\t\t\t\t\t\t\ti++;\n\t\t\t\t\t\t\t\t\t} while (uu < uuE);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} while ((mask >>= 1) > 0);\n\t\t\t\t\tmask = 0x80000000;\n\t\t\t\t} while (wPos-- > 0);\n\n\t\t\t\treturn resultNum;\n\t\t\t}\n\n\t\t\tprivate unsafe BigInteger OddModTwoPow (BigInteger exp)\n\t\t\t{\n\n\t\t\t\tuint [] wkspace = new uint [mod.length << 1 + 1];\n\n\t\t\t\tBigInteger resultNum = Montgomery.ToMont ((BigInteger)2, this.mod);\n\t\t\t\tresultNum = new BigInteger (resultNum, mod.length << 1 +1);\n\n\t\t\t\tuint mPrime = Montgomery.Inverse (mod.data [0]);\n\n\t\t\t\t//\n\t\t\t\t// TODO: eat small bits, the ones we can do with no modular reduction\n\t\t\t\t//\n\t\t\t\tuint pos = (uint)exp.BitCount () - 2;\n\n\t\t\t\tdo {\n\t\t\t\t\tKernel.SquarePositive (resultNum, ref wkspace);\n\t\t\t\t\tresultNum = Montgomery.Reduce (resultNum, mod, mPrime);\n\n\t\t\t\t\tif (exp.TestBit (pos)) {\n\t\t\t\t\t\t//\n\t\t\t\t\t\t// resultNum = (resultNum * 2) % mod\n\t\t\t\t\t\t//\n\n\t\t\t\t\t\tfixed (uint* u = resultNum.data) {\n\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t// Double\n\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\tuint* uu = u;\n\t\t\t\t\t\t\tuint* uuE = u + resultNum.length;\n\t\t\t\t\t\t\tuint x, carry = 0;\n\t\t\t\t\t\t\twhile (uu < uuE) {\n\t\t\t\t\t\t\t\tx = *uu;\n\t\t\t\t\t\t\t\t*uu = (x << 1) | carry;\n\t\t\t\t\t\t\t\tcarry = x >> (32 - 1);\n\t\t\t\t\t\t\t\tuu++;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// subtraction inlined because we know it is square\n\t\t\t\t\t\t\tif (carry != 0 || resultNum >= mod) {\n\t\t\t\t\t\t\t\tfixed (uint* s = mod.data) {\n\t\t\t\t\t\t\t\t\tuu = u;\n\t\t\t\t\t\t\t\t\tuint c = 0;\n\t\t\t\t\t\t\t\t\tuint* ss = s;\n\t\t\t\t\t\t\t\t\tdo {\n\t\t\t\t\t\t\t\t\t\tuint a = *ss++;\n\t\t\t\t\t\t\t\t\t\tif (((a += c) < c) | ((* (uu++) -= a) > ~a))\n\t\t\t\t\t\t\t\t\t\t\tc = 1;\n\t\t\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\t\t\tc = 0;\n\t\t\t\t\t\t\t\t\t} while (uu < uuE);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} while (pos-- > 0);\n\n\t\t\t\tresultNum = Montgomery.Reduce (resultNum, mod, mPrime);\n\t\t\t\treturn resultNum;\n\t\t\t}\n#endif\n\t\t\t#endregion\n\t\t}\n\n\t\t/// <summary>\n\t\t/// Low level functions for the BigInteger\n\t\t/// </summary>\n\t\tprivate sealed class Kernel {\n\n\t\t\t#region Addition/Subtraction\n\n\t\t\t/// <summary>\n\t\t\t/// Adds two numbers with the same sign.\n\t\t\t/// </summary>\n\t\t\t/// <param name="bi1">A BigInteger</param>\n\t\t\t/// <param name="bi2">A BigInteger</param>\n\t\t\t/// <returns>bi1 + bi2</returns>\n\t\t\tpublic static BigInteger AddSameSign(BigInteger bi1, BigInteger bi2) {\n\t\t\t\tuint[] x, y;\n\t\t\t\tuint yMax, xMax, i = 0;\n\n\t\t\t\t// x should be bigger\n\t\t\t\tif (bi1.length < bi2.length) {\n\t\t\t\t\tx = bi2.data;\n\t\t\t\t\txMax = bi2.length;\n\t\t\t\t\ty = bi1.data;\n\t\t\t\t\tyMax = bi1.length;\n\t\t\t\t} else {\n\t\t\t\t\tx = bi1.data;\n\t\t\t\t\txMax = bi1.length;\n\t\t\t\t\ty = bi2.data;\n\t\t\t\t\tyMax = bi2.length;\n\t\t\t\t}\n\n\t\t\t\tBigInteger result = new BigInteger(Sign.Positive, xMax + 1);\n\n\t\t\t\tuint[] r = result.data;\n\n\t\t\t\tulong sum = 0;\n\n\t\t\t\t// Add common parts of both numbers\n\t\t\t\tdo {\n\t\t\t\t\tsum = ((ulong)x[i]) + ((ulong)y[i]) + sum;\n\t\t\t\t\tr[i] = (uint)sum;\n\t\t\t\t\tsum >>= 32;\n\t\t\t\t} while (++i < yMax);\n\n\t\t\t\t// Copy remainder of longer number while carry propagation is required\n\t\t\t\tbool carry = (sum != 0);\n\n\t\t\t\tif (carry) {\n\n\t\t\t\t\tif (i < xMax) {\n\t\t\t\t\t\tdo\n\t\t\t\t\t\t\tcarry = ((r[i] = x[i] + 1) == 0);\n\t\t\t\t\t\twhile (++i < xMax && carry);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (carry) {\n\t\t\t\t\t\tr[i] = 1;\n\t\t\t\t\t\tresult.length = ++i;\n\t\t\t\t\t\treturn result;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Copy the rest\n\t\t\t\tif (i < xMax) {\n\t\t\t\t\tdo\n\t\t\t\t\t\tr[i] = x[i];\n\t\t\t\t\twhile (++i < xMax);\n\t\t\t\t}\n\n\t\t\t\tresult.Normalize();\n\t\t\t\treturn result;\n\t\t\t}\n\n\t\t\tpublic static BigInteger Subtract(BigInteger big, BigInteger small) {\n\t\t\t\tBigInteger result = new BigInteger(Sign.Positive, big.length);\n\n\t\t\t\tuint[] r = result.data, b = big.data, s = small.data;\n\t\t\t\tuint i = 0, c = 0;\n\n\t\t\t\tdo {\n\n\t\t\t\t\tuint x = s[i];\n\t\t\t\t\tif (((x += c) < c) | ((r[i] = b[i] - x) > ~x))\n\t\t\t\t\t\tc = 1;\n\t\t\t\t\telse\n\t\t\t\t\t\tc = 0;\n\n\t\t\t\t} while (++i < small.length);\n\n\t\t\t\tif (i == big.length) goto fixup;\n\n\t\t\t\tif (c == 1) {\n\t\t\t\t\tdo\n\t\t\t\t\t\tr[i] = b[i] - 1;\n\t\t\t\t\twhile (b[i++] == 0 && i < big.length);\n\n\t\t\t\t\tif (i == big.length) goto fixup;\n\t\t\t\t}\n\n\t\t\t\tdo\n\t\t\t\t\tr[i] = b[i];\n\t\t\t\twhile (++i < big.length);\n\n\t\t\tfixup:\n\n\t\t\t\tresult.Normalize();\n\t\t\t\treturn result;\n\t\t\t}\n\n\t\t\tpublic static void MinusEq(BigInteger big, BigInteger small) {\n\t\t\t\tuint[] b = big.data, s = small.data;\n\t\t\t\tuint i = 0, c = 0;\n\n\t\t\t\tdo {\n\t\t\t\t\tuint x = s[i];\n\t\t\t\t\tif (((x += c) < c) | ((b[i] -= x) > ~x))\n\t\t\t\t\t\tc = 1;\n\t\t\t\t\telse\n\t\t\t\t\t\tc = 0;\n\t\t\t\t} while (++i < small.length);\n\n\t\t\t\tif (i == big.length) goto fixup;\n\n\t\t\t\tif (c == 1) {\n\t\t\t\t\tdo\n\t\t\t\t\t\tb[i]--;\n\t\t\t\t\twhile (b[i++] == 0 && i < big.length);\n\t\t\t\t}\n\n\t\t\tfixup:\n\n\t\t\t\t// Normalize length\n\t\t\t\twhile (big.length > 0 && big.data[big.length - 1] == 0) big.length--;\n\n\t\t\t\t// Check for zero\n\t\t\t\tif (big.length == 0)\n\t\t\t\t\tbig.length++;\n\n\t\t\t}\n\n\t\t\tpublic static void PlusEq(BigInteger bi1, BigInteger bi2) {\n\t\t\t\tuint[] x, y;\n\t\t\t\tuint yMax, xMax, i = 0;\n\t\t\t\tbool flag = false;\n\n\t\t\t\t// x should be bigger\n\t\t\t\tif (bi1.length < bi2.length) {\n\t\t\t\t\tflag = true;\n\t\t\t\t\tx = bi2.data;\n\t\t\t\t\txMax = bi2.length;\n\t\t\t\t\ty = bi1.data;\n\t\t\t\t\tyMax = bi1.length;\n\t\t\t\t} else {\n\t\t\t\t\tx = bi1.data;\n\t\t\t\t\txMax = bi1.length;\n\t\t\t\t\ty = bi2.data;\n\t\t\t\t\tyMax = bi2.length;\n\t\t\t\t}\n\n\t\t\t\tuint[] r = bi1.data;\n\n\t\t\t\tulong sum = 0;\n\n\t\t\t\t// Add common parts of both numbers\n\t\t\t\tdo {\n\t\t\t\t\tsum += ((ulong)x[i]) + ((ulong)y[i]);\n\t\t\t\t\tr[i] = (uint)sum;\n\t\t\t\t\tsum >>= 32;\n\t\t\t\t} while (++i < yMax);\n\n\t\t\t\t// Copy remainder of longer number while carry propagation is required\n\t\t\t\tbool carry = (sum != 0);\n\n\t\t\t\tif (carry) {\n\n\t\t\t\t\tif (i < xMax) {\n\t\t\t\t\t\tdo\n\t\t\t\t\t\t\tcarry = ((r[i] = x[i] + 1) == 0);\n\t\t\t\t\t\twhile (++i < xMax && carry);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (carry) {\n\t\t\t\t\t\tr[i] = 1;\n\t\t\t\t\t\tbi1.length = ++i;\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Copy the rest\n\t\t\t\tif (flag && i < xMax - 1) {\n\t\t\t\t\tdo\n\t\t\t\t\t\tr[i] = x[i];\n\t\t\t\t\twhile (++i < xMax);\n\t\t\t\t}\n\n\t\t\t\tbi1.length = xMax + 1;\n\t\t\t\tbi1.Normalize();\n\t\t\t}\n\n\t\t\t#endregion\n\n\t\t\t#region Compare\n\n\t\t\t/// <summary>\n\t\t\t/// Compares two BigInteger\n\t\t\t/// </summary>\n\t\t\t/// <param name="bi1">A BigInteger</param>\n\t\t\t/// <param name="bi2">A BigInteger</param>\n\t\t\t/// <returns>The sign of bi1 - bi2</returns>\n\t\t\tpublic static Sign Compare(BigInteger bi1, BigInteger bi2) {\n\t\t\t\t//\n\t\t\t\t// Step 1. Compare the lengths\n\t\t\t\t//\n\t\t\t\tuint l1 = bi1.length, l2 = bi2.length;\n\n\t\t\t\twhile (l1 > 0 && bi1.data[l1 - 1] == 0) l1--;\n\t\t\t\twhile (l2 > 0 && bi2.data[l2 - 1] == 0) l2--;\n\n\t\t\t\tif (l1 == 0 && l2 == 0) return Sign.Zero;\n\n\t\t\t\t// bi1 len < bi2 len\n\t\t\t\tif (l1 < l2) return Sign.Negative;\n\t\t\t\t// bi1 len > bi2 len\n\t\t\t\telse if (l1 > l2) return Sign.Positive;\n\n\t\t\t\t//\n\t\t\t\t// Step 2. Compare the bits\n\t\t\t\t//\n\n\t\t\t\tuint pos = l1 - 1;\n\n\t\t\t\twhile (pos != 0 && bi1.data[pos] == bi2.data[pos]) pos--;\n\n\t\t\t\tif (bi1.data[pos] < bi2.data[pos])\n\t\t\t\t\treturn Sign.Negative;\n\t\t\t\telse if (bi1.data[pos] > bi2.data[pos])\n\t\t\t\t\treturn Sign.Positive;\n\t\t\t\telse\n\t\t\t\t\treturn Sign.Zero;\n\t\t\t}\n\n\t\t\t#endregion\n\n\t\t\t#region Division\n\n\t\t\t#region Dword\n\n\t\t\t/// <summary>\n\t\t\t/// Performs n / d and n % d in one operation.\n\t\t\t/// </summary>\n\t\t\t/// <param name="n">A BigInteger, upon exit this will hold n / d</param>\n\t\t\t/// <param name="d">The divisor</param>\n\t\t\t/// <returns>n % d</returns>\n\t\t\tpublic static uint SingleByteDivideInPlace(BigInteger n, uint d) {\n\t\t\t\tulong r = 0;\n\t\t\t\tuint i = n.length;\n\n\t\t\t\twhile (i-- > 0) {\n\t\t\t\t\tr <<= 32;\n\t\t\t\t\tr |= n.data[i];\n\t\t\t\t\tn.data[i] = (uint)(r / d);\n\t\t\t\t\tr %= d;\n\t\t\t\t}\n\t\t\t\tn.Normalize();\n\n\t\t\t\treturn (uint)r;\n\t\t\t}\n\n\t\t\tpublic static uint DwordMod(BigInteger n, uint d) {\n\t\t\t\tulong r = 0;\n\t\t\t\tuint i = n.length;\n\n\t\t\t\twhile (i-- > 0) {\n\t\t\t\t\tr <<= 32;\n\t\t\t\t\tr |= n.data[i];\n\t\t\t\t\tr %= d;\n\t\t\t\t}\n\n\t\t\t\treturn (uint)r;\n\t\t\t}\n\n\t\t\tpublic static BigInteger DwordDiv(BigInteger n, uint d) {\n\t\t\t\tBigInteger ret = new BigInteger(Sign.Positive, n.length);\n\n\t\t\t\tulong r = 0;\n\t\t\t\tuint i = n.length;\n\n\t\t\t\twhile (i-- > 0) {\n\t\t\t\t\tr <<= 32;\n\t\t\t\t\tr |= n.data[i];\n\t\t\t\t\tret.data[i] = (uint)(r / d);\n\t\t\t\t\tr %= d;\n\t\t\t\t}\n\t\t\t\tret.Normalize();\n\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\tpublic static BigInteger[] DwordDivMod(BigInteger n, uint d) {\n\t\t\t\tBigInteger ret = new BigInteger(Sign.Positive, n.length);\n\n\t\t\t\tulong r = 0;\n\t\t\t\tuint i = n.length;\n\n\t\t\t\twhile (i-- > 0) {\n\t\t\t\t\tr <<= 32;\n\t\t\t\t\tr |= n.data[i];\n\t\t\t\t\tret.data[i] = (uint)(r / d);\n\t\t\t\t\tr %= d;\n\t\t\t\t}\n\t\t\t\tret.Normalize();\n\n\t\t\t\tBigInteger rem = (uint)r;\n\n\t\t\t\treturn new BigInteger[] { ret, rem };\n\t\t\t}\n\n\t\t\t#endregion\n\n\t\t\t#region BigNum\n\n\t\t\tpublic static BigInteger[] multiByteDivide(BigInteger bi1, BigInteger bi2) {\n\t\t\t\tif (Kernel.Compare(bi1, bi2) == Sign.Negative)\n\t\t\t\t\treturn new BigInteger[2] { 0, new BigInteger(bi1) };\n\n\t\t\t\tbi1.Normalize(); bi2.Normalize();\n\n\t\t\t\tif (bi2.length == 1)\n\t\t\t\t\treturn DwordDivMod(bi1, bi2.data[0]);\n\n\t\t\t\tuint remainderLen = bi1.length + 1;\n\t\t\t\tint divisorLen = (int)bi2.length + 1;\n\n\t\t\t\tuint mask = 0x80000000;\n\t\t\t\tuint val = bi2.data[bi2.length - 1];\n\t\t\t\tint shift = 0;\n\t\t\t\tint resultPos = (int)bi1.length - (int)bi2.length;\n\n\t\t\t\twhile (mask != 0 && (val & mask) == 0) {\n\t\t\t\t\tshift++; mask >>= 1;\n\t\t\t\t}\n\n\t\t\t\tBigInteger quot = new BigInteger(Sign.Positive, bi1.length - bi2.length + 1);\n\t\t\t\tBigInteger rem = (bi1 << shift);\n\n\t\t\t\tuint[] remainder = rem.data;\n\n\t\t\t\tbi2 = bi2 << shift;\n\n\t\t\t\tint j = (int)(remainderLen - bi2.length);\n\t\t\t\tint pos = (int)remainderLen - 1;\n\n\t\t\t\tuint firstDivisorByte = bi2.data[bi2.length - 1];\n\t\t\t\tulong secondDivisorByte = bi2.data[bi2.length - 2];\n\n\t\t\t\twhile (j > 0) {\n\t\t\t\t\tulong dividend = ((ulong)remainder[pos] << 32) + (ulong)remainder[pos - 1];\n\n\t\t\t\t\tulong q_hat = dividend / (ulong)firstDivisorByte;\n\t\t\t\t\tulong r_hat = dividend % (ulong)firstDivisorByte;\n\n\t\t\t\t\tdo {\n\n\t\t\t\t\t\tif (q_hat == 0x100000000 ||\n\t\t\t\t\t\t\t(q_hat * secondDivisorByte) > ((r_hat << 32) + remainder[pos - 2])) {\n\t\t\t\t\t\t\tq_hat--;\n\t\t\t\t\t\t\tr_hat += (ulong)firstDivisorByte;\n\n\t\t\t\t\t\t\tif (r_hat < 0x100000000)\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} while (true);\n\n\t\t\t\t\t//\n\t\t\t\t\t// At this point, q_hat is either exact, or one too large\n\t\t\t\t\t// (more likely to be exact) so, we attempt to multiply the\n\t\t\t\t\t// divisor by q_hat, if we get a borrow, we just subtract\n\t\t\t\t\t// one from q_hat and add the divisor back.\n\t\t\t\t\t//\n\n\t\t\t\t\tuint t;\n\t\t\t\t\tuint dPos = 0;\n\t\t\t\t\tint nPos = pos - divisorLen + 1;\n\t\t\t\t\tulong mc = 0;\n\t\t\t\t\tuint uint_q_hat = (uint)q_hat;\n\t\t\t\t\tdo {\n\t\t\t\t\t\tmc += (ulong)bi2.data[dPos] * (ulong)uint_q_hat;\n\t\t\t\t\t\tt = remainder[nPos];\n\t\t\t\t\t\tremainder[nPos] -= (uint)mc;\n\t\t\t\t\t\tmc >>= 32;\n\t\t\t\t\t\tif (remainder[nPos] > t) mc++;\n\t\t\t\t\t\tdPos++; nPos++;\n\t\t\t\t\t} while (dPos < divisorLen);\n\n\t\t\t\t\tnPos = pos - divisorLen + 1;\n\t\t\t\t\tdPos = 0;\n\n\t\t\t\t\t// Overestimate\n\t\t\t\t\tif (mc != 0) {\n\t\t\t\t\t\tuint_q_hat--;\n\t\t\t\t\t\tulong sum = 0;\n\n\t\t\t\t\t\tdo {\n\t\t\t\t\t\t\tsum = ((ulong)remainder[nPos]) + ((ulong)bi2.data[dPos]) + sum;\n\t\t\t\t\t\t\tremainder[nPos] = (uint)sum;\n\t\t\t\t\t\t\tsum >>= 32;\n\t\t\t\t\t\t\tdPos++; nPos++;\n\t\t\t\t\t\t} while (dPos < divisorLen);\n\n\t\t\t\t\t}\n\n\t\t\t\t\tquot.data[resultPos--] = (uint)uint_q_hat;\n\n\t\t\t\t\tpos--;\n\t\t\t\t\tj--;\n\t\t\t\t}\n\n\t\t\t\tquot.Normalize();\n\t\t\t\trem.Normalize();\n\t\t\t\tBigInteger[] ret = new BigInteger[2] { quot, rem };\n\n\t\t\t\tif (shift != 0)\n\t\t\t\t\tret[1] >>= shift;\n\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\t#endregion\n\n\t\t\t#endregion\n\n\t\t\t#region Shift\n\t\t\tpublic static BigInteger LeftShift(BigInteger bi, int n) {\n\t\t\t\tif (n == 0) return new BigInteger(bi, bi.length + 1);\n\n\t\t\t\tint w = n >> 5;\n\t\t\t\tn &= ((1 << 5) - 1);\n\n\t\t\t\tBigInteger ret = new BigInteger(Sign.Positive, bi.length + 1 + (uint)w);\n\n\t\t\t\tuint i = 0, l = bi.length;\n\t\t\t\tif (n != 0) {\n\t\t\t\t\tuint x, carry = 0;\n\t\t\t\t\twhile (i < l) {\n\t\t\t\t\t\tx = bi.data[i];\n\t\t\t\t\t\tret.data[i + w] = (x << n) | carry;\n\t\t\t\t\t\tcarry = x >> (32 - n);\n\t\t\t\t\t\ti++;\n\t\t\t\t\t}\n\t\t\t\t\tret.data[i + w] = carry;\n\t\t\t\t} else {\n\t\t\t\t\twhile (i < l) {\n\t\t\t\t\t\tret.data[i + w] = bi.data[i];\n\t\t\t\t\t\ti++;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tret.Normalize();\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\tpublic static BigInteger RightShift(BigInteger bi, int n) {\n\t\t\t\tif (n == 0) return new BigInteger(bi);\n\n\t\t\t\tint w = n >> 5;\n\t\t\t\tint s = n & ((1 << 5) - 1);\n\n\t\t\t\tBigInteger ret = new BigInteger(Sign.Positive, bi.length - (uint)w + 1);\n\t\t\t\tuint l = (uint)ret.data.Length - 1;\n\n\t\t\t\tif (s != 0) {\n\n\t\t\t\t\tuint x, carry = 0;\n\n\t\t\t\t\twhile (l-- > 0) {\n\t\t\t\t\t\tx = bi.data[l + w];\n\t\t\t\t\t\tret.data[l] = (x >> n) | carry;\n\t\t\t\t\t\tcarry = x << (32 - n);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\twhile (l-- > 0)\n\t\t\t\t\t\tret.data[l] = bi.data[l + w];\n\n\t\t\t\t}\n\t\t\t\tret.Normalize();\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\t#endregion\n\n\t\t\t#region Multiply\n\n\t\t\tpublic static BigInteger MultiplyByDword(BigInteger n, uint f) {\n\t\t\t\tBigInteger ret = new BigInteger(Sign.Positive, n.length + 1);\n\n\t\t\t\tuint i = 0;\n\t\t\t\tulong c = 0;\n\n\t\t\t\tdo {\n\t\t\t\t\tc += (ulong)n.data[i] * (ulong)f;\n\t\t\t\t\tret.data[i] = (uint)c;\n\t\t\t\t\tc >>= 32;\n\t\t\t\t} while (++i < n.length);\n\t\t\t\tret.data[i] = (uint)c;\n\t\t\t\tret.Normalize();\n\t\t\t\treturn ret;\n\n\t\t\t}\n\n\t\t\t/// <summary>\n\t\t\t/// Multiplies the data in x [xOffset:xOffset+xLen] by\n\t\t\t/// y [yOffset:yOffset+yLen] and puts it into\n\t\t\t/// d [dOffset:dOffset+xLen+yLen].\n\t\t\t/// </summary>\n\t\t\t/// <remarks>\n\t\t\t/// This code is unsafe! It is the caller\'s responsibility to make\n\t\t\t/// sure that it is safe to access x [xOffset:xOffset+xLen],\n\t\t\t/// y [yOffset:yOffset+yLen], and d [dOffset:dOffset+xLen+yLen].\n\t\t\t/// </remarks>\n\t\t\tpublic static unsafe void Multiply(uint[] x, uint xOffset, uint xLen, uint[] y, uint yOffset, uint yLen, uint[] d, uint dOffset) {\n\t\t\t\tfixed (uint* xx = x, yy = y, dd = d) {\n\t\t\t\t\tuint* xP = xx + xOffset,\n\t\t\t\t\t\txE = xP + xLen,\n\t\t\t\t\t\tyB = yy + yOffset,\n\t\t\t\t\t\tyE = yB + yLen,\n\t\t\t\t\t\tdB = dd + dOffset;\n\n\t\t\t\t\tfor (; xP < xE; xP++, dB++) {\n\n\t\t\t\t\t\tif (*xP == 0) continue;\n\n\t\t\t\t\t\tulong mcarry = 0;\n\n\t\t\t\t\t\tuint* dP = dB;\n\t\t\t\t\t\tfor (uint* yP = yB; yP < yE; yP++, dP++) {\n\t\t\t\t\t\t\tmcarry += ((ulong)*xP * (ulong)*yP) + (ulong)*dP;\n\n\t\t\t\t\t\t\t*dP = (uint)mcarry;\n\t\t\t\t\t\t\tmcarry >>= 32;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (mcarry != 0)\n\t\t\t\t\t\t\t*dP = (uint)mcarry;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/// <summary>\n\t\t\t/// Multiplies the data in x [xOffset:xOffset+xLen] by\n\t\t\t/// y [yOffset:yOffset+yLen] and puts the low mod words into\n\t\t\t/// d [dOffset:dOffset+mod].\n\t\t\t/// </summary>\n\t\t\t/// <remarks>\n\t\t\t/// This code is unsafe! It is the caller\'s responsibility to make\n\t\t\t/// sure that it is safe to access x [xOffset:xOffset+xLen],\n\t\t\t/// y [yOffset:yOffset+yLen], and d [dOffset:dOffset+mod].\n\t\t\t/// </remarks>\n\t\t\tpublic static unsafe void MultiplyMod2p32pmod(uint[] x, int xOffset, int xLen, uint[] y, int yOffest, int yLen, uint[] d, int dOffset, int mod) {\n\t\t\t\tfixed (uint* xx = x, yy = y, dd = d) {\n\t\t\t\t\tuint* xP = xx + xOffset,\n\t\t\t\t\t\txE = xP + xLen,\n\t\t\t\t\t\tyB = yy + yOffest,\n\t\t\t\t\t\tyE = yB + yLen,\n\t\t\t\t\t\tdB = dd + dOffset,\n\t\t\t\t\t\tdE = dB + mod;\n\n\t\t\t\t\tfor (; xP < xE; xP++, dB++) {\n\n\t\t\t\t\t\tif (*xP == 0) continue;\n\n\t\t\t\t\t\tulong mcarry = 0;\n\t\t\t\t\t\tuint* dP = dB;\n\t\t\t\t\t\tfor (uint* yP = yB; yP < yE && dP < dE; yP++, dP++) {\n\t\t\t\t\t\t\tmcarry += ((ulong)*xP * (ulong)*yP) + (ulong)*dP;\n\n\t\t\t\t\t\t\t*dP = (uint)mcarry;\n\t\t\t\t\t\t\tmcarry >>= 32;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (mcarry != 0 && dP < dE)\n\t\t\t\t\t\t\t*dP = (uint)mcarry;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tpublic static unsafe void SquarePositive(BigInteger bi, ref uint[] wkSpace) {\n\t\t\t\tuint[] t = wkSpace;\n\t\t\t\twkSpace = bi.data;\n\t\t\t\tuint[] d = bi.data;\n\t\t\t\tuint dl = bi.length;\n\t\t\t\tbi.data = t;\n\n\t\t\t\tfixed (uint* dd = d, tt = t) {\n\n\t\t\t\t\tuint* ttE = tt + t.Length;\n\t\t\t\t\t// Clear the dest\n\t\t\t\t\tfor (uint* ttt = tt; ttt < ttE; ttt++)\n\t\t\t\t\t\t*ttt = 0;\n\n\t\t\t\t\tuint* dP = dd, tP = tt;\n\n\t\t\t\t\tfor (uint i = 0; i < dl; i++, dP++) {\n\t\t\t\t\t\tif (*dP == 0)\n\t\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t\tulong mcarry = 0;\n\t\t\t\t\t\tuint bi1val = *dP;\n\n\t\t\t\t\t\tuint* dP2 = dP + 1, tP2 = tP + 2 * i + 1;\n\n\t\t\t\t\t\tfor (uint j = i + 1; j < dl; j++, tP2++, dP2++) {\n\t\t\t\t\t\t\t// k = i + j\n\t\t\t\t\t\t\tmcarry += ((ulong)bi1val * (ulong)*dP2) + *tP2;\n\n\t\t\t\t\t\t\t*tP2 = (uint)mcarry;\n\t\t\t\t\t\t\tmcarry >>= 32;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (mcarry != 0)\n\t\t\t\t\t\t\t*tP2 = (uint)mcarry;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Double t. Inlined for speed.\n\n\t\t\t\t\ttP = tt;\n\n\t\t\t\t\tuint x, carry = 0;\n\t\t\t\t\twhile (tP < ttE) {\n\t\t\t\t\t\tx = *tP;\n\t\t\t\t\t\t*tP = (x << 1) | carry;\n\t\t\t\t\t\tcarry = x >> (32 - 1);\n\t\t\t\t\t\ttP++;\n\t\t\t\t\t}\n\t\t\t\t\tif (carry != 0) *tP = carry;\n\n\t\t\t\t\t// Add in the diagnals\n\n\t\t\t\t\tdP = dd;\n\t\t\t\t\ttP = tt;\n\t\t\t\t\tfor (uint* dE = dP + dl; (dP < dE); dP++, tP++) {\n\t\t\t\t\t\tulong val = (ulong)*dP * (ulong)*dP + *tP;\n\t\t\t\t\t\t*tP = (uint)val;\n\t\t\t\t\t\tval >>= 32;\n\t\t\t\t\t\t*(++tP) += (uint)val;\n\t\t\t\t\t\tif (*tP < (uint)val) {\n\t\t\t\t\t\t\tuint* tP3 = tP;\n\t\t\t\t\t\t\t// Account for the first carry\n\t\t\t\t\t\t\t(*++tP3)++;\n\n\t\t\t\t\t\t\t// Keep adding until no carry\n\t\t\t\t\t\t\twhile ((*tP3++) == 0)\n\t\t\t\t\t\t\t\t(*tP3)++;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbi.length <<= 1;\n\n\t\t\t\t\t// Normalize length\n\t\t\t\t\twhile (tt[bi.length - 1] == 0 && bi.length > 1) bi.length--;\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* \n\t\t\t * Never called in BigInteger (and part of a private class)\n\t\t\t * \t\t\tpublic static bool Double (uint [] u, int l)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tuint x, carry = 0;\n\t\t\t\t\t\t\tuint i = 0;\n\t\t\t\t\t\t\twhile (i < l) {\n\t\t\t\t\t\t\t\tx = u [i];\n\t\t\t\t\t\t\t\tu [i] = (x << 1) | carry;\n\t\t\t\t\t\t\t\tcarry = x >> (32 - 1);\n\t\t\t\t\t\t\t\ti++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (carry != 0) u [l] = carry;\n\t\t\t\t\t\t\treturn carry != 0;\n\t\t\t\t\t\t}*/\n\n\t\t\t#endregion\n\n\t\t\t#region Number Theory\n\n\t\t\tpublic static BigInteger gcd(BigInteger a, BigInteger b) {\n\t\t\t\tBigInteger x = a;\n\t\t\t\tBigInteger y = b;\n\n\t\t\t\tBigInteger g = y;\n\n\t\t\t\twhile (x.length > 1) {\n\t\t\t\t\tg = x;\n\t\t\t\t\tx = y % x;\n\t\t\t\t\ty = g;\n\n\t\t\t\t}\n\t\t\t\tif (x == 0) return g;\n\n\t\t\t\t// TODO: should we have something here if we can convert to long?\n\n\t\t\t\t//\n\t\t\t\t// Now we can just do it with single precision. I am using the binary gcd method,\n\t\t\t\t// as it should be faster.\n\t\t\t\t//\n\n\t\t\t\tuint yy = x.data[0];\n\t\t\t\tuint xx = y % yy;\n\n\t\t\t\tint t = 0;\n\n\t\t\t\twhile (((xx | yy) & 1) == 0) {\n\t\t\t\t\txx >>= 1; yy >>= 1; t++;\n\t\t\t\t}\n\t\t\t\twhile (xx != 0) {\n\t\t\t\t\twhile ((xx & 1) == 0) xx >>= 1;\n\t\t\t\t\twhile ((yy & 1) == 0) yy >>= 1;\n\t\t\t\t\tif (xx >= yy)\n\t\t\t\t\t\txx = (xx - yy) >> 1;\n\t\t\t\t\telse\n\t\t\t\t\t\tyy = (yy - xx) >> 1;\n\t\t\t\t}\n\n\t\t\t\treturn yy << t;\n\t\t\t}\n\n\t\t\tpublic static uint modInverse(BigInteger bi, uint modulus) {\n\t\t\t\tuint a = modulus, b = bi % modulus;\n\t\t\t\tuint p0 = 0, p1 = 1;\n\n\t\t\t\twhile (b != 0) {\n\t\t\t\t\tif (b == 1)\n\t\t\t\t\t\treturn p1;\n\t\t\t\t\tp0 += (a / b) * p1;\n\t\t\t\t\ta %= b;\n\n\t\t\t\t\tif (a == 0)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tif (a == 1)\n\t\t\t\t\t\treturn modulus - p0;\n\n\t\t\t\t\tp1 += (b / a) * p0;\n\t\t\t\t\tb %= a;\n\n\t\t\t\t}\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tpublic static BigInteger modInverse(BigInteger bi, BigInteger modulus) {\n\t\t\t\tif (modulus.length == 1) return modInverse(bi, modulus.data[0]);\n\n\t\t\t\tBigInteger[] p = { 0, 1 };\n\t\t\t\tBigInteger[] q = new BigInteger[2];    // quotients\n\t\t\t\tBigInteger[] r = { 0, 0 };             // remainders\n\n\t\t\t\tint step = 0;\n\n\t\t\t\tBigInteger a = modulus;\n\t\t\t\tBigInteger b = bi;\n\n\t\t\t\tModulusRing mr = new ModulusRing(modulus);\n\n\t\t\t\twhile (b != 0) {\n\n\t\t\t\t\tif (step > 1) {\n\n\t\t\t\t\t\tBigInteger pval = mr.Difference(p[0], p[1] * q[0]);\n\t\t\t\t\t\tp[0] = p[1]; p[1] = pval;\n\t\t\t\t\t}\n\n\t\t\t\t\tBigInteger[] divret = multiByteDivide(a, b);\n\n\t\t\t\t\tq[0] = q[1]; q[1] = divret[0];\n\t\t\t\t\tr[0] = r[1]; r[1] = divret[1];\n\t\t\t\t\ta = b;\n\t\t\t\t\tb = divret[1];\n\n\t\t\t\t\tstep++;\n\t\t\t\t}\n\n\t\t\t\tif (r[0] != 1)\n\t\t\t\t\tthrow (new ArithmeticException("No inverse!"));\n\n\t\t\t\treturn mr.Difference(p[0], p[1] * q[0]);\n\n\t\t\t}\n\t\t\t#endregion\n\t\t}\n\t}\n}'