b'{-# LANGUAGE Arrows     #-}\n{-# LANGUAGE CPP        #-}\n{-# LANGUAGE RankNTypes #-}\n-- The following warning is disabled so that we do not see warnings due to\n-- using ListT on an MSF to implement parallelism with broadcasting.\n#if __GLASGOW_HASKELL__ < 800\n{-# OPTIONS_GHC -fno-warn-warnings-deprecations #-}\n#else\n{-# OPTIONS_GHC -Wno-deprecations #-}\n#endif\n{-# OPTIONS_HADDOCK ignore-exports #-}\n-- |\n-- Copyright  : (c) Ivan Perez, 2019-2022\n--              (c) Ivan Perez and Manuel Baerenz, 2016-2018\n-- License    : BSD3\n-- Maintainer : ivan.perez@keera.co.uk\n--\n-- Implementation of Yampa using Monadic Stream Processing library.\nmodule FRP.BearRiver\n    (module FRP.BearRiver, module X)\n  where\n\n-- External imports\n#if !MIN_VERSION_base(4,8,0)\nimport           Control.Applicative       (Applicative (..), (<$>))\n#endif\nimport           Control.Applicative       (Alternative (..))\nimport           Control.Arrow             as X\nimport qualified Control.Category          as Category\nimport           Control.DeepSeq           (NFData (..))\nimport qualified Control.Monad.Fail        as Fail\nimport           Control.Monad.Random      (MonadRandom)\nimport           Data.Functor.Identity     (Identity (..))\nimport           Data.Maybe                (fromMaybe)\nimport           Data.Traversable          as T\nimport           Data.VectorSpace          as X\n\n-- Internal imports (dunai)\nimport           Control.Monad.Trans.MSF                 hiding (dSwitch,\n                                                          switch)\nimport qualified Control.Monad.Trans.MSF                 as MSF\nimport           Control.Monad.Trans.MSF.List            (sequenceS, widthFirst)\nimport           Data.MonadicStreamFunction              (iPre)\nimport           Data.MonadicStreamFunction              as X hiding\n                                                              (reactimate,\n                                                               repeatedly,\n                                                               trace)\nimport           Data.MonadicStreamFunction.InternalCore (MSF (MSF, unMSF))\nimport           FRP.BearRiver.Arrow                     as X\n\n-- Internal imports (dunai, instances)\nimport Data.MonadicStreamFunction.Instances.ArrowLoop () -- not needed, just\n                                                         -- re-exported\n\ninfixr 0 -->, -:>, >--, >=-\n\n-- * Basic definitions\n\n-- | Time is used both for time intervals (duration), and time w.r.t. some\n-- agreed reference point in time.\ntype Time = Double\n\n-- | DTime is the time type for lengths of sample intervals. Conceptually,\n-- DTime = R+ = { x in R | x > 0 }. Don\'t assume Time and DTime have the same\n-- representation.\ntype DTime = Double\n\n-- | Extensible signal function (signal function with a notion of time, but\n-- which can be extended with actions).\n--\n-- Signal function that transforms a signal carrying values of some type \'a\'\n-- into a signal carrying values of some type \'b\'. You can think of it as\n-- (Signal a -> Signal b). A signal is, conceptually, a function from \'Time\' to\n-- value.\ntype SF m = MSF (ClockInfo m)\n\n-- | Information on the progress of time.\ntype ClockInfo m = ReaderT DTime m\n\n-- | A single possible event occurrence, that is, a value that may or may not\n-- occur. Events are used to represent values that are not produced\n-- continuously, such as mouse clicks (only produced when the mouse is clicked,\n-- as opposed to mouse positions, which are always defined).\ndata Event a = Event a | NoEvent\n  deriving (Eq, Ord, Show)\n\n-- | The type \'Event\' is isomorphic to \'Maybe\'. The \'Functor\' instance of\n-- \'Event\' is analogous to the \'Functor\' instance of \'Maybe\', where the given\n-- function is applied to the value inside the \'Event\', if any.\ninstance Functor Event where\n  fmap _ NoEvent   = NoEvent\n  fmap f (Event c) = Event (f c)\n\n-- | The type \'Event\' is isomorphic to \'Maybe\'. The \'Applicative\' instance of\n-- \'Event\' is analogous to the \'Applicative\' instance of \'Maybe\', where the\n-- lack of a value (i.e., \'NoEvent\') causes \'(<*>)\' to produce no value\n-- (\'NoEvent\').\ninstance Applicative Event where\n  pure = Event\n\n  Event f <*> Event x = Event (f x)\n  _       <*> _       = NoEvent\n\n-- | The type \'Event\' is isomorphic to \'Maybe\'. The \'Monad\' instance of \'Event\'\n-- is analogous to the \'Monad\' instance of \'Maybe\', where the lack of a value\n-- (i.e., \'NoEvent\') causes bind to produce no value (\'NoEvent\').\ninstance Monad Event where\n  return = pure\n\n  Event x >>= f = f x\n  NoEvent >>= _ = NoEvent\n\n-- | MonadFail instance\ninstance Fail.MonadFail Event where\n  -- | Fail with \'NoEvent\'.\n  fail _ = NoEvent\n\n-- | Alternative instance\ninstance Alternative Event where\n  -- | An empty alternative carries no event, so it is ignored.\n  empty = NoEvent\n  -- | Merge favouring the left event (\'NoEvent\' only if both are \'NoEvent\').\n  NoEvent <|> r = r\n  l       <|> _ = l\n\n-- | NFData instance\ninstance NFData a => NFData (Event a) where\n  -- | Evaluate value carried by event.\n  rnf NoEvent   = ()\n  rnf (Event a) = rnf a `seq` ()\n\n-- ** Lifting\n\n-- | Lifts a pure function into a signal function (applied pointwise).\narrPrim :: Monad m => (a -> b) -> SF m a b\narrPrim = arr\n\n-- | Lifts a pure function into a signal function applied to events (applied\n-- pointwise).\narrEPrim :: Monad m => (Event a -> b) -> SF m (Event a) b\narrEPrim = arr\n\n-- * Signal functions\n\n-- ** Basic signal functions\n\n-- | Identity: identity = arr id\n--\n-- Using \'identity\' is preferred over lifting id, since the arrow combinators\n-- know how to optimise certain networks based on the transformations being\n-- applied.\nidentity :: Monad m => SF m a a\nidentity = Category.id\n\n-- | Identity: constant b = arr (const b)\n--\n-- Using \'constant\' is preferred over lifting const, since the arrow\n-- combinators know how to optimise certain networks based on the\n-- transformations being applied.\nconstant :: Monad m => b -> SF m a b\nconstant = arr . const\n\n-- | Outputs the time passed since the signal function instance was started.\nlocalTime :: Monad m => SF m a Time\nlocalTime = constant 1.0 >>> integral\n\n-- | Alternative name for localTime.\ntime :: Monad m => SF m a Time\ntime = localTime\n\n-- ** Initialization\n\n-- | Initialization operator (cf. Lustre/Lucid Synchrone).\n--\n-- The output at time zero is the first argument, and from that point on it\n-- behaves like the signal function passed as second argument.\n(-->) :: Monad m => b -> SF m a b -> SF m a b\nb0 --> sf = sf >>> replaceOnce b0\n\n-- | Output pre-insert operator.\n--\n-- Insert a sample in the output, and from that point on, behave like the given\n-- sf.\n(-:>) :: Monad m => b -> SF m a b -> SF m a b\nb -:> sf = iPost b sf\n\n-- | Input initialization operator.\n--\n-- The input at time zero is the first argument, and from that point on it\n-- behaves like the signal function passed as second argument.\n(>--) :: Monad m => a -> SF m a b -> SF m a b\na0 >-- sf = replaceOnce a0 >>> sf\n\n-- | Transform initial input value.\n--\n-- Applies a transformation \'f\' only to the first input value at time zero.\n(>=-) :: Monad m => (a -> a) -> SF m a b -> SF m a b\nf >=- sf = MSF $ \\a -> do\n  (b, sf\') <- unMSF sf (f a)\n  return (b, sf\')\n\n-- | Override initial value of input signal.\ninitially :: Monad m => a -> SF m a a\ninitially = (--> identity)\n\n-- * Simple, stateful signal processing\n\n-- | Applies a function point-wise, using the last output as next input. This\n-- creates a well-formed loop based on a pure, auxiliary function.\nsscan :: Monad m => (b -> a -> b) -> b -> SF m a b\nsscan f bInit = feedback bInit u\n  where\n    u = undefined -- (arr f >>^ dup)\n\n-- | Generic version of \'sscan\', in which the auxiliary function produces an\n-- internal accumulator and an "held" output.\n--\n-- Applies a function point-wise, using the last known \'Just\' output to form\n-- the output, and next input accumulator. If the output is \'Nothing\', the last\n-- known accumulators are used. This creates a well-formed loop based on a\n-- pure, auxiliary function.\nsscanPrim :: Monad m => (c -> a -> Maybe (c, b)) -> c -> b -> SF m a b\nsscanPrim f cInit bInit = MSF $ \\a -> do\n  let o = f cInit a\n  case o of\n    Nothing       -> return (bInit, sscanPrim f cInit bInit)\n    Just (c\', b\') -> return (b\',    sscanPrim f c\' b\')\n\n-- | Event source that never occurs.\nnever :: Monad m => SF m a (Event b)\nnever = constant NoEvent\n\n-- | Event source with a single occurrence at time 0. The value of the event is\n-- given by the function argument.\nnow :: Monad m => b -> SF m a (Event b)\nnow b0 = Event b0 --> never\n\n-- | Event source with a single occurrence at or as soon after (local) time /q/\n-- as possible.\nafter :: Monad m\n      => Time -- ^ The time /q/ after which the event should be produced\n      -> b    -- ^ Value to produce at that time\n      -> SF m a (Event b)\nafter q x = feedback q go\n  where\n    go = MSF $ \\(_, t) -> do\n           dt <- ask\n           let t\' = t - dt\n               e  = if t > 0 && t\' < 0 then Event x else NoEvent\n               ct = if t\' < 0 then constant (NoEvent, t\') else go\n           return ((e, t\'), ct)\n\n-- | Event source with repeated occurrences with interval q.\n--\n-- Note: If the interval is too short w.r.t. the sampling intervals, the result\n-- will be that events occur at every sample. However, no more than one event\n-- results from any sampling interval, thus avoiding an "event backlog" should\n-- sampling become more frequent at some later point in time.\nrepeatedly :: Monad m => Time -> b -> SF m a (Event b)\nrepeatedly q x\n    | q > 0     = afterEach qxs\n    | otherwise = error "bearriver: repeatedly: Non-positive period."\n  where\n    qxs = (q, x):qxs\n\n-- | Event source with consecutive occurrences at the given intervals.\n--\n-- Should more than one event be scheduled to occur in any sampling interval,\n-- only the first will in fact occur to avoid an event backlog.\n\n-- After all, after, repeatedly etc. are defined in terms of afterEach.\nafterEach :: Monad m => [(Time, b)] -> SF m a (Event b)\nafterEach qxs = afterEachCat qxs >>> arr (fmap head)\n\n-- | Event source with consecutive occurrences at the given intervals.\n--\n-- Should more than one event be scheduled to occur in any sampling interval,\n-- the output list will contain all events produced during that interval.\nafterEachCat :: Monad m => [(Time, b)] -> SF m a (Event [b])\nafterEachCat = afterEachCat\' 0\n  where\n    afterEachCat\' :: Monad m => Time -> [(Time, b)] -> SF m a (Event [b])\n    afterEachCat\' _ []  = never\n    afterEachCat\' t qxs = MSF $ \\_ -> do\n      dt <- ask\n      let (ev, t\', qxs\') = fireEvents [] (t + dt) qxs\n          ev\' = if null ev\n                  then NoEvent\n                  else Event (reverse ev)\n\n      return (ev\', afterEachCat\' t\' qxs\')\n\n    fireEvents :: [b] -> Time -> [(Time, b)] -> ([b], Time, [(Time, b)])\n    fireEvents ev t []       = (ev, t, [])\n    fireEvents ev t (qx:qxs)\n        | fst qx < 0   = error "bearriver: afterEachCat: Non-positive period."\n        | overdue >= 0 = fireEvents (snd qx:ev) overdue qxs\n        | otherwise    = (ev, t, qx:qxs)\n      where\n        overdue = t - fst qx\n\n-- * Events\n\n-- | Apply an \'MSF\' to every input. Freezes temporarily if the input is\n-- \'NoEvent\', and continues as soon as an \'Event\' is received.\nmapEventS :: Monad m => MSF m a b -> MSF m (Event a) (Event b)\nmapEventS msf = proc eventA -> case eventA of\n  Event a -> arr Event <<< msf -< a\n  NoEvent -> returnA           -< NoEvent\n\n-- ** Relation to other types\n\n-- | Convert an \'Event\' into a \'Maybe\' value.\n--\n-- Both types are isomorphic, where a value containing an event is mapped to a\n-- \'Just\', and \'NoEvent\' is mapped to \'Nothing\'. There is, however, a semantic\n-- difference: a signal carrying a Maybe may change constantly, but, for a\n-- signal carrying an \'Event\', there should be a bounded frequency such that\n-- sampling the signal faster does not render more event occurrences.\neventToMaybe :: Event a -> Maybe a\neventToMaybe = event Nothing Just\n\n-- | Create an event if a \'Bool\' is \'True\'.\nboolToEvent :: Bool -> Event ()\nboolToEvent True  = Event ()\nboolToEvent False = NoEvent\n\n-- * Hybrid SF m combinators\n\n-- | A rising edge detector. Useful for things like detecting key presses. It\n-- is initialised as /up/, meaning that events occurring at time 0 will not be\n-- detected.\nedge :: Monad m => SF m Bool (Event ())\nedge = edgeFrom True\n\n-- | A rising edge detector that can be initialized as up (\'True\', meaning that\n-- events occurring at time 0 will not be detected) or down (\'False\', meaning\n-- that events occurring at time 0 will be detected).\niEdge :: Monad m => Bool -> SF m Bool (Event ())\niEdge = edgeFrom\n\n-- | Like \'edge\', but parameterized on the tag value.\n--\n-- From Yampa\nedgeTag :: Monad m => a -> SF m Bool (Event a)\nedgeTag a = edge >>> arr (`tag` a)\n\n-- | Edge detector particularized for detecting transitions on a \'Maybe\'\n-- signal from \'Nothing\' to \'Just\'.\n--\n-- From Yampa\n\n-- !!! 2005-07-09: To be done or eliminated\n-- !!! Maybe could be kept as is, but could be easy to implement directly in\n-- !!! terms of sscan?\nedgeJust :: Monad m => SF m (Maybe a) (Event a)\nedgeJust = edgeBy isJustEdge (Just undefined)\n  where\n    isJustEdge Nothing  Nothing     = Nothing\n    isJustEdge Nothing  ma@(Just _) = ma\n    isJustEdge (Just _) (Just _)    = Nothing\n    isJustEdge (Just _) Nothing     = Nothing\n\n-- | Edge detector parameterized on the edge detection function and initial\n-- state, i.e., the previous input sample. The first argument to the edge\n-- detection function is the previous sample, the second the current one.\nedgeBy :: Monad m => (a -> a -> Maybe b) -> a -> SF m a (Event b)\nedgeBy isEdge aPrev = MSF $ \\a ->\n  return (maybeToEvent (isEdge aPrev a), edgeBy isEdge a)\n\n-- | Convert a maybe value into a event (\'Event\' is isomorphic to \'Maybe\').\nmaybeToEvent :: Maybe a -> Event a\nmaybeToEvent = maybe NoEvent Event\n\n-- | A rising edge detector that can be initialized as up (\'True\', meaning that\n-- events occurring at time 0 will not be detected) or down (\'False\', meaning\n-- that events occurring at time 0 will be detected).\nedgeFrom :: Monad m => Bool -> SF m Bool (Event())\nedgeFrom prev = MSF $ \\a -> do\n  let res | prev      = NoEvent\n          | a         = Event ()\n          | otherwise = NoEvent\n      ct  = edgeFrom a\n  return (res, ct)\n\n-- * Stateful event suppression\n\n-- | Suppression of initial (at local time 0) event.\nnotYet :: Monad m => SF m (Event a) (Event a)\nnotYet = feedback False $ arr (\\(e, c) ->\n  if c then (e, True) else (NoEvent, True))\n\n-- | Suppress all but the first event.\nonce :: Monad m => SF m (Event a) (Event a)\nonce = takeEvents 1\n\n-- | Suppress all but the first n events.\ntakeEvents :: Monad m => Int -> SF m (Event a) (Event a)\ntakeEvents n | n <= 0 = never\ntakeEvents n = dSwitch (arr dup) (const (NoEvent >-- takeEvents (n - 1)))\n\n-- | Suppress first n events.\n\n-- Here dSwitch or switch does not really matter.\ndropEvents :: Monad m => Int -> SF m (Event a) (Event a)\ndropEvents n | n <= 0 = identity\ndropEvents n =\n  dSwitch (never &&& identity) (const (NoEvent >-- dropEvents (n - 1)))\n\n-- * Pointwise functions on events\n\n-- | Make the NoEvent constructor available. Useful e.g. for initialization,\n-- ((-->) & friends), and it\'s easily available anyway (e.g. mergeEvents []).\nnoEvent :: Event a\nnoEvent = NoEvent\n\n-- | Suppress any event in the first component of a pair.\nnoEventFst :: (Event a, b) -> (Event c, b)\nnoEventFst (_, b) = (NoEvent, b)\n\n-- | Suppress any event in the second component of a pair.\nnoEventSnd :: (a, Event b) -> (a, Event c)\nnoEventSnd (a, _) = (a, NoEvent)\n\n-- | An event-based version of the maybe function.\nevent :: a -> (b -> a) -> Event b -> a\nevent _ f (Event x) = f x\nevent x _ NoEvent   = x\n\n-- | Extract the value from an event. Fails if there is no event.\nfromEvent :: Event a -> a\nfromEvent (Event x) = x\nfromEvent _         = error "fromEvent NoEvent"\n\n-- | Tests whether the input represents an actual event.\nisEvent :: Event a -> Bool\nisEvent (Event _) = True\nisEvent _         = False\n\n-- | Negation of \'isEvent\'.\nisNoEvent :: Event a -> Bool\nisNoEvent (Event _) = False\nisNoEvent _         = True\n\n-- | Tags an (occurring) event with a value ("replacing" the old value).\n--\n-- Applicative-based definition:\n-- tag = ($>)\ntag :: Event a -> b -> Event b\ntag NoEvent   _ = NoEvent\ntag (Event _) b = Event b\n\n-- | Tags an (occurring) event with a value ("replacing" the old value). Same\n-- as \'tag\' with the arguments swapped.\n--\n-- Applicative-based definition:\n-- tagWith = (<$)\ntagWith :: b -> Event a -> Event b\ntagWith = flip tag\n\n-- | Attaches an extra value to the value of an occurring event.\nattach :: Event a -> b -> Event (a, b)\ne `attach` b = fmap (\\a -> (a, b)) e\n\n-- | Left-biased event merge (always prefer left event, if present).\nlMerge :: Event a -> Event a -> Event a\nlMerge = mergeBy (\\e1 _ -> e1)\n\n-- | Right-biased event merge (always prefer right event, if present).\nrMerge :: Event a -> Event a -> Event a\nrMerge = flip lMerge\n\n-- | Unbiased event merge: simultaneous occurrence is an error.\nmerge :: Event a -> Event a -> Event a\nmerge = mergeBy $ error "Bearriver: merge: Simultaneous event occurrence."\n\n-- Applicative-based definition:\n-- mergeBy f le re = (f <$> le <*> re) <|> le <|> re\nmergeBy :: (a -> a -> a) -> Event a -> Event a -> Event a\nmergeBy _       NoEvent      NoEvent      = NoEvent\nmergeBy _       le@(Event _) NoEvent      = le\nmergeBy _       NoEvent      re@(Event _) = re\nmergeBy resolve (Event l)    (Event r)    = Event (resolve l r)\n\n-- | A generic event merge-map utility that maps event occurrences, merging the\n-- results. The first three arguments are mapping functions, the third of which\n-- will only be used when both events are present. Therefore, \'mergeBy\' =\n-- \'mapMerge\' \'id\' \'id\'\n--\n-- Applicative-based definition:\n-- mapMerge lf rf lrf le re = (f <$> le <*> re) <|> (lf <$> le) <|> (rf <$> re)\nmapMerge :: (a -> c)\n            -- ^ Mapping function used when first event is present.\n         -> (b -> c)\n            -- ^ Mapping function used when second event is present.\n         -> (a -> b -> c)\n            -- ^ Mapping function used when both events are present.\n         -> Event a\n            -- ^ First event\n         -> Event b\n            -- ^ Second event\n         -> Event c\nmapMerge _  _  _   NoEvent   NoEvent   = NoEvent\nmapMerge lf _  _   (Event l) NoEvent   = Event (lf l)\nmapMerge _  rf _   NoEvent   (Event r) = Event (rf r)\nmapMerge _  _  lrf (Event l) (Event r) = Event (lrf l r)\n\n-- | Merge a list of events; foremost event has priority.\n--\n-- Foldable-based definition:\n-- mergeEvents :: Foldable t => t (Event a) -> Event a\n-- mergeEvents =  asum\nmergeEvents :: [Event a] -> Event a\nmergeEvents = foldr lMerge NoEvent\n\n-- | Collect simultaneous event occurrences; no event if none.\ncatEvents :: [Event a] -> Event [a]\ncatEvents eas = case [ a | Event a <- eas ] of\n                  [] -> NoEvent\n                  as -> Event as\n\n-- | Join (conjunction) of two events. Only produces an event if both events\n-- exist.\n--\n-- Applicative-based definition:\n-- joinE = liftA2 (,)\njoinE :: Event a -> Event b -> Event (a, b)\njoinE NoEvent   _         = NoEvent\njoinE _         NoEvent   = NoEvent\njoinE (Event l) (Event r) = Event (l, r)\n\n-- | Split event carrying pairs into two events.\nsplitE :: Event (a, b) -> (Event a, Event b)\nsplitE NoEvent        = (NoEvent, NoEvent)\nsplitE (Event (a, b)) = (Event a, Event b)\n\n------------------------------------------------------------------------------\n-- Event filtering\n------------------------------------------------------------------------------\n\n-- | Filter out events that don\'t satisfy some predicate.\nfilterE :: (a -> Bool) -> Event a -> Event a\nfilterE p e@(Event a) = if p a then e else NoEvent\nfilterE _ NoEvent     = NoEvent\n\n-- | Combined event mapping and filtering. Note: since \'Event\' is a \'Functor\',\n-- see \'fmap\' for a simpler version of this function with no filtering.\nmapFilterE :: (a -> Maybe b) -> Event a -> Event b\nmapFilterE _ NoEvent   = NoEvent\nmapFilterE f (Event a) = case f a of\n                           Nothing -> NoEvent\n                           Just b  -> Event b\n\n-- | Enable/disable event occurrences based on an external condition.\ngate :: Event a -> Bool -> Event a\n_ `gate` False = NoEvent\ne `gate` True  = e\n\n-- * Switching\n\n-- ** Basic switchers\n\n-- | Basic switch.\n--\n-- By default, the first signal function is applied. Whenever the second value\n-- in the pair actually is an event, the value carried by the event is used to\n-- obtain a new signal function to be applied *at that time and at future\n-- times*. Until that happens, the first value in the pair is produced in the\n-- output signal.\n--\n-- Important note: at the time of switching, the second signal function is\n-- applied immediately. If that second SF can also switch at time zero, then a\n-- double (nested) switch might take place. If the second SF refers to the\n-- first one, the switch might take place infinitely many times and never be\n-- resolved.\n--\n-- Remember: The continuation is evaluated strictly at the time\n-- of switching!\nswitch :: Monad m => SF m a (b, Event c) -> (c -> SF m a b) -> SF m a b\nswitch sf sfC = MSF $ \\a -> do\n  (o, ct) <- unMSF sf a\n  case o of\n    (_, Event c) -> local (const 0) (unMSF (sfC c) a)\n    (b, NoEvent) -> return (b, switch ct sfC)\n\n-- | Switch with delayed observation.\n--\n-- By default, the first signal function is applied.\n--\n-- Whenever the second value in the pair actually is an event, the value\n-- carried by the event is used to obtain a new signal function to be applied\n-- *at future times*.\n--\n-- Until that happens, the first value in the pair is produced in the output\n-- signal.\n--\n-- Important note: at the time of switching, the second signal function is used\n-- immediately, but the current input is fed by it (even though the actual\n-- output signal value at time 0 is discarded).\n--\n-- If that second SF can also switch at time zero, then a double (nested)\n-- switch might take place. If the second SF refers to the first one, the\n-- switch might take place infinitely many times and never be resolved.\n--\n-- Remember: The continuation is evaluated strictly at the time\n-- of switching!\ndSwitch :: Monad m => SF m a (b, Event c) -> (c -> SF m a b) -> SF m a b\ndSwitch sf sfC = MSF $ \\a -> do\n  (o, ct) <- unMSF sf a\n  case o of\n    (b, Event c) -> do (_, ct\') <- local (const 0) (unMSF (sfC c) a)\n                       return (b, ct\')\n    (b, NoEvent) -> return (b, dSwitch ct sfC)\n\n-- * Parallel composition and switching\n\n-- ** Parallel composition and switching over collections with broadcasting\n\n#if MIN_VERSION_base(4,8,0)\nparB :: Monad m => [SF m a b] -> SF m a [b]\n#else\nparB :: (Functor m, Monad m) => [SF m a b] -> SF m a [b]\n#endif\n-- ^ Spatial parallel composition of a signal function collection. Given a\n-- collection of signal functions, it returns a signal function that broadcasts\n-- its input signal to every element of the collection, to return a signal\n-- carrying a collection of outputs. See \'par\'.\n--\n-- For more information on how parallel composition works, check\n-- <https://www.antonycourtney.com/pubs/hw03.pdf>\nparB = widthFirst . sequenceS\n\n-- | Decoupled parallel switch with broadcasting (dynamic collection of signal\n-- functions spatially composed in parallel). See \'dpSwitch\'.\n--\n-- For more information on how parallel composition works, check\n-- <https://www.antonycourtney.com/pubs/hw03.pdf>\ndpSwitchB :: (Functor m, Monad m, Traversable col)\n          => col (SF m a b)\n          -> SF m (a, col b) (Event c)\n          -> (col (SF m a b) -> c -> SF m a (col b))\n          -> SF m a (col b)\ndpSwitchB sfs sfF sfCs = MSF $ \\a -> do\n  res <- T.mapM (`unMSF` a) sfs\n  let bs   = fmap fst res\n      sfs\' = fmap snd res\n  (e, sfF\') <- unMSF sfF (a, bs)\n  ct <- case e of\n          Event c -> snd <$> unMSF (sfCs sfs c) a\n          NoEvent -> return (dpSwitchB sfs\' sfF\' sfCs)\n  return (bs, ct)\n\n-- ** Parallel composition over collections\n\n-- | Apply an SF to every element of a list.\n--\n-- Example:\n--\n-- >>> embed (parC integral) (deltaEncode 0.1 [[1, 2], [2, 4], [3, 6], [4.0, 8.0 :: Float]])\n-- [[0.0,0.0],[0.1,0.2],[0.3,0.6],[0.6,1.2]]\n--\n-- The number of SFs or expected inputs is determined by the first input\n-- list, and not expected to vary over time.\n--\n-- If more inputs come in a subsequent list, they are ignored.\n--\n-- >>> embed (parC (arr (+1))) (deltaEncode 0.1 [[0], [1, 1], [3, 4], [6, 7, 8], [1, 1], [0, 0], [1, 9, 8]])\n-- [[1],[2],[4],[7],[2],[1],[2]]\n--\n-- If less inputs come in a subsequent list, an exception is thrown.\n--\n-- >>> embed (parC (arr (+1))) (deltaEncode 0.1 [[0, 0], [1, 1], [3, 4], [6, 7, 8], [1, 1], [0, 0], [1, 9, 8]])\n-- [[1,1],[2,2],[4,5],[7,8],[2,2],[1,1],[2,10]]\nparC :: Monad m => SF m a b -> SF m [a] [b]\nparC = parC0\n  where\n    parC0 :: Monad m => SF m a b -> SF m [a] [b]\n    parC0 sf0 = MSF $ \\as -> do\n      os <- T.mapM (\\(a, sf) -> unMSF sf a) $\n              zip as (replicate (length as) sf0)\n\n      let bs  = fmap fst os\n          cts = fmap snd os\n      return (bs, parC\' cts)\n\n    parC\' :: Monad m => [SF m a b] -> SF m [a] [b]\n    parC\' sfs = MSF $ \\as -> do\n      os <- T.mapM (\\(a, sf) -> unMSF sf a) $ zip as sfs\n      let bs  = fmap fst os\n          cts = fmap snd os\n      return (bs, parC\' cts)\n\n-- * Discrete to continuous-time signal functions\n\n-- ** Wave-form generation\n\n-- | Zero-order hold.\n--\n-- Converts a discrete-time signal into a continuous-time signal, by holding\n-- the last value until it changes in the input signal. The given parameter may\n-- be used for time zero, and until the first event occurs in the input signal,\n-- so hold is always well-initialized.\n--\n-- >>> embed (hold 1) (deltaEncode 0.1 [NoEvent, NoEvent, Event 2, NoEvent, Event 3, NoEvent])\n-- [1,1,2,2,3,3]\nhold :: Monad m => a -> SF m (Event a) a\nhold a = feedback a $ arr $ \\(e, a\') ->\n  dup (event a\' id e)\n\n-- ** Accumulators\n\n-- | Accumulator parameterized by the accumulation function.\naccumBy :: Monad m => (b -> a -> b) -> b -> SF m (Event a) (Event b)\naccumBy f b = mapEventS $ accumulateWith (flip f) b\n\n-- | Zero-order hold accumulator parameterized by the accumulation function.\naccumHoldBy :: Monad m => (b -> a -> b) -> b -> SF m (Event a) b\naccumHoldBy f b = feedback b $ arr $ \\(a, b\') ->\n  let b\'\' = event b\' (f b\') a\n  in (b\'\', b\'\')\n\n-- * State keeping combinators\n\n-- ** Loops with guaranteed well-defined feedback\n\n-- | Loop with an initial value for the signal being fed back.\nloopPre :: Monad m => c -> SF m (a, c) (b, c) -> SF m a b\nloopPre = feedback\n\n-- * Integration and differentiation\n\n-- | Integration using the rectangle rule.\nintegral :: (Monad m, Fractional s, VectorSpace a s) => SF m a a\nintegral = integralFrom zeroVector\n\n-- | Integrate using an auxiliary function that takes the current and the last\n-- input, the time between those samples, and the last output, and returns a\n-- new output.\nintegralFrom :: (Monad m, Fractional s, VectorSpace a s) => a -> SF m a a\nintegralFrom a0 = proc a -> do\n  dt <- constM ask        -< ()\n  accumulateWith (^+^) a0 -< realToFrac dt *^ a\n\n-- | A very crude version of a derivative. It simply divides the value\n-- difference by the time difference. Use at your own risk.\nderivative :: (Monad m, Fractional s, VectorSpace a s) => SF m a a\nderivative = derivativeFrom zeroVector\n\n-- | A very crude version of a derivative. It simply divides the value\n-- difference by the time difference. Use at your own risk.\n--\n-- Starts from a given value for the input signal at time zero.\nderivativeFrom :: (Monad m, Fractional s, VectorSpace a s) => a -> SF m a a\nderivativeFrom a0 = proc a -> do\n  dt   <- constM ask -< ()\n  aOld <- iPre a0    -< a\n  returnA            -< (a ^-^ aOld) ^/ realToFrac dt\n\n-- | Integrate using an auxiliary function that takes the current and the last\n-- input, the time between those samples, and the last output, and returns a\n-- new output.\n\n-- NOTE: BUG in this function, it needs two a\'s but we can only provide one\niterFrom :: Monad m => (a -> a -> DTime -> b -> b) -> b -> SF m a b\niterFrom f b = MSF $ \\a -> do\n  dt <- ask\n  let b\' = f a a dt b\n  return (b, iterFrom f b\')\n\n-- * Noise (random signal) sources and stochastic event sources\n\n-- | Stochastic event source with events occurring on average once every tAvg\n-- seconds. However, no more than one event results from any one sampling\n-- interval in the case of relatively sparse sampling, thus avoiding an "event\n-- backlog" should sampling become more frequent at some later point in time.\noccasionally :: MonadRandom m\n             => Time -- ^ The time /q/ after which the event should be produced\n                     -- on average\n             -> b    -- ^ Value to produce at time of event\n             -> SF m a (Event b)\noccasionally tAvg b\n    | tAvg <= 0\n    = error "bearriver: Non-positive average interval in occasionally."\n\n    | otherwise = proc _ -> do\n        r   <- getRandomRS (0, 1) -< ()\n        dt  <- timeDelta          -< ()\n        let p = 1 - exp (-(dt / tAvg))\n        returnA -< if r < p then Event b else NoEvent\n  where\n    timeDelta :: Monad m => SF m a DTime\n    timeDelta = constM ask\n\n-- * Execution/simulation\n\n-- ** Reactimation\n\n-- | Convenience function to run a signal function indefinitely, using a IO\n-- actions to obtain new input and process the output.\n--\n-- This function first runs the initialization action, which provides the\n-- initial input for the signal transformer at time 0.\n--\n-- Afterwards, an input sensing action is used to obtain new input (if any) and\n-- the time since the last iteration. The argument to the input sensing\n-- function indicates if it can block. If no new input is received, it is\n-- assumed to be the same as in the last iteration.\n--\n-- After applying the signal function to the input, the actuation IO action is\n-- executed. The first argument indicates if the output has changed, the second\n-- gives the actual output). Actuation functions may choose to ignore the first\n-- argument altogether. This action should return True if the reactimation must\n-- stop, and False if it should continue.\n--\n-- Note that this becomes the program\'s /main loop/, which makes using this\n-- function incompatible with GLUT, Gtk and other graphics libraries. It may\n-- also impose a sizeable constraint in larger projects in which different\n-- subparts run at different time steps. If you need to control the main loop\n-- yourself for these or other reasons, use \'reactInit\' and \'react\'.\nreactimate :: Monad m\n           => m a\n           -> (Bool -> m (DTime, Maybe a))\n           -> (Bool -> b -> m Bool)\n           -> SF Identity a b\n           -> m ()\nreactimate senseI sense actuate sf = do\n    MSF.reactimateB $ senseSF >>> sfIO >>> actuateSF\n    return ()\n  where\n    sfIO = morphS (return.runIdentity) (runReaderS sf)\n\n    -- Sense\n    senseSF = MSF.dSwitch senseFirst senseRest\n\n    -- Sense: First sample\n    senseFirst = constM senseI >>> arr (\\x -> ((0, x), Just x))\n\n    -- Sense: Remaining samples\n    senseRest a = constM (sense True) >>> (arr id *** keepLast a)\n\n    keepLast :: Monad m => a -> MSF m (Maybe a) a\n    keepLast a = MSF $ \\ma ->\n      let a\' = fromMaybe a ma\n      in a\' `seq` return (a\', keepLast a\')\n\n    -- Consume/render\n    actuateSF = arr (\\x -> (True, x)) >>> arrM (uncurry actuate)\n\n-- * Debugging / Step by step simulation\n\n-- | Evaluate an SF, and return an output and an initialized SF.\n--\n-- /WARN/: Do not use this function for standard simulation. This function is\n-- intended only for debugging/testing. Apart from being potentially slower and\n-- consuming more memory, it also breaks the FRP abstraction by making samples\n-- discrete and step based.\nevalAtZero :: SF Identity a b -> a -> (b, SF Identity a b)\nevalAtZero sf a = runIdentity $ runReaderT (unMSF sf a) 0\n\n-- | Evaluate an initialized SF, and return an output and a continuation.\n--\n-- /WARN/: Do not use this function for standard simulation. This function is\n-- intended only for debugging/testing. Apart from being potentially slower and\n-- consuming more memory, it also breaks the FRP abstraction by making samples\n-- discrete and step based.\nevalAt :: SF Identity a b -> DTime -> a -> (b, SF Identity a b)\nevalAt sf dt a = runIdentity $ runReaderT (unMSF sf a) dt\n\n-- | Given a signal function and time delta, it moves the signal function into\n-- the future, returning a new uninitialized SF and the initial output.\n--\n-- While the input sample refers to the present, the time delta refers to the\n-- future (or to the time between the current sample and the next sample).\n--\n-- /WARN/: Do not use this function for standard simulation. This function is\n-- intended only for debugging/testing. Apart from being potentially slower and\n-- consuming more memory, it also breaks the FRP abstraction by making samples\n-- discrete and step based.\nevalFuture :: SF Identity a b -> a -> DTime -> (b, SF Identity a b)\nevalFuture sf = flip (evalAt sf)\n\n-- * Auxiliary functions\n\n-- ** Event handling\n\n-- | Replace the value of the input signal at time zero with the given\n-- argument.\nreplaceOnce :: Monad m => a -> SF m a a\nreplaceOnce a = dSwitch (arr $ const (a, Event ())) (const $ arr id)\n'