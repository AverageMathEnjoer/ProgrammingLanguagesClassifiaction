b'module GameIO (saveGame, loadGame) where\n\nimport qualified Data.Map as M\nimport qualified Text.Parsec as P\nimport qualified Text.Parsec.Language as P\nimport qualified Text.Parsec.Token as P\nimport Control.DeepSeq\nimport Control.Applicative\nimport GameModel\nimport GameUtils\n\ngameToString :: Game -> String\ngameToString (Game gridSize status) =\n  (show gridSize) ++ "," ++ [cellStatusToChar (M.lookup (Coord x y) status) |\n                          x <- [0..(gridSize - 1)], y <- [0..(gridSize - 1)]]\n  where\n    cellStatusToChar Nothing = \'x\'\n    cellStatusToChar (Just (CellStatus CellKnown CellMine)) = \'M\'\n    cellStatusToChar (Just (CellStatus CellKnown CellNotMine)) = \'N\'\n    cellStatusToChar (Just (CellStatus CellUnknown CellMine)) = \'m\'\n    cellStatusToChar (Just (CellStatus CellUnknown CellNotMine)) = \'n\'\n    \nsaveGame :: Game -> IO ()\nsaveGame g = writeFile "game.data" (gameToString g)\n\nparseCellStatus :: P.Parsec String u CellStatus\nparseCellStatus =\n      (P.char \'M\' *> pure (CellStatus CellKnown CellMine))\n  <|> (P.char \'N\' *> pure (CellStatus CellKnown CellNotMine))\n  <|> (P.char \'m\' *> pure (CellStatus CellUnknown CellMine))\n  <|> (P.char \'n\' *> pure (CellStatus CellUnknown CellNotMine))\n\nparseGame :: P.Parsec String u Game\nparseGame = do\n  size <- fromIntegral <$> P.decimal P.haskell\n  _ <- P.char \',\'\n  cellStatuses <- P.count (size * size) parseCellStatus\n  let statuses = M.fromList $ zip [Coord x y | x <- [0..(size - 1)],\n                               y <- [0..(size - 1)]] cellStatuses\n  return $ Game size statuses\n\nloadGame :: IO (Maybe Game)\nloadGame = do\n  gameData <- readFile "game.data"\n  gameData `deepseq` (return . eitherToJust $ P.parse parseGame "" gameData)\n'