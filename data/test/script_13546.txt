b'module ListAux where\n\nimport Data.List\n\n\n-- splitting into n parts, and its inverse:\n\nsplitIntoN :: Int -> [a] -> [[a]]\nsplitIntoN n xs = takeIter parts xs\n  where l = length xs\n        parts = zipWith (+) ((replicate (l `mod` n) 1) ++ repeat 0)\n                            (replicate n (l `div` n))\ntakeIter :: [Int] -> [a] -> [[a]]\ntakeIter [] [] = []\ntakeIter [] _  = error "elements left over"\ntakeIter (t:ts) xs = hs : takeIter ts rest\n    where (hs,rest) = splitAt t xs\n\nunSplit :: [[a]] -> [a]\nunSplit = concat\n\n-- splitting into parts of same size. Inverse is concat again.\n\nsplitAtN :: Int -> [a] -> [[a]]\nsplitAtN n [] = []\nsplitAtN n xs = ys : splitAtN n zs\n\t        where (ys,zs) = splitAt n xs\n\n----------------------------------------\n\n-- splitting round-robin until list runs empty, and its inverse:\n\nunshuffle :: Int -> [a] -> [[a]]\nunshuffle n xs = [takeEach n (drop i xs) | i <- [0..n-1]]\n where takeEach n [] = []\n       takeEach n (x:xs) = x : takeEach n (drop (n-1) xs)\n\n-- inverse to unshuffle\nshuffle :: [[a]] -> [a]\nshuffle = concat . transpose\n\n'