b'{-# LANGUAGE ImpredicativeTypes #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE NoMonomorphismRestriction #-}\n\n-- ! BUILD_COMMAND: runhaskell --ghc-arg=-fglasgow-exts -XStandaloneDeriving -XTypeSynonymInstances -XDeriveGeneric -XGADTs -XOverloadedStrings -XFlexibleContexts -XFlexibleInstances -XTypeFamilies -XTypeApplications -XAllowAmbiguousTypes -XPartialTypeSignatures -fno-warn-partial-type-signatures\n-- ! BUILD_DIR: beam-sqlite/examples/\n-- ! FORMAT: sql\nmodule Main where\n\nimport Prelude hiding (lookup)\n\nimport Database.Beam hiding (withDatabaseDebug)\nimport qualified Database.Beam as Beam\nimport Database.Beam.Sqlite hiding (runBeamSqliteDebug)\nimport qualified Database.Beam.Sqlite as Sqlite\nimport Database.SQLite.Simple\n\nimport Lens.Micro\n\nimport Data.Text (Text)\nimport Data.Int\n\nimport Control.Monad\n\nimport Data.IORef\n\ndata UserT f\n    = User\n    { _userEmail     :: Columnar f Text\n    , _userFirstName :: Columnar f Text\n    , _userLastName  :: Columnar f Text\n    , _userPassword  :: Columnar f Text }\n    deriving Generic\ntype User = UserT Identity\nderiving instance Show User\nderiving instance Eq User\n\ninstance Beamable UserT\ninstance Table UserT where\n    data PrimaryKey UserT f = UserId (Columnar f Text) deriving Generic\n    primaryKey = UserId . _userEmail\ninstance Beamable (PrimaryKey UserT)\n\ntype UserId = PrimaryKey UserT Identity\n\ndata AddressT f = Address\n                { _addressId    :: C f Int32\n                , _addressLine1 :: C f Text\n                , _addressLine2 :: C f (Maybe Text)\n                , _addressCity  :: C f Text\n                , _addressState :: C f Text\n                , _addressZip   :: C f Text\n\n                , _addressForUser :: PrimaryKey UserT f }\n                  deriving Generic\ntype Address = AddressT Identity\nderiving instance Show (PrimaryKey UserT Identity)\nderiving instance Show Address\n\ninstance Table AddressT where\n    data PrimaryKey AddressT f = AddressId (Columnar f Int32) deriving Generic\n    primaryKey = AddressId . _addressId\n\ninstance Beamable AddressT\ninstance Beamable (PrimaryKey AddressT)\n\ndata ShoppingCartDb f = ShoppingCartDb\n                      { _shoppingCartUsers         :: f (TableEntity UserT)\n                      , _shoppingCartUserAddresses :: f (TableEntity AddressT) }\n                        deriving Generic\n\ninstance Database be ShoppingCartDb\n\nshoppingCartDb :: DatabaseSettings Sqlite ShoppingCartDb\nshoppingCartDb = defaultDbSettings `withDbModification`\n                 dbModification {\n                   _shoppingCartUserAddresses =\n                     modifyTable (\\_ -> "addresses") $\n                     tableModification {\n                       _addressLine1 = fieldNamed "address1",\n                       _addressLine2 = fieldNamed "address2"\n                     }\n                 }\n\nshoppingCartDb1 :: DatabaseSettings Sqlite ShoppingCartDb\nshoppingCartDb1 = defaultDbSettings `withDbModification`\n                  dbModification {\n                    _shoppingCartUsers = modifyTable (\\_ -> "users") tableModification,\n                    _shoppingCartUserAddresses = modifyTable (\\_ -> "user_addresses") tableModification\n                  }\n\nAddress (LensFor addressId)    (LensFor addressLine1)\n        (LensFor addressLine2) (LensFor addressCity)\n        (LensFor addressState) (LensFor addressZip)\n        (UserId (LensFor addressForUserId)) =\n        tableLenses\n\nUser (LensFor userEmail)    (LensFor userFirstName)\n     (LensFor userLastName) (LensFor userPassword) =\n     tableLenses\n\nShoppingCartDb (TableLens shoppingCartUsers)\n               (TableLens shoppingCartUserAddresses) =\n               dbLenses\n\nmain :: IO ()\nmain =\n  do conn <- open ":memory:"\n     execute_ conn "CREATE TABLE cart_users (email VARCHAR NOT NULL, first_name VARCHAR NOT NULL, last_name VARCHAR NOT NULL, password VARCHAR NOT NULL, PRIMARY KEY( email ));"\n     execute_ conn "CREATE TABLE addresses ( id INTEGER PRIMARY KEY AUTOINCREMENT, address1 VARCHAR NOT NULL, address2 VARCHAR, city VARCHAR NOT NULL, state VARCHAR NOT NULL, zip VARCHAR NOT NULL, for_user__email VARCHAR NOT NULL );"\n\n     let james = User "james@example.com" "James" "Smith" "b4cc344d25a2efe540adbf2678e2304c"\n         betty = User "betty@example.com" "Betty" "Jones" "82b054bd83ffad9b6cf8bdb98ce3cc2f"\n         sam = User "sam@example.com" "Sam" "Taylor" "332532dcfaa1cbf61e2a266bd723612c"\n     runBeamSqlite conn $ runInsert $\n       insert (_shoppingCartUsers shoppingCartDb) $\n       insertValues [ james, betty, sam ]\n\n     let addresses = [ Address default_ (val_ "123 Little Street") (val_ Nothing) (val_ "Boston") (val_ "MA") (val_ "12345") (pk james)\n                     , Address default_ (val_ "222 Main Street") (val_ (Just "Ste 1")) (val_ "Houston") (val_ "TX") (val_ "8888") (pk betty)\n                     , Address default_ (val_ "9999 Residence Ave") (val_ Nothing) (val_ "Sugarland") (val_ "TX") (val_ "8989") (pk betty) ]\n\n     runBeamSqlite conn $ runInsert $\n       insert (_shoppingCartUserAddresses shoppingCartDb) $\n       insertExpressions addresses\n\n     let runBeamSqliteDebug _ = Sqlite.runBeamSqliteDebug putStrLn\n\n\n     (do let putStrLn :: String -> IO ()\n             putStrLn _ = pure ()\n\n             print _ = pure ()\n\n         BEAM_PLACEHOLDER\n       )\n'