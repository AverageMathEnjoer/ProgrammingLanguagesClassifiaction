b'// I2Cdev library collection - MS5803 I2C device class\n// Based on Measurement Specialties MS5803 document, 3/25/2013 (DA5803-01BA_010)\n// 3/29/2016 by Ryan Neve <Ryan@PlanktosInstruments.com>\n// Updates should (hopefully) always be available at https://github.com/jrowberg/i2cdevlib\n//\n// Changelog:\n//     ... - ongoing debug release\n\n// NOTE: THIS IS ONLY A PARIAL RELEASE. THIS DEVICE CLASS IS CURRENTLY UNDERGOING ACTIVE\n// DEVELOPMENT AND IS STILL MISSING SOME IMPORTANT FEATURES. PLEASE KEEP THIS IN MIND IF\n// YOU DECIDE TO USE THIS PARTICULAR CODE FOR ANYTHING.\n\n/* ============================================\nI2Cdev device library code is placed under the MIT license\nCopyright (c) 2014 Ryan Neve\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the "Software"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n===============================================\n*/\n#include "MS5803_I2C.h"\n\nconst static uint8_t INIT_TRIES = 3;\nconst static uint16_t PRESS_ATM_MBAR_DEFAULT = 1015;\n\n\t\nconst char* CALIBRATION_CONSTANTS[] = {\n\t"_c1_SENSt1",\n\t"_c2_OFFt1",\n\t"_c3_TCS",\n\t"_c4_TCO",\n\t"_c5_Tref",\n\t"_c6_TEMPSENS"\n};\n\n/** Default constructor, uses default I2C address.\n* @see MPU6050_DEFAULT_ADDRESS\n*/\nMS5803::MS5803() { MS5803(MS5803_DEFAULT_ADDRESS);}\n\n/** Specific address constructor.\n* @param address I2C address\n* @see MS5803_DEFAULT_ADDRESS\n* @see MS5803_ADDRESS_AD0_LOW\n* @see MS5803_ADDRESS_AD0_HIGH\n*/\nMS5803::MS5803(uint8_t address) {\n\tsetAddress(address);\n\t_initialized = false;\n\t_c1_SENSt1\t\t= 0;\n\t_c2_OFFt1\t\t= 0;\n\t_c3_TCS\t\t\t= 0;\n\t_c4_TCO\t\t\t= 0;\n\t_c5_Tref\t\t= 0;\n\t_c6_TEMPSENS\t= 0;\n\t_press_atm_mBar = (float)PRESS_ATM_MBAR_DEFAULT/1000.0; //default, can be changed with setAtmospheric() \n}\n// Because sometimes you want to set the address later.\nvoid MS5803::setAddress(uint8_t address) {\n\t_dev_address = address;\n}\n\n/** Power on and prepare for general usage.\n* This will reset the device to make sure that the calibration PROM gets loaded into\n* the internal register. It will then read the calibration constants from the PROM\n*/\nbool MS5803::initialize(uint8_t model) {\n\t_initialized = false;\n\t// Make sure model is valid.\n\tswitch (model) {\n\t\tcase ( 1): _model = BA01; break;\n\t\tcase ( 2): _model = BA02; break;\n\t\tcase ( 5): _model = BA05; break;\n\t\tcase (14): _model = BA14; break;\n\t\tcase (30): _model = BA30; break;\n\t\tdefault:\n\t\t\tSerial.print(F("MS5803 Model entered (")); Serial.print(model); Serial.println(F(") is not valid/supported."));\n\t\t\t_model = INVALID; \n\t\t\treturn 0;\n\t}\n\tif (_debug) Serial.println(reset());\n\tuint8_t tries = 0;\n\tdo {\n\t\t_getCalConstants(); // Seems to partially fail the first try sometimes.\n\t\tif (_c1_SENSt1 && _c2_OFFt1 && _c3_TCS && _c4_TCO && _c5_Tref && _c6_TEMPSENS ) _initialized = true; // They must all be non-0\n\t\ttries++;\n\t} while (!_initialized && ( tries < INIT_TRIES) );\n\tif (_debug) {\n\t\tfor ( uint8_t i = 1 ; i <= 6; i++){\n\t\t\tSerial.print(i);\n\t\t\tSerial.print(": ");\n\t\t\tSerial.print(CALIBRATION_CONSTANTS[i-1]);\n\t\t\tSerial.print(" = ");\n\t\t\tSerial.println(_getCalConstant(i));\n\t\t}\n\t}\n\treturn _initialized;\n}\n\n// See if we can communicate\nbool MS5803::testConnection(){\n\tuint8_t reg_address = CMD_ADC_CONV + TEMPERATURE + ADC_256;\n\treturn I2Cdev::writeBytes(_dev_address,reg_address,0,_buffer);\n}\n\nuint16_t MS5803::reset(){\n\t// Not sure how to send no buffer to an address.\n\treturn I2Cdev::writeBytes(_dev_address, MS5803_RESET,0,_buffer);\n}\n\nvoid MS5803::_getCalConstants(){\n\t/* Query and parse calibration constants */\n\tI2Cdev::readBytes(_dev_address,MS5803_PROM_C1,2,_buffer);\n\t_c1_SENSt1 =   (((uint16_t)_buffer[0] << 8) + _buffer[1]);\n\tI2Cdev::readBytes(_dev_address,MS5803_PROM_C2,2,_buffer);\n\t_c2_OFFt1 =    (((uint16_t)_buffer[0] << 8) + _buffer[1]);\n\tI2Cdev::readBytes(_dev_address,MS5803_PROM_C3,2,_buffer);\n\t_c3_TCS =      (((uint16_t)_buffer[0] << 8) + _buffer[1]);\n\tI2Cdev::readBytes(_dev_address,MS5803_PROM_C4,2,_buffer);\n\t_c4_TCO =      (((uint16_t)_buffer[0] << 8) + _buffer[1]);\n\tI2Cdev::readBytes(_dev_address,MS5803_PROM_C5,2,_buffer);\n\t_c5_Tref =     (((uint16_t)_buffer[0] << 8) + _buffer[1]);\n\tI2Cdev::readBytes(_dev_address,MS5803_PROM_C6,2,_buffer);\n\t_c6_TEMPSENS = (((uint16_t)_buffer[0] << 8) + _buffer[1]);\n}\n\nint32_t MS5803::_getCalConstant(uint8_t constant_no){\n\tswitch ( constant_no ) {\n\t\tcase 1: return _c1_SENSt1;\n\t\tcase 2: return _c2_OFFt1;\n\t\tcase 3: return _c3_TCS;\n\t\tcase 4: return _c4_TCO;\n\t\tcase 5: return _c5_Tref;\n\t\tcase 6: return _c6_TEMPSENS;\n\t\tdefault: return 0;\n\t}\n}\n\n/*\tThis function communicates with the sensor and does all the math to convert \n\traw values to good data. Data can be accessed with various getters.\n*/\nvoid MS5803::calcMeasurements(precision _precision){\n\t// Get raw temperature and pressure values\n\t_d2_temperature = _getADCconversion(TEMPERATURE, _precision);\n\t_d1_pressure = _getADCconversion(PRESSURE, _precision);\n\t//Now that we have a raw temperature, let\'s compute our actual.\n\t_dT = _d2_temperature - ((int32_t)_c5_Tref << 8);\n\tdouble temp_dT = _dT / (double)pow(2,23);\n\t_TEMP = 2000 +  (int32_t)(temp_dT * _c6_TEMPSENS);\n\tif ( _debug ) {\n\t\tSerial.println("Raw values:");\n\t\tSerial.print("    _d2_temperature = "); Serial.println(_d2_temperature);\n\t\tSerial.print("    _d1_pressure = "); Serial.println(_d1_pressure);\n\t\tSerial.println("First order values:");\n\t\tSerial.print("    _dT = "); Serial.println(_dT);\n\t\tSerial.print("    _TEMP = "); Serial.println(_TEMP);\n\t}\n\t// Second order variables\n\tint64_t T2 = 0;\n\tint64_t off2 = 0;\n\tint64_t sens2 = 0;\n\t// Every variant does the calculations differently, so...\n\tswitch (_model) {\n\t\tcase (BA01):  //MS5803-01-----------------------------------------------------------\n\t\t\t_OFF  = ((int64_t)_c2_OFFt1  << 16 ) + ((((int64_t)_c4_TCO * (int64_t)_dT)) >> 7 );\n\t\t\t_SENS = ((int64_t)_c1_SENSt1 << 15 ) + ((((int64_t)_c3_TCS * (int64_t)_dT)) >> 8 );\n\t\t\t// 2nd Order calculations\n\t\t\tif ( _TEMP < 2000.0) {  // Is temperature below or above 20.00 deg C ?\n\t\t\t\tT2 = 3 * pow(_dT,2)/(int64_t)pow(2,31);\n\t\t\t\toff2  = 3 * pow((_TEMP - 2000.0),2);\n\t\t\t\tsens2 = 7 * pow((_TEMP - 2000.0),2) / 8;\n\t\t\t\tif ( _TEMP < 1500.0 ) sens2 += 2 * pow((_TEMP + 1500.0),2);// below 15C\n\t\t\t}\n\t\t\telse {\n\t\t\t\tT2 = 0;\n\t\t\t\toff2 = 0;\n\t\t\t\tsens2 = 0;\n\t\t\t\tif ( _TEMP >= 4500.0 ) {\n\t\t\t\t\tsens2 -= ((int64_t)pow((_TEMP - 4500.0),2) >> 3);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase (BA02):  //MS5803-02-----------------------------------------------------------\n\t\t\t_OFF  = ((int64_t)_c2_OFFt1  << 17 ) + ((((int64_t)_c4_TCO * (int64_t)_dT)) >> 6 );\n\t\t\t_SENS = ((int64_t)_c1_SENSt1 << 16 ) + ((((int64_t)_c3_TCS * (int64_t)_dT)) >> 7 );\n\t\t\t// 2nd Order calculations\n\t\t\tif ( _TEMP < 2000.0) {  // Is temperature below or above 20.00 deg C ?\n\t\t\t\tT2 = 3 * pow(_dT,2)/(int64_t)pow(2,31);\n\t\t\t\toff2 = 61 * pow((_TEMP - 2000.0),2) / 16;\n\t\t\t\tsens2 = 2 * pow(((int64_t)_TEMP - 2000.0),2);\n\t\t\t\tif ( _TEMP < 1500.0 ) { // below 15C\n\t\t\t\t\toff2  += 20 * pow((_TEMP + 1500.0),2);\n\t\t\t\t\tsens2 += 12 * pow((_TEMP + 1500.0),2);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tT2 = 0;\n\t\t\t\toff2 = 0;\n\t\t\t\tsens2 = 0;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase (BA05):  //MS5803-05-----------------------------------------------------------\n\t\t\t_OFF  = ((int64_t)_c2_OFFt1  << 18 ) + ((((int64_t)_c4_TCO * (int64_t)_dT)) >> 5 );\n\t\t\t_SENS = ((int64_t)_c1_SENSt1 << 17 ) + ((((int64_t)_c3_TCS * (int64_t)_dT)) >> 7 );\n\t\t\t// 2nd Order calculations\n\t\t\tif ( _TEMP < 2000.0) {  // Is temperature below or above 20.00 deg C ?\n\t\t\t\tT2 = 3 * pow(_dT,2)/(int64_t)pow(2,33);\n\t\t\t\toff2 =  3 * pow((_TEMP - 2000.0),2) / 8;\n\t\t\t\tsens2 = 7 * pow((_TEMP - 2000.0),2) / 8;\n\t\t\t\tif ( _TEMP < -1500.0 ) { // below -15C\n\t\t\t\t\tsens2 += 3 * pow((_TEMP + 1500.0),2);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tT2 = 0;\n\t\t\t\toff2 = 0;\n\t\t\t\tsens2 = 0;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase (BA14):  //MS5803-14-----------------------------------------------------------\n\t\t\t// 14 and 30 are the same calculations...\n\t\tcase (BA30):  //MS5803-30-----------------------------------------------------------\n\t\t\t_OFF  = ((int64_t)_c2_OFFt1  << 16 ) + ((((int64_t)_c4_TCO * (int64_t)_dT)) >> 7 );\n\t\t\t_SENS = ((int64_t)_c1_SENSt1 << 15 ) + ((((int64_t)_c3_TCS * (int64_t)_dT)) >> 8 );\n\t\t\t// 2nd Order calculations\n\t\t\tif ( _TEMP < 2000.0) {  // Is temperature below or above 20.00 deg C ?\n\t\t\t\tT2 = 3 * pow(_dT,2)/(int64_t)pow(2,33);\n\t\t\t\toff2 =  3 * pow((_TEMP - 2000.0),2) / 2;\n\t\t\t\tsens2 = 5 * pow((_TEMP - 2000.0),2) / 8;\n\t\t\t\tif ( _TEMP < 1500.0 ) { // below 15C\n\t\t\t\t\toff2  += 7 * pow((_TEMP + 1500.0),2);\n\t\t\t\t\tsens2 += 4 * pow((_TEMP + 1500.0),2);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tT2 =    7 * ((int64_t)_dT * _dT) >> 37;\n\t\t\t\toff2 =  1 * (pow((_TEMP - 2000.0),2)) / 16;\n\t\t\t\tsens2 = 0;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t_OFF = 0;\n\t\t\t_SENS = 0;\n\t\t\tT2 = 0;\n\t\t\tsens2 = 0;\n\t\t\toff2 = 0;\n\t}\n\tif ( _debug ) {\n\t\tSerial.print("    _OFF = "); serialPrintln64(_OFF);\n\t\tSerial.print("    _SENS = "); serialPrintln64(_SENS);\n\t}\n\t // Second Order\n\t_TEMP  -= T2;\n\t_SENS  -= sens2;\n\t_OFF   -= off2;\n\t// Now pressure\n\tswitch (_model) {\n\t\tcase (BA05):  //MS5803-05-----------------------------------------------------------\n\t\t\t_P = ((((int32_t)_d1_pressure * _SENS) >> 21 ) - _OFF) >> 15;\n\t\t\t_P /= 10; // NO IDEA WHY THIS NEEDS TO BE DONE. PERHAPS AN ERROR IN THE DATASHEET?\n\t\t\tbreak;\n\t\tcase (BA01):  //MS5803-01--passthrough----------------------------------------------\n\t\tcase (BA02):  //MS5803-02--passthrough----------------------------------------------\n\t\tcase (BA14):  //MS5803-14--passthrough----------------------------------------------\n\t\t\t_P = ((((int32_t)_d1_pressure * _SENS) >> 21 ) - _OFF) >> 15;\n\t\t\tbreak;\n\t\tcase (BA30):  //MS5803-30-----------------------------------------------------------\n\t\t\t_P = ((((int32_t)_d1_pressure * _SENS) >> 21 ) - _OFF) >> 13;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t_P = 0;\n\t}\n\tif ( _debug ) {\n\t\tSerial.println("Second order values:");\n\t\tSerial.print("    T2 = "); serialPrintln64(T2);\n\t\tSerial.print("    sens2 = "); serialPrintln64(sens2);\n\t\tSerial.print("    off2 = "); serialPrintln64(off2);\n\t\tSerial.print("    _TEMP = "); Serial.println(_TEMP);\n\t\tSerial.print("    _SENS = "); serialPrintln64(_SENS);\n\t\tSerial.print("    _OFF = "); serialPrintln64(_OFF);\n\t\tSerial.println("Pressure:");\n\t\tSerial.print("    _P = "); Serial.println(_P);\n\t}\n}\n\nint32_t MS5803::_getADCconversion(measurement _measurement, precision _precision){\n\t// Retrieve ADC measurement from the device.\n\t// Select measurement type and precision\n\tuint32_t result;\n\tuint8_t reg_address = CMD_ADC_CONV + _measurement + _precision;\n\tuint8_t write_length = 0;\n\tuint8_t read_length = 3;\n\tuint16_t read_timeout = 2000;\n\t//sendCommand(CMD_ADC_CONV + _measurement + _precision);\n\tI2Cdev::writeBytes(_dev_address,reg_address,write_length,_buffer); // buffer is ignored when write_length is 0\n\t\t\n\t// Wait for conversion to complete\n\tdelay(1); //general delay\n\tswitch( _precision )\n\t{\n\t\tcase ADC_256 : delay(1); break;\n\t\tcase ADC_512 : delay(3 >> CLKPR); break;\n\t\tcase ADC_1024: delay(4 >> CLKPR); break;\n\t\tcase ADC_2048: delay(6 >> CLKPR); break;\n\t\tcase ADC_4096: delay(10 >> CLKPR); break;\n\t}\n\tI2Cdev::readBytes(_dev_address,MS5803_ADC_READ,read_length,_buffer,read_timeout);\n\tresult = ((uint32_t)_buffer[0] << 16) + ((uint32_t)_buffer[1] << 8) + _buffer[2];\n\tif (_debug) {\n\t\tSerial.print("Reading MS5803 ADC");\n\t\tswitch (_measurement) {\n\t\t\tcase PRESSURE:    Serial.println(" Pressure: "   ); break;\n\t\t\tcase TEMPERATURE: Serial.println(" Temperature: "); break;\n\t\t}\n\t\tSerial.print("    buffer[0] = "); Serial.println(_buffer[0]);\n\t\tSerial.print("    buffer[1] = "); Serial.println(_buffer[1]);\n\t\tSerial.print("    buffer[2] = "); Serial.println(_buffer[2]);\n\t}\n\treturn result;\n}\n\nvoid serialPrintln64(int64_t val64){\n\tserialPrint64(val64);\n\tSerial.println();\n}\nvoid serialPrint64(int64_t val64){\n\tint32_t result_high = val64 / 10000000L;\n\tint32_t result_low = val64 - (10000000LL * result_high);\n\tSerial.print(result_high);\n\tSerial.print(result_low);\n}'