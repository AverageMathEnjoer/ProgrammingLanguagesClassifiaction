b'module Database.Beam.Migrate.Tool.Status where\n\nimport           Database.Beam.Migrate.Backend\nimport           Database.Beam.Migrate.Log\nimport           Database.Beam.Migrate.Tool.Backend\nimport           Database.Beam.Migrate.Tool.CmdLine\nimport           Database.Beam.Migrate.Tool.Diff\nimport           Database.Beam.Migrate.Tool.Registry\n\nimport           Data.Text (unpack)\nimport qualified Data.Text as T\nimport           Data.Time (LocalTime)\nimport           Data.UUID (UUID)\n\nimport           System.Console.ANSI\n\nimport           Text.Read\n\ndata MigrateStatus\n  = MigrateStatusNoCommits Bool {- whether the schema has been created or not -}\n  | MigrateStatusAtBranch UUID LocalTime PredicateDiff\n  deriving Show\n\ndisplayMigrateStatus :: MigrateCmdLine -> MigrationRegistry\n                     -> DatabaseName -> MigrateStatus\n                     -> IO ()\ndisplayMigrateStatus _ reg dbName sts = do\n  putStrLn ("Status for \'" ++ unDatabaseName dbName ++ "\':\\n")\n  let curHead = registryHeadCommit reg\n  case sts of\n    MigrateStatusNoCommits _ ->\n      putStr . unlines $\n      [ "No commit history in this database."\n      , ""\n      , "You have some choices: "\n      , ""\n      , "  1. Run \'beam-migrate database match -d DBNAME\' to attempt to determine"\n      , "     which commit this database is at. If you have a good idea of which"\n      , "     commit we\'re at, run "\n      , "     \'beam-migrate database match -d DBNAME --hint COMMIT\'"\n      , ""\n      , "  2. Run \'beam-migrate import -d DBNAME --commit\' to import the current"\n      , "     database state as a new migration from the empty state."\n      , ""\n      , "  3. Run \'beam-migrate migrate --auto -d DBNAME COMMIT\' to generate a"\n      , "     commit for the current database, and then an automatic migration"\n      , "     from that commit to the commit specified." ]\n    MigrateStatusAtBranch branchId timestamp (PredicateDiff expected actual) ->\n      case lookupSchema branchId [] reg of\n        Nothing ->\n          putStrLn . unlines $\n          [ "At commit " ++ show branchId ++ ", which is not registered in "\n          , "the registry."\n          , ""\n          , "This usually happens because this database is managed by another"\n          , "beam-migrate registry. Are you running \'beam-migrate\' from the"\n          , "right directory?" ]\n        Just sch -> do\n          putStrLn ("At commit " ++ show branchId ++ "\\n")\n          showCommit timestamp sch\n\n          let green x = setSGRCode [ SetColor Foreground Dull Green ] ++ x ++ setSGRCode [ Reset ]\n              yellow x = setSGRCode [ SetColor Foreground Dull Yellow ] ++ x ++ setSGRCode [ Reset ]\n              red x = setSGRCode [ SetColor Foreground Dull Red ] ++ x ++ setSGRCode [ Reset ]\n          if expected == actual\n            then putStrLn (green "Database matches its latest schema\\n")\n            else putStrLn (red "Database differs from registered schema.\\nRun \'beam-migrate diff\' for a full diff\\n")\n\n          if curHead /= branchId\n            then do\n              putStrLn (yellow "The database is at schema " ++ show branchId)\n              putStrLn (yellow "  but beam-migrate HEAD is at " ++ show curHead)\n              putStrLn "\\nRun \'beam-migrate migrate\' to move this database to the current HEAD"\n            else putStrLn "Everything is up-to-date"\n\nshowCommit :: LocalTime -> RegisteredSchemaInfo -> IO ()\nshowCommit atTime sch = do\n  let green x = setSGRCode [ SetColor Foreground Dull Green ] ++ x ++ setSGRCode [ Reset ]\n  putStrLn . unlines $\n    [  setSGRCode [ SetColor Foreground Dull Yellow ] ++ "schema " ++ show (registeredSchemaInfoHash sch)\n    , green "Date" ++ ":      " ++ show atTime\n    , green "Commiter" ++ ":  " ++ unpack (userInfoCommitter (registeredSchemaInfoCommitter sch))\n    , green "Formats" ++ ":   " ++\n      showMigrationFormats (registeredSchemaInfoFormats sch) ]\n  putStrLn (T.unpack . T.unlines . map ("    " <>) .\n             T.lines . registeredSchemaInfoMessage $ sch)\n\nhasBackendTables :: String -> BeamMigrationBackend be m -> IO Bool\nhasBackendTables connStr be@BeamMigrationBackend { backendTransact = transact } =\n  do res <- transact connStr (checkForBackendTables be)\n     case res of\n       Left err -> fail ("hasBackendTables: " ++ show err)\n       Right  x -> pure x\n\ngetStatus :: MigrateCmdLine -> MigrationRegistry -> DatabaseName -> IO MigrateStatus\ngetStatus cmdLine reg dbName = do\n  (db, _, SomeBeamMigrationBackend be) <- loadBackend cmdLine reg dbName\n  hasSchema <- hasBackendTables (migrationDbConnString db) be\n  if not hasSchema\n    then do\n      putStrLn "WARNING: Beam migrate not installed in this database. Run"\n      putStrLn "WARNING:"\n      putStrLn ("WARNING:  beam-migrate database upgrade " ++ unDatabaseName dbName)\n      putStrLn "WARNING:"\n      putStrLn "WARNING: to build the beam tables in the database"\n      pure (MigrateStatusNoCommits False)\n    else case be of\n           BeamMigrationBackend { backendTransact = transact } -> do\n             logEntry <- reportDdlErrors (transact (migrationDbConnString db) getLatestLogEntry)\n             case logEntry of\n               Nothing -> pure (MigrateStatusNoCommits True)\n               Just logEntry\' ->\n                 case readMaybe (unpack (_logEntryCommitId logEntry\')) of\n                   Nothing -> fail "Invalid commit id for last log entry"\n                   Just commitId -> do\n                     diff <- genDiffFromSources cmdLine reg\n                                                (PredicateFetchSourceDbHead db Nothing)\n                                                (PredicateFetchSourceCommit (Just (migrationDbBackend db)) commitId)\n                     pure (MigrateStatusAtBranch commitId (_logEntryDate logEntry\') diff)\n\ndisplayStatus :: MigrateCmdLine -> IO ()\ndisplayStatus MigrateCmdLine { migrateDatabase = Nothing } =\n  fail "No database specified"\ndisplayStatus cmdLine@(MigrateCmdLine { migrateDatabase = Just dbName }) = do\n  reg <- lookupRegistry cmdLine\n\n  case migrationRegistryMode reg of\n    BeamMigrateReady ->\n      putStrLn (setSGRCode [ SetColor Foreground Dull Green ] ++\n                "(ready to perform migrations)")\n    BeamMigrateCreatingSchema {} ->\n      putStrLn (setSGRCode [ SetColor Foreground Dull Red ] ++\n                "beam-migrate is currently in the process of creating a schema.\\n" ++\n                "Use \'beam-migrate abort\' to abort the schema creation process.\\n" ++\n                "Some commands will not proceed with a pending schema edit.")\n    BeamMigrateEditingMigration {} ->\n      putStrLn (setSGRCode [ SetColor Foreground Dull Red ] ++\n                "beam-migrate is currently in the process of editing a migration.\\n" ++\n                "Use \'beam-migrate abort\' to abort the migration editing process.\\n" ++\n                "Some commands will not proceed with a pending migration edit.")\n\n  putStrLn (setSGRCode [Reset])\n\n  migrateStatus <- getStatus cmdLine reg dbName\n\n  displayMigrateStatus cmdLine reg dbName migrateStatus\n'