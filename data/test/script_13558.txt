b"//1-d bit \nint valR[N], valL[N], bit[N];\nmap<int, int> id;\nvoid add(int x){\n\twhile(x<N){\n\t\tbit[x]++;\n\t\tx += x&(-x);\n\t}\n}\nint query(int x){\n\tint ans = 0;\n\twhile(x){\n\t\tans += bit[x];\n\t\tx -= x&(-x);\n\t}\n\treturn ans;\n}\nvoid suffix(){\n\tset<int> no;\n\t//for suffix queries\n\t//add all no's in the set that you will add + query\n\t//otherwise use lower_bound to find the correct id\n\tfo(i, n) no.insert(valL[i]);\n\tfo(i, n) no.insert(valR[i]);\n\tint pos = 1;\n\t//give IDs in descending order so that\n\t//suffix is handles as prefix\n\tfor(auto it = no.rbegin(); it != no.rend(); ++it)\n\t\tid[*it] = pos++;\n}\nint main()\n{\n\tios_base::sync_with_stdio(false);\n\tcin.tie(NULL);\n\tint i,k,j;\n\tclr(bit);\n\tcin>>n;\n\tfo(i, n)cin>>a[i];\n\tmap<int, int> cnt;\n\tFo(i, n-1, -1) valR[i] = 1+cnt[a[i]]++;\n\tcnt.clear();\n\tFo(i, 0, n) valL[i] = 1+cnt[a[i]]++;\n\tsuffix();\n\tll ans = 0;\n\tfo(i,n){\n\t\t//since suffix stored as prefix\n\t\t//[1,x-1] represent ans for >x\n\t\tans += query(id[valR[i]]-1);\n\t\tadd(id[valL[i]]);\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n} \n"