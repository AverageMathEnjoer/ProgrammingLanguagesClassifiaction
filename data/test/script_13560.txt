b'/*\n    SPDX-FileCopyrightText: 2020 Milian Wolff <mail@milianw.de>\n\n    SPDX-License-Identifier: LGPL-2.1-or-later\n*/\n\n#include <algorithm>\n#include <array>\n#include <cstdint>\n#include <iostream>\n#include <list>\n#include <random>\n#include <vector>\n\n#include <QVector>\n\n#include <boost/container/pmr/monotonic_buffer_resource.hpp>\n#include <boost/container/pmr/polymorphic_allocator.hpp>\n#include <boost/container/pmr/slist.hpp>\n#include <boost/container/slist.hpp>\n\n#include "../../src/analyze/allocationdata.h"\n\nconstexpr uint64_t MAX_TREE_DEPTH = 64;\nconstexpr uint64_t NO_BRANCH_DEPTH = 4;\nconstexpr uint64_t BRANCH_WIDTH = 8;\nconstexpr uint64_t NUM_TRACES = 1000000;\n\nusing Trace = std::array<uint64_t, MAX_TREE_DEPTH>;\n\nuint64_t generateIp(uint64_t level)\n{\n    if (level % NO_BRANCH_DEPTH) {\n        return level;\n    }\n    static std::mt19937_64 engine(0);\n    static std::uniform_int_distribution<uint64_t> dist(0, BRANCH_WIDTH - 1);\n    return dist(engine);\n}\n\nTrace generateTrace()\n{\n    Trace trace;\n    for (uint64_t i = 0; i < MAX_TREE_DEPTH; ++i) {\n        trace[i] = generateIp(i);\n    }\n    return trace;\n}\n\nstd::vector<Trace> generateTraces()\n{\n    std::vector<Trace> traces(NUM_TRACES);\n    std::generate(traces.begin(), traces.end(), generateTrace);\n    return traces;\n}\n\nnamespace Tree {\ntemplate <template <typename...> class Container>\nstruct Node\n{\n    AllocationData cost;\n    uint64_t ip = 0;\n    const Node* parent = nullptr;\n    Container<Node> children;\n};\n\ntemplate <template <typename...> class Container>\nvoid setParentsImpl(Container<Node<Container>>& nodes, const Node<Container>* parent)\n{\n    for (auto& node : nodes) {\n        node.parent = parent;\n        setParentsImpl(node.children, &node);\n    }\n}\n\nvoid setParents(QVector<Node<QVector>>& nodes, const Node<QVector>* parent)\n{\n    setParentsImpl(nodes, parent);\n}\n\nvoid setParents(std::vector<Node<std::vector>>& nodes, const Node<std::vector>* parent)\n{\n    setParentsImpl(nodes, parent);\n}\n\nvoid setParents(std::list<Node<std::list>>&, const Node<std::list>*)\n{\n    // nothing to do\n}\n\nvoid setParents(boost::container::slist<Node<boost::container::slist>>&, const Node<boost::container::slist>*)\n{\n    // nothing to do\n}\n\nvoid setParents(boost::container::pmr::slist<Node<boost::container::pmr::slist>>&,\n                const Node<boost::container::pmr::slist>*)\n{\n    // nothing to do\n}\n\ntemplate <template <typename...> class Container, typename... Allocator>\nContainer<Node<Container>> buildTree(const std::vector<Trace>& traces, const Allocator&... allocator)\n{\n    auto findNode = [&](Container<Node<Container>>* nodes, uint64_t ip, const Node<Container>* parent) {\n        auto it =\n            std::find_if(nodes->begin(), nodes->end(), [ip](const Node<Container>& node) { return node.ip == ip; });\n        if (it != nodes->end())\n            return it;\n        return nodes->insert(it, Node<Container> {{}, ip, parent, Container<Node<Container>> {allocator...}});\n    };\n\n    Container<Node<Container>> ret(allocator...);\n    const Node<Container>* parent = nullptr;\n    for (const auto& trace : traces) {\n        auto* nodes = &ret;\n        for (const auto& ip : trace) {\n            auto it = findNode(nodes, ip, parent);\n            it->cost.allocations++;\n            nodes = &it->children;\n            parent = &(*it);\n        }\n    }\n\n    setParents(ret, nullptr);\n\n    return ret;\n}\n\ntemplate <template <typename...> class Container>\nuint64_t numNodes(const Node<Container>& node)\n{\n    return std::accumulate(node.children.begin(), node.children.end(), uint64_t(1),\n                           [](uint64_t count, const Node<Container>& node) { return count + numNodes(node); });\n}\n\ntemplate <template <typename...> class Container>\nuint64_t numNodes(const Container<Node<Container>>& tree)\n{\n    return std::accumulate(tree.begin(), tree.end(), uint64_t(0),\n                           [](uint64_t count, const Node<Container>& node) { return count + numNodes(node); });\n}\n\ntemplate <template <typename...> class Container>\nstd::pair<uint64_t, uint64_t> run(const std::vector<Trace>& traces)\n{\n    const auto tree = buildTree<Container>(traces);\n    return {tree.size(), numNodes(tree)};\n}\n\ntemplate <>\nstd::pair<uint64_t, uint64_t> run<boost::container::pmr::slist>(const std::vector<Trace>& traces)\n{\n    boost::container::pmr::monotonic_buffer_resource mbr;\n    const auto tree = buildTree<boost::container::pmr::slist>(traces, &mbr);\n    return {tree.size(), numNodes<boost::container::pmr::slist>(tree)};\n}\n}\n\nenum class Tag\n{\n    QVector,\n    StdVector,\n    StdList,\n    BoostSlist,\n    BoostPmrSlist,\n};\n\nstd::pair<uint64_t, uint64_t> run(const std::vector<Trace>& traces, Tag tag)\n{\n    switch (tag) {\n    case Tag::QVector:\n        return Tree::run<QVector>(traces);\n    case Tag::StdVector:\n        return Tree::run<std::vector>(traces);\n    case Tag::StdList:\n        return Tree::run<std::list>(traces);\n    case Tag::BoostSlist:\n        return Tree::run<boost::container::slist>(traces);\n    case Tag::BoostPmrSlist:\n        return Tree::run<boost::container::pmr::slist>(traces);\n    }\n    Q_UNREACHABLE();\n}\n\nint main(int argc, char** argv)\n{\n    if (argc != 2) {\n        std::cerr << "usage: bench_tree [QVector|std::vector|std::list|boost::slist|boost::pmr::slist]\\n";\n        return 1;\n    }\n\n    const auto tag = [&]() {\n        auto t = std::string(argv[1]);\n        if (t == "QVector")\n            return Tag::QVector;\n        if (t == "std::vector")\n            return Tag::StdVector;\n        if (t == "std::list")\n            return Tag::StdList;\n        if (t == "boost::slist")\n            return Tag::BoostSlist;\n        if (t == "boost::pmr::slist")\n            return Tag::BoostPmrSlist;\n        std::cerr << "unhandled tag: " << t << "\\n";\n        exit(1);\n    }();\n\n    const auto traces = generateTraces();\n    const auto result = run(traces, tag);\n    std::cout << result.first << ", " << result.second << std::endl;\n    return 0;\n}\n'