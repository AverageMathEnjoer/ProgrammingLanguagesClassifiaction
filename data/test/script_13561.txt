b'#\' Univariate Statistics for Numerical Data\n#\'\n#\' Calculates mean, sd, min, Q1*, median, Q3*, max, MAD, IQR*, CV, \n#\' skewness*, SE.skewness*, and kurtosis* on numerical vectors. (*) Not \n#\' available when using sampling weights.\n#\'\n#\' @param x A numerical vector or a data frame.\n#\' @param var Unquoted expression referring to a specific column in \\code{x}.\n#\'   Provides support for piped function calls (e.g.\n#\'   \\code{my_df \\%>\\% descr(my_var)}.    \n#\' @param stats Character. Which stats to produce. Either \\dQuote{all} (default),\n#\'   \\dQuote{fivenum}, \\dQuote{common} (see \\emph{Details}), or a selection of :\n#\'   \\dQuote{mean}, \\dQuote{sd}, \\dQuote{min}, \\dQuote{q1}, \\dQuote{med},\n#\'   \\dQuote{q3}, \\dQuote{max}, \\dQuote{mad}, \\dQuote{iqr}, \\dQuote{cv},\n#\'   \\dQuote{skewness}, \\dQuote{se.skewness}, \\dQuote{kurtosis},\n#\'   \\dQuote{n.valid}, and \\dQuote{pct.valid}. Can be set globally via\n#\'   \\code{\\link{st_options}}, option \\dQuote{descr.stats}.\n#\' @param na.rm Logical. Argument to be passed to statistical functions. \n#\'   Defaults to \\code{TRUE}.\n#\' @param round.digits Numeric. Number of significant digits to display. \n#\'   Defaults to \\code{2}. Can be set globally with \\code{\\link{st_options}}.\n#\' @param transpose Logical. Make variables appears as columns, and stats as\n#\'   rows. Defaults to \\code{FALSE}. Can be set globally with\n#\'   \\code{\\link{st_options}}, option \\dQuote{descr.transpose}.\n#\' @param order Character. When analyzing more than one variable, this parameter\n#\'   determines how to order variables. Valid values are \\dQuote{sort} (or\n#\'   simply \\dQuote{s}), \\dQuote{preserve} (or \\dQuote{p}), or a vector\n#\'   containing all variable names in the desired order. Defaults to\n#\'   \\dQuote{sort}.\n#\' @param style Character. Style to be used by \\code{\\link[pander]{pander}}. One\n#\'   of \\dQuote{simple} (default), \\dQuote{grid}, \\dQuote{rmarkdown}, or\n#\'   \\dQuote{jira}. Can be set globally with \\code{\\link{st_options}}.\n#\' @param plain.ascii Logical. \\code{\\link[pander]{pander}} argument; when\n#\'   \\code{TRUE} (default), no markup characters will be used (useful when\n#\'   printing to console). If \\code{style = \'rmarkdown\'} is specified, value\n#\'   is set to \\code{FALSE} automatically. Can be set globally using\n#\'   \\code{\\link{st_options}}.\n#\' @param justify Character. Alignment of numbers in cells; \\dQuote{l} for left,\n#\'   \\dQuote{c} for center, or \\dQuote{r} for right (default). Has no effect on \n#\'   \\emph{html} tables.\n#\' @param headings Logical. Set to \\code{FALSE} to omit heading section. Can be\n#\'   set globally via \\code{\\link{st_options}}. \\code{TRUE} by default.\n#\' @param display.labels Logical. Show variable / data frame labels in heading\n#\'   section. Defaults to \\code{TRUE}. Can be set globally with\n#\'   \\code{\\link{st_options}}.\n#\' @param split.tables Character. \\code{\\link[pander]{pander}} argument that\n#\'   specifies how many characters wide a table can be. \\code{100} by default.\n#\' @param weights Numeric. Vector of weights having same length as \\emph{x}.\n#\'   \\code{NA} (default) indicates that no weights are used.\n#\' @param rescale.weights Logical. When set to \\code{TRUE}, a global constant is\n#\'   apply to make the total count equal \\code{nrow(x)}. \\code{FALSE} by default.\n#\' @param \\dots Additional arguments passed to \\code{\\link[pander]{pander}} or\n#\'   \\code{\\link[base]{format}}.\n#\'\n#\' @return An object having classes \\dQuote{\\emph{matrix}} and\n#\'   \\dQuote{\\emph{summarytools}} containing the statistics, with extra\n#\'   attributes used by \\code{\\link{print}} method and \\link{view} function.\n#\'\n#\' @examples\n#\' data("exams")\n#\' \n#\' # All stats for all numerical variabls\n#\' descr(exams)\n#\' \n#\' # Only common statistics\n#\' descr(exams, stats = "common")\n#\' \n#\' # Arbitrary selection of statistics, transposed\n#\' descr(exams, stats = c("mean", "sd", "min", "max"), transpose = TRUE)\n#\' \n#\' # Rmarkdown-ready\n#\' descr(exams, plain.ascii = FALSE, style = "rmarkdown")\n#\'\n#\' # Grouped statistics\n#\' data("tobacco")\n#\' with(tobacco, stby(BMI, gender, descr))\n#\'\n#\' # Grouped statistics, transposed\n#\' with(tobacco, stby(BMI, age.gr, descr, stats = "common", transpose = TRUE))\n#\'\n#\' \\dontrun{\n#\' # Show in Viewer (or browser if not in RStudio)\n#\' view(descr(exams))\n#\' \n#\' # Save to html file with title\n#\' print(descr(exams),\n#\'       file = "descr_exams.html", \n#\'       report.title = "BMI by Age Group",\n#\'       footnote = "<b>Schoolyear:</b> 2018-2019<br/><b>Semester:</b> Fall")\n#\' \n#\' }\n#\'\n#\' @keywords univar\n#\' @author Dominic Comtois, \\email{dominic.comtois@@gmail.com}\n#\' @export\n#\' @importFrom matrixStats weightedMean weightedSd weightedMedian weightedMad\n#\' @importFrom rapportools skewness kurtosis nvalid\n#\' @importFrom stats IQR mad median sd quantile\n#\' @importFrom utils head\n#\' @importFrom dplyr %>% as_tibble select starts_with summarize_all group_keys\n#\' @importFrom tidyr separate gather spread\ndescr <- function(x,\n                  var             = NULL,\n                  stats           = st_options("descr.stats"),\n                  na.rm           = TRUE,\n                  round.digits    = st_options("round.digits"),\n                  transpose       = st_options("descr.transpose"),\n                  order           = "sort",\n                  style           = st_options("style"),\n                  plain.ascii     = st_options("plain.ascii"),\n                  justify         = "r",\n                  headings        = st_options("headings"),\n                  display.labels  = st_options("display.labels"),\n                  split.tables    = 100,\n                  weights         = NA,\n                  rescale.weights = FALSE,\n                  ...) {\n  \n  # handle objects of class "grouped_df" (dplyr::group_by)\n  if (inherits(x, "grouped_df")) {\n    \n    if ("var" %in% names(match.call())) {\n      # var might contain a function call -- such as df %>% descr(na.omit(var1))\n      if (inherits(as.list(match.call()[-1])$var, "call")) {\n        var_obj <- eval(as.list(match.call()[-1])$var, envir = x)\n        varname <- intersect(colnames(x), \n                             as.character(as.list(match.call()[-1])$var))\n      } else {\n        var_obj <- x[[as.list(match.call()[-1])$var]]\n        varname <- deparse(substitute(var))\n      }\n    } else {\n      var_obj  <- x[ ,setdiff(colnames(x), group_vars(x))]\n    }\n    \n    parse_info <- try(\n      parse_args(sys.calls(), sys.frames(), match.call(),\n                 var_name  = (ncol(x) == 1),\n                 var_label = (ncol(x) == 1), caller = "descr"),\n      silent = TRUE)\n\n    outlist  <- list()\n    gr_ks    <- map_groups(group_keys(x))\n    gr_inds  <- attr(x, "groups")$.rows\n    \n    for (g in seq_along(gr_ks)) {\n      outlist[[g]] <- descr(x               = as_tibble(var_obj)[gr_inds[[g]], ],\n                            stats           = stats,\n                            na.rm           = na.rm,\n                            round.digits    = round.digits,\n                            transpose       = transpose,\n                            order           = order,\n                            style           = style,\n                            plain.ascii     = plain.ascii,\n                            justify         = justify,\n                            headings        = headings,\n                            display.labels  = display.labels,\n                            split.tables    = split.tables,\n                            weights         = weights,\n                            rescale.weights = rescale.weights,\n                            ...             = ...)\n      \n      if (!inherits(parse_info, "try-error")) {\n        if (!is.null(parse_info$df_name))\n          attr(outlist[[g]], "data_info")$Data.frame <- parse_info$df_name\n        if (!is.null(parse_info$df_label))\n          attr(outlist[[g]], "data_info")$Data.frame.label <- parse_info$df_label\n        if (!is.null(parse_info$var_name)) {\n          attr(outlist[[g]], "data_info")$Variable <- parse_info$var_name\n        } else if (exists("varname")) {\n          attr(outlist[[g]], "data_info")$Variable <- varname\n          if (identical(colnames(outlist[[g]]), "value"))\n            colnames(outlist[[g]]) <- varname\n          if (identical(rownames(outlist[[g]]), "value"))\n            rownames(outlist[[g]]) <- varname\n        }\n        if (!is.null(parse_info$var_label))\n          attr(outlist[[g]], "data_info")$Variable.label <- parse_info$var_label\n      }\n      \n      attr(outlist[[g]], "data_info")$by_var <- \n        setdiff(colnames(attr(x, "groups")), ".rows")\n      \n      attr(outlist[[g]], "data_info")$Group    <- gr_ks[g]\n      attr(outlist[[g]], "data_info")$by_first <- g == 1\n      attr(outlist[[g]], "data_info")$by_last  <- g == length(gr_ks)\n    }\n    \n    if (length(group_vars(x)) == 1 && is.null(dim(var_obj))) {\n      names(outlist) <- sub(paste(group_vars(x), "= "), "", gr_ks)\n    } else {\n      names(outlist) <- gr_ks\n    }\n    class(outlist) <- c("stby")\n    attr(outlist, "groups") <- group_keys(x)\n    return(outlist)\n  }\n  \n  # When var is provided, discard all other variables\n  if (is.data.frame(x) && ncol(x) > 1 && "var" %in% names(match.call())) {\n    \n    # var might contain a function call -- such as df %>% descr(na.omit(var1))\n    if (inherits(as.list(match.call()[-1])$var, "call")) {\n      x_obj   <- eval(as.list(match.call()[-1])$var, envir = x)\n      varname <- intersect(colnames(x),\n                           as.character(as.list(match.call()[-1])$var))\n    } else {\n      x_obj   <- x[[as.list(match.call()[-1])$var]]\n      varname <- deparse(substitute(var))\n    }\n  } else {\n    x_obj <- x\n    if (!is.null(colnames(x))) {\n      varname  <- colnames(x)\n    }\n  }\n  \n  # Validate arguments -------------------------------------------------------\n  errmsg <- character()  # problems with arguments will be stored here\n  \n  if (is.null(x)) {\n    tmp_x_name <- deparse(substitute(x))\n    stop(tmp_x_name, " is either NULL or does not exist")\n  }\n  \n  if (is.atomic(x_obj) && !is.numeric(x_obj)) {\n    errmsg %+=% "\'x\' must be numeric"\n  }\n  \n  # make x_obj a tibble\n  if (!inherits(x_obj, "tbl")) {\n    x.df <- as_tibble(x_obj)\n  } else {\n    x.df <- x_obj\n  }\n  \n  # Get variable label\n  if (ncol(x.df) == 1) {\n    var_label <- label(x.df[[1]])\n  } else {\n    var_label <- NA\n  }\n  \n  if (!is.data.frame(x.df)) {\n    errmsg %+=% paste("\'x\' must be a numeric vector, a data.frame, a tibble,",\n                      "a data.table; attempted conversion to tibble failed")\n  }\n  \n  errmsg <- c(errmsg, check_args(match.call(), list(...)))\n  \n  valid_stats <- list(\n    no_wgts = c("mean", "sd", "min", "q1", "med", "q3","max", "mad", \n                "iqr", "cv", "skewness", "se.skewness", "kurtosis", \n                "n.valid", "pct.valid"),\n    wgts = c("mean", "sd", "min", "med", "max", "mad", "cv", \n             "n.valid", "pct.valid")\n  )\n  \n  if (identical(stats, "all")) {\n    stats <- valid_stats[[2 - as.numeric(identical(weights, NA))]]\n  } else if (identical(stats, "fivenum")) {\n    if (!identical(weights, NA)) {\n      errmsg %+=% paste("fivenum is not supported when weights are used; valid",\n                        "stats are:", paste(valid_stats$wgts, collapse = ", "))\n      \n    }\n    stats <- c("min", "q1", "med", "q3", "max")\n  } else if (identical(stats, "common")) {\n    stats <- c("mean", "sd", "min", "med", "max", "n.valid", "pct.valid")\n  } else {\n    stats <- tolower(stats)\n    invalid_stats <- \n      setdiff(stats, valid_stats[[2 - as.numeric(identical(weights, NA))]])\n    if (length(invalid_stats) > 0) {\n      errmsg %+=%\n        paste("The following statistics are not recognized, or not allowed: ",\n              paste(dQuote(invalid_stats), collapse = ", "))\n    }\n  }\n\n  if (length(errmsg) > 0) {\n    stop(paste(errmsg, collapse = "\\n  "))\n  }\n\n  # End of arguments validation ------------------------------------------------\n  \n  # When style is rmarkdown, make plain.ascii FALSE unless specified explicitly\n  if (style == "rmarkdown" && isTRUE(plain.ascii) && \n      (!"plain.ascii" %in% (names(match.call())))) {\n    plain.ascii <- FALSE\n  }\n  \n  # Get info about x from parsing function\n  parse_info <- try(\n    parse_args(sys.calls(), sys.frames(), match.call(),\n               var_name = (ncol(x.df) == 1),\n               var_label = (ncol(x.df) == 1), caller = "descr"),\n    silent = TRUE)\n  \n  if (inherits(parse_info, "try-error")) {\n    parse_info <- list()\n  }\n\n  if (!"var_name" %in% names(parse_info)) {\n    if (exists("varname")) {\n      parse_info$var_name <- varname\n    } else {\n      parse_info$var_name <- colnames(x.df)\n    }\n  }\n  \n  # Identify and exclude non-numerical columns from x\n  col_to_remove <- which(!vapply(x.df, is.numeric, logical(1)))\n  \n  if (length(col_to_remove) > 0) {\n    ignored             <- colnames(x.df)[col_to_remove]\n    x.df                <- x.df[-col_to_remove]\n    order               <- setdiff(order, ignored)\n    parse_info$var_name <- parse_info$var_name[-col_to_remove]\n  }\n  \n  if (ncol(x.df) == 0) {\n    stop("no numerical variables found in ", deparse(match.call()$x))\n  }\n\n  # Verify that the order argument is still valid after column removal\n  if (length(order) > 1) {\n    if (length(ind <- which(!colnames(x.df) %in% order)) > 0) {\n      message("column(s) not specified in \'order\' (",\n              paste(colnames(x.df)[ind], collapse = ", "), \n              ") will appear at the end of the table")\n      order <- c(order, colnames(x.df)[ind])\n    } \n  }\n  # No weights being used ------------------------------------------------------\n  if (identical(weights, NA)) {\n    \n    # Prepare the summarizing functions for dplyr::summarize; there are 3 stats\n    # that will be calculated later on so to not slow down the function\n    dummy <- function(x) NA\n    \n    summar_funs <- list(~ mean(., na.rm = na.rm),\n                        ~ sd(., na.rm = na.rm),\n                        ~ min(., na.rm = na.rm),\n                        ~ quantile(., probs = .25, type = 2, names = FALSE, \n                                   na.rm = na.rm),\n                        ~ median(., na.rm = na.rm),\n                        ~ quantile(., probs = .75, type = 2, names = FALSE, \n                                   na.rm = na.rm),\n                        ~ max(., na.rm = na.rm),\n                        ~ mad(., na.rm = na.rm),\n                        ~ IQR(., na.rm = na.rm),\n                        ~ dummy(.), # placeholder for cv\n                        ~ rapportools::skewness(., na.rm = na.rm),\n                        ~ dummy(.), # placeholder for se.skewnes\n                        ~ rapportools::kurtosis(., na.rm = na.rm),\n                        ~ rapportools::nvalid(., na.rm = na.rm),\n                        ~ dummy(.))  # placeholder for pct.valid\n    \n    fun_names <- c("mean", "sd", "min", "q1", "med", "q3", "max", "mad", "iqr",\n                   "cv", "skewness", "se.skewness", "kurtosis", "n.valid",\n                   "pct.valid")\n    \n    names(summar_funs) <- fun_names\n    summar_funs <- summar_funs[which(fun_names %in% stats)]\n\n    if (ncol(x.df) > 1) {\n      results <- suppressWarnings(\n        x.df %>% summarize_all(.funs = summar_funs) %>%\n          gather("variable", "value") %>%\n          separate("variable", c("var", "stat"), sep = "_(?=[^_]*$)") %>%\n          spread("var", "value")\n        )\n      \n      if (identical(order, "preserve")) {\n        results <- results[ ,c("stat", colnames(x.df))]\n      } else if (length(order) > 1) {\n        results <- results[ ,c("stat", order)]\n      }\n      \n      # Transform results into output object\n      output <- as.data.frame(t(results[ ,-1]))\n      colnames(output) <- results$stat\n    } else {\n      output <- x.df %>% summarize_all(.funs = summar_funs, na.rm = na.rm) %>%\n        as.data.frame\n      rownames(output) <- parse_info$var_name\n    }\n\n    # Calculate additional stats if needed\n    if ("cv" %in% stats) {\n      output$cv <- output$sd / output$mean\n    }\n    \n    if ("se.skewness" %in% stats) {\n      output$se.skewness <- \n        with(output, \n             sqrt((6 * n.valid * (n.valid - 1)) / \n                    ((n.valid - 2) * (n.valid + 1) * (n.valid + 3))))\n    }\n    \n    if ("pct.valid" %in% stats) {\n      output$pct.valid <- output$n.valid *100 / nrow(x.df)\n    }\n    \n    # Apply corrections where n.valid = 0\n    zerows <- which(output$n.valid == 0)\n    output[zerows, setdiff(stats, "n.valid")] <- NA\n    \n  } else {\n    \n    # Weights being used -------------------------------------------------------\n    \n    weights_string <- deparse(substitute(weights))\n\n    if (sum(is.na(weights)) > 0) {\n      warning("Missing values on weight variable have been detected and will",\n              "be treated as zeroes")\n      weights[is.na(weights)] <- 0\n    }\n\n    # If some weights are 0 or negative, delete rows\n    zero_wgts <- which(weights <= 0)\n    if (length(zero_wgts)) {\n      x.df <- x.df[-zero_wgts, ]\n      message(length(zero_wgts), " rows with weight <= 0 were deleted")\n    }\n\n    # If weights are in x.df, remove them\n    if(length(parse_info$df_name) == 1 && \n       grepl(parse_info$df_name, weights_string)) {\n      wgts_vname <- sub(paste0(parse_info$df_name, "\\\\$"), "", weights_string)\n      ind <- which(names(x.df) == wgts_vname)\n      if (length(ind) == 1) {\n        x.df <- x.df[-ind]\n        parse_info$var_name <- setdiff(parse_info$var_name, wgts_vname)  \n      }\n    }\n    \n    # Build skeleton for output dataframe\n    output <- data.frame(mean      = numeric(),\n                         sd        = numeric(),\n                         min       = numeric(),\n                         med       = numeric(),\n                         max       = numeric(),\n                         mad       = numeric(),\n                         cv        = numeric(),\n                         n.valid   = numeric(),\n                         pct.valid = numeric())\n    \n    # Rescale weights if necessary\n    if (rescale.weights) {\n      weights <- weights / sum(weights) * nrow(x.df)\n    }\n    \n    for(i in seq_along(x.df)) {\n      variable <- as.numeric(x.df[[i]])\n      \n      # Extract number and proportion of missing and valid values\n      if (any(c("n.valid", "pct.valid") %in% stats)) {\n        n_valid <- sum(weights[which(!is.na(variable))])\n        p_valid <- n_valid / sum(weights)\n      } else {\n        # calculate n_valid for validation // all missing\n        n_valid <- sum(!is.na(variable))\n        p_valid <- NA\n      }\n      \n      # Remove missing values from variable and from corresponding weights\n      if (isTRUE(na.rm)) {\n        ind <- which(!is.na(variable))\n        variable <- variable[ind]\n        weights_tmp <- weights[ind]\n      }\n\n      # Calculate mean and sd if necessary\n      if (any(c("mean", "cv") %in% stats)) {\n        variable.mean <- weightedMean(variable, weights_tmp, refine = TRUE, \n                                      na.rm = na.rm)\n      }\n      \n      if (any(c("sd", "cv") %in% stats)) {\n        variable.sd <- weightedSd(variable, weights_tmp, na.rm = na.rm)\n      }\n      \n      # Calculate and insert stats into output dataframe\n      output[i, ] <-\n        c(ifelse("mean" %in% stats, variable.mean, NA),\n          ifelse("sd"   %in% stats, variable.sd, NA),\n          ifelse("min"  %in% stats, min(variable, na.rm = na.rm), NA),\n          ifelse("med"  %in% stats, weightedMedian(variable, weights_tmp, \n                                                   refine = TRUE, \n                                                   na.rm = na.rm), NA),\n          ifelse("max"  %in% stats, max(variable, na.rm = na.rm), NA),\n          ifelse("mad"  %in% stats, weightedMad(variable, weights_tmp, \n                                                refine = TRUE, \n                                                na.rm = na.rm), NA),\n          ifelse("cv"   %in% stats, variable.sd/variable.mean, NA),\n          ifelse("n.valid"   %in% stats, n_valid, NA),\n          ifelse("pct.valid" %in% stats, p_valid * 100, NA))\n    }\n    \n    rownames(output) <- parse_info$var_name\n    \n    # Apply corrections where n.valid = 0\n    zerows <- which(output$n.valid == 0)\n    output[zerows, setdiff(stats, "n.valid")] <- NA\n  }\n  \n  # Prepare output data -------------------------------------------------------\n  # Keep and order required stats from output\n  output <- output[ ,stats, drop = FALSE]\n  \n  # Corrections for special case where nrow = 0\n  if (nrow(x.df) == 0) {\n    for (cn in colnames(output)) {\n      if (cn == "n.valid") {\n        next\n      } else if (cn == "pct.valid") {\n        output[[cn]] <- NaN\n      } else {\n        output[[cn]] <- NA\n      }\n    }\n  }\n  \n  # Apply translations to colnames\n  for (i in seq_along(output)) {\n    if (colnames(output)[i] == "sd") {\n      colnames(output)[i] <- trs("sd.long")\n    } else {\n      colnames(output)[i] <- trs(colnames(output)[i])\n    }\n  }\n\n  # Transpose when transpose is FALSE; even though this is counter-intuitive,\n  # we prefer that the "vertical" version be the default one and that at the\n  # same time, the default value for transpose be FALSE.\n  if (!isTRUE(transpose)) {\n    output <- t(output)\n  }\n  \n  # Set class/attributes\n  class(output)            <- c("summarytools", class(output))\n  attr(output, "st_type")  <- "descr"\n  attr(output, "date")     <- Sys.Date()\n  attr(output, "fn_call")  <- match.call()\n  attr(output, "stats")    <- stats\n  data_info <-\n    list(\n      Data.frame       = ifelse("df_name" %in% names(parse_info), \n                                parse_info$df_name, NA),\n      Data.frame.label = ifelse("df_label" %in% names(parse_info), \n                                parse_info$df_label, NA),\n      Variable         = ifelse("var_name" %in% names(parse_info) && \n                                  length(parse_info$var_name) == 1,\n                                parse_info$var_name, NA),\n      Variable.label   = ifelse("var_label" %in% names(parse_info) &&\n                                  length(parse_info$var_label) == 1,\n                                parse_info$var_label,\n                                ifelse(!is.na(var_label), var_label, NA)),\n      Weights          = ifelse(identical(weights, NA), NA,\n                                sub(pattern = paste0(parse_info$df_name, "$"), \n                                    replacement = "", x = weights_string, \n                                    fixed = TRUE)),\n      by_var           = NA,\n      Group            = ifelse("by_group" %in% names(parse_info),\n                                parse_info$by_group, NA),\n      by_first         = ifelse("by_group" %in% names(parse_info), \n                                parse_info$by_first, NA),\n      by_last          = ifelse("by_group" %in% names(parse_info), \n                                parse_info$by_last, NA),\n      transposed       = transpose,\n      N.Obs            = nrow(x.df))\n  \n  if ("by_var" %in% names(parse_info)) {\n    data_info$by_var <- parse_info$by_var\n  }\n  \n  attr(output, "data_info") <- data_info[!is.na(data_info)]\n  \n  attr(output, "format_info") <- list(style          = style,\n                                      round.digits   = round.digits,\n                                      plain.ascii    = plain.ascii,\n                                      justify        = justify,\n                                      headings       = headings,\n                                      display.labels = display.labels,\n                                      split.tables   = split.tables)\n  \n  if (nrow(x.df) == 0) {\n    attr(output, "format_info") %+=% list(missing = "N/A")\n  }\n  \n  attr(output, "user_fmt") <- list(... = ...)\n  \n  attr(output, "lang") <- st_options("lang")\n  \n  if (exists("ignored"))\n    attr(output, "ignored") <- ignored\n  \n  return(output)\n}\n'