b'package com.quyunshuo.androidbaseframemvvm.base.utils\n\nimport android.app.Activity\nimport android.content.Context\nimport android.view.View\nimport android.view.inputmethod.InputMethodManager\nimport com.quyunshuo.androidbaseframemvvm.base.BaseApplication\nimport java.lang.reflect.Field\n\n/**\n * \xe8\xa7\xa3\xe5\x86\xb3 Android \xe8\x87\xaa\xe8\xba\xab\xe7\x9a\x84 Bug\n *\n * @author Qu Yunshuo\n * @since 2020/10/22\n */\nclass AndroidBugFixUtils {\n\n    /**\n     * \xe8\xa7\xa3\xe5\x86\xb3 InputMethodManager \xe9\x80\xa0\xe6\x88\x90\xe7\x9a\x84\xe5\x86\x85\xe5\xad\x98\xe6\xb3\x84\xe9\x9c\xb2\n     *\n     * \xe4\xbd\xbf\xe7\x94\xa8\xe6\x96\xb9\xe5\xbc\x8f\xef\xbc\x9a\n     * ```\n     * override fun onDestroy() {\n     *     AndroidBugFixUtils().fixSoftInputLeaks(this)\n     *     super.onDestroy()\n     * }\n     * ```\n     */\n    fun fixSoftInputLeaks(activity: Activity) {\n        val imm =\n            BaseApplication.context.getSystemService(Context.INPUT_METHOD_SERVICE) as InputMethodManager\n        val leakViews = arrayOf("mLastSrvView", "mCurRootView", "mServedView", "mNextServedView")\n        for (leakView in leakViews) {\n            try {\n                val leakViewField: Field =\n                    InputMethodManager::class.java.getDeclaredField(leakView) ?: continue\n                if (!leakViewField.isAccessible) leakViewField.isAccessible = true\n                val view: Any? = leakViewField.get(imm)\n                if (view !is View) continue\n                if (view.rootView == activity.window.decorView.rootView) {\n                    leakViewField.set(imm, null)\n                }\n            } catch (t: Throwable) {\n            }\n        }\n    }\n}'