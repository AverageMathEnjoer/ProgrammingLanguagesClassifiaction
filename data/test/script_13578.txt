b'\xef\xbb\xbfusing System.Runtime.InteropServices;\nusing System.Text;\n\nnamespace XboxDownload\n{\n    internal class ClassMbr\n    {\n        public const string MBR = "0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000123456780000";\n\n        const uint GENERIC_READ = 0x80000000;\n        const uint GENERIC_WRITE = 0x40000000;\n        const uint OPEN_EXISTING = 3;\n        const uint FILE_BEGIN = 0;\n        const int FILE_SHARE_READ = 0x00000001;\n        const int FILE_SHARE_WRITE = 0x00000002;\n\n        [DllImport("Kernel32.dll", CharSet = CharSet.Unicode)]\n        extern static IntPtr CreateFile(string fileName, uint accessFlag, uint shareMode, IntPtr security, uint createFlag, uint attributeFlag, IntPtr tempfile);\n\n        [DllImport("Kernel32.dll")]\n        extern static bool ReadFile(IntPtr handle, [Out] byte[] buffer, uint bufferLength, ref uint length, IntPtr overLapped);\n\n        [DllImport("kernel32.dll")]\n        extern static bool WriteFile(IntPtr handle, byte[] buffer, int bufferLength, ref int length, IntPtr overLapped);\n\n        [DllImport("Kernel32.dll")]\n        extern static bool CloseHandle(IntPtr handle);\n\n        [DllImport("Kernel32.dll")]\n        extern static uint SetFilePointer(IntPtr handle, int offset, IntPtr distance, uint flag);\n\n        public static byte[] ReadMBR(string sDeviceID)\n        {\n            IntPtr DiskHandle = CreateFile(sDeviceID, GENERIC_READ, 0, IntPtr.Zero, OPEN_EXISTING, 0, IntPtr.Zero);\n            byte[] buffer = new byte[512];\n            uint length = 0;\n            _ = SetFilePointer(DiskHandle, 0, IntPtr.Zero, FILE_BEGIN);\n            ReadFile(DiskHandle, buffer, 512, ref length, IntPtr.Zero);\n            CloseHandle(DiskHandle);\n            return buffer;\n        }\n\n        public static bool WriteMBR(string sDeviceID, byte[] MBR)\n        {\n            IntPtr DiskHandle = CreateFile(sDeviceID, GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, (IntPtr)0, OPEN_EXISTING, 0, (IntPtr)0);\n            int length = 0;\n            _ = SetFilePointer(DiskHandle, 0, IntPtr.Zero, FILE_BEGIN);\n            bool b = WriteFile(DiskHandle, MBR, 512, ref length, (IntPtr)0);\n            CloseHandle(DiskHandle);\n            return b;\n        }\n\n        public static byte[] HexToByte(string byteStr)\n        {\n            byteStr = byteStr.ToUpper().Replace(" ", "");\n            int len = byteStr.Length / 2;\n            byte[] data = new byte[len];\n            for (int i = 0; i < len; i++)\n            {\n                data[i] = Convert.ToByte(byteStr.Substring(i * 2, 2), 16);\n            }\n            return data;\n        }\n\n        public static string ByteToHex(byte[] bytes)\n        {\n            StringBuilder sb = new ();\n            if (bytes.Length > 0)\n            {\n                foreach (var item in bytes)\n                {\n                    sb.Append(item.ToString("X2"));\n                }\n            }\n            return sb.ToString();\n        }\n\n        public static string ConvertBytes(ulong len)\n        {\n            double leng = Convert.ToDouble(len);\n            string[] sizes = { "Bytes", "KB", "MB", "GB", "TB", "PB", "EB", "ZB", "YB" };\n            int order = 0;\n            while (leng >= 1024 && order + 1 < sizes.Length)\n            {\n                order++;\n                leng /= 1024;\n            }\n            return String.Format("{0:#.00} {1}", leng, sizes[order]);\n        }\n    }\n}\n'