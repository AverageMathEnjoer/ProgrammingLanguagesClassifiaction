b'{-# LANGUAGE CPP #-}\n{-# LANGUAGE GADTs #-}\n{-# LANGUAGE LambdaCase #-}\n{-# LANGUAGE RankNTypes #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n\n-- |\n-- Module      : Hoodle.GUI.Reflect\n-- Copyright   : (c) 2013, 2014 Ian-Woo Kim\n--\n-- License     : BSD3\n-- Maintainer  : Ian-Woo Kim <ianwookim@gmail.com>\n-- Stability   : experimental\n-- Portability : GHC\nmodule Hoodle.GUI.Reflect where\n\nimport Control.Lens (Lens\', view, (.~), (^.), _1, _2, _3)\nimport Control.Monad (when)\nimport qualified Control.Monad.State as St\nimport Control.Monad.Trans (liftIO)\nimport Data.Array.MArray (writeArray)\nimport qualified Data.Foldable as F (forM_, mapM_)\nimport qualified Data.Map as M (lookup)\nimport Data.Maybe (fromMaybe)\nimport Data.Word (Word8)\nimport qualified Graphics.UI.Gtk as Gtk\nimport Hoodle.Accessor (pureUpdateUhdl)\nimport Hoodle.Coroutine.Draw\n  ( doIOaction_,\n    invalidateAll,\n  )\nimport Hoodle.GUI.Menu\n  ( color2Int,\n    newPageMode2Int,\n    penType2Int,\n    point2Int,\n  )\nimport Hoodle.Type.Canvas\n  ( CanvasId,\n    currEraser,\n    currHighlighter,\n    currPen,\n    currentPageNum,\n    drawArea,\n    forBoth\',\n    pageArrangement,\n    penColor,\n    penSet,\n    penType,\n    penWidth,\n    unboxBiAct,\n    viewInfo,\n  )\nimport Hoodle.Type.Coroutine (MainCoroutine)\nimport Hoodle.Type.Enum\n  ( PenColor (ColorRGBA),\n    PenType (..),\n    penColorRGBAmap,\n    selectType,\n  )\nimport Hoodle.Type.Event (AllEvent (UsrEv), UserEvent (ActionOrdered))\nimport Hoodle.Type.HoodleState\n  ( HoodleState,\n    UIComponentSignalHandler,\n    UnitHoodle,\n    currentCanvasInfo,\n    currentUnit,\n    cursorInfo,\n    doesUseVariableCursor,\n    getCurrentCanvasId,\n    gtkUIManager,\n    hoodleModeState,\n    hoodleModeStateEither,\n    newPageMode,\n    newPageModeSignal,\n    pageModeSignal,\n    penColorSignal,\n    penInfo,\n    penModeSignal,\n    penPointSignal,\n    selectInfo,\n    setCurrentCanvasId,\n    settings,\n    uiComponentSignalHandler,\n    unitHoodles,\n  )\nimport Hoodle.Type.PageArrangement\n  ( CanvasCoordinate (..),\n    PageCoordinate (..),\n    PageNum (..),\n  )\nimport Hoodle.Type.Predefined\n  ( maxCursorHeight,\n    maxCursorWidth,\n  )\nimport Hoodle.Util (msgShout, (#))\nimport Hoodle.View.Coordinate\n  ( desktop2Canvas,\n    makeCanvasGeometry,\n    page2Desktop,\n  )\n\n-- |\nchangeCurrentCanvasId :: CanvasId -> MainCoroutine UnitHoodle\nchangeCurrentCanvasId cid = do\n  xst <- St.get\n  let uhdl = view (unitHoodles . currentUnit) xst\n  case setCurrentCanvasId cid uhdl of\n    Nothing -> return uhdl\n    Just uhdl\' -> do\n      pureUpdateUhdl (const uhdl\')\n      reflectViewModeUI\n      return uhdl\'\n\n-- | check current canvas id and new active canvas id and invalidate if it\'s\n--   changed.\nchkCvsIdNInvalidate :: CanvasId -> MainCoroutine ()\nchkCvsIdNInvalidate cid = do\n  currcid <- St.gets (getCurrentCanvasId . view (unitHoodles . currentUnit))\n  when (currcid /= cid) (changeCurrentCanvasId cid >> invalidateAll)\n\n-- | block signal for act\nblockWhile :: (Gtk.GObjectClass w) => Maybe (Gtk.ConnectId w) -> IO () -> IO ()\nblockWhile msig act = do\n  -- F.mapM_ (\\_ -> print "signal will be blocked") msig\n  F.mapM_ Gtk.signalBlock msig >> act >> F.mapM_ Gtk.signalUnblock msig\n\n-- | reflect view mode UI for current canvas info\nreflectViewModeUI :: MainCoroutine ()\nreflectViewModeUI = do\n  xstate <- St.get\n  let uhdl = view (unitHoodles . currentUnit) xstate\n      cinfobox = view currentCanvasInfo uhdl\n      ui = view gtkUIManager xstate\n  let mconnid = view (uiComponentSignalHandler . pageModeSignal) xstate\n  agr <- liftIO $ Gtk.uiManagerGetActionGroups ui\n  ra1 <-\n    maybe (error "reflectUI") return\n      =<< liftIO (Gtk.actionGroupGetAction (head agr) "ONEPAGEA")\n  let wra1 = Gtk.castToRadioAction ra1\n  unboxBiAct (pgmodupdate_s mconnid wra1) (pgmodupdate_c mconnid wra1) cinfobox\n  return ()\n  where\n    pgmodupdate_s mconnid wra1 _cinfo = do\n      liftIO $\n        blockWhile mconnid $\n          Gtk.set wra1 [Gtk.radioActionCurrentValue Gtk.:= 1]\n    pgmodupdate_c mconnid wra1 _cinfo = do\n      liftIO $\n        blockWhile mconnid $\n          Gtk.set wra1 [Gtk.radioActionCurrentValue Gtk.:= 0]\n\n-- |\nreflectPenModeUI :: MainCoroutine ()\nreflectPenModeUI = do\n  reflectUIRadio penModeSignal "PENA" f\n  reflectCursor False\n  where\n    f xst =\n      Just $\n        hoodleModeStateEither ((view hoodleModeState . view (unitHoodles . currentUnit)) xst)\n          # either\n            (\\_ -> (penType2Int . Left . view (penInfo . penType)) xst)\n            (\\_ -> (penType2Int . Right . view (selectInfo . selectType)) xst)\n\n-- |\nreflectPenColorUI :: MainCoroutine ()\nreflectPenColorUI = do\n  reflectUIRadio penColorSignal "BLUEA" f\n  reflectCursor False\n  where\n    f xst =\n      let mcolor =\n            case view (penInfo . penType) xst of\n              PenWork -> Just (view (penInfo . penSet . currPen . penColor) xst)\n              HighlighterWork -> Just (view (penInfo . penSet . currHighlighter . penColor) xst)\n              _ -> Nothing\n       in fmap color2Int mcolor\n\n-- |\nreflectPenWidthUI :: MainCoroutine ()\nreflectPenWidthUI = do\n  reflectUIRadio penPointSignal "PENVERYFINEA" f\n  reflectCursor False\n  where\n    f xst =\n      case view (penInfo . penType) xst of\n        PenWork ->\n          ( Just . point2Int PenWork\n              . view (penInfo . penSet . currPen . penWidth)\n          )\n            xst\n        HighlighterWork ->\n          let x =\n                ( Just . point2Int HighlighterWork\n                    . view (penInfo . penSet . currHighlighter . penWidth)\n                )\n                  xst\n           in -- y = view (penInfo.penSet.currHighlighter.penWidth) xst\n              x\n        EraserWork ->\n          ( Just . point2Int EraserWork\n              . view (penInfo . penSet . currEraser . penWidth)\n          )\n            xst\n        _ -> Nothing\n\n-- |\nreflectNewPageModeUI :: MainCoroutine ()\nreflectNewPageModeUI =\n  reflectUIRadio newPageModeSignal "NEWPAGEPLAINA" (Just . newPageMode2Int . (^. settings . newPageMode))\n\n-- |\nreflectUIRadio ::\n  Lens\' UIComponentSignalHandler (Maybe (Gtk.ConnectId Gtk.RadioAction)) ->\n  String ->\n  (HoodleState -> Maybe Int) ->\n  MainCoroutine ()\nreflectUIRadio lnz name f = do\n  xst <- St.get\n  let ui = view gtkUIManager xst\n      mconnid = view (uiComponentSignalHandler . lnz) xst\n  agr <- liftIO $ Gtk.uiManagerGetActionGroups ui\n  Just pma <- liftIO $ Gtk.actionGroupGetAction (head agr) name\n  let wpma = Gtk.castToRadioAction pma\n  update xst wpma mconnid\n  where\n    update xst wpma mconnid = do\n      f xst\n        # maybe\n          (return ())\n          ( \\v ->\n              doIOaction_ $ blockWhile mconnid (Gtk.set wpma [Gtk.radioActionCurrentValue Gtk.:= v])\n          )\n\n-- | this function must be moved to GUI.Reflect\nreflectUIToggle :: Gtk.UIManager -> String -> Bool -> IO ()\nreflectUIToggle ui str b = do\n  agr <-\n    Gtk.uiManagerGetActionGroups ui >>= \\case\n      [] -> error "No action group?"\n      y : _ -> return y\n  Just savea <- Gtk.actionGroupGetAction agr str -- ("SAVEA" :: String)\n  Gtk.actionSetSensitive savea b\n\n-- |\nreflectCursor :: Bool -> MainCoroutine ()\nreflectCursor isforced = do\n  xst <- St.get\n  let b = view (settings . doesUseVariableCursor) xst\n      pinfo = view penInfo xst\n      pcolor = view (penSet . currPen . penColor) pinfo\n      pwidth = view (penSet . currPen . penWidth) pinfo\n      cinfo = view cursorInfo xst\n      (ccolor, cwidth, cvar) = cinfo\n  when (pcolor /= ccolor || pwidth /= cwidth || b /= cvar || isforced) $ do\n    msgShout "reflectCursor: change cursor"\n    St.put . (cursorInfo . _1 .~ pcolor) . (cursorInfo . _2 .~ pwidth) . (cursorInfo . _3 .~ b) $ xst\n    doIOaction_ $\n      if b\n        then varyCursor xst\n        else do\n          let uhdl = view (unitHoodles . currentUnit) xst\n              cinfobox = view currentCanvasInfo uhdl\n              canvas = forBoth\' unboxBiAct (view drawArea) cinfobox\n          Just win <- Gtk.widgetGetWindow canvas\n          Gtk.postGUIAsync (Gtk.drawWindowSetCursor win Nothing)\n          return (UsrEv ActionOrdered)\n  where\n    varyCursor xst = do\n      putStrLn "reflectCursor : inside act"\n\n      -- Gtk.postGUIAsync $ do\n      let uhdl = view (unitHoodles . currentUnit) xst\n          -- mcur       = view cursorInfo xst\n          cinfobox = view currentCanvasInfo uhdl\n          canvas = forBoth\' unboxBiAct (view drawArea) cinfobox\n          cpn =\n            PageNum $\n              forBoth\' unboxBiAct (view currentPageNum) cinfobox\n          pinfo = view penInfo xst\n          pcolor = view (penSet . currPen . penColor) pinfo\n          pwidth = view (penSet . currPen . penWidth) pinfo\n      Just win <- Gtk.widgetGetWindow canvas\n      dpy <- Gtk.widgetGetDisplay canvas\n\n      geometry <-\n        forBoth\'\n          unboxBiAct\n          ( \\c ->\n              let arr = view (viewInfo . pageArrangement) c\n               in makeCanvasGeometry cpn arr canvas\n          )\n          cinfobox\n      let p2c = desktop2Canvas geometry . page2Desktop geometry\n          CvsCoord (x0, _y0) = p2c (cpn, PageCoord (0, 0))\n          CvsCoord (x1, _y1) = p2c (cpn, PageCoord (pwidth, pwidth))\n          cursize = x1 - x0\n          (r, g, b, a) = case pcolor of\n            ColorRGBA r\' g\' b\' a\' -> (r\', g\', b\', a\')\n            _ -> fromMaybe (0, 0, 0, 1) (M.lookup pcolor penColorRGBAmap)\n      pb <- Gtk.pixbufNew Gtk.ColorspaceRgb True 8 maxCursorWidth maxCursorHeight\n      let numPixels = maxCursorWidth * maxCursorHeight\n      pbData <- (Gtk.pixbufGetPixels pb :: IO (Gtk.PixbufData Int Word8))\n      F.forM_ [0 .. numPixels - 1] $ \\i -> do\n        let cvt :: Double -> Word8\n            cvt x\n              | x < 0.0039 = 0\n              | x > 0.996 = 255\n              | otherwise = fromIntegral (floor (x * 256 - 1) `mod` 256 :: Int)\n        if fromIntegral (i `mod` maxCursorWidth) < cursize\n          && fromIntegral (i `div` maxCursorWidth) < cursize\n          then do\n            writeArray pbData (4 * i) (cvt r)\n            writeArray pbData (4 * i + 1) (cvt g)\n            writeArray pbData (4 * i + 2) (cvt b)\n            writeArray pbData (4 * i + 3) (cvt a)\n          else do\n            writeArray pbData (4 * i) 0\n            writeArray pbData (4 * i + 1) 0\n            writeArray pbData (4 * i + 2) 0\n            writeArray pbData (4 * i + 3) 0\n\n      Gtk.drawWindowSetCursor win . Just\n        =<< Gtk.cursorNewFromPixbuf dpy pb (floor cursize `div` 2) (floor cursize `div` 2)\n      return (UsrEv ActionOrdered)\n'