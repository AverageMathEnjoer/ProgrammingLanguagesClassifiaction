b'package com.kyleduo.switchbutton;\n\nimport android.animation.ValueAnimator;\nimport android.annotation.SuppressLint;\nimport android.content.Context;\nimport android.content.res.ColorStateList;\nimport android.content.res.Resources;\nimport android.content.res.TypedArray;\nimport android.graphics.Canvas;\nimport android.graphics.Color;\nimport android.graphics.Paint;\nimport android.graphics.PointF;\nimport android.graphics.RectF;\nimport android.graphics.drawable.Drawable;\nimport android.graphics.drawable.StateListDrawable;\nimport android.os.Build;\nimport android.os.Parcel;\nimport android.os.Parcelable;\nimport android.text.Layout;\nimport android.text.StaticLayout;\nimport android.text.TextPaint;\nimport android.text.TextUtils;\nimport android.util.AttributeSet;\nimport android.util.TypedValue;\nimport android.view.MotionEvent;\nimport android.view.SoundEffectConstants;\nimport android.view.ViewConfiguration;\nimport android.view.ViewParent;\nimport android.view.animation.AccelerateDecelerateInterpolator;\nimport android.widget.CompoundButton;\n\n\n/**\n * SwitchButton\n *\n * @author kyleduo\n * @since 2014-09-24\n */\n\n@SuppressWarnings("unused")\npublic class SwitchButton extends CompoundButton {\n    public static final float DEFAULT_THUMB_RANGE_RATIO = 1.8f;\n    public static final int DEFAULT_THUMB_SIZE_DP = 20;\n    public static final int DEFAULT_THUMB_MARGIN_DP = 2;\n    public static final int DEFAULT_ANIMATION_DURATION = 250;\n    public static final int DEFAULT_TINT_COLOR = 0x327FC2;\n\n    private static final int[] CHECKED_PRESSED_STATE = new int[]{android.R.attr.state_checked, android.R.attr.state_enabled, android.R.attr.state_pressed};\n    private static final int[] UNCHECKED_PRESSED_STATE = new int[]{-android.R.attr.state_checked, android.R.attr.state_enabled, android.R.attr.state_pressed};\n\n    private Drawable mThumbDrawable, mBackDrawable;\n    private ColorStateList mBackColor, mThumbColor;\n    private float mThumbRadius, mBackRadius;\n    private RectF mThumbMargin;\n    private float mThumbRangeRatio;\n    private long mAnimationDuration;\n    // fade back drawable or color when dragging or animating\n    private boolean mFadeBack;\n    private int mTintColor;\n    private int mThumbWidth;\n    private int mThumbHeight;\n    private int mBackWidth;\n    private int mBackHeight;\n\n    private int mCurrThumbColor, mCurrBackColor, mNextBackColor, mOnTextColor, mOffTextColor;\n    private Drawable mCurrentBackDrawable, mNextBackDrawable;\n    private RectF mThumbRectF, mBackRectF, mSafeRectF, mTextOnRectF, mTextOffRectF;\n    private Paint mPaint;\n    // whether using Drawable for thumb or back\n    private boolean mIsThumbUseDrawable, mIsBackUseDrawable;\n    private boolean mDrawDebugRect = false;\n    private ValueAnimator mProgressAnimator;\n    // animation control\n    private float mProgress;\n    // temp position of thumb when dragging or animating\n    private RectF mPresentThumbRectF;\n    private float mStartX, mStartY, mLastX;\n    private int mTouchSlop;\n    private int mClickTimeout;\n    private Paint mRectPaint;\n    private CharSequence mTextOn;\n    private CharSequence mTextOff;\n    private TextPaint mTextPaint;\n    private Layout mOnLayout;\n    private Layout mOffLayout;\n    private float mTextWidth;\n    private float mTextHeight;\n    private int mTextThumbInset;\n    private int mTextExtra;\n    private int mTextAdjust;\n    // FIX #78,#85 : When restoring saved states, setChecked() called by super. So disable\n    // animation and event listening when restoring.\n    private boolean mRestoring = false;\n    private boolean mReady = false;\n    private boolean mCatch = false;\n    private UnsetPressedState mUnsetPressedState;\n\n    private CompoundButton.OnCheckedChangeListener mChildOnCheckedChangeListener;\n\n    public SwitchButton(Context context, AttributeSet attrs, int defStyle) {\n        super(context, attrs, defStyle);\n        init(attrs);\n    }\n\n    public SwitchButton(Context context, AttributeSet attrs) {\n        super(context, attrs);\n        init(attrs);\n    }\n\n    public SwitchButton(Context context) {\n        super(context);\n        init(null);\n    }\n\n    private void init(AttributeSet attrs) {\n        mTouchSlop = ViewConfiguration.get(getContext()).getScaledTouchSlop();\n        mClickTimeout = ViewConfiguration.getPressedStateDuration() + ViewConfiguration.getTapTimeout();\n\n        mPaint = new Paint(Paint.ANTI_ALIAS_FLAG);\n        mRectPaint = new Paint(Paint.ANTI_ALIAS_FLAG);\n        mRectPaint.setStyle(Paint.Style.STROKE);\n        mRectPaint.setStrokeWidth(getResources().getDisplayMetrics().density);\n\n        mTextPaint = getPaint();\n\n        mThumbRectF = new RectF();\n        mBackRectF = new RectF();\n        mSafeRectF = new RectF();\n        mThumbMargin = new RectF();\n        mTextOnRectF = new RectF();\n        mTextOffRectF = new RectF();\n\n        mProgressAnimator = ValueAnimator.ofFloat(0, 0).setDuration(DEFAULT_ANIMATION_DURATION);\n        mProgressAnimator.setInterpolator(new AccelerateDecelerateInterpolator());\n        mProgressAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {\n            @Override\n            public void onAnimationUpdate(ValueAnimator valueAnimator) {\n                setProgress((float) valueAnimator.getAnimatedValue());\n            }\n        });\n\n        mPresentThumbRectF = new RectF();\n\n        Resources res = getResources();\n        float density = res.getDisplayMetrics().density;\n\n        Drawable thumbDrawable = null;\n        ColorStateList thumbColor = null;\n        float margin = density * DEFAULT_THUMB_MARGIN_DP;\n        float marginLeft = 0;\n        float marginRight = 0;\n        float marginTop = 0;\n        float marginBottom = 0;\n        float thumbWidth = 0;\n        float thumbHeight = 0;\n        float thumbRadius = -1;\n        float backRadius = -1;\n        Drawable backDrawable = null;\n        ColorStateList backColor = null;\n        float thumbRangeRatio = DEFAULT_THUMB_RANGE_RATIO;\n        int animationDuration = DEFAULT_ANIMATION_DURATION;\n        boolean fadeBack = true;\n        int tintColor = 0;\n        String textOn = null;\n        String textOff = null;\n        int textThumbInset = 0;\n        int textExtra = 0;\n        int textAdjust = 0;\n\n        TypedArray ta = attrs == null ? null : getContext().obtainStyledAttributes(attrs, R.styleable.SwitchButton);\n        if (ta != null) {\n            thumbDrawable = ta.getDrawable(R.styleable.SwitchButton_kswThumbDrawable);\n            thumbColor = ta.getColorStateList(R.styleable.SwitchButton_kswThumbColor);\n            margin = ta.getDimension(R.styleable.SwitchButton_kswThumbMargin, margin);\n            marginLeft = ta.getDimension(R.styleable.SwitchButton_kswThumbMarginLeft, margin);\n            marginRight = ta.getDimension(R.styleable.SwitchButton_kswThumbMarginRight, margin);\n            marginTop = ta.getDimension(R.styleable.SwitchButton_kswThumbMarginTop, margin);\n            marginBottom = ta.getDimension(R.styleable.SwitchButton_kswThumbMarginBottom, margin);\n            thumbWidth = ta.getDimension(R.styleable.SwitchButton_kswThumbWidth, thumbWidth);\n            thumbHeight = ta.getDimension(R.styleable.SwitchButton_kswThumbHeight, thumbHeight);\n            thumbRadius = ta.getDimension(R.styleable.SwitchButton_kswThumbRadius, thumbRadius);\n            backRadius = ta.getDimension(R.styleable.SwitchButton_kswBackRadius, backRadius);\n            backDrawable = ta.getDrawable(R.styleable.SwitchButton_kswBackDrawable);\n            backColor = ta.getColorStateList(R.styleable.SwitchButton_kswBackColor);\n            thumbRangeRatio = ta.getFloat(R.styleable.SwitchButton_kswThumbRangeRatio, thumbRangeRatio);\n            animationDuration = ta.getInteger(R.styleable.SwitchButton_kswAnimationDuration, animationDuration);\n            fadeBack = ta.getBoolean(R.styleable.SwitchButton_kswFadeBack, true);\n            tintColor = ta.getColor(R.styleable.SwitchButton_kswTintColor, tintColor);\n            textOn = ta.getString(R.styleable.SwitchButton_kswTextOn);\n            textOff = ta.getString(R.styleable.SwitchButton_kswTextOff);\n            textThumbInset = ta.getDimensionPixelSize(R.styleable.SwitchButton_kswTextThumbInset, 0);\n            textExtra = ta.getDimensionPixelSize(R.styleable.SwitchButton_kswTextExtra, 0);\n            textAdjust = ta.getDimensionPixelSize(R.styleable.SwitchButton_kswTextAdjust, 0);\n            ta.recycle();\n        }\n\n        // click\n        ta = attrs == null ? null : getContext().obtainStyledAttributes(attrs, new int[]{android.R.attr.focusable, android.R.attr.clickable});\n        if (ta != null) {\n            boolean focusable = ta.getBoolean(0, true);\n            //noinspection ResourceType\n            @SuppressLint("ResourceType")\n            boolean clickable = ta.getBoolean(1, focusable);\n            setFocusable(focusable);\n            setClickable(clickable);\n            ta.recycle();\n        } else {\n            setFocusable(true);\n            setClickable(true);\n        }\n\n        // text\n        mTextOn = textOn;\n        mTextOff = textOff;\n        mTextThumbInset = textThumbInset;\n        mTextExtra = textExtra;\n        mTextAdjust = textAdjust;\n\n        // thumb drawable and color\n        mThumbDrawable = thumbDrawable;\n        mThumbColor = thumbColor;\n        mIsThumbUseDrawable = mThumbDrawable != null;\n        mTintColor = tintColor;\n        if (mTintColor == 0) {\n            mTintColor = getThemeAccentColorOrDefault(getContext(), DEFAULT_TINT_COLOR);\n        }\n        if (!mIsThumbUseDrawable && mThumbColor == null) {\n            mThumbColor = ColorUtils.generateThumbColorWithTintColor(mTintColor);\n            mCurrThumbColor = mThumbColor.getDefaultColor();\n        }\n\n        // thumbSize\n        mThumbWidth = ceil(thumbWidth);\n        mThumbHeight = ceil(thumbHeight);\n\n        // back drawable and color\n        mBackDrawable = backDrawable;\n        mBackColor = backColor;\n        mIsBackUseDrawable = mBackDrawable != null;\n        if (!mIsBackUseDrawable && mBackColor == null) {\n            mBackColor = ColorUtils.generateBackColorWithTintColor(mTintColor);\n            mCurrBackColor = mBackColor.getDefaultColor();\n            mNextBackColor = mBackColor.getColorForState(CHECKED_PRESSED_STATE, mCurrBackColor);\n        }\n\n        // margin\n        mThumbMargin.set(marginLeft, marginTop, marginRight, marginBottom);\n\n        // size & measure params must larger than 1\n        mThumbRangeRatio = mThumbMargin.width() >= 0 ? Math.max(thumbRangeRatio, 1) : thumbRangeRatio;\n\n        mThumbRadius = thumbRadius;\n        mBackRadius = backRadius;\n        mAnimationDuration = animationDuration;\n        mFadeBack = fadeBack;\n\n        mProgressAnimator.setDuration(mAnimationDuration);\n\n        // sync checked status\n        if (isChecked()) {\n            setProgress(1);\n        }\n    }\n\n    private static int getThemeAccentColorOrDefault(Context context, @SuppressWarnings("SameParameterValue") int defaultColor) {\n        int colorAttr;\n        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {\n            colorAttr = android.R.attr.colorAccent;\n        } else {\n            //Get colorAccent defined for AppCompat\n            colorAttr = context.getResources().getIdentifier("colorAccent", "attr", context.getPackageName());\n        }\n        TypedValue outValue = new TypedValue();\n        boolean resolved = context.getTheme().resolveAttribute(colorAttr, outValue, true);\n        return resolved ? outValue.data : defaultColor;\n    }\n\n    private Layout makeLayout(CharSequence text) {\n        return new StaticLayout(text, mTextPaint, (int) Math.ceil(Layout.getDesiredWidth(text, mTextPaint)), Layout.Alignment.ALIGN_CENTER, 1.f, 0, false);\n    }\n\n    @Override\n    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {\n        /*\n         * ensure textLayout\n         */\n        if (mOnLayout == null && !TextUtils.isEmpty(mTextOn)) {\n            mOnLayout = makeLayout(mTextOn);\n        }\n        if (mOffLayout == null && !TextUtils.isEmpty(mTextOff)) {\n            mOffLayout = makeLayout(mTextOff);\n        }\n\n        float onWidth = mOnLayout != null ? mOnLayout.getWidth() : 0;\n        float offWidth = mOffLayout != null ? mOffLayout.getWidth() : 0;\n        if (onWidth != 0 || offWidth != 0) {\n            mTextWidth = Math.max(onWidth, offWidth);\n        } else {\n            mTextWidth = 0;\n        }\n\n        float onHeight = mOnLayout != null ? mOnLayout.getHeight() : 0;\n        float offHeight = mOffLayout != null ? mOffLayout.getHeight() : 0;\n        if (onHeight != 0 || offHeight != 0) {\n            mTextHeight = Math.max(onHeight, offHeight);\n        } else {\n            mTextHeight = 0;\n        }\n\n        setMeasuredDimension(measureWidth(widthMeasureSpec), measureHeight(heightMeasureSpec));\n    }\n\n    /**\n     * SwitchButton use this formula to determine the final size of thumb, background and itself.\n     * <p>\n     * textWidth = max(onWidth, offWidth)\n     * thumbRange = thumbWidth * rangeRatio\n     * textExtraSpace = textWidth + textExtra - (moveRange - thumbWidth + max(thumbMargin.left, thumbMargin.right) + textThumbInset)\n     * backWidth = thumbRange + thumbMargin.left + thumbMargin.right + max(textExtraSpace, 0)\n     * contentSize = thumbRange + max(thumbMargin.left, 0) + max(thumbMargin.right, 0) + max(textExtraSpace, 0)\n     *\n     * @param widthMeasureSpec widthMeasureSpec\n     * @return measuredWidth\n     */\n    private int measureWidth(int widthMeasureSpec) {\n        int widthSize = MeasureSpec.getSize(widthMeasureSpec);\n        int widthMode = MeasureSpec.getMode(widthMeasureSpec);\n        int measuredWidth = widthSize;\n\n        if (mThumbWidth == 0 && mIsThumbUseDrawable) {\n            mThumbWidth = mThumbDrawable.getIntrinsicWidth();\n        }\n\n        int moveRange;\n        int textWidth = ceil(mTextWidth);\n        // how much the background should extend to fit text.\n        int textExtraSpace;\n        int contentSize;\n\n        if (mThumbRangeRatio == 0) {\n            mThumbRangeRatio = DEFAULT_THUMB_RANGE_RATIO;\n        }\n\n        if (widthMode == MeasureSpec.EXACTLY) {\n            contentSize = widthSize - getPaddingLeft() - getPaddingRight();\n\n            if (mThumbWidth != 0) {\n                moveRange = ceil(mThumbWidth * mThumbRangeRatio);\n                textExtraSpace = textWidth + mTextExtra - (moveRange - mThumbWidth + ceil(Math.max(mThumbMargin.left, mThumbMargin.right)));\n                mBackWidth = ceil(moveRange + mThumbMargin.left + mThumbMargin.right + Math.max(textExtraSpace, 0));\n                if (mBackWidth < 0) {\n                    mThumbWidth = 0;\n                }\n                if (moveRange + Math.max(mThumbMargin.left, 0) + Math.max(mThumbMargin.right, 0) + Math.max(textExtraSpace, 0) > contentSize) {\n                    mThumbWidth = 0;\n                }\n            }\n\n            if (mThumbWidth == 0) {\n                contentSize = widthSize - getPaddingLeft() - getPaddingRight();\n                moveRange = ceil(contentSize - Math.max(mThumbMargin.left, 0) - Math.max(mThumbMargin.right, 0));\n                if (moveRange < 0) {\n                    mThumbWidth = 0;\n                    mBackWidth = 0;\n                    return measuredWidth;\n                }\n                mThumbWidth = ceil(moveRange / mThumbRangeRatio);\n                mBackWidth = ceil(moveRange + mThumbMargin.left + mThumbMargin.right);\n                if (mBackWidth < 0) {\n                    mThumbWidth = 0;\n                    mBackWidth = 0;\n                    return measuredWidth;\n                }\n                textExtraSpace = textWidth + mTextExtra - (moveRange - mThumbWidth + ceil(Math.max(mThumbMargin.left, mThumbMargin.right)));\n                if (textExtraSpace > 0) {\n                    // since backWidth is determined by view width, so we can only reduce thumbSize.\n                    mThumbWidth = mThumbWidth - textExtraSpace;\n                }\n                if (mThumbWidth < 0) {\n                    mThumbWidth = 0;\n                    mBackWidth = 0;\n                    return measuredWidth;\n                }\n            }\n        } else {\n            /*\n            If parent view want SwitchButton to determine it\'s size itself, we calculate the minimal\n            size of it\'s content. Further more, we ignore the limitation of widthSize since we want\n            to display SwitchButton in its actual size rather than compress the shape.\n             */\n            if (mThumbWidth == 0) {\n                /*\n                If thumbWidth is not set, use the default one.\n                 */\n                mThumbWidth = ceil(getResources().getDisplayMetrics().density * DEFAULT_THUMB_SIZE_DP);\n            }\n            if (mThumbRangeRatio == 0) {\n                mThumbRangeRatio = DEFAULT_THUMB_RANGE_RATIO;\n            }\n\n            moveRange = ceil(mThumbWidth * mThumbRangeRatio);\n            textExtraSpace = ceil(textWidth + mTextExtra - (moveRange - mThumbWidth + Math.max(mThumbMargin.left, mThumbMargin.right) + mTextThumbInset));\n            mBackWidth = ceil(moveRange + mThumbMargin.left + mThumbMargin.right + Math.max(0, textExtraSpace));\n            if (mBackWidth < 0) {\n                mThumbWidth = 0;\n                mBackWidth = 0;\n                return measuredWidth;\n            }\n            contentSize = ceil(moveRange + Math.max(0, mThumbMargin.left) + Math.max(0, mThumbMargin.right) + Math.max(0, textExtraSpace));\n\n            measuredWidth = Math.max(contentSize, contentSize + getPaddingLeft() + getPaddingRight());\n        }\n        return measuredWidth;\n    }\n\n    private int measureHeight(int heightMeasureSpec) {\n        int heightSize = MeasureSpec.getSize(heightMeasureSpec);\n        int heightMode = MeasureSpec.getMode(heightMeasureSpec);\n        int measuredHeight = heightSize;\n\n        if (mThumbHeight == 0 && mIsThumbUseDrawable) {\n            mThumbHeight = mThumbDrawable.getIntrinsicHeight();\n        }\n        int contentSize;\n        int textExtraSpace;\n        if (heightMode == MeasureSpec.EXACTLY) {\n            if (mThumbHeight != 0) {\n                /*\n                If thumbHeight has been set, we calculate backHeight and check if there is enough room.\n                 */\n                mBackHeight = ceil(mThumbHeight + mThumbMargin.top + mThumbMargin.bottom);\n                mBackHeight = ceil(Math.max(mBackHeight, mTextHeight));\n                if (mBackHeight + getPaddingTop() + getPaddingBottom() - Math.min(0, mThumbMargin.top) - Math.min(0, mThumbMargin.bottom) > heightSize) {\n                    // No enough room, we set thumbHeight to zero to calculate these value again.\n                    mThumbHeight = 0;\n                }\n            }\n\n            if (mThumbHeight == 0) {\n                mBackHeight = ceil(heightSize - getPaddingTop() - getPaddingBottom() + Math.min(0, mThumbMargin.top) + Math.min(0, mThumbMargin.bottom));\n                if (mBackHeight < 0) {\n                    mBackHeight = 0;\n                    mThumbHeight = 0;\n                    return measuredHeight;\n                }\n                mThumbHeight = ceil(mBackHeight - mThumbMargin.top - mThumbMargin.bottom);\n            }\n            if (mThumbHeight < 0) {\n                mBackHeight = 0;\n                mThumbHeight = 0;\n                return measuredHeight;\n            }\n        } else {\n            if (mThumbHeight == 0) {\n                mThumbHeight = ceil(getResources().getDisplayMetrics().density * DEFAULT_THUMB_SIZE_DP);\n            }\n            mBackHeight = ceil(mThumbHeight + mThumbMargin.top + mThumbMargin.bottom);\n            if (mBackHeight < 0) {\n                mBackHeight = 0;\n                mThumbHeight = 0;\n                return measuredHeight;\n            }\n            textExtraSpace = ceil(mTextHeight - mBackHeight);\n            if (textExtraSpace > 0) {\n                mBackHeight += textExtraSpace;\n                mThumbHeight += textExtraSpace;\n            }\n            contentSize = Math.max(mThumbHeight, mBackHeight);\n\n            measuredHeight = Math.max(contentSize, contentSize + getPaddingTop() + getPaddingBottom());\n            measuredHeight = Math.max(measuredHeight, getSuggestedMinimumHeight());\n        }\n\n        return measuredHeight;\n    }\n\n    @Override\n    protected void onSizeChanged(int w, int h, int oldw, int oldh) {\n        super.onSizeChanged(w, h, oldw, oldh);\n        if (w != oldw || h != oldh) {\n            setup();\n        }\n    }\n\n    private int ceil(double dimen) {\n        return (int) Math.ceil(dimen);\n    }\n\n    /**\n     * set up the rect of back and thumb\n     */\n    private void setup() {\n        if (mThumbWidth == 0 || mThumbHeight == 0 || mBackWidth == 0 || mBackHeight == 0) {\n            return;\n        }\n\n        if (mThumbRadius == -1) {\n            mThumbRadius = Math.min(mThumbWidth, mThumbHeight) / 2f;\n        }\n        if (mBackRadius == -1) {\n            mBackRadius = Math.min(mBackWidth, mBackHeight) / 2f;\n        }\n\n        int contentWidth = getMeasuredWidth() - getPaddingLeft() - getPaddingRight();\n        int contentHeight = getMeasuredHeight() - getPaddingTop() - getPaddingBottom();\n\n        // max range of drawing content, when thumbMargin is negative, drawing range is larger than backWidth\n        int drawingWidth = ceil(mBackWidth - Math.min(0, mThumbMargin.left) - Math.min(0, mThumbMargin.right));\n        int drawingHeight = ceil(mBackHeight - Math.min(0, mThumbMargin.top) - Math.min(0, mThumbMargin.bottom));\n\n        float thumbTop;\n        if (contentHeight <= drawingHeight) {\n            thumbTop = getPaddingTop() + Math.max(0, mThumbMargin.top);\n        } else {\n            // center vertical in content area\n            thumbTop = getPaddingTop() + Math.max(0, mThumbMargin.top) + (contentHeight - drawingHeight + 1) / 2f;\n        }\n\n        float thumbLeft;\n        if (contentWidth <= mBackWidth) {\n            thumbLeft = getPaddingLeft() + Math.max(0, mThumbMargin.left);\n        } else {\n            thumbLeft = getPaddingLeft() + Math.max(0, mThumbMargin.left) + (contentWidth - drawingWidth + 1) / 2f;\n        }\n\n        mThumbRectF.set(thumbLeft, thumbTop, thumbLeft + mThumbWidth, thumbTop + mThumbHeight);\n\n        float backLeft = mThumbRectF.left - mThumbMargin.left;\n        mBackRectF.set(backLeft,\n                mThumbRectF.top - mThumbMargin.top,\n                backLeft + mBackWidth,\n                mThumbRectF.top - mThumbMargin.top + mBackHeight);\n\n        mSafeRectF.set(mThumbRectF.left, 0, mBackRectF.right - mThumbMargin.right - mThumbRectF.width(), 0);\n\n        float minBackRadius = Math.min(mBackRectF.width(), mBackRectF.height()) / 2.f;\n        mBackRadius = Math.min(minBackRadius, mBackRadius);\n\n        if (mBackDrawable != null) {\n            mBackDrawable.setBounds((int) mBackRectF.left, (int) mBackRectF.top, ceil(mBackRectF.right), ceil(mBackRectF.bottom));\n        }\n\n        if (mOnLayout != null) {\n            float onLeft = mBackRectF.left + (mBackRectF.width() + mTextThumbInset - mThumbWidth - mThumbMargin.right - mOnLayout.getWidth()) / 2f - mTextAdjust;\n            float onTop = mBackRectF.top + (mBackRectF.height() - mOnLayout.getHeight()) / 2;\n            mTextOnRectF.set(onLeft, onTop, onLeft + mOnLayout.getWidth(), onTop + mOnLayout.getHeight());\n        }\n\n        if (mOffLayout != null) {\n            float offLeft = mBackRectF.right - (mBackRectF.width() + mTextThumbInset - mThumbWidth - mThumbMargin.left - mOffLayout.getWidth()) / 2f - mOffLayout.getWidth() + mTextAdjust;\n            float offTop = mBackRectF.top + (mBackRectF.height() - mOffLayout.getHeight()) / 2;\n            mTextOffRectF.set(offLeft, offTop, offLeft + mOffLayout.getWidth(), offTop + mOffLayout.getHeight());\n        }\n\n        mReady = true;\n    }\n\n    @Override\n    protected void onDraw(Canvas canvas) {\n        super.onDraw(canvas);\n\n        if (!mReady) {\n            setup();\n        }\n        if (!mReady) {\n            return;\n        }\n\n        // fade back\n        if (mIsBackUseDrawable) {\n            if (mFadeBack && mCurrentBackDrawable != null && mNextBackDrawable != null) {\n                // fix #75, 70%A + 30%B != 30%B + 70%A, order matters when mix two layer of different alpha.\n                // So make sure the order of on/off layers never change during slide from one endpoint to another.\n                Drawable below = isChecked() ? mCurrentBackDrawable : mNextBackDrawable;\n                Drawable above = isChecked() ? mNextBackDrawable : mCurrentBackDrawable;\n\n                int alpha = (int) (255 * getProgress());\n                below.setAlpha(alpha);\n                below.draw(canvas);\n                alpha = 255 - alpha;\n                above.setAlpha(alpha);\n                above.draw(canvas);\n            } else {\n                mBackDrawable.setAlpha(255);\n                mBackDrawable.draw(canvas);\n            }\n        } else {\n            if (mFadeBack) {\n                int alpha;\n                int colorAlpha;\n\n                // fix #75\n                int belowColor = isChecked() ? mCurrBackColor : mNextBackColor;\n                int aboveColor = isChecked() ? mNextBackColor : mCurrBackColor;\n\n                // curr back\n                alpha = (int) (255 * getProgress());\n                colorAlpha = Color.alpha(belowColor);\n                colorAlpha = colorAlpha * alpha / 255;\n                mPaint.setARGB(colorAlpha, Color.red(belowColor), Color.green(belowColor), Color.blue(belowColor));\n                canvas.drawRoundRect(mBackRectF, mBackRadius, mBackRadius, mPaint);\n\n                // next back\n                alpha = 255 - alpha;\n                colorAlpha = Color.alpha(aboveColor);\n                colorAlpha = colorAlpha * alpha / 255;\n                mPaint.setARGB(colorAlpha, Color.red(aboveColor), Color.green(aboveColor), Color.blue(aboveColor));\n                canvas.drawRoundRect(mBackRectF, mBackRadius, mBackRadius, mPaint);\n\n                mPaint.setAlpha(255);\n            } else {\n                mPaint.setColor(mCurrBackColor);\n                canvas.drawRoundRect(mBackRectF, mBackRadius, mBackRadius, mPaint);\n            }\n        }\n\n        // text\n        Layout switchText = getProgress() > 0.5 ? mOnLayout : mOffLayout;\n        RectF textRectF = getProgress() > 0.5 ? mTextOnRectF : mTextOffRectF;\n        if (switchText != null && textRectF != null) {\n            int alpha = (int) (255 * (getProgress() >= 0.75 ? getProgress() * 4 - 3 : (getProgress() < 0.25 ? 1 - getProgress() * 4 : 0)));\n            int textColor = getProgress() > 0.5 ? mOnTextColor : mOffTextColor;\n            int colorAlpha = Color.alpha(textColor);\n            colorAlpha = colorAlpha * alpha / 255;\n            switchText.getPaint().setARGB(colorAlpha, Color.red(textColor), Color.green(textColor), Color.blue(textColor));\n            canvas.save();\n            canvas.translate(textRectF.left, textRectF.top);\n            switchText.draw(canvas);\n            canvas.restore();\n        }\n\n        // thumb\n        mPresentThumbRectF.set(mThumbRectF);\n        mPresentThumbRectF.offset(mProgress * mSafeRectF.width(), 0);\n        if (mIsThumbUseDrawable) {\n            mThumbDrawable.setBounds((int) mPresentThumbRectF.left, (int) mPresentThumbRectF.top, ceil(mPresentThumbRectF.right), ceil(mPresentThumbRectF.bottom));\n            mThumbDrawable.draw(canvas);\n        } else {\n            mPaint.setColor(mCurrThumbColor);\n            canvas.drawRoundRect(mPresentThumbRectF, mThumbRadius, mThumbRadius, mPaint);\n        }\n\n        if (mDrawDebugRect) {\n            mRectPaint.setColor(Color.parseColor("#AA0000"));\n            canvas.drawRect(mBackRectF, mRectPaint);\n            mRectPaint.setColor(Color.parseColor("#0000FF"));\n            canvas.drawRect(mPresentThumbRectF, mRectPaint);\n            mRectPaint.setColor(Color.parseColor("#000000"));\n            canvas.drawLine(mSafeRectF.left, mThumbRectF.top, mSafeRectF.right, mThumbRectF.top, mRectPaint);\n            mRectPaint.setColor(Color.parseColor("#00CC00"));\n            canvas.drawRect(getProgress() > 0.5 ? mTextOnRectF : mTextOffRectF, mRectPaint);\n        }\n    }\n\n    @Override\n    protected void drawableStateChanged() {\n        super.drawableStateChanged();\n\n        if (!mIsThumbUseDrawable && mThumbColor != null) {\n            mCurrThumbColor = mThumbColor.getColorForState(getDrawableState(), mCurrThumbColor);\n        } else {\n            setDrawableState(mThumbDrawable);\n        }\n\n        int[] nextState = isChecked() ? UNCHECKED_PRESSED_STATE : CHECKED_PRESSED_STATE;\n        ColorStateList textColors = getTextColors();\n        if (textColors != null) {\n            int defaultTextColor = textColors.getDefaultColor();\n            mOnTextColor = textColors.getColorForState(CHECKED_PRESSED_STATE, defaultTextColor);\n            mOffTextColor = textColors.getColorForState(UNCHECKED_PRESSED_STATE, defaultTextColor);\n        }\n        if (!mIsBackUseDrawable && mBackColor != null) {\n            mCurrBackColor = mBackColor.getColorForState(getDrawableState(), mCurrBackColor);\n            mNextBackColor = mBackColor.getColorForState(nextState, mCurrBackColor);\n        } else {\n            if (mBackDrawable instanceof StateListDrawable && mFadeBack) {\n                mBackDrawable.setState(nextState);\n                mNextBackDrawable = mBackDrawable.getCurrent().mutate();\n            } else {\n                mNextBackDrawable = null;\n            }\n            setDrawableState(mBackDrawable);\n            if (mBackDrawable != null) {\n                mCurrentBackDrawable = mBackDrawable.getCurrent().mutate();\n            }\n        }\n    }\n\n    @Override\n    public boolean onTouchEvent(MotionEvent event) {\n\n        if (!isEnabled() || !isClickable() || !isFocusable() || !mReady) {\n            return false;\n        }\n\n        int action = event.getAction();\n\n        float deltaX = event.getX() - mStartX;\n        float deltaY = event.getY() - mStartY;\n\n        switch (action) {\n            case MotionEvent.ACTION_DOWN:\n                mStartX = event.getX();\n                mStartY = event.getY();\n                mLastX = mStartX;\n                setPressed(true);\n                break;\n\n            case MotionEvent.ACTION_MOVE:\n                float x = event.getX();\n                setProgress(getProgress() + (x - mLastX) / mSafeRectF.width());\n                mLastX = x;\n                if (!mCatch && (Math.abs(deltaX) > mTouchSlop / 2f || Math.abs(deltaY) > mTouchSlop / 2f)) {\n                    if (deltaY == 0 || Math.abs(deltaX) > Math.abs(deltaY)) {\n                        catchView();\n                    } else if (Math.abs(deltaY) > Math.abs(deltaX)) {\n                        return false;\n                    }\n                }\n                break;\n\n            case MotionEvent.ACTION_CANCEL:\n            case MotionEvent.ACTION_UP:\n                mCatch = false;\n                float time = event.getEventTime() - event.getDownTime();\n                if (Math.abs(deltaX) < mTouchSlop && Math.abs(deltaY) < mTouchSlop && time < mClickTimeout) {\n                    performClick();\n                } else {\n                    boolean nextStatus = getStatusBasedOnPos();\n                    if (nextStatus != isChecked()) {\n                        playSoundEffect(SoundEffectConstants.CLICK);\n                        setChecked(nextStatus);\n                    } else {\n                        animateToState(nextStatus);\n                    }\n                }\n                if (isPressed()) {\n                    if (mUnsetPressedState == null) {\n                        mUnsetPressedState = new UnsetPressedState();\n                    }\n                    if (!post(mUnsetPressedState)) {\n                        mUnsetPressedState.run();\n                    }\n                }\n                break;\n\n            default:\n                break;\n        }\n        return true;\n    }\n\n\n    /**\n     * return the status based on position of thumb\n     *\n     * @return whether checked or not\n     */\n    private boolean getStatusBasedOnPos() {\n        return getProgress() > 0.5f;\n    }\n\n    private float getProgress() {\n        return mProgress;\n    }\n\n    private void setProgress(final float progress) {\n        float tempProgress = progress;\n        if (tempProgress > 1) {\n            tempProgress = 1;\n        } else if (tempProgress < 0) {\n            tempProgress = 0;\n        }\n        this.mProgress = tempProgress;\n        invalidate();\n    }\n\n    @Override\n    public boolean performClick() {\n        return super.performClick();\n    }\n\n    /**\n     * processing animation\n     *\n     * @param checked checked or unChecked\n     */\n    protected void animateToState(boolean checked) {\n        if (mProgressAnimator == null) {\n            return;\n        }\n        if (mProgressAnimator.isRunning()) {\n            mProgressAnimator.cancel();\n        }\n        mProgressAnimator.setDuration(mAnimationDuration);\n        if (checked) {\n            mProgressAnimator.setFloatValues(mProgress, 1f);\n        } else {\n            mProgressAnimator.setFloatValues(mProgress, 0);\n        }\n        mProgressAnimator.start();\n    }\n\n    private void catchView() {\n        ViewParent parent = getParent();\n        if (parent != null) {\n            parent.requestDisallowInterceptTouchEvent(true);\n        }\n        mCatch = true;\n    }\n\n    @Override\n    public void setChecked(final boolean checked) {\n        // animate before super.setChecked() become user may call setChecked again in OnCheckedChangedListener\n        if (isChecked() != checked) {\n            animateToState(checked);\n        }\n        if (mRestoring) {\n            setCheckedImmediatelyNoEvent(checked);\n        } else {\n            super.setChecked(checked);\n        }\n    }\n\n    public void setCheckedNoEvent(final boolean checked) {\n        if (mChildOnCheckedChangeListener == null) {\n            setChecked(checked);\n        } else {\n            super.setOnCheckedChangeListener(null);\n            setChecked(checked);\n            super.setOnCheckedChangeListener(mChildOnCheckedChangeListener);\n        }\n    }\n\n    public void setCheckedImmediatelyNoEvent(boolean checked) {\n        if (mChildOnCheckedChangeListener == null) {\n            setCheckedImmediately(checked);\n        } else {\n            super.setOnCheckedChangeListener(null);\n            setCheckedImmediately(checked);\n            super.setOnCheckedChangeListener(mChildOnCheckedChangeListener);\n        }\n    }\n\n    public void toggleNoEvent() {\n        if (mChildOnCheckedChangeListener == null) {\n            toggle();\n        } else {\n            super.setOnCheckedChangeListener(null);\n            toggle();\n            super.setOnCheckedChangeListener(mChildOnCheckedChangeListener);\n        }\n    }\n\n    public void toggleImmediatelyNoEvent() {\n        if (mChildOnCheckedChangeListener == null) {\n            toggleImmediately();\n        } else {\n            super.setOnCheckedChangeListener(null);\n            toggleImmediately();\n            super.setOnCheckedChangeListener(mChildOnCheckedChangeListener);\n        }\n    }\n\n    @Override\n    public void setOnCheckedChangeListener(OnCheckedChangeListener onCheckedChangeListener) {\n        super.setOnCheckedChangeListener(onCheckedChangeListener);\n        mChildOnCheckedChangeListener = onCheckedChangeListener;\n    }\n\n    public void setCheckedImmediately(boolean checked) {\n        super.setChecked(checked);\n        if (mProgressAnimator != null && mProgressAnimator.isRunning()) {\n            mProgressAnimator.cancel();\n        }\n        setProgress(checked ? 1 : 0);\n        invalidate();\n    }\n\n    public void toggleImmediately() {\n        setCheckedImmediately(!isChecked());\n    }\n\n    private void setDrawableState(Drawable drawable) {\n        if (drawable != null) {\n            int[] myDrawableState = getDrawableState();\n            drawable.setState(myDrawableState);\n            invalidate();\n        }\n    }\n\n    public boolean isDrawDebugRect() {\n        return mDrawDebugRect;\n    }\n\n    public void setDrawDebugRect(boolean drawDebugRect) {\n        mDrawDebugRect = drawDebugRect;\n        invalidate();\n    }\n\n    public long getAnimationDuration() {\n        return mAnimationDuration;\n    }\n\n    public void setAnimationDuration(long animationDuration) {\n        mAnimationDuration = animationDuration;\n    }\n\n    public Drawable getThumbDrawable() {\n        return mThumbDrawable;\n    }\n\n    public void setThumbDrawable(Drawable thumbDrawable) {\n        mThumbDrawable = thumbDrawable;\n        mIsThumbUseDrawable = mThumbDrawable != null;\n        refreshDrawableState();\n        mReady = false;\n        requestLayout();\n        invalidate();\n    }\n\n    public void setThumbDrawableRes(int thumbDrawableRes) {\n        setThumbDrawable(getDrawableCompat(getContext(), thumbDrawableRes));\n    }\n\n    public Drawable getBackDrawable() {\n        return mBackDrawable;\n    }\n\n    public void setBackDrawable(Drawable backDrawable) {\n        mBackDrawable = backDrawable;\n        mIsBackUseDrawable = mBackDrawable != null;\n        refreshDrawableState();\n        mReady = false;\n        requestLayout();\n        invalidate();\n    }\n\n    public void setBackDrawableRes(int backDrawableRes) {\n        setBackDrawable(getDrawableCompat(getContext(), backDrawableRes));\n    }\n\n    public ColorStateList getBackColor() {\n        return mBackColor;\n    }\n\n    public void setBackColor(ColorStateList backColor) {\n        mBackColor = backColor;\n        if (mBackColor != null) {\n            setBackDrawable(null);\n        }\n        invalidate();\n    }\n\n    public void setBackColorRes(int backColorRes) {\n        setBackColor(getColorStateListCompat(getContext(), backColorRes));\n    }\n\n    public ColorStateList getThumbColor() {\n        return mThumbColor;\n    }\n\n    public void setThumbColor(ColorStateList thumbColor) {\n        mThumbColor = thumbColor;\n        if (mThumbColor != null) {\n            setThumbDrawable(null);\n        }\n        invalidate();\n    }\n\n    public void setThumbColorRes(int thumbColorRes) {\n        setThumbColor(getColorStateListCompat(getContext(), thumbColorRes));\n    }\n\n    public float getThumbRangeRatio() {\n        return mThumbRangeRatio;\n    }\n\n    public void setThumbRangeRatio(float thumbRangeRatio) {\n        mThumbRangeRatio = thumbRangeRatio;\n        // We need to mark "ready" to false since requestLayout may not cause size changed.\n        mReady = false;\n        requestLayout();\n    }\n\n    public RectF getThumbMargin() {\n        return mThumbMargin;\n    }\n\n    public void setThumbMargin(RectF thumbMargin) {\n        if (thumbMargin == null) {\n            setThumbMargin(0, 0, 0, 0);\n        } else {\n            setThumbMargin(thumbMargin.left, thumbMargin.top, thumbMargin.right, thumbMargin.bottom);\n        }\n    }\n\n    public void setThumbMargin(float left, float top, float right, float bottom) {\n        mThumbMargin.set(left, top, right, bottom);\n        mReady = false;\n        requestLayout();\n    }\n\n    public void setThumbSize(int width, int height) {\n        mThumbWidth = width;\n        mThumbHeight = height;\n        mReady = false;\n        requestLayout();\n    }\n\n    public float getThumbWidth() {\n        return mThumbWidth;\n    }\n\n    public float getThumbHeight() {\n        return mThumbHeight;\n    }\n\n    public float getThumbRadius() {\n        return mThumbRadius;\n    }\n\n    public void setThumbRadius(float thumbRadius) {\n        mThumbRadius = thumbRadius;\n        if (!mIsThumbUseDrawable) {\n            invalidate();\n        }\n    }\n\n    public PointF getBackSizeF() {\n        return new PointF(mBackRectF.width(), mBackRectF.height());\n    }\n\n    public float getBackRadius() {\n        return mBackRadius;\n    }\n\n    public void setBackRadius(float backRadius) {\n        mBackRadius = backRadius;\n        if (!mIsBackUseDrawable) {\n            invalidate();\n        }\n    }\n\n    public boolean isFadeBack() {\n        return mFadeBack;\n    }\n\n    public void setFadeBack(boolean fadeBack) {\n        mFadeBack = fadeBack;\n    }\n\n    public int getTintColor() {\n        return mTintColor;\n    }\n\n    public void setTintColor(@SuppressWarnings("SameParameterValue") int tintColor) {\n        mTintColor = tintColor;\n        mThumbColor = ColorUtils.generateThumbColorWithTintColor(mTintColor);\n        mBackColor = ColorUtils.generateBackColorWithTintColor(mTintColor);\n        mIsBackUseDrawable = false;\n        mIsThumbUseDrawable = false;\n        // call this method to refresh color states\n        refreshDrawableState();\n        invalidate();\n    }\n\n    public void setText(CharSequence onText, CharSequence offText) {\n        mTextOn = onText;\n        mTextOff = offText;\n\n        mOnLayout = null;\n        mOffLayout = null;\n\n        mReady = false;\n        requestLayout();\n        invalidate();\n    }\n\n    public CharSequence getTextOn() {\n        return mTextOn;\n    }\n\n    public CharSequence getTextOff() {\n        return mTextOff;\n    }\n\n    public void setTextThumbInset(int textThumbInset) {\n        mTextThumbInset = textThumbInset;\n        mReady = false;\n        requestLayout();\n        invalidate();\n    }\n\n    public void setTextExtra(int textExtra) {\n        mTextExtra = textExtra;\n        mReady = false;\n        requestLayout();\n        invalidate();\n    }\n\n    public void setTextAdjust(int textAdjust) {\n        mTextAdjust = textAdjust;\n        mReady = false;\n        requestLayout();\n        invalidate();\n    }\n\n    @Override\n    public Parcelable onSaveInstanceState() {\n        Parcelable superState = super.onSaveInstanceState();\n        SavedState ss = new SavedState(superState);\n        ss.onText = mTextOn;\n        ss.offText = mTextOff;\n        return ss;\n    }\n\n    @Override\n    public void onRestoreInstanceState(Parcelable state) {\n        SavedState ss = (SavedState) state;\n        setText(ss.onText, ss.offText);\n        mRestoring = true;\n        super.onRestoreInstanceState(ss.getSuperState());\n        mRestoring = false;\n    }\n\n    /**\n     * Copied from compat library\n     *\n     * @param context context\n     * @param id      id\n     * @return Drawable\n     */\n    private Drawable getDrawableCompat(Context context, int id) {\n        final int version = Build.VERSION.SDK_INT;\n        if (version >= 21) {\n            return context.getDrawable(id);\n        } else {\n            //noinspection deprecation\n            return context.getResources().getDrawable(id);\n        }\n    }\n\n    /**\n     * Copied from compat library\n     *\n     * @param context context\n     * @param id      id\n     * @return ColorStateList\n     */\n    private ColorStateList getColorStateListCompat(Context context, int id) {\n        final int version = Build.VERSION.SDK_INT;\n        if (version >= 23) {\n            return context.getColorStateList(id);\n        } else {\n            //noinspection deprecation\n            return context.getResources().getColorStateList(id);\n        }\n    }\n\n    static class SavedState extends BaseSavedState {\n        CharSequence onText;\n        CharSequence offText;\n\n        SavedState(Parcelable superState) {\n            super(superState);\n        }\n\n        private SavedState(Parcel in) {\n            super(in);\n            onText = TextUtils.CHAR_SEQUENCE_CREATOR.createFromParcel(in);\n            offText = TextUtils.CHAR_SEQUENCE_CREATOR.createFromParcel(in);\n        }\n\n        @Override\n        public void writeToParcel(Parcel out, int flags) {\n            super.writeToParcel(out, flags);\n            TextUtils.writeToParcel(onText, out, flags);\n            TextUtils.writeToParcel(offText, out, flags);\n        }\n\n        public static final Parcelable.Creator<SavedState> CREATOR\n                = new Parcelable.Creator<SavedState>() {\n            public SavedState createFromParcel(Parcel in) {\n                return new SavedState(in);\n            }\n\n            public SavedState[] newArray(int size) {\n                return new SavedState[size];\n            }\n        };\n    }\n\n    private final class UnsetPressedState implements Runnable {\n        @Override\n        public void run() {\n            setPressed(false);\n        }\n    }\n}'