b"{-# LANGUAGE BangPatterns, CPP #-}\n\nimport Data.List\nimport System.Environment\nimport Control.Parallel\nimport Control.Parallel.Strategies\nimport Control.Applicative\n#ifdef PARSCHED \nimport PARSCHED\n#else\nimport Control.Monad.Par\n#endif\n\n-- Rough results, GHC 6.13: (val=777)\n--   V1 (SDM):             2.2s\n--   V2 (SDM):             2.7s\n--   V3 (SDM, parallel):   1.0s on 7 cores\n--   V4 (original):        got bored waiting\n--   V5 (HWL assoc):       5.2s\n--   V6 (SDM, Int result): 0.9s\n--   V7 (SDM, parallel):   0.2s on 7 cores\n\n-----------------------------------------------------------------------------\n-- Version 1: returns results as a list of list of coins\n\npayL :: Int -> [(Int,Int)] -> [Int] -> [[Int]]\npayL 0   coins     acc = [acc]\npayL _   []        acc = []\npayL val ((c,q):coins) acc\n  | c > val   = payL val coins acc\n  | otherwise = left ++ right\n  where\n    left  = payL (val - c) coins' (c:acc)\n    right = payL val coins acc\n\n    coins' | q == 1    = coins\n           | otherwise = (c,q-1) : coins\n\n-----------------------------------------------------------------------------\n-- Version 2: uses a custom AList type to avoid repeated appends\n\n-- The idea here is that by avoiding the append we might be able to\n-- parallelise this more easily by just forcing evaluation to WHNF at\n-- each level.  I haven't parallelised this version yet, though (V5\n-- below is much easier) --SDM\n\ndata AList a = ANil | ASing a | Append (AList a) (AList a)\n\nlenA :: AList a -> Int\nlenA ANil          = 0\nlenA (ASing _)     = 1\nlenA (Append l r)  = lenA l + lenA r\n\nappend ANil r = r\nappend l ANil = l -- **\nappend l r    = Append l r\n\n   -- making append less strict (omit ** above) can make the algorithm\n   -- faster in sequential mode, because it runs in constant space.\n   -- However, ** helps parallelism.\n\npayA :: Int -> [(Int,Int)] -> [Int] -> AList [Int]\npayA 0   coins     acc = ASing acc\npayA _   []        acc = ANil\npayA val ((c,q):coins) acc\n  | c > val   = payA val coins acc\n  | otherwise = append left right -- strict in l, maybe strict in r\n  where\n    left  = payA (val - c) coins' (c:acc)\n    right = payA val coins acc\n    coins' | q == 1    = coins\n           | otherwise = (c,q-1) : coins\n\n-----------------------------------------------------------------------------\n-- Version 3: parallel version of V2\n\npayA_par :: Int -> Int -> [(Int,Int)] -> [Int] -> AList [Int]\npayA_par 0     val coins acc = payA val coins acc\npayA_par _     0   coins acc = ASing acc\npayA_par _     _   []    acc = ANil\npayA_par depth val ((c,q):coins) acc\n  | c > val    = payA_par depth val coins acc\n  | otherwise  = res\n                \n  where\n    res = unEval $ pure append <*> rpar left <*> rwhnf right\n\n    left  = payA_par (if q == 1 then (depth-1) else depth) (val - c) coins' (c:acc)\n    right = payA_par (depth-1) val coins acc\n\n    coins' | q == 1    = coins\n           | otherwise = (c,q-1) : coins\n\n-----------------------------------------------------------------------------\n-- Version 4: original list-of-list version (very slow)\n\npay :: Int -> Int -> [Int] -> [Int] -> [[Int]]\npay _   0 coins accum   = [accum]\npay _   val [] _        = []\npay pri val coins accum = \n    res\t\t\n    where -- \n          coins'  = dropWhile (>val) coins\n          coin_vals = nub coins'      \n          res = concat ( map\n                           ( \\ c -> let \n                                      new_coins = \n                                          ((dropWhile (>c) coins')\\\\[c])\n                                    in \t\t\t   \n                                      pay (pri-1)\n\t\t\t\t          (val-c) \n                                          new_coins\n     \t                                  (c:accum)\n                           )\n                           coin_vals )\n\n\n-----------------------------------------------------------------------------\n-- Version 5: assoc-list version (by HWL?)\n\n-- assoc-list-based version; still multiple list traversals\npay1 :: Int -> Int -> [(Int,Int)] -> [(Int,Int)] -> [[(Int,Int)]]\npay1 _   0 coins accum   = [accum]\npay1 _   val [] _        = []\npay1 pri val coins accum = res\n    where --\n          coins'  = dropWhile ((>val) . fst) coins\n          res = concat ( \n                         map\n                           ( \\ (c,q) -> let \n                                          -- several traversals                                        \n                                          new_coins = \n                                            filter (not . (==0) . snd) $\n                                             map (\\ x'@(c',q') -> if c==c' then (c',q'-1) else x') $\n                                              dropWhile ((>c) . fst) $\n                                               coins'\n                                          new_accum = \n                                            map (\\ x'@(c',q') -> if c==c' then (c',q'+1) else x') accum\n                                        in \t\t\t   \n                                      \t  pay1 (pri-1)\n\t\t\t\t      \t      (val-c) \n                                      \t      new_coins\n     \t                              \t      new_accum\n                           )\n                           coins' )\n\n-----------------------------------------------------------------------------\n-- Version 6: just return the number of results, not the results themselves\n\npayN :: Int -> [(Int,Int)] -> Int\npayN 0   coins     = 1\npayN _   []        = 0\npayN val ((c,q):coins)\n  | c > val   = payN val coins\n  | otherwise = left + right\n  where\n    left  = payN (val - c) coins'\n    right = payN val coins\n\n    coins' | q == 1    = coins\n           | otherwise = (c,q-1) : coins\n\n-----------------------------------------------------------------------------\n-- Version 7: parallel version of payN\n\npayN_par :: Int -> Int -> [(Int,Int)] -> Int\npayN_par 0     val coins  = payN val coins\npayN_par _     0   coins  = 1\npayN_par _     _   []     = 0\npayN_par depth val ((c,q):coins)\n  | c > val    = payN_par depth val coins\n  | otherwise  = res\n                \n  where\n    res = right `par` left `pseq` left + right\n\n    left  = payN_par (if q == 1 then (depth-1) else depth) (val - c) coins'\n    right = payN_par (depth-1) val coins\n\n    coins' | q == 1    = coins\n           | otherwise = (c,q-1) : coins\n\n-----------------------------------------------------------------------------\n\n-----------------------------------------------------------------------------\n-- Version 8: monad-par version of payN\n-- Competitive with Version 7.\n\npayN_mp :: Int -> Int -> [(Int,Int)] -> Int\npayN_mp depth val coins = \n    runPar $ \n        payN_mpM depth val coins  \n\n-- payN_mpM :: Int -> Int -> [(Int,Int)] -> Par Int\npayN_mpM 0     val coins  = return $ payN val coins\npayN_mpM _     0   coins  = return 1\npayN_mpM _     _   []     = return 0\npayN_mpM depth val ((c,q):coins)\n  | c > val    = payN_mpM depth val coins\n  | otherwise  = res\n                \n  where\n    res = \n            do lv <- spawn $ left\n               r <- right\n               l <- get lv\n               return (l + r)\n\n    left  = payN_mpM (if q == 1 then (depth-1) else depth) (val - c) coins'\n    right = payN_mpM (depth-1) val coins\n\n    coins' | q == 1    = coins\n           | otherwise = (c,q-1) : coins\n\n-----------------------------------------------------------------------------\n\n\n-- driver\n\nmain = do\n         let vals = [250, 100, 25, 10, 5, 1]   \n         -- let quants = [1, 3, 2, 5, 7, 12]\t\t   -- small setup\n         -- let quants = [5, 8, 8, 9, 12, 17]           -- std setup\n         let quants = [55, 88, 88, 99, 122, 177]  -- large setup\n\n         let coins  = concat (zipWith replicate quants vals)\n             coins1 = zip vals quants\n\n         ls <- fmap (fmap read) getArgs\n         let [n,arg] = \n              case ls of\n                [n, arg] -> [n, arg]\n\t        []       -> [3, 500] -- Ideally it should test all...\n\n         case n of\n           -- sequential, list of results\n           1 -> print $ length $ payL arg coins1 []\n           -- sequential, append-list of results\n           2 -> print $ lenA   $ payA arg coins1 []\n           -- parallel, append-list of results\n           3 -> print $ lenA   $ payA_par 4 arg coins1 []\n\n           4 -> print $ length (pay 0 arg coins [])\n           5 -> print $ length (pay1 0 arg coins1 (map (\\(c,q) -> (c,0)) coins1))\n           6 -> print $ payN arg coins1\n           7 -> print $ payN_par 4 arg coins1\n           8 -> print $ payN_mp 4 arg coins1\n           \n"