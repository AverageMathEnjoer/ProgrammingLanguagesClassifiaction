b'{-# LANGUAGE DataKinds #-}\n{-# LANGUAGE DeriveGeneric #-}\n{-# LANGUAGE InstanceSigs #-}\n{-# LANGUAGE OverloadedStrings #-}\n{-# LANGUAGE QuasiQuotes #-}\n{-# LANGUAGE RecordWildCards #-}\n{-# LANGUAGE TypeApplications #-}\n{-# LANGUAGE TypeFamilies #-}\n\n-- | [Google build oauth2 web server application](https://developers.google.com/identity/protocols/oauth2/web-server)\nmodule Network.OAuth2.Provider.Google where\n\nimport Crypto.PubKey.RSA.Types\nimport Data.Aeson\nimport Data.Aeson qualified as Aeson\nimport Data.Bifunctor\nimport Data.ByteString.Contrib\nimport Data.Map.Strict qualified as Map\nimport Data.Maybe\nimport Data.Set qualified as Set\nimport Data.Text qualified as T\nimport Data.Text.Lazy (Text)\nimport Data.Text.Lazy qualified as TL\nimport Data.Time\nimport GHC.Generics\nimport Jose.Jwa\nimport Jose.Jws\nimport Jose.Jwt\nimport Network.OAuth.OAuth2\nimport Network.OAuth2.Experiment\nimport OpenSSL.EVP.PKey (toKeyPair)\nimport OpenSSL.PEM (\n  PemPasswordSupply (PwNone),\n  readPrivateKey,\n )\nimport OpenSSL.RSA\nimport URI.ByteString.QQ\n\n{-\nTo test at google playground, set redirect uri to "https://developers.google.com/oauthplayground"\n-}\n\ndata Google = Google deriving (Eq, Show)\n\ntype instance IdpUserInfo Google = GoogleUser\n\n-- * Authorization Code flow\n\ndefaultGoogleApp :: IdpApplication \'AuthorizationCode Google\ndefaultGoogleApp =\n  AuthorizationCodeIdpApplication\n    { idpAppClientId = ""\n    , idpAppClientSecret = ""\n    , idpAppScope =\n        Set.fromList\n          [ "https://www.googleapis.com/auth/userinfo.email"\n          , "https://www.googleapis.com/auth/userinfo.profile"\n          ]\n    , idpAppAuthorizeState = "CHANGE_ME"\n    , idpAppAuthorizeExtraParams = Map.empty\n    , idpAppRedirectUri = [uri|http://localhost|]\n    , idpAppName = "default-google-App"\n    , idpAppTokenRequestAuthenticationMethod = ClientSecretBasic\n    , idp = defaultGoogleIdp\n    }\n\n-- * Service Account\n\n-- | Service account key (in JSON format) that download from google\ndata GoogleServiceAccountKey = GoogleServiceAccountKey\n  { privateKey :: String\n  , clientEmail :: Text\n  , projectId :: Text\n  , privateKeyId :: Text\n  , clientId :: Text\n  , authUri :: Text\n  , tokenUri :: Text\n  , authProviderX509CertUrl :: Text\n  , clientX509CertUrl :: Text\n  }\n  deriving (Generic)\n\ninstance FromJSON GoogleServiceAccountKey where\n  parseJSON = genericParseJSON defaultOptions {fieldLabelModifier = camelTo2 \'_\'}\n\n-- * Service Account\n\nmkJwt ::\n  PrivateKey ->\n  -- | Private key\n  Text ->\n  -- | Issuer\n  Maybe Text ->\n  -- | impersonate user\n  Set.Set Scope ->\n  -- | Scope\n  Idp Google ->\n  IO (Either String Jwt)\nmkJwt privateKey iss muser scopes idp = do\n  now <- getCurrentTime\n  let payload =\n        bsToStrict $\n          Aeson.encode $\n            Aeson.object $\n              [ "iss" .= iss\n              , "scope" .= T.intercalate " " (map (TL.toStrict . unScope) $ Set.toList scopes)\n              , "aud" .= idpTokenEndpoint idp\n              , "exp" .= tToSeconds (addUTCTime (secondsToNominalDiffTime 300) now) -- 5 minutes expiration time\n              , "iat" .= tToSeconds now\n              ]\n                ++ maybe [] (\\a -> ["sub" .= a]) muser\n  first show <$> rsaEncode RS256 privateKey payload\n  where\n    tToSeconds = formatTime defaultTimeLocale "%s"\n\n-- | Read private RSA Key in PEM format\nreadPemRsaKey ::\n  -- | PEM content\n  String ->\n  IO (Either String PrivateKey)\nreadPemRsaKey pemStr = do\n  somePair <- readPrivateKey pemStr PwNone\n  pure $ case (toKeyPair somePair :: Maybe RSAKeyPair) of\n    Just k ->\n      Right $\n        PrivateKey\n          { private_pub =\n              PublicKey\n                { public_size = rsaSize k\n                , public_n = rsaN k\n                , public_e = rsaE k\n                }\n          , private_d = rsaD k\n          , private_p = rsaP k\n          , private_q = rsaQ k\n          , private_dP = fromMaybe 0 (rsaDMP1 k)\n          , private_dQ = fromMaybe 0 (rsaDMQ1 k)\n          , private_qinv = fromMaybe 0 (rsaIQMP k)\n          }\n    Nothing -> Left "unable to parse PEM to RSA key"\n\ndefaultServiceAccountApp :: Jwt -> IdpApplication \'JwtBearer Google\ndefaultServiceAccountApp jwt =\n  JwtBearerIdpApplication\n    { idpAppName = "google-sa-app"\n    , idpAppJwt = unJwt jwt\n    , idp = defaultGoogleIdp\n    }\n\n-- * IDP\n\ndefaultGoogleIdp :: Idp Google\ndefaultGoogleIdp =\n  Idp\n    { idpFetchUserInfo = authGetJSON @(IdpUserInfo Google)\n    , idpAuthorizeEndpoint = [uri|https://accounts.google.com/o/oauth2/v2/auth|]\n    , idpTokenEndpoint = [uri|https://oauth2.googleapis.com/token|]\n    , idpUserInfoEndpoint = [uri|https://www.googleapis.com/oauth2/v2/userinfo|]\n    }\n\n-- requires scope "https://www.googleapis.com/auth/userinfo.profile" to obtain "name".\n-- requires scopes "https://www.googleapis.com/auth/userinfo.email" to obtain "email".\ndata GoogleUser = GoogleUser\n  { name :: Text\n  , id :: Text\n  , email :: Text\n  }\n  deriving (Show, Generic)\n\ninstance FromJSON GoogleUser\n'