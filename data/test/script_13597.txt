b'import Data.List\nimport Data.List.Split\n\ntype Cell = Int\ntype Grid = [(Cell, Cell)] \n\nblankGrid :: String\nblankGrid = replicate 36 \'.\'\n\n-- The grid from the book\ng1 :: Grid\ng1 = [  (17, 18), -- Special vehicle - i.e. our car.\n        (1, 15), \n        (2, 9), \n        (3, 10), \n        (4, 11), \n        (5, 6), \n        (12, 19), \n        (13, 27), \n        (24, 26), \n        (31, 38), \n        (33, 34), \n        (36, 37), \n        (40, 41)]\n\n-- The grid from the image\ng2 :: Grid\ng2 = [  (16, 17), -- Special vehicle - i.e. our car.\n        (1, 2),\n        (8, 22),\n        (29, 36),\n        (11, 25),\n        (38, 40),\n        (33, 34),\n        (6, 20)]\n\ndrawGrid :: Grid -> IO ()\ndrawGrid g = putStr $ intersperse \' \' $ "\\n" ++ unlines (chunksOf 6 $ showGrid g)\n\nshowGrid :: Grid -> String\nshowGrid g = foldl superimpose blankGrid vehicleGrids\n  where\n    vehicles = zip vehicleNames (vehiclePositions g)\n    vehicleGrids = map showVehicle vehicles\n\ncellToArrayPos :: Cell -> Int\ncellToArrayPos c = (c `div` 7) * 6 + (c `mod` 7) - 1\n\nvehiclePositions :: Grid -> [[Cell]]\nvehiclePositions  = map vehiclePos\n  where\n    vehiclePos (a, b) \n        | isHorizontal (a, b)   = map cellToArrayPos  [a .. b]\n        | otherwise             = map cellToArrayPos $ verticalPositions (a, b)\n\nverticalPositions :: (Cell, Cell) -> [Int]\nverticalPositions (a, b) \n    | b - a > 12    = [a, a + 7, b]\n    | b - a == 7    = [a, b]\n    | otherwise     = []\n\nshowVehicle :: (Char, [Int]) -> String\nshowVehicle (c, xs) = gridPoints xs 0\n  where\n    gridPoints [] n   = replicate (36 - n) \'.\'\n    gridPoints (x:xs) n = replicate (x - n) \'.\' ++ [c] ++ gridPoints xs (x + 1)\n\nsuperimpose :: String -> String -> String\nsuperimpose = zipWith combine\n  where\n    combine :: Char -> Char -> Char\n    combine topCh bottomCh\n        | topCh == \'.\' && bottomCh == \'.\'   = \'.\'\n        | topCh == \'.\' && bottomCh /= \'.\'   = bottomCh\n        | topCh /= \'.\' && bottomCh == \'.\'   = topCh\n        | topCh /= \'.\' && bottomCh /= \'.\'   = \'X\'\n\nvehicleNames :: String\nvehicleNames = "@" ++ [\'a\'..] -- The first vehicle is our special one - we mark it with an @.\n\nisVertical :: (Cell, Cell) -> Bool\nisVertical (c1, c2) = c2 - c1 > 6 \n\nisHorizontal :: (Cell, Cell) -> Bool\nisHorizontal (c1, c2) = c2 - c1 < 6 \n'