b'module Main where\n\nimport Control.Monad (when)\nimport Control.Monad.State (runStateT)\nimport Data.Attoparsec.ByteString (parse)\nimport Data.Attoparsec.Types (IResult (Done))\nimport qualified Data.ByteString as B\nimport Data.Hoodle.Simple\n  ( Dimension (Dim),\n    Hoodle (..),\n    Page (..),\n  )\nimport Graphics.Hoodle.Render\n  ( initRenderContext,\n    renderPageStateT,\n  )\nimport Graphics.Rendering.Cairo\n  ( renderWith,\n    withPDFSurface,\n    withSVGSurface,\n  )\nimport System.Environment (getArgs)\nimport Text.Hoodle.Parse.Attoparsec (hoodle)\n\n-- |\nmain :: IO ()\nmain = do\n  args <- getArgs\n  when (length args /= 3) $ error "print1page mod infile outfile (mod = svg/pdf/png"\n  let mod = head args\n      infile = args !! 1\n      outfile = args !! 2\n  mh <- attoparsec (args !! 1)\n  case mh of\n    Nothing -> print "not parsed"\n    Just hoo -> do\n      ctxt <- initRenderContext hoo\n      let fstpage = head (hoodle_pages hoo)\n          Dim w h = page_dim fstpage\n          cairowork s = renderWith s $ do\n            runStateT (renderPageStateT fstpage) ctxt\n            return ()\n\n      let action\n            | mod == "svg" = withSVGSurface outfile w h cairowork\n            | mod == "pdf" = withPDFSurface outfile w h cairowork\n            | otherwise = return ()\n      action\n\n-- |\nattoparsec :: FilePath -> IO (Maybe Hoodle)\nattoparsec fp = do\n  bstr <- B.readFile fp\n  let r = parse hoodle bstr\n  case r of\n    Done _ h -> return (Just h)\n    _ -> return Nothing\n'