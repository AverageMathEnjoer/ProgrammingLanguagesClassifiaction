b'{-# LANGUAGE CPP #-}\n#ifdef __HADDOCK_VERSION__\n{-# OPTIONS_GHC -Wno-unused-imports #-}\n#endif\n\n#include "containers.h"\n\n-----------------------------------------------------------------------------\n-- |\n-- Module      :  Data.Sequence\n-- Copyright   :  (c) Ross Paterson 2005\n--                (c) Louis Wasserman 2009\n--                (c) Bertram Felgenhauer, David Feuer, Ross Paterson, and\n--                    Milan Straka 2014\n-- License     :  BSD-style\n-- Maintainer  :  libraries@haskell.org\n-- Portability :  portable\n--\n-- = Finite sequences\n--\n-- The @\'Seq\' a@ type represents a finite sequence of values of\n-- type @a@.\n--\n-- Sequences generally behave very much like lists.\n--\n-- * The class instances for sequences are all based very closely on those for\n-- lists.\n--\n-- * Many functions in this module have the same names as functions in\n-- the "Prelude" or in "Data.List". In almost all cases, these functions\n-- behave analogously. For example, \'filter\' filters a sequence in exactly the\n-- same way that @"Prelude".\'Prelude.filter\'@ filters a list. The only major\n-- exception is the \'lookup\' function, which is based on the function by\n-- that name in "Data.IntMap" rather than the one in "Prelude".\n--\n-- There are two major differences between sequences and lists:\n--\n-- * Sequences support a wider variety of efficient operations than\n-- do lists. Notably, they offer\n--\n--     * Constant-time access to both the front and the rear with\n--     \'<|\', \'|>\', \'viewl\', \'viewr\'. For recent GHC versions, this can\n--     be done more conveniently using the bidirectional patterns \'Empty\',\n--     \':<|\', and \':|>\'. See the detailed explanation in the \\"Pattern synonyms\\"\n--     section.\n--     * Logarithmic-time concatenation with \'><\'\n--     * Logarithmic-time splitting with \'splitAt\', \'take\' and \'drop\'\n--     * Logarithmic-time access to any element with\n--     \'lookup\', \'!?\', \'index\', \'insertAt\', \'deleteAt\', \'adjust\'\', and \'update\'\n--\n--   Note that sequences are typically /slower/ than lists when using only\n--   operations for which they have the same big-\\(O\\) complexity: sequences\n--   make rather mediocre stacks!\n--\n-- * Whereas lists can be either finite or infinite, sequences are\n-- always finite. As a result, a sequence is strict in its\n-- length. Ignoring efficiency, you can imagine that \'Seq\' is defined\n--\n--     @ data Seq a = Empty | a :<| !(Seq a) @\n--\n--     This means that many operations on sequences are stricter than\n--     those on lists. For example,\n--\n--     @ (1 : undefined) !! 0 = 1 @\n--\n--     but\n--\n--     @ (1 :<| undefined) ``index`` 0 = undefined @\n--\n-- Sequences may also be compared to immutable\n-- [arrays](https://hackage.haskell.org/package/array)\n-- or [vectors](https://hackage.haskell.org/package/vector).\n-- Like these structures, sequences support fast indexing,\n-- although not as fast. But editing an immutable array or vector,\n-- or combining it with another, generally requires copying the\n-- entire structure; sequences generally avoid that, copying only\n-- the portion that has changed.\n--\n-- == Detailed performance information\n--\n-- An amortized running time is given for each operation, with \\(n\\) referring\n-- to the length of the sequence and /i/ being the integral index used by\n-- some operations. These bounds hold even in a persistent (shared) setting.\n--\n-- Despite sequences being structurally strict from a semantic standpoint,\n-- they are in fact implemented using laziness internally. As a result,\n-- many operations can be performed /incrementally/, producing their results\n-- as they are demanded. This greatly improves performance in some cases. These\n-- functions include\n--\n-- * The \'Functor\' methods \'fmap\' and \'<$\', along with \'mapWithIndex\'\n-- * The \'Applicative\' methods \'<*>\', \'*>\', and \'<*\'\n-- * The zips: \'zipWith\', \'zip\', etc.\n-- * \'inits\', \'tails\'\n-- * \'fromFunction\', \'replicate\', \'intersperse\', and \'cycleTaking\'\n-- * \'reverse\'\n-- * \'chunksOf\'\n--\n-- Note that the \'Monad\' method, \'>>=\', is not particularly lazy. It will\n-- take time proportional to the sum of the logarithms of the individual\n-- result sequences to produce anything whatsoever.\n--\n-- Several functions take special advantage of sharing to produce\n-- results using much less time and memory than one might expect. These\n-- are documented individually for functions, but also include certain\n-- class methods:\n--\n-- \'<$\' and \'*>\' each take time and space proportional\n-- to the logarithm of the size of their result.\n--\n-- \'<*\' takes time and space proportional to the product of the length\n-- of its first argument and the logarithm of the length of its second\n-- argument.\n--\n-- == Warning\n--\n-- The size of a \'Seq\' must not exceed @maxBound::Int@. Violation\n-- of this condition is not detected and if the size limit is exceeded, the\n-- behaviour of the sequence is undefined. This is unlikely to occur in most\n-- applications, but some care may be required when using \'><\', \'<*>\', \'*>\', or\n-- \'>>\', particularly repeatedly and particularly in combination with\n-- \'replicate\' or \'fromFunction\'.\n--\n-- == Implementation\n--\n-- The implementation uses 2-3 finger trees annotated with sizes,\n-- as described in section 4.2 of\n--\n--    * Ralf Hinze and Ross Paterson,\n--      [\\"Finger trees: a simple general-purpose data structure\\"]\n--      (http://staff.city.ac.uk/~ross/papers/FingerTree.html),\n--      /Journal of Functional Programming/ 16:2 (2006) pp 197-217.\n--\n-----------------------------------------------------------------------------\n\n\nmodule Data.Sequence (\n    -- * Finite sequences\n#if defined(DEFINE_PATTERN_SYNONYMS)\n    Seq (Empty, (:<|), (:|>)),\n    -- $patterns\n#else\n    Seq,\n#endif\n    -- * Construction\n    empty,          -- :: Seq a\n    singleton,      -- :: a -> Seq a\n    (<|),           -- :: a -> Seq a -> Seq a\n    (|>),           -- :: Seq a -> a -> Seq a\n    (><),           -- :: Seq a -> Seq a -> Seq a\n    fromList,       -- :: [a] -> Seq a\n    fromFunction,   -- :: Int -> (Int -> a) -> Seq a\n    fromArray,      -- :: Ix i => Array i a -> Seq a\n    -- ** Repetition\n    replicate,      -- :: Int -> a -> Seq a\n    replicateA,     -- :: Applicative f => Int -> f a -> f (Seq a)\n    replicateM,     -- :: Applicative m => Int -> m a -> m (Seq a)\n    cycleTaking,    -- :: Int -> Seq a -> Seq a\n    -- ** Iterative construction\n    iterateN,       -- :: Int -> (a -> a) -> a -> Seq a\n    unfoldr,        -- :: (b -> Maybe (a, b)) -> b -> Seq a\n    unfoldl,        -- :: (b -> Maybe (b, a)) -> b -> Seq a\n    -- * Deconstruction\n    -- | Additional functions for deconstructing sequences are available\n    -- via the \'Data.Foldable.Foldable\' instance of \'Seq\'.\n\n    -- ** Queries\n    null,           -- :: Seq a -> Bool\n    length,         -- :: Seq a -> Int\n    -- ** Views\n    ViewL(..),\n    viewl,          -- :: Seq a -> ViewL a\n    ViewR(..),\n    viewr,          -- :: Seq a -> ViewR a\n    -- * Scans\n    scanl,          -- :: (a -> b -> a) -> a -> Seq b -> Seq a\n    scanl1,         -- :: (a -> a -> a) -> Seq a -> Seq a\n    scanr,          -- :: (a -> b -> b) -> b -> Seq a -> Seq b\n    scanr1,         -- :: (a -> a -> a) -> Seq a -> Seq a\n    -- * Sublists\n    tails,          -- :: Seq a -> Seq (Seq a)\n    inits,          -- :: Seq a -> Seq (Seq a)\n    chunksOf,       -- :: Int -> Seq a -> Seq (Seq a)\n    -- ** Sequential searches\n    takeWhileL,     -- :: (a -> Bool) -> Seq a -> Seq a\n    takeWhileR,     -- :: (a -> Bool) -> Seq a -> Seq a\n    dropWhileL,     -- :: (a -> Bool) -> Seq a -> Seq a\n    dropWhileR,     -- :: (a -> Bool) -> Seq a -> Seq a\n    spanl,          -- :: (a -> Bool) -> Seq a -> (Seq a, Seq a)\n    spanr,          -- :: (a -> Bool) -> Seq a -> (Seq a, Seq a)\n    breakl,         -- :: (a -> Bool) -> Seq a -> (Seq a, Seq a)\n    breakr,         -- :: (a -> Bool) -> Seq a -> (Seq a, Seq a)\n    partition,      -- :: (a -> Bool) -> Seq a -> (Seq a, Seq a)\n    filter,         -- :: (a -> Bool) -> Seq a -> Seq a\n    -- * Sorting\n    sort,           -- :: Ord a => Seq a -> Seq a\n    sortBy,         -- :: (a -> a -> Ordering) -> Seq a -> Seq a\n    sortOn,         -- :: Ord b => (a -> b) -> Seq a -> Seq a\n    unstableSort,   -- :: Ord a => Seq a -> Seq a\n    unstableSortBy, -- :: (a -> a -> Ordering) -> Seq a -> Seq a\n    unstableSortOn, -- :: Ord b => (a -> b) -> Seq a -> Seq a\n    -- * Indexing\n    lookup,         -- :: Int -> Seq a -> Maybe a\n    (!?),           -- :: Seq a -> Int -> Maybe a\n    index,          -- :: Seq a -> Int -> a\n    adjust,         -- :: (a -> a) -> Int -> Seq a -> Seq a\n    adjust\',        -- :: (a -> a) -> Int -> Seq a -> Seq a\n    update,         -- :: Int -> a -> Seq a -> Seq a\n    take,           -- :: Int -> Seq a -> Seq a\n    drop,           -- :: Int -> Seq a -> Seq a\n    insertAt,       -- :: Int -> a -> Seq a -> Seq a\n    deleteAt,       -- :: Int -> Seq a -> Seq a\n    splitAt,        -- :: Int -> Seq a -> (Seq a, Seq a)\n    -- ** Indexing with predicates\n    -- | These functions perform sequential searches from the left\n    -- or right ends of the sequence, returning indices of matching\n    -- elements.\n    elemIndexL,     -- :: Eq a => a -> Seq a -> Maybe Int\n    elemIndicesL,   -- :: Eq a => a -> Seq a -> [Int]\n    elemIndexR,     -- :: Eq a => a -> Seq a -> Maybe Int\n    elemIndicesR,   -- :: Eq a => a -> Seq a -> [Int]\n    findIndexL,     -- :: (a -> Bool) -> Seq a -> Maybe Int\n    findIndicesL,   -- :: (a -> Bool) -> Seq a -> [Int]\n    findIndexR,     -- :: (a -> Bool) -> Seq a -> Maybe Int\n    findIndicesR,   -- :: (a -> Bool) -> Seq a -> [Int]\n    -- * Folds\n    -- | General folds are available via the \'Data.Foldable.Foldable\' instance\n    -- of \'Seq\'.\n    foldMapWithIndex, -- :: Monoid m => (Int -> a -> m) -> Seq a -> m\n    foldlWithIndex, -- :: (b -> Int -> a -> b) -> b -> Seq a -> b\n    foldrWithIndex, -- :: (Int -> a -> b -> b) -> b -> Seq a -> b\n    -- * Transformations\n    mapWithIndex,   -- :: (Int -> a -> b) -> Seq a -> Seq b\n    traverseWithIndex, -- :: Applicative f => (Int -> a -> f b) -> Seq a -> f (Seq b)\n    reverse,        -- :: Seq a -> Seq a\n    intersperse,    -- :: a -> Seq a -> Seq a\n    -- ** Zips and unzip\n    zip,            -- :: Seq a -> Seq b -> Seq (a, b)\n    zipWith,        -- :: (a -> b -> c) -> Seq a -> Seq b -> Seq c\n    zip3,           -- :: Seq a -> Seq b -> Seq c -> Seq (a, b, c)\n    zipWith3,       -- :: (a -> b -> c -> d) -> Seq a -> Seq b -> Seq c -> Seq d\n    zip4,           -- :: Seq a -> Seq b -> Seq c -> Seq d -> Seq (a, b, c, d)\n    zipWith4,       -- :: (a -> b -> c -> d -> e) -> Seq a -> Seq b -> Seq c -> Seq d -> Seq e\n    unzip,          -- :: Seq (a, b) -> (Seq a, Seq b)\n    unzipWith       -- :: (a -> (b, c)) -> Seq a -> (Seq b, Seq c)\n    ) where\n\nimport Data.Sequence.Internal\nimport Data.Sequence.Internal.Sorting\nimport Prelude ()\n#ifdef __HADDOCK_VERSION__\nimport Control.Monad (Monad (..))\nimport Data.Functor (Functor (..))\n#endif\n\n{- $patterns\n\n== Pattern synonyms\n\nMuch like lists can be constructed and matched using the\n@:@ and @[]@ constructors, sequences can be constructed and\nmatched using the \'Empty\', \':<|\', and \':|>\' pattern synonyms.\n\n=== Note\n\nThese patterns are only available with GHC version 8.0 or later,\nand version 8.2 works better with them. When writing for such recent\nversions of GHC, the patterns can be used in place of \'empty\',\n\'<|\', \'|>\', \'viewl\', and \'viewr\'.\n\n=== __Pattern synonym examples__\n\nImport the patterns:\n\n@\nimport Data.Sequence (Seq (..))\n@\n\nLook at the first three elements of a sequence\n\n@\ngetFirst3 :: Seq a -> Maybe (a,a,a)\ngetFirst3 (x1 :<| x2 :<| x3 :<| _xs) = Just (x1,x2,x3)\ngetFirst3 _ = Nothing\n@\n\n@\n\\> getFirst3 (\'fromList\' [1,2,3,4]) = Just (1,2,3)\n\\> getFirst3 (\'fromList\' [1,2]) = Nothing\n@\n\nMove the last two elements from the end of the first list\nonto the beginning of the second one.\n\n@\nshift2Right :: Seq a -> Seq a -> (Seq a, Seq a)\nshift2Right Empty ys = (Empty, ys)\nshift2Right (Empty :|> x) ys = (Empty, x :<| ys)\nshift2Right (xs :|> x1 :|> x2) ys = (xs, x1 :<| x2 :<| ys)\n@\n\n@\n\\> shift2Right (\'fromList\' []) (\'fromList\' [10]) = (\'fromList\' [], \'fromList\' [10])\n\\> shift2Right (\'fromList\' [9]) (\'fromList\' [10]) = (\'fromList\' [], \'fromList\' [9,10])\n\\> shift2Right (\'fromList\' [8,9]) (\'fromList\' [10]) = (\'fromList\' [], \'fromList\' [8,9,10])\n\\> shift2Right (\'fromList\' [7,8,9]) (\'fromList\' [10]) = (\'fromList\' [7], \'fromList\' [8,9,10])\n@\n-}\n'