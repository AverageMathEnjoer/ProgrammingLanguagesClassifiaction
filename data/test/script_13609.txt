b'/*\n    SPDX-FileCopyrightText: 2018 Milian Wolff <mail@milianw.de>\n\n    SPDX-License-Identifier: LGPL-2.1-or-later\n*/\n\n#include "3rdparty/catch.hpp"\n\n#include "util/linereader.h"\n#include "util/linewriter.h"\n\n#include "tempfile.h"\n\n#include <limits>\n\nusing namespace std;\n\nconstexpr uint64_t operator"" _u64(unsigned long long v)\n{\n    return static_cast<uint64_t>(v);\n}\n\nTEST_CASE ("write data", "[write]") {\n    TempFile file;\n    REQUIRE(file.open());\n\n    LineWriter writer(file.fd);\n    REQUIRE(writer.canWrite());\n    REQUIRE(writer.write("hello world\\n"));\n    REQUIRE(writer.write("%d %x\\n", 42, 42));\n    REQUIRE(writer.writeHexLine(\'t\', 0u, 0ul, 1u, 1ul, 15u, 15ul, 16u, 16ul));\n    REQUIRE(writer.writeHexLine(\'u\', std::numeric_limits<uint32_t>::max() - 1, std::numeric_limits<uint32_t>::max()));\n    REQUIRE(writer.writeHexLine(\'l\', std::numeric_limits<uint64_t>::max() - 1, std::numeric_limits<uint64_t>::max()));\n\n    REQUIRE(file.readContents().empty());\n\n    REQUIRE(writer.flush());\n\n    const string expectedContents = "hello world\\n"\n                                    "42 2a\\n"\n                                    "t 0 0 1 1 f f 10 10\\n"\n                                    "u fffffffe ffffffff\\n"\n                                    "l fffffffffffffffe ffffffffffffffff\\n";\n\n    REQUIRE(file.readContents() == expectedContents);\n}\n\nTEST_CASE ("buffered write", "[write]") {\n    TempFile file;\n    REQUIRE(file.open());\n\n    LineWriter writer(file.fd);\n    REQUIRE(writer.canWrite());\n    ostringstream expectedContents;\n    for (unsigned i = 0; i < 10000; ++i) {\n        REQUIRE(writer.write("%d %x\\n", 42, 42));\n        expectedContents << "42 2a\\n";\n        if (i % 1000 == 0) {\n            const string longString(LineWriter::BUFFER_CAPACITY * 2, \'*\');\n            REQUIRE(writer.write(longString));\n            expectedContents << std::hex << longString.size() << \' \' << longString;\n        }\n    }\n    for (unsigned i = 0; i < LineWriter::BUFFER_CAPACITY * 2; ++i) {\n        const string longString(i, \'*\');\n        REQUIRE(writer.write(longString));\n        expectedContents << std::hex << longString.size() << \' \' << longString;\n    }\n\n    expectedContents.flush();\n\n    REQUIRE(expectedContents.str().size() > LineWriter::BUFFER_CAPACITY);\n    REQUIRE(writer.flush());\n\n    REQUIRE(file.readContents() == expectedContents.str());\n}\n\nTEST_CASE ("buffered writeHex", "[write]") {\n    TempFile file;\n    REQUIRE(file.open());\n\n    LineWriter writer(file.fd);\n    REQUIRE(writer.canWrite());\n    string expectedContents;\n    for (unsigned i = 0; i < 10000; ++i) {\n        REQUIRE(writer.writeHexLine(\'t\', 0x123u, 0x456u));\n        expectedContents += "t 123 456\\n";\n    }\n    REQUIRE(expectedContents.size() > LineWriter::BUFFER_CAPACITY);\n    REQUIRE(writer.flush());\n\n    REQUIRE(file.readContents() == expectedContents);\n}\n\nTEST_CASE ("write flush", "[write]") {\n    TempFile file;\n    REQUIRE(file.open());\n\n    LineWriter writer(file.fd);\n    REQUIRE(writer.canWrite());\n\n    string data1(LineWriter::BUFFER_CAPACITY - 10, \'#\');\n    REQUIRE(writer.write(data1.c_str()));\n    // not yet written\n    REQUIRE(file.readContents().empty());\n\n    // NOTE: while this data would fit,\n    //       snprintf used by the writer tries to append a \\0 too which doesn\'t fit\n    string data2(10, \'+\');\n    REQUIRE(writer.write(data2.c_str()));\n    // so the above flushes, but only the first chunk\n    REQUIRE(file.readContents() == data1);\n\n    writer.flush();\n    REQUIRE(file.readContents() == data1 + data2);\n}\n\nTEST_CASE ("read line 64bit", "[read]") {\n    const string contents =\n        "m /tmp/KDevelop-5.2.1-x86_64/usr/lib/libKF5Completion.so.5 7f48beedc00 0 36854 236858 2700\\n";\n    stringstream stream(contents);\n\n    LineReader reader;\n    REQUIRE(reader.getLine(stream));\n    REQUIRE(reader.line()\n            == "m /tmp/KDevelop-5.2.1-x86_64/usr/lib/libKF5Completion.so.5 7f48beedc00 0 36854 236858 2700");\n    REQUIRE(reader.mode() == \'m\');\n\n    string module;\n    REQUIRE(reader >> module);\n    REQUIRE(module == "/tmp/KDevelop-5.2.1-x86_64/usr/lib/libKF5Completion.so.5");\n\n    for (auto expected : {0x7f48beedc00_u64, 0x0_u64, 0x36854_u64, 0x236858_u64, 0x2700_u64}) {\n        uint64_t addr = 0;\n        REQUIRE(reader >> addr);\n        REQUIRE(addr == expected);\n    }\n\n    uint64_t x = 0;\n    REQUIRE(!(reader >> x));\n    REQUIRE(!(reader >> module));\n}\n\nTEST_CASE ("read line 32bit", "[read]") {\n    const string contents = "t 4 3\\n"\n                            "a 11c00 4\\n"\n                            "+ 0\\n";\n    stringstream stream(contents);\n    LineReader reader;\n    uint32_t idx = 0;\n\n    REQUIRE(reader.getLine(stream));\n    REQUIRE(reader.line() == "t 4 3");\n    REQUIRE(reader.mode() == \'t\');\n    REQUIRE(reader >> idx);\n    REQUIRE(idx == 0x4);\n    REQUIRE(reader >> idx);\n    REQUIRE(idx == 0x3);\n    REQUIRE(!(reader >> idx));\n\n    REQUIRE(reader.getLine(stream));\n    REQUIRE(reader.line() == "a 11c00 4");\n    REQUIRE(reader.mode() == \'a\');\n    REQUIRE(reader >> idx);\n    REQUIRE(idx == 0x11c00);\n    REQUIRE(reader >> idx);\n    REQUIRE(idx == 0x4);\n    REQUIRE(!(reader >> idx));\n\n    REQUIRE(reader.getLine(stream));\n    REQUIRE(reader.line() == "+ 0");\n    REQUIRE(reader.mode() == \'+\');\n\n    REQUIRE(reader >> idx);\n    REQUIRE(idx == 0x0);\n    REQUIRE(!(reader >> idx));\n}\n'