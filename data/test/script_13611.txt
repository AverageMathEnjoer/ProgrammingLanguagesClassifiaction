b'using System;\nusing System.Diagnostics;\nusing System.Threading;\n\nnamespace CS_SQLite3\n{\n  public partial class CSSQLite\n  {\n    /*\n    ** 2008 October 07\n    **\n    ** The author disclaims copyright to this source code.  In place of\n    ** a legal notice, here is a blessing:\n    **\n    **    May you do good and not evil.\n    **    May you find forgiveness for yourself and forgive others.\n    **    May you share freely, never taking more than you give.\n    **\n    *************************************************************************\n    ** This file contains the C functions that implement mutexes.\n    **\n    ** This implementation in this file does not provide any mutual\n    ** exclusion and is thus suitable for use only in applications\n    ** that use SQLite in a single thread.  The routines defined\n    ** here are place-holders.  Applications can substitute working\n    ** mutex routines at start-time using the\n    **\n    **     sqlite3_config(SQLITE_CONFIG_MUTEX,...)\n    **\n    ** interface.\n    **\n    ** If compiled with SQLITE_DEBUG, then additional logic is inserted\n    ** that does error checking on mutexes to make sure they are being\n    ** called correctly.\n    **\n    ** $Id: mutex_noop.c,v 1.3 2008/12/05 17:17:08 drh Exp $\n    **\n    *************************************************************************\n    **  Included in SQLite3 port to C#-SQLite;  2008 Noah B Hart\n    **  C#-SQLite is an independent reimplementation of the SQLite software library\n    **\n    **  $Header$\n    *************************************************************************\n    */\n    //#include "sqliteInt.h"\n\n\n#if (SQLITE_MUTEX_NOOP) && !(SQLITE_DEBUG)\n/*\n** Stub routines for all mutex methods.\n**\n** This routines provide no mutual exclusion or error checking.\n*/\nstatic int noopMutexHeld(sqlite3_mutex *p){ return 1; }\nstatic int noopMutexNotheld(sqlite3_mutex *p){ return 1; }\nstatic int noopMutexInit(void){ return SQLITE_OK; }\nstatic int noopMutexEnd(void){ return SQLITE_OK; }\nstatic sqlite3_mutex *noopMutexAlloc(int id){ return (sqlite3_mutex*)8; }\nstatic void noopMutexFree(sqlite3_mutex *p){ return; }\nstatic void noopMutexEnter(sqlite3_mutex *p){ return; }\nstatic int noopMutexTry(sqlite3_mutex *p){ return SQLITE_OK; }\nstatic void noopMutexLeave(sqlite3_mutex *p){ return; }\n\nsqlite3_mutex_methods *sqlite3DefaultMutex(void){\nstatic sqlite3_mutex_methods sMutex = {\nnoopMutexInit,\nnoopMutexEnd,\nnoopMutexAlloc,\nnoopMutexFree,\nnoopMutexEnter,\nnoopMutexTry,\nnoopMutexLeave,\n\nnoopMutexHeld,\nnoopMutexNotheld\n};\n\nreturn &sMutex;\n}\n#endif //* defined(SQLITE_MUTEX_NOOP) && !defined(SQLITE_DEBUG) */\n\n#if (SQLITE_MUTEX_NOOP) && (SQLITE_DEBUG)\n/*\n** In this implementation, error checking is provided for testing\n** and debugging purposes.  The mutexes still do not provide any\n** mutual exclusion.\n*/\n\n/*\n** The mutex object\n*/\nstruct sqlite3_mutex {\nint id;     /* The mutex type */\nint cnt;    /* Number of entries without a matching leave */\n};\n\n/*\n** The sqlite3_mutex_held() and sqlite3_mutex_notheld() routine are\n** intended for use inside Debug.Assert() statements.\n*/\nstatic int debugMutexHeld(sqlite3_mutex *p){\nreturn p==0 || p->cnt>0;\n}\nstatic int debugMutexNotheld(sqlite3_mutex *p){\nreturn p==0 || p->cnt==0;\n}\n\n/*\n** Initialize and deinitialize the mutex subsystem.\n*/\nstatic int debugMutexInit(void){ return SQLITE_OK; }\nstatic int debugMutexEnd(void){ return SQLITE_OK; }\n\n/*\n** The sqlite3_mutex_alloc() routine allocates a new\n** mutex and returns a pointer to it.  If it returns NULL\n** that means that a mutex could not be allocated.\n*/\nstatic sqlite3_mutex *debugMutexAlloc(int id){\nstatic sqlite3_mutex aStatic[6];\nsqlite3_mutex *pNew = 0;\nswitch( id ){\ncase SQLITE_MUTEX_FAST:\ncase SQLITE_MUTEX_RECURSIVE: {\npNew = sqlite3Malloc(sizeof(*pNew));\nif( pNew ){\npNew->id = id;\npNew->cnt = 0;\n}\nbreak;\n}\ndefault: {\nDebug.Assert( id-2 >= 0 );\nassert( id-2 < (int)(sizeof(aStatic)/sizeof(aStatic[0])) );\npNew = &aStatic[id-2];\npNew->id = id;\nbreak;\n}\n}\nreturn pNew;\n}\n\n/*\n** This routine deallocates a previously allocated mutex.\n*/\nstatic void debugMutexFree(sqlite3_mutex *p){\nDebug.Assert( p->cnt==0 );\nDebug.Assert( p->id==SQLITE_MUTEX_FAST || p->id==SQLITE_MUTEX_RECURSIVE );\n//sqlite3_free(ref p);\n}\n\n/*\n** The sqlite3_mutex_enter() and sqlite3_mutex_try() routines attempt\n** to enter a mutex.  If another thread is already within the mutex,\n** sqlite3_mutex_enter() will block and sqlite3_mutex_try() will return\n** SQLITE_BUSY.  The sqlite3_mutex_try() interface returns SQLITE_OK\n** upon successful entry.  Mutexes created using SQLITE_MUTEX_RECURSIVE can\n** be entered multiple times by the same thread.  In such cases the,\n** mutex must be exited an equal number of times before another thread\n** can enter.  If the same thread tries to enter any other kind of mutex\n** more than once, the behavior is undefined.\n*/\nstatic void debugMutexEnter(sqlite3_mutex *p){\nDebug.Assert( p->id==SQLITE_MUTEX_RECURSIVE || debugMutexNotheld(p) );\np->cnt++;\n}\nstatic int debugMutexTry(sqlite3_mutex *p){\nDebug.Assert( p->id==SQLITE_MUTEX_RECURSIVE || debugMutexNotheld(p) );\np->cnt++;\nreturn SQLITE_OK;\n}\n\n/*\n** The sqlite3_mutex_leave() routine exits a mutex that was\n** previously entered by the same thread.  The behavior\n** is undefined if the mutex is not currently entered or\n** is not currently allocated.  SQLite will never do either.\n*/\nstatic void debugMutexLeave(sqlite3_mutex *p){\nDebug.Assert( debugMutexHeld(p) );\np->cnt--;\nDebug.Assert( p->id==SQLITE_MUTEX_RECURSIVE || debugMutexNotheld(p) );\n}\n\nsqlite3_mutex_methods *sqlite3DefaultMutex(void){\nstatic sqlite3_mutex_methods sMutex = {\ndebugMutexInit,\ndebugMutexEnd,\ndebugMutexAlloc,\ndebugMutexFree,\ndebugMutexEnter,\ndebugMutexTry,\ndebugMutexLeave,\n\ndebugMutexHeld,\ndebugMutexNotheld\n};\n\nreturn &sMutex;\n}\n#endif //* (SQLITE_MUTEX_NOOP) && (SQLITE_DEBUG) */\n  }\n}\n'