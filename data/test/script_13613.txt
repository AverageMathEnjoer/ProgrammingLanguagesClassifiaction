b'//http://codeforces.com/gym/100570/submission/21226425\n#include <bits/stdc++.h>\nusing namespace std;\n#define gc getchar_unlocked\n#define fo(i,n) for(i=0;i<n;i++)\n#define Fo(i,k,n) for(i=k;i<n;i++)\n#define ll long long\n#define si(x)\tscanf("%d",&x)\n#define sl(x)\tscanf("%I64d",&x)\n#define ss(s)\tscanf("%s",s)\n#define pb push_back\n#define mp make_pair\n#define F first\n#define S second\n#define all(x) x.begin(), x.end()\n#define clr(x) memset(x, 0, sizeof(x))\n#define sortall(x) sort(all(x))\n#define tr(it, a) for(auto it = a.begin(); it != a.end(); it++)\n#define PI 3.1415926535897932384626\ntypedef pair<int, int>\tpii;\ntypedef pair<ll, ll>\tpll;\ntypedef vector<int>\t\tvi;\ntypedef vector<ll>\t\tvl;\ntypedef vector<pii>\t\tvpii;\ntypedef vector<pll>\t\tvpll;\ntypedef vector<vi>\t\tvvi;\ntypedef vector<vl>\t\tvvl;\nint mod ;\nconst int N = 3e5;\nvi g[N], cg[N];\nvl stree[N], contri[N], wt[N];\nvi cur;\nint part;\nint gvis[N], c_par[N];\nconst int LG = 20;\n//LCA begins\n//1 based index\nint a[N], lvl[N], P[N][LG], sz[N];\nll D[N];\nvoid predfs(int u, int par){\n\tif (!par)lvl[u] = D[u] = 0;\n    P[u][0] = par;\n    int pos = -1;\n\tfor(int v:g[u]){\n\t\tint w = wt[u][++pos];\n\t\tif (v == par) continue;\n\t\tlvl[v] = 1+lvl[u];\n\t\tD[v] = w+D[u];\n\t\tpredfs(v, u);\n\t}\n}\nvoid prelca(int n){\n\tint i, j;\n\tfo(i, LG) fo(j, n+1) P[j][i] = -1;\n\tlvl[0] = -1;\n\tpredfs(1, 0);\n\tfor(i=1; i<LG; i++){\n        Fo(j, 1, n+1)\n            if (P[j][i-1] != -1)\n                P[j][i] = P[P[j][i-1]][i-1];\n\t}\n}\nint lca(int u, int v){\n    int i, lg;\n    if (lvl[u] < lvl[v]) swap(u, v);\n    for(lg = 0; (1<<lg) <= lvl[u]; lg++);\n    lg--;\n    for(i=lg; i>=0; i--){\n        if (lvl[u] - (1<<i) >= lvl[v])\n            u = P[u][i];\n    }\n    if (u == v) return u;\n    for(i=lg; i>=0; i--){\n        if (P[u][i] != -1 and P[u][i] != P[v][i])\n            u = P[u][i], v = P[v][i];\n    }\n    return P[u][0];\n}\n\nll dis(int u, int v){\n\tif (u == v) return 0;\n    if (lvl[u] < lvl[v]) swap(u, v);\n    int w = lca(u, v);\n    return D[u] + D[v] - 2*D[w];\n}\n//lca ends\nint tot = 0;\nvoid dfs2(int u, int par){\n\tif (par == 0)tot = 0;\n    sz[u] = 1;\n    tot++;\n    for(int v: g[u]){\n        if (gvis[v] or v == par) continue;\n        dfs2(v, u);\n        sz[u] += sz[v];\n    }\n}\n//centroid decomposition begins\nint centroid(int u, int par){\n\n    for(int v: g[u]){\n        if ( v == par or gvis[v]) continue;\n        if (2*sz[v] > tot) return centroid(v, u);\n    }\n    return u;\n}\nvoid decompose(int u, int par){\n\tdfs2(u, 0);\n\tint cen = centroid(u, 0);\n\tgvis[cen] = 1;\n\tif (par) c_par[cen] = par;\n\tfor(int v: g[cen])\n\t\tif (!gvis[v]) decompose(v, cen);\n}\n//build centroid tree\nvoid build_centroid_tree(int n){\n\tint i;\n\tFo(i, 1, n+1) if (c_par[i]) cg[c_par[i]].pb(i);\n}\nvoid calc_root(int u, int root){\n\tstree[root].pb(dis(u, root));\n\tfor(int v: cg[u]) \n\t\tcalc_root(v, root);\n}\nvoid calc_contri(int u, int root){\n\tint par = c_par[root];\n\tcontri[root].pb(dis(u, par));\n\tfor(int v: cg[u]) \n\t\tcalc_contri(v, root);\n}\n//traverse centroid tree\nvoid traverse_centroid_tree(int u, int par){\n\tfor(int v: cg[u]){\n\t\tif (v == par) continue;\n\t\ttraverse_centroid_tree(v, u);\n\t}\n\tcalc_root(u, u);\n\tif (!par) \n\t\treturn;\n\tcalc_contri(u, u);\n}\nbool f(ll val, ll x){\n\treturn val >= x;\n}\nint bin(vl &a, ll val, int lo, int hi){\n\tif (a.empty())return 0;\n\tif (val < 0)return 0;\n\tif (a[0] > val) return 0;\n\tif (lo == hi) return lo+1;\n\tif (lo+1 == hi){\n\t\tif(f(val, a[hi]))return hi+1;\n\t\treturn lo+1;\n\t}\n\tint mid = (lo+hi)/2;\n\tif(f(val, a[mid])) return bin(a, val, mid, hi);\n\telse return bin(a, val, lo, mid-1);\n}\n//# nodes u | dis(u,v) <= l \nint query(int v, ll l){\n\tint ans = bin(stree[v], l, 0, (int)stree[v].size()-1);\n\tint u = v;\n\tint orig = v;\n\tv = c_par[v];\n\twhile(v){\n\t\tll y = dis(orig, v);\n\t\tans += bin(stree[v], l-y, 0, (int)stree[v].size()-1);\n\t\tans -= bin(contri[u], l-y, 0, (int)contri[u].size()-1);\n\t\tu = v;\n\t\tv = c_par[v];\n\t}\n\treturn ans;\n}\n\n//centroid decomposition ends\nint main()\n{\n\tios_base::sync_with_stdio(false);\n\tcin.tie(NULL);\n\tll i,n,k,j, u, v, w, q;\n\tint t;\n\tcin>>n>>q;\n\tfo(i, n-1){\n        cin>>u>>v>>w;\n        g[u].pb(v);\n        g[v].pb(u);\n        wt[v].pb(w);\n        wt[u].pb(w);\n\t}\n\tprelca(n);\n\tdecompose(1, 0);\n\tbuild_centroid_tree(n);\n\tFo(i, 1, n+1) \n\t\tif (!c_par[i])\n\t\t\ttraverse_centroid_tree(i, 0);\n\tFo(i, 1, n+1) sortall(contri[i]);\n\tFo(i, 1, n+1) sortall(stree[i]);\n\twhile(q--){\n\t\tcin>>v>>w;\n\t\tcout<<query(v, w)<<endl;\n\t}\n\treturn 0;\n}\n\nint mpow(int base, int exp) {\nbase %= mod;\nint result = 1;\nwhile (exp > 0) {\nif (exp & 1) result = ((ll)result * base) % mod;\nbase = ((ll)base * base) % mod;\nexp >>= 1;\n}\nreturn result;\n}\n'