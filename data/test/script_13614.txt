b'{-# LANGUAGE OverloadedStrings #-}\n\nmodule Test.Parsers.Object\n(\n  spec\n)\nwhere\n\nimport Pdf.Core.Object\nimport Pdf.Core.Parsers.Object\n\nimport Data.Attoparsec.ByteString\nimport qualified Data.Vector as Vector\nimport qualified Data.HashMap.Strict as HashMap\nimport Test.Hspec\n\nspec :: Spec\nspec = describe "Parsers.Object" $ do\n  parseStringSpec\n  parseHexStringSpec\n  parseBoolSpec\n  parseNameSpec\n  parseNumberSpec\n  parseArraySpec\n  parseDictSpec\n  parseRefSpec\n\nparseStringSpec :: Spec\nparseStringSpec = describe "parseString" $ do\n  it "should unescape 3-digit character" $ do\n    parseOnly parseString "(hello\\\\040world)"\n      `shouldBe` Right "hello world"\n\n  it "should unescape 2-digit character" $ do\n    parseOnly parseString "(hello\\\\40world)"\n      `shouldBe` Right "hello world"\n\n  it "should unescape 1-digit character" $ do\n    parseOnly parseString "(hello\\\\0world)"\n      `shouldBe` Right "hello\\NULworld"\n\n  it "should accept nested parens" $ do\n    parseOnly parseString "(hello( )world)"\n      `shouldBe` Right "hello( )world"\n\n  it "should unescape special chars" $ do\n    parseOnly parseString "(\\\\(\\\\)\\\\\\\\\\\\n\\\\f\\\\r\\\\t\\\\b)"\n      `shouldBe` Right "()\\\\\\n\\f\\r\\t\\b"\n\nparseHexStringSpec :: Spec\nparseHexStringSpec = describe "parseHexString" $ do\n  it "should parse hex string" $ do\n    parseOnly parseHexString "<00FFff>"\n      `shouldBe` Right "\\NUL\\255\\255"\n\nparseBoolSpec :: Spec\nparseBoolSpec = describe "parseBool" $ do\n  it "should parse \'true\' as True" $ do\n    parseOnly parseBool "true"\n      `shouldBe` Right True\n\n  it "should parse \'false\' as False" $ do\n    parseOnly parseBool "false"\n      `shouldBe` Right False\n\nparseNameSpec :: Spec\nparseNameSpec = describe "parseName" $ do\n  it "should parse a name" $ do\n    parseOnly parseName "/hello"\n      `shouldBe` Right "hello"\n\nparseNumberSpec :: Spec\nparseNumberSpec = describe "parseNumber" $ do\n  it "should parse int" $ do\n    parseOnly parseNumber "42"\n      `shouldBe` Right 42\n\n  it "should parse float" $ do\n    parseOnly parseNumber "42.4"\n      `shouldBe` Right 42.4\n\n  it "should parse float without leading 0." $ do\n    parseOnly parseNumber ".4"\n      `shouldBe` Right 0.4\n\nparseArraySpec :: Spec\nparseArraySpec = describe "parseArray" $ do\n  it "should parse array" $ do\n    parseOnly parseArray "[42 true]"\n      `shouldBe` Right (Vector.fromList [Number 42, Bool True])\n\nparseDictSpec :: Spec\nparseDictSpec = describe "parseDict" $ do\n  it "should parse a dictionary" $ do\n    parseOnly parseDict "<</hello true>>"\n      `shouldBe` Right (HashMap.fromList [("hello", Bool True)])\n  it "should allow comments inside" $ do\n    parseOnly parseDict "<</hello%I\'m a comment\\ntrue>>"\n      `shouldBe` Right (HashMap.fromList [("hello", Bool True)])\n    parseOnly parseDict "<</hello%I\'m a comment\\n%another\\ntrue>>"\n      `shouldBe` Right (HashMap.fromList [("hello", Bool True)])\n    parseOnly parseDict "<</hello%I\'m a comment\\n\\rtrue>>"\n      `shouldBe` Right (HashMap.fromList [("hello", Bool True)])\n    parseOnly parseDict "<</hello %I\'m a comment\\n true>>"\n      `shouldBe` Right (HashMap.fromList [("hello", Bool True)])\n\nparseRefSpec :: Spec\nparseRefSpec = describe "parseRef" $ do\n  it "should parse a reference" $ do\n    parseOnly parseRef "42 24 R"\n      `shouldBe` Right (R 42 24)\n'