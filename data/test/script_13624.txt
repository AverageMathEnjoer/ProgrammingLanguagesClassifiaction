b'package com.rengwuxian.materialedittext;\n\nimport android.annotation.TargetApi;\nimport android.content.Context;\nimport android.content.res.ColorStateList;\nimport android.content.res.Configuration;\nimport android.content.res.TypedArray;\nimport android.graphics.Bitmap;\nimport android.graphics.BitmapFactory;\nimport android.graphics.Canvas;\nimport android.graphics.Color;\nimport android.graphics.Paint;\nimport android.graphics.PorterDuff;\nimport android.graphics.Typeface;\nimport android.graphics.drawable.Drawable;\nimport android.os.Build;\nimport android.support.annotation.DrawableRes;\nimport android.support.annotation.IntDef;\nimport android.support.annotation.NonNull;\nimport android.support.annotation.Nullable;\nimport android.support.v7.widget.AppCompatMultiAutoCompleteTextView;\nimport android.text.Editable;\nimport android.text.Layout;\nimport android.text.StaticLayout;\nimport android.text.TextPaint;\nimport android.text.TextUtils;\nimport android.text.TextWatcher;\nimport android.text.method.TransformationMethod;\nimport android.util.AttributeSet;\nimport android.util.TypedValue;\nimport android.view.Gravity;\nimport android.view.MotionEvent;\nimport android.view.View;\n\nimport com.nineoldandroids.animation.ArgbEvaluator;\nimport com.nineoldandroids.animation.ObjectAnimator;\nimport com.rengwuxian.materialedittext.validation.METLengthChecker;\nimport com.rengwuxian.materialedittext.validation.METValidator;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\n/**\n * Created by rengwuxian on 2015/1/8.\n */\npublic class MaterialMultiAutoCompleteTextView extends AppCompatMultiAutoCompleteTextView {\n\n  @IntDef({FLOATING_LABEL_NONE, FLOATING_LABEL_NORMAL, FLOATING_LABEL_HIGHLIGHT})\n  public @interface FloatingLabelType {\n  }\n\n  public static final int FLOATING_LABEL_NONE = 0;\n  public static final int FLOATING_LABEL_NORMAL = 1;\n  public static final int FLOATING_LABEL_HIGHLIGHT = 2;\n\n  /**\n   * the spacing between the main text and the inner top padding.\n   */\n  private int extraPaddingTop;\n\n  /**\n   * the spacing between the main text and the inner bottom padding.\n   */\n  private int extraPaddingBottom;\n\n  /**\n   * the extra spacing between the main text and the left, actually for the left icon.\n   */\n  private int extraPaddingLeft;\n\n  /**\n   * the extra spacing between the main text and the right, actually for the right icon.\n   */\n  private int extraPaddingRight;\n\n  /**\n   * the floating label\'s text size.\n   */\n  private int floatingLabelTextSize;\n\n  /**\n   * the floating label\'s text color.\n   */\n  private int floatingLabelTextColor;\n\n  /**\n   * the bottom texts\' size.\n   */\n  private int bottomTextSize;\n\n  /**\n   * the spacing between the main text and the floating label.\n   */\n  private int floatingLabelPadding;\n\n  /**\n   * the spacing between the main text and the bottom components (bottom ellipsis, helper/error text, characters counter).\n   */\n  private int bottomSpacing;\n\n  /**\n   * whether the floating label should be shown. default is false.\n   */\n  private boolean floatingLabelEnabled;\n\n  /**\n   * whether to highlight the floating label\'s text color when focused (with the main color). default is true.\n   */\n  private boolean highlightFloatingLabel;\n\n  /**\n   * the base color of the line and the texts. default is black.\n   */\n  private int baseColor;\n\n  /**\n   * inner top padding\n   */\n  private int innerPaddingTop;\n\n  /**\n   * inner bottom padding\n   */\n  private int innerPaddingBottom;\n\n  /**\n   * inner left padding\n   */\n  private int innerPaddingLeft;\n\n  /**\n   * inner right padding\n   */\n  private int innerPaddingRight;\n\n  /**\n   * the underline\'s highlight color, and the highlight color of the floating label if app:highlightFloatingLabel is set true in the xml. default is black(when app:darkTheme is false) or white(when app:darkTheme is true)\n   */\n  private int primaryColor;\n\n  /**\n   * the color for when something is wrong.(e.g. exceeding max characters)\n   */\n  private int errorColor;\n\n  /**\n   * min characters count limit. 0 means no limit. default is 0. NOTE: the character counter will increase the View\'s height.\n   */\n  private int minCharacters;\n\n  /**\n   * max characters count limit. 0 means no limit. default is 0. NOTE: the character counter will increase the View\'s height.\n   */\n  private int maxCharacters;\n\n  /**\n   * whether to show the bottom ellipsis in singleLine mode. default is false. NOTE: the bottom ellipsis will increase the View\'s height.\n   */\n  private boolean singleLineEllipsis;\n\n  /**\n   * Always show the floating label, instead of animating it in/out. False by default.\n   */\n  private boolean floatingLabelAlwaysShown;\n\n  /**\n   * Always show the helper text, no matter if the edit text is focused. False by default.\n   */\n  private boolean helperTextAlwaysShown;\n\n  /**\n   * bottom ellipsis\'s height\n   */\n  private int bottomEllipsisSize;\n\n  /**\n   * min bottom lines count.\n   */\n  private int minBottomLines;\n\n  /**\n   * reserved bottom text lines count, no matter if there is some helper/error text.\n   */\n  private int minBottomTextLines;\n\n  /**\n   * real-time bottom lines count. used for bottom extending/collapsing animation.\n   */\n  private float currentBottomLines;\n\n  /**\n   * bottom lines count.\n   */\n  private float bottomLines;\n\n  /**\n   * Helper text at the bottom\n   */\n  private String helperText;\n\n  /**\n   * Helper text color\n   */\n  private int helperTextColor = -1;\n\n  /**\n   * error text for manually invoked {@link #setError(CharSequence)}\n   */\n  private String tempErrorText;\n\n  /**\n   * animation fraction of the floating label (0 as totally hidden).\n   */\n  private float floatingLabelFraction;\n\n  /**\n   * whether the floating label is being shown.\n   */\n  private boolean floatingLabelShown;\n\n  /**\n   * the floating label\'s focusFraction\n   */\n  private float focusFraction;\n\n  /**\n   * The font used for the accent texts (floating label, error/helper text, character counter, etc.)\n   */\n  private Typeface accentTypeface;\n\n  /**\n   * The font used on the view (EditText content)\n   */\n  private Typeface typeface;\n\n  /**\n   * Text for the floatLabel if different from the hint\n   */\n  private CharSequence floatingLabelText;\n\n  /**\n   * Whether or not to show the underline. Shown by default\n   */\n  private boolean hideUnderline;\n\n  /**\n   * Underline\'s color\n   */\n  private int underlineColor;\n\n  /**\n   * Whether to validate as soon as the text has changed. False by default\n   */\n  private boolean autoValidate;\n\n  /**\n   * Whether the characters count is valid\n   */\n  private boolean charactersCountValid;\n\n  /**\n   * Whether use animation to show/hide the floating label.\n   */\n  private boolean floatingLabelAnimating;\n\n  /**\n   * Whether check the characters count at the beginning it\'s shown.\n   */\n  private boolean checkCharactersCountAtBeginning;\n\n  /**\n   * Left Icon\n   */\n  private Bitmap[] iconLeftBitmaps;\n\n  /**\n   * Right Icon\n   */\n  private Bitmap[] iconRightBitmaps;\n\n  /**\n   * Clear Button\n   */\n  private Bitmap[] clearButtonBitmaps;\n\n  /**\n   * Auto validate when focus lost.\n   */\n  private boolean validateOnFocusLost;\n\n  private boolean showClearButton;\n  private boolean firstShown;\n  private int iconSize;\n  private int iconOuterWidth;\n  private int iconOuterHeight;\n  private int iconPadding;\n  private boolean clearButtonTouched;\n  private boolean clearButtonClicking;\n  private ColorStateList textColorStateList;\n  private ColorStateList textColorHintStateList;\n  private ArgbEvaluator focusEvaluator = new ArgbEvaluator();\n  Paint paint = new Paint(Paint.ANTI_ALIAS_FLAG);\n  TextPaint textPaint = new TextPaint(Paint.ANTI_ALIAS_FLAG);\n  StaticLayout textLayout;\n  ObjectAnimator labelAnimator;\n  ObjectAnimator labelFocusAnimator;\n  ObjectAnimator bottomLinesAnimator;\n  OnFocusChangeListener innerFocusChangeListener;\n  OnFocusChangeListener outerFocusChangeListener;\n  private List<METValidator> validators;\n  private METLengthChecker lengthChecker;\n\n  public MaterialMultiAutoCompleteTextView(Context context) {\n    super(context);\n    init(context, null);\n  }\n\n  public MaterialMultiAutoCompleteTextView(Context context, AttributeSet attrs) {\n    super(context, attrs);\n    init(context, attrs);\n  }\n\n  @TargetApi(Build.VERSION_CODES.LOLLIPOP)\n  public MaterialMultiAutoCompleteTextView(Context context, AttributeSet attrs, int style) {\n    super(context, attrs, style);\n    init(context, attrs);\n  }\n\n  private void init(Context context, AttributeSet attrs) {\n    iconSize = getPixel(32);\n    iconOuterWidth = getPixel(48);\n    iconOuterHeight = getPixel(32);\n\n    bottomSpacing = getResources().getDimensionPixelSize(R.dimen.inner_components_spacing);\n    bottomEllipsisSize = getResources().getDimensionPixelSize(R.dimen.bottom_ellipsis_height);\n\n    // default baseColor is black\n    int defaultBaseColor = Color.BLACK;\n\n    TypedArray typedArray = context.obtainStyledAttributes(attrs, R.styleable.MaterialEditText);\n    textColorStateList = typedArray.getColorStateList(R.styleable.MaterialEditText_met_textColor);\n    textColorHintStateList = typedArray.getColorStateList(R.styleable.MaterialEditText_met_textColorHint);\n    baseColor = typedArray.getColor(R.styleable.MaterialEditText_met_baseColor, defaultBaseColor);\n\n    // retrieve the default primaryColor\n    int defaultPrimaryColor;\n    TypedValue primaryColorTypedValue = new TypedValue();\n    try {\n      if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {\n        context.getTheme().resolveAttribute(android.R.attr.colorPrimary, primaryColorTypedValue, true);\n        defaultPrimaryColor = primaryColorTypedValue.data;\n      } else {\n        throw new RuntimeException("SDK_INT less than LOLLIPOP");\n      }\n    } catch (Exception e) {\n      try {\n        int colorPrimaryId = getResources().getIdentifier("colorPrimary", "attr", getContext().getPackageName());\n        if (colorPrimaryId != 0) {\n          context.getTheme().resolveAttribute(colorPrimaryId, primaryColorTypedValue, true);\n          defaultPrimaryColor = primaryColorTypedValue.data;\n        } else {\n          throw new RuntimeException("colorPrimary not found");\n        }\n      } catch (Exception e1) {\n        defaultPrimaryColor = baseColor;\n      }\n    }\n\n    primaryColor = typedArray.getColor(R.styleable.MaterialEditText_met_primaryColor, defaultPrimaryColor);\n    setFloatingLabelInternal(typedArray.getInt(R.styleable.MaterialEditText_met_floatingLabel, 0));\n    errorColor = typedArray.getColor(R.styleable.MaterialEditText_met_errorColor, Color.parseColor("#e7492E"));\n    minCharacters = typedArray.getInt(R.styleable.MaterialEditText_met_minCharacters, 0);\n    maxCharacters = typedArray.getInt(R.styleable.MaterialEditText_met_maxCharacters, 0);\n    singleLineEllipsis = typedArray.getBoolean(R.styleable.MaterialEditText_met_singleLineEllipsis, false);\n    helperText = typedArray.getString(R.styleable.MaterialEditText_met_helperText);\n    helperTextColor = typedArray.getColor(R.styleable.MaterialEditText_met_helperTextColor, -1);\n    minBottomTextLines = typedArray.getInt(R.styleable.MaterialEditText_met_minBottomTextLines, 0);\n    String fontPathForAccent = typedArray.getString(R.styleable.MaterialEditText_met_accentTypeface);\n    if (fontPathForAccent != null && !isInEditMode()) {\n      accentTypeface = getCustomTypeface(fontPathForAccent);\n      textPaint.setTypeface(accentTypeface);\n    }\n    String fontPathForView = typedArray.getString(R.styleable.MaterialEditText_met_typeface);\n    if (fontPathForView != null && !isInEditMode()) {\n      typeface = getCustomTypeface(fontPathForView);\n      setTypeface(typeface);\n    }\n    floatingLabelText = typedArray.getString(R.styleable.MaterialEditText_met_floatingLabelText);\n    if (floatingLabelText == null) {\n      floatingLabelText = getHint();\n    }\n    floatingLabelPadding = typedArray.getDimensionPixelSize(R.styleable.MaterialEditText_met_floatingLabelPadding, bottomSpacing);\n    floatingLabelTextSize = typedArray.getDimensionPixelSize(R.styleable.MaterialEditText_met_floatingLabelTextSize, getResources().getDimensionPixelSize(R.dimen.floating_label_text_size));\n    floatingLabelTextColor = typedArray.getColor(R.styleable.MaterialEditText_met_floatingLabelTextColor, -1);\n    floatingLabelAnimating = typedArray.getBoolean(R.styleable.MaterialEditText_met_floatingLabelAnimating, true);\n    bottomTextSize = typedArray.getDimensionPixelSize(R.styleable.MaterialEditText_met_bottomTextSize, getResources().getDimensionPixelSize(R.dimen.bottom_text_size));\n    hideUnderline = typedArray.getBoolean(R.styleable.MaterialEditText_met_hideUnderline, false);\n    underlineColor = typedArray.getColor(R.styleable.MaterialEditText_met_underlineColor, -1);\n    autoValidate = typedArray.getBoolean(R.styleable.MaterialEditText_met_autoValidate, false);\n    iconLeftBitmaps = generateIconBitmaps(typedArray.getResourceId(R.styleable.MaterialEditText_met_iconLeft, -1));\n    iconRightBitmaps = generateIconBitmaps(typedArray.getResourceId(R.styleable.MaterialEditText_met_iconRight, -1));\n    showClearButton = typedArray.getBoolean(R.styleable.MaterialEditText_met_clearButton, false);\n    clearButtonBitmaps = generateIconBitmaps(R.drawable.met_ic_clear);\n    iconPadding = typedArray.getDimensionPixelSize(R.styleable.MaterialEditText_met_iconPadding, getPixel(16));\n    floatingLabelAlwaysShown = typedArray.getBoolean(R.styleable.MaterialEditText_met_floatingLabelAlwaysShown, false);\n    helperTextAlwaysShown = typedArray.getBoolean(R.styleable.MaterialEditText_met_helperTextAlwaysShown, false);\n    validateOnFocusLost = typedArray.getBoolean(R.styleable.MaterialEditText_met_validateOnFocusLost, false);\n    checkCharactersCountAtBeginning = typedArray.getBoolean(R.styleable.MaterialEditText_met_checkCharactersCountAtBeginning, true);\n    typedArray.recycle();\n\n    int[] paddings = new int[]{\n      android.R.attr.padding, // 0\n      android.R.attr.paddingLeft, // 1\n      android.R.attr.paddingTop, // 2\n      android.R.attr.paddingRight, // 3\n      android.R.attr.paddingBottom // 4\n    };\n    TypedArray paddingsTypedArray = context.obtainStyledAttributes(attrs, paddings);\n    int padding = paddingsTypedArray.getDimensionPixelSize(0, 0);\n    innerPaddingLeft = paddingsTypedArray.getDimensionPixelSize(1, padding);\n    innerPaddingTop = paddingsTypedArray.getDimensionPixelSize(2, padding);\n    innerPaddingRight = paddingsTypedArray.getDimensionPixelSize(3, padding);\n    innerPaddingBottom = paddingsTypedArray.getDimensionPixelSize(4, padding);\n    paddingsTypedArray.recycle();\n\n    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN) {\n      setBackground(null);\n    } else {\n      setBackgroundDrawable(null);\n    }\n    if (singleLineEllipsis) {\n      TransformationMethod transformationMethod = getTransformationMethod();\n      setSingleLine();\n      setTransformationMethod(transformationMethod);\n    }\n    initMinBottomLines();\n    initPadding();\n    initText();\n    initFloatingLabel();\n    initTextWatcher();\n    checkCharactersCount();\n  }\n\n  private void initText() {\n    if (!TextUtils.isEmpty(getText())) {\n      CharSequence text = getText();\n      setText(null);\n      resetHintTextColor();\n      setText(text);\n      setSelection(text.length());\n      floatingLabelFraction = 1;\n      floatingLabelShown = true;\n    } else {\n      resetHintTextColor();\n    }\n    resetTextColor();\n  }\n\n  private void initTextWatcher() {\n    addTextChangedListener(new TextWatcher() {\n      @Override\n      public void beforeTextChanged(CharSequence s, int start, int count, int after) {\n      }\n\n      @Override\n      public void onTextChanged(CharSequence s, int start, int before, int count) {\n      }\n\n      @Override\n      public void afterTextChanged(Editable s) {\n        checkCharactersCount();\n        if (autoValidate) {\n          validate();\n        } else {\n          setError(null);\n        }\n        postInvalidate();\n      }\n    });\n  }\n\n  private Typeface getCustomTypeface(@NonNull String fontPath) {\n    return Typeface.createFromAsset(getContext().getAssets(), fontPath);\n  }\n\n  public void setIconLeft(@DrawableRes int res) {\n    iconLeftBitmaps = generateIconBitmaps(res);\n    initPadding();\n  }\n\n  public void setIconLeft(Drawable drawable) {\n    iconLeftBitmaps = generateIconBitmaps(drawable);\n    initPadding();\n  }\n\n  public void setIconLeft(Bitmap bitmap) {\n    iconLeftBitmaps = generateIconBitmaps(bitmap);\n    initPadding();\n  }\n\n  public void setIconRight(@DrawableRes int res) {\n    iconRightBitmaps = generateIconBitmaps(res);\n    initPadding();\n  }\n\n  public void setIconRight(Drawable drawable) {\n    iconRightBitmaps = generateIconBitmaps(drawable);\n    initPadding();\n  }\n\n  public void setIconRight(Bitmap bitmap) {\n    iconRightBitmaps = generateIconBitmaps(bitmap);\n    initPadding();\n  }\n\n  public boolean isShowClearButton() {\n    return showClearButton;\n  }\n\n  public void setShowClearButton(boolean show) {\n    showClearButton = show;\n    correctPaddings();\n  }\n\n  private Bitmap[] generateIconBitmaps(@DrawableRes int origin) {\n    if (origin == -1) {\n      return null;\n    }\n    BitmapFactory.Options options = new BitmapFactory.Options();\n    options.inJustDecodeBounds = true;\n    BitmapFactory.decodeResource(getResources(), origin, options);\n    int size = Math.max(options.outWidth, options.outHeight);\n    options.inSampleSize = size > iconSize ? size / iconSize : 1;\n    options.inJustDecodeBounds = false;\n    return generateIconBitmaps(BitmapFactory.decodeResource(getResources(), origin, options));\n  }\n\n  private Bitmap[] generateIconBitmaps(Drawable drawable) {\n    if (drawable == null)\n      return null;\n    Bitmap bitmap = Bitmap.createBitmap(drawable.getIntrinsicWidth(), drawable.getIntrinsicHeight(), Bitmap.Config.ARGB_8888);\n    Canvas canvas = new Canvas(bitmap);\n    drawable.setBounds(0, 0, canvas.getWidth(), canvas.getHeight());\n    drawable.draw(canvas);\n    return generateIconBitmaps(Bitmap.createScaledBitmap(bitmap, iconSize, iconSize, false));\n  }\n\n  private Bitmap[] generateIconBitmaps(Bitmap origin) {\n    if (origin == null) {\n      return null;\n    }\n    Bitmap[] iconBitmaps = new Bitmap[4];\n    origin = scaleIcon(origin);\n    iconBitmaps[0] = origin.copy(Bitmap.Config.ARGB_8888, true);\n    Canvas canvas = new Canvas(iconBitmaps[0]);\n    canvas.drawColor(baseColor & 0x00ffffff | (Colors.isLight(baseColor) ? 0xff000000 : 0x8a000000), PorterDuff.Mode.SRC_IN);\n    iconBitmaps[1] = origin.copy(Bitmap.Config.ARGB_8888, true);\n    canvas = new Canvas(iconBitmaps[1]);\n    canvas.drawColor(primaryColor, PorterDuff.Mode.SRC_IN);\n    iconBitmaps[2] = origin.copy(Bitmap.Config.ARGB_8888, true);\n    canvas = new Canvas(iconBitmaps[2]);\n    canvas.drawColor(baseColor & 0x00ffffff | (Colors.isLight(baseColor) ? 0x4c000000 : 0x42000000), PorterDuff.Mode.SRC_IN);\n    iconBitmaps[3] = origin.copy(Bitmap.Config.ARGB_8888, true);\n    canvas = new Canvas(iconBitmaps[3]);\n    canvas.drawColor(errorColor, PorterDuff.Mode.SRC_IN);\n    return iconBitmaps;\n  }\n\n  private Bitmap scaleIcon(Bitmap origin) {\n    int width = origin.getWidth();\n    int height = origin.getHeight();\n    int size = Math.max(width, height);\n    if (size == iconSize) {\n      return origin;\n    } else if (size > iconSize) {\n      int scaledWidth;\n      int scaledHeight;\n      if (width > iconSize) {\n        scaledWidth = iconSize;\n        scaledHeight = (int) (iconSize * ((float) height / width));\n      } else {\n        scaledHeight = iconSize;\n        scaledWidth = (int) (iconSize * ((float) width / height));\n      }\n      return Bitmap.createScaledBitmap(origin, scaledWidth, scaledHeight, false);\n    } else {\n      return origin;\n    }\n  }\n\n  public float getFloatingLabelFraction() {\n    return floatingLabelFraction;\n  }\n\n  public void setFloatingLabelFraction(float floatingLabelFraction) {\n    this.floatingLabelFraction = floatingLabelFraction;\n    invalidate();\n  }\n\n  public float getFocusFraction() {\n    return focusFraction;\n  }\n\n  public void setFocusFraction(float focusFraction) {\n    this.focusFraction = focusFraction;\n    invalidate();\n  }\n\n  public float getCurrentBottomLines() {\n    return currentBottomLines;\n  }\n\n  public void setCurrentBottomLines(float currentBottomLines) {\n    this.currentBottomLines = currentBottomLines;\n    initPadding();\n  }\n\n  public boolean isFloatingLabelAlwaysShown() {\n    return floatingLabelAlwaysShown;\n  }\n\n  public void setFloatingLabelAlwaysShown(boolean floatingLabelAlwaysShown) {\n    this.floatingLabelAlwaysShown = floatingLabelAlwaysShown;\n    invalidate();\n  }\n\n  public boolean isHelperTextAlwaysShown() {\n    return helperTextAlwaysShown;\n  }\n\n  public void setHelperTextAlwaysShown(boolean helperTextAlwaysShown) {\n    this.helperTextAlwaysShown = helperTextAlwaysShown;\n    invalidate();\n  }\n\n  @Nullable\n  public Typeface getAccentTypeface() {\n    return accentTypeface;\n  }\n\n  /**\n   * Set typeface used for the accent texts (floating label, error/helper text, character counter, etc.)\n   */\n  public void setAccentTypeface(Typeface accentTypeface) {\n    this.accentTypeface = accentTypeface;\n    this.textPaint.setTypeface(accentTypeface);\n    postInvalidate();\n  }\n\n  public boolean isHideUnderline() {\n    return hideUnderline;\n  }\n\n  /**\n   * Set whether or not to hide the underline (shown by default).\n   * <p/>\n   * The positions of text below will be adjusted accordingly (error/helper text, character counter, ellipses, etc.)\n   * <p/>\n   * NOTE: You probably don\'t want to hide this if you have any subtext features of this enabled, as it can look weird to not have a dividing line between them.\n   */\n  public void setHideUnderline(boolean hideUnderline) {\n    this.hideUnderline = hideUnderline;\n    initPadding();\n    postInvalidate();\n  }\n\n  /**\n   * get the color of the underline for normal state\n   */\n  public int getUnderlineColor() {\n    return underlineColor;\n  }\n\n  /**\n   * Set the color of the underline for normal state\n   * @param color\n   */\n  public void setUnderlineColor(int color) {\n    this.underlineColor = color;\n    postInvalidate();\n  }\n\n  public CharSequence getFloatingLabelText() {\n    return floatingLabelText;\n  }\n\n  /**\n   * Set the floating label text.\n   * <p/>\n   * Pass null to force fallback to use hint\'s value.\n   *\n   * @param floatingLabelText\n   */\n  public void setFloatingLabelText(@Nullable CharSequence floatingLabelText) {\n    this.floatingLabelText = floatingLabelText == null ? getHint() : floatingLabelText;\n    postInvalidate();\n  }\n\n  public int getFloatingLabelTextSize() {\n    return floatingLabelTextSize;\n  }\n\n  public void setFloatingLabelTextSize(int size) {\n    floatingLabelTextSize = size;\n    initPadding();\n  }\n\n  public int getFloatingLabelTextColor() {\n    return floatingLabelTextColor;\n  }\n\n  public void setFloatingLabelTextColor(int color) {\n    this.floatingLabelTextColor = color;\n    postInvalidate();\n  }\n\n  public int getBottomTextSize() {\n    return bottomTextSize;\n  }\n\n  public void setBottomTextSize(int size) {\n    bottomTextSize = size;\n    initPadding();\n  }\n\n  private int getPixel(int dp) {\n    return Density.dp2px(getContext(), dp);\n  }\n\n  private void initPadding() {\n    extraPaddingTop = floatingLabelEnabled ? floatingLabelTextSize + floatingLabelPadding : floatingLabelPadding;\n    textPaint.setTextSize(bottomTextSize);\n    Paint.FontMetrics textMetrics = textPaint.getFontMetrics();\n    extraPaddingBottom = (int) ((textMetrics.descent - textMetrics.ascent) * currentBottomLines) + (hideUnderline ? bottomSpacing : bottomSpacing * 2);\n    extraPaddingLeft = iconLeftBitmaps == null ? 0 : (iconOuterWidth + iconPadding);\n    extraPaddingRight = iconRightBitmaps == null ? 0 : (iconOuterWidth + iconPadding);\n    correctPaddings();\n  }\n\n  /**\n   * calculate {@link #minBottomLines}\n   */\n  private void initMinBottomLines() {\n    boolean extendBottom = minCharacters > 0 || maxCharacters > 0 || singleLineEllipsis || tempErrorText != null || helperText != null;\n    currentBottomLines = minBottomLines = minBottomTextLines > 0 ? minBottomTextLines : extendBottom ? 1 : 0;\n  }\n\n  /**\n   * use {@link #setPaddings(int, int, int, int)} instead, or the paddingTop and the paddingBottom may be set incorrectly.\n   */\n  @Deprecated\n  @Override\n  public final void setPadding(int left, int top, int right, int bottom) {\n    super.setPadding(left, top, right, bottom);\n  }\n\n  /**\n   * Use this method instead of {@link #setPadding(int, int, int, int)} to automatically set the paddingTop and the paddingBottom correctly.\n   */\n  public void setPaddings(int left, int top, int right, int bottom) {\n    innerPaddingTop = top;\n    innerPaddingBottom = bottom;\n    innerPaddingLeft = left;\n    innerPaddingRight = right;\n    correctPaddings();\n  }\n\n  /**\n   * Set paddings to the correct values\n   */\n  private void correctPaddings() {\n    int buttonsWidthLeft = 0, buttonsWidthRight = 0;\n    int buttonsWidth = iconOuterWidth * getButtonsCount();\n    if (isRTL()) {\n      buttonsWidthLeft = buttonsWidth;\n    } else {\n      buttonsWidthRight = buttonsWidth;\n    }\n    super.setPadding(innerPaddingLeft + extraPaddingLeft + buttonsWidthLeft, innerPaddingTop + extraPaddingTop, innerPaddingRight + extraPaddingRight + buttonsWidthRight, innerPaddingBottom + extraPaddingBottom);\n  }\n\n  private int getButtonsCount() {\n    return isShowClearButton() ? 1 : 0;\n  }\n\n  @Override\n  protected void onAttachedToWindow() {\n    super.onAttachedToWindow();\n    if (!firstShown) {\n      firstShown = true;\n    }\n  }\n\n  @Override\n  protected void onLayout(boolean changed, int left, int top, int right, int bottom) {\n    super.onLayout(changed, left, top, right, bottom);\n    if (changed) {\n      adjustBottomLines();\n    }\n  }\n\n  /**\n   * @return True, if adjustments were made that require the view to be invalidated.\n   */\n  private boolean adjustBottomLines() {\n    // Bail out if we have a zero width; lines will be adjusted during next layout.\n    if (getWidth() == 0) {\n      return false;\n    }\n    int destBottomLines;\n    textPaint.setTextSize(bottomTextSize);\n    if (tempErrorText != null || helperText != null) {\n      Layout.Alignment alignment = (getGravity() & Gravity.RIGHT) == Gravity.RIGHT || isRTL() ?\n        Layout.Alignment.ALIGN_OPPOSITE : (getGravity() & Gravity.LEFT) == Gravity.LEFT ?\n        Layout.Alignment.ALIGN_NORMAL : Layout.Alignment.ALIGN_CENTER;\n      textLayout = new StaticLayout(tempErrorText != null ? tempErrorText : helperText, textPaint, getWidth() - getBottomTextLeftOffset() - getBottomTextRightOffset() - getPaddingLeft() - getPaddingRight(), alignment, 1.0f, 0.0f, true);\n      destBottomLines = Math.max(textLayout.getLineCount(), minBottomTextLines);\n    } else {\n      destBottomLines = minBottomLines;\n    }\n    if (bottomLines != destBottomLines) {\n      getBottomLinesAnimator(destBottomLines).start();\n    }\n    bottomLines = destBottomLines;\n    return true;\n  }\n\n  /**\n   * get inner top padding, not the real paddingTop\n   */\n  public int getInnerPaddingTop() {\n    return innerPaddingTop;\n  }\n\n  /**\n   * get inner bottom padding, not the real paddingBottom\n   */\n  public int getInnerPaddingBottom() {\n    return innerPaddingBottom;\n  }\n\n  /**\n   * get inner left padding, not the real paddingLeft\n   */\n  public int getInnerPaddingLeft() {\n    return innerPaddingLeft;\n  }\n\n  /**\n   * get inner right padding, not the real paddingRight\n   */\n  public int getInnerPaddingRight() {\n    return innerPaddingRight;\n  }\n\n  private void initFloatingLabel() {\n    // observe the text changing\n    addTextChangedListener(new TextWatcher() {\n      @Override\n      public void beforeTextChanged(CharSequence s, int start, int count, int after) {\n      }\n\n      @Override\n      public void onTextChanged(CharSequence s, int start, int before, int count) {\n      }\n\n      @Override\n      public void afterTextChanged(Editable s) {\n        if (floatingLabelEnabled) {\n          if (s.length() == 0) {\n            if (floatingLabelShown) {\n              floatingLabelShown = false;\n              getLabelAnimator().reverse();\n            }\n          } else if (!floatingLabelShown) {\n            floatingLabelShown = true;\n            getLabelAnimator().start();\n          }\n        }\n      }\n    });\n    // observe the focus state to animate the floating label\'s text color appropriately\n    innerFocusChangeListener = new OnFocusChangeListener() {\n      @Override\n      public void onFocusChange(View v, boolean hasFocus) {\n        if (floatingLabelEnabled && highlightFloatingLabel) {\n          if (hasFocus) {\n            getLabelFocusAnimator().start();\n          } else {\n            getLabelFocusAnimator().reverse();\n          }\n        }\n        if (validateOnFocusLost && !hasFocus) {\n          validate();\n        }\n        if (outerFocusChangeListener != null) {\n          outerFocusChangeListener.onFocusChange(v, hasFocus);\n        }\n      }\n    };\n    super.setOnFocusChangeListener(innerFocusChangeListener);\n  }\n\n  public boolean isValidateOnFocusLost() {\n    return validateOnFocusLost;\n  }\n\n  public void setValidateOnFocusLost(boolean validate) {\n    this.validateOnFocusLost = validate;\n  }\n\n  public void setBaseColor(int color) {\n    if (baseColor != color) {\n      baseColor = color;\n    }\n\n    initText();\n\n    postInvalidate();\n  }\n\n  public void setPrimaryColor(int color) {\n    primaryColor = color;\n    postInvalidate();\n  }\n\n  /**\n   * Same function as {@link #setTextColor(int)}. (Directly overriding the built-in one could cause some error, so use this method instead.)\n   */\n  public void setMetTextColor(int color) {\n    textColorStateList = ColorStateList.valueOf(color);\n    resetTextColor();\n  }\n\n  /**\n   * Same function as {@link #setTextColor(ColorStateList)}. (Directly overriding the built-in one could cause some error, so use this method instead.)\n   */\n  public void setMetTextColor(ColorStateList colors) {\n    textColorStateList = colors;\n    resetTextColor();\n  }\n\n  private void resetTextColor() {\n    if (textColorStateList == null) {\n      textColorStateList = new ColorStateList(new int[][]{new int[]{android.R.attr.state_enabled}, EMPTY_STATE_SET}, new int[]{baseColor & 0x00ffffff | 0xdf000000, baseColor & 0x00ffffff | 0x44000000});\n      setTextColor(textColorStateList);\n    } else {\n      setTextColor(textColorStateList);\n    }\n  }\n\n  /**\n   * Same function as {@link #setHintTextColor(int)}. (The built-in one is a final method that can\'t be overridden, so use this method instead.)\n   */\n  public void setMetHintTextColor(int color) {\n    textColorHintStateList = ColorStateList.valueOf(color);\n    resetHintTextColor();\n  }\n\n  /**\n   * Same function as {@link #setHintTextColor(ColorStateList)}. (The built-in one is a final method that can\'t be overridden, so use this method instead.)\n   */\n  public void setMetHintTextColor(ColorStateList colors) {\n    textColorHintStateList = colors;\n    resetHintTextColor();\n  }\n\n  private void resetHintTextColor() {\n    if (textColorHintStateList == null) {\n      setHintTextColor(baseColor & 0x00ffffff | 0x44000000);\n    } else {\n      setHintTextColor(textColorHintStateList);\n    }\n  }\n\n  private void setFloatingLabelInternal(int mode) {\n    switch (mode) {\n      case FLOATING_LABEL_NORMAL:\n        floatingLabelEnabled = true;\n        highlightFloatingLabel = false;\n        break;\n      case FLOATING_LABEL_HIGHLIGHT:\n        floatingLabelEnabled = true;\n        highlightFloatingLabel = true;\n        break;\n      default:\n        floatingLabelEnabled = false;\n        highlightFloatingLabel = false;\n        break;\n    }\n  }\n\n  public void setFloatingLabel(@FloatingLabelType int mode) {\n    setFloatingLabelInternal(mode);\n    initPadding();\n  }\n\n  public int getFloatingLabelPadding() {\n    return floatingLabelPadding;\n  }\n\n  public void setFloatingLabelPadding(int padding) {\n    floatingLabelPadding = padding;\n    postInvalidate();\n  }\n\n  public boolean isFloatingLabelAnimating() {\n    return floatingLabelAnimating;\n  }\n\n  public void setFloatingLabelAnimating(boolean animating) {\n    floatingLabelAnimating = animating;\n  }\n\n  public void setSingleLineEllipsis() {\n    setSingleLineEllipsis(true);\n  }\n\n  public void setSingleLineEllipsis(boolean enabled) {\n    singleLineEllipsis = enabled;\n    initMinBottomLines();\n    initPadding();\n    postInvalidate();\n  }\n\n  public int getMaxCharacters() {\n    return maxCharacters;\n  }\n\n  public void setMaxCharacters(int max) {\n    maxCharacters = max;\n    initMinBottomLines();\n    initPadding();\n    postInvalidate();\n  }\n\n  public int getMinCharacters() {\n    return minCharacters;\n  }\n\n  public void setMinCharacters(int min) {\n    minCharacters = min;\n    initMinBottomLines();\n    initPadding();\n    postInvalidate();\n  }\n\n  public int getMinBottomTextLines() {\n    return minBottomTextLines;\n  }\n\n  public void setMinBottomTextLines(int lines) {\n    minBottomTextLines = lines;\n    initMinBottomLines();\n    initPadding();\n    postInvalidate();\n  }\n\n  public boolean isAutoValidate() {\n    return autoValidate;\n  }\n\n  public void setAutoValidate(boolean autoValidate) {\n    this.autoValidate = autoValidate;\n    if (autoValidate) {\n      validate();\n    }\n  }\n\n  public int getErrorColor() {\n    return errorColor;\n  }\n\n  public void setErrorColor(int color) {\n    errorColor = color;\n    postInvalidate();\n  }\n\n  public void setHelperText(CharSequence helperText) {\n    this.helperText = helperText == null ? null : helperText.toString();\n    if (adjustBottomLines()) {\n      postInvalidate();\n    }\n  }\n\n  public String getHelperText() {\n    return helperText;\n  }\n\n  public int getHelperTextColor() {\n    return helperTextColor;\n  }\n\n  public void setHelperTextColor(int color) {\n    helperTextColor = color;\n    postInvalidate();\n  }\n\n  @Override\n  public void setError(CharSequence errorText) {\n    tempErrorText = errorText == null ? null : errorText.toString();\n    if (adjustBottomLines()) {\n      postInvalidate();\n    }\n  }\n\n  @Override\n  public CharSequence getError() {\n    return tempErrorText;\n  }\n\n  /**\n   * only used to draw the bottom line\n   */\n  private boolean isInternalValid() {\n    return tempErrorText == null && isCharactersCountValid();\n  }\n\n  /**\n   * if the main text matches the regex\n   *\n   * @deprecated use the new validator interface to add your own custom validator\n   */\n  @Deprecated\n  public boolean isValid(String regex) {\n    if (regex == null) {\n      return false;\n    }\n    Pattern pattern = Pattern.compile(regex);\n    Matcher matcher = pattern.matcher(getText());\n    return matcher.matches();\n  }\n\n  /**\n   * check if the main text matches the regex, and set the error text if not.\n   *\n   * @return true if it matches the regex, false if not.\n   * @deprecated use the new validator interface to add your own custom validator\n   */\n  @Deprecated\n  public boolean validate(String regex, CharSequence errorText) {\n    boolean isValid = isValid(regex);\n    if (!isValid) {\n      setError(errorText);\n    }\n    postInvalidate();\n    return isValid;\n  }\n\n  /**\n   * Run validation on a single validator instance\n   *\n   * @param validator Validator to check\n   * @return True if valid, false if not\n   */\n  public boolean validateWith(@NonNull METValidator validator) {\n    CharSequence text = getText();\n    boolean isValid = validator.isValid(text, text.length() == 0);\n    if (!isValid) {\n      setError(validator.getErrorMessage());\n    }\n    postInvalidate();\n    return isValid;\n  }\n\n  /**\n   * Check all validators, sets the error text if not\n   * <p/>\n   * NOTE: this stops at the first validator to report invalid.\n   *\n   * @return True if all validators pass, false if not\n   */\n  public boolean validate() {\n    if (validators == null || validators.isEmpty()) {\n      return true;\n    }\n\n    CharSequence text = getText();\n    boolean isEmpty = text.length() == 0;\n\n    boolean isValid = true;\n    for (METValidator validator : validators) {\n      //noinspection ConstantConditions\n      isValid = isValid && validator.isValid(text, isEmpty);\n      if (!isValid) {\n        setError(validator.getErrorMessage());\n        break;\n      }\n    }\n    if (isValid) {\n      setError(null);\n    }\n\n    postInvalidate();\n    return isValid;\n  }\n\n  public boolean hasValidators() {\n    return this.validators != null && !this.validators.isEmpty();\n  }\n\n  /**\n   * Adds a new validator to the View\'s list of validators\n   * <p/>\n   * This will be checked with the others in {@link #validate()}\n   *\n   * @param validator Validator to add\n   * @return This instance, for easy chaining\n   */\n  public MaterialMultiAutoCompleteTextView addValidator(METValidator validator) {\n    if (validators == null) {\n      this.validators = new ArrayList<>();\n    }\n    this.validators.add(validator);\n    return this;\n  }\n\n  public void clearValidators() {\n    if (this.validators != null) {\n      this.validators.clear();\n    }\n  }\n\n  @Nullable\n  public List<METValidator> getValidators() {\n    return this.validators;\n  }\n\n  public void setLengthChecker(METLengthChecker lengthChecker) {\n    this.lengthChecker = lengthChecker;\n  }\n\n  @Override\n  public void setOnFocusChangeListener(OnFocusChangeListener listener) {\n    if (innerFocusChangeListener == null) {\n      super.setOnFocusChangeListener(listener);\n    } else {\n      outerFocusChangeListener = listener;\n    }\n  }\n\n  private ObjectAnimator getLabelAnimator() {\n    if (labelAnimator == null) {\n      labelAnimator = ObjectAnimator.ofFloat(this, "floatingLabelFraction", 0f, 1f);\n    }\n    labelAnimator.setDuration(floatingLabelAnimating ? 300 : 0);\n    return labelAnimator;\n  }\n\n  private ObjectAnimator getLabelFocusAnimator() {\n    if (labelFocusAnimator == null) {\n      labelFocusAnimator = ObjectAnimator.ofFloat(this, "focusFraction", 0f, 1f);\n    }\n    return labelFocusAnimator;\n  }\n\n  private ObjectAnimator getBottomLinesAnimator(float destBottomLines) {\n    if (bottomLinesAnimator == null) {\n      bottomLinesAnimator = ObjectAnimator.ofFloat(this, "currentBottomLines", destBottomLines);\n    } else {\n      bottomLinesAnimator.cancel();\n      bottomLinesAnimator.setFloatValues(destBottomLines);\n    }\n    return bottomLinesAnimator;\n  }\n\n  @Override\n  protected void onDraw(@NonNull Canvas canvas) {\n    int startX = getScrollX() + (iconLeftBitmaps == null ? 0 : (iconOuterWidth + iconPadding));\n    int endX = getScrollX() + (iconRightBitmaps == null ? getWidth() : getWidth() - iconOuterWidth - iconPadding);\n    int lineStartY = getScrollY() + getHeight() - getPaddingBottom();\n\n    // draw the icon(s)\n    paint.setAlpha(255);\n    if (iconLeftBitmaps != null) {\n      Bitmap icon = iconLeftBitmaps[!isInternalValid() ? 3 : !isEnabled() ? 2 : hasFocus() ? 1 : 0];\n      int iconLeft = startX - iconPadding - iconOuterWidth + (iconOuterWidth - icon.getWidth()) / 2;\n      int iconTop = lineStartY + bottomSpacing - iconOuterHeight + (iconOuterHeight - icon.getHeight()) / 2;\n      canvas.drawBitmap(icon, iconLeft, iconTop, paint);\n    }\n    if (iconRightBitmaps != null) {\n      Bitmap icon = iconRightBitmaps[!isInternalValid() ? 3 : !isEnabled() ? 2 : hasFocus() ? 1 : 0];\n      int iconRight = endX + iconPadding + (iconOuterWidth - icon.getWidth()) / 2;\n      int iconTop = lineStartY + bottomSpacing - iconOuterHeight + (iconOuterHeight - icon.getHeight()) / 2;\n      canvas.drawBitmap(icon, iconRight, iconTop, paint);\n    }\n\n    // draw the clear button\n    if (hasFocus() && showClearButton && !TextUtils.isEmpty(getText()) && isEnabled()) {\n      paint.setAlpha(255);\n      int buttonLeft;\n      if (isRTL()) {\n        buttonLeft = startX;\n      } else {\n        buttonLeft = endX - iconOuterWidth;\n      }\n      Bitmap clearButtonBitmap = clearButtonBitmaps[0];\n      buttonLeft += (iconOuterWidth - clearButtonBitmap.getWidth()) / 2;\n      int iconTop = lineStartY + bottomSpacing - iconOuterHeight + (iconOuterHeight - clearButtonBitmap.getHeight()) / 2;\n      canvas.drawBitmap(clearButtonBitmap, buttonLeft, iconTop, paint);\n    }\n\n    // draw the underline\n    if (!hideUnderline) {\n      lineStartY += bottomSpacing;\n      if (!isInternalValid()) { // not valid\n        paint.setColor(errorColor);\n        canvas.drawRect(startX, lineStartY, endX, lineStartY + getPixel(2), paint);\n      } else if (!isEnabled()) { // disabled\n        paint.setColor(underlineColor != -1 ? underlineColor : baseColor & 0x00ffffff | 0x44000000);\n        float interval = getPixel(1);\n        for (float xOffset = 0; xOffset < getWidth(); xOffset += interval * 3) {\n          canvas.drawRect(startX + xOffset, lineStartY, startX + xOffset + interval, lineStartY + getPixel(1), paint);\n        }\n      } else if (hasFocus()) { // focused\n        paint.setColor(primaryColor);\n        canvas.drawRect(startX, lineStartY, endX, lineStartY + getPixel(2), paint);\n      } else { // normal\n        paint.setColor(underlineColor != -1 ? underlineColor : baseColor & 0x00ffffff | 0x1E000000);\n        canvas.drawRect(startX, lineStartY, endX, lineStartY + getPixel(1), paint);\n      }\n    }\n\n    textPaint.setTextSize(bottomTextSize);\n    Paint.FontMetrics textMetrics = textPaint.getFontMetrics();\n    float relativeHeight = -textMetrics.ascent - textMetrics.descent;\n    float bottomTextPadding = bottomTextSize + textMetrics.ascent + textMetrics.descent;\n\n    // draw the characters counter\n    if ((hasFocus() && hasCharactersCounter()) || !isCharactersCountValid()) {\n      textPaint.setColor(isCharactersCountValid() ? (baseColor & 0x00ffffff | 0x44000000) : errorColor);\n      String charactersCounterText = getCharactersCounterText();\n      canvas.drawText(charactersCounterText, isRTL() ? startX : endX - textPaint.measureText(charactersCounterText), lineStartY + bottomSpacing + relativeHeight, textPaint);\n    }\n\n    // draw the bottom text\n    if (textLayout != null) {\n      if (tempErrorText != null || ((helperTextAlwaysShown || hasFocus()) && !TextUtils.isEmpty(helperText))) { // error text or helper text\n        textPaint.setColor(tempErrorText != null ? errorColor : helperTextColor != -1 ? helperTextColor : (baseColor & 0x00ffffff | 0x44000000));\n        canvas.save();\n        if (isRTL()) {\n          canvas.translate(endX - textLayout.getWidth(), lineStartY + bottomSpacing - bottomTextPadding);\n        } else {\n          canvas.translate(startX + getBottomTextLeftOffset(), lineStartY + bottomSpacing - bottomTextPadding);\n        }\n        textLayout.draw(canvas);\n        canvas.restore();\n      }\n    }\n\n    // draw the floating label\n    if (floatingLabelEnabled && !TextUtils.isEmpty(floatingLabelText)) {\n      textPaint.setTextSize(floatingLabelTextSize);\n      // calculate the text color\n      textPaint.setColor((Integer) focusEvaluator.evaluate(focusFraction * (isEnabled() ? 1 : 0), floatingLabelTextColor != -1 ? floatingLabelTextColor : (baseColor & 0x00ffffff | 0x44000000), primaryColor));\n\n      // calculate the horizontal position\n      float floatingLabelWidth = textPaint.measureText(floatingLabelText.toString());\n      int floatingLabelStartX;\n      if ((getGravity() & Gravity.RIGHT) == Gravity.RIGHT || isRTL()) {\n        floatingLabelStartX = (int) (endX - floatingLabelWidth);\n      } else if ((getGravity() & Gravity.LEFT) == Gravity.LEFT) {\n        floatingLabelStartX = startX;\n      } else {\n        floatingLabelStartX = startX + (int) (getInnerPaddingLeft() + (getWidth() - getInnerPaddingLeft() - getInnerPaddingRight() - floatingLabelWidth) / 2);\n      }\n\n      // calculate the vertical position\n      int distance = floatingLabelPadding;\n      int floatingLabelStartY = (int) (innerPaddingTop + floatingLabelTextSize + floatingLabelPadding - distance * (floatingLabelAlwaysShown ? 1 : floatingLabelFraction) + getScrollY());\n\n      // calculate the alpha\n      int alpha = ((int) ((floatingLabelAlwaysShown ? 1 : floatingLabelFraction) * 0xff * (0.74f * focusFraction * (isEnabled() ? 1 : 0) + 0.26f) * (floatingLabelTextColor != -1 ? 1 : Color.alpha(floatingLabelTextColor) / 256f)));\n      textPaint.setAlpha(alpha);\n\n      // draw the floating label\n      canvas.drawText(floatingLabelText.toString(), floatingLabelStartX, floatingLabelStartY, textPaint);\n    }\n\n    // draw the bottom ellipsis\n    if (hasFocus() && singleLineEllipsis && getScrollX() != 0) {\n      paint.setColor(isInternalValid() ? primaryColor : errorColor);\n      float startY = lineStartY + bottomSpacing;\n      int ellipsisStartX;\n      if (isRTL()) {\n        ellipsisStartX = endX;\n      } else {\n        ellipsisStartX = startX;\n      }\n      int signum = isRTL() ? -1 : 1;\n      canvas.drawCircle(ellipsisStartX + signum * bottomEllipsisSize / 2, startY + bottomEllipsisSize / 2, bottomEllipsisSize / 2, paint);\n      canvas.drawCircle(ellipsisStartX + signum * bottomEllipsisSize * 5 / 2, startY + bottomEllipsisSize / 2, bottomEllipsisSize / 2, paint);\n      canvas.drawCircle(ellipsisStartX + signum * bottomEllipsisSize * 9 / 2, startY + bottomEllipsisSize / 2, bottomEllipsisSize / 2, paint);\n    }\n\n    // draw the original things\n    super.onDraw(canvas);\n  }\n\n  @TargetApi(Build.VERSION_CODES.JELLY_BEAN_MR1)\n  private boolean isRTL() {\n    if (Build.VERSION.SDK_INT < Build.VERSION_CODES.JELLY_BEAN_MR1) {\n      return false;\n    }\n    Configuration config = getResources().getConfiguration();\n    return config.getLayoutDirection() == View.LAYOUT_DIRECTION_RTL;\n  }\n\n  private int getBottomTextLeftOffset() {\n    return isRTL() ? getCharactersCounterWidth() : getBottomEllipsisWidth();\n  }\n\n  private int getBottomTextRightOffset() {\n    return isRTL() ? getBottomEllipsisWidth() : getCharactersCounterWidth();\n  }\n\n  private int getCharactersCounterWidth() {\n    return hasCharactersCounter() ? (int) textPaint.measureText(getCharactersCounterText()) : 0;\n  }\n\n  private int getBottomEllipsisWidth() {\n    return singleLineEllipsis ? (bottomEllipsisSize * 5 + getPixel(4)) : 0;\n  }\n\n  private void checkCharactersCount() {\n    if ((!firstShown && !checkCharactersCountAtBeginning) || !hasCharactersCounter()) {\n      charactersCountValid = true;\n    } else {\n      CharSequence text = getText();\n      int count = text == null ? 0 : checkLength(text);\n      charactersCountValid = (count >= minCharacters && (maxCharacters <= 0 || count <= maxCharacters));\n    }\n  }\n\n  public boolean isCharactersCountValid() {\n    return charactersCountValid;\n  }\n\n  private boolean hasCharactersCounter() {\n    return minCharacters > 0 || maxCharacters > 0;\n  }\n\n  private String getCharactersCounterText() {\n    String text;\n    if (minCharacters <= 0) {\n      text = isRTL() ? maxCharacters + " / " + checkLength(getText()) : checkLength(getText()) + " / " + maxCharacters;\n    } else if (maxCharacters <= 0) {\n      text = isRTL() ? "+" + minCharacters + " / " + checkLength(getText()) : checkLength(getText()) + " / " + minCharacters + "+";\n    } else {\n      text = isRTL() ? maxCharacters + "-" + minCharacters + " / " + checkLength(getText()) : checkLength(getText()) + " / " + minCharacters + "-" + maxCharacters;\n    }\n    return text;\n  }\n\n  @Override\n  public boolean onTouchEvent(MotionEvent event) {\n    if (singleLineEllipsis && getScrollX() > 0 && event.getAction() == MotionEvent.ACTION_DOWN && event.getX() < getPixel(4 * 5) && event.getY() > getHeight() - extraPaddingBottom - innerPaddingBottom && event.getY() < getHeight() - innerPaddingBottom) {\n      setSelection(0);\n      return false;\n    }\n    if (hasFocus() && showClearButton && isEnabled()) {\n      switch (event.getAction()) {\n        case MotionEvent.ACTION_DOWN:\n          if (insideClearButton(event)) {\n            clearButtonTouched = true;\n            clearButtonClicking = true;\n            return true;\n          }\n        case MotionEvent.ACTION_MOVE:\n          if (clearButtonClicking && !insideClearButton(event)) {\n            clearButtonClicking = false;\n          }\n          if (clearButtonTouched) {\n            return true;\n          }\n          break;\n        case MotionEvent.ACTION_UP:\n          if (clearButtonClicking) {\n            if (!TextUtils.isEmpty(getText())) {\n              setText(null);\n            }\n            clearButtonClicking = false;\n          }\n          if (clearButtonTouched) {\n            clearButtonTouched = false;\n            return true;\n          }\n          clearButtonTouched = false;\n          break;\n        case MotionEvent.ACTION_CANCEL:\n          clearButtonTouched = false;\n          clearButtonClicking = false;\n          break;\n      }\n    }\n    return super.onTouchEvent(event);\n  }\n\n  private boolean insideClearButton(MotionEvent event) {\n    float x = event.getX();\n    float y = event.getY();\n    int startX = getScrollX() + (iconLeftBitmaps == null ? 0 : (iconOuterWidth + iconPadding));\n    int endX = getScrollX() + (iconRightBitmaps == null ? getWidth() : getWidth() - iconOuterWidth - iconPadding);\n    int buttonLeft;\n    if (isRTL()) {\n      buttonLeft = startX;\n    } else {\n      buttonLeft = endX - iconOuterWidth;\n    }\n    int buttonTop = getScrollY() + getHeight() - getPaddingBottom() + bottomSpacing - iconOuterHeight;\n    return (x >= buttonLeft && x < buttonLeft + iconOuterWidth && y >= buttonTop && y < buttonTop + iconOuterHeight);\n  }\n\n  private int checkLength(CharSequence text) {\n    if (lengthChecker==null) return text.length();\n    return lengthChecker.getLength(text);\n  }\n}'