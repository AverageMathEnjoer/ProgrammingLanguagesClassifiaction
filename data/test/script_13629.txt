b'{-# LANGUAGE CPP, FlexibleInstances, ForeignFunctionInterface #-}\nmodule Main where\n\nimport Control.Applicative\nimport Control.Monad\nimport Control.Monad.IO.Class\nimport Control.Monad.ST\n\n-- #define UNBOXED\n#ifdef UNBOXED\nimport qualified Data.Vector.Unboxed as V \nimport qualified Data.Vector.Unboxed.Mutable as MV\n#else\nimport qualified Data.Vector.Storable as V \nimport qualified Data.Vector.Storable.Mutable as MV\n#endif\n\nimport qualified Debug.Trace as DT\n\nimport System.Random.MWC (create, uniformVector, uniformR)\n\nimport System.Environment\nimport Control.Exception\nimport Test.QuickCheck (Arbitrary, arbitrary, sized, choose, vector)\n\nimport Data.List.Split (chunksOf)\nimport Data.List (intersperse)\n\nimport Data.Word (Word32)\nimport Data.Time.Clock\nimport Text.Printf\nimport Data.Vector.Algorithms.Merge (sort)\n\n#ifdef GPU_ENABLED\nimport Foreign.CUDA.Driver    (initialise)\nimport Foreign.CUDA.Runtime.Device (reset, setFlags, DeviceFlag(..))\n#endif\n\nimport Foreign.Ptr\nimport Foreign.C.Types\nimport Foreign.Marshal.Array (allocaArray)\nimport System.IO.Unsafe(unsafePerformIO)\n\n#ifdef PARSCHED\nimport PARSCHED\n#elif 0\nimport Control.Monad.Par.Meta.SMPMergeSort\n#define GPU_ENABLED\n#else\n-- import Control.Monad.Par\nimport Control.Monad.Par.IO\nimport Control.Monad.Par.Class\ntype Par a = ParIO a\n#endif\n\n--------------------------------------------------------------------------------\n\n-- Element type being sorted:\ntype ElmT  = Word32\ntype CElmT = CUInt\n\n-- Here we can choose safe or unsafe operations:\n#ifndef SAFE\nthawit  x     = V.unsafeThaw   x\nnewMV   x     = MV.unsafeNew   x\nreadMV  x y   = MV.unsafeRead  x y\nwriteMV x y z = MV.unsafeWrite x y z\nsliceMV x y z = MV.unsafeSlice x y z\ncopyMV  x y   = MV.unsafeCopy  x y \n#else\nthawit  x     = V.thaw   x\nnewMV   x     = MV.new   x\nreadMV  x y   = MV.read  x y\nwriteMV x y z = MV.write x y z\nsliceMV x y z = MV.slice x y z\ncopyMV  x y   = MV.copy  x y \n#endif\n{-# INLINE thawit #-}\n{-# INLINE newMV #-}\n{-# INLINE readMV #-}\n{-# INLINE writeMV #-}\n{-# INLINE sliceMV #-}\n{-# INLINE copyMV #-}\n\n----------------------------------------------------------------------------------------------------\n-- A zoo of mergesort variations!\n----------------------------------------------------------------------------------------------------\n\n-- import System.Random.Mersenne\n-- import Random.MWC.Pure (seed, range_random)\n\n-- | Vector.Algorithms sort\n#ifdef OLDTYPES      \nseqsort :: V.Vector ElmT -> Par (V.Vector ElmT)\n#endif\nseqsort v = return $ V.create $ do \n--                mut <- thawit v\n                mut <- V.thaw v\n                -- This is the pure-haskell sort on mutable vectors\n                -- from the vector-algorithms package:\n                sort mut\n                return mut\n\n#if defined(CILK_SEQ) || defined (CILK_PAR)\nforeign import ccall unsafe "wrap_seqquick"\n  c_seqquick :: Ptr CElmT -> CLong -> IO (Ptr CElmT)\n\n-- | Sequential Cilk sort\ncilkSeqSort :: V.Vector ElmT -> Par (V.Vector ElmT)\ncilkSeqSort v = liftIO $ do\n  mutv <- V.thaw v\n  MV.unsafeWith mutv $ \\vptr ->\n    c_seqquick (castPtr vptr) (fromIntegral $ V.length v)\n  V.unsafeFreeze mutv\n\nforeign import ccall unsafe "wrap_cilksort"\n  c_cilksort ::  Ptr CElmT -> Ptr CElmT -> CLong -> IO CLong\n\n-- | Cilk sort using the Cilk runtime, meant to trigger\n-- oversubscription\ncilkRuntimeSort :: V.Vector ElmT -> Par (V.Vector ElmT)\ncilkRuntimeSort v = liftIO $ do\n    mutv <- V.thaw v\n    MV.unsafeWith mutv $ \\vptr ->\n      allocaArray (V.length v) $ \\tptr ->\n        c_cilksort (castPtr vptr) tptr (fromIntegral $ V.length v)\n    V.unsafeFreeze mutv  \n\nforeign import ccall unsafe "wrap_seqmerge"\n  c_seqmerge ::  Ptr CElmT -> CLong -> Ptr CElmT -> CLong -> Ptr CElmT -> IO ()\n\ncilkSeqMerge :: V.Vector ElmT -> V.Vector ElmT -> V.Vector ElmT\ncilkSeqMerge v1 v2 = unsafePerformIO $ do\n    mutv1 <- thawit v1\n    mutv2 <- thawit v2\n    let len1 = V.length v1\n\tlen2 = V.length v2\n--    V.create $ do \n    do\n       dest <- newMV (len1 + len2)\n--       dest <- MV.unsafeNew (len1 + len2)\n       MV.unsafeWith mutv1 $ \\vptr1 ->\n\tMV.unsafeWith mutv2 $ \\vptr2 ->         \n\t MV.unsafeWith dest $ \\vdest ->\n\t    c_seqmerge (castPtr vptr1) (fromIntegral len1) \n\t\t       (castPtr vptr2) (fromIntegral len2) \n\t\t       (castPtr vdest)\n--       return dest\n       V.unsafeFreeze dest\n#endif\n-- End CILK block.\n\n-- Merge sort for a Vector using the Par monad\n-- t is the threshold for using sequential merge (see merge)\n#ifdef OLDTYPES      \ncpuMergeSort :: Int -> (V.Vector ElmT -> Par (V.Vector ElmT)) -> V.Vector ElmT -> Par (V.Vector ElmT)\n#else\ncpuMergeSort :: Int -> (V.Vector ElmT -> Par d s (V.Vector ElmT)) -> V.Vector ElmT -> Par d s (V.Vector ElmT)\n#endif\ncpuMergeSort t cpuMS vec = if V.length vec <= t\n                           then cpuMS vec\n                           else do\n                      let n = (V.length vec) `div` 2\n                      let (lhalf, rhalf) = V.splitAt n vec\n                      ileft <- spawn_ (cpuMergeSort t cpuMS lhalf)\n                      right <-         cpuMergeSort t cpuMS rhalf\n                      left  <- get ileft\n                      merge t left right\n\ntype RangedThreshold = (Int, Int)            \n\ninRange :: Int -> RangedThreshold -> Bool\ninRange n (lo, hi) = lo <= n && n <= hi\n\nbelowRange :: Int -> RangedThreshold -> Bool\nbelowRange n (lo, _) = lo > n\n\n#ifdef GPU_ENABLED\n-- | This one statically does HALF the work on the GPU and HALF on the CPU.\nstaticMergeSort :: Int                              -- ^ CPU threshold\n                -> Int                              -- ^ GPU threshold\n                -> (V.Vector ElmT -> Par (V.Vector ElmT)) -- ^ sequential CPU sort\n                -> Bool                                   -- ^ blocking GPU?\n                -> V.Vector ElmT                    -- ^ Vector to sort\n                -> Par (V.Vector ElmT)\nstaticMergeSort cpuT gpuT cpuMS isBlocking vec = divide \n  where\n    (k, r) = V.length vec `divMod` 1024\n    nGPU   = let (k\', parity) = k `divMod` 2 in 1024 * (k\' + parity)\n    divide = do\n      let (gpuHalf, cpuHalf) = V.splitAt nGPU vec\n      case (V.length gpuHalf, V.length cpuHalf) of\n        (0, 0) -> return V.empty\n        (0, _) -> mergeCPU cpuHalf\n        (_, 0) -> mergeGPU gpuHalf\n        _ -> do\n          ileft <- spawn_ (mergeCPU cpuHalf)\n          right <-         mergeGPU gpuHalf\n          left  <- get ileft\n          merge cpuT left right\n\n    -- | All leaves bottom out to cpu mergesort:\n    mergeCPU vec | V.length vec <= cpuT = cpuMS vec\n                 | otherwise         = do\n      let n = (V.length vec) `div` 2\n      let (lhalf, rhalf) = V.splitAt n vec\n      ileft <- spawn_ (mergeCPU lhalf)\n      right <-         mergeCPU rhalf\n      left  <- get ileft\n      merge cpuT left right\n\n    -- | All leaves bottom out to GPU (blocking or not):\n    mergeGPU vec | V.length vec <= gpuT =\n      case isBlocking of\n        False -> get =<< spawnGPUMergeSort vec\n        True  -> liftIO $ blockingGPUMergeSort vec\n    mergeGPU vec = do\n      let n = (V.length vec) `div` 2\n      let (lhalf, rhalf) = V.splitAt n vec\n      ileft <- spawn_ (mergeGPU lhalf)\n      right <-         mergeGPU rhalf\n      left  <- get ileft\n      merge cpuT left right\n\n\n-- | Dynamic work-stealing sort; assumes that subproblems are split\n-- into multiples of 1024.\ndynamicMergeSort :: Int                                    -- ^ CPU threshold\n                 -> RangedThreshold                        -- ^ GPU threshold\n                 -> (V.Vector ElmT -> Par (V.Vector ElmT)) -- ^ sequential CPU sort\n                 -> V.Vector ElmT                          -- ^ Vector to sort\n                 -> Par (V.Vector ElmT)\ndynamicMergeSort cpuT gpuT cpuMS vec | V.length vec `belowRange` gpuT =\n  get =<< spawnCPUGPUMergeSort (cpuMergeSort cpuT cpuMS) vec\ndynamicMergeSort cpuT gpuT cpuMS vec | V.length vec `inRange` gpuT =\n  get =<< spawnCPUGPUMergeSort (dynamicMergeSort cpuT gpuT cpuMS) vec\ndynamicMergeSort cpuT gpuT cpuMS vec = do\n  let n = (V.length vec) `div` 2\n  let (lhalf, rhalf) = V.splitAt n vec\n  ileft <- spawn_ (dynamicMergeSort cpuT gpuT cpuMS lhalf)\n  right <-        (dynamicMergeSort cpuT gpuT cpuMS rhalf)\n  left  <- get ileft\n  merge cpuT left right\n\n#endif /* End if GPU_ENABLED */\n\n\n-- If either list has length less than t, use sequential merge. Otherwise:\n--   1. Find the median of the two combined lists using findSplit\n--   2. Split the lists at the median\n--   3. Merge each of the lefts and rights\n--   4. Append the merged lefts and the merged rights\n#ifdef OLDTYPES                 \nmerge :: Int -> (V.Vector ElmT) -> (V.Vector ElmT) -> Par (V.Vector ElmT)\n#endif\nmerge t left right =\n        if V.length left  < t || \n           V.length right < t\n#if  defined(CILK_SEQ) || defined(CILK_PAR)\n        then return $ cilkSeqMerge left right\n#else\n        then return $ seqmerge left right\n#endif\n        else do\n            let (splitL, splitR) = findSplit left right\n            let (llhalf, rlhalf) = V.splitAt splitL left\n            let (lrhalf, rrhalf) = V.splitAt splitR right\n            isortLeft <- spawn_ (merge t llhalf lrhalf)\n            sortRight <-         merge t rlhalf rrhalf\n            sortLeft  <- get isortLeft\n            -- NOTE: this append is where our most expensive copies\n            -- happen, in contrast, for example with the Cilk\n            -- implementation, which is fully inplace:\n            return (sortLeft V.++ sortRight)\n        \n{-\n - Given two sorted vectors, return a pair of indices such that splitting on \n - these indices results in 4 vectors in which every value in the two left \n - side vectors is smaller than all of the values in the right side vectors.\n -\n - In other words, if lIndex and rIndex are the splitting points for the\n - vectors named left and right, then every item in left, up to lIndex, is\n - smaller than every item in right from rIndex on; and every item in right,\n - up to rIndex, is smaller than every item in left from lIndex on.\n -\n - Additionally, (lIndex + rIndex) should be as close to \n - (length(left) + length(right))/2 as possible.\n -}\nfindSplit :: V.Vector ElmT -> V.Vector ElmT -> (Int, Int)\nfindSplit left right = (lIndex, rIndex)\n        where\n            (lIndex, rIndex) = split 0 (V.length left) 0 (V.length right)\n\n            split :: Int -> Int -> Int -> Int -> (Int, Int)\n            split lLow lHigh rLow rHigh = \n                let lIndex = (lLow + lHigh) `div` 2\n                    rIndex = (rLow + rHigh) `div` 2 in\n                    \n                    if (lIndex == 0)\n                    then if (right V.! (rIndex - 1)) < (left V.! lIndex)\n                         then (lIndex, rIndex)\n                         else split 0 0 rLow rIndex\n                    else if (rIndex == 0)\n                    then if (left V.! (lIndex - 1)) < (right V.! rIndex)\n                         then (lIndex, rIndex)\n                         else split lLow lIndex 0 0\n                    else if (left V.! (lIndex - 1)) < (right V.! rIndex) &&\n                            (right V.! (rIndex - 1)) < (left V.! lIndex)\n                    then (lIndex, rIndex)\n                    else if (left V.! (lIndex - 1)) < (right V.! rIndex)\n                    then split lIndex lHigh rLow rIndex\n                    else split lLow lIndex rIndex rHigh\n\n-- | Sequential merge: takes two sorted vectors and merges them in a sequential\n-- fashion.\n-- This is an imperative version using the ST monad:\nseqmerge :: V.Vector ElmT -> V.Vector ElmT -> V.Vector ElmT\nseqmerge left_ right_ = \n--    DT.trace ("seqmerge "++ show (left_, right_)) $\n    -- TODO: Should probably prevent this being called on empty vectors:\n    if V.null left_  then right_ else \n    if V.null right_ then left_  else \n    V.create $ do\n      let lenL = V.length left_\n\t  lenR = V.length right_\n\t  len  = lenL + lenR \n      left  <- thawit left_\n      right <- thawit right_\n      dest  <- newMV len      \n      -- Ideally this would be replaced with a vectorized sorting\n      -- network (e.g. a bitonic network)!\n      let \n          -- lx is the element stored in position li of `left`:\n\t  loop li lx ri rx di = \n            let di\' = di+1 in\n            if lx < rx then do \n               writeMV dest di lx\n               let li\' = li+1\n               if li\' == lenL then\n\t\t  copyOffset right dest ri di\' (lenR - ri)\n                else when (di\' < len) $ do\n                  lx\' <- readMV left li\'\n                  loop li\' lx\' ri rx di\'\n            else do \n               writeMV dest di rx\n               let ri\' = ri+1\n               if ri\' == lenR then\n\t\t  copyOffset left dest li di\' (lenL - li)\n                else when (di\' < len) $ do\n                  rx\' <- readMV right ri\'\n                  loop li lx ri\' rx\' di\'\n      fstL <- readMV left  0\n      fstR <- readMV right 0\n      loop 0 fstL 0 fstR 0\n      return dest\n\n-- RRN: We could also consider an FFI seqmerge!  That would be\n-- consistent with our FFI calls on the sorting leaves.\n\n----------------------------------------------------------------------------------------------------\n-- Misc Helpers:\n\n#if 0\n-- RRN: This appears to space leak:\nmkRandomVec :: Int -> IO (V.Vector ElmT)\nmkRandomVec n = do\n  g <- create\n  uniformVector g n :: IO (V.Vector ElmT)\n-- mkRandomVec n = withSystemRandom $ \\g -> uniformVector g n :: IO (V.Vector ElmT)\n\n#else \n-- | Create a vector containing the numbers [0,N) in random order.\nmkRandomVec :: Int -> IO (V.Vector ElmT)\nmkRandomVec len = return $ \n  -- Annoyingly there is no MV.generate:\n  V.create (do g <- create\n               v <- thawit$ V.generate len fromIntegral\n               loop 0 v g)\n where \n  -- Note: creating 2^24 elements takes 1.6 seconds under -O2 but 36\n  -- seconds under -O0.  This sorely needs optimization!\n  loop n vec g | n == len  = return vec\n\t       | otherwise = do \n--    let (offset,g\') = randomR (0, len - n - 1) g\n    offset <- uniformR (0, len - n - 1) g\n    MV.swap vec n (n + offset)\n    loop (n+1) vec g\n#endif\n\n\n-- | Format a large number with commas.\ncommaint :: (Show a, Integral a) => a -> String\ncommaint n | n < 0 = "-" ++ commaint (-n)\ncommaint n = \n   reverse $ concat $\n   intersperse "," $ \n   chunksOf 3 $ reverse (show n)\n\n\n-- copyOffset :: (PrimMonad m, MVector v e)\n--            => v (PrimState m) e -> v (PrimState m) e -> Int -> Int -> Int -> m ()\ncopyOffset :: MV.MVector s ElmT -> MV.MVector s ElmT -> Int -> Int -> Int -> ST s ()\ncopyOffset from to iFrom iTo len =\n  copyMV (sliceMV iTo len to)\n\t (sliceMV iFrom len from)\n{-# INLINE copyOffset #-}\n\n\n----------------------------------------------------------------------------------------------------\n\nisMode "cpu"     = True\nisMode "gpu"     = True\nisMode "dynamic" = True\nisMode "static"  = True\nisMode "static_blocking" = True\nisMode _         = False\n\n\n-- | Main, based on quicksort main\n-- Usage: ./Main [mode] [expt] [threshold] [gpulo expt] [gpuhi expt]\n--   mode is one of:\n--     * cpu (parallel cpu sort)\n--     * static (50/50 cpu/gpu work)\n--     * static_blocking (same as static, but GPU calls block par threads)\n--     * dynamic (work stealing between cpu/gpu)\n--   t is threshold to bottom out to sequential sort and sequential merge\n--   expt controls the length of the vector to sort (length = 2^expt)\n--   gpulo, gpuhi constrain the vector sizes where dynamic will potentially\n--     execute on the GPU; (2^gpulo) <= n <= (2^gpuhi). Has no effect on other modes.\nmain = do args <- getArgs\n          let (mode, lo, hi, expt, t) =\n                  case args of\n                    -- The default size should be very small.\n                    -- Just for testing, not for benchmarking:\n--                    []     -> ("dynamic", 16, 22, 10, 2)\n                    []     -> ("cpu", 16,22, 10, 32)\n                    -- hack for SHORTRUN in benchmark script\n                    ["cpu"] -> ("cpu", 16,22, 10, 32)\n                    -- "Dynamic partitioning takes extra arguments:"\n                    ["dynamic", n, t, lo, hi] \n                           -> ("dynamic", (read lo), (read hi), (read n), (read t))\n                    [mode, n]    | isMode mode -> (mode, 16, 22, read n, 8192)\n                    [mode, n, t] | isMode mode -> (mode, 16, 22, read n, read t)\n                    xs -> error $ "invalid argument list, expecting cpu/dynamic [log_2(numelems)]: " ++ unwords xs\n              gpuThi = 2 ^ (min 22 hi)\n              gpuTlo = 2 ^ lo\n              gpuT   = (gpuTlo, gpuThi)\n#ifdef CILK_SEQ\n              cpuMS x = cilkSeqSort x\n#elif defined(CILK_PAR)\n              cpuMS x = cilkRuntimeSort x\n#else\n              cpuMS x = seqsort x \n#endif\n\n--              parComp :: V.Vector ElmT -> Par d s (V.Vector ElmT)\n              parComp \n                      | mode == "cpu"     = cpuMergeSort t cpuMS\n#ifdef GPU_ENABLED\n                      | mode == "gpu"     = \\v -> get =<< spawnGPUMergeSort v\n                      | mode == "dynamic" = dynamicMergeSort t gpuT cpuMS\n                      | mode == "static"  = staticMergeSort t gpuThi cpuMS False\n                      | mode == "static_blocking"  = staticMergeSort t gpuThi cpuMS True\n\n          initialise [] -- CUDA initialize.\n          reset\n--          setFlags [BlockingSync] -- set sync behavior to wait on OS primitive\n--          setFlags [ScheduleYield] -- set sync behavior to yield periodically\n\n#endif\n--          g <- getStdGen\n\n          putStrLn $ "Merge sorting " ++ commaint (2^expt) ++ \n                     " elements. First generate a random permutation:"\n\n#ifdef CILK_SEQ\n          putStrLn $ "CILK_SEQ: Using sequential quicksort from cilksort.c ..."\n#elif defined(CILK_PAR)\n          putStrLn $ "CILK_PAR: Using paralell mergesort from cilksort.c ..."\n#endif\n\n          start <- getCurrentTime\n--          let rands = randomPermutation (2^expt) g\n          rands <- mkRandomVec (2^expt)\n          evaluate$ rands\n          evaluate$ rands V.! 0\n          end   <- getCurrentTime\n          printf "Creating vector took %0.3f sec.\\n"\n            ((fromRational$ toRational $ diffUTCTime end start) :: Double)\n\n          putStrLn "Executing monad-par based sort..."\n          start <- getCurrentTime\n          sorted <- runParIO $ parComp rands\n          putStr "Beginning of sorted list:\\n  "\n          print $ V.slice 0 8 sorted\n          end   <- getCurrentTime\n          putStr "End of sorted list:\\n  "\n          print $ V.slice (V.length rands - 8) 8 sorted\n\n          -- TODO: Verify that the output is correct!  (After timing is finished.)\n\n          let runningTime = ((fromRational $ toRational $ diffUTCTime end start) :: Double)\n          printf "Sorting vector took %0.3f sec.\\n" runningTime\n          putStrLn $ "SELFTIMED " ++ show runningTime\n          when (expt <= 4) $ do\n            putStrLn$ "  Unsorted: " ++  show rands\n            putStrLn$ "  Sorted  : " ++  show sorted\n#ifdef GPU_ENABLED\n          -- reset CUDA driver\n          reset\n#endif\n\n\n-- Needed for Par monad to work with unboxed vectors\n-- instance NFData (V.Vector Int) where\n--   rnf = rnf . V.toList\n-- \n-- RRN: This ^^ is very inefficient!  If you did want to force the\n-- evaluation, at the very worst you would want to do a fold to\n-- traverse a (boxed) vector, but with an unboxed vector the whole\n-- thing is evaluated when one element is.  It should be enough to\n-- read one element.  (It *might* be enough to just use "pseq" or\n-- "evaluate" on the vector value itself, but I\'m not sure.)\n\n\n-- Used for QuickCheck\ninstance Arbitrary (V.Vector Int) where\n    arbitrary = do\n        ls <- sized (\\n -> choose (0, n) >>= vector)\n        return (V.fromList ls)\n\n----------------------------------------------------------------------------------------------------\n-- SCRAP:\n\n-- Although vector cons is supported, it requires O(n) time. Since list cons\n-- is much faster, we\'ll build up a list of tuples and use the batch update\n-- for vectors: (//).\nseqmerge_pure :: V.Vector ElmT -> V.Vector ElmT -> V.Vector ElmT\nseqmerge_pure left right = \n    -- (left V.++ right) V.// (seqhelp 0 left right)\n    V.unsafeUpd (V.replicate len 0) (seqhelp 0 left right)\n\n    where\n        len = (V.length left) + (V.length right)\n        seqhelp :: Int -> V.Vector ElmT -> V.Vector ElmT -> [(Int, ElmT)]\n        seqhelp n left right = \n            if n >= len\n            then []\n            else if V.null left\n            then zip [n..(n + V.length right)] (V.toList right)\n            else if V.null right\n            then zip [n..(n + V.length left)]  (V.toList left)\n            else if (V.head left) < (V.head right)\n            then (n, V.head left)  : seqhelp (n+1) (V.tail left) right\n            else (n, V.head right) : seqhelp (n+1) left (V.tail right)\n'