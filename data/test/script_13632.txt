b'{-# LANGUAGE Arrows     #-}\n{-# LANGUAGE CPP        #-}\n{-# LANGUAGE Rank2Types #-}\n-- |\n-- Copyright  : (c) Ivan Perez and Manuel Baerenz, 2016\n-- License    : BSD3\n-- Maintainer : ivan.perez@keera.co.uk\n--\n-- \'MSF\'s in the \'ExceptT\' monad are monadic stream functions that can throw\n-- exceptions, i.e. return an exception value instead of a continuation. This\n-- module gives ways to throw exceptions in various ways, and to handle them\n-- through a monadic interface.\nmodule Control.Monad.Trans.MSF.Except\n    ( module Control.Monad.Trans.MSF.Except\n    , module Control.Monad.Trans.Except\n    )\n  where\n\n-- External imports\n#if !MIN_VERSION_base(4,8,0)\nimport           Control.Applicative        (Applicative (..), (<$>))\n#endif\n\nimport           Control.Arrow              (arr, returnA, (<<<), (>>>))\nimport qualified Control.Category           as Category\nimport           Control.Monad              (ap, liftM)\nimport           Control.Monad.Trans.Class  (lift)\nimport           Control.Monad.Trans.Except hiding (liftCallCC, liftListen,\n                                             liftPass)\nimport           Control.Monad.Trans.Maybe  (MaybeT, runMaybeT)\nimport           Data.Void                  (Void)\n\n-- Internal imports\nimport Data.MonadicStreamFunction              (arrM, constM, count, feedback,\n                                                liftTransS, mapMaybeS, morphS,\n                                                reactimate)\nimport Data.MonadicStreamFunction.InternalCore (MSF (MSF, unMSF))\n\n-- External, necessary for older base versions\n#if !MIN_VERSION_base(4,10,0)\nfromLeft  :: a -> Either a b -> a\nfromLeft  _ (Left  a) = a\nfromLeft  a (Right _) = a\nfromRight :: b -> Either a b -> b\nfromRight _ (Right b) = b\nfromRight b (Left  _) = b\n#else\nimport           Data.Either                (fromLeft, fromRight)\n#endif\n\n-- * Throwing exceptions\n\n-- | Throw the exception \'e\' whenever the function evaluates to \'True\'.\nthrowOnCond :: Monad m => (a -> Bool) -> e -> MSF (ExceptT e m) a a\nthrowOnCond cond e = proc a -> if cond a\n  then throwS  -< e\n  else returnA -< a\n\n-- | Throws the exception when the input is \'True\'. Variant of \'throwOnCond\'\n-- for Kleisli arrows.\nthrowOnCondM :: Monad m => (a -> m Bool) -> e -> MSF (ExceptT e m) a a\nthrowOnCondM cond e = proc a -> do\n  b <- arrM (lift . cond) -< a\n  if b\n    then throwS  -< e\n    else returnA -< a\n\n-- | Throw the exception when the input is \'True\'.\nthrowOn :: Monad m => e -> MSF (ExceptT e m) Bool ()\nthrowOn e = proc b -> throwOn\' -< (b, e)\n\n-- | Variant of \'throwOn\', where the exception may change every tick.\nthrowOn\' :: Monad m => MSF (ExceptT e m) (Bool, e) ()\nthrowOn\' = proc (b, e) -> if b\n  then throwS  -< e\n  else returnA -< ()\n\n-- | When the input is @Just e@, throw the exception @e@. (Does not output any\n-- actual data.)\nthrowMaybe :: Monad m => MSF (ExceptT e m) (Maybe e) (Maybe a)\nthrowMaybe = mapMaybeS throwS\n\n-- | Immediately throw the incoming exception.\nthrowS :: Monad m => MSF (ExceptT e m) e a\nthrowS = arrM throwE\n\n-- | Immediately throw the given exception.\nthrow :: Monad m => e -> MSF (ExceptT e m) a b\nthrow = constM . throwE\n\n-- | Do not throw an exception.\npass :: Monad m => MSF (ExceptT e m) a a\npass = Category.id\n\n-- | Converts an \'MSF\' in \'MaybeT\' to an \'MSF\' in \'ExceptT\'. Whenever\n-- \'Nothing\' is thrown, throw @()@ instead.\nmaybeToExceptS :: (Functor m, Monad m)\n               => MSF (MaybeT m) a b -> MSF (ExceptT () m) a b\nmaybeToExceptS = morphS (ExceptT . (maybe (Left ()) Right <$>) . runMaybeT)\n\n-- * Catching exceptions\n\n-- | Catch an exception in an \'MSF\'. As soon as an exception occurs, the\n-- current continuation is replaced by a new \'MSF\', the exception handler,\n-- based on the exception value. For exception catching where the handler can\n-- throw further exceptions, see \'MSFExcept\' further below.\ncatchS :: Monad m => MSF (ExceptT e m) a b -> (e -> MSF m a b) -> MSF m a b\ncatchS msf f = safely $ do\n  e <- try msf\n  safe $ f e\n\n-- | Similar to Yampa\'s delayed switching. Loses a @b@ in case of an exception.\nuntilE :: Monad m\n       => MSF m a b\n       -> MSF m b (Maybe e)\n       -> MSF (ExceptT e m) a b\nuntilE msf msfe = proc a -> do\n  b  <- liftTransS msf  -< a\n  me <- liftTransS msfe -< b\n  inExceptT -< ExceptT $ return $ maybe (Right b) Left me\n\n-- | Escape an \'ExceptT\' layer by outputting the exception whenever it occurs.\n-- If an exception occurs, the current \'MSF\' continuation is tested again on\n-- the next input.\nexceptS :: (Functor m, Monad m) => MSF (ExceptT e m) a b -> MSF m a (Either e b)\nexceptS = transG return $ const $ fmap f . runExceptT\n  where\n    f (Left e)       = (Left e , Nothing)\n    f (Right (b, c)) = (Right b, Just c )\n\n-- | Embed an \'ExceptT\' value inside the \'MSF\'. Whenever the input value is an\n-- ordinary value, it is passed on. If it is an exception, it is raised.\ninExceptT :: Monad m => MSF (ExceptT e m) (ExceptT e m a) a\ninExceptT = arrM id\n\n-- | In case an exception occurs in the first argument, replace the exception\n-- by the second component of the tuple.\ntagged :: Monad m => MSF (ExceptT e1 m) a b -> MSF (ExceptT e2 m) (a, e2) b\ntagged msf = runMSFExcept $ do\n  _       <- try $ msf <<< arr fst\n  (_, e2) <- currentInput\n  return e2\n\n-- * Monad interface for Exception MSFs\n\n-- | \'MSF\'s with an \'ExceptT\' transformer layer are in fact monads /in the\n-- exception type/.\n--\n--   * \'return\' corresponds to throwing an exception immediately.\n--   * \'>>=\' is exception handling: The first value throws an exception, while\n--     the Kleisli arrow handles the exception and produces a new signal\n--     function, which can throw exceptions in a different type.\n--   * @m@: The monad that the \'MSF\' may take side effects in.\n--   * @a@: The input type\n--   * @b@: The output type\n--   * @e@: The type of exceptions that can be thrown\nnewtype MSFExcept m a b e = MSFExcept { runMSFExcept :: MSF (ExceptT e m) a b }\n\n-- | Execute an \'MSF\' in \'ExceptT\' until it raises an exception.\n--\n-- An alias for the \'MSFExcept\' constructor, used to enter the \'MSFExcept\'\n-- monad context.\ntry :: MSF (ExceptT e m) a b -> MSFExcept m a b e\ntry = MSFExcept\n\n-- | Immediately throw the current input as an exception.\ncurrentInput :: Monad m => MSFExcept m e b e\ncurrentInput = try throwS\n\n-- | Functor instance for MSFs on the \'Either\' monad. Fmapping is the same as\n-- applying a transformation to the \'Left\' values.\ninstance Monad m => Functor (MSFExcept m a b) where\n  fmap = liftM\n\n-- | Applicative instance for MSFs on the \'Either\' monad. The function \'pure\'\n-- throws an exception.\ninstance Monad m => Applicative (MSFExcept m a b) where\n  pure = MSFExcept . throw\n  (<*>) = ap\n\n-- | Monad instance for \'MSFExcept\'. Bind uses the exception as the \'return\'\n-- value in the monad.\ninstance Monad m => Monad (MSFExcept m a b) where\n  return = pure\n  MSFExcept msf >>= f = MSFExcept $ handleExceptT msf $ runMSFExcept . f\n\n-- | Execute an MSF and, if it throws an exception, recover by switching to a\n-- second MSF.\nhandleExceptT :: Monad m\n              => MSF (ExceptT e1 m) a b\n              -> (e1 -> MSF (ExceptT e2 m) a b)\n              -> MSF (ExceptT e2 m) a b\nhandleExceptT msf f = flip handleGen msf $ \\a mbcont -> do\n  ebcont <- lift $ runExceptT mbcont\n  case ebcont of\n    Left e          -> unMSF (f e) a\n    Right (b, msf\') -> return (b, handleExceptT msf\' f)\n\n-- | If no exception can occur, the \'MSF\' can be executed without the \'ExceptT\'\n-- layer.\nsafely :: Monad m => MSFExcept m a b Void -> MSF m a b\nsafely (MSFExcept msf) = morphS fromExcept msf\n  where\n    -- We can assume that the pattern @Left e@ will not occur, since @e@ would\n    -- have to be of type @Void@.\n    fromExcept ma = do\n      rightMa <- runExceptT ma\n      return $ fromRight (error "safely: Received `Left`") rightMa\n\n-- | An \'MSF\' without an \'ExceptT\' layer never throws an exception, and can\n-- thus have an arbitrary exception type.\nsafe :: Monad m => MSF m a b -> MSFExcept m a b e\nsafe = try . liftTransS\n\n-- | Inside the \'MSFExcept\' monad, execute an action of the wrapped monad.\n-- This passes the last input value to the action, but doesn\'t advance a tick.\nonce :: Monad m => (a -> m e) -> MSFExcept m a b e\nonce f = try $ arrM (lift . f) >>> throwS\n\n-- | Variant of \'once\' without input.\nonce_ :: Monad m => m e -> MSFExcept m a b e\nonce_ = once . const\n\n-- | Advances a single tick with the given Kleisli arrow, and then throws an\n-- exception.\nstep :: Monad m => (a -> m (b, e)) -> MSFExcept m a b e\nstep f = try $ proc a -> do\n  n      <- count           -< ()\n  (b, e) <- arrM (lift . f) -< a\n  _      <- throwOn\'        -< (n > (1 :: Int), e)\n  returnA                   -< b\n\n-- | Advances a single tick outputting the value, and then throws \'()\'.\nstep_ :: Monad m => b -> MSFExcept m a b ()\nstep_ b = step $ const $ return (b, ())\n\n-- | Converts a list to an \'MSFExcept\', which outputs an element of the list at\n-- each step, throwing \'()\' when the list ends.\nlistToMSFExcept :: Monad m => [b] -> MSFExcept m a b ()\nlistToMSFExcept = mapM_ step_\n\n-- * Utilities definable in terms of \'MSFExcept\'\n\n-- | Extract an \'MSF\' from a monadic action.\n--\n-- Runs a monadic action that produces an \'MSF\' on the first iteration/step,\n-- and uses that \'MSF\' as the main signal function for all inputs (including\n-- the first one).\nperformOnFirstSample :: Monad m => m (MSF m a b) -> MSF m a b\nperformOnFirstSample sfaction = safely $ do\n  msf <- once_ sfaction\n  safe msf\n\n-- | Reactimates an \'MSFExcept\' until it throws an exception.\nreactimateExcept :: Monad m => MSFExcept m () () e -> m e\nreactimateExcept msfe = do\n  leftMe <- runExceptT $ reactimate $ runMSFExcept msfe\n  return $ fromLeft (error "reactimateExcept: Received `Right`") leftMe\n\n-- | Reactimates an \'MSF\' until it returns \'True\'.\nreactimateB :: Monad m => MSF m () Bool -> m ()\nreactimateB sf = reactimateExcept $ try $ liftTransS sf >>> throwOn ()\n\n-- | Run first MSF until the second value in the output tuple is @Just c@ (for\n-- some @c@), then start the second MSF.\n--\n-- Analog to Yampa\'s\n-- [@switch@](https://hackage.haskell.org/package/Yampa/docs/FRP-Yampa-Switches.html#v:switch),\n-- with \'Maybe\' instead of @Event@.\nswitch :: Monad m => MSF m a (b, Maybe c) -> (c -> MSF m a b) -> MSF m a b\nswitch sf f = catchS ef f\n  where\n    -- Run sf, throwing an exception if there is a no-Nothing value in the\n    -- second element of the pair, and returning the first element otherwise.\n    ef = proc a -> do\n           (b, me)  <- liftTransS sf  -< a\n           throwMaybe                 -< me\n           returnA                    -< b\n\n-- | Run first MSF until the second value in the output tuple is @Just c@ (for\n-- some @c@), then start the second MSF.\n--\n-- Analog to Yampa\'s\n-- [@dswitch@](https://hackage.haskell.org/package/Yampa/docs/FRP-Yampa-Switches.html#v:dSwitch),\n-- with \'Maybe\' instead of @Event@.\ndSwitch :: Monad m => MSF m a (b, Maybe c) -> (c -> MSF m a b) -> MSF m a b\ndSwitch sf f = catchS ef f\n  where\n    ef = feedback Nothing $ proc (a, me) -> do\n           throwMaybe    -< me\n           liftTransS sf -< a\n\n-- | More general lifting combinator that enables recovery. Note that, unlike a\n-- polymorphic lifting function @forall a . m a -> m1 a@, this auxiliary\n-- function needs to be a bit more structured, and produces a Maybe value. The\n-- previous \'MSF\' is used if a new one is not produced.\ntransG :: (Monad m1, Monad m2)\n       => (a2 -> m1 a1)\n       -> (forall c. a2 -> m1 (b1, c) -> m2 (b2, Maybe c))\n       -> MSF m1 a1 b1\n       -> MSF m2 a2 b2\ntransG transformInput transformOutput msf = go\n  where\n    go = MSF $ \\a2 -> do\n           (b2, msf\') <- transformOutput a2 $ unMSF msf =<< transformInput a2\n           case msf\' of\n             Just msf\'\' ->\n               return (b2, transG transformInput transformOutput msf\'\')\n             Nothing ->\n               return (b2, go)\n\n-- | Use a generic handler to handle exceptions in MSF processing actions.\nhandleGen :: (a -> m1 (b1, MSF m1 a b1) -> m2 (b2, MSF m2 a b2))\n          -> MSF m1 a b1\n          -> MSF m2 a b2\nhandleGen handler msf = MSF $ \\a -> handler a (unMSF msf a)\n'