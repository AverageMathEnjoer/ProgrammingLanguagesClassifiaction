b'{-# LANGUAGE DataKinds, GADTs, TypeOperators, MultiParamTypeClasses, FlexibleInstances, TypeFamilies, PolyKinds, ScopedTypeVariables #-}\n\n-- | Converts function arguments to tuple-like types.\n--\n-- For example, take @f :: a -> b -> c -> r@.\n-- This module can convert it to @f\' :: (a, b, c) -> r@, at compile time.\n--\n-- This is especially useful for (de)serialization.\n-- Suppose you have a function that takes multiple arguments\n-- and you want to obtain all of its arguments from some serialized data.\n-- The serialization library will make it very easy to unpack types\n-- like tuples/lists, but de-serializing *fuction arguments* is not that simple.\n--\n-- Using this module, you can write an instance how to unpack the \'TypeList\' type,\n-- and then use \'translate\' to make any function take such a single \'TypeList\'\n-- instead of multiple function arguments.\nmodule FFI.Anything.TypeUncurry.DataKinds where\n\nimport           Data.Proxy\n\n\n-- * Type-level lists (containing types)\n\n-- NOTE: GHC 7.4 cannot deal with DataKinds\n-- (see http://hackage.haskell.org/trac/ghc/ticket/5881)\n--\n-- This is why we have two separate implementations:\n-- - one with DataKinds for GHC >= 7.6\n-- - one with a standard Nil / Cons type-level list for older\n--   compilers which is not kind-safe\n\n-- | Type-level list that can contain arbitrarily mixed types.\n--\n-- Example:\n--\n-- >1 ::: "hello" ::: 2.3 :: TypeList \'[Int, String, Double]\ndata TypeList l where\n  Nil :: TypeList \'[] -- TODO make singleton list, not empty list, base type?\n  (:::) :: a -> TypeList l -> TypeList (a \': l)\n\n-- Right-associativity, like (->)\ninfixr :::\n\n-- Example: You can write:\n--\n-- exampleTypeList :: TypeList \'[String, Int]\n-- exampleTypeList = "a" ::: 3 ::: Nil\n\n\n-- * \\"Uncurrying\\" functions\n\n{- In the following, we try to not use Template Haskell,\n   using an instance of (a -> ...) to convert functions to TypeLists automatically\n   (similar to how you make variadic functions).\n-}\n\n-- | Arguments to a function, e.g. @[String, Int]@ for @String -> Int -> r@.\ntype family Param f :: [*] where\n  Param (a -> f) = a \': Param f\n  Param r = \'[]\n\n-- | The result of a function, e.g. @r@ for @String -> Int -> r@.\ntype family Result f :: * where\n  Result (a -> f) = Result f\n  Result r = r\n\n\n-- | Function f can be translated to \'TypeList\' l with result type r.\nclass (Param f ~ l, Result f ~ r) => ToTypeList f l r where\n  -- | Translates a function taking multiple arguments to a function\n  -- taking a single \'TypeList\' containing the types of all arguments.\n  --\n  -- Example: @t1 -> ... -> tn -> r@ becomes @TypeList [t1, ..., tn] -> r@.\n  translate :: f -> TypeList l -> r\n\n\n-- | Base case: A "pure" function without arguments\n-- can be translated to @TypeList Nil -> r@.\ninstance (ToTypeList f l r) => ToTypeList (a -> f) (a \': l) r where\n  translate f (a ::: l) = translate (f a) l\n\n-- | Base case: A value @r@ can be translated to @TypeList Nil -> r@.\ninstance (Param f ~ \'[], Result f ~ r, f ~ r) => ToTypeList f \'[] r where\n  -- Could also be written as\n  --   (Param r ~ \'[], Result r ~ r) => ToTypeList r \'[] r\n  -- but I find the other way clearer.\n  translate r Nil = r\n\n\n-- Now an example:\n--\n-- someFunction :: Int -> Double -> String\n-- someFunction _i _d = return "asdf"\n--\n-- exampleAutoTranslate = translate someFunction\n--\n-- -- ghci would give as type for this: TypeList ((:) * Int ((:) * Double ([] *))) -> [Char]\n\n\n-- * Length of type-level lists\n\n-- | Allows to calculate the length of a \'TypeList\', at compile time.\n--\n-- We need to use a \'Proxy\' for this.\nclass ParamLength (l :: [*]) where\n  -- | Calculates the length of a type list, put into a proxy. Usage:\n  --\n  -- >paramLength (Proxy :: Proxy l)\n  paramLength :: Proxy l -> Int\n\ninstance ParamLength \'[] where\n  paramLength _ = 0\n\ninstance (ParamLength l) => ParamLength (a \': l) where\n  paramLength _ = succ $ paramLength (Proxy :: Proxy l)\n'