b'{-# OPTIONS_GHC -fno-warn-orphans #-}\n{-# LANGUAGE\n    FlexibleInstances\n  , OverloadedStrings\n  , ScopedTypeVariables\n  #-}\n\nimport Prelude hiding ((.))\n\nimport Control.Category ((.))\nimport Control.Monad (void)\nimport Data.String\nimport Test.Framework (defaultMain)\nimport Test.Framework.Providers.HUnit (testCase)\nimport Test.HUnit (Assertion, assertEqual)\nimport qualified Data.Label.Total             as L\nimport qualified Language.Haskell.Exts.Parser as H\nimport qualified Language.Haskell.Exts.Syntax as H\n\nimport Rest.Api\nimport Rest.Dictionary (xmlJsonO)\nimport Rest.Gen.Base.ActionInfo\nimport Rest.Gen.Base.ApiTree\nimport Rest.Handler\nimport Rest.Resource\nimport Rest.Schema\n\nmain :: IO ()\nmain =\n  defaultMain [ testCase "Listing has right parameters." testListingParams\n              , testCase "Selects should show up only once." testSingleSelect\n              , testCase "Removes should show up only once." testSingleRemove\n              , testCase "Listing should have List type." testListingType\n              ]\n\ntestListingParams :: Assertion\ntestListingParams = assertEqual "Parameters" ["offset", "count"] (params actionInfo)\n  where\n    [actionInfo] = resourceToActionInfo resource\n    resource :: Resource IO IO Void () Void\n    resource = mkResourceId { name = "resource", schema = Schema (Just (Many ())) (Named []), list = listHandler }\n    listHandler () = mkListing id $ \\_ -> return []\n\ntestSingleSelect :: Assertion\ntestSingleSelect = assertEqual "Number of select ActionInfos." 1 (length actionInfos)\n  where\n    actionInfos = filter isSelect $ resourceToActionInfo resource\n    resource :: Resource IO IO ServerId Void Void\n    resource = mkResourceId\n      { name   = "resource"\n      , schema = noListing $\n                   named\n                     [ ("id", singleBy ById)\n                     , ("ip", singleBy ByIp)\n                     ]\n      , get    = Just handler_\n      , selects = [ ("resources", handler_) ]\n      }\n    handler_ = mkConstHandler id $ return ()\n    isSelect ai = actionTarget ai == Any && actionType ai == Retrieve && postAction ai\n\ntestSingleRemove :: Assertion\ntestSingleRemove = assertEqual "Number of remove ActionInfos." 1 (length actionInfos)\n  where\n    actionInfos = filter isRemove $ resourceToActionInfo resource\n    resource :: Resource IO IO ServerId Void Void\n    resource = mkResourceId\n      { name   = "resource"\n      , schema = noListing $\n                   named\n                     [ ("id", singleBy ById)\n                     , ("ip", singleBy ByIp)\n                     ]\n      , remove = Just handler_\n      }\n    handler_ = mkConstHandler id $ return ()\n    isRemove ai = actionTarget ai == Self && actionType ai == Delete && postAction ai\n\ndata ServerId = ById String | ByIp String\n\ntestListingType :: Assertion\ntestListingType =\n  assertEqual "Listing should have List type"\n    "Rest.Types.Container.List (())"\n    -- (L.get haskellType . outputs . itemInfo . head . resItems $ api)\n    (L.get (haskellType . desc) . head . outputs . itemInfo . head . resItems $ api)\n  where\n    api = apiTree (route resource)\n    resource :: Resource IO IO Void () Void\n    resource = mkResourceId { name = "resource", schema = Schema (Just (Many ())) (Named []), list = listHandler }\n    listHandler () = mkListing xmlJsonO $ \\_ -> return [()]\n\ninstance IsString (H.Type ()) where\n  fromString = void . H.fromParseResult . H.parseType\n'