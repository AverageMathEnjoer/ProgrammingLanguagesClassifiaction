b'{-# LANGUAGE DataKinds #-}\n{-# LANGUAGE GADTs #-}\n\n-- |\n-- Module      : Hoodle.ModelAction.Page\n-- Copyright   : (c) 2011-2016 Ian-Woo Kim\n--\n-- License     : BSD3\n-- Maintainer  : Ian-Woo Kim <ianwookim@gmail.com>\n-- Stability   : experimental\n-- Portability : GHC\nmodule Hoodle.ModelAction.Page where\n\nimport Control.Lens (set, view)\nimport Data.Functor.Identity (Identity (..))\nimport Data.Hoodle.Generic\n  ( GHoodle,\n    gdimension,\n    gpages,\n  )\nimport Data.Hoodle.Select\n  ( gSelect2GHoodle,\n    gselAll,\n    gselSelected,\n  )\nimport qualified Data.IntMap as M\nimport Data.Maybe (fromMaybe)\nimport qualified Graphics.UI.Gtk as Gtk (adjustmentGetValue)\nimport Hoodle.Type.Alias (EditMode, Hoodle, Page)\nimport Hoodle.Type.Canvas\n  ( CanvasId,\n    CanvasInfo,\n    CanvasInfoBox (CanvasContPage, CanvasSinglePage),\n    adjustments,\n    currentPageNum,\n    drawArea,\n    forBoth,\n    pageArrangement,\n    unboxBiAct,\n    unboxBiXform,\n    viewInfo,\n    xfrmCvsInfo,\n    xfrmViewInfo,\n    zoomMode,\n  )\nimport Hoodle.Type.Enum (ZoomModeRel (ZoomIn, ZoomOut))\nimport Hoodle.Type.HoodleState\n  ( HoodleModeState (SelectState, ViewAppendState),\n    UnitHoodle,\n    cvsInfoMap,\n    getCanvasInfo,\n    getHoodle,\n    hoodleModeState,\n    hoodleModeStateEither,\n    setCanvasInfoMap,\n  )\nimport Hoodle.Type.PageArrangement\n  ( CanvasCoordinate (..),\n    DesktopCoordinate (..),\n    PageCoordinate (..),\n    PageDimension (..),\n    PageNum (..),\n    ViewMode (ContinuousPage, SinglePage),\n    makeContinuousArrangement,\n    makeSingleArrangement,\n  )\nimport Hoodle.Type.Predefined (predefinedZoomStepFactor)\nimport Hoodle.Util (maybeError\')\nimport Hoodle.View.Coordinate\n  ( CanvasGeometry\n      ( canvasDim,\n        desktop2Canvas,\n        desktop2Page\n      ),\n    getCvsGeomFrmCvsInfo,\n    makeCanvasGeometry,\n  )\n\n-- |\ngetPageMap :: HoodleModeState -> M.IntMap (Page EditMode)\ngetPageMap = either (view gpages) (view gselAll) . hoodleModeStateEither\n\n-- |\nsetPageMap :: M.IntMap (Page EditMode) -> HoodleModeState -> HoodleModeState\nsetPageMap nmap =\n  either\n    (ViewAppendState . set gpages nmap)\n    (SelectState . set gselSelected Nothing . set gselAll nmap)\n    . hoodleModeStateEither\n\n-- |\nupdatePageAll :: HoodleModeState -> UnitHoodle -> IO UnitHoodle\nupdatePageAll hdlmodst uhdl = do\n  let cmap = view cvsInfoMap uhdl\n  cmap\' <- mapM (updatePage hdlmodst . adjustPage hdlmodst) cmap\n  return $\n    fromMaybe uhdl\n      . setCanvasInfoMap cmap\'\n      . set hoodleModeState hdlmodst\n      $ uhdl\n\n-- |\nadjustPage :: HoodleModeState -> CanvasInfoBox -> CanvasInfoBox\nadjustPage hdlmodst = runIdentity . forBoth unboxBiXform (return . fsingle)\n  where\n    fsingle :: CanvasInfo a -> CanvasInfo a\n    fsingle cinfo =\n      let cpn = view currentPageNum cinfo\n          pagemap = getPageMap hdlmodst\n       in adjustwork cpn pagemap\n      where\n        adjustwork cpn pagemap =\n          if M.notMember cpn pagemap\n            then\n              let (minp, _) = M.findMin pagemap\n                  (maxp, _) = M.findMax pagemap\n               in if cpn > maxp\n                    then set currentPageNum maxp cinfo\n                    else set currentPageNum minp cinfo\n            else cinfo\n\n-- |\ngetPageFromGHoodleMap :: Int -> GHoodle M.IntMap a -> a\ngetPageFromGHoodleMap pagenum =\n  maybeError\' ("getPageFromGHoodleMap " ++ show pagenum) . M.lookup pagenum . view gpages\n\n-- |\nupdateCvsInfoFrmHoodle :: Hoodle EditMode -> CanvasInfoBox -> IO CanvasInfoBox\nupdateCvsInfoFrmHoodle hdl (CanvasSinglePage cinfo) = do\n  let pagenum = view currentPageNum cinfo\n      oarr = view (viewInfo . pageArrangement) cinfo\n      canvas = view drawArea cinfo\n      zmode = view (viewInfo . zoomMode) cinfo\n  geometry <- makeCanvasGeometry (PageNum pagenum) oarr canvas\n  let cdim = canvasDim geometry\n      pg = getPageFromGHoodleMap pagenum hdl\n      pdim = PageDimension $ view gdimension pg\n      (hadj, vadj) = view adjustments cinfo\n  (xpos, ypos) <- (,) <$> Gtk.adjustmentGetValue hadj <*> Gtk.adjustmentGetValue vadj\n  let arr = makeSingleArrangement zmode pdim cdim (xpos, ypos)\n      vinfo = view viewInfo cinfo\n      nvinfo = xfrmViewInfo (const arr) vinfo\n  return\n    . CanvasSinglePage\n    . set currentPageNum pagenum\n    . xfrmCvsInfo (const nvinfo)\n    $ cinfo\nupdateCvsInfoFrmHoodle hdl (CanvasContPage cinfo) = do\n  let pagenum = view currentPageNum cinfo\n      oarr = view (viewInfo . pageArrangement) cinfo\n      canvas = view drawArea cinfo\n      zmode = view (viewInfo . zoomMode) cinfo\n      (hadj, vadj) = view adjustments cinfo\n  (xdesk, ydesk) <-\n    (,) <$> Gtk.adjustmentGetValue hadj\n      <*> Gtk.adjustmentGetValue vadj\n  geometry <- makeCanvasGeometry (PageNum pagenum) oarr canvas\n  case desktop2Page geometry (DeskCoord (xdesk, ydesk)) of\n    Nothing -> return (CanvasContPage cinfo)\n    Just ulcoord -> do\n      let cdim = canvasDim geometry\n          arr = makeContinuousArrangement zmode cdim hdl ulcoord\n      let vinfo = view viewInfo cinfo\n          nvinfo = xfrmViewInfo (const arr) vinfo\n      return\n        . CanvasContPage\n        . set currentPageNum pagenum\n        . xfrmCvsInfo (const nvinfo)\n        $ cinfo\n\n-- |\nupdatePage :: HoodleModeState -> CanvasInfoBox -> IO CanvasInfoBox\nupdatePage (ViewAppendState hdl) c = updateCvsInfoFrmHoodle hdl c\nupdatePage (SelectState thdl) c = do\n  let hdl = gSelect2GHoodle thdl\n  updateCvsInfoFrmHoodle hdl c\n\n-- |\nsetPage :: UnitHoodle -> PageNum -> CanvasId -> IO CanvasInfoBox\nsetPage uhdl pnum cid = do\n  let cinfobox = getCanvasInfo cid uhdl\n  unboxBiAct\n    (fmap CanvasSinglePage . setPageSingle uhdl pnum)\n    (fmap CanvasContPage . setPageCont uhdl pnum)\n    cinfobox\n\n-- | setPageSingle : in Single Page mode\nsetPageSingle ::\n  UnitHoodle ->\n  PageNum ->\n  CanvasInfo \'SinglePage ->\n  IO (CanvasInfo \'SinglePage)\nsetPageSingle uhdl pnum cinfo = do\n  let hdl = getHoodle uhdl\n  geometry <- getCvsGeomFrmCvsInfo cinfo\n  let cdim = canvasDim geometry\n  let pg = getPageFromGHoodleMap (unPageNum pnum) hdl\n      pdim = PageDimension (view gdimension pg)\n      zmode = view (viewInfo . zoomMode) cinfo\n      arr = makeSingleArrangement zmode pdim cdim (0, 0)\n  return $\n    set currentPageNum (unPageNum pnum)\n      . set (viewInfo . pageArrangement) arr\n      $ cinfo\n\n-- | setPageCont : in Continuous Page mode\nsetPageCont ::\n  UnitHoodle ->\n  PageNum ->\n  CanvasInfo \'ContinuousPage ->\n  IO (CanvasInfo \'ContinuousPage)\nsetPageCont uhdl pnum cinfo = do\n  let hdl = getHoodle uhdl\n  geometry <- getCvsGeomFrmCvsInfo cinfo\n  let cdim = canvasDim geometry\n      zmode = view (viewInfo . zoomMode) cinfo\n      arr = makeContinuousArrangement zmode cdim hdl (pnum, PageCoord (0, 0))\n  return $\n    set currentPageNum (unPageNum pnum)\n      . set (viewInfo . pageArrangement) arr\n      $ cinfo\n\n-- | need to be refactored into zoomRatioFrmRelToCurr (rename zoomRatioRelPredefined)\nrelZoomRatio :: CanvasGeometry -> ZoomModeRel -> Double\nrelZoomRatio geometry rzmode =\n  let CvsCoord (cx0, _cy0) = desktop2Canvas geometry (DeskCoord (0, 0))\n      CvsCoord (cx1, _cy1) = desktop2Canvas geometry (DeskCoord (1, 1))\n      scalefactor = case rzmode of\n        ZoomIn -> predefinedZoomStepFactor\n        ZoomOut -> 1.0 / predefinedZoomStepFactor\n   in (cx1 - cx0) * scalefactor\n\n-- |\nzoomRatioFrmRelToCurr :: CanvasGeometry -> Double -> Double\nzoomRatioFrmRelToCurr geometry z =\n  let CvsCoord (cx0, _cy0) = desktop2Canvas geometry (DeskCoord (0, 0))\n      CvsCoord (cx1, _cy1) = desktop2Canvas geometry (DeskCoord (1, 1))\n   in (cx1 - cx0) * z\n'