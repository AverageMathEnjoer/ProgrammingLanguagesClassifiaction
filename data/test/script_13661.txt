b'#\' Find C source code for internal R functions\n#\'\n#\' Opens a link to code search on github.\n#\'\n#\' @param fun .Internal or .Primitive function call.\n#\' @export\n#\' @examples\n#\' \\donttest{\n#\' show_c_source(.Internal(mean(x)))\n#\' show_c_source(.Primitive(sum(x)))\n#\' }\nshow_c_source  <- function(fun) {\n  fun <- substitute(fun)\n  stopifnot(is.call(fun))\n\n  name <- as.character(fun[[1]])\n  if (!(name %in% c(".Internal", ".Primitive"))) {\n    stop("Only know how to look up .Internal and .Primitive calls",\n      call. = FALSE)\n  }\n\n  internal_name <- as.character(fun[[2]][[1]])\n\n  names <- names_c()\n  found <- names[names$name == internal_name, , drop = FALSE]\n\n  if (nrow(found) != 1) {\n    stop("Could not find entry for ", internal_name, call. = FALSE)\n  }\n\n  message(internal_name, " is implemented by ", found$cfun,\n    " with op = ", found$offset)\n\n  query <- sprintf("SEXP attribute_hidden %s+repo:wch/r-source&type=Code",\n    found$cfun)\n  url <- paste0("https://github.com/search?q=", utils::URLencode(query))\n\n  if (interactive()) {\n    utils::browseURL(url)\n  } else {\n    message("Please visit ", url)\n  }\n}\n\n#\' Extract function table from names.c from R subversion repository.\n#\'\n#\' Since this is an expensive operation, it is done once and cached within\n#\' a session.\n#\'\n#\' @return A data frame with columns\n#\' \\item{name}{the function name in R}\n#\' \\item{c-entry}{The name of the corresponding C function, actually declared\n#\'   in ../include/Internal.h. All start with "do_", return SEXP, and\n#\'   have argument list (SEXP call, SEXP op, SEXP args, SEXP env)}\n#\' \\item{offset}{the \'op\' (offset pointer) above; used for C functions\n#\' \t which deal with more than one R function}\n#\' \\item{eval}{XYZ (three digits) \\cr\n#\'  \\cr\n#\'  X=0 says that we should force R_Visible on \\cr\n#\'  X=1 says that we should force R_Visible off \\cr\n#\'  X=2 says that we should switch R_Visible on but let the C code update it. \\cr\n#\'  \\cr\n#\'  Y=1 says that this is an internal function which must\n#\'      be accessed with a\t.Internal(.) call, any other value is\n#\'      accessible directly and printed in R as ".Primitive(..)".\\cr\n#\'  \\cr\n#\'  Z=0 says don\'t evaluate (SPECIALSXP).\\cr\n#\'  Z=1 says evaluate arguments before calling (BUILTINSXP)}\n#\' \\item{arity}{How many arguments are required/allowed;  "-1"\tmeaning ``any\'\'}\n#\' \\item{pp-kind}{Deparsing Info (-> PPkind in ../include/Defn.h )}\n#\' \\item{precedence}{Operator precedence (-> PPprec in ../include/Defn.h )}\n#\' \\item{rightassoc}{Right or left associative operator}\n#\' @keywords internal\n#\' @export\nnames_c <- function() {\n  if (exists("names_c", envir = cache)) return(cache$names_c)\n  lines <- readLines("http://svn.r-project.org/R/trunk/src/main/names.c")\n\n  # Find lines starting with {"\n  fun_table <- lines[grepl("^[{][\\"]", lines)]\n  # Strip out {}, trailing comma and comments\n  fun_table <- gsub("[{}]", "", fun_table)\n  fun_table <- gsub(",$", "", fun_table)\n  fun_table <- gsub("/[*].*[*]/", "", fun_table)\n\n  table <- utils::read.csv(text = fun_table, strip = TRUE, header = FALSE,\n    stringsAsFactors = FALSE)\n  names(table) <- c("name", "cfun", "offset", "eval", "arity", "pp_kind",\n    "precedence", "rightassoc")\n\n  table$eval <- sprintf("%03d", table$eval)\n  table$rightassoc <- table$rightassoc == 1\n\n  # Cache result\n  cache$names_c <- table\n  table\n}\n\ncache <- new.env(parent = emptyenv())\n'