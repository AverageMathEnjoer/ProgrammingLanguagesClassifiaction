b'using System;\nusing System.Diagnostics;\nusing System.Text;\n\nnamespace CS_SQLite3\n{\n  public partial class CSSQLite\n  {\n    /*\n    ** 2006 June 10\n    **\n    ** The author disclaims copyright to this source code.  In place of\n    ** a legal notice, here is a blessing:\n    **\n    **    May you do good and not evil.\n    **    May you find forgiveness for yourself and forgive others.\n    **    May you share freely, never taking more than you give.\n    **\n    *************************************************************************\n    ** This file contains code used to help implement virtual tables.\n    **\n    ** $Id: vtab.c,v 1.94 2009/08/08 18:01:08 drh Exp $\n    **\n    *************************************************************************\n    **  Included in SQLite3 port to C#-SQLite;  2008 Noah B Hart\n    **  C#-SQLite is an independent reimplementation of the SQLite software library\n    **\n    **  $Header$\n    *************************************************************************\n    */\n#if !SQLITE_OMIT_VIRTUALTABLE\n//#include "sqliteInt.h"\n\n/*\n** The actual function that does the work of creating a new module.\n** This function implements the sqlite3_create_module() and\n** sqlite3_create_module_v2() interfaces.\n*/\nstatic int createModule(\n  sqlite3 *db,                    /* Database in which module is registered */\n  const char *zName,              /* Name assigned to this module */\n  const sqlite3_module *pModule,  /* The definition of the module */\n  void *pAux,                     /* Context pointer for xCreate/xConnect */\n  void (*xDestroy)(void *)        /* Module destructor function */\n){\n  int rc, nName;\n  Module *pMod;\n\n  sqlite3_mutex_enter(db->mutex);\n  nName = sqlite3Strlen30(zName);\n  pMod = (Module *)sqlite3DbMallocRaw(db, sizeof(Module) + nName + 1);\n  if( pMod ){\n    Module *pDel;\n    char *zCopy = (char *)(&pMod[1]);\n    memcpy(zCopy, zName, nName+1);\n    pMod->zName = zCopy;\n    pMod->pModule = pModule;\n    pMod->pAux = pAux;\n    pMod->xDestroy = xDestroy;\n    pDel = (Module *)sqlite3HashInsert(&db->aModule, zCopy, nName, (void*)pMod);\n    if( pDel && pDel->xDestroy ){\n      pDel->xDestroy(pDel->pAux);\n    }\n    sqlite3DbFree(db, pDel);\n    if( pDel==pMod ){\n      db->mallocFailed = 1;\n    }\n    sqlite3ResetInternalSchema(db, 0);\n  }else if( xDestroy ){\n    xDestroy(pAux);\n  }\n  rc = sqlite3ApiExit(db, SQLITE_OK);\n  sqlite3_mutex_leave(db->mutex);\n  return rc;\n}\n\n\n/*\n** External API function used to create a new virtual-table module.\n*/\nint sqlite3_create_module(\n  sqlite3 *db,                    /* Database in which module is registered */\n  const char *zName,              /* Name assigned to this module */\n  const sqlite3_module *pModule,  /* The definition of the module */\n  void *pAux                      /* Context pointer for xCreate/xConnect */\n){\n  return createModule(db, zName, pModule, pAux, 0);\n}\n\n/*\n** External API function used to create a new virtual-table module.\n*/\nint sqlite3_create_module_v2(\n  sqlite3 *db,                    /* Database in which module is registered */\n  const char *zName,              /* Name assigned to this module */\n  const sqlite3_module *pModule,  /* The definition of the module */\n  void *pAux,                     /* Context pointer for xCreate/xConnect */\n  void (*xDestroy)(void *)        /* Module destructor function */\n){\n  return createModule(db, zName, pModule, pAux, xDestroy);\n}\n\n/*\n** Lock the virtual table so that it cannot be disconnected.\n** Locks nest.  Every lock should have a corresponding unlock.\n** If an unlock is omitted, resources leaks will occur.  \n**\n** If a disconnect is attempted while a virtual table is locked,\n** the disconnect is deferred until all locks have been removed.\n*/\nvoid sqlite3VtabLock(VTable *pVTab){\n  pVTab->nRef++;\n}\n\n\n/*\n** pTab is a pointer to a Table structure representing a virtual-table.\n** Return a pointer to the VTable object used by connection db to access \n** this virtual-table, if one has been created, or NULL otherwise.\n*/\nVTable *sqlite3GetVTable(sqlite3 *db, Table *pTab){\n  VTable *pVtab;\n  assert( IsVirtual(pTab) );\n  for(pVtab=pTab->pVTable; pVtab && pVtab->db!=db; pVtab=pVtab->pNext);\n  return pVtab;\n}\n\n/*\n** Decrement the ref-count on a virtual table object. When the ref-count\n** reaches zero, call the xDisconnect() method to delete the object.\n*/\nvoid sqlite3VtabUnlock(VTable *pVTab){\n  sqlite3 *db = pVTab->db;\n\n  assert( db );\n  assert( pVTab->nRef>0 );\n  assert( sqlite3SafetyCheckOk(db) );\n\n  pVTab->nRef--;\n  if( pVTab->nRef==0 ){\n    sqlite3_vtab *p = pVTab->pVtab;\n    if( p ){\n#if SQLITE_DEBUG\n      if( pVTab->db->magic==SQLITE_MAGIC_BUSY ){\n        (void)sqlite3SafetyOff(db);\n        p->pModule->xDisconnect(p);\n        (void)sqlite3SafetyOn(db);\n      } else\n#endif\n      {\n        p->pModule->xDisconnect(p);\n      }\n    }\n    sqlite3DbFree(db, pVTab);\n  }\n}\n\n/*\n** Table p is a virtual table. This function moves all elements in the\n** p->pVTable list to the sqlite3.pDisconnect lists of their associated\n** database connections to be disconnected at the next opportunity. \n** Except, if argument db is not NULL, then the entry associated with\n** connection db is left in the p->pVTable list.\n*/\nstatic VTable *vtabDisconnectAll(sqlite3 *db, Table *p){\n  VTable *pRet = 0;\n  VTable *pVTable = p->pVTable;\n  p->pVTable = 0;\n\n  /* Assert that the mutex (if any) associated with the BtShared database \n  ** that contains table p is held by the caller. See header comments \n  ** above function sqlite3VtabUnlockList() for an explanation of why\n  ** this makes it safe to access the sqlite3.pDisconnect list of any\n  ** database connection that may have an entry in the p->pVTable list.  */\n  assert( db==0 ||\n    sqlite3BtreeHoldsMutex(db->aDb[sqlite3SchemaToIndex(db, p->pSchema)].pBt) \n  );\n\n  while( pVTable ){\n    sqlite3 *db2 = pVTable->db;\n    VTable *pNext = pVTable->pNext;\n    assert( db2 );\n    if( db2==db ){\n      pRet = pVTable;\n      p->pVTable = pRet;\n      pRet->pNext = 0;\n    }else{\n      pVTable->pNext = db2->pDisconnect;\n      db2->pDisconnect = pVTable;\n    }\n    pVTable = pNext;\n  }\n\n  assert( !db || pRet );\n  return pRet;\n}\n\n\n/*\n** Disconnect all the virtual table objects in the sqlite3.pDisconnect list.\n**\n** This function may only be called when the mutexes associated with all\n** shared b-tree databases opened using connection db are held by the \n** caller. This is done to protect the sqlite3.pDisconnect list. The\n** sqlite3.pDisconnect list is accessed only as follows:\n**\n**   1) By this function. In this case, all BtShared mutexes and the mutex\n**      associated with the database handle itself must be held.\n**\n**   2) By function vtabDisconnectAll(), when it adds a VTable entry to\n**      the sqlite3.pDisconnect list. In this case either the BtShared mutex\n**      associated with the database the virtual table is stored in is held\n**      or, if the virtual table is stored in a non-sharable database, then\n**      the database handle mutex is held.\n**\n** As a result, a sqlite3.pDisconnect cannot be accessed simultaneously \n** by multiple threads. It is thread-safe.\n*/\nvoid sqlite3VtabUnlockList(sqlite3 *db){\n  VTable *p = db->pDisconnect;\n  db->pDisconnect = 0;\n\n  assert( sqlite3BtreeHoldsAllMutexes(db) );\n  assert( sqlite3_mutex_held(db->mutex) );\n\n  if( p ){\n    sqlite3ExpirePreparedStatements(db);\n    do {\n      VTable *pNext = p->pNext;\n      sqlite3VtabUnlock(p);\n      p = pNext;\n    }while( p );\n  }\n}\n\n/*\n** Clear any and all virtual-table information from the Table record.\n** This routine is called, for example, just before deleting the Table\n** record.\n**\n** Since it is a virtual-table, the Table structure contains a pointer\n** to the head of a linked list of VTable structures. Each VTable \n** structure is associated with a single sqlite3* user of the schema.\n** The reference count of the VTable structure associated with database \n** connection db is decremented immediately (which may lead to the \n** structure being xDisconnected and free). Any other VTable structures\n** in the list are moved to the sqlite3.pDisconnect list of the associated \n** database connection.\n*/\nvoid sqlite3VtabClear(Table *p){\n  vtabDisconnectAll(0, p);\n  if( p->azModuleArg ){\n    int i;\n    for(i=0; i<p->nModuleArg; i++){\n      sqlite3DbFree(p->dbMem, p->azModuleArg[i]);\n    }\n    sqlite3DbFree(p->dbMem, p->azModuleArg);\n  }\n}\n\n/*\n** Add a new module argument to pTable->azModuleArg[].\n** The string is not copied - the pointer is stored.  The\n** string will be freed automatically when the table is\n** deleted.\n*/\nstatic void addModuleArgument(sqlite3 *db, Table *pTable, char *zArg){\n  int i = pTable->nModuleArg++;\n  int nBytes = sizeof(char *)*(1+pTable->nModuleArg);\n  char **azModuleArg;\n  azModuleArg = sqlite3DbRealloc(db, pTable->azModuleArg, nBytes);\n  if( azModuleArg==0 ){\n    int j;\n    for(j=0; j<i; j++){\n      sqlite3DbFree(db, pTable->azModuleArg[j]);\n    }\n    sqlite3DbFree(db, zArg);\n    sqlite3DbFree(db, pTable->azModuleArg);\n    pTable->nModuleArg = 0;\n  }else{\n    azModuleArg[i] = zArg;\n    azModuleArg[i+1] = 0;\n  }\n  pTable->azModuleArg = azModuleArg;\n}\n\n/*\n** The parser calls this routine when it first sees a CREATE VIRTUAL TABLE\n** statement.  The module name has been parsed, but the optional list\n** of parameters that follow the module name are still pending.\n*/\nvoid sqlite3VtabBeginParse(\n  Parse *pParse,        /* Parsing context */\n  Token *pName1,        /* Name of new table, or database name */\n  Token *pName2,        /* Name of new table or NULL */\n  Token *pModuleName    /* Name of the module for the virtual table */\n){\n  int iDb;              /* The database the table is being created in */\n  Table *pTable;        /* The new virtual table */\n  sqlite3 *db;          /* Database connection */\n\n  sqlite3StartTable(pParse, pName1, pName2, 0, 0, 1, 0);\n  pTable = pParse->pNewTable;\n  if( pTable==0 ) return;\n  assert( 0==pTable->pIndex );\n\n  db = pParse->db;\n  iDb = sqlite3SchemaToIndex(db, pTable->pSchema);\n  assert( iDb>=0 );\n\n  pTable->tabFlags |= TF_Virtual;\n  pTable->nModuleArg = 0;\n  addModuleArgument(db, pTable, sqlite3NameFromToken(db, pModuleName));\n  addModuleArgument(db, pTable, sqlite3DbStrDup(db, db->aDb[iDb].zName));\n  addModuleArgument(db, pTable, sqlite3DbStrDup(db, pTable->zName));\n  pParse->sNameToken.n = (int)(&pModuleName->z[pModuleName->n] - pName1->z);\n\n#if !SQLITE_OMIT_AUTHORIZATION\n  /* Creating a virtual table invokes the authorization callback twice.\n  ** The first invocation, to obtain permission to INSERT a row into the\n  ** sqlite_master table, has already been made by sqlite3StartTable().\n  ** The second call, to obtain permission to create the table, is made now.\n  */\n  if( pTable->azModuleArg ){\n    sqlite3AuthCheck(pParse, SQLITE_CREATE_VTABLE, pTable->zName, \n            pTable->azModuleArg[0], pParse->db->aDb[iDb].zName);\n  }\n#endif\n}\n\n/*\n** This routine takes the module argument that has been accumulating\n** in pParse->zArg[] and appends it to the list of arguments on the\n** virtual table currently under construction in pParse->pTable.\n*/\nstatic void addArgumentToVtab(Parse *pParse){\n  if( pParse->sArg.z && ALWAYS(pParse->pNewTable) ){\n    const char *z = (const char*)pParse->sArg.z;\n    int n = pParse->sArg.n;\n    sqlite3 *db = pParse->db;\n    addModuleArgument(db, pParse->pNewTable, sqlite3DbStrNDup(db, z, n));\n  }\n}\n\n/*\n** The parser calls this routine after the CREATE VIRTUAL TABLE statement\n** has been completely parsed.\n*/\nvoid sqlite3VtabFinishParse(Parse *pParse, Token *pEnd){\n  Table *pTab = pParse->pNewTable;  /* The table being constructed */\n  sqlite3 *db = pParse->db;         /* The database connection */\n\n  if( pTab==0 ) return;\n  addArgumentToVtab(pParse);\n  pParse->sArg.z = 0;\n  if( pTab->nModuleArg<1 ) return;\n  \n  /* If the CREATE VIRTUAL TABLE statement is being entered for the\n  ** first time (in other words if the virtual table is actually being\n  ** created now instead of just being read out of sqlite_master) then\n  ** do additional initialization work and store the statement text\n  ** in the sqlite_master table.\n  */\n  if( !db->init.busy ){\n    char *zStmt;\n    char *zWhere;\n    int iDb;\n    Vdbe *v;\n\n    /* Compute the complete text of the CREATE VIRTUAL TABLE statement */\n    if( pEnd ){\n      pParse->sNameToken.n = (int)(pEnd->z - pParse->sNameToken.z) + pEnd->n;\n    }\n    zStmt = sqlite3MPrintf(db, "CREATE VIRTUAL TABLE %T", &pParse->sNameToken);\n\n    /* A slot for the record has already been allocated in the \n    ** SQLITE_MASTER table.  We just need to update that slot with all\n    ** the information we\'ve collected.  \n    **\n    ** The VM register number pParse->regRowid holds the rowid of an\n    ** entry in the sqlite_master table tht was created for this vtab\n    ** by sqlite3StartTable().\n    */\n    iDb = sqlite3SchemaToIndex(db, pTab->pSchema);\n    sqlite3NestedParse(pParse,\n      "UPDATE %Q.%s "\n         "SET type=\'table\', name=%Q, tbl_name=%Q, rootpage=0, sql=%Q "\n       "WHERE rowid=#%d",\n      db->aDb[iDb].zName, SCHEMA_TABLE(iDb),\n      pTab->zName,\n      pTab->zName,\n      zStmt,\n      pParse->regRowid\n    );\n    sqlite3DbFree(db, zStmt);\n    v = sqlite3GetVdbe(pParse);\n    sqlite3ChangeCookie(pParse, iDb);\n\n    sqlite3VdbeAddOp2(v, OP_Expire, 0, 0);\n    zWhere = sqlite3MPrintf(db, "name=\'%q\'", pTab->zName);\n    sqlite3VdbeAddOp4(v, OP_ParseSchema, iDb, 1, 0, zWhere, P4_DYNAMIC);\n    sqlite3VdbeAddOp4(v, OP_VCreate, iDb, 0, 0, \n                         pTab->zName, sqlite3Strlen30(pTab->zName) + 1);\n  }\n\n  /* If we are rereading the sqlite_master table create the in-memory\n  ** record of the table. The xConnect() method is not called until\n  ** the first time the virtual table is used in an SQL statement. This\n  ** allows a schema that contains virtual tables to be loaded before\n  ** the required virtual table implementations are registered.  */\n  else {\n    Table *pOld;\n    Schema *pSchema = pTab->pSchema;\n    const char *zName = pTab->zName;\n    int nName = sqlite3Strlen30(zName);\n    pOld = sqlite3HashInsert(&pSchema->tblHash, zName, nName, pTab);\n    if( pOld ){\n      db->mallocFailed = 1;\n      assert( pTab==pOld );  /* Malloc must have failed inside HashInsert() */\n      return;\n    }\n    pSchema->db = pParse->db;\n    pParse->pNewTable = 0;\n  }\n}\n\n/*\n** The parser calls this routine when it sees the first token\n** of an argument to the module name in a CREATE VIRTUAL TABLE statement.\n*/\nvoid sqlite3VtabArgInit(Parse *pParse){\n  addArgumentToVtab(pParse);\n  pParse->sArg.z = 0;\n  pParse->sArg.n = 0;\n}\n\n/*\n** The parser calls this routine for each token after the first token\n** in an argument to the module name in a CREATE VIRTUAL TABLE statement.\n*/\nvoid sqlite3VtabArgExtend(Parse *pParse, Token *p){\n  Token *pArg = &pParse->sArg;\n  if( pArg->z==0 ){\n    pArg->z = p->z;\n    pArg->n = p->n;\n  }else{\n    assert(pArg->z < p->z);\n    pArg->n = (int)(&p->z[p->n] - pArg->z);\n  }\n}\n\n/*\n** Invoke a virtual table constructor (either xCreate or xConnect). The\n** pointer to the function to invoke is passed as the fourth parameter\n** to this procedure.\n*/\nstatic int vtabCallConstructor(\n  sqlite3 *db, \n  Table *pTab,\n  Module *pMod,\n  int (*xConstruct)(sqlite3*,void*,int,const char*const*,sqlite3_vtab**,char**),\n  char **pzErr\n){\n  VTable *pVTable;\n  int rc;\n  const char *const*azArg = (const char *const*)pTab->azModuleArg;\n  int nArg = pTab->nModuleArg;\n  char *zErr = 0;\n  char *zModuleName = sqlite3MPrintf(db, "%s", pTab->zName);\n\n  if( !zModuleName ){\n    return SQLITE_NOMEM;\n  }\n\n  pVTable = sqlite3DbMallocZero(db, sizeof(VTable));\n  if( !pVTable ){\n    sqlite3DbFree(db, zModuleName);\n    return SQLITE_NOMEM;\n  }\n  pVTable->db = db;\n  pVTable->pMod = pMod;\n\n  assert( !db->pVTab );\n  assert( xConstruct );\n  db->pVTab = pTab;\n\n  /* Invoke the virtual table constructor */\n  (void)sqlite3SafetyOff(db);\n  rc = xConstruct(db, pMod->pAux, nArg, azArg, &pVTable->pVtab, &zErr);\n  (void)sqlite3SafetyOn(db);\n  if( rc==SQLITE_NOMEM ) db->mallocFailed = 1;\n\n  if( SQLITE_OK!=rc ){\n    if( zErr==0 ){\n      *pzErr = sqlite3MPrintf(db, "vtable constructor failed: %s", zModuleName);\n    }else {\n      *pzErr = sqlite3MPrintf(db, "%s", zErr);\n      sqlite3DbFree(db, zErr);\n    }\n    sqlite3DbFree(db, pVTable);\n  }else if( ALWAYS(pVTable->pVtab) ){\n    /* Justification of ALWAYS():  A correct vtab constructor must allocate\n    ** the sqlite3_vtab object if successful.  */\n    pVTable->pVtab->pModule = pMod->pModule;\n    pVTable->nRef = 1;\n    if( db->pVTab ){\n      const char *zFormat = "vtable constructor did not declare schema: %s";\n      *pzErr = sqlite3MPrintf(db, zFormat, pTab->zName);\n      sqlite3VtabUnlock(pVTable);\n      rc = SQLITE_ERROR;\n    }else{\n      int iCol;\n      /* If everything went according to plan, link the new VTable structure\n      ** into the linked list headed by pTab->pVTable. Then loop through the \n      ** columns of the table to see if any of them contain the token "hidden".\n      ** If so, set the Column.isHidden flag and remove the token from\n      ** the type string.  */\n      pVTable->pNext = pTab->pVTable;\n      pTab->pVTable = pVTable;\n\n      for(iCol=0; iCol<pTab->nCol; iCol++){\n        char *zType = pTab->aCol[iCol].zType;\n        int nType;\n        int i = 0;\n        if( !zType ) continue;\n        nType = sqlite3Strlen30(zType);\n        if( sqlite3StrNICmp("hidden", zType, 6)||(zType[6] && zType[6]!=\' \') ){\n          for(i=0; i<nType; i++){\n            if( (0==sqlite3StrNICmp(" hidden", &zType[i], 7))\n             && (zType[i+7]==\'\\0\' || zType[i+7]==\' \')\n            ){\n              i++;\n              break;\n            }\n          }\n        }\n        if( i<nType ){\n          int j;\n          int nDel = 6 + (zType[i+6] ? 1 : 0);\n          for(j=i; (j+nDel)<=nType; j++){\n            zType[j] = zType[j+nDel];\n          }\n          if( zType[i]==\'\\0\' && i>0 ){\n            assert(zType[i-1]==\' \');\n            zType[i-1] = \'\\0\';\n          }\n          pTab->aCol[iCol].isHidden = 1;\n        }\n      }\n    }\n  }\n\n  sqlite3DbFree(db, zModuleName);\n  db->pVTab = 0;\n  return rc;\n}\n\n/*\n** This function is invoked by the parser to call the xConnect() method\n** of the virtual table pTab. If an error occurs, an error code is returned \n** and an error left in pParse.\n**\n** This call is a no-op if table pTab is not a virtual table.\n*/\nint sqlite3VtabCallConnect(Parse *pParse, Table *pTab){\n  sqlite3 *db = pParse->db;\n  const char *zMod;\n  Module *pMod;\n  int rc;\n\n  assert( pTab );\n  if( (pTab->tabFlags & TF_Virtual)==0 || sqlite3GetVTable(db, pTab) ){\n    return SQLITE_OK;\n  }\n\n  /* Locate the required virtual table module */\n  zMod = pTab->azModuleArg[0];\n  pMod = (Module*)sqlite3HashFind(&db->aModule, zMod, sqlite3Strlen30(zMod));\n\n  if( !pMod ){\n    const char *zModule = pTab->azModuleArg[0];\n    sqlite3ErrorMsg(pParse, "no such module: %s", zModule);\n    rc = SQLITE_ERROR;\n  }else{\n    char *zErr = 0;\n    rc = vtabCallConstructor(db, pTab, pMod, pMod->pModule->xConnect, &zErr);\n    if( rc!=SQLITE_OK ){\n      sqlite3ErrorMsg(pParse, "%s", zErr);\n    }\n    sqlite3DbFree(db, zErr);\n  }\n\n  return rc;\n}\n\n/*\n** Add the virtual table pVTab to the array sqlite3.aVTrans[].\n*/\nstatic int addToVTrans(sqlite3 *db, VTable *pVTab){\n  const int ARRAY_INCR = 5;\n\n  /* Grow the sqlite3.aVTrans array if required */\n  if( (db->nVTrans%ARRAY_INCR)==0 ){\n    VTable **aVTrans;\n    int nBytes = sizeof(sqlite3_vtab *) * (db->nVTrans + ARRAY_INCR);\n    aVTrans = sqlite3DbRealloc(db, (void *)db->aVTrans, nBytes);\n    if( !aVTrans ){\n      return SQLITE_NOMEM;\n    }\n    memset(&aVTrans[db->nVTrans], 0, sizeof(sqlite3_vtab *)*ARRAY_INCR);\n    db->aVTrans = aVTrans;\n  }\n\n  /* Add pVtab to the end of sqlite3.aVTrans */\n  db->aVTrans[db->nVTrans++] = pVTab;\n  sqlite3VtabLock(pVTab);\n  return SQLITE_OK;\n}\n\n/*\n** This function is invoked by the vdbe to call the xCreate method\n** of the virtual table named zTab in database iDb. \n**\n** If an error occurs, *pzErr is set to point an an English language\n** description of the error and an SQLITE_XXX error code is returned.\n** In this case the caller must call sqlite3DbFree(db, ) on *pzErr.\n*/\nint sqlite3VtabCallCreate(sqlite3 *db, int iDb, const char *zTab, char **pzErr){\n  int rc = SQLITE_OK;\n  Table *pTab;\n  Module *pMod;\n  const char *zMod;\n\n  pTab = sqlite3FindTable(db, zTab, db->aDb[iDb].zName);\n  assert( pTab && (pTab->tabFlags & TF_Virtual)!=0 && !pTab->pVTable );\n\n  /* Locate the required virtual table module */\n  zMod = pTab->azModuleArg[0];\n  pMod = (Module*)sqlite3HashFind(&db->aModule, zMod, sqlite3Strlen30(zMod));\n\n  /* If the module has been registered and includes a Create method, \n  ** invoke it now. If the module has not been registered, return an \n  ** error. Otherwise, do nothing.\n  */\n  if( !pMod ){\n    *pzErr = sqlite3MPrintf(db, "no such module: %s", zMod);\n    rc = SQLITE_ERROR;\n  }else{\n    rc = vtabCallConstructor(db, pTab, pMod, pMod->pModule->xCreate, pzErr);\n  }\n\n  /* Justification of ALWAYS():  The xConstructor method is required to\n  ** create a valid sqlite3_vtab if it returns SQLITE_OK. */\n  if( rc==SQLITE_OK && ALWAYS(sqlite3GetVTable(db, pTab)) ){\n      rc = addToVTrans(db, sqlite3GetVTable(db, pTab));\n  }\n\n  return rc;\n}\n\n/*\n** This function is used to set the schema of a virtual table.  It is only\n** valid to call this function from within the xCreate() or xConnect() of a\n** virtual table module.\n*/\nint sqlite3_declare_vtab(sqlite3 *db, const char *zCreateTable){\n  Parse *pParse;\n\n  int rc = SQLITE_OK;\n  Table *pTab;\n  char *zErr = 0;\n\n  sqlite3_mutex_enter(db->mutex);\n  pTab = db->pVTab;\n  if( !pTab ){\n    sqlite3Error(db, SQLITE_MISUSE, 0);\n    sqlite3_mutex_leave(db->mutex);\n    return SQLITE_MISUSE;\n  }\n  assert( (pTab->tabFlags & TF_Virtual)!=0 );\n\n  pParse = sqlite3StackAllocZero(db, sizeof(*pParse));\n  if( pParse==0 ){\n    rc = SQLITE_NOMEM;\n  }else{\n    pParse->declareVtab = 1;\n    pParse->db = db;\n  \n    if( \n        SQLITE_OK == sqlite3RunParser(pParse, zCreateTable, &zErr) && \n        pParse->pNewTable && \n        !pParse->pNewTable->pSelect && \n        (pParse->pNewTable->tabFlags & TF_Virtual)==0\n    ){\n      if( !pTab->aCol ){\n        pTab->aCol = pParse->pNewTable->aCol;\n        pTab->nCol = pParse->pNewTable->nCol;\n        pParse->pNewTable->nCol = 0;\n        pParse->pNewTable->aCol = 0;\n      }\n      db->pVTab = 0;\n    } else {\n      sqlite3Error(db, SQLITE_ERROR, zErr);\n      sqlite3DbFree(db, zErr);\n      rc = SQLITE_ERROR;\n    }\n    pParse->declareVtab = 0;\n  \n    if( pParse->pVdbe ){\n      sqlite3VdbeFinalize(pParse->pVdbe);\n    }\n    sqlite3DeleteTable(pParse->pNewTable);\n    sqlite3StackFree(db, pParse);\n  }\n\n  assert( (rc&0xff)==rc );\n  rc = sqlite3ApiExit(db, rc);\n  sqlite3_mutex_leave(db->mutex);\n  return rc;\n}\n\n/*\n** This function is invoked by the vdbe to call the xDestroy method\n** of the virtual table named zTab in database iDb. This occurs\n** when a DROP TABLE is mentioned.\n**\n** This call is a no-op if zTab is not a virtual table.\n*/\nint sqlite3VtabCallDestroy(sqlite3 *db, int iDb, const char *zTab){\n  int rc = SQLITE_OK;\n  Table *pTab;\n\n  pTab = sqlite3FindTable(db, zTab, db->aDb[iDb].zName);\n  if( ALWAYS(pTab!=0 && pTab->pVTable!=0) ){\n    VTable *p = vtabDisconnectAll(db, pTab);\n\n    rc = sqlite3SafetyOff(db);\n    assert( rc==SQLITE_OK );\n    rc = p->pMod->pModule->xDestroy(p->pVtab);\n    (void)sqlite3SafetyOn(db);\n\n    /* Remove the sqlite3_vtab* from the aVTrans[] array, if applicable */\n    if( rc==SQLITE_OK ){\n      assert( pTab->pVTable==p && p->pNext==0 );\n      p->pVtab = 0;\n      pTab->pVTable = 0;\n      sqlite3VtabUnlock(p);\n    }\n  }\n\n  return rc;\n}\n\n/*\n** This function invokes either the xRollback or xCommit method\n** of each of the virtual tables in the sqlite3.aVTrans array. The method\n** called is identified by the second argument, "offset", which is\n** the offset of the method to call in the sqlite3_module structure.\n**\n** The array is cleared after invoking the callbacks. \n*/\nstatic void callFinaliser(sqlite3 *db, int offset){\n  int i;\n  if( db->aVTrans ){\n    for(i=0; i<db->nVTrans; i++){\n      VTable *pVTab = db->aVTrans[i];\n      sqlite3_vtab *p = pVTab->pVtab;\n      if( p ){\n        int (*x)(sqlite3_vtab *);\n        x = *(int (**)(sqlite3_vtab *))((char *)p->pModule + offset);\n        if( x ) x(p);\n      }\n      sqlite3VtabUnlock(pVTab);\n    }\n    sqlite3DbFree(db, db->aVTrans);\n    db->nVTrans = 0;\n    db->aVTrans = 0;\n  }\n}\n\n/*\n** Invoke the xSync method of all virtual tables in the sqlite3.aVTrans\n** array. Return the error code for the first error that occurs, or\n** SQLITE_OK if all xSync operations are successful.\n**\n** Set *pzErrmsg to point to a buffer that should be released using \n** sqlite3DbFree() containing an error message, if one is available.\n*/\nint sqlite3VtabSync(sqlite3 *db, char **pzErrmsg){\n  int i;\n  int rc = SQLITE_OK;\n  int rcsafety;\n  VTable **aVTrans = db->aVTrans;\n\n  rc = sqlite3SafetyOff(db);\n  db->aVTrans = 0;\n  for(i=0; rc==SQLITE_OK && i<db->nVTrans; i++){\n    int (*x)(sqlite3_vtab *);\n    sqlite3_vtab *pVtab = aVTrans[i]->pVtab;\n    if( pVtab && (x = pVtab->pModule->xSync)!=0 ){\n      rc = x(pVtab);\n      sqlite3DbFree(db, *pzErrmsg);\n      *pzErrmsg = pVtab->zErrMsg;\n      pVtab->zErrMsg = 0;\n    }\n  }\n  db->aVTrans = aVTrans;\n  rcsafety = sqlite3SafetyOn(db);\n\n  if( rc==SQLITE_OK ){\n    rc = rcsafety;\n  }\n  return rc;\n}\n\n/*\n** Invoke the xRollback method of all virtual tables in the \n** sqlite3.aVTrans array. Then clear the array itself.\n*/\nint sqlite3VtabRollback(sqlite3 *db){\n  callFinaliser(db, offsetof(sqlite3_module,xRollback));\n  return SQLITE_OK;\n}\n\n/*\n** Invoke the xCommit method of all virtual tables in the \n** sqlite3.aVTrans array. Then clear the array itself.\n*/\nint sqlite3VtabCommit(sqlite3 *db){\n  callFinaliser(db, offsetof(sqlite3_module,xCommit));\n  return SQLITE_OK;\n}\n\n/*\n** If the virtual table pVtab supports the transaction interface\n** (xBegin/xRollback/xCommit and optionally xSync) and a transaction is\n** not currently open, invoke the xBegin method now.\n**\n** If the xBegin call is successful, place the sqlite3_vtab pointer\n** in the sqlite3.aVTrans array.\n*/\nint sqlite3VtabBegin(sqlite3 *db, VTable *pVTab){\n  int rc = SQLITE_OK;\n  const sqlite3_module *pModule;\n\n  /* Special case: If db->aVTrans is NULL and db->nVTrans is greater\n  ** than zero, then this function is being called from within a\n  ** virtual module xSync() callback. It is illegal to write to \n  ** virtual module tables in this case, so return SQLITE_LOCKED.\n  */\n  if( sqlite3VtabInSync(db) ){\n    return SQLITE_LOCKED;\n  }\n  if( !pVTab ){\n    return SQLITE_OK;\n  } \n  pModule = pVTab->pVtab->pModule;\n\n  if( pModule->xBegin ){\n    int i;\n\n\n    /* If pVtab is already in the aVTrans array, return early */\n    for(i=0; i<db->nVTrans; i++){\n      if( db->aVTrans[i]==pVTab ){\n        return SQLITE_OK;\n      }\n    }\n\n    /* Invoke the xBegin method */\n    rc = pModule->xBegin(pVTab->pVtab);\n    if( rc==SQLITE_OK ){\n      rc = addToVTrans(db, pVTab);\n    }\n  }\n  return rc;\n}\n\n/*\n** The first parameter (pDef) is a function implementation.  The\n** second parameter (pExpr) is the first argument to this function.\n** If pExpr is a column in a virtual table, then let the virtual\n** table implementation have an opportunity to overload the function.\n**\n** This routine is used to allow virtual table implementations to\n** overload MATCH, LIKE, GLOB, and REGEXP operators.\n**\n** Return either the pDef argument (indicating no change) or a \n** new FuncDef structure that is marked as ephemeral using the\n** SQLITE_FUNC_EPHEM flag.\n*/\nFuncDef *sqlite3VtabOverloadFunction(\n  sqlite3 *db,    /* Database connection for reporting malloc problems */\n  FuncDef *pDef,  /* Function to possibly overload */\n  int nArg,       /* Number of arguments to the function */\n  Expr *pExpr     /* First argument to the function */\n){\n  Table *pTab;\n  sqlite3_vtab *pVtab;\n  sqlite3_module *pMod;\n  void (*xFunc)(sqlite3_context*,int,sqlite3_value**) = 0;\n  void *pArg = 0;\n  FuncDef *pNew;\n  int rc = 0;\n  char *zLowerName;\n  unsigned char *z;\n\n\n  /* Check to see the left operand is a column in a virtual table */\n  if( NEVER(pExpr==0) ) return pDef;\n  if( pExpr->op!=TK_COLUMN ) return pDef;\n  pTab = pExpr->pTab;\n  if( NEVER(pTab==0) ) return pDef;\n  if( (pTab->tabFlags & TF_Virtual)==0 ) return pDef;\n  pVtab = sqlite3GetVTable(db, pTab)->pVtab;\n  assert( pVtab!=0 );\n  assert( pVtab->pModule!=0 );\n  pMod = (sqlite3_module *)pVtab->pModule;\n  if( pMod->xFindFunction==0 ) return pDef;\n \n  /* Call the xFindFunction method on the virtual table implementation\n  ** to see if the implementation wants to overload this function \n  */\n  zLowerName = sqlite3DbStrDup(db, pDef->zName);\n  if( zLowerName ){\n    for(z=(unsigned char*)zLowerName; *z; z++){\n      *z = sqlite3UpperToLower[*z];\n    }\n    rc = pMod->xFindFunction(pVtab, nArg, zLowerName, &xFunc, &pArg);\n    sqlite3DbFree(db, zLowerName);\n  }\n  if( rc==0 ){\n    return pDef;\n  }\n\n  /* Create a new ephemeral function definition for the overloaded\n  ** function */\n  pNew = sqlite3DbMallocZero(db, sizeof(*pNew)\n                             + sqlite3Strlen30(pDef->zName) + 1);\n  if( pNew==0 ){\n    return pDef;\n  }\n  *pNew = *pDef;\n  pNew->zName = (char *)&pNew[1];\n  memcpy(pNew->zName, pDef->zName, sqlite3Strlen30(pDef->zName)+1);\n  pNew->xFunc = xFunc;\n  pNew->pUserData = pArg;\n  pNew->flags |= SQLITE_FUNC_EPHEM;\n  return pNew;\n}\n\n/*\n** Make sure virtual table pTab is contained in the pParse->apVirtualLock[]\n** array so that an OP_VBegin will get generated for it.  Add pTab to the\n** array if it is missing.  If pTab is already in the array, this routine\n** is a no-op.\n*/\nvoid sqlite3VtabMakeWritable(Parse *pParse, Table *pTab){\n  int i, n;\n  Table **apVtabLock;\n\n  assert( IsVirtual(pTab) );\n  for(i=0; i<pParse->nVtabLock; i++){\n    if( pTab==pParse->apVtabLock[i] ) return;\n  }\n  n = (pParse->nVtabLock+1)*sizeof(pParse->apVtabLock[0]);\n  apVtabLock = sqlite3_realloc(pParse->apVtabLock, n);\n  if( apVtabLock ){\n    pParse->apVtabLock = apVtabLock;\n    pParse->apVtabLock[pParse->nVtabLock++] = pTab;\n  }else{\n    pParse->db->mallocFailed = 1;\n  }\n}\n\n#endif //* SQLITE_OMIT_VIRTUALTABLE */\n\n  }\n}\n'