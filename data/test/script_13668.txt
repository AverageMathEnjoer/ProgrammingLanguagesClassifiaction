b'/*\n    SPDX-FileCopyrightText: 2014-2016 Milian Wolff <mail@milianw.de>\n\n    SPDX-License-Identifier: LGPL-2.1-or-later\n*/\n\n/**\n * @file heaptrack_print.cpp\n *\n * @brief Evaluate and print the collected heaptrack data.\n */\n\n#include <boost/program_options.hpp>\n\n#include "analyze/accumulatedtracedata.h"\n#include "analyze/suppressions.h"\n\n#include <future>\n#include <iomanip>\n#include <iostream>\n\n#include <tsl/robin_set.h>\n\n#include "util/config.h"\n\nusing namespace std;\nnamespace po = boost::program_options;\n\nnamespace {\n\n/**\n * Merged allocation information by instruction pointer outside of alloc funcs\n */\nstruct MergedAllocation : public AllocationData\n{\n    // individual backtraces\n    std::vector<Allocation> traces;\n    // location\n    IpIndex ipIndex;\n};\n\nclass formatBytes\n{\npublic:\n    formatBytes(int64_t bytes, int width = 0)\n        : m_bytes(bytes)\n        , m_width(width)\n    {\n    }\n\n    friend ostream& operator<<(ostream& out, const formatBytes data);\n\nprivate:\n    int64_t m_bytes;\n    int m_width;\n};\n\ntemplate <typename Bytes>\nostream& writeBytes(ostream& out, Bytes bytes, int width, const char* unit)\n{\n    const auto unitLength = strlen(unit);\n    if (width > static_cast<int>(unitLength)) {\n        return out << fixed << setprecision(2) << setw(width - unitLength) << bytes << unit;\n    } else {\n        return out << fixed << setprecision(2) << bytes << *unit;\n    }\n}\n\nostream& operator<<(ostream& out, const formatBytes data)\n{\n    auto bytes = static_cast<double>(data.m_bytes);\n\n    static const auto units = {"B", "KB", "MB", "GB", "TB"};\n    auto unit = units.begin();\n    size_t i = 0;\n    while (i < units.size() - 1 && std::abs(bytes) > 1000.) {\n        bytes /= 1000.;\n        ++i;\n        ++unit;\n    }\n\n    if (i == 0) {\n        // no fractions for bytes\n        return writeBytes(out, data.m_bytes, data.m_width, *unit);\n    } else {\n        return writeBytes(out, bytes, data.m_width, *unit);\n    }\n}\n\nenum CostType\n{\n    Allocations,\n    Temporary,\n    Leaked,\n    Peak\n};\n\nstd::istream& operator>>(std::istream& in, CostType& type)\n{\n    std::string token;\n    in >> token;\n    if (token == "allocations")\n        type = Allocations;\n    else if (token == "temporary")\n        type = Temporary;\n    else if (token == "leaked")\n        type = Leaked;\n    else if (token == "peak")\n        type = Peak;\n    else\n        in.setstate(std::ios_base::failbit);\n    return in;\n}\n\nstruct Printer final : public AccumulatedTraceData\n{\n    void finalize()\n    {\n        applyLeakSuppressions();\n        filterAllocations();\n        mergedAllocations = mergeAllocations(allocations);\n    }\n\n    void mergeAllocation(vector<MergedAllocation>* mergedAllocations, const Allocation& allocation) const\n    {\n        const auto trace = findTrace(allocation.traceIndex);\n        const auto traceIp = findIp(trace.ipIndex);\n        auto it = lower_bound(mergedAllocations->begin(), mergedAllocations->end(), traceIp,\n                              [this](const MergedAllocation& allocation, const InstructionPointer traceIp) -> bool {\n                                  // Compare meta data without taking the instruction pointer address into account.\n                                  // This is useful since sometimes, esp. when we lack debug symbols, the same\n                                  // function allocates memory at different IP addresses which is pretty useless\n                                  // information most of the time\n                                  // TODO: make this configurable, but on-by-default\n                                  const auto allocationIp = findIp(allocation.ipIndex);\n                                  return allocationIp.compareWithoutAddress(traceIp);\n                              });\n        if (it == mergedAllocations->end() || !findIp(it->ipIndex).equalWithoutAddress(traceIp)) {\n            MergedAllocation merged;\n            merged.ipIndex = trace.ipIndex;\n            it = mergedAllocations->insert(it, merged);\n        }\n        it->traces.push_back(allocation);\n    }\n\n    // merge allocations so that different traces that point to the same\n    // instruction pointer at the end where the allocation function is\n    // called are combined\n    vector<MergedAllocation> mergeAllocations(const vector<Allocation>& allocations) const\n    {\n        // TODO: merge deeper traces, i.e. A,B,C,D and A,B,C,F\n        //       should be merged to A,B,C: D & F\n        //       currently the below will only merge it to: A: B,C,D & B,C,F\n        vector<MergedAllocation> ret;\n        ret.reserve(allocations.size());\n        for (const Allocation& allocation : allocations) {\n            mergeAllocation(&ret, allocation);\n        }\n        for (MergedAllocation& merged : ret) {\n            for (const Allocation& allocation : merged.traces) {\n                merged.allocations += allocation.allocations;\n                merged.leaked += allocation.leaked;\n                merged.peak += allocation.peak;\n                merged.temporary += allocation.temporary;\n            }\n        }\n        return ret;\n    }\n\n    void filterAllocations()\n    {\n        if (filterBtFunction.empty()) {\n            return;\n        }\n        allocations.erase(remove_if(allocations.begin(), allocations.end(),\n                                    [&](const Allocation& allocation) -> bool {\n                                        auto node = findTrace(allocation.traceIndex);\n                                        while (node.ipIndex) {\n                                            const auto& ip = findIp(node.ipIndex);\n                                            if (isStopIndex(ip.frame.functionIndex)) {\n                                                break;\n                                            }\n                                            auto matchFunction = [this](const Frame& frame) {\n                                                return stringify(frame.functionIndex).find(filterBtFunction)\n                                                    != string::npos;\n                                            };\n                                            if (matchFunction(ip.frame)) {\n                                                return false;\n                                            }\n                                            for (const auto& inlined : ip.inlined) {\n                                                if (matchFunction(inlined)) {\n                                                    return false;\n                                                }\n                                            }\n                                            node = findTrace(node.parentIndex);\n                                        };\n                                        return true;\n                                    }),\n                          allocations.end());\n    }\n\n    void printIndent(ostream& out, size_t indent, const char* indentString = "  ") const\n    {\n        while (indent--) {\n            out << indentString;\n        }\n    }\n\n    void printIp(const IpIndex ip, ostream& out, const size_t indent = 0) const\n    {\n        printIp(findIp(ip), out, indent);\n    }\n\n    void printIp(const InstructionPointer& ip, ostream& out, const size_t indent = 0, bool flameGraph = false) const\n    {\n        printIndent(out, indent);\n\n        if (ip.frame.functionIndex) {\n            out << prettyFunction(stringify(ip.frame.functionIndex));\n        } else {\n            out << "0x" << hex << ip.instructionPointer << dec;\n        }\n\n        if (flameGraph) {\n            // only print the file name but nothing else\n            auto printFile = [this, &out](FileIndex fileIndex) {\n                const auto& file = stringify(fileIndex);\n                auto idx = file.find_last_of(\'/\') + 1;\n                out << " (" << file.substr(idx) << ")";\n            };\n            if (ip.frame.fileIndex) {\n                printFile(ip.frame.fileIndex);\n            }\n            out << \';\';\n            for (const auto& inlined : ip.inlined) {\n                out << prettyFunction(stringify(inlined.functionIndex));\n                printFile(inlined.fileIndex);\n                out << \';\';\n            }\n            return;\n        }\n\n        out << \'\\n\';\n        printIndent(out, indent + 1);\n\n        if (ip.frame.fileIndex) {\n            out << "at " << stringify(ip.frame.fileIndex) << \':\' << ip.frame.line << \'\\n\';\n            printIndent(out, indent + 1);\n        }\n\n        if (ip.moduleIndex) {\n            out << "in " << stringify(ip.moduleIndex);\n        } else {\n            out << "in ??";\n        }\n        out << \'\\n\';\n\n        for (const auto& inlined : ip.inlined) {\n            printIndent(out, indent);\n            out << prettyFunction(stringify(inlined.functionIndex)) << \'\\n\';\n            printIndent(out, indent + 1);\n            out << "at " << stringify(inlined.fileIndex) << \':\' << inlined.line << \'\\n\';\n        }\n    }\n\n    void printBacktrace(const TraceIndex traceIndex, ostream& out, const size_t indent = 0,\n                        bool skipFirst = false) const\n    {\n        if (!traceIndex) {\n            out << "  ??";\n            return;\n        }\n        printBacktrace(findTrace(traceIndex), out, indent, skipFirst);\n    }\n\n    void printBacktrace(TraceNode node, ostream& out, const size_t indent = 0, bool skipFirst = false) const\n    {\n        tsl::robin_set<TraceIndex> recursionGuard;\n        while (node.ipIndex) {\n            const auto& ip = findIp(node.ipIndex);\n            if (!skipFirst) {\n                printIp(ip, out, indent);\n            }\n            skipFirst = false;\n\n            if (isStopIndex(ip.frame.functionIndex)) {\n                break;\n            }\n\n            if (!recursionGuard.insert(node.parentIndex).second) {\n                cerr << "Trace recursion detected - corrupt data file? " << node.parentIndex.index << endl;\n                break;\n            }\n            node = findTrace(node.parentIndex);\n        };\n    }\n\n    /**\n     * recursive top-down printer in the format\n     *\n     * func1;func2 (file);func2 (file);\n     */\n    void printFlamegraph(TraceNode node, ostream& out) const\n    {\n        if (!node.ipIndex) {\n            return;\n        }\n\n        const auto& ip = findIp(node.ipIndex);\n\n        if (!isStopIndex(ip.frame.functionIndex)) {\n            printFlamegraph(findTrace(node.parentIndex), out);\n        }\n        printIp(ip, out, 0, true);\n    }\n\n    template <typename T, typename LabelPrinter, typename SubLabelPrinter>\n    void printAllocations(T AllocationData::*member, LabelPrinter label, SubLabelPrinter sublabel)\n    {\n        if (mergeBacktraces) {\n            printMerged(member, label, sublabel);\n        } else {\n            printUnmerged(member, label);\n        }\n    }\n\n    template <typename T, typename LabelPrinter, typename SubLabelPrinter>\n    void printMerged(T AllocationData::*member, LabelPrinter label, SubLabelPrinter sublabel)\n    {\n        auto sortOrder = [member](const AllocationData& l, const AllocationData& r) {\n            return std::abs(l.*member) > std::abs(r.*member);\n        };\n        sort(mergedAllocations.begin(), mergedAllocations.end(), sortOrder);\n        for (size_t i = 0; i < min(peakLimit, mergedAllocations.size()); ++i) {\n            auto& allocation = mergedAllocations[i];\n            if (!(allocation.*member)) {\n                break;\n            }\n            label(allocation);\n            printIp(allocation.ipIndex, cout);\n\n            if (!allocation.ipIndex) {\n                continue;\n            }\n\n            sort(allocation.traces.begin(), allocation.traces.end(), sortOrder);\n            int64_t handled = 0;\n            for (size_t j = 0; j < min(subPeakLimit, allocation.traces.size()); ++j) {\n                const auto& trace = allocation.traces[j];\n                if (!(trace.*member)) {\n                    break;\n                }\n                sublabel(trace);\n                handled += trace.*member;\n                printBacktrace(trace.traceIndex, cout, 2, true);\n            }\n            if (allocation.traces.size() > subPeakLimit) {\n                cout << "  and ";\n                if (member == &AllocationData::allocations) {\n                    cout << (allocation.*member - handled);\n                } else {\n                    cout << formatBytes(allocation.*member - handled);\n                }\n                cout << " from " << (allocation.traces.size() - subPeakLimit) << " other places\\n";\n            }\n            cout << \'\\n\';\n        }\n    }\n\n    template <typename T, typename LabelPrinter>\n    void printUnmerged(T AllocationData::*member, LabelPrinter label)\n    {\n        sort(allocations.begin(), allocations.end(),\n             [member](const Allocation& l, const Allocation& r) { return std::abs(l.*member) > std::abs(r.*member); });\n        for (size_t i = 0; i < min(peakLimit, allocations.size()); ++i) {\n            const auto& allocation = allocations[i];\n            if (!(allocation.*member)) {\n                break;\n            }\n            label(allocation);\n            printBacktrace(allocation.traceIndex, cout, 1);\n            cout << \'\\n\';\n        }\n        cout << endl;\n    }\n\n    void writeMassifHeader(const char* command)\n    {\n        // write massif header\n        massifOut << "desc: heaptrack\\n"\n                  << "cmd: " << command << \'\\n\'\n                  << "time_unit: s\\n";\n    }\n\n    void writeMassifSnapshot(size_t timeStamp, bool isLast)\n    {\n        if (!lastMassifPeak) {\n            lastMassifPeak = totalCost.leaked;\n            massifAllocations = allocations;\n        }\n        massifOut << "#-----------\\n"\n                  << "snapshot=" << massifSnapshotId << \'\\n\'\n                  << "#-----------\\n"\n                  << "time=" << (0.001 * timeStamp) << \'\\n\'\n                  << "mem_heap_B=" << lastMassifPeak << \'\\n\'\n                  << "mem_heap_extra_B=0\\n"\n                  << "mem_stacks_B=0\\n";\n\n        if (massifDetailedFreq && (isLast || !(massifSnapshotId % massifDetailedFreq))) {\n            massifOut << "heap_tree=detailed\\n";\n            const size_t threshold = double(lastMassifPeak) * massifThreshold * 0.01;\n            writeMassifBacktrace(massifAllocations, lastMassifPeak, threshold, IpIndex());\n        } else {\n            massifOut << "heap_tree=empty\\n";\n        }\n\n        ++massifSnapshotId;\n        lastMassifPeak = 0;\n    }\n\n    void writeMassifBacktrace(const vector<Allocation>& allocations, size_t heapSize, size_t threshold,\n                              const IpIndex& location, size_t depth = 0)\n    {\n        int64_t skippedLeaked = 0;\n        size_t numAllocs = 0;\n        size_t skipped = 0;\n        auto mergedAllocations = mergeAllocations(allocations);\n        sort(mergedAllocations.begin(), mergedAllocations.end(),\n             [](const MergedAllocation& l, const MergedAllocation& r) { return l.leaked > r.leaked; });\n\n        const auto ip = findIp(location);\n\n        // skip anything below main\n        const bool shouldStop = isStopIndex(ip.frame.functionIndex);\n        if (!shouldStop) {\n            for (auto& merged : mergedAllocations) {\n                if (merged.leaked < 0) {\n                    // list is sorted, so we can bail out now - these entries are\n                    // uninteresting for massif\n                    break;\n                }\n\n                // skip items below threshold\n                if (static_cast<size_t>(merged.leaked) >= threshold) {\n                    ++numAllocs;\n                    // skip the first level of the backtrace, otherwise we\'d endlessly\n                    // recurse\n                    for (auto& alloc : merged.traces) {\n                        alloc.traceIndex = findTrace(alloc.traceIndex).parentIndex;\n                    }\n                } else {\n                    ++skipped;\n                    skippedLeaked += merged.leaked;\n                }\n            }\n        }\n\n        // TODO: write inlined frames out to massif files\n        printIndent(massifOut, depth, " ");\n        massifOut << \'n\' << (numAllocs + (skipped ? 1 : 0)) << ": " << heapSize;\n        if (!depth) {\n            massifOut << " (heap allocation functions) malloc/new/new[], "\n                         "--alloc-fns, etc.\\n";\n        } else {\n            massifOut << " 0x" << hex << ip.instructionPointer << dec << ": ";\n            if (ip.frame.functionIndex) {\n                massifOut << stringify(ip.frame.functionIndex);\n            } else {\n                massifOut << "???";\n            }\n\n            massifOut << " (";\n            if (ip.frame.fileIndex) {\n                massifOut << stringify(ip.frame.fileIndex) << \':\' << ip.frame.line;\n            } else if (ip.moduleIndex) {\n                massifOut << stringify(ip.moduleIndex);\n            } else {\n                massifOut << "???";\n            }\n            massifOut << ")\\n";\n        }\n\n        auto writeSkipped = [&] {\n            if (skipped) {\n                printIndent(massifOut, depth, " ");\n                massifOut << " n0: " << skippedLeaked << " in " << skipped << " places, all below massif\'s threshold ("\n                          << massifThreshold << ")\\n";\n                skipped = 0;\n            }\n        };\n\n        if (!shouldStop) {\n            for (const auto& merged : mergedAllocations) {\n                if (merged.leaked > 0 && static_cast<size_t>(merged.leaked) >= threshold) {\n                    if (skippedLeaked > merged.leaked) {\n                        // manually inject this entry to keep the output sorted\n                        writeSkipped();\n                    }\n                    writeMassifBacktrace(merged.traces, merged.leaked, threshold, merged.ipIndex, depth + 1);\n                }\n            }\n            writeSkipped();\n        }\n    }\n\n    void handleAllocation(const AllocationInfo& info, const AllocationInfoIndex /*index*/) override\n    {\n        if (printHistogram) {\n            ++sizeHistogram[info.size];\n        }\n\n        if (totalCost.leaked > 0 && static_cast<size_t>(totalCost.leaked) > lastMassifPeak && massifOut.is_open()) {\n            massifAllocations = allocations;\n            lastMassifPeak = totalCost.leaked;\n        }\n    }\n\n    void handleTimeStamp(int64_t /*oldStamp*/, int64_t newStamp, bool isFinalTimeStamp, ParsePass pass) override\n    {\n        if (pass != ParsePass::FirstPass) {\n            return;\n        }\n        if (massifOut.is_open()) {\n            writeMassifSnapshot(newStamp, isFinalTimeStamp);\n        }\n    }\n\n    void handleDebuggee(const char* command) override\n    {\n        cout << "Debuggee command was: " << command << endl;\n        if (massifOut.is_open()) {\n            writeMassifHeader(command);\n        }\n    }\n\n    bool printHistogram = false;\n    bool mergeBacktraces = true;\n\n    vector<MergedAllocation> mergedAllocations;\n\n    std::map<uint64_t, uint64_t> sizeHistogram;\n\n    uint64_t massifSnapshotId = 0;\n    uint64_t lastMassifPeak = 0;\n    vector<Allocation> massifAllocations;\n    ofstream massifOut;\n    double massifThreshold = 1;\n    uint64_t massifDetailedFreq = 1;\n\n    string filterBtFunction;\n    size_t peakLimit = 10;\n    size_t subPeakLimit = 5;\n};\n}\n\nint main(int argc, char** argv)\n{\n    po::options_description desc("Options", 120, 60);\n    // clang-format off\n    desc.add_options()\n        ("file,f", po::value<string>(),\n            "The heaptrack data file to print.")\n        ("diff,d", po::value<string>()->default_value({}),\n            "Find the differences to this file.")\n        ("shorten-templates,t", po::value<bool>()->default_value(true)->implicit_value(true),\n            "Shorten template identifiers.")\n        ("merge-backtraces,m", po::value<bool>()->default_value(true)->implicit_value(true),\n            "Merge backtraces.\\nNOTE: the merged peak consumption is not correct.")\n        ("print-peaks,p", po::value<bool>()->default_value(true)->implicit_value(true),\n            "Print backtraces to top allocators, sorted by peak consumption.")\n        ("print-allocators,a", po::value<bool>()->default_value(true)->implicit_value(true),\n            "Print backtraces to top allocators, sorted by number of calls to allocation functions.")\n        ("print-temporary,T", po::value<bool>()->default_value(true)->implicit_value(true),\n            "Print backtraces to top allocators, sorted by number of temporary allocations.")\n        ("print-leaks,l", po::value<bool>()->default_value(false)->implicit_value(true),\n            "Print backtraces to leaked memory allocations.")\n        ("peak-limit,n", po::value<size_t>()->default_value(10)->implicit_value(10),\n            "Limit the number of reported peaks.")\n        ("sub-peak-limit,s", po::value<size_t>()->default_value(5)->implicit_value(5),\n            "Limit the number of reported backtraces of merged peak locations.")\n        ("print-histogram,H", po::value<string>()->default_value(string()),\n            "Path to output file where an allocation size histogram will be written to.")\n        ("flamegraph-cost-type", po::value<CostType>()->default_value(Allocations),\n            "The cost type to use when generating a flamegraph. Possible options are:\\n"\n            "  - allocations: number of allocations\\n"\n            "  - temporary: number of temporary allocations\\n"\n            "  - leaked: bytes not deallocated at the end\\n"\n            "  - peak: bytes consumed at highest total memory consumption")\n        ("print-flamegraph,F", po::value<string>()->default_value(string()),\n            "Path to output file where a flame-graph compatible stack file will be written to.\\n"\n            "To visualize the resulting file, use flamegraph.pl from "\n            "https://github.com/brendangregg/FlameGraph:\\n"\n            "  heaptrack_print heaptrack.someapp.PID.gz -F stacks.txt\\n"\n            "  # optionally pass --reverse to flamegraph.pl\\n"\n            "  flamegraph.pl --title \\"heaptrack: allocations\\" --colors mem \\\\\\n"\n            "    --countname allocations < stacks.txt > heaptrack.someapp.PID.svg\\n"\n            "  [firefox|chromium] heaptrack.someapp.PID.svg\\n")\n        ("print-massif,M", po::value<string>()->default_value(string()),\n            "Path to output file where a massif compatible data file will be written to.")\n        ("massif-threshold", po::value<double>()->default_value(1.),\n            "Percentage of current memory usage, below which allocations are aggregated into a \'below threshold\' entry.\\n"\n            "This is only used in the massif output file so far.\\n")\n        ("massif-detailed-freq", po::value<size_t>()->default_value(2),\n            "Frequency of detailed snapshots in the massif output file. Increase  this to reduce the file size.\\n"\n            "You can set the value to zero to disable detailed snapshots.\\n")\n        ("filter-bt-function", po::value<string>()->default_value(string()),\n            "Only print allocations where the backtrace contains the given function.")\n        ("suppressions", po::value<string>()->default_value(string()),\n            "Load list of leak suppressions from the specified file. Specify one suppression per line, and start each line with \'leak:\', i.e. use the LSAN suppression file format.")\n        ("disable-embedded-suppressions",\n            "Ignore suppression definitions that are embedded into the heaptrack data file. By default, heaptrack will copy the suppressions"\n            "optionally defined via a `const char *__lsan_default_suppressions()` symbol in the debuggee application. These are then always "\n            "applied when analyzing the data, unless this feature is explicitly disabled using this command line option.")\n        ("disable-builtin-suppressions",\n            "Ignore suppression definitions that are built into heaptrack. By default, heaptrack will suppress certain "\n            "known leaks from common system libraries.")\n        ("print-suppressions", po::value<bool>()->default_value(false)->implicit_value(true),\n            "Show statistics for matched suppressions.")\n        ("help,h", "Show this help message.")\n        ("version,v", "Displays version information.");\n    // clang-format on\n    po::positional_options_description p;\n    p.add("file", -1);\n\n    po::variables_map vm;\n    try {\n        po::store(po::command_line_parser(argc, argv).options(desc).positional(p).run(), vm);\n        if (vm.count("help")) {\n            cout << "heaptrack_print - analyze heaptrack data files.\\n"\n                 << "\\n"\n                 << "heaptrack is a heap memory profiler which records information\\n"\n                 << "about calls to heap allocation functions such as malloc, "\n                    "operator new etc. pp.\\n"\n                 << "This print utility can then be used to analyze the generated "\n                    "data files.\\n\\n"\n                 << desc << endl;\n            return 0;\n        } else if (vm.count("version")) {\n            cout << "heaptrack_print " << HEAPTRACK_VERSION_STRING << endl;\n            return 0;\n        }\n        po::notify(vm);\n    } catch (const po::error& error) {\n        cerr << "ERROR: " << error.what() << endl << endl << desc << endl;\n        return 1;\n    }\n\n    if (!vm.count("file")) {\n        // NOTE: stay backwards compatible to old boost 1.41 available in RHEL 6\n        //       otherwise, we could simplify this by setting the file option\n        //       as ->required() using the new 1.42 boost API\n        cerr << "ERROR: the option \'--file\' is required but missing\\n\\n" << desc << endl;\n        return 1;\n    }\n\n    Printer data;\n\n    const auto inputFile = vm["file"].as<string>();\n    const auto diffFile = vm["diff"].as<string>();\n    data.shortenTemplates = vm["shorten-templates"].as<bool>();\n    data.mergeBacktraces = vm["merge-backtraces"].as<bool>();\n    data.filterBtFunction = vm["filter-bt-function"].as<string>();\n    data.peakLimit = vm["peak-limit"].as<size_t>();\n    data.subPeakLimit = vm["sub-peak-limit"].as<size_t>();\n    const string printHistogram = vm["print-histogram"].as<string>();\n    data.printHistogram = !printHistogram.empty();\n    const string printFlamegraph = vm["print-flamegraph"].as<string>();\n    const auto flamegraphCostType = vm["flamegraph-cost-type"].as<CostType>();\n    const string printMassif = vm["print-massif"].as<string>();\n    if (!printMassif.empty()) {\n        data.massifOut.open(printMassif, ios_base::out);\n        if (!data.massifOut.is_open()) {\n            cerr << "Failed to open massif output file \\"" << printMassif << "\\"." << endl;\n            return 1;\n        }\n        data.massifThreshold = vm["massif-threshold"].as<double>();\n        data.massifDetailedFreq = vm["massif-detailed-freq"].as<size_t>();\n    }\n    const bool printLeaks = vm["print-leaks"].as<bool>();\n    const bool printPeaks = vm["print-peaks"].as<bool>();\n    const bool printAllocs = vm["print-allocators"].as<bool>();\n    const bool printTemporary = vm["print-temporary"].as<bool>();\n    const auto printSuppressions = vm["print-suppressions"].as<bool>();\n    const auto suppressionsFile = vm["suppressions"].as<string>();\n\n    data.filterParameters.disableEmbeddedSuppressions = vm.count("disable-embedded-suppressions");\n    data.filterParameters.disableBuiltinSuppressions = vm.count("disable-builtin-suppressions");\n    bool suppressionsOk = false;\n    data.filterParameters.suppressions = parseSuppressions(suppressionsFile, &suppressionsOk);\n    if (!suppressionsOk) {\n        return 1;\n    }\n\n    cout << "reading file \\"" << inputFile << "\\" - please wait, this might take some time..." << endl;\n\n    if (!diffFile.empty()) {\n        cout << "reading diff file \\"" << diffFile << "\\" - please wait, this might take some time..." << endl;\n        Printer diffData;\n        auto diffRead = async(launch::async, [&diffData, diffFile]() { return diffData.read(diffFile, false); });\n\n        if (!data.read(inputFile, false) || !diffRead.get()) {\n            return 1;\n        }\n\n        data.diff(diffData);\n    } else if (!data.read(inputFile, false)) {\n        return 1;\n    }\n\n    data.finalize();\n\n    cout << "finished reading file, now analyzing data:\\n" << endl;\n\n    if (printAllocs) {\n        // sort by amount of allocations\n        cout << "MOST CALLS TO ALLOCATION FUNCTIONS\\n";\n        data.printAllocations(&AllocationData::allocations,\n                              [](const AllocationData& data) {\n                                  cout << data.allocations << " calls to allocation functions with "\n                                       << formatBytes(data.peak) << " peak consumption from\\n";\n                              },\n                              [](const AllocationData& data) {\n                                  cout << data.allocations << " calls with " << formatBytes(data.peak)\n                                       << " peak consumption from:\\n";\n                              });\n        cout << endl;\n    }\n\n    if (printPeaks) {\n        cout << "PEAK MEMORY CONSUMERS\\n";\n        data.printAllocations(&AllocationData::peak,\n                              [](const AllocationData& data) {\n                                  cout << formatBytes(data.peak) << " peak memory consumed over " << data.allocations\n                                       << " calls from\\n";\n                              },\n                              [](const AllocationData& data) {\n                                  cout << formatBytes(data.peak) << " consumed over " << data.allocations\n                                       << " calls from:\\n";\n                              });\n        cout << endl;\n    }\n\n    if (printLeaks) {\n        // sort by amount of leaks\n        cout << "MEMORY LEAKS\\n";\n        data.printAllocations(&AllocationData::leaked,\n                              [](const AllocationData& data) {\n                                  cout << formatBytes(data.leaked) << " leaked over " << data.allocations\n                                       << " calls from\\n";\n                              },\n                              [](const AllocationData& data) {\n                                  cout << formatBytes(data.leaked) << " leaked over " << data.allocations\n                                       << " calls from:\\n";\n                              });\n        cout << endl;\n    }\n\n    if (printTemporary) {\n        // sort by amount of temporary allocations\n        cout << "MOST TEMPORARY ALLOCATIONS\\n";\n        data.printAllocations(&AllocationData::temporary,\n                              [](const AllocationData& data) {\n                                  cout << data.temporary << " temporary allocations of " << data.allocations\n                                       << " allocations in total (" << fixed << setprecision(2)\n                                       << (float(data.temporary) * 100.f / data.allocations) << "%) from\\n";\n                              },\n                              [](const AllocationData& data) {\n                                  cout << data.temporary << " temporary allocations of " << data.allocations\n                                       << " allocations in total (" << fixed << setprecision(2)\n                                       << (float(data.temporary) * 100.f / data.allocations) << "%) from:\\n";\n                              });\n        cout << endl;\n    }\n\n    const double totalTimeS = data.totalTime ? (1000. / data.totalTime) : 1.;\n    cout << "total runtime: " << fixed << (data.totalTime / 1000.) << "s.\\n"\n         << "calls to allocation functions: " << data.totalCost.allocations << " ("\n         << int64_t(data.totalCost.allocations * totalTimeS) << "/s)\\n"\n         << "temporary memory allocations: " << data.totalCost.temporary << " ("\n         << int64_t(data.totalCost.temporary * totalTimeS) << "/s)\\n"\n         << "peak heap memory consumption: " << formatBytes(data.totalCost.peak) << \'\\n\'\n         << "peak RSS (including heaptrack overhead): " << formatBytes(data.peakRSS * data.systemInfo.pageSize) << \'\\n\'\n         << "total memory leaked: " << formatBytes(data.totalCost.leaked) << \'\\n\';\n    if (data.totalLeakedSuppressed) {\n        cout << "suppressed leaks: " << formatBytes(data.totalLeakedSuppressed) << \'\\n\';\n\n        if (printSuppressions) {\n            cout << "Suppressions used:\\n";\n            cout << setw(16) << "matches" << \' \' << setw(16) << "leaked"\n                 << " pattern\\n";\n            for (const auto& suppression : data.suppressions) {\n                if (!suppression.matches) {\n                    continue;\n                }\n                cout << setw(16) << suppression.matches << \' \' << formatBytes(suppression.leaked, 16) << \' \'\n                     << suppression.pattern << \'\\n\';\n            }\n        }\n    }\n\n    if (!printHistogram.empty()) {\n        ofstream histogram(printHistogram, ios_base::out);\n        if (!histogram.is_open()) {\n            cerr << "Failed to open histogram output file \\"" << printHistogram << "\\"." << endl;\n        } else {\n            for (auto entry : data.sizeHistogram) {\n                histogram << entry.first << \'\\t\' << entry.second << \'\\n\';\n            }\n        }\n    }\n\n    if (!printFlamegraph.empty()) {\n        ofstream flamegraph(printFlamegraph, ios_base::out);\n        if (!flamegraph.is_open()) {\n            cerr << "Failed to open flamegraph output file \\"" << printFlamegraph << "\\"." << endl;\n        } else {\n            for (const auto& allocation : data.allocations) {\n                if (!allocation.traceIndex) {\n                    flamegraph << "??";\n                } else {\n                    data.printFlamegraph(data.findTrace(allocation.traceIndex), flamegraph);\n                }\n                flamegraph << \' \';\n                switch (flamegraphCostType) {\n                case Allocations:\n                    flamegraph << allocation.allocations;\n                    break;\n                case Temporary:\n                    flamegraph << allocation.temporary;\n                    break;\n                case Peak:\n                    flamegraph << allocation.peak;\n                    break;\n                case Leaked:\n                    flamegraph << allocation.leaked;\n                    break;\n                }\n                flamegraph << \'\\n\';\n            }\n        }\n    }\n\n    return 0;\n}\n'