b'{-# LANGUAGE OverloadedStrings #-}\n\n-- | PDF document page\n\nmodule Pdf.Document.Page\n(\n  Page,\n  pageParentNode,\n  pageContents,\n  pageMediaBox,\n  pageFontDicts,\n  pageExtractText,\n  pageExtractGlyphs,\n  glyphsToText\n)\nwhere\n\nimport Pdf.Core.Object\nimport Pdf.Core.Object.Util\nimport Pdf.Core.Exception\nimport Pdf.Core.Util\nimport Pdf.Content\n\nimport Pdf.Document.Pdf\nimport Pdf.Document.Types\nimport Pdf.Document.PageNode\nimport Pdf.Document.FontDict\nimport Pdf.Document.Internal.Types\nimport Pdf.Document.Internal.Util\n\nimport Data.Maybe\nimport qualified Data.List as List\nimport qualified Data.Traversable as Traversable\nimport Data.ByteString (ByteString)\nimport qualified Data.ByteString.Lazy as Lazy (ByteString)\nimport qualified Data.ByteString.Lazy as Lazy.ByteString\nimport Data.Text (Text)\nimport qualified Data.Text.Lazy as Lazy.Text\nimport qualified Data.Text.Lazy.Builder as Text.Builder\nimport Data.Map (Map)\nimport qualified Data.Map as Map\nimport qualified Data.Vector as Vector\nimport qualified Data.HashMap.Strict as HashMap\nimport Control.Monad\nimport Control.Monad.IO.Class\nimport Control.Exception hiding (throw)\nimport System.IO.Streams (InputStream)\nimport qualified System.IO.Streams as Streams\nimport qualified System.IO.Streams.Attoparsec as Streams\n\n-- | Page\'s parent node\npageParentNode :: Page -> IO PageNode\npageParentNode (Page pdf _ dict) = do\n  ref <- sure $ (HashMap.lookup "Parent" dict >>= refValue)\n      `notice` "Parent should be a reference"\n  node <- loadPageNode pdf ref\n  case node of\n    PageTreeNode n -> return n\n    PageTreeLeaf _ -> throwIO $ Corrupted\n      "page parent should be a note, but leaf found" []\n\n-- | List of references to page\'s content streams\npageContents :: Page -> IO [Ref]\npageContents (Page pdf pageRef dict) =\n  message ("contents for page: " ++ show pageRef) $ do\n  case HashMap.lookup "Contents" dict of\n    Nothing -> return []\n    Just (Ref ref) -> do\n      -- it could be reference to the only content stream,\n      -- or to an array of content streams\n      o <- lookupObject pdf ref >>= deref pdf\n      case o of\n        Stream _ -> return [ref]\n        Array objs -> forM (Vector.toList objs) $ \\obj ->\n          sure $ refValue obj `notice` "Content should be a reference"\n        _ -> throwIO $ Corrupted\n          ("Unexpected value in page content ref: " ++ show o) []\n    Just (Array objs) -> forM (Vector.toList objs) $ \\obj ->\n      sure $ refValue obj `notice` "Content should be a reference"\n    _ -> throwIO $ Corrupted "Unexpected value in page contents" []\n\n-- | Media box, inheritable\npageMediaBox :: Page -> IO (Rectangle Double)\npageMediaBox page = mediaBoxRec (PageTreeLeaf page)\n\nmediaBoxRec :: PageTree -> IO (Rectangle Double)\nmediaBoxRec tree = do\n  let (pdf, dict) =\n        case tree of\n          PageTreeNode (PageNode p _ d) -> (p, d)\n          PageTreeLeaf (Page p _ d) -> (p, d)\n  case HashMap.lookup "MediaBox" dict of\n    Just box -> do\n      box\' <- deref pdf box\n      arr <- sure $ arrayValue box\'\n          `notice` "MediaBox should be an array"\n      sure $ rectangleFromArray arr\n    Nothing -> do\n      parent <-\n        case tree of\n          PageTreeNode node -> do\n            parent <- pageNodeParent node\n            case parent of\n              Nothing -> throwIO $ Corrupted "Media box not found" []\n              Just p -> return (PageTreeNode p)\n          PageTreeLeaf page -> PageTreeNode <$> pageParentNode page\n      mediaBoxRec parent\n\n-- | Font dictionaries for the page\npageFontDicts :: Page -> IO [(Name, FontDict)]\npageFontDicts (Page pdf _ dict) =\n  case HashMap.lookup "Resources" dict of\n    Nothing -> return []\n    Just res -> do\n      res\' <- deref pdf res\n      resDict <- sure $ dictValue res\'\n          `notice` "Resources should be a dictionary"\n      case HashMap.lookup "Font" resDict of\n        Nothing -> return []\n        Just fonts -> do\n          fonts\' <- deref pdf fonts\n          fontsDict <- sure $ dictValue fonts\'\n              `notice` "Font should be a dictionary"\n          forM (HashMap.toList fontsDict) $ \\(name, font) -> do\n            font\' <- deref pdf font\n            fontDict <- sure $ dictValue font\'\n                `notice` "Each font should be a dictionary"\n            ensureType "Font" fontDict\n            return (name, FontDict pdf fontDict)\n\ndata XObject = XObject\n  { xobjectContent :: Lazy.ByteString\n  , xobjectGlyphDecoder :: GlyphDecoder\n  , xobjectChildren :: Map Name XObject\n  }\n\ninstance Show XObject where\n  show xobj = show (xobjectContent xobj, xobjectChildren xobj)\n\npageXObjects :: Page -> IO (Map Name XObject)\npageXObjects (Page pdf _ dict) = dictXObjects pdf dict\n\ndictXObjects :: Pdf -> Dict -> IO (Map Name XObject)\ndictXObjects pdf dict =\n  case HashMap.lookup "Resources" dict of\n    Nothing -> return Map.empty\n    Just res -> do\n      resDict <- do\n        v <- deref pdf res\n        sure $ dictValue v\n          `notice` "Resources should be a dict"\n\n      case HashMap.lookup "XObject" resDict of\n        Nothing -> return Map.empty\n        Just xo -> do\n          xosDict <- do\n            v <- deref pdf xo\n            sure $ dictValue v\n              `notice` "XObject should be a dict"\n          result <- forM (HashMap.toList xosDict) $ \\(name, o) -> do\n            ref <- sure $ refValue o\n              `notice` "Not a ref"\n            s@(S xoDict _) <- do\n              v <- lookupObject pdf ref\n              sure $ streamValue v\n                `notice` "Not a stream"\n\n            case HashMap.lookup "Subtype" xoDict of\n              Just (Name "Form") -> do\n                is <- streamContent pdf ref s\n                cont <- Lazy.ByteString.fromChunks <$> Streams.toList is\n\n                fontDicts <- Map.fromList <$>\n                  pageFontDicts (Page pdf ref xoDict)\n\n                glyphDecoders <- Traversable.forM fontDicts $ \\fontDict ->\n                  fontInfoDecodeGlyphs <$> fontDictLoadInfo fontDict\n                let glyphDecoder fontName = \\str ->\n                      case Map.lookup fontName glyphDecoders of\n                        Nothing -> []\n                        Just decode -> decode str\n\n                children <- dictXObjects pdf xoDict\n\n                let xobj = XObject\n                      { xobjectContent = cont\n                      , xobjectGlyphDecoder = glyphDecoder\n                      , xobjectChildren = children\n                      }\n                return (name, Just xobj)\n\n              _ -> return (name, Nothing)\n\n          return $ Map.fromList $ flip mapMaybe result $ \\(n, mo) -> do\n            o <- mo\n            return (n, o)\n\n-- | Extract text from the page\n--\n-- It tries to add spaces between chars if they don\'t present\n-- as actual characters in content stream.\npageExtractText :: Page -> IO Text\npageExtractText page = glyphsToText <$> pageExtractGlyphs page\n\npageExtractGlyphs :: Page -> IO [Span]\npageExtractGlyphs page = do\n  fontDicts <- Map.fromList <$> pageFontDicts page\n  glyphDecoders <- Traversable.forM fontDicts $ \\fontDict ->\n    fontInfoDecodeGlyphs <$> fontDictLoadInfo fontDict\n  let glyphDecoder fontName = \\str ->\n        case Map.lookup fontName glyphDecoders of\n          Nothing -> []\n          Just decode -> decode str\n\n  xobjects <- pageXObjects page\n\n  is <- do\n    contents <- pageContents page\n    let Page pdf _ _ = page\n    is <- combinedContent pdf contents\n    Streams.parserToInputStream parseContent is\n\n  -- use content stream processor to extract text\n  let loop xobjs s p = do\n        next <- readNextOperator s\n        case next of\n          Just (Op_Do, [Name name]) -> processDo xobjs name p >>= loop xobjs s\n          Just op ->\n            case processOp op p of\n              Left err -> throwIO (Unexpected err [])\n              Right  p\' -> loop xobjs s p\'\n          Nothing -> return p\n\n      processDo xobjs name p = do\n        case Map.lookup name xobjs of\n          Nothing -> return p\n          Just xobj -> do\n            s <- do\n              s <- Streams.fromLazyByteString (xobjectContent xobj)\n              Streams.parserToInputStream parseContent s\n\n            let gdec\' = prGlyphDecoder p\n            p\' <- loop (xobjectChildren xobj) s\n              (p {prGlyphDecoder = xobjectGlyphDecoder xobj})\n            return (p\' {prGlyphDecoder = gdec\'})\n\n  p <- loop xobjects is $ mkProcessor {\n    prGlyphDecoder = glyphDecoder\n    }\n  return (List.reverse (prSpans p))\n\ncombinedContent :: Pdf -> [Ref] -> IO (InputStream ByteString)\ncombinedContent pdf refs = do\n  allStreams <- forM refs $ \\ref -> do\n    o <- lookupObject pdf ref\n    case o of\n      Stream s -> return (ref, s)\n      _ -> throwIO (Corrupted "Page content is not a stream" [])\n\n  Streams.fromGenerator $ forM_ allStreams $ \\(ref, stream) -> do\n    is <- liftIO $ streamContent pdf ref stream\n    yield is\n  where\n  yield is = do\n    chunk <- liftIO $ Streams.read is\n    case chunk of\n      Nothing -> return ()\n      Just c -> do\n        Streams.yield c\n        yield is\n\n-- | Convert glyphs to text, trying to add spaces and newlines\n--\n-- It takes list of spans. Each span is a list of glyphs that are outputed in one shot.\n-- So we don\'t need to add space inside span, only between them.\nglyphsToText :: [Span] -> Text\nglyphsToText\n  = Lazy.Text.toStrict\n  . Text.Builder.toLazyText\n  . snd\n  . foldl step ((Vector 0 0, False), mempty)\n  . List.map spGlyphs\n  where\n  step acc [] = acc\n  step ((Vector lx2 ly2, wasSpace), res) sp =\n    let Vector x1 y1 = glyphTopLeft (head sp)\n        Vector x2 _ = glyphBottomRight (last sp)\n        Vector _ y2 = glyphTopLeft (last sp)\n        space =\n          if abs (ly2 - y1) < 1.8\n            then  if wasSpace || abs (lx2 - x1) < 1.8\n                    then mempty\n                    else Text.Builder.singleton \' \'\n            else Text.Builder.singleton \'\\n\'\n        txt = Text.Builder.fromLazyText $ Lazy.Text.fromChunks $ mapMaybe glyphText sp\n        endWithSpace = glyphText (last sp) == Just " "\n    in ((Vector x2 y2, endWithSpace), mconcat [res, space, txt])\n'