b'#define SQLITE_MAX_EXPR_DEPTH\n\nusing System;\nusing System.Diagnostics;\nusing System.Text;\n\nusing Bitmask = System.UInt64;\nusing i64 = System.Int64;\nusing u8 = System.Byte;\nusing u32 = System.UInt32;\nusing u16 = System.UInt16;\n\nusing Pgno = System.UInt32;\n\nnamespace CS_SQLite3\n{\n  public partial class CSSQLite\n  {\n    /*\n    ** 2001 September 15\n    **\n    ** The author disclaims copyright to this source code.  In place of\n    ** a legal notice, here is a blessing:\n    **\n    **    May you do good and not evil.\n    **    May you find forgiveness for yourself and forgive others.\n    **    May you share freely, never taking more than you give.\n    **\n    *************************************************************************\n    ** This file contains routines used for analyzing expressions and\n    ** for generating VDBE code that evaluates expressions in SQLite.\n    **\n    ** $Id: expr.c,v 1.448 2009/07/27 10:05:05 danielk1977 Exp $\n    **\n    *************************************************************************\n    **  Included in SQLite3 port to C#-SQLite;  2008 Noah B Hart\n    **  C#-SQLite is an independent reimplementation of the SQLite software library\n    **\n    **  $Header$\n    *************************************************************************\n    */\n    //#include "sqliteInt.h"\n\n    /*\n    ** Return the \'affinity\' of the expression pExpr if any.\n    **\n    ** If pExpr is a column, a reference to a column via an \'AS\' alias,\n    ** or a sub-select with a column as the return value, then the\n    ** affinity of that column is returned. Otherwise, 0x00 is returned,\n    ** indicating no affinity for the expression.\n    **\n    ** i.e. the WHERE clause expresssions in the following statements all\n    ** have an affinity:\n    **\n    ** CREATE TABLE t1(a);\n    ** SELECT * FROM t1 WHERE a;\n    ** SELECT a AS b FROM t1 WHERE b;\n    ** SELECT * FROM t1 WHERE (select a from t1);\n    */\n    static char sqlite3ExprAffinity( Expr pExpr )\n    {\n      int op = pExpr.op;\n      if ( op == TK_SELECT )\n      {\n        Debug.Assert( ( pExpr.flags & EP_xIsSelect ) != 0 );\n        return sqlite3ExprAffinity( pExpr.x.pSelect.pEList.a[0].pExpr );\n      }\n#if !SQLITE_OMIT_CAST\n      if ( op == TK_CAST )\n      {\n        Debug.Assert( !ExprHasProperty( pExpr, EP_IntValue ) );\n        return sqlite3AffinityType( pExpr.u.zToken );\n      }\n#endif\n      if ( ( op == TK_AGG_COLUMN || op == TK_COLUMN || op == TK_REGISTER )\n      && pExpr.pTab != null\n      )\n      {\n        /* op==TK_REGISTER && pExpr.pTab!=0 happens when pExpr was originally\n        ** a TK_COLUMN but was previously evaluated and cached in a register */\n        int j = pExpr.iColumn;\n        if ( j < 0 ) return SQLITE_AFF_INTEGER;\n        Debug.Assert( pExpr.pTab != null && j < pExpr.pTab.nCol );\n        return pExpr.pTab.aCol[j].affinity;\n      }\n      return pExpr.affinity;\n    }\n\n    /*\n    ** Set the collating sequence for expression pExpr to be the collating\n    ** sequence named by pToken.   Return a pointer to the revised expression.\n    ** The collating sequence is marked as "explicit" using the EP_ExpCollate\n    ** flag.  An explicit collating sequence will override implicit\n    ** collating sequences.\n    */\n    static Expr sqlite3ExprSetColl( Parse pParse, Expr pExpr, Token pCollName )\n    {\n      string zColl;            /* Dequoted name of collation sequence */\n      CollSeq pColl;\n      sqlite3 db = pParse.db;\n      zColl = sqlite3NameFromToken( db, pCollName );\n      if ( pExpr != null && zColl != null )\n      {\n        pColl = sqlite3LocateCollSeq( pParse, zColl );\n        if ( pColl != null )\n        {\n          pExpr.pColl = pColl;\n          pExpr.flags |= EP_ExpCollate;\n        }\n      }\n      //sqlite3DbFree( db, ref zColl );\n      return pExpr;\n    }\n\n    /*\n    ** Return the default collation sequence for the expression pExpr. If\n    ** there is no default collation type, return 0.\n    */\n    static CollSeq sqlite3ExprCollSeq( Parse pParse, Expr pExpr )\n    {\n      CollSeq pColl = null;\n      Expr p = pExpr;\n      while ( ALWAYS( p != null ) )\n      {\n        int op;\n        pColl = pExpr.pColl;\n        if (pColl != null ) break;\n        op = p.op;\n        if ( ( op == TK_AGG_COLUMN || op == TK_COLUMN || op == TK_REGISTER ) && p.pTab != null )\n        {\n          /* op==TK_REGISTER && p->pTab!=0 happens when pExpr was originally\n          ** a TK_COLUMN but was previously evaluated and cached in a register */\n          string zColl;\n          int j = p.iColumn;\n          if ( j >= 0 )\n          {\n            sqlite3 db = pParse.db;\n            zColl = p.pTab.aCol[j].zColl;\n            pColl = sqlite3FindCollSeq( db, ENC( db ), zColl, 0 );\n            pExpr.pColl = pColl;\n          }\n          break;\n        }\n        if ( op != TK_CAST && op != TK_UPLUS )\n        {\n          break;\n        }\n        p = p.pLeft;\n      }\n      if ( sqlite3CheckCollSeq( pParse, pColl ) != 0 )\n      {\n        pColl = null;\n      }\n      return pColl;\n    }\n\n    /*\n    ** pExpr is an operand of a comparison operator.  aff2 is the\n    ** type affinity of the other operand.  This routine returns the\n    ** type affinity that should be used for the comparison operator.\n    */\n    static char sqlite3CompareAffinity( Expr pExpr, char aff2 )\n    {\n      char aff1 = sqlite3ExprAffinity( pExpr );\n      if ( aff1 != \'\\0\' && aff2 != \'\\0\' )\n      {\n        /* Both sides of the comparison are columns. If one has numeric\n        ** affinity, use that. Otherwise use no affinity.\n        */\n        if ( aff1 >= SQLITE_AFF_NUMERIC || aff2 >= SQLITE_AFF_NUMERIC )\n        //        if (sqlite3IsNumericAffinity(aff1) || sqlite3IsNumericAffinity(aff2))\n        {\n          return SQLITE_AFF_NUMERIC;\n        }\n        else\n        {\n          return SQLITE_AFF_NONE;\n        }\n      }\n      else if ( aff1 == \'\\0\' && aff2 == \'\\0\' )\n      {\n        /* Neither side of the comparison is a column.  Compare the\n        ** results directly.\n        */\n        return SQLITE_AFF_NONE;\n      }\n      else\n      {\n        /* One side is a column, the other is not. Use the columns affinity. */\n        Debug.Assert( aff1 == 0 || aff2 == 0 );\n        return ( aff1 != \'\\0\' ? aff1 : aff2 );\n      }\n    }\n\n    /*\n    ** pExpr is a comparison operator.  Return the type affinity that should\n    ** be applied to both operands prior to doing the comparison.\n    */\n    static char comparisonAffinity( Expr pExpr )\n    {\n      char aff;\n      Debug.Assert( pExpr.op == TK_EQ || pExpr.op == TK_IN || pExpr.op == TK_LT ||\n      pExpr.op == TK_GT || pExpr.op == TK_GE || pExpr.op == TK_LE ||\n      pExpr.op == TK_NE );\n      Debug.Assert( pExpr.pLeft != null );\n      aff = sqlite3ExprAffinity( pExpr.pLeft );\n      if ( pExpr.pRight != null )\n      {\n        aff = sqlite3CompareAffinity( pExpr.pRight, aff );\n      }\n      else if ( ExprHasProperty( pExpr, EP_xIsSelect ) )\n      {\n        aff = sqlite3CompareAffinity( pExpr.x.pSelect.pEList.a[0].pExpr, aff );\n      }\n      else if ( aff == \'\\0\' )\n      {\n        aff = SQLITE_AFF_NONE;\n      }\n      return aff;\n    }\n\n    /*\n    ** pExpr is a comparison expression, eg. \'=\', \'<\', IN(...) etc.\n    ** idx_affinity is the affinity of an indexed column. Return true\n    ** if the index with affinity idx_affinity may be used to implement\n    ** the comparison in pExpr.\n    */\n    static bool sqlite3IndexAffinityOk( Expr pExpr, char idx_affinity )\n    {\n      char aff = comparisonAffinity( pExpr );\n      switch ( aff )\n      {\n        case SQLITE_AFF_NONE:\n          return true;\n        case SQLITE_AFF_TEXT:\n          return idx_affinity == SQLITE_AFF_TEXT;\n        default:\n          return idx_affinity >= SQLITE_AFF_NUMERIC;// sqlite3IsNumericAffinity(idx_affinity);\n      }\n    }\n\n    /*\n    ** Return the P5 value that should be used for a binary comparison\n    ** opcode (OP_Eq, OP_Ge etc.) used to compare pExpr1 and pExpr2.\n    */\n    static u8 binaryCompareP5( Expr pExpr1, Expr pExpr2, int jumpIfNull )\n    {\n      u8 aff = (u8)sqlite3ExprAffinity( pExpr2 );\n      aff = (u8)( (u8)sqlite3CompareAffinity( pExpr1, (char)aff ) | (u8)jumpIfNull );\n      return aff;\n    }\n\n    /*\n    ** Return a pointer to the collation sequence that should be used by\n    ** a binary comparison operator comparing pLeft and pRight.\n    **\n    ** If the left hand expression has a collating sequence type, then it is\n    ** used. Otherwise the collation sequence for the right hand expression\n    ** is used, or the default (BINARY) if neither expression has a collating\n    ** type.\n    **\n    ** Argument pRight (but not pLeft) may be a null pointer. In this case,\n    ** it is not considered.\n    */\n    static CollSeq sqlite3BinaryCompareCollSeq(\n    Parse pParse,\n    Expr pLeft,\n    Expr pRight\n    )\n    {\n      CollSeq pColl;\n      Debug.Assert( pLeft != null );\n      if ( ( pLeft.flags & EP_ExpCollate ) != 0 )\n      {\n        Debug.Assert( pLeft.pColl != null );\n        pColl = pLeft.pColl;\n      }\n      else if ( pRight != null && ( ( pRight.flags & EP_ExpCollate ) != 0 ) )\n      {\n        Debug.Assert( pRight.pColl != null );\n        pColl = pRight.pColl;\n      }\n      else\n      {\n        pColl = sqlite3ExprCollSeq( pParse, pLeft );\n        if ( pColl == null )\n        {\n          pColl = sqlite3ExprCollSeq( pParse, pRight );\n        }\n      }\n      return pColl;\n    }\n\n    /*\n    ** Generate the operands for a comparison operation.  Before\n    ** generating the code for each operand, set the EP_AnyAff\n    ** flag on the expression so that it will be able to used a\n    ** cached column value that has previously undergone an\n    ** affinity change.\n    */\n    static void codeCompareOperands(\n    Parse pParse,        /* Parsing and code generating context */\n    Expr pLeft,          /* The left operand */\n    ref int pRegLeft,    /* Register where left operand is stored */\n    ref int pFreeLeft,   /* Free this register when done */\n    Expr pRight,         /* The right operand */\n    ref int pRegRight,   /* Register where right operand is stored */\n    ref int pFreeRight   /* Write temp register for right operand there */\n    )\n    {\n\n      while ( pLeft.op == TK_UPLUS ) pLeft = pLeft.pLeft;\n      pLeft.flags |= EP_AnyAff;\n      pRegLeft = sqlite3ExprCodeTemp( pParse, pLeft, ref pFreeLeft );\n      while ( pRight.op == TK_UPLUS ) pRight = pRight.pLeft;\n      pRight.flags |= EP_AnyAff;\n      pRegRight = sqlite3ExprCodeTemp( pParse, pRight, ref pFreeRight );\n    }\n\n    /*\n    ** Generate code for a comparison operator.\n    */\n    static int codeCompare(\n    Parse pParse,    /* The parsing (and code generating) context */\n    Expr pLeft,      /* The left operand */\n    Expr pRight,     /* The right operand */\n    int opcode,       /* The comparison opcode */\n    int in1, int in2, /* Register holding operands */\n    int dest,         /* Jump here if true.  */\n    int jumpIfNull    /* If true, jump if either operand is NULL */\n    )\n    {\n      int p5;\n      int addr;\n      CollSeq p4;\n\n      p4 = sqlite3BinaryCompareCollSeq( pParse, pLeft, pRight );\n      p5 = binaryCompareP5( pLeft, pRight, jumpIfNull );\n      addr = sqlite3VdbeAddOp4( pParse.pVdbe, opcode, in2, dest, in1,\n      p4, P4_COLLSEQ );\n      sqlite3VdbeChangeP5( pParse.pVdbe, (u8)p5 );\n      if ( ( p5 & SQLITE_AFF_MASK ) != SQLITE_AFF_NONE )\n      {\n        sqlite3ExprCacheAffinityChange( pParse, in1, 1 );\n        sqlite3ExprCacheAffinityChange( pParse, in2, 1 );\n      }\n      return addr;\n    }\n\n#if SQLITE_MAX_EXPR_DEPTH //>0\n    /*\n** Check that argument nHeight is less than or equal to the maximum\n** expression depth allowed. If it is not, leave an error message in\n** pParse.\n*/\n    static int sqlite3ExprCheckHeight( Parse pParse, int nHeight )\n    {\n      int rc = SQLITE_OK;\n      int mxHeight = pParse.db.aLimit[SQLITE_LIMIT_EXPR_DEPTH];\n      if ( nHeight > mxHeight )\n      {\n        sqlite3ErrorMsg( pParse,\n        "Expression tree is too large (maximum depth %d)", mxHeight\n        );\n        rc = SQLITE_ERROR;\n      }\n      return rc;\n    }\n\n    /* The following three functions, heightOfExpr(), heightOfExprList()\n    ** and heightOfSelect(), are used to determine the maximum height\n    ** of any expression tree referenced by the structure passed as the\n    ** first argument.\n    **\n    ** If this maximum height is greater than the current value pointed\n    ** to by pnHeight, the second parameter, then set pnHeight to that\n    ** value.\n    */\n    static void heightOfExpr( Expr p, ref int pnHeight )\n    {\n      if ( p != null )\n      {\n        if ( p.nHeight > pnHeight )\n        {\n          pnHeight = p.nHeight;\n        }\n      }\n    }\n    static void heightOfExprList( ExprList p, ref int pnHeight )\n    {\n      if ( p != null )\n      {\n        int i;\n        for ( i = 0 ; i < p.nExpr ; i++ )\n        {\n          heightOfExpr( p.a[i].pExpr, ref pnHeight );\n        }\n      }\n    }\n    static void heightOfSelect( Select p, ref int pnHeight )\n    {\n      if ( p != null )\n      {\n        heightOfExpr( p.pWhere, ref  pnHeight );\n        heightOfExpr( p.pHaving, ref  pnHeight );\n        heightOfExpr( p.pLimit, ref  pnHeight );\n        heightOfExpr( p.pOffset, ref  pnHeight );\n        heightOfExprList( p.pEList, ref pnHeight );\n        heightOfExprList( p.pGroupBy, ref pnHeight );\n        heightOfExprList( p.pOrderBy, ref  pnHeight );\n        heightOfSelect( p.pPrior, ref  pnHeight );\n      }\n    }\n\n    /*\n    ** Set the Expr.nHeight variable in the structure passed as an\n    ** argument. An expression with no children, Expr.x.pList or\n    ** Expr.x.pSelect member has a height of 1. Any other expression\n    ** has a height equal to the maximum height of any other\n    ** referenced Expr plus one.\n    */\n    static void exprSetHeight( Expr p )\n    {\n      int nHeight = 0;\n      heightOfExpr( p.pLeft, ref nHeight );\n      heightOfExpr( p.pRight, ref nHeight );\n      if ( ExprHasProperty( p, EP_xIsSelect ) )\n      {\n        heightOfSelect( p.x.pSelect, ref nHeight );\n      }\n      else\n      {\n        heightOfExprList( p.x.pList, ref nHeight );\n      }\n      p.nHeight = nHeight + 1;\n    }\n\n    /*\n    ** Set the Expr.nHeight variable using the exprSetHeight() function. If\n    ** the height is greater than the maximum allowed expression depth,\n    ** leave an error in pParse.\n    */\n    static void sqlite3ExprSetHeight( Parse pParse, Expr p )\n    {\n      exprSetHeight( p );\n      sqlite3ExprCheckHeight( pParse, p.nHeight );\n    }\n\n    /*\n    ** Return the maximum height of any expression tree referenced\n    ** by the select statement passed as an argument.\n    */\n    static int sqlite3SelectExprHeight( Select p )\n    {\n      int nHeight = 0;\n      heightOfSelect( p, ref nHeight );\n      return nHeight;\n    }\n#else\n//#define exprSetHeight(y)\n#endif //* SQLITE_MAX_EXPR_DEPTH>0 */\n\n    /*\n** This routine is the core allocator for Expr nodes.\n**\n** Construct a new expression node and return a pointer to it.  Memory\n** for this node and for the pToken argument is a single allocation\n** obtained from sqlite3DbMalloc().  The calling function\n** is responsible for making sure the node eventually gets freed.\n**\n** If dequote is true, then the token (if it exists) is dequoted.\n** If dequote is false, no dequoting is performance.  The deQuote\n** parameter is ignored if pToken is NULL or if the token does not\n** appear to be quoted.  If the quotes were of the form "..." (double-quotes)\n** then the EP_DblQuoted flag is set on the expression node.\n**\n** Special case:  If op==TK_INTEGER and pToken points to a string that\n** can be translated into a 32-bit integer, then the token is not\n** stored in u.zToken.  Instead, the integer values is written\n** into u.iValue and the EP_IntValue flag is set.  No extra storage\n** is allocated to hold the integer text and the dequote flag is ignored.\n*/\n    static Expr sqlite3ExprAlloc(\n    sqlite3 db,           /* Handle for sqlite3DbMallocZero() (may be null) */\n    int op,               /* Expression opcode */\n    Token pToken,         /* Token argument.  Might be NULL */\n    int dequote           /* True to dequote */\n    )\n    {\n      Expr pNew;\n      int nExtra = 0;\n      int iValue = 0;\n\n      if ( pToken != null )\n      {\n        if ( op != TK_INTEGER || pToken.z == null || pToken.z.Length == 0\n        || sqlite3GetInt32( pToken.z.ToString(), ref iValue ) == false )\n        {\n          nExtra = pToken.n + 1;\n        }\n      }\n      pNew = new Expr();//sqlite3DbMallocZero(db, sizeof(Expr)+nExtra);\n      if ( pNew != null )\n      {\n        pNew.op = (u8)op;\n        pNew.iAgg = -1;\n        if ( pToken != null )\n        {\n          if ( nExtra == 0 )\n          {\n            pNew.flags |= EP_IntValue;\n            pNew.u.iValue = iValue;\n          }\n          else\n          {\n            int c;\n            //pNew.u.zToken = (char*)&pNew[1];\n            if ( pToken.n > 0 ) pNew.u.zToken = pToken.z.Substring( 0, pToken.n );//memcpy(pNew.u.zToken, pToken.z, pToken.n);\n            //pNew.u.zToken[pToken.n] = 0;\n            if ( dequote != 0 && nExtra >= 3\n            && ( ( c = pToken.z[0] ) == \'\\\'\' || c == \'"\' || c == \'[\' || c == \'`\' ) )\n            {\n#if DEBUG_CLASS_EXPR || DEBUG_CLASS_ALL\nsqlite3Dequote(ref pNew.u._zToken);\n#else\n              sqlite3Dequote( ref pNew.u.zToken );\n#endif\n              if ( c == \'"\' ) pNew.flags |= EP_DblQuoted;\n            }\n          }\n        }\n#if SQLITE_MAX_EXPR_DEPTH//>0\n        pNew.nHeight = 1;\n#endif\n      }\n      return pNew;\n    }\n\n    /*\n    ** Allocate a new expression node from a zero-terminated token that has\n    ** already been dequoted.\n    */\n    static Expr sqlite3Expr(\n    sqlite3 db,           /* Handle for sqlite3DbMallocZero() (may be null) */\n    int op,               /* Expression opcode */\n    string zToken         /* Token argument.  Might be NULL */\n    )\n    {\n      Token x = new Token();\n      x.z = zToken;\n      x.n = !String.IsNullOrEmpty( zToken ) ? sqlite3Strlen30( zToken ) : 0;\n      return sqlite3ExprAlloc( db, op, x, 0 );\n    }\n\n    /*\n    ** Attach subtrees pLeft and pRight to the Expr node pRoot.\n    **\n    ** If pRoot==NULL that means that a memory allocation error has occurred.\n    ** In that case, delete the subtrees pLeft and pRight.\n    */\n    static void sqlite3ExprAttachSubtrees(\n    sqlite3 db,\n    Expr pRoot,\n    Expr pLeft,\n    Expr pRight\n    )\n    {\n      if ( pRoot == null )\n      {\n        //Debug.Assert( db.mallocFailed != 0 );\n        sqlite3ExprDelete( db, ref pLeft );\n        sqlite3ExprDelete( db, ref pRight );\n      }\n      else\n      {\n        if ( pRight != null )\n        {\n          pRoot.pRight = pRight;\n          if ( ( pRight.flags & EP_ExpCollate ) != 0 )\n          {\n            pRoot.flags |= EP_ExpCollate;\n            pRoot.pColl = pRight.pColl;\n          }\n        }\n        if ( pLeft != null )\n        {\n          pRoot.pLeft = pLeft;\n          if ( ( pLeft.flags & EP_ExpCollate ) != 0 )\n          {\n            pRoot.flags |= EP_ExpCollate;\n            pRoot.pColl = pLeft.pColl;\n          }\n        }\n        exprSetHeight( pRoot );\n      }\n    }\n\n    /*\n    ** Allocate a Expr node which joins as many as two subtrees.\n    **\n    ** One or both of the subtrees can be NULL.  Return a pointer to the new\n    ** Expr node.  Or, if an OOM error occurs, set pParse->db->mallocFailed,\n    ** free the subtrees and return NULL.\n    */\n    // OVERLOADS, so I don\'t need to rewrite parse.c\n    static Expr sqlite3PExpr( Parse pParse, int op, int null_3, int null_4, int null_5 )\n    {\n      return sqlite3PExpr( pParse, op, null, null, null );\n    }\n    static Expr sqlite3PExpr( Parse pParse, int op, int null_3, int null_4, Token pToken )\n    {\n      return sqlite3PExpr( pParse, op, null, null, pToken );\n    }\n    static Expr sqlite3PExpr( Parse pParse, int op, Expr pLeft, int null_4, int null_5 )\n    {\n      return sqlite3PExpr( pParse, op, pLeft, null, null );\n    }\n    static Expr sqlite3PExpr( Parse pParse, int op, Expr pLeft, int null_4, Token pToken )\n    {\n      return sqlite3PExpr( pParse, op, pLeft, null, pToken );\n    }\n    static Expr sqlite3PExpr( Parse pParse, int op, Expr pLeft, Expr pRight, int null_5 )\n    {\n      return sqlite3PExpr( pParse, op, pLeft, pRight, null );\n    }\n    static Expr sqlite3PExpr(\n    Parse pParse,          /* Parsing context */\n    int op,                 /* Expression opcode */\n    Expr pLeft,            /* Left operand */\n    Expr pRight,           /* Right operand */\n    Token pToken     /* Argument Token */\n    )\n    {\n      Expr p = sqlite3ExprAlloc( pParse.db, op, pToken, 1 );\n      sqlite3ExprAttachSubtrees( pParse.db, p, pLeft, pRight );\n      return p;\n    }\n\n\n    /*\n    ** When doing a nested parse, you can include terms in an expression\n    ** that look like this:   #1 #2 ...  These terms refer to registers\n    ** in the virtual machine.  #N is the N-th register.\n    **\n    ** This routine is called by the parser to deal with on of those terms.\n    ** It immediately generates code to store the value in a memory location.\n    ** The returns an expression that will code to extract the value from\n    ** that memory location as needed.\n    */\n    static Expr sqlite3RegisterExpr( Parse pParse, Token pToken )\n    {\n      Vdbe v = pParse.pVdbe;\n      Expr p;\n      if ( pParse.nested == 0 )\n      {\n        sqlite3ErrorMsg( pParse, "near \\"%T\\": syntax error", pToken );\n        return sqlite3PExpr( pParse, TK_NULL, null, null, null );\n      }\n      if ( v == null ) return null;\n      p = sqlite3PExpr( pParse, TK_REGISTER, null, null, pToken );\n      if ( p == null )\n      {\n        return null;  /* Malloc failed */\n      }\n      p.u.iValue = atoi( pToken.z.Substring( 1 ) ); ;//atoi((char*)&pToken - z[1]);\n      return p;\n    }\n\n    /*\n    ** Join two expressions using an AND operator.  If either expression is\n    ** NULL, then just return the other expression.\n    */\n    static Expr sqlite3ExprAnd( sqlite3 db, Expr pLeft, Expr pRight )\n    {\n      if ( pLeft == null )\n      {\n        return pRight;\n      }\n      else if ( pRight == null )\n      {\n        return pLeft;\n      }\n      else\n      {\n        Expr pNew = sqlite3ExprAlloc( db, TK_AND, null, 0 );\n        sqlite3ExprAttachSubtrees( db, pNew, pLeft, pRight );\n        return pNew;\n      }\n    }\n\n    /*\n    ** Construct a new expression node for a function with multiple\n    ** arguments.\n    */\n    // OVERLOADS, so I don\'t need to rewrite parse.c\n    static Expr sqlite3ExprFunction( Parse pParse, int null_2, Token pToken )\n    {\n      return sqlite3ExprFunction( pParse, null, pToken );\n    }\n    static Expr sqlite3ExprFunction( Parse pParse, ExprList pList, int null_3 )\n    {\n      return sqlite3ExprFunction( pParse, pList, null );\n    }\n    static Expr sqlite3ExprFunction( Parse pParse, ExprList pList, Token pToken )\n    {\n      Expr pNew;\n      sqlite3 db = pParse.db;\n      Debug.Assert( pToken != null );\n      pNew = sqlite3ExprAlloc( db, TK_FUNCTION, pToken, 1 );\n      if ( pNew == null )\n      {\n        sqlite3ExprListDelete( db, ref pList ); /* Avoid memory leak when malloc fails */\n        return null;\n      }\n      pNew.x.pList = pList;\n      Debug.Assert( !ExprHasProperty( pNew, EP_xIsSelect ) );\n\n      sqlite3ExprSetHeight( pParse, pNew );\n      return pNew;\n    }\n\n    /*\n    ** Assign a variable number to an expression that encodes a wildcard\n    ** in the original SQL statement.\n    **\n    ** Wildcards consisting of a single "?" are assigned the next sequential\n    ** variable number.\n    **\n    ** Wildcards of the form "?nnn" are assigned the number "nnn".  We make\n    ** sure "nnn" is not too be to avoid a denial of service attack when\n    ** the SQL statement comes from an external source.\n    **\n    ** Wildcards of the form ":aaa", "@aaa" or "$aaa" are assigned the same number\n    ** as the previous instance of the same wildcard.  Or if this is the first\n    ** instance of the wildcard, the next sequenial variable number is\n    ** assigned.\n    */\n    static void sqlite3ExprAssignVarNumber( Parse pParse, Expr pExpr )\n    {\n      sqlite3 db = pParse.db;\n      string z;\n\n      if ( pExpr == null ) return;\n      Debug.Assert( !ExprHasAnyProperty( pExpr, EP_IntValue | EP_Reduced | EP_TokenOnly ) );\n      z = pExpr.u.zToken;\n      Debug.Assert( z != null );\n      Debug.Assert( z.Length != 0 );\n      if ( z.Length == 1 )\n      {\n        /* Wildcard of the form "?".  Assign the next variable number */\n        Debug.Assert( z[0] == \'?\' );\n        pExpr.iTable = ++pParse.nVar;\n      }\n      else if ( z[0] == \'?\' )\n      {\n        /* Wildcard of the form "?nnn".  Convert "nnn" to an integer and\n        ** use it as the variable number */\n        int i;\n        pExpr.iTable = i = atoi( z.Substring( 1 ) );//atoi((char*)&z[1]);\n        testcase( i == 0 );\n        testcase( i == 1 );\n        testcase( i == db.aLimit[SQLITE_LIMIT_VARIABLE_NUMBER] - 1 );\n        testcase( i == db.aLimit[SQLITE_LIMIT_VARIABLE_NUMBER] );\n        if ( i < 1 || i > db.aLimit[SQLITE_LIMIT_VARIABLE_NUMBER] )\n        {\n          sqlite3ErrorMsg( pParse, "variable number must be between ?1 and ?%d",\n          db.aLimit[SQLITE_LIMIT_VARIABLE_NUMBER] );\n        }\n        if ( i > pParse.nVar )\n        {\n          pParse.nVar = i;\n        }\n      }\n      else\n      {\n        /* Wildcards like ":aaa", "$aaa" or "@aaa".  Reuse the same variable\n        ** number as the prior appearance of the same name, or if the name\n        ** has never appeared before, reuse the same variable number\n        */\n        int i;\n        int n;\n        n = sqlite3Strlen30( z );\n        for ( i = 0 ; i < pParse.nVarExpr ; i++ )\n        {\n          Expr pE = pParse.apVarExpr[i];\n          Debug.Assert( pE != null );\n          if ( memcmp( pE.u.zToken, z, n ) == 0 && pE.u.zToken.Length == n )\n          {\n            pExpr.iTable = pE.iTable;\n            break;\n          }\n        }\n        if ( i >= pParse.nVarExpr )\n        {\n          pExpr.iTable = ++pParse.nVar;\n          if ( pParse.nVarExpr >= pParse.nVarExprAlloc - 1 )\n          {\n            pParse.nVarExprAlloc += pParse.nVarExprAlloc + 10;\n            pParse.apVarExpr = new Expr[pParse.nVarExprAlloc];\n            //sqlite3DbReallocOrFree(\n            //  db,\n            //  pParse.apVarExpr,\n            //  pParse.nVarExprAlloc*sizeof(pParse.apVarExpr[0])\n            //);\n          }\n          //if ( 0 == db.mallocFailed )\n          {\n            Debug.Assert( pParse.apVarExpr != null );\n            pParse.apVarExpr[pParse.nVarExpr++] = pExpr;\n          }\n        }\n      }\n      if ( pParse.nErr == 0 && pParse.nVar > db.aLimit[SQLITE_LIMIT_VARIABLE_NUMBER] )\n      {\n        sqlite3ErrorMsg( pParse, "too many SQL variables" );\n      }\n    }\n\n    /*\n    ** Clear an expression structure without deleting the structure itself.\n    ** Substructure is deleted.\n    */\n    static void sqlite3ExprClear( sqlite3 db, Expr p )\n    {\n      Debug.Assert( p != null );\n      if ( !ExprHasAnyProperty( p, EP_TokenOnly ) )\n      {\n        sqlite3ExprDelete( db, ref p.pLeft );\n        sqlite3ExprDelete( db, ref p.pRight );\n        if ( !ExprHasProperty( p, EP_Reduced ) && ( p.flags2 & EP2_MallocedToken ) != 0 )\n        {\n#if DEBUG_CLASS_EXPR || DEBUG_CLASS_ALL\n//sqlite3DbFree( db, ref p.u._zToken );\n#else\n          //sqlite3DbFree( db, ref p.u.zToken );\n#endif\n        }\n        if ( ExprHasProperty( p, EP_xIsSelect ) )\n        {\n          sqlite3SelectDelete( db, ref p.x.pSelect );\n        }\n        else\n        {\n          sqlite3ExprListDelete( db, ref p.x.pList );\n        }\n      }\n    }\n\n    /*\n    ** Recursively delete an expression tree.\n    */\n    static void sqlite3ExprDelete( sqlite3 db, ref Expr p )\n    {\n      if ( p == null ) return;\n      sqlite3ExprClear( db, p );\n      if ( !ExprHasProperty( p, EP_Static ) )\n      {\n        //sqlite3DbFree( db, ref p );\n      }\n    }\n\n    /*\n    ** Return the number of bytes allocated for the expression structure\n    ** passed as the first argument. This is always one of EXPR_FULLSIZE,\n    ** EXPR_REDUCEDSIZE or EXPR_TOKENONLYSIZE.\n    */\n    static int exprStructSize( Expr p )\n    {\n      if ( ExprHasProperty( p, EP_TokenOnly ) ) return EXPR_TOKENONLYSIZE;\n      if ( ExprHasProperty( p, EP_Reduced ) ) return EXPR_REDUCEDSIZE;\n      return EXPR_FULLSIZE;\n    }\n\n    /*\n    ** The dupedExpr*Size() routines each return the number of bytes required\n    ** to store a copy of an expression or expression tree.  They differ in\n    ** how much of the tree is measured.\n    **\n    **     dupedExprStructSize()     Size of only the Expr structure\n    **     dupedExprNodeSize()       Size of Expr + space for token\n    **     dupedExprSize()           Expr + token + subtree components\n    **\n    ***************************************************************************\n    **\n    ** The dupedExprStructSize() function returns two values OR-ed together:\n    ** (1) the space required for a copy of the Expr structure only and\n    ** (2) the EP_xxx flags that indicate what the structure size should be.\n    ** The return values is always one of:\n    **\n    **      EXPR_FULLSIZE\n    **      EXPR_REDUCEDSIZE   | EP_Reduced\n    **      EXPR_TOKENONLYSIZE | EP_TokenOnly\n    **\n    ** The size of the structure can be found by masking the return value\n    ** of this routine with 0xfff.  The flags can be found by masking the\n    ** return value with EP_Reduced|EP_TokenOnly.\n    **\n    ** Note that with flags==EXPRDUP_REDUCE, this routines works on full-size\n    ** (unreduced) Expr objects as they or originally constructed by the parser.\n    ** During expression analysis, extra information is computed and moved into\n    ** later parts of teh Expr object and that extra information might get chopped\n    ** off if the expression is reduced.  Note also that it does not work to\n    ** make a EXPRDUP_REDUCE copy of a reduced expression.  It is only legal\n    ** to reduce a pristine expression tree from the parser.  The implementation\n    ** of dupedExprStructSize() contain multiple assert() statements that attempt\n    ** to enforce this constraint.\n    */\n    static int dupedExprStructSize( Expr p, int flags )\n    {\n      int nSize;\n      Debug.Assert( flags == EXPRDUP_REDUCE || flags == 0 ); /* Only one flag value allowed */\n      if ( 0 == ( flags & EXPRDUP_REDUCE ) )\n      {\n        nSize = EXPR_FULLSIZE;\n      }\n      else\n      {\n        Debug.Assert( !ExprHasAnyProperty( p, EP_TokenOnly | EP_Reduced ) );\n        Debug.Assert( !ExprHasProperty( p, EP_FromJoin ) );\n        Debug.Assert( ( p.flags2 & EP2_MallocedToken ) == 0 );\n        Debug.Assert( ( p.flags2 & EP2_Irreducible ) == 0 );\n        if ( p.pLeft != null || p.pRight != null || p.pColl != null || p.x.pList != null || p.x.pSelect != null )\n        {\n          nSize = EXPR_REDUCEDSIZE | EP_Reduced;\n        }\n        else\n        {\n          nSize = EXPR_TOKENONLYSIZE | EP_TokenOnly;\n        }\n      }\n      return nSize;\n    }\n\n    /*\n    ** This function returns the space in bytes required to store the copy\n    ** of the Expr structure and a copy of the Expr.u.zToken string (if that\n    ** string is defined.)\n    */\n    static int dupedExprNodeSize( Expr p, int flags )\n    {\n      int nByte = dupedExprStructSize( p, flags ) & 0xfff;\n      if ( !ExprHasProperty( p, EP_IntValue ) && p.u.zToken != null )\n      {\n        nByte += sqlite3Strlen30( p.u.zToken ) + 1;\n      }\n      return ROUND8( nByte );\n    }\n\n    /*\n    ** Return the number of bytes required to create a duplicate of the\n    ** expression passed as the first argument. The second argument is a\n    ** mask containing EXPRDUP_XXX flags.\n    **\n    ** The value returned includes space to create a copy of the Expr struct\n    ** itself and the buffer referred to by Expr.u.zToken, if any.\n    **\n    ** If the EXPRDUP_REDUCE flag is set, then the return value includes\n    ** space to duplicate all Expr nodes in the tree formed by Expr.pLeft\n    ** and Expr.pRight variables (but not for any structures pointed to or\n    ** descended from the Expr.x.pList or Expr.x.pSelect variables).\n    */\n    static int dupedExprSize( Expr p, int flags )\n    {\n      int nByte = 0;\n      if ( p != null )\n      {\n        nByte = dupedExprNodeSize( p, flags );\n        if ( ( flags & EXPRDUP_REDUCE ) != 0 )\n        {\n          nByte += dupedExprSize( p.pLeft, flags ) + dupedExprSize( p.pRight, flags );\n        }\n      }\n      return nByte;\n    }\n\n    /*\n    ** This function is similar to sqlite3ExprDup(), except that if pzBuffer\n    ** is not NULL then *pzBuffer is assumed to point to a buffer large enough\n    ** to store the copy of expression p, the copies of p->u.zToken\n    ** (if applicable), and the copies of the p->pLeft and p->pRight expressions,\n    ** if any. Before returning, *pzBuffer is set to the first byte passed the\n    ** portion of the buffer copied into by this function.\n    */\n    static Expr exprDup( sqlite3 db, Expr p, int flags, ref Expr pzBuffer )\n    {\n      Expr pNew = null;                      /* Value to return */\n      if ( p != null )\n      {\n        bool isReduced = ( flags & EXPRDUP_REDUCE ) != 0;\n        Expr zAlloc = new Expr();\n        u32 staticFlag = 0;\n\n        Debug.Assert( pzBuffer == null || isReduced );\n\n        /* Figure out where to write the new Expr structure. */\n        //if ( pzBuffer !=null)\n        //{\n        //  zAlloc = pzBuffer;\n        //  staticFlag = EP_Static;\n        //}\n        //else\n        //{\n        //  zAlloc = new Expr();//sqlite3DbMallocRaw( db, dupedExprSize( p, flags ) );\n        //}\n        pNew = p.Copy_Minimal();// (Expr*)zAlloc;\n\n        if ( pNew != null )\n        {\n          /* Set nNewSize to the size allocated for the structure pointed to\n          ** by pNew. This is either EXPR_FULLSIZE, EXPR_REDUCEDSIZE or\n          ** EXPR_TOKENONLYSIZE. nToken is set to the number of bytes consumed\n          ** by the copy of the p->u.zToken string (if any).\n          */\n          int nStructSize = dupedExprStructSize( p, flags );\n          int nNewSize = nStructSize & 0xfff;\n          int nToken;\n          if ( !ExprHasProperty( p, EP_IntValue ) && !String.IsNullOrEmpty( p.u.zToken ) )\n          {\n            nToken = sqlite3Strlen30( p.u.zToken );\n          }\n          else\n          {\n            nToken = 0;\n          }\n          if ( isReduced )\n          {\n            Debug.Assert( !ExprHasProperty( p, EP_Reduced ) );\n            //memcpy( zAlloc, p, nNewSize );\n          }\n          else\n          {\n            int nSize = exprStructSize( p );\n            //memcpy( zAlloc, p, nSize );\n            //memset( &zAlloc[nSize], 0, EXPR_FULLSIZE - nSize );\n          }\n\n          /* Set the EP_Reduced, EP_TokenOnly, and EP_Static flags appropriately. */\n          unchecked { pNew.flags &= (ushort)( ~( EP_Reduced | EP_TokenOnly | EP_Static ) ); }\n          pNew.flags |= (ushort)( nStructSize & ( EP_Reduced | EP_TokenOnly ) );\n          pNew.flags |= (ushort)staticFlag;\n\n          /* Copy the p->u.zToken string, if any. */\n          if ( nToken != 0 )\n          {\n            string zToken;// = pNew.u.zToken = (char*)&zAlloc[nNewSize];\n            zToken = p.u.zToken.Substring( 0, nToken );// memcpy( zToken, p.u.zToken, nToken );\n          }\n\n          if ( 0 == ( ( p.flags | pNew.flags ) & EP_TokenOnly ) )\n          {\n            /* Fill in the pNew.x.pSelect or pNew.x.pList member. */\n            if ( ExprHasProperty( p, EP_xIsSelect ) )\n            {\n              pNew.x.pSelect = sqlite3SelectDup( db, p.x.pSelect, isReduced ? 1 : 0 );\n            }\n            else\n            {\n              pNew.x.pList = sqlite3ExprListDup( db, p.x.pList, isReduced ? 1 : 0 );\n            }\n          }\n\n          /* Fill in pNew.pLeft and pNew.pRight. */\n          if ( ExprHasAnyProperty( pNew, EP_Reduced | EP_TokenOnly ) )\n          {\n            //zAlloc += dupedExprNodeSize( p, flags );\n            if ( ExprHasProperty( pNew, EP_Reduced ) )\n            {\n              pNew.pLeft = exprDup( db, p.pLeft, EXPRDUP_REDUCE, ref zAlloc );\n              pNew.pRight = exprDup( db, p.pRight, EXPRDUP_REDUCE, ref zAlloc );\n            }\n            if ( pzBuffer != null )\n            {\n              pzBuffer = zAlloc;\n            }\n          }\n          else\n          {\n            pNew.flags2 = 0;\n            if ( !ExprHasAnyProperty( p, EP_TokenOnly ) )\n            {\n              pNew.pLeft = sqlite3ExprDup( db, p.pLeft, 0 );\n              pNew.pRight = sqlite3ExprDup( db, p.pRight, 0 );\n            }\n          }\n        }\n      }\n      return pNew;\n    }\n\n    /*\n    ** The following group of routines make deep copies of expressions,\n    ** expression lists, ID lists, and select statements.  The copies can\n    ** be deleted (by being passed to their respective ...Delete() routines)\n    ** without effecting the originals.\n    **\n    ** The expression list, ID, and source lists return by sqlite3ExprListDup(),\n    ** sqlite3IdListDup(), and sqlite3SrcListDup() can not be further expanded\n    ** by subsequent calls to sqlite*ListAppend() routines.\n    **\n    ** Any tables that the SrcList might point to are not duplicated.\n    **\n    ** The flags parameter contains a combination of the EXPRDUP_XXX flags.\n    ** If the EXPRDUP_REDUCE flag is set, then the structure returned is a\n    ** truncated version of the usual Expr structure that will be stored as\n    ** part of the in-memory representation of the database schema.\n    */\n    static Expr sqlite3ExprDup( sqlite3 db, Expr p, int flags )\n    {\n      Expr ExprDummy = null;\n      return exprDup( db, p, flags, ref ExprDummy );\n    }\n\n    static ExprList sqlite3ExprListDup( sqlite3 db, ExprList p, int flags )\n    {\n      ExprList pNew;\n      ExprList_item pItem;\n      ExprList_item pOldItem;\n      int i;\n      if ( p == null ) return null;\n      pNew = new ExprList();//sqlite3DbMallocRaw(db, sizeof(*pNew) );\n      if ( pNew == null ) return null;\n      pNew.iECursor = 0;\n      pNew.nExpr = pNew.nAlloc = p.nExpr;\n      pNew.a = new ExprList_item[p.nExpr];//sqlite3DbMallocRaw(db,  p.nExpr*sizeof(p.a[0]) );\n      //if( pItem==null ){\n      //  //sqlite3DbFree(db,ref pNew);\n      //  return null;\n      //}\n      //pOldItem = p.a;\n      for ( i = 0 ; i < p.nExpr ; i++ )\n      {//pItem++, pOldItem++){\n        pItem = pNew.a[i] = new ExprList_item();\n        pOldItem = p.a[i];\n        Expr pOldExpr = pOldItem.pExpr;\n        pItem.pExpr = sqlite3ExprDup( db, pOldExpr, flags );\n        pItem.zName = pOldItem.zName;// sqlite3DbStrDup(db, pOldItem.zName);\n        pItem.zSpan = pOldItem.zSpan;// sqlite3DbStrDup( db, pOldItem.zSpan );\n        pItem.sortOrder = pOldItem.sortOrder;\n        pItem.done = 0;\n        pItem.iCol = pOldItem.iCol;\n        pItem.iAlias = pOldItem.iAlias;\n      }\n      return pNew;\n    }\n\n    /*\n    ** If cursors, triggers, views and subqueries are all omitted from\n    ** the build, then none of the following routines, except for\n    ** sqlite3SelectDup(), can be called. sqlite3SelectDup() is sometimes\n    ** called with a NULL argument.\n    */\n#if !SQLITE_OMIT_VIEW || !SQLITE_OMIT_TRIGGER  || !SQLITE_OMIT_SUBQUERY\n    static SrcList sqlite3SrcListDup( sqlite3 db, SrcList p, int flags )\n    {\n      SrcList pNew;\n      int i;\n      int nByte;\n      if ( p == null ) return null;\n      //nByte = sizeof(*p) + (p.nSrc>0 ? sizeof(p.a[0]) * (p.nSrc-1) : 0);\n      pNew = new SrcList();//sqlite3DbMallocRaw(db, nByte );\n      if ( p.nSrc > 0 ) pNew.a = new SrcList_item[p.nSrc];\n      if ( pNew == null ) return null;\n      pNew.nSrc = pNew.nAlloc = p.nSrc;\n      for ( i = 0 ; i < p.nSrc ; i++ )\n      {\n        pNew.a[i] = new SrcList_item();\n        SrcList_item pNewItem = pNew.a[i];\n        SrcList_item pOldItem = p.a[i];\n        Table pTab;\n        pNewItem.zDatabase = pOldItem.zDatabase;// sqlite3DbStrDup(db, pOldItem.zDatabase);\n        pNewItem.zName = pOldItem.zName;// sqlite3DbStrDup(db, pOldItem.zName);\n        pNewItem.zAlias = pOldItem.zAlias;// sqlite3DbStrDup(db, pOldItem.zAlias);\n        pNewItem.jointype = pOldItem.jointype;\n        pNewItem.iCursor = pOldItem.iCursor;\n        pNewItem.isPopulated = pOldItem.isPopulated;\n        pNewItem.zIndex = pOldItem.zIndex;// sqlite3DbStrDup( db, pOldItem.zIndex );\n        pNewItem.notIndexed = pOldItem.notIndexed;\n        pNewItem.pIndex = pOldItem.pIndex;\n        pTab = pNewItem.pTab = pOldItem.pTab;\n        if ( pTab != null )\n        {\n          pTab.nRef++;\n        }\n        pNewItem.pSelect = sqlite3SelectDup( db, pOldItem.pSelect, flags );\n        pNewItem.pOn = sqlite3ExprDup( db, pOldItem.pOn, flags );\n        pNewItem.pUsing = sqlite3IdListDup( db, pOldItem.pUsing );\n        pNewItem.colUsed = pOldItem.colUsed;\n      }\n      return pNew;\n    }\n\n    static IdList sqlite3IdListDup( sqlite3 db, IdList p )\n    {\n      IdList pNew;\n      int i;\n      if ( p == null ) return null;\n      pNew = new IdList();//sqlite3DbMallocRaw(db, sizeof(*pNew) );\n      if ( pNew == null ) return null;\n      pNew.nId = pNew.nAlloc = p.nId;\n      pNew.a = new IdList_item[p.nId];//sqlite3DbMallocRaw(db, p.nId*sizeof(p.a[0]) );\n      if ( pNew.a == null )\n      {\n        //sqlite3DbFree( db, ref pNew );\n        return null;\n      }\n      for ( i = 0 ; i < p.nId ; i++ )\n      {\n        pNew.a[i] = new IdList_item();\n        IdList_item pNewItem = pNew.a[i];\n        IdList_item pOldItem = p.a[i];\n        pNewItem.zName = pOldItem.zName;// sqlite3DbStrDup(db, pOldItem.zName);\n        pNewItem.idx = pOldItem.idx;\n      }\n      return pNew;\n    }\n\n    static Select sqlite3SelectDup( sqlite3 db, Select p, int flags )\n    {\n      Select pNew;\n      if ( p == null ) return null;\n      pNew = new Select();//sqlite3DbMallocRaw(db, sizeof(*p) );\n      if ( pNew == null ) return null;\n      pNew.pEList = sqlite3ExprListDup( db, p.pEList, flags );\n      pNew.pSrc = sqlite3SrcListDup( db, p.pSrc, flags );\n      pNew.pWhere = sqlite3ExprDup( db, p.pWhere, flags );\n      pNew.pGroupBy = sqlite3ExprListDup( db, p.pGroupBy, flags );\n      pNew.pHaving = sqlite3ExprDup( db, p.pHaving, flags );\n      pNew.pOrderBy = sqlite3ExprListDup( db, p.pOrderBy, flags );\n      pNew.op = p.op;\n      pNew.pPrior = sqlite3SelectDup( db, p.pPrior, flags );\n      pNew.pLimit = sqlite3ExprDup( db, p.pLimit, flags );\n      pNew.pOffset = sqlite3ExprDup( db, p.pOffset, flags );\n      pNew.iLimit = 0;\n      pNew.iOffset = 0;\n      pNew.selFlags = (u16)( p.selFlags & ~SF_UsesEphemeral );\n      pNew.pRightmost = null;\n      pNew.addrOpenEphm[0] = -1;\n      pNew.addrOpenEphm[1] = -1;\n      pNew.addrOpenEphm[2] = -1;\n      return pNew;\n    }\n#else\nSelect sqlite3SelectDup(sqlite3 db, Select p, int flags){\nDebug.Assert( p==null );\nreturn null;\n}\n#endif\n\n\n    /*\n** Add a new element to the end of an expression list.  If pList is\n** initially NULL, then create a new expression list.\n**\n** If a memory allocation error occurs, the entire list is freed and\n** NULL is returned.  If non-NULL is returned, then it is guaranteed\n** that the new entry was successfully appended.\n*/\n    // OVERLOADS, so I don\'t need to rewrite parse.c\n    static ExprList sqlite3ExprListAppend( Parse pParse, int null_2, Expr pExpr )\n    {\n      return sqlite3ExprListAppend( pParse, null, pExpr );\n    }\n    static ExprList sqlite3ExprListAppend(\n    Parse pParse,          /* Parsing context */\n    ExprList pList,        /* List to which to append. Might be NULL */\n    Expr pExpr             /* Expression to be appended. Might be NULL */\n    )\n    {\n      sqlite3 db = pParse.db;\n      if ( pList == null )\n      {\n        pList = new ExprList();  //sqlite3DbMallocZero(db, ExprList).Length;\n        if ( pList == null )\n        {\n          goto no_mem;\n        }\n        Debug.Assert( pList.nAlloc == 0 );\n      }\n      if ( pList.nAlloc <= pList.nExpr )\n      {\n        ExprList_item a;\n        int n = pList.nAlloc * 2 + 4;\n        //a = sqlite3DbRealloc(db, pList.a, n*sizeof(pList.a[0]));\n        //if( a==0 ){\n        //  goto no_mem;\n        //}\n        Array.Resize( ref pList.a, n );// = a;\n        pList.nAlloc = pList.a.Length;// sqlite3DbMallocSize(db, a)/sizeof(a[0]);\n      }\n      Debug.Assert( pList.a != null );\n      if ( true )\n      {\n        pList.a[pList.nExpr] = new ExprList_item(); ;\n        ExprList_item pItem = pList.a[pList.nExpr++];\n        //pItem = new ExprList_item();//memset(pItem, 0, sizeof(*pItem));\n        pItem.pExpr = pExpr;\n      }\n      return pList;\n\nno_mem:\n      /* Avoid leaking memory if malloc has failed. */\n      sqlite3ExprDelete( db, ref pExpr );\n      sqlite3ExprListDelete( db, ref pList );\n      return null;\n    }\n\n    /*\n    ** Set the ExprList.a[].zName element of the most recently added item\n    ** on the expression list.\n    **\n    ** pList might be NULL following an OOM error.  But pName should never be\n    ** NULL.  If a memory allocation fails, the pParse.db.mallocFailed flag\n    ** is set.\n    */\n    static void sqlite3ExprListSetName(\n    Parse pParse,          /* Parsing context */\n    ExprList pList,        /* List to which to add the span. */\n    Token pName,           /* Name to be added */\n    int dequote            /* True to cause the name to be dequoted */\n    )\n    {\n      Debug.Assert( pList != null /* || pParse.db.mallocFailed != 0 */ );\n      if ( pList != null )\n      {\n        ExprList_item pItem;\n        Debug.Assert( pList.nExpr > 0 );\n        pItem = pList.a[pList.nExpr - 1];\n        Debug.Assert( pItem.zName == null );\n        pItem.zName = pName.z.Substring( 0, pName.n );//sqlite3DbStrNDup(pParse.db, pName.z, pName.n);\n        if ( dequote != 0 && !String.IsNullOrEmpty( pItem.zName ) ) sqlite3Dequote( ref pItem.zName );\n      }\n    }\n\n    /*\n    ** Set the ExprList.a[].zSpan element of the most recently added item\n    ** on the expression list.\n    **\n    ** pList might be NULL following an OOM error.  But pSpan should never be\n    ** NULL.  If a memory allocation fails, the pParse.db.mallocFailed flag\n    ** is set.\n    */\n    static void sqlite3ExprListSetSpan(\n    Parse pParse,          /* Parsing context */\n    ExprList pList,        /* List to which to add the span. */\n    ExprSpan pSpan         /* The span to be added */\n    )\n    {\n      sqlite3 db = pParse.db;\n      Debug.Assert( pList != null /*|| db.mallocFailed != 0 */ );\n      if ( pList != null )\n      {\n        ExprList_item pItem = pList.a[pList.nExpr - 1];\n        Debug.Assert( pList.nExpr > 0 );\n        Debug.Assert( /* db.mallocFailed != 0 || */ pItem.pExpr == pSpan.pExpr );\n        //sqlite3DbFree( db, pItem.zSpan );\n        pItem.zSpan = pSpan.zStart.Substring( 0, pSpan.zStart.Length <= pSpan.zEnd.Length ? pSpan.zStart.Length : pSpan.zStart.Length - pSpan.zEnd.Length );// sqlite3DbStrNDup( db, pSpan.zStart,\n        //(int)( pSpan.zEnd- pSpan.zStart) );\n      }\n    }\n\n    /*\n    ** If the expression list pEList contains more than iLimit elements,\n    ** leave an error message in pParse.\n    */\n    static void sqlite3ExprListCheckLength(\n    Parse pParse,\n    ExprList pEList,\n    string zObject\n    )\n    {\n      int mx = pParse.db.aLimit[SQLITE_LIMIT_COLUMN];\n      testcase( pEList != null && pEList.nExpr == mx );\n      testcase( pEList != null && pEList.nExpr == mx + 1 );\n      if ( pEList != null && pEList.nExpr > mx )\n      {\n        sqlite3ErrorMsg( pParse, "too many columns in %s", zObject );\n      }\n    }\n\n\n    /*\n    ** Delete an entire expression list.\n    */\n    static void sqlite3ExprListDelete( sqlite3 db, ref ExprList pList )\n    {\n      int i;\n      ExprList_item pItem;\n      if ( pList == null ) return;\n      Debug.Assert( pList.a != null || ( pList.nExpr == 0 && pList.nAlloc == 0 ) );\n      Debug.Assert( pList.nExpr <= pList.nAlloc );\n      for ( i = 0 ; i < pList.nExpr ; i++ )\n      {\n        if ( ( pItem = pList.a[i] ) != null )\n        {\n          sqlite3ExprDelete( db, ref pItem.pExpr );\n          //sqlite3DbFree( db, ref pItem.zName );\n          //sqlite3DbFree( db, ref pItem.zSpan );\n        }\n      }\n      //sqlite3DbFree( db, ref pList.a );\n      //sqlite3DbFree( db, ref pList );\n    }\n\n    /*\n    ** These routines are Walker callbacks.  Walker.u.pi is a pointer\n    ** to an integer.  These routines are checking an expression to see\n    ** if it is a constant.  Set *Walker.u.pi to 0 if the expression is\n    ** not constant.\n    **\n    ** These callback routines are used to implement the following:\n    **\n    **     sqlite3ExprIsConstant()\n    **     sqlite3ExprIsConstantNotJoin()\n    **     sqlite3ExprIsConstantOrFunction()\n    **\n    */\n    static int exprNodeIsConstant( Walker pWalker, ref Expr pExpr )\n    {\n      /* If pWalker.u.i is 3 then any term of the expression that comes from\n      ** the ON or USING clauses of a join disqualifies the expression\n      ** from being considered constant. */\n      if ( pWalker.u.i == 3 && ExprHasAnyProperty( pExpr, EP_FromJoin ) )\n      {\n        pWalker.u.i = 0;\n        return WRC_Abort;\n      }\n\n      switch ( pExpr.op )\n      {\n        /* Consider functions to be constant if all their arguments are constant\n        ** and pWalker.u.i==2 */\n        case TK_FUNCTION:\n          if ( ( pWalker.u.i ) == 2 ) return 0;\n          goto case TK_ID;\n        /* Fall through */\n        case TK_ID:\n        case TK_COLUMN:\n        case TK_AGG_FUNCTION:\n        case TK_AGG_COLUMN:\n          testcase( pExpr.op == TK_ID );\n          testcase( pExpr.op == TK_COLUMN );\n          testcase( pExpr.op == TK_AGG_FUNCTION );\n          testcase( pExpr.op == TK_AGG_COLUMN );\n          pWalker.u.i = 0;\n          return WRC_Abort;\n        default:\n          testcase( pExpr.op == TK_SELECT ); /* selectNodeIsConstant will disallow */\n          testcase( pExpr.op == TK_EXISTS ); /* selectNodeIsConstant will disallow */\n          return WRC_Continue;\n      }\n    }\n\n    static int selectNodeIsConstant( Walker pWalker, Select NotUsed )\n    {\n      UNUSED_PARAMETER( NotUsed );\n      pWalker.u.i = 0;\n      return WRC_Abort;\n    }\n    static int exprIsConst( Expr p, int initFlag )\n    {\n      Walker w = new Walker();\n      w.u.i = initFlag;\n      w.xExprCallback = exprNodeIsConstant;\n      w.xSelectCallback = selectNodeIsConstant;\n      sqlite3WalkExpr( w, ref p );\n      return w.u.i;\n    }\n\n    /*\n    ** Walk an expression tree.  Return 1 if the expression is constant\n    ** and 0 if it involves variables or function calls.\n    **\n    ** For the purposes of this function, a double-quoted string (ex: "abc")\n    ** is considered a variable but a single-quoted string (ex: \'abc\') is\n    ** a constant.\n    */\n    static int sqlite3ExprIsConstant( Expr p )\n    {\n      return exprIsConst( p, 1 );\n    }\n\n    /*\n    ** Walk an expression tree.  Return 1 if the expression is constant\n    ** that does no originate from the ON or USING clauses of a join.\n    ** Return 0 if it involves variables or function calls or terms from\n    ** an ON or USING clause.\n    */\n    static int sqlite3ExprIsConstantNotJoin( Expr p )\n    {\n      return exprIsConst( p, 3 );\n    }\n\n    /*\n    ** Walk an expression tree.  Return 1 if the expression is constant\n    ** or a function call with constant arguments.  Return and 0 if there\n    ** are any variables.\n    **\n    ** For the purposes of this function, a double-quoted string (ex: "abc")\n    ** is considered a variable but a single-quoted string (ex: \'abc\') is\n    ** a constant.\n    */\n    static int sqlite3ExprIsConstantOrFunction( Expr p )\n    {\n      return exprIsConst( p, 2 );\n    }\n\n    /*\n    ** If the expression p codes a constant integer that is small enough\n    ** to fit in a 32-bit integer, return 1 and put the value of the integer\n    ** in pValue.  If the expression is not an integer or if it is too big\n    ** to fit in a signed 32-bit integer, return 0 and leave pValue unchanged.\n    */\n    static int sqlite3ExprIsInteger( Expr p, ref int pValue )\n    {\n      int rc = 0;\n      if ( ( p.flags & EP_IntValue ) != 0 )\n      {\n        pValue = (int)p.u.iValue;\n        return 1;\n      }\n      switch ( p.op )\n      {\n        case TK_INTEGER:\n          {\n            rc = sqlite3GetInt32( p.u.zToken, ref pValue ) ? 1 : 0;\n            Debug.Assert( rc == 0 );\n            break;\n          }\n        case TK_UPLUS:\n          {\n            rc = sqlite3ExprIsInteger( p.pLeft, ref  pValue );\n            break;\n          }\n        case TK_UMINUS:\n          {\n            int v = 0;\n            if ( sqlite3ExprIsInteger( p.pLeft, ref v ) != 0 )\n            {\n              pValue = -v;\n              rc = 1;\n            }\n            break;\n          }\n        default: break;\n      }\n      if ( rc != 0 )\n      {\n        Debug.Assert( ExprHasAnyProperty( p, EP_Reduced | EP_TokenOnly )\n        || ( p.flags2 & EP2_MallocedToken ) == 0 );\n        p.op = TK_INTEGER;\n        p.flags |= EP_IntValue;\n        p.u.iValue = pValue;\n      }\n      return rc;\n    }\n\n    /*\n    ** Return TRUE if the given string is a row-id column name.\n    */\n    static bool sqlite3IsRowid( string z )\n    {\n      if ( sqlite3StrICmp( z, "_ROWID_" ) == 0 ) return true;\n      if ( sqlite3StrICmp( z, "ROWID" ) == 0 ) return true;\n      if ( sqlite3StrICmp( z, "OID" ) == 0 ) return true;\n      return false;\n    }\n\n\n    /*\n    ** Return true if we are able to the IN operator optimization on a\n    ** query of the form\n    **\n    **       x IN (SELECT ...)\n    **\n    ** Where the SELECT... clause is as specified by the parameter to this\n    ** routine.\n    **\n    ** The Select object passed in has already been preprocessed and no\n    ** errors have been found.\n    */\n#if !SQLITE_OMIT_SUBQUERY\n    static int isCandidateForInOpt( Select p )\n    {\n      SrcList pSrc;\n      ExprList pEList;\n      Table pTab;\n      if ( p == null ) return 0;                   /* right-hand side of IN is SELECT */\n      if ( p.pPrior != null ) return 0;              /* Not a compound SELECT */\n      if ( ( p.selFlags & ( SF_Distinct | SF_Aggregate ) ) != 0 )\n      {\n        testcase( ( p.selFlags & ( SF_Distinct | SF_Aggregate ) ) == SF_Distinct );\n        testcase( ( p.selFlags & ( SF_Distinct | SF_Aggregate ) ) == SF_Aggregate );\n        return 0; /* No DISTINCT keyword and no aggregate functions */\n      }\n      Debug.Assert( p.pGroupBy == null );         /* Has no GROUP BY clause */\n      if ( p.pLimit != null ) return 0;           /* Has no LIMIT clause */\n      Debug.Assert( p.pOffset == null );          /* No LIMIT means no OFFSET */\n\n      if ( p.pWhere != null ) return 0;           /* Has no WHERE clause */\n      pSrc = p.pSrc;\n      Debug.Assert( pSrc != null );\n      if ( pSrc.nSrc != 1 ) return 0;             /* Single term in FROM clause */\n      if ( pSrc.a[0].pSelect != null ) return 0;  /* FROM is not a subquery or view */\n      pTab = pSrc.a[0].pTab;\n      if ( NEVER( pTab == null ) ) return 0;\n      Debug.Assert( pTab.pSelect == null );       /* FROM clause is not a view */\n      if ( IsVirtual( pTab ) ) return 0;          /* FROM clause not a virtual table */\n      pEList = p.pEList;\n      if ( pEList.nExpr != 1 ) return 0;          /* One column in the result set */\n      if ( pEList.a[0].pExpr.op != TK_COLUMN ) return 0; /* Result is a column */\n      return 1;\n    }\n#endif //* SQLITE_OMIT_SUBQUERY */\n\n    /*\n** This function is used by the implementation of the IN (...) operator.\n** It\'s job is to find or create a b-tree structure that may be used\n** either to test for membership of the (...) set or to iterate through\n** its members, skipping duplicates.\n**\n** The index of the cursor opened on the b-tree (database table, database index\n** or ephermal table) is stored in pX->iTable before this function returns.\n** The returned value of this function indicates the b-tree type, as follows:\n**\n**   IN_INDEX_ROWID - The cursor was opened on a database table.\n**   IN_INDEX_INDEX - The cursor was opened on a database index.\n**   IN_INDEX_EPH -   The cursor was opened on a specially created and\n**                    populated epheremal table.\n**\n** An existing b-tree may only be used if the SELECT is of the simple\n** form:\n**\n**     SELECT <column> FROM <table>\n**\n** If the prNotFound parameter is 0, then the b-tree will be used to iterate\n** through the set members, skipping any duplicates. In this case an\n** epheremal table must be used unless the selected <column> is guaranteed\n** to be unique - either because it is an INTEGER PRIMARY KEY or it\n** has a UNIQUE constraint or UNIQUE index.\n**\n** If the prNotFound parameter is not 0, then the b-tree will be used\n** for fast set membership tests. In this case an epheremal table must\n** be used unless <column> is an INTEGER PRIMARY KEY or an index can\n** be found with <column> as its left-most column.\n**\n** When the b-tree is being used for membership tests, the calling function\n** needs to know whether or not the structure contains an SQL NULL\n** value in order to correctly evaluate expressions like "X IN (Y, Z)".\n** If there is a chance that the b-tree might contain a NULL value at\n** runtime, then a register is allocated and the register number written\n** to *prNotFound. If there is no chance that the b-tree contains a\n** NULL value, then *prNotFound is left unchanged.\n**\n** If a register is allocated and its location stored in *prNotFound, then\n** its initial value is NULL. If the b-tree does not remain constant\n** for the duration of the query (i.e. the SELECT that generates the b-tree\n** is a correlated subquery) then the value of the allocated register is\n** reset to NULL each time the b-tree is repopulated. This allows the\n** caller to use vdbe code equivalent to the following:\n**\n**   if( register==NULL ){\n**     has_null = <test if data structure contains null>\n**     register = 1\n**   }\n**\n** in order to avoid running the <test if data structure contains null>\n** test more often than is necessary.\n*/\n#if !SQLITE_OMIT_SUBQUERY\n    static int sqlite3FindInIndex( Parse pParse, Expr pX, ref int prNotFound )\n    {\n      Select p;                             /* SELECT to the right of IN operator */\n      int eType = 0;                        /* Type of RHS table. IN_INDEX_* */\n      int iTab = pParse.nTab++;             /* Cursor of the RHS table */\n      bool mustBeUnique = ( prNotFound != 0 );   /* True if RHS must be unique */\n\n      /* Check to see if an existing table or index can be used to\n      ** satisfy the query.  This is preferable to generating a new\n      ** ephemeral table.\n      */\n      p = ( ExprHasProperty( pX, EP_xIsSelect ) ? pX.x.pSelect : null );\n      if ( ALWAYS( pParse.nErr == 0 ) && isCandidateForInOpt( p ) != 0 )\n      {\n        sqlite3 db = pParse.db;               /* Database connection */\n        Expr pExpr = p.pEList.a[0].pExpr;     /* Expression <column> */\n        int iCol = pExpr.iColumn;             /* Index of column <column> */\n        Vdbe v = sqlite3GetVdbe( pParse );      /* Virtual machine being coded */\n        Table pTab = p.pSrc.a[0].pTab;        /* Table <table>. */\n        int iDb;                              /* Database idx for pTab */\n\n        /* Code an OP_VerifyCookie and OP_TableLock for <table>. */\n        iDb = sqlite3SchemaToIndex( db, pTab.pSchema );\n        sqlite3CodeVerifySchema( pParse, iDb );\n        sqlite3TableLock( pParse, iDb, pTab.tnum, 0, pTab.zName );\n\n        /* This function is only called from two places. In both cases the vdbe\n        ** has already been allocated. So assume sqlite3GetVdbe() is always\n        ** successful here.\n        */\n        Debug.Assert( v != null );\n        if ( iCol < 0 )\n        {\n          int iMem = ++pParse.nMem;\n          int iAddr;\n          sqlite3VdbeUsesBtree( v, iDb );\n\n          iAddr = sqlite3VdbeAddOp1( v, OP_If, iMem );\n          sqlite3VdbeAddOp2( v, OP_Integer, 1, iMem );\n\n          sqlite3OpenTable( pParse, iTab, iDb, pTab, OP_OpenRead );\n          eType = IN_INDEX_ROWID;\n\n          sqlite3VdbeJumpHere( v, iAddr );\n        }\n        else\n        {\n          Index pIdx;                         /* Iterator variable */\n          /* The collation sequence used by the comparison. If an index is to\n          ** be used in place of a temp.table, it must be ordered according\n          ** to this collation sequence. */\n          CollSeq pReq = sqlite3BinaryCompareCollSeq( pParse, pX.pLeft, pExpr );\n\n          /* Check that the affinity that will be used to perform the\n          ** comparison is the same as the affinity of the column. If\n          ** it is not, it is not possible to use any index.\n          */\n          char aff = comparisonAffinity( pX );\n          bool affinity_ok = ( pTab.aCol[iCol].affinity == aff || aff == SQLITE_AFF_NONE );\n\n          for ( pIdx = pTab.pIndex ; pIdx != null && eType == 0 && affinity_ok ; pIdx = pIdx.pNext )\n          {\n            if ( ( pIdx.aiColumn[0] == iCol )\n            && ( sqlite3FindCollSeq( db, ENC( db ), pIdx.azColl[0], 0 ) == pReq )\n            && ( mustBeUnique == false || ( pIdx.nColumn == 1 && pIdx.onError != OE_None ) )\n            )\n            {\n              int iMem = ++pParse.nMem;\n              int iAddr;\n              KeyInfo pKey;\n\n              pKey = sqlite3IndexKeyinfo( pParse, pIdx );\n              iDb = sqlite3SchemaToIndex( db, pIdx.pSchema );\n              sqlite3VdbeUsesBtree( v, iDb );\n\n              iAddr = sqlite3VdbeAddOp1( v, OP_If, iMem );\n              sqlite3VdbeAddOp2( v, OP_Integer, 1, iMem );\n\n              sqlite3VdbeAddOp4( v, OP_OpenRead, iTab, pIdx.tnum, iDb,\n              pKey, P4_KEYINFO_HANDOFF );\n#if SQLITE_DEBUG\n              VdbeComment( v, "%s", pIdx.zName );\n#endif\n              eType = IN_INDEX_INDEX;\n\n              sqlite3VdbeJumpHere( v, iAddr );\n              if ( //prNotFound != null &&         -- always exists under C#\n              pTab.aCol[iCol].notNull == 0 )\n              {\n                prNotFound = ++pParse.nMem;\n              }\n            }\n          }\n        }\n      }\n\n      if ( eType == 0 )\n      {\n        /* Could not found an existing able or index to use as the RHS b-tree.\n        ** We will have to generate an ephemeral table to do the job.\n        */\n        int rMayHaveNull = 0;\n        eType = IN_INDEX_EPH;\n        if ( prNotFound != -1 )  // Klude to show prNotFound not available\n        {\n          prNotFound = rMayHaveNull = ++pParse.nMem;\n        }\n        else\n          if ( pX.pLeft.iColumn < 0 && !ExprHasAnyProperty( pX, EP_xIsSelect ) )\n          {\n            eType = IN_INDEX_ROWID;\n          }\n        sqlite3CodeSubselect( pParse, pX, rMayHaveNull, eType == IN_INDEX_ROWID );\n      }\n      else\n      {\n        pX.iTable = iTab;\n      }\n      return eType;\n    }\n#endif\n\n    /*\n** Generate code for scalar subqueries used as an expression\n** and IN operators.  Examples:\n**\n**     (SELECT a FROM b)          -- subquery\n**     EXISTS (SELECT a FROM b)   -- EXISTS subquery\n**     x IN (4,5,11)              -- IN operator with list on right-hand side\n**     x IN (SELECT a FROM b)     -- IN operator with subquery on the right\n**\n** The pExpr parameter describes the expression that contains the IN\n** operator or subquery.\n**\n** If parameter isRowid is non-zero, then expression pExpr is guaranteed\n** to be of the form "<rowid> IN (?, ?, ?)", where <rowid> is a reference\n** to some integer key column of a table B-Tree. In this case, use an\n** intkey B-Tree to store the set of IN(...) values instead of the usual\n** (slower) variable length keys B-Tree.\n**\n** If rMayHaveNull is non-zero, that means that the operation is an IN\n** (not a SELECT or EXISTS) and that the RHS might contains NULLs.\n** Furthermore, the IN is in a WHERE clause and that we really want\n** to iterate over the RHS of the IN operator in order to quickly locate\n** all corresponding LHS elements.  All this routine does is initialize\n** the register given by rMayHaveNull to NULL.  Calling routines will take\n** care of changing this register value to non-NULL if the RHS is NULL-free.\n**\n** If rMayHaveNull is zero, that means that the subquery is being used\n** for membership testing only.  There is no need to initialize any\n** registers to indicate the presense or absence of NULLs on the RHS.\n*/\n#if !SQLITE_OMIT_SUBQUERY\n    static void sqlite3CodeSubselect(\n    Parse pParse,          /* Parsing context */\n    Expr pExpr,            /* The IN, SELECT, or EXISTS operator */\n    int rMayHaveNull,      /* Register that records whether NULLs exist in RHS */\n    bool isRowid           /* If true, LHS of IN operator is a rowid */\n    )\n    {\n      int testAddr = 0;                       /* One-time test address */\n      Vdbe v = sqlite3GetVdbe( pParse );\n      if ( NEVER( v == null ) ) return;\n      sqlite3ExprCachePush( pParse );\n\n      /* This code must be run in its entirety every time it is encountered\n      ** if any of the following is true:\n      **\n      **    *  The right-hand side is a correlated subquery\n      **    *  The right-hand side is an expression list containing variables\n      **    *  We are inside a trigger\n      **\n      ** If all of the above are false, then we can run this code just once\n      ** save the results, and reuse the same result on subsequent invocations.\n      */\n      if ( !ExprHasAnyProperty( pExpr, EP_VarSelect ) && null == pParse.trigStack )\n      {\n        int mem = ++pParse.nMem;\n        sqlite3VdbeAddOp1( v, OP_If, mem );\n        testAddr = sqlite3VdbeAddOp2( v, OP_Integer, 1, mem );\n        Debug.Assert( testAddr > 0 /* || pParse.db.mallocFailed != 0 */ );\n      }\n\n      switch ( pExpr.op )\n      {\n        case TK_IN:\n          {\n            char affinity;\n            KeyInfo keyInfo;\n            int addr;        /* Address of OP_OpenEphemeral instruction */\n            Expr pLeft = pExpr.pLeft;\n\n            if ( rMayHaveNull != 0 )\n            {\n              sqlite3VdbeAddOp2( v, OP_Null, 0, rMayHaveNull );\n            }\n\n            affinity = sqlite3ExprAffinity( pLeft );\n\n            /* Whether this is an \'x IN(SELECT...)\' or an \'x IN(<exprlist>)\'\n            ** expression it is handled the same way. A virtual table is\n            ** filled with single-field index keys representing the results\n            ** from the SELECT or the <exprlist>.\n            **\n            ** If the \'x\' expression is a column value, or the SELECT...\n            ** statement returns a column value, then the affinity of that\n            ** column is used to build the index keys. If both \'x\' and the\n            ** SELECT... statement are columns, then numeric affinity is used\n            ** if either column has NUMERIC or INTEGER affinity. If neither\n            ** \'x\' nor the SELECT... statement are columns, then numeric affinity\n            ** is used.\n            */\n            pExpr.iTable = pParse.nTab++;\n            addr = sqlite3VdbeAddOp2( v, OP_OpenEphemeral, (int)pExpr.iTable, !isRowid );\n            keyInfo = new KeyInfo();// memset( &keyInfo, 0, sizeof(keyInfo ));\n            keyInfo.nField = 1;\n\n            if ( ExprHasProperty( pExpr, EP_xIsSelect ) )\n            {\n              /* Case 1:     expr IN (SELECT ...)\n              **\n              ** Generate code to write the results of the select into the temporary\n              ** table allocated and opened above.\n              */\n              SelectDest dest = new SelectDest();\n              ExprList pEList;\n\n              Debug.Assert( !isRowid );\n              sqlite3SelectDestInit( dest, SRT_Set, pExpr.iTable );\n              dest.affinity = (char)affinity;\n              Debug.Assert( ( pExpr.iTable & 0x0000FFFF ) == pExpr.iTable );\n              if ( sqlite3Select( pParse, pExpr.x.pSelect, ref dest ) != 0 )\n              {\n                return;\n              }\n              pEList = pExpr.x.pSelect.pEList;\n              if ( ALWAYS( pEList != null ) && pEList.nExpr > 0 )\n              {\n                keyInfo.aColl[0] = sqlite3BinaryCompareCollSeq( pParse, pExpr.pLeft,\n                pEList.a[0].pExpr );\n              }\n            }\n            else if ( pExpr.x.pList != null )\n            {\n              /* Case 2:     expr IN (exprlist)\n              **\n              ** For each expression, build an index key from the evaluation and\n              ** store it in the temporary table. If <expr> is a column, then use\n              ** that columns affinity when building index keys. If <expr> is not\n              ** a column, use numeric affinity.\n              */\n              int i;\n              ExprList pList = pExpr.x.pList;\n              ExprList_item pItem;\n              int r1, r2, r3;\n\n              if ( affinity == \'\\0\' )\n              {\n                affinity = SQLITE_AFF_NONE;\n              }\n              keyInfo.aColl[0] = sqlite3ExprCollSeq( pParse, pExpr.pLeft );\n\n              /* Loop through each expression in <exprlist>. */\n              r1 = sqlite3GetTempReg( pParse );\n              r2 = sqlite3GetTempReg( pParse );\n              sqlite3VdbeAddOp2( v, OP_Null, 0, r2 );\n              for ( i = 0 ; i < pList.nExpr ; i++ )\n              {//, pItem++){\n                pItem = pList.a[i];\n                Expr pE2 = pItem.pExpr;\n\n                /* If the expression is not constant then we will need to\n                ** disable the test that was generated above that makes sure\n                ** this code only executes once.  Because for a non-constant\n                ** expression we need to rerun this code each time.\n                */\n                if ( testAddr != 0 && sqlite3ExprIsConstant( pE2 ) == 0 )\n                {\n                  sqlite3VdbeChangeToNoop( v, testAddr - 1, 2 );\n                  testAddr = 0;\n                }\n\n                /* Evaluate the expression and insert it into the temp table */\n                r3 = sqlite3ExprCodeTarget( pParse, pE2, r1 );\n                if ( isRowid )\n                {\n                  sqlite3VdbeAddOp2( v, OP_MustBeInt, r3, sqlite3VdbeCurrentAddr( v ) + 2 );\n                  sqlite3VdbeAddOp3( v, OP_Insert, pExpr.iTable, r2, r3 );\n                }\n                else\n                {\n                  sqlite3VdbeAddOp4( v, OP_MakeRecord, r3, 1, r2, affinity, 1 );\n                  sqlite3ExprCacheAffinityChange( pParse, r3, 1 );\n                  sqlite3VdbeAddOp2( v, OP_IdxInsert, pExpr.iTable, r2 );\n                }\n              }\n              sqlite3ReleaseTempReg( pParse, r1 );\n              sqlite3ReleaseTempReg( pParse, r2 );\n            }\n            if ( !isRowid )\n            {\n              sqlite3VdbeChangeP4( v, addr, keyInfo, P4_KEYINFO );\n            }\n            break;\n          }\n\n        case TK_EXISTS:\n        case TK_SELECT:\n        default:\n          {\n            /* If this has to be a scalar SELECT.  Generate code to put the\n            ** value of this select in a memory cell and record the number\n            ** of the memory cell in iColumn.  If this is an EXISTS, write\n            ** an integer 0 (not exists) or 1 (exists) into a memory cell\n            ** and record that memory cell in iColumn.\n            */\n            Token one = new Token( "1", 1 );    /* Token for literal value 1 */\n            Select pSel;                        /* SELECT statement to encode */\n            SelectDest dest = new SelectDest(); /* How to deal with SELECt result */\n\n            testcase( pExpr.op == TK_EXISTS );\n            testcase( pExpr.op == TK_SELECT );\n            Debug.Assert( pExpr.op == TK_EXISTS || pExpr.op == TK_SELECT );\n\n            Debug.Assert( ExprHasProperty( pExpr, EP_xIsSelect ) );\n            pSel = pExpr.x.pSelect;\n            sqlite3SelectDestInit( dest, 0, ++pParse.nMem );\n            if ( pExpr.op == TK_SELECT )\n            {\n              dest.eDest = SRT_Mem;\n              sqlite3VdbeAddOp2( v, OP_Null, 0, dest.iParm );\n#if SQLITE_DEBUG\n              VdbeComment( v, "Init subquery result" );\n#endif\n            }\n            else\n            {\n              dest.eDest = SRT_Exists;\n              sqlite3VdbeAddOp2( v, OP_Integer, 0, dest.iParm );\n#if SQLITE_DEBUG\n              VdbeComment( v, "Init EXISTS result" );\n#endif\n            }\n            sqlite3ExprDelete( pParse.db, ref pSel.pLimit );\n            pSel.pLimit = sqlite3PExpr( pParse, TK_INTEGER, null, null, one );\n            if ( sqlite3Select( pParse, pSel, ref dest ) != 0 )\n            {\n              return;\n            }\n            pExpr.iColumn = (short)dest.iParm;\n            ExprSetIrreducible( pExpr );\n            break;\n          }\n      }\n\n      if ( testAddr != 0 )\n      {\n        sqlite3VdbeJumpHere( v, testAddr - 1 );\n      }\n      sqlite3ExprCachePop( pParse, 1 );\n\n      return;\n    }\n#endif // * SQLITE_OMIT_SUBQUERY */\n\n    /*\n** Duplicate an 8-byte value\n*/\n    //static char *dup8bytes(Vdbe v, const char *in){\n    //  char *out = sqlite3DbMallocRaw(sqlite3VdbeDb(v), 8);\n    //  if( out ){\n    //    memcpy(out, in, 8);\n    //  }\n    //  return out;\n    //}\n\n    /*\n    ** Generate an instruction that will put the floating point\n    ** value described by z[0..n-1] into register iMem.\n    **\n    ** The z[] string will probably not be zero-terminated.  But the\n    ** z[n] character is guaranteed to be something that does not look\n    ** like the continuation of the number.\n    */\n    static void codeReal( Vdbe v, string z, bool negateFlag, int iMem )\n    {\n      if ( ALWAYS( !String.IsNullOrEmpty( z ) ) )\n      {\n        double value = 0;\n        //char *zV;\n        sqlite3AtoF( z, ref value );\n        if ( sqlite3IsNaN( value ) )\n        {\n          sqlite3VdbeAddOp2( v, OP_Null, 0, iMem );\n        }\n        else\n        {\n          if ( negateFlag ) value = -value;\n          //zV = dup8bytes(v,  value);\n          sqlite3VdbeAddOp4( v, OP_Real, 0, iMem, 0, value, P4_REAL );\n        }\n      }\n    }\n\n    /*\n    ** Generate an instruction that will put the integer describe by\n    ** text z[0..n-1] into register iMem.\n    **\n    ** The z[] string will probably not be zero-terminated.  But the\n    ** z[n] character is guaranteed to be something that does not look\n    ** like the continuation of the number.\n    */\n    static void codeInteger( Vdbe v, Expr pExpr, bool negFlag, int iMem )\n    {\n      if ( ( pExpr.flags & EP_IntValue ) != 0 )\n      {\n        int i = pExpr.u.iValue;\n        if ( negFlag ) i = -i;\n        sqlite3VdbeAddOp2( v, OP_Integer, i, iMem );\n      }\n      else\n      {\n        string z = pExpr.u.zToken;\n        Debug.Assert( !String.IsNullOrEmpty( z ) );\n        if ( sqlite3FitsIn64Bits( z, negFlag ) )\n        {\n          i64 value = 0;\n          //string zV;\n          sqlite3Atoi64( negFlag ? "-" + z : z, ref value );\n          //if ( negFlag ) value = -value;\n          //zV = dup8bytes( v, (char*)&value );\n          //sqlite3VdbeAddOp4( v, OP_Int64, 0, iMem, 0, zV, P4_INT64 );\n          sqlite3VdbeAddOp4( v, OP_Int64, 0, iMem, 0, value, P4_INT64 );\n        }\n        else\n        {\n          codeReal( v, z, negFlag, iMem );\n        }\n      }\n    }\n\n    /*\n    ** Clear a cache entry.\n    */\n    static void cacheEntryClear( Parse pParse, yColCache p )\n    {\n      if ( p.tempReg != 0 )\n      {\n        if ( pParse.nTempReg < ArraySize( pParse.aTempReg ) )\n        {\n          pParse.aTempReg[pParse.nTempReg++] = p.iReg;\n        }\n        p.tempReg = 0;\n      }\n    }\n\n\n    /*\n    ** Record in the column cache that a particular column from a\n    ** particular table is stored in a particular register.\n    */\n    static void sqlite3ExprCacheStore( Parse pParse, int iTab, int iCol, int iReg )\n    {\n      int i;\n      int minLru;\n      int idxLru;\n      yColCache p;\n\n      Debug.Assert( iReg > 0 );  /* Register numbers are always positive */\n      Debug.Assert( iCol >= -1 && iCol < 32768 );  /* Finite column numbers */\n\n      /* First replace any existing entry */\n      for ( i = 0 ; i < SQLITE_N_COLCACHE ; i++ )//p=pParse.aColCache... p++)\n      {\n        p = pParse.aColCache[i];\n        if ( p.iReg != 0 && p.iTable == iTab && p.iColumn == iCol )\n        {\n          cacheEntryClear( pParse, p );\n          p.iLevel = pParse.iCacheLevel;\n          p.iReg = iReg;\n          p.affChange = false;\n          p.lru = pParse.iCacheCnt++;\n          return;\n        }\n      }\n\n      /* Find an empty slot and replace it */\n      for ( i = 0 ; i < SQLITE_N_COLCACHE ; i++ )//p=pParse.aColCache... p++)\n      {\n        p = pParse.aColCache[i];\n        if ( p.iReg == 0 )\n        {\n          p.iLevel = pParse.iCacheLevel;\n          p.iTable = iTab;\n          p.iColumn = iCol;\n          p.iReg = iReg;\n          p.affChange = false;\n          p.tempReg = 0;\n          p.lru = pParse.iCacheCnt++;\n          return;\n        }\n      }\n\n      /* Replace the last recently used */\n      minLru = 0x7fffffff;\n      idxLru = -1;\n      for ( i = 0 ; i < SQLITE_N_COLCACHE ; i++ )//p=pParse.aColCache..., p++)\n      {\n        p = pParse.aColCache[i];\n        if ( p.lru < minLru )\n        {\n          idxLru = i;\n          minLru = p.lru;\n        }\n      }\n      if ( ALWAYS( idxLru >= 0 ) )\n      {\n        p = pParse.aColCache[idxLru];\n        p.iLevel = pParse.iCacheLevel;\n        p.iTable = iTab;\n        p.iColumn = iCol;\n        p.iReg = iReg;\n        p.affChange = false;\n        p.tempReg = 0;\n        p.lru = pParse.iCacheCnt++;\n        return;\n      }\n    }\n\n    /*\n    ** Indicate that a register is being overwritten.  Purge the register\n    ** from the column cache.\n    */\n    static void sqlite3ExprCacheRemove( Parse pParse, int iReg )\n    {\n      int i;\n      yColCache p;\n      for ( i = 0 ; i < SQLITE_N_COLCACHE ; i++ )//p=pParse.aColCache... p++)\n      {\n        p = pParse.aColCache[i];\n        if ( p.iReg == iReg )\n        {\n          cacheEntryClear( pParse, p );\n          p.iReg = 0;\n        }\n      }\n    }\n\n    /*\n    ** Remember the current column cache context.  Any new entries added\n    ** added to the column cache after this call are removed when the\n    ** corresponding pop occurs.\n    */\n    static void sqlite3ExprCachePush( Parse pParse )\n    {\n      pParse.iCacheLevel++;\n    }\n\n    /*\n    ** Remove from the column cache any entries that were added since the\n    ** the previous N Push operations.  In other words, restore the cache\n    ** to the state it was in N Pushes ago.\n    */\n    static void sqlite3ExprCachePop( Parse pParse, int N )\n    {\n      int i;\n      yColCache p;\n      Debug.Assert( N > 0 );\n      Debug.Assert( pParse.iCacheLevel >= N );\n      pParse.iCacheLevel -= N;\n      for ( i = 0 ; i < SQLITE_N_COLCACHE ; i++ )// p++)\n      {\n        p = pParse.aColCache[i];\n        if ( p.iReg != 0 && p.iLevel > pParse.iCacheLevel )\n        {\n          cacheEntryClear( pParse, p );\n          p.iReg = 0;\n        }\n      }\n    }\n\n    /*\n    ** When a cached column is reused, make sure that its register is\n    ** no longer available as a temp register.  ticket #3879:  that same\n    ** register might be in the cache in multiple places, so be sure to\n    ** get them all.\n    */\n    static void sqlite3ExprCachePinRegister( Parse pParse, int iReg )\n    {\n      int i;\n      yColCache p;\n      for ( i = 0 ; i < SQLITE_N_COLCACHE ; i++ )//p=pParse->aColCache; i<SQLITE_N_COLCACHE; i++, p++)\n      {\n        p = pParse.aColCache[i];\n        if ( p.iReg == iReg )\n        {\n          p.tempReg = 0;\n        }\n      }\n    }\n\n    /*\n    ** Generate code that will extract the iColumn-th column from\n    ** table pTab and store the column value in a register.  An effort\n    ** is made to store the column value in register iReg, but this is\n    ** not guaranteed.  The location of the column value is returned.\n    **\n    ** There must be an open cursor to pTab in iTable when this routine\n    ** is called.  If iColumn<0 then code is generated that extracts the rowid.\n    **\n    ** This routine might attempt to reuse the value of the column that\n    ** has already been loaded into a register.  The value will always\n    ** be used if it has not undergone any affinity changes.  But if\n    ** an affinity change has occurred, then the cached value will only be\n    ** used if allowAffChng is true.\n    */\n    static int sqlite3ExprCodeGetColumn(\n    Parse pParse,     /* Parsing and code generating context */\n    Table pTab,       /* Description of the table we are reading from */\n    int iColumn,      /* Index of the table column */\n    int iTable,       /* The cursor pointing to the table */\n    int iReg,         /* Store results here */\n    bool allowAffChng /* True if prior affinity changes are OK */\n    )\n    {\n      Vdbe v = pParse.pVdbe;\n      int i;\n      yColCache p;\n\n      for ( i = 0 ; i < SQLITE_N_COLCACHE ; i++ )\n      {// p=pParse.aColCache, p++\n        p = pParse.aColCache[i];\n        if ( p.iReg > 0 && p.iTable == iTable && p.iColumn == iColumn\n        && ( !p.affChange || allowAffChng ) )\n        {\n          p.lru = pParse.iCacheCnt++;\n          sqlite3ExprCachePinRegister( pParse, p.iReg );\n          return p.iReg;\n        }\n      }\n      Debug.Assert( v != null );\n      if ( iColumn < 0 )\n      {\n        sqlite3VdbeAddOp2( v, OP_Rowid, iTable, iReg );\n      }\n      else if ( ALWAYS( pTab != null ) )\n      {\n        int op = IsVirtual( pTab ) ? OP_VColumn : OP_Column;\n        sqlite3VdbeAddOp3( v, op, iTable, iColumn, iReg );\n        sqlite3ColumnDefault( v, pTab, iColumn, iReg );\n      }\n      sqlite3ExprCacheStore( pParse, iTable, iColumn, iReg );\n      return iReg;\n    }\n\n    /*\n    ** Clear all column cache entries.\n    */\n    static void sqlite3ExprCacheClear( Parse pParse )\n    {\n      int i;\n      yColCache p;\n\n      for ( i = 0 ; i < SQLITE_N_COLCACHE ; i++ )// p=pParse.aColCache... p++)\n      {\n        p = pParse.aColCache[i];\n        if ( p.iReg != 0 )\n        {\n          cacheEntryClear( pParse, p );\n          p.iReg = 0;\n        }\n      }\n    }\n\n    /*\n    ** Record the fact that an affinity change has occurred on iCount\n    ** registers starting with iStart.\n    */\n    static void sqlite3ExprCacheAffinityChange( Parse pParse, int iStart, int iCount )\n    {\n      int iEnd = iStart + iCount - 1;\n      int i;\n      yColCache p;\n      for ( i = 0 ; i < SQLITE_N_COLCACHE ; i++ )// p=pParse.aColCache... p++)\n      {\n        p = pParse.aColCache[i];\n        int r = p.iReg;\n        if ( r >= iStart && r <= iEnd )\n        {\n          p.affChange = true;\n        }\n      }\n    }\n\n    /*\n    ** Generate code to move content from registers iFrom...iFrom+nReg-1\n    ** over to iTo..iTo+nReg-1. Keep the column cache up-to-date.\n    */\n    static void sqlite3ExprCodeMove( Parse pParse, int iFrom, int iTo, int nReg )\n    {\n      int i;\n      yColCache p;\n      if ( NEVER( iFrom == iTo ) ) return;\n      sqlite3VdbeAddOp3( pParse.pVdbe, OP_Move, iFrom, iTo, nReg );\n      for ( i = 0 ; i < SQLITE_N_COLCACHE ; i++ )// p=pParse.aColCache... p++)\n      {\n        p = pParse.aColCache[i];\n        int x = p.iReg;\n        if ( x >= iFrom && x < iFrom + nReg )\n        {\n          p.iReg += iTo - iFrom;\n        }\n      }\n    }\n\n    /*\n    ** Generate code to copy content from registers iFrom...iFrom+nReg-1\n    ** over to iTo..iTo+nReg-1.\n    */\n    static void sqlite3ExprCodeCopy( Parse pParse, int iFrom, int iTo, int nReg )\n    {\n      int i;\n      if ( NEVER( iFrom == iTo ) ) return;\n      for ( i = 0 ; i < nReg ; i++ )\n      {\n        sqlite3VdbeAddOp2( pParse.pVdbe, OP_Copy, iFrom + i, iTo + i );\n      }\n    }\n\n    /*\n    ** Return true if any register in the range iFrom..iTo (inclusive)\n    ** is used as part of the column cache.\n    */\n    static int usedAsColumnCache( Parse pParse, int iFrom, int iTo )\n    {\n      int i;\n      yColCache p;\n      for ( i = 0 ; i < SQLITE_N_COLCACHE ; i++ )//p=pParse.aColCache... p++)\n      {\n        p = pParse.aColCache[i];\n        int r = p.iReg;\n        if ( r >= iFrom && r <= iTo ) return 1;\n      }\n      return 0;\n    }\n\n\n    /*\n    ** If the last instruction coded is an ephemeral copy of any of\n    ** the registers in the nReg registers beginning with iReg, then\n    ** convert the last instruction from OP_SCopy to OP_Copy.\n    */\n    static void sqlite3ExprHardCopy( Parse pParse, int iReg, int nReg )\n    {\n      VdbeOp pOp;\n      Vdbe v;\n\n      //Debug.Assert( pParse.db.mallocFailed == 0 );\n      v = pParse.pVdbe;\n      Debug.Assert( v != null );\n      pOp = sqlite3VdbeGetOp( v, -1 );\n      Debug.Assert( pOp != null );\n      if ( pOp.opcode == OP_SCopy && pOp.p1 >= iReg && pOp.p1 < iReg + nReg )\n      {\n        pOp.opcode = OP_Copy;\n      }\n    }\n\n    /*\n    ** Generate code to store the value of the iAlias-th alias in register\n    ** target.  The first time this is called, pExpr is evaluated to compute\n    ** the value of the alias.  The value is stored in an auxiliary register\n    ** and the number of that register is returned.  On subsequent calls,\n    ** the register number is returned without generating any code.\n    **\n    ** Note that in order for this to work, code must be generated in the\n    ** same order that it is executed.\n    **\n    ** Aliases are numbered starting with 1.  So iAlias is in the range\n    ** of 1 to pParse.nAlias inclusive.\n    **\n    ** pParse.aAlias[iAlias-1] records the register number where the value\n    ** of the iAlias-th alias is stored.  If zero, that means that the\n    ** alias has not yet been computed.\n    */\n    static int codeAlias( Parse pParse, int iAlias, Expr pExpr, int target )\n    {\n#if FALSE\nsqlite3 db = pParse.db;\nint iReg;\nif ( pParse.nAliasAlloc < pParse.nAlias )\n{\npParse.aAlias = new int[pParse.nAlias]; //sqlite3DbReallocOrFree(db, pParse.aAlias,\n//sizeof(pParse.aAlias[0])*pParse.nAlias );\ntestcase( db.mallocFailed != 0 && pParse.nAliasAlloc > 0 );\nif ( db.mallocFailed != 0 ) return 0;\n//memset(&pParse.aAlias[pParse.nAliasAlloc], 0,\n//       (pParse.nAlias-pParse.nAliasAlloc)*sizeof(pParse.aAlias[0]));\npParse.nAliasAlloc = pParse.nAlias;\n}\nDebug.Assert( iAlias > 0 && iAlias <= pParse.nAlias );\niReg = pParse.aAlias[iAlias - 1];\nif ( iReg == 0 )\n{\nif ( pParse.iCacheLevel != 0 )\n{\niReg = sqlite3ExprCodeTarget( pParse, pExpr, target );\n}\nelse\n{\niReg = ++pParse.nMem;\nsqlite3ExprCode( pParse, pExpr, iReg );\npParse.aAlias[iAlias - 1] = iReg;\n}\n}\nreturn iReg;\n#else\n      UNUSED_PARAMETER( iAlias );\n      return sqlite3ExprCodeTarget( pParse, pExpr, target );\n#endif\n    }\n\n    /*\n    ** Generate code into the current Vdbe to evaluate the given\n    ** expression.  Attempt to store the results in register "target".\n    ** Return the register where results are stored.\n    **\n    ** With this routine, there is no guarantee  that results will\n    ** be stored in target.  The result might be stored in some other\n    ** register if it is convenient to do so.  The calling function\n    ** must check the return code and move the results to the desired\n    ** register.\n    */\n    static int sqlite3ExprCodeTarget( Parse pParse, Expr pExpr, int target )\n    {\n      Vdbe v = pParse.pVdbe;    /* The VM under construction */\n      int op;                   /* The opcode being coded */\n      int inReg = target;       /* Results stored in register inReg */\n      int regFree1 = 0;         /* If non-zero free this temporary register */\n      int regFree2 = 0;         /* If non-zero free this temporary register */\n      int r1 = 0, r2 = 0, r3 = 0, r4 = 0;       /* Various register numbers */\n      sqlite3 db = pParse.db; /* The database connection */\n\n      Debug.Assert( target > 0 && target <= pParse.nMem );\n      if ( v == null )\n      {\n        //Debug.Assert( pParse.db.mallocFailed != 0 );\n        return 0;\n      }\n\n      if ( pExpr == null )\n      {\n        op = TK_NULL;\n      }\n      else\n      {\n        op = pExpr.op;\n      }\n      switch ( op )\n      {\n        case TK_AGG_COLUMN:\n          {\n            AggInfo pAggInfo = pExpr.pAggInfo;\n            AggInfo_col pCol = pAggInfo.aCol[pExpr.iAgg];\n            if ( pAggInfo.directMode == 0 )\n            {\n              Debug.Assert( pCol.iMem > 0 );\n              inReg = pCol.iMem;\n              break;\n            }\n            else if ( pAggInfo.useSortingIdx != 0 )\n            {\n              sqlite3VdbeAddOp3( v, OP_Column, pAggInfo.sortingIdx,\n              pCol.iSorterColumn, target );\n              break;\n            }\n            /* Otherwise, fall thru into the TK_COLUMN case */\n          }\n          goto case TK_COLUMN;\n        case TK_COLUMN:\n          {\n            if ( pExpr.iTable < 0 )\n            {\n              /* This only happens when coding check constraints */\n              Debug.Assert( pParse.ckBase > 0 );\n              inReg = pExpr.iColumn + pParse.ckBase;\n            }\n            else\n            {\n              testcase( ( pExpr.flags & EP_AnyAff ) != 0 );\n              inReg = sqlite3ExprCodeGetColumn( pParse, pExpr.pTab,\n              pExpr.iColumn, pExpr.iTable, target,\n              ( pExpr.flags & EP_AnyAff ) != 0 );\n            }\n            break;\n          }\n        case TK_INTEGER:\n          {\n            codeInteger( v, pExpr, false, target );\n            break;\n          }\n        case TK_FLOAT:\n          {\n            Debug.Assert( !ExprHasProperty( pExpr, EP_IntValue ) );\n            codeReal( v, pExpr.u.zToken, false, target );\n            break;\n          }\n        case TK_STRING:\n          {\n            Debug.Assert( !ExprHasProperty( pExpr, EP_IntValue ) );\n            sqlite3VdbeAddOp4( v, OP_String8, 0, target, 0, pExpr.u.zToken, 0 );\n            break;\n          }\n        case TK_NULL:\n          {\n            sqlite3VdbeAddOp2( v, OP_Null, 0, target );\n            break;\n          }\n#if !SQLITE_OMIT_BLOB_LITERAL\n        case TK_BLOB:\n          {\n            int n;\n            string z;\n            byte[] zBlob;\n            Debug.Assert( !ExprHasProperty( pExpr, EP_IntValue ) );\n            Debug.Assert( pExpr.u.zToken[0] == \'x\' || pExpr.u.zToken[0] == \'X\' );\n            Debug.Assert( pExpr.u.zToken[1] == \'\\\'\' );\n            z = pExpr.u.zToken.Substring( 2 );\n            n = sqlite3Strlen30( z ) - 1;\n            Debug.Assert( z[n] == \'\\\'\' );\n            zBlob = sqlite3HexToBlob( sqlite3VdbeDb( v ), z, n );\n            sqlite3VdbeAddOp4( v, OP_Blob, n / 2, target, 0, zBlob, P4_DYNAMIC );\n            break;\n          }\n#endif\n        case TK_VARIABLE:\n          {\n            VdbeOp pOp;\n            Debug.Assert( !ExprHasProperty( pExpr, EP_IntValue ) );\n            Debug.Assert( pExpr.u.zToken != null );\n            Debug.Assert( pExpr.u.zToken.Length != 0 );\n            if ( pExpr.u.zToken.Length == 1\n            && ( pOp = sqlite3VdbeGetOp( v, -1 ) ).opcode == OP_Variable\n            && pOp.p1 + pOp.p3 == pExpr.iTable\n            && pOp.p2 + pOp.p3 == target\n            && pOp.p4.z == null\n            )\n            {\n              /* If the previous instruction was a copy of the previous unnamed\n              ** parameter into the previous register, then simply increment the\n              ** repeat count on the prior instruction rather than making a new\n              ** instruction.\n              */\n              pOp.p3++;\n            }\n            else\n            {\n              sqlite3VdbeAddOp3( v, OP_Variable, pExpr.iTable, target, 1 );\n              if ( pExpr.u.zToken.Length > 1 )\n              {\n                sqlite3VdbeChangeP4( v, -1, pExpr.u.zToken, 0 );\n              }\n            }\n            break;\n          }\n        case TK_REGISTER:\n          {\n            inReg = pExpr.iTable;\n            break;\n          }\n        case TK_AS:\n          {\n            inReg = codeAlias( pParse, pExpr.iTable, pExpr.pLeft, target );\n            break;\n          }\n#if !SQLITE_OMIT_CAST\n        case TK_CAST:\n          {\n            /* Expressions of the form:   CAST(pLeft AS token) */\n            int aff, to_op;\n            inReg = sqlite3ExprCodeTarget( pParse, pExpr.pLeft, target );\n            Debug.Assert( !ExprHasProperty( pExpr, EP_IntValue ) );\n            aff = sqlite3AffinityType( pExpr.u.zToken );\n            to_op = aff - SQLITE_AFF_TEXT + OP_ToText;\n            Debug.Assert( to_op == OP_ToText || aff != SQLITE_AFF_TEXT );\n            Debug.Assert( to_op == OP_ToBlob || aff != SQLITE_AFF_NONE );\n            Debug.Assert( to_op == OP_ToNumeric || aff != SQLITE_AFF_NUMERIC );\n            Debug.Assert( to_op == OP_ToInt || aff != SQLITE_AFF_INTEGER );\n            Debug.Assert( to_op == OP_ToReal || aff != SQLITE_AFF_REAL );\n            testcase( to_op == OP_ToText );\n            testcase( to_op == OP_ToBlob );\n            testcase( to_op == OP_ToNumeric );\n            testcase( to_op == OP_ToInt );\n            testcase( to_op == OP_ToReal );\n            if ( inReg != target )\n            {\n              sqlite3VdbeAddOp2( v, OP_SCopy, inReg, target );\n              inReg = target;\n            }\n            sqlite3VdbeAddOp1( v, to_op, inReg );\n            testcase( usedAsColumnCache( pParse, inReg, inReg ) != 0 );\n            sqlite3ExprCacheAffinityChange( pParse, inReg, 1 );\n            break;\n          }\n#endif // * SQLITE_OMIT_CAST */\n        case TK_LT:\n        case TK_LE:\n        case TK_GT:\n        case TK_GE:\n        case TK_NE:\n        case TK_EQ:\n          {\n            Debug.Assert( TK_LT == OP_Lt );\n            Debug.Assert( TK_LE == OP_Le );\n            Debug.Assert( TK_GT == OP_Gt );\n            Debug.Assert( TK_GE == OP_Ge );\n            Debug.Assert( TK_EQ == OP_Eq );\n            Debug.Assert( TK_NE == OP_Ne );\n            testcase( op == TK_LT );\n            testcase( op == TK_LE );\n            testcase( op == TK_GT );\n            testcase( op == TK_GE );\n            testcase( op == TK_EQ );\n            testcase( op == TK_NE );\n            codeCompareOperands( pParse, pExpr.pLeft, ref r1, ref regFree1,\n            pExpr.pRight, ref r2, ref regFree2 );\n            codeCompare( pParse, pExpr.pLeft, pExpr.pRight, op,\n            r1, r2, inReg, SQLITE_STOREP2 );\n            testcase( regFree1 == 0 );\n            testcase( regFree2 == 0 );\n            break;\n          }\n        case TK_AND:\n        case TK_OR:\n        case TK_PLUS:\n        case TK_STAR:\n        case TK_MINUS:\n        case TK_REM:\n        case TK_BITAND:\n        case TK_BITOR:\n        case TK_SLASH:\n        case TK_LSHIFT:\n        case TK_RSHIFT:\n        case TK_CONCAT:\n          {\n            Debug.Assert( TK_AND == OP_And );\n            Debug.Assert( TK_OR == OP_Or );\n            Debug.Assert( TK_PLUS == OP_Add );\n            Debug.Assert( TK_MINUS == OP_Subtract );\n            Debug.Assert( TK_REM == OP_Remainder );\n            Debug.Assert( TK_BITAND == OP_BitAnd );\n            Debug.Assert( TK_BITOR == OP_BitOr );\n            Debug.Assert( TK_SLASH == OP_Divide );\n            Debug.Assert( TK_LSHIFT == OP_ShiftLeft );\n            Debug.Assert( TK_RSHIFT == OP_ShiftRight );\n            Debug.Assert( TK_CONCAT == OP_Concat );\n            testcase( op == TK_AND );\n            testcase( op == TK_OR );\n            testcase( op == TK_PLUS );\n            testcase( op == TK_MINUS );\n            testcase( op == TK_REM );\n            testcase( op == TK_BITAND );\n            testcase( op == TK_BITOR );\n            testcase( op == TK_SLASH );\n            testcase( op == TK_LSHIFT );\n            testcase( op == TK_RSHIFT );\n            testcase( op == TK_CONCAT );\n            r1 = sqlite3ExprCodeTemp( pParse, pExpr.pLeft, ref regFree1 );\n            r2 = sqlite3ExprCodeTemp( pParse, pExpr.pRight, ref regFree2 );\n            sqlite3VdbeAddOp3( v, op, r2, r1, target );\n            testcase( regFree1 == 0 );\n            testcase( regFree2 == 0 );\n            break;\n          }\n        case TK_UMINUS:\n          {\n            Expr pLeft = pExpr.pLeft;\n            Debug.Assert( pLeft != null );\n            if ( pLeft.op == TK_FLOAT )\n            {\n              Debug.Assert( !ExprHasProperty( pExpr, EP_IntValue ) );\n              codeReal( v, pLeft.u.zToken, true, target );\n            }\n            else if ( pLeft.op == TK_INTEGER )\n            {\n              codeInteger( v, pLeft, true, target );\n            }\n            else\n            {\n              regFree1 = r1 = sqlite3GetTempReg( pParse );\n              sqlite3VdbeAddOp2( v, OP_Integer, 0, r1 );\n              r2 = sqlite3ExprCodeTemp( pParse, pExpr.pLeft, ref regFree2 );\n              sqlite3VdbeAddOp3( v, OP_Subtract, r2, r1, target );\n              testcase( regFree2 == 0 );\n            }\n            inReg = target;\n            break;\n          }\n        case TK_BITNOT:\n        case TK_NOT:\n          {\n            Debug.Assert( TK_BITNOT == OP_BitNot );\n            Debug.Assert( TK_NOT == OP_Not );\n            testcase( op == TK_BITNOT );\n            testcase( op == TK_NOT );\n            r1 = sqlite3ExprCodeTemp( pParse, pExpr.pLeft, ref regFree1 );\n            testcase( regFree1 == 0 );\n            inReg = target;\n            sqlite3VdbeAddOp2( v, op, r1, inReg );\n            break;\n          }\n        case TK_ISNULL:\n        case TK_NOTNULL:\n          {\n            int addr;\n            Debug.Assert( TK_ISNULL == OP_IsNull );\n            Debug.Assert( TK_NOTNULL == OP_NotNull );\n            testcase( op == TK_ISNULL );\n            testcase( op == TK_NOTNULL );\n            sqlite3VdbeAddOp2( v, OP_Integer, 1, target );\n            r1 = sqlite3ExprCodeTemp( pParse, pExpr.pLeft, ref regFree1 );\n            testcase( regFree1 == 0 );\n            addr = sqlite3VdbeAddOp1( v, op, r1 );\n            sqlite3VdbeAddOp2( v, OP_AddImm, target, -1 );\n            sqlite3VdbeJumpHere( v, addr );\n            break;\n          }\n        case TK_AGG_FUNCTION:\n          {\n            AggInfo pInfo = pExpr.pAggInfo;\n            if ( pInfo == null )\n            {\n              Debug.Assert( !ExprHasProperty( pExpr, EP_IntValue ) );\n              sqlite3ErrorMsg( pParse, "misuse of aggregate: %s()", pExpr.u.zToken );\n            }\n            else\n            {\n              inReg = pInfo.aFunc[pExpr.iAgg].iMem;\n            }\n            break;\n          }\n        case TK_CONST_FUNC:\n        case TK_FUNCTION:\n          {\n            ExprList pFarg;        /* List of function arguments */\n            int nFarg;             /* Number of function arguments */\n            FuncDef pDef;          /* The function definition object */\n            int nId;               /* Length of the function name in bytes */\n            string zId;            /* The function name */\n            int constMask = 0;     /* Mask of function arguments that are constant */\n            int i;                 /* Loop counter */\n            u8 enc = ENC( db );    /* The text encoding used by this database */\n            CollSeq pColl = null;  /* A collating sequence */\n\n            Debug.Assert( !ExprHasProperty( pExpr, EP_xIsSelect ) );\n            testcase( op == TK_CONST_FUNC );\n            testcase( op == TK_FUNCTION );\n            if ( ExprHasAnyProperty( pExpr, EP_TokenOnly ) )\n            {\n              pFarg = null;\n            }\n            else\n            {\n              pFarg = pExpr.x.pList;\n            }\n            nFarg = pFarg != null ? pFarg.nExpr : 0;\n            Debug.Assert( !ExprHasProperty( pExpr, EP_IntValue ) );\n            zId = pExpr.u.zToken;\n            nId = sqlite3Strlen30( zId );\n            pDef = sqlite3FindFunction( pParse.db, zId, nId, nFarg, enc, 0 );\n            Debug.Assert( pDef != null );\n            if ( pFarg != null )\n            {\n              r1 = sqlite3GetTempRange( pParse, nFarg );\n              sqlite3ExprCodeExprList( pParse, pFarg, r1, true );\n            }\n            else\n            {\n              r1 = 0;\n            }\n#if !SQLITE_OMIT_VIRTUALTABLE\n/* Possibly overload the function if the first argument is\n** a virtual table column.\n**\n** For infix functions (LIKE, GLOB, REGEXP, and MATCH) use the\n** second argument, not the first, as the argument to test to\n** see if it is a column in a virtual table.  This is done because\n** the left operand of infix functions (the operand we want to\n** control overloading) ends up as the second argument to the\n** function.  The expression "A glob B" is equivalent to\n** "glob(B,A).  We want to use the A in "A glob B" to test\n** for function overloading.  But we use the B term in "glob(B,A)".\n*/\nif ( nFarg >= 2 && ( pExpr.flags & EP_InfixFunc ) )\n{\npDef = sqlite3VtabOverloadFunction( db, pDef, nFarg, pFarg.a[1].pExpr );\n}\nelse if ( nFarg > 0 )\n{\npDef = sqlite3VtabOverloadFunction( db, pDef, nFarg, pFarg.a[0].pExpr );\n}\n#endif\n            for ( i = 0 ; i < nFarg ; i++ )\n            {\n              if ( i < 32 && sqlite3ExprIsConstant( pFarg.a[i].pExpr ) != 0 )\n              {\n                constMask |= ( 1 << i );\n              }\n              if ( ( pDef.flags & SQLITE_FUNC_NEEDCOLL ) != 0 && null == pColl )\n              {\n                pColl = sqlite3ExprCollSeq( pParse, pFarg.a[i].pExpr );\n              }\n            }\n            if ( ( pDef.flags & SQLITE_FUNC_NEEDCOLL ) != 0 )\n            {\n              if ( null == pColl ) pColl = db.pDfltColl;\n              sqlite3VdbeAddOp4( v, OP_CollSeq, 0, 0, 0, pColl, P4_COLLSEQ );\n            }\n            sqlite3VdbeAddOp4( v, OP_Function, constMask, r1, target,\n            pDef, P4_FUNCDEF );\n            sqlite3VdbeChangeP5( v, (u8)nFarg );\n            if ( nFarg != 0 )\n            {\n              sqlite3ReleaseTempRange( pParse, r1, nFarg );\n            }\n            sqlite3ExprCacheAffinityChange( pParse, r1, nFarg );\n            break;\n          }\n#if !SQLITE_OMIT_SUBQUERY\n        case TK_EXISTS:\n        case TK_SELECT:\n          {\n            testcase( op == TK_EXISTS );\n            testcase( op == TK_SELECT );\n            sqlite3CodeSubselect( pParse, pExpr, 0, false );\n            inReg = pExpr.iColumn;\n            break;\n          }\n        case TK_IN:\n          {\n            int rNotFound = 0;\n            int rMayHaveNull = 0;\n            int j2, j3, j4, j5;\n            char affinity;\n            int eType;\n\n            VdbeNoopComment( v, "begin IN expr r%d", target );\n            eType = sqlite3FindInIndex( pParse, pExpr, ref rMayHaveNull );\n            if ( rMayHaveNull != 0 )\n            {\n              rNotFound = ++pParse.nMem;\n            }\n\n            /* Figure out the affinity to use to create a key from the results\n            ** of the expression. affinityStr stores a static string suitable for\n            ** P4 of OP_MakeRecord.\n            */\n            affinity = comparisonAffinity( pExpr );\n\n            /* Code the <expr> from "<expr> IN (...)". The temporary table\n            ** pExpr.iTable contains the values that make up the (...) set.\n            */\n            sqlite3ExprCachePush( pParse );\n            sqlite3ExprCode( pParse, pExpr.pLeft, target );\n            j2 = sqlite3VdbeAddOp1( v, OP_IsNull, target );\n            if ( eType == IN_INDEX_ROWID )\n            {\n              j3 = sqlite3VdbeAddOp1( v, OP_MustBeInt, target );\n              j4 = sqlite3VdbeAddOp3( v, OP_NotExists, pExpr.iTable, 0, target );\n              sqlite3VdbeAddOp2( v, OP_Integer, 1, target );\n              j5 = sqlite3VdbeAddOp0( v, OP_Goto );\n              sqlite3VdbeJumpHere( v, j3 );\n              sqlite3VdbeJumpHere( v, j4 );\n              sqlite3VdbeAddOp2( v, OP_Integer, 0, target );\n            }\n            else\n            {\n              r2 = regFree2 = sqlite3GetTempReg( pParse );\n\n              /* Create a record and test for set membership. If the set contains\n              ** the value, then jump to the end of the test code. The target\n              ** register still contains the true (1) value written to it earlier.\n              */\n              sqlite3VdbeAddOp4( v, OP_MakeRecord, target, 1, r2, affinity, 1 );\n              sqlite3VdbeAddOp2( v, OP_Integer, 1, target );\n              j5 = sqlite3VdbeAddOp3( v, OP_Found, pExpr.iTable, 0, r2 );\n\n              /* If the set membership test fails, then the result of the\n              ** "x IN (...)" expression must be either 0 or NULL. If the set\n              ** contains no NULL values, then the result is 0. If the set\n              ** contains one or more NULL values, then the result of the\n              ** expression is also NULL.\n              */\n              if ( rNotFound == 0 )\n              {\n                /* This branch runs if it is known at compile time (now) that\n                ** the set contains no NULL values. This happens as the result\n                ** of a "NOT NULL" constraint in the database schema. No need\n                ** to test the data structure at runtime in this case.\n                */\n                sqlite3VdbeAddOp2( v, OP_Integer, 0, target );\n              }\n              else\n              {\n                /* This block populates the rNotFound register with either NULL\n                ** or 0 (an integer value). If the data structure contains one\n                ** or more NULLs, then set rNotFound to NULL. Otherwise, set it\n                ** to 0. If register rMayHaveNull is already set to some value\n                ** other than NULL, then the test has already been run and\n                ** rNotFound is already populated.\n                */\n                byte[] nullRecord = { 0x02, 0x00 };\n                j3 = sqlite3VdbeAddOp1( v, OP_NotNull, rMayHaveNull );\n                sqlite3VdbeAddOp2( v, OP_Null, 0, rNotFound );\n                sqlite3VdbeAddOp4( v, OP_Blob, 2, rMayHaveNull, 0,\n                nullRecord, P4_STATIC );\n                j4 = sqlite3VdbeAddOp3( v, OP_Found, pExpr.iTable, 0, rMayHaveNull );\n                sqlite3VdbeAddOp2( v, OP_Integer, 0, rNotFound );\n                sqlite3VdbeJumpHere( v, j4 );\n                sqlite3VdbeJumpHere( v, j3 );\n\n                /* Copy the value of register rNotFound (which is either NULL or 0)\n                ** into the target register. This will be the result of the\n                ** expression.\n                */\n                sqlite3VdbeAddOp2( v, OP_Copy, rNotFound, target );\n              }\n            }\n            sqlite3VdbeJumpHere( v, j2 );\n            sqlite3VdbeJumpHere( v, j5 );\n            sqlite3ExprCachePop( pParse, 1 );\n            VdbeComment( v, "end IN expr r%d", target );\n            break;\n          }\n#endif\n        /*\n**    x BETWEEN y AND z\n**\n** This is equivalent to\n**\n**    x>=y AND x<=z\n**\n** X is stored in pExpr.pLeft.\n** Y is stored in pExpr.x.pList.a[0].pExpr.\n** Z is stored in pExpr.x.pList.a[1].pExpr.\n*/\n        case TK_BETWEEN:\n          {\n            Expr pLeft = pExpr.pLeft;\n            ExprList_item pLItem = pExpr.x.pList.a[0];\n            Expr pRight = pLItem.pExpr;\n            codeCompareOperands( pParse, pLeft, ref r1, ref regFree1,\n            pRight, ref r2, ref regFree2 );\n\n            testcase( regFree1 == 0 );\n            testcase( regFree2 == 0 );\n            r3 = sqlite3GetTempReg( pParse );\n            r4 = sqlite3GetTempReg( pParse );\n            codeCompare( pParse, pLeft, pRight, OP_Ge,\n            r1, r2, r3, SQLITE_STOREP2 );\n            pLItem = pExpr.x.pList.a[1];// pLItem++;\n            pRight = pLItem.pExpr;\n            sqlite3ReleaseTempReg( pParse, regFree2 );\n            r2 = sqlite3ExprCodeTemp( pParse, pRight, ref regFree2 );\n            testcase( regFree2 == 0 );\n            codeCompare( pParse, pLeft, pRight, OP_Le, r1, r2, r4, SQLITE_STOREP2 );\n            sqlite3VdbeAddOp3( v, OP_And, r3, r4, target );\n            sqlite3ReleaseTempReg( pParse, r3 );\n            sqlite3ReleaseTempReg( pParse, r4 );\n            break;\n          }\n        case TK_UPLUS:\n          {\n            inReg = sqlite3ExprCodeTarget( pParse, pExpr.pLeft, target );\n            break;\n          }\n\n        /*\n        ** Form A:\n        **   CASE x WHEN e1 THEN r1 WHEN e2 THEN r2 ... WHEN eN THEN rN ELSE y END\n        **\n        ** Form B:\n        **   CASE WHEN e1 THEN r1 WHEN e2 THEN r2 ... WHEN eN THEN rN ELSE y END\n        **\n        ** Form A is can be transformed into the equivalent form B as follows:\n        **   CASE WHEN x=e1 THEN r1 WHEN x=e2 THEN r2 ...\n        **        WHEN x=eN THEN rN ELSE y END\n        **\n        ** X (if it exists) is in pExpr.pLeft.\n        ** Y is in pExpr.pRight.  The Y is also optional.  If there is no\n        ** ELSE clause and no other term matches, then the result of the\n        ** exprssion is NULL.\n        ** Ei is in pExpr.x.pList.a[i*2] and Ri is pExpr.x.pList.a[i*2+1].\n        **\n        ** The result of the expression is the Ri for the first matching Ei,\n        ** or if there is no matching Ei, the ELSE term Y, or if there is\n        ** no ELSE term, NULL.\n        */\n        default: Debug.Assert( op == TK_CASE );\n          {\n            int endLabel;                     /* GOTO label for end of CASE stmt */\n            int nextCase;                     /* GOTO label for next WHEN clause */\n            int nExpr;                        /* 2x number of WHEN terms */\n            int i;                            /* Loop counter */\n            ExprList pEList;                  /* List of WHEN terms */\n            ExprList_item[] aListelem;        /* Array of WHEN terms */\n            Expr opCompare = new Expr();      /* The X==Ei expression */\n            Expr cacheX;                      /* Cached expression X */\n            Expr pX;                          /* The X expression */\n            Expr pTest = null;                /* X==Ei (form A) or just Ei (form B) */\n#if !NDEBUG\n            int iCacheLevel = pParse.iCacheLevel;\n            //VVA_ONLY( int iCacheLevel = pParse.iCacheLevel; )\n#endif\n            Debug.Assert( !ExprHasProperty( pExpr, EP_xIsSelect ) && pExpr.x.pList != null );\n            Debug.Assert( ( pExpr.x.pList.nExpr % 2 ) == 0 );\n            Debug.Assert( pExpr.x.pList.nExpr > 0 );\n            pEList = pExpr.x.pList;\n            aListelem = pEList.a;\n            nExpr = pEList.nExpr;\n            endLabel = sqlite3VdbeMakeLabel( v );\n            if ( ( pX = pExpr.pLeft ) != null )\n            {\n              cacheX = pX;\n              testcase( pX.op == TK_COLUMN );\n              testcase( pX.op == TK_REGISTER );\n              cacheX.iTable = sqlite3ExprCodeTemp( pParse, pX, ref regFree1 );\n              testcase( regFree1 == 0 );\n              cacheX.op = TK_REGISTER;\n              opCompare.op = TK_EQ;\n              opCompare.pLeft = cacheX;\n              pTest = opCompare;\n            }\n            for ( i = 0 ; i < nExpr ; i = i + 2 )\n            {\n              sqlite3ExprCachePush( pParse );\n              if ( pX != null )\n              {\n                Debug.Assert( pTest != null );\n                opCompare.pRight = aListelem[i].pExpr;\n              }\n              else\n              {\n                pTest = aListelem[i].pExpr;\n              }\n              nextCase = sqlite3VdbeMakeLabel( v );\n              testcase( pTest.op == TK_COLUMN );\n              sqlite3ExprIfFalse( pParse, pTest, nextCase, SQLITE_JUMPIFNULL );\n              testcase( aListelem[i + 1].pExpr.op == TK_COLUMN );\n              testcase( aListelem[i + 1].pExpr.op == TK_REGISTER );\n              sqlite3ExprCode( pParse, aListelem[i + 1].pExpr, target );\n              sqlite3VdbeAddOp2( v, OP_Goto, 0, endLabel );\n              sqlite3ExprCachePop( pParse, 1 );\n              sqlite3VdbeResolveLabel( v, nextCase );\n            }\n            if ( pExpr.pRight != null )\n            {\n              sqlite3ExprCachePush( pParse );\n              sqlite3ExprCode( pParse, pExpr.pRight, target );\n              sqlite3ExprCachePop( pParse, 1 );\n            }\n            else\n            {\n              sqlite3VdbeAddOp2( v, OP_Null, 0, target );\n            }\n#if !NDEBUG\n            Debug.Assert( /* db.mallocFailed != 0 || */ pParse.nErr > 0\n            || pParse.iCacheLevel == iCacheLevel );\n#endif\n            sqlite3VdbeResolveLabel( v, endLabel );\n            break;\n          }\n#if !SQLITE_OMIT_TRIGGER\n        case TK_RAISE:\n          {\n            if ( pParse.trigStack == null )\n            {\n              sqlite3ErrorMsg( pParse,\n              "RAISE() may only be used within a trigger-program" );\n              return 0;\n            }\n            if ( pExpr.affinity != OE_Ignore )\n            {\n              Debug.Assert( pExpr.affinity == OE_Rollback ||\n              pExpr.affinity == OE_Abort ||\n              pExpr.affinity == OE_Fail );\n              Debug.Assert( !ExprHasProperty( pExpr, EP_IntValue ) );\n              sqlite3VdbeAddOp4( v, OP_Halt, SQLITE_CONSTRAINT, pExpr.affinity, 0,\n              Encoding.UTF8.GetBytes( pExpr.u.zToken ), 0 );\n            }\n            else\n            {\n              Debug.Assert( pExpr.affinity == OE_Ignore );\n              sqlite3VdbeAddOp2( v, OP_ContextPop, 0, 0 );\n              sqlite3VdbeAddOp2( v, OP_Goto, 0, pParse.trigStack.ignoreJump );\n#if SQLITE_DEBUG\n              VdbeComment( v, "raise(IGNORE)" );\n#endif\n            }\n            break;\n          }\n#endif\n      }\n      sqlite3ReleaseTempReg( pParse, regFree1 );\n      sqlite3ReleaseTempReg( pParse, regFree2 );\n      return inReg;\n    }\n\n    /*\n    ** Generate code to evaluate an expression and store the results\n    ** into a register.  Return the register number where the results\n    ** are stored.\n    **\n    ** If the register is a temporary register that can be deallocated,\n    ** then write its number into pReg.  If the result register is not\n    ** a temporary, then set pReg to zero.\n    */\n    static int sqlite3ExprCodeTemp( Parse pParse, Expr pExpr, ref int pReg )\n    {\n      int r1 = sqlite3GetTempReg( pParse );\n      int r2 = sqlite3ExprCodeTarget( pParse, pExpr, r1 );\n      if ( r2 == r1 )\n      {\n        pReg = r1;\n      }\n      else\n      {\n        sqlite3ReleaseTempReg( pParse, r1 );\n        pReg = 0;\n      }\n      return r2;\n    }\n\n    /*\n    ** Generate code that will evaluate expression pExpr and store the\n    ** results in register target.  The results are guaranteed to appear\n    ** in register target.\n    */\n    static int sqlite3ExprCode( Parse pParse, Expr pExpr, int target )\n    {\n      int inReg;\n\n      Debug.Assert( target > 0 && target <= pParse.nMem );\n      inReg = sqlite3ExprCodeTarget( pParse, pExpr, target );\n      Debug.Assert( pParse.pVdbe != null /* || pParse.db.mallocFailed != 0 */ );\n      if ( inReg != target && pParse.pVdbe != null )\n      {\n        sqlite3VdbeAddOp2( pParse.pVdbe, OP_SCopy, inReg, target );\n      }\n      return target;\n    }\n\n    /*\n    ** Generate code that evalutes the given expression and puts the result\n    ** in register target.\n    **\n    ** Also make a copy of the expression results into another "cache" register\n    ** and modify the expression so that the next time it is evaluated,\n    ** the result is a copy of the cache register.\n    **\n    ** This routine is used for expressions that are used multiple\n    ** times.  They are evaluated once and the results of the expression\n    ** are reused.\n    */\n    static int sqlite3ExprCodeAndCache( Parse pParse, Expr pExpr, int target )\n    {\n      Vdbe v = pParse.pVdbe;\n      int inReg;\n      inReg = sqlite3ExprCode( pParse, pExpr, target );\n      Debug.Assert( target > 0 );\n      /* This routine is called for terms to INSERT or UPDATE.  And the only\n      ** other place where expressions can be converted into TK_REGISTER is\n      ** in WHERE clause processing.  So as currently implemented, there is\n      ** no way for a TK_REGISTER to exist here.  But it seems prudent to\n      ** keep the ALWAYS() in case the conditions above change with future\n      ** modifications or enhancements. */\n      if ( ALWAYS( pExpr.op != TK_REGISTER ) )\n      {\n        int iMem;\n        iMem = ++pParse.nMem;\n        sqlite3VdbeAddOp2( v, OP_Copy, inReg, iMem );\n        pExpr.iTable = iMem;\n        pExpr.op = TK_REGISTER;\n      }\n      return inReg;\n    }\n\n    /*\n    ** Return TRUE if pExpr is an constant expression that is appropriate\n    ** for factoring out of a loop.  Appropriate expressions are:\n    **\n    **    *  Any expression that evaluates to two or more opcodes.\n    **\n    **    *  Any OP_Integer, OP_Real, OP_String, OP_Blob, OP_Null,\n    **       or OP_Variable that does not need to be placed in a\n    **       specific register.\n    **\n    ** There is no point in factoring out single-instruction constant\n    ** expressions that need to be placed in a particular register.\n    ** We could factor them out, but then we would end up adding an\n    ** OP_SCopy instruction to move the value into the correct register\n    ** later.  We might as well just use the original instruction and\n    ** avoid the OP_SCopy.\n    */\n    static int isAppropriateForFactoring( Expr p )\n    {\n      if ( sqlite3ExprIsConstantNotJoin( p ) == 0 )\n      {\n        return 0;  /* Only constant expressions are appropriate for factoring */\n      }\n      if ( ( p.flags & EP_FixedDest ) == 0 )\n      {\n        return 1;  /* Any constant without a fixed destination is appropriate */\n      }\n      while ( p.op == TK_UPLUS ) p = p.pLeft;\n      switch ( p.op )\n      {\n#if !SQLITE_OMIT_BLOB_LITERAL\n        case TK_BLOB:\n#endif\n        case TK_VARIABLE:\n        case TK_INTEGER:\n        case TK_FLOAT:\n        case TK_NULL:\n        case TK_STRING:\n          {\n            testcase( p.op == TK_BLOB );\n            testcase( p.op == TK_VARIABLE );\n            testcase( p.op == TK_INTEGER );\n            testcase( p.op == TK_FLOAT );\n            testcase( p.op == TK_NULL );\n            testcase( p.op == TK_STRING );\n            /* Single-instruction constants with a fixed destination are\n            ** better done in-line.  If we factor them, they will just end\n            ** up generating an OP_SCopy to move the value to the destination\n            ** register. */\n            return 0;\n          }\n        case TK_UMINUS:\n          {\n            if ( p.pLeft.op == TK_FLOAT || p.pLeft.op == TK_INTEGER )\n            {\n              return 0;\n            }\n            break;\n          }\n        default:\n          {\n            break;\n          }\n      }\n      return 1;\n    }\n\n    /*\n    ** If pExpr is a constant expression that is appropriate for\n    ** factoring out of a loop, then evaluate the expression\n    ** into a register and convert the expression into a TK_REGISTER\n    ** expression.\n    */\n    static int evalConstExpr( Walker pWalker, ref Expr pExpr )\n    {\n      Parse pParse = pWalker.pParse;\n      switch ( pExpr.op )\n      {\n        case TK_REGISTER:\n          {\n            return WRC_Prune;\n          }\n        case TK_FUNCTION:\n        case TK_AGG_FUNCTION:\n        case TK_CONST_FUNC:\n          {\n            /* The arguments to a function have a fixed destination.\n            ** Mark them this way to avoid generated unneeded OP_SCopy\n            ** instructions.\n            */\n            ExprList pList = pExpr.x.pList;\n            Debug.Assert( !ExprHasProperty( pExpr, EP_xIsSelect ) );\n            if ( pList != null )\n            {\n              int i = pList.nExpr;\n              ExprList_item pItem;//= pList.a;\n              for ( ; i > 0 ; i-- )\n              {//, pItem++){\n                pItem = pList.a[pList.nExpr - i];\n                if ( ALWAYS( pItem.pExpr != null ) ) pItem.pExpr.flags |= EP_FixedDest;\n              }\n            }\n            break;\n          }\n      }\n      if ( isAppropriateForFactoring( pExpr ) != 0 )\n      {\n        int r1 = ++pParse.nMem;\n        int r2;\n        r2 = sqlite3ExprCodeTarget( pParse, pExpr, r1 );\n        if ( NEVER( r1 != r2 ) ) sqlite3ReleaseTempReg( pParse, r1 );\n        pExpr.op = TK_REGISTER;\n        pExpr.iTable = r2;\n        return WRC_Prune;\n      }\n      return WRC_Continue;\n    }\n\n    /*\n    ** Preevaluate constant subexpressions within pExpr and store the\n    ** results in registers.  Modify pExpr so that the constant subexpresions\n    ** are TK_REGISTER opcodes that refer to the precomputed values.\n    */\n    static void sqlite3ExprCodeConstants( Parse pParse, Expr pExpr )\n    {\n      Walker w = new Walker();\n      w.xExprCallback = (dxExprCallback)evalConstExpr;\n      w.xSelectCallback = null;\n      w.pParse = pParse;\n      sqlite3WalkExpr( w, ref pExpr );\n    }\n\n    /*\n    ** Generate code that pushes the value of every element of the given\n    ** expression list into a sequence of registers beginning at target.\n    **\n    ** Return the number of elements evaluated.\n    */\n    static int sqlite3ExprCodeExprList(\n    Parse pParse,     /* Parsing context */\n    ExprList pList,   /* The expression list to be coded */\n    int target,       /* Where to write results */\n    bool doHardCopy   /* Make a hard copy of every element */\n    )\n    {\n      ExprList_item pItem;\n      int i, n;\n      Debug.Assert( pList != null );\n      Debug.Assert( target > 0 );\n      n = pList.nExpr;\n      for ( i = 0 ; i < n ; i++ )// pItem++)\n      {\n        pItem = pList.a[i];\n        if ( pItem.iAlias != 0 )\n        {\n          int iReg = codeAlias( pParse, pItem.iAlias, pItem.pExpr, target + i );\n          Vdbe v = sqlite3GetVdbe( pParse );\n          if ( iReg != target + i )\n          {\n            sqlite3VdbeAddOp2( v, OP_SCopy, iReg, target + i );\n          }\n        }\n        else\n        {\n          sqlite3ExprCode( pParse, pItem.pExpr, target + i );\n        }\n        if ( doHardCopy /* && 0 == pParse.db.mallocFailed */ )\n        {\n          sqlite3ExprHardCopy( pParse, target, n );\n        }\n      }\n      return n;\n    }\n\n    /*\n    ** Generate code for a boolean expression such that a jump is made\n    ** to the label "dest" if the expression is true but execution\n    ** continues straight thru if the expression is false.\n    **\n    ** If the expression evaluates to NULL (neither true nor false), then\n    ** take the jump if the jumpIfNull flag is SQLITE_JUMPIFNULL.\n    **\n    ** This code depends on the fact that certain token values (ex: TK_EQ)\n    ** are the same as opcode values (ex: OP_Eq) that implement the corresponding\n    ** operation.  Special comments in vdbe.c and the mkopcodeh.awk script in\n    ** the make process cause these values to align.  Assert()s in the code\n    ** below verify that the numbers are aligned correctly.\n    */\n    static void sqlite3ExprIfTrue( Parse pParse, Expr pExpr, int dest, int jumpIfNull )\n    {\n      Vdbe v = pParse.pVdbe;\n      int op = 0;\n      int regFree1 = 0;\n      int regFree2 = 0;\n      int r1 = 0, r2 = 0;\n\n      Debug.Assert( jumpIfNull == SQLITE_JUMPIFNULL || jumpIfNull == 0 );\n      if ( NEVER( v == null ) ) return;  /* Existance of VDBE checked by caller */\n      if ( NEVER( pExpr == null ) ) return;  /* No way this can happen */\n      op = pExpr.op;\n      switch ( op )\n      {\n        case TK_AND:\n          {\n            int d2 = sqlite3VdbeMakeLabel( v );\n            testcase( jumpIfNull == 0 );\n            sqlite3ExprCachePush( pParse );\n            sqlite3ExprIfFalse( pParse, pExpr.pLeft, d2, jumpIfNull ^ SQLITE_JUMPIFNULL );\n            sqlite3ExprIfTrue( pParse, pExpr.pRight, dest, jumpIfNull );\n            sqlite3VdbeResolveLabel( v, d2 );\n            sqlite3ExprCachePop( pParse, 1 );\n            break;\n          }\n        case TK_OR:\n          {\n            testcase( jumpIfNull == 0 );\n            sqlite3ExprIfTrue( pParse, pExpr.pLeft, dest, jumpIfNull );\n            sqlite3ExprIfTrue( pParse, pExpr.pRight, dest, jumpIfNull );\n            break;\n          }\n        case TK_NOT:\n          {\n            testcase( jumpIfNull == 0 );\n            sqlite3ExprIfFalse( pParse, pExpr.pLeft, dest, jumpIfNull );\n            break;\n          }\n        case TK_LT:\n        case TK_LE:\n        case TK_GT:\n        case TK_GE:\n        case TK_NE:\n        case TK_EQ:\n          {\n            Debug.Assert( TK_LT == OP_Lt );\n            Debug.Assert( TK_LE == OP_Le );\n            Debug.Assert( TK_GT == OP_Gt );\n            Debug.Assert( TK_GE == OP_Ge );\n            Debug.Assert( TK_EQ == OP_Eq );\n            Debug.Assert( TK_NE == OP_Ne );\n            testcase( op == TK_LT );\n            testcase( op == TK_LE );\n            testcase( op == TK_GT );\n            testcase( op == TK_GE );\n            testcase( op == TK_EQ );\n            testcase( op == TK_NE );\n            testcase( jumpIfNull == 0 );\n            codeCompareOperands( pParse, pExpr.pLeft, ref r1, ref regFree1,\n            pExpr.pRight, ref r2, ref regFree2 );\n            codeCompare( pParse, pExpr.pLeft, pExpr.pRight, op,\n            r1, r2, dest, jumpIfNull );\n            testcase( regFree1 == 0 );\n            testcase( regFree2 == 0 );\n            break;\n          }\n        case TK_ISNULL:\n        case TK_NOTNULL:\n          {\n            Debug.Assert( TK_ISNULL == OP_IsNull );\n            Debug.Assert( TK_NOTNULL == OP_NotNull );\n            testcase( op == TK_ISNULL );\n            testcase( op == TK_NOTNULL );\n            r1 = sqlite3ExprCodeTemp( pParse, pExpr.pLeft, ref regFree1 );\n            sqlite3VdbeAddOp2( v, op, r1, dest );\n            testcase( regFree1 == 0 );\n            break;\n          }\n        case TK_BETWEEN:\n          {\n            /*    x BETWEEN y AND z\n            **\n            ** Is equivalent to\n            **\n            **    x>=y AND x<=z\n            **\n            ** Code it as such, taking care to do the common subexpression\n            ** elementation of x.\n            */\n            Expr exprAnd = new Expr();\n            Expr compLeft = new Expr();\n            Expr compRight = new Expr();\n            Expr exprX = new Expr();\n\n            Debug.Assert( !ExprHasProperty( pExpr, EP_xIsSelect ) );\n            exprX = pExpr.pLeft.Copy();\n            exprAnd.op = TK_AND;\n            exprAnd.pLeft = compLeft;\n            exprAnd.pRight = compRight;\n            compLeft.op = TK_GE;\n            compLeft.pLeft = exprX;\n            compLeft.pRight = pExpr.x.pList.a[0].pExpr;\n            compRight.op = TK_LE;\n            compRight.pLeft = exprX;\n            compRight.pRight = pExpr.x.pList.a[1].pExpr;\n            exprX.iTable = sqlite3ExprCodeTemp( pParse, exprX, ref regFree1 );\n            testcase( regFree1 == 0 );\n            exprX.op = TK_REGISTER;\n            testcase( jumpIfNull == 0 );\n            sqlite3ExprIfTrue( pParse, exprAnd, dest, jumpIfNull );\n            break;\n          }\n        default:\n          {\n            r1 = sqlite3ExprCodeTemp( pParse, pExpr, ref regFree1 );\n            sqlite3VdbeAddOp3( v, OP_If, r1, dest, jumpIfNull != 0 ? 1 : 0 );\n            testcase( regFree1 == 0 );\n            testcase( jumpIfNull == 0 );\n            break;\n          }\n      }\n      sqlite3ReleaseTempReg( pParse, regFree1 );\n      sqlite3ReleaseTempReg( pParse, regFree2 );\n    }\n\n    /*\n    ** Generate code for a boolean expression such that a jump is made\n    ** to the label "dest" if the expression is false but execution\n    ** continues straight thru if the expression is true.\n    **\n    ** If the expression evaluates to NULL (neither true nor false) then\n    ** jump if jumpIfNull is SQLITE_JUMPIFNULL or fall through if jumpIfNull\n    ** is 0.\n    */\n    static void sqlite3ExprIfFalse( Parse pParse, Expr pExpr, int dest, int jumpIfNull )\n    {\n      Vdbe v = pParse.pVdbe;\n      int op = 0;\n      int regFree1 = 0;\n      int regFree2 = 0;\n      int r1 = 0, r2 = 0;\n\n      Debug.Assert( jumpIfNull == SQLITE_JUMPIFNULL || jumpIfNull == 0 );\n      if ( NEVER( v == null ) ) return; /* Existance of VDBE checked by caller */\n      if ( pExpr == null ) return;\n\n      /* The value of pExpr.op and op are related as follows:\n      **\n      **       pExpr.op            op\n      **       ---------          ----------\n      **       TK_ISNULL          OP_NotNull\n      **       TK_NOTNULL         OP_IsNull\n      **       TK_NE              OP_Eq\n      **       TK_EQ              OP_Ne\n      **       TK_GT              OP_Le\n      **       TK_LE              OP_Gt\n      **       TK_GE              OP_Lt\n      **       TK_LT              OP_Ge\n      **\n      ** For other values of pExpr.op, op is undefined and unused.\n      ** The value of TK_ and OP_ constants are arranged such that we\n      ** can compute the mapping above using the following expression.\n      ** Assert()s verify that the computation is correct.\n      */\n      op = ( ( pExpr.op + ( TK_ISNULL & 1 ) ) ^ 1 ) - ( TK_ISNULL & 1 );\n\n      /* Verify correct alignment of TK_ and OP_ constants\n      */\n      Debug.Assert( pExpr.op != TK_ISNULL || op == OP_NotNull );\n      Debug.Assert( pExpr.op != TK_NOTNULL || op == OP_IsNull );\n      Debug.Assert( pExpr.op != TK_NE || op == OP_Eq );\n      Debug.Assert( pExpr.op != TK_EQ || op == OP_Ne );\n      Debug.Assert( pExpr.op != TK_LT || op == OP_Ge );\n      Debug.Assert( pExpr.op != TK_LE || op == OP_Gt );\n      Debug.Assert( pExpr.op != TK_GT || op == OP_Le );\n      Debug.Assert( pExpr.op != TK_GE || op == OP_Lt );\n\n      switch ( pExpr.op )\n      {\n        case TK_AND:\n          {\n            testcase( jumpIfNull == 0 );\n            sqlite3ExprIfFalse( pParse, pExpr.pLeft, dest, jumpIfNull );\n            sqlite3ExprIfFalse( pParse, pExpr.pRight, dest, jumpIfNull );\n            break;\n          }\n        case TK_OR:\n          {\n            int d2 = sqlite3VdbeMakeLabel( v );\n            testcase( jumpIfNull == 0 );\n            sqlite3ExprCachePush( pParse );\n            sqlite3ExprIfTrue( pParse, pExpr.pLeft, d2, jumpIfNull ^ SQLITE_JUMPIFNULL );\n            sqlite3ExprIfFalse( pParse, pExpr.pRight, dest, jumpIfNull );\n            sqlite3VdbeResolveLabel( v, d2 );\n            sqlite3ExprCachePop( pParse, 1 );\n            break;\n          }\n        case TK_NOT:\n          {\n            sqlite3ExprIfTrue( pParse, pExpr.pLeft, dest, jumpIfNull );\n            break;\n          }\n        case TK_LT:\n        case TK_LE:\n        case TK_GT:\n        case TK_GE:\n        case TK_NE:\n        case TK_EQ:\n          {\n            testcase( op == TK_LT );\n            testcase( op == TK_LE );\n            testcase( op == TK_GT );\n            testcase( op == TK_GE );\n            testcase( op == TK_EQ );\n            testcase( op == TK_NE );\n            testcase( jumpIfNull == 0 );\n            codeCompareOperands( pParse, pExpr.pLeft, ref  r1, ref  regFree1,\n            pExpr.pRight, ref r2, ref regFree2 );\n            codeCompare( pParse, pExpr.pLeft, pExpr.pRight, op,\n            r1, r2, dest, jumpIfNull );\n            testcase( regFree1 == 0 );\n            testcase( regFree2 == 0 );\n            break;\n          }\n        case TK_ISNULL:\n        case TK_NOTNULL:\n          {\n            testcase( op == TK_ISNULL );\n            testcase( op == TK_NOTNULL );\n            r1 = sqlite3ExprCodeTemp( pParse, pExpr.pLeft, ref regFree1 );\n            sqlite3VdbeAddOp2( v, op, r1, dest );\n            testcase( regFree1 == 0 );\n            break;\n          }\n        case TK_BETWEEN:\n          {\n            /*    x BETWEEN y AND z\n            **\n            ** Is equivalent to\n            **\n            **    x>=y AND x<=z\n            **\n            ** Code it as such, taking care to do the common subexpression\n            ** elementation of x.\n            */\n            Expr exprAnd = new Expr();\n            Expr compLeft = new Expr();\n            Expr compRight = new Expr();\n            Expr exprX = new Expr();\n\n            Debug.Assert( !ExprHasProperty( pExpr, EP_xIsSelect ) );\n            exprX = pExpr.pLeft;\n            exprAnd.op = TK_AND;\n            exprAnd.pLeft = compLeft;\n            exprAnd.pRight = compRight;\n            compLeft.op = TK_GE;\n            compLeft.pLeft = exprX;\n            compLeft.pRight = pExpr.x.pList.a[0].pExpr;\n            compRight.op = TK_LE;\n            compRight.pLeft = exprX;\n            compRight.pRight = pExpr.x.pList.a[1].pExpr;\n            exprX.iTable = sqlite3ExprCodeTemp( pParse, exprX, ref regFree1 );\n            testcase( regFree1 == 0 );\n            exprX.op = TK_REGISTER;\n            testcase( jumpIfNull == 0 );\n            sqlite3ExprIfFalse( pParse, exprAnd, dest, jumpIfNull );\n            break;\n          }\n        default:\n          {\n            r1 = sqlite3ExprCodeTemp( pParse, pExpr, ref regFree1 );\n            sqlite3VdbeAddOp3( v, OP_IfNot, r1, dest, jumpIfNull != 0 ? 1 : 0 );\n            testcase( regFree1 == 0 );\n            testcase( jumpIfNull == 0 );\n            break;\n          }\n      }\n      sqlite3ReleaseTempReg( pParse, regFree1 );\n      sqlite3ReleaseTempReg( pParse, regFree2 );\n    }\n\n    /*\n    ** Do a deep comparison of two expression trees.  Return TRUE (non-zero)\n    ** if they are identical and return FALSE if they differ in any way.\n    **\n    ** Sometimes this routine will return FALSE even if the two expressions\n    ** really are equivalent.  If we cannot prove that the expressions are\n    ** identical, we return FALSE just to be safe.  So if this routine\n    ** returns false, then you do not really know for certain if the two\n    ** expressions are the same.  But if you get a TRUE return, then you\n    ** can be sure the expressions are the same.  In the places where\n    ** this routine is used, it does not hurt to get an extra FALSE - that\n    ** just might result in some slightly slower code.  But returning\n    ** an incorrect TRUE could lead to a malfunction.\n    */\n    static bool sqlite3ExprCompare( Expr pA, Expr pB )\n    {\n      int i;\n      if ( pA == null || pB == null )\n      {\n        return pB == pA;\n      }\n      Debug.Assert( !ExprHasAnyProperty( pA, EP_TokenOnly | EP_Reduced ) );\n      Debug.Assert( !ExprHasAnyProperty( pB, EP_TokenOnly | EP_Reduced ) );\n      if ( ExprHasProperty( pA, EP_xIsSelect ) || ExprHasProperty( pB, EP_xIsSelect ) )\n      {\n        return false;\n      }\n      if ( ( pA.flags & EP_Distinct ) != ( pB.flags & EP_Distinct ) ) return false;\n      if ( pA.op != pB.op ) return false;\n      if ( !sqlite3ExprCompare( pA.pLeft, pB.pLeft ) ) return false;\n      if ( !sqlite3ExprCompare( pA.pRight, pB.pRight ) ) return false;\n      if ( pA.x.pList != null && pB.x.pList != null )\n      {\n        if ( pA.x.pList.nExpr != pB.x.pList.nExpr ) return false;\n        for ( i = 0 ; i < pA.x.pList.nExpr ; i++ )\n        {\n          Expr pExprA = pA.x.pList.a[i].pExpr;\n          Expr pExprB = pB.x.pList.a[i].pExpr;\n          if ( !sqlite3ExprCompare( pExprA, pExprB ) ) return false;\n        }\n      }\n      else if ( pA.x.pList != null || pB.x.pList != null )\n      {\n        return false;\n      }\n      if ( pA.iTable != pB.iTable || pA.iColumn != pB.iColumn ) return false;\n      if ( ExprHasProperty( pA, EP_IntValue ) )\n      {\n        if ( !ExprHasProperty( pB, EP_IntValue ) || pA.u.iValue != pB.u.iValue )\n        {\n          return false;\n        }\n      }\n      else if ( pA.op != TK_COLUMN && pA.u.zToken != null )\n      {\n        if ( ExprHasProperty( pB, EP_IntValue ) || NEVER( pB.u.zToken == null ) ) return false;\n        if ( sqlite3StrICmp( pA.u.zToken, pB.u.zToken ) != 0 )\n        {\n          return false;\n        }\n      }\n      return true;\n    }\n\n\n    /*\n    ** Add a new element to the pAggInfo.aCol[] array.  Return the index of\n    ** the new element.  Return a negative number if malloc fails.\n    */\n    static int addAggInfoColumn( sqlite3 db, AggInfo pInfo )\n    {\n      int i = 0;\n      pInfo.aCol = sqlite3ArrayAllocate(\n      db,\n      pInfo.aCol,\n      -1,//sizeof(pInfo.aCol[0]),\n      3,\n      ref pInfo.nColumn,\n      ref pInfo.nColumnAlloc,\n      ref i\n      );\n      return i;\n    }\n\n    /*\n    ** Add a new element to the pAggInfo.aFunc[] array.  Return the index of\n    ** the new element.  Return a negative number if malloc fails.\n    */\n    static int addAggInfoFunc( sqlite3 db, AggInfo pInfo )\n    {\n      int i = 0;\n      pInfo.aFunc = sqlite3ArrayAllocate(\n      db,\n      pInfo.aFunc,\n      -1,//sizeof(pInfo.aFunc[0]),\n      3,\n      ref pInfo.nFunc,\n      ref pInfo.nFuncAlloc,\n      ref i\n      );\n      return i;\n    }\n\n    /*\n    ** This is the xExprCallback for a tree walker.  It is used to\n    ** implement sqlite3ExprAnalyzeAggregates().  See sqlite3ExprAnalyzeAggregates\n    ** for additional information.\n    */\n    static int analyzeAggregate( Walker pWalker, ref Expr pExpr )\n    {\n      int i;\n      NameContext pNC = pWalker.u.pNC;\n      Parse pParse = pNC.pParse;\n      SrcList pSrcList = pNC.pSrcList;\n      AggInfo pAggInfo = pNC.pAggInfo;\n\n      switch ( pExpr.op )\n      {\n        case TK_AGG_COLUMN:\n        case TK_COLUMN:\n          {\n            testcase( pExpr.op == TK_AGG_COLUMN );\n            testcase( pExpr.op == TK_COLUMN );\n            /* Check to see if the column is in one of the tables in the FROM\n            ** clause of the aggregate query */\n            if ( ALWAYS( pSrcList != null ) )\n            {\n              SrcList_item pItem;// = pSrcList.a;\n              for ( i = 0 ; i < pSrcList.nSrc ; i++ )\n              {//, pItem++){\n                pItem = pSrcList.a[i];\n                AggInfo_col pCol;\n                Debug.Assert( !ExprHasAnyProperty( pExpr, EP_TokenOnly | EP_Reduced ) );\n                if ( pExpr.iTable == pItem.iCursor )\n                {\n                  /* If we reach this point, it means that pExpr refers to a table\n                  ** that is in the FROM clause of the aggregate query.\n                  **\n                  ** Make an entry for the column in pAggInfo.aCol[] if there\n                  ** is not an entry there already.\n                  */\n                  int k;\n                  //pCol = pAggInfo.aCol;\n                  for ( k = 0 ; k < pAggInfo.nColumn ; k++ )\n                  {//, pCol++){\n                    pCol = pAggInfo.aCol[k];\n                    if ( pCol.iTable == pExpr.iTable &&\n                    pCol.iColumn == pExpr.iColumn )\n                    {\n                      break;\n                    }\n                  }\n                  if ( ( k >= pAggInfo.nColumn )\n                  && ( k = addAggInfoColumn( pParse.db, pAggInfo ) ) >= 0\n                  )\n                  {\n                    pCol = pAggInfo.aCol[k];\n                    pCol.pTab = pExpr.pTab;\n                    pCol.iTable = pExpr.iTable;\n                    pCol.iColumn = pExpr.iColumn;\n                    pCol.iMem = ++pParse.nMem;\n                    pCol.iSorterColumn = -1;\n                    pCol.pExpr = pExpr;\n                    if ( pAggInfo.pGroupBy != null )\n                    {\n                      int j, n;\n                      ExprList pGB = pAggInfo.pGroupBy;\n                      ExprList_item pTerm;// = pGB.a;\n                      n = pGB.nExpr;\n                      for ( j = 0 ; j < n ; j++ )\n                      {//, pTerm++){\n                        pTerm = pGB.a[j];\n                        Expr pE = pTerm.pExpr;\n                        if ( pE.op == TK_COLUMN && pE.iTable == pExpr.iTable &&\n                        pE.iColumn == pExpr.iColumn )\n                        {\n                          pCol.iSorterColumn = j;\n                          break;\n                        }\n                      }\n                    }\n                    if ( pCol.iSorterColumn < 0 )\n                    {\n                      pCol.iSorterColumn = pAggInfo.nSortingColumn++;\n                    }\n                  }\n                  /* There is now an entry for pExpr in pAggInfo.aCol[] (either\n                  ** because it was there before or because we just created it).\n                  ** Convert the pExpr to be a TK_AGG_COLUMN referring to that\n                  ** pAggInfo.aCol[] entry.\n                  */\n                  ExprSetIrreducible( pExpr );\n                  pExpr.pAggInfo = pAggInfo;\n                  pExpr.op = TK_AGG_COLUMN;\n                  pExpr.iAgg = (short)k;\n                  break;\n                } /* endif pExpr.iTable==pItem.iCursor */\n              } /* end loop over pSrcList */\n            }\n            return WRC_Prune;\n          }\n        case TK_AGG_FUNCTION:\n          {\n            /* The pNC.nDepth==0 test causes aggregate functions in subqueries\n            ** to be ignored */\n            if ( pNC.nDepth == 0 )\n            {\n              /* Check to see if pExpr is a duplicate of another aggregate\n              ** function that is already in the pAggInfo structure\n              */\n              AggInfo_func pItem;// = pAggInfo.aFunc;\n              for ( i = 0 ; i < pAggInfo.nFunc ; i++ )\n              {//, pItem++){\n                pItem = pAggInfo.aFunc[i];\n                if ( sqlite3ExprCompare( pItem.pExpr, pExpr ) )\n                {\n                  break;\n                }\n              }\n              if ( i >= pAggInfo.nFunc )\n              {\n                /* pExpr is original.  Make a new entry in pAggInfo.aFunc[]\n                */\n                u8 enc = pParse.db.aDbStatic[0].pSchema.enc;// ENC(pParse.db);\n                i = addAggInfoFunc( pParse.db, pAggInfo );\n                if ( i >= 0 )\n                {\n                  Debug.Assert( !ExprHasProperty( pExpr, EP_xIsSelect ) );\n                  pItem = pAggInfo.aFunc[i];\n                  pItem.pExpr = pExpr;\n                  pItem.iMem = ++pParse.nMem;\n                  Debug.Assert( !ExprHasProperty( pExpr, EP_IntValue ) );\n                  pItem.pFunc = sqlite3FindFunction( pParse.db,\n                  pExpr.u.zToken, sqlite3Strlen30( pExpr.u.zToken ),\n                  pExpr.x.pList != null ? pExpr.x.pList.nExpr : 0, enc, 0 );\n                  if ( ( pExpr.flags & EP_Distinct ) != 0 )\n                  {\n                    pItem.iDistinct = pParse.nTab++;\n                  }\n                  else\n                  {\n                    pItem.iDistinct = -1;\n                  }\n                }\n              }\n              /* Make pExpr point to the appropriate pAggInfo.aFunc[] entry\n              */\n              Debug.Assert( !ExprHasAnyProperty( pExpr, EP_TokenOnly | EP_Reduced ) );\n              ExprSetIrreducible( pExpr );\n              pExpr.iAgg = (short)i;\n              pExpr.pAggInfo = pAggInfo;\n              return WRC_Prune;\n            }\n            break;\n          }\n      }\n      return WRC_Continue;\n    }\n\n    static int analyzeAggregatesInSelect( Walker pWalker, Select pSelect )\n    {\n      NameContext pNC = pWalker.u.pNC;\n      if ( pNC.nDepth == 0 )\n      {\n        pNC.nDepth++;\n        sqlite3WalkSelect( pWalker, pSelect );\n        pNC.nDepth--;\n        return WRC_Prune;\n      }\n      else\n      {\n        return WRC_Continue;\n      }\n    }\n\n\n    /*\n    ** Analyze the given expression looking for aggregate functions and\n    ** for variables that need to be added to the pParse.aAgg[] array.\n    ** Make additional entries to the pParse.aAgg[] array as necessary.\n    **\n    ** This routine should only be called after the expression has been\n    ** analyzed by sqlite3ResolveExprNames().\n    */\n    static void sqlite3ExprAnalyzeAggregates( NameContext pNC, ref  Expr pExpr )\n    {\n      Walker w = new Walker();\n      w.xExprCallback = (dxExprCallback)analyzeAggregate;\n      w.xSelectCallback = (dxSelectCallback)analyzeAggregatesInSelect;\n      w.u.pNC = pNC;\n      Debug.Assert( pNC.pSrcList != null );\n      sqlite3WalkExpr( w, ref pExpr );\n    }\n\n    /*\n    ** Call sqlite3ExprAnalyzeAggregates() for every expression in an\n    ** expression list.  Return the number of errors.\n    **\n    ** If an error is found, the analysis is cut short.\n    */\n    static void sqlite3ExprAnalyzeAggList( NameContext pNC, ExprList pList )\n    {\n      ExprList_item pItem;\n      int i;\n      if ( pList != null )\n      {\n        for ( i = 0 ; i < pList.nExpr ; i++ )//, pItem++)\n        {\n          pItem = pList.a[i];\n          sqlite3ExprAnalyzeAggregates( pNC, ref pItem.pExpr );\n        }\n      }\n    }\n\n    /*\n    ** Allocate a single new register for use to hold some intermediate result.\n    */\n    static int sqlite3GetTempReg( Parse pParse )\n    {\n      if ( pParse.nTempReg == 0 )\n      {\n        return ++pParse.nMem;\n      }\n      return pParse.aTempReg[--pParse.nTempReg];\n    }\n\n    /*\n    ** Deallocate a register, making available for reuse for some other\n    ** purpose.\n    **\n    ** If a register is currently being used by the column cache, then\n    ** the dallocation is deferred until the column cache line that uses\n    ** the register becomes stale.\n    */\n    static void sqlite3ReleaseTempReg( Parse pParse, int iReg )\n    {\n      if ( iReg != 0 && pParse.nTempReg < ArraySize( pParse.aTempReg ) )\n      {\n        int i;\n        yColCache p;\n        for ( i = 0 ; i < SQLITE_N_COLCACHE ; i++ )//p=pParse.aColCache... p++)\n        {\n          p = pParse.aColCache[i];\n          if ( p.iReg == iReg )\n          {\n            p.tempReg = 1;\n            return;\n          }\n        }\n        pParse.aTempReg[pParse.nTempReg++] = iReg;\n      }\n    }\n\n    /*\n    ** Allocate or deallocate a block of nReg consecutive registers\n    */\n    static int sqlite3GetTempRange( Parse pParse, int nReg )\n    {\n      int i, n;\n      i = pParse.iRangeReg;\n      n = pParse.nRangeReg;\n      if ( nReg <= n && usedAsColumnCache( pParse, i, i + n - 1 ) == 0 )\n      {\n        pParse.iRangeReg += nReg;\n        pParse.nRangeReg -= nReg;\n      }\n      else\n      {\n        i = pParse.nMem + 1;\n        pParse.nMem += nReg;\n      }\n      return i;\n    }\n    static void sqlite3ReleaseTempRange( Parse pParse, int iReg, int nReg )\n    {\n      if ( nReg > pParse.nRangeReg )\n      {\n        pParse.nRangeReg = nReg;\n        pParse.iRangeReg = iReg;\n      }\n    }\n  }\n}\n'