b'{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{-# LANGUAGE Rank2Types #-}\n\n-- | This file provides a basic capability for parallel in-place\n-- modification of (disjoint) partitions of an array.  It allows\n-- mutation via arbitrary `ST` computations.\n\nmodule VecPar\n       (ParVec, runParVec, forkWithVec, liftST, getParVec, initParVec)\n       where\n\nimport Control.Monad\nimport Control.Monad.IO.Class\nimport Control.Monad.Par.IO (ParIO,runParIO,IVar)\nimport qualified Control.Monad.Par.Class as PC\nimport qualified Control.Monad.Trans.State.Strict as S\nimport Control.Monad.ST        (ST)\nimport Control.Monad.ST.Unsafe (unsafeSTToIO)\nimport Control.Monad.Trans (lift)\nimport Data.STRef\nimport Data.Vector.Mutable as MV\nimport Data.Vector       (freeze)\nimport Prelude hiding (read, length)\nimport System.IO.Unsafe (unsafePerformIO)\n\n-- | The ParVec monad.  It uses the StateT monad transformer to layer\n-- a state of type (STVector s elt) on top of an inner monad, ParIO.\n-- Its third parameter, \'a\', is the type inside the ParVec\n-- computation, and the \'elt\' parameter is the element type of the\n-- vector.  The \'s\' parameter is what\'s known as a "phantom type".\nnewtype ParVec s elt a = ParVec ((S.StateT (STVector s elt) ParIO) a)\n deriving Monad\n\n-- | Here, runParVec has a rank-2 type, and the phantom type \'s\' is\n-- bound by the inner forall quantifier.\nrunParVec :: forall a elt . (forall s . ParVec s elt a) -> a\n-- Here we\'re just using the ParVec value constructor tag to\n-- destructure the argument to runParVec.  The \'st\' in (ParVec st) is\n-- of the type ((S.StateT (STVector s elt) ParIO) a).  The\n-- unsafePerformIO lets us get the needed \'a\' out of an IO\n-- computation.\nrunParVec (ParVec st) = unsafePerformIO io\n where\n   -- Create a new mutable vector of length 0 and do a runStateT with\n   -- it, getting back a monadic value of type ParIO, which we then\n   -- run, getting a value and a final state.  We keep the value and\n   -- throw away the state.\n   io = do vec <- MV.new 0 -- :: IO (STVector RealWorld elt)\n           let x = S.runStateT st vec -- x :: ParIO (a, STVector s0 elt)\n           (a,_) <- runParIO x\n           return a\n\n-- | getParVec is a ParVec computation that results in the current\n-- value of the state, which is of type \'STVector s elt\'.\ngetParVec :: ParVec s elt (STVector s elt)\ngetParVec = ParVec S.get\n\n-- | initParVec creates a new mutable vector and returns a ParVec\n-- computation with that new mutable vector\'s state as its state.\ninitParVec :: Int -> ParVec s elt ()\ninitParVec size = do\n  vec <- liftST $ MV.new size\n  ParVec $ S.put vec\n\n-- | forkWithVec takes a split point and two ParVec computations.  It\n-- gets the state of the current computation, which is a vector, and\n-- then divides up that state between the two other computations.\n-- Writes to those two computations actually mutate the original\n-- vector.\nforkWithVec :: forall elt a b s .\n               Int\n            -> (forall sl . ParVec sl elt a)\n            -> (forall sr . ParVec sr elt b)\n            -> ParVec s elt (a,b)\nforkWithVec mid (ParVec lef) (ParVec rig) = ParVec $ do\n  vec <- S.get\n  let lvec = slice 0 mid vec\n      rvec = slice mid (length vec - mid) vec\n  lv <- lift$ PC.spawn_$ S.evalStateT lef lvec\n  S.put rvec\n  rx <- rig                     -- Do the R one on this thread.\n  lx <- lift$ PC.get lv         -- Wait for the forked thread to finish.\n  S.put vec                     -- Put the whole vec back in place.\n  return (lx,rx)\n\n-- | Allow `ST` computations inside `ParVec` computations.\nliftST :: ST s a -> ParVec s elt a\nliftST st = ParVec $ liftIO io\n  where\n    io = unsafeSTToIO st\n\ninstance PC.ParFuture IVar (ParVec s elt) where\n  spawn_ (ParVec task) = ParVec $ \n    do iv <- lift $ PC.new\n       lift $ PC.fork $ do\n           (res,_) <- S.runStateT task\n                      (error "spawn_: This child thread does not have permission to touch the array!")\n           PC.put_ iv res\n       return iv\n  get iv = ParVec $ lift $ PC.get iv\n\ninstance PC.ParIVar IVar (ParVec s elt) where\n  fork (ParVec task) = ParVec $ \n    lift $ PC.fork $ do\n      (res,_) <- S.runStateT task\n                 (error "fork: This child thread does not have permission to touch the array!")\n      return res\n  new       = ParVec$ lift PC.new\n  put_ iv v = ParVec$ lift$ PC.put_ iv v\n  \n  \n--------------------------------------------------------------------------------\n-- Tests and Scrap:\n--------------------------------------------------------------------------------\n\n-- Little tests:\nt1 = unsafeSTToIO p1\nt2 = runParVec p2\n\np1 :: ST s String\np1 = do\n  r <- newSTRef "hi"\n  writeSTRef r "hello"\n  readSTRef r\n\n\np2 :: ParVec s Float String\np2 = do\n  r <- liftST$ newSTRef "hi"\n  initParVec 10\n  v <- getParVec\n\n  liftST$ set v 0\n\n  forkWithVec 5\n     (do v1 <- getParVec\n         -- We can\'t protect against this sort of out-of-bounds error\n         -- at compile time -- for that we\'d need dependent types.\n         -- liftST$ write v1 9 0 -- BAD! out of bounds\n         liftST$ write v1 2 33.3\n     )\n     (do v2 <- getParVec\n         -- This, we actually *can* protect against at compile time.\n         -- liftST$ read v 2  -- BAD!\n         -- liftST$ readSTRef r\n         liftST$ write v2 2 44.4)\n\n  z <- liftST$ freeze v\n\n  liftST$ writeSTRef r "hello "\n  hello <- liftST$ readSTRef r\n  return$ hello ++ show z\n\n'