b'const int N = 70;\nset<int> g[N];\nbool vis[N];\n\nvoid fill_cluster_size(int u, int &cluster_size) {\n    vis[u] = 1;\n    // cout << "dfs::at couple " << u << endl;\n    cluster_size++;\n    for(int v: g[u]) {\n        if(!vis[v]) {\n            fill_cluster_size(v, cluster_size);\n        }\n    }\n}\n\nint get_couple_id(int person) {\n    return person / 2;\n}\n\n\nclass Solution {\npublic:\n    int minSwapsCouples(vector<int>& row) {\n        int n = row.size() / 2;\n        // normalizing the seating arrangement in terms of couple ids\n        for(int &x: row) x = get_couple_id(x);\n        \n        for(int i = 0; i < n; i++) {\n            g[i].clear();\n            vis[i] = 0;\n        }\n        \n        for(int i = 0; i < row.size(); i += 2) {\n            int c1 = row[i], c2 = row[i+1];\n            if( c1 == c2 ) continue;\n            g[c1].insert(c2);\n            g[c2].insert(c1);\n            // cout << i << " adding edge in couple " << c1 << " " << c2 << endl;\n        }\n        \n        int ans = 0;\n        for(int i = 0; i < n; i++) {\n            if(!vis[i]) {\n                int cluster_size = 0;\n                fill_cluster_size(i, cluster_size);\n                ans += cluster_size - 1;\n            }\n        }\n        return ans;\n    }\n};\n/*\n    0,3,1,2 -> 0,1,3,2\n    easy notation: 0,1,0,1\n    - Find a swap that can make two couples happy.\n    - \n(0, 1) --- 1st couple --- couple id = 0\n(2, 3) --- 2nd couple --- couple id = 1\n(4, 5) -- 3rd couple --- couple id = 2\n    0,3,5,2,1,4 --> 0,1,2,1,0,2\n    \n    0---1---2\n    \\______/\n\nx----y      <--- 1 swap\nx----y----z <--- 2 swaps\n\nC couples --- C-1 swaps\n*/\n'