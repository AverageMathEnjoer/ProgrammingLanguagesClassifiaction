b'using System;\nusing System.Diagnostics;\nusing System.Text;\n\nusing u8 = System.Byte;\nusing u16 = System.UInt16;\nusing u32 = System.UInt32;\nusing sqlite3_int64 = System.Int64;\n\nnamespace CS_SQLite3\n{\n  using sqlite3_stmt = CSSQLite.Vdbe;\n\n  public partial class CSSQLite\n  {\n    /*\n    ** 2005 May 25\n    **\n    ** The author disclaims copyright to this source code.  In place of\n    ** a legal notice, here is a blessing:\n    **\n    **    May you do good and not evil.\n    **    May you find forgiveness for yourself and forgive others.\n    **    May you share freely, never taking more than you give.\n    **\n    *************************************************************************\n    ** This file contains the implementation of the sqlite3_prepare()\n    ** interface, and routines that contribute to loading the database schema\n    ** from disk.\n    **\n    ** $Id: prepare.c,v 1.131 2009/08/06 17:43:31 drh Exp $\n    **\n    *************************************************************************\n    **  Included in SQLite3 port to C#-SQLite;  2008 Noah B Hart\n    **  C#-SQLite is an independent reimplementation of the SQLite software library\n    **\n    **  $Header$\n    *************************************************************************\n    */\n    //#include "sqliteInt.h"\n\n    /*\n    ** Fill the InitData structure with an error message that indicates\n    ** that the database is corrupt.\n    */\n    static void corruptSchema(\n    InitData pData, /* Initialization context */\n    string zObj,    /* Object being parsed at the point of error */\n    string zExtra   /* Error information */\n    )\n    {\n      sqlite3 db = pData.db;\n      if ( /*  0 == db.mallocFailed && */  ( db.flags & SQLITE_RecoveryMode ) == 0 )\n      {\n        {\n          if ( zObj == null ) zObj = "?";\n          sqlite3SetString( ref  pData.pzErrMsg, db,\n          "malformed database schema (%s)", zObj );\n          if ( !String.IsNullOrEmpty( zExtra ) )\n          {\n            pData.pzErrMsg = sqlite3MAppendf( db, pData.pzErrMsg\n              , "%s - %s", pData.pzErrMsg, zExtra );\n          }\n        }\n        pData.rc = //db.mallocFailed != 0 ? SQLITE_NOMEM :\n#if SQLITE_DEBUG\n SQLITE_CORRUPT_BKPT();\n#else\nSQLITE_CORRUPT;\n#endif\n      }\n    }\n\n    /*\n    ** This is the callback routine for the code that initializes the\n    ** database.  See sqlite3Init() below for additional information.\n    ** This routine is also called from the OP_ParseSchema opcode of the VDBE.\n    **\n    ** Each callback contains the following information:\n    **\n    **     argv[0] = name of thing being created\n    **     argv[1] = root page number for table or index. 0 for trigger or view.\n    **     argv[2] = SQL text for the CREATE statement.\n    **\n    */\n    static int sqlite3InitCallback( object pInit, sqlite3_int64 argc, object p2, object NotUsed )\n    {\n      string[] argv = (string[])p2;\n      InitData pData = (InitData)pInit;\n      sqlite3 db = pData.db;\n      int iDb = pData.iDb;\n\n      Debug.Assert( argc == 3 );\n      UNUSED_PARAMETER2( NotUsed, argc );\n      Debug.Assert( sqlite3_mutex_held( db.mutex ) );\n      DbClearProperty( db, iDb, DB_Empty );\n      //if ( db.mallocFailed != 0 )\n      //{\n      //  corruptSchema( pData, argv[0], "" );\n      //  return 1;\n      //}\n\n      Debug.Assert( iDb >= 0 && iDb < db.nDb );\n      if ( argv == null ) return 0;   /* Might happen if EMPTY_RESULT_CALLBACKS are on */\n      if ( argv[1] == null )\n      {\n        corruptSchema( pData, argv[0], "" );\n      }\n      else if ( argv[2] != null && argv[2].Length != 0 )\n      {\n        /* Call the parser to process a CREATE TABLE, INDEX or VIEW.\n        ** But because db.init.busy is set to 1, no VDBE code is generated\n        ** or executed.  All the parser does is build the internal data\n        ** structures that describe the table, index, or view.\n        */\n        string zErr = "";\n        int rc;\n        Debug.Assert( db.init.busy != 0 );\n        db.init.iDb = iDb;\n        db.init.newTnum = atoi( argv[1] );\n        db.init.orphanTrigger = 0;\n        rc = sqlite3_exec( db, argv[2], null, null, ref zErr );\n        db.init.iDb = 0;\n        Debug.Assert( rc != SQLITE_OK || zErr == "" );\n        if ( SQLITE_OK != rc )\n        {\n          if ( db.init.orphanTrigger!=0 )\n          {\n            Debug.Assert( iDb == 1 );\n          }\n          else\n          {\n            pData.rc = rc;\n            if ( rc == SQLITE_NOMEM )\n            {\n              //        db.mallocFailed = 1;\n            }\n            else if ( rc != SQLITE_INTERRUPT && rc != SQLITE_LOCKED )\n            {\n              corruptSchema( pData, argv[0], zErr );\n            }\n          }          //sqlite3DbFree( db, ref zErr );\n        }\n      }\n      else if ( argv[0] == null || argv[0] == "" )\n      {\n        corruptSchema( pData, null, null );\n      }\n      else\n      {\n        /* If the SQL column is blank it means this is an index that\n        ** was created to be the PRIMARY KEY or to fulfill a UNIQUE\n        ** constraint for a CREATE TABLE.  The index should have already\n        ** been created when we processed the CREATE TABLE.  All we have\n        ** to do here is record the root page number for that index.\n        */\n        Index pIndex;\n        pIndex = sqlite3FindIndex( db, argv[0], db.aDb[iDb].zName );\n        if ( pIndex == null )\n        {\n          /* This can occur if there exists an index on a TEMP table which\n          ** has the same name as another index on a permanent index.  Since\n          ** the permanent table is hidden by the TEMP table, we can also\n          ** safely ignore the index on the permanent table.\n          */\n          /* Do Nothing */\n          ;\n        }\n        else if ( sqlite3GetInt32( argv[1], ref pIndex.tnum ) == false )\n        {\n          corruptSchema( pData, argv[0], "invalid rootpage" );\n        }\n      }\n      return 0;\n    }\n\n    /*\n    ** Attempt to read the database schema and initialize internal\n    ** data structures for a single database file.  The index of the\n    ** database file is given by iDb.  iDb==0 is used for the main\n    ** database.  iDb==1 should never be used.  iDb>=2 is used for\n    ** auxiliary databases.  Return one of the SQLITE_ error codes to\n    ** indicate success or failure.\n    */\n    static int sqlite3InitOne( sqlite3 db, int iDb, ref string pzErrMsg )\n    {\n      int rc;\n      int i;\n      int size;\n      Table pTab;\n      Db pDb;\n      string[] azArg = new string[4];\n      u32[] meta = new u32[5];\n      InitData initData = new InitData();\n      string zMasterSchema;\n      string zMasterName = SCHEMA_TABLE( iDb );\n      int openedTransaction = 0;\n\n      /*\n      ** The master database table has a structure like this\n      */\n      string master_schema =\n      "CREATE TABLE sqlite_master(\\n" +\n      "  type text,\\n" +\n      "  name text,\\n" +\n      "  tbl_name text,\\n" +\n      "  rootpage integer,\\n" +\n      "  sql text\\n" +\n      ")"\n      ;\n#if !SQLITE_OMIT_TEMPDB\n      string temp_master_schema =\n      "CREATE TEMP TABLE sqlite_temp_master(\\n" +\n      "  type text,\\n" +\n      "  name text,\\n" +\n      "  tbl_name text,\\n" +\n      "  rootpage integer,\\n" +\n      "  sql text\\n" +\n      ")"\n      ;\n#else\n//#define temp_master_schema 0\n#endif\n\n      Debug.Assert( iDb >= 0 && iDb < db.nDb );\n      Debug.Assert( db.aDb[iDb].pSchema != null );\n      Debug.Assert( sqlite3_mutex_held( db.mutex ) );\n      Debug.Assert( iDb == 1 || sqlite3BtreeHoldsMutex( db.aDb[iDb].pBt ) );\n\n      /* zMasterSchema and zInitScript are set to point at the master schema\n      ** and initialisation script appropriate for the database being\n      ** initialised. zMasterName is the name of the master table.\n      */\n      if ( OMIT_TEMPDB == 0 && iDb == 1 )\n      {\n        zMasterSchema = temp_master_schema;\n      }\n      else\n      {\n        zMasterSchema = master_schema;\n      }\n      zMasterName = SCHEMA_TABLE( iDb );\n\n      /* Construct the schema tables.  */\n      azArg[0] = zMasterName;\n      azArg[1] = "1";\n      azArg[2] = zMasterSchema;\n      azArg[3] = "";\n      initData.db = db;\n      initData.iDb = iDb;\n      initData.rc = SQLITE_OK;\n      initData.pzErrMsg = pzErrMsg;\n      sqlite3SafetyOff( db );\n      sqlite3InitCallback( initData, 3, azArg, null );\n      sqlite3SafetyOn( db );\n      if ( initData.rc != 0 )\n      {\n        rc = initData.rc;\n        goto error_out;\n      }\n      pTab = sqlite3FindTable( db, zMasterName, db.aDb[iDb].zName );\n      if ( ALWAYS( pTab ) )\n      {\n        pTab.tabFlags |= TF_Readonly;\n      }\n\n      /* Create a cursor to hold the database open\n      */\n      pDb = db.aDb[iDb];\n      if ( pDb.pBt == null )\n      {\n        if ( OMIT_TEMPDB == 0 && ALWAYS( iDb == 1 ) )\n        {\n          DbSetProperty( db, 1, DB_SchemaLoaded );\n        }\n        return SQLITE_OK;\n      }\n\n      /* If there is not already a read-only (or read-write) transaction opened\n      ** on the b-tree database, open one now. If a transaction is opened, it \n      ** will be closed before this function returns.  */\n      sqlite3BtreeEnter( pDb.pBt );\n      if ( !sqlite3BtreeIsInReadTrans( pDb.pBt ) )\n      {\n        rc = sqlite3BtreeBeginTrans( pDb.pBt, 0 );\n        if ( rc != SQLITE_OK )\n        {\n          sqlite3SetString( ref pzErrMsg, db, "%s", sqlite3ErrStr( rc ) );\n          goto initone_error_out;\n        }\n        openedTransaction = 1;\n      }\n\n      /* Get the database meta information.\n      **\n      ** Meta values are as follows:\n      **    meta[0]   Schema cookie.  Changes with each schema change.\n      **    meta[1]   File format of schema layer.\n      **    meta[2]   Size of the page cache.\n      **    meta[3]   Largest rootpage (auto/incr_vacuum mode)\n      **    meta[4]   Db text encoding. 1:UTF-8 2:UTF-16LE 3:UTF-16BE\n      **    meta[5]   User version\n      **    meta[6]   Incremental vacuum mode\n      **    meta[7]   unused\n      **    meta[8]   unused\n      **    meta[9]   unused\n      **\n      ** Note: The #defined SQLITE_UTF* symbols in sqliteInt.h correspond to\n      ** the possible values of meta[BTREE_TEXT_ENCODING-1].\n      */\n      for ( i = 0 ; i < ArraySize( meta ) ; i++ )\n      {\n        sqlite3BtreeGetMeta( pDb.pBt, i + 1, ref meta[i] );\n      }\n      pDb.pSchema.schema_cookie = (int)meta[BTREE_SCHEMA_VERSION - 1];\n\n      /* If opening a non-empty database, check the text encoding. For the\n      ** main database, set sqlite3.enc to the encoding of the main database.\n      ** For an attached db, it is an error if the encoding is not the same\n      ** as sqlite3.enc.\n      */\n      if ( meta[BTREE_TEXT_ENCODING - 1] != 0 )\n      {  /* text encoding */\n        if ( iDb == 0 )\n        {\n          u8 encoding;\n          /* If opening the main database, set ENC(db). */\n          encoding = (u8)( meta[BTREE_TEXT_ENCODING - 1] & 3 );\n          if ( encoding == 0 ) encoding = SQLITE_UTF8;\n          db.aDb[0].pSchema.enc = encoding; //ENC( db ) = encoding;\n          db.pDfltColl = sqlite3FindCollSeq( db, SQLITE_UTF8, "BINARY", 0 );\n        }\n        else\n        {\n          /* If opening an attached database, the encoding much match ENC(db) */\n          if ( meta[BTREE_TEXT_ENCODING - 1] != ENC( db ) )\n          {\n            sqlite3SetString( ref pzErrMsg, db, "attached databases must use the same" +\n            " text encoding as main database" );\n            rc = SQLITE_ERROR;\n            goto initone_error_out;\n          }\n        }\n      }\n      else\n      {\n        DbSetProperty( db, iDb, DB_Empty );\n      }\n      pDb.pSchema.enc = ENC( db );\n\n      if ( pDb.pSchema.cache_size == 0 )\n      {\n        size = (int)meta[BTREE_DEFAULT_CACHE_SIZE - 1];\n        if ( size == 0 ) { size = SQLITE_DEFAULT_CACHE_SIZE; }\n        if ( size < 0 ) size = -size;\n        pDb.pSchema.cache_size = size;\n        sqlite3BtreeSetCacheSize( pDb.pBt, pDb.pSchema.cache_size );\n      }\n\n      /*\n      ** file_format==1    Version 3.0.0.\n      ** file_format==2    Version 3.1.3.  // ALTER TABLE ADD COLUMN\n      ** file_format==3    Version 3.1.4.  // ditto but with non-NULL defaults\n      ** file_format==4    Version 3.3.0.  // DESC indices.  Boolean constants\n      */\n      pDb.pSchema.file_format = (u8)meta[BTREE_FILE_FORMAT - 1];\n      if ( pDb.pSchema.file_format == 0 )\n      {\n        pDb.pSchema.file_format = 1;\n      }\n      if ( pDb.pSchema.file_format > SQLITE_MAX_FILE_FORMAT )\n      {\n        sqlite3SetString( ref pzErrMsg, db, "unsupported file format" );\n        rc = SQLITE_ERROR;\n        goto initone_error_out;\n      }\n\n      /* Ticket #2804:  When we open a database in the newer file format,\n      ** clear the legacy_file_format pragma flag so that a VACUUM will\n      ** not downgrade the database and thus invalidate any descending\n      ** indices that the user might have created.\n      */\n      if ( iDb == 0 && meta[BTREE_FILE_FORMAT - 1] >= 4 )\n      {\n        db.flags &= ~SQLITE_LegacyFileFmt;\n      }\n\n      /* Read the schema information out of the schema tables\n      */\n      Debug.Assert( db.init.busy != 0 );\n      {\n        string zSql;\n        zSql = sqlite3MPrintf( db,\n        "SELECT name, rootpage, sql FROM \'%q\'.%s",\n        db.aDb[iDb].zName, zMasterName );\n        sqlite3SafetyOff( db );\n#if ! SQLITE_OMIT_AUTHORIZATION\n{\nint (*xAuth)(void*,int,const char*,const char*,const char*,const char*);\nxAuth = db.xAuth;\ndb.xAuth = 0;\n#endif\n        rc = sqlite3_exec( db, zSql, (dxCallback)sqlite3InitCallback, initData, 0 );\n        pzErrMsg = initData.pzErrMsg;\n#if ! SQLITE_OMIT_AUTHORIZATION\ndb.xAuth = xAuth;\n}\n#endif\n        if ( rc == SQLITE_OK ) rc = initData.rc;\n        sqlite3SafetyOn( db );\n        //sqlite3DbFree( db, ref zSql );\n#if !SQLITE_OMIT_ANALYZE\n        if ( rc == SQLITE_OK )\n        {\n          sqlite3AnalysisLoad( db, iDb );\n        }\n#endif\n      }\n      //if ( db.mallocFailed != 0 )\n      //{\n      //  rc = SQLITE_NOMEM;\n      //  sqlite3ResetInternalSchema( db, 0 );\n      //}\n      if ( rc == SQLITE_OK || ( db.flags & SQLITE_RecoveryMode ) != 0 )\n      {\n        /* Black magic: If the SQLITE_RecoveryMode flag is set, then consider\n        ** the schema loaded, even if errors occurred. In this situation the\n        ** current sqlite3_prepare() operation will fail, but the following one\n        ** will attempt to compile the supplied statement against whatever subset\n        ** of the schema was loaded before the error occurred. The primary\n        ** purpose of this is to allow access to the sqlite_master table\n        ** even when its contents have been corrupted.\n        */\n        DbSetProperty( db, iDb, DB_SchemaLoaded );\n        rc = SQLITE_OK;\n      }\n/* Jump here for an error that occurs after successfully allocating\n** curMain and calling sqlite3BtreeEnter(). For an error that occurs\n** before that point, jump to error_out.\n*/\ninitone_error_out:\n      if ( openedTransaction != 0 )\n      {\n        sqlite3BtreeCommit( pDb.pBt );\n      }\n      sqlite3BtreeLeave( pDb.pBt );\n\nerror_out:\n      if ( rc == SQLITE_NOMEM || rc == SQLITE_IOERR_NOMEM )\n      {\n//        db.mallocFailed = 1;\n      }\n      return rc;\n    }\n\n    /*\n    ** Initialize all database files - the main database file, the file\n    ** used to store temporary tables, and any additional database files\n    ** created using ATTACH statements.  Return a success code.  If an\n    ** error occurs, write an error message into pzErrMsg.\n    **\n    ** After a database is initialized, the DB_SchemaLoaded bit is set\n    ** bit is set in the flags field of the Db structure. If the database\n    ** file was of zero-length, then the DB_Empty flag is also set.\n    */\n    static int sqlite3Init( sqlite3 db, ref string pzErrMsg )\n    {\n      int i, rc;\n      bool commit_internal = !( ( db.flags & SQLITE_InternChanges ) != 0 );\n\n      Debug.Assert( sqlite3_mutex_held( db.mutex ) );\n      rc = SQLITE_OK;\n      db.init.busy = 1;\n      for ( i = 0 ; rc == SQLITE_OK && i < db.nDb ; i++ )\n      {\n        if ( DbHasProperty( db, i, DB_SchemaLoaded ) || i == 1 ) continue;\n        rc = sqlite3InitOne( db, i, ref pzErrMsg );\n        if ( rc != 0 )\n        {\n          sqlite3ResetInternalSchema( db, i );\n        }\n      }\n\n      /* Once all the other databases have been initialised, load the schema\n      ** for the TEMP database. This is loaded last, as the TEMP database\n      ** schema may contain references to objects in other databases.\n      */\n#if !SQLITE_OMIT_TEMPDB\n      if ( rc == SQLITE_OK && ALWAYS( db.nDb > 1 )\n      && !DbHasProperty( db, 1, DB_SchemaLoaded ) )\n      {\n        rc = sqlite3InitOne( db, 1, ref pzErrMsg );\n        if ( rc != 0 )\n        {\n          sqlite3ResetInternalSchema( db, 1 );\n        }\n      }\n#endif\n\n      db.init.busy = 0;\n      if ( rc == SQLITE_OK && commit_internal )\n      {\n        sqlite3CommitInternalChanges( db );\n      }\n\n      return rc;\n    }\n\n    /*\n    ** This routine is a no-op if the database schema is already initialised.\n    ** Otherwise, the schema is loaded. An error code is returned.\n    */\n    static int sqlite3ReadSchema( Parse pParse )\n    {\n      int rc = SQLITE_OK;\n      sqlite3 db = pParse.db;\n      Debug.Assert( sqlite3_mutex_held( db.mutex ) );\n      if ( 0 == db.init.busy )\n      {\n        rc = sqlite3Init( db, ref pParse.zErrMsg );\n      }\n      if ( rc != SQLITE_OK )\n      {\n        pParse.rc = rc;\n        pParse.nErr++;\n      }\n      return rc;\n    }\n\n\n    /*\n    ** Check schema cookies in all databases.  If any cookie is out\n    ** of date set pParse->rc to SQLITE_SCHEMA.  If all schema cookies\n    ** make no changes to pParse->rc.\n    */\n    static void schemaIsValid( Parse pParse )\n    {\n      sqlite3 db = pParse.db;\n      int iDb;\n      int rc;\n      u32 cookie = 0;\n\n      Debug.Assert( pParse.checkSchema!=0 );\n      Debug.Assert( sqlite3_mutex_held( db.mutex ) );\n      for ( iDb = 0 ; iDb < db.nDb ; iDb++ )\n      {\n        int openedTransaction = 0;         /* True if a transaction is opened */\n        Btree pBt = db.aDb[iDb].pBt;     /* Btree database to read cookie from */\n        if ( pBt == null ) continue;\n\n        /* If there is not already a read-only (or read-write) transaction opened\n        ** on the b-tree database, open one now. If a transaction is opened, it \n        ** will be closed immediately after reading the meta-value. */\n        if ( !sqlite3BtreeIsInReadTrans( pBt ) )\n        {\n          rc = sqlite3BtreeBeginTrans( pBt, 0 );\n          //if ( rc == SQLITE_NOMEM || rc == SQLITE_IOERR_NOMEM )\n          //{\n          //    db.mallocFailed = 1;\n          //}\n          if ( rc != SQLITE_OK ) return;\n          openedTransaction = 1;\n        }\n\n        /* Read the schema cookie from the database. If it does not match the \n        ** value stored as part of the in the in-memory schema representation,\n        ** set Parse.rc to SQLITE_SCHEMA. */\n        sqlite3BtreeGetMeta( pBt, BTREE_SCHEMA_VERSION, ref cookie );\n        if ( cookie != db.aDb[iDb].pSchema.schema_cookie )\n        {\n          pParse.rc = SQLITE_SCHEMA;\n        }\n\n        /* Close the transaction, if one was opened. */\n        if ( openedTransaction!=0 )\n        {\n          sqlite3BtreeCommit( pBt );\n        }\n      }\n    }\n\n    /*\n    ** Convert a schema pointer into the iDb index that indicates\n    ** which database file in db.aDb[] the schema refers to.\n    **\n    ** If the same database is attached more than once, the first\n    ** attached database is returned.\n    */\n    static int sqlite3SchemaToIndex( sqlite3 db, Schema pSchema )\n    {\n      int i = -1000000;\n\n      /* If pSchema is NULL, then return -1000000. This happens when code in\n      ** expr.c is trying to resolve a reference to a transient table (i.e. one\n      ** created by a sub-select). In this case the return value of this\n      ** function should never be used.\n      **\n      ** We return -1000000 instead of the more usual -1 simply because using\n      ** -1000000 as the incorrect index into db->aDb[] is much\n      ** more likely to cause a segfault than -1 (of course there are assert()\n      ** statements too, but it never hurts to play the odds).\n      */\n      Debug.Assert( sqlite3_mutex_held( db.mutex ) );\n      if ( pSchema != null )\n      {\n        for ( i = 0 ; ALWAYS( i < db.nDb ) ; i++ )\n        {\n          if ( db.aDb[i].pSchema == pSchema )\n          {\n            break;\n          }\n        }\n        Debug.Assert( i >= 0 && i < db.nDb );\n      }\n      return i;\n    }\n\n    /*\n    ** Compile the UTF-8 encoded SQL statement zSql into a statement handle.\n    */\n    static int sqlite3Prepare(\n    sqlite3 db,               /* Database handle. */\n    string zSql,              /* UTF-8 encoded SQL statement. */\n    int nBytes,               /* Length of zSql in bytes. */\n    int saveSqlFlag,          /* True to copy SQL text into the sqlite3_stmt */\n    ref sqlite3_stmt ppStmt,  /* OUT: A pointer to the prepared statement */\n    ref string pzTail         /* OUT: End of parsed string */\n    )\n    {\n      Parse pParse;             /* Parsing context */\n      string zErrMsg = "";      /* Error message */\n      int rc = SQLITE_OK;       /* Result code */\n      int i;                    /* Loop counter */\n\n      /* Allocate the parsing context */\n      pParse = new Parse();//sqlite3StackAllocZero(db, sizeof(*pParse));\n      if ( pParse == null )\n      {\n        rc = SQLITE_NOMEM;\n        goto end_prepare;\n      }\n      pParse.sLastToken.z = "";\n      if ( sqlite3SafetyOn( db ) )\n      {\n        rc = SQLITE_MISUSE;\n        goto end_prepare;\n      }\n      Debug.Assert( ppStmt == null );//  assert( ppStmt && *ppStmt==0 );\n      //Debug.Assert( 0 == db.mallocFailed );\n      Debug.Assert( sqlite3_mutex_held( db.mutex ) );\n\n      /* Check to verify that it is possible to get a read lock on all\n      ** database schemas.  The inability to get a read lock indicates that\n      ** some other database connection is holding a write-lock, which in\n      ** turn means that the other connection has made uncommitted changes\n      ** to the schema.\n      **\n      ** Were we to proceed and prepare the statement against the uncommitted\n      ** schema changes and if those schema changes are subsequently rolled\n      ** back and different changes are made in their place, then when this\n      ** prepared statement goes to run the schema cookie would fail to detect\n      ** the schema change.  Disaster would follow.\n      **\n      ** This thread is currently holding mutexes on all Btrees (because\n      ** of the sqlite3BtreeEnterAll() in sqlite3LockAndPrepare()) so it\n      ** is not possible for another thread to start a new schema change\n      ** while this routine is running.  Hence, we do not need to hold\n      ** locks on the schema, we just need to make sure nobody else is\n      ** holding them.\n      **\n      ** Note that setting READ_UNCOMMITTED overrides most lock detection,\n      ** but it does *not* override schema lock detection, so this all still\n      ** works even if READ_UNCOMMITTED is set.\n      */\n      for ( i = 0 ; i < db.nDb ; i++ )\n      {\n        Btree pBt = db.aDb[i].pBt;\n        if ( pBt != null )\n        {\n          Debug.Assert( sqlite3BtreeHoldsMutex( pBt ) );\n          rc = sqlite3BtreeSchemaLocked( pBt );\n          if ( rc != 0 )\n          {\n            string zDb = db.aDb[i].zName;\n            sqlite3Error( db, rc, "database schema is locked: %s", zDb );\n            sqlite3SafetyOff( db );\n            testcase( db.flags & SQLITE_ReadUncommitted );\n            goto end_prepare;\n          }\n        }\n      }\n\n      sqlite3VtabUnlockList( db );\n\n      pParse.db = db;\n      if ( nBytes >= 0 && ( nBytes == 0 || zSql[nBytes - 1] != 0 ) )\n      {\n        string zSqlCopy;\n        int mxLen = db.aLimit[SQLITE_LIMIT_SQL_LENGTH];\n        testcase( nBytes == mxLen );\n        testcase( nBytes == mxLen + 1 );\n        if ( nBytes > mxLen )\n        {\n          sqlite3Error( db, SQLITE_TOOBIG, "statement too long" );\n          sqlite3SafetyOff( db );\n          rc = sqlite3ApiExit( db, SQLITE_TOOBIG );\n          goto end_prepare;\n        }\n        zSqlCopy = zSql.Substring( 0, nBytes );// sqlite3DbStrNDup(db, zSql, nBytes);\n        if ( zSqlCopy != null )\n        {\n          sqlite3RunParser( pParse, zSqlCopy, ref zErrMsg );\n          //sqlite3DbFree( db, ref zSqlCopy );\n          //pParse->zTail = &zSql[pParse->zTail-zSqlCopy];\n        }\n        else\n        {\n          //pParse->zTail = &zSql[nBytes];\n        }\n      }\n      else\n      {\n        sqlite3RunParser( pParse, zSql, ref zErrMsg );\n      }\n\n      //if ( db.mallocFailed != 0 )\n      //{\n      //  pParse.rc = SQLITE_NOMEM;\n      //}\n      if ( pParse.rc == SQLITE_DONE ) pParse.rc = SQLITE_OK;\n      if ( pParse.checkSchema != 0)\n      {\n        schemaIsValid( pParse );\n      }\n      if ( pParse.rc == SQLITE_SCHEMA )\n      {\n        sqlite3ResetInternalSchema( db, 0 );\n      }\n      //if ( db.mallocFailed != 0 )\n      //{\n      //  pParse.rc = SQLITE_NOMEM;\n      //}\n      //if (pzTail != null)\n      {\n        pzTail = pParse.zTail == null ? "" : pParse.zTail.ToString();\n      }\n      rc = pParse.rc;\n#if !SQLITE_OMIT_EXPLAIN\n      if ( rc == SQLITE_OK && pParse.pVdbe != null && pParse.explain != 0 )\n      {\n        string[] azColName = new string[] {\n"addr", "opcode", "p1", "p2", "p3", "p4", "p5", "comment",\n"order", "from", "detail"\n};\n        int iFirst, mx;\n        if ( pParse.explain == 2 )\n        {\n          sqlite3VdbeSetNumCols( pParse.pVdbe, 3 );\n          iFirst = 8;\n          mx = 11;\n        }\n        else\n        {\n          sqlite3VdbeSetNumCols( pParse.pVdbe, 8 );\n          iFirst = 0;\n          mx = 8;\n        }\n        for ( i = iFirst ; i < mx ; i++ )\n        {\n          sqlite3VdbeSetColName( pParse.pVdbe, i - iFirst, COLNAME_NAME,\n                azColName[i], SQLITE_STATIC );\n        }\n      }\n#endif\n\n      if ( sqlite3SafetyOff( db ) )\n      {\n        rc = SQLITE_MISUSE;\n      }\n\n      Debug.Assert( db.init.busy == 0 || saveSqlFlag == 0 );\n      if ( db.init.busy == 0 )\n      {\n        Vdbe pVdbe = pParse.pVdbe;\n        sqlite3VdbeSetSql( pVdbe, zSql, (int)( zSql.Length - ( pParse.zTail == null ? 0 : pParse.zTail.Length ) ), saveSqlFlag );\n      }\n      if ( pParse.pVdbe != null && ( rc != SQLITE_OK /*|| db.mallocFailed != 0 */ ) )\n      {\n        sqlite3VdbeFinalize( pParse.pVdbe );\n        Debug.Assert( ppStmt == null );\n      }\n      else\n      {\n        ppStmt = pParse.pVdbe;\n      }\n\n      if ( zErrMsg != "" )\n      {\n        sqlite3Error( db, rc, "%s", zErrMsg );\n        //sqlite3DbFree( db, ref zErrMsg );\n      }\n      else\n      {\n        sqlite3Error( db, rc, 0 );\n      }\n\nend_prepare:\n\n      //sqlite3StackFree( db, pParse );\n      rc = sqlite3ApiExit( db, rc );\n      Debug.Assert( ( rc & db.errMask ) == rc );\n      return rc;\n    }\n\n    static int sqlite3LockAndPrepare(\n    sqlite3 db,               /* Database handle. */\n    string zSql,              /* UTF-8 encoded SQL statement. */\n    int nBytes,               /* Length of zSql in bytes. */\n    int saveSqlFlag,         /* True to copy SQL text into the sqlite3_stmt */\n    ref sqlite3_stmt ppStmt,  /* OUT: A pointer to the prepared statement */\n    ref string pzTail         /* OUT: End of parsed string */\n    )\n    {\n      int rc;\n      //  assert( ppStmt!=0 );\n      ppStmt = null;\n      if ( !sqlite3SafetyCheckOk( db ) )\n      {\n        return SQLITE_MISUSE;\n      }\n      sqlite3_mutex_enter( db.mutex );\n      sqlite3BtreeEnterAll( db );\n      rc = sqlite3Prepare( db, zSql, nBytes, saveSqlFlag, ref ppStmt, ref pzTail );\n      if ( rc == SQLITE_SCHEMA )\n      {\n        sqlite3_finalize( ref ppStmt );\n        rc = sqlite3Prepare( db, zSql, nBytes, saveSqlFlag, ref ppStmt, ref  pzTail );\n      }\n      sqlite3BtreeLeaveAll( db );\n      sqlite3_mutex_leave( db.mutex );\n      return rc;\n    }\n\n    /*\n    ** Rerun the compilation of a statement after a schema change.\n    **\n    ** If the statement is successfully recompiled, return SQLITE_OK. Otherwise,\n    ** if the statement cannot be recompiled because another connection has\n    ** locked the sqlite3_master table, return SQLITE_LOCKED. If any other error\n    ** occurs, return SQLITE_SCHEMA.\n    */\n    static int sqlite3Reprepare( Vdbe p )\n    {\n      int rc;\n      sqlite3_stmt pNew = new sqlite3_stmt();\n      string zSql;\n      sqlite3 db;\n\n      Debug.Assert( sqlite3_mutex_held( sqlite3VdbeDb( p ).mutex ) );\n      zSql = sqlite3_sql( (sqlite3_stmt)p );\n      Debug.Assert( zSql != null );  /* Reprepare only called for prepare_v2() statements */\n      db = sqlite3VdbeDb( p );\n      Debug.Assert( sqlite3_mutex_held( db.mutex ) );\n      string dummy = "";\n      rc = sqlite3LockAndPrepare( db, zSql, -1, 1, ref pNew, ref dummy );\n      if ( rc != 0 )\n      {\n        if ( rc == SQLITE_NOMEM )\n        {\n  //        db.mallocFailed = 1;\n        }\n        Debug.Assert( pNew == null );\n        return ( rc == SQLITE_LOCKED ) ? SQLITE_LOCKED : SQLITE_SCHEMA;\n      }\n      else\n      {\n        Debug.Assert( pNew != null );\n      }\n      sqlite3VdbeSwap( (Vdbe)pNew, p );\n      sqlite3TransferBindings( pNew, (sqlite3_stmt)p );\n      sqlite3VdbeResetStepResult( (Vdbe)pNew );\n      sqlite3VdbeFinalize( (Vdbe)pNew );\n      return SQLITE_OK;\n    }\n\n\n    /*\n    ** Two versions of the official API.  Legacy and new use.  In the legacy\n    ** version, the original SQL text is not saved in the prepared statement\n    ** and so if a schema change occurs, SQLITE_SCHEMA is returned by\n    ** sqlite3_step().  In the new version, the original SQL text is retained\n    ** and the statement is automatically recompiled if an schema change\n    ** occurs.\n    */\n    public static int sqlite3_prepare(\n    sqlite3 db,           /* Database handle. */\n    string zSql,          /* UTF-8 encoded SQL statement. */\n    int nBytes,           /* Length of zSql in bytes. */\n    ref sqlite3_stmt ppStmt,  /* OUT: A pointer to the prepared statement */\n    ref string pzTail         /* OUT: End of parsed string */\n    )\n    {\n      int rc;\n      rc = sqlite3LockAndPrepare( db, zSql, nBytes, 0, ref  ppStmt, ref pzTail );\n      Debug.Assert( rc == SQLITE_OK || ppStmt == null );  /* VERIFY: F13021 */\n      return rc;\n    }\n    public static int sqlite3_prepare_v2(\n    sqlite3 db,               /* Database handle. */\n    string zSql,              /* UTF-8 encoded SQL statement. */\n    int nBytes,               /* Length of zSql in bytes. */\n    ref sqlite3_stmt ppStmt,  /* OUT: A pointer to the prepared statement */\n    int dummy /* ( No string passed) */\n    )\n    {\n      string pzTail = null;\n      int rc;\n      rc = sqlite3LockAndPrepare( db, zSql, nBytes, 1, ref  ppStmt, ref pzTail );\n      Debug.Assert( rc == SQLITE_OK || ppStmt == null );  /* VERIFY: F13021 */\n      return rc;\n    }\n    public static int sqlite3_prepare_v2(\n    sqlite3 db,               /* Database handle. */\n    string zSql,              /* UTF-8 encoded SQL statement. */\n    int nBytes,               /* Length of zSql in bytes. */\n    ref sqlite3_stmt ppStmt,  /* OUT: A pointer to the prepared statement */\n    ref string pzTail         /* OUT: End of parsed string */\n    )\n    {\n      int rc;\n      rc = sqlite3LockAndPrepare( db, zSql, nBytes, 1, ref  ppStmt, ref pzTail );\n      Debug.Assert( rc == SQLITE_OK || ppStmt == null );  /* VERIFY: F13021 */\n      return rc;\n    }\n\n\n#if ! SQLITE_OMIT_UTF16\n\n/*\n** Compile the UTF-16 encoded SQL statement zSql into a statement handle.\n*/\nstatic int sqlite3Prepare16(\nsqlite3 db,              /* Database handle. */\nstring zSql,             /* UTF-8 encoded SQL statement. */\nint nBytes,              /* Length of zSql in bytes. */\nbool saveSqlFlag,         /* True to save SQL text into the sqlite3_stmt */\nref sqlite3_stmt ppStmt, /* OUT: A pointer to the prepared statement */\nref string pzTail        /* OUT: End of parsed string */\n){\n/* This function currently works by first transforming the UTF-16\n** encoded string to UTF-8, then invoking sqlite3_prepare(). The\n** tricky bit is figuring out the pointer to return in pzTail.\n*/\nstring zSql8;\nstring zTail8 = "";\nint rc = SQLITE_OK;\n\nassert( ppStmt );\n*ppStmt = 0;\nif( !sqlite3SafetyCheckOk(db) ){\nreturn SQLITE_MISUSE;\n}\nsqlite3_mutex_enter(db.mutex);\nzSql8 = sqlite3Utf16to8(db, zSql, nBytes);\nif( zSql8 !=""){\nrc = sqlite3LockAndPrepare(db, zSql8, -1, saveSqlFlag, ref ppStmt, ref zTail8);\n}\n\nif( zTail8 !="" && pzTail !=""){\n/* If sqlite3_prepare returns a tail pointer, we calculate the\n** equivalent pointer into the UTF-16 string by counting the unicode\n** characters between zSql8 and zTail8, and then returning a pointer\n** the same number of characters into the UTF-16 string.\n*/\nDebugger.Break (); // TODO --\n//  int chars_parsed = sqlite3Utf8CharLen(zSql8, (int)(zTail8-zSql8));\n//  pzTail = (u8 *)zSql + sqlite3Utf16ByteLen(zSql, chars_parsed);\n}\n//sqlite3DbFree(db,ref zSql8);\nrc = sqlite3ApiExit(db, rc);\nsqlite3_mutex_leave(db.mutex);\nreturn rc;\n}\n\n/*\n** Two versions of the official API.  Legacy and new use.  In the legacy\n** version, the original SQL text is not saved in the prepared statement\n** and so if a schema change occurs, SQLITE_SCHEMA is returned by\n** sqlite3_step().  In the new version, the original SQL text is retained\n** and the statement is automatically recompiled if an schema change\n** occurs.\n*/\npublic static int sqlite3_prepare16(\nsqlite3 db,               /* Database handle. */\nstring zSql,              /* UTF-8 encoded SQL statement. */\nint nBytes,               /* Length of zSql in bytes. */\nref sqlite3_stmt ppStmt,  /* OUT: A pointer to the prepared statement */\nref string pzTail         /* OUT: End of parsed string */\n){\nint rc;\nrc = sqlite3Prepare16(db,zSql,nBytes,false,ref ppStmt,ref pzTail);\nDebug.Assert( rc==SQLITE_OK || ppStmt==null || ppStmt==null );  /* VERIFY: F13021 */\nreturn rc;\n}\npublic static int sqlite3_prepare16_v2(\nsqlite3 db,               /* Database handle. */\nstring zSql,              /* UTF-8 encoded SQL statement. */\nint nBytes,               /* Length of zSql in bytes. */\nref sqlite3_stmt ppStmt,  /* OUT: A pointer to the prepared statement */\nref string pzTail         /* OUT: End of parsed string */\n)\n{\nint rc;\nrc = sqlite3Prepare16(db,zSql,nBytes,true,ref ppStmt,ref pzTail);\nDebug.Assert( rc==SQLITE_OK || ppStmt==null || ppStmt==null );  /* VERIFY: F13021 */\nreturn rc;\n}\n\n#endif // * SQLITE_OMIT_UTF16 */\n  }\n}\n'