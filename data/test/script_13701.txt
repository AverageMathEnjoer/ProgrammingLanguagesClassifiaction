b'{-# LANGUAGE NoImplicitPrelude #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n{-# LANGUAGE OverloadedStrings #-}\n\nmodule Course.Interactive where\n\nimport Course.Core\nimport Course.Functor\nimport Course.Applicative\nimport Course.Monad\nimport Course.Traversable\nimport Course.List\nimport Course.Optional\n\n-- | Eliminates any value over which a functor is defined.\nvooid ::\n  Functor m =>\n  m a\n  -> m ()\nvooid =\n  (<$>) (const ())\n\n-- | A version of @bind@ that ignores the result of the effect.\n(>-) ::\n  Monad m =>\n  m a\n  -> m b\n  -> m b\n(>-) a =\n  (>>=) a . const\n\n-- | Runs an action until a result of that action satisfies a given predicate.\nuntilM ::\n  Monad m =>\n  (a -> m Bool) -- ^ The predicate to satisfy to stop running the action.\n  -> m a -- ^ The action to run until the predicate satisfies.\n  -> m a\nuntilM p a =\n  a >>= \\r ->\n  p r >>= \\q ->\n  if q\n    then\n      pure r\n    else\n      untilM p a\n\n-- | Example program that uses IO to echo back characters that are entered by the user.\necho ::\n  IO ()\necho =\n  vooid (untilM\n          (\\c ->\n            if c == \'q\'\n              then\n                putStrLn "Bye!" >-\n                pure True\n              else\n                pure False)\n          (putStr "Enter a character: " >-\n           getChar >>= \\c ->\n           putStrLn "" >-\n           putStrLn (c :. Nil) >-\n           pure c))\n\ndata Op =\n  Op Char Chars (IO ()) -- keyboard entry, description, program\n\n-- |\n--\n-- * Ask the user to enter a string to convert to upper-case.\n--\n-- * Convert the string to upper-case.\n--\n-- * Print the upper-cased string to standard output.\n--\n-- /Tip:/ @getLine :: IO String@ -- an IO action that reads a string from standard input.\n--\n-- /Tip:/ @toUpper :: Char -> Char@ -- (Data.Char) converts a character to upper-case.\n--\n-- /Tip:/ @putStr :: String -> IO ()@ -- Prints a string to standard output.\n--\n-- /Tip:/ @putStrLn :: String -> IO ()@ -- Prints a string and then a new line to standard output.\nconvertInteractive ::\n  IO ()\nconvertInteractive =\n  error "todo: Course.Interactive#convertInteractive"\n\n-- |\n--\n-- * Ask the user to enter a file name to reverse.\n--\n-- * Ask the user to enter a file name to write the reversed file to.\n--\n-- * Read the contents of the input file.\n--\n-- * Reverse the contents of the input file.\n--\n-- * Write the reversed contents to the output file.\n--\n-- /Tip:/ @getLine :: IO String@ -- an IO action that reads a string from standard input.\n--\n-- /Tip:/ @readFile :: FilePath -> IO String@ -- an IO action that reads contents of a file.\n--\n-- /Tip:/ @writeFile :: FilePath -> String -> IO ()@ -- writes a string to a file.\n--\n-- /Tip:/ @reverse :: [a] -> [a]@ -- reverses a list.\n--\n-- /Tip:/ @putStr :: String -> IO ()@ -- Prints a string to standard output.\n--\n-- /Tip:/ @putStrLn :: String -> IO ()@ -- Prints a string and then a new line to standard output.\nreverseInteractive ::\n  IO ()\nreverseInteractive =\n  error "todo: Course.Interactive#reverseInteractive"\n\n-- |\n--\n-- * Ask the user to enter a string to url-encode.\n--\n-- * Convert the string with a URL encoder.\n--\n-- * For simplicity, encoding is defined as:\n--\n-- * @\' \' -> \\"%20\\"@\n--\n-- * @\'\\t\' -> \\"%09\\"@\n--\n-- * @\'\\"\' -> \\"%22\\"@\n--\n-- * @/anything else is unchanged/@\n--\n-- * Print the encoded URL to standard output.\n--\n-- /Tip:/ @putStr :: String -> IO ()@ -- Prints a string to standard output.\n--\n-- /Tip:/ @putStrLn :: String -> IO ()@ -- Prints a string and then a new line to standard output.\nencodeInteractive ::\n  IO ()\nencodeInteractive =\n  error "todo: Course.Interactive#encodeInteractive"\n\ninteractive ::\n  IO ()\ninteractive =\n  let ops = (\n               Op \'c\' "Convert a string to upper-case" convertInteractive\n            :. Op \'r\' "Reverse a file" reverseInteractive\n            :. Op \'e\' "Encode a URL" encodeInteractive\n            :. Op \'q\' "Quit" (pure ())\n            :. Nil\n            )\n  in vooid (untilM\n             (\\c ->\n               if c == \'q\'\n                 then\n                   putStrLn "Bye!" >-\n                   pure True\n                 else\n                   pure False)\n             (putStrLn "Select: " >-\n              traverse (\\(Op c s _) ->\n                putStr (c :. Nil) >-\n                putStr ". " >-\n                putStrLn s) ops >-\n              getChar >>= \\c ->\n              putStrLn "" >-\n              let o = find (\\(Op c\' _ _) -> c\' == c) ops\n                  r = case o of\n                        Empty -> (putStrLn "Not a valid selection. Try again." >-)\n                        Full (Op _ _ k) -> (k >-)\n              in r (pure c)))\n'