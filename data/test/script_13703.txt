b'{-# LANGUAGE\n    CPP\n  , FlexibleInstances\n  , TypeSynonymInstances\n  , UndecidableInstances\n  #-}\n#if !MIN_VERSION_base(4,8,0)\n{-# LANGUAGE OverlappingInstances #-}\n#endif\nmodule Code.Build where\n\nimport Data.List\n\n-- | Representation of code, each string represents a line\nnewtype Code = Code { unCode :: [String] }\n\nshowCode :: Code -> String\nshowCode = intercalate "\\n" . unCode\n\n-- | Type class for lifting data structures into code\nclass Codeable a where\n  code :: a -> Code\n\ninstance Codeable Code where\n  code = id\n\ninstance {-# OVERLAPPING #-} Codeable String where\n  code = Code . (:[])\n\ninstance Codeable a => Codeable (Maybe a) where\n  code = maybe noCode code\n\ninstance {-# OVERLAPPABLE #-} Show a => Codeable a where\n  code = Code . (:[]) . show\n\nclass CodeList a where\n  codeList :: a -> [Code]\n\ninstance {-# OVERLAPPABLE #-} Codeable a => CodeList a where\n  codeList = (:[]) . code\n\ninstance {-# OVERLAPPING #-} Codeable a => CodeList [a] where\n  codeList = map code\n\n-- * Functions on code\nnoCode :: Code\nnoCode = Code []\n\nline :: Code\nline = Code [""]\n\nisNull :: Codeable a => a -> Bool\nisNull = null . unCode . code\n\nnumLines :: CodeList a => a -> Int\nnumLines = length . unCode . mkStack . codeList\n\nsingleLine :: CodeList a => a -> Bool\nsingleLine = (==1) . numLines\n\nindent :: Codeable a => Int -> a -> Code\nindent n = Code . map (replicate n \' \' ++) . unCode . code\n\nsurround :: Codeable a => String -> String -> a -> Code\nsurround l r a = l <+> a <+> r\n\nparenthesis :: Codeable a => a -> Code\nparenthesis = surround "(" ")"\n\naccolades :: Codeable a => a -> Code\naccolades = surround "{" "}"\n\nsquare :: Codeable a => a -> Code\nsquare = surround "[" "]"\n\nalign :: Codeable a => a -> Code\nalign v = Code . map addWhite . unCode . code $ v\n    where addWhite l = l ++ replicate (codeWidth v - length l) \' \'\n\ncodeWidth :: Codeable a => a -> Int\ncodeWidth = foldr (max . length) 0 . unCode . code\n\ncodeLines :: Codeable a => a -> [Code]\ncodeLines = map (Code . (:[])) . unCode . code\n\nmany :: Codeable a => a -> Code\nmany = Code . concat . repeat . unCode . code\n\nmkSequence :: Codeable a => [a] -> Code\nmkSequence = foldl (<+>) noCode . map code\n\nmkStack :: Codeable a => [a] -> Code\nmkStack = foldl (<->) noCode . map code\n\ninterleave :: (Codeable a, CodeList l) => a -> l -> Code\ninterleave c l =\n  case codeList l of\n    []      -> noCode\n    [x]     -> x\n    (x: xs) -> x <+> code c <+> interleave c xs\n\n-- * Combinators for building blocks of code\ninfixl 4 <+>\ninfixl 4 <++>\ninfixl 4 <+|\n\ninfixl 3 |>+<|\ninfixl 3 |><|\ninfixl 3 ><\ninfixl 3 |><\ninfixl 3 ><|\n\ninfixl 2 <->\n\n-- | Join two blocks line by line, in the way of inner join, so both lines have to be present.\n(|><|) :: (Codeable a, Codeable b) => a -> b -> Code\na |><| b = Code $ zipWith (++) ca cb\n        where ca = unCode . code $ a\n              cb = unCode . code $ b\n\n-- | Join two blocks line by line, in the way of outer join, so both missing lines are discarded.\n(><) :: (Codeable a, Codeable b) => a -> b -> Code\na >< b = a <-> mkStack (replicate ((numLines (code b) - numLines (code a)) `max` 0) line) |><| b <-> mkStack (replicate ((numLines (code a) - numLines (code b)) `max` 0) line)\n\n-- | Left outer-join\n(|><) :: (Codeable a, Codeable b) => a -> b -> Code\na |>< b = a <-> mkStack (replicate ((numLines (code b) - numLines (code a)) `max` 0) line) |><| b\n\n-- | Right outer-join\n(><|) :: (Codeable a, Codeable b) => a -> b -> Code\na ><| b = a |><| b <-> mkStack (replicate ((numLines (code a) - numLines (code b)) `max` 0) line)\n\n-- | Sequencing. Place the second block after the last line of the first block. Aligns the second block\n(<+>) :: (Codeable a, Codeable b) => a -> b -> Code\na <+> b =\n  case ca of\n    [] -> code b\n    ls -> case cb of\n            []        -> code a\n            (bl: bls) -> Code $ init ls ++ [last ls ++ bl] ++ bls\n  where ca = unCode . code $ a\n        cb = unCode . code $ b\n\n-- | Same as <++> but with space\n(<++>) :: (Codeable a, Codeable b) => a -> b -> Code\na <++> b\n  | empty a = code b\n  | empty b = code a\n  | otherwise = a <+> " " <+> b\n    where\n     empty x = all (== "") (unCode (code x))\n\n-- | Place the second block after the last line of the first block. Aligns the second block\n(<+|) :: (Codeable a, Codeable b) => a -> b -> Code\na <+| b =\n  case ca of\n    [] -> code b\n    ls -> case cb of\n            []        -> code a\n            (bl: bls) -> Code $ init ls ++ [last ls ++ bl] ++ map (replicate (length $ last ls) \' \' ++) bls\n  where ca = unCode . code $ a\n        cb = unCode . code $ b\n\n-- | Combination of join and sequence. The code blocks in the second argument are sequenced with the first argument.\n(|>+<|) :: (Codeable a, CodeList b) => a -> b -> Code\na |>+<| b = mkStack $ zipWith (<+|) (codeLines a) (codeList b)\n\n-- | Place two pieces of code under each other\n(<->) :: (Codeable a, Codeable b) => a -> b -> Code\na <-> b = Code $ unCode (code a) ++ unCode (code b)\n'