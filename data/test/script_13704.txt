b'/*\n    SPDX-FileCopyrightText: 2017 Maxim Golov <maxim.golov@gmail.com>\n\n    SPDX-License-Identifier: LGPL-2.1-or-later\n*/\n\n#include <atomic>\n#include <errno.h>\n#include <pthread.h>\n#include <signal.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n\nstd::atomic<bool> g_exit(false);\n\nvoid* run_signal_thread(void*)\n{\n    // Unblock interesting signals for this thread only\n    sigset_t mask;\n    sigemptyset(&mask);\n    sigaddset(&mask, SIGQUIT);\n    sigaddset(&mask, SIGINT);\n    sigaddset(&mask, SIGTERM);\n\n    if (sigprocmask(SIG_SETMASK, &mask, nullptr) < 0) {\n        perror("failed to set signal mask");\n        abort();\n    }\n\n    timespec timeout;\n    timeout.tv_sec = 0;\n    timeout.tv_nsec = 100 * 1000 * 1000;\n\n    do {\n        int sig = sigtimedwait(&mask, nullptr, &timeout);\n        if (sig < 0) {\n            if (errno == EINTR || errno == EAGAIN) {\n                continue;\n            } else {\n                perror("signal wait failed");\n                abort();\n            }\n        } else if (sig == SIGQUIT || sig == SIGINT || sig == SIGTERM) {\n            g_exit = true;\n        }\n    } while (!g_exit);\n\n    return nullptr;\n}\n\nint main()\n{\n    pthread_t signal_thread;\n\n    // when tracked by heaptrack, this will initialize our background thread\n    // without the signal mask set. thus this thread will handle the signal\n    // and kill the whole application then\n    char* p = new char[1000];\n\n    // block all signals for this thread\n    sigset_t mask;\n    sigfillset(&mask);\n    int ret = pthread_sigmask(SIG_SETMASK, &mask, nullptr);\n    if (ret < 0) {\n        perror("failed to block signals");\n        abort();\n    }\n\n    ret = pthread_create(&signal_thread, nullptr, &run_signal_thread, nullptr);\n    if (ret < 0) {\n        perror("failed to create signal handler thread");\n        abort();\n    }\n\n    fprintf(stderr, "Started, press Ctrl-C to abort\\n");\n\n    // main loop\n    while (!g_exit) {\n        usleep(1000 * 1000);\n    }\n\n    fprintf(stderr, "Interrupted\\n");\n\n    ret = pthread_join(signal_thread, nullptr);\n    if (ret < 0) {\n        perror("failed to join the signal handler thread");\n        abort();\n    }\n\n    delete[] p;\n\n    fprintf(stderr, "Done.\\n");\n\n    return 0;\n}\n'