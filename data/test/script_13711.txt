b'using System;\nusing System.Diagnostics;\nusing System.Threading;\n\nnamespace CS_SQLite3\n{\n  public partial class CSSQLite\n  {\n    /*\n    ** 2007 August 14\n    **\n    ** The author disclaims copyright to this source code.  In place of\n    ** a legal notice, here is a blessing:\n    **\n    **    May you do good and not evil.\n    **    May you find forgiveness for yourself and forgive others.\n    **    May you share freely, never taking more than you give.\n    **\n    *************************************************************************\n    ** This file contains the C functions that implement mutexes for win32\n    **\n    ** $Id: mutex_w32.c,v 1.18 2009/08/10 03:23:21 shane Exp $\n    **\n    *************************************************************************\n    **  Included in SQLite3 port to C#-SQLite;  2008 Noah B Hart\n    **  C#-SQLite is an independent reimplementation of the SQLite software library\n    **\n    **  $Header$\n    *************************************************************************\n    */\n    //#include "sqliteInt.h"\n\n    /*\n    ** The code in this file is only used if we are compiling multithreaded\n    ** on a win32 system.\n    */\n#if SQLITE_MUTEX_W32\n\n\n/*\n** Each recursive mutex is an instance of the following structure.\n*/\nstruct sqlite3_mutex {\nCRITICAL_SECTION mutex;    /* Mutex controlling the lock */\nint id;                    /* Mutex type */\nint nRef;                  /* Number of enterances */\nDWORD owner;               /* Thread holding this mutex */\n};\n\n/*\n** Return true (non-zero) if we are running under WinNT, Win2K, WinXP,\n** or WinCE.  Return false (zero) for Win95, Win98, or WinME.\n**\n** Here is an interesting observation:  Win95, Win98, and WinME lack\n** the LockFileEx() API.  But we can still statically link against that\n** API as long as we don\'t call it win running Win95/98/ME.  A call to\n** this routine is used to determine if the host is Win95/98/ME or\n** WinNT/2K/XP so that we will know whether or not we can safely call\n** the LockFileEx() API.\n**\n** mutexIsNT() is only used for the TryEnterCriticalSection() API call,\n** which is only available if your application was compiled with\n** _WIN32_WINNT defined to a value >= 0x0400.  Currently, the only\n** call to TryEnterCriticalSection() is #ifdef\'ed out, so #if\n** this out as well.\n*/\n#if FALSE\n#if SQLITE_OS_WINCE\n//# define mutexIsNT()  (1)\n#else\nstatic int mutexIsNT(void){\nstatic int osType = 0;\nif( osType==0 ){\nOSVERSIONINFO sInfo;\nsInfo.dwOSVersionInfoSize = sizeof(sInfo);\nGetVersionEx(&sInfo);\nosType = sInfo.dwPlatformId==VER_PLATFORM_WIN32_NT ? 2 : 1;\n}\nreturn osType==2;\n}\n#endif //* SQLITE_OS_WINCE */\n#endif\n\n#if SQLITE_DEBUG\n/*\n** The sqlite3_mutex_held() and sqlite3_mutex_notheld() routine are\n** intended for use only inside Debug.Assert() statements.\n*/\nstatic int winMutexHeld(sqlite3_mutex p){\nreturn p.nRef!=0 && p.owner==GetCurrentThreadId();\n}\nstatic int winMutexNotheld(sqlite3_mutex p){\nreturn p.nRef==0 || p.owner!=GetCurrentThreadId();\n}\n#endif\n\n\n/*\n** Initialize and deinitialize the mutex subsystem.\n*/\nstatic sqlite3_mutex winMutex_staticMutexes[6];\nstatic int winMutex_isInit = 0;\n/* As winMutexInit() and winMutexEnd() are called as part\n** of the sqlite3_initialize and sqlite3_shutdown()\n** processing, the "interlocked" magic is probably not\n** strictly necessary.\n*/\nstatic long winMutex_lock = 0;\n\nstatic int winMutexInit(void){\n/* The first to increment to 1 does actual initialization */\nif( InterlockedCompareExchange(winMutex_lock, 1, 0)==0 ){\nint i;\nfor(i=0; i<sizeof(winMutex_staticMutexes)/sizeof(winMutex_staticMutexes[0]); i++){\nInitializeCriticalSection(&winMutex_staticMutexes[i].mutex);\n}\nwinMutex_isInit = 1;\n}else{\n/* Someone else is in the process of initing the static mutexes */\nwhile( !winMutex_isInit ){\nSleep(1);\n}\n}\nreturn SQLITE_OK;\n}\n\nstatic int winMutexEnd(void){\n/* The first to decrement to 0 does actual shutdown\n** (which should be the last to shutdown.) */\nif( InterlockedCompareExchange(winMutex_lock, 0, 1)==1 ){\nif( winMutex_isInit==1 ){\nint i;\nfor(i=0; i<sizeof(winMutex_staticMutexes)/sizeof(winMutex_staticMutexes[0]); i++){\nDeleteCriticalSection(&winMutex_staticMutexes[i].mutex);\n}\nwinMutex_isInit = 0;\n}\n}\nreturn SQLITE_OK;\n}\n\n/*\n** The sqlite3_mutex_alloc() routine allocates a new\n** mutex and returns a pointer to it.  If it returns NULL\n** that means that a mutex could not be allocated.  SQLite\n** will unwind its stack and return an error.  The argument\n** to sqlite3_mutex_alloc() is one of these integer constants:\n**\n** <ul>\n** <li>  SQLITE_MUTEX_FAST               0\n** <li>  SQLITE_MUTEX_RECURSIVE          1\n** <li>  SQLITE_MUTEX_STATIC_MASTER      2\n** <li>  SQLITE_MUTEX_STATIC_MEM         3\n** <li>  SQLITE_MUTEX_STATIC_PRNG        4\n** </ul>\n**\n** The first two constants cause sqlite3_mutex_alloc() to create\n** a new mutex.  The new mutex is recursive when SQLITE_MUTEX_RECURSIVE\n** is used but not necessarily so when SQLITE_MUTEX_FAST is used.\n** The mutex implementation does not need to make a distinction\n** between SQLITE_MUTEX_RECURSIVE and SQLITE_MUTEX_FAST if it does\n** not want to.  But SQLite will only request a recursive mutex in\n** cases where it really needs one.  If a faster non-recursive mutex\n** implementation is available on the host platform, the mutex subsystem\n** might return such a mutex in response to SQLITE_MUTEX_FAST.\n**\n** The other allowed parameters to sqlite3_mutex_alloc() each return\n** a pointer to a static preexisting mutex.  Three static mutexes are\n** used by the current version of SQLite.  Future versions of SQLite\n** may add additional static mutexes.  Static mutexes are for internal\n** use by SQLite only.  Applications that use SQLite mutexes should\n** use only the dynamic mutexes returned by SQLITE_MUTEX_FAST or\n** SQLITE_MUTEX_RECURSIVE.\n**\n** Note that if one of the dynamic mutex parameters (SQLITE_MUTEX_FAST\n** or SQLITE_MUTEX_RECURSIVE) is used then sqlite3_mutex_alloc()\n** returns a different mutex on every call.  But for the static\n** mutex types, the same mutex is returned on every call that has\n** the same type number.\n*/\nstatic sqlite3_mutex *winMutexAlloc(int iType){\nsqlite3_mutex p;\n\nswitch( iType ){\ncase SQLITE_MUTEX_FAST:\ncase SQLITE_MUTEX_RECURSIVE: {\np = sqlite3MallocZero( sizeof(*p) );\nif( p ){\np.id = iType;\nInitializeCriticalSection(p.mutex);\n}\nbreak;\n}\ndefault: {\nDebug.Assert( winMutex_isInit==1 );\nDebug.Assert(iType-2 >= 0 );\nassert( iType-2 < sizeof(winMutex_staticMutexes)/sizeof(winMutex_staticMutexes[0]) );\np = &winMutex_staticMutexes[iType-2];\np.id = iType;\nbreak;\n}\n}\nreturn p;\n}\n\n\n/*\n** This routine deallocates a previously\n** allocated mutex.  SQLite is careful to deallocate every\n** mutex that it allocates.\n*/\nstatic void winMutexFree(sqlite3_mutex p){\nDebug.Assert(p );\nDebug.Assert(p.nRef==0 );\nDebug.Assert(p.id==SQLITE_MUTEX_FAST || p.id==SQLITE_MUTEX_RECURSIVE );\nDeleteCriticalSection(p.mutex);\n//sqlite3DbFree(db,p);\n}\n\n/*\n** The sqlite3_mutex_enter() and sqlite3_mutex_try() routines attempt\n** to enter a mutex.  If another thread is already within the mutex,\n** sqlite3_mutex_enter() will block and sqlite3_mutex_try() will return\n** SQLITE_BUSY.  The sqlite3_mutex_try() interface returns SQLITE_OK\n** upon successful entry.  Mutexes created using SQLITE_MUTEX_RECURSIVE can\n** be entered multiple times by the same thread.  In such cases the,\n** mutex must be exited an equal number of times before another thread\n** can enter.  If the same thread tries to enter any other kind of mutex\n** more than once, the behavior is undefined.\n*/\nstatic void winMutexEnter(sqlite3_mutex p){\nDebug.Assert(p.id==SQLITE_MUTEX_RECURSIVE || winMutexNotheld(p) );\nEnterCriticalSection(p.mutex);\np.owner = GetCurrentThreadId();\np.nRef++;\n}\nstatic int winMutexTry(sqlite3_mutex p){\nint rc = SQLITE_BUSY;\nDebug.Assert(p.id==SQLITE_MUTEX_RECURSIVE || winMutexNotheld(p) );\n/*\n** The sqlite3_mutex_try() routine is very rarely used, and when it\n** is used it is merely an optimization.  So it is OK for it to always\n** fail.\n**\n** The TryEnterCriticalSection() interface is only available on WinNT.\n** And some windows compilers complain if you try to use it without\n** first doing some #defines that prevent SQLite from building on Win98.\n** For that reason, we will omit this optimization for now.  See\n** ticket #2685.\n*/\n#if FALSE\nif( mutexIsNT() && TryEnterCriticalSection(p.mutex) ){\np.owner = GetCurrentThreadId();\np.nRef++;\nrc = SQLITE_OK;\n}\n#else\nUNUSED_PARAMETER(p);\n#endif\nreturn rc;\n}\n\n/*\n** The sqlite3_mutex_leave() routine exits a mutex that was\n** previously entered by the same thread.  The behavior\n** is undefined if the mutex is not currently entered or\n** is not currently allocated.  SQLite will never do either.\n*/\nstatic void winMutexLeave(sqlite3_mutex p){\nDebug.Assert(p.nRef>0 );\nDebug.Assert(p.owner==GetCurrentThreadId() );\np.nRef--;\nDebug.Assert(p.nRef==0 || p.id==SQLITE_MUTEX_RECURSIVE );\nLeaveCriticalSection(p.mutex);\n}\n\nsqlite3_mutex_methods *sqlite3DefaultMutex(void){\nstatic sqlite3_mutex_methods sMutex = {\nwinMutexInit,\nwinMutexEnd,\nwinMutexAlloc,\nwinMutexFree,\nwinMutexEnter,\nwinMutexTry,\nwinMutexLeave,\n#if SQLITE_DEBUG\nwinMutexHeld,\nwinMutexNotheld\n#else\nnull,\nnull\n#endif\n};\n\nreturn &sMutex;\n}\n#endif // * SQLITE_MUTEX_W32 */\n  }\n}\n\n'