b'{-# LANGUAGE BangPatterns #-}\n\nmodule TestHelpers where\n\nimport Data.List\nimport Prelude hiding (catch)\nimport Control.Exception \nimport System.IO.Unsafe (unsafePerformIO)\nimport Data.IORef\nimport Data.Time.Clock\n\nimport Control.Monad.Par.Class\n\n------------------------------------------------------------\n-- Helpers\n\n-- _unsafeio :: IO a -> Par a\n_unsafeio :: ParFuture iv p => IO a -> p a\n_unsafeio io = let x = unsafePerformIO io in\n\t        x `seq` return x\n\n_waste_time :: Int -> Double\n_waste_time n = loop n 1.00111\n  where \n    loop 0  !x             = x\n    loop !n !x | x > 100.0 = loop (n-1) (x / 2)\n    loop !n !x             = loop (n-1) (x + x * 0.5011)\n\n-- This version watches the clock so it uses a constant amount of time\n-- regardless of compile/interpret mode an opt lvl.\nwaste_time :: Double -> IO Double\nwaste_time seconds = \n    do strt <- getCurrentTime\n       let loop !x | x > 100.0 = chk (x / 2)\n\t   loop !x             = chk (x + x * 0.5011)\n\t   chk  !x = do t <- getCurrentTime\n\t\t\tif diffUTCTime t strt >= realToFrac seconds\n\t\t\t then return x\n\t\t\t else loop x\n       loop  1.00111\n\n-- Obviously this takes a lot longer if it\'s interpreted:\n--awhile = 300000000\nawhile :: Integer\nawhile = 3 * 1000 * 1000\n-- awhile = 300000\n\natomicModifyIORef_ :: IORef a -> (a -> a) -> IO ()\natomicModifyIORef_ rf fn = atomicModifyIORef rf (\\x -> (fn x, ()))\n\n\n-- | Haskell doesn\'t offer a way to create a Handle for in-memory output.\n--   So here we use IORefs instead...\ncollectOutput :: (IORef [String] -> IO ()) -> IO String\ncollectOutput fn = \n  do c <- newIORef []\n     fn c\n     ls <- readIORef c\n     return (unlines (reverse ls))\n\nprnt :: IORef [String] -> String -> IO ()\nprnt ref str = atomicModifyIORef_ ref (str:)\n\n-- _prnt :: IORef [String] -> String -> Par ()\n_prnt :: ParFuture iv p => IORef [String] -> String -> p ()\n_prnt ref = _unsafeio . prnt ref\n     \n\n\n-- -----------------------------------------------------------------------------\n\n-- assertException :: (Exception e, Eq e) => e -> IO a -> IO ()\n-- assertException ex action =\n--     handleJust isWanted (const $ return ()) $ do\n--         action\n--         assertFailure $ "Expected exception: " ++ show ex\n--   where isWanted = guard . (== ex)\n\n-- | Ensure that evaluating an expression returns an exception\n--   containing one of the expected messages.\nassertException  :: [String] -> a -> IO ()\nassertException msgs val = do\n x <- catch (do evaluate val; return Nothing) \n            (\\e -> do putStrLn$ "Good.  Caught exception: " ++ show (e :: SomeException)\n                      return (Just$ show e))\n case x of \n  Nothing -> error "Failed to get an exception!"\n  Just s -> \n   if  any (`isInfixOf` s) msgs\n   then return () \n   else error$ "Got the wrong exception, expected to one of the strings: "++ show msgs\n\t       ++ "\\nInstead got this exception:\\n  " ++ show s\n     \n'