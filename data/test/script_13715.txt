b'{-# LANGUAGE LambdaCase #-}\n{-# LANGUAGE OverloadedStrings #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n{-# OPTIONS_GHC -fno-warn-incomplete-uni-patterns #-}\n\nmodule Hoodle.ModelAction.Window where\n\nimport Control.Lens (view)\nimport Control.Monad ((<=<))\nimport Control.Monad.Trans (liftIO)\nimport Data.Foldable (forM_, traverse_)\nimport Data.IORef (newIORef, readIORef)\nimport qualified Data.IntMap as M\nimport Data.Maybe (fromMaybe)\nimport Data.UUID (UUID)\nimport Data.UUID.V4 (nextRandom)\nimport qualified Graphics.UI.Gtk as Gtk\nimport Hoodle.Device (PenButton (..), getPointer)\nimport Hoodle.Type.Canvas\n  ( CanvasId,\n    CanvasInfo (..),\n    CanvasInfoBox (CanvasSinglePage),\n    CanvasInfoMap,\n    MyScrollWindow (..),\n    ViewInfo,\n    canvasId,\n    defaultCanvasWidgets,\n    defaultCvsInfoSinglePage,\n    drawArea,\n    forBoth,\n    forBoth\',\n    scrolledWindow,\n    unboxBiAct,\n    unboxBiXform,\n    _canvasId,\n    _currentPageNum,\n    _drawArea,\n    _horizAdjConnId,\n    _horizAdjustment,\n    _scrollCanvas,\n    _scrollVScrollbar,\n    _scrolledWindow,\n    _vertAdjConnId,\n    _vertAdjustment,\n    _viewInfo,\n  )\nimport Hoodle.Type.Event (AllEvent (..), UserEvent (..))\nimport Hoodle.Type.HoodleState\n  ( FileStore (LocalDir, TempDir),\n    HoodleState,\n    UnitHoodle,\n    callBack,\n    currentUnit,\n    cvsInfoMap,\n    deviceList,\n    gtkUIManager,\n    hoodleFileControl,\n    hoodleFileName,\n    rootOfRootWindow,\n    setCanvasId,\n    setCanvasInfoMap,\n    unitHoodles,\n    updateFromCanvasInfoAsCurrentCanvas,\n  )\nimport Hoodle.Type.Window (WindowConfig (HSplit, Node, VSplit))\nimport Hoodle.Util (maybeError\')\nimport System.FilePath (takeFileName)\n\n-- | set frame title according to file name\nsetTitleFromFileName :: HoodleState -> IO ()\nsetTitleFromFileName xstate = do\n  case view (unitHoodles . currentUnit . hoodleFileControl . hoodleFileName) xstate of\n    LocalDir Nothing ->\n      Gtk.set\n        (view rootOfRootWindow xstate)\n        [Gtk.windowTitle Gtk.:= ("untitled" :: String)]\n    LocalDir (Just filename) ->\n      Gtk.set\n        (view rootOfRootWindow xstate)\n        [Gtk.windowTitle Gtk.:= takeFileName filename]\n    TempDir _filename ->\n      Gtk.set\n        (view rootOfRootWindow xstate)\n        [Gtk.windowTitle Gtk.:= ("shared document" :: String)]\n\n-- |\nnewCanvasId :: CanvasInfoMap -> CanvasId\nnewCanvasId cmap = let cids = M.keys cmap in maximum cids + 1\n\n-- | initialize CanvasInfo with creating windows and connect events\ninitCanvasInfo :: HoodleState -> UnitHoodle -> CanvasId -> IO (CanvasInfo a)\ninitCanvasInfo xstate uhdl cid =\n  minimalCanvasInfo cid >>= connectDefaultEventCanvasInfo xstate uhdl\n\n-- | only creating windows\nminimalCanvasInfo :: CanvasId -> IO (CanvasInfo a)\nminimalCanvasInfo cid = do\n  canvas <- Gtk.drawingAreaNew\n  hadj <- Gtk.adjustmentNew 0 0 500 100 200 200\n  vadj <- Gtk.adjustmentNew 0 0 500 100 200 200\n  vbox <- Gtk.vBoxNew False 0\n  hscr <- Gtk.hScrollbarNew hadj\n  hbox <- Gtk.hBoxNew False 0\n  vscr <- Gtk.vScrollbarNew vadj\n  Gtk.boxPackStart hbox canvas Gtk.PackGrow 0\n  Gtk.boxPackEnd hbox vscr Gtk.PackNatural 0\n  Gtk.boxPackStart vbox hbox Gtk.PackGrow 0\n  Gtk.boxPackEnd vbox hscr Gtk.PackNatural 0\n  let scrwin = MyScrollWindow vbox hscr vscr\n  return $ CanvasInfo cid canvas Nothing scrwin (error "no viewInfo" :: ViewInfo a) 0 hadj vadj Nothing Nothing defaultCanvasWidgets Nothing\n\n-- | only connect events\nconnectDefaultEventCanvasInfo ::\n  HoodleState -> UnitHoodle -> CanvasInfo a -> IO (CanvasInfo a)\nconnectDefaultEventCanvasInfo xstate _uhdl cinfo = do\n  let callback = view callBack xstate\n      ui = view gtkUIManager xstate\n      dev = view deviceList xstate\n      canvas = _drawArea cinfo\n      cid = _canvasId cinfo\n      scrwin = _scrolledWindow cinfo\n      hadj = _horizAdjustment cinfo\n      vadj = _vertAdjustment cinfo\n  Gtk.widgetSetCanFocus canvas True\n  Gtk.widgetGrabFocus canvas\n  _confevent <- canvas `Gtk.on` Gtk.configureEvent $\n    Gtk.tryEvent $ do\n      (w, h) <- Gtk.eventSize\n      liftIO $ callback (UsrEv (CanvasConfigure cid (fromIntegral w) (fromIntegral h)))\n  _keyevent <- canvas `Gtk.on` Gtk.keyPressEvent $\n    Gtk.tryEvent $ do\n      m <- Gtk.eventModifier\n      n <- Gtk.eventKeyName\n      let keystr = show m ++ ":" ++ show n\n      liftIO $ callback (UsrEv (CustomKeyEvent keystr))\n  _bpevent <- canvas `Gtk.on` Gtk.buttonPressEvent $\n    Gtk.tryEvent $ do\n      liftIO $ Gtk.widgetGrabFocus canvas\n      (mbtn, mp) <- getPointer dev\n      forM_ mp $ \\p -> do\n        let pbtn = fromMaybe PenButton1 mbtn\n        case pbtn of\n          TouchButton -> liftIO (callback (UsrEv (TouchDown cid p)))\n          _ -> liftIO (callback (UsrEv (PenDown cid pbtn p)))\n  _brevent <- canvas `Gtk.on` Gtk.buttonReleaseEvent $\n    Gtk.tryEvent $ do\n      (mbtn, mp) <- getPointer dev\n      forM_ mp $ \\p -> do\n        let pbtn = fromMaybe PenButton1 mbtn\n        case pbtn of\n          TouchButton -> (liftIO . callback . UsrEv) (TouchUp cid p)\n          _ -> (liftIO . callback . UsrEv) (PenUp cid p)\n  _drawev <- canvas `Gtk.on` Gtk.draw $ do\n    liftIO $ Gtk.widgetGrabFocus canvas\n    (liftIO . callback . UsrEv) (UpdateCanvas cid)\n  _ <- canvas `Gtk.on` Gtk.motionNotifyEvent $\n    Gtk.tryEvent $ do\n      (mbtn, mp) <- getPointer dev\n      forM_ mp $ \\p -> do\n        let pbtn = fromMaybe PenButton1 mbtn\n        case pbtn of\n          TouchButton -> (liftIO . callback . UsrEv) (TouchMove cid p)\n          _ -> (liftIO . callback . UsrEv) (PenMove cid p)\n  -- drag and drop setting\n  Gtk.dragDestSet canvas [Gtk.DestDefaultMotion, Gtk.DestDefaultDrop] [Gtk.ActionCopy]\n  Gtk.dragDestAddTextTargets canvas\n  _ <- canvas `Gtk.on` Gtk.dragDataReceived $ \\_dc pos _i _ts -> do\n    s <- Gtk.selectionDataGetText\n    (liftIO . callback . UsrEv) (GotLink s pos)\n  Gtk.widgetAddEvents canvas [Gtk.PointerMotionMask, Gtk.Button1MotionMask, Gtk.KeyPressMask]\n  agr <-\n    liftIO\n      ( Gtk.uiManagerGetActionGroups ui >>= \\case\n          [] -> error "No action group? "\n          y : _ -> return y\n      )\n  _uxinputa <-\n    liftIO\n      ( Gtk.actionGroupGetAction agr ("UXINPUTA" :: String) >>= \\(Just x) ->\n          return (Gtk.castToToggleAction x)\n      )\n  hadjconnid <- Gtk.afterValueChanged hadj $ do\n    v <- Gtk.adjustmentGetValue hadj\n    (callback . UsrEv) (HScrollBarMoved cid v)\n  vadjconnid <- Gtk.afterValueChanged vadj $ do\n    v <- Gtk.adjustmentGetValue vadj\n    (callback . UsrEv) (VScrollBarMoved cid v)\n  let vscrbar = _scrollVScrollbar scrwin\n  _bpevtvscrbar <- vscrbar `Gtk.on` Gtk.buttonPressEvent $ do\n    v <- liftIO $ Gtk.adjustmentGetValue vadj\n    liftIO ((callback . UsrEv) (VScrollBarStart cid v))\n    return False\n  _brevtvscrbar <- vscrbar `Gtk.on` Gtk.buttonReleaseEvent $ do\n    v <- liftIO $ Gtk.adjustmentGetValue vadj\n    liftIO ((callback . UsrEv) (VScrollBarEnd cid v))\n    return False\n  return $\n    cinfo\n      { _horizAdjConnId = Just hadjconnid,\n        _vertAdjConnId = Just vadjconnid\n      }\n\n-- | recreate windows from old canvas info but no event connect\nreinitCanvasInfoStage1 ::\n  UnitHoodle -> CanvasInfo a -> IO (CanvasInfo a)\nreinitCanvasInfoStage1 _uhdl oldcinfo = do\n  let cid = view canvasId oldcinfo\n  newcinfo <- minimalCanvasInfo cid\n  return $\n    newcinfo\n      { _viewInfo = _viewInfo oldcinfo,\n        _currentPageNum = _currentPageNum oldcinfo\n      }\n\n-- | event connect\nreinitCanvasInfoStage2 ::\n  HoodleState -> UnitHoodle -> CanvasInfo a -> IO (CanvasInfo a)\nreinitCanvasInfoStage2 = connectDefaultEventCanvasInfo\n\n-- | event connecting for all windows\neventConnect :: HoodleState -> UnitHoodle -> WindowConfig -> IO (UnitHoodle, WindowConfig)\neventConnect xst uhdl (Node cid) = do\n  let cmap = view cvsInfoMap uhdl\n      cinfobox = maybeError\' "eventConnect" $ M.lookup cid cmap\n  ncinfobox <- forBoth unboxBiXform (reinitCanvasInfoStage2 xst uhdl) cinfobox\n  let uhdl\' = updateFromCanvasInfoAsCurrentCanvas ncinfobox uhdl\n  return (uhdl\', Node cid)\neventConnect xst uhdl (HSplit wconf1 wconf2) = do\n  (uhdl\', wconf1\') <- eventConnect xst uhdl wconf1\n  (uhdl\'\', wconf2\') <- eventConnect xst uhdl\' wconf2\n  return (uhdl\'\', HSplit wconf1\' wconf2\')\neventConnect xst uhdl (VSplit wconf1 wconf2) = do\n  (uhdl\', wconf1\') <- eventConnect xst uhdl wconf1\n  (uhdl\'\', wconf2\') <- eventConnect xst uhdl\' wconf2\n  return (uhdl\'\', VSplit wconf1\' wconf2\')\n\n-- | default construct frame\nconstructFrame ::\n  HoodleState ->\n  UnitHoodle ->\n  WindowConfig ->\n  IO (UnitHoodle, Gtk.Widget, WindowConfig)\nconstructFrame xst uhdl wcfg =\n  let callback = view callBack xst\n   in constructFrame\' callback (CanvasSinglePage defaultCvsInfoSinglePage) uhdl wcfg\n\n-- | construct frames with template\nconstructFrame\' ::\n  (AllEvent -> IO ()) ->\n  CanvasInfoBox ->\n  UnitHoodle ->\n  WindowConfig ->\n  IO (UnitHoodle, Gtk.Widget, WindowConfig)\nconstructFrame\' _callback template ouhdl (Node cid) = do\n  let ocmap = view cvsInfoMap ouhdl\n  (cinfobox, _cmap, uhdl) <- case M.lookup cid ocmap of\n    Just cinfobox\' -> return (cinfobox\', ocmap, ouhdl)\n    Nothing -> do\n      let cinfobox\' = setCanvasId cid template\n          cmap\' = M.insert cid cinfobox\' ocmap\n          uhdl\' = fromMaybe ouhdl (setCanvasInfoMap cmap\' ouhdl)\n      return (cinfobox\', cmap\', uhdl\')\n  ncinfobox <- forBoth unboxBiXform (reinitCanvasInfoStage1 uhdl) cinfobox\n  let uhdl\' = updateFromCanvasInfoAsCurrentCanvas ncinfobox uhdl\n  forBoth\' unboxBiAct (putStrLn <=< Gtk.widgetGetName . view drawArea) ncinfobox\n  let scrwin = forBoth\' unboxBiAct (Gtk.castToWidget . _scrollCanvas . view scrolledWindow) ncinfobox\n  return (uhdl\', scrwin, Node cid)\nconstructFrame\' callback template uhdl (HSplit wconf1 wconf2) = do\n  (uhdl\', win1, wconf1\') <- constructFrame\' callback template uhdl wconf1\n  (uhdl\'\', win2, wconf2\') <- constructFrame\' callback template uhdl\' wconf2\n  hpane\' <- Gtk.hPanedNew\n  _ <- hpane\' `Gtk.on` Gtk.buttonPressEvent $ do\n    liftIO ((callback . UsrEv) PaneMoveStart)\n    return False\n  _ <- hpane\' `Gtk.on` Gtk.buttonReleaseEvent $ do\n    liftIO ((callback . UsrEv) PaneMoveEnd)\n    return False\n  Gtk.panedPack1 hpane\' win1 True False\n  Gtk.panedPack2 hpane\' win2 True False\n  Gtk.widgetShowAll hpane\'\n  return (uhdl\'\', Gtk.castToWidget hpane\', HSplit wconf1\' wconf2\')\nconstructFrame\' callback template uhdl (VSplit wconf1 wconf2) = do\n  (uhdl\', win1, wconf1\') <- constructFrame\' callback template uhdl wconf1\n  (uhdl\'\', win2, wconf2\') <- constructFrame\' callback template uhdl\' wconf2\n  vpane\' <- Gtk.vPanedNew\n  _ <- vpane\' `Gtk.on` Gtk.buttonPressEvent $ do\n    liftIO ((callback . UsrEv) PaneMoveStart)\n    return False\n  _ <- vpane\' `Gtk.on` Gtk.buttonReleaseEvent $ do\n    liftIO ((callback . UsrEv) PaneMoveEnd)\n    return False\n  Gtk.panedPack1 vpane\' win1 True False\n  Gtk.panedPack2 vpane\' win2 True False\n  Gtk.widgetShowAll vpane\'\n  return (uhdl\'\', Gtk.castToWidget vpane\', VSplit wconf1\' wconf2\')\n\nregisterFrameToContainer :: Gtk.Window -> Gtk.Box -> Gtk.Widget -> IO ()\nregisterFrameToContainer rtrwin rtcntr win = do\n  Gtk.boxPackEnd rtcntr win Gtk.PackGrow 0\n  Gtk.widgetShowAll rtrwin\n  Gtk.widgetQueueDraw rtrwin\n\ncreateTab :: (AllEvent -> IO ()) -> Gtk.Notebook -> Gtk.VBox -> IO (Int, UUID, Gtk.Button)\ncreateTab callback notebook vboxcvs = do\n  hbox <- Gtk.hBoxNew False 0\n  ebox <- Gtk.eventBoxNew\n  label <- Gtk.labelNew (Just "      " :: Maybe String)\n  Gtk.containerAdd ebox label\n  Gtk.dragSourceSet ebox [Gtk.Button1] [Gtk.ActionCopy]\n  Gtk.dragSourceSetIconStock ebox Gtk.stockIndex\n  Gtk.dragSourceAddTextTargets ebox\n  button <- Gtk.buttonNewWithLabel ("X" :: String)\n  Gtk.boxPackStart hbox ebox Gtk.PackNatural 0\n  Gtk.boxPackStart hbox button Gtk.PackNatural 0\n  Gtk.widgetShowAll hbox\n  mlabel <- Gtk.labelNew (Nothing :: Maybe String)\n  n <- Gtk.notebookAppendPageMenu notebook vboxcvs hbox mlabel\n  uuid <- nextRandom\n  _ <- button `Gtk.on` Gtk.buttonActivated $ callback (UsrEv (CloseTab uuid))\n  _ <- ebox `Gtk.on` Gtk.dragDataGet $ \\_dc _iid _ts -> do\n    minfo <- liftIO $ do\n      ref <- newIORef (Nothing :: Maybe String)\n      callback (UsrEv (GetHoodleFileInfoFromTab uuid ref))\n      readIORef ref\n    traverse_ Gtk.selectionDataSetText minfo\n  return (n, uuid, button)\n'