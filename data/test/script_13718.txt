b'context("betaFitting")\ntest_that("estimates of beta fit from various methods are equal", {\n  # test for equivalence of DESeq2 estimates with those\n  # found using IRLS code and using optim\n  m <- 10\n  set.seed(1)\n  y <- rpois(m,20)\n  sf <- rep(1,m)\n  condition <- factor(rep(0:1,each=m/2))\n  x <- cbind(rep(1,m),rep(0:1,each=m/2))\n  lambda <- 2\n  alpha <- .5\n\n  dds <- DESeqDataSetFromMatrix(matrix(y,nrow=1),\n                                colData=DataFrame(condition),\n                                design= ~ condition)\n  sizeFactors(dds) <- sf\n  dispersions(dds) <- alpha\n  mcols(dds)$baseMean <- mean(y)\n\n  # for testing we convert beta to the naturual log scale:\n  # convert lambda from log to log2 scale by multiplying by log(2)^2\n  # then convert beta back from log2 to log scale by multiplying by log(2)\n  betaDESeq <- log(2)*DESeq2:::fitNbinomGLMs(dds, lambda=c(0,lambda*log(2)^2))$betaMatrix\n\n  # the IRLS algorithm\n  betaIRLS <- c(1,1)\n  for (t in 1:100) {\n    mu.hat <- as.vector(sf * exp(x %*% betaIRLS))\n    w <- diag(1/(1/mu.hat^2 * ( mu.hat + alpha * mu.hat^2 )))\n    z <- log(mu.hat/sf) + (y - mu.hat)/mu.hat\n    ridge <- diag(c(0,lambda))\n    betaIRLS <- as.vector(solve(t(x) %*% w %*% x + ridge) %*% t(x) %*% w %*% z)\n  }\n\n  # using optim\n  objectiveFn <- function(p) {\n    mu <- exp(x %*% p)\n    logLike <- sum(dnbinom(y, mu=mu, size=1/alpha, log=TRUE))\n    prior <- dnorm(p[2], 0, sqrt(1/lambda),log=TRUE)\n    -1 * (logLike + prior)\n  }\n  betaOptim <- optim(c(.1,.1), objectiveFn, control=list(reltol=1e-16))$par\n\n  expect_equal(as.numeric(betaDESeq), betaIRLS, tolerance=1e-6)\n  expect_equal(as.numeric(betaDESeq), betaOptim, tolerance=1e-6)\n})\n'