b'{-# LANGUAGE OverloadedStrings #-}\n\n-- | Pdf file as a set of objects\n\nmodule Pdf.Core.File\n( File(..)\n, withPdfFile\n, fromHandle\n, fromBytes\n, fromBuffer\n, lastTrailer\n, findObject\n, streamContent\n, rawStreamContent\n, EncryptionStatus(..)\n, encryptionStatus\n, setUserPassword\n, setDecryptor\n, NotFound(..)\n)\nwhere\n\nimport Data.ByteString (ByteString)\nimport qualified Data.ByteString as ByteString\nimport Data.IORef\nimport qualified Data.HashMap.Strict as HashMap\nimport Control.Monad\nimport Control.Exception (Exception, throwIO, catch)\nimport System.IO (Handle)\nimport qualified System.IO as IO\nimport System.IO.Streams (InputStream)\n\nimport Pdf.Core.Object\nimport Pdf.Core.Object.Util\nimport Pdf.Core.Exception\nimport Pdf.Core.XRef\nimport Pdf.Core.Stream (StreamFilter)\nimport Pdf.Core.Util\nimport qualified Pdf.Core.Stream as Stream\nimport Pdf.Core.IO.Buffer (Buffer)\nimport qualified Pdf.Core.IO.Buffer as Buffer\nimport Pdf.Core.Encryption\n\n-- | Pdf file is a collection of \'Object\'s\ndata File = File\n  { fileLastXRef :: XRef\n  , fileBuffer :: Buffer\n  , fileFilters :: [StreamFilter]\n  , fileDecryptor :: IORef (Maybe Decryptor)\n  }\n\n-- | The last trailer is an entry point to PDF file. All other objects\n-- usually are referensed from it, directly or indirectly.\nlastTrailer :: File -> IO Dict\nlastTrailer file = trailer (fileBuffer file) (fileLastXRef file)\n\n-- | Get an object with the specified ref.\nfindObject :: File -> Ref -> IO Object\nfindObject file ref = do\n  mentry <- fmap Just (lookupEntryRec file ref)\n    `catch` \\(UnknownXRefStreamEntryType _) -> return Nothing\n  case mentry of\n    Nothing -> return Null\n    Just entry -> readObjectForEntry file entry\n\n-- | Get content of the stream\n--\n-- It\'s decrypted and decoded using registered \'StreamFilter\'s if necessary.\nstreamContent :: File -> Ref -> Stream -> IO (InputStream ByteString)\nstreamContent file ref s = do\n  is <- rawStreamContent file ref s\n  Stream.decodeStream (fileFilters file) s is\n\n-- | Get content of the stream\n--\n-- Content would be decrypted if necessary.\nrawStreamContent :: File -> Ref -> Stream -> IO (InputStream ByteString)\nrawStreamContent file ref (S dict pos) = do\n  len <- do\n    obj <- sure $ HashMap.lookup "Length" dict\n      `notice` "Length missing in stream"\n    case obj of\n      Number _ -> sure $ intValue obj\n        `notice` "Length should be an integer"\n      Ref r -> do\n        o <- findObject file r\n        sure $ intValue o `notice` "Length should be an integer"\n      _ -> throwIO $ Corrupted "Length should be an integer" []\n  is <- Stream.rawStreamContent (fileBuffer file) len pos\n  mdecryptor <- readIORef (fileDecryptor file)\n  case mdecryptor of\n    Nothing -> return is\n    Just decryptor -> decryptor ref DecryptStream is\n\n-- | Describes wether PDF file is encrypted, plain or already decrypted\ndata EncryptionStatus\n  = Encrypted  -- ^ requires decryption\n  | Decrypted  -- ^ already decrypted\n  | Plain      -- ^ doesn\'t require decryption\n  deriving (Show, Eq, Enum)\n\n-- | Get encryption status.\n--\n-- If it\'s \'Encrypted\', you may want to \'setUserPassword\' to decrypt it.\nencryptionStatus :: File -> IO EncryptionStatus\nencryptionStatus file = do\n  tr <- lastTrailer file\n  case HashMap.lookup "Encrypt" tr of\n    Nothing -> return Plain\n    Just _ -> do\n      decr <- readIORef (fileDecryptor file)\n      case decr of\n        Nothing -> return Encrypted\n        Just _ -> return Decrypted\n\n-- | Set user password to decrypt PDF file.\n--\n-- Use empty bytestring to set the default password.\n-- Returns @True@ on success.\n-- See also \'setDecryptor\'.\nsetUserPassword :: File -> ByteString -> IO Bool\nsetUserPassword file password = message "setUserPassword" $ do\n  tr <- lastTrailer file\n  enc <-\n    case HashMap.lookup "Encrypt" tr of\n      Nothing -> throwIO (Unexpected "document is not encrypted" [])\n      Just o -> do\n        o\' <- deref file o\n        case o\' of\n          Dict d -> return d\n          Null -> throwIO (Corrupted "encryption encryption dict is null" [])\n          _ -> throwIO (Corrupted "document Encrypt should be a dictionary" [])\n  let either_decryptor = mkStandardDecryptor tr enc\n        (ByteString.take 32 $ password `mappend` defaultUserPassword)\n  case either_decryptor of\n    Left err -> throwIO $ Corrupted err []\n    Right Nothing -> return False\n    Right (Just decryptor) -> do\n      setDecryptor file decryptor\n      return True\n  where\n  deref f (Ref ref) = findObject f ref\n  deref _ o = return o\n\n-- | Decrypt file using the specified decryptor.\n--\n-- Use it if \'setUserPassword\' doesn\'t work for you.\nsetDecryptor :: File -> Decryptor -> IO ()\nsetDecryptor file decryptor =\n  writeIORef (fileDecryptor file) (Just decryptor)\n\n-- | Create file from a buffer.\n--\n-- You may use \'Stream.knownFilters\' as the first argument.\nfromBuffer :: [StreamFilter] -> Buffer -> IO File\nfromBuffer filters buffer = do\n  xref <- lastXRef buffer\n  decryptor <- newIORef Nothing\n  return File\n    { fileLastXRef = xref\n    , fileBuffer = buffer\n    , fileFilters = filters\n    , fileDecryptor = decryptor\n    }\n\n-- | Create file from a binary handle.\n--\n-- You may use \'Stream.knownFilters\' as the first argument.\nfromHandle :: [StreamFilter] -> Handle -> IO File\nfromHandle filters handle = do\n  buffer <- Buffer.fromHandle handle\n  fromBuffer filters buffer\n\n-- | Create file from a ByteString.\n--\n-- You may use \'Stream.knownFilters\' as the first argument.\nfromBytes :: [StreamFilter] -> ByteString -> IO File\nfromBytes filters bytes = do\n  buffer <- Buffer.fromBytes bytes\n  fromBuffer filters buffer\n\n-- | Open Pdf file\n--\n-- You may want to check \'encryptionStatus\' and \'setUserPassword\' if\n-- file is encrypted.\nwithPdfFile :: FilePath -> (File -> IO a) -> IO a\nwithPdfFile path action =\n  IO.withBinaryFile path IO.ReadMode $ \\handle -> do\n    file <- fromHandle Stream.knownFilters handle\n    action file\n\nlookupEntryRec :: File -> Ref -> IO Entry\nlookupEntryRec file ref = loop (fileLastXRef file)\n  where\n  loop xref = do\n    res <- lookupEntry file ref xref\n    case res of\n      Just e -> return e\n      Nothing -> do\n        prev <- prevXRef (fileBuffer file) xref\n        case prev of\n          Just p -> loop p\n          Nothing -> throwIO (NotFound $ "The Ref not found: " ++ show ref)\n\nlookupEntry :: File -> Ref -> XRef -> IO (Maybe Entry)\nlookupEntry file ref xref@(XRefTable _) =\n  lookupTableEntry (fileBuffer file) xref ref\nlookupEntry file ref (XRefStream _ s@(S dict _)) = do\n  content <- streamContent file ref s\n  lookupStreamEntry dict content ref\n\nreadObjectForEntry :: File -> Entry -> IO Object\n\nreadObjectForEntry _ EntryFree{} = return Null\n\nreadObjectForEntry file (EntryUsed off gen) = do\n  (ref, obj) <- readObjectAtOffset (fileBuffer file) off\n  let R _ gen\' = ref\n  unless (gen\' == gen) $\n    throwIO (Corrupted "readObjectForEntry" ["object generation missmatch"])\n  decrypt file ref obj\n\nreadObjectForEntry file (EntryCompressed index num) = do\n  let ref= R index 0\n  objStream@(S dict _) <- do\n    o <- findObject file ref\n    sure $ streamValue o `notice` "Compressed entry should be in stream"\n  first <- sure $ (HashMap.lookup "First" dict >>= intValue)\n      `notice` "First should be an integer"\n  content <- streamContent file ref objStream\n  readCompressedObject content (fromIntegral first) num\n\ndecrypt :: File -> Ref -> Object -> IO Object\ndecrypt file ref o = do\n  maybe_decr <- readIORef (fileDecryptor file)\n  case maybe_decr of\n    Nothing -> return o\n    Just decr -> decryptObject decr ref o\n\ndata NotFound = NotFound String\n  deriving (Show)\n\ninstance Exception NotFound\n'