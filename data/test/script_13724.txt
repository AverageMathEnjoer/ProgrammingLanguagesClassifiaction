b'{-# LANGUAGE NoImplicitPrelude #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n{-# LANGUAGE InstanceSigs #-}\n{-# LANGUAGE RebindableSyntax #-}\n\nmodule Course.State where\n\nimport Course.Core\nimport qualified Prelude as P\nimport Course.Optional\nimport Course.List\nimport Course.Functor\nimport Course.Applicative\nimport Course.Monad\nimport qualified Data.Set as S\n\n-- $setup\n-- >>> import Test.QuickCheck.Function\n-- >>> import Data.List(nub)\n-- >>> import Test.QuickCheck\n-- >>> import qualified Prelude as P(fmap)\n-- >>> import Course.Core\n-- >>> import Course.List\n-- >>> instance Arbitrary a => Arbitrary (List a) where arbitrary = P.fmap listh arbitrary\n\n-- A `State` is a function from a state value `s` to (a produced value `a`, and a resulting state `s`).\nnewtype State s a =\n  State {\n    runState ::\n      s\n      -> (a, s)\n  }\n\n-- | Run the `State` seeded with `s` and retrieve the resulting state.\n--\n-- prop> \\(Fun _ f) s -> exec (State f) s == snd (runState (State f) s)\nexec ::\n  State s a\n  -> s\n  -> s\nexec =\n  error "todo: Course.State#exec"\n\n-- | Run the `State` seeded with `s` and retrieve the resulting value.\n--\n-- prop> \\(Fun _ f) s -> eval (State f) s == fst (runState (State f) s)\neval ::\n  State s a\n  -> s\n  -> a\neval =\n  error "todo: Course.State#eval"\n\n-- | A `State` where the state also distributes into the produced value.\n--\n-- >>> runState get 0\n-- (0,0)\nget ::\n  State s s\nget =\n  error "todo: Course.State#get"\n\n-- | A `State` where the resulting state is seeded with the given value.\n--\n-- >>> runState (put 1) 0\n-- ((),1)\nput ::\n  s\n  -> State s ()\nput =\n  error "todo: Course.State#put"\n\n-- | Implement the `Functor` instance for `State s`.\n--\n-- >>> runState ((+1) <$> State (\\s -> (9, s * 2))) 3\n-- (10,6)\ninstance Functor (State s) where\n  (<$>) ::\n    (a -> b)\n    -> State s a\n    -> State s b\n  (<$>) =\n    error "todo: Course.State#(<$>)"\n\n-- | Implement the `Applicative` instance for `State s`.\n--\n-- >>> runState (pure 2) 0\n-- (2,0)\n--\n-- >>> runState (pure (+1) <*> pure 0) 0\n-- (1,0)\n--\n-- >>> import qualified Prelude as P\n-- >>> runState (State (\\s -> ((+3), s P.++ ["apple"])) <*> State (\\s -> (7, s P.++ ["banana"]))) []\n-- (10,["apple","banana"])\ninstance Applicative (State s) where\n  pure ::\n    a\n    -> State s a\n  pure =\n    error "todo: Course.State pure#instance (State s)"\n  (<*>) ::\n    State s (a -> b)\n    -> State s a\n    -> State s b \n  (<*>) =\n    error "todo: Course.State (<*>)#instance (State s)"\n\n-- | Implement the `Bind` instance for `State s`.\n--\n-- >>> runState ((const $ put 2) =<< put 1) 0\n-- ((),2)\n--\n-- >>> let modify f = State (\\s -> ((), f s)) in runState (modify (+1) >>= \\() -> modify (*2)) 7\n-- ((),16)\ninstance Monad (State s) where\n  (=<<) ::\n    (a -> State s b)\n    -> State s a\n    -> State s b\n  (=<<) =\n    error "todo: Course.State (=<<)#instance (State s)"\n\n-- | Find the first element in a `List` that satisfies a given predicate.\n-- It is possible that no element is found, hence an `Optional` result.\n-- However, while performing the search, we sequence some `Monad` effect through.\n--\n-- Note the similarity of the type signature to List#find\n-- where the effect appears in every return position:\n--   find ::  (a ->   Bool) -> List a ->    Optional a\n--   findM :: (a -> f Bool) -> List a -> f (Optional a)\n--\n-- >>> let p x = (\\s -> (const $ pure (x == \'c\')) =<< put (1+s)) =<< get in runState (findM p $ listh [\'a\'..\'h\']) 0\n-- (Full \'c\',3)\n--\n-- >>> let p x = (\\s -> (const $ pure (x == \'i\')) =<< put (1+s)) =<< get in runState (findM p $ listh [\'a\'..\'h\']) 0\n-- (Empty,8)\nfindM ::\n  Monad f =>\n  (a -> f Bool)\n  -> List a\n  -> f (Optional a)\nfindM =\n  error "todo: Course.State#findM"\n\n-- | Find the first element in a `List` that repeats.\n-- It is possible that no element repeats, hence an `Optional` result.\n--\n-- /Tip:/ Use `findM` and `State` with a @Data.Set#Set@.\n--\n-- prop> \\xs -> case firstRepeat xs of Empty -> let xs\' = hlist xs in nub xs\' == xs\'; Full x -> length (filter (== x) xs) > 1\n-- prop> \\xs -> case firstRepeat xs of Empty -> True; Full x -> let (l, (rx :. rs)) = span (/= x) xs in let (l2, r2) = span (/= x) rs in let l3 = hlist (l ++ (rx :. Nil) ++ l2) in nub l3 == l3\nfirstRepeat ::\n  Ord a =>\n  List a\n  -> Optional a\nfirstRepeat =\n  error "todo: Course.State#firstRepeat"\n\n-- | Remove all duplicate elements in a `List`.\n-- /Tip:/ Use `filtering` and `State` with a @Data.Set#Set@.\n--\n-- prop> \\xs -> firstRepeat (distinct xs) == Empty\n--\n-- prop> \\xs -> distinct xs == distinct (flatMap (\\x -> x :. x :. Nil) xs)\ndistinct ::\n  Ord a =>\n  List a\n  -> List a\ndistinct =\n  error "todo: Course.State#distinct"\n\n-- | A happy number is a positive integer, where the sum of the square of its digits eventually reaches 1 after repetition.\n-- In contrast, a sad number (not a happy number) is where the sum of the square of its digits never reaches 1\n-- because it results in a recurring sequence.\n--\n-- /Tip:/ Use `firstRepeat` with `produce`.\n--\n-- /Tip:/ Use `join` to write a @square@ function.\n--\n-- /Tip:/ Use library functions: @Optional#contains@, @Data.Char#digitToInt@.\n--\n-- >>> isHappy 4\n-- False\n--\n-- >>> isHappy 7\n-- True\n--\n-- >>> isHappy 42\n-- False\n--\n-- >>> isHappy 44\n-- True\nisHappy ::\n  Integer\n  -> Bool\nisHappy =\n  error "todo: Course.State#isHappy"\n'