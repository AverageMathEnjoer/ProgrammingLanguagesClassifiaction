b'{-# OPTIONS -cpp #-}\n{-# LANGUAGE BangPatterns #-}\n\n{- Matrix multiplication using a torus (gentleman algorithm) -- FR10 --    -}\n\n{-\nRL/JB ParCo2005: eliminate result communication (Maybe-Type)\n\nJB PhD2008: adapt for simple PhD skeleton tests\n\nJB MSR07/2008: modified to use all available toroid skeletons.\n\nJB MSR07/2008: derived a straight-forward GpH program using identical\n               helpers and strategies\n\nJB optimised prodEscalar\n\nJB for ghc-6.9: replaced Control.Parallel.Strategies by a workaround\n   (reexporting what should work)\n\n-}\n        \nmodule Main(main) where\n\nimport System.Environment\nimport Data.List hiding (foldl\', foldl1\')\nimport ListAux\nimport Control.DeepSeq\n#ifdef NEW_GENERIC\nimport qualified Data.Par as C\n#else\nimport qualified Control.Monad.Par.Combinator as C\n#endif\n\n#ifdef PARSCHED \nimport PARSCHED\n#else\nimport Control.Monad.Par\n#endif\n\n-------------------------------------\n\ntype Vector = [Int]\ntype Matrix = [Vector]\n\n-- main computation, different versions:\nmult :: Int -> Matrix -> Matrix -> Int -> [[Maybe Matrix]]\nmult 0 m1 m2 _ = \n#ifdef OUTPUT\n        [[Just $ multMatricesTr m1 (transpose m2)]]\n#else\n        rnf (multMatricesTr m1 (transpose m2)) `seq` [[Nothing]]\n#endif\nmult v m1 m2 c = results\n where results ::  [[Maybe Matrix]]\n#ifdef OUTPUT\n       results = [[Just computed]]\n#else\n       results = (rnf computed `seq` [[Nothing]])\n#endif\n       computed = multMatricesTr m1 m2Tr\n--       strats\' = strats ++ repeat undef\n       m2Tr = transpose m2\n\nprMM\' :: (Matrix,Matrix) -> Matrix\nprMM\' (c,mt) = [[prVV f c | c <- mt]|f <-c]\nprVV :: Vector -> Vector -> Int\nprVV f c = sum (zipWith (*) f c)\n \nshiftRight c [] = []\nshiftRight c (xs:xss) = (xs2++xs1):shiftRight (c-1) xss\n where (xs1,xs2) = splitAt c xs\n\nshiftDown c xss = transpose (shiftRight c (transpose xss))\n\njoin2 :: Matrix -> Matrix -> Matrix\njoin2 xs ys = zipWith (++) xs ys\njoin :: [Matrix] -> Matrix\njoin xss = foldr join2 (repeat []) xss\n       \nsplitIntoClusters :: Int -> Matrix -> [[Matrix]]\nsplitIntoClusters c m | c < 1 = splitIntoClusters 1 m\nsplitIntoClusters c m1 = mss\n  where bh  = kPartition (length m1) c\n        bhsplit [] [] = []\n        bhsplit [] _  = error "some elements left over"\n\tbhsplit (t:ts) xs = hs : (bhsplit ts rest)\n\t  \t  where (hs,rest) = splitAt t xs   \n        ms  = bhsplit bh m1 -- blocks of rows \n        mss = map (colsplit bh) ms\n        colsplit [] _  = []\n        colsplit (t:ts) rs\n         | head rs == [] = []\n         | otherwise = (cab:colsplit ts resto)\n          where  (cab,resto) = unzip (map (splitAt t) rs)\n        \n--        mss = map (repartir (length m1 `div` c)) ms\n--        repartir c xs\n--         | head xs == [] = []\n--         | otherwise = (cab:repartir c resto)\n--          where  (cab,resto) = unzip (map (splitAt c) xs)\n\n-- helper for splitIntoClusters (formerly bresenham)\nkPartition :: Int -> Int -> [Int]\nkPartition n k = zipWith (+) ((replicate (n `mod` k) 1) ++ repeat 0)\n                             (replicate k (n `div` k))\n\n          \nmult\' :: Int -> Int -> ((Matrix,Matrix),[Matrix],[Matrix]) -> (Maybe Matrix,[Matrix],[Matrix])\nmult\' nc nr ((sm1,sm2),sm1s,sm2s) \n#ifdef OUTPUT\n    =  (Just result,toRight,toDown)\n#else\n    =  (rnf result `seq` Nothing ,toRight,toDown)\n#endif\n  where toRight  = take (nc-1) (sm1:sm1s)\n        toDown   = take (nr-1) (sm2\':sm2s)\n        sm2\'     = transpose sm2\n        sms      = zipWith multMatricesTr (sm1:sm1s) (sm2\':sm2s)\n        result = foldl1\' addMatrices sms  -- foldr1: not enough demand??\n\n        \naddMatrices :: Matrix -> Matrix -> Matrix\naddMatrices m1 m2 = zipWith addVectors m1 m2\n  where addVectors :: Vector -> Vector -> Vector\n        addVectors v1 v2 = zipWith (+) v1 v2\n\n-- Assumes the second matrix has already been transposed        \nmultMatricesTr :: Matrix -> Matrix -> Matrix\nmultMatricesTr m1 m2 =\n  runPar $ C.parMap (\\row -> [prodEscalar2 row col | col <- m2]) m1\n\n-- JB 2008: a lot faster, directly consuming lists, and tail-recursive (optimised with -O2)\nprodEscalar2JB :: Vector -> Vector -> Int\nprodEscalar2JB v1 v2 = addProd v1 v2 0\n    where addProd :: Vector -> Vector -> Int -> Int\n          addProd (v:vs) (w:ws) acc = addProd vs ws (acc + v*w)\n          addProd [] [] n = n\n          addProd _  _  _ = error "addProd: length does not match"\n\n-- JB 2008: identical when using ghc-6.8.3, avoids bug in ghc-HEAD. Version suggested by SM\nprodEscalar2 :: Vector -> Vector -> Int\nprodEscalar2 v1 v2 = addProd v1 v2 0\naddProd :: Vector -> Vector -> Int -> Int\naddProd (v:vs) (w:ws) !acc = addProd vs ws (acc + v*w)\naddProd _ _ !n = n\n\n\nprodEscalar :: Vector -> Vector -> Int\nprodEscalar v1 v2 = sum (zipWith (*) v1 v2)\n\n\n------- foldl, strict in head element\nfoldl1\' :: NFData a => (a->a->a) -> [a] -> a\nfoldl1\' f (x:xs) = foldl\' f x xs\n\nfoldl\'           ::  NFData a => (a -> b -> a) -> a -> [b] -> a\nfoldl\' f a []     = a\nfoldl\' f a (x:xs) = -- whnf, not enough( (foldl\' f) $! (f a x)) xs\n\t\t    let first = f a x \n\t\t    in rnf first `seq` foldl\' f first xs\n\n\nusage :: String -> String\nusage name = "Cannon\'s algorithm: Usage:\\n\\t "++\n\t     name ++ " <matrix size> <version> <blocksPerRow> \\n" ++\n             "Version selects from " -- ++ show (zip [0..] names)\n\nmain = do \n       args <- getArgs\n       let l = length args\n       if l == 0 then do n <- getProgName\n                         putStrLn (usage n)\n                         putStrLn "\\n *** defaults: size 100, seq. computation ***"\n                 else return () --putStrLn "Cannon\'s algorithm"\n\n       let    size  = if null args then 100 else read (head args)\n\t      opt   = if length args < 2 then 0 else read (args!!1)\n\t      chunk = if length args < 3 then 1 \n                                         else read (args!!2)\n\t      a = "Matrices of size " ++ show size ++ \n--                  " with skeleton " ++ ((names++repeat "UNDEF")!!opt) ++\n                  " using chunk parameter " ++ show chunk ++ "\\n"\n\t      res = mult opt (mA size) (mB size) chunk\n\t      b = multMatricesTr (mA size) (transpose (mB size))\n       -- putStrLn a\n#ifdef OUTPUT\n       putStrLn "Output wanted, checking result for correctness..."\n       let computed = map (map fromJust) res\n           computed\' = concat (map join computed)\n       printMat computed\'\n       if (b == computed\')  \n                 then putStrLn "Correct!"\n                 else do putStrLn "WRONG RESULT! Should be"\n                         printMat b\n#else\n       -- putStrLn "No Output, matrix stays distributed."\n       putStrLn (show res)\n#endif        \n\n\n         \nm1 size = replicate size [1..size]\nm2 size = listToListList size [1..size*size]\nmA size = if size <= 4000 then m1 size else listToListList size (concat (take 20 (repeat [1..(size*size `div` 20)])))\nmB size = if size <= 4000 then m1 size else listToListList size (concat (take 20 (repeat [0,2.. ((size*size) `div` 20)-2])))\nlistToListList c m \n | length m <= c = [m]\n | otherwise = c1 : listToListList c resto\n  where (c1,resto) = splitAt c m\n\n\nprintMat :: Matrix -> IO ()\nprintMat m = putStrLn ("Matrix: " ++ (show (length (head m))) \n                       ++ " x " ++ (show $ length m) ++ "\\n" \n                       ++ (showMat m))\n\n-- instance Show a => Show (Matrix a) where\nshowMat m_ = "<<" ++ unlines (map (concatMap (\\ x -> show x ++ " ")) m_) ++ ">>"\n\nfromJust :: Maybe a -> a\nfromJust (Just x) = x\nfromJust Nothing  = error "fromJust"\n'