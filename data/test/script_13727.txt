b'{-# LANGUAGE BangPatterns #-}\n\nmodule Main where\n\nimport Control.DeepSeq (rnf)\nimport Control.Exception (evaluate)\nimport Test.Tasty.Bench (bench, defaultMain, whnf)\nimport Data.List (foldl\')\nimport qualified Data.Set as S\n\nmain = do\n    let s = S.fromAscList elems :: S.Set Int\n        s_even = S.fromAscList elems_even :: S.Set Int\n        s_odd = S.fromAscList elems_odd :: S.Set Int\n        strings_s = S.fromList strings\n    evaluate $ rnf [s, s_even, s_odd]\n    defaultMain\n        [ bench "member" $ whnf (member elems) s\n        , bench "insert" $ whnf (ins elems) S.empty\n        , bench "map" $ whnf (S.map (+ 1)) s\n        , bench "filter" $ whnf (S.filter ((== 0) . (`mod` 2))) s\n        , bench "partition" $ whnf (S.partition ((== 0) . (`mod` 2))) s\n        , bench "fold" $ whnf (S.fold (:) []) s\n        , bench "delete" $ whnf (del elems) s\n        , bench "findMin" $ whnf S.findMin s\n        , bench "findMax" $ whnf S.findMax s\n        , bench "deleteMin" $ whnf S.deleteMin s\n        , bench "deleteMax" $ whnf S.deleteMax s\n        , bench "unions" $ whnf S.unions [s_even, s_odd]\n        , bench "union" $ whnf (S.union s_even) s_odd\n        , bench "difference" $ whnf (S.difference s) s_even\n        , bench "intersection" $ whnf (S.intersection s) s_even\n        , bench "fromList" $ whnf S.fromList elems\n        , bench "fromList-desc" $ whnf S.fromList (reverse elems)\n        , bench "fromAscList" $ whnf S.fromAscList elems\n        , bench "fromDistinctAscList" $ whnf S.fromDistinctAscList elems\n        , bench "disjoint:false" $ whnf (S.disjoint s) s_even\n        , bench "disjoint:true" $ whnf (S.disjoint s_odd) s_even\n        , bench "null.intersection:false" $ whnf (S.null. S.intersection s) s_even\n        , bench "null.intersection:true" $ whnf (S.null. S.intersection s_odd) s_even\n        , bench "alterF:member" $ whnf (alterF_member elems) s\n        , bench "alterF:insert" $ whnf (alterF_ins elems) S.empty\n        , bench "alterF:delete" $ whnf (alterF_del elems) s\n        , bench "alterF:four" $ whnf (alterF_four elems) s\n        , bench "alterF:four:strings" $ whnf (alterF_four strings) strings_s\n        , bench "alterF_naive:four" $ whnf (alterF_naive_four elems) s\n        , bench "alterF_naive:four:strings" $ whnf (alterF_naive_four strings) strings_s\n        , bench "powerSet (19)" $ whnf S.powerSet (S.fromList[1..19])\n        , bench "powerSet (20)" $ whnf S.powerSet (S.fromList[1..20])\n        , bench "powerSet (21)" $ whnf S.powerSet (S.fromList[1..21])\n        , bench "member.powerSet (16)" $ whnf (\\ s -> all (flip S.member s) s) (S.powerSet (S.fromList [1..16]))\n        , bench "member.powerSet (17)" $ whnf (\\ s -> all (flip S.member s) s) (S.powerSet (S.fromList [1..17]))\n        , bench "member.powerSet (18)" $ whnf (\\ s -> all (flip S.member s) s) (S.powerSet (S.fromList [1..18]))\n        ]\n  where\n    elems = [1..2^12]\n    elems_even = [2,4..2^12]\n    elems_odd = [1,3..2^12]\n    strings = map show elems\n\nmember :: [Int] -> S.Set Int -> Int\nmember xs s = foldl\' (\\n x -> if S.member x s then n + 1 else n) 0 xs\n\nins :: [Int] -> S.Set Int -> S.Set Int\nins xs s0 = foldl\' (\\s a -> S.insert a s) s0 xs\n\ndel :: [Int] -> S.Set Int -> S.Set Int\ndel xs s0 = foldl\' (\\s k -> S.delete k s) s0 xs\n\nalterF_member :: [Int] -> S.Set Int -> Int\nalterF_member xs s = foldl\' (\\n x -> if member\' x s then n + 1 else n) 0 xs\n  where\n    member\' k s = getConsty (S.alterF (\\b -> Consty b) k s)\n\nalterF_ins :: [Int] -> S.Set Int -> S.Set Int\nalterF_ins xs s0 = foldl\' (\\s a -> insert\' a s) s0 xs\n  where\n    insert\' k s = runIdent (S.alterF (const (Ident True)) k s)\n\nalterF_del :: [Int] -> S.Set Int -> S.Set Int\nalterF_del xs s0 = foldl\' (\\s k -> delete\' k s) s0 xs\n  where\n    delete\' k s = runIdent (S.alterF (const (Ident False)) k s)\n\nalterF_four :: Ord a => [a] -> S.Set a -> S.Set a\nalterF_four xs s0 = foldl\' (\\s k -> S.alterF four k s `seq` s) s0 xs\n\nalterF_naive_four :: Ord a => [a] -> S.Set a -> S.Set a\nalterF_naive_four xs s0 = foldl\' (\\s k -> alterF_naive four k s `seq` s) s0 xs\n\nalterF_naive :: (Ord a, Functor f) => (Bool -> f Bool) -> a -> S.Set a -> f (S.Set a)\nalterF_naive f k s = fmap g (f (k `S.member` s))\n  where\n    g True  = S.insert k s\n    g False = S.delete k s\n\nfour :: Bool -> Four Bool\n               -- insert  delete  reinsert  toggle\nfour True  = Four True    False   True      False\nfour False = Four True    False   False     True\n\nnewtype Consty a b = Consty { getConsty :: a}\ninstance Functor (Consty a) where\n  fmap _ (Consty a) = Consty a\n\nnewtype Ident a = Ident { runIdent :: a }\ninstance Functor Ident where\n  fmap f (Ident a) = Ident (f a)\n\ndata Four a = Four !a !a !a !a\ninstance Functor Four where\n  fmap f (Four a b c d) = Four (f a) (f b) (f c) (f d)\n'