b'{-# LANGUAGE ScopedTypeVariables #-}\n\nimport Data.List\nimport Test.Hspec\nimport Test.Hspec.QuickCheck\nimport Test.QuickCheck\n\nmain :: IO ()\nmain = hspec $ do\n    describe "my_length" $\n        prop "behaves like model" $ \\(xs :: [Integer]) ->\n           my_length xs `shouldBe` fromIntegral (length xs)\n    describe "my_length_iter" $\n        prop "behaves like model" $ \\(xs :: [Integer]) ->\n           my_length_iter xs `shouldBe` fromIntegral (length xs)\n    describe "my_sum" $\n        prop "behaves like model" $ \\(xs :: [Integer]) ->\n           my_sum xs `shouldBe` fromIntegral (sum xs)\n    describe "my_sum_iter" $\n        prop "behaves like model" $ \\(xs :: [Integer]) ->\n           my_sum_iter xs `shouldBe` fromIntegral (sum xs)\n    describe "my_product" $\n        prop "behaves like model" $ \\(xs :: [Integer]) ->\n           my_product xs `shouldBe` fromIntegral (product xs)\n    describe "my_product_iter" $\n        prop "behaves like model" $ \\(xs :: [Integer]) ->\n           my_product_iter xs `shouldBe` fromIntegral (product xs)\n    describe "my_maximum" $\n        prop "behaves like model" $ \\(xs :: [Integer]) -> xs /= []\n          ==> my_maximum xs `shouldBe` maximum xs\n    describe "my_maximum_iter" $\n        prop "behaves like model" $ \\(xs :: [Integer]) -> xs /= []\n          ==> my_maximum_iter xs `shouldBe` maximum xs\n    describe "my_minimum" $\n        prop "behaves like model" $ \\(xs :: [Integer]) -> xs /= []\n          ==> my_minimum xs `shouldBe` minimum xs\n    describe "my_minimum_iter" $\n        prop "behaves like model" $ \\(xs :: [Integer]) -> xs /= []\n          ==> my_minimum_iter xs `shouldBe` minimum xs\n    describe "my_and" $\n        prop "behaves like model" $ \\(xs :: [Bool]) ->\n           my_and xs `shouldBe` and xs\n    describe "my_and_bad_iter" $\n        prop "behaves like model" $ \\(xs :: [Bool]) ->\n           my_and_bad_iter xs `shouldBe` and xs\n    describe "my_and_iter" $\n        prop "behaves like model" $ \\(xs :: [Bool]) ->\n           my_and_iter xs `shouldBe` and xs\n    describe "my_or" $\n        prop "behaves like model" $ \\(xs :: [Bool]) ->\n           my_or xs `shouldBe` or xs\n    describe "my_or_iter" $\n        prop "behaves like model" $ \\(xs :: [Bool]) ->\n           my_or_iter xs `shouldBe` or xs\n    describe "my_all" $\n        prop "behaves like model" $ \\(xs :: [Integer]) -> do\n           my_all even xs `shouldBe` all even xs\n           my_all odd  xs `shouldBe` all odd  xs\n           my_all (>1) xs `shouldBe` all (>1) xs\n    describe "my_all_iter" $\n        prop "behaves like model" $ \\(xs :: [Integer]) -> do\n           my_all_iter even xs `shouldBe` all even xs\n           my_all_iter odd  xs `shouldBe` all odd  xs\n           my_all_iter (>1) xs `shouldBe` all (>1) xs\n    describe "my_elem" $\n        prop "behaves like model" $ \\(k :: Integer) (xs :: [Integer]) ->\n           my_elem k xs `shouldBe` elem k xs\n    describe "my_find" $\n        prop "behaves like model" $ \\(xs :: [Integer]) -> do\n           my_find even xs `shouldBe` find even xs\n           my_find odd  xs `shouldBe` find odd  xs\n           my_find (>1) xs `shouldBe` find (>1) xs\n    describe "my_lookup" $\n        prop "behaves like model" $ \\(k :: Integer) (xs :: [(Integer,Integer)]) ->\n           my_lookup k xs `shouldBe` lookup k xs\n    describe "my_foldr" $\n        prop "behaves like model" $ \\(xs :: [Integer]) -> do\n           my_foldr (+) 0 xs `shouldBe` sum xs\n           my_foldr (*) 1 xs `shouldBe` product xs\n    describe "my_foldl" $\n        prop "behaves like model" $ \\(xs :: [Integer]) -> do\n           my_foldl (+) 0 xs `shouldBe` sum xs\n           my_foldl (*) 1 xs `shouldBe` product xs\n\n----------------------------------------------------------------\n\nmy_length :: [a] -> Integer\nmy_length []     = 0\nmy_length (_:xs) = my_length xs + 1\n\nmy_length_iter :: [a] -> Integer\nmy_length_iter as = iter as 0\n  where\n    iter :: [a] -> Integer -> Integer\n    iter []     n = n\n    iter (_:xs) n = iter xs (n + 1)\n\n----------------------------------------------------------------\n\nmy_sum :: [Integer] -> Integer\nmy_sum []     = 0\nmy_sum (x:xs) = my_sum xs + x\n\nmy_sum_iter :: [Integer] -> Integer\nmy_sum_iter as = iter as 0\n  where\n    iter []     acc = acc\n    iter (x:xs) acc = iter xs (acc + x)\n\nmy_product :: [Integer] -> Integer\nmy_product []     = 1\nmy_product (x:xs) = my_product xs * x\n\nmy_product_iter :: [Integer] -> Integer\nmy_product_iter as = iter as 1\n  where\n    iter []     acc = acc\n    iter (x:xs) acc = iter xs (acc * x)\n\n----------------------------------------------------------------\n\nmy_maximum :: Ord a => [a] -> a\nmy_maximum []  = error "my_maximum"\nmy_maximum [x] = x\nmy_maximum (x:xs)\n  | x > y      = x\n  | otherwise  = y\n  where\n    y = my_maximum xs\n\nmy_maximum_iter :: Ord a => [a] -> a\nmy_maximum_iter []  = error "my_maximum_iter"\nmy_maximum_iter (a:as) = iter as a\n  where\n    iter []     acc = acc\n    iter (x:xs) acc\n      | x > acc     = iter xs x\n      | otherwise   = iter xs acc\n\nmy_minimum :: Ord a => [a] -> a\nmy_minimum []  = error "my_minimum"\nmy_minimum [x] = x\nmy_minimum (x:xs)\n  | y < x      = y\n  | otherwise  = x\n  where\n    y = my_minimum xs\n\nmy_minimum_iter :: Ord a => [a] -> a\nmy_minimum_iter []  = error "my_minimum_iter"\nmy_minimum_iter (a:as) = iter as a\n  where\n    iter []     acc = acc\n    iter (x:xs) acc\n      | x < acc     = iter xs x\n      | otherwise   = iter xs acc\n\n----------------------------------------------------------------\n\nmy_and :: [Bool] -> Bool\nmy_and []     = True\nmy_and (x:xs) = x && my_and xs\n\nmy_and_bad_iter :: [Bool] -> Bool\nmy_and_bad_iter as = iter as True\n  where\n    iter []     acc = acc\n    iter (x:xs) acc = iter xs (x && acc)\n\nmy_and_iter :: [Bool] -> Bool\nmy_and_iter [] = True\nmy_and_iter (x:xs)\n  | x          = my_and_iter xs\n  | otherwise  = False\n\nmy_or :: [Bool] -> Bool\nmy_or []     = False\nmy_or (x:xs) = x || my_or xs\n\nmy_or_iter :: [Bool] -> Bool\nmy_or_iter [] = False\nmy_or_iter (x:xs)\n  | x         = True\n  | otherwise = my_or_iter xs\n\nmy_all :: (a -> Bool) -> [a] -> Bool\nmy_all _ []     = True\nmy_all p (x:xs) = p x && my_all p xs\n\nmy_all_iter :: (a -> Bool) -> [a] -> Bool\nmy_all_iter _ []     = True\nmy_all_iter p (x:xs)\n  | p x       = my_all_iter p xs\n  | otherwise = False\n\n----------------------------------------------------------------\n\nmy_elem :: Eq a => a -> [a] -> Bool\nmy_elem _ []  = False\nmy_elem k (x:xs)\n  | k == x    = True\n  | otherwise = my_elem k xs\n\nmy_find :: (a -> Bool) -> [a] -> Maybe a\nmy_find _ [] = Nothing\nmy_find p (x:xs)\n  | p x       = Just x\n  | otherwise = my_find p xs\n\nmy_lookup :: Eq k => k -> [(k,v)] -> Maybe v\nmy_lookup _ []           = Nothing\nmy_lookup key ((k,v):kvs)\n    | key == k           = Just v\n    | otherwise          = my_lookup key kvs\n\n----------------------------------------------------------------\n\nmy_foldr :: (a -> b -> b) -> b -> [a] -> b\nmy_foldr _ ini []     = ini\nmy_foldr f ini (x:xs) = f x (my_foldr f ini xs)\n\nmy_foldl :: (a -> b -> a) -> a -> [b] -> a\nmy_foldl _ acc []     = acc\nmy_foldl f acc (x:xs) = my_foldl f (f acc x) xs\n'