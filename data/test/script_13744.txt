b'# Wrangle Data With data.table\n\n#======================================================================================================\n# Install data.table\n\ninstall.packages("data.table")\n\n#======================================================================================================\n# Load data.table\n\nlibrary(data.table)\n\n#======================================================================================================\n# Build a data.table from scratch\n\ntransactions <- data.table(\n  TransactionID = seq(1, 10),\n  TransactionDate = as.Date(c("2010-08-21", "2011-05-26", "2011-06-16", "2012-08-26", "2013-06-06", \n                              "2013-12-23", "2013-12-30", "2014-04-24", "2015-04-24", "2016-05-08")),\n  UserID = c(7L, 3L, 3L, 1L, 2L, 2L, 3L, NA, 7L, 3L),\n  ProductID = c(2L, 4L, 3L, 2L, 4L, 5L, 4L, 2L, 4L, 4L),\n  Quantity = c(1L, 1L, 1L, 3L, 1L, 6L, 1L, 3L, 3L, 4L)\n)\n\n#======================================================================================================\n# Read data from a CSV file\n\n# Load transactions\ntransactions <- fread("https://raw.githubusercontent.com/ben519/DataWrangling/master/Data/transactions.csv")\n\n#======================================================================================================\n# Meta info\n\n# Full summary\nstr(transactions)\n\n# How many rows?\nnrow(transactions)\n\n# How many columns?\nncol(transactions)\n\n# Get the row names\nrownames(transactions)\n\n# Get the column names\ncolnames(transactions)\n\n# Change the name of column "Quantity" to "Quant"\nsetnames(transactions, "Quantity", "Quant")\nsetnames(transactions, "Quant", "Quantity")  # change it back\n\n# Change the name of columns ProductID and UserID to PID and UID respectively\nsetnames(transactions, c("ProductID", "UserID"), c("PID", "UID"))\nsetnames(transactions, c("PID", "UID"), c("ProductID", "UserID"))  # change them back\n\n#======================================================================================================\n# Ordering the rows of a data.table\n\n# Order the rows of transactions by TransactionID descending\ntransactions[order(-TransactionID)]\n\n# Order the rows of transactions by Quantity ascending, TransactionDate descending\nsetorderv(transactions, c("Quantity", "TransactionDate"), order=c(1, -1))\nsetorder(transactions, TransactionID)  # change it back\n\n#======================================================================================================\n# Ordering the columns of a data.table\n\n# Set the column order of transactions as ProductID, Quantity, TransactionDate, TransactionID, UserID\nsetcolorder(transactions, c("ProductID", "Quantity", "TransactionDate", "TransactionID", "UserID"))\nsetcolorder(transactions, c("TransactionID", "TransactionDate", "UserID", "ProductID", "Quantity"))  # reset the column order\n\n# Make UserID the first column of transactions\nsetcolorder(transactions, unique(c("UserID", colnames(transactions))))\nsetcolorder(transactions, c("TransactionID", "TransactionDate", "UserID", "ProductID", "Quantity"))  # reset the column order\n\n#======================================================================================================\n# Extracting vectors from a data.table\n\n# Get the 2nd column\ntransactions[[2]]\n\n# Get the ProductID vector\ntransactions$ProductID\n\n# Get the ProductID vector using a variable\ncol <- "ProductID"\ntransactions[[col]]\n\n#======================================================================================================\n# Row subsetting\n\n# Subset rows 1, 3, and 6\ntransactions[c(1,3,6)]\n\n# Subset rows exlcuding 1, 3, and 6\ntransactions[-c(1,3,6)]\ntransactions[!c(1,3,6)]\n\n# Subset the first 3 rows\ntransactions[1:3]\nhead(transactions, 3)\n\n# Subset rows excluding the first 3 rows\ntransactions[-1:-3]\ntail(transactions, -3)\n\n# Subset the last 2 rows\ntail(transactions, 2)\n\n# Subset rows excluding the last 2 rows\ntail(transactions, -2)\n\n# Subset rows where Quantity > 1\ntransactions[Quantity > 1]\n\n# Subset rows where UserID = 2\ntransactions[UserID == 2]\n\n# Subset rows where Quantity > 1 and UserID = 2\ntransactions[Quantity > 1 & UserID == 2]\n\n# Subset rows where Quantity + UserID is > 3\ntransactions[Quantity + UserID > 3]\n\n# Subset rows where an external vector, foo, is TRUE\nfoo <- c(TRUE, FALSE, TRUE, FALSE, TRUE, FALSE, TRUE, FALSE, TRUE, FALSE)\ntransactions[foo]\n\n# Subset rows where an external vector, bar, is positive\nbar <- c(1, -3, 2, 2, 0, -4, -4, 0, 0, 2)\ntransactions[bar > 0]\n\n# Subset rows where foo is TRUE or bar is negative\ntransactions[foo | bar < 0]\n\n# Subset the rows where foo is not TRUE and bar is not negative\ntransactions[!foo & bar >= 0]\n\n#======================================================================================================\n# Column subsetting\n\n# Subset by columns 1 and 3\ntransactions[, c(1, 3), with=FALSE]\n\n# Subset by columns TransactionID and TransactionDate\ntransactions[, list(TransactionID, TransactionDate)]\ntransactions[, .(TransactionID, TransactionDate)]  # short-hand version of line above\n\n# Subset rows where TransactionID > 5 and subset columns by TransactionID and TransactionDate\ntransactions[TransactionID > 5, list(TransactionID, TransactionDate)]\n\n# Subset columns by a variable vector of columm names\ncols <- c("TransactionID", "UserID", "Quantity")\ntransactions[, cols, with=FALSE]\n\n# Subset columns excluding a variable vector of column names\ncols <- c("TransactionID", "UserID", "Quantity")\ntransactions[, !cols, with=FALSE]\n\n#======================================================================================================\n# Inserting and updating values\n\n# Convert the TransactionDate column to type Date\ntransactions[, TransactionDate := as.Date(TransactionDate)]\n\n# Insert a new column, Foo = UserID + ProductID\ntransactions[, Foo := UserID + ProductID]\n\n# Subset rows where TransactionID is even and set Foo = NA\ntransactions[TransactionID %% 2 == 0, Foo := NA]\n\n# Add 100 to each TransactionID\ntransactions[, TransactionID := TransactionID + 100L]\ntransactions[, TransactionID := TransactionID - 100L]  # revert to original IDs\n\n# Insert a column indicating each row number\ntransactions[, RowIdx := .I]\n\n# Insert columns indicating the rank of each Quantity, minimum Quantity and maximum Quantity\ntransactions[, `:=`(QuantityRk=frank(Quantity, ties.method = "average"), QuantityMin=min(Quantity), QuantityMax=max(Quantity))]\n\n# Remove column Foo\ntransactions[, Foo := NULL]\n\n# Remove multiple columns RowIdx, QuantityRk, and RowIdx\ntransactions[, c("RowIdx", "QuantityRk", "QuantityMin", "QuantityMax") := NULL]\n\n#======================================================================================================\n# Grouping the rows of a data.table\n\n#--------------------------------------------------\n# Group By + Aggregate\n\n# Group the transations per user, measuring the number of transactions per user\ntransactions[, list(Transactions = .N), by=UserID]\n\n# Group the transactions per user, measuring the transactions and average quantity per user\ntransactions[, list(Transactions = .N, QuantityAvg = mean(Quantity)), by=UserID]\n\n# Group the transactions per year of the transaction date, measuring the number of transactions per year\ntransactions[, list(Transactions = .N), by=year(TransactionDate)]\n\n# Group the transactions per (user, transaction-year) pair, measuring the number of transactions per group\ntransactions[, list(Transactions = .N), by=list(UserID, TransactionYear=year(TransactionDate))]\n\n# Group the transactions per user, measuring the max quantity each user made for a single transaction and the date of that transaction\ntransactions[, list(MaxTransactionQuantityDate=TransactionDate[which.max(Quantity)], MaxQuantity=max(Quantity)), by=UserID]\n\n# Group the transactions per (user, transaction-year), and then group by transaction-year to get the number of users who made a transaction each year\ntransactions[, list(Transactions = .N), by=list(UserID, TransactionYear=year(TransactionDate))][, list(Users=.N), by=TransactionYear]\n\n#--------------------------------------------------\n# Group By + Update\n\n# Insert a column in transactions indicating the number of transactions per user\ntransactions[, UserTransactions := .N, by=UserID]\n\n# Insert columns in transactions indicating the first transaction date and last transaction date per user\ntransactions[, `:=`(FirstTransactionDate=min(TransactionDate), LastTransactionDate=max(TransactionDate)), by=UserID]\n\n# For each transaction, get the date of the previous transaction made by the same user\nsetorder(transactions, "UserID", "TransactionDate")\ntransactions[, PrevTransactionDate := c(as.Date(NA), head(TransactionDate, -1)), by=UserID]\n\n#======================================================================================================\n# Joining data.tables\n\n# Load datasets from CSV\nusers <- fread("https://raw.githubusercontent.com/ben519/DataWrangling/master/Data/users.csv")\nsessions <- fread("https://raw.githubusercontent.com/ben519/DataWrangling/master/Data/sessions.csv")\nproducts <- fread("https://raw.githubusercontent.com/ben519/DataWrangling/master/Data/products.csv")\ntransactions <- transactions <- fread("https://raw.githubusercontent.com/ben519/DataWrangling/master/Data/transactions.csv")\n\n# Convert date columns to Date type\nusers[, `:=`(Registered = as.Date(Registered), Cancelled = as.Date(Cancelled))]\nsessions[, SessionDate := as.Date(SessionDate)]\ntransactions[, TransactionDate := as.Date(TransactionDate)]\n\n#--------------------------------------------------\n# Basic Joins\n\n# Join users to transactions, keeping all rows from transactions and only matching rows from users (left join)\nusers[transactions, on="UserID"]\n\n# Which transactions have a UserID not in users? (anti join)\ntransactions[!users, on="UserID"]\n\n# Join users to transactions, keeping only rows from transactions and users that match via UserID (inner join)\nusers[transactions, on="UserID", nomatch=0]\n\n# Join users to transactions, displaying all matching rows AND all non-matching rows (full outer join)\nmerge(users, transactions, by="UserID", all=TRUE)\n\n# Determine which sessions occured on the same day each user registered\nusers[sessions, on=c("UserID", "Registered" = "SessionDate"), nomatch=0]\n\n# Build a dataset with every possible (UserID, ProductID) pair (cross join)\nCJ(UserID=users$UserID, ProductID=products$ProductID)\n\n# Determine how much quantity of each product was purchased by each user\ntransactions[, list(Quantity=sum(Quantity)), by=list(UserID, ProductID)][CJ(UserID=users$UserID, ProductID=products$ProductID), on=c("UserID", "ProductID")]\n\n# For each user, get each possible pair of pair transactions (TransactionID1, TransactionID2)\nt1 <- transactions[, list(UserID, TransactionID1=TransactionID)]\nt2 <- transactions[, list(UserID, TransactionID2=TransactionID)]\nt1[t2, on="UserID", allow.cartesian=TRUE]\n\n# Join each user to his/her first occuring transaction in the transactions table\ntransactions[users, on="UserID", mult="first"]\n\n#--------------------------------------------------\n# Rolling Joins\n\n# Determine the ID of the last session which occured prior to (and including) the date of each transaction per user\nsessions[, RollDate := SessionDate]\ntransactions[, RollDate := TransactionDate]\nsetkey(sessions, "UserID", "RollDate")\nsetkey(transactions, "UserID", "RollDate")\nsessions[transactions, roll=TRUE]\n\n# Determine the ID of the first session which occured after (and including) the date of each transaction per user\nsessions[, RollDate := SessionDate]\ntransactions[, RollDate := TransactionDate]\nsetkey(sessions, "UserID", "RollDate")\nsetkey(transactions, "UserID", "RollDate")\nsessions[transactions, roll=-Inf]\n\n#--------------------------------------------------\n# Non-equi joins\n\n# Determine the first transaction that occured for each user prior to (and including) his/her Cancelled date\nsetorder(transactions, "TransactionDate")\ntransactions[users, on=list(UserID, TransactionDate <= Cancelled), mult="first"]\n\n# Get all transactions where TransactionDate is after the user\'s Cancellation Date\nusers[transactions, on=list(UserID, Cancelled < TransactionDate), nomatch=0]\n\n#--------------------------------------------------\n# Join + Update\n\n# Insert the price of each product in the transactions dataset (join + update)\ntransactions[products, ProductPrice := Price, on="ProductID"]\n\n# Insert the number of transactions each user made into the users dataset\nusers[transactions, on="UserID", Transactions := .N, by=UserID]\n\n#--------------------------------------------------\n# Setting a key and secondary indexing\n\n# Set the key of Transactions as UserID\nsetkey(transactions, "UserID")  # notice rows are now sorted by UserID\n\n# View the key of transactions\nkey(transactions)\n\n# Set the key of users as UserID and join to transactions, matching rows only (inner join)\nsetkey(users, "UserID")\ntransactions[users, nomatch=0]\n\n# Set ProductID as the key of transactions and products without re-ordering the rows, then join matching rows only\nsetkey(transactions, "ProductID", physical=FALSE)\nsetkey(products, "ProductID", physical=FALSE)\ntransactions[products, nomatch=0]\n\n# Set each ID column as a secondary join index\nsetindex(transactions, "TransactionID")\nsetindex(transactions, "ProductID")\nsetindex(transactions, "UserID")\nsetindex(products, "ProductID")\nsetindex(users, "UserID")\n\n# View indices\nindices(transactions)\nindices(products)\nindices(users)\n\n# Inner join between users, transactions, and products\nusers[transactions, on="UserID"][products, on="ProductID"]  # Note that having the pre-computed secondary indices makes this faster\n\n#======================================================================================================\n# Reshaping a data.table\n\n# Read datasets from CSV\nusers <- fread("https://raw.githubusercontent.com/ben519/DataWrangling/master/Data/users.csv")\ntransactions <- transactions <- fread("https://raw.githubusercontent.com/ben519/DataWrangling/master/Data/transactions.csv")\n\n# Convert date columns to Date type\nusers[, `:=`(Registered = as.Date(Registered), Cancelled = as.Date(Cancelled))]\ntransactions[, TransactionDate := as.Date(TransactionDate)]\n\n# Add column TransactionWeekday as a factor with levels Sunday through Saturday\ntransactions[, TransactionWeekday := factor(weekdays(TransactionDate), levels=c("Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"))]\n\n#--------------------------------------------------\n# Convert data from tall format to wide format\n\n# One-hot encode Weekday (i.e. convert data from tall to wide, where each possible weekday is a column)\ndcast(transactions, TransactionID ~ TransactionWeekday, value.var="TransactionWeekday", fun.aggregate=function(x) length(x))\n\n#--------------------------------------------------\n# Convert data from wide format to tall format\n\n# Build a data.table with columns {UserID, ActionType, Date} where ActionType is either "Registered" or "Cancelled" and Date is the corresponding date value\nmelt(users, id.vars="UserID", measure.vars=c("Registered", "Cancelled"), variable.name="ActionType", value.name="Date")\n\n#======================================================================================================\n# To Do\n\n# Get rows which contain at least 1 NA value\n# Get rows which contain at least 1 NA value within a subset of columns\n\n# Get rows which contain all NA values\n# Get rows which contain all NA values within a subset of columns\n\n# Get the max value per row\n# Get the max value per row within a subset of columns\n'