b'{-# LANGUAGE\n    DeriveDataTypeable\n  , DeriveGeneric\n  , DeriveFunctor\n  , DeriveFoldable\n  , DeriveTraversable\n  , FlexibleContexts\n  , FlexibleInstances\n  , GADTs\n  , ScopedTypeVariables\n  , StandaloneDeriving\n  , TupleSections\n  , UndecidableInstances\n  #-}\nmodule Rest.Types.Container\n  ( List(..)\n  , SomeOutput(..)\n  ) where\n\nimport Prelude hiding (mapM)\n\nimport Data.Aeson.Types\nimport Data.JSON.Schema (JSONSchema (..), gSchema)\nimport Data.Typeable\nimport GHC.Generics\nimport Generics.Generic.Aeson\nimport Generics.XmlPickler (gxpickle)\nimport Text.XML.HXT.Arrow.Pickle\nimport Text.XML.HXT.Arrow.Pickle.Schema\nimport Text.XML.HXT.Arrow.Pickle.Xml\nimport qualified Data.JSON.Schema as JSONSchema\n\n-------------------------------------------------------------------------------\n\ndata List a = List\n  { offset :: Int\n  , count  :: Int\n  , items  :: [a]\n  } deriving (Generic, Eq, Ord, Show, Read, Typeable, Functor, Foldable, Traversable)\n\ninstance XmlPickler a => XmlPickler (List a) where xpickle   = gxpickle\ninstance ToJSON     a => ToJSON     (List a) where toJSON    = gtoJson\ninstance FromJSON   a => FromJSON   (List a) where parseJSON = gparseJson\ninstance JSONSchema a => JSONSchema (List a) where schema    = gSchema\n\n-------------------------------------------------------------------------------\n\ndata SomeOutput where\n  SomeOutput :: (XmlPickler o, ToJSON o, JSONSchema o) => o -> SomeOutput\n\nderiving instance Typeable SomeOutput\n\ninstance XmlPickler SomeOutput where\n  xpickle = PU\n    (\\(SomeOutput e) st -> appPickle xpickle e st)\n    (throwMsg "Cannot unpickle SomeOutput.")\n    Any\n\ninstance ToJSON SomeOutput where\n  toJSON (SomeOutput r) = toJSON r\n\ninstance JSONSchema SomeOutput where\n  schema _ = JSONSchema.Any\n'