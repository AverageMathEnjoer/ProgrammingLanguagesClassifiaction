b'#include "TaskStatusTracker.h"\n#include <numeric>\n\nTaskStatusTracker::TaskStatusTracker(AppContext& appContext)\n\t: appContext(appContext)\n{\n\tappContext.taskManager.addCallback(this);\n}\nTaskStatusTracker::~TaskStatusTracker()\n{\n\tappContext.taskManager.removeCallback(this);\n}\n\nvoid TaskStatusTracker::updateTotalProgress()\n{\n\tif (taskList.empty())\n\t{\n\t\ttotalProgress = 0.0f;\n\t\tthis->mainOnTotalProgressUpdate();\n\t\treturn;\n\t}\n\tfloat progressPerTask = 1.0f / (float)(taskList.size() - staleTaskRefs.size());\n\ttotalProgress = std::transform_reduce(taskList.begin(), taskList.end(), 0.0f,\n\t\t[](float a, float b) {return a + b; },\n\t\t[progressPerTask](const TaskStatusDesc& desc) {\n\t\t\tif (desc.hasResult)\n\t\t\t\treturn 0.0f;\n\t\t\tif (desc.range == 0)\n\t\t\t\treturn 0.0f;\n\t\t\tif (desc.progress >= desc.range)\n\t\t\t\treturn 1.0f;\n\t\t\treturn progressPerTask * static_cast<float>(static_cast<double>(desc.progress) / static_cast<double>(desc.range));\n\t\t});\n\tthis->mainOnTotalProgressUpdate();\n}\nvoid TaskStatusTracker::updateLatestProgressMessage()\n{\n\tauto latestElemIt = std::max_element(taskList.begin(), taskList.end(),\n\t\t[](const TaskStatusDesc& a, const TaskStatusDesc& b) { return a.progressDescNumber < b.progressDescNumber; });\n\tif (latestElemIt == taskList.end())\n\t{\n\t\tlatestProgressMessage.clear();\n\t\tthis->mainOnProgressMessageUpdate();\n\t\treturn;\n\t}\n\tlatestProgressMessage = latestElemIt->curProgressDesc;\n\tthis->mainOnProgressMessageUpdate();\n}\n\nvoid TaskStatusTracker::OnAdd(std::shared_ptr<ITask>& pTask)\n{\n\tif (pTask == nullptr)\n\t\treturn;\n\tappContext.postMainThreadCallback([this, pTask]() {\n\t\tauto taskListIt = taskList.end();\n\t\tauto taskMapIt = taskByPtr.find(pTask.get());\n\t\tif (taskMapIt != taskByPtr.end())\n\t\t\treturn;\n\t\ttaskListIt = taskList.insert(taskList.end(), TaskStatusDesc(pTask, taskList.end(), staleTaskRefs.end()));\n\t\ttaskListIt->selfRef = taskListIt;\n\t\ttaskListIt->name = pTask->getName();\n\t\ttaskListIt->progress = 0;\n\t\ttaskListIt->range = 0;\n\t\ttaskByPtr.insert({ pTask.get(), taskListIt });\n\t\tthis->updateTotalProgress();\n\t\tthis->mainOnTaskAdd(taskListIt);\n\t\t});\n}\n\nvoid TaskStatusTracker::OnProgress(std::shared_ptr<ITask>& pTask, unsigned int progress, unsigned int range)\n{\n\tif (pTask == nullptr)\n\t\treturn;\n\tappContext.postMainThreadCallback([this, pTask, progress, range]() {\n\t\tauto taskMapIt = taskByPtr.find(pTask.get());\n\t\tif (taskMapIt == taskByPtr.end())\n\t\t\treturn;\n\t\tauto taskListIt = taskMapIt->second;\n\t\ttaskListIt->progress = progress;\n\t\ttaskListIt->range = range;\n\t\tthis->updateTotalProgress();\n\t\tthis->mainOnTaskProgressUpdate(taskListIt);\n\t});\n}\n\nvoid TaskStatusTracker::OnProgressDesc(std::shared_ptr<ITask>& pTask, const std::string& desc)\n{\n\tif (pTask == nullptr)\n\t\treturn;\n\tappContext.postMainThreadCallback([this, pTask, desc]() {\n\t\tauto taskMapIt = taskByPtr.find(pTask.get());\n\t\tif (taskMapIt == taskByPtr.end())\n\t\t\treturn;\n\t\tauto taskListIt = taskMapIt->second;\n\t\ttaskListIt->curProgressDesc.assign(desc);\n\t\tif (!desc.empty())\n\t\t{\n\t\t\tif (this->progressDescCounter == std::numeric_limits<decltype(this->progressDescCounter)>::max())\n\t\t\t{\n\t\t\t\tthis->progressDescCounter = 1;\n\t\t\t\tfor (TaskStatusDesc& desc : taskList)\n\t\t\t\t\tdesc.progressDescNumber = (desc.curProgressDesc.empty() ? 0 : 1);\n\t\t\t}\n\t\t\ttaskListIt->progressDescNumber = ++this->progressDescCounter;\n\t\t\tthis->latestProgressMessage = desc;\n\t\t\tthis->mainOnProgressMessageUpdate();\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttaskListIt->progressDescNumber = 0;\n\t\t\tthis->updateLatestProgressMessage();\n\t\t}\n\t\tthis->mainOnTaskProgressDescUpdate(taskListIt);\n\t});\n}\nvoid TaskStatusTracker::OnLogMessage(std::shared_ptr<ITask>& pTask, const std::string& msg)\n{\n\tif (pTask == nullptr)\n\t\treturn;\n\t\n\tappContext.postMainThreadCallback([this, pTask, msg]() {\n\t\tauto taskMapIt = taskByPtr.find(pTask.get());\n\t\tif (taskMapIt == taskByPtr.end())\n\t\t\treturn;\n\t\tauto taskListIt = taskMapIt->second;\n\t\tif (!msg.ends_with(\'\\n\'))\n\t\t\ttaskListIt->messages.emplace_back(msg + "\\n");\n\t\telse\n\t\t\ttaskListIt->messages.emplace_back(msg);\n\t\tthis->mainOnTaskAddLogMessage(taskListIt);\n\t});\n}\nvoid TaskStatusTracker::OnCompletion(std::shared_ptr<ITask>& pTask, TaskResult result)\n{\n\tif (pTask == nullptr)\n\t\treturn;\n\tappContext.postMainThreadCallback([this, pTask, result]() {\n\t\tauto taskMapIt = taskByPtr.find(pTask.get());\n\t\tif (taskMapIt == taskByPtr.end())\n\t\t\treturn;\n\t\tauto taskListIt = taskMapIt->second;\n\t\ttaskByPtr.erase(taskMapIt);\n\t\tassert(taskListIt->hasResult == false);\n\t\ttaskListIt->hasResult = true;\n\t\ttaskListIt->result = result;\n\t\tthis->lastTaskResult = result;\n\t\tunsigned int progressDescNumber = taskListIt->progressDescNumber;\n\t\ttaskListIt->progressDescNumber = 0;\n\t\tbool taskProgressDescUpdate = (!taskListIt->curProgressDesc.empty());\n\t\ttaskListIt->curProgressDesc.clear();\n\t\tstaleTaskRefs.push_back(taskListIt);\n\t\tif (progressDescNumber == this->progressDescCounter)\n\t\t\tthis->updateLatestProgressMessage();\n\t\telse\n\t\t\tthis->mainOnProgressMessageUpdate(); //Let the tracker subclass update task counter labels, etc..\n\t\tthis->updateTotalProgress();\n\t\tif (taskProgressDescUpdate)\n\t\t\tthis->mainOnTaskProgressDescUpdate(taskListIt);\n\t\tif (taskListIt->cancelable)\n\t\t{\n\t\t\ttaskListIt->cancelable = false;\n\t\t\tthis->mainOnTaskCancelableChange(taskListIt);\n\t\t}\n\t\tthis->mainOnTaskCompletion(taskListIt);\n\t});\n}\nvoid TaskStatusTracker::OnCancelableChange(std::shared_ptr<ITask>& pTask, bool cancelable)\n{\n\tif (pTask == nullptr)\n\t\treturn;\n\tappContext.postMainThreadCallback([this, pTask, cancelable]() {\n\t\tauto taskMapIt = taskByPtr.find(pTask.get());\n\t\tif (taskMapIt == taskByPtr.end())\n\t\t\treturn;\n\t\tauto taskListIt = taskMapIt->second;\n\t\ttaskListIt->cancelable = cancelable;\n\t\tthis->mainOnTaskCancelableChange(taskListIt);\n\t});\n}\n\nvoid TaskStatusTracker::preEraseElement(std::list<TaskStatusDesc>::iterator listEntry)\n{}\n\nvoid TaskStatusTracker::eraseStaleElements()\n{\n\tif (erasingStaleElements)\n\t{\n\t\trepeatEraseStaleElements = true;\n\t\treturn;\n\t}\n\terasingStaleElements = true;\n\tauto staleListEndIt = staleTaskRefs.end();\n\tdo {\n\t\trepeatEraseStaleElements = false;\n\t\tfor (auto staleListIt = staleTaskRefs.begin(); staleListIt != staleTaskRefs.end();)\n\t\t{\n\t\t\tauto curStaleListIt = staleListIt;\n\t\t\t++staleListIt;\n\n\t\t\ttypename decltype(taskList)::iterator taskListIt = *curStaleListIt;\n\t\t\tif (taskListIt->eraseIfStale)\n\t\t\t{\n\t\t\t\tpreEraseElement(taskListIt);\n\t\t\t\tstaleTaskRefs.erase(curStaleListIt);\n\t\t\t\ttaskList.erase(taskListIt);\n\t\t\t}\n\t\t}\n\t} while (repeatEraseStaleElements);\n\terasingStaleElements = false;\n}\n\nvoid TaskStatusTracker::mainOnTaskAdd(std::list<TaskStatusDesc>::iterator listEntry)\n{}\nvoid TaskStatusTracker::mainOnTaskProgressUpdate(std::list<TaskStatusDesc>::iterator listEntry)\n{}\nvoid TaskStatusTracker::mainOnTaskProgressDescUpdate(std::list<TaskStatusDesc>::iterator listEntry)\n{}\nvoid TaskStatusTracker::mainOnTaskAddLogMessage(std::list<TaskStatusDesc>::iterator listEntry)\n{}\nvoid TaskStatusTracker::mainOnTaskCompletion(std::list<TaskStatusDesc>::iterator listEntry)\n{\n\teraseStaleElements();\n}\nvoid TaskStatusTracker::mainOnTaskCancelableChange(std::list<TaskStatusDesc>::iterator listEntry)\n{}\n\nvoid TaskStatusTracker::mainOnTotalProgressUpdate()\n{}\nvoid TaskStatusTracker::mainOnProgressMessageUpdate()\n{}\n'