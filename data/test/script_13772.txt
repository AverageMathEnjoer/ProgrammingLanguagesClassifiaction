b'{-# LANGUAGE TemplateHaskell #-}\nmodule TreeSitter.Example (tests) where\n\nimport Control.Monad.IO.Class\nimport Foreign\nimport Foreign.C.Types\nimport Hedgehog\nimport TreeSitter.Cursor\nimport TreeSitter.Node\nimport TreeSitter.Parser\n\ntests :: IO Bool\ntests = checkSequential $$(discover)\n\nprop_TSNode_sizeOf = property $\n  sizeOf (undefined :: TSNode) === fromIntegral sizeof_tsnode\n\nprop_TSNode_roundtrips = property $ do\n  peeked <- liftIO (with (TSNode 1 (TSPoint 2 3) 4 nullPtr nullPtr) peek)\n  peeked ===              TSNode 1 (TSPoint 2 3) 4 nullPtr nullPtr\n\nprop_TSPoint_sizeOf = property $\n  sizeOf (undefined :: TSPoint) === fromIntegral sizeof_tspoint\n\nprop_TSPoint_roundtrips = property $ do\n  peeked <- liftIO (with (TSPoint 1 2) peek)\n  peeked ===              TSPoint 1 2\n\nprop_Node_sizeOf = property $\n  sizeOf (undefined :: Node) === fromIntegral sizeof_node\n\nprop_Node_roundtrips = property $ do\n  peeked <- liftIO (with (Node (TSNode 1 (TSPoint 2 3) 4 nullPtr nullPtr) nullPtr 1 (TSPoint 4 5) 7 8 nullPtr 9 10) peek)\n  peeked ===              Node (TSNode 1 (TSPoint 2 3) 4 nullPtr nullPtr) nullPtr 1 (TSPoint 4 5) 7 8 nullPtr 9 10\n\nprop_TSTreeCursor_sizeOf = property $\n  sizeOfCursor === fromIntegral sizeof_tstreecursor\n\nprop_Parser_timeout = property $ do\n  parser <- liftIO ts_parser_new\n  timeout <- liftIO (ts_parser_timeout_micros parser)\n  timeout === 0\n  liftIO (ts_parser_set_timeout_micros parser 1000)\n  timeout <- liftIO (ts_parser_timeout_micros parser)\n  timeout === 1000\n  liftIO (ts_parser_delete parser)\n\nforeign import ccall unsafe "src/bridge.c sizeof_tsnode" sizeof_tsnode :: CSize\nforeign import ccall unsafe "src/bridge.c sizeof_tspoint" sizeof_tspoint :: CSize\nforeign import ccall unsafe "src/bridge.c sizeof_node" sizeof_node :: CSize\nforeign import ccall unsafe "src/bridge.c sizeof_tstreecursor" sizeof_tstreecursor :: CSize\n'