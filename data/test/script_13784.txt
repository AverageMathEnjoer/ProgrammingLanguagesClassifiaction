b'{-# LANGUAGE FunctionalDependencies #-}\n{-# LANGUAGE TypeApplications #-}\n{-# LANGUAGE UndecidableInstances #-}\n{-# LANGUAGE DataKinds #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n\nmodule Database.Beam.Migrate.SQL.Tables\n  ( -- * Table manipulation\n\n    -- ** Creation and deletion\n    createTable, dropTable\n  , preserve\n\n    -- ** @ALTER TABLE@\n  , TableMigration(..)\n  , ColumnMigration(..)\n  , alterTable\n\n  , renameTableTo, renameColumnTo\n  , addColumn, dropColumn\n\n    -- * Field specification\n  , DefaultValue, Constraint(..), NotNullConstraint\n\n  , field\n\n  , defaultTo_, notNull, unique\n\n    -- ** Internal classes\n    --    Provided without documentation for use in type signatures\n  , FieldReturnType(..)\n  , IsNotNull\n  ) where\n\nimport Database.Beam\nimport Database.Beam.Schema.Tables\nimport Database.Beam.Backend.SQL\nimport Database.Beam.Backend.SQL.AST (TableName(..))\nimport Database.Beam.Query.Internal (tableNameFromEntity)\n\nimport Database.Beam.Migrate.Types\nimport Database.Beam.Migrate.Checks\nimport Database.Beam.Migrate.SQL.Types\nimport Database.Beam.Migrate.SQL.SQL92\n\nimport Control.Applicative\nimport Control.Monad.Identity\nimport Control.Monad.Writer.Strict\nimport Control.Monad.State\n\nimport Data.Text (Text)\nimport Data.Typeable\nimport qualified Data.Kind as Kind (Constraint)\n\nimport GHC.TypeLits\n\nimport Lens.Micro ((^.))\n\n-- * Table manipulation\n\n-- | Add a @CREATE TABLE@ statement to this migration\n--\n--   The first argument is the name of the table.\n--\n--   The second argument is a table containing a \'FieldSchema\' for each field.\n--   See documentation on the \'Field\' command for more information.c\ncreateTable :: ( Beamable table, Table table\n               , BeamMigrateSqlBackend be )\n            => Text -> TableSchema be table\n            -> Migration be (CheckedDatabaseEntity be db (TableEntity table))\ncreateTable newTblName tblSettings =\n  do let pkFields = allBeamValues (\\(Columnar\' (TableFieldSchema name _ _)) -> name) (primaryKey tblSettings)\n         tblConstraints = if null pkFields then [] else [ primaryKeyConstraintSyntax pkFields ]\n         createTableCommand =\n           createTableSyntax Nothing (tableName Nothing newTblName)\n                             (allBeamValues (\\(Columnar\' (TableFieldSchema name (FieldSchema schema) _)) -> (name, schema)) tblSettings)\n                             tblConstraints\n         command = createTableCmd createTableCommand\n\n         tbl\' = changeBeamRep (\\(Columnar\' (TableFieldSchema name _ _)) -> Columnar\' (TableField (pure name) name)) tblSettings\n\n         fieldChecks = changeBeamRep (\\(Columnar\' (TableFieldSchema _ _ cs)) -> Columnar\' (Const cs)) tblSettings\n\n         tblChecks = [ TableCheck (\\tblName _ -> Just (SomeDatabasePredicate (TableExistsPredicate tblName))) ] ++\n                     primaryKeyCheck\n\n         primaryKeyCheck =\n           case allBeamValues (\\(Columnar\' (TableFieldSchema name _ _)) -> name) (primaryKey tblSettings) of\n             [] -> []\n             cols -> [ TableCheck (\\tblName _ -> Just (SomeDatabasePredicate (TableHasPrimaryKey tblName cols))) ]\n\n     upDown command Nothing\n     pure (CheckedDatabaseEntity (CheckedDatabaseTable (DatabaseTable Nothing newTblName newTblName tbl\') tblChecks fieldChecks) [])\n\n-- | Add a @DROP TABLE@ statement to this migration.\ndropTable :: BeamMigrateSqlBackend be\n          => CheckedDatabaseEntity be db (TableEntity table)\n          -> Migration be ()\ndropTable (CheckedDatabaseEntity (CheckedDatabaseTable dt _ _) _) =\n  let command = dropTableCmd (dropTableSyntax (tableNameFromEntity dt))\n  in upDown command Nothing\n\n-- | Copy a table schema from one database to another\npreserve :: CheckedDatabaseEntity be db e\n         -> Migration be (CheckedDatabaseEntity be db\' e)\npreserve (CheckedDatabaseEntity desc checks) = pure (CheckedDatabaseEntity desc checks)\n\n-- * Alter table\n\n-- | A column in the process of being altered\ndata ColumnMigration a\n  = ColumnMigration\n  { columnMigrationFieldName :: Text\n  , columnMigrationFieldChecks :: [FieldCheck] }\n\n-- | Monad representing a series of @ALTER TABLE@ statements\nnewtype TableMigration be a\n  = TableMigration (WriterT [BeamSqlBackendAlterTableSyntax be] (State (TableName, [TableCheck])) a)\n  deriving (Monad, Applicative, Functor)\n\n-- | @ALTER TABLE ... RENAME TO@ command\nrenameTableTo :: BeamMigrateSqlBackend be\n              => Text -> table ColumnMigration\n              -> TableMigration be (table ColumnMigration)\nrenameTableTo newName oldTbl = TableMigration $ do\n  (TableName curSchema curNm, chks) <- get\n  tell [ alterTableSyntax (tableName curSchema curNm) (renameTableToSyntax newName) ]\n  put (TableName curSchema curNm, chks)\n  return oldTbl\n\n-- | @ALTER TABLE ... RENAME COLUMN ... TO ...@ command\nrenameColumnTo :: BeamMigrateSqlBackend be\n               => Text -> ColumnMigration a\n               -> TableMigration be (ColumnMigration a)\nrenameColumnTo newName column = TableMigration $ do\n  (TableName curSchema curNm, _) <- get\n  tell [ alterTableSyntax (tableName curSchema curNm)\n           (renameColumnToSyntax (columnMigrationFieldName column) newName) ]\n  pure column { columnMigrationFieldName = newName }\n\n-- | @ALTER TABLE ... DROP COLUMN ...@ command\ndropColumn :: BeamMigrateSqlBackend be\n           => ColumnMigration a -> TableMigration be ()\ndropColumn column = TableMigration $ do\n  (TableName curSchema curNm, _)<- get\n  tell [ alterTableSyntax (tableName curSchema curNm)\n           (dropColumnSyntax (columnMigrationFieldName column)) ]\n\n-- | @ALTER TABLE ... ADD COLUMN ...@ command\naddColumn :: BeamMigrateSqlBackend be\n          => TableFieldSchema be a\n          -> TableMigration be (ColumnMigration a)\naddColumn (TableFieldSchema nm (FieldSchema fieldSchemaSyntax) checks) =\n  TableMigration $\n  do (TableName curSchema curNm, _) <- get\n     tell [ alterTableSyntax (tableName curSchema curNm) (addColumnSyntax nm fieldSchemaSyntax) ]\n     pure (ColumnMigration nm checks)\n\n-- | Compose a series of @ALTER TABLE@ commands\n--\n--   Example usage\n--\n-- @\n-- migrate (OldDb oldTbl) = do\n--   alterTable oldTbl $ \\oldTbl\' ->\n--     field2 <- renameColumnTo "NewNameForField2" (_field2 oldTbl\')\n--     dropColumn (_field3 oldTbl\')\n--     renameTableTo "NewTableName"\n--     field4 <- addColumn (field "ANewColumn" smallint notNull (defaultTo_ (val_ 0)))\n--     return (NewTable (_field1 oldTbl\') field2 field4)\n-- @\n--\n--   The above would result in commands like:\n--\n-- @\n-- ALTER TABLE <oldtable> RENAME COLUMN <field2> TO "NewNameForField2";\n-- ALTER TABLE <oldtable> DROP COLUMN <field3>;\n-- ALTER TABLE <oldtable> RENAME TO "NewTableName";\n-- ALTER TABLE "NewTableName" ADD COLUMN "ANewColumn" SMALLINT NOT NULL DEFAULT 0;\n-- @\n--\nalterTable :: forall be db db\' table table\'\n            . (Table table\', BeamMigrateSqlBackend be)\n           => CheckedDatabaseEntity be db (TableEntity table)\n           -> (table ColumnMigration -> TableMigration be (table\' ColumnMigration))\n           -> Migration be (CheckedDatabaseEntity be db\' (TableEntity table\'))\nalterTable (CheckedDatabaseEntity (CheckedDatabaseTable dt tblChecks tblFieldChecks) entityChecks) alterColumns =\n let initialTbl = runIdentity $\n                  zipBeamFieldsM\n                      (\\(Columnar\' fd :: Columnar\' (TableField table) x)\n                        (Columnar\' (Const checks) :: Columnar\' (Const [FieldCheck]) x) ->\n                         pure (Columnar\' (ColumnMigration (fd ^. fieldName) checks)\n                               :: Columnar\' ColumnMigration x))\n                      (dbTableSettings dt) tblFieldChecks\n\n     TableMigration alterColumns\' = alterColumns initialTbl\n     ((newTbl, cmds), (TableName tblSchema\' tblNm\', tblChecks\')) =\n       runState (runWriterT alterColumns\')\n                ( TableName (dbTableSchema dt) (dbTableCurrentName dt)\n                , tblChecks )\n\n     fieldChecks\' = changeBeamRep (\\(Columnar\' (ColumnMigration _ checks) :: Columnar\' ColumnMigration a) ->\n                                     Columnar\' (Const checks) :: Columnar\' (Const [FieldCheck]) a)\n                                  newTbl\n\n     tbl\' :: TableSettings table\'\n     tbl\' = changeBeamRep (\\(Columnar\' (ColumnMigration nm _) :: Columnar\' ColumnMigration a) ->\n                              Columnar\' (TableField (pure nm) nm) :: Columnar\' (TableField table\') a)\n                          newTbl\n in forM_ cmds (\\cmd -> upDown (alterTableCmd cmd) Nothing) >>\n    pure (CheckedDatabaseEntity (CheckedDatabaseTable\n                                  (DatabaseTable tblSchema\' (dbTableOrigName dt)\n                                     tblNm\' tbl\')\n                                   tblChecks\' fieldChecks\') entityChecks)\n\n-- * Fields\n\n-- | Build a schema for a field. This function takes the name and type of the\n-- field and a variable number of modifiers, such as constraints and default\n-- values. GHC will complain at you if the modifiers do not make sense. For\n-- example, you cannot apply the \'notNull\' constraint to a column with a \'Maybe\'\n-- type.\n--\n-- Example of creating a table named "Employee" with three columns: "FirstName",\n-- "LastName", and "HireDate"\n--\n-- @\n-- data Employee f =\n--   Employee { _firstName :: C f Text\n--            , _lastName  :: C f Text\n--            , _hireDate  :: C f (Maybe LocalTime)\n--            } deriving Generic\n-- instance Beamable Employee\n--\n-- instance Table Employee where\n--    data PrimaryKey Employee f = EmployeeKey (C f Text) (C f Text) deriving Generic\n--    primaryKey = EmployeeKey \\<$\\> _firstName \\<*\\> _lastName\n--\n-- instance Beamable PrimaryKey Employee f\n--\n-- data EmployeeDb entity\n--     = EmployeeDb { _employees :: entity (TableEntity Employee) }\n--     deriving Generic\n-- instance Database EmployeeDb\n--\n-- migration :: IsSql92DdlCommandSyntax syntax => Migration syntax () EmployeeDb\n-- migration = do\n--   employees <- createTable "EmployeesTable"\n--                  (Employee (field "FirstNameField" (varchar (Just 15)) notNull)\n--                            (field "last_name" (varchar Nothing) notNull (defaultTo_ (val_ "Smith")))\n--                            (field "hiredDate" (maybeType timestamp)))\n--   return (EmployeeDb employees)\n-- @\nfield :: ( BeamMigrateSqlBackend be\n         , FieldReturnType \'False \'False be resTy a )\n      => Text -> DataType be resTy -> a\nfield name (DataType ty) = field\' (Proxy @\'False) (Proxy @\'False) name ty Nothing Nothing []\n\n-- ** Default values\n\n-- | Represents the default value of a field with a given column schema syntax and type\nnewtype DefaultValue be a = DefaultValue (BeamSqlBackendExpressionSyntax be)\n\n-- | Build a \'DefaultValue\' from a \'QExpr\'. GHC will complain if you supply more\n-- than one default value.\ndefaultTo_ :: BeamMigrateSqlBackend be\n           => (forall s. QExpr be s a)\n           -> DefaultValue be a\ndefaultTo_ (QExpr e) =\n  DefaultValue (e "t")\n\n-- ** Constraints\n\n-- | Represents a constraint in the given column schema syntax\nnewtype Constraint be\n  = Constraint (BeamSqlBackendConstraintSyntax be)\n\nnewtype NotNullConstraint be\n  = NotNullConstraint (Constraint be)\n\n-- | The SQL92 @NOT NULL@ constraint\nnotNull :: BeamMigrateSqlBackend be => NotNullConstraint be\nnotNull = NotNullConstraint (Constraint notNullConstraintSyntax)\n\n-- | SQL @UNIQUE@ constraint\nunique :: BeamMigrateSqlBackend be => Constraint be\nunique = Constraint uniqueColumnConstraintSyntax\n\n-- ** \'field\' variable arity classes\n\nclass FieldReturnType (defaultGiven :: Bool) (collationGiven :: Bool) be resTy a | a -> be resTy where\n  field\' :: BeamMigrateSqlBackend be\n         => Proxy defaultGiven -> Proxy collationGiven\n         -> Text\n         -> BeamMigrateSqlBackendDataTypeSyntax be\n         -> Maybe (BeamSqlBackendExpressionSyntax be)\n         -> Maybe Text -> [ BeamSqlBackendColumnConstraintDefinitionSyntax be ]\n         -> a\n\ninstance FieldReturnType \'True collationGiven be resTy a =>\n  FieldReturnType \'False collationGiven be resTy (DefaultValue be resTy -> a) where\n  field\' _ collationGiven nm ty _ collation constraints (DefaultValue e) =\n    field\' (Proxy @\'True) collationGiven nm ty (Just e) collation constraints\n\ninstance FieldReturnType defaultGiven collationGiven be resTy a =>\n  FieldReturnType defaultGiven collationGiven be resTy (Constraint be -> a) where\n  field\' defaultGiven collationGiven nm ty default_\' collation constraints (Constraint e) =\n    field\' defaultGiven collationGiven nm ty default_\' collation (constraints ++ [ constraintDefinitionSyntax Nothing e Nothing ])\n\ninstance ( FieldReturnType defaultGiven collationGiven be resTy (Constraint be -> a)\n         , IsNotNull resTy ) =>\n  FieldReturnType defaultGiven collationGiven be resTy (NotNullConstraint be -> a) where\n  field\' defaultGiven collationGiven nm ty default_\' collation constraints (NotNullConstraint c) =\n    field\' defaultGiven collationGiven nm ty default_\' collation constraints c\n\ninstance ( FieldReturnType \'True collationGiven be resTy a\n         , TypeError (\'Text "Only one DEFAULT clause can be given per \'field\' invocation") ) =>\n  FieldReturnType \'True collationGiven be resTy (DefaultValue be resTy -> a) where\n\n  field\' = error "Unreachable because of GHC Custom Type Errors"\n\ninstance ( FieldReturnType defaultGiven collationGiven be resTy a\n         , TypeError (\'Text "Only one type declaration allowed per \'field\' invocation")) =>\n  FieldReturnType defaultGiven collationGiven be resTy (DataType be\' x -> a) where\n  field\' = error "Unreachable because of GHC Custom Type Errors"\n\ninstance ( BeamMigrateSqlBackend be, HasDataTypeCreatedCheck (BeamMigrateSqlBackendDataTypeSyntax be) ) =>\n  FieldReturnType defaultGiven collationGiven be resTy (TableFieldSchema be resTy) where\n  field\' _ _ nm ty default_\' collation constraints =\n    TableFieldSchema nm (FieldSchema (columnSchemaSyntax ty default_\' constraints collation)) checks\n    where checks = [ FieldCheck (\\tbl field\'\' -> SomeDatabasePredicate (TableHasColumn tbl field\'\' ty :: TableHasColumn be)) ] ++\n                   map (\\cns -> FieldCheck (\\tbl field\'\' -> SomeDatabasePredicate (TableColumnHasConstraint tbl field\'\' cns :: TableColumnHasConstraint be))) constraints\n\ntype family IsNotNull (x :: *) :: Kind.Constraint where\n  IsNotNull (Maybe x) = TypeError (\'Text "You used Database.Beam.Migrate.notNull on a column with type" \':$$:\n                                   \'ShowType (Maybe x) \':$$:\n                                   \'Text "Either remove \'notNull\' from your migration or \'Maybe\' from your table")\n  IsNotNull x = ()\n'