b"{-# OPTIONS_GHC -fno-warn-orphans #-}\n{-# LANGUAGE\n    CPP\n  , RankNTypes\n  #-}\n#if MIN_VERSION_base(4,9,0)\n{-# OPTIONS_GHC -Wno-redundant-constraints #-}\n#endif\nmodule Rest.Driver.Happstack\n  ( apiToHandler\n  , apiToHandler'\n  ) where\n\nimport Control.Applicative\nimport Control.Concurrent.MVar (readMVar)\nimport Control.Monad\nimport Control.Monad.Trans (MonadIO (liftIO))\nimport Happstack.Server\n\nimport qualified Data.ByteString.UTF8 as UTF8\nimport qualified Data.Map             as M\nimport qualified Happstack.Server     as Happstack\n\nimport Rest.Api (Api)\nimport Rest.Driver.Perform (Rest (..))\nimport Rest.Driver.Types (Run)\n\nimport qualified Rest.Driver.Types as Rest\nimport qualified Rest.Run          as Rest\n\napiToHandler :: (Functor m, MonadPlus m, MonadIO m, Rest m) => Api m -> m Response\napiToHandler = apiToHandler' id\n\napiToHandler' :: (Applicative m, Functor n, Monad m, MonadPlus n, MonadIO n, Rest n) => Run m n -> Api m -> n Response\napiToHandler' run api = toResponse <$> Rest.apiToHandler' run api\n\ninstance (Functor m, MonadPlus m, MonadIO m) => Rest (ServerPartT m) where\n  getHeader nm     = fmap UTF8.toString . Happstack.getHeader nm <$> askRq\n  getParameter  nm = optional (look nm)\n  getBody =\n    do rq <- askRq\n       bdy <- liftIO (readMVar (rqBody rq))\n       return (unBody bdy)\n  getMethod       = toRestMethod . rqMethod <$> askRq\n  getPaths        = rqPaths <$> askRq\n  lookupMimeType  = return . flip M.lookup Happstack.mimeTypes\n  setHeader       = Happstack.setHeaderM\n  setResponseCode = Happstack.setResponseCode\n\ntoRestMethod :: Happstack.Method -> Maybe Rest.Method\ntoRestMethod Happstack.GET    = Just Rest.GET\ntoRestMethod Happstack.POST   = Just Rest.POST\ntoRestMethod Happstack.PUT    = Just Rest.PUT\ntoRestMethod Happstack.DELETE = Just Rest.DELETE\ntoRestMethod _                = Nothing\n"