b'#include <sys/mman.h>\n#include <dlfcn.h>\n#include <dl.h>\n#include <link.h>\n#include <string>\n#include <magisk.h>\n#include <android_prop.h>\n#include "hide_utils.h"\n#include "logging.h"\n#include "module.h"\n#include "entry.h"\n#include <iostream>\n#include <elf_util.h>\n#include <set>\n\nnamespace hide {\n    namespace {\n        class ProtectedDataGuard {\n\n        public:\n            ProtectedDataGuard() {\n                if (ctor != nullptr)\n                    (this->*ctor)();\n            }\n\n            ~ProtectedDataGuard() {\n                if (dtor != nullptr)\n                    (this->*dtor)();\n            }\n\n            static bool setup(const SandHook::ElfImg &linker) {\n                ctor = MemFunc{.data = {.p = reinterpret_cast<void *>(linker.getSymbAddress(\n                        "__dl__ZN18ProtectedDataGuardC2Ev")),\n                        .adj = 0}}\n                        .f;\n                dtor = MemFunc{.data = {.p = reinterpret_cast<void *>(linker.getSymbAddress(\n                        "__dl__ZN18ProtectedDataGuardD2Ev")),\n                        .adj = 0}}\n                        .f;\n                return ctor != nullptr && dtor != nullptr;\n            }\n\n            ProtectedDataGuard(const ProtectedDataGuard &) = delete;\n\n            void operator=(const ProtectedDataGuard &) = delete;\n\n        private:\n            using FuncType = void (ProtectedDataGuard::*)();\n\n            static FuncType ctor;\n            static FuncType dtor;\n\n            union MemFunc {\n                FuncType f;\n\n                struct {\n                    void *p;\n                    std::ptrdiff_t adj;\n                } data;\n            };\n        };\n\n        ProtectedDataGuard::FuncType ProtectedDataGuard::ctor = nullptr;\n        ProtectedDataGuard::FuncType ProtectedDataGuard::dtor = nullptr;\n\n        struct soinfo;\n\n        soinfo *solist = nullptr;\n        soinfo **sonext = nullptr;\n        soinfo *somain = nullptr;\n\n        template<typename T>\n        inline T *getStaticVariable(const SandHook::ElfImg &linker, std::string_view name) {\n            auto *addr = reinterpret_cast<T **>(linker.getSymbAddress(name.data()));\n            return addr == nullptr ? nullptr : *addr;\n        }\n\n        struct soinfo {\n            soinfo *next() {\n                return *(soinfo **) ((uintptr_t) this + solist_next_offset);\n            }\n\n            void next(soinfo *si) {\n                *(soinfo **) ((uintptr_t) this + solist_next_offset) = si;\n            }\n\n            const char *get_realpath() {\n                return get_realpath_sym ? get_realpath_sym(this) : ((std::string *) (\n                        (uintptr_t) this + solist_realpath_offset))->c_str();\n\n            }\n\n            static bool setup(const SandHook::ElfImg &linker) {\n                get_realpath_sym = reinterpret_cast<decltype(get_realpath_sym)>(linker.getSymbAddress(\n                        "__dl__ZNK6soinfo12get_realpathEv"));\n                auto vsdo = getStaticVariable<soinfo>(linker, "__dl__ZL4vdso");\n                for (size_t i = 0; i < 1024 / sizeof(void *); i++) {\n                    auto *possible_next = *(void **) ((uintptr_t) solist + i * sizeof(void *));\n                    if (possible_next == somain || (vsdo != nullptr && possible_next == vsdo)) {\n                        solist_next_offset = i * sizeof(void *);\n                        return android_prop::GetApiLevel() < 26 || get_realpath_sym != nullptr;\n                    }\n                }\n                LOGW("failed to search next offset");\n                // shortcut\n                return android_prop::GetApiLevel() < 26 || get_realpath_sym != nullptr;\n            }\n\n#ifdef __LP64__\n            constexpr static size_t solist_realpath_offset = 0x1a8;\n            inline static size_t solist_next_offset = 0x30;\n#else\n            constexpr static size_t solist_realpath_offset = 0x174;\n            inline static size_t solist_next_offset = 0xa4;\n#endif\n\n            // since Android 8\n            inline static const char *(*get_realpath_sym)(soinfo *);\n        };\n\n        bool solist_remove_soinfo(soinfo *si) {\n            soinfo *prev = nullptr, *trav;\n            for (trav = solist; trav != nullptr; trav = trav->next()) {\n                if (trav == si) {\n                    break;\n                }\n                prev = trav;\n            }\n\n            if (trav == nullptr) {\n                // si was not in solist\n                LOGE("name \\"%s\\"@%p is not in solist!", si->get_realpath(), si);\n                return false;\n            }\n\n            // prev will never be null, because the first entry in solist is\n            // always the static libdl_info.\n            prev->next(si->next());\n            if (si == *sonext) {\n                *sonext = prev;\n            }\n\n            LOGD("removed soinfo: %s", si->get_realpath());\n\n            return true;\n        }\n\n        const auto initialized = []() {\n            SandHook::ElfImg linker("/linker");\n            return ProtectedDataGuard::setup(linker) &&\n                   (solist = getStaticVariable<soinfo>(linker, "__dl__ZL6solist")) != nullptr &&\n                   (sonext = linker.getSymbAddress<soinfo**>("__dl__ZL6sonext")) != nullptr &&\n                   (somain = getStaticVariable<soinfo>(linker, "__dl__ZL6somain")) != nullptr &&\n                   soinfo::setup(linker);\n        }();\n\n        std::list<soinfo *> linker_get_solist() {\n            std::list<soinfo *> linker_solist{};\n            for (auto *iter = solist; iter; iter = iter->next()) {\n                linker_solist.push_back(iter);\n            }\n            return linker_solist;\n        }\n\n        void RemovePathsFromSolist(const std::set<std::string_view> &names) {\n            if (!initialized) {\n                LOGW("not initialized");\n                return;\n            }\n            ProtectedDataGuard g;\n            for (const auto &soinfo : linker_get_solist()) {\n                const auto &real_path = soinfo->get_realpath();\n                if (real_path && names.count(real_path)) {\n                    solist_remove_soinfo(soinfo);\n                }\n            }\n        }\n\n        using riru_hide_t = int(const std::set<std::string_view> &names);\n\n        void *riru_hide_handle;\n        riru_hide_t *riru_hide_func;\n\n        void HidePathsFromMaps(const std::set<std::string_view> &names) {\n            if (!riru_hide_func) return;\n\n            LOGD("do hide");\n            riru_hide_func(names);\n\n            // cleanup riruhide.so\n            LOGD("dlclose");\n            if (dlclose(riru_hide_handle) != 0) {\n                LOGE("dlclose failed: %s", dlerror());\n                return;\n            }\n        }\n    }  // namespace\n\n    void HideFromMaps() {\n        auto self_path = magisk::GetPathForSelfLib("libriru.so");\n        std::set<std::string_view> names{self_path};\n        for (const auto &module : modules::Get()) {\n            if (module.supportHide) {\n                if (!module.isLoaded()) {\n                    LOGD("%s is unloaded", module.id.data());\n                } else {\n                    names.emplace(module.path);\n                }\n            } else {\n                LOGD("module %s does not support hide", module.id.data());\n            }\n        }\n        if (!names.empty()) hide::HidePathsFromMaps(names);\n    }\n\n    static void RemoveFromSoList(const std::set<std::string_view> &names) {\n        hide::RemovePathsFromSolist(names);\n    }\n\n    void HideFromSoList() {\n        auto self_path = magisk::GetPathForSelfLib("libriru.so");\n        std::set<std::string_view> names_to_remove{};\n        if (Entry::IsSelfUnloadAllowed()) {\n            LOGD("don\'t hide self since it will be unloaded");\n        } else {\n            names_to_remove.emplace(self_path);\n        }\n        for (const auto &module : modules::Get()) {\n            if (module.supportHide) {\n                if (!module.isLoaded()) {\n                    LOGD("%s is unloaded", module.id.data());\n                    continue;\n                }\n                if (module.apiVersion < 24) {\n                    LOGW("%s is too old to hide so", module.id.data());\n                } else {\n                    names_to_remove.emplace(module.path);\n                }\n            } else {\n                LOGD("module %s does not support hide", module.id.data());\n            }\n        }\n\n        if (android_prop::GetApiLevel() >= 23 && !names_to_remove.empty()) {\n            RemoveFromSoList(names_to_remove);\n        }\n    }\n\n    void PrepareMapsHideLibrary() {\n        auto hide_lib_path = magisk::GetPathForSelfLib("libriruhide.so");\n\n        // load riruhide.so and run the hide\n        LOGD("dlopen libriruhide");\n        riru_hide_handle = DlopenExt(hide_lib_path.c_str(), 0);\n        if (!riru_hide_handle) {\n            LOGE("dlopen %s failed: %s", hide_lib_path.c_str(), dlerror());\n            return;\n        }\n        riru_hide_func = reinterpret_cast<riru_hide_t *>(dlsym(riru_hide_handle, "riru_hide"));\n        if (!riru_hide_func) {\n            LOGE("dlsym failed: %s", dlerror());\n            dlclose(riru_hide_handle);\n            return;\n        }\n    }\n}  // namespace Hide\n'