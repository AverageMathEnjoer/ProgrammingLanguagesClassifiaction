b'package effectivejava.chapter2.item6;\nimport java.util.regex.Pattern;\n\n// Reusing expensive object for improved performance (Pages 22 and 23)\npublic class RomanNumerals {\n    // Performance can be greatly improved! (Page 22)\n    static boolean isRomanNumeralSlow(String s) {\n        return s.matches("^(?=.)M*(C[MD]|D?C{0,3})"\n                + "(X[CL]|L?X{0,3})(I[XV]|V?I{0,3})$");\n    }\n\n    // Reusing expensive object for improved performance (Page 23)\n    private static final Pattern ROMAN = Pattern.compile(\n            "^(?=.)M*(C[MD]|D?C{0,3})"\n                    + "(X[CL]|L?X{0,3})(I[XV]|V?I{0,3})$");\n\n    static boolean isRomanNumeralFast(String s) {\n        return ROMAN.matcher(s).matches();\n    }\n\n    public static void main(String[] args) {\n        int numSets = Integer.parseInt(args[0]);\n        int numReps = Integer.parseInt(args[1]);\n        boolean b = false;\n\n        for (int i = 0; i < numSets; i++) {\n            long start = System.nanoTime();\n            for (int j = 0; j < numReps; j++) {\n                b ^= isRomanNumeralSlow("MCMLXXVI");  // Change Slow to Fast to see performance difference\n            }\n            long end = System.nanoTime();\n            System.out.println(((end - start) / (1_000. * numReps)) + " \xce\xbcs.");\n        }\n\n        // Prevents VM from optimizing away everything.\n        if (!b)\n            System.out.println();\n    }\n}\n\n'