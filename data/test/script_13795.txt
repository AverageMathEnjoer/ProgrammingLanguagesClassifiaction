b"{-# LANGUAGE DuplicateRecordFields #-}\n\nmodule Cachix.API.WebSocketSubprotocol where\n\nimport qualified Control.Concurrent.Async as Async\nimport qualified Control.Concurrent.STM.TMQueue as TMQueue\nimport qualified Control.Exception.Safe as Safe\nimport qualified Data.Aeson as Aeson\nimport Data.Time (UTCTime)\nimport Data.UUID (UUID)\nimport qualified Network.WebSockets as WS\nimport Protolude\n\ndata Message cmd = Message\n  { method :: Text,\n    command :: cmd,\n    agent :: Maybe UUID,\n    id :: UUID\n  }\n  deriving (Show, Eq, Generic, Aeson.FromJSON, Aeson.ToJSON)\n\ndata Cache = Cache\n  { cacheName :: Text,\n    publicKey :: Text,\n    isPublic :: Bool\n  }\n  deriving (Show, Eq, Generic, Aeson.FromJSON, Aeson.ToJSON)\n\ndata AgentInformation = AgentInformation\n  { cache :: Maybe Cache,\n    id :: UUID\n  }\n  deriving (Show, Eq, Generic, Aeson.FromJSON, Aeson.ToJSON)\n\ndata DeploymentDetails = DeploymentDetails\n  { storePath :: Text,\n    id :: UUID,\n    index :: Int64,\n    rollbackScript :: Maybe Text\n  }\n  deriving (Show, Eq, Generic, Aeson.FromJSON, Aeson.ToJSON)\n\ndata BackendCommand\n  = Deployment DeploymentDetails\n  | AgentRegistered AgentInformation\n  deriving (Show, Eq, Generic, Aeson.FromJSON, Aeson.ToJSON)\n\ndata AgentCommand\n  = DeploymentStarted {id :: UUID, time :: UTCTime, closureSize :: Maybe Int64}\n  | DeploymentFinished {id :: UUID, time :: UTCTime, hasSucceeded :: Bool}\n  deriving (Show, Eq, Generic, Aeson.FromJSON, Aeson.ToJSON)\n\nparseMessage :: Aeson.FromJSON cmd => ByteString -> Either Text (Message cmd)\nparseMessage = first toS . Aeson.eitherDecodeStrict'\n\nsendMessage :: Aeson.ToJSON cmd => WS.Connection -> Message cmd -> IO ()\nsendMessage connection cmd =\n  WS.sendTextData connection (Aeson.encode cmd)\n\n-- | Receive and process messages in parallel.\n--\n-- Note: This will not rethrow the 'CloseRequest' exception!\n--\n-- TODO: use Async.replicateConcurrently\nreceiveDataConcurrently :: WS.Connection -> (ByteString -> IO ()) -> IO ()\nreceiveDataConcurrently connection action =\n  do\n    queue <- atomically TMQueue.newTMQueue\n    Async.withAsync (consumer queue) (producer queue)\n  where\n    producer queue consumerThread =\n      loop\n        `finally` closeGracefully queue consumerThread\n        `Safe.catch` closeRequest\n      where\n        loop = do\n          payload <- WS.receiveData connection\n          atomically $ TMQueue.writeTMQueue queue payload\n          loop\n\n    consumer queue = loop\n      where\n        loop = do\n          payload <- atomically $ TMQueue.readTMQueue queue\n          case payload of\n            Nothing -> return ()\n            Just msg -> action msg *> loop\n\n    -- Close the queue and wait for the consumer finish processing messages.\n    closeGracefully :: TMQueue.TMQueue a -> Async.Async () -> IO ()\n    closeGracefully queue consumerThread = do\n      atomically $ TMQueue.closeTMQueue queue\n      Async.wait consumerThread\n\n    closeRequest :: WS.ConnectionException -> IO ()\n    closeRequest (WS.CloseRequest _ _) = return ()\n    closeRequest e = throwIO e\n\ndata Log = Log\n  { line :: Text,\n    time :: UTCTime\n  }\n  deriving (Generic, Show, Aeson.ToJSON, Aeson.FromJSON)\n"