b'import Data.Array (bounds, listArray)\nimport Data.Maybe (fromJust)\nimport Test.Tasty\nimport Test.Tasty.HUnit\nimport Test.Tasty.QuickCheck\nimport qualified Data.Foldable as F\nimport qualified Data.Graph as G\nimport qualified Data.List as L\nimport qualified Data.Set as S\n\ndefault (Int)\n\nmain :: IO ()\nmain = defaultMain $ testGroup "graph-properties"\n  [ testCase "buildG" test_buildG\n  , testCase "graphFromEdges" test_graphFromEdges\n  , testCase "dfs" test_dfs\n  , testCase "dff" test_dff\n\n  , testProperty "prop_dfs" prop_dfs\n  , testProperty "prop_dff" prop_dff\n  , testProperty "prop_topSort" prop_topSort\n  , testProperty "prop_scc" prop_scc\n  , testProperty "prop_bcc" prop_bcc\n  , testProperty "prop_stronglyConnCompR" prop_stronglyConnCompR\n  ]\n\n----------------------------------------------------------------\n-- Arbitrary graphs\n----------------------------------------------------------------\n\nnewtype Graph = Graph G.Graph deriving Show\n\ninstance Arbitrary Graph where\n  arbitrary = sized $ \\sz0 -> do\n    sz <- choose (0, sz0)\n    l <- arbitrary\n    let u = l + sz - 1\n    edges <- if sz == 0\n             then pure []\n             else listOf $ (,) <$> choose (l,u) <*> choose (l,u)\n    pure $ Graph $ G.buildG (l,u) edges\n\n-- Directed acyclic graph\nnewtype DAG = DAG G.Graph deriving Show\n\ninstance Arbitrary DAG where\n  arbitrary = sized $ \\sz0 -> do\n    sz <- choose (0, sz0)\n    l <- arbitrary\n    let u = l + sz - 1\n    vs <- shuffle [l..u]\n    -- edges are directed in the order in which their vertices appear in vs\n    edges <- if sz <= 1\n             then pure []\n             else listOf $ ((,) <$> choose (l,u) <*> choose (l,u)) `suchThat`\n                           \\(from, to) -> fromJust (L.elemIndex from vs) < fromJust (L.elemIndex to vs)\n    pure $ DAG $ G.buildG (l,u) edges\n\n-- A graph where for every edge (u,v), the reverse edge (v,u) exists\nnewtype UndirectedG = UndirectedG G.Graph deriving Show\n\ninstance Arbitrary UndirectedG where\n  arbitrary = do\n    Graph g <- arbitrary\n    let edges = G.edges g\n    pure $ UndirectedG $ G.buildG (bounds g) (edges ++ [(v,u) | (u,v) <- edges])\n\nnewtype AdjList node key = AdjList [(node, key, [key])] deriving Show\n\ninstance (Arbitrary node, Arbitrary key, Eq key) => Arbitrary (AdjList node key) where\n  arbitrary = do\n    keys <- L.nub <$> arbitrary\n    keyss <- vectorOf (length keys) arbitrary\n    nodes <- vectorOf (length keys) arbitrary\n    pure $ AdjList $ zip3 nodes keys keyss\n\n----------------------------------------------------------------\n-- Unit tests\n----------------------------------------------------------------\n\ntest_buildG :: Assertion\ntest_buildG = do\n  G.buildG (1,0) [] @?= listArray (1,0) []\n  G.buildG (1,1) [(1,1), (1,1), (1,1)] @?= listArray (1,1) [[1, 1, 1]]\n  G.buildG (1,3) [(1,2), (1,3), (2,3)] @?= listArray (1,3) [[3, 2], [3], []]\n  G.buildG (1,3) [(1,2), (1,3), (2,1), (2,3), (3,1), (3,2)] @?= listArray (1, 3) [[3, 2], [3, 1], [2, 1]]\n\ntest_graphFromEdges :: Assertion\ntest_graphFromEdges = do\n  let (graph1, _, _) = G.graphFromEdges ([] :: [(Int, Int, [Int])])\n  graph1 @?= listArray (0,-1) []\n\n  let (graph2, nodeFromVertex2, vertexFromKey2) = G.graphFromEdges [(\'a\', 10, [10])]\n  graph2 @?= listArray (0,0) [[0]]\n  nodeFromVertex2 0 @?= (\'a\', 10, [10])\n  vertexFromKey2 10 @?= Just 0\n\n  let (graph3, nodeFromVertex3, vertexFromKey3) = G.graphFromEdges [(\'b\', 20, [30, 40]), (\'a\', 10, [20, 30, 40]), (\'d\', 40, []), (\'c\', 30, [40])]\n  graph3 @?= listArray (0,3) [[1, 2, 3], [2, 3], [3], []]\n  map nodeFromVertex3 [0..3] @?= [(\'a\', 10, [20, 30, 40]), (\'b\', 20, [30, 40]), (\'c\', 30, [40]), (\'d\', 40, [])]\n  map vertexFromKey3 [10, 20, 30, 40] @?= map Just [0..3]\n\ntest_dfs :: Assertion\ntest_dfs = do\n  G.dfs (G.buildG (1,0) []) [] @?= []\n  G.dfs (G.buildG (1,1) [(1,1), (1,1), (1,1)]) [1] @?= [G.Node 1 []]\n  G.dfs (G.buildG (1,3) [(1,2), (1,3), (2,3)]) [1] @?= [G.Node 1 [G.Node 3 [], G.Node 2 []]]\n  G.dfs (G.buildG (1,3) [(1,2), (1,3), (2,3)]) [2] @?= [G.Node 2 [G.Node 3 []]]\n  G.dfs (G.buildG (1,3) [(1,2), (1,3), (2,3)]) [3] @?= [G.Node 3 []]\n  G.dfs (G.buildG (1,3) [(1,2), (1,3), (2,3)]) [3,2,1] @?= [G.Node 3 [], G.Node 2 [], G.Node 1 []]\n\ntest_dff :: Assertion\ntest_dff = do\n  G.dff (G.buildG (1,0) []) @?= []\n  G.dff (G.buildG (1,1) [(1,1), (1,1), (1,1)]) @?= [G.Node 1 []]\n  G.dff (G.buildG (1,3) [(1,2), (1,3), (2,3)]) @?= [G.Node 1 [G.Node 3 [], G.Node 2 []]]\n  G.dff (G.buildG (1,3) [(1,2), (1,3), (2,1), (2,3), (3,1), (3,2)]) @?= [G.Node 1 [G.Node 3 [G.Node 2 []]]]\n\n----------------------------------------------------------------\n-- QuickCheck\n----------------------------------------------------------------\n\n-- Note: This tests some simple properties but not complete correctness\nprop_dfs :: Graph -> Property\nprop_dfs (Graph g) =\n  let vsgen = if null (G.vertices g) then pure [] else listOf $ choose (bounds g)\n  in forAll vsgen $ \\vs ->\n    let ts = G.dfs g vs\n    in S.fromList (concatMap F.toList ts) `S.isSubsetOf` S.fromList (G.vertices g) .&&.\n       S.fromList (concatMap treeEdges ts) `S.isSubsetOf` S.fromList (G.edges g)\n\n-- Note: This tests some simple properties but not complete correctness\nprop_dff :: Graph -> Property\nprop_dff (Graph g) =\n  let ts = G.dff g\n  in L.sort (concatMap F.toList ts) === G.vertices g .&&.\n     S.fromList (concatMap treeEdges ts) `S.isSubsetOf` S.fromList (G.edges g)\n\nprop_topSort :: DAG -> Property\nprop_topSort (DAG g) =\n  let vs = G.topSort g\n  in L.sort vs === G.vertices g .&&.\n     and [not (G.path g v u) | u:vs\' <- L.tails vs, v <- vs\']\n\nprop_scc :: Graph -> Property\nprop_scc (Graph g) =\n  let ts = G.scc g\n  in L.sort (concatMap F.toList ts) === G.vertices g .&&.\n     S.fromList (concatMap treeEdges ts) `S.isSubsetOf` S.fromList (G.edges g) .&&.\n     -- vertices in a component are mutually reachable\n     and [G.path g u v | t <- ts, u <- F.toList t, v <- F.toList t] .&&.\n     -- vertices in later components are not reachable from earlier components, due to reverse\n     -- topological order\n     and [not (G.path g u v) | t:ts\' <- L.tails ts, u <- F.toList t, v <- concatMap F.toList ts\']\n\nprop_bcc :: UndirectedG -> Property\nprop_bcc (UndirectedG g) =\n  let ts = G.bcc g\n      comps = concatMap F.toList ts :: [[G.Vertex]]\n  in S.fromList (concat comps) `S.isSubsetOf` S.fromList (G.vertices g) .&&.\n     all testBCC comps .&&.\n     all (uncurry testBCCs) (concatMap treeEdges ts)\n  where\n    -- a biconnected component remains connected even if any single vertex is removed\n    testBCC c = and [subsetComponents (L.delete x c) == 1 | x <- c]\n    -- adjacent biconnected components are connected, but become disconnected if their common\n    -- vertex is removed\n    testBCCs c1 c2 = case c1 `L.intersect` c2 of\n      [x] -> subsetComponents (c1 ++ c2) == 1 &&\n             subsetComponents ((c1 ++ c2) L.\\\\ [x, x]) == 2\n      _   -> False\n    -- the number of components in the given subset of vertices\n    subsetComponents xs =\n      let g\' = G.buildG (bounds g) [(u,v) | (u,v) <- G.edges g, u `elem` xs && v `elem` xs]\n      in length (G.dfs g\' xs)\n\nprop_stronglyConnCompR :: AdjList Int Int -> Property\nprop_stronglyConnCompR (AdjList adj) =\n  let comps = G.stronglyConnCompR adj\n  in L.sort (G.flattenSCCs comps) === L.sort adj .&&.\n     all testSCC comps .&&.\n     -- vertices in later components are not reachable from earlier components, due to reverse\n     -- topological order\n     and [ not (G.path g (getv k) (getv k\'))\n         | c:cs <- L.tails comps\n         , (_,k,_) <- G.flattenSCC c\n         , (_,k\',_) <- G.flattenSCCs cs\n         ]\n  where\n    (g, _, vertexFromKey) = G.graphFromEdges adj\n    getv = fromJust . vertexFromKey\n    -- vertices in a cyclic component are mutually reachable\n    testSCC (G.AcyclicSCC (_, k, ks)) = k `notElem` ks\n    testSCC (G.CyclicSCC [(_, k, ks)]) = k `elem` ks\n    testSCC (G.CyclicSCC xs) = and [G.path g (getv k) (getv k\') | (_,k,_) <- xs , (_,k\',_) <- xs]\n\ntreeEdges :: G.Tree a -> [(a, a)]\ntreeEdges t = go t []\n  where go (G.Node x ts) acc = [(x,y) | G.Node y _ <- ts] ++ foldr go acc ts\n'