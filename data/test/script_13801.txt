b'{-# LANGUAGE OverloadedStrings #-}\n\n-- | Page tree node\n\nmodule Pdf.Document.PageNode\n(\n  PageNode,\n  PageTree(..),\n  pageNodeNKids,\n  pageNodeParent,\n  pageNodeKids,\n  loadPageNode,\n  pageNodePageByNum,\n)\nwhere\n\nimport Pdf.Core\nimport Pdf.Core.Exception\nimport Pdf.Core.Util\nimport Pdf.Core.Object.Util\n\nimport Pdf.Document.Pdf\nimport Pdf.Document.Internal.Types\nimport Pdf.Document.Internal.Util\n\nimport qualified Data.Vector as Vector\nimport qualified Data.HashMap.Strict as HashMap\nimport Control.Monad\nimport Control.Exception hiding (throw)\n\n-- | Total number of child leaf nodes, including deep children\npageNodeNKids :: PageNode -> IO Int\npageNodeNKids (PageNode _ _ dict) = sure $\n  (HashMap.lookup "Count" dict >>= intValue)\n  `notice` "Count should be an integer"\n\n-- | Parent page node\npageNodeParent :: PageNode -> IO (Maybe PageNode)\npageNodeParent (PageNode pdf _ dict) =\n  case HashMap.lookup "Parent" dict of\n    Nothing -> return Nothing\n    Just o@(Ref ref) -> do\n      obj <- deref pdf o\n      node <- sure $ dictValue obj `notice` "Parent should be a dictionary"\n      ensureType "Pages" node\n      return $ Just (PageNode pdf ref node)\n    _ -> throwIO (Corrupted "Parent should be an indirect ref" [])\n\n-- | Referencies to all kids\npageNodeKids :: PageNode -> IO [Ref]\npageNodeKids (PageNode pdf _ dict) = do\n  obj <- sure (HashMap.lookup "Kids" dict\n                `notice` "Page node should have Kids")\n        >>= deref pdf\n  kids <- sure $ arrayValue obj\n    `notice` "Kids should be an array"\n  forM (Vector.toList kids) $ \\k -> sure $\n    refValue k `notice` "each kid should be a reference"\n\n-- | Load page tree node by reference\nloadPageNode :: Pdf -> Ref -> IO PageTree\nloadPageNode pdf ref = do\n  obj <- lookupObject pdf ref >>= deref pdf\n  node <- sure $ dictValue obj `notice` "page should be a dictionary"\n  nodeType <- sure $ dictionaryType node\n  case nodeType of\n    "Pages" -> return $ PageTreeNode (PageNode pdf ref node)\n    "Page" -> return $ PageTreeLeaf (Page pdf ref node)\n    _ -> throwIO $ Corrupted ("Unexpected page tree node type: "\n                              ++ show nodeType) []\n\n-- | Find page by it\'s number\n--\n-- Note: it is not efficient for PDF files with a lot of pages,\n-- because it performs traversal through the page tree each time.\n-- Use \'pageNodeNKids\', \'pageNodeKids\' and \'loadPageNode\' for\n-- efficient traversal.\npageNodePageByNum :: PageNode -> Int -> IO Page\npageNodePageByNum node@(PageNode pdf nodeRef _) num =\n  message ("page #" ++ show num ++ " for node: " ++ show nodeRef) $ do\n  pageNodeKids node >>= loop num\n  where\n  loop _ [] = throwIO $ Corrupted "Page not found" []\n  loop i (x:xs) = do\n    kid <- loadPageNode pdf x\n    case kid  of\n      PageTreeNode n -> do\n        nkids <- pageNodeNKids n\n        if i < nkids\n          then pageNodePageByNum n i\n          else loop (i - nkids) xs\n      PageTreeLeaf page ->\n        if i == 0\n          then return page\n          else loop (i - 1) xs\n'