b"{-# LANGUAGE\n    CPP\n  , FlexibleContexts\n  , GADTs\n  , NoImplicitPrelude\n  #-}\n#if MIN_VERSION_base(4,9,0)\n{-# OPTIONS_GHC -Wno-redundant-constraints #-}\n#endif\n-- | Error types that can be returned by handlers, as well as some\n-- utilities for manipulating these errors.\nmodule Rest.Error\n  ( module Rest.Types.Error\n  , mapE\n  , orThrow\n  , orThrowWith\n  , eitherToStatus\n  , domainReason\n  , (>|<)\n  ) where\n\nimport Prelude.Compat\n\nimport Control.Monad.Except\n\nimport Rest.Types.Error\n\n-- Error utilities.\n\ninfixl 8 `mapE`\n\nmapE :: (Applicative m, Monad m) => (e -> e') -> ExceptT e m a -> ExceptT e' m a\nmapE f = mapExceptT (either (Left . f) Right <$>)\n\norThrow :: MonadError e m => m (Maybe b) -> e -> m b\norThrow a e = a >>= throwError e `maybe` return\n\norThrowWith :: MonadError a m => m (Either e b) -> (e -> a) -> m b\norThrowWith a f = a >>= (throwError . f) `either` return\n\neitherToStatus :: Either a b -> Status a b\neitherToStatus (Left  e) = Failure e\neitherToStatus (Right e) = Success e\n\n-- | Wrap your custom error type in a 'Reason'.\n\ndomainReason :: a -> Reason a\ndomainReason = CustomReason . DomainReason\n\ninfixl 3 >|<\n-- | Try two ExceptT computations left to right yielding the last error if both fail.\n-- This prevents the need for a Semigroup or Monoid instance for the error type, which is necessary if using (<!>) or (<|>) respectively.\n(>|<) :: (Monad m) => ExceptT f m a -> ExceptT e m a -> ExceptT e m a\nExceptT m >|< ExceptT n = ExceptT $ m >>= either (const n) (return . Right)\n"