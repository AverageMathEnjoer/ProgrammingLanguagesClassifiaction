b'module Cachix.Deploy.ActivateCommand where\n\nimport qualified Cachix.API.Deploy.V1 as API.V1\nimport qualified Cachix.API.Deploy.V2 as API.V2\nimport Cachix.API.Error (escalate)\nimport qualified Cachix.API.WebSocketSubprotocol as WSS\nimport qualified Cachix.Client.Config as Config\nimport qualified Cachix.Client.Env as Env\nimport qualified Cachix.Client.Retry as Retry\nimport Cachix.Client.Servant (deployClientV1, deployClientV2)\nimport qualified Cachix.Client.URI as URI\nimport Cachix.Client.Version (versionNumber)\nimport qualified Cachix.Deploy.OptionsParser as DeployOptions\nimport qualified Cachix.Deploy.Websocket as WebSocket\nimport Cachix.Types.Deploy (Deploy)\nimport qualified Cachix.Types.Deploy as Types\nimport qualified Cachix.Types.DeployResponse as DeployResponse\nimport qualified Cachix.Types.Deployment as Deployment\nimport qualified Control.Concurrent.Async as Async\nimport qualified Data.Aeson as Aeson\nimport Data.HashMap.Strict (filterWithKey)\nimport qualified Data.HashMap.Strict as HM\nimport qualified Data.Text as Text\nimport qualified Data.Text.IO as Text\nimport Data.UUID (UUID)\nimport qualified Data.UUID as UUID\nimport qualified Network.WebSockets as WS\nimport Protolude hiding (toS)\nimport Protolude.Conv\nimport Servant.Auth.Client (Token (..))\nimport Servant.Client.Streaming (ClientEnv, runClientM)\nimport Servant.Conduit ()\nimport System.Environment (getEnv)\nimport qualified Text.Megaparsec as Parse\nimport qualified Text.Megaparsec.Char as Parse\n\nrun :: Env.Env -> DeployOptions.ActivateOptions -> IO ()\nrun env DeployOptions.ActivateOptions {DeployOptions.payloadPath, DeployOptions.agents, DeployOptions.deployAsync} = do\n  -- TODO: improve the error message here\n  agentToken <- toS <$> getEnv "CACHIX_ACTIVATE_TOKEN"\n  Aeson.eitherDecodeFileStrict\' payloadPath >>= \\case\n    Left err -> do\n      hPutStrLn stderr $ "Error parsing the deployment spec: " <> err\n      exitFailure\n    Right deploySpec -> do\n      activate env deployAsync agentToken (filterAgents agents deploySpec)\n  where\n    filterAgents [] deploySpec = deploySpec\n    filterAgents chosenAgents deploySpec =\n      deploySpec\n        { Types.agents = filterWithKey (\\k _ -> k `elem` chosenAgents) (Types.agents deploySpec)\n        }\n\n-- TODO: use prettyprinter\nactivate :: Env.Env -> Bool -> ByteString -> Deploy -> IO ()\nactivate Env.Env {cachixoptions, clientenv} deployAsync agentToken payload = do\n  deployResponse <-\n    escalate <=< (`runClientM` clientenv) $\n      API.V2.activate deployClientV2 (Token agentToken) payload\n\n  let agents = HM.toList (DeployResponse.agents deployResponse)\n\n  Text.putStr (renderOverview agents)\n\n  -- Skip streaming the logs when run with the --async flag\n  when deployAsync exitSuccess\n\n  Text.putStr "\\n\\n"\n  deployments <- Async.mapConcurrently watchDeployments agents\n\n  Text.putStr "\\n"\n  Text.putStr (renderSummary deployments)\n\n  if all isSuccessfulDeployment deployments\n    then exitSuccess\n    else exitFailure\n  where\n    isSuccessfulDeployment = (==) Deployment.Succeeded . Deployment.status . snd\n\n    watchDeployments (agentName, details) = do\n      let deploymentID = DeployResponse.id details\n          host = Config.host cachixoptions\n          hostname = URI.getHostname host\n          port = fromMaybe (URI.Port 80) (URI.getPortFor (URI.getScheme host))\n          path = "/api/v1/deploy/log/" <> UUID.toText deploymentID <> "?view=true"\n          useSSL = URI.requiresSSL (URI.getScheme host)\n          headers = [("Authorization", "Bearer " <> agentToken)]\n          identifier = unwords ["cachix", versionNumber]\n          options =\n            WebSocket.Options\n              { WebSocket.host = hostname,\n                WebSocket.port = port,\n                WebSocket.path = path,\n                WebSocket.useSSL = useSSL,\n                WebSocket.headers = headers,\n                WebSocket.identifier = identifier\n              }\n\n      deployment <- Async.withAsync (printLogsToTerminal options agentName) $ \\logThread -> do\n        deployment <- pollDeploymentStatus clientenv (Token agentToken) deploymentID\n\n        -- Wait for all the logs to arrive\n        let status = Deployment.status deployment\n        when (status == Deployment.Failed || status == Deployment.Succeeded) $\n          void (Async.waitCatch logThread)\n\n        pure deployment\n\n      pure (agentName, deployment)\n\npollDeploymentStatus :: ClientEnv -> Token -> UUID -> IO Deployment.Deployment\npollDeploymentStatus clientEnv token deploymentID = loop\n  where\n    loop = do\n      deployment <-\n        Retry.retryAll . const $\n          escalate <=< (`runClientM` clientEnv) $\n            API.V1.getDeployment deployClientV1 token deploymentID\n\n      case Deployment.status deployment of\n        Deployment.Cancelled -> pure deployment\n        Deployment.Failed -> pure deployment\n        Deployment.Succeeded -> pure deployment\n        _ -> do\n          threadDelay (2 * 1000 * 1000)\n          loop\n\nprintLogsToTerminal :: WebSocket.Options -> Text -> IO ()\nprintLogsToTerminal options agentName =\n  WebSocket.runClientWith options WS.defaultConnectionOptions $ \\connection ->\n    fix $ \\loop -> do\n      message <- WS.receiveData connection\n      case Aeson.eitherDecodeStrict\' message of\n        Left error -> do\n          Text.putStrLn $ "Error parsing the log message: " <> show error\n          loop\n        Right msg -> do\n          putStrLn $ unwords [inBrackets agentName, WSS.line msg]\n          unless (isDeploymentDone (WSS.line msg)) loop\n  where\n    -- Parse each log line looking for the success/failure messages.\n    -- TODO: figure out a way to avoid this. How can we tell when the log is done?\n    isDeploymentDone :: Text -> Bool\n    isDeploymentDone = isRight . Parse.parse logEndMessageParser ""\n\n    logEndMessageParser :: Parse.Parsec Void Text Text\n    logEndMessageParser =\n      Parse.string "Successfully activated the deployment"\n        <|> Parse.string "Failed to activate the deployment"\n\nrenderOverview :: [(Text, DeployResponse.Details)] -> Text\nrenderOverview agents =\n  Text.intercalate "\\n" $\n    "Deploying agents:"\n      : [ inBrackets agentName <> " " <> DeployResponse.url details\n          | (agentName, details) <- agents\n        ]\n\nrenderSummary :: [(Text, Deployment.Deployment)] -> Text\nrenderSummary results =\n  Text.intercalate "\\n" $\n    "Deployment summary:"\n      : [ inBrackets agentName <> " " <> renderStatus (Deployment.status deployment)\n          | (agentName, deployment) <- results\n        ]\n  where\n    renderStatus = \\case\n      Deployment.Succeeded -> "Deployed successfully"\n      Deployment.Failed -> "Failed to deploy"\n      Deployment.Cancelled -> "Deployment cancelled"\n      Deployment.InProgress -> "Still deploying"\n      Deployment.Pending -> "Deployment not started"\n\ninBrackets :: (Semigroup a, IsString a) => a -> a\ninBrackets s = "[" <> s <> "]"\n'