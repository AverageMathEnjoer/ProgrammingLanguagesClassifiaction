b'{-# LANGUAGE GADTs #-}\n{-# LANGUAGE KindSignatures #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n{-# LANGUAGE NoMonomorphismRestriction #-}\n\n-- | describe world object\nmodule Sample where\n\nimport Control.Applicative\nimport Control.Category\nimport Control.Lens\nimport Control.Monad.Reader\nimport Control.Monad.State\n--\nimport Control.Monad.Trans.Crtn\nimport Control.Monad.Trans.Crtn.Logger\nimport Control.Monad.Trans.Crtn.Object\nimport Control.Monad.Trans.Crtn.Queue\nimport Control.Monad.Trans.Crtn.World\nimport Control.Monad.Trans.Except\n--\nimport Event\nimport SampleActor\n--\nimport Prelude hiding (id, (.))\n\n-- |\nworld :: forall m. (MonadIO m, MonadFail m) => SObjT (WorldOp Event m) m ()\nworld = ReaderT staction\n  where\n    staction req = do\n      runStateT (go req) initWorld\n      return ()\n    go ::\n      (MonadIO m, MonadFail m) =>\n      Arg (WorldOp Event m) ->\n      StateT (WorldAttrib (SObjBT (WorldOp Event m) m)) (SObjBT (WorldOp Event m) m) ()\n    go (Arg GiveEvent ev) = do\n      dobj <- gets (^. worldActor . objDoor)\n      mobj <- gets (^. worldActor . objMessageBoard)\n      aobj <- gets (^. worldActor . objAir)\n      Right (dobj\', mobj\', aobj\') <-\n        runExceptT $ do\n          d1 <- fst <$> ExceptT (dobj <==| giveEventSub ev)\n          m1 <- fst <$> ExceptT (mobj <==| giveEventSub ev)\n          a1 <- fst <$> ExceptT (aobj <==| giveEventSub ev)\n          return (d1, m1, a1)\n      modify\n        ( (worldActor . objDoor .~ dobj\')\n            . (worldActor . objMessageBoard .~ mobj\')\n            . (worldActor . objAir .~ aobj\')\n        )\n      req <- lift (request (Res GiveEvent ()))\n      go req\n    go (Arg FlushLog (logobj :: LogServer m ())) = do\n      logf <- gets (^. worldState . tempLog)\n      let msg = logf ""\n      if (not . null) msg\n        then do\n          Right (logobj\', _) <- (lift . lift) (logobj <==| writeLog ("[World] " ++ logf ""))\n          modify (worldState . tempLog .~ id)\n          req <- lift (request (Res FlushLog logobj\'))\n          go req\n        else do\n          req <- lift (request Ign)\n          go req\n    go (Arg FlushQueue ()) = do\n      q <- gets (^. worldState . tempQueue)\n      let lst = fqueue q ++ reverse (bqueue q)\n      modify (worldState . tempQueue .~ emptyQueue)\n      req <- lift (request (Res FlushQueue lst))\n      go req\n'