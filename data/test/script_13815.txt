b'#include <string.h>\n#include <math.h>\n#define PVRTEXLIB_IMPORT\n#include <PVRTexLib.hpp>\n#include "ETexFmts.h"\n\nconst PVRTuint64 pvr_ARGB8 = PVRTGENPIXELID4(\'r\', \'g\', \'b\', \'a\', 8, 8, 8, 8);\nconst PVRTuint64 pvr_RGB8 = PVRTGENPIXELID4(\'r\', \'g\', \'b\', 0, 8, 8, 8, 0);\nsize_t Compress(uint32_t texFmt, unsigned int height, unsigned int width, unsigned int mipCount, void *pInBuf, size_t inBufLen, void *pOutBuf, size_t outBufLen, int compressQuality);\nunsigned int GetMaxCompressedSize(int width, int height, uint32_t texFmt);\nsize_t Decompress(uint32_t texFmt, unsigned int height, unsigned int width, unsigned int mipCount, void *pInBuf, size_t inBufLen, void *pOutBuf, size_t outBufLen);\n\nsize_t Compress(uint32_t texFmt, unsigned int height, unsigned int width, unsigned int mipCount, void *pInBuf, size_t inBufLen, void *pOutBuf, size_t outBufLen, int compressQuality)\n{\n\tif ((texFmt >= TexFmt_MAX) || (inBufLen < (width * height * 4)) || (outBufLen < GetMaxCompressedSize(width, height, texFmt)))\n\t\treturn 0;\n\tpvrtexlib::PVRTextureHeader header(pvr_ARGB8, width, height, 1, mipCount, 1, 1, PVRTLCS_Linear);\n\n\tpvrtexlib::PVRTexture tex(header, pInBuf);\n\tif (!tex.Transcode(PixelTypeByTextureFormat[texFmt], VariableTypeByTextureFormat[texFmt], PVRTLCS_Linear, (PVRTexLibCompressorQuality)compressQuality))\n\t\treturn 0;\n\tmemcpy(pOutBuf, tex.GetTextureDataPointer(), (outBufLen < tex.GetTextureDataSize()) ? outBufLen : tex.GetTextureDataSize());\n\treturn tex.GetTextureDataSize();\n}\nunsigned int GetMaxCompressedSize(int width, int height, uint32_t texFmt)\n{\n\tif (texFmt >= TexFmt_MAX)\n\t\treturn 0;\n\tswitch (texFmt)\n\t{\n\tcase TexFmt_EAC_R:\n\tcase TexFmt_EAC_RG:\n\tcase TexFmt_EAC_R_SIGNED:\n\tcase TexFmt_EAC_RG_SIGNED:\n\tcase TexFmt_ETC_RGB4:\n\tcase TexFmt_ETC_RGB4_3DS:\n\tcase TexFmt_ETC_RGBA8_3DS:\n\tcase TexFmt_ETC2_RGB4:\n\tcase TexFmt_ETC2_RGBA1:\n\tcase TexFmt_ETC2_RGBA8:\n\t\t//the compressions are limited to block sizes\n\t\twidth = width + ((width & 3) ? 1 : 0);\n\t\theight = height + ((height & 3) ? 1 : 0);\n\t\tbreak;\n\tcase TexFmt_ASTC_RGB_4x4:\n\tcase TexFmt_ASTC_RGBA_4x4:\n\t\treturn (unsigned int)(ceil((double)width / 4.0F) * ceil((double)height / 4.0F)) * 16;\n\tcase TexFmt_ASTC_RGB_5x5:\n\tcase TexFmt_ASTC_RGBA_5x5:\n\t\treturn (unsigned int)(ceil((double)width / 5.0F) * ceil((double)height / 5.0F)) * 16;\n\tcase TexFmt_ASTC_RGB_6x6:\n\tcase TexFmt_ASTC_RGBA_6x6:\n\t\treturn (unsigned int)(ceil((double)width / 6.0F) * ceil((double)height / 6.0F)) * 16;\n\tcase TexFmt_ASTC_RGB_8x8:\n\tcase TexFmt_ASTC_RGBA_8x8:\n\t\treturn (unsigned int)(ceil((double)width / 8.0F) * ceil((double)height / 8.0F)) * 16;\n\tcase TexFmt_ASTC_RGB_10x10:\n\tcase TexFmt_ASTC_RGBA_10x10:\n\t\treturn (unsigned int)(ceil((double)width / 10.0F) * ceil((double)height / 10.0F)) * 16;\n\tcase TexFmt_ASTC_RGB_12x12:\n\tcase TexFmt_ASTC_RGBA_12x12:\n\t\treturn (unsigned int)(ceil((double)width / 12.0F) * ceil((double)height / 12.0F)) * 16;\n\t}\n\tpvrtexlib::PVRTextureHeader header(PixelTypeByTextureFormat[texFmt], width, height, 1, 1, 1, 1, PVRTLCS_Linear);\n\treturn header.GetTextureDataSize();\n}\nsize_t Decompress(uint32_t texFmt, unsigned int height, unsigned int width, unsigned int mipCount, void *pInBuf, size_t inBufLen, void *pOutBuf, size_t outBufLen)\n{\n\tif (mipCount == (unsigned int)-1)\n\t\tmipCount = 1;\n\tif (texFmt >= TexFmt_MAX)\n\t\treturn 0;\n\tpvrtexlib::PVRTextureHeader header(PixelTypeByTextureFormat[texFmt], width, height, 1, mipCount, 1, 1, PVRTLCS_Linear);\n\tunsigned int bpp = header.GetTextureBitsPerPixel();\n\tif (((bpp * width * height) > (inBufLen * 8)) || (4 * width * height) > outBufLen)\n\t{\n\t\treturn 0;\n\t}\n\telse\n\t{\n\t\tpvrtexlib::PVRTexture tex(header, pInBuf);\n\t\tif (!tex.Transcode(pvr_ARGB8, PVRTLVT_UnsignedByteNorm, PVRTLCS_Linear, PVRTLCQ_PVRTCBest))\n\t\t\treturn 0;\n\n\t\tmemcpy(pOutBuf, tex.GetTextureDataPointer(), width * height * 4);\n\t\treturn width * height * 4;\n\t}\n}\n'