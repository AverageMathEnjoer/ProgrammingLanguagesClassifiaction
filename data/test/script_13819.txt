b'\xef\xbb\xbfusing System;\nusing System.Runtime.InteropServices;\n\nnamespace SweetPotato {\n    internal class SSPIHelper {\n\n        public enum SecBufferType {\n            SECBUFFER_VERSION = 0,\n            SECBUFFER_EMPTY = 0,\n            SECBUFFER_DATA = 1,\n            SECBUFFER_TOKEN = 2\n        }\n\n        [StructLayout(LayoutKind.Sequential)]\n        public struct SecBuffer : IDisposable {\n            private int cbBuffer;\n            private int bufferType;\n            private IntPtr pvBuffer;\n\n            public SecBuffer(int bufferSize) {\n                cbBuffer = bufferSize;\n                bufferType = (int)SecBufferType.SECBUFFER_TOKEN;\n                if (bufferSize > 0) {\n                    pvBuffer = Marshal.AllocHGlobal(bufferSize);\n                } else {\n                    pvBuffer = IntPtr.Zero;\n                }\n            }\n\n            public SecBuffer(byte[] secBufferBytes) {\n                cbBuffer = secBufferBytes.Length;\n                bufferType = (int)SecBufferType.SECBUFFER_TOKEN;\n                pvBuffer = Marshal.AllocHGlobal(cbBuffer);\n                Marshal.Copy(secBufferBytes, 0, pvBuffer, cbBuffer);\n            }\n\n            public SecBuffer(byte[] secBufferBytes, SecBufferType bufferType) {\n                cbBuffer = secBufferBytes.Length;\n                this.bufferType = (int)bufferType;\n                pvBuffer = Marshal.AllocHGlobal(cbBuffer);\n                Marshal.Copy(secBufferBytes, 0, pvBuffer, cbBuffer);\n            }\n\n            public void Dispose() {\n                if (pvBuffer != IntPtr.Zero) {\n                    Marshal.FreeHGlobal(pvBuffer);\n                    pvBuffer = IntPtr.Zero;\n                }\n            }\n\n            public byte[] GetBytes() {\n                byte[] buffer = null;\n                if (cbBuffer > 0) {\n                    buffer = new byte[cbBuffer];\n                    Marshal.Copy(pvBuffer, buffer, 0, cbBuffer);\n                }\n                return buffer;\n            }\n        }\n\n        [StructLayout(LayoutKind.Sequential)]\n        public struct SecBufferDesc : IDisposable {\n            public int ulVersion;\n            public int cBuffers;\n            public IntPtr pBuffers; //Point to SecBuffer\n\n            public SecBufferDesc(int bufferSize) {\n                ulVersion = (int)SecBufferType.SECBUFFER_VERSION;\n                cBuffers = 1;\n                SecBuffer secBuffer = new SecBuffer(bufferSize);\n                pBuffers = Marshal.AllocHGlobal(Marshal.SizeOf(secBuffer));\n                Marshal.StructureToPtr(secBuffer, pBuffers, false);\n\n            }\n\n            public SecBufferDesc(byte[] secBufferBytes) {\n                ulVersion = (int)SecBufferType.SECBUFFER_VERSION;\n                cBuffers = 1;\n                SecBuffer secBuffer = new SecBuffer(secBufferBytes);\n                pBuffers = Marshal.AllocHGlobal(Marshal.SizeOf(secBuffer));\n                Marshal.StructureToPtr(secBuffer, pBuffers, false);\n            }\n\n            public void Dispose() {\n                if (pBuffers != IntPtr.Zero) {\n                    SecBuffer secBuffer = (SecBuffer)Marshal.PtrToStructure(pBuffers, typeof(SecBuffer));\n                    secBuffer.Dispose();\n                    Marshal.FreeHGlobal(pBuffers);\n                    pBuffers = IntPtr.Zero;\n                }\n            }\n\n            public SecBuffer GetSecBuffer() {\n                if (pBuffers == IntPtr.Zero)\n                    throw new ObjectDisposedException("SecBufferDesc");\n                SecBuffer secBuffer = (SecBuffer)Marshal.PtrToStructure(pBuffers, typeof(SecBuffer));\n                return secBuffer;\n            }\n        }\n\n        [StructLayout(LayoutKind.Sequential, Pack = 8)]\n        internal class TimeStamp {\n            public uint LowPart;\n            public int HighPart;\n        };\n\n        [StructLayout(LayoutKind.Sequential, Pack = 8)]\n        internal class CredHandle {\n            IntPtr LowPart;\n            IntPtr HighPart;\n        };\n\n        [StructLayout(LayoutKind.Sequential, Pack = 8)]\n        internal class CtxHandle {\n            IntPtr LowPart;\n            IntPtr HighPart;\n        };\n\n\n        [DllImport("secur32.dll", SetLastError = true)]\n        public static extern int AcquireCredentialsHandle(\n            string pszPrincipal, //SEC_CHAR*\n            string pszPackage, //SEC_CHAR* //"Kerberos","NTLM","Negotiative"\n            int fCredentialUse,\n            IntPtr PAuthenticationID,//_LUID AuthenticationID,//pvLogonID, //PLUID\n            IntPtr pAuthData,//PVOID\n            IntPtr pGetKeyFn, //SEC_GET_KEY_FN\n            IntPtr pvGetKeyArgument, //PVOID\n            CredHandle phCredential, //SecHandle //PCtxtHandle ref\n            TimeStamp ptsExpiry); //PTimeStamp //TimeStamp ref\n\n        [DllImport("secur32.dll", SetLastError = true)]\n        public static extern int AcceptSecurityContext(CredHandle phCredential, CtxHandle phContext,\n                            ref SecBufferDesc pInput,\n                            uint fContextReq,\n                            uint TargetDataRep,\n                            CtxHandle phNewContext,\n                            out SecBufferDesc pOutput,\n                            out uint pfContextAttr,    //managed ulong == 64 bits!!!\n                            TimeStamp ptsTimeStamp);\n\n        [DllImport("secur32.dll", SetLastError = true)]\n        public static extern int QuerySecurityContextToken(CtxHandle phContext, out IntPtr hToken);\n\n        public const int TOKEN_QUERY = 0x00008;\n        public const int SEC_E_OK = 0;\n        public const int SEC_I_CONTINUE_NEEDED = 0x00090312;\n        public const int SECPKG_CRED_OUTBOUND = 2;\n        public const int SECURITY_NATIVE_DREP = 0x10;\n        public const int SECPKG_CRED_INBOUND = 1;\n        public const int MAX_TOKEN_SIZE = 12288;\n    }\n}\n'