b'#include "stdafx.h"\n#include "AssetsFileTable.h"\n#include <stdint.h>\n#include <memory>\n#include <assert.h>\n\nASSETSTOOLS_API AssetsFileTable::AssetsFileTable(AssetsFile *pFile/*, bool readNames*/)\n{\n\tthis->pFile = pFile;\n\tthis->pReader = pFile->pReader; \n\t//this->pLookupBase = NULL;\n\n\t//AssetsFileHeader header;\n\t//reader(0, sizeof(AssetsFileHeader), &header, readerPar);\n\n\tQWORD fileListPos = pFile->AssetTablePos;\n\tunsigned int fileCount = 0;\n\tpReader->Read(fileListPos, 4, &fileCount);\n\tif (pFile->header.endianness)\n\t\tSwapEndians_(fileCount);\n\tfileListPos += 4;\n\tif (pFile->header.format >= 0x0E)\n\t\tfileListPos = ((fileListPos + 3) & (~0x3)); //align to 4-byte boundary\n\n\tthis->assetFileInfoCount = fileCount;\n\n\t//AssetFileInfo *pFileInfo = new AssetFileInfo[fileCount];\n\tAssetFileInfoEx *pFileInfoEx = new AssetFileInfoEx[fileCount];\n\n\tfor (unsigned int i = 0; i < fileCount; i++)\n\t{\n\t\tfileListPos = pFileInfoEx[i].Read(pFile->header.format, fileListPos, pReader, pFile->header.endianness);\n\t\tif (pFile->header.format >= 0x10)\n\t\t{\n\t\t\tif (pFileInfoEx[i].curFileTypeOrIndex >= pFile->typeTree.fieldCount)\n\t\t\t{\n\t\t\t\tpFileInfoEx[i].curFileType = 0x80000000;\n\t\t\t\tpFileInfoEx[i].inheritedUnityClass = 0xFFFF;\n\t\t\t\tpFileInfoEx[i].scriptIndex = 0xFFFF;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tuint32_t classId = pFile->typeTree.pTypes_Unity5[pFileInfoEx[i].curFileTypeOrIndex].classId;\n\t\t\t\tif (pFile->typeTree.pTypes_Unity5[pFileInfoEx[i].curFileTypeOrIndex].scriptIndex != 0xFFFF)\n\t\t\t\t{\n\t\t\t\t\tpFileInfoEx[i].curFileType = (int)(-1 - (int)pFile->typeTree.pTypes_Unity5[pFileInfoEx[i].curFileTypeOrIndex].scriptIndex);\n\t\t\t\t\tpFileInfoEx[i].inheritedUnityClass = (uint16_t)classId;\n\t\t\t\t\tpFileInfoEx[i].scriptIndex = pFile->typeTree.pTypes_Unity5[pFileInfoEx[i].curFileTypeOrIndex].scriptIndex;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tpFileInfoEx[i].curFileType = classId;\n\t\t\t\t\tpFileInfoEx[i].inheritedUnityClass = (uint16_t)classId;\n\t\t\t\t\tpFileInfoEx[i].scriptIndex = 0xFFFF;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\tpFileInfoEx[i].curFileType = pFileInfoEx[i].curFileTypeOrIndex;\n\t\tpFileInfoEx[i].absolutePos = pFile->header.offs_firstFile + pFileInfoEx[i].offs_curFile;\n\t}\n\tthis->pAssetFileInfo = pFileInfoEx;\n}\nASSETSTOOLS_API bool AssetFileInfoEx::ReadName(AssetsFile *pFile, std::string &out, IAssetsReader *pReaderView)\n{\n\tout.clear();\n\tif (HasName(this->curFileType))\n\t{\n\t\tif (!pReaderView)\n\t\t\tpReaderView = pFile->pReader;\n\t\tunsigned int nameSize = 0;\n\t\tif (pReaderView->Read(this->absolutePos, 4, &nameSize) != 4)\n\t\t\treturn false;\n\n\t\tif (pFile->header.endianness != 0) SwapEndians_(nameSize);\n\t\tif (nameSize + 4 >= this->curFileSize || nameSize >= 4092)\n\t\t\treturn false;\n\n\t\tout.resize(nameSize, 0);\n\t\tif (pReaderView->Read(this->absolutePos + 4, nameSize, out.data()) != nameSize)\n\t\t{\n\t\t\tout.clear();\n\t\t\treturn false;\n\t\t}\n\t\tfor (size_t i = 0; i < nameSize; i++)\n\t\t{\n\t\t\tif (out[i] < 0x20)\n\t\t\t{\n\t\t\t\tout.clear();\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\n\nASSETSTOOLS_API AssetFileInfoEx *AssetsFileTable::getAssetInfo(QWORD pathId)\n{\n\tif (!lookup.empty())\n\t{\n\t\tAssetFileInfoEx tmp;\n\t\ttmp.index = pathId;\n\t\tauto it = lookup.find(&tmp);\n\t\tif (it != lookup.end())\n\t\t{\n\t\t\treturn it->pInfo;\n\t\t}\n\t}\n\tfor (unsigned int i = 0; i < assetFileInfoCount; i++)\n\t{\n\t\tif (pAssetFileInfo[i].index == pathId)\n\t\t\treturn &pAssetFileInfo[i];\n\t}\n\treturn NULL;\n}\n\nASSETSTOOLS_API AssetsFile *AssetsFileTable::getAssetsFile()\n{\n\treturn pFile;\n}\nASSETSTOOLS_API IAssetsReader *AssetsFileTable::getReader()\n{\n\treturn pReader;\n}\n\nASSETSTOOLS_API bool AssetsFileTable::GenerateQuickLookupTree()\n{\n\t{\n\t\tstd::set<AssetFileInfoEx_KeyRef> tmp;\n\t\tlookup.swap(tmp);\n\t}\n\tstruct LookupIterator\n\t{\n\t\tAssetFileInfoEx *pFileTable;\n\t\tsize_t fileTableSize;\n\t\tsize_t i;\n\t\tinline LookupIterator()\n\t\t\t: pFileTable(nullptr), fileTableSize(0), i(0)\n\t\t{}\n\t\tinline LookupIterator(AssetFileInfoEx *pFileTable, size_t fileTableSize, size_t i)\n\t\t\t: pFileTable(pFileTable), fileTableSize(fileTableSize), i(i)\n\t\t{}\n\t\tinline LookupIterator(LookupIterator &&other)\n\t\t{\n\t\t\t(*this) = std::move(other);\n\t\t}\n\t\tinline LookupIterator(const LookupIterator &other)\n\t\t{\n\t\t\t(*this) = other;\n\t\t}\n\t\tinline LookupIterator &operator=(const LookupIterator &other)\n\t\t{\n\t\t\tthis->pFileTable = other.pFileTable;\n\t\t\tthis->fileTableSize = other.fileTableSize;\n\t\t\tthis->i = other.i;\n\t\t\treturn (*this);\n\t\t}\n\t\tinline LookupIterator &operator=(LookupIterator &&other)\n\t\t{\n\t\t\tthis->pFileTable = other.pFileTable;\n\t\t\tthis->fileTableSize = other.fileTableSize;\n\t\t\tthis->i = other.i;\n\t\t\tother.i = other.fileTableSize;\n\t\t\treturn (*this);\n\t\t}\n\t\tinline bool operator==(const LookupIterator &other)\n\t\t{\n\t\t\treturn (pFileTable == other.pFileTable && fileTableSize == other.fileTableSize && i == other.i)\n\t\t\t\t|| (i >= fileTableSize && other.i >= other.fileTableSize);\n\t\t}\n\t\tinline bool operator!=(const LookupIterator &other)\n\t\t{\n\t\t\treturn !((*this) == other);\n\t\t}\n\t\tinline LookupIterator &operator++() //pre-increment\n\t\t{\n\t\t\tif (i < fileTableSize) i++;\n\t\t\treturn (*this);\n\t\t}\n\t\tinline LookupIterator operator++(int) //post-increment\n\t\t{\n\t\t\tLookupIterator ret = (*this);\n\t\t\t++(*this);\n\t\t\treturn ret;\n\t\t}\n\t\tAssetFileInfoEx_KeyRef resultTmp;\n\t\tinline AssetFileInfoEx_KeyRef &operator*()\n\t\t{\n\t\t\tassert(i < fileTableSize);\n\t\t\tresultTmp = AssetFileInfoEx_KeyRef(&pFileTable[i]);\n\t\t\treturn resultTmp;\n\t\t}\n\t\tinline AssetFileInfoEx_KeyRef *operator->()\n\t\t{\n\t\t\treturn &(*(*this)); //&this->operator*()\n\t\t}\n\t};\n\tlookup.insert(LookupIterator(pAssetFileInfo, assetFileInfoCount, 0), LookupIterator());\n\treturn true;\n\t//FreeQuickLookupTree<unsigned long long, AssetsFileTable>(pLookupBase);\n\t//pLookupBase = NULL;\n\t//return ::GenerateQuickLookupTree<unsigned long long, AssetsFileTable>(this, pLookupBase);\n}\n\nASSETSTOOLS_API AssetsFileTable::~AssetsFileTable()\n{\n\tif (pAssetFileInfo != NULL)\n\t\tdelete[] pAssetFileInfo;\n\t//FreeQuickLookupTree<unsigned long long, AssetsFileTable>(pLookupBase);\n}\n'