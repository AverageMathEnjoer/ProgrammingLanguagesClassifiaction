b'{-# LANGUAGE BangPatterns #-}\n{-# LANGUAGE DataKinds #-}\n{-# LANGUAGE Rank2Types #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n\nmodule Cachix.Client.Push.S3 where\n\nimport qualified Cachix.API as API\nimport Cachix.API.Error\nimport Cachix.Client.Retry (retryAll)\nimport Cachix.Client.Servant (cachixClient)\nimport Cachix.Types.BinaryCache\nimport qualified Cachix.Types.MultipartUpload as Multipart\nimport Conduit (MonadResource, MonadUnliftIO)\nimport Control.DeepSeq (rwhnf)\nimport Crypto.Hash (Digest, MD5)\nimport qualified Crypto.Hash as Crypto\nimport Data.ByteArray.Encoding (Base (..), convertToBase)\nimport Data.Conduit (ConduitT, handleC, (.|))\nimport Data.Conduit.ByteString (ChunkSize, chunkStream)\nimport qualified Data.Conduit.Combinators as CC\nimport Data.Conduit.ConcurrentMap (concurrentMapM_)\nimport Data.List (lookup)\nimport qualified Data.List.NonEmpty as NonEmpty\nimport Data.UUID (UUID)\nimport Network.HTTP.Client as HTTP\nimport qualified Network.HTTP.Types.Header as HTTP\nimport Protolude\nimport Servant.Auth ()\nimport Servant.Auth.Client\nimport qualified Servant.Client as Client\nimport Servant.Client.Streaming\nimport Servant.Conduit ()\n\n-- | The size of each uploaded part.\n--\n-- Common values for S3 are 8MB and 16MB. The minimum is 5MB.\n--\n-- Lower values will increase HTTP overhead. Some cloud services impose request body limits.\n-- For example, Amazon API Gateway caps out at 10MB.\nchunkSize :: ChunkSize\nchunkSize = 8 * 1024 * 1024\n\n-- | The number of parts to upload concurrently.\n-- Speeds up the upload of very large files.\nconcurrentParts :: Int\nconcurrentParts = 8\n\n-- | The size of the temporary output buffer.\n--\n-- Keep this value high to avoid stalling smaller uploads while waiting for a large upload to complete.\n-- Each completed upload response is very lightweight.\noutputBufferSize :: Int\noutputBufferSize = 100\n\nstreamUpload ::\n  forall m.\n  (MonadUnliftIO m, MonadResource m) =>\n  ClientEnv ->\n  Token ->\n  Text ->\n  CompressionMethod ->\n  ConduitT\n    ByteString\n    Void\n    m\n    (Either SomeException (UUID, Text, Maybe (NonEmpty Multipart.CompletedPart)))\nstreamUpload env authToken cacheName compressionMethod = do\n  Multipart.CreateMultipartUploadResponse {narId, uploadId} <- createMultipartUpload\n\n  handleC (abortMultipartUpload narId uploadId) $\n    chunkStream (Just chunkSize)\n      .| concurrentMapM_ concurrentParts outputBufferSize (uploadPart narId uploadId)\n      .| completeMultipartUpload narId uploadId\n  where\n    manager = Client.manager env\n\n    createMultipartUpload :: ConduitT ByteString Void m Multipart.CreateMultipartUploadResponse\n    createMultipartUpload =\n      liftIO $ withClientM createNarRequest env escalate\n      where\n        createNarRequest = API.createNar cachixClient authToken cacheName (Just compressionMethod)\n\n    uploadPart :: UUID -> Text -> (Int, ByteString) -> m (Maybe Multipart.CompletedPart)\n    uploadPart narId uploadId (partNumber, !part) = do\n      let partHashMD5 :: Digest MD5 = Crypto.hash part\n          contentMD5 :: ByteString = convertToBase Base64 partHashMD5\n\n      let uploadNarPartRequest = API.uploadNarPart cachixClient authToken cacheName narId uploadId partNumber (Multipart.SigningData (decodeUtf8 contentMD5))\n      Multipart.UploadPartResponse {uploadUrl} <- liftIO $ withClientM uploadNarPartRequest env escalate\n\n      initialRequest <- liftIO $ HTTP.parseUrlThrow (toS uploadUrl)\n      let request =\n            initialRequest\n              { HTTP.method = "PUT",\n                HTTP.requestBody = HTTP.RequestBodyBS part,\n                HTTP.requestHeaders =\n                  [ ("Content-Type", "application/octet-stream"),\n                    ("Content-MD5", contentMD5)\n                  ]\n              }\n\n      response <- liftIO $ retryAll $ \\_ -> HTTP.httpNoBody request manager\n      let eTag = decodeUtf8 <$> lookup HTTP.hETag (HTTP.responseHeaders response)\n      -- Strictly evaluate each eTag after uploading each part\n      let !_ = rwhnf eTag\n      return $ Multipart.CompletedPart partNumber <$> eTag\n\n    completeMultipartUpload narId uploadId = do\n      parts <- CC.sinkList\n      return $ Right (narId, uploadId, sequenceA $ NonEmpty.fromList parts)\n\n    abortMultipartUpload narId uploadId err = do\n      let abortMultipartUploadRequest = API.abortMultipartUpload cachixClient authToken cacheName narId uploadId\n      _ <- liftIO $ withClientM abortMultipartUploadRequest env escalate\n      return $ Left err\n'