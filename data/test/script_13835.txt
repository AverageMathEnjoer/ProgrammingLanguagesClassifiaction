b'module Network.Server.Chat.Loop where\n\nimport Prelude hiding (mapM_)\nimport Network(PortID(..), sClose, withSocketsDo, listenOn)\nimport System.IO(BufferMode(..))\nimport Data.IORef(IORef, newIORef, readIORef)\nimport Data.Foldable(Foldable, mapM_)\nimport Control.Applicative(Applicative, pure)\nimport Control.Concurrent(forkIO)\nimport Control.Exception(finally, try, catch, Exception)\nimport Control.Monad(forever)\nimport Control.Monad.Trans(MonadTrans(..), MonadIO(..))\n\nimport Network.Server.Common.Accept\nimport Network.Server.Common.HandleLens\nimport Network.Server.Common.Lens\nimport Network.Server.Common.Line\nimport Network.Server.Common.Env\nimport Network.Server.Common.Ref\nimport Data.Set(Set)\nimport qualified Data.Set as S\n\ndata Loop v f a =\n  Loop (Env v -> f a)\n\ntype IOLoop v a =\n  Loop v IO a\n\ntype IORefLoop v a =\n  IOLoop (IORef v) a\n\ninstance Functor f => Functor (Loop v f) where\n  fmap f (Loop k) =\n    Loop (fmap f . k)\n\ninstance Applicative f => Applicative (Loop v f) where\n  pure =\n    Loop . pure . pure\n  Loop f <*> Loop x =\n    Loop (\\a -> f a <*> x a)\n\ninstance Monad f => Monad (Loop v f) where\n  return =\n    Loop . return . return\n  Loop k >>= f =\n    Loop (\\v -> k v >>= \\a ->\n      let Loop l = f a\n      in l v)\n\ninstance MonadTrans (Loop v) where\n  lift =\n    Loop . const\n\ninstance MonadIO f => MonadIO (Loop v f) where\n  liftIO =\n    lift . liftIO\n\netry ::\n  Exception e =>\n  (Env v -> IO a)\n  -> IOLoop v (Either e a)\netry k =\n  Loop $ try . k\n\nserver ::\n  IO w -- server initialise\n  -> (w -> IO v) -- client accepted (pre)\n  -> IOLoop v () -- per-client\n  -> IO a\nserver i r (Loop f) =\n  let hand s w c = forever $\n                     do q <- accept\' s\n                        lSetBuffering q NoBuffering\n                        _ <- atomicModifyIORef_ c (S.insert (refL `getL` q))\n                        x <- r w\n                        forkIO (f (Env q c x))\n  in withSocketsDo $ do\n       s <- listenOn (PortNumber 6060)\n       w <- i\n       c <- newIORef S.empty\n       hand s w c `finally` sClose s\n\nallClients :: IOLoop v (Set Ref)\nallClients = Loop $ \\env -> readIORef (clientsL `getL` env)\n\nperClient ::\n  IOLoop v x -- client accepted (post)\n  -> (String -> IOLoop v a) -- read line from client\n  -> IOLoop v ()\nperClient =\n  error "todo"\n\nloop ::\n  IO w -- server initialise\n  -> (w -> IO v) -- client accepted (pre)\n  -> IOLoop v x -- client accepted (post)\n  -> (String -> IOLoop v w) -- read line from client\n  -> IO a\nloop i r q f =\n  server i r (perClient q f)\n\niorefServer ::\n  v -- server initialise\n  -> IORefLoop v () -- per-client\n  -> IO a\niorefServer x =\n  server (newIORef x) return\n\niorefLoop ::\n  v -- server initialise\n  -> IORefLoop v x -- client accepted (post)\n  -> (String -> IORefLoop v w) -- read line from client\n  -> IO a\niorefLoop x q f =\n  iorefServer x (perClient q f)\n\npPutStrLn ::\n  String\n  -> IOLoop v ()\npPutStrLn s =\n  Loop (`lPutStrLn` s)\n\n(!) ::\n  Foldable t =>\n  IOLoop v (t Ref)\n  -> String\n  -> IOLoop v ()\nclients ! msg =\n clients >>= purgeClients (\\y -> liftIO (lPutStrLn y msg))\n\ninfixl 2 !\n\npurgeClients ::\n  Foldable t =>\n  (Ref -> IOLoop v ())\n  -> t Ref\n  -> IOLoop v ()\npurgeClients a =\n  mapM_ (\\y ->\n    ecatch (a y)\n      (\\x -> do _ <- modifyClients (S.delete y)\n                xprint x)\n        )\n\nreadEnv ::\n  Applicative f =>\n  Loop v f (Env v)\nreadEnv =\n  Loop $ pure\n\nreadEnvval ::\n  Applicative f =>\n  Loop v f v\nreadEnvval =\n  fmap (envvalL `getL`) readEnv\n\nreadIOEnvval ::\n  IORefLoop a a\nreadIOEnvval =\n  Loop $ \\env ->\n    readIORef (envvalL `getL` env)\n\nallClientsButThis ::\n  IOLoop v (Set Ref)\nallClientsButThis =\n  Loop $ \\env ->\n    fmap (S.delete ((acceptL .@ refL) `getL` env)) (readIORef (clientsL `getL` env))\n\n-- Control.Monad.CatchIO\necatch ::\n  Exception e =>\n  IOLoop v a\n  -> (e -> IOLoop v a)\n  -> IOLoop v a\necatch (Loop k) f =\n  Loop $ \\env -> k env `catch` (\\e -> let Loop l = f e in l env)\n\nmodifyClients ::\n  (Set Ref -> Set Ref)\n  -> IOLoop v (Set Ref)\nmodifyClients f =\n  Loop $ \\env ->\n    atomicModifyIORef_ (clientsL `getL` env) f\n'