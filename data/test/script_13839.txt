b'{-# LANGUAGE\n    NoImplicitPrelude\n  , OverloadedStrings\n  #-}\nmodule Rest.Types.Method (Method (..)) where\n\nimport Prelude.Compat\n\nimport Data.Aeson (ToJSON (..), FromJSON (..))\nimport Data.Aeson.Types (typeMismatch)\nimport Data.Char (toLower)\nimport Data.JSON.Schema (JSONSchema (..))\nimport Text.XML.HXT.Arrow.Pickle\nimport Text.XML.HXT.Arrow.Pickle.Schema\nimport Text.XML.HXT.Arrow.Pickle.Xml\n\nimport qualified Data.Aeson       as Json\nimport qualified Data.JSON.Schema as Schema\nimport qualified Data.Text        as Text\n\ndata Method = GET | PUT | POST | DELETE\n  deriving (Show, Eq, Bounded, Enum)\n\ninstance ToJSON     Method where\n  toJSON = toJSON . methodToString\n\ninstance FromJSON   Method where\n  parseJSON (Json.String s) = case s of\n    "GET"    -> return GET\n    "PUT"    -> return PUT\n    "POST"   -> return POST\n    "DELETE" -> return DELETE\n    m -> fail $ "Unknown string when parsing method: " ++ Text.unpack m\n  parseJSON j = typeMismatch "String" j\n\ninstance JSONSchema Method where\n  schema _ = Schema.Choice [ Schema.Constant (Json.String "GET")\n                           , Schema.Constant (Json.String "PUT")\n                           , Schema.Constant (Json.String "POST")\n                           , Schema.Constant (Json.String "DELETE")\n                           ]\n\ninstance XmlPickler Method where\n  xpickle = PU\n    (\\x -> appPickle (xpElem (methodToStringLC x) (xpickle :: PU ())) ())\n    (choices (map mkUnpickler enumAll))\n    (scAlts (map (\\m -> scElem (methodToStringLC m) scEmpty) enumAll))\n\nmkUnpickler :: Method -> Unpickler Method\nmkUnpickler m = appUnPickle (xpWrap (const m, const ())\n                              (xpElem (methodToStringLC m)\n                                (xpickle :: PU ()))\n                            )\n\n{-# ANN choice ("HLint: ignore Eta reduce"::String) #-}\nchoice :: Unpickler a -> Unpickler a -> Unpickler a\nchoice x y = mchoice x pure y\n\nchoices :: [Unpickler a] -> Unpickler a\nchoices = foldr1 choice\n\nenumAll :: (Bounded a, Enum a) => [a]\nenumAll = [minBound .. maxBound]\n\nmethodToString :: Method -> String\nmethodToString GET    = "GET"\nmethodToString PUT    = "PUT"\nmethodToString POST   = "POST"\nmethodToString DELETE = "DELETE"\n\nmethodToStringLC :: Method -> String\nmethodToStringLC = map toLower . methodToString\n'