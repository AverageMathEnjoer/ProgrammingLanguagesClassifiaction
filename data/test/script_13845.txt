b'\xef\xbb\xbf//\n// Options.cs\n//\n// Authors:\n//  Jonathan Pryor <jpryor@novell.com>, <Jonathan.Pryor@microsoft.com>\n//  Federico Di Gregorio <fog@initd.org>\n//  Rolf Bjarne Kvinge <rolf@xamarin.com>\n//\n// Copyright (C) 2008 Novell (http://www.novell.com)\n// Copyright (C) 2009 Federico Di Gregorio.\n// Copyright (C) 2012 Xamarin Inc (http://www.xamarin.com)\n// Copyright (C) 2017 Microsoft Corporation (http://www.microsoft.com)\n//\n// Permission is hereby granted, free of charge, to any person obtaining\n// a copy of this software and associated documentation files (the\n// "Software"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to\n// permit persons to whom the Software is furnished to do so, subject to\n// the following conditions:\n// \n// The above copyright notice and this permission notice shall be\n// included in all copies or substantial portions of the Software.\n// \n// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,\n// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n//\n\n// Compile With:\n//   mcs -debug+ -r:System.Core Options.cs -o:Mono.Options.dll -t:library\n//   mcs -debug+ -d:LINQ -r:System.Core Options.cs -o:Mono.Options.dll -t:library\n//\n// The LINQ version just changes the implementation of\n// OptionSet.Parse(IEnumerable<string>), and confers no semantic changes.\n\n//\n// A Getopt::Long-inspired option parsing library for C#.\n//\n// Mono.Options.OptionSet is built upon a key/value table, where the\n// key is a option format string and the value is a delegate that is \n// invoked when the format string is matched.\n//\n// Option format strings:\n//  Regex-like BNF Grammar: \n//    name: .+\n//    type: [=:]\n//    sep: ( [^{}]+ | \'{\' .+ \'}\' )?\n//    aliases: ( name type sep ) ( \'|\' name type sep )*\n// \n// Each \'|\'-delimited name is an alias for the associated action.  If the\n// format string ends in a \'=\', it has a required value.  If the format\n// string ends in a \':\', it has an optional value.  If neither \'=\' or \':\'\n// is present, no value is supported.  `=\' or `:\' need only be defined on one\n// alias, but if they are provided on more than one they must be consistent.\n//\n// Each alias portion may also end with a "key/value separator", which is used\n// to split option values if the option accepts > 1 value.  If not specified,\n// it defaults to \'=\' and \':\'.  If specified, it can be any character except\n// \'{\' and \'}\' OR the *string* between \'{\' and \'}\'.  If no separator should be\n// used (i.e. the separate values should be distinct arguments), then "{}"\n// should be used as the separator.\n//\n// Options are extracted either from the current option by looking for\n// the option name followed by an \'=\' or \':\', or is taken from the\n// following option IFF:\n//  - The current option does not contain a \'=\' or a \':\'\n//  - The current option requires a value (i.e. not a Option type of \':\')\n//\n// The `name\' used in the option format string does NOT include any leading\n// option indicator, such as \'-\', \'--\', or \'/\'.  All three of these are\n// permitted/required on any named option.\n//\n// Option bundling is permitted so long as:\n//   - \'-\' is used to start the option group\n//   - all of the bundled options are a single character\n//   - at most one of the bundled options accepts a value, and the value\n//     provided starts from the next character to the end of the string.\n//\n// This allows specifying \'-a -b -c\' as \'-abc\', and specifying \'-D name=value\'\n// as \'-Dname=value\'.\n//\n// Option processing is disabled by specifying "--".  All options after "--"\n// are returned by OptionSet.Parse() unchanged and unprocessed.\n//\n// Unprocessed options are returned from OptionSet.Parse().\n//\n// Examples:\n//  int verbose = 0;\n//  OptionSet p = new OptionSet ()\n//    .Add ("v", v => ++verbose)\n//    .Add ("name=|value=", v => Console.WriteLine (v));\n//  p.Parse (new string[]{"-v", "--v", "/v", "-name=A", "/name", "B", "extra"});\n//\n// The above would parse the argument string array, and would invoke the\n// lambda expression three times, setting `verbose\' to 3 when complete.  \n// It would also print out "A" and "B" to standard output.\n// The returned array would contain the string "extra".\n//\n// C# 3.0 collection initializers are supported and encouraged:\n//  var p = new OptionSet () {\n//    { "h|?|help", v => ShowHelp () },\n//  };\n//\n// System.ComponentModel.TypeConverter is also supported, allowing the use of\n// custom data types in the callback type; TypeConverter.ConvertFromString()\n// is used to convert the value option to an instance of the specified\n// type:\n//\n//  var p = new OptionSet () {\n//    { "foo=", (Foo f) => Console.WriteLine (f.ToString ()) },\n//  };\n//\n// Random other tidbits:\n//  - Boolean options (those w/o \'=\' or \':\' in the option format string)\n//    are explicitly enabled if they are followed with \'+\', and explicitly\n//    disabled if they are followed with \'-\':\n//      string a = null;\n//      var p = new OptionSet () {\n//        { "a", s => a = s },\n//      };\n//      p.Parse (new string[]{"-a"});   // sets v != null\n//      p.Parse (new string[]{"-a+"});  // sets v != null\n//      p.Parse (new string[]{"-a-"});  // sets v == null\n//\n\n//\n// Mono.Options.CommandSet allows easily having separate commands and\n// associated command options, allowing creation of a *suite* along the\n// lines of **git**(1), **svn**(1), etc.\n//\n// CommandSet allows intermixing plain text strings for `--help` output,\n// Option values -- as supported by OptionSet -- and Command instances,\n// which have a name, optional help text, and an optional OptionSet.\n//\n//  var suite = new CommandSet ("suite-name") {\n//    // Use strings and option values, as with OptionSet\n//    "usage: suite-name COMMAND [OPTIONS]+",\n//    { "v:", "verbosity", (int? v) => Verbosity = v.HasValue ? v.Value : Verbosity+1 },\n//    // Commands may also be specified\n//    new Command ("command-name", "command help") {\n//      Options = new OptionSet {/*...*/},\n//      Run     = args => { /*...*/},\n//    },\n//    new MyCommandSubclass (),\n//  };\n//  return suite.Run (new string[]{...});\n//\n// CommandSet provides a `help` command, and forwards `help COMMAND`\n// to the registered Command instance by invoking Command.Invoke()\n// with `--help` as an option.\n//\n\nusing System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing System.Collections.ObjectModel;\nusing System.ComponentModel;\nusing System.Globalization;\nusing System.IO;\n#if PCL\nusing System.Reflection;\n#else\nusing System.Runtime.Serialization;\nusing System.Security.Permissions;\n#endif\nusing System.Text;\nusing System.Text.RegularExpressions;\n\n#if LINQ\nusing System.Linq;\n#endif\n\n#if TEST\nusing NDesk.Options;\n#endif\n\n#if PCL\nusing MessageLocalizerConverter = System.Func<string, string>;\n#else\nusing MessageLocalizerConverter = System.Converter<string, string>;\n#endif\n\n#if NDESK_OPTIONS\nnamespace NDesk.Options\n#else\nnamespace Mono.Options\n#endif\n{\n    static class StringCoda {\n\n        public static IEnumerable<string> WrappedLines(string self, params int[] widths) {\n            IEnumerable<int> w = widths;\n            return WrappedLines(self, w);\n        }\n\n        public static IEnumerable<string> WrappedLines(string self, IEnumerable<int> widths) {\n            if (widths == null)\n                throw new ArgumentNullException("widths");\n            return CreateWrappedLinesIterator(self, widths);\n        }\n\n        private static IEnumerable<string> CreateWrappedLinesIterator(string self, IEnumerable<int> widths) {\n            if (string.IsNullOrEmpty(self)) {\n                yield return string.Empty;\n                yield break;\n            }\n            using (IEnumerator<int> ewidths = widths.GetEnumerator()) {\n                bool? hw = null;\n                int width = GetNextWidth(ewidths, int.MaxValue, ref hw);\n                int start = 0, end;\n                do {\n                    end = GetLineEnd(start, width, self);\n                    // endCorrection is 1 if the line end is \'\\n\', and might be 2 if the line end is \'\\r\\n\'.\n                    int endCorrection = 1;\n                    if (end >= 2 && self.Substring(end - 2, 2).Equals("\\r\\n"))\n                        endCorrection = 2;\n                    char c = self[end - endCorrection];\n                    if (char.IsWhiteSpace(c))\n                        end -= endCorrection;\n                    bool needContinuation = end != self.Length && !IsEolChar(c);\n                    string continuation = "";\n                    if (needContinuation) {\n                        --end;\n                        continuation = "-";\n                    }\n                    string line = self.Substring(start, end - start) + continuation;\n                    yield return line;\n                    start = end;\n                    if (char.IsWhiteSpace(c))\n                        start += endCorrection;\n                    width = GetNextWidth(ewidths, width, ref hw);\n                } while (start < self.Length);\n            }\n        }\n\n        private static int GetNextWidth(IEnumerator<int> ewidths, int curWidth, ref bool? eValid) {\n            if (!eValid.HasValue || (eValid.HasValue && eValid.Value)) {\n                curWidth = (eValid = ewidths.MoveNext()).Value ? ewidths.Current : curWidth;\n                // \'.\' is any character, - is for a continuation\n                const string minWidth = ".-";\n                if (curWidth < minWidth.Length)\n                    throw new ArgumentOutOfRangeException("widths",\n                            string.Format("Element must be >= {0}, was {1}.", minWidth.Length, curWidth));\n                return curWidth;\n            }\n            // no more elements, use the last element.\n            return curWidth;\n        }\n\n        private static bool IsEolChar(char c) {\n            return !char.IsLetterOrDigit(c);\n        }\n\n        private static int GetLineEnd(int start, int length, string description) {\n            int end = System.Math.Min(start + length, description.Length);\n            int sep = -1;\n            for (int i = start; i < end; ++i) {\n                if (i + 2 <= description.Length && description.Substring(i, 2).Equals("\\r\\n"))\n                    return i + 2;\n                if (description[i] == \'\\n\')\n                    return i + 1;\n                if (IsEolChar(description[i]))\n                    sep = i + 1;\n            }\n            if (sep == -1 || end == description.Length)\n                return end;\n            return sep;\n        }\n    }\n\n    public class OptionValueCollection : IList, IList<string> {\n\n        List<string> values = new List<string>();\n        OptionContext c;\n\n        internal OptionValueCollection(OptionContext c) {\n            this.c = c;\n        }\n\n        #region ICollection\n        void ICollection.CopyTo(Array array, int index) { (values as ICollection).CopyTo(array, index); }\n        bool ICollection.IsSynchronized { get { return (values as ICollection).IsSynchronized; } }\n        object ICollection.SyncRoot { get { return (values as ICollection).SyncRoot; } }\n        #endregion\n\n        #region ICollection<T>\n        public void Add(string item) { values.Add(item); }\n        public void Clear() { values.Clear(); }\n        public bool Contains(string item) { return values.Contains(item); }\n        public void CopyTo(string[] array, int arrayIndex) { values.CopyTo(array, arrayIndex); }\n        public bool Remove(string item) { return values.Remove(item); }\n        public int Count { get { return values.Count; } }\n        public bool IsReadOnly { get { return false; } }\n        #endregion\n\n        #region IEnumerable\n        IEnumerator IEnumerable.GetEnumerator() { return values.GetEnumerator(); }\n        #endregion\n\n        #region IEnumerable<T>\n        public IEnumerator<string> GetEnumerator() { return values.GetEnumerator(); }\n        #endregion\n\n        #region IList\n        int IList.Add(object value) { return (values as IList).Add(value); }\n        bool IList.Contains(object value) { return (values as IList).Contains(value); }\n        int IList.IndexOf(object value) { return (values as IList).IndexOf(value); }\n        void IList.Insert(int index, object value) { (values as IList).Insert(index, value); }\n        void IList.Remove(object value) { (values as IList).Remove(value); }\n        void IList.RemoveAt(int index) { (values as IList).RemoveAt(index); }\n        bool IList.IsFixedSize { get { return false; } }\n        object IList.this[int index] { get { return this[index]; } set { (values as IList)[index] = value; } }\n        #endregion\n\n        #region IList<T>\n        public int IndexOf(string item) { return values.IndexOf(item); }\n        public void Insert(int index, string item) { values.Insert(index, item); }\n        public void RemoveAt(int index) { values.RemoveAt(index); }\n\n        private void AssertValid(int index) {\n            if (c.Option == null)\n                throw new InvalidOperationException("OptionContext.Option is null.");\n            if (index >= c.Option.MaxValueCount)\n                throw new ArgumentOutOfRangeException("index");\n            if (c.Option.OptionValueType == OptionValueType.Required &&\n                    index >= values.Count)\n                throw new OptionException(string.Format(\n                            c.OptionSet.MessageLocalizer("Missing required value for option \'{0}\'."), c.OptionName),\n                        c.OptionName);\n        }\n\n        public string this[int index] {\n            get {\n                AssertValid(index);\n                return index >= values.Count ? null : values[index];\n            }\n            set {\n                values[index] = value;\n            }\n        }\n        #endregion\n\n        public List<string> ToList() {\n            return new List<string>(values);\n        }\n\n        public string[] ToArray() {\n            return values.ToArray();\n        }\n\n        public override string ToString() {\n            return string.Join(", ", values.ToArray());\n        }\n    }\n\n    public class OptionContext {\n        private Option option;\n        private string name;\n        private int index;\n        private OptionSet set;\n        private OptionValueCollection c;\n\n        public OptionContext(OptionSet set) {\n            this.set = set;\n            this.c = new OptionValueCollection(this);\n        }\n\n        public Option Option {\n            get { return option; }\n            set { option = value; }\n        }\n\n        public string OptionName {\n            get { return name; }\n            set { name = value; }\n        }\n\n        public int OptionIndex {\n            get { return index; }\n            set { index = value; }\n        }\n\n        public OptionSet OptionSet {\n            get { return set; }\n        }\n\n        public OptionValueCollection OptionValues {\n            get { return c; }\n        }\n    }\n\n    public enum OptionValueType {\n        None,\n        Optional,\n        Required,\n    }\n\n    public abstract class Option {\n        string prototype, description;\n        string[] names;\n        OptionValueType type;\n        int count;\n        string[] separators;\n        bool hidden;\n\n        protected Option(string prototype, string description)\n            : this(prototype, description, 1, false) {\n        }\n\n        protected Option(string prototype, string description, int maxValueCount)\n            : this(prototype, description, maxValueCount, false) {\n        }\n\n        protected Option(string prototype, string description, int maxValueCount, bool hidden) {\n            if (prototype == null)\n                throw new ArgumentNullException("prototype");\n            if (prototype.Length == 0)\n                throw new ArgumentException("Cannot be the empty string.", "prototype");\n            if (maxValueCount < 0)\n                throw new ArgumentOutOfRangeException("maxValueCount");\n\n            this.prototype = prototype;\n            this.description = description;\n            this.count = maxValueCount;\n            this.names = (this is OptionSet.Category)\n                // append GetHashCode() so that "duplicate" categories have distinct\n                // names, e.g. adding multiple "" categories should be valid.\n                ? new[] { prototype + this.GetHashCode() }\n                : prototype.Split(\'|\');\n\n            if (this is OptionSet.Category || this is CommandOption)\n                return;\n\n            this.type = ParsePrototype();\n            this.hidden = hidden;\n\n            if (this.count == 0 && type != OptionValueType.None)\n                throw new ArgumentException(\n                        "Cannot provide maxValueCount of 0 for OptionValueType.Required or " +\n                            "OptionValueType.Optional.",\n                        "maxValueCount");\n            if (this.type == OptionValueType.None && maxValueCount > 1)\n                throw new ArgumentException(\n                        string.Format("Cannot provide maxValueCount of {0} for OptionValueType.None.", maxValueCount),\n                        "maxValueCount");\n            if (Array.IndexOf(names, "<>") >= 0 &&\n                    ((names.Length == 1 && this.type != OptionValueType.None) ||\n                     (names.Length > 1 && this.MaxValueCount > 1)))\n                throw new ArgumentException(\n                        "The default option handler \'<>\' cannot require values.",\n                        "prototype");\n        }\n\n        public string Prototype { get { return prototype; } }\n        public string Description { get { return description; } }\n        public OptionValueType OptionValueType { get { return type; } }\n        public int MaxValueCount { get { return count; } }\n        public bool Hidden { get { return hidden; } }\n\n        public string[] GetNames() {\n            return (string[])names.Clone();\n        }\n\n        public string[] GetValueSeparators() {\n            if (separators == null)\n                return new string[0];\n            return (string[])separators.Clone();\n        }\n\n        protected static T Parse<T>(string value, OptionContext c) {\n            Type tt = typeof(T);\n#if PCL\n\t\t\tTypeInfo ti = tt.GetTypeInfo ();\n#else\n            Type ti = tt;\n#endif\n            bool nullable =\n                ti.IsValueType &&\n                ti.IsGenericType &&\n                !ti.IsGenericTypeDefinition &&\n                ti.GetGenericTypeDefinition() == typeof(Nullable<>);\n#if PCL\n\t\t\tType targetType = nullable ? tt.GenericTypeArguments [0] : tt;\n#else\n            Type targetType = nullable ? tt.GetGenericArguments()[0] : tt;\n#endif\n            T t = default(T);\n            try {\n                if (value != null) {\n#if PCL\n\t\t\t\t\tif (targetType.GetTypeInfo ().IsEnum)\n\t\t\t\t\t\tt = (T) Enum.Parse (targetType, value, true);\n\t\t\t\t\telse\n\t\t\t\t\t\tt = (T) Convert.ChangeType (value, targetType);\n#else\n                    TypeConverter conv = TypeDescriptor.GetConverter(targetType);\n                    t = (T)conv.ConvertFromString(value);\n#endif\n                }\n            } catch (Exception e) {\n                throw new OptionException(\n                        string.Format(\n                            c.OptionSet.MessageLocalizer("Could not convert string `{0}\' to type {1} for option `{2}\'."),\n                            value, targetType.Name, c.OptionName),\n                        c.OptionName, e);\n            }\n            return t;\n        }\n\n        internal string[] Names { get { return names; } }\n        internal string[] ValueSeparators { get { return separators; } }\n\n        static readonly char[] NameTerminator = new char[] { \'=\', \':\' };\n\n        private OptionValueType ParsePrototype() {\n            char type = \'\\0\';\n            List<string> seps = new List<string>();\n            for (int i = 0; i < names.Length; ++i) {\n                string name = names[i];\n                if (name.Length == 0)\n                    throw new ArgumentException("Empty option names are not supported.", "prototype");\n\n                int end = name.IndexOfAny(NameTerminator);\n                if (end == -1)\n                    continue;\n                names[i] = name.Substring(0, end);\n                if (type == \'\\0\' || type == name[end])\n                    type = name[end];\n                else\n                    throw new ArgumentException(\n                            string.Format("Conflicting option types: \'{0}\' vs. \'{1}\'.", type, name[end]),\n                            "prototype");\n                AddSeparators(name, end, seps);\n            }\n\n            if (type == \'\\0\')\n                return OptionValueType.None;\n\n            if (count <= 1 && seps.Count != 0)\n                throw new ArgumentException(\n                        string.Format("Cannot provide key/value separators for Options taking {0} value(s).", count),\n                        "prototype");\n            if (count > 1) {\n                if (seps.Count == 0)\n                    this.separators = new string[] { ":", "=" };\n                else if (seps.Count == 1 && seps[0].Length == 0)\n                    this.separators = null;\n                else\n                    this.separators = seps.ToArray();\n            }\n\n            return type == \'=\' ? OptionValueType.Required : OptionValueType.Optional;\n        }\n\n        private static void AddSeparators(string name, int end, ICollection<string> seps) {\n            int start = -1;\n            for (int i = end + 1; i < name.Length; ++i) {\n                switch (name[i]) {\n                    case \'{\':\n                        if (start != -1)\n                            throw new ArgumentException(\n                                    string.Format("Ill-formed name/value separator found in \\"{0}\\".", name),\n                                    "prototype");\n                        start = i + 1;\n                        break;\n                    case \'}\':\n                        if (start == -1)\n                            throw new ArgumentException(\n                                    string.Format("Ill-formed name/value separator found in \\"{0}\\".", name),\n                                    "prototype");\n                        seps.Add(name.Substring(start, i - start));\n                        start = -1;\n                        break;\n                    default:\n                        if (start == -1)\n                            seps.Add(name[i].ToString());\n                        break;\n                }\n            }\n            if (start != -1)\n                throw new ArgumentException(\n                        string.Format("Ill-formed name/value separator found in \\"{0}\\".", name),\n                        "prototype");\n        }\n\n        public void Invoke(OptionContext c) {\n            OnParseComplete(c);\n            c.OptionName = null;\n            c.Option = null;\n            c.OptionValues.Clear();\n        }\n\n        protected abstract void OnParseComplete(OptionContext c);\n\n        internal void InvokeOnParseComplete(OptionContext c) {\n            OnParseComplete(c);\n        }\n\n        public override string ToString() {\n            return Prototype;\n        }\n    }\n\n    public abstract class ArgumentSource {\n\n        protected ArgumentSource() {\n        }\n\n        public abstract string[] GetNames();\n        public abstract string Description { get; }\n        public abstract bool GetArguments(string value, out IEnumerable<string> replacement);\n\n#if !PCL || NETSTANDARD1_3\n        public static IEnumerable<string> GetArgumentsFromFile(string file) {\n            return GetArguments(File.OpenText(file), true);\n        }\n#endif\n\n        public static IEnumerable<string> GetArguments(TextReader reader) {\n            return GetArguments(reader, false);\n        }\n\n        // Cribbed from mcs/driver.cs:LoadArgs(string)\n        static IEnumerable<string> GetArguments(TextReader reader, bool close) {\n            try {\n                StringBuilder arg = new StringBuilder();\n\n                string line;\n                while ((line = reader.ReadLine()) != null) {\n                    int t = line.Length;\n\n                    for (int i = 0; i < t; i++) {\n                        char c = line[i];\n\n                        if (c == \'"\' || c == \'\\\'\') {\n                            char end = c;\n\n                            for (i++; i < t; i++) {\n                                c = line[i];\n\n                                if (c == end)\n                                    break;\n                                arg.Append(c);\n                            }\n                        } else if (c == \' \') {\n                            if (arg.Length > 0) {\n                                yield return arg.ToString();\n                                arg.Length = 0;\n                            }\n                        } else\n                            arg.Append(c);\n                    }\n                    if (arg.Length > 0) {\n                        yield return arg.ToString();\n                        arg.Length = 0;\n                    }\n                }\n            } finally {\n                if (close)\n                    reader.Dispose();\n            }\n        }\n    }\n\n#if !PCL || NETSTANDARD1_3\n    internal class ResponseFileSource : ArgumentSource {\n\n        public override string[] GetNames() {\n            return new string[] { "@file" };\n        }\n\n        public override string Description {\n            get { return "Read response file for more options."; }\n        }\n\n        public override bool GetArguments(string value, out IEnumerable<string> replacement) {\n            if (string.IsNullOrEmpty(value) || !value.StartsWith("@")) {\n                replacement = null;\n                return false;\n            }\n            replacement = ArgumentSource.GetArgumentsFromFile(value.Substring(1));\n            return true;\n        }\n    }\n#endif\n\n#if !PCL\n    [Serializable]\n#endif\n    internal class OptionException : Exception {\n        private string option;\n\n        public OptionException() {\n        }\n\n        public OptionException(string message, string optionName)\n            : base(message) {\n            this.option = optionName;\n        }\n\n        public OptionException(string message, string optionName, Exception innerException)\n            : base(message, innerException) {\n            this.option = optionName;\n        }\n\n#if !PCL\n        protected OptionException(SerializationInfo info, StreamingContext context)\n            : base(info, context) {\n            this.option = info.GetString("OptionName");\n        }\n#endif\n\n        public string OptionName {\n            get { return this.option; }\n        }\n\n#if !PCL\n#pragma warning disable 618 // SecurityPermissionAttribute is obsolete\n        [SecurityPermission(SecurityAction.LinkDemand, SerializationFormatter = true)]\n#pragma warning restore 618\n        public override void GetObjectData(SerializationInfo info, StreamingContext context) {\n            base.GetObjectData(info, context);\n            info.AddValue("OptionName", option);\n        }\n#endif\n    }\n\n    public delegate void OptionAction<TKey, TValue>(TKey key, TValue value);\n\n    public class OptionSet : KeyedCollection<string, Option> {\n        public OptionSet()\n            : this(null) {\n        }\n\n        public OptionSet(MessageLocalizerConverter localizer) {\n            this.roSources = new ReadOnlyCollection<ArgumentSource>(sources);\n            this.localizer = localizer;\n            if (this.localizer == null) {\n                this.localizer = delegate (string f) {\n                    return f;\n                };\n            }\n        }\n\n        MessageLocalizerConverter localizer;\n\n        public MessageLocalizerConverter MessageLocalizer {\n            get { return localizer; }\n            internal set { localizer = value; }\n        }\n\n        List<ArgumentSource> sources = new List<ArgumentSource>();\n        ReadOnlyCollection<ArgumentSource> roSources;\n\n        public ReadOnlyCollection<ArgumentSource> ArgumentSources {\n            get { return roSources; }\n        }\n\n\n        protected override string GetKeyForItem(Option item) {\n            if (item == null)\n                throw new ArgumentNullException("option");\n            if (item.Names != null && item.Names.Length > 0)\n                return item.Names[0];\n            // This should never happen, as it\'s invalid for Option to be\n            // constructed w/o any names.\n            throw new InvalidOperationException("Option has no names!");\n        }\n\n        [Obsolete("Use KeyedCollection.this[string]")]\n        protected Option GetOptionForName(string option) {\n            if (option == null)\n                throw new ArgumentNullException("option");\n            try {\n                return base[option];\n            } catch (KeyNotFoundException) {\n                return null;\n            }\n        }\n\n        protected override void InsertItem(int index, Option item) {\n            base.InsertItem(index, item);\n            AddImpl(item);\n        }\n\n        protected override void RemoveItem(int index) {\n            Option p = Items[index];\n            base.RemoveItem(index);\n            // KeyedCollection.RemoveItem() handles the 0th item\n            for (int i = 1; i < p.Names.Length; ++i) {\n                Dictionary.Remove(p.Names[i]);\n            }\n        }\n\n        protected override void SetItem(int index, Option item) {\n            base.SetItem(index, item);\n            AddImpl(item);\n        }\n\n        private void AddImpl(Option option) {\n            if (option == null)\n                throw new ArgumentNullException("option");\n            List<string> added = new List<string>(option.Names.Length);\n            try {\n                // KeyedCollection.InsertItem/SetItem handle the 0th name.\n                for (int i = 1; i < option.Names.Length; ++i) {\n                    Dictionary.Add(option.Names[i], option);\n                    added.Add(option.Names[i]);\n                }\n            } catch (Exception) {\n                foreach (string name in added)\n                    Dictionary.Remove(name);\n                throw;\n            }\n        }\n\n        public OptionSet Add(string header) {\n            if (header == null)\n                throw new ArgumentNullException("header");\n            Add(new Category(header));\n            return this;\n        }\n\n        internal sealed class Category : Option {\n\n            // Prototype starts with \'=\' because this is an invalid prototype\n            // (see Option.ParsePrototype(), and thus it\'ll prevent Category\n            // instances from being accidentally used as normal options.\n            public Category(string description)\n                : base("=:Category:= " + description, description) {\n            }\n\n            protected override void OnParseComplete(OptionContext c) {\n                throw new NotSupportedException("Category.OnParseComplete should not be invoked.");\n            }\n        }\n\n\n        public new OptionSet Add(Option option) {\n            base.Add(option);\n            return this;\n        }\n\n        sealed class ActionOption : Option {\n            Action<OptionValueCollection> action;\n\n            public ActionOption(string prototype, string description, int count, Action<OptionValueCollection> action)\n                : this(prototype, description, count, action, false) {\n            }\n\n            public ActionOption(string prototype, string description, int count, Action<OptionValueCollection> action, bool hidden)\n                : base(prototype, description, count, hidden) {\n                if (action == null)\n                    throw new ArgumentNullException("action");\n                this.action = action;\n            }\n\n            protected override void OnParseComplete(OptionContext c) {\n                action(c.OptionValues);\n            }\n        }\n\n        public OptionSet Add(string prototype, Action<string> action) {\n            return Add(prototype, null, action);\n        }\n\n        public OptionSet Add(string prototype, string description, Action<string> action) {\n            return Add(prototype, description, action, false);\n        }\n\n        public OptionSet Add(string prototype, string description, Action<string> action, bool hidden) {\n            if (action == null)\n                throw new ArgumentNullException("action");\n            Option p = new ActionOption(prototype, description, 1,\n                    delegate (OptionValueCollection v) { action(v[0]); }, hidden);\n            base.Add(p);\n            return this;\n        }\n\n        public OptionSet Add(string prototype, OptionAction<string, string> action) {\n            return Add(prototype, null, action);\n        }\n\n        public OptionSet Add(string prototype, string description, OptionAction<string, string> action) {\n            return Add(prototype, description, action, false);\n        }\n\n        public OptionSet Add(string prototype, string description, OptionAction<string, string> action, bool hidden) {\n            if (action == null)\n                throw new ArgumentNullException("action");\n            Option p = new ActionOption(prototype, description, 2,\n                    delegate (OptionValueCollection v) { action(v[0], v[1]); }, hidden);\n            base.Add(p);\n            return this;\n        }\n\n        sealed class ActionOption<T> : Option {\n            Action<T> action;\n\n            public ActionOption(string prototype, string description, Action<T> action)\n                : base(prototype, description, 1) {\n                if (action == null)\n                    throw new ArgumentNullException("action");\n                this.action = action;\n            }\n\n            protected override void OnParseComplete(OptionContext c) {\n                action(Parse<T>(c.OptionValues[0], c));\n            }\n        }\n\n        sealed class ActionOption<TKey, TValue> : Option {\n            OptionAction<TKey, TValue> action;\n\n            public ActionOption(string prototype, string description, OptionAction<TKey, TValue> action)\n                : base(prototype, description, 2) {\n                if (action == null)\n                    throw new ArgumentNullException("action");\n                this.action = action;\n            }\n\n            protected override void OnParseComplete(OptionContext c) {\n                action(\n                        Parse<TKey>(c.OptionValues[0], c),\n                        Parse<TValue>(c.OptionValues[1], c));\n            }\n        }\n\n        public OptionSet Add<T>(string prototype, Action<T> action) {\n            return Add(prototype, null, action);\n        }\n\n        public OptionSet Add<T>(string prototype, string description, Action<T> action) {\n            return Add(new ActionOption<T>(prototype, description, action));\n        }\n\n        public OptionSet Add<TKey, TValue>(string prototype, OptionAction<TKey, TValue> action) {\n            return Add(prototype, null, action);\n        }\n\n        public OptionSet Add<TKey, TValue>(string prototype, string description, OptionAction<TKey, TValue> action) {\n            return Add(new ActionOption<TKey, TValue>(prototype, description, action));\n        }\n\n        public OptionSet Add(ArgumentSource source) {\n            if (source == null)\n                throw new ArgumentNullException("source");\n            sources.Add(source);\n            return this;\n        }\n\n        protected virtual OptionContext CreateOptionContext() {\n            return new OptionContext(this);\n        }\n\n        public List<string> Parse(IEnumerable<string> arguments) {\n            if (arguments == null)\n                throw new ArgumentNullException("arguments");\n            OptionContext c = CreateOptionContext();\n            c.OptionIndex = -1;\n            bool process = true;\n            List<string> unprocessed = new List<string>();\n            Option def = Contains("<>") ? this["<>"] : null;\n            ArgumentEnumerator ae = new ArgumentEnumerator(arguments);\n            foreach (string argument in ae) {\n                ++c.OptionIndex;\n                if (argument == "--") {\n                    process = false;\n                    continue;\n                }\n                if (!process) {\n                    Unprocessed(unprocessed, def, c, argument);\n                    continue;\n                }\n                if (AddSource(ae, argument))\n                    continue;\n                if (!Parse(argument, c))\n                    Unprocessed(unprocessed, def, c, argument);\n            }\n            if (c.Option != null)\n                c.Option.Invoke(c);\n            return unprocessed;\n        }\n\n        class ArgumentEnumerator : IEnumerable<string> {\n            List<IEnumerator<string>> sources = new List<IEnumerator<string>>();\n\n            public ArgumentEnumerator(IEnumerable<string> arguments) {\n                sources.Add(arguments.GetEnumerator());\n            }\n\n            public void Add(IEnumerable<string> arguments) {\n                sources.Add(arguments.GetEnumerator());\n            }\n\n            public IEnumerator<string> GetEnumerator() {\n                do {\n                    IEnumerator<string> c = sources[sources.Count - 1];\n                    if (c.MoveNext())\n                        yield return c.Current;\n                    else {\n                        c.Dispose();\n                        sources.RemoveAt(sources.Count - 1);\n                    }\n                } while (sources.Count > 0);\n            }\n\n            IEnumerator IEnumerable.GetEnumerator() {\n                return GetEnumerator();\n            }\n        }\n\n        bool AddSource(ArgumentEnumerator ae, string argument) {\n            foreach (ArgumentSource source in sources) {\n                IEnumerable<string> replacement;\n                if (!source.GetArguments(argument, out replacement))\n                    continue;\n                ae.Add(replacement);\n                return true;\n            }\n            return false;\n        }\n\n        private static bool Unprocessed(ICollection<string> extra, Option def, OptionContext c, string argument) {\n            if (def == null) {\n                extra.Add(argument);\n                return false;\n            }\n            c.OptionValues.Add(argument);\n            c.Option = def;\n            c.Option.Invoke(c);\n            return false;\n        }\n\n        private readonly Regex ValueOption = new Regex(\n            @"^(?<flag>--|-|/)(?<name>[^:=]+)((?<sep>[:=])(?<value>.*))?$");\n\n        protected bool GetOptionParts(string argument, out string flag, out string name, out string sep, out string value) {\n            if (argument == null)\n                throw new ArgumentNullException("argument");\n\n            flag = name = sep = value = null;\n            Match m = ValueOption.Match(argument);\n            if (!m.Success) {\n                return false;\n            }\n            flag = m.Groups["flag"].Value;\n            name = m.Groups["name"].Value;\n            if (m.Groups["sep"].Success && m.Groups["value"].Success) {\n                sep = m.Groups["sep"].Value;\n                value = m.Groups["value"].Value;\n            }\n            return true;\n        }\n\n        protected virtual bool Parse(string argument, OptionContext c) {\n            if (c.Option != null) {\n                ParseValue(argument, c);\n                return true;\n            }\n\n            string f, n, s, v;\n            if (!GetOptionParts(argument, out f, out n, out s, out v))\n                return false;\n\n            Option p;\n            if (Contains(n)) {\n                p = this[n];\n                c.OptionName = f + n;\n                c.Option = p;\n                switch (p.OptionValueType) {\n                    case OptionValueType.None:\n                        c.OptionValues.Add(n);\n                        c.Option.Invoke(c);\n                        break;\n                    case OptionValueType.Optional:\n                    case OptionValueType.Required:\n                        ParseValue(v, c);\n                        break;\n                }\n                return true;\n            }\n            // no match; is it a bool option?\n            if (ParseBool(argument, n, c))\n                return true;\n            // is it a bundled option?\n            if (ParseBundledValue(f, string.Concat(n + s + v), c))\n                return true;\n\n            return false;\n        }\n\n        private void ParseValue(string option, OptionContext c) {\n            if (option != null)\n                foreach (string o in c.Option.ValueSeparators != null\n                        ? option.Split(c.Option.ValueSeparators, c.Option.MaxValueCount - c.OptionValues.Count, StringSplitOptions.None)\n                        : new string[] { option }) {\n                    c.OptionValues.Add(o);\n                }\n            if (c.OptionValues.Count == c.Option.MaxValueCount ||\n                    c.Option.OptionValueType == OptionValueType.Optional)\n                c.Option.Invoke(c);\n            else if (c.OptionValues.Count > c.Option.MaxValueCount) {\n                throw new OptionException(localizer(string.Format(\n                                "Error: Found {0} option values when expecting {1}.",\n                                c.OptionValues.Count, c.Option.MaxValueCount)),\n                        c.OptionName);\n            }\n        }\n\n        private bool ParseBool(string option, string n, OptionContext c) {\n            Option p;\n            string rn;\n            if (n.Length >= 1 && (n[n.Length - 1] == \'+\' || n[n.Length - 1] == \'-\') &&\n                    Contains((rn = n.Substring(0, n.Length - 1)))) {\n                p = this[rn];\n                string v = n[n.Length - 1] == \'+\' ? option : null;\n                c.OptionName = option;\n                c.Option = p;\n                c.OptionValues.Add(v);\n                p.Invoke(c);\n                return true;\n            }\n            return false;\n        }\n\n        private bool ParseBundledValue(string f, string n, OptionContext c) {\n            if (f != "-")\n                return false;\n            for (int i = 0; i < n.Length; ++i) {\n                Option p;\n                string opt = f + n[i].ToString();\n                string rn = n[i].ToString();\n                if (!Contains(rn)) {\n                    if (i == 0)\n                        return false;\n                    throw new OptionException(string.Format(localizer(\n                                    "Cannot use unregistered option \'{0}\' in bundle \'{1}\'."), rn, f + n), null);\n                }\n                p = this[rn];\n                switch (p.OptionValueType) {\n                    case OptionValueType.None:\n                        Invoke(c, opt, n, p);\n                        break;\n                    case OptionValueType.Optional:\n                    case OptionValueType.Required: {\n                            string v = n.Substring(i + 1);\n                            c.Option = p;\n                            c.OptionName = opt;\n                            ParseValue(v.Length != 0 ? v : null, c);\n                            return true;\n                        }\n                    default:\n                        throw new InvalidOperationException("Unknown OptionValueType: " + p.OptionValueType);\n                }\n            }\n            return true;\n        }\n\n        private static void Invoke(OptionContext c, string name, string value, Option option) {\n            c.OptionName = name;\n            c.Option = option;\n            c.OptionValues.Add(value);\n            option.Invoke(c);\n        }\n\n        private const int OptionWidth = 29;\n        private const int Description_FirstWidth = 80 - OptionWidth;\n        private const int Description_RemWidth = 80 - OptionWidth - 2;\n\n        static readonly string CommandHelpIndentStart = new string(\' \', OptionWidth);\n        static readonly string CommandHelpIndentRemaining = new string(\' \', OptionWidth + 2);\n\n        public void WriteOptionDescriptions(TextWriter o) {\n            foreach (Option p in this) {\n                int written = 0;\n\n                if (p.Hidden)\n                    continue;\n\n                Category c = p as Category;\n                if (c != null) {\n                    WriteDescription(o, p.Description, "", 80, 80);\n                    continue;\n                }\n                CommandOption co = p as CommandOption;\n                if (co != null) {\n                    WriteCommandDescription(o, co.Command, co.CommandName);\n                    continue;\n                }\n\n                if (!WriteOptionPrototype(o, p, ref written))\n                    continue;\n\n                if (written < OptionWidth)\n                    o.Write(new string(\' \', OptionWidth - written));\n                else {\n                    o.WriteLine();\n                    o.Write(new string(\' \', OptionWidth));\n                }\n\n                WriteDescription(o, p.Description, new string(\' \', OptionWidth + 2),\n                        Description_FirstWidth, Description_RemWidth);\n            }\n\n            foreach (ArgumentSource s in sources) {\n                string[] names = s.GetNames();\n                if (names == null || names.Length == 0)\n                    continue;\n\n                int written = 0;\n\n                Write(o, ref written, "  ");\n                Write(o, ref written, names[0]);\n                for (int i = 1; i < names.Length; ++i) {\n                    Write(o, ref written, ", ");\n                    Write(o, ref written, names[i]);\n                }\n\n                if (written < OptionWidth)\n                    o.Write(new string(\' \', OptionWidth - written));\n                else {\n                    o.WriteLine();\n                    o.Write(new string(\' \', OptionWidth));\n                }\n\n                WriteDescription(o, s.Description, new string(\' \', OptionWidth + 2),\n                        Description_FirstWidth, Description_RemWidth);\n            }\n        }\n\n        internal void WriteCommandDescription(TextWriter o, Command c, string commandName) {\n            var name = new string(\' \', 8) + (commandName ?? c.Name);\n            if (name.Length < OptionWidth - 1) {\n                WriteDescription(o, name + new string(\' \', OptionWidth - name.Length) + c.Help, CommandHelpIndentRemaining, 80, Description_RemWidth);\n            } else {\n                WriteDescription(o, name, "", 80, 80);\n                WriteDescription(o, CommandHelpIndentStart + c.Help, CommandHelpIndentRemaining, 80, Description_RemWidth);\n            }\n        }\n\n        void WriteDescription(TextWriter o, string value, string prefix, int firstWidth, int remWidth) {\n            bool indent = false;\n            foreach (string line in GetLines(localizer(GetDescription(value)), firstWidth, remWidth)) {\n                if (indent)\n                    o.Write(prefix);\n                o.WriteLine(line);\n                indent = true;\n            }\n        }\n\n        bool WriteOptionPrototype(TextWriter o, Option p, ref int written) {\n            string[] names = p.Names;\n\n            int i = GetNextOptionIndex(names, 0);\n            if (i == names.Length)\n                return false;\n\n            if (names[i].Length == 1) {\n                Write(o, ref written, "  -");\n                Write(o, ref written, names[0]);\n            } else {\n                Write(o, ref written, "      --");\n                Write(o, ref written, names[0]);\n            }\n\n            for (i = GetNextOptionIndex(names, i + 1);\n                    i < names.Length; i = GetNextOptionIndex(names, i + 1)) {\n                Write(o, ref written, ", ");\n                Write(o, ref written, names[i].Length == 1 ? "-" : "--");\n                Write(o, ref written, names[i]);\n            }\n\n            if (p.OptionValueType == OptionValueType.Optional ||\n                    p.OptionValueType == OptionValueType.Required) {\n                if (p.OptionValueType == OptionValueType.Optional) {\n                    Write(o, ref written, localizer("["));\n                }\n                Write(o, ref written, localizer("=" + GetArgumentName(0, p.MaxValueCount, p.Description)));\n                string sep = p.ValueSeparators != null && p.ValueSeparators.Length > 0\n                    ? p.ValueSeparators[0]\n                    : " ";\n                for (int c = 1; c < p.MaxValueCount; ++c) {\n                    Write(o, ref written, localizer(sep + GetArgumentName(c, p.MaxValueCount, p.Description)));\n                }\n                if (p.OptionValueType == OptionValueType.Optional) {\n                    Write(o, ref written, localizer("]"));\n                }\n            }\n            return true;\n        }\n\n        static int GetNextOptionIndex(string[] names, int i) {\n            while (i < names.Length && names[i] == "<>") {\n                ++i;\n            }\n            return i;\n        }\n\n        static void Write(TextWriter o, ref int n, string s) {\n            n += s.Length;\n            o.Write(s);\n        }\n\n        static string GetArgumentName(int index, int maxIndex, string description) {\n            var matches = Regex.Matches(description ?? "", @"(?<=(?<!\\{)\\{)[^{}]*(?=\\}(?!\\}))"); // ignore double braces \n            string argName = "";\n            foreach (Match match in matches) {\n                var parts = match.Value.Split(\':\');\n                // for maxIndex=1 it can be {foo} or {0:foo}\n                if (maxIndex == 1) {\n                    argName = parts[parts.Length - 1];\n                }\n                // look for {i:foo} if maxIndex > 1\n                if (maxIndex > 1 && parts.Length == 2 &&\n                    parts[0] == index.ToString(CultureInfo.InvariantCulture)) {\n                    argName = parts[1];\n                }\n            }\n\n            if (string.IsNullOrEmpty(argName)) {\n                argName = maxIndex == 1 ? "VALUE" : "VALUE" + (index + 1);\n            }\n            return argName;\n        }\n\n        private static string GetDescription(string description) {\n            if (description == null)\n                return string.Empty;\n            StringBuilder sb = new StringBuilder(description.Length);\n            int start = -1;\n            for (int i = 0; i < description.Length; ++i) {\n                switch (description[i]) {\n                    case \'{\':\n                        if (i == start) {\n                            sb.Append(\'{\');\n                            start = -1;\n                        } else if (start < 0)\n                            start = i + 1;\n                        break;\n                    case \'}\':\n                        if (start < 0) {\n                            if ((i + 1) == description.Length || description[i + 1] != \'}\')\n                                throw new InvalidOperationException("Invalid option description: " + description);\n                            ++i;\n                            sb.Append("}");\n                        } else {\n                            sb.Append(description.Substring(start, i - start));\n                            start = -1;\n                        }\n                        break;\n                    case \':\':\n                        if (start < 0)\n                            goto default;\n                        start = i + 1;\n                        break;\n                    default:\n                        if (start < 0)\n                            sb.Append(description[i]);\n                        break;\n                }\n            }\n            return sb.ToString();\n        }\n\n        private static IEnumerable<string> GetLines(string description, int firstWidth, int remWidth) {\n            return StringCoda.WrappedLines(description, firstWidth, remWidth);\n        }\n    }\n\n    internal class Command {\n        public string Name { get; }\n        public string Help { get; }\n\n        public OptionSet Options { get; set; }\n        public Action<IEnumerable<string>> Run { get; set; }\n\n        public CommandSet CommandSet { get; internal set; }\n\n        public Command(string name, string help = null) {\n            if (string.IsNullOrEmpty(name))\n                throw new ArgumentNullException(nameof(name));\n\n            Name = NormalizeCommandName(name);\n            Help = help;\n        }\n\n        static string NormalizeCommandName(string name) {\n            var value = new StringBuilder(name.Length);\n            var space = false;\n            for (int i = 0; i < name.Length; ++i) {\n                if (!char.IsWhiteSpace(name, i)) {\n                    space = false;\n                    value.Append(name[i]);\n                } else if (!space) {\n                    space = true;\n                    value.Append(\' \');\n                }\n            }\n            return value.ToString();\n        }\n\n        public virtual int Invoke(IEnumerable<string> arguments) {\n            var rest = Options?.Parse(arguments) ?? arguments;\n            Run?.Invoke(rest);\n            return 0;\n        }\n    }\n\n    class CommandOption : Option {\n        public Command Command { get; }\n        public string CommandName { get; }\n\n        // Prototype starts with \'=\' because this is an invalid prototype\n        // (see Option.ParsePrototype(), and thus it\'ll prevent Category\n        // instances from being accidentally used as normal options.\n        public CommandOption(Command command, string commandName = null, bool hidden = false)\n            : base("=:Command:= " + (commandName ?? command?.Name), (commandName ?? command?.Name), maxValueCount: 0, hidden: hidden) {\n            if (command == null)\n                throw new ArgumentNullException(nameof(command));\n            Command = command;\n            CommandName = commandName ?? command.Name;\n        }\n\n        protected override void OnParseComplete(OptionContext c) {\n            throw new NotSupportedException("CommandOption.OnParseComplete should not be invoked.");\n        }\n    }\n\n    class HelpOption : Option {\n        Option option;\n        CommandSet commands;\n\n        public HelpOption(CommandSet commands, Option d)\n            : base(d.Prototype, d.Description, d.MaxValueCount, d.Hidden) {\n            this.commands = commands;\n            this.option = d;\n        }\n\n        protected override void OnParseComplete(OptionContext c) {\n            commands.showHelp = true;\n\n            option?.InvokeOnParseComplete(c);\n        }\n    }\n\n    class CommandOptionSet : OptionSet {\n        CommandSet commands;\n\n        public CommandOptionSet(CommandSet commands, MessageLocalizerConverter localizer)\n            : base(localizer) {\n            this.commands = commands;\n        }\n\n        protected override void SetItem(int index, Option item) {\n            if (ShouldWrapOption(item)) {\n                base.SetItem(index, new HelpOption(commands, item));\n                return;\n            }\n            base.SetItem(index, item);\n        }\n\n        bool ShouldWrapOption(Option item) {\n            if (item == null)\n                return false;\n            var help = item as HelpOption;\n            if (help != null)\n                return false;\n            foreach (var n in item.Names) {\n                if (n == "help")\n                    return true;\n            }\n            return false;\n        }\n\n        protected override void InsertItem(int index, Option item) {\n            if (ShouldWrapOption(item)) {\n                base.InsertItem(index, new HelpOption(commands, item));\n                return;\n            }\n            base.InsertItem(index, item);\n        }\n    }\n\n    internal class CommandSet : KeyedCollection<string, Command> {\n        readonly string suite;\n\n        OptionSet options;\n        TextWriter outWriter;\n        TextWriter errorWriter;\n\n        internal List<CommandSet> NestedCommandSets;\n\n        internal HelpCommand help;\n\n        internal bool showHelp;\n\n        internal OptionSet Options => options;\n\n#if !PCL || NETSTANDARD1_3\n        public CommandSet(string suite, MessageLocalizerConverter localizer = null)\n            : this(suite, Console.Out, Console.Error, localizer) {\n        }\n#endif\n\n        public CommandSet(string suite, TextWriter output, TextWriter error, MessageLocalizerConverter localizer = null) {\n            if (suite == null)\n                throw new ArgumentNullException(nameof(suite));\n            if (output == null)\n                throw new ArgumentNullException(nameof(output));\n            if (error == null)\n                throw new ArgumentNullException(nameof(error));\n\n            this.suite = suite;\n            options = new CommandOptionSet(this, localizer);\n            outWriter = output;\n            errorWriter = error;\n        }\n\n        public string Suite => suite;\n        public TextWriter Out => outWriter;\n        public TextWriter Error => errorWriter;\n        public MessageLocalizerConverter MessageLocalizer => options.MessageLocalizer;\n\n        protected override string GetKeyForItem(Command item) {\n            return item?.Name;\n        }\n\n        public new CommandSet Add(Command value) {\n            if (value == null)\n                throw new ArgumentNullException(nameof(value));\n            AddCommand(value);\n            options.Add(new CommandOption(value));\n            return this;\n        }\n\n        void AddCommand(Command value) {\n            if (value.CommandSet != null && value.CommandSet != this) {\n                throw new ArgumentException("Command instances can only be added to a single CommandSet.", nameof(value));\n            }\n            value.CommandSet = this;\n            if (value.Options != null) {\n                value.Options.MessageLocalizer = options.MessageLocalizer;\n            }\n\n            base.Add(value);\n\n            help = help ?? value as HelpCommand;\n        }\n\n        public CommandSet Add(string header) {\n            options.Add(header);\n            return this;\n        }\n\n        public CommandSet Add(Option option) {\n            options.Add(option);\n            return this;\n        }\n\n        public CommandSet Add(string prototype, Action<string> action) {\n            options.Add(prototype, action);\n            return this;\n        }\n\n        public CommandSet Add(string prototype, string description, Action<string> action) {\n            options.Add(prototype, description, action);\n            return this;\n        }\n\n        public CommandSet Add(string prototype, string description, Action<string> action, bool hidden) {\n            options.Add(prototype, description, action, hidden);\n            return this;\n        }\n\n        public CommandSet Add(string prototype, OptionAction<string, string> action) {\n            options.Add(prototype, action);\n            return this;\n        }\n\n        public CommandSet Add(string prototype, string description, OptionAction<string, string> action) {\n            options.Add(prototype, description, action);\n            return this;\n        }\n\n        public CommandSet Add(string prototype, string description, OptionAction<string, string> action, bool hidden) {\n            options.Add(prototype, description, action, hidden);\n            return this;\n        }\n\n        public CommandSet Add<T>(string prototype, Action<T> action) {\n            options.Add(prototype, null, action);\n            return this;\n        }\n\n        public CommandSet Add<T>(string prototype, string description, Action<T> action) {\n            options.Add(prototype, description, action);\n            return this;\n        }\n\n        public CommandSet Add<TKey, TValue>(string prototype, OptionAction<TKey, TValue> action) {\n            options.Add(prototype, action);\n            return this;\n        }\n\n        public CommandSet Add<TKey, TValue>(string prototype, string description, OptionAction<TKey, TValue> action) {\n            options.Add(prototype, description, action);\n            return this;\n        }\n\n        public CommandSet Add(ArgumentSource source) {\n            options.Add(source);\n            return this;\n        }\n\n        public CommandSet Add(CommandSet nestedCommands) {\n            if (nestedCommands == null)\n                throw new ArgumentNullException(nameof(nestedCommands));\n\n            if (NestedCommandSets == null) {\n                NestedCommandSets = new List<CommandSet>();\n            }\n\n            if (!AlreadyAdded(nestedCommands)) {\n                NestedCommandSets.Add(nestedCommands);\n                foreach (var o in nestedCommands.options) {\n                    if (o is CommandOption c) {\n                        options.Add(new CommandOption(c.Command, $"{nestedCommands.Suite} {c.CommandName}"));\n                    } else {\n                        options.Add(o);\n                    }\n                }\n            }\n\n            nestedCommands.options = this.options;\n            nestedCommands.outWriter = this.outWriter;\n            nestedCommands.errorWriter = this.errorWriter;\n\n            return this;\n        }\n\n        bool AlreadyAdded(CommandSet value) {\n            if (value == this)\n                return true;\n            if (NestedCommandSets == null)\n                return false;\n            foreach (var nc in NestedCommandSets) {\n                if (nc.AlreadyAdded(value))\n                    return true;\n            }\n            return false;\n        }\n\n        public IEnumerable<string> GetCompletions(string prefix = null) {\n            string rest;\n            ExtractToken(ref prefix, out rest);\n\n            foreach (var command in this) {\n                if (command.Name.StartsWith(prefix, StringComparison.OrdinalIgnoreCase)) {\n                    yield return command.Name;\n                }\n            }\n\n            if (NestedCommandSets == null)\n                yield break;\n\n            foreach (var subset in NestedCommandSets) {\n                if (subset.Suite.StartsWith(prefix, StringComparison.OrdinalIgnoreCase)) {\n                    foreach (var c in subset.GetCompletions(rest)) {\n                        yield return $"{subset.Suite} {c}";\n                    }\n                }\n            }\n        }\n\n        static void ExtractToken(ref string input, out string rest) {\n            rest = "";\n            input = input ?? "";\n\n            int top = input.Length;\n            for (int i = 0; i < top; i++) {\n                if (char.IsWhiteSpace(input[i]))\n                    continue;\n\n                for (int j = i; j < top; j++) {\n                    if (char.IsWhiteSpace(input[j])) {\n                        rest = input.Substring(j).Trim();\n                        input = input.Substring(i, j).Trim();\n                        return;\n                    }\n                }\n                rest = "";\n                if (i != 0)\n                    input = input.Substring(i).Trim();\n                return;\n            }\n        }\n\n        public int Run(IEnumerable<string> arguments) {\n            if (arguments == null)\n                throw new ArgumentNullException(nameof(arguments));\n\n            this.showHelp = false;\n            if (help == null) {\n                help = new HelpCommand();\n                AddCommand(help);\n            }\n            Action<string> setHelp = v => showHelp = v != null;\n            if (!options.Contains("help")) {\n                options.Add("help", "", setHelp, hidden: true);\n            }\n            if (!options.Contains("?")) {\n                options.Add("?", "", setHelp, hidden: true);\n            }\n            var extra = options.Parse(arguments);\n            if (extra.Count == 0) {\n                if (showHelp) {\n                    return help.Invoke(extra);\n                }\n                Out.WriteLine(options.MessageLocalizer($"Use `{Suite} help` for usage."));\n                return 1;\n            }\n            var command = GetCommand(extra);\n            if (command == null) {\n                help.WriteUnknownCommand(extra[0]);\n                return 1;\n            }\n            if (showHelp) {\n                if (command.Options?.Contains("help") ?? true) {\n                    extra.Add("--help");\n                    return command.Invoke(extra);\n                }\n                command.Options.WriteOptionDescriptions(Out);\n                return 0;\n            }\n            return command.Invoke(extra);\n        }\n\n        internal Command GetCommand(List<string> extra) {\n            return TryGetLocalCommand(extra) ?? TryGetNestedCommand(extra);\n        }\n\n        Command TryGetLocalCommand(List<string> extra) {\n            var name = extra[0];\n            if (Contains(name)) {\n                extra.RemoveAt(0);\n                return this[name];\n            }\n            for (int i = 1; i < extra.Count; ++i) {\n                name = name + " " + extra[i];\n                if (!Contains(name))\n                    continue;\n                extra.RemoveRange(0, i + 1);\n                return this[name];\n            }\n            return null;\n        }\n\n        Command TryGetNestedCommand(List<string> extra) {\n            if (NestedCommandSets == null)\n                return null;\n\n            var nestedCommands = NestedCommandSets.Find(c => c.Suite == extra[0]);\n            if (nestedCommands == null)\n                return null;\n\n            var extraCopy = new List<string>(extra);\n            extraCopy.RemoveAt(0);\n            if (extraCopy.Count == 0)\n                return null;\n\n            var command = nestedCommands.GetCommand(extraCopy);\n            if (command != null) {\n                extra.Clear();\n                extra.AddRange(extraCopy);\n                return command;\n            }\n            return null;\n        }\n    }\n\n    internal class HelpCommand : Command {\n        public HelpCommand()\n            : base("help", help: "Show this message and exit") {\n        }\n\n        public override int Invoke(IEnumerable<string> arguments) {\n            var extra = new List<string>(arguments ?? new string[0]);\n            var _ = CommandSet.Options.MessageLocalizer;\n            if (extra.Count == 0) {\n                CommandSet.Options.WriteOptionDescriptions(CommandSet.Out);\n                return 0;\n            }\n            var command = CommandSet.GetCommand(extra);\n            if (command == this || extra.Contains("--help")) {\n                CommandSet.Out.WriteLine(_($"Usage: {CommandSet.Suite} COMMAND [OPTIONS]"));\n                CommandSet.Out.WriteLine(_($"Use `{CommandSet.Suite} help COMMAND` for help on a specific command."));\n                CommandSet.Out.WriteLine();\n                CommandSet.Out.WriteLine(_($"Available commands:"));\n                CommandSet.Out.WriteLine();\n                var commands = GetCommands();\n                commands.Sort((x, y) => string.Compare(x.Key, y.Key, StringComparison.OrdinalIgnoreCase));\n                foreach (var c in commands) {\n                    if (c.Key == "help") {\n                        continue;\n                    }\n                    CommandSet.Options.WriteCommandDescription(CommandSet.Out, c.Value, c.Key);\n                }\n                CommandSet.Options.WriteCommandDescription(CommandSet.Out, CommandSet.help, "help");\n                return 0;\n            }\n            if (command == null) {\n                WriteUnknownCommand(extra[0]);\n                return 1;\n            }\n            if (command.Options != null) {\n                command.Options.WriteOptionDescriptions(CommandSet.Out);\n                return 0;\n            }\n            return command.Invoke(new[] { "--help" });\n        }\n\n        List<KeyValuePair<string, Command>> GetCommands() {\n            var commands = new List<KeyValuePair<string, Command>>();\n\n            foreach (var c in CommandSet) {\n                commands.Add(new KeyValuePair<string, Command>(c.Name, c));\n            }\n\n            if (CommandSet.NestedCommandSets == null)\n                return commands;\n\n            foreach (var nc in CommandSet.NestedCommandSets) {\n                AddNestedCommands(commands, "", nc);\n            }\n\n            return commands;\n        }\n\n        void AddNestedCommands(List<KeyValuePair<string, Command>> commands, string outer, CommandSet value) {\n            foreach (var v in value) {\n                commands.Add(new KeyValuePair<string, Command>($"{outer}{value.Suite} {v.Name}", v));\n            }\n            if (value.NestedCommandSets == null)\n                return;\n            foreach (var nc in value.NestedCommandSets) {\n                AddNestedCommands(commands, $"{outer}{value.Suite} ", nc);\n            }\n        }\n\n        internal void WriteUnknownCommand(string unknownCommand) {\n            CommandSet.Error.WriteLine(CommandSet.Options.MessageLocalizer($"{CommandSet.Suite}: Unknown command: {unknownCommand}"));\n            CommandSet.Error.WriteLine(CommandSet.Options.MessageLocalizer($"{CommandSet.Suite}: Use `{CommandSet.Suite} help` for usage."));\n        }\n    }\n}\n'