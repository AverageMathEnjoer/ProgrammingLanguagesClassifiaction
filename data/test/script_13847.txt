b"{-# LANGUAGE CPP                 #-}\n{-# LANGUAGE GADTs               #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n-- |\n-- Copyright  : (c) Ivan Perez, 2017\n-- License    : BSD3\n-- Maintainer : ivan.perez@keera.co.uk\n--\n-- Future-time linear temporal logic implemented on top of monadic stream\n-- functions.\n--\n-- This module can be used to define LTL-like predicates on Monadic Stream\n-- Functions, and to evaluate them. The main entry point is the function\n-- 'evalT', which takes a temporal predicate, and a stream of inputs, and\n-- evaluates the predicate against the stream. Evaluation takes place at time\n-- 0, although it is possible to express conditions on future samples.\n--\n-- /Disclaimer/: This is not necessarily the same as LTL.\nmodule FRP.Dunai.LTLFuture\n    ( TPred(..)\n    , tPredMap\n    , evalT\n    )\n  where\n\n-- External imports\n#if !MIN_VERSION_base(4,8,0)\nimport Control.Applicative (Applicative, pure, (<$>), (<*>))\n#endif\n\nimport Control.Monad.Trans.MSF.Reader          (ReaderT, readerS, runReaderS)\nimport Data.MonadicStreamFunction              (MSF)\nimport Data.MonadicStreamFunction.InternalCore (unMSF)\n\n-- Internal imports\nimport FRP.Dunai.Stream (DTime, SignalSampleStream)\n\n-- * Temporal Logics based on SFs\n\n-- | Type representing future-time linear temporal logic with until and next.\ndata TPred m a where\n  Prop       :: MSF m a Bool -> TPred m a\n  And        :: TPred m a -> TPred m a -> TPred m a\n  Or         :: TPred m a -> TPred m a -> TPred m a\n  Not        :: TPred m a -> TPred m a\n  Implies    :: TPred m a -> TPred m a -> TPred m a\n  Always     :: TPred m a -> TPred m a\n  Eventually :: TPred m a -> TPred m a\n  Next       :: TPred m a -> TPred m a\n  Until      :: TPred m a -> TPred m a -> TPred m a\n\n-- | Apply a transformation to the leaves of a temporal predicate (to the SFs).\ntPredMap :: (Functor m, Applicative m, Monad m)\n         => (MSF m a Bool -> m (MSF m a Bool))  -- ^ Transformation to apply\n         -> TPred m a                           -- ^ Temporal predicate\n         -> m (TPred m a)\ntPredMap f (Prop sf)       = Prop       <$> f sf\ntPredMap f (And t1 t2)     = And        <$> tPredMap f t1 <*> tPredMap f t2\ntPredMap f (Or t1 t2)      = Or         <$> tPredMap f t1 <*> tPredMap f t2\ntPredMap f (Not t1)        = Not        <$> tPredMap f t1\ntPredMap f (Implies t1 t2) = Implies    <$> tPredMap f t1 <*> tPredMap f t2\ntPredMap f (Always t1)     = Always     <$> tPredMap f t1\ntPredMap f (Eventually t1) = Eventually <$> tPredMap f t1\ntPredMap f (Next t1)       = Next       <$> tPredMap f t1\ntPredMap f (Until t1 t2)   = Until      <$> tPredMap f t1 <*> tPredMap f t2\n\n-- * Temporal Evaluation\n\n-- | Evaluates a temporal predicate at time T=0 against a sample stream.\n--\n-- Returns 'True' if the temporal proposition is currently true.\nevalT :: (Functor m, Applicative m, Monad m)\n      => TPred (ReaderT DTime m) a\n      -> SignalSampleStream a\n      -> m Bool\nevalT (Prop _sf)      []     = return False\nevalT (And t1 t2)     []     = (&&) <$> evalT t1 [] <*> evalT t2 []\nevalT (Or  t1 t2)     []     = (||) <$> evalT t1 [] <*> evalT t2 []\nevalT (Not t1)        []     = not  <$> evalT t1 []\nevalT (Implies t1 t2) []     = (||) <$> (not <$> evalT t1 []) <*> evalT t2 []\nevalT (Always _t)     []     = return True\nevalT (Eventually _t) []     = return False\nevalT (Next _t)       []     = return False\nevalT (Until t1 t2)   []     = (||) <$> evalT t1 [] <*> evalT t2 []\nevalT op              (x:xs) = do\n  (r, op') <- stepF op x\n  case (r, xs) of\n    (Def x,    _) -> return x\n    (SoFar x, []) -> return x\n    (SoFar _, xs) -> evalT op' xs\n\n-- ** Multi-valued temporal evaluation\n\n-- | Multi-valued logic result\ndata MultiRes\n  = Def Bool   -- ^ Definite value known\n  | SoFar Bool -- ^ Value so far, but could change\n\n-- | Multi-valued implementation of @and@.\nandM :: MultiRes -> MultiRes -> MultiRes\nandM (Def False)   _             = Def False\nandM _             (Def False)   = Def False\nandM (Def True)    x             = x\nandM x             (Def True)    = x\nandM (SoFar False) (SoFar _)     = SoFar False\nandM (SoFar _)     (SoFar False) = SoFar False\nandM (SoFar True)  (SoFar x)     = SoFar x\n\n-- | Multi-valued implementation of @or@.\norM :: MultiRes -> MultiRes -> MultiRes\norM (Def False)   x             = x\norM _             (Def False)   = Def False\norM (Def True)    x             = x\norM x             (Def True)    = x\norM (SoFar False) (SoFar _)     = SoFar False\norM (SoFar _)     (SoFar False) = SoFar False\norM (SoFar True)  (SoFar x)     = SoFar x\n\n-- | Perform one step of evaluation of a temporal predicate.\nstepF :: (Applicative m, Monad m)\n      => TPred (ReaderT DTime m) a\n      -> (DTime, a)\n      -> m (MultiRes, TPred (ReaderT DTime m) a)\n\nstepF (Prop sf) x = do\n  (b, sf') <- unMSF (runReaderS sf) x\n  return (Def b, Prop (readerS sf'))\n\nstepF (Always sf) x = do\n  (b, sf') <- stepF sf x\n  case b of\n    Def True    -> pure (SoFar True,  Always sf')\n    Def False   -> pure (Def False,   Always sf')\n    SoFar True  -> pure (SoFar True,  Always sf')\n    SoFar False -> pure (SoFar False, Always sf')\n\nstepF (Eventually sf) x = do\n  (b, sf') <- stepF sf x\n  case b of\n    Def   True  -> pure (SoFar True,  Always sf')\n    Def   False -> pure (SoFar False, Always sf')\n    SoFar True  -> pure (SoFar True,  Always sf')\n    SoFar False -> pure (SoFar False, Always sf')\n\nstepF (Not sf) x = do\n  (b, sf') <- stepF sf x\n  case b of\n    Def x   -> pure (Def (not x),   Not sf')\n    SoFar x -> pure (SoFar (not x), Not sf')\n\nstepF (And sf1 sf2) x = do\n  (b1, sf1') <- stepF sf1 x\n  (b2, sf2') <- stepF sf2 x\n  let r = andM b1 b2\n  pure (r, And sf1' sf2')\n\nstepF (Or sf1 sf2) x = do\n  (b1, sf1') <- stepF sf1 x\n  (b2, sf2') <- stepF sf2 x\n  let r = orM b1 b2\n  pure (r, Or sf1' sf2')\n\nstepF (Implies sf1 sf2) x =\n  stepF (Not sf1 `Or` sf2) x\n"