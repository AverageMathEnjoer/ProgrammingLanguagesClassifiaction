b'{-# LANGUAGE CPP #-}\n{-# LANGUAGE DataKinds #-}\n{-# LANGUAGE GADTs #-}\n{-# LANGUAGE Rank2Types #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n{-# LANGUAGE TypeFamilies #-}\n\n-- |\n-- Module      : Hoodle.View.Draw\n-- Copyright   : (c) 2011-2016 Ian-Woo Kim\n--\n-- License     : BSD3\n-- Maintainer  : Ian-Woo Kim <ianwookim@gmail.com>\n-- Stability   : experimental\n-- Portability : GHC\nmodule Hoodle.View.Draw where\n\nimport Control.Lens (at, set, view)\nimport Control.Monad (void, when)\nimport Control.Monad.Trans (MonadIO (liftIO), lift)\nimport Control.Monad.Trans.Maybe (MaybeT (..))\nimport Data.Foldable (concatMap, foldr, mapM_)\nimport Data.Hoodle.BBox\n  ( BBox (..),\n    BBoxed (..),\n    IntersectBBox (Intersect),\n    ULMaybe\n      ( Bottom,\n        Middle,\n        Top\n      ),\n    UnionBBox (Union, unUnion),\n    bboxToDim,\n    fromMaybe,\n    getBBox,\n    moveBBoxByOffset,\n    toMaybe,\n    xformBBox,\n  )\nimport Data.Hoodle.Generic\n  ( gdimension,\n    gitems,\n    glayers,\n    gpages,\n  )\nimport Data.Hoodle.Predefined (predefinedPenShapeAspectXY)\nimport Data.Hoodle.Select\n  ( gSelect2GHoodle,\n    gselAll,\n    gselSelected,\n  )\nimport Data.Hoodle.Simple (Dimension (..), Stroke (..))\nimport Data.Hoodle.Zipper (currIndex)\nimport qualified Data.IntMap as M\nimport Data.Kind (Type)\nimport Data.Maybe (mapMaybe)\nimport Data.Sequence (Seq (..), ViewL (..), viewl)\nimport Graphics.Hoodle.Render\n  ( Xform4Page (..),\n    scalex,\n    scaley,\n    transx,\n    transy,\n  )\nimport Graphics.Hoodle.Render.Generic\n  ( StrokeBBoxOption (DrawFull),\n    cairoRenderOption,\n  )\nimport Graphics.Hoodle.Render.Highlight\n  ( renderRItemHltd,\n    renderStrkHltd,\n  )\nimport Graphics.Hoodle.Render.Type\n  ( CanvasId,\n    InBBox (..),\n    InBBoxBkgBuf (..),\n    InBBoxOption (..),\n    RBkgOpt (RBkgDrawPDF),\n    RItem,\n    RenderCache,\n    hPage2RPage,\n    selectedLayer,\n  )\nimport Graphics.Hoodle.Render.Type.HitTest\n  ( Hitted (..),\n    TEitherAlterHitted (..),\n    getB,\n  )\nimport Graphics.Hoodle.Render.Util (clipBBox)\nimport qualified Graphics.Rendering.Cairo as Cairo\nimport qualified Graphics.UI.Gtk as Gtk\nimport Hoodle.Type.Alias (EditMode (..), Hoodle, Page, SelectMode (..))\nimport Hoodle.Type.Canvas\n  ( CanvasInfo,\n    ViewInfo,\n    canvasId,\n    canvasWidgets,\n    currentPageNum,\n    drawArea,\n    mDrawSurface,\n    notifiedItem,\n    pageArrangement,\n    viewInfo,\n  )\nimport Hoodle.Type.Enum\n  ( DrawFlag (BkgEfficient, Clear, Efficient),\n    PenColor (..),\n    convertPenColorToRGBA,\n  )\nimport Hoodle.Type.PageArrangement\n  ( CanvasCoordinate (..),\n    CanvasDimension (..),\n    DesktopCoordinate (..),\n    PageCoordinate (..),\n    PageNum (..),\n    ViewMode (ContinuousPage, SinglePage),\n    ViewPortBBox (..),\n  )\nimport Hoodle.Type.Predefined\n  ( predefinedLassoColor,\n    predefinedLassoDash,\n    predefinedLassoHandleSize,\n    predefinedLassoWidth,\n  )\nimport Hoodle.Type.Widget\n  ( ClockWidgetConfig,\n    ScrollWidgetConfig,\n    WidgetItem\n      ( ClockWidget,\n        LayerWidget,\n        PanZoomWidget,\n        ScrollWidget\n      ),\n    allWidgets,\n    clockWidgetConfig,\n    clockWidgetPosition,\n    clockWidgetTime,\n    doesUseClockWidget,\n    doesUseLayerWidget,\n    doesUsePanZoomWidget,\n    doesUseScrollWidget,\n    layerWidgetConfig,\n    layerWidgetPosition,\n    layerWidgetShowContent,\n    panZoomWidgetConfig,\n    panZoomWidgetPosition,\n    panZoomWidgetTouchIsZoom,\n    scrollWidgetConfig,\n    widgetConfig,\n  )\nimport Hoodle.Util (uncurry4)\nimport Hoodle.View.Coordinate\n  ( CanvasGeometry\n      ( canvas2Desktop,\n        canvasDim,\n        desktop2Canvas,\n        page2Desktop\n      ),\n    getPagesInRange,\n    getPagesInViewPortRange,\n    makeCanvasGeometry,\n  )\n--\nimport Prelude hiding (concatMap, foldr, mapM_)\n\n-- |\ntype family DrawingFunction (v :: ViewMode) :: Type -> Type\n\n-- |\nnewtype SinglePageDraw a = SinglePageDraw\n  { unSinglePageDraw ::\n      RenderCache ->\n      CanvasId ->\n      -- isCurrentCanvas\n      Bool ->\n      (Gtk.DrawingArea, Maybe Cairo.Surface) ->\n      (PageNum, Page a) ->\n      ViewInfo \'SinglePage ->\n      Maybe BBox ->\n      DrawFlag ->\n      IO (Page a)\n  }\n\nnewtype ContPageDraw a = ContPageDraw\n  { unContPageDraw ::\n      RenderCache ->\n      -- isCurrentCanvas\n      Bool ->\n      CanvasInfo \'ContinuousPage ->\n      Maybe BBox ->\n      Hoodle a ->\n      DrawFlag ->\n      IO (Hoodle a)\n  }\n\n-- |\ntype instance DrawingFunction \'SinglePage = SinglePageDraw\n\n-- |\ntype instance DrawingFunction \'ContinuousPage = ContPageDraw\n\n-- |\ngetCanvasViewPort :: CanvasGeometry -> ViewPortBBox\ngetCanvasViewPort geometry =\n  let DeskCoord (x0, y0) = canvas2Desktop geometry (CvsCoord (0, 0))\n      CanvasDimension (Dim w h) = canvasDim geometry\n      DeskCoord (x1, y1) = canvas2Desktop geometry (CvsCoord (w, h))\n   in ViewPortBBox (BBox (x0, y0) (x1, y1))\n\n-- |\ngetBBoxInPageCoord :: CanvasGeometry -> PageNum -> BBox -> BBox\ngetBBoxInPageCoord geometry pnum bbox =\n  let DeskCoord (x0, y0) = page2Desktop geometry (pnum, PageCoord (0, 0))\n   in moveBBoxByOffset (-x0, -y0) bbox\n\n-- |\ngetViewableBBox ::\n  CanvasGeometry ->\n  -- | in desktop coordinate\n  Maybe BBox ->\n  IntersectBBox\ngetViewableBBox geometry mbbox =\n  let ViewPortBBox vportbbox = getCanvasViewPort geometry\n   in (fromMaybe mbbox :: IntersectBBox) `mappend` Intersect (Middle vportbbox)\n\n-- | double buffering within two image surfaces\nvirtualDoubleBufferDraw ::\n  (MonadIO m) =>\n  Cairo.Surface -> -- source surface\n  Cairo.Surface -> -- target surface\n  Cairo.Render () -> -- pre-render before source paint\n  Cairo.Render () -> -- post-render after source paint\n  m ()\nvirtualDoubleBufferDraw srcsfc tgtsfc pre post =\n  Cairo.renderWith tgtsfc $ do\n    pre\n    Cairo.setSourceSurface srcsfc 0 0\n    Cairo.setOperator Cairo.OperatorSource\n    Cairo.paint\n    Cairo.setOperator Cairo.OperatorOver\n    post\n\n-- |\ndoubleBufferFlush :: Cairo.Surface -> CanvasInfo a -> IO ()\ndoubleBufferFlush sfc cinfo = do\n  let canvas = view drawArea cinfo\n  Just win <- Gtk.widgetGetWindow canvas\n  Gtk.renderWithDrawWindow win $ do\n    Cairo.setSourceSurface sfc 0 0\n    Cairo.setOperator Cairo.OperatorSource\n    Cairo.paint\n\n-- | common routine for double buffering\ndoubleBufferDraw ::\n  (Gtk.DrawWindow, Maybe Cairo.Surface) ->\n  CanvasGeometry ->\n  Cairo.Render a ->\n  IntersectBBox ->\n  IO (Maybe a)\ndoubleBufferDraw (win, msfc) geometry rndr (Intersect ibbox) = do\n  let Dim cw ch = unCanvasDimension . canvasDim $ geometry\n      mbbox\' = case ibbox of\n        Top -> Just (BBox (0, 0) (cw, ch))\n        Middle bbox -> Just (xformBBox (unCvsCoord . desktop2Canvas geometry . DeskCoord) bbox)\n        Bottom -> Nothing\n  let action = do\n        case msfc of\n          Nothing -> do\n            Gtk.renderWithDrawWindow win $ do\n              clipBBox mbbox\'\n              Cairo.setSourceRGBA 0.5 0.5 0.5 1\n              Cairo.rectangle 0 0 cw ch\n              Cairo.fill\n              rndr\n          Just sfc -> do\n            r <- Cairo.renderWith sfc $ do\n              clipBBox mbbox\'\n              Cairo.setSourceRGBA 0.5 0.5 0.5 1\n              Cairo.rectangle 0 0 cw ch\n              Cairo.fill\n              clipBBox mbbox\'\n              rndr\n            Gtk.renderWithDrawWindow win $ do\n              Cairo.setSourceSurface sfc 0 0\n              Cairo.setOperator Cairo.OperatorSource\n              Cairo.paint\n            return r\n  case ibbox of\n    Top -> Just <$> action\n    Middle _ -> Just <$> action\n    Bottom -> return Nothing\n\n-- |\nmkXform4Page :: CanvasGeometry -> PageNum -> Xform4Page\nmkXform4Page geometry pnum =\n  let CvsCoord (x0, y0) = desktop2Canvas geometry . page2Desktop geometry $ (pnum, PageCoord (0, 0))\n      CvsCoord (x1, y1) = desktop2Canvas geometry . page2Desktop geometry $ (pnum, PageCoord (1, 1))\n      sx = x1 - x0\n      sy = y1 - y0\n   in Xform4Page x0 y0 sx sy\n\n-- |\ncairoXform4PageCoordinate :: Xform4Page -> Cairo.Render ()\ncairoXform4PageCoordinate xform = do\n  Cairo.translate (transx xform) (transy xform)\n  Cairo.scale (scalex xform) (scaley xform)\n\n-- |\ndata PressureMode = NoPressure | Pressure\n\n-- |\ndrawCurvebitGen ::\n  PressureMode ->\n  Gtk.DrawingArea ->\n  CanvasGeometry ->\n  Double ->\n  (Double, Double, Double, Double) ->\n  PageNum ->\n  Seq (Double, Double, Double) ->\n  ((Double, Double), Double) ->\n  ((Double, Double), Double) ->\n  IO ()\ndrawCurvebitGen pmode canvas geometry wdth (r, g, b, a) pnum pdraw ((x0, y0), z0) ((x, y), z) = do\n  Just win <- Gtk.widgetGetWindow canvas\n  Gtk.renderWithDrawWindow win $ do\n    cairoXform4PageCoordinate (mkXform4Page geometry pnum)\n    Cairo.setSourceRGBA r g b a\n    case pmode of\n      NoPressure -> do\n        Cairo.setLineWidth wdth\n        case viewl pdraw of\n          EmptyL -> return ()\n          (xo, yo, _) :< rest -> do\n            Cairo.moveTo xo yo\n            mapM_ (\\(x\', y\', _) -> Cairo.lineTo x\' y\') rest\n            Cairo.lineTo x y\n            Cairo.stroke\n      Pressure -> do\n        let wx0 = 0.5 * fst predefinedPenShapeAspectXY * wdth * z0\n            wy0 = 0.5 * snd predefinedPenShapeAspectXY * wdth * z0\n            wx = 0.5 * fst predefinedPenShapeAspectXY * wdth * z\n            wy = 0.5 * snd predefinedPenShapeAspectXY * wdth * z\n        Cairo.moveTo (x0 - wx0) (y0 - wy0)\n        Cairo.lineTo (x0 + wx0) (y0 + wy0)\n        Cairo.lineTo (x + wx) (y + wy)\n        Cairo.lineTo (x - wx) (y - wy)\n        Cairo.fill\n\n-- |\ndrawFuncGen ::\n  em ->\n  ( RenderCache ->\n    CanvasId ->\n    (PageNum, Page em) ->\n    Maybe BBox ->\n    DrawFlag ->\n    Cairo.Render (Page em)\n  ) ->\n  DrawingFunction \'SinglePage em\ndrawFuncGen _typ render = SinglePageDraw func\n  where\n    func cache cid isCurrentCvs (canvas, msfc) (pnum, page) vinfo mbbox flag =\n      do\n        let arr = view pageArrangement vinfo\n        geometry <- makeCanvasGeometry pnum arr canvas\n        Just win <- Gtk.widgetGetWindow canvas\n        let ibboxnew = getViewableBBox geometry mbbox\n        let mbboxnew = toMaybe ibboxnew\n            xformfunc = cairoXform4PageCoordinate (mkXform4Page geometry pnum)\n            renderfunc = do\n              xformfunc\n              pg <- render cache cid (pnum, page) mbboxnew flag\n              -- Start Widget\n              when isCurrentCvs (emphasisCanvasRender ColorBlue geometry)\n              -- End Widget\n              Cairo.resetClip\n              return pg\n        doubleBufferDraw (win, msfc) geometry renderfunc ibboxnew\n        >>= maybe (return page) return\n\n-- |\ndrawFuncSelGen ::\n  ( RenderCache ->\n    CanvasId ->\n    (PageNum, Page SelectMode) ->\n    Maybe BBox ->\n    DrawFlag ->\n    Cairo.Render ()\n  ) ->\n  ( RenderCache ->\n    CanvasId ->\n    (PageNum, Page SelectMode) ->\n    Maybe BBox ->\n    DrawFlag ->\n    Cairo.Render ()\n  ) ->\n  DrawingFunction \'SinglePage SelectMode\ndrawFuncSelGen rencont rensel = drawFuncGen SelectMode (\\c i x y f -> rencont c i x y f >> rensel c i x y f >> return (snd x))\n\n-- |\nemphasisCanvasRender :: PenColor -> CanvasGeometry -> Cairo.Render ()\nemphasisCanvasRender pcolor geometry = do\n  Cairo.save\n  Cairo.identityMatrix\n  let CanvasDimension (Dim cw ch) = canvasDim geometry\n  let (r, g, b, a) = convertPenColorToRGBA pcolor\n  Cairo.setSourceRGBA r g b a\n  Cairo.setLineWidth 2\n  Cairo.rectangle 0 0 cw ch\n  Cairo.stroke\n  Cairo.restore\n\n-- | highlight current page\nemphasisPageRender :: CanvasGeometry -> (PageNum, Page EditMode) -> Cairo.Render ()\nemphasisPageRender geometry (pn, pg) = do\n  Cairo.save\n  Cairo.identityMatrix\n  cairoXform4PageCoordinate (mkXform4Page geometry pn)\n  let Dim w h = view gdimension pg\n  Cairo.setSourceRGBA 0 0 1.0 1\n  Cairo.setLineWidth 2\n  Cairo.rectangle 0 0 w h\n  Cairo.stroke\n  Cairo.restore\n\n-- | highlight notified item (like link)\nemphasisNotifiedRender :: CanvasGeometry -> (PageNum, BBox, RItem) -> Cairo.Render ()\nemphasisNotifiedRender geometry (pn, BBox (x1, y1) (x2, y2), _) = do\n  Cairo.save\n  Cairo.identityMatrix\n  cairoXform4PageCoordinate (mkXform4Page geometry pn)\n  Cairo.setSourceRGBA 1.0 1.0 0 0.1\n  Cairo.rectangle x1 y1 (x2 - x1) (y2 - y1)\n  Cairo.fill\n  Cairo.restore\n\n-- |\ndrawContPageGen ::\n  ( RenderCache ->\n    CanvasId ->\n    (PageNum, Page EditMode) ->\n    Maybe BBox ->\n    DrawFlag ->\n    Cairo.Render (Int, Page EditMode)\n  ) ->\n  DrawingFunction \'ContinuousPage EditMode\ndrawContPageGen render = ContPageDraw func\n  where\n    func ::\n      RenderCache ->\n      Bool ->\n      CanvasInfo \'ContinuousPage ->\n      Maybe BBox ->\n      Hoodle EditMode ->\n      DrawFlag ->\n      IO (Hoodle EditMode)\n    func cache isCurrentCvs cinfo mbbox hdl flag =\n      do\n        let cid = view canvasId cinfo\n            arr = view (viewInfo . pageArrangement) cinfo\n            pnum = PageNum . view currentPageNum $ cinfo\n            canvas = view drawArea cinfo\n            msfc = view mDrawSurface cinfo\n        geometry <- makeCanvasGeometry pnum arr canvas\n        let pgs = view gpages hdl\n            mcpg = view (at (unPageNum pnum)) pgs\n        let drawpgs = mapMaybe f (getPagesInViewPortRange geometry hdl)\n              where\n                f k =\n                  maybe Nothing (\\a -> Just (k, a))\n                    . M.lookup (unPageNum k)\n                    $ pgs\n        Just win <- Gtk.widgetGetWindow canvas\n        let ibboxnew = getViewableBBox geometry mbbox\n        let mbboxnew = toMaybe ibboxnew\n            xformfunc = cairoXform4PageCoordinate (mkXform4Page geometry pnum)\n            onepagerender (pn, pg) = do\n              Cairo.identityMatrix\n              cairoXform4PageCoordinate (mkXform4Page geometry pn)\n              let pgmbbox = fmap (getBBoxInPageCoord geometry pn) mbboxnew\n              render cache cid (pn, pg) pgmbbox flag\n            renderfunc = do\n              xformfunc\n              ndrawpgs <- mapM onepagerender drawpgs\n              let npgs = foldr rfunc pgs ndrawpgs\n                    where\n                      rfunc (k, pg) = M.adjust (const pg) k\n              let nhdl = set gpages npgs hdl\n              mapM_ (\\cpg -> emphasisPageRender geometry (pnum, cpg)) mcpg\n              mapM_ (emphasisNotifiedRender geometry) (view notifiedItem cinfo)\n              when isCurrentCvs (emphasisCanvasRender ColorRed geometry)\n              let mbbox_canvas = fmap (xformBBox (unCvsCoord . desktop2Canvas geometry . DeskCoord)) mbboxnew\n              drawWidgets allWidgets hdl cinfo mbbox_canvas\n              Cairo.resetClip\n              return nhdl\n        doubleBufferDraw (win, msfc) geometry renderfunc ibboxnew\n        >>= maybe (return hdl) return\n\n-- |\ndrawContPageSelGen ::\n  ( RenderCache ->\n    CanvasId ->\n    (PageNum, Page EditMode) ->\n    Maybe BBox ->\n    DrawFlag ->\n    Cairo.Render (Int, Page EditMode)\n  ) ->\n  ( RenderCache ->\n    CanvasId ->\n    (PageNum, Page SelectMode) ->\n    Maybe BBox ->\n    DrawFlag ->\n    Cairo.Render (Int, Page SelectMode)\n  ) ->\n  DrawingFunction \'ContinuousPage SelectMode\ndrawContPageSelGen rendergen rendersel = ContPageDraw func\n  where\n    func ::\n      RenderCache ->\n      Bool ->\n      CanvasInfo \'ContinuousPage ->\n      Maybe BBox ->\n      Hoodle SelectMode ->\n      DrawFlag ->\n      IO (Hoodle SelectMode)\n    func cache isCurrentCvs cinfo mbbox thdl flag =\n      do\n        let cid = view canvasId cinfo\n            arr = view (viewInfo . pageArrangement) cinfo\n            pnum = PageNum . view currentPageNum $ cinfo\n            mtpage = view gselSelected thdl\n            canvas = view drawArea cinfo\n            msfc = view mDrawSurface cinfo\n            pgs = view gselAll thdl\n            mcpg = view (at (unPageNum pnum)) pgs\n            hdl = gSelect2GHoodle thdl\n        geometry <- makeCanvasGeometry pnum arr canvas\n        let drawpgs = mapMaybe f (getPagesInViewPortRange geometry hdl)\n              where\n                f k =\n                  maybe Nothing (\\a -> Just (k, a))\n                    . M.lookup (unPageNum k)\n                    $ pgs\n        Just win <- Gtk.widgetGetWindow canvas\n        let ibboxnew = getViewableBBox geometry mbbox\n            mbboxnew = toMaybe ibboxnew\n            onepagerender (pn, pg) = do\n              Cairo.identityMatrix\n              let xform = mkXform4Page geometry pn\n              cairoXform4PageCoordinate xform\n              rendergen cache cid (pn, pg) (fmap (getBBoxInPageCoord geometry pn) mbboxnew) flag\n            selpagerender ::\n              (PageNum, Page SelectMode) ->\n              Cairo.Render (Int, Page SelectMode)\n            selpagerender (pn, pg) = do\n              Cairo.identityMatrix\n              let xform = mkXform4Page geometry pn\n              cairoXform4PageCoordinate xform\n              rendersel cache cid (pn, pg) (fmap (getBBoxInPageCoord geometry pn) mbboxnew) flag\n            renderfunc :: Cairo.Render (Hoodle SelectMode)\n            renderfunc = do\n              let xform = mkXform4Page geometry pnum\n              cairoXform4PageCoordinate xform\n              ndrawpgs <- mapM onepagerender drawpgs\n              let npgs = foldr rfunc pgs ndrawpgs\n                    where\n                      rfunc (k, pg) = M.adjust (const pg) k\n              let nthdl :: Hoodle SelectMode\n                  nthdl = set gselAll npgs thdl\n              r <- runMaybeT $ do\n                (n, tpage) <- MaybeT (return mtpage)\n                lift (selpagerender (PageNum n, tpage))\n              let nthdl2 = set gselSelected r nthdl\n              maybe (return ()) (\\cpg -> emphasisPageRender geometry (pnum, cpg)) mcpg\n              mapM_ (emphasisNotifiedRender geometry) (view notifiedItem cinfo)\n              when isCurrentCvs (emphasisCanvasRender ColorGreen geometry)\n              let mbbox_canvas = fmap (xformBBox (unCvsCoord . desktop2Canvas geometry . DeskCoord)) mbboxnew\n              drawWidgets allWidgets hdl cinfo mbbox_canvas\n              Cairo.resetClip\n              return nthdl2\n        doubleBufferDraw (win, msfc) geometry renderfunc ibboxnew\n        >>= maybe (return thdl) return\n\n-- |\ndrawSinglePage :: CanvasGeometry -> DrawingFunction \'SinglePage EditMode\ndrawSinglePage geometry = drawFuncGen EditMode f\n  where\n    f cache cid (pnum, page) mbbox flag = do\n      let xform = mkXform4Page geometry pnum\n      case flag of\n        Clear -> do\n          (pg\', _) <- cairoRenderOption (RBkgDrawPDF, DrawFull) cache cid (page, Just xform)\n          return pg\'\n        BkgEfficient -> do\n          (InBBoxBkgBuf pg\', _) <- cairoRenderOption (InBBoxOption mbbox) cache cid (InBBoxBkgBuf page, Just xform)\n          return pg\'\n        Efficient -> do\n          (InBBox pg\', _) <- cairoRenderOption (InBBoxOption mbbox) cache cid (InBBox page, Just xform)\n          return pg\'\n\n-- |\ndrawSinglePageSel :: CanvasGeometry -> DrawingFunction \'SinglePage SelectMode\ndrawSinglePageSel geometry = drawFuncSelGen rendercontent renderselect\n  where\n    rendercontent cache cid (pnum, tpg) mbbox flag = do\n      let pg\' = hPage2RPage tpg\n          xform = mkXform4Page geometry pnum\n      case flag of\n        Clear -> void $ cairoRenderOption (RBkgDrawPDF, DrawFull) cache cid (pg\', Just xform)\n        BkgEfficient -> void $ cairoRenderOption (InBBoxOption mbbox) cache cid (InBBoxBkgBuf pg\', Just xform)\n        Efficient -> void $ cairoRenderOption (InBBoxOption mbbox) cache cid (InBBox pg\', Just xform)\n    renderselect _cache _cid (_pnum, tpg) mbbox _flag = do\n      cairoHittedBoxDraw geometry tpg mbbox\n      return ()\n\n-- |\ndrawContHoodle :: CanvasGeometry -> DrawingFunction \'ContinuousPage EditMode\ndrawContHoodle geometry = drawContPageGen f\n  where\n    f cache cid (pnum@(PageNum n), page) mbbox flag = do\n      let xform = mkXform4Page geometry pnum\n      case flag of\n        Clear -> do\n          (p\', _) <- cairoRenderOption (RBkgDrawPDF, DrawFull) cache cid (page, Just xform)\n          return (n, p\')\n        BkgEfficient -> do\n          (p\', _) <- cairoRenderOption (InBBoxOption mbbox) cache cid (InBBoxBkgBuf page, Just xform)\n          return (n, unInBBoxBkgBuf p\')\n        Efficient -> do\n          (p\', _) <- cairoRenderOption (InBBoxOption mbbox) cache cid (InBBox page, Just xform)\n          return (n, unInBBox p\')\n\n-- |\ndrawContHoodleSel ::\n  CanvasGeometry ->\n  DrawingFunction \'ContinuousPage SelectMode\ndrawContHoodleSel geometry = drawContPageSelGen renderother renderselect\n  where\n    renderother cache cid (pnum@(PageNum n), page) mbbox flag = do\n      let xform = mkXform4Page geometry pnum\n      case flag of\n        Clear -> (,) n . fst <$> cairoRenderOption (RBkgDrawPDF, DrawFull) cache cid (page, Just xform)\n        BkgEfficient -> (,) n . unInBBoxBkgBuf . fst <$> cairoRenderOption (InBBoxOption mbbox) cache cid (InBBoxBkgBuf page, Just xform)\n        Efficient -> (,) n . unInBBox . fst <$> cairoRenderOption (InBBoxOption mbbox) cache cid (InBBox page, Just xform)\n    renderselect _cache _cid (PageNum n, tpg) mbbox _flag = do\n      cairoHittedBoxDraw geometry tpg mbbox\n      return (n, tpg)\n\n-- |\ncairoHittedBoxDraw ::\n  CanvasGeometry ->\n  Page SelectMode ->\n  Maybe BBox ->\n  Cairo.Render ()\ncairoHittedBoxDraw geometry tpg mbbox = do\n  let layers = view glayers tpg\n      slayer = view selectedLayer layers\n  case unTEitherAlterHitted . view gitems $ slayer of\n    Right alist -> do\n      clipBBox mbbox\n      Cairo.setSourceRGBA 0.0 0.0 1.0 1.0\n      let hititms = concatMap unHitted (getB alist)\n      mapM_ renderSelectedItem hititms\n      let ulbbox =\n            unUnion . mconcat . fmap (Union . Middle . getBBox) $\n              hititms\n      case ulbbox of\n        Middle bbox -> renderSelectHandle geometry bbox\n        _ -> return ()\n      Cairo.resetClip\n    Left _ -> return ()\n\n-- |\nrenderLasso :: CanvasGeometry -> Seq (Double, Double) -> Cairo.Render ()\nrenderLasso geometry lst = do\n  let z = canvas2DesktopRatio geometry\n  Cairo.setLineWidth (predefinedLassoWidth * z)\n  uncurry4 Cairo.setSourceRGBA predefinedLassoColor\n  let (dasha, dashb) = predefinedLassoDash\n      adjusteddash = (fmap (* z) dasha, dashb * z)\n  uncurry Cairo.setDash adjusteddash\n  case viewl lst of\n    EmptyL -> return ()\n    x :< xs -> do\n      uncurry Cairo.moveTo x\n      mapM_ (uncurry Cairo.lineTo) xs\n      Cairo.stroke\n\n-- |\nrenderBoxSelection :: BBox -> Cairo.Render ()\nrenderBoxSelection bbox = do\n  Cairo.setLineWidth predefinedLassoWidth\n  uncurry4 Cairo.setSourceRGBA predefinedLassoColor\n  uncurry Cairo.setDash predefinedLassoDash\n  let (x1, y1) = bbox_upperleft bbox\n      (x2, y2) = bbox_lowerright bbox\n  Cairo.rectangle x1 y1 (x2 - x1) (y2 - y1)\n  Cairo.stroke\n\n-- |\nrenderSelectedStroke :: BBoxed Stroke -> Cairo.Render ()\nrenderSelectedStroke str = do\n  Cairo.setLineWidth 1.5\n  Cairo.setSourceRGBA 0 0 1 1\n  renderStrkHltd str\n\n-- |\nrenderSelectedItem :: RItem -> Cairo.Render ()\nrenderSelectedItem itm = do\n  Cairo.setLineWidth 1.5\n  Cairo.setSourceRGBA 0 0 1 1\n  renderRItemHltd itm\n\n-- |\ncanvas2DesktopRatio :: CanvasGeometry -> Double\ncanvas2DesktopRatio geometry =\n  let DeskCoord (tx1, _) = canvas2Desktop geometry (CvsCoord (0, 0))\n      DeskCoord (tx2, _) = canvas2Desktop geometry (CvsCoord (1, 0))\n   in tx2 - tx1\n\n-- |\nrenderSelectHandle :: CanvasGeometry -> BBox -> Cairo.Render ()\nrenderSelectHandle geometry bbox = do\n  let z = canvas2DesktopRatio geometry\n  Cairo.setLineWidth (predefinedLassoWidth * z)\n  uncurry4 Cairo.setSourceRGBA predefinedLassoColor\n  let (dasha, dashb) = predefinedLassoDash\n      adjusteddash = (fmap (* z) dasha, dashb * z)\n  uncurry Cairo.setDash adjusteddash\n  let (x1, y1) = bbox_upperleft bbox\n      (x2, y2) = bbox_lowerright bbox\n      hsize = predefinedLassoHandleSize * z\n  Cairo.rectangle x1 y1 (x2 - x1) (y2 - y1)\n  Cairo.stroke\n  Cairo.setSourceRGBA 1 0 0 0.8\n  Cairo.rectangle (x1 - hsize) (y1 - hsize) (2 * hsize) (2 * hsize)\n  Cairo.fill\n  Cairo.setSourceRGBA 1 0 0 0.8\n  Cairo.rectangle (x1 - hsize) (y2 - hsize) (2 * hsize) (2 * hsize)\n  Cairo.fill\n  Cairo.setSourceRGBA 1 0 0 0.8\n  Cairo.rectangle (x2 - hsize) (y1 - hsize) (2 * hsize) (2 * hsize)\n  Cairo.fill\n  Cairo.setSourceRGBA 1 0 0 0.8\n  Cairo.rectangle (x2 - hsize) (y2 - hsize) (2 * hsize) (2 * hsize)\n  Cairo.fill\n  Cairo.setSourceRGBA 0.5 0 0.2 0.8\n  Cairo.rectangle (x1 - hsize * 0.6) (0.5 * (y1 + y2) - hsize * 0.6) (1.2 * hsize) (1.2 * hsize)\n  Cairo.fill\n  Cairo.setSourceRGBA 0.5 0 0.2 0.8\n  Cairo.rectangle (x2 - hsize * 0.6) (0.5 * (y1 + y2) - hsize * 0.6) (1.2 * hsize) (1.2 * hsize)\n  Cairo.fill\n  Cairo.setSourceRGBA 0.5 0 0.2 0.8\n  Cairo.rectangle (0.5 * (x1 + x2) - hsize * 0.6) (y1 - hsize * 0.6) (1.2 * hsize) (1.2 * hsize)\n  Cairo.fill\n  Cairo.setSourceRGBA 0.5 0 0.2 0.8\n  Cairo.rectangle (0.5 * (x1 + x2) - hsize * 0.6) (y2 - hsize * 0.6) (1.2 * hsize) (1.2 * hsize)\n  Cairo.fill\n\n-- |\ncanvasImageSurface ::\n  RenderCache ->\n  CanvasId ->\n  -- | multiply\n  Maybe Double ->\n  CanvasGeometry ->\n  Hoodle EditMode ->\n  IO (Cairo.Surface, Dimension)\ncanvasImageSurface cache cid mmulti geometry hdl = do\n  let ViewPortBBox bbx_desk = getCanvasViewPort geometry\n      nbbx_desk = case mmulti of\n        Nothing -> bbx_desk\n        Just z ->\n          let (x0, y0) = bbox_upperleft bbx_desk\n              (x1, y1) = bbox_lowerright bbx_desk\n              Dim ws_desk hs_desk = bboxToDim bbx_desk\n           in BBox (x0 - z * ws_desk, y0 - z * hs_desk) (x1 + z * ws_desk, y1 + z * hs_desk)\n      nbbx_cvs =\n        xformBBox (unCvsCoord . desktop2Canvas geometry . DeskCoord) nbbx_desk\n      nvport = ViewPortBBox nbbx_desk\n      Dim w_cvs h_cvs = bboxToDim nbbx_cvs\n  let pgs = view gpages hdl\n      drawpgs = (mapMaybe f . getPagesInRange geometry nvport) hdl\n        where\n          f k = maybe Nothing (\\a -> Just (k, a)) . M.lookup (unPageNum k) $ pgs\n      onepagerender (pn, pg) = do\n        Cairo.identityMatrix\n        case mmulti of\n          Nothing -> return ()\n          Just z -> do\n            let (ws_cvs, hs_cvs) = (w_cvs / (2 * z + 1), h_cvs / (2 * z + 1))\n            Cairo.translate (z * ws_cvs) (z * hs_cvs)\n        let xform = mkXform4Page geometry pn\n        cairoXform4PageCoordinate xform\n        cairoRenderOption (InBBoxOption Nothing) cache cid (InBBox pg, Nothing :: Maybe Xform4Page)\n      renderfunc = do\n        Cairo.setSourceRGBA 0.5 0.5 0.5 1\n        Cairo.rectangle 0 0 w_cvs h_cvs\n        Cairo.fill\n        mapM_ onepagerender drawpgs\n  print (Prelude.length drawpgs)\n  sfc <- Cairo.createImageSurface Cairo.FormatARGB32 (floor w_cvs) (floor h_cvs)\n  Cairo.renderWith sfc renderfunc\n  return (sfc, Dim w_cvs h_cvs)\n\n---------------------------------------------------\n--                Widgets                        --\n---------------------------------------------------\n\n-- |\ndrawWidgets ::\n  [WidgetItem] ->\n  Hoodle EditMode ->\n  CanvasInfo a ->\n  Maybe BBox ->\n  Cairo.Render ()\ndrawWidgets witms hdl cinfo mbbox = do\n  when (PanZoomWidget `elem` witms && view (canvasWidgets . widgetConfig . doesUsePanZoomWidget) cinfo) $\n    renderPanZoomWidget\n      (view (canvasWidgets . panZoomWidgetConfig . panZoomWidgetTouchIsZoom) cinfo)\n      mbbox\n      (view (canvasWidgets . panZoomWidgetConfig . panZoomWidgetPosition) cinfo)\n  when\n    (LayerWidget `elem` witms && view (canvasWidgets . widgetConfig . doesUseLayerWidget) cinfo)\n    (drawLayerWidget hdl cinfo mbbox (view (canvasWidgets . layerWidgetConfig . layerWidgetPosition) cinfo))\n\n  when (ClockWidget `elem` witms && view (canvasWidgets . widgetConfig . doesUseClockWidget) cinfo) $\n    renderClockWidget mbbox (view (canvasWidgets . clockWidgetConfig) cinfo)\n\n  when (ScrollWidget `elem` witms && view (canvasWidgets . widgetConfig . doesUseScrollWidget) cinfo) $\n    renderScrollWidget mbbox (view (canvasWidgets . scrollWidgetConfig) cinfo)\n\n---------------------\n-- Pan Zoom Widget --\n---------------------\n\n-- |\nrenderPanZoomWidget :: Bool -> Maybe BBox -> CanvasCoordinate -> Cairo.Render ()\nrenderPanZoomWidget b mbbox (CvsCoord (x, y)) = do\n  Cairo.identityMatrix\n  clipBBox mbbox\n  Cairo.setSourceRGBA 0.5 0.5 0.2 0.3\n  Cairo.rectangle x y 100 100\n  Cairo.fill\n  Cairo.setSourceRGBA 0.2 0.2 0.7 0.5\n  Cairo.rectangle (x + 10) (y + 10) 40 80\n  Cairo.fill\n  Cairo.setSourceRGBA 0.2 0.7 0.2 0.5\n  Cairo.rectangle (x + 50) (y + 10) 40 80\n  Cairo.fill\n  Cairo.setSourceRGBA 0.7 0.2 0.2 (if b then 1.0 else 0.5)\n  Cairo.rectangle (x + 30) (y + 30) 40 40\n  Cairo.fill\n  Cairo.setSourceRGBA 0.5 0.5 0.5 0.5\n  Cairo.rectangle x y 10 10\n  Cairo.fill\n  Cairo.setSourceRGBA 0 0 0 0.7\n  Cairo.setLineWidth 1\n  Cairo.moveTo x y\n  Cairo.lineTo (x + 10) (y + 10)\n  Cairo.stroke\n  Cairo.moveTo x (y + 10)\n  Cairo.lineTo (x + 10) y\n  Cairo.stroke\n  Cairo.resetClip\n\n------------------\n-- Layer Widget --\n------------------\n\ndrawLayerWidget ::\n  Hoodle EditMode ->\n  CanvasInfo a ->\n  Maybe BBox ->\n  CanvasCoordinate ->\n  Cairo.Render ()\ndrawLayerWidget hdl cinfo mbbox cvscoord = do\n  let cpn = view currentPageNum cinfo\n      lc = view (canvasWidgets . layerWidgetConfig) cinfo\n  void $\n    runMaybeT $ do\n      pg <- MaybeT . return $ view (gpages . at cpn) hdl\n      let lyrs = view glayers pg\n          n = currIndex lyrs\n      lift $ renderLayerWidget (show n) mbbox cvscoord\n      when (view layerWidgetShowContent lc) $ do\n        liftIO $ putStrLn "drawLayerWidget: not implemented"\n\nrenderLayerContent ::\n  Maybe BBox ->\n  Dimension ->\n  Cairo.Surface ->\n  CanvasCoordinate ->\n  Cairo.Render ()\nrenderLayerContent mbbox (Dim w h) sfc (CvsCoord (x, y)) = do\n  Cairo.identityMatrix\n  clipBBox mbbox\n  let sx = 200 / w\n  Cairo.rectangle (x + 100) y 200 (h * 200 / w)\n  Cairo.setLineWidth 0.5\n  Cairo.setSourceRGBA 0 0 0 1\n  Cairo.stroke\n  Cairo.translate (x + 100) y\n  Cairo.scale sx sx\n  Cairo.setSourceSurface sfc 0 0\n  Cairo.paint\n\n-- |\nrenderLayerWidget :: String -> Maybe BBox -> CanvasCoordinate -> Cairo.Render ()\nrenderLayerWidget str mbbox (CvsCoord (x, y)) = do\n  Cairo.identityMatrix\n  clipBBox mbbox\n  Cairo.setSourceRGBA 0.5 0.5 0.2 0.3\n  Cairo.rectangle x y 100 100\n  Cairo.fill\n  Cairo.rectangle x y 10 10\n  Cairo.fill\n  Cairo.setSourceRGBA 0 0 0 0.7\n  Cairo.setLineWidth 1\n  Cairo.moveTo x y\n  Cairo.lineTo (x + 10) (y + 10)\n  Cairo.stroke\n  Cairo.moveTo x (y + 10)\n  Cairo.lineTo (x + 10) y\n  Cairo.stroke\n  -- upper right\n  Cairo.setSourceRGBA 0 0 0 0.4\n  Cairo.moveTo (x + 80) y\n  Cairo.lineTo (x + 100) y\n  Cairo.lineTo (x + 100) (y + 20)\n  Cairo.fill\n  -- lower left\n  Cairo.setSourceRGBA 0 0 0 0.1\n  Cairo.moveTo x (y + 80)\n  Cairo.lineTo x (y + 100)\n  Cairo.lineTo (x + 20) (y + 100)\n  Cairo.fill\n  -- middle right\n  Cairo.setSourceRGBA 0 0 0 0.3\n  Cairo.moveTo (x + 90) (y + 40)\n  Cairo.lineTo (x + 100) (y + 50)\n  Cairo.lineTo (x + 90) (y + 60)\n  Cairo.fill\n  --\n  Cairo.identityMatrix\n  l1 <- Gtk.createLayout "layer"\n  Gtk.updateLayout l1\n  (_, reclog) <- liftIO $ Gtk.layoutGetExtents l1\n  let Gtk.PangoRectangle _ _ w1 h1 = reclog\n  Cairo.moveTo (x + 15) y\n  let sx1 = 50 / w1\n      sy1 = 20 / h1\n  Cairo.scale sx1 sy1\n  Gtk.layoutPath l1\n  Cairo.setSourceRGBA 0 0 0 0.4\n  Cairo.fill\n  --\n  Cairo.identityMatrix\n  l <- Gtk.createLayout str\n  Gtk.updateLayout l\n  (_, reclog2) <- liftIO $ Gtk.layoutGetExtents l\n  let Gtk.PangoRectangle _ _ w h = reclog2\n  Cairo.moveTo (x + 30) (y + 20)\n  let sx = 40 / w\n      sy = 60 / h\n  Cairo.scale sx sy\n  Gtk.layoutPath l\n  Cairo.setSourceRGBA 0 0 0 0.4\n  Cairo.fill\n\n------------------\n-- Clock Widget --\n------------------\n\nrenderClockWidget :: Maybe BBox -> ClockWidgetConfig -> Cairo.Render ()\nrenderClockWidget mbbox cfg = do\n  let CvsCoord (x, y) = view clockWidgetPosition cfg\n      (h, m, s) = view clockWidgetTime cfg\n      div2rad :: Int -> Int -> Double\n      div2rad n theta = fromIntegral theta / fromIntegral n * 2.0 * pi\n  Cairo.identityMatrix\n  clipBBox mbbox\n  Cairo.setSourceRGBA 0.5 0.5 0.2 0.3\n  Cairo.arc x y 50 0.0 (2.0 * pi)\n  Cairo.fill\n  --\n  Cairo.setSourceRGBA 1 0 0 0.7\n  Cairo.setLineWidth 0.5\n  Cairo.moveTo x y\n  Cairo.lineTo (x + 45 * sin (div2rad 60 s)) (y - 45 * cos (div2rad 60 s))\n  Cairo.stroke\n  --\n  Cairo.setSourceRGBA 0 0 0 1\n  Cairo.setLineWidth 1.0\n  Cairo.moveTo x y\n  Cairo.lineTo (x + 50 * sin (div2rad 60 m)) (y - 50 * cos (div2rad 60 m))\n  Cairo.stroke\n  --\n  Cairo.setSourceRGBA 0 0 0 1\n  Cairo.setLineWidth 2.0\n  Cairo.moveTo x y\n  Cairo.lineTo\n    (x + 30 * sin (div2rad 12 h + div2rad 720 m))\n    (y - 30 * cos (div2rad 12 h + div2rad 720 m))\n  Cairo.stroke\n  --\n  Cairo.resetClip\n\n------------------\n-- Clock Widget --\n------------------\n\nrenderScrollWidget :: Maybe BBox -> ScrollWidgetConfig -> Cairo.Render ()\nrenderScrollWidget mbbox _cfg = do\n  Cairo.identityMatrix\n  clipBBox mbbox\n  Cairo.setSourceRGBA 0.5 0.5 0.2 0.3\n  Cairo.moveTo 100 0\n  Cairo.lineTo 0 50\n  Cairo.lineTo 200 50\n  Cairo.fill\n  --\n  Cairo.resetClip\n'