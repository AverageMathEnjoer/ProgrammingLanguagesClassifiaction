b'package com.db.williamchart.renderer\n\nimport com.db.williamchart.ChartContract\nimport com.db.williamchart.animation.ChartAnimation\nimport com.db.williamchart.data.configuration.DonutChartConfiguration\nimport com.db.williamchart.data.DonutDataPoint\nimport com.db.williamchart.data.Frame\nimport com.db.williamchart.extensions.toDonutDataPoint\n\nclass DonutChartRenderer(\n    val view: ChartContract.DonutView,\n    private var animation: ChartAnimation<DonutDataPoint>\n) : ChartContract.DonutRenderer {\n\n    private var innerFrameWithStroke: Frame = Frame(0f, 0f, 0f, 0f)\n\n    private var datapoints = emptyList<DonutDataPoint>()\n\n    private lateinit var chartConfiguration: DonutChartConfiguration\n\n    override fun preDraw(configuration: DonutChartConfiguration): Boolean {\n\n        chartConfiguration = configuration\n\n        if (chartConfiguration.colorsSize < datapoints.size)\n            throw IllegalArgumentException(\n                "Number of datapoints is ${datapoints.size} " +\n                    "but only ${chartConfiguration.colorsSize} color(s) provided."\n            )\n\n        val left =\n            configuration.paddings.left + configuration.thickness / 2\n        val top =\n            configuration.paddings.top + configuration.thickness / 2\n        val right =\n            configuration.width - configuration.paddings.right - configuration.thickness / 2\n        val bottom =\n            configuration.height - configuration.paddings.bottom - configuration.thickness / 2\n        innerFrameWithStroke = Frame(left, top, right, bottom)\n\n        datapoints.forEach { it.screenDegrees = it.value * fullDegrees / chartConfiguration.total }\n        datapoints = datapoints.sortedByDescending { it.screenDegrees }\n\n        animation.animateFrom(ignoreStartPosition, datapoints) {\n            view.postInvalidate()\n        }\n\n        return true\n    }\n\n    override fun draw() {\n\n        if (chartConfiguration.barBackgroundColor != 0)\n            view.drawBackground(innerFrameWithStroke)\n\n        view.drawArc(datapoints.map { it.screenDegrees }, innerFrameWithStroke)\n    }\n\n    override fun render(values: List<Float>) {\n        val valuesOffset = values.generateValuesOffset()\n        datapoints = values.mapIndexed { index, value ->\n            value.toDonutDataPoint(valuesOffset[index])\n        }\n        view.postInvalidate()\n    }\n\n    override fun anim(values: List<Float>, animation: ChartAnimation<DonutDataPoint>) {\n        val valuesOffset = values.generateValuesOffset()\n        datapoints = values.mapIndexed { index, value ->\n            value.toDonutDataPoint(valuesOffset[index])\n        }\n        this.animation = animation\n        view.postInvalidate()\n    }\n\n    private fun List<Float>.generateValuesOffset(): List<Float> {\n        val valuesOffset: MutableList<Float> = mutableListOf()\n        this.forEachIndexed { index, _ ->\n            val offset = if (index == 0) 0f else valuesOffset[index - 1] + this[index - 1]\n            valuesOffset.add(index, offset)\n        }\n        return valuesOffset.toList()\n    }\n\n    companion object {\n        private const val fullDegrees = 360\n        private const val ignoreStartPosition = -1234f\n    }\n}\n'