b'// Copyright (c) 2022 Manuel Schneider\n\n#include "albert/extensions/queryhandler.h"\n#include "extensions/globalqueryhandlerprivate.h"\n#include "extensions/indexqueryhandlerprivate.h"\n#include "albert/logging.h"\n#include "itemindex.h"\n#include "query.h"\n#include "queryengine.h"\n#include "usagedatabase.h"\n#include <QCoreApplication>\n#include <QSettings>\n#include <QTimer>\n#include <cmath>\nusing namespace albert;\nusing namespace std;\nstatic const char *CFG_MEMORY_DECAY = "memoryDecay";\nstatic const double DEF_MEMORY_DECAY = 0.5;\nstatic const char *CFG_PRIO_PERFECT = "prioritize_perfect_match";\nstatic const bool DEF_PRIO_PERFECT = true;\nstatic const char *CFG_TRIGGER = "trigger";\nstatic const char *CFG_TRIGGER_ENABLED = "trigger_enabled";\nstatic const uint DEF_ERROR_TOLERANCE_DIVISOR = 4;\nstatic const char* CFG_FUZZY = "fuzzy";\nstatic const bool  DEF_FUZZY = false;\nstatic const char* CFG_SEPARATORS = "separators";\nstatic const char* DEF_SEPARATORS = R"R([\\s\\\\\\/\\-\\[\\](){}#!?<>"\'=+*.:,;_]+)R";\nstatic const uint GRAM_SIZE = 2;\n\nQueryEngine::QueryEngine(ExtensionRegistry &registry):\n    ExtensionWatcher<TriggerQueryHandler>(registry),\n    ExtensionWatcher<GlobalQueryHandler>(registry),\n    ExtensionWatcher<IndexQueryHandler>(registry),\n    ExtensionWatcher<FallbackHandler>(registry)\n{\n    UsageDatabase::initializeDatabase();\n\n    QSettings s(qApp->applicationName());\n    fuzzy_ = s.value(CFG_FUZZY, DEF_FUZZY).toBool();\n    separators_ = s.value(CFG_SEPARATORS, DEF_SEPARATORS).toString();\n    memory_decay_ = s.value(CFG_MEMORY_DECAY, DEF_MEMORY_DECAY).toDouble();\n    prioritize_perfect_match_ = s.value(CFG_PRIO_PERFECT, DEF_PRIO_PERFECT).toBool();\n\n    updateUsageScore();\n    GlobalQueryHandlerPrivate::setPrioritizePerfectMatch(prioritize_perfect_match_);\n\n    for (auto &[id, handler] : registry.extensions<QueryHandler>()) {\n        trigger_query_handlers_.insert(handler);\n        HandlerConfig config{\n                handler->settings()->value(CFG_TRIGGER, handler->defaultTrigger()).toString(),\n                handler->settings()->value(CFG_TRIGGER_ENABLED, true).toBool()\n        };\n        query_handler_configs_.emplace(handler, config);\n    }\n    updateActiveTriggers();\n}\n\nshared_ptr<albert::Query> QueryEngine::query(const QString &query_string)\n{\n    shared_ptr<::Query> query;\n\n    for (const auto &[trigger, handler] : active_triggers_)\n        if (query_string.startsWith(trigger))\n            query = make_shared<::Query>(fallback_handlers_, handler, query_string.mid(trigger.size()), trigger);\n\n    if (!query)\n        query = make_shared<::Query>(fallback_handlers_, &global_search_handler, query_string);\n\n    auto onActivate = [this, q=query->string()](const QString& e, const QString &i, const QString &a){\n        UsageDatabase::addActivation(q, e, i, a);\n        QTimer::singleShot(0, [this](){ updateUsageScore(); });\n    };\n\n    QObject::connect(&query->matches_, &ItemsModel::activated, onActivate);\n    QObject::connect(&query->fallbacks_, &ItemsModel::activated, onActivate);  // TODO differentiate\n\n    return query;\n}\n\nvoid QueryEngine::updateActiveTriggers()\n{\n    active_triggers_.clear();\n    for (const auto &[handler, config]: query_handler_configs_)\n        if (config.enabled)\n            if (const auto &[it, success] = active_triggers_.emplace(config.trigger, handler); !success)\n                WARN << QString("Trigger conflict \'%1\': Already reserved for %2.").arg(config.trigger, it->second->id());\n}\n\nvoid QueryEngine::onAdd(TriggerQueryHandler *handler)\n{\n    trigger_query_handlers_.insert(handler);\n    HandlerConfig conf {\n        handler->settings()->value(CFG_TRIGGER, handler->defaultTrigger()).toString(),\n        handler->settings()->value(CFG_TRIGGER_ENABLED, true).toBool()\n    };\n    query_handler_configs_.emplace(handler, conf);\n    updateActiveTriggers();\n}\n\nvoid QueryEngine::onRem(TriggerQueryHandler *handler)\n{\n    trigger_query_handlers_.erase(handler);\n    query_handler_configs_.erase(handler);\n    updateActiveTriggers();\n}\n\nvoid QueryEngine::onAdd(GlobalQueryHandler *handler)\n{\n    global_search_handler.handlers.insert(handler->d.get());\n}\n\nvoid QueryEngine::onRem(GlobalQueryHandler *handler)\n{\n    global_search_handler.handlers.erase(handler->d.get());\n}\n\nvoid QueryEngine::onAdd(IndexQueryHandler *handler)\n{\n    index_query_handlers_.insert(handler);\n    handler->d->setIndex(make_unique<ItemIndex>(separators_, false, GRAM_SIZE, fuzzy_?DEF_ERROR_TOLERANCE_DIVISOR:0));\n}\n\nvoid QueryEngine::onRem(IndexQueryHandler *handler)\n{\n    index_query_handlers_.erase(handler);\n}\n\nvoid QueryEngine::onAdd(FallbackHandler *handler)\n{\n    fallback_handlers_.insert(handler);\n}\n\nvoid QueryEngine::onRem(FallbackHandler *handler)\n{\n    fallback_handlers_.erase(handler);\n}\n\nconst map<TriggerQueryHandler*,QueryEngine::HandlerConfig> &QueryEngine::handlerConfig() const\n{\n    return query_handler_configs_;\n}\n\nconst map<QString, TriggerQueryHandler *> &QueryEngine::activeTriggers() const\n{\n    return active_triggers_;\n}\n\nvoid QueryEngine::setEnabled(TriggerQueryHandler *handler, bool enabled)\n{\n    query_handler_configs_.at(handler).enabled = enabled;\n    updateActiveTriggers();\n    handler->settings()->setValue(CFG_TRIGGER_ENABLED, enabled);\n}\n\nvoid QueryEngine::setTrigger(TriggerQueryHandler *handler, const QString& trigger)\n{\n    if (!handler->allowTriggerRemap())\n        return;\n\n    query_handler_configs_.at(handler).trigger = trigger;\n    updateActiveTriggers();\n    handler->settings()->setValue(CFG_TRIGGER, trigger);\n}\n\nvoid QueryEngine::updateUsageScore() const\n{\n    vector<Activation> activations = UsageDatabase::activations();\n\n    // Compute usage weights\n    map<pair<QString,QString>,double> usage_weights;\n    for (int i = 0, k = (int)activations.size(); i < (int)activations.size(); ++i, --k){\n        auto activation = activations[i];\n        auto weight = pow(memory_decay_, k);\n        if (const auto &[it, success] =\n            usage_weights.emplace(make_pair(activation.extension_id, activation.item_id), weight);\n            !success)\n            it->second += weight;\n    }\n\n    // Invert the list. Results in ordered by rank map\n    map<double,vector<pair<QString,QString>>> weight_items;\n    for (const auto &[ids, weight] : usage_weights)\n        weight_items[weight].emplace_back(ids);\n\n    // Distribute scores linearly over the interval preserving the order\n    map<pair<QString,QString>,RankItem::Score> usage_scores;\n    double rank = 0.0;\n    for (const auto &[weight, vids] : weight_items){\n        RankItem::Score score = rank / (double)weight_items.size() * RankItem::MAX_SCORE;\n        for (const auto &ids : vids)\n            usage_scores.emplace(ids, score);\n        rank += 1.0;\n    }\n\n    GlobalQueryHandlerPrivate::setScores(usage_scores);\n}\n\ndouble QueryEngine::memoryDecay() const\n{\n    return memory_decay_;\n}\n\n// @param forgetfulness: must be in range [0.5,1] i.e. from [MRU,MFU]\nvoid QueryEngine::setMemoryDecay(double val)\n{\n    memory_decay_ = val;\n    QSettings(qApp->applicationName()).setValue(CFG_MEMORY_DECAY, val);\n    updateUsageScore();\n}\n\nbool QueryEngine::prioritizePerfectMatch() const\n{\n    return prioritize_perfect_match_;\n}\n\nvoid QueryEngine::setPrioritizePerfectMatch(bool val)\n{\n    prioritize_perfect_match_ = val;\n    QSettings(qApp->applicationName()).setValue(CFG_PRIO_PERFECT, val);\n    GlobalQueryHandlerPrivate::setPrioritizePerfectMatch(prioritize_perfect_match_);\n}\n\n\nbool QueryEngine::fuzzy() const\n{\n    return fuzzy_;\n}\n\nvoid QueryEngine::setFuzzy(bool fuzzy)\n{\n    fuzzy_ = fuzzy;\n    QSettings(qApp->applicationName()).setValue(CFG_FUZZY, fuzzy);\n    for (auto &iqh : index_query_handlers_)\n        iqh->d->setIndex(make_unique<ItemIndex>(separators_, false, GRAM_SIZE, fuzzy_ ? DEF_ERROR_TOLERANCE_DIVISOR : 0));\n}\n\nconst QString &QueryEngine::separators() const\n{\n    return separators_;\n}\n\nvoid QueryEngine::setSeparators(const QString &separators)\n{\n    separators_ = separators;\n    QSettings(qApp->applicationName()).setValue(CFG_SEPARATORS, separators);\n    for (auto &iqh : index_query_handlers_)\n        iqh->d->setIndex(make_unique<ItemIndex>(separators_, false, GRAM_SIZE, fuzzy_ ? DEF_ERROR_TOLERANCE_DIVISOR : 0));\n}\n'