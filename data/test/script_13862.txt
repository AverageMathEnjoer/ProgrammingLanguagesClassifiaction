b'#define SQLITE_OS_WIN\n\nusing System;\nusing System.ComponentModel;\nusing System.Diagnostics;\nusing System.IO;\nusing System.Runtime.InteropServices;\nusing System.Text;\nusing System.Threading;\n\nusing HANDLE = System.IntPtr;\nusing DWORD = System.UInt64;\nusing WORD = System.Int32;\nusing i64 = System.Int64;\nusing u8 = System.Byte;\nusing u32 = System.UInt32;\n\nusing sqlite3_int64 = System.Int64;\n\nnamespace CS_SQLite3\n{\n  internal static class HelperMethods\n  {\n    public static bool IsRunningMediumTrust()\n    {\n      // placeholder method\n      // this is where it needs to check if it\'s running in an ASP.Net MediumTrust or lower environment\n      // in order to pick the appropriate locking strategy\n      return false;\n    }\n  }\n\n  public partial class CSSQLite\n  {\n    /// <summary>\n    /// Basic locking strategy for Console/Winform applications\n    /// </summary>\n    private class LockingStrategy\n    {\n      [DllImport( "kernel32.dll" )]\n      static extern bool LockFileEx( IntPtr hFile, uint dwFlags, uint dwReserved,\n      uint nNumberOfBytesToLockLow, uint nNumberOfBytesToLockHigh,\n      [In] ref System.Threading.NativeOverlapped lpOverlapped );\n\n      const int LOCKFILE_FAIL_IMMEDIATELY = 1;\n\n      public virtual void LockFile( sqlite3_file pFile, long offset, long length )\n      {\n        pFile.fs.Lock( offset, length );\n      }\n\n      public virtual int SharedLockFile( sqlite3_file pFile, long offset, long length )\n      {\n        Debug.Assert( length == SHARED_SIZE );\n        Debug.Assert( offset == SHARED_FIRST );\n        System.Threading.NativeOverlapped ovlp = new System.Threading.NativeOverlapped();\n        ovlp.OffsetLow = (int)offset;\n        ovlp.OffsetHigh = 0;\n        ovlp.EventHandle = IntPtr.Zero;\n\n        return LockFileEx( pFile.fs.Handle, LOCKFILE_FAIL_IMMEDIATELY, 0, (uint)length, 0, ref ovlp ) ? 1 : 0;\n      }\n\n      public virtual void UnlockFile( sqlite3_file pFile, long offset, long length )\n      {\n        pFile.fs.Unlock( offset, length );\n      }\n    }\n\n    /// <summary>\n    /// Locking strategy for Medium Trust. It uses the same trick used in the native code for WIN_CE\n    /// which doesn\'t support LockFileEx as well.\n    /// </summary>\n    private class MediumTrustLockingStrategy : LockingStrategy\n    {\n      public override int SharedLockFile( sqlite3_file pFile, long offset, long length )\n      {\n        Debug.Assert( length == SHARED_SIZE );\n        Debug.Assert( offset == SHARED_FIRST );\n        try\n        {\n          pFile.fs.Lock( offset + pFile.sharedLockByte, 1 );\n        }\n        catch ( IOException )\n        {\n          return 0;\n        }\n        return 1;\n      }\n    }\n\n\n\n    /*\n    ** 2004 May 22\n    **\n    ** The author disclaims copyright to this source code.  In place of\n    ** a legal notice, here is a blessing:\n    **\n    **    May you do good and not evil.\n    **    May you find forgiveness for yourself and forgive others.\n    **    May you share freely, never taking more than you give.\n    **\n    ******************************************************************************\n    **\n    ** This file contains code that is specific to windows.\n    **\n    ** $Id: os_win.c,v 1.157 2009/08/05 04:08:30 shane Exp $\n    **\n    *************************************************************************\n    **  Included in SQLite3 port to C#-SQLite;  2008 Noah B Hart\n    **  C#-SQLite is an independent reimplementation of the SQLite software library\n    **\n    **  $Header$\n    *************************************************************************\n    */\n    //#include "sqliteInt.h"\n#if SQLITE_OS_WIN               // * This file is used for windows only */\n\n\n    /*\n** A Note About Memory Allocation:\n**\n** This driver uses malloc()/free() directly rather than going through\n** the SQLite-wrappers sqlite3Malloc()///sqlite3DbFree(db,ref  ).  Those wrappers\n** are designed for use on embedded systems where memory is scarce and\n** malloc failures happen frequently.  Win32 does not typically run on\n** embedded systems, and when it does the developers normally have bigger\n** problems to worry about than running out of memory.  So there is not\n** a compelling need to use the wrappers.\n**\n** But there is a good reason to not use the wrappers.  If we use the\n** wrappers then we will get simulated malloc() failures within this\n** driver.  And that causes all kinds of problems for our tests.  We\n** could enhance SQLite to deal with simulated malloc failures within\n** the OS driver, but the code to deal with those failure would not\n** be exercised on Linux (which does not need to malloc() in the driver)\n** and so we would have difficulty writing coverage tests for that\n** code.  Better to leave the code out, we think.\n**\n** The point of this discussion is as follows:  When creating a new\n** OS layer for an embedded system, if you use this file as an example,\n** avoid the use of malloc()/free().  Those routines work ok on windows\n** desktops but not so well in embedded systems.\n*/\n\n    //#include <winbase.h>\n\n#if __CYGWIN__\n//# include <sys/cygwin.h>\n#endif\n\n    /*\n** Macros used to determine whether or not to use threads.\n*/\n#if THREADSAFE\n//# define SQLITE_W32_THREADS 1\n#endif\n\n    /*\n** Include code that is common to all os_*.c files\n*/\n    //#include "os_common.h"\n\n    /*\n    ** Some microsoft compilers lack this definition.\n    */\n#if !INVALID_FILE_ATTRIBUTES\n    //# define INVALID_FILE_ATTRIBUTES ((DWORD)-1)\n    const int INVALID_FILE_ATTRIBUTES = -1;\n#endif\n\n    /*\n** Determine if we are dealing with WindowsCE - which has a much\n** reduced API.\n*/\n#if SQLITE_OS_WINCE\n//# define AreFileApisANSI() 1\n//# define GetDiskFreeSpaceW() 0\n#endif\n\n    /*\n** WinCE lacks native support for file locking so we have to fake it\n** with some code of our own.\n*/\n#if SQLITE_OS_WINCE\ntypedef struct winceLock {\nint nReaders;       /* Number of reader locks obtained */\nBOOL bPending;      /* Indicates a pending lock has been obtained */\nBOOL bReserved;     /* Indicates a reserved lock has been obtained */\nBOOL bExclusive;    /* Indicates an exclusive lock has been obtained */\n} winceLock;\n#endif\n\n    private static LockingStrategy lockingStrategy = HelperMethods.IsRunningMediumTrust() ? new MediumTrustLockingStrategy() : new LockingStrategy();\n\n    /*\n    ** The winFile structure is a subclass of sqlite3_file* specific to the win32\n    ** portability layer.\n    */\n    //typedef struct sqlite3_file sqlite3_file;\n    public partial class sqlite3_file\n    {\n      public FileStream fs;          /* Filestream access to this file*/\n      // public HANDLE h;            /* Handle for accessing the file */\n      public int locktype;           /* Type of lock currently held on this file */\n      public int sharedLockByte;     /* Randomly chosen byte used as a shared lock */\n      public DWORD lastErrno;        /* The Windows errno from the last I/O error */\n      public DWORD sectorSize;       /* Sector size of the device file is on */\n#if SQLITE_OS_WINCE\nWCHAR *zDeleteOnClose;  /* Name of file to delete when closing */\nHANDLE hMutex;          /* Mutex used to control access to shared lock */\nHANDLE hShared;         /* Shared memory segment used for locking */\nwinceLock local;        /* Locks obtained by this instance of sqlite3_file */\nwinceLock *shared;      /* Global shared lock memory for the file  */\n#endif\n\n      public void Clear()\n      {\n        pMethods = null;\n        fs = null;\n        locktype = 0;\n        sharedLockByte = 0;\n        lastErrno = 0;\n        sectorSize = 0;\n      }\n    };\n\n    /*\n    ** Forward prototypes.\n    */\n    //static int getSectorSize(\n    //    sqlite3_vfs *pVfs,\n    //    const char *zRelative     /* UTF-8 file name */\n    //);\n\n    /*\n    ** The following variable is (normally) set once and never changes\n    ** thereafter.  It records whether the operating system is Win95\n    ** or WinNT.\n    **\n    ** 0:   Operating system unknown.\n    ** 1:   Operating system is Win95.\n    ** 2:   Operating system is WinNT.\n    **\n    ** In order to facilitate testing on a WinNT system, the test fixture\n    ** can manually set this value to 1 to emulate Win98 behavior.\n    */\n#if SQLITE_TEST\n    int sqlite3_os_type = 0;\n#else\nstatic int sqlite3_os_type = 0;\n#endif\n\n    /*\n** Return true (non-zero) if we are running under WinNT, Win2K, WinXP,\n** or WinCE.  Return false (zero) for Win95, Win98, or WinME.\n**\n** Here is an interesting observation:  Win95, Win98, and WinME lack\n** the LockFileEx() API.  But we can still statically link against that\n** API as long as we don\'t call it when running Win95/98/ME.  A call to\n** this routine is used to determine if the host is Win95/98/ME or\n** WinNT/2K/XP so that we will know whether or not we can safely call\n** the LockFileEx() API.\n*/\n#if SQLITE_OS_WINCE\n//# define isNT()  (1)\n#else\n    static bool isNT()\n    {\n      //if (sqlite3_os_type == 0)\n      //{\n      //  OSVERSIONINFO sInfo;\n      //  sInfo.dwOSVersionInfoSize = sInfo.Length;\n      //  GetVersionEx(&sInfo);\n      //  sqlite3_os_type = sInfo.dwPlatformId == VER_PLATFORM_WIN32_NT ? 2 : 1;\n      //}\n      //return sqlite3_os_type == 2;\n      return Environment.OSVersion.Platform >= PlatformID.Win32NT;\n    }\n#endif // * SQLITE_OS_WINCE */\n\n    /*\n** Convert a UTF-8 string to microsoft unicode (UTF-16?).\n**\n** Space to hold the returned string is obtained from malloc.\n*/\n    //static WCHAR *utf8ToUnicode(string zFilename){\n    //  int nChar;\n    //  WCHAR *zWideFilename;\n\n    //  nChar = MultiByteToWideChar(CP_UTF8, 0, zFilename, -1, NULL, 0);\n    //  zWideFilename = malloc( nChar*sizeof(zWideFilename[0]) );\n    //  if( zWideFilename==0 ){\n    //    return 0;\n    //  }\n    //  nChar = MultiByteToWideChar(CP_UTF8, 0, zFilename, -1, zWideFilename, nChar);\n    //  if( nChar==0 ){\n    //    free(zWideFilename);\n    //    zWideFileName = "";\n    //  }\n    //  return zWideFilename;\n    //}\n\n    /*\n    ** Convert microsoft unicode to UTF-8.  Space to hold the returned string is\n    ** obtained from malloc().\n    */\n    //static char *unicodeToUtf8(const WCHAR *zWideFilename){\n    //  int nByte;\n    //  char *zFilename;\n\n    //  nByte = WideCharToMultiByte(CP_UTF8, 0, zWideFilename, -1, 0, 0, 0, 0);\n    //  zFilename = malloc( nByte );\n    //  if( zFilename==0 ){\n    //    return 0;\n    //  }\n    //  nByte = WideCharToMultiByte(CP_UTF8, 0, zWideFilename, -1, zFilename, nByte,\n    //                              0, 0);\n    //  if( nByte == 0 ){\n    //    free(zFilename);\n    //    zFileName = "";\n    //  }\n    //  return zFilename;\n    //}\n\n    /*\n    ** Convert an ansi string to microsoft unicode, based on the\n    ** current codepage settings for file apis.\n    **\n    ** Space to hold the returned string is obtained\n    ** from malloc.\n    */\n    //static WCHAR *mbcsToUnicode(string zFilename){\n    //  int nByte;\n    //  WCHAR *zMbcsFilename;\n    //  int codepage = AreFileApisANSI() ? CP_ACP : CP_OEMCP;\n\n    //  nByte = MultiByteToWideChar(codepage, 0, zFilename, -1, NULL,0)*WCHAR.Length;\n    //  zMbcsFilename = malloc( nByte*sizeof(zMbcsFilename[0]) );\n    //  if( zMbcsFilename==0 ){\n    //    return 0;\n    //  }\n    //  nByte = MultiByteToWideChar(codepage, 0, zFilename, -1, zMbcsFilename, nByte);\n    //  if( nByte==0 ){\n    //    free(zMbcsFilename);\n    //    zMbcsFileName = "";\n    //  }\n    //  return zMbcsFilename;\n    //}\n\n    /*\n    ** Convert microsoft unicode to multibyte character string, based on the\n    ** user\'s Ansi codepage.\n    **\n    ** Space to hold the returned string is obtained from\n    ** malloc().\n    */\n    //static char *unicodeToMbcs(const WCHAR *zWideFilename){\n    //  int nByte;\n    //  char *zFilename;\n    //  int codepage = AreFileApisANSI() ? CP_ACP : CP_OEMCP;\n\n    //  nByte = WideCharToMultiByte(codepage, 0, zWideFilename, -1, 0, 0, 0, 0);\n    //  zFilename = malloc( nByte );\n    //  if( zFilename==0 ){\n    //    return 0;\n    //  }\n    //  nByte = WideCharToMultiByte(codepage, 0, zWideFilename, -1, zFilename, nByte,\n    //                              0, 0);\n    //  if( nByte == 0 ){\n    //    free(zFilename);\n    //    zFileName = "";\n    //  }\n    //  return zFilename;\n    //}\n\n    /*\n    ** Convert multibyte character string to UTF-8.  Space to hold the\n    ** returned string is obtained from malloc().\n    */\n    //static char *sqlite3_win32_mbcs_to_utf8(string zFilename){\n    //  char *zFilenameUtf8;\n    //  WCHAR *zTmpWide;\n\n    //  zTmpWide = mbcsToUnicode(zFilename);\n    //  if( zTmpWide==0 ){\n    //    return 0;\n    //  }\n    //  zFilenameUtf8 = unicodeToUtf8(zTmpWide);\n    //  free(zTmpWide);\n    //  return zFilenameUtf8;\n    //}\n\n    /*\n    ** Convert UTF-8 to multibyte character string.  Space to hold the\n    ** returned string is obtained from malloc().\n    */\n    //static char *utf8ToMbcs(string zFilename){\n    //  char *zFilenameMbcs;\n    //  WCHAR *zTmpWide;\n\n    //  zTmpWide = utf8ToUnicode(zFilename);\n    //  if( zTmpWide==0 ){\n    //    return 0;\n    //  }\n    //  zFilenameMbcs = unicodeToMbcs(zTmpWide);\n    //  free(zTmpWide);\n    //  return zFilenameMbcs;\n    //}\n\n#if SQLITE_OS_WINCE\n/*************************************************************************\n** This section contains code for WinCE only.\n*/\n/*\n** WindowsCE does not have a localtime() function.  So create a\n** substitute.\n*/\n//#include <time.h>\nstruct tm *__cdecl localtime(const time_t *t)\n{\nstatic struct tm y;\nFILETIME uTm, lTm;\nSYSTEMTIME pTm;\nsqlite3_int64 t64;\nt64 = *t;\nt64 = (t64 + 11644473600)*10000000;\nuTm.dwLowDateTime = t64 & 0xFFFFFFFF;\nuTm.dwHighDateTime= t64 >> 32;\nFileTimeToLocalFileTime(&uTm,&lTm);\nFileTimeToSystemTime(&lTm,&pTm);\ny.tm_year = pTm.wYear - 1900;\ny.tm_mon = pTm.wMonth - 1;\ny.tm_wday = pTm.wDayOfWeek;\ny.tm_mday = pTm.wDay;\ny.tm_hour = pTm.wHour;\ny.tm_min = pTm.wMinute;\ny.tm_sec = pTm.wSecond;\nreturn &y;\n}\n\n/* This will never be called, but defined to make the code compile */\n//#define GetTempPathA(a,b)\n\n//#define LockFile(a,b,c,d,e)       winceLockFile(&a, b, c, d, e)\n//#define UnlockFile(a,b,c,d,e)     winceUnlockFile(&a, b, c, d, e)\n//#define LockFileEx(a,b,c,d,e,f)   winceLockFileEx(&a, b, c, d, e, f)\n\n//#define HANDLE_TO_WINFILE(a) (sqlite3_file*)&((char*)a)[-offsetof(sqlite3_file,h)]\n\n/*\n** Acquire a lock on the handle h\n*/\nstatic void winceMutexAcquire(HANDLE h){\nDWORD dwErr;\ndo {\ndwErr = WaitForSingleObject(h, INFINITE);\n} while (dwErr != WAIT_OBJECT_0 && dwErr != WAIT_ABANDONED);\n}\n/*\n** Release a lock acquired by winceMutexAcquire()\n*/\n//#define winceMutexRelease(h) ReleaseMutex(h)\n\n/*\n** Create the mutex and shared memory used for locking in the file\n** descriptor pFile\n*/\nstatic BOOL winceCreateLock(string zFilename, sqlite3_file pFile){\nWCHAR *zTok;\nWCHAR *zName = utf8ToUnicode(zFilename);\nBOOL bInit = TRUE;\n\n/* Initialize the local lockdata */\nZeroMemory(pFile.local, pFile.local).Length;\n\n/* Replace the backslashes from the filename and lowercase it\n** to derive a mutex name. */\nzTok = CharLowerW(zName);\nfor (;*zTok;zTok++){\nif (*zTok == \'\\\\\') *zTok = \'_\';\n}\n\n/* Create/open the named mutex */\npFile.hMutex = CreateMutexW(NULL, FALSE, zName);\nif (!pFile.hMutex){\npFile->lastErrno = (u32)GetLastError();\nfree(zName);\nreturn FALSE;\n}\n\n/* Acquire the mutex before continuing */\nwinceMutexAcquire(pFile.hMutex);\n\n/* Since the names of named mutexes, semaphores, file mappings etc are\n** case-sensitive, take advantage of that by uppercasing the mutex name\n** and using that as the shared filemapping name.\n*/\nCharUpperW(zName);\npFile.hShared = CreateFileMappingW(INVALID_HANDLE_VALUE, NULL,\nPAGE_READWRITE, 0, winceLock.Length,\nzName);\n\n/* Set a flag that indicates we\'re the first to create the memory so it\n** must be zero-initialized */\nif (GetLastError() == ERROR_ALREADY_EXISTS){\nbInit = FALSE;\n}\n\nfree(zName);\n\n/* If we succeeded in making the shared memory handle, map it. */\nif (pFile.hShared){\npFile.shared = (winceLock*)MapViewOfFile(pFile.hShared,\nFILE_MAP_READ|FILE_MAP_WRITE, 0, 0, winceLock).Length;\n/* If mapping failed, close the shared memory handle and erase it */\nif (!pFile.shared){\npFile->lastErrno = (u32)GetLastError();\nCloseHandle(pFile.hShared);\npFile.hShared = NULL;\n}\n}\n\n/* If shared memory could not be created, then close the mutex and fail */\nif (pFile.hShared == NULL){\nwinceMutexRelease(pFile.hMutex);\nCloseHandle(pFile.hMutex);\npFile.hMutex = NULL;\nreturn FALSE;\n}\n\n/* Initialize the shared memory if we\'re supposed to */\nif (bInit) {\nZeroMemory(pFile.shared, winceLock).Length;\n}\n\nwinceMutexRelease(pFile.hMutex);\nreturn TRUE;\n}\n\n/*\n** Destroy the part of sqlite3_file that deals with wince locks\n*/\nstatic void winceDestroyLock(sqlite3_file pFile){\nif (pFile.hMutex){\n/* Acquire the mutex */\nwinceMutexAcquire(pFile.hMutex);\n\n/* The following blocks should probably Debug.Assert in debug mode, but they\nare to cleanup in case any locks remained open */\nif (pFile.local.nReaders){\npFile.shared.nReaders --;\n}\nif (pFile.local.bReserved){\npFile.shared.bReserved = FALSE;\n}\nif (pFile.local.bPending){\npFile.shared.bPending = FALSE;\n}\nif (pFile.local.bExclusive){\npFile.shared.bExclusive = FALSE;\n}\n\n/* De-reference and close our copy of the shared memory handle */\nUnmapViewOfFile(pFile.shared);\nCloseHandle(pFile.hShared);\n\n/* Done with the mutex */\nwinceMutexRelease(pFile.hMutex);\nCloseHandle(pFile.hMutex);\npFile.hMutex = NULL;\n}\n}\n\n/*\n** An implementation of the LockFile() API of windows for wince\n*/\nstatic BOOL winceLockFile(\nHANDLE phFile,\nDWORD dwFileOffsetLow,\nDWORD dwFileOffsetHigh,\nDWORD nNumberOfBytesToLockLow,\nDWORD nNumberOfBytesToLockHigh\n){\nsqlite3_file pFile = HANDLE_TO_WINFILE(phFile);\nBOOL bReturn = FALSE;\n\nif (!pFile.hMutex) return TRUE;\nwinceMutexAcquire(pFile.hMutex);\n\n/* Wanting an exclusive lock? */\nif (dwFileOffsetLow == SHARED_FIRST\n&& nNumberOfBytesToLockLow == SHARED_SIZE){\nif (pFile.shared.nReaders == 0 && pFile.shared.bExclusive == 0){\npFile.shared.bExclusive = TRUE;\npFile.local.bExclusive = TRUE;\nbReturn = TRUE;\n}\n}\n\n/* Want a read-only lock? */\nelse if (dwFileOffsetLow == SHARED_FIRST &&\nnNumberOfBytesToLockLow == 1){\nif (pFile.shared.bExclusive == 0){\npFile.local.nReaders ++;\nif (pFile.local.nReaders == 1){\npFile.shared.nReaders ++;\n}\nbReturn = TRUE;\n}\n}\n\n/* Want a pending lock? */\nelse if (dwFileOffsetLow == PENDING_BYTE && nNumberOfBytesToLockLow == 1){\n/* If no pending lock has been acquired, then acquire it */\nif (pFile.shared.bPending == 0) {\npFile.shared.bPending = TRUE;\npFile.local.bPending = TRUE;\nbReturn = TRUE;\n}\n}\n/* Want a reserved lock? */\nelse if (dwFileOffsetLow == RESERVED_BYTE && nNumberOfBytesToLockLow == 1){\nif (pFile.shared.bReserved == 0) {\npFile.shared.bReserved = TRUE;\npFile.local.bReserved = TRUE;\nbReturn = TRUE;\n}\n}\n\nwinceMutexRelease(pFile.hMutex);\nreturn bReturn;\n}\n\n/*\n** An implementation of the UnlockFile API of windows for wince\n*/\nstatic BOOL winceUnlockFile(\nHANDLE phFile,\nDWORD dwFileOffsetLow,\nDWORD dwFileOffsetHigh,\nDWORD nNumberOfBytesToUnlockLow,\nDWORD nNumberOfBytesToUnlockHigh\n){\nsqlite3_file pFile = HANDLE_TO_WINFILE(phFile);\nBOOL bReturn = FALSE;\n\nif (!pFile.hMutex) return TRUE;\nwinceMutexAcquire(pFile.hMutex);\n\n/* Releasing a reader lock or an exclusive lock */\nif (dwFileOffsetLow >= SHARED_FIRST &&\ndwFileOffsetLow < SHARED_FIRST + SHARED_SIZE){\n/* Did we have an exclusive lock? */\nif (pFile.local.bExclusive){\npFile.local.bExclusive = FALSE;\npFile.shared.bExclusive = FALSE;\nbReturn = TRUE;\n}\n\n/* Did we just have a reader lock? */\nelse if (pFile.local.nReaders){\npFile.local.nReaders --;\nif (pFile.local.nReaders == 0)\n{\npFile.shared.nReaders --;\n}\nbReturn = TRUE;\n}\n}\n\n/* Releasing a pending lock */\nelse if (dwFileOffsetLow == PENDING_BYTE && nNumberOfBytesToUnlockLow == 1){\nif (pFile.local.bPending){\npFile.local.bPending = FALSE;\npFile.shared.bPending = FALSE;\nbReturn = TRUE;\n}\n}\n/* Releasing a reserved lock */\nelse if (dwFileOffsetLow == RESERVED_BYTE && nNumberOfBytesToUnlockLow == 1){\nif (pFile.local.bReserved) {\npFile.local.bReserved = FALSE;\npFile.shared.bReserved = FALSE;\nbReturn = TRUE;\n}\n}\n\nwinceMutexRelease(pFile.hMutex);\nreturn bReturn;\n}\n\n/*\n** An implementation of the LockFileEx() API of windows for wince\n*/\nstatic BOOL winceLockFileEx(\nHANDLE phFile,\nDWORD dwFlags,\nDWORD dwReserved,\nDWORD nNumberOfBytesToLockLow,\nDWORD nNumberOfBytesToLockHigh,\nLPOVERLAPPED lpOverlapped\n){\n/* If the caller wants a shared read lock, forward this call\n** to winceLockFile */\nif (lpOverlapped.Offset == SHARED_FIRST &&\ndwFlags == 1 &&\nnNumberOfBytesToLockLow == SHARED_SIZE){\nreturn winceLockFile(phFile, SHARED_FIRST, 0, 1, 0);\n}\nreturn FALSE;\n}\n/*\n** End of the special code for wince\n*****************************************************************************/\n#endif // * SQLITE_OS_WINCE */\n\n    /*****************************************************************************\n** The next group of routines implement the I/O methods specified\n** by the sqlite3_io_methods object.\n******************************************************************************/\n\n    /*\n    ** Close a file.\n    **\n    ** It is reported that an attempt to close a handle might sometimes\n    ** fail.  This is a very unreasonable result, but windows is notorious\n    ** for being unreasonable so I do not doubt that it might happen.  If\n    ** the close fails, we pause for 100 milliseconds and try again.  As\n    ** many as MX_CLOSE_ATTEMPT attempts to close the handle are made before\n    ** giving up and returning an error.\n    */\n    public static int MX_CLOSE_ATTEMPT = 3;\n    static int winClose( sqlite3_file id )\n    {\n      bool rc;\n      int cnt = 0;\n      sqlite3_file pFile = (sqlite3_file)id;\n\n      Debug.Assert( id != null );\n#if SQLITE_DEBUG\n      OSTRACE3( "CLOSE %d (%s)\\n", pFile.fs.GetHashCode(), pFile.fs.Name );\n#endif\n      do\n      {\n        pFile.fs.Close();\n        rc = true;\n        //  rc = CloseHandle(pFile.h);\n        //  if (!rc && ++cnt < MX_CLOSE_ATTEMPT) Thread.Sleep(100); //, 1) );\n      } while ( !rc && ++cnt < MX_CLOSE_ATTEMPT ); //, 1) );\n#if SQLITE_OS_WINCE\n//#define WINCE_DELETION_ATTEMPTS 3\nwinceDestroyLock(pFile);\nif( pFile.zDeleteOnClose ){\nint cnt = 0;\nwhile(\nDeleteFileW(pFile.zDeleteOnClose)==0\n&& GetFileAttributesW(pFile.zDeleteOnClose)!=0xffffffff\n&& cnt++ < WINCE_DELETION_ATTEMPTS\n){\nSleep(100);  /* Wait a little before trying again */\n}\nfree(pFile.zDeleteOnClose);\n}\n#endif\n#if SQLITE_TEST\n      OpenCounter( -1 );\n#endif\n      return rc ? SQLITE_OK : SQLITE_IOERR;\n    }\n\n    /*\n    ** Some microsoft compilers lack this definition.\n    */\n#if !INVALID_SET_FILE_POINTER\n    const int INVALID_SET_FILE_POINTER = -1;\n#endif\n\n    /*\n** Read data from a file into a buffer.  Return SQLITE_OK if all\n** bytes were read successfully and SQLITE_IOERR if anything goes\n** wrong.\n*/\n    static int winRead(\n    sqlite3_file id,           /* File to read from */\n    byte[] pBuf,           /* Write content into this buffer */\n    int amt,                   /* Number of bytes to read */\n    sqlite3_int64 offset       /* Begin reading at this offset */\n    )\n    {\n\n      //LONG upperBits = (LONG)( ( offset >> 32 ) & 0x7fffffff );\n      //LONG lowerBits = (LONG)( offset & 0xffffffff );\n      long rc;\n      sqlite3_file pFile = id;\n      //DWORD error;\n      long got;\n\n      Debug.Assert( id != null );\n#if SQLITE_TEST\n      //SimulateIOError(return SQLITE_IOERR_READ);  TODO --  How to implement this?\n#endif\n#if SQLITE_DEBUG\n      OSTRACE3( "READ %d lock=%d\\n", pFile.fs.GetHashCode(), pFile.locktype );\n#endif\n      if ( !id.fs.CanRead ) return SQLITE_IOERR_READ;\n      try\n      {\n        rc = id.fs.Seek( offset, SeekOrigin.Begin ); // SetFilePointer(pFile.fs.Name, lowerBits, upperBits, FILE_BEGIN);\n      }\n      catch ( Exception e )      //            if( rc==INVALID_SET_FILE_POINTER && (error=GetLastError())!=NO_ERROR )\n      {\n        pFile.lastErrno = (u32)Marshal.GetLastWin32Error();\n        return SQLITE_FULL;\n      }\n\n      try\n      {\n        got = id.fs.Read( pBuf, 0, amt ); // if (!ReadFile(pFile.fs.Name, pBuf, amt, got, 0))\n      }\n      catch ( Exception e )\n      {\n        pFile.lastErrno = (u32)Marshal.GetLastWin32Error();\n        return SQLITE_IOERR_READ;\n      }\n      if ( got == amt )\n      {\n        return SQLITE_OK;\n      }\n      else\n      {\n        /* Unread parts of the buffer must be zero-filled */\n        Array.Clear( pBuf, (int)got, (int)( amt - got ) ); // memset(&((char*)pBuf)[got], 0, amt - got);\n        return SQLITE_IOERR_SHORT_READ;\n      }\n    }\n\n    /*\n    ** Write data from a buffer into a file.  Return SQLITE_OK on success\n    ** or some other error code on failure.\n    */\n    static int winWrite(\n    sqlite3_file id,          /* File to write into */\n    byte[] pBuf,              /* The bytes to be written */\n    int amt,                  /* Number of bytes to write */\n    sqlite3_int64 offset      /* Offset into the file to begin writing at */\n    )\n    {\n      //LONG upperBits = (LONG)( ( offset >> 32 ) & 0x7fffffff );\n      //LONG lowerBits = (LONG)( offset & 0xffffffff );\n      int rc;\n      //  sqlite3_file pFile = (sqlite3_file*)id;\n      //  DWORD error;\n      long wrote = 0;\n\n      Debug.Assert( id != null );\n#if SQLITE_TEST\n      if ( SimulateIOError() ) return SQLITE_IOERR_WRITE;\n      if ( SimulateDiskfullError() ) return SQLITE_FULL;\n#endif\n#if SQLITE_DEBUG\n      OSTRACE3( "WRITE %d lock=%d\\n", id.fs.GetHashCode(), id.locktype );\n#endif\n      //  rc = SetFilePointer(pFile.fs.Name, lowerBits, upperBits, FILE_BEGIN);\n      id.fs.Seek( offset, SeekOrigin.Begin );\n      //  if( rc==INVALID_SET_FILE_POINTER && GetLastError()!=NO_ERROR ){\n      //  pFile.lastErrno = (u32)GetLastError();\n      //    return SQLITE_FULL;\n      //  }\n      Debug.Assert( amt > 0 );\n      wrote = id.fs.Position;\n      try\n      {\n        Debug.Assert( pBuf.Length >= amt );\n        id.fs.Write( pBuf, 0, amt );\n        rc = 1;// Success\n        wrote = id.fs.Position - wrote;\n      }\n      catch ( IOException e )\n      {\n        return SQLITE_READONLY;\n      }\n      //  while(\n      //     amt>0\n      //     && (rc = WriteFile(pFile.fs.Name, pBuf, amt, wrote, 0))!=0\n      //     && wrote>0\n      //  ){\n      //    amt -= wrote;\n      //    pBuf = &((char*)pBuf)[wrote];\n      //  }\n      if ( rc == 0 || amt > (int)wrote )\n      {\n        id.lastErrno = (u32)Marshal.GetLastWin32Error();\n        return SQLITE_FULL;\n      }\n      return SQLITE_OK;\n    }\n\n    /*\n    ** Truncate an open file to a specified size\n    */\n    static int winTruncate( sqlite3_file id, sqlite3_int64 nByte )\n    {\n      //LONG upperBits = (LONG)( ( nByte >> 32 ) & 0x7fffffff );\n      //LONG lowerBits = (LONG)( nByte & 0xffffffff );\n      //DWORD rc;\n      //winFile* pFile = (winFile*)id;\n      //DWORD error;\n\n      Debug.Assert( id != null );\n#if SQLITE_DEBUG\n      OSTRACE3( "TRUNCATE %d %lld\\n", id.fs.Name, nByte );\n#endif\n#if SQLITE_TEST\n      //SimulateIOError(return SQLITE_IOERR_TRUNCATE);  TODO --  How to implement this?\n#endif\n      //rc = SetFilePointer( pFile->h, lowerBits, &upperBits, FILE_BEGIN );\n      //if ( rc == INVALID_SET_FILE_POINTER && ( error = GetLastError() ) != NO_ERROR )\n      //{\n      //  pFile->lastErrno = error;\n      //  return SQLITE_IOERR_TRUNCATE;\n      //}\n      ///* SetEndOfFile will fail if nByte is negative */\n      //if ( !SetEndOfFile( pFile->h ) )\n      //{\n      //  pFile->lastErrno = GetLastError();\n      //  return SQLITE_IOERR_TRUNCATE;\n      //}\n      try\n      {\n        id.fs.SetLength( nByte );\n      }\n      catch ( IOException e )\n      {\n        id.lastErrno = (u32)Marshal.GetLastWin32Error();\n        return SQLITE_IOERR_TRUNCATE;\n      }\n      return SQLITE_OK;\n    }\n\n#if SQLITE_TEST\n    /*\n** Count the number of fullsyncs and normal syncs.  This is used to test\n** that syncs and fullsyncs are occuring at the right times.\n*/\n    static int sqlite3_sync_count = 0;\n    static int sqlite3_fullsync_count = 0;\n#endif\n\n    /*\n** Make sure all writes to a particular file are committed to disk.\n*/\n    static int winSync( sqlite3_file id, int flags )\n    {\n#if !SQLITE_NO_SYNC\n      sqlite3_file pFile = (sqlite3_file)id;\n      Debug.Assert( id != null );\n#if SQLITE_DEBUG\n      OSTRACE3( "SYNC %d lock=%d\\n", pFile.fs.GetHashCode(), pFile.locktype );\n#endif\n#else\nUNUSED_PARAMETER(id);\n#endif\n#if !SQLITE_TEST\nUNUSED_PARAMETER(flags);\n#else\n      if ( ( flags & SQLITE_SYNC_FULL ) != 0 )\n      {\n        sqlite3_fullsync_count++;\n      }\n      sqlite3_sync_count++;\n#endif\n      /* If we compiled with the SQLITE_NO_SYNC flag, then syncing is a\n** no-op\n*/\n#if SQLITE_NO_SYNC\nreturn SQLITE_OK;\n#else\n      pFile.fs.Flush();\n      return SQLITE_OK;\n      //if (FlushFileBuffers(pFile.h) != 0)\n      //{\n      //  return SQLITE_OK;\n      //}\n      //else\n      //{\n      //  pFile->lastErrno = (u32)GetLastError();\n      //  return SQLITE_IOERR;\n      //}\n#endif\n    }\n\n    /*\n    ** Determine the current size of a file in bytes\n    */\n    static int sqlite3_fileSize( sqlite3_file id, ref int pSize )\n    {\n      //DWORD upperBits;\n      //DWORD lowerBits;\n      //  sqlite3_file pFile = (sqlite3_file)id;\n      //  DWORD error;\n      Debug.Assert( id != null );\n#if SQLITE_TEST\n      //SimulateIOError(return SQLITE_IOERR_FSTAT);  TODO --  How to implement this?\n#endif\n      //lowerBits = GetFileSize(pFile.fs.Name, upperBits);\n      //if ( ( lowerBits == INVALID_FILE_SIZE )\n      //   && ( ( error = GetLastError() ) != NO_ERROR ) )\n      //{\n      //  pFile->lastErrno = error;\n      //  return SQLITE_IOERR_FSTAT;\n      //}\n      //pSize = (((sqlite3_int64)upperBits)<<32) + lowerBits;\n      pSize = id.fs.CanRead ? (int)id.fs.Length : 0;\n      return SQLITE_OK;\n    }\n\n\n    /*\n    ** Acquire a reader lock.\n    ** Different API routines are called depending on whether or not this\n    ** is Win95 or WinNT.\n    */\n    static int getReadLock( sqlite3_file pFile )\n    {\n      int res = 0;\n      if ( isNT() )\n      {\n        res = lockingStrategy.SharedLockFile( pFile, SHARED_FIRST, SHARED_SIZE );\n      }\n      /* isNT() is 1 if SQLITE_OS_WINCE==1, so this else is never executed.\n      */\n#if !SQLITE_OS_WINCE\n      //else\n      //{\n      //  int lk;\n      //  sqlite3_randomness(lk.Length, lk);\n      //  pFile->sharedLockByte = (u16)((lk & 0x7fffffff)%(SHARED_SIZE - 1));\n      //  res = pFile.fs.Lock( SHARED_FIRST + pFile.sharedLockByte, 0, 1, 0);\n#endif\n      //}\n      if ( res == 0 )\n      {\n        pFile.lastErrno = (u32)Marshal.GetLastWin32Error();\n      }\n      return res;\n    }\n\n    /*\n    ** Undo a readlock\n    */\n    static int unlockReadLock( sqlite3_file pFile )\n    {\n      int res = 1;\n      if ( isNT() )\n      {\n        try\n        {\n          lockingStrategy.UnlockFile( pFile, SHARED_FIRST, SHARED_SIZE ); //     res = UnlockFile(pFilE.h, SHARED_FIRST, 0, SHARED_SIZE, 0);\n        }\n        catch ( Exception e )\n        {\n          res = 0;\n        }\n      }\n      /* isNT() is 1 if SQLITE_OS_WINCE==1, so this else is never executed.\n      */\n#if !SQLITE_OS_WINCE\n      else\n      {\n        Debugger.Break(); //    res = UnlockFile(pFilE.h, SHARED_FIRST + pFilE.sharedLockByte, 0, 1, 0);\n      }\n#endif\n      if ( res == 0 )\n      {\n        pFile.lastErrno = (u32)Marshal.GetLastWin32Error();\n      }\n      return res;\n    }\n\n    /*\n    ** Lock the file with the lock specified by parameter locktype - one\n    ** of the following:\n    **\n    **     (1) SHARED_LOCK\n    **     (2) RESERVED_LOCK\n    **     (3) PENDING_LOCK\n    **     (4) EXCLUSIVE_LOCK\n    **\n    ** Sometimes when requesting one lock state, additional lock states\n    ** are inserted in between.  The locking might fail on one of the later\n    ** transitions leaving the lock state different from what it started but\n    ** still short of its goal.  The following chart shows the allowed\n    ** transitions and the inserted intermediate states:\n    **\n    **    UNLOCKED -> SHARED\n    **    SHARED -> RESERVED\n    **    SHARED -> (PENDING) -> EXCLUSIVE\n    **    RESERVED -> (PENDING) -> EXCLUSIVE\n    **    PENDING -> EXCLUSIVE\n    **\n    ** This routine will only increase a lock.  The winUnlock() routine\n    ** erases all locks at once and returns us immediately to locking level 0.\n    ** It is not possible to lower the locking level one step at a time.  You\n    ** must go straight to locking level 0.\n    */\n    static int winLock( sqlite3_file id, int locktype )\n    {\n      int rc = SQLITE_OK;         /* Return code from subroutines */\n      int res = 1;                /* Result of a windows lock call */\n      int newLocktype;            /* Set pFile.locktype to this value before exiting */\n      bool gotPendingLock = false;/* True if we acquired a PENDING lock this time */\n      sqlite3_file pFile = (sqlite3_file)id;\n      DWORD error = NO_ERROR;\n\n      Debug.Assert( id != null );\n#if SQLITE_DEBUG\n      OSTRACE5( "LOCK %d %d was %d(%d)\\n",\n      pFile.fs.GetHashCode(), locktype, pFile.locktype, pFile.sharedLockByte );\n#endif\n      /* If there is already a lock of this type or more restrictive on the\n** OsFile, do nothing. Don\'t use the end_lock: exit path, as\n** sqlite3OsEnterMutex() hasn\'t been called yet.\n*/\n      if ( pFile.locktype >= locktype )\n      {\n        return SQLITE_OK;\n      }\n\n      /* Make sure the locking sequence is correct\n      */\n      Debug.Assert( pFile.locktype != NO_LOCK || locktype == SHARED_LOCK );\n      Debug.Assert( locktype != PENDING_LOCK );\n      Debug.Assert( locktype != RESERVED_LOCK || pFile.locktype == SHARED_LOCK );\n\n      /* Lock the PENDING_LOCK byte if we need to acquire a PENDING lock or\n      ** a SHARED lock.  If we are acquiring a SHARED lock, the acquisition of\n      ** the PENDING_LOCK byte is temporary.\n      */\n      newLocktype = pFile.locktype;\n      if ( pFile.locktype == NO_LOCK\n      || ( ( locktype == EXCLUSIVE_LOCK )\n      && ( pFile.locktype == RESERVED_LOCK ) )\n      )\n      {\n        int cnt = 3;\n        res = 0;\n        while ( cnt-- > 0 && res == 0 )//(res = LockFile(pFile.fs.SafeFileHandle.DangerousGetHandle().ToInt32(), PENDING_BYTE, 0, 1, 0)) == 0)\n        {\n          try\n          {\n            lockingStrategy.LockFile( pFile, PENDING_BYTE, 1 );\n            res = 1;\n          }\n          catch ( Exception e )\n          {\n            /* Try 3 times to get the pending lock.  The pending lock might be\n            ** held by another reader process who will release it momentarily.\n            */\n#if SQLITE_DEBUG\n            OSTRACE2( "could not get a PENDING lock. cnt=%d\\n", cnt );\n#endif\n            Thread.Sleep( 1 );\n          }\n        }\n        gotPendingLock = ( res != 0 );\n        if ( 0 == res )\n        {\n          error = (u32)Marshal.GetLastWin32Error();\n        }\n      }\n\n      /* Acquire a shared lock\n      */\n      if ( locktype == SHARED_LOCK && res != 0 )\n      {\n        Debug.Assert( pFile.locktype == NO_LOCK );\n        res = getReadLock( pFile );\n        if ( res != 0 )\n        {\n          newLocktype = SHARED_LOCK;\n        }\n        else\n        {\n          error = (u32)Marshal.GetLastWin32Error();\n        }\n      }\n\n      /* Acquire a RESERVED lock\n      */\n      if ( ( locktype == RESERVED_LOCK ) && res != 0 )\n      {\n        Debug.Assert( pFile.locktype == SHARED_LOCK );\n        try\n        {\n          lockingStrategy.LockFile( pFile, RESERVED_BYTE, 1 );//res = LockFile(pFile.fs.SafeFileHandle.DangerousGetHandle().ToInt32(), RESERVED_BYTE, 0, 1, 0);\n          newLocktype = RESERVED_LOCK;\n          res = 1;\n        }\n        catch ( Exception e )\n        {\n          res = 0;\n          error = (u32)Marshal.GetLastWin32Error();\n        }\n        if ( res != 0 )\n        {\n          newLocktype = RESERVED_LOCK;\n        }\n        else\n        {\n          error = (u32)Marshal.GetLastWin32Error();\n        }\n      }\n\n      /* Acquire a PENDING lock\n      */\n      if ( locktype == EXCLUSIVE_LOCK && res != 0 )\n      {\n        newLocktype = PENDING_LOCK;\n        gotPendingLock = false;\n      }\n\n      /* Acquire an EXCLUSIVE lock\n      */\n      if ( locktype == EXCLUSIVE_LOCK && res != 0 )\n      {\n        Debug.Assert( pFile.locktype >= SHARED_LOCK );\n        res = unlockReadLock( pFile );\n#if SQLITE_DEBUG\n        OSTRACE2( "unreadlock = %d\\n", res );\n#endif\n        //res = LockFile(pFile.fs.SafeFileHandle.DangerousGetHandle().ToInt32(), SHARED_FIRST, 0, SHARED_SIZE, 0);\n        try\n        {\n          lockingStrategy.LockFile( pFile, SHARED_FIRST, SHARED_SIZE );\n          newLocktype = EXCLUSIVE_LOCK;\n          res = 1;\n        }\n        catch ( Exception e )\n        {\n          res = 0;\n        }\n        if ( res != 0 )\n        {\n          newLocktype = EXCLUSIVE_LOCK;\n        }\n        else\n        {\n          error = (u32)Marshal.GetLastWin32Error();\n#if SQLITE_DEBUG\n          OSTRACE2( "error-code = %d\\n", error );\n#endif\n          getReadLock( pFile );\n        }\n      }\n\n      /* If we are holding a PENDING lock that ought to be released, then\n      ** release it now.\n      */\n      if ( gotPendingLock && locktype == SHARED_LOCK )\n      {\n        lockingStrategy.UnlockFile( pFile, PENDING_BYTE, 1 );\n      }\n\n      /* Update the state of the lock has held in the file descriptor then\n      ** return the appropriate result code.\n      */\n      if ( res != 0 )\n      {\n        rc = SQLITE_OK;\n      }\n      else\n      {\n#if SQLITE_DEBUG\n        OSTRACE4( "LOCK FAILED %d trying for %d but got %d\\n", pFile.fs.GetHashCode(),\n        locktype, newLocktype );\n#endif\n        pFile.lastErrno = error;\n        rc = SQLITE_BUSY;\n      }\n      pFile.locktype = (u8)newLocktype;\n      return rc;\n    }\n\n    /*\n    ** This routine checks if there is a RESERVED lock held on the specified\n    ** file by this or any other process. If such a lock is held, return\n    ** non-zero, otherwise zero.\n    */\n    static int winCheckReservedLock( sqlite3_file id, ref int pResOut )\n    {\n      int rc;\n      sqlite3_file pFile = (sqlite3_file)id;\n      Debug.Assert( id != null );\n      if ( pFile.locktype >= RESERVED_LOCK )\n      {\n        rc = 1;\n#if SQLITE_DEBUG\n        OSTRACE3( "TEST WR-LOCK %d %d (local)\\n", pFile.fs.Name, rc );\n#endif\n      }\n      else\n      {\n        try\n        {\n          lockingStrategy.LockFile( pFile, RESERVED_BYTE, 1 );\n          lockingStrategy.UnlockFile( pFile, RESERVED_BYTE, 1 );\n          rc = 1;\n        }\n        catch ( IOException e )\n        { rc = 0; }\n        rc = 1 - rc; // !rc\n#if SQLITE_DEBUG\n        OSTRACE3( "TEST WR-LOCK %d %d (remote)\\n", pFile.fs.GetHashCode(), rc );\n#endif\n      }\n      pResOut = rc;\n      return SQLITE_OK;\n    }\n\n    /*\n    ** Lower the locking level on file descriptor id to locktype.  locktype\n    ** must be either NO_LOCK or SHARED_LOCK.\n    **\n    ** If the locking level of the file descriptor is already at or below\n    ** the requested locking level, this routine is a no-op.\n    **\n    ** It is not possible for this routine to fail if the second argument\n    ** is NO_LOCK.  If the second argument is SHARED_LOCK then this routine\n    ** might return SQLITE_IOERR;\n    */\n    static int winUnlock( sqlite3_file id, int locktype )\n    {\n      int type;\n      sqlite3_file pFile = (sqlite3_file)id;\n      int rc = SQLITE_OK;\n      Debug.Assert( pFile != null );\n      Debug.Assert( locktype <= SHARED_LOCK );\n\n#if SQLITE_DEBUG\n      OSTRACE5( "UNLOCK %d to %d was %d(%d)\\n", pFile.fs.GetHashCode(), locktype,\n      pFile.locktype, pFile.sharedLockByte );\n#endif\n      type = pFile.locktype;\n      if ( type >= EXCLUSIVE_LOCK )\n      {\n        lockingStrategy.UnlockFile( pFile, SHARED_FIRST, SHARED_SIZE ); // UnlockFile(pFilE.h, SHARED_FIRST, 0, SHARED_SIZE, 0);\n        if ( locktype == SHARED_LOCK && getReadLock( pFile ) == 0 )\n        {\n          /* This should never happen.  We should always be able to\n          ** reacquire the read lock */\n          rc = SQLITE_IOERR_UNLOCK;\n        }\n      }\n      if ( type >= RESERVED_LOCK )\n      {\n        try\n        {\n          lockingStrategy.UnlockFile( pFile, RESERVED_BYTE, 1 );// UnlockFile(pFilE.h, RESERVED_BYTE, 0, 1, 0);\n        }\n        catch ( Exception e ) { }\n      }\n      if ( locktype == NO_LOCK && type >= SHARED_LOCK )\n      {\n        unlockReadLock( pFile );\n      }\n      if ( type >= PENDING_LOCK )\n      {\n        try\n        {\n          lockingStrategy.UnlockFile( pFile, PENDING_BYTE, 1 );//    UnlockFile(pFilE.h, PENDING_BYTE, 0, 1, 0);\n        }\n        catch ( Exception e )\n        { }\n      }\n      pFile.locktype = (u8)locktype;\n      return rc;\n    }\n\n    /*\n    ** Control and query of the open file handle.\n    */\n    static int winFileControl( sqlite3_file id, int op, ref int pArg )\n    {\n      switch ( op )\n      {\n        case SQLITE_FCNTL_LOCKSTATE:\n          {\n            pArg = ( (sqlite3_file)id ).locktype;\n            return SQLITE_OK;\n          }\n        case SQLITE_LAST_ERRNO:\n          {\n            pArg = (int)( (sqlite3_file)id ).lastErrno;\n            return SQLITE_OK;\n          }\n      }\n      return SQLITE_ERROR;\n    }\n\n    /*\n    ** Return the sector size in bytes of the underlying block device for\n    ** the specified file. This is almost always 512 bytes, but may be\n    ** larger for some devices.\n    **\n    ** SQLite code assumes this function cannot fail. It also assumes that\n    ** if two files are created in the same file-system directory (i.e.\n    ** a database and its journal file) that the sector size will be the\n    ** same for both.\n    */\n    static int winSectorSize( sqlite3_file id )\n    {\n      Debug.Assert( id != null );\n      return (int)( id.sectorSize );\n    }\n\n    /*\n    ** Return a vector of device characteristics.\n    */\n    static int winDeviceCharacteristics( sqlite3_file id )\n    {\n      UNUSED_PARAMETER( id );\n      return 0;\n    }\n\n    /*\n    ** This vector defines all the methods that can operate on an\n    ** sqlite3_file for win32.\n    */\n    static sqlite3_io_methods winIoMethod = new sqlite3_io_methods(\n    1,                        /* iVersion */\n    (dxClose)winClose,\n    (dxRead)winRead,\n    (dxWrite)winWrite,\n    (dxTruncate)winTruncate,\n    (dxSync)winSync,\n    (dxFileSize)sqlite3_fileSize,\n    (dxLock)winLock,\n    (dxUnlock)winUnlock,\n    (dxCheckReservedLock)winCheckReservedLock,\n    (dxFileControl)winFileControl,\n    (dxSectorSize)winSectorSize,\n    (dxDeviceCharacteristics)winDeviceCharacteristics\n    );\n\n    /***************************************************************************\n    ** Here ends the I/O methods that form the sqlite3_io_methods object.\n    **\n    ** The next block of code implements the VFS methods.\n    ****************************************************************************/\n\n    /*\n    ** Convert a UTF-8 filename into whatever form the underlying\n    ** operating system wants filenames in.  Space to hold the result\n    ** is obtained from malloc and must be freed by the calling\n    ** function.\n    */\n    static string convertUtf8Filename( string zFilename )\n    {\n      return zFilename;\n      // string zConverted = "";\n      //if (isNT())\n      //{\n      //  zConverted = utf8ToUnicode(zFilename);\n      /* isNT() is 1 if SQLITE_OS_WINCE==1, so this else is never executed.\n      */\n#if !SQLITE_OS_WINCE\n      //}\n      //else\n      //{\n      //  zConverted = utf8ToMbcs(zFilename);\n#endif\n      //}\n      /* caller will handle out of memory */\n      //return zConverted;\n    }\n\n    /*\n    ** Create a temporary file name in zBuf.  zBuf must be big enough to\n    ** hold at pVfs.mxPathname characters.\n    */\n    static int getTempname( int nBuf, StringBuilder zBuf )\n    {\n      const string zChars = "abcdefghijklmnopqrstuvwxyz0123456789";\n      //static char zChars[] =\n      //  "abcdefghijklmnopqrstuvwxyz"\n      //  "ABCDEFGHIJKLMNOPQRSTUVWXYZ"\n      //  "0123456789";\n      //size_t i, j;\n      //char zTempPath[MAX_PATH+1];\n      //if( sqlite3_temp_directory ){\n      //  sqlite3_snprintf(MAX_PATH-30, zTempPath, "%s", sqlite3_temp_directory);\n      //}else if( isNT() ){\n      //  char *zMulti;\n      //  WCHAR zWidePath[MAX_PATH];\n      //  GetTempPathW(MAX_PATH-30, zWidePath);\n      //  zMulti = unicodeToUtf8(zWidePath);\n      //  if( zMulti ){\n      //    sqlite3_snprintf(MAX_PATH-30, zTempPath, "%s", zMulti);\n      //    free(zMulti);\n      //  }else{\n      //    return SQLITE_NOMEM;\n      //  }\n      /* isNT() is 1 if SQLITE_OS_WINCE==1, so this else is never executed.\n      ** Since the ASCII version of these Windows API do not exist for WINCE,\n      ** it\'s important to not reference them for WINCE builds.\n      */\n#if !SQLITE_OS_WINCE\n      //}else{\n      //  char *zUtf8;\n      //  char zMbcsPath[MAX_PATH];\n      //  GetTempPathA(MAX_PATH-30, zMbcsPath);\n      //  zUtf8 = sqlite3_win32_mbcs_to_utf8(zMbcsPath);\n      //  if( zUtf8 ){\n      //    sqlite3_snprintf(MAX_PATH-30, zTempPath, "%s", zUtf8);\n      //    free(zUtf8);\n      //  }else{\n      //    return SQLITE_NOMEM;\n      //  }\n#endif\n      //}\n\n      StringBuilder zRandom = new StringBuilder( 20 );\n      i64 iRandom = 0;\n      for ( int i = 0 ; i < 20 ; i++ )\n      {\n        sqlite3_randomness( 1, ref iRandom );\n        zRandom.Append( (char)zChars[(int)( iRandom % ( zChars.Length - 1 ) )] );\n      }\n      //  zBuf[j] = 0;\n      zBuf.Append( Path.GetTempPath() + SQLITE_TEMP_FILE_PREFIX + zRandom.ToString() );\n      //for(i=sqlite3Strlen30(zTempPath); i>0 && zTempPath[i-1]==\'\\\\\'; i--){}\n      //zTempPath[i] = 0;\n      //sqlite3_snprintf(nBuf-30, zBuf,\n      //                 "%s\\\\"SQLITE_TEMP_FILE_PREFIX, zTempPath);\n      //j = sqlite3Strlen30(zBuf);\n      //sqlite3_randomness(20, zBuf[j]);\n      //for(i=0; i<20; i++, j++){\n      //  zBuf[j] = (char)zChars[ ((unsigned char)zBuf[j])%(sizeof(zChars)-1) ];\n      //}\n      //zBuf[j] = 0;\n\n#if SQLITE_DEBUG\n      OSTRACE2( "TEMP FILENAME: %s\\n", zBuf.ToString() );\n#endif\n      return SQLITE_OK;\n    }\n\n    /*\n    ** The return value of getLastErrorMsg\n    ** is zero if the error message fits in the buffer, or non-zero\n    ** otherwise (if the message was truncated).\n    */\n    static int getLastErrorMsg( int nBuf, ref string zBuf )\n    {\n      //int error = GetLastError ();\n\n#if SQLITE_OS_WINCE\nsqlite3_snprintf(nBuf, zBuf, "OsError 0x%x (%u)", error, error);\n#else\n      /* FormatMessage returns 0 on failure.  Otherwise it\n** returns the number of TCHARs written to the output\n** buffer, excluding the terminating null char.\n*/\n      //int iDummy = 0;\n      //object oDummy = null;\n      //if ( 00 == FormatMessageA( FORMAT_MESSAGE_FROM_SYSTEM,\n      //ref oDummy,\n      //error,\n      //0,\n      //zBuf,\n      //nBuf - 1,\n      //ref iDummy ) )\n      //{\n      //  sqlite3_snprintf( nBuf, ref zBuf, "OsError 0x%x (%u)", error, error );\n      //}\n#endif\n      zBuf = new Win32Exception( Marshal.GetLastWin32Error() ).Message;\n\n      return 0;\n    }\n\n    /*\n    ** Open a file.\n    */\n    static int winOpen(\n    sqlite3_vfs pVfs,       /* Not used */\n    string zName,           /* Name of the file (UTF-8) */\n    sqlite3_file pFile, /* Write the SQLite file handle here */\n    int flags,              /* Open mode flags */\n    ref int pOutFlags       /* Status return flags */\n    )\n    {\n      //HANDLE h;\n      FileStream fs = null;\n      FileAccess dwDesiredAccess;\n      FileShare dwShareMode;\n      FileMode dwCreationDisposition;\n      FileOptions dwFlagsAndAttributes;\n#if SQLITE_OS_WINCE\nint isTemp = 0;\n#endif\n      //winFile* pFile = (winFile*)id;\n      string zConverted;                 /* Filename in OS encoding */\n      string zUtf8Name = zName;    /* Filename in UTF-8 encoding */\n      StringBuilder zTmpname = new StringBuilder( MAX_PATH + 1 );        /* Buffer used to create temp filename */\n\n      Debug.Assert( pFile != null );\n      UNUSED_PARAMETER( pVfs );\n\n      /* If the second argument to this function is NULL, generate a\n      ** temporary file name to use\n      */\n      if ( String.IsNullOrEmpty( zUtf8Name ) )\n      {\n        int rc = getTempname( MAX_PATH + 1, zTmpname );\n        if ( rc != SQLITE_OK )\n        {\n          return rc;\n        }\n        zUtf8Name = zTmpname.ToString();\n      }\n\n      // /* Convert the filename to the system encoding. */\n      zConverted = zUtf8Name;// convertUtf8Filename( zUtf8Name );\n      if ( String.IsNullOrEmpty( zConverted ) )\n      {\n        return SQLITE_NOMEM;\n      }\n\n      if ( ( flags & SQLITE_OPEN_READWRITE ) != 0 )\n      {\n        dwDesiredAccess = FileAccess.Read | FileAccess.Write; // GENERIC_READ | GENERIC_WRITE;\n      }\n      else\n      {\n        dwDesiredAccess = FileAccess.Read; // GENERIC_READ;\n      }\n      /* SQLITE_OPEN_EXCLUSIVE is used to make sure that a new file is\n      ** created. SQLite doesn\'t use it to indicate "exclusive access"\n      ** as it is usually understood.\n      */\n      Debug.Assert( 0 == ( flags & SQLITE_OPEN_EXCLUSIVE ) || ( flags & SQLITE_OPEN_CREATE ) != 0 );\n      if ( ( flags & SQLITE_OPEN_EXCLUSIVE ) != 0 )\n      {\n        /* Creates a new file, only if it does not already exist. */\n        /* If the file exists, it fails. */\n        dwCreationDisposition = FileMode.CreateNew;// CREATE_NEW;\n      }\n      else if ( ( flags & SQLITE_OPEN_CREATE ) != 0 )\n      {\n        /* Open existing file, or create if it doesn\'t exist */\n        dwCreationDisposition = FileMode.OpenOrCreate;// OPEN_ALWAYS;\n      }\n      else\n      {\n        /* Opens a file, only if it exists. */\n        dwCreationDisposition = FileMode.Open;//OPEN_EXISTING;\n      }\n      dwShareMode = FileShare.Read | FileShare.Write;// FILE_SHARE_READ | FILE_SHARE_WRITE;\n      if ( ( flags & SQLITE_OPEN_DELETEONCLOSE ) != 0 )\n      {\n#if SQLITE_OS_WINCE\ndwFlagsAndAttributes = FILE_ATTRIBUTE_HIDDEN;\nisTemp = 1;\n#else\n        dwFlagsAndAttributes = FileOptions.DeleteOnClose; // FILE_ATTRIBUTE_TEMPORARY\n        //| FILE_ATTRIBUTE_HIDDEN\n        //| FILE_FLAG_DELETE_ON_CLOSE;\n#endif\n      }\n      else\n      {\n        dwFlagsAndAttributes = FileOptions.None; // FILE_ATTRIBUTE_NORMAL;\n      }\n      /* Reports from the internet are that performance is always\n      ** better if FILE_FLAG_RANDOM_ACCESS is used.  Ticket #2699. */\n#if SQLITE_OS_WINCE\ndwFlagsAndAttributes |= FileOptions.RandomAccess; // FILE_FLAG_RANDOM_ACCESS;\n#endif\n      if ( isNT() )\n      {\n        //h = CreateFileW((WCHAR*)zConverted,\n        //   dwDesiredAccess,\n        //   dwShareMode,\n        //   NULL,\n        //   dwCreationDisposition,\n        //   dwFlagsAndAttributes,\n        //   NULL\n        //);\n\n        //\n        // retry opening the file a few times; this is because of a racing condition between a delete and open call to the FS\n        //\n        int retries = 3;\n        while ( ( fs == null ) && ( retries > 0 ) )\n          try\n          {\n            retries--;\n            fs = new FileStream( zConverted, dwCreationDisposition, dwDesiredAccess, dwShareMode, 1024, dwFlagsAndAttributes );\n#if SQLITE_DEBUG\n            OSTRACE3( "OPEN %d (%s)\\n", fs.GetHashCode(), fs.Name );\n#endif\n          }\n          catch ( Exception e )\n          {\n            Thread.Sleep( 100 );\n          }\n\n        /* isNT() is 1 if SQLITE_OS_WINCE==1, so this else is never executed.\n        ** Since the ASCII version of these Windows API do not exist for WINCE,\n        ** it\'s important to not reference them for WINCE builds.\n        */\n#if !SQLITE_OS_WINCE\n      }\n      else\n      {\n        Debugger.Break(); // Not NT\n        //h = CreateFileA((char*)zConverted,\n        //   dwDesiredAccess,\n        //   dwShareMode,\n        //   NULL,\n        //   dwCreationDisposition,\n        //   dwFlagsAndAttributes,\n        //   NULL\n        //);\n#endif\n      }\n      if ( fs == null || fs.SafeFileHandle.IsInvalid ) //(h == INVALID_HANDLE_VALUE)\n      {\n        //        free(zConverted);\n        if ( ( flags & SQLITE_OPEN_READWRITE ) != 0 )\n        {\n          return winOpen( pVfs, zName, pFile,\n          ( ( flags | SQLITE_OPEN_READONLY ) & ~SQLITE_OPEN_READWRITE ), ref pOutFlags );\n        }\n        else\n        {\n          return SQLITE_CANTOPEN;\n        }\n      }\n      //if ( pOutFlags )\n      //{\n      if ( ( flags & SQLITE_OPEN_READWRITE ) != 0 )\n      {\n        pOutFlags = SQLITE_OPEN_READWRITE;\n      }\n      else\n      {\n        pOutFlags = SQLITE_OPEN_READONLY;\n      }\n      //}\n      pFile.Clear(); // memset(pFile, 0, sizeof(*pFile));\n      pFile.pMethods = winIoMethod;\n      pFile.fs = fs;\n      pFile.lastErrno = NO_ERROR;\n      pFile.sectorSize = (ulong)getSectorSize( pVfs, zUtf8Name );\n#if SQLITE_OS_WINCE\nif( (flags & (SQLITE_OPEN_READWRITE|SQLITE_OPEN_MAIN_DB)) ==\n(SQLITE_OPEN_READWRITE|SQLITE_OPEN_MAIN_DB)\n&& !winceCreateLock(zName, pFile)\n){\nCloseHandle(h);\nfree(zConverted);\nreturn SQLITE_CANTOPEN;\n}\nif( isTemp ){\npFile.zDeleteOnClose = zConverted;\n}else\n#endif\n      {\n        // free(zConverted);\n      }\n#if SQLITE_TEST\n      OpenCounter( +1 );\n#endif\n      return SQLITE_OK;\n    }\n\n    /*\n    ** Delete the named file.\n    **\n    ** Note that windows does not allow a file to be deleted if some other\n    ** process has it open.  Sometimes a virus scanner or indexing program\n    ** will open a journal file shortly after it is created in order to do\n    ** whatever it does.  While this other process is holding the\n    ** file open, we will be unable to delete it.  To work around this\n    ** problem, we delay 100 milliseconds and try to delete again.  Up\n    ** to MX_DELETION_ATTEMPTs deletion attempts are run before giving\n    ** up and returning an error.\n    */\n    static int MX_DELETION_ATTEMPTS = 5;\n    static int winDelete(\n    sqlite3_vfs pVfs,         /* Not used on win32 */\n    string zFilename,         /* Name of file to delete */\n    int syncDir               /* Not used on win32 */\n    )\n    {\n      int cnt = 0;\n      int rc;\n      int error;\n      UNUSED_PARAMETER( pVfs );\n      UNUSED_PARAMETER( syncDir );\n      string zConverted = convertUtf8Filename( zFilename );\n      if ( zConverted == null || zConverted == "" )\n      {\n        return SQLITE_NOMEM;\n      }\n#if SQLITE_TEST\n      //SimulateIOError(return SQLITE_IOERR_DELETE);  TODO --  How to implement this?\n#endif\n      if ( isNT() )\n      {\n        do\n        //  DeleteFileW(zConverted);\n        //}while(   (   ((rc = GetFileAttributesW(zConverted)) != INVALID_FILE_ATTRIBUTES)\n        //           || ((error = GetLastError()) == ERROR_ACCESS_DENIED))\n        //       && (++cnt < MX_DELETION_ATTEMPTS)\n        //       && (Sleep(100), 1) );\n        {\n          if ( !File.Exists( zFilename ) )\n          {\n            rc = SQLITE_IOERR;\n            break;\n          }\n          try\n          {\n            File.Delete( zConverted );\n            rc = SQLITE_OK;\n          }\n          catch ( IOException e )\n          {\n            rc = SQLITE_IOERR;\n            Thread.Sleep( 100 );\n          }\n        } while ( rc != SQLITE_OK && ++cnt < MX_DELETION_ATTEMPTS );\n        /* isNT() is 1 if SQLITE_OS_WINCE==1, so this else is never executed.\n        ** Since the ASCII version of these Windows API do not exist for WINCE,\n        ** it\'s important to not reference them for WINCE builds.\n        */\n#if !SQLITE_OS_WINCE\n      }\n      else\n      {\n        do\n        {\n          //DeleteFileA( zConverted );\n          //}while(   (   ((rc = GetFileAttributesA(zConverted)) != INVALID_FILE_ATTRIBUTES)\n          //           || ((error = GetLastError()) == ERROR_ACCESS_DENIED))\n          //       && (cnt++ < MX_DELETION_ATTEMPTS)\n          //       && (Sleep(100), 1) );\n          if ( !File.Exists( zFilename ) )\n          {\n            rc = SQLITE_IOERR;\n            break;\n          }\n          try\n          {\n            File.Delete( zConverted );\n            rc = SQLITE_OK;\n          }\n          catch ( IOException e )\n          {\n            rc = SQLITE_IOERR;\n            Thread.Sleep( 100 );\n          }\n        } while ( rc != SQLITE_OK && cnt++ < MX_DELETION_ATTEMPTS );\n#endif\n      }\n      //free(zConverted);\n#if SQLITE_DEBUG\n      OSTRACE2( "DELETE \\"%s\\"\\n", zFilename );\n#endif\n      //return ( ( rc == INVALID_FILE_ATTRIBUTES )\n      //&& ( error == ERROR_FILE_NOT_FOUND ) ) ? SQLITE_OK : SQLITE_IOERR_DELETE;\n      return rc;\n    }\n\n    /*\n    ** Check the existence and status of a file.\n    */\n    static int winAccess(\n    sqlite3_vfs pVfs,       /* Not used on win32 */\n    string zFilename,       /* Name of file to check */\n    int flags,              /* Type of test to make on this file */\n    ref int pResOut         /* OUT: Result */\n    )\n    {\n      FileAttributes attr = 0; // DWORD attr;\n      int rc = 0;\n      //  void *zConverted = convertUtf8Filename(zFilename);\n      UNUSED_PARAMETER( pVfs );\n      //  if( zConverted==0 ){\n      //    return SQLITE_NOMEM;\n      //  }\n      //if ( isNT() )\n      //{\n      //\n      // Do a quick test to prevent the try/catch block\n      if ( flags == SQLITE_ACCESS_EXISTS )\n      {\n        pResOut = File.Exists( zFilename ) ? 1 : 0;\n        return SQLITE_OK;\n      }\n      //\n      try\n      {\n        attr = File.GetAttributes( zFilename );// GetFileAttributesW( (WCHAR*)zConverted );\n        if ( attr == FileAttributes.Directory )\n        {\n          StringBuilder zTmpname = new StringBuilder( 255 );        /* Buffer used to create temp filename */\n          getTempname( 256, zTmpname );\n\n          string zTempFilename;\n          zTempFilename = zTmpname.ToString();//( SQLITE_TEMP_FILE_PREFIX.Length + 1 );\n          try\n          {\n            FileStream fs = File.Create( zTempFilename, 1, FileOptions.DeleteOnClose );\n            fs.Close();\n            attr = FileAttributes.Normal;\n          }\n          catch ( IOException e ) { attr = FileAttributes.ReadOnly; }\n        }\n      }\n      /* isNT() is 1 if SQLITE_OS_WINCE==1, so this else is never executed.\n      ** Since the ASCII version of these Windows API do not exist for WINCE,\n      ** it\'s important to not reference them for WINCE builds.\n      */\n#if !SQLITE_OS_WINCE\n      //}\n      //else\n      //{\n      //  attr = GetFileAttributesA( (char*)zConverted );\n#endif\n      //}\n      catch ( IOException e )\n      { }\n      //  free(zConverted);\n      switch ( flags )\n      {\n        case SQLITE_ACCESS_READ:\n        case SQLITE_ACCESS_EXISTS:\n          rc = attr != 0 ? 1 : 0;// != INVALID_FILE_ATTRIBUTES;\n          break;\n        case SQLITE_ACCESS_READWRITE:\n          rc = attr == 0 ? 0 : (int)( attr & FileAttributes.ReadOnly ) != 0 ? 0 : 1; //FILE_ATTRIBUTE_READONLY ) == 0;\n          break;\n        default:\n          Debug.Assert( "" == "Invalid flags argument" );\n          rc = 0;\n          break;\n      }\n      pResOut = rc;\n      return SQLITE_OK;\n    }\n\n    /*\n    ** Turn a relative pathname into a full pathname.  Write the full\n    ** pathname into zOut[].  zOut[] will be at least pVfs.mxPathname\n    ** bytes in size.\n    */\n    static int winFullPathname(\n    sqlite3_vfs pVfs,             /* Pointer to vfs object */\n    string zRelative,             /* Possibly relative input path */\n    int nFull,                    /* Size of output buffer in bytes */\n    StringBuilder zFull           /* Output buffer */\n    )\n    {\n\n#if __CYGWIN__\nUNUSED_PARAMETER(nFull);\ncygwin_conv_to_full_win32_path(zRelative, zFull);\nreturn SQLITE_OK;\n#endif\n\n#if SQLITE_OS_WINCE\nUNUSED_PARAMETER(nFull);\n/* WinCE has no concept of a relative pathname, or so I am told. */\nsqlite3_snprintf(pVfs.mxPathname, zFull, "%s", zRelative);\nreturn SQLITE_OK;\n#endif\n\n#if !SQLITE_OS_WINCE && !__CYGWIN__\n      int nByte;\n      //string  zConverted;\n      string zOut = null;\n      UNUSED_PARAMETER( nFull );\n      //convertUtf8Filename(zRelative));\n      if ( isNT() )\n      {\n        //string zTemp;\n        //nByte = GetFullPathNameW( zConverted, 0, 0, 0) + 3;\n        //zTemp = malloc( nByte*sizeof(zTemp[0]) );\n        //if( zTemp==0 ){\n        //  free(zConverted);\n        //  return SQLITE_NOMEM;\n        //}\n        //zTemp = GetFullPathNameW(zConverted, nByte, zTemp, 0);\n        // will happen on exit; was   free(zConverted);\n        try\n        {\n          zOut = Path.GetFullPath( zRelative ); // was unicodeToUtf8(zTemp);\n        }\n        catch ( IOException e )\n        { zOut = zRelative; }\n        // will happen on exit; was   free(zTemp);\n        /* isNT() is 1 if SQLITE_OS_WINCE==1, so this else is never executed.\n        ** Since the ASCII version of these Windows API do not exist for WINCE,\n        ** it\'s important to not reference them for WINCE builds.\n        */\n#if !SQLITE_OS_WINCE\n      }\n      else\n      {\n        Debugger.Break(); // -- Not Running under NT\n        //string zTemp;\n        //nByte = GetFullPathNameA(zConverted, 0, 0, 0) + 3;\n        //zTemp = malloc( nByte*sizeof(zTemp[0]) );\n        //if( zTemp==0 ){\n        //  free(zConverted);\n        //  return SQLITE_NOMEM;\n        //}\n        //GetFullPathNameA( zConverted, nByte, zTemp, 0);\n        // free(zConverted);\n        //zOut = sqlite3_win32_mbcs_to_utf8(zTemp);\n        // free(zTemp);\n#endif\n      }\n      if ( zOut != null )\n      {\n        // sqlite3_snprintf(pVfs.mxPathname, zFull, "%s", zOut);\n        if ( zFull.Length > pVfs.mxPathname ) zFull.Length = pVfs.mxPathname;\n        zFull.Append( zOut );\n\n        // will happen on exit; was   free(zOut);\n        return SQLITE_OK;\n      }\n      else\n      {\n        return SQLITE_NOMEM;\n      }\n#endif\n    }\n\n\n    /*\n    ** Get the sector size of the device used to store\n    ** file.\n    */\n    static int getSectorSize(\n    sqlite3_vfs pVfs,\n    string zRelative     /* UTF-8 file name */\n    )\n    {\n      int bytesPerSector = SQLITE_DEFAULT_SECTOR_SIZE;\n      StringBuilder zFullpath = new StringBuilder( MAX_PATH + 1 );\n      int rc;\n      bool dwRet = false;\n      int dwDummy = 0;\n\n      /*\n      ** We need to get the full path name of the file\n      ** to get the drive letter to look up the sector\n      ** size.\n      */\n      rc = winFullPathname( pVfs, zRelative, MAX_PATH, zFullpath );\n      if ( rc == SQLITE_OK )\n      {\n        StringBuilder zConverted = new StringBuilder( convertUtf8Filename( zFullpath.ToString() ) );\n        if ( zConverted.Length != 0 )\n        {\n          if ( isNT() )\n          {\n            /* trim path to just drive reference */\n            //for ( ; *p ; p++ )\n            //{\n            //  if ( *p == \'\\\\\' )\n            //  {\n            //    *p = \'\\0\';\n            //    break;\n            //  }\n            //}\n            int i;\n            for ( i = 0 ; i < zConverted.Length && i < MAX_PATH ; i++ )\n            {\n              if ( zConverted[i] == \'\\\\\' )\n              {\n                i++;\n                break;\n              }\n            }\n            zConverted.Length = i;\n            //dwRet = GetDiskFreeSpace( zConverted,\n            //     ref dwDummy,\n            //     ref bytesPerSector,\n            //     ref dwDummy,\n            //     ref dwDummy );\n            //#if !SQLITE_OS_WINCE\n            //}else{\n            //  /* trim path to just drive reference */\n            //  CHAR* p = (CHAR*)zConverted;\n            //  for ( ; *p ; p++ )\n            //  {\n            //    if ( *p == \'\\\\\' )\n            //    {\n            //      *p = \'\\0\';\n            //      break;\n            //    }\n            //  }\n            //        dwRet = GetDiskFreeSpaceA((CHAR*)zConverted,\n            //                                  dwDummy,\n            //                                  ref bytesPerSector,\n            //                                  dwDummy,\n            //                                  dwDummy );\n            //#endif\n          }\n          //free(zConverted);\n        }\n        //  if ( !dwRet )\n        //  {\n        //    bytesPerSector = SQLITE_DEFAULT_SECTOR_SIZE;\n        //  }\n        //}\n        bytesPerSector = GetbytesPerSector( zConverted );\n      }\n      return bytesPerSector == 0 ? SQLITE_DEFAULT_SECTOR_SIZE : bytesPerSector;\n    }\n\n#if !SQLITE_OMIT_LOAD_EXTENSION\n    /*\n** Interfaces for opening a shared library, finding entry points\n** within the shared library, and closing the shared library.\n*/\n    /*\n    ** Interfaces for opening a shared library, finding entry points\n    ** within the shared library, and closing the shared library.\n    */\n    //static void *winDlOpen(sqlite3_vfs pVfs, string zFilename){\n    //  HANDLE h;\n    //  void *zConverted = convertUtf8Filename(zFilename);\n    //  UNUSED_PARAMETER(pVfs);\n    //  if( zConverted==0 ){\n    //    return 0;\n    //  }\n    //  if( isNT() ){\n    //    h = LoadLibraryW((WCHAR*)zConverted);\n    /* isNT() is 1 if SQLITE_OS_WINCE==1, so this else is never executed.\n    ** Since the ASCII version of these Windows API do not exist for WINCE,\n    ** it\'s important to not reference them for WINCE builds.\n    */\n#if !SQLITE_OS_WINCE\n    //  }else{\n    //    h = LoadLibraryA((char*)zConverted);\n#endif\n    //  }\n    //  free(zConverted);\n    //  return (void*)h;\n    //}\n    //static void winDlError(sqlite3_vfs pVfs, int nBuf, char *zBufOut){\n    //  UNUSED_PARAMETER(pVfs);\n    //  getLastErrorMsg(nBuf, zBufOut);\n    //}\n    //    static object winDlSym(sqlite3_vfs pVfs, HANDLE pHandle, String zSymbol){\n    //  UNUSED_PARAMETER(pVfs);\n    //#if SQLITE_OS_WINCE\n    //      /* The GetProcAddressA() routine is only available on wince. */\n    //      return GetProcAddressA((HANDLE)pHandle, zSymbol);\n    //#else\n    //     /* All other windows platforms expect GetProcAddress() to take\n    //      ** an Ansi string regardless of the _UNICODE setting */\n    //      return GetProcAddress((HANDLE)pHandle, zSymbol);\n    //#endif\n    //   }\n    //    static void winDlClose( sqlite3_vfs pVfs, HANDLE pHandle )\n    //   {\n    //  UNUSED_PARAMETER(pVfs);\n    //     FreeLibrary((HANDLE)pHandle);\n    //   }\n    //TODO -- Fix This\n    static HANDLE winDlOpen( sqlite3_vfs vfs, string zFilename ) { return new HANDLE(); }\n    static int winDlError( sqlite3_vfs vfs, int nByte, ref string zErrMsg ) { return 0; }\n    static HANDLE winDlSym( sqlite3_vfs vfs, HANDLE data, string zSymbol ) { return new HANDLE(); }\n    static int winDlClose( sqlite3_vfs vfs, HANDLE data ) { return 0; }\n#else // * if SQLITE_OMIT_LOAD_EXTENSION is defined: */\nstatic object winDlOpen(ref sqlite3_vfs vfs, string zFilename) { return null; }\nstatic int winDlError(ref sqlite3_vfs vfs, int nByte, ref string zErrMsg) { return 0; }\nstatic object winDlSym(ref sqlite3_vfs vfs, object data, string zSymbol) { return null; }\nstatic int winDlClose(ref sqlite3_vfs vfs, object data) { return 0; }\n#endif\n\n\n    /*\n** Write up to nBuf bytes of randomness into zBuf.\n*/\n\n    //[StructLayout( LayoutKind.Explicit, Size = 16, CharSet = CharSet.Ansi )]\n    //public class _SYSTEMTIME\n    //{\n    //  [FieldOffset( 0 )]\n    //  public u32 byte_0_3;\n    //  [FieldOffset( 4 )]\n    //  public u32 byte_4_7;\n    //  [FieldOffset( 8 )]\n    //  public u32 byte_8_11;\n    //  [FieldOffset( 12 )]\n    //  public u32 byte_12_15;\n    //}\n    //[DllImport( "Kernel32.dll" )]\n    //private static extern bool QueryPerformanceCounter( out long lpPerformanceCount );\n\n    static int winRandomness( sqlite3_vfs pVfs, int nBuf, ref byte[] zBuf )\n    {\n      int n = 0;\n      UNUSED_PARAMETER( pVfs );\n#if (SQLITE_TEST)\n      n = nBuf;\n      Array.Clear( zBuf, 0, n );// memset( zBuf, 0, nBuf );\n#else\nbyte[] sBuf = BitConverter.GetBytes(System.DateTime.Now.Ticks);\nzBuf[0] = sBuf[0];\nzBuf[1] = sBuf[1];\nzBuf[2] = sBuf[2];\nzBuf[3] = sBuf[3];\n;// memcpy(&zBuf[n], x, sizeof(x))\nn += 16;// sizeof(x);\nif ( sizeof( DWORD ) <= nBuf - n )\n{\n//DWORD pid = GetCurrentProcessId();\nput32bits( zBuf, n, (u32)Process.GetCurrentProcess().Id );//(memcpy(&zBuf[n], pid, sizeof(pid));\nn += 4;// sizeof(pid);\n}\nif ( sizeof( DWORD ) <= nBuf - n )\n{\n//DWORD cnt = GetTickCount();\nSystem.DateTime dt = new System.DateTime();\nput32bits( zBuf, n, (u32)dt.Ticks );// memcpy(&zBuf[n], cnt, sizeof(cnt));\nn += 4;// cnt.Length;\n}\nif ( sizeof( long ) <= nBuf - n )\n{\nlong i;\ni = System.DateTime.UtcNow.Millisecond;// QueryPerformanceCounter(out i);\nput32bits( zBuf, n, (u32)( i & 0xFFFFFFFF ) );//memcpy(&zBuf[n], i, sizeof(i));\nput32bits( zBuf, n, (u32)( i >> 32 ) );\nn += sizeof( long );\n}\n#endif\n      return n;\n    }\n\n\n    /*\n    ** Sleep for a little while.  Return the amount of time slept.\n    */\n    static int winSleep( sqlite3_vfs pVfs, int microsec )\n    {\n      Thread.Sleep( ( microsec + 999 ) / 1000 );\n      UNUSED_PARAMETER( pVfs );\n      return ( ( microsec + 999 ) / 1000 ) * 1000;\n    }\n\n    /*\n    ** The following variable, if set to a non-zero value, becomes the result\n    ** returned from sqlite3OsCurrentTime().  This is used for testing.\n    */\n#if SQLITE_TEST\n    //    static int sqlite3_current_time = 0;\n#endif\n\n    /*\n** Find the current time (in Universal Coordinated Time).  Write the\n** current time and date as a Julian Day number into prNow and\n** return 0.  Return 1 if the time and date cannot be found.\n*/\n    static int winCurrentTime( sqlite3_vfs pVfs, ref double prNow )\n    {\n      FILETIME ft = new FILETIME();\n      /* FILETIME structure is a 64-bit value representing the number of\n      100-nanosecond intervals since January 1, 1601 (= JD 2305813.5).\n      */\n      sqlite3_int64 timeW;   /* Whole days */\n      sqlite3_int64 timeF;   /* Fractional Days */\n\n      /* Number of 100-nanosecond intervals in a single day */\n      const sqlite3_int64 ntuPerDay =\n      10000000 * (sqlite3_int64)86400;\n\n      /* Number of 100-nanosecond intervals in half of a day */\n      const sqlite3_int64 ntuPerHalfDay =\n      10000000 * (sqlite3_int64)43200;\n\n      ///* 2^32 - to avoid use of LL and warnings in gcc */\n      //const sqlite3_int64 max32BitValue =\n      //(sqlite3_int64)2000000000 + (sqlite3_int64)2000000000 + (sqlite3_int64)294967296;\n\n      //#if SQLITE_OS_WINCE\n      //SYSTEMTIME time;\n      //GetSystemTime(&time);\n      ///* if SystemTimeToFileTime() fails, it returns zero. */\n      //if (!SystemTimeToFileTime(&time,&ft)){\n      //return 1;\n      //}\n      //#else\n      //      GetSystemTimeAsFileTime( ref ft );\n      //      ft = System.DateTime.UtcNow.ToFileTime();\n      //#endif\n      //      UNUSED_PARAMETER( pVfs );\n      //      timeW = ( ( (sqlite3_int64)ft.dwHighDateTime ) * max32BitValue ) + (sqlite3_int64)ft.dwLowDateTime;\n      timeW = System.DateTime.UtcNow.ToFileTime();\n      timeF = timeW % ntuPerDay;          /* fractional days (100-nanoseconds) */\n      timeW = timeW / ntuPerDay;          /* whole days */\n      timeW = timeW + 2305813;            /* add whole days (from 2305813.5) */\n      timeF = timeF + ntuPerHalfDay;      /* add half a day (from 2305813.5) */\n      timeW = timeW + ( timeF / ntuPerDay );  /* add whole day if half day made one */\n      timeF = timeF % ntuPerDay;          /* compute new fractional days */\n      prNow = (double)timeW + ( (double)timeF / (double)ntuPerDay );\n#if SQLITE_TEST\n      if ( ( sqlite3_current_time.iValue ) != 0 )\n      {\n        prNow = ( (double)sqlite3_current_time.iValue + (double)43200 ) / (double)86400 + (double)2440587;\n      }\n#endif\n      return 0;\n    }\n\n\n    /*\n    ** The idea is that this function works like a combination of\n    ** GetLastError() and FormatMessage() on windows (or errno and\n    ** strerror_r() on unix). After an error is returned by an OS\n    ** function, SQLite calls this function with zBuf pointing to\n    ** a buffer of nBuf bytes. The OS layer should populate the\n    ** buffer with a nul-terminated UTF-8 encoded error message\n    ** describing the last IO error to have occurred within the calling\n    ** thread.\n    **\n    ** If the error message is too large for the supplied buffer,\n    ** it should be truncated. The return value of xGetLastError\n    ** is zero if the error message fits in the buffer, or non-zero\n    ** otherwise (if the message was truncated). If non-zero is returned,\n    ** then it is not necessary to include the nul-terminator character\n    ** in the output buffer.\n    **\n    ** Not supplying an error message will have no adverse effect\n    ** on SQLite. It is fine to have an implementation that never\n    ** returns an error message:\n    **\n    **   int xGetLastError(sqlite3_vfs pVfs, int nBuf, char *zBuf){\n    **     Debug.Assert(zBuf[0]==\'\\0\');\n    **     return 0;\n    **   }\n    **\n    ** However if an error message is supplied, it will be incorporated\n    ** by sqlite into the error message available to the user using\n    ** sqlite3_errmsg(), possibly making IO errors easier to debug.\n    */\n    static int winGetLastError( sqlite3_vfs pVfs, int nBuf, ref string zBuf )\n    {\n      UNUSED_PARAMETER( pVfs );\n      return getLastErrorMsg( nBuf, ref zBuf );\n    }\n\n    static sqlite3_vfs winVfs = new sqlite3_vfs(\n    1,                              /* iVersion */\n    -1, //sqlite3_file.Length,      /* szOsFile */\n    MAX_PATH,                       /* mxPathname */\n    null,                           /* pNext */\n    "win32",                        /* zName */\n    0,                              /* pAppData */\n\n    (dxOpen)winOpen,                /* xOpen */\n    (dxDelete)winDelete,            /* xDelete */\n    (dxAccess)winAccess,            /* xAccess */\n    (dxFullPathname)winFullPathname,/* xFullPathname */\n    (dxDlOpen)winDlOpen,            /* xDlOpen */\n    (dxDlError)winDlError,          /* xDlError */\n    (dxDlSym)winDlSym,              /* xDlSym */\n    (dxDlClose)winDlClose,          /* xDlClose */\n    (dxRandomness)winRandomness,    /* xRandomness */\n    (dxSleep)winSleep,              /* xSleep */\n    (dxCurrentTime)winCurrentTime,  /* xCurrentTime */\n    (dxGetLastError)winGetLastError /* xGetLastError */\n    );\n\n    /*\n    ** Initialize and deinitialize the operating system interface.\n    */\n    static int sqlite3_os_init()\n    {\n      sqlite3_vfs_register( winVfs, 1 );\n      return SQLITE_OK;\n    }\n    static int sqlite3_os_end()\n    {\n      return SQLITE_OK;\n    }\n\n#endif // * SQLITE_OS_WIN */\n    //\n    //          Windows DLL definitions\n    //\n\n    const int NO_ERROR = 0;\n  }\n}\n'