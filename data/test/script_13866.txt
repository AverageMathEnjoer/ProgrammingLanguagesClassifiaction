b'\xef\xbb\xbf// UVa1515 Pool Construction\n// Rujia Liu\n// \xe5\x9b\xa0\xe4\xb8\xba\xe5\x9b\xbe\xe8\xbe\x83\xe5\xa4\xa7\xef\xbc\x8c\xe6\x89\x80\xe4\xbb\xa5\xe9\x87\x87\xe7\x94\xa8Dinic\xe8\x80\x8c\xe4\xb8\x8d\xe6\x98\xafEdmondsKarp\n// \xe5\xbe\x97\xe7\x9b\x8a\xe4\xba\x8e\xe6\x8e\xa5\xe5\x8f\xa3\xe4\xb8\x80\xe8\x87\xb4\xe6\x80\xa7\xef\xbc\x8c\xe8\xaf\xbb\xe8\x80\x85\xe6\x97\xa0\xe9\xa1\xbb\xe7\x90\x86\xe8\xa7\xa3Dinic\xe5\xb0\xb1\xe8\x83\xbd\xe4\xbd\xbf\xe7\x94\xa8\xe5\xae\x83\xe3\x80\x82\n#include<cstdio>\n#include<cstring>\n#include<queue>\n#include<algorithm>\nusing namespace std;\n\nconst int maxn = 50*50+10;\n\nconst int INF = 1000000000;\n\nstruct Edge {\n  int from, to, cap, flow;\n};\n\nbool operator < (const Edge& a, const Edge& b) {\n  return a.from < b.from || (a.from == b.from && a.to < b.to);\n}\n\nstruct Dinic {\n  int n, m, s, t;\n  vector<Edge> edges;    // \xe8\xbe\xb9\xe6\x95\xb0\xe7\x9a\x84\xe4\xb8\xa4\xe5\x80\x8d\n  vector<int> G[maxn];   // \xe9\x82\xbb\xe6\x8e\xa5\xe8\xa1\xa8\xef\xbc\x8cG[i][j]\xe8\xa1\xa8\xe7\xa4\xba\xe7\xbb\x93\xe7\x82\xb9i\xe7\x9a\x84\xe7\xac\xacj\xe6\x9d\xa1\xe8\xbe\xb9\xe5\x9c\xa8e\xe6\x95\xb0\xe7\xbb\x84\xe4\xb8\xad\xe7\x9a\x84\xe5\xba\x8f\xe5\x8f\xb7\n  bool vis[maxn];        // BFS\xe4\xbd\xbf\xe7\x94\xa8\n  int d[maxn];           // \xe4\xbb\x8e\xe8\xb5\xb7\xe7\x82\xb9\xe5\x88\xb0i\xe7\x9a\x84\xe8\xb7\x9d\xe7\xa6\xbb\n  int cur[maxn];         // \xe5\xbd\x93\xe5\x89\x8d\xe5\xbc\xa7\xe6\x8c\x87\xe9\x92\x88\n\n  void init(int n) {\n    for(int i = 0; i < n; i++) G[i].clear();\n    edges.clear();\n  }\n\n  void AddEdge(int from, int to, int cap) {\n    edges.push_back((Edge){from, to, cap, 0});\n    edges.push_back((Edge){to, from, 0, 0});\n    m = edges.size();\n    G[from].push_back(m-2);\n    G[to].push_back(m-1);\n  }\n\n  bool BFS() {\n    memset(vis, 0, sizeof(vis));\n    queue<int> Q;\n    Q.push(s);\n    vis[s] = 1;\n    d[s] = 0;\n    while(!Q.empty()) {\n      int x = Q.front(); Q.pop();\n      for(int i = 0; i < G[x].size(); i++) {\n        Edge& e = edges[G[x][i]];\n        if(!vis[e.to] && e.cap > e.flow) {\n          vis[e.to] = 1;\n          d[e.to] = d[x] + 1;\n          Q.push(e.to);\n        }\n      }\n    }\n    return vis[t];\n  }\n\n  int DFS(int x, int a) {\n    if(x == t || a == 0) return a;\n    int flow = 0, f;\n    for(int& i = cur[x]; i < G[x].size(); i++) {\n      Edge& e = edges[G[x][i]];\n      if(d[x] + 1 == d[e.to] && (f = DFS(e.to, min(a, e.cap-e.flow))) > 0) {\n        e.flow += f;\n        edges[G[x][i]^1].flow -= f;\n        flow += f;\n        a -= f;\n        if(a == 0) break;\n      }\n    }\n    return flow;\n  }\n\n  int Maxflow(int s, int t) {\n    this->s = s; this->t = t;\n    int flow = 0;\n    while(BFS()) {\n      memset(cur, 0, sizeof(cur));\n      flow += DFS(s, INF);\n    }\n    return flow;\n  }\n};\n\nDinic g;\n\nint w, h;\nchar pool[99][99];\n\ninline int ID(int i, int j) { return i*w+j; }\n\nint main() {\n  int T, d, f, b;\n  scanf("%d", &T);\n  while(T--) {\n    scanf("%d%d%d%d%d", &w, &h, &d, &f, &b);\n    for(int i = 0; i < h; i++) scanf("%s", pool[i]);\n    int cost = 0;\n    for(int i = 0; i < h; i++) {\n      if(pool[i][0] == \'.\') { pool[i][0] = \'#\'; cost += f; }\n      if(pool[i][w-1] == \'.\') { pool[i][w-1] = \'#\'; cost += f; }\n    }\n    for(int i = 0; i < w; i++) {\n      if(pool[0][i] == \'.\') { pool[0][i] = \'#\'; cost += f; }\n      if(pool[h-1][i] == \'.\') { pool[h-1][i] = \'#\'; cost += f; }\n    }\n    g.init(h*w+2);\n   \n    for(int i = 0; i < h; i++)\n      for(int j = 0; j < w; j++){\n        if(pool[i][j] == \'#\') { // grass\n          int cap = INF;\n          if(i != 0 && i != h-1 && j != 0 && j != w-1) cap = d;\n          g.AddEdge(h*w, ID(i,j), cap); // s->grass, cap=d or inf\n        } else { // hole\n          g.AddEdge(ID(i,j), h*w+1, f); // hole->t, cap=f\n        }\n        if(i > 0)   g.AddEdge(ID(i,j), ID(i-1,j), b);\n        if(i < h-1) g.AddEdge(ID(i,j), ID(i+1,j), b);\n        if(j > 0)   g.AddEdge(ID(i,j), ID(i,j-1), b);\n        if(j < w-1) g.AddEdge(ID(i,j), ID(i,j+1), b);\n      }\n    printf("%d\\n", cost + g.Maxflow(h*w, h*w+1));\n  }\n  return 0;\n}\n'