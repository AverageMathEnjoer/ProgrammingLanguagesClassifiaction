b'{-# OPTIONS_GHC -fno-warn-orphans #-}\n{-# LANGUAGE UndecidableInstances #-}\n{-# LANGUAGE LambdaCase #-}\n{-# LANGUAGE TupleSections #-}\n{-# LANGUAGE CPP #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n\n-- | Module providing (almost) full support for Postgres query and data\n-- manipulation statements. These functions shadow the functions in\n-- "Database.Beam.Query" and provide a strict superset of functionality. They\n-- map 1-to-1 with the underlying Postgres support.\nmodule Database.Beam.Postgres.Full\n  ( -- * Additional @SELECT@ features\n\n    -- ** @SELECT@ Locking clause\n    PgWithLocking, PgLockedTables\n  , PgSelectLockingStrength(..), PgSelectLockingOptions(..)\n  , lockingAllTablesFor_, lockingFor_\n\n  , locked_, lockAll_, withLocks_\n\n  -- ** Lateral joins\n  , lateral_\n\n  -- * @INSERT@ and @INSERT RETURNING@\n  , insert, insertReturning\n  , insertDefaults\n  , runPgInsertReturningList\n\n  , PgInsertReturning(..)\n\n  -- ** Specifying conflict actions\n\n  , PgInsertOnConflict(..)\n\n  , onConflictDefault, onConflict\n  , conflictingConstraint\n  , BeamHasInsertOnConflict(..)\n  , onConflictUpdateAll\n  , onConflictUpdateInstead\n\n  -- * @UPDATE RETURNING@\n  , PgUpdateReturning(..)\n  , runPgUpdateReturningList\n  , updateReturning\n\n  -- * @DELETE RETURNING@\n  , PgDeleteReturning(..)\n  , runPgDeleteReturningList\n  , deleteReturning\n\n  -- * Generalized @RETURNING@\n  , PgReturning(..)\n  ) where\n\nimport           Database.Beam hiding (insert, insertValues)\nimport           Database.Beam.Query.Internal\nimport           Database.Beam.Backend.SQL\nimport           Database.Beam.Backend.SQL.BeamExtensions\nimport           Database.Beam.Schema.Tables\n\nimport           Database.Beam.Postgres.Types\nimport           Database.Beam.Postgres.Syntax\n\nimport           Control.Monad.Free.Church\n\nimport           Data.Proxy (Proxy(..))\nimport qualified Data.Text as T\n#if !MIN_VERSION_base(4, 11, 0)\nimport           Data.Semigroup\n#endif\n\n-- * @SELECT@\n\n-- | An explicit lock against some tables. You can create a value of this type using the \'locked_\'\n-- function. You can combine these values monoidally to combine multiple locks for use with the\n-- \'withLocks_\' function.\nnewtype PgLockedTables s = PgLockedTables [ T.Text ]\n  deriving (Semigroup, Monoid)\n\n-- | Combines the result of a query along with a set of locked tables. Used as a\n-- return value for the \'lockingFor_\' function.\ndata PgWithLocking s a = PgWithLocking (PgLockedTables s) a\ninstance ProjectibleWithPredicate c be res a => ProjectibleWithPredicate c be res (PgWithLocking s a) where\n  project\' p be mutateM (PgWithLocking tbls a) =\n    PgWithLocking tbls <$> project\' p be mutateM a\n\n  projectSkeleton\' ctxt be mkM =\n    PgWithLocking mempty <$> projectSkeleton\' ctxt be mkM\n\n-- | Use with \'lockingFor_\' to lock all tables mentioned in the query\nlockAll_ :: a -> PgWithLocking s a\nlockAll_ = PgWithLocking mempty\n\n-- | Return and lock the given tables. Typically used as an infix operator. See the\n-- <https://haskell-beam.github.io/beam/user-guide/backends/beam-postgres/ the user guide> for usage\n-- examples\nwithLocks_ :: a -> PgLockedTables s -> PgWithLocking s a\nwithLocks_ = flip PgWithLocking\n\n-- | Join with a table while locking it explicitly. Provides a \'PgLockedTables\' value that can be\n-- used with \'withLocks_\' to explicitly lock a table during a @SELECT@ statement\nlocked_ :: (Beamable tbl, Database Postgres db)\n        => DatabaseEntity Postgres db (TableEntity tbl)\n        -> Q Postgres db s (PgLockedTables s, tbl (QExpr Postgres s))\nlocked_ (DatabaseEntity dt) = do\n  (nm, joined) <- Q (liftF (QAll (\\_ -> fromTable (tableNamed (tableName (dbTableSchema dt) (dbTableCurrentName dt))) .\n                                        Just . (,Nothing))\n                                 (tableFieldsToExpressions (dbTableSettings dt))\n                                 (\\_ -> Nothing) id))\n  pure (PgLockedTables [nm], joined)\n\n-- | Lock some tables during the execution of a query. This is rather complicated, and there are\n-- several usage examples in\n-- <https://haskell-beam.github.io/beam/user-guide/backends/beam-postgres/ the user guide>\n--\n-- The Postgres locking clause is rather complex, and beam currently does not check several\n-- pre-conditions. It is assumed you kinda know what you\'re doing.\n--\n-- Things which postgres doesn\'t like, but beam will do\n--\n-- * Using aggregates within a query that has a locking clause\n-- * Using @UNION@, @INTERSECT@, or @EXCEPT@\n--\n--   See <https://www.postgresql.org/docs/10/static/sql-select.html#SQL-FOR-UPDATE-SHARE here> for\n--   more details.\n--\n-- This function accepts a locking strength (@UPDATE@, @SHARE@, @KEY SHARE@, etc), an optional\n-- locking option (@NOWAIT@ or @SKIP LOCKED@), and a query whose rows to lock. The query should\n-- return its result wrapped in \'PgWithLocking\', via the `withLocks_` or `lockAll_` function.\n--\n-- If you want to use the most common behavior (lock all rows in every table mentioned), the\n-- \'lockingAllTablesFor_\' function may be what you\'re after.\nlockingFor_ :: forall a db s\n             . ( Database Postgres db, Projectible Postgres a, ThreadRewritable (QNested s) a )\n            => PgSelectLockingStrength\n            -> Maybe PgSelectLockingOptions\n            -> Q Postgres db (QNested s) (PgWithLocking (QNested s) a)\n            -> Q Postgres db s (WithRewrittenThread (QNested s) s a)\nlockingFor_ lockStrength mLockOptions (Q q) =\n  Q (liftF (QForceSelect (\\(PgWithLocking (PgLockedTables tblNms) _) tbl ords limit offset ->\n                            let locking = PgSelectLockingClauseSyntax lockStrength tblNms mLockOptions\n                            in pgSelectStmt tbl ords limit offset (Just locking))\n                         q (\\(PgWithLocking _ a) -> rewriteThread (Proxy @s) a)))\n\n-- | Like \'lockingFor_\', but does not require an explicit set of locked tables. This produces an\n-- empty @FOR .. OF@ clause.\nlockingAllTablesFor_ :: ( Database Postgres db, Projectible Postgres a, ThreadRewritable (QNested s) a )\n                     => PgSelectLockingStrength\n                     -> Maybe PgSelectLockingOptions\n                     -> Q Postgres db (QNested s) a\n                     -> Q Postgres db s (WithRewrittenThread (QNested s) s a)\nlockingAllTablesFor_ lockStrength mLockOptions q =\n  lockingFor_ lockStrength mLockOptions (lockAll_ <$> q)\n\n-- * @INSERT@\n\n-- | The Postgres @DEFAULT VALUES@ clause for the @INSERT@ command.\ninsertDefaults :: SqlInsertValues Postgres tbl\ninsertDefaults = SqlInsertValues (PgInsertValuesSyntax (emit "DEFAULT VALUES"))\n\n-- | A @beam-postgres@-specific version of \'Database.Beam.Query.insert\', which\n-- provides fuller support for the much richer Postgres @INSERT@ syntax. This\n-- allows you to specify @ON CONFLICT@ actions. For even more complete support,\n-- see \'insertReturning\'.\ninsert :: DatabaseEntity Postgres db (TableEntity table)\n       -> SqlInsertValues Postgres (table (QExpr Postgres s)) -- TODO arbitrary projectibles\n       -> PgInsertOnConflict table\n       -> SqlInsert Postgres table\ninsert tbl@(DatabaseEntity dt@(DatabaseTable {})) values onConflict_ =\n  case insertReturning tbl values onConflict_\n         (Nothing :: Maybe (table (QExpr Postgres PostgresInaccessible) -> QExpr Postgres PostgresInaccessible Int)) of\n    PgInsertReturning a ->\n      SqlInsert (dbTableSettings dt) (PgInsertSyntax a)\n    PgInsertReturningEmpty ->\n      SqlInsertNoRows\n\n-- | The most general kind of @INSERT@ that postgres can perform\ndata PgInsertReturning a\n  = PgInsertReturning PgSyntax\n  | PgInsertReturningEmpty\n\n-- | The full Postgres @INSERT@ syntax, supporting conflict actions and the\n-- @RETURNING CLAUSE@. See \'PgInsertOnConflict\' for how to specify a conflict\n-- action or provide \'onConflictDefault\' to preserve the behavior without any\n-- @ON CONFLICT@ clause. The last argument takes a newly inserted row and\n-- returns the expression to be returned as part of the @RETURNING@ clause. For\n-- a backend-agnostic version of this functionality see\n-- \'MonadBeamInsertReturning\'. Use \'runInsertReturning\' to get the results.\ninsertReturning :: Projectible Postgres a\n                => DatabaseEntity Postgres be (TableEntity table)\n                -> SqlInsertValues Postgres (table (QExpr Postgres s))\n                -> PgInsertOnConflict table\n                -> Maybe (table (QExpr Postgres PostgresInaccessible) -> a)\n                -> PgInsertReturning (QExprToIdentity a)\n\ninsertReturning _ SqlInsertValuesEmpty _ _ = PgInsertReturningEmpty\ninsertReturning (DatabaseEntity tbl@(DatabaseTable {}))\n                (SqlInsertValues (PgInsertValuesSyntax insertValues_))\n                (PgInsertOnConflict mkOnConflict)\n                mMkProjection =\n  PgInsertReturning $\n  emit "INSERT INTO " <> fromPgTableName (tableName (dbTableSchema tbl) (dbTableCurrentName tbl)) <>\n  emit "(" <> pgSepBy (emit ", ") (allBeamValues (\\(Columnar\' f) -> pgQuotedIdentifier (_fieldName f)) tblSettings) <> emit ") " <>\n  insertValues_ <> emit " " <> fromPgInsertOnConflict (mkOnConflict tblFields) <>\n  (case mMkProjection of\n     Nothing -> mempty\n     Just mkProjection ->\n         emit " RETURNING " <>\n         pgSepBy (emit ", ") (map fromPgExpression (project (Proxy @Postgres) (mkProjection tblQ) "t")))\n   where\n     tblQ = changeBeamRep (\\(Columnar\' f) -> Columnar\' (QExpr (\\_ -> fieldE (unqualifiedField (_fieldName f))))) tblSettings\n     tblFields = changeBeamRep (\\(Columnar\' f) -> Columnar\' (QField True (dbTableCurrentName tbl) (_fieldName f))) tblSettings\n\n     tblSettings = dbTableSettings tbl\n\nrunPgInsertReturningList\n  :: ( MonadBeam be m\n     , BeamSqlBackendSyntax be ~ PgCommandSyntax\n     , FromBackendRow be a\n     )\n  => PgInsertReturning a\n  -> m [a]\nrunPgInsertReturningList = \\case\n  PgInsertReturningEmpty -> pure []\n  PgInsertReturning syntax -> runReturningList $ PgCommandSyntax PgCommandTypeDataUpdateReturning syntax\n\n-- ** @ON CONFLICT@ clause\n\n-- | What to do when an @INSERT@ statement inserts a row into the table @tbl@\n-- that violates a constraint.\nnewtype PgInsertOnConflict (tbl :: (* -> *) -> *) =\n    PgInsertOnConflict (tbl (QField QInternal) -> PgInsertOnConflictSyntax)\n\n-- | Postgres @LATERAL JOIN@ support\n--\n-- Allows the use of variables introduced on the left side of a @JOIN@ to be used on the right hand\n-- side.\n--\n-- Because of the default scoping rules, we can\'t use the typical monadic bind (@>>=@) operator to\n-- create this join.\n--\n-- Instead, \'lateral_\'  takes two  arguments. The first  is the  left hand side  of the  @JOIN@. The\n-- second is a function that  takes the result of the first join and  uses those variables to create\n-- the right hand side.\n--\n-- For example, to join table A with a subquery that returns the first three rows in B which matches\n-- a column in A, ordered by another column in B:\n--\n-- > lateral_ (_tableA database) $ \\tblA ->\n-- >   limit_ 3 $\n-- >   ordering_ (\\(_, b) -> asc_ (_bField2 b)) $ do\n-- >     b <- _tableB database\n-- >     guard_ (_bField1 b ==. _aField1 a)\n-- >     pure (a, b0\nlateral_ :: forall s a b db\n          . ( ThreadRewritable s a, ThreadRewritable (QNested s) b, Projectible Postgres b )\n         => a -> (WithRewrittenThread s (QNested s) a -> Q Postgres db (QNested s) b)\n         -> Q Postgres db s (WithRewrittenThread (QNested s) s b)\nlateral_ using mkSubquery = do\n  let Q subquery = mkSubquery (rewriteThread (Proxy @(QNested s)) using)\n  Q (liftF (QArbitraryJoin subquery\n                           "lat_"\n                           (\\a b on\' ->\n                              case on\' of\n                                Nothing ->\n                                  PgFromSyntax $\n                                  fromPgFrom a <> emit " CROSS JOIN LATERAL " <> fromPgFrom b\n                                Just on\'\' ->\n                                  PgFromSyntax $\n                                  fromPgFrom a <> emit " JOIN LATERAL " <> fromPgFrom b <> emit " ON " <> fromPgExpression on\'\')\n                           (\\_ -> Nothing)\n                           (rewriteThread (Proxy @s))))\n\n-- | By default, Postgres will throw an error when a conflict is detected. This\n-- preserves that functionality.\nonConflictDefault :: PgInsertOnConflict tbl\nonConflictDefault = PgInsertOnConflict (\\_ -> PgInsertOnConflictSyntax mempty)\n\n-- | Tells postgres what to do on an @INSERT@ conflict. The first argument is\n-- the type of conflict to provide an action for. For example, to only provide\n-- an action for certain fields, use \'conflictingFields\'. Or to only provide an\n-- action over certain fields where a particular condition is met, use\n-- \'conflictingFields\'. If you have a particular constraint violation in mind,\n-- use \'conflictingConstraint\'. To perform an action on any conflict, use\n-- \'anyConflict\'.\n--\n-- See the\n-- <https://www.postgresql.org/docs/current/static/sql-insert.html Postgres documentation>.\nonConflict :: Beamable tbl\n           => SqlConflictTarget Postgres tbl\n           -> SqlConflictAction Postgres tbl\n           -> PgInsertOnConflict tbl\nonConflict (PgInsertOnConflictTarget tgt) (PgConflictAction update_) =\n  PgInsertOnConflict $ \\tbl ->\n  let exprTbl = changeBeamRep (\\(Columnar\' (QField _ _ nm)) ->\n                                 Columnar\' (QExpr (\\_ -> fieldE (unqualifiedField nm))))\n                              tbl\n  in PgInsertOnConflictSyntax $\n     emit "ON CONFLICT " <> fromPgInsertOnConflictTarget (tgt exprTbl)\n                         <> fromPgConflictAction (update_ tbl)\n\n-- | Perform the action only if the given named constraint is violated\nconflictingConstraint :: T.Text -> SqlConflictTarget Postgres tbl\nconflictingConstraint nm =\n  PgInsertOnConflictTarget $ \\_ ->\n  PgInsertOnConflictTargetSyntax $\n  emit "ON CONSTRAINT " <> pgQuotedIdentifier nm <> emit " "\n\n-- * @UPDATE@\n\n-- | The most general kind of @UPDATE@ that postgres can perform\n--\n-- You can build this from a \'SqlUpdate\' by using \'returning\'\n--\n-- > update tbl where `returning` projection\n--\n-- Run the result with \'runPgUpdateReturningList\'\ndata PgUpdateReturning a\n  = PgUpdateReturning PgSyntax\n  | PgUpdateReturningEmpty\n\n-- | Postgres @UPDATE ... RETURNING@ statement support. The last\n-- argument takes the newly inserted row and returns the values to be\n-- returned. Use \'runUpdateReturning\' to get the results.\nupdateReturning :: Projectible Postgres a\n                => DatabaseEntity Postgres be (TableEntity table)\n                -> (forall s. table (QField s) -> QAssignment Postgres s)\n                -> (forall s. table (QExpr Postgres s) -> QExpr Postgres s Bool)\n                -> (table (QExpr Postgres PostgresInaccessible) -> a)\n                -> PgUpdateReturning (QExprToIdentity a)\nupdateReturning table@(DatabaseEntity (DatabaseTable { dbTableSettings = tblSettings }))\n                mkAssignments\n                mkWhere\n                mkProjection =\n  case update table mkAssignments mkWhere of\n    SqlUpdate _ pgUpdate ->\n      PgUpdateReturning $\n      fromPgUpdate pgUpdate <>\n      emit " RETURNING " <>\n      pgSepBy (emit ", ") (map fromPgExpression (project (Proxy @Postgres) (mkProjection tblQ) "t"))\n\n    SqlIdentityUpdate -> PgUpdateReturningEmpty\n  where\n    tblQ = changeBeamRep (\\(Columnar\' f) -> Columnar\' (QExpr (pure (fieldE (unqualifiedField (_fieldName f)))))) tblSettings\n\nrunPgUpdateReturningList\n  :: ( MonadBeam be m\n     , BeamSqlBackendSyntax be ~ PgCommandSyntax\n     , FromBackendRow be a\n     )\n  => PgUpdateReturning a\n  -> m [a]\nrunPgUpdateReturningList = \\case\n  PgUpdateReturningEmpty -> pure []\n  PgUpdateReturning syntax -> runReturningList $ PgCommandSyntax PgCommandTypeDataUpdateReturning syntax\n\n-- * @DELETE@\n\n-- | The most general kind of @DELETE@ that postgres can perform\n--\n-- You can build this from a \'SqlDelete\' by using \'returning\'\n--\n-- > delete tbl where `returning` projection\n--\n-- Run the result with \'runPgDeleteReturningList\'\nnewtype PgDeleteReturning a = PgDeleteReturning PgSyntax\n\n-- | Postgres @DELETE ... RETURNING@ statement support. The last\n-- argument takes the newly inserted row and returns the values to be\n-- returned. Use \'runDeleteReturning\' to get the results.\ndeleteReturning :: Projectible Postgres a\n                => DatabaseEntity Postgres be (TableEntity table)\n                -> (forall s. table (QExpr Postgres s) -> QExpr Postgres s Bool)\n                -> (table (QExpr Postgres PostgresInaccessible) -> a)\n                -> PgDeleteReturning (QExprToIdentity a)\ndeleteReturning table@(DatabaseEntity (DatabaseTable { dbTableSettings = tblSettings }))\n                mkWhere\n                mkProjection =\n  PgDeleteReturning $\n  fromPgDelete pgDelete <>\n  emit " RETURNING " <>\n  pgSepBy (emit ", ") (map fromPgExpression (project (Proxy @Postgres) (mkProjection tblQ) "t"))\n  where\n    SqlDelete _ pgDelete = delete table $ \\t -> mkWhere t\n    tblQ = changeBeamRep (\\(Columnar\' f) -> Columnar\' (QExpr (pure (fieldE (unqualifiedField (_fieldName f)))))) tblSettings\n\nrunPgDeleteReturningList\n  :: ( MonadBeam be m\n     , BeamSqlBackendSyntax be ~ PgCommandSyntax\n     , FromBackendRow be a\n     )\n  => PgDeleteReturning a\n  -> m [a]\nrunPgDeleteReturningList (PgDeleteReturning syntax) = runReturningList $ PgCommandSyntax PgCommandTypeDataUpdateReturning syntax\n\n-- * General @RETURNING@ support\n\nclass PgReturning cmd where\n  type PgReturningType cmd :: * -> *\n\n  returning :: (Beamable tbl, Projectible Postgres a)\n            => cmd Postgres tbl -> (tbl (QExpr Postgres PostgresInaccessible) -> a)\n            -> PgReturningType cmd (QExprToIdentity a)\n\ninstance PgReturning SqlInsert where\n  type PgReturningType SqlInsert = PgInsertReturning\n\n  returning SqlInsertNoRows _ = PgInsertReturningEmpty\n  returning (SqlInsert tblSettings (PgInsertSyntax syntax)) mkProjection =\n    PgInsertReturning $\n    syntax <> emit " RETURNING " <>\n    pgSepBy (emit ", ") (map fromPgExpression (project (Proxy @Postgres) (mkProjection tblQ) "t"))\n\n    where\n      tblQ = changeBeamRep (\\(Columnar\' f) -> Columnar\' (QExpr . pure . fieldE . unqualifiedField . _fieldName $ f)) tblSettings\n\ninstance PgReturning SqlUpdate where\n  type PgReturningType SqlUpdate = PgUpdateReturning\n\n  returning SqlIdentityUpdate _ = PgUpdateReturningEmpty\n  returning (SqlUpdate tblSettings (PgUpdateSyntax syntax)) mkProjection =\n    PgUpdateReturning $\n    syntax <> emit " RETURNING " <>\n    pgSepBy (emit ", ") (map fromPgExpression (project (Proxy @Postgres) (mkProjection tblQ) "t"))\n\n    where\n      tblQ = changeBeamRep (\\(Columnar\' f) -> Columnar\' (QExpr . pure . fieldE . unqualifiedField . _fieldName $ f)) tblSettings\n\ninstance PgReturning SqlDelete where\n  type PgReturningType SqlDelete = PgDeleteReturning\n\n  returning (SqlDelete tblSettings (PgDeleteSyntax syntax)) mkProjection =\n    PgDeleteReturning $\n    syntax <> emit " RETURNING " <>\n    pgSepBy (emit ", ") (map fromPgExpression (project (Proxy @Postgres) (mkProjection tblQ) "t"))\n\n    where\n      tblQ = changeBeamRep (\\(Columnar\' f) -> Columnar\' (QExpr . pure . fieldE . unqualifiedField . _fieldName $ f)) tblSettings\n\ninstance BeamHasInsertOnConflict Postgres where\n  newtype SqlConflictTarget Postgres table =\n    PgInsertOnConflictTarget (table (QExpr Postgres QInternal) -> PgInsertOnConflictTargetSyntax)\n  newtype SqlConflictAction Postgres table =\n    PgConflictAction (table (QField QInternal) -> PgConflictActionSyntax)\n\n  insertOnConflict tbl vs target action = insert tbl vs $ onConflict target action\n\n  -- | Perform the conflict action when any constraint or index conflict occurs.\n  -- Syntactically, this is the @ON CONFLICT@ clause, without any /conflict target/.\n  anyConflict = PgInsertOnConflictTarget (\\_ -> PgInsertOnConflictTargetSyntax mempty)\n\n  -- | The Postgres @DO NOTHING@ action\n  onConflictDoNothing = PgConflictAction $ \\_ -> PgConflictActionSyntax (emit "DO NOTHING")\n\n  -- | The Postgres @DO UPDATE SET@ action, without the @WHERE@ clause. The\n  -- argument takes an updatable row (like the one used in \'update\') and the\n  -- conflicting row. Use \'current_\' on the first argument to get the current\n  -- value of the row in the database.\n  onConflictUpdateSet mkAssignments =\n    PgConflictAction $ \\tbl ->\n    let QAssignment assignments = mkAssignments tbl tblExcluded\n        tblExcluded = changeBeamRep (\\(Columnar\' (QField _ _ nm)) -> Columnar\' (QExpr (\\_ -> fieldE (qualifiedField "excluded" nm)))) tbl\n\n        assignmentSyntaxes =\n          [ fromPgFieldName fieldNm <> emit "=" <> pgParens (fromPgExpression expr)\n          | (fieldNm, expr) <- assignments ]\n    in PgConflictActionSyntax $\n       emit "DO UPDATE SET " <> pgSepBy (emit ", ") assignmentSyntaxes\n\n  -- | The Postgres @DO UPDATE SET@ action, with the @WHERE@ clause. This is like\n  -- \'onConflictUpdateSet\', but only rows satisfying the given condition are\n  -- updated. Sometimes this results in more efficient locking. See the Postgres\n  -- <https://www.postgresql.org/docs/current/static/sql-insert.html manual> for\n  -- more information.\n  onConflictUpdateSetWhere mkAssignments where_ =\n    PgConflictAction $ \\tbl ->\n    let QAssignment assignments = mkAssignments tbl tblExcluded\n        QExpr where_\' = where_ tbl tblExcluded\n        tblExcluded = changeBeamRep (\\(Columnar\' (QField _ _ nm)) -> Columnar\' (QExpr (\\_ -> fieldE (qualifiedField "excluded" nm)))) tbl\n\n        assignmentSyntaxes =\n          [ fromPgFieldName fieldNm <> emit "=" <> pgParens (fromPgExpression expr)\n          | (fieldNm, expr) <- assignments ]\n    in PgConflictActionSyntax $\n       emit "DO UPDATE SET " <> pgSepBy (emit ", ") assignmentSyntaxes <> emit " WHERE " <> fromPgExpression (where_\' "t")\n\n  -- | Perform the conflict action only when these fields conflict. The first\n  -- argument gets the current row as a table of expressions. Return the conflict\n  -- key. For more information, see the @beam-postgres@ manual.\n  conflictingFields makeProjection =\n    PgInsertOnConflictTarget $ \\tbl ->\n    PgInsertOnConflictTargetSyntax $\n    pgParens (pgSepBy (emit ", ") $\n              map fromPgExpression $\n              project (Proxy @Postgres) (makeProjection tbl) "t") <>\n    emit " "\n\n  -- | Like \'conflictingFields\', but only perform the action if the condition\n  -- given in the second argument is met. See the postgres\n  -- <https://www.postgresql.org/docs/current/static/sql-insert.html manual> for\n  -- more information.\n  conflictingFieldsWhere makeProjection makeWhere =\n    PgInsertOnConflictTarget $ \\tbl ->\n    PgInsertOnConflictTargetSyntax $\n    pgParens (pgSepBy (emit ", ") $\n              map fromPgExpression (project (Proxy @Postgres)\n                                            (makeProjection tbl) "t")) <>\n    emit " WHERE " <>\n    pgParens (let QExpr mkE = makeWhere tbl\n                  PgExpressionSyntax e = mkE "t"\n              in e) <>\n    emit " "\n'