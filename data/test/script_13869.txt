b'/*\n * Copyright 2013 - 2016 Mario Arias\n *\n * Licensed under the Apache License, Version 2.0 (the "License");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * \thttp://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an "AS IS" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.funktionale.tries\n\nimport org.assertj.core.api.Assertions.assertThat\nimport org.assertj.core.api.Assertions.assertThatThrownBy\nimport org.funktionale.tries.Try.Failure\nimport org.funktionale.tries.Try.Success\nimport org.testng.Assert.*\nimport org.testng.annotations.Test\n\n\nclass TryTest {\n    val success = Try { "10".toInt() }\n    val failure = Try { "NaN".toInt() }\n\n    @Test fun show() {\n        val problem = success.flatMap { x -> failure.map { y -> x / y } }\n        when (problem) {\n            is Success -> fail("This should not be possible")\n            is Failure -> println(problem)\n        }\n    }\n\n    @Test fun get() {\n        assertEquals(10, success())\n        try {\n            failure()\n            fail()\n        } catch (e: Exception) {\n            assertTrue(e is NumberFormatException)\n        }\n    }\n\n    @Test fun getOrElse() {\n        assertEquals(success.getOrElse { 5 }, 10)\n        assertEquals(failure.getOrElse { 5 }, 5)\n    }\n\n    @Test fun orElse() {\n        assertEquals(success.orElse { Success(5) }.get(), 10)\n        assertEquals(failure.orElse { Success(5) }.get(), 5)\n    }\n\n    @Test fun `foreach with side effect (applied on Success)`() {\n        var wasInside = false\n        success.foreach { wasInside = true }\n        assertThat(wasInside).isTrue()\n    }\n\n    @Test fun `foreach with side effect (applied on Failure)`() {\n        var wasInside = false\n        failure.foreach { wasInside = true }\n        assertThat(wasInside).isFalse()\n    }\n\n    @Test fun `foreach with exception thrown inside (applied on Success)`() {\n        assertThatThrownBy {\n            success.foreach { throw RuntimeException("thrown inside") }\n        }.hasMessage("thrown inside")\n    }\n\n    @Test fun `foreach with exception thrown inside (applied on Failure)`() {\n        failure.foreach { throw RuntimeException("thrown inside") }\n        // and no exception should be thrown\n    }\n\n    @Test fun `onEach with side effect (applied on Success)`() {\n        var wasInside = false\n        success.onEach { wasInside = true }\n        assertThat(wasInside).isTrue()\n    }\n\n    @Test fun `onEach with side effect (applied on Failure)`() {\n        var wasInside = false\n        failure.onEach { wasInside = true }\n        assertThat(wasInside).isFalse()\n    }\n\n    @Test fun `onEach with exception thrown inside (applied on Success)`() {\n        assertThatThrownBy {\n            success.onEach { throw RuntimeException("thrown inside") }.get()\n        }.hasMessage("thrown inside")\n    }\n\n    @Test fun `onEach with exception thrown inside (applied on Failure)`() {\n        assertThatThrownBy {\n            failure.onEach { throw RuntimeException("thrown inside") }.get()\n        }.isInstanceOf(NumberFormatException::class.java)\n    }\n\n    @Test fun `onEach with change of carried value (applied on Success)`() {\n        val result = success.onEach { it * 2 }.get()\n        assertThat(result).isEqualTo(10)\n    }\n\n    @Test fun `onEach with change of carried value (applied on Failure)`() {\n        assertThatThrownBy {\n            failure.onEach { it * 2 }.get()\n        }.isInstanceOf(NumberFormatException::class.java)\n    }\n\n    @Test fun flatMap() {\n        assertEquals(success.flatMap { Success(it * 2) }.get(), 20)\n        assertTrue(failure.flatMap { Success(it * 2) }.isFailure())\n    }\n\n    @Test fun map() {\n        assertEquals(success.map { it * 2 }.get(), 20)\n        assertTrue(failure.map { it * 2 }.isFailure())\n    }\n\n    @Test fun exists() {\n        assertTrue(success.exists { it > 5 })\n        assertFalse(failure.exists { it > 5 })\n    }\n\n    @Test fun filter() {\n        assertTrue(success.filter { it > 5 }.isSuccess())\n        assertTrue(success.filter { it < 5 }.isFailure())\n        assertFalse(failure.filter { it > 5 }.isSuccess())\n    }\n\n    @Test fun rescue() {\n        assertEquals(success.rescue { Success(5) }.get(), 10)\n        assertEquals(failure.rescue { Success(5) }.get(), 5)\n    }\n\n    @Test fun handle() {\n        assertEquals(success.handle { 5 }.get(), 10)\n        assertEquals(failure.handle { 5 }.get(), 5)\n    }\n\n    @Test fun onSuccessAndOnFailure() {\n        success.onSuccess { assertEquals(it, 10) }\n                .onFailure { fail() }\n        failure.onSuccess { fail() }\n                .onFailure { }\n    }\n\n    @Test fun toOption() {\n        assertTrue(success.toOption().isDefined())\n        assertTrue(failure.toOption().isEmpty())\n    }\n\n    @Test fun toDisjunction() {\n        assertTrue(success.toDisjunction().isRight())\n        assertTrue(failure.toDisjunction().isLeft())\n    }\n\n    @Test fun failed() {\n        success.failed().onFailure { assertTrue(it is UnsupportedOperationException) }\n        failure.failed().onSuccess { assertTrue(it is NumberFormatException) }\n    }\n\n    @Test fun transform() {\n        assertEquals(success.transform({ Try { it.toString() } }) { Try { "NaN" } }.get(), "10")\n        assertEquals(failure.transform({ Try { it.toString() } }) { Try { "NaN" } }.get(), "NaN")\n    }\n\n    @Test fun fold() {\n        assertEquals(success.fold(Int::toString) { "NaN" }, "10")\n        assertEquals(success.fold({ throw RuntimeException("Fire($it)!!") }) { "NaN" }, "NaN")\n        assertEquals(failure.fold(Int::toString) { "NaN" }, "NaN")\n    }\n\n    @Test fun flatten() {\n        assertTrue(Try { success }.flatten().isSuccess())\n        assertTrue(Try { failure }.flatten().isFailure())\n        assertTrue(Try<Try<Int>> { throw RuntimeException("") }.flatten().isFailure())\n    }\n}'