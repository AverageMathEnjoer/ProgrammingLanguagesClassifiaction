b'#\' clusterMatch\n#\'\n#\' Creates properly sized clusters for matching, using either\n#\' alphabetical or word embedding clustering. If using word embedding,\n#\' the function first creates a word embedding out of the provided\n#\' vectors, and then runs PCA on the matrix. It then takes the first\n#\' \\code{k} dimensions (where \\code{k} is provided by the user) and\n#\' k-means is run on that matrix to get the clusters.\n#\'\n#\' @usage clusterMatch(vecA, vecB, nclusters, max.n, word.embed, min.var,\n#\' weighted.kmeans, iter.max)\n#\'\n#\' @param vecA The character vector from dataset A\n#\' @param vecB The character vector from dataset B\n#\' @param nclusters The number of clusters to create from the provided data. Either\n#\' nclusters = NULL or max.n = NULL.\n#\' @param max.n The maximum size of either dataset A or dataset B in\n#\' the largest cluster. Either nclusters = NULL or max.n = NULL\n#\' @param word.embed Whether to use word embedding clustering. Default is FALSE.\n#\' @param min.var The minimum amount of explained variance (maximum = 1) a\n#\' PCA dimension can provide in order to be included in k-means clustering when\n#\' using word embedding. Default is .20.\n#\' @param weighted.kmeans Whether to weight the k-means algorithm features by the\n#\' explained variance of the included principal component when using word\n#\' embedding clustering. Default is FALSE.\n#\' @param iter.max Maximum number of iterations for the k-means algorithm.\n#\'\n#\' @return \\code{clusterMatch} returns a list of length 3:\n#\' \\item{clusterA}{The cluster assignments for dataset A}\n#\' \\item{clusterB}{The cluster assignments for dataset B}\n#\' \\item{n.clusters}{The number of clusters created}\n#\' \\item{kmeans}{The k-means object output.}\n#\' \\item{pca}{The PCA object output.}\n#\' \\item{dims.pca}{The number of dimensions from PCA used for the k-means clustering.}\n#\'\n#\' @author Ben Fifield <benfifield@gmail.com>\n#\'\n#\' @examples data(samplematch)\n#\' cl <- clusterMatch(dfA$firstname, dfB$firstname, nclusters = 3)\n#\' @export\n#\' @importFrom FactoClass kmeansW\n#\' @importFrom stringr str_count\nclusterMatch <- function(vecA, vecB,\n                         nclusters = NULL, max.n = NULL,\n                         word.embed = FALSE,\n                         min.var = .20,\n                         weighted.kmeans = FALSE,\n                         iter.max = 5000){\n\n    ## Warning\n    if(is.null(nclusters) & is.null(max.n)){\n        stop("Please provide either the number of clusters (\'nclusters\') to create or the maximum n of each cluster (\'max.n\') as an argument.")\n    }\n\n    ## Clean and combine\n    if(class(vecA) == "factor"){\n        vecA <- as.character(vecA)\n    }\n    if(class(vecB) == "factor"){\n        vecB <- as.character(vecB)\n    }\n    setid <- c(rep(1, length(vecA)), rep(2, length(vecB)))\n    vec <- c(vecA, vecB)\n\n    ## ------------------------\n    ## Which type of clustering\n    ## ------------------------\n    if(word.embed){   \n        ## Create word embedding\n        out <- sapply(letters, function(x){str_count(vec, x)})\n\n        ## Do pca\n        pca.out <- prcomp(out, scale = TRUE)\n        pred <- predict(pca.out, out)\n\n        ## Get difference in variances\n        vars <- apply(pca.out$x, 2, var)  \n        props <- vars / sum(vars)\n        cs.var <- cumsum(props)\n        diffs <- diff(cs.var)\n        dims.include <- c(1, which(diffs > min.var) + 1)\n\n        ## Get first K dimensions\n        dims <- pred[,1:dims.include]\n    }else{\n        dims <- as.numeric(as.factor(vec))\n        weighted.kmeans <- FALSE\n    }\n\n    ## ----------\n    ## Run kmeans\n    ## ----------\n    if(!is.null(nclusters)){\n        ncl <- nclusters\n    }else{\n        ncl <- max(round(max(length(vecA), length(vecB))/max.n, 0), 1)\n    }\n    if(weighted.kmeans){\n        kmw <- props[1:dims.include]/sum(props[1:dims.include])\n        km.out <- kmeansW(dims, centers = ncl, weight = kmw, iter.max = iter.max)\n        if(ncl == 1){\n            km.out$cluster <- km.out$cluster + 1\n        }\n    }else{\n        km.out <- kmeans(dims, centers = ncl, iter.max = iter.max)\n    }\n    cluster <- km.out$cluster\n\n    ## --------------------\n    ## Create output object\n    ## --------------------\n    if(word.embed){\n        out <- list(clusterA = cluster[setid == 1], clusterB = cluster[setid == 2],\n                    n.clusters = ncl, kmeans = km.out,\n                    pca = pca.out, dims.pca = dims.include)\n    }else{\n        out <- list(clusterA = cluster[setid == 1], clusterB = cluster[setid == 2],\n                    n.clusters = ncl, kmeans = km.out)\n    }\n\n    return(out)\n    \n}\n\n'