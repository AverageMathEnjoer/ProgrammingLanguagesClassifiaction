b'#pragma once\n#include "CreateEmptyValueField.h"\n\nAssetTypeValueField *CreateEmptyValueFieldFromTemplate(AssetTypeTemplateField *pTemplate,\n\tstd::vector<std::unique_ptr<uint8_t[]>>& allocatedMemory)\n{\n\tstatic const QWORD nullValue = 0; //Is the 0 or empty value for types below.\n\tswitch (pTemplate->valueType)\n\t{\n\tcase ValueType_String:\n\t\tif (pTemplate->children.size() < 1 || !pTemplate->children[0].isArray) return nullptr; //Invalid string.\n\tcase ValueType_Bool:\n\tcase ValueType_Int8:\n\tcase ValueType_UInt8:\n\tcase ValueType_Int16:\n\tcase ValueType_UInt16:\n\tcase ValueType_Int32:\n\tcase ValueType_UInt32:\n\tcase ValueType_Int64:\n\tcase ValueType_UInt64:\n\tcase ValueType_Float:\n\tcase ValueType_Double:\n\t\t{\n\t\t\tuint8_t *pCurMem = new uint8_t[sizeof(AssetTypeValueField) + sizeof(AssetTypeValue)];\n\t\t\tallocatedMemory.push_back(std::unique_ptr<uint8_t[]>(pCurMem));\n\t\t\tAssetTypeValueField *pNewField = (AssetTypeValueField*)pCurMem;\n\t\t\tAssetTypeValue *pNewValue = (AssetTypeValue*)(&pNewField[1]);\n\n\t\t\t*pNewValue = AssetTypeValue(pTemplate->valueType, const_cast<QWORD*>(&nullValue));\n\t\t\tpNewField->Read(pNewValue, pTemplate, 0, nullptr);\n\t\t\treturn pNewField;\n\t\t}\n\tcase ValueType_ByteArray:\n\tcase ValueType_Array:\n\tcase ValueType_None:\n\t\tif (pTemplate->isArray)\n\t\t{\n\t\t\tif (pTemplate->children.size() < 2) return nullptr; //Invalid array.\n\t\t\tuint8_t *pCurMem = new uint8_t[sizeof(AssetTypeValueField) + sizeof(AssetTypeValue)];\n\t\t\tallocatedMemory.push_back(std::unique_ptr<uint8_t[]>(pCurMem));\n\t\t\tAssetTypeValueField *pNewField = (AssetTypeValueField*)pCurMem;\n\t\t\tAssetTypeValue *pNewValue = (AssetTypeValue*)(&pNewField[1]);\n\n\t\t\tAssetTypeByteArray _tmpArray;\n\t\t\t_tmpArray.size = 0;\n\t\t\t_tmpArray.data = nullptr;\n\t\t\t*pNewValue = AssetTypeValue(ValueType_ByteArray, &_tmpArray);\n\t\t\tpNewField->Read(pNewValue, pTemplate, 0, nullptr);\n\n\t\t\treturn pNewField;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tuint8_t *pCurMem = new uint8_t[sizeof(AssetTypeValueField) + (sizeof(AssetTypeValueField*) * pTemplate->children.size())];\n\t\t\tallocatedMemory.push_back(std::unique_ptr<uint8_t[]>(pCurMem));\n\t\t\tAssetTypeValueField *pNewField = (AssetTypeValueField*)pCurMem;\n\t\t\tAssetTypeValueField **pNewChildList = (AssetTypeValueField**)((uintptr_t)pCurMem + sizeof(AssetTypeValueField));\n\t\t\tfor (size_t i = 0; i < pTemplate->children.size(); i++)\n\t\t\t{\n\t\t\t\tif (! (pNewChildList[i] = CreateEmptyValueFieldFromTemplate(&pTemplate->children[i], allocatedMemory)) )\n\t\t\t\t{\n\t\t\t\t\treturn nullptr;\n\t\t\t\t}\n\t\t\t}\n\t\t\tpNewField->Read(nullptr, pTemplate, (uint32_t)pTemplate->children.size(), pNewChildList);\n\t\t\treturn pNewField;\n\t\t}\n\tdefault:\n\t\treturn nullptr; //Unknown type.\n\t}\n}\n\nAssetsEntryReplacer *MakeEmptyAssetReplacer(\n\tAppContext &appContext, std::shared_ptr<AssetsFileContextInfo> pFileInfo, long long int pathID, int classID, int monoClassID,\n\tunsigned int relFileID_MonoScript, long long int pathID_MonoScript, Hash128 propertiesHash_MonoScript)\n{\n\tAssetIdentifier initialAsset;\n\t//CAssetInterface *pInitialInterface = nullptr;\n\tint monoBehaviourClass = pFileInfo->GetClassByName("MonoBehaviour");\n\tif (monoClassID != -1 && monoBehaviourClass != -1 && pathID_MonoScript != 0)\n\t{\n\t\tAssetTypeTemplateField behavTemplateBase;\n\t\tif (pFileInfo->MakeTemplateField(&behavTemplateBase, appContext, monoBehaviourClass))\n\t\t{\n\t\t\tstd::vector<std::unique_ptr<uint8_t[]>> valueMemory;\n\t\t\tAssetTypeValueField *pBaseField = CreateEmptyValueFieldFromTemplate(&behavTemplateBase, valueMemory);\n\t\t\tif (pBaseField)\n\t\t\t{\n\t\t\t\tAssetTypeValueField *pFileIDField = pBaseField->Get("m_Script")->Get("m_FileID");\n\t\t\t\tAssetTypeValueField *pPathIDField = pBaseField->Get("m_Script")->Get("m_PathID");\n\t\t\t\tif (!pFileIDField->IsDummy() && pFileIDField->GetValue() && !pPathIDField->IsDummy() && pPathIDField->GetValue())\n\t\t\t\t{\n\t\t\t\t\tpFileIDField->GetValue()->Set(&relFileID_MonoScript);\n\t\t\t\t\tpPathIDField->GetValue()->Set(&pathID_MonoScript);\n\t\t\t\t\tIAssetsWriterToMemory *pWriter = Create_AssetsWriterToMemory();\n\t\t\t\t\tbool isBigEndian = false; pFileInfo->getEndianness(isBigEndian);\n\t\t\t\t\tpBaseField->Write(pWriter, 0, isBigEndian);\n\t\t\t\t\tvoid *pData = nullptr; size_t dataLen = 0;\n\t\t\t\t\tif (pWriter->GetBuffer(pData, dataLen))\n\t\t\t\t\t{\n\t\t\t\t\t\tAssetsEntryReplacer *pInitialReplacer = MakeAssetModifierFromMemory(\n\t\t\t\t\t\t\t(uint32_t)pFileInfo->getFileID(), (QWORD)pathID, classID, (uint16_t)monoClassID, \n\t\t\t\t\t\t\tpData, dataLen, Free_AssetsWriterToMemory_DynBuf);\n\t\t\t\t\t\tif (pInitialReplacer)\n\t\t\t\t\t\t\tpWriter->SetFreeBuffer(false);\n\t\t\t\t\t\tinitialAsset = AssetIdentifier(pFileInfo->getFileID(), pathID);\n\t\t\t\t\t\tinitialAsset.pFile = pFileInfo;\n\t\t\t\t\t\tinitialAsset.pReplacer.reset(pInitialReplacer, FreeAssetsReplacer);\n\t\t\t\t\t}\n\t\t\t\t\tFree_AssetsWriter(pWriter);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tAssetTypeTemplateField templateBase;\n\tif (pFileInfo->MakeTemplateField(&templateBase, appContext, classID, (uint16_t)monoClassID, &initialAsset))\n\t{\n\t\tstd::vector<std::unique_ptr<uint8_t[]>> valueMemory;\n\t\tAssetTypeValueField *pBaseField = CreateEmptyValueFieldFromTemplate(&templateBase, valueMemory);\n\t\tif (pBaseField)\n\t\t{\n\t\t\tstd::shared_ptr<ClassDatabaseFile> pBaseClassDb = pFileInfo->GetClassDatabase();\n\n\t\t\tClassDatabaseFile *pAssetTypeDb = nullptr;\n\t\t\tClassDatabaseType *pAssetType = nullptr;\n\t\t\tClassDatabaseFile tempCombinedFile;\n\t\t\tHash128 scriptID; bool hasScriptID = false;\n\t\t\tif (monoClassID != -1 && pathID_MonoScript != 0)\n\t\t\t{\n\t\t\t\tAssetTypeValueField *pFileIDField = pBaseField->Get("m_Script")->Get("m_FileID");\n\t\t\t\tAssetTypeValueField *pPathIDField = pBaseField->Get("m_Script")->Get("m_PathID");\n\t\t\t\tif (!pFileIDField->IsDummy() && pFileIDField->GetValue() && !pPathIDField->IsDummy() && pPathIDField->GetValue())\n\t\t\t\t{\n\t\t\t\t\tpFileIDField->GetValue()->Set(&relFileID_MonoScript);\n\t\t\t\t\tpPathIDField->GetValue()->Set(&pathID_MonoScript);\n\t\t\t\t}\n\t\t\t\tClassDatabaseFile *pScriptClassDb = nullptr;\n\t\t\t\tClassDatabaseType *pScriptClassType = nullptr;\n\t\t\t\tif (initialAsset.pReplacer != nullptr && pBaseClassDb &&\n\t\t\t\t\tpFileInfo->FindScriptClassDatabaseEntry(pScriptClassDb, pScriptClassType, initialAsset, appContext, &scriptID))\n\t\t\t\t{\n\t\t\t\t\thasScriptID = true;\n\t\t\t\t\tClassDatabaseType *pMonoBehaviourClassType = nullptr;\n\t\t\t\t\tint monoBehaviourClass = pFileInfo->GetClassByName("MonoBehaviour");\n\t\t\t\t\tif (monoBehaviourClass >= 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tfor (size_t i = 0; i < pBaseClassDb->classes.size(); i++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (pBaseClassDb->classes[i].classId == monoBehaviourClass)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tpMonoBehaviourClassType = &pBaseClassDb->classes[i];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (pMonoBehaviourClassType)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t//Generate the combined ClassDatabaseType.\n\t\t\t\t\t\t\ttempCombinedFile.classes.resize(1);\n\t\t\t\t\t\t\tClassDatabaseType &newType = tempCombinedFile.classes[0];\n\n\t\t\t\t\t\t\tnewType.assemblyFileName.fromStringTable = false;\n\t\t\t\t\t\t\tnewType.assemblyFileName.str.string = "";\n\t\t\t\t\t\t\tnewType.name.fromStringTable = false;\n\t\t\t\t\t\t\tnewType.name.str.string = "";\n\n\t\t\t\t\t\t\tnewType.classId = -(monoClassID + 1);\n\t\t\t\t\t\t\tnewType.baseClass = monoBehaviourClass;\n\n\t\t\t\t\t\t\tfor (size_t i = 0; i < pMonoBehaviourClassType->fields.size(); i++)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tnewType.fields.push_back(pMonoBehaviourClassType->fields[i]);\n\t\t\t\t\t\t\t\tClassDatabaseTypeField &curMonoBehavField = newType.fields[newType.fields.size() - 1];\n\t\t\t\t\t\t\t\tcurMonoBehavField.fieldName.str.string = curMonoBehavField.fieldName.GetString(pBaseClassDb.get());\n\t\t\t\t\t\t\t\tcurMonoBehavField.fieldName.fromStringTable = false;\n\t\t\t\t\t\t\t\tcurMonoBehavField.typeName.str.string = curMonoBehavField.typeName.GetString(pBaseClassDb.get());\n\t\t\t\t\t\t\t\tcurMonoBehavField.typeName.fromStringTable = false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfor (size_t i = 1; i < pScriptClassType->fields.size(); i++)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tnewType.fields.push_back(pScriptClassType->fields[i]);\n\t\t\t\t\t\t\t\tClassDatabaseTypeField &curMonoBehavField = newType.fields[newType.fields.size() - 1];\n\t\t\t\t\t\t\t\tcurMonoBehavField.fieldName.str.string = curMonoBehavField.fieldName.GetString(pScriptClassDb);\n\t\t\t\t\t\t\t\tcurMonoBehavField.fieldName.fromStringTable = false;\n\t\t\t\t\t\t\t\tcurMonoBehavField.typeName.str.string = curMonoBehavField.typeName.GetString(pScriptClassDb);\n\t\t\t\t\t\t\t\tcurMonoBehavField.typeName.fromStringTable = false;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tpAssetTypeDb = &tempCombinedFile;\n\t\t\t\t\t\t\tpAssetType = &newType;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (pBaseClassDb)\n\t\t\t{\n\t\t\t\tfor (size_t i = 0; i < pBaseClassDb->classes.size(); i++)\n\t\t\t\t{\n\t\t\t\t\tif (pBaseClassDb->classes[i].classId == classID)\n\t\t\t\t\t{\n\t\t\t\t\t\tpAssetTypeDb = pBaseClassDb.get();\n\t\t\t\t\t\tpAssetType = &pBaseClassDb->classes[i];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tstd::unique_ptr<IAssetsWriterToMemory> pWriter(Create_AssetsWriterToMemory());\n\t\t\tbool bigEndian = false; pFileInfo->getEndianness(bigEndian);\n\t\t\tpBaseField->Write(pWriter.get(), 0, bigEndian);\n\t\t\tvoid *pData = nullptr; size_t dataLen = 0;\n\t\t\tif (pWriter->GetBuffer(pData, dataLen))\n\t\t\t{\n\t\t\t\tAssetsEntryReplacer *pReplacer = MakeAssetModifierFromMemory(\n\t\t\t\t\t(uint32_t)pFileInfo->getFileID(), (QWORD)pathID, classID, (uint16_t)monoClassID, \n\t\t\t\t\tpData, dataLen, Free_AssetsWriterToMemory_DynBuf);\n\t\t\t\tif (pReplacer)\n\t\t\t\t{\n\t\t\t\t\tpWriter->SetFreeBuffer(false);\n\t\t\t\t\tif (hasScriptID)\n\t\t\t\t\t\tpReplacer->SetScriptIDHash(scriptID);\n\t\t\t\t\tif (pAssetTypeDb && pAssetType)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (propertiesHash_MonoScript.qValue[0] == 0 && propertiesHash_MonoScript.qValue[1] == 0)\n\t\t\t\t\t\t\tpReplacer->SetPropertiesHash(pAssetType->MakeTypeHash(pAssetTypeDb));\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tpReplacer->SetPropertiesHash(propertiesHash_MonoScript);\n\t\t\t\t\t\t//TODO: Don\'t add the type information if it\'s already in the type tree or not needed (i.e. .assets file has no tree)!\n\t\t\t\t\t\tauto pReplacerDatabase = std::make_shared<ClassDatabaseFile>();\n\t\t\t\t\t\tif (pReplacerDatabase->InsertFrom(pAssetTypeDb, pAssetType))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tassert(pReplacerDatabase->classes.size() == 1);\n\t\t\t\t\t\t\tif (pReplacerDatabase->classes.size() == 1)\n\t\t\t\t\t\t\t\tpReplacer->SetTypeInfo(std::move(pReplacerDatabase), &pReplacerDatabase->classes[0]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (monoClassID != -1 && pathID_MonoScript != 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tAssetPPtr pptr; \n\t\t\t\t\t\tpptr.fileID = relFileID_MonoScript; pptr.pathID = (QWORD)pathID_MonoScript;\n\t\t\t\t\t\tpReplacer->AddPreloadDependency(pptr);\n\t\t\t\t\t}\n\t\t\t\t\treturn pReplacer;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn NULL;\n}\n'