b'-- vim:fdm=marker\n{-# LANGUAGE BangPatterns, ImplicitParams, MultiParamTypeClasses, DeriveDataTypeable, FlexibleContexts, CApiFFI #-}\n-- | Console reporter ingredient.\n--\n-- @since 0.11.3\nmodule Test.Tasty.Ingredients.ConsoleReporter\n  ( consoleTestReporter\n  , consoleTestReporterWithHook\n  , Quiet(..)\n  , HideSuccesses(..)\n  , AnsiTricks(..)\n  -- * Internals\n  -- | The following functions and datatypes are internals that are exposed to\n  -- simplify the task of rolling your own custom console reporter UI.\n\n  -- ** Output colouring\n  , UseColor(..)\n  , useColor\n  -- ** Test failure statistics\n  , Statistics(..)\n  , computeStatistics\n  , printStatistics\n  , printStatisticsNoTime\n  -- ** Outputting results\n  , TestOutput(..)\n  , buildTestOutput\n  , foldTestOutput\n  , withConsoleFormat\n  ) where\n\nimport Prelude hiding (fail, EQ)\nimport Control.Monad (join, unless, void, when, (<=<))\nimport Control.Monad.IO.Class (liftIO)\nimport Control.Monad.Trans.Reader (Reader, runReader, ask)\nimport Control.Monad.Trans.State (evalState, evalStateT, get, modify, put)\nimport Control.Concurrent.STM\nimport Control.Exception\nimport Test.Tasty.Core\nimport Test.Tasty.Providers.ConsoleFormat\nimport Test.Tasty.Run\nimport Test.Tasty.Ingredients\nimport Test.Tasty.Ingredients.ListTests\nimport Test.Tasty.Options\nimport Test.Tasty.Options.Core\nimport Test.Tasty.Patterns\nimport Test.Tasty.Patterns.Printer\nimport Test.Tasty.Patterns.Types\nimport Test.Tasty.Runners.Reducers\nimport Test.Tasty.Runners.Utils\nimport Text.Printf\nimport qualified Data.IntMap as IntMap\nimport Data.Char\n#ifdef USE_WCWIDTH\nimport Foreign.C.Types (CInt(..), CWchar(..))\n#endif\nimport Data.List (isInfixOf)\nimport Data.Maybe\nimport Data.Monoid (Any(..))\nimport qualified Data.Semigroup as Sem\nimport Data.Typeable\nimport Options.Applicative hiding (action, str, Success, Failure)\nimport System.IO\nimport System.Console.ANSI\n#if !MIN_VERSION_base(4,11,0)\nimport Data.Foldable (foldMap)\n#endif\n\n--------------------------------------------------\n-- TestOutput base definitions\n--------------------------------------------------\n-- {{{\n-- | \'TestOutput\' is an intermediary between output formatting and output\n-- printing. It lets us have several different printing modes (normal; print\n-- failures only; quiet).\n--\n-- @since 0.12\ndata TestOutput\n  = PrintTest\n      {- test name         -} String\n      {- print test name   -} (IO ())\n      {- print test result -} (Result -> IO ())\n      -- ^ Name of a test, an action that prints the test name, and an action\n      -- that renders the result of the action.\n  | PrintHeading String (IO ()) TestOutput\n      -- ^ Name of a test group, an action that prints the heading of a test\n      -- group and the \'TestOutput\' for that test group.\n  | Skip -- ^ Inactive test (e.g. not matching the current pattern)\n  | Seq TestOutput TestOutput -- ^ Two sets of \'TestOutput\' on the same level\n\n-- The monoid laws should hold observationally w.r.t. the semantics defined\n-- in this module.\n--\n-- @since 0.12.0.1\ninstance Sem.Semigroup TestOutput where\n  (<>) = Seq\ninstance Monoid TestOutput where\n  mempty = Skip\n#if !MIN_VERSION_base(4,11,0)\n  mappend = (Sem.<>)\n#endif\n\napplyHook :: ([TestName] -> Result -> IO Result) -> TestOutput -> TestOutput\napplyHook hook = go []\n  where\n    go path (PrintTest name printName printResult) =\n      PrintTest name printName (printResult <=< hook (name : path))\n    go path (PrintHeading name printName printBody) =\n      PrintHeading name printName (go (name : path) printBody)\n    go path (Seq a b) = Seq (go path a) (go path b)\n    go _ Skip = mempty\n\ntype Level = Int\n\n-- | Build the \'TestOutput\' for a \'TestTree\' and \'OptionSet\'. The @colors@\n-- ImplicitParam controls whether the output is colored.\n--\n-- @since 0.11.3\nbuildTestOutput :: (?colors :: Bool) => OptionSet -> TestTree -> TestOutput\nbuildTestOutput opts tree =\n  let\n    -- Do not retain the reference to the tree more than necessary\n    !alignment = computeAlignment opts tree\n\n    runSingleTest\n      :: (IsTest t, ?colors :: Bool)\n      => OptionSet -> TestName -> t -> Ap (Reader Level) TestOutput\n    runSingleTest _opts name _test = Ap $ do\n      level <- ask\n\n      let\n        printTestName = do\n          printf "%s%s: %s" (indent level) name\n            (replicate (alignment - indentSize * level - stringWidth name) \' \')\n          hFlush stdout\n\n        printTestResult result = do\n          rDesc <- formatMessage $ resultDescription result\n\n          -- use an appropriate printing function\n          let\n            printFn =\n              case resultOutcome result of\n                Success -> ok\n                Failure TestDepFailed -> skipped\n                _ -> fail\n            time = resultTime result\n          printFn (resultShortDescription result)\n          -- print time only if it\'s significant\n          when (time >= 0.01) $\n            printFn (printf " (%.2fs)" time)\n          printFn "\\n"\n\n          when (not $ null rDesc) $\n            (if resultSuccessful result then infoOk else infoFail) $\n              printf "%s%s\\n" (indent $ level + 1) (formatDesc (level+1) rDesc)\n          case resultDetailsPrinter result of\n            ResultDetailsPrinter action -> action level withConsoleFormat\n\n      return $ PrintTest name printTestName printTestResult\n\n    runGroup :: OptionSet -> TestName -> [Ap (Reader Level) TestOutput] -> Ap (Reader Level) TestOutput\n    runGroup _opts name grp = Ap $ do\n      level <- ask\n      let\n        printHeading = printf "%s%s\\n" (indent level) name\n        printBody = runReader (getApp (mconcat grp)) (level + 1)\n      return $ PrintHeading name printHeading printBody\n\n  in\n    flip runReader 0 $ getApp $\n      foldTestTree\n        trivialFold\n          { foldSingle = runSingleTest\n          , foldGroup = runGroup\n          }\n          opts tree\n\n-- | Fold function for the \'TestOutput\' tree into a \'Monoid\'.\n--\n-- @since 0.12\nfoldTestOutput\n  :: Monoid b\n  => (String -> IO () -> IO Result -> (Result -> IO ()) -> b)\n  -- ^ Eliminator for test cases. The @IO ()@ prints the testname. The\n  -- @IO Result@ blocks until the test is finished, returning it\'s \'Result\'.\n  -- The @Result -> IO ()@ function prints the formatted output.\n  -> (String -> IO () -> b -> b)\n  -- ^ Eliminator for test groups. The @IO ()@ prints the test group\'s name.\n  -- The @b@ is the result of folding the test group.\n  -> TestOutput -- ^ The @TestOutput@ being rendered.\n  -> StatusMap -- ^ The @StatusMap@ received by the \'TestReporter\'\n  -> b\nfoldTestOutput foldTest foldHeading outputTree smap =\n  flip evalState 0 $ getApp $ go outputTree where\n  go (PrintTest name printName printResult) = Ap $ do\n    ix <- get\n    put $! ix + 1\n    let\n      statusVar =\n        fromMaybe (error "internal error: index out of bounds") $\n        IntMap.lookup ix smap\n      readStatusVar = getResultFromTVar statusVar\n    return $ foldTest name printName readStatusVar printResult\n  go (PrintHeading name printName printBody) = Ap $\n    foldHeading name printName <$> getApp (go printBody)\n  go (Seq a b) = mappend (go a) (go b)\n  go Skip = mempty\n\n-- }}}\n\n--------------------------------------------------\n-- TestOutput modes\n--------------------------------------------------\n-- {{{\nconsoleOutput :: (?colors :: Bool) => TestOutput -> StatusMap -> IO ()\nconsoleOutput toutput smap =\n  getTraversal . fst $ foldTestOutput foldTest foldHeading toutput smap\n  where\n    foldTest _name printName getResult printResult =\n      ( Traversal $ do\n          printName :: IO ()\n          r <- getResult\n          printResult r\n      , Any True)\n    foldHeading _name printHeading (printBody, Any nonempty) =\n      ( Traversal $ do\n          when nonempty $ do printHeading :: IO (); getTraversal printBody\n      , Any nonempty\n      )\n\nconsoleOutputHidingSuccesses :: (?colors :: Bool) => TestOutput -> StatusMap -> IO ()\nconsoleOutputHidingSuccesses toutput smap =\n  void . getApp $ foldTestOutput foldTest foldHeading toutput smap\n  where\n    foldTest _name printName getResult printResult =\n      Ap $ do\n          printName :: IO ()\n          r <- getResult\n          if resultSuccessful r\n            then do clearThisLine; return $ Any False\n            else do printResult r :: IO (); return $ Any True\n\n    foldHeading _name printHeading printBody =\n      Ap $ do\n        printHeading :: IO ()\n        Any failed <- getApp printBody\n        unless failed clearAboveLine\n        return $ Any failed\n\n    clearAboveLine = do cursorUpLine 1; clearThisLine\n    clearThisLine = do clearLine; setCursorColumn 0\n\nstreamOutputHidingSuccesses :: (?colors :: Bool) => TestOutput -> StatusMap -> IO ()\nstreamOutputHidingSuccesses toutput smap =\n  void . flip evalStateT [] . getApp $\n    foldTestOutput foldTest foldHeading toutput smap\n  where\n    foldTest _name printName getResult printResult =\n      Ap $ do\n          r <- liftIO $ getResult\n          if resultSuccessful r\n            then return $ Any False\n            else do\n              stack <- get\n              put []\n\n              liftIO $ do\n                sequence_ $ reverse stack\n                printName :: IO ()\n                printResult r :: IO ()\n\n              return $ Any True\n\n    foldHeading _name printHeading printBody =\n      Ap $ do\n        modify (printHeading :)\n        Any failed <- getApp printBody\n        unless failed $\n          modify $ \\stack ->\n            case stack of\n              _:rest -> rest\n              [] -> [] -- shouldn\'t happen anyway\n        return $ Any failed\n\n-- }}}\n\n--------------------------------------------------\n-- Statistics\n--------------------------------------------------\n-- {{{\n\n-- | Track the number of tests that were run and failures of a \'TestTree\' or\n-- sub-tree.\n--\n-- @since 0.11.3\ndata Statistics = Statistics\n  { statTotal :: !Int -- ^ Number of active tests (e.g., that match the\n                      -- pattern specified on the commandline), inactive tests\n                      -- are not counted.\n  , statFailures :: !Int -- ^ Number of active tests that failed.\n  }\n\n-- | @since 0.12.0.1\ninstance Sem.Semigroup Statistics where\n  Statistics t1 f1 <> Statistics t2 f2 = Statistics (t1 + t2) (f1 + f2)\ninstance Monoid Statistics where\n  mempty = Statistics 0 0\n#if !MIN_VERSION_base(4,11,0)\n  mappend = (Sem.<>)\n#endif\n\n-- | @computeStatistics@ computes a summary \'Statistics\' for\n-- a given state of the \'StatusMap\'.\n-- Useful in combination with \'printStatistics\'.\n--\n-- @since 1.2.3\ncomputeStatistics :: StatusMap -> IO Statistics\ncomputeStatistics = getApp . foldMap (\\var -> Ap $\n  (\\r -> Statistics 1 (if resultSuccessful r then 0 else 1))\n    <$> getResultFromTVar var)\n\nreportStatistics :: (?colors :: Bool) => Statistics -> IO ()\nreportStatistics st = case statFailures st of\n    0 -> ok $ printf "All %d tests passed" (statTotal st)\n    fs -> fail $ printf "%d out of %d tests failed" fs (statTotal st)\n\n-- | @printStatistics@ reports test success/failure statistics and time it took\n-- to run. The \'Time\' results is intended to be filled in by the \'TestReporter\'\n-- callback. The @colors@ ImplicitParam controls whether coloured output is\n-- used.\n--\n-- @since 0.11.3\nprintStatistics :: (?colors :: Bool) => Statistics -> Time -> IO ()\nprintStatistics st time = do\n  printf "\\n"\n  reportStatistics st\n  case statFailures st of\n    0 -> ok $ printf " (%.2fs)\\n" time\n    _ -> fail $ printf " (%.2fs)\\n" time\n\n-- | @printStatisticsNoTime@ reports test success/failure statistics\n-- The @colors@ ImplicitParam controls whether coloured output is used.\n--\n-- @since 0.12\nprintStatisticsNoTime :: (?colors :: Bool) => Statistics -> IO ()\nprintStatisticsNoTime st = reportStatistics st >> printf "\\n"\n\n-- | Wait until\n--\n-- * all tests have finished successfully, and return \'True\', or\n--\n-- * at least one test has failed, and return \'False\'\nstatusMapResult\n  :: Int -- ^ lookahead\n  -> StatusMap\n  -> IO Bool\nstatusMapResult lookahead0 smap\n  | IntMap.null smap = return True\n  | otherwise =\n      join . atomically $\n        IntMap.foldrWithKey f finish smap mempty lookahead0\n  where\n    f :: Int\n      -> TVar Status\n      -> (IntMap.IntMap () -> Int -> STM (IO Bool))\n      -> (IntMap.IntMap () -> Int -> STM (IO Bool))\n    -- ok_tests is a set of tests that completed successfully\n    -- lookahead is the number of unfinished tests that we are allowed to\n    -- look at\n    f key tvar k ok_tests lookahead\n      | lookahead <= 0 =\n          -- We looked at too many unfinished tests.\n          next_iter ok_tests\n      | otherwise = do\n          this_status <- readTVar tvar\n          case this_status of\n            Done r ->\n              if resultSuccessful r\n                then k (IntMap.insert key () ok_tests) lookahead\n                else return $ return False\n            _ -> k ok_tests (lookahead-1)\n\n    -- next_iter is called when we end the current iteration,\n    -- either because we reached the end of the test tree\n    -- or because we exhausted the lookahead\n    next_iter :: IntMap.IntMap () -> STM (IO Bool)\n    next_iter ok_tests =\n      -- If we made no progress at all, wait until at least some tests\n      -- complete.\n      -- Otherwise, reduce the set of tests we are looking at.\n      if IntMap.null ok_tests\n        then retry\n        else return $ statusMapResult lookahead0 (IntMap.difference smap ok_tests)\n\n    finish :: IntMap.IntMap () -> Int -> STM (IO Bool)\n    finish ok_tests _ = next_iter ok_tests\n\n-- }}}\n\n--------------------------------------------------\n-- Console test reporter\n--------------------------------------------------\n-- {{{\n\n-- | A simple console UI.\n--\n-- @since 0.4\nconsoleTestReporter :: Ingredient\nconsoleTestReporter = TestReporter consoleTestReporterOptions $ \\opts tree ->\n  let\n    TestPattern pattern = lookupOption opts\n    tests = testsNames opts tree\n    hook = (return .) . appendPatternIfTestFailed tests pattern\n    TestReporter _ cb = consoleTestReporterWithHook hook\n  in cb opts tree\n\nappendPatternIfTestFailed\n  :: [TestName] -- ^ list of (pre-intercalated) test names\n  -> Maybe Expr -- ^ current pattern, if any\n  -> [TestName] -- ^ name of current test, represented as a list of group names\n  -> Result     -- ^ vanilla result\n  -> Result\nappendPatternIfTestFailed [_] _ _ res = res -- if there is only one test, nothing to refine\nappendPatternIfTestFailed _ _ [] res  = res -- should be impossible\nappendPatternIfTestFailed tests currentPattern (name : names) res = case resultOutcome res of\n  Success -> res\n  Failure{} -> res { resultDescription = resultDescription res ++ msg }\n  where\n    msg = "\\nUse -p \'" ++ escapeQuotes (printAwkExpr pattern) ++ "\' to rerun this test only."\n\n    escapeQuotes = concatMap $ \\c -> if c == \'\\\'\' then "\'\\\\\'\'" else [c]\n\n    findPattern [_] pat _ = ERE pat\n    findPattern _  pat [] = EQ (Field (IntLit 0)) (StringLit pat)\n    findPattern ts pat (n : ns) = let pat\' = n ++ \'.\' : pat in\n      findPattern (filter (pat\' `isInfixOf`) ts) pat\' ns\n\n    individualPattern = findPattern (filter (name `isInfixOf`) tests) name names\n\n    pattern = maybe id And currentPattern individualPattern\n\nconsoleTestReporterOptions :: [OptionDescription]\nconsoleTestReporterOptions =\n  [ Option (Proxy :: Proxy Quiet)\n  , Option (Proxy :: Proxy HideSuccesses)\n  , Option (Proxy :: Proxy UseColor)\n  , Option (Proxy :: Proxy AnsiTricks)\n  ]\n\n-- | A simple console UI with a hook to postprocess results,\n-- depending on their names and external conditions\n-- (e. g., its previous outcome, stored in a file).\n-- Names are listed in reverse order:\n-- from test\'s own name to a name of the outermost test group.\n--\n-- @since 1.4.2\nconsoleTestReporterWithHook :: ([TestName] -> Result -> IO Result) -> Ingredient\nconsoleTestReporterWithHook hook = TestReporter consoleTestReporterOptions $\n  \\opts tree -> Just $ \\smap -> do\n\n  let\n    whenColor = lookupOption opts\n    Quiet quiet = lookupOption opts\n    HideSuccesses hideSuccesses = lookupOption opts\n    NumThreads numThreads = lookupOption opts\n    AnsiTricks ansiTricks = lookupOption opts\n\n  if quiet\n    then do\n      b <- statusMapResult numThreads smap\n      return $ \\_time -> return b\n    else\n\n      do\n      isTerm <- hSupportsANSI stdout\n      isTermColor <- hSupportsANSIColor stdout\n\n      (\\k -> if isTerm\n        then (do hideCursor; k) `finally` showCursor\n        else k) $ do\n\n          hSetBuffering stdout LineBuffering\n\n          let\n            ?colors = useColor whenColor isTermColor\n\n          let\n            toutput = applyHook hook $ buildTestOutput opts tree\n\n          case () of { _\n            | hideSuccesses && isTerm && ansiTricks ->\n                consoleOutputHidingSuccesses toutput smap\n            | hideSuccesses ->\n                streamOutputHidingSuccesses toutput smap\n            | otherwise -> consoleOutput toutput smap\n          }\n\n          return $ \\time -> do\n            stats <- computeStatistics smap\n            printStatistics stats time\n            return $ statFailures stats == 0\n\n-- | Do not print test results (see README for details).\n--\n-- @since 0.8\nnewtype Quiet = Quiet Bool\n  deriving (Eq, Ord, Typeable)\ninstance IsOption Quiet where\n  defaultValue = Quiet False\n  parseValue = fmap Quiet . safeReadBool\n  optionName = return "quiet"\n  optionHelp = return "Do not produce any output; indicate success only by the exit code"\n  optionCLParser = mkFlagCLParser (short \'q\') (Quiet True)\n\n-- | Report only failed tests.\n--\n-- At the moment, this option only works globally. As an argument\n-- to \'Test.Tasty.localOption\', it does nothing.\n--\n-- @since 0.8\nnewtype HideSuccesses = HideSuccesses Bool\n  deriving (Eq, Ord, Typeable)\ninstance IsOption HideSuccesses where\n  defaultValue = HideSuccesses False\n  parseValue = fmap HideSuccesses . safeReadBool\n  optionName = return "hide-successes"\n  optionHelp = return "Do not print tests that passed successfully"\n  optionCLParser = mkFlagCLParser mempty (HideSuccesses True)\n\n-- | When to use color on the output\n--\n-- @since 0.11.3\ndata UseColor\n  = Never\n  | Always\n  | Auto -- ^ Only if stdout is an ANSI color supporting terminal\n  deriving (Eq, Ord, Typeable)\n\n-- | Control color output\ninstance IsOption UseColor where\n  defaultValue = Auto\n  parseValue = parseUseColor\n  optionName = return "color"\n  optionHelp = return "When to use colored output"\n  optionCLParser = mkOptionCLParser $ metavar "never|always|auto"\n  showDefaultValue = Just . displayUseColor\n\n-- | By default, when the option @--hide-successes@ is given and the output\n-- goes to an ANSI-capable terminal, we employ some ANSI terminal tricks to\n-- display the name of the currently running test and then erase it if it\n-- succeeds.\n--\n-- These tricks sometimes fail, however\xe2\x80\x94in particular, when the test names\n-- happen to be longer than the width of the terminal window. See\n--\n-- * <https://github.com/UnkindPartition/tasty/issues/152>\n--\n-- * <https://github.com/UnkindPartition/tasty/issues/250>\n--\n-- When that happens, this option can be used to disable the tricks. In\n-- that case, the test name will be printed only once the test fails.\n--\n-- @since 1.3\nnewtype AnsiTricks = AnsiTricks { getAnsiTricks :: Bool }\n  deriving Typeable\n\ninstance IsOption AnsiTricks where\n  defaultValue = AnsiTricks True\n  parseValue = fmap AnsiTricks . safeReadBool\n  optionName = return "ansi-tricks"\n  optionHelp = return $\n    -- Multiline literals don\'t work because of -XCPP.\n    "Enable various ANSI terminal tricks. " ++\n    "Can be set to \'true\' or \'false\'."\n  showDefaultValue = Just . displayBool . getAnsiTricks\n\ndisplayBool :: Bool -> String\ndisplayBool b =\n  case b of\n    False -> "false"\n    True  -> "true"\n\n-- | @useColor when isTerm@ decides if colors should be used,\n--   where @isTerm@ indicates whether @stdout@ is a terminal device.\n--\n--   @since 0.11.3\nuseColor :: UseColor -> Bool -> Bool\nuseColor when_ isTerm =\n  case when_ of\n    Never  -> False\n    Always -> True\n    Auto   -> isTerm\n\nparseUseColor :: String -> Maybe UseColor\nparseUseColor s =\n  case map toLower s of\n    "never"  -> return Never\n    "always" -> return Always\n    "auto"   -> return Auto\n    _        -> Nothing\n\ndisplayUseColor :: UseColor -> String\ndisplayUseColor uc =\n  case uc of\n    Never  -> "never"\n    Always -> "always"\n    Auto   -> "auto"\n\n-- }}}\n\n--------------------------------------------------\n-- Various utilities\n--------------------------------------------------\n-- {{{\ngetResultFromTVar :: TVar Status -> IO Result\ngetResultFromTVar var =\n  atomically $ do\n    status <- readTVar var\n    case status of\n      Done r -> return r\n      _ -> retry\n\n-- }}}\n\n--------------------------------------------------\n-- Formatting\n--------------------------------------------------\n-- {{{\n\nindentSize :: Int\nindentSize = 2\n\nindent :: Int -> String\nindent n = replicate (indentSize * n) \' \'\n\n-- handle multi-line result descriptions properly\nformatDesc\n  :: Int -- indent\n  -> String\n  -> String\nformatDesc n desc =\n  let\n    -- remove all trailing linebreaks\n    chomped = reverse . dropWhile (== \'\\n\') . reverse $ desc\n\n    multiline = \'\\n\' `elem` chomped\n\n    -- we add a leading linebreak to the description, to start it on a new\n    -- line and add an indentation\n    paddedDesc = flip concatMap chomped $ \\c ->\n      if c == \'\\n\'\n        then c : indent n\n        else [c]\n  in\n    if multiline\n      then paddedDesc\n      else chomped\n\ndata Maximum a\n  = Maximum a\n  | MinusInfinity\n\ninstance Ord a => Sem.Semigroup (Maximum a) where\n  Maximum a <> Maximum b = Maximum (a `max` b)\n  MinusInfinity <> a = a\n  a <> MinusInfinity = a\ninstance Ord a => Monoid (Maximum a) where\n  mempty = MinusInfinity\n#if !MIN_VERSION_base(4,11,0)\n  mappend = (Sem.<>)\n#endif\n\n-- | Compute the amount of space needed to align \\"OK\\"s and \\"FAIL\\"s\ncomputeAlignment :: OptionSet -> TestTree -> Int\ncomputeAlignment opts =\n  fromMonoid .\n  foldTestTree\n    trivialFold\n      { foldSingle = \\_ name _ level -> Maximum (stringWidth name + level)\n      , foldGroup = \\_opts _ m -> mconcat m . (+ indentSize)\n      }\n    opts\n  where\n    fromMonoid m =\n      case m 0 of\n        MinusInfinity -> 0\n        Maximum x -> x\n\n-- | Compute the length/width of the string as it would appear in a monospace\n--   terminal. This takes into account that even in a \xe2\x80\x9cmono\xe2\x80\x9dspace font, not\n--   all characters actually have the same width, in particular, most CJK\n--   characters have twice the same as Western characters.\n--\n--   (This only works properly on Unix at the moment; on Windows, the function\n--   treats every character as width-1 like \'Data.List.length\' does.)\nstringWidth :: String -> Int\n#ifdef USE_WCWIDTH\nstringWidth = Prelude.sum . map charWidth\n where charWidth c = case wcwidth (fromIntegral (ord c)) of\n        -1 -> 1  -- many chars have "undefined" width; default to 1 for these.\n        w  -> fromIntegral w\nforeign import capi safe "wchar.h wcwidth" wcwidth :: CWchar -> CInt\n#else\nstringWidth = length\n#endif\n\n-- (Potentially) colorful output\nok, fail, skipped, infoOk, infoFail :: (?colors :: Bool) => String -> IO ()\nfail     = output failFormat\nok       = output okFormat\nskipped  = output skippedFormat\n-- Just default foreground color for \'infoOk\'; do not apply \'infoOkFormat\',\n-- because terminal\'s background could be white itself. See #298.\ninfoOk   = putStr\ninfoFail = output infoFailFormat\n\noutput\n  :: (?colors :: Bool)\n  => ConsoleFormat\n  -> String\n  -> IO ()\noutput format = withConsoleFormat format . putStr\n\n-- | Run action with console configured for a specific output format\n--\n-- This function does not apply any output formats if colors are disabled at command\n-- line or console detection.\n--\n-- Can be used by providers that wish to provider specific result details printing,\n-- while re-using the tasty formats and coloring logic.\n--\n-- @since 1.3.1\nwithConsoleFormat :: (?colors :: Bool) => ConsoleFormatPrinter\nwithConsoleFormat format action\n  | ?colors =\n    (do\n      setSGR\n        [ SetColor Foreground (colorIntensity format) (color format)\n        , SetConsoleIntensity (consoleIntensity format)\n        ]\n      action\n    ) `finally` setSGR []\n  | otherwise = action\n\n-- }}}\n'