b'// UVa1627 Team them up!\n// Rujia Liu\n#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nconst int maxn = 100 + 5;\n\nint n, G[maxn][maxn], color[maxn], diff[maxn], cc;\nvector<int> team[maxn][2]; // team[cc][c] is the list of people in connected-component cc, color c\n\n// returns false if not bipartite graph\nbool dfs(int u, int c) {\n  color[u] = c;\n  team[cc][c-1].push_back(u);\n  for(int v = 0; v < n; v++) {\n    if(u != v && !(G[u][v] && G[v][u])) { // u and v must be in different groups\n      if(color[v] > 0 && color[v] == color[u]) return false;\n      if(!color[v] && !dfs(v, 3-c)) return false;\n    }\n  }\n  return true;\n}\n\nbool build_graph() {\n  memset(color, 0, sizeof(color));\n  cc = 0; // current connected-component\n  for(int i = 0; i < n; i++)\n    if(!color[i]) {\n      team[cc][0].clear();\n      team[cc][1].clear();\n      if(!dfs(i, 1)) return false;\n      diff[cc] = team[cc][0].size() - team[cc][1].size();\n      cc++;\n    }\n\n  return true;\n}\n\n// d[i][j+n] = 1 iff we can arrange first i cc so that team 1 has j more people than team 2.\nint d[maxn][maxn*2], teamno[maxn]; \n\nvoid print(int ans) {\n  vector<int> team1, team2;\n  for(int i = cc-1; i >= 0; i--) {\n    int t;\n    if(d[i][ans-diff[i]+n]) { t = 0; ans -= diff[i]; }\n    else { t = 1; ans += diff[i]; }\n    for(int j = 0; j < team[i][t].size(); j++)\n      team1.push_back(team[i][t][j]);\n    for(int j = 0; j < team[i][1^t].size(); j++)\n      team2.push_back(team[i][1^t][j]);\n  }\n  printf("%d", team1.size());\n  for(int i = 0; i < team1.size(); i++) printf(" %d", team1[i]+1);\n  printf("\\n");\n\n  printf("%d", team2.size());\n  for(int i = 0; i < team2.size(); i++) printf(" %d", team2[i]+1);\n  printf("\\n");\n}\n\nvoid dp() {\n  memset(d, 0, sizeof(d));\n  d[0][0+n] = 1;\n  for(int i = 0; i < cc; i++)\n    for(int j = -n; j <= n; j++) if(d[i][j+n]) {\n      d[i+1][j+diff[i]+n] = 1;\n      d[i+1][j-diff[i]+n] = 1;\n    }\n  for(int ans = 0; ans <= n; ans++) {\n    if(d[cc][ans+n]) { print(ans); return; }\n    if(d[cc][-ans+n]) { print(-ans); return; }\n  }\n}\n\nint main() {\n  int T;\n  cin >> T;\n  while(T--) {\n    cin >> n;\n    memset(G, 0, sizeof(G));\n    for(int u = 0; u < n; u++) {\n      int v;\n      while(cin >> v && v) G[u][v-1] = 1;\n    }\n\n    if(n == 1 || !build_graph()) cout << "No solution\\n";\n    else dp();\n\n    if(T) cout << "\\n";\n  }\n  return 0;\n}\n'