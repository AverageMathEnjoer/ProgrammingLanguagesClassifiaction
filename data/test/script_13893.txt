b'#include "AssetIterator.h"\n#include "AppContext.h"\n#include <assert.h>\n\n//Instantiate an AssetIdentifier with a relative fileID relative to the dependencies for an absolute fileID and a pathID.\nAssetIdentifier::AssetIdentifier(unsigned int referenceFromFileID, unsigned int relFileID, pathid_t pathID)\n\t: fileID(relFileID), pathID(pathID), fileIDIsRelative(true), referenceFromFileID(referenceFromFileID), pFile(nullptr), pAssetInfo(nullptr), pReplacer(nullptr)\n{\n\n}\nAssetIdentifier::AssetIdentifier(unsigned int fileID, std::shared_ptr<AssetsEntryReplacer> &pReplacer)\n\t: fileID(fileID), pathID(pReplacer->GetPathID()), fileIDIsRelative(false), pFile(nullptr), pAssetInfo(nullptr), pReplacer(pReplacer)\n{}\n//Instantiate an AssetIdentifier with a relative fileID (from pReferenceFromFile->references) and a pathID.\nAssetIdentifier::AssetIdentifier(std::shared_ptr<class AssetsFileContextInfo> &pReferenceFromFile, unsigned int relFileID, pathid_t pathID)\n\t: fileID(pReferenceFromFile->resolveRelativeFileID(relFileID)), pathID(pathID), fileIDIsRelative(false), pFile(nullptr), pAssetInfo(nullptr), pReplacer(nullptr)\n{\n}\nAssetIdentifier::AssetIdentifier(std::shared_ptr<class AssetsFileContextInfo> _pFile, pathid_t pathID)\n\t: fileID(_pFile->getFileID()), pathID(pathID), fileIDIsRelative(false), pFile(std::move(_pFile)), pAssetInfo(nullptr), pReplacer(nullptr)\n{\n}\nAssetIdentifier::AssetIdentifier(std::shared_ptr<class AssetsFileContextInfo> _pFile, AssetFileInfoEx *pAssetInfo)\n\t: fileID(_pFile->getFileID()), pathID(pAssetInfo->index), fileIDIsRelative(false), pFile(std::move(_pFile)), pAssetInfo(pAssetInfo), pReplacer(nullptr)\n{}\nAssetIdentifier::AssetIdentifier(std::shared_ptr<class AssetsFileContextInfo> _pFile, std::shared_ptr<AssetsEntryReplacer> &pReplacer)\n\t: fileID(_pFile->getFileID()), pathID(pAssetInfo->index), fileIDIsRelative(false), pFile(std::move(_pFile)), pAssetInfo(nullptr), pReplacer(pReplacer)\n{}\nbool AssetIdentifier::resolve(class AppContext &appContext)\n{\n\tif (!pFile)\n\t{\n\t\tunsigned int absFileID = fileID;\n\t\tif (fileIDIsRelative)\n\t\t{\n\t\t\tstd::shared_ptr<FileContextInfo> pSourceContextInfoRaw = appContext.getContextInfo(referenceFromFileID);\n\t\t\tif (!pSourceContextInfoRaw)\n\t\t\t\treturn false;\n\t\t\tAssetsFileContextInfo *pSourceContextInfo = dynamic_cast<AssetsFileContextInfo*>(pSourceContextInfoRaw.get());\n\t\t\tif (!pSourceContextInfo)\n\t\t\t\treturn false;\n\t\t\tabsFileID = pSourceContextInfo->resolveRelativeFileID(fileID);\n\t\t}\n\t\tif (absFileID == 0)\n\t\t\treturn false;\n\t\tstd::shared_ptr<FileContextInfo> pContextInfo = appContext.getContextInfo(absFileID);\n\t\tif (!pContextInfo)\n\t\t\treturn false;\n\t\tpFile = std::dynamic_pointer_cast<AssetsFileContextInfo>(pContextInfo);\n\t}\n\tif (!pFile)\n\t\treturn false;\n\tif (!pAssetInfo && !pReplacer)\n\t{\n\t\tpReplacer = pFile->getReplacer(pathID);\n\t\tif (!pReplacer)\n\t\t\tpAssetInfo = pFile->getAssetsFileContext()->getAssetsFileTable()->getAssetInfo(pathID);\n\t}\n\tif (!pAssetInfo && !pReplacer)\n\t\treturn false;\n\treturn true;\n}\nint32_t AssetIdentifier::getClassID()\n{\n\tif (pReplacer)\n\t\treturn pReplacer->GetClassID();\n\tif (pAssetInfo)\n\t\treturn (int32_t)pAssetInfo->curFileType;\n\treturn INT32_MIN;\n}\nuint16_t AssetIdentifier::getMonoScriptID()\n{\n\tif (pReplacer)\n\t\treturn pReplacer->GetMonoScriptID();\n\tif (pAssetInfo)\n\t\treturn pAssetInfo->scriptIndex;\n\treturn 0xFFFF;\n}\nuint64_t AssetIdentifier::getDataSize() //Will return 0 if resolve was not called successfully (unless the (pFile,pAssetInfo) constructor was called)\n{\n\tif (pReplacer)\n\t\treturn pReplacer->GetSize();\n\tif (pAssetInfo)\n\t\treturn pAssetInfo->curFileSize;\n\treturn 0;\n}\nsize_t AssetIdentifier::read(size_t size, void *buffer) //Returns the actually read bytes.\n{\n\tif (pReplacer)\n\t{\n\t\tIAssetsWriterToMemory *pWriter = Create_AssetsWriterToMemory(buffer, size);\n\t\tif (!pWriter)\n\t\t\treturn 0;\n\t\tuint64_t length = pReplacer->Write(0, pWriter);\n\t\tFree_AssetsWriter(pWriter);\n\t\treturn length;\n\t}\n\tif (pAssetInfo && pFile)\n\t{\n\t\tQWORD pos = pAssetInfo->absolutePos;\n\t\tuint32_t assetSize = pAssetInfo->curFileSize;\n\t\tif (size > assetSize)\n\t\t\tsize = assetSize;\n\t\t//Unsafe is OK here since we explicitly state the file position in the Read call.\n\t\tIAssetsReader *pReader = pFile->getAssetsFileContext()->getReaderUnsafe();\n\t\tif (!pReader)\n\t\t\treturn 0;\n\t\tuint64_t length = pReader->Read(pos, assetSize, buffer, false);\n\t\treturn length;\n\t}\n\treturn 0;\n}\n\nIAssetsReader_ptr AssetIdentifier::makeReader()\n{\n\tIAssetsReader_ptr ret(nullptr, DummyAssetsReaderDeleter);\n\tif (pReplacer)\n\t{\n\t\tif (pReplacer->GetSize() > SIZE_MAX)\n\t\t\treturn ret;\n\t\tIAssetsWriterToMemory *pWriter = Create_AssetsWriterToMemory((size_t)pReplacer->GetSize());\n\t\tif (!pWriter)\n\t\t\treturn ret;\n\t\tuint64_t length = pReplacer->Write(0, pWriter);\n\t\tvoid *dataBuffer = nullptr; size_t dataSize = 0;\n\t\tIAssetsReader *pReader = nullptr;\n\t\tif (pWriter->GetBuffer(dataBuffer, dataSize))\n\t\t{\n\t\t\tpReader = Create_AssetsReaderFromMemory(dataBuffer, dataSize, false, Free_AssetsWriterToMemory_DynBuf);\n\t\t\tif (pReader)\n\t\t\t\tpWriter->SetFreeBuffer(false);\n\t\t}\n\t\tFree_AssetsWriter(pWriter);\n\t\treturn IAssetsReader_ptr(pReader, Free_AssetsReader);// pReader;\n\t}\n\tif (pAssetInfo && pFile)\n\t{\n\t\tQWORD pos = pAssetInfo->absolutePos;\n\t\tuint32_t assetSize = pAssetInfo->curFileSize;\n\t\t//Unsafe is OK here since AssetsReaderFromReaderRange behaves like a view if alwaysSeek is set to true.\n\t\tIAssetsReader *pReader = pFile->getAssetsFileContext()->getReaderUnsafe();\n\t\tif (!pReader)\n\t\t\treturn ret;\n\t\treturn IAssetsReader_ptr(Create_AssetsReaderFromReaderRange(pReader, pos, assetSize, true), Free_AssetsReader);\n\t}\n\treturn ret;\n}\nbool AssetIdentifier::isBigEndian()\n{\n\tif (pFile)\n\t{ \n\t\tbool result; pFile->getEndianness(result); return result;\n\t}\n\treturn false;\n}\n\n\nAssetIterator::AssetIterator(AssetsFileContextInfo *pContextInfo, bool ignoreExisting, bool ignoreReplacers, bool ignoreRemoverReplacers)\n\t: pContextInfo(pContextInfo), pAssetsFileTable(nullptr), assetIndex(0), pAssetReplacerHint(nullptr),\n\tignoreReplacers(ignoreReplacers), ignoreExisting(ignoreExisting), ignoreRemoverReplacers(ignoreRemoverReplacers)\n{\n\tif (pContextInfo->pContext)\n\t\tpAssetsFileTable = pContextInfo->pContext->getAssetsFileTable();\n\tif (pAssetsFileTable && ignoreExisting)\n\t\tassetIndex = pAssetsFileTable->assetFileInfoCount;\n\tif (!ignoreReplacers)\n\t{\n\t\tpContextInfo->lockReplacersRead();\n\t\treplacersIterator = pContextInfo->pReplacersByPathID.cbegin();\n\t\tif (!ignoreExisting && pAssetsFileTable)\n\t\t{\n\t\t\tupdateAssetReplacerHint();\n\t\t\tif (pAssetReplacerHint && (*pAssetReplacerHint)->GetType() == AssetsReplacement_Remove)\n\t\t\t\t++(*this); //Skip removed assets\n\t\t}\n\t\tif (ignoreExisting || !pAssetsFileTable || assetIndex >= pAssetsFileTable->assetFileInfoCount)\n\t\t{\n\t\t\twhile (replacersIterator != pContextInfo->pReplacersByPathID.cend()\n\t\t\t\t&& (ignoreRemoverReplacers && replacersIterator->second.pReplacer->GetType() == AssetsReplacement_Remove)) //Skip removed assets\n\t\t\t\t++replacersIterator;\n\t\t}\n\t}\n}\nAssetIterator::~AssetIterator()\n{\n\tif (!ignoreReplacers && pContextInfo)\n\t\tpContextInfo->unlockReplacersRead();\n}\nAssetIterator::AssetIterator(AssetIterator &&other)\n{\n\tpContextInfo = other.pContextInfo;\n\tpAssetsFileTable = other.pAssetsFileTable;\n\tassetIndex = other.assetIndex;\n\tpAssetReplacerHint = other.pAssetReplacerHint;\n\tignoreReplacers = other.ignoreReplacers;\n\tignoreExisting = other.ignoreExisting;\n\tignoreRemoverReplacers = other.ignoreRemoverReplacers;\n\treplacersIterator = other.replacersIterator;\n\tother.ignoreExisting = true;\n\tother.ignoreReplacers = true; //The old iterator must not unlock the replacers list.\n}\nAssetIterator &AssetIterator::operator=(const AssetIterator &other)\n{\n\tif ((!ignoreReplacers && pContextInfo) && (other.ignoreReplacers || pContextInfo != other.pContextInfo))\n\t{\n\t\tif (pContextInfo) pContextInfo->unlockReplacersRead();\n\t}\n\tif ((ignoreReplacers || pContextInfo != other.pContextInfo) && !other.ignoreReplacers)\n\t\tother.pContextInfo->lockReplacersRead();\n\tpContextInfo = other.pContextInfo;\n\tpAssetsFileTable = other.pAssetsFileTable;\n\tassetIndex = other.assetIndex;\n\tpAssetReplacerHint = other.pAssetReplacerHint;\n\tignoreExisting = other.ignoreExisting;\n\tignoreReplacers = other.ignoreReplacers;\n\tignoreRemoverReplacers = other.ignoreRemoverReplacers;\n\treplacersIterator = other.replacersIterator;\n\treturn *this;\n}\nvoid AssetIterator::updateAssetReplacerHint()\n{\n\tpAssetReplacerHint = nullptr;\n\tif (!ignoreReplacers && assetIndex < pAssetsFileTable->assetFileInfoCount)\n\t{\n\t\t//Look for replacers for this asset.\n\t\tauto it = pContextInfo->pReplacersByPathID.find((pathid_t)pAssetsFileTable->pAssetFileInfo[assetIndex].index);\n\t\tif (it != pContextInfo->pReplacersByPathID.end())\n\t\t{\n\t\t\tpAssetReplacerHint = &it->second.pReplacer;\n\t\t\tassert(it->second.replacesExistingAsset);\n\t\t}\n\t}\n}\nAssetIterator &AssetIterator::operator++()\n{\n\tbool increment = true;\n\tif (!ignoreExisting && pAssetsFileTable && assetIndex < pAssetsFileTable->assetFileInfoCount)\n\t{\n\t\tif (assetIndex == pAssetsFileTable->assetFileInfoCount - 1)\n\t\t\tincrement = false;\n\t\twhile (++assetIndex < pAssetsFileTable->assetFileInfoCount && assetIndex != 0) //Also detect overflow\n\t\t{\n\t\t\tupdateAssetReplacerHint();\n\t\t\tif (pAssetReplacerHint && (*pAssetReplacerHint)->GetType() == AssetsReplacement_Remove)\n\t\t\t\tcontinue; //Skip removed assets\n\t\t\treturn (*this);\n\t\t}\n\t\tassetIndex = pAssetsFileTable->assetFileInfoCount;\n\t}\n\tif (!ignoreReplacers && pContextInfo)\n\t{\n\t\tif (increment) ++replacersIterator;\n\t\twhile (replacersIterator != pContextInfo->pReplacersByPathID.cend()\n\t\t\t&& ((!ignoreExisting && replacersIterator->second.replacesExistingAsset) //Skip replacers that were already iterated over before.\n\t\t\t|| (replacersIterator->second.pReplacer->GetType() == AssetsReplacement_Remove))) //Skip removed assets\n\t\t\t++replacersIterator;\n\t\treturn (*this);\n\t}\n\treturn (*this);\n}\nbool AssetIterator::isEnd() const\n{\n\tif (!ignoreExisting && pAssetsFileTable)\n\t{\n\t\tif (assetIndex < pAssetsFileTable->assetFileInfoCount)\n\t\t\treturn false;\n\t}\n\tif (!ignoreReplacers && pContextInfo)\n\t{\n\t\tif (replacersIterator != pContextInfo->pReplacersByPathID.cend())\n\t\t\treturn false;\n\t}\n\treturn true;\n}\nvoid AssetIterator::get(AssetIdentifier &identifier)\n{\n\tassert(pContextInfo != nullptr);\n\tassert(!isEnd());\n\tidentifier.fileID = pContextInfo->getFileID();\n\tidentifier.fileIDIsRelative = false;\n\tif (identifier.pFile.get() != pContextInfo)\n\t\tidentifier.pFile = nullptr;\n\tif (!ignoreExisting && pAssetsFileTable && assetIndex < pAssetsFileTable->assetFileInfoCount)\n\t{\n\t\tidentifier.pAssetInfo = &pAssetsFileTable->pAssetFileInfo[assetIndex];\n\t\tidentifier.pathID = (pathid_t)identifier.pAssetInfo->index;\n\t\tif (pAssetReplacerHint)\n\t\t\tidentifier.pReplacer = *pAssetReplacerHint;\n\t\telse\n\t\t\tidentifier.pReplacer = nullptr;\n\t\treturn;\n\t}\n\tif (!ignoreReplacers && pContextInfo)\n\t{\n\t\tidentifier.pAssetInfo = nullptr;\n\t\tidentifier.pReplacer = replacersIterator->second.pReplacer;\n\t\tidentifier.pathID = (pathid_t)identifier.pReplacer->GetPathID();\n\t\treturn;\n\t}\n\tassert(false);\n\tidentifier.pAssetInfo = nullptr;\n\tidentifier.pReplacer = nullptr;\n\tidentifier.pathID = 0;\n}\n'