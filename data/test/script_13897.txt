b"{-# LANGUAGE CPP        #-}\n{-# LANGUAGE Rank2Types #-}\n-- We disable the following warning because this module purposefully defines\n-- orphan instances. This is a design decision in Dunai, so that we give\n-- implementors further flexibility while giving most users the features they\n-- expect.\n{-# OPTIONS_GHC -fno-warn-orphans #-}\n-- |\n-- Copyright  : (c) Ivan Perez and Manuel Baerenz, 2016\n-- License    : BSD3\n-- Maintainer : ivan.perez@keera.co.uk\n--\n-- Monadic Stream Functions are synchronized stream functions with side\n-- effects.\n--\n-- 'MSF's are defined by a function\n-- @unMSF :: MSF m a b -> a -> m (b, MSF m a b)@\n-- that executes one step of a simulation, and produces an output in a monadic\n-- context, and a continuation to be used for future steps.\n--\n-- 'MSF's are a generalisation of the implementation mechanism used by Yampa,\n-- Wormholes and other FRP and reactive implementations.\n--\n-- When combined with different monads, they produce interesting effects. For\n-- example, when combined with the 'Maybe' monad, they become transformations\n-- that may stop producing outputs (and continuations). The 'Either' monad\n-- gives rise to 'MSF's that end with a result (akin to Tasks in Yampa, and\n-- Monadic FRP).\n--\n-- Flattening, that is, going from some structure @MSF (t m) a b@ to @MSF m a b@\n-- for a specific transformer @t@ often gives rise to known FRP constructs.\n-- For instance, flattening with 'EitherT' gives rise to switching, and\n-- flattening with 'ListT' gives rise to parallelism with broadcasting.\n--\n-- 'MSF's can be used to implement many FRP variants, including Arrowized FRP,\n-- Classic FRP, and plain reactive programming. Arrowized and applicative\n-- syntax are both supported.\n--\n-- For a very detailed introduction to 'MSF's, see:\n-- <http://dl.acm.org/citation.cfm?id=2976010>\n-- (mirror: <http://www.cs.nott.ac.uk/~psxip1/#FRPRefactored>).\nmodule Data.MonadicStreamFunction.Core\n  ( -- * Types\n    MSF\n    -- * Lifting and Monadic transformations\n    -- ** Lifting point-wise computations\n  , constM\n  , arrM\n  , liftBaseM\n    -- ** Trans-monadic MSF combinators\n    -- *** MonadBase\n  , liftBaseS\n  , (^>>>)\n  , (>>>^)\n    -- *** MonadTrans\n  , liftTransS\n    -- *** Generic Monadic Transformations\n  , morphS\n  , morphGS\n    -- * Depending on the past\n  , feedback\n    -- * Simulation\n  , reactimate\n  , embed\n  , module X\n  )\n  where\n\n-- External imports\nimport           Control.Arrow             (Arrow (..), (>>>))\nimport qualified Control.Arrow             as X\nimport           Control.Category          as C (id, (.))\nimport           Control.Monad.Base        (MonadBase, liftBase)\nimport           Control.Monad.Trans.Class (MonadTrans, lift)\nimport           Prelude                   hiding (id, sum, (.))\n\n#if !MIN_VERSION_base(4,8,0)\nimport Control.Applicative (Applicative(..))\n#endif\n\n-- Internal imports\nimport Data.MonadicStreamFunction.InternalCore (MSF, embed, feedback, morphGS,\n                                                reactimate)\n\n-- * Definitions\n\n-- | 'Arrow' instance for 'MSF's.\ninstance Monad m => Arrow (MSF m) where\n  arr f = arrM (return . f)\n\n  first =\n    -- This implementation is equivalent to:\n    -- first sf = MSF $ \\(a, c) -> do\n    --   (b, sf') <- unMSF sf a\n    --   b `seq` return ((b, c), first sf')\n    morphGS $ \\f (a, c) -> do\n      (b, msf') <- f a\n      return ((b, c), msf')\n\n-- * Functor and applicative instances\n\n-- | 'Functor' instance for 'MSF's.\ninstance Monad m => Functor (MSF m a) where\n  fmap f msf = msf >>> arr f\n\n-- | 'Applicative' instance for 'MSF's.\ninstance (Functor m, Monad m) => Applicative (MSF m a) where\n  -- It is possible to define this instance with only Applicative m\n  pure = arr . const\n\n  fs <*> bs = (fs &&& bs) >>> arr (uncurry ($))\n\n-- ** Lifting point-wise computations\n\n-- | Lifts a monadic computation into a Stream.\nconstM :: Monad m => m b -> MSF m a b\nconstM = arrM . const\n\n-- | Apply a monadic transformation to every element of the input stream.\n--\n-- Generalisation of 'arr' from 'Arrow' to monadic functions.\narrM :: Monad m => (a -> m b) -> MSF m a b\narrM f =\n  -- This implementation is equivalent to:\n  -- arrM f = go\n  --   where\n  --     go = MSF $ \\a -> do\n  --            b <- f a\n  --            return (b, go)\n  morphGS (\\i a -> i a >>= \\(_, c) -> f a >>= \\b -> return (b, c)) C.id\n\n-- | Monadic lifting from one monad into another\nliftBaseM :: (Monad m2, MonadBase m1 m2) => (a -> m1 b) -> MSF m2 a b\nliftBaseM = arrM . (liftBase .)\n\n-- ** MSF combinators that apply monad transformations\n\n-- | Lift innermost monadic actions in monad stack (generalisation of\n-- 'liftIO').\nliftBaseS :: (Monad m2, MonadBase m1 m2) => MSF m1 a b -> MSF m2 a b\nliftBaseS = morphS liftBase\n\n-- *** MonadBase\n\n-- | Lift the first 'MSF' into the monad of the second.\n(^>>>) :: MonadBase m1 m2 => MSF m1 a b -> MSF m2 b c -> MSF m2 a c\nsf1 ^>>> sf2 = liftBaseS sf1 >>> sf2\n{-# INLINE (^>>>) #-}\n\n-- | Lift the second 'MSF' into the monad of the first.\n(>>>^) :: MonadBase m1 m2 => MSF m2 a b -> MSF m1 b c -> MSF m2 a c\nsf1 >>>^ sf2 = sf1 >>> liftBaseS sf2\n{-# INLINE (>>>^) #-}\n\n-- *** MonadTrans\n\n-- | Lift inner monadic actions in monad stacks.\nliftTransS :: (MonadTrans t, Monad m, Monad (t m))\n           => MSF m a b\n           -> MSF (t m) a b\nliftTransS = morphS lift\n\n-- *** Generic monadic transformation\n\n-- | Apply trans-monadic actions (in an arbitrary way).\n--\n-- This is just a convenience function when you have a function to move across\n-- monads, because the signature of 'morphGS' is a bit complex.\nmorphS :: (Monad m2, Monad m1)\n       => (forall c . m1 c -> m2 c)\n       -> MSF m1 a b\n       -> MSF m2 a b\nmorphS morph = morphGS morph'\n  where\n    -- The following makes the a's and the b's the same, and it just says:\n    -- whatever function m1F you give me to apply to every sample, I use morph\n    -- on the result to go from m1 to m2.\n    --\n    -- Remember that:\n    -- morphGS :: Monad m2\n    --         => (forall c . (a1 -> m1 (b1, c)) -> (a2 -> m2 (b2, c)))\n    --           -- ^ The natural transformation. @mi@, @ai@ and @bi@ for\n    --           --   @i = 1, 2@ can be chosen freely, but @c@ must be\n    --           --   universally quantified\n    --         -> MSF m1 a1 b1\n    --         -> MSF m2 a2 b2\n    --\n    --  morph' :: (forall c . (a -> m1 (b, c)) -> (a -> m2 (b, c)))\n    morph' m1F = morph . m1F\n"