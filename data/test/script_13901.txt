b'module DunaiExamplesMonads where\n\nimport Control.Monad (when, MonadPlus)\nimport Data.MonadicStreamFunction\nimport Data.MonadicStreamFunction.Instances.ArrowPlus\nimport Control.Monad.Trans.Class\nimport Control.Monad.Trans.MSF.Except\nimport Control.Monad.Trans.MSF.Reader\nimport Control.Monad.Trans.MSF.Writer\nimport Control.Monad.Trans.MSF.List\nimport Control.Monad.Trans.MSF.State\nimport Control.Monad.Trans.MSF.Maybe\n\ntype GameEnv1 = ReaderT GameSettings\n\ndata GameSettings = GameSettings\n  {  leftPlayerPos   :: Int\n  ,  rightPlayerPos  :: Int\n  }\n\ntype Ball = Int\n\nballToRight  ::   Monad m => MSF (GameEnv1 m) () Ball\nballToRight  =\n  count >>> arrM (\\n -> (n +) <$> asks leftPlayerPos)\n\nhitRight    ::  Monad m => MSF (GameEnv1 m) Ball Bool\nhitRight    =   arrM (\\i -> (i >=) <$> asks rightPlayerPos)\n\ntype GameEnv2 m =\n  WriterT [String] (ReaderT GameSettings m)\n\nballToLeft2      :: Monad m => MSF (GameEnv2 m) () Ball\nballToLeft2      =\n  count >>> arrM addRightPlayerPos >>> arrM checkHitR\n\n  where  checkHitR    :: Monad m => Int -> GameEnv2 m Int\n         checkHitR n  = do\n           rp <- lift (asks rightPlayerPos)\n           when (rp > n) $ tell [ "Ball at " ++ show n ]\n           return n\n\n         addRightPlayerPos = (\\n -> (n +) <$> lift (asks leftPlayerPos))\n\n\nhitLeft2    ::  Monad m => MSF (GameEnv2 m) Ball Bool\nhitLeft2    =   arrM (\\i -> (i >=) <$> lift (asks rightPlayerPos))\n\n\nballToRight2      :: Monad m => MSF (GameEnv2 m) () Ball\nballToRight2      =\n  count >>> arrM addLeftPlayerPos >>> arrM checkHitR\n\n  where  checkHitR    :: Monad m => Int -> GameEnv2 m Int\n         checkHitR n  = do\n           rp <- lift (asks rightPlayerPos)\n           when (rp > n) $ tell [ "Ball at " ++ show n ]\n           return n\n\n         addLeftPlayerPos = (\\n -> (n +) <$> lift (asks leftPlayerPos))\n\n\nhitRight2    ::  Monad m => MSF (GameEnv2 m) Ball Bool\nhitRight2    =   arrM (\\i -> (i >=) <$> lift (asks rightPlayerPos))\n\nballBounceOnce  :: (Monad m, MonadPlus m) =>  MSF (GameEnv2 m) () Ball\nballBounceOnce  =  ballUntilRight `catchMaybe` ballLeft2\n\nballLeft2   ::  (Monad m, MonadPlus m) => MSF (GameEnv2 m) () Ball\nballLeft2   =   singleBallLeft <+> singleBallLeft\n  where\n    singleBallLeft =\n      count >>>\n        arrM (\\n -> (\\p -> p - n) <$> lift (asks rightPlayerPos))\n\nballUntilRight  ::  Monad m => MSF (MaybeT (GameEnv2 m)) () Ball\nballUntilRight  =   liftTransS (ballToRight2\n                    >>> (arr id &&& hitRight2))\n                    >>> arrM filterHit\n  where\n    filterHit (b, c) = MaybeT $ return $\n      if c then Nothing else Just b\n\nballUntilLeft  ::  Monad m => MSF (MaybeT (GameEnv2 m)) () Ball\nballUntilLeft  =   liftTransS (ballToLeft2\n                    >>> (arr id &&& hitLeft2))\n                    >>> arrM filterHit\n  where\n    filterHit (b, c) = MaybeT $ return $\n      if c then Nothing else Just b\n\n\ngame2 ::  Monad m => MSF (GameEnv2 m) () Ball\ngame2 =   ballUntilRight `catchMaybe` (ballUntilLeft `catchMaybe` game2)\n\ntype GameEnv3 m = ReaderT GameSettings (ListT m)\n\nballLeft   ::  Monad m => MSF (GameEnv3 m) () Ball\nballLeft   =   singleBallLeft <+> singleBallLeft\n  where\n    singleBallLeft =\n      count >>>\n        arrM (\\n -> (\\p -> p - n) <$> asks rightPlayerPos)\n\n\nballToRight3  ::   Monad m => MSF (GameEnv3 m) () Ball\nballToRight3  =\n  count >>> arrM (\\n -> (n +) <$> asks leftPlayerPos)\n\nhitRight3 :: Monad m => MSF (GameEnv3 m) Ball Bool\nhitRight3 =  arrM (\\i -> (i >=) <$> asks rightPlayerPos)\n\ngame3  :: Monad m\n       => MSF (GameEnv3 (StateT Integer m)) () Ball\ngame3  =        ballToRight3  `untilMaybe` hitRight3\n  `catchMaybe`  ballToLeft3   `untilMaybe` hitLeft3\n  `catchMaybe`  (lift (lift incOneRound)  `andThen` game3)\n\nballToLeft3  ::   Monad m => MSF (GameEnv3 m) () Ball\nballToLeft3  =\n  count >>> arrM (\\n -> (n +) <$> asks rightPlayerPos)\n\nhitLeft3 :: Monad m => MSF (GameEnv3 m) Ball Bool\nhitLeft3 =  arrM (\\i -> (i >=) <$> asks leftPlayerPos)\n\nincOneRound  :: Monad m => StateT Integer m ()\nincOneRound  = modify (+1)\n\nmainMSF :: MSF IO () ()\nmainMSF = (runStateS_ (widthFirst parallelGame) 0) >>> arrM print\n where\n   parallelGame :: Monad m => MSF (ListT (StateT Integer m)) () (Ball, Ball)\n   parallelGame  =    runReaderS_ game3 (GameSettings 20 17)\n                 &&&  runReaderS_ game3 (GameSettings 10  4)\n\nandThen :: Monad m\n        => m ()\n        -> MSF m a b\n        -> MSF m a b\nandThen a b = performOnFirstSample (a >> return b)\n'