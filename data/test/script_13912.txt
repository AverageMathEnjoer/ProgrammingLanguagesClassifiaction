b'/*\n * Copyright (C) 2007 The Android Open Source Project Licensed under the Apache\n * License, Version 2.0 (the "License"); you may not use this file except in\n * compliance with the License. You may obtain a copy of the License at\n * http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law\n * or agreed to in writing, software distributed under the License is\n * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\npackage com.naman14.timber.helpers;\n\nimport android.content.Context;\nimport android.content.Intent;\nimport android.media.AudioManager;\nimport android.os.Handler;\nimport android.os.Message;\nimport android.os.PowerManager;\nimport android.os.PowerManager.WakeLock;\nimport androidx.legacy.content.WakefulBroadcastReceiver;\nimport android.util.Log;\nimport android.view.KeyEvent;\n\nimport com.naman14.timber.MusicService;\nimport com.naman14.timber.activities.MainActivity;\nimport com.naman14.timber.utils.PreferencesUtility;\n\n/**\n * Used to control headset playback.\n * Single press: pause/resume\n * Double press: next track\n * Triple press: previous track\n * Long press: voice search\n */\npublic class MediaButtonIntentReceiver extends WakefulBroadcastReceiver {\n    private static final boolean DEBUG = false;\n    private static final String TAG = "ButtonIntentReceiver";\n\n    private static final int MSG_LONGPRESS_TIMEOUT = 1;\n    private static final int MSG_HEADSET_DOUBLE_CLICK_TIMEOUT = 2;\n\n    private static final int LONG_PRESS_DELAY = 1000;\n    private static final int DOUBLE_CLICK = 800;\n\n    private static WakeLock mWakeLock = null;\n    private static int mClickCounter = 0;\n    private static long mLastClickTime = 0;\n    private static boolean mDown = false;\n    private static boolean mLaunched = false;\n\n    private static Handler mHandler = new Handler() {\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public void handleMessage(final Message msg) {\n            switch (msg.what) {\n                case MSG_LONGPRESS_TIMEOUT:\n                    if (DEBUG) Log.v(TAG, "Handling longpress timeout, launched " + mLaunched);\n                    if (!mLaunched) {\n                        final Context context = (Context) msg.obj;\n                        final Intent i = new Intent();\n                        i.setClass(context, MainActivity.class);\n                        i.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TOP);\n                        context.startActivity(i);\n                        mLaunched = true;\n                    }\n                    break;\n\n                case MSG_HEADSET_DOUBLE_CLICK_TIMEOUT:\n                    final int clickCount = msg.arg1;\n                    final String command;\n\n                    if (DEBUG) Log.v(TAG, "Handling headset click, count = " + clickCount);\n                    switch (clickCount) {\n                        case 1:\n                            command = MusicService.CMDTOGGLEPAUSE;\n                            break;\n                        case 2:\n                            command = MusicService.CMDNEXT;\n                            break;\n                        case 3:\n                            command = MusicService.CMDPREVIOUS;\n                            break;\n                        default:\n                            command = null;\n                            break;\n                    }\n\n                    if (command != null) {\n                        final Context context = (Context) msg.obj;\n                        startService(context, command);\n                    }\n                    break;\n            }\n            releaseWakeLockIfHandlerIdle();\n        }\n    };\n\n    private static void startService(Context context, String command) {\n        final Intent i = new Intent(context, MusicService.class);\n        i.setAction(MusicService.SERVICECMD);\n        i.putExtra(MusicService.CMDNAME, command);\n        i.putExtra(MusicService.FROM_MEDIA_BUTTON, true);\n        startWakefulService(context, i);\n    }\n\n    private static void acquireWakeLockAndSendMessage(Context context, Message msg, long delay) {\n        if (mWakeLock == null) {\n            Context appContext = context.getApplicationContext();\n            PowerManager pm = (PowerManager) appContext.getSystemService(Context.POWER_SERVICE);\n            mWakeLock = pm.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, "Timber headset button");\n            mWakeLock.setReferenceCounted(false);\n        }\n        if (DEBUG) Log.v(TAG, "Acquiring wake lock and sending " + msg.what);\n        // Make sure we don\'t indefinitely hold the wake lock under any circumstances\n        mWakeLock.acquire(10000);\n\n        mHandler.sendMessageDelayed(msg, delay);\n    }\n\n    private static void releaseWakeLockIfHandlerIdle() {\n        if (mHandler.hasMessages(MSG_LONGPRESS_TIMEOUT)\n                || mHandler.hasMessages(MSG_HEADSET_DOUBLE_CLICK_TIMEOUT)) {\n            if (DEBUG) Log.v(TAG, "Handler still has messages pending, not releasing wake lock");\n            return;\n        }\n\n        if (mWakeLock != null) {\n            if (DEBUG) Log.v(TAG, "Releasing wake lock");\n            mWakeLock.release();\n            mWakeLock = null;\n        }\n    }\n\n    @Override\n    public void onReceive(final Context context, final Intent intent) {\n        final String intentAction = intent.getAction();\n        if (AudioManager.ACTION_AUDIO_BECOMING_NOISY.equals(intentAction)) {\n            if (PreferencesUtility.getInstance(context).pauseEnabledOnDetach())\n                startService(context, MusicService.CMDPAUSE);\n        } else if (Intent.ACTION_MEDIA_BUTTON.equals(intentAction)) {\n            final KeyEvent event = intent.getParcelableExtra(Intent.EXTRA_KEY_EVENT);\n            if (event == null) {\n                return;\n            }\n\n            final int keycode = event.getKeyCode();\n            final int action = event.getAction();\n            final long eventtime = event.getEventTime();\n\n            String command = null;\n            switch (keycode) {\n                case KeyEvent.KEYCODE_MEDIA_STOP:\n                    command = MusicService.CMDSTOP;\n                    break;\n                case KeyEvent.KEYCODE_HEADSETHOOK:\n                case KeyEvent.KEYCODE_MEDIA_PLAY_PAUSE:\n                    command = MusicService.CMDTOGGLEPAUSE;\n                    break;\n                case KeyEvent.KEYCODE_MEDIA_NEXT:\n                    command = MusicService.CMDNEXT;\n                    break;\n                case KeyEvent.KEYCODE_MEDIA_PREVIOUS:\n                    command = MusicService.CMDPREVIOUS;\n                    break;\n                case KeyEvent.KEYCODE_MEDIA_PAUSE:\n                    command = MusicService.CMDPAUSE;\n                    break;\n                case KeyEvent.KEYCODE_MEDIA_PLAY:\n                    command = MusicService.CMDPLAY;\n                    break;\n            }\n            if (command != null) {\n                if (action == KeyEvent.ACTION_DOWN) {\n                    if (mDown) {\n                        if (MusicService.CMDTOGGLEPAUSE.equals(command)\n                                || MusicService.CMDPLAY.equals(command)) {\n                            if (mLastClickTime != 0\n                                    && eventtime - mLastClickTime > LONG_PRESS_DELAY) {\n                                acquireWakeLockAndSendMessage(context,\n                                        mHandler.obtainMessage(MSG_LONGPRESS_TIMEOUT, context), 0);\n                            }\n                        }\n                    } else if (event.getRepeatCount() == 0) {\n\n                        if (keycode == KeyEvent.KEYCODE_HEADSETHOOK) {\n                            if (eventtime - mLastClickTime >= DOUBLE_CLICK) {\n                                mClickCounter = 0;\n                            }\n\n                            mClickCounter++;\n                            if (DEBUG) Log.v(TAG, "Got headset click, count = " + mClickCounter);\n                            mHandler.removeMessages(MSG_HEADSET_DOUBLE_CLICK_TIMEOUT);\n\n                            Message msg = mHandler.obtainMessage(\n                                    MSG_HEADSET_DOUBLE_CLICK_TIMEOUT, mClickCounter, 0, context);\n\n                            long delay = mClickCounter < 3 ? DOUBLE_CLICK : 0;\n                            if (mClickCounter >= 3) {\n                                mClickCounter = 0;\n                            }\n                            mLastClickTime = eventtime;\n                            acquireWakeLockAndSendMessage(context, msg, delay);\n                        } else {\n                            startService(context, command);\n                        }\n                        mLaunched = false;\n                        mDown = true;\n                    }\n                } else {\n                    mHandler.removeMessages(MSG_LONGPRESS_TIMEOUT);\n                    mDown = false;\n                }\n                if (isOrderedBroadcast()) {\n                    abortBroadcast();\n                }\n                releaseWakeLockIfHandlerIdle();\n            }\n        }\n    }\n}\n'