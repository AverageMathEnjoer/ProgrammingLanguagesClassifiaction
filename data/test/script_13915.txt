b'#include <vector>\n#include <unistd.h>\n#include <mntent.h>\n#include <android_prop.h>\n#include <xhook.h>\n#include <dlfcn.h>\n#include <elf_util.h>\n\n#include "jni_hooks.h"\n#include "logging.h"\n#include "module.h"\n#include "entry.h"\n\nnamespace jni::zygote {\n    const char *classname = "com/android/internal/os/Zygote";\n    JNINativeMethod *nativeForkAndSpecialize = nullptr;\n    JNINativeMethod *nativeSpecializeAppProcess = nullptr;\n    JNINativeMethod *nativeForkSystemServer = nullptr;\n}\n\nstatic int shouldSkipUid(int uid) {\n    int appId = uid % 100000;\n    if (appId >= 10000 && appId <= 19999) return 0;\n    return 1;\n}\n\n// -----------------------------------------------------------------\n\nstatic bool useTableOverride = false;\n\nusing GetJniNativeInterface_t = const JNINativeInterface *();\nusing SetTableOverride_t = void(JNINativeInterface *);\nusing RegisterNatives_t = jint(JNIEnv *, jclass, const JNINativeMethod *, jint);\n\nstatic SetTableOverride_t *setTableOverride = nullptr;\nstatic RegisterNatives_t *old_RegisterNatives = nullptr;\n\nstatic std::unique_ptr<JNINativeMethod[]>\nonRegisterZygote(const char *className, const JNINativeMethod *methods, int numMethods) {\n\n    auto newMethods = std::make_unique<JNINativeMethod[]>(numMethods);\n    memcpy(newMethods.get(), methods, sizeof(JNINativeMethod) * numMethods);\n\n    JNINativeMethod method;\n    for (int i = 0; i < numMethods; ++i) {\n        method = methods[i];\n\n        if (strcmp(method.name, "nativeForkAndSpecialize") == 0) {\n            jni::zygote::nativeForkAndSpecialize = new JNINativeMethod{method.name,\n                                                                       method.signature,\n                                                                       method.fnPtr};\n\n            if (strcmp(nativeForkAndSpecialize_r_sig, method.signature) == 0)\n                newMethods[i].fnPtr = (void *) nativeForkAndSpecialize_r;\n            else if (strcmp(nativeForkAndSpecialize_p_sig, method.signature) == 0)\n                newMethods[i].fnPtr = (void *) nativeForkAndSpecialize_p;\n            else if (strcmp(nativeForkAndSpecialize_oreo_sig, method.signature) == 0)\n                newMethods[i].fnPtr = (void *) nativeForkAndSpecialize_oreo;\n            else if (strcmp(nativeForkAndSpecialize_marshmallow_sig, method.signature) == 0)\n                newMethods[i].fnPtr = (void *) nativeForkAndSpecialize_marshmallow;\n\n            else if (strcmp(nativeForkAndSpecialize_r_dp3_sig, method.signature) == 0)\n                newMethods[i].fnPtr = (void *) nativeForkAndSpecialize_r_dp3;\n            else if (strcmp(nativeForkAndSpecialize_r_dp2_sig, method.signature) == 0)\n                newMethods[i].fnPtr = (void *) nativeForkAndSpecialize_r_dp2;\n\n            else if (strcmp(nativeForkAndSpecialize_q_alternative_sig, method.signature) == 0)\n                newMethods[i].fnPtr = (void *) nativeForkAndSpecialize_q_alternative;\n\n            else if (strcmp(nativeForkAndSpecialize_samsung_p_sig, method.signature) == 0)\n                newMethods[i].fnPtr = (void *) nativeForkAndSpecialize_samsung_p;\n            else if (strcmp(nativeForkAndSpecialize_samsung_o_sig, method.signature) == 0)\n                newMethods[i].fnPtr = (void *) nativeForkAndSpecialize_samsung_o;\n            else if (strcmp(nativeForkAndSpecialize_samsung_n_sig, method.signature) == 0)\n                newMethods[i].fnPtr = (void *) nativeForkAndSpecialize_samsung_n;\n            else if (strcmp(nativeForkAndSpecialize_samsung_m_sig, method.signature) == 0)\n                newMethods[i].fnPtr = (void *) nativeForkAndSpecialize_samsung_m;\n\n            else\n                LOGW("found nativeForkAndSpecialize but signature %s mismatch", method.signature);\n\n            auto replaced = newMethods[i].fnPtr != methods[i].fnPtr;\n            if (replaced) {\n                LOGI("replaced com.android.internal.os.Zygote#nativeForkAndSpecialize");\n            }\n        } else if (strcmp(method.name, "nativeSpecializeAppProcess") == 0) {\n            jni::zygote::nativeSpecializeAppProcess = new JNINativeMethod{method.name,\n                                                                          method.signature,\n                                                                          method.fnPtr};\n\n            if (strcmp(nativeSpecializeAppProcess_r_sig, method.signature) == 0)\n                newMethods[i].fnPtr = (void *) nativeSpecializeAppProcess_r;\n            else if (strcmp(nativeSpecializeAppProcess_q_sig, method.signature) == 0)\n                newMethods[i].fnPtr = (void *) nativeSpecializeAppProcess_q;\n            else if (strcmp(nativeSpecializeAppProcess_q_alternative_sig, method.signature) == 0)\n                newMethods[i].fnPtr = (void *) nativeSpecializeAppProcess_q_alternative;\n            else if (strcmp(nativeSpecializeAppProcess_sig_samsung_q, method.signature) == 0)\n                newMethods[i].fnPtr = (void *) nativeSpecializeAppProcess_samsung_q;\n\n            else if (strcmp(nativeSpecializeAppProcess_r_dp3_sig, method.signature) == 0)\n                newMethods[i].fnPtr = (void *) nativeSpecializeAppProcess_r_dp3;\n            else if (strcmp(nativeSpecializeAppProcess_r_dp2_sig, method.signature) == 0)\n                newMethods[i].fnPtr = (void *) nativeSpecializeAppProcess_r_dp2;\n\n            else\n                LOGW("found nativeSpecializeAppProcess but signature %s mismatch",\n                     method.signature);\n\n            auto replaced = newMethods[i].fnPtr != methods[i].fnPtr;\n            if (replaced) {\n                LOGI("replaced com.android.internal.os.Zygote#nativeSpecializeAppProcess");\n            }\n        } else if (strcmp(method.name, "nativeForkSystemServer") == 0) {\n            jni::zygote::nativeForkSystemServer = new JNINativeMethod{method.name, method.signature,\n                                                                      method.fnPtr};\n\n            if (strcmp(nativeForkSystemServer_sig, method.signature) == 0)\n                newMethods[i].fnPtr = (void *) nativeForkSystemServer;\n            else if (strcmp(nativeForkSystemServer_samsung_q_sig, method.signature) == 0)\n                newMethods[i].fnPtr = (void *) nativeForkSystemServer_samsung_q;\n            else\n                LOGW("found nativeForkSystemServer but signature %s mismatch", method.signature);\n\n            auto replaced = newMethods[i].fnPtr != methods[i].fnPtr;\n            if (replaced) {\n                LOGI("replaced com.android.internal.os.Zygote#nativeForkSystemServer");\n            }\n        }\n    }\n\n    return newMethods;\n}\n\nstatic std::unique_ptr<JNINativeMethod[]>\nhandleRegisterNative(const char *className, const JNINativeMethod *methods, int numMethods) {\n    if (strcmp("com/android/internal/os/Zygote", className) == 0) {\n        return onRegisterZygote(className, methods, numMethods);\n    } else {\n        return nullptr;\n    }\n}\n\n#define XHOOK_REGISTER(PATH_REGEX, NAME) \\\n    if (xhook_register(PATH_REGEX, #NAME, (void*) new_##NAME, (void **) &old_##NAME) != 0) \\\n        LOGE("failed to register hook " #NAME "."); \\\n\n#define NEW_FUNC_DEF(ret, func, ...) \\\n    using func##_t = ret(__VA_ARGS__); \\\n    static func##_t *old_##func; \\\n    static ret new_##func(__VA_ARGS__)\n\nNEW_FUNC_DEF(int, jniRegisterNativeMethods, JNIEnv *env, const char *className,\n             const JNINativeMethod *methods, int numMethods) {\n    LOGD("jniRegisterNativeMethods %s", className);\n\n    auto newMethods = handleRegisterNative(className, methods, numMethods);\n    int res = old_jniRegisterNativeMethods(env, className, newMethods ? newMethods.get() : methods,\n                                           numMethods);\n    /*if (!newMethods) {\n        NativeMethod::jniRegisterNativeMethodsPost(env, className, methods, numMethods);\n    }*/\n    return res;\n}\n\nstatic jclass zygoteClass;\n\nstatic void prepareClassesForRegisterNativeHook(JNIEnv *env) {\n    static bool called = false;\n    if (called) return;\n    called = true;\n\n    auto _zygoteClass = env->FindClass("com/android/internal/os/Zygote");\n\n    // There are checks that enforces no local refs exists during Runtime::Start, make them global ref\n    zygoteClass = (jclass) env->NewGlobalRef(_zygoteClass);\n\n    env->DeleteLocalRef(_zygoteClass);\n}\n\nstatic int\nnew_RegisterNative(JNIEnv *env, jclass cls, const JNINativeMethod *methods, jint numMethods) {\n    prepareClassesForRegisterNativeHook(env);\n\n    const char *className;\n    if (zygoteClass != nullptr && env->IsSameObject(zygoteClass, cls)) {\n        className = "com/android/internal/os/Zygote";\n        LOGD("RegisterNative %s", className);\n        env->DeleteGlobalRef(zygoteClass);\n        zygoteClass = nullptr;\n    } else {\n        className = "";\n    }\n\n    auto newMethods = handleRegisterNative(className, methods, numMethods);\n    auto res = old_RegisterNatives(env, cls, newMethods ? newMethods.get() : methods, numMethods);\n    return res;\n}\n\n#define RestoreJNIMethod(_cls, method) \\\n    if (jni::_cls::method != nullptr) { \\\n        if (old_jniRegisterNativeMethods) \\\n        old_jniRegisterNativeMethods(env, jni::_cls::classname, jni::_cls::method, 1); \\\n        delete jni::_cls::method; \\\n    }\n\nvoid jni::RestoreHooks(JNIEnv *env) {\n    if (useTableOverride) {\n        setTableOverride(nullptr);\n    } else {\n        xhook_register(".*\\\\libandroid_runtime.so$", "jniRegisterNativeMethods",\n                       (void *) old_jniRegisterNativeMethods,\n                       nullptr);\n        if (xhook_refresh(0) == 0) {\n            xhook_clear();\n        }\n    }\n\n    RestoreJNIMethod(zygote, nativeForkAndSpecialize)\n    RestoreJNIMethod(zygote, nativeSpecializeAppProcess)\n    RestoreJNIMethod(zygote, nativeForkSystemServer)\n\n    LOGD("hooks restored");\n}\n\nvoid jni::InstallHooks() {\n    XHOOK_REGISTER(".*\\\\libandroid_runtime.so$", jniRegisterNativeMethods)\n\n    if (xhook_refresh(0) == 0) {\n        xhook_clear();\n        LOGI("hook installed");\n    } else {\n        LOGE("failed to refresh hook");\n    }\n\n    useTableOverride = old_jniRegisterNativeMethods == nullptr;\n\n    if (useTableOverride) {\n        LOGI("no jniRegisterNativeMethods");\n\n        SandHook::ElfImg art("libart.so");\n\n        auto *GetJniNativeInterface = art.getSymbAddress<GetJniNativeInterface_t *>(\n                "_ZN3art21GetJniNativeInterfaceEv");\n        setTableOverride = art.getSymbAddress<SetTableOverride_t *>(\n                "_ZN3art9JNIEnvExt16SetTableOverrideEPK18JNINativeInterface");\n\n        if (setTableOverride != nullptr && GetJniNativeInterface != nullptr) {\n            auto functions = GetJniNativeInterface();\n            auto new_JNINativeInterface = new JNINativeInterface();\n            memcpy(new_JNINativeInterface, functions, sizeof(JNINativeInterface));\n            old_RegisterNatives = functions->RegisterNatives;\n            new_JNINativeInterface->RegisterNatives = new_RegisterNative;\n\n            setTableOverride(new_JNINativeInterface);\n            LOGI("override table installed");\n        } else {\n            if (GetJniNativeInterface == nullptr) LOGE("cannot find GetJniNativeInterface");\n            if (setTableOverride == nullptr) LOGE("cannot find setTableOverride");\n        }\n\n        auto *handle = dlopen("libnativehelper.so", 0);\n        if (handle) {\n            old_jniRegisterNativeMethods = reinterpret_cast<jniRegisterNativeMethods_t *>(dlsym(\n                    handle,\n                    "jniRegisterNativeMethods"));\n        }\n    }\n}\n\n// -----------------------------------------------------------------\n\nstatic void nativeForkAndSpecialize_pre(\n        JNIEnv *env, jclass clazz, jint &uid, jint &gid, jintArray &gids, jint &runtime_flags,\n        jobjectArray &rlimits, jint &mount_external, jstring &se_info, jstring &se_name,\n        jintArray &fdsToClose, jintArray &fdsToIgnore, jboolean &is_child_zygote,\n        jstring &instructionSet, jstring &appDataDir, jboolean &isTopApp,\n        jobjectArray &pkgDataInfoList,\n        jobjectArray &whitelistedDataInfoList, jboolean &bindMountAppDataDirs,\n        jboolean &bindMountAppStorageDirs) {\n\n    for (const auto &module : modules::Get()) {\n        if (!module.hasForkAndSpecializePre())\n            continue;\n\n        module.resetAllowUnload();\n\n        if (module.apiVersion < 25) {\n            if (module.hasShouldSkipUid() && module.shouldSkipUid(uid))\n                continue;\n\n            if (!module.hasShouldSkipUid() && shouldSkipUid(uid))\n                continue;\n        }\n\n        module.forkAndSpecializePre(\n                env, clazz, &uid, &gid, &gids, &runtime_flags, &rlimits, &mount_external,\n                &se_info, &se_name, &fdsToClose, &fdsToIgnore, &is_child_zygote,\n                &instructionSet, &appDataDir, &isTopApp, &pkgDataInfoList, &whitelistedDataInfoList,\n                &bindMountAppDataDirs, &bindMountAppStorageDirs);\n    }\n}\n\nstatic void\nnativeForkAndSpecialize_post(JNIEnv *env, jclass clazz, jint uid, jboolean is_child_zygote,\n                             jint res) {\n\n    if (res == 0) jni::RestoreHooks(env);\n\n    for (const auto &module : modules::Get()) {\n        if (!module.hasForkAndSpecializePost())\n            continue;\n\n        if (module.apiVersion < 25) {\n            if (module.hasShouldSkipUid() && module.shouldSkipUid(uid))\n                continue;\n\n            if (!module.hasShouldSkipUid() && shouldSkipUid(uid))\n                continue;\n        }\n\n        if (res == 0) LOGD("%s: forkAndSpecializePost", module.id.data());\n\n        module.forkAndSpecializePost(env, clazz, res);\n    }\n\n    if (res == 0) Entry::Unload(is_child_zygote);\n}\n\n// -----------------------------------------------------------------\n\nstatic void nativeSpecializeAppProcess_pre(\n        JNIEnv *env, jclass clazz, jint &uid, jint &gid, jintArray &gids, jint &runtimeFlags,\n        jobjectArray &rlimits, jint &mountExternal, jstring &seInfo, jstring &niceName,\n        jboolean &startChildZygote, jstring &instructionSet, jstring &appDataDir,\n        jboolean &isTopApp, jobjectArray &pkgDataInfoList, jobjectArray &whitelistedDataInfoList,\n        jboolean &bindMountAppDataDirs, jboolean &bindMountAppStorageDirs) {\n\n    for (auto &module : modules::Get()) {\n        if (!module.hasSpecializeAppProcessPre())\n            continue;\n\n        module.resetAllowUnload();\n\n        if (module.apiVersion < 25) {\n            if (module.hasShouldSkipUid() && module.shouldSkipUid(uid))\n                continue;\n\n            if (!module.hasShouldSkipUid() && shouldSkipUid(uid))\n                continue;\n        }\n\n        module.specializeAppProcessPre(\n                env, clazz, &uid, &gid, &gids, &runtimeFlags, &rlimits, &mountExternal, &seInfo,\n                &niceName, &startChildZygote, &instructionSet, &appDataDir, &isTopApp,\n                &pkgDataInfoList, &whitelistedDataInfoList, &bindMountAppDataDirs,\n                &bindMountAppStorageDirs);\n    }\n}\n\nstatic void\nnativeSpecializeAppProcess_post(JNIEnv *env, jclass clazz, jint uid, jboolean is_child_zygote) {\n\n    jni::RestoreHooks(env);\n\n    for (const auto &module : modules::Get()) {\n        if (!module.hasSpecializeAppProcessPost())\n            continue;\n\n        if (module.apiVersion < 25) {\n            if (module.hasShouldSkipUid() && module.shouldSkipUid(uid))\n                continue;\n\n            if (!module.hasShouldSkipUid() && shouldSkipUid(uid))\n                continue;\n        }\n\n        LOGD("%s: specializeAppProcessPost", module.id.data());\n        module.specializeAppProcessPost(env, clazz);\n    }\n\n    Entry::Unload(is_child_zygote);\n}\n\n// -----------------------------------------------------------------\n\nstatic void nativeForkSystemServer_pre(\n        JNIEnv *env, jclass clazz, uid_t &uid, gid_t &gid, jintArray &gids, jint &debug_flags,\n        jobjectArray &rlimits, jlong &permittedCapabilities, jlong &effectiveCapabilities) {\n\n    for (const auto &module : modules::Get()) {\n        if (!module.hasForkSystemServerPre())\n            continue;\n\n        module.resetAllowUnload();\n\n        module.forkSystemServerPre(\n                env, clazz, &uid, &gid, &gids, &debug_flags, &rlimits, &permittedCapabilities,\n                &effectiveCapabilities);\n    }\n}\n\nstatic void nativeForkSystemServer_post(JNIEnv *env, jclass clazz, jint res) {\n\n    if (res == 0) jni::RestoreHooks(env);\n\n    if (res == 0 && android_prop::CheckZTE()) {\n        auto *process = env->FindClass("android/os/Process");\n        auto *set_argv0 = env->GetStaticMethodID(process, "setArgV0", "(Ljava/lang/String;)V");\n        env->CallStaticVoidMethod(process, set_argv0, env->NewStringUTF("system_server"));\n    }\n\n    for (const auto &module : modules::Get()) {\n        if (!module.hasForkSystemServerPost()) continue;\n\n        if (res == 0) LOGD("%s: forkSystemServerPost", module.id.data());\n        module.forkSystemServerPost(env, clazz, res);\n    }\n}\n\n// -----------------------------------------------------------------\n[[clang::no_stack_protector]]\njint nativeForkAndSpecialize_marshmallow(\n        JNIEnv *env, jclass clazz, jint uid, jint gid, jintArray gids, jint debug_flags,\n        jobjectArray rlimits, jint mount_external, jstring se_info, jstring se_name,\n        jintArray fdsToClose, jstring instructionSet, jstring appDataDir) {\n\n    jintArray fdsToIgnore = nullptr;\n    jboolean is_child_zygote = JNI_FALSE;\n    jboolean isTopApp = JNI_FALSE;\n    jobjectArray pkgDataInfoList = nullptr;\n    jobjectArray whitelistedDataInfoList = nullptr;\n    jboolean bindMountAppDataDirs = JNI_FALSE;\n    jboolean bindMountAppStorageDirs = JNI_FALSE;\n\n    nativeForkAndSpecialize_pre(env, clazz, uid, gid, gids, debug_flags, rlimits, mount_external,\n                                se_info, se_name, fdsToClose, fdsToIgnore, is_child_zygote,\n                                instructionSet, appDataDir, isTopApp, pkgDataInfoList,\n                                whitelistedDataInfoList,\n                                bindMountAppDataDirs, bindMountAppStorageDirs);\n\n    jint res = ((nativeForkAndSpecialize_marshmallow_t *) jni::zygote::nativeForkAndSpecialize->fnPtr)(\n            env, clazz, uid, gid, gids, debug_flags, rlimits, mount_external, se_info, se_name,\n            fdsToClose, instructionSet, appDataDir);\n\n    nativeForkAndSpecialize_post(env, clazz, uid, is_child_zygote, res);\n    return res;\n}\n\n[[clang::no_stack_protector]]\njint nativeForkAndSpecialize_oreo(\n        JNIEnv *env, jclass clazz, jint uid, jint gid, jintArray gids, jint debug_flags,\n        jobjectArray rlimits, jint mount_external, jstring se_info, jstring se_name,\n        jintArray fdsToClose, jintArray fdsToIgnore, jstring instructionSet, jstring appDataDir) {\n\n    jboolean is_child_zygote = JNI_FALSE;\n    jboolean isTopApp = JNI_FALSE;\n    jobjectArray pkgDataInfoList = nullptr;\n    jobjectArray whitelistedDataInfoList = nullptr;\n    jboolean bindMountAppDataDirs = JNI_FALSE;\n    jboolean bindMountAppStorageDirs = JNI_FALSE;\n\n    nativeForkAndSpecialize_pre(env, clazz, uid, gid, gids, debug_flags, rlimits, mount_external,\n                                se_info, se_name, fdsToClose, fdsToIgnore, is_child_zygote,\n                                instructionSet, appDataDir, isTopApp, pkgDataInfoList,\n                                whitelistedDataInfoList,\n                                bindMountAppDataDirs, bindMountAppStorageDirs);\n\n    jint res = ((nativeForkAndSpecialize_oreo_t *) jni::zygote::nativeForkAndSpecialize->fnPtr)(\n            env, clazz, uid, gid, gids, debug_flags, rlimits, mount_external, se_info, se_name,\n            fdsToClose, fdsToIgnore, instructionSet, appDataDir);\n\n    nativeForkAndSpecialize_post(env, clazz, uid, is_child_zygote, res);\n    return res;\n}\n\n[[clang::no_stack_protector]]\njint nativeForkAndSpecialize_p(\n        JNIEnv *env, jclass clazz, jint uid, jint gid, jintArray gids, jint runtime_flags,\n        jobjectArray rlimits, jint mount_external, jstring se_info, jstring se_name,\n        jintArray fdsToClose, jintArray fdsToIgnore, jboolean is_child_zygote,\n        jstring instructionSet, jstring appDataDir) {\n\n    jboolean isTopApp = JNI_FALSE;\n    jobjectArray pkgDataInfoList = nullptr;\n    jobjectArray whitelistedDataInfoList = nullptr;\n    jboolean bindMountAppDataDirs = JNI_FALSE;\n    jboolean bindMountAppStorageDirs = JNI_FALSE;\n\n    nativeForkAndSpecialize_pre(env, clazz, uid, gid, gids, runtime_flags, rlimits, mount_external,\n                                se_info, se_name, fdsToClose, fdsToIgnore, is_child_zygote,\n                                instructionSet, appDataDir, isTopApp, pkgDataInfoList,\n                                whitelistedDataInfoList,\n                                bindMountAppDataDirs, bindMountAppStorageDirs);\n\n    jint res = ((nativeForkAndSpecialize_p_t *) jni::zygote::nativeForkAndSpecialize->fnPtr)(\n            env, clazz, uid, gid, gids, runtime_flags, rlimits, mount_external, se_info, se_name,\n            fdsToClose, fdsToIgnore, is_child_zygote, instructionSet, appDataDir);\n\n    nativeForkAndSpecialize_post(env, clazz, uid, is_child_zygote, res);\n    return res;\n}\n\n[[clang::no_stack_protector]]\njint nativeForkAndSpecialize_q_alternative(\n        JNIEnv *env, jclass clazz, jint uid, jint gid, jintArray gids, jint runtime_flags,\n        jobjectArray rlimits, jint mount_external, jstring se_info, jstring se_name,\n        jintArray fdsToClose, jintArray fdsToIgnore, jboolean is_child_zygote,\n        jstring instructionSet, jstring appDataDir, jboolean isTopApp) {\n\n    jobjectArray pkgDataInfoList = nullptr;\n    jobjectArray whitelistedDataInfoList = nullptr;\n    jboolean bindMountAppDataDirs = JNI_FALSE;\n    jboolean bindMountAppStorageDirs = JNI_FALSE;\n\n    nativeForkAndSpecialize_pre(env, clazz, uid, gid, gids, runtime_flags, rlimits, mount_external,\n                                se_info, se_name, fdsToClose, fdsToIgnore, is_child_zygote,\n                                instructionSet, appDataDir, isTopApp, pkgDataInfoList,\n                                whitelistedDataInfoList,\n                                bindMountAppDataDirs, bindMountAppStorageDirs);\n\n    jint res = ((nativeForkAndSpecialize_q_alternative_t *) jni::zygote::nativeForkAndSpecialize->fnPtr)(\n            env, clazz, uid, gid, gids, runtime_flags, rlimits, mount_external, se_info, se_name,\n            fdsToClose, fdsToIgnore, is_child_zygote, instructionSet, appDataDir, isTopApp);\n\n    nativeForkAndSpecialize_post(env, clazz, uid, is_child_zygote, res);\n    return res;\n}\n\n[[clang::no_stack_protector]]\njint nativeForkAndSpecialize_r(\n        JNIEnv *env, jclass clazz, jint uid, jint gid, jintArray gids, jint runtime_flags,\n        jobjectArray rlimits, jint mount_external, jstring se_info, jstring se_name,\n        jintArray fdsToClose, jintArray fdsToIgnore, jboolean is_child_zygote,\n        jstring instructionSet, jstring appDataDir, jboolean isTopApp, jobjectArray pkgDataInfoList,\n        jobjectArray whitelistedDataInfoList, jboolean bindMountAppDataDirs,\n        jboolean bindMountAppStorageDirs) {\n\n    nativeForkAndSpecialize_pre(env, clazz, uid, gid, gids, runtime_flags, rlimits, mount_external,\n                                se_info, se_name, fdsToClose, fdsToIgnore, is_child_zygote,\n                                instructionSet, appDataDir, isTopApp, pkgDataInfoList,\n                                whitelistedDataInfoList,\n                                bindMountAppDataDirs, bindMountAppStorageDirs);\n\n    jint res = ((nativeForkAndSpecialize_r_t *) jni::zygote::nativeForkAndSpecialize->fnPtr)(\n            env, clazz, uid, gid, gids, runtime_flags, rlimits, mount_external, se_info, se_name,\n            fdsToClose, fdsToIgnore, is_child_zygote, instructionSet, appDataDir, isTopApp,\n            pkgDataInfoList,\n            whitelistedDataInfoList, bindMountAppDataDirs, bindMountAppStorageDirs);\n\n    nativeForkAndSpecialize_post(env, clazz, uid, is_child_zygote, res);\n    return res;\n}\n\n[[clang::no_stack_protector]]\njint nativeForkAndSpecialize_r_dp3(\n        JNIEnv *env, jclass clazz, jint uid, jint gid, jintArray gids, jint runtime_flags,\n        jobjectArray rlimits, jint mount_external, jstring se_info, jstring se_name,\n        jintArray fdsToClose, jintArray fdsToIgnore, jboolean is_child_zygote,\n        jstring instructionSet, jstring appDataDir, jboolean isTopApp, jobjectArray pkgDataInfoList,\n        jboolean bindMountAppStorageDirs) {\n\n    jobjectArray whitelistedDataInfoList = nullptr;\n    jboolean bindMountAppDataDirs = JNI_FALSE;\n\n    nativeForkAndSpecialize_pre(env, clazz, uid, gid, gids, runtime_flags, rlimits, mount_external,\n                                se_info, se_name, fdsToClose, fdsToIgnore, is_child_zygote,\n                                instructionSet, appDataDir, isTopApp, pkgDataInfoList,\n                                whitelistedDataInfoList,\n                                bindMountAppDataDirs, bindMountAppStorageDirs);\n\n    jint res = ((nativeForkAndSpecialize_r_dp3_t *) jni::zygote::nativeForkAndSpecialize->fnPtr)(\n            env, clazz, uid, gid, gids, runtime_flags, rlimits, mount_external, se_info, se_name,\n            fdsToClose, fdsToIgnore, is_child_zygote, instructionSet, appDataDir, isTopApp,\n            pkgDataInfoList,\n            bindMountAppStorageDirs);\n\n    nativeForkAndSpecialize_post(env, clazz, uid, is_child_zygote, res);\n    return res;\n}\n\n[[clang::no_stack_protector]]\njint nativeForkAndSpecialize_r_dp2(\n        JNIEnv *env, jclass clazz, jint uid, jint gid, jintArray gids, jint runtime_flags,\n        jobjectArray rlimits, jint mount_external, jstring se_info, jstring se_name,\n        jintArray fdsToClose, jintArray fdsToIgnore, jboolean is_child_zygote,\n        jstring instructionSet, jstring appDataDir, jboolean isTopApp,\n        jobjectArray pkgDataInfoList) {\n\n    jobjectArray whitelistedDataInfoList = nullptr;\n    jboolean bindMountAppDataDirs = JNI_FALSE;\n    jboolean bindMountAppStorageDirs = JNI_FALSE;\n\n    nativeForkAndSpecialize_pre(env, clazz, uid, gid, gids, runtime_flags, rlimits, mount_external,\n                                se_info, se_name, fdsToClose, fdsToIgnore, is_child_zygote,\n                                instructionSet, appDataDir, isTopApp, pkgDataInfoList,\n                                whitelistedDataInfoList,\n                                bindMountAppDataDirs, bindMountAppStorageDirs);\n\n    jint res = ((nativeForkAndSpecialize_r_dp2_t *) jni::zygote::nativeForkAndSpecialize->fnPtr)(\n            env, clazz, uid, gid, gids, runtime_flags, rlimits, mount_external, se_info, se_name,\n            fdsToClose, fdsToIgnore, is_child_zygote, instructionSet, appDataDir, isTopApp,\n            pkgDataInfoList);\n\n    nativeForkAndSpecialize_post(env, clazz, uid, is_child_zygote, res);\n    return res;\n}\n\n[[clang::no_stack_protector]]\njint nativeForkAndSpecialize_samsung_p(\n        JNIEnv *env, jclass clazz, jint uid, jint gid, jintArray gids, jint runtime_flags,\n        jobjectArray rlimits, jint mount_external, jstring se_info, jint category, jint accessInfo,\n        jstring se_name, jintArray fdsToClose, jintArray fdsToIgnore, jboolean is_child_zygote,\n        jstring instructionSet, jstring appDataDir) {\n\n    jboolean isTopApp = JNI_FALSE;\n    jobjectArray pkgDataInfoList = nullptr;\n    jobjectArray whitelistedDataInfoList = nullptr;\n    jboolean bindMountAppDataDirs = JNI_FALSE;\n    jboolean bindMountAppStorageDirs = JNI_FALSE;\n\n    nativeForkAndSpecialize_pre(env, clazz, uid, gid, gids, runtime_flags, rlimits, mount_external,\n                                se_info, se_name, fdsToClose, fdsToIgnore, is_child_zygote,\n                                instructionSet, appDataDir, isTopApp, pkgDataInfoList,\n                                whitelistedDataInfoList,\n                                bindMountAppDataDirs, bindMountAppStorageDirs);\n\n    jint res = ((nativeForkAndSpecialize_samsung_p_t *) jni::zygote::nativeForkAndSpecialize->fnPtr)(\n            env, clazz, uid, gid, gids, runtime_flags, rlimits, mount_external, se_info, category,\n            accessInfo, se_name, fdsToClose, fdsToIgnore, is_child_zygote, instructionSet,\n            appDataDir);\n\n    nativeForkAndSpecialize_post(env, clazz, uid, is_child_zygote, res);\n    return res;\n}\n\n[[clang::no_stack_protector]]\njint nativeForkAndSpecialize_samsung_o(\n        JNIEnv *env, jclass clazz, jint uid, jint gid, jintArray gids, jint debug_flags,\n        jobjectArray rlimits, jint mount_external, jstring se_info, jint category, jint accessInfo,\n        jstring se_name, jintArray fdsToClose, jintArray fdsToIgnore, jstring instructionSet,\n        jstring appDataDir) {\n\n    jboolean is_child_zygote = JNI_FALSE;\n    jboolean isTopApp = JNI_FALSE;\n    jobjectArray pkgDataInfoList = nullptr;\n    jobjectArray whitelistedDataInfoList = nullptr;\n    jboolean bindMountAppDataDirs = JNI_FALSE;\n    jboolean bindMountAppStorageDirs = JNI_FALSE;\n\n    nativeForkAndSpecialize_pre(env, clazz, uid, gid, gids, debug_flags, rlimits, mount_external,\n                                se_info, se_name, fdsToClose, fdsToIgnore, is_child_zygote,\n                                instructionSet, appDataDir, isTopApp, pkgDataInfoList,\n                                whitelistedDataInfoList,\n                                bindMountAppDataDirs, bindMountAppStorageDirs);\n\n    jint res = ((nativeForkAndSpecialize_samsung_o_t *) jni::zygote::nativeForkAndSpecialize->fnPtr)(\n            env, clazz, uid, gid, gids, debug_flags, rlimits, mount_external, se_info, category,\n            accessInfo, se_name, fdsToClose, fdsToIgnore, instructionSet, appDataDir);\n\n    nativeForkAndSpecialize_post(env, clazz, uid, is_child_zygote, res);\n    return res;\n}\n\n[[clang::no_stack_protector]]\njint nativeForkAndSpecialize_samsung_n(\n        JNIEnv *env, jclass clazz, jint uid, jint gid, jintArray gids, jint debug_flags,\n        jobjectArray rlimits, jint mount_external, jstring se_info, jint category, jint accessInfo,\n        jstring se_name, jintArray fdsToClose, jstring instructionSet, jstring appDataDir,\n        jint a1) {\n\n    jintArray fdsToIgnore = nullptr;\n    jboolean is_child_zygote = JNI_FALSE;\n    jboolean isTopApp = JNI_FALSE;\n    jobjectArray pkgDataInfoList = nullptr;\n    jobjectArray whitelistedDataInfoList = nullptr;\n    jboolean bindMountAppDataDirs = JNI_FALSE;\n    jboolean bindMountAppStorageDirs = JNI_FALSE;\n\n    nativeForkAndSpecialize_pre(env, clazz, uid, gid, gids, debug_flags, rlimits, mount_external,\n                                se_info, se_name, fdsToClose, fdsToIgnore, is_child_zygote,\n                                instructionSet, appDataDir, isTopApp, pkgDataInfoList,\n                                whitelistedDataInfoList,\n                                bindMountAppDataDirs, bindMountAppStorageDirs);\n\n    jint res = ((nativeForkAndSpecialize_samsung_n_t *) jni::zygote::nativeForkAndSpecialize->fnPtr)(\n            env, clazz, uid, gid, gids, debug_flags, rlimits, mount_external, se_info, category,\n            accessInfo, se_name, fdsToClose, instructionSet, appDataDir, a1);\n\n    nativeForkAndSpecialize_post(env, clazz, uid, is_child_zygote, res);\n    return res;\n}\n\n[[clang::no_stack_protector]]\njint nativeForkAndSpecialize_samsung_m(\n        JNIEnv *env, jclass clazz, jint uid, jint gid, jintArray gids, jint debug_flags,\n        jobjectArray rlimits, jint mount_external, jstring se_info, jint category, jint accessInfo,\n        jstring se_name, jintArray fdsToClose, jstring instructionSet, jstring appDataDir) {\n\n    jintArray fdsToIgnore = nullptr;\n    jboolean is_child_zygote = JNI_FALSE;\n    jboolean isTopApp = JNI_FALSE;\n    jobjectArray pkgDataInfoList = nullptr;\n    jobjectArray whitelistedDataInfoList = nullptr;\n    jboolean bindMountAppDataDirs = JNI_FALSE;\n    jboolean bindMountAppStorageDirs = JNI_FALSE;\n\n    nativeForkAndSpecialize_pre(env, clazz, uid, gid, gids, debug_flags, rlimits, mount_external,\n                                se_info, se_name, fdsToClose, fdsToIgnore, is_child_zygote,\n                                instructionSet, appDataDir, isTopApp, pkgDataInfoList,\n                                whitelistedDataInfoList,\n                                bindMountAppDataDirs, bindMountAppStorageDirs);\n\n    jint res = ((nativeForkAndSpecialize_samsung_m_t *) jni::zygote::nativeForkAndSpecialize->fnPtr)(\n            env, clazz, uid, gid, gids, debug_flags, rlimits, mount_external, se_info, category,\n            accessInfo, se_name, fdsToClose, instructionSet, appDataDir);\n\n    nativeForkAndSpecialize_post(env, clazz, uid, is_child_zygote, res);\n    return res;\n}\n\n// -----------------------------------------------------------------\n[[clang::no_stack_protector]]\nvoid nativeSpecializeAppProcess_q(\n        JNIEnv *env, jclass clazz, jint uid, jint gid, jintArray gids, jint runtimeFlags,\n        jobjectArray rlimits, jint mountExternal, jstring seInfo, jstring niceName,\n        jboolean startChildZygote, jstring instructionSet, jstring appDataDir) {\n\n    jboolean isTopApp = JNI_FALSE;\n    jobjectArray pkgDataInfoList = nullptr;\n    jobjectArray whitelistedDataInfoList = nullptr;\n    jboolean bindMountAppDataDirs = JNI_FALSE;\n    jboolean bindMountAppStorageDirs = JNI_FALSE;\n\n    nativeSpecializeAppProcess_pre(\n            env, clazz, uid, gid, gids, runtimeFlags, rlimits, mountExternal, seInfo, niceName,\n            startChildZygote, instructionSet, appDataDir, isTopApp, pkgDataInfoList,\n            whitelistedDataInfoList, bindMountAppDataDirs, bindMountAppStorageDirs);\n\n    ((nativeSpecializeAppProcess_q_t *) jni::zygote::nativeSpecializeAppProcess->fnPtr)(\n            env, clazz, uid, gid, gids, runtimeFlags, rlimits, mountExternal, seInfo, niceName,\n            startChildZygote, instructionSet, appDataDir);\n\n    nativeSpecializeAppProcess_post(env, clazz, uid, startChildZygote);\n}\n\n[[clang::no_stack_protector]]\nvoid nativeSpecializeAppProcess_q_alternative(\n        JNIEnv *env, jclass clazz, jint uid, jint gid, jintArray gids, jint runtimeFlags,\n        jobjectArray rlimits, jint mountExternal, jstring seInfo, jstring niceName,\n        jboolean startChildZygote, jstring instructionSet, jstring appDataDir,\n        jboolean isTopApp) {\n\n    jobjectArray pkgDataInfoList = nullptr;\n    jobjectArray whitelistedDataInfoList = nullptr;\n    jboolean bindMountAppDataDirs = JNI_FALSE;\n    jboolean bindMountAppStorageDirs = JNI_FALSE;\n\n    nativeSpecializeAppProcess_pre(\n            env, clazz, uid, gid, gids, runtimeFlags, rlimits, mountExternal, seInfo, niceName,\n            startChildZygote, instructionSet, appDataDir, isTopApp, pkgDataInfoList,\n            whitelistedDataInfoList, bindMountAppDataDirs, bindMountAppStorageDirs);\n\n    ((nativeSpecializeAppProcess_q_alternative_t *) jni::zygote::nativeSpecializeAppProcess->fnPtr)(\n            env, clazz, uid, gid, gids, runtimeFlags, rlimits, mountExternal, seInfo, niceName,\n            startChildZygote, instructionSet, appDataDir, isTopApp);\n\n    nativeSpecializeAppProcess_post(env, clazz, uid, startChildZygote);\n}\n\n[[clang::no_stack_protector]]\nvoid nativeSpecializeAppProcess_r(\n        JNIEnv *env, jclass clazz, jint uid, jint gid, jintArray gids, jint runtimeFlags,\n        jobjectArray rlimits, jint mountExternal, jstring seInfo, jstring niceName,\n        jboolean startChildZygote, jstring instructionSet, jstring appDataDir,\n        jboolean isTopApp, jobjectArray pkgDataInfoList, jobjectArray whitelistedDataInfoList,\n        jboolean bindMountAppDataDirs, jboolean bindMountAppStorageDirs) {\n\n    nativeSpecializeAppProcess_pre(\n            env, clazz, uid, gid, gids, runtimeFlags, rlimits, mountExternal, seInfo, niceName,\n            startChildZygote, instructionSet, appDataDir, isTopApp, pkgDataInfoList,\n            whitelistedDataInfoList, bindMountAppDataDirs, bindMountAppStorageDirs);\n\n    ((nativeSpecializeAppProcess_r_t *) jni::zygote::nativeSpecializeAppProcess->fnPtr)(\n            env, clazz, uid, gid, gids, runtimeFlags, rlimits, mountExternal, seInfo, niceName,\n            startChildZygote, instructionSet, appDataDir, isTopApp, pkgDataInfoList,\n            whitelistedDataInfoList, bindMountAppDataDirs, bindMountAppStorageDirs);\n\n    nativeSpecializeAppProcess_post(env, clazz, uid, startChildZygote);\n}\n\n[[clang::no_stack_protector]]\nvoid nativeSpecializeAppProcess_r_dp3(\n        JNIEnv *env, jclass clazz, jint uid, jint gid, jintArray gids, jint runtimeFlags,\n        jobjectArray rlimits, jint mountExternal, jstring seInfo, jstring niceName,\n        jboolean startChildZygote, jstring instructionSet, jstring appDataDir,\n        jboolean isTopApp, jobjectArray pkgDataInfoList, jboolean bindMountAppStorageDirs) {\n\n    jobjectArray whitelistedDataInfoList = nullptr;\n    jboolean bindMountAppDataDirs = JNI_FALSE;\n\n    nativeSpecializeAppProcess_pre(\n            env, clazz, uid, gid, gids, runtimeFlags, rlimits, mountExternal, seInfo, niceName,\n            startChildZygote, instructionSet, appDataDir, isTopApp, pkgDataInfoList,\n            whitelistedDataInfoList, bindMountAppDataDirs, bindMountAppStorageDirs);\n\n    ((nativeSpecializeAppProcess_r_dp3_t *) jni::zygote::nativeSpecializeAppProcess->fnPtr)(\n            env, clazz, uid, gid, gids, runtimeFlags, rlimits, mountExternal, seInfo, niceName,\n            startChildZygote, instructionSet, appDataDir, isTopApp, pkgDataInfoList,\n            bindMountAppStorageDirs);\n\n    nativeSpecializeAppProcess_post(env, clazz, uid, startChildZygote);\n}\n\n[[clang::no_stack_protector]]\nvoid nativeSpecializeAppProcess_r_dp2(\n        JNIEnv *env, jclass clazz, jint uid, jint gid, jintArray gids, jint runtimeFlags,\n        jobjectArray rlimits, jint mountExternal, jstring seInfo, jstring niceName,\n        jboolean startChildZygote, jstring instructionSet, jstring appDataDir,\n        jboolean isTopApp, jobjectArray pkgDataInfoList) {\n\n    jobjectArray whitelistedDataInfoList = nullptr;\n    jboolean bindMountAppDataDirs = JNI_FALSE;\n    jboolean bindMountAppStorageDirs = JNI_FALSE;\n\n    nativeSpecializeAppProcess_pre(\n            env, clazz, uid, gid, gids, runtimeFlags, rlimits, mountExternal, seInfo, niceName,\n            startChildZygote, instructionSet, appDataDir, isTopApp, pkgDataInfoList,\n            whitelistedDataInfoList, bindMountAppDataDirs, bindMountAppStorageDirs);\n\n    ((nativeSpecializeAppProcess_r_dp2_t *) jni::zygote::nativeSpecializeAppProcess->fnPtr)(\n            env, clazz, uid, gid, gids, runtimeFlags, rlimits, mountExternal, seInfo, niceName,\n            startChildZygote, instructionSet, appDataDir, isTopApp, pkgDataInfoList);\n\n    nativeSpecializeAppProcess_post(env, clazz, uid, startChildZygote);\n}\n\n[[clang::no_stack_protector]]\nvoid nativeSpecializeAppProcess_samsung_q(\n        JNIEnv *env, jclass clazz, jint uid, jint gid, jintArray gids, jint runtimeFlags,\n        jobjectArray rlimits, jint mountExternal, jstring seInfo, jint space, jint accessInfo,\n        jstring niceName, jboolean startChildZygote, jstring instructionSet, jstring appDataDir) {\n\n    jboolean isTopApp = JNI_FALSE;\n    jobjectArray pkgDataInfoList = nullptr;\n    jobjectArray whitelistedDataInfoList = nullptr;\n    jboolean bindMountAppDataDirs = JNI_FALSE;\n    jboolean bindMountAppStorageDirs = JNI_FALSE;\n\n    nativeSpecializeAppProcess_pre(\n            env, clazz, uid, gid, gids, runtimeFlags, rlimits, mountExternal, seInfo, niceName,\n            startChildZygote, instructionSet, appDataDir, isTopApp, pkgDataInfoList,\n            whitelistedDataInfoList, bindMountAppDataDirs, bindMountAppStorageDirs);\n\n    ((nativeSpecializeAppProcess_samsung_t *) jni::zygote::nativeSpecializeAppProcess->fnPtr)(\n            env, clazz, uid, gid, gids, runtimeFlags, rlimits, mountExternal, seInfo, space,\n            accessInfo, niceName, startChildZygote, instructionSet, appDataDir);\n\n    nativeSpecializeAppProcess_post(env, clazz, uid, startChildZygote);\n}\n\n// -----------------------------------------------------------------\n[[clang::no_stack_protector]]\njint nativeForkSystemServer(\n        JNIEnv *env, jclass clazz, uid_t uid, gid_t gid, jintArray gids, jint runtimeFlags,\n        jobjectArray rlimits, jlong permittedCapabilities, jlong effectiveCapabilities) {\n\n    nativeForkSystemServer_pre(\n            env, clazz, uid, gid, gids, runtimeFlags, rlimits, permittedCapabilities,\n            effectiveCapabilities);\n\n    jint res = ((nativeForkSystemServer_t *) jni::zygote::nativeForkSystemServer->fnPtr)(\n            env, clazz, uid, gid, gids, runtimeFlags, rlimits, permittedCapabilities,\n            effectiveCapabilities);\n\n    nativeForkSystemServer_post(env, clazz, res);\n    return res;\n}\n\n[[clang::no_stack_protector]]\njint nativeForkSystemServer_samsung_q(\n        JNIEnv *env, jclass cls, uid_t uid, gid_t gid, jintArray gids, jint runtimeFlags,\n        jint space, jint accessInfo, jobjectArray rlimits, jlong permittedCapabilities,\n        jlong effectiveCapabilities) {\n\n    nativeForkSystemServer_pre(\n            env, cls, uid, gid, gids, runtimeFlags, rlimits, permittedCapabilities,\n            effectiveCapabilities);\n\n    jint res = ((nativeForkSystemServer_samsung_q_t *) jni::zygote::nativeForkSystemServer->fnPtr)(\n            env, cls, uid, gid, gids, runtimeFlags, space, accessInfo, rlimits,\n            permittedCapabilities,\n            effectiveCapabilities);\n\n    nativeForkSystemServer_post(env, cls, res);\n    return res;\n}\n'