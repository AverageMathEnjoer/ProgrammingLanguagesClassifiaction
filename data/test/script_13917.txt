b'{-# LANGUAGE BangPatterns #-}\n{-# LANGUAGE FlexibleContexts #-}\n\n--\n-- Radix sort for a subclass of element types. Taken and modified\n-- slightly from the Accelerate benchmark suite.\n--\n\nimport qualified Prelude\nimport Prelude               hiding (zip, map, scanl, scanr, zipWith, fst)\nimport Data.Bits             hiding (shiftL, shiftR, bit, testBit)\nimport Data.Array.Accelerate as Acc\nimport Data.Array.Accelerate.CUDA as CUDA\n\nimport Control.Exception     (evaluate)\nimport Data.Array.IArray     hiding ((!))\nimport Data.Array.Unboxed    (UArray)\nimport Data.Array.IO         (MArray, IOUArray)\nimport qualified Data.Array.MArray as M\n\nimport Data.List             (sort)\nimport Data.Array.Unboxed    (IArray, UArray, listArray, bounds, elems)\nimport System.Environment    (getArgs, withArgs)\nimport System.Random\nimport System.Random.MWC\nimport Unsafe.Coerce\n\n-- import Criterion.Main\n\n-- import Control.Monad.Par.Meta.SharedMemoryAccelerate\nimport Foreign.CUDA (sync)\n\n-- Radix sort\n-- ----------\n\nclass Elt e => Radix e where\n    passes :: Exp e   -> Int                -- Haskell-side control needs to know this\n    radix  :: Exp Int -> Exp e -> Exp Int\n\ninstance Radix Int where                    -- may be 32- or 64-bit\n    passes    = bitSize . (undefined :: Exp t -> t)\n    radix i e = i ==* (passes\' e - 1) ? (radix\' (e `xor` minBound), radix\' e)\n      where\n        radix\' x = (x `shiftR` i) .&. 1\n        passes\'  = constant . passes\n\n-- For IEEE-754 floating-point representation. Unsafe, but widely supported.\n--\ninstance Radix Float where\n    passes _   = 32\n    radix i e  = let x = (unsafeCoerce e :: Exp Int32)\n                 in  i ==* 31 ? (radix\' (x `xor` minBound), radix\' (floatFlip x))\n      where\n        floatFlip x = x `testBit` 31 ? (complement x, x)  -- twos-complement negative numbers\n        radix\'    x = x `testBit` i  ? (1,0)\n\n\n--\n-- A simple (parallel) radix sort implementation [1].\n--\n-- [1] G. E. Blelloch. "Prefix sums and their applications." Technical Report\n--     CMU-CS-90-190. Carnegie Mellon University. 1990.\n--\nsortAcc :: Radix a => Vector a -> Acc (Vector a)\nsortAcc = sortAccBy id\n\nsortAccBy :: (Elt a, Radix r) => (Exp a -> Exp r) -> Vector a -> Acc (Vector a)\nsortAccBy rdx arr = foldr1 (>->) (Prelude.map radixPass [0..p-1]) (use arr)\n  where\n    n = constant $ (arraySize $ arrayShape arr) - 1\n    p = passes . rdx . (undefined :: Vector e -> Exp e) $ arr\n\n    deal f x      = let (a,b) = unlift x in (f ==* 0) ? (a,b)\n    radixPass k v = let flags = map (radix (constant k) . rdx) v\n                        idown = prescanl (+) 0 . map (xor 1) $ flags\n                        iup   = map (n-) . prescanr (+) 0    $ flags\n                        index = zipWith deal flags (zip idown iup)\n                    in\n                    permute const v (\\ix -> index1 (index!ix)) v\n\n\nsortRef :: UArray Int Int -> UArray Int Int\nsortRef xs = listArray (bounds xs) $ sort (elems xs)\n\n-- Convert an Unboxed Data.Array to an Accelerate Array\n--\nconvertUArray :: (IArray UArray e, Acc.Elt e) => UArray Int e -> IO (Acc.Vector e)\nconvertUArray v =\n  let arr = Acc.fromIArray v\n  in  evaluate (arr `Acc.indexArray` (Z:.0)) >> return arr\n\n-- Generate a random, uniformly distributed vector of specified size over the\n-- range. For integral types the range is inclusive, for floating point numbers\n-- the range (a,b] is used, if one ignores rounding errors.\n--\nrandomUArrayR :: (Variate a, MArray IOUArray a IO, IArray UArray a)\n  => (a,a)\n  -> GenIO\n  -> Int\n  -> IO (UArray Int a)\nrandomUArrayR lim gen n = do\n  mu  <- M.newArray_ (0,n-1) :: MArray IOUArray e IO => IO (IOUArray Int e)\n  let go !i | i < n     = uniformR lim gen >>= M.writeArray mu i >> go (i+1)\n            | otherwise = M.unsafeFreeze mu\n  go 0\n\n-- Main\n-- ----\n\nmain :: IO () -- Int -> IO (() -> UArray Int Int, () -> Acc (Vector Int))\nmain = withSystemRandom $ \\gen -> do\n  args <- getArgs\n  let (n,args\') = case args of \n                    []  -> (10000 :: Int, [])\n                    (n:args\') -> ((read n), args\')\n  \n  vec  <- randomUArrayR (minBound,maxBound) gen n\n  vec\' <- convertUArray vec\n  --\n--  sync\n--  withArgs args\' $ defaultMain $ [bench "radix" $ whnf CUDA.run $ sortAcc (vec\' :: Vector Int)]\n  print $ CUDA.run (sortAcc (vec\' :: Vector Int))\n  where\n    {-# NOINLINE run_ref #-}\n    run_ref xs () = sortRef xs\n    run_acc xs () = sortAcc xs\n--    run_par xs () = runPar $ do\n--      ans <- spawnAcc $ run_acc (xs :: Vector Int) ()\n--      get ans'