b'{-# LANGUAGE NoImplicitPrelude #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n{-# LANGUAGE InstanceSigs #-}\n{-# LANGUAGE OverloadedStrings #-}\n{-# LANGUAGE RebindableSyntax #-}\n\nmodule Course.Parser where\n\nimport Course.Core\nimport Course.Person\nimport Course.Functor\nimport Course.Applicative\nimport Course.Monad\nimport Course.List\nimport Course.Optional\nimport Data.Char\n\n-- $setup\n-- >>> :set -XOverloadedStrings\n-- >>> import Data.Char(isUpper)\n\ntype Input = Chars\n\ndata ParseResult a =\n    UnexpectedEof\n  | ExpectedEof Input\n  | UnexpectedChar Char\n  | UnexpectedString Chars\n  | Result Input a\n  deriving Eq\n\ninstance Show a => Show (ParseResult a) where\n  show UnexpectedEof =\n    "Unexpected end of stream"\n  show (ExpectedEof i) =\n    stringconcat ["Expected end of stream, but got >", show i, "<"]\n  show (UnexpectedChar c) =\n    stringconcat ["Unexpected character: ", show [c]]\n  show (UnexpectedString s) =\n    stringconcat ["Unexpected string: ", show s]\n  show (Result i a) =\n    stringconcat ["Result >", hlist i, "< ", show a]\n  \ninstance Functor ParseResult where\n  _ <$> UnexpectedEof =\n    UnexpectedEof\n  _ <$> ExpectedEof i =\n    ExpectedEof i\n  _ <$> UnexpectedChar c =\n    UnexpectedChar c\n  _ <$> UnexpectedString s =\n    UnexpectedString s\n  f <$> Result i a =\n    Result i (f a)\n\n-- Function to determine is a parse result is an error.\nisErrorResult ::\n  ParseResult a\n  -> Bool\nisErrorResult (Result _ _) =\n  False\nisErrorResult UnexpectedEof =\n  True\nisErrorResult (ExpectedEof _) =\n  True\nisErrorResult (UnexpectedChar _) =\n  True\nisErrorResult (UnexpectedString _) =\n  True\n\n-- | Runs the given function on a successful parse result. Otherwise return the same failing parse result.\nonResult ::\n  ParseResult a\n  -> (Input -> a -> ParseResult b)\n  -> ParseResult b\nonResult UnexpectedEof _ = \n  UnexpectedEof\nonResult (ExpectedEof i) _ = \n  ExpectedEof i\nonResult (UnexpectedChar c) _ = \n  UnexpectedChar c\nonResult (UnexpectedString s)  _ = \n  UnexpectedString s\nonResult (Result i a) k = \n  k i a\n\ndata Parser a = P (Input -> ParseResult a)\n\nparse ::\n  Parser a\n  -> Input\n  -> ParseResult a\nparse (P p) =\n  p\n\n-- | Produces a parser that always fails with @UnexpectedChar@ using the given character.\nunexpectedCharParser ::\n  Char\n  -> Parser a\nunexpectedCharParser c =\n  P (\\_ -> UnexpectedChar c)\n\n--- | Return a parser that always returns the given parse result.\n---\n--- >>> isErrorResult (parse (constantParser UnexpectedEof) "abc")\n--- True\nconstantParser ::\n  ParseResult a\n  -> Parser a\nconstantParser =\n  P . const\n\n-- | Return a parser that succeeds with a character off the input or fails with an error if the input is empty.\n--\n-- >>> parse character "abc"\n-- Result >bc< \'a\'\n--\n-- >>> isErrorResult (parse character "")\n-- True\ncharacter ::\n  Parser Char\ncharacter =\n  error "todo: Course.Parser#character"\n\n-- | Parsers can map.\n-- Write a Functor instance for a @Parser@.\n--\n-- >>> parse (toUpper <$> character) "amz"\n-- Result >mz< \'A\'\ninstance Functor Parser where\n  (<$>) ::\n    (a -> b)\n    -> Parser a\n    -> Parser b\n  (<$>) =\n     error "todo: Course.Parser (<$>)#instance Parser"\n\n-- | Return a parser that always succeeds with the given value and consumes no input.\n--\n-- >>> parse (valueParser 3) "abc"\n-- Result >abc< 3\nvalueParser ::\n  a\n  -> Parser a\nvalueParser =\n  error "todo: Course.Parser#valueParser"\n\n-- | Return a parser that tries the first parser for a successful value.\n--\n--   * If the first parser succeeds then use this parser.\n--\n--   * If the first parser fails, try the second parser.\n--\n-- >>> parse (character ||| valueParser \'v\') ""\n-- Result >< \'v\'\n--\n-- >>> parse (constantParser UnexpectedEof ||| valueParser \'v\') ""\n-- Result >< \'v\'\n--\n-- >>> parse (character ||| valueParser \'v\') "abc"\n-- Result >bc< \'a\'\n--\n-- >>> parse (constantParser UnexpectedEof ||| valueParser \'v\') "abc"\n-- Result >abc< \'v\'\n(|||) ::\n  Parser a\n  -> Parser a\n  -> Parser a\n(|||) =\n  error "todo: Course.Parser#(|||)"\n\ninfixl 3 |||\n\n-- | Parsers can bind.\n-- Return a parser that puts its input into the given parser and\n--\n--   * if that parser succeeds with a value (a), put that value into the given function\n--     then put in the remaining input in the resulting parser.\n--\n--   * if that parser fails with an error the returned parser fails with that error.\n--\n-- >>> parse ((\\c -> if c == \'x\' then character else valueParser \'v\') =<< character) "abc"\n-- Result >bc< \'v\'\n--\n-- >>> parse ((\\c -> if c == \'x\' then character else valueParser \'v\') =<< character) "a"\n-- Result >< \'v\'\n--\n-- >>> parse ((\\c -> if c == \'x\' then character else valueParser \'v\') =<< character) "xabc"\n-- Result >bc< \'a\'\n--\n-- >>> isErrorResult (parse ((\\c -> if c == \'x\' then character else valueParser \'v\') =<< character) "")\n-- True\n--\n-- >>> isErrorResult (parse ((\\c -> if c == \'x\' then character else valueParser \'v\') =<< character) "x")\n-- True\ninstance Monad Parser where\n  (=<<) ::\n    (a -> Parser b)\n    -> Parser a\n    -> Parser b\n  (=<<) =\n    error "todo: Course.Parser (=<<)#instance Parser"\n\n-- | Write an Applicative functor instance for a @Parser@.\n-- /Tip:/ Use @(=<<)@.\ninstance Applicative Parser where\n  pure ::\n    a\n    -> Parser a\n  pure =\n    valueParser\n  (<*>) ::\n    Parser (a -> b)\n    -> Parser a\n    -> Parser b\n  (<*>) =\n    error "todo: Course.Parser (<*>)#instance Parser"\n\n-- | Return a parser that continues producing a list of values from the given parser.\n--\n-- /Tip:/ Use @list1@, @pure@ and @(|||)@.\n--\n-- >>> parse (list character) ""\n-- Result >< ""\n--\n-- >>> parse (list digit) "123abc"\n-- Result >abc< "123"\n--\n-- >>> parse (list digit) "abc"\n-- Result >abc< ""\n--\n-- >>> parse (list character) "abc"\n-- Result >< "abc"\n--\n-- >>> parse (list (character *> valueParser \'v\')) "abc"\n-- Result >< "vvv"\n--\n-- >>> parse (list (character *> valueParser \'v\')) ""\n-- Result >< ""\nlist ::\n  Parser a\n  -> Parser (List a)\nlist =\n  error "todo: Course.Parser#list"\n\n-- | Return a parser that produces at least one value from the given parser then\n-- continues producing a list of values from the given parser (to ultimately produce a non-empty list).\n--\n-- /Tip:/ Use @(=<<)@, @list@ and @pure@.\n--\n-- >>> parse (list1 (character)) "abc"\n-- Result >< "abc"\n--\n-- >>> parse (list1 (character *> valueParser \'v\')) "abc"\n-- Result >< "vvv"\n--\n-- >>> isErrorResult (parse (list1 (character *> valueParser \'v\')) "")\n-- True\nlist1 ::\n  Parser a\n  -> Parser (List a)\nlist1 =\n  error "todo: Course.Parser#list1"\n\n-- | Return a parser that produces a character but fails if\n--\n--   * The input is empty.\n--\n--   * The character does not satisfy the given predicate.\n--\n-- /Tip:/ The @(=<<)@, @unexpectedCharParser@ and @character@ functions will be helpful here.\n--\n-- >>> parse (satisfy isUpper) "Abc"\n-- Result >bc< \'A\'\n--\n-- >>> isErrorResult (parse (satisfy isUpper) "abc")\n-- True\nsatisfy ::\n  (Char -> Bool)\n  -> Parser Char\nsatisfy =\n  error "todo: Course.Parser#satisfy"\n\n-- | Return a parser that produces the given character but fails if\n--\n--   * The input is empty.\n--\n--   * The produced character is not equal to the given character.\n--\n-- /Tip:/ Use the @satisfy@ function.\nis ::\n  Char -> Parser Char\nis =\n  error "todo: Course.Parser#is"\n\n-- | Return a parser that produces a character between \'0\' and \'9\' but fails if\n--\n--   * The input is empty.\n--\n--   * The produced character is not a digit.\n--\n-- /Tip:/ Use the @satisfy@ and @Data.Char#isDigit@ functions.\ndigit ::\n  Parser Char\ndigit =\n  error "todo: Course.Parser#digit"\n\n--\n-- | Return a parser that produces a space character but fails if\n--\n--   * The input is empty.\n--\n--   * The produced character is not a space.\n--\n-- /Tip:/ Use the @satisfy@ and @Data.Char#isSpace@ functions.\nspace ::\n  Parser Char\nspace =\n  error "todo: Course.Parser#space"\n\n-- | Return a parser that produces one or more space characters\n-- (consuming until the first non-space) but fails if\n--\n--   * The input is empty.\n--\n--   * The first produced character is not a space.\n--\n-- /Tip:/ Use the @list1@ and @space@ functions.\nspaces1 ::\n  Parser Chars\nspaces1 =\n  error "todo: Course.Parser#spaces1"\n\n-- | Return a parser that produces a lower-case character but fails if\n--\n--   * The input is empty.\n--\n--   * The produced character is not lower-case.\n--\n-- /Tip:/ Use the @satisfy@ and @Data.Char#isLower@ functions.\nlower ::\n  Parser Char\nlower =\n  error "todo: Course.Parser#lower"\n\n-- | Return a parser that produces an upper-case character but fails if\n--\n--   * The input is empty.\n--\n--   * The produced character is not upper-case.\n--\n-- /Tip:/ Use the @satisfy@ and @Data.Char#isUpper@ functions.\nupper ::\n  Parser Char\nupper =\n  error "todo: Course.Parser#upper"\n\n-- | Return a parser that produces an alpha character but fails if\n--\n--   * The input is empty.\n--\n--   * The produced character is not alpha.\n--\n-- /Tip:/ Use the @satisfy@ and @Data.Char#isAlpha@ functions.\nalpha ::\n  Parser Char\nalpha =\n  error "todo: Course.Parser#alpha"\n\n-- | Return a parser that sequences the given list of parsers by producing all their results\n-- but fails on the first failing parser of the list.\n--\n-- /Tip:/ Use @(=<<)@ and @pure@.\n-- /Tip:/ Optionally use @List#foldRight@. If not, an explicit recursive call.\n--\n-- >>> parse (sequenceParser (character :. is \'x\' :. upper :. Nil)) "axCdef"\n-- Result >def< "axC"\n--\n-- >>> isErrorResult (parse (sequenceParser (character :. is \'x\' :. upper :. Nil)) "abCdef")\n-- True\nsequenceParser ::\n  List (Parser a)\n  -> Parser (List a)\nsequenceParser =\n  error "todo: Course.Parser#sequenceParser"\n\n-- | Return a parser that produces the given number of values off the given parser.\n-- This parser fails if the given parser fails in the attempt to produce the given number of values.\n--\n-- /Tip:/ Use @sequenceParser@ and @List.replicate@.\n--\n-- >>> parse (thisMany 4 upper) "ABCDef"\n-- Result >ef< "ABCD"\n--\n-- >>> isErrorResult (parse (thisMany 4 upper) "ABcDef")\n-- True\nthisMany ::\n  Int\n  -> Parser a\n  -> Parser (List a)\nthisMany =\n  error "todo: Course.Parser#thisMany"\n\n-- | This one is done for you.\n--\n-- /Age: positive integer/\n--\n-- >>> parse ageParser "120"\n-- Result >< 120\n--\n-- >>> isErrorResult (parse ageParser "abc")\n-- True\n--\n-- >>> isErrorResult (parse ageParser "-120")\n-- True\nageParser ::\n  Parser Int\nageParser =\n  (\\k -> case read k of Empty  -> constantParser (UnexpectedString k)\n                        Full h -> pure h) =<< (list1 digit)\n\n-- | Write a parser for Person.firstName.\n-- /First Name: non-empty string that starts with a capital letter and is followed by zero or more lower-case letters/\n--\n-- /Tip:/ Use @(=<<)@, @pure@, @upper@, @list@ and @lower@.\n--\n-- >>> parse firstNameParser "Abc"\n-- Result >< "Abc"\n--\n-- >>> isErrorResult (parse firstNameParser "abc")\n-- True\nfirstNameParser ::\n  Parser Chars\nfirstNameParser =\n  error "todo: Course.Parser#firstNameParser"\n\n-- | Write a parser for Person.surname.\n--\n-- /Surname: string that starts with a capital letter and is followed by 5 or more lower-case letters./\n--\n-- /Tip:/ Use @(=<<)@, @pure@, @upper@, @thisMany@, @lower@ and @list@.\n--\n-- >>> parse surnameParser "Abcdef"\n-- Result >< "Abcdef"\n--\n-- >>> parse surnameParser "Abcdefghijklmnopqrstuvwxyz"\n-- Result >< "Abcdefghijklmnopqrstuvwxyz"\n--\n-- >>> isErrorResult (parse surnameParser "Abc")\n-- True\n--\n-- >>> isErrorResult (parse surnameParser "abc")\n-- True\nsurnameParser ::\n  Parser Chars\nsurnameParser =\n  error "todo: Course.Parser#surnameParser"\n\n-- | Write a parser for Person.smoker.\n--\n-- /Smoker: character that must be @\'y\'@ or @\'n\'@/\n--\n-- /Tip:/ Use @is@ and @(|||)@./\n--\n-- >>> parse smokerParser "yabc"\n-- Result >abc< True\n--\n-- >>> parse smokerParser "nabc"\n-- Result >abc< False\n--\n-- >>> isErrorResult (parse smokerParser "abc")\n-- True\nsmokerParser ::\n  Parser Bool\nsmokerParser =\n  error "todo: Course.Parser#smokerParser"\n\n-- | Write part of a parser for Person#phoneBody.\n-- This parser will only produce a string of digits, dots or hyphens.\n-- It will ignore the overall requirement of a phone number to\n-- start with a digit and end with a hash (#).\n--\n-- /Phone: string of digits, dots or hyphens .../\n--\n-- /Tip:/ Use @list@, @digit@, @(|||)@ and @is@.\n--\n-- >>> parse phoneBodyParser "123-456"\n-- Result >< "123-456"\n--\n-- >>> parse phoneBodyParser "123-4a56"\n-- Result >a56< "123-4"\n--\n-- >>> parse phoneBodyParser "a123-456"\n-- Result >a123-456< ""\nphoneBodyParser ::\n  Parser Chars\nphoneBodyParser =\n  error "todo: Course.Parser#phoneBodyParser"\n\n-- | Write a parser for Person.phone.\n--\n-- /Phone: ... but must start with a digit and end with a hash (#)./\n--\n-- /Tip:/ Use @(=<<)@, @pure@, @digit@, @phoneBodyParser@ and @is@.\n--\n-- >>> parse phoneParser "123-456#"\n-- Result >< "123-456"\n--\n-- >>> parse phoneParser "123-456#abc"\n-- Result >abc< "123-456"\n--\n-- >>> isErrorResult (parse phoneParser "123-456")\n-- True\n--\n-- >>> isErrorResult (parse phoneParser "a123-456")\n-- True\nphoneParser ::\n  Parser Chars\nphoneParser =\n  error "todo: Course.Parser#phoneParser"\n\n-- | Write a parser for Person.\n--\n-- /Tip:/ Use @(=<<)@,\n--            @pure@,\n--            @(>>>)@,\n--            @spaces1@,\n--            @ageParser@,\n--            @firstNameParser@,\n--            @surnameParser@,\n--            @smokerParser@,\n--            @phoneParser@.\n--\n-- >>> isErrorResult (parse personParser "")\n-- True\n--\n-- >>> isErrorResult (parse personParser "12x Fred Clarkson y 123-456.789#")\n-- True\n--\n-- >>> isErrorResult (parse personParser "123 fred Clarkson y 123-456.789#")\n-- True\n--\n-- >>> isErrorResult (parse personParser "123 Fred Cla y 123-456.789#")\n-- True\n--\n-- >>> isErrorResult (parse personParser "123 Fred clarkson y 123-456.789#")\n-- True\n--\n-- >>> isErrorResult (parse personParser "123 Fred Clarkson x 123-456.789#")\n-- True\n--\n-- >>> isErrorResult (parse personParser "123 Fred Clarkson y 1x3-456.789#")\n-- True\n--\n-- >>> isErrorResult (parse personParser "123 Fred Clarkson y -123-456.789#")\n-- True\n--\n-- >>> isErrorResult (parse personParser "123 Fred Clarkson y 123-456.789")\n-- True\n--\n-- >>> parse personParser "123 Fred Clarkson y 123-456.789#"\n-- Result >< Person 123 "Fred" "Clarkson" True "123-456.789"\n\n--\n-- >>> parse personParser "123 Fred Clarkson y 123-456.789# rest"\n-- Result > rest< Person 123 "Fred" "Clarkson" True "123-456.789"\n\n--\n-- >>> parse personParser "123  Fred   Clarkson    y     123-456.789#"\n-- Result >< Person 123 "Fred" "Clarkson" True "123-456.789"\npersonParser ::\n  Parser Person\npersonParser =\n  error "todo: Course.Parser#personParser"\n\n-- Make sure all the tests pass!\n\n----\n\n-- Did you repeat yourself in `personParser` ? This might help:\n\n(>>=~) ::\n  Parser a\n  -> (a -> Parser b)\n  -> Parser b\n(>>=~) p f =\n  (p <* spaces1) >>= f\n\ninfixl 1 >>=~\n\n-- or maybe this\n\n(<*>~) ::\n  Parser (a -> b)\n  -> Parser a\n  -> Parser b\n(<*>~) f a =\n  f <*> spaces1 *> a\n\ninfixl 4 <*>~\n'