b'#include <dlfcn.h>\n#include <android_prop.h>\n#include <pthread.h>\n#include <rirud.h>\n#include "jni_hooks.h"\n#include "logging.h"\n#include "module.h"\n#include "hide_utils.h"\n#include "magisk.h"\n#include "entry.h"\n\nstatic void *self_handle;\nstatic bool self_unload_allowed;\n\nstruct SelfUnloadGuard {\n\n    SelfUnloadGuard() {\n        pthread_mutex_init(&mutex_, nullptr);\n    }\n\n    ~SelfUnloadGuard() {\n        LOGD("self unload lock (destructor)");\n        pthread_mutex_lock(&mutex_);\n\n        LOGD("self unload");\n\n        timespec ts = {.tv_sec = 0, .tv_nsec = 1000000L};\n        nanosleep(&ts, nullptr);\n    }\n\n    struct Holder {\n        explicit Holder(pthread_mutex_t *mutex) : mutex_(mutex) {\n            LOGD("self unload lock (holder constructor)");\n            pthread_mutex_lock(mutex_);\n        }\n\n        Holder(Holder &&other) noexcept: mutex_(other.mutex_) {\n            other.mutex_ = nullptr;\n        }\n\n        ~Holder() {\n            if (mutex_) {\n                pthread_mutex_unlock(mutex_);\n                LOGD("self unload unlock (holder destructor)");\n            }\n        }\n\n    private:\n        pthread_mutex_t *mutex_;\n\n    public:\n        Holder(const Holder &) = delete;\n\n        void operator=(const Holder &) = delete;\n    };\n\n    auto hold() { return Holder(&mutex_); };\n\nprivate:\n    pthread_mutex_t mutex_{};\n} self_unload_guard;\n\nstatic void SelfUnload() {\n    LOGD("attempt to self unload");\n\n    [[maybe_unused]] auto holder = self_unload_guard.hold();\n\n    pthread_t thread;\n    pthread_create(&thread, nullptr, (void *(*)(void *)) &dlclose, self_handle);\n    pthread_detach(thread);\n}\n\nbool Entry::IsSelfUnloadAllowed() {\n    return self_unload_allowed;\n}\n\nvoid Entry::Unload(jboolean is_child_zygote) {\n    self_unload_allowed = true;\n\n    for (auto &module : modules::Get()) {\n        if (module.allowUnload()) {\n            LOGD("%s: unload", module.id.data());\n            module.unload();\n        } else {\n            if (module.apiVersion >= 25)\n                LOGD("%s: unload is not allow for this process", module.id.data());\n            else {\n                LOGD("%s: unload is not supported by module (API < 25), self unload is also disabled",\n                     module.id.data());\n                self_unload_allowed = false;\n            }\n        }\n    }\n\n    hide::HideFromSoList();\n\n    // Child zygote (webview zyote or app zygote) has no "execmem" permission\n    if (android_prop::GetApiLevel() < 29 && !is_child_zygote) {\n        hide::HideFromMaps();\n    }\n\n    if (self_unload_allowed) {\n        SelfUnload();\n    }\n}\n\nextern "C" [[gnu::visibility("default")]] [[maybe_unused]] void\n// NOLINTNEXTLINE\ninit(void *handle, const char* magisk_path, const RirudSocket& rirud) {\n    self_handle = handle;\n\n    magisk::SetPath(magisk_path);\n    hide::PrepareMapsHideLibrary();\n    jni::InstallHooks();\n    modules::Load(rirud);\n}\n'