b'package com.naman14.timber.slidinguppanel;\n\nimport android.annotation.SuppressLint;\nimport android.content.Context;\nimport android.content.res.TypedArray;\nimport android.graphics.Canvas;\nimport android.graphics.Paint;\nimport android.graphics.PixelFormat;\nimport android.graphics.Rect;\nimport android.graphics.drawable.Drawable;\nimport android.os.Parcel;\nimport android.os.Parcelable;\nimport androidx.core.content.ContextCompat;\nimport androidx.core.view.MotionEventCompat;\nimport androidx.core.view.ViewCompat;\nimport android.util.AttributeSet;\nimport android.view.Gravity;\nimport android.view.MotionEvent;\nimport android.view.View;\nimport android.view.ViewGroup;\nimport android.view.accessibility.AccessibilityEvent;\n\nimport com.naman14.timber.R;\n\npublic class SlidingUpPanelLayout extends ViewGroup {\n\n    private static final String TAG = SlidingUpPanelLayout.class.getSimpleName();\n\n    /**\n     * Default peeking out panel height\n     */\n    private static final int DEFAULT_PANEL_HEIGHT = 68; // dp;\n\n    /**\n     * Default anchor point height\n     */\n    private static final float DEFAULT_ANCHOR_POINT = 1.0f; // In relative %\n    /**\n     * Default height of the shadow above the peeking out panel\n     */\n    private static final int DEFAULT_SHADOW_HEIGHT = 4; // dp;\n    /**\n     * If no fade color is given by default it will fade to 80% gray.\n     */\n    private static final int DEFAULT_FADE_COLOR = 0x99000000;\n    /**\n     * Whether we should hook up the drag view clickable state\n     */\n    private static final boolean DEFAULT_DRAG_VIEW_CLICKABLE = true;\n    /**\n     * Default Minimum velocity that will be detected as a fling\n     */\n    private static final int DEFAULT_MIN_FLING_VELOCITY = 400; // dips per second\n    /**\n     * Default is set to false because that is how it was written\n     */\n    private static final boolean DEFAULT_OVERLAY_FLAG = false;\n    /**\n     * Default attributes for layout\n     */\n    private static final int[] DEFAULT_ATTRS = new int[]{\n            android.R.attr.gravity\n    };\n    /**\n     * Default paralax length of the main view\n     */\n    private static final int DEFAULT_PARALAX_OFFSET = 0;\n    /**\n     * Default slide panel offset when collapsed\n     */\n    private static final int DEFAULT_SLIDE_PANEL_OFFSET = 0;\n    /**\n     * Default direct offset flag\n     */\n    private static final boolean DEFAULT_DIRECT_OFFSET_FLAG = false;\n    /**\n     * Default initial state for the component\n     */\n    private static SlideState DEFAULT_SLIDE_STATE = SlideState.COLLAPSED;\n    /**\n     * The paint used to dim the main layout when sliding\n     */\n    private final Paint mCoveredFadePaint = new Paint();\n    /**\n     * Drawable used to draw the shadow between panes.\n     */\n    private final Drawable mShadowDrawable;\n    private final ViewDragHelper mDragHelper;\n    private final Rect mTmpRect = new Rect();\n    /**\n     * Minimum velocity that will be detected as a fling\n     */\n    private int mMinFlingVelocity = DEFAULT_MIN_FLING_VELOCITY;\n    /**\n     * The fade color used for the panel covered by the slider. 0 = no fading.\n     */\n    private int mCoveredFadeColor = DEFAULT_FADE_COLOR;\n    /**\n     * The size of the overhang in pixels.\n     */\n    private int mPanelHeight = -1;\n    /**\n     * Determines how much to slide the panel off when expanded\n     */\n    private int mSlidePanelOffset = 0;\n    /**\n     * The size of the shadow in pixels.\n     */\n    private int mShadowHeight = -1;\n    /**\n     * Paralax offset\n     */\n    private int mParallaxOffset = -1;\n    /**\n     * Clamps the Main view to the slideable view\n     */\n    private boolean mDirectOffset = false;\n    /**\n     * True if the collapsed panel should be dragged up.\n     */\n    private boolean mIsSlidingUp;\n    /**\n     * Panel overlays the windows instead of putting it underneath it.\n     */\n    private boolean mOverlayContent = DEFAULT_OVERLAY_FLAG;\n    /**\n     * If provided, the panel can be dragged by only this view. Otherwise, the entire panel can be\n     * used for dragging.\n     */\n    private View mDragView;\n    /**\n     * If provided, the panel can be dragged by only this view. Otherwise, the entire panel can be\n     * used for dragging.\n     */\n    private int mDragViewResId = -1;\n    /**\n     * Whether clicking on the drag view will expand/collapse\n     */\n    private boolean mDragViewClickable = DEFAULT_DRAG_VIEW_CLICKABLE;\n    /**\n     * The child view that can slide, if any.\n     */\n    private View mSlideableView;\n    /**\n     * The main view\n     */\n    private View mMainView;\n    /**\n     * The background view\n     */\n    private View mBackgroundView;\n    private SlideState mSlideState = SlideState.COLLAPSED;\n    /**\n     * How far the panel is offset from its expanded position.\n     * range [0, 1] where 0 = collapsed, 1 = expanded.\n     */\n    private float mSlideOffset;\n    /**\n     * How far in pixels the slideable panel may move.\n     */\n    private int mSlideRange;\n    /**\n     * A panel view is locked into internal scrolling or another condition that\n     * is preventing a drag.\n     */\n    private boolean mIsUnableToDrag;\n    /**\n     * Flag indicating that sliding feature is enabled\\disabled\n     */\n    private boolean mIsSlidingEnabled;\n    /**\n     * Flag indicating if a drag view can have its own touch events.  If set\n     * to true, a drag view can scroll horizontally and have its own click listener.\n     * <p/>\n     * Default is set to false.\n     */\n    private boolean mIsUsingDragViewTouchEvents;\n    private float mInitialMotionX;\n    private float mInitialMotionY;\n    private float mAnchorPoint = 1.f;\n    private PanelSlideListener mPanelSlideListener;\n    /**\n     * Stores whether or not the pane was expanded the last time it was slideable.\n     * If expand/collapse operations are invoked this state is modified. Used by\n     * instance state save/restore.\n     */\n    private boolean mFirstLayout = true;\n\n    public SlidingUpPanelLayout(Context context) {\n        this(context, null);\n    }\n\n    public SlidingUpPanelLayout(Context context, AttributeSet attrs) {\n        this(context, attrs, 0);\n    }\n\n    public SlidingUpPanelLayout(Context context, AttributeSet attrs, int defStyle) {\n        super(context, attrs, defStyle);\n\n        if (isInEditMode()) {\n            mShadowDrawable = null;\n            mDragHelper = null;\n            return;\n        }\n\n        if (attrs != null) {\n            TypedArray defAttrs = context.obtainStyledAttributes(attrs, DEFAULT_ATTRS);\n\n            if (defAttrs != null) {\n                int gravity = defAttrs.getInt(0, Gravity.NO_GRAVITY);\n                if (gravity != Gravity.TOP && gravity != Gravity.BOTTOM) {\n                    throw new IllegalArgumentException("gravity must be set to either top or bottom");\n                }\n                mIsSlidingUp = gravity == Gravity.BOTTOM;\n            }\n\n            defAttrs.recycle();\n\n            TypedArray ta = context.obtainStyledAttributes(attrs, R.styleable.SlidingUpPanelLayout);\n\n            if (ta != null) {\n                mPanelHeight = ta.getDimensionPixelSize(R.styleable.SlidingUpPanelLayout_panelHeight, -1);\n                mSlidePanelOffset = ta.getDimensionPixelSize(R.styleable.SlidingUpPanelLayout_slidePanelOffset, DEFAULT_SLIDE_PANEL_OFFSET);\n                mShadowHeight = ta.getDimensionPixelSize(R.styleable.SlidingUpPanelLayout_shadowHeight, -1);\n                mParallaxOffset = ta.getDimensionPixelSize(R.styleable.SlidingUpPanelLayout_paralaxOffset, -1);\n                mDirectOffset = ta.getBoolean(R.styleable.SlidingUpPanelLayout_directOffset, DEFAULT_DIRECT_OFFSET_FLAG);\n\n                mMinFlingVelocity = ta.getInt(R.styleable.SlidingUpPanelLayout_flingVelocity, DEFAULT_MIN_FLING_VELOCITY);\n                mCoveredFadeColor = ta.getColor(R.styleable.SlidingUpPanelLayout_fadeColor, DEFAULT_FADE_COLOR);\n\n                mDragViewResId = ta.getResourceId(R.styleable.SlidingUpPanelLayout_dragView, -1);\n                mDragViewClickable = ta.getBoolean(R.styleable.SlidingUpPanelLayout_dragViewClickable, DEFAULT_DRAG_VIEW_CLICKABLE);\n\n                mOverlayContent = ta.getBoolean(R.styleable.SlidingUpPanelLayout_overlay, DEFAULT_OVERLAY_FLAG);\n\n                mAnchorPoint = ta.getFloat(R.styleable.SlidingUpPanelLayout_anchorPoint, DEFAULT_ANCHOR_POINT);\n\n                mSlideState = SlideState.values()[ta.getInt(R.styleable.SlidingUpPanelLayout_initialState, DEFAULT_SLIDE_STATE.ordinal())];\n            }\n\n            ta.recycle();\n        }\n\n        final float density = context.getResources().getDisplayMetrics().density;\n        if (mPanelHeight == -1) {\n            mPanelHeight = (int) (DEFAULT_PANEL_HEIGHT * density + 0.5f);\n        }\n        if (mShadowHeight == -1) {\n            mShadowHeight = (int) (DEFAULT_SHADOW_HEIGHT * density + 0.5f);\n        }\n        if (mParallaxOffset == -1) {\n            mParallaxOffset = (int) (DEFAULT_PARALAX_OFFSET * density);\n        }\n        // If the shadow height is zero, don\'t show the shadow\n        if (mShadowHeight > 0) {\n            if (mIsSlidingUp) {\n                mShadowDrawable = ContextCompat.getDrawable(context, R.drawable.above_shadow);\n            } else {\n                mShadowDrawable = ContextCompat.getDrawable(context, R.drawable.below_shadow);\n            }\n\n        } else {\n            mShadowDrawable = null;\n        }\n\n        setWillNotDraw(false);\n\n        mDragHelper = ViewDragHelper.create(this, 0.5f, new DragHelperCallback());\n        mDragHelper.setMinVelocity(mMinFlingVelocity * density);\n\n        mIsSlidingEnabled = true;\n    }\n\n    private static boolean hasOpaqueBackground(View v) {\n        final Drawable bg = v.getBackground();\n        return bg != null && bg.getOpacity() == PixelFormat.OPAQUE;\n    }\n\n    /**\n     * Set the Drag View after the view is inflated\n     */\n    @Override\n    protected void onFinishInflate() {\n        super.onFinishInflate();\n        if (mDragViewResId != -1) {\n            setDragView(findViewById(mDragViewResId));\n        }\n    }\n\n    /**\n     * @return The ARGB-packed color value used to fade the fixed pane\n     */\n    public int getCoveredFadeColor() {\n        return mCoveredFadeColor;\n    }\n\n    /**\n     * Set the color used to fade the pane covered by the sliding pane out when the pane\n     * will become fully covered in the expanded state.\n     *\n     * @param color An ARGB-packed color value\n     */\n    public void setCoveredFadeColor(int color) {\n        mCoveredFadeColor = color;\n        invalidate();\n    }\n\n    public boolean isSlidingEnabled() {\n        return mIsSlidingEnabled && mSlideableView != null;\n    }\n\n    /**\n     * Set sliding enabled flag\n     *\n     * @param enabled flag value\n     */\n    public void setSlidingEnabled(boolean enabled) {\n        mIsSlidingEnabled = enabled;\n    }\n\n    /**\n     * @return The current collapsed panel height\n     */\n    public int getPanelHeight() {\n        return mPanelHeight;\n    }\n\n    /**\n     * Set the collapsed panel height in pixels\n     *\n     * @param val A height in pixels\n     */\n    public void setPanelHeight(int val) {\n        mPanelHeight = val;\n        requestLayout();\n    }\n\n    /**\n     * Sets the panel offset when collapsed so you can exit\n     * the boundaries of the top of the screen\n     *\n     * @param val Offset in pixels\n     */\n    public void setSlidePanelOffset(int val) {\n        mSlidePanelOffset = val;\n        requestLayout();\n    }\n\n    /**\n     * @return The current paralax offset\n     */\n    public int getCurrentParalaxOffset() {\n        if (mParallaxOffset < 0) {\n            return 0;\n        }\n\n        return (int) (mParallaxOffset * getDirectionalSlideOffset());\n    }\n\n    /**\n     * @return The directional slide offset\n     */\n    protected float getDirectionalSlideOffset() {\n        return mIsSlidingUp ? -mSlideOffset : mSlideOffset;\n    }\n\n    /**\n     * Sets the panel slide listener\n     *\n     * @param listener\n     */\n    public void setPanelSlideListener(PanelSlideListener listener) {\n        mPanelSlideListener = listener;\n    }\n\n    /**\n     * Set the draggable view portion. Use to null, to allow the whole panel to be draggable\n     *\n     * @param dragView A view that will be used to drag the panel.\n     */\n    public void setDragView(View dragView) {\n        if (mDragView != null && mDragViewClickable) {\n            mDragView.setOnClickListener(null);\n        }\n        mDragView = dragView;\n        if (mDragView != null) {\n            mDragView.setClickable(true);\n            mDragView.setFocusable(false);\n            mDragView.setFocusableInTouchMode(false);\n            if (mDragViewClickable) {\n                mDragView.setOnClickListener(new OnClickListener() {\n                    @Override\n                    public void onClick(View v) {\n                        if (!isEnabled()) return;\n                        if (!isPanelExpanded() && !isPanelAnchored()) {\n                            expandPanel(mAnchorPoint);\n                        } else {\n                            collapsePanel();\n                        }\n                    }\n                });\n            }\n        }\n    }\n\n    /**\n     * Gets the currently set anchor point\n     *\n     * @return the currently set anchor point\n     */\n    public float getAnchorPoint() {\n        return mAnchorPoint;\n    }\n\n    /**\n     * Set an anchor point where the panel can stop during sliding\n     *\n     * @param anchorPoint A value between 0 and 1, determining the position of the anchor point\n     *                    starting from the top of the layout.\n     */\n    public void setAnchorPoint(float anchorPoint) {\n        if (anchorPoint > 0 && anchorPoint <= 1) {\n            mAnchorPoint = anchorPoint;\n        }\n    }\n\n    /**\n     * Check if the panel is set as an overlay.\n     */\n    public boolean isOverlayed() {\n        return mOverlayContent;\n    }\n\n    /**\n     * Sets whether or not the panel overlays the content\n     *\n     * @param overlayed\n     */\n    public void setOverlayed(boolean overlayed) {\n        mOverlayContent = overlayed;\n    }\n\n    void dispatchOnPanelSlide(View panel) {\n        if (mPanelSlideListener != null) {\n            mPanelSlideListener.onPanelSlide(panel, mSlideOffset);\n        }\n    }\n\n    void dispatchOnPanelExpanded(View panel) {\n        if (mPanelSlideListener != null) {\n            mPanelSlideListener.onPanelExpanded(panel);\n        }\n        sendAccessibilityEvent(AccessibilityEvent.TYPE_WINDOW_STATE_CHANGED);\n    }\n\n    void dispatchOnPanelCollapsed(View panel) {\n        if (mPanelSlideListener != null) {\n            mPanelSlideListener.onPanelCollapsed(panel);\n        }\n        sendAccessibilityEvent(AccessibilityEvent.TYPE_WINDOW_STATE_CHANGED);\n    }\n\n    void dispatchOnPanelAnchored(View panel) {\n        if (mPanelSlideListener != null) {\n            mPanelSlideListener.onPanelAnchored(panel);\n        }\n        sendAccessibilityEvent(AccessibilityEvent.TYPE_WINDOW_STATE_CHANGED);\n    }\n\n    void dispatchOnPanelHidden(View panel) {\n        if (mPanelSlideListener != null) {\n            mPanelSlideListener.onPanelHidden(panel);\n        }\n        sendAccessibilityEvent(AccessibilityEvent.TYPE_WINDOW_STATE_CHANGED);\n    }\n\n    void updateObscuredViewVisibility() {\n        if (getChildCount() == 0) {\n            return;\n        }\n        final int leftBound = getPaddingLeft();\n        final int rightBound = getWidth() - getPaddingRight();\n        final int topBound = getPaddingTop();\n        final int bottomBound = getHeight() - getPaddingBottom();\n        final int left;\n        final int right;\n        final int top;\n        final int bottom;\n        if (mSlideableView != null && hasOpaqueBackground(mSlideableView)) {\n            left = mSlideableView.getLeft();\n            right = mSlideableView.getRight();\n            top = mSlideableView.getTop();\n            bottom = mSlideableView.getBottom();\n        } else {\n            left = right = top = bottom = 0;\n        }\n        View child = mMainView;\n        final int clampedChildLeft = Math.max(leftBound, child.getLeft());\n        final int clampedChildTop = Math.max(topBound, child.getTop());\n        final int clampedChildRight = Math.min(rightBound, child.getRight());\n        final int clampedChildBottom = Math.min(bottomBound, child.getBottom());\n        final int vis;\n        if (clampedChildLeft >= left && clampedChildTop >= top &&\n                clampedChildRight <= right && clampedChildBottom <= bottom) {\n            vis = INVISIBLE;\n        } else {\n            vis = VISIBLE;\n        }\n        child.setVisibility(vis);\n    }\n\n    void setAllChildrenVisible() {\n        for (int i = 0, childCount = getChildCount(); i < childCount; i++) {\n            final View child = getChildAt(i);\n            if (child.getVisibility() == INVISIBLE) {\n                child.setVisibility(VISIBLE);\n            }\n        }\n    }\n\n    @Override\n    protected void onAttachedToWindow() {\n        super.onAttachedToWindow();\n        mFirstLayout = true;\n    }\n\n    @Override\n    protected void onDetachedFromWindow() {\n        super.onDetachedFromWindow();\n        mFirstLayout = true;\n    }\n\n    @Override\n    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {\n        final int widthMode = MeasureSpec.getMode(widthMeasureSpec);\n        final int widthSize = MeasureSpec.getSize(widthMeasureSpec);\n        final int heightMode = MeasureSpec.getMode(heightMeasureSpec);\n        final int heightSize = MeasureSpec.getSize(heightMeasureSpec);\n\n        if (widthMode != MeasureSpec.EXACTLY) {\n            throw new IllegalStateException("Width must have an exact value or MATCH_PARENT");\n        } else if (heightMode != MeasureSpec.EXACTLY) {\n            throw new IllegalStateException("Height must have an exact value or MATCH_PARENT");\n        }\n\n        final int childCount = getChildCount();\n\n        if (childCount != 2 && childCount != 3) {\n            throw new IllegalStateException("Sliding up panel layout must have exactly 2 or 3 children!");\n        }\n\n        if (childCount == 2) {\n            mMainView = getChildAt(0);\n            mSlideableView = getChildAt(1);\n        } else {\n            mBackgroundView = getChildAt(0);\n            mMainView = getChildAt(1);\n            mSlideableView = getChildAt(2);\n        }\n\n        if (mDragView == null) {\n            setDragView(mSlideableView);\n        }\n\n        // If the sliding panel is not visible, then put the whole view in the hidden state\n        if (mSlideableView.getVisibility() == GONE) {\n            mSlideState = SlideState.HIDDEN;\n        }\n\n        int layoutHeight = heightSize - getPaddingTop() - getPaddingBottom();\n\n        // First pass. Measure based on child LayoutParams width/height.\n        for (int i = 0; i < childCount; i++) {\n            final View child = getChildAt(i);\n            final LayoutParams lp = (LayoutParams) child.getLayoutParams();\n\n            // We always measure the sliding panel in order to know it\'s height (needed for show panel)\n            if (child.getVisibility() == GONE && child == mMainView) {\n                continue;\n            }\n\n            int height = layoutHeight;\n            if (child == mMainView && !mOverlayContent && mSlideState != SlideState.HIDDEN) {\n                height -= mPanelHeight;\n            }\n\n            int childWidthSpec;\n            if (lp.width == LayoutParams.WRAP_CONTENT) {\n                childWidthSpec = MeasureSpec.makeMeasureSpec(widthSize, MeasureSpec.AT_MOST);\n            } else if (lp.width == LayoutParams.MATCH_PARENT) {\n                childWidthSpec = MeasureSpec.makeMeasureSpec(widthSize, MeasureSpec.EXACTLY);\n            } else {\n                childWidthSpec = MeasureSpec.makeMeasureSpec(lp.width, MeasureSpec.EXACTLY);\n            }\n\n            int childHeightSpec;\n            if (lp.height == LayoutParams.WRAP_CONTENT) {\n                childHeightSpec = MeasureSpec.makeMeasureSpec(height, MeasureSpec.AT_MOST);\n            } else if (lp.height == LayoutParams.MATCH_PARENT) {\n                childHeightSpec = MeasureSpec.makeMeasureSpec(height, MeasureSpec.EXACTLY);\n            } else {\n                childHeightSpec = MeasureSpec.makeMeasureSpec(lp.height, MeasureSpec.EXACTLY);\n            }\n\n            if (child == mSlideableView) {\n                mSlideRange = MeasureSpec.getSize(childHeightSpec) - mPanelHeight + mSlidePanelOffset;\n                childHeightSpec += mSlidePanelOffset;\n            }\n\n            child.measure(childWidthSpec, childHeightSpec);\n        }\n\n        setMeasuredDimension(widthSize, heightSize);\n    }\n\n    @Override\n    protected void onLayout(boolean changed, int l, int t, int r, int b) {\n        final int paddingLeft = getPaddingLeft();\n        final int paddingTop = getPaddingTop();\n\n        final int childCount = getChildCount();\n\n        if (mFirstLayout) {\n            switch (mSlideState) {\n                case EXPANDED:\n                    mSlideOffset = 1.0f;\n                    break;\n                case ANCHORED:\n                    mSlideOffset = mAnchorPoint;\n                    break;\n                case HIDDEN:\n                    int newTop = computePanelTopPosition(0.0f) + (mIsSlidingUp ? +mPanelHeight : -mPanelHeight);\n                    mSlideOffset = computeSlideOffset(newTop);\n                    break;\n                default:\n                    mSlideOffset = 0.f;\n                    break;\n            }\n        }\n\n        for (int i = 0; i < childCount; i++) {\n            final View child = getChildAt(i);\n\n            // Always layout the sliding view on the first layout\n            if (child.getVisibility() == GONE && (child == mMainView || mFirstLayout)) {\n                continue;\n            }\n\n            final int childHeight = child.getMeasuredHeight();\n            int childTop = paddingTop;\n\n            if (child == mSlideableView) {\n                childTop = computePanelTopPosition(mSlideOffset);\n            }\n\n            if (!mIsSlidingUp) {\n                if (child == mMainView && !mOverlayContent) {\n                    childTop = computePanelTopPosition(mSlideOffset) + mSlideableView.getMeasuredHeight();\n                }\n            }\n            final int childBottom = childTop + childHeight;\n            final int childLeft = paddingLeft;\n            final int childRight = childLeft + child.getMeasuredWidth();\n\n            child.layout(childLeft, childTop, childRight, childBottom);\n        }\n\n        if (mFirstLayout) {\n            updateObscuredViewVisibility();\n        }\n\n        mFirstLayout = false;\n    }\n\n    @Override\n    protected void onSizeChanged(int w, int h, int oldw, int oldh) {\n        super.onSizeChanged(w, h, oldw, oldh);\n        // Recalculate sliding panes and their details\n        if (h != oldh) {\n            mFirstLayout = true;\n        }\n    }\n\n    /**\n     * Set if the drag view can have its own touch events.  If set\n     * to true, a drag view can scroll horizontally and have its own click listener.\n     * <p/>\n     * Default is set to false.\n     */\n    public void setEnableDragViewTouchEvents(boolean enabled) {\n        mIsUsingDragViewTouchEvents = enabled;\n    }\n\n    @Override\n    public void setEnabled(boolean enabled) {\n        if (!enabled) {\n            collapsePanel();\n        }\n        super.setEnabled(enabled);\n    }\n\n    @Override\n    public boolean onInterceptTouchEvent(MotionEvent ev) {\n        final int action = MotionEventCompat.getActionMasked(ev);\n\n\n        if (!isEnabled() || !mIsSlidingEnabled || (mIsUnableToDrag && action != MotionEvent.ACTION_DOWN)) {\n            mDragHelper.cancel();\n            return super.onInterceptTouchEvent(ev);\n        }\n\n        if (action == MotionEvent.ACTION_CANCEL || action == MotionEvent.ACTION_UP) {\n            mDragHelper.cancel();\n            return false;\n        }\n\n        final float x = ev.getX();\n        final float y = ev.getY();\n\n        switch (action) {\n            case MotionEvent.ACTION_DOWN: {\n                mIsUnableToDrag = false;\n                mInitialMotionX = x;\n                mInitialMotionY = y;\n                break;\n            }\n\n            case MotionEvent.ACTION_MOVE: {\n                final float adx = Math.abs(x - mInitialMotionX);\n                final float ady = Math.abs(y - mInitialMotionY);\n                final int dragSlop = mDragHelper.getTouchSlop();\n\n                // Handle any horizontal scrolling on the drag view.\n                if (mIsUsingDragViewTouchEvents && adx > dragSlop && ady < dragSlop) {\n                    return super.onInterceptTouchEvent(ev);\n                }\n\n                if ((ady > dragSlop && adx > ady) || !isDragViewUnder((int) mInitialMotionX, (int) mInitialMotionY)) {\n                    mDragHelper.cancel();\n                    mIsUnableToDrag = true;\n                    return false;\n                }\n                break;\n            }\n        }\n\n        return mDragHelper.shouldInterceptTouchEvent(ev);\n    }\n\n    @Override\n    public boolean onTouchEvent(MotionEvent ev) {\n        if (!isSlidingEnabled()) {\n            return super.onTouchEvent(ev);\n        }\n        mDragHelper.processTouchEvent(ev);\n        return true;\n    }\n\n    private boolean isDragViewUnder(int x, int y) {\n        if (mDragView == null) return false;\n        int[] viewLocation = new int[2];\n        mDragView.getLocationOnScreen(viewLocation);\n        int[] parentLocation = new int[2];\n        this.getLocationOnScreen(parentLocation);\n        int screenX = parentLocation[0] + x;\n        int screenY = parentLocation[1] + y;\n        return screenX >= viewLocation[0] && screenX < viewLocation[0] + mDragView.getWidth() &&\n                screenY >= viewLocation[1] && screenY < viewLocation[1] + mDragView.getHeight();\n    }\n\n    private boolean expandPanel(View pane, int initialVelocity, float mSlideOffset) {\n        return mFirstLayout || smoothSlideTo(mSlideOffset, initialVelocity);\n    }\n\n    private boolean collapsePanel(View pane, int initialVelocity) {\n        return mFirstLayout || smoothSlideTo(0.0f, initialVelocity);\n    }\n\n    /*\n     * Computes the top position of the panel based on the slide offset.\n     */\n    private int computePanelTopPosition(float slideOffset) {\n        int slidingViewHeight = mSlideableView != null ? mSlideableView.getMeasuredHeight() : 0;\n        int slidePixelOffset = (int) (slideOffset * mSlideRange);\n        // Compute the top of the panel if its collapsed\n        return mIsSlidingUp\n                ? getMeasuredHeight() - getPaddingBottom() - mPanelHeight - slidePixelOffset\n                : getPaddingTop() - slidingViewHeight + mPanelHeight + slidePixelOffset;\n    }\n\n    /*\n     * Computes the slide offset based on the top position of the panel\n     */\n    private float computeSlideOffset(int topPosition) {\n        // Compute the panel top position if the panel is collapsed (offset 0)\n        final int topBoundCollapsed = computePanelTopPosition(0);\n\n        // Determine the new slide offset based on the collapsed top position and the new required\n        // top position\n        return (mIsSlidingUp\n                ? (float) (topBoundCollapsed - topPosition) / mSlideRange\n                : (float) (topPosition - topBoundCollapsed) / mSlideRange);\n    }\n\n    /**\n     * Collapse the sliding pane if it is currently slideable. If first layout\n     * has already completed this will animate.\n     *\n     * @return true if the pane was slideable and is now collapsed/in the process of collapsing\n     */\n    public boolean collapsePanel() {\n        if (mFirstLayout) {\n            mSlideState = SlideState.COLLAPSED;\n            return true;\n        } else {\n            if (mSlideState == SlideState.HIDDEN || mSlideState == SlideState.COLLAPSED)\n                return false;\n            return collapsePanel(mSlideableView, 0);\n        }\n    }\n\n    /**\n     * Expand the sliding pane if it is currently slideable.\n     *\n     * @return true if the pane was slideable and is now expanded/in the process of expading\n     */\n    public boolean expandPanel() {\n        if (mFirstLayout) {\n            mSlideState = SlideState.EXPANDED;\n            return true;\n        } else {\n            return expandPanel(1.0f);\n        }\n    }\n\n    /**\n     * Expand the sliding pane to the anchor point if it is currently slideable.\n     *\n     * @return true if the pane was slideable and is now expanded/in the process of expading\n     */\n    public boolean anchorPanel() {\n        if (mFirstLayout) {\n            mSlideState = SlideState.ANCHORED;\n            return true;\n        } else {\n            return expandPanel(mAnchorPoint);\n        }\n    }\n\n    /**\n     * Partially expand the sliding panel up to a specific offset\n     *\n     * @param mSlideOffset Value between 0 and 1, where 0 is completely expanded.\n     * @return true if the pane was slideable and is now expanded/in the process of expanding\n     */\n    public boolean expandPanel(float mSlideOffset) {\n        if (mSlideableView == null || mSlideState == SlideState.EXPANDED) return false;\n        mSlideableView.setVisibility(View.VISIBLE);\n        return expandPanel(mSlideableView, 0, mSlideOffset);\n    }\n\n    /**\n     * Check if the sliding panel in this layout is fully expanded.\n     *\n     * @return true if sliding panel is completely expanded\n     */\n    public boolean isPanelExpanded() {\n        return mSlideState == SlideState.EXPANDED;\n    }\n\n    /**\n     * Check if the sliding panel in this layout is anchored.\n     *\n     * @return true if sliding panel is anchored\n     */\n    public boolean isPanelAnchored() {\n        return mSlideState == SlideState.ANCHORED;\n    }\n\n    /**\n     * Check if the sliding panel in this layout is currently visible.\n     *\n     * @return true if the sliding panel is visible.\n     */\n    public boolean isPanelHidden() {\n        return mSlideState == SlideState.HIDDEN;\n    }\n\n    /**\n     * Shows the panel from the hidden state\n     */\n    public void showPanel() {\n        if (mFirstLayout) {\n            mSlideState = SlideState.COLLAPSED;\n        } else {\n            if (mSlideableView == null || mSlideState != SlideState.HIDDEN) return;\n            mSlideableView.setVisibility(View.VISIBLE);\n            requestLayout();\n            smoothSlideTo(0, 0);\n        }\n    }\n\n    /**\n     * Hides the sliding panel entirely.\n     */\n    public void hidePanel() {\n        if (mFirstLayout) {\n            mSlideState = SlideState.HIDDEN;\n        } else {\n            if (mSlideState == SlideState.DRAGGING || mSlideState == SlideState.HIDDEN) return;\n            int newTop = computePanelTopPosition(0.0f) + (mIsSlidingUp ? +mPanelHeight : -mPanelHeight);\n            smoothSlideTo(computeSlideOffset(newTop), 0);\n        }\n    }\n\n    @SuppressLint("NewApi")\n    private void onPanelDragged(int newTop) {\n        mSlideState = SlideState.DRAGGING;\n        // Recompute the slide offset based on the new top position\n        mSlideOffset = computeSlideOffset(newTop);\n        // Update the parallax based on the new slide offset\n        if ((mParallaxOffset > 0 || mDirectOffset) && mSlideOffset >= 0) {\n            int mainViewOffset = 0;\n            if (mParallaxOffset > 0) {\n                mainViewOffset = getCurrentParalaxOffset();\n            } else {\n                mainViewOffset = (int) (getDirectionalSlideOffset() * mSlideRange);\n            }\n\n            mMainView.setTranslationY(mainViewOffset);\n        }\n\n        // Dispatch the slide event\n        dispatchOnPanelSlide(mSlideableView);\n        // If the slide offset is negative, and overlay is not on, we need to increase the\n        // height of the main content\n        if (mSlideOffset <= 0 && !mOverlayContent) {\n            // expand the main view\n            LayoutParams lp = (LayoutParams) mMainView.getLayoutParams();\n            lp.height = mIsSlidingUp ? (newTop - getPaddingBottom()) : (getHeight() - getPaddingBottom() - mSlideableView.getMeasuredHeight() - newTop);\n            mMainView.requestLayout();\n        }\n    }\n\n    @Override\n    protected boolean drawChild(Canvas canvas, View child, long drawingTime) {\n        boolean result;\n        final int save = canvas.save();\n\n        if (isSlidingEnabled() && mMainView == child) {\n            // Clip against the slider; no sense drawing what will immediately be covered,\n            // Unless the panel is set to overlay content\n            if (!mOverlayContent) {\n                canvas.getClipBounds(mTmpRect);\n                if (mIsSlidingUp) {\n                    mTmpRect.bottom = Math.min(mTmpRect.bottom, mSlideableView.getTop());\n                } else {\n                    mTmpRect.top = Math.max(mTmpRect.top, mSlideableView.getBottom());\n                }\n                canvas.clipRect(mTmpRect);\n            }\n        }\n\n        result = super.drawChild(canvas, child, drawingTime);\n        canvas.restoreToCount(save);\n\n        if (mCoveredFadeColor != 0 && mSlideOffset > 0) {\n            final int baseAlpha = (mCoveredFadeColor & 0xff000000) >>> 24;\n            final int imag = (int) (baseAlpha * mSlideOffset);\n            final int color = imag << 24 | (mCoveredFadeColor & 0xffffff);\n            mCoveredFadePaint.setColor(color);\n            canvas.drawRect(mTmpRect, mCoveredFadePaint);\n        }\n\n        return result;\n    }\n\n    /**\n     * Smoothly animate mDraggingPane to the target X position within its range.\n     *\n     * @param slideOffset position to animate to\n     * @param velocity    initial velocity in case of fling, or 0.\n     */\n    boolean smoothSlideTo(float slideOffset, int velocity) {\n        if (!isSlidingEnabled()) {\n            // Nothing to do.\n            return false;\n        }\n\n        int panelTop = computePanelTopPosition(slideOffset);\n        if (mDragHelper.smoothSlideViewTo(mSlideableView, mSlideableView.getLeft(), panelTop)) {\n            setAllChildrenVisible();\n            ViewCompat.postInvalidateOnAnimation(this);\n            return true;\n        }\n        return false;\n    }\n\n    @Override\n    public void computeScroll() {\n        if (mDragHelper != null && mDragHelper.continueSettling(true)) {\n            if (!isSlidingEnabled()) {\n                mDragHelper.abort();\n                return;\n            }\n\n            ViewCompat.postInvalidateOnAnimation(this);\n        }\n    }\n\n    @Override\n    public void draw(Canvas c) {\n        super.draw(c);\n\n        if (!isSlidingEnabled()) {\n            // No need to draw a shadow if we don\'t have one.\n            return;\n        }\n\n        final int right = mSlideableView.getRight();\n        final int top;\n        final int bottom;\n        if (mIsSlidingUp) {\n            top = mSlideableView.getTop() - mShadowHeight;\n            bottom = mSlideableView.getTop();\n        } else {\n            top = mSlideableView.getBottom();\n            bottom = mSlideableView.getBottom() + mShadowHeight;\n        }\n        final int left = mSlideableView.getLeft();\n\n        if (mShadowDrawable != null) {\n            mShadowDrawable.setBounds(left, top, right, bottom);\n            mShadowDrawable.draw(c);\n        }\n    }\n\n    /**\n     * Tests scrollability within child views of v given a delta of dx.\n     *\n     * @param v      View to test for horizontal scrollability\n     * @param checkV Whether the view v passed should itself be checked for scrollability (true),\n     *               or just its children (false).\n     * @param dx     Delta scrolled in pixels\n     * @param x      X coordinate of the active touch point\n     * @param y      Y coordinate of the active touch point\n     * @return true if child views of v can be scrolled by delta of dx.\n     */\n    protected boolean canScroll(View v, boolean checkV, int dx, int x, int y) {\n        if (v instanceof ViewGroup) {\n            final ViewGroup group = (ViewGroup) v;\n            final int scrollX = v.getScrollX();\n            final int scrollY = v.getScrollY();\n            final int count = group.getChildCount();\n            // Count backwards - let topmost views consume scroll distance first.\n            for (int i = count - 1; i >= 0; i--) {\n                final View child = group.getChildAt(i);\n                if (x + scrollX >= child.getLeft() && x + scrollX < child.getRight() &&\n                        y + scrollY >= child.getTop() && y + scrollY < child.getBottom() &&\n                        canScroll(child, true, dx, x + scrollX - child.getLeft(),\n                                y + scrollY - child.getTop())) {\n                    return true;\n                }\n            }\n        }\n        return checkV && ViewCompat.canScrollHorizontally(v, -dx);\n    }\n\n    @Override\n    protected ViewGroup.LayoutParams generateDefaultLayoutParams() {\n        return new LayoutParams();\n    }\n\n    @Override\n    protected ViewGroup.LayoutParams generateLayoutParams(ViewGroup.LayoutParams p) {\n        return p instanceof MarginLayoutParams\n                ? new LayoutParams((MarginLayoutParams) p)\n                : new LayoutParams(p);\n    }\n\n    @Override\n    protected boolean checkLayoutParams(ViewGroup.LayoutParams p) {\n        return p instanceof LayoutParams && super.checkLayoutParams(p);\n    }\n\n    @Override\n    public ViewGroup.LayoutParams generateLayoutParams(AttributeSet attrs) {\n        return new LayoutParams(getContext(), attrs);\n    }\n\n    @Override\n    public Parcelable onSaveInstanceState() {\n        Parcelable superState = super.onSaveInstanceState();\n\n        SavedState ss = new SavedState(superState);\n        ss.mSlideState = mSlideState;\n\n        return ss;\n    }\n\n    @Override\n    public void onRestoreInstanceState(Parcelable state) {\n        SavedState ss = (SavedState) state;\n        super.onRestoreInstanceState(ss.getSuperState());\n        mSlideState = ss.mSlideState;\n    }\n\n    /**\n     * Current state of the slideable view.\n     */\n    private enum SlideState {\n        EXPANDED,\n        COLLAPSED,\n        ANCHORED,\n        HIDDEN,\n        DRAGGING\n    }\n\n    /**\n     * Listener for monitoring events about sliding panes.\n     */\n    public interface PanelSlideListener {\n        /**\n         * Called when a sliding pane\'s position changes.\n         *\n         * @param panel       The child view that was moved\n         * @param slideOffset The new offset of this sliding pane within its range, from 0-1\n         */\n        void onPanelSlide(View panel, float slideOffset);\n\n        /**\n         * Called when a sliding panel becomes slid completely collapsed.\n         *\n         * @param panel The child view that was slid to an collapsed position\n         */\n        void onPanelCollapsed(View panel);\n\n        /**\n         * Called when a sliding panel becomes slid completely expanded.\n         *\n         * @param panel The child view that was slid to a expanded position\n         */\n        void onPanelExpanded(View panel);\n\n        /**\n         * Called when a sliding panel becomes anchored.\n         *\n         * @param panel The child view that was slid to a anchored position\n         */\n        void onPanelAnchored(View panel);\n\n        /**\n         * Called when a sliding panel becomes completely hidden.\n         *\n         * @param panel The child view that was slid to a hidden position\n         */\n        void onPanelHidden(View panel);\n    }\n\n    /**\n     * No-op stubs for {@link PanelSlideListener}. If you only want to implement a subset\n     * of the listener methods you can extend this instead of implement the full interface.\n     */\n    public static class SimplePanelSlideListener implements PanelSlideListener {\n        @Override\n        public void onPanelSlide(View panel, float slideOffset) {\n        }\n\n        @Override\n        public void onPanelCollapsed(View panel) {\n        }\n\n        @Override\n        public void onPanelExpanded(View panel) {\n        }\n\n        @Override\n        public void onPanelAnchored(View panel) {\n        }\n\n        @Override\n        public void onPanelHidden(View panel) {\n        }\n    }\n\n    public static class LayoutParams extends MarginLayoutParams {\n        private static final int[] ATTRS = new int[]{\n                android.R.attr.layout_weight\n        };\n\n        public LayoutParams() {\n            super(MATCH_PARENT, MATCH_PARENT);\n        }\n\n        public LayoutParams(int width, int height) {\n            super(width, height);\n        }\n\n        public LayoutParams(ViewGroup.LayoutParams source) {\n            super(source);\n        }\n\n        public LayoutParams(MarginLayoutParams source) {\n            super(source);\n        }\n\n        public LayoutParams(LayoutParams source) {\n            super(source);\n        }\n\n        public LayoutParams(Context c, AttributeSet attrs) {\n            super(c, attrs);\n\n            final TypedArray a = c.obtainStyledAttributes(attrs, ATTRS);\n            a.recycle();\n        }\n\n    }\n\n    static class SavedState extends BaseSavedState {\n        public static final Creator<SavedState> CREATOR =\n                new Creator<SavedState>() {\n                    @Override\n                    public SavedState createFromParcel(Parcel in) {\n                        return new SavedState(in);\n                    }\n\n                    @Override\n                    public SavedState[] newArray(int size) {\n                        return new SavedState[size];\n                    }\n                };\n        SlideState mSlideState;\n\n        SavedState(Parcelable superState) {\n            super(superState);\n        }\n\n        private SavedState(Parcel in) {\n            super(in);\n            try {\n                mSlideState = Enum.valueOf(SlideState.class, in.readString());\n            } catch (IllegalArgumentException e) {\n                mSlideState = SlideState.COLLAPSED;\n            }\n        }\n\n        @Override\n        public void writeToParcel(Parcel out, int flags) {\n            super.writeToParcel(out, flags);\n            out.writeString(mSlideState.toString());\n        }\n    }\n\n    private class DragHelperCallback extends ViewDragHelper.Callback {\n\n        @Override\n        public boolean tryCaptureView(View child, int pointerId) {\n            if (mIsUnableToDrag) {\n                return false;\n            }\n\n            return child == mSlideableView;\n        }\n\n        @Override\n        public void onViewDragStateChanged(int state) {\n            if (mDragHelper.getViewDragState() == ViewDragHelper.STATE_IDLE) {\n                mSlideOffset = computeSlideOffset(mSlideableView.getTop());\n\n                if (mSlideOffset == 1) {\n                    if (mSlideState != SlideState.EXPANDED) {\n                        updateObscuredViewVisibility();\n                        mSlideState = SlideState.EXPANDED;\n                        dispatchOnPanelExpanded(mSlideableView);\n                    }\n                } else if (mSlideOffset == 0) {\n                    if (mSlideState != SlideState.COLLAPSED) {\n                        mSlideState = SlideState.COLLAPSED;\n                        dispatchOnPanelCollapsed(mSlideableView);\n                    }\n                } else if (mSlideOffset < 0) {\n                    mSlideState = SlideState.HIDDEN;\n                    mSlideableView.setVisibility(View.GONE);\n                    dispatchOnPanelHidden(mSlideableView);\n                } else if (mSlideState != SlideState.ANCHORED) {\n                    updateObscuredViewVisibility();\n                    mSlideState = SlideState.ANCHORED;\n                    dispatchOnPanelAnchored(mSlideableView);\n                }\n            }\n        }\n\n        @Override\n        public void onViewCaptured(View capturedChild, int activePointerId) {\n            setAllChildrenVisible();\n        }\n\n        @Override\n        public void onViewPositionChanged(View changedView, int left, int top, int dx, int dy) {\n            onPanelDragged(top);\n            invalidate();\n        }\n\n        @Override\n        public void onViewReleased(View releasedChild, float xvel, float yvel) {\n            int target = 0;\n\n            // direction is always positive if we are sliding in the expanded direction\n            float direction = mIsSlidingUp ? -yvel : yvel;\n\n            if (direction > 0) {\n                // swipe up -> expand\n                target = computePanelTopPosition(1.0f);\n            } else if (direction < 0) {\n                // swipe down -> collapse\n                target = computePanelTopPosition(0.0f);\n            } else if (mAnchorPoint != 1 && mSlideOffset >= (1.f + mAnchorPoint) / 2) {\n                // zero velocity, and far enough from anchor point => expand to the top\n                target = computePanelTopPosition(1.0f);\n            } else if (mAnchorPoint == 1 && mSlideOffset >= 0.5f) {\n                // zero velocity, and far enough from anchor point => expand to the top\n                target = computePanelTopPosition(1.0f);\n            } else if (mAnchorPoint != 1 && mSlideOffset >= mAnchorPoint) {\n                target = computePanelTopPosition(mAnchorPoint);\n            } else if (mAnchorPoint != 1 && mSlideOffset >= mAnchorPoint / 2) {\n                target = computePanelTopPosition(mAnchorPoint);\n            } else {\n                // settle at the bottom\n                target = computePanelTopPosition(0.0f);\n            }\n\n            mDragHelper.settleCapturedViewAt(releasedChild.getLeft(), target);\n            invalidate();\n        }\n\n        @Override\n        public int getViewVerticalDragRange(View child) {\n            return mSlideRange;\n        }\n\n        @Override\n        public int clampViewPositionVertical(View child, int top, int dy) {\n            final int collapsedTop = computePanelTopPosition(0.f);\n            final int expandedTop = computePanelTopPosition(1.0f);\n            if (mIsSlidingUp) {\n                return Math.min(Math.max(top, expandedTop), collapsedTop);\n            } else {\n                return Math.min(Math.max(top, collapsedTop), expandedTop);\n            }\n        }\n    }\n}\n'