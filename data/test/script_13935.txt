b'{-# LANGUAGE\n    CPP\n  , FlexibleContexts\n  , GADTs\n  , OverloadedStrings\n  , RankNTypes\n  , ScopedTypeVariables\n  #-}\n#if MIN_VERSION_base(4,9,0)\n{-# OPTIONS_GHC -Wno-redundant-constraints #-}\n#endif\nmodule Rest.Driver.Perform\n  ( Rest (..)\n  , failureWriter\n  , writeResponse\n  , accept\n  ) where\n\nimport Control.Applicative\nimport Control.Monad\nimport Control.Monad.Cont\nimport Control.Monad.Error.Class\nimport Control.Monad.RWS\nimport Control.Monad.Reader\nimport Control.Monad.State\nimport Control.Monad.Trans.Except\nimport Control.Monad.Trans.Identity\nimport Control.Monad.Trans.Maybe (MaybeT (..))\nimport Control.Monad.Writer\nimport Data.Aeson.Utils\nimport Data.Char (isSpace, ord, toLower)\nimport Data.List\nimport Data.List.Split\nimport Data.Maybe\nimport Data.Text.Lazy.Encoding (decodeUtf8)\nimport Data.UUID.Types (UUID)\nimport Network.Multipart (BodyPart (..), MultiPart (..), showMultipartBody)\nimport Safe\nimport System.IO.Unsafe\nimport System.Random (randomIO)\nimport Text.Xml.Pickle\n\nimport qualified Data.ByteString.Lazy      as B\nimport qualified Data.ByteString.Lazy.UTF8 as UTF8\nimport qualified Data.Label.Total          as L\n\nimport Rest.Dictionary (Dict, Dicts (..), Error (..), Errors, Format (..), FromMaybe, Header (..),\n                        Input (..), Inputs, Json (..), Output (..), Outputs, Param (..), Xml (..))\nimport Rest.Driver.Types\nimport Rest.Error\nimport Rest.Handler\nimport Rest.Types.Void\nimport qualified Rest.Dictionary   as D\nimport qualified Rest.Driver.Types as Rest\n\nclass (Applicative m, Monad m) => Rest m where\n  getHeader       :: String -> m (Maybe String)\n  getParameter    :: String -> m (Maybe String)\n  getBody         :: m UTF8.ByteString\n  getMethod       :: m (Maybe Rest.Method)\n  getPaths        :: m [String]\n  lookupMimeType  :: String -> m (Maybe String)\n  setHeader       :: String -> String -> m ()\n  setResponseCode :: Int -> m ()\n\ninstance Rest m => Rest (ContT r m) where\n  getHeader       = lift . getHeader\n  getParameter    = lift . getParameter\n  getBody         = lift getBody\n  getMethod       = lift getMethod\n  getPaths        = lift getPaths\n  lookupMimeType  = lift . lookupMimeType\n  setHeader nm    = lift . setHeader nm\n  setResponseCode = lift . setResponseCode\n\ninstance Rest m => Rest (ExceptT e m) where\n  getHeader       = lift . getHeader\n  getParameter    = lift . getParameter\n  getBody         = lift getBody\n  getMethod       = lift getMethod\n  getPaths        = lift getPaths\n  lookupMimeType  = lift . lookupMimeType\n  setHeader nm    = lift . setHeader nm\n  setResponseCode = lift . setResponseCode\n\ninstance (Monoid w, Rest m) => Rest (RWST r w s m) where\n  getHeader       = lift . getHeader\n  getParameter    = lift . getParameter\n  getBody         = lift getBody\n  getMethod       = lift getMethod\n  getPaths        = lift getPaths\n  lookupMimeType  = lift . lookupMimeType\n  setHeader nm    = lift . setHeader nm\n  setResponseCode = lift . setResponseCode\n\ninstance Rest m => Rest (ReaderT r m) where\n  getHeader       = lift . getHeader\n  getParameter    = lift . getParameter\n  getBody         = lift getBody\n  getMethod       = lift getMethod\n  getPaths        = lift getPaths\n  lookupMimeType  = lift . lookupMimeType\n  setHeader nm    = lift . setHeader nm\n  setResponseCode = lift . setResponseCode\n\ninstance Rest m => Rest (StateT s m) where\n  getHeader       = lift . getHeader\n  getParameter    = lift . getParameter\n  getBody         = lift getBody\n  getMethod       = lift getMethod\n  getPaths        = lift getPaths\n  lookupMimeType  = lift . lookupMimeType\n  setHeader nm    = lift . setHeader nm\n  setResponseCode = lift . setResponseCode\n\ninstance (Monoid w, Rest m) => Rest (WriterT w m) where\n  getHeader       = lift . getHeader\n  getParameter    = lift . getParameter\n  getBody         = lift getBody\n  getMethod       = lift getMethod\n  getPaths        = lift getPaths\n  lookupMimeType  = lift . lookupMimeType\n  setHeader nm    = lift . setHeader nm\n  setResponseCode = lift . setResponseCode\n\ninstance Rest m => Rest (IdentityT m) where\n  getHeader       = lift . getHeader\n  getParameter    = lift . getParameter\n  getBody         = lift getBody\n  getMethod       = lift getMethod\n  getPaths        = lift getPaths\n  lookupMimeType  = lift . lookupMimeType\n  setHeader nm    = lift . setHeader nm\n  setResponseCode = lift . setResponseCode\n\ninstance Rest m => Rest (MaybeT m) where\n  getHeader       = lift . getHeader\n  getParameter    = lift . getParameter\n  getBody         = lift getBody\n  getMethod       = lift getMethod\n  getPaths        = lift getPaths\n  lookupMimeType  = lift . lookupMimeType\n  setHeader nm    = lift . setHeader nm\n  setResponseCode = lift . setResponseCode\n\nwriteResponse :: Rest m => RunnableHandler m -> m UTF8.ByteString\nwriteResponse (RunnableHandler run (GenHandler dict act _)) = do\n  res <- runExceptT $ do\n    let os = L.get D.outputs dict\n    validator os\n    inp <- fetchInputs dict\n    output <- mapExceptT run (act inp)\n    outputWriter os output\n  case res of\n    Left  er -> failureWriter (L.get D.errors dict) er\n    Right r  -> return r\n\n-------------------------------------------------------------------------------\n-- Fetching the input resource.\n\nfetchInputs :: Rest m => Dict h p j o e -> ExceptT (Reason (FromMaybe Void e)) m (Env h p (FromMaybe () j))\nfetchInputs dict =\n  do bs <- getBody\n     ct <- parseContentType <$> getContentType\n\n     h <- HeaderError `mapE` headers    (L.get D.headers dict)\n     p <- ParamError  `mapE` parameters (L.get D.params dict)\n     let inputs = L.get D.inputs dict\n     j <- InputError  `mapE`\n            case inputs of\n              None -> return ()\n              _    ->\n                case ct of\n                  Just XmlFormat      -> parser XmlFormat     inputs bs\n                  Just JsonFormat     -> parser JsonFormat    inputs bs\n                  Just StringFormat   -> parser StringFormat  inputs bs\n                  Just FileFormat     -> parser FileFormat    inputs bs\n                  Just x              -> throwError (UnsupportedFormat (show x))\n                  Nothing | B.null bs -> parser NoFormat inputs bs\n                  Nothing             -> throwError (UnsupportedFormat "unknown")\n     return (Env h p j)\n\ngetContentType :: Rest m => m (Maybe String)\ngetContentType = getHeader "Content-Type"\n\nparseContentType :: Maybe String -> Maybe Format\nparseContentType mct =\n  let segs  = concat (take 1 . splitOn ";" <$> splitOn "," (fromMaybe "" mct))\n      types = flip concatMap segs $ \\ty ->\n                case splitOn "/" ty of\n                  ["application", "xml"]          -> [XmlFormat]\n                  ["application", "json"]         -> [JsonFormat]\n                  ["text",        "xml"]          -> [XmlFormat]\n                  ["text",        "json"]         -> [JsonFormat]\n                  ["text",        "plain"]        -> [StringFormat]\n                  ["application", "octet-stream"] -> [FileFormat]\n                  ["application", _             ] -> [FileFormat]\n                  ["image",       _             ] -> [FileFormat]\n                  _                               -> []\n  in headMay types\n\nheaders :: Rest m => Header h -> ExceptT DataError m h\nheaders NoHeader      = return ()\nheaders (Header xs h) = mapM getHeader xs >>= either throwError return . h\nheaders (TwoHeaders h1 h2) = (,) <$> headers h1 <*> headers h2\n\nparameters :: Rest m => Param p -> ExceptT DataError m p\nparameters NoParam      = return ()\nparameters (Param xs p) = mapM (lift . getParameter) xs >>= either throwError return . p\nparameters (TwoParams p1 p2) = (,) <$> parameters p1 <*> parameters p2\n\nparser :: Monad m => Format -> Inputs j -> B.ByteString -> ExceptT DataError m (FromMaybe () j)\nparser NoFormat None       _ = return ()\nparser f        None       _ = throwError (UnsupportedFormat (show f))\nparser f        (Dicts ds) v = parserD f ds\n  where\n    parserD :: Monad m => Format -> [D.Input j] -> ExceptT DataError m j\n    parserD XmlFormat     (XmlI           : _ ) = case eitherFromXML (UTF8.toString v) of\n                                                    Left err -> throwError (ParseError err)\n                                                    Right  r -> return r\n    parserD XmlFormat     (XmlTextI       : _ ) = return (decodeUtf8 v)\n    parserD StringFormat  (ReadI          : _ ) = (throwError (ParseError "Read") `maybe` return) (readMay (UTF8.toString v))\n    parserD JsonFormat    (JsonI          : _ ) = case eitherDecodeV v of\n                                                    Right a -> return a\n                                                    Left  e -> throwError (ParseError e)\n    parserD StringFormat  (StringI        : _ ) = return (UTF8.toString v)\n    parserD FileFormat    (FileI          : _ ) = return v\n    parserD XmlFormat     (RawXmlI        : _ ) = return v\n    parserD JsonFormat    (RawJsonI       : _ ) = return v\n    parserD JsonFormat    (RawJsonAndXmlI : _ ) = return (Left $ Json v)\n    parserD XmlFormat     (RawJsonAndXmlI : _ ) = return (Right $ Xml v)\n    parserD t             []                    = throwError (UnsupportedFormat (show t))\n    parserD t             (_              : xs) = parserD t xs\n\n-------------------------------------------------------------------------------\n-- Failure responses.\n\nfailureWriter :: Rest m => Errors e -> Reason (FromMaybe Void e) -> m UTF8.ByteString\nfailureWriter es err =\n  do formats <- acceptM\n     fromMaybeT (printFallback formats) $\n       msum (  (tryPrint err                     es   <$> (formats ++ [XmlFormat]))\n            ++ (tryPrint (fallbackError formats) None <$> formats                 )\n            )\n  where\n    tryPrint :: forall m e e\'. (e ~ FromMaybe Void e\', Rest m)\n             => Reason e -> Errors e\' -> Format -> MaybeT m UTF8.ByteString\n    tryPrint e None JsonFormat = printError JsonFormat (toResponseCode e) (encode e)\n    tryPrint e None XmlFormat  = printError XmlFormat  (toResponseCode e) (UTF8.fromString (toXML e))\n    tryPrint _ None _          = mzero\n    tryPrint e (Dicts ds) f = tryPrintD ds f\n      where\n        tryPrintD :: Rest m => [D.Error e] -> Format -> MaybeT m UTF8.ByteString\n        tryPrintD (JsonE   : _ ) JsonFormat = printError JsonFormat (toResponseCode e) (encode e)\n        tryPrintD (XmlE    : _ ) XmlFormat  = printError XmlFormat  (toResponseCode e) (UTF8.fromString (toXML e))\n        tryPrintD (_       : xs) t          = tryPrintD xs t\n        tryPrintD []             _          = mzero\n\n    printError f cd x =\n      do contentType f\n         setResponseCode cd\n         return x\n\n    printFallback fs = printError XmlFormat (toResponseCode (fallbackError fs)) (UTF8.fromString (toXML $ fallbackError fs))\n\n    fallbackError :: [Format] -> Reason_\n    fallbackError fs = OutputError (UnsupportedFormat $ intercalate "," $ map formatCT fs)\n\n    formatCT v =\n      case v of\n        XmlFormat       -> "xml"\n        JsonFormat      -> "json"\n        StringFormat    -> "text/plain"\n        FileFormat      -> "application/octet-stream"\n        MultipartFormat -> "multipart/mixed"\n        NoFormat        -> "any"\n\n    fromMaybeT def = runMaybeT >=> maybe def return\n\n-------------------------------------------------------------------------------\n-- Printing the output resource.\n\ncontentType :: Rest m => Format -> m ()\ncontentType c = setHeader "Content-Type" $\n  case c of\n    JsonFormat -> "application/json; charset=UTF-8"\n    XmlFormat  -> "application/xml; charset=UTF-8"\n    _          -> "text/plain; charset=UTF-8"\n\n\nvalidator :: forall v m e. Rest m => Outputs v -> ExceptT (Reason e) m ()\nvalidator = tryOutputs try\n  where\n    try :: Outputs v -> Format -> ExceptT (Last DataError) m ()\n    try None NoFormat        = return ()\n    try None XmlFormat       = return ()\n    try None JsonFormat      = return ()\n    try None StringFormat    = return ()\n    try None MultipartFormat = return ()\n    try None FileFormat      = unsupportedFormat FileFormat\n    try (Dicts ds) f = tryD ds f\n      where\n        tryD :: forall v\'. [Output v\'] -> Format -> ExceptT (Last DataError) m ()\n        tryD (XmlO           : _ ) XmlFormat    = return ()\n        tryD (RawXmlO        : _ ) XmlFormat    = return ()\n        tryD (JsonO          : _ ) JsonFormat   = return ()\n        tryD (RawJsonO       : _ ) JsonFormat   = return ()\n        tryD (StringO        : _ ) StringFormat = return ()\n        tryD (FileO          : _ ) FileFormat   = return ()\n        tryD (RawJsonAndXmlO : _ ) _            = return ()\n        tryD (MultipartO     : _ ) _            = return () -- Multipart is always ok, subparts can fail.\n        tryD []                    t            = unsupportedFormat t\n        tryD (_              : xs) t            = tryD xs t\n\noutputWriter :: forall v m e. Rest m => Outputs v -> FromMaybe () v -> ExceptT (Reason e) m UTF8.ByteString\noutputWriter outputs v = tryOutputs try outputs\n  where\n    try :: Outputs v -> Format -> ExceptT (Last DataError) m UTF8.ByteString\n    try None NoFormat        = contentType NoFormat >> ok ""\n    try None XmlFormat       = contentType NoFormat >> ok "<done/>"\n    try None JsonFormat      = contentType NoFormat >> ok "{}"\n    try None StringFormat    = contentType NoFormat >> ok "done"\n    try None FileFormat      = unsupportedFormat FileFormat\n    try None MultipartFormat = contentType NoFormat >> ok ""\n    try (Dicts ds) f = tryD ds f\n      where\n        tryD :: forall v\'. FromMaybe () v ~ v\' => [Output v\'] -> Format -> ExceptT (Last DataError) m UTF8.ByteString\n        tryD (XmlO           : _ ) XmlFormat    = contentType XmlFormat    >> ok (UTF8.fromString (toXML v))\n        tryD (RawXmlO        : _ ) XmlFormat    = contentType XmlFormat    >> ok v\n        tryD (JsonO          : _ ) JsonFormat   = contentType JsonFormat   >> ok (encode v)\n        tryD (RawJsonO       : _ ) JsonFormat   = contentType JsonFormat   >> ok v\n        tryD (RawJsonAndXmlO : _ ) JsonFormat   = contentType JsonFormat   >> ok v\n        tryD (RawJsonAndXmlO : _ ) XmlFormat    = contentType XmlFormat    >> ok v\n        tryD (StringO        : _ ) StringFormat = contentType StringFormat >> ok (UTF8.fromString v)\n        tryD (MultipartO     : _ ) _            = outputMultipart v\n        tryD (FileO          : _ ) FileFormat   =\n          do let (content, filename, isAttachment) = v\n                 ext = (reverse . takeWhile (/=\'.\') . reverse) filename\n             mime <- fromMaybe "application/octet-stream" <$> lookupMimeType (map toLower ext)\n             setHeader "Content-Type" mime\n             setHeader "Cache-Control" "max-age=604800"\n             setHeader "Content-Disposition" (  (if isAttachment then "attachment; " else "")\n                                             ++ "filename=\\"" ++ headerEscape filename ++ "\\""\n                                             )\n             ok content\n        tryD []                t            = unsupportedFormat t\n        tryD (_          : xs) t            = tryD xs t\n    ok r = setResponseCode 200 >> return r\n    -- Escape double quotes with a backslash, since we quote the\n    -- values with double quotes, and filter out characters below\n    -- space. The latter prevents e.g. newlines ending up in the file\n    -- name, which can cause \'response splitting\' security issues.\n    headerEscape :: String -> String\n    headerEscape = filter ((>=32) . ord) . intercalate "\\\\\\"" . splitOn "\\""\n\nunsupportedFormat :: (Monad m, Show a) => a -> ExceptT (Last DataError) m a1\nunsupportedFormat = throwError . Last . Just . UnsupportedFormat . show\n\ntryOutputs :: Rest m => (t -> Format -> ExceptT (Last DataError) m a) -> t -> ExceptT (Reason e) m a\ntryOutputs try outputs = do\n  formats <- lift acceptM\n  rethrowLast $ msum (try outputs <$> formats) <|> unsupportedFormat formats\n  where\n    rethrowLast :: Monad m => ExceptT (Last DataError) m a -> ExceptT (Reason e) m a\n    rethrowLast = either (maybe (error "Rest.Driver.Perform: ExceptT threw Last Nothing, this is a bug") (throwError . OutputError) . getLast) return <=< lift . runExceptT\n\noutputMultipart :: Rest m => [BodyPart] -> m UTF8.ByteString\noutputMultipart vs =\n  do let boundary = show $ unsafePerformIO (randomIO :: IO UUID)\n     setHeader "Content-Type" ("multipart/mixed; boundary=" ++ boundary)\n     return $ showMultipartBody boundary (MultiPart vs)\n\nacceptM :: Rest m => m [Format]\nacceptM =\n  do acceptHeader <- getHeader "Accept"\n     ct <- getHeader "Content-Type"\n     ty <- getParameter "type"\n     return $ accept acceptHeader ct ty\n\naccept :: Maybe String -> Maybe String -> Maybe String -> [Format]\naccept acceptHeader mct mty =\n  let ct :: Maybe Format\n      ct = parseContentType mct\n      fromQuery :: [Format]\n      fromQuery =\n        case mty of\n          Just "json" -> [JsonFormat]\n          Just "xml"  -> [XmlFormat]\n          _           -> []\n      fromAccept :: [Format]\n      fromAccept = maybe (allFormats ct) (splitter ct) acceptHeader\n  in (fromQuery ++ fromAccept)\n  where\n    allFormats :: Maybe Format -> [Format]\n    allFormats ct = maybe id (:) ct [minBound .. maxBound]\n    splitter :: Maybe Format -> String -> [Format]\n    splitter ct hdr = nub (match ct =<< takeWhile (/= \';\') . trim <$> splitOn "," hdr)\n\n    match :: Maybe Format -> String -> [Format]\n    match ct ty\' =\n      case map trim <$> (splitOn "+" . trim <$> splitOn "/" ty\') of\n        [ ["*"]           , ["*"] ] -> allFormats ct\n        [ ["*"]                   ] -> allFormats ct\n        [ ["text"]        , xs    ] -> xs >>= txt\n        [ ["application"] , xs    ] -> xs >>= app\n        [ ["image"]       , xs    ] -> xs >>= img\n        _                           -> []\n\n    trim = f . f\n      where f = reverse . dropWhile isSpace\n\n    txt "*"            = [XmlFormat, JsonFormat, StringFormat]\n    txt "json"         = [JsonFormat]\n    txt "xml"          = [XmlFormat]\n    txt "plain"        = [StringFormat]\n    txt _              = []\n    app "*"            = [XmlFormat, JsonFormat, FileFormat]\n    app "xml"          = [XmlFormat]\n    app "json"         = [JsonFormat]\n    app "octet-stream" = [FileFormat]\n    app _              = []\n    img _              = [FileFormat]\n'