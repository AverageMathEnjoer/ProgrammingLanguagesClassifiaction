b'{-# LANGUAGE NoImplicitPrelude #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n{-# LANGUAGE InstanceSigs #-}\n{-# LANGUAGE RebindableSyntax #-}\n{-# LANGUAGE OverloadedStrings #-}\n\nmodule Course.StateT where\n\nimport Course.Core\nimport Course.ExactlyOne\nimport Course.Optional\nimport Course.List\nimport Course.Functor\nimport Course.Applicative\nimport Course.Monad\nimport Course.State\nimport qualified Data.Set as S\nimport qualified Prelude as P\n\n-- $setup\n-- >>> import Test.QuickCheck\n-- >>> import qualified Prelude as P(fmap)\n-- >>> instance Arbitrary a => Arbitrary (List a) where arbitrary = P.fmap listh arbitrary\n\n-- | A `StateT` is a function from a state value `s` to a functor f of (a produced value `a`, and a resulting state `s`).\nnewtype StateT s f a =\n  StateT {\n    runStateT ::\n      s\n      -> f (a, s)\n  }\n\n-- | Implement the `Functor` instance for @StateT s f@ given a @Functor f@.\n--\n-- >>> runStateT ((+1) <$> (pure 2) :: StateT Int List Int) 0\n-- [(3,0)]\ninstance Functor f => Functor (StateT s f) where\n  (<$>) ::\n    (a -> b)\n    -> StateT s f a\n    -> StateT s f b\n  (<$>) =\n    error "todo: Course.StateT (<$>)#instance (StateT s f)"\n\n-- | Implement the `Applicative` instance for @StateT s f@ given a @Monad f@.\n--\n-- >>> runStateT (pure 2) 0\n-- (2,0)\n--\n-- >>> runStateT ((pure 2) :: StateT Int List Int) 0\n-- [(2,0)]\n--\n-- >>> runStateT (pure (+2) <*> ((pure 2) :: StateT Int List Int)) 0\n-- [(4,0)]\n--\n-- >>> import qualified Prelude as P\n-- >>> runStateT (StateT (\\s -> Full ((+2), s P.++ [1])) <*> (StateT (\\s -> Full (2, s P.++ [2])))) [0]\n-- Full (4,[0,1,2])\n--\n-- >>> runStateT (StateT (\\s -> ((+2), s P.++ [1]) :. ((+3), s P.++ [1]) :. Nil) <*> (StateT (\\s -> (2, s P.++ [2]) :. Nil))) [0]\n-- [(4,[0,1,2]),(5,[0,1,2])]\ninstance Monad f => Applicative (StateT s f) where\n  pure ::\n    a\n    -> StateT s f a\n  pure =\n    error "todo: Course.StateT pure#instance (StateT s f)"\n  (<*>) ::\n   StateT s f (a -> b)\n    -> StateT s f a\n    -> StateT s f b\n  (<*>) =\n    error "todo: Course.StateT (<*>)#instance (StateT s f)"\n\n-- | Implement the `Monad` instance for @StateT s f@ given a @Monad f@.\n-- Make sure the state value is passed through in `bind`.\n--\n-- >>> runStateT ((const $ putT 2) =<< putT 1) 0\n-- ((),2)\n--\n-- >>> let modify f = StateT (\\s -> pure ((), f s)) in runStateT (modify (+1) >>= \\() -> modify (*2)) 7\n-- ((),16)\ninstance Monad f => Monad (StateT s f) where\n  (=<<) ::\n    (a -> StateT s f b)\n    -> StateT s f a\n    -> StateT s f b\n  (=<<) =\n    error "todo: Course.StateT (=<<)#instance (StateT s f)"\n\n-- | A `State\'` is `StateT` specialised to the `ExactlyOne` functor.\ntype State\' s a =\n  StateT s ExactlyOne a\n\n-- | Provide a constructor for `State\'` values\n--\n-- >>> runStateT (state\' $ runState $ put 1) 0\n-- ExactlyOne  ((),1)\nstate\' ::\n  (s -> (a, s))\n  -> State\' s a\nstate\' =\n  error "todo: Course.StateT#state\'"\n\n-- | Provide an unwrapper for `State\'` values.\n--\n-- >>> runState\' (state\' $ runState $ put 1) 0\n-- ((),1)\nrunState\' ::\n  State\' s a\n  -> s\n  -> (a, s)\nrunState\' =\n  error "todo: Course.StateT#runState\'"\n\n-- | Run the `StateT` seeded with `s` and retrieve the resulting state.\nexecT ::\n  Functor f =>\n  StateT s f a\n  -> s\n  -> f s\nexecT =\n  error "todo: Course.StateT#execT"\n\n-- | Run the `State` seeded with `s` and retrieve the resulting state.\nexec\' ::\n  State\' s a\n  -> s\n  -> s\nexec\' =\n  error "todo: Course.StateT#exec\'"\n\n-- | Run the `StateT` seeded with `s` and retrieve the resulting value.\nevalT ::\n  Functor f =>\n  StateT s f a\n  -> s\n  -> f a\nevalT =\n  error "todo: Course.StateT#evalT"\n\n-- | Run the `State` seeded with `s` and retrieve the resulting value.\neval\' ::\n  State\' s a\n  -> s\n  -> a\neval\' =\n  error "todo: Course.StateT#eval\'"\n\n-- | A `StateT` where the state also distributes into the produced value.\n--\n-- >>> (runStateT (getT :: StateT Int List Int) 3)\n-- [(3,3)]\ngetT ::\n  Applicative f =>\n  StateT s f s\ngetT =\n  error "todo: Course.StateT#getT"\n\n-- | A `StateT` where the resulting state is seeded with the given value.\n--\n-- >>> runStateT (putT 2) 0\n-- ((),2)\n--\n-- >>> runStateT (putT 2 :: StateT Int List ()) 0\n-- [((),2)]\nputT ::\n  Applicative f =>\n  s\n  -> StateT s f ()\nputT =\n  error "todo: Course.StateT#putT"\n\n-- | Remove all duplicate elements in a `List`.\n--\n-- /Tip:/ Use `filtering` and `State\'` with a @Data.Set#Set@.\n--\n-- prop> \\xs -> distinct\' xs == distinct\' (flatMap (\\x -> x :. x :. Nil) xs)\ndistinct\' ::\n  (Ord a, Num a) =>\n  List a\n  -> List a\ndistinct\' =\n  error "todo: Course.StateT#distinct\'"\n\n-- | Remove all duplicate elements in a `List`.\n-- However, if you see a value greater than `100` in the list,\n-- abort the computation by producing `Empty`.\n--\n-- /Tip:/ Use `filtering` and `StateT` over `Optional` with a @Data.Set#Set@.\n--\n-- >>> distinctF $ listh [1,2,3,2,1]\n-- Full [1,2,3]\n--\n-- >>> distinctF $ listh [1,2,3,2,1,101]\n-- Empty\ndistinctF ::\n  (Ord a, Num a) =>\n  List a\n  -> Optional (List a)\ndistinctF =\n  error "todo: Course.StateT#distinctF"\n\n-- | An `OptionalT` is a functor of an `Optional` value.\ndata OptionalT f a =\n  OptionalT {\n    runOptionalT ::\n      f (Optional a)\n  }\n\n-- | Implement the `Functor` instance for `OptionalT f` given a Functor f.\n--\n-- >>> runOptionalT $ (+1) <$> OptionalT (Full 1 :. Empty :. Nil)\n-- [Full 2,Empty]\ninstance Functor f => Functor (OptionalT f) where\n  (<$>) =\n    error "todo: Course.StateT (<$>)#instance (OptionalT f)"\n\n-- | Implement the `Applicative` instance for `OptionalT f` given a Monad f.\n--\n-- /Tip:/ Use `onFull` to help implement (<*>).\n--\n-- >>> runOptionalT $ OptionalT Nil <*> OptionalT (Full 1 :. Full 2 :. Nil)\n-- []\n--\n-- >>> runOptionalT $ OptionalT (Full (+1) :. Full (+2) :. Nil) <*> OptionalT Nil\n-- []\n--\n-- >>> runOptionalT $ OptionalT (Empty :. Nil) <*> OptionalT (Empty :. Nil)\n-- [Empty]\n--\n-- >>> runOptionalT $ OptionalT (Full (+1) :. Empty :. Nil) <*> OptionalT (Empty :. Nil)\n-- [Empty,Empty]\n--\n-- >>> runOptionalT $ OptionalT (Empty :. Nil) <*> OptionalT (Full 1 :. Full 2 :. Nil)\n-- [Empty]\n--\n-- >>> runOptionalT $ OptionalT (Full (+1) :. Empty :. Nil) <*> OptionalT (Full 1 :. Full 2 :. Nil)\n-- [Full 2,Full 3,Empty]\n--\n-- >>> runOptionalT $ OptionalT (Full (+1) :. Full (+2) :. Nil) <*> OptionalT (Full 1 :. Empty :. Nil)\n-- [Full 2,Empty,Full 3,Empty]\ninstance Monad f => Applicative (OptionalT f) where\n  pure =\n    error "todo: Course.StateT pure#instance (OptionalT f)"\n  (<*>) =\n    error "todo: Course.StateT (<*>)#instance (OptionalT f)"\n\n-- | Implement the `Monad` instance for `OptionalT f` given a Monad f.\n--\n-- >>> runOptionalT $ (\\a -> OptionalT (Full (a+1) :. Full (a+2) :. Nil)) =<< OptionalT (Full 1 :. Empty :. Nil)\n-- [Full 2,Full 3,Empty]\ninstance Monad f => Monad (OptionalT f) where\n  (=<<) =\n    error "todo: Course.StateT (=<<)#instance (OptionalT f)"\n\n-- | A `Logger` is a pair of a list of log values (`[l]`) and an arbitrary value (`a`).\ndata Logger l a =\n  Logger (List l) a\n  deriving (Eq, Show)\n\n-- | Implement the `Functor` instance for `Logger\n--\n-- >>> (+3) <$> Logger (listh [1,2]) 3\n-- Logger [1,2] 6\ninstance Functor (Logger l) where\n  (<$>) =\n    error "todo: Course.StateT (<$>)#instance (Logger l)"\n\n-- | Implement the `Applicative` instance for `Logger`.\n--\n-- >>> pure "table" :: Logger Int P.String\n-- Logger [] "table"\n--\n-- >>> Logger (listh [1,2]) (+7) <*> Logger (listh [3,4]) 3\n-- Logger [1,2,3,4] 10\ninstance Applicative (Logger l) where\n  pure =\n    error "todo: Course.StateT pure#instance (Logger l)"\n  (<*>) =\n    error "todo: Course.StateT (<*>)#instance (Logger l)"\n\n-- | Implement the `Monad` instance for `Logger`.\n-- The `bind` implementation must append log values to maintain associativity.\n--\n-- >>> (\\a -> Logger (listh [4,5]) (a+3)) =<< Logger (listh [1,2]) 3\n-- Logger [1,2,4,5] 6\ninstance Monad (Logger l) where\n  (=<<) =\n    error "todo: Course.StateT (=<<)#instance (Logger l)"\n\n-- | A utility function for producing a `Logger` with one log value.\n--\n-- >>> log1 1 2\n-- Logger [1] 2\nlog1 ::\n  l\n  -> a\n  -> Logger l a\nlog1 =\n  error "todo: Course.StateT#log1"\n\n-- | Remove all duplicate integers from a list. Produce a log as you go.\n-- If there is an element above 100, then abort the entire computation and produce no result.\n-- However, always keep a log. If you abort the computation, produce a log with the value,\n-- "aborting > 100: " followed by the value that caused it.\n-- If you see an even number, produce a log message, "even number: " followed by the even number.\n-- Other numbers produce no log message.\n--\n-- /Tip:/ Use `filtering` and `StateT` over (`OptionalT` over `Logger` with a @Data.Set#Set@).\n--\n-- >>> distinctG $ listh [1,2,3,2,6]\n-- Logger ["even number: 2","even number: 2","even number: 6"] (Full [1,2,3,6])\n--\n-- >>> distinctG $ listh [1,2,3,2,6,106]\n-- Logger ["even number: 2","even number: 2","even number: 6","aborting > 100: 106"] Empty\ndistinctG ::\n  (Integral a, Show a) =>\n  List a\n  -> Logger Chars (Optional (List a))\ndistinctG =\n  error "todo: Course.StateT#distinctG"\n\nonFull ::\n  Applicative f =>\n  (t -> f (Optional a))\n  -> Optional t\n  -> f (Optional a)\nonFull g o =\n  case o of\n    Empty ->\n      pure Empty\n    Full a ->\n      g a\n'