b'{-# LANGUAGE ScopedTypeVariables #-}\nmodule Rest.Gen.JavaScript (mkJsApi) where\n\nimport Prelude hiding ((.))\n\nimport Control.Category ((.))\nimport Data.Maybe\nimport Text.StringTemplate\nimport qualified Data.Label.Total   as L\nimport qualified Data.List.NonEmpty as NList\n\nimport Code.Build\nimport Code.Build.JavaScript\nimport Rest.Api (Router, Version)\nimport Rest.Gen.Base\nimport Rest.Gen.Types\nimport Rest.Gen.Utils\nimport qualified Rest.Gen.NoAnnotation as N\n\nmkJsApi :: N.ModuleName -> Bool -> Version -> Router m s -> IO String\nmkJsApi ns priv ver r =\n  do prelude <- render . setManyAttrib attrs . newSTMP <$> readContent "Javascript/prelude.js"\n     epilogue <- render . setManyAttrib attrs . newSTMP <$> readContent "Javascript/epilogue.js"\n     let cod = showCode $ mkStack\n                [ unModuleName ns ++ ".prototype.version" .=. string (show ver)\n                , mkJsCode (unModuleName ns) priv r\n                ]\n     return $ mkJsModule (prelude ++ cod ++ epilogue)\n  where attrs = [("apinamespace", unModuleName ns), ("dollar", "$")]\n\nmkJsModule :: String -> String\nmkJsModule content = "(function (window) {\\n\\n" ++ content ++ "\\n\\n})(this);"\n\nmkJsCode :: String -> Bool -> Router m s -> Code\nmkJsCode ns priv = mkJs ns . sortTree . (if priv then id else noPrivate) . apiSubtrees\n\nmkJs :: String -> ApiResource -> Code\nmkJs ns = foldTreeChildren mkStack (\\i ls -> mkStack $ mkRes ns i : ls)\n\nmkRes :: String -> ApiResource -> Code\nmkRes ns node = mkStack\n  [ if hasAccessor node\n      then resourceLoc ns node .=. mkAccessorConstructor ns node\n      else resourceLoc ns node .=. jsObject []\n  , resourceLoc ns node ++ ".apiObjectType" .=. string "resourceDir"\n  , mkAccessFuncs ns node\n  , mkPreFuncs ns node\n  , mkPostFuncs ns node\n  ]\n\nmkAccessorConstructor :: String -> ApiResource -> Code\nmkAccessorConstructor ns resource =\n  let constrName = jsDir (cleanName (resName resource))\n  in functionDecl constrName ["url", "secureUrl", "modifyRequest"] $\n       jsIf (code $ "this instanceof " ++ constrName)\n            (proc (ns ++ ".setContext") (code "this, url, secureUrl, modifyRequest"))\n         <-> jsElse (ret $ call (constrName ++ ".access") (code "url, secureUrl, modifyRequest"))\n\nmkPreFuncs :: String -> ApiResource -> Code\nmkPreFuncs ns node =\n  let items = filter ((\\i -> not $ postAction i || isAccessor i) . itemInfo) $ resItems node\n  in mkFunctions (resourceLoc ns node ++ ".") (mkFunction ns) items\n\nmkAccessFuncs :: String -> ApiResource -> Code\nmkAccessFuncs ns node =\n  let items = filter ((\\i -> not (postAction i) && isAccessor i) . itemInfo) $ resItems node\n  in mkFunctions (resourceLoc ns node ++ ".") (mkAccessor ns) items\n\nmkPostFuncs :: String -> ApiResource -> Code\nmkPostFuncs ns node =\n  let items = filter (postAction . itemInfo) $ resItems node\n  in mkFunctions (resourceLoc ns node ++ ".prototype.") (mkFunction ns) items\n\nmkFunctions :: String -> (ApiAction -> Code) -> [ApiAction] -> Code\nmkFunctions loc maker = mkStack . map (\\item -> loc ++ mkJsName item .=. maker item)\n\nmkAccessor :: String -> ApiAction -> Code\nmkAccessor ns node@(ApiAction _ _ ai) =\n  let fParams  = maybeToList mIdent\n      urlPart  = (if resDir ai == "" then "" else resDir ai ++ "/")\n              ++ maybe "" (\\i -> "\' + encodeURIComponent(" ++ i ++ ") + \'/") mIdent\n      mIdent   = jsId . cleanName . description <$> ident ai\n  in function fParams\n      [ var "postfix" $ "\'" ++ urlPart ++ "\'"\n      , var "accessor" $ new "this" . code $  "this.contextUrl + postfix, "\n                                           ++ "this.secureContextUrl + postfix, "\n                                           ++ "this.modifyRequest"\n      , "accessor.get" .=. mkFunction ns node\n      , ret "accessor"\n      ]\n\nmkFunction :: String -> ApiAction -> Code\nmkFunction ns (ApiAction _ _ ai) =\n  let fParams  = maybeToList mIdent\n              ++ maybeToList (fmap fst3 mInp)\n              ++ ["success", "error", "params", "callOpts"]\n      mInp     = fmap (mkType . L.get (dataType . desc) . chooseType) . NList.nonEmpty . inputs $ ai\n      mOut     = dataTypesToAcceptHeader JSON . responseAcceptType . chooseResponseType $ ai\n      urlPart  = (if isAccessor ai then const "" else id) $\n                 (if resDir ai == "" then "" else resDir ai ++ "/")\n              ++ maybe "" (\\i -> "\' + encodeURIComponent(" ++ i ++ ") + \'/") mIdent\n      mIdent   = (if isAccessor ai then const Nothing else id) $ jsId . cleanName . description <$> ident ai\n  in function fParams $ ret $\n        call (ns ++ "." ++ "ajaxCall")\n          [ string (method ai)\n          , code $ (if https ai then "this.secureContextUrl" else "this.contextUrl") ++ " + \'" ++ urlPart ++ "\'"\n          , code "params"\n          , code "success"\n          , code "error"\n          , string $ maybe "text/plain" snd3 mInp\n          , string mOut\n          , maybe (code "undefined") (\\(p, _, f) -> f (code p)) mInp\n          , code "callOpts"\n          , code "this.modifyRequest"\n          ]\n\nresourceLoc :: String -> ApiResource -> String\nresourceLoc ns = ((ns ++ ".prototype.") ++) . locFromLink . resLink\n  where locFromLink (LResource i1 : LAccess [] : LResource i2 : xs) = jsDir (cleanName i1) ++ "." ++ locFromLink (LResource i2 : xs)\n        locFromLink (LResource i : xs) = case locFromLink xs of\n                                          [] -> jsDir $ cleanName i\n                                          ls -> jsDir (cleanName i) ++ ".prototype." ++ ls\n        locFromLink (_ : xs) = locFromLink xs\n        locFromLink [] = ""\n\nmkJsName :: ApiAction -> String\nmkJsName item =\n  case mkFuncParts item of\n    []       -> ""\n    (x : xs) ->\n      let res = x ++ concatMap upFirst xs\n      in if res `elem` reservedWords\n         then res ++ "_"\n         else res\n\njsDir :: [String] -> String\njsDir = concatMap upFirst\n\njsId :: [String] -> String\njsId []       = ""\njsId (x : xs) =\n  let res = x ++ concatMap upFirst xs\n  in if res `elem` reservedWords\n     then res ++ "_"\n     else res\n\n-- | Javascript reserved words in the broadest sense.\n-- Taken from https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Lexical_grammar#Keywords\n\nreservedWords :: [String]\nreservedWords = es6Reserved ++ futureReserved ++ futureReservedStrict ++ oldFutureReserved\n             ++ reservedLiterals\n  where\n    es6Reserved =\n      [ "break", "case", "class", "catch", "const", "continue", "debugger", "default", "delete"\n      , "do", "else", "export", "extends", "finally", "for", "function", "if", "import", "in"\n      , "instanceof", "let", "new", "return", "super", "switch", "this", "throw", "try", "typeof"\n      , "var", "void", "while", "with", "yield"\n      ]\n    futureReserved = ["enum", "await"]\n    futureReservedStrict =\n      [ "implements", "package", "protected", "static", "interface", "private", "public" ]\n    oldFutureReserved =\n      [ "abstract", "boolean", "byte", "char", "double", "final", "float", "goto", "int", "long"\n      , "native", "short", "synchronized", "transient", "volatile"\n      ]\n    reservedLiterals = ["null", "false", "true"]\n\nmkType :: DataType -> (String, String, Code -> Code)\nmkType dt =\n  case dt of\n    String -> ("text", "text/plain", id)\n    XML    -> ("xml" , "text/xml", id)\n    JSON   -> ("json", "text/json", call "JSON.stringify")\n    File   -> ("file", "application/octet-stream", id)\n    Other  -> ("text", "text/plain", id)\n'