b'/*\n* Copyright (C) 2014 The CyanogenMod Project\n*\n* Licensed under the Apache License, Version 2.0 (the "License");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n* http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an "AS IS" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\npackage com.naman14.timber.provider;\n\nimport android.content.ContentValues;\nimport android.content.Context;\nimport android.database.Cursor;\nimport android.database.sqlite.SQLiteDatabase;\n\nimport com.naman14.timber.helpers.MusicPlaybackTrack;\nimport com.naman14.timber.utils.TimberUtils;\n\nimport java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.LinkedList;\n\n/**\n * This keeps track of the music playback and history state of the playback service\n */\npublic class MusicPlaybackState {\n    private static MusicPlaybackState sInstance = null;\n\n    private MusicDB mMusicDatabase = null;\n\n    public MusicPlaybackState(final Context context) {\n        mMusicDatabase = MusicDB.getInstance(context);\n    }\n\n    public static final synchronized MusicPlaybackState getInstance(final Context context) {\n        if (sInstance == null) {\n            sInstance = new MusicPlaybackState(context.getApplicationContext());\n        }\n        return sInstance;\n    }\n\n    public void onCreate(final SQLiteDatabase db) {\n        StringBuilder builder = new StringBuilder();\n        builder.append("CREATE TABLE IF NOT EXISTS ");\n        builder.append(PlaybackQueueColumns.NAME);\n        builder.append("(");\n\n        builder.append(PlaybackQueueColumns.TRACK_ID);\n        builder.append(" LONG NOT NULL,");\n\n        builder.append(PlaybackQueueColumns.SOURCE_ID);\n        builder.append(" LONG NOT NULL,");\n\n        builder.append(PlaybackQueueColumns.SOURCE_TYPE);\n        builder.append(" INT NOT NULL,");\n\n        builder.append(PlaybackQueueColumns.SOURCE_POSITION);\n        builder.append(" INT NOT NULL);");\n\n        db.execSQL(builder.toString());\n\n        builder = new StringBuilder();\n        builder.append("CREATE TABLE IF NOT EXISTS ");\n        builder.append(PlaybackHistoryColumns.NAME);\n        builder.append("(");\n\n        builder.append(PlaybackHistoryColumns.POSITION);\n        builder.append(" INT NOT NULL);");\n\n        db.execSQL(builder.toString());\n    }\n\n    public void onUpgrade(final SQLiteDatabase db, final int oldVersion, final int newVersion) {\n        // this table was created in version 2 so call the onCreate method if we hit that scenario\n        if (oldVersion < 2 && newVersion >= 2) {\n            onCreate(db);\n        }\n    }\n\n    public void onDowngrade(SQLiteDatabase db, int oldVersion, int newVersion) {\n\n        db.execSQL("DROP TABLE IF EXISTS " + PlaybackQueueColumns.NAME);\n        db.execSQL("DROP TABLE IF EXISTS " + PlaybackHistoryColumns.NAME);\n        onCreate(db);\n    }\n\n    public synchronized void saveState(final ArrayList<MusicPlaybackTrack> queue,\n                                       LinkedList<Integer> history) {\n        final SQLiteDatabase database = mMusicDatabase.getWritableDatabase();\n        database.beginTransaction();\n\n        try {\n            database.delete(PlaybackQueueColumns.NAME, null, null);\n            database.delete(PlaybackHistoryColumns.NAME, null, null);\n            database.setTransactionSuccessful();\n        } finally {\n            database.endTransaction();\n        }\n\n        final int NUM_PROCESS = 20;\n        int position = 0;\n        while (position < queue.size()) {\n            database.beginTransaction();\n            try {\n                for (int i = position; i < queue.size() && i < position + NUM_PROCESS; i++) {\n                    MusicPlaybackTrack track = queue.get(i);\n                    ContentValues values = new ContentValues(4);\n\n                    values.put(PlaybackQueueColumns.TRACK_ID, track.mId);\n                    values.put(PlaybackQueueColumns.SOURCE_ID, track.mSourceId);\n                    values.put(PlaybackQueueColumns.SOURCE_TYPE, track.mSourceType.mId);\n                    values.put(PlaybackQueueColumns.SOURCE_POSITION, track.mSourcePosition);\n\n                    database.insert(PlaybackQueueColumns.NAME, null, values);\n                }\n                database.setTransactionSuccessful();\n            } finally {\n                database.endTransaction();\n                position += NUM_PROCESS;\n            }\n        }\n\n        if (history != null) {\n            Iterator<Integer> iter = history.iterator();\n            while (iter.hasNext()) {\n                database.beginTransaction();\n                try {\n                    for (int i = 0; iter.hasNext() && i < NUM_PROCESS; i++) {\n                        ContentValues values = new ContentValues(1);\n                        values.put(PlaybackHistoryColumns.POSITION, iter.next());\n\n                        database.insert(PlaybackHistoryColumns.NAME, null, values);\n                    }\n\n                    database.setTransactionSuccessful();\n                } finally {\n                    database.endTransaction();\n                }\n            }\n        }\n    }\n\n    public ArrayList<MusicPlaybackTrack> getQueue() {\n        ArrayList<MusicPlaybackTrack> results = new ArrayList<>();\n\n        Cursor cursor = null;\n        try {\n            cursor = mMusicDatabase.getReadableDatabase().query(PlaybackQueueColumns.NAME, null,\n                    null, null, null, null, null);\n\n            if (cursor != null && cursor.moveToFirst()) {\n                results.ensureCapacity(cursor.getCount());\n\n                do {\n                    results.add(new MusicPlaybackTrack(cursor.getLong(0), cursor.getLong(1),\n                            TimberUtils.IdType.getTypeById(cursor.getInt(2)), cursor.getInt(3)));\n                } while (cursor.moveToNext());\n            }\n\n            return results;\n        } finally {\n            if (cursor != null) {\n                cursor.close();\n                cursor = null;\n            }\n        }\n    }\n\n    public LinkedList<Integer> getHistory(final int playlistSize) {\n        LinkedList<Integer> results = new LinkedList<>();\n\n        Cursor cursor = null;\n        try {\n            cursor = mMusicDatabase.getReadableDatabase().query(PlaybackHistoryColumns.NAME, null,\n                    null, null, null, null, null);\n\n            if (cursor != null && cursor.moveToFirst()) {\n                do {\n                    int pos = cursor.getInt(0);\n                    if (pos >= 0 && pos < playlistSize) {\n                        results.add(pos);\n                    }\n                } while (cursor.moveToNext());\n            }\n\n            return results;\n        } finally {\n            if (cursor != null) {\n                cursor.close();\n                cursor = null;\n            }\n        }\n    }\n\n    public class PlaybackQueueColumns {\n\n        public static final String NAME = "playbackqueue";\n        public static final String TRACK_ID = "trackid";\n        public static final String SOURCE_ID = "sourceid";\n        public static final String SOURCE_TYPE = "sourcetype";\n        public static final String SOURCE_POSITION = "sourceposition";\n    }\n\n    public class PlaybackHistoryColumns {\n\n        public static final String NAME = "playbackhistory";\n\n        public static final String POSITION = "position";\n    }\n}\n'