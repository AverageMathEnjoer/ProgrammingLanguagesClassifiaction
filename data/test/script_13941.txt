b'{-# LANGUAGE FlexibleContexts #-}\n\nmodule VecInsertionSort (sort) where\n\nimport Control.Monad (unless)\nimport Control.Monad.ST (ST, runST)\nimport Data.Foldable (forM_)\n\nimport qualified Data.Vector.Unboxed as V\nimport qualified Data.Vector.Unboxed.Mutable as M\n\nsort :: [Int] -> [Int]  -- sort on mutable arrays\nsort list = runST $ do\n    let listSize = length list\n    vec <- V.thaw $ V.fromList list :: ST s (M.MVector s Int)\n\n    forM_ [1..listSize - 1] $ \\i -> do\n        let jScan j\n                | j >= 0 = do\n                    cur  <- M.read vec j\n                    next <- M.read vec (j + 1)\n                    unless (cur <= next) $ do M.write vec j next\n                                              M.write vec (j + 1) cur\n                                              jScan (j - 1)\n                | otherwise = return ()\n        jScan (i - 1)\n\n    resVec <- V.freeze vec\n    return $ V.toList resVec\n'