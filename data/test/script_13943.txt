b'{-# LANGUAGE TemplateHaskell #-}\nmodule TreeSitter.Language\n( module TreeSitter.Language\n, module TreeSitter.Symbol\n) where\n\nimport           Data.Ix (Ix)\nimport           Data.List (mapAccumL)\nimport qualified Data.Set as Set\nimport           Data.Traversable (for)\nimport           Data.Word\nimport           Foreign.C.String\nimport           Foreign.Ptr\nimport           Language.Haskell.TH\nimport           Language.Haskell.TH.Syntax\nimport           System.Directory\nimport           System.FilePath.Posix\nimport           TreeSitter.Symbol\n\n-- | A tree-sitter language.\n--\n--   This type is uninhabited and used only for type safety within \'Ptr\' values.\ndata Language\n\nforeign import ccall unsafe "ts_language_symbol_count" ts_language_symbol_count :: Ptr Language -> IO Word32\nforeign import ccall unsafe "ts_language_symbol_name" ts_language_symbol_name :: Ptr Language -> TSSymbol -> IO CString\nforeign import ccall unsafe "ts_language_symbol_type" ts_language_symbol_type :: Ptr Language -> TSSymbol -> IO Int\nforeign import ccall unsafe "ts_language_symbol_for_name" ts_language_symbol_for_name :: Ptr Language -> CString -> Int -> Bool -> IO TSSymbol\n\n-- | TemplateHaskell construction of a datatype for the referenced Language.\nmkSymbolDatatype :: Name -> Ptr Language -> Q [Dec]\nmkSymbolDatatype name language = do\n  symbols <- renameDups . map ((,) . fst <*> uncurry symbolToName) . (++ [(Regular, "ParseError")]) <$> runIO (languageSymbols language)\n  Module _ modName <- thisModule\n  let mkMatch symbolType str = match (conP (Name (OccName str) (NameQ modName)) []) (normalB [e|symbolType|]) []\n  datatype <- dataD (pure []) name [] Nothing (flip normalC [] . mkName . snd <$> symbols)\n    [ derivClause Nothing (map conT [ \'\'Bounded, \'\'Enum, \'\'Eq, \'\'Ix, \'\'Ord, \'\'Show ]) ]\n  symbolInstance <- [d|\n    instance Symbol $(conT name) where\n      symbolType = $(lamCaseE (uncurry mkMatch <$> symbols)) |]\n  pure (datatype : symbolInstance)\n\nrenameDups :: [(a, String)] -> [(a, String)]\nrenameDups = snd . mapAccumL go mempty\n  where go done (ty, name) = let name\' = rename name in (Set.insert name\' done, (ty, name\'))\n          where rename name | name `Set.member` done = rename (name ++ "\'")\n                            | otherwise              = name\n\n-- https://stackoverflow.com/questions/16163948/how-do-i-use-templatehaskells-adddependentfile-on-a-file-relative-to-the-file-b\naddDependentFileRelative :: FilePath -> Q [Dec]\naddDependentFileRelative relativeFile = do\n    currentFilename <- loc_filename <$> location\n    pwd             <- runIO getCurrentDirectory\n\n    let invocationRelativePath = takeDirectory (pwd </> currentFilename) </> relativeFile\n\n    addDependentFile invocationRelativePath\n\n    return []\n\n\nlanguageSymbols :: Ptr Language -> IO [(SymbolType, String)]\nlanguageSymbols language = ts_language_symbol_count language >>= \\ count -> for [0..fromIntegral (pred count)] $ \\ symbol -> do\n  cname <- ts_language_symbol_name language symbol\n  name <- peekCString cname\n  ty <- toEnum <$> ts_language_symbol_type language symbol\n  pure (ty, name)\n'