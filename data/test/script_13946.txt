b'plotDispEsts.DESeqDataSet <- function( object, ymin, CV=FALSE,\n  genecol = "black", fitcol = "red", finalcol = "dodgerblue",\n  legend=TRUE, xlab, ylab, log = "xy", cex = 0.45, ... )\n{\n  if (missing(xlab)) xlab <- "mean of normalized counts"\n  if (missing(ylab)) {\n    if (CV) {\n      ylab <- "coefficient of variation"\n    } else {\n      ylab <- "dispersion"\n    }\n  }\n  \n  px = mcols(object)$baseMean\n  sel = (px>0)\n  px = px[sel]\n\n  # transformation of dispersion into CV or not\n  f <- if (CV) sqrt else I\n  \n  py = f(mcols(object)$dispGeneEst[sel])\n  if(missing(ymin))\n      ymin = 10^floor(log10(min(py[py>0], na.rm=TRUE))-0.1)\n\n  plot(px, pmax(py, ymin), xlab=xlab, ylab=ylab,\n    log=log, pch=ifelse(py<ymin, 6, 20), col=genecol, cex=cex, ... )\n\n  # use a circle over outliers\n  pchOutlier <- ifelse(mcols(object)$dispOutlier[sel],1,16)\n  cexOutlier <- ifelse(mcols(object)$dispOutlier[sel],2*cex,cex)\n  lwdOutlier <- ifelse(mcols(object)$dispOutlier[sel],2,1)\n  if (!is.null(dispersions(object))) {\n    points(px, f(dispersions(object)[sel]), col=finalcol, cex=cexOutlier,\n           pch=pchOutlier, lwd=lwdOutlier)\n  }\n\n  if (!is.null(mcols(object)$dispFit)) {\n    points(px, f(mcols(object)$dispFit[sel]), col=fitcol, cex=cex, pch=16)\n  }\n  \n  if (legend) {\n    legend("bottomright",c("gene-est","fitted","final"),pch=16,\n           col=c(genecol,fitcol,finalcol),bg="white")\n  }\n}\n\n#\' Plot dispersion estimates\n#\'\n#\' A simple helper function that plots the per-gene dispersion\n#\' estimates together with the fitted mean-dispersion relationship.\n#\'\n#\' @docType methods\n#\' @name plotDispEsts\n#\' @rdname plotDispEsts\n#\' @aliases plotDispEsts plotDispEsts,DESeqDataSet-method\n#\' \n#\' @param object a DESeqDataSet, with dispersions estimated\n#\' @param ymin the lower bound for points on the plot, points beyond this\n#\'    are drawn as triangles at ymin\n#\' @param CV logical, whether to plot the asymptotic or biological\n#\' coefficient of variation (the square root of dispersion) on the y-axis.\n#\' As the mean grows to infinity, the square root of dispersion gives\n#\' the coefficient of variation for the counts. Default is \\code{FALSE},\n#\' plotting dispersion.\n#\' @param genecol the color for gene-wise dispersion estimates\n#\' @param fitcol the color of the fitted estimates\n#\' @param finalcol the color of the final estimates used for testing\n#\' @param legend logical, whether to draw a legend\n#\' @param xlab xlab\n#\' @param ylab ylab\n#\' @param log log\n#\' @param cex cex\n#\' @param ... further arguments to \\code{plot}\n#\'\n#\' @author Simon Anders\n#\'\n#\' @examples\n#\' \n#\' dds <- makeExampleDESeqDataSet()\n#\' dds <- estimateSizeFactors(dds)\n#\' dds <- estimateDispersions(dds)\n#\' plotDispEsts(dds)\n#\'\n#\' @export\nsetMethod("plotDispEsts", signature(object="DESeqDataSet"), plotDispEsts.DESeqDataSet)\n\n# Jan 2023 -- single function copied from `geneplotter` to reduce dependency count\n# colors were changed for ease of viewing from red to blue\nplotMA.dataframe <- function( object, ylim = NULL,\n  colNonSig = "gray60", colSig = "blue", colLine = "grey40",\n  log = "x", cex=0.45,\n  xlab="mean of normalized counts", ylab="log fold change",\n  ... ) {\n  if ( !( ncol(object) == 3 & inherits( object[[1]], "numeric" ) & inherits( object[[2]], "numeric" )\n    & inherits( object[[3]], "logical" ) ) ) {\n    stop( "When called with a data.frame, plotMA expects the data frame\n  to have 3 columns, two numeric ones for mean and log fold change,\n  and a logical one for significance.")\n  }\n  colnames(object) <- c( "mean", "lfc", "sig" )\n  object <- subset( object, mean != 0 )\n  py <- object$lfc\n  if ( is.null(ylim) )\n    ylim <- c(-1,1) * quantile(abs(py[is.finite(py)]), probs=0.99) * 1.1\n  plot(object$mean, pmax(ylim[1], pmin(ylim[2], py)),\n       log=log, pch=ifelse(py<ylim[1], 6, ifelse(py>ylim[2], 2, 16)),\n       cex=cex, col=ifelse( object$sig, colSig, colNonSig ), xlab=xlab, ylab=ylab, ylim=ylim, ...)\n  abline( h=0, lwd=4, col=colLine )\n}\n\nplotMA.DESeqDataSet <- function(object, alpha=.1, main="",\n                                xlab="mean of normalized counts", ylim,\n                                colNonSig="gray60", colSig="blue", colLine="grey40",\n                                returnData=FALSE,\n                                MLE=FALSE, ...) {\n    res <- results(object, ...)\n    plotMA.DESeqResults(res, alpha=alpha, main=main, xlab=xlab, ylim=ylim, MLE=MLE)\n}\n\nplotMA.DESeqResults <- function(object, alpha, main="",\n                                xlab="mean of normalized counts", ylim,\n                                colNonSig="gray60", colSig="blue", colLine="grey40",\n                                returnData=FALSE,\n                                MLE=FALSE, ...) {\n\n  sval <- "svalue" %in% names(object)\n\n  if (sval) {\n    test.col <- "svalue"\n  } else {\n    test.col <- "padj"\n  }\n\n  if (MLE) {\n    if (is.null(object$lfcMLE)) {\n      stop("lfcMLE column is not present: you should first run results() with addMLE=TRUE")\n    }\n    lfc.col <- "lfcMLE"\n  } else {\n    lfc.col <- "log2FoldChange"\n  }\n  \n  if (missing(alpha)) {\n    if (sval) {\n      alpha <- 0.005\n      message("thresholding s-values on alpha=0.005 to color points")\n    } else {\n      if (is.null(metadata(object)$alpha)) {\n        alpha <- 0.1\n      } else {\n        alpha <- metadata(object)$alpha\n      }\n    }\n  }\n\n  isDE <- ifelse(is.na(object[[test.col]]), FALSE, object[[test.col]] < alpha)\n  df <- data.frame(mean = object[["baseMean"]],\n                   lfc = object[[lfc.col]],\n                   isDE = isDE)\n\n  if (returnData) {\n    return(df)\n  }\n\n  if (missing(ylim)) {\n    ylim <- NULL\n  }\n\n  plotMA.dataframe(\n    df, ylim=ylim,\n    colNonSig=colNonSig, colSig=colSig, colLine=colLine,\n    xlab=xlab, main=main, ...)\n}\n\n#\' MA-plot from base means and log fold changes\n#\'\n#\' A simple helper function that makes a so-called "MA-plot", i.e. a\n#\' scatter plot of log2 fold changes (on the y-axis) versus the mean of\n#\' normalized counts (on the x-axis).\n#\'\n#\' This function is essentially two lines of code: building a\n#\' \\code{data.frame} and passing this to the \\code{plotMA} method\n#\' for \\code{data.frame}, now copied from the geneplotter package.\n#\' The code was modified in version 1.28 to change from red to blue points\n#\' for better visibility for users with color-blindness. The original plots\n#\' can still be made via the use of \\code{returnData=TRUE} and passing the\n#\' resulting data.frame directly to \\code{geneplotter::plotMA}.\n#\' The code of this function can be seen with:\n#\' \\code{getMethod("plotMA","DESeqDataSet")}\n#\' If the \\code{object} contains a column \\code{svalue} then these\n#\' will be used for coloring the points (with a default \\code{alpha=0.005}).\n#\'\n#\' @docType methods\n#\' @name plotMA\n#\' @rdname plotMA\n#\' @aliases plotMA plotMA,DESeqDataSet-method plotMA,DESeqResults-method\n#\' \n#\' @param object a \\code{DESeqResults} object produced by \\code{\\link{results}};\n#\' or a \\code{DESeqDataSet} processed by \\code{\\link{DESeq}}, or the\n#\' individual functions \\code{\\link{nbinomWaldTest}} or \\code{\\link{nbinomLRT}}\n#\' @param alpha the significance level for thresholding adjusted p-values\n#\' @param main optional title for the plot\n#\' @param xlab optional defaults to "mean of normalized counts"\n#\' @param ylim optional y limits\n#\' @param colNonSig color to use for non-significant data points\n#\' @param colSig color to use for significant data points\n#\' @param colLine color to use for the horizontal (y=0) line\n#\' @param returnData logical, whether to return the data.frame used for plotting\n#\' @param MLE if \\code{betaPrior=TRUE} was used,\n#\' whether to plot the MLE (unshrunken estimates), defaults to FALSE.\n#\' Requires that \\code{\\link{results}} was run with \\code{addMLE=TRUE}.\n#\' Note that the MLE will be plotted regardless of this argument,\n#\' if DESeq() was run with \\code{betaPrior=FALSE}. See \\code{\\link{lfcShrink}}\n#\' for examples on how to plot shrunken log2 fold changes.\n#\' @param ... further arguments passed to \\code{plotMA} if object\n#\' is \\code{DESeqResults} or to \\code{\\link{results}} if object is\n#\' \\code{DESeqDataSet}\n#\'\n#\' @author Michael Love\n#\'\n#\' @examples\n#\'\n#\' dds <- makeExampleDESeqDataSet()\n#\' dds <- DESeq(dds)\n#\' plotMA(dds)\n#\' res <- results(dds)\n#\' plotMA(res)\n#\'\n#\' @importFrom graphics abline\n#\'\n#\' @export\nsetMethod("plotMA", signature(object="DESeqDataSet"), plotMA.DESeqDataSet)\n\n#\' @name plotMA\n#\' @rdname plotMA\n#\' @export\nsetMethod("plotMA", signature(object="DESeqResults"), plotMA.DESeqResults)\n\nplotPCA.DESeqTransform = function(object, intgroup="condition", ntop=500, returnData=FALSE)\n{\n  # calculate the variance for each gene\n  rv <- rowVars(assay(object))\n\n  # select the ntop genes by variance\n  select <- order(rv, decreasing=TRUE)[seq_len(min(ntop, length(rv)))]\n\n  # perform a PCA on the data in assay(x) for the selected genes\n  pca <- prcomp(t(assay(object)[select,]))\n\n  # the contribution to the total variance for each component\n  percentVar <- pca$sdev^2 / sum( pca$sdev^2 )\n\n  if (!all(intgroup %in% names(colData(object)))) {\n    stop("the argument \'intgroup\' should specify columns of colData(dds)")\n  }\n\n  intgroup.df <- as.data.frame(colData(object)[, intgroup, drop=FALSE])\n  \n  # add the intgroup factors together to create a new grouping factor\n  group <- if (length(intgroup) > 1) {\n    factor(apply( intgroup.df, 1, paste, collapse=":"))\n  } else {\n    colData(object)[[intgroup]]\n  }\n\n  # assembly the data for the plot\n  d <- data.frame(PC1=pca$x[,1], PC2=pca$x[,2], group=group, intgroup.df, name=colnames(object))\n\n  if (returnData) {\n    attr(d, "percentVar") <- percentVar[1:2]\n    return(d)\n  }\n  \n  ggplot(data=d, aes_string(x="PC1", y="PC2", color="group")) + geom_point(size=3) + \n    xlab(paste0("PC1: ",round(percentVar[1] * 100),"% variance")) +\n      ylab(paste0("PC2: ",round(percentVar[2] * 100),"% variance")) +\n        coord_fixed()\n}\n\n#\' Sample PCA plot for transformed data\n#\' \n#\' This plot helps to check for batch effects and the like. \n#\'\n#\' @docType methods\n#\' @name plotPCA\n#\' @rdname plotPCA\n#\' @aliases plotPCA plotPCA,DESeqTransform-method\n#\'\n#\' @param object a \\code{\\link{DESeqTransform}} object, with data in \\code{assay(x)},\n#\' produced for example by either \\code{\\link{rlog}} or\n#\' \\code{\\link{varianceStabilizingTransformation}}.\n#\' @param intgroup interesting groups: a character vector of\n#\' names in \\code{colData(x)} to use for grouping\n#\' @param ntop number of top genes to use for principal components,\n#\' selected by highest row variance\n#\' @param returnData should the function only return the data.frame of PC1 and PC2\n#\' with intgroup covariates for custom plotting (default is FALSE)\n#\' \n#\' @return An object created by \\code{ggplot}, which can be assigned and further customized.\n#\' \n#\' @author Wolfgang Huber\n#\'\n#\' @note See the vignette for an example of variance stabilization and PCA plots.\n#\' Note that the source code of \\code{plotPCA} is very simple.\n#\' The source can be found by typing \\code{DESeq2:::plotPCA.DESeqTransform}\n#\' or \\code{getMethod("plotPCA","DESeqTransform")}, or\n#\' browsed on github at \\url{https://github.com/mikelove/DESeq2/blob/master/R/plots.R}\n#\' Users should find it easy to customize this function.\n#\' \n#\' @examples\n#\'\n#\' # using rlog transformed data:\n#\' dds <- makeExampleDESeqDataSet(betaSD=1)\n#\' rld <- rlog(dds)\n#\' plotPCA(rld)\n#\'\n#\' # also possible to perform custom transformation:\n#\' dds <- estimateSizeFactors(dds)\n#\' # shifted log of normalized counts\n#\' se <- SummarizedExperiment(log2(counts(dds, normalized=TRUE) + 1),\n#\'                            colData=colData(dds))\n#\' # the call to DESeqTransform() is needed to\n#\' # trigger our plotPCA method.\n#\' plotPCA( DESeqTransform( se ) )\n#\'\n#\' @importFrom ggplot2 ggplot geom_point xlab ylab coord_fixed aes_string\n#\' @export\nsetMethod("plotPCA", signature(object="DESeqTransform"), plotPCA.DESeqTransform)\n\n#\' Plot of normalized counts for a single gene\n#\'\n#\' Normalized counts plus a pseudocount of 0.5 are shown by default.\n#\' \n#\' @param dds a \\code{DESeqDataSet}\n#\' @param gene a character, specifying the name of the gene to plot\n#\' @param intgroup interesting groups: a character vector of names in \\code{colData(x)} to use for grouping.\n#\' Must be factor variables. If you want to plot counts over numeric, choose \\code{returnData=TRUE}\n#\' @param normalized whether the counts should be normalized by size factor\n#\' (default is TRUE)\n#\' @param transform whether to have log scale y-axis or not.\n#\' defaults to TRUE\n#\' @param main as in \'plot\'\n#\' @param xlab as in \'plot\'\n#\' @param returnData should the function only return the data.frame of counts and\n#\' covariates for custom plotting (default is FALSE)\n#\' @param replaced use the outlier-replaced counts if they exist\n#\' @param pc pseudocount for log transform\n#\' @param ... arguments passed to plot\n#\' \n#\' @examples\n#\'\n#\' dds <- makeExampleDESeqDataSet()\n#\' plotCounts(dds, "gene1")\n#\' \n#\' @export\nplotCounts <- function(dds, gene, intgroup="condition",\n                       normalized=TRUE, transform=TRUE,\n                       main, xlab="group",\n                       returnData=FALSE,\n                       replaced=FALSE,\n                       pc, ...) {\n\n  stopifnot(length(gene) == 1 & (is.character(gene) | (is.numeric(gene) & (gene >= 1 & gene <= nrow(dds)))))\n  if (!all(intgroup %in% names(colData(dds)))) stop("all variables in \'intgroup\' must be columns of colData")\n  if (!returnData) {\n    if (!all(sapply(intgroup, function(v) is(colData(dds)[[v]], "factor")))) {\n      stop("all variables in \'intgroup\' should be factors, or choose returnData=TRUE and plot manually")\n    }\n  }\n      \n\n  if (missing(pc)) {\n    pc <- if (transform) 0.5 else 0\n  }\n  \n  if (is.null(sizeFactors(dds)) & is.null(normalizationFactors(dds))) {\n    dds <- estimateSizeFactors(dds)\n  }\n  cnts <- counts(dds,normalized=normalized,replaced=replaced)[gene,]\n  group <- if (length(intgroup) == 1) {\n    colData(dds)[[intgroup]]\n  } else if (length(intgroup) == 2) {\n    lvls <- as.vector(t(outer(levels(colData(dds)[[intgroup[1]]]),\n                              levels(colData(dds)[[intgroup[2]]]),\n                              function(x,y) paste(x,y,sep=":"))))\n    droplevels(factor(apply( as.data.frame(colData(dds)[, intgroup, drop=FALSE]),\n                            1, paste, collapse=":"), levels=lvls))\n  } else {\n    factor(apply( as.data.frame(colData(dds)[, intgroup, drop=FALSE]),\n                 1, paste, collapse=":"))\n  }\n  data <- data.frame(count=cnts + pc, group=as.integer(group))\n  logxy <- if (transform) "y" else "" \n  if (missing(main)) {\n    main <- if (is.numeric(gene)) {\n      rownames(dds)[gene]\n    } else {\n      gene\n    }\n  }\n  ylab <- ifelse(normalized,"normalized count","count")\n  if (returnData) return(data.frame(count=data$count, colData(dds)[intgroup]))\n  plot(data$group + runif(ncol(dds),-.05,.05), data$count, xlim=c(.5,max(data$group)+.5),\n       log=logxy, xaxt="n", xlab=xlab, ylab=ylab, main=main, ...)\n  axis(1, at=seq_along(levels(group)), levels(group))\n}\n\n\n#\' Sparsity plot\n#\'\n#\' A simple plot of the concentration of counts in a single sample over the\n#\' sum of counts per gene. Not technically the same as "sparsity", but this\n#\' plot is useful diagnostic for datasets which might not fit a negative\n#\' binomial assumption: genes with many zeros and individual very large\n#\' counts are difficult to model with the negative binomial distribution.\n#\'\n#\' @param x a matrix or DESeqDataSet\n#\' @param normalized whether to normalize the counts from a DESeqDataSEt\n#\' @param ... passed to \\code{plot}\n#\'\n#\' @examples\n#\'\n#\' dds <- makeExampleDESeqDataSet(n=1000,m=4,dispMeanRel=function(x) .5)\n#\' dds <- estimateSizeFactors(dds)\n#\' plotSparsity(dds)\n#\' \n#\' @export\nplotSparsity <- function(x, normalized=TRUE, ...) {\n  if (is(x, "DESeqDataSet")) {\n    x <- counts(x, normalized=normalized)\n  }\n  rs <- rowSums(x)\n  rmx <- apply(x, 1, max)\n  plot(rs[rs > 0], (rmx/rs)[rs > 0], log="x", ylim=c(0,1), xlab="sum of counts per gene",\n       ylab="max count / sum", main="Concentration of counts over total sum of counts", ...)\n}\n\n# convenience function for adding alpha transparency to named colors\n## col2useful <- function(col,alpha) {\n##   x <- col2rgb(col)/255\n##   rgb(x[1],x[2],x[3],alpha)\n## }\n'