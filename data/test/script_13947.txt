b'module Code.Build.JavaScript where\n\nimport Code.Build\nimport Data.List\n\njsObject :: [(String, Code)] -> Code\njsObject [] = code "{}"\njsObject items = ("{ " <-> many ", ") |><| mkStack (map fst items) |><| many ": " |>+<| map snd items <-> "}"\n\nstatements :: CodeList a => a -> Code\nstatements = mkStack . codeList\n\nblock :: CodeList a => a -> Code\nblock c = "{" <-> indent 2 (statements c) <-> "}"\n\njsIf :: (Codeable a, CodeList b) => a -> b -> Code\njsIf cond blk = "if" <++> parenthesis cond <-> block blk\n\njsElse :: CodeList a => a -> Code\njsElse blk = "else" <-> block blk\n\nfor :: (Codeable a, CodeList b) => a -> b -> Code\nfor cond blk = "for" <++> parenthesis cond <-> block blk\n\nfunction :: CodeList a => [String] -> a -> Code\nfunction pars body = "function" <++> parenthesis (intercalate ", " pars) <-> block body\n\nfunctionDecl :: CodeList a => String -> [String] -> a -> Code\nfunctionDecl name pars body = "function" <++> name <++> parenthesis (intercalate ", " pars) <-> block body\n\ncall :: CodeList a => String -> a -> Code\ncall func as | all singleLine (codeList as) = func <+> parenthesis (interleave ", " $ codeList as)\n             | otherwise                    = func <+| (("( " <-> many ", ") |>+<| as) <+> ")"\n\nproc :: CodeList a => String -> a -> Code\nproc f a = call f a <+> ";"\n\nret :: Codeable a => a -> Code\nret a = "return " <+| a <+> ";"\n\nstring :: Codeable a => a -> Code\nstring = surround "\\"" "\\""\n\nnew :: Codeable a => String -> a ->  Code\nnew clas c = "new" <++> clas <+| parenthesis c\n\nvar :: Codeable a => String -> a -> Code\nvar n c | singleLine (code c) = "var " <+> n <+> " = " <+| c <+> ";"\n        | otherwise           = "var " <+> n <+> " =" <-> indent 2 c <+> ";"\n\ninfix 2 .=.\n\n(.=.) :: Codeable b => String -> b -> Code\nv .=. c | singleLine (code c) = v <+> " = " <+| c <+> ";"\n        | otherwise           = v <+> " =" <-> indent 2 c <+> ";"\n'