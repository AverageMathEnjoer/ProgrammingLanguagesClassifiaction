b'{-# LANGUAGE OverloadedStrings #-}\n\nmodule Hoodle.Util where\n\nimport Control.Applicative ((<|>))\nimport Control.Monad (void)\nimport Control.Monad.IO.Class (MonadIO (liftIO))\nimport Control.Monad.Trans.Maybe (MaybeT (..))\nimport Data.Attoparsec.ByteString.Char8\n  ( anyChar,\n    endOfInput,\n    inClass,\n    manyTill,\n    parseOnly,\n    satisfy,\n    string,\n    try,\n  )\nimport qualified Data.ByteString.Char8 as B\nimport Data.Functor (($>))\nimport Data.Hoodle.Simple\n  ( Dimension (..),\n    Hoodle (..),\n    Page (..),\n  )\nimport Data.Maybe (fromMaybe, listToMaybe)\nimport Data.Time.Clock (getCurrentTime)\nimport Data.Time.Format\n  ( defaultTimeLocale,\n    formatTime,\n  )\nimport Data.UUID.V4 (nextRandom)\nimport Network.URI (unEscapeString)\nimport System.Directory\n  ( createDirectoryIfMissing,\n    getTemporaryDirectory,\n  )\nimport System.Environment (getEnv)\nimport System.FilePath ((<.>), (</>))\nimport System.IO\n  ( IOMode (AppendMode),\n    hClose,\n    hPutStr,\n    hPutStrLn,\n    openFile,\n  )\n\n(#) :: a -> (a -> b) -> b\n(#) = flip ($)\n\ninfixr 0 #\n\nmaybeFlip :: Maybe a -> b -> (a -> b) -> b\nmaybeFlip m n j = maybe n j m\n\nmaybeRead :: Read a => String -> Maybe a\nmaybeRead = fmap fst . listToMaybe . reads\n\nrunMaybeT_ :: (Monad m) => MaybeT m a -> m ()\nrunMaybeT_ m = void (runMaybeT m)\n\nfromJustError :: String -> Maybe a -> a\nfromJustError _ (Just x) = x\nfromJustError err Nothing = error err\n\neither_ :: (Monad m) => (b -> m ()) -> Either a b -> m ()\neither_ = either (const (return ()))\n\nuncurry4 :: (a -> b -> c -> d -> e) -> (a, b, c, d) -> e\nuncurry4 f (x, y, z, w) = f x y z w\n\ngetLargestWidth :: Hoodle -> Double\ngetLargestWidth hdl =\n  let ws = map (dim_width . page_dim) (hoodle_pages hdl)\n   in maximum ws\n\ngetLargestHeight :: Hoodle -> Double\ngetLargestHeight hdl =\n  let hs = map (dim_height . page_dim) (hoodle_pages hdl)\n   in maximum hs\n\nwaitUntil :: (Monad m) => (a -> Bool) -> m a -> m ()\nwaitUntil p act = do\n  a <- act\n  if p a\n    then return ()\n    else waitUntil p act\n\n-- | for debugging\nerrorlog :: String -> IO ()\nerrorlog str = do\n  homepath <- getEnv "HOME"\n  let dir = homepath </> ".hoodle.d"\n  createDirectoryIfMissing False dir\n  outh <- openFile (dir </> "error.log") AppendMode\n  utctime <- getCurrentTime\n  let timestr = formatTime defaultTimeLocale "%F %H:%M:%S %Z" utctime\n  hPutStr outh (timestr ++ " : ")\n  hPutStrLn outh str\n  hClose outh\n\n-- | for debugging\nmsgShout :: (MonadIO m) => String -> m ()\nmsgShout = liftIO . putStrLn\n\n-- |\nmaybeError\' :: String -> Maybe a -> a\nmaybeError\' str = fromMaybe (error str)\n\ndata UrlPath = FileUrl FilePath | HttpUrl String\n  deriving (Show, Eq)\n\ndata T = N | F | H | HS deriving (Show, Eq)\n\n-- |\nurlParse :: String -> Maybe UrlPath\nurlParse str =\n  if length str < 7\n    then Just (FileUrl str)\n    else\n      let p = do\n            b <-\n              try (string "file://" $> F)\n                <|> try (string "http://" $> H)\n                <|> try (string "https://" $> HS)\n                <|> return N\n            remaining <- manyTill anyChar ((satisfy (inClass "\\r\\n") $> ()) <|> endOfInput)\n            return (b, remaining)\n          r = parseOnly p (B.pack str)\n       in case r of\n            Left _ -> Nothing\n            Right (b, f) -> case b of\n              N -> Just (FileUrl f)\n              F -> Just (FileUrl (unEscapeString f))\n              H -> Just (HttpUrl ("http://" ++ f))\n              HS -> Just (HttpUrl ("https://" ++ f))\n\n-- |\nmkTmpFile :: String -> IO FilePath\nmkTmpFile ext = do\n  tdir <- getTemporaryDirectory\n  tuuid <- nextRandom\n  return $ tdir </> show tuuid <.> ext\n'