b'{-# LANGUAGE BangPatterns #-}\n{-# LANGUAGE NumericUnderscores #-}\n{-# LANGUAGE OverloadedLabels #-}\n{-# LANGUAGE OverloadedStrings #-}\n\nmodule Main where\n\nimport Control.Concurrent (forkIO, threadDelay)\nimport Control.Concurrent.STM (TVar, atomically, modifyTVar\', newTVarIO, readTVar)\nimport qualified Control.Exception as E\nimport Control.Lens ((%~), (.~), (^.))\nimport Control.Monad (forever)\nimport qualified Data.ByteString as BS\nimport qualified Data.ByteString.Lazy as BL\nimport Data.Fixed (Fixed (MkFixed))\nimport Data.Foldable (toList)\nimport Data.GI.Base (AttrOp ((:=)), new, on)\nimport Data.GI.Gtk.Threading (postGUIASync)\nimport qualified Data.List as L (foldl\')\nimport Data.Maybe (fromMaybe)\nimport Data.Sequence ((|>))\nimport qualified Data.Sequence as Seq (empty)\nimport GHC.RTS.Events (Event (..))\nimport GHC.RTS.Events.Incremental\n  ( Decoder (..),\n    decodeEvents,\n    readHeader,\n  )\nimport qualified GI.Cairo.Render as R\nimport GI.Cairo.Render.Connector (renderWithContext)\nimport qualified GI.Gtk as Gtk\nimport Network.Socket\n  ( Family (AF_UNIX),\n    SockAddr (SockAddrUnix),\n    Socket,\n    SocketType (Stream),\n    close,\n    connect,\n    socket,\n    withSocketsDo,\n  )\nimport Network.Socket.ByteString (recv)\nimport Render\n  ( canvasHeight,\n    canvasWidth,\n    drawLogcatState,\n    flushDoubleBuffer,\n    pixelToSec,\n    secToPixel,\n    timelineMargin,\n  )\nimport System.IO (hFlush, stdout)\nimport Text.Pretty.Simple (pPrint)\nimport Types\n  ( HasLogcatState (..),\n    HasViewState (..),\n    LogcatState,\n    emptyLogcatState,\n  )\nimport Util.Event (eventInfoToString)\nimport Util.Histo (aggregateCount, histoAdd)\n\nrecordEvent :: TVar LogcatState -> Event -> IO ()\nrecordEvent sref ev =\n  atomically $ do\n    ltime <- (^. logcatLastEventTime) <$> readTVar sref\n    let sec = MkFixed (fromIntegral (evTime ev))\n        updateLastEventTime =\n          if sec > ltime\n            then logcatLastEventTime .~ sec\n            else id\n    modifyTVar\' sref ((logcatEventQueue %~ (|> ev)) . updateLastEventTime)\n\n-- | Adjust timeline viewport to ensure the last event is out of the right margin\n-- of the timeline. This checks if the last event falls under the margin, and if so,\n-- move the plot origin to make the last event at the center of the timeline.\nadjustTimelineOrigin :: LogcatState -> LogcatState\nadjustTimelineOrigin s\n  | ltimePos > canvasWidth - timelineMargin =\n    let currCenterTime = pixelToSec origin (canvasWidth * 0.5)\n        deltaTime = ltime - currCenterTime\n     in (logcatViewState . viewTimeOrigin %~ (\\x -> x + deltaTime)) s\n  | otherwise = s\n  where\n    origin = s ^. logcatViewState . viewTimeOrigin\n    ltime = s ^. logcatLastEventTime\n    ltimePos = secToPixel origin ltime\n\nflushEventQueue :: R.Surface -> TVar LogcatState -> IO ()\nflushEventQueue sfc sref = do\n  atomically $ do\n    s <- readTVar sref\n    let queue = s ^. logcatEventQueue\n        hist = s ^. logcatEventHisto\n        diff = aggregateCount $ fmap (eventInfoToString . evSpec) $ toList queue\n        hist\' = L.foldl\' histoAdd hist diff\n    modifyTVar\' sref $\n      (logcatEventStore %~ (<> queue))\n        . (logcatEventQueue .~ Seq.empty)\n        . (logcatEventHisto .~ hist\')\n        . adjustTimelineOrigin\n  R.renderWith sfc $ do\n    drawLogcatState sref\n\ndump :: TVar LogcatState -> Socket -> IO ()\ndump sref sock = goHeader ""\n  where\n    goHeader bs0 = do\n      bs1 <- recv sock 1024\n      let bs = bs0 <> bs1\n      let lbs = BL.fromStrict bs\n      let e = readHeader lbs\n      case e of\n        Left err -> print err >> goHeader bs\n        Right (hdr, lbs\') -> do\n          pPrint hdr\n          let dec0 = decodeEvents hdr\n          goEvents hdr dec0 (BL.toStrict lbs\')\n\n    go :: Decoder Event -> BS.ByteString -> IO (Maybe (Decoder Event), BS.ByteString)\n    go dec !bytes = do\n      case dec of\n        Produce ev dec\' -> do\n          recordEvent sref ev\n          hFlush stdout\n          go dec\' bytes\n        Consume k ->\n          if BS.null bytes\n            then pure (Just dec, "")\n            else go (k bytes) ""\n        Done bytes\' ->\n          pure (Nothing, bytes\')\n        Error _bytes\' e -> do\n          pPrint e\n          hFlush stdout\n          -- reset if error happens.\n          pure (Nothing, "")\n\n    goEvents hdr dec !bytes = do\n      (mdec\', bytes\') <- go dec bytes\n      let dec\' = fromMaybe (decodeEvents hdr) mdec\'\n      bytes\'\' <- recv sock 1024\n      goEvents hdr dec\' (bytes\' <> bytes\'\')\n\ntickTock :: Gtk.DrawingArea -> R.Surface -> TVar LogcatState -> IO ()\ntickTock drawingArea sfc sref = forever $ do\n  threadDelay 1_000_000\n  flushEventQueue sfc sref\n  postGUIASync $\n    #queueDraw drawingArea\n\nmain :: IO ()\nmain = do\n  sref <- newTVarIO emptyLogcatState\n  _ <- Gtk.init Nothing\n  -- NOTE: this should be closed with surfaceDestroy\n  sfc <- R.createImageSurface R.FormatARGB32 (floor canvasWidth) (floor canvasHeight)\n  mainWindow <- new Gtk.Window [#type := Gtk.WindowTypeToplevel]\n  drawingArea <- new Gtk.DrawingArea []\n  _ <- drawingArea `on` #draw $\n    renderWithContext $ do\n      flushDoubleBuffer sfc\n      pure True\n  layout <- do\n    vbox <- new Gtk.Box [#orientation := Gtk.OrientationVertical, #spacing := 0]\n    #packStart vbox drawingArea True True 0\n    pure vbox\n  #add mainWindow layout\n  #setDefaultSize mainWindow (floor canvasWidth) (floor canvasHeight)\n  #showAll mainWindow\n\n  _ <- forkIO $ tickTock drawingArea sfc sref\n  _ <- forkIO $ receiver sref\n  Gtk.main\n  R.surfaceFinish sfc\n\nreceiver :: TVar LogcatState -> IO ()\nreceiver sref =\n  withSocketsDo $ do\n    let file = "/tmp/eventlog.sock"\n        open = do\n          sock <- socket AF_UNIX Stream 0\n          connect sock (SockAddrUnix file)\n          pure sock\n    E.bracket open close (dump sref)\n    pure ()\n'