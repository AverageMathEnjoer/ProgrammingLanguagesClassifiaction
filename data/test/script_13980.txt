b"module Network.Server.TicTacToe.Loop where\n\nimport Control.Applicative (Applicative, pure)\nimport Control.Concurrent (forkIO)\nimport Control.Exception (Exception, catch, finally, try)\nimport Control.Monad (liftM)\nimport Control.Monad (forever)\nimport Control.Monad.Trans (MonadIO(..), MonadTrans(..))\nimport Data.Foldable (Foldable, mapM_)\nimport Data.IORef (IORef, newIORef, readIORef)\nimport Data.Set (Set)\nimport qualified Data.Set as S\nimport Prelude hiding (mapM_)\nimport System.IO (BufferMode(..))\n\nimport Network (PortID(..), listenOn, sClose, withSocketsDo)\nimport Network.Server.Common.Accept\nimport Network.Server.Common.Env\nimport Network.Server.Common.HandleLens\nimport Network.Server.Common.Lens\nimport Network.Server.Common.Line\nimport Network.Server.Common.Ref\n\ndata Loop v s f a =\n  Loop (Env v -> s -> f (a, s))\n\ntype IOLoop v s a = Loop v s IO a\n\ntype IORefLoop v s a = IOLoop (IORef v) s a\n\nexecLoop :: Functor f => Loop v s f a -> Env v -> s -> f a\nexecLoop (Loop l) e = fmap fst . l e\n\ninitLoop :: Functor f => (Env v -> f a) -> Loop v s f a\ninitLoop f = Loop $ \\env s -> fmap (\\a -> (a, s)) . f $ env\n\ninstance Functor f => Functor (Loop v s f) where\n  fmap f (Loop k) = Loop (\\env -> fmap (\\(a, t) -> (f a, t)) . k env)\n\ninstance Applicative f => Applicative (Loop v s f) where\n  pure = undefined\n  (<*>) = undefined\n\ninstance Monad f => Monad (Loop v s f) where\n  return a = Loop $ \\_ s -> return (a, s)\n  Loop k >>= f =\n    Loop\n      (\\env s ->\n         k env s >>= \\(a, t) ->\n           let Loop l = f a\n            in l env t)\n\ninstance MonadTrans (Loop v s) where\n  lift x = Loop (\\_ s -> liftM (\\a -> (a, s)) x)\n\ninstance MonadIO f => MonadIO (Loop v s f) where\n  liftIO = lift . liftIO\n\netry :: Exception e => (Env v -> IO a) -> IOLoop v s (Either e a)\netry k = initLoop $ try . k\n\nserver ::\n     IO w -- server initialise\n  -> (w -> IO v) -- client accepted (pre)\n  -> s -- initial state\n  -> IOLoop v s () -- per-client\n  -> IO a\nserver i r t l =\n  let hand s w c =\n        forever $ do\n          q <- accept' s\n          lSetBuffering q NoBuffering\n          _ <- atomicModifyIORef_ c (S.insert (refL `getL` q))\n          x <- r w\n          forkIO (execLoop l (Env q c x) t)\n   in withSocketsDo $ do\n        s <- listenOn (PortNumber 6060)\n        w <- i\n        c <- newIORef S.empty\n        hand s w c `finally` sClose s\n\nperClient ::\n     IOLoop v s x -- client accepted (post)\n  -> (String -> IOLoop v s a) -- read line from client\n  -> IOLoop v s ()\nperClient q f =\n  let lp = do\n        k <- etry lGetLine\n        case k of\n          Left e -> xprint e\n          Right [] -> lp\n          Right l -> f l >> lp\n   in do _ <- q\n         lp\n\nloop ::\n     IO w -- server initialise\n  -> (w -> IO v) -- client accepted (pre)\n  -> s -- initial state\n  -> IOLoop v s x -- client accepted (post)\n  -> (String -> IOLoop v s w) -- read line from client\n  -> IO a\nloop i r s q f = server i r s (perClient q f)\n\niorefServer ::\n     v -- server initialise\n  -> s -- initial state\n  -> IORefLoop v s () -- per-client\n  -> IO a\niorefServer x s = server (newIORef x) return s\n\niorefLoop ::\n     v -- server initialise\n  -> s -- initial state\n  -> IORefLoop v s x -- client accepted (post)\n  -> (String -> IORefLoop v s w) -- read line from client\n  -> IO a\niorefLoop x s q f = iorefServer x s (perClient q f)\n\npPutStrLn :: String -> IOLoop v s ()\npPutStrLn s = initLoop (`lPutStrLn` s)\n\n(!) :: Foldable t => IOLoop v s (t Ref) -> String -> IOLoop v s ()\nclients !msg = clients >>= purgeClients (\\y -> liftIO (lPutStrLn y msg))\n\ninfixl 2 !\n\npurgeClients :: Foldable t => (Ref -> IOLoop s v ()) -> t Ref -> IOLoop s v ()\npurgeClients a =\n  mapM_\n    (\\y ->\n       ecatch\n         (a y)\n         (\\x -> do\n            _ <- modifyClients (S.delete y)\n            xprint x))\n\nreadEnv :: Applicative f => Loop v s f (Env v)\nreadEnv = initLoop $ pure\n\nreadEnvval :: Applicative f => Loop v s f v\nreadEnvval = fmap (envvalL `getL`) readEnv\n\nreadIOEnvval :: IORefLoop a s a\nreadIOEnvval = initLoop $ \\env -> readIORef (envvalL `getL` env)\n\nallClientsButThis :: IOLoop v s (Set Ref)\nallClientsButThis =\n  initLoop $ \\env ->\n    fmap\n      (S.delete ((acceptL .@ refL) `getL` env))\n      (readIORef (clientsL `getL` env))\n\n-- Control.Monad.CatchIO\necatch :: Exception e => IOLoop v s a -> (e -> IOLoop v s a) -> IOLoop v s a\necatch (Loop k) f =\n  Loop $ \\env s ->\n    k env s `catch`\n    (\\e ->\n       let Loop l = f e\n        in l env s)\n\nmodifyClients :: (Set Ref -> Set Ref) -> IOLoop v s (Set Ref)\nmodifyClients f = initLoop $ \\env -> atomicModifyIORef_ (clientsL `getL` env) f\n"