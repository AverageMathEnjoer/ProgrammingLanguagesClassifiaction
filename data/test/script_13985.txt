b'// I2Cdev library collection - MYDEVSTUB I2C device class\n// Based on [Manufacturer Name] MYDEVSTUB datasheet, [datasheet date]\n// [current release date] by [Author Name] <[Author Email]>\n// Updates should (hopefully) always be available at https://github.com/jrowberg/i2cdevlib\n//\n// Changelog:\n//     [YYYY-mm-dd] - updated some broken thing\n//     [YYYY-mm-dd] - initial release\n\n/* ============================================\nI2Cdev device library code is placed under the MIT license\nCopyright (c) 2011 [Author Name], Jeff Rowberg\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the "Software"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n===============================================\n*/\n\n#include "MYDEVSTUB.h"\n\n// ============================================================================\n// DEVICE LIBRARY CONVENTIONS:\n//\n// 1. The class name should be the same as the device model if at all possible.\n//    No spaces or hyphens, and ideally no underlines unless they\'re absolutely\n//    necessary for clarity. ALL CAPS for model numbers, or FirstInitial caps\n//    for full names. For example:\n//      - ADXL345\n//      - MPU6050\n//      - TCA6424A\n//      - PanelPilot\n//\n// 2. All #defines should use a device-specific prefix that is the same as the\n//    all-caps version of the class name ("MYDEVSTUB_" in this example).\n//\n// 3. All #defines should be ALL CAPS, no matter what. This makes them clearly\n//    distinctive from variables, classes, and functions.\n//\n// 4. Class methods and member variables should be named using camelCaps.\n//\n// 5. Every device class should contain an "initialize()" method which takes\n//    no parameters and resets any important settings back to a known state,\n//    ideally the defaults outlined in the datasheet. Some devices have a\n//    RESET command available, which may be suitable. Some devices may not\n//    require any specific initialization, but an empty method should be\n//    created for consistency anyway.\n//\n// 6. Every device class should contain a "testConnection()" method which\n//    returns TRUE if the device appears to be connected, or FALSE otherwise.\n//    If a known ID register or device code is available, check for that. Since\n//    such an ID register is not always available, at least check to make sure\n//    that an I2C read may be performed on a specific register and that data\n//    does actually come back (the I2Cdev class returns a "bytes read" value\n//    for all read operations).\n//\n// 7. All class methods should be documented with useful information in Doxygen\n//    format. You can take the info right out of the datasheet if you want to,\n//    since that\'s likely to be helpful. Writing your own info is fine as well.\n//    The goal is to have enough clear documentation right in the code that\n//    someone can determine how the device works by studying the code alone.\n//\n// ============================================================================\n\n/* ============================================================================\n   I2Cdev Class Quick Primer:\n\n   The I2Cdev class provides simple methods for reading and writing from I2C\n   device registers without messing with the underlying TWI/I2C functions. You\n   just specify the device address, register address, and source or destination\n   data according to which action you are doing. Here is the list of relevant\n   function prototypes from the I2Cdev class (more info in the .cpp/.h files):\n\n    static int8_t readBit(uint8_t devAddr, uint8_t regAddr, uint8_t bitNum, uint8_t *data, uint16_t timeout=I2Cdev::readTimeout);\n    static int8_t readBitW(uint8_t devAddr, uint8_t regAddr, uint8_t bitNum, uint16_t *data, uint16_t timeout=I2Cdev::readTimeout);\n    static int8_t readBits(uint8_t devAddr, uint8_t regAddr, uint8_t bitStart, uint8_t length, uint8_t *data, uint16_t timeout=I2Cdev::readTimeout);\n    static int8_t readBitsW(uint8_t devAddr, uint8_t regAddr, uint8_t bitStart, uint8_t length, uint16_t *data, uint16_t timeout=I2Cdev::readTimeout);\n    static int8_t readByte(uint8_t devAddr, uint8_t regAddr, uint8_t *data, uint16_t timeout=I2Cdev::readTimeout);\n    static int8_t readWord(uint8_t devAddr, uint8_t regAddr, uint16_t *data, uint16_t timeout=I2Cdev::readTimeout);\n    static int8_t readBytes(uint8_t devAddr, uint8_t regAddr, uint8_t length, uint8_t *data, uint16_t timeout=I2Cdev::readTimeout);\n    static int8_t readWords(uint8_t devAddr, uint8_t regAddr, uint8_t length, uint16_t *data, uint16_t timeout=I2Cdev::readTimeout);\n\n    static bool writeBit(uint8_t devAddr, uint8_t regAddr, uint8_t bitNum, uint8_t data);\n    static bool writeBitW(uint8_t devAddr, uint8_t regAddr, uint8_t bitNum, uint16_t data);\n    static bool writeBits(uint8_t devAddr, uint8_t regAddr, uint8_t bitStart, uint8_t length, uint8_t data);\n    static bool writeBitsW(uint8_t devAddr, uint8_t regAddr, uint8_t bitStart, uint8_t length, uint16_t data);\n    static bool writeByte(uint8_t devAddr, uint8_t regAddr, uint8_t data);\n    static bool writeWord(uint8_t devAddr, uint8_t regAddr, uint16_t data);\n    static bool writeBytes(uint8_t devAddr, uint8_t regAddr, uint8_t length, uint8_t *data);\n    static bool writeWords(uint8_t devAddr, uint8_t regAddr, uint8_t length, uint16_t *data);\n\n   Note that ALL OF THESE METHODS ARE STATIC. No I2Cdev object is needed; just\n   use the static class methods.\n   \n   Also note that the first two parameters of every one of these methods are\n   the same: "devAddr" and "regAddr". For every method, you need to specify the\n   target/slave address and the register address.\n   \n   If your device uses 8-bit registers, you will want to use the following:\n       readBit, readBits, readByte, readBytes\n       writeBit, writeBits, writeByte, writeBytes\n       \n   ...but if it uses 16-bit registers, you will want to use these instead:\n       readBitW, readBitsW, readWord, readWords\n       writeBitW, writeBitsW, writeWord, writeWords\n       \n   Here\'s a sample of how to use a few of the methods. Note that in each case, \n   the "buffer" variable is a uint8_t array or pointer, and the "value" variable\n   (in three of the write examples) is a uint8_t single byte. The multi-byte\n   write methods still require an array or pointer.\n\n       READ 1 BIT FROM DEVICE 0x68, REGISTER 0x02, BIT POSITION 4\n       bytesRead = I2Cdev::readBit(0x68, 0x02, 4, buffer);\n\n       READ 3 BITS FROM DEVICE 0x68, REGISTER 0x02, BIT POSITION 4\n       bytesRead = I2Cdev::readBits(0x68, 0x02, 4, 3, buffer);\n\n       READ 1 BYTE FROM DEVICE 0x68, REGISTER 0x02\n       bytesRead = I2Cdev::readByte(0x68, 0x02, buffer);\n\n       READ 2 BYTES FROM DEVICE 0x68, REGISTER 0x02 (AND 0x03 FOR 2ND BYTE)\n       bytesRead = I2Cdev::readBytes(0x68, 0x02, 2, buffer);\n\n       WRITE 1 BIT TO DEVICE 0x68, REGISTER 0x02, BIT POSITION 4\n       status = I2Cdev::writeBit(0x68, 0x02, 4, value);\n\n       WRITE 3 BITS TO DEVICE 0x68, REGISTER 0x02, BIT POSITION 4\n       status = I2Cdev::writeBits(0x68, 0x02, 4, 3, value);\n\n       WRITE 1 BYTE TO DEVICE 0x68, REGISTER 0x02\n       status = I2Cdev::writeByte(0x68, 0x02, value);\n\n       WRITE 2 BYTES TO DEVICE 0x68, REGISTER 0x02 (AND 0x03 FOR 2ND BYTE)\n       status = I2Cdev::writeBytes(0x68, 0x02, 2, buffer);\n       \n   The word-based methods are exactly the same, except they use 16-bit variables\n   instead of 8-bit ones.\n\n   ============================================================================ */\n\n/** Default constructor, uses default I2C address.\n * @see MYDEVSTUB_DEFAULT_ADDRESS\n */\nMYDEVSTUB::MYDEVSTUB() {\n    devAddr = MYDEVSTUB_DEFAULT_ADDRESS;\n}\n\n/** Specific address constructor.\n * @param address I2C address\n * @see MYDEVSTUB_DEFAULT_ADDRESS\n * @see MYDEVSTUB_ADDRESS\n */\nMYDEVSTUB::MYDEVSTUB(uint8_t address) {\n    devAddr = address;\n}\n\n/** Power on and prepare for general usage.\n */\nvoid MYDEVSTUB::initialize() {\n    // ----------------------------------------------------------------------------\n    // STUB TODO:\n    // Perform any important initialization here. Maybe nothing is required, but\n    // the method should exist anyway.\n    // ----------------------------------------------------------------------------\n}\n\n/** Verify the I2C connection.\n * Make sure the device is connected and responds as expected.\n * @return True if connection is valid, false otherwise\n */\nbool MYDEVSTUB::testConnection() {\n    if (I2Cdev::readByte(devAddr, MYDEVSTUB_RA_WHO_AM_I, buffer) == 1) {\n        return true;\n    }\n    return false;\n}\n\n// ----------------------------------------------------------------------------\n// STUB TODO:\n// Define methods to fully cover all available functionality provided by the\n// device, according to the datasheet and/or register map. Unless there is very\n// clear reason not to, try to follow the get/set naming convention for all\n// values, for instance:\n//   - uint8_t getThreshold()\n//   - void setThreshold(uint8_t threshold)\n//   - uint8_t getRate()\n//   - void setRate(uint8_t rate)\n//\n// Some methods may be named differently if it makes sense. As long as all\n// functionality is covered, that\'s the important part. The methods here are\n// only examples and should not be kept for your real device.\n// ----------------------------------------------------------------------------\n\n// MEASURE1 register, read-only\n\nuint8_t MYDEVSTUB::getMeasurement1() {\n    // read a single byte and return it\n    I2Cdev::readByte(devAddr, MYDEVSTUB_RA_MEASURE1, buffer);\n    return buffer[0];\n}\n\n// MEASURE2 register, read-only\n\nuint8_t MYDEVSTUB::getMeasurement2() {\n    // read a single byte and return it\n    I2Cdev::readByte(devAddr, MYDEVSTUB_RA_MEASURE2, buffer);\n    return buffer[0];\n}\n\n// MEASURE3 register, read-only\n\nuint8_t MYDEVSTUB::getMeasurement3() {\n    // read a single byte and return it\n    I2Cdev::readByte(devAddr, MYDEVSTUB_RA_MEASURE3, buffer);\n    return buffer[0];\n}\n\n// CONFIG1 register, r/w\n\nvoid MYDEVSTUB::reset() {\n    // write a single bit to the RESET position in the CONFIG1 register\n    I2Cdev::writeBit(devAddr, MYDEVSTUB_RA_CONFIG1, MYDEVSTUB_CONFIG1_RESET_BIT, 1);\n}\nbool MYDEVSTUB::getFIFOEnabled() {\n    // read a single bit from the FIFO_EN position in the CONFIG1 regsiter\n    I2Cdev::readBit(devAddr, MYDEVSTUB_RA_CONFIG1, MYDEVSTUB_CONFIG1_FIFO_EN_BIT, buffer);\n    return buffer[0];\n}\nvoid MYDEVSTUB::setFIFOEnabled(bool enabled) {\n    // write a single bit to the FIFO_EN position in the CONFIG1 regsiter\n    I2Cdev::writeBit(devAddr, MYDEVSTUB_RA_CONFIG1, MYDEVSTUB_CONFIG1_FIFO_EN_BIT, enabled);\n}\n\n// CONFIG2 register, r/w\n\nuint8_t MYDEVSTUB::getInterruptMode() {\n    // reading a single bit from a register\n    I2Cdev::readBit(devAddr, MYDEVSTUB_RA_CONFIG2, MYDEVSTUB_CONFIG2_INTMODE_BIT, buffer);\n    return buffer[0];\n}\nvoid MYDEVSTUB::setInterruptMode(uint8_t mode) {\n    // writing a single bit into a register\n}\nuint8_t MYDEVSTUB::getRate() {\n    // reading multiple single bit from a register\n    I2Cdev::readBits(devAddr, MYDEVSTUB_RA_CONFIG2, MYDEVSTUB_CONFIG2_RATE_BIT, MYDEVSTUB_CONFIG2_RATE_LENGTH, buffer);\n    return buffer[0];\n}\nvoid MYDEVSTUB::setRate(uint8_t rate) {\n    // writing multiple bits into a register\n    I2Cdev::writeBits(devAddr, MYDEVSTUB_RA_CONFIG2, MYDEVSTUB_CONFIG2_RATE_BIT, MYDEVSTUB_CONFIG2_RATE_LENGTH, rate);\n}\n\n// DATA_* registers, r/w\n\nuint16_t MYDEVSTUB::getData() {\n    // reading two H/L bytes and bit-shifting them into a 16-bit value\n    I2Cdev::readBytes(devAddr, MYDEVSTUB_RA_DATA_H, 2, buffer);\n    return (buffer[0] << 8) + buffer[1];\n}\nvoid MYDEVSTUB::setData(uint16_t value) {\n    // splitting a 16-bit value into two H/L bytes and writing them\n    buffer[0] = value >> 8;\n    buffer[1] = value & 0xFF;\n    I2Cdev::writeBytes(devAddr, MYDEVSTUB_RA_DATA_H, 2, buffer);\n}\n\n// WHO_AM_I register, read-only\n\nuint8_t MYDEVSTUB::getDeviceID() {\n    // read a single byte and return it\n    I2Cdev::readByte(devAddr, MYDEVSTUB_RA_WHO_AM_I, buffer);\n    return buffer[0];\n}\n'