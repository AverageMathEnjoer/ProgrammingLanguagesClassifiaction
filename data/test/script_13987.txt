b'{-# LANGUAGE BangPatterns #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n\nmodule SetOperations (benchmark) where\n\nimport Test.Tasty.Bench (bench, defaultMain, whnf)\nimport Data.List (partition, sortBy)\nimport Data.Ord (comparing)\nimport Data.Tuple as Tuple\n\n-- | Benchmark a set operation for the given container.\n-- Takes the following arguments:\n-- * A way to construct the container\n-- * Flag if we should benchmark the operations with reversed arguments.\n-- * A list of operations.\nbenchmark :: forall container. (Show container, Eq container) => ([Int] -> container) -> Bool -> [(String, container -> container -> container)] -> IO ()\nbenchmark fromList swap methods = do\n\n  defaultMain $ [ bench (method_str++"-"++input_str ++ "_" ++ data_sizes) $\n                        whnf (method input1) input2\n\n                | (method_str, method) <- methods\n                , (input_str, data_sizes, (input1, input2)) <- sortBenchs (base_inputs ++ swapped_input)\n                ]\n\n  where\n    -- Sort benchmark inputs by (data variant, data sizes)\n    sortBenchs = sortBy (comparing (\\(name,size,_) -> (name,size)))\n\n    -- Data size descriptions, also used in the benchmark names.\n    -- They are used to describe how large the input data is, but NOT the data itself.\n    -- So for example nn_swap /= nn since the data size for both arguments is the same\n    -- but the actual data is different.\n    n, s, t :: Int\n    n = 100000\n    s {-small-} = n `div` 10\n    t {-tiny-} = round $ sqrt $ fromIntegral n\n\n    base_inputs :: [(String,String,(container,container))]\n    base_inputs = [ ("disj", "nn", disj_nn), ("disj","ns", disj_ns), ("disj","nt", disj_nt)\n                                            , ("common","nn", common_nn), ("common","ns", common_ns), ("common","nt", common_nt)\n                                            , ("mix","nn", mix_nn), ("mix","ns", mix_ns), ("mix","nt", mix_nt)\n                                            , ("block","nn", block_nn), ("block","ns", block_ns)\n                                            ]\n\n    -- Input with set arguments swapped.\n    swapped_input\n      | swap = map swap_input base_inputs\n      | otherwise = []\n\n    -- Reverse arguments\n    swap_input (name, data_sizes, input_data) =\n        (name, reverse data_sizes ++ "_swap", Tuple.swap input_data)\n\n    -- Data variants\n    all_n = fromList [1..n]\n\n    !disj_nn = seqPair $ (all_n, fromList [n+1..n+n])\n    !disj_ns = seqPair $ (all_n, fromList [n+1..n+s])\n    !disj_nt = seqPair $ (all_n, fromList [n+1..n+t])\n    !common_nn = seqPair $ (all_n, fromList [2,4..n])\n    !common_ns = seqPair $ (all_n, fromList [0,1+n`div`s..n])\n    !common_nt = seqPair $ (all_n, fromList [0,1+n`div`t..n])\n    !mix_nn = seqPair $ fromLists $ partition ((/= 0) . (`mod` 2)) [1..n+n]\n    !mix_ns = seqPair $ fromLists $ partition ((/= 0) . (`mod` (1 + n`div`s))) [1..s+n]\n    !mix_nt = seqPair $ fromLists $ partition ((/= 0) . (`mod` (1 + n`div`t))) [1..t+n]\n    !block_nn = seqPair $ fromLists $ partition ((>= t) . (`mod` (t * 2))) [1..n+n]\n    !block_ns = seqPair $ fromLists $ partition ((>= t) . (`mod` (t * (1 + n`div`s)))) [1..s+n]\n\n    fromLists (xs, ys) = (fromList xs, fromList ys)\n    seqPair pair@(xs, ys) = xs `seq` ys `seq` pair\n'