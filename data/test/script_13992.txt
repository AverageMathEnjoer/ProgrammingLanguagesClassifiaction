b'{-# LANGUAGE DataKinds #-}\n{-# LANGUAGE DuplicateRecordFields #-}\n{-# LANGUAGE FlexibleContexts #-}\n{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE RankNTypes #-}\n{-# LANGUAGE TypeFamilies #-}\n{-# LANGUAGE UndecidableInstances #-}\n\n-- | This module contains a new way of doing OAuth2 authorization and authentication\n-- in order to obtain Access Token and maybe Refresh Token base on rfc6749.\n--\n-- This module will become default in future release. (TBD but likely 3.0).\n--\n-- The key concept/change is to introduce the \'GrantTypeFlow\', which determines the entire work flow per spec.\n-- Each work flow will have slight different request parameters, which often time you\'ll see\n-- different configuration when creating OAuth2 application in the IdP developer application page.\n--\n-- Here are supported flows\n--\n-- 1. Authorization Code. This flow requires authorize call to obtain an authorize code,\n-- then exchange the code for tokens.\n--\n-- 2. Resource Owner Password. This flow only requires to hit token endpoint with, of course,\n-- username and password, to obtain tokens.\n--\n-- 3. Client Credentials. This flow also only requires to hit token endpoint but with different parameters.\n-- Client credentials flow does not involve an end user hence you won\'t be able to hit userinfo endpoint\n-- with access token obtained.\n--\n-- 5. PKCE (rfc7636). This is enhancement on top of authorization code flow.\n--\n-- Implicit flow is not supported because it is more for SPA (single page app)\n-- and more or less obsolete by Authorization Code flow with PKCE.\n--\n-- Here is quick sample for how to use vocabularies from this new module.\n--\n-- Firstly, initialize your IdP (use google as example) and the application.\n--\n-- @\n-- {\\-# LANGUAGE DataKinds #-\\}\n--\n-- data Google = Google deriving (Eq, Show)\n-- googleIdp :: Idp Google\n-- googleIdp =\n--   Idp\n--     { idpFetchUserInfo = authGetJSON @(IdpUserInfo Google),\n--       idpAuthorizeEndpoint = [uri|https:\\/\\/accounts.google.com\\/o\\/oauth2\\/v2\\/auth|],\n--       idpTokenEndpoint = [uri|https:\\/\\/oauth2.googleapis.com\\/token|],\n--       idpUserInfoEndpoint = [uri|https:\\/\\/www.googleapis.com\\/oauth2\\/v2\\/userinfo|]\n--     }\n--\n-- fooApp :: IdpApplication \'AuthorizationCode Google\n-- fooApp =\n--   AuthorizationCodeIdpApplication\n--     { idpAppClientId = "xxxxx",\n--       idpAppClientSecret = "xxxxx",\n--       idpAppScope =\n--         Set.fromList\n--           [ \\"https:\\/\\/www.googleapis.com\\/auth\\/userinfo.email\\",\n--             \\"https:\\/\\/www.googleapis.com\\/auth\\/userinfo.profile\\"\n--           ],\n--       idpAppAuthorizeState = \\"CHANGE_ME\\",\n--       idpAppAuthorizeExtraParams = Map.empty,\n--       idpAppRedirectUri = [uri|http:\\/\\/localhost\\/oauth2\\/callback|],\n--       idpAppName = "default-google-App",\n--       idpAppTokenRequestAuthenticationMethod = ClientSecretBasic,\n--       idp = googleIdp\n--     }\n-- @\n--\n-- Secondly, construct the authorize URL.\n--\n-- @\n-- authorizeUrl = mkAuthorizeRequest fooApp\n-- @\n--\n-- Thirdly, after a successful redirect with authorize code,\n-- you could exchange for access token\n--\n-- @\n-- mgr <- liftIO $ newManager tlsManagerSettings\n-- tokenResp <- conduitTokenRequest fooApp mgr authorizeCode\n-- @\n--\n-- Lastly, you probably like to fetch user info\n--\n-- @\n-- conduitUserInfoRequest fooApp mgr (accessToken tokenResp)\n-- @\n--\n-- Also you could find example from @hoauth2-providers-tutorials@ module.\nmodule Network.OAuth2.Experiment (\n  module Network.OAuth2.Experiment.Types,\n  module Network.OAuth2.Experiment.Pkce,\n) where\n\nimport Network.OAuth2.Experiment.Pkce\nimport Network.OAuth2.Experiment.Types\n'