b'{-# LANGUAGE CPP #-}\n\n-- A quicksort benchmark for monad-par\n\nimport System.Random\nimport System.Environment\nimport Control.Monad\nimport Data.Time.Clock\nimport Text.Printf\nimport Control.Monad.Par.AList as A\nimport Control.Exception\nimport Control.DeepSeq\nimport Data.Int\nimport Data.List as L\n-- import Prelude (($), print, read)\n-- import qualified Prelude as P\n\n#ifdef PARSCHED \nimport PARSCHED\n#else\nimport Control.Monad.Par\n-- import Control.Monad.Par.Scheds.Trace\n#endif\n\n\n\n\n\n-- TODO: Rewrite with AList.. lists are not good for this.\n\nquicksortP :: A.AList Int -> Par (A.AList Int)\nquicksortP A.ANil       = return empty\nquicksortP (A.ASing x)  = return (singleton x)\nquicksortP (A.AList ls) = error "implement me"\n\n-- This quicksort always choses the pivot to be the first element:\nquicksortP xs = \n-- quicksortP (A.Append hd tl) = \n  let pivot = A.head xs \n      rest  = A.tail xs in\n  do\n     let low  =  A.filter (<  pivot) rest\n         high =  A.filter (>= pivot) rest\n\n     lf <- spawn$ quicksortP low\n     h  <-        quicksortP high\n     l  <- get lf\n\n     return (l `append` singleton pivot `append` h)\n    \n\n-- Another version.  TODO: Switch to this one:\n-- | AList version of quicksort\naqs :: A.AList Int -> A.AList Int\naqs A.ANil = A.ANil\naqs (A.ASing x) = A.ASing x\naqs (A.AList xs) = undefined\naqs (A.Append xs ys) = low\' `A.append` (pivot `A.cons` high\')\n  where pivot = A.head xs\n        (low, high) = A.partition (< pivot) (A.Append (A.tail xs) ys)\n        low\' = aqs low\n        high\' = aqs high\n\nprop_aqs :: [Int] -> Bool\nprop_aqs xs = L.sort xs == (A.toList $ aqs (A.fromListBalanced xs))\n\n-- TODO: replace with fromListBalanced:\n-- | \'genRandoms\' creates 2^N random numbers.\ngenRandoms :: Int -> StdGen -> AList Int\n--genRandoms n = loop (mkStdGen 120) n \ngenRandoms n g = loop g n \n where\n  loop rng 0 = ASing$ fst$ next rng\n  loop rng n = let (r1,r2) = split rng in\n               A.Append (loop r1 (n-1)) \n\t\t        (loop r2 (n-1))\n\nmain = do args <- getArgs\n          let size =\n                case args of\n                  []  -> 8\n                  [n] -> (read n)\n\n          g <- getStdGen          \n          let rands = genRandoms size g\n--          let rands = genRandoms size (mkStdGen 120)\n\n          putStrLn$ "Quicksorting "++show size++" elements. First deepseq the rands:"\n\t  evaluate (deepseq rands ())\n--          nfIO rands\n-- \t  deepseq rands $ return ()\n\n--           putStrLn$ "Length of rands: "++ show (A.length rands)\n--           putStrLn$ "Length of filtered: "++ show (A.length (A.filter (>=0) rands))\n\n          putStrLn "Executing monad-par based sort..."\n          start <- getCurrentTime\n          let sorted = runPar $ quicksortP rands\n          putStr "Prefix of sorted list:\\n  "\n          print$ take 8 $ A.toList sorted\n          end   <- getCurrentTime\n\n          let runningTime = ((fromRational $ toRational $ diffUTCTime end start) :: Double)\n          printf "Sorting AList took %0.3f sec.\\n" runningTime\n          putStrLn $ "SELFTIMED " ++ show runningTime\n          when (size <= 4) $ do\n            putStrLn$ "  Unsorted: " ++  show rands\n            putStrLn$ "  Sorted  : " ++  show sorted\n'