b'{-# LANGUAGE DeriveGeneric, GeneralizedNewtypeDeriving, RankNTypes, ScopedTypeVariables #-}\n{-# OPTIONS_GHC -funbox-strict-fields #-}\nmodule TreeSitter.Node\n( Node(..)\n, nodeStartPoint\n, nodeStartByte\n, TSPoint(..)\n, TSNode(..)\n, FieldId(..)\n, ts_node_copy_child_nodes\n, ts_node_poke_p\n) where\n\nimport Foreign\nimport Foreign.C\nimport GHC.Generics\nimport TreeSitter.Symbol (TSSymbol)\n\ndata Node = Node\n  { nodeTSNode     :: !TSNode\n  , nodeType       :: !CString\n  , nodeSymbol     :: !TSSymbol\n  , nodeEndPoint   :: !TSPoint\n  , nodeEndByte    :: !Word32\n  , nodeChildCount :: !Word32\n  , nodeFieldName  :: !CString\n  , nodeIsNamed    :: !CBool\n  , nodeIsExtra    :: !CBool\n  }\n  deriving (Show, Eq, Generic)\n\nnodeStartPoint :: Node -> TSPoint\nnodeStartPoint node = let TSNode _ p _ _ _ = nodeTSNode node in p\n\nnodeStartByte :: Node -> Word32\nnodeStartByte node = let TSNode b _ _ _ _ = nodeTSNode node in b\n\ndata TSPoint = TSPoint { pointRow :: !Word32, pointColumn :: !Word32 }\n  deriving (Show, Eq, Generic)\n\ndata TSNode = TSNode !Word32 !TSPoint !Word32 !(Ptr ()) !(Ptr ())\n  deriving (Show, Eq, Generic)\n\nnewtype FieldId = FieldId { getFieldId :: Word16 }\n  deriving (Eq, Ord, Show, Storable)\n\n\n-- | \'Struct\' is a strict \'Monad\' with automatic alignment & advancing, & inferred type.\nnewtype Struct a = Struct { runStruct :: forall b . Ptr b -> IO (a, Ptr a) }\n\nevalStruct :: Struct a -> Ptr b -> IO a\nevalStruct s p = fmap fst $! runStruct s p\n{-# INLINE evalStruct #-}\n\npeekStruct :: forall a . Storable a => Struct a\npeekStruct = Struct (\\ p -> do\n  let aligned = alignPtr (castPtr p) (alignment (undefined :: a))\n  a <- peek aligned\n  pure (a, aligned `plusPtr` sizeOf a))\n{-# INLINE peekStruct #-}\n\npokeStruct :: Storable a => a -> Struct ()\npokeStruct a = Struct (\\ p -> do\n  let aligned = alignPtr (castPtr p) (alignment a)\n  poke aligned a\n  pure ((), castPtr aligned `plusPtr` sizeOf a))\n{-# INLINE pokeStruct #-}\n\n\ninstance Storable Node where\n  alignment _ = alignment (undefined :: TSNode)\n  {-# INLINE alignment #-}\n  sizeOf _ = 80\n  {-# INLINE sizeOf #-}\n  peek = evalStruct $ Node <$> peekStruct\n                           <*> peekStruct\n                           <*> peekStruct\n                           <*> peekStruct\n                           <*> peekStruct\n                           <*> peekStruct\n                           <*> peekStruct\n                           <*> peekStruct\n                           <*> peekStruct\n  {-# INLINE peek #-}\n  poke ptr (Node n t s ep eb c fn nn ne) = flip evalStruct ptr $ do\n    pokeStruct n\n    pokeStruct t\n    pokeStruct s\n    pokeStruct ep\n    pokeStruct eb\n    pokeStruct c\n    pokeStruct fn\n    pokeStruct nn\n    pokeStruct ne\n  {-# INLINE poke #-}\n\ninstance Storable TSPoint where\n  alignment _ = alignment (0 :: Int32)\n  {-# INLINE alignment #-}\n  sizeOf _ = 8\n  {-# INLINE sizeOf #-}\n  peek = evalStruct $ TSPoint <$> peekStruct\n                              <*> peekStruct\n  {-# INLINE peek #-}\n  poke ptr (TSPoint r c) = flip evalStruct ptr $ do\n    pokeStruct r\n    pokeStruct c\n  {-# INLINE poke #-}\n\ninstance Storable TSNode where\n  alignment _ = alignment (nullPtr :: Ptr ())\n  {-# INLINE alignment #-}\n  sizeOf _ = 32\n  {-# INLINE sizeOf #-}\n  peek = evalStruct $ TSNode <$> peekStruct\n                             <*> peekStruct\n                             <*> peekStruct\n                             <*> peekStruct\n                             <*> peekStruct\n  {-# INLINE peek #-}\n  poke ptr (TSNode sb sp o4 p1 p2) = flip evalStruct ptr $ do\n    pokeStruct sb\n    pokeStruct sp\n    pokeStruct o4\n    pokeStruct p1\n    pokeStruct p2\n  {-# INLINE poke #-}\n\ninstance Functor Struct where\n  fmap f a = Struct go where\n    go p = do\n      (a\', p\') <- runStruct a p\n      let fa = f a\'\n      fa `seq` p\' `seq` pure (fa, castPtr p\')\n    {-# INLINE go #-}\n  {-# INLINE fmap #-}\n\ninstance Applicative Struct where\n  pure a = Struct (\\ p -> pure (a, castPtr p))\n  {-# INLINE pure #-}\n\n  f <*> a = Struct go where\n    go p = do\n      (f\', p\')  <- runStruct f          p\n      (a\', p\'\') <- p\' `seq` runStruct a (castPtr p\')\n      let fa = f\' a\'\n      fa `seq` p\'\' `seq` pure (fa, castPtr p\'\')\n    {-# INLINE go #-}\n  {-# INLINE (<*>) #-}\n\ninstance Monad Struct where\n  return = pure\n  {-# INLINE return #-}\n\n  a >>= f = Struct go where\n    go p = do\n      (a\', p\')   <- runStruct a               p\n      (fa\', p\'\') <- p\' `seq` runStruct (f a\') (castPtr p\')\n      fa\' `seq` p\'\' `seq` pure (fa\', p\'\')\n    {-# INLINE go #-}\n  {-# INLINE (>>=) #-}\n\n\nforeign import ccall unsafe "src/bridge.c ts_node_copy_child_nodes" ts_node_copy_child_nodes :: Ptr TSNode -> Ptr Node -> IO ()\n-- NB: this leaves the field name as NULL.\nforeign import ccall unsafe "src/bridge.c ts_node_poke_p" ts_node_poke_p :: Ptr TSNode -> Ptr Node -> IO ()\n'