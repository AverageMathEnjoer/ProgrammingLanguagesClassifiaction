b'{-# LANGUAGE DerivingStrategies #-}\n\nmodule Cachix.Deploy.Log where\n\nimport qualified Cachix.API.WebSocketSubprotocol as WSS\nimport qualified Control.Concurrent.STM.TMQueue as TMQueue\nimport Control.Exception.Safe (MonadMask, bracket)\nimport qualified Data.Aeson as Aeson\nimport Data.Conduit ((.|))\nimport qualified Data.Conduit as Conduit\nimport qualified Data.Conduit.Combinators as Conduit\nimport qualified Data.Conduit.TQueue as Conduit\nimport Data.Time.Clock (getCurrentTime)\nimport qualified Katip\nimport qualified Network.WebSockets as WS\nimport Protolude hiding (bracket, toS)\nimport Protolude.Conv (toS)\n\n-- A temporary crutch while we fix up the types\ntype WithLog = Katip.KatipContextT IO () -> IO ()\n\ndata Options = Options\n  { -- | The minimum verbosity level\n    verbosity :: Verbosity,\n    -- | The logging namespace, e.g. agent\n    namespace :: Katip.Namespace,\n    -- | The logging environment, e.g. production\n    environment :: Katip.Environment\n  }\n  deriving stock (Show, Generic)\n  deriving anyclass (Aeson.ToJSON, Aeson.FromJSON)\n\ndata Verbosity\n  = Normal\n  | Verbose\n  deriving stock (Show, Generic)\n  deriving anyclass (Aeson.ToJSON, Aeson.FromJSON)\n\nwithLog ::\n  (MonadIO m, MonadMask m) =>\n  Options ->\n  (WithLog -> m a) ->\n  m a\nwithLog Options {..} inner =\n  let permit = case verbosity of\n        Verbose -> Katip.DebugS\n        Normal -> Katip.InfoS\n\n      createLogEnv = liftIO $ do\n        logEnv <- Katip.initLogEnv namespace environment\n        stdoutScribe <- Katip.mkHandleScribe Katip.ColorIfTerminal stdout (Katip.permitItem permit) Katip.V2\n        Katip.registerScribe "stdout" stdoutScribe Katip.defaultScribeSettings logEnv\n\n      createContext logEnv = Katip.runKatipContextT logEnv () namespace\n\n      closeLog = liftIO . Katip.closeScribes\n   in bracket createLogEnv closeLog $ inner . createContext\n\n-- Streaming log\n\ntype LogStream = Conduit.ConduitT ByteString Conduit.Void IO ()\n\n-- TODO: prepend katip-like format to each line\nstreamLog :: WithLog -> WS.Connection -> TMQueue.TMQueue ByteString -> IO ()\nstreamLog logger connection queue = do\n  Conduit.runConduit $\n    Conduit.sourceTMQueue queue\n      .| Conduit.linesUnboundedAscii\n      .| logLocal logger\n      .| sendLog connection\n\nstreamLine :: LogStream -> ByteString -> IO ()\nstreamLine logStream msg = Conduit.connect (Conduit.yield $ msg <> "\\n") logStream\n\nlogLocal :: WithLog -> Conduit.ConduitT ByteString ByteString IO ()\nlogLocal logger =\n  Conduit.mapM $ \\bs -> do\n    logger . Katip.logLocM Katip.DebugS . Katip.ls $ bs\n    return bs\n\nsendLog :: WS.Connection -> LogStream\nsendLog connection = Conduit.mapM_ $ \\bs -> do\n  now <- getCurrentTime\n  WS.sendTextData connection $ Aeson.encode $ WSS.Log {WSS.line = toS bs, WSS.time = now}\n'