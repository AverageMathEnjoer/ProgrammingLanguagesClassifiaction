b'module URISpec where\n\nimport qualified Cachix.Client.URI as URI\nimport qualified Data.Aeson as Aeson\nimport qualified Data.ByteString.Char8 as Char8\nimport qualified Data.ByteString.Lazy as BL\nimport Data.Either.Extra\nimport qualified Dhall\nimport qualified Dhall.Core\nimport Protolude\nimport qualified Servant.Client.Core as Servant\nimport Test.Hspec\n\nsecureScheme :: ByteString\nsecureScheme = "https"\n\nunsecureScheme :: ByteString\nunsecureScheme = "http"\n\nhost :: ByteString\nhost = "cachix.org"\n\nsubdomain :: Text\nsubdomain = "foo"\n\nsecureUri :: ByteString\nsecureUri = secureScheme <> "://" <> host\n\nunsecureUri :: ByteString\nunsecureUri = unsecureScheme <> "://" <> host\n\nsecureUriWithSubdomain :: ByteString\nsecureUriWithSubdomain = secureScheme <> "://" <> encodeUtf8 subdomain <> "." <> host\n\n-- A helper that throws an error when parsing fails.\nparseURI\' :: ByteString -> URI.URI\nparseURI\' = fromRight\' . URI.parseURI\n\nspec :: Spec\nspec =\n  describe "URI" $ do\n    it "parses a URI" $\n      URI.parseURI secureUri `shouldSatisfy` isRight\n\n    it "re-serializes a URI" $\n      URI.serialize <$> URI.parseURI secureUri `shouldBe` Right secureUri\n\n    it "appends a subdomain" $\n      let parsedURI = parseURI\' secureUri\n          newURI = URI.appendSubdomain subdomain parsedURI\n       in URI.serialize newURI `shouldBe` secureUriWithSubdomain\n\n    it "returns the hostname" $\n      URI.getHostname (parseURI\' secureUri) `shouldBe` URI.Host host\n\n    it "returns port 80 for HTTP URIs" $\n      let scheme = URI.getScheme (parseURI\' unsecureUri)\n       in URI.getPortFor scheme `shouldBe` Just (URI.Port 80)\n\n    it "returns port 443 for HTTPS URIs" $\n      let scheme = URI.getScheme (parseURI\' secureUri)\n       in URI.getPortFor scheme `shouldBe` Just (URI.Port 443)\n\n    it "detects if SSL is required" $\n      let getScheme = URI.getScheme . parseURI\'\n       in do\n            URI.requiresSSL (getScheme secureUri) `shouldBe` True\n            URI.requiresSSL (getScheme unsecureUri) `shouldBe` False\n\n    it "converts to JSON" $\n      Aeson.encode (parseURI\' secureUri) `shouldBe` "\\"" <> BL.fromStrict secureUri <> "\\""\n\n    it "converts from JSON" $\n      Aeson.decodeStrict\' ("\\"" <> secureUri <> "\\"") `shouldBe` Just (parseURI\' secureUri)\n\n    it "converts to Dhall" $\n      let asDhall = Dhall.embed Dhall.inject (parseURI\' secureUri)\n       in Dhall.Core.pretty asDhall `shouldBe` "\\"" <> decodeUtf8 secureUri <> "\\""\n\n    it "converts from Dhall" $\n      Dhall.input Dhall.auto ("\\"" <> decodeUtf8 secureUri <> "\\"") `shouldReturn` parseURI\' secureUri\n\n    -- https://github.com/cachix/cachix/issues/462\n    it "converts to a Servant BaseUrl without trailing slashes" $\n      let uriWithTrailingSlash = secureUri <> "/"\n          uri = parseURI\' uriWithTrailingSlash\n       in Servant.baseUrlPath (URI.getBaseUrl uri) `shouldBe` ""\n'