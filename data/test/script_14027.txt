b'namespace CS_SQLite3\n{\n  public partial class CSSQLite\n  {\n    /*\n    ** 2001 September 15\n    **\n    ** The author disclaims copyright to this source code.  In place of\n    ** a legal notice, here is a blessing:\n    **\n    **    May you do good and not evil.\n    **    May you find forgiveness for yourself and forgive others.\n    **    May you share freely, never taking more than you give.\n    **\n    *************************************************************************\n    ** This header file defines the interface that the sqlite B-Tree file\n    ** subsystem.  See comments in the source code for a detailed description\n    ** of what each interface routine does.\n    **\n    ** @(#) $Id: btree.h,v 1.120 2009/07/22 00:35:24 drh Exp $\n    **\n    *************************************************************************\n    **  Included in SQLite3 port to C#-SQLite;  2008 Noah B Hart\n    **  C#-SQLite is an independent reimplementation of the SQLite software library\n    **\n    **  $Header$\n    *************************************************************************\n    */\n    //#if !_BTREE_H_\n    //#define _BTREE_H_\n\n    /* TODO: This definition is just included so other modules compile. It\n    ** needs to be revisited.\n    */\n    const int SQLITE_N_BTREE_META = 10;\n\n    /*\n    ** If defined as non-zero, auto-vacuum is enabled by default. Otherwise\n    ** it must be turned on for each database using "PRAGMA auto_vacuum = 1".\n    */\n#if !SQLITE_DEFAULT_AUTOVACUUM\n    const int SQLITE_DEFAULT_AUTOVACUUM = 0;\n#endif\n\n    const int BTREE_AUTOVACUUM_NONE = 0;        /* Do not do auto-vacuum */\n    const int BTREE_AUTOVACUUM_FULL = 1;        /* Do full auto-vacuum */\n    const int BTREE_AUTOVACUUM_INCR = 2;        /* Incremental vacuum */\n\n    /*\n    ** Forward declarations of structure\n    */\n    //typedef struct Btree Btree;\n    //typedef struct BtCursor BtCursor;\n    //typedef struct BtShared BtShared;\n    //typedef struct BtreeMutexArray BtreeMutexArray;\n\n    /*\n    ** This structure records all of the Btrees that need to hold\n    ** a mutex before we enter sqlite3VdbeExec().  The Btrees are\n    ** are placed in aBtree[] in order of aBtree[].pBt.  That way,\n    ** we can always lock and unlock them all quickly.\n    */\n    public class BtreeMutexArray\n    {\n      public int nMutex;\n      public Btree[] aBtree = new Btree[SQLITE_MAX_ATTACHED + 1];\n    };\n\n\n    //int sqlite3BtreeOpen(\n    //  string zFilename,       /* Name of database file to open */\n    //  sqlite3 db,             /* Associated database connection */\n    //  Btree **ppBtree,        /* Return open Btree* here */\n    //  int flags,              /* Flags */\n    //  int vfsFlags            /* Flags passed through to VFS open */\n    //);\n\n    /* The flags parameter to sqlite3BtreeOpen can be the bitwise or of the\n    ** following values.\n    **\n    ** NOTE:  These values must match the corresponding PAGER_ values in\n    ** pager.h.\n    */\n    const int BTREE_OMIT_JOURNAL = 1; /* Do not use journal.  No argument */\n    const int BTREE_NO_READLOCK = 2; /* Omit readlocks on readonly files */\n    const int BTREE_MEMORY = 4; /* In-memory DB.  No argument */\n    const int BTREE_READONLY = 8; /* Open the database in read-only mode */\n    const int BTREE_READWRITE = 16; /* Open for both reading and writing */\n    const int BTREE_CREATE = 32; /* Create the database if it does not exist */\n\n    //int sqlite3BtreeClose(Btree*);\n    //int sqlite3BtreeSetCacheSize(Btree*,int);\n    //int sqlite3BtreeSetSafetyLevel(Btree*,int,int);\n    //int sqlite3BtreeSyncDisabled(Btree*);\n    //int sqlite3BtreeSetPageSize(Btree *p, int nPagesize, int nReserve, int eFix);\n    //int sqlite3BtreeGetPageSize(Btree*);\n    //int sqlite3BtreeMaxPageCount(Btree*,int);\n    //int sqlite3BtreeGetReserve(Btree*);\n    //int sqlite3BtreeSetAutoVacuum(Btree , int);\n    //int sqlite3BtreeGetAutoVacuum(Btree );\n    //int sqlite3BtreeBeginTrans(Btree*,int);\n    //int sqlite3BtreeCommitPhaseOne(Btree*, string zMaster);\n    //int sqlite3BtreeCommitPhaseTwo(Btree*);\n    //int sqlite3BtreeCommit(Btree*);\n    //int sqlite3BtreeRollback(Btree*);\n    //int sqlite3BtreeBeginStmt(Btree*);\n    //int sqlite3BtreeCreateTable(Btree*, int*, int flags);\n    //int sqlite3BtreeIsInTrans(Btree*);\n    //int sqlite3BtreeIsInReadTrans(Btree*);\n    //int sqlite3BtreeIsInBackup(Btree*);\n    //void *sqlite3BtreeSchema(Btree , int, void(*)(void *));\n    //int sqlite3BtreeSchemaLocked( Btree* pBtree );\n    //int sqlite3BtreeLockTable( Btree* pBtree, int iTab, u8 isWriteLock );\n    //int sqlite3BtreeSavepoint(Btree *, int, int);\n\n    //const char *sqlite3BtreeGetFilename(Btree );\n    //const char *sqlite3BtreeGetJournalname(Btree );\n    //int sqlite3BtreeCopyFile(Btree *, Btree *);\n\n    //int sqlite3BtreeIncrVacuum(Btree );\n\n    /* The flags parameter to sqlite3BtreeCreateTable can be the bitwise OR\n    ** of the following flags:\n    */\n    const int BTREE_INTKEY = 1;   /* Table has only 64-bit signed integer keys */\n    const int BTREE_ZERODATA = 2;   /* Table has keys only - no data */\n    const int BTREE_LEAFDATA = 4; /* Data stored in leaves only.  Implies INTKEY */\n\n    //int sqlite3BtreeDropTable(Btree*, int, int*);\n    //int sqlite3BtreeClearTable(Btree*, int, int*);\n    //void sqlite3BtreeTripAllCursors(Btree*, int);\n\n    //void sqlite3BtreeGetMeta(Btree *pBtree, int idx, u32 *pValue);\n    //int sqlite3BtreeUpdateMeta(Btree*, int idx, u32 value);\n\n\n    /*\n    ** The second parameter to sqlite3BtreeGetMeta or sqlite3BtreeUpdateMeta\n    ** should be one of the following values. The integer values are assigned\n    ** to constants so that the offset of the corresponding field in an\n    ** SQLite database header may be found using the following formula:\n    **\n    **   offset = 36 + (idx * 4)\n    **\n    ** For example, the free-page-count field is located at byte offset 36 of\n    ** the database file header. The incr-vacuum-flag field is located at\n    ** byte offset 64 (== 36+4*7).\n    */\n    //#define BTREE_FREE_PAGE_COUNT     0\n    //#define BTREE_SCHEMA_VERSION      1\n    //#define BTREE_FILE_FORMAT         2\n    //#define BTREE_DEFAULT_CACHE_SIZE  3\n    //#define BTREE_LARGEST_ROOT_PAGE   4\n    //#define BTREE_TEXT_ENCODING       5\n    //#define BTREE_USER_VERSION        6\n    //#define BTREE_INCR_VACUUM         7\n    const int BTREE_FREE_PAGE_COUNT = 0;\n    const int BTREE_SCHEMA_VERSION = 1;\n    const int BTREE_FILE_FORMAT = 2;\n    const int BTREE_DEFAULT_CACHE_SIZE = 3;\n    const int BTREE_LARGEST_ROOT_PAGE = 4;\n    const int BTREE_TEXT_ENCODING = 5;\n    const int BTREE_USER_VERSION = 6;\n    const int BTREE_INCR_VACUUM = 7;\n\n    //int sqlite3BtreeCursor(\n    //  Btree*,                              /* BTree containing table to open */\n    //  int iTable,                          /* Index of root page */\n    //  int wrFlag,                          /* 1 for writing.  0 for read-only */\n    //  struct KeyInfo*,                     /* First argument to compare function */\n    //  BtCursor pCursor                    /* Space to write cursor structure */\n    //);\n    //int sqlite3BtreeCursorSize(void);\n\n    //int sqlite3BtreeCloseCursor(BtCursor*);\n    //int sqlite3BtreeMovetoUnpacked(\n    //  BtCursor*,\n    //  UnpackedRecord pUnKey,\n    //  i64 intKey,\n    //  int bias,\n    //  int pRes\n    //);\n    //int sqlite3BtreeCursorHasMoved(BtCursor*, int*);\n    //int sqlite3BtreeDelete(BtCursor*);\n    //int sqlite3BtreeInsert(BtCursor*, const void pKey, i64 nKey,\n    //                                  const void pData, int nData,\n    //                                  int nZero, int bias, int seekResult);\n    //int sqlite3BtreeFirst(BtCursor*, int pRes);\n    //int sqlite3BtreeLast(BtCursor*, int pRes);\n    //int sqlite3BtreeNext(BtCursor*, int pRes);\n    //int sqlite3BtreeEof(BtCursor*);\n    //int sqlite3BtreePrevious(BtCursor*, int pRes);\n    //int sqlite3BtreeKeySize(BtCursor*, i64 pSize);\n    //int sqlite3BtreeKey(BtCursor*, u32 offset, u32 amt, void*);\n    //const void *sqlite3BtreeKeyFetch(BtCursor*, int pAmt);\n    //const void *sqlite3BtreeDataFetch(BtCursor*, int pAmt);\n    //int sqlite3BtreeDataSize(BtCursor*, u32 pSize);\n    //int sqlite3BtreeData(BtCursor*, u32 offset, u32 amt, void*);\n    //void sqlite3BtreeSetCachedRowid(BtCursor*, sqlite3_int64);\n    //sqlite3_int64 sqlite3BtreeGetCachedRowid(BtCursor*);\n\n    //char *sqlite3BtreeIntegrityCheck(Btree*, int *aRoot, int nRoot, int, int*);\n    //struct Pager *sqlite3BtreePager(Btree*);\n\n    //int sqlite3BtreePutData(BtCursor*, u32 offset, u32 amt, void*);\n    //void sqlite3BtreeCacheOverflow(BtCursor );\n    //void sqlite3BtreeClearCursor(BtCursor *);\n\n    //#ifndef NDEBUG\n    //int sqlite3BtreeCursorIsValid(BtCursor*);\n    //#endif\n\n    //#if !SQLITE_OMIT_BTREECOUNT\n    //int sqlite3BtreeCount(BtCursor *, i64 *);\n    //#endif\n\n    //#if SQLITE_TEST\n    //int sqlite3BtreeCursorInfo(BtCursor*, int*, int);\n    //void sqlite3BtreeCursorList(Btree*);\n    //#endif\n\n#if !SQLITE_OMIT_SHARED_CACHE\n//void sqlite3BtreeEnter(Btree*);\n//void sqlite3BtreeEnterAll(sqlite3*);\n#else\n    //# define sqlite3BtreeEnter(X)\n    static void sqlite3BtreeEnter( Btree bt ) { }\n    //# define sqlite3BtreeEnterAll(X)\n    static void sqlite3BtreeEnterAll( sqlite3 p ) { }\n#endif\n\n#if !(SQLITE_OMIT_SHARED_CACHE) && SQLITE_THREADSAFE\n//void sqlite3BtreeLeave(Btree*);\n//void sqlite3BtreeEnterCursor(BtCursor*);\n//void sqlite3BtreeLeaveCursor(BtCursor*);\n//void sqlite3BtreeLeaveAll(sqlite3*);\n//void sqlite3BtreeMutexArrayEnter(BtreeMutexArray*);\n//void sqlite3BtreeMutexArrayLeave(BtreeMutexArray*);\n//void sqlite3BtreeMutexArrayInsert(BtreeMutexArray*, Btree*);\n#if !NDEBUG\n/* These routines are used inside assert() statements only. */\nint sqlite3BtreeHoldsMutex(Btree*);\nint sqlite3BtreeHoldsAllMutexes(sqlite3*);\n#endif\n#else\n\n    //# define sqlite3BtreeLeave(X)\n    static void sqlite3BtreeLeave( Btree X ) { }\n\n    //# define sqlite3BtreeEnterCursor(X)\n    static void sqlite3BtreeEnterCursor( BtCursor X ) { }\n\n    //# define sqlite3BtreeLeaveCursor(X)\n    static void sqlite3BtreeLeaveCursor( BtCursor X ) { }\n\n    //# define sqlite3BtreeLeaveAll(X)\n    static void sqlite3BtreeLeaveAll( sqlite3 X ) { }\n\n    //# define sqlite3BtreeMutexArrayEnter(X)\n    static void sqlite3BtreeMutexArrayEnter( BtreeMutexArray X ) { }\n\n    //# define sqlite3BtreeMutexArrayLeave(X)\n    static void sqlite3BtreeMutexArrayLeave( BtreeMutexArray X ) { }\n\n    //# define sqlite3BtreeMutexArrayInsert(X,Y)\n    static void sqlite3BtreeMutexArrayInsert( BtreeMutexArray X, Btree Y ) { }\n\n    //# define sqlite3BtreeHoldsMutex(X) 1\n    static bool sqlite3BtreeHoldsMutex( Btree X ) { return true; }\n\n    //# define sqlite3BtreeHoldsAllMutexes(X) 1\n    static bool sqlite3BtreeHoldsAllMutexes( sqlite3 X ) { return true; }\n#endif\n\n\n    //#endif // * _BTREE_H_ */\n\n  }\n}\n'