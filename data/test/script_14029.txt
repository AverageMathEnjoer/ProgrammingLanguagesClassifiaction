b'#\' Obtain Grouped Statistics With summarytools\n#\'\n#\' This is essentially the base \\code{\\link{by}} function, except for the \n#\' class of the returned object.\n#\'\n#\' @usage stby(data, INDICES, FUN, ..., simplify = TRUE)\n#\' \n#\' @param data an R object, normally a data frame, possibly a matrix.\n#\' @param INDICES a grouping variable or a list of grouping variables,\n#\'  each of length nrow(data).\n#\' @param FUN a function to be applied to (usually data-frame) subsets of data.\n#\' @param \\dots Further arguments to FUN.\n#\' @param simplify Logical. Essentially a placeholder to maintain full\n#\'  compatibility with base by. For more details, see \n#\'  \\code{\\link[base]{tapply}}.\n#\'\n#\' @return An object having classes \\dQuote{list} and \\dQuote{summarytools}.\n#\'\n#\' @examples\n#\' data("tobacco")\n#\' with(tobacco, stby(BMI, gender, descr))\n#\' \n#\' @seealso \\code{\\link[base]{by}}, \\code{\\link[base]{tapply}}\n#\' @keywords utilities\n#\' @export\nstby <- function(data, INDICES, FUN, ..., simplify = TRUE) {\n  UseMethod("stby", data)\n}\n  \n#\' @method stby data.frame\n#\' @keywords utilities\n#\' @export\nstby.data.frame <- function(data, INDICES, FUN, ..., simplify = TRUE) {\n  if (identical(FUN, summarytools::freq) && ncol(data) > 1) {\n    stop("when using freq() with stby(), only one variable may be analysed")\n  }\n  if (!is.list(INDICES)) {\n    IND <- vector("list", 1L)\n    IND[[1L]] <- INDICES\n    names(IND) <- deparse(substitute(INDICES))[1L]\n  }\n  else IND <- INDICES\n  FUNx <- function(x) FUN(data[x, , drop = FALSE], ...)\n  nd <- nrow(data)\n  structure(eval(substitute(tapply(seq_len(nd), IND, FUNx, \n     simplify = simplify)), data), call = match.call(), class = "stby")\n}\n\n\n#\' @method stby default\n#\' @export\nstby.default <- function(data, INDICES, FUN, ..., simplify = TRUE) {\n  dd <- as.data.frame(data)\n  if (length(dim(data))) \n    by(dd, INDICES, FUN, ..., simplify = simplify)\n  else {\n    if (!is.list(INDICES)) {\n      IND <- vector("list", 1L)\n      IND[[1L]] <- INDICES\n      names(IND) <- deparse(substitute(INDICES))[1L]\n    }\n    else IND <- INDICES\n    FUNx <- function(x) FUN(dd[x, ], ...)\n    nd <- nrow(dd)\n    structure(eval(substitute(tapply(seq_len(nd), IND, FUNx, \n      simplify = simplify)), dd), call = match.call(), \n      class = "stby")\n  }\n}\n'