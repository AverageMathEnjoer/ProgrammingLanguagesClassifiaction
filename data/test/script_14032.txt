b'struct matrix{\n\tint n, m;\n\tvector<vi> mat;\n\tmatrix(){\n\t\t;\n\t}\n\tmatrix(int x, int y = 0, int iden = 0){\n\t\tn = x; m = y;\n\t\tif(y==0) m = n;\n\t\tmat = vector<vi>(n, vi(m, 0));\n\t\tif(iden){\n\t\t\tint i;\n\t\t\tfo(i, n) mat[i][i] = 1;\n\t\t}\n\t}\n\tvoid out(){\n\t\tint i, j;\n\t\tfo(i, n){fo(j, m)cout<<mat[i][j]<<" ";cout<<endl;}\n\t}\n\tint rowsum(int x){\n\t\tint i;\n\t\tll ans = 0;\n\t\tfo(i, m){\n\t\t\tans += mat[x][i];\n\t\t\tif (ans>=mod) ans -= mod;\n\t\t}\n\t\treturn ans;\n\t}\n\tint colsum(int x){\n\t\tint i;\n\t\tll ans = 0;\n\t\tfo(i, n){\n\t\t\tans += mat[i][x];\n\t\t\tif (ans>=mod) ans -= mod;\n\t\t}\n\t\treturn ans;\n\t}\n};\nmatrix operator *(matrix a, matrix b){\n\tmatrix c = matrix(a.n);\n\tint i, j, k, n = c.n;\n\tfo(i, n)fo(j, n){\n\t\tint &val = c.mat[i][j];\n\t\tval = 0;\n\t\tfo(k, n){\n\t\t\tval += (a.mat[i][k]*1LL*b.mat[k][j])%mod;\n\t\t\tif (val >= mod) val -= mod;\n\t\t}\n\t}\n\treturn c;\n}\nmatrix operator *(int a, matrix b){\n\tmatrix c = matrix(a.n);\n\tint i, j, k, n = c.n;\n\tfo(i, n)fo(j, n){\n\t\tint &val = c.mat[i][j];\n\t\tval = (a*b.mat[i][j])%mod;\n\t}\n\treturn c;\n}\nmatrix operator +(matrix a, matrix b){\n\tmatrix c = matrix(a.n);\n\tint i, j, k, n = c.n;\n\tfo(i, n)fo(j, n){\n\t\tint &val = c.mat[i][j];\n\t\tval = (a.mat[i][j]+b.mat[i][j]);\n\t\tif (val >= mod) val -= mod;\n\t}\n\treturn c;\n}\nmatrix operator -(matrix a, matrix b){\n\tmatrix c = matrix(a.n);\n\tint i, j, k, n = c.n;\n\tfo(i, n)fo(j, n){\n\t\tint &val = c.mat[i][j];\n\t\tval = (a.mat[i][j]-b.mat[i][j]);\n\t\tif (val >= mod) val -= mod;\n\t\tif (val < 0) val += mod;\n\t}\n\treturn c;\n}\nmatrix operator %(matrix M, int MOD)\n{\n\tmatrix temp(M.n);\n\tfor(int i=0;i<M.n;i++)\n\t\tfor(int j=0;j<M.n;j++)\n\t\t\ttemp.mat[i][j]=M.mat[i][j]%MOD;\n\treturn temp;\n}\nmatrix p(matrix &n,int m,int MOD = mod)\n{\n    if(m==0) \n\t\treturn matrix(n.n,n.n, 1);\n    matrix x=p(n,m/2,MOD);\n    if(m%2==0) \n       return x*x;\n    else\n       return x*x*n;\n}\n'