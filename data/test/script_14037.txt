b'package com.db.williamchart.renderer\n\nimport com.db.williamchart.ChartContract\nimport com.db.williamchart.Painter\nimport com.db.williamchart.animation.ChartAnimation\nimport com.db.williamchart.data.configuration.BarChartConfiguration\nimport com.db.williamchart.data.configuration.ChartConfiguration\nimport com.db.williamchart.data.DataPoint\nimport com.db.williamchart.data.Frame\nimport com.db.williamchart.data.Label\nimport com.db.williamchart.data.notInitialized\nimport com.db.williamchart.data.shouldDisplayAxisX\nimport com.db.williamchart.data.shouldDisplayAxisY\nimport com.db.williamchart.data.configuration.toOuterFrame\nimport com.db.williamchart.data.contains\nimport com.db.williamchart.data.withPaddings\nimport com.db.williamchart.extensions.maxValueBy\nimport com.db.williamchart.extensions.toBarScale\nimport com.db.williamchart.extensions.toDataPoints\nimport com.db.williamchart.extensions.toLabels\nimport com.db.williamchart.renderer.executor.DebugWithLabelsFrame\nimport com.db.williamchart.renderer.executor.DefineVerticalBarsClickableFrames\nimport com.db.williamchart.renderer.executor.GetVerticalBarBackgroundFrames\nimport com.db.williamchart.renderer.executor.GetVerticalBarFrames\nimport com.db.williamchart.renderer.executor.MeasureBarChartPaddings\n\nclass BarChartRenderer(\n    private val view: ChartContract.BarView,\n    private val painter: Painter,\n    private var animation: ChartAnimation<DataPoint>\n) : ChartContract.Renderer {\n\n    private var data = emptyList<DataPoint>()\n\n    private var zeroPositionY: Float = 0.0f\n\n    private lateinit var outerFrame: Frame\n\n    private lateinit var innerFrame: Frame\n\n    private lateinit var chartConfiguration: BarChartConfiguration\n\n    private lateinit var xLabels: List<Label>\n\n    private lateinit var yLabels: List<Label>\n\n    private lateinit var barsBackgroundFrames: List<Frame>\n\n    override fun preDraw(configuration: ChartConfiguration): Boolean {\n\n        if (data.isEmpty()) return true\n\n        chartConfiguration = configuration as BarChartConfiguration\n\n        if (chartConfiguration.scale.notInitialized())\n            chartConfiguration = chartConfiguration.copy(scale = data.toBarScale())\n\n        xLabels = data.toLabels()\n        val scaleStep = chartConfiguration.scale.size / RendererConstants.defaultScaleNumberOfSteps\n        yLabels = List(RendererConstants.defaultScaleNumberOfSteps + 1) {\n            val scaleValue = chartConfiguration.scale.min + scaleStep * it\n            Label(\n                label = chartConfiguration.labelsFormatter(scaleValue),\n                screenPositionX = 0F,\n                screenPositionY = 0F\n            )\n        }\n\n        val longestChartLabelWidth =\n            yLabels.maxValueBy {\n                painter.measureLabelWidth(\n                    it.label,\n                    chartConfiguration.labelsSize\n                )\n            }\n                ?: throw IllegalArgumentException("Looks like there\'s no labels to find the longest width.")\n\n        val paddings = MeasureBarChartPaddings()(\n            axisType = chartConfiguration.axis,\n            labelsHeight = painter.measureLabelHeight(chartConfiguration.labelsSize),\n            longestLabelWidth = longestChartLabelWidth,\n            labelsPaddingToInnerChart = RendererConstants.labelsPaddingToInnerChart\n        )\n\n        outerFrame = chartConfiguration.toOuterFrame()\n        innerFrame = outerFrame.withPaddings(paddings)\n\n        zeroPositionY =\n            processZeroPositionY(\n                innerTop = innerFrame.top,\n                innerBottom = innerFrame.bottom,\n                scaleRange = chartConfiguration.scale.size\n            )\n\n        placeLabelsX(innerFrame)\n        placeLabelsY(innerFrame)\n        placeDataPoints(innerFrame, zeroPositionY)\n\n        barsBackgroundFrames =\n            GetVerticalBarBackgroundFrames()(\n                innerFrame,\n                chartConfiguration.barsSpacing,\n                data\n            )\n\n        animation.animateFrom(zeroPositionY, data) { view.postInvalidate() }\n\n        return false\n    }\n\n    override fun draw() {\n\n        if (data.isEmpty()) return\n\n        if (chartConfiguration.axis.shouldDisplayAxisX())\n            view.drawLabels(xLabels)\n\n        if (chartConfiguration.axis.shouldDisplayAxisY())\n            view.drawLabels(yLabels)\n\n        view.drawGrid(\n            innerFrame,\n            xLabels.map { it.screenPositionX },\n            yLabels.map { it.screenPositionY }\n        )\n\n        if (chartConfiguration.barsBackgroundColor != -1)\n            view.drawBarsBackground(barsBackgroundFrames)\n\n        view.drawBars(\n            GetVerticalBarFrames()(\n                innerFrame,\n                zeroPositionY,\n                chartConfiguration.barsSpacing,\n                data\n            )\n        )\n\n        if (RendererConstants.inDebug) {\n            view.drawDebugFrame(\n                listOf(outerFrame, innerFrame) +\n                    DebugWithLabelsFrame()(\n                        painter = painter,\n                        axisType = chartConfiguration.axis,\n                        xLabels = xLabels,\n                        yLabels = yLabels,\n                        labelsSize = chartConfiguration.labelsSize\n                    ) +\n                    DefineVerticalBarsClickableFrames()(\n                        innerFrame,\n                        data.map { Pair(it.screenPositionX, it.screenPositionY) }\n                    ) +\n                    Frame(innerFrame.left, zeroPositionY, innerFrame.right, zeroPositionY)\n            )\n        }\n    }\n\n    override fun render(entries: List<Pair<String, Float>>) {\n        data = entries.toDataPoints()\n        view.postInvalidate()\n    }\n\n    override fun anim(entries: List<Pair<String, Float>>, animation: ChartAnimation<DataPoint>) {\n        data = entries.toDataPoints()\n        this.animation = animation\n        view.postInvalidate()\n    }\n\n    override fun processClick(x: Float?, y: Float?): Triple<Int, Float, Float> {\n\n        if (x == null || y == null || data.isEmpty())\n            return Triple(-1, -1f, -1f)\n\n        val index =\n            DefineVerticalBarsClickableFrames()(\n                innerFrame,\n                data.map { Pair(it.screenPositionX, it.screenPositionY) }\n            )\n                .indexOfFirst { it.contains(x, y) }\n\n        return if (index != -1)\n            Triple(index, data[index].screenPositionX, data[index].screenPositionY)\n        else Triple(-1, -1f, -1f)\n    }\n\n    override fun processTouch(x: Float?, y: Float?): Triple<Int, Float, Float> = processClick(x, y)\n\n    private fun placeLabelsX(innerFrame: Frame) {\n\n        val halfBarWidth = (innerFrame.right - innerFrame.left) / xLabels.size / 2\n        val labelsLeftPosition = innerFrame.left + halfBarWidth\n        val labelsRightPosition = innerFrame.right - halfBarWidth\n        val widthBetweenLabels = (labelsRightPosition - labelsLeftPosition) / (xLabels.size - 1)\n        val xLabelsVerticalPosition =\n            innerFrame.bottom -\n                painter.measureLabelAscent(chartConfiguration.labelsSize) +\n                RendererConstants.labelsPaddingToInnerChart\n\n        xLabels.forEachIndexed { index, label ->\n            label.screenPositionX = labelsLeftPosition + (widthBetweenLabels * index)\n            label.screenPositionY = xLabelsVerticalPosition\n        }\n    }\n\n    private fun placeLabelsY(innerFrame: Frame) {\n\n        val heightBetweenLabels =\n            (innerFrame.bottom - innerFrame.top) / RendererConstants.defaultScaleNumberOfSteps\n        val labelsBottomPosition =\n            innerFrame.bottom + painter.measureLabelHeight(chartConfiguration.labelsSize) / 2\n\n        yLabels.forEachIndexed { index, label ->\n            label.screenPositionX =\n                innerFrame.left -\n                    RendererConstants.labelsPaddingToInnerChart -\n                    painter.measureLabelWidth(label.label, chartConfiguration.labelsSize) / 2\n            label.screenPositionY = labelsBottomPosition - heightBetweenLabels * index\n        }\n    }\n\n    private fun placeDataPoints(\n        innerFrame: Frame,\n        zeroPositionY: Float\n    ) {\n        // Chart upper part with positive points\n        val positiveHeight = zeroPositionY - innerFrame.top\n        val positiveScale = chartConfiguration.scale.max\n\n        // Chart bottom part with negative points\n        val negativeHeight = innerFrame.bottom - zeroPositionY\n        val negativeScale = chartConfiguration.scale.min\n\n        val halfBarWidth = (innerFrame.right - innerFrame.left) / xLabels.size / 2\n        val labelsLeftPosition = innerFrame.left + halfBarWidth\n        val labelsRightPosition = innerFrame.right - halfBarWidth\n        val widthBetweenLabels = (labelsRightPosition - labelsLeftPosition) / (xLabels.size - 1)\n\n        data.forEachIndexed { index, dataPoint ->\n            dataPoint.screenPositionX = labelsLeftPosition + (widthBetweenLabels * index)\n            dataPoint.screenPositionY =\n                if (dataPoint.value >= 0f)\n                    zeroPositionY - (positiveHeight * dataPoint.value / positiveScale) // Positive\n                else zeroPositionY + (negativeHeight * dataPoint.value / negativeScale) // Negative\n        }\n    }\n\n    private fun processZeroPositionY(\n        innerTop: Float,\n        innerBottom: Float,\n        scaleRange: Float\n    ): Float {\n        val chartHeight = innerBottom - innerTop\n        return innerTop + (chartHeight * chartConfiguration.scale.max / scaleRange)\n    }\n}\n'