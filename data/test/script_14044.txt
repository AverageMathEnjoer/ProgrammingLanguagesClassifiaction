b'// I2Cdev library collection - Main I2C device class\n// Abstracts bit and byte I2C R/W functions into a convenient class\n// 6/9/2012 by Jeff Rowberg <jeff@rowberg.net>\n//\n// Changelog:\n//     2012-06-09 - fix major issue with reading > 32 bytes at a time with Arduino Wire\n//                - add compiler warnings when using outdated or IDE or limited I2Cdev implementation\n//     2011-11-01 - fix write*Bits mask calculation (thanks sasquatch @ Arduino forums)\n//     2011-10-03 - added automatic Arduino version detection for ease of use\n//     2011-10-02 - added Gene Knight\'s NBWire TwoWire class implementation with small modifications\n//     2011-08-31 - added support for Arduino 1.0 Wire library (methods are different from 0.x)\n//     2011-08-03 - added optional timeout parameter to read* methods to easily change from default\n//     2011-08-02 - added support for 16-bit registers\n//                - fixed incorrect Doxygen comments on some methods\n//                - added timeout value for read operations (thanks mem @ Arduino forums)\n//     2011-07-30 - changed read/write function structures to return success or byte counts\n//                - made all methods static for multi-device memory savings\n//     2011-07-28 - initial release\n\n/* ============================================\nI2Cdev device library code is placed under the MIT license\nCopyright (c) 2012 Jeff Rowberg\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the "Software"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n===============================================\n*/\n\n#include "I2Cdev.h"\n\n#if I2CDEV_IMPLEMENTATION == I2CDEV_ARDUINO_WIRE\n\n    #ifdef I2CDEV_IMPLEMENTATION_WARNINGS\n        #if ARDUINO < 100\n            #warn Using outdated Arduino IDE with Wire library is functionally limiting.\n            #warn Arduino IDE v1.0.1+ with I2Cdev Fastwire implementation is recommended.\n            #warn This I2Cdev implementation does not support:\n            #warn - Repeated starts conditions\n            #warn - Timeout detection (some Wire requests block forever)\n        #elif ARDUINO == 100\n            #warn Using outdated Arduino IDE with Wire library is functionally limiting.\n            #warn Arduino IDE v1.0.1+ with I2Cdev Fastwire implementation is recommended.\n            #warn This I2Cdev implementation does not support:\n            #warn - Repeated starts conditions\n            #warn - Timeout detection (some Wire requests block forever)\n        #elif ARDUINO > 100\n            /*\n            #warning Using current Arduino IDE with Wire library is functionally limiting.\n            #warning Arduino IDE v1.0.1+ with I2CDEV_BUILTIN_FASTWIRE implementation is recommended.\n            #warning This I2Cdev implementation does not support:\n            #warning - Timeout detection (some Wire requests block forever)\n            */\n        #endif\n    #endif\n\n#elif I2CDEV_IMPLEMENTATION == I2CDEV_BUILTIN_FASTWIRE\n\n    #error The I2CDEV_BUILTIN_FASTWIRE implementation is known to be broken right now. Patience, Iago!\n\n#elif I2CDEV_IMPLEMENTATION == I2CDEV_BUILTIN_NBWIRE\n\n    #ifdef I2CDEV_IMPLEMENTATION_WARNINGS\n        #warn Using I2CDEV_BUILTIN_NBWIRE implementation may adversely affect interrupt detection.\n        #warn This I2Cdev implementation does not support:\n        #warn - Repeated starts conditions\n    #endif\n\n    // NBWire implementation based heavily on code by Gene Knight <Gene@Telobot.com>\n    // Originally posted on the Arduino forum at http://arduino.cc/forum/index.php/topic,70705.0.html\n    // Originally offered to the i2cdevlib project at http://arduino.cc/forum/index.php/topic,68210.30.html\n    TwoWire Wire;\n\n#endif\n\n/** Default constructor.\n */\nI2Cdev::I2Cdev() {\n\n}\n\n/** Read a single bit from an 8-bit device register.\n * @param devAddr I2C slave device address\n * @param regAddr Register regAddr to read from\n * @param bitNum Bit position to read (0-7)\n * @param data Container for single bit value\n * @param timeout Optional read timeout in milliseconds (0 to disable, leave off to use default class value in I2Cdev::readTimeout)\n * @return Status of read operation (true = success)\n */\nint8_t I2Cdev::readBit(uint8_t devAddr, uint8_t regAddr, uint8_t bitNum, uint8_t *data, uint16_t timeout) {\n    uint8_t b;\n    uint8_t count = readByte(devAddr, regAddr, &b, timeout);\n    *data = b & (1 << bitNum);\n    return count;\n}\n\n/** Read a single bit from a 16-bit device register.\n * @param devAddr I2C slave device address\n * @param regAddr Register regAddr to read from\n * @param bitNum Bit position to read (0-15)\n * @param data Container for single bit value\n * @param timeout Optional read timeout in milliseconds (0 to disable, leave off to use default class value in I2Cdev::readTimeout)\n * @return Status of read operation (true = success)\n */\nint8_t I2Cdev::readBitW(uint8_t devAddr, uint8_t regAddr, uint8_t bitNum, uint16_t *data, uint16_t timeout) {\n    uint16_t b;\n    uint8_t count = readWord(devAddr, regAddr, &b, timeout);\n    *data = b & (1 << bitNum);\n    return count;\n}\n\n/** Read multiple bits from an 8-bit device register.\n * @param devAddr I2C slave device address\n * @param regAddr Register regAddr to read from\n * @param bitStart First bit position to read (0-7)\n * @param length Number of bits to read (not more than 8)\n * @param data Container for right-aligned value (i.e. \'101\' read from any bitStart position will equal 0x05)\n * @param timeout Optional read timeout in milliseconds (0 to disable, leave off to use default class value in I2Cdev::readTimeout)\n * @return Status of read operation (true = success)\n */\nint8_t I2Cdev::readBits(uint8_t devAddr, uint8_t regAddr, uint8_t bitStart, uint8_t length, uint8_t *data, uint16_t timeout) {\n    // 01101001 read byte\n    // 76543210 bit numbers\n    //    xxx   args: bitStart=4, length=3\n    //    010   masked\n    //   -> 010 shifted\n    uint8_t count, b;\n    if ((count = readByte(devAddr, regAddr, &b, timeout)) != 0) {\n        uint8_t mask = ((1 << length) - 1) << (bitStart - length + 1);\n        b &= mask;\n        b >>= (bitStart - length + 1);\n        *data = b;\n    }\n    return count;\n}\n\n/** Read multiple bits from a 16-bit device register.\n * @param devAddr I2C slave device address\n * @param regAddr Register regAddr to read from\n * @param bitStart First bit position to read (0-15)\n * @param length Number of bits to read (not more than 16)\n * @param data Container for right-aligned value (i.e. \'101\' read from any bitStart position will equal 0x05)\n * @param timeout Optional read timeout in milliseconds (0 to disable, leave off to use default class value in I2Cdev::readTimeout)\n * @return Status of read operation (1 = success, 0 = failure, -1 = timeout)\n */\nint8_t I2Cdev::readBitsW(uint8_t devAddr, uint8_t regAddr, uint8_t bitStart, uint8_t length, uint16_t *data, uint16_t timeout) {\n    // 1101011001101001 read byte\n    // fedcba9876543210 bit numbers\n    //    xxx           args: bitStart=12, length=3\n    //    010           masked\n    //           -> 010 shifted\n    uint8_t count;\n    uint16_t w;\n    if ((count = readWord(devAddr, regAddr, &w, timeout)) != 0) {\n        uint16_t mask = ((1 << length) - 1) << (bitStart - length + 1);\n        w &= mask;\n        w >>= (bitStart - length + 1);\n        *data = w;\n    }\n    return count;\n}\n\n/** Read single byte from an 8-bit device register.\n * @param devAddr I2C slave device address\n * @param regAddr Register regAddr to read from\n * @param data Container for byte value read from device\n * @param timeout Optional read timeout in milliseconds (0 to disable, leave off to use default class value in I2Cdev::readTimeout)\n * @return Status of read operation (true = success)\n */\nint8_t I2Cdev::readByte(uint8_t devAddr, uint8_t regAddr, uint8_t *data, uint16_t timeout) {\n    return readBytes(devAddr, regAddr, 1, data, timeout);\n}\n\n/** Read single word from a 16-bit device register.\n * @param devAddr I2C slave device address\n * @param regAddr Register regAddr to read from\n * @param data Container for word value read from device\n * @param timeout Optional read timeout in milliseconds (0 to disable, leave off to use default class value in I2Cdev::readTimeout)\n * @return Status of read operation (true = success)\n */\nint8_t I2Cdev::readWord(uint8_t devAddr, uint8_t regAddr, uint16_t *data, uint16_t timeout) {\n    return readWords(devAddr, regAddr, 1, data, timeout);\n}\n\n/** Read multiple bytes from an 8-bit device register.\n * @param devAddr I2C slave device address\n * @param regAddr First register regAddr to read from\n * @param length Number of bytes to read\n * @param data Buffer to store read data in\n * @param timeout Optional read timeout in milliseconds (0 to disable, leave off to use default class value in I2Cdev::readTimeout)\n * @return Number of bytes read (-1 indicates failure)\n */\nint8_t I2Cdev::readBytes(uint8_t devAddr, uint8_t regAddr, uint8_t length, uint8_t *data, uint16_t timeout) {\n    #ifdef I2CDEV_SERIAL_DEBUG\n        Serial.print("I2C (0x");\n        Serial.print(devAddr, HEX);\n        Serial.print(") reading ");\n        Serial.print(length, DEC);\n        Serial.print(" bytes from 0x");\n        Serial.print(regAddr, HEX);\n        Serial.print("...");\n    #endif\n\n    int8_t count = 0;\n    uint32_t t1 = millis();\n\n    #if (I2CDEV_IMPLEMENTATION == I2CDEV_ARDUINO_WIRE)\n\n        #if (ARDUINO < 100)\n            // Arduino v00xx (before v1.0), Wire library\n\n            // I2C/TWI subsystem uses internal buffer that breaks with large data requests\n            // so if user requests more than I2CDEVLIB_WIRE_BUFFER_LENGTH bytes, we have to do it in\n            // smaller chunks instead of all at once\n            for (uint8_t k = 0; k < length; k += min(length, I2CDEVLIB_WIRE_BUFFER_LENGTH)) {\n                Wire.beginTransmission(devAddr);\n                Wire.send(regAddr);\n                Wire.endTransmission();\n                Wire.requestFrom(devAddr, (uint8_t)min(length - k, I2CDEVLIB_WIRE_BUFFER_LENGTH));\n                for (; Wire.available() && (timeout == 0 || millis() - t1 < timeout); count++) {\n                    data[count] = Wire.receive();\n                    #ifdef I2CDEV_SERIAL_DEBUG\n                        Serial.print(data[count], HEX);\n                        if (count + 1 < length) Serial.print(" ");\n                    #endif\n                }\n            }\n        #elif (ARDUINO == 100)\n            // Arduino v1.0.0, Wire library\n            // Adds standardized write() and read() stream methods instead of send() and receive()\n\n            // I2C/TWI subsystem uses internal buffer that breaks with large data requests\n            // so if user requests more than I2CDEVLIB_WIRE_BUFFER_LENGTH bytes, we have to do it in\n            // smaller chunks instead of all at once\n            for (uint8_t k = 0; k < length; k += min(length, I2CDEVLIB_WIRE_BUFFER_LENGTH)) {\n                Wire.beginTransmission(devAddr);\n                Wire.write(regAddr);\n                Wire.endTransmission();\n                Wire.requestFrom(devAddr, (uint8_t)min(length - k, I2CDEVLIB_WIRE_BUFFER_LENGTH));\n                for (; Wire.available() && (timeout == 0 || millis() - t1 < timeout); count++) {\n                    data[count] = Wire.read();\n                    #ifdef I2CDEV_SERIAL_DEBUG\n                        Serial.print(data[count], HEX);\n                        if (count + 1 < length) Serial.print(" ");\n                    #endif\n                }\n            }\n        #elif (ARDUINO > 100)\n            // Arduino v1.0.1+, Wire library\n            // Adds official support for repeated start condition, yay!\n\n            // I2C/TWI subsystem uses internal buffer that breaks with large data requests\n            // so if user requests more than I2CDEVLIB_WIRE_BUFFER_LENGTH bytes, we have to do it in\n            // smaller chunks instead of all at once\n            for (uint8_t k = 0; k < length; k += min(length, I2CDEVLIB_WIRE_BUFFER_LENGTH)) {\n                Wire.beginTransmission(devAddr);\n                Wire.write(regAddr);\n                Wire.endTransmission();\n                Wire.requestFrom(devAddr, (uint8_t)min(length - k, I2CDEVLIB_WIRE_BUFFER_LENGTH));\n                for (; Wire.available() && (timeout == 0 || millis() - t1 < timeout); count++) {\n                    data[count] = Wire.read();\n                    #ifdef I2CDEV_SERIAL_DEBUG\n                        Serial.print(data[count], HEX);\n                        if (count + 1 < length) Serial.print(" ");\n                    #endif\n                }\n            }\n        #endif\n\n    #elif (I2CDEV_IMPLEMENTATION == I2CDEV_BUILTIN_FASTWIRE)\n        // Fastwire library (STILL UNDER DEVELOPMENT, NON-FUNCTIONAL!)\n\n        // no loop required for fastwire\n        uint8_t status = Fastwire::readBuf(devAddr, regAddr, data, length);\n        if (status == 0) {\n            count = length; // success\n        } else {\n            count = -1; // error\n        }\n\t#elif (I2CDEV_IMPLEMENTATION == I2CDEV_MSP430)\n\n        I2C_readBytesFromAddress(devAddr, regAddr, length, data);\n\n\t\tcount = length; //TODO implement something meaningful, for now just making sure no error is thrown\n\t\n    #endif\n\n    // check for timeout\n    if (timeout > 0 && millis() - t1 >= timeout && count < length) count = -1; // timeout\n\n    #ifdef I2CDEV_SERIAL_DEBUG\n        Serial.print(". Done (");\n        Serial.print(count, DEC);\n        Serial.println(" read).");\n    #endif\n\n    return count;\n}\n\n/** Read multiple words from a 16-bit device register.\n * @param devAddr I2C slave device address\n * @param regAddr First register regAddr to read from\n * @param length Number of words to read\n * @param data Buffer to store read data in\n * @param timeout Optional read timeout in milliseconds (0 to disable, leave off to use default class value in I2Cdev::readTimeout)\n * @return Number of words read (0 indicates failure)\n */\nint8_t I2Cdev::readWords(uint8_t devAddr, uint8_t regAddr, uint8_t length, uint16_t *data, uint16_t timeout) {\n    #ifdef I2CDEV_SERIAL_DEBUG\n        Serial.print("I2C (0x");\n        Serial.print(devAddr, HEX);\n        Serial.print(") reading ");\n        Serial.print(length, DEC);\n        Serial.print(" words from 0x");\n        Serial.print(regAddr, HEX);\n        Serial.print("...");\n    #endif\n\n    int8_t count = 0;\n    uint32_t t1 = millis();\n\n    #if (I2CDEV_IMPLEMENTATION == I2CDEV_ARDUINO_WIRE)\n\n        #if (ARDUINO < 100)\n            // Arduino v00xx (before v1.0), Wire library\n\n            // I2C/TWI subsystem uses internal buffer that breaks with large data requests\n            // so if user requests more than I2CDEVLIB_WIRE_BUFFER_LENGTH bytes, we have to do it in\n            // smaller chunks instead of all at once\n            for (uint8_t k = 0; k < length * 2; k += min(length * 2, I2CDEVLIB_WIRE_BUFFER_LENGTH)) {\n                Wire.beginTransmission(devAddr);\n                Wire.send(regAddr);\n                Wire.endTransmission();\n                Wire.requestFrom(devAddr, (uint8_t)(length * 2)); // length=words, this wants bytes\n    \n                bool msb = true; // starts with MSB, then LSB\n                for (; Wire.available() && count < length && (timeout == 0 || millis() - t1 < timeout);) {\n                    if (msb) {\n                        // first byte is bits 15-8 (MSb=15)\n                        data[count] = Wire.receive() << 8;\n                    } else {\n                        // second byte is bits 7-0 (LSb=0)\n                        data[count] |= Wire.receive();\n                        #ifdef I2CDEV_SERIAL_DEBUG\n                            Serial.print(data[count], HEX);\n                            if (count + 1 < length) Serial.print(" ");\n                        #endif\n                        count++;\n                    }\n                    msb = !msb;\n                }\n            }\n        #elif (ARDUINO == 100)\n            // Arduino v1.0.0, Wire library\n            // Adds standardized write() and read() stream methods instead of send() and receive()\n    \n            // I2C/TWI subsystem uses internal buffer that breaks with large data requests\n            // so if user requests more than I2CDEVLIB_WIRE_BUFFER_LENGTH bytes, we have to do it in\n            // smaller chunks instead of all at once\n            for (uint8_t k = 0; k < length * 2; k += min(length * 2, I2CDEVLIB_WIRE_BUFFER_LENGTH)) {\n                Wire.beginTransmission(devAddr);\n                Wire.write(regAddr);\n                Wire.endTransmission();\n                Wire.requestFrom(devAddr, (uint8_t)(length * 2)); // length=words, this wants bytes\n    \n                bool msb = true; // starts with MSB, then LSB\n                for (; Wire.available() && count < length && (timeout == 0 || millis() - t1 < timeout);) {\n                    if (msb) {\n                        // first byte is bits 15-8 (MSb=15)\n                        data[count] = Wire.read() << 8;\n                    } else {\n                        // second byte is bits 7-0 (LSb=0)\n                        data[count] |= Wire.read();\n                        #ifdef I2CDEV_SERIAL_DEBUG\n                            Serial.print(data[count], HEX);\n                            if (count + 1 < length) Serial.print(" ");\n                        #endif\n                        count++;\n                    }\n                    msb = !msb;\n                }\n            }\n        #elif (ARDUINO > 100)\n            // Arduino v1.0.1+, Wire library\n            // Adds official support for repeated start condition, yay!\n\n            // I2C/TWI subsystem uses internal buffer that breaks with large data requests\n            // so if user requests more than I2CDEVLIB_WIRE_BUFFER_LENGTH bytes, we have to do it in\n            // smaller chunks instead of all at once\n            for (uint8_t k = 0; k < length * 2; k += min(length * 2, I2CDEVLIB_WIRE_BUFFER_LENGTH)) {\n                Wire.beginTransmission(devAddr);\n                Wire.write(regAddr);\n                Wire.endTransmission();\n                Wire.requestFrom(devAddr, (uint8_t)(length * 2)); // length=words, this wants bytes\n        \n                bool msb = true; // starts with MSB, then LSB\n                for (; Wire.available() && count < length && (timeout == 0 || millis() - t1 < timeout);) {\n                    if (msb) {\n                        // first byte is bits 15-8 (MSb=15)\n                        data[count] = Wire.read() << 8;\n                    } else {\n                        // second byte is bits 7-0 (LSb=0)\n                        data[count] |= Wire.read();\n                        #ifdef I2CDEV_SERIAL_DEBUG\n                            Serial.print(data[count], HEX);\n                            if (count + 1 < length) Serial.print(" ");\n                        #endif\n                        count++;\n                    }\n                    msb = !msb;\n                }\n            }\n        #endif\n\n    #elif (I2CDEV_IMPLEMENTATION == I2CDEV_BUILTIN_FASTWIRE)\n        // Fastwire library (STILL UNDER DEVELOPMENT, NON-FUNCTIONAL!)\n\n        // no loop required for fastwire\n        uint16_t intermediate[(uint8_t)length];\n        uint8_t status = Fastwire::readBuf(devAddr, regAddr, (uint8_t *)intermediate, (uint8_t)(length * 2));\n        if (status == 0) {\n            count = length; // success\n            for (uint8_t i = 0; i < length; i++) {\n                data[i] = (intermediate[2*i] << 8) | intermediate[2*i + 1];\n            }\n        } else {\n            count = -1; // error\n        }\n\n\t#elif (I2CDEV_IMPLEMENTATION == I2CDEV_MSP430)\n       //TODO implement\n\n    #endif\n\n    if (timeout > 0 && millis() - t1 >= timeout && count < length) count = -1; // timeout\n\n    #ifdef I2CDEV_SERIAL_DEBUG\n        Serial.print(". Done (");\n        Serial.print(count, DEC);\n        Serial.println(" read).");\n    #endif\n    \n    return count;\n}\n\n/** write a single bit in an 8-bit device register.\n * @param devAddr I2C slave device address\n * @param regAddr Register regAddr to write to\n * @param bitNum Bit position to write (0-7)\n * @param value New bit value to write\n * @return Status of operation (true = success)\n */\nbool I2Cdev::writeBit(uint8_t devAddr, uint8_t regAddr, uint8_t bitNum, uint8_t data) {\n    uint8_t b;\n    readByte(devAddr, regAddr, &b);\n    b = (data != 0) ? (b | (1 << bitNum)) : (b & ~(1 << bitNum));\n    return writeByte(devAddr, regAddr, b);\n}\n\n/** write a single bit in a 16-bit device register.\n * @param devAddr I2C slave device address\n * @param regAddr Register regAddr to write to\n * @param bitNum Bit position to write (0-15)\n * @param value New bit value to write\n * @return Status of operation (true = success)\n */\nbool I2Cdev::writeBitW(uint8_t devAddr, uint8_t regAddr, uint8_t bitNum, uint16_t data) {\n    uint16_t w;\n    readWord(devAddr, regAddr, &w);\n    w = (data != 0) ? (w | (1 << bitNum)) : (w & ~(1 << bitNum));\n    return writeWord(devAddr, regAddr, w);\n}\n\n/** Write multiple bits in an 8-bit device register.\n * @param devAddr I2C slave device address\n * @param regAddr Register regAddr to write to\n * @param bitStart First bit position to write (0-7)\n * @param length Number of bits to write (not more than 8)\n * @param data Right-aligned value to write\n * @return Status of operation (true = success)\n */\nbool I2Cdev::writeBits(uint8_t devAddr, uint8_t regAddr, uint8_t bitStart, uint8_t length, uint8_t data) {\n    //      010 value to write\n    // 76543210 bit numbers\n    //    xxx   args: bitStart=4, length=3\n    // 00011100 mask byte\n    // 10101111 original value (sample)\n    // 10100011 original & ~mask\n    // 10101011 masked | value\n    uint8_t b;\n    if (readByte(devAddr, regAddr, &b) != 0) {\n        uint8_t mask = ((1 << length) - 1) << (bitStart - length + 1);\n        data <<= (bitStart - length + 1); // shift data into correct position\n        data &= mask; // zero all non-important bits in data\n        b &= ~(mask); // zero all important bits in existing byte\n        b |= data; // combine data with existing byte\n        return writeByte(devAddr, regAddr, b);\n    } else {\n        return false;\n    }\n}\n\n/** Write multiple bits in a 16-bit device register.\n * @param devAddr I2C slave device address\n * @param regAddr Register regAddr to write to\n * @param bitStart First bit position to write (0-15)\n * @param length Number of bits to write (not more than 16)\n * @param data Right-aligned value to write\n * @return Status of operation (true = success)\n */\nbool I2Cdev::writeBitsW(uint8_t devAddr, uint8_t regAddr, uint8_t bitStart, uint8_t length, uint16_t data) {\n    //              010 value to write\n    // fedcba9876543210 bit numbers\n    //    xxx           args: bitStart=12, length=3\n    // 0001110000000000 mask byte\n    // 1010111110010110 original value (sample)\n    // 1010001110010110 original & ~mask\n    // 1010101110010110 masked | value\n    uint16_t w;\n    if (readWord(devAddr, regAddr, &w) != 0) {\n        uint8_t mask = ((1 << length) - 1) << (bitStart - length + 1);\n        data <<= (bitStart - length + 1); // shift data into correct position\n        data &= mask; // zero all non-important bits in data\n        w &= ~(mask); // zero all important bits in existing word\n        w |= data; // combine data with existing word\n        return writeWord(devAddr, regAddr, w);\n    } else {\n        return false;\n    }\n}\n\n/** Write single byte to an 8-bit device register.\n * @param devAddr I2C slave device address\n * @param regAddr Register address to write to\n * @param data New byte value to write\n * @return Status of operation (true = success)\n */\nbool I2Cdev::writeByte(uint8_t devAddr, uint8_t regAddr, uint8_t data) {\n    return writeBytes(devAddr, regAddr, 1, &data);\n}\n\n/** Write single word to a 16-bit device register.\n * @param devAddr I2C slave device address\n * @param regAddr Register address to write to\n * @param data New word value to write\n * @return Status of operation (true = success)\n */\nbool I2Cdev::writeWord(uint8_t devAddr, uint8_t regAddr, uint16_t data) {\n    return writeWords(devAddr, regAddr, 1, &data);\n}\n\n/** Write multiple bytes to an 8-bit device register.\n * @param devAddr I2C slave device address\n * @param regAddr First register address to write to\n * @param length Number of bytes to write\n * @param data Buffer to copy new data from\n * @return Status of operation (true = success)\n */\nbool I2Cdev::writeBytes(uint8_t devAddr, uint8_t regAddr, uint8_t length, uint8_t* data) {\n    #ifdef I2CDEV_SERIAL_DEBUG\n        Serial.print("I2C (0x");\n        Serial.print(devAddr, HEX);\n        Serial.print(") writing ");\n        Serial.print(length, DEC);\n        Serial.print(" bytes to 0x");\n        Serial.print(regAddr, HEX);\n        Serial.print("...");\n    #endif\n    uint8_t status = 0;\n    #if ((I2CDEV_IMPLEMENTATION == I2CDEV_ARDUINO_WIRE && ARDUINO < 100) || I2CDEV_IMPLEMENTATION == I2CDEV_BUILTIN_NBWIRE)\n        Wire.beginTransmission(devAddr);\n        Wire.send((uint8_t) regAddr); // send address\n    #elif (I2CDEV_IMPLEMENTATION == I2CDEV_ARDUINO_WIRE && ARDUINO >= 100)\n        Wire.beginTransmission(devAddr);\n        Wire.write((uint8_t) regAddr); // send address\n    #endif\n    for (uint8_t i = 0; i < length; i++) {\n        #if ((I2CDEV_IMPLEMENTATION == I2CDEV_ARDUINO_WIRE && ARDUINO < 100) || I2CDEV_IMPLEMENTATION == I2CDEV_BUILTIN_NBWIRE)\n            Wire.send((uint8_t) data[i]);\n        #elif (I2CDEV_IMPLEMENTATION == I2CDEV_ARDUINO_WIRE && ARDUINO >= 100)\n            Wire.write((uint8_t) data[i]);\n        #elif (I2CDEV_IMPLEMENTATION == I2CDEV_BUILTIN_FASTWIRE)\n            status = Fastwire::write(devAddr, regAddr, data[i]);\n            Serial.println(status);\n        #endif\n        #ifdef I2CDEV_SERIAL_DEBUG\n            Serial.print(data[i], HEX);\n            if (i + 1 < length) Serial.print(" ");\n        #endif\n    }\n    #if ((I2CDEV_IMPLEMENTATION == I2CDEV_ARDUINO_WIRE && ARDUINO < 100) || I2CDEV_IMPLEMENTATION == I2CDEV_BUILTIN_NBWIRE)\n        Wire.endTransmission();\n    #elif (I2CDEV_IMPLEMENTATION == I2CDEV_ARDUINO_WIRE && ARDUINO >= 100)\n        status = Wire.endTransmission();\n    #endif\n    #ifdef I2CDEV_SERIAL_DEBUG\n        Serial.println(". Done.");\n    #endif\n\n\t#if (I2CDEV_IMPLEMENTATION == I2CDEV_MSP430)\n//        unsigned char d[2];\t\t//dummy field to hold regAddr\n//        d[0]=regAddr;\n//\n//        USCI_I2C_transmitinit(devAddr, I2C_PRESCALE);\n//        while ( USCI_I2C_notready() );         // wait for bus to be free\n//        USCI_I2C_transmit(1,d);                // send address\n//        while ( USCI_I2C_notready() );         // wait for bus to be free\n//        USCI_I2C_transmit(length,data);       // start transmitting\n\n        I2C_writeBytesToAddress(devAddr, regAddr, length, data);\n\n\t#endif\n    return status == 0;\n}\n\n/** Write multiple words to a 16-bit device register.\n * @param devAddr I2C slave device address\n * @param regAddr First register address to write to\n * @param length Number of words to write\n * @param data Buffer to copy new data from\n * @return Status of operation (true = success)\n */\nbool I2Cdev::writeWords(uint8_t devAddr, uint8_t regAddr, uint8_t length, uint16_t* data) {\n    #ifdef I2CDEV_SERIAL_DEBUG\n        Serial.print("I2C (0x");\n        Serial.print(devAddr, HEX);\n        Serial.print(") writing ");\n        Serial.print(length, DEC);\n        Serial.print(" words to 0x");\n        Serial.print(regAddr, HEX);\n        Serial.print("...");\n    #endif\n    uint8_t status = 0;\n    #if ((I2CDEV_IMPLEMENTATION == I2CDEV_ARDUINO_WIRE && ARDUINO < 100) || I2CDEV_IMPLEMENTATION == I2CDEV_BUILTIN_NBWIRE)\n        Wire.beginTransmission(devAddr);\n        Wire.send(regAddr); // send address\n    #elif (I2CDEV_IMPLEMENTATION == I2CDEV_ARDUINO_WIRE && ARDUINO >= 100)\n        Wire.beginTransmission(devAddr);\n        Wire.write(regAddr); // send address\n\t#elif (I2CDEV_IMPLEMENTATION == I2CDEV_MSP430)\n\n//        //Specify slave address\n//\t\tI2C_setSlaveAddress(devAddr);\n//\n//\t\t//Set in transmit mode\n//\t\tI2C_setMode(I2C_TRANSMIT_MODE);\n//\n//\t\t//Enable I2C Module to start operations\n//\t\tI2C_enable();\n//\n//\t\t//Enable TX interrupt\n//\t\tI2C_enableInterrupt(I2C_TRANSMIT_INTERRUPT);\n//\n//\t\t//Set transmit length\n//\t\tTXLENGTH = 1;\n//\t\t//Load TX byte counter\n//\t\ttransmitCounter = 1;\n//\t\ttransmitData[0] = regAddr;\n//\n//\t\t//Initiate start and send first character\n//\t\tI2C_masterMultiByteSendStart(transmitData[0]);\n//\n//\t\t//Delay until transmission completes\n//\t\twhile (I2C_isBusBusy()) ;\n//todo implement\n\n    #endif\n    for (uint8_t i = 0; i < length * 2; i++) {\n        #if ((I2CDEV_IMPLEMENTATION == I2CDEV_ARDUINO_WIRE && ARDUINO < 100) || I2CDEV_IMPLEMENTATION == I2CDEV_BUILTIN_NBWIRE)\n            Wire.send((uint8_t)(data[i++] >> 8)); // send MSB\n            Wire.send((uint8_t)data[i]);          // send LSB\n        #elif (I2CDEV_IMPLEMENTATION == I2CDEV_ARDUINO_WIRE && ARDUINO >= 100)\n            Wire.write((uint8_t)(data[i++] >> 8)); // send MSB\n            Wire.write((uint8_t)data[i]);          // send LSB\n        #elif (I2CDEV_IMPLEMENTATION == I2CDEV_BUILTIN_FASTWIRE)\n            status = Fastwire::write(devAddr, regAddr, (uint8_t)(data[i++] >> 8));\n            status = Fastwire::write(devAddr, regAddr + 1, (uint8_t)data[i]);\n\t\t#elif (I2CDEV_IMPLEMENTATION == I2CDEV_MSP430)\n\n\n//    \t\t//Set transmit length\n//    \t\tTXLENGTH = 2;\n//    \t\t//Load TX byte counter\n//    \t\ttransmitCounter = 1;\n//    \t\ttransmitData[0] = (uint8_t)(data[i++] >> 8);\n//    \t\ttransmitData[1] = (uint8_t)(data[i++]);\n//\n//    \t\t//Initiate start and send first character\n//    \t\tI2C_masterMultiByteSendStart(transmitData[0]);\n//\n//    \t\t//Delay until transmission completes\n//    \t\twhile (I2C_isBusBusy()) ;\n\n        #endif\n        #ifdef I2CDEV_SERIAL_DEBUG\n            Serial.print(data[i], HEX);\n            if (i + 1 < length) Serial.print(" ");\n        #endif\n    }\n    #if ((I2CDEV_IMPLEMENTATION == I2CDEV_ARDUINO_WIRE && ARDUINO < 100) || I2CDEV_IMPLEMENTATION == I2CDEV_BUILTIN_NBWIRE)\n        Wire.endTransmission();\n    #elif (I2CDEV_IMPLEMENTATION == I2CDEV_ARDUINO_WIRE && ARDUINO >= 100)\n        status = Wire.endTransmission();\n\t#elif (I2CDEV_IMPLEMENTATION == I2CDEV_MSP430)\n//    \t//Delay until transmission completes\n//    \twhile (I2C_isBusBusy()) ;\n//\n//    \t//Disable TX interrupt\n//    \tI2C_disableInterrupt(I2C_TRANSMIT_INTERRUPT);\n//    \t//Disable I2C Module to stop operations\n//    \tI2C_disable();\n    #endif\n    #ifdef I2CDEV_SERIAL_DEBUG\n        Serial.println(". Done.");\n    #endif\n    return status == 0;\n}\n\n/** Default timeout value for read operations.\n * Set this to 0 to disable timeout detection.\n */\nuint16_t I2Cdev::readTimeout = I2CDEV_DEFAULT_READ_TIMEOUT;\n\n#if I2CDEV_IMPLEMENTATION == I2CDEV_BUILTIN_FASTWIRE\n    /*\n    FastWire 0.2\n    This is a library to help faster programs to read I2C devices.\n    Copyright(C) 2011 Francesco Ferrara\n    occhiobello at gmail dot com\n    */\n\n    boolean Fastwire::waitInt() {\n        int l = 250;\n        while (!(TWCR & (1 << TWINT)) && l-- > 0);\n        return l > 0;\n    }\n\n    void Fastwire::setup(int khz, boolean pullup) {\n        TWCR = 0;\n        #if defined(__AVR_ATmega168__) || defined(__AVR_ATmega8__) || defined(__AVR_ATmega328P__)\n            // activate internal pull-ups for twi (PORTC bits 4 & 5)\n            // as per note from atmega8 manual pg167\n            if (pullup) PORTC |= ((1 << 4) | (1 << 5));\n            else        PORTC &= ~((1 << 4) | (1 << 5));\n        #elif defined(__AVR_ATmega644P__) || defined(__AVR_ATmega644__)\n            // activate internal pull-ups for twi (PORTC bits 0 & 1)\n            if (pullup) PORTC |= ((1 << 0) | (1 << 1));\n            else        PORTC &= ~((1 << 0) | (1 << 1));\n        #else\n            // activate internal pull-ups for twi (PORTD bits 0 & 1)\n            // as per note from atmega128 manual pg204\n            if (pullup) PORTD |= ((1 << 0) | (1 << 1));\n            else        PORTD &= ~((1 << 0) | (1 << 1));\n        #endif\n\n        TWSR = 0; // no prescaler => prescaler = 1\n        TWBR = ((16000L / khz) - 16) / 2; // change the I2C clock rate\n        TWCR = 1 << TWEN; // enable twi module, no interrupt\n    }\n\n    byte Fastwire::write(byte device, byte address, byte value) {\n        byte twst, retry;\n\n        retry = 2;\n        do {\n            TWCR = (1 << TWINT) | (1 << TWEN) | (1 << TWSTO) | (1 << TWSTA);\n            if (!waitInt()) return 1;\n            twst = TWSR & 0xF8;\n            if (twst != TW_START && twst != TW_REP_START) return 2;\n\n            TWDR = device & 0xFE; // send device address without read bit (1)\n            TWCR = (1 << TWINT) | (1 << TWEN);\n            if (!waitInt()) return 3;\n            twst = TWSR & 0xF8;\n        } while (twst == TW_MT_SLA_NACK && retry-- > 0);\n        if (twst != TW_MT_SLA_ACK) return 4;\n\n        TWDR = address; // send data to the previously addressed device\n        TWCR = (1 << TWINT) | (1 << TWEN);\n        if (!waitInt()) return 5;\n        twst = TWSR & 0xF8;\n        if (twst != TW_MT_DATA_ACK) return 6;\n\n        TWDR = value; // send data to the previously addressed device\n        TWCR = (1 << TWINT) | (1 << TWEN);\n        if (!waitInt()) return 7;\n        twst = TWSR & 0xF8;\n        if (twst != TW_MT_DATA_ACK) return 8;\n\n        return 0;\n    }\n\n    byte Fastwire::readBuf(byte device, byte address, byte *data, byte num) {\n        byte twst, retry;\n\n        retry = 2;\n        do {\n            TWCR = (1 << TWINT) | (1 << TWEN) | (1 << TWSTO) | (1 << TWSTA);\n            if (!waitInt()) return 16;\n            twst = TWSR & 0xF8;\n            if (twst != TW_START && twst != TW_REP_START) return 17;\n\n            TWDR = device & 0xfe; // send device address to write\n            TWCR = (1 << TWINT) | (1 << TWEN);\n            if (!waitInt()) return 18;\n            twst = TWSR & 0xF8;\n        } while (twst == TW_MT_SLA_NACK && retry-- > 0);\n        if (twst != TW_MT_SLA_ACK) return 19;\n\n        TWDR = address; // send data to the previously addressed device\n        TWCR = (1 << TWINT) | (1 << TWEN);\n        if (!waitInt()) return 20;\n        twst = TWSR & 0xF8;\n        if (twst != TW_MT_DATA_ACK) return 21;\n\n        /***/\n\n        retry = 2;\n        do {\n            TWCR = (1 << TWINT) | (1 << TWEN) | (1 << TWSTO) | (1 << TWSTA);\n            if (!waitInt()) return 22;\n            twst = TWSR & 0xF8;\n            if (twst != TW_START && twst != TW_REP_START) return 23;\n\n            TWDR = device | 0x01; // send device address with the read bit (1)\n            TWCR = (1 << TWINT) | (1 << TWEN);\n            if (!waitInt()) return 24;\n            twst = TWSR & 0xF8;\n        } while (twst == TW_MR_SLA_NACK && retry-- > 0);\n        if (twst != TW_MR_SLA_ACK) return 25;\n\n        for(uint8_t i = 0; i < num; i++) {\n            if (i == num - 1)\n               TWCR = (1 << TWINT) | (1 << TWEN);\n            else\n                TWCR = (1 << TWINT) | (1 << TWEN) | (1 << TWEA);\n            if (!waitInt()) return 26;\n            twst = TWSR & 0xF8;\n            if (twst != TW_MR_DATA_ACK && twst != TW_MR_DATA_NACK) return twst;\n            data[i] = TWDR;\n        }\n\n        return 0;\n   }\n#endif\n\n#if I2CDEV_IMPLEMENTATION == I2CDEV_BUILTIN_NBWIRE\n    // NBWire implementation based heavily on code by Gene Knight <Gene@Telobot.com>\n    // Originally posted on the Arduino forum at http://arduino.cc/forum/index.php/topic,70705.0.html\n    // Originally offered to the i2cdevlib project at http://arduino.cc/forum/index.php/topic,68210.30.html\n\n    /*\n    call this version 1.0\n    \n    Offhand, the only funky part that I can think of is in nbrequestFrom, where the buffer\n    length and index are set *before* the data is actually read. The problem is that these\n    are variables local to the TwoWire object, and by the time we actually have read the\n    data, and know what the length actually is, we have no simple access to the object\'s \n    variables. The actual bytes read *is* given to the callback function, though.\n    \n    The ISR code for a slave receiver is commented out. I don\'t have that setup, and can\'t\n    verify it at this time. Save it for 2.0!\n    \n    The handling of the read and write processes here is much like in the demo sketch code: \n    the process is broken down into sequential functions, where each registers the next as a\n    callback, essentially.\n    \n    For example, for the Read process, twi_read00 just returns if TWI is not yet in a \n    ready state. When there\'s another interrupt, and the interface *is* ready, then it\n    sets up the read, starts it, and registers twi_read01 as the function to call after\n    the *next* interrupt. twi_read01, then, just returns if the interface is still in a\n    "reading" state. When the reading is done, it copies the information to the buffer,\n    cleans up, and calls the user-requested callback function with the actual number of \n    bytes read.\n    \n    The writing is similar.\n    \n    Questions, comments and problems can go to Gene@Telobot.com.\n    \n    Thumbs Up!\n    Gene Knight\n    \n    */\n    \n    uint8_t TwoWire::rxBuffer[NBWIRE_BUFFER_LENGTH];\n    uint8_t TwoWire::rxBufferIndex = 0;\n    uint8_t TwoWire::rxBufferLength = 0;\n    \n    uint8_t TwoWire::txAddress = 0;\n    uint8_t TwoWire::txBuffer[NBWIRE_BUFFER_LENGTH];\n    uint8_t TwoWire::txBufferIndex = 0;\n    uint8_t TwoWire::txBufferLength = 0;\n    \n    //uint8_t TwoWire::transmitting = 0;\n    void (*TwoWire::user_onRequest)(void);\n    void (*TwoWire::user_onReceive)(int);\n    \n    static volatile uint8_t twi_transmitting;\n    static volatile uint8_t twi_state;\n    static uint8_t twi_slarw;\n    static volatile uint8_t twi_error;\n    static uint8_t twi_masterBuffer[TWI_BUFFER_LENGTH];\n    static volatile uint8_t twi_masterBufferIndex;\n    static uint8_t twi_masterBufferLength;\n    static uint8_t twi_rxBuffer[TWI_BUFFER_LENGTH];\n    static volatile uint8_t twi_rxBufferIndex;\n    //static volatile uint8_t twi_Interrupt_Continue_Command;\n    static volatile uint8_t twi_Return_Value;\n    static volatile uint8_t twi_Done;\n    void (*twi_cbendTransmissionDone)(int);\n    void (*twi_cbreadFromDone)(int);\n    \n    void twi_init() {\n        // initialize state\n        twi_state = TWI_READY;\n\n        // activate internal pull-ups for twi\n        // as per note from atmega8 manual pg167\n        sbi(PORTC, 4);\n        sbi(PORTC, 5);\n\n        // initialize twi prescaler and bit rate\n        cbi(TWSR, TWPS0); // TWI Status Register - Prescaler bits\n        cbi(TWSR, TWPS1);\n\n        /* twi bit rate formula from atmega128 manual pg 204\n        SCL Frequency = CPU Clock Frequency / (16 + (2 * TWBR))\n        note: TWBR should be 10 or higher for master mode\n        It is 72 for a 16mhz Wiring board with 100kHz TWI */\n\n        TWBR = ((CPU_FREQ / TWI_FREQ) - 16) / 2; // bitrate register\n        // enable twi module, acks, and twi interrupt\n\n        TWCR = (1 << TWEN) | (1 << TWIE) | (1 << TWEA);\n\n        /* TWEN - TWI Enable Bit\n        TWIE - TWI Interrupt Enable\n        TWEA - TWI Enable Acknowledge Bit\n        TWINT - TWI Interrupt Flag\n        TWSTA - TWI Start Condition\n        */\n    }\n    \n    typedef struct {\n        uint8_t address;\n        uint8_t* data;\n        uint8_t length;\n        uint8_t wait;\n        uint8_t i;\n    } twi_Write_Vars;\n\n    twi_Write_Vars *ptwv = 0;\n    static void (*fNextInterruptFunction)(void) = 0;\n    \n    void twi_Finish(byte bRetVal) {\n        if (ptwv) {\n            free(ptwv);\n            ptwv = 0;\n        }\n        twi_Done = 0xFF;\n        twi_Return_Value = bRetVal;\n        fNextInterruptFunction = 0;\n    }\n    \n    uint8_t twii_WaitForDone(uint16_t timeout) {\n        uint32_t endMillis = millis() + timeout;\n        while (!twi_Done && (timeout == 0 || millis() < endMillis)) continue;\n        return twi_Return_Value;\n    }\n    \n    void twii_SetState(uint8_t ucState) {\n        twi_state = ucState;\n    }\n\n    void twii_SetError(uint8_t ucError) {\n        twi_error = ucError ;\n    }\n\n    void twii_InitBuffer(uint8_t ucPos, uint8_t ucLength) {\n        twi_masterBufferIndex = 0;\n        twi_masterBufferLength = ucLength;\n    }\n\n    void twii_CopyToBuf(uint8_t* pData, uint8_t ucLength) {\n        uint8_t i;\n        for (i = 0; i < ucLength; ++i) {\n            twi_masterBuffer[i] = pData[i];\n        }\n    }\n\n    void twii_CopyFromBuf(uint8_t *pData, uint8_t ucLength) {\n        uint8_t i;\n        for (i = 0; i < ucLength; ++i) {\n            pData[i] = twi_masterBuffer[i];\n        }\n    }\n\n    void twii_SetSlaRW(uint8_t ucSlaRW) {\n        twi_slarw = ucSlaRW;\n    }\n\n    void twii_SetStart() {\n        TWCR = (1 << TWEN) | (1 << TWIE) | (1 << TWEA) | (1 << TWINT) | (1 << TWSTA);\n    }\n\n    void twi_write01() {\n        if (TWI_MTX == twi_state) return; // blocking test\n        twi_transmitting = 0 ;\n        if (twi_error == 0xFF)\n            twi_Finish (0);    // success\n        else if (twi_error == TW_MT_SLA_NACK)\n            twi_Finish (2);    // error: address send, nack received\n        else if (twi_error == TW_MT_DATA_NACK)\n            twi_Finish (3);    // error: data send, nack received\n        else\n            twi_Finish (4);    // other twi error\n        if (twi_cbendTransmissionDone) return twi_cbendTransmissionDone(twi_Return_Value);\n        return;\n    }\n    \n    \n    void twi_write00() {\n        if (TWI_READY != twi_state) return; // blocking test\n        if (TWI_BUFFER_LENGTH < ptwv -> length) {\n            twi_Finish(1); // end write with error 1\n            return;\n        }\n        twi_Done = 0x00; // show as working\n        twii_SetState(TWI_MTX); // to transmitting\n        twii_SetError(0xFF); // to No Error\n        twii_InitBuffer(0, ptwv -> length); // pointer and length\n        twii_CopyToBuf(ptwv -> data, ptwv -> length); // get the data\n        twii_SetSlaRW((ptwv -> address << 1) | TW_WRITE); // write command\n        twii_SetStart(); // start the cycle\n        fNextInterruptFunction = twi_write01; // next routine\n        return twi_write01();\n    }\n    \n    void twi_writeTo(uint8_t address, uint8_t* data, uint8_t length, uint8_t wait) {\n        uint8_t i;\n        ptwv = (twi_Write_Vars *)malloc(sizeof(twi_Write_Vars));\n        ptwv -> address = address;\n        ptwv -> data = data;\n        ptwv -> length = length;\n        ptwv -> wait = wait;\n        fNextInterruptFunction = twi_write00;\n        return twi_write00();\n    }\n\n    void twi_read01() {\n        if (TWI_MRX == twi_state) return; // blocking test\n        if (twi_masterBufferIndex < ptwv -> length) ptwv -> length = twi_masterBufferIndex;\n        twii_CopyFromBuf(ptwv -> data, ptwv -> length);\n        twi_Finish(ptwv -> length);\n        if (twi_cbreadFromDone) return twi_cbreadFromDone(twi_Return_Value);\n        return;\n    }\n    \n    void twi_read00() {\n        if (TWI_READY != twi_state) return; // blocking test\n        if (TWI_BUFFER_LENGTH < ptwv -> length) twi_Finish(0); // error return\n        twi_Done = 0x00; // show as working\n        twii_SetState(TWI_MRX); // reading\n        twii_SetError(0xFF); // reset error\n        twii_InitBuffer(0, ptwv -> length - 1); // init to one less than length\n        twii_SetSlaRW((ptwv -> address << 1) | TW_READ); // read command\n        twii_SetStart(); // start cycle\n        fNextInterruptFunction = twi_read01;\n        return twi_read01();\n    }\n\n    void twi_readFrom(uint8_t address, uint8_t* data, uint8_t length) {\n        uint8_t i;\n\n        ptwv = (twi_Write_Vars *)malloc(sizeof(twi_Write_Vars));\n        ptwv -> address = address;\n        ptwv -> data = data;\n        ptwv -> length = length;\n        fNextInterruptFunction = twi_read00;\n        return twi_read00();\n    }\n\n    void twi_reply(uint8_t ack) {\n        // transmit master read ready signal, with or without ack\n        if (ack){\n            TWCR = (1 << TWEN) | (1 << TWIE) | (1 << TWINT) | (1 << TWEA);\n        } else {\n            TWCR = (1 << TWEN) | (1 << TWIE) | (1 << TWINT);\n        }\n    }\n    \n    void twi_stop(void) {\n        // send stop condition\n        TWCR = (1 << TWEN) | (1 << TWIE) | (1 << TWEA) | (1 << TWINT) | (1 << TWSTO);\n    \n        // wait for stop condition to be exectued on bus\n        // TWINT is not set after a stop condition!\n        while (TWCR & (1 << TWSTO)) {\n            continue;\n        }\n    \n        // update twi state\n        twi_state = TWI_READY;\n    }\n\n    void twi_releaseBus(void) {\n        // release bus\n        TWCR = (1 << TWEN) | (1 << TWIE) | (1 << TWEA) | (1 << TWINT);\n    \n        // update twi state\n        twi_state = TWI_READY;\n    }\n    \n    SIGNAL(TWI_vect) {\n        switch (TW_STATUS) {\n            // All Master\n            case TW_START:     // sent start condition\n            case TW_REP_START: // sent repeated start condition\n                // copy device address and r/w bit to output register and ack\n                TWDR = twi_slarw;\n                twi_reply(1);\n                break;\n    \n            // Master Transmitter\n            case TW_MT_SLA_ACK:  // slave receiver acked address\n            case TW_MT_DATA_ACK: // slave receiver acked data\n                // if there is data to send, send it, otherwise stop\n                if (twi_masterBufferIndex < twi_masterBufferLength) {\n                    // copy data to output register and ack\n                    TWDR = twi_masterBuffer[twi_masterBufferIndex++];\n                    twi_reply(1);\n                } else {\n                    twi_stop();\n                }\n                break;\n\n            case TW_MT_SLA_NACK:  // address sent, nack received\n                twi_error = TW_MT_SLA_NACK;\n                twi_stop();\n                break;\n\n            case TW_MT_DATA_NACK: // data sent, nack received\n                twi_error = TW_MT_DATA_NACK;\n                twi_stop();\n                break;\n\n            case TW_MT_ARB_LOST: // lost bus arbitration\n                twi_error = TW_MT_ARB_LOST;\n                twi_releaseBus();\n                break;\n    \n            // Master Receiver\n            case TW_MR_DATA_ACK: // data received, ack sent\n                // put byte into buffer\n                twi_masterBuffer[twi_masterBufferIndex++] = TWDR;\n\n            case TW_MR_SLA_ACK:  // address sent, ack received\n                // ack if more bytes are expected, otherwise nack\n                if (twi_masterBufferIndex < twi_masterBufferLength) {\n                    twi_reply(1);\n                } else {\n                    twi_reply(0);\n                }\n                break;\n\n            case TW_MR_DATA_NACK: // data received, nack sent\n                // put final byte into buffer\n                twi_masterBuffer[twi_masterBufferIndex++] = TWDR;\n\n            case TW_MR_SLA_NACK: // address sent, nack received\n                twi_stop();\n                break;\n\n        // TW_MR_ARB_LOST handled by TW_MT_ARB_LOST case\n\n        // Slave Receiver (NOT IMPLEMENTED YET)\n        /*\n            case TW_SR_SLA_ACK:   // addressed, returned ack\n            case TW_SR_GCALL_ACK: // addressed generally, returned ack\n            case TW_SR_ARB_LOST_SLA_ACK:   // lost arbitration, returned ack\n            case TW_SR_ARB_LOST_GCALL_ACK: // lost arbitration, returned ack\n                // enter slave receiver mode\n                twi_state = TWI_SRX;\n\n                // indicate that rx buffer can be overwritten and ack\n                twi_rxBufferIndex = 0;\n                twi_reply(1);\n                break;\n\n            case TW_SR_DATA_ACK:       // data received, returned ack\n            case TW_SR_GCALL_DATA_ACK: // data received generally, returned ack\n                // if there is still room in the rx buffer\n                if (twi_rxBufferIndex < TWI_BUFFER_LENGTH) {\n                    // put byte in buffer and ack\n                    twi_rxBuffer[twi_rxBufferIndex++] = TWDR;\n                    twi_reply(1);\n                } else {\n                    // otherwise nack\n                    twi_reply(0);\n                }\n                break;\n\n            case TW_SR_STOP: // stop or repeated start condition received\n                // put a null char after data if there\'s room\n                if (twi_rxBufferIndex < TWI_BUFFER_LENGTH) {\n                    twi_rxBuffer[twi_rxBufferIndex] = 0;\n                }\n\n                // sends ack and stops interface for clock stretching\n                twi_stop();\n\n                // callback to user defined callback\n                twi_onSlaveReceive(twi_rxBuffer, twi_rxBufferIndex);\n\n                // since we submit rx buffer to "wire" library, we can reset it\n                twi_rxBufferIndex = 0;\n\n                // ack future responses and leave slave receiver state\n                twi_releaseBus();\n                break;\n\n            case TW_SR_DATA_NACK:       // data received, returned nack\n            case TW_SR_GCALL_DATA_NACK: // data received generally, returned nack\n                // nack back at master\n                twi_reply(0);\n                break;\n\n            // Slave Transmitter\n            case TW_ST_SLA_ACK:          // addressed, returned ack\n            case TW_ST_ARB_LOST_SLA_ACK: // arbitration lost, returned ack\n                // enter slave transmitter mode\n                twi_state = TWI_STX;\n\n                // ready the tx buffer index for iteration\n                twi_txBufferIndex = 0;\n\n                // set tx buffer length to be zero, to verify if user changes it\n                twi_txBufferLength = 0;\n\n                // request for txBuffer to be filled and length to be set\n                // note: user must call twi_transmit(bytes, length) to do this\n                twi_onSlaveTransmit();\n\n                // if they didn\'t change buffer & length, initialize it\n                if (0 == twi_txBufferLength) {\n                    twi_txBufferLength = 1;\n                    twi_txBuffer[0] = 0x00;\n                }\n                \n                // transmit first byte from buffer, fall through\n\n            case TW_ST_DATA_ACK: // byte sent, ack returned\n                // copy data to output register\n                TWDR = twi_txBuffer[twi_txBufferIndex++];\n\n                // if there is more to send, ack, otherwise nack\n                if (twi_txBufferIndex < twi_txBufferLength) {\n                    twi_reply(1);\n                } else {\n                    twi_reply(0);\n                }\n                break;\n\n            case TW_ST_DATA_NACK: // received nack, we are done\n            case TW_ST_LAST_DATA: // received ack, but we are done already!\n                // ack future responses\n                twi_reply(1);\n                // leave slave receiver state\n                twi_state = TWI_READY;\n                break;\n            */\n\n            // all\n            case TW_NO_INFO:   // no state information\n                break;\n\n            case TW_BUS_ERROR: // bus error, illegal stop/start\n                twi_error = TW_BUS_ERROR;\n                twi_stop();\n                break;\n        }\n\n        if (fNextInterruptFunction) return fNextInterruptFunction();\n    }\n\n    TwoWire::TwoWire() { }\n    \n    void TwoWire::begin(void) {\n        rxBufferIndex = 0;\n        rxBufferLength = 0;\n    \n        txBufferIndex = 0;\n        txBufferLength = 0;\n\n        twi_init();\n    }\n    \n    void TwoWire::beginTransmission(uint8_t address) {\n        //beginTransmission((uint8_t)address);\n\n        // indicate that we are transmitting\n        twi_transmitting = 1;\n        \n        // set address of targeted slave\n        txAddress = address;\n        \n        // reset tx buffer iterator vars\n        txBufferIndex = 0;\n        txBufferLength = 0;\n    }\n    \n    uint8_t TwoWire::endTransmission(uint16_t timeout) {\n        // transmit buffer (blocking)\n        //int8_t ret =\n        twi_cbendTransmissionDone = NULL;\n        twi_writeTo(txAddress, txBuffer, txBufferLength, 1);\n        int8_t ret = twii_WaitForDone(timeout);\n\n        // reset tx buffer iterator vars\n        txBufferIndex = 0;\n        txBufferLength = 0;\n\n        // indicate that we are done transmitting\n        // twi_transmitting = 0;\n        return ret;\n    }\n\n    void TwoWire::nbendTransmission(void (*function)(int)) {\n        twi_cbendTransmissionDone = function;\n        twi_writeTo(txAddress, txBuffer, txBufferLength, 1);\n        return;\n    }\n    \n    void TwoWire::send(uint8_t data) {\n        if (twi_transmitting) {\n            // in master transmitter mode\n            // don\'t bother if buffer is full\n            if (txBufferLength >= NBWIRE_BUFFER_LENGTH) {\n                return;\n            }\n\n            // put byte in tx buffer\n            txBuffer[txBufferIndex] = data;\n            ++txBufferIndex;\n\n            // update amount in buffer\n            txBufferLength = txBufferIndex;\n        } else {\n            // in slave send mode\n            // reply to master\n            //twi_transmit(&data, 1);\n        }\n    }\n    \n    uint8_t TwoWire::receive(void) {\n        // default to returning null char\n        // for people using with char strings\n        uint8_t value = 0;\n      \n        // get each successive byte on each call\n        if (rxBufferIndex < rxBufferLength) {\n            value = rxBuffer[rxBufferIndex];\n            ++rxBufferIndex;\n        }\n    \n        return value;\n    }\n    \n    uint8_t TwoWire::requestFrom(uint8_t address, int quantity, uint16_t timeout) {\n        // clamp to buffer length\n        if (quantity > NBWIRE_BUFFER_LENGTH) {\n            quantity = NBWIRE_BUFFER_LENGTH;\n        }\n\n        // perform blocking read into buffer\n        twi_cbreadFromDone = NULL;\n        twi_readFrom(address, rxBuffer, quantity);\n        uint8_t read = twii_WaitForDone(timeout);\n\n        // set rx buffer iterator vars\n        rxBufferIndex = 0;\n        rxBufferLength = read;\n    \n        return read;\n    }\n    \n    void TwoWire::nbrequestFrom(uint8_t address, int quantity, void (*function)(int)) {\n        // clamp to buffer length\n        if (quantity > NBWIRE_BUFFER_LENGTH) {\n            quantity = NBWIRE_BUFFER_LENGTH;\n        }\n\n        // perform blocking read into buffer\n        twi_cbreadFromDone = function;\n        twi_readFrom(address, rxBuffer, quantity);\n        //uint8_t read = twii_WaitForDone();\n\n        // set rx buffer iterator vars\n        //rxBufferIndex = 0;\n        //rxBufferLength = read;\n\n        rxBufferIndex = 0;\n        rxBufferLength = quantity; // this is a hack\n\n        return; //read;\n    }\n\n    uint8_t TwoWire::available(void) {\n        return rxBufferLength - rxBufferIndex;\n    }\n\n#endif\n\n#if  I2CDEV_IMPLEMENTATION == I2CDEV_MSP430\n//MSP 430 I2C implementation based on TI examples\n\n\n#endif\n'