b'// UVa1471 Defense Lines\n// Rujia Liu\n// Algorithm 1: use STL set to maintain the candidates.\n// This is a little bit more intuitive, but less efficient (than algorithm 2)\n#include<cstdio>\n#include<set>\n#include<cassert>\nusing namespace std;\n\nconst int maxn = 200000 + 5;\nint n, a[maxn], f[maxn], g[maxn];\n\nstruct Candidate {\n  int a, g;\n  Candidate(int a, int g):a(a),g(g) {}\n  bool operator < (const Candidate& rhs) const {\n    return a < rhs.a;\n  }\n};\n\nset<Candidate> s;\n\nint main() {\n  int T;\n  scanf("%d", &T);\n  while(T--) {\n    scanf("%d", &n);\n    for(int i = 0; i < n; i++)\n      scanf("%d", &a[i]);\n    if(n == 1) { printf("1\\n"); continue; }\n\n    // g[i] is the length of longest increasing continuous subsequence ending at i\n    g[0] = 1;\n    for(int i = 1; i < n; i++)\n      if(a[i-1] < a[i]) g[i] = g[i-1] + 1;\n      else g[i] = 1;\n\n    // f[i] is the length of longest increasing continuous subsequence starting from i\n    f[n-1] = 1;\n    for(int i = n-2; i >= 0; i--)\n      if(a[i] < a[i+1]) f[i] = f[i+1] + 1;\n      else f[i] = 1;\n\n    s.clear();\n    s.insert(Candidate(a[0], g[0]));\n    int ans = 1;\n    for(int i = 1; i < n; i++) {\n      Candidate c(a[i], g[i]);\n      set<Candidate>::iterator it = s.lower_bound(c); // first one that is >= c\n      bool keep = true;\n      if(it != s.begin()) {\n        Candidate last = *(--it); // (--it) points to the largest one that is < c\n        int len = f[i] + last.g; \n        ans = max(ans, len);\n        if(c.g <= last.g) keep = false;\n      }\n\n      if(keep) {\n        s.erase(c); // if c.a is already present, the old g must be <= c.g\n        s.insert(c);\n        it = s.find(c); // this is a bit cumbersome and slow but it\'s clear\n        it++;\n        while(it != s.end() && it->a > c.a && it->g <= c.g) s.erase(it++);\n      }\n    }\n    printf("%d\\n", ans);\n  }\n  return 0;\n}\n'