b'package com.naman14.timber.widgets;\n\nimport android.content.Context;\nimport android.content.res.TypedArray;\nimport android.graphics.BlurMaskFilter;\nimport android.graphics.Canvas;\nimport android.graphics.Color;\nimport android.graphics.Paint;\nimport android.graphics.Path;\nimport android.graphics.PathMeasure;\nimport android.graphics.RectF;\nimport android.os.Bundle;\nimport android.os.Parcelable;\nimport android.util.AttributeSet;\nimport android.view.MotionEvent;\nimport android.view.View;\n\nimport com.naman14.timber.R;\n\npublic class CircularSeekBar extends View {\n\n    // Default values\n    private static final float DEFAULT_CIRCLE_X_RADIUS = 30f;\n    private static final float DEFAULT_CIRCLE_Y_RADIUS = 30f;\n    private static final float DEFAULT_POINTER_RADIUS = 7f;\n    private static final float DEFAULT_POINTER_HALO_WIDTH = 6f;\n    private static final float DEFAULT_POINTER_HALO_BORDER_WIDTH = 2f;\n    private static final float DEFAULT_CIRCLE_STROKE_WIDTH = 5f;\n    private static final float DEFAULT_START_ANGLE = 270f; // Geometric (clockwise, relative to 3 o\'clock)\n    private static final float DEFAULT_END_ANGLE = 270f; // Geometric (clockwise, relative to 3 o\'clock)\n    private static final int DEFAULT_MAX = 100;\n    private static final int DEFAULT_PROGRESS = 0;\n    private static final int DEFAULT_CIRCLE_COLOR = Color.DKGRAY;\n    private static final int DEFAULT_CIRCLE_PROGRESS_COLOR = Color.argb(235, 74, 138, 255);\n    private static final int DEFAULT_POINTER_COLOR = Color.argb(235, 74, 138, 255);\n    private static final int DEFAULT_POINTER_HALO_COLOR = Color.argb(135, 74, 138, 255);\n    private static final int DEFAULT_POINTER_HALO_COLOR_ONTOUCH = Color.argb(135, 74, 138, 255);\n    private static final int DEFAULT_CIRCLE_FILL_COLOR = Color.TRANSPARENT;\n    private static final int DEFAULT_POINTER_ALPHA = 135;\n    private static final int DEFAULT_POINTER_ALPHA_ONTOUCH = 100;\n    private static final boolean DEFAULT_USE_CUSTOM_RADII = false;\n    private static final boolean DEFAULT_MAINTAIN_EQUAL_CIRCLE = true;\n    private static final boolean DEFAULT_MOVE_OUTSIDE_CIRCLE = false;\n    private static final boolean DEFAULT_LOCK_ENABLED = true;\n    /**\n     * Used to scale the dp units to pixels\n     */\n    private final float DPTOPX_SCALE = getResources().getDisplayMetrics().density;\n    /**\n     * Minimum touch target size in DP. 48dp is the Android design recommendation\n     */\n    private final float MIN_TOUCH_TARGET_DP = 48;\n    /**\n     * {@code Paint} instance used to draw the inactive circle.\n     */\n    private Paint mCirclePaint;\n\n    /**\n     * {@code Paint} instance used to draw the circle fill.\n     */\n    private Paint mCircleFillPaint;\n\n    /**\n     * {@code Paint} instance used to draw the active circle (represents progress).\n     */\n    private Paint mCircleProgressPaint;\n\n    /**\n     * {@code Paint} instance used to draw the glow from the active circle.\n     */\n    private Paint mCircleProgressGlowPaint;\n\n    /**\n     * {@code Paint} instance used to draw the center of the pointer.\n     * Note: This is broken on 4.0+, as BlurMasks do not work with hardware acceleration.\n     */\n    private Paint mPointerPaint;\n\n    /**\n     * {@code Paint} instance used to draw the halo of the pointer.\n     * Note: The halo is the part that changes transparency.\n     */\n    private Paint mPointerHaloPaint;\n\n    /**\n     * {@code Paint} instance used to draw the border of the pointer, outside of the halo.\n     */\n    private Paint mPointerHaloBorderPaint;\n\n    /**\n     * The width of the circle (in pixels).\n     */\n    private float mCircleStrokeWidth;\n\n    /**\n     * The X radius of the circle (in pixels).\n     */\n    private float mCircleXRadius;\n\n    /**\n     * The Y radius of the circle (in pixels).\n     */\n    private float mCircleYRadius;\n\n    /**\n     * The radius of the pointer (in pixels).\n     */\n    private float mPointerRadius;\n\n    /**\n     * The width of the pointer halo (in pixels).\n     */\n    private float mPointerHaloWidth;\n\n    /**\n     * The width of the pointer halo border (in pixels).\n     */\n    private float mPointerHaloBorderWidth;\n\n    /**\n     * Start angle of the CircularSeekBar.\n     * Note: If mStartAngle and mEndAngle are set to the same angle, 0.1 is subtracted\n     * from the mEndAngle to make the circle function properly.\n     */\n    private float mStartAngle;\n\n    /**\n     * End angle of the CircularSeekBar.\n     * Note: If mStartAngle and mEndAngle are set to the same angle, 0.1 is subtracted\n     * from the mEndAngle to make the circle function properly.\n     */\n    private float mEndAngle;\n\n    /**\n     * {@code RectF} that represents the circle (or ellipse) of the seekbar.\n     */\n    private RectF mCircleRectF = new RectF();\n\n    /**\n     * Holds the color value for {@code mPointerPaint} before the {@code Paint} instance is created.\n     */\n    private int mPointerColor = DEFAULT_POINTER_COLOR;\n\n    /**\n     * Holds the color value for {@code mPointerHaloPaint} before the {@code Paint} instance is created.\n     */\n    private int mPointerHaloColor = DEFAULT_POINTER_HALO_COLOR;\n\n    /**\n     * Holds the color value for {@code mPointerHaloPaint} before the {@code Paint} instance is created.\n     */\n    private int mPointerHaloColorOnTouch = DEFAULT_POINTER_HALO_COLOR_ONTOUCH;\n\n    /**\n     * Holds the color value for {@code mCirclePaint} before the {@code Paint} instance is created.\n     */\n    private int mCircleColor = DEFAULT_CIRCLE_COLOR;\n\n    /**\n     * Holds the color value for {@code mCircleFillPaint} before the {@code Paint} instance is created.\n     */\n    private int mCircleFillColor = DEFAULT_CIRCLE_FILL_COLOR;\n\n    /**\n     * Holds the color value for {@code mCircleProgressPaint} before the {@code Paint} instance is created.\n     */\n    private int mCircleProgressColor = DEFAULT_CIRCLE_PROGRESS_COLOR;\n\n    /**\n     * Holds the alpha value for {@code mPointerHaloPaint}.\n     */\n    private int mPointerAlpha = DEFAULT_POINTER_ALPHA;\n\n    /**\n     * Holds the OnTouch alpha value for {@code mPointerHaloPaint}.\n     */\n    private int mPointerAlphaOnTouch = DEFAULT_POINTER_ALPHA_ONTOUCH;\n\n    /**\n     * Distance (in degrees) that the the circle/semi-circle makes up.\n     * This amount represents the max of the circle in degrees.\n     */\n    private float mTotalCircleDegrees;\n\n    /**\n     * Distance (in degrees) that the current progress makes up in the circle.\n     */\n    private float mProgressDegrees;\n\n    /**\n     * {@code Path} used to draw the circle/semi-circle.\n     */\n    private Path mCirclePath;\n\n    /**\n     * {@code Path} used to draw the progress on the circle.\n     */\n    private Path mCircleProgressPath;\n\n    /**\n     * Max value that this CircularSeekBar is representing.\n     */\n    private int mMax;\n\n    /**\n     * Progress value that this CircularSeekBar is representing.\n     */\n    private int mProgress;\n\n    /**\n     * If true, then the user can specify the X and Y radii.\n     * If false, then the View itself determines the size of the CircularSeekBar.\n     */\n    private boolean mCustomRadii;\n\n    /**\n     * Maintain a perfect circle (equal x and y radius), regardless of view or custom attributes.\n     * The smaller of the two radii will always be used in this case.\n     * The default is to be a circle and not an ellipse, due to the behavior of the ellipse.\n     */\n    private boolean mMaintainEqualCircle;\n\n    /**\n     * Once a user has touched the circle, this determines if moving outside the circle is able\n     * to change the position of the pointer (and in turn, the progress).\n     */\n    private boolean mMoveOutsideCircle;\n\n    /**\n     * Used for enabling/disabling the lock option for easier hitting of the 0 progress mark.\n     */\n    private boolean lockEnabled = true;\n\n    /**\n     * Used for when the user moves beyond the start of the circle when moving counter clockwise.\n     * Makes it easier to hit the 0 progress mark.\n     */\n    private boolean lockAtStart = true;\n\n    /**\n     * Used for when the user moves beyond the end of the circle when moving clockwise.\n     * Makes it easier to hit the 100% (max) progress mark.\n     */\n    private boolean lockAtEnd = false;\n\n    /**\n     * When the user is touching the circle on ACTION_DOWN, this is set to true.\n     * Used when touching the CircularSeekBar.\n     */\n    private boolean mUserIsMovingPointer = false;\n\n    /**\n     * Represents the clockwise distance from {@code mStartAngle} to the touch angle.\n     * Used when touching the CircularSeekBar.\n     */\n    private float cwDistanceFromStart;\n\n    /**\n     * Represents the counter-clockwise distance from {@code mStartAngle} to the touch angle.\n     * Used when touching the CircularSeekBar.\n     */\n    private float ccwDistanceFromStart;\n\n    /**\n     * Represents the clockwise distance from {@code mEndAngle} to the touch angle.\n     * Used when touching the CircularSeekBar.\n     */\n    private float cwDistanceFromEnd;\n\n    /**\n     * Represents the counter-clockwise distance from {@code mEndAngle} to the touch angle.\n     * Used when touching the CircularSeekBar.\n     * Currently unused, but kept just in case.\n     */\n    @SuppressWarnings("unused")\n    private float ccwDistanceFromEnd;\n\n    /**\n     * The previous touch action value for {@code cwDistanceFromStart}.\n     * Used when touching the CircularSeekBar.\n     */\n    private float lastCWDistanceFromStart;\n\n    /**\n     * Represents the clockwise distance from {@code mPointerPosition} to the touch angle.\n     * Used when touching the CircularSeekBar.\n     */\n    private float cwDistanceFromPointer;\n\n    /**\n     * Represents the counter-clockwise distance from {@code mPointerPosition} to the touch angle.\n     * Used when touching the CircularSeekBar.\n     */\n    private float ccwDistanceFromPointer;\n\n    /**\n     * True if the user is moving clockwise around the circle, false if moving counter-clockwise.\n     * Used when touching the CircularSeekBar.\n     */\n    private boolean mIsMovingCW;\n\n    /**\n     * The width of the circle used in the {@code RectF} that is used to draw it.\n     * Based on either the View width or the custom X radius.\n     */\n    private float mCircleWidth;\n\n    /**\n     * The height of the circle used in the {@code RectF} that is used to draw it.\n     * Based on either the View width or the custom Y radius.\n     */\n    private float mCircleHeight;\n\n    /**\n     * Represents the progress mark on the circle, in geometric degrees.\n     * This is not provided by the user; it is calculated;\n     */\n    private float mPointerPosition;\n\n    /**\n     * Pointer position in terms of X and Y coordinates.\n     */\n    private float[] mPointerPositionXY = new float[2];\n\n    /**\n     * Listener.\n     */\n    private OnCircularSeekBarChangeListener mOnCircularSeekBarChangeListener;\n\n    public CircularSeekBar(Context context) {\n        super(context);\n        init(null, 0);\n    }\n\n    public CircularSeekBar(Context context, AttributeSet attrs) {\n        super(context, attrs);\n        init(attrs, 0);\n    }\n\n    public CircularSeekBar(Context context, AttributeSet attrs, int defStyle) {\n        super(context, attrs, defStyle);\n        init(attrs, defStyle);\n    }\n\n    /**\n     * Initialize the CircularSeekBar with the attributes from the XML style.\n     * Uses the defaults defined at the top of this file when an attribute is not specified by the user.\n     *\n     * @param attrArray TypedArray containing the attributes.\n     */\n    private void initAttributes(TypedArray attrArray) {\n        mCircleXRadius = attrArray.getFloat(R.styleable.CircularSeekBar_circle_x_radius, DEFAULT_CIRCLE_X_RADIUS) * DPTOPX_SCALE;\n        mCircleYRadius = attrArray.getFloat(R.styleable.CircularSeekBar_circle_y_radius, DEFAULT_CIRCLE_Y_RADIUS) * DPTOPX_SCALE;\n        mPointerRadius = attrArray.getFloat(R.styleable.CircularSeekBar_pointer_radius, DEFAULT_POINTER_RADIUS) * DPTOPX_SCALE;\n        mPointerHaloWidth = attrArray.getFloat(R.styleable.CircularSeekBar_pointer_halo_width, DEFAULT_POINTER_HALO_WIDTH) * DPTOPX_SCALE;\n        mPointerHaloBorderWidth = attrArray.getFloat(R.styleable.CircularSeekBar_pointer_halo_border_width, DEFAULT_POINTER_HALO_BORDER_WIDTH) * DPTOPX_SCALE;\n        mCircleStrokeWidth = attrArray.getFloat(R.styleable.CircularSeekBar_circle_stroke_width, DEFAULT_CIRCLE_STROKE_WIDTH) * DPTOPX_SCALE;\n\n        String tempColor = attrArray.getString(R.styleable.CircularSeekBar_pointer_color);\n        if (tempColor != null) {\n            try {\n                mPointerColor = Color.parseColor(tempColor);\n            } catch (IllegalArgumentException e) {\n                mPointerColor = DEFAULT_POINTER_COLOR;\n            }\n        }\n\n        tempColor = attrArray.getString(R.styleable.CircularSeekBar_pointer_halo_color);\n        if (tempColor != null) {\n            try {\n                mPointerHaloColor = Color.parseColor(tempColor);\n            } catch (IllegalArgumentException e) {\n                mPointerHaloColor = DEFAULT_POINTER_HALO_COLOR;\n            }\n        }\n\n        tempColor = attrArray.getString(R.styleable.CircularSeekBar_pointer_halo_color_ontouch);\n        if (tempColor != null) {\n            try {\n                mPointerHaloColorOnTouch = Color.parseColor(tempColor);\n            } catch (IllegalArgumentException e) {\n                mPointerHaloColorOnTouch = DEFAULT_POINTER_HALO_COLOR_ONTOUCH;\n            }\n        }\n\n        tempColor = attrArray.getString(R.styleable.CircularSeekBar_circle_color);\n        if (tempColor != null) {\n            try {\n                mCircleColor = Color.parseColor(tempColor);\n            } catch (IllegalArgumentException e) {\n                mCircleColor = DEFAULT_CIRCLE_COLOR;\n            }\n        }\n\n        tempColor = attrArray.getString(R.styleable.CircularSeekBar_circle_progress_color);\n        if (tempColor != null) {\n            try {\n                mCircleProgressColor = Color.parseColor(tempColor);\n            } catch (IllegalArgumentException e) {\n                mCircleProgressColor = DEFAULT_CIRCLE_PROGRESS_COLOR;\n            }\n        }\n\n        tempColor = attrArray.getString(R.styleable.CircularSeekBar_circle_fill);\n        if (tempColor != null) {\n            try {\n                mCircleFillColor = Color.parseColor(tempColor);\n            } catch (IllegalArgumentException e) {\n                mCircleFillColor = DEFAULT_CIRCLE_FILL_COLOR;\n            }\n        }\n\n        mPointerAlpha = Color.alpha(mPointerHaloColor);\n\n        mPointerAlphaOnTouch = attrArray.getInt(R.styleable.CircularSeekBar_pointer_alpha_ontouch, DEFAULT_POINTER_ALPHA_ONTOUCH);\n        if (mPointerAlphaOnTouch > 255 || mPointerAlphaOnTouch < 0) {\n            mPointerAlphaOnTouch = DEFAULT_POINTER_ALPHA_ONTOUCH;\n        }\n\n        mMax = attrArray.getInt(R.styleable.CircularSeekBar_max, DEFAULT_MAX);\n        mProgress = attrArray.getInt(R.styleable.CircularSeekBar_progress, DEFAULT_PROGRESS);\n        mCustomRadii = attrArray.getBoolean(R.styleable.CircularSeekBar_use_custom_radii, DEFAULT_USE_CUSTOM_RADII);\n        mMaintainEqualCircle = attrArray.getBoolean(R.styleable.CircularSeekBar_maintain_equal_circle, DEFAULT_MAINTAIN_EQUAL_CIRCLE);\n        mMoveOutsideCircle = attrArray.getBoolean(R.styleable.CircularSeekBar_move_outside_circle, DEFAULT_MOVE_OUTSIDE_CIRCLE);\n        lockEnabled = attrArray.getBoolean(R.styleable.CircularSeekBar_lock_enabled, DEFAULT_LOCK_ENABLED);\n\n        // Modulo 360 right now to avoid constant conversion\n        mStartAngle = ((360f + (attrArray.getFloat((R.styleable.CircularSeekBar_start_angle), DEFAULT_START_ANGLE) % 360f)) % 360f);\n        mEndAngle = ((360f + (attrArray.getFloat((R.styleable.CircularSeekBar_end_angle), DEFAULT_END_ANGLE) % 360f)) % 360f);\n\n        if (mStartAngle == mEndAngle) {\n            //mStartAngle = mStartAngle + 1f;\n            mEndAngle = mEndAngle - .1f;\n        }\n\n\n    }\n\n    /**\n     * Initializes the {@code Paint} objects with the appropriate styles.\n     */\n    private void initPaints() {\n        mCirclePaint = new Paint();\n        mCirclePaint.setAntiAlias(true);\n        mCirclePaint.setDither(true);\n        mCirclePaint.setColor(mCircleColor);\n        mCirclePaint.setStrokeWidth(mCircleStrokeWidth);\n        mCirclePaint.setStyle(Paint.Style.STROKE);\n        mCirclePaint.setStrokeJoin(Paint.Join.ROUND);\n        mCirclePaint.setStrokeCap(Paint.Cap.ROUND);\n\n        mCircleFillPaint = new Paint();\n        mCircleFillPaint.setAntiAlias(true);\n        mCircleFillPaint.setDither(true);\n        mCircleFillPaint.setColor(mCircleFillColor);\n        mCircleFillPaint.setStyle(Paint.Style.FILL);\n\n        mCircleProgressPaint = new Paint();\n        mCircleProgressPaint.setAntiAlias(true);\n        mCircleProgressPaint.setDither(true);\n        mCircleProgressPaint.setColor(mCircleProgressColor);\n        mCircleProgressPaint.setStrokeWidth(mCircleStrokeWidth);\n        mCircleProgressPaint.setStyle(Paint.Style.STROKE);\n        mCircleProgressPaint.setStrokeJoin(Paint.Join.ROUND);\n        mCircleProgressPaint.setStrokeCap(Paint.Cap.ROUND);\n\n        mCircleProgressGlowPaint = new Paint();\n        mCircleProgressGlowPaint.set(mCircleProgressPaint);\n        mCircleProgressGlowPaint.setMaskFilter(new BlurMaskFilter((5f * DPTOPX_SCALE), BlurMaskFilter.Blur.NORMAL));\n\n        mPointerPaint = new Paint();\n        mPointerPaint.setAntiAlias(true);\n        mPointerPaint.setDither(true);\n        mPointerPaint.setStyle(Paint.Style.FILL);\n        mPointerPaint.setColor(mPointerColor);\n        mPointerPaint.setStrokeWidth(mPointerRadius);\n\n        mPointerHaloPaint = new Paint();\n        mPointerHaloPaint.set(mPointerPaint);\n        mPointerHaloPaint.setColor(mPointerHaloColor);\n        mPointerHaloPaint.setAlpha(mPointerAlpha);\n        mPointerHaloPaint.setStrokeWidth(mPointerRadius + mPointerHaloWidth);\n\n        mPointerHaloBorderPaint = new Paint();\n        mPointerHaloBorderPaint.set(mPointerPaint);\n        mPointerHaloBorderPaint.setStrokeWidth(mPointerHaloBorderWidth);\n        mPointerHaloBorderPaint.setStyle(Paint.Style.STROKE);\n\n    }\n\n    /**\n     * Calculates the total degrees between mStartAngle and mEndAngle, and sets mTotalCircleDegrees\n     * to this value.\n     */\n    private void calculateTotalDegrees() {\n        mTotalCircleDegrees = (360f - (mStartAngle - mEndAngle)) % 360f; // Length of the entire circle/arc\n        if (mTotalCircleDegrees <= 0f) {\n            mTotalCircleDegrees = 360f;\n        }\n    }\n\n    /**\n     * Calculate the degrees that the progress represents. Also called the sweep angle.\n     * Sets mProgressDegrees to that value.\n     */\n    private void calculateProgressDegrees() {\n        mProgressDegrees = mPointerPosition - mStartAngle; // Verified\n        mProgressDegrees = (mProgressDegrees < 0 ? 360f + mProgressDegrees : mProgressDegrees); // Verified\n    }\n\n    /**\n     * Calculate the pointer position (and the end of the progress arc) in degrees.\n     * Sets mPointerPosition to that value.\n     */\n    private void calculatePointerAngle() {\n        float progressPercent = ((float) mProgress / (float) mMax);\n        mPointerPosition = (progressPercent * mTotalCircleDegrees) + mStartAngle;\n        mPointerPosition = mPointerPosition % 360f;\n    }\n\n    private void calculatePointerXYPosition() {\n        PathMeasure pm = new PathMeasure(mCircleProgressPath, false);\n        boolean returnValue = pm.getPosTan(pm.getLength(), mPointerPositionXY, null);\n        if (!returnValue) {\n            pm = new PathMeasure(mCirclePath, false);\n            returnValue = pm.getPosTan(0, mPointerPositionXY, null);\n        }\n    }\n\n    /**\n     * Initialize the {@code Path} objects with the appropriate values.\n     */\n    private void initPaths() {\n        mCirclePath = new Path();\n        mCirclePath.addArc(mCircleRectF, mStartAngle, mTotalCircleDegrees);\n\n        mCircleProgressPath = new Path();\n        mCircleProgressPath.addArc(mCircleRectF, mStartAngle, mProgressDegrees);\n    }\n\n    /**\n     * Initialize the {@code RectF} objects with the appropriate values.\n     */\n    private void initRects() {\n        mCircleRectF.set(-mCircleWidth, -mCircleHeight, mCircleWidth, mCircleHeight);\n    }\n\n    @Override\n    protected void onDraw(Canvas canvas) {\n        super.onDraw(canvas);\n\n        canvas.translate(this.getWidth() / 2, this.getHeight() / 2);\n\n        canvas.drawPath(mCirclePath, mCirclePaint);\n        canvas.drawPath(mCircleProgressPath, mCircleProgressGlowPaint);\n        canvas.drawPath(mCircleProgressPath, mCircleProgressPaint);\n\n        canvas.drawPath(mCirclePath, mCircleFillPaint);\n\n        canvas.drawCircle(mPointerPositionXY[0], mPointerPositionXY[1], mPointerRadius + mPointerHaloWidth, mPointerHaloPaint);\n        canvas.drawCircle(mPointerPositionXY[0], mPointerPositionXY[1], mPointerRadius, mPointerPaint);\n        if (mUserIsMovingPointer) {\n            canvas.drawCircle(mPointerPositionXY[0], mPointerPositionXY[1], mPointerRadius + mPointerHaloWidth + (mPointerHaloBorderWidth / 2f), mPointerHaloBorderPaint);\n        }\n    }\n\n    /**\n     * Get the progress of the CircularSeekBar.\n     *\n     * @return The progress of the CircularSeekBar.\n     */\n    public int getProgress() {\n        int progress = Math.round((float) mMax * mProgressDegrees / mTotalCircleDegrees);\n        return progress;\n    }\n\n    /**\n     * Set the progress of the CircularSeekBar.\n     * If the progress is the same, then any listener will not receive a onProgressChanged event.\n     *\n     * @param progress The progress to set the CircularSeekBar to.\n     */\n    public void setProgress(int progress) {\n        if (mProgress != progress) {\n            mProgress = progress;\n            if (mOnCircularSeekBarChangeListener != null) {\n                mOnCircularSeekBarChangeListener.onProgressChanged(this, progress, false);\n            }\n\n            recalculateAll();\n            invalidate();\n        }\n    }\n\n    private void setProgressBasedOnAngle(float angle) {\n        mPointerPosition = angle;\n        calculateProgressDegrees();\n        mProgress = Math.round((float) mMax * mProgressDegrees / mTotalCircleDegrees);\n    }\n\n    private void recalculateAll() {\n        calculateTotalDegrees();\n        calculatePointerAngle();\n        calculateProgressDegrees();\n\n        initRects();\n\n        initPaths();\n\n        calculatePointerXYPosition();\n    }\n\n    @Override\n    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {\n        int height = getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec);\n        int width = getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec);\n        if (mMaintainEqualCircle) {\n            int min = Math.min(width, height);\n            setMeasuredDimension(min, min);\n        } else {\n            setMeasuredDimension(width, height);\n        }\n\n        // Set the circle width and height based on the view for the moment\n        mCircleHeight = (float) height / 2f - mCircleStrokeWidth - mPointerRadius - (mPointerHaloBorderWidth * 1.5f);\n        mCircleWidth = (float) width / 2f - mCircleStrokeWidth - mPointerRadius - (mPointerHaloBorderWidth * 1.5f);\n\n        // If it is not set to use custom\n        if (mCustomRadii) {\n            // Check to make sure the custom radii are not out of the view. If they are, just use the view values\n            if ((mCircleYRadius - mCircleStrokeWidth - mPointerRadius - mPointerHaloBorderWidth) < mCircleHeight) {\n                mCircleHeight = mCircleYRadius - mCircleStrokeWidth - mPointerRadius - (mPointerHaloBorderWidth * 1.5f);\n            }\n\n            if ((mCircleXRadius - mCircleStrokeWidth - mPointerRadius - mPointerHaloBorderWidth) < mCircleWidth) {\n                mCircleWidth = mCircleXRadius - mCircleStrokeWidth - mPointerRadius - (mPointerHaloBorderWidth * 1.5f);\n            }\n        }\n\n        if (mMaintainEqualCircle) { // Applies regardless of how the values were determined\n            float min = Math.min(mCircleHeight, mCircleWidth);\n            mCircleHeight = min;\n            mCircleWidth = min;\n        }\n\n        recalculateAll();\n    }\n\n    public boolean isLockEnabled() {\n        return lockEnabled;\n    }\n\n    public void setLockEnabled(boolean lockEnabled) {\n        this.lockEnabled = lockEnabled;\n    }\n\n    @Override\n    public boolean onTouchEvent(MotionEvent event) {\n        // Convert coordinates to our internal coordinate system\n        float x = event.getX() - getWidth() / 2;\n        float y = event.getY() - getHeight() / 2;\n\n        // Get the distance from the center of the circle in terms of x and y\n        float distanceX = mCircleRectF.centerX() - x;\n        float distanceY = mCircleRectF.centerY() - y;\n\n        // Get the distance from the center of the circle in terms of a radius\n        float touchEventRadius = (float) Math.sqrt((Math.pow(distanceX, 2) + Math.pow(distanceY, 2)));\n\n        float minimumTouchTarget = MIN_TOUCH_TARGET_DP * DPTOPX_SCALE; // Convert minimum touch target into px\n        float additionalRadius; // Either uses the minimumTouchTarget size or larger if the ring/pointer is larger\n\n        if (mCircleStrokeWidth < minimumTouchTarget) { // If the width is less than the minimumTouchTarget, use the minimumTouchTarget\n            additionalRadius = minimumTouchTarget / 2;\n        } else {\n            additionalRadius = mCircleStrokeWidth / 2; // Otherwise use the width\n        }\n        float outerRadius = Math.max(mCircleHeight, mCircleWidth) + additionalRadius; // Max outer radius of the circle, including the minimumTouchTarget or wheel width\n        float innerRadius = Math.min(mCircleHeight, mCircleWidth) - additionalRadius; // Min inner radius of the circle, including the minimumTouchTarget or wheel width\n\n        if (mPointerRadius < (minimumTouchTarget / 2)) { // If the pointer radius is less than the minimumTouchTarget, use the minimumTouchTarget\n            additionalRadius = minimumTouchTarget / 2;\n        } else {\n            additionalRadius = mPointerRadius; // Otherwise use the radius\n        }\n\n        float touchAngle;\n        touchAngle = (float) ((java.lang.Math.atan2(y, x) / Math.PI * 180) % 360); // Verified\n        touchAngle = (touchAngle < 0 ? 360 + touchAngle : touchAngle); // Verified\n\n        cwDistanceFromStart = touchAngle - mStartAngle; // Verified\n        cwDistanceFromStart = (cwDistanceFromStart < 0 ? 360f + cwDistanceFromStart : cwDistanceFromStart); // Verified\n        ccwDistanceFromStart = 360f - cwDistanceFromStart; // Verified\n\n        cwDistanceFromEnd = touchAngle - mEndAngle; // Verified\n        cwDistanceFromEnd = (cwDistanceFromEnd < 0 ? 360f + cwDistanceFromEnd : cwDistanceFromEnd); // Verified\n        ccwDistanceFromEnd = 360f - cwDistanceFromEnd; // Verified\n\n        switch (event.getAction()) {\n            case MotionEvent.ACTION_DOWN:\n                // These are only used for ACTION_DOWN for handling if the pointer was the part that was touched\n                float pointerRadiusDegrees = (float) ((mPointerRadius * 180) / (Math.PI * Math.max(mCircleHeight, mCircleWidth)));\n                cwDistanceFromPointer = touchAngle - mPointerPosition;\n                cwDistanceFromPointer = (cwDistanceFromPointer < 0 ? 360f + cwDistanceFromPointer : cwDistanceFromPointer);\n                ccwDistanceFromPointer = 360f - cwDistanceFromPointer;\n                // This is for if the first touch is on the actual pointer.\n                if (((touchEventRadius >= innerRadius) && (touchEventRadius <= outerRadius)) && ((cwDistanceFromPointer <= pointerRadiusDegrees) || (ccwDistanceFromPointer <= pointerRadiusDegrees))) {\n                    setProgressBasedOnAngle(mPointerPosition);\n                    lastCWDistanceFromStart = cwDistanceFromStart;\n                    mIsMovingCW = true;\n                    mPointerHaloPaint.setAlpha(mPointerAlphaOnTouch);\n                    mPointerHaloPaint.setColor(mPointerHaloColorOnTouch);\n                    recalculateAll();\n                    invalidate();\n                    if (mOnCircularSeekBarChangeListener != null) {\n                        mOnCircularSeekBarChangeListener.onStartTrackingTouch(this);\n                    }\n                    mUserIsMovingPointer = true;\n                    lockAtEnd = false;\n                    lockAtStart = false;\n                } else if (cwDistanceFromStart > mTotalCircleDegrees) { // If the user is touching outside of the start AND end\n                    mUserIsMovingPointer = false;\n                    return false;\n                } else if ((touchEventRadius >= innerRadius) && (touchEventRadius <= outerRadius)) { // If the user is touching near the circle\n                    setProgressBasedOnAngle(touchAngle);\n                    lastCWDistanceFromStart = cwDistanceFromStart;\n                    mIsMovingCW = true;\n                    mPointerHaloPaint.setAlpha(mPointerAlphaOnTouch);\n                    mPointerHaloPaint.setColor(mPointerHaloColorOnTouch);\n                    recalculateAll();\n                    invalidate();\n                    if (mOnCircularSeekBarChangeListener != null) {\n                        mOnCircularSeekBarChangeListener.onStartTrackingTouch(this);\n                        mOnCircularSeekBarChangeListener.onProgressChanged(this, mProgress, true);\n                    }\n                    mUserIsMovingPointer = true;\n                    lockAtEnd = false;\n                    lockAtStart = false;\n                } else { // If the user is not touching near the circle\n                    mUserIsMovingPointer = false;\n                    return false;\n                }\n                break;\n            case MotionEvent.ACTION_MOVE:\n                if (mUserIsMovingPointer) {\n                    if (lastCWDistanceFromStart < cwDistanceFromStart) {\n                        if ((cwDistanceFromStart - lastCWDistanceFromStart) > 180f && !mIsMovingCW) {\n                            lockAtStart = true;\n                            lockAtEnd = false;\n                        } else {\n                            mIsMovingCW = true;\n                        }\n                    } else {\n                        if ((lastCWDistanceFromStart - cwDistanceFromStart) > 180f && mIsMovingCW) {\n                            lockAtEnd = true;\n                            lockAtStart = false;\n                        } else {\n                            mIsMovingCW = false;\n                        }\n                    }\n\n                    if (lockAtStart && mIsMovingCW) {\n                        lockAtStart = false;\n                    }\n                    if (lockAtEnd && !mIsMovingCW) {\n                        lockAtEnd = false;\n                    }\n                    if (lockAtStart && !mIsMovingCW && (ccwDistanceFromStart > 90)) {\n                        lockAtStart = false;\n                    }\n                    if (lockAtEnd && mIsMovingCW && (cwDistanceFromEnd > 90)) {\n                        lockAtEnd = false;\n                    }\n                    // Fix for passing the end of a semi-circle quickly\n                    if (!lockAtEnd && cwDistanceFromStart > mTotalCircleDegrees && mIsMovingCW && lastCWDistanceFromStart < mTotalCircleDegrees) {\n                        lockAtEnd = true;\n                    }\n\n                    if (lockAtStart && lockEnabled) {\n                        // TODO: Add a check if mProgress is already 0, in which case don\'t call the listener\n                        mProgress = 0;\n                        recalculateAll();\n                        invalidate();\n                        if (mOnCircularSeekBarChangeListener != null) {\n                            mOnCircularSeekBarChangeListener.onProgressChanged(this, mProgress, true);\n                        }\n\n                    } else if (lockAtEnd && lockEnabled) {\n                        mProgress = mMax;\n                        recalculateAll();\n                        invalidate();\n                        if (mOnCircularSeekBarChangeListener != null) {\n                            mOnCircularSeekBarChangeListener.onProgressChanged(this, mProgress, true);\n                        }\n                    } else if ((mMoveOutsideCircle) || (touchEventRadius <= outerRadius)) {\n                        if (!(cwDistanceFromStart > mTotalCircleDegrees)) {\n                            setProgressBasedOnAngle(touchAngle);\n                        }\n                        recalculateAll();\n                        invalidate();\n                        if (mOnCircularSeekBarChangeListener != null) {\n                            mOnCircularSeekBarChangeListener.onProgressChanged(this, mProgress, true);\n                        }\n                    } else {\n                        break;\n                    }\n\n                    lastCWDistanceFromStart = cwDistanceFromStart;\n                } else {\n                    return false;\n                }\n                break;\n            case MotionEvent.ACTION_UP:\n                mPointerHaloPaint.setAlpha(mPointerAlpha);\n                mPointerHaloPaint.setColor(mPointerHaloColor);\n                if (mUserIsMovingPointer) {\n                    mUserIsMovingPointer = false;\n                    invalidate();\n                    if (mOnCircularSeekBarChangeListener != null) {\n                        mOnCircularSeekBarChangeListener.onStopTrackingTouch(this);\n                    }\n                } else {\n                    return false;\n                }\n                break;\n            case MotionEvent.ACTION_CANCEL: // Used when the parent view intercepts touches for things like scrolling\n                mPointerHaloPaint.setAlpha(mPointerAlpha);\n                mPointerHaloPaint.setColor(mPointerHaloColor);\n                mUserIsMovingPointer = false;\n                invalidate();\n                break;\n        }\n\n        if (event.getAction() == MotionEvent.ACTION_MOVE && getParent() != null) {\n            getParent().requestDisallowInterceptTouchEvent(true);\n        }\n\n        return true;\n    }\n\n    private void init(AttributeSet attrs, int defStyle) {\n        final TypedArray attrArray = getContext().obtainStyledAttributes(attrs, R.styleable.CircularSeekBar, defStyle, 0);\n\n        initAttributes(attrArray);\n\n        attrArray.recycle();\n\n        initPaints();\n    }\n\n    @Override\n    protected Parcelable onSaveInstanceState() {\n        Parcelable superState = super.onSaveInstanceState();\n\n        Bundle state = new Bundle();\n        state.putParcelable("PARENT", superState);\n        state.putInt("MAX", mMax);\n        state.putInt("PROGRESS", mProgress);\n        state.putInt("mCircleColor", mCircleColor);\n        state.putInt("mCircleProgressColor", mCircleProgressColor);\n        state.putInt("mPointerColor", mPointerColor);\n        state.putInt("mPointerHaloColor", mPointerHaloColor);\n        state.putInt("mPointerHaloColorOnTouch", mPointerHaloColorOnTouch);\n        state.putInt("mPointerAlpha", mPointerAlpha);\n        state.putInt("mPointerAlphaOnTouch", mPointerAlphaOnTouch);\n        state.putBoolean("lockEnabled", lockEnabled);\n\n        return state;\n    }\n\n    @Override\n    protected void onRestoreInstanceState(Parcelable state) {\n        Bundle savedState = (Bundle) state;\n\n        Parcelable superState = savedState.getParcelable("PARENT");\n        super.onRestoreInstanceState(superState);\n\n        mMax = savedState.getInt("MAX");\n        mProgress = savedState.getInt("PROGRESS");\n        mCircleColor = savedState.getInt("mCircleColor");\n        mCircleProgressColor = savedState.getInt("mCircleProgressColor");\n        mPointerColor = savedState.getInt("mPointerColor");\n        mPointerHaloColor = savedState.getInt("mPointerHaloColor");\n        mPointerHaloColorOnTouch = savedState.getInt("mPointerHaloColorOnTouch");\n        mPointerAlpha = savedState.getInt("mPointerAlpha");\n        mPointerAlphaOnTouch = savedState.getInt("mPointerAlphaOnTouch");\n        lockEnabled = savedState.getBoolean("lockEnabled");\n\n        initPaints();\n\n        recalculateAll();\n    }\n\n\n    public void setOnSeekBarChangeListener(OnCircularSeekBarChangeListener l) {\n        mOnCircularSeekBarChangeListener = l;\n    }\n\n    /**\n     * Gets the circle color.\n     *\n     * @return An integer color value for the circle\n     */\n    public int getCircleColor() {\n        return mCircleColor;\n    }\n\n    /**\n     * Sets the circle color.\n     *\n     * @param color the color of the circle\n     */\n    public void setCircleColor(int color) {\n        mCircleColor = color;\n        mCirclePaint.setColor(mCircleColor);\n        invalidate();\n    }\n\n    /**\n     * Gets the circle progress color.\n     *\n     * @return An integer color value for the circle progress\n     */\n    public int getCircleProgressColor() {\n        return mCircleProgressColor;\n    }\n\n    /**\n     * Sets the circle progress color.\n     *\n     * @param color the color of the circle progress\n     */\n    public void setCircleProgressColor(int color) {\n        mCircleProgressColor = color;\n        mCircleProgressPaint.setColor(mCircleProgressColor);\n        invalidate();\n    }\n\n    /**\n     * Gets the pointer color.\n     *\n     * @return An integer color value for the pointer\n     */\n    public int getPointerColor() {\n        return mPointerColor;\n    }\n\n    /**\n     * Sets the pointer color.\n     *\n     * @param color the color of the pointer\n     */\n    public void setPointerColor(int color) {\n        mPointerColor = color;\n        mPointerPaint.setColor(mPointerColor);\n        invalidate();\n    }\n\n    /**\n     * Gets the pointer halo color.\n     *\n     * @return An integer color value for the pointer halo\n     */\n    public int getPointerHaloColor() {\n        return mPointerHaloColor;\n    }\n\n    /**\n     * Sets the pointer halo color.\n     *\n     * @param color the color of the pointer halo\n     */\n    public void setPointerHaloColor(int color) {\n        mPointerHaloColor = color;\n        mPointerHaloPaint.setColor(mPointerHaloColor);\n        invalidate();\n    }\n\n    /**\n     * Gets the pointer alpha value.\n     *\n     * @return An integer alpha value for the pointer (0..255)\n     */\n    public int getPointerAlpha() {\n        return mPointerAlpha;\n    }\n\n    /**\n     * Sets the pointer alpha.\n     *\n     * @param alpha the alpha of the pointer\n     */\n    public void setPointerAlpha(int alpha) {\n        if (alpha >= 0 && alpha <= 255) {\n            mPointerAlpha = alpha;\n            mPointerHaloPaint.setAlpha(mPointerAlpha);\n            invalidate();\n        }\n    }\n\n    /**\n     * Gets the pointer alpha value when touched.\n     *\n     * @return An integer alpha value for the pointer (0..255) when touched\n     */\n    public int getPointerAlphaOnTouch() {\n        return mPointerAlphaOnTouch;\n    }\n\n    /**\n     * Sets the pointer alpha when touched.\n     *\n     * @param alpha the alpha of the pointer (0..255) when touched\n     */\n    public void setPointerAlphaOnTouch(int alpha) {\n        if (alpha >= 0 && alpha <= 255) {\n            mPointerAlphaOnTouch = alpha;\n        }\n    }\n\n    /**\n     * Gets the circle fill color.\n     *\n     * @return An integer color value for the circle fill\n     */\n    public int getCircleFillColor() {\n        return mCircleFillColor;\n    }\n\n    /**\n     * Sets the circle fill color.\n     *\n     * @param color the color of the circle fill\n     */\n    public void setCircleFillColor(int color) {\n        mCircleFillColor = color;\n        mCircleFillPaint.setColor(mCircleFillColor);\n        invalidate();\n    }\n\n    /**\n     * Get the current max of the CircularSeekBar.\n     *\n     * @return Synchronized integer value of the max.\n     */\n    public synchronized int getMax() {\n        return mMax;\n    }\n\n    /**\n     * Set the max of the CircularSeekBar.\n     * If the new max is less than the current progress, then the progress will be set to zero.\n     * If the progress is changed as a result, then any listener will receive a onProgressChanged event.\n     *\n     * @param max The new max for the CircularSeekBar.\n     */\n    public void setMax(int max) {\n        if (!(max <= 0)) { // Check to make sure it\'s greater than zero\n            if (max <= mProgress) {\n                mProgress = 0; // If the new max is less than current progress, set progress to zero\n                if (mOnCircularSeekBarChangeListener != null) {\n                    mOnCircularSeekBarChangeListener.onProgressChanged(this, mProgress, false);\n                }\n            }\n            mMax = max;\n\n            recalculateAll();\n            invalidate();\n        }\n    }\n\n    /**\n     * Listener for the CircularSeekBar. Implements the same methods as the normal OnSeekBarChangeListener.\n     */\n    public interface OnCircularSeekBarChangeListener {\n\n        void onProgressChanged(CircularSeekBar circularSeekBar, int progress, boolean fromUser);\n\n        void onStopTrackingTouch(CircularSeekBar seekBar);\n\n        void onStartTrackingTouch(CircularSeekBar seekBar);\n    }\n\n}'