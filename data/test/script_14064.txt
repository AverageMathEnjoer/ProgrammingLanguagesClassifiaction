b'class Bcc{\n  vector<int> num,inS;\n  stack<int> roots,st;\n  int cnt;\npublic:\n  vv<int> bcc,tree;\n  vector<int> brdg,inv;\n  void dfs(const vv<int> &g,const vector<pii> &es,int v,int e){\n    num[v]=++cnt;\n    st.push(v); inS[v]=1; roots.push(v);\n    for(const int &i:g[v])if(i!=e){\n\tint w=es[i].X+es[i].Y-v;\n\tif(!num[w]){\n\t  dfs(g,es,w,i);\n\t}else if(inS[w]){\n\t  while(num[roots.top()]>num[w]) roots.pop();\n\t}\n      }\n    if(v==roots.top()){\n      brdg.pb(e);\n      bcc.pb(vector<int>());\n      while(1){\n\tint w=st.top(); st.pop(); inS[w]=0;\n\tbcc.back().pb(w);\n\tif(v==w) break;\n      }\n      roots.pop();\n    }\n  }\n  \n  Bcc(vv<int> &g,vector<pii> es){\n    const int n=g.size();\n    num.resize(n); inS.resize(n);\n    int cnt=0;\n    rep(i,n)if(!num[i]){\n      dfs(g,es,i,-1);\n      brdg.pop_back();\n    }\n    const int m=bcc.size();\n    inv.resize(n);\n    rep(i,m) for(const int &v:bcc[i]) inv[v]=i;\n    for(pii &p:es){p.X=inv[p.X]; p.Y=inv[p.Y];}\n    //sort(all(es)); UNIQUE(es);\n    tree.resize(m); //tedge.resize(m);\n    int i=0;\n    for(const pii &p:es){\n      if(p.X!=p.Y){\n\ttree[p.X].pb(p.Y);\n\ttree[p.Y].pb(p.X);\n\t// tedge[p.X].pb(i);\n\t// tedge[p.Y].pb(i);\n      }\n      ++i;\n    }\n  }\n};\n'