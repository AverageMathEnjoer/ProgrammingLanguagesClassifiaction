b"-- |\n-- Copyright  : (c) Ivan Perez, 2017-2023\n-- License    : BSD3\n-- Maintainer : ivan.perez@keera.co.uk\n--\n-- Streams and stream manipulation API.\n--\n-- The evaluation of Dunai MSFs, especially for testing purposes, needs the\n-- generation of suitable input streams.\n--\n-- While some streams can be generated randomly using QuickCheck, it is\n-- sometimes useful to be able to preprend or adapt an input stream. It is also\n-- useful to debug programs when you have recorded input streams using Haskell\n-- Titan.\n--\n-- This module defines types for input streams, as well as an API to create,\n-- examine and combine streams. It also provides evaluation functions that are\n-- needed to apply an MSF to a stream and obtain an output stream and a\n-- continuation MSF.\nmodule FRP.Dunai.Stream where\n\n-- External imports\nimport Control.Monad.Trans.MSF.Reader          (ReaderT, readerS, runReaderS)\nimport Data.MonadicStreamFunction              (MSF)\nimport Data.MonadicStreamFunction.InternalCore (unMSF)\n\n-- * Types\n\n-- | A stream of samples, with their sampling times.\ntype SignalSampleStream a = SampleStream (DTime, a)\n\n-- | A stream of samples, with no sampling time.\ntype SampleStream a = [a]\n\n-- | DTime is the time type for lengths of sample intervals. Conceptually,\n-- DTime = R+ = { x in R | x > 0 }.\ntype DTime = Double\n\n-- ** Creation\n\n-- | Group a series of samples with a series of time deltas.\n--\n-- The first sample will have no delta. Unused samples and deltas will be\n-- dropped.\ngroupDeltas :: [a] -> [DTime] -> SignalSampleStream a\ngroupDeltas xs ds = zip (0:ds) xs\n\n-- * Obtain samples\n\n-- | Turn a stream with sampling times into a list of values.\nsamples :: SignalSampleStream a -> [a]\nsamples = map snd\n\n-- | Return the first sample in a signal sample stream.\nfirstSample :: SignalSampleStream a -> a\nfirstSample = head . samples\n\n-- | Return the last sample in a signal sample stream.\nlastSample :: SignalSampleStream a -> a\nlastSample = last . samples\n\n-- * Stream manipulation\n\n-- ** Merging\n\n-- | Merge two streams, using an auxiliary function to merge samples that fall\n-- at the exact same sampling time.\nsMerge :: (a -> a -> a)\n       -> SignalSampleStream a\n       -> SignalSampleStream a\n       -> SignalSampleStream a\nsMerge _ []                xs2               = xs2\nsMerge _ xs1               []                = xs1\nsMerge f ((dt1, x1) : xs1) ((dt2, x2) : xs2)\n  | dt1 == dt2 = (dt1, f x1 x2) : sMerge f xs1 xs2\n  | dt1 <  dt2 = (dt1, x1) : sMerge f xs1 ((dt2 - dt1, x2) : xs2)\n  | otherwise  = (dt2, x2) : sMerge f ((dt1 - dt2, x1) : xs1) xs2\n\n-- ** Concatenating\n\n-- | Concatenate two sample streams, separating them by a given time delta.\nsConcat :: SignalSampleStream a -> SignalSampleStream a -> SignalSampleStream a\nsConcat xs1 xs2 = xs1 ++ xs2\n\n-- ** Refining\n\n-- | Refine a signal sample stream by establishing the maximum time delta.\n--\n-- If two samples are separated by a time delta bigger than the given max DT,\n-- the former is replicated as many times as necessary.\nsRefine :: DTime -> a -> SignalSampleStream a -> SignalSampleStream a\nsRefine _     _  []             = []\nsRefine maxDT a0 ((dt, a) : as)\n  | dt > maxDT = (maxDT, a0) : sRefine maxDT a0 ((dt - maxDT, a) : as)\n  | otherwise  = (dt, a) : sRefine maxDT a as\n\n-- | Refine a stream by establishing the maximum time delta.\n--\n-- If two samples are separated by a time delta bigger than the given max DT,\n-- the auxiliary interpolation function is used to determine the intermediate\n-- sample.\nrefineWith :: (a -> a -> a)\n           -> DTime\n           -> a\n           -> SignalSampleStream a\n           -> SignalSampleStream a\nrefineWith _           _     _  []             = []\nrefineWith interpolate maxDT a0 ((dt, a) : as)\n    | dt > maxDT\n    = (maxDT, interpolate a0 a) :\n        refineWith interpolate maxDT a' ((dt - maxDT, a) : as)\n    | otherwise\n    = (dt, a) : refineWith interpolate maxDT a as\n  where\n    a' = interpolate a0 a\n\n-- ** Clipping (dropping samples)\n\n-- | Clip a signal sample stream at a given number of samples.\nsClipAfterFrame :: Int -> SignalSampleStream a -> SignalSampleStream a\nsClipAfterFrame = take\n\n-- | Clip a signal sample stream after a certain (non-zero) time.\nsClipAfterTime :: DTime -> SignalSampleStream a -> SignalSampleStream a\nsClipAfterTime _  []              = []\nsClipAfterTime dt ((dt', x) : xs)\n  | dt < dt'  = []\n  | otherwise = (dt', x) : sClipAfterTime (dt - dt') xs\n\n-- | Drop the first n samples of a signal sample stream. The time deltas are\n-- not re-calculated.\nsClipBeforeFrame :: Int -> SignalSampleStream a -> SignalSampleStream a\nsClipBeforeFrame 0 xs@(_:_) = xs\nsClipBeforeFrame _ xs@[_]   = xs\nsClipBeforeFrame n xs       = sClipBeforeFrame (n - 1) xs\n\n-- | Drop the first samples of a signal sample stream up to a given time. The\n-- time deltas are not re-calculated to match the original stream.\nsClipBeforeTime :: DTime -> SignalSampleStream a -> SignalSampleStream a\nsClipBeforeTime dt xs\n    | dt <= 0        = xs\n    | length xs == 1 = xs\n    | dt < dt'       = (dt' - dt, x') : xs'\n    | otherwise      = sClipBeforeTime (dt - dt') ((0, x') : xs')\n  where\n    (_ : (dt', x') : xs') = xs\n\n-- | Evaluate an SF with a 'SignalSampleStream', obtaining an output stream and\n-- a continuation.\n--\n-- You should never use this for actual execution in your applications, only\n-- for testing.\nevalSF :: Monad m\n       => MSF (ReaderT DTime m) a b\n       -> SignalSampleStream a\n       -> m (SampleStream b, MSF (ReaderT DTime m) a b)\nevalSF fsf as = do\n    (ss, msf') <- evalMSF msf'' as\n    return (ss, readerS msf')\n  where\n    msf'' = runReaderS fsf\n\n-- | Evaluate an MSF with a 'SampleStream', obtaining an output stream and a\n-- continuation.\n--\n-- You should never use this for actual execution in your applications, only\n-- for testing.\nevalMSF :: Monad m\n        => MSF m a b\n        -> SampleStream a\n        -> m (SampleStream b, MSF m a b)\nevalMSF fsf []     = return ([], fsf)\nevalMSF fsf (a:as) = do\n  (b, fsf')   <- unMSF fsf a\n  (bs, fsf'') <- evalMSF fsf' as\n  let outputStrm = b : bs\n  return (outputStrm, fsf'')\n"