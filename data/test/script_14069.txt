b'{-# LANGUAGE ExistentialQuantification #-}\n{-# LANGUAGE FlexibleContexts #-}\n{-# LANGUAGE GADTs #-}\n{-# LANGUAGE ImportQualifiedPost #-}\n{-# LANGUAGE OverloadedStrings #-}\n{-# LANGUAGE RankNTypes #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n{-# LANGUAGE TypeApplications #-}\n{-# LANGUAGE TypeFamilies #-}\n{-# LANGUAGE TypeOperators #-}\n\nmodule App (app) where\n\nimport Control.Monad\nimport Control.Monad.IO.Class\nimport Control.Monad.Trans.Except\nimport Data.Aeson\nimport Data.Maybe\nimport Data.Text.Lazy (Text)\nimport Data.Text.Lazy qualified as TL\nimport Idp\nimport Network.HTTP.Conduit\nimport Network.HTTP.Types\nimport Network.OAuth.OAuth2\nimport Network.OAuth.OAuth2 qualified as OAuth2\nimport Network.OAuth2.Experiment\nimport Network.OAuth2.Provider.Auth0 qualified as IAuth0\nimport Network.OAuth2.Provider.Okta qualified as IOkta\nimport Network.Wai qualified as WAI\nimport Network.Wai.Handler.Warp (run)\nimport Network.Wai.Middleware.Static\nimport Session\nimport Types\nimport Utils\nimport Views\nimport Web.Scotty\nimport Prelude\n\n------------------------------\n-- App\n------------------------------\n\nmyServerPort :: Int\nmyServerPort = 9988\n\napp :: IO ()\napp =\n  putStrLn ("Starting Server. http://localhost:" ++ show myServerPort)\n    >> waiApp\n    >>= run myServerPort\n\nwaiApp :: IO WAI.Application\nwaiApp = do\n  cache <- initCacheStore\n  re <- runExceptT $ do\n    myAuth0Idp <- IAuth0.mkAuth0Idp "freizl.auth0.com"\n    myOktaIdp <- IOkta.mkOktaIdp "dev-494096.okta.com"\n    -- For the sake of simplicity for this demo App,\n    -- I store user data in MVar in server side.\n    -- It means user session shared across browsers.\n    -- which simplify my testing cross browsers.\n    -- I am sure you don\'t want to this for your production services.\n    initIdps cache (myAuth0Idp, myOktaIdp)\n    pure (myAuth0Idp, myOktaIdp)\n  case re of\n    Left e -> Prelude.error $ TL.unpack $ "unable to init cache: " <> e\n    Right r -> do\n      putStrLn "global cache has been initialized."\n      initApp cache r\n\ninitApp :: CacheStore -> (Idp IAuth0.Auth0, Idp IOkta.Okta) -> IO WAI.Application\ninitApp cache idps = scottyApp $ do\n  middleware $ staticPolicy (addBase "public/assets")\n  defaultHandler globalErrorHandler\n  get "/" $ indexH cache\n  get "/oauth2/callback" $ callbackH cache\n  get "/logout" $ logoutH cache\n  get "/refresh" $ refreshH cache\n\n  get "/login/password-grant" $ testPasswordGrantTypeH idps\n  get "/login/cc-grant" (testClientCredentialGrantTypeH idps)\n\n  get "/login/jwt-grant" testJwtBearerGrantTypeH\n\n--------------------------------------------------\n\n-- * Handlers\n\n--------------------------------------------------\n\nredirectToHomeM :: ActionM ()\nredirectToHomeM = redirect "/"\n\nglobalErrorHandler :: Text -> ActionM ()\nglobalErrorHandler t = status status500 >> html t\n\nrefreshH :: CacheStore -> ActionM ()\nrefreshH c = do\n  idpData@(DemoAppEnv idp sData) <- readIdpParam c\n  exceptToActionM $ do\n    newToken <- doRefreshToken idpData\n    liftIO $ putStrLn ">>>>>> got new token"\n    upsertDemoAppEnv c (DemoAppEnv idp (sData {oauth2Token = Just newToken}))\n  redirectToHomeM\n\nlogoutH :: CacheStore -> ActionM ()\nlogoutH c = do\n  idpData <- readIdpParam c\n  liftIO (removeKey c (toLabel idpData))\n  redirectToHomeM\n\nindexH :: CacheStore -> ActionM ()\nindexH c = liftIO (allValues c) >>= overviewTpl\n\ncallbackH :: CacheStore -> ActionM ()\ncallbackH c = do\n  -- https://hackage.haskell.org/package/scotty-0.12/docs/Web-Scotty.html#t:Param\n  -- (Text, Text)\n  pas <- params\n  let stateP = paramValue "state" pas\n  when (null stateP) (raise "callbackH: no state from callback request")\n  let codeP = paramValue "code" pas\n  when (null codeP) (raise "callbackH: no code from callback request")\n  exceptToActionM $ do\n    idpData <- lookupKey c (TL.takeWhile (/= \'.\') (head stateP))\n    fetchTokenAndUser c (head codeP) idpData\n  redirectToHomeM\n\ntestPasswordGrantTypeH :: (Idp IAuth0.Auth0, Idp IOkta.Okta) -> ActionM ()\ntestPasswordGrantTypeH (auth0, okta) = do\n  idpP <- paramValue "i" <$> params\n  when (null idpP) (raise "testPasswordGrantTypeH: no idp parameter in the password grant type login request")\n  let i = head idpP\n  case i of\n    "auth0" -> testPasswordGrantType (auth0PasswordGrantApp auth0)\n    "okta" -> testPasswordGrantType (oktaPasswordGrantApp okta)\n    _ -> raise $ "unable to find password grant type flow for idp " <> i\n  where\n    testPasswordGrantType ::\n      ( HasTokenRequest a\n      , \'ResourceOwnerPassword ~ a\n      , HasDemoLoginUser b\n      , HasUserInfoRequest a\n      , FromJSON (IdpUserInfo b)\n      ) =>\n      IdpApplication a b ->\n      ActionM ()\n    testPasswordGrantType idpApp = do\n      exceptToActionM $ do\n        mgr <- liftIO $ newManager tlsManagerSettings\n        token <- withExceptT oauth2ErrorToText $ conduitTokenRequest idpApp mgr\n        user <- tryFetchUser mgr token idpApp\n        liftIO $ print user\n      redirectToHomeM\n\ntestClientCredentialGrantTypeH :: (Idp IAuth0.Auth0, Idp IOkta.Okta) -> ActionM ()\ntestClientCredentialGrantTypeH (auth0, okta) = do\n  idpP <- paramValue "i" <$> params\n  when (null idpP) (raise "testClientCredentialsGrantTypeH: no idp parameter in the password grant type login request")\n  let i = head idpP\n  case i of\n    "auth0" -> testClientCredentialsGrantType (auth0ClientCredentialsGrantApp auth0)\n    "okta" -> liftIO (oktaClientCredentialsGrantApp okta) >>= testClientCredentialsGrantType\n    _ -> raise $ "unable to find password grant type flow for idp " <> i\n\ntestClientCredentialsGrantType ::\n  forall a b.\n  ( \'ClientCredentials ~ b\n  ) =>\n  HasTokenRequest b =>\n  IdpApplication b a ->\n  ActionM ()\ntestClientCredentialsGrantType testApp = do\n  exceptToActionM $ do\n    mgr <- liftIO $ newManager tlsManagerSettings\n    -- client credentials flow is meant for machine to machine\n    -- hence wont be able to hit /userinfo endpoint\n    tokenResp <- withExceptT oauth2ErrorToText $ conduitTokenRequest testApp mgr\n    liftIO $ print tokenResp\n  redirectToHomeM\n\n-- Only testing google for now\ntestJwtBearerGrantTypeH :: ActionM ()\ntestJwtBearerGrantTypeH = do\n  exceptToActionM $ do\n    testApp <- googleServiceAccountApp\n    mgr <- liftIO $ newManager tlsManagerSettings\n    tokenResp <- withExceptT oauth2ErrorToText $ conduitTokenRequest testApp mgr\n    user <- tryFetchUser mgr tokenResp testApp\n    liftIO $ print user\n  redirectToHomeM\n\n--------------------------------------------------\n\n-- * Services\n\n--------------------------------------------------\n\nexceptToActionM :: Show a => ExceptT Text IO a -> ActionM a\nexceptToActionM e = do\n  result <- liftIO $ runExceptT e\n  either raise return result\n\nreadIdpParam :: CacheStore -> ActionM DemoAppEnv\nreadIdpParam c = do\n  pas <- params\n  let idpP = paramValue "idp" pas\n  when (null idpP) redirectToHomeM\n  exceptToActionM $ lookupKey c (head idpP)\n\nfetchTokenAndUser ::\n  CacheStore ->\n  Text ->\n  DemoAppEnv ->\n  ExceptT Text IO ()\nfetchTokenAndUser c exchangeToken idpData@(DemoAppEnv (DemoAuthorizationApp idpAppConfig) DemoAppPerAppSessionData {..}) = do\n  mgr <- liftIO $ newManager tlsManagerSettings\n  token <-\n    if isSupportPkce idpAppConfig\n      then do\n        when (isNothing authorizePkceCodeVerifier) (throwE "Unable to find code verifier")\n        withExceptT oauth2ErrorToText $\n          conduitPkceTokenRequest\n            idpAppConfig\n            mgr\n            (ExchangeToken $ TL.toStrict exchangeToken, fromJust authorizePkceCodeVerifier)\n      else withExceptT oauth2ErrorToText $ conduitTokenRequest idpAppConfig mgr (ExchangeToken $ TL.toStrict exchangeToken)\n  liftIO $ do\n    putStrLn "Found access token"\n    print token\n  luser <- tryFetchUser mgr token idpAppConfig\n  liftIO $ do\n    print luser\n  updateIdp c idpData luser token\n  where\n    updateIdp :: MonadIO m => CacheStore -> DemoAppEnv -> DemoLoginUser -> OAuth2Token -> ExceptT Text m ()\n    updateIdp c1 (DemoAppEnv iApp sData) luser token =\n      upsertDemoAppEnv\n        c1\n        (DemoAppEnv iApp $ sData {loginUser = Just luser, oauth2Token = Just token})\n\noauth2ErrorToText :: TokenRequestError -> Text\noauth2ErrorToText e = TL.pack $ "conduitTokenRequest - cannot fetch access token. error detail: " ++ show e\n\ntryFetchUser ::\n  forall a b.\n  (HasDemoLoginUser a, HasUserInfoRequest b, FromJSON (IdpUserInfo a)) =>\n  Manager ->\n  OAuth2Token ->\n  IdpApplication b a ->\n  ExceptT Text IO DemoLoginUser\ntryFetchUser mgr at idpAppConfig = do\n  user <- withExceptT bslToText $ conduitUserInfoRequest idpAppConfig mgr (accessToken at)\n  pure $ toLoginUser @a user\n\ndoRefreshToken :: DemoAppEnv -> ExceptT Text IO OAuth2Token\ndoRefreshToken (DemoAppEnv (DemoAuthorizationApp idpAppConfig) (DemoAppPerAppSessionData {..})) = do\n  at <- maybe (throwE "no token response found for idp") pure oauth2Token\n  rt <- maybe (throwE "no refresh token found for idp") pure (OAuth2.refreshToken at)\n  withExceptT (TL.pack . show) $ do\n    mgr <- liftIO $ newManager tlsManagerSettings\n    conduitRefreshTokenRequest idpAppConfig mgr rt\n'