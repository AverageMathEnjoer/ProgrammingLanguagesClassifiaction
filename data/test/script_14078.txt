b'{-# LANGUAGE\n    CPP\n  , DoAndIfThenElse\n  , LambdaCase\n  , PatternGuards\n  , TemplateHaskell\n  , ViewPatterns\n  #-}\nmodule Rest.Gen.Haskell\n  ( HaskellContext (..)\n  , mkHsApi\n  ) where\n\nimport Control.Applicative\nimport Control.Arrow (first, second)\nimport Control.Category\nimport Control.Monad\nimport Data.Label (modify, set)\nimport Data.Label.Derive (mkLabelsNamed)\nimport Data.List\nimport Data.Maybe\nimport Prelude hiding (id, (.))\nimport Safe\nimport System.Directory\nimport System.FilePath\nimport qualified Data.Generics.Uniplate.Data                 as U\nimport qualified Data.Label.Total                            as L\nimport qualified Data.List.NonEmpty                          as NList\nimport qualified Distribution.ModuleName                     as Cabal\nimport qualified Distribution.Package                        as Cabal\nimport qualified Distribution.PackageDescription             as Cabal\nimport qualified Distribution.PackageDescription.Parse       as Cabal\nimport qualified Distribution.PackageDescription.PrettyPrint as Cabal\nimport qualified Distribution.Simple.Utils                   as Cabal\nimport qualified Distribution.Verbosity                      as Cabal\nimport qualified Distribution.Version                        as Cabal\nimport qualified Language.Haskell.Exts.Pretty                as H\nimport qualified Language.Haskell.Exts.Syntax                as H\n\nimport Rest.Api (Router, Version)\n\nimport Rest.Gen.Base\nimport Rest.Gen.Types\nimport Rest.Gen.Utils\nimport qualified Rest.Gen.NoAnnotation          as N\nimport qualified Rest.Gen.Base.ActionInfo.Ident as Ident\n\nmkLabelsNamed ("_" ++) [\'\'Cabal.GenericPackageDescription, \'\'Cabal.CondTree, \'\'Cabal.Library]\n\ndata HaskellContext =\n  HaskellContext\n    { apiVersion     :: Version\n    , targetPath     :: String\n    , wrapperName    :: String\n    , includePrivate :: Bool\n    , sources        :: [N.ModuleName]\n    , imports        :: [N.ImportDecl]\n    , rewrites       :: [(N.ModuleName, N.ModuleName)]\n    , namespace      :: [String]\n    }\n\nmkHsApi :: HaskellContext -> Router m s -> IO ()\nmkHsApi ctx r =\n  do let tree = sortTree . (if includePrivate ctx then id else noPrivate) . apiSubtrees $ r\n     mkCabalFile ctx tree\n     mapM_ (writeRes ctx) $ allSubTrees tree\n\nmkCabalFile :: HaskellContext -> ApiResource -> IO ()\nmkCabalFile ctx tree =\n  do cabalExists <- doesFileExist cabalFile\n     gpkg <-\n       if cabalExists\n       then updateExposedModules modules <$> Cabal.readPackageDescription Cabal.normal cabalFile\n       else return (mkGenericPackageDescription (wrapperName ctx) modules)\n     writeCabalFile cabalFile gpkg\n  where\n    cabalFile = targetPath ctx </> wrapperName ctx ++ ".cabal"\n    modules   = map (Cabal.fromString . unModuleName) (sources ctx)\n             ++ map (Cabal.fromString . qualModName . (namespace ctx ++)) (allSubResourceIds tree)\n\nwriteCabalFile :: FilePath -> Cabal.GenericPackageDescription -> IO ()\nwriteCabalFile path = Cabal.writeUTF8File path . unlines . filter emptyField . lines . Cabal.showGenericPackageDescription\n  where emptyField = (/= "\\"\\" ") . takeWhile (/= \':\') . reverse\n\nupdateExposedModules :: [Cabal.ModuleName] -> Cabal.GenericPackageDescription -> Cabal.GenericPackageDescription\nupdateExposedModules modules = modify _condLibrary (Just . maybe (mkCondLibrary modules) (set (_exposedModules . _condTreeData) modules))\n\nmkGenericPackageDescription :: String -> [Cabal.ModuleName] -> Cabal.GenericPackageDescription\nmkGenericPackageDescription name modules =\n#if MIN_VERSION_Cabal(2,0,0)\n  Cabal.GenericPackageDescription pkg [] (Just (mkCondLibrary modules)) [] [] [] [] []\n#else\n  Cabal.GenericPackageDescription pkg [] (Just (mkCondLibrary modules)) [] [] []\n#endif\n  where\n    pkg = Cabal.emptyPackageDescription\n      { Cabal.package        = Cabal.PackageIdentifier (cabalPackageName name) (cabalVersion [0, 1])\n      , Cabal.buildType      = Just Cabal.Simple\n      , Cabal.specVersionRaw = Right (Cabal.orLaterVersion (cabalVersion [1, 8]))\n      }\n\nmkCondLibrary :: [Cabal.ModuleName] -> Cabal.CondTree Cabal.ConfVar [Cabal.Dependency] Cabal.Library\nmkCondLibrary modules = Cabal.CondNode\n  { Cabal.condTreeData        = cabalLibrary modules\n  , Cabal.condTreeConstraints =\n     [ Cabal.Dependency (cabalPackageName "base")        (Cabal.withinVersion $ cabalVersion [4]      )\n     , Cabal.Dependency (cabalPackageName "rest-types")  (Cabal.withinVersion $ cabalVersion [1, 10]  )\n     , Cabal.Dependency (cabalPackageName "rest-client") (Cabal.withinVersion $ cabalVersion [0, 5, 2])\n     ]\n  , Cabal.condTreeComponents  = []\n  }\n\ncabalLibrary :: [Cabal.ModuleName] -> Cabal.Library\n#if MIN_VERSION_Cabal(2,0,0)\ncabalLibrary mods = Cabal.emptyLibrary\n  { Cabal.exposedModules = mods\n  , Cabal.libBuildInfo = (Cabal.libBuildInfo Cabal.emptyLibrary) { Cabal.hsSourceDirs = ["src"] }\n  }\n#else\n#if MIN_VERSION_Cabal(1,22,0)\ncabalLibrary mods = Cabal.Library mods [] [] [] True Cabal.emptyBuildInfo { Cabal.hsSourceDirs = ["src"] }\n#else\ncabalLibrary mods = Cabal.Library mods True Cabal.emptyBuildInfo { Cabal.hsSourceDirs = ["src"] }\n#endif\n#endif\n\ncabalVersion :: [Int] -> Cabal.Version\n#if MIN_VERSION_Cabal(2,0,0)\ncabalVersion = Cabal.mkVersion\n#else\ncabalVersion v = Cabal.Version v []\n#endif\n\ncabalPackageName :: String -> Cabal.PackageName\n#if MIN_VERSION_Cabal(2,0,0)\ncabalPackageName =  Cabal.mkPackageName\n#else\ncabalPackageName = Cabal.PackageName\n#endif\n\nwriteRes :: HaskellContext -> ApiResource -> IO ()\nwriteRes ctx node =\n  do createDirectoryIfMissing True (targetPath ctx </> "src" </> modPath (namespace ctx ++ resParents node))\n     writeFile (targetPath ctx </> "src" </> modPath (namespace ctx ++ resId node) ++ ".hs") (mkRes ctx node)\n\nmkRes :: HaskellContext -> ApiResource -> String\nmkRes ctx node = H.prettyPrint $ buildHaskellModule ctx node pragmas Nothing\n  where\n    pragmas :: [N.ModulePragma]\n    pragmas = [ H.LanguagePragma () [H.Ident () "OverloadedStrings"]\n              , H.OptionsPragma () (Just H.GHC) "-fno-warn-unused-imports"\n              ]\n    _warningText = "Warning!! This is automatically generated code, do not modify!"\n\nbuildHaskellModule :: HaskellContext -> ApiResource ->\n                      [N.ModulePragma] -> Maybe N.WarningText ->\n                      N.Module\nbuildHaskellModule ctx node pragmas warningText =\n  rewriteModuleNames (rewrites ctx) $\n     H.Module () (Just $ H.ModuleHead () name warningText exportSpecs) pragmas importDecls decls\n  where\n    name :: N.ModuleName\n    name = H.ModuleName () $ qualModName $ namespace ctx ++ resId node\n    exportSpecs :: Maybe N.ExportSpecList\n    exportSpecs = Nothing\n    importDecls :: [N.ImportDecl]\n    importDecls = nub $ namedImport "Rest.Client.Internal"\n                      : extraImports\n                     ++ parentImports\n                     ++ dataImports\n                     ++ idImports\n    decls :: [N.Decl]\n    decls = idData node ++ concat funcs\n\n    extraImports :: [N.ImportDecl]\n    extraImports = imports ctx\n    parentImports :: [N.ImportDecl]\n    parentImports = map mkImport . tail . inits . resParents $ node\n    dataImports :: [N.ImportDecl]\n    dataImports = map (qualImport . unModuleName) datImp\n    idImports :: [N.ImportDecl]\n    idImports = concat . mapMaybe (return . map (qualImport . unModuleName) . Ident.haskellModules <=< snd) . resAccessors $ node\n\n    funcs :: [[N.Decl]]\n    datImp :: [N.ModuleName]\n    (funcs, datImp) = second (nub . concat) . unzip . map (mkFunction (apiVersion ctx) . resName $ node) $ resItems node\n    mkImport :: [String] -> N.ImportDecl\n    mkImport p = (namedImport importName)\n                   { H.importQualified = True\n                   , H.importAs        = importAs\'\n                   }\n      where\n        importName :: String\n        importName = qualModName $ namespace ctx ++ p\n        importAs\' :: Maybe N.ModuleName\n        importAs\' = fmap (H.ModuleName () . modName) . lastMay $ p\n\nrewriteModuleNames :: [(N.ModuleName, N.ModuleName)] -> N.Module -> N.Module\nrewriteModuleNames rews = U.transformBi $ \\m -> lookupJustDef m m rews\n\nnoBinds :: Maybe N.Binds\nnoBinds = Nothing\n\nuse :: N.Name -> N.Exp\nuse = H.Var () . H.UnQual ()\n\nuseMQual :: Maybe N.ModuleName -> N.Name -> N.Exp\nuseMQual Nothing = use\nuseMQual (Just qual) = H.Var () . H.Qual () qual\n\nmkFunction :: Version -> String -> ApiAction -> ([N.Decl], [N.ModuleName])\nmkFunction ver res (ApiAction _ lnk ai) =\n  ([H.TypeSig () [funName] fType,\n    H.FunBind () [H.Match () funName fParams rhs noBinds]],\n    responseModules errorI ++ responseModules output ++ maybe [] inputModules mInp)\n     where\n       funName :: N.Name\n       funName = mkHsName ai\n       fParams :: [N.Pat]\n       fParams = map (H.PVar ()) $ lPars\n                           ++ maybe [] ((:[]) . hsName . cleanName . description) (ident ai)\n                           ++ maybe [] (const [input]) mInp\n                           ++ (if null (params ai) then [] else [pList])\n       lUrl :: N.Exp\n       lPars :: [N.Name]\n       (lUrl, lPars) = linkToURL res lnk\n       mInp :: Maybe InputInfo\n       mInp = fmap (inputInfo . L.get desc . chooseType) . NList.nonEmpty . inputs $ ai\n       fType :: N.Type\n       fType = H.TyForall () Nothing (Just ctx) $ fTypify tyParts\n         where\n           ctx :: N.Context\n           ctx = H.CxSingle () $ H.ClassA () (H.UnQual () cls) [m]\n           cls :: N.Name\n           cls = H.Ident () "ApiStateC"\n           m :: N.Type\n           m = H.TyVar () $ H.Ident () "m"\n           fTypify :: [N.Type] -> N.Type\n           fTypify = \\case\n             []          -> error "Rest.Gen.Haskell.mkFunction.fTypify - expects at least one type"\n             [ty1]       -> ty1\n             [ty1, ty2]  -> H.TyFun () ty1 ty2\n             (ty1 : tys) -> H.TyFun () ty1 (fTypify tys)\n           tyParts :: [N.Type]\n           tyParts = map qualIdent lPars\n                  ++ maybe [] (return . Ident.haskellType) (ident ai)\n                  ++ inp\n                  ++ (if null (params ai)\n                      then []\n                      else [H.TyList ()\n                              (H.TyTuple () H.Boxed\n                                [ haskellStringType\n                                , haskellStringType\n                                ])])\n                  ++ [H.TyApp () m\n                        (H.TyApp ()\n                          (H.TyApp ()\n                            (H.TyCon () $ H.UnQual () (H.Ident () "ApiResponse"))\n                            (responseHaskellType errorI))\n                          (responseHaskellType output))]\n           qualIdent :: N.Name -> N.Type\n           qualIdent = \\case\n             (H.Ident _ s)\n               | s == cleanHsName res -> H.TyCon () $ H.UnQual () tyIdent\n               | otherwise            -> H.TyCon () $ H.Qual () (H.ModuleName () $ modName s) tyIdent\n             H.Symbol{}               -> error "Rest.Gen.Haskell.mkFunction.qualIdent - not expecting a Symbol"\n           inp :: [N.Type]\n           inp | Just i <- mInp\n               , i\' <- inputHaskellType i = [i\']\n               | otherwise = []\n       input :: N.Name\n       input = H.Ident () "input"\n       pList :: N.Name\n       pList = H.Ident () "pList"\n       rhs :: N.Rhs\n       rhs = H.UnGuardedRhs () $ H.Let () binds expr\n         where\n           binds :: N.Binds\n           binds = H.BDecls () [rHeadersBind, requestBind]\n           rHeadersBind :: N.Decl\n           rHeadersBind =\n             H.PatBind () (H.PVar () rHeaders)\n               (H.UnGuardedRhs () $\n                 H.List ()\n                   [ H.Tuple () H.Boxed\n                     [ use hAccept\n                     , stringLit $ dataTypesToAcceptHeader JSON $ responseAcceptType responseType\n                     ]\n                   , H.Tuple () H.Boxed\n                     [ use hContentType\n                     , stringLit $ maybe "text/plain" inputContentType mInp\n                     ]])\n               noBinds\n\n           rHeaders     :: N.Name\n           rHeaders     = H.Ident () "rHeaders"\n           hAccept      :: N.Name\n           hAccept      = H.Ident () "hAccept"\n           hContentType :: N.Name\n           hContentType = H.Ident () "hContentType"\n           doRequest    :: N.Name\n           doRequest    = H.Ident () "doRequest"\n\n           requestBind :: N.Decl\n           requestBind =\n             H.PatBind () (H.PVar () request)\n                (H.UnGuardedRhs () $\n                  appLast\n                    (H.App ()\n                      (H.App ()\n                        (H.App ()\n                          (H.App () (H.App () (use makeReq) (stringLit str)) (stringLit ve))\n                          url)\n                        (if null (params ai) then H.List () [] else use pList))\n                      (use rHeaders))) noBinds\n             where\n               str = show $ method ai\n           appLast :: N.Exp -> N.Exp\n           appLast e\n             | Just i <- mInp = H.App () e (H.App () (use $ H.Ident () $ inputFunc i) (use input))\n             | otherwise = H.App () e (stringLit "")\n           makeReq :: N.Name\n           makeReq = H.Ident () "makeReq"\n           request :: N.Name\n           request = H.Ident () "request"\n\n           expr :: N.Exp\n           expr = H.App () (H.App () (H.App () (use doRequest)\n                                      (use . H.Ident () $ responseFunc errorI))\n                                      (use . H.Ident () $ responseFunc output))\n                                      (use request)\n\n       ve :: String\n       url :: N.Exp\n       (ve, url) = ("v" ++ show ver, lUrl)\n       errorI :: ResponseInfo\n       errorI = errorInfo responseType\n       output :: ResponseInfo\n       output = outputInfo responseType\n       responseType :: ResponseType\n       responseType = chooseResponseType ai\n\nlinkToURL :: String -> Link -> (N.Exp, [N.Name])\nlinkToURL res lnk = first (H.List ()) $ urlParts res lnk ([], [])\n\nurlParts :: String -> Link -> ([N.Exp], [N.Name]) -> ([N.Exp], [N.Name])\nurlParts res lnk ac@(rlnk, pars) =\n  case lnk of\n    [] -> ac\n    (LResource r : a@(LAccess _) : xs)\n      | not (hasParam a) -> urlParts res xs (rlnk ++ [H.List () [stringLit r]], pars)\n      | otherwise -> urlParts res xs (rlnk\', pars ++ [H.Ident () . cleanHsName $ r])\n           where\n             rlnk\' = rlnk ++ (H.List () [stringLit r] : tailed)\n             tailed = [H.App () (useMQual qual $ H.Ident () "readId")\n                             (use . hsName $ cleanName r)]\n               where\n                 qual :: Maybe N.ModuleName\n                 qual | r == res  = Nothing\n                      | otherwise = Just . H.ModuleName () $ modName r\n    (LParam p : xs) -> urlParts res xs (rlnk ++ [H.List () [H.App () (use $ H.Ident () "showUrl")\n                                                          (use $ hsName (cleanName p))]], pars)\n    (i : xs) -> urlParts res xs (rlnk ++ [H.List () [stringLit $ itemString i]], pars)\n\nidData :: ApiResource -> [N.Decl]\nidData node =\n  case resAccessors node of\n    [] -> []\n    [(_pth, Nothing)] -> []\n    [(pth, Just i)] ->\n      let pp xs | null pth = xs\n                | otherwise = stringLit pth : xs\n      in [ H.TypeDecl () (H.DHead () tyIdent) (Ident.haskellType i),\n           H.TypeSig () [funName] fType,\n           H.FunBind () [ H.Match () funName [H.PVar () x]\n                            (H.UnGuardedRhs () $ H.List () $ pp [showURLx])\n                            noBinds\n                        ]\n         ]\n    ls ->\n      let ctor :: (String, Maybe Ident) -> N.QualConDecl\n          ctor (pth,mi) =\n            H.QualConDecl () Nothing Nothing (H.ConDecl () (H.Ident () (dataName pth)) $ maybe [] f mi)\n              where\n                f ty = [Ident.haskellType ty]\n          fun :: (String, Maybe Ident) -> [N.Decl]\n          fun (pth, mi) = [H.FunBind () [H.Match () funName fparams rhs noBinds]]\n            where\n              (fparams, rhs) =\n                case mi of\n                  Nothing ->\n                    ( [H.PVar () . H.Ident () $ dataName pth]\n                    , H.UnGuardedRhs () $ H.List () [stringLit pth]\n                    )\n                  Just{}  ->  -- Pattern match with data constructor\n                    ([H.PParen () $ H.PApp () (H.UnQual () $ H.Ident () (dataName pth)) [H.PVar () x]],\n                     H.UnGuardedRhs () $ H.List () [stringLit pth, showURLx])\n      in [ H.DataDecl () (H.DataType ()) Nothing (H.DHead () tyIdent) (map ctor ls) []\n         , H.TypeSig () [funName] fType\n         ] ++ concatMap fun ls\n    where\n      x        :: N.Name\n      x        = H.Ident () "x"\n      fType    :: N.Type\n      fType    = H.TyFun () (H.TyCon () $ H.UnQual () tyIdent) (H.TyList () haskellStringType)\n      funName  :: N.Name\n      funName  = H.Ident () "readId"\n      showURLx :: N.Exp\n      showURLx = H.App () (H.Var () $ H.UnQual () $ H.Ident () "showUrl") (H.Var () $ H.UnQual () x)\n\ntyIdent :: N.Name\ntyIdent = H.Ident () "Identifier"\n\nmkHsName :: ActionInfo -> N.Name\nmkHsName ai = hsName $ concatMap cleanName parts\n  where\n      parts = case actionType ai of\n        Retrieve   -> case nm of\n          [] -> ["access"]\n          _  -> nm\n          where\n            nm = get ++ by ++ target\n        Create     -> ["create"] ++ by ++ target\n        -- Should be delete, but delete is a JS keyword and causes problems in collect.\n        Delete     -> ["remove"] ++ by ++ target\n        DeleteMany -> ["removeMany"] ++ by ++ target\n        List       -> ["list"] ++ by ++ target\n        Update     -> ["save"] ++ by ++ target\n        UpdateMany -> ["saveMany"] ++ by ++ target\n        Modify   -> if resDir ai == "" then ["do"] else [resDir ai]\n\n      target = if resDir ai == "" then maybe [] ((:[]) . description) (ident ai) else [resDir ai]\n      by     = ["by" | target /= [] && (isJust (ident ai) || actionType ai == UpdateMany)]\n      get    = ["get" | not (isAccessor ai)]\n\nhsName :: [String] -> N.Name\nhsName []       = H.Ident () ""\nhsName (x : xs) = H.Ident () $ cleanHsName $ downFirst x ++ concatMap upFirst xs\n\ncleanHsName :: String -> String\ncleanHsName s =\n  if s `elem` reservedNames\n    then s ++ "_"\n    else intercalate "" . cleanName $ s\n  where\n    reservedNames =\n      ["as","case","class","data","instance","default","deriving","do"\n      ,"foreign","if","then","else","import","infix","infixl","infixr","let"\n      ,"in","module","newtype","of","qualified","type","where"]\n\nqualModName :: ResourceId -> String\nqualModName = intercalate "." . map modName\n\nmodPath :: ResourceId -> String\nmodPath = intercalate "/" . map modName\n\ndataName :: String -> String\ndataName = modName\n\nmodName :: String -> String\nmodName = concatMap upFirst . cleanName\n\ndata InputInfo = InputInfo\n  { inputModules     :: [N.ModuleName]\n  , inputHaskellType :: N.Type\n  , inputContentType :: String\n  , inputFunc        :: String\n  } deriving (Eq, Show)\n\ninputInfo :: DataDesc -> InputInfo\ninputInfo dsc =\n  case L.get dataType dsc of\n    String -> InputInfo [] haskellStringType "text/plain" "toLbs"\n    XML    -> InputInfo (L.get haskellModules dsc) (L.get haskellType dsc) "text/xml" "toXML"\n    JSON   -> InputInfo (L.get haskellModules dsc) (L.get haskellType dsc) "text/json" "toJSON"\n    File   -> InputInfo [] haskellByteStringType "application/octet-stream" "id"\n    Other  -> InputInfo [] haskellByteStringType "text/plain" "id"\n\ndata ResponseInfo = ResponseInfo\n  { responseModules     :: [N.ModuleName]\n  , responseHaskellType :: N.Type\n  , responseFunc        :: String\n  } deriving (Eq, Show)\n\noutputInfo :: ResponseType -> ResponseInfo\noutputInfo r =\n  case outputType r of\n    Nothing -> ResponseInfo [] haskellUnitType "(const ())"\n    Just t -> case L.get dataType t of\n      String -> ResponseInfo [] haskellStringType "toString"\n      XML    -> ResponseInfo (L.get haskellModules t) (L.get haskellType t) "fromXML"\n      JSON   -> ResponseInfo (L.get haskellModules t) (L.get haskellType t) "fromJSON"\n      File   -> ResponseInfo [] haskellByteStringType "id"\n      Other  -> ResponseInfo [] haskellByteStringType "id"\n\nerrorInfo :: ResponseType -> ResponseInfo\nerrorInfo r =\n  case errorType r of\n    -- Rest only has XML and JSON instances for errors, so we need to\n    -- include at least one of these in the accept header. We don\'t\n    -- want to make assumptions about the response type if there is no\n    -- accept header so in that case we force it to be JSON.\n    Nothing -> fromJustNote ("rest-gen bug: toResponseInfo\' was called with a data type other than XML or JSON, responseType: " ++ show r)\n             . toResponseInfo\' . defaultErrorDataDesc . maybe JSON (\\x -> case x of { XML -> XML; _ -> JSON })\n             . fmap (L.get dataType) . outputType\n             $ r\n    Just t -> toResponseInfo [t]\n  where\n    toResponseInfo :: [DataDesc] -> ResponseInfo\n    toResponseInfo xs\n      = fromMaybe (error $ "Unsupported error formats: " ++ show xs ++ ", this is a bug in rest-gen.")\n      . headMay\n      . mapMaybe toResponseInfo\'\n      $ xs\n    toResponseInfo\' :: DataDesc -> Maybe ResponseInfo\n    toResponseInfo\' t = case L.get dataType t of\n      XML  -> Just $ ResponseInfo (L.get haskellModules t) (L.get haskellType t) "fromXML"\n      JSON -> Just $ ResponseInfo (L.get haskellModules t) (L.get haskellType t) "fromJSON"\n      _    -> Nothing\n\ndefaultErrorDataDesc :: DataType -> DataDesc\ndefaultErrorDataDesc dt =\n  DataDesc\n    { _dataType       = dt\n    , _haskellType    = haskellVoidType\n    , _haskellModules = [ModuleName () "Rest.Types.Void"]\n    }\n\nstringLit :: String -> N.Exp\nstringLit s = H.Lit () $ H.String () s s\n'