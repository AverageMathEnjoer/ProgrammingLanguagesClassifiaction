b'module Main where\n\nimport Prelude hiding (Nothing, Left, Right)\nimport Control.Concurrent\nimport System.IO.Unsafe\nimport UI.HSCurses.Curses\n\ngameWidth = 40\ngameHeight = 10\npaddleHeight = 4\n\n\n\n{-\n---------------------- Data --------------------\n-}\n\n-- The input at any moment in time can be either nothing,\n-- a direction in which to move the paddle, or a request\n-- to quit the game.\ndata Input = Nothing | Movement Direction | Quit\ndata Direction = Up | Down\n\n-- The game state consists of a ball and two paddles.\ndata GameState = Game Ball Paddle Paddle | Ended\ndata Paddle = Left Int | Right Int\n-- A ball has four properties: x, y, xspeed and yspeed.\ndata Ball = Ball Int Int Int Int\n\n\n\n{-\n---------------------- Game engine --------------------\n-}\n\n\n-- This checks for game loss, collision with walls and\n-- paddles, and otherwise just advances the ball\n-- according to its speed.\nstepBall :: GameState -> GameState\nstepBall (Game ball left right)\n  | x <= 0 || x >= gameWidth                  = Ended\n  | y == 1                                    = stepBall (Game (Ball x (y+1) xs (-ys)) left right)\n  | y == gameHeight                           = stepBall (Game (Ball x (y-1) xs (-ys)) left right)\n  | x == lx && y `elem` [ly..ly+paddleHeight] = stepBall (Game (Ball (x+1) y (-xs) ys) left right)\n  | x == rx && y `elem` [ry..ry+paddleHeight] = stepBall (Game (Ball (x-1) y (-xs) ys) left right)\n  | otherwise                                 = Game (Ball (x+xs) (y+ys) xs ys) left right\n  where\n    (Ball x y xs ys) = ball\n    lx        = 3+1\n    (Left ly) = left\n    rx         = gameWidth - 3 - 1\n    (Right ry) = right\n\n-- This checks which way the ball is moving and\n-- imitates that at limited speed\nstepAI :: GameState -> GameState\nstepAI (Game ball (Left ly) right) =\n  Game ball (Left $ constrain (ly + signum ys) 1 (gameHeight-paddleHeight)) right\n  where\n    (Ball _ _ _ ys) = ball\n    constrain v a b\n      | v < a     = a\n      | v > b     = b\n      | otherwise = v\n\n\n-- Depending on what direction, move the paddles and\n-- make sure they do not exit the court.\nmovePaddle :: Direction -> GameState -> GameState\nmovePaddle Up   (Game ball left (Right ry)) = Game ball left (Right $ max 1 (ry - 1))\nmovePaddle Down (Game ball left (Right ry)) = Game ball left (Right $ min (gameHeight-paddleHeight) (ry + 1))\n\n-- Transform the state according to a single input.\ntransformSingle :: Input -> GameState -> GameState\ntransformSingle Nothing state = state\ntransformSingle (Movement Up) state = movePaddle Up state\ntransformSingle (Movement Down) state = movePaddle Down state\ntransformSingle Quit _ = Ended\n\n-- Given an initial state and a list of inputs, return\n-- a list of all the intermediate states until the game\n-- ends when the state is transformed with the inputs.\n-- Note that there is no base case for an empty input\n-- list, because the input list should be considered\n-- "infinitely long" as long as the game is running.\ntransform :: [Input] -> GameState -> [GameState]\ntransform (i:input) state =\n  state : (case transformSingle i state of\n             Ended    -> [Ended]\n             newState -> transform input $ stepGame newState)\n  where\n    stepGame = stepBall . stepAI\n\n\n\n\n\n\n{-\n---------------------- Input/Output --------------------\n-}\n\n\n-- Given a (curses) window to draw on and a list of\n-- game states, draw each state successively. Here,\n-- too, the list of game states should be considered\n-- infinite. When the game ends, it should end with\n-- one of the game-ending game states, not abruptly\n-- with the end of the list.\ndraw :: Window -> [GameState] -> IO ()\ndraw w (Ended:_) = return ()\ndraw w ((Game (Ball x y _ _) (Left ly) (Right ry)):states) = do\n  wclear w\n\n  mvWAddStr w 0 0 $ replicate gameWidth \'-\'\n  mvWAddStr w (gameHeight+1) 0 $ replicate gameWidth \'-\'\n  mvWAddStr w y x "o"\n  drawPaddle 3 ly\n  drawPaddle (gameWidth-3) ry\n\n  refresh\n  threadDelay 100000\n  draw w states\n\n  where\n    drawPaddle x yoffset =\n      mapM_ (\\i -> mvWAddStr w i x "|") [yoffset..yoffset+paddleHeight]\n\n\n-- Get an infinite sequence of keys from curses.\ngetKeys :: IO [Key]\ngetKeys = unsafeInterleaveIO $ do\n  a <- fmap decodeKey getch\n  as <- getKeys\n  return $ a : as\n\n\n\n\n{-\n---------------------- Glue --------------------\n-}\n\n\nmain = do\n  -- Set a few options for curses\n  initCurses\n  w <- initScr\n  raw True\n  noDelay w True\n  echo False\n\n  -- Transform the infinite list of keys into an\n  -- infinite list of inputs that makes sense for\n  -- the game engine.\n  inputs <- fmap (map toInternalInput) getKeys\n\n  -- Record the game history (all the intermediary\n  -- states) by transforming the initial state with\n  -- the inputs.\n  let centerx = gameWidth `div` 2\n      centery = gameHeight `div` 2\n      gameHistory = transform inputs $ Game (Ball centerx centery 1 1)\n                                            (Left $ centery - paddleHeight `div` 2)\n                                            (Right $ centery - paddleHeight `div` 2)\n\n  -- Draw the entire history!\n  draw w gameHistory\n\n  -- Be nice and tell the user that there\'s no\n  -- more game to be played\n  wclear w\n  mvWAddStr w 3 3 "Game Over! Press q to exit"\n  waitForOkay\n\n  -- Reset the terminal and quit curses\n  endWin\n\n  where\n    toInternalInput :: Key -> Input\n    toInternalInput (KeyChar \'u\') = Movement Up\n    toInternalInput (KeyChar \'e\') = Movement Down\n    toInternalInput (KeyChar \'q\') = Quit\n    toInternalInput _ = Nothing\n\n    waitForOkay :: IO ()\n    waitForOkay = do\n      c <- fmap decodeKey getch\n      case c of\n        (KeyChar \'q\') -> return ()\n        _             -> waitForOkay\n\n\n'