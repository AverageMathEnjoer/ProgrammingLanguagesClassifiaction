b'{-# LANGUAGE CPP #-}\n{-# LANGUAGE BangPatterns #-}\n#if __GLASGOW_HASKELL__\n{-# LANGUAGE RankNTypes #-}\n{-# LANGUAGE DeriveDataTypeable #-}\n{-# LANGUAGE DeriveGeneric #-}\n{-# LANGUAGE DeriveLift #-}\n{-# LANGUAGE StandaloneDeriving #-}\n#  if __GLASGOW_HASKELL__ >= 802\n{-# LANGUAGE Safe #-}\n#  else\n{-# LANGUAGE Trustworthy #-}\n#  endif\n#endif\n\n#include "containers.h"\n\n-----------------------------------------------------------------------------\n-- |\n-- Module      :  Data.Graph\n-- Copyright   :  (c) The University of Glasgow 2002\n-- License     :  BSD-style (see the file libraries/base/LICENSE)\n--\n-- Maintainer  :  libraries@haskell.org\n-- Portability :  portable\n--\n-- = Finite Graphs\n--\n-- The @\'Graph\'@ type is an adjacency list representation of a finite, directed\n-- graph with vertices of type @Int@.\n--\n-- The @\'SCC\'@ type represents a\n-- <https://en.wikipedia.org/wiki/Strongly_connected_component strongly-connected component>\n-- of a graph.\n--\n-- == Implementation\n--\n-- The implementation is based on\n--\n--   * /Structuring Depth-First Search Algorithms in Haskell/,\n--     by David King and John Launchbury, <http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.52.6526>\n--\n-----------------------------------------------------------------------------\n\nmodule Data.Graph (\n\n    -- * Graphs\n      Graph\n    , Bounds\n    , Edge\n    , Vertex\n    , Table\n\n    -- ** Graph Construction\n    , graphFromEdges\n    , graphFromEdges\'\n    , buildG\n\n    -- ** Graph Properties\n    , vertices\n    , edges\n    , outdegree\n    , indegree\n\n    -- ** Graph Transformations\n    , transposeG\n\n    -- ** Graph Algorithms\n    , dfs\n    , dff\n    , topSort\n    , reverseTopSort\n    , components\n    , scc\n    , bcc\n    , reachable\n    , path\n\n\n    -- * Strongly Connected Components\n    , SCC(..)\n\n    -- ** Construction\n    , stronglyConnComp\n    , stronglyConnCompR\n\n    -- ** Conversion\n    , flattenSCC\n    , flattenSCCs\n\n    -- * Trees\n    , module Data.Tree\n\n    ) where\n\nimport Utils.Containers.Internal.Prelude\nimport Prelude ()\n#if USE_ST_MONAD\nimport Control.Monad.ST\nimport Data.Array.ST.Safe (newArray, readArray, writeArray)\n# if USE_UNBOXED_ARRAYS\nimport Data.Array.ST.Safe (STUArray)\n# else\nimport Data.Array.ST.Safe (STArray)\n# endif\n#else\nimport Data.IntSet (IntSet)\nimport qualified Data.IntSet as Set\n#endif\nimport Data.Tree (Tree(Node), Forest)\n\n-- std interfaces\nimport Data.Foldable as F\nimport Control.DeepSeq (NFData(rnf))\nimport Data.Maybe\nimport Data.Array\n#if USE_UNBOXED_ARRAYS\nimport qualified Data.Array.Unboxed as UA\nimport Data.Array.Unboxed ( UArray )\n#else\nimport qualified Data.Array as UA\n#endif\nimport qualified Data.List as L\nimport Data.Functor.Classes\n#if !MIN_VERSION_base(4,11,0)\nimport Data.Semigroup (Semigroup (..))\n#endif\n#ifdef __GLASGOW_HASKELL__\nimport GHC.Generics (Generic, Generic1)\nimport Data.Data (Data)\nimport Language.Haskell.TH.Syntax (Lift)\n-- See Note [ Template Haskell Dependencies ]\nimport Language.Haskell.TH ()\n#endif\n\n-- Make sure we don\'t use Integer by mistake.\ndefault ()\n\n-------------------------------------------------------------------------\n--                                                                      -\n--      Strongly Connected Components\n--                                                                      -\n-------------------------------------------------------------------------\n\n-- | Strongly connected component.\ndata SCC vertex = AcyclicSCC vertex     -- ^ A single vertex that is not\n                                        -- in any cycle.\n                | CyclicSCC  [vertex]   -- ^ A maximal set of mutually\n                                        -- reachable vertices.\n#if __GLASGOW_HASKELL__ >= 802\n  deriving ( Eq   -- ^ @since 0.5.9\n           , Show -- ^ @since 0.5.9\n           , Read -- ^ @since 0.5.9\n           )\n#else\n  deriving (Eq, Show, Read)\n#endif\n\n#ifdef __GLASGOW_HASKELL__\n-- | @since 0.5.9\nderiving instance Data vertex => Data (SCC vertex)\n\n-- | @since 0.5.9\nderiving instance Generic1 SCC\n\n-- | @since 0.5.9\nderiving instance Generic (SCC vertex)\n\n-- | @since 0.6.6\nderiving instance Lift vertex => Lift (SCC vertex)\n#endif\n\n-- | @since 0.5.9\ninstance Eq1 SCC where\n  liftEq eq (AcyclicSCC v1) (AcyclicSCC v2) = eq v1 v2\n  liftEq eq (CyclicSCC vs1) (CyclicSCC vs2) = liftEq eq vs1 vs2\n  liftEq _ _ _ = False\n-- | @since 0.5.9\ninstance Show1 SCC where\n  liftShowsPrec sp _sl d (AcyclicSCC v) = showsUnaryWith sp "AcyclicSCC" d v\n  liftShowsPrec _sp sl d (CyclicSCC vs) = showsUnaryWith (const sl) "CyclicSCC" d vs\n-- | @since 0.5.9\ninstance Read1 SCC where\n  liftReadsPrec rp rl = readsData $\n    readsUnaryWith rp "AcyclicSCC" AcyclicSCC <>\n    readsUnaryWith (const rl) "CyclicSCC" CyclicSCC\n\n-- | @since 0.5.9\ninstance F.Foldable SCC where\n  foldr c n (AcyclicSCC v) = c v n\n  foldr c n (CyclicSCC vs) = foldr c n vs\n\n-- | @since 0.5.9\ninstance Traversable SCC where\n  -- We treat the non-empty cyclic case specially to cut one\n  -- fmap application.\n  traverse f (AcyclicSCC vertex) = AcyclicSCC <$> f vertex\n  traverse _f (CyclicSCC []) = pure (CyclicSCC [])\n  traverse f (CyclicSCC (x : xs)) =\n    liftA2 (\\x\' xs\' -> CyclicSCC (x\' : xs\')) (f x) (traverse f xs)\n\ninstance NFData a => NFData (SCC a) where\n    rnf (AcyclicSCC v) = rnf v\n    rnf (CyclicSCC vs) = rnf vs\n\n-- | @since 0.5.4\ninstance Functor SCC where\n    fmap f (AcyclicSCC v) = AcyclicSCC (f v)\n    fmap f (CyclicSCC vs) = CyclicSCC (fmap f vs)\n\n-- | The vertices of a list of strongly connected components.\nflattenSCCs :: [SCC a] -> [a]\nflattenSCCs = concatMap flattenSCC\n\n-- | The vertices of a strongly connected component.\nflattenSCC :: SCC vertex -> [vertex]\nflattenSCC (AcyclicSCC v) = [v]\nflattenSCC (CyclicSCC vs) = vs\n\n-- | \\(O((V+E) \\log V)\\). The strongly connected components of a directed graph,\n-- reverse topologically sorted.\n--\n-- ==== __Examples__\n--\n-- > stronglyConnComp [("a",0,[1]),("b",1,[2,3]),("c",2,[1]),("d",3,[3])]\n-- >   == [CyclicSCC ["d"],CyclicSCC ["b","c"],AcyclicSCC "a"]\nstronglyConnComp\n        :: Ord key\n        => [(node, key, [key])]\n                -- ^ The graph: a list of nodes uniquely identified by keys,\n                -- with a list of keys of nodes this node has edges to.\n                -- The out-list may contain keys that don\'t correspond to\n                -- nodes of the graph; such edges are ignored.\n        -> [SCC node]\n\nstronglyConnComp edges0\n  = map get_node (stronglyConnCompR edges0)\n  where\n    get_node (AcyclicSCC (n, _, _)) = AcyclicSCC n\n    get_node (CyclicSCC triples)     = CyclicSCC [n | (n,_,_) <- triples]\n{-# INLINABLE stronglyConnComp #-}\n\n-- | \\(O((V+E) \\log V)\\). The strongly connected components of a directed graph,\n-- reverse topologically sorted.  The function is the same as\n-- \'stronglyConnComp\', except that all the information about each node retained.\n-- This interface is used when you expect to apply \'SCC\' to\n-- (some of) the result of \'SCC\', so you don\'t want to lose the\n-- dependency information.\n--\n-- ==== __Examples__\n--\n-- > stronglyConnCompR [("a",0,[1]),("b",1,[2,3]),("c",2,[1]),("d",3,[3])]\n-- >  == [CyclicSCC [("d",3,[3])],CyclicSCC [("b",1,[2,3]),("c",2,[1])],AcyclicSCC ("a",0,[1])]\nstronglyConnCompR\n        :: Ord key\n        => [(node, key, [key])]\n                -- ^ The graph: a list of nodes uniquely identified by keys,\n                -- with a list of keys of nodes this node has edges to.\n                -- The out-list may contain keys that don\'t correspond to\n                -- nodes of the graph; such edges are ignored.\n        -> [SCC (node, key, [key])]     -- ^ Reverse topologically sorted\n\nstronglyConnCompR [] = []  -- added to avoid creating empty array in graphFromEdges -- SOF\nstronglyConnCompR edges0\n  = map decode forest\n  where\n    (graph, vertex_fn,_) = graphFromEdges edges0\n    forest             = scc graph\n    decode (Node v []) | mentions_itself v = CyclicSCC [vertex_fn v]\n                       | otherwise         = AcyclicSCC (vertex_fn v)\n    decode other = CyclicSCC (dec other [])\n                 where\n                   dec (Node v ts) vs = vertex_fn v : foldr dec vs ts\n    mentions_itself v = v `elem` (graph ! v)\n{-# INLINABLE stronglyConnCompR #-}\n\n-------------------------------------------------------------------------\n--                                                                      -\n--      Graphs\n--                                                                      -\n-------------------------------------------------------------------------\n\n-- | Abstract representation of vertices.\ntype Vertex  = Int\n-- | Table indexed by a contiguous set of vertices.\n--\n-- /Note: This is included for backwards compatibility./\ntype Table a = Array Vertex a\n-- | Adjacency list representation of a graph, mapping each vertex to its\n-- list of successors.\ntype Graph   = Array Vertex [Vertex]\n-- | The bounds of an @Array@.\ntype Bounds  = (Vertex, Vertex)\n-- | An edge from the first vertex to the second.\ntype Edge    = (Vertex, Vertex)\n\n#if !USE_UNBOXED_ARRAYS\ntype UArray i a = Array i a\n#endif\n\n-- | \\(O(V)\\). Returns the list of vertices in the graph.\n--\n-- ==== __Examples__\n--\n-- > vertices (buildG (0,-1) []) == []\n--\n-- > vertices (buildG (0,2) [(0,1),(1,2)]) == [0,1,2]\nvertices :: Graph -> [Vertex]\nvertices  = indices\n-- See Note [Inline for fusion]\n{-# INLINE vertices #-}\n\n-- | \\(O(V+E)\\). Returns the list of edges in the graph.\n--\n-- ==== __Examples__\n--\n-- > edges (buildG (0,-1) []) == []\n--\n-- > edges (buildG (0,2) [(0,1),(1,2)]) == [(0,1),(1,2)]\nedges    :: Graph -> [Edge]\nedges g   = [ (v, w) | v <- vertices g, w <- g!v ]\n-- See Note [Inline for fusion]\n{-# INLINE edges #-}\n\n-- | \\(O(V+E)\\). Build a graph from a list of edges.\n--\n-- Warning: This function will cause a runtime exception if a vertex in the edge\n-- list is not within the given @Bounds@.\n--\n-- ==== __Examples__\n--\n-- > buildG (0,-1) [] == array (0,-1) []\n-- > buildG (0,2) [(0,1), (1,2)] == array (0,1) [(0,[1]),(1,[2])]\n-- > buildG (0,2) [(0,1), (0,2), (1,2)] == array (0,2) [(0,[2,1]),(1,[2]),(2,[])]\nbuildG :: Bounds -> [Edge] -> Graph\nbuildG = accumArray (flip (:)) []\n-- See Note [Inline for fusion]\n{-# INLINE buildG #-}\n\n-- | \\(O(V+E)\\). The graph obtained by reversing all edges.\n--\n-- ==== __Examples__\n--\n-- > transposeG (buildG (0,2) [(0,1), (1,2)]) == array (0,2) [(0,[]),(1,[0]),(2,[1])]\ntransposeG  :: Graph -> Graph\ntransposeG g = buildG (bounds g) (reverseE g)\n\nreverseE    :: Graph -> [Edge]\nreverseE g   = [ (w, v) | (v, w) <- edges g ]\n-- See Note [Inline for fusion]\n{-# INLINE reverseE #-}\n\n-- | \\(O(V+E)\\). A table of the count of edges from each node.\n--\n-- ==== __Examples__\n--\n-- > outdegree (buildG (0,-1) []) == array (0,-1) []\n--\n-- > outdegree (buildG (0,2) [(0,1), (1,2)]) == array (0,2) [(0,1),(1,1),(2,0)]\noutdegree :: Graph -> Array Vertex Int\n-- This is bizarrely lazy. We build an array filled with thunks, instead\n-- of actually calculating anything. This is the historical behavior, and I\n-- suppose someone *could* be relying on it, but it might be worth finding\n-- out. Note that we *can\'t* be so lazy with indegree.\noutdegree  = fmap length\n\n-- | \\(O(V+E)\\). A table of the count of edges into each node.\n--\n-- ==== __Examples__\n--\n-- > indegree (buildG (0,-1) []) == array (0,-1) []\n--\n-- > indegree (buildG (0,2) [(0,1), (1,2)]) == array (0,2) [(0,0),(1,1),(2,1)]\nindegree :: Graph -> Array Vertex Int\nindegree g = accumArray (+) 0 (bounds g) [(v, 1) | (_, outs) <- assocs g, v <- outs]\n\n-- | \\(O((V+E) \\log V)\\). Identical to \'graphFromEdges\', except that the return\n-- value does not include the function which maps keys to vertices. This\n-- version of \'graphFromEdges\' is for backwards compatibility.\ngraphFromEdges\'\n        :: Ord key\n        => [(node, key, [key])]\n        -> (Graph, Vertex -> (node, key, [key]))\ngraphFromEdges\' x = (a,b) where\n    (a,b,_) = graphFromEdges x\n{-# INLINABLE graphFromEdges\' #-}\n\n-- | \\(O((V+E) \\log V)\\). Build a graph from a list of nodes uniquely identified\n-- by keys, with a list of keys of nodes this node should have edges to.\n--\n-- This function takes an adjacency list representing a graph with vertices of\n-- type @key@ labeled by values of type @node@ and produces a @Graph@-based\n-- representation of that list. The @Graph@ result represents the /shape/ of the\n-- graph, and the functions describe a) how to retrieve the label and adjacent\n-- vertices of a given vertex, and b) how to retrieve a vertex given a key.\n--\n-- @(graph, nodeFromVertex, vertexFromKey) = graphFromEdges edgeList@\n--\n-- * @graph :: Graph@ is the raw, array based adjacency list for the graph.\n-- * @nodeFromVertex :: Vertex -> (node, key, [key])@ returns the node\n--   associated with the given 0-based @Int@ vertex; see /warning/ below. This\n--   runs in \\(O(1)\\) time.\n-- * @vertexFromKey :: key -> Maybe Vertex@ returns the @Int@ vertex for the\n--   key if it exists in the graph, @Nothing@ otherwise. This runs in\n--   \\(O(\\log V)\\) time.\n--\n-- To safely use this API you must either extract the list of vertices directly\n-- from the graph or first call @vertexFromKey k@ to check if a vertex\n-- corresponds to the key @k@. Once it is known that a vertex exists you can use\n-- @nodeFromVertex@ to access the labelled node and adjacent vertices. See below\n-- for examples.\n--\n-- Note: The out-list may contain keys that don\'t correspond to nodes of the\n-- graph; they are ignored.\n--\n-- Warning: The @nodeFromVertex@ function will cause a runtime exception if the\n-- given @Vertex@ does not exist.\n--\n-- ==== __Examples__\n--\n-- An empty graph.\n--\n-- > (graph, nodeFromVertex, vertexFromKey) = graphFromEdges []\n-- > graph = array (0,-1) []\n--\n-- A graph where the out-list references unspecified nodes (@\\\'c\\\'@), these are\n-- ignored.\n--\n-- > (graph, _, _) = graphFromEdges [("a", \'a\', [\'b\']), ("b", \'b\', [\'c\'])]\n-- > array (0,1) [(0,[1]),(1,[])]\n--\n--\n-- A graph with 3 vertices: ("a") -> ("b") -> ("c")\n--\n-- > (graph, nodeFromVertex, vertexFromKey) = graphFromEdges [("a", \'a\', [\'b\']), ("b", \'b\', [\'c\']), ("c", \'c\', [])]\n-- > graph == array (0,2) [(0,[1]),(1,[2]),(2,[])]\n-- > nodeFromVertex 0 == ("a",\'a\',"b")\n-- > vertexFromKey \'a\' == Just 0\n--\n-- Get the label for a given key.\n--\n-- > let getNodePart (n, _, _) = n\n-- > (graph, nodeFromVertex, vertexFromKey) = graphFromEdges [("a", \'a\', [\'b\']), ("b", \'b\', [\'c\']), ("c", \'c\', [])]\n-- > getNodePart . nodeFromVertex <$> vertexFromKey \'a\' == Just "A"\n--\ngraphFromEdges\n        :: Ord key\n        => [(node, key, [key])]\n        -> (Graph, Vertex -> (node, key, [key]), key -> Maybe Vertex)\ngraphFromEdges edges0\n  = (graph, \\v -> vertex_map ! v, key_vertex)\n  where\n    max_v           = length edges0 - 1\n    bounds0         = (0,max_v) :: (Vertex, Vertex)\n    sorted_edges    = L.sortBy lt edges0\n    edges1          = zipWith (,) [0..] sorted_edges\n\n    graph           = array bounds0 [(,) v (mapMaybe key_vertex ks) | (,) v (_,    _, ks) <- edges1]\n    key_map         = array bounds0 [(,) v k                       | (,) v (_,    k, _ ) <- edges1]\n    vertex_map      = array bounds0 edges1\n\n    (_,k1,_) `lt` (_,k2,_) = k1 `compare` k2\n\n    -- key_vertex :: key -> Maybe Vertex\n    --  returns Nothing for non-interesting vertices\n    key_vertex k   = findVertex 0 max_v\n                   where\n                     findVertex a b | a > b\n                              = Nothing\n                     findVertex a b = case compare k (key_map ! mid) of\n                                   LT -> findVertex a (mid-1)\n                                   EQ -> Just mid\n                                   GT -> findVertex (mid+1) b\n                              where\n                                mid = a + (b - a) `div` 2\n{-# INLINABLE graphFromEdges #-}\n\n-------------------------------------------------------------------------\n--                                                                      -\n--      Depth first search\n--                                                                      -\n-------------------------------------------------------------------------\n\n-- | \\(O(V+E)\\). A spanning forest of the graph, obtained from a depth-first\n-- search of the graph starting from each vertex in an unspecified order.\ndff          :: Graph -> [Tree Vertex]\ndff g         = dfs g (vertices g)\n\n-- | \\(O(V+E)\\). A spanning forest of the part of the graph reachable from the\n-- listed vertices, obtained from a depth-first search of the graph starting at\n-- each of the listed vertices in order.\n\n-- This function deviates from King and Launchbury\'s implementation by\n-- bundling together the functions generate, prune, and chop for efficiency\n-- reasons.\ndfs :: Graph -> [Vertex] -> [Tree Vertex]\ndfs g vs0 = run (bounds g) $ go vs0\n  where\n    go :: [Vertex] -> SetM s [Tree Vertex]\n    go [] = pure []\n    go (v:vs) = do\n      visited <- contains v\n      if visited\n      then go vs\n      else do\n        include v\n        as <- go (g!v)\n        bs <- go vs\n        pure $ Node v as : bs\n\n-- A monad holding a set of vertices visited so far.\n#if USE_ST_MONAD\n\n-- Use the ST monad if available, for constant-time primitives.\n\n#if USE_UNBOXED_ARRAYS\nnewtype SetM s a = SetM { runSetM :: STUArray s Vertex Bool -> ST s a }\n#else\nnewtype SetM s a = SetM { runSetM :: STArray  s Vertex Bool -> ST s a }\n#endif\n\ninstance Monad (SetM s) where\n    return = pure\n    {-# INLINE return #-}\n    SetM v >>= f = SetM $ \\s -> do { x <- v s; runSetM (f x) s }\n    {-# INLINE (>>=) #-}\n\ninstance Functor (SetM s) where\n    f `fmap` SetM v = SetM $ \\s -> f `fmap` v s\n    {-# INLINE fmap #-}\n\ninstance Applicative (SetM s) where\n    pure x = SetM $ const (return x)\n    {-# INLINE pure #-}\n    SetM f <*> SetM v = SetM $ \\s -> f s >>= (`fmap` v s)\n    -- We could also use the following definition\n    --   SetM f <*> SetM v = SetM $ \\s -> f s <*> v s\n    -- but Applicative (ST s) instance is present only in GHC 7.2+\n    {-# INLINE (<*>) #-}\n\nrun          :: Bounds -> (forall s. SetM s a) -> a\nrun bnds act  = runST (newArray bnds False >>= runSetM act)\n\ncontains     :: Vertex -> SetM s Bool\ncontains v    = SetM $ \\ m -> readArray m v\n\ninclude      :: Vertex -> SetM s ()\ninclude v     = SetM $ \\ m -> writeArray m v True\n\n#else /* !USE_ST_MONAD */\n\n-- Portable implementation using IntSet.\n\nnewtype SetM s a = SetM { runSetM :: IntSet -> (a, IntSet) }\n\ninstance Monad (SetM s) where\n    return x     = SetM $ \\s -> (x, s)\n    SetM v >>= f = SetM $ \\s -> case v s of (x, s\') -> runSetM (f x) s\'\n\ninstance Functor (SetM s) where\n    f `fmap` SetM v = SetM $ \\s -> case v s of (x, s\') -> (f x, s\')\n    {-# INLINE fmap #-}\n\ninstance Applicative (SetM s) where\n    pure x = SetM $ \\s -> (x, s)\n    {-# INLINE pure #-}\n    SetM f <*> SetM v = SetM $ \\s -> case f s of (k, s\') -> case v s\' of (x, s\'\') -> (k x, s\'\')\n    {-# INLINE (<*>) #-}\n\nrun          :: Bounds -> SetM s a -> a\nrun _ act     = fst (runSetM act Set.empty)\n\ncontains     :: Vertex -> SetM s Bool\ncontains v    = SetM $ \\ m -> (Set.member v m, m)\n\ninclude      :: Vertex -> SetM s ()\ninclude v     = SetM $ \\ m -> ((), Set.insert v m)\n\n#endif /* !USE_ST_MONAD */\n\n-------------------------------------------------------------------------\n--                                                                      -\n--      Algorithms\n--                                                                      -\n-------------------------------------------------------------------------\n\n------------------------------------------------------------\n-- Algorithm 1: depth first search numbering\n------------------------------------------------------------\n\npreorder\' :: Tree a -> [a] -> [a]\npreorder\' (Node a ts) = (a :) . preorderF\' ts\n\npreorderF\' :: [Tree a] -> [a] -> [a]\npreorderF\' ts = foldr (.) id $ map preorder\' ts\n\npreorderF :: [Tree a] -> [a]\npreorderF ts = preorderF\' ts []\n\ntabulate        :: Bounds -> [Vertex] -> UArray Vertex Int\ntabulate bnds vs = UA.array bnds (zipWith (flip (,)) [1..] vs)\n-- Why zipWith (flip (,)) instead of just using zip with the\n-- arguments in the other order? We want the [1..] to fuse\n-- away, and these days that only happens when it\'s the first\n-- list argument.\n\npreArr          :: Bounds -> [Tree Vertex] -> UArray Vertex Int\npreArr bnds      = tabulate bnds . preorderF\n\n------------------------------------------------------------\n-- Algorithm 2: topological sorting\n------------------------------------------------------------\n\npostorder :: Tree a -> [a] -> [a]\npostorder (Node a ts) = postorderF ts . (a :)\n\npostorderF   :: [Tree a] -> [a] -> [a]\npostorderF ts = foldr (.) id $ map postorder ts\n\npostOrd :: Graph -> [Vertex]\npostOrd g = postorderF (dff g) []\n\n-- | \\(O(V+E)\\). A topological sort of the graph.\n-- The order is partially specified by the condition that a vertex /i/\n-- precedes /j/ whenever /j/ is reachable from /i/ but not vice versa.\n--\n-- Note: A topological sort exists only when there are no cycles in the graph.\n-- If the graph has cycles, the output of this function will not be a\n-- topological sort. In such a case consider using \'scc\'.\ntopSort      :: Graph -> [Vertex]\ntopSort       = reverse . postOrd\n\n-- | \\(O(V+E)\\). Reverse ordering of `topSort`.\n--\n-- See note in \'topSort\'.\n--\n-- @since 0.6.4\nreverseTopSort :: Graph -> [Vertex]\nreverseTopSort = postOrd\n\n------------------------------------------------------------\n-- Algorithm 3: connected components\n------------------------------------------------------------\n\n-- | \\(O(V+E)\\). The connected components of a graph.\n-- Two vertices are connected if there is a path between them, traversing\n-- edges in either direction.\ncomponents   :: Graph -> [Tree Vertex]\ncomponents    = dff . undirected\n\nundirected   :: Graph -> Graph\nundirected g  = buildG (bounds g) (edges g ++ reverseE g)\n\n-- Algorithm 4: strongly connected components\n\n-- | \\(O(V+E)\\). The strongly connected components of a graph, in reverse\n-- topological order.\n--\n-- ==== __Examples__\n--\n-- > scc (buildG (0,3) [(3,1),(1,2),(2,0),(0,1)])\n-- >   == [Node {rootLabel = 0, subForest = [Node {rootLabel = 1, subForest = [Node {rootLabel = 2, subForest = []}]}]}\n-- >      ,Node {rootLabel = 3, subForest = []}]\n\nscc  :: Graph -> [Tree Vertex]\nscc g = dfs g (reverse (postOrd (transposeG g)))\n\n------------------------------------------------------------\n-- Algorithm 5: Classifying edges\n------------------------------------------------------------\n\n{-\nXXX unused code\n\ntree              :: Bounds -> Forest Vertex -> Graph\ntree bnds ts       = buildG bnds (concat (map flat ts))\n where flat (Node v ts\') = [ (v, w) | Node w _us <- ts\' ]\n                        ++ concat (map flat ts\')\n\nback              :: Graph -> Table Int -> Graph\nback g post        = mapT select g\n where select v ws = [ w | w <- ws, post!v < post!w ]\n\ncross             :: Graph -> Table Int -> Table Int -> Graph\ncross g pre post   = mapT select g\n where select v ws = [ w | w <- ws, post!v > post!w, pre!v > pre!w ]\n\nforward           :: Graph -> Graph -> Table Int -> Graph\nforward g tree\' pre = mapT select g\n where select v ws = [ w | w <- ws, pre!v < pre!w ] \\\\ tree\' ! v\n\nmapT    :: (Vertex -> a -> b) -> Array Vertex a -> Array Vertex b\nmapT f t = array (bounds t) [ (,) v (f v (t!v)) | v <- indices t ]\n-}\n\n------------------------------------------------------------\n-- Algorithm 6: Finding reachable vertices\n------------------------------------------------------------\n\n-- | \\(O(V+E)\\). Returns the list of vertices reachable from a given vertex.\n--\n-- ==== __Examples__\n--\n-- > reachable (buildG (0,0) []) 0 == [0]\n--\n-- > reachable (buildG (0,2) [(0,1), (1,2)]) 0 == [0,1,2]\nreachable :: Graph -> Vertex -> [Vertex]\nreachable g v = preorderF (dfs g [v])\n\n-- | \\(O(V+E)\\). Returns @True@ if the second vertex reachable from the first.\n--\n-- ==== __Examples__\n--\n-- > path (buildG (0,0) []) 0 0 == True\n--\n-- > path (buildG (0,2) [(0,1), (1,2)]) 0 2 == True\n--\n-- > path (buildG (0,2) [(0,1), (1,2)]) 2 0 == False\npath :: Graph -> Vertex -> Vertex -> Bool\npath g v w    = w `elem` (reachable g v)\n\n------------------------------------------------------------\n-- Algorithm 7: Biconnected components\n------------------------------------------------------------\n\n-- | \\(O(V+E)\\). The biconnected components of a graph.\n-- An undirected graph is biconnected if the deletion of any vertex\n-- leaves it connected.\n--\n-- The input graph is expected to be undirected, i.e. for every edge in the\n-- graph the reverse edge is also in the graph. If the graph is not undirected\n-- the output is arbitrary.\nbcc :: Graph -> [Tree [Vertex]]\nbcc g = concatMap bicomps forest\n  where\n    -- The algorithm here is the same as given by King and Launchbury, which is\n    -- an adaptation of Hopcroft and Tarjan\'s. The implementation, however, has\n    -- been modified from King and Launchbury to make it efficient.\n\n    forest = dff g\n\n    -- dnum!v is the index of vertex v in the dfs preorder of vertices\n    dnum = preArr (bounds g) forest\n\n    -- Wraps up the component of every child of the root\n    bicomps :: Tree Vertex -> [Tree [Vertex]]\n    bicomps (Node v tws) =\n      [Node (v : curw []) (donew []) | (_, curw, donew) <- map collect tws]\n\n    -- Returns a triple of\n    -- * lowpoint of v\n    -- * difference list of vertices in v\'s component\n    -- * difference list of trees of components, whose root components are\n    --   adjacent to v\'s component\n    collect :: Tree Vertex\n            -> (Int, [Vertex] -> [Vertex], [Tree [Vertex]] -> [Tree [Vertex]])\n    collect (Node v tws) = (lowv, (v:) . curv, donev)\n      where\n        dv = dnum UA.! v\n        accf (lowv\', curv\', donev\') tw\n          | loww < dv  -- w\'s component extends through v\n            = (lowv\'\', curv\' . curw, donev\' . donew)\n          | otherwise  -- w\'s component ends with v as an articulation point\n            = (lowv\'\', curv\', donev\' . (Node (v : curw []) (donew []) :))\n          where\n            (loww, curw, donew) = collect tw\n            !lowv\'\' = min lowv\' loww\n        !lowv0 = F.foldl\' min dv [dnum UA.! w | w <- g!v]\n        !(lowv, curv, donev) = F.foldl\' accf (lowv0, id, id) tws\n\n--------------------------------------------------------------------------------\n\n-- Note [Inline for fusion]\n-- ~~~~~~~~~~~~~~~~~~~~~~~~\n--\n-- We inline simple functions that produce or consume lists so that list fusion\n-- can fire. transposeG is a function where this is particularly useful; it has\n-- two intermediate lists in its definition which get fused away.\n'