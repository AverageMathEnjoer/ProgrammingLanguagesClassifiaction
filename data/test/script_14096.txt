b'{-# LANGUAGE Arrows #-}\n\nimport Control.Monad\nimport Data.MonadicStreamFunction\nimport Control.Monad.Trans.Class\nimport Control.Monad.Trans.Writer.Strict\nimport Control.Monad.Trans.Reader\n\ntype DTime = Double\n\ntype SF m a b = MSF (ReaderT DTime m) a b\n\nlocalTime :: Monad m => SF m a DTime\nlocalTime = MSF $ \\a -> do\n  dt <- ask\n  return (dt, localTime >>> arr (+dt))\n\n\ntype AssertionId     = String\ntype DebuggingMonadT = WriterT [ (String, DTime) ]\n\nassert :: Monad m => String -> SF (DebuggingMonadT m) Bool ()\nassert assertionId = proc (val) -> do\n    t <- localTime                    -< ()\n    _ <- withSideEffect optionallyLog -< (t, val)\n    returnA -< ()\n  where\n    optionallyLog (t1, v1) = when v1 (lift $ tell [(assertionId, t1)])\n\nballAboveFloorM :: Monad m => SF (DebuggingMonadT m) () Double\nballAboveFloorM = proc () -> do\n  ballPos <- bouncingBall -< ()\n  () <- assert "Ball must always be above the floor" -<(ballPos >= 0)\n  returnA -< ballPos\n\nbouncingBall = undefined\n'