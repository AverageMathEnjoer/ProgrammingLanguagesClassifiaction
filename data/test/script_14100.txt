b'{- HLINT ignore -}\n{-# LANGUAGE DeriveDataTypeable #-}\n\nmodule Main where\n\n{-\nimport Control.Monad (filterM)\nimport Data.Maybe (isNothing, mapMaybe)\nimport qualified Graphics.UI.Gtk as Gtk (initGUI)\n--\nimport Hoodle.Publish.PDF\n  ( createPdf,\n    isHdl,\n    isPdf,\n    isUpdated,\n    takeFile,\n  )\nimport System.Console.CmdArgs\n  ( Data,\n    Typeable,\n    argPos,\n    cmdArgs,\n    def,\n    modes,\n    typ,\n    (&=),\n  )\nimport System.Directory (removeFile)\nimport System.Directory.Tree (AnchoredDirTree (..), build, flattenDir)\nimport System.FilePath (makeRelative, replaceExtension, (</>))\n\n--\n\ndata HoodlePublish = Publish\n  { urlbase :: String,\n    rootpath :: FilePath,\n    buildpath :: FilePath,\n    specialurlbase :: String\n  }\n  deriving (Show, Data, Typeable)\n\npublish :: HoodlePublish\npublish =\n  Publish\n    { urlbase = def &= typ "URLBASE" &= argPos 0,\n      rootpath = def &= typ "ORIGNALFILEDIR" &= argPos 1,\n      buildpath = def &= typ "TARGETFILEDIR" &= argPos 2,\n      specialurlbase = def &= typ "SPECIALURLBASE"\n    }\n\nmode :: HoodlePublish\nmode = modes [publish]\n\n-- |\nmain :: IO ()\nmain = do\n  _ <- Gtk.initGUI\n  params <- cmdArgs mode\n  (_r :/ r\') <- build (rootpath params)\n  let files = mapMaybe takeFile . flattenDir $ r\'\n      hdlfiles = filter isHdl files\n      pairs =\n        map\n          ( (,) <$> id\n              <*> (buildpath params </>) . flip replaceExtension "pdf" . makeRelative (rootpath params)\n          )\n          hdlfiles\n      swappedpairs = map (\\(x, y) -> (y, x)) pairs\n  (_b :/ b\') <- build (buildpath params)\n  let files2 = mapMaybe takeFile . flattenDir $ b\'\n      pdffiles = filter isPdf files2\n      willbeerased = filter (\\x -> isNothing (lookup x swappedpairs)) pdffiles\n  mapM_ removeFile willbeerased\n  updatedpairs <- filterM isUpdated pairs\n  mapM_ (createPdf (urlbase params, specialurlbase params) (rootpath params)) updatedpairs\n-}\n\nmain :: IO ()\nmain = pure ()\n'