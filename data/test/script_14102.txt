b'{-# LANGUAGE OverloadedStrings #-}\n\nmodule Hoodle.Type.HoodleState\n  ( HoodleState,\n    HoodleModeState (..),\n    UnitHoodle,\n    IsOneTimeSelectMode (..),\n    Settings,\n    UIComponentSignalHandler,\n    FileStore (..),\n    -- | labels\n    unitKey,\n    unitUUID,\n    unitButton,\n    hoodleModeState,\n    hoodleFileControl,\n    cvsInfoMap,\n    currentCanvas,\n    isOneTimeSelectMode,\n    frameState,\n    rootWindow,\n    unitHoodles,\n    rootNotebook,\n    rootContainer,\n    rootOfRootWindow,\n    currentPenDraw,\n    callBack,\n    deviceList,\n    penInfo,\n    cursorInfo,\n    selectInfo,\n    gtkUIManager,\n    isSaved,\n    undoTable,\n    backgroundStyle,\n    isFullScreen,\n    settings,\n    uiComponentSignalHandler,\n    lastTimeCanvasConfigure,\n    hookSet,\n    tempLog,\n    tempQueue,\n    statusBar,\n    renderCacheVar,\n    pdfRenderQueue,\n    genRenderQueue,\n    doesNotInvalidate,\n    nextPdfBkgPageNum,\n    --\n    hoodleFileName,\n    lastSavedTime,\n    syncMD5History,\n    --\n    doesUseXInput,\n    doesUseTouch,\n    doesUsePopUpMenu,\n    doesEmbedImage,\n    doesEmbedPDF,\n    doesFollowLinks,\n    doesKeepAspectRatio,\n    doesUseVariableCursor,\n    newPageMode,\n    networkEditSourceInfo,\n    --\n    penModeSignal,\n    pageModeSignal,\n    penPointSignal,\n    penColorSignal,\n    newPageModeSignal,\n    switchTabSignal,\n    -- | others\n    emptyUnitHoodle,\n    emptyHoodleState,\n    defaultSettings,\n    defaultUIComponentSignalHandler,\n    getHoodle,\n    -- | additional lenses\n    --  , getCanvasInfoMap\n    setCanvasInfoMap,\n    getCurrentCanvasId,\n    setCurrentCanvasId,\n    currentCanvasInfo,\n    resetHoodleModeStateBuffers,\n    getCanvasInfo,\n    setCanvasInfo,\n    updateFromCanvasInfoAsCurrentCanvas,\n    setCanvasId,\n    modifyCanvasInfo,\n    hoodleModeStateEither,\n    getCurrentPageFromHoodleModeState,\n    getCurrentPageDimFromHoodleModeState,\n    -- | for debug\n    -- , showCanvasInfoMapViewPortBBox\n    -- , getTheUnit\n    -- , putTheUnit\n    currentUnit,\n  )\nwhere\n\nimport Control.Concurrent (ThreadId)\nimport Control.Concurrent.STM (TVar, newTVarIO)\nimport Control.Lens (Lens\', lens, set, view, (^.))\nimport Control.Monad.Trans.Crtn.Event (ActionOrder)\nimport Control.Monad.Trans.Crtn.Queue\n  ( Queue,\n    emptyQueue,\n  )\nimport Data.Functor.Identity (Identity (..))\nimport qualified Data.HashMap.Strict as HM\nimport Data.Hoodle.Generic\n  ( emptyGHoodle,\n    gdimension,\n    gpages,\n  )\nimport Data.Hoodle.Select\n  ( gSelect2GHoodle,\n    gselAll,\n  )\nimport qualified Data.IntMap as M\nimport Data.Maybe (fromMaybe)\nimport Data.Sequence (empty)\nimport qualified Data.Text as T\nimport Data.Time.Clock (UTCTime)\nimport Data.UUID (UUID)\nimport Graphics.Hoodle.Render (updateHoodleBuf)\nimport Graphics.Hoodle.Render.Type\n  ( GenCommandQueue,\n    HHoodle,\n    PDFCommandQueue,\n    RHoodle,\n    RenderCache,\n    Renderer,\n  )\nimport qualified Graphics.UI.Gtk as Gtk hiding (Clipboard, get, set)\nimport Hoodle.Device (DeviceList)\nimport Hoodle.Script.Hook (Hook)\nimport Hoodle.Type.Alias\n  ( EditMode,\n    Hoodle,\n    Page,\n    SelectMode,\n  )\nimport Hoodle.Type.Canvas\n  ( CanvasId,\n    CanvasInfo,\n    CanvasInfoBox,\n    CanvasInfoMap,\n    PenDraw,\n    PenInfo,\n    canvasId,\n    currPen,\n    currentPageNum,\n    defaultPenInfo,\n    emptyPenDraw,\n    forBoth,\n    penColor,\n    penSet,\n    penWidth,\n    unboxBiXform,\n    unboxLens,\n  )\nimport Hoodle.Type.Enum\n  ( BackgroundStyle (BkgStyleLined),\n    NewPageModeType (NPPlain),\n    PenColor,\n    SelectInfo (..),\n    SelectType (SelectLassoWork),\n  )\nimport Hoodle.Type.Event (AllEvent)\nimport Hoodle.Type.PageArrangement (PageDimension (..))\nimport Hoodle.Type.Undo (UndoTable, emptyUndo)\nimport Hoodle.Type.Window (WindowConfig)\nimport Hoodle.Util (fromJustError, maybeError\')\n\n-- |\ndata HoodleModeState\n  = ViewAppendState {unView :: RHoodle}\n  | SelectState {tempSelect :: HHoodle}\n\n-- |\ndata IsOneTimeSelectMode\n  = NoOneTimeSelectMode\n  | YesBeforeSelect\n  | YesAfterSelect\n  deriving (Show, Eq, Ord)\n\ndata UnitHoodle = UnitHoodle\n  { _unitKey :: Int,\n    _unitUUID :: UUID,\n    _unitButton :: Gtk.Button,\n    _hoodleModeState :: HoodleModeState,\n    _hoodleFileControl :: HoodleFileControl,\n    _cvsInfoMap :: CanvasInfoMap,\n    _currentCanvas :: (CanvasId, CanvasInfoBox),\n    _frameState :: WindowConfig,\n    _rootWindow :: Gtk.Widget,\n    _rootContainer :: Gtk.Box,\n    _isSaved :: Bool,\n    _undoTable :: UndoTable HoodleModeState,\n    _isOneTimeSelectMode :: IsOneTimeSelectMode\n  }\n\ndata HoodleState = HoodleState\n  { _unitHoodles :: (Int, M.IntMap UnitHoodle),\n    _rootNotebook :: Gtk.Notebook,\n    _rootOfRootWindow :: Gtk.Window,\n    _currentPenDraw :: PenDraw,\n    _callBack :: AllEvent -> IO (),\n    _deviceList :: DeviceList,\n    _penInfo :: PenInfo,\n    -- | (pen color, pen width, use variable cursor)\n    _cursorInfo :: (PenColor, Double, Bool),\n    _selectInfo :: SelectInfo,\n    _gtkUIManager :: Gtk.UIManager,\n    _isFullScreen :: Bool,\n    _settings :: Settings,\n    _backgroundStyle :: BackgroundStyle,\n    _uiComponentSignalHandler :: UIComponentSignalHandler,\n    _lastTimeCanvasConfigure :: Maybe UTCTime,\n    _hookSet :: Maybe Hook,\n    _tempQueue :: Queue (Either (ActionOrder AllEvent) AllEvent),\n    _tempLog :: String -> String,\n    _statusBar :: Maybe Gtk.Statusbar,\n    _renderCacheVar :: TVar RenderCache,\n    _pdfRenderQueue :: PDFCommandQueue,\n    _genRenderQueue :: GenCommandQueue,\n    _doesNotInvalidate :: Bool,\n    _nextPdfBkgPageNum :: Maybe Int\n  }\n\n-- | current unit\ncurrentUnit :: Lens\' (Int, M.IntMap UnitHoodle) UnitHoodle\ncurrentUnit = lens (\\(k, m) -> fromJustError "currentUnit" (M.lookup k m)) (\\(_, m) a -> (_unitKey a, M.insert (_unitKey a) a m))\n\n-- | lens for unitKey\nunitKey :: Lens\' UnitHoodle Int\nunitKey = lens _unitKey (\\f a -> f {_unitKey = a})\n\n-- | lens for unitKey\nunitUUID :: Lens\' UnitHoodle UUID\nunitUUID = lens _unitUUID (\\f a -> f {_unitUUID = a})\n\n-- | lens for unitKey\nunitButton :: Lens\' UnitHoodle Gtk.Button\nunitButton = lens _unitButton (\\f a -> f {_unitButton = a})\n\n-- | lens for hoodleModeState\nhoodleModeState :: Lens\' UnitHoodle HoodleModeState\nhoodleModeState = lens _hoodleModeState (\\f a -> f {_hoodleModeState = a})\n\n-- |\nhoodleFileControl :: Lens\' UnitHoodle HoodleFileControl\nhoodleFileControl = lens _hoodleFileControl (\\f a -> f {_hoodleFileControl = a})\n\n-- | lens for cvsInfoMap\ncvsInfoMap :: Lens\' UnitHoodle CanvasInfoMap\ncvsInfoMap = lens _cvsInfoMap (\\f a -> f {_cvsInfoMap = a})\n\n-- | lens for currentCanvas\ncurrentCanvas :: Lens\' UnitHoodle (CanvasId, CanvasInfoBox)\ncurrentCanvas = lens _currentCanvas (\\f a -> f {_currentCanvas = a})\n\n-- | lens for frameState\nframeState :: Lens\' UnitHoodle WindowConfig\nframeState = lens _frameState (\\f a -> f {_frameState = a})\n\n-- | lens for rootWindow\nrootWindow :: Lens\' UnitHoodle Gtk.Widget\nrootWindow = lens _rootWindow (\\f a -> f {_rootWindow = a})\n\n-- | lens for rootContainer\nrootContainer :: Lens\' UnitHoodle Gtk.Box\nrootContainer = lens _rootContainer (\\f a -> f {_rootContainer = a})\n\n-- | lens for isSaved\nisSaved :: Lens\' UnitHoodle Bool\nisSaved = lens _isSaved (\\f a -> f {_isSaved = a})\n\n-- | lens for undoTable\nundoTable :: Lens\' UnitHoodle (UndoTable HoodleModeState)\nundoTable = lens _undoTable (\\f a -> f {_undoTable = a})\n\n-- | lens for isOneTimeSelectMode\nisOneTimeSelectMode :: Lens\' UnitHoodle IsOneTimeSelectMode\nisOneTimeSelectMode = lens _isOneTimeSelectMode (\\f a -> f {_isOneTimeSelectMode = a})\n\n-- | lens for unitHoodles\nunitHoodles :: Lens\' HoodleState (Int, M.IntMap UnitHoodle)\nunitHoodles = lens _unitHoodles (\\f a -> f {_unitHoodles = a})\n\n-- | lens for rootWindow\nrootNotebook :: Lens\' HoodleState Gtk.Notebook\nrootNotebook = lens _rootNotebook (\\f a -> f {_rootNotebook = a})\n\n-- | lens for rootOfRootWindow\nrootOfRootWindow :: Lens\' HoodleState Gtk.Window\nrootOfRootWindow = lens _rootOfRootWindow (\\f a -> f {_rootOfRootWindow = a})\n\n-- | lens for currentPenDraw\ncurrentPenDraw :: Lens\' HoodleState PenDraw\ncurrentPenDraw = lens _currentPenDraw (\\f a -> f {_currentPenDraw = a})\n\n-- | lens for callBack\ncallBack :: Lens\' HoodleState (AllEvent -> IO ())\ncallBack = lens _callBack (\\f a -> f {_callBack = a})\n\n-- | lens for deviceList\ndeviceList :: Lens\' HoodleState DeviceList\ndeviceList = lens _deviceList (\\f a -> f {_deviceList = a})\n\n-- | lens for penInfo\npenInfo :: Lens\' HoodleState PenInfo\npenInfo = lens _penInfo (\\f a -> f {_penInfo = a})\n\n-- | lens for cursorInfo\ncursorInfo :: Lens\' HoodleState (PenColor, Double, Bool)\ncursorInfo = lens _cursorInfo (\\f a -> f {_cursorInfo = a})\n\n-- | lens for selectInfo\nselectInfo :: Lens\' HoodleState SelectInfo\nselectInfo = lens _selectInfo (\\f a -> f {_selectInfo = a})\n\n-- | lens for gtkUIManager\ngtkUIManager :: Lens\' HoodleState Gtk.UIManager\ngtkUIManager = lens _gtkUIManager (\\f a -> f {_gtkUIManager = a})\n\n-- | background style = plain, lined, ruled, graph\nbackgroundStyle :: Lens\' HoodleState BackgroundStyle\nbackgroundStyle = lens _backgroundStyle (\\f a -> f {_backgroundStyle = a})\n\n-- | lens for isFullScreen\nisFullScreen :: Lens\' HoodleState Bool\nisFullScreen = lens _isFullScreen (\\f a -> f {_isFullScreen = a})\n\n-- |\nsettings :: Lens\' HoodleState Settings\nsettings = lens _settings (\\f a -> f {_settings = a})\n\n-- |\nuiComponentSignalHandler :: Lens\' HoodleState UIComponentSignalHandler\nuiComponentSignalHandler = lens _uiComponentSignalHandler (\\f a -> f {_uiComponentSignalHandler = a})\n\n-- | lens for lastTimeCanvasConfigure\nlastTimeCanvasConfigure :: Lens\' HoodleState (Maybe UTCTime)\nlastTimeCanvasConfigure = lens _lastTimeCanvasConfigure (\\f a -> f {_lastTimeCanvasConfigure = a})\n\n-- | lens for hookSet\nhookSet :: Lens\' HoodleState (Maybe Hook)\nhookSet = lens _hookSet (\\f a -> f {_hookSet = a})\n\n-- | lens for tempQueue\ntempQueue :: Lens\' HoodleState (Queue (Either (ActionOrder AllEvent) AllEvent))\ntempQueue = lens _tempQueue (\\f a -> f {_tempQueue = a})\n\n-- | lens for tempLog\ntempLog :: Lens\' HoodleState (String -> String)\ntempLog = lens _tempLog (\\f a -> f {_tempLog = a})\n\n-- |\nstatusBar :: Lens\' HoodleState (Maybe Gtk.Statusbar)\nstatusBar = lens _statusBar (\\f a -> f {_statusBar = a})\n\n-- |\nrenderCacheVar :: Lens\' HoodleState (TVar RenderCache)\nrenderCacheVar = lens _renderCacheVar (\\f a -> f {_renderCacheVar = a})\n\n-- |\npdfRenderQueue :: Lens\' HoodleState PDFCommandQueue\npdfRenderQueue = lens _pdfRenderQueue (\\f a -> f {_pdfRenderQueue = a})\n\n-- |\ngenRenderQueue :: Lens\' HoodleState GenCommandQueue\ngenRenderQueue = lens _genRenderQueue (\\f a -> f {_genRenderQueue = a})\n\n-- |\ndoesNotInvalidate :: Lens\' HoodleState Bool\ndoesNotInvalidate = lens _doesNotInvalidate (\\f a -> f {_doesNotInvalidate = a})\n\n-- |\nnextPdfBkgPageNum :: Lens\' HoodleState (Maybe Int)\nnextPdfBkgPageNum = lens _nextPdfBkgPageNum (\\f a -> f {_nextPdfBkgPageNum = a})\n\n{-\n-- |\ncursorInfo :: Lens\' HoodleState (Maybe Cursor)\ncursorInfo = lens _cursorInfo (\\f a -> f { _cursorInfo = a })\n-}\n\ndata FileStore\n  = LocalDir (Maybe FilePath)\n  | TempDir FilePath\n\n-- |\ndata HoodleFileControl = HoodleFileControl\n  { _hoodleFileName :: FileStore, -- Maybe FilePath\n    _lastSavedTime :: Maybe UTCTime,\n    _syncMD5History :: [T.Text]\n  }\n\n-- | lens for currFileName\nhoodleFileName :: Lens\' HoodleFileControl FileStore -- (Maybe FilePath)\nhoodleFileName = lens _hoodleFileName (\\f a -> f {_hoodleFileName = a})\n\n-- | lens for last saved time\nlastSavedTime :: Lens\' HoodleFileControl (Maybe UTCTime)\nlastSavedTime = lens _lastSavedTime (\\f a -> f {_lastSavedTime = a})\n\n-- | lens for last saved time\nsyncMD5History :: Lens\' HoodleFileControl [T.Text]\nsyncMD5History = lens _syncMD5History (\\f a -> f {_syncMD5History = a})\n\n-- |\ndata UIComponentSignalHandler = UIComponentSignalHandler\n  { _penModeSignal :: Maybe (Gtk.ConnectId Gtk.RadioAction),\n    _pageModeSignal :: Maybe (Gtk.ConnectId Gtk.RadioAction),\n    _penPointSignal :: Maybe (Gtk.ConnectId Gtk.RadioAction),\n    _penColorSignal :: Maybe (Gtk.ConnectId Gtk.RadioAction),\n    _newPageModeSignal :: Maybe (Gtk.ConnectId Gtk.RadioAction),\n    _switchTabSignal :: Maybe (Gtk.ConnectId Gtk.Notebook)\n  }\n\n-- | lens for penModeSignal\npenModeSignal :: Lens\' UIComponentSignalHandler (Maybe (Gtk.ConnectId Gtk.RadioAction))\npenModeSignal = lens _penModeSignal (\\f a -> f {_penModeSignal = a})\n\n-- | lens for pageModeSignal\npageModeSignal :: Lens\' UIComponentSignalHandler (Maybe (Gtk.ConnectId Gtk.RadioAction))\npageModeSignal = lens _pageModeSignal (\\f a -> f {_pageModeSignal = a})\n\n-- | lens for penPointSignal\npenPointSignal :: Lens\' UIComponentSignalHandler (Maybe (Gtk.ConnectId Gtk.RadioAction))\npenPointSignal = lens _penPointSignal (\\f a -> f {_penPointSignal = a})\n\n-- | lens for penColorSignal\npenColorSignal :: Lens\' UIComponentSignalHandler (Maybe (Gtk.ConnectId Gtk.RadioAction))\npenColorSignal = lens _penColorSignal (\\f a -> f {_penColorSignal = a})\n\n-- | lens for newPageModeSignal\nnewPageModeSignal :: Lens\' UIComponentSignalHandler (Maybe (Gtk.ConnectId Gtk.RadioAction))\nnewPageModeSignal = lens _newPageModeSignal (\\f a -> f {_newPageModeSignal = a})\n\n-- | lens for switchTabSignal\nswitchTabSignal :: Lens\' UIComponentSignalHandler (Maybe (Gtk.ConnectId Gtk.Notebook))\nswitchTabSignal = lens _switchTabSignal (\\f a -> f {_switchTabSignal = a})\n\n-- | A set of Hoodle settings\ndata Settings = Settings\n  { _doesUseXInput :: Bool,\n    _doesUseTouch :: Bool,\n    _doesUsePopUpMenu :: Bool,\n    _doesEmbedImage :: Bool,\n    _doesEmbedPDF :: Bool,\n    _doesFollowLinks :: Bool,\n    _doesKeepAspectRatio :: Bool,\n    _doesUseVariableCursor :: Bool,\n    _newPageMode :: NewPageModeType,\n    _networkEditSourceInfo :: Maybe ThreadId\n  }\n\n-- | flag for XInput extension (needed for using full power of wacom)\ndoesUseXInput :: Lens\' Settings Bool\ndoesUseXInput = lens _doesUseXInput (\\f a -> f {_doesUseXInput = a})\n\n-- | flag for touch\ndoesUseTouch :: Lens\' Settings Bool\ndoesUseTouch = lens _doesUseTouch (\\f a -> f {_doesUseTouch = a})\n\n-- | flag for using popup menu\ndoesUsePopUpMenu :: Lens\' Settings Bool\ndoesUsePopUpMenu = lens _doesUsePopUpMenu (\\f a -> f {_doesUsePopUpMenu = a})\n\n-- | flag for embedding image as base64 in hdl file\ndoesEmbedImage :: Lens\' Settings Bool\ndoesEmbedImage = lens _doesEmbedImage (\\f a -> f {_doesEmbedImage = a})\n\n-- | flag for embedding pdf background as base64 in hdl file\ndoesEmbedPDF :: Lens\' Settings Bool\ndoesEmbedPDF = lens _doesEmbedPDF (\\f a -> f {_doesEmbedPDF = a})\n\n-- | flag for embedding pdf background as base64 in hdl file\ndoesFollowLinks :: Lens\' Settings Bool\ndoesFollowLinks = lens _doesFollowLinks (\\f a -> f {_doesFollowLinks = a})\n\n-- | flag for keeping aspect ratio\ndoesKeepAspectRatio :: Lens\' Settings Bool\ndoesKeepAspectRatio = lens _doesKeepAspectRatio (\\f a -> f {_doesKeepAspectRatio = a})\n\n-- | flag for variable cursor\ndoesUseVariableCursor :: Lens\' Settings Bool\ndoesUseVariableCursor = lens _doesUseVariableCursor (\\f a -> f {_doesUseVariableCursor = a})\n\n-- | new page mode: plain | last | cycle\nnewPageMode :: Lens\' Settings NewPageModeType\nnewPageMode = lens _newPageMode (\\f a -> f {_newPageMode = a})\n\n-- | network edit source mode\nnetworkEditSourceInfo :: Lens\' Settings (Maybe ThreadId)\nnetworkEditSourceInfo = lens _networkEditSourceInfo (\\f a -> f {_networkEditSourceInfo = a})\n\n-- |\nemptyUnitHoodle :: IO UnitHoodle\nemptyUnitHoodle = do\n  hdl <- emptyGHoodle\n  return $\n    UnitHoodle\n      { _unitKey = 0,\n        _unitUUID = error "unitUUID",\n        _unitButton = error "unitButton",\n        _hoodleModeState = ViewAppendState hdl,\n        _hoodleFileControl = emptyHoodleFileControl,\n        _cvsInfoMap = error "emptyHoodleState.cvsInfoMap",\n        _currentCanvas = error "emtpyHoodleState.currentCanvas",\n        _frameState = error "emptyHoodleState.frameState",\n        _rootWindow = error "emtpyHoodleState.rootWindow",\n        _rootContainer = error "emptyHoodleState.rootContainer",\n        _isSaved = False,\n        _undoTable = emptyUndo 1,\n        _isOneTimeSelectMode = NoOneTimeSelectMode\n      }\n\n-- | default hoodle state\nemptyHoodleState :: IO HoodleState\nemptyHoodleState = do\n  unit <- emptyUnitHoodle\n  tvarpdf <- newTVarIO empty\n  tvargen <- newTVarIO empty\n  tvarcache <- newTVarIO HM.empty\n  return $\n    HoodleState\n      { _unitHoodles = (0, M.singleton 0 unit),\n        _rootNotebook = error "emtpyHoodleState.rootNotebook",\n        _rootOfRootWindow = error "emptyHoodleState.rootOfRootWindow",\n        _currentPenDraw = emptyPenDraw,\n        _callBack = error "emtpyHoodleState.callBack",\n        _deviceList = error "emtpyHoodleState.deviceList",\n        _penInfo = defaultPenInfo,\n        _cursorInfo = (defaultPenInfo ^. penSet . currPen . penColor, defaultPenInfo ^. penSet . currPen . penWidth, False),\n        _selectInfo = SelectInfo SelectLassoWork,\n        _gtkUIManager = error "emptyHoodleState.gtkUIManager",\n        -- , _isEventBlocked = False\n        _backgroundStyle = BkgStyleLined,\n        _isFullScreen = False,\n        _settings = defaultSettings,\n        _uiComponentSignalHandler = defaultUIComponentSignalHandler,\n        -- , _pageModeSignal = Nothing\n        -- , _penModeSignal = Nothing\n        _lastTimeCanvasConfigure = Nothing,\n        _hookSet = Nothing,\n        _tempQueue = emptyQueue,\n        _tempLog = id,\n        _statusBar = Nothing,\n        _renderCacheVar = tvarcache, -- HM.empty\n        _pdfRenderQueue = tvarpdf,\n        _genRenderQueue = tvargen,\n        _doesNotInvalidate = False,\n        _nextPdfBkgPageNum = Nothing\n        -- , _cursorInfo = Nothing\n      }\n\nemptyHoodleFileControl :: HoodleFileControl\nemptyHoodleFileControl =\n  HoodleFileControl\n    { _hoodleFileName = LocalDir Nothing,\n      _lastSavedTime = Nothing,\n      _syncMD5History = []\n    }\n\ndefaultUIComponentSignalHandler :: UIComponentSignalHandler\ndefaultUIComponentSignalHandler =\n  UIComponentSignalHandler\n    { _penModeSignal = Nothing,\n      _pageModeSignal = Nothing,\n      _penPointSignal = Nothing,\n      _penColorSignal = Nothing,\n      _newPageModeSignal = Nothing,\n      _switchTabSignal = Nothing\n    }\n\n-- | default settings\ndefaultSettings :: Settings\ndefaultSettings =\n  Settings\n    { _doesUseXInput = False,\n      _doesUseTouch = True,\n      _doesUsePopUpMenu = True,\n      _doesEmbedImage = True,\n      _doesEmbedPDF = True,\n      _doesFollowLinks = True,\n      _doesKeepAspectRatio = False,\n      _doesUseVariableCursor = False,\n      _newPageMode = NPPlain,\n      _networkEditSourceInfo = Nothing\n    }\n\n-- |\ngetHoodle :: UnitHoodle -> Hoodle EditMode\ngetHoodle = either id gSelect2GHoodle . hoodleModeStateEither . view hoodleModeState\n\n-- |\ngetCurrentCanvasId :: UnitHoodle -> CanvasId\ngetCurrentCanvasId = fst . _currentCanvas\n\n-- |\nsetCurrentCanvasId :: CanvasId -> UnitHoodle -> Maybe UnitHoodle\nsetCurrentCanvasId a f = do\n  cinfobox <- M.lookup a (_cvsInfoMap f)\n  return (f {_currentCanvas = (a, cinfobox)})\n\n-- |\nsetCanvasInfoMap :: CanvasInfoMap -> UnitHoodle -> Maybe UnitHoodle\nsetCanvasInfoMap cmap uhdl\n  | M.null cmap = Nothing\n  | otherwise =\n    let (cid, _) = _currentCanvas uhdl\n        (cidmax, cinfomax) = M.findMax cmap\n        mcinfobox = M.lookup cid cmap\n     in Just\n          . maybe\n            (uhdl {_currentCanvas = (cidmax, cinfomax), _cvsInfoMap = cmap})\n            ( \\cinfobox ->\n                uhdl\n                  { _currentCanvas = (cid, cinfobox),\n                    _cvsInfoMap = cmap\n                  }\n            )\n          $ mcinfobox\n\ncurrentCanvasInfo :: Lens\' UnitHoodle CanvasInfoBox\ncurrentCanvasInfo = lens getter setter\n  where\n    getter = snd . _currentCanvas\n    setter f a =\n      let cid = fst . _currentCanvas $ f\n          cmap\' = M.adjust (const a) cid (_cvsInfoMap f)\n       in f {_currentCanvas = (cid, a), _cvsInfoMap = cmap\'}\n\n-- |\nresetHoodleModeStateBuffers :: CanvasId -> HoodleModeState -> Renderer ()\nresetHoodleModeStateBuffers cid hdlmodestate1 =\n  case hdlmodestate1 of\n    ViewAppendState hdl -> updateHoodleBuf cid hdl\n    _ -> return ()\n\n-- |\ngetCanvasInfo :: CanvasId -> UnitHoodle -> CanvasInfoBox\ngetCanvasInfo cid uhdl =\n  let cinfoMap = view cvsInfoMap uhdl\n      maybeCvs = M.lookup cid cinfoMap\n   in maybeError\' ("no canvas with id = " ++ show cid) maybeCvs\n\n-- |\nsetCanvasInfo :: (CanvasId, CanvasInfoBox) -> UnitHoodle -> UnitHoodle\nsetCanvasInfo (cid, cinfobox) uhdl =\n  let cmap = view cvsInfoMap uhdl\n      cmap\' = M.insert cid cinfobox cmap\n   in fromMaybe uhdl $ setCanvasInfoMap cmap\' uhdl\n\n-- | change current canvas. this is the master function\nupdateFromCanvasInfoAsCurrentCanvas :: CanvasInfoBox -> UnitHoodle -> UnitHoodle\nupdateFromCanvasInfoAsCurrentCanvas cinfobox uhdl =\n  let cid = view (unboxLens canvasId) cinfobox\n      cmap = view cvsInfoMap uhdl\n      cmap\' = M.insert cid cinfobox cmap\n   in uhdl\n        { _currentCanvas = (cid, cinfobox),\n          _cvsInfoMap = cmap\'\n        }\n\n-- |\nsetCanvasId :: CanvasId -> CanvasInfoBox -> CanvasInfoBox\nsetCanvasId cid = runIdentity . forBoth unboxBiXform (return . set canvasId cid)\n\n-- |\nmodifyCanvasInfo ::\n  CanvasId ->\n  (CanvasInfoBox -> CanvasInfoBox) ->\n  UnitHoodle ->\n  UnitHoodle\nmodifyCanvasInfo cid f uhdl =\n  fromMaybe uhdl . flip setCanvasInfoMap uhdl\n    . M.adjust f cid\n    . view cvsInfoMap\n    $ uhdl\n\n-- |\nhoodleModeStateEither :: HoodleModeState -> Either (Hoodle EditMode) (Hoodle SelectMode)\nhoodleModeStateEither hdlmodst = case hdlmodst of\n  ViewAppendState hdl -> Left hdl\n  SelectState thdl -> Right thdl\n\n-- |\ngetCurrentPageFromHoodleModeState ::\n  CanvasInfo a -> HoodleModeState -> Page EditMode\ngetCurrentPageFromHoodleModeState cinfo hdlmodst =\n  let cpn = view currentPageNum cinfo\n      pagemap = getPageMapFromHoodleModeState hdlmodst\n   in maybeError\' "updatePageFromCanvasToHoodle" $ M.lookup cpn pagemap\n\n-- |\ngetCurrentPageDimFromHoodleModeState ::\n  CanvasInfo a -> HoodleModeState -> PageDimension\ngetCurrentPageDimFromHoodleModeState cinfo =\n  PageDimension . view gdimension . getCurrentPageFromHoodleModeState cinfo\n\n-- |\ngetPageMapFromHoodleModeState :: HoodleModeState -> M.IntMap (Page EditMode)\ngetPageMapFromHoodleModeState = either (view gpages) (view gselAll) . hoodleModeStateEither\n'