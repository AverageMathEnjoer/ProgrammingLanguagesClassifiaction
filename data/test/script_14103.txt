b'{-# LANGUAGE MultiWayIf #-}\n{-# LANGUAGE OverloadedStrings #-}\n{-# OPTIONS_GHC -fno-warn-unused-do-bind #-}\n\nmodule Text.Hoodle.Parse.Attoparsec.V0_3 where\n\nimport Control.Applicative (many, (<|>))\nimport Control.Monad (void)\nimport Data.Attoparsec.ByteString\n  ( Parser,\n    endOfInput,\n    inClass,\n    many1,\n    manyTill,\n    notInClass,\n    satisfy,\n    skipWhile,\n    string,\n    takeTill,\n    takeWhile,\n    takeWhile1,\n    try,\n    (<?>),\n  )\nimport Data.Attoparsec.ByteString.Char8\n  ( anyChar,\n    char,\n    decimal,\n    double,\n    isHorizontalSpace,\n    skipSpace,\n  )\nimport qualified Data.ByteString.Char8 as B\nimport Data.Functor (($>), (<&>))\nimport qualified Data.Hoodle.Simple.V0_3 as H\nimport Data.Strict.Tuple (Pair ((:!:)))\nimport qualified Data.Text as T\nimport qualified Data.Text.Encoding as TE\nimport Prelude hiding (takeWhile)\n\n-- |\nskipSpaces :: Parser ()\nskipSpaces = satisfy isHorizontalSpace *> skipWhile isHorizontalSpace\n\n-- |\ntrimStartingSpace :: Parser ()\ntrimStartingSpace =\n  do try endOfInput\n    <|> (takeWhile (inClass " \\n") $> ())\n\n-- |\nlangle :: Parser Char\nlangle = char \'<\'\n\n-- |\nrangle :: Parser Char\nrangle = char \'>\'\n\n-- |\nxmlheader :: Parser B.ByteString\nxmlheader = string "<?" *> takeTill (inClass "?>") <* string "?>"\n\n-- |\nheadercontentWorker :: B.ByteString -> Parser B.ByteString\nheadercontentWorker bstr = do\n  h <- takeWhile1 (notInClass "?>")\n  (string "?>" <&> (bstr `B.append` h `B.append`))\n    <|> headercontentWorker (bstr `B.append` h)\n\n-- |\nheadercontent :: Parser B.ByteString\nheadercontent = headercontentWorker B.empty\n\n-- |\ndata StrokeWidth = SingleWidth Double | VarWidth [Double]\n\n-- |\ndata XmlStroke = XmlStroke\n  { xstrk_tool :: B.ByteString,\n    xstrk_color :: B.ByteString,\n    xstrk_width :: StrokeWidth,\n    xstrk_xydata :: [Pair Double Double]\n  }\n\n-- |\nxmlstroketagopen :: Parser XmlStroke\nxmlstroketagopen = do\n  trim\n  string "<stroke"\n  trim\n  string "tool="\n  char \'"\'\n  tool <- alphabet\n  char \'"\'\n  trim\n  string "color="\n  char \'"\'\n  color <- alphanumsharp\n  char \'"\'\n  trim\n  string "width="\n  width <- strokewidth\n  char \'>\'\n  return $ XmlStroke tool color width []\n\nstrokewidth :: Parser StrokeWidth\nstrokewidth = do\n  char \'"\'\n  wlst <- many $ do\n    trimStartingSpace\n    w <- double\n    skipSpace\n    return w\n  char \'"\'\n  let msw\n        | length wlst == 1 = return (SingleWidth (head wlst))\n        | null wlst = fail "no width"\n        | otherwise = return (VarWidth wlst)\n  msw\n\n-- |\nxmlstroketagclose :: Parser ()\nxmlstroketagclose = void $ string "</stroke>"\n\n-- |\nxmlstroke :: Parser XmlStroke\nxmlstroke = do\n  trim\n  strokeinit <- xmlstroketagopen\n  coordlist <- many $ do\n    trimStartingSpace\n    x <- double\n    skipSpace\n    y <- double\n    skipSpace\n    return (x :!: y)\n  xmlstroketagclose\n  return $ strokeinit {xstrk_xydata = coordlist}\n\n-- |\nonestroke :: Parser H.Stroke\nonestroke = do\n  xstrk <- xmlstroke\n  let r = case xstrk_width xstrk of\n        SingleWidth w ->\n          ( H.Stroke <$> xstrk_tool\n              <*> xstrk_color\n              <*> pure w\n              <*> xstrk_xydata\n          )\n            xstrk\n        VarWidth ws ->\n          let xyz = mkXYZ (xstrk_xydata xstrk) ws\n           in ( H.VWStroke <$> xstrk_tool <*> xstrk_color\n                  <*> pure xyz\n              )\n                xstrk\n  return r\n\n-- |\nmkXYZ :: [Pair Double Double] -> [Double] -> [(Double, Double, Double)]\nmkXYZ = zipWith f where f (x :!: y) z = (x, y, z)\n\n-- |\nimg :: Parser H.Item\nimg = do\n  trim\n  string "<img"\n  trim\n  string "src=\\""\n  fsrc <- parseFileName\n  char \'"\'\n  trim\n  string "x=\\""\n  posx <- double\n  char \'"\'\n  trim\n  string "y=\\""\n  posy <- double\n  char \'"\'\n  trim\n  string "width=\\""\n  width <- double\n  char \'"\'\n  trim\n  string "height=\\""\n  height <- double\n  char \'"\'\n  trim\n  string "/>"\n  (return . H.ItemImage) (H.Image fsrc (posx, posy) (H.Dim width height))\n\nsvgHeader :: Parser ((Double, Double), H.Dimension)\nsvgHeader = do\n  trim\n  string "<svgobject"\n  trim\n  string "x=\\""\n  posx <- double\n  char \'"\'\n  trim\n  string "y=\\""\n  posy <- double\n  char \'"\'\n  trim\n  string "width=\\""\n  width <- double\n  char \'"\'\n  trim\n  string "height=\\""\n  height <- double\n  char \'"\'\n  trim\n  string ">"\n  return ((posx, posy), H.Dim width height)\n\nsvgFooter :: Parser ()\nsvgFooter = void $ string "</svgobject>"\n\ntextCDATA :: Parser B.ByteString\ntextCDATA = do\n  string "<text>"\n  bstr <- getCDATA\n  string "</text>"\n  return bstr\n\ncommandCDATA :: Parser B.ByteString\ncommandCDATA = do\n  string "<command>"\n  bstr <- getCDATA\n  string "</command>"\n  return bstr\n\nrenderCDATA :: Parser B.ByteString\nrenderCDATA = do\n  string "<render>"\n  bstr <- getCDATA\n  string "</render>"\n  return bstr\n\ngetCDATA :: Parser B.ByteString\ngetCDATA = (string "<![CDATA[" *> manyTill anyChar (try (string "]]>"))) <&> B.pack\n\nsvgObj :: Parser H.Item\nsvgObj = do\n  (xy, dim) <- svgHeader\n  trim\n  (mt, mc) <-\n    try\n      ( do\n          t <- textCDATA\n          trim\n          c <- commandCDATA\n          return (Just t, Just c)\n      )\n      <|> try (textCDATA >>= \\t -> return (Just t, Nothing))\n      <|> return (Nothing, Nothing)\n  trim\n  bstr <- renderCDATA\n  trim\n  svgFooter\n  (return . H.ItemSVG) (H.SVG mt mc bstr xy dim)\n\nlinkHeader ::\n  Parser\n    ( B.ByteString,\n      B.ByteString,\n      Maybe B.ByteString,\n      B.ByteString,\n      Maybe B.ByteString,\n      (Double, Double),\n      H.Dimension\n    )\nlinkHeader = do\n  trim\n  string "<link"\n  trim\n  i <- B.pack <$> (string "id=\\"" *> manyTill anyChar (try (char \'"\')))\n  trim\n  typ <- B.pack <$> (string "type=\\"" *> manyTill anyChar (try (char \'"\')))\n  trim\n  mlid <-\n    if\n        | typ == "simple" -> return Nothing\n        | typ == "linkdocid" || typ == "anchor" ->\n          Just\n            <$> ( string "linkedid=\\""\n                    *> takeTill (inClass "\\"")\n                    <* char \'"\'\n                )\n        | otherwise -> fail "unknown link type"\n  trim\n  loc <-\n    if typ == "simple" || typ == "linkdocid" || typ == "anchor"\n      then\n        string "location=\\""\n          *> takeTill (inClass "\\"")\n          <* char \'"\'\n      else fail "unknown link type"\n  trim\n  maid <-\n    if\n        | typ == "anchor" ->\n          Just\n            <$> ( string "anchorid=\\""\n                    *> takeTill (inClass "\\"")\n                    <* char \'"\'\n                )\n        | typ == "simple" || typ == "linkdocid" -> return Nothing\n        | otherwise -> fail "unknown link type"\n  trim\n  posx <- string "x=\\"" *> double <* char \'"\'\n  trim\n  posy <- string "y=\\"" *> double <* char \'"\'\n  trim\n  width <- string "width=\\"" *> double <* char \'"\'\n  trim\n  height <- string "height=\\"" *> double <* char \'"\'\n  trim\n  string ">"\n  return (i, typ, mlid, loc, maid, (posx, posy), H.Dim width height)\n\nlinkFooter :: Parser ()\nlinkFooter = void $ string "</link>"\n\nlink :: Parser H.Item\nlink = do\n  (i, typ, mlid, loc, maid, xy, dim) <- linkHeader\n  trim\n  (mt, mc) <-\n    try\n      ( do\n          t <- textCDATA\n          trim\n          c <- commandCDATA\n          return (Just t, Just c)\n      )\n      <|> try (textCDATA >>= \\t -> return (Just t, Nothing))\n      <|> return (Nothing, Nothing)\n  trim\n  bstr <- renderCDATA\n  trim\n  linkFooter\n  let lnk\n        | typ == "simple" = H.Link i typ loc mt mc bstr xy dim\n        | typ == "linkdocid" =\n          maybe\n            (error "no linkedid or location for linkdocid")\n            (\\lid -> H.LinkDocID i lid loc mt mc bstr xy dim)\n            mlid\n        | typ == "anchor" =\n          maybe\n            (error "no linkedid for anchor")\n            (\\(lid, aid) -> H.LinkAnchor i lid loc aid bstr xy dim)\n            (mlid >>= \\lid -> maid >>= \\aid -> return (lid, aid))\n        | otherwise = error "link type is not recognized"\n  (return . H.ItemLink) lnk\n\nanchor :: Parser H.Item\nanchor = do\n  trim\n  string "<anchor"\n  trim\n  i <- B.pack <$> (string "id=\\"" *> manyTill anyChar (try (char \'"\')))\n  trim\n  posx <- string "x=\\"" *> double <* char \'"\'\n  trim\n  posy <- string "y=\\"" *> double <* char \'"\'\n  trim\n  width <- string "width=\\"" *> double <* char \'"\'\n  trim\n  height <- string "height=\\"" *> double <* char \'"\'\n  trim\n  try\n    ( string "/>"\n        >> return (H.ItemAnchor (H.Anchor i "" (posx, posy) (H.Dim width height)))\n    )\n    <|> ( do\n            string ">"\n            trim\n            bstr <- renderCDATA\n            trim\n            void (string "</anchor>")\n            return . H.ItemAnchor $ H.Anchor i bstr (posx, posy) (H.Dim width height)\n        )\n\n-- |\ntrim :: Parser ()\ntrim = trimStartingSpace\n\n-- |\ncheckHoodleVersion :: Parser B.ByteString\ncheckHoodleVersion = do\n  trim\n  xmlheader\n  trim\n  hoodleheaderstart\n  trim\n  hoodleversion\n\n-- |\nhoodle :: Parser H.Hoodle\nhoodle = do\n  trim\n  xmlheader <?> "xmlheader"\n  trim\n  (_v, hid) <- hoodleheader <?> "hoodleheader"\n  trim\n  t <- title <?> "title"\n  trim\n  revs <- many (revision <?> "revision")\n  skipSpace\n  pdf <- try (Just <$> embeddedpdf) <|> return Nothing\n  txt <- try (Just <$> embeddedtext) <|> return Nothing\n  pgs <- many1 (page <?> "page")\n  trim\n  hoodleclose\n  return $ H.Hoodle hid t revs pdf txt pgs\n\npage :: Parser H.Page\npage = do\n  trim\n  dim <- pageheader\n  trim\n  bkg <- background <?> "background"\n  trim\n  layers <- many1 layer\n  trim\n  pageclose\n  return $ H.Page dim bkg layers\n\nlayer :: Parser H.Layer\nlayer = do\n  trim\n  layerheader <?> "layer"\n  trim\n  itms <- many (try (H.ItemStroke <$> onestroke) <|> try img <|> try svgObj <|> try link <|> anchor)\n  trim\n  layerclose\n  return $ H.Layer itms\n\ntitle :: Parser B.ByteString\ntitle = do\n  trim\n  titleheader\n  str <- takeTill (inClass "<")\n  titleclose\n  return str\n\ntitleheader :: Parser B.ByteString\ntitleheader = string "<title>"\n\ntitleclose :: Parser B.ByteString\ntitleclose = string "</title>"\n\nrevision :: Parser H.Revision\nrevision = do\n  skipSpace\n  string "<revision"\n  skipSpace\n  string "revmd5=\\""\n  md5str <- manyTill anyChar (try (char \'"\'))\n  skipSpace\n  try\n    ( do\n        string "revtxt=\\""\n        txtstr <- manyTill anyChar (try (char \'"\'))\n        skipSpace\n        string "/>"\n        return (H.Revision (B.pack md5str) (B.pack txtstr))\n    )\n    <|> ( do\n            string "type=\\"ink\\""\n            skipSpace\n            char \'>\'\n            skipSpace\n            strks <- many1 onestroke\n            skipSpace\n            string "</revision>"\n            return (H.RevisionInk (B.pack md5str) strks)\n        )\n\nembeddedpdf :: Parser B.ByteString\nembeddedpdf = do\n  string "<embeddedpdf"\n  trim\n  string "src=\\""\n  str <- manyTill anyChar (try (char \'"\'))\n  trim\n  string "/>"\n  return (B.pack str)\n\nembeddedtext :: Parser T.Text\nembeddedtext = do\n  string "<embeddedtext>"\n  bstr <- getCDATA\n  string "</embeddedtext>"\n  return (TE.decodeUtf8 bstr)\n\nhoodleheader :: Parser (B.ByteString, B.ByteString)\nhoodleheader = do\n  hoodleheaderstart\n  trim\n  v <- hoodleversion\n  trim\n  hid <- hoodleid\n  trim\n  char \'>\'\n  return (v, hid)\n\nhoodleheaderstart :: Parser B.ByteString\nhoodleheaderstart = string "<hoodle"\n\nhoodleversion :: Parser B.ByteString\nhoodleversion = string "version=\\"" *> takeTill (inClass "\\"") <* char \'"\'\n\nhoodleid :: Parser B.ByteString\nhoodleid = string "id=\\"" *> takeTill (inClass "\\"") <* char \'"\'\n\nhoodleheaderend :: Parser Char\nhoodleheaderend = char \'>\'\n\nhoodleclose :: Parser B.ByteString\nhoodleclose = string "</hoodle>"\n\npageheader :: Parser H.Dimension\npageheader = do\n  pageheaderstart\n  trim\n  string "width="\n  char \'"\'\n  w <- double\n  char \'"\'\n  trim\n  string "height="\n  char \'"\'\n  h <- double\n  char \'"\'\n  takeTill (inClass ">")\n  pageheaderend\n  return $ H.Dim w h\n\npageheaderstart :: Parser B.ByteString\npageheaderstart = string "<page"\n\npageheaderend :: Parser Char\npageheaderend = char \'>\'\n\npageclose :: Parser B.ByteString\npageclose = string "</page>"\n\nlayerheader :: Parser B.ByteString\nlayerheader = string "<layer>"\n\nlayerclose :: Parser B.ByteString\nlayerclose = string "</layer>"\n\nbackground :: Parser H.Background\nbackground = do\n  trim\n  backgroundheader\n  trim\n  string "type="\n  char \'"\'\n  typ <- alphabet\n  char \'"\'\n  case typ of\n    "solid" -> do\n      trim\n      string "color="\n      char \'"\'\n      col <- alphanumsharp\n      char \'"\'\n      trim\n      string "style="\n      trim\n      char \'"\'\n      sty <- alphabet\n      char \'"\'\n      trim\n      takeTill (inClass "/>")\n      backgroundclose\n      return $ H.Background typ col sty\n    "pdf" -> do\n      trim <?> "trim0"\n      (mdomain, mfilename) <-\n        try\n          ( do\n              string "domain="\n              char \'"\'\n              domain <- alphabet\n              char \'"\'\n              trim <?> "trim1"\n              string "filename="\n              trim <?> "trim2"\n              char \'"\'\n              filename <- parseFileName <?> "filename parse"\n              char \'"\'\n              return (Just domain, Just filename)\n          )\n          <|> return (Nothing, Nothing)\n      trim <?> "trim3"\n      string "pageno="\n      trim <?> "trim4"\n      char \'"\'\n      pnum <- decimal <?> "decimal"\n      char \'"\'\n      trim\n      takeTill (inClass "/>") <?> "here takeTill"\n      backgroundclose\n      return $ H.BackgroundPdf typ mdomain mfilename pnum\n    "embedpdf" -> do\n      trim <?> "trim0"\n      string "pageno="\n      char \'"\'\n      pnum <- decimal <?> "embedpdf decimal"\n      char \'"\'\n      trim\n      backgroundclose\n      return $ H.BackgroundEmbedPdf typ pnum\n    _ -> fail "in parsing background"\n\nalphabet :: Parser B.ByteString\nalphabet = takeWhile1 (\\w -> (w >= 65 && w <= 90) || (w >= 97 && w <= 122))\n\nalphanumsharp :: Parser B.ByteString\nalphanumsharp =\n  takeWhile1\n    ( \\w ->\n        (w >= 65 && w <= 90)\n          || (w >= 97 && w <= 122)\n          || (w >= 48 && w <= 57)\n          || (w == 35)\n    )\n\n-- | need to be reimplemented\nparseFileName :: Parser B.ByteString\nparseFileName = takeTill (inClass [\'"\'])\n\n-- |\nbackgroundheader :: Parser B.ByteString\nbackgroundheader = string "<background"\n\n-- |\nbackgroundclose :: Parser B.ByteString\nbackgroundclose = string "/>"\n'