b'#include <unordered_map>\n#include <memory>\n#include "../libStringConverter/convert.h"\n#include "../UABE_Generic/PluginManager.h"\n#include "../UABE_Generic/FileContextInfo.h"\n#include "../UABE_Generic/AppContext.h"\n#include "../AssetsTools/TextureFileFormat.h"\n\n#include "Texture.h"\n\n#ifdef _WIN32\n#define STBI_WINDOWS_UTF8\n#endif\n#define STB_IMAGE_IMPLEMENTATION\n#include "stb_image.h"\n#define STB_IMAGE_WRITE_IMPLEMENTATION\n#include "stb_image_write.h"\n\n#define LODEPNG_NO_COMPILE_DECODER\n#define LODEPNG_NO_COMPILE_ANCILLARY_CHUNKS\n#include "lodepng.h"\n\n#pragma region Import\nstatic int stbi__AssetsTools_read(void* user, char* data, int size)\n{\n\treturn (int)((IAssetsReader*)user)->Read((QWORD)size, data);\n}\nstatic void stbi__AssetsTools_skip(void* user, int n)\n{\n\t((IAssetsReader*)user)->Seek(AssetsSeek_Cur, n);\n}\nstatic int stbi__AssetsTools_eof(void* user)\n{\n\tif (((IAssetsReader*)user)->Seek(AssetsSeek_Cur, 1))\n\t{\n\t\t((IAssetsReader*)user)->Seek(AssetsSeek_Cur, -1);\n\t\treturn 0;\n\t}\n\treturn 1;\n}\nstatic stbi_io_callbacks stbi__AssetsTools_callbacks =\n{\n   stbi__AssetsTools_read,\n   stbi__AssetsTools_skip,\n   stbi__AssetsTools_eof,\n};\n\nbool LoadTextureFromFile(const char *filePath, std::vector<uint8_t> &newTextureData, unsigned int &newWidth, unsigned int &newHeight)\n{\n\tstd::unique_ptr<IAssetsReader> pImageFileReader(Create_AssetsReaderFromFile(filePath, true, RWOpenFlags_Immediately));\n\tif (pImageFileReader == nullptr)\n\t\treturn false;\n\n\tint width, height, n;\n\tstbi__vertically_flip_on_load = 1; //added because the image is flipped on save\n\tuint8_t *pImg = stbi_load_from_callbacks(&stbi__AssetsTools_callbacks, pImageFileReader.get(), &width, &height, &n, 4);\n\tif (pImg == NULL)\n\t\treturn false;\n\tnewWidth = width;\n\tnewHeight = height;\n\tnewTextureData.assign(&pImg[0], &pImg[(size_t)width * height * 4]);\n\tfree(pImg);\n\treturn true;\n}\n#pragma endregion\n\nbool PluginSupportsElements(std::vector<AssetUtilDesc>& elements)\n{\n\tstd::unordered_map<AssetsFileContextInfo*, int32_t> texture2DClassIDs;\n\tfor (size_t i = 0; i < elements.size(); i++)\n\t{\n\t\tif (elements[i].asset.pFile == nullptr)\n\t\t\treturn false;\n\t\tAssetsFileContextInfo* pFile = elements[i].asset.pFile.get();\n\t\tauto classIDsit = texture2DClassIDs.find(pFile);\n\t\tint32_t texture2DClassID = -1;\n\t\tif (classIDsit == texture2DClassIDs.end())\n\t\t{\n\t\t\ttexture2DClassID = pFile->GetClassByName("Texture2D");\n\t\t\ttexture2DClassIDs[pFile] = texture2DClassID;\n\t\t}\n\t\telse\n\t\t\ttexture2DClassID = classIDsit->second;\n\t\tif (texture2DClassID == -1)\n\t\t\treturn false;\n\t\tint32_t classId = elements[i].asset.getClassID();\n\t\tif (classId != texture2DClassID)\n\t\t\treturn false;\n\t}\n\treturn true;\n}\n\nclass TextureExportTask : public AssetExportTask\n{\n\tAppContext& appContext;\n\tEExportFormat exportFormat;\n\tTypeTemplateCache templateCache;\npublic:\n\tTextureExportTask(AppContext& appContext,\n\t\tstd::vector<AssetUtilDesc> _assets, std::string _baseDir, std::string _extension, EExportFormat exportFormat,\n\t\tbool stopOnError = false)\n\n\t\t: AssetExportTask(std::move(_assets), "Export Texture2D", std::move(_extension), std::move(_baseDir), stopOnError),\n\t\tappContext(appContext), exportFormat(exportFormat)\n\t{}\n\n\tbool exportAsset(AssetUtilDesc& desc, std::string path, std::optional<std::reference_wrapper<TaskProgressManager>> progressManager)\n\t{\n\t\tif (desc.asset.pFile == nullptr)\n\t\t\tthrow AssetUtilError("Unable to find the target .assets file.");\n\n\t\tIAssetsReader_ptr pAssetReader = desc.asset.makeReader();\n\t\tif (pAssetReader == nullptr)\n\t\t\tthrow AssetUtilError("Unable to read the asset.");\n\t\tQWORD assetSize = 0;\n\t\tif (!pAssetReader->Seek(AssetsSeek_End, 0) || !pAssetReader->Tell(assetSize) || !pAssetReader->Seek(AssetsSeek_Begin, 0))\n\t\t\tthrow AssetUtilError("Unable to read the asset.");\n\n\t\tAssetTypeTemplateField& templateBase = templateCache.getTemplateField(appContext, desc.asset);\n\t\tAssetTypeTemplateField* pTemplateBase = &templateBase;\n\n\t\tAssetTypeInstance assetInstance(1, &pTemplateBase, assetSize, pAssetReader.get(), desc.asset.isBigEndian());\n\t\tAssetTypeValueField* pBaseField = assetInstance.GetBaseField();\n\t\tif (pBaseField == nullptr || pBaseField->IsDummy())\n\t\t\tthrow AssetUtilError("Unable to deserialize the asset.");\n\n\t\tTextureFile textureFile; memset(&textureFile, 0, sizeof(TextureFile));\n\t\tif (!ReadTextureFile(&textureFile, pBaseField))\n\t\t\tthrow AssetUtilError("Unknown Texture2D asset format.");\n\t\t//Retrieve the texture format version.\n\t\tSupportsTextureFormat(desc.asset.pFile->getAssetsFileContext()->getAssetsFile(),\n\t\t\t(TextureFormat)0,\n\t\t\ttextureFile.extra.textureFormatVersion);\n\n\t\tif (textureFile._pictureDataSize == 0)\n\t\t\ttextureFile.pPictureData = NULL;\n\t\tstd::vector<uint8_t> texDataResourceBuf;\n\t\tstd::vector<uint8_t> texDataDecompressed((size_t)textureFile.m_Width * textureFile.m_Height * 4);\n\t\tif (textureFile._pictureDataSize == 0 && (textureFile.m_Width * textureFile.m_Height) > 0 && textureFile.m_StreamData.size)\n\t\t{\n\t\t\tstd::shared_ptr<ResourcesFileContextInfo> streamResourcesContextInfo;\n\t\t\tstreamResourcesContextInfo = FindResourcesFile(appContext, textureFile.m_StreamData.path, desc.asset, progressManager);\n\t\t\t//Non-null guaranteed by FindResourcesFile (AssetUtilError thrown otherwise).\n\n\t\t\tstd::shared_ptr<IAssetsReader> pStreamReader = streamResourcesContextInfo->getResource(streamResourcesContextInfo,\n\t\t\t\ttextureFile.m_StreamData.offset,\n\t\t\t\ttextureFile.m_StreamData.size);\n\t\t\tif (pStreamReader == nullptr)\n\t\t\t\tthrow AssetUtilError("Unable to locate the texture resource.");\n\n\t\t\ttexDataResourceBuf.resize(textureFile.m_StreamData.size);\n\t\t\ttextureFile.pPictureData = texDataResourceBuf.data();\n\t\t\tif (pStreamReader->Read(0, textureFile.m_StreamData.size, textureFile.pPictureData)\n\t\t\t\t< textureFile.m_StreamData.size)\n\t\t\t\tthrow AssetUtilError("Unable to read data from the texture resource.");\n\n\t\t\ttextureFile._pictureDataSize = textureFile.m_StreamData.size;\n\t\t}\n\t\tif (!GetTextureData(&textureFile, texDataDecompressed.data()))\n\t\t\tthrow AssetUtilError("Unable to convert the texture data.");\n\n\t\tswitch (exportFormat)\n\t\t{\n\t\tcase EExportFormat::PNG:\n\t\t\t{\n\t\t\t\tif (textureFile.m_Height > 1)\n\t\t\t\t{\n\t\t\t\t\tstd::vector<uint8_t> flipDataTmp(textureFile.m_Width * 4);\n\t\t\t\t\tunsigned int stride = textureFile.m_Width * 4;\n\t\t\t\t\tunsigned int halfHeight = textureFile.m_Height / 2;\n\t\t\t\t\tunsigned int curLinePos = 0;\n\t\t\t\t\tunsigned int curEndLinePos = stride * (textureFile.m_Height - 1);\n\t\t\t\t\tfor (unsigned int y = 0; y < halfHeight; y++)\n\t\t\t\t\t{\n\t\t\t\t\t\tmemcpy(flipDataTmp.data(), &texDataDecompressed.data()[curLinePos], stride);\n\t\t\t\t\t\tmemcpy(&texDataDecompressed.data()[curLinePos], &texDataDecompressed.data()[curEndLinePos], stride);\n\t\t\t\t\t\tmemcpy(&texDataDecompressed.data()[curEndLinePos], flipDataTmp.data(), stride);\n\n\t\t\t\t\t\tcurLinePos += stride;\n\t\t\t\t\t\tcurEndLinePos -= stride;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//stbi_write_pngW(targetFile, g_TextureWidth, g_TextureHeight, 4, textureData, g_TextureWidth*4);\n\t\t\t\tauto pathW = unique_MultiByteToWide(path.c_str());\n\t\t\t\tlodepng_encode32_fileW(pathW.get(), texDataDecompressed.data(), textureFile.m_Width, textureFile.m_Height);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase EExportFormat::TGA:\n\t\t\tstbi_write_tga(path.c_str(), textureFile.m_Width, textureFile.m_Height, 4, true, texDataDecompressed.data());\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tassert(false);\n\t\t\tthrow AssetUtilError("Unexpected export format.");\n\t\t\tbreak;\n\t\t}\n\n\t\treturn true;\n\t}\n};\nclass TextureExportProvider : public IAssetOptionProviderGeneric\n{\npublic:\n\tstd::string optionName;\n\tstd::string extension;\n\tstd::string extensionFilter;\n\tEExportFormat exportFormat;\n\tclass Runner : public IOptionRunner\n\t{\n\t\tAppContext& appContext;\n\t\tstd::vector<AssetUtilDesc> selection;\n\t\tstd::string extension;\n\t\tstd::string extensionFilter;\n\t\tEExportFormat exportFormat;\n\tpublic:\n\t\tRunner(AppContext& appContext, std::vector<AssetUtilDesc> _selection,\n\t\t\tconst std::string& extension, const std::string& extensionFilter,\n\t\t\tEExportFormat exportFormat)\n\t\t\t: appContext(appContext), selection(std::move(_selection)),\n\t\t\t  extension(extension), extensionFilter(extensionFilter), exportFormat(exportFormat)\n\t\t{}\n\t\tvoid operator()()\n\t\t{\n\t\t\tstd::string exportLocation = appContext.QueryAssetExportLocation(selection, extension, extensionFilter);\n\t\t\tif (!exportLocation.empty())\n\t\t\t{\n\t\t\t\tauto pTask = std::make_shared<TextureExportTask>(appContext, std::move(selection), std::move(exportLocation), std::move(extension), exportFormat);\n\t\t\t\tappContext.taskManager.enqueue(pTask);\n\t\t\t}\n\t\t}\n\t};\n\n\tinline TextureExportProvider(const std::string &optionName,\n\t\tconst std::string &extension, const std::string &extensionFilter,\n\t\tEExportFormat exportFormat)\n\n\t\t: optionName(optionName), extension(extension), extensionFilter(extensionFilter), exportFormat(exportFormat)\n\t{}\n\tEAssetOptionType getType()\n\t{\n\t\treturn EAssetOptionType::Export;\n\t}\n\tstd::unique_ptr<IOptionRunner> prepareForSelection(\n\t\tclass AppContext& appContext,\n\t\tstd::vector<struct AssetUtilDesc> selection,\n\t\tstd::string& optionName)\n\t{\n\t\tif (!PluginSupportsElements(selection))\n\t\t\treturn nullptr;\n\t\toptionName = this->optionName;\n\t\treturn std::make_unique<Runner>(appContext, std::move(selection), extension, extensionFilter, exportFormat);\n\t}\n};\n\n//class GenericTexturePluginDesc : public IPluginDesc\n//{\n\tGenericTexturePluginDesc::GenericTexturePluginDesc()\n\t{\n\t\tpProviders = { \n\t\t\tstd::make_shared<TextureExportProvider>("Export to .png", ".png", "*.png|PNG file:", EExportFormat::PNG),\n\t\t\tstd::make_shared<TextureExportProvider>("Export to .tga", ".tga", "*.tga|TGA file:", EExportFormat::TGA),\n\t\t\t//std::make_shared<TextureImportProvider>() \n\t\t};\n\t}\n\tstd::string GenericTexturePluginDesc::getName()\n\t{\n\t\treturn "Texture";\n\t}\n\tstd::string GenericTexturePluginDesc::getAuthor()\n\t{\n\t\treturn "";\n\t}\n\tstd::string GenericTexturePluginDesc::getDescriptionText()\n\t{\n\t\treturn "Export and import the content of Texture2D assets.";\n\t}\n\t//The IPluginDesc object should keep a reference to the returned options, as the caller may keep only std::weak_ptrs.\n\t//Note: May be called early, e.g. before program UI initialization.\n\tstd::vector<std::shared_ptr<IOptionProvider>> GenericTexturePluginDesc::getPluginOptions(class AppContext& appContext)\n\t{\n\t\treturn pProviders;\n\t}\n//};\n'