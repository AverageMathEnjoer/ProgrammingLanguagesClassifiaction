b'#\' Extract Data Information From Arguments Passed to Functions\n#\'\n#\' Using sys.calls(), sys.frames() and match.call(), this utility function\n#\' extracts and/or infers information about the data being processed.\n#\' Data frame name, variable names and labels if any, subsetting information,\n#\' grouping information (when by() is used) are returned by the function which\n#\' tries various methods to get this information.\n#\'\n#\' @param sys_calls Object created using \\code{sys.calls()}.\n#\' @param sys_frames Object created using \\code{sys.frames()}.\n#\' @param match_call Object created using \\code{match.call()}.\n#\' @param var Character. \\dQuote{x} (default) and/or \\dQuote{y} (the latter \n#\'   being used only in \\code{\\link{ctable}}).\n#\' @param silent Logical. Hide console messages. \\code{TRUE} by default.\n#\' \n#\' @return A list consisting of one or many of the following items\n#\' \\itemize{\n#\'   \\item df_name The data frame name\n#\'   \\item df_label The data frame label\n#\'   \\item var_name The variable name(s)\n#\'   \\item var_label The variable label\n#\'   \\item by_var The variable used in \\code{by()}, when in the call stack\n#\'   \\item by_group The group, when \\code{by()} was used\n#\'   \\item by_first Binary indicator used when \\code{by()} is in the call stack\n#\'   \\item by_last Binary indicator}\n#\'\n#\' @keywords internal misc\n#\'\n#\' @author Dominic Comtois, \\email{dominic.comtois@@gmail.com}\n#\'\n#\' @importFrom pryr standardise_call where\n#\' @importFrom utils head\nparse_args <- function(sys_calls,\n                       sys_frames,\n                       match_call, \n                       var       = "x",\n                       silent    = FALSE, \n                       df_name   = TRUE,\n                       df_label  = TRUE,\n                       var_name  = TRUE,\n                       var_label = TRUE,\n                       caller = "") {\n  \n  upd_output <- function(item, value, force = FALSE) {\n    output <- get("output", envir = fn.env)\n    if (isTRUE(force) || \n        ((length(output[[item]]) == 0 || is.na(output[[item]])) &&\n          length(value) == 1 && class(value) == class(output[[item]]))) {\n      names(value) <- NULL\n      \n      if (sum(value %in% c(".", NA)) == length(value))\n        value <- NA_character_\n      \n      output[[item]] <- value\n      \n      # Check if output is ready to be returned\n      if (count_empty(output, count.nas = FALSE) == 0) {\n        # Cleanup\n        for (item in intersect(c("var_name", "by_var", "by_group"),\n                                 names(output))) {\n          if (length(output$df_name) == 1 && !is.na(output$df_name)) {\n            \n            re <- paste0("^",output$df_name,  # starts with df_name\n                         "[$[]*[\'\\"]?",       # subsetting chars\n                         "([\\\\w_.]+)",        # var_name (group 1)\n                         "[\'\\"]?\\\\]{0,2}",    # closing subsetting char(s)\n                         "(.*)$")             # remainder of expression (gr. 2)\n            output[[item]] <- sub(pattern = re,\n                                  replacement = "\\\\1\\\\2", \n                                  x = output[[item]], perl = TRUE)\n            \n            if (item == "by_group") {\n              output$by_group <- gsub(paste0(output$df_name, "\\\\$"), "", output$by_group)\n            }\n            \n          }\n          output[[item]] <- gsub("[\'\\"]", "", output[[item]])\n        }\n      \n        empty_elements <- as.numeric(\n          which(vapply(output, function(x) {identical(x, NA_character_) || \n              length(x) == 0}, TRUE))\n          )\n        \n        if (length(empty_elements) > 0) {\n          output <- output[-empty_elements]\n        }\n        \n        assign("do_return", envir = fn.env, value = TRUE)        \n      }\n    }\n    assign("output", output, envir = fn.env)\n  }\n\n  populate_by_info <- function() {\n    \n    if ("list" %in% all.names(calls$by$INDICES)) {\n      by_var <- character()\n      for (i in seq_len(length(calls$by$INDICES) - 1)) {\n        by_var[i]  <- sub("\\\\(\\\\)", "", deparse(calls$by$INDICES[i + 1]))\n      }\n    } else {\n      by_var <- deparse(calls$by$INDICES)\n    }\n\n    for (i in seq_along(by_var)) {\n      # Normalize variable name\n      if (grepl(re4, by_var[i], perl = TRUE)) {\n        df_nm   <- sub(re1, "\\\\1", by_var[i], perl = TRUE)\n        df_       <- get_object(df_nm, "data.frame")\n        if (!identical(df_, NA)) {\n          v_name <- sub(re1, "\\\\4", by_var[i], perl = TRUE)\n          if (v_name %in% colnames(df_)) {\n            by_var[i] <- paste(df_nm, v_name, sep = "$")\n          }\n        }\n      }\n      \n      if (grepl(re2, by_var[i], perl = TRUE)) {\n        df_nm <- sub(re2, "\\\\1", by_var[i], perl = TRUE)\n        df_   <- get_object(df_nm, "data.frame")\n        if (!identical(df_, NA)) {\n          var_number <- as.numeric(sub(re2, "\\\\4", by_var[i], perl = TRUE))\n          v_name <- colnames(df_)[var_number]\n          by_var[i] <- paste(df_nm, v_name, sep = "$")\n        }\n      }\n    }\n  \n    # On first iteration, generate levels based on IND variables, and store\n    if (length(.st_env$byInfo) == 0) {\n      if (is.null(names(sys_frames[[pos$tapply]]$namelist)) ||\n          is.na(names(sys_frames[[pos$tapply]]$namelist)[1])) {\n        names(sys_frames[[pos$tapply]]$namelist) <- \n          by_var #as.character(calls$by$INDICES)[-1]\n      }\n      by_levels <- sys_frames[[pos$tapply]]$namelist\n      .st_env$byInfo$by_levels <- \n        expand.grid(by_levels, stringsAsFactors = FALSE)\n      # Following line is possibly redundant\n      colnames(.st_env$byInfo$by_levels) <- by_var\n      .st_env$byInfo$iter <- 1\n    }\n   \n    # Populate by_group item\n    by_group <- \n      paste(colnames(.st_env$byInfo$by_levels),\n            as.character(.st_env$byInfo$by_levels[.st_env$byInfo$iter, ]),\n            sep = " = ", collapse = ", ")\n    \n    # by_first and by_last are used by print.summarytools when printing objects\n    # passed by the by() function\n    if (.st_env$byInfo$iter == 1 && nrow(.st_env$byInfo$by_levels) == 1) {\n      by_first <- TRUE\n      by_last  <- TRUE\n      .st_env$byInfo <- list()\n    } else if (.st_env$byInfo$iter == 1) {\n      by_first <- TRUE\n      by_last  <- FALSE\n      .st_env$byInfo$iter <- .st_env$byInfo$iter + 1\n    } else if (.st_env$byInfo$iter == nrow(.st_env$byInfo$by_levels)) {\n      by_first <- FALSE\n      by_last  <- TRUE\n      .st_env$byInfo <- list()\n    } else {\n      by_first <- FALSE\n      by_last <- FALSE\n      .st_env$byInfo$iter <- .st_env$byInfo$iter + 1\n    }\n    \n    upd_output("by_var",   by_var, force = (length(by_var) > 1))\n    upd_output("by_group", by_group)\n    upd_output("by_first", by_first)\n    upd_output("by_last",  by_last)\n    TRUE\n  }\n  \n  by_ctable_case <- function() {\n    if (!is.null(names(calls$by$data))) {\n      v_name <- c(deparse(calls$by$data$x), deparse(calls$by$data$y))\n    } else {\n      v_name <- as.character(calls$by$data[2:3])\n    }\n    \n    if (!"with" %in% names(calls)) {\n      if (any(grepl("\\\\$", v_name))) {\n        df_nm    <- sub("^([\\\\w._]+)\\\\$.+$", "\\\\1", v_name[1], perl = TRUE)\n        df_nm[2] <- sub("^([\\\\w._]+)\\\\$.+$", "\\\\1", v_name[2], perl = TRUE)\n      }\n      \n      if (isTRUE(df_nm[1] == df_nm[2])) {\n        df_nm <- df_nm[1]\n        df_ <- get_object(df_nm, "data.frame")\n        if (!identical(df_, NA)) {\n          upd_output("df_name", df_nm)\n          upd_output("df_label", label(df_))\n        }\n      } else {\n        upd_output("df_name", NA_character_)\n        upd_output("df_label", NA_character_)\n      }\n    }\n    upd_output("var_name", v_name, force = TRUE)\n  }\n\n  get_object <- function(name, class) {\n    for (i in seq_along(sys_frames)) {\n      if (name %in% ls(sys_frames[[i]])) {\n        if (inherits(sys_frames[[i]][[name]], class)) {\n          return(sys_frames[[i]][[name]])\n        }\n      }\n    }\n    # fallback method\n    env <- pryr::where(name = name)\n    return(get(name, env, mode = "list"))\n  }\n\n  parse_data_str <- function(str) {\n    \n    if (grepl(re1, str, perl = TRUE)) {\n      df_nm <- sub(re1, "\\\\1", str, perl = TRUE)\n      df_   <- get_object(df_nm, "data.frame")\n      if (!identical(df_, NA)) {\n        upd_output("df_name", df_nm)\n        upd_output("df_label", label(df_))\n        v_name <- sub(re1, "\\\\4", str, perl = TRUE)\n        if (v_name %in% colnames(df_)) {\n          upd_output("var_name", v_name)\n          upd_output("var_label", label(df_[[v_name]]))\n          return(TRUE)\n        }\n      }\n    } else if (grepl(re2, str, perl = TRUE)) {\n      df_nm   <- sub(re2, "\\\\1", str, perl = TRUE)\n      df_       <- get_object(df_nm, "data.frame")\n      if (!identical(df_, NA)) {\n        upd_output("df_name",  df_nm)\n        upd_output("df_label", label(df_))\n        var_number <- as.numeric(sub(re2, "\\\\4", str, perl = TRUE))\n        upd_output("var_name",  colnames(df_)[var_number])\n        upd_output("var_label", label(df_[[var_number]]))\n        return(TRUE)\n      }\n    } else if (grepl(re3, str, perl = TRUE)) {\n      obj_name <- sub(re3, "\\\\1", str, perl = TRUE)\n      obj_env <- try(pryr::where(obj_name))\n      if (!inherits(obj_env, "try-error")) {\n        obj <- get(obj_name, envir = obj_env)\n        if (is.data.frame(obj)) {\n          upd_output("df_name", obj_name)\n          upd_output("df_label", label(obj))\n          if (isTRUE(var_name)) {\n            obj2_name <- sub(re3, "\\\\2", str, perl = TRUE)\n            obj2      <- try(eval(parse(text = obj2_name), envir = obj), \n                             silent = TRUE)\n            if (!inherits(obj2, "try-error") && is.atomic(obj2)) {\n              upd_output("var_name",  obj2_name)\n              upd_output("var_label", NA_character_)\n            }\n          }\n        } else if (is.atomic(obj)) {\n          upd_output("var_name", obj_name)\n          upd_output("var_label", label(obj))\n        }\n        return(TRUE)\n      }\n    }\n    upd_output("df_name",   NA_character_)\n    upd_output("var_name",  NA_character_)\n    upd_output("df_label",  NA_character_)\n    upd_output("var_label", NA_character_)\n    return(FALSE)\n  }\n  \n  # When pipe is used, this recursive function gets the "deepest" lhs\n  # that constitutes something other than a function call\n  get_lhs <- function(x) {\n    if (!is.null(names(x)) && "lhs" %in% names(x) && is.call(x$lhs)) {\n      x$lhs <- pryr::standardise_call(x$lhs)\n      return(get_lhs(x$lhs))\n    } else if (!is.null(names(x)) && "lhs" %in% names(x)) {\n      return(x$lhs)\n    } else {\n      return(x)\n    }\n  }\n  \n  get_last_x <- function(expr) {\n    if (is.call(expr) && "x" %in% names(pryr::standardise_call(expr))) {\n      get_last_x(pryr::standardise_call(expr)$x)\n    } else {\n      return(expr)\n    }\n  }\n  \n  # Declare a few "constant" ---------------------------------------------------\n  oper <- c("$", "[", "[[", "<", ">", "<=", ">=", "==", ":", "%>%")\n  fn.env <- environment()\n  do_return <- FALSE\n  # regex 1 ; both names are there (df$name, df[\'name\']), etc.\n  re1 <- paste0("^([\\\\w.]+)(\\\\$|\\\\[{1,2})(.*\\\\,\\\\s)?[\'\\"]?",\n                "([a-zA-Z._][\\\\w._]+)[\'\\"]?\\\\]{0,2}(\\\\[.+)?$")\n  # regex 2 ; there is numeric indexing (df[[2]], df[ ,2], df[2])\n  re2 <- "^([\\\\w.]+)(\\\\$|\\\\[{1,2})(.*\\\\,\\\\s)?(\\\\d+)\\\\]{1,2}(\\\\[.+)?$"\n  # regex 3 : fallback solution when only 1 name can be found / second group\n  #           can also be further decomposed if needed\n  re3 <- "^([a-zA-Z._][\\\\w.]*)[$[]*(.*?)$"\n  # re4 is like re1 but doesn\'t match df$name\n  re4 <- paste0("^([\\\\w.]+)(\\\\[{1,2})(.*\\\\,\\\\s)?[\'\\"]?",\n                "([a-zA-Z._][\\\\w._]+)[\'\\"]?\\\\]{0,2}(\\\\[.+)?$")\n  \n  # Initialize output object\n  output <- list()\n  if (isTRUE(df_name))\n    output %+=% list(df_name   = character())\n  if (isTRUE(df_label))\n    output %+=% list(df_label  = character())\n  if (isTRUE(var_name))\n    output %+=% list(var_name  = character())\n  if (isTRUE(var_label))\n    output %+=% list(var_label = character())\n  \n  #  Make a list of all data items contained in the environments\n  ls_sys_frames <- lapply(sys_frames, ls)\n  funs_stack    <- lapply(sys_calls, head, 1)\n  names(ls_sys_frames) <- sub("summarytools::", "",\n                              as.character(unlist(funs_stack)))\n  \n  # Look for position of by() + tapply(), with() lapply() and %>% in sys.calls()\n  pos         <- list()\n  pos$by      <- which(funs_stack %in% c("by()", "stby()"))\n  pos$with    <- which(funs_stack %in% c("base::with()", "with()"))\n  pos$pipe    <- which(funs_stack == "`%>%`()")\n  pos$piper   <- which(funs_stack == "`%>>%`()")\n  pos$dollar  <- which(funs_stack == "`%$%`()")\n  pos$lapply  <- which(funs_stack == "lapply()")\n  pos$tapply  <- which(funs_stack == "tapply()")\n  pos$fun     <- which(grepl(paste0(caller, "()"), funs_stack))\n  \n  pos <- pos[-which(unlist(lapply(pos, length)) == 0)]\n  \n  if ("by" %in% names(pos)) {\n    output %+=% list(by_var   = character(),\n                     by_group = character(),\n                     by_first = logical(),\n                     by_last  = logical())\n  }\n  \n  # Generate standardized calls\n  calls <- list()\n  for (i in seq_along(pos)) {\n    calls[[names(pos)[i]]] <- sys_calls[[pos[[i]]]]\n  }\n\n  # in the call stack: by() ----------------------------------------------------  \n  if ("by" %in% names(calls)) {\n    calls$by <- pryr::standardise_call(calls$by)\n    try(calls$lapply <- pryr::standardise_call(calls$lapply[-4]), silent = TRUE)\n    try(calls$tapply <- pryr::standardise_call(calls$tapply), silent = TRUE)\n\n    populate_by_info()\n    # treat special case of by() called on ctable, with ou without "with()"\n    if (length(calls$by$data) > 1 && deparse(calls$by$data[[1]]) == "list"\n        #&& identical(names(calls$by$data), c("", "x", "y"))) {\n        && caller == "ctable") {\n      by_ctable_case()\n      if (isTRUE(do_return)) {\n        return(output)\n      }\n    } else {\n      x <- sys_frames[[pos$by]]$data\n      if (is.data.frame(x)) {\n        if (length(calls$by$data) == 1) {\n          upd_output("df_name", deparse(calls$by$data))\n          upd_output("df_label",\n                     label(get_object(deparse(calls$by$data), "data.frame")))\n        } else {\n          parse_data_str(deparse(calls$by$data))\n        }\n      } else if (is.atomic(x)) {\n        if (length(calls$by$data) == 1) {\n          upd_output("var_name", deparse(calls$by$data))\n          upd_output("var_label", label(x))\n          if (!"with" %in% names(calls)) {\n            upd_output("df_name", NA_character_)\n            upd_output("df_label", NA_character_)\n          }\n        } else {\n          x_str <- deparse(calls$by$data)\n          parse_data_str(x_str)\n        }\n      }\n    }\n    if (isTRUE(do_return)) {\n      return(output)\n    }\n  }\n  \n  # in the call stack: with() --------------------------------------------------  \n  if ("with" %in% names(calls)) {\n    x <- sys_frames[[pos$with]]$data\n    calls$with <- pryr::standardise_call(calls$with)\n    calls$with$expr <- pryr::standardise_call(calls$with$expr)\n    if (is.data.frame(x)) {\n      if (length(calls$with$data) == 1) {\n        tmp_name <- deparse(calls$with$data)\n        if (tmp_name == "." && "dollar" %in% names(calls)) {\n          calls$dollar <- pryr::standardise_call(calls$dollar)\n          if (is.call(calls$dollar$rhs) && \n              identical(pryr::standardise_call(calls$dollar$rhs), calls$with$expr)) {\n            tmp_name <- calls$dollar$lhs\n            if (length(tmp_name) == 1) {\n              upd_output("df_name",  deparse(tmp_name))\n            } else {\n              upd_output("df_name",  NA_character_)\n            }\n            upd_output("df_label", label(x))\n          }\n        } else if (tmp_name == "." && "pipe" %in% names(calls)) {\n          calls$pipe <- pryr::standardise_call(calls$pipe)\n          calls$pipe$lhs <- pryr::standardise_call(calls$pipe$lhs)\n          tmp_name <- get_lhs(calls$pipe$lhs)\n          if (length(tmp_name) == 1) {\n            upd_output("df_name",  deparse(tmp_name))\n          } else if (is.null(tmp_name)) {\n            upd_output("df_name", deparse(calls$pipe$lhs))\n          }\n        } else {\n          upd_output("df_name", deparse(calls$with$data))\n        }\n      } else {\n        upd_output("df_name", setdiff(as.character(calls$with$data), oper)[1])\n      }\n      upd_output("df_label", label(x))\n      if (isTRUE(do_return)) {\n        return(output)\n      }\n      \n      if ("x" %in% names(calls$with$expr)) {\n        if (is.call(calls$with$expr$x)) {\n          v_name <- c(x = deparse(pryr::standardise_call(calls$with$expr$x)$x),\n                      y = deparse(pryr::standardise_call(calls$with$expr$x)$y))\n        } else {\n          v_name <- c(x = deparse(calls$with$expr$x),\n                      y = deparse(calls$with$expr$y))\n        }\n        if (length(var) == 1) {\n          upd_output("var_name",  v_name[[var]])\n          upd_output("var_label", label(x[[v_name[[var]]]]))\n        } else {\n          upd_output("var_name", v_name, force = TRUE)\n          upd_output("var_label", NA_character_)\n        }\n      } else if ("data" %in% names(calls$with$expr)) {\n        calls$with$expr$data <- pryr::standardise_call(calls$with$expr$data)\n        if ("x" %in% names(calls$with$expr$data)) {\n          v_name <- c(x = deparse(calls$with$expr$data$x),\n                      y = deparse(calls$with$expr$data$y))\n          if (length(var) == 1) {\n            upd_output("var_name",  v_name[[var]])\n            upd_output("var_label", label(x[[v_name[[var]]]]))\n          } else {\n            upd_output("var_name", v_name, force = TRUE)\n            upd_output("var_label", NA_character_)\n          }\n        }\n      }\n      if (isTRUE(do_return)) {\n        return(output)\n      }\n    }\n  }\n\n  # in the call stack: %>% -----------------------------------------------------\n  if ("pipe" %in% names(calls)) {\n    calls$pipe <- pryr::standardise_call(calls$pipe)\n    # obj_name <- deparse(calls$pipe$lhs)\n    # obj_name <- sub(paste0(caller, "\\\\((.+)\\\\)"), "\\\\1", obj_name)\n    obj_expr <- get_lhs(calls$pipe)\n    obj_name <- deparse(obj_expr)\n    obj_str  <- as.character(obj_expr)\n    obj      <- eval(obj_expr, \n                     envir = sys_frames[[pos$pipe]]$parent)\n    if (is.data.frame(obj)) {\n      upd_output("df_label", label(obj))\n      if (ncol(obj) == 1) {\n        upd_output("var_name", names(obj))\n        upd_output("var_label", label(obj[[1]]))\n      }\n      if (length(setdiff(obj_str, c(caller, oper))) == 1) {\n        upd_output("df_name", setdiff(obj_str, c(caller, oper)))\n      } else if (length(setdiff(obj_str, c(caller, oper))) == 2) {\n        upd_output("df_name", setdiff(obj_str, oper)[1])\n        upd_output("var_name", setdiff(obj_str, oper)[2])\n      }\n    } else {\n      parse_data_str(obj_name)\n    }\n    if (isTRUE(do_return)) {\n      return(output)\n    }\n  }\n\n  # in the call stack: %>>% ----------------------------------------------------\n  if ("piper" %in% names(calls)) {\n    # Get "last x" to have dataframe name\n    x_expr   <- get_last_x(calls$piper)\n    #x_name   <- deparse(x_expr)\n    x_str    <- as.character(x_expr)\n    \n    # Get object to get to the variables\n    obj      <- eval(pryr::standardise_call(calls$piper)$x, \n                     envir = sys_frames[[pos$piper]]$envir)\n    if (is.data.frame(obj)) {\n      upd_output("df_label", label(obj))\n      if (ncol(obj) == 1) {\n        upd_output("var_name", colnames(obj))\n        upd_output("var_label", label(obj[[1]]))\n      }\n      if (length(x_str <- setdiff(x_str, c(caller, oper))) == 1) {\n        upd_output("df_name", x_str)\n      } else if (length(x_str) == 2) {\n        upd_output("df_name", x_str[1])\n        upd_output("var_name", x_str[2])\n      }\n    } else {\n      # obj is a vector or factor\n      upd_output("var_label", label(obj))\n      if (length(x_str <- setdiff(x_str, c(caller, oper, ""))) == 1) {\n        upd_output("df_name", x_str)\n      } else if (length(x_str) == 2) {\n        upd_output("df_name", x_str[1])\n        vnum <- suppressWarnings(as.numeric(x_str[2]))\n        if (!is.na(vnum)) {\n          obj_df <- get_object(name = x_str[1], "data.frame")\n          if (vnum <= ncol(obj_df)) {\n            upd_output("var_name", colnames(obj_df)[vnum])\n          }\n        } else {\n          upd_output("var_name", x_str[2])\n        }\n      }\n    }\n    if (isTRUE(do_return)) {\n      return(output)\n    }\n  }\n  \n  # in the call stack: lapply() ------------------------------------------------\n  if ("lapply" %in% names(calls)) {\n    try(calls$lapply <- pryr::standardise_call(calls$lapply[-4]))\n        \n    iter <- sys_frames[[pos$lapply]]$i\n    obj  <- sys_frames[[pos$lapply]]$X[iter]\n    \n    if (is.atomic(obj[[1]])) {\n      v_name <- names(obj)\n      \n      # Find the data frame\n      df_nm <- setdiff(all.names(calls$lapply$X), oper)[1]\n      df_     <- get_object(df_nm, "data.frame")\n      if (identical(df_, NA)) {\n        env <- try(pryr::where(df_nm))\n        if (!inherits(env, "try-error")) {\n          df_ <- get(df_nm, envir = env)\n        }\n      }\n      if (is.data.frame(df_) && v_name %in% colnames(df_)) {\n        upd_output("var_name",  paste(df_nm, v_name, sep = "$"))\n        upd_output("var_label", label(df_[[v_name]]))\n        upd_output("df_name",   NA_character_)\n        upd_output("df_label",  NA_character_)\n      }\n    } else if (is.data.frame(obj[[1]])) {\n      df_nm <- names(obj)\n      upd_output("df_name",   df_nm)\n      upd_output("df_label",  label(obj))\n      upd_output("var_name",  NA_character_)\n      upd_output("var_label", NA_character_)\n    }\n    \n    if (isTRUE(do_return)) {\n      return(output)\n    }\n  }  \n      \n  if ("fun" %in% names(calls)) {\n    calls$fun <- pryr::standardise_call(calls$fun)\n    obj2 <- sys_frames[[pos$fun]][[var]]\n    if (is.data.frame(obj2)) {\n      if (length(calls$fun[[var]]) == 1) {\n        upd_output("df_name",   deparse(calls$fun[[var]]))\n        upd_output("df_label",  label(obj2))\n        upd_output("var_name",  NA_character_)\n        upd_output("var_label", NA_character_)\n      } else {\n        parse_data_str(paste(deparse(calls$fun[[var]]), collapse = " "))\n      }\n    } else if (is.atomic(obj2)) {\n      if (length(calls$fun[[var]]) == 1) {\n        if (all(c("x", "var") %in% names(calls[["fun"]]))) {\n          if (deparse(calls[["fun"]]$x) != ".") {\n            upd_output("df_name", deparse(calls[["fun"]]$x))\n          }\n          try(upd_output("df_label", label(eval(calls[["fun"]]$x))),\n              silent = TRUE)\n          if (length(calls[["fun"]]$var) == 1) {\n            upd_output("var_name", deparse(calls[["fun"]]$var))\n            upd_output("var_label", label(obj2))\n          } else {\n            if (exists("obj") && is.data.frame(obj)) {\n              v_ind <-\n                which(as.character(calls[["fun"]]$var) %in% colnames(obj))\n              if (length(v_ind) == 1) {\n                upd_output("var_name", as.character(calls[["fun"]]$var)[v_ind])\n              } else {\n                if (grepl(".+\\\\(.+\\\\)", deparse(calls[["fun"]]$var))) {\n                  upd_output("var_name", sub("^.+\\\\((.*?)\\\\)+$", "\\\\1", \n                                             deparse(calls[["fun"]]$var)))\n                } else {\n                  upd_output("var_name", NA_character_)\n                }\n              }\n            }\n          }\n        } else {\n          upd_output("var_name",  deparse(calls$fun[[var]]))\n          upd_output("var_label", label(obj2))\n          upd_output("df_name",   NA_character_)\n          upd_output("df_label",  NA_character_)\n        }\n      } else {\n        parse_data_str(deparse(calls$fun[[var]]))\n      }\n    }\n  }\n  \n  empty_elements <- as.numeric(\n    which(vapply(output, function(x) {identical(x, NA_character_) || \n        length(x) == 0}, TRUE))\n  )\n  \n  if (length(empty_elements) > 0) {\n    output <- output[-empty_elements]\n  }\n  return(output)\n}\n'