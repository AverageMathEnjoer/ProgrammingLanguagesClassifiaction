b'{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE GADTs #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n\nmodule Hoodle.Type.Coroutine where\n\nimport Control.Concurrent (MVar)\nimport Control.Error.Util (hoistEither)\nimport Control.Lens ((%~), (.~), (^.))\nimport Control.Monad (void)\nimport Control.Monad.Reader (ReaderT (..))\nimport Control.Monad.State (gets, modify, runStateT)\nimport Control.Monad.Trans (lift, liftIO)\nimport Control.Monad.Trans.Crtn (CrtnErr (Other), request, (<==|))\nimport qualified Control.Monad.Trans.Crtn.Driver as D\nimport Control.Monad.Trans.Crtn.Logger (writeLog)\nimport Control.Monad.Trans.Crtn.Object\n  ( Arg (..),\n    CObjT,\n    EStT,\n    Res (Ign, Res),\n    SObjBT,\n    SObjT,\n  )\nimport Control.Monad.Trans.Crtn.Queue\n  ( bqueue,\n    emptyQueue,\n    enqueue,\n    fqueue,\n  )\nimport Control.Monad.Trans.Crtn.World (WorldOp (FlushLog, FlushQueue, GiveEvent))\nimport Control.Monad.Trans.Except (runExceptT)\nimport Hoodle.Type.Event (AllEvent, mkIOaction)\nimport Hoodle.Type.HoodleState\n  ( HoodleState,\n    tempLog,\n    tempQueue,\n  )\nimport Hoodle.Util (errorlog)\n\n-- |\ndata MainOp i o where\n  DoEvent :: MainOp AllEvent ()\n\ndoEvent :: (Monad m) => AllEvent -> CObjT MainOp m ()\ndoEvent ev = void $ request (Arg DoEvent ev)\n\n-- |\ntype MainCoroutine = MainObjB\n\ntype MainObjB = SObjBT MainOp (EStT HoodleState WorldObjB)\n\n-- |\ntype MainObj = SObjT MainOp (EStT HoodleState WorldObjB)\n\n-- |\ntype WorldObj = SObjT (WorldOp AllEvent DriverB) DriverB\n\n-- |\ntype WorldObjB = SObjBT (WorldOp AllEvent DriverB) DriverB\n\n-- |\nworld :: HoodleState -> MainObj () -> WorldObj ()\nworld xstate initmc = ReaderT staction\n  where\n    staction req = void (runStateT erract xstate)\n      where\n        erract = do\n          r <- runExceptT (go initmc req)\n          case r of\n            Left e -> liftIO (errorlog (show e))\n            Right _r\' -> return ()\n    go ::\n      MainObj () ->\n      Arg (WorldOp AllEvent DriverB) ->\n      EStT HoodleState WorldObjB ()\n    go mcobj (Arg GiveEvent ev) = do\n      Right mcobj\' <- fmap (fmap fst) (mcobj <==| doEvent ev)\n      req <- lift . lift $ request (Res GiveEvent ())\n      go mcobj\' req\n    go mcobj (Arg FlushLog logobj) = do\n      logf <- gets (^. tempLog)\n      let msg = logf ""\n      if (not . null) msg\n        then do\n          Right logobj\' <- lift . lift . lift $ fmap (fmap fst) (logobj <==| writeLog msg)\n          modify (tempLog .~ id)\n          req <- lift . lift $ request (Res FlushLog logobj\')\n          go mcobj req\n        else do\n          req <- lift . lift $ request Ign\n          go mcobj req\n    go mcobj (Arg FlushQueue ()) = do\n      q <- gets (^. tempQueue)\n      let lst = fqueue q ++ reverse (bqueue q)\n      modify (tempQueue .~ emptyQueue)\n      req <- lift . lift $ request (Res FlushQueue lst)\n      go mcobj req\n\n-- |\ntype Driver a = D.Driver AllEvent IO a\n\n-- |\ntype DriverB = SObjBT (D.DrvOp AllEvent) IO\n\n-- |\ntype EventVar = MVar (Maybe (Driver ()))\n\n-- |\nmaybeError :: String -> Maybe a -> MainCoroutine a\nmaybeError str = maybe (lift . hoistEither . Left . Other $ str) return\n\n-- |\ndoIOaction :: ((AllEvent -> IO ()) -> IO AllEvent) -> MainCoroutine ()\ndoIOaction action = modify (tempQueue %~ enqueue (mkIOaction action))\n'