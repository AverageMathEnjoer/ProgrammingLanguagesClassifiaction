b'#\' Frequency Tables for Factors and Other Discrete Data\n#\'\n#\' Displays weighted or unweighted frequencies, including <NA> counts and\n#\' proportions.\n#\'\n#\' @param x Factor, vector, or data frame.\n#\' @param var Optional unquoted variable name. Provides support for piped\n#\'   function calls (e.g. \\code{my_df \\%>\\% freq(my_var)}). \n#\' @param round.digits Numeric. Number of significant digits to display. \n#\'   Defaults to \\code{2}. Can be set globally with \\code{\\link{st_options}}.\n#\' @param order Character. Ordering of rows in frequency table; \\dQuote{name}\n#\'   (default for non-factors), \\dQuote{level} (default for factors), or \\dQuote{freq} (from\n#\'   most frequent to less frequent). To invert the order, place a minus sign\n#\'   before or after the word. \\dQuote{-freq} will thus display the items\n#\'   starting from the lowest in frequency to the highest, and so forth.\n#\' @param style Character. Style to be used by \\code{\\link[pander]{pander}}. One\n#\'   of \\dQuote{simple} (default), \\dQuote{grid}, \\dQuote{rmarkdown}, or\n#\'   \\dQuote{jira}. Can be set globally with \\code{\\link{st_options}}.\n#\' @param plain.ascii Logical. \\code{\\link[pander]{pander}} argument; when\n#\'   \\code{TRUE}, no markup characters will be used (useful when printing to\n#\'   console). Defaults to \\code{TRUE} unless \\code{style = \'rmarkdown\'}, in\n#\'   which case it will be set to \\code{FALSE} automatically. Can be set\n#\'   globally with \\code{\\link{st_options}}.\n#\' @param justify String indicating alignment of columns. By default\n#\'   (\\dQuote{default}), \\dQuote{right} is used for text tables and\n#\'   \\dQuote{center} is used for \\emph{html} tables. You can force it to one of\n#\'   \\dQuote{left}, \\dQuote{center}, or \\dQuote{right}.\n#\' @param cumul Logical. Set to \\code{FALSE} to hide cumulative proportions\n#\'  from results. \\code{TRUE} by default. To change this value globally, see \n#\'   \\code{\\link{st_options}}.\n#\' @param totals Logical. Set to \\code{FALSE} to hide totals from results. \n#\'   \\code{TRUE} by default. To change this value globally, see \n#\'   \\code{\\link{st_options}}.\n#\' @param report.nas Logical. Set to \\code{FALSE} to turn off reporting of\n#\'   missing values. To change this default value globally, see\n#\'   \\code{\\link{st_options}}.\n#\' @param rows Character or numeric vector allowing subsetting of the results.\n#\'   The order given here will be reflected in the resulting table. If a single\n#\'   string is used, it will be used as a regular expression to filter row \n#\'   names.\n#\' @param missing Characters to display in NA cells. Defaults to \\dQuote{}.\n#\' @param display.type Logical. Should variable type be displayed? Default is\n#\'   \\code{TRUE}.\n#\' @param display.labels Logical. Should variable / data frame labels be\n#\'   displayed? Default is \\code{TRUE}. To change this default value globally,\n#\'   see \\code{\\link{st_options}}.\n#\' @param headings Logical. Set to \\code{FALSE} to omit heading section. Can be\n#\'   set globally via \\code{\\link{st_options}}.\n#\' @param weights Vector of weights; must be of the same length as \\code{x}.\n#\' @param rescale.weights Logical parameter. When set to \\code{TRUE}, the total\n#\'   count will be the same as the unweighted \\code{x}. \\code{FALSE} by default.\n#\' @param \\dots Additional arguments passed to \\code{\\link[pander]{pander}}.\n#\'\n#\' @return A frequency table of class \\code{matrix} and \\code{summarytools} with\n#\'   added attributes used by \\emph{print} method.\n#\'\n#\' @details The default \\code{plain.ascii = TRUE} option is there to make\n#\'   results appear cleaner in the console. To avoid rmarkdown rendering\n#\'   problems, this option is automatically set to \\code{FALSE} whenever\n#\'   \\code{style = "rmarkdown"} (unless \\code{plain.ascii = TRUE} is made\n#\'   explicit in the function call).\n#\'\n#\' @note The data type represents the \\code{\\link[base]{class}} in most cases. \n#\'\n#\' @examples\n#\' data(tobacco)\n#\' freq(tobacco$gender)\n#\' freq(tobacco$gender, totals = FALSE)\n#\' \n#\' # Ignore NA\'s, don\'t show totals, omit headings\n#\' freq(tobacco$gender, report.nas = FALSE, totals = FALSE, headings = FALSE)\n#\' \n#\' # In .Rmd documents, use the two following arguments, minimally\n#\' freq(tobacco$gender, style="rmarkdown", plain.ascii = FALSE)\n#\' \n#\' # Grouped Frequencies\n#\' with(tobacco, stby(diseased, smoker, freq))\n#\' (fr_smoker_by_gender <- with(tobacco, stby(smoker, gender, freq)))\n#\' \n#\' # Print html Source\n#\' print(fr_smoker_by_gender, method = "render", footnote = NA)\n#\' \n#\' # Order by frequency (+ to -)\n#\' freq(tobacco$age.gr, order = "freq")\n#\' \n#\' # Order by frequency (- to +)\n#\' freq(tobacco$age.gr, order = "-freq")\n#\' \n#\' # Use the \'rows\' argument to display only the 10 most common items\n#\' freq(tobacco$age.gr, order = "freq", rows = 1:10)\n#\' \n#\' \\dontrun{\n#\' # Display rendered html results in RStudio\'s Viewer\n#\' # notice \'view()\' is NOT written with capital V\n#\' # If working outside RStudio, Web browser is used instead\n#\' # A temporary file is stored in temp dir\n#\' view(fr_smoker_by_gender)\n#\' \n#\' # Display rendered html results in default Web browser\n#\' # A temporary file is stored in temp dir here too\n#\' print(fr_smoker_by_gender, method = "browser")\n#\' \n#\' # Write results to text file (.txt, .md, .Rmd) or html file (.html)\n#\' print(fr_smoker_by_gender, method = "render", file = "fr_smoker_by_gender.md)\n#\' print(fr_smoker_by_gender, method = "render", file = "fr_smoker_by_gender.html)\n#\' }\n#\' \n#\' @seealso \\code{\\link[base]{table}}\n#\'\n#\' @keywords univar classes category\n#\' @author Dominic Comtois, \\email{dominic.comtois@@gmail.com}\n#\' @export\n#\' @importFrom stats xtabs\n#\' @importFrom dplyr n_distinct group_keys group_vars\n#\' @importFrom lubridate is.Date\nfreq <- function(x,\n                 var             = NULL,\n                 round.digits    = st_options("round.digits"),\n                 order           = "default",\n                 style           = st_options("style"),\n                 plain.ascii     = st_options("plain.ascii"),\n                 justify         = "default",\n                 cumul           = st_options("freq.cumul"),\n                 totals          = st_options("freq.totals"),\n                 report.nas      = st_options("freq.report.nas"),\n                 rows            = numeric(),\n                 missing         = "",\n                 display.type    = TRUE,\n                 display.labels  = st_options("display.labels"),\n                 headings        = st_options("headings"),\n                 weights         = NA,\n                 rescale.weights = FALSE,\n                 ...) {\n\n  # Initialize flag_by variable that will be set in the args validation function\n  flag_by <- logical()\n  \n  # handle objects of class "grouped_df" (dplyr::group_by)\n  if (inherits(x, "grouped_df")) {\n    \n    if ("var" %in% names(match.call())) {\n      # var might contain a function call -- such as df %>% freq(na.omit(var1))\n      if (inherits(as.list(match.call()[-1])$var, "call")) {\n        var_obj <- eval(as.list(match.call()[-1])$var, envir = x)\n        varname <- intersect(colnames(x), \n                             as.character(as.list(match.call()[-1])$var))\n      } else {\n        var_obj <- x[[as.list(match.call()[-1])$var]]\n        varname <- deparse(substitute(var))\n      }\n    } else {\n      if (ncol(x) > ncol(group_keys(x)) + 1) {\n        stop("when using group_by() with freq(), only one categorical variable ",\n             "may be analyzed; the number of grouping variables however is not ",\n             "limited by any technical constraints")\n      } else if (ncol(x) < ncol(group_keys(x)) + 1) {\n        stop("the number of variables passed to freq() must equal the number ",\n             "of grouping variables + 1")\n      }\n      \n      var_obj <- x[[setdiff(colnames(x), group_vars(x))]]\n      varname <- setdiff(colnames(x), group_vars(x))\n    }\n    \n    parse_info <- try(\n      parse_args(sys.calls(), sys.frames(), match.call(), \n                 df_name = TRUE, df_label = FALSE, var_name = FALSE,\n                 var_label = FALSE, caller = "freq"),\n      silent = TRUE)\n    \n    outlist  <- list()\n    gr_ks    <- map_groups(group_keys(x))\n    gr_inds  <- attr(x, "groups")$.rows\n\n    if ("weights" %in% names(match.call())) {\n      weights_str <- deparse(substitute(weights))\n      weights_all <- parent.frame()$.[[weights_str]]\n    }\n    \n    for (g in seq_along(gr_ks)) {\n      if ("weights" %in% names(match.call())) {\n        weights <- weights_all[gr_inds[[g]]]\n      }\n      \n      outlist[[g]] <- freq(x               = var_obj[gr_inds[[g]]],\n                           round.digits    = round.digits,\n                           order           = order,\n                           style           = style,\n                           plain.ascii     = plain.ascii,\n                           justify         = justify,\n                           cumul           = cumul,\n                           totals          = totals,\n                           report.nas      = report.nas,\n                           rows            = rows,\n                           missing         = missing,\n                           display.type    = display.type,\n                           display.labels  = display.labels,\n                           headings        = headings,\n                           weights         = weights,\n                           rescale.weights = rescale.weights,\n                           ...             = ... )\n      \n      if (!inherits(parse_info, "try-error") && !is.null(parse_info$df_name)) {\n        attr(outlist[[g]], "data_info")$Data.frame <- parse_info$df_name\n      }\n      \n      if (exists("weights_str")) {\n        attr(outlist[[g]], "data_info")$Weights <- weights_str\n      }\n      \n      if (!is.na(label(x))) {\n        attr(outlist[[g]], "data_info")$Data.frame.label <- label(x)\n      }\n      \n      attr(outlist[[g]], "data_info")$Variable <- varname\n      \n      if (!is.na(label(x[[varname]]))) {\n        attr(outlist[[g]], "data_info")$Variable.label <- label(x[[varname]])\n      }\n      \n      attr(outlist[[g]], "data_info")$by_var   <- group_vars(x)\n      attr(outlist[[g]], "data_info")$Group    <- gr_ks[g]\n      attr(outlist[[g]], "data_info")$by_first <- g == 1\n      attr(outlist[[g]], "data_info")$by_last  <- g == length(gr_ks)\n      \n      attr(outlist[[g]], "st_type") <- "freq"\n    }\n    \n    names(outlist) <- gr_ks\n    class(outlist) <- c("stby")\n    attr(outlist, "groups") <- group_keys(x)\n    return(outlist)\n  }\n  \n  # When x is a dataframe and var is not provided, we make recursive calls\n  # to freq() with each variable\n  else if (is.data.frame(x) && ncol(x) > 1 && \n           !"var" %in% names(match.call())) {\n    \n    # Get information about x from parsing function\n    parse_info <- try(parse_args(sys.calls(), sys.frames(), match.call(),\n                                 silent = TRUE, var_name = FALSE,\n                                 var_label = FALSE,\n                                 caller = "freq"),\n                      silent = TRUE)\n    \n    if (inherits(parse_info, "try-error") || !length(parse_info)) {\n      parse_info <- list()\n      df_name <- deparse(substitute(x))\n    } else {\n      df_name <- parse_info$df_name\n    }\n    \n    out <- list()\n    ignored <- character()\n    for (i in seq_along(x)) {\n      if (!class(x[[i]]) %in% c("character", "factor") &&\n          n_distinct(x[[i]]) > st_options("freq.ignore.threshold")) {\n        ignored %+=% names(x)[i] \n        next \n      }\n      \n      out[[length(out) + 1]] <- \n        freq(x[[i]],\n             round.digits     = round.digits,\n             order            = order,\n             style            = style,\n             plain.ascii      = plain.ascii,\n             justify          = justify,\n             cumul            = cumul,\n             totals           = totals,\n             report.nas       = report.nas,\n             rows             = rows,\n             missing          = missing,\n             display.type     = display.type,\n             display.labels   = display.labels,\n             headings         = headings,\n             weights          = weights,\n             rescale.weights  = rescale.weights,\n             ...)\n      \n      attr(out[[length(out)]], "data_info")$Data.frame <- df_name\n      attr(out[[length(out)]], "data_info")$Variable   <- colnames(x)[i]\n      if (!is.na(label(x[[i]]))) {\n        attr(out[[length(out)]], "data_info")$Variable.label <- label(x[[i]])\n      }\n\n      if (length(out) == 1) {\n        attr(out[[length(out)]], "format_info")$var.only <- FALSE\n      } else {\n        attr(out[[length(out)]], "format_info")$var.only <- TRUE\n      }\n      \n      if (length(ignored) > 0) {\n        attr(out, "ignored") <- ignored\n      }\n    }\n    class(out) <- c("list", "summarytools")\n    return(out)\n  }\n  \n  else {\n    # Simple call (no iteration needed, or call from higher-level iteration)    \n    if ("var" %in% names(match.call())) {\n      dfname <- as.character(substitute(x))\n      if (inherits(as.list(match.call()[-1])$var, "name")) {\n        x <- x[[as.list(match.call()[-1])$var]]\n        varname <- deparse(substitute(var))\n      } else if (inherits(as.list(match.call()[-1])$var, "call")) {\n        varname <- tail(all.names(as.list(match.call()[-1])$var), 1)\n        x <- x[[varname]]\n      }\n    }\n    \n    # if x is a data.frame with 1 column, extract this column as x\n    if (!is.null(ncol(x)) && ncol(x) == 1) {\n      varname <- colnames(x)\n      x <- x[[1]]\n    }\n    \n    # Validate arguments -------------------------------------------------------\n    errmsg <- character()  # problems with arguments will be stored in here\n    \n    if (!is.atomic(x)) {\n      x <- try(as.vector(x), silent = TRUE)\n      if (inherits(x, "try-error") || (!is.atomic(x) && !is.Date(x))) {\n        errmsg %+=% "argument x must be a vector or a factor"\n      }\n    }\n    \n    order_sign <- "+"\n    errmsg <- c(errmsg, check_args(match.call(), list(...)))\n    \n    if (length(errmsg) > 0) {\n      stop(paste(errmsg, collapse = "\\n  "))\n    }\n    \n    # End of arguments validation ----------------------------------------------\n    \n    # When style = "rmarkdown", make plain.ascii FALSE unless explicit\n    if (style == "rmarkdown" && isTRUE(plain.ascii) && \n        !("plain.ascii" %in% (names(match.call())))) {\n      if (!isTRUE(st_options("freq.silent"))) {\n        message("setting plain.ascii to FALSE")\n      }\n      plain.ascii <- FALSE\n    }\n    \n    # Replace NaN\'s by NA\'s (This simplifies matters a lot)\n    if (NaN %in% x)  {\n      if (isFALSE(st_options("freq.silent"))) {\n        message(paste(sum(is.nan(x)), "NaN value(s) converted to NA\\n"))\n      }\n      x[is.nan(x)] <- NA\n    }\n    \n    # Get information about x from parsing function\n    parse_info <- try(\n      parse_args(sys.calls(), sys.frames(), match.call(),\n                 silent = exists("varname", inherits = FALSE),\n                 caller = "freq"),\n      silent = TRUE)\n    \n    if (inherits(parse_info, "try-error")) {\n      parse_info <- list()\n    }\n    \n    if (!("var_name" %in% names(parse_info)) && exists("varname")) {\n      parse_info$var_name <- varname\n    }\n    \n    if (!("df_name" %in% names(parse_info)) && exists("dfname")) {\n      parse_info$df_name <- dfname\n    }\n    \n    if (!"var_label" %in% names(parse_info) && !is.na(label(x))) {\n      parse_info$var_label <- label(x)\n    }\n    \n    # create a basic frequency table, always including NA ----------------------\n    if (identical(NA, weights)) {\n      freq_table <- table(x, useNA = "always")\n    } else {\n      # Weights are used\n      weights_string <- deparse(substitute(weights))\n      \n      # Subset weights when called from by()/stby() to match current data subset\n      if (isTRUE(flag_by)) {\n        pf <- parent.frame(2)\n        weights <- weights[pf$X[[pf$i]]]\n      }\n      \n      if (sum(is.na(weights)) > 0) {\n        warning("missing values on weight variable have been detected and ",\n                "were treated as zeroes")\n        weights[is.na(weights)] <- 0\n      }\n      \n      if (isTRUE(rescale.weights)) {\n        weights <- weights / sum(weights) * length(x)\n      }\n      \n      freq_table <- xtabs(formula = weights ~ x, addNA = TRUE)\n      if (!NA %in% names(freq_table)) {\n        freq_table <- c(freq_table, "<NA>" = 0)\n      }\n    }\n    \n    # Order by [-]freq if needed\n    if (order == "freq") {\n      nas_freq   <- tail(freq_table, 1)\n      freq_table <- freq_table[-length(freq_table)]\n      freq_table <- sort(freq_table, decreasing = (order_sign == "+"))\n      freq_table <- append(freq_table, nas_freq)\n    }\n    \n    # order by [-]name if needed\n    if (order == "name") {\n      freq_table <- freq_table[order(names(freq_table), \n                                     decreasing = (order_sign == "-"), \n                                     na.last = TRUE)]\n    }\n    \n    # order by [-]level if needed\n    if (is.factor(x) && order == "level" && order_sign == "-") {\n      freq_table <- c(freq_table[rev(levels(x))], tail(freq_table, 1))\n    }\n    \n    if (is.character(rows) && length(rows) == 1) {\n      # Use string as regular expression to filter rows\n      rr <- grep(rows, names(freq_table))\n      if (length(rr) == 0) {\n        stop("\'rows\' argument doesn\'t match any data")\n      }\n      \n      freq_table <- c(freq_table[rr], tail(freq_table, 1))\n      \n    } else if (length(rows) > 0) {\n      if (is.character(rows)) { \n        if (length(rows) < n_distinct(x)) {\n          freq_table <- \n            c(freq_table[rows], \n              "(Other)" = sum(freq_table[setdiff(na.omit(names(freq_table)), rows)]),\n              tail(freq_table, 1))\n        } else {\n          freq_table <- c(freq_table[rows], tail(freq_table, 1))\n        }\n      } else if (is.numeric(rows)) {\n        if (sign(rows[1]) == 1) {\n          if (length(rows) < n_distinct(x, na.rm = TRUE)) {\n            freq_table <- \n              c(freq_table[rows], \n                "(Other)" = sum(freq_table[setdiff(seq_along(freq_table[-1]), \n                                                   rows)]),\n                tail(freq_table, 1))\n          } else {\n            freq_table <- c(freq_table[rows], tail(freq_table, 1))\n          }\n        } else {\n          ind_other <- intersect(seq_along(freq_table[-1]), abs(rows))\n          freq_table <- c(freq_table[c(rows, -length(freq_table))],\n                          "(Other)" = sum(freq_table[ind_other]),\n                          tail(freq_table, 1))\n        }\n      }\n    }\n    \n    # Change the name of the NA item (last) to avoid potential\n    # problems when echoing to console\n    names(freq_table)[length(freq_table)] <- "<NA>"\n    \n    # calculate proportions (valid, i.e excluding NA\'s)\n    P_valid <- prop.table(freq_table[-length(freq_table)]) * 100\n    \n    # Add "<NA>" item to the proportions; this assures\n    # proper length when cbind\'ing later on\n    P_valid["<NA>"] <- NA\n    \n    # calculate proportions (total, i.e. including NA\'s)\n    P_tot <- prop.table(freq_table) * 100\n    \n    # Calculate cumulative proportions -----------------------------------------\n    \n    P_valid_cum <- cumsum(P_valid)\n    P_valid_cum["<NA>"] <- NA\n    P_tot_cum <- cumsum(P_tot)\n    \n    # Combine the info to build the final frequency table ----------------------\n    \n    output <- cbind(freq_table, P_valid, P_valid_cum, P_tot, P_tot_cum)\n    output <- rbind(output, c(colSums(output, na.rm = TRUE)[1:2], rep(100,3)))\n    colnames(output) <- c(trs("freq"), trs("pct.valid.f"), trs("pct.valid.cum"), \n                          trs("pct.total"), trs("pct.total.cum"))\n    rownames(output) <- c(ws_to_symbol(names(freq_table)), trs("total"))\n    rownames(output)[rownames(output) == ""] <- \n      paste0("(", trs("empty.str"), ")")\n    \n    # NA\'s explicited with forcats::fct_explicit_na(): set report.nas to FALSE\n    # unless report.nas was explicit in the function call\n    fn_call <- match.call()\n    \n    if (is.factor(x) && "(Missing)" %in% levels(x)\n        && sum(is.na(x)) == 0 && isTRUE(report.nas)) {\n      if (isFALSE(st_options("freq.silent"))) {\n        message("explicit NA\'s detected - temporarily setting \'report.nas\' to FALSE")\n      }\n      report.nas <- FALSE\n      # hack the fn_call attribute to prevent print method from overriding it \n      tmp_args <- append(as.list(fn_call)[-1], list(report.nas = FALSE))\n      if (length(tmp_narm <- which(names(tmp_args) == "report.nas")) == 2) {\n        tmp_args <- tmp_args[-tmp_narm[1]]\n      }\n      tmp_args <- append(list(name = "freq"), tmp_args)\n      fn_call  <- do.call(what = "call", args = tmp_args, quote = TRUE)\n    }\n    \n    # Update the output class and attributes -----------------------------------\n    \n    class(output) <- c("summarytools", class(output))\n    \n    attr(output, "st_type") <- "freq"\n    attr(output, "fn_call") <- fn_call\n    attr(output, "date")    <- Sys.Date()\n    \n    # Determine data "type", in a non-strict way\n    if (all(c("ordered", "factor") %in% class(x))) {\n      Data.type <- trs("factor.ordered")\n    } else if ("factor" %in% class(x)) {\n      Data.type <- trs("factor")\n    } else if (all(c("POSIXct", "POSIXt") %in% class(x))) { \n      Data.type <- trs("datetime")\n    } else if ("Date" %in% class(x)) {\n      Data.type <- trs("date")\n    } else if ("logical" %in% class(x)) {\n      Data.type <- trs("logical")\n    } else if ("character" %in% class(x)) {\n      Data.type <- trs("character")\n    } else if ("integer" %in% class(x)) {\n      Data.type <- trs("integer")\n    } else if ("numeric" %in% class(x)) {\n      Data.type <- trs("numeric")\n    } else {\n      Data.type <- ifelse(mode(x) %in% rownames(.keywords_context),\n                          trs(mode(x)), mode(x))\n    }\n    \n    data_info <-\n      list(\n        Data.frame       = ifelse("df_name" %in% names(parse_info), \n                                  parse_info$df_name, NA),\n        Data.frame.label = ifelse("df_label" %in% names(parse_info), \n                                  parse_info$df_label, NA),\n        Variable         = ifelse("var_name" %in% names(parse_info), \n                                  parse_info$var_name, NA),\n        Variable.label   = ifelse("var_label" %in% names(parse_info), \n                                  parse_info$var_label, NA),\n        Data.type        = Data.type,\n        Weights          = ifelse(\n          identical(weights, NA), NA,\n          ifelse(is.null(parse_info$df_name), \n                 yes = weights_string,\n                 no = sub(\n                   pattern = paste0(parse_info$df_name,\n                                    "$"), \n                   replacement = "",\n                   x = weights_string, \n                   fixed = TRUE))),\n        Group            = ifelse("by_group" %in% names(parse_info),\n                                  parse_info$by_group, NA),\n        by_first         = ifelse("by_group" %in% names(parse_info), \n                                  parse_info$by_first, NA),\n        by_last          = ifelse("by_group" %in% names(parse_info), \n                                  parse_info$by_last , NA))\n    \n    attr(output, "data_info") <- data_info[!is.na(data_info)]\n    \n    attr(output, "format_info") <- list(style          = style,\n                                        round.digits   = round.digits,\n                                        plain.ascii    = plain.ascii,\n                                        justify        = justify,\n                                        cumul          = cumul,\n                                        totals         = totals,\n                                        report.nas     = report.nas,\n                                        missing        = missing,\n                                        display.type   = display.type,\n                                        display.labels = display.labels,\n                                        headings       = headings,\n                                        split.tables   = Inf)\n    \n    attr(output, "user_fmt") <- list(... = ...)\n    \n    attr(output, "lang") <- st_options("lang")\n    \n    return(output)\n    \n  }\n}\n'