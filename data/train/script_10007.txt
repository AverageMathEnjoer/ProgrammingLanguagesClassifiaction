b'using System;\nusing System.Diagnostics;\nusing HANDLE = System.IntPtr;\n\nnamespace CS_SQLite3\n{\n  public partial class CSSQLite\n  {\n    /*\n    ** 2006 June 7\n    **\n    ** The author disclaims copyright to this source code.  In place of\n    ** a legal notice, here is a blessing:\n    **\n    **    May you do good and not evil.\n    **    May you find forgiveness for yourself and forgive others.\n    **    May you share freely, never taking more than you give.\n    **\n    *************************************************************************\n    ** This file contains code used to dynamically load extensions into\n    ** the SQLite library.\n    **\n    ** $Id: loadext.c,v 1.60 2009/06/03 01:24:54 drh Exp $\n    **\n    *************************************************************************\n    **  Included in SQLite3 port to C#-SQLite;  2008 Noah B Hart\n    **  C#-SQLite is an independent reimplementation of the SQLite software library\n    **\n    **  $Header$\n    *************************************************************************\n    */\n\n#if !SQLITE_CORE\n    //#define SQLITE_CORE 1  /* Disable the API redefinition in sqlite3ext.h */\n    const int SQLITE_CORE = 1;\n#endif\n    //#include "sqlite3ext.h"\n    //#include "sqliteInt.h"\n    //#include <string.h>\n\n#if !SQLITE_OMIT_LOAD_EXTENSION\n\n    /*\n** Some API routines are omitted when various features are\n** excluded from a build of SQLite.  Substitute a NULL pointer\n** for any missing APIs.\n*/\n#if !SQLITE_ENABLE_COLUMN_METADATA\n    //# define sqlite3_column_database_name   0\n    //# define sqlite3_column_database_name16 0\n    //# define sqlite3_column_table_name      0\n    //# define sqlite3_column_table_name16    0\n    //# define sqlite3_column_origin_name     0\n    //# define sqlite3_column_origin_name16   0\n    //# define sqlite3_table_column_metadata  0\n#endif\n\n#if SQLITE_OMIT_AUTHORIZATION\n    //# define sqlite3_set_authorizer         0\n#endif\n\n#if SQLITE_OMIT_UTF16\n    //# define sqlite3_bind_text16            0\n    //# define sqlite3_collation_needed16     0\n    //# define sqlite3_column_decltype16      0\n    //# define sqlite3_column_name16          0\n    //# define sqlite3_column_text16          0\n    //# define sqlite3_complete16             0\n    //# define sqlite3_create_collation16     0\n    //# define sqlite3_create_function16      0\n    //# define sqlite3_errmsg16               0\n    static string sqlite3_errmsg16( sqlite3 db ) { return ""; }\n    //# define sqlite3_open16                 0\n    //# define sqlite3_prepare16              0\n    //# define sqlite3_prepare16_v2           0\n    //# define sqlite3_result_error16         0\n    //# define sqlite3_result_text16          0\n    static void sqlite3_result_text16( sqlite3_context pCtx, string z, int n, dxDel xDel ) { }\n    //# define sqlite3_result_text16be        0\n    //# define sqlite3_result_text16le        0\n    //# define sqlite3_value_text16           0\n    //# define sqlite3_value_text16be         0\n    //# define sqlite3_value_text16le         0\n    //# define sqlite3_column_database_name16 0\n    //# define sqlite3_column_table_name16    0\n    //# define sqlite3_column_origin_name16   0\n#endif\n\n#if SQLITE_OMIT_COMPLETE\n//# define sqlite3_complete 0\n//# define sqlite3_complete16 0\n#endif\n\n#if SQLITE_OMIT_PROGRESS_CALLBACK\n//# define sqlite3_progress_handler 0\nstatic void sqlite3_progress_handler (sqlite3 db,       int nOps, dxProgress xProgress, object pArg){}\n#endif\n\n#if SQLITE_OMIT_VIRTUALTABLE\n    //# define sqlite3_create_module 0\n    //# define sqlite3_create_module_v2 0\n    //# define sqlite3_declare_vtab 0\n#endif\n\n#if SQLITE_OMIT_SHARED_CACHE\n    //# define sqlite3_enable_shared_cache 0\n#endif\n\n#if SQLITE_OMIT_TRACE\n//# define sqlite3_profile       0\n//# define sqlite3_trace         0\n#endif\n\n#if SQLITE_OMIT_GET_TABLE\n    //# define //sqlite3_free_table    0\n    //# define sqlite3_get_table     0\n    public static int sqlite3_get_table(\n    sqlite3 db,             /* An open database */\n    string zSql,            /* SQL to be evaluated */\n    ref string[] pazResult, /* Results of the query */\n    ref int pnRow,          /* Number of result rows written here */\n    ref int pnColumn,       /* Number of result columns written here */\n    ref string pzErrmsg     /* Error msg written here */\n    ) { return 0; }\n#endif\n\n#if SQLITE_OMIT_INCRBLOB\n    //#define sqlite3_bind_zeroblob  0\n    //#define sqlite3_blob_bytes     0\n    //#define sqlite3_blob_close     0\n    //#define sqlite3_blob_open      0\n    //#define sqlite3_blob_read      0\n    //#define sqlite3_blob_write     0\n#endif\n\n    /*\n** The following structure contains pointers to all SQLite API routines.\n** A pointer to this structure is passed into extensions when they are\n** loaded so that the extension can make calls back into the SQLite\n** library.\n**\n** When adding new APIs, add them to the bottom of this structure\n** in order to preserve backwards compatibility.\n**\n** Extensions that use newer APIs should first call the\n** sqlite3_libversion_number() to make sure that the API they\n** intend to use is supported by the library.  Extensions should\n** also check to make sure that the pointer to the function is\n** not NULL before calling it.\n*/\n    static sqlite3_api_routines sqlite3Apis = new sqlite3_api_routines();\n    //{\n    //  sqlite3_aggregate_context,\n#if !SQLITE_OMIT_DEPRECATED\n    /  sqlite3_aggregate_count,\n#else\n//  0,\n#endif\n    //  sqlite3_bind_blob,\n    //  sqlite3_bind_double,\n    //  sqlite3_bind_int,\n    //  sqlite3_bind_int64,\n    //  sqlite3_bind_null,\n    //  sqlite3_bind_parameter_count,\n    //  sqlite3_bind_parameter_index,\n    //  sqlite3_bind_parameter_name,\n    //  sqlite3_bind_text,\n    //  sqlite3_bind_text16,\n    //  sqlite3_bind_value,\n    //  sqlite3_busy_handler,\n    //  sqlite3_busy_timeout,\n    //  sqlite3_changes,\n    //  sqlite3_close,\n    //  sqlite3_collation_needed,\n    //  sqlite3_collation_needed16,\n    //  sqlite3_column_blob,\n    //  sqlite3_column_bytes,\n    //  sqlite3_column_bytes16,\n    //  sqlite3_column_count,\n    //  sqlite3_column_database_name,\n    //  sqlite3_column_database_name16,\n    //  sqlite3_column_decltype,\n    //  sqlite3_column_decltype16,\n    //  sqlite3_column_double,\n    //  sqlite3_column_int,\n    //  sqlite3_column_int64,\n    //  sqlite3_column_name,\n    //  sqlite3_column_name16,\n    //  sqlite3_column_origin_name,\n    //  sqlite3_column_origin_name16,\n    //  sqlite3_column_table_name,\n    //  sqlite3_column_table_name16,\n    //  sqlite3_column_text,\n    //  sqlite3_column_text16,\n    //  sqlite3_column_type,\n    //  sqlite3_column_value,\n    //  sqlite3_commit_hook,\n    //  sqlite3_complete,\n    //  sqlite3_complete16,\n    //  sqlite3_create_collation,\n    //  sqlite3_create_collation16,\n    //  sqlite3_create_function,\n    //  sqlite3_create_function16,\n    //  sqlite3_create_module,\n    //  sqlite3_data_count,\n    //  sqlite3_db_handle,\n    //  sqlite3_declare_vtab,\n    //  sqlite3_enable_shared_cache,\n    //  sqlite3_errcode,\n    //  sqlite3_errmsg,\n    //  sqlite3_errmsg16,\n    //  sqlite3_exec,\n#if !SQLITE_OMIT_DEPRECATED\n    //sqlite3_expired,\n#else\n//0,\n#endif\n    //  sqlite3_finalize,\n    //  //sqlite3_free,\n    //  //sqlite3_free_table,\n    //  sqlite3_get_autocommit,\n    //  sqlite3_get_auxdata,\n    //  sqlite3_get_table,\n    //  0,     /* Was sqlite3_global_recover(), but that function is deprecated */\n    //  sqlite3_interrupt,\n    //  sqlite3_last_insert_rowid,\n    //  sqlite3_libversion,\n    //  sqlite3_libversion_number,\n    //  sqlite3_malloc,\n    //  sqlite3_mprintf,\n    //  sqlite3_open,\n    //  sqlite3_open16,\n    //  sqlite3_prepare,\n    //  sqlite3_prepare16,\n    //  sqlite3_profile,\n    //  sqlite3_progress_handler,\n    //  sqlite3_realloc,\n    //  sqlite3_reset,\n    //  sqlite3_result_blob,\n    //  sqlite3_result_double,\n    //  sqlite3_result_error,\n    //  sqlite3_result_error16,\n    //  sqlite3_result_int,\n    //  sqlite3_result_int64,\n    //  sqlite3_result_null,\n    //  sqlite3_result_text,\n    //  sqlite3_result_text16,\n    //  sqlite3_result_text16be,\n    //  sqlite3_result_text16le,\n    //  sqlite3_result_value,\n    //  sqlite3_rollback_hook,\n    //  sqlite3_set_authorizer,\n    //  sqlite3_set_auxdata,\n    //  sqlite3_snprintf,\n    //  sqlite3_step,\n    //  sqlite3_table_column_metadata,\n#if !SQLITE_OMIT_DEPRECATED\n    //sqlite3_thread_cleanup,\n#else\n//  0,\n#endif\n    //  sqlite3_total_changes,\n    //  sqlite3_trace,\n#if !SQLITE_OMIT_DEPRECATED\n    //sqlite3_transfer_bindings,\n#else\n//  0,\n#endif\n    //  sqlite3_update_hook,\n    //  sqlite3_user_data,\n    //  sqlite3_value_blob,\n    //  sqlite3_value_bytes,\n    //  sqlite3_value_bytes16,\n    //  sqlite3_value_double,\n    //  sqlite3_value_int,\n    //  sqlite3_value_int64,\n    //  sqlite3_value_numeric_type,\n    //  sqlite3_value_text,\n    //  sqlite3_value_text16,\n    //  sqlite3_value_text16be,\n    //  sqlite3_value_text16le,\n    //  sqlite3_value_type,\n    //  sqlite3_vmprintf,\n    //  /*\n    //  ** The original API set ends here.  All extensions can call any\n    //  ** of the APIs above provided that the pointer is not NULL.  But\n    //  ** before calling APIs that follow, extension should check the\n    //  ** sqlite3_libversion_number() to make sure they are dealing with\n    //  ** a library that is new enough to support that API.\n    //  *************************************************************************\n    //  */\n    //  sqlite3_overload_function,\n\n    //  /*\n    //  ** Added after 3.3.13\n    //  */\n    //  sqlite3_prepare_v2,\n    //  sqlite3_prepare16_v2,\n    //  sqlite3_clear_bindings,\n\n    //  /*\n    //  ** Added for 3.4.1\n    //  */\n    //  sqlite3_create_module_v2,\n\n    //  /*\n    //  ** Added for 3.5.0\n    //  */\n    //  sqlite3_bind_zeroblob,\n    //  sqlite3_blob_bytes,\n    //  sqlite3_blob_close,\n    //  sqlite3_blob_open,\n    //  sqlite3_blob_read,\n    //  sqlite3_blob_write,\n    //  sqlite3_create_collation_v2,\n    //  sqlite3_file_control,\n    //  sqlite3_memory_highwater,\n    //  sqlite3_memory_used,\n#if SQLITE_MUTEX_OMIT\n    //  0,\n    //  0,\n    //  0,\n    //  0,\n    //  0,\n#else\n//  sqlite3MutexAlloc,\n//  sqlite3_mutex_enter,\n//  sqlite3_mutex_free,\n//  sqlite3_mutex_leave,\n//  sqlite3_mutex_try,\n#endif\n    //  sqlite3_open_v2,\n    //  sqlite3_release_memory,\n    //  sqlite3_result_error_nomem,\n    //  sqlite3_result_error_toobig,\n    //  sqlite3_sleep,\n    //  sqlite3_soft_heap_limit,\n    //  sqlite3_vfs_find,\n    //  sqlite3_vfs_register,\n    //  sqlite3_vfs_unregister,\n\n    //  /*\n    //  ** Added for 3.5.8\n    //  */\n    //  sqlite3_threadsafe,\n    //  sqlite3_result_zeroblob,\n    //  sqlite3_result_error_code,\n    //  sqlite3_test_control,\n    //  sqlite3_randomness,\n    //  sqlite3_context_db_handle,\n\n    //  /*\n    //  ** Added for 3.6.0\n    //  */\n    //  sqlite3_extended_result_codes,\n    //  sqlite3_limit,\n    //  sqlite3_next_stmt,\n    //  sqlite3_sql,\n    //  sqlite3_status,\n    //};\n\n    /*\n    ** Attempt to load an SQLite extension library contained in the file\n    ** zFile.  The entry point is zProc.  zProc may be 0 in which case a\n    ** default entry point name (sqlite3_extension_init) is used.  Use\n    ** of the default name is recommended.\n    **\n    ** Return SQLITE_OK on success and SQLITE_ERROR if something goes wrong.\n    **\n    ** If an error occurs and pzErrMsg is not 0, then fill pzErrMsg with\n    ** error message text.  The calling function should free this memory\n    ** by calling //sqlite3DbFree(db, ).\n    */\n    static int sqlite3LoadExtension(\n    sqlite3 db,           /* Load the extension into this database connection */\n    string zFile,         /* Name of the shared library containing extension */\n    string zProc,         /* Entry point.  Use "sqlite3_extension_init" if 0 */\n    ref string pzErrMsg   /* Put error message here if not 0 */\n    )\n    {\n      sqlite3_vfs pVfs = db.pVfs;\n      HANDLE handle;\n      dxInit xInit; //int (*xInit)(sqlite3*,char**,const sqlite3_api_routines*);\n      string zErrmsg = "";\n      //object aHandle;\n      const int nMsg = 300;\n      if ( pzErrMsg != null ) pzErrMsg = null;\n\n\n      /* Ticket #1863.  To avoid a creating security problems for older\n      ** applications that relink against newer versions of SQLite, the\n      ** ability to run load_extension is turned off by default.  One\n      ** must call sqlite3_enable_load_extension() to turn on extension\n      ** loading.  Otherwise you get the following error.\n      */\n      if ( ( db.flags & SQLITE_LoadExtension ) == 0 )\n      {\n        //if( pzErrMsg != null){\n        pzErrMsg = sqlite3_mprintf( "not authorized" );\n        //}\n        return SQLITE_ERROR;\n      }\n\n      if ( zProc == null || zProc == "" )\n      {\n        zProc = "sqlite3_extension_init";\n      }\n\n      handle = sqlite3OsDlOpen( pVfs, zFile );\n      if ( handle == IntPtr.Zero )\n      {\n        //    if( pzErrMsg ){\n        zErrmsg = "";//zErrmsg = sqlite3StackAllocZero(db, nMsg);\n        //if( zErrmsg !=null){\n        sqlite3_snprintf( nMsg, ref zErrmsg,\n        "unable to open shared library [%s]", zFile );\n        sqlite3OsDlError( pVfs, nMsg - 1, ref zErrmsg );\n        pzErrMsg = zErrmsg;// sqlite3DbStrDup( 0, zErrmsg );\n        //sqlite3StackFree( db, zErrmsg );\n        //}\n        return SQLITE_ERROR;\n      }\n      //xInit = (int(*)(sqlite3*,char**,const sqlite3_api_routines*))\n      //                 sqlite3OsDlSym(pVfs, handle, zProc);\n      xInit = (dxInit)sqlite3OsDlSym( pVfs, handle, ref  zProc );\n      Debugger.Break(); // TODO --\n      //if( xInit==0 ){\n      //  if( pzErrMsg ){\n      //    zErrmsg = sqlite3StackAllocZero(db, nMsg);\n      //    if( zErrmsg ){\n      //      sqlite3_snprintf(nMsg, zErrmsg,\n      //          "no entry point [%s] in shared library [%s]", zProc,zFile);\n      //      sqlite3OsDlError(pVfs, nMsg-1, zErrmsg);\n      //      *pzErrMsg = sqlite3DbStrDup(0, zErrmsg);\n      //      //sqlite3StackFree(db, zErrmsg);\n      //    }\n      //    sqlite3OsDlClose(pVfs, handle);\n      //  }\n      //  return SQLITE_ERROR;\n      //  }else if( xInit(db, ref zErrmsg, sqlite3Apis) ){\n      ////    if( pzErrMsg !=null){\n      //      pzErrMsg = sqlite3_mprintf("error during initialization: %s", zErrmsg);\n      //    //}\n      //    //sqlite3DbFree(db,ref zErrmsg);\n      //    sqlite3OsDlClose(pVfs, ref handle);\n      //    return SQLITE_ERROR;\n      //  }\n\n      //  /* Append the new shared library handle to the db.aExtension array. */\n      //  aHandle = sqlite3DbMallocZero(db, sizeof(handle)*db.nExtension+1);\n      //  if( aHandle==null ){\n      //    return SQLITE_NOMEM;\n      //  }\n      //  if( db.nExtension>0 ){\n      //    memcpy(aHandle, db.aExtension, sizeof(handle)*(db.nExtension));\n      //  }\n      //  //sqlite3DbFree(db,ref db.aExtension);\n      //  db.aExtension = aHandle;\n\n      //  db.aExtension[db.nExtension++] = handle;\n      return SQLITE_OK;\n    }\n\n    public static int sqlite3_load_extension(\n    sqlite3 db,          /* Load the extension into this database connection */\n    string zFile,        /* Name of the shared library containing extension */\n    string zProc,        /* Entry point.  Use "sqlite3_extension_init" if 0 */\n    ref string pzErrMsg  /* Put error message here if not 0 */\n    )\n    {\n      int rc;\n      sqlite3_mutex_enter( db.mutex );\n      rc = sqlite3LoadExtension( db, zFile, zProc, ref pzErrMsg );\n      rc = sqlite3ApiExit( db, rc );\n      sqlite3_mutex_leave( db.mutex );\n      return rc;\n    }\n\n    /*\n    ** Call this routine when the database connection is closing in order\n    ** to clean up loaded extensions\n    */\n    static void sqlite3CloseExtensions( sqlite3 db )\n    {\n      int i;\n      Debug.Assert( sqlite3_mutex_held( db.mutex ) );\n      for ( i = 0 ; i < db.nExtension ; i++ )\n      {\n        sqlite3OsDlClose( db.pVfs, (HANDLE)db.aExtension[i] );\n      }\n      //sqlite3DbFree( db, ref db.aExtension );\n    }\n\n    /*\n    ** Enable or disable extension loading.  Extension loading is disabled by\n    ** default so as not to open security holes in older applications.\n    */\n    public static int sqlite3_enable_load_extension( sqlite3 db, int onoff )\n    {\n      sqlite3_mutex_enter( db.mutex );\n      if ( onoff != 0 )\n      {\n        db.flags |= SQLITE_LoadExtension;\n      }\n      else\n      {\n        db.flags &= ~SQLITE_LoadExtension;\n      }\n      sqlite3_mutex_leave( db.mutex );\n      return SQLITE_OK;\n    }\n\n#endif //* SQLITE_OMIT_LOAD_EXTENSION */\n\n    /*\n** The auto-extension code added regardless of whether or not extension\n** loading is supported.  We need a dummy sqlite3Apis pointer for that\n** code if regular extension loading is not available.  This is that\n** dummy pointer.\n*/\n#if SQLITE_OMIT_LOAD_EXTENSION\nconst sqlite3_api_routines sqlite3Apis = null;\n#endif\n\n\n    /*\n** The following object holds the list of automatically loaded\n** extensions.\n**\n** This list is shared across threads.  The SQLITE_MUTEX_STATIC_MASTER\n** mutex must be held while accessing this list.\n*/\n    //typedef struct sqlite3AutoExtList sqlite3AutoExtList;\n    public class sqlite3AutoExtList\n    {\n      public int nExt = 0;            /* Number of entries in aExt[] */\n      public dxInit[] aExt = null;    /* Pointers to the extension init functions */\n      public sqlite3AutoExtList( int nExt, dxInit[] aExt ) { this.nExt = nExt; this.aExt = aExt; }\n    }\n    static sqlite3AutoExtList sqlite3Autoext = new sqlite3AutoExtList( 0, null );\n    /* The "wsdAutoext" macro will resolve to the autoextension\n    ** state vector.  If writable static data is unsupported on the target,\n    ** we have to locate the state vector at run-time.  In the more common\n    ** case where writable static data is supported, wsdStat can refer directly\n    ** to the "sqlite3Autoext" state vector declared above.\n    */\n#if SQLITE_OMIT_WSD\n//# define wsdAutoextInit \\\nsqlite3AutoExtList *x = &GLOBAL(sqlite3AutoExtList,sqlite3Autoext)\n//# define wsdAutoext x[0]\n#else\n    //# define wsdAutoextInit\n    static void wsdAutoextInit() { }\n    //# define wsdAutoext sqlite3Autoext\n    static sqlite3AutoExtList wsdAutoext = sqlite3Autoext;\n#endif\n\n    /*\n** Register a statically linked extension that is automatically\n** loaded by every new database connection.\n*/\n    static int sqlite3_auto_extension( dxInit xInit )\n    {\n      int rc = SQLITE_OK;\n#if !SQLITE_OMIT_AUTOINIT\n      rc = sqlite3_initialize();\n      if ( rc != 0 )\n      {\n        return rc;\n      }\n      else\n#endif\n      {\n        int i;\n#if SQLITE_THREADSAFE\nsqlite3_mutex mutex = sqlite3MutexAlloc( SQLITE_MUTEX_STATIC_MASTER );\n#else\n        sqlite3_mutex mutex = sqlite3MutexAlloc( SQLITE_MUTEX_STATIC_MASTER ); // Need this since mutex_enter & leave are not MACROS under C#\n#endif\n        wsdAutoextInit();\n        sqlite3_mutex_enter( mutex );\n        for ( i = 0 ; i < wsdAutoext.nExt ; i++ )\n        {\n          if ( wsdAutoext.aExt[i] == xInit ) break;\n        }\n        //if( i==wsdAutoext.nExt ){\n        //  int nByte = (wsdAutoext.nExt+1)*sizeof(wsdAutoext.aExt[0]);\n        //  void **aNew;\n        //  aNew = sqlite3_realloc(wsdAutoext.aExt, nByte);\n        //  if( aNew==0 ){\n        //    rc = SQLITE_NOMEM;\n        //  }else{\n        Array.Resize( ref wsdAutoext.aExt, wsdAutoext.nExt + 1 );//        wsdAutoext.aExt = aNew;\n        wsdAutoext.aExt[wsdAutoext.nExt] = xInit;\n        wsdAutoext.nExt++;\n        //}\n        sqlite3_mutex_leave( mutex );\n        Debug.Assert( ( rc & 0xff ) == rc );\n        return rc;\n      }\n    }\n\n    /*\n    ** Reset the automatic extension loading mechanism.\n    */\n    static void sqlite3_reset_auto_extension()\n    {\n#if !SQLITE_OMIT_AUTOINIT\n      if ( sqlite3_initialize() == SQLITE_OK )\n#endif\n      {\n#if SQLITE_THREADSAFE\nsqlite3_mutex mutex = sqlite3MutexAlloc( SQLITE_MUTEX_STATIC_MASTER );\n#else\n        sqlite3_mutex mutex = sqlite3MutexAlloc( SQLITE_MUTEX_STATIC_MASTER ); // Need this since mutex_enter & leave are not MACROS under C#\n#endif\n        wsdAutoextInit();\n        sqlite3_mutex_enter( mutex );\n#if SQLITE_OMIT_WSD\n//sqlite3_free( ref wsdAutoext.aExt );\nwsdAutoext.aExt = null;\nwsdAutoext.nExt = 0;\n#else\n        //sqlite3_free( ref sqlite3Autoext.aExt );\n        sqlite3Autoext.aExt = null;\n        sqlite3Autoext.nExt = 0;\n#endif\n        sqlite3_mutex_leave( mutex );\n      }\n    }\n\n    /*\n    ** Load all automatic extensions.\n    **\n    ** If anything goes wrong, set an error in the database connection.\n    */\n    static void sqlite3AutoLoadExtensions( sqlite3 db )\n    {\n      int i;\n      bool go = true;\n      dxInit xInit;//)(sqlite3*,char**,const sqlite3_api_routines*);\n\n      wsdAutoextInit();\n#if SQLITE_OMIT_WSD\nif ( wsdAutoext.nExt == 0 )\n#else\n      if ( sqlite3Autoext.nExt == 0 )\n#endif\n      {\n        /* Common case: early out without every having to acquire a mutex */\n        return;\n      }\n      for ( i = 0 ; go ; i++ )\n      {\n        string zErrmsg = "";\n#if SQLITE_THREADSAFE\nsqlite3_mutex mutex = sqlite3MutexAlloc( SQLITE_MUTEX_STATIC_MASTER );\n#else\n        sqlite3_mutex mutex = sqlite3MutexAlloc( SQLITE_MUTEX_STATIC_MASTER ); // Need this since mutex_enter & leave are not MACROS under C#\n#endif\n        sqlite3_mutex_enter( mutex );\n        if ( i >= wsdAutoext.nExt )\n        {\n          xInit = null;\n          go = false;\n        }\n        else\n        {\n          xInit = (dxInit)\n          wsdAutoext.aExt[i];\n        }\n        sqlite3_mutex_leave( mutex );\n        zErrmsg = "";\n        if ( xInit != null && xInit( db, ref zErrmsg, (sqlite3_api_routines)sqlite3Apis ) != 0 )\n        {\n          sqlite3Error( db, SQLITE_ERROR,\n          "automatic extension loading failed: %s", zErrmsg );\n          go = false;\n        }\n        //sqlite3DbFree( db, ref zErrmsg );\n      }\n    }\n  }\n}\n\n'