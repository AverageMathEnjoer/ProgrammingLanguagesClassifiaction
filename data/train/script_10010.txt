b'{-# LANGUAGE NoImplicitPrelude #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n{-# LANGUAGE OverloadedStrings #-}\n{-# LANGUAGE RebindableSyntax #-}\n\nmodule Course.JsonParser where\n\nimport Course.Core\nimport Course.Parser\nimport Course.MoreParser\nimport Course.JsonValue\nimport Course.Functor\nimport Course.Applicative\nimport Course.Monad\nimport Course.List\nimport Course.Optional\n\n-- $setup\n-- >>> :set -XOverloadedStrings\n\n-- A special character is one of the following:\n-- * \\b  Backspace (ascii code 08)\n-- * \\f  Form feed (ascii code 0C)\n-- * \\n  New line\n-- * \\r  Carriage return\n-- * \\t  Tab\n-- * \\v  Vertical tab\n-- * \\\'  Apostrophe or single quote (only valid in single quoted json strings)\n-- * \\"  Double quote (only valid in double quoted json strings)\n-- * \\\\  Backslash character\ndata SpecialCharacter =\n  BackSpace\n  | FormFeed\n  | NewLine\n  | CarriageReturn\n  | Tab\n  | VerticalTab\n  | SingleQuote\n  | DoubleQuote\n  | Backslash\n  deriving (Eq, Ord, Show)\n\n-- NOTE: This is not inverse to @toSpecialCharacter@.\nfromSpecialCharacter ::\n  SpecialCharacter\n  -> Char\nfromSpecialCharacter BackSpace =\n  chr 0x08\nfromSpecialCharacter FormFeed =\n  chr 0x0C\nfromSpecialCharacter NewLine =\n  \'\\n\'\nfromSpecialCharacter CarriageReturn =\n  \'\\r\'\nfromSpecialCharacter Tab =\n  \'\\t\'\nfromSpecialCharacter VerticalTab =\n  \'\\v\'\nfromSpecialCharacter SingleQuote =\n  \'\\\'\'\nfromSpecialCharacter DoubleQuote =\n  \'"\'\nfromSpecialCharacter Backslash =\n  \'\\\\\'\n\n-- NOTE: This is not inverse to @fromSpecialCharacter@.\ntoSpecialCharacter ::\n  Char\n  -> Optional SpecialCharacter\ntoSpecialCharacter c =\n  let table = (\'b\', BackSpace) :.\n              (\'f\', FormFeed) :.\n              (\'n\', NewLine) :.\n              (\'r\', CarriageReturn) :.\n              (\'t\', Tab) :.\n              (\'v\', VerticalTab) :.\n              (\'\\\'\', SingleQuote) :.\n              (\'"\' , DoubleQuote) :.\n              (\'\\\\\', Backslash) :.\n              Nil\n  in snd <$> find ((==) c . fst) table\n  \n-- | Parse a JSON string. Handle double-quotes, special characters, hexadecimal characters. See http://json.org for the full list of control characters in JSON.\n--\n-- /Tip:/ Use `hex`, `fromSpecialCharacter`, `between`, `is`, `charTok`, `toSpecialCharacter`.\n--\n-- >>> parse jsonString "\\" abc\\""\n-- Result >< " abc"\n--\n-- >>> parse jsonString "\\"abc\\"def"\n-- Result >def< "abc"\n--\n-- >>> parse jsonString "\\"\\\\babc\\"def"\n-- Result >def< "\\babc"\n--\n-- >>> parse jsonString "\\"\\\\u00abc\\"def"\n-- Result >def< "\\171c"\n--\n-- >>> parse jsonString "\\"\\\\u00ffabc\\"def"\n-- Result >def< "\\255abc"\n--\n-- >>> parse jsonString "\\"\\\\u00faabc\\"def"\n-- Result >def< "\\250abc"\n--\n-- >>> isErrorResult (parse jsonString "abc")\n-- True\n--\n-- >>> isErrorResult (parse jsonString "\\"\\\\abc\\"def")\n-- True\njsonString ::\n  Parser Chars\njsonString =\n  error "todo: Course.JsonParser#jsonString"\n\n-- | Parse a JSON rational.\n--\n-- /Tip:/ Use @readFloats@.\n--\n-- >>> parse jsonNumber "234"\n-- Result >< 234 % 1\n--\n-- >>> parse jsonNumber "-234"\n-- Result >< (-234) % 1\n--\n-- >>> parse jsonNumber "123.45"\n-- Result >< 2469 % 20\n--\n-- >>> parse jsonNumber "-123"\n-- Result >< (-123) % 1\n--\n-- >>> parse jsonNumber "-123.45"\n-- Result >< (-2469) % 20\n--\n-- >>> isErrorResult (parse jsonNumber "-")\n-- True\n--\n-- >>> isErrorResult (parse jsonNumber "abc")\n-- True\njsonNumber ::\n  Parser Rational\njsonNumber =\n  error "todo: Course.JsonParser#jsonNumber"\n\n-- | Parse a JSON true literal.\n--\n-- /Tip:/ Use `stringTok`.\n--\n-- >>> parse jsonTrue "true"\n-- Result >< "true"\n--\n-- >>> isErrorResult (parse jsonTrue "TRUE")\n-- True\njsonTrue ::\n  Parser Chars\njsonTrue =\n  error "todo: Course.JsonParser#jsonTrue"\n\n-- | Parse a JSON false literal.\n--\n-- /Tip:/ Use `stringTok`.\n--\n-- >>> parse jsonFalse "false"\n-- Result >< "false"\n--\n-- >>> isErrorResult (parse jsonFalse "FALSE")\n-- True\njsonFalse ::\n  Parser Chars\njsonFalse =\n  error "todo: Course.JsonParser#jsonFalse"\n\n-- | Parse a JSON null literal.\n--\n-- /Tip:/ Use `stringTok`.\n--\n-- >>> parse jsonNull "null"\n-- Result >< "null"\n--\n-- >>> isErrorResult (parse jsonNull "NULL")\n-- True\njsonNull ::\n  Parser Chars\njsonNull =\n  error "todo: Course.JsonParser#jsonNull"\n\n-- | Parse a JSON array.\n--\n-- /Tip:/ Use `betweenSepbyComma` and `jsonValue`.\n--\n-- >>> parse jsonArray "[]"\n-- Result >< []\n--\n-- >>> parse jsonArray "[true]"\n-- Result >< [JsonTrue]\n--\n-- >>> parse jsonArray "[true, \\"abc\\"]"\n-- Result >< [JsonTrue,JsonString "abc"]\n--\n-- >>> parse jsonArray "[true, \\"abc\\", []]"\n-- Result >< [JsonTrue,JsonString "abc",JsonArray []]\n--\n-- >>> parse jsonArray "[true, \\"abc\\", [false]]"\n-- Result >< [JsonTrue,JsonString "abc",JsonArray [JsonFalse]]\njsonArray ::\n  Parser (List JsonValue)\njsonArray =\n  error "todo: Course.JsonParser#jsonArray"\n\n-- | Parse a JSON object.\n--\n-- /Tip:/ Use `jsonString`, `charTok`, `betweenSepbyComma` and `jsonValue`.\n--\n-- >>> parse jsonObject "{}"\n-- Result >< []\n--\n-- >>> parse jsonObject "{ \\"key1\\" : true }"\n-- Result >< [("key1",JsonTrue)]\n--\n-- >>> parse jsonObject "{ \\"key1\\" : true , \\"key2\\" : false }"\n-- Result >< [("key1",JsonTrue),("key2",JsonFalse)]\n--\n-- >>> parse jsonObject "{ \\"key1\\" : true , \\"key2\\" : false } xyz"\n-- Result >xyz< [("key1",JsonTrue),("key2",JsonFalse)]\njsonObject ::\n  Parser Assoc\njsonObject =\n  error "todo: Course.JsonParser#jsonObject"\n\n-- | Parse a JSON value.\n--\n-- /Tip:/ Use `spaces`, `jsonNull`, `jsonTrue`, `jsonFalse`, `jsonArray`, `jsonString`, `jsonObject` and `jsonNumber`.\n--\n-- >>> parse jsonValue "true"\n-- Result >< JsonTrue\n--\n-- >>> parse jsonObject "{ \\"key1\\" : true , \\"key2\\" : [7, false] }"\n-- Result >< [("key1",JsonTrue),("key2",JsonArray [JsonRational (7 % 1),JsonFalse])]\n--\n-- >>> parse jsonObject "{ \\"key1\\" : true , \\"key2\\" : [7, false] , \\"key3\\" : { \\"key4\\" : null } }"\n-- Result >< [("key1",JsonTrue),("key2",JsonArray [JsonRational (7 % 1),JsonFalse]),("key3",JsonObject [("key4",JsonNull)])]\njsonValue ::\n  Parser JsonValue\njsonValue =\n   error "todo: Course.JsonParser#jsonValue"\n\n-- | Read a file into a JSON value.\n--\n-- /Tip:/ Use @System.IO#readFile@ and `jsonValue`.\nreadJsonValue ::\n  FilePath\n  -> IO (ParseResult JsonValue)\nreadJsonValue =\n  error "todo: Course.JsonParser#readJsonValue"\n'