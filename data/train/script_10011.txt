b'/*\n* Copyright (C) 2014 The CyanogenMod Project\n*\n* Licensed under the Apache License, Version 2.0 (the "License");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n* http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an "AS IS" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\npackage com.naman14.timber.dataloaders;\n\nimport android.database.AbstractCursor;\nimport android.database.Cursor;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.HashMap;\nimport java.util.List;\n\n/**\n * This cursor basically wraps a song cursor and is given a list of the order of the ids of the\n * contents of the cursor. It wraps the Cursor and simulates the internal cursor being sorted\n * by moving the point to the appropriate spot\n */\npublic class SortedCursor extends AbstractCursor {\n    // cursor to wrap\n    private final Cursor mCursor;\n    // the map of external indices to internal indices\n    private ArrayList<Integer> mOrderedPositions;\n    // this contains the ids that weren\'t found in the underlying cursor\n    private ArrayList<Long> mMissingIds;\n    // this contains the mapped cursor positions and afterwards the extra ids that weren\'t found\n    private HashMap<Long, Integer> mMapCursorPositions;\n    // extra we want to store with the cursor\n    private ArrayList<Object> mExtraData;\n\n    /**\n     * @param cursor     to wrap\n     * @param order      the list of unique ids in sorted order to display\n     * @param columnName the column name of the id to look up in the internal cursor\n     */\n    public SortedCursor(final Cursor cursor, final long[] order, final String columnName,\n                        final List<? extends Object> extraData) {\n        if (cursor == null) {\n            throw new IllegalArgumentException("Non-null cursor is needed");\n        }\n\n        mCursor = cursor;\n        mMissingIds = buildCursorPositionMapping(order, columnName, extraData);\n    }\n\n    /**\n     * This function populates mOrderedPositions with the cursor positions in the order based\n     * on the order passed in\n     *\n     * @param order     the target order of the internal cursor\n     * @param extraData Extra data we want to add to the cursor\n     * @return returns the ids that aren\'t found in the underlying cursor\n     */\n    private ArrayList<Long> buildCursorPositionMapping(final long[] order,\n                                                       final String columnName, final List<? extends Object> extraData) {\n        ArrayList<Long> missingIds = new ArrayList<Long>();\n\n        mOrderedPositions = new ArrayList<Integer>(mCursor.getCount());\n        mExtraData = new ArrayList<Object>();\n\n        mMapCursorPositions = new HashMap<Long, Integer>(mCursor.getCount());\n        final int idPosition = mCursor.getColumnIndex(columnName);\n\n        if (mCursor.moveToFirst()) {\n            // first figure out where each of the ids are in the cursor\n            do {\n                mMapCursorPositions.put(mCursor.getLong(idPosition), mCursor.getPosition());\n            } while (mCursor.moveToNext());\n\n            // now create the ordered positions to map to the internal cursor given the\n            // external sort order\n            for (int i = 0; order != null && i < order.length; i++) {\n                final long id = order[i];\n                if (mMapCursorPositions.containsKey(id)) {\n                    mOrderedPositions.add(mMapCursorPositions.get(id));\n                    mMapCursorPositions.remove(id);\n                    if (extraData != null) {\n                        mExtraData.add(extraData.get(i));\n                    }\n                } else {\n                    missingIds.add(id);\n                }\n            }\n\n            mCursor.moveToFirst();\n        }\n\n        return missingIds;\n    }\n\n    /**\n     * @return the list of ids that weren\'t found in the underlying cursor\n     */\n    public ArrayList<Long> getMissingIds() {\n        return mMissingIds;\n    }\n\n    /**\n     * @return the list of ids that were in the underlying cursor but not part of the ordered list\n     */\n    public Collection<Long> getExtraIds() {\n        return mMapCursorPositions.keySet();\n    }\n\n    /**\n     * @return the extra object data that was passed in to be attached to the current row\n     */\n    public Object getExtraData() {\n        int position = getPosition();\n        return position < mExtraData.size() ? mExtraData.get(position) : null;\n    }\n\n    @Override\n    public void close() {\n        mCursor.close();\n\n        super.close();\n    }\n\n    @Override\n    public int getCount() {\n        return mOrderedPositions.size();\n    }\n\n    @Override\n    public String[] getColumnNames() {\n        return mCursor.getColumnNames();\n    }\n\n    @Override\n    public String getString(int column) {\n        return mCursor.getString(column);\n    }\n\n    @Override\n    public short getShort(int column) {\n        return mCursor.getShort(column);\n    }\n\n    @Override\n    public int getInt(int column) {\n        return mCursor.getInt(column);\n    }\n\n    @Override\n    public long getLong(int column) {\n        return mCursor.getLong(column);\n    }\n\n    @Override\n    public float getFloat(int column) {\n        return mCursor.getFloat(column);\n    }\n\n    @Override\n    public double getDouble(int column) {\n        return mCursor.getDouble(column);\n    }\n\n    @Override\n    public boolean isNull(int column) {\n        return mCursor.isNull(column);\n    }\n\n    @Override\n    public boolean onMove(int oldPosition, int newPosition) {\n        if (newPosition >= 0 && newPosition < getCount()) {\n            mCursor.moveToPosition(mOrderedPositions.get(newPosition));\n            return true;\n        }\n\n        return false;\n    }\n}\n'