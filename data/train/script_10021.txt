b"{-# LANGUAGE PolyKinds #-}\n\n-- | Finally tagless encoding of SQL92 syntax\nmodule Database.Beam.Backend.SQL.SQL92 where\n\nimport Database.Beam.Backend.SQL.Types\nimport Database.Beam.Backend.SQL.Row\n\nimport Data.Int\nimport Data.Kind (Type)\nimport Data.Tagged\nimport Data.Text (Text)\nimport Data.Time (LocalTime)\nimport Data.Typeable\n\n-- * Finally tagless style\n\nclass HasSqlValueSyntax expr ty where\n  sqlValueSyntax :: ty -> expr\n\nautoSqlValueSyntax :: (HasSqlValueSyntax expr String, Show a) => a -> expr\nautoSqlValueSyntax = sqlValueSyntax . show\n\ntype Sql92SelectExpressionSyntax select = Sql92SelectTableExpressionSyntax (Sql92SelectSelectTableSyntax select)\ntype Sql92SelectProjectionSyntax select = Sql92SelectTableProjectionSyntax (Sql92SelectSelectTableSyntax select)\ntype Sql92SelectGroupingSyntax select = Sql92SelectTableGroupingSyntax (Sql92SelectSelectTableSyntax select)\ntype Sql92SelectFromSyntax select = Sql92SelectTableFromSyntax (Sql92SelectSelectTableSyntax select)\ntype Sql92InsertExpressionSyntax select = Sql92InsertValuesExpressionSyntax (Sql92InsertValuesSyntax select)\ntype Sql92TableNameSyntax select = Sql92TableSourceTableNameSyntax (Sql92FromTableSourceSyntax (Sql92SelectFromSyntax select))\n\ntype Sql92ValueSyntax cmdSyntax = Sql92ExpressionValueSyntax (Sql92ExpressionSyntax cmdSyntax)\ntype Sql92ExpressionSyntax cmdSyntax = Sql92SelectExpressionSyntax (Sql92SelectSyntax cmdSyntax)\ntype Sql92ExtractFieldSyntax cmdSyntax = Sql92ExpressionExtractFieldSyntax (Sql92ExpressionSyntax cmdSyntax)\ntype Sql92HasValueSyntax cmdSyntax = HasSqlValueSyntax (Sql92ValueSyntax cmdSyntax)\n\n-- Putting these in the head constraint can cause infinite recursion that would\n-- need <UndecidableSuperclasses. If we define them here, we can easily use them\n-- in functions that need them and avoid unnecessary extensions.\ntype Sql92SelectSanityCheck select =\n  ( Sql92FromExpressionSyntax (Sql92SelectTableFromSyntax (Sql92SelectSelectTableSyntax select)) ~\n    Sql92SelectTableExpressionSyntax (Sql92SelectSelectTableSyntax select)\n  , Sql92TableSourceSelectSyntax (Sql92FromTableSourceSyntax (Sql92SelectTableFromSyntax (Sql92SelectSelectTableSyntax select))) ~ select\n  , Sql92ProjectionExpressionSyntax (Sql92SelectTableProjectionSyntax (Sql92SelectSelectTableSyntax select)) ~\n    Sql92SelectTableExpressionSyntax (Sql92SelectSelectTableSyntax select)\n  , Sql92OrderingExpressionSyntax (Sql92SelectOrderingSyntax select) ~\n    Sql92SelectTableExpressionSyntax (Sql92SelectSelectTableSyntax select)\n  , Sql92TableSourceExpressionSyntax (Sql92FromTableSourceSyntax (Sql92SelectTableFromSyntax (Sql92SelectSelectTableSyntax select))) ~\n    Sql92SelectTableExpressionSyntax (Sql92SelectSelectTableSyntax select))\ntype Sql92SanityCheck cmd =\n  ( Sql92SelectSanityCheck (Sql92SelectSyntax cmd)\n  , Sql92ExpressionValueSyntax (Sql92InsertValuesExpressionSyntax (Sql92InsertValuesSyntax (Sql92InsertSyntax cmd))) ~ Sql92ValueSyntax cmd\n  , Sql92ExpressionValueSyntax (Sql92UpdateExpressionSyntax (Sql92UpdateSyntax cmd)) ~ Sql92ValueSyntax cmd\n  , Sql92ExpressionValueSyntax (Sql92DeleteExpressionSyntax (Sql92DeleteSyntax cmd)) ~ Sql92ValueSyntax cmd\n\n  , Sql92SelectTableExpressionSyntax (Sql92SelectSelectTableSyntax (Sql92SelectSyntax cmd)) ~\n    Sql92InsertValuesExpressionSyntax (Sql92InsertValuesSyntax (Sql92InsertSyntax cmd))\n\n  , Sql92SelectTableExpressionSyntax (Sql92SelectSelectTableSyntax (Sql92SelectSyntax cmd)) ~\n    Sql92UpdateExpressionSyntax (Sql92UpdateSyntax cmd)\n\n  , Sql92DeleteExpressionSyntax (Sql92DeleteSyntax cmd) ~\n    Sql92UpdateExpressionSyntax (Sql92UpdateSyntax cmd)\n\n  , Sql92ExpressionSelectSyntax (Sql92InsertExpressionSyntax (Sql92InsertSyntax cmd)) ~\n    Sql92SelectSyntax cmd\n\n  , Sql92InsertValuesSelectSyntax (Sql92InsertValuesSyntax (Sql92InsertSyntax cmd)) ~\n    Sql92SelectSyntax cmd\n\n  , Sql92UpdateFieldNameSyntax (Sql92UpdateSyntax cmd) ~\n    Sql92ExpressionFieldNameSyntax (Sql92InsertValuesExpressionSyntax (Sql92InsertValuesSyntax (Sql92InsertSyntax cmd)))\n  )\n\ntype Sql92ReasonableMarshaller be =\n   ( FromBackendRow be SqlNull\n   , FromBackendRow be Text, FromBackendRow be Bool\n   , FromBackendRow be Char\n   , FromBackendRow be Int16, FromBackendRow be Int32, FromBackendRow be Int64\n   , FromBackendRow be LocalTime )\n\n-- | Type classes for syntaxes which can be displayed\nclass Sql92DisplaySyntax syntax where\n\n  -- | Render the syntax as a 'String', representing the SQL expression it\n  -- stands for\n  displaySyntax :: syntax -> String\n\nclass ( IsSql92SelectSyntax (Sql92SelectSyntax cmd)\n      , IsSql92InsertSyntax (Sql92InsertSyntax cmd)\n      , IsSql92UpdateSyntax (Sql92UpdateSyntax cmd)\n      , IsSql92DeleteSyntax (Sql92DeleteSyntax cmd) ) =>\n  IsSql92Syntax cmd where\n  type Sql92SelectSyntax cmd :: Type\n  type Sql92InsertSyntax cmd :: Type\n  type Sql92UpdateSyntax cmd :: Type\n  type Sql92DeleteSyntax cmd :: Type\n\n  selectCmd :: Sql92SelectSyntax cmd -> cmd\n  insertCmd :: Sql92InsertSyntax cmd -> cmd\n  updateCmd :: Sql92UpdateSyntax cmd -> cmd\n  deleteCmd :: Sql92DeleteSyntax cmd -> cmd\n\nclass ( IsSql92SelectTableSyntax (Sql92SelectSelectTableSyntax select)\n      , IsSql92OrderingSyntax (Sql92SelectOrderingSyntax select) ) =>\n    IsSql92SelectSyntax select where\n    type Sql92SelectSelectTableSyntax select :: Type\n    type Sql92SelectOrderingSyntax select :: Type\n\n    selectStmt :: Sql92SelectSelectTableSyntax select\n               -> [Sql92SelectOrderingSyntax select]\n               -> Maybe Integer {-^ LIMIT -}\n               -> Maybe Integer {-^ OFFSET -}\n               -> select\n\nclass ( IsSql92ExpressionSyntax (Sql92SelectTableExpressionSyntax select)\n      , IsSql92AggregationExpressionSyntax (Sql92SelectTableExpressionSyntax select)\n      , IsSql92ProjectionSyntax (Sql92SelectTableProjectionSyntax select)\n      , IsSql92FromSyntax (Sql92SelectTableFromSyntax select)\n      , IsSql92GroupingSyntax (Sql92SelectTableGroupingSyntax select)\n      , IsSql92AggregationSetQuantifierSyntax (Sql92SelectTableSetQuantifierSyntax select)\n\n      , Sql92GroupingExpressionSyntax (Sql92SelectTableGroupingSyntax select) ~ Sql92SelectTableExpressionSyntax select\n      , Sql92FromExpressionSyntax (Sql92SelectTableFromSyntax select) ~ Sql92SelectTableExpressionSyntax select\n      , Sql92SelectSelectTableSyntax (Sql92SelectTableSelectSyntax select) ~ select\n\n      , Eq (Sql92SelectTableExpressionSyntax select) ) =>\n    IsSql92SelectTableSyntax select where\n  type Sql92SelectTableSelectSyntax select :: Type\n  type Sql92SelectTableExpressionSyntax select :: Type\n  type Sql92SelectTableProjectionSyntax select :: Type\n  type Sql92SelectTableFromSyntax select :: Type\n  type Sql92SelectTableGroupingSyntax select :: Type\n  type Sql92SelectTableSetQuantifierSyntax select :: Type\n\n  selectTableStmt :: Maybe (Sql92SelectTableSetQuantifierSyntax select)\n                  -> Sql92SelectTableProjectionSyntax select\n                  -> Maybe (Sql92SelectTableFromSyntax select)\n                  -> Maybe (Sql92SelectTableExpressionSyntax select)   {-^ Where clause -}\n                  -> Maybe (Sql92SelectTableGroupingSyntax select)\n                  -> Maybe (Sql92SelectTableExpressionSyntax select) {-^ having clause -}\n                  -> select\n\n  unionTables, intersectTables, exceptTable ::\n    Bool -> select -> select -> select\n\nclass ( IsSql92InsertValuesSyntax (Sql92InsertValuesSyntax insert)\n      , IsSql92TableNameSyntax (Sql92InsertTableNameSyntax insert) ) =>\n  IsSql92InsertSyntax insert where\n\n  type Sql92InsertValuesSyntax insert :: Type\n  type Sql92InsertTableNameSyntax insert :: Type\n\n  insertStmt :: Sql92InsertTableNameSyntax insert\n             -> [ Text ]\n             -- ^ Fields\n             -> Sql92InsertValuesSyntax insert\n             -> insert\n\nclass IsSql92ExpressionSyntax (Sql92InsertValuesExpressionSyntax insertValues) =>\n  IsSql92InsertValuesSyntax insertValues where\n  type Sql92InsertValuesExpressionSyntax insertValues :: Type\n  type Sql92InsertValuesSelectSyntax insertValues :: Type\n\n  insertSqlExpressions :: [ [ Sql92InsertValuesExpressionSyntax insertValues ] ]\n                       -> insertValues\n  insertFromSql :: Sql92InsertValuesSelectSyntax insertValues\n                -> insertValues\n\nclass ( IsSql92ExpressionSyntax (Sql92UpdateExpressionSyntax update)\n      , IsSql92FieldNameSyntax (Sql92UpdateFieldNameSyntax update)\n      , IsSql92TableNameSyntax (Sql92UpdateTableNameSyntax update) ) =>\n      IsSql92UpdateSyntax update where\n\n  type Sql92UpdateTableNameSyntax  update :: Type\n  type Sql92UpdateFieldNameSyntax  update :: Type\n  type Sql92UpdateExpressionSyntax update :: Type\n\n  updateStmt :: Sql92UpdateTableNameSyntax update\n             -> [(Sql92UpdateFieldNameSyntax update, Sql92UpdateExpressionSyntax update)]\n             -> Maybe (Sql92UpdateExpressionSyntax update) {-^ WHERE -}\n             -> update\n\nclass ( IsSql92TableNameSyntax (Sql92DeleteTableNameSyntax delete)\n      , IsSql92ExpressionSyntax (Sql92DeleteExpressionSyntax delete) ) =>\n  IsSql92DeleteSyntax delete where\n  type Sql92DeleteTableNameSyntax  delete :: Type\n  type Sql92DeleteExpressionSyntax delete :: Type\n\n  deleteStmt :: Sql92DeleteTableNameSyntax delete -> Maybe Text\n             -> Maybe (Sql92DeleteExpressionSyntax delete)\n             -> delete\n\n  -- | Whether or not the @DELETE@ command supports aliases\n  deleteSupportsAlias :: Proxy delete -> Bool\n  deleteSupportsAlias _ = False -- Delete aliases are a non-standard feature\n\nclass IsSql92FieldNameSyntax fn where\n  qualifiedField :: Text -> Text -> fn\n  unqualifiedField :: Text -> fn\n\nclass IsSql92QuantifierSyntax quantifier where\n  quantifyOverAll, quantifyOverAny :: quantifier\n\nclass IsSql92ExtractFieldSyntax extractField where\n  secondsField :: extractField\n  minutesField :: extractField\n  hourField :: extractField\n  dayField :: extractField\n  monthField :: extractField\n  yearField :: extractField\n\nclass IsSql92DataTypeSyntax dataType where\n  domainType :: Text -> dataType\n  charType :: Maybe Word -> Maybe Text -> dataType\n  varCharType :: Maybe Word -> Maybe Text -> dataType\n  nationalCharType :: Maybe Word -> dataType\n  nationalVarCharType :: Maybe Word -> dataType\n  bitType :: Maybe Word -> dataType\n  varBitType :: Maybe Word -> dataType\n  numericType :: Maybe (Word, Maybe Word) -> dataType\n  decimalType :: Maybe (Word, Maybe Word) -> dataType\n  intType :: dataType\n  smallIntType :: dataType\n  floatType :: Maybe Word -> dataType\n  doubleType :: dataType\n  realType :: dataType\n\n  dateType :: dataType\n  timeType :: Maybe Word -> Bool {-^ With time zone -} -> dataType\n  timestampType :: Maybe Word -> Bool {-^ With time zone -} -> dataType\n  -- TODO interval type\n\nclass ( HasSqlValueSyntax (Sql92ExpressionValueSyntax expr) Int32\n      , HasSqlValueSyntax (Sql92ExpressionValueSyntax expr) Bool\n      , IsSql92FieldNameSyntax (Sql92ExpressionFieldNameSyntax expr)\n      , IsSql92QuantifierSyntax (Sql92ExpressionQuantifierSyntax expr)\n      , IsSql92DataTypeSyntax (Sql92ExpressionCastTargetSyntax expr)\n      , IsSql92ExtractFieldSyntax (Sql92ExpressionExtractFieldSyntax expr)\n      , Typeable expr ) =>\n    IsSql92ExpressionSyntax expr where\n  type Sql92ExpressionQuantifierSyntax expr :: Type\n  type Sql92ExpressionValueSyntax      expr :: Type\n  type Sql92ExpressionSelectSyntax     expr :: Type\n  type Sql92ExpressionFieldNameSyntax  expr :: Type\n  type Sql92ExpressionCastTargetSyntax expr :: Type\n  type Sql92ExpressionExtractFieldSyntax expr :: Type\n\n  valueE :: Sql92ExpressionValueSyntax expr -> expr\n\n  rowE, quantifierListE, coalesceE :: [ expr ] -> expr\n  quantifierListE = rowE\n\n  caseE :: [(expr, expr)]\n        -> expr -> expr\n  fieldE :: Sql92ExpressionFieldNameSyntax expr -> expr\n\n  betweenE :: expr -> expr -> expr -> expr\n  betweenE a lower upper =\n    (gtE Nothing a lower) `andE` (ltE Nothing a upper)\n\n  andE, orE, addE, subE, mulE, divE, likeE,\n    modE, overlapsE, nullIfE, positionE\n    :: expr\n    -> expr\n    -> expr\n\n  eqE, neqE, ltE, gtE, leE, geE\n    :: Maybe (Sql92ExpressionQuantifierSyntax expr)\n    -> expr -> expr -> expr\n\n  -- | Compare the first and second argument for nullable equality, if\n  -- they are both not null, return the result of the third expression\n  --\n  -- Some backends, like @beam-postgres@ totally ignore the third\n  -- result, because all equality there is sensible.\n  eqMaybeE, neqMaybeE :: expr -> expr -> expr -> expr\n\n  eqMaybeE a b e =\n    let aIsNull = isNullE a\n        bIsNull = isNullE b\n    in caseE [ ( aIsNull `andE` bIsNull, valueE (sqlValueSyntax True) )\n             , ( aIsNull `orE` bIsNull, valueE (sqlValueSyntax False) ) ]\n             e\n\n\n  neqMaybeE a b e =\n    let aIsNull = isNullE a\n        bIsNull = isNullE b\n    in caseE [ ( aIsNull `andE` bIsNull, valueE (sqlValueSyntax False) )\n             , ( aIsNull `orE` bIsNull, valueE (sqlValueSyntax True) ) ]\n             e\n\n  castE :: expr -> Sql92ExpressionCastTargetSyntax expr -> expr\n\n  notE, negateE, isNullE, isNotNullE,\n    isTrueE, isNotTrueE, isFalseE, isNotFalseE,\n    isUnknownE, isNotUnknownE, charLengthE,\n    octetLengthE, bitLengthE,\n    lowerE, upperE,\n    trimE\n    :: expr\n    -> expr\n\n  -- | Included so that we can easily write a Num instance, but not defined in SQL92.\n  --   Implementations that do not support this, should use CASE .. WHEN ..\n  absE :: expr -> expr\n\n  extractE :: Sql92ExpressionExtractFieldSyntax expr -> expr -> expr\n\n  existsE, uniqueE, subqueryE\n    :: Sql92ExpressionSelectSyntax expr -> expr\n\n  currentTimestampE :: expr\n\n  defaultE :: expr\n\n  inE :: expr -> [ expr ] -> expr\n  inSelectE :: expr -> Sql92ExpressionSelectSyntax expr -> expr\n\ninstance HasSqlValueSyntax syntax x => HasSqlValueSyntax syntax (SqlSerial x) where\n  sqlValueSyntax (SqlSerial x) = sqlValueSyntax x\n\nclass IsSql92AggregationSetQuantifierSyntax (Sql92AggregationSetQuantifierSyntax expr) =>\n  IsSql92AggregationExpressionSyntax expr where\n\n  type Sql92AggregationSetQuantifierSyntax expr :: Type\n\n  countAllE :: expr\n  countE, avgE, maxE, minE, sumE\n    :: Maybe (Sql92AggregationSetQuantifierSyntax expr) -> expr -> expr\n\nclass IsSql92AggregationSetQuantifierSyntax q where\n  setQuantifierDistinct, setQuantifierAll :: q\n\nclass IsSql92ExpressionSyntax (Sql92ProjectionExpressionSyntax proj) => IsSql92ProjectionSyntax proj where\n  type Sql92ProjectionExpressionSyntax proj :: Type\n\n  projExprs :: [ (Sql92ProjectionExpressionSyntax proj, Maybe Text) ]\n            -> proj\n\nclass IsSql92OrderingSyntax ord where\n  type Sql92OrderingExpressionSyntax ord :: Type\n  ascOrdering, descOrdering\n    :: Sql92OrderingExpressionSyntax ord -> ord\n\nclass IsSql92TableNameSyntax tblName where\n  tableName :: Maybe Text {-^ Schema -}\n            -> Text {-^ Table name -}\n            -> tblName\n\nclass IsSql92TableNameSyntax (Sql92TableSourceTableNameSyntax tblSource) =>\n  IsSql92TableSourceSyntax tblSource where\n\n  type Sql92TableSourceSelectSyntax tblSource :: Type\n  type Sql92TableSourceExpressionSyntax tblSource :: Type\n  type Sql92TableSourceTableNameSyntax tblSource :: Type\n\n  tableNamed :: Sql92TableSourceTableNameSyntax tblSource\n             -> tblSource\n  tableFromSubSelect :: Sql92TableSourceSelectSyntax tblSource -> tblSource\n  tableFromValues :: [ [ Sql92TableSourceExpressionSyntax tblSource ] ] -> tblSource\n\nclass IsSql92GroupingSyntax grouping where\n  type Sql92GroupingExpressionSyntax grouping :: Type\n\n  groupByExpressions :: [ Sql92GroupingExpressionSyntax grouping ] -> grouping\n\nclass ( IsSql92TableSourceSyntax (Sql92FromTableSourceSyntax from)\n      , IsSql92ExpressionSyntax (Sql92FromExpressionSyntax from) ) =>\n    IsSql92FromSyntax from where\n  type Sql92FromTableSourceSyntax from :: Type\n  type Sql92FromExpressionSyntax from :: Type\n\n  fromTable :: Sql92FromTableSourceSyntax from\n            -> Maybe (Text, Maybe [Text])\n            -> from\n\n  innerJoin, leftJoin, rightJoin\n    :: from -> from\n      -> Maybe (Sql92FromExpressionSyntax from)\n      -> from\n\nclass IsSql92FromSyntax from =>\n  IsSql92FromOuterJoinSyntax from where\n\n  outerJoin :: from -> from -> Maybe (Sql92FromExpressionSyntax from) -> from\n\n-- Tagged\n\ninstance HasSqlValueSyntax vs t => HasSqlValueSyntax vs (Tagged tag t) where\n  sqlValueSyntax = sqlValueSyntax . untag\n\n"