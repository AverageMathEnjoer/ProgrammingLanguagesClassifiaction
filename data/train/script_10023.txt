b'using System;\nusing System.Diagnostics;\nusing System.Text;\n\nusing Bitmask = System.UInt64;\nusing u8 = System.Byte;\nusing u16 = System.UInt16;\nusing u32 = System.UInt32;\n\nnamespace CS_SQLite3\n{\n  using sqlite3_value = CSSQLite.Mem;\n\n  public partial class CSSQLite\n  {\n    /*\n    ** 2008 August 18\n    **\n    ** The author disclaims copyright to this source code.  In place of\n    ** a legal notice, here is a blessing:\n    **\n    **    May you do good and not evil.\n    **    May you find forgiveness for yourself and forgive others.\n    **    May you share freely, never taking more than you give.\n    **\n    *************************************************************************\n    **\n    ** This file contains routines used for walking the parser tree and\n    ** resolve all identifiers by associating them with a particular\n    ** table and column.\n    **\n    ** $Id: resolve.c,v 1.30 2009/06/15 23:15:59 drh Exp $\n    **\n    *************************************************************************\n    **  Included in SQLite3 port to C#-SQLite;  2008 Noah B Hart\n    **  C#-SQLite is an independent reimplementation of the SQLite software library\n    **\n    **  $Header$\n    *************************************************************************\n    */\n    //#include "sqliteInt.h"\n    //#include <stdlib.h>\n    //#include <string.h>\n\n    /*\n    ** Turn the pExpr expression into an alias for the iCol-th column of the\n    ** result set in pEList.\n    **\n    ** If the result set column is a simple column reference, then this routine\n    ** makes an exact copy.  But for any other kind of expression, this\n    ** routine make a copy of the result set column as the argument to the\n    ** TK_AS operator.  The TK_AS operator causes the expression to be\n    ** evaluated just once and then reused for each alias.\n    **\n    ** The reason for suppressing the TK_AS term when the expression is a simple\n    ** column reference is so that the column reference will be recognized as\n    ** usable by indices within the WHERE clause processing logic.\n    **\n    ** Hack:  The TK_AS operator is inhibited if zType[0]==\'G\'.  This means\n    ** that in a GROUP BY clause, the expression is evaluated twice.  Hence:\n    **\n    **     SELECT random()%5 AS x, count(*) FROM tab GROUP BY x\n    **\n    ** Is equivalent to:\n    **\n    **     SELECT random()%5 AS x, count(*) FROM tab GROUP BY random()%5\n    **\n    ** The result of random()%5 in the GROUP BY clause is probably different\n    ** from the result in the result-set.  We might fix this someday.  Or\n    ** then again, we might not...\n    */\n    static void resolveAlias(\n    Parse pParse,         /* Parsing context */\n    ExprList pEList,      /* A result set */\n    int iCol,             /* A column in the result set.  0..pEList.nExpr-1 */\n    Expr pExpr,       /* Transform this into an alias to the result set */\n    string zType          /* "GROUP" or "ORDER" or "" */\n    )\n    {\n      Expr pOrig;           /* The iCol-th column of the result set */\n      Expr pDup;            /* Copy of pOrig */\n      sqlite3 db;           /* The database connection */\n\n      Debug.Assert( iCol >= 0 && iCol < pEList.nExpr );\n      pOrig = pEList.a[iCol].pExpr;\n      Debug.Assert( pOrig != null );\n      Debug.Assert( ( pOrig.flags & EP_Resolved ) != 0 );\n      db = pParse.db;\n      if ( pOrig.op != TK_COLUMN && ( zType.Length == 0 || zType[0] != \'G\' ) )\n      {\n        pDup = sqlite3ExprDup( db, pOrig, 0 );\n        pDup = sqlite3PExpr( pParse, TK_AS, pDup, null, null );\n        if ( pDup == null ) return;\n        if ( pEList.a[iCol].iAlias == 0 )\n        {\n          pEList.a[iCol].iAlias = (u16)( ++pParse.nAlias );\n        }\n        pDup.iTable = pEList.a[iCol].iAlias;\n      }\n      else if ( ExprHasProperty( pOrig, EP_IntValue ) || pOrig.u.zToken == null )\n      {\n        pDup = sqlite3ExprDup( db, pOrig, 0 );\n        if ( pDup == null ) return;\n      }\n      else\n      {\n        string zToken = pOrig.u.zToken;\n        Debug.Assert( zToken != null );\n        pOrig.u.zToken = null;\n        pDup = sqlite3ExprDup( db, pOrig, 0 );\n        pOrig.u.zToken = zToken;\n        if ( pDup == null ) return;\n        Debug.Assert( ( pDup.flags & ( EP_Reduced | EP_TokenOnly ) ) == 0 );\n        pDup.flags2 |= EP2_MallocedToken;\n        pDup.u.zToken = zToken;// sqlite3DbStrDup( db, zToken );\n      }\n      if ( ( pExpr.flags & EP_ExpCollate ) != 0 )\n      {\n        pDup.pColl = pExpr.pColl;\n        pDup.flags |= EP_ExpCollate;\n      }\n      sqlite3ExprClear( db, pExpr );\n      pExpr.CopyFrom( pDup ); //memcpy(pExpr, pDup, sizeof(*pExpr));\n      //sqlite3DbFree( db, ref pDup );\n    }\n\n    /*\n    ** Given the name of a column of the form X.Y.Z or Y.Z or just Z, look up\n    ** that name in the set of source tables in pSrcList and make the pExpr\n    ** expression node refer back to that source column.  The following changes\n    ** are made to pExpr:\n    **\n    **    pExpr->iDb           Set the index in db->aDb[] of the database X\n    **                         (even if X is implied).\n    **    pExpr->iTable        Set to the cursor number for the table obtained\n    **                         from pSrcList.\n    **    pExpr->pTab          Points to the Table structure of X.Y (even if\n    **                         X and/or Y are implied.)\n    **    pExpr->iColumn       Set to the column number within the table.\n    **    pExpr->op            Set to TK_COLUMN.\n    **    pExpr->pLeft         Any expression this points to is deleted\n    **    pExpr->pRight        Any expression this points to is deleted.\n    **\n    ** The zDb variable is the name of the database (the "X").  This value may be\n    ** NULL meaning that name is of the form Y.Z or Z.  Any available database\n    ** can be used.  The zTable variable is the name of the table (the "Y").  This\n    ** value can be NULL if zDb is also NULL.  If zTable is NULL it\n    ** means that the form of the name is Z and that columns from any table\n    ** can be used.\n    **\n    ** If the name cannot be resolved unambiguously, leave an error message\n    ** in pParse and return WRC_Abort.  Return WRC_Prune on success.\n    */\n    static int lookupName(\n    Parse pParse,       /* The parsing context */\n    string zDb,         /* Name of the database containing table, or NULL */\n    string zTab,        /* Name of table containing column, or NULL */\n    string zCol,        /* Name of the column. */\n    NameContext pNC,    /* The name context used to resolve the name */\n    Expr pExpr          /* Make this EXPR node point to the selected column */\n    )\n    {\n      int i, j;            /* Loop counters */\n      int cnt = 0;                      /* Number of matching column names */\n      int cntTab = 0;                   /* Number of matching table names */\n      sqlite3 db = pParse.db;         /* The database connection */\n      SrcList_item pItem;       /* Use for looping over pSrcList items */\n      SrcList_item pMatch = null;  /* The matching pSrcList item */\n      NameContext pTopNC = pNC;        /* First namecontext in the list */\n      Schema pSchema = null;              /* Schema of the expression */\n\n      Debug.Assert( pNC != null ); /* the name context cannot be NULL. */\n      Debug.Assert( zCol != null );    /* The Z in X.Y.Z cannot be NULL */\n      Debug.Assert( !ExprHasAnyProperty( pExpr, EP_TokenOnly | EP_Reduced ) );\n\n      /* Initialize the node to no-match */\n      pExpr.iTable = -1;\n      pExpr.pTab = null;\n      ExprSetIrreducible( pExpr );\n\n      /* Start at the inner-most context and move outward until a match is found */\n      while ( pNC != null && cnt == 0 )\n      {\n        ExprList pEList;\n        SrcList pSrcList = pNC.pSrcList;\n\n        if ( pSrcList != null )\n        {\n          for ( i = 0 ; i < pSrcList.nSrc ; i++ )//, pItem++ )\n          {\n            pItem = pSrcList.a[i];\n            Table pTab;\n            int iDb;\n            Column pCol;\n\n            pTab = pItem.pTab;\n            Debug.Assert( pTab != null && pTab.zName != null );\n            iDb = sqlite3SchemaToIndex( db, pTab.pSchema );\n            Debug.Assert( pTab.nCol > 0 );\n            if ( zTab != null )\n            {\n              if ( pItem.zAlias != null )\n              {\n                string zTabName = pItem.zAlias;\n                if ( sqlite3StrICmp( zTabName, zTab ) != 0 ) continue;\n              }\n              else\n              {\n                string zTabName = pTab.zName;\n                if ( NEVER( zTabName == null ) || sqlite3StrICmp( zTabName, zTab ) != 0 )\n                {\n                  continue;\n                }\n                if ( zDb != null && sqlite3StrICmp( db.aDb[iDb].zName, zDb ) != 0 )\n                {\n                  continue;\n                }\n              }\n            }\n            if ( 0 == ( cntTab++ ) )\n            {\n              pExpr.iTable = pItem.iCursor;\n              pExpr.pTab = pTab;\n              pSchema = pTab.pSchema;\n              pMatch = pItem;\n            }\n            for ( j = 0 ; j < pTab.nCol ; j++ )//, pCol++ )\n            {\n              pCol = pTab.aCol[j];\n              if ( sqlite3StrICmp( pCol.zName, zCol ) == 0 )\n              {\n                IdList pUsing;\n                cnt++;\n                pExpr.iTable = pItem.iCursor;\n                pExpr.pTab = pTab;\n                pMatch = pItem;\n                pSchema = pTab.pSchema;\n                /* Substitute the rowid (column -1) for the INTEGER PRIMARY KEY */\n                pExpr.iColumn = (short)( j == pTab.iPKey ? -1 : j );\n                if ( i < pSrcList.nSrc - 1 )\n                {\n                  if ( ( pSrcList.a[i + 1].jointype & JT_NATURAL ) != 0 )// pItem[1].jointype\n                  {\n                    /* If this match occurred in the left table of a natural join,\n                    ** then skip the right table to avoid a duplicate match */\n                    //pItem++;\n                    i++;\n                  }\n                  else if ( ( pUsing = pSrcList.a[i + 1].pUsing ) != null )//pItem[1].pUsing\n                  {\n                    /* If this match occurs on a column that is in the USING clause\n                    ** of a join, skip the search of the right table of the join\n                    ** to avoid a duplicate match there. */\n                    int k;\n                    for ( k = 0 ; k < pUsing.nId ; k++ )\n                    {\n                      if ( sqlite3StrICmp( pUsing.a[k].zName, zCol ) == 0 )\n                      {\n                        //pItem++;\n                        i++;\n                        break;\n                      }\n                    }\n                  }\n                }\n                break;\n              }\n            }\n          }\n        }\n\n#if !SQLITE_OMIT_TRIGGER\n        /* If we have not already resolved the name, then maybe\n** it is a new.* or old.* trigger argument reference\n*/\n        if ( zDb == null && zTab != null && cnt == 0 && pParse.trigStack != null )\n        {\n          TriggerStack pTriggerStack = pParse.trigStack;\n          Table pTab = null;\n          u32 piColMask = 0;\n          bool bNew = false;\n          bool bOld = false;\n          if ( pTriggerStack.newIdx != -1 && sqlite3StrICmp( "new", zTab ) == 0 )\n          {\n            pExpr.iTable = pTriggerStack.newIdx;\n            Debug.Assert( pTriggerStack.pTab != null );\n            pTab = pTriggerStack.pTab;\n            piColMask = pTriggerStack.newColMask;\n            bNew = true;\n          }\n          else if ( pTriggerStack.oldIdx != -1 && sqlite3StrICmp( "old", zTab ) == 0 )\n          {\n            pExpr.iTable = pTriggerStack.oldIdx;\n            Debug.Assert( pTriggerStack.pTab != null );\n            pTab = pTriggerStack.pTab;\n            piColMask = pTriggerStack.oldColMask;\n            bOld = true;\n          }\n\n          if ( pTab != null )\n          {\n            int iCol;\n            Column pCol;// = pTab.aCol;\n\n            pSchema = pTab.pSchema;\n            cntTab++;\n            for ( iCol = 0 ; iCol < pTab.nCol ; iCol++ )//, pCol++)\n            {\n              pCol = pTab.aCol[iCol];\n              if ( sqlite3StrICmp( pCol.zName, zCol ) == 0 )\n              {\n                cnt++;\n                pExpr.iColumn = (short)( iCol == pTab.iPKey ? -1 : iCol );\n                pExpr.pTab = pTab;\n                testcase( iCol == 31 );\n                testcase( iCol == 32 );\n                if ( iCol >= 32 )\n                {\n                  piColMask = 0xffffffff;\n                }\n                else\n                {\n                  piColMask |= ( (u32)1 ) << iCol;\n                }\n                break;\n              }\n            }\n            if ( bOld ) pTriggerStack.oldColMask = piColMask;\n            if ( bNew ) pTriggerStack.newColMask = piColMask;\n          }\n        }\n#endif //* !SQLITE_OMIT_TRIGGER) */\n\n        /*\n** Perhaps the name is a reference to the ROWID\n*/\n        if ( cnt == 0 && cntTab == 1 && sqlite3IsRowid( zCol ) )\n        {\n          cnt = 1;\n          pExpr.iColumn = -1;\n          pExpr.affinity = SQLITE_AFF_INTEGER;\n        }\n\n        /*\n        ** If the input is of the form Z (not Y.Z or X.Y.Z) then the name Z\n        ** might refer to an result-set alias.  This happens, for example, when\n        ** we are resolving names in the WHERE clause of the following command:\n        **\n        **     SELECT a+b AS x FROM table WHERE x<10;\n        **\n        ** In cases like this, replace pExpr with a copy of the expression that\n        ** forms the result set entry ("a+b" in the example) and return immediately.\n        ** Note that the expression in the result set should have already been\n        ** resolved by the time the WHERE clause is resolved.\n        */\n        if ( cnt == 0 && ( pEList = pNC.pEList ) != null && zTab == null )\n        {\n          for ( j = 0 ; j < pEList.nExpr ; j++ )\n          {\n            string zAs = pEList.a[j].zName;\n            if ( zAs != null && sqlite3StrICmp( zAs, zCol ) == 0 )\n            {\n              Expr pOrig;\n              Debug.Assert( pExpr.pLeft == null && pExpr.pRight == null );\n              Debug.Assert( pExpr.x.pList == null );\n              Debug.Assert( pExpr.x.pSelect == null );\n              pOrig = pEList.a[j].pExpr;\n              if ( 0 == pNC.allowAgg && ExprHasProperty( pOrig, EP_Agg ) )\n              {\n                sqlite3ErrorMsg( pParse, "misuse of aliased aggregate %s", zAs );\n                return WRC_Abort;\n              }\n              resolveAlias( pParse, pEList, j, pExpr, "" );\n              cnt = 1;\n              pMatch = null;\n              Debug.Assert( zTab == null && zDb == null );\n              goto lookupname_end;\n            }\n          }\n        }\n\n        /* Advance to the next name context.  The loop will exit when either\n        ** we have a match (cnt>0) or when we run out of name contexts.\n        */\n        if ( cnt == 0 )\n        {\n          pNC = pNC.pNext;\n        }\n      }\n\n      /*\n      ** If X and Y are NULL (in other words if only the column name Z is\n      ** supplied) and the value of Z is enclosed in double-quotes, then\n      ** Z is a string literal if it doesn\'t match any column names.  In that\n      ** case, we need to return right away and not make any changes to\n      ** pExpr.\n      **\n      ** Because no reference was made to outer contexts, the pNC.nRef\n      ** fields are not changed in any context.\n      */\n      if ( cnt == 0 && zTab == null && ExprHasProperty( pExpr, EP_DblQuoted ) )\n      {\n        pExpr.op = TK_STRING;\n        pExpr.pTab = null;\n        return WRC_Prune;\n      }\n\n      /*\n      ** cnt==0 means there was not match.  cnt>1 means there were two or\n      ** more matches.  Either way, we have an error.\n      */\n      if ( cnt != 1 )\n      {\n        string zErr;\n        zErr = cnt == 0 ? "no such column" : "ambiguous column name";\n        if ( zDb != null )\n        {\n          sqlite3ErrorMsg( pParse, "%s: %s.%s.%s", zErr, zDb, zTab, zCol );\n        }\n        else if ( zTab != null )\n        {\n          sqlite3ErrorMsg( pParse, "%s: %s.%s", zErr, zTab, zCol );\n        }\n        else\n        {\n          sqlite3ErrorMsg( pParse, "%s: %s", zErr, zCol );\n        }\n        pTopNC.nErr++;\n      }\n\n      /* If a column from a table in pSrcList is referenced, then record\n      ** this fact in the pSrcList.a[].colUsed bitmask.  Column 0 causes\n      ** bit 0 to be set.  Column 1 sets bit 1.  And so forth.  If the\n      ** column number is greater than the number of bits in the bitmask\n      ** then set the high-order bit of the bitmask.\n      */\n      if ( pExpr.iColumn >= 0 && pMatch != null )\n      {\n        int n = pExpr.iColumn;\n        testcase( n == BMS - 1 );\n        if ( n >= BMS )\n        {\n          n = BMS - 1;\n        }\n        Debug.Assert( pMatch.iCursor == pExpr.iTable );\n        pMatch.colUsed |= ( (Bitmask)1 ) << n;\n      }\n\n      /* Clean up and return\n      */\n      sqlite3ExprDelete( db, ref pExpr.pLeft );\n      pExpr.pLeft = null;\n      sqlite3ExprDelete( db, ref pExpr.pRight );\n      pExpr.pRight = null;\n      pExpr.op = TK_COLUMN;\nlookupname_end:\n      if ( cnt == 1 )\n      {\n        Debug.Assert( pNC != null );\n        sqlite3AuthRead( pParse, pExpr, pSchema, pNC.pSrcList );\n        /* Increment the nRef value on all name contexts from TopNC up to\n        ** the point where the name matched. */\n        for ( ; ; )\n        {\n          Debug.Assert( pTopNC != null );\n          pTopNC.nRef++;\n          if ( pTopNC == pNC ) break;\n          pTopNC = pTopNC.pNext;\n        }\n        return WRC_Prune;\n      }\n      else\n      {\n        return WRC_Abort;\n      }\n    }\n\n    /*\n    ** This routine is callback for sqlite3WalkExpr().\n    **\n    ** Resolve symbolic names into TK_COLUMN operators for the current\n    ** node in the expression tree.  Return 0 to continue the search down\n    ** the tree or 2 to abort the tree walk.\n    **\n    ** This routine also does error checking and name resolution for\n    ** function names.  The operator for aggregate functions is changed\n    ** to TK_AGG_FUNCTION.\n    */\n    static int resolveExprStep( Walker pWalker, ref Expr pExpr )\n    {\n      NameContext pNC;\n      Parse pParse;\n\n      pNC = pWalker.u.pNC;\n      Debug.Assert( pNC != null );\n      pParse = pNC.pParse;\n      Debug.Assert( pParse == pWalker.pParse );\n\n      if ( ExprHasAnyProperty( pExpr, EP_Resolved ) ) return WRC_Prune;\n      ExprSetProperty( pExpr, EP_Resolved );\n#if !NDEBUG\n      if ( pNC.pSrcList != null && pNC.pSrcList.nAlloc > 0 )\n      {\n        SrcList pSrcList = pNC.pSrcList;\n        int i;\n        for ( i = 0 ; i < pNC.pSrcList.nSrc ; i++ )\n        {\n          Debug.Assert( pSrcList.a[i].iCursor >= 0 && pSrcList.a[i].iCursor < pParse.nTab );\n        }\n      }\n#endif\n      switch ( pExpr.op )\n      {\n\n#if (SQLITE_ENABLE_UPDATE_DELETE_LIMIT) && !(SQLITE_OMIT_SUBQUERY)\n/* The special operator TK_ROW means use the rowid for the first\n** column in the FROM clause.  This is used by the LIMIT and ORDER BY\n** clause processing on UPDATE and DELETE statements.\n*/\ncase TK_ROW: {\nSrcList pSrcList = pNC.pSrcList;\nSrcList_item pItem;\nDebug.Assert( pSrcList !=null && pSrcList.nSrc==1 );\npItem = pSrcList.a[0];\npExpr.op = TK_COLUMN;\npExpr.pTab = pItem.pTab;\npExpr.iTable = pItem.iCursor;\npExpr.iColumn = -1;\npExpr.affinity = SQLITE_AFF_INTEGER;\nbreak;\n}\n#endif //* defined(SQLITE_ENABLE_UPDATE_DELETE_LIMIT) && !defined(SQLITE_OMIT_SUBQUERY) /\n\n        /* A lone identifier is the name of a column.\n*/\n        case TK_ID:\n          {\n            return lookupName( pParse, null, null, pExpr.u.zToken, pNC, pExpr );\n          }\n\n        /* A table name and column name:     ID.ID\n        ** Or a database, table and column:  ID.ID.ID\n        */\n        case TK_DOT:\n          {\n            string zColumn;\n            string zTable;\n            string zDb;\n            Expr pRight;\n\n            /* if( pSrcList==0 ) break; */\n            pRight = pExpr.pRight;\n            if ( pRight.op == TK_ID )\n            {\n              zDb = null;\n              zTable = pExpr.pLeft.u.zToken;\n              zColumn = pRight.u.zToken;\n            }\n            else\n            {\n              Debug.Assert( pRight.op == TK_DOT );\n              zDb = pExpr.pLeft.u.zToken;\n              zTable = pRight.pLeft.u.zToken;\n              zColumn = pRight.pRight.u.zToken;\n            }\n            return lookupName( pParse, zDb, zTable, zColumn, pNC, pExpr );\n          }\n\n        /* Resolve function names\n        */\n        case TK_CONST_FUNC:\n        case TK_FUNCTION:\n          {\n            ExprList pList = pExpr.x.pList;    /* The argument list */\n            int n = pList != null ? pList.nExpr : 0;  /* Number of arguments */\n            bool no_such_func = false;       /* True if no such function exists */\n            bool wrong_num_args = false;     /* True if wrong number of arguments */\n            bool is_agg = false;             /* True if is an aggregate function */\n            int auth;                   /* Authorization to use the function */\n            int nId;                    /* Number of characters in function name */\n            string zId;                 /* The function name. */\n            FuncDef pDef;              /* Information about the function */\n            u8 enc = (u8)pParse.db.aDbStatic[0].pSchema.enc;// ENC( pParse.db );   /* The database encoding */\n\n            testcase( pExpr.op == TK_CONST_FUNC );\n            Debug.Assert( !ExprHasProperty( pExpr, EP_xIsSelect ) );\n            zId = pExpr.u.zToken;\n            nId = sqlite3Strlen30( zId );\n            pDef = sqlite3FindFunction( pParse.db, zId, nId, n, enc, 0 );\n            if ( pDef == null )\n            {\n              pDef = sqlite3FindFunction( pParse.db, zId, nId, -1, enc, 0 );\n              if ( pDef == null )\n              {\n                no_such_func = true;\n              }\n              else\n              {\n                wrong_num_args = true;\n              }\n            }\n            else\n            {\n              is_agg = pDef.xFunc == null;\n            }\n#if !SQLITE_OMIT_AUTHORIZATION\nif( pDef ){\nauth = sqlite3AuthCheck(pParse, SQLITE_FUNCTION, 0, pDef.zName, 0);\nif( auth!=SQLITE_OK ){\nif( auth==SQLITE_DENY ){\nsqlite3ErrorMsg(pParse, "not authorized to use function: %s",\npDef.zName);\npNC.nErr++;\n}\npExpr.op = TK_NULL;\nreturn WRC_Prune;\n}\n}\n#endif\n            if ( is_agg && 0 == pNC.allowAgg )\n            {\n              sqlite3ErrorMsg( pParse, "misuse of aggregate function %.*s()", nId, zId );\n              pNC.nErr++;\n              is_agg = false;\n            }\n            else if ( no_such_func )\n            {\n              sqlite3ErrorMsg( pParse, "no such function: %.*s", nId, zId );\n              pNC.nErr++;\n            }\n            else if ( wrong_num_args )\n            {\n              sqlite3ErrorMsg( pParse, "wrong number of arguments to function %.*s()",\n              nId, zId );\n              pNC.nErr++;\n            }\n            if ( is_agg )\n            {\n              pExpr.op = TK_AGG_FUNCTION;\n              pNC.hasAgg = 1;\n            }\n            if ( is_agg ) pNC.allowAgg = 0;\n            sqlite3WalkExprList( pWalker, pList );\n            if ( is_agg ) pNC.allowAgg = 1;\n            /* FIX ME:  Compute pExpr.affinity based on the expected return\n            ** type of the function\n            */\n            return WRC_Prune;\n          }\n#if !SQLITE_OMIT_SUBQUERY\n        case TK_SELECT:\n        case TK_EXISTS:\n          {\n            testcase( pExpr.op == TK_EXISTS );\n            goto case TK_IN;\n          }\n#endif\n        case TK_IN:\n          {\n            testcase( pExpr.op == TK_IN );\n            if ( ExprHasProperty( pExpr, EP_xIsSelect ) )\n            {\n              int nRef = pNC.nRef;\n#if !SQLITE_OMIT_CHECK\n              if ( pNC.isCheck != 0 )\n              {\n                sqlite3ErrorMsg( pParse, "subqueries prohibited in CHECK constraints" );\n              }\n#endif\n              sqlite3WalkSelect( pWalker, pExpr.x.pSelect );\n              Debug.Assert( pNC.nRef >= nRef );\n              if ( nRef != pNC.nRef )\n              {\n                ExprSetProperty( pExpr, EP_VarSelect );\n              }\n            }\n            break;\n          }\n#if !SQLITE_OMIT_CHECK\n        case TK_VARIABLE:\n          {\n            if ( pNC.isCheck != 0 )\n            {\n              sqlite3ErrorMsg( pParse, "parameters prohibited in CHECK constraints" );\n            }\n            break;\n          }\n#endif\n      }\n      return ( pParse.nErr != 0 /* || pParse.db.mallocFailed != 0 */ ) ? WRC_Abort : WRC_Continue;\n    }\n\n    /*\n    ** pEList is a list of expressions which are really the result set of the\n    ** a SELECT statement.  pE is a term in an ORDER BY or GROUP BY clause.\n    ** This routine checks to see if pE is a simple identifier which corresponds\n    ** to the AS-name of one of the terms of the expression list.  If it is,\n    ** this routine return an integer between 1 and N where N is the number of\n    ** elements in pEList, corresponding to the matching entry.  If there is\n    ** no match, or if pE is not a simple identifier, then this routine\n    ** return 0.\n    **\n    ** pEList has been resolved.  pE has not.\n    */\n    static int resolveAsName(\n    Parse pParse,     /* Parsing context for error messages */\n    ExprList pEList,  /* List of expressions to scan */\n    Expr pE           /* Expression we are trying to match */\n    )\n    {\n      int i;             /* Loop counter */\n\n      UNUSED_PARAMETER( pParse );\n\n      if ( pE.op == TK_ID )\n      {\n        string zCol = pE.u.zToken;\n\n        for ( i = 0 ; i < pEList.nExpr ; i++ )\n        {\n          string zAs = pEList.a[i].zName;\n          if ( zAs != null && sqlite3StrICmp( zAs, zCol ) == 0 )\n          {\n            return i + 1;\n          }\n        }\n      }\n      return 0;\n    }\n\n    /*\n    ** pE is a pointer to an expression which is a single term in the\n    ** ORDER BY of a compound SELECT.  The expression has not been\n    ** name resolved.\n    **\n    ** At the point this routine is called, we already know that the\n    ** ORDER BY term is not an integer index into the result set.  That\n    ** case is handled by the calling routine.\n    **\n    ** Attempt to match pE against result set columns in the left-most\n    ** SELECT statement.  Return the index i of the matching column,\n    ** as an indication to the caller that it should sort by the i-th column.\n    ** The left-most column is 1.  In other words, the value returned is the\n    ** same integer value that would be used in the SQL statement to indicate\n    ** the column.\n    **\n    ** If there is no match, return 0.  Return -1 if an error occurs.\n    */\n    static int resolveOrderByTermToExprList(\n    Parse pParse,     /* Parsing context for error messages */\n    Select pSelect,   /* The SELECT statement with the ORDER BY clause */\n    Expr pE           /* The specific ORDER BY term */\n    )\n    {\n      int i = 0;             /* Loop counter */\n      ExprList pEList;  /* The columns of the result set */\n      NameContext nc;    /* Name context for resolving pE */\n\n      Debug.Assert( sqlite3ExprIsInteger( pE, ref i ) == 0 );\n      pEList = pSelect.pEList;\n\n      /* Resolve all names in the ORDER BY term expression\n      */\n      nc = new NameContext();// memset( &nc, 0, sizeof( nc ) );\n      nc.pParse = pParse;\n      nc.pSrcList = pSelect.pSrc;\n      nc.pEList = pEList;\n      nc.allowAgg = 1;\n      nc.nErr = 0;\n      if ( sqlite3ResolveExprNames( nc, ref pE ) != 0 )\n      {\n        sqlite3ErrorClear( pParse );\n        return 0;\n      }\n\n      /* Try to match the ORDER BY expression against an expression\n      ** in the result set.  Return an 1-based index of the matching\n      ** result-set entry.\n      */\n      for ( i = 0 ; i < pEList.nExpr ; i++ )\n      {\n        if ( sqlite3ExprCompare( pEList.a[i].pExpr, pE ) )\n        {\n          return i + 1;\n        }\n      }\n\n      /* If no match, return 0. */\n      return 0;\n    }\n\n    /*\n    ** Generate an ORDER BY or GROUP BY term out-of-range error.\n    */\n    static void resolveOutOfRangeError(\n    Parse pParse,         /* The error context into which to write the error */\n    string zType,     /* "ORDER" or "GROUP" */\n    int i,                 /* The index (1-based) of the term out of range */\n    int mx                 /* Largest permissible value of i */\n    )\n    {\n      sqlite3ErrorMsg( pParse,\n      "%r %s BY term out of range - should be " +\n      "between 1 and %d", i, zType, mx );\n    }\n\n    /*\n    ** Analyze the ORDER BY clause in a compound SELECT statement.   Modify\n    ** each term of the ORDER BY clause is a constant integer between 1\n    ** and N where N is the number of columns in the compound SELECT.\n    **\n    ** ORDER BY terms that are already an integer between 1 and N are\n    ** unmodified.  ORDER BY terms that are integers outside the range of\n    ** 1 through N generate an error.  ORDER BY terms that are expressions\n    ** are matched against result set expressions of compound SELECT\n    ** beginning with the left-most SELECT and working toward the right.\n    ** At the first match, the ORDER BY expression is transformed into\n    ** the integer column number.\n    **\n    ** Return the number of errors seen.\n    */\n    static int resolveCompoundOrderBy(\n    Parse pParse,        /* Parsing context.  Leave error messages here */\n    Select pSelect       /* The SELECT statement containing the ORDER BY */\n    )\n    {\n      int i;\n      ExprList pOrderBy;\n      ExprList pEList;\n      sqlite3 db;\n      int moreToDo = 1;\n\n      pOrderBy = pSelect.pOrderBy;\n      if ( pOrderBy == null ) return 0;\n      db = pParse.db;\n#if SQLITE_MAX_COLUMN\nif( pOrderBy.nExpr>db.aLimit[SQLITE_LIMIT_COLUMN] ){\nsqlite3ErrorMsg(pParse, "too many terms in ORDER BY clause");\nreturn 1;\n}\n#endif\n      for ( i = 0 ; i < pOrderBy.nExpr ; i++ )\n      {\n        pOrderBy.a[i].done = 0;\n      }\n      pSelect.pNext = null;\n      while ( pSelect.pPrior != null )\n      {\n        pSelect.pPrior.pNext = pSelect;\n        pSelect = pSelect.pPrior;\n      }\n      while ( pSelect != null && moreToDo != 0 )\n      {\n        ExprList_item pItem;\n        moreToDo = 0;\n        pEList = pSelect.pEList;\n        Debug.Assert( pEList != null );\n        for ( i = 0 ; i < pOrderBy.nExpr ; i++ )//, pItem++)\n        {\n          pItem = pOrderBy.a[i];\n          int iCol = -1;\n          Expr pE, pDup;\n          if ( pItem.done != 0 ) continue;\n          pE = pItem.pExpr;\n          if ( sqlite3ExprIsInteger( pE, ref iCol ) != 0 )\n          {\n            if ( iCol <= 0 || iCol > pEList.nExpr )\n            {\n              resolveOutOfRangeError( pParse, "ORDER", i + 1, pEList.nExpr );\n              return 1;\n            }\n          }\n          else\n          {\n            iCol = resolveAsName( pParse, pEList, pE );\n            if ( iCol == 0 )\n            {\n              pDup = sqlite3ExprDup( db, pE, 0 );\n              ////if ( 0 == db.mallocFailed )\n              {\n                Debug.Assert( pDup != null );\n                iCol = resolveOrderByTermToExprList( pParse, pSelect, pDup );\n              }\n              sqlite3ExprDelete( db, ref pDup );\n            }\n          }\n          if ( iCol > 0 )\n          {\n            CollSeq pColl = pE.pColl;\n            int flags = pE.flags & EP_ExpCollate;\n            sqlite3ExprDelete( db, ref pE );\n            pItem.pExpr = pE = sqlite3Expr( db, TK_INTEGER, null );\n            if ( pE == null ) return 1;\n            pE.pColl = pColl;\n            pE.flags = (u16)( pE.flags | EP_IntValue | flags );\n            pE.u.iValue = iCol;\n            pItem.iCol = (u16)iCol;\n            pItem.done = 1;\n          }\n          else\n          {\n            moreToDo = 1;\n          }\n        }\n        pSelect = pSelect.pNext;\n      }\n      for ( i = 0 ; i < pOrderBy.nExpr ; i++ )\n      {\n        if ( pOrderBy.a[i].done == 0 )\n        {\n          sqlite3ErrorMsg( pParse, "%r ORDER BY term does not match any " +\n          "column in the result set", i + 1 );\n          return 1;\n        }\n      }\n      return 0;\n    }\n\n    /*\n    ** Check every term in the ORDER BY or GROUP BY clause pOrderBy of\n    ** the SELECT statement pSelect.  If any term is reference to a\n    ** result set expression (as determined by the ExprList.a.iCol field)\n    ** then convert that term into a copy of the corresponding result set\n    ** column.\n    **\n    ** If any errors are detected, add an error message to pParse and\n    ** return non-zero.  Return zero if no errors are seen.\n    */\n    static int sqlite3ResolveOrderGroupBy(\n    Parse pParse,        /* Parsing context.  Leave error messages here */\n    Select pSelect,      /* The SELECT statement containing the clause */\n    ExprList pOrderBy,   /* The ORDER BY or GROUP BY clause to be processed */\n    string zType         /* "ORDER" or "GROUP" */\n    )\n    {\n      int i;\n      sqlite3 db = pParse.db;\n      ExprList pEList;\n      ExprList_item pItem;\n\n      if ( pOrderBy == null /* || pParse.db.mallocFailed != 0 */ ) return 0;\n#if SQLITE_MAX_COLUMN\nif( pOrderBy.nExpr>db.aLimit[SQLITE_LIMIT_COLUMN] ){\nsqlite3ErrorMsg(pParse, "too many terms in %s BY clause", zType);\nreturn 1;\n}\n#endif\n      pEList = pSelect.pEList;\n      Debug.Assert( pEList != null );  /* sqlite3SelectNew() guarantees this */\n      for ( i = 0 ; i < pOrderBy.nExpr ; i++ )//, pItem++)\n      {\n        pItem = pOrderBy.a[i];\n        if ( pItem.iCol != 0 )\n        {\n          if ( pItem.iCol > pEList.nExpr )\n          {\n            resolveOutOfRangeError( pParse, zType, i + 1, pEList.nExpr );\n            return 1;\n          }\n          resolveAlias( pParse, pEList, pItem.iCol - 1, pItem.pExpr, zType );\n        }\n      }\n      return 0;\n    }\n\n    /*\n    ** pOrderBy is an ORDER BY or GROUP BY clause in SELECT statement pSelect.\n    ** The Name context of the SELECT statement is pNC.  zType is either\n    ** "ORDER" or "GROUP" depending on which type of clause pOrderBy is.\n    **\n    ** This routine resolves each term of the clause into an expression.\n    ** If the order-by term is an integer I between 1 and N (where N is the\n    ** number of columns in the result set of the SELECT) then the expression\n    ** in the resolution is a copy of the I-th result-set expression.  If\n    ** the order-by term is an identify that corresponds to the AS-name of\n    ** a result-set expression, then the term resolves to a copy of the\n    ** result-set expression.  Otherwise, the expression is resolved in\n    ** the usual way - using sqlite3ResolveExprNames().\n    **\n    ** This routine returns the number of errors.  If errors occur, then\n    ** an appropriate error message might be left in pParse.  (OOM errors\n    ** excepted.)\n    */\n    static int resolveOrderGroupBy(\n    NameContext pNC,     /* The name context of the SELECT statement */\n    Select pSelect,      /* The SELECT statement holding pOrderBy */\n    ExprList pOrderBy,   /* An ORDER BY or GROUP BY clause to resolve */\n    string zType         /* Either "ORDER" or "GROUP", as appropriate */\n    )\n    {\n      int i;                         /* Loop counter */\n      int iCol;                      /* Column number */\n      ExprList_item pItem;   /* A term of the ORDER BY clause */\n      Parse pParse;                 /* Parsing context */\n      int nResult;                   /* Number of terms in the result set */\n\n      if ( pOrderBy == null ) return 0;\n      nResult = pSelect.pEList.nExpr;\n      pParse = pNC.pParse;\n      for ( i = 0 ; i < pOrderBy.nExpr ; i++ )//, pItem++ )\n      {\n        pItem = pOrderBy.a[i];\n        Expr pE = pItem.pExpr;\n        iCol = resolveAsName( pParse, pSelect.pEList, pE );\n        if ( iCol > 0 )\n        {\n          /* If an AS-name match is found, mark this ORDER BY column as being\n          ** a copy of the iCol-th result-set column.  The subsequent call to\n          ** sqlite3ResolveOrderGroupBy() will convert the expression to a\n          ** copy of the iCol-th result-set expression. */\n          pItem.iCol = (u16)iCol;\n          continue;\n        }\n        if ( sqlite3ExprIsInteger( pE, ref iCol ) != 0 )\n        {\n          /* The ORDER BY term is an integer constant.  Again, set the column\n          ** number so that sqlite3ResolveOrderGroupBy() will convert the\n          ** order-by term to a copy of the result-set expression */\n          if ( iCol < 1 )\n          {\n            resolveOutOfRangeError( pParse, zType, i + 1, nResult );\n            return 1;\n          }\n          pItem.iCol = (u16)iCol;\n          continue;\n        }\n\n        /* Otherwise, treat the ORDER BY term as an ordinary expression */\n        pItem.iCol = 0;\n        if ( sqlite3ResolveExprNames( pNC, ref pE ) != 0 )\n        {\n          return 1;\n        }\n      }\n      return sqlite3ResolveOrderGroupBy( pParse, pSelect, pOrderBy, zType );\n    }\n\n    /*\n    ** Resolve names in the SELECT statement p and all of its descendents.\n    */\n    static int resolveSelectStep( Walker pWalker, Select p )\n    {\n      NameContext pOuterNC;  /* Context that contains this SELECT */\n      NameContext sNC;       /* Name context of this SELECT */\n      bool isCompound;       /* True if p is a compound select */\n      int nCompound;         /* Number of compound terms processed so far */\n      Parse pParse;          /* Parsing context */\n      ExprList pEList;       /* Result set expression list */\n      int i;                 /* Loop counter */\n      ExprList pGroupBy;     /* The GROUP BY clause */\n      Select pLeftmost;      /* Left-most of SELECT of a compound */\n      sqlite3 db;            /* Database connection */\n\n\n      Debug.Assert( p != null );\n      if ( ( p.selFlags & SF_Resolved ) != 0 )\n      {\n        return WRC_Prune;\n      }\n      pOuterNC = pWalker.u.pNC;\n      pParse = pWalker.pParse;\n      db = pParse.db;\n\n      /* Normally sqlite3SelectExpand() will be called first and will have\n      ** already expanded this SELECT.  However, if this is a subquery within\n      ** an expression, sqlite3ResolveExprNames() will be called without a\n      ** prior call to sqlite3SelectExpand().  When that happens, let\n      ** sqlite3SelectPrep() do all of the processing for this SELECT.\n      ** sqlite3SelectPrep() will invoke both sqlite3SelectExpand() and\n      ** this routine in the correct order.\n      */\n      if ( ( p.selFlags & SF_Expanded ) == 0 )\n      {\n        sqlite3SelectPrep( pParse, p, pOuterNC );\n        return ( pParse.nErr != 0 /*|| db.mallocFailed != 0 */ ) ? WRC_Abort : WRC_Prune;\n      }\n\n      isCompound = p.pPrior != null;\n      nCompound = 0;\n      pLeftmost = p;\n      while ( p != null )\n      {\n        Debug.Assert( ( p.selFlags & SF_Expanded ) != 0 );\n        Debug.Assert( ( p.selFlags & SF_Resolved ) == 0 );\n        p.selFlags |= SF_Resolved;\n\n        /* Resolve the expressions in the LIMIT and OFFSET clauses. These\n        ** are not allowed to refer to any names, so pass an empty NameContext.\n        */\n        sNC = new NameContext();// memset( &sNC, 0, sizeof( sNC ) );\n        sNC.pParse = pParse;\n        if ( sqlite3ResolveExprNames( sNC, ref p.pLimit ) != 0 ||\n        sqlite3ResolveExprNames( sNC, ref p.pOffset ) != 0 )\n        {\n          return WRC_Abort;\n        }\n\n        /* Set up the local name-context to pass to sqlite3ResolveExprNames() to\n        ** resolve the result-set expression list.\n        */\n        sNC.allowAgg = 1;\n        sNC.pSrcList = p.pSrc;\n        sNC.pNext = pOuterNC;\n\n        /* Resolve names in the result set. */\n        pEList = p.pEList;\n        Debug.Assert( pEList != null );\n        for ( i = 0 ; i < pEList.nExpr ; i++ )\n        {\n          Expr pX = pEList.a[i].pExpr;\n          if ( sqlite3ResolveExprNames( sNC, ref pX ) != 0 )\n          {\n            return WRC_Abort;\n          }\n        }\n\n        /* Recursively resolve names in all subqueries\n        */\n        for ( i = 0 ; i < p.pSrc.nSrc ; i++ )\n        {\n          SrcList_item pItem = p.pSrc.a[i];\n          if ( pItem.pSelect != null )\n          {\n            string zSavedContext = pParse.zAuthContext;\n            if ( pItem.zName != null ) pParse.zAuthContext = pItem.zName;\n            sqlite3ResolveSelectNames( pParse, pItem.pSelect, pOuterNC );\n            pParse.zAuthContext = zSavedContext;\n            if ( pParse.nErr != 0 /*|| db.mallocFailed != 0 */ ) return WRC_Abort;\n          }\n        }\n\n        /* If there are no aggregate functions in the result-set, and no GROUP BY\n        ** expression, do not allow aggregates in any of the other expressions.\n        */\n        Debug.Assert( ( p.selFlags & SF_Aggregate ) == 0 );\n        pGroupBy = p.pGroupBy;\n        if ( pGroupBy != null || sNC.hasAgg != 0 )\n        {\n          p.selFlags |= SF_Aggregate;\n        }\n        else\n        {\n          sNC.allowAgg = 0;\n        }\n\n        /* If a HAVING clause is present, then there must be a GROUP BY clause.\n        */\n        if ( p.pHaving != null && pGroupBy == null )\n        {\n          sqlite3ErrorMsg( pParse, "a GROUP BY clause is required before HAVING" );\n          return WRC_Abort;\n        }\n\n        /* Add the expression list to the name-context before parsing the\n        ** other expressions in the SELECT statement. This is so that\n        ** expressions in the WHERE clause (etc.) can refer to expressions by\n        ** aliases in the result set.\n        **\n        ** Minor point: If this is the case, then the expression will be\n        ** re-evaluated for each reference to it.\n        */\n        sNC.pEList = p.pEList;\n        if ( sqlite3ResolveExprNames( sNC, ref p.pWhere ) != 0 ||\n        sqlite3ResolveExprNames( sNC, ref p.pHaving ) != 0\n        )\n        {\n          return WRC_Abort;\n        }\n\n        /* The ORDER BY and GROUP BY clauses may not refer to terms in\n        ** outer queries\n        */\n        sNC.pNext = null;\n        sNC.allowAgg = 1;\n\n        /* Process the ORDER BY clause for singleton SELECT statements.\n        ** The ORDER BY clause for compounds SELECT statements is handled\n        ** below, after all of the result-sets for all of the elements of\n        ** the compound have been resolved.\n        */\n        if ( !isCompound && resolveOrderGroupBy( sNC, p, p.pOrderBy, "ORDER" ) != 0 )\n        {\n          return WRC_Abort;\n        }\n        //if ( db.mallocFailed != 0 )\n        //{\n        //  return WRC_Abort;\n        //}\n\n        /* Resolve the GROUP BY clause.  At the same time, make sure\n        ** the GROUP BY clause does not contain aggregate functions.\n        */\n        if ( pGroupBy != null )\n        {\n          ExprList_item pItem;\n\n          if ( resolveOrderGroupBy( sNC, p, pGroupBy, "GROUP" ) != 0 /*|| db.mallocFailed != 0 */ )\n          {\n            return WRC_Abort;\n          }\n          for ( i = 0 ; i < pGroupBy.nExpr ; i++ )//, pItem++)\n          {\n            pItem = pGroupBy.a[i];\n            if ( ( pItem.pExpr.flags & EP_Agg ) != 0 )//HasProperty(pItem.pExpr, EP_Agg) )\n            {\n              sqlite3ErrorMsg( pParse, "aggregate functions are not allowed in " +\n              "the GROUP BY clause" );\n              return WRC_Abort;\n            }\n          }\n        }\n\n        /* Advance to the next term of the compound\n        */\n        p = p.pPrior;\n        nCompound++;\n      }\n\n      /* Resolve the ORDER BY on a compound SELECT after all terms of\n      ** the compound have been resolved.\n      */\n      if ( isCompound && resolveCompoundOrderBy( pParse, pLeftmost ) != 0 )\n      {\n        return WRC_Abort;\n      }\n\n      return WRC_Prune;\n    }\n\n    /*\n    ** This routine walks an expression tree and resolves references to\n    ** table columns and result-set columns.  At the same time, do error\n    ** checking on function usage and set a flag if any aggregate functions\n    ** are seen.\n    **\n    ** To resolve table columns references we look for nodes (or subtrees) of the\n    ** form X.Y.Z or Y.Z or just Z where\n    **\n    **      X:   The name of a database.  Ex:  "main" or "temp" or\n    **           the symbolic name assigned to an ATTACH-ed database.\n    **\n    **      Y:   The name of a table in a FROM clause.  Or in a trigger\n    **           one of the special names "old" or "new".\n    **\n    **      Z:   The name of a column in table Y.\n    **\n    ** The node at the root of the subtree is modified as follows:\n    **\n    **    Expr.op        Changed to TK_COLUMN\n    **    Expr.pTab      Points to the Table object for X.Y\n    **    Expr.iColumn   The column index in X.Y.  -1 for the rowid.\n    **    Expr.iTable    The VDBE cursor number for X.Y\n    **\n    **\n    ** To resolve result-set references, look for expression nodes of the\n    ** form Z (with no X and Y prefix) where the Z matches the right-hand\n    ** size of an AS clause in the result-set of a SELECT.  The Z expression\n    ** is replaced by a copy of the left-hand side of the result-set expression.\n    ** Table-name and function resolution occurs on the substituted expression\n    ** tree.  For example, in:\n    **\n    **      SELECT a+b AS x, c+d AS y FROM t1 ORDER BY x;\n    **\n    ** The "x" term of the order by is replaced by "a+b" to render:\n    **\n    **      SELECT a+b AS x, c+d AS y FROM t1 ORDER BY a+b;\n    **\n    ** Function calls are checked to make sure that the function is\n    ** defined and that the correct number of arguments are specified.\n    ** If the function is an aggregate function, then the pNC.hasAgg is\n    ** set and the opcode is changed from TK_FUNCTION to TK_AGG_FUNCTION.\n    ** If an expression contains aggregate functions then the EP_Agg\n    ** property on the expression is set.\n    **\n    ** An error message is left in pParse if anything is amiss.  The number\n    ** if errors is returned.\n    */\n    static int sqlite3ResolveExprNames(\n    NameContext pNC,       /* Namespace to resolve expressions in. */\n    ref Expr pExpr         /* The expression to be analyzed. */\n    )\n    {\n      u8 savedHasAgg;\n      Walker w = new Walker();\n\n      if ( pExpr == null ) return 0;\n#if SQLITE_MAX_EXPR_DEPTH//>0\n{\nParse pParse = pNC.pParse;\nif( sqlite3ExprCheckHeight(pParse, pExpr.nHeight+pNC.pParse.nHeight) ){\nreturn 1;\n}\npParse.nHeight += pExpr.nHeight;\n}\n#endif\n      savedHasAgg = pNC.hasAgg;\n      pNC.hasAgg = 0;\n      w.xExprCallback = resolveExprStep;\n      w.xSelectCallback = resolveSelectStep;\n      w.pParse = pNC.pParse;\n      w.u.pNC = pNC;\n      sqlite3WalkExpr( w, ref pExpr );\n#if SQLITE_MAX_EXPR_DEPTH//>0\npNC.pParse.nHeight -= pExpr.nHeight;\n#endif\n      if ( pNC.nErr > 0 || w.pParse.nErr > 0 )\n      {\n        ExprSetProperty( pExpr, EP_Error );\n      }\n      if ( pNC.hasAgg != 0 )\n      {\n        ExprSetProperty( pExpr, EP_Agg );\n      }\n      else if ( savedHasAgg != 0 )\n      {\n        pNC.hasAgg = 1;\n      }\n      return ExprHasProperty( pExpr, EP_Error ) ? 1 : 0;\n    }\n\n\n    /*\n    ** Resolve all names in all expressions of a SELECT and in all\n    ** decendents of the SELECT, including compounds off of p.pPrior,\n    ** subqueries in expressions, and subqueries used as FROM clause\n    ** terms.\n    **\n    ** See sqlite3ResolveExprNames() for a description of the kinds of\n    ** transformations that occur.\n    **\n    ** All SELECT statements should have been expanded using\n    ** sqlite3SelectExpand() prior to invoking this routine.\n    */\n    static void sqlite3ResolveSelectNames(\n    Parse pParse,         /* The parser context */\n    Select p,             /* The SELECT statement being coded. */\n    NameContext pOuterNC  /* Name context for parent SELECT statement */\n    )\n    {\n      Walker w = new Walker();\n\n      Debug.Assert( p != null );\n      w.xExprCallback = resolveExprStep;\n      w.xSelectCallback = resolveSelectStep;\n      w.pParse = pParse;\n      w.u.pNC = pOuterNC;\n      sqlite3WalkSelect( w, p );\n    }\n  }\n}\n'