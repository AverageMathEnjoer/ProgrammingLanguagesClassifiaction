b'#include <bits/stdc++.h>\nusing namespace std;\n#define gc getchar_unlocked\n#define fo(i,n) for(i=0;i<n;i++)\n#define Fo(i,k,n) for(i=k;i<n;i++)\n#define ll long long\n#define si(x)\tscanf("%d",&x)\n#define sl(x)\tscanf("%I64d",&x)\n#define ss(s)\tscanf("%s",s)\n#define pb push_back\n#define mp make_pair\n#define F first\n#define S second\n#define clr(x) memset(x, 0, sizeof(x))\n#define tr(it, a) for(auto it = a.begin(); it != a.end(); it++)\n#define PI 3.1415926535897932384626\ntypedef pair<int, int>\tpii;\ntypedef pair<ll, ll>\tpll;\ntypedef vector<int>\t\tvi;\ntypedef vector<ll>\t\tvl;\ntypedef vector<pii>\t\tvpii;\ntypedef vector<pll>\t\tvpll;\ntypedef vector<vi>\t\tvvi;\ntypedef vector<vl>\t\tvvl;\nconst int mod = 1000000007;\nconst int N = 2e5;\nvi g[N];\nint a[N];\n//Takes query values in increasing order\n//Add lines in sorted order\nclass ConvexHull{\n\tint ptr;\n\ttypedef pii Line;\n\tvector<Line> lines;\n\tpublic:\n\t\tConvexHull(){\n\t\t\tptr = 0;\n\t\t\tlines.clear();\n\t\t}\n\t\tint f(Line l, int x){\n\t\t\treturn l.F*x+l.S;\n\t\t}\n\t\tbool bad(Line l1, Line l2, Line l3){\n\t\t\treturn (l3.S-l1.S)*(l1.F-l2.F) <= (l1.F-l3.F)*(l2.S-l1.S);\n\t\t}\n\t\tvoid addLine(Line l3){\n\t\t\tlines.pb(l3);\n\t\t\twhile(lines.size()>=3){\n\t\t\t\tint tot = lines.size();\n\t\t\t\tLine l3 = lines[tot-1];\n\t\t\t\tLine l2 = lines[tot-2];\n\t\t\t\tLine l1 = lines[tot-3];\n\t\t\t\tif (bad(l1, l2, l3)){\n\t\t\t\t\tlines.erase(lines.end()-2);\n\t\t\t\t}\n\t\t\t\telse break;\n\t\t\t}\n\t\t}\n\t\t//Returns Minimum \n\t\t//Query values must be in non-decreasing order\n\t\t//Otherwise use Binary Search (Maintain the end points of lines)\n\t\tint get(int x){\n\t\t\tif (ptr >= lines.size()) ptr = lines.size()-1;\n\t\t\twhile(ptr < lines.size()-1 and f(lines[ptr], x) > f(lines[ptr+1], x))\n\t\t\t\tptr++;\n\t\t\treturn f(lines[ptr], x);\n\t\t}\n};\n//END\nbool f(pii a, pii b){\n\tif (a.F != b.F) return a.F > b.F;\n\treturn a.S < b.S;\n}\nint main()\n{\n\tios_base::sync_with_stdio(false);\n\tcin.tie(NULL);\n\tint i,n;\n\tvpii data;\n\tcin>>n;\n\tfo(i, n){\n\t\tint m, c;\n\t\tcin>>m>>c;\n\t\tdata.pb({m, c});\n\t}\n\tsort(data.begin(), data.end(), f);\n\tConvexHull A;\n\tfo(i, n) A.addLine(data[i]);\n\tcin>>n;\n\tvi points;\n\tfo(i, n){\n\t\tint x;\n\t\tcin>>x;\n\t\tpoints.pb(x);\n\t}\n\tsort(points.begin(), points.end());\n\tfor(int x: points)\n\t\tcout<<x<<" "<<A.get(x)<<endl;\n\n\t\n\treturn 0;\n} \n\n\n'