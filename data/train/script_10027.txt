b'{-# LANGUAGE AllowAmbiguousTypes #-}\n{-# LANGUAGE CPP #-}\n\n-- | Definitions of interest to those implement a new beam backend.\n--\n-- Steps to defining a beam backend:\n--\n--   1. Ensure the command syntax for your backend satisfies \'Sql92SaneDdlCommandSyntax\'.\n--   2. Create a value of type \'BeamMigrationBackend\'\n--   3. For compatibility with @beam-migrate-cli@, export this value in an\n--      exposed module with the name \'migrationBackend\'.\n--\n-- This may sound trivial, but it\'s a bit more involved. In particular, in order\n-- to complete step 2, you will have to define several instances for some of\n-- your syntax pieces (for example, data types and constraints will need to be\n-- \'Hashable\'). You will also need to provide a reasonable function to fetch\n-- predicates from your database, and a function to convert all these predicates\n-- to corresponding predicates in the Haskell syntax. If you have custom data\n-- types or predicates, you will need to supply \'BeamDeserializers\' to\n-- deserialize them from JSON. Finally, if your backend has custom\n-- \'DatabasePredicate\'s you will have to provide appropriate \'ActionProvider\'s\n-- to discover potential actions for your backend. See the documentation for\n-- "Database.Beam.Migrate.Actions" for more information.\n--\n-- Tools may be interested in the \'SomeBeamMigrationBackend\' data type which\n-- provides a monomorphic type to wrap the polymorphic \'BeamMigrationBackend\'\n-- type. Currently, @beam-migrate-cli@ uses this type to get the underlying\n-- \'BeamMigrationBackend\' via the @hint@ package.\n--\n-- For an example migrate backend, see "Database.Beam.Sqlite.Migrate"\nmodule Database.Beam.Migrate.Backend\n  ( BeamMigrationBackend(..)\n  , DdlError\n\n  -- * Haskell predicate conversion\n  , HaskellPredicateConverter(..)\n  , sql92HsPredicateConverters\n  , hasColumnConverter\n  , trivialHsConverter, hsPredicateConverter\n\n  -- * For tooling authors\n  , SomeBeamMigrationBackend(..), SomeCheckedDatabaseSettings(..) )\nwhere\n\nimport           Database.Beam\nimport           Database.Beam.Backend.SQL\nimport           Database.Beam.Migrate.Actions\nimport           Database.Beam.Migrate.Checks\nimport           Database.Beam.Migrate.Serialization\nimport           Database.Beam.Migrate.SQL\nimport           Database.Beam.Migrate.Types\n  ( SomeDatabasePredicate(..), CheckedDatabaseSettings )\n\nimport           Database.Beam.Haskell.Syntax\n\nimport           Control.Applicative\nimport qualified Control.Monad.Fail as Fail\n\n#if ! MIN_VERSION_base(4,11,0)\nimport           Data.Semigroup\n#endif\nimport           Data.Text (Text)\nimport           Data.Time\n\nimport           Data.Typeable\n\n-- | Type of errors that can be thrown by backends during DDL statement\n-- execution. Currently just a synonym for \'String\'\ntype DdlError = String\n\n-- | Backends should create a value of this type and export it in an exposed\n-- module under the name \'migrationBackend\'. See the module documentation for\n-- more details.\ndata BeamMigrationBackend be m where\n  BeamMigrationBackend ::\n    ( MonadBeam be m\n    , Fail.MonadFail m\n    , HasQBuilder be\n    , BeamMigrateSqlBackend be\n    , HasDataTypeCreatedCheck (BeamMigrateSqlBackendDataTypeSyntax be)\n    , BeamSqlBackendCanSerialize be LocalTime\n    , BeamSqlBackendCanSerialize be (Maybe LocalTime)\n    , BeamSqlBackendCanSerialize be Text\n    , BeamSqlBackendCanSerialize be SqlNull\n    , Sql92ReasonableMarshaller be ) =>\n    { backendName :: String\n    , backendConnStringExplanation :: String\n    , backendGetDbConstraints :: m [ SomeDatabasePredicate ]\n    , backendPredicateParsers :: BeamDeserializers be\n    , backendRenderSyntax :: BeamSqlBackendSyntax be -> String\n    , backendFileExtension :: String\n    , backendConvertToHaskell :: HaskellPredicateConverter\n    , backendActionProvider :: ActionProvider be\n    , backendTransact :: forall a. String -> m a -> IO (Either DdlError a)\n    } -> BeamMigrationBackend be m\n\n-- | Monomorphic wrapper for use with plugin loaders that cannot handle\n-- polymorphism\ndata SomeBeamMigrationBackend where\n  SomeBeamMigrationBackend :: Typeable be\n                           => BeamMigrationBackend be m\n                           -> SomeBeamMigrationBackend\n\n-- | Monomorphic wrapper to use when interpreting a module which\n-- exports a \'CheckedDatabaseSettings\'.\ndata SomeCheckedDatabaseSettings where\n  SomeCheckedDatabaseSettings :: Database be db => CheckedDatabaseSettings be db\n                              -> SomeCheckedDatabaseSettings\n\n-- | In order to support Haskell schema generation, backends need to provide a\n-- way to convert arbitrary \'DatabasePredicate\'s generated by the backend\'s\n-- \'backendGetDbConstraints\' function into appropriate predicates in the Haskell\n-- syntax. Not all predicates have any meaning when translated to Haskell, so\n-- backends can choose to drop any predicate (simply return \'Nothing\').\nnewtype HaskellPredicateConverter\n  = HaskellPredicateConverter (SomeDatabasePredicate -> Maybe SomeDatabasePredicate)\n\ninstance Semigroup HaskellPredicateConverter where\n  (<>) = mappend\n\n-- | \'HaskellPredicateConverter\'s can be combined monoidally.\ninstance Monoid HaskellPredicateConverter where\n  mempty = HaskellPredicateConverter $ \\_ -> Nothing\n  mappend (HaskellPredicateConverter a) (HaskellPredicateConverter b) =\n    HaskellPredicateConverter $ \\r -> a r <|> b r\n\n-- | Converters for the \'TableExistsPredicate\', \'TableHasPrimaryKey\', and\n-- \'TableHasColumn\' (when supplied with a function to convert a backend data\n-- type to a haskell one).\nsql92HsPredicateConverters :: forall fromBe\n                             . Typeable fromBe\n                            => (BeamMigrateSqlBackendDataTypeSyntax fromBe -> Maybe HsDataType)\n                            -> HaskellPredicateConverter\nsql92HsPredicateConverters convType =\n  trivialHsConverter @TableExistsPredicate <>\n  trivialHsConverter @TableHasPrimaryKey   <>\n  hasColumnConverter @fromBe convType\n\n-- | Converter for \'TableHasColumn\', when given a function to convert backend\n-- data type to a haskell one.\nhasColumnConverter :: forall fromBe\n                    . Typeable fromBe\n                   => (BeamMigrateSqlBackendDataTypeSyntax fromBe -> Maybe HsDataType)\n                   -> HaskellPredicateConverter\nhasColumnConverter convType =\n  hsPredicateConverter $\n  \\(TableHasColumn tbl col ty :: TableHasColumn fromBe) ->\n    fmap SomeDatabasePredicate (TableHasColumn tbl col <$> convType ty :: Maybe (TableHasColumn HsMigrateBackend))\n\n-- | Some predicates have no dependence on a backend. For example, \'TableExistsPredicate\' has no parameters that\n-- depend on the backend. It can be converted straightforwardly:\n--\n-- @\n-- trivialHsConverter @TableExistsPredicate\n-- @\ntrivialHsConverter :: forall pred. Typeable pred => HaskellPredicateConverter\ntrivialHsConverter =\n  HaskellPredicateConverter $ \\orig@(SomeDatabasePredicate p\') ->\n  case cast p\' of\n    Nothing -> Nothing\n    Just (_ :: pred) -> Just orig\n\n-- | Utility function for converting a monomorphically typed predicate to a\n-- haskell one.\nhsPredicateConverter :: Typeable pred => (pred -> Maybe SomeDatabasePredicate) -> HaskellPredicateConverter\nhsPredicateConverter f =\n  HaskellPredicateConverter $ \\(SomeDatabasePredicate p\') ->\n  case cast p\' of\n    Nothing -> Nothing\n    Just p\'\' -> f p\'\'\n\n'