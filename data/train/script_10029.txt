b'import System.Environment (getArgs)\n\nnotElem\' :: Eq a => [a] -> a -> Bool\nnotElem\' a n = notElem n a\n\n(\\\\) :: Eq a => [a] -> [a] -> [a]\nus \\\\ vs = filter (notElem\' vs) us\n\nnub\' :: Ord a => [a] -> [a]\nnub\' [] = []\nnub\' (x:xs) = if notElem x xs then x : nub\' xs \n              else (x : nub\' (xs \\\\ [x])) `min` (nub\' xs)\n\nnub\'\' :: Ord a => [a] -> [a]\nnub\'\' = hub []\n\nhub :: Ord a => [a] -> [a] -> [a]\nhub ws []       = []\nhub ws (x:xs)   = case (x `elem` xs, x `elem` ws) of\n                    (False, False)  -> us ++ [x] ++ hub [] (xs\\\\us) \n                    (False,True)    -> us ++ [x] ++ hub (tail vs) (xs\\\\us) \n                    (True, False)   -> hub (us ++ [x]) xs\n                    (True, True)    -> hub ws xs\n                  where (us, vs) = span (< x) ws\n\nmain = do\n    args <- getArgs\n    let word = case args of\n                    [] -> "calculus"\n                    (x:_) -> x\n    putStrLn $ show $ nub\'\' word\n\n\n'