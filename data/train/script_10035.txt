b"\n// -----------------------------------------------------------------------\n// Licensed to The .NET Foundation under one or more agreements.\n// The .NET Foundation licenses this file to you under the MIT license.\n// -----------------------------------------------------------------------\n//\n// CCob (@_EthicalChaos_) -     Updated slightly from original Kerberos.NET version to use BigInteger\n//                              from Mono library and not .NET, since System.Numerics is only available\n//                              since .NET 4.0+.  Also switched to raw byte arrays for .NET 2.0+ compatibility.   \n//                              Mono's internal representation of data is in also in big endian format\n//                              so this class had to be updated to reflect that as .NET's BigInteger is little endian.\n//                              We are not particular bothered about security correctness of using ManagedDiffieHellman\n//                              as long as we can use it to calculate a valid shared secret from the KDC.\n//\n\nusing Mono.Math;\nusing System;\nusing System.Linq;\nusing System.Security.Cryptography;\n\nnamespace Kerberos.NET.Crypto {\n    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    //\n    // DO NOT USE THIS\n    //\n    // THIS IS NOT PRODUCTION-WORTHY CODE\n    // IT IS UNSAFE AND UNTESTED\n    //\n    // DO NOT USE THIS\n    //\n    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n    /// <summary>\n    /// DO NOT USE THIS\n    ///\n    /// THIS IS NOT PRODUCTION-WORTHY CODE\n    /// IT IS UNSAFE AND UNTESTED\n    ///\n    /// DO NOT USE THIS\n    /// </summary>\n    public abstract class ManagedDiffieHellman : IKeyAgreement\n    {\n        private readonly int keyLength;\n\n        private readonly BigInteger prime;\n        private readonly BigInteger generator;\n        private readonly BigInteger factor;\n        private readonly BigInteger x;\n\n        private readonly BigInteger y;\n\n        private BigInteger partnerKey;\n        private bool disposedValue;\n\n        public ManagedDiffieHellman(byte[] prime, byte[] generator, byte[] factor)\n        {\n            this.keyLength = prime.Length;\n\n            this.prime = ParseBigInteger(prime);\n            this.generator = ParseBigInteger(generator);\n            this.factor = ParseBigInteger(factor);\n\n            this.x = this.GeneratePrime();\n\n            this.y = this.generator.ModPow(this.x, this.prime);\n\n            this.PublicKey = new DiffieHellmanKey\n            {\n                Type = AsymmetricKeyType.Public,\n                Generator = this.Depad(this.generator.GetBytes()),\n                Modulus = this.Depad(this.prime.GetBytes()),\n                PublicComponent = this.Depad(this.y.GetBytes()),\n                Factor = this.Depad(this.factor.GetBytes()),\n                KeyLength = prime.Length\n            };\n\n            this.PrivateKey = new DiffieHellmanKey\n            {\n                Type = AsymmetricKeyType.Private,\n                Generator = this.Depad(this.generator.GetBytes()),\n                Modulus = this.Depad(this.prime.GetBytes()),\n                PublicComponent = this.Depad(this.y.GetBytes()),\n                Factor = this.Depad(this.factor.GetBytes()),\n                PrivateComponent = this.Depad(this.x.GetBytes()),\n                KeyLength = prime.Length\n            };\n        }\n\n        private BigInteger GeneratePrime()\n        {\n            // RSA's P and Q parameters are prime, but len(P+Q) = keylength\n            // so generate an RSA key twice as large as required and just\n            // use P as the prime.\n\n            // P in RSA is a safer prime than primes used in DH so it's\n            // good enough here, though it's costlier to generate.\n\n            using (var alg = new RSACryptoServiceProvider(this.keyLength * 2 * 8))\n            {\n                var rsa = alg.ExportParameters(true);\n\n                return ParseBigInteger(rsa.P.Reverse().ToArray());\n            }\n        }\n\n        private static BigInteger ParseBigInteger(byte[] arr)\n        {\n            var pv = arr;\n\n            if (pv[0] != 0)\n            {\n                var copy = new byte[pv.Length + 1];\n\n                pv.CopyTo(copy, 1);\n\n                pv = copy;\n            }\n\n            return new BigInteger(pv);\n        }\n\n        public IExchangeKey PublicKey { get; }\n\n        public IExchangeKey PrivateKey { get; }\n\n        public byte[] GenerateAgreement()\n        {\n            var z = this.partnerKey.ModPow(this.x, this.prime);\n\n            var ag = z.GetBytes().ToArray();\n\n            var agreement = this.Depad(ag);\n\n            agreement = Pad(agreement, this.keyLength);\n\n            return agreement;\n        }\n\n        public void ImportPartnerKey(IExchangeKey publicKey)\n        {\n            if (publicKey == null)\n            {\n                throw new ArgumentNullException(nameof(publicKey));\n            }\n\n            this.partnerKey = ParseBigInteger(publicKey.PublicComponent);\n        }\n\n        private byte[] Depad(byte[] data)\n        {\n            int leadingZeros;\n\n            for(leadingZeros = 0; leadingZeros < data.Length; ++leadingZeros) {                \n                if(!(data[leadingZeros] == 0 && data.Length > this.keyLength)) {\n                    break;\n                }\n            }\n\n            byte[] result = new byte[data.Length - leadingZeros];\n\n            Array.Copy(data, leadingZeros, result, 0, result.Length);\n\n            return result;\n        }\n\n        private static byte[] Pad(byte[] agreement, int keyLength)\n        {\n            var copy = new byte[keyLength];\n\n            agreement.CopyTo(copy, keyLength - agreement.Length);\n\n            return copy;\n        }\n\n        protected virtual void Dispose(bool disposing)\n        {\n            if (!this.disposedValue)\n            {\n                this.disposedValue = true;\n            }\n        }\n\n        public void Dispose()\n        {\n            this.Dispose(disposing: true);\n            GC.SuppressFinalize(this);\n        }\n    }\n}"