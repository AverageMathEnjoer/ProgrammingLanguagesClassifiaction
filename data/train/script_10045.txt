b'//http://codeforces.com/contest/716/problem/E\n#include <bits/stdc++.h>\nusing namespace std;\n#define gc getchar_unlocked\n#define fo(i,n) for(i=0;i<n;i++)\n#define Fo(i,k,n) for(i=k;i<n;i++)\n#define ll long long\n#define si(x)\tscanf("%d",&x)\n#define sl(x)\tscanf("%I64d",&x)\n#define ss(s)\tscanf("%s",s)\n#define pb push_back\n#define mp make_pair\n#define F first\n#define S second\n#define all(x) x.begin(), x.end()\n#define clr(x) memset(x, 0, sizeof(x))\n#define sortall(x) sort(all(x))\n#define tr(it, a) for(auto it = a.begin(); it != a.end(); it++)\n#define PI 3.1415926535897932384626\ntypedef pair<int, int>\tpii;\ntypedef pair<ll, ll>\tpll;\ntypedef vector<int>\t\tvi;\ntypedef vector<ll>\t\tvl;\ntypedef vector<pii>\t\tvpii;\ntypedef vector<pll>\t\tvpll;\ntypedef vector<vi>\t\tvvi;\ntypedef vector<vl>\t\tvvl;\nint mod ;\nconst int N = 3e5;\nvpii g[N];\nvi cur;\nint part;\nint a[N], gvis[N], lvl[N], stree[N];\nll up[N], down[N], sz[N];\nint prime[N];\nvl primes;\nll inv;\n\nint mpow(int base, int exp);\nll PHI;\nll add(ll a, ll b);\nll mul(ll a, ll b);\nvoid seive();\nint phi(int n);\nvoid dfs(int u, int par){\n    //add u to current tree\n    if (par == 0) cur.clear();\n    cur.pb(u);\n    lvl[u] = 1+lvl[par];\n    sz[u] = 1;\n    for(pii it: g[u]){\n        int v = it.F;\n        if (gvis[v] or v == par) continue;\n        dfs(v, u);\n        sz[u] += sz[v];\n    }\n}\nint centroid(int u, int par){\n\n    for(auto it: g[u]){\n        int v = it.F;\n        if ( v == par or gvis[v]) continue;\n        if (2*sz[v] > (int)cur.size()) return centroid(v, u);\n    }\n    return u;\n}\nvoid go(int u, int par, int cen){\n    lvl[u] = 1+lvl[par];\n    if(par == cen){\n        stree[u] = part++;\n    }\n    else {\n        stree[u] = stree[par];\n    }\n    for(auto it: g[u]){\n        int v = it.F, w = it.S;\n        if (v == par or gvis[v]) continue;\n        down[v] = add( mul(10, down[u]), w);\n        up[v] = add(up[u], mul(w, mpow(10, lvl[u])));\n        go(v, u, cen);\n    }\n}\nmap<int, int> cnt, st[N];\nll solvefor(int cen){\n    int i;\n    //solve for centroid\n    //init current parts of subtree\n    part = 0;\n\n\n    //make centroid as root\n    //find levels\n\n    //find up down values\n    up[cen] = down[cen] = 0;\n    stree[0] = N-1;\n    go(cen, 0, cen);\n\n    //precalculate the maps\n    cnt.clear();\n    fo(i, part) st[i].clear();\n\n    //traverse only the current nodes in present tree\n    for(int u: cur) cnt[up[u]]++, st[stree[u]][up[u]]++;\n\n\n    //calculate ans\n    ll ans = 0;\n    for(int u: cur){\n        if (u == cen){\n            ans += cnt[0]-1;\n        }\n        else{\n            ll val = mul((mod-(down[u]%mod))%mod, mpow(mpow(10, lvl[u]), PHI-1));\n            ans += cnt[val] - st[stree[u]][val];\n        }\n\n    }\n\n    return ans;\n}\nll solve(int u){\n    //dfs to calculate centroid\n    dfs(u, 0);\n    //find centroid of current tree\n    int cen = centroid(u, 0);\n    ll ans = solvefor(cen);\n    //mark cen done in global visited\n    //handles centroid decomposition later on\n    gvis[cen] = 1;\n    for(auto it: g[cen])\n        if (!gvis[it.F])\n            ans += solve(it.F);\n    return ans;\n}\nint main()\n{\n\tios_base::sync_with_stdio(false);\n\tcin.tie(NULL);\n\tint i,n,k,j, u, v, w;\n\tint t;\n\tcin>>n>>mod;\n\tseive();\n\tfo(i, n-1){\n        cin>>u>>v>>w;\n        u++, v++;\n        g[u].pb({v, w});\n        g[v].pb({u, w});\n\t}\n\tlvl[0] = -1;\n\tPHI = phi(mod);\n\tll ans = solve(1);\n\tcout<<ans<<endl;\n\n\treturn 0;\n}\n\nint mpow(int base, int exp) {\nbase %= mod;\nint result = 1;\nwhile (exp > 0) {\nif (exp & 1) result = ((ll)result * base) % mod;\nbase = ((ll)base * base) % mod;\nexp >>= 1;\n}\nreturn result;\n}\n\nvoid seive(){\n    ll i;\n    Fo(i, 1, N) prime[i] = i;\n    for(i=2; i*i < N; i++){\n        if (prime[i] == i){\n            primes.pb(i);\n            for(ll j = 2*i; j < N; j += i)\n                if (prime[j] == j)\n                    prime[j] = i;\n        }\n    }\n}\nint phi(int n){\n    int n1, n2;\n    n2 = n; n1 = 1;\n    int i = 0;\n    while(i<(int)primes.size() and  primes[i]*primes[i] <= n){\n        if (n % primes[i] == 0){\n            while(n % primes[i] == 0) n /= primes[i];\n            n2 /= primes[i];\n            n1 *= primes[i]-1;\n        }\n        i++;\n    }\n    if (n>1){\n        n2 /= n;\n        n1 *= n-1;\n    }\n    return n1*n2;\n}\nll add(ll a, ll b){\n    a += b;\n    return a%mod;\n}\nll mul(ll a, ll b){\n    a *= b;\n    return a%mod;\n}\n\n'