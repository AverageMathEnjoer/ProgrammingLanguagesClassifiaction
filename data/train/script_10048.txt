b'module Rest.Gen\n  ( generate\n  ) where\n\nimport Data.Char\nimport Data.Foldable\nimport Data.Label\nimport Data.Maybe\nimport System.Directory\nimport System.Exit\nimport System.Process\nimport qualified Language.Haskell.Exts.Syntax as H\n\nimport Rest.Api (Api, Some1 (..), withVersion)\n\nimport Rest.Gen.Config\nimport Rest.Gen.Docs (DocsContext (DocsContext), writeDocs)\nimport Rest.Gen.Haskell (HaskellContext (HaskellContext), mkHsApi)\nimport Rest.Gen.JavaScript (mkJsApi)\nimport Rest.Gen.Ruby (mkRbApi)\nimport Rest.Gen.Types\nimport Rest.Gen.Utils\nimport qualified Rest.Gen.NoAnnotation as N\n\ngenerate :: Config -> String -> Api m -> [N.ModuleName] -> [N.ImportDecl] -> [(N.ModuleName, N.ModuleName)] -> IO ()\ngenerate config name api sources imports rewrites =\n  withVersion (get apiVersion config) api (putStrLn "Could not find api version" >> exitFailure) $ \\ver (Some1 r) ->\n     case get action config of\n       Just (MakeDocs root) ->\n         do loc <- getTargetDir config "./docs"\n            setupTargetDir config loc\n            let context = DocsContext root ver (fromMaybe "./templates" (getSourceLocation config))\n            writeDocs context r loc\n            exitSuccess\n       Just MakeJS          -> mkJsApi (overModuleName (++ "Api") moduleName) (get apiPrivate config) ver r >>= toTarget config\n       Just MakeRb          -> mkRbApi (overModuleName (++ "Api") moduleName) (get apiPrivate config) ver r >>= toTarget config\n       Just MakeHS          ->\n         do loc <- getTargetDir config "./client"\n            setupTargetDir config loc\n            let context = HaskellContext ver loc (packageName ++ "-client") (get apiPrivate config) sources imports rewrites [unModuleName moduleName, "Client"]\n            mkHsApi context r\n            exitSuccess\n       Nothing              -> return ()\n  where\n    packageName = map toLower name\n    moduleName  = H.ModuleName () $ upFirst packageName\n\ngetTargetDir :: Config -> String -> IO String\ngetTargetDir config str =\n  case get target config of\n    Stream     -> putStrLn ("Cannot generate documentation to stdOut, generating to " ++ str) >> return str\n    Default    -> putStrLn ("Generating to " ++ str) >> return str\n    Location d -> putStrLn ("Generating to " ++ d) >> return d\n\nsetupTargetDir :: Config -> String -> IO ()\nsetupTargetDir config t =\n  do createDirectoryIfMissing True t\n     forM_ (getSourceLocation config) $ \\s -> system $ "cp -rf " ++ s ++ " " ++ t\n\ntoTarget :: Config -> String -> IO ()\ntoTarget config code =\n  do let outf =\n           case get target config of\n             Stream     -> putStrLn\n             Default    -> putStrLn\n             Location l -> writeFile l\n     outf code\n     exitSuccess\n\ngetSourceLocation :: Config -> Maybe String\ngetSourceLocation config =\n  case get source config of\n    Location s -> Just s\n    _          -> Nothing\n'