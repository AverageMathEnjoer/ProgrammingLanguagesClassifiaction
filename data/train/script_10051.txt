b'/*\n    SPDX-FileCopyrightText: 2018 Milian Wolff <mail@milianw.de>\n\n    SPDX-License-Identifier: LGPL-2.1-or-later\n*/\n\n#include "3rdparty/catch.hpp"\n#include "track/libheaptrack.h"\n#include "util/linewriter.h"\n\n#include <cstdio>\n#include <cmath>\n\n#include <thread>\n#include <future>\n#include <vector>\n#include <iostream>\n\n#include "tempfile.h"\n\nbool initBeforeCalled = false;\nbool initAfterCalled = false;\nbool stopCalled = false;\n\nusing namespace std;\n\nTEST_CASE ("api") {\n    TempFile tmp; // opened/closed by heaptrack_init\n\n    SECTION ("init") {\n        heaptrack_init(tmp.fileName.c_str(),\n                       []() {\n                           REQUIRE(!initBeforeCalled);\n                           REQUIRE(!initAfterCalled);\n                           REQUIRE(!stopCalled);\n                           initBeforeCalled = true;\n                       },\n                       [](LineWriter& out) {\n                           REQUIRE(initBeforeCalled);\n                           REQUIRE(!initAfterCalled);\n                           REQUIRE(!stopCalled);\n                           initAfterCalled = true;\n                       },\n                       []() {\n                           REQUIRE(initBeforeCalled);\n                           REQUIRE(initAfterCalled);\n                           REQUIRE(!stopCalled);\n                           stopCalled = true;\n                       });\n\n        REQUIRE(initBeforeCalled);\n        REQUIRE(initAfterCalled);\n        REQUIRE(!stopCalled);\n\n        int data[2] = {0};\n\n        SECTION ("no-op-malloc") {\n            heaptrack_malloc(0, 0);\n        }\n        SECTION ("no-op-malloc-free") {\n            heaptrack_free(0);\n        }\n        SECTION ("no-op-malloc-realloc") {\n            heaptrack_realloc(data, 1, 0);\n        }\n\n        SECTION ("malloc-free") {\n            heaptrack_malloc(data, 4);\n            heaptrack_free(data);\n        }\n\n        SECTION ("realloc") {\n            heaptrack_malloc(data, 4);\n            heaptrack_realloc(data, 8, data);\n            heaptrack_realloc(data, 16, data + 1);\n            heaptrack_free(data + 1);\n        }\n\n        SECTION ("invalidate-cache") {\n            heaptrack_invalidate_module_cache();\n        }\n\n        SECTION ("multi-threaded") {\n            const auto numThreads = min(4u, thread::hardware_concurrency());\n\n            cout << "start threads" << endl;\n            {\n                vector<future<void>> futures;\n                for (unsigned i = 0; i < numThreads; ++i) {\n                    futures.emplace_back(async(launch::async, [](){\n                        for (int i = 0; i < 10000; ++i) {\n                            heaptrack_malloc(&i, i);\n                            heaptrack_realloc(&i, i + 1, &i);\n                            heaptrack_free(&i);\n                            if (i % 100 == 0) {\n                                heaptrack_invalidate_module_cache();\n                            }\n                        }\n                    }));\n                }\n            }\n            cout << "threads finished" << endl;\n        }\n\n        SECTION ("stop") {\n            heaptrack_stop();\n            REQUIRE(stopCalled);\n        }\n    }\n}\n'