b'{-# LANGUAGE DuplicateRecordFields #-}\n\nmodule Main\n  ( main,\n  )\nwhere\n\nimport Cachix.API.Error (escalateAs)\nimport qualified Cachix.API.WebSocketSubprotocol as AgentInformation (AgentInformation (..))\nimport qualified Cachix.API.WebSocketSubprotocol as DeploymentDetails (DeploymentDetails (..))\nimport qualified Cachix.API.WebSocketSubprotocol as WSS\nimport qualified Cachix.Client.URI as URI\nimport qualified Cachix.Deploy.Activate as Activate\nimport qualified Cachix.Deploy.Agent as Agent\nimport Cachix.Deploy.Deployment (Deployment (..))\nimport qualified Cachix.Deploy.Lock as Lock\nimport qualified Cachix.Deploy.Log as Log\nimport qualified Cachix.Deploy.Websocket as WebSocket\nimport qualified Control.Concurrent.Async as Async\nimport qualified Control.Concurrent.STM.TMQueue as TMQueue\nimport qualified Control.Exception.Safe as Safe\nimport qualified Data.Aeson as Aeson\nimport qualified Data.Conduit.TQueue as Conduit\nimport Data.Time.Clock (getCurrentTime)\nimport qualified Data.UUID as UUID\nimport qualified Data.UUID.V4 as UUID\nimport GHC.IO.Encoding\nimport qualified Katip as K\nimport qualified Network.WebSockets as WS\nimport Protolude hiding (toS)\nimport Protolude.Conv\nimport System.IO (BufferMode (..), hSetBuffering)\n\nlockFilename :: Text -> FilePath\nlockFilename agentName = "deployment-" <> toS agentName\n\n-- | Activate the new deployment.\n--\n-- If the target profile is already locked by another deployment, exit\n-- immediately and rely on the backend to reschedule.\nmain :: IO ()\nmain = do\n  setLocaleEncoding utf8\n  hSetBuffering stdout LineBuffering\n  hSetBuffering stderr LineBuffering\n\n  deployment@Deployment\n    { agentName,\n      agentToken,\n      host,\n      logOptions,\n      deploymentDetails\n    } <-\n    escalateAs (FatalError . toS) . Aeson.eitherDecode . toS =<< getContents\n\n  let deploymentID = DeploymentDetails.id deploymentDetails\n  let headers = WebSocket.createHeaders agentName agentToken\n  let port = fromMaybe (URI.Port 80) (URI.getPortFor (URI.getScheme host))\n  let logWebsocketOptions =\n        WebSocket.Options\n          { WebSocket.host = URI.getHostname host,\n            WebSocket.port = port,\n            WebSocket.path = "/api/v1/deploy/log/" <> UUID.toText deploymentID,\n            WebSocket.useSSL = URI.requiresSSL (URI.getScheme host),\n            WebSocket.headers = headers,\n            WebSocket.identifier = Agent.agentIdentifier agentName\n          }\n  let serviceWebsocketOptions =\n        WebSocket.Options\n          { WebSocket.host = URI.getHostname host,\n            WebSocket.port = port,\n            WebSocket.path = "/ws-deployment",\n            WebSocket.useSSL = URI.requiresSSL (URI.getScheme host),\n            WebSocket.headers = headers,\n            WebSocket.identifier = Agent.agentIdentifier agentName\n          }\n\n  Log.withLog logOptions $ \\withLog ->\n    void . Lock.withTryLock (lockFilename agentName) $ do\n      -- Open a connection to logging stream\n      (logQueue, loggingThread) <- runLogStream withLog logWebsocketOptions\n\n      -- Open a connection to Cachix and block until it\'s ready.\n      service <- WebSocket.new withLog serviceWebsocketOptions\n      shutdownService <- Agent.connectToService service\n\n      deploy withLog deployment service (Conduit.sinkTMQueue logQueue)\n        `finally` do\n          withLog $ K.logLocM K.DebugS "Cleaning up websocket connections"\n          atomically $ TMQueue.closeTMQueue logQueue\n          shutdownService\n          Async.wait loggingThread\n\n-- | Run the deployment commands\ndeploy ::\n  -- | Logging context\n  Log.WithLog ->\n  -- | Deployment information passed from the agent\n  Deployment ->\n  Agent.ServiceWebSocket ->\n  -- | Logging Websocket connection\n  Log.LogStream ->\n  IO ()\ndeploy withLog Deployment {..} service logStream = do\n  withLog $ K.logLocM K.InfoS $ K.ls $ "Deploying #" <> deploymentIndex <> ": " <> storePath\n\n  activationStatus <- handleAsActivationStatus $\n    Activate.withCacheArgs host agentInformation agentToken $ \\cacheArgs -> do\n      startDeployment Nothing\n\n      Activate.downloadStorePaths logStream deploymentDetails cacheArgs\n\n      -- Read the closure size and report\n      --\n      -- TODO: query the remote store to get the size before downloading (and\n      -- possibly running out of disk space)\n      closureSize <- fromRight Nothing <$> Activate.getClosureSize cacheArgs storePath\n      when (isJust closureSize) $ startDeployment closureSize\n\n      rollbackAction <- Activate.activate logStream profileName (toS storePath)\n\n      -- Run tests on the new deployment\n      testResults <- handleAsFailureReason $ do\n        -- Run a basic network test against the backend\n        pong <- WebSocket.waitForPong 10 service\n        when (isNothing pong) $ throwIO Activate.NetworkTestFailure\n\n        -- Run the optional rollback script\n        for (WSS.rollbackScript deploymentDetails) $ \\rollbackScript -> do\n          Log.streamLine logStream "Running rollback script."\n          rollbackScriptResult <- Safe.tryIO $ Activate.runShellWithExitCode logStream (toS rollbackScript) []\n          case rollbackScriptResult of\n            Right ExitSuccess -> pure ()\n            Right (ExitFailure _) -> throwIO Activate.RollbackScriptExitFailure\n            Left e -> throwIO (Activate.RollbackScriptUnexpectedError e)\n\n      -- Roll back if any of the tests have failed\n      case testResults of\n        Right _ -> pure Activate.Success\n        Left testErrors ->\n          case rollbackAction of\n            Just rollback -> do\n              Log.streamLine logStream "Deployment failed, rolling back ..."\n              rollback\n              throwIO (Activate.Rollback testErrors)\n            Nothing -> do\n              Log.streamLine logStream "Skipping rollback as this is the first deployment."\n              throwIO (Activate.Failure testErrors)\n\n  case activationStatus of\n    Activate.Failure e -> logDeploymentFailed e\n    Activate.Rollback e -> logDeploymentFailed e\n    Activate.Success -> do\n      -- NOTE: the activate command uses this message to detect the end of the log\n      Log.streamLine logStream "Successfully activated the deployment."\n      withLog $ K.logLocM K.InfoS $ K.ls $ "Deployment #" <> deploymentIndex <> " finished."\n\n  endDeployment activationStatus\n  where\n    storePath = DeploymentDetails.storePath deploymentDetails\n    deploymentID = DeploymentDetails.id deploymentDetails\n    deploymentIndex = show (DeploymentDetails.index deploymentDetails)\n\n    handleAsActivationStatus :: IO Activate.Status -> IO Activate.Status\n    handleAsActivationStatus action =\n      action\n        `Safe.catches` [ Safe.Handler (\\(e :: Activate.Status) -> pure e),\n                         Safe.Handler (\\(e :: SomeException) -> pure $ Activate.Failure (Activate.UnexpectedError e))\n                       ]\n\n    handleAsFailureReason :: IO a -> IO (Either Activate.FailureReason a)\n    handleAsFailureReason action =\n      fmap Right action\n        `Safe.catches` [ Safe.Handler (\\(e :: Activate.FailureReason) -> pure (Left e)),\n                         Safe.Handler (\\(e :: SomeException) -> pure $ Left (Activate.UnexpectedError e))\n                       ]\n\n    logDeploymentFailed e = do\n      Log.streamLine logStream $\n        toS $\n          unwords\n            -- NOTE: the activate command uses this message to detect the end of the log\n            [ "Failed to activate the deployment.",\n              toS $ displayException e\n            ]\n      withLog $ K.logLocM K.InfoS $ K.ls $ "Deploying #" <> deploymentIndex <> " failed."\n\n    startDeployment :: Maybe Int64 -> IO ()\n    startDeployment closureSize = do\n      now <- getCurrentTime\n      msg <-\n        createMessage $\n          WSS.DeploymentStarted\n            { WSS.id = deploymentID,\n              WSS.time = now,\n              WSS.closureSize = closureSize\n            }\n      WebSocket.send service (WebSocket.DataMessage msg)\n\n    endDeployment :: Activate.Status -> IO ()\n    endDeployment status = do\n      let hasSucceeded =\n            case status of\n              Activate.Success -> True\n              _ -> False\n      now <- getCurrentTime\n      msg <-\n        createMessage $\n          WSS.DeploymentFinished\n            { WSS.id = deploymentID,\n              WSS.time = now,\n              WSS.hasSucceeded = hasSucceeded\n            }\n      WebSocket.send service (WebSocket.DataMessage msg)\n\n    createMessage :: WSS.AgentCommand -> IO (WSS.Message WSS.AgentCommand)\n    createMessage command = do\n      uuid <- UUID.nextRandom\n      return $\n        WSS.Message\n          { WSS.method = method,\n            WSS.command = command,\n            WSS.id = uuid,\n            WSS.agent = Just $ AgentInformation.id agentInformation\n          }\n      where\n        -- TODO: move to WSS\n        method = case command of\n          WSS.DeploymentStarted {} -> "DeploymentStarted"\n          WSS.DeploymentFinished {} -> "DeploymentFinished"\n\n-- Log\n\n-- TODO: prepend katip-like format to each line\n-- TODO: Re-use the WebSocket module here (without ping?)\nrunLogStream ::\n  Log.WithLog ->\n  WebSocket.Options ->\n  -- | Returns a queue for writing messages and the thread handle\n  IO (TMQueue.TMQueue ByteString, Async.Async ())\nrunLogStream withLog options = do\n  queue <- TMQueue.newTMQueueIO\n  thread <- Async.async $\n    WebSocket.reconnectWithLog withLog $\n      WebSocket.runClientWith options WS.defaultConnectionOptions $ \\connection ->\n        Log.streamLog withLog connection queue\n          `finally` WebSocket.waitForGracefulShutdown connection\n  return (queue, thread)\n'