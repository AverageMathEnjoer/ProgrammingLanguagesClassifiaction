b'{-# LANGUAGE BangPatterns #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n\nmodule Plugin.CheckImports (plugin) where\n\nimport Control.Monad.IO.Class (MonadIO (liftIO))\nimport CoreMonad\n  ( getDynFlags,\n    getHscEnv,\n    getModule,\n    getOrigNameCache,\n  )\nimport Data.Char (isAlpha)\nimport Data.Foldable (for_)\nimport Data.IORef (readIORef)\nimport Data.List (concat, foldl\', intercalate, sort)\nimport Data.Map (Map)\nimport qualified Data.Map as M\nimport Data.Monoid ((<>))\nimport Data.Set (Set)\nimport qualified Data.Set as S\nimport DynFlags (DynFlags)\nimport GHC (getModuleInfo)\nimport GhcPlugins\n  ( CommandLineOption,\n    CoreM,\n    CoreToDo,\n    HsParsedModule,\n    Hsc,\n    ModSummary,\n    Plugin (..),\n    defaultPlugin,\n    putMsgS,\n  )\nimport HsDecls (HsGroup (..))\nimport HsExtension (GhcRn)\nimport HscTypes (HsParsedModule (..), ModIface (..))\nimport IOEnv (failWithM)\nimport Module (ModuleName, lookupModuleEnv)\nimport Name (Name, getName, localiseName)\nimport Outputable (Outputable (ppr), showSDoc)\nimport RdrName\n  ( GlobalRdrElt (..),\n    GlobalRdrEnv,\n    ImpDeclSpec (..),\n    ImportSpec (..),\n    greLabel,\n    pprGlobalRdrEnv,\n    pprNameProvenance,\n  )\nimport TcRnTypes (IfM, TcGblEnv (..), TcM)\n\nplugin :: Plugin\nplugin =\n  defaultPlugin\n    { typeCheckResultAction = typecheckPlugin\n    }\n\nprintPpr :: (Outputable a, MonadIO m) => DynFlags -> a -> m ()\nprintPpr dflags = liftIO . putStrLn . showSDoc dflags . ppr\n\nformatName :: DynFlags -> Name -> String\nformatName dflags name =\n  let str = showSDoc dflags . ppr . localiseName $ name\n   in case str of\n        (x : xs) ->\n          if isAlpha x\n            then str\n            else "(" <> str <> ")"\n        _ -> str\n\nformatImportedNames :: [String] -> String\nformatImportedNames names =\n  case fmap (<> ",\\n") $ sort names of\n    line0 : lines ->\n      let line0\' = "  ( " <> line0\n          lines\' = fmap ("    " <>) lines\n          footer = "  )"\n       in concat ([line0\'] <> lines\' <> [footer])\n    _ -> "  ()"\n\nmkModuleNameMap :: GlobalRdrElt -> [(ModuleName, Name)]\nmkModuleNameMap gre = do\n  spec <- gre_imp gre\n  let modName = is_mod $ is_decl spec\n  pure (modName, gre_name gre)\n\ntypecheckPlugin ::\n  [CommandLineOption] ->\n  ModSummary ->\n  TcGblEnv ->\n  TcM TcGblEnv\ntypecheckPlugin _ modsummary tc = do\n  liftIO $ putStrLn "typecheck plugin"\n  dflags <- getDynFlags\n  let globalRdrEnv :: GlobalRdrEnv\n      globalRdrEnv = tcg_rdr_env tc\n  usedGREs :: [GlobalRdrElt] <-\n    liftIO $ readIORef (tcg_used_gres tc)\n  let moduleImportMap :: Map ModuleName (Set Name)\n      moduleImportMap =\n        foldl\' (\\(!m) (modu, name) -> M.insertWith S.union modu (S.singleton name) m) M.empty $\n          concatMap mkModuleNameMap usedGREs\n  for_ (M.toList moduleImportMap) $ \\(modu, names) -> liftIO $ do\n    putStrLn "---------"\n    printPpr dflags modu\n    let imported = fmap (formatName dflags) $ S.toList names\n    putStrLn $ formatImportedNames imported\n  printPpr dflags modsummary\n  failWithM "force fail"\n  pure tc\n'