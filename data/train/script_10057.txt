b'// UVa1601 The Morning after Halloween\n// Rujia Liu\n// This code implements the simpliest yet efficient-enough algorithm I\'m aware of\n// Readers are encouraged to experiment on other algorithms (especially for better efficiency!)\n#include<cstdio>\n#include<cstring>\n#include<cctype>\n#include<queue>\nusing namespace std;\n\nconst int maxs = 20;\nconst int maxn = 150; // 75% cells plus 2 fake nodes\nconst int dx[]={1,-1,0,0,0}; // 4 moves, plus "no move"\nconst int dy[]={0,0,1,-1,0};\n\ninline int ID(int a, int b, int c) {\n  return (a<<16)|(b<<8)|c;\n}\n\nint s[3], t[3]; // starting/ending position of each ghost\n\nint deg[maxn], G[maxn][5]; // target cells for each move (including "no move")\n\ninline bool conflict(int a, int b, int a2, int b2) {\n  return a2 == b2 || (a2 == b && b2 == a);\n}\n\nint d[maxn][maxn][maxn]; // distance from starting state\n\nint bfs() {\n    queue<int> q;\n    memset(d, -1, sizeof(d));\n    q.push(ID(s[0], s[1], s[2])); // starting node\n    d[s[0]][s[1]][s[2]] = 0;\n    while(!q.empty()) {\n      int u = q.front(); q.pop();\n      int a = (u>>16)&0xff, b = (u>>8)&0xff, c = u&0xff;\n      if(a == t[0] && b == t[1] && c == t[2]) return d[a][b][c]; // solution found\n      for(int i = 0; i < deg[a]; i++) {\n        int a2 = G[a][i];\n        for(int j = 0; j < deg[b]; j++) {\n          int b2 = G[b][j];\n          if(conflict(a, b, a2, b2)) continue;\n          for(int k = 0; k < deg[c]; k++) {\n            int c2 = G[c][k];\n            if(conflict(a, c, a2, c2)) continue;\n            if(conflict(b, c, b2, c2)) continue;\n            if(d[a2][b2][c2] != -1) continue;\n            d[a2][b2][c2] = d[a][b][c]+1;\n            q.push(ID(a2, b2, c2));\n          }\n        }\n      }\n    }\n  return -1;\n}\n\nint main() {\n  int w, h, n; \n\n  while(scanf("%d%d%d\\n", &w, &h, &n) == 3 && n) {\n    char maze[20][20];\n    for(int i = 0; i < h; i++)\n      fgets(maze[i], 20, stdin);\n\n    // extract empty cells\n    int cnt, x[maxn], y[maxn], id[maxs][maxs]; // cnt is the number of empty cells\n    cnt = 0;\n    for(int i = 0; i < h; i++)\n      for(int j = 0; j < w; j++)\n        if(maze[i][j] != \'#\') {\n          x[cnt] = i; y[cnt] = j; id[i][j] = cnt;\n          if(islower(maze[i][j])) s[maze[i][j] - \'a\'] = cnt;\n          else if(isupper(maze[i][j])) t[maze[i][j] - \'A\'] = cnt;\n          cnt++;\n        }\n\n    // build a graph of empty cells\n    for(int i = 0; i < cnt; i++) {\n      deg[i] = 0;\n      for(int dir = 0; dir < 5; dir++) {\n        int nx = x[i]+dx[dir], ny = y[i]+dy[dir];\n        // "Outermost cells of a map are walls" means we don\'t need to check out-of-bound\n        if(maze[nx][ny] != \'#\') G[i][deg[i]++] = id[nx][ny];\n      }\n    }\n\n    // add fakes nodes so that in each case we have 3 ghosts. this makes the code shorter\n    if(n <= 2) { deg[cnt] = 1; G[cnt][0] = cnt; s[2] = t[2] = cnt++; }\n    if(n <= 1) { deg[cnt] = 1; G[cnt][0] = cnt; s[1] = t[1] = cnt++; }\n\n    printf("%d\\n", bfs());\n  }\n  return 0;\n}\n'