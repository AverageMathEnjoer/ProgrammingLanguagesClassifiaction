b'/*\n * Copyright 2013 - 2016 Mario Arias\n *\n * Licensed under the Apache License, Version 2.0 (the "License");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * \thttp://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an "AS IS" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.funktionale.playground.eh\n\nimport org.funktionale.either.Either\nimport org.funktionale.either.Either.Left\nimport org.funktionale.either.Either.Right\n\n/**\n * Created by IntelliJ IDEA.\n * @author Mario Arias\n * Date: 4/07/15\n * Time: 1:05 PM\n */\n\n/*fun mean(xs: Collection<Double>): Double {\n    if (xs.isEmpty()) {\n        throw ArithmeticException("mean of empty collection")\n    } else {\n        return xs.sum() / xs.size()\n    }\n}*/\n\n/*fun mean(xs: Collection<Double>, onEmpty: Double): Double {\n    return if (xs.isEmpty()) {\n        onEmpty\n    } else {\n        xs.sum() / xs.size()\n    }\n}\n\nfun mean(xs: Collection<Double>): Option<Double> {\n    return if (xs.isEmpty()) {\n        None\n    } else {\n        Some(xs.sum() / xs.size())\n    }\n}\n\nfun variance(xs: Collection<Double>): Option<Double> {\n    return mean(xs).flatMap { m ->\n        mean(xs.map { x ->\n            Math.pow(x - m, 2.0)\n        })\n    }\n}\n\nfun<P1, R> ((P1) -> R).lift(): (Option<P1>) -> Option<R> {\n    return { it.map(this) }\n}\n\nfun<T> Collection<Option<T>>.sequence(): Option<Collection<T>> {\n    return if (this.isEmpty()) {\n        Some(emptyList<T>())\n    } else {\n        first().flatMap { hh -> tail().sequence().map { hh concat it } }\n    }\n}\n\nfun<T> Collection<Option<T>>.sequence2(): Option<Collection<T>> {\n    return toList().foldRight(Some(emptyList())){ x: Option<T>, y: Option<Collection<T>> ->\n        x.map(y){i1,i2 ->\n            i1 concat i2\n        }\n    }\n}\n\nfun<T> Collection<Option<T>>.sequence3(): Option<Collection<T>> {\n    return this.traverse { it }\n}\n\n\nfun<T,R> Collection<T>.traverse(f:(T) -> Option<R>):Option<Collection<R>>{\n    return toList().foldRight(Some(emptyList())){x, y ->\n        f(x).map(y){ i1,i2 ->\n            i1 concat i2\n        }\n    }\n}\n\n\nfun<T> Iterable<T>.tail(): Collection<T> {\n    return this.drop(1)\n}\n\nfun<T> T.concat(rest: Collection<T>): Collection<T> {\n    return listOf(this) + rest\n}\n\nfun parseInts(a: Collection<String>): Option<Collection<Int>> {\n    return a.map { Try { it.toInt() } }.sequence3()\n}*/\n\n/*fun map2<P1,P2,R>(a:Option<P1>,b:Option<P2>,f:(P1,P2) -> R):Option<R>{\n    return a.flatMap { aa -> b.map { bb -> f(aa,bb) } }\n}*/\n\n/*fun parseInsuranceRateQuotes(age: String, numberOfSpeedingTickets: String): Option<Double> {\n    val optAge = Try { age.toInt() }\n    val optTickers = Try {numberOfSpeedingTickets.toInt()}\n}*/\n\n/*fun Try<T>(body: () -> T): Option<T> {\n    return try {\n        Some(body())\n    } catch(e: Exception) {\n        None\n    }\n}*/\n\nfun mean(xs:Collection<Double>): Either<String, Double> {\n    return if (xs.isEmpty()){\n        Left("mean of empty list!")\n    } else {\n        Right(xs.sum() / xs.size)\n    }\n}\n\nfun main(args: Array<String>) {\n    /*val abs: (Double) -> Double = { i: Double -> Math.abs(i) }\n    val liftAbs: (Option<Double>) -> Option<Double> = abs.lift()\n    println(liftAbs((-2.0).toOption()))*/\n    //println(parseInts(listOf("1", "2", "3")))\n}'