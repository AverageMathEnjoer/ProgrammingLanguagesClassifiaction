b'module GameMove (doMoveCommand) where\nimport GameModel\nimport GameUtils\nimport GameIO\nimport GameDisplay\nimport IdrisGen\nimport System.Process\nimport System.IO\nimport qualified Data.ByteString as BS\nimport qualified Data.ByteString.Char8 as BS8\nimport qualified Data.Map as M\nimport qualified Text.Parsec as P\nimport qualified Text.Parsec.Language as P\nimport qualified Text.Parsec.Token as P\nimport Control.Applicative\nimport Text.Printf\nimport Data.Char (digitToInt)\n\ndata IdrisSExp = IdrisNil | IdrisNum Int | IdrisStr String | IdrisKey String\n                 | IdrisBracketed [IdrisSExp] deriving (Eq, Ord, Show)\n\nparseEscapedChar :: P.Parsec String u Char\nparseEscapedChar = (P.char \'\\\\\' *> P.anyChar) <|> P.anyChar\nparseIdrisStr :: P.Parsec String u String\nparseIdrisStr = (P.char \'"\') *> P.manyTill parseEscapedChar (P.try $ P.char \'"\')\n\nparseIdrisSExp :: P.Parsec String u IdrisSExp\nparseIdrisSExp =\n      (P.string "nil" *> pure IdrisNil)\n  <|> ((IdrisNum . fromIntegral) <$> P.integer P.haskell)\n  <|> (IdrisStr <$> parseIdrisStr)\n  <|> (IdrisKey <$> (P.char \':\' *> P.many (P.alphaNum <|> P.char \'-\')))\n  <|> (P.char \'(\' *> (IdrisBracketed <$> P.sepBy parseIdrisSExp (P.optional $ P.char \' \')) <* P.char \')\')\n\nreadRawIdrisMessage :: Handle -> IO BS.ByteString\nreadRawIdrisMessage h = do\n  lenData <- BS.hGet h 6\n  let Just len = parseHexNumber (BS8.unpack lenData)\n  remainingData <- BS.hGet h len\n  return remainingData\n\nparseHexNumber :: String -> Maybe Int\nparseHexNumber nStr = fmap fromIntegral $\n  eitherToJust $ P.parse (number 16 P.hexDigit) "" nStr\n  where\n    number base baseDigit\n        = do\n            digits <- P.many1 baseDigit\n            let n = foldl (\\x d -> base*x + toInteger (digitToInt d)) 0 digits\n            seq n (return n)\n  \nwriteIdrisMessage :: Handle -> BS.ByteString -> IO ()\nwriteIdrisMessage h bs = do\n  hPutStr h (printf "%06x" (BS.length bs))\n  BS.hPut h bs\n  hFlush h\n\nreadIdrisMessage :: Handle -> IO IdrisSExp\nreadIdrisMessage h = do\n  msg <- readRawIdrisMessage h\n  let Right sexp = P.parse parseIdrisSExp "" (BS8.unpack msg)\n  return sexp\n\nprocessIdrisMessagesUntilReturn :: Handle -> IO Bool\nprocessIdrisMessagesUntilReturn h = do\n  msg <- readIdrisMessage h\n  case msg of\n    IdrisBracketed [IdrisKey "warning", IdrisBracketed [IdrisStr source, IdrisBracketed [IdrisNum low, IdrisNum high], _, IdrisStr warning, _], _] -> do\n      putStrLn $ "At " ++ (show source) ++ " " ++ (show low) ++ "-" ++ (show high) ++ ": " ++ warning\n      processIdrisMessagesUntilReturn h\n    IdrisBracketed [IdrisKey "return", IdrisBracketed [IdrisKey "ok", IdrisBracketed []], _] ->\n      return True\n    IdrisBracketed [IdrisKey "return", _, _] ->\n      return False\n    _ -> processIdrisMessagesUntilReturn h\n  \nprocessMove :: Coord -> String -> String -> IO ()\nprocessMove c@(Coord x y) varPrefix expectedType = do\n  let factCheck = "module CheckMove\\n\\\n                 \\  import ProofSweeperBase\\n\\\n                 \\  import ProofSweeperKnown\\n\\\n                 \\  import ProofSweeperPlay\\n\\\n                 \\  total\\n\\\n                 \\  checkMove : MineFact (MkCoord " ++ (show x) ++ " " ++ (show y)\n                      ++ ") " ++ expectedType ++ "\\n\\\n                 \\  checkMove = " ++ varPrefix ++ "_" ++ (show x) ++ "_"\n                      ++ (show y) ++ "\\n"\n  writeFile "CheckMove.idr" factCheck\n  (Just hIn, Just hOut, _, procHandle) <- createProcess (proc "idris" ["--ide-mode"]) {\n      std_in = CreatePipe\n    , std_out = CreatePipe\n  }\n  writeIdrisMessage hIn (BS8.pack "((:load-file \\"CheckMove.idr\\") 1)")\n  result <- processIdrisMessagesUntilReturn hOut\n  writeIdrisMessage hIn (BS8.pack "((:metavariables 100) 1)")\n  result2 <- processIdrisMessagesUntilReturn hOut\n  terminateProcess procHandle\n\n  if result && not result2\n    then putStrLn "There are holes remaining"\n    else return ()\n\n  if (not $ result && result2)\n    then putStrLn "Not accepting move due to failure"\n    else do\n      Just game <- loadGame\n      case M.lookup (Coord x y) (gameStatus game) of\n        Just statusNow -> do\n          let newStatus = statusNow { cellVisibility = CellKnown }\n          let counts = gameToMineCounts game\n          let game\' = expandNotMinesWithoutNeighbours\n                       (game { gameStatus = M.insert c newStatus (gameStatus game) })\n                       counts\n          saveGame game\'\n          saveIdrisGame game\' counts\n          putStrLn $ displayGame game\' counts\n        Nothing -> putStrLn "Proof of something that is not true - did you abuse believe_me / assert_total etc...?"\n  \ndoMoveCommand :: String -> String -> String -> IO ()\ndoMoveCommand commandName xStr yStr =\n    case (parseNumber xStr, parseNumber yStr) of\n      (Just x, Just y) ->\n        case commandName of\n          "mine" -> processMove (Coord x y) "mineAt" "IsMine"\n          "notmine" -> processMove (Coord x y) "noMineAt" "IsNotMine"\n          _ -> putStrLn "First argument to move must be mine or notmine"\n      _ -> putStrLn "Expected numbers as second and third argument to move"\n'