b'/* \n * Fast QR Code generator library\n * \n * Copyright (c) Project Nayuki. (MIT License)\n * https://www.nayuki.io/page/fast-qr-code-generator-library\n * \n * Permission is hereby granted, free of charge, to any person obtaining a copy of\n * this software and associated documentation files (the "Software"), to deal in\n * the Software without restriction, including without limitation the rights to\n * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of\n * the Software, and to permit persons to whom the Software is furnished to do so,\n * subject to the following conditions:\n * - The above copyright notice and this permission notice shall be included in\n *   all copies or substantial portions of the Software.\n * - The Software is provided "as is", without warranty of any kind, express or\n *   implied, including but not limited to the warranties of merchantability,\n *   fitness for a particular purpose and noninfringement. In no event shall the\n *   authors or copyright holders be liable for any claim, damages or other\n *   liability, whether in an action of contract, tort or otherwise, arising from,\n *   out of or in connection with the Software or the use or other dealings in the\n *   Software.\n */\n\npackage io.nayuki.fastqrcodegen;\n\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Objects;\n\n\n/**\n * A QR Code symbol, which is a type of two-dimension barcode.\n * Invented by Denso Wave and described in the ISO/IEC 18004 standard.\n * <p>Instances of this class represent an immutable square grid of dark and light cells.\n * The class provides static factory functions to create a QR Code from text or binary data.\n * The class covers the QR Code Model 2 specification, supporting all versions (sizes)\n * from 1 to 40, all 4 error correction levels, and 4 character encoding modes.</p>\n * <p>Ways to create a QR Code object:</p>\n * <ul>\n *   <li><p>High level: Take the payload data and call {@link QrCode#encodeText(String,Ecc)}\n *     or {@link QrCode#encodeBinary(byte[],Ecc)}.</p></li>\n *   <li><p>Mid level: Custom-make the list of {@link QrSegment segments}\n *     and call {@link QrCode#encodeSegments(List,Ecc)} or\n *     {@link QrCode#encodeSegments(List,Ecc,int,int,int,boolean)}</p></li>\n *   <li><p>Low level: Custom-make the array of data codeword bytes (including segment headers and\n *     final padding, excluding error correction codewords), supply the appropriate version number,\n *     and call the {@link QrCode#QrCode(int,Ecc,byte[],int) constructor}.</p></li>\n * </ul>\n * <p>(Note that all ways require supplying the desired error correction level.)</p>\n * @see QrSegment\n */\npublic final class QrCode {\n\t\n\t/*---- Static factory functions (high level) ----*/\n\t\n\t/**\n\t * Returns a QR Code representing the specified Unicode text string at the specified error correction level.\n\t * As a conservative upper bound, this function is guaranteed to succeed for strings that have 738 or fewer\n\t * Unicode code points (not UTF-16 code units) if the low error correction level is used. The smallest possible\n\t * QR Code version is automatically chosen for the output. The ECC level of the result may be higher than the\n\t * ecl argument if it can be done without increasing the version.\n\t * @param text the text to be encoded (not {@code null}), which can be any Unicode string\n\t * @param ecl the error correction level to use (not {@code null}) (boostable)\n\t * @return a QR Code (not {@code null}) representing the text\n\t * @throws NullPointerException if the text or error correction level is {@code null}\n\t * @throws DataTooLongException if the text fails to fit in the\n\t * largest version QR Code at the ECL, which means it is too long\n\t */\n\tpublic static QrCode encodeText(String text, Ecc ecl) {\n\t\tObjects.requireNonNull(text);\n\t\tObjects.requireNonNull(ecl);\n\t\tList<QrSegment> segs = QrSegment.makeSegments(text);\n\t\treturn encodeSegments(segs, ecl);\n\t}\n\t\n\t\n\t/**\n\t * Returns a QR Code representing the specified binary data at the specified error correction level.\n\t * This function always encodes using the binary segment mode, not any text mode. The maximum number of\n\t * bytes allowed is 2953. The smallest possible QR Code version is automatically chosen for the output.\n\t * The ECC level of the result may be higher than the ecl argument if it can be done without increasing the version.\n\t * @param data the binary data to encode (not {@code null})\n\t * @param ecl the error correction level to use (not {@code null}) (boostable)\n\t * @return a QR Code (not {@code null}) representing the data\n\t * @throws NullPointerException if the data or error correction level is {@code null}\n\t * @throws DataTooLongException if the data fails to fit in the\n\t * largest version QR Code at the ECL, which means it is too long\n\t */\n\tpublic static QrCode encodeBinary(byte[] data, Ecc ecl) {\n\t\tObjects.requireNonNull(data);\n\t\tObjects.requireNonNull(ecl);\n\t\tQrSegment seg = QrSegment.makeBytes(data);\n\t\treturn encodeSegments(Arrays.asList(seg), ecl);\n\t}\n\t\n\t\n\t/*---- Static factory functions (mid level) ----*/\n\t\n\t/**\n\t * Returns a QR Code representing the specified segments at the specified error correction\n\t * level. The smallest possible QR Code version is automatically chosen for the output. The ECC level\n\t * of the result may be higher than the ecl argument if it can be done without increasing the version.\n\t * <p>This function allows the user to create a custom sequence of segments that switches\n\t * between modes (such as alphanumeric and byte) to encode text in less space.\n\t * This is a mid-level API; the high-level API is {@link #encodeText(String,Ecc)}\n\t * and {@link #encodeBinary(byte[],Ecc)}.</p>\n\t * @param segs the segments to encode\n\t * @param ecl the error correction level to use (not {@code null}) (boostable)\n\t * @return a QR Code (not {@code null}) representing the segments\n\t * @throws NullPointerException if the list of segments, any segment, or the error correction level is {@code null}\n\t * @throws DataTooLongException if the segments fail to fit in the\n\t * largest version QR Code at the ECL, which means they are too long\n\t */\n\tpublic static QrCode encodeSegments(List<QrSegment> segs, Ecc ecl) {\n\t\treturn encodeSegments(segs, ecl, MIN_VERSION, MAX_VERSION, -1, true);\n\t}\n\t\n\t\n\t/**\n\t * Returns a QR Code representing the specified segments with the specified encoding parameters.\n\t * The smallest possible QR Code version within the specified range is automatically\n\t * chosen for the output. Iff boostEcl is {@code true}, then the ECC level of the\n\t * result may be higher than the ecl argument if it can be done without increasing\n\t * the version. The mask number is either between 0 to 7 (inclusive) to force that\n\t * mask, or &#x2212;1 to automatically choose an appropriate mask (which may be slow).\n\t * <p>This function allows the user to create a custom sequence of segments that switches\n\t * between modes (such as alphanumeric and byte) to encode text in less space.\n\t * This is a mid-level API; the high-level API is {@link #encodeText(String,Ecc)}\n\t * and {@link #encodeBinary(byte[],Ecc)}.</p>\n\t * @param segs the segments to encode\n\t * @param ecl the error correction level to use (not {@code null}) (boostable)\n\t * @param minVersion the minimum allowed version of the QR Code (at least 1)\n\t * @param maxVersion the maximum allowed version of the QR Code (at most 40)\n\t * @param mask the mask number to use (between 0 and 7 (inclusive)), or &#x2212;1 for automatic mask\n\t * @param boostEcl increases the ECC level as long as it doesn\'t increase the version number\n\t * @return a QR Code (not {@code null}) representing the segments\n\t * @throws NullPointerException if the list of segments, any segment, or the error correction level is {@code null}\n\t * @throws IllegalArgumentException if 1 &#x2264; minVersion &#x2264; maxVersion &#x2264; 40\n\t * or &#x2212;1 &#x2264; mask &#x2264; 7 is violated\n\t * @throws DataTooLongException if the segments fail to fit in\n\t * the maxVersion QR Code at the ECL, which means they are too long\n\t */\n\tpublic static QrCode encodeSegments(List<QrSegment> segs, Ecc ecl, int minVersion, int maxVersion, int mask, boolean boostEcl) {\n\t\tObjects.requireNonNull(segs);\n\t\tObjects.requireNonNull(ecl);\n\t\tif (!(MIN_VERSION <= minVersion && minVersion <= maxVersion && maxVersion <= MAX_VERSION) || mask < -1 || mask > 7)\n\t\t\tthrow new IllegalArgumentException("Invalid value");\n\t\t\n\t\t// Find the minimal version number to use\n\t\tint version, dataUsedBits;\n\t\tfor (version = minVersion; ; version++) {\n\t\t\tint dataCapacityBits = getNumDataCodewords(version, ecl) * 8;  // Number of data bits available\n\t\t\tdataUsedBits = QrSegment.getTotalBits(segs, version);\n\t\t\tif (dataUsedBits != -1 && dataUsedBits <= dataCapacityBits)\n\t\t\t\tbreak;  // This version number is found to be suitable\n\t\t\tif (version >= maxVersion) {  // All versions in the range could not fit the given data\n\t\t\t\tString msg = "Segment too long";\n\t\t\t\tif (dataUsedBits != -1)\n\t\t\t\t\tmsg = String.format("Data length = %d bits, Max capacity = %d bits", dataUsedBits, dataCapacityBits);\n\t\t\t\tthrow new DataTooLongException(msg);\n\t\t\t}\n\t\t}\n\t\tassert dataUsedBits != -1;\n\t\t\n\t\t// Increase the error correction level while the data still fits in the current version number\n\t\tfor (Ecc newEcl : Ecc.values()) {  // From low to high\n\t\t\tif (boostEcl && dataUsedBits <= getNumDataCodewords(version, newEcl) * 8)\n\t\t\t\tecl = newEcl;\n\t\t}\n\t\t\n\t\t// Concatenate all segments to create the data bit string\n\t\tBitBuffer bb = new BitBuffer();\n\t\tfor (QrSegment seg : segs) {\n\t\t\tbb.appendBits(seg.mode.modeBits, 4);\n\t\t\tbb.appendBits(seg.numChars, seg.mode.numCharCountBits(version));\n\t\t\tbb.appendBits(seg.data, seg.bitLength);\n\t\t}\n\t\tassert bb.bitLength == dataUsedBits;\n\t\t\n\t\t// Add terminator and pad up to a byte if applicable\n\t\tint dataCapacityBits = getNumDataCodewords(version, ecl) * 8;\n\t\tassert bb.bitLength <= dataCapacityBits;\n\t\tbb.appendBits(0, Math.min(4, dataCapacityBits - bb.bitLength));\n\t\tbb.appendBits(0, (8 - bb.bitLength % 8) % 8);\n\t\tassert bb.bitLength % 8 == 0;\n\t\t\n\t\t// Pad with alternating bytes until data capacity is reached\n\t\tfor (int padByte = 0xEC; bb.bitLength < dataCapacityBits; padByte ^= 0xEC ^ 0x11)\n\t\t\tbb.appendBits(padByte, 8);\n\t\t\n\t\t// Create the QR Code object\n\t\treturn new QrCode(version, ecl, bb.getBytes(), mask);\n\t}\n\t\n\t\n\t\n\t/*---- Instance fields ----*/\n\t\n\t// Public immutable scalar parameters:\n\t\n\t/** The version number of this QR Code, which is between 1 and 40 (inclusive).\n\t * This determines the size of this barcode. */\n\tpublic final int version;\n\t\n\t/** The width and height of this QR Code, measured in modules, between\n\t * 21 and 177 (inclusive). This is equal to version &#xD7; 4 + 17. */\n\tpublic final int size;\n\t\n\t/** The error correction level used in this QR Code, which is not {@code null}. */\n\tpublic final Ecc errorCorrectionLevel;\n\t\n\t/** The index of the mask pattern used in this QR Code, which is between 0 and 7 (inclusive).\n\t * <p>Even if a QR Code is created with automatic masking requested (mask =\n\t * &#x2212;1), the resulting object still has a mask value between 0 and 7. */\n\tpublic final int mask;\n\t\n\t// Private grid of modules of this QR Code, packed tightly into bits.\n\t// Immutable after constructor finishes. Accessed through getModule().\n\tprivate final int[] modules;\n\t\n\t\n\t\n\t/*---- Constructor (low level) ----*/\n\t\n\t/**\n\t * Constructs a QR Code with the specified version number,\n\t * error correction level, data codeword bytes, and mask number.\n\t * <p>This is a low-level API that most users should not use directly. A mid-level\n\t * API is the {@link #encodeSegments(List,Ecc,int,int,int,boolean)} function.</p>\n\t * @param ver the version number to use, which must be in the range 1 to 40 (inclusive)\n\t * @param ecl the error correction level to use\n\t * @param dataCodewords the bytes representing segments to encode (without ECC)\n\t * @param msk the mask pattern to use, which is either &#x2212;1 for automatic choice or from 0 to 7 for fixed choice\n\t * @throws NullPointerException if the byte array or error correction level is {@code null}\n\t * @throws IllegalArgumentException if the version or mask value is out of range,\n\t * or if the data is the wrong length for the specified version and error correction level\n\t */\n\tpublic QrCode(int ver, Ecc ecl, byte[] dataCodewords, int msk) {\n\t\t// Check arguments and initialize fields\n\t\tif (ver < MIN_VERSION || ver > MAX_VERSION)\n\t\t\tthrow new IllegalArgumentException("Version value out of range");\n\t\tif (msk < -1 || msk > 7)\n\t\t\tthrow new IllegalArgumentException("Mask value out of range");\n\t\tversion = ver;\n\t\tsize = ver * 4 + 17;\n\t\terrorCorrectionLevel = Objects.requireNonNull(ecl);\n\t\tObjects.requireNonNull(dataCodewords);\n\t\t\n\t\tQrTemplate tpl = QrTemplate.MEMOIZER.get(ver);\n\t\tmodules = tpl.template.clone();\n\t\t\n\t\t// Compute ECC, draw modules, do masking\n\t\tbyte[] allCodewords = addEccAndInterleave(dataCodewords);\n\t\tdrawCodewords(tpl.dataOutputBitIndexes, allCodewords);\n\t\tmask = handleConstructorMasking(tpl.masks, msk);\n\t}\n\t\n\t\n\t\n\t/*---- Public instance methods ----*/\n\t\n\t/**\n\t * Returns the color of the module (pixel) at the specified coordinates, which is {@code false}\n\t * for light or {@code true} for dark. The top left corner has the coordinates (x=0, y=0).\n\t * If the specified coordinates are out of bounds, then {@code false} (light) is returned.\n\t * @param x the x coordinate, where 0 is the left edge and size&#x2212;1 is the right edge\n\t * @param y the y coordinate, where 0 is the top edge and size&#x2212;1 is the bottom edge\n\t * @return {@code true} if the coordinates are in bounds and the module\n\t * at that location is dark, or {@code false} (light) otherwise\n\t */\n\tpublic boolean getModule(int x, int y) {\n\t\tif (0 <= x && x < size && 0 <= y && y < size) {\n\t\t\tint i = y * size + x;\n\t\t\treturn getBit(modules[i >>> 5], i) != 0;\n\t\t} else\n\t\t\treturn false;\n\t}\n\t\n\t\n\t\n\t/*---- Private helper methods for constructor: Drawing function modules ----*/\n\t\n\t// Draws two copies of the format bits (with its own error correction code)\n\t// based on the given mask and this object\'s error correction level field.\n\tprivate void drawFormatBits(int msk) {\n\t\t// Calculate error correction code and pack bits\n\t\tint data = errorCorrectionLevel.formatBits << 3 | msk;  // errCorrLvl is uint2, mask is uint3\n\t\tint rem = data;\n\t\tfor (int i = 0; i < 10; i++)\n\t\t\trem = (rem << 1) ^ ((rem >>> 9) * 0x537);\n\t\tint bits = (data << 10 | rem) ^ 0x5412;  // uint15\n\t\tassert bits >>> 15 == 0;\n\t\t\n\t\t// Draw first copy\n\t\tfor (int i = 0; i <= 5; i++)\n\t\t\tsetModule(8, i, getBit(bits, i));\n\t\tsetModule(8, 7, getBit(bits, 6));\n\t\tsetModule(8, 8, getBit(bits, 7));\n\t\tsetModule(7, 8, getBit(bits, 8));\n\t\tfor (int i = 9; i < 15; i++)\n\t\t\tsetModule(14 - i, 8, getBit(bits, i));\n\t\t\n\t\t// Draw second copy\n\t\tfor (int i = 0; i < 8; i++)\n\t\t\tsetModule(size - 1 - i, 8, getBit(bits, i));\n\t\tfor (int i = 8; i < 15; i++)\n\t\t\tsetModule(8, size - 15 + i, getBit(bits, i));\n\t\tsetModule(8, size - 8, 1);  // Always dark\n\t}\n\t\n\t\n\t// Sets the module at the given coordinates to the given color.\n\t// Only used by the constructor. Coordinates must be in bounds.\n\tprivate void setModule(int x, int y, int dark) {\n\t\tassert 0 <= x && x < size;\n\t\tassert 0 <= y && y < size;\n\t\tassert dark == 0 || dark == 1;\n\t\tint i = y * size + x;\n\t\tmodules[i >>> 5] &= ~(1 << i);\n\t\tmodules[i >>> 5] |= dark << i;\n\t}\n\t\n\t\n\t/*---- Private helper methods for constructor: Codewords and masking ----*/\n\t\n\t// Returns a new byte string representing the given data with the appropriate error correction\n\t// codewords appended to it, based on this object\'s version and error correction level.\n\tprivate byte[] addEccAndInterleave(byte[] data) {\n\t\tObjects.requireNonNull(data);\n\t\tif (data.length != getNumDataCodewords(version, errorCorrectionLevel))\n\t\t\tthrow new IllegalArgumentException();\n\t\t\n\t\t// Calculate parameter numbers\n\t\tint numBlocks = NUM_ERROR_CORRECTION_BLOCKS[errorCorrectionLevel.ordinal()][version];\n\t\tint blockEccLen = ECC_CODEWORDS_PER_BLOCK  [errorCorrectionLevel.ordinal()][version];\n\t\tint rawCodewords = QrTemplate.getNumRawDataModules(version) / 8;\n\t\tint numShortBlocks = numBlocks - rawCodewords % numBlocks;\n\t\tint shortBlockDataLen = rawCodewords / numBlocks - blockEccLen;\n\t\t\n\t\t// Split data into blocks, calculate ECC, and interleave\n\t\t// (not concatenate) the bytes into a single sequence\n\t\tbyte[] result = new byte[rawCodewords];\n\t\tReedSolomonGenerator rs = ReedSolomonGenerator.MEMOIZER.get(blockEccLen);\n\t\tbyte[] ecc = new byte[blockEccLen];  // Temporary storage per iteration\n\t\tfor (int i = 0, k = 0; i < numBlocks; i++) {\n\t\t\tint datLen = shortBlockDataLen + (i < numShortBlocks ? 0 : 1);\n\t\t\trs.getRemainder(data, k, datLen, ecc);\n\t\t\tfor (int j = 0, l = i; j < datLen; j++, k++, l += numBlocks) {  // Copy data\n\t\t\t\tif (j == shortBlockDataLen)\n\t\t\t\t\tl -= numShortBlocks;\n\t\t\t\tresult[l] = data[k];\n\t\t\t}\n\t\t\tfor (int j = 0, l = data.length + i; j < blockEccLen; j++, l += numBlocks)  // Copy ECC\n\t\t\t\tresult[l] = ecc[j];\n\t\t}\n\t\treturn result;\n\t}\n\t\n\t\n\t// Draws the given sequence of 8-bit codewords (data and error correction)\n\t// onto the entire data area of this QR Code, based on the given bit indexes.\n\tprivate void drawCodewords(int[] dataOutputBitIndexes, byte[] allCodewords) {\n\t\tObjects.requireNonNull(dataOutputBitIndexes);\n\t\tObjects.requireNonNull(allCodewords);\n\t\tif (allCodewords.length * 8 != dataOutputBitIndexes.length)\n\t\t\tthrow new IllegalArgumentException();\n\t\tfor (int i = 0; i < dataOutputBitIndexes.length; i++) {\n\t\t\tint j = dataOutputBitIndexes[i];\n\t\t\tint bit = getBit(allCodewords[i >>> 3], ~i & 7);\n\t\t\tmodules[j >>> 5] |= bit << j;\n\t\t}\n\t}\n\t\n\t\n\t// XORs the codeword modules in this QR Code with the given mask pattern.\n\t// The function modules must be marked and the codeword bits must be drawn\n\t// before masking. Due to the arithmetic of XOR, calling applyMask() with\n\t// the same mask value a second time will undo the mask. A final well-formed\n\t// QR Code needs exactly one (not zero, two, etc.) mask applied.\n\tprivate void applyMask(int[] msk) {\n\t\tif (msk.length != modules.length)\n\t\t\tthrow new IllegalArgumentException();\n\t\tfor (int i = 0; i < msk.length; i++)\n\t\t\tmodules[i] ^= msk[i];\n\t}\n\t\n\t\n\t// A messy helper function for the constructor. This QR Code must be in an unmasked state when this\n\t// method is called. The \'mask\' argument is the requested mask, which is -1 for auto or 0 to 7 for fixed.\n\t// This method applies and returns the actual mask chosen, from 0 to 7.\n\tprivate int handleConstructorMasking(int[][] masks, int msk) {\n\t\tif (msk == -1) {  // Automatically choose best mask\n\t\t\tint minPenalty = Integer.MAX_VALUE;\n\t\t\tfor (int i = 0; i < 8; i++) {\n\t\t\t\tapplyMask(masks[i]);\n\t\t\t\tdrawFormatBits(i);\n\t\t\t\tint penalty = getPenaltyScore();\n\t\t\t\tif (penalty < minPenalty) {\n\t\t\t\t\tmsk = i;\n\t\t\t\t\tminPenalty = penalty;\n\t\t\t\t}\n\t\t\t\tapplyMask(masks[i]);  // Undoes the mask due to XOR\n\t\t\t}\n\t\t}\n\t\tassert 0 <= msk && msk <= 7;\n\t\tapplyMask(masks[msk]);  // Apply the final choice of mask\n\t\tdrawFormatBits(msk);  // Overwrite old format bits\n\t\treturn msk;  // The caller shall assign this value to the final-declared field\n\t}\n\t\n\t\n\t// Calculates and returns the penalty score based on state of this QR Code\'s current modules.\n\t// This is used by the automatic mask choice algorithm to find the mask pattern that yields the lowest score.\n\tprivate int getPenaltyScore() {\n\t\tint result = 0;\n\t\tint dark = 0;\n\t\tint[] runHistory = new int[7];\n\t\t\n\t\t// Iterate over adjacent pairs of rows\n\t\tfor (int index = 0, downIndex = size, end = size * size; index < end; ) {\n\t\t\tint runColor = 0;\n\t\t\tint runX = 0;\n\t\t\tArrays.fill(runHistory, 0);\n\t\t\tint curRow = 0;\n\t\t\tint nextRow = 0;\n\t\t\tfor (int x = 0; x < size; x++, index++, downIndex++) {\n\t\t\t\tint c = getBit(modules[index >>> 5], index);\n\t\t\t\tif (c == runColor) {\n\t\t\t\t\trunX++;\n\t\t\t\t\tif (runX == 5)\n\t\t\t\t\t\tresult += PENALTY_N1;\n\t\t\t\t\telse if (runX > 5)\n\t\t\t\t\t\tresult++;\n\t\t\t\t} else {\n\t\t\t\t\tfinderPenaltyAddHistory(runX, runHistory);\n\t\t\t\t\tif (runColor == 0)\n\t\t\t\t\t\tresult += finderPenaltyCountPatterns(runHistory) * PENALTY_N3;\n\t\t\t\t\trunColor = c;\n\t\t\t\t\trunX = 1;\n\t\t\t\t}\n\t\t\t\tdark += c;\n\t\t\t\tif (downIndex < end) {\n\t\t\t\t\tcurRow = ((curRow << 1) | c) & 3;\n\t\t\t\t\tnextRow = ((nextRow << 1) | getBit(modules[downIndex >>> 5], downIndex)) & 3;\n\t\t\t\t\t// 2*2 blocks of modules having same color\n\t\t\t\t\tif (x >= 1 && (curRow == 0 || curRow == 3) && curRow == nextRow)\n\t\t\t\t\t\tresult += PENALTY_N2;\n\t\t\t\t}\n\t\t\t}\n\t\t\tresult += finderPenaltyTerminateAndCount(runColor, runX, runHistory) * PENALTY_N3;\n\t\t}\n\t\t\n\t\t// Iterate over single columns\n\t\tfor (int x = 0; x < size; x++) {\n\t\t\tint runColor = 0;\n\t\t\tint runY = 0;\n\t\t\tArrays.fill(runHistory, 0);\n\t\t\tfor (int y = 0, index = x; y < size; y++, index += size) {\n\t\t\t\tint c = getBit(modules[index >>> 5], index);\n\t\t\t\tif (c == runColor) {\n\t\t\t\t\trunY++;\n\t\t\t\t\tif (runY == 5)\n\t\t\t\t\t\tresult += PENALTY_N1;\n\t\t\t\t\telse if (runY > 5)\n\t\t\t\t\t\tresult++;\n\t\t\t\t} else {\n\t\t\t\t\tfinderPenaltyAddHistory(runY, runHistory);\n\t\t\t\t\tif (runColor == 0)\n\t\t\t\t\t\tresult += finderPenaltyCountPatterns(runHistory) * PENALTY_N3;\n\t\t\t\t\trunColor = c;\n\t\t\t\t\trunY = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tresult += finderPenaltyTerminateAndCount(runColor, runY, runHistory) * PENALTY_N3;\n\t\t}\n\t\t\n\t\t// Balance of dark and light modules\n\t\tint total = size * size;  // Note that size is odd, so dark/total != 1/2\n\t\t// Compute the smallest integer k >= 0 such that (45-5k)% <= dark/total <= (55+5k)%\n\t\tint k = (Math.abs(dark * 20 - total * 10) + total - 1) / total - 1;\n\t\tresult += k * PENALTY_N4;\n\t\treturn result;\n\t}\n\t\n\t\n\t\n\t/*---- Private helper functions ----*/\n\t\n\t// Returns the number of 8-bit data (i.e. not error correction) codewords contained in any\n\t// QR Code of the given version number and error correction level, with remainder bits discarded.\n\t// This stateless pure function could be implemented as a (40*4)-cell lookup table.\n\tstatic int getNumDataCodewords(int ver, Ecc ecl) {\n\t\treturn QrTemplate.getNumRawDataModules(ver) / 8\n\t\t\t- ECC_CODEWORDS_PER_BLOCK    [ecl.ordinal()][ver]\n\t\t\t* NUM_ERROR_CORRECTION_BLOCKS[ecl.ordinal()][ver];\n\t}\n\t\n\t\n\t// Can only be called immediately after a light run is added, and\n\t// returns either 0, 1, or 2. A helper function for getPenaltyScore().\n\tprivate int finderPenaltyCountPatterns(int[] runHistory) {\n\t\tint n = runHistory[1];\n\t\tassert n <= size * 3;\n\t\tboolean core = n > 0 && runHistory[2] == n && runHistory[3] == n * 3 && runHistory[4] == n && runHistory[5] == n;\n\t\treturn (core && runHistory[0] >= n * 4 && runHistory[6] >= n ? 1 : 0)\n\t\t     + (core && runHistory[6] >= n * 4 && runHistory[0] >= n ? 1 : 0);\n\t}\n\t\n\t\n\t// Must be called at the end of a line (row or column) of modules. A helper function for getPenaltyScore().\n\tprivate int finderPenaltyTerminateAndCount(int currentRunColor, int currentRunLength, int[] runHistory) {\n\t\tif (currentRunColor == 1) {  // Terminate dark run\n\t\t\tfinderPenaltyAddHistory(currentRunLength, runHistory);\n\t\t\tcurrentRunLength = 0;\n\t\t}\n\t\tcurrentRunLength += size;  // Add light border to final run\n\t\tfinderPenaltyAddHistory(currentRunLength, runHistory);\n\t\treturn finderPenaltyCountPatterns(runHistory);\n\t}\n\t\n\t\n\t// Pushes the given value to the front and drops the last value. A helper function for getPenaltyScore().\n\tprivate void finderPenaltyAddHistory(int currentRunLength, int[] runHistory) {\n\t\tif (runHistory[0] == 0)\n\t\t\tcurrentRunLength += size;  // Add light border to initial run\n\t\tSystem.arraycopy(runHistory, 0, runHistory, 1, runHistory.length - 1);\n\t\trunHistory[0] = currentRunLength;\n\t}\n\t\n\t\n\t// Returns 0 or 1 based on the (i mod 32)\'th bit of x.\n\tstatic int getBit(int x, int i) {\n\t\treturn (x >>> i) & 1;\n\t}\n\t\n\t\n\t/*---- Constants and tables ----*/\n\t\n\t/** The minimum version number  (1) supported in the QR Code Model 2 standard. */\n\tpublic static final int MIN_VERSION =  1;\n\t\n\t/** The maximum version number (40) supported in the QR Code Model 2 standard. */\n\tpublic static final int MAX_VERSION = 40;\n\t\n\t\n\t// For use in getPenaltyScore(), when evaluating which mask is best.\n\tprivate static final int PENALTY_N1 =  3;\n\tprivate static final int PENALTY_N2 =  3;\n\tprivate static final int PENALTY_N3 = 40;\n\tprivate static final int PENALTY_N4 = 10;\n\t\n\t\n\tprivate static final byte[][] ECC_CODEWORDS_PER_BLOCK = {\n\t\t// Version: (note that index 0 is for padding, and is set to an illegal value)\n\t\t//0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40    Error correction level\n\t\t{-1,  7, 10, 15, 20, 26, 18, 20, 24, 30, 18, 20, 24, 26, 30, 22, 24, 28, 30, 28, 28, 28, 28, 30, 30, 26, 28, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30},  // Low\n\t\t{-1, 10, 16, 26, 18, 24, 16, 18, 22, 22, 26, 30, 22, 22, 24, 24, 28, 28, 26, 26, 26, 26, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28},  // Medium\n\t\t{-1, 13, 22, 18, 26, 18, 24, 18, 22, 20, 24, 28, 26, 24, 20, 30, 24, 28, 28, 26, 30, 28, 30, 30, 30, 30, 28, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30},  // Quartile\n\t\t{-1, 17, 28, 22, 16, 22, 28, 26, 26, 24, 28, 24, 28, 22, 24, 24, 30, 28, 28, 26, 28, 30, 24, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30},  // High\n\t};\n\t\n\tprivate static final byte[][] NUM_ERROR_CORRECTION_BLOCKS = {\n\t\t// Version: (note that index 0 is for padding, and is set to an illegal value)\n\t\t//0, 1, 2, 3, 4, 5, 6, 7, 8, 9,10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40    Error correction level\n\t\t{-1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 4,  4,  4,  4,  4,  6,  6,  6,  6,  7,  8,  8,  9,  9, 10, 12, 12, 12, 13, 14, 15, 16, 17, 18, 19, 19, 20, 21, 22, 24, 25},  // Low\n\t\t{-1, 1, 1, 1, 2, 2, 4, 4, 4, 5, 5,  5,  8,  9,  9, 10, 10, 11, 13, 14, 16, 17, 17, 18, 20, 21, 23, 25, 26, 28, 29, 31, 33, 35, 37, 38, 40, 43, 45, 47, 49},  // Medium\n\t\t{-1, 1, 1, 2, 2, 4, 4, 6, 6, 8, 8,  8, 10, 12, 16, 12, 17, 16, 18, 21, 20, 23, 23, 25, 27, 29, 34, 34, 35, 38, 40, 43, 45, 48, 51, 53, 56, 59, 62, 65, 68},  // Quartile\n\t\t{-1, 1, 1, 2, 4, 4, 4, 5, 6, 8, 8, 11, 11, 16, 16, 18, 16, 19, 21, 25, 25, 25, 34, 30, 32, 35, 37, 40, 42, 45, 48, 51, 54, 57, 60, 63, 66, 70, 74, 77, 81},  // High\n\t};\n\t\n\t\n\t\n\t/*---- Public helper enumeration ----*/\n\t\n\t/**\n\t * The error correction level in a QR Code symbol.\n\t */\n\tpublic enum Ecc {\n\t\t// Must be declared in ascending order of error protection\n\t\t// so that the implicit ordinal() and values() work properly\n\t\t/** The QR Code can tolerate about  7% erroneous codewords. */ LOW(1),\n\t\t/** The QR Code can tolerate about 15% erroneous codewords. */ MEDIUM(0),\n\t\t/** The QR Code can tolerate about 25% erroneous codewords. */ QUARTILE(3),\n\t\t/** The QR Code can tolerate about 30% erroneous codewords. */ HIGH(2);\n\t\t\n\t\t// In the range 0 to 3 (unsigned 2-bit integer).\n\t\tfinal int formatBits;\n\t\t\n\t\t// Constructor.\n\t\tprivate Ecc(int fb) {\n\t\t\tformatBits = fb;\n\t\t}\n\t}\n\t\n}\n'