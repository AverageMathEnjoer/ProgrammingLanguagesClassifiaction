b'// Copyright (c) 2022 Manuel Schneider\n\n#include "albert/albert.h"\n#include "albert/logging.h"\n#include "albert/util/util.h"\n#include "terminalprovider.h"\n#include <QCoreApplication>\n#include <QDir>\n#include <QFile>\n#include <QProcess>\n#include <QSettings>\n#include <QStandardPaths>\n#include <QStringList>\n#include <QTemporaryFile>\n#include <memory>\n#include <pwd.h>\n#include <unistd.h>\nusing namespace albert;\nusing namespace std;\nstatic const char* CFG_TERM = "terminal";\n\n\nstatic QString userShell()\n{\n    // Get the user shell (passwd must not be freed)\n    passwd *pwd = getpwuid(geteuid());\n    if (pwd == nullptr){\n        CRIT << "Could not retrieve user shell. Terminal dysfunctional.";\n        return {};\n    }\n    return {pwd->pw_shell};\n}\n\n\n#if defined(Q_OS_LINUX)\n\n\nstruct ExecutableTerminal : public Terminal\n{\n    const char *name_;\n    const vector<const char*> command_line_;\n\n    ExecutableTerminal(const char* name, vector<const char*> commandline)\n        : name_(name), command_line_(commandline.begin(), commandline.end()) {}\n\n    QString name() const override { return name_; };\n\n    void run(const QString &script, const QString &working_dir, bool close_on_exit) const override\n    {\n        QString shell = userShell();\n        QStringList commandline{command_line_.begin(), command_line_.end()};\n        commandline << shell;\n\n        if (!script.isEmpty()) {\n            if (close_on_exit)\n                commandline << "-i" << "-c" << script;\n            else\n                commandline << "-i" << "-c" << QString("%1; exec %2").arg(script, shell);\n        }\n\n        albert::runDetachedProcess(commandline, working_dir);\n    };\n};\n\n\nstatic const vector<ExecutableTerminal> exec_terminals\n{\n        {"Alacritty", {"alacritty", "-e"}},\n        {"Black Box", {"blackbox-terminal", "--"}},\n        {"Console", {"kgx", "-e"}},\n        {"Cool Retro Term", {"cool-retro-term", "-e"}},\n        {"Deepin Terminal", {"deepin-terminal", "-x"}},\n        {"Elementary Terminal", {"io.elementary.terminal", "-x"}},\n        {"Foot", {"foot"}},\n        {"Gnome Terminal", {"gnome-terminal", "--"}},\n        {"Kitty", {"kitty", "--"}},\n        {"Konsole", {"konsole", "-e"}},\n        {"LXTerminal", {"lxterminal", "-e"}},\n        {"Mate-Terminal", {"mate-terminal", "-x"}},\n        {"QTerminal", {"qterminal", "-e"}},\n        {"RoxTerm", {"roxterm", "-x"}},\n        {"St", {"st", "-e"}},\n        {"Terminator", {"terminator", "-u", "-g", "/dev/null", "-x"}},  // TODO remove in future. See #1177 and https://github.com/gnome-terminator/terminator/issues/702\n        {"Terminology", {"terminology", "-e"}},\n        {"Termite", {"termite", "-e"}},\n        {"Tilix", {"tilix", "-e"}},\n        {"UXTerm", {"uxterm", "-e"}},\n        {"Urxvt", {"urxvt", "-e"}},\n        {"WezTerm", {"wezterm", "cli", "spawn", "--"}},\n        {"XFCE-Terminal", {"xfce4-terminal", "-x"}},\n        {"XTerm", {"xterm", "-e"}}\n};\n\n\nstatic vector<unique_ptr<Terminal>> findTerminals()\n{\n    vector<unique_ptr<Terminal>> result;\n    // Filter available supported terms by availability\n    for (const auto & exec_term : exec_terminals)\n        if (!QStandardPaths::findExecutable(exec_term.command_line_[0]).isNull())\n            result.emplace_back(make_unique<ExecutableTerminal>(exec_term));\n    return result;\n}\n\n\n#elif defined(Q_OS_MAC)\n\n\nstatic void execAppleScript(const QString &script)\n{\n    QProcess p;\n    DEBG << "Execute AppleScript: " << script;\n    p.start("/usr/bin/osascript", {"-l", "AppleScript"});\n    p.waitForStarted();\n    p.write(script.toUtf8());\n    p.closeWriteChannel();\n    p.waitForFinished();\n    if (p.exitCode())\n        WARN << "Executed AppleScript " << p.exitCode() << p.error();\n}\n\n\nstatic QString writeCommandFile(const QString &script, bool close_on_exit, const QString &working_dir)\n{\n    auto file = QDir(QStandardPaths::writableLocation(QStandardPaths::CacheLocation)).filePath("terminal.command");\n    QFile f(file);\n    if (f.open(QIODevice::WriteOnly)) {\n        if (!working_dir.isEmpty())\n            f.write(QString("cd \\"%1\\";").arg(working_dir).toUtf8());\n        f.write("clear;");\n        f.write(script.toUtf8());\n        if (!close_on_exit)\n            // space needed because exec behaves differently on ;;\n            f.write(QString(" ; exec %1 -i").arg(userShell()).toUtf8());\n        f.close();\n    }\n    return file;\n}\n\n\nstruct iTerm : public Terminal\n{\n    QString name() const override { return "iTerm.app"; };\n    void run(const QString &script, const QString &working_dir, bool close_on_exit) const override\n    {\n        auto file = writeCommandFile(script, close_on_exit, working_dir);\n        execAppleScript(QString("tell application \\"iTerm2\\"\\n"\n                                "create window with default profile command \\"zsh -i %1\\"\\n"\n                                "end tell").arg(file));\n    };\n};\n\n\nstruct AppleTerminal : public Terminal\n{\n    QString name() const override { return "Terminal.app"; };\n    void run(const QString &script, const QString &working_dir, bool close_on_exit) const override\n    {\n        auto file = writeCommandFile(script, close_on_exit, working_dir);\n        execAppleScript(QString("tell application \\"Terminal\\"\\n"\n                                "activate\\n"\n                                "do script \\"exec zsh -i %1\\"\\n"\n                                "end tell").arg(file));\n    };\n};\n\n\nstatic vector<unique_ptr<Terminal>> findTerminals()\n{\n    vector<unique_ptr<Terminal>> result;\n\n    if (QFile::exists("/Applications/iTerm.app"))\n        result.emplace_back(make_unique<iTerm>());\n\n    if (QFile::exists("/System/Applications/Utilities/Terminal.app"))\n        result.emplace_back(make_unique<AppleTerminal>());\n\n    return result;\n}\n\n\n#endif\n\n\nTerminalProvider::TerminalProvider() : terminal_(nullptr)\n{\n    terminals_ = findTerminals();\n    if (terminals_.empty())\n        qFatal("No terminals available.");\n\n    // Set the configured terminal\n    auto cfg_term_cmd = QSettings(qApp->applicationName()).value(CFG_TERM, QString()).toString();\n    for (const auto & terminal : terminals_)\n        if (terminal->name() == cfg_term_cmd)\n            terminal_ = terminal.get();\n\n    if (!terminal_){\n        terminal_ = terminals_[0].get();\n        INFO << "Configured terminal not available. Using:" << terminal_->name();\n        setTerminal(0);\n    }\n}\n\nconst Terminal &TerminalProvider::terminal()\n{\n    return *terminal_;\n}\n\nconst vector<unique_ptr<Terminal>> &TerminalProvider::terminals() const\n{\n    return terminals_;\n}\n\nvoid TerminalProvider::setTerminal(uint i)\n{\n    terminal_ = terminals_[i].get();\n    QSettings(qApp->applicationName()).setValue(CFG_TERM, terminal_->name());\n}\n'