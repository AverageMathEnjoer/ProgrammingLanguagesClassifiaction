b'#include <dlfcn.h>\n#include <unistd.h>\n#include <cstring>\n#include <fcntl.h>\n#include <cstdio>\n#include <sys/system_properties.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <socket.h>\n#include <malloc.h>\n#include <dl.h>\n#include <android_prop.h>\n#include "rirud.h"\n#include "config.h"\n#include "logging.h"\n#include <list>\n#include "buff_string.h"\n\n#ifndef NDEBUG\n#ifndef HAS_NATIVE_BRIDGE\n#define HAS_NATIVE_BRIDGE\n#endif\n#endif\n\n#ifdef HAS_NATIVE_BRIDGE\n\n#include "native_bridge_callbacks.h"\n\n//NOLINTNEXTLINE\nextern "C" [[gnu::visibility("default")]] uint8_t NativeBridgeItf[\n        sizeof(NativeBridgeCallbacks<__ANDROID_API_R__>) * 2]{0};\n\nstatic void *original_bridge = nullptr;\n\n__used __attribute__((destructor)) void Destructor() {\n    if (original_bridge) dlclose(original_bridge);\n}\n\n#endif\n\n__used __attribute__((constructor)) void Constructor() {\n    if (getuid() != 0) {\n        return;\n    }\n\n    std::string_view cmdline = getprogname();\n\n    if (cmdline != "zygote" &&\n        cmdline != "zygote32" &&\n        cmdline != "zygote64" &&\n        cmdline != "usap32" &&\n        cmdline != "usap64") {\n        LOGW("not zygote (cmdline=%s)", cmdline.data());\n        return;\n    }\n\n    LOGI("Riru %s (%d) in %s", riru::versionName, riru::versionCode, cmdline.data());\n    LOGI("Android %s (api %d, preview_api %d)", android_prop::GetRelease(),\n         android_prop::GetApiLevel(),\n         android_prop::GetPreviewApiLevel());\n\n    constexpr auto retries = 5U;\n    RirudSocket rirud{retries};\n\n    if (!rirud.valid()) {\n        LOGE("rirud connect fails");\n        return;\n    }\n\n    std::string magisk_path = rirud.ReadMagiskTmpfsPath();\n    if (magisk_path.empty()) {\n        LOGE("failed to obtain magisk path");\n        return;\n    }\n\n    BuffString<PATH_MAX> riru_path;\n    riru_path += magisk_path;\n    riru_path += "/.magisk/modules/riru-core/lib";\n#ifdef __LP64__\n    riru_path += "64";\n#endif\n    riru_path += "/libriru.so";\n\n    auto *handle = DlopenExt(riru_path, 0);\n    if (handle) {\n        auto init = reinterpret_cast<void (*)(void *, const char *, const RirudSocket &)>(dlsym(\n                handle, "init"));\n        if (init) {\n            init(handle, magisk_path.data(), rirud);\n        } else {\n            LOGE("dlsym init %s", dlerror());\n        }\n    } else {\n        LOGE("dlopen riru.so %s", dlerror());\n    }\n\n#ifdef HAS_NATIVE_BRIDGE\n\n    auto native_bridge = rirud.ReadNativeBridge();\n    if (native_bridge.empty()) {\n        LOGW("Failed to read original native bridge from socket");\n        return;\n    }\n\n    LOGI("original native bridge: %s", native_bridge.data());\n\n    if (native_bridge == "0") {\n        return;\n    }\n\n    original_bridge = dlopen(native_bridge.data(), RTLD_NOW);\n    if (original_bridge == nullptr) {\n        LOGE("dlopen failed: %s", dlerror());\n        return;\n    }\n\n    auto *original_native_bridge_itf = dlsym(original_bridge, "NativeBridgeItf");\n    if (original_native_bridge_itf == nullptr) {\n        LOGE("dlsym failed: %s", dlerror());\n        return;\n    }\n\n    int sdk = 0;\n    std::array<char, PROP_VALUE_MAX + 1> value;\n    if (__system_property_get("ro.build.version.sdk", value.data()) > 0) {\n        sdk = atoi(value.data());\n    }\n\n    auto callbacks_size = 0;\n    if (sdk >= __ANDROID_API_R__) {\n        callbacks_size = sizeof(NativeBridgeCallbacks<__ANDROID_API_R__>);\n    } else if (sdk == __ANDROID_API_Q__) {\n        callbacks_size = sizeof(NativeBridgeCallbacks<__ANDROID_API_Q__>);\n    } else if (sdk == __ANDROID_API_P__) {\n        callbacks_size = sizeof(NativeBridgeCallbacks<__ANDROID_API_P__>);\n    } else if (sdk == __ANDROID_API_O_MR1__) {\n        callbacks_size = sizeof(NativeBridgeCallbacks<__ANDROID_API_O_MR1__>);\n    } else if (sdk == __ANDROID_API_O__) {\n        callbacks_size = sizeof(NativeBridgeCallbacks<__ANDROID_API_O__>);\n    } else if (sdk == __ANDROID_API_N_MR1__) {\n        callbacks_size = sizeof(NativeBridgeCallbacks<__ANDROID_API_N_MR1__>);\n    } else if (sdk == __ANDROID_API_N__) {\n        callbacks_size = sizeof(NativeBridgeCallbacks<__ANDROID_API_N__>);\n    } else if (sdk == __ANDROID_API_M__) {\n        callbacks_size = sizeof(NativeBridgeCallbacks<__ANDROID_API_M__>);\n    }\n\n    memcpy(NativeBridgeItf, original_native_bridge_itf, callbacks_size);\n#endif\n}\n'