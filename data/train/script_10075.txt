b'\xef\xbb\xbf//  Copyright 2019 Google Inc. All Rights Reserved.\n//\n//  Licensed under the Apache License, Version 2.0 (the "License");\n//  you may not use this file except in compliance with the License.\n//  You may obtain a copy of the License at\n//\n//  http://www.apache.org/licenses/LICENSE-2.0\n//\n//  Unless required by applicable law or agreed to in writing, software\n//  distributed under the License is distributed on an "AS IS" BASIS,\n//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n//  See the License for the specific language governing permissions and\n//  limitations under the License.\n\nusing System;\nusing System.IO;\nusing Rubeus.Win32.Rpc;\n\nnamespace Rubeus.Ndr.Marshal\n{\n    /// <summary>\n    /// Represents an NDR pickled type.\n    /// </summary>\n    public class NdrPickledType\n    {\n        /// <summary>\n        /// Constructor from a type 1 serialized buffer.\n        /// </summary>\n        /// <param name="encoded">The type 1 serialized encoded buffer.</param>\n        public NdrPickledType(byte[] encoded)\n        {\n            BinaryReader reader = new BinaryReader(new MemoryStream(encoded));\n            if (reader.ReadByte() != 1)\n            {\n                throw new ArgumentException("Only support version 1 serialization");\n            }\n            if (reader.ReadByte() != 0x10)\n            {\n                throw new ArgumentException("Only support little-endian NDR data.");\n            }\n            if (reader.ReadInt16() != 8)\n            {\n                throw new ArgumentException("Unexpected header length");\n            }\n            // Padding.\n            reader.ReadInt32();\n            int length = reader.ReadInt32();\n            // Padding.\n            reader.ReadInt32();\n            Data = reader.ReadAllBytes(length);\n            DataRepresentation = new NdrDataRepresentation()\n            {\n                IntegerRepresentation =  NdrIntegerRepresentation.LittleEndian,\n                CharacterRepresentation = NdrCharacterRepresentation.ASCII,\n                FloatingPointRepresentation = NdrFloatingPointRepresentation.IEEE\n            };\n        }\n\n        internal NdrPickledType(byte[] data, NdrDataRepresentation data_representation)\n        {\n            DataRepresentation = data_representation;\n            if (DataRepresentation.CharacterRepresentation != NdrCharacterRepresentation.ASCII ||\n                DataRepresentation.FloatingPointRepresentation != NdrFloatingPointRepresentation.IEEE)\n            {\n                throw new ArgumentException("Invalid data representation for type 1 serialized buffer");\n            }\n            Data = data;\n        }\n\n        internal byte[] Data { get; }\n\n        internal NdrDataRepresentation DataRepresentation { get; }\n\n        /// <summary>\n        /// Convert the pickled type to a type 1 serialized encoded buffer.\n        /// </summary>\n        /// <returns>The type 1 serialized encoded buffer.</returns>\n        public byte[] ToArray()\n        {\n            MemoryStream stm = new MemoryStream();\n            BinaryWriter writer = new BinaryWriter(stm);\n\n            writer.Write((byte)1);\n            writer.Write((byte)(DataRepresentation.IntegerRepresentation == NdrIntegerRepresentation.LittleEndian ? 0x10 : 0));\n            writer.Write((short)8);\n            writer.Write(0xCCCCCCCCU);\n\n            writer.Write(Data.Length);\n            writer.Write(0);\n            writer.Write(Data);\n            return stm.ToArray();\n        }\n    }\n}\n'