b'using System;\nusing System.Diagnostics;\nusing System.Text;\n\nusing Pgno = System.UInt32;\n\nusing u32 = System.UInt32;\n\nnamespace CS_SQLite3\n{\n  using sqlite3_stmt = CSSQLite.Vdbe;\n\n  public partial class CSSQLite\n  {\n    /*\n    ** 2003 April 6\n    **\n    ** The author disclaims copyright to this source code.  In place of\n    ** a legal notice, here is a blessing:\n    **\n    **    May you do good and not evil.\n    **    May you find forgiveness for yourself and forgive others.\n    **    May you share freely, never taking more than you give.\n    **\n    *************************************************************************\n    ** This file contains code used to implement the VACUUM command.\n    **\n    ** Most of the code in this file may be omitted by defining the\n    ** SQLITE_OMIT_VACUUM macro.\n    **\n    ** $Id: vacuum.c,v 1.91 2009/07/02 07:47:33 danielk1977 Exp $\n    **\n    *************************************************************************\n    **  Included in SQLite3 port to C#-SQLite;  2008 Noah B Hart\n    **  C#-SQLite is an independent reimplementation of the SQLite software library\n    **\n    **  $Header$\n    *************************************************************************\n    */\n    //#include "sqliteInt.h"\n    //#include "vdbeInt.h"\n\n#if !SQLITE_OMIT_VACUUM && !SQLITE_OMIT_ATTACH\n    /*\n** Execute zSql on database db. Return an error code.\n*/\n    static int execSql( sqlite3 db, string zSql )\n    {\n      sqlite3_stmt pStmt = null;\n#if !NDEBUG\n      int rc;\n      //VVA_ONLY( int rc; )\n#endif\n      if ( zSql == null )\n      {\n        return SQLITE_NOMEM;\n      }\n      string Dummy = null;\n      if ( SQLITE_OK != sqlite3_prepare( db, zSql, -1, ref pStmt, ref Dummy ) )\n      {\n        return sqlite3_errcode( db );\n      }\n#if !NDEBUG\n      rc = sqlite3_step( pStmt );\n      //VVA_ONLY( rc = ) sqlite3_step(pStmt);\n      Debug.Assert( rc != SQLITE_ROW );\n#else\nsqlite3_step(pStmt);\n#endif\n      return sqlite3_finalize( ref pStmt );\n    }\n\n    /*\n    ** Execute zSql on database db. The statement returns exactly\n    ** one column. Execute this as SQL on the same database.\n    */\n    static int execExecSql( sqlite3 db, string zSql )\n    {\n      sqlite3_stmt pStmt = null;\n      int rc;\n\n      string Dummy = null;\n      rc = sqlite3_prepare( db, zSql, -1, ref pStmt, ref Dummy );\n      if ( rc != SQLITE_OK ) return rc;\n\n      while ( SQLITE_ROW == sqlite3_step( pStmt ) )\n      {\n        rc = execSql( db, sqlite3_column_text( pStmt, 0 ) );\n        if ( rc != SQLITE_OK )\n        {\n          sqlite3_finalize( ref pStmt );\n          return rc;\n        }\n      }\n\n      return sqlite3_finalize( ref pStmt );\n    }\n\n    /*\n    ** The non-standard VACUUM command is used to clean up the database,\n    ** collapse free space, etc.  It is modelled after the VACUUM command\n    ** in PostgreSQL.\n    **\n    ** In version 1.0.x of SQLite, the VACUUM command would call\n    ** gdbm_reorganize() on all the database tables.  But beginning\n    ** with 2.0.0, SQLite no longer uses GDBM so this command has\n    ** become a no-op.\n    */\n    static void sqlite3Vacuum( Parse pParse )\n    {\n      Vdbe v = sqlite3GetVdbe( pParse );\n      if ( v != null )\n      {\n        sqlite3VdbeAddOp2( v, OP_Vacuum, 0, 0 );\n      }\n      return;\n    }\n\n    /*\n    ** This routine implements the OP_Vacuum opcode of the VDBE.\n    */\n    static int sqlite3RunVacuum( ref string pzErrMsg, sqlite3 db )\n    {\n      int rc = SQLITE_OK;     /* Return code from service routines */\n      Btree pMain;            /* The database being vacuumed */\n      Btree pTemp;            /* The temporary database we vacuum into */\n      string zSql = "";       /* SQL statements */\n      int saved_flags;        /* Saved value of the db.flags */\n      int saved_nChange;      /* Saved value of db.nChange */\n      int saved_nTotalChange; /* Saved value of db.nTotalChange */\n      Db pDb = null;          /* Database to detach at end of vacuum */\n      bool isMemDb;           /* True if vacuuming a :memory: database */\n      int nRes;\n\n      if ( 0 == db.autoCommit )\n      {\n        sqlite3SetString( ref pzErrMsg, db, "cannot VACUUM from within a transaction" );\n        return SQLITE_ERROR;\n      }\n\n      /* Save the current value of the write-schema flag before setting it. */\n      saved_flags = db.flags;\n      saved_nChange = db.nChange;\n      saved_nTotalChange = db.nTotalChange;\n      db.flags |= SQLITE_WriteSchema | SQLITE_IgnoreChecks;\n\n      pMain = db.aDb[0].pBt;\n      isMemDb = sqlite3PagerIsMemdb( sqlite3BtreePager( pMain ) );\n\n      /* Attach the temporary database as \'vacuum_db\'. The synchronous pragma\n      ** can be set to \'off\' for this file, as it is not recovered if a crash\n      ** occurs anyway. The integrity of the database is maintained by a\n      ** (possibly synchronous) transaction opened on the main database before\n      ** sqlite3BtreeCopyFile() is called.\n      **\n      ** An optimisation would be to use a non-journaled pager.\n      ** (Later:) I tried setting "PRAGMA vacuum_db.journal_mode=OFF" but\n      ** that actually made the VACUUM run slower.  Very little journalling\n      ** actually occurs when doing a vacuum since the vacuum_db is initially\n      ** empty.  Only the journal header is written.  Apparently it takes more\n      ** time to parse and run the PRAGMA to turn journalling off than it does\n      ** to write the journal header file.\n      */\n      zSql = "ATTACH \'\' AS vacuum_db;";\n      rc = execSql( db, zSql );\n      if ( rc != SQLITE_OK ) goto end_of_vacuum;\n      pDb = db.aDb[db.nDb - 1];\n      Debug.Assert( db.aDb[db.nDb - 1].zName == "vacuum_db" );\n      pTemp = db.aDb[db.nDb - 1].pBt;\n\n      nRes = sqlite3BtreeGetReserve( pMain );\n\n      /* A VACUUM cannot change the pagesize of an encrypted database. */\n#if SQLITE_HAS_CODEC\nif( db.nextPagesize ){\nextern void sqlite3CodecGetKey(sqlite3*, int, void**, int*);\nint nKey;\nchar *zKey;\nsqlite3CodecGetKey(db, 0, (void**)&zKey, nKey);\nif( nKey ) db.nextPagesize = 0;\n}\n#endif\n\n      if ( sqlite3BtreeSetPageSize( pTemp, sqlite3BtreeGetPageSize( pMain ), nRes, 0 ) != 0\n      || ( !isMemDb && sqlite3BtreeSetPageSize( pTemp, db.nextPagesize, nRes, 0 ) != 0 )\n      //|| NEVER( db.mallocFailed != 0 )\n      )\n      {\n        rc = SQLITE_NOMEM;\n        goto end_of_vacuum;\n      }\n      rc = execSql( db, "PRAGMA vacuum_db.synchronous=OFF" );\n      if ( rc != SQLITE_OK )\n      {\n        goto end_of_vacuum;\n      }\n\n#if !SQLITE_OMIT_AUTOVACUUM\n      sqlite3BtreeSetAutoVacuum( pTemp, db.nextAutovac >= 0 ? db.nextAutovac :\n                             sqlite3BtreeGetAutoVacuum( pMain ) );\n#endif\n\n      /* Begin a transaction */\n      rc = execSql( db, "BEGIN EXCLUSIVE;" );\n      if ( rc != SQLITE_OK ) goto end_of_vacuum;\n\n      /* Query the schema of the main database. Create a mirror schema\n      ** in the temporary database.\n      */\n      rc = execExecSql( db,\n      "SELECT \'CREATE TABLE vacuum_db.\' || substr(sql,14) " +\n      "  FROM sqlite_master WHERE type=\'table\' AND name!=\'sqlite_sequence\'" +\n      "   AND rootpage>0"\n      );\n      if ( rc != SQLITE_OK ) goto end_of_vacuum;\n      rc = execExecSql( db,\n      "SELECT \'CREATE INDEX vacuum_db.\' || substr(sql,14)" +\n      "  FROM sqlite_master WHERE sql LIKE \'CREATE INDEX %\' " );\n      if ( rc != SQLITE_OK ) goto end_of_vacuum;\n      rc = execExecSql( db,\n      "SELECT \'CREATE UNIQUE INDEX vacuum_db.\' || substr(sql,21) " +\n      "  FROM sqlite_master WHERE sql LIKE \'CREATE UNIQUE INDEX %\'" );\n      if ( rc != SQLITE_OK ) goto end_of_vacuum;\n\n      /* Loop through the tables in the main database. For each, do\n      ** an "INSERT INTO vacuum_db.xxx SELECT * FROM xxx;" to copy\n      ** the contents to the temporary database.\n      */\n      rc = execExecSql( db,\n      "SELECT \'INSERT INTO vacuum_db.\' || quote(name) " +\n      "|| \' SELECT * FROM \' || quote(name) || \';\'" +\n      "FROM sqlite_master " +\n      "WHERE type = \'table\' AND name!=\'sqlite_sequence\' " +\n      "  AND rootpage>0"\n\n      );\n      if ( rc != SQLITE_OK ) goto end_of_vacuum;\n\n      /* Copy over the sequence table\n      */\n      rc = execExecSql( db,\n      "SELECT \'DELETE FROM vacuum_db.\' || quote(name) || \';\' " +\n      "FROM vacuum_db.sqlite_master WHERE name=\'sqlite_sequence\' "\n      );\n      if ( rc != SQLITE_OK ) goto end_of_vacuum;\n      rc = execExecSql( db,\n      "SELECT \'INSERT INTO vacuum_db.\' || quote(name) " +\n      "|| \' SELECT * FROM \' || quote(name) || \';\' " +\n      "FROM vacuum_db.sqlite_master WHERE name==\'sqlite_sequence\';"\n      );\n      if ( rc != SQLITE_OK ) goto end_of_vacuum;\n\n\n      /* Copy the triggers, views, and virtual tables from the main database\n      ** over to the temporary database.  None of these objects has any\n      ** associated storage, so all we have to do is copy their entries\n      ** from the SQLITE_MASTER table.\n      */\n      rc = execSql( db,\n      "INSERT INTO vacuum_db.sqlite_master " +\n      "  SELECT type, name, tbl_name, rootpage, sql" +\n      "    FROM sqlite_master" +\n      "   WHERE type=\'view\' OR type=\'trigger\'" +\n      "      OR (type=\'table\' AND rootpage=0)"\n      );\n      if ( rc != 0 ) goto end_of_vacuum;\n\n      /* At this point, unless the main db was completely empty, there is now a\n      ** transaction open on the vacuum database, but not on the main database.\n      ** Open a btree level transaction on the main database. This allows a\n      ** call to sqlite3BtreeCopyFile(). The main database btree level\n      ** transaction is then committed, so the SQL level never knows it was\n      ** opened for writing. This way, the SQL transaction used to create the\n      ** temporary database never needs to be committed.\n      */\n      {\n        u32 meta = 0;\n        int i;\n\n        /* This array determines which meta meta values are preserved in the\n        ** vacuum.  Even entries are the meta value number and odd entries\n        ** are an increment to apply to the meta value after the vacuum.\n        ** The increment is used to increase the schema cookie so that other\n        ** connections to the same database will know to reread the schema.\n        */\n        byte[] aCopy = new byte[]  {\nBTREE_SCHEMA_VERSION,     1,  /* Add one to the old schema cookie */\nBTREE_DEFAULT_CACHE_SIZE, 0,  /* Preserve the default page cache size */\nBTREE_TEXT_ENCODING,      0,  /* Preserve the text encoding */\nBTREE_USER_VERSION,       0,  /* Preserve the user version */\n};\n\n        Debug.Assert( sqlite3BtreeIsInTrans( pTemp ) );\n        Debug.Assert( sqlite3BtreeIsInTrans( pMain ) );\n\n        /* Copy Btree meta values */\n        for ( i = 0 ; i < ArraySize( aCopy ) ; i += 2 )\n        {\n          /* GetMeta() and UpdateMeta() cannot fail in this context because\n          ** we already have page 1 loaded into cache and marked dirty. */\n          sqlite3BtreeGetMeta( pMain, aCopy[i], ref meta );\n          rc = sqlite3BtreeUpdateMeta( pTemp, aCopy[i], (u32)( meta + aCopy[i + 1] ) );\n          if ( NEVER( rc != SQLITE_OK ) ) goto end_of_vacuum;\n        }\n\n        rc = sqlite3BtreeCopyFile( pMain, pTemp );\n        if ( rc != SQLITE_OK ) goto end_of_vacuum;\n        rc = sqlite3BtreeCommit( pTemp );\n        if ( rc != SQLITE_OK ) goto end_of_vacuum;\n#if !SQLITE_OMIT_AUTOVACUUM\n        sqlite3BtreeSetAutoVacuum( pMain, sqlite3BtreeGetAutoVacuum( pTemp ) );\n#endif\n      }\n      Debug.Assert( rc == SQLITE_OK );\n      rc = sqlite3BtreeSetPageSize( pMain, sqlite3BtreeGetPageSize( pTemp ), nRes, 1 );\n\nend_of_vacuum:\n      /* Restore the original value of db.flags */\n      db.flags = saved_flags;\n      db.nChange = saved_nChange;\n      db.nTotalChange = saved_nTotalChange;\n\n      /* Currently there is an SQL level transaction open on the vacuum\n      ** database. No locks are held on any other files (since the main file\n      ** was committed at the btree level). So it safe to end the transaction\n      ** by manually setting the autoCommit flag to true and detaching the\n      ** vacuum database. The vacuum_db journal file is deleted when the pager\n      ** is closed by the DETACH.\n      */\n      db.autoCommit = 1;\n\n      if ( pDb != null )\n      {\n        sqlite3BtreeClose( ref pDb.pBt );\n        pDb.pBt = null;\n        pDb.pSchema = null;\n      }\n\n      sqlite3ResetInternalSchema( db, 0 );\n\n      return rc;\n    }\n#endif  // * SQLITE_OMIT_VACUUM && SQLITE_OMIT_ATTACH */\n  }\n}\n'