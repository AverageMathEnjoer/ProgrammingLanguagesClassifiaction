b'\n-- Ported from Haskell CnC version (BSD license)\n--   by Chih-Ping Chen\n\n-- NOTE: This is a contributed program that uses unsafePerformIO and\n-- thus is not a representative Par program.\n\n{-# LANGUAGE ExistentialQuantification\n   , ScopedTypeVariables\n   , BangPatterns\n   , NamedFieldPuns\n   , RecordWildCards\n   , FlexibleInstances\n   , DeriveDataTypeable\n   , TypeSynonymInstances\n   , PackageImports\n   , CPP #-}\n\n-- Author: Chih-Ping Chen\n-- Modified by Ryan Newton.\n\n-- This program uses monad-par to do cholesky transformation.\n\n-- Description\n-- -----------\n-- Given a symmetric positive definite matrix A, the Cholesky decomposition is\n-- a lower triangular matrix L such that A=L.L^(T).\n\n-- Usage\n-- -----\n\n-- The command line is:\n\n-- cholesky n b filename\n-- \t n :\tinput SPD matrix size\n-- \t b : \tblock/tile size\n-- \t filename: input matrix file name\n\n-- Several sample input files are provided. m6.in is a 6x6 matrix (n=6).\n-- Input_matrix.zip contains the files m50.in, m100.in, m500.in, and m1000.in with\n-- corresponding \'n\' of 50, 100, 500, and 1000.\n\n-- e.g.\n-- cholesky 1000 50 m1000.in 4\n-- cholesky v 6 2 m6.in\n\n-- The input SPD matrix is read from the file specified. The output will be a\n-- lower triangular matrix.\n\nimport Data.Int\nimport qualified Data.List as List\nimport qualified Data.Array.Unboxed as Array\nimport Data.Array.IO\nimport Data.Array.MArray\nimport Debug.Trace\nimport System.Posix.Files\nimport System.Environment\nimport System.IO\nimport System.IO.Unsafe\nimport Data.Map\nimport Data.IORef\nimport qualified Data.ByteString.Char8 as B\n\n-- Fix the old deepseq version for the NFData Map instance.\n-- A seriously annoying portability problem.\n-- import "deepseq-1.1.0.2" Control.DeepSeq\nimport "deepseq" Control.DeepSeq\nimport Control.Exception\nimport Data.Time.Clock -- Not in 6.10\n\nimport Control.Monad\n#ifdef PARSCHED\nimport PARSCHED\n#else\nimport Control.Monad.Par\n#endif\n\ntimeit io =\n    do strt <- getCurrentTime\n       io\n       end  <- getCurrentTime\n       return (diffUTCTime end strt)\n\n-- The type of the input/output array.\ntype Matrix = Array.UArray (Int, Int) Float\n\n-- A matrix is divided into "Tile"s, and carries intermediate results\n-- of the computation.\ntype Tile = IOUArray  (Int, Int) Float\n\n-- Tile3D allows us to refer to a IVar associated with a tile. The first\n-- two dimensions of the index are the coordinates of the tile in the matrix.\n-- The last dimension is the "generation" dimension. I.e., a (IVar Tile) mapped\n-- by (i, j, k+1) is the next generation of the (IVar Tile) mapped by (i, j, k).\ntype Tiles3D = Map (Int, Int, Int) (IVar Tile)\n\n-- NFData is needed for spawnP.  Use default instances.\ninstance NFData Matrix\ninstance NFData Tile where\n\ninstance NFData Tiles3D where\n-- ^^ The automatic instance for Maps was REMOVED in Deepseq 1.2\n--    Deepseq 1.1 will cause a problem here.  We force 1.2 in the monad-par.cabal file.\n\n\nparMap_ :: (a -> Par ()) -> [a] -> Par ()\nparMap_ f xs = mapM (spawn . f) xs >> return ()\n\ngetTileV :: (Int, Int, Int) -> Tiles3D -> IVar Tile\ngetTileV triplet tiles =\n    findWithDefault (error "This can\'t be happening...") triplet tiles\n\n-- This kicks off cholesky factorization on the diagonal tiles.\ns0Compute :: IVar Tiles3D -> Int -> Int -> Par ()\ns0Compute lkjiv p b =\n    do lkji <- get lkjiv\n       parMap_ (s1Compute lkji p b) [0..p-1]\n\n-- This does the cholesky factorization on the a diagonal tile, and\n-- kicks off triangular system solve on the tiles that are below and\n-- on the same column as the diagonal tile.\ns1Compute :: Tiles3D -> Int -> Int -> Int -> Par ()\ns1Compute lkji p b k =\n    do\n       -- Read the tile:\n       aBlock <- get $ getTileV (k, k, k) lkji\n       -- Write an output tile:\n       put (getTileV (k, k, k+1) lkji) (s1Core aBlock b)\n       -- Do triangular solves on the tiles with the same column number\n       parMap_ (s2Compute lkji b) [(k,j) | j <- [k+1..p-1]]\n    where s1Core aBlock b = unsafePerformIO $\n                            do lBlock <- newArray ((0,0), (b-1,b-1)) 0.0\n                               forM_ [0..b-1] (outer aBlock lBlock b)\n                               return lBlock\n          outer aBlock lBlock b kb = do base <- readArray aBlock (kb,kb)\n                                        writeArray lBlock (kb,kb) (sqrt base)\n                                        forM_ [kb+1 .. b-1] (inner1 aBlock lBlock kb)\n                                        forM_ [kb+1 .. b-1] (inner2 aBlock lBlock kb b)\n          inner1 aBlock lBlock kb jb = do base1 <- readArray aBlock (jb,kb)\n                                          base2 <- readArray lBlock (kb,kb)\n                                          writeArray lBlock (jb,kb) (base1 /base2)\n          inner2 aBlock lBlock kb b jbb = do forM_ [kb+1 .. b-1] (inner3 aBlock lBlock jbb kb)\n          inner3 aBlock lBlock jbb kb ib = do base1 <- readArray aBlock (ib, jbb)\n                                              base2 <- readArray lBlock (ib, kb)\n                                              base3 <- readArray lBlock (jbb, kb)\n                                              writeArray aBlock (ib,jbb) (base1 - base2 * base3)\n\n-- This does the triangular system solve on a tile T, and\n-- kicks off the symmetric rank-k update on the tiles that\n-- are to the right and on the same row as T.\ns2Compute :: Tiles3D -> Int -> (Int, Int) -> Par ()\ns2Compute lkji b (k, j) =\n    do\n       aBlock <- get $ getTileV (j,k,k) lkji\n       liBlock <- get $ getTileV (k,k,k+1) lkji\n       put (getTileV (j,k,k+1) lkji) (s2Core aBlock liBlock b)\n       parMap_ (s3Compute lkji b) [(k, j, i) | i <- [k+1..j]]\n    where s2Core aBlock liBlock b = unsafePerformIO $\n                                    do loBlock <- newArray ((0,0),(b-1,b-1)) 0.0\n                                       forM_ [0..b-1] (outer aBlock liBlock loBlock b)\n                                       return loBlock\n          outer aBlock liBlock loBlock b kb = do forM_ [0..b-1] (inner1 aBlock liBlock loBlock kb)\n                                                 forM_ [kb+1..b-1] (inner2 aBlock liBlock loBlock b kb)\n          inner1 aBlock liBlock loBlock kb ib = do base1 <- readArray aBlock (ib,kb)\n                                                   base2 <- readArray liBlock (kb,kb)\n                                                   writeArray loBlock (ib,kb) (base1 / base2)\n          inner2 aBlock liBlock loBlock b kb jb = do forM_ [0..b-1] (inner3 aBlock liBlock loBlock kb jb)\n          inner3 aBlock liBlock loBlock kb jb ib = do base1 <- readArray aBlock (ib,jb)\n                                                      base2 <- readArray liBlock (jb,kb)\n                                                      base3 <- readArray loBlock (ib,kb)\n                                                      writeArray aBlock (ib,jb) (base1 - (base2 * base3))\n\n\n-- This computes the symmetric rank-k update on a tile.\ns3Compute :: Tiles3D -> Int -> (Int, Int, Int) -> Par ()\ns3Compute lkji b (k,j,i) | i == j =\n    do\n       aBlock <- get $ getTileV (j,i,k) lkji\n       l2Block <- get $ getTileV (j,k,k+1) lkji\n       put (getTileV (j,i,k+1) lkji) (s3Core aBlock l2Block b)\n--       spawnP lkji\n       return ()\n    where s3Core aBlock l2Block b = unsafePerformIO $\n                                    do forM_ [0..b-1] (outer aBlock l2Block b)\n                                       return aBlock\n          outer aBlock l2Block b jb = do forM_ [0..b-1] (inner1 aBlock l2Block b jb)\n          inner1 aBlock l2Block b jb kb = do base <- readArray l2Block (jb,kb)\n                                             forM_ [jb..b-1] (inner2 aBlock l2Block jb kb (-base))\n          inner2 aBlock l2Block jb kb temp ib = do base1 <- readArray aBlock (ib,jb)\n                                                   base2 <- readArray l2Block (ib,kb)\n                                                   writeArray aBlock (ib,jb) (base1 + temp * base2)\n\ns3Compute lkji b (k,j,i) | otherwise =\n    do\n       aBlock <- get $ getTileV (j,i,k) lkji\n       l2Block <- get $ getTileV (i,k,k+1) lkji\n       l1Block <- get $ getTileV (j,k,k+1) lkji\n       put (getTileV (j,i,k+1) lkji) (s3Core aBlock l1Block l2Block b)\n       return ()\n    where s3Core aBlock l1Block l2Block b = unsafePerformIO $\n                                            do forM_ [0..b-1] (outer aBlock l1Block l2Block b)\n                                               return aBlock\n          outer aBlock l1Block l2Block b jb = do forM_ [0..b-1] (inner1 aBlock l1Block l2Block b jb)\n          inner1 aBlock l1Block l2Block b jb kb = do base <- readArray l2Block (jb,kb)\n                                                     forM_ [0..b-1] (inner2 aBlock l1Block jb kb (-base))\n          inner2 aBlock l1Block jb kb temp ib = do base1 <- readArray aBlock (ib,jb)\n                                                   base2 <- readArray l1Block (ib,kb)\n                                                   writeArray aBlock (ib,jb) (base1 + temp * base2)\n\n-- initLkji initialize the (IVar Tile) map using the input array.\ninitLkji :: Matrix -> Int -> Int -> Int -> Par (IVar Tiles3D)\ninitLkji arrA n p b =\n    let tile i j = unsafePerformIO $ newListArray ((0,0),(b-1,b-1)) (tileList i j)\n        tileList i j = [ arrA Array.! (i * b + ii, j * b + jj) | ii <- [0..b-1], jj <-[0..b-1]]\n        fn c (i, j, k) | k == 0 =\n            do mv <- c\n               m <- get mv\n               tv <- spawnP $ tile i j\n               spawnP $ insert (i, j, k) tv m\n        fn c (i, j, k) | otherwise =\n            do mv <- c\n               m <- get mv\n               tv <- new\n               spawnP $ insert (i, j, k) tv m\n    in List.foldl fn (spawnP empty)  [(i, j, k) | i <- [0..p-1], j <- [0..i], k <- [0..j+1]]\n\n\n-- composeResult collect the tiles with the final results back into one single matrix.\ncomposeResult :: Tiles3D -> Int -> Int -> Int -> Par Matrix\ncomposeResult lkji n p b =\n    do assocs <- sequence [ grab i ib j | i <- [0..p-1], ib <- [0..b-1], j <- [0..i]]\n       return $ Array.array ((0,0),(n-1,n-1)) (concat assocs)\n    where grab i ib j = if (i == j) then\n                           do matOut <- get $ getTileV (i,j,j+1) lkji\n                              compose1 matOut\n                        else\n                           do matOut <- get $ getTileV (i,j,j+1) lkji\n                              compose2 matOut\n                        where compose1 matOut = do forM [0..ib] (compose11 matOut)\n                              compose11 matOut jb = let elem = unsafePerformIO $\n                                                               do readArray matOut (ib,jb)\n                                                    in return ((i*b+ib,j*b+jb),elem)\n                              compose2 matOut = do forM [0..b-1] (compose11 matOut)\n\n{-# INLINE for_ #-}\nfor_ start end fn | start > end = error "for_: start is greater than end"\nfor_ start end fn = loop start\n where\n  loop !i | i == end  = return ()\n          | otherwise = do fn i; loop (i+1)\n\nrun :: Int -> Int -> Matrix -> Matrix\nrun n b arrA =\n    let p = n `div` b\n    in\n        runPar $\n        do\n            lkjiv <- initLkji arrA n p b\n            _ <- s0Compute lkjiv p b\n            lkji\' <- get lkjiv\n            composeResult lkji\' n p b\n\nmain =\n    do ls <- getArgs\n       let (n, b, fname) =\n            case ls of\n              []           -> (6,     2, "cholesky_matrix6.dat")\n\n              -- To get more data try this:\n\t      -- wget http://people.csail.mit.edu/newton/haskell-cnc/datasets/cholesky_matrix_data.tbz\n\n              ["medium"]   -> (500,  50, "cholesky_matrix500.dat")\n              ["big"]      -> (1000, 50, "cholesky_matrix1000.dat")\n              [a,b,c]      -> (read a, read b, c)\n\n       bool <- fileExist fname\n       let fname\' = if bool then fname else "examples/"++fname\n\n       ref <- newIORef undefined\n       let meaningless_write !val = writeIORef ref val\n\n       t1 <- getCurrentTime\n       putStrLn "Begin reading from disk..."\n       arrA <- initMatrix n fname\'\n       evaluate arrA\n       t2 <- getCurrentTime\n       putStrLn $" ... ArrA read from disk: time " ++ show (diffUTCTime t2 t1)\n       hFlush stdout\n\n       arrB <- return $ run n b arrA\n       --putStrLn $ show $ [((i,j),arrB Array.! (i,j)) | i <-[0..n-1], j<-[0..i]]\n\n       putStrLn "Making sure evaluation of arrB is forced..."\n       evaluate arrB\n       --putStrLn $ show $ [((i,j),arrB Array.! (i,j)) | i <-[0..n-1], j<-[0..i]]\n       t3 <- getCurrentTime\n\n-- FIXME: Using deepseq here seems to delay the evaluation to the reference of\n--       t3 <- case deepseq arrB () of _ -> getCurrentTime\n--       t3 <- arrB `deepseq` getCurrentTime\n       putStrLn$ "Finished: eval time "++ show (diffUTCTime t3 t2)\n\n       putStrLn$ "SELFTIMED " ++ show ((fromRational $ toRational $ diffUTCTime t3 t2) :: Double)\n       t4 <- getCurrentTime\n       val <- readIORef ref\n       putStrLn$ "Last value: " ++ show (arrB Array.! (n-1, n-1))\n       t5 <- getCurrentTime\n       putStrLn$ "SELFTIMED\' " ++ show ((fromRational $ toRational $ diffUTCTime t5 t4) :: Double)\n\ninitMatrix :: Int -> [Char] -> IO Matrix\ninitMatrix n fname =\n    do fs <- B.readFile fname\n       return $! Array.listArray ((0,0), (n-1, n-1))\n                                (List.cycle $ List.map (read . B.unpack) (B.words fs))\n\n'