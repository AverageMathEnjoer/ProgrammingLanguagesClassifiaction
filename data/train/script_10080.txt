b'/*\n * Copyright (C) 2013 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the "License");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an "AS IS" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\npackage com.naman14.timber.slidinguppanel;\n\nimport android.content.Context;\nimport androidx.core.view.MotionEventCompat;\nimport androidx.core.view.VelocityTrackerCompat;\nimport androidx.core.view.ViewCompat;\nimport androidx.core.widget.ScrollerCompat;\nimport android.view.MotionEvent;\nimport android.view.VelocityTracker;\nimport android.view.View;\nimport android.view.ViewConfiguration;\nimport android.view.ViewGroup;\nimport android.view.animation.Interpolator;\n\nimport java.util.Arrays;\n\n/**\n * ViewDragHelper is a utility class for writing custom ViewGroups. It offers a number\n * of useful operations and state tracking for allowing a user to drag and reposition\n * views within their parent ViewGroup.\n */\npublic class ViewDragHelper {\n    /**\n     * A null/invalid pointer ID.\n     */\n    public static final int INVALID_POINTER = -1;\n    /**\n     * A view is not currently being dragged or animating as a result of a fling/snap.\n     */\n    public static final int STATE_IDLE = 0;\n    /**\n     * A view is currently being dragged. The position is currently changing as a result\n     * of user input or simulated user input.\n     */\n    public static final int STATE_DRAGGING = 1;\n    /**\n     * A view is currently settling into place as a result of a fling or\n     * predefined non-interactive motion.\n     */\n    public static final int STATE_SETTLING = 2;\n    /**\n     * Edge flag indicating that the left edge should be affected.\n     */\n    public static final int EDGE_LEFT = 1 << 0;\n    /**\n     * Edge flag indicating that the right edge should be affected.\n     */\n    public static final int EDGE_RIGHT = 1 << 1;\n    /**\n     * Edge flag indicating that the top edge should be affected.\n     */\n    public static final int EDGE_TOP = 1 << 2;\n    /**\n     * Edge flag indicating that the bottom edge should be affected.\n     */\n    public static final int EDGE_BOTTOM = 1 << 3;\n    /**\n     * Edge flag set indicating all edges should be affected.\n     */\n    public static final int EDGE_ALL = EDGE_LEFT | EDGE_TOP | EDGE_RIGHT | EDGE_BOTTOM;\n    /**\n     * Indicates that a check should occur along the horizontal axis\n     */\n    public static final int DIRECTION_HORIZONTAL = 1 << 0;\n    /**\n     * Indicates that a check should occur along the vertical axis\n     */\n    public static final int DIRECTION_VERTICAL = 1 << 1;\n    /**\n     * Indicates that a check should occur along all axes\n     */\n    public static final int DIRECTION_ALL = DIRECTION_HORIZONTAL | DIRECTION_VERTICAL;\n    private static final String TAG = "ViewDragHelper";\n    private static final int EDGE_SIZE = 20; // dp\n\n    private static final int BASE_SETTLE_DURATION = 256; // ms\n    private static final int MAX_SETTLE_DURATION = 600; // ms\n    /**\n     * Interpolator defining the animation curve for mScroller\n     */\n    private static final Interpolator sInterpolator = new Interpolator() {\n        public float getInterpolation(float t) {\n            t -= 1.0f;\n            return t * t * t * t * t + 1.0f;\n        }\n    };\n    private final Callback mCallback;\n    private final ViewGroup mParentView;\n    // Current drag state; idle, dragging or settling\n    private int mDragState;\n    // Distance to travel before a drag may begin\n    private int mTouchSlop;\n    // Last known position/pointer tracking\n    private int mActivePointerId = INVALID_POINTER;\n    private float[] mInitialMotionX;\n    private float[] mInitialMotionY;\n    private float[] mLastMotionX;\n    private float[] mLastMotionY;\n    private int[] mInitialEdgesTouched;\n    private int[] mEdgeDragsInProgress;\n    private int[] mEdgeDragsLocked;\n    private int mPointersDown;\n    private VelocityTracker mVelocityTracker;\n    private float mMaxVelocity;\n    private float mMinVelocity;\n    private int mEdgeSize;\n    private int mTrackingEdges;\n    private ScrollerCompat mScroller;\n    private View mCapturedView;\n    private final Runnable mSetIdleRunnable = new Runnable() {\n        public void run() {\n            setDragState(STATE_IDLE);\n        }\n    };\n    private boolean mReleaseInProgress;\n\n    /**\n     * Apps should use ViewDragHelper.create() to get a new instance.\n     * This will allow VDH to use internal compatibility implementations for different\n     * platform versions.\n     *\n     * @param context   Context to initialize config-dependent params from\n     * @param forParent Parent view to monitor\n     */\n    private ViewDragHelper(Context context, ViewGroup forParent, Callback cb) {\n        if (forParent == null) {\n            throw new IllegalArgumentException("Parent view may not be null");\n        }\n        if (cb == null) {\n            throw new IllegalArgumentException("Callback may not be null");\n        }\n\n        mParentView = forParent;\n        mCallback = cb;\n\n        final ViewConfiguration vc = ViewConfiguration.get(context);\n        final float density = context.getResources().getDisplayMetrics().density;\n        mEdgeSize = (int) (EDGE_SIZE * density + 0.5f);\n\n        mTouchSlop = vc.getScaledTouchSlop();\n        mMaxVelocity = vc.getScaledMaximumFlingVelocity();\n        mMinVelocity = vc.getScaledMinimumFlingVelocity();\n        mScroller = ScrollerCompat.create(context, sInterpolator);\n    }\n\n    /**\n     * Factory method to create a new ViewDragHelper.\n     *\n     * @param forParent Parent view to monitor\n     * @param cb        Callback to provide information and receive events\n     * @return a new ViewDragHelper instance\n     */\n    public static ViewDragHelper create(ViewGroup forParent, Callback cb) {\n        return new ViewDragHelper(forParent.getContext(), forParent, cb);\n    }\n\n    /**\n     * Factory method to create a new ViewDragHelper.\n     *\n     * @param forParent   Parent view to monitor\n     * @param sensitivity Multiplier for how sensitive the helper should be about detecting\n     *                    the start of a drag. Larger values are more sensitive. 1.0f is normal.\n     * @param cb          Callback to provide information and receive events\n     * @return a new ViewDragHelper instance\n     */\n    public static ViewDragHelper create(ViewGroup forParent, float sensitivity, Callback cb) {\n        final ViewDragHelper helper = create(forParent, cb);\n        helper.mTouchSlop = (int) (helper.mTouchSlop * (1 / sensitivity));\n        return helper;\n    }\n\n    /**\n     * Return the currently configured minimum velocity. Any flings with a magnitude less\n     * than this value in pixels per second. Callback methods accepting a velocity will receive\n     * zero as a velocity value if the real detected velocity was below this threshold.\n     *\n     * @return the minimum velocity that will be detected\n     */\n    public float getMinVelocity() {\n        return mMinVelocity;\n    }\n\n    /**\n     * Set the minimum velocity that will be detected as having a magnitude greater than zero\n     * in pixels per second. Callback methods accepting a velocity will be clamped appropriately.\n     *\n     * @param minVel Minimum velocity to detect\n     */\n    public void setMinVelocity(float minVel) {\n        mMinVelocity = minVel;\n    }\n\n    /**\n     * Retrieve the current drag state of this helper. This will return one of\n     * {@link #STATE_IDLE}, {@link #STATE_DRAGGING} or {@link #STATE_SETTLING}.\n     *\n     * @return The current drag state\n     */\n    public int getViewDragState() {\n        return mDragState;\n    }\n\n    /**\n     * Enable edge tracking for the selected edges of the parent view.\n     * The callback\'s {@link Callback#onEdgeTouched(int, int)} and\n     * {@link Callback#onEdgeDragStarted(int, int)} methods will only be invoked\n     * for edges for which edge tracking has been enabled.\n     *\n     * @param edgeFlags Combination of edge flags describing the edges to watch\n     * @see #EDGE_LEFT\n     * @see #EDGE_TOP\n     * @see #EDGE_RIGHT\n     * @see #EDGE_BOTTOM\n     */\n    public void setEdgeTrackingEnabled(int edgeFlags) {\n        mTrackingEdges = edgeFlags;\n    }\n\n    /**\n     * Return the size of an edge. This is the range in pixels along the edges of this view\n     * that will actively detect edge touches or drags if edge tracking is enabled.\n     *\n     * @return The size of an edge in pixels\n     * @see #setEdgeTrackingEnabled(int)\n     */\n    public int getEdgeSize() {\n        return mEdgeSize;\n    }\n\n    /**\n     * Capture a specific child view for dragging within the parent. The callback will be notified\n     * but {@link Callback#tryCaptureView(android.view.View, int)} will not be asked permission to\n     * capture this view.\n     *\n     * @param childView       Child view to capture\n     * @param activePointerId ID of the pointer that is dragging the captured child view\n     */\n    public void captureChildView(View childView, int activePointerId) {\n        if (childView.getParent() != mParentView) {\n            throw new IllegalArgumentException("captureChildView: parameter must be a descendant " +\n                    "of the ViewDragHelper\'s tracked parent view (" + mParentView + ")");\n        }\n\n        mCapturedView = childView;\n        mActivePointerId = activePointerId;\n        mCallback.onViewCaptured(childView, activePointerId);\n        setDragState(STATE_DRAGGING);\n    }\n\n    /**\n     * @return The currently captured view, or null if no view has been captured.\n     */\n    public View getCapturedView() {\n        return mCapturedView;\n    }\n\n    /**\n     * @return The ID of the pointer currently dragging the captured view,\n     * or {@link #INVALID_POINTER}.\n     */\n    public int getActivePointerId() {\n        return mActivePointerId;\n    }\n\n    /**\n     * @return The minimum distance in pixels that the user must travel to initiate a drag\n     */\n    public int getTouchSlop() {\n        return mTouchSlop;\n    }\n\n    /**\n     * The result of a call to this method is equivalent to\n     * {@link #processTouchEvent(android.view.MotionEvent)} receiving an ACTION_CANCEL event.\n     */\n    public void cancel() {\n        mActivePointerId = INVALID_POINTER;\n        clearMotionHistory();\n\n        if (mVelocityTracker != null) {\n            mVelocityTracker.recycle();\n            mVelocityTracker = null;\n        }\n    }\n\n    /**\n     * {@link #cancel()}, but also abort all motion in progress and snap to the end of any\n     * animation.\n     */\n    public void abort() {\n        cancel();\n        if (mDragState == STATE_SETTLING) {\n            final int oldX = mScroller.getCurrX();\n            final int oldY = mScroller.getCurrY();\n            mScroller.abortAnimation();\n            final int newX = mScroller.getCurrX();\n            final int newY = mScroller.getCurrY();\n            mCallback.onViewPositionChanged(mCapturedView, newX, newY, newX - oldX, newY - oldY);\n        }\n        setDragState(STATE_IDLE);\n    }\n\n    /**\n     * Animate the view <code>child</code> to the given (left, top) position.\n     * If this method returns true, the caller should invoke {@link #continueSettling(boolean)}\n     * on each subsequent frame to continue the motion until it returns false. If this method\n     * returns false there is no further work to do to complete the movement.\n     * <p/>\n     * <p>This operation does not count as a capture event, though {@link #getCapturedView()}\n     * will still report the sliding view while the slide is in progress.</p>\n     *\n     * @param child     Child view to capture and animate\n     * @param finalLeft Final left position of child\n     * @param finalTop  Final top position of child\n     * @return true if animation should continue through {@link #continueSettling(boolean)} calls\n     */\n    public boolean smoothSlideViewTo(View child, int finalLeft, int finalTop) {\n        mCapturedView = child;\n        mActivePointerId = INVALID_POINTER;\n\n        return forceSettleCapturedViewAt(finalLeft, finalTop, 0, 0);\n    }\n\n    /**\n     * Settle the captured view at the given (left, top) position.\n     * The appropriate velocity from prior motion will be taken into account.\n     * If this method returns true, the caller should invoke {@link #continueSettling(boolean)}\n     * on each subsequent frame to continue the motion until it returns false. If this method\n     * returns false there is no further work to do to complete the movement.\n     *\n     * @param finalLeft Settled left edge position for the captured view\n     * @param finalTop  Settled top edge position for the captured view\n     * @return true if animation should continue through {@link #continueSettling(boolean)} calls\n     */\n    public boolean settleCapturedViewAt(int finalLeft, int finalTop) {\n        if (!mReleaseInProgress) {\n            throw new IllegalStateException("Cannot settleCapturedViewAt outside of a call to " +\n                    "Callback#onViewReleased");\n        }\n\n        return forceSettleCapturedViewAt(finalLeft, finalTop,\n                (int) VelocityTrackerCompat.getXVelocity(mVelocityTracker, mActivePointerId),\n                (int) VelocityTrackerCompat.getYVelocity(mVelocityTracker, mActivePointerId));\n    }\n\n    /**\n     * Settle the captured view at the given (left, top) position.\n     *\n     * @param finalLeft Target left position for the captured view\n     * @param finalTop  Target top position for the captured view\n     * @param xvel      Horizontal velocity\n     * @param yvel      Vertical velocity\n     * @return true if animation should continue through {@link #continueSettling(boolean)} calls\n     */\n    private boolean forceSettleCapturedViewAt(int finalLeft, int finalTop, int xvel, int yvel) {\n        final int startLeft = mCapturedView.getLeft();\n        final int startTop = mCapturedView.getTop();\n        final int dx = finalLeft - startLeft;\n        final int dy = finalTop - startTop;\n\n        if (dx == 0 && dy == 0) {\n            // Nothing to do. Send callbacks, be done.\n            mScroller.abortAnimation();\n            setDragState(STATE_IDLE);\n            return false;\n        }\n\n        final int duration = computeSettleDuration(mCapturedView, dx, dy, xvel, yvel);\n        mScroller.startScroll(startLeft, startTop, dx, dy, duration);\n\n        setDragState(STATE_SETTLING);\n        return true;\n    }\n\n    private int computeSettleDuration(View child, int dx, int dy, int xvel, int yvel) {\n        xvel = clampMag(xvel, (int) mMinVelocity, (int) mMaxVelocity);\n        yvel = clampMag(yvel, (int) mMinVelocity, (int) mMaxVelocity);\n        final int absDx = Math.abs(dx);\n        final int absDy = Math.abs(dy);\n        final int absXVel = Math.abs(xvel);\n        final int absYVel = Math.abs(yvel);\n        final int addedVel = absXVel + absYVel;\n        final int addedDistance = absDx + absDy;\n\n        final float xweight = xvel != 0 ? (float) absXVel / addedVel :\n                (float) absDx / addedDistance;\n        final float yweight = yvel != 0 ? (float) absYVel / addedVel :\n                (float) absDy / addedDistance;\n\n        int xduration = computeAxisDuration(dx, xvel, mCallback.getViewHorizontalDragRange(child));\n        int yduration = computeAxisDuration(dy, yvel, mCallback.getViewVerticalDragRange(child));\n\n        return (int) (xduration * xweight + yduration * yweight);\n    }\n\n    private int computeAxisDuration(int delta, int velocity, int motionRange) {\n        if (delta == 0) {\n            return 0;\n        }\n\n        final int width = mParentView.getWidth();\n        final int halfWidth = width / 2;\n        final float distanceRatio = Math.min(1f, (float) Math.abs(delta) / width);\n        final float distance = halfWidth + halfWidth *\n                distanceInfluenceForSnapDuration(distanceRatio);\n\n        int duration;\n        velocity = Math.abs(velocity);\n        if (velocity > 0) {\n            duration = 4 * Math.round(1000 * Math.abs(distance / velocity));\n        } else {\n            final float range = (float) Math.abs(delta) / motionRange;\n            duration = (int) ((range + 1) * BASE_SETTLE_DURATION);\n        }\n        return Math.min(duration, MAX_SETTLE_DURATION);\n    }\n\n    /**\n     * Clamp the magnitude of value for absMin and absMax.\n     * If the value is below the minimum, it will be clamped to zero.\n     * If the value is above the maximum, it will be clamped to the maximum.\n     *\n     * @param value  Value to clamp\n     * @param absMin Absolute value of the minimum significant value to return\n     * @param absMax Absolute value of the maximum value to return\n     * @return The clamped value with the same sign as <code>value</code>\n     */\n    private int clampMag(int value, int absMin, int absMax) {\n        final int absValue = Math.abs(value);\n        if (absValue < absMin) return 0;\n        if (absValue > absMax) return value > 0 ? absMax : -absMax;\n        return value;\n    }\n\n    /**\n     * Clamp the magnitude of value for absMin and absMax.\n     * If the value is below the minimum, it will be clamped to zero.\n     * If the value is above the maximum, it will be clamped to the maximum.\n     *\n     * @param value  Value to clamp\n     * @param absMin Absolute value of the minimum significant value to return\n     * @param absMax Absolute value of the maximum value to return\n     * @return The clamped value with the same sign as <code>value</code>\n     */\n    private float clampMag(float value, float absMin, float absMax) {\n        final float absValue = Math.abs(value);\n        if (absValue < absMin) return 0;\n        if (absValue > absMax) return value > 0 ? absMax : -absMax;\n        return value;\n    }\n\n    private float distanceInfluenceForSnapDuration(float f) {\n        f -= 0.5f; // center the values about 0.\n        f *= 0.3f * Math.PI / 2.0f;\n        return (float) Math.sin(f);\n    }\n\n    /**\n     * Settle the captured view based on standard free-moving fling behavior.\n     * The caller should invoke {@link #continueSettling(boolean)} on each subsequent frame\n     * to continue the motion until it returns false.\n     *\n     * @param minLeft Minimum X position for the view\'s left edge\n     * @param minTop  Minimum Y position for the view\'s top edge\n     * @param maxLeft Maximum X position for the view\'s left edge\n     * @param maxTop  Maximum Y position for the view\'s top edge\n     */\n    public void flingCapturedView(int minLeft, int minTop, int maxLeft, int maxTop) {\n        if (!mReleaseInProgress) {\n            throw new IllegalStateException("Cannot flingCapturedView outside of a call to " +\n                    "Callback#onViewReleased");\n        }\n\n        mScroller.fling(mCapturedView.getLeft(), mCapturedView.getTop(),\n                (int) VelocityTrackerCompat.getXVelocity(mVelocityTracker, mActivePointerId),\n                (int) VelocityTrackerCompat.getYVelocity(mVelocityTracker, mActivePointerId),\n                minLeft, maxLeft, minTop, maxTop);\n\n        setDragState(STATE_SETTLING);\n    }\n\n    /**\n     * Move the captured settling view by the appropriate amount for the current time.\n     * If <code>continueSettling</code> returns true, the caller should call it again\n     * on the next frame to continue.\n     *\n     * @param deferCallbacks true if state callbacks should be deferred via posted message.\n     *                       Set this to true if you are calling this method from\n     *                       {@link android.view.View#computeScroll()} or similar methods\n     *                       invoked as part of layout or drawing.\n     * @return true if settle is still in progress\n     */\n    public boolean continueSettling(boolean deferCallbacks) {\n        if (mDragState == STATE_SETTLING) {\n            boolean keepGoing = mScroller.computeScrollOffset();\n            final int x = mScroller.getCurrX();\n            final int y = mScroller.getCurrY();\n            final int dx = x - mCapturedView.getLeft();\n            final int dy = y - mCapturedView.getTop();\n\n            if (dx != 0) {\n                mCapturedView.offsetLeftAndRight(dx);\n            }\n            if (dy != 0) {\n                mCapturedView.offsetTopAndBottom(dy);\n            }\n\n            if (dx != 0 || dy != 0) {\n                mCallback.onViewPositionChanged(mCapturedView, x, y, dx, dy);\n            }\n\n            if (keepGoing && x == mScroller.getFinalX() && y == mScroller.getFinalY()) {\n                // Close enough. The interpolator/scroller might think we\'re still moving\n                // but the user sure doesn\'t.\n                mScroller.abortAnimation();\n                keepGoing = mScroller.isFinished();\n            }\n\n            if (!keepGoing) {\n                if (deferCallbacks) {\n                    mParentView.post(mSetIdleRunnable);\n                } else {\n                    setDragState(STATE_IDLE);\n                }\n            }\n        }\n\n        return mDragState == STATE_SETTLING;\n    }\n\n    /**\n     * Like all callback events this must happen on the UI thread, but release\n     * involves some extra semantics. During a release (mReleaseInProgress)\n     * is the only time it is valid to call {@link #settleCapturedViewAt(int, int)}\n     * or {@link #flingCapturedView(int, int, int, int)}.\n     */\n    private void dispatchViewReleased(float xvel, float yvel) {\n        mReleaseInProgress = true;\n        mCallback.onViewReleased(mCapturedView, xvel, yvel);\n        mReleaseInProgress = false;\n\n        if (mDragState == STATE_DRAGGING) {\n            // onViewReleased didn\'t call a method that would have changed this. Go idle.\n            setDragState(STATE_IDLE);\n        }\n    }\n\n    private void clearMotionHistory() {\n        if (mInitialMotionX == null) {\n            return;\n        }\n        Arrays.fill(mInitialMotionX, 0);\n        Arrays.fill(mInitialMotionY, 0);\n        Arrays.fill(mLastMotionX, 0);\n        Arrays.fill(mLastMotionY, 0);\n        Arrays.fill(mInitialEdgesTouched, 0);\n        Arrays.fill(mEdgeDragsInProgress, 0);\n        Arrays.fill(mEdgeDragsLocked, 0);\n        mPointersDown = 0;\n    }\n\n    private void clearMotionHistory(int pointerId) {\n        if (mInitialMotionX == null) {\n            return;\n        }\n        mInitialMotionX[pointerId] = 0;\n        mInitialMotionY[pointerId] = 0;\n        mLastMotionX[pointerId] = 0;\n        mLastMotionY[pointerId] = 0;\n        mInitialEdgesTouched[pointerId] = 0;\n        mEdgeDragsInProgress[pointerId] = 0;\n        mEdgeDragsLocked[pointerId] = 0;\n        mPointersDown &= ~(1 << pointerId);\n    }\n\n    private void ensureMotionHistorySizeForId(int pointerId) {\n        if (mInitialMotionX == null || mInitialMotionX.length <= pointerId) {\n            float[] imx = new float[pointerId + 1];\n            float[] imy = new float[pointerId + 1];\n            float[] lmx = new float[pointerId + 1];\n            float[] lmy = new float[pointerId + 1];\n            int[] iit = new int[pointerId + 1];\n            int[] edip = new int[pointerId + 1];\n            int[] edl = new int[pointerId + 1];\n\n            if (mInitialMotionX != null) {\n                System.arraycopy(mInitialMotionX, 0, imx, 0, mInitialMotionX.length);\n                System.arraycopy(mInitialMotionY, 0, imy, 0, mInitialMotionY.length);\n                System.arraycopy(mLastMotionX, 0, lmx, 0, mLastMotionX.length);\n                System.arraycopy(mLastMotionY, 0, lmy, 0, mLastMotionY.length);\n                System.arraycopy(mInitialEdgesTouched, 0, iit, 0, mInitialEdgesTouched.length);\n                System.arraycopy(mEdgeDragsInProgress, 0, edip, 0, mEdgeDragsInProgress.length);\n                System.arraycopy(mEdgeDragsLocked, 0, edl, 0, mEdgeDragsLocked.length);\n            }\n\n            mInitialMotionX = imx;\n            mInitialMotionY = imy;\n            mLastMotionX = lmx;\n            mLastMotionY = lmy;\n            mInitialEdgesTouched = iit;\n            mEdgeDragsInProgress = edip;\n            mEdgeDragsLocked = edl;\n        }\n    }\n\n    private void saveInitialMotion(float x, float y, int pointerId) {\n        ensureMotionHistorySizeForId(pointerId);\n        mInitialMotionX[pointerId] = mLastMotionX[pointerId] = x;\n        mInitialMotionY[pointerId] = mLastMotionY[pointerId] = y;\n        mInitialEdgesTouched[pointerId] = getEdgesTouched((int) x, (int) y);\n        mPointersDown |= 1 << pointerId;\n    }\n\n    private void saveLastMotion(MotionEvent ev) {\n        final int pointerCount = MotionEventCompat.getPointerCount(ev);\n        for (int i = 0; i < pointerCount; i++) {\n            final int pointerId = MotionEventCompat.getPointerId(ev, i);\n            final float x = MotionEventCompat.getX(ev, i);\n            final float y = MotionEventCompat.getY(ev, i);\n            mLastMotionX[pointerId] = x;\n            mLastMotionY[pointerId] = y;\n        }\n    }\n\n    /**\n     * Check if the given pointer ID represents a pointer that is currently down (to the best\n     * of the ViewDragHelper\'s knowledge).\n     * <p/>\n     * <p>The state used to report this information is populated by the methods\n     * {@link #shouldInterceptTouchEvent(android.view.MotionEvent)} or\n     * {@link #processTouchEvent(android.view.MotionEvent)}. If one of these methods has not\n     * been called for all relevant MotionEvents to track, the information reported\n     * by this method may be stale or incorrect.</p>\n     *\n     * @param pointerId pointer ID to check; corresponds to IDs provided by MotionEvent\n     * @return true if the pointer with the given ID is still down\n     */\n    public boolean isPointerDown(int pointerId) {\n        return (mPointersDown & 1 << pointerId) != 0;\n    }\n\n    void setDragState(int state) {\n        if (mDragState != state) {\n            mDragState = state;\n            mCallback.onViewDragStateChanged(state);\n            if (state == STATE_IDLE) {\n                mCapturedView = null;\n            }\n        }\n    }\n\n    /**\n     * Attempt to capture the view with the given pointer ID. The callback will be involved.\n     * This will put us into the "dragging" state. If we\'ve already captured this view with\n     * this pointer this method will immediately return true without consulting the callback.\n     *\n     * @param toCapture View to capture\n     * @param pointerId Pointer to capture with\n     * @return true if capture was successful\n     */\n    boolean tryCaptureViewForDrag(View toCapture, int pointerId) {\n        if (toCapture == mCapturedView && mActivePointerId == pointerId) {\n            // Already done!\n            return true;\n        }\n        if (toCapture != null && mCallback.tryCaptureView(toCapture, pointerId)) {\n            mActivePointerId = pointerId;\n            captureChildView(toCapture, pointerId);\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * Tests scrollability within child views of v given a delta of dx.\n     *\n     * @param v      View to test for horizontal scrollability\n     * @param checkV Whether the view v passed should itself be checked for scrollability (true),\n     *               or just its children (false).\n     * @param dx     Delta scrolled in pixels along the X axis\n     * @param dy     Delta scrolled in pixels along the Y axis\n     * @param x      X coordinate of the active touch point\n     * @param y      Y coordinate of the active touch point\n     * @return true if child views of v can be scrolled by delta of dx.\n     */\n    protected boolean canScroll(View v, boolean checkV, int dx, int dy, int x, int y) {\n        if (v instanceof ViewGroup) {\n            final ViewGroup group = (ViewGroup) v;\n            final int scrollX = v.getScrollX();\n            final int scrollY = v.getScrollY();\n            final int count = group.getChildCount();\n            // Count backwards - let topmost views consume scroll distance first.\n            for (int i = count - 1; i >= 0; i--) {\n                // TODO: Add versioned support here for transformed views.\n                // This will not work for transformed views in Honeycomb+\n                final View child = group.getChildAt(i);\n                if (x + scrollX >= child.getLeft() && x + scrollX < child.getRight() &&\n                        y + scrollY >= child.getTop() && y + scrollY < child.getBottom() &&\n                        canScroll(child, true, dx, dy, x + scrollX - child.getLeft(),\n                                y + scrollY - child.getTop())) {\n                    return true;\n                }\n            }\n        }\n\n        return checkV && (ViewCompat.canScrollHorizontally(v, -dx) ||\n                ViewCompat.canScrollVertically(v, -dy));\n    }\n\n    /**\n     * Check if this event as provided to the parent view\'s onInterceptTouchEvent should\n     * cause the parent to intercept the touch event stream.\n     *\n     * @param ev MotionEvent provided to onInterceptTouchEvent\n     * @return true if the parent view should return true from onInterceptTouchEvent\n     */\n    public boolean shouldInterceptTouchEvent(MotionEvent ev) {\n        final int action = MotionEventCompat.getActionMasked(ev);\n        final int actionIndex = MotionEventCompat.getActionIndex(ev);\n\n        if (action == MotionEvent.ACTION_DOWN) {\n            // Reset things for a new event stream, just in case we didn\'t get\n            // the whole previous stream.\n            cancel();\n        }\n\n        if (mVelocityTracker == null) {\n            mVelocityTracker = VelocityTracker.obtain();\n        }\n        mVelocityTracker.addMovement(ev);\n\n        switch (action) {\n            case MotionEvent.ACTION_DOWN: {\n                final float x = ev.getX();\n                final float y = ev.getY();\n                final int pointerId = MotionEventCompat.getPointerId(ev, 0);\n                saveInitialMotion(x, y, pointerId);\n\n                final View toCapture = findTopChildUnder((int) x, (int) y);\n\n                // Catch a settling view if possible.\n                if (toCapture == mCapturedView && mDragState == STATE_SETTLING) {\n                    tryCaptureViewForDrag(toCapture, pointerId);\n                }\n\n                final int edgesTouched = mInitialEdgesTouched[pointerId];\n                if ((edgesTouched & mTrackingEdges) != 0) {\n                    mCallback.onEdgeTouched(edgesTouched & mTrackingEdges, pointerId);\n                }\n                break;\n            }\n\n            case MotionEventCompat.ACTION_POINTER_DOWN: {\n                final int pointerId = MotionEventCompat.getPointerId(ev, actionIndex);\n                final float x = MotionEventCompat.getX(ev, actionIndex);\n                final float y = MotionEventCompat.getY(ev, actionIndex);\n\n                saveInitialMotion(x, y, pointerId);\n\n                // A ViewDragHelper can only manipulate one view at a time.\n                if (mDragState == STATE_IDLE) {\n                    final int edgesTouched = mInitialEdgesTouched[pointerId];\n                    if ((edgesTouched & mTrackingEdges) != 0) {\n                        mCallback.onEdgeTouched(edgesTouched & mTrackingEdges, pointerId);\n                    }\n                } else if (mDragState == STATE_SETTLING) {\n                    // Catch a settling view if possible.\n                    final View toCapture = findTopChildUnder((int) x, (int) y);\n                    if (toCapture == mCapturedView) {\n                        tryCaptureViewForDrag(toCapture, pointerId);\n                    }\n                }\n                break;\n            }\n\n            case MotionEvent.ACTION_MOVE: {\n                // First to cross a touch slop over a draggable view wins. Also report edge drags.\n                final int pointerCount = MotionEventCompat.getPointerCount(ev);\n                for (int i = 0; i < pointerCount && mInitialMotionX != null && mInitialMotionY != null; i++) {\n                    final int pointerId = MotionEventCompat.getPointerId(ev, i);\n                    final float x = MotionEventCompat.getX(ev, i);\n                    final float y = MotionEventCompat.getY(ev, i);\n                    final float dx = x - mInitialMotionX[pointerId];\n                    final float dy = y - mInitialMotionY[pointerId];\n\n                    reportNewEdgeDrags(dx, dy, pointerId);\n                    if (mDragState == STATE_DRAGGING) {\n                        // Callback might have started an edge drag\n                        break;\n                    }\n\n                    final View toCapture = findTopChildUnder((int) mInitialMotionX[pointerId], (int) mInitialMotionY[pointerId]);\n                    if (toCapture != null && checkTouchSlop(toCapture, dx, dy) &&\n                            tryCaptureViewForDrag(toCapture, pointerId)) {\n                        break;\n                    }\n                }\n                saveLastMotion(ev);\n                break;\n            }\n\n            case MotionEventCompat.ACTION_POINTER_UP: {\n                final int pointerId = MotionEventCompat.getPointerId(ev, actionIndex);\n                clearMotionHistory(pointerId);\n                break;\n            }\n\n            case MotionEvent.ACTION_UP:\n            case MotionEvent.ACTION_CANCEL: {\n                cancel();\n                break;\n            }\n        }\n\n        return mDragState == STATE_DRAGGING;\n    }\n\n    /**\n     * Process a touch event received by the parent view. This method will dispatch callback events\n     * as needed before returning. The parent view\'s onTouchEvent implementation should call this.\n     *\n     * @param ev The touch event received by the parent view\n     */\n    public void processTouchEvent(MotionEvent ev) {\n        final int action = MotionEventCompat.getActionMasked(ev);\n        final int actionIndex = MotionEventCompat.getActionIndex(ev);\n\n        if (action == MotionEvent.ACTION_DOWN) {\n            // Reset things for a new event stream, just in case we didn\'t get\n            // the whole previous stream.\n            cancel();\n        }\n\n        if (mVelocityTracker == null) {\n            mVelocityTracker = VelocityTracker.obtain();\n        }\n        mVelocityTracker.addMovement(ev);\n\n        switch (action) {\n            case MotionEvent.ACTION_DOWN: {\n                final float x = ev.getX();\n                final float y = ev.getY();\n                final int pointerId = MotionEventCompat.getPointerId(ev, 0);\n                final View toCapture = findTopChildUnder((int) x, (int) y);\n\n                saveInitialMotion(x, y, pointerId);\n\n                // Since the parent is already directly processing this touch event,\n                // there is no reason to delay for a slop before dragging.\n                // Start immediately if possible.\n                tryCaptureViewForDrag(toCapture, pointerId);\n\n                final int edgesTouched = mInitialEdgesTouched[pointerId];\n                if ((edgesTouched & mTrackingEdges) != 0) {\n                    mCallback.onEdgeTouched(edgesTouched & mTrackingEdges, pointerId);\n                }\n                break;\n            }\n\n            case MotionEventCompat.ACTION_POINTER_DOWN: {\n                final int pointerId = MotionEventCompat.getPointerId(ev, actionIndex);\n                final float x = MotionEventCompat.getX(ev, actionIndex);\n                final float y = MotionEventCompat.getY(ev, actionIndex);\n\n                saveInitialMotion(x, y, pointerId);\n\n                // A ViewDragHelper can only manipulate one view at a time.\n                if (mDragState == STATE_IDLE) {\n                    // If we\'re idle we can do anything! Treat it like a normal down event.\n\n                    final View toCapture = findTopChildUnder((int) x, (int) y);\n                    tryCaptureViewForDrag(toCapture, pointerId);\n\n                    final int edgesTouched = mInitialEdgesTouched[pointerId];\n                    if ((edgesTouched & mTrackingEdges) != 0) {\n                        mCallback.onEdgeTouched(edgesTouched & mTrackingEdges, pointerId);\n                    }\n                } else if (isCapturedViewUnder((int) x, (int) y)) {\n                    // We\'re still tracking a captured view. If the same view is under this\n                    // point, we\'ll swap to controlling it with this pointer instead.\n                    // (This will still work if we\'re "catching" a settling view.)\n\n                    tryCaptureViewForDrag(mCapturedView, pointerId);\n                }\n                break;\n            }\n\n            case MotionEvent.ACTION_MOVE: {\n                if (mDragState == STATE_DRAGGING) {\n                    final int index = MotionEventCompat.findPointerIndex(ev, mActivePointerId);\n                    final float x = MotionEventCompat.getX(ev, index);\n                    final float y = MotionEventCompat.getY(ev, index);\n                    final int idx = (int) (x - mLastMotionX[mActivePointerId]);\n                    final int idy = (int) (y - mLastMotionY[mActivePointerId]);\n\n                    dragTo(mCapturedView.getLeft() + idx, mCapturedView.getTop() + idy, idx, idy);\n\n                    saveLastMotion(ev);\n                } else {\n                    // Check to see if any pointer is now over a draggable view.\n                    final int pointerCount = MotionEventCompat.getPointerCount(ev);\n                    for (int i = 0; i < pointerCount; i++) {\n                        final int pointerId = MotionEventCompat.getPointerId(ev, i);\n                        final float x = MotionEventCompat.getX(ev, i);\n                        final float y = MotionEventCompat.getY(ev, i);\n                        final float dx = x - mInitialMotionX[pointerId];\n                        final float dy = y - mInitialMotionY[pointerId];\n\n                        reportNewEdgeDrags(dx, dy, pointerId);\n                        if (mDragState == STATE_DRAGGING) {\n                            // Callback might have started an edge drag.\n                            break;\n                        }\n\n                        final View toCapture = findTopChildUnder((int) x, (int) y);\n                        if (checkTouchSlop(toCapture, dx, dy) &&\n                                tryCaptureViewForDrag(toCapture, pointerId)) {\n                            break;\n                        }\n                    }\n                    saveLastMotion(ev);\n                }\n                break;\n            }\n\n            case MotionEventCompat.ACTION_POINTER_UP: {\n                final int pointerId = MotionEventCompat.getPointerId(ev, actionIndex);\n                if (mDragState == STATE_DRAGGING && pointerId == mActivePointerId) {\n                    // Try to find another pointer that\'s still holding on to the captured view.\n                    int newActivePointer = INVALID_POINTER;\n                    final int pointerCount = MotionEventCompat.getPointerCount(ev);\n                    for (int i = 0; i < pointerCount; i++) {\n                        final int id = MotionEventCompat.getPointerId(ev, i);\n                        if (id == mActivePointerId) {\n                            // This one\'s going away, skip.\n                            continue;\n                        }\n\n                        final float x = MotionEventCompat.getX(ev, i);\n                        final float y = MotionEventCompat.getY(ev, i);\n                        if (findTopChildUnder((int) x, (int) y) == mCapturedView &&\n                                tryCaptureViewForDrag(mCapturedView, id)) {\n                            newActivePointer = mActivePointerId;\n                            break;\n                        }\n                    }\n\n                    if (newActivePointer == INVALID_POINTER) {\n                        // We didn\'t find another pointer still touching the view, release it.\n                        releaseViewForPointerUp();\n                    }\n                }\n                clearMotionHistory(pointerId);\n                break;\n            }\n\n            case MotionEvent.ACTION_UP: {\n                if (mDragState == STATE_DRAGGING) {\n                    releaseViewForPointerUp();\n                }\n                cancel();\n                break;\n            }\n\n            case MotionEvent.ACTION_CANCEL: {\n                if (mDragState == STATE_DRAGGING) {\n                    dispatchViewReleased(0, 0);\n                }\n                cancel();\n                break;\n            }\n        }\n    }\n\n    private void reportNewEdgeDrags(float dx, float dy, int pointerId) {\n        int dragsStarted = 0;\n        if (checkNewEdgeDrag(dx, dy, pointerId, EDGE_LEFT)) {\n            dragsStarted |= EDGE_LEFT;\n        }\n        if (checkNewEdgeDrag(dy, dx, pointerId, EDGE_TOP)) {\n            dragsStarted |= EDGE_TOP;\n        }\n        if (checkNewEdgeDrag(dx, dy, pointerId, EDGE_RIGHT)) {\n            dragsStarted |= EDGE_RIGHT;\n        }\n        if (checkNewEdgeDrag(dy, dx, pointerId, EDGE_BOTTOM)) {\n            dragsStarted |= EDGE_BOTTOM;\n        }\n\n        if (dragsStarted != 0) {\n            mEdgeDragsInProgress[pointerId] |= dragsStarted;\n            mCallback.onEdgeDragStarted(dragsStarted, pointerId);\n        }\n    }\n\n    private boolean checkNewEdgeDrag(float delta, float odelta, int pointerId, int edge) {\n        final float absDelta = Math.abs(delta);\n        final float absODelta = Math.abs(odelta);\n\n        if ((mInitialEdgesTouched[pointerId] & edge) != edge || (mTrackingEdges & edge) == 0 ||\n                (mEdgeDragsLocked[pointerId] & edge) == edge ||\n                (mEdgeDragsInProgress[pointerId] & edge) == edge ||\n                (absDelta <= mTouchSlop && absODelta <= mTouchSlop)) {\n            return false;\n        }\n        if (absDelta < absODelta * 0.5f && mCallback.onEdgeLock(edge)) {\n            mEdgeDragsLocked[pointerId] |= edge;\n            return false;\n        }\n        return (mEdgeDragsInProgress[pointerId] & edge) == 0 && absDelta > mTouchSlop;\n    }\n\n    /**\n     * Check if we\'ve crossed a reasonable touch slop for the given child view.\n     * If the child cannot be dragged along the horizontal or vertical axis, motion\n     * along that axis will not count toward the slop check.\n     *\n     * @param child Child to check\n     * @param dx    Motion since initial position along X axis\n     * @param dy    Motion since initial position along Y axis\n     * @return true if the touch slop has been crossed\n     */\n    private boolean checkTouchSlop(View child, float dx, float dy) {\n        if (child == null) {\n            return false;\n        }\n        final boolean checkHorizontal = mCallback.getViewHorizontalDragRange(child) > 0;\n        final boolean checkVertical = mCallback.getViewVerticalDragRange(child) > 0;\n\n        if (checkHorizontal && checkVertical) {\n            return dx * dx + dy * dy > mTouchSlop * mTouchSlop;\n        } else if (checkHorizontal) {\n            return Math.abs(dx) > mTouchSlop;\n        } else if (checkVertical) {\n            return Math.abs(dy) > mTouchSlop;\n        }\n        return false;\n    }\n\n    /**\n     * Check if any pointer tracked in the current gesture has crossed\n     * the required slop threshold.\n     * <p/>\n     * <p>This depends on internal state populated by\n     * {@link #shouldInterceptTouchEvent(android.view.MotionEvent)} or\n     * {@link #processTouchEvent(android.view.MotionEvent)}. You should only rely on\n     * the results of this method after all currently available touch data\n     * has been provided to one of these two methods.</p>\n     *\n     * @param directions Combination of direction flags, see {@link #DIRECTION_HORIZONTAL},\n     *                   {@link #DIRECTION_VERTICAL}, {@link #DIRECTION_ALL}\n     * @return true if the slop threshold has been crossed, false otherwise\n     */\n    public boolean checkTouchSlop(int directions) {\n        final int count = mInitialMotionX.length;\n        for (int i = 0; i < count; i++) {\n            if (checkTouchSlop(directions, i)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Check if the specified pointer tracked in the current gesture has crossed\n     * the required slop threshold.\n     * <p/>\n     * <p>This depends on internal state populated by\n     * {@link #shouldInterceptTouchEvent(android.view.MotionEvent)} or\n     * {@link #processTouchEvent(android.view.MotionEvent)}. You should only rely on\n     * the results of this method after all currently available touch data\n     * has been provided to one of these two methods.</p>\n     *\n     * @param directions Combination of direction flags, see {@link #DIRECTION_HORIZONTAL},\n     *                   {@link #DIRECTION_VERTICAL}, {@link #DIRECTION_ALL}\n     * @param pointerId  ID of the pointer to slop check as specified by MotionEvent\n     * @return true if the slop threshold has been crossed, false otherwise\n     */\n    public boolean checkTouchSlop(int directions, int pointerId) {\n        if (!isPointerDown(pointerId)) {\n            return false;\n        }\n\n        final boolean checkHorizontal = (directions & DIRECTION_HORIZONTAL) == DIRECTION_HORIZONTAL;\n        final boolean checkVertical = (directions & DIRECTION_VERTICAL) == DIRECTION_VERTICAL;\n\n        final float dx = mLastMotionX[pointerId] - mInitialMotionX[pointerId];\n        final float dy = mLastMotionY[pointerId] - mInitialMotionY[pointerId];\n\n        if (checkHorizontal && checkVertical) {\n            return dx * dx + dy * dy > mTouchSlop * mTouchSlop;\n        } else if (checkHorizontal) {\n            return Math.abs(dx) > mTouchSlop;\n        } else if (checkVertical) {\n            return Math.abs(dy) > mTouchSlop;\n        }\n        return false;\n    }\n\n    /**\n     * Check if any of the edges specified were initially touched in the currently active gesture.\n     * If there is no currently active gesture this method will return false.\n     *\n     * @param edges Edges to check for an initial edge touch. See {@link #EDGE_LEFT},\n     *              {@link #EDGE_TOP}, {@link #EDGE_RIGHT}, {@link #EDGE_BOTTOM} and\n     *              {@link #EDGE_ALL}\n     * @return true if any of the edges specified were initially touched in the current gesture\n     */\n    public boolean isEdgeTouched(int edges) {\n        final int count = mInitialEdgesTouched.length;\n        for (int i = 0; i < count; i++) {\n            if (isEdgeTouched(edges, i)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Check if any of the edges specified were initially touched by the pointer with\n     * the specified ID. If there is no currently active gesture or if there is no pointer with\n     * the given ID currently down this method will return false.\n     *\n     * @param edges Edges to check for an initial edge touch. See {@link #EDGE_LEFT},\n     *              {@link #EDGE_TOP}, {@link #EDGE_RIGHT}, {@link #EDGE_BOTTOM} and\n     *              {@link #EDGE_ALL}\n     * @return true if any of the edges specified were initially touched in the current gesture\n     */\n    public boolean isEdgeTouched(int edges, int pointerId) {\n        return isPointerDown(pointerId) && (mInitialEdgesTouched[pointerId] & edges) != 0;\n    }\n\n    private void releaseViewForPointerUp() {\n        mVelocityTracker.computeCurrentVelocity(1000, mMaxVelocity);\n        final float xvel = clampMag(\n                VelocityTrackerCompat.getXVelocity(mVelocityTracker, mActivePointerId),\n                mMinVelocity, mMaxVelocity);\n        final float yvel = clampMag(\n                VelocityTrackerCompat.getYVelocity(mVelocityTracker, mActivePointerId),\n                mMinVelocity, mMaxVelocity);\n        dispatchViewReleased(xvel, yvel);\n    }\n\n    private void dragTo(int left, int top, int dx, int dy) {\n        int clampedX = left;\n        int clampedY = top;\n        final int oldLeft = mCapturedView.getLeft();\n        final int oldTop = mCapturedView.getTop();\n        if (dx != 0) {\n            clampedX = mCallback.clampViewPositionHorizontal(mCapturedView, left, dx);\n            mCapturedView.offsetLeftAndRight(clampedX - oldLeft);\n        }\n        if (dy != 0) {\n            clampedY = mCallback.clampViewPositionVertical(mCapturedView, top, dy);\n            mCapturedView.offsetTopAndBottom(clampedY - oldTop);\n        }\n\n        if (dx != 0 || dy != 0) {\n            final int clampedDx = clampedX - oldLeft;\n            final int clampedDy = clampedY - oldTop;\n            mCallback.onViewPositionChanged(mCapturedView, clampedX, clampedY,\n                    clampedDx, clampedDy);\n        }\n    }\n\n    /**\n     * Determine if the currently captured view is under the given point in the\n     * parent view\'s coordinate system. If there is no captured view this method\n     * will return false.\n     *\n     * @param x X position to test in the parent\'s coordinate system\n     * @param y Y position to test in the parent\'s coordinate system\n     * @return true if the captured view is under the given point, false otherwise\n     */\n    public boolean isCapturedViewUnder(int x, int y) {\n        return isViewUnder(mCapturedView, x, y);\n    }\n\n    /**\n     * Determine if the supplied view is under the given point in the\n     * parent view\'s coordinate system.\n     *\n     * @param view Child view of the parent to hit test\n     * @param x    X position to test in the parent\'s coordinate system\n     * @param y    Y position to test in the parent\'s coordinate system\n     * @return true if the supplied view is under the given point, false otherwise\n     */\n    public boolean isViewUnder(View view, int x, int y) {\n        if (view == null) {\n            return false;\n        }\n        return x >= view.getLeft() &&\n                x < view.getRight() &&\n                y >= view.getTop() &&\n                y < view.getBottom();\n    }\n\n    /**\n     * Find the topmost child under the given point within the parent view\'s coordinate system.\n     * The child order is determined using {@link Callback#getOrderedChildIndex(int)}.\n     *\n     * @param x X position to test in the parent\'s coordinate system\n     * @param y Y position to test in the parent\'s coordinate system\n     * @return The topmost child view under (x, y) or null if none found.\n     */\n    public View findTopChildUnder(int x, int y) {\n        final int childCount = mParentView.getChildCount();\n        for (int i = childCount - 1; i >= 0; i--) {\n            final View child = mParentView.getChildAt(mCallback.getOrderedChildIndex(i));\n            if (x >= child.getLeft() && x < child.getRight() &&\n                    y >= child.getTop() && y < child.getBottom()) {\n                return child;\n            }\n        }\n        return null;\n    }\n\n    private int getEdgesTouched(int x, int y) {\n        int result = 0;\n\n        if (x < mParentView.getLeft() + mEdgeSize) result |= EDGE_LEFT;\n        if (y < mParentView.getTop() + mEdgeSize) result |= EDGE_TOP;\n        if (x > mParentView.getRight() - mEdgeSize) result |= EDGE_RIGHT;\n        if (y > mParentView.getBottom() - mEdgeSize) result |= EDGE_BOTTOM;\n\n        return result;\n    }\n\n    /**\n     * A Callback is used as a communication channel with the ViewDragHelper back to the\n     * parent view using it. <code>on*</code>methods are invoked on siginficant events and several\n     * accessor methods are expected to provide the ViewDragHelper with more information\n     * about the state of the parent view upon request. The callback also makes decisions\n     * governing the range and draggability of child views.\n     */\n    public static abstract class Callback {\n        /**\n         * Called when the drag state changes. See the <code>STATE_*</code> constants\n         * for more information.\n         *\n         * @param state The new drag state\n         * @see #STATE_IDLE\n         * @see #STATE_DRAGGING\n         * @see #STATE_SETTLING\n         */\n        public void onViewDragStateChanged(int state) {\n        }\n\n        /**\n         * Called when the captured view\'s position changes as the result of a drag or settle.\n         *\n         * @param changedView View whose position changed\n         * @param left        New X coordinate of the left edge of the view\n         * @param top         New Y coordinate of the top edge of the view\n         * @param dx          Change in X position from the last call\n         * @param dy          Change in Y position from the last call\n         */\n        public void onViewPositionChanged(View changedView, int left, int top, int dx, int dy) {\n        }\n\n        /**\n         * Called when a child view is captured for dragging or settling. The ID of the pointer\n         * currently dragging the captured view is supplied. If activePointerId is\n         * identified as {@link #INVALID_POINTER} the capture is programmatic instead of\n         * pointer-initiated.\n         *\n         * @param capturedChild   Child view that was captured\n         * @param activePointerId Pointer id tracking the child capture\n         */\n        public void onViewCaptured(View capturedChild, int activePointerId) {\n        }\n\n        /**\n         * Called when the child view is no longer being actively dragged.\n         * The fling velocity is also supplied, if relevant. The velocity values may\n         * be clamped to system minimums or maximums.\n         * <p/>\n         * <p>Calling code may decide to fling or otherwise release the view to let it\n         * settle into place. It should do so using {@link #settleCapturedViewAt(int, int)}\n         * or {@link #flingCapturedView(int, int, int, int)}. If the Callback invokes\n         * one of these methods, the ViewDragHelper will enter {@link #STATE_SETTLING}\n         * and the view capture will not fully end until it comes to a complete stop.\n         * If neither of these methods is invoked before <code>onViewReleased</code> returns,\n         * the view will stop in place and the ViewDragHelper will return to\n         * {@link #STATE_IDLE}.</p>\n         *\n         * @param releasedChild The captured child view now being released\n         * @param xvel          X velocity of the pointer as it left the screen in pixels per second.\n         * @param yvel          Y velocity of the pointer as it left the screen in pixels per second.\n         */\n        public void onViewReleased(View releasedChild, float xvel, float yvel) {\n        }\n\n        /**\n         * Called when one of the subscribed edges in the parent view has been touched\n         * by the user while no child view is currently captured.\n         *\n         * @param edgeFlags A combination of edge flags describing the edge(s) currently touched\n         * @param pointerId ID of the pointer touching the described edge(s)\n         * @see #EDGE_LEFT\n         * @see #EDGE_TOP\n         * @see #EDGE_RIGHT\n         * @see #EDGE_BOTTOM\n         */\n        public void onEdgeTouched(int edgeFlags, int pointerId) {\n        }\n\n        /**\n         * Called when the given edge may become locked. This can happen if an edge drag\n         * was preliminarily rejected before beginning, but after {@link #onEdgeTouched(int, int)}\n         * was called. This method should return true to lock this edge or false to leave it\n         * unlocked. The default behavior is to leave edges unlocked.\n         *\n         * @param edgeFlags A combination of edge flags describing the edge(s) locked\n         * @return true to lock the edge, false to leave it unlocked\n         */\n        public boolean onEdgeLock(int edgeFlags) {\n            return false;\n        }\n\n        /**\n         * Called when the user has started a deliberate drag away from one\n         * of the subscribed edges in the parent view while no child view is currently captured.\n         *\n         * @param edgeFlags A combination of edge flags describing the edge(s) dragged\n         * @param pointerId ID of the pointer touching the described edge(s)\n         * @see #EDGE_LEFT\n         * @see #EDGE_TOP\n         * @see #EDGE_RIGHT\n         * @see #EDGE_BOTTOM\n         */\n        public void onEdgeDragStarted(int edgeFlags, int pointerId) {\n        }\n\n        /**\n         * Called to determine the Z-order of child views.\n         *\n         * @param index the ordered position to query for\n         * @return index of the view that should be ordered at position <code>index</code>\n         */\n        public int getOrderedChildIndex(int index) {\n            return index;\n        }\n\n        /**\n         * Return the magnitude of a draggable child view\'s horizontal range of motion in pixels.\n         * This method should return 0 for views that cannot move horizontally.\n         *\n         * @param child Child view to check\n         * @return range of horizontal motion in pixels\n         */\n        public int getViewHorizontalDragRange(View child) {\n            return 0;\n        }\n\n        /**\n         * Return the magnitude of a draggable child view\'s vertical range of motion in pixels.\n         * This method should return 0 for views that cannot move vertically.\n         *\n         * @param child Child view to check\n         * @return range of vertical motion in pixels\n         */\n        public int getViewVerticalDragRange(View child) {\n            return 0;\n        }\n\n        /**\n         * Called when the user\'s input indicates that they want to capture the given child view\n         * with the pointer indicated by pointerId. The callback should return true if the user\n         * is permitted to drag the given view with the indicated pointer.\n         * <p/>\n         * <p>ViewDragHelper may call this method multiple times for the same view even if\n         * the view is already captured; this indicates that a new pointer is trying to take\n         * control of the view.</p>\n         * <p/>\n         * <p>If this method returns true, a call to {@link #onViewCaptured(android.view.View, int)}\n         * will follow if the capture is successful.</p>\n         *\n         * @param child     Child the user is attempting to capture\n         * @param pointerId ID of the pointer attempting the capture\n         * @return true if capture should be allowed, false otherwise\n         */\n        public abstract boolean tryCaptureView(View child, int pointerId);\n\n        /**\n         * Restrict the motion of the dragged child view along the horizontal axis.\n         * The default implementation does not allow horizontal motion; the extending\n         * class must override this method and provide the desired clamping.\n         *\n         * @param child Child view being dragged\n         * @param left  Attempted motion along the X axis\n         * @param dx    Proposed change in position for left\n         * @return The new clamped position for left\n         */\n        public int clampViewPositionHorizontal(View child, int left, int dx) {\n            return 0;\n        }\n\n        /**\n         * Restrict the motion of the dragged child view along the vertical axis.\n         * The default implementation does not allow vertical motion; the extending\n         * class must override this method and provide the desired clamping.\n         *\n         * @param child Child view being dragged\n         * @param top   Attempted motion along the Y axis\n         * @param dy    Proposed change in position for top\n         * @return The new clamped position for top\n         */\n        public int clampViewPositionVertical(View child, int top, int dy) {\n            return 0;\n        }\n    }\n}'