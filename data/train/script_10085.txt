b'{-# LANGUAGE DataKinds #-}\n{-# LANGUAGE QuasiQuotes #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n{-# LANGUAGE TypeOperators #-}\n\nmodule Cachix.Client.Commands\n  ( authtoken,\n    generateKeypair,\n    push,\n    watchStore,\n    watchExec,\n    use,\n    pin,\n  )\nwhere\n\nimport qualified Cachix.API as API\nimport Cachix.API.Error\nimport Cachix.Client.CNix (filterInvalidStorePath)\nimport qualified Cachix.Client.Config as Config\nimport Cachix.Client.Env (Env (..))\nimport Cachix.Client.Exception (CachixException (..))\nimport Cachix.Client.HumanSize (humanSize)\nimport qualified Cachix.Client.InstallationMode as InstallationMode\nimport qualified Cachix.Client.NixConf as NixConf\nimport Cachix.Client.NixVersion (assertNixVersion)\nimport Cachix.Client.OptionsParser\n  ( PinOptions (..),\n    PushArguments (..),\n    PushOptions (..),\n  )\nimport Cachix.Client.Push\nimport Cachix.Client.Retry (retryAll)\nimport Cachix.Client.Secrets\n  ( SigningKey (SigningKey),\n    exportSigningKey,\n  )\nimport Cachix.Client.Servant\nimport qualified Cachix.Client.WatchStore as WatchStore\nimport qualified Cachix.Types.BinaryCache as BinaryCache\nimport qualified Cachix.Types.PinCreate as PinCreate\nimport qualified Cachix.Types.SigningKeyCreate as SigningKeyCreate\nimport qualified Control.Concurrent.Async as Async\nimport Control.Exception.Safe (throwM)\nimport Control.Retry (RetryStatus (rsIterNumber))\nimport Crypto.Sign.Ed25519 (PublicKey (PublicKey), createKeypair)\nimport qualified Data.ByteString.Base64 as B64\nimport Data.String.Here\nimport qualified Data.Text as T\nimport qualified Data.Text.IO as T.IO\nimport GHC.IO.Handle (hDuplicate, hDuplicateTo)\nimport Hercules.CNix.Store (Store, StorePath, followLinksToStorePath, storePathToPath, withStore)\nimport Network.HTTP.Types (status401, status404)\nimport Protolude hiding (toS)\nimport Protolude.Conv\nimport Servant.API (NoContent)\nimport Servant.Auth.Client\nimport Servant.Client.Streaming\nimport Servant.Conduit ()\nimport System.Directory (doesFileExist)\nimport System.IO (hIsTerminalDevice)\nimport qualified System.Posix.Signals as Signals\nimport qualified System.Process\n\n-- TODO: check that token actually authenticates!\nauthtoken :: Env -> Maybe Text -> IO ()\nauthtoken Env {cachixoptions} (Just token) = do\n  let configPath = Config.configPath cachixoptions\n  config <- Config.getConfig configPath\n  Config.writeConfig configPath $ config {Config.authToken = Token (toS token)}\nauthtoken env Nothing = authtoken env . Just . T.strip =<< T.IO.getContents\n\ngenerateKeypair :: Env -> Text -> IO ()\ngenerateKeypair env name = do\n  authToken <- Config.getAuthTokenRequired (config env)\n  (PublicKey pk, sk) <- createKeypair\n  let signingKey = exportSigningKey $ SigningKey sk\n      signingKeyCreate = SigningKeyCreate.SigningKeyCreate (toS $ B64.encode pk)\n      bcc = Config.BinaryCacheConfig name signingKey\n  -- we first validate if key can be added to the binary cache\n  (_ :: NoContent) <-\n    escalate <=< retryAll $ \\_ ->\n      (`runClientM` clientenv env) $\n        API.createKey cachixClient authToken name signingKeyCreate\n  -- if key was successfully added, write it to the config\n  -- TODO: warn if binary cache with the same key already exists\n  let cfg = config env & Config.setBinaryCaches [bcc]\n  Config.writeConfig (Config.configPath (cachixoptions env)) cfg\n  putStrLn\n    ( [iTrim|\nSecret signing key has been saved in the file above. To populate\nyour binary cache:\n\n    $ nix-build | cachix push ${name}\n\nOr if you\'d like to use the signing key on another machine or CI:\n\n    $ export CACHIX_SIGNING_KEY=${signingKey}\n    $ nix-build | cachix push ${name}\n\nTo instruct Nix to use the binary cache:\n\n    $ cachix use ${name}\n\nIMPORTANT: Make sure to make a backup for the signing key above, as you have the only copy.\n  |] ::\n        Text\n    )\n\nnotAuthenticatedBinaryCache :: Text -> CachixException\nnotAuthenticatedBinaryCache name =\n  AccessDeniedBinaryCache $\n    "Binary cache " <> name <> " doesn\'t exist or it\'s private and you need a token: " <> Config.noAuthTokenError\n\naccessDeniedBinaryCache :: Text -> Maybe ByteString -> CachixException\naccessDeniedBinaryCache name maybeBody =\n  AccessDeniedBinaryCache $ "Binary cache " <> name <> " doesn\'t exist or you don\'t have access." <> context maybeBody\n  where\n    context Nothing = ""\n    context (Just body) = " Error: " <> toS body\n\nuse :: Env -> Text -> InstallationMode.UseOptions -> IO ()\nuse env name useOptions = do\n  optionalAuthToken <- Config.getAuthTokenMaybe (config env)\n  let token = fromMaybe (Token "") optionalAuthToken\n  -- 1. get cache public key\n  res <- retryAll $ \\_ -> (`runClientM` clientenv env) $ API.getCache cachixClient token name\n  case res of\n    Left err -> handleCacheResponse name optionalAuthToken err\n    Right binaryCache -> do\n      () <- escalateAs UnsupportedNixVersion =<< assertNixVersion\n      user <- InstallationMode.getUser\n      nc <- NixConf.read NixConf.Global\n      isTrusted <- InstallationMode.isTrustedUser $ NixConf.readLines (catMaybes [nc]) NixConf.isTrustedUsers\n      isNixOS <- doesFileExist "/run/current-system/nixos-version"\n      let nixEnv =\n            InstallationMode.NixEnv\n              { InstallationMode.isRoot = user == "root",\n                InstallationMode.isTrusted = isTrusted,\n                InstallationMode.isNixOS = isNixOS\n              }\n      InstallationMode.addBinaryCache (config env) binaryCache useOptions $\n        InstallationMode.getInstallationMode nixEnv useOptions\n\nhandleCacheResponse :: Text -> Maybe Token -> ClientError -> IO a\nhandleCacheResponse name optionalAuthToken err\n  | isErr err status401 && isJust optionalAuthToken = throwM $ accessDeniedBinaryCache name (failureResponseBody err)\n  | isErr err status401 = throwM $ notAuthenticatedBinaryCache name\n  | isErr err status404 = throwM $ BinaryCacheNotFound $ "Binary cache " <> name <> " does not exist."\n  | otherwise = throwM err\n\nfailureResponseBody :: ClientError -> Maybe ByteString\nfailureResponseBody (FailureResponse _ response) = Just $ toS $ responseBody response\nfailureResponseBody _ = Nothing\n\npush :: Env -> PushArguments -> IO ()\npush env (PushPaths opts name cliPaths) = do\n  hasStdin <- not <$> hIsTerminalDevice stdin\n  inputStorePaths <-\n    case (hasStdin, cliPaths) of\n      (False, []) -> throwIO $ NoInput "You need to specify store paths either as stdin or as an command argument"\n      (True, []) -> T.words <$> getContents\n      -- If we get both stdin and cli args, prefer cli args.\n      -- This avoids hangs in cases where stdin is non-interactive but unused by caller\n      -- some programming environments always create a (non-interactive) stdin\n      -- that may or may not be written to by the caller.\n      -- This is somewhat like the behavior of `cat` for example.\n      (_, paths) -> return paths\n  withPushParams env opts name $ \\pushParams -> do\n    normalized <-\n      liftIO $\n        for inputStorePaths $\n          \\path -> do\n            storePath <- followLinksToStorePath (pushParamsStore pushParams) (encodeUtf8 path)\n            filterInvalidStorePath (pushParamsStore pushParams) storePath\n    pushedPaths <-\n      pushClosure\n        (mapConcurrentlyBounded (numJobs opts))\n        pushParams\n        (catMaybes normalized)\n    case (length normalized, length pushedPaths) of\n      (0, _) -> putTextError "Nothing to push."\n      (_, 0) -> putTextError "Nothing to push - all store paths are already on Cachix."\n      _ -> putTextError "All done."\npush _ _ =\n  throwIO $\n    DeprecatedCommand "DEPRECATED: cachix watch-store has replaced cachix push --watch-store."\n\nputTextError :: Text -> IO ()\nputTextError = hPutStrLn stderr\n\npin :: Env -> PinOptions -> IO ()\npin env pinOpts = do\n  authToken <- Config.getAuthTokenRequired (config env)\n  storePath <- withStore $ \\store -> do\n    path <- followLinksToStorePath store (encodeUtf8 $ pinStorePath pinOpts)\n    storePathToPath store path\n  traverse_ (validateArtifact (toS storePath)) (pinArtifacts pinOpts)\n  let pinCreate =\n        PinCreate.PinCreate\n          { name = pinName pinOpts,\n            storePath = toS storePath,\n            artifacts = pinArtifacts pinOpts,\n            keep = pinKeep pinOpts\n          }\n  void $ escalate <=< retryAll $ \\_ ->\n    (`runClientM` clientenv env) $ API.createPin cachixClient authToken (pinCacheName pinOpts) pinCreate\n  where\n    validateArtifact :: Text -> Text -> IO ()\n    validateArtifact storePath artifact = do\n      -- strip prefix / from artifact path if it exists\n      let artifactPath = storePath <> "/" <> fromMaybe artifact (T.stripPrefix "/" artifact)\n      exists <- doesFileExist (toS artifactPath)\n      unless exists $ throwIO $ ArtifactNotFound $ "Artifact " <> artifactPath <> " doesn\'t exist."\n\nwatchStore :: Env -> PushOptions -> Text -> IO ()\nwatchStore env opts name = do\n  withPushParams env opts name $ \\pushParams ->\n    WatchStore.startWorkers (pushParamsStore pushParams) (numJobs opts) pushParams\n\nwatchExec :: Env -> PushOptions -> Text -> Text -> [Text] -> IO ()\nwatchExec env pushOpts name cmd args = withPushParams env pushOpts name $ \\pushParams -> do\n  stdoutOriginal <- hDuplicate stdout\n  let process =\n        (System.Process.proc (toS cmd) (toS <$> args))\n          { System.Process.std_out = System.Process.UseHandle stdoutOriginal\n          }\n      watch = do\n        hDuplicateTo stderr stdout -- redirect all stdout to stderr\n        WatchStore.startWorkers (pushParamsStore pushParams) (numJobs pushOpts) pushParams\n\n  (_, exitCode) <-\n    Async.concurrently watch $ do\n      exitCode <-\n        bracketOnError\n          (getProcessHandle <$> System.Process.createProcess process)\n          ( \\processHandle -> do\n              -- Terminate the process\n              uninterruptibleMask_ (System.Process.terminateProcess processHandle)\n              -- Wait for the process to clean up and exit\n              _ <- System.Process.waitForProcess processHandle\n              -- Stop watching the store and wait for all paths to be pushed\n              Signals.raiseSignal Signals.sigINT\n          )\n          System.Process.waitForProcess\n\n      -- Stop watching the store and wait for all paths to be pushed\n      Signals.raiseSignal Signals.sigINT\n      return exitCode\n\n  exitWith exitCode\n  where\n    getProcessHandle (_, _, _, processHandle) = processHandle\n\nretryText :: RetryStatus -> Text\nretryText retrystatus =\n  if rsIterNumber retrystatus == 0\n    then ""\n    else "(retry #" <> show (rsIterNumber retrystatus) <> ") "\n\npushStrategy :: Store -> Maybe Token -> PushOptions -> Text -> BinaryCache.CompressionMethod -> StorePath -> PushStrategy IO ()\npushStrategy store authToken opts name compressionMethod storePath =\n  PushStrategy\n    { onAlreadyPresent = pass,\n      on401 = handleCacheResponse name authToken,\n      onError = throwM,\n      onAttempt = \\retrystatus size -> do\n        path <- decodeUtf8With lenientDecode <$> storePathToPath store storePath\n        -- we append newline instead of putStrLn due to https://github.com/haskell/text/issues/242\n        putStr $ retryText retrystatus <> "compressing using " <> T.toLower (show compressionMethod) <> " and pushing " <> path <> " (" <> humanSize (fromIntegral size) <> ")\\n",\n      onDone = pass,\n      Cachix.Client.Push.compressionMethod = compressionMethod,\n      Cachix.Client.Push.compressionLevel = Cachix.Client.OptionsParser.compressionLevel opts,\n      Cachix.Client.Push.omitDeriver = Cachix.Client.OptionsParser.omitDeriver opts\n    }\n\nwithPushParams :: Env -> PushOptions -> Text -> (PushParams IO () -> IO ()) -> IO ()\nwithPushParams env pushOpts name m = do\n  pushSecret <- findPushSecret (config env) name\n  authToken <- Config.getAuthTokenMaybe (config env)\n  compressionMethodBackend <- case pushSecret of\n    PushSigningKey {} -> pure Nothing\n    PushToken {} -> do\n      let token = fromMaybe (Token "") authToken\n      res <- retryAll $ \\_ -> (`runClientM` clientenv env) $ API.getCache cachixClient token name\n      case res of\n        Left err -> handleCacheResponse name authToken err\n        Right binaryCache -> pure (Just $ BinaryCache.preferredCompressionMethod binaryCache)\n  let compressionMethod = fromMaybe BinaryCache.ZSTD (head $ catMaybes [Cachix.Client.OptionsParser.compressionMethod pushOpts, compressionMethodBackend])\n  withStore $ \\store ->\n    m\n      PushParams\n        { pushParamsName = name,\n          pushParamsSecret = pushSecret,\n          pushParamsClientEnv = clientenv env,\n          pushParamsStrategy = pushStrategy store authToken pushOpts name compressionMethod,\n          pushParamsStore = store\n        }\n'