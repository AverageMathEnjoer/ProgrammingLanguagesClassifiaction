b'{-# OPTIONS_GHC -fno-warn-unused-binds -fno-warn-name-shadowing#-}\n{-# LANGUAGE BangPatterns #-}\n{-# LANGUAGE DataKinds #-}\n{-# LANGUAGE UndecidableInstances #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{-# LANGUAGE DeriveGeneric #-}\n{-# LANGUAGE LambdaCase #-}\n{-# LANGUAGE CPP #-}\n\n-- | SQLite implementations of the Beam SQL syntax classes\n--\n-- The SQLite command syntax is implemented by \'SQLiteCommandSyntax\'.\nmodule Database.Beam.Sqlite.Syntax\n  (  -- * SQLite syntaxes\n    SqliteSyntax(..)\n\n  , SqliteCommandSyntax(..)\n\n  , SqliteSelectSyntax(..), SqliteInsertSyntax(..)\n  , SqliteUpdateSyntax(..), SqliteDeleteSyntax(..)\n\n  , SqliteOnConflictSyntax(..)\n  , SqliteInsertValuesSyntax(..)\n  , SqliteColumnSchemaSyntax(..)\n  , SqliteExpressionSyntax(..), SqliteValueSyntax(..)\n  , SqliteTableNameSyntax(..)\n  , SqliteFieldNameSyntax(..)\n  , SqliteAggregationSetQuantifierSyntax(..)\n\n  , fromSqliteExpression\n\n    -- * SQLite data type syntax\n  , SqliteDataTypeSyntax(..)\n  , sqliteTextType, sqliteBlobType\n  , sqliteBigIntType, sqliteSerialType\n\n    -- * Building and consuming \'SqliteSyntax\'\n  , fromSqliteCommand, formatSqliteInsert, formatSqliteInsertOnConflict\n\n  , emit, emitValue, parens, commas, quotedIdentifier\n\n  , sqliteEscape, withPlaceholders\n  , sqliteRenderSyntaxScript\n  ) where\n\nimport           Database.Beam.Backend.Internal.Compat\nimport           Database.Beam.Backend.SQL\nimport           Database.Beam.Backend.SQL.AST (ExtractField(..))\nimport           Database.Beam.Haskell.Syntax\nimport           Database.Beam.Migrate.Checks (HasDataTypeCreatedCheck(..))\nimport           Database.Beam.Migrate.SQL.Builder hiding (fromSqlConstraintAttributes)\nimport           Database.Beam.Migrate.SQL.SQL92\nimport           Database.Beam.Migrate.Serialization\nimport           Database.Beam.Query hiding (ExtractField(..))\n\nimport           Data.ByteString (ByteString)\nimport qualified Data.ByteString as B\nimport           Data.ByteString.Builder\nimport qualified Data.ByteString.Lazy.Char8 as BL\nimport           Data.Coerce\nimport qualified Data.DList as DL\nimport           Data.Hashable\nimport           Data.Int\nimport           Data.Maybe\nimport           Data.Scientific\nimport           Data.String\nimport qualified Data.Text as T\nimport qualified Data.Text.Encoding as TE\nimport qualified Data.Text.Lazy as TL\nimport           Data.Time\nimport           Data.Word\n#if !MIN_VERSION_base(4, 11, 0)\nimport           Data.Semigroup\n#endif\nimport           GHC.TypeLits\n\nimport           Database.SQLite.Simple (SQLData(..))\nimport           Database.SQLite.Simple.ToField (toField)\n\nimport           GHC.Float\nimport           GHC.Generics\n\n-- | The syntax for SQLite is stored as a \'Builder\' along with a list of data\n-- that hasn\'t been serialized yet.\n--\n-- The first argument is a function that receives a builder for \'SQLData\' and\n-- returns the concrete syntax to embed into the query. For queries sent to the\n-- backend, this is simply a function that returns @"?"@. Thus, the syntax sent\n-- to the backend includes proper placeholders. The list of data is sent to the\n-- SQLite library for proper escaping.\n--\n-- When the syntax is being serialized for display (for use in beam migrate for\n-- example), the data builder attempts to properly format and escape the data.\n-- This returns syntax suitable for inclusion in scripts. In this case, the\n-- value list is ignored.\ndata SqliteSyntax = SqliteSyntax ((SQLData -> Builder) -> Builder) (DL.DList SQLData)\nnewtype SqliteData = SqliteData SQLData -- newtype for Hashable\n  deriving Eq\n\ninstance Show SqliteSyntax where\n  show (SqliteSyntax s d) =\n    "SqliteSyntax (" <> show (toLazyByteString (withPlaceholders s)) <> ") " <> show d\n\ninstance Sql92DisplaySyntax SqliteSyntax where\n  displaySyntax = BL.unpack . sqliteRenderSyntaxScript\n\ninstance Semigroup SqliteSyntax where\n  (<>) = mappend\n\ninstance Monoid SqliteSyntax where\n  mempty = SqliteSyntax (\\_ -> mempty) mempty\n  mappend (SqliteSyntax ab av) (SqliteSyntax bb bv) =\n    SqliteSyntax (\\v -> ab v <> bb v) (av <> bv)\n\ninstance Eq SqliteSyntax where\n  SqliteSyntax ab av == SqliteSyntax bb bv =\n    toLazyByteString (withPlaceholders ab) ==\n      toLazyByteString (withPlaceholders bb) &&\n    av == bv\n\ninstance Hashable SqliteSyntax where\n  hashWithSalt salt (SqliteSyntax s d) =\n      hashWithSalt salt ( toLazyByteString (withPlaceholders s)\n                        , map SqliteData (DL.toList d) )\ninstance Hashable SqliteData where\n  hashWithSalt salt (SqliteData (SQLInteger i)) = hashWithSalt salt (0 :: Int, i)\n  hashWithSalt salt (SqliteData (SQLFloat d))   = hashWithSalt salt (1 :: Int, d)\n  hashWithSalt salt (SqliteData (SQLText t))    = hashWithSalt salt (2 :: Int, t)\n  hashWithSalt salt (SqliteData (SQLBlob b))    = hashWithSalt salt (3 :: Int, b)\n  hashWithSalt salt (SqliteData SQLNull)        = hashWithSalt salt (4 :: Int)\n\n-- | Convert the first argument of \'SQLiteSyntax\' to a \'ByteString\' \'Builder\',\n-- where all the data has been replaced by @"?"@ placeholders.\nwithPlaceholders :: ((SQLData -> Builder) -> Builder) -> Builder\nwithPlaceholders build = build (\\_ -> "?")\n\n-- | Embed a \'ByteString\' directly in the syntax\nemit :: ByteString -> SqliteSyntax\nemit b = SqliteSyntax (\\_ -> byteString b) mempty\n\nemit\' :: Show a => a -> SqliteSyntax\nemit\' x = SqliteSyntax (\\_ -> byteString (fromString (show x))) mempty\n\nquotedIdentifier :: T.Text -> SqliteSyntax\nquotedIdentifier txt = emit "\\"" <> SqliteSyntax (\\_ -> stringUtf8 (T.unpack (sqliteEscape txt))) mempty <> emit "\\""\n\n-- | A best effort attempt to implement the escaping rules of SQLite. This is\n-- never used to escape data sent to the database; only for emitting scripts or\n-- displaying syntax to the user.\nsqliteEscape :: T.Text -> T.Text\nsqliteEscape = T.concatMap (\\c -> if c == \'"\' then "\\"\\"" else T.singleton c)\n\n-- | Emit a properly escaped value into the syntax\n--\n-- This causes a literal @?@ 3\nemitValue ::  SQLData -> SqliteSyntax\nemitValue v = SqliteSyntax ($ v) (DL.singleton v)\n\n-- | Render a \'SqliteSyntax\' as a lazy \'BL.ByteString\', for purposes of\n-- displaying to a user. Embedded \'SQLData\' is directly embedded into the\n-- concrete syntax, with a best effort made to escape strings.\nsqliteRenderSyntaxScript :: SqliteSyntax -> BL.ByteString\nsqliteRenderSyntaxScript (SqliteSyntax s _) =\n    toLazyByteString . s $ \\case\n      SQLInteger i -> int64Dec i\n      SQLFloat   d -> doubleDec d\n      SQLText    t -> TE.encodeUtf8Builder (sqliteEscape t)\n      SQLBlob    b -> char8 \'X\' <> char8 \'\\\'\' <>\n                      foldMap word8Hex (B.unpack b) <>\n                      char8 \'\\\'\'\n      SQLNull      -> "NULL"\n\n-- * Syntax types\n\n-- | A SQLite command. @INSERT@ is special cased to handle @AUTO INCREMENT@\n-- columns. The \'fromSqliteCommand\' function will take an \'SqliteCommandSyntax\'\n-- and convert it into the correct \'SqliteSyntax\'.\ndata SqliteCommandSyntax\n  = SqliteCommandSyntax SqliteSyntax\n  | SqliteCommandInsert SqliteInsertSyntax\n\n-- | Convert a \'SqliteCommandSyntax\' into a renderable \'SqliteSyntax\'\nfromSqliteCommand :: SqliteCommandSyntax -> SqliteSyntax\nfromSqliteCommand (SqliteCommandSyntax s) = s\nfromSqliteCommand (SqliteCommandInsert (SqliteInsertSyntax tbl fields values onConflict)) =\n    formatSqliteInsertOnConflict tbl fields values onConflict\n\n-- | SQLite @SELECT@ syntax\nnewtype SqliteSelectSyntax = SqliteSelectSyntax { fromSqliteSelect :: SqliteSyntax }\n\n-- | SQLite @ON CONFLICT@ syntax\nnewtype SqliteOnConflictSyntax = SqliteOnConflictSyntax { fromSqliteOnConflict :: SqliteSyntax }\n\n-- | SQLite @INSERT@ syntax. This doesn\'t directly wrap \'SqliteSyntax\' because\n-- we need to do some processing on @INSERT@ statements to deal with @AUTO\n-- INCREMENT@ columns. Use \'formatSqliteInsert\' to turn \'SqliteInsertSyntax\'\n-- into \'SqliteSyntax\'.\ndata SqliteInsertSyntax\n  = SqliteInsertSyntax\n  { sqliteInsertTable      :: !SqliteTableNameSyntax\n  , sqliteInsertFields     :: [ T.Text ]\n  , sqliteInsertValues     :: !SqliteInsertValuesSyntax\n  , sqliteInsertOnConflict :: !(Maybe SqliteOnConflictSyntax)\n  }\n\n-- | SQLite @UPDATE@ syntax\nnewtype SqliteUpdateSyntax = SqliteUpdateSyntax { fromSqliteUpdate :: SqliteSyntax }\n-- | SQLite @DELETE@ syntax\nnewtype SqliteDeleteSyntax = SqliteDeleteSyntax { fromSqliteDelete :: SqliteSyntax }\n\nnewtype SqliteSelectTableSyntax = SqliteSelectTableSyntax { fromSqliteSelectTable :: SqliteSyntax }\n\n-- | Implements beam SQL expression syntaxes\ndata SqliteExpressionSyntax\n  = SqliteExpressionSyntax SqliteSyntax\n  | SqliteExpressionDefault\n  deriving (Show, Eq, Generic)\ninstance Hashable SqliteExpressionSyntax\nnewtype SqliteFromSyntax = SqliteFromSyntax { fromSqliteFromSyntax :: SqliteSyntax }\nnewtype SqliteComparisonQuantifierSyntax = SqliteComparisonQuantifierSyntax { fromSqliteComparisonQuantifier :: SqliteSyntax }\nnewtype SqliteAggregationSetQuantifierSyntax = SqliteAggregationSetQuantifierSyntax { fromSqliteAggregationSetQuantifier :: SqliteSyntax }\nnewtype SqliteProjectionSyntax = SqliteProjectionSyntax { fromSqliteProjection :: SqliteSyntax }\nnewtype SqliteGroupingSyntax = SqliteGroupingSyntax { fromSqliteGrouping :: SqliteSyntax }\nnewtype SqliteOrderingSyntax = SqliteOrderingSyntax { fromSqliteOrdering :: SqliteSyntax }\n-- | SQLite syntax for values that can be embedded in \'SqliteSyntax\'\nnewtype SqliteValueSyntax = SqliteValueSyntax { fromSqliteValue :: SqliteSyntax }\nnewtype SqliteTableSourceSyntax = SqliteTableSourceSyntax { fromSqliteTableSource :: SqliteSyntax }\nnewtype SqliteFieldNameSyntax = SqliteFieldNameSyntax { fromSqliteFieldNameSyntax :: SqliteSyntax }\n\n-- | SQLite @VALUES@ clause in @INSERT@. Expressions need to be handled\n-- explicitly in order to deal with @DEFAULT@ values and @AUTO INCREMENT@\n-- columns.\ndata SqliteInsertValuesSyntax\n  = SqliteInsertExpressions [ [ SqliteExpressionSyntax ] ]\n  | SqliteInsertFromSql SqliteSelectSyntax\nnewtype SqliteCreateTableSyntax = SqliteCreateTableSyntax { fromSqliteCreateTable :: SqliteSyntax }\ndata SqliteTableOptionsSyntax = SqliteTableOptionsSyntax SqliteSyntax SqliteSyntax\n\n-- | SQLite syntax for column schemas in @CREATE TABLE@ or @ALTER COLUMN ... ADD\n-- COLUMN@ statements\ndata SqliteColumnSchemaSyntax\n  = SqliteColumnSchemaSyntax\n  { fromSqliteColumnSchema :: SqliteSyntax\n  , sqliteIsSerialColumn   :: Bool }\n  deriving (Show, Eq, Generic)\ninstance Hashable SqliteColumnSchemaSyntax\n\ninstance Sql92DisplaySyntax SqliteColumnSchemaSyntax where\n  displaySyntax = displaySyntax . fromSqliteColumnSchema\n\n-- | SQLite syntax that implements \'IsSql92DataTypeSyntax\' and a good portion of\n-- \'IsSql99DataTypeSyntax\', except for array and row types.\ndata SqliteDataTypeSyntax\n  = SqliteDataTypeSyntax\n  { fromSqliteDataType :: SqliteSyntax\n  , sqliteDataTypeToHs :: HsDataType\n  , sqliteDataTypeSerialized :: BeamSerializedDataType\n  , sqliteDataTypeSerial :: Bool\n  } deriving (Show, Eq, Generic)\ninstance Hashable SqliteDataTypeSyntax where\n  hashWithSalt salt (SqliteDataTypeSyntax s _ _ _) = hashWithSalt salt s\ninstance Sql92DisplaySyntax SqliteDataTypeSyntax where\n  displaySyntax = displaySyntax . fromSqliteDataType\n\ndata SqliteColumnConstraintDefinitionSyntax\n  = SqliteColumnConstraintDefinitionSyntax\n  { fromSqliteColumnConstraintDefinition :: SqliteSyntax\n  , sqliteColumnConstraintDefinitionSerialized :: BeamSerializedConstraintDefinition\n  } deriving (Show, Eq)\ninstance Hashable SqliteColumnConstraintDefinitionSyntax where\n  hashWithSalt salt (SqliteColumnConstraintDefinitionSyntax s _) = hashWithSalt salt s\ninstance Sql92DisplaySyntax SqliteColumnConstraintDefinitionSyntax where\n  displaySyntax = displaySyntax . fromSqliteColumnConstraintDefinition\n\ndata SqliteColumnConstraintSyntax\n    = SqliteColumnConstraintSyntax\n    { fromSqliteColumnConstraint :: SqlConstraintAttributesBuilder -> SqliteSyntax\n    , sqliteColumnConstraintSerialized :: BeamSerializedConstraint }\ndata SqliteTableConstraintSyntax\n  = SqliteTableConstraintSyntax\n  { fromSqliteTableConstraint :: SqliteSyntax\n  , sqliteTableConstraintPrimaryKey :: Maybe [ T.Text ] }\ndata SqliteMatchTypeSyntax\n    = SqliteMatchTypeSyntax\n    { fromSqliteMatchType :: SqliteSyntax\n    , sqliteMatchTypeSerialized :: BeamSerializedMatchType }\ndata SqliteReferentialActionSyntax\n    = SqliteReferentialActionSyntax\n    { fromSqliteReferentialAction :: SqliteSyntax\n    , sqliteReferentialActionSerialized :: BeamSerializedReferentialAction }\nnewtype SqliteAlterTableSyntax = SqliteAlterTableSyntax { fromSqliteAlterTable :: SqliteSyntax }\nnewtype SqliteAlterTableActionSyntax = SqliteAlterTableActionSyntax { fromSqliteAlterTableAction :: Maybe SqliteSyntax }\nnewtype SqliteAlterColumnActionSyntax = SqliteAlterColumnActionSyntax { fromSqliteAlterColumnAction :: Maybe SqliteSyntax }\nnewtype SqliteDropTableSyntax = SqliteDropTableSyntax { fromSqliteDropTable :: SqliteSyntax }\nnewtype SqliteTableNameSyntax = SqliteTableNameSyntax { fromSqliteTableName :: SqliteSyntax }\n\nfromSqliteExpression :: SqliteExpressionSyntax -> SqliteSyntax\nfromSqliteExpression (SqliteExpressionSyntax s) = s\nfromSqliteExpression SqliteExpressionDefault = emit "NULL /* DEFAULT */"\n\nsqliteExpressionSerialized :: SqliteExpressionSyntax -> BeamSerializedExpression\nsqliteExpressionSerialized = BeamSerializedExpression . TE.decodeUtf8 . BL.toStrict .\n                             sqliteRenderSyntaxScript . fromSqliteExpression\n\n-- | Format a SQLite @INSERT@ expression for the given table name, fields, and values.\nformatSqliteInsert :: SqliteTableNameSyntax -> [ T.Text ] -> SqliteInsertValuesSyntax -> SqliteSyntax\nformatSqliteInsert tblNm fields values =\n  formatSqliteInsertOnConflict tblNm fields values Nothing\n\n-- | Format a SQLite @INSERT@ expression for the given table name, fields,\n-- values, and optionally an @ON CONFLICT@ clause.\nformatSqliteInsertOnConflict :: SqliteTableNameSyntax -> [ T.Text ] -> SqliteInsertValuesSyntax -> Maybe SqliteOnConflictSyntax -> SqliteSyntax\nformatSqliteInsertOnConflict tblNm fields values onConflict = mconcat\n  [ emit "INSERT INTO "\n  , fromSqliteTableName tblNm\n  , if null fields\n      then mempty\n      else parens (commas (map quotedIdentifier fields))\n  , emit " "\n  , case values of\n      SqliteInsertFromSql (SqliteSelectSyntax select) -> select\n      -- Because SQLite doesn\'t support explicit DEFAULT values, if an insert\n      -- batch contains any defaults, we split it into a series of single-row\n      -- inserts specifying only the non-default columns (which could differ\n      -- between rows in the batch). To insert all default values, there is\n      -- special DEFAULT VALUES syntax, which only supports one row anyway.\n      -- Unfortunately, SQLite doesn\'t currently support DEFAULT VALUES with ON\n      -- CONFLICT. We don\'t specially catch that in hopes that SQLite will some\n      -- day support it, since there is really no reason it shouldn\'t.\n      SqliteInsertExpressions [[]] -> emit "DEFAULT VALUES"\n      SqliteInsertExpressions es ->\n        emit "VALUES " <> commas (map (\\row -> parens (commas (map fromSqliteExpression row)) ) es)\n  , maybe mempty ((emit " " <>) . fromSqliteOnConflict) onConflict\n  ]\n\ninstance IsSql92Syntax SqliteCommandSyntax where\n  type Sql92SelectSyntax SqliteCommandSyntax = SqliteSelectSyntax\n  type Sql92InsertSyntax SqliteCommandSyntax = SqliteInsertSyntax\n  type Sql92UpdateSyntax SqliteCommandSyntax = SqliteUpdateSyntax\n  type Sql92DeleteSyntax SqliteCommandSyntax = SqliteDeleteSyntax\n\n  selectCmd = SqliteCommandSyntax . fromSqliteSelect\n  insertCmd = SqliteCommandInsert\n  updateCmd = SqliteCommandSyntax . fromSqliteUpdate\n  deleteCmd = SqliteCommandSyntax . fromSqliteDelete\n\ninstance IsSql92DdlCommandSyntax SqliteCommandSyntax where\n  type Sql92DdlCommandCreateTableSyntax SqliteCommandSyntax = SqliteCreateTableSyntax\n  type Sql92DdlCommandAlterTableSyntax SqliteCommandSyntax  = SqliteAlterTableSyntax\n  type Sql92DdlCommandDropTableSyntax SqliteCommandSyntax = SqliteDropTableSyntax\n\n  createTableCmd = SqliteCommandSyntax . fromSqliteCreateTable\n  alterTableCmd = SqliteCommandSyntax . fromSqliteAlterTable\n  dropTableCmd = SqliteCommandSyntax . fromSqliteDropTable\n\ninstance IsSql92TableNameSyntax SqliteTableNameSyntax where\n  -- SQLite doesn\'t have schemas proper, but it does have attached databases, which is what we use here\n  tableName Nothing tbl = SqliteTableNameSyntax (quotedIdentifier tbl)\n  tableName (Just sch) tbl = SqliteTableNameSyntax (quotedIdentifier sch <> emit "." <> quotedIdentifier tbl)\n\ninstance IsSql92DropTableSyntax SqliteDropTableSyntax where\n  type Sql92DropTableTableNameSyntax SqliteDropTableSyntax = SqliteTableNameSyntax\n\n  dropTableSyntax nm = SqliteDropTableSyntax (emit "DROP TABLE " <> fromSqliteTableName nm)\n\ninstance IsSql92AlterTableSyntax SqliteAlterTableSyntax where\n  type Sql92AlterTableAlterTableActionSyntax SqliteAlterTableSyntax = SqliteAlterTableActionSyntax\n  type Sql92AlterTableTableNameSyntax SqliteAlterTableSyntax = SqliteTableNameSyntax\n\n  alterTableSyntax nm action =\n    SqliteAlterTableSyntax $\n    case fromSqliteAlterTableAction action of\n      Just alterTable ->\n        emit "ALTER TABLE " <> fromSqliteTableName nm <> emit " " <> alterTable\n      Nothing ->\n        emit "SELECT 1"\n\ninstance IsSql92AlterTableActionSyntax SqliteAlterTableActionSyntax where\n  type Sql92AlterTableAlterColumnActionSyntax SqliteAlterTableActionSyntax = SqliteAlterColumnActionSyntax\n  type Sql92AlterTableColumnSchemaSyntax SqliteAlterTableActionSyntax = SqliteColumnSchemaSyntax\n\n  alterColumnSyntax columnNm columnAction =\n    SqliteAlterTableActionSyntax $\n    case fromSqliteAlterColumnAction columnAction of\n      Nothing -> Nothing\n      Just columnAction ->\n        Just (emit "ALTER COLUMN " <> quotedIdentifier columnNm <> columnAction)\n  addColumnSyntax columnNm schema =\n    SqliteAlterTableActionSyntax . Just $\n    emit "ADD COLUMN " <> quotedIdentifier columnNm <> emit " " <> fromSqliteColumnSchema schema\n  dropColumnSyntax _ = SqliteAlterTableActionSyntax Nothing\n\n  renameTableToSyntax newNm =\n    SqliteAlterTableActionSyntax . Just $\n    emit "RENAME TO " <> quotedIdentifier newNm\n\n  renameColumnToSyntax oldNm newNm =\n    SqliteAlterTableActionSyntax . Just $\n    emit "RENAME COLUMN " <> quotedIdentifier oldNm <>\n    emit " TO "           <> quotedIdentifier newNm\n\ninstance IsSql92AlterColumnActionSyntax SqliteAlterColumnActionSyntax where\n  setNotNullSyntax = SqliteAlterColumnActionSyntax Nothing\n  setNullSyntax = SqliteAlterColumnActionSyntax Nothing\n\ninstance IsSql92ColumnSchemaSyntax SqliteColumnSchemaSyntax where\n  type Sql92ColumnSchemaColumnTypeSyntax SqliteColumnSchemaSyntax = SqliteDataTypeSyntax\n  type Sql92ColumnSchemaExpressionSyntax SqliteColumnSchemaSyntax = SqliteExpressionSyntax\n  type Sql92ColumnSchemaColumnConstraintDefinitionSyntax SqliteColumnSchemaSyntax = SqliteColumnConstraintDefinitionSyntax\n\n  columnSchemaSyntax  ty defVal constraints collation =\n    SqliteColumnSchemaSyntax\n      (fromSqliteDataType ty <>\n       maybe mempty (\\defVal -> emit " DEFAULT " <> parens (fromSqliteExpression defVal)) defVal <>\n       foldMap (\\constraint -> emit " " <> fromSqliteColumnConstraintDefinition constraint <> emit " ") constraints <>\n       maybe mempty (\\c -> emit " COLLATE " <> quotedIdentifier c) collation)\n      (if sqliteDataTypeSerial ty then True else False)\n\ninstance IsSql92ColumnConstraintDefinitionSyntax SqliteColumnConstraintDefinitionSyntax where\n  type Sql92ColumnConstraintDefinitionConstraintSyntax SqliteColumnConstraintDefinitionSyntax = SqliteColumnConstraintSyntax\n  type Sql92ColumnConstraintDefinitionAttributesSyntax SqliteColumnConstraintDefinitionSyntax = SqlConstraintAttributesBuilder\n\n  constraintDefinitionSyntax nm def attrs =\n    SqliteColumnConstraintDefinitionSyntax\n      (maybe mempty (\\nm\' -> emit "CONSTRAINT " <> quotedIdentifier nm\') nm <>\n       fromSqliteColumnConstraint def (fromMaybe mempty attrs))\n      (constraintDefinitionSyntax nm (sqliteColumnConstraintSerialized def)\n                                     (fmap sqlConstraintAttributesSerialized attrs))\n\ninstance Sql92SerializableConstraintDefinitionSyntax SqliteColumnConstraintDefinitionSyntax where\n  serializeConstraint = fromBeamSerializedConstraintDefinition . sqliteColumnConstraintDefinitionSerialized\n\ninstance IsSql92ColumnConstraintSyntax SqliteColumnConstraintSyntax where\n  type Sql92ColumnConstraintMatchTypeSyntax SqliteColumnConstraintSyntax = SqliteMatchTypeSyntax\n  type Sql92ColumnConstraintReferentialActionSyntax SqliteColumnConstraintSyntax = SqliteReferentialActionSyntax\n  type Sql92ColumnConstraintExpressionSyntax SqliteColumnConstraintSyntax = SqliteExpressionSyntax\n\n  notNullConstraintSyntax = SqliteColumnConstraintSyntax (\\_ -> emit "NOT NULL") notNullConstraintSyntax\n  uniqueColumnConstraintSyntax = SqliteColumnConstraintSyntax (\\_ -> emit "UNIQUE") uniqueColumnConstraintSyntax\n  primaryKeyColumnConstraintSyntax = SqliteColumnConstraintSyntax (\\_ -> emit "PRIMARY KEY") primaryKeyColumnConstraintSyntax\n  checkColumnConstraintSyntax expr =\n    SqliteColumnConstraintSyntax (\\_ -> emit "CHECK " <> parens (fromSqliteExpression expr))\n                                 (checkColumnConstraintSyntax (sqliteExpressionSerialized expr))\n  referencesConstraintSyntax tbl fields matchType onUpdate onDelete =\n    SqliteColumnConstraintSyntax sqliteConstraint\n                                 (referencesConstraintSyntax tbl fields (fmap sqliteMatchTypeSerialized matchType)\n                                                             (fmap sqliteReferentialActionSerialized onUpdate)\n                                                             (fmap sqliteReferentialActionSerialized onDelete))\n    where\n      sqliteConstraint (SqlConstraintAttributesBuilder atTime deferrable) =\n        emit "REFERENCES " <> quotedIdentifier tbl <> parens (commas (map quotedIdentifier fields)) <>\n        maybe mempty (\\matchType\' -> emit " MATCH " <> fromSqliteMatchType matchType\') matchType <>\n        maybe mempty (\\onUpdate\' -> emit " ON UPDATE " <> fromSqliteReferentialAction onUpdate\') onUpdate <>\n        maybe mempty (\\onDelete\' -> emit " ON DELETE " <> fromSqliteReferentialAction onDelete\') onDelete <>\n        case (deferrable, atTime) of\n          (_, Just atTime) ->\n            let deferrable\' = fromMaybe False deferrable\n            in (if deferrable\' then emit " DEFERRABLE " else emit " NOT DEFERRABLE ") <>\n               case atTime of\n                 InitiallyDeferred -> emit "INITIALLY DEFERRED"\n                 InitiallyImmediate -> emit "INITIALLY IMMEDIATE"\n          (Just deferrable\', _) ->\n            if deferrable\' then emit " DEFERRABLE" else emit " NOT DEFERRABLE"\n          _ -> mempty\n\ninstance IsSql92MatchTypeSyntax SqliteMatchTypeSyntax where\n  fullMatchSyntax = SqliteMatchTypeSyntax (emit "FULL") fullMatchSyntax\n  partialMatchSyntax = SqliteMatchTypeSyntax (emit "PARTIAL") partialMatchSyntax\n\ninstance IsSql92ReferentialActionSyntax SqliteReferentialActionSyntax where\n  referentialActionCascadeSyntax = SqliteReferentialActionSyntax (emit "CASCADE") referentialActionCascadeSyntax\n  referentialActionSetNullSyntax = SqliteReferentialActionSyntax (emit "SET NULL") referentialActionSetNullSyntax\n  referentialActionSetDefaultSyntax = SqliteReferentialActionSyntax (emit "SET DEFAULT") referentialActionSetDefaultSyntax\n  referentialActionNoActionSyntax = SqliteReferentialActionSyntax (emit "NO ACTION") referentialActionNoActionSyntax\n\ninstance IsSql92TableConstraintSyntax SqliteTableConstraintSyntax where\n  primaryKeyConstraintSyntax fields =\n    SqliteTableConstraintSyntax\n      (emit "PRIMARY KEY" <> parens (commas (map quotedIdentifier fields)))\n      (Just fields)\n\ninstance IsSql92CreateTableSyntax SqliteCreateTableSyntax where\n  type Sql92CreateTableColumnSchemaSyntax SqliteCreateTableSyntax = SqliteColumnSchemaSyntax\n  type Sql92CreateTableTableConstraintSyntax SqliteCreateTableSyntax = SqliteTableConstraintSyntax\n  type Sql92CreateTableOptionsSyntax SqliteCreateTableSyntax = SqliteTableOptionsSyntax\n  type Sql92CreateTableTableNameSyntax SqliteCreateTableSyntax = SqliteTableNameSyntax\n\n  createTableSyntax _ nm fields constraints =\n    let fieldDefs = map mkFieldDef fields\n        constraintDefs = map fromSqliteTableConstraint constraints\n        noPkConstraintDefs = map fromSqliteTableConstraint (filter (isNothing . sqliteTableConstraintPrimaryKey) constraints)\n\n        constraintPks = mapMaybe sqliteTableConstraintPrimaryKey constraints\n        fieldPrimaryKey = map fst (filter (sqliteIsSerialColumn . snd) fields)\n\n        mkFieldDef (fieldNm, fieldTy) =\n          quotedIdentifier fieldNm <> emit " " <>\n          fromSqliteColumnSchema fieldTy\n\n        createWithConstraints constraintDefs\' =\n          SqliteCreateTableSyntax $\n          emit "CREATE TABLE " <> fromSqliteTableName nm <> parens (commas (fieldDefs <> constraintDefs\'))\n        normalCreateTable = createWithConstraints constraintDefs\n        createTableNoPkConstraint = createWithConstraints noPkConstraintDefs\n\n    in case fieldPrimaryKey of\n         []  -> normalCreateTable\n         [field] ->\n           case constraintPks of\n             [] -> error "A column claims to have a primary key, but there is no key on this table"\n             [[fieldPk]]\n               | field /= fieldPk -> error "Two columns claim to be a primary key on this table"\n               | otherwise -> createTableNoPkConstraint\n             _ -> error "There are multiple primary key constraints on this table"\n         _ -> error "More than one column claims to be a primary key on this table"\n\ninstance IsSql92DataTypeSyntax SqliteDataTypeSyntax where\n  domainType nm = SqliteDataTypeSyntax (quotedIdentifier nm) (domainType nm) (domainType nm) False\n  charType prec charSet = SqliteDataTypeSyntax (emit "CHAR" <> sqliteOptPrec prec <> sqliteOptCharSet charSet)\n                                               (charType prec charSet)\n                                               (charType prec charSet)\n                                               False\n  varCharType prec charSet = SqliteDataTypeSyntax (emit "VARCHAR" <> sqliteOptPrec prec <> sqliteOptCharSet charSet)\n                                                  (varCharType prec charSet)\n                                                  (varCharType prec charSet)\n                                                  False\n  nationalCharType prec = SqliteDataTypeSyntax (emit "NATIONAL CHAR" <> sqliteOptPrec prec)\n                                               (nationalCharType prec)\n                                               (nationalCharType prec)\n                                               False\n  nationalVarCharType prec = SqliteDataTypeSyntax (emit "NATIONAL CHARACTER VARYING" <> sqliteOptPrec prec)\n                                                  (nationalVarCharType prec)\n                                                  (nationalVarCharType prec)\n                                                  False\n  bitType prec = SqliteDataTypeSyntax (emit "BIT" <> sqliteOptPrec prec) (bitType prec) (bitType prec) False\n  varBitType prec = SqliteDataTypeSyntax (emit "BIT VARYING" <> sqliteOptPrec prec) (varBitType prec) (varBitType prec) False\n\n  numericType prec = SqliteDataTypeSyntax (emit "NUMERIC" <> sqliteOptNumericPrec prec) (numericType prec) (numericType prec) False\n  decimalType prec = SqliteDataTypeSyntax (emit "DECIMAL" <> sqliteOptNumericPrec prec) (decimalType prec) (decimalType prec) False\n\n  intType = SqliteDataTypeSyntax (emit "INTEGER") intType intType False\n  smallIntType = SqliteDataTypeSyntax (emit "SMALLINT") smallIntType smallIntType False\n\n  floatType prec = SqliteDataTypeSyntax (emit "FLOAT" <> sqliteOptPrec prec) (floatType prec) (floatType prec) False\n  doubleType = SqliteDataTypeSyntax (emit "DOUBLE PRECISION") doubleType doubleType False\n  realType = SqliteDataTypeSyntax (emit "REAL") realType realType False\n  dateType = SqliteDataTypeSyntax (emit "DATE") dateType dateType False\n  timeType prec withTz = SqliteDataTypeSyntax (emit "TIME" <> sqliteOptPrec prec <> if withTz then emit " WITH TIME ZONE" else mempty)\n                                              (timeType prec withTz) (timeType prec withTz) False\n  timestampType prec withTz = SqliteDataTypeSyntax (emit "TIMESTAMP" <> sqliteOptPrec prec <> if withTz then emit " WITH TIME ZONE" else mempty)\n                                                   (timestampType prec withTz) (timestampType prec withTz) False\n\ninstance IsSql99DataTypeSyntax SqliteDataTypeSyntax where\n  characterLargeObjectType = sqliteTextType\n  binaryLargeObjectType = sqliteBlobType\n  booleanType = SqliteDataTypeSyntax (emit "BOOLEAN") booleanType booleanType False\n  arrayType _ _ = error "SQLite does not support arrayType"\n  rowType _ = error "SQLite does not support rowType"\n\ninstance IsSql2008BigIntDataTypeSyntax SqliteDataTypeSyntax where\n  bigIntType = sqliteBigIntType\n\nsqliteTextType, sqliteBlobType, sqliteBigIntType :: SqliteDataTypeSyntax\nsqliteTextType = SqliteDataTypeSyntax (emit "TEXT")\n                                      (HsDataType (hsVarFrom "sqliteText" "Database.Beam.Sqlite")\n                                                  (HsType (tyConNamed "Text")\n                                                          (importSome "Data.Text" [importTyNamed "Text"]))\n                                                  characterLargeObjectType)\n                                     characterLargeObjectType\n                                     False\nsqliteBlobType = SqliteDataTypeSyntax (emit "BLOB")\n                                      (HsDataType (hsVarFrom "sqliteBlob" "Database.Beam.Sqlite")\n                                                  (HsType (tyConNamed "ByteString")\n                                                          (importSome "Data.ByteString" [importTyNamed "ByteString"]))\n                                                  binaryLargeObjectType)\n                                       binaryLargeObjectType\n                                       False\nsqliteBigIntType = SqliteDataTypeSyntax (emit "BIGINT")\n                                        (HsDataType (hsVarFrom "sqliteBigInt" "Database.Beam.Sqlite")\n                                                    (HsType (tyConNamed "Int64")\n                                                            (importSome "Data.Int" [importTyNamed "Int64"]))\n                                                    bigIntType)\n                                        bigIntType\n                                        False\n\ninstance Sql92SerializableDataTypeSyntax SqliteDataTypeSyntax where\n  serializeDataType = fromBeamSerializedDataType . sqliteDataTypeSerialized\n\nsqliteOptPrec :: Maybe Word -> SqliteSyntax\nsqliteOptPrec Nothing = mempty\nsqliteOptPrec (Just x) = parens (emit (fromString (show x)))\n\nsqliteOptNumericPrec :: Maybe (Word, Maybe Word)  -> SqliteSyntax\nsqliteOptNumericPrec Nothing = mempty\nsqliteOptNumericPrec (Just (prec, Nothing)) = sqliteOptPrec (Just prec)\nsqliteOptNumericPrec (Just (prec, Just dec)) = parens $ emit (fromString (show prec)) <> emit ", " <> emit (fromString (show dec))\n\nsqliteOptCharSet :: Maybe T.Text -> SqliteSyntax\nsqliteOptCharSet Nothing = mempty\nsqliteOptCharSet (Just cs) = emit " CHARACTER SET " <> emit (TE.encodeUtf8 cs)\n\ninstance IsSql92SelectSyntax SqliteSelectSyntax where\n  type Sql92SelectSelectTableSyntax SqliteSelectSyntax = SqliteSelectTableSyntax\n  type Sql92SelectOrderingSyntax SqliteSelectSyntax = SqliteOrderingSyntax\n\n  selectStmt tbl ordering limit offset =\n    SqliteSelectSyntax $\n    fromSqliteSelectTable tbl <>\n    (case ordering of\n       [] -> mempty\n       _ -> emit " ORDER BY " <> commas (coerce ordering)) <>\n    case (limit, offset) of\n      (Nothing, Nothing) -> mempty\n      (Just limit, Nothing) -> emit " LIMIT " <> emit\' limit\n      (Nothing, Just offset) -> emit " LIMIT -1 OFFSET " <> emit\' offset\n      (Just limit, Just offset) -> emit " LIMIT " <> emit\' limit <>\n                                   emit " OFFSET " <> emit\' offset\n\ninstance IsSql92SelectTableSyntax SqliteSelectTableSyntax where\n  type Sql92SelectTableSelectSyntax SqliteSelectTableSyntax = SqliteSelectSyntax\n  type Sql92SelectTableExpressionSyntax SqliteSelectTableSyntax = SqliteExpressionSyntax\n  type Sql92SelectTableProjectionSyntax SqliteSelectTableSyntax = SqliteProjectionSyntax\n  type Sql92SelectTableFromSyntax SqliteSelectTableSyntax = SqliteFromSyntax\n  type Sql92SelectTableGroupingSyntax SqliteSelectTableSyntax = SqliteGroupingSyntax\n  type Sql92SelectTableSetQuantifierSyntax SqliteSelectTableSyntax = SqliteAggregationSetQuantifierSyntax\n\n  selectTableStmt setQuantifier proj from where_ grouping having =\n    SqliteSelectTableSyntax $\n    emit "SELECT " <>\n    maybe mempty (<> emit " ") (fromSqliteAggregationSetQuantifier <$> setQuantifier) <>\n    fromSqliteProjection proj <>\n    maybe mempty (emit " FROM " <>) (fromSqliteFromSyntax <$> from) <>\n    maybe mempty (emit " WHERE " <>) (fromSqliteExpression <$> where_) <>\n    maybe mempty (emit " GROUP BY " <>) (fromSqliteGrouping <$> grouping) <>\n    maybe mempty (emit " HAVING " <>) (fromSqliteExpression <$> having)\n\n  unionTables all = tableOp (if all then "UNION ALL" else "UNION")\n  intersectTables all = tableOp (if all then "INTERSECT ALL" else "INTERSECT")\n  exceptTable all = tableOp (if all then "EXCEPT ALL" else "EXCEPT")\n\ntableOp :: ByteString -> SqliteSelectTableSyntax -> SqliteSelectTableSyntax -> SqliteSelectTableSyntax\ntableOp op a b =\n  SqliteSelectTableSyntax $\n  fromSqliteSelectTable a <> spaces (emit op) <> fromSqliteSelectTable b\n\ninstance IsSql92FromSyntax SqliteFromSyntax where\n  type Sql92FromExpressionSyntax SqliteFromSyntax = SqliteExpressionSyntax\n  type Sql92FromTableSourceSyntax SqliteFromSyntax = SqliteTableSourceSyntax\n\n  fromTable tableSrc Nothing = SqliteFromSyntax (fromSqliteTableSource tableSrc)\n  fromTable tableSrc (Just (nm, colNms)) =\n    SqliteFromSyntax (fromSqliteTableSource tableSrc <> emit " AS " <> quotedIdentifier nm <>\n                      maybe mempty (\\colNms\' -> parens (commas (map quotedIdentifier colNms\'))) colNms)\n\n  innerJoin = _join "INNER JOIN"\n  leftJoin = _join "LEFT JOIN"\n  rightJoin = _join "RIGHT JOIN"\n\n_join :: ByteString -> SqliteFromSyntax -> SqliteFromSyntax -> Maybe SqliteExpressionSyntax -> SqliteFromSyntax\n_join joinType a b Nothing =\n  SqliteFromSyntax (fromSqliteFromSyntax a <> spaces (emit joinType) <> fromSqliteFromSyntax b)\n_join joinType a b (Just on) =\n  SqliteFromSyntax (fromSqliteFromSyntax a <> spaces (emit joinType) <> fromSqliteFromSyntax b <> emit " ON " <> fromSqliteExpression on)\n\ninstance IsSql92ProjectionSyntax SqliteProjectionSyntax where\n  type Sql92ProjectionExpressionSyntax SqliteProjectionSyntax = SqliteExpressionSyntax\n\n  projExprs exprs =\n    SqliteProjectionSyntax $\n    commas (map (\\(expr, nm) -> fromSqliteExpression expr <>\n                                maybe mempty (\\nm -> emit " AS " <> quotedIdentifier nm) nm) exprs)\n\ninstance IsSql92FieldNameSyntax SqliteFieldNameSyntax where\n  qualifiedField a b =\n    SqliteFieldNameSyntax $\n    quotedIdentifier a <> emit "." <> quotedIdentifier b\n  unqualifiedField a =\n    SqliteFieldNameSyntax $\n    quotedIdentifier a\n\ninstance IsSql92TableSourceSyntax SqliteTableSourceSyntax where\n  type Sql92TableSourceTableNameSyntax SqliteTableSourceSyntax = SqliteTableNameSyntax\n  type Sql92TableSourceSelectSyntax SqliteTableSourceSyntax = SqliteSelectSyntax\n  type Sql92TableSourceExpressionSyntax SqliteTableSourceSyntax = SqliteExpressionSyntax\n\n  tableNamed = SqliteTableSourceSyntax . fromSqliteTableName\n  tableFromSubSelect s =\n    SqliteTableSourceSyntax (parens (fromSqliteSelect s))\n  tableFromValues vss = SqliteTableSourceSyntax . parens $\n                        emit "VALUES " <>\n                        commas (map (\\vs -> parens (commas (map fromSqliteExpression vs))) vss)\n\ninstance IsSql92GroupingSyntax SqliteGroupingSyntax where\n  type Sql92GroupingExpressionSyntax SqliteGroupingSyntax = SqliteExpressionSyntax\n\n  groupByExpressions es =\n    SqliteGroupingSyntax $\n    commas (map fromSqliteExpression es)\n\ninstance IsSql92OrderingSyntax SqliteOrderingSyntax where\n  type Sql92OrderingExpressionSyntax SqliteOrderingSyntax = SqliteExpressionSyntax\n\n  ascOrdering e = SqliteOrderingSyntax (fromSqliteExpression e <> emit " ASC")\n  descOrdering e = SqliteOrderingSyntax (fromSqliteExpression e <> emit " DESC")\n\ninstance HasSqlValueSyntax SqliteValueSyntax Int8 where\n  sqlValueSyntax i = SqliteValueSyntax (emitValue (SQLInteger (fromIntegral i)))\ninstance HasSqlValueSyntax SqliteValueSyntax Int16 where\n  sqlValueSyntax i = SqliteValueSyntax (emitValue (SQLInteger (fromIntegral i)))\ninstance HasSqlValueSyntax SqliteValueSyntax Int32 where\n  sqlValueSyntax i = SqliteValueSyntax (emitValue (SQLInteger (fromIntegral i)))\ninstance HasSqlValueSyntax SqliteValueSyntax Int64 where\n  sqlValueSyntax i = SqliteValueSyntax (emitValue (SQLInteger (fromIntegral i)))\ninstance HasSqlValueSyntax SqliteValueSyntax Word8 where\n  sqlValueSyntax i = SqliteValueSyntax (emitValue (SQLInteger (fromIntegral i)))\ninstance HasSqlValueSyntax SqliteValueSyntax Word16 where\n  sqlValueSyntax i = SqliteValueSyntax (emitValue (SQLInteger (fromIntegral i)))\ninstance HasSqlValueSyntax SqliteValueSyntax Word32 where\n  sqlValueSyntax i = SqliteValueSyntax (emitValue (SQLInteger (fromIntegral i)))\ninstance HasSqlValueSyntax SqliteValueSyntax Word64 where\n  sqlValueSyntax i = SqliteValueSyntax (emitValue (SQLInteger (fromIntegral i)))\ninstance HasSqlValueSyntax SqliteValueSyntax Scientific where\n  sqlValueSyntax s = SqliteValueSyntax (emitValue (SQLText (fromString (show s)))) -- Rely on sqlites duck typing\ninstance HasSqlValueSyntax SqliteValueSyntax Float where\n  sqlValueSyntax f = SqliteValueSyntax (emitValue (SQLFloat (float2Double f)))\ninstance HasSqlValueSyntax SqliteValueSyntax Double where\n  sqlValueSyntax f = SqliteValueSyntax (emitValue (SQLFloat f))\ninstance HasSqlValueSyntax SqliteValueSyntax Bool where\n  sqlValueSyntax = sqlValueSyntax . (\\b -> if b then 1 else 0 :: Int32)\ninstance HasSqlValueSyntax SqliteValueSyntax SqlNull where\n  sqlValueSyntax _ = SqliteValueSyntax (emit "NULL")\ninstance HasSqlValueSyntax SqliteValueSyntax String where\n  sqlValueSyntax s = SqliteValueSyntax (emitValue (SQLText (fromString s)))\ninstance HasSqlValueSyntax SqliteValueSyntax T.Text where\n  sqlValueSyntax s = SqliteValueSyntax (emitValue (SQLText s))\ninstance HasSqlValueSyntax SqliteValueSyntax TL.Text where\n  sqlValueSyntax s = SqliteValueSyntax (emitValue (SQLText (TL.toStrict s)))\ninstance HasSqlValueSyntax SqliteValueSyntax x =>\n  HasSqlValueSyntax SqliteValueSyntax (Maybe x) where\n  sqlValueSyntax (Just x) = sqlValueSyntax x\n  sqlValueSyntax Nothing = sqlValueSyntax SqlNull\n\ninstance TypeError (PreferExplicitSize Int Int32) => HasSqlValueSyntax SqliteValueSyntax Int where\n  sqlValueSyntax i = SqliteValueSyntax (emitValue (SQLInteger (fromIntegral i)))\n\ninstance TypeError (PreferExplicitSize Word Word32) => HasSqlValueSyntax SqliteValueSyntax Word where\n  sqlValueSyntax i = SqliteValueSyntax (emitValue (SQLInteger (fromIntegral i)))\n\ninstance IsCustomSqlSyntax SqliteExpressionSyntax where\n  newtype CustomSqlSyntax SqliteExpressionSyntax =\n    SqliteCustomExpressionSyntax { fromSqliteCustomExpression :: SqliteSyntax }\n    deriving (Monoid, Semigroup)\n\n  customExprSyntax = SqliteExpressionSyntax . fromSqliteCustomExpression\n  renderSyntax = SqliteCustomExpressionSyntax . fromSqliteExpression\ninstance IsString (CustomSqlSyntax SqliteExpressionSyntax) where\n  fromString = SqliteCustomExpressionSyntax . emit . fromString\n\ninstance IsSql92QuantifierSyntax SqliteComparisonQuantifierSyntax where\n  quantifyOverAll = SqliteComparisonQuantifierSyntax (emit "ALL")\n  quantifyOverAny = SqliteComparisonQuantifierSyntax (emit "ANY")\n\ninstance IsSql92ExpressionSyntax SqliteExpressionSyntax where\n  type Sql92ExpressionValueSyntax SqliteExpressionSyntax = SqliteValueSyntax\n  type Sql92ExpressionSelectSyntax SqliteExpressionSyntax = SqliteSelectSyntax\n  type Sql92ExpressionFieldNameSyntax SqliteExpressionSyntax = SqliteFieldNameSyntax\n  type Sql92ExpressionQuantifierSyntax SqliteExpressionSyntax = SqliteComparisonQuantifierSyntax\n  type Sql92ExpressionCastTargetSyntax SqliteExpressionSyntax = SqliteDataTypeSyntax\n  type Sql92ExpressionExtractFieldSyntax SqliteExpressionSyntax = ExtractField\n\n  addE = binOp "+"; subE = binOp "-"; mulE = binOp "*"; divE = binOp "/"\n  modE = binOp "%"; orE = binOp "OR"; andE = binOp "AND"; likeE = binOp "LIKE"\n  overlapsE = binOp "OVERLAPS"\n\n  eqE = compOp "="; neqE = compOp "<>"; ltE = compOp "<"; gtE = compOp ">"\n  leE = compOp "<="; geE = compOp ">="\n\n  negateE = unOp "-"; notE = unOp "NOT"\n\n  isNotNullE = postFix "IS NOT NULL"; isNullE = postFix "IS NULL"\n\n  -- SQLite doesn\'t handle tri-state booleans properly\n  isTrueE = postFix "IS 1"; isNotTrueE = postFix "IS NOT 1"\n  isFalseE = postFix "IS 0"; isNotFalseE = postFix "IS NOT 0"\n  isUnknownE = postFix "IS NULL"; isNotUnknownE = postFix "IS NOT NULL"\n\n  existsE select = SqliteExpressionSyntax (emit "EXISTS " <> parens (fromSqliteSelect select))\n  uniqueE select = SqliteExpressionSyntax (emit "UNIQUE " <> parens (fromSqliteSelect select))\n\n  betweenE a b c = SqliteExpressionSyntax (parens (fromSqliteExpression a) <>\n                                           emit " BETWEEN " <>\n                                           parens (fromSqliteExpression b) <>\n                                           emit " AND " <>\n                                           parens (fromSqliteExpression c))\n\n  valueE = SqliteExpressionSyntax . fromSqliteValue\n\n  rowE vs = SqliteExpressionSyntax (parens (commas (map fromSqliteExpression vs)))\n  fieldE = SqliteExpressionSyntax . fromSqliteFieldNameSyntax\n\n  subqueryE = SqliteExpressionSyntax . parens . fromSqliteSelect\n\n  positionE needle haystack =\n    SqliteExpressionSyntax $\n    emit "POSITION" <> parens (parens (fromSqliteExpression needle) <> emit " IN " <> parens (fromSqliteExpression haystack))\n  nullIfE a b =\n    SqliteExpressionSyntax $\n    emit "NULLIF" <> parens (fromSqliteExpression a <> emit ", " <> fromSqliteExpression b)\n  absE x = SqliteExpressionSyntax (emit "ABS" <> parens (fromSqliteExpression x))\n  bitLengthE x = SqliteExpressionSyntax (emit "8 * LENGTH" <> parens (emit "CAST" <> parens (parens (fromSqliteExpression x) <> emit " AS BLOB")))\n  charLengthE x = SqliteExpressionSyntax (emit "LENGTH" <> parens (fromSqliteExpression x))\n  octetLengthE x = SqliteExpressionSyntax (emit "LENGTH" <> parens (emit "CAST" <> parens (parens (fromSqliteExpression x) <> emit " AS BLOB")))\n  lowerE x = SqliteExpressionSyntax (emit "LOWER" <> parens (fromSqliteExpression x))\n  upperE x = SqliteExpressionSyntax (emit "UPPER" <> parens (fromSqliteExpression x))\n  trimE x = SqliteExpressionSyntax (emit "TRIM" <> parens (fromSqliteExpression x))\n  coalesceE es = SqliteExpressionSyntax (emit "COALESCE" <> parens (commas (map fromSqliteExpression es)))\n  extractE = sqliteExtract\n  castE e t = SqliteExpressionSyntax (emit "CAST" <> parens (parens (fromSqliteExpression e) <> emit " AS " <> fromSqliteDataType t))\n  caseE cases else_ =\n    SqliteExpressionSyntax $\n    emit "CASE " <>\n    foldMap (\\(cond, res) -> emit "WHEN " <> fromSqliteExpression cond <> emit " THEN " <> fromSqliteExpression res <> emit " ") cases <>\n    emit "ELSE " <> fromSqliteExpression else_ <> emit " END"\n\n  currentTimestampE = SqliteExpressionSyntax (emit "CURRENT_TIMESTAMP")\n\n  defaultE = SqliteExpressionDefault\n  inE e es = SqliteExpressionSyntax (parens (fromSqliteExpression e) <> emit " IN " <> parens (commas (map fromSqliteExpression es)))\n  inSelectE e sel =\n      SqliteExpressionSyntax (parens (fromSqliteExpression e) <> emit " IN " <> parens (fromSqliteSelect sel))\n\ninstance IsSql99ConcatExpressionSyntax SqliteExpressionSyntax where\n  concatE [] = valueE (sqlValueSyntax ("" :: T.Text))\n  concatE (x:xs) =\n    SqliteExpressionSyntax $ parens $\n    foldl (\\a b -> a <> emit " || " <> parens (fromSqliteExpression b)) (fromSqliteExpression x) xs\n\ninstance IsSql99FunctionExpressionSyntax SqliteExpressionSyntax where\n  functionCallE fn args =\n    SqliteExpressionSyntax $\n    fromSqliteExpression fn <> parens (commas (fmap fromSqliteExpression args))\n  functionNameE nm = SqliteExpressionSyntax (emit (TE.encodeUtf8 nm))\n\nbinOp :: ByteString -> SqliteExpressionSyntax -> SqliteExpressionSyntax -> SqliteExpressionSyntax\nbinOp op a b =\n  SqliteExpressionSyntax $\n  parens (fromSqliteExpression a) <> emit " " <> emit op <> emit " " <> parens (fromSqliteExpression b)\n\ncompOp :: ByteString -> Maybe SqliteComparisonQuantifierSyntax\n       -> SqliteExpressionSyntax -> SqliteExpressionSyntax\n       -> SqliteExpressionSyntax\ncompOp op quantifier a b =\n  SqliteExpressionSyntax $\n  parens (fromSqliteExpression a) <>\n  emit op <>\n  maybe mempty (\\q -> emit " " <> fromSqliteComparisonQuantifier q <> emit " ") quantifier <>\n  parens (fromSqliteExpression b)\n\nunOp, postFix :: ByteString -> SqliteExpressionSyntax -> SqliteExpressionSyntax\nunOp op a =\n  SqliteExpressionSyntax (emit op <> parens (fromSqliteExpression a))\npostFix op a =\n  SqliteExpressionSyntax (parens (fromSqliteExpression a) <> emit " " <> emit op)\n\ninstance IsSql92AggregationExpressionSyntax SqliteExpressionSyntax where\n  type Sql92AggregationSetQuantifierSyntax SqliteExpressionSyntax = SqliteAggregationSetQuantifierSyntax\n\n  countAllE = SqliteExpressionSyntax (emit "COUNT(*)")\n  countE = unAgg "COUNT"\n  sumE = unAgg "SUM"\n  avgE = unAgg "AVG"\n  minE = unAgg "MIN"\n  maxE = unAgg "MAX"\n\nunAgg :: ByteString -> Maybe SqliteAggregationSetQuantifierSyntax -> SqliteExpressionSyntax\n      -> SqliteExpressionSyntax\nunAgg fn q e =\n  SqliteExpressionSyntax $\n  emit fn <> parens (maybe mempty (\\q -> fromSqliteAggregationSetQuantifier q <> emit " ") q <>\n                     fromSqliteExpression e)\n\ninstance IsSql92AggregationSetQuantifierSyntax SqliteAggregationSetQuantifierSyntax where\n  setQuantifierDistinct = SqliteAggregationSetQuantifierSyntax (emit "DISTINCT")\n  setQuantifierAll = SqliteAggregationSetQuantifierSyntax (emit "ALL")\n\ninstance IsSql92InsertSyntax SqliteInsertSyntax where\n  type Sql92InsertTableNameSyntax SqliteInsertSyntax = SqliteTableNameSyntax\n  type Sql92InsertValuesSyntax SqliteInsertSyntax = SqliteInsertValuesSyntax\n\n  insertStmt table fields values = SqliteInsertSyntax table fields values Nothing\n\ninstance IsSql92InsertValuesSyntax SqliteInsertValuesSyntax where\n  type Sql92InsertValuesExpressionSyntax SqliteInsertValuesSyntax = SqliteExpressionSyntax\n  type Sql92InsertValuesSelectSyntax SqliteInsertValuesSyntax = SqliteSelectSyntax\n\n  insertSqlExpressions = SqliteInsertExpressions\n  insertFromSql = SqliteInsertFromSql\n\ninstance IsSql92UpdateSyntax SqliteUpdateSyntax where\n  type Sql92UpdateTableNameSyntax SqliteUpdateSyntax = SqliteTableNameSyntax\n  type Sql92UpdateFieldNameSyntax SqliteUpdateSyntax = SqliteFieldNameSyntax\n  type Sql92UpdateExpressionSyntax SqliteUpdateSyntax = SqliteExpressionSyntax\n\n  updateStmt tbl fields where_ =\n    SqliteUpdateSyntax $\n    emit "UPDATE " <> fromSqliteTableName tbl <>\n    (case fields of\n       [] -> mempty\n       _ -> emit " SET " <>\n            commas (map (\\(field, val) -> fromSqliteFieldNameSyntax field <> emit "=" <> fromSqliteExpression val) fields)) <>\n    maybe mempty (\\where_ -> emit " WHERE " <> fromSqliteExpression where_) where_\n\ninstance IsSql92DeleteSyntax SqliteDeleteSyntax where\n  type Sql92DeleteTableNameSyntax SqliteDeleteSyntax = SqliteTableNameSyntax\n  type Sql92DeleteExpressionSyntax SqliteDeleteSyntax = SqliteExpressionSyntax\n\n  deleteStmt tbl Nothing where_ =\n    SqliteDeleteSyntax $\n    emit "DELETE FROM " <> fromSqliteTableName tbl <>\n    maybe mempty (\\where_ -> emit " WHERE " <> fromSqliteExpression where_) where_\n  deleteStmt _ (Just _) _ =\n      error "beam-sqlite: invariant failed: DELETE must not have a table alias"\n\nspaces, parens :: SqliteSyntax -> SqliteSyntax\nspaces a = emit " " <> a <> emit " "\nparens a = emit "(" <> a <> emit ")"\n\ncommas :: [SqliteSyntax] -> SqliteSyntax\ncommas [] = mempty\ncommas [x] = x\ncommas (x:xs) = x <> foldMap (emit ", " <>) xs\n\nstrftimeSyntax :: SqliteExpressionSyntax -> SqliteExpressionSyntax -> [ SqliteExpressionSyntax ] -> SqliteExpressionSyntax\nstrftimeSyntax fmt ts mods =\n    functionCallE (SqliteExpressionSyntax (emit "strftime"))\n                  (fmt:ts:mods)\n\n-- | SQLite does not support @EXTRACT@ directly, but we can emulate\n-- the behavior if we know which field we want.\nsqliteExtract :: ExtractField -> SqliteExpressionSyntax -> SqliteExpressionSyntax\nsqliteExtract field from =\n    case field of\n      ExtractFieldTimeZoneHour   -> error "sqliteExtract: TODO ExtractFieldTimeZoneHour"\n      ExtractFieldTimeZoneMinute -> error "sqliteExtract: TODO ExtractFieldTimeZoneMinute"\n\n      ExtractFieldDateTimeYear   -> extractStrftime "%Y"\n      ExtractFieldDateTimeMonth  -> extractStrftime "%m"\n      ExtractFieldDateTimeDay    -> extractStrftime "%d"\n      ExtractFieldDateTimeHour   -> extractStrftime "%H"\n      ExtractFieldDateTimeMinute -> extractStrftime "%M"\n      ExtractFieldDateTimeSecond -> extractStrftime "%S"\n\n    where\n      extractStrftime :: String -> SqliteExpressionSyntax\n      extractStrftime fmt = strftimeSyntax (valueE (sqlValueSyntax fmt)) from []\n\nsqliteSerialType :: SqliteDataTypeSyntax\nsqliteSerialType = SqliteDataTypeSyntax (emit "INTEGER PRIMARY KEY AUTOINCREMENT")\n                                        intType\n                                        (BeamSerializedDataType (beamSerializeJSON "sqlite" "serial"))\n                                        True\n\ninstance HasSqlValueSyntax SqliteValueSyntax ByteString where\n  sqlValueSyntax bs = SqliteValueSyntax (emitValue (SQLBlob bs))\n\ninstance HasSqlValueSyntax SqliteValueSyntax UTCTime where\n  sqlValueSyntax tm = SqliteValueSyntax (emitValue (toField tm))\n\ninstance HasSqlValueSyntax SqliteValueSyntax LocalTime where\n  sqlValueSyntax tm = SqliteValueSyntax (emitValue (SQLText (fromString tmStr)))\n    where tmStr = formatTime defaultTimeLocale (iso8601DateFormat (Just "%H:%M:%S%Q")) tm\n\ninstance HasSqlValueSyntax SqliteValueSyntax Day where\n  sqlValueSyntax tm = SqliteValueSyntax (emitValue (SQLText (fromString tmStr)))\n    where tmStr = formatTime defaultTimeLocale (iso8601DateFormat Nothing) tm\n\ninstance HasDataTypeCreatedCheck SqliteDataTypeSyntax where\n  dataTypeHasBeenCreated _ _ = True\n'