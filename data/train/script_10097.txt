b'#\' @importFrom grDevices recordPlot dev.cur hcl dev.list dev.off\n#\' @importFrom utils browseURL\n#\' @import xml2\n\n# function to preview HTML in RStudio viewer or web browser\npreview = function(x){\n  htmlFile = tempfile(fileext=".html")\n  cat(x, file=htmlFile)\n  viewer = getOption("viewer")\n  if ((!is.null(viewer)) && is.function(viewer))\n    viewer(htmlFile)\n  else\n    browseURL(htmlFile)\n}\n\n# helper function to show p values right aligned with digitspvals sign digits and \n# degrees of freedom columns as right aligned integers\nxtable2 = function(x, ndigits = 2, ndigitspvals = 2, trim.pval = 1E-16, ...) {\n  sm = xtable(x)\n  ncol = ncol(sm)\n  digs = rep(ndigits, ncol + 1)\n  disp = rep("f", ncol + 1)\n  whch = grep("\\\\QPr(\\\\E|\\\\Qp-value\\\\E|\\\\Qp value\\\\E|\\\\Qpadj\\\\E|^p$|^padj$|p[.]value", colnames(sm))\n  \n  if (length(whch) != 0) {\n    for(j in whch){ # Format the pvalues in scientific format\n      sm[,j] <- sapply(sm[,j],function(val){\n        val <- ifelse(val < trim.pval, \n                      paste0("< ", formatC(trim.pval, format = "e", digits = 0)), \n                      formatC(val, format = "e", digits = ndigitspvals))\n        return(val)\n      })\n    }\n  }\n  # whch = grep("^Df$|^df$", colnames(sm))\n  # if (length(whch) != 0){\n  #   digs[whch + 1] = 0\n  #   disp[whch + 1] = "d"\n  # }\n  # digs[c(1,which(!sapply(sm,is.numeric))+1)] <- NA\n  # disp[c(1,which(!sapply(sm,is.numeric))+1)] <- "s"\n  # for(i in 2:length(digs)){\n  #   if(disp[i]=="f") sm[,i-1] <- round(sm[,i-1], digits = digs[i])\n  # }\n  xtable(sm, digits = digs, display = disp,...)\n}\n\ntidy2 <- function(x, ndigits = 2, ndigitspvals = 2, trim.pval = T, ...) {\n  x <- tidy(x)\n  ncol = ncol(x)\n  digs = rep(ndigits, ncol)\n  whch = grep("\\\\QPr(\\\\E|\\\\Qp-value\\\\E|\\\\Qp value\\\\E|\\\\Qpadj\\\\E|^p$|^padj$|p[.]value", colnames(x))\n  if (length(whch) != 0) { digs[whch] = "pval" }\n  whch = grep("^Df$|^df$", colnames(x))\n  if (length(whch) != 0){ digs[whch] = 0 }\n  digs[!sapply(x,is.numeric)] <- NA\n  for(i in 1:length(digs)){\n    if(is.numeric(digs[i])) x[,i] <- round(x[,i], digits = digs[i])\n    if(digs[i]=="pval"){ \n      x[,i] <- sapply(x[,i],function(val){\n        ifelse(val < 10^-ndigitspvals & trim.pval,\n               paste0("<", 10^-ndigitspvals),\n               formatC(val, format = "f", digits = ndigitspvals))\n      })\n    }\n  }\n  return(x)\n}\n\ndata.frame2<- function(x, ndigits = 2, ndigitspvals = 2, trim.pval = T,...) {\n  x <- data.frame(x, check.names = F)\n  ncol = ncol(x)\n  digs = rep(ndigits, ncol)\n  whch = grep("\\\\QPr(\\\\E|\\\\Qp-value\\\\E|\\\\Qp value\\\\E|\\\\Qpadj\\\\E|^p$|^padj$", colnames(x))\n  if (length(whch) != 0) { digs[whch] = "pval" }\n  whch = grep("^Df$|^df$", colnames(x))\n  if (length(whch) != 0){ digs[whch] = 0 }\n  for(i in 1:length(digs)){\n    if(is.numeric(digs[i])) x[,i-1] <- round(x[,i-1], digits = digs[i])\n    if(digs[i]=="pval"){ \n      x[,i-1] <- sapply(x[,i-1],function(val){\n        ifelse(val < 10^-ndigitspvals & trim.pval,\n               paste0("<", 10^-ndigitspvals),\n               formatC(val, format = "f", digits = ndigitspvals))\n      })\n    }\n  }\n  return(x)\n}\n\n\n# function to capture currently active plot\n\ncaptureplot = function() {\n  current.device = dev.cur()\n  nm = names(current.device)[1L]\n  if(nm == "null device") stop("no device to print from")\n  if (dev.cur() == 1) \n    stop("no active graphics device found")\n  p = invisible(recordPlot())\n  p\n}\n\n\n# function to clip a value between an allowed range; x can be a single value, a vector or a matrix\n\nclip = function(x, a, b) {(a + (x-a > 0)*(x-a) - (x-b > 0)*(x-b))} \n\n\n# function that returns default ggplot colours for n groups\n\ngg_color_hue <- function(n,l=65,c=100) {\n  hues = seq(15, 375, length=n+1)\n  hcl(h=hues, l=l, c=c)[1:n]\n}\n\n\n# select rows from a dataframe mydata based on a list of selection conditions given \n# in a named list "selection"\n# e.g. \n# mydata=data.frame(group1=c(rep("MALE",6),rep("FEMALE",6)),group2=c(rep("TREATED",3),rep("UNTREATED",3)))\n# selection=list(group1="MALE",group2="TREATED")\n# selrows(mydata,selection)\n# 1 2 3\nselrows=function(mydata,selection) {\n  nms=names(selection)\n  sel=data.frame(matrix(TRUE,nrow=nrow(mydata),ncol=length(nms)))\n  for (i in 1:length(nms)) { sel[,i]=(mydata[,nms[[i]]]==selection[nms[[i]]][[1]]) }\n  which(apply(sel*1,1,prod)==1)\n}\n\n\n# Function to extract the slide size of a presentation from an XML (for PPT)\n# This is needed when using officer package\nget.slide.size <- function(doc, units="in"){\n  doc.xml <- doc$presentation$get()\n  nodes.xml<- xml_children(doc.xml)\n  ind <- which(grepl(sapply(nodes.xml, as.character), pattern = "sldSz"))\n  slide.size <- as.numeric(xml_attrs(nodes.xml[[ind]])[1:2])\n  fac <- ifelse(units == "cm", 360000, 360000 * 2.54 ) # fac = number of pixels per inch or cm\n  slide.size <- slide.size/fac\n  names(slide.size) <- c("width", "height")\n  return(slide.size)\n}\n\n\n# for a given graph width, height, page orientation and type\n# returns the best suited template\n# TO DO: maybe still add additional parameter "pageaspectr" to support A4, 16:9 or 4:3\nbesttemplate = function(w,h,margins = c(top=1,right=1,bottom=1,left=1),orient="auto",type="PPT") {\n  # size of A5 to A1 landscape PPT/DOC templates\n  landscA=list(c(8.27,5.83),c(11.7,8.27),c(16.5,11.7),c(23.4,16.5),c(33.1,23.4))\n  if (type=="PPT" ) { \n    landscA = lapply(landscA,function(x){\n      return(x-c(margins["left"]+margins["right"],margins["top"]+margins["bottom"]))\n    }) \n  }\n  if (type=="DOC") landscA=lapply(landscA,function(x) x-1)[1:3] # allow for 1 inch margins+DOC only supports A5, A4 and A3\n  sizes=(5:1)[1:length(landscA)]\n  portrA=lapply(landscA,rev) # size of A5 to A1 landscape PPT/DOC templates\n  #w=8.9;h=6.7;\n  if (orient=="auto") orient=ifelse(w>=h,"landscape","portrait")\n  bestpagesize=suppressWarnings(ifelse( orient=="landscape", \n                                        sizes[max( min(which(w<=unlist(lapply(landscA,head,n=1)))), \n                                                                        min(which(h<=unlist(lapply(landscA,tail,n=1)))) )],\n                                        sizes[max( min(which(w<=unlist(lapply(portrA,head,n=1)))),\n                                                   min(which(h<=unlist(lapply(portrA,tail,n=1)))) )] ))\n  if (is.na(bestpagesize)) bestpagesize=min(sizes)\n  return(paste0("A",bestpagesize,"_",orient)) \n}\n\n\n# Function that shuts down the newly opened devices to match a previous setup\n# if dev.old is NULL, all devices are clsed\ndev.reset <- function(dev.init = NULL) {\n  i <- dev.list()[!dev.list() %in% dev.init]\n  for (ii in i ) dev.off(ii)\n  return(NULL)\n}\n'