b'using System;\nusing System.Diagnostics;\nusing System.Runtime.InteropServices;\n\nusing Pgno = System.UInt32;\nusing i64 = System.Int64;\nusing u32 = System.UInt32;\nusing BITVEC_TELEM = System.Byte;\n\nnamespace CS_SQLite3\n{\n\n  public partial class CSSQLite\n  {\n    /*\n    ** 2008 February 16\n    **\n    ** The author disclaims copyright to this source code.  In place of\n    ** a legal notice, here is a blessing:\n    **\n    **    May you do good and not evil.\n    **    May you find forgiveness for yourself and forgive others.\n    **    May you share freely, never taking more than you give.\n    **\n    *************************************************************************\n    ** This file implements an object that represents a fixed-length\n    ** bitmap.  Bits are numbered starting with 1.\n    **\n    ** A bitmap is used to record which pages of a database file have been\n    ** journalled during a transaction, or which pages have the "dont-write"\n    ** property.  Usually only a few pages are meet either condition.\n    ** So the bitmap is usually sparse and has low cardinality.\n    ** But sometimes (for example when during a DROP of a large table) most\n    ** or all of the pages in a database can get journalled.  In those cases,\n    ** the bitmap becomes dense with high cardinality.  The algorithm needs\n    ** to handle both cases well.\n    **\n    ** The size of the bitmap is fixed when the object is created.\n    **\n    ** All bits are clear when the bitmap is created.  Individual bits\n    ** may be set or cleared one at a time.\n    **\n    ** Test operations are about 100 times more common that set operations.\n    ** Clear operations are exceedingly rare.  There are usually between\n    ** 5 and 500 set operations per Bitvec object, though the number of sets can\n    ** sometimes grow into tens of thousands or larger.  The size of the\n    ** Bitvec object is the number of pages in the database file at the\n    ** start of a transaction, and is thus usually less than a few thousand,\n    ** but can be as large as 2 billion for a really big database.\n    **\n    ** @(#) $Id: bitvec.c,v 1.17 2009/07/25 17:33:26 drh Exp $\n    **\n    *************************************************************************\n    **  Included in SQLite3 port to C#-SQLite;  2008 Noah B Hart\n    **  C#-SQLite is an independent reimplementation of the SQLite software library\n    **\n    **  $Header$\n    *************************************************************************\n    */\n    //#include "sqliteInt.h"\n\n    /* Size of the Bitvec structure in bytes. */\n    const int BITVEC_SZ = 512;\n\n    /* Round the union size down to the nearest pointer boundary, since that\'s how\n    ** it will be aligned within the Bitvec struct. */\n    //#define BITVEC_USIZE     (((BITVEC_SZ-(3*sizeof(u32)))/sizeof(Bitvec*))*sizeof(Bitvec*))\n    const int BITVEC_USIZE = ( ( ( BITVEC_SZ - ( 3 * sizeof( u32 ) ) ) / 4 ) * 4 );\n\n    /* Type of the array "element" for the bitmap representation.\n    ** Should be a power of 2, and ideally, evenly divide into BITVEC_USIZE.\n    ** Setting this to the "natural word" size of your CPU may improve\n    ** performance. */\n    //#define BITVEC_TELEM     u8\n    //using BITVEC_TELEM     = System.Byte;\n\n    /* Size, in bits, of the bitmap element. */\n    //#define BITVEC_SZELEM    8\n    const int BITVEC_SZELEM = 8;\n\n    /* Number of elements in a bitmap array. */\n    //#define BITVEC_NELEM     (BITVEC_USIZE/sizeof(BITVEC_TELEM))\n    const int BITVEC_NELEM = ( BITVEC_USIZE / sizeof( BITVEC_TELEM ) );\n\n    /* Number of bits in the bitmap array. */\n    //#define BITVEC_NBIT      (BITVEC_NELEM*BITVEC_SZELEM)\n    const int BITVEC_NBIT = ( BITVEC_NELEM * BITVEC_SZELEM );\n\n    /* Number of u32 values in hash table. */\n    //#define BITVEC_NINT      (BITVEC_USIZE/sizeof(u32))\n    const int BITVEC_NINT = ( BITVEC_USIZE / sizeof( u32 ) );\n\n    /* Maximum number of entries in hash table before\n    ** sub-dividing and re-hashing. */\n    //#define BITVEC_MXHASH    (BITVEC_NINT/2)\n    const int BITVEC_MXHASH = ( BITVEC_NINT / 2 );\n\n    /* Hashing function for the aHash representation.\n    ** Empirical testing showed that the *37 multiplier\n    ** (an arbitrary prime)in the hash function provided\n    ** no fewer collisions than the no-op *1. */\n    //#define BITVEC_HASH(X)   (((X)*1)%BITVEC_NINT)\n    static u32 BITVEC_HASH( u32 X ) { return ( ( ( X ) * 1 ) % BITVEC_NINT ); }\n\n    const int BITVEC_NPTR = ( BITVEC_USIZE / 4 );//sizeof(Bitvec *));\n\n\n    /*\n    ** A bitmap is an instance of the following structure.\n    **\n    ** This bitmap records the existence of zero or more bits\n    ** with values between 1 and iSize, inclusive.\n    **\n    ** There are three possible representations of the bitmap.\n    ** If iSize<=BITVEC_NBIT, then Bitvec.u.aBitmap[] is a straight\n    ** bitmap.  The least significant bit is bit 1.\n    **\n    ** If iSize>BITVEC_NBIT and iDivisor==0 then Bitvec.u.aHash[] is\n    ** a hash table that will hold up to BITVEC_MXHASH distinct values.\n    **\n    ** Otherwise, the value i is redirected into one of BITVEC_NPTR\n    ** sub-bitmaps pointed to by Bitvec.u.apSub[].  Each subbitmap\n    ** handles up to iDivisor separate values of i.  apSub[0] holds\n    ** values between 1 and iDivisor.  apSub[1] holds values between\n    ** iDivisor+1 and 2*iDivisor.  apSub[N] holds values between\n    ** N*iDivisor+1 and (N+1)*iDivisor.  Each subbitmap is normalized\n    ** to hold deal with values between 1 and iDivisor.\n    */\n    public class _u\n    {\n      public BITVEC_TELEM[] aBitmap = new byte[BITVEC_NELEM];   /* Bitmap representation */\n      public u32[] aHash = new u32[BITVEC_NINT];        /* Hash table representation */\n      public Bitvec[] apSub = new Bitvec[BITVEC_NPTR];  /* Recursive representation */\n    }\n    public class Bitvec\n    {\n      public u32 iSize;     /* Maximum bit index.  Max iSize is 4,294,967,296. */\n      public u32 nSet;      /* Number of bits that are set - only valid for aHash\n      ** element.  Max is BITVEC_NINT.  For BITVEC_SZ of 512,\n      ** this would be 125. */\n      public u32 iDivisor;  /* Number of bits handled by each apSub[] entry. */\n      /* Should >=0 for apSub element. */\n      /* Max iDivisor is max(u32) / BITVEC_NPTR + 1.  */\n      /* For a BITVEC_SZ of 512, this would be 34,359,739. */\n      public _u u = new _u();\n\n      public static implicit operator bool( Bitvec b )\n      {\n        return ( b != null );\n      }\n    };\n\n    /*\n    ** Create a new bitmap object able to handle bits between 0 and iSize,\n    ** inclusive.  Return a pointer to the new object.  Return NULL if\n    ** malloc fails.\n    */\n    static Bitvec sqlite3BitvecCreate( u32 iSize )\n    {\n      Bitvec p;\n      //Debug.Assert( sizeof(p)==BITVEC_SZ );\n      p = new Bitvec();//sqlite3MallocZero( sizeof(p) );\n      if ( p != null )\n      {\n        p.iSize = iSize;\n      }\n      return p;\n    }\n\n    /*\n    ** Check to see if the i-th bit is set.  Return true or false.\n    ** If p is NULL (if the bitmap has not been created) or if\n    ** i is out of range, then return false.\n    */\n    static int sqlite3BitvecTest( Bitvec p, u32 i )\n    {\n      if ( p == null || i == 0 ) return 0;\n      if ( i > p.iSize ) return 0;\n      i--;\n      while ( p.iDivisor != 0 )\n      {\n        u32 bin = i / p.iDivisor;\n        i = i % p.iDivisor;\n        p = p.u.apSub[bin];\n        if ( null == p )\n        {\n          return 0;\n        }\n      }\n      if ( p.iSize <= BITVEC_NBIT )\n      {\n        return ( ( p.u.aBitmap[i / BITVEC_SZELEM] & ( 1 << (int)( i & ( BITVEC_SZELEM - 1 ) ) ) ) != 0 ) ? 1 : 0;\n      }\n      else\n      {\n        u32 h = BITVEC_HASH( i++ );\n        while ( p.u.aHash[h] != 0 )\n        {\n          if ( p.u.aHash[h] == i ) return 1;\n          h = ( h + 1 ) % BITVEC_NINT;\n        }\n        return 0;\n      }\n    }\n\n    /*\n    ** Set the i-th bit.  Return 0 on success and an error code if\n    ** anything goes wrong.\n    **\n    ** This routine might cause sub-bitmaps to be allocated.  Failing\n    ** to get the memory needed to hold the sub-bitmap is the only\n    ** that can go wrong with an insert, assuming p and i are valid.\n    **\n    ** The calling function must ensure that p is a valid Bitvec object\n    ** and that the value for "i" is within range of the Bitvec object.\n    ** Otherwise the behavior is undefined.\n    */\n    static int sqlite3BitvecSet( Bitvec p, u32 i )\n    {\n      u32 h;\n      if ( p == null ) return SQLITE_OK;\n      Debug.Assert( i > 0 );\n      Debug.Assert( i <= p.iSize );\n      i--;\n      while ( ( p.iSize > BITVEC_NBIT ) && p.iDivisor != 0 )\n      {\n        u32 bin = i / p.iDivisor;\n        i = i % p.iDivisor;\n        if ( p.u.apSub[bin] == null )\n        {\n          p.u.apSub[bin] = sqlite3BitvecCreate( p.iDivisor );\n          if ( p.u.apSub[bin] == null ) return SQLITE_NOMEM;\n        }\n        p = p.u.apSub[bin];\n      }\n      if ( p.iSize <= BITVEC_NBIT )\n      {\n        p.u.aBitmap[i / BITVEC_SZELEM] |= (byte)( 1 << (int)( i & ( BITVEC_SZELEM - 1 ) ) );\n        return SQLITE_OK;\n      }\n      h = BITVEC_HASH( i++ );\n      /* if there wasn\'t a hash collision, and this doesn\'t */\n      /* completely fill the hash, then just add it without */\n      /* worring about sub-dividing and re-hashing. */\n      if ( 0 == p.u.aHash[h] )\n      {\n        if ( p.nSet < ( BITVEC_NINT - 1 ) )\n        {\n          goto bitvec_set_end;\n        }\n        else\n        {\n          goto bitvec_set_rehash;\n        }\n      }\n      /* there was a collision, check to see if it\'s already */\n      /* in hash, if not, try to find a spot for it */\n      do\n      {\n        if ( p.u.aHash[h] == i ) return SQLITE_OK;\n        h++;\n        if ( h >= BITVEC_NINT ) h = 0;\n      } while ( p.u.aHash[h] != 0 );\n/* we didn\'t find it in the hash.  h points to the first */\n/* available free spot. check to see if this is going to */\n/* make our hash too "full".  */\nbitvec_set_rehash:\n      if ( p.nSet >= BITVEC_MXHASH )\n      {\n        u32 j;\n        int rc;\n        u32[] aiValues = new u32[BITVEC_NINT];// = sqlite3StackAllocRaw(0, sizeof(p->u.aHash));\n        if ( aiValues == null )\n        {\n          return SQLITE_NOMEM;\n        }\n        else\n        {\n\n          Buffer.BlockCopy( p.u.aHash, 0, aiValues, 0, aiValues.Length * ( sizeof( u32 ) ) );// memcpy(aiValues, p->u.aHash, sizeof(p->u.aHash));\n          p.u.apSub = new Bitvec[BITVEC_NPTR];//memset(p->u.apSub, 0, sizeof(p->u.apSub));\n          p.iDivisor = ( p.iSize + BITVEC_NPTR - 1 ) / BITVEC_NPTR;\n          rc = sqlite3BitvecSet( p, i );\n          for ( j = 0 ; j < BITVEC_NINT ; j++ )\n          {\n            if ( aiValues[j] != 0 ) rc |= sqlite3BitvecSet( p, aiValues[j] );\n          }\n          //sqlite3StackFree( null, aiValues );\n          return rc;\n        }\n      }\nbitvec_set_end:\n      p.nSet++;\n      p.u.aHash[h] = i;\n      return SQLITE_OK;\n    }\n\n    /*\n    ** Clear the i-th bit.\n    **\n    ** pBuf must be a pointer to at least BITVEC_SZ bytes of temporary storage\n    ** that BitvecClear can use to rebuilt its hash table.\n    */\n    static void sqlite3BitvecClear( Bitvec p, u32 i, u32[] pBuf )\n    {\n      if ( p == null ) return; \n      Debug.Assert( i > 0 );\n      i--;\n      while ( p.iDivisor != 0 )\n      {\n        u32 bin = i / p.iDivisor;\n        i = i % p.iDivisor;\n        p = p.u.apSub[bin];\n        if ( null == p )\n        {\n          return;\n        }\n      }\n      if ( p.iSize <= BITVEC_NBIT )\n      {\n        p.u.aBitmap[i / BITVEC_SZELEM] &= (byte)~( ( 1 << (int)( i & ( BITVEC_SZELEM - 1 ) ) ) );\n      }\n      else\n      {\n        u32 j;\n        u32[] aiValues = pBuf;\n        Array.Copy( p.u.aHash, aiValues, p.u.aHash.Length );//memcpy(aiValues, p->u.aHash, sizeof(p->u.aHash));\n        p.u.aHash = new u32[aiValues.Length];// memset(p->u.aHash, 0, sizeof(p->u.aHash));\n        p.nSet = 0;\n        for ( j = 0 ; j < BITVEC_NINT ; j++ )\n        {\n          if ( aiValues[j] != 0 && aiValues[j] != ( i + 1 ) )\n          {\n            u32 h = BITVEC_HASH( aiValues[j] - 1 );\n            p.nSet++;\n            while ( p.u.aHash[h] != 0 )\n            {\n              h++;\n              if ( h >= BITVEC_NINT ) h = 0;\n            }\n            p.u.aHash[h] = aiValues[j];\n          }\n        }\n      }\n    }\n\n    /*\n    ** Destroy a bitmap object.  Reclaim all memory used.\n    */\n    static void sqlite3BitvecDestroy( ref Bitvec p )\n    {\n      if ( p == null ) return;\n      if ( p.iDivisor != 0 )\n      {\n        u32 i;\n        for ( i = 0 ; i < BITVEC_NPTR ; i++ )\n        {\n          sqlite3BitvecDestroy( ref p.u.apSub[i] );\n        }\n      }\n      //sqlite3_free( ref p );\n    }\n\n    /*\n    ** Return the value of the iSize parameter specified when Bitvec *p\n    ** was created.\n    */\n    static u32 sqlite3BitvecSize( Bitvec p )\n    {\n      return p.iSize;\n    }\n\n#if !SQLITE_OMIT_BUILTIN_TEST\n    /*\n** Let V[] be an array of unsigned characters sufficient to hold\n** up to N bits.  Let I be an integer between 0 and N.  0<=I<N.\n** Then the following macros can be used to set, clear, or test\n** individual bits within V.\n*/\n    //#define SETBIT(V,I)      V[I>>3] |= (1<<(I&7))\n    static void SETBIT( byte[] V, int I ) { V[I >> 3] |= (byte)( 1 << ( I & 7 ) ); }\n\n    //#define CLEARBIT(V,I)    V[I>>3] &= ~(1<<(I&7))\n    static void CLEARBIT( byte[] V, int I ) { V[I >> 3] &= (byte)~( 1 << ( I & 7 ) ); }\n\n    //#define TESTBIT(V,I)     (V[I>>3]&(1<<(I&7)))!=0\n    static int TESTBIT( byte[] V, int I ) { return ( V[I >> 3] & ( 1 << ( I & 7 ) ) ) != 0 ? 1 : 0; }\n\n    /*\n    ** This routine runs an extensive test of the Bitvec code.\n    **\n    ** The input is an array of integers that acts as a program\n    ** to test the Bitvec.  The integers are opcodes followed\n    ** by 0, 1, or 3 operands, depending on the opcode.  Another\n    ** opcode follows immediately after the last operand.\n    **\n    ** There are 6 opcodes numbered from 0 through 5.  0 is the\n    ** "halt" opcode and causes the test to end.\n    **\n    **    0          Halt and return the number of errors\n    **    1 N S X    Set N bits beginning with S and incrementing by X\n    **    2 N S X    Clear N bits beginning with S and incrementing by X\n    **    3 N        Set N randomly chosen bits\n    **    4 N        Clear N randomly chosen bits\n    **    5 N S X    Set N bits from S increment X in array only, not in bitvec\n    **\n    ** The opcodes 1 through 4 perform set and clear operations are performed\n    ** on both a Bitvec object and on a linear array of bits obtained from malloc.\n    ** Opcode 5 works on the linear array only, not on the Bitvec.\n    ** Opcode 5 is used to deliberately induce a fault in order to\n    ** confirm that error detection works.\n    **\n    ** At the conclusion of the test the linear array is compared\n    ** against the Bitvec object.  If there are any differences,\n    ** an error is returned.  If they are the same, zero is returned.\n    **\n    ** If a memory allocation error occurs, return -1.\n    */\n    static int sqlite3BitvecBuiltinTest( u32 sz, int[] aOp )\n    {\n      Bitvec pBitvec = null;\n      byte[] pV = null;\n      int rc = -1;\n      int i, nx, pc, op;\n      u32[] pTmpSpace;\n\n      /* Allocate the Bitvec to be tested and a linear array of\n      ** bits to act as the reference */\n      pBitvec = sqlite3BitvecCreate( sz );\n      pV = new byte[( sz + 7 ) / 8 + 1];// sqlite3_malloc( ( sz + 7 ) / 8 + 1 );\n      pTmpSpace = new u32[BITVEC_SZ];// sqlite3_malloc( BITVEC_SZ );\n      if ( pBitvec == null || pV == null || pTmpSpace == null ) goto bitvec_end;\n      Array.Clear( pV, 0, (int)( sz + 7 ) / 8 + 1 );// memset( pV, 0, ( sz + 7 ) / 8 + 1 );\n\n      /* NULL pBitvec tests */\n      sqlite3BitvecSet( null, (u32)1 );\n      sqlite3BitvecClear( null, 1, pTmpSpace );\n\n      /* Run the program */\n      pc = 0;\n      while ( ( op = aOp[pc] ) != 0 )\n      {\n        switch ( op )\n        {\n          case 1:\n          case 2:\n          case 5:\n            {\n              nx = 4;\n              i = aOp[pc + 2] - 1;\n              aOp[pc + 2] += aOp[pc + 3];\n              break;\n            }\n          case 3:\n          case 4:\n          default:\n            {\n              nx = 2;\n              i64 i64Temp = 0;\n              sqlite3_randomness( sizeof( i64 ), ref i64Temp );\n              i = (int)i64Temp;\n              break;\n            }\n        }\n        if ( ( --aOp[pc + 1] ) > 0 ) nx = 0;\n        pc += nx;\n        i = (int)( ( i & 0x7fffffff ) % sz );\n        if ( ( op & 1 ) != 0 )\n        {\n          SETBIT( pV, ( i + 1 ) );\n          if ( op != 5 )\n          {\n            if ( sqlite3BitvecSet( pBitvec, (u32)i + 1 ) != 0 ) goto bitvec_end;\n          }\n        }\n        else\n        {\n          CLEARBIT( pV, ( i + 1 ) );\n          sqlite3BitvecClear( pBitvec, (u32)i + 1, pTmpSpace );\n        }\n      }\n\n      /* Test to make sure the linear array exactly matches the\n      ** Bitvec object.  Start with the assumption that they do\n      ** match (rc==0).  Change rc to non-zero if a discrepancy\n      ** is found.\n      */\n      rc = sqlite3BitvecTest( null, 0 ) + sqlite3BitvecTest( pBitvec, sz + 1 )\n      + sqlite3BitvecTest( pBitvec, 0 )\n      + (int)( sqlite3BitvecSize( pBitvec ) - sz );\n      for ( i = 1 ; i <= sz ; i++ )\n      {\n        if ( ( TESTBIT( pV, i ) ) != sqlite3BitvecTest( pBitvec, (u32)i ) )\n        {\n          rc = i;\n          break;\n        }\n      }\n\n          /* Free allocated structure */\nbitvec_end:\n      //sqlite3_free( ref pTmpSpace );\n      //sqlite3_free( ref pV );\n      sqlite3BitvecDestroy( ref pBitvec );\n      return rc;\n    }\n#endif //* SQLITE_OMIT_BUILTIN_TEST */\n  }\n}\n'