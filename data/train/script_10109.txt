b'{-# LANGUAGE RankNTypes, NamedFieldPuns, BangPatterns,\n             ExistentialQuantification, CPP, ScopedTypeVariables,\n             TypeSynonymInstances, MultiParamTypeClasses,\n             GeneralizedNewtypeDeriving, PackageImports,\n             ParallelListComp #-}\n\n\n{- OPTIONS_GHC -Wall -fno-warn-name-shadowing -fno-warn-unused-do-bind -}\n\n-- {- LANGUAGE Trustworthy -}\n-- TODO: Before declaring this module TRUSTWORTHY/SAFE, we need to\n-- make the IVar type abstract.\n\n{-# LANGUAGE TypeFamilies #-}\n\n-- | A scheduler for the Par monad based on directly performing IO\n-- actions when Par methods are called (i.e. without using a lazy\n-- trace data structure).\n\nmodule Control.Monad.Par.Scheds.Direct (\n   Sched(..),\n   Par, -- abstract: Constructor not exported.\n   IVar(..), IVarContents(..),\n--    sched,\n    runPar, runParIO,\n    new, get, put_, fork,\n    newFull, newFull_, put,\n    spawn, spawn_, spawnP,\n    spawn1_, fixPar, FixParException (..)\n--   runParAsync, runParAsyncHelper,\n--   yield,\n ) where\n\nimport Control.Applicative\nimport Control.Concurrent hiding (yield)\nimport Data.IORef         (IORef,newIORef,readIORef,writeIORef,atomicModifyIORef)\nimport Text.Printf        (printf)\nimport GHC.Conc           (numCapabilities,yield)\nimport           "mtl" Control.Monad.Cont as C\nimport qualified "mtl" Control.Monad.Reader as RD\nimport qualified       System.Random.MWC as Random\nimport                 System.IO.Unsafe (unsafePerformIO)\nimport                 System.Mem.StableName (makeStableName, hashStableName)\nimport qualified       Control.Monad.Par.Class  as PC\nimport qualified       Control.Monad.Par.Unsafe as UN\nimport                 Control.Monad.Par.Scheds.DirectInternal\n                       (Par(..), Sched(..), HotVar, SessionID, Session(Session),\n                        newHotVar, readHotVar, modifyHotVar, modifyHotVar_,\n                        writeHotVarRaw, fixPar, FixParException (..))\n#ifdef NEW_GENERIC\nimport qualified       Control.Par.Class as PN\nimport qualified       Control.Par.Class.Unsafe as PU\n#endif\nimport Control.DeepSeq\n#ifdef NESTED_SCHEDS\nimport qualified Data.Map as M\n#endif\nimport qualified Data.Set as S\nimport Data.Maybe (catMaybes)\nimport Data.Word (Word64)\n\n-- import Data.Concurrent.Deque.Class (WSDeque)\n#ifdef USE_CHASELEV\n#warning "Note: using Chase-Lev lockfree workstealing deques..."\nimport Data.Concurrent.Deque.ChaseLev.DequeInstance\nimport Data.Concurrent.Deque.ChaseLev as R\n#else\nimport Data.Concurrent.Deque.Reference.DequeInstance\nimport Data.Concurrent.Deque.Reference as R\n#endif\n\nimport qualified Control.Exception as E\n\nimport Prelude hiding (null)\nimport qualified Prelude\n\n#if __GLASGOW_HASKELL__ <= 700\nimport GHC.Conc (forkOnIO)\nforkOn = forkOnIO\n#endif\n\n--------------------------------------------------------------------------------\n-- Configuration Toggles\n--------------------------------------------------------------------------------\n\n-- [2012.08.30] This shows a 10X improvement on nested parfib:\n-- #define NESTED_SCHEDS\n#define PARPUTS\n#define FORKPARENT\n#define IDLING_ON\n   -- Next, IF idling is on, should we do wakeups?:\n#define WAKEIDLE\n\n-- #define WAIT_FOR_WORKERS\n\n-------------------------------------------------------------------\n-- Ifdefs for the above preprocessor defines.  Try to MINIMIZE code\n-- that lives in this dangerous region, and instead do normal\n-- conditionals and trust dead-code-elimination.\n--------------------------------------------------------------------\n\n#ifdef DEBUG_DIRECT\n#warning "DEBUG: Activating debugging for Direct.hs"\nimport Debug.Trace        (trace)\nimport System.Environment (getEnvironment)\ntheEnv = unsafePerformIO $ getEnvironment\ndbg = True\ndbglvl = 1\n#else\ndbg = False\ndbglvl = 0\n#endif\ndbg    :: Bool\ndbglvl :: Int\n\n_PARPUTS :: Bool\n#ifdef PARPUTS\n_PARPUTS = True\n#else\n_PARPUTS = False\n#endif\n\n_FORKPARENT :: Bool\n#ifdef FORKPARENT\n_FORKPARENT = True\n#else\n#warning "FORKPARENT POLICY NOT USED; THIS IS GENERALLY WORSE"\n_FORKPARENT = False\n#endif\n\n_IDLING_ON :: Bool\n#ifdef IDLING_ON\n_IDLING_ON = True\n#else\n_IDLING_ON = False\n#endif\n\n_WAIT_FOR_WORKERS :: Bool\n#ifdef WAIT_FOR_WORKERS\n_WAIT_FOR_WORKERS = True\n#else\n_WAIT_FOR_WORKERS = False\n#endif\n\n\n\n--------------------------------------------------------------------------------\n-- Core type definitions\n--------------------------------------------------------------------------------\n\ntype ROnly = RD.ReaderT Sched IO\n\nnewtype IVar a = IVar (IORef (IVarContents a))\n\ndata IVarContents a = Full a | Empty | Blocked [a -> IO ()]\n\nunsafeParIO :: IO a -> Par a\nunsafeParIO iom = Par (lift$ lift iom)\n\nio :: IO a -> Par a\nio = unsafeParIO -- shorthand used below\n\n--------------------------------------------------------------------------------\n-- Global State\n--------------------------------------------------------------------------------\n\n-- This keeps track of ALL worker threads across all unreated\n-- `runPar` instantiations.  This is used to detect nested invocations\n-- of `runPar` and avoid reinitialization.\n-- globalWorkerPool :: IORef (Data.IntMap ())\n#ifdef NESTED_SCHEDS\nglobalWorkerPool :: IORef (M.Map ThreadId Sched)\nglobalWorkerPool = unsafePerformIO $ newIORef M.empty\n#endif\n-- TODO! Make this semi-local! (not shared between "top-level" runPars)\n\n{-# INLINE amINested #-}\n{-# INLINE registerWorker #-}\n{-# INLINE unregisterWorker #-}\namINested :: ThreadId -> IO (Maybe Sched)\nregisterWorker :: ThreadId -> Sched -> IO ()\nunregisterWorker :: ThreadId -> IO ()\n#ifdef NESTED_SCHEDS\n-- | If the current threadID is ALREADY a worker, return the corresponding Sched structure.\namINested tid = do\n  -- There is no race here.  Each thread inserts itself before it\n  -- becomes an active worker.\n  wp <- readIORef globalWorkerPool\n  return (M.lookup tid wp)\nregisterWorker tid sched =\n  atomicModifyIORef globalWorkerPool $\n    \\ mp -> (M.insert tid sched mp, ())\nunregisterWorker tid =\n  atomicModifyIORef globalWorkerPool $\n    \\ mp -> (M.delete tid mp, ())\n#else\namINested      _      = return Nothing\nregisterWorker _ _    = return ()\nunregisterWorker _tid = return ()\n#endif\n\n-----------------------------------------------------------------------------\n-- Helpers #2:  Pushing and popping work.\n-----------------------------------------------------------------------------\n\n{-# INLINE popWork  #-}\npopWork :: Sched -> IO (Maybe (Par ()))\npopWork Sched{ workpool, no } = do\n  mb <- R.tryPopL workpool\n  when dbg $ case mb of\n         Nothing -> return ()\n         Just _  -> do sn <- makeStableName mb\n                       printf " [%d]                                   -> POP work unit %d\\n" no (hashStableName sn)\n  return mb\n\n{-# INLINE pushWork #-}\npushWork :: Sched -> Par () -> IO ()\npushWork Sched { workpool, idle, no } task = do\n  R.pushL workpool task\n  when dbg $ do sn <- makeStableName task\n                printf " [%d]                                   -> PUSH work unit %d\\n" no (hashStableName sn)\n#if  defined(IDLING_ON) && defined(WAKEIDLE)\n  --when isMain$    -- Experimenting with reducing contention by doing this only from a single thread.\n                    -- TODO: We need to have a proper binary wakeup-tree.\n  tryWakeIdle idle\n#endif\n  return ()\n\ntryWakeIdle :: HotVar [MVar Bool] -> IO ()\ntryWakeIdle idle = do\n-- NOTE: I worry about having the idle var hammered by all threads on their spawn-path:\n  -- If any worker is idle, wake one up and give it work to do.\n  idles <- readHotVar idle -- Optimistically do a normal read first.\n  when (not (Prelude.null idles)) $ do\n    when dbg$ printf "Waking %d idle thread(s).\\n" (length idles)\n    r <- modifyHotVar idle (\\is -> case is of\n                             []      -> ([], return ())\n                             (i:ils) -> (ils, putMVar i False))\n    r -- wake an idle worker up by putting an MVar.\n\nrand :: HotVar Random.GenIO -> IO Int\nrand ref = Random.uniformR (0, numCapabilities-1) =<< readHotVar ref\n\n--------------------------------------------------------------------------------\n-- Running computations in the Par monad\n--------------------------------------------------------------------------------\n\ninstance NFData (IVar a) where\n  rnf !_ = ()\n\n{-# NOINLINE runPar #-}\nrunPar = unsafePerformIO . runParIO\n\n\n-- | This procedure creates a new worker on the current thread (with a\n--   new session ID) and plugs it into the work-stealing environment.\n--   This new worker extracts itself from the work stealing pool when\n--   `userComp` has completed, thus freeing the current thread (this\n--   procedure) to return normally.\nrunNewSessionAndWait :: String -> Sched -> Par b -> IO b\nrunNewSessionAndWait name sched userComp = do\n    tid <- myThreadId -- TODO: remove when done debugging\n    sid <- modifyHotVar (sessionCounter sched) (\\ x -> (x+1,x))\n    _ <- modifyHotVar (activeSessions sched) (\\ set -> (S.insert sid set, ()))\n\n    -- Here we have an extra IORef... ugly.\n    ref <- newIORef (error$ "Empty session-result ref ("++name++") should never be touched (sid "++ show sid++", "++show tid ++")")\n    newFlag <- newHotVar False\n    -- Push the new session:\n    _ <- modifyHotVar (sessions sched) (\\ ls -> ((Session sid newFlag) : ls, ()))\n\n    let userComp\' = do when dbg$ io$ do\n                           tid2 <- myThreadId\n                           printf " [%d %s] Starting Par computation on %s.\\n" (no sched) (show tid2) name\n                       ans <- userComp\n                       -- This add-on to userComp will run only after userComp has completed successfully,\n                       -- but that does NOT guarantee that userComp-forked computations have terminated:\n                       io$ do when (dbglvl>=1) $ do\n                                tid3 <- myThreadId\n                                printf " [%d %s] Continuation for %s called, finishing it up (%d)...\\n" (no sched) (show tid3) name sid\n                              writeIORef ref ans\n                              writeHotVarRaw newFlag True\n                              modifyHotVar (activeSessions sched) (\\ set -> (S.delete sid set, ()))\n        kont :: Word64 -> a -> ROnly ()\n        kont n = trivialCont$ "("++name++", sid "++show sid++", round "++show n++")"\n        loop :: Word64 -> ROnly ()\n        loop n = do flg <- liftIO$ readIORef newFlag\n                    unless flg $ do\n                      when dbg $ liftIO$ do\n                        tid4 <- myThreadId\n                        printf " [%d %s] BOUNCE %d... going into reschedule until finished.\\n" (no sched) (show tid4) n\n                      rescheduleR 0 $ trivialCont$ "("++name++", sid "++show sid++")"\n                      loop (n+1)\n\n    -- THIS IS RETURNING TOO EARLY!!:\n    runReaderWith sched (C.runContT (unPar userComp\') (kont 0))  -- Does this ASSUME child stealing?\n    runReaderWith sched (loop 1)\n\n    -- TODO: Ideally we would wait for ALL outstanding (stolen) work on this "team" to complete.\n\n    when (dbglvl>=1)$ do\n      active <- readHotVar (activeSessions sched)\n      sess@True <- readHotVar newFlag -- ASSERT!\n      printf " [%d %s] RETURN from %s (sessFin %s) runContT (%d) active set %s\\n"\n               (no sched) (show tid) name (show sess) sid (show active)\n\n    -- Here we pop off the frame we added to the session stack:\n    modifyHotVar_ (sessions sched) $ \\ (Session sid2 _ : tl) ->\n        if sid == sid2\n        then tl\n        else error$ "Tried to pop the session stack and found we ("++show sid\n                   ++") were not on the top! (instead "++show sid2++")"\n\n    -- By returning here we ARE implicitly reengaging the scheduler, since we\n    -- are already inside the rescheduleR loop on this thread\n    -- (before runParIO was called in a nested fashion).\n    readIORef ref\n\n\n{-# NOINLINE runParIO #-}\nrunParIO userComp = do\n   tid <- myThreadId\n#if __GLASGOW_HASKELL__ >= 701 /* 20110301 */\n    --\n    -- We create a thread on each CPU with forkOn.  The CPU on which\n    -- the current thread is running will host the main thread; the\n    -- other CPUs will host worker threads.\n    --\n    -- Note: GHC 7.1.20110301 is required for this to work, because that\n    -- is when threadCapability was added.\n    --\n   (main_cpu, _) <- threadCapability tid\n#else\n    --\n    -- Lacking threadCapability, we always pick CPU #0 to run the main\n    -- thread.  If the current thread is not running on CPU #0, this\n    -- will require some data to be shipped over the memory bus, and\n    -- hence will be slightly slower than the version above.\n    --\n   let main_cpu = 0\n#endif\n   maybSched <- amINested tid\n   tidorig <- myThreadId -- TODO: remove when done debugging\n   case maybSched of\n     Just (sched) -> do\n       -- Here the current thread is ALREADY a worker.  All we need to\n       -- do is plug the users new computation in.\n\n       sid0 <- readHotVar (sessionCounter sched)\n       when (dbglvl>=1)$ printf " [%d %s] runPar called from existing worker thread, new session (%d)....\\n" (no sched) (show tid) (sid0 + 1)\n       runNewSessionAndWait "nested runPar" sched userComp\n\n     ------------------------------------------------------------\n     -- Non-nested case, make a new set of worker threads:\n     ------------------------------------------------------------\n     Nothing -> do\n       allscheds <- makeScheds main_cpu\n       [Session _ topSessFlag] <- readHotVar$ sessions$ head allscheds\n\n       mfin <- newEmptyMVar\n       doneFlags <- forM (zip [0..] allscheds) $ \\(cpu,sched) -> do\n            workerDone <- newEmptyMVar\n            ----------------------------------------\n            let wname = ("(worker "++show cpu++" of originator "++show tidorig++")")\n--            forkOn cpu $ do\n            _ <- forkWithExceptions (forkOn cpu) wname $ do\n            ------------------------------------------------------------STRT WORKER THREAD\n              tid2 <- myThreadId\n              registerWorker tid2 sched\n              if (cpu /= main_cpu)\n                 then do when dbg$ printf " [%d %s] Anonymous worker entering scheduling loop.\\n" cpu (show tid2)\n                         runReaderWith sched $ rescheduleR 0 (trivialCont (wname++show tid2))\n                         when dbg$ printf " [%d] Anonymous worker exited scheduling loop.  FINISHED.\\n" cpu\n                         putMVar workerDone cpu\n                         return ()\n                 else do x <- runNewSessionAndWait "top-lvl main worker" sched userComp\n                         -- When the main worker finishes we can tell the anonymous "system" workers:\n                         writeIORef topSessFlag True\n                         when dbg$ do printf " *** Out of entire runContT user computation on main thread %s.\\n" (show tid2)\n                         --  sanityCheck allscheds\n                         putMVar mfin x\n\n              unregisterWorker tid\n            ------------------------------------------------------------END WORKER THREAD\n            return (if cpu == main_cpu then Nothing else Just workerDone)\n\n       when _WAIT_FOR_WORKERS $ do\n           when dbg$ printf " *** [%s] Originator thread: waiting for workers to complete." (show tidorig)\n           forM_ (catMaybes doneFlags) $ \\ mv -> do\n             n <- readMVar mv\n    --         n <- A.wait mv\n             when dbg$ printf "   * [%s]  Worker %s completed\\n" (show tidorig) (show n)\n\n       when dbg$ do printf " *** [%s] Reading final MVar on originator thread.\\n" (show tidorig)\n       -- We don\'t directly use the thread we come in on.  Rather, that thread waits\n       -- waits.  One reason for this is that the main/progenitor thread in\n       -- GHC is expensive like a forkOS thread.\n       ----------------------------------------\n       --              DEBUGGING             --\n#ifdef DEBUG_DIRECT\n       busyTakeMVar (" The global wait "++ show tidorig) mfin -- Final value.\n--       dbgTakeMVar "global waiting thread" mfin -- Final value.\n#else\n       takeMVar mfin -- Final value.\n#endif\n       ----------------------------------------\n\n-- Create the default scheduler(s) state:\nmakeScheds :: Int -> IO [Sched]\nmakeScheds main = do\n   when dbg$ do tid <- myThreadId\n                printf "[initialization] Creating %d worker threads, currently on %s\\n" numCapabilities (show tid)\n   workpools <- replicateM numCapabilities $ R.newQ\n   rngs      <- replicateM numCapabilities $ Random.create >>= newHotVar\n   idle      <- newHotVar []\n   -- The STACKs are per-worker.. but the root finished flag is shared between all anonymous system workers:\n   sessionFinished <- newHotVar False\n   sessionStacks   <- mapM newHotVar (replicate numCapabilities [Session baseSessionID sessionFinished])\n   activeSessions  <- newHotVar S.empty\n   sessionCounter  <- newHotVar (baseSessionID + 1)\n   let allscheds = [ Sched { no=x, idle, isMain= (x==main),\n                             workpool=wp, scheds=allscheds, rng=rng,\n                             sessions = stck,\n                             activeSessions=activeSessions,\n                             sessionCounter=sessionCounter\n                           }\n                   --  | (x,wp,rng,stck) <- zip4 [0..] workpools rngs sessionStacks\n                   | x   <- [0 .. numCapabilities-1]\n                   | wp  <- workpools\n                   | rng <- rngs\n                   | stck <- sessionStacks\n                   ]\n   return allscheds\n\n\n-- The ID of top-level runPar sessions.\nbaseSessionID :: SessionID\nbaseSessionID = 1000\n\n\n--------------------------------------------------------------------------------\n-- IVar operations\n--------------------------------------------------------------------------------\n\n{-# INLINE new  #-}\n-- | Creates a new @IVar@\nnew :: Par (IVar a)\nnew  = io$ do r <- newIORef Empty\n              return (IVar r)\n\n{-# INLINE get  #-}\n-- | Read the value in an @IVar@.  The \'get\' operation can only return when the\n-- value has been written by a prior or parallel @put@ to the same\n-- @IVar@.\nget (IVar vr) =  do\n  callCC $ \\kont ->\n    do\n       e  <- io$ readIORef vr\n       case e of\n          Full a -> return a\n          _ -> do\n            sch <- RD.ask\n#  ifdef DEBUG_DIRECT\n            sn <- io$ makeStableName vr  -- Should probably do the MutVar inside...\n            let resched = trace (" ["++ show (no sch) ++ "]  - Rescheduling on unavailable ivar "++show (hashStableName sn)++"!")\n#else\n            let resched =\n#  endif\n                          longjmpSched -- Invariant: kont must not be lost.\n            -- Because we continue on the same processor the Sched stays the same:\n            -- TODO: Try NOT using monadic values as first class.  Check for performance effect:\n            r <- io$ atomicModifyIORef vr $ \\x -> case x of\n                      Empty      -> (Blocked [pushWork sch . kont], resched)\n                      Full a     -> (Full a, return a) -- kont is implicit here.\n                      Blocked ks -> (Blocked (pushWork sch . kont:ks), resched)\n            r\n\n-- | NOTE unsafePeek is NOT exposed directly through this module.  (So\n-- this module remains SAFE in the Safe Haskell sense.)  It can only\n-- be accessed by importing Control.Monad.Par.Unsafe.\n{-# INLINE unsafePeek #-}\nunsafePeek :: IVar a -> Par (Maybe a)\nunsafePeek (IVar v) = do\n  e  <- io$ readIORef v\n  case e of\n    Full a -> return (Just a)\n    _      -> return Nothing\n\n------------------------------------------------------------\n{-# INLINE put_ #-}\n-- | @put_@ is a version of @put@ that is head-strict rather than fully-strict.\n--   In this scheduler, puts immediately execute woken work in the current thread.\nput_ (IVar vr) !content = do\n   sched <- RD.ask\n   ks <- io$ do\n      ks <- atomicModifyIORef vr $ \\e -> case e of\n               Empty      -> (Full content, [])\n               Full _     -> error "multiple put"\n               Blocked ks -> (Full content, ks)\n#ifdef DEBUG_DIRECT\n      when (dbglvl >=  3) $ do\n         sn <- makeStableName vr\n         printf " [%d] Put value %s into IVar %d.  Waking up %d continuations.\\n"\n                (no sched) (show content) (hashStableName sn) (length ks)\n         return ()\n#endif\n      return ks\n   wakeUp sched ks content\n\n-- | NOTE unsafeTryPut is NOT exposed directly through this module.  (So\n-- this module remains SAFE in the Safe Haskell sense.)  It can only\n-- be accessed by importing Control.Monad.Par.Unsafe.\n{-# INLINE unsafeTryPut #-}\nunsafeTryPut (IVar vr) !content = do\n   -- Head strict rather than fully strict.\n   sched <- RD.ask\n   (ks,res) <- io$ do\n      pr <- atomicModifyIORef vr $ \\e -> case e of\n                   Empty      -> (Full content, ([], content))\n                   Full x     -> (Full x, ([], x))\n                   Blocked ks -> (Full content, (ks, content))\n#ifdef DEBUG_DIRECT\n      sn <- makeStableName vr\n      printf " [%d] unsafeTryPut: value %s in IVar %d.  Waking up %d continuations.\\n"\n             (no sched) (show content) (hashStableName sn) (length (fst pr))\n#endif\n      return pr\n   wakeUp sched ks content\n   return res\n\n-- | When an IVar is filled in, continuations wake up.\n{-# INLINE wakeUp #-}\nwakeUp :: Sched -> [a -> IO ()]-> a -> Par ()\nwakeUp _sched ks arg = loop ks\n where\n   loop [] = return ()\n   loop (kont:rest) = do\n     -- FIXME -- without strict firewalls keeping ivars from moving\n     -- between runPar sessions, if we allow nested scheduler use\n     -- we could potentially wake up work belonging to a different\n     -- runPar and thus bring it into our worker and delay our own\n     -- continuation until its completion.\n     if _PARPUTS then\n       -- We do NOT force the putting thread to postpone its continuation.\n       do _ <- spawn_$ pMap kont rest\n          return ()\n       -- case rest of\n       --   [] -> spawn_$ io$ kont arg\n       --   _  -> spawn_$ do spawn_$ io$ kont arg\n       --                    io$ parchain rest\n       -- error$"FINISHME - wake "++show (length ks)++" conts"\n      else\n       -- This version sacrifices a parallelism opportunity and\n       -- imposes additional serialization.\n       --\n       -- [2012.08.31] WARNING -- this serialzation CAN cause deadlock.\n       -- This "optimization" should not be on the table.\n       -- mapM_ ($arg) ks\n       do io$ kont arg\n          loop rest\n     return ()\n\n   pMap kont [] = io$ kont arg\n   pMap kont (more:rest) =\n     do _ <- spawn_$ io$ kont arg\n        pMap more rest\n\n   -- parchain [kont] = kont arg\n   -- parchain (kont:rest) = do spawn$ io$ kont arg\n   --                           parchain rest\n\n\n------------------------------------------------------------\n{-# INLINE fork #-}\nfork :: Par () -> Par ()\nfork task =\n  -- Forking the "parent" means offering up the continuation of the\n  -- fork rather than the task argument for stealing:\n  case _FORKPARENT of\n    True -> do\n      sched <- RD.ask\n      callCC$ \\parent -> do\n         let wrapped = parent ()\n         io$ pushWork sched wrapped\n         -- Then execute the child task and return to the scheduler when it is complete:\n         task\n         -- If we get to this point we have finished the child task:\n         _ <- longjmpSched -- We reschedule to pop the cont we pushed.\n         -- TODO... OPTIMIZATION: we could also try the pop directly, and if it succeeds return normally....\n         io$ printf " !!! ERROR: Should never reach this point #1\\n"\n\n      when dbg$ do\n       sched2 <- RD.ask\n       io$ printf "  -  called parent continuation... was on worker [%d] now on worker [%d]\\n" (no sched) (no sched2)\n       return ()\n\n    False -> do\n      sch <- RD.ask\n      when dbg$ io$ printf " [%d] forking task...\\n" (no sch)\n      io$ pushWork sch task\n\n-- This routine "longjmp"s to the scheduler, throwing out its own continuation.\nlongjmpSched :: Par a\n-- longjmpSched = Par $ C.ContT rescheduleR\nlongjmpSched = Par $ C.ContT (\\ _k -> rescheduleR 0 (trivialCont "longjmpSched"))\n\n-- Reschedule the scheduler loop until it observes sessionFinished==True, and\n-- then it finally invokes its continuation.\nrescheduleR :: Word64 -> (a -> ROnly ()) -> ROnly ()\nrescheduleR cnt kont = do\n  mysched <- RD.ask\n  when dbg$ liftIO$ do tid <- myThreadId\n                       sess <- readSessions mysched\n                       null <- R.nullQ (workpool mysched)\n                       printf " [%d %s]  - Reschedule #%d... sessions %s, pool empty %s\\n"\n                              (no mysched) (show tid) cnt (show sess) (show null)\n  mtask  <- liftIO$ popWork mysched\n  case mtask of\n    Nothing -> do\n                  (Session _ finRef):_ <- liftIO$ readIORef $ sessions mysched\n                  fin <- liftIO$ readIORef finRef\n                  if fin\n                   then do when (dbglvl >= 1) $ liftIO $ do\n                             tid <- myThreadId\n                             sess <- readSessions mysched\n                             printf " [%d %s]  - DROP out of reschedule loop, sessionFinished=%s, all sessions %s\\n"\n                                    (no mysched) (show tid) (show fin) (show sess)\n                             empt <- R.nullQ$ workpool mysched\n                             when (not empt) $ do\n                               printf " [%d %s] - WARNING - leaving rescheduleR while local workpoll is nonempty\\n"\n                                      (no mysched) (show tid)\n\n                           kont (error "Direct.hs: The result value from rescheduleR should not be used.")\n                   else do\n                     -- when (dbglvl >= 1) $ liftIO $ do\n                     --     tid <- myThreadId\n                     --     sess <- readSessions mysched\n                     --     printf " [%d %s]  -    Apparently NOT finished with head session... trying to steal, all sessions %s\\n"\n                     --            (no mysched) (show tid) (show sess)\n                     liftIO$ steal mysched\n#ifdef WAKEIDLE\n--                     io$ tryWakeIdle (idle mysched)\n#endif\n                     liftIO yield\n                     rescheduleR (cnt+1) kont\n    Just task -> do\n       -- When popping work from our own queue the Sched (Reader value) stays the same:\n       when dbg $ do sn <- liftIO$ makeStableName task\n                     liftIO$ printf " [%d] popped work %d from own queue\\n" (no mysched) (hashStableName sn)\n       let C.ContT fn = unPar task\n       -- Run the stolen task with a continuation that returns to the scheduler if the task exits normally:\n       fn (\\ _ -> do\n           sch <- RD.ask\n           when dbg$ liftIO$ printf "  + task finished successfully on cpu %d, calling reschedule continuation..\\n" (no sch)\n           rescheduleR 0 kont)\n\n\n-- | Attempt to steal work or, failing that, give up and go idle.\n--\n--   The current policy is to do a burst of of N tries without\n--   yielding or pausing in between.\nsteal :: Sched -> IO ()\nsteal mysched@Sched{ idle, scheds, rng, no=my_no } = do\n  when (dbglvl>=2)$ do tid <- myThreadId\n                       printf " [%d %s]  + stealing\\n" my_no (show tid)\n  i <- getnext (-1 :: Int)\n  go maxtries i\n where\n--    maxtries = numCapabilities -- How many times should we attempt theft before going idle?\n    maxtries = 20 * numCapabilities -- How many times should we attempt theft before going idle?\n\n    getnext _ = rand rng\n\n    ----------------------------------------\n    -- IDLING behavior:\n    go 0 _ | _IDLING_ON =\n            do m <- newEmptyMVar\n               r <- modifyHotVar idle $ \\is -> (m:is, is)\n               if length r == numCapabilities - 1\n                  then do\n                     when dbg$ printf " [%d]  | waking up all threads\\n" my_no\n                     writeHotVarRaw idle []\n                     mapM_ (\\vr -> putMVar vr True) r\n                  else do\n                    (Session _ finRef):_ <- readIORef $ sessions mysched\n                    fin <- readIORef finRef\n                    done <- if fin then pure True else takeMVar m\n                    if done\n                       then do\n                         when dbg$ printf " [%d]  | shutting down\\n" my_no\n                         return ()\n                       else do\n                         when dbg$ printf " [%d]  | woken up\\n" my_no\n                         i <- getnext (-1::Int)\n                         go maxtries i\n\n    -- We need to return from this loop to check sessionFinished and exit the scheduler if necessary.\n    go 0 _i | _IDLING_ON == False = yield\n\n    ----------------------------------------\n    go tries i\n      | i == my_no = do i\' <- getnext i\n                        go (tries-1) i\'\n\n      | otherwise     = do\n         -- We ONLY go through the global sched array to access victims:\n         let schd = scheds!!i\n         when (dbglvl>=2)$ printf " [%d]  | trying steal from %d\\n" my_no (no schd)\n\n--         let dq = workpool schd :: WSDeque (Par ())\n         let dq = workpool schd\n         r <- R.tryPopR dq\n\n         case r of\n           Just task  -> do\n              when dbg$ do sn <- makeStableName task\n                           printf " [%d]  | stole work (unit %d) from cpu %d\\n" my_no (hashStableName sn) (no schd)\n              runReaderWith mysched $\n                C.runContT (unPar task)\n                 (\\_ -> do\n                   when dbg$ do sn <- liftIO$ makeStableName task\n                                liftIO$ printf " [%d]  | DONE running stolen work (unit %d) from %d\\n" my_no (hashStableName sn) (no schd)\n                   return ())\n\n           Nothing -> do i\' <- getnext i\n                         go (tries-1) i\'\n\n-- | The continuation which should not be called.\n_errK :: t\n_errK = error "Error cont: this closure shouldn\'t be used"\n\ntrivialCont :: String -> a -> ROnly ()\n#ifdef DEBUG_DIRECT\ntrivialCont str _ = do\n--                trace (str ++" trivialCont evaluated!")\n                liftIO$ printf " !! trivialCont evaluated, msg: %s\\n" str\n#else\ntrivialCont _str _ = do\n#endif\n                return ()\n\n----------------------------------------------------------------------------------------------------\n\n\n--------------------------------------------------------------------------------\n-- <boilerplate>\n\n-- TEMP: TODO: Factor out this boilerplate somehow.\n\n{-# INLINE spawn1_ #-}\n-- Spawn a one argument function instead of a thunk.  This is good for debugging if the value supports "Show".\nspawn1_ f x =\n#ifdef DEBUG_DIRECT\n do sn  <- io$ makeStableName f\n    sch <- RD.ask; when dbg$ io$ printf " [%d] spawning fn %d with arg %s\\n" (no sch) (hashStableName sn) (show x)\n#endif\n    spawn_ (f x)\n\n-- The following is usually inefficient!\nnewFull_ a = do v <- new\n                put_ v a\n                return v\n\nnewFull a = deepseq a (newFull_ a)\n\n{-# INLINE put  #-}\nput v a = deepseq a (put_ v a)\n\nspawn p  = do r <- new;  fork (p >>= put r);   return r\nspawn_ p = do r <- new;  fork (p >>= put_ r);  return r\nspawnP a = spawn (return a)\n\n-- In Debug mode we require that IVar contents be Show-able:\n#ifdef DEBUG_DIRECT\nput    :: (Show a, NFData a) => IVar a -> a -> Par ()\nspawn  :: (Show a, NFData a) => Par a -> Par (IVar a)\nspawn_ :: Show a => Par a -> Par (IVar a)\nspawn1_ :: (Show a, Show b) => (a -> Par b) -> a -> Par (IVar b)\nspawnP :: (Show a, NFData a) => a -> Par (IVar a)\nput_   :: Show a => IVar a -> a -> Par ()\nget    :: Show a => IVar a -> Par a\nrunPar :: Show a => Par a -> a\nrunParIO :: Show a => Par a -> IO a\nnewFull :: (Show a, NFData a) => a -> Par (IVar a)\nnewFull_ ::  Show a => a -> Par (IVar a)\nunsafeTryPut :: Show b => IVar b -> b -> Par b\n#else\nspawn  :: NFData a => Par a -> Par (IVar a)\nspawn_ :: Par a -> Par (IVar a)\nspawn1_ :: (a -> Par b) -> a -> Par (IVar b)\nspawnP :: NFData a => a -> Par (IVar a)\nput_   :: IVar a -> a -> Par ()\nput    :: NFData a => IVar a -> a -> Par ()\nget    :: IVar a -> Par a\nrunPar :: Par a -> a\nrunParIO :: Par a -> IO a\nnewFull :: NFData a => a -> Par (IVar a)\nnewFull_ ::  a -> Par (IVar a)\nunsafeTryPut :: IVar b -> b -> Par b\n\n-- We can\'t make proper instances with the extra Show constraints:\ninstance PC.ParFuture IVar Par  where\n  get    = get\n  spawn  = spawn\n  spawn_ = spawn_\n  spawnP = spawnP\n\ninstance PC.ParIVar IVar Par  where\n  fork = fork\n  new  = new\n  put_ = put_\n  newFull = newFull\n  newFull_ = newFull_\n\ninstance UN.ParUnsafe IVar Par  where\n  unsafePeek   = unsafePeek\n  unsafeTryPut = unsafeTryPut\n  unsafeParIO  = unsafeParIO\n#endif\n\n\n\n#ifdef NEW_GENERIC\ninstance PU.ParMonad Par where\n  fork = fork\n  internalLiftIO io = Par (lift $ lift io)\n\ninstance PU.ParThreadSafe Par where\n  unsafeParIO io = Par (lift $ lift io)\n\ninstance PN.ParFuture Par where\n  type Future Par = IVar\n  type FutContents Par a = ()\n  get    = get\n  spawn  = spawn\n  spawn_ = spawn_\n  spawnP = spawnP\n\ninstance PN.ParIVar Par  where\n  new  = new\n  put_ = put_\n  newFull = newFull\n  newFull_ = newFull_\n#endif\n\n-- </boilerplate>\n--------------------------------------------------------------------------------\n\n\n{-# INLINE runReaderWith #-}\n-- | Arguments flipped for convenience.\nrunReaderWith :: r -> RD.ReaderT r m a -> m a\nrunReaderWith state m = RD.runReaderT m state\n\n\n--------------------------------------------------------------------------------\n-- DEBUGGING TOOLs\n--------------------------------------------------------------------------------\n\n-- Make sure there is no work left in any deque after exiting.\n_sanityCheck :: [Sched] -> IO ()\n_sanityCheck allscheds = do\n  forM_ allscheds $ \\ Sched{no, workpool} -> do\n     b <- R.nullQ workpool\n     when (not b) $ do\n         () <- printf "WARNING: After main thread exited non-empty queue remains for worker %d\\n" no\n         return ()\n  printf "Sanity check complete.\\n"\n\n\n-- | This tries to localize the blocked-indefinitely exception:\n_dbgTakeMVar :: String -> MVar a -> IO a\n_dbgTakeMVar msg mv =\n--  catch (takeMVar mv) ((\\_ -> doDebugStuff) :: BlockedIndefinitelyOnMVar -> IO a)\n  E.catch (takeMVar mv) (\\(_::IOError) -> doDebugStuff)\n where\n   doDebugStuff = do printf "This takeMVar blocked indefinitely!: %s\\n" msg\n                     error "failed"\n\n-- | For debugging purposes.  This can help us figure out (by an ugly\n--   process of elimination) which MVar reads are leading to a "Thread\n--   blocked indefinitely" exception.\n{-\nbusyTakeMVar :: String -> MVar a -> IO a\nbusyTakeMVar msg mv = try (10 * 1000 * 1000)\n where\n try 0 = do\n   when dbg $ do\n     tid <- myThreadId\n     -- After we\'ve failed enough times, start complaining:\n     printf "%s not getting anywhere, msg: %s\\n" (show tid) msg\n   try (100 * 1000)\n try n = do\n   x <- tryTakeMVar mv\n   case x of\n     Just y  -> return y\n     Nothing -> do yield; try (n-1)\n-}\n\n-- | Fork a thread but ALSO set up an error handler that suppresses\n--   MVar exceptions.\n_forkIO_Suppress :: Int -> IO () -> IO ThreadId\n_forkIO_Suppress whre action =\n  forkOn whre $\n           E.handle (\\e ->\n                      case (e :: E.BlockedIndefinitelyOnMVar) of\n                       _ -> do\n                               putStrLn$"CAUGHT child thread exception: "++show e\n                               return ()\n                    )\n           action\n\n\n-- | Exceptions that walk up the fork tree of threads:\nforkWithExceptions :: (IO () -> IO ThreadId) -> String -> IO () -> IO ThreadId\nforkWithExceptions forkit descr action = do\n   parent <- myThreadId\n   forkit $ do\n      tid <- myThreadId\n      E.catch action\n         (\\ e ->\n           case E.fromException e of\n             Just E.ThreadKilled -> printf\n                                    "\\nThreadKilled exception inside child thread, %s (not propagating!): %s\\n" (show tid) (show descr)\n             _  -> do printf\n                        "\\nException inside child thread %s, %s: %s\\n" (show descr) (show tid) (show e)\n                      E.throwTo parent (e :: E.SomeException)\n         )\n\n\n-- Do all the memory reads to snapshot the current session stack:\nreadSessions :: Sched -> IO [(SessionID, Bool)]\nreadSessions sched = do\n  ls <- readIORef (sessions sched)\n  bools <- mapM (\\ (Session _ r) -> readIORef r) ls\n  return (zip (map (\\ (Session sid _) -> sid) ls) bools)\n'