b'{-# LANGUAGE CPP #-}\n{-# LANGUAGE BangPatterns #-}\n{-# LANGUAGE PatternGuards #-}\n\n{-# OPTIONS_GHC -fno-warn-incomplete-uni-patterns #-}\n\n#include "containers.h"\n\n-----------------------------------------------------------------------------\n-- |\n-- Module      :  Data.IntMap.Strict.Internal\n-- Copyright   :  (c) Daan Leijen 2002\n--                (c) Andriy Palamarchuk 2008\n-- License     :  BSD-style\n-- Maintainer  :  libraries@haskell.org\n-- Portability :  portable\n--\n--\n-- = Finite Int Maps (strict interface)\n--\n-- The @\'IntMap\' v@ type represents a finite map (sometimes called a dictionary)\n-- from key of type @Int@ to values of type @v@.\n--\n-- Each function in this module is careful to force values before installing\n-- them in an \'IntMap\'. This is usually more efficient when laziness is not\n-- necessary. When laziness /is/ required, use the functions in\n-- "Data.IntMap.Lazy".\n--\n-- In particular, the functions in this module obey the following law:\n--\n--  - If all values stored in all maps in the arguments are in WHNF, then all\n--    values stored in all maps in the results will be in WHNF once those maps\n--    are evaluated.\n--\n-- For a walkthrough of the most commonly used functions see the\n-- <https://haskell-containers.readthedocs.io/en/latest/map.html maps introduction>.\n--\n-- This module is intended to be imported qualified, to avoid name clashes with\n-- Prelude functions:\n--\n-- > import Data.IntMap.Strict (IntMap)\n-- > import qualified Data.IntMap.Strict as IntMap\n--\n-- Note that the implementation is generally /left-biased/. Functions that take\n-- two maps as arguments and combine them, such as `union` and `intersection`,\n-- prefer the values in the first argument to those in the second.\n--\n--\n-- == Detailed performance information\n--\n-- The amortized running time is given for each operation, with \\(n\\) referring to\n-- the number of entries in the map and \\(W\\) referring to the number of bits in\n-- an \'Int\' (32 or 64).\n--\n-- Benchmarks comparing "Data.IntMap.Strict" with other dictionary\n-- implementations can be found at https://github.com/haskell-perf/dictionaries.\n--\n--\n-- == Warning\n--\n-- The \'IntMap\' type is shared between the lazy and strict modules, meaning that\n-- the same \'IntMap\' value can be passed to functions in both modules. This\n-- means that the \'Functor\', \'Traversable\' and \'Data.Data.Data\' instances are\n-- the same as for the "Data.IntMap.Lazy" module, so if they are used the\n-- resulting map may contain suspended values (thunks).\n--\n--\n-- == Implementation\n--\n-- The implementation is based on /big-endian patricia trees/.  This data\n-- structure performs especially well on binary operations like \'union\' and\n-- \'intersection\'. Additionally, benchmarks show that it is also (much) faster\n-- on insertions and deletions when compared to a generic size-balanced map\n-- implementation (see "Data.Map").\n--\n--    * Chris Okasaki and Andy Gill,  \\"/Fast Mergeable Integer Maps/\\",\n--      Workshop on ML, September 1998, pages 77-86,\n--      <http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.37.5452>\n--\n--    * D.R. Morrison, \\"/PATRICIA -- Practical Algorithm To Retrieve Information Coded In Alphanumeric/\\",\n--      Journal of the ACM, 15(4), October 1968, pages 514-534.\n--\n-----------------------------------------------------------------------------\n\n-- See the notes at the beginning of Data.IntMap.Internal.\n\nmodule Data.IntMap.Strict.Internal (\n    -- * Map type\n#if !defined(TESTING)\n    IntMap, Key          -- instance Eq,Show\n#else\n    IntMap(..), Key          -- instance Eq,Show\n#endif\n\n    -- * Construction\n    , empty\n    , singleton\n    , fromSet\n\n    -- ** From Unordered Lists\n    , fromList\n    , fromListWith\n    , fromListWithKey\n\n    -- ** From Ascending Lists\n    , fromAscList\n    , fromAscListWith\n    , fromAscListWithKey\n    , fromDistinctAscList\n\n    -- * Insertion\n    , insert\n    , insertWith\n    , insertWithKey\n    , insertLookupWithKey\n\n    -- * Deletion\\/Update\n    , delete\n    , adjust\n    , adjustWithKey\n    , update\n    , updateWithKey\n    , updateLookupWithKey\n    , alter\n    , alterF\n\n    -- * Query\n    -- ** Lookup\n    , lookup\n    , (!?)\n    , (!)\n    , findWithDefault\n    , member\n    , notMember\n    , lookupLT\n    , lookupGT\n    , lookupLE\n    , lookupGE\n\n    -- ** Size\n    , null\n    , size\n\n    -- * Combine\n\n    -- ** Union\n    , union\n    , unionWith\n    , unionWithKey\n    , unions\n    , unionsWith\n\n    -- ** Difference\n    , difference\n    , (\\\\)\n    , differenceWith\n    , differenceWithKey\n\n    -- ** Intersection\n    , intersection\n    , intersectionWith\n    , intersectionWithKey\n\n    -- ** Disjoint\n    , disjoint\n\n    -- ** Compose\n    , compose\n\n    -- ** Universal combining function\n    , mergeWithKey\n\n    -- * Traversal\n    -- ** Map\n    , map\n    , mapWithKey\n    , traverseWithKey\n    , traverseMaybeWithKey\n    , mapAccum\n    , mapAccumWithKey\n    , mapAccumRWithKey\n    , mapKeys\n    , mapKeysWith\n    , mapKeysMonotonic\n\n    -- * Folds\n    , foldr\n    , foldl\n    , foldrWithKey\n    , foldlWithKey\n    , foldMapWithKey\n\n    -- ** Strict folds\n    , foldr\'\n    , foldl\'\n    , foldrWithKey\'\n    , foldlWithKey\'\n\n    -- * Conversion\n    , elems\n    , keys\n    , assocs\n    , keysSet\n\n    -- ** Lists\n    , toList\n\n-- ** Ordered lists\n    , toAscList\n    , toDescList\n\n    -- * Filter\n    , filter\n    , filterWithKey\n    , restrictKeys\n    , withoutKeys\n    , partition\n    , partitionWithKey\n\n    , takeWhileAntitone\n    , dropWhileAntitone\n    , spanAntitone\n\n    , mapMaybe\n    , mapMaybeWithKey\n    , mapEither\n    , mapEitherWithKey\n\n    , split\n    , splitLookup\n    , splitRoot\n\n    -- * Submap\n    , isSubmapOf, isSubmapOfBy\n    , isProperSubmapOf, isProperSubmapOfBy\n\n    -- * Min\\/Max\n    , lookupMin\n    , lookupMax\n    , findMin\n    , findMax\n    , deleteMin\n    , deleteMax\n    , deleteFindMin\n    , deleteFindMax\n    , updateMin\n    , updateMax\n    , updateMinWithKey\n    , updateMaxWithKey\n    , minView\n    , maxView\n    , minViewWithKey\n    , maxViewWithKey\n\n#ifdef __GLASGOW_HASKELL__\n    -- * Debugging\n    , showTree\n    , showTreeWith\n#endif\n    ) where\n\nimport Utils.Containers.Internal.Prelude hiding\n  (lookup,map,filter,foldr,foldl,null)\nimport Prelude ()\n\nimport Data.Bits\nimport qualified Data.IntMap.Internal as L\nimport Data.IntMap.Internal\n  ( IntMap (..)\n  , Key\n  , mask\n  , branchMask\n  , nomatch\n  , zero\n  , natFromInt\n  , intFromNat\n  , bin\n  , binCheckLeft\n  , binCheckRight\n  , link\n  , linkWithMask\n\n  , (\\\\)\n  , (!)\n  , (!?)\n  , empty\n  , assocs\n  , filter\n  , filterWithKey\n  , findMin\n  , findMax\n  , foldMapWithKey\n  , foldr\n  , foldl\n  , foldr\'\n  , foldl\'\n  , foldlWithKey\n  , foldrWithKey\n  , foldlWithKey\'\n  , foldrWithKey\'\n  , keysSet\n  , mergeWithKey\'\n  , compose\n  , delete\n  , deleteMin\n  , deleteMax\n  , deleteFindMax\n  , deleteFindMin\n  , difference\n  , elems\n  , intersection\n  , disjoint\n  , isProperSubmapOf\n  , isProperSubmapOfBy\n  , isSubmapOf\n  , isSubmapOfBy\n  , lookup\n  , lookupLE\n  , lookupGE\n  , lookupLT\n  , lookupGT\n  , lookupMin\n  , lookupMax\n  , minView\n  , maxView\n  , minViewWithKey\n  , maxViewWithKey\n  , keys\n  , mapKeys\n  , mapKeysMonotonic\n  , member\n  , notMember\n  , null\n  , partition\n  , partitionWithKey\n  , takeWhileAntitone\n  , dropWhileAntitone\n  , spanAntitone\n  , restrictKeys\n  , size\n  , split\n  , splitLookup\n  , splitRoot\n  , toAscList\n  , toDescList\n  , toList\n  , union\n  , unions\n  , withoutKeys\n  )\n#ifdef __GLASGOW_HASKELL__\nimport Data.IntMap.Internal.DeprecatedDebug (showTree, showTreeWith)\n#endif\nimport qualified Data.IntSet.Internal as IntSet\nimport Utils.Containers.Internal.BitUtil\nimport Utils.Containers.Internal.StrictPair\nimport qualified Data.Foldable as Foldable\n\n{--------------------------------------------------------------------\n  Query\n--------------------------------------------------------------------}\n\n-- | \\(O(\\min(n,W))\\). The expression @(\'findWithDefault\' def k map)@\n-- returns the value at key @k@ or returns @def@ when the key is not an\n-- element of the map.\n--\n-- > findWithDefault \'x\' 1 (fromList [(5,\'a\'), (3,\'b\')]) == \'x\'\n-- > findWithDefault \'x\' 5 (fromList [(5,\'a\'), (3,\'b\')]) == \'a\'\n\n-- See IntMap.Internal.Note: Local \'go\' functions and capturing]\nfindWithDefault :: a -> Key -> IntMap a -> a\nfindWithDefault def !k = go\n  where\n    go (Bin p m l r) | nomatch k p m = def\n                     | zero k m  = go l\n                     | otherwise = go r\n    go (Tip kx x) | k == kx   = x\n                  | otherwise = def\n    go Nil = def\n\n{--------------------------------------------------------------------\n  Construction\n--------------------------------------------------------------------}\n-- | \\(O(1)\\). A map of one element.\n--\n-- > singleton 1 \'a\'        == fromList [(1, \'a\')]\n-- > size (singleton 1 \'a\') == 1\n\nsingleton :: Key -> a -> IntMap a\nsingleton k !x\n  = Tip k x\n{-# INLINE singleton #-}\n\n{--------------------------------------------------------------------\n  Insert\n--------------------------------------------------------------------}\n-- | \\(O(\\min(n,W))\\). Insert a new key\\/value pair in the map.\n-- If the key is already present in the map, the associated value is\n-- replaced with the supplied value, i.e. \'insert\' is equivalent to\n-- @\'insertWith\' \'const\'@.\n--\n-- > insert 5 \'x\' (fromList [(5,\'a\'), (3,\'b\')]) == fromList [(3, \'b\'), (5, \'x\')]\n-- > insert 7 \'x\' (fromList [(5,\'a\'), (3,\'b\')]) == fromList [(3, \'b\'), (5, \'a\'), (7, \'x\')]\n-- > insert 5 \'x\' empty                         == singleton 5 \'x\'\n\ninsert :: Key -> a -> IntMap a -> IntMap a\ninsert !k !x t =\n  case t of\n    Bin p m l r\n      | nomatch k p m -> link k (Tip k x) p t\n      | zero k m      -> Bin p m (insert k x l) r\n      | otherwise     -> Bin p m l (insert k x r)\n    Tip ky _\n      | k==ky         -> Tip k x\n      | otherwise     -> link k (Tip k x) ky t\n    Nil -> Tip k x\n\n-- right-biased insertion, used by \'union\'\n-- | \\(O(\\min(n,W))\\). Insert with a combining function.\n-- @\'insertWith\' f key value mp@\n-- will insert the pair (key, value) into @mp@ if key does\n-- not exist in the map. If the key does exist, the function will\n-- insert @f new_value old_value@.\n--\n-- > insertWith (++) 5 "xxx" (fromList [(5,"a"), (3,"b")]) == fromList [(3, "b"), (5, "xxxa")]\n-- > insertWith (++) 7 "xxx" (fromList [(5,"a"), (3,"b")]) == fromList [(3, "b"), (5, "a"), (7, "xxx")]\n-- > insertWith (++) 5 "xxx" empty                         == singleton 5 "xxx"\n\ninsertWith :: (a -> a -> a) -> Key -> a -> IntMap a -> IntMap a\ninsertWith f k x t\n  = insertWithKey (\\_ x\' y\' -> f x\' y\') k x t\n\n-- | \\(O(\\min(n,W))\\). Insert with a combining function.\n-- @\'insertWithKey\' f key value mp@\n-- will insert the pair (key, value) into @mp@ if key does\n-- not exist in the map. If the key does exist, the function will\n-- insert @f key new_value old_value@.\n--\n-- > let f key new_value old_value = (show key) ++ ":" ++ new_value ++ "|" ++ old_value\n-- > insertWithKey f 5 "xxx" (fromList [(5,"a"), (3,"b")]) == fromList [(3, "b"), (5, "5:xxx|a")]\n-- > insertWithKey f 7 "xxx" (fromList [(5,"a"), (3,"b")]) == fromList [(3, "b"), (5, "a"), (7, "xxx")]\n-- > insertWithKey f 5 "xxx" empty                         == singleton 5 "xxx"\n--\n-- If the key exists in the map, this function is lazy in @value@ but strict\n-- in the result of @f@.\n\ninsertWithKey :: (Key -> a -> a -> a) -> Key -> a -> IntMap a -> IntMap a\ninsertWithKey f !k x t =\n  case t of\n    Bin p m l r\n      | nomatch k p m -> link k (singleton k x) p t\n      | zero k m      -> Bin p m (insertWithKey f k x l) r\n      | otherwise     -> Bin p m l (insertWithKey f k x r)\n    Tip ky y\n      | k==ky         -> Tip k $! f k x y\n      | otherwise     -> link k (singleton k x) ky t\n    Nil -> singleton k x\n\n-- | \\(O(\\min(n,W))\\). The expression (@\'insertLookupWithKey\' f k x map@)\n-- is a pair where the first element is equal to (@\'lookup\' k map@)\n-- and the second element equal to (@\'insertWithKey\' f k x map@).\n--\n-- > let f key new_value old_value = (show key) ++ ":" ++ new_value ++ "|" ++ old_value\n-- > insertLookupWithKey f 5 "xxx" (fromList [(5,"a"), (3,"b")]) == (Just "a", fromList [(3, "b"), (5, "5:xxx|a")])\n-- > insertLookupWithKey f 7 "xxx" (fromList [(5,"a"), (3,"b")]) == (Nothing,  fromList [(3, "b"), (5, "a"), (7, "xxx")])\n-- > insertLookupWithKey f 5 "xxx" empty                         == (Nothing,  singleton 5 "xxx")\n--\n-- This is how to define @insertLookup@ using @insertLookupWithKey@:\n--\n-- > let insertLookup kx x t = insertLookupWithKey (\\_ a _ -> a) kx x t\n-- > insertLookup 5 "x" (fromList [(5,"a"), (3,"b")]) == (Just "a", fromList [(3, "b"), (5, "x")])\n-- > insertLookup 7 "x" (fromList [(5,"a"), (3,"b")]) == (Nothing,  fromList [(3, "b"), (5, "a"), (7, "x")])\n\ninsertLookupWithKey :: (Key -> a -> a -> a) -> Key -> a -> IntMap a -> (Maybe a, IntMap a)\ninsertLookupWithKey f0 !k0 x0 t0 = toPair $ go f0 k0 x0 t0\n  where\n    go f k x t =\n      case t of\n        Bin p m l r\n          | nomatch k p m -> Nothing :*: link k (singleton k x) p t\n          | zero k m      -> let (found :*: l\') = go f k x l in (found :*: Bin p m l\' r)\n          | otherwise     -> let (found :*: r\') = go f k x r in (found :*: Bin p m l r\')\n        Tip ky y\n          | k==ky         -> (Just y :*: (Tip k $! f k x y))\n          | otherwise     -> (Nothing :*: link k (singleton k x) ky t)\n        Nil -> Nothing :*: (singleton k x)\n\n\n{--------------------------------------------------------------------\n  Deletion\n--------------------------------------------------------------------}\n-- | \\(O(\\min(n,W))\\). Adjust a value at a specific key. When the key is not\n-- a member of the map, the original map is returned.\n--\n-- > adjust ("new " ++) 5 (fromList [(5,"a"), (3,"b")]) == fromList [(3, "b"), (5, "new a")]\n-- > adjust ("new " ++) 7 (fromList [(5,"a"), (3,"b")]) == fromList [(3, "b"), (5, "a")]\n-- > adjust ("new " ++) 7 empty                         == empty\n\nadjust ::  (a -> a) -> Key -> IntMap a -> IntMap a\nadjust f k m\n  = adjustWithKey (\\_ x -> f x) k m\n\n-- | \\(O(\\min(n,W))\\). Adjust a value at a specific key. When the key is not\n-- a member of the map, the original map is returned.\n--\n-- > let f key x = (show key) ++ ":new " ++ x\n-- > adjustWithKey f 5 (fromList [(5,"a"), (3,"b")]) == fromList [(3, "b"), (5, "5:new a")]\n-- > adjustWithKey f 7 (fromList [(5,"a"), (3,"b")]) == fromList [(3, "b"), (5, "a")]\n-- > adjustWithKey f 7 empty                         == empty\n\nadjustWithKey ::  (Key -> a -> a) -> Key -> IntMap a -> IntMap a\nadjustWithKey f !k t =\n  case t of\n    Bin p m l r\n      | nomatch k p m -> t\n      | zero k m      -> Bin p m (adjustWithKey f k l) r\n      | otherwise     -> Bin p m l (adjustWithKey f k r)\n    Tip ky y\n      | k==ky         -> Tip ky $! f k y\n      | otherwise     -> t\n    Nil -> Nil\n\n-- | \\(O(\\min(n,W))\\). The expression (@\'update\' f k map@) updates the value @x@\n-- at @k@ (if it is in the map). If (@f x@) is \'Nothing\', the element is\n-- deleted. If it is (@\'Just\' y@), the key @k@ is bound to the new value @y@.\n--\n-- > let f x = if x == "a" then Just "new a" else Nothing\n-- > update f 5 (fromList [(5,"a"), (3,"b")]) == fromList [(3, "b"), (5, "new a")]\n-- > update f 7 (fromList [(5,"a"), (3,"b")]) == fromList [(3, "b"), (5, "a")]\n-- > update f 3 (fromList [(5,"a"), (3,"b")]) == singleton 5 "a"\n\nupdate ::  (a -> Maybe a) -> Key -> IntMap a -> IntMap a\nupdate f\n  = updateWithKey (\\_ x -> f x)\n\n-- | \\(O(\\min(n,W))\\). The expression (@\'update\' f k map@) updates the value @x@\n-- at @k@ (if it is in the map). If (@f k x@) is \'Nothing\', the element is\n-- deleted. If it is (@\'Just\' y@), the key @k@ is bound to the new value @y@.\n--\n-- > let f k x = if x == "a" then Just ((show k) ++ ":new a") else Nothing\n-- > updateWithKey f 5 (fromList [(5,"a"), (3,"b")]) == fromList [(3, "b"), (5, "5:new a")]\n-- > updateWithKey f 7 (fromList [(5,"a"), (3,"b")]) == fromList [(3, "b"), (5, "a")]\n-- > updateWithKey f 3 (fromList [(5,"a"), (3,"b")]) == singleton 5 "a"\n\nupdateWithKey ::  (Key -> a -> Maybe a) -> Key -> IntMap a -> IntMap a\nupdateWithKey f !k t =\n  case t of\n    Bin p m l r\n      | nomatch k p m -> t\n      | zero k m      -> binCheckLeft p m (updateWithKey f k l) r\n      | otherwise     -> binCheckRight p m l (updateWithKey f k r)\n    Tip ky y\n      | k==ky         -> case f k y of\n                           Just !y\' -> Tip ky y\'\n                           Nothing -> Nil\n      | otherwise     -> t\n    Nil -> Nil\n\n-- | \\(O(\\min(n,W))\\). Lookup and update.\n-- The function returns original value, if it is updated.\n-- This is different behavior than \'Data.Map.updateLookupWithKey\'.\n-- Returns the original key value if the map entry is deleted.\n--\n-- > let f k x = if x == "a" then Just ((show k) ++ ":new a") else Nothing\n-- > updateLookupWithKey f 5 (fromList [(5,"a"), (3,"b")]) == (Just "a", fromList [(3, "b"), (5, "5:new a")])\n-- > updateLookupWithKey f 7 (fromList [(5,"a"), (3,"b")]) == (Nothing,  fromList [(3, "b"), (5, "a")])\n-- > updateLookupWithKey f 3 (fromList [(5,"a"), (3,"b")]) == (Just "b", singleton 5 "a")\n\nupdateLookupWithKey ::  (Key -> a -> Maybe a) -> Key -> IntMap a -> (Maybe a,IntMap a)\nupdateLookupWithKey f0 !k0 t0 = toPair $ go f0 k0 t0\n  where\n    go f k t =\n      case t of\n        Bin p m l r\n          | nomatch k p m -> (Nothing :*: t)\n          | zero k m      -> let (found :*: l\') = go f k l in (found :*: binCheckLeft p m l\' r)\n          | otherwise     -> let (found :*: r\') = go f k r in (found :*: binCheckRight p m l r\')\n        Tip ky y\n          | k==ky         -> case f k y of\n                               Just !y\' -> (Just y :*: Tip ky y\')\n                               Nothing  -> (Just y :*: Nil)\n          | otherwise     -> (Nothing :*: t)\n        Nil -> (Nothing :*: Nil)\n\n\n\n-- | \\(O(\\min(n,W))\\). The expression (@\'alter\' f k map@) alters the value @x@ at @k@, or absence thereof.\n-- \'alter\' can be used to insert, delete, or update a value in an \'IntMap\'.\n-- In short : @\'lookup\' k (\'alter\' f k m) = f (\'lookup\' k m)@.\nalter :: (Maybe a -> Maybe a) -> Key -> IntMap a -> IntMap a\nalter f !k t =\n  case t of\n    Bin p m l r\n      | nomatch k p m -> case f Nothing of\n                           Nothing -> t\n                           Just !x  -> link k (Tip k x) p t\n      | zero k m      -> binCheckLeft p m (alter f k l) r\n      | otherwise     -> binCheckRight p m l (alter f k r)\n    Tip ky y\n      | k==ky         -> case f (Just y) of\n                           Just !x -> Tip ky x\n                           Nothing -> Nil\n      | otherwise     -> case f Nothing of\n                           Just !x -> link k (Tip k x) ky t\n                           Nothing -> t\n    Nil               -> case f Nothing of\n                           Just !x -> Tip k x\n                           Nothing -> Nil\n\n-- | \\(O(\\log n)\\). The expression (@\'alterF\' f k map@) alters the value @x@ at\n-- @k@, or absence thereof.  \'alterF\' can be used to inspect, insert, delete,\n-- or update a value in an \'IntMap\'.  In short : @\'lookup\' k <$> \'alterF\' f k m = f\n-- (\'lookup\' k m)@.\n--\n-- Example:\n--\n-- @\n-- interactiveAlter :: Int -> IntMap String -> IO (IntMap String)\n-- interactiveAlter k m = alterF f k m where\n--   f Nothing = do\n--      putStrLn $ show k ++\n--          " was not found in the map. Would you like to add it?"\n--      getUserResponse1 :: IO (Maybe String)\n--   f (Just old) = do\n--      putStrLn $ "The key is currently bound to " ++ show old ++\n--          ". Would you like to change or delete it?"\n--      getUserResponse2 :: IO (Maybe String)\n-- @\n--\n-- \'alterF\' is the most general operation for working with an individual\n-- key that may or may not be in a given map.\n\n-- Note: \'alterF\' is a flipped version of the \'at\' combinator from\n-- \'Control.Lens.At\'.\n--\n-- @since 0.5.8\n\nalterF :: Functor f\n       => (Maybe a -> f (Maybe a)) -> Key -> IntMap a -> f (IntMap a)\n-- This implementation was modified from \'Control.Lens.At\'.\nalterF f k m = (<$> f mv) $ \\fres ->\n  case fres of\n    Nothing -> maybe m (const (delete k m)) mv\n    Just !v\' -> insert k v\' m\n  where mv = lookup k m\n\n\n{--------------------------------------------------------------------\n  Union\n--------------------------------------------------------------------}\n-- | The union of a list of maps, with a combining operation.\n--\n-- > unionsWith (++) [(fromList [(5, "a"), (3, "b")]), (fromList [(5, "A"), (7, "C")]), (fromList [(5, "A3"), (3, "B3")])]\n-- >     == fromList [(3, "bB3"), (5, "aAA3"), (7, "C")]\n\nunionsWith :: Foldable f => (a->a->a) -> f (IntMap a) -> IntMap a\nunionsWith f ts\n  = Foldable.foldl\' (unionWith f) empty ts\n\n-- | \\(O(n+m)\\). The union with a combining function.\n--\n-- > unionWith (++) (fromList [(5, "a"), (3, "b")]) (fromList [(5, "A"), (7, "C")]) == fromList [(3, "b"), (5, "aA"), (7, "C")]\n\nunionWith :: (a -> a -> a) -> IntMap a -> IntMap a -> IntMap a\nunionWith f m1 m2\n  = unionWithKey (\\_ x y -> f x y) m1 m2\n\n-- | \\(O(n+m)\\). The union with a combining function.\n--\n-- > let f key left_value right_value = (show key) ++ ":" ++ left_value ++ "|" ++ right_value\n-- > unionWithKey f (fromList [(5, "a"), (3, "b")]) (fromList [(5, "A"), (7, "C")]) == fromList [(3, "b"), (5, "5:a|A"), (7, "C")]\n\nunionWithKey :: (Key -> a -> a -> a) -> IntMap a -> IntMap a -> IntMap a\nunionWithKey f m1 m2\n  = mergeWithKey\' Bin (\\(Tip k1 x1) (Tip _k2 x2) -> Tip k1 $! f k1 x1 x2) id id m1 m2\n\n{--------------------------------------------------------------------\n  Difference\n--------------------------------------------------------------------}\n\n-- | \\(O(n+m)\\). Difference with a combining function.\n--\n-- > let f al ar = if al == "b" then Just (al ++ ":" ++ ar) else Nothing\n-- > differenceWith f (fromList [(5, "a"), (3, "b")]) (fromList [(5, "A"), (3, "B"), (7, "C")])\n-- >     == singleton 3 "b:B"\n\ndifferenceWith :: (a -> b -> Maybe a) -> IntMap a -> IntMap b -> IntMap a\ndifferenceWith f m1 m2\n  = differenceWithKey (\\_ x y -> f x y) m1 m2\n\n-- | \\(O(n+m)\\). Difference with a combining function. When two equal keys are\n-- encountered, the combining function is applied to the key and both values.\n-- If it returns \'Nothing\', the element is discarded (proper set difference).\n-- If it returns (@\'Just\' y@), the element is updated with a new value @y@.\n--\n-- > let f k al ar = if al == "b" then Just ((show k) ++ ":" ++ al ++ "|" ++ ar) else Nothing\n-- > differenceWithKey f (fromList [(5, "a"), (3, "b")]) (fromList [(5, "A"), (3, "B"), (10, "C")])\n-- >     == singleton 3 "3:b|B"\n\ndifferenceWithKey :: (Key -> a -> b -> Maybe a) -> IntMap a -> IntMap b -> IntMap a\ndifferenceWithKey f m1 m2\n  = mergeWithKey f id (const Nil) m1 m2\n\n{--------------------------------------------------------------------\n  Intersection\n--------------------------------------------------------------------}\n\n-- | \\(O(n+m)\\). The intersection with a combining function.\n--\n-- > intersectionWith (++) (fromList [(5, "a"), (3, "b")]) (fromList [(5, "A"), (7, "C")]) == singleton 5 "aA"\n\nintersectionWith :: (a -> b -> c) -> IntMap a -> IntMap b -> IntMap c\nintersectionWith f m1 m2\n  = intersectionWithKey (\\_ x y -> f x y) m1 m2\n\n-- | \\(O(n+m)\\). The intersection with a combining function.\n--\n-- > let f k al ar = (show k) ++ ":" ++ al ++ "|" ++ ar\n-- > intersectionWithKey f (fromList [(5, "a"), (3, "b")]) (fromList [(5, "A"), (7, "C")]) == singleton 5 "5:a|A"\n\nintersectionWithKey :: (Key -> a -> b -> c) -> IntMap a -> IntMap b -> IntMap c\nintersectionWithKey f m1 m2\n  = mergeWithKey\' bin (\\(Tip k1 x1) (Tip _k2 x2) -> Tip k1 $! f k1 x1 x2) (const Nil) (const Nil) m1 m2\n\n{--------------------------------------------------------------------\n  MergeWithKey\n--------------------------------------------------------------------}\n\n-- | \\(O(n+m)\\). A high-performance universal combining function. Using\n-- \'mergeWithKey\', all combining functions can be defined without any loss of\n-- efficiency (with exception of \'union\', \'difference\' and \'intersection\',\n-- where sharing of some nodes is lost with \'mergeWithKey\').\n--\n-- Please make sure you know what is going on when using \'mergeWithKey\',\n-- otherwise you can be surprised by unexpected code growth or even\n-- corruption of the data structure.\n--\n-- When \'mergeWithKey\' is given three arguments, it is inlined to the call\n-- site. You should therefore use \'mergeWithKey\' only to define your custom\n-- combining functions. For example, you could define \'unionWithKey\',\n-- \'differenceWithKey\' and \'intersectionWithKey\' as\n--\n-- > myUnionWithKey f m1 m2 = mergeWithKey (\\k x1 x2 -> Just (f k x1 x2)) id id m1 m2\n-- > myDifferenceWithKey f m1 m2 = mergeWithKey f id (const empty) m1 m2\n-- > myIntersectionWithKey f m1 m2 = mergeWithKey (\\k x1 x2 -> Just (f k x1 x2)) (const empty) (const empty) m1 m2\n--\n-- When calling @\'mergeWithKey\' combine only1 only2@, a function combining two\n-- \'IntMap\'s is created, such that\n--\n-- * if a key is present in both maps, it is passed with both corresponding\n--   values to the @combine@ function. Depending on the result, the key is either\n--   present in the result with specified value, or is left out;\n--\n-- * a nonempty subtree present only in the first map is passed to @only1@ and\n--   the output is added to the result;\n--\n-- * a nonempty subtree present only in the second map is passed to @only2@ and\n--   the output is added to the result.\n--\n-- The @only1@ and @only2@ methods /must return a map with a subset (possibly empty) of the keys of the given map/.\n-- The values can be modified arbitrarily.  Most common variants of @only1@ and\n-- @only2@ are \'id\' and @\'const\' \'empty\'@, but for example @\'map\' f@ or\n-- @\'filterWithKey\' f@ could be used for any @f@.\n\nmergeWithKey :: (Key -> a -> b -> Maybe c) -> (IntMap a -> IntMap c) -> (IntMap b -> IntMap c)\n             -> IntMap a -> IntMap b -> IntMap c\nmergeWithKey f g1 g2 = mergeWithKey\' bin combine g1 g2\n  where -- We use the lambda form to avoid non-exhaustive pattern matches warning.\n        combine = \\(Tip k1 x1) (Tip _k2 x2) -> case f k1 x1 x2 of Nothing -> Nil\n                                                                  Just !x -> Tip k1 x\n        {-# INLINE combine #-}\n{-# INLINE mergeWithKey #-}\n\n{--------------------------------------------------------------------\n  Min\\/Max\n--------------------------------------------------------------------}\n\n-- | \\(O(\\log n)\\). Update the value at the minimal key.\n--\n-- > updateMinWithKey (\\ k a -> Just ((show k) ++ ":" ++ a)) (fromList [(5,"a"), (3,"b")]) == fromList [(3,"3:b"), (5,"a")]\n-- > updateMinWithKey (\\ _ _ -> Nothing)                     (fromList [(5,"a"), (3,"b")]) == singleton 5 "a"\n\nupdateMinWithKey :: (Key -> a -> Maybe a) -> IntMap a -> IntMap a\nupdateMinWithKey f t =\n  case t of Bin p m l r | m < 0 -> binCheckRight p m l (go f r)\n            _ -> go f t\n  where\n    go f\' (Bin p m l r) = binCheckLeft p m (go f\' l) r\n    go f\' (Tip k y) = case f\' k y of\n                        Just !y\' -> Tip k y\'\n                        Nothing -> Nil\n    go _ Nil = error "updateMinWithKey Nil"\n\n-- | \\(O(\\log n)\\). Update the value at the maximal key.\n--\n-- > updateMaxWithKey (\\ k a -> Just ((show k) ++ ":" ++ a)) (fromList [(5,"a"), (3,"b")]) == fromList [(3,"b"), (5,"5:a")]\n-- > updateMaxWithKey (\\ _ _ -> Nothing)                     (fromList [(5,"a"), (3,"b")]) == singleton 3 "b"\n\nupdateMaxWithKey :: (Key -> a -> Maybe a) -> IntMap a -> IntMap a\nupdateMaxWithKey f t =\n  case t of Bin p m l r | m < 0 -> binCheckLeft p m (go f l) r\n            _ -> go f t\n  where\n    go f\' (Bin p m l r) = binCheckRight p m l (go f\' r)\n    go f\' (Tip k y) = case f\' k y of\n                        Just !y\' -> Tip k y\'\n                        Nothing -> Nil\n    go _ Nil = error "updateMaxWithKey Nil"\n\n-- | \\(O(\\log n)\\). Update the value at the maximal key.\n--\n-- > updateMax (\\ a -> Just ("X" ++ a)) (fromList [(5,"a"), (3,"b")]) == fromList [(3, "b"), (5, "Xa")]\n-- > updateMax (\\ _ -> Nothing)         (fromList [(5,"a"), (3,"b")]) == singleton 3 "b"\n\nupdateMax :: (a -> Maybe a) -> IntMap a -> IntMap a\nupdateMax f = updateMaxWithKey (const f)\n\n-- | \\(O(\\log n)\\). Update the value at the minimal key.\n--\n-- > updateMin (\\ a -> Just ("X" ++ a)) (fromList [(5,"a"), (3,"b")]) == fromList [(3, "Xb"), (5, "a")]\n-- > updateMin (\\ _ -> Nothing)         (fromList [(5,"a"), (3,"b")]) == singleton 5 "a"\n\nupdateMin :: (a -> Maybe a) -> IntMap a -> IntMap a\nupdateMin f = updateMinWithKey (const f)\n\n\n{--------------------------------------------------------------------\n  Mapping\n--------------------------------------------------------------------}\n-- | \\(O(n)\\). Map a function over all values in the map.\n--\n-- > map (++ "x") (fromList [(5,"a"), (3,"b")]) == fromList [(3, "bx"), (5, "ax")]\n\nmap :: (a -> b) -> IntMap a -> IntMap b\nmap f = go\n  where\n    go (Bin p m l r) = Bin p m (go l) (go r)\n    go (Tip k x)     = Tip k $! f x\n    go Nil           = Nil\n\n#ifdef __GLASGOW_HASKELL__\n{-# NOINLINE [1] map #-}\n{-# RULES\n"map/map" forall f g xs . map f (map g xs) = map (\\x -> f $! g x) xs\n"map/mapL" forall f g xs . map f (L.map g xs) = map (\\x -> f (g x)) xs\n #-}\n#endif\n\n-- | \\(O(n)\\). Map a function over all values in the map.\n--\n-- > let f key x = (show key) ++ ":" ++ x\n-- > mapWithKey f (fromList [(5,"a"), (3,"b")]) == fromList [(3, "3:b"), (5, "5:a")]\n\nmapWithKey :: (Key -> a -> b) -> IntMap a -> IntMap b\nmapWithKey f t\n  = case t of\n      Bin p m l r -> Bin p m (mapWithKey f l) (mapWithKey f r)\n      Tip k x     -> Tip k $! f k x\n      Nil         -> Nil\n\n#ifdef __GLASGOW_HASKELL__\n-- Pay close attention to strictness here. We need to force the\n-- intermediate result for map f . map g, and we need to refrain\n-- from forcing it for map f . L.map g, etc.\n--\n-- TODO Consider moving map and mapWithKey to IntMap.Internal so we can write\n-- non-orphan RULES for things like L.map f (map g xs). We\'d need a new function\n-- for this, and we\'d have to pay attention to simplifier phases. Something like\n--\n-- lsmap :: (b -> c) -> (a -> b) -> IntMap a -> IntMap c\n-- lsmap _ _ Nil = Nil\n-- lsmap f g (Tip k x) = let !gx = g x in Tip k (f gx)\n-- lsmap f g (Bin p m l r) = Bin p m (lsmap f g l) (lsmap f g r)\n{-# NOINLINE [1] mapWithKey #-}\n{-# RULES\n"mapWithKey/mapWithKey" forall f g xs . mapWithKey f (mapWithKey g xs) =\n  mapWithKey (\\k a -> f k $! g k a) xs\n"mapWithKey/mapWithKeyL" forall f g xs . mapWithKey f (L.mapWithKey g xs) =\n  mapWithKey (\\k a -> f k (g k a)) xs\n"mapWithKey/map" forall f g xs . mapWithKey f (map g xs) =\n  mapWithKey (\\k a -> f k $! g a) xs\n"mapWithKey/mapL" forall f g xs . mapWithKey f (L.map g xs) =\n  mapWithKey (\\k a -> f k (g a)) xs\n"map/mapWithKey" forall f g xs . map f (mapWithKey g xs) =\n  mapWithKey (\\k a -> f $! g k a) xs\n"map/mapWithKeyL" forall f g xs . map f (L.mapWithKey g xs) =\n  mapWithKey (\\k a -> f (g k a)) xs\n #-}\n#endif\n\n-- | \\(O(n)\\).\n-- @\'traverseWithKey\' f s == \'fromList\' <$> \'traverse\' (\\(k, v) -> (,) k <$> f k v) (\'toList\' m)@\n-- That is, behaves exactly like a regular \'traverse\' except that the traversing\n-- function also has access to the key associated with a value.\n--\n-- > traverseWithKey (\\k v -> if odd k then Just (succ v) else Nothing) (fromList [(1, \'a\'), (5, \'e\')]) == Just (fromList [(1, \'b\'), (5, \'f\')])\n-- > traverseWithKey (\\k v -> if odd k then Just (succ v) else Nothing) (fromList [(2, \'c\')])           == Nothing\ntraverseWithKey :: Applicative t => (Key -> a -> t b) -> IntMap a -> t (IntMap b)\ntraverseWithKey f = go\n  where\n    go Nil = pure Nil\n    go (Tip k v) = (\\ !v\' -> Tip k v\') <$> f k v\n    go (Bin p m l r)\n      | m < 0     = liftA2 (flip (Bin p m)) (go r) (go l)\n      | otherwise = liftA2 (Bin p m) (go l) (go r)\n{-# INLINE traverseWithKey #-}\n\n-- | \\(O(n)\\). Traverse keys\\/values and collect the \'Just\' results.\n--\n-- @since 0.6.4\ntraverseMaybeWithKey\n  :: Applicative f => (Key -> a -> f (Maybe b)) -> IntMap a -> f (IntMap b)\ntraverseMaybeWithKey f = go\n    where\n    go Nil           = pure Nil\n    go (Tip k x)     = maybe Nil (Tip k $!) <$> f k x\n    go (Bin p m l r)\n      | m < 0     = liftA2 (flip (bin p m)) (go r) (go l)\n      | otherwise = liftA2 (bin p m) (go l) (go r)\n\n-- | \\(O(n)\\). The function @\'mapAccum\'@ threads an accumulating\n-- argument through the map in ascending order of keys.\n--\n-- > let f a b = (a ++ b, b ++ "X")\n-- > mapAccum f "Everything: " (fromList [(5,"a"), (3,"b")]) == ("Everything: ba", fromList [(3, "bX"), (5, "aX")])\n\nmapAccum :: (a -> b -> (a,c)) -> a -> IntMap b -> (a,IntMap c)\nmapAccum f = mapAccumWithKey (\\a\' _ x -> f a\' x)\n\n-- | \\(O(n)\\). The function @\'mapAccumWithKey\'@ threads an accumulating\n-- argument through the map in ascending order of keys.\n--\n-- > let f a k b = (a ++ " " ++ (show k) ++ "-" ++ b, b ++ "X")\n-- > mapAccumWithKey f "Everything:" (fromList [(5,"a"), (3,"b")]) == ("Everything: 3-b 5-a", fromList [(3, "bX"), (5, "aX")])\n\nmapAccumWithKey :: (a -> Key -> b -> (a,c)) -> a -> IntMap b -> (a,IntMap c)\nmapAccumWithKey f a t\n  = mapAccumL f a t\n\n-- | \\(O(n)\\). The function @\'mapAccumL\'@ threads an accumulating\n-- argument through the map in ascending order of keys.  Strict in\n-- the accumulating argument and the both elements of the\n-- result of the function.\nmapAccumL :: (a -> Key -> b -> (a,c)) -> a -> IntMap b -> (a,IntMap c)\nmapAccumL f0 a0 t0 = toPair $ go f0 a0 t0\n  where\n    go f a t\n      = case t of\n          Bin p m l r\n            | m < 0 ->\n                let (a1 :*: r\') = go f a r\n                    (a2 :*: l\') = go f a1 l\n                in (a2 :*: Bin p m l\' r\')\n            | otherwise ->\n                let (a1 :*: l\') = go f a l\n                    (a2 :*: r\') = go f a1 r\n                in (a2 :*: Bin p m l\' r\')\n          Tip k x     -> let !(a\',!x\') = f a k x in (a\' :*: Tip k x\')\n          Nil         -> (a :*: Nil)\n\n-- | \\(O(n)\\). The function @\'mapAccumRWithKey\'@ threads an accumulating\n-- argument through the map in descending order of keys.\nmapAccumRWithKey :: (a -> Key -> b -> (a,c)) -> a -> IntMap b -> (a,IntMap c)\nmapAccumRWithKey f0 a0 t0 = toPair $ go f0 a0 t0\n  where\n    go f a t\n      = case t of\n          Bin p m l r\n            | m < 0 ->\n              let (a1 :*: l\') = go f a l\n                  (a2 :*: r\') = go f a1 r\n              in (a2 :*: Bin p m l\' r\')\n            | otherwise ->\n              let (a1 :*: r\') = go f a r\n                  (a2 :*: l\') = go f a1 l\n              in (a2 :*: Bin p m l\' r\')\n          Tip k x     -> let !(a\',!x\') = f a k x in (a\' :*: Tip k x\')\n          Nil         -> (a :*: Nil)\n\n-- | \\(O(n \\log n)\\).\n-- @\'mapKeysWith\' c f s@ is the map obtained by applying @f@ to each key of @s@.\n--\n-- The size of the result may be smaller if @f@ maps two or more distinct\n-- keys to the same new key.  In this case the associated values will be\n-- combined using @c@.\n--\n-- > mapKeysWith (++) (\\ _ -> 1) (fromList [(1,"b"), (2,"a"), (3,"d"), (4,"c")]) == singleton 1 "cdab"\n-- > mapKeysWith (++) (\\ _ -> 3) (fromList [(1,"b"), (2,"a"), (3,"d"), (4,"c")]) == singleton 3 "cdab"\n\nmapKeysWith :: (a -> a -> a) -> (Key->Key) -> IntMap a -> IntMap a\nmapKeysWith c f = fromListWith c . foldrWithKey (\\k x xs -> (f k, x) : xs) []\n\n{--------------------------------------------------------------------\n  Filter\n--------------------------------------------------------------------}\n-- | \\(O(n)\\). Map values and collect the \'Just\' results.\n--\n-- > let f x = if x == "a" then Just "new a" else Nothing\n-- > mapMaybe f (fromList [(5,"a"), (3,"b")]) == singleton 5 "new a"\n\nmapMaybe :: (a -> Maybe b) -> IntMap a -> IntMap b\nmapMaybe f = mapMaybeWithKey (\\_ x -> f x)\n\n-- | \\(O(n)\\). Map keys\\/values and collect the \'Just\' results.\n--\n-- > let f k _ = if k < 5 then Just ("key : " ++ (show k)) else Nothing\n-- > mapMaybeWithKey f (fromList [(5,"a"), (3,"b")]) == singleton 3 "key : 3"\n\nmapMaybeWithKey :: (Key -> a -> Maybe b) -> IntMap a -> IntMap b\nmapMaybeWithKey f (Bin p m l r)\n  = bin p m (mapMaybeWithKey f l) (mapMaybeWithKey f r)\nmapMaybeWithKey f (Tip k x) = case f k x of\n  Just !y  -> Tip k y\n  Nothing -> Nil\nmapMaybeWithKey _ Nil = Nil\n\n-- | \\(O(n)\\). Map values and separate the \'Left\' and \'Right\' results.\n--\n-- > let f a = if a < "c" then Left a else Right a\n-- > mapEither f (fromList [(5,"a"), (3,"b"), (1,"x"), (7,"z")])\n-- >     == (fromList [(3,"b"), (5,"a")], fromList [(1,"x"), (7,"z")])\n-- >\n-- > mapEither (\\ a -> Right a) (fromList [(5,"a"), (3,"b"), (1,"x"), (7,"z")])\n-- >     == (empty, fromList [(5,"a"), (3,"b"), (1,"x"), (7,"z")])\n\nmapEither :: (a -> Either b c) -> IntMap a -> (IntMap b, IntMap c)\nmapEither f m\n  = mapEitherWithKey (\\_ x -> f x) m\n\n-- | \\(O(n)\\). Map keys\\/values and separate the \'Left\' and \'Right\' results.\n--\n-- > let f k a = if k < 5 then Left (k * 2) else Right (a ++ a)\n-- > mapEitherWithKey f (fromList [(5,"a"), (3,"b"), (1,"x"), (7,"z")])\n-- >     == (fromList [(1,2), (3,6)], fromList [(5,"aa"), (7,"zz")])\n-- >\n-- > mapEitherWithKey (\\_ a -> Right a) (fromList [(5,"a"), (3,"b"), (1,"x"), (7,"z")])\n-- >     == (empty, fromList [(1,"x"), (3,"b"), (5,"a"), (7,"z")])\n\nmapEitherWithKey :: (Key -> a -> Either b c) -> IntMap a -> (IntMap b, IntMap c)\nmapEitherWithKey f0 t0 = toPair $ go f0 t0\n  where\n    go f (Bin p m l r)\n      = bin p m l1 r1 :*: bin p m l2 r2\n      where\n        (l1 :*: l2) = go f l\n        (r1 :*: r2) = go f r\n    go f (Tip k x) = case f k x of\n      Left !y  -> (Tip k y :*: Nil)\n      Right !z -> (Nil :*: Tip k z)\n    go _ Nil = (Nil :*: Nil)\n\n{--------------------------------------------------------------------\n  Conversions\n--------------------------------------------------------------------}\n\n-- | \\(O(n)\\). Build a map from a set of keys and a function which for each key\n-- computes its value.\n--\n-- > fromSet (\\k -> replicate k \'a\') (Data.IntSet.fromList [3, 5]) == fromList [(5,"aaaaa"), (3,"aaa")]\n-- > fromSet undefined Data.IntSet.empty == empty\n\nfromSet :: (Key -> a) -> IntSet.IntSet -> IntMap a\nfromSet _ IntSet.Nil = Nil\nfromSet f (IntSet.Bin p m l r) = Bin p m (fromSet f l) (fromSet f r)\nfromSet f (IntSet.Tip kx bm) = buildTree f kx bm (IntSet.suffixBitMask + 1)\n  where -- This is slightly complicated, as we to convert the dense\n        -- representation of IntSet into tree representation of IntMap.\n        --\n        -- We are given a nonzero bit mask \'bmask\' of \'bits\' bits with prefix \'prefix\'.\n        -- We split bmask into halves corresponding to left and right subtree.\n        -- If they are both nonempty, we create a Bin node, otherwise exactly\n        -- one of them is nonempty and we construct the IntMap from that half.\n        buildTree g !prefix !bmask bits = case bits of\n          0 -> Tip prefix $! g prefix\n          _ -> case intFromNat ((natFromInt bits) `shiftRL` 1) of\n                 bits2 | bmask .&. ((1 `shiftLL` bits2) - 1) == 0 ->\n                           buildTree g (prefix + bits2) (bmask `shiftRL` bits2) bits2\n                       | (bmask `shiftRL` bits2) .&. ((1 `shiftLL` bits2) - 1) == 0 ->\n                           buildTree g prefix bmask bits2\n                       | otherwise ->\n                           Bin prefix bits2 (buildTree g prefix bmask bits2) (buildTree g (prefix + bits2) (bmask `shiftRL` bits2) bits2)\n\n{--------------------------------------------------------------------\n  Lists\n--------------------------------------------------------------------}\n-- | \\(O(n \\min(n,W))\\). Create a map from a list of key\\/value pairs.\n--\n-- > fromList [] == empty\n-- > fromList [(5,"a"), (3,"b"), (5, "c")] == fromList [(5,"c"), (3,"b")]\n-- > fromList [(5,"c"), (3,"b"), (5, "a")] == fromList [(5,"a"), (3,"b")]\n\nfromList :: [(Key,a)] -> IntMap a\nfromList xs\n  = Foldable.foldl\' ins empty xs\n  where\n    ins t (k,x)  = insert k x t\n\n-- | \\(O(n \\min(n,W))\\). Create a map from a list of key\\/value pairs with a combining function. See also \'fromAscListWith\'.\n--\n-- > fromListWith (++) [(5,"a"), (5,"b"), (3,"b"), (3,"a"), (5,"a")] == fromList [(3, "ab"), (5, "aba")]\n-- > fromListWith (++) [] == empty\n\nfromListWith :: (a -> a -> a) -> [(Key,a)] -> IntMap a\nfromListWith f xs\n  = fromListWithKey (\\_ x y -> f x y) xs\n\n-- | \\(O(n \\min(n,W))\\). Build a map from a list of key\\/value pairs with a combining function. See also fromAscListWithKey\'.\n--\n-- > let f key new_value old_value = show key ++ ":" ++ new_value ++ "|" ++ old_value\n-- > fromListWithKey f [(5,"a"), (5,"b"), (3,"b"), (3,"a"), (5,"c")] == fromList [(3, "3:a|b"), (5, "5:c|5:b|a")]\n-- > fromListWithKey f [] == empty\n\nfromListWithKey :: (Key -> a -> a -> a) -> [(Key,a)] -> IntMap a\nfromListWithKey f xs\n  = Foldable.foldl\' ins empty xs\n  where\n    ins t (k,x) = insertWithKey f k x t\n\n-- | \\(O(n)\\). Build a map from a list of key\\/value pairs where\n-- the keys are in ascending order.\n--\n-- > fromAscList [(3,"b"), (5,"a")]          == fromList [(3, "b"), (5, "a")]\n-- > fromAscList [(3,"b"), (5,"a"), (5,"b")] == fromList [(3, "b"), (5, "b")]\n\nfromAscList :: [(Key,a)] -> IntMap a\nfromAscList = fromMonoListWithKey Nondistinct (\\_ x _ -> x)\n{-# NOINLINE fromAscList #-}\n\n-- | \\(O(n)\\). Build a map from a list of key\\/value pairs where\n-- the keys are in ascending order, with a combining function on equal keys.\n-- /The precondition (input list is ascending) is not checked./\n--\n-- > fromAscListWith (++) [(3,"b"), (5,"a"), (5,"b")] == fromList [(3, "b"), (5, "ba")]\n\nfromAscListWith :: (a -> a -> a) -> [(Key,a)] -> IntMap a\nfromAscListWith f = fromMonoListWithKey Nondistinct (\\_ x y -> f x y)\n{-# NOINLINE fromAscListWith #-}\n\n-- | \\(O(n)\\). Build a map from a list of key\\/value pairs where\n-- the keys are in ascending order, with a combining function on equal keys.\n-- /The precondition (input list is ascending) is not checked./\n--\n-- > fromAscListWith (++) [(3,"b"), (5,"a"), (5,"b")] == fromList [(3, "b"), (5, "ba")]\n\nfromAscListWithKey :: (Key -> a -> a -> a) -> [(Key,a)] -> IntMap a\nfromAscListWithKey f = fromMonoListWithKey Nondistinct f\n{-# NOINLINE fromAscListWithKey #-}\n\n-- | \\(O(n)\\). Build a map from a list of key\\/value pairs where\n-- the keys are in ascending order and all distinct.\n-- /The precondition (input list is strictly ascending) is not checked./\n--\n-- > fromDistinctAscList [(3,"b"), (5,"a")] == fromList [(3, "b"), (5, "a")]\n\nfromDistinctAscList :: [(Key,a)] -> IntMap a\nfromDistinctAscList = fromMonoListWithKey Distinct (\\_ x _ -> x)\n{-# NOINLINE fromDistinctAscList #-}\n\n-- | \\(O(n)\\). Build a map from a list of key\\/value pairs with monotonic keys\n-- and a combining function.\n--\n-- The precise conditions under which this function works are subtle:\n-- For any branch mask, keys with the same prefix w.r.t. the branch\n-- mask must occur consecutively in the list.\n\nfromMonoListWithKey :: Distinct -> (Key -> a -> a -> a) -> [(Key,a)] -> IntMap a\nfromMonoListWithKey distinct f = go\n  where\n    go []              = Nil\n    go ((kx,vx) : zs1) = addAll\' kx vx zs1\n\n    -- `addAll\'` collects all keys equal to `kx` into a single value,\n    -- and then proceeds with `addAll`.\n    addAll\' !kx vx []\n        = Tip kx $! vx\n    addAll\' !kx vx ((ky,vy) : zs)\n        | Nondistinct <- distinct, kx == ky\n        = let !v = f kx vy vx in addAll\' ky v zs\n        -- inlined: | otherwise = addAll kx (Tip kx $! vx) (ky : zs)\n        | m <- branchMask kx ky\n        , Inserted ty zs\' <- addMany\' m ky vy zs\n        = addAll kx (linkWithMask m ky ty {-kx-} (Tip kx $! vx)) zs\'\n\n    -- for `addAll` and `addMany`, kx is /a/ key inside the tree `tx`\n    -- `addAll` consumes the rest of the list, adding to the tree `tx`\n    addAll !_kx !tx []\n        = tx\n    addAll !kx !tx ((ky,vy) : zs)\n        | m <- branchMask kx ky\n        , Inserted ty zs\' <- addMany\' m ky vy zs\n        = addAll kx (linkWithMask m ky ty {-kx-} tx) zs\'\n\n    -- `addMany\'` is similar to `addAll\'`, but proceeds with `addMany\'`.\n    addMany\' !_m !kx vx []\n        = Inserted (Tip kx $! vx) []\n    addMany\' !m !kx vx zs0@((ky,vy) : zs)\n        | Nondistinct <- distinct, kx == ky\n        = let !v = f kx vy vx in addMany\' m ky v zs\n        -- inlined: | otherwise = addMany m kx (Tip kx $! vx) (ky : zs)\n        | mask kx m /= mask ky m\n        = Inserted (Tip kx $! vx) zs0\n        | mxy <- branchMask kx ky\n        , Inserted ty zs\' <- addMany\' mxy ky vy zs\n        = addMany m kx (linkWithMask mxy ky ty {-kx-} (Tip kx $! vx)) zs\'\n\n    -- `addAll` adds to `tx` all keys whose prefix w.r.t. `m` agrees with `kx`.\n    addMany !_m !_kx tx []\n        = Inserted tx []\n    addMany !m !kx tx zs0@((ky,vy) : zs)\n        | mask kx m /= mask ky m\n        = Inserted tx zs0\n        | mxy <- branchMask kx ky\n        , Inserted ty zs\' <- addMany\' mxy ky vy zs\n        = addMany m kx (linkWithMask mxy ky ty {-kx-} tx) zs\'\n{-# INLINE fromMonoListWithKey #-}\n\ndata Inserted a = Inserted !(IntMap a) ![(Key,a)]\n\ndata Distinct = Distinct | Nondistinct\n'