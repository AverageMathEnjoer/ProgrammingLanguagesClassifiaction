b'{-# LANGUAGE UndecidableInstances #-}\n\n-- | Defines classen \'SqlEq\' and \'SqlOrd\' that can be used to perform equality\n--   and comparison operations on certain expressions.\n--\n--   In particular, any \'Beamable\' value over \'QGenExpr\' or any \'QGenExpr\'\n--   object can be compared for equality and inequality using the \'(==.)\' and\n--   \'(/=.)\' operators respectively.\n--\n--   Simple (scalar) \'QGenExpr\'s can be compared using the \'(<.)\', \'(>.)\',\n--   \'(<=.)\', and \'(>=.)\' operators respectively.\n--\n--   The "Quantified Comparison Syntax" (i.e., @.. > ANY (..)@) is supported\n--   using the corresponding operators suffixed with a @*@ before the dot. For\n--   example, @x == ANY(SELECT ..)@ can be written.\n--\n-- > x ==*. anyOf_ ..\n--\n--   Or, for example, @x > ALL(SELECT ..)@ can be written\n--\n-- > x >*. allOf_ ..\nmodule Database.Beam.Query.Ord\n  ( SqlEq(..), SqlEqQuantified(..), SqlIn(..)\n  , HasSqlInTable(..)\n  , SqlOrd(..), SqlOrdQuantified(..)\n  , QQuantified(..)\n\n  , HasSqlEqualityCheck(..), HasSqlQuantifiedEqualityCheck(..)\n  , HasTableEquality, HasTableEqualityNullable\n\n  , isTrue_, isNotTrue_\n  , isFalse_, isNotFalse_\n  , isUnknown_, isNotUnknown_\n  , unknownAs_, sqlBool_\n  , possiblyNullBool_\n  , fromPossiblyNullBool_\n\n  , anyOf_, anyIn_\n  , allOf_, allIn_\n\n  , inQuery_\n\n  , between_\n  ) where\n\nimport Database.Beam.Query.Internal\nimport Database.Beam.Query.Types\nimport Database.Beam.Query.Operator\n\nimport Database.Beam.Schema.Tables\nimport Database.Beam.Backend.SQL\n-- import Database.Beam.Backend.SQL.AST (Expression)\n--import Database.Beam.Backend.SQL.Builder (SqlSyntaxBackend)\n\nimport Control.Applicative\nimport Control.Monad.State\n\nimport Data.Maybe\nimport Data.Proxy\nimport Data.Kind\nimport Data.Word\nimport Data.Int\nimport Data.Tagged\nimport Data.Text (Text)\nimport Data.Time (UTCTime, LocalTime, Day, TimeOfDay)\n\nimport GHC.TypeLits\n\n-- | A data structure representing the set to quantify a comparison operator over.\ndata QQuantified be s r\n  = QQuantified (BeamSqlBackendExpressionQuantifierSyntax be) (WithExprContext (BeamSqlBackendExpressionSyntax be))\n\n-- | Convert a /known not null/ bool to a \'SqlBool\'. See \'unknownAs_\' for the inverse\nsqlBool_ :: QGenExpr context syntax s Bool -> QGenExpr context syntax s SqlBool\nsqlBool_ (QExpr s) = QExpr s\n\n-- | SQL @IS TRUE@ operator\nisTrue_ :: BeamSqlBackend be\n        => QGenExpr context be s SqlBool -> QGenExpr context be s Bool\nisTrue_ (QExpr s) = QExpr (fmap isTrueE s)\n\n-- | SQL @IS NOT TRUE@ operator\nisNotTrue_ :: BeamSqlBackend be\n           => QGenExpr context be s SqlBool -> QGenExpr context be s Bool\nisNotTrue_ (QExpr s) = QExpr (fmap isNotTrueE s)\n\n-- | SQL @IS FALSE@ operator\nisFalse_ :: BeamSqlBackend be\n         => QGenExpr context be s SqlBool -> QGenExpr context be s Bool\nisFalse_ (QExpr s) = QExpr (fmap isFalseE s)\n\n-- | SQL @IS NOT FALSE@ operator\nisNotFalse_ :: BeamSqlBackend be\n            => QGenExpr context be s SqlBool -> QGenExpr context be s Bool\nisNotFalse_ (QExpr s) = QExpr (fmap isNotFalseE s)\n\n-- | SQL @IS UNKNOWN@ operator\nisUnknown_ :: BeamSqlBackend be\n           => QGenExpr context be s SqlBool -> QGenExpr context be s Bool\nisUnknown_ (QExpr s) = QExpr (fmap isUnknownE s)\n\n-- | SQL @IS NOT UNKNOWN@ operator\nisNotUnknown_ :: BeamSqlBackend be\n              => QGenExpr context be s SqlBool -> QGenExpr context be s Bool\nisNotUnknown_ (QExpr s) = QExpr (fmap isNotUnknownE s)\n\n-- | Return the first argument if the expression has the unknown SQL value\n-- See \'sqlBool_\' for the inverse\nunknownAs_ :: BeamSqlBackend be\n           => Bool -> QGenExpr context be s SqlBool -> QGenExpr context be s Bool\nunknownAs_ False = isTrue_ -- If unknown is being treated as false, then return true only if the expression is true\nunknownAs_ True  = isNotFalse_ -- If unknown is being treated as true, then return true only if the expression is not false\n\n-- | Retrieve a \'SqlBool\' value as a potentially @NULL@ \'Bool\'. This\n-- is useful if you want to get the value of a SQL boolean expression\n-- directly, without having to specify what to do on @UNKNOWN@. Note\n-- that both @NULL@ and @UNKNOWN@ will be returned as \'Nothing\'.\npossiblyNullBool_ :: QGenExpr context be s SqlBool -> QGenExpr context be s (Maybe Bool)\npossiblyNullBool_ (QExpr e) = QExpr e\n\n-- | Convert a possibly @NULL@ \'Bool\' to a \'SqlBool\'.\nfromPossiblyNullBool_ :: QGenExpr context be s (Maybe Bool) -> QGenExpr context be s SqlBool\nfromPossiblyNullBool_ (QExpr e) = QExpr e\n\n-- | A \'QQuantified\' representing a SQL @ALL(..)@ for use with a\n--   <#quantified-comparison-operator quantified comparison operator>\n--\n--   Accepts a subquery. Use \'allIn_\' for an explicit list\nallOf_\n  :: forall s a be db\n   . ( BeamSqlBackend be, HasQBuilder be )\n  => Q be db (QNested s) (QExpr be (QNested s) a)\n  -> QQuantified be s a\nallOf_ s = QQuantified quantifyOverAll (\\tblPfx -> subqueryE (buildSqlQuery tblPfx s))\n\n-- | A \'QQuantified\' representing a SQL @ALL(..)@ for use with a\n--   <#quantified-comparison-operator quantified comparison operator>\n--\n--   Accepts an explicit list of typed expressions. Use \'allOf_\' for\n--   a subquery\nallIn_\n  :: forall s a be\n   . BeamSqlBackend be\n  => [QExpr be s a]\n  -> QQuantified be s a\nallIn_ es = QQuantified quantifyOverAll (quantifierListE <$> mapM (\\(QExpr e) -> e) es)\n\n-- | A \'QQuantified\' representing a SQL @ANY(..)@ for use with a\n--   <#quantified-comparison-operator quantified comparison operator>\n--\n--   Accepts a subquery. Use \'anyIn_\' for an explicit list\nanyOf_\n  :: forall s a be db\n   . ( BeamSqlBackend be, HasQBuilder be )\n  => Q be db (QNested s) (QExpr be (QNested s) a)\n  -> QQuantified be s a\nanyOf_ s = QQuantified quantifyOverAny (\\tblPfx -> subqueryE (buildSqlQuery tblPfx s))\n\n-- | A \'QQuantified\' representing a SQL @ANY(..)@ for use with a\n--   <#quantified-comparison-operator quantified comparison operator>\n--\n--   Accepts an explicit list of typed expressions. Use \'anyOf_\' for\n--   a subquery\nanyIn_\n  :: forall s a be\n   . BeamSqlBackend be\n  => [QExpr be s a]\n  -> QQuantified be s a\nanyIn_ es = QQuantified quantifyOverAny (quantifierListE <$> mapM (\\(QExpr e) -> e) es)\n\n-- | SQL @BETWEEN@ clause\nbetween_ :: BeamSqlBackend be\n         => QGenExpr context be s a -> QGenExpr context be s a\n         -> QGenExpr context be s a -> QGenExpr context be s Bool\nbetween_ (QExpr a) (QExpr min_) (QExpr max_) =\n  QExpr (liftA3 betweenE a min_ max_)\n\nclass SqlIn expr a | a -> expr where\n  -- | SQL @IN@ predicate\n  in_ :: a -> [ a ] -> expr Bool\n\ninstance BeamSqlBackend be => SqlIn (QGenExpr context be s) (QGenExpr context be s a) where\n  in_ _ [] = QExpr (pure (valueE (sqlValueSyntax False)))\n  in_ (QExpr row) options = QExpr (inE <$> row <*> mapM (\\(QExpr o) -> o) options)\n\n-- | Class for backends which support SQL @IN@ on lists of row values, which is\n-- not part of ANSI SQL. This is useful for @IN@ on primary keys.\nclass BeamSqlBackend be => HasSqlInTable be where\n  inRowValuesE\n    :: Proxy be\n    -> BeamSqlBackendExpressionSyntax be\n    -> [ BeamSqlBackendExpressionSyntax be ]\n    -> BeamSqlBackendExpressionSyntax be\n  inRowValuesE Proxy = inE\n\ninstance ( HasSqlInTable be, Beamable table ) =>\n  SqlIn (QGenExpr context be s) (table (QGenExpr context be s)) where\n\n  in_ _ [] = QExpr (pure (valueE (sqlValueSyntax False)))\n  in_ row options = QExpr (inRowValuesE (Proxy @be) <$> toExpr row <*> (mapM toExpr options))\n    where toExpr :: table (QGenExpr context be s) -> TablePrefix -> BeamSqlBackendExpressionSyntax be\n          toExpr = fmap rowE . sequence . allBeamValues (\\(Columnar\' (QExpr x)) -> x)\n\ninfix 4 `between_`, `in_`, `inQuery_`\n\ninQuery_ :: (HasQBuilder be, BeamSqlBackend be)\n         => QGenExpr ctx be s a -> Q be db s (QExpr be s a) -> QGenExpr ctx be s Bool\ninQuery_ (QExpr needle) haystack = QExpr (inSelectE <$> needle <*> flip buildSqlQuery haystack)\n\n-- | Class for expression types or expression containers for which there is a\n--   notion of equality.\n--\n--   Instances are provided to check the equality of expressions of the same\n--   type as well as entire \'Beamable\' types parameterized over \'QGenExpr\'\nclass SqlEq expr a | a -> expr where\n  -- | Given two expressions, returns whether they are equal, using Haskell semantics (NULLs handled properly)\n  (==.) :: a -> a -> expr Bool\n  -- | Given two expressions, returns whether they are not equal, using Haskell semantics (NULLs handled properly)\n  (/=.) :: a -> a -> expr Bool\n\n  -- | Given two expressions, returns the /SQL tri-state boolean/ when compared for equality\n  (==?.) :: a -> a -> expr SqlBool\n\n  -- | Given two expressions, returns the /SQL tri-state boolean/ when compared for inequality\n  (/=?.) :: a -> a -> expr SqlBool\n\n-- | Class for expression types for which there is a notion of /quantified/\n--   equality.\nclass SqlEq expr a => SqlEqQuantified expr quantified a | a -> expr quantified where\n\n  -- | Quantified equality and inequality using /SQL semantics/ (tri-state boolean)\n  (==*.), (/=*.) :: a -> quantified -> expr SqlBool\n\ninfix 4 ==., /=., ==?., /=?., ==*., /=*.\ninfix 4 <., >., <=., >=.\ninfix 4 <*., >*., <=*., >=*.\n\n-- | Class for Haskell types that can be compared for equality in the given backend\nclass BeamSqlBackend be => HasSqlEqualityCheck be a where\n\n  sqlEqE, sqlNeqE :: Proxy a -> Proxy be\n                  -> BeamSqlBackendExpressionSyntax be\n                  -> BeamSqlBackendExpressionSyntax be\n                  -> BeamSqlBackendExpressionSyntax be\n  sqlEqE _ _ = eqE Nothing\n  sqlNeqE _ _ = neqE Nothing\n\n  -- | Tri-state equality\n  sqlEqTriE, sqlNeqTriE :: Proxy a -> Proxy be\n                        -> BeamSqlBackendExpressionSyntax be\n                        -> BeamSqlBackendExpressionSyntax be\n                        -> BeamSqlBackendExpressionSyntax be\n  sqlEqTriE _ _ = eqE Nothing\n  sqlNeqTriE _ _ = neqE Nothing\n\ntype family CanCheckMaybeEquality a :: Constraint where\n  CanCheckMaybeEquality (Maybe a) =\n    TypeError (\'Text "Attempt to check equality of nested Maybe." \':$$:\n               \'Text "Beam can only reasonably check equality of a single nesting of Maybe.")\n  CanCheckMaybeEquality a = ()\n\ninstance (HasSqlEqualityCheck be a, CanCheckMaybeEquality a) => HasSqlEqualityCheck be (Maybe a) where\n  sqlEqE _ _ a b = eqMaybeE a b (sqlEqE (Proxy @a) (Proxy @be) a b)\n  sqlNeqE _ _ a b = neqMaybeE a b (sqlNeqE (Proxy @a) (Proxy @be) a b)\n\ninstance HasSqlEqualityCheck be a => HasSqlEqualityCheck be (SqlSerial a) where\n  sqlEqE _ = sqlEqE (Proxy @a)\n  sqlNeqE _ = sqlNeqE (Proxy @a)\n\n  sqlEqTriE _ = sqlEqTriE (Proxy @a)\n  sqlNeqTriE _ = sqlNeqTriE (Proxy @a)\n\n-- | Class for Haskell types that can be compared for quantified equality in the given backend\nclass HasSqlEqualityCheck be a => HasSqlQuantifiedEqualityCheck be a where\n  sqlQEqE, sqlQNeqE :: Proxy a -> Proxy be\n                    -> Maybe (BeamSqlBackendExpressionQuantifierSyntax be)\n                    -> BeamSqlBackendExpressionSyntax be\n                    -> BeamSqlBackendExpressionSyntax be\n                    -> BeamSqlBackendExpressionSyntax be\n  sqlQEqE _ _ = eqE\n  sqlQNeqE _ _ = neqE\n\ninstance (HasSqlQuantifiedEqualityCheck syntax a, CanCheckMaybeEquality a) => HasSqlQuantifiedEqualityCheck syntax (Maybe a) where\n  sqlQEqE _ = sqlQEqE (Proxy @a)\n  sqlQNeqE _ = sqlQNeqE (Proxy @a)\n\ninstance HasSqlQuantifiedEqualityCheck syntax a => HasSqlQuantifiedEqualityCheck syntax (SqlSerial a) where\n  sqlQEqE _ = sqlQEqE (Proxy @a)\n  sqlQNeqE _ = sqlQNeqE (Proxy @a)\n\n-- | Compare two arbitrary expressions (of the same type) for equality\ninstance ( BeamSqlBackend be, HasSqlEqualityCheck be a ) =>\n  SqlEq (QGenExpr context be s) (QGenExpr context be s a) where\n\n  (==.) = qBinOpE (sqlEqE (Proxy @a) (Proxy @be))\n  (/=.) = qBinOpE (sqlNeqE (Proxy @a) (Proxy @be))\n\n  (==?.) = qBinOpE (sqlEqTriE (Proxy @a) (Proxy @be))\n  (/=?.) = qBinOpE (sqlNeqTriE (Proxy @a) (Proxy @be))\n\n-- | Two arbitrary expressions can be quantifiably compared for equality.\ninstance ( BeamSqlBackend be, HasSqlQuantifiedEqualityCheck be a ) =>\n  SqlEqQuantified (QGenExpr context be s) (QQuantified be s a) (QGenExpr context be s a) where\n\n  a ==*. QQuantified q b = qBinOpE (sqlQEqE (Proxy @a) (Proxy @be) (Just q)) a (QExpr b)\n  a /=*. QQuantified q b = qBinOpE (sqlQNeqE (Proxy @a) (Proxy @be) (Just q)) a (QExpr b)\n\n-- | Constraint synonym to check if two tables can be compared for equality\ntype HasTableEquality be tbl =\n  (FieldsFulfillConstraint (HasSqlEqualityCheck be) tbl, Beamable tbl)\ntype HasTableEqualityNullable be tbl =\n  (FieldsFulfillConstraintNullable (HasSqlEqualityCheck be) tbl, Beamable tbl)\n\n-- | Compare two arbitrary \'Beamable\' types containing \'QGenExpr\'s for equality.\ninstance ( BeamSqlBackend be, Beamable tbl\n         , FieldsFulfillConstraint (HasSqlEqualityCheck be) tbl ) =>\n         SqlEq (QGenExpr context be s) (tbl (QGenExpr context be s)) where\n\n  a ==. b = let (_, e) = runState (zipBeamFieldsM\n                                   (\\x\'@(Columnar\' (Columnar\' HasConstraint :*: Columnar\' x)) (Columnar\' y) ->\n                                       do modify (\\expr ->\n                                                    case expr of\n                                                      Nothing -> Just $ x ==. y\n                                                      Just expr\' -> Just $ expr\' &&. x ==. y)\n                                          return x\') (withConstraints @(HasSqlEqualityCheck be) `alongsideTable` a) b) Nothing\n            in fromMaybe (QExpr (\\_ -> valueE (sqlValueSyntax True))) e\n  a /=. b = not_ (a ==. b)\n\n  a ==?. b = let (_, e) = runState (zipBeamFieldsM\n                                    (\\x\'@(Columnar\' (Columnar\' HasConstraint :*: Columnar\' x)) (Columnar\' y) ->\n                                        do modify (\\expr ->\n                                                     case expr of\n                                                       Nothing -> Just $ x ==?. y\n                                                       Just expr\' -> Just $ expr\' &&?. x ==?. y)\n                                           return x\') (withConstraints @(HasSqlEqualityCheck be) `alongsideTable` a) b) Nothing\n            in fromMaybe (QExpr (\\_ -> valueE (sqlValueSyntax True))) e\n  a /=?. b = sqlNot_ (a ==?. b)\n\ninstance ( BeamSqlBackend be, Beamable tbl\n         , FieldsFulfillConstraintNullable (HasSqlEqualityCheck be) tbl )\n    => SqlEq (QGenExpr context be s) (tbl (Nullable (QGenExpr context be s))) where\n\n  a ==. b = let (_, e) = runState (zipBeamFieldsM\n                                      (\\x\'@(Columnar\' (Columnar\' HasConstraint :*: Columnar\' x)) (Columnar\' y) -> do\n                                          modify (\\expr ->\n                                                    case expr of\n                                                      Nothing -> Just $ x ==. y\n                                                      Just expr\' -> Just $ expr\' &&. x ==. y)\n                                          return x\')\n                                      (withNullableConstraints @(HasSqlEqualityCheck be) `alongsideTable` a) b) Nothing\n            in fromMaybe (QExpr (\\_ -> valueE (sqlValueSyntax True))) e\n  a /=. b = not_ (a ==. b)\n\n  a ==?. b = let (_, e) = runState (zipBeamFieldsM\n                                    (\\x\'@(Columnar\' (Columnar\' HasConstraint :*: Columnar\' x)) (Columnar\' y) ->\n                                        do modify (\\expr ->\n                                                     case expr of\n                                                       Nothing -> Just $ x ==?. y\n                                                       Just expr\' -> Just $ expr\' &&?. x ==?. y)\n                                           return x\') (withNullableConstraints @(HasSqlEqualityCheck be) `alongsideTable` a) b) Nothing\n            in fromMaybe (QExpr (\\_ -> valueE (sqlValueSyntax True))) e\n  a /=?. b = sqlNot_ (a ==?. b)\n\n\n-- * Comparisons\n\n-- | Class for expression types or expression containers for which there is a\n--   notion of ordering.\n--\n--   Instances are provided to check the ordering of expressions of the same\n--   type. Since there is no universal notion of ordering for an arbitrary\n--   number of expressions, no instance is provided for \'Beamable\' types.\nclass SqlOrd expr e | e -> expr where\n\n  (<.), (>.), (<=.), (>=.) :: e -> e -> expr Bool\n\n-- | Class for things which can be /quantifiably/ compared.\nclass SqlOrd expr e =>\n  SqlOrdQuantified expr quantified e | e -> expr quantified where\n\n  (<*.), (>*.), (<=*.), (>=*.) :: e -> quantified  -> expr Bool\n\ninstance BeamSqlBackend be =>\n  SqlOrd (QGenExpr context be s) (QGenExpr context be s a) where\n\n  (<.) = qBinOpE (ltE Nothing)\n  (>.) = qBinOpE (gtE Nothing)\n  (<=.) = qBinOpE (leE Nothing)\n  (>=.) = qBinOpE (geE Nothing)\n\ninstance BeamSqlBackend be =>\n  SqlOrdQuantified (QGenExpr context be s) (QQuantified be s a) (QGenExpr context be s a) where\n  a <*. QQuantified q b = qBinOpE (ltE (Just q)) a (QExpr b)\n  a <=*. QQuantified q b = qBinOpE (leE (Just q)) a (QExpr b)\n  a >*. QQuantified q b = qBinOpE (gtE (Just q)) a (QExpr b)\n  a >=*. QQuantified q b = qBinOpE (geE (Just q)) a (QExpr b)\n\ninstance BeamSqlBackend (MockSqlBackend cmd) => HasSqlEqualityCheck (MockSqlBackend cmd) Text\ninstance BeamSqlBackend (MockSqlBackend cmd) => HasSqlEqualityCheck (MockSqlBackend cmd) Integer\ninstance BeamSqlBackend (MockSqlBackend cmd) => HasSqlEqualityCheck (MockSqlBackend cmd) Int\ninstance BeamSqlBackend (MockSqlBackend cmd) => HasSqlEqualityCheck (MockSqlBackend cmd) Int8\ninstance BeamSqlBackend (MockSqlBackend cmd) => HasSqlEqualityCheck (MockSqlBackend cmd) Int16\ninstance BeamSqlBackend (MockSqlBackend cmd) => HasSqlEqualityCheck (MockSqlBackend cmd) Int32\ninstance BeamSqlBackend (MockSqlBackend cmd) => HasSqlEqualityCheck (MockSqlBackend cmd) Int64\ninstance BeamSqlBackend (MockSqlBackend cmd) => HasSqlEqualityCheck (MockSqlBackend cmd) Word\ninstance BeamSqlBackend (MockSqlBackend cmd) => HasSqlEqualityCheck (MockSqlBackend cmd) Word8\ninstance BeamSqlBackend (MockSqlBackend cmd) => HasSqlEqualityCheck (MockSqlBackend cmd) Word16\ninstance BeamSqlBackend (MockSqlBackend cmd) => HasSqlEqualityCheck (MockSqlBackend cmd) Word32\ninstance BeamSqlBackend (MockSqlBackend cmd) => HasSqlEqualityCheck (MockSqlBackend cmd) Word64\ninstance BeamSqlBackend (MockSqlBackend cmd) => HasSqlEqualityCheck (MockSqlBackend cmd) Double\ninstance BeamSqlBackend (MockSqlBackend cmd) => HasSqlEqualityCheck (MockSqlBackend cmd) Float\ninstance BeamSqlBackend (MockSqlBackend cmd) => HasSqlEqualityCheck (MockSqlBackend cmd) Bool\ninstance BeamSqlBackend (MockSqlBackend cmd) => HasSqlEqualityCheck (MockSqlBackend cmd) UTCTime\ninstance BeamSqlBackend (MockSqlBackend cmd) => HasSqlEqualityCheck (MockSqlBackend cmd) LocalTime\ninstance BeamSqlBackend (MockSqlBackend cmd) => HasSqlEqualityCheck (MockSqlBackend cmd) Day\ninstance BeamSqlBackend (MockSqlBackend cmd) => HasSqlEqualityCheck (MockSqlBackend cmd) TimeOfDay\ninstance ( BeamSqlBackend (MockSqlBackend cmd)\n         , HasSqlEqualityCheck (MockSqlBackend cmd) a\n         ) => HasSqlEqualityCheck (MockSqlBackend cmd) (Tagged t a)\n\ninstance BeamSqlBackend (MockSqlBackend cmd) => HasSqlQuantifiedEqualityCheck (MockSqlBackend cmd) Text\ninstance BeamSqlBackend (MockSqlBackend cmd) => HasSqlQuantifiedEqualityCheck (MockSqlBackend cmd) Integer\ninstance BeamSqlBackend (MockSqlBackend cmd) => HasSqlQuantifiedEqualityCheck (MockSqlBackend cmd) Int\ninstance BeamSqlBackend (MockSqlBackend cmd) => HasSqlQuantifiedEqualityCheck (MockSqlBackend cmd) Int8\ninstance BeamSqlBackend (MockSqlBackend cmd) => HasSqlQuantifiedEqualityCheck (MockSqlBackend cmd) Int16\ninstance BeamSqlBackend (MockSqlBackend cmd) => HasSqlQuantifiedEqualityCheck (MockSqlBackend cmd) Int32\ninstance BeamSqlBackend (MockSqlBackend cmd) => HasSqlQuantifiedEqualityCheck (MockSqlBackend cmd) Int64\ninstance BeamSqlBackend (MockSqlBackend cmd) => HasSqlQuantifiedEqualityCheck (MockSqlBackend cmd) Word\ninstance BeamSqlBackend (MockSqlBackend cmd) => HasSqlQuantifiedEqualityCheck (MockSqlBackend cmd) Word8\ninstance BeamSqlBackend (MockSqlBackend cmd) => HasSqlQuantifiedEqualityCheck (MockSqlBackend cmd) Word16\ninstance BeamSqlBackend (MockSqlBackend cmd) => HasSqlQuantifiedEqualityCheck (MockSqlBackend cmd) Word32\ninstance BeamSqlBackend (MockSqlBackend cmd) => HasSqlQuantifiedEqualityCheck (MockSqlBackend cmd) Word64\ninstance BeamSqlBackend (MockSqlBackend cmd) => HasSqlQuantifiedEqualityCheck (MockSqlBackend cmd) Double\ninstance BeamSqlBackend (MockSqlBackend cmd) => HasSqlQuantifiedEqualityCheck (MockSqlBackend cmd) Float\ninstance BeamSqlBackend (MockSqlBackend cmd) => HasSqlQuantifiedEqualityCheck (MockSqlBackend cmd) Bool\ninstance BeamSqlBackend (MockSqlBackend cmd) => HasSqlQuantifiedEqualityCheck (MockSqlBackend cmd) UTCTime\ninstance BeamSqlBackend (MockSqlBackend cmd) => HasSqlQuantifiedEqualityCheck (MockSqlBackend cmd) LocalTime\ninstance BeamSqlBackend (MockSqlBackend cmd) => HasSqlQuantifiedEqualityCheck (MockSqlBackend cmd) Day\ninstance BeamSqlBackend (MockSqlBackend cmd) => HasSqlQuantifiedEqualityCheck (MockSqlBackend cmd) TimeOfDay\ninstance ( BeamSqlBackend (MockSqlBackend cmd)\n         , HasSqlQuantifiedEqualityCheck (MockSqlBackend cmd) a\n         ) => HasSqlQuantifiedEqualityCheck (MockSqlBackend cmd) (Tagged t a)\n\n'