b'package com.codeest.geeknews.component;\r\n\r\nimport android.content.Context;\r\nimport android.graphics.Bitmap;\r\nimport android.graphics.BitmapFactory;\r\nimport android.graphics.Canvas;\r\nimport android.graphics.PixelFormat;\r\nimport android.graphics.drawable.BitmapDrawable;\r\nimport android.graphics.drawable.Drawable;\r\n\r\nimport com.codeest.geeknews.app.Constants;\r\n\r\nimport org.json.JSONArray;\r\nimport org.json.JSONObject;\r\n\r\nimport java.io.BufferedReader;\r\nimport java.io.BufferedWriter;\r\nimport java.io.ByteArrayInputStream;\r\nimport java.io.ByteArrayOutputStream;\r\nimport java.io.File;\r\nimport java.io.FileOutputStream;\r\nimport java.io.FileReader;\r\nimport java.io.FileWriter;\r\nimport java.io.IOException;\r\nimport java.io.ObjectInputStream;\r\nimport java.io.ObjectOutputStream;\r\nimport java.io.RandomAccessFile;\r\nimport java.io.Serializable;\r\nimport java.math.BigDecimal;\r\nimport java.util.Collections;\r\nimport java.util.HashMap;\r\nimport java.util.Map;\r\nimport java.util.Map.Entry;\r\nimport java.util.Set;\r\nimport java.util.concurrent.atomic.AtomicInteger;\r\nimport java.util.concurrent.atomic.AtomicLong;\r\n\r\n/**\r\n * @author Michael Yang\xef\xbc\x88www.yangfuhai.com\xef\xbc\x89 update at 2013.08.07\r\n */\r\npublic class ACache {\r\n    public static final int TIME_HOUR = 60 * 60;\r\n    public static final int TIME_DAY = TIME_HOUR * 24;\r\n    private static final int MAX_SIZE = 1000 * 1000 * 50; // 50 mb\r\n    private static final int MAX_COUNT = Integer.MAX_VALUE; // \xe4\xb8\x8d\xe9\x99\x90\xe5\x88\xb6\xe5\xad\x98\xe6\x94\xbe\xe6\x95\xb0\xe6\x8d\xae\xe7\x9a\x84\xe6\x95\xb0\xe9\x87\x8f\r\n    private static Map<String, ACache> mInstanceMap = new HashMap<String, ACache>();\r\n    private ACacheManager mCache;\r\n\r\n\r\n    public static ACache get(Context ctx) {\r\n        return get(ctx, "Data");\r\n    }\r\n\r\n\r\n    public static ACache get(Context ctx, String cacheName) {\r\n        File f = new File(Constants.PATH_DATA, cacheName);\r\n        return get(f, MAX_SIZE, MAX_COUNT);\r\n    }\r\n\r\n\r\n    public static ACache get(File cacheDir) {\r\n        return get(cacheDir, MAX_SIZE, MAX_COUNT);\r\n    }\r\n\r\n\r\n    public static ACache get(Context ctx, long max_zise, int max_count) {\r\n        File f = new File(Constants.PATH_DATA, "Data");\r\n        return get(f, max_zise, max_count);\r\n    }\r\n\r\n\r\n    public static ACache get(File cacheDir, long max_zise, int max_count) {\r\n        ACache manager = mInstanceMap.get(cacheDir.getAbsoluteFile() + myPid());\r\n        if (manager == null) {\r\n            manager = new ACache(cacheDir, max_zise, max_count);\r\n            mInstanceMap.put(cacheDir.getAbsolutePath() + myPid(), manager);\r\n        }\r\n        return manager;\r\n    }\r\n\r\n    public static boolean deleteDir(File dir) {\r\n        if (dir != null && dir.isDirectory()) {\r\n            String[] children = dir.list();\r\n            for (String aChildren : children) {\r\n                boolean success = deleteDir(new File(dir, aChildren));\r\n                if (!success) {\r\n                    return false;\r\n                }\r\n            }\r\n        }\r\n        assert dir != null;\r\n        return dir.delete();\r\n    }\r\n\r\n    public static String getCacheSize(File file) {\r\n        return getFormatSize(getFolderSize(file));\r\n    }\r\n\r\n    public static long getFolderSize(File file) {\r\n        long size = 0;\r\n        try {\r\n            File[] fileList = file.listFiles();\r\n            for (File aFileList : fileList) {\r\n                // \xe5\xa6\x82\xe6\x9e\x9c\xe4\xb8\x8b\xe9\x9d\xa2\xe8\xbf\x98\xe6\x9c\x89\xe6\x96\x87\xe4\xbb\xb6\r\n                if (aFileList.isDirectory()) {\r\n                    size = size + getFolderSize(aFileList);\r\n                } else {\r\n                    size = size + aFileList.length();\r\n                }\r\n            }\r\n        } catch (Exception e) {\r\n            e.printStackTrace();\r\n        }\r\n        return size;\r\n    }\r\n\r\n    public static String getFormatSize(double size) {\r\n        double kiloByte = size / 1024;\r\n        if (kiloByte < 1) {\r\n//            return size + "Byte";\r\n            return "0K";\r\n        }\r\n\r\n        double megaByte = kiloByte / 1024;\r\n        if (megaByte < 1) {\r\n            BigDecimal result1 = new BigDecimal(Double.toString(kiloByte));\r\n            return result1.setScale(2, BigDecimal.ROUND_HALF_UP)\r\n                    .toPlainString() + "KB";\r\n        }\r\n\r\n        double gigaByte = megaByte / 1024;\r\n        if (gigaByte < 1) {\r\n            BigDecimal result2 = new BigDecimal(Double.toString(megaByte));\r\n            return result2.setScale(2, BigDecimal.ROUND_HALF_UP)\r\n                    .toPlainString() + "MB";\r\n        }\r\n\r\n        double teraBytes = gigaByte / 1024;\r\n        if (teraBytes < 1) {\r\n            BigDecimal result3 = new BigDecimal(Double.toString(gigaByte));\r\n            return result3.setScale(2, BigDecimal.ROUND_HALF_UP)\r\n                    .toPlainString() + "GB";\r\n        }\r\n        BigDecimal result4 = new BigDecimal(teraBytes);\r\n        return result4.setScale(2, BigDecimal.ROUND_HALF_UP).toPlainString()\r\n                + "TB";\r\n    }\r\n\r\n\r\n    private static String myPid() {\r\n        return "_" + android.os.Process.myPid();\r\n    }\r\n\r\n\r\n    private ACache(File cacheDir, long max_size, int max_count) {\r\n        if (!cacheDir.exists() && !cacheDir.mkdirs()) {\r\n            throw new RuntimeException("can\'t make dirs in " + cacheDir.getAbsolutePath());\r\n        }\r\n        mCache = new ACacheManager(cacheDir, max_size, max_count);\r\n    }\r\n\r\n    // =======================================\r\n    // ============ String\xe6\x95\xb0\xe6\x8d\xae \xe8\xaf\xbb\xe5\x86\x99 ==============\r\n    // =======================================\r\n\r\n\r\n    /**\r\n     * \xe4\xbf\x9d\xe5\xad\x98 String\xe6\x95\xb0\xe6\x8d\xae \xe5\x88\xb0 \xe7\xbc\x93\xe5\xad\x98\xe4\xb8\xad\r\n     *\r\n     * @param key \xe4\xbf\x9d\xe5\xad\x98\xe7\x9a\x84key\r\n     * @param value \xe4\xbf\x9d\xe5\xad\x98\xe7\x9a\x84String\xe6\x95\xb0\xe6\x8d\xae\r\n     */\r\n    public void put(String key, String value) {\r\n        File file = mCache.newFile(key);\r\n        BufferedWriter out = null;\r\n        try {\r\n            out = new BufferedWriter(new FileWriter(file), 1024);\r\n            out.write(value);\r\n        } catch (IOException e) {\r\n            e.printStackTrace();\r\n        } finally {\r\n            if (out != null) {\r\n                try {\r\n                    out.flush();\r\n                    out.close();\r\n                } catch (IOException e) {\r\n                    e.printStackTrace();\r\n                }\r\n            }\r\n            mCache.put(file);\r\n        }\r\n    }\r\n\r\n\r\n    /**\r\n     * \xe4\xbf\x9d\xe5\xad\x98 String\xe6\x95\xb0\xe6\x8d\xae \xe5\x88\xb0 \xe7\xbc\x93\xe5\xad\x98\xe4\xb8\xad\r\n     *\r\n     * @param key \xe4\xbf\x9d\xe5\xad\x98\xe7\x9a\x84key\r\n     * @param value \xe4\xbf\x9d\xe5\xad\x98\xe7\x9a\x84String\xe6\x95\xb0\xe6\x8d\xae\r\n     * @param saveTime \xe4\xbf\x9d\xe5\xad\x98\xe7\x9a\x84\xe6\x97\xb6\xe9\x97\xb4\xef\xbc\x8c\xe5\x8d\x95\xe4\xbd\x8d\xef\xbc\x9a\xe7\xa7\x92\r\n     */\r\n    public void put(String key, String value, int saveTime) {\r\n        put(key, Utils.newStringWithDateInfo(saveTime, value));\r\n    }\r\n\r\n\r\n    /**\r\n     * \xe8\xaf\xbb\xe5\x8f\x96 String\xe6\x95\xb0\xe6\x8d\xae\r\n     *\r\n     * @return String \xe6\x95\xb0\xe6\x8d\xae\r\n     */\r\n    public String getAsString(String key) {\r\n        File file = mCache.get(key);\r\n        if (!file.exists()) return null;\r\n        boolean removeFile = false;\r\n        BufferedReader in = null;\r\n        try {\r\n            in = new BufferedReader(new FileReader(file));\r\n            String readString = "";\r\n            String currentLine;\r\n            while ((currentLine = in.readLine()) != null) {\r\n                readString += currentLine;\r\n            }\r\n            if (!Utils.isDue(readString)) {\r\n                return Utils.clearDateInfo(readString);\r\n            }\r\n            else {\r\n                removeFile = true;\r\n                return null;\r\n            }\r\n        } catch (IOException e) {\r\n            e.printStackTrace();\r\n            return null;\r\n        } finally {\r\n            if (in != null) {\r\n                try {\r\n                    in.close();\r\n                } catch (IOException e) {\r\n                    e.printStackTrace();\r\n                }\r\n            }\r\n            if (removeFile) remove(key);\r\n        }\r\n    }\r\n\r\n    // =======================================\r\n    // ============= JSONObject \xe6\x95\xb0\xe6\x8d\xae \xe8\xaf\xbb\xe5\x86\x99 ==============\r\n    // =======================================\r\n\r\n\r\n    /**\r\n     * \xe4\xbf\x9d\xe5\xad\x98 JSONObject\xe6\x95\xb0\xe6\x8d\xae \xe5\x88\xb0 \xe7\xbc\x93\xe5\xad\x98\xe4\xb8\xad\r\n     *  @param key \xe4\xbf\x9d\xe5\xad\x98\xe7\x9a\x84key\r\n     * @param value \xe4\xbf\x9d\xe5\xad\x98\xe7\x9a\x84JSON\xe6\x95\xb0\xe6\x8d\xae\r\n     */\r\n    public void put(String key, JSONObject value) {\r\n        put(key, value.toString());\r\n    }\r\n\r\n\r\n    /**\r\n     * \xe4\xbf\x9d\xe5\xad\x98 JSONObject\xe6\x95\xb0\xe6\x8d\xae \xe5\x88\xb0 \xe7\xbc\x93\xe5\xad\x98\xe4\xb8\xad\r\n     *\r\n     * @param key \xe4\xbf\x9d\xe5\xad\x98\xe7\x9a\x84key\r\n     * @param value \xe4\xbf\x9d\xe5\xad\x98\xe7\x9a\x84JSONObject\xe6\x95\xb0\xe6\x8d\xae\r\n     * @param saveTime \xe4\xbf\x9d\xe5\xad\x98\xe7\x9a\x84\xe6\x97\xb6\xe9\x97\xb4\xef\xbc\x8c\xe5\x8d\x95\xe4\xbd\x8d\xef\xbc\x9a\xe7\xa7\x92\r\n     */\r\n    public void put(String key, JSONObject value, int saveTime) {\r\n        put(key, value.toString(), saveTime);\r\n    }\r\n\r\n\r\n    /**\r\n     * \xe8\xaf\xbb\xe5\x8f\x96JSONObject\xe6\x95\xb0\xe6\x8d\xae\r\n     *\r\n     * @return JSONObject\xe6\x95\xb0\xe6\x8d\xae\r\n     */\r\n    public JSONObject getAsJSONObject(String key) {\r\n        String JSONString = getAsString(key);\r\n        try {\r\n            JSONObject obj = new JSONObject(JSONString);\r\n            return obj;\r\n        } catch (Exception e) {\r\n            e.printStackTrace();\r\n            return null;\r\n        }\r\n    }\r\n\r\n    // =======================================\r\n    // ============ JSONArray \xe6\x95\xb0\xe6\x8d\xae \xe8\xaf\xbb\xe5\x86\x99 =============\r\n    // =======================================\r\n\r\n\r\n    /**\r\n     * \xe4\xbf\x9d\xe5\xad\x98 JSONArray\xe6\x95\xb0\xe6\x8d\xae \xe5\x88\xb0 \xe7\xbc\x93\xe5\xad\x98\xe4\xb8\xad\r\n     *\r\n     * @param key \xe4\xbf\x9d\xe5\xad\x98\xe7\x9a\x84key\r\n     * @param value \xe4\xbf\x9d\xe5\xad\x98\xe7\x9a\x84JSONArray\xe6\x95\xb0\xe6\x8d\xae\r\n     */\r\n    public void put(String key, JSONArray value) {\r\n        put(key, value.toString());\r\n    }\r\n\r\n\r\n    /**\r\n     * \xe4\xbf\x9d\xe5\xad\x98 JSONArray\xe6\x95\xb0\xe6\x8d\xae \xe5\x88\xb0 \xe7\xbc\x93\xe5\xad\x98\xe4\xb8\xad\r\n     *\r\n     * @param key \xe4\xbf\x9d\xe5\xad\x98\xe7\x9a\x84key\r\n     * @param value \xe4\xbf\x9d\xe5\xad\x98\xe7\x9a\x84JSONArray\xe6\x95\xb0\xe6\x8d\xae\r\n     * @param saveTime \xe4\xbf\x9d\xe5\xad\x98\xe7\x9a\x84\xe6\x97\xb6\xe9\x97\xb4\xef\xbc\x8c\xe5\x8d\x95\xe4\xbd\x8d\xef\xbc\x9a\xe7\xa7\x92\r\n     */\r\n    public void put(String key, JSONArray value, int saveTime) {\r\n        put(key, value.toString(), saveTime);\r\n    }\r\n\r\n\r\n    /**\r\n     * \xe8\xaf\xbb\xe5\x8f\x96JSONArray\xe6\x95\xb0\xe6\x8d\xae\r\n     *\r\n     * @return JSONArray\xe6\x95\xb0\xe6\x8d\xae\r\n     */\r\n    public JSONArray getAsJSONArray(String key) {\r\n        String JSONString = getAsString(key);\r\n        try {\r\n            JSONArray obj = new JSONArray(JSONString);\r\n            return obj;\r\n        } catch (Exception e) {\r\n            e.printStackTrace();\r\n            return null;\r\n        }\r\n    }\r\n\r\n    // =======================================\r\n    // ============== byte \xe6\x95\xb0\xe6\x8d\xae \xe8\xaf\xbb\xe5\x86\x99 =============\r\n    // =======================================\r\n\r\n\r\n    /**\r\n     * \xe4\xbf\x9d\xe5\xad\x98 byte\xe6\x95\xb0\xe6\x8d\xae \xe5\x88\xb0 \xe7\xbc\x93\xe5\xad\x98\xe4\xb8\xad\r\n     *\r\n     * @param key \xe4\xbf\x9d\xe5\xad\x98\xe7\x9a\x84key\r\n     * @param value \xe4\xbf\x9d\xe5\xad\x98\xe7\x9a\x84\xe6\x95\xb0\xe6\x8d\xae\r\n     */\r\n    public void put(String key, byte[] value) {\r\n        File file = mCache.newFile(key);\r\n        FileOutputStream out = null;\r\n        try {\r\n            out = new FileOutputStream(file);\r\n            out.write(value);\r\n        } catch (Exception e) {\r\n            e.printStackTrace();\r\n        } finally {\r\n            if (out != null) {\r\n                try {\r\n                    out.flush();\r\n                    out.close();\r\n                } catch (IOException e) {\r\n                    e.printStackTrace();\r\n                }\r\n            }\r\n            mCache.put(file);\r\n        }\r\n    }\r\n\r\n\r\n    /**\r\n     * \xe4\xbf\x9d\xe5\xad\x98 byte\xe6\x95\xb0\xe6\x8d\xae \xe5\x88\xb0 \xe7\xbc\x93\xe5\xad\x98\xe4\xb8\xad\r\n     *\r\n     * @param key \xe4\xbf\x9d\xe5\xad\x98\xe7\x9a\x84key\r\n     * @param value \xe4\xbf\x9d\xe5\xad\x98\xe7\x9a\x84\xe6\x95\xb0\xe6\x8d\xae\r\n     * @param saveTime \xe4\xbf\x9d\xe5\xad\x98\xe7\x9a\x84\xe6\x97\xb6\xe9\x97\xb4\xef\xbc\x8c\xe5\x8d\x95\xe4\xbd\x8d\xef\xbc\x9a\xe7\xa7\x92\r\n     */\r\n    public void put(String key, byte[] value, int saveTime) {\r\n        put(key, Utils.newByteArrayWithDateInfo(saveTime, value));\r\n    }\r\n\r\n\r\n    /**\r\n     * \xe8\x8e\xb7\xe5\x8f\x96 byte \xe6\x95\xb0\xe6\x8d\xae\r\n     *\r\n     * @return byte \xe6\x95\xb0\xe6\x8d\xae\r\n     */\r\n    public byte[] getAsBinary(String key) {\r\n        RandomAccessFile RAFile = null;\r\n        boolean removeFile = false;\r\n        try {\r\n            File file = mCache.get(key);\r\n            if (!file.exists()) return null;\r\n            RAFile = new RandomAccessFile(file, "r");\r\n            byte[] byteArray = new byte[(int) RAFile.length()];\r\n            RAFile.read(byteArray);\r\n            if (!Utils.isDue(byteArray)) {\r\n                return Utils.clearDateInfo(byteArray);\r\n            }\r\n            else {\r\n                removeFile = true;\r\n                return null;\r\n            }\r\n        } catch (Exception e) {\r\n            e.printStackTrace();\r\n            return null;\r\n        } finally {\r\n            if (RAFile != null) {\r\n                try {\r\n                    RAFile.close();\r\n                } catch (IOException e) {\r\n                    e.printStackTrace();\r\n                }\r\n            }\r\n            if (removeFile) remove(key);\r\n        }\r\n    }\r\n\r\n    // =======================================\r\n    // ============= \xe5\xba\x8f\xe5\x88\x97\xe5\x8c\x96 \xe6\x95\xb0\xe6\x8d\xae \xe8\xaf\xbb\xe5\x86\x99 ===============\r\n    // =======================================\r\n\r\n\r\n    /**\r\n     * \xe4\xbf\x9d\xe5\xad\x98 Serializable\xe6\x95\xb0\xe6\x8d\xae \xe5\x88\xb0 \xe7\xbc\x93\xe5\xad\x98\xe4\xb8\xad\r\n     *\r\n     * @param key \xe4\xbf\x9d\xe5\xad\x98\xe7\x9a\x84key\r\n     * @param value \xe4\xbf\x9d\xe5\xad\x98\xe7\x9a\x84value\r\n     */\r\n    public void put(String key, Serializable value) {\r\n        put(key, value, -1);\r\n    }\r\n\r\n\r\n    /**\r\n     * \xe4\xbf\x9d\xe5\xad\x98 Serializable\xe6\x95\xb0\xe6\x8d\xae\xe5\x88\xb0 \xe7\xbc\x93\xe5\xad\x98\xe4\xb8\xad\r\n     *\r\n     * @param key \xe4\xbf\x9d\xe5\xad\x98\xe7\x9a\x84key\r\n     * @param value \xe4\xbf\x9d\xe5\xad\x98\xe7\x9a\x84value\r\n     * @param saveTime \xe4\xbf\x9d\xe5\xad\x98\xe7\x9a\x84\xe6\x97\xb6\xe9\x97\xb4\xef\xbc\x8c\xe5\x8d\x95\xe4\xbd\x8d\xef\xbc\x9a\xe7\xa7\x92\r\n     */\r\n    public void put(String key, Serializable value, int saveTime) {\r\n        ByteArrayOutputStream baos = null;\r\n        ObjectOutputStream oos = null;\r\n        try {\r\n            baos = new ByteArrayOutputStream();\r\n            oos = new ObjectOutputStream(baos);\r\n            oos.writeObject(value);\r\n            byte[] data = baos.toByteArray();\r\n            if (saveTime != -1) {\r\n                put(key, data, saveTime);\r\n            }\r\n            else {\r\n                put(key, data);\r\n            }\r\n        } catch (Exception e) {\r\n            e.printStackTrace();\r\n        } finally {\r\n            try {\r\n                oos.close();\r\n            } catch (IOException e) {\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n    /**\r\n     * \xe8\xaf\xbb\xe5\x8f\x96 Serializable\xe6\x95\xb0\xe6\x8d\xae\r\n     *\r\n     * @return Serializable \xe6\x95\xb0\xe6\x8d\xae\r\n     */\r\n    public Object getAsObject(String key) {\r\n        byte[] data = getAsBinary(key);\r\n        if (data != null) {\r\n            ByteArrayInputStream bais = null;\r\n            ObjectInputStream ois = null;\r\n            try {\r\n                bais = new ByteArrayInputStream(data);\r\n                ois = new ObjectInputStream(bais);\r\n                Object reObject = ois.readObject();\r\n                return reObject;\r\n            } catch (Exception e) {\r\n                e.printStackTrace();\r\n                return null;\r\n            } finally {\r\n                try {\r\n                    if (bais != null) bais.close();\r\n                } catch (IOException e) {\r\n                    e.printStackTrace();\r\n                }\r\n                try {\r\n                    if (ois != null) ois.close();\r\n                } catch (IOException e) {\r\n                    e.printStackTrace();\r\n                }\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    // =======================================\r\n    // ============== bitmap \xe6\x95\xb0\xe6\x8d\xae \xe8\xaf\xbb\xe5\x86\x99 =============\r\n    // =======================================\r\n\r\n\r\n    /**\r\n     * \xe4\xbf\x9d\xe5\xad\x98 bitmap \xe5\x88\xb0 \xe7\xbc\x93\xe5\xad\x98\xe4\xb8\xad\r\n     *\r\n     * @param key \xe4\xbf\x9d\xe5\xad\x98\xe7\x9a\x84key\r\n     * @param value \xe4\xbf\x9d\xe5\xad\x98\xe7\x9a\x84bitmap\xe6\x95\xb0\xe6\x8d\xae\r\n     */\r\n    public void put(String key, Bitmap value) {\r\n        put(key, Utils.Bitmap2Bytes(value));\r\n    }\r\n\r\n\r\n    /**\r\n     * \xe4\xbf\x9d\xe5\xad\x98 bitmap \xe5\x88\xb0 \xe7\xbc\x93\xe5\xad\x98\xe4\xb8\xad\r\n     *\r\n     * @param key \xe4\xbf\x9d\xe5\xad\x98\xe7\x9a\x84key\r\n     * @param value \xe4\xbf\x9d\xe5\xad\x98\xe7\x9a\x84 bitmap \xe6\x95\xb0\xe6\x8d\xae\r\n     * @param saveTime \xe4\xbf\x9d\xe5\xad\x98\xe7\x9a\x84\xe6\x97\xb6\xe9\x97\xb4\xef\xbc\x8c\xe5\x8d\x95\xe4\xbd\x8d\xef\xbc\x9a\xe7\xa7\x92\r\n     */\r\n    public void put(String key, Bitmap value, int saveTime) {\r\n        put(key, Utils.Bitmap2Bytes(value), saveTime);\r\n    }\r\n\r\n\r\n    /**\r\n     * \xe8\xaf\xbb\xe5\x8f\x96 bitmap \xe6\x95\xb0\xe6\x8d\xae\r\n     *\r\n     * @return bitmap \xe6\x95\xb0\xe6\x8d\xae\r\n     */\r\n    public Bitmap getAsBitmap(String key) {\r\n        if (getAsBinary(key) == null) {\r\n            return null;\r\n        }\r\n        return Utils.Bytes2Bimap(getAsBinary(key));\r\n    }\r\n\r\n    // =======================================\r\n    // ============= drawable \xe6\x95\xb0\xe6\x8d\xae \xe8\xaf\xbb\xe5\x86\x99 =============\r\n    // =======================================\r\n\r\n\r\n    /**\r\n     * \xe4\xbf\x9d\xe5\xad\x98 drawable \xe5\x88\xb0 \xe7\xbc\x93\xe5\xad\x98\xe4\xb8\xad\r\n     *\r\n     * @param key \xe4\xbf\x9d\xe5\xad\x98\xe7\x9a\x84key\r\n     * @param value \xe4\xbf\x9d\xe5\xad\x98\xe7\x9a\x84drawable\xe6\x95\xb0\xe6\x8d\xae\r\n     */\r\n    public void put(String key, Drawable value) {\r\n        put(key, Utils.drawable2Bitmap(value));\r\n    }\r\n\r\n\r\n    /**\r\n     * \xe4\xbf\x9d\xe5\xad\x98 drawable \xe5\x88\xb0 \xe7\xbc\x93\xe5\xad\x98\xe4\xb8\xad\r\n     *\r\n     * @param key \xe4\xbf\x9d\xe5\xad\x98\xe7\x9a\x84key\r\n     * @param value \xe4\xbf\x9d\xe5\xad\x98\xe7\x9a\x84 drawable \xe6\x95\xb0\xe6\x8d\xae\r\n     * @param saveTime \xe4\xbf\x9d\xe5\xad\x98\xe7\x9a\x84\xe6\x97\xb6\xe9\x97\xb4\xef\xbc\x8c\xe5\x8d\x95\xe4\xbd\x8d\xef\xbc\x9a\xe7\xa7\x92\r\n     */\r\n    public void put(String key, Drawable value, int saveTime) {\r\n        put(key, Utils.drawable2Bitmap(value), saveTime);\r\n    }\r\n\r\n\r\n    /**\r\n     * \xe8\xaf\xbb\xe5\x8f\x96 Drawable \xe6\x95\xb0\xe6\x8d\xae\r\n     *\r\n     * @return Drawable \xe6\x95\xb0\xe6\x8d\xae\r\n     */\r\n    public Drawable getAsDrawable(String key) {\r\n        if (getAsBinary(key) == null) {\r\n            return null;\r\n        }\r\n        return Utils.bitmap2Drawable(Utils.Bytes2Bimap(getAsBinary(key)));\r\n    }\r\n\r\n\r\n    /**\r\n     * \xe8\x8e\xb7\xe5\x8f\x96\xe7\xbc\x93\xe5\xad\x98\xe6\x96\x87\xe4\xbb\xb6\r\n     *\r\n     * @return value \xe7\xbc\x93\xe5\xad\x98\xe7\x9a\x84\xe6\x96\x87\xe4\xbb\xb6\r\n     */\r\n    public File file(String key) {\r\n        File f = mCache.newFile(key);\r\n        if (f.exists()) return f;\r\n        return null;\r\n    }\r\n\r\n\r\n    /**\r\n     * \xe7\xa7\xbb\xe9\x99\xa4\xe6\x9f\x90\xe4\xb8\xaakey\r\n     *\r\n     * @return \xe6\x98\xaf\xe5\x90\xa6\xe7\xa7\xbb\xe9\x99\xa4\xe6\x88\x90\xe5\x8a\x9f\r\n     */\r\n    public boolean remove(String key) {\r\n        return mCache.remove(key);\r\n    }\r\n\r\n\r\n    /**\r\n     * \xe6\xb8\x85\xe9\x99\xa4\xe6\x89\x80\xe6\x9c\x89\xe6\x95\xb0\xe6\x8d\xae\r\n     */\r\n    public void clear() {\r\n        mCache.clear();\r\n    }\r\n\r\n\r\n    /**\r\n     * @author \xe6\x9d\xa8\xe7\xa6\x8f\xe6\xb5\xb7\xef\xbc\x88michael\xef\xbc\x89 www.yangfuhai.com\r\n     * @version 1.0\r\n     * @title \xe7\xbc\x93\xe5\xad\x98\xe7\xae\xa1\xe7\x90\x86\xe5\x99\xa8\r\n     */\r\n    public class ACacheManager {\r\n        private final AtomicLong cacheSize;\r\n        private final AtomicInteger cacheCount;\r\n        private final long sizeLimit;\r\n        private final int countLimit;\r\n        private final Map<File, Long> lastUsageDates = Collections.synchronizedMap(new HashMap<File, Long>());\r\n        protected File cacheDir;\r\n\r\n\r\n        private ACacheManager(File cacheDir, long sizeLimit, int countLimit) {\r\n            this.cacheDir = cacheDir;\r\n            this.sizeLimit = sizeLimit;\r\n            this.countLimit = countLimit;\r\n            cacheSize = new AtomicLong();\r\n            cacheCount = new AtomicInteger();\r\n            calculateCacheSizeAndCacheCount();\r\n        }\r\n\r\n\r\n        /**\r\n         * \xe8\xae\xa1\xe7\xae\x97 cacheSize\xe5\x92\x8ccacheCount\r\n         */\r\n        private void calculateCacheSizeAndCacheCount() {\r\n            new Thread(new Runnable() {\r\n                @Override public void run() {\r\n                    int size = 0;\r\n                    int count = 0;\r\n                    File[] cachedFiles = cacheDir.listFiles();\r\n                    if (cachedFiles != null) {\r\n                        for (File cachedFile : cachedFiles) {\r\n                            size += calculateSize(cachedFile);\r\n                            count += 1;\r\n                            lastUsageDates.put(cachedFile, cachedFile.lastModified());\r\n                        }\r\n                        cacheSize.set(size);\r\n                        cacheCount.set(count);\r\n                    }\r\n                }\r\n            }).start();\r\n        }\r\n\r\n\r\n        private void put(File file) {\r\n            int curCacheCount = cacheCount.get();\r\n            while (curCacheCount + 1 > countLimit) {\r\n                long freedSize = removeNext();\r\n                cacheSize.addAndGet(-freedSize);\r\n\r\n                curCacheCount = cacheCount.addAndGet(-1);\r\n            }\r\n            cacheCount.addAndGet(1);\r\n\r\n            long valueSize = calculateSize(file);\r\n            long curCacheSize = cacheSize.get();\r\n            while (curCacheSize + valueSize > sizeLimit) {\r\n                long freedSize = removeNext();\r\n                curCacheSize = cacheSize.addAndGet(-freedSize);\r\n            }\r\n            cacheSize.addAndGet(valueSize);\r\n\r\n            Long currentTime = System.currentTimeMillis();\r\n            file.setLastModified(currentTime);\r\n            lastUsageDates.put(file, currentTime);\r\n        }\r\n\r\n\r\n        private File get(String key) {\r\n            File file = newFile(key);\r\n            Long currentTime = System.currentTimeMillis();\r\n            file.setLastModified(currentTime);\r\n            lastUsageDates.put(file, currentTime);\r\n\r\n            return file;\r\n        }\r\n\r\n\r\n        private File newFile(String key) {\r\n            return new File(cacheDir, key.hashCode() + "");\r\n        }\r\n\r\n\r\n        private boolean remove(String key) {\r\n            File image = get(key);\r\n            return image.delete();\r\n        }\r\n\r\n\r\n        private void clear() {\r\n            lastUsageDates.clear();\r\n            cacheSize.set(0);\r\n            File[] files = cacheDir.listFiles();\r\n            if (files != null) {\r\n                for (File f : files) {\r\n                    f.delete();\r\n                }\r\n            }\r\n        }\r\n\r\n\r\n        /**\r\n         * \xe7\xa7\xbb\xe9\x99\xa4\xe6\x97\xa7\xe7\x9a\x84\xe6\x96\x87\xe4\xbb\xb6\r\n         */\r\n        private long removeNext() {\r\n            if (lastUsageDates.isEmpty()) {\r\n                return 0;\r\n            }\r\n\r\n            Long oldestUsage = null;\r\n            File mostLongUsedFile = null;\r\n            Set<Entry<File, Long>> entries = lastUsageDates.entrySet();\r\n            synchronized (lastUsageDates) {\r\n                for (Entry<File, Long> entry : entries) {\r\n                    if (mostLongUsedFile == null) {\r\n                        mostLongUsedFile = entry.getKey();\r\n                        oldestUsage = entry.getValue();\r\n                    }\r\n                    else {\r\n                        Long lastValueUsage = entry.getValue();\r\n                        if (lastValueUsage < oldestUsage) {\r\n                            oldestUsage = lastValueUsage;\r\n                            mostLongUsedFile = entry.getKey();\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n            long fileSize = calculateSize(mostLongUsedFile);\r\n            if (mostLongUsedFile.delete()) {\r\n                lastUsageDates.remove(mostLongUsedFile);\r\n            }\r\n            return fileSize;\r\n        }\r\n\r\n\r\n        private long calculateSize(File file) {\r\n            return file.length();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @author \xe6\x9d\xa8\xe7\xa6\x8f\xe6\xb5\xb7\xef\xbc\x88michael\xef\xbc\x89 www.yangfuhai.com\r\n     * @version 1.0\r\n     * @title \xe6\x97\xb6\xe9\x97\xb4\xe8\xae\xa1\xe7\xae\x97\xe5\xb7\xa5\xe5\x85\xb7\xe7\xb1\xbb\r\n     */\r\n    private static class Utils {\r\n\r\n        /**\r\n         * \xe5\x88\xa4\xe6\x96\xad\xe7\xbc\x93\xe5\xad\x98\xe7\x9a\x84String\xe6\x95\xb0\xe6\x8d\xae\xe6\x98\xaf\xe5\x90\xa6\xe5\x88\xb0\xe6\x9c\x9f\r\n         *\r\n         * @return true\xef\xbc\x9a\xe5\x88\xb0\xe6\x9c\x9f\xe4\xba\x86 false\xef\xbc\x9a\xe8\xbf\x98\xe6\xb2\xa1\xe6\x9c\x89\xe5\x88\xb0\xe6\x9c\x9f\r\n         */\r\n        private static boolean isDue(String str) {\r\n            return isDue(str.getBytes());\r\n        }\r\n\r\n\r\n        /**\r\n         * \xe5\x88\xa4\xe6\x96\xad\xe7\xbc\x93\xe5\xad\x98\xe7\x9a\x84byte\xe6\x95\xb0\xe6\x8d\xae\xe6\x98\xaf\xe5\x90\xa6\xe5\x88\xb0\xe6\x9c\x9f\r\n         *\r\n         * @return true\xef\xbc\x9a\xe5\x88\xb0\xe6\x9c\x9f\xe4\xba\x86 false\xef\xbc\x9a\xe8\xbf\x98\xe6\xb2\xa1\xe6\x9c\x89\xe5\x88\xb0\xe6\x9c\x9f\r\n         */\r\n        private static boolean isDue(byte[] data) {\r\n            String[] strs = getDateInfoFromDate(data);\r\n            if (strs != null && strs.length == 2) {\r\n                String saveTimeStr = strs[0];\r\n                while (saveTimeStr.startsWith("0")) {\r\n                    saveTimeStr = saveTimeStr.substring(1, saveTimeStr.length());\r\n                }\r\n                long saveTime = Long.valueOf(saveTimeStr);\r\n                long deleteAfter = Long.valueOf(strs[1]);\r\n                if (System.currentTimeMillis() > saveTime + deleteAfter * 1000) {\r\n                    return true;\r\n                }\r\n            }\r\n            return false;\r\n        }\r\n\r\n\r\n        private static String newStringWithDateInfo(int second, String strInfo) {\r\n            return createDateInfo(second) + strInfo;\r\n        }\r\n\r\n\r\n        private static byte[] newByteArrayWithDateInfo(int second, byte[] data2) {\r\n            byte[] data1 = createDateInfo(second).getBytes();\r\n            byte[] retdata = new byte[data1.length + data2.length];\r\n            System.arraycopy(data1, 0, retdata, 0, data1.length);\r\n            System.arraycopy(data2, 0, retdata, data1.length, data2.length);\r\n            return retdata;\r\n        }\r\n\r\n\r\n        private static String clearDateInfo(String strInfo) {\r\n            if (strInfo != null && hasDateInfo(strInfo.getBytes())) {\r\n                strInfo = strInfo.substring(strInfo.indexOf(mSeparator) + 1, strInfo.length());\r\n            }\r\n            return strInfo;\r\n        }\r\n\r\n\r\n        private static byte[] clearDateInfo(byte[] data) {\r\n            if (hasDateInfo(data)) {\r\n                return copyOfRange(data, indexOf(data, mSeparator) + 1, data.length);\r\n            }\r\n            return data;\r\n        }\r\n\r\n\r\n        private static boolean hasDateInfo(byte[] data) {\r\n            return data != null && data.length > 15 && data[13] == \'-\' && indexOf(data, mSeparator) > 14;\r\n        }\r\n\r\n\r\n        private static String[] getDateInfoFromDate(byte[] data) {\r\n            if (hasDateInfo(data)) {\r\n                String saveDate = new String(copyOfRange(data, 0, 13));\r\n                String deleteAfter = new String(copyOfRange(data, 14, indexOf(data, mSeparator)));\r\n                return new String[] { saveDate, deleteAfter };\r\n            }\r\n            return null;\r\n        }\r\n\r\n\r\n        private static int indexOf(byte[] data, char c) {\r\n            for (int i = 0; i < data.length; i++) {\r\n                if (data[i] == c) {\r\n                    return i;\r\n                }\r\n            }\r\n            return -1;\r\n        }\r\n\r\n\r\n        private static byte[] copyOfRange(byte[] original, int from, int to) {\r\n            int newLength = to - from;\r\n            if (newLength < 0) throw new IllegalArgumentException(from + " > " + to);\r\n            byte[] copy = new byte[newLength];\r\n            System.arraycopy(original, from, copy, 0, Math.min(original.length - from, newLength));\r\n            return copy;\r\n        }\r\n\r\n\r\n        private static final char mSeparator = \' \';\r\n\r\n\r\n        private static String createDateInfo(int second) {\r\n            String currentTime = System.currentTimeMillis() + "";\r\n            while (currentTime.length() < 13) {\r\n                currentTime = "0" + currentTime;\r\n            }\r\n            return currentTime + "-" + second + mSeparator;\r\n        }\r\n\r\n\r\n        /*\r\n         * Bitmap \xe2\x86\x92 byte[]\r\n         */\r\n        private static byte[] Bitmap2Bytes(Bitmap bm) {\r\n            if (bm == null) {\r\n                return null;\r\n            }\r\n            ByteArrayOutputStream baos = new ByteArrayOutputStream();\r\n            bm.compress(Bitmap.CompressFormat.PNG, 100, baos);\r\n            return baos.toByteArray();\r\n        }\r\n\r\n\r\n        /*\r\n         * byte[] \xe2\x86\x92 Bitmap\r\n         */\r\n        private static Bitmap Bytes2Bimap(byte[] b) {\r\n            if (b.length == 0) {\r\n                return null;\r\n            }\r\n            return BitmapFactory.decodeByteArray(b, 0, b.length);\r\n        }\r\n\r\n\r\n        /*\r\n         * Drawable \xe2\x86\x92 Bitmap\r\n         */\r\n        private static Bitmap drawable2Bitmap(Drawable drawable) {\r\n            if (drawable == null) {\r\n                return null;\r\n            }\r\n            // \xe5\x8f\x96 drawable \xe7\x9a\x84\xe9\x95\xbf\xe5\xae\xbd\r\n            int w = drawable.getIntrinsicWidth();\r\n            int h = drawable.getIntrinsicHeight();\r\n            // \xe5\x8f\x96 drawable \xe7\x9a\x84\xe9\xa2\x9c\xe8\x89\xb2\xe6\xa0\xbc\xe5\xbc\x8f\r\n            Bitmap.Config config = drawable.getOpacity() != PixelFormat.OPAQUE\r\n                    ? Bitmap.Config.ARGB_8888\r\n                    : Bitmap.Config.RGB_565;\r\n            // \xe5\xbb\xba\xe7\xab\x8b\xe5\xaf\xb9\xe5\xba\x94 bitmap\r\n            Bitmap bitmap = Bitmap.createBitmap(w, h, config);\r\n            // \xe5\xbb\xba\xe7\xab\x8b\xe5\xaf\xb9\xe5\xba\x94 bitmap \xe7\x9a\x84\xe7\x94\xbb\xe5\xb8\x83\r\n            Canvas canvas = new Canvas(bitmap);\r\n            drawable.setBounds(0, 0, w, h);\r\n            // \xe6\x8a\x8a drawable \xe5\x86\x85\xe5\xae\xb9\xe7\x94\xbb\xe5\x88\xb0\xe7\x94\xbb\xe5\xb8\x83\xe4\xb8\xad\r\n            drawable.draw(canvas);\r\n            return bitmap;\r\n        }\r\n\r\n\r\n        /*\r\n         * Bitmap \xe2\x86\x92 Drawable\r\n         */\r\n        @SuppressWarnings("deprecation") private static Drawable bitmap2Drawable(Bitmap bm) {\r\n            if (bm == null) {\r\n                return null;\r\n            }\r\n            return new BitmapDrawable(bm);\r\n        }\r\n    }\r\n}'