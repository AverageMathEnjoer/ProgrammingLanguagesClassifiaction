b'// UVa12171 Sculpture\n// Rujia Liu\n#include<cstdio>\n#include<cstring>\n#include<queue>\n#include<algorithm>\nusing namespace std;\n\nconst int maxn = 50 + 5;\nconst int maxc = 1000 + 1;\n\n// original data\nint n, x0[maxn], y0[maxn], z0[maxn], x1[maxn], y1[maxn], z1[maxn];\n\n// discretization related\nint nx, ny, nz;\nint xs[maxn*2], ys[maxn*2], zs[maxn*2];\n\n// floodfill related\nconst int dx[] = {1,-1,0,0,0,0};\nconst int dy[] = {0,0,1,-1,0,0};\nconst int dz[] = {0,0,0,0,1,-1};\nint color[maxn*2][maxn*2][maxn*2];\n\nstruct Cell {\n  int x, y, z;\n  Cell(int x=0, int y=0, int z=0):x(x),y(y),z(z){}\n  bool valid() const {\n    return x >= 0 && x < nx-1 && y >= 0 && y < ny-1 && z >= 0 && z < nz-1;\n  }\n  bool solid() const {\n    return color[x][y][z] == 1; // solid\n  }\n  bool getVis() const {\n    return color[x][y][z] == 2; // visited\n  }\n  void setVis() const {\n    color[x][y][z] = 2;\n  }\n  Cell neighbor(int dir) const {\n    return Cell(x+dx[dir], y+dy[dir], z+dz[dir]);\n  }\n  int volume() const {\n    return (xs[x+1]-xs[x])*(ys[y+1]-ys[y])*(zs[z+1]-zs[z]);\n  }\n  int area(int dir) const {\n    if(dx[dir] != 0) return (ys[y+1]-ys[y])*(zs[z+1]-zs[z]);\n    else if(dy[dir] != 0) return (xs[x+1]-xs[x])*(zs[z+1]-zs[z]);\n    return (xs[x+1]-xs[x])*(ys[y+1]-ys[y]);\n  }\n};\n\nvoid discretize(int* x, int& n) {\n  sort(x, x+n);\n  n = unique(x, x+n) - x;\n}\n\nint ID(int* x, int n, int x0) {\n  return lower_bound(x, x + n, x0) - x;\n}\n\nvoid floodfill(int& v, int& s) {\n  v = 0;\n  s = 0;\n  Cell c;\n  c.setVis();\n  queue<Cell> q;\n  q.push(c);\n  while(!q.empty()) {\n    Cell c = q.front(); q.pop();\n    v += c.volume();\n    for(int i = 0; i < 6; i++) {\n      Cell c2 = c.neighbor(i);\n      if(!c2.valid()) continue;\n      if(c2.solid()) s += c.area(i);\n      else if(!c2.getVis()){\n        c2.setVis();\n        q.push(c2);\n      }\n    }\n  }\n  v = maxc*maxc*maxc - v;\n}\n\nint main() {\n  int T;\n  scanf("%d", &T);\n  while(T--) {\n    nx = ny = nz = 2;\n    xs[0] = ys[0] = zs[0] = 0;\n    xs[1] = ys[1] = zs[1] = maxc;\n    scanf("%d", &n);\n    for(int i = 0; i < n; i++) {\n      scanf("%d%d%d%d%d%d", &x0[i], &y0[i], &z0[i], &x1[i], &y1[i], &z1[i]);\n      x1[i] += x0[i]; y1[i] += y0[i]; z1[i] += z0[i];\n      xs[nx++] = x0[i]; xs[nx++] = x1[i];\n      ys[ny++] = y0[i]; ys[ny++] = y1[i];\n      zs[nz++] = z0[i]; zs[nz++] = z1[i];\n    }\n    discretize(xs, nx);\n    discretize(ys, ny);\n    discretize(zs, nz);\n\n    // paint\n    memset(color, 0, sizeof(color));\n    for(int i = 0; i < n; i++) {\n      int X1 = ID(xs, nx, x0[i]), X2 = ID(xs, nx, x1[i]);\n      int Y1 = ID(ys, ny, y0[i]), Y2 = ID(ys, ny, y1[i]);\n      int Z1 = ID(zs, nz, z0[i]), Z2 = ID(zs, nz, z1[i]);\n      for(int X = X1; X < X2; X++)\n        for(int Y = Y1; Y < Y2; Y++)\n          for(int Z = Z1; Z < Z2; Z++)\n            color[X][Y][Z] = 1;\n    }\n\n    int v, s;\n    floodfill(v, s);\n    printf("%d %d\\n", s, v);\n  }\n\n  return 0;\n}\n'