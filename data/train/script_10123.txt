b'// Copyright (c) 2022-2023 Manuel Schneider\n\n#include "albert/albert.h"\n#include "albert/config.h"\n#include "albert/export.h"\n#include "albert/extensions/frontend.h"\n#include "albert/logging.h"\n#include "albert/util/util.h"\n#include "app.h"\n#include "rpcserver.h"\n#include "scopedcrashindicator.h"\n#include "xdg/iconlookup.h"\n#include <QApplication>\n#include <QCommandLineParser>\n#include <QIcon>\n#include <QMessageBox>\n#include <QMetaEnum>\n#include <QSettings>\n#include <QStandardPaths>\n#include <QTime>\n#include <csignal>\n#include <memory>\n#ifdef Q_OS_MAC\n#include "macos.h"\n#endif\nALBERT_LOGGING\nusing namespace std;\nusing namespace albert;\n\nnamespace {\nconst char *CFG_LAST_USED_VERSION = "last_used_version";\nunique_ptr<App> app;\n}\n\nvoid albert::show(const QString &text)\n{\n    if (!text.isNull())\n        app->plugin_provider.frontend()->setInput(text);\n    app->plugin_provider.frontend()->setVisible(true);\n}\n\nvoid albert::hide()\n{\n    app->plugin_provider.frontend()->setVisible(false);\n}\n\nvoid albert::toggle()\n{\n    app->plugin_provider.frontend()->setVisible(!app->plugin_provider.frontend()->isVisible());\n}\n\nvoid albert::runTerminal(const QString &script, const QString &working_dir, bool close_on_exit)\n{\n    app->terminal_provider.terminal().run(script, working_dir, close_on_exit);\n}\n\nvoid albert::showSettings()\n{\n    hide();\n    if (!app->settings_window)\n        app->settings_window = new SettingsWindow(*app);\n    app->settings_window->bringToFront();\n}\n\nvoid albert::restart()\n{\n    QMetaObject::invokeMethod(qApp, "exit", Qt::QueuedConnection, Q_ARG(int, -1));\n}\n\nvoid albert::quit()\n{\n    QMetaObject::invokeMethod(qApp, "quit", Qt::QueuedConnection);\n}\n\nvoid albert::sendTrayNotification(const QString &title, const QString &message, int ms)\n{\n    app->tray_icon.showMessage(title, message, QSystemTrayIcon::NoIcon, ms);\n}\n\n\nstatic void messageHandler(QtMsgType type, const QMessageLogContext &context, const QString &message)\n{\n    switch (type) {\n        case QtDebugMsg:\n            fprintf(stdout, "%s \\x1b[34;1m[debg:%s]\\x1b[0m \\x1b[3m%s\\x1b[0m\\n",\n                    QTime::currentTime().toString().toLocal8Bit().constData(),\n                    context.category,\n                    message.toLocal8Bit().constData());\n            break;\n        case QtInfoMsg:\n            fprintf(stdout, "%s \\x1b[32;1m[info:%s]\\x1b[0m %s\\n",\n                    QTime::currentTime().toString().toLocal8Bit().constData(),\n                    context.category,\n                    message.toLocal8Bit().constData());\n            break;\n        case QtWarningMsg:\n            fprintf(stdout, "%s \\x1b[33;1m[warn:%s]\\x1b[0;1m %s\\x1b[0m\\n",\n                    QTime::currentTime().toString().toLocal8Bit().constData(),\n                    context.category,\n                    message.toLocal8Bit().constData());\n            break;\n        case QtCriticalMsg:\n            fprintf(stdout, "%s \\x1b[31;1m[crit:%s]\\x1b[0;1m %s\\x1b[0m\\n",\n                    QTime::currentTime().toString().toLocal8Bit().constData(),\n                    context.category,\n                    message.toLocal8Bit().constData());\n            break;\n        case QtFatalMsg:\n            fprintf(stderr, "%s \\x1b[41;30;4m[fatal:%s]\\x1b[0;1m %s  --  [%s]\\x1b[0m\\n",\n                    QTime::currentTime().toString().toLocal8Bit().constData(),\n                    context.category,\n                    message.toLocal8Bit().constData(),\n                    context.function);\n            QMessageBox::critical(nullptr, "Fatal error", message);\n            exit(1);\n    }\n    fflush(stdout);\n}\n\nstatic void createWritableApplicationPaths()\n{\n    auto locs = {\n            QStandardPaths::AppConfigLocation,\n            QStandardPaths::AppDataLocation,\n            QStandardPaths::CacheLocation\n    };\n    for (auto loc: locs)\n        if (auto path = QStandardPaths::writableLocation(loc); !QDir(path).mkpath("."))\n            qFatal("Could not create dir: %s", qPrintable(path));\n}\n\nstatic void installSignalHandlers()\n{\n    for (int sig: {SIGINT, SIGTERM, SIGHUP, SIGPIPE})\n        signal(sig, [](int) { QMetaObject::invokeMethod(qApp, "quit", Qt::QueuedConnection); });\n}\n\nstatic unique_ptr<QApplication> initializeQApp(int &argc, char **argv)\n{\n    if (const char *key = "LANGUAGE"; qEnvironmentVariableIsSet(key))\n        QLocale::setDefault(QLocale(qEnvironmentVariable(key)));\n    else if (key = "LANG"; qEnvironmentVariableIsSet(key))\n        QLocale::setDefault(QLocale(qEnvironmentVariable(key)));\n\n    auto qapp = make_unique<QApplication>(argc, argv);\n    QApplication::setApplicationName("albert");\n    QApplication::setApplicationDisplayName("Albert");\n    QApplication::setApplicationVersion(ALBERT_VERSION);\n    QString icon = XDG::IconLookup::iconPath("albert");\n    if (icon.isEmpty())\n        icon = ":app_icon";\n    QApplication::setWindowIcon(QIcon(icon));\n    QApplication::setQuitOnLastWindowClosed(false);\n\n    installSignalHandlers();\n    createWritableApplicationPaths();\n\n    return qapp;\n}\n\nstatic void printSystemReport()\n{\n    QTextStream out(stdout);\n    auto print = [&out](const QString& s){ out << s << \'\\n\'; };\n\n    const uint8_t w = 22;\n    print(QString("%1: %2").arg("Albert version", w).arg(QApplication::applicationVersion()));\n    print(QString("%1: %2").arg("Build date", w).arg(__DATE__ " " __TIME__));\n    print(QString("%1: %2").arg("Qt version", w).arg(qVersion()));\n    print(QString("%1: %2").arg("Build ABI", w).arg(QSysInfo::buildAbi()));\n    print(QString("%1: %2/%3").arg("Arch (build/current)", w).arg(QSysInfo::buildCpuArchitecture(), QSysInfo::currentCpuArchitecture()));\n    print(QString("%1: %2/%3").arg("Kernel (type/version)", w).arg(QSysInfo::kernelType(), QSysInfo::kernelVersion()));\n    print(QString("%1: %2").arg("OS", w).arg(QSysInfo::prettyProductName()));\n    print(QString("%1: %2/%3").arg("OS (type/version)", w).arg(QSysInfo::productType(), QSysInfo::productVersion()));\n    print(QString("%1: %2").arg("$QT_QPA_PLATFORMTHEME", w).arg(QString::fromLocal8Bit(qgetenv("QT_QPA_PLATFORMTHEME"))));\n    print(QString("%1: %2").arg("Platform name", w).arg(QGuiApplication::platformName()));\n    print(QString("%1: %2").arg("Font", w).arg(QGuiApplication::font().toString()));\n    print(QString("%1: %2").arg("Binary location", w).arg(QApplication::applicationFilePath()));\n    print(QString("%1: %2").arg("$PWD", w).arg(QString::fromLocal8Bit(qgetenv("PWD"))));\n    print(QString("%1: %2").arg("$SHELL", w).arg(QString::fromLocal8Bit(qgetenv("SHELL"))));\n    print(QString("%1: %2").arg("$LANG", w).arg(QString::fromLocal8Bit(qgetenv("LANG"))));\n    QMetaEnum metaEnum = QMetaEnum::fromType<QLocale::Language>();\n    QLocale loc;\n    print(QString("%1: %2").arg("Language", w).arg(metaEnum.valueToKey(loc.language())));\n    print(QString("%1: %2").arg("Locale", w).arg(loc.name()));\n#if defined(Q_OS_LINUX)\n    print(QString("%1: %2").arg("$XDG_SESSION_TYPE", w).arg(QString::fromLocal8Bit(qgetenv("XDG_SESSION_TYPE"))));\n    print(QString("%1: %2").arg("$XDG_CURRENT_DESKTOP", w).arg(QString::fromLocal8Bit(qgetenv("XDG_CURRENT_DESKTOP"))));\n    print(QString("%1: %2").arg("$DESKTOP_SESSION", w).arg(QString::fromLocal8Bit(qgetenv("DESKTOP_SESSION"))));\n    print(QString("%1: %2").arg("$XDG_SESSION_DESKTOP", w).arg(QString::fromLocal8Bit(qgetenv("XDG_SESSION_DESKTOP"))));\n    print(QString("%1: %2").arg("Icon theme", w).arg(QIcon::themeName()));\n#endif\n    out.flush();\n}\n\nstatic void notifyVersionChange()\n{\n    auto settings = QSettings(qApp->applicationName());\n    auto current_version = qApp->applicationVersion();\n    auto last_used_version = settings.value(CFG_LAST_USED_VERSION).toString();\n\n    if (last_used_version.isNull()){  // First run\n        QMessageBox(\n                QMessageBox::Warning, "First run",\n                "This is the first time you\'ve launched Albert. Albert is plugin based. "\n                "You have to enable some plugins you want to use.").exec();\n        albert::showSettings();\n    }\n    else if (current_version.section(\'.\', 1, 1) != last_used_version.section(\'.\', 1, 1) )  // FIXME in first major version\n        QMessageBox(QMessageBox::Information, "Major version changed",\n                    QString("You are now using Albert %1. The major version changed. "\n                            "Some parts of the API might have changed. Check the "\n                            "<a href=\\"https://albertlauncher.github.io/news/\\">news</a>.")\n                            .arg(current_version)).exec();\n\n    if (last_used_version != current_version)\n        settings.setValue(CFG_LAST_USED_VERSION, current_version);\n}\n\nint ALBERT_EXPORT main(int argc, char **argv);\nint main(int argc, char **argv)\n{\n    if (qApp != nullptr)\n        qFatal("Calling main twice is not allowed.");\n\n    qInstallMessageHandler(messageHandler);\n    auto qapp = initializeQApp(argc, argv);\n\n    QCommandLineParser parser;\n    auto opt_p = QCommandLineOption({"p", "plugin-dirs"}, "Set the plugin dirs to use. Comma separated.", "directory");\n    auto opt_r = QCommandLineOption({"r", "report"}, "Print issue report.");\n    auto opt_q = QCommandLineOption({"q", "quiet"}, "Warnings only.");\n    auto opt_d = QCommandLineOption({"d", "debug"}, "Full debug output. Ignore \'--quiet\'.");\n    parser.addOptions({opt_p, opt_r, opt_q, opt_d});\n    parser.addPositionalArgument("command", "RPC command to send to the running instance", "[command [params...]]");\n    parser.addVersionOption();\n    parser.addHelpOption();\n    parser.process(*qapp);\n\n    if (parser.isSet(opt_r)){\n        printSystemReport();\n        ::exit(EXIT_SUCCESS);\n    }\n\n    if (!parser.positionalArguments().isEmpty())\n        RPCServer::trySendMessageAndExit(parser.positionalArguments().join(" "));\n\n    if (parser.isSet(opt_q))\n        QLoggingCategory::setFilterRules("*.debug=false\\n*.info=false");\n    else if (parser.isSet(opt_d))\n        printSystemReport();\n    else\n        QLoggingCategory::setFilterRules("*.debug=false");\n\n#if defined(Q_OS_MAC)\n    setActivationPolicyAccessory();\n#endif\n    ScopedCrashIndicator crash_indicator;\n    app = make_unique<App>(parser.value(opt_p).split(\',\', Qt::SkipEmptyParts));\n    app->initialize();\n    notifyVersionChange();\n    QObject::connect(qApp, &QApplication::aboutToQuit, [&]() { app.reset(); }); // Delete app _before_ loop exits\n\n//    albert::showSettings();\n\n    int return_value = qApp->exec();\n    if (return_value == -1 && runDetachedProcess(qApp->arguments(), QDir::currentPath()))\n        return EXIT_SUCCESS;\n    return return_value;\n}\n'