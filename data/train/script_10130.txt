b'{-# LANGUAGE DataKinds #-}\n{-# LANGUAGE DuplicateRecordFields #-}\n\nmodule Cachix.Deploy.Agent where\n\nimport qualified Cachix.API.WebSocketSubprotocol as WSS\nimport qualified Cachix.Client.Config as Config\nimport Cachix.Client.URI (URI)\nimport qualified Cachix.Client.URI as URI\nimport Cachix.Client.Version (versionNumber)\nimport qualified Cachix.Deploy.Deployment as Deployment\nimport qualified Cachix.Deploy.Lock as Lock\nimport qualified Cachix.Deploy.Log as Log\nimport qualified Cachix.Deploy.OptionsParser as CLI\nimport qualified Cachix.Deploy.StdinProcess as StdinProcess\nimport qualified Cachix.Deploy.Websocket as WebSocket\nimport qualified Control.Concurrent.Async as Async\nimport Control.Concurrent.Extra (once)\nimport qualified Control.Concurrent.MVar as MVar\nimport Control.Exception.Safe (onException, throwString, withException)\nimport qualified Control.Exception.Safe as Safe\nimport qualified Control.Retry as Retry\nimport qualified Data.Aeson as Aeson\nimport Data.IORef\nimport Data.String (String)\nimport qualified Katip as K\nimport Paths_cachix (getBinDir)\nimport Protolude hiding (onException, toS)\nimport Protolude.Conv\nimport qualified System.Directory as Directory\nimport System.Environment (getEnv, lookupEnv)\nimport qualified System.Posix.Files as Posix.Files\nimport qualified System.Posix.Process as Posix\nimport qualified System.Posix.Signals as Signals\nimport qualified System.Posix.Types as Posix\nimport qualified System.Posix.User as Posix.User\nimport qualified System.Timeout as Timeout\n\ntype ServiceWebSocket = WebSocket.WebSocket (WSS.Message WSS.AgentCommand) (WSS.Message WSS.BackendCommand)\n\ndata Agent = Agent\n  { name :: Text,\n    token :: Text,\n    profileName :: Text,\n    agentState :: IORef (Maybe WSS.AgentInformation),\n    pid :: Posix.CPid,\n    bootstrap :: Bool,\n    host :: URI,\n    logOptions :: Log.Options,\n    withLog :: Log.WithLog,\n    websocket :: ServiceWebSocket\n  }\n\nagentIdentifier :: Text -> Text\nagentIdentifier agentName = unwords [agentName, toS versionNumber]\n\nrun :: Config.CachixOptions -> CLI.AgentOptions -> IO ()\nrun cachixOptions agentOptions =\n  Log.withLog logOptions $ \\withLog ->\n    logExceptions withLog $\n      withAgentLock agentOptions $ do\n        checkUserOwnsHome\n\n        -- TODO: show a more helpful error if the token is missing\n        -- TODO: show a more helpful error when the token isn\'t valid\n        -- TODO: wrap the token in a newtype or use servant\'s Token\n        agentToken <- toS <$> getEnv "CACHIX_AGENT_TOKEN"\n        agentState <- newIORef Nothing\n\n        pid <- Posix.getProcessID\n\n        let port = fromMaybe (URI.Port 80) $ (URI.getPortFor . URI.getScheme) host\n        let websocketOptions =\n              WebSocket.Options\n                { WebSocket.host = basename,\n                  WebSocket.port = port,\n                  WebSocket.path = "/ws",\n                  WebSocket.useSSL = URI.requiresSSL (URI.getScheme host),\n                  WebSocket.headers = WebSocket.createHeaders agentName agentToken,\n                  WebSocket.identifier = agentIdentifier agentName\n                }\n\n        websocket <- WebSocket.new withLog websocketOptions\n        channel <- WebSocket.receive websocket\n        shutdownWebsocket <- connectToService websocket\n\n        installSignalHandlers shutdownWebsocket\n\n        let agent =\n              Agent\n                { name = agentName,\n                  token = agentToken,\n                  profileName = profileName,\n                  agentState = agentState,\n                  pid = pid,\n                  bootstrap = CLI.bootstrap agentOptions,\n                  host = host,\n                  logOptions = logOptions,\n                  withLog = withLog,\n                  websocket = websocket\n                }\n\n        WebSocket.readDataMessages channel $ \\message ->\n          handleCommand agent (WSS.command message)\n  where\n    host = Config.host cachixOptions\n    basename = URI.getHostname host\n    agentName = CLI.name agentOptions\n    profileName = fromMaybe "system" (CLI.profile agentOptions)\n\n    verbosity =\n      if Config.verbose cachixOptions\n        then Log.Verbose\n        else Log.Normal\n\n    logOptions =\n      Log.Options\n        { verbosity = verbosity,\n          namespace = "agent",\n          environment = "production"\n        }\n\nlogExceptions :: Log.WithLog -> IO a -> IO a\nlogExceptions withLog action = withException action $ \\someE -> do\n  case fromException someE of\n    Just ExitSuccess -> exitSuccess\n    Just e -> do\n      withLog . K.logLocM K.ErrorS . K.ls $\n        unlines\n          [ "The agent encountered an exception:",\n            toS (displayException e)\n          ]\n      exitFailure\n    Nothing -> exitFailure\n\nlockFilename :: Text -> FilePath\nlockFilename agentName = "agent-" <> toS agentName\n\n-- | Acquire a lock for this agent. Skip this step if we\'re bootstrapping the agent.\nwithAgentLock :: CLI.AgentOptions -> IO () -> IO ()\nwithAgentLock CLI.AgentOptions {bootstrap = True} action = action\nwithAgentLock CLI.AgentOptions {name} action = tryToAcquireLock 0\n  where\n    tryToAcquireLock :: Int -> IO ()\n    tryToAcquireLock attempts = do\n      lock <- Lock.withTryLockAndPid (lockFilename name) action\n      when (isNothing lock) $\n        if attempts >= 5\n          then throwIO (AgentAlreadyRunning name)\n          else do\n            threadDelay (3 * 1000 * 1000)\n            tryToAcquireLock (attempts + 1)\n\ninstallSignalHandlers :: IO () -> IO ()\ninstallSignalHandlers shutdown =\n  for_ [Signals.sigINT, Signals.sigTERM] $ \\signal ->\n    Signals.installHandler signal handler Nothing\n  where\n    handler = Signals.CatchOnce shutdown\n\nregisterAgent :: Agent -> WSS.AgentInformation -> IO ()\nregisterAgent Agent {agentState, withLog} agentInformation = do\n  withLog $ K.logLocM K.InfoS "Agent registered."\n  atomicWriteIORef agentState (Just agentInformation)\n\nlaunchDeployment :: Agent -> WSS.DeploymentDetails -> IO ()\nlaunchDeployment agent@Agent {..} deploymentDetails = do\n  agentRegistered <- readIORef agentState\n\n  case agentRegistered of\n    -- TODO: the agent should either not exist before we register or\n    -- we should re-register here as a precaution.\n    Nothing -> pure ()\n    Just agentInformation -> do\n      binDir <- toS <$> getBinDir\n      exitCode <-\n        StdinProcess.readProcess (binDir <> "/.cachix-deployment") [] $\n          toS . Aeson.encode $\n            Deployment.Deployment\n              { Deployment.agentName = name,\n                Deployment.agentToken = token,\n                Deployment.profileName = profileName,\n                Deployment.host = host,\n                Deployment.deploymentDetails = deploymentDetails,\n                Deployment.agentInformation = agentInformation,\n                Deployment.logOptions = logOptions\n              }\n\n      when\n        (bootstrap && exitCode == ExitSuccess)\n        (verifyBootstrapSuccess agent)\n\nverifyBootstrapSuccess :: Agent -> IO ()\nverifyBootstrapSuccess Agent {name, withLog} = do\n  withLog . K.logLocM K.InfoS . K.ls $\n    unwords ["Waiting for another agent to take over..."]\n\n  eAgentPid <-\n    Safe.tryIO $\n      Retry.recoverAll\n        (Retry.limitRetries 20 <> Retry.constantDelay 1000)\n        (const waitForAgent)\n\n  case eAgentPid of\n    Right pid -> do\n      withLog . K.logLocM K.InfoS . K.ls $\n        unwords ["Found an active agent for", name, "with PID " <> show pid <> ".", "Exiting."]\n      exitSuccess\n    _ -> do\n      withLog . K.logLocM K.InfoS . K.ls $\n        unwords ["Cannot find an active agent for", name <> ".", "Waiting for more deployments."]\n  where\n    lockfile = lockFilename name\n\n    -- The PID might be stale in rare cases. Only use this for diagnostics.\n    waitForAgent :: IO Posix.CPid\n    waitForAgent = do\n      lock <- Lock.withTryLock lockfile (pure ())\n      mpid <- Lock.readPidFile lockfile\n      case (lock, mpid) of\n        (Nothing, Just pid) -> pure pid\n        _ -> throwString "No active agent found"\n\nhandleCommand :: Agent -> WSS.BackendCommand -> IO ()\nhandleCommand agent command =\n  case command of\n    WSS.AgentRegistered agentInformation -> registerAgent agent agentInformation\n    WSS.Deployment deploymentDetails -> launchDeployment agent deploymentDetails\n\n-- | Asynchronously open and maintain a websocket connection to the backend for\n-- sending deployment progress updates.\nconnectToService :: ServiceWebSocket -> IO (IO ())\nconnectToService websocket = do\n  close <- MVar.newEmptyMVar\n\n  thread <- Async.async $\n    WebSocket.runConnection websocket $ do\n      WebSocket.handleJSONMessages websocket (MVar.readMVar close)\n\n  -- Block until the initial connection is established\n  void $ MVar.readMVar (WebSocket.connection websocket)\n\n  once $ do\n    void $ MVar.tryPutMVar close ()\n    void $ Timeout.timeout (5 * 1000 * 1000) (Async.wait thread)\n\n-- | Fetch the home directory and verify that the owner matches the current user.\n-- Throws either \'NoHomeFound\' or \'UserDoesNotOwnHome\'.\ncheckUserOwnsHome :: IO ()\ncheckUserOwnsHome = do\n  home <- Directory.getHomeDirectory `onException` throwIO NoHomeFound\n  stat <- Posix.Files.getFileStatus home\n  userId <- Posix.User.getEffectiveUserID\n\n  when (userId /= Posix.Files.fileOwner stat) $ do\n    userName <- Posix.User.userName <$> Posix.User.getUserEntryForID userId\n    sudoUser <- lookupEnv "SUDO_USER"\n    throwIO $\n      UserDoesNotOwnHome\n        { userName = userName,\n          sudoUser = sudoUser,\n          home = home\n        }\n\ndata Error\n  = -- | An agent with the same name is already running.\n    AgentAlreadyRunning Text\n  | -- | No home directory.\n    NoHomeFound\n  | -- | Safeguard against creating root-owned files in user directories.\n    -- This is an issue on macOS, where, by default, sudo does not reset $HOME.\n    UserDoesNotOwnHome\n      { userName :: String,\n        sudoUser :: Maybe String,\n        home :: FilePath\n      }\n  deriving (Show)\n\ninstance Exception Error where\n  displayException = \\case\n    AgentAlreadyRunning agentName -> toS $ unwords ["The agent", agentName, "is already running."]\n    NoHomeFound -> "Could not find the user\xe2\x80\x99s home directory. Make sure to set the $HOME variable."\n    UserDoesNotOwnHome {userName = userName, sudoUser = sudoUser, home = home} ->\n      if isJust sudoUser\n        then toS $ unlines [warningMessage, suggestSudoFlagH]\n        else toS warningMessage\n      where\n        warningMessage = "The current user (" <> toS userName <> ") does not own the home directory (" <> toS home <> ")"\n        suggestSudoFlagH = "Try running the agent with `sudo -H`."\n'