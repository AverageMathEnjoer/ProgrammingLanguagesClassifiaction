b'#include "AssetPluginUtil.h"\n#include "../AssetsTools/AssetTypeClass.h"\n#include "AppContext.h"\n#include <cmath>\n#include <concepts>\n#include <locale>\n#include <codecvt>\n#include <filesystem>\n#include <chrono>\n#include <format>\n\nstd::string AssetUtilDesc::makeExportFilePath(std::unordered_map<std::string, size_t>& nameCountBuffer,\n\tconst std::string &extension, std::string baseDir) const\n{\n\tif (asset.pFile == nullptr || asset.pFile->getFileContext() == nullptr)\n\t\treturn "";\n\tif (baseDir.empty() && asset.pFile->getParentFileID() == 0)\n\t\tbaseDir = asset.pFile->getFileContext()->getFileDirectoryPath();\n\tif (!baseDir.empty())\n\t\tbaseDir += (char)std::filesystem::path::preferred_separator;\n\tstatic_assert((std::filesystem::path::preferred_separator & ~0x7F) == 0, "Path separator is outside the ASCII space");\n\t//std::filesystem::path appears to be a mess with std::string carrying UTF-8 chars on Windows.\n\t//std::filesystem::u8path is deprecated, path(std::string) interprets the string as non-UTF-8.\n\t//-> Only way would be to copy it to a char8_t container or reinterpret the raw string data pointers to char8_t* and pass it to path(..).\n\t//Plain std::string concatenation is easier and should be reliable enough, given that baseDir is good.\n\tstd::string& ret = baseDir;\n\tret += MakeAssetExportName(asset.pathID,\n\t\tassetName, nameCountBuffer,\n\t\tassetsFileName);\n\tret += extension;\n\treturn ret;\n}\n\nstd::string MakeAssetExportName(pathid_t pathID, std::string assetName,\n\tstd::unordered_map<std::string, size_t>& nameCountBuffer,\n\tstd::string assetsFileName)\n{\n\tFilterNameForExportInplace(assetName);\n\tif (assetName.empty()) assetName = "unnamed asset";\n\n\tauto previousInstance = nameCountBuffer.end();\n\n\tchar identifier[32]; identifier[0] = 0;\n\tif (pathID != 0)\n\t{\n\t\tsprintf_s(identifier, "-%lld", (int64_t)pathID);\n\t}\n\telse if (!nameCountBuffer.empty())\n\t{\n\t\tpreviousInstance = nameCountBuffer.find(assetName);\n\t\tif (previousInstance != nameCountBuffer.end())\n\t\t{\n\t\t\tsprintf_s(identifier, "-%zu", previousInstance->second + 1);\n\t\t\tpreviousInstance->second++;\n\t\t}\n\t\telse\n\t\t\tnameCountBuffer.insert({ assetName, 1 });\n\t}\n\telse\n\t\tnameCountBuffer.insert({ assetName, 1 });\n\n\tstd::string ret = std::move(assetName);\n\tif (!assetsFileName.empty())\n\t{\n\t\tret += "-";\n\t\tFilterNameForExportInplace(assetsFileName);\n\t\tret += assetsFileName;\n\t}\n\tret += identifier;\n\treturn ret;\n}\n\nstd::shared_ptr<ResourcesFileContextInfo> FindResourcesFile(class AppContext &appContext,\n\tconst std::string& streamDataFileName, AssetIdentifier& asset,\n\tstd::optional<std::reference_wrapper<TaskProgressManager>> progressManager)\n{\n\tstd::shared_ptr<ResourcesFileContextInfo> ret = nullptr;\n\n\tstd::vector<FileContextInfo_ptr> matchingFiles = appContext.getContextInfo(streamDataFileName, asset.pFile.get());\n\tsize_t numActualCandidates = 0;\n\tfor (FileContextInfo_ptr& curFile : matchingFiles)\n\t{\n\t\tif (curFile->getFileContext() != nullptr && curFile->getFileContext()->getType() == FileContext_Resources)\n\t\t{\n\t\t\tnumActualCandidates++;\n\t\t\tif (!ret) //Use the first candidate.\n\t\t\t\tret = std::dynamic_pointer_cast<ResourcesFileContextInfo>(curFile);\n\t\t}\n\t}\n\tif (ret == nullptr)\n\t{\n\t\t//This case may be a candidate for on-demand loading with C++20 coroutines, e.g. co_await taskManager.enqueue(appContext.CreateFileOpenTask(...))\n\t\t//-> Support for coroutines within AssetExportTask as well as AsyncTask required for this.\n\t\tthrow AssetUtilError(std::string("Unable to locate the streamed data file. Make sure to open it inside the application. Name: ") + streamDataFileName);\n\t}\n\tif (numActualCandidates > 1 && progressManager.has_value())\n\t{\n\t\t//If several matching resource files are found, the plugin uses the \'first one\'.\n\t\t//However, \'first one\' is defined by the order in an unordered_map within AppContext, i.e. is arbitrary.\n\t\tprogressManager->get().logMessage(std::format(\n\t\t\t"Warning while exporting an asset (File ID {0}, Path ID {1}): {2}",\n\t\t\tasset.fileID, (int64_t)asset.pathID, "Found multiple matching streamed data files. Using an arbitrary one."));\n\t}\n\treturn ret;\n}\nAssetTypeTemplateField& TypeTemplateCache::getTemplateField(class AppContext& appContext, class AssetIdentifier &asset,\n\tstd::function<void(AssetTypeTemplateField&)> newTemplateCallback)\n{\n\tif (!asset.pFile)\n\t{\n\t\tasset.resolve(appContext);\n\t\tif (!asset.pFile)\n\t\t\tthrow AssetUtilError("TypeTemplateCache::getTemplateField: Cannot resolve the asset.");\n\t}\n\tunsigned int fileID = asset.pFile->getFileID();\n\tint32_t classID = asset.getClassID();\n\n\t{\n\t\tstd::shared_lock templateCacheLock(templateCacheMutex);\n\t\tauto resultIt = templateCache.find(ClassIdentifier{ fileID, classID });\n\t\tif (resultIt != templateCache.end())\n\t\t\treturn *resultIt->second;\n\t}\n\n\tauto pTemplateBase = std::make_unique<AssetTypeTemplateField>();\n\tif (!asset.pFile->MakeTemplateField(pTemplateBase.get(), appContext, asset.getClassID(), asset.getMonoScriptID(), &asset))\n\t\tthrow AssetUtilError("Unable to extract type information.");\n\tnewTemplateCallback(*pTemplateBase);\n\n\t{\n\t\tstd::scoped_lock templateCacheLock(templateCacheMutex);\n\t\tauto insertResult = templateCache.insert({ ClassIdentifier{ fileID, classID }, std::move(pTemplateBase) });\n\t\t//insertResult.second: true if the insertion actually took place, false if someone else added it in the meantime.\n\t\t//insertResult.first: Iterator to the inserted or existing map entry (which is a .\n\t\tassert(insertResult.first->second != nullptr);\n\t\treturn *insertResult.first->second;\n\t}\n}\n\nAssetExportTask::AssetExportTask(std::vector<AssetUtilDesc> _assets, std::string _taskName,\n\tstd::string _extension, std::string _baseDir,\n\tbool stopOnError, bool writeOnCompletionOnly)\n\t: assets(std::move(_assets)), taskName(std::move(_taskName)),\n\t  extension(std::move(_extension)), baseDir(std::move(_baseDir)),\n\t  stopOnError(stopOnError), writeOnCompletionOnly(writeOnCompletionOnly)\n{}\nconst std::string& AssetExportTask::getName()\n{\n\treturn taskName;\n}\nTaskResult AssetExportTask::execute(TaskProgressManager& progressManager)\n{\n\tunsigned int progressRange = static_cast<unsigned int>(std::min<size_t>(assets.size(), 10000));\n\tsize_t assetsPerProgressStep = assets.size() / progressRange;\n\tprogressManager.setProgress(0, progressRange);\n\tprogressManager.setCancelable();\n\tauto lastDescTime = std::chrono::high_resolution_clock::now();\n\tstd::unordered_map<std::string, size_t> nameClashMap;\n\tbool encounteredErrors = false;\n\tfor (size_t i = 0; i < assets.size(); ++i)\n\t{\n\t\tif (progressManager.isCanceled())\n\t\t\treturn TaskResult_Canceled;\n\t\tif ((i % assetsPerProgressStep) == 0)\n\t\t\tprogressManager.setProgress((unsigned int)(i / assetsPerProgressStep), progressRange);\n\t\tauto curTime = std::chrono::high_resolution_clock::now();\n\t\tif (i == 0 || std::chrono::duration_cast<std::chrono::milliseconds>(curTime - lastDescTime).count() >= 500)\n\t\t{\n\t\t\tprogressManager.setProgressDesc(std::format("Exporting {}/{}", (i + 1), assets.size()));\n\t\t\tlastDescTime = curTime;\n\t\t}\n\t\tstd::string exportPath = (assets.size() > 1) ? assets[i].makeExportFilePath(nameClashMap, extension, baseDir) : baseDir;\n\t\ttry {\n\t\t\tbool result = exportAsset(assets[i], exportPath, progressManager);\n\t\t\tif (!result && stopOnError)\n\t\t\t\treturn (TaskResult)-1;\n\t\t\tif (!result)\n\t\t\t\tencounteredErrors = true;\n\t\t}\n\t\tcatch (AssetUtilError err) {\n\t\t\tprogressManager.logMessage(std::format(\n\t\t\t\t"Error exporting an asset (File ID {0}, Path ID {1}): {2}",\n\t\t\t\tassets[i].asset.fileID, (int64_t)assets[i].asset.pathID, err.what()));\n\t\t\tif (err.getMayStop() && stopOnError)\n\t\t\t\treturn (TaskResult)-1;\n\t\t\tencounteredErrors = true;\n\t\t}\n\t}\n\ttry {\n\t\tonCompletion(baseDir, progressManager);\n\t}\n\tcatch (AssetUtilError err) {\n\t\tprogressManager.logMessage(std::format(\n\t\t\t"Error finishing the export task: {0}", err.what()));\n\t\tif (err.getMayStop() && stopOnError)\n\t\t\treturn (TaskResult)-1;\n\t\tencounteredErrors = true;\n\t}\n\treturn (TaskResult)(encounteredErrors ? -2 : 0);\n}\nvoid AssetExportTask::onCompletion(const std::string& outputPath, std::optional<std::reference_wrapper<TaskProgressManager>> progressManager)\n{}\n\nAssetExportRawTask::AssetExportRawTask(std::vector<AssetUtilDesc> _assets, std::string _taskName,\n\tstd::string _extension, std::string _baseDir, bool stopOnError)\n\t: AssetExportTask(std::move(_assets), std::move(_taskName), std::move(_extension), std::move(_baseDir), stopOnError)\n{}\nbool AssetExportRawTask::exportAsset(AssetUtilDesc& desc, std::string path, std::optional<std::reference_wrapper<TaskProgressManager>> progressManager)\n{\n\tIAssetsReader_ptr pReader = desc.asset.makeReader();\n\tif (pReader == nullptr)\n\t\tthrow AssetUtilError("Unable to read the asset.");\n\tQWORD size = 0;\n\tif (!pReader->Seek(AssetsSeek_End, 0) || !pReader->Tell(size) || !pReader->Seek(AssetsSeek_Begin, 0))\n\t\tthrow AssetUtilError("Unable to read the asset.");\n\tstd::unique_ptr<AssetsEntryReplacer> pReplacer(MakeAssetModifierFromReader(0, 0, -1, (uint16_t)-1, pReader.get(), size));\n\tif (pReplacer == nullptr)\n\t\tthrow AssetUtilError("Unexpected runtime error.");\n\tstd::unique_ptr<IAssetsWriter> pWriter(Create_AssetsWriterToFile(path.c_str(), true, true, RWOpenFlags_Immediately));\n\tif (pWriter == nullptr)\n\t\tthrow AssetUtilError("Unable to create the output file.");\n\n\tif (pReplacer->Write(0, pWriter.get()) != size)\n\t\tthrow AssetUtilError("Unable to write the asset.");\n\treturn true;\n}\n\ntemplate <typename floatT>\nrequires std::same_as<floatT, float> || std::same_as<floatT, double>\nstatic void formatFloatStr(floatT fval, std::string& outStr)\n{\n\t//float and double are always IEEE-754 binary32/64.\n\tif (fval == std::numeric_limits<floatT>::infinity()\n\t\t|| fval == -std::numeric_limits<floatT>::infinity())\n\t{\n\t\toutStr.insert(outStr.size(), (fval < 0) ? "\\"-" : "\\"+");\n\t\toutStr.insert(outStr.size(), "Infinity\\"");\n\t}\n\telse if (isinf(fval) || isnan(fval))\n\t{\n\t\tassert(!isinf(fval)); //Should be covered by the previous check.\n\t\ttypename std::conditional<sizeof(floatT) == 4, uint32_t, uint64_t>::type f_as_uint;\n\t\tf_as_uint = *reinterpret_cast<decltype(f_as_uint)*>(&fval);\n\t\tconstexpr std::string_view fmt = (sizeof(floatT) == 4) ? "\\"0x{:08X}\\"" : "\\"0x{:016X}\\"";\n\t\tstd::format_to(std::back_inserter(outStr), fmt, f_as_uint);\n\t}\n\telse\n\t{\n\t\tconstexpr std::string_view fmt = (sizeof(floatT) == 4) ? "{:.9g}" : "{:.17g}";\n\t\tstd::format_to(std::back_inserter(outStr), fmt, fval);\n\t}\n}\n\ntemplate <typename floatT>\nrequires std::same_as<floatT, float> || std::same_as<floatT, double>\nstatic bool parseFloatStr(floatT &outFloat, const std::string& str)\n{\n\toutFloat = 0.0;\n\tif (str.empty())\n\t\treturn false;\n\tif (str[0] == \'"\')\n\t{\n\t\tif (str.length() == 1 || str.back() != \'"\')\n\t\t\treturn false;\n\t\tif (0==str.compare(1, std::string::npos, "+Infinity\\"")\n\t\t\t|| 0==str.compare(1, std::string::npos, "Infinity\\""))\n\t\t{\n\t\t\toutFloat = std::numeric_limits<floatT>::infinity();\n\t\t\treturn true;\n\t\t}\n\t\tif (0==str.compare(1, std::string::npos, "-Infinity\\""))\n\t\t{\n\t\t\toutFloat = -std::numeric_limits<floatT>::infinity();\n\t\t\treturn true;\n\t\t}\n\t\tif (0==str.compare(1, 2, "0x"))\n\t\t{\n\t\t\ttypename std::conditional<sizeof(floatT) == 4, uint32_t, uint64_t>::type f_as_uint;\n\t\t\tchar* endptr = nullptr;\n\t\t\tf_as_uint = (decltype(f_as_uint))_strtoui64(&str.c_str()[3], &endptr, 16);\n\t\t\tif (endptr != &str.c_str()[str.size() - 1]) //Position of closing \'"\'\n\t\t\t\treturn false;\n\t\t\toutFloat = *reinterpret_cast<floatT*>(&f_as_uint);\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\ttry {\n\t\tstruct _stof_wrap\n\t\t{\n\t\t\tinline float operator()(const std::string &str) { return std::stof(str); }\n\t\t};\n\t\tstruct _stod_wrap\n\t\t{\n\t\t\tinline double operator()(const std::string& str) { return std::stod(str); }\n\t\t};\n\t\ttypename std::conditional<sizeof(floatT) == 4, _stof_wrap, _stod_wrap>::type converter;\n\t\toutFloat = converter(str);\n\t\treturn true;\n\t}\n\tcatch (std::invalid_argument) { return false; }\n\tcatch (std::out_of_range) { return false; }\n\tassert(false);\n\treturn false;\n}\n\nAssetExportDumpTask::AssetExportDumpTask(class AppContext& appContext,\n\tstd::vector<AssetUtilDesc> _assets, std::string _taskName,\n\tstd::string _extension, std::string _baseDir, bool stopOnError)\n\t: AssetExportTask(std::move(_assets), std::move(_taskName), std::move(_extension), std::move(_baseDir), stopOnError),\n\tappContext(appContext)\n{}\nbool AssetExportDumpTask::exportAsset(AssetUtilDesc& desc, std::string path, std::optional<std::reference_wrapper<TaskProgressManager>> progressManager)\n{\n\tif (desc.asset.pFile == nullptr)\n\t\tthrow AssetUtilError("Unable to find the .assets file.");\n\n\tIAssetsReader_ptr pReader = desc.asset.makeReader();\n\tif (pReader == nullptr)\n\t\tthrow AssetUtilError("Unable to read the asset.");\n\tQWORD size = 0;\n\tif (!pReader->Seek(AssetsSeek_End, 0) || !pReader->Tell(size) || !pReader->Seek(AssetsSeek_Begin, 0))\n\t\tthrow AssetUtilError("Unable to read the asset.");\n\n\tAssetTypeTemplateField templateBase;\n\tif (!desc.asset.pFile->MakeTemplateField(&templateBase, appContext, desc.asset.getClassID(), desc.asset.getMonoScriptID(), &desc.asset))\n\t\tthrow AssetUtilError("Unable to extract type information.");\n\tAssetTypeTemplateField *pTemplateBase = &templateBase;\n\n\tAssetTypeInstance assetInstance(1, &pTemplateBase, size, pReader.get(), desc.asset.isBigEndian());\n\tAssetTypeValueField* pBaseField = assetInstance.GetBaseField();\n\tif (pBaseField == nullptr || pBaseField->IsDummy())\n\t\tthrow AssetUtilError("Unable to deserialize the asset.");\n\n\tstd::unique_ptr<IAssetsWriter> pWriter(Create_AssetsWriterToFile(path.c_str(), true, true, RWOpenFlags_Immediately));\n\tif (pWriter == nullptr)\n\t\tthrow AssetUtilError("Unable to create the output file.");\n\n\tdumpAsset(pReader.get(), pBaseField, pWriter.get());\n\n\treturn true;\n}\n\nstruct _Dump_OutputLineBufHandler\n{\n\tstd::string& lineBuf;\n\tIAssetsWriter* pWriter;\n\t_Dump_OutputLineBufHandler(std::string& lineBuf, IAssetsWriter* pWriter)\n\t\t: lineBuf(lineBuf), pWriter(pWriter)\n\t{}\n\tvoid operator()()\n\t{\n\t\tsize_t size = lineBuf.size() * sizeof(decltype(lineBuf.data()[0]));\n\t\tif (size > 0 && size != pWriter->Write(size, lineBuf.data()))\n\t\t\tthrow AssetUtilError("Unable to write the dump.");\n\t}\n};\nstruct _Dump_OutputRawCharsHandler\n{\n\tIAssetsWriter* pWriter;\n\t_Dump_OutputRawCharsHandler(IAssetsWriter* pWriter)\n\t\t: pWriter(pWriter)\n\t{}\n\tvoid operator()(const char* begin, size_t count)\n\t{\n\t\tsize_t size = count * sizeof(decltype(begin[0]));\n\t\tif (size > 0 && size != pWriter->Write(size, begin))\n\t\t\tthrow AssetUtilError("Unable to write the dump.");\n\t}\n};\n\nAssetExportTextDumpTask::AssetExportTextDumpTask(class AppContext& appContext,\n\tstd::vector<AssetUtilDesc> _assets, std::string _taskName,\n\tstd::string _extension, std::string _baseDir, bool stopOnError)\n\t: AssetExportDumpTask(appContext, std::move(_assets), std::move(_taskName), std::move(_extension), std::move(_baseDir), stopOnError)\n{}\nvoid AssetExportTextDumpTask::dumpAsset(IAssetsReader* pReader, AssetTypeValueField* pBaseField, IAssetsWriter* pDumpWriter)\n{\n\tstd::string lineBuf;\n\trecursiveDumpAsset(pReader, pBaseField, 0, pDumpWriter, lineBuf);\n}\nvoid AssetExportTextDumpTask::recursiveDumpAsset(IAssetsReader* pReader, AssetTypeValueField* pField, size_t depth,\n\tIAssetsWriter* pDumpWriter, std::string &lineBuf)\n{\n\tif (pField == nullptr)\n\t\tthrow AssetUtilError("Null field encountered.");\n\n\t_Dump_OutputLineBufHandler outputLineBuf(lineBuf, pDumpWriter);\n\t_Dump_OutputRawCharsHandler outputRawChars(pDumpWriter);\n\n\tlineBuf.clear();\n\tfor (size_t i = 0; i < depth; ++i)\n\t\tlineBuf += " ";\n\toutputLineBuf();\n\n\tEnumValueTypes valueType = ValueType_None;\n\tif (pField->GetValue() != NULL)\n\t\tvalueType = pField->GetValue()->GetType();\n\tint alignment = (int)pField->GetTemplateField()->align;\n\t\n\tswitch (valueType)\n\t{\n\t\tcase ValueType_Bool:\n\t\t\tlineBuf.clear();\n\t\t\tstd::format_to(std::back_inserter(lineBuf), \n\t\t\t\t"{} {} {} = {}\\r\\n", alignment, pField->GetType(), pField->GetName(), pField->GetValue()->AsBool() ? "true" : "false");\n\t\t\toutputLineBuf();\n\t\t\tbreak;\n\t\tcase ValueType_Int8:\n\t\tcase ValueType_Int16:\n\t\tcase ValueType_Int32:\n\t\tcase ValueType_Int64:\n\t\t\tlineBuf.clear();\n\t\t\tstd::format_to(std::back_inserter(lineBuf),\n\t\t\t\t"{} {} {} = {}\\r\\n", alignment, pField->GetType(), pField->GetName(), pField->GetValue()->AsInt64());\n\t\t\toutputLineBuf();\n\t\t\tbreak;\n\t\tcase ValueType_UInt8:\n\t\tcase ValueType_UInt16:\n\t\tcase ValueType_UInt32:\n\t\tcase ValueType_UInt64:\n\t\t\tlineBuf.clear();\n\t\t\tstd::format_to(std::back_inserter(lineBuf),\n\t\t\t\t"{} {} {} = {}\\r\\n", alignment, pField->GetType(), pField->GetName(), pField->GetValue()->AsUInt64());\n\t\t\toutputLineBuf();\n\t\t\tbreak;\n\t\tcase ValueType_Float:\n\t\t\tlineBuf.clear();\n\t\t\tstd::format_to(std::back_inserter(lineBuf),\n\t\t\t\t"{} {} {} = ", alignment, pField->GetType(), pField->GetName());\n\t\t\tformatFloatStr(pField->GetValue()->AsFloat(), lineBuf);\n\t\t\tlineBuf.insert(lineBuf.size(), "\\r\\n");\n\t\t\toutputLineBuf();\n\t\t\tbreak;\n\t\tcase ValueType_Double:\n\t\t\tlineBuf.clear();\n\t\t\tstd::format_to(std::back_inserter(lineBuf),\n\t\t\t\t"{} {} {} = ", alignment, pField->GetType(), pField->GetName());\n\t\t\tformatFloatStr(pField->GetValue()->AsDouble(), lineBuf);\n\t\t\tlineBuf.insert(lineBuf.size(), "\\r\\n");\n\t\t\toutputLineBuf();\n\t\t\tbreak;\n\t\tcase ValueType_String:\n\t\t\t{\n\t\t\t\tif (pField->GetTemplateField()->children.size() > 0 && pField->GetTemplateField()->children[0].align)\n\t\t\t\t\talignment = true;\n\t\t\t\tlineBuf.clear();\n\t\t\t\tstd::format_to(std::back_inserter(lineBuf),\n\t\t\t\t\t"{} {} {} = \\"", alignment, pField->GetType(), pField->GetName());\n\t\t\t\toutputLineBuf();\n\t\t\t\tchar *strValue = pField->GetValue()->AsString();\n\t\t\t\t//Escape the string: \'\\r\' -> "\\\\r", \'\\n\' -> "\\\\n" and \'\\\\\' -> "\\\\\\\\".\n\t\t\t\t// \'\\"\' is not escaped, since the string end can be inferred from the line end.\n\t\t\t\tsize_t strLen = strlen(strValue); size_t strPos = 0;\n\t\t\t\tfor (size_t i = 0; i < strLen; i++)\n\t\t\t\t{\n\t\t\t\t\tif (strValue[i] == \'\\\\\')\n\t\t\t\t\t{\n\t\t\t\t\t\t//Output characters: strValue[strPos, i]\n\t\t\t\t\t\toutputRawChars(&strValue[strPos], i - strPos + 1);\n\t\t\t\t\t\toutputRawChars("\\\\", 1);\n\t\t\t\t\t\tstrPos = i+1;\n\t\t\t\t\t}\n\t\t\t\t\telse if (strValue[i] == \'\\r\' || strValue[i] == \'\\n\')\n\t\t\t\t\t{\n\t\t\t\t\t\t//Output characters: strValue[strPos, i)\n\t\t\t\t\t\toutputRawChars(&strValue[strPos], i - strPos);\n\t\t\t\t\t\toutputRawChars((strValue[i] == \'\\r\') ? "\\\\r" : "\\\\n", 2);\n\t\t\t\t\t\tstrPos = i+1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//Output characters: strValue[strPos, strLen)\n\t\t\t\toutputRawChars(&strValue[strPos], strLen - strPos);\n\t\t\t\toutputRawChars("\\"\\r\\n", 3);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase ValueType_ByteArray:\n\t\t\t{\n\t\t\t\tif (pField->GetTemplateField()->children.size() != 2)\n\t\t\t\t\tthrow AssetUtilError("Unexpected byte array serialization.");\n\t\t\t\tAssetTypeByteArray *pByteArray = pField->GetValue()->AsByteArray();\n\t\t\t\tlineBuf.clear();\n\t\t\t\tstd::format_to(std::back_inserter(lineBuf),\n\t\t\t\t\t"{} {} {} ({} items)\\r\\n", alignment, pField->GetType(), pField->GetName(), pByteArray->size);\n\t\t\t\toutputLineBuf();\n\t\t\t\tlineBuf.clear();\n\t\t\t\tfor (size_t i = 0; i <= depth; ++i)\n\t\t\t\t\tlineBuf += " ";\n\t\t\t\tAssetTypeTemplateField *countVal = &pField->GetTemplateField()->children[0];\n\t\t\t\tstd::format_to(std::back_inserter(lineBuf),\n\t\t\t\t\t"{} {} {} = {}\\r\\n", 0, countVal->type, countVal->name, pByteArray->size);\n\t\t\t\toutputLineBuf();\n\t\t\t\tAssetTypeTemplateField *byteVal = &pField->GetTemplateField()->children[1];\n\t\t\t\tfor (uint32_t i = 0; i < pByteArray->size; i++)\n\t\t\t\t{\n\t\t\t\t\tlineBuf.clear();\n\t\t\t\t\tfor (size_t i = 0; i <= depth; ++i)\n\t\t\t\t\t\tlineBuf += " ";\n\t\t\t\t\tstd::format_to(std::back_inserter(lineBuf),\n\t\t\t\t\t\t"[{}]\\r\\n", i);\n\t\t\t\t\toutputLineBuf();\n\t\t\t\t\tlineBuf.clear();\n\t\t\t\t\tfor (size_t i = 0; i <= depth+1; ++i)\n\t\t\t\t\t\tlineBuf += " ";\n\t\t\t\t\tstd::format_to(std::back_inserter(lineBuf),\n\t\t\t\t\t\t"{} {} {} = {}\\r\\n", 0, byteVal->type, byteVal->name, pByteArray->data[i]);\n\t\t\t\t\toutputLineBuf();\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase ValueType_Array:\n\t\t\t{\n\t\t\t\tif (pField->GetTemplateField()->children.size() != 2)\n\t\t\t\t\tthrow AssetUtilError("Unexpected array serialization.");\n\t\t\t\tlineBuf.clear();\n\t\t\t\tstd::format_to(std::back_inserter(lineBuf),\n\t\t\t\t\t"{} {} {} ({} items)\\r\\n", alignment, pField->GetType(), pField->GetName(), pField->GetChildrenCount());\n\t\t\t\toutputLineBuf();\n\t\t\t\tlineBuf.clear();\n\t\t\t\tfor (size_t i = 0; i <= depth; ++i)\n\t\t\t\t\tlineBuf += " ";\n\t\t\t\tAssetTypeTemplateField *countVal = &pField->GetTemplateField()->children[0];\n\t\t\t\tstd::format_to(std::back_inserter(lineBuf),\n\t\t\t\t\t"{} {} {} = {}\\r\\n", 0, countVal->type, countVal->name, pField->GetChildrenCount());\n\t\t\t\toutputLineBuf();\n\t\t\t\tfor (uint32_t i = 0; i < pField->GetChildrenCount(); i++)\n\t\t\t\t{\n\t\t\t\t\tlineBuf.clear();\n\t\t\t\t\tfor (size_t i = 0; i <= depth; ++i)\n\t\t\t\t\t\tlineBuf += " ";\n\t\t\t\t\tstd::format_to(std::back_inserter(lineBuf),\n\t\t\t\t\t\t"[{}]\\r\\n", i);\n\t\t\t\t\toutputLineBuf();\n\t\t\t\t\trecursiveDumpAsset(pReader, pField->operator[](i), depth + 2, pDumpWriter, lineBuf);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase ValueType_None:\n\t\t\t{\n\t\t\t\tlineBuf.clear();\n\t\t\t\tstd::format_to(std::back_inserter(lineBuf),\n\t\t\t\t\t"{} {} {}\\r\\n", alignment, pField->GetType(), pField->GetName());\n\t\t\t\toutputLineBuf();\n\t\t\t\tfor (uint32_t i = 0; i < pField->GetChildrenCount(); i++)\n\t\t\t\t{\n\t\t\t\t\trecursiveDumpAsset(pReader, pField->operator[](i), depth + 1, pDumpWriter, lineBuf);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t}\n}\n\nAssetExportJSONDumpTask::AssetExportJSONDumpTask(class AppContext& appContext,\n\tstd::vector<AssetUtilDesc> _assets, std::string _taskName,\n\tstd::string _extension, std::string _baseDir, bool stopOnError)\n\t: AssetExportDumpTask(appContext, std::move(_assets), std::move(_taskName), std::move(_extension), std::move(_baseDir), stopOnError)\n{}\nvoid AssetExportJSONDumpTask::dumpAsset(IAssetsReader* pReader, AssetTypeValueField* pBaseField, IAssetsWriter* pDumpWriter)\n{\n\tstd::string lineBuf;\n\t_Dump_OutputLineBufHandler outputLineBuf(lineBuf, pDumpWriter);\n\tlineBuf.assign("{\\r\\n    ");\n\toutputLineBuf();\n\t\n\trecursiveDumpAsset(pReader, pBaseField, 1, pDumpWriter, lineBuf);\n\n\tlineBuf.assign("\\r\\n}");\n\toutputLineBuf();\n}\n\n\nvoid AssetExportJSONDumpTask::recursiveDumpAsset(IAssetsReader* pReader, AssetTypeValueField* pField, size_t depth,\n\tIAssetsWriter* pDumpWriter, std::string& lineBuf, bool dumpValueOnly)\n{\n\tconstexpr bool stripExtendedInfo = false;\n\tif (pField == nullptr)\n\t\tthrow AssetUtilError("Null field encountered.");\n\n\t_Dump_OutputLineBufHandler outputLineBuf(lineBuf, pDumpWriter);\n\t_Dump_OutputRawCharsHandler outputRawChars(pDumpWriter);\n\n\tEnumValueTypes valueType = ValueType_None;\n\tif (pField->GetValue() != NULL)\n\t\tvalueType = pField->GetValue()->GetType();\n\n\tif (!dumpValueOnly)\n\t{\n\t\tbool alignment = pField->GetTemplateField()->align ||\n\t\t\t(valueType == ValueType_String && (pField->GetTemplateField()->children.size() > 0 && pField->GetTemplateField()->children[0].align));\n\t\tstd::string fieldName;\n\t\tif (stripExtendedInfo)\n\t\t\tfieldName.assign(pField->GetName());\n\t\telse\n\t\t\tfieldName = std::format("{} {} {}", alignment ? "1" : "0", pField->GetType(), pField->GetName());\n\t\tlineBuf.clear();\n\t\tstd::format_to(std::back_inserter(lineBuf),\n\t\t\t"\\"{}\\": ", fieldName);\n\t\toutputLineBuf();\n\t}\n\n\tswitch (valueType)\n\t{\n\t\tcase ValueType_Bool:\n\t\t\tif (pField->GetValue()->AsBool())\n\t\t\t\tlineBuf.assign("true");\n\t\t\telse\n\t\t\t\tlineBuf.assign("false");\n\t\t\toutputLineBuf();\n\t\t\tbreak;\n\t\tcase ValueType_Int8:\n\t\tcase ValueType_Int16:\n\t\tcase ValueType_Int32:\n\t\t\tlineBuf.clear();\n\t\t\tstd::format_to(std::back_inserter(lineBuf), "{}", pField->GetValue()->AsInt());\n\t\t\toutputLineBuf();\n\t\t\tbreak;\n\t\tcase ValueType_UInt8:\n\t\tcase ValueType_UInt16:\n\t\tcase ValueType_UInt32:\n\t\t\tlineBuf.clear();\n\t\t\tstd::format_to(std::back_inserter(lineBuf), "{}", pField->GetValue()->AsUInt());\n\t\t\toutputLineBuf();\n\t\t\tbreak;\n\t\tcase ValueType_Int64:\n\t\t\tlineBuf.clear();\n\t\t\tstd::format_to(std::back_inserter(lineBuf), "\\"{}\\"", pField->GetValue()->AsInt64());\n\t\t\toutputLineBuf();\n\t\t\tbreak;\n\t\tcase ValueType_UInt64:\n\t\t\tlineBuf.clear();\n\t\t\tstd::format_to(std::back_inserter(lineBuf), "\\"{}\\"", pField->GetValue()->AsUInt64());\n\t\t\toutputLineBuf();\n\t\t\tbreak;\n\t\tcase ValueType_Float:\n\t\t\tlineBuf.clear();\n\t\t\tformatFloatStr(pField->GetValue()->AsFloat(), lineBuf);\n\t\t\toutputLineBuf();\n\t\t\tbreak;\n\t\tcase ValueType_Double:\n\t\t\tlineBuf.clear();\n\t\t\tformatFloatStr(pField->GetValue()->AsDouble(), lineBuf);\n\t\t\toutputLineBuf();\n\t\t\tbreak;\n\t\tcase ValueType_String:\n\t\t\t{\n\t\t\t\toutputRawChars("\\"", 1);\n\t\t\t\tchar *strValue = pField->GetValue()->AsString();\n\t\t\t\tsize_t strLen = strlen(strValue); size_t strPos = 0;\n\t\t\t\tfor (size_t i = 0; i < strLen; i++)\n\t\t\t\t{\n\t\t\t\t\tif (strValue[i] & 0x80) //UTF-8 character has another byte ((char & 0xC0) == 0x80 for the 2nd/3rd/4th byte)\n\t\t\t\t\t{\n\t\t\t\t\t\t//Output strValue[strPos,i]\n\t\t\t\t\t\toutputRawChars(&strValue[strPos], i - strPos + 1);\n\t\t\t\t\t\tstrPos = i+1;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tlineBuf.clear();\n\t\t\t\t\t\tconst char *replaceString = NULL;\n\t\t\t\t\t\tswitch (strValue[i])\n\t\t\t\t\t\t{\n\t\t\t\t\t\tcase \'\\\\\':\n\t\t\t\t\t\t\tlineBuf.assign("\\\\\\\\");\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase \'"\':\n\t\t\t\t\t\t\tlineBuf.assign("\\\\\\"");\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase \'\\b\':\n\t\t\t\t\t\t\tlineBuf.assign("\\\\b");\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase \'\\f\':\n\t\t\t\t\t\t\tlineBuf.assign("\\\\f");\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase \'\\n\':\n\t\t\t\t\t\t\tlineBuf.assign("\\\\n");\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase \'\\r\':\n\t\t\t\t\t\t\tlineBuf.assign("\\\\r");\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase \'\\t\':\n\t\t\t\t\t\t\tlineBuf.assign("\\\\t");\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tif (strValue[i] < 0x20)\n\t\t\t\t\t\t\t\tstd::format_to(std::back_inserter(lineBuf), "\\\\u{:04u}", strValue[i]);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!lineBuf.empty())\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t//Output strValue[strPos,i)\n\t\t\t\t\t\t\toutputRawChars(&strValue[strPos], i - strPos);\n\t\t\t\t\t\t\tstrPos = i;\n\t\t\t\t\t\t\toutputLineBuf();\n\t\t\t\t\t\t\tstrPos++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//Output strValue[strPos,strLen)\n\t\t\t\toutputRawChars(&strValue[strPos], strLen - strPos);\n\t\t\t\toutputRawChars("\\"", 1);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase ValueType_ByteArray:\n\t\t\t{\n\t\t\t\tAssetTypeByteArray *pByteArray = pField->GetValue()->AsByteArray();\n\t\t\t\toutputRawChars("[", 1);\n\t\t\t\tfor (uint32_t i = 0; i < pByteArray->size; i++)\n\t\t\t\t{\n\t\t\t\t\tif (i)\n\t\t\t\t\t\tpDumpWriter->Write(2, ", ");\n\t\t\t\t\tlineBuf.clear();\n\t\t\t\t\tstd::format_to(std::back_inserter(lineBuf), "{}", pByteArray->data[i]);\n\t\t\t\t\toutputLineBuf();\n\t\t\t\t}\n\t\t\t\toutputRawChars("]", 1);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase ValueType_Array:\n\t\t\t{\n\t\t\t\tif (pField->GetChildrenCount() > 0)\n\t\t\t\t\toutputRawChars("[\\r\\n", 3);\n\t\t\t\telse\n\t\t\t\t\toutputRawChars("[", 1);\n\t\t\t\t//bool writeChildAsObject = !field->GetTemplateField()->children[1].hasValue;\n\t\t\t\tfor (uint32_t i = 0; i < pField->GetChildrenCount(); i++)\n\t\t\t\t{\n\t\t\t\t\tlineBuf.clear();\n\t\t\t\t\tif (i != 0)\n\t\t\t\t\t\tlineBuf += ",\\r\\n";\n\t\t\t\t\tfor (size_t _i = 0; _i <= depth; ++_i)\n\t\t\t\t\t\tlineBuf += "    ";\n\t\t\t\t\tif (!stripExtendedInfo)\n\t\t\t\t\t\tlineBuf += "{";\n\t\t\t\t\toutputLineBuf();\n\t\t\t\t\trecursiveDumpAsset(pReader, pField->operator[](i), depth + 1, pDumpWriter, lineBuf, stripExtendedInfo);\n\t\t\t\t\tif (!stripExtendedInfo)\n\t\t\t\t\t\toutputRawChars("}", 1);\n\t\t\t\t}\n\t\t\t\tif (pField->GetChildrenCount() > 0)\n\t\t\t\t{\n\t\t\t\t\tlineBuf.clear();\n\t\t\t\t\tlineBuf += "\\r\\n";\n\t\t\t\t\tfor (size_t _i = 0; _i < depth; _i++)\n\t\t\t\t\t\tlineBuf += "    ";\n\t\t\t\t\toutputLineBuf();\n\t\t\t\t}\n\t\t\t\toutputRawChars("]", 1);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase ValueType_None:\n\t\t\t{\n\t\t\t\tbool drawBrackets = false;\n\t\t\t\tif (dumpValueOnly)\n\t\t\t\t{\n\t\t\t\t\tif (pField->GetChildrenCount() > 1)\n\t\t\t\t\t{\n\t\t\t\t\t\toutputRawChars("{\\r\\n", 3);\n\t\t\t\t\t\tdrawBrackets = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (pField->GetChildrenCount() > 1)\n\t\t\t\t{\n\t\t\t\t\tlineBuf.clear();\n\t\t\t\t\tlineBuf += "\\r\\n";\n\t\t\t\t\tfor (size_t _i = 0; _i < depth; _i++)\n\t\t\t\t\t\tlineBuf += "    ";\n\t\t\t\t\tlineBuf += "{\\r\\n";\n\t\t\t\t\toutputLineBuf();\n\t\t\t\t\tdrawBrackets = true;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\toutputRawChars(" {\\r\\n", 4);\n\t\t\t\t\tdrawBrackets = true;\n\t\t\t\t}\n\t\t\t\tfor (uint32_t i = 0; i < pField->GetChildrenCount(); i++)\n\t\t\t\t{\n\t\t\t\t\tlineBuf.clear();\n\t\t\t\t\tif (i != 0)\n\t\t\t\t\t\tlineBuf += ",\\r\\n";\n\t\t\t\t\tfor (size_t _i = 0; _i <= depth; _i++)\n\t\t\t\t\t\tlineBuf += "    ";\n\t\t\t\t\toutputLineBuf();\n\t\t\t\t\trecursiveDumpAsset(pReader, pField->operator[](i), depth + 1, pDumpWriter, lineBuf);\n\t\t\t\t}\n\t\t\t\tlineBuf.clear();\n\t\t\t\tif (pField->GetChildrenCount() > 0)\n\t\t\t\t\tlineBuf += "\\r\\n";\n\t\t\t\tif (drawBrackets)\n\t\t\t\t{\n\t\t\t\t\tfor (size_t _i = 0; _i < depth; _i++)\n\t\t\t\t\t\tlineBuf += "    ";\n\t\t\t\t\tlineBuf += "}";\n\t\t\t\t}\n\t\t\t\toutputLineBuf();\n\t\t\t}\n\t\t\tbreak;\n\t}\n}\n\n\n\n\nCGenericBatchImportDialogDesc::CGenericBatchImportDialogDesc(std::vector<AssetUtilDesc> _elements, const std::string& extensionRegex)\n\t: elements(std::move(_elements))\n{\n\tfor (size_t i = 0; i < elements.size(); ++i)\n\t{\n\t\tif (elements[i].asset.pathID != 0)\n\t\t\telementByPathID.insert({ elements[i].asset.pathID, i });\n\t}\n\timportFilePaths.resize(elements.size());\n\timportFilePathOverrides.resize(elements.size());\n\tregex = MakeImportFileNameRegex(extensionRegex);\n}\nbool CGenericBatchImportDialogDesc::GetImportableAssetDescs(OUT std::vector<AssetDesc>& nameList)\n{\n\tnameList.reserve(elements.size());\n\tfor (size_t i = 0; i < elements.size(); i++)\n\t{\n\t\tAssetDesc curDesc;\n\t\tstd::string& desc = getElementDescription(i);\n\t\tcurDesc.description = desc.c_str();\n\t\tcurDesc.assetsFileName = elements[i].assetsFileName.c_str();\n\t\tcurDesc.pathID = static_cast<pathid_t>(elements[i].asset.pathID);\n\t\tnameList.push_back(curDesc);\n\t}\n\treturn true;\n}\nbool CGenericBatchImportDialogDesc::GetFilenameMatchStrings(OUT std::vector<const char*>& regexList, OUT bool& checkSubDirs)\n{\n\tregexList.push_back(regex.c_str());\n\tcheckSubDirs = false;\n\treturn true;\n}\nbool CGenericBatchImportDialogDesc::GetFilenameMatchInfo(IN const char* filename, IN std::vector<const char*>& capturingGroups, OUT size_t& matchIndex)\n{\n\tconst char* assetsFileName = nullptr; pathid_t pathID = 0;\n\tmatchIndex = (size_t)-1;\n\tif (RetrieveImportRegexInfo(capturingGroups, assetsFileName, pathID))\n\t{\n\t\tauto it_pair = elementByPathID.equal_range(pathID);\n\t\tfor (auto it = it_pair.first; it != it_pair.second; ++it)\n\t\t{\n\t\t\tsize_t i = it->second;\n\t\t\tassert(pathID == elements[i].asset.pathID);\n\t\t\tstd::string elementFileNameFiltered = elements[i].assetsFileName;\n\t\t\tFilterNameForExportInplace(elementFileNameFiltered);\n\t\t\tif (elementFileNameFiltered == assetsFileName)\n\t\t\t{\n\t\t\t\tmatchIndex = i;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\nvoid CGenericBatchImportDialogDesc::SetInputFilepath(IN size_t matchIndex, IN const char* filepath)\n{\n\tif (matchIndex < importFilePaths.size())\n\t{\n\t\timportFilePaths[matchIndex].assign(filepath ? filepath : "");\n\t}\n}\nbool CGenericBatchImportDialogDesc::HasFilenameOverride(IN size_t matchIndex, OUT std::string& filenameOverride, OUT bool& relativeToBasePath)\n{\n\trelativeToBasePath = false;\n\tif (matchIndex >= importFilePathOverrides.size())\n\t\treturn false;\n\tif (importFilePathOverrides[matchIndex].size() > 0)\n\t{\n\t\tfilenameOverride.assign(importFilePathOverrides[matchIndex]);\n\t\treturn true;\n\t}\n\tfilenameOverride.clear();\n\treturn false;\n}\n\nAssetImportTask::AssetImportTask(std::vector<AssetUtilDesc> _assets, std::vector<std::string> _importFilePaths,\n\t\tstd::string _taskName, bool stopOnError)\n\t: assets(std::move(_assets)), importFilePaths(std::move(_importFilePaths)),\n\ttaskName(std::move(_taskName)), stopOnError(stopOnError)\n{\n\tif (assets.size() != importFilePaths.size())\n\t\tthrow std::invalid_argument("AssetImportTask: assets and importFilePaths should have matching numbers of elements!");\n}\nconst std::string& AssetImportTask::getName()\n{\n\treturn taskName;\n}\nTaskResult AssetImportTask::execute(TaskProgressManager& progressManager)\n{\n\tunsigned int progressRange = static_cast<unsigned int>(std::max<size_t>(std::min<size_t>(assets.size(), 10000), 1));\n\tsize_t assetsPerProgressStep = assets.size() / progressRange;\n\tconstexpr size_t assetsPerDescUpdate = 8;\n\tprogressManager.setCancelable();\n\tprogressManager.setProgress(0, progressRange);\n\tauto lastDescTime = std::chrono::high_resolution_clock::time_point::min();\n\tbool encounteredErrors = false;\n\tfor (size_t i = 0; i < assets.size(); ++i)\n\t{\n\t\tif (progressManager.isCanceled())\n\t\t\treturn TaskResult_Canceled;\n\t\tif ((i % assetsPerProgressStep) == 0)\n\t\t\tprogressManager.setProgress((unsigned int)(i / assetsPerProgressStep), progressRange);\n\t\tauto curTime = std::chrono::high_resolution_clock::now();\n\t\tif (std::chrono::duration_cast<std::chrono::milliseconds>(curTime - lastDescTime).count() >= 500)\n\t\t{\n\t\t\tprogressManager.setProgressDesc(std::format("Importing {}/{}", (i + 1), assets.size()));\n\t\t\tlastDescTime = curTime;\n\t\t}\n\t\ttry {\n\t\t\tbool result = (importFilePaths[i].empty() || importAsset(assets[i], importFilePaths[i], progressManager));\n\t\t\tif (!result && stopOnError)\n\t\t\t\treturn (TaskResult)-1;\n\t\t\tif (!result)\n\t\t\t\tencounteredErrors = true;\n\t\t}\n\t\tcatch (AssetUtilError err) {\n\t\t\tprogressManager.logMessage(std::format(\n\t\t\t\t"Error importing an asset (File ID {0}, Path ID {1}): {2}",\n\t\t\t\tassets[i].asset.fileID, (int64_t)assets[i].asset.pathID, err.what()));\n\t\t\tif (err.getMayStop() && stopOnError)\n\t\t\t\treturn (TaskResult)-1;\n\t\t\tencounteredErrors = true;\n\t\t}\n\t}\n\treturn (TaskResult)(encounteredErrors ? -2 : 0);\n}\n\nstatic void Free_AssetsWriterToMemory_Delete(void* buffer)\n{\n\tif (buffer)\n\t\tdelete[] (uint8_t*)buffer;\n}\n\nAssetImportRawTask::AssetImportRawTask(AppContext& appContext,\n\tstd::vector<AssetUtilDesc> _assets, std::vector<std::string> _importFilePaths,\n\tstd::string _taskName, bool stopOnError)\n\t: AssetImportTask(std::move(_assets), std::move(_importFilePaths), std::move(_taskName), stopOnError),\n\t  appContext(appContext)\n{}\n\nbool AssetImportRawTask::importAsset(AssetUtilDesc& asset, std::string path, std::optional<std::reference_wrapper<TaskProgressManager>> progressManager)\n{\n\tif (asset.asset.pFile == nullptr)\n\t\tthrow AssetUtilError("Unable to find the target .assets file.");\n\tstd::unique_ptr<IAssetsReader> pReader(Create_AssetsReaderFromFile(path.c_str(), true, RWOpenFlags_Immediately));// desc.asset.makeReader();\n\tif (pReader == nullptr)\n\t\tthrow AssetUtilError("Unable to read the file.");\n\tQWORD size = 0;\n\tif (!pReader->Seek(AssetsSeek_End, 0) || !pReader->Tell(size) || !pReader->Seek(AssetsSeek_Begin, 0) || size >= SIZE_MAX)\n\t\tthrow AssetUtilError("Unable to read the file.");\n\tstd::unique_ptr<uint8_t[]> memBuf(new uint8_t[(size_t)size]);\n\tif (pReader->Read(size, memBuf.get()) != size)\n\t\tthrow AssetUtilError("Unable to read the file.");\n\tstd::shared_ptr<AssetsEntryReplacer> pReplacer(MakeAssetModifierFromMemory(0, asset.asset.pathID,\n\t\tasset.asset.getClassID(), asset.asset.getMonoScriptID(),\n\t\tmemBuf.release(), (size_t)size, Free_AssetsWriterToMemory_Delete));\n\tif (pReplacer == nullptr)\n\t\tthrow AssetUtilError("Unexpected runtime error.");\n\tasset.asset.pFile->addReplacer(pReplacer, appContext);\n\treturn true;\n}\n\nAssetImportDumpTask::AssetImportDumpTask(AppContext& appContext,\n\tstd::vector<AssetUtilDesc> _assets, std::vector<std::string> _importFilePaths,\n\tstd::string _taskName, bool stopOnError)\n\t: AssetImportTask(std::move(_assets), std::move(_importFilePaths), std::move(_taskName), stopOnError),\n\tappContext(appContext)\n{}\n\nbool AssetImportDumpTask::importAsset(AssetUtilDesc& asset, std::string path, std::optional<std::reference_wrapper<TaskProgressManager>> progressManager)\n{\n\tif (asset.asset.pFile == nullptr)\n\t\tthrow AssetUtilError("Unable to find the target .assets file.");\n\tstd::unique_ptr<IAssetsReader> pReader(Create_AssetsReaderFromFile(path.c_str(), true, RWOpenFlags_Immediately));// desc.asset.makeReader();\n\tif (pReader == nullptr)\n\t\tthrow AssetUtilError("Unable to read the file.");\n\tQWORD size = 0;\n\tif (!pReader->Seek(AssetsSeek_End, 0) || !pReader->Tell(size) || !pReader->Seek(AssetsSeek_Begin, 0))\n\t\tthrow AssetUtilError("Unable to read the file.");\n\tstd::unique_ptr<IAssetsWriterToMemory> pWriter(Create_AssetsWriterToMemory());\n\tparseDump(pReader.get(), pWriter.get());\n\n\tsize_t bufferLen = 0; void* buffer = NULL;\n\tpWriter->GetBuffer(buffer, bufferLen);\n\tpWriter->SetFreeBuffer(false);\n\n\tstd::shared_ptr<AssetsEntryReplacer> pReplacer(MakeAssetModifierFromMemory(0, asset.asset.pathID,\n\t\tasset.asset.getClassID(), asset.asset.getMonoScriptID(),\n\t\tbuffer, bufferLen, Free_AssetsWriterToMemory_DynBuf));\n\tif (pReplacer == nullptr)\n\t\tthrow AssetUtilError("Unexpected runtime error.");\n\n\tasset.asset.pFile->addReplacer(pReplacer, appContext);\n\treturn true;\n}\nvoid AssetImportDumpTask::parseDump(IAssetsReader* pDumpReader, IAssetsWriter* pWriter)\n{\n\tpDumpReader->Seek(AssetsSeek_Begin, 0);\n\tunsigned char curChar = 0;\n\twhile (pDumpReader->Read(1, &curChar) && ((curChar <= 0x20) || (curChar & 0x80))) {}\n\tpDumpReader->Seek(AssetsSeek_Begin, 0);\n\tif (curChar == \'{\')\n\t\tparseJSONDump(pDumpReader, pWriter);\n\telse\n\t\tparseTextDump(pDumpReader, pWriter);\n}\n\n//Parses an integer type (valueType: ValueType_Int*, ValueType_UInt*) in base-10 string representation (valueStr)\n// and writes it out.\n//valueStr need not end after the number representation.\n//\n//Returns false iff the represented value is out of range for the type (otherwise true).\nstatic bool parsePrimitiveInt(EnumValueTypes valueType, const char *valueStr, QWORD &filePos, IAssetsWriter* pWriter)\n{\n\tswitch (valueType)\n\t{\n\t\tcase ValueType_Int8:\n\t\t{\n\t\t\tint32_t int8Tmp = strtol((char*)valueStr, NULL, 10);\n\t\t\tif (int8Tmp < INT8_MIN || int8Tmp > INT8_MAX)\n\t\t\t\treturn false;\n\t\t\tpWriter->Write(filePos, 1, &int8Tmp); filePos += 1;\n\t\t}\n\t\tbreak;\n\t\tcase ValueType_Int16:\n\t\t{\n\t\t\tint32_t int16Tmp = strtol((char*)valueStr, NULL, 10);\n\t\t\tif (int16Tmp < INT16_MIN || int16Tmp > INT16_MAX)\n\t\t\t\treturn false;\n\t\t\tpWriter->Write(filePos, 2, &int16Tmp); filePos += 2;\n\t\t}\n\t\tbreak;\n\t\tcase ValueType_Int32:\n\t\t{\n\t\t\terrno = 0;\n\t\t\tstatic_assert(sizeof(long) == sizeof(int32_t), "Unsupported long size.");\n\t\t\tint32_t int32Tmp = strtol((char*)valueStr, NULL, 10);\n\t\t\tif ((int32Tmp == LONG_MIN || int32Tmp == LONG_MAX) && errno == ERANGE)\n\t\t\t\treturn false;\n\t\t\tpWriter->Write(filePos, 4, &int32Tmp); filePos += 4;\n\t\t}\n\t\tbreak;\n\t\tcase ValueType_Int64:\n\t\t{\n\t\t\tstatic_assert(sizeof(long long) == sizeof(int64_t), "Unsupported long long size.");\n\t\t\terrno = 0;\n\t\t\tint64_t int64Tmp = strtoll((char*)valueStr, NULL, 10);\n\t\t\tif ((int64Tmp == LLONG_MIN || int64Tmp == LLONG_MAX) && errno == ERANGE)\n\t\t\t\treturn false;\n\t\t\tpWriter->Write(filePos, 8, &int64Tmp); filePos += 8;\n\t\t}\n\t\tbreak;\n\t\tcase ValueType_UInt8:\n\t\t{\n\t\t\tuint32_t uint8Tmp = strtoul((char*)valueStr, NULL, 10);\n\t\t\tif (uint8Tmp > UINT8_MAX)\n\t\t\t\treturn false;\n\t\t\tpWriter->Write(filePos, 1, &uint8Tmp); filePos += 1;\n\t\t}\n\t\tbreak;\n\t\tcase ValueType_UInt16:\n\t\t{\n\t\t\tuint32_t uint16Tmp = strtoul((char*)valueStr, NULL, 10);\n\t\t\tif (uint16Tmp > UINT16_MAX)\n\t\t\t\treturn false;\n\t\t\tpWriter->Write(filePos, 2, &uint16Tmp); filePos += 2;\n\t\t}\n\t\tbreak;\n\t\tcase ValueType_UInt32:\n\t\t{\n\t\t\tstatic_assert(sizeof(unsigned long) == sizeof(uint32_t), "Unsupported unsigned long size.");\n\t\t\terrno = 0;\n\t\t\tuint32_t uint32Tmp = strtoul((char*)valueStr, NULL, 10);\n\t\t\tif (uint32Tmp == ULONG_MAX && errno == ERANGE)\n\t\t\t\treturn false;\n\t\t\tpWriter->Write(filePos, 4, &uint32Tmp); filePos += 4;\n\t\t}\n\t\tbreak;\n\t\tcase ValueType_UInt64:\n\t\t{\n\t\t\tstatic_assert(sizeof(unsigned long long) == sizeof(uint64_t), "Unsupported unsigned long long size.");\n\t\t\terrno = 0;\n\t\t\tuint64_t uint64Tmp = strtoull((char*)valueStr, NULL, 10);\n\t\t\tif (uint64Tmp == ULLONG_MAX && errno == ERANGE)\n\t\t\t\treturn false;\n\t\t\tpWriter->Write(filePos, 8, &uint64Tmp); filePos += 8;\n\t\t}\n\t\tbreak;\n\t}\n\treturn true;\n}\n\nvoid AssetImportDumpTask::parseTextDump(IAssetsReader* pDumpReader, IAssetsWriter* pWriter)\n{\n\tstruct _TypeInfo\n\t{\n\t\tbool align;\n\t\tshort depth;\n\t};\n\tstd::vector<_TypeInfo> previousTypes;\n\tstd::vector<char8_t> lineBuffer;\n\tauto readLine = [&lineBuffer, pDumpReader]()\n\t{\n\t\tsize_t lineLen = -1; size_t lineBufferPos = 0; size_t readBytes = 0;\n\t\tdo {\n\t\t\tlineBuffer.resize(lineBufferPos + 256);\n\t\t\treadBytes = pDumpReader->Read(256, &lineBuffer[lineBufferPos]);\n\t\t\tif (readBytes == 0)\n\t\t\t\tbreak;\n\t\t\tlineBuffer.resize(lineBufferPos + readBytes);\n\t\t\tfor (size_t i = 0; i < readBytes; i++)\n\t\t\t{\n\t\t\t\tif (lineBuffer[lineBufferPos + i] == \'\\n\')\n\t\t\t\t{\n\t\t\t\t\tlineLen = lineBufferPos + i;\n\t\t\t\t\t//fseek(pDumpFile, (long)(i+1+((nextCh==\'\\n\')?1:0))-((long)readBytes), SEEK_CUR);\n\t\t\t\t\tpDumpReader->Seek(AssetsSeek_Cur, (int64_t)((i + 1) - readBytes));\n\t\t\t\t\tlineBuffer.resize(lineBufferPos + i);\n\t\t\t\t\treadBytes = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tlineBufferPos += readBytes;\n\t\t} while (lineLen == -1);\n\t\tif (!lineBuffer.empty() && lineBuffer.back() == \'\\r\')\n\t\t\tlineBuffer.pop_back();\n\t\tlineBuffer.push_back(0);\n\t\treturn (lineLen != -1);\n\t};\n\tQWORD filePos = 0;\n\t//Checks the depths of the previous lines.\n\t//If the new line exits at least one depth level,\n\t// the alignment of these depth levels is looked up and applied.\n\tauto checkPrevDepthsAndAlign = [&previousTypes, &filePos, pWriter](short newDepth) {\n\t\tshort previousDepth;\n\t\tif (previousTypes.size() > 0 && ((previousDepth = previousTypes.back().depth) > newDepth))\n\t\t{\n\t\t\t//The new line exits at least one depth level compared to its predecessor.\n\t\t\t//As the predecessor must be a value type (since it apparently does not have any children),\n\t\t\t// we need to further check its predecessors to find out if alignment needs to be applied.\n\t\t\t// (Value types have their alignment applied immediately).\n\t\t\tfor (size_t _i = previousTypes.size() - 2 + 1; _i > 0; _i--)\n\t\t\t{\n\t\t\t\tsize_t i = _i - 1;\n\t\t\t\tif (previousTypes[i].depth < newDepth)\n\t\t\t\t\tbreak; //This line precedes opening the depth level for the new line.\n\t\t\t\tif (previousTypes[i].depth < previousDepth)\n\t\t\t\t{\n\t\t\t\t\t//The depth level of this line\'s children is closed.\n\t\t\t\t\tif (previousTypes[i].align)\n\t\t\t\t\t{\n\t\t\t\t\t\tuint32_t dwNull = 0; int paddingLen = 3 - ((filePos - 1) & 3);\n\t\t\t\t\t\tpWriter->Write(filePos, paddingLen, &dwNull); filePos += paddingLen;\n\t\t\t\t\t\t//No need to check further, as we are aligned to the 4 byte boundary.\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t\tpreviousDepth = previousTypes[i].depth;\n\t\t\t\t\t//The new line either closes this line\'s depth level, too,\n\t\t\t\t\t// or is a direct neighbour to this line.\n\t\t\t\t}\n\t\t\t\tif (previousTypes[i].depth == newDepth)\n\t\t\t\t\tbreak; //Found a preceding neighbour, so the lookup can stop now.\n\t\t\t}\n\t\t}\n\t};\n\tsize_t numLine = 0;\n\tauto getLineMessage = [&numLine]() {\n\t\treturn std::string("Line ") + std::to_string(numLine) + ": ";\n\t};\n\twhile (true)\n\t{\n\t\tlineBuffer.clear();\n\t\tif (!readLine())\n\t\t\tbreak;\n\t\t++numLine;\n\t\tassert(lineBuffer.size() > 0 && lineBuffer.back() == 0);\n\t\tsize_t lineLen = lineBuffer.size() - 1;\n\t\t_TypeInfo ti; ti.depth = -1;\n\t\tfor (size_t i = 0; i < lineBuffer.size() - 1; i++)\n\t\t{\n\t\t\tif (lineBuffer[i] != \' \')\n\t\t\t{\n\t\t\t\tti.depth = (i > SHRT_MAX) ? -1 : (short)i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (ti.depth == -1)\n\t\t\tcontinue;\n\t\tif (lineBuffer[ti.depth] != \'0\' && lineBuffer[ti.depth] != \'1\') //no alignment info (either invalid file or array index item)\n\t\t\tcontinue; //as it neither has a value nor specifies alignment, we can ignore this\n\t\tif (ti.depth + 2 >= lineBuffer.size())\n\t\t\tcontinue;\n\t\tti.align = lineBuffer[ti.depth] == \'1\';\n\t\tchar8_t* fieldType = &lineBuffer[ti.depth + 2];\n\t\tchar8_t* fieldName = nullptr; size_t fieldNamePos = 0;\n\t\tsize_t _tmpTypeBegin = ti.depth + 2;\n\t\t//"unsigned int" is the only built-in type with a space in its name.\n\t\tif (!_strnicmp((char*)fieldType, "unsigned ", 9))\n\t\t{\n\t\t\t_tmpTypeBegin = ti.depth + 2 + 9;\n\t\t}\n\t\tfor (size_t lineBufferPos = _tmpTypeBegin; lineBufferPos < lineLen; lineBufferPos++)\n\t\t{\n\t\t\tif (lineBuffer[lineBufferPos] == \' \')\n\t\t\t{\n\t\t\t\tfieldName = &lineBuffer[lineBufferPos + 1];\n\t\t\t\tfieldNamePos = lineBufferPos + 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tcheckPrevDepthsAndAlign(ti.depth);\n\t\tpreviousTypes.push_back(ti);\n\n\t\tif (fieldName == nullptr)\n\t\t\tcontinue;\n\n\t\tsize_t valueBeginPos = 0;\n\t\tfor (size_t lineBufferPos = fieldNamePos; lineBufferPos < lineLen; lineBufferPos++)\n\t\t{\n\t\t\tif (lineBuffer[lineBufferPos] == \'=\')\n\t\t\t{\n\t\t\t\tbool hasAdditionalSpace = false;\n\t\t\t\tif ((lineBufferPos + 1) < lineLen)\n\t\t\t\t{\n\t\t\t\t\tif (lineBuffer[lineBufferPos + 1] == \' \')\n\t\t\t\t\t\thasAdditionalSpace = true;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tbreak;\n\t\t\t\tvalueBeginPos = lineBufferPos + (hasAdditionalSpace ? 2 : 1);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (valueBeginPos != 0)\n\t\t{\n\t\t\tsize_t valueEndPos = valueBeginPos;\n\t\t\tfor (size_t _i = lineLen; _i > valueBeginPos; --_i)\n\t\t\t{\n\t\t\t\tsize_t i = _i - 1;\n\t\t\t\tif (lineBuffer[i] > 0x20)\n\t\t\t\t{\n\t\t\t\t\tvalueEndPos = i + 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tlineBuffer[fieldNamePos - 1] = 0; //so GetValueTypeByTypeName can find the type\n\t\t\tchar8_t* value = &lineBuffer[valueBeginPos];\n\t\t\tEnumValueTypes valueType = GetValueTypeByTypeName((char*)fieldType);\n\t\t\tswitch (valueType)\n\t\t\t{\n\t\t\tcase ValueType_Bool:\n\t\t\t{\n\t\t\t\tuint8_t boolTmp = !_strnicmp((char*)value, "true", 4) ? 1 : 0;\n\t\t\t\tpWriter->Write(filePos, 1, &boolTmp); filePos += 1;\n\t\t\t}\n\t\t\tbreak;\n\t\t\tcase ValueType_Int8:\n\t\t\tcase ValueType_Int16:\n\t\t\tcase ValueType_Int32:\n\t\t\tcase ValueType_Int64:\n\t\t\tcase ValueType_UInt8:\n\t\t\tcase ValueType_UInt16:\n\t\t\tcase ValueType_UInt32:\n\t\t\tcase ValueType_UInt64:\n\t\t\t{\n\t\t\t\tif (!parsePrimitiveInt(valueType, (char*)value, filePos, pWriter))\n\t\t\t\t\tthrow AssetUtilError(getLineMessage() + "Primitive value out of range.");\n\t\t\t}\n\t\t\tbreak;\n\t\t\tcase ValueType_Float:\n\t\t\t{\n\t\t\t\tfloat floatTmp;\n\t\t\t\tif (!parseFloatStr<float>(floatTmp, std::string(&lineBuffer[valueBeginPos], &lineBuffer[valueEndPos])))\n\t\t\t\t\tthrow AssetUtilError(std::string("Line ") + std::to_string(numLine) + ": Unable to parse value.");\n\t\t\t\tpWriter->Write(filePos, 4, &floatTmp); filePos += 4;\n\t\t\t}\n\t\t\tbreak;\n\t\t\tcase ValueType_Double:\n\t\t\t{\n\t\t\t\tdouble doubleTmp;\n\t\t\t\tif (!parseFloatStr<double>(doubleTmp, std::string(&lineBuffer[valueBeginPos], &lineBuffer[valueEndPos])))\n\t\t\t\t\tthrow AssetUtilError(std::string("Line ") + std::to_string(numLine) + ": Unable to parse value.");\n\t\t\t\tpWriter->Write(filePos, 8, &doubleTmp); filePos += 8;\n\t\t\t}\n\t\t\tbreak;\n\t\t\tcase ValueType_String:\n\t\t\t{\n\t\t\t\tif (((valueBeginPos + 1) > (size_t)lineLen) || (lineBuffer[valueBeginPos] != \'"\'))\n\t\t\t\t\tbreak;\n\t\t\t\tvalue = &value[1];\n\t\t\t\tfor (size_t lineBufferPos = (size_t)lineLen - 1; lineBufferPos > valueBeginPos; lineBufferPos--)\n\t\t\t\t{\n\t\t\t\t\tif (lineBuffer[lineBufferPos] == \'"\')\n\t\t\t\t\t{\n\t\t\t\t\t\tlineBuffer[lineBufferPos] = 0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tsize_t valueLen = strlen((char*)value);\n\t\t\t\tstd::vector<char8_t> valueBuffer(valueLen + 1);\n\t\t\t\tsize_t valueBufferIndex = 0;\n\t\t\t\tfor (size_t i = 0; i < valueLen; i++)\n\t\t\t\t{\n\t\t\t\t\tif (value[i] == \'\\\\\' && ((i + 1) < (valueLen)))\n\t\t\t\t\t{\n\t\t\t\t\t\tswitch (value[i + 1])\n\t\t\t\t\t\t{\n\t\t\t\t\t\tcase \'\\\\\':\n\t\t\t\t\t\t\tvalueBuffer[valueBufferIndex++] = \'\\\\\';\n\t\t\t\t\t\t\ti++;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase \'r\':\n\t\t\t\t\t\t\tvalueBuffer[valueBufferIndex++] = \'\\r\';\n\t\t\t\t\t\t\ti++;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase \'n\':\n\t\t\t\t\t\t\tvalueBuffer[valueBufferIndex++] = \'\\n\';\n\t\t\t\t\t\t\ti++;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tvalueBuffer[valueBufferIndex++] = value[i];\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tvalueBuffer[valueBufferIndex++] = value[i];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tpWriter->Write(filePos, 4, &valueBufferIndex); filePos += 4;\n\t\t\t\tpWriter->Write(filePos, valueBufferIndex, valueBuffer.data()); filePos += valueBufferIndex;\n\t\t\t}\n\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tvalueType = ValueType_None;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (valueType != ValueType_None)\n\t\t\t{\n\t\t\t\tif (ti.align)\n\t\t\t\t{\n\t\t\t\t\tuint32_t dwNull = 0; int paddingLen = 3 - ((filePos - 1) & 3);\n\t\t\t\t\tpWriter->Write(filePos, paddingLen, &dwNull); filePos += paddingLen;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcheckPrevDepthsAndAlign(0);\n}\n\n#define JSMN_PARENT_LINKS\n#define JSMN_STATIC\n#include <jsmn.h>\nvoid AssetImportDumpTask::parseJSONDump(IAssetsReader* pDumpReader, IAssetsWriter* pWriter)\n{\n\tQWORD filePos = 0;\n\tjsmn_parser parser;\n\tjsmn_init(&parser);\n\tpDumpReader->Seek(AssetsSeek_End, 0);\n\tQWORD jsonLen = 0;\n\tpDumpReader->Tell(jsonLen);\n\tpDumpReader->Seek(AssetsSeek_Begin, 0);\n\t//fseek(pDumpFile, 0, SEEK_END);\n\t//size_t jsonLen = (size_t)ftell(pDumpFile);\n\t//fseek(pDumpFile, 0, SEEK_SET);\n\tstd::vector<char> jsonBuffer(jsonLen + 1);\n\tjsonLen = pDumpReader->Read(jsonLen, jsonBuffer.data());\n\t//jsonLen = fread(jsonBuffer, 1, jsonLen, pDumpFile);\n\tif (jsonLen == 0)\n\t{\n\t\tthrow AssetUtilError("Unable to read the file.");\n\t\treturn;\n\t}\n\tjsonBuffer[jsonLen] = 0;\n\tstd::vector<jsmntok_t> tokens(16); size_t actualTokenCount = 0;\n\twhile (true)\n\t{\n\t\tint err = jsmn_parse(&parser, jsonBuffer.data(), (size_t)jsonLen, &tokens[0], (unsigned int)tokens.size());\n\t\tsize_t startIndex = actualTokenCount;\n\t\tif (err < 0)\n\t\t{\n\t\t\tswitch (err)\n\t\t\t{\n\t\t\tdefault:\n\t\t\tcase JSMN_ERROR_INVAL:\n\t\t\tcase JSMN_ERROR_PART:\n\t\t\t\tthrow AssetUtilError("The JSON file is invalid or cut off or bigger than 2 GiB.");\n\t\t\tcase JSMN_ERROR_NOMEM:\n\t\t\t\tactualTokenCount = (size_t)parser.toknext;\n\t\t\t\tif (tokens.size() > INT_MAX)\n\t\t\t\t\tthrow AssetUtilError("The JSON token count is out of range.");\n\t\t\t\ttokens.resize(std::min<size_t>(INT_MAX, tokens.size() * 2));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tactualTokenCount = (size_t)err;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (actualTokenCount > INT_MAX)\n\t\tthrow AssetUtilError("The JSON token count is out of range.");\n\tbool doubleConvertErr = false;\n\tfor (size_t i = 0; i < actualTokenCount; i++)\n\t{\n\t\tjsmntok_t& token = tokens[i];\n\t\t//Safety checks; Probably not required because jsmn shouldn\'t allow such cases.\n\t\tif ((token.start < 0) || (token.start > token.end) || ((unsigned long)token.end > jsonLen) || (token.parent != -1 && token.parent >= i))\n\t\t\tthrow AssetUtilError("Invalid JSON file.");\n\t\tswitch (token.type)\n\t\t{\n\t\tcase JSMN_ARRAY:\n\t\t{\n\t\t\tif (token.parent == -1 || tokens[token.parent].type != JSMN_STRING) //Has no name\n\t\t\t\tthrow AssetUtilError("UABE json dump not as expected; A JSON array is missing a name.");\n\t\t\tunsigned int count = (unsigned int)token.size;\n\t\t\tpWriter->Write(filePos, 4, &count); filePos += 4;\n\t\t}\n\t\tbreak;\n\t\tcase JSMN_STRING:\n\t\t{\n\t\t\tif (jsonBuffer[token.end] != \'"\')\n\t\t\t\tthrow AssetUtilError("Unable to parse a JSON string object.");\n\t\t\tif (/*(token.parent == -1 || tokens[token.parent].type != 5)\n\t\t\t\t&& */((int)actualTokenCount > (i + 1)) && tokens[i + 1].parent == i) //Is a token name.\n\t\t\t{\n\t\t\t\tif ((token.end - token.start) < 3\n\t\t\t\t\t|| (jsonBuffer[token.start] != \'0\' && jsonBuffer[token.start] != \'1\')\n\t\t\t\t\t|| jsonBuffer[token.start + 1] != \' \')\n\t\t\t\t{\n\t\t\t\t\tthrow AssetUtilError("UABE json dump not as expected; Field name format is unexpected.");\n\t\t\t\t}\n\t\t\t\tjsonBuffer[token.end] = 0;\n\t\t\t\t//token.type = (jsmntype_t)5; //Custom type for names.\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t//Is a string value.\n\t\t\tbool parsed = false;\n\t\t\t//Handle non-JSON primitives (depending on the type determined by the JSON field name).\n\t\t\tif (token.parent != -1 && tokens[token.parent].type == JSMN_STRING)\n\t\t\t{\n\t\t\t\tjsmntok_t& nameToken = tokens[token.parent];\n\t\t\t\tint size = nameToken.end - nameToken.start;\n\t\t\t\tint start = nameToken.start + 2;\n\t\t\t\tif (size > 11 && !strncmp(&jsonBuffer[start], "unsigned ", 9))\n\t\t\t\t\tstart += 9;\n\t\t\t\tfor (int i = start; i < nameToken.end; i++)\n\t\t\t\t{\n\t\t\t\t\tif (jsonBuffer[i] == \' \')\n\t\t\t\t\t{\n\t\t\t\t\t\tjsonBuffer[i] = 0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tEnumValueTypes valueType = GetValueTypeByTypeName(&jsonBuffer[nameToken.start + 2]);\n\t\t\t\tchar* value = &jsonBuffer[token.start];\n\t\t\t\tswitch (valueType)\n\t\t\t\t{\n\t\t\t\tcase ValueType_Int64:\n\t\t\t\tcase ValueType_UInt64:\n\t\t\t\t\tif (!parsePrimitiveInt(valueType, value, filePos, pWriter))\n\t\t\t\t\t\tthrow AssetUtilError("Primitive value out of range.");\n\t\t\t\t\tparsed = true;\n\t\t\t\t\tbreak;\n\t\t\t\tcase ValueType_Float:\n\t\t\t\t\t{\n\t\t\t\t\t\tfloat floatTmp;\n\t\t\t\t\t\tif (!parseFloatStr<float>(floatTmp, "\\"" + std::string(&jsonBuffer[token.start], &jsonBuffer[token.end]) + "\\""))\n\t\t\t\t\t\t\tthrow AssetUtilError("Unable to parse float value.");\n\t\t\t\t\t\tpWriter->Write(filePos, 4, &floatTmp); filePos += 4;\n\t\t\t\t\t}\n\t\t\t\t\tparsed = true;\n\t\t\t\t\tbreak;\n\t\t\t\tcase ValueType_Double:\n\t\t\t\t\t{\n\t\t\t\t\t\tdouble doubleTmp;\n\t\t\t\t\t\tif (!parseFloatStr<double>(doubleTmp, "\\"" + std::string(&jsonBuffer[token.start], &jsonBuffer[token.end]) + "\\""))\n\t\t\t\t\t\t\tthrow AssetUtilError("Unable to parse float value.");\n\t\t\t\t\t\tpWriter->Write(filePos, 8, &doubleTmp); filePos += 8;\n\t\t\t\t\t}\n\t\t\t\t\tparsed = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (parsed)\n\t\t\t\tbreak;\n\t\t\t// Handle escaped string values.\n\t\t\tQWORD outStartPos = filePos;\n\t\t\tunsigned int inCount = 0;\n\t\t\tunsigned int outCount = 0;\n\t\t\tpWriter->Write(filePos, 4, &outCount); filePos += 4;\n\t\t\tfor (int i = token.start; i < token.end; i++)\n\t\t\t{\n\t\t\t\tif (jsonBuffer[i] != \'\\\\\')\n\t\t\t\t\tcontinue;\n\t\t\t\t//Write the pending characters.\n\t\t\t\tpWriter->Write(filePos, i - (token.start + inCount), &jsonBuffer[token.start + inCount]);\n\t\t\t\tfilePos += i - (token.start + inCount);\n\t\t\t\tinCount = i - token.start;\n\t\t\t\t//inCount now points to the \'\\\\\' character.\n\t\t\t\tif ((i + 1) >= token.end)\n\t\t\t\t\tbreak;\n\t\t\t\ti++;\n\t\t\t\t//Parse the escape sequence.\n\t\t\t\tswitch (jsonBuffer[i])\n\t\t\t\t{\n\t\t\t\tcase \'"\':\n\t\t\t\tcase \'\\\\\':\n\t\t\t\tcase \'/\':\n\t\t\t\t\t//The character will be directly copied (next Write call).\n\t\t\t\t\t//Increment inCount beyond the \'\\\\\' character.\n\t\t\t\t\tinCount++;\n\t\t\t\t\tbreak;\n\t\t\t\tcase \'b\':\n\t\t\t\t\tpWriter->Write(filePos, 1, "\\b");\n\t\t\t\t\tfilePos++; inCount += 2;\n\t\t\t\t\tbreak;\n\t\t\t\tcase \'f\':\n\t\t\t\t\tpWriter->Write(filePos, 1, "\\f");\n\t\t\t\t\tfilePos++; inCount += 2;\n\t\t\t\t\tbreak;\n\t\t\t\tcase \'n\':\n\t\t\t\t\tpWriter->Write(filePos, 1, "\\n");\n\t\t\t\t\tfilePos++; inCount += 2;\n\t\t\t\t\tbreak;\n\t\t\t\tcase \'r\':\n\t\t\t\t\tpWriter->Write(filePos, 1, "\\r");\n\t\t\t\t\tfilePos++; inCount += 2;\n\t\t\t\t\tbreak;\n\t\t\t\tcase \'t\':\n\t\t\t\t\tpWriter->Write(filePos, 1, "\\t");\n\t\t\t\t\tfilePos++; inCount += 2;\n\t\t\t\t\tbreak;\n\t\t\t\tcase \'u\':\n\t\t\t\t\t//Should also suppate UTF-16 surrogate pairs.\n\t\t\t\t\tif ((i + 5) >= token.end || (i + 5) < 0)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t{\n\t\t\t\t\t\twchar_t fullCharacter[2] = { 0,0 };\n\t\t\t\t\t\tsize_t endIdx = SIZE_MAX;\n\t\t\t\t\t\tbool valid = false;\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t//Parse primary "\\\\u" sequence.\n\t\t\t\t\t\t\twchar_t firstChar = (wchar_t)\n\t\t\t\t\t\t\t\tstd::stoul(std::string(&jsonBuffer[i + 1], &jsonBuffer[i + 1 + 4]), &endIdx, 16);\n\t\t\t\t\t\t\tvalid = (endIdx == 4);\n\t\t\t\t\t\t\ti += 4; inCount += 6;\n\t\t\t\t\t\t\tif (valid)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tfullCharacter[0] = firstChar;\n\t\t\t\t\t\t\t\tif (firstChar >= 0xD800 && firstChar <= 0xDFFF)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t//Look for and parse secondary "\\\\u" sequence.\n\t\t\t\t\t\t\t\t\tif ((i + 6) < token.end && (i + 6) > 0 && jsonBuffer[i + 1] == \'\\\\\' && jsonBuffer[i + 2] == \'u\')\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\twchar_t secondChar = (wchar_t)\n\t\t\t\t\t\t\t\t\t\t\tstd::stoul(std::string(&jsonBuffer[i + 3], &jsonBuffer[i + 3 + 4]), &endIdx, 16);\n\t\t\t\t\t\t\t\t\t\tvalid = (endIdx == 4);\n\t\t\t\t\t\t\t\t\t\ti += 6; inCount += 6;\n\t\t\t\t\t\t\t\t\t\tfullCharacter[1] = secondChar;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\t\tvalid = false;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (std::invalid_argument) { valid = false;  }\n\t\t\t\t\t\tcatch (std::out_of_range) { valid = false; }\n\t\t\t\t\t\tif (!valid)\n\t\t\t\t\t\t\tthrow AssetUtilError("Unable to parse a JSON \\\\u sequence (invalid characters?)");\n\t\t\t\t\t\tstd::string utf8Str = std::wstring_convert<std::codecvt_utf8_utf16<wchar_t>>("").\n\t\t\t\t\t\t\tto_bytes(&fullCharacter[0], &fullCharacter[fullCharacter[1] ? 2 : 1]);\n\t\t\t\t\t\tif (utf8Str.empty())\n\t\t\t\t\t\t\tthrow AssetUtilError("Unable to convert a JSON \\\\u sequence (invalid UTF-16?)");\n\t\t\t\t\t\tpWriter->Write(filePos, utf8Str.size() * sizeof(char), utf8Str.data());\n\t\t\t\t\t\tfilePos += utf8Str.size() * sizeof(char);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tpWriter->Write(filePos, token.end - (token.start + inCount), &jsonBuffer[token.start + inCount]);\n\t\t\tfilePos += token.end - (token.start + inCount);\n\t\t\toutCount = (unsigned int)(filePos - outStartPos - 4);\n\t\t\tpWriter->Write(outStartPos, 4, &outCount);\n\t\t}\n\t\tbreak;\n\t\tcase JSMN_PRIMITIVE:\n\t\t{\n\t\t\tjsonBuffer[token.end] = 0;\n\t\t\tEnumValueTypes valueType = ValueType_None;\n\t\t\tif (token.parent != -1)\n\t\t\t{\n\t\t\t\tif (tokens[token.parent].type == JSMN_STRING) //parent is the name\n\t\t\t\t{\n\t\t\t\t\tint size = tokens[token.parent].end - tokens[token.parent].start;\n\t\t\t\t\tint start = tokens[token.parent].start + 2;\n\t\t\t\t\tif (size > 11 && !strncmp(&jsonBuffer[start], "unsigned ", 9))\n\t\t\t\t\t\tstart += 9;\n\t\t\t\t\tfor (int i = start; i < tokens[token.parent].end; i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (jsonBuffer[i] == \' \')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tjsonBuffer[i] = 0;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tvalueType = GetValueTypeByTypeName(&jsonBuffer[tokens[token.parent].start + 2]);\n\t\t\t\t}\n\t\t\t\telse if (tokens[token.parent].type == JSMN_ARRAY) //byte array\n\t\t\t\t{\n\t\t\t\t\tvalueType = ValueType_UInt8;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (valueType == ValueType_None)\n\t\t\t\tthrow AssetUtilError("Encountered an unknown primitive value type.");\n\t\t\tchar* value = &jsonBuffer[token.start];\n\t\t\tswitch (valueType)\n\t\t\t{\n\t\t\tcase ValueType_Bool:\n\t\t\t\t{\n\t\t\t\t\tuint8_t boolTmp = (!_strnicmp(value, "1", 1) || !_strnicmp(value, "true", 4)) ? 1 : 0;\n\t\t\t\t\tpWriter->Write(filePos, 1, &boolTmp); filePos += 1;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase ValueType_Int8:\n\t\t\tcase ValueType_Int16:\n\t\t\tcase ValueType_Int32:\n\t\t\tcase ValueType_Int64:\n\t\t\tcase ValueType_UInt8:\n\t\t\tcase ValueType_UInt16:\n\t\t\tcase ValueType_UInt32:\n\t\t\tcase ValueType_UInt64:\n\t\t\t{\n\t\t\t\tif (!parsePrimitiveInt(valueType, value, filePos, pWriter))\n\t\t\t\t\tthrow AssetUtilError("Primitive value out of range.");\n\t\t\t}\n\t\t\tbreak;\n\t\t\tcase ValueType_Float:\n\t\t\t\t{\n\t\t\t\t\tfloat floatTmp;\n\t\t\t\t\tif (!parseFloatStr<float>(floatTmp, std::string(&jsonBuffer[token.start], &jsonBuffer[token.end])))\n\t\t\t\t\t\tthrow AssetUtilError("Unable to parse float value.");\n\t\t\t\t\tpWriter->Write(filePos, 4, &floatTmp); filePos += 4;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase ValueType_Double:\n\t\t\t\t{\n\t\t\t\t\tdouble doubleTmp;\n\t\t\t\t\tif (!parseFloatStr<double>(doubleTmp, std::string(&jsonBuffer[token.start], &jsonBuffer[token.end])))\n\t\t\t\t\t\tthrow AssetUtilError("Unable to parse float value.");\n\t\t\t\t\tpWriter->Write(filePos, 8, &doubleTmp); filePos += 8;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t}\n\t\t//Alignment\n\t\t{\n\t\t\t//Because a value token\'s name is its parent token, this works when the next token is a direct neighbour or a parent\'s neighbour.\n\t\t\tint target = -1;\n\t\t\tif ((i + 1) < actualTokenCount)\n\t\t\t{\n\t\t\t\tif (tokens[i + 1].parent == i)\n\t\t\t\t\t//Don\'t need to check because : \n\t\t\t\t\t//1) i is a JSMN_OBJECT, i+1 a child,\n\t\t\t\t\t//or 2) i is a JSMN_STRING and the name of i+1, so i isn\'t represented in the binary and doesn\'t need alignment.\n\t\t\t\t\tcontinue;\n\t\t\t\ttarget = tokens[i + 1].parent;\n\t\t\t}\n\t\t\tjsmntok_t& curParentToken = token;\n\t\t\twhile ((curParentToken.parent != -1) && (curParentToken.parent > target))\n\t\t\t{\n\t\t\t\tcurParentToken = tokens[curParentToken.parent];\n\t\t\t\tif (curParentToken.type == JSMN_STRING) //The name of i or one of i\'s parents.\n\t\t\t\t{\n\t\t\t\t\tif (jsonBuffer[curParentToken.start] == \'1\') //Alignment indicator is on.\n\t\t\t\t\t{\n\t\t\t\t\t\tQWORD alignCount = (4 - (filePos & 3)) & 3;\n\t\t\t\t\t\tif (alignCount > 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tuint32_t nullDw = 0;\n\t\t\t\t\t\t\tpWriter->Write(filePos, alignCount, &nullDw); filePos += alignCount;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak; //Don\'t need to continue as another alignment is a redundant one.\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n'