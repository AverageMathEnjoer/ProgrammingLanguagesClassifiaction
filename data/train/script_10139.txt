b'{-# LANGUAGE DuplicateRecordFields #-}\n{-# LANGUAGE FlexibleContexts #-}\n{-# LANGUAGE InstanceSigs #-}\n{-# LANGUAGE OverloadedStrings #-}\n{-# LANGUAGE QuasiQuotes #-}\n{-# LANGUAGE RecordWildCards #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n{-# LANGUAGE TypeApplications #-}\n{-# LANGUAGE TypeOperators #-}\n\nmodule Idp where\n\nimport Control.Monad.IO.Class\nimport Control.Monad.Trans.Except\nimport Data.Aeson qualified as Aeson\nimport Data.Aeson.Key qualified as Aeson\nimport Data.Aeson.KeyMap qualified as Aeson\nimport Data.Bifunctor\nimport Data.ByteString qualified as BS\nimport Data.ByteString.Contrib\nimport Data.Default\nimport Data.Map.Strict qualified as Map\nimport Data.Maybe\nimport Data.Set qualified as Set\nimport Data.Text.Lazy (Text)\nimport Data.Text.Lazy qualified as TL\nimport Data.Text.Lazy.Encoding qualified as TL\nimport Env qualified\nimport Jose.Jwt\nimport Lens.Micro\nimport Network.OAuth.OAuth2\nimport Network.OAuth2.Experiment\nimport Network.OAuth2.Provider.Auth0 qualified as IAuth0\nimport Network.OAuth2.Provider.AzureAD qualified as IAzureAD\nimport Network.OAuth2.Provider.Dropbox qualified as IDropbox\nimport Network.OAuth2.Provider.Facebook qualified as IFacebook\nimport Network.OAuth2.Provider.Fitbit qualified as IFitbit\nimport Network.OAuth2.Provider.Github qualified as IGithub\nimport Network.OAuth2.Provider.Google qualified as IGoogle\nimport Network.OAuth2.Provider.Linkedin qualified as ILinkedin\nimport Network.OAuth2.Provider.Okta qualified as IOkta\nimport Network.OAuth2.Provider.Slack qualified as ISlack\nimport Network.OAuth2.Provider.StackExchange qualified as IStackExchange\nimport Network.OAuth2.Provider.Twitter qualified as ITwitter\nimport Network.OAuth2.Provider.Weibo qualified as IWeibo\nimport Network.OAuth2.Provider.ZOHO qualified as IZOHO\nimport Session\nimport System.Directory\nimport Types\nimport URI.ByteString\nimport URI.ByteString.QQ (uri)\nimport Prelude hiding (id)\n\ndefaultOAuth2RedirectUri :: URI\ndefaultOAuth2RedirectUri = [uri|http://localhost:9988/oauth2/callback|]\n\ncreateAuthorizationApps :: MonadIO m => (Idp IAuth0.Auth0, Idp IOkta.Okta) -> ExceptT Text m [DemoAuthorizationApp]\ncreateAuthorizationApps (myAuth0Idp, myOktaIdp) = do\n  configParams <- readEnvFile\n  let initIdpAppConfig :: IdpApplication \'AuthorizationCode i -> IdpApplication \'AuthorizationCode i\n      initIdpAppConfig idpAppConfig@AuthorizationCodeIdpApplication {..} =\n        case Aeson.lookup (Aeson.fromString $ TL.unpack $ TL.toLower $ getIdpAppName idpAppConfig) configParams of\n          Nothing -> idpAppConfig\n          Just config ->\n            idpAppConfig\n              { idpAppClientId = ClientId $ Env.clientId config\n              , idpAppClientSecret = ClientSecret $ Env.clientSecret config\n              , idpAppRedirectUri = defaultOAuth2RedirectUri\n              , idpAppScope = Set.unions [idpAppScope, Set.map Scope (Set.fromList (fromMaybe [] (Env.scopes config)))]\n              , idpAppAuthorizeState = AuthorizeState (idpAppName <> ".hoauth2-demo-app-123")\n              }\n  pure\n    [ DemoAuthorizationApp (initIdpAppConfig IAzureAD.defaultAzureADApp)\n    , DemoAuthorizationApp (initIdpAppConfig (IAuth0.defaultAuth0App myAuth0Idp))\n    , DemoAuthorizationApp (initIdpAppConfig IFacebook.defaultFacebookApp)\n    , DemoAuthorizationApp (initIdpAppConfig IFitbit.defaultFitbitApp)\n    , DemoAuthorizationApp (initIdpAppConfig IGithub.defaultGithubApp)\n    , DemoAuthorizationApp (initIdpAppConfig IDropbox.defaultDropboxApp)\n    , DemoAuthorizationApp (initIdpAppConfig IGoogle.defaultGoogleApp)\n    , DemoAuthorizationApp (initIdpAppConfig ILinkedin.defaultLinkedinApp)\n    , DemoAuthorizationApp (initIdpAppConfig (IOkta.defaultOktaApp myOktaIdp))\n    , DemoAuthorizationApp (initIdpAppConfig ITwitter.defaultTwitterApp)\n    , DemoAuthorizationApp (initIdpAppConfig ISlack.defaultSlackApp)\n    , DemoAuthorizationApp (initIdpAppConfig IWeibo.defaultWeiboApp)\n    , DemoAuthorizationApp (initIdpAppConfig IZOHO.defaultZohoApp)\n    , DemoAuthorizationApp (initIdpAppConfig IStackExchange.defaultStackExchangeApp)\n    ]\n\ngoogleServiceAccountApp ::\n  ExceptT\n    Text\n    IO\n    (IdpApplication \'JwtBearer IGoogle.Google)\ngoogleServiceAccountApp = do\n  IGoogle.GoogleServiceAccountKey {..} <- withExceptT TL.pack (ExceptT $ Aeson.eitherDecodeFileStrict ".google-sa.json")\n  pkey <- withExceptT TL.pack (ExceptT $ IGoogle.readPemRsaKey privateKey)\n  jwt <-\n    withExceptT\n      TL.pack\n      ( ExceptT $\n          IGoogle.mkJwt\n            pkey\n            clientEmail\n            Nothing\n            ( Set.fromList\n                [ "https://www.googleapis.com/auth/userinfo.email"\n                , "https://www.googleapis.com/auth/userinfo.profile"\n                ]\n            )\n            IGoogle.defaultGoogleIdp\n      )\n  pure $ IGoogle.defaultServiceAccountApp jwt\n\noktaPasswordGrantApp :: Idp IOkta.Okta -> IdpApplication \'ResourceOwnerPassword IOkta.Okta\noktaPasswordGrantApp i =\n  ResourceOwnerPasswordIDPApplication\n    { idpAppClientId = ""\n    , idpAppClientSecret = ""\n    , idpAppName = "okta-demo-password-grant-app"\n    , idpAppScope = Set.fromList ["openid", "profile"]\n    , idpAppUserName = ""\n    , idpAppPassword = ""\n    , idpAppTokenRequestExtraParams = Map.empty\n    , idp = i\n    }\n\n-- Base on the document, it works well with custom Athourization Server\n-- https://developer.okta.com/docs/guides/implement-grant-type/clientcreds/main/#client-credentials-flow\n--\n-- With Org AS, got this error\n-- Client Credentials requests to the Org Authorization Server must use the private_key_jwt token_endpoint_auth_method\n--\noktaClientCredentialsGrantApp :: Idp IOkta.Okta -> IO (IdpApplication \'ClientCredentials IOkta.Okta)\noktaClientCredentialsGrantApp i = do\n  let clientId = "0oa9mbklxn2Ac0oJ24x7"\n  keyJsonStr <- BS.readFile ".okta-key.json"\n  case Aeson.eitherDecodeStrict keyJsonStr of\n    Right jwk -> do\n      ejwt <- IOkta.mkOktaClientCredentialAppJwt jwk clientId i\n      case ejwt of\n        Right jwt ->\n          pure\n            ClientCredentialsIDPApplication\n              { idpAppClientId = clientId\n              , idpAppClientSecret = ClientSecret (TL.decodeUtf8 $ bsFromStrict $ unJwt jwt)\n              , idpAppTokenRequestAuthenticationMethod = ClientAssertionJwt\n              , idpAppName = "okta-demo-cc-grant-jwt-app"\n              , -- , idpAppScope = Set.fromList ["hw-test"]\n                idpAppScope = Set.fromList ["okta.users.read"]\n              , idpAppTokenRequestExtraParams = Map.empty\n              , idp = i\n              }\n        Left e -> Prelude.error e\n    Left e -> Prelude.error e\n\n-- | https://auth0.com/docs/api/authentication#resource-owner-password\nauth0PasswordGrantApp :: Idp IAuth0.Auth0 -> IdpApplication \'ResourceOwnerPassword IAuth0.Auth0\nauth0PasswordGrantApp i =\n  ResourceOwnerPasswordIDPApplication\n    { idpAppClientId = ""\n    , idpAppClientSecret = ""\n    , idpAppName = "auth0-demo-password-grant-app"\n    , idpAppScope = Set.fromList ["openid", "profile", "email"]\n    , idpAppUserName = "test"\n    , idpAppPassword = ""\n    , idpAppTokenRequestExtraParams = Map.empty\n    , idp = i\n    }\n\n-- | https://auth0.com/docs/api/authentication#client-credentials-flow\nauth0ClientCredentialsGrantApp :: Idp IAuth0.Auth0 -> IdpApplication \'ClientCredentials IAuth0.Auth0\nauth0ClientCredentialsGrantApp i =\n  ClientCredentialsIDPApplication\n    { idpAppClientId = ""\n    , idpAppClientSecret = ""\n    , idpAppTokenRequestAuthenticationMethod = ClientSecretPost\n    , idpAppName = "auth0-demo-cc-grant-app"\n    , idpAppScope = Set.fromList ["read:users"]\n    , idpAppTokenRequestExtraParams = Map.fromList [("audience ", "https://freizl.auth0.com/api/v2/")]\n    , idp = i\n    }\n\nisSupportPkce :: forall a i. (\'AuthorizationCode ~ a) => IdpApplication a i -> Bool\nisSupportPkce AuthorizationCodeIdpApplication {..} =\n  let hostStr = idpAuthorizeEndpoint idp ^. (authorityL . _Just . authorityHostL . hostBSL)\n   in any\n        (`BS.isInfixOf` hostStr)\n        [ "auth0.com"\n        , "okta.com"\n        , "google.com"\n        , "twitter.com"\n        ]\n\nenvFilePath :: String\nenvFilePath = ".env.json"\n\nreadEnvFile :: MonadIO m => ExceptT Text m Env.EnvConfig\nreadEnvFile = liftIO $ do\n  pwd <- getCurrentDirectory\n  envFileE <- doesFileExist (pwd <> "/" <> envFilePath)\n  if envFileE\n    then do\n      putStrLn "Found .env.json"\n      fileContent <- BS.readFile envFilePath\n      case Aeson.eitherDecodeStrict fileContent of\n        Left err -> print err >> return Aeson.empty\n        Right ec -> return ec\n    else return Aeson.empty\n\ninitIdps :: MonadIO m => CacheStore -> (Idp IAuth0.Auth0, Idp IOkta.Okta) -> ExceptT Text m ()\ninitIdps c is = do\n  idps <- createAuthorizationApps is\n  mapM mkDemoAppEnv idps >>= mapM_ (upsertDemoAppEnv c)\n\nmkDemoAppEnv :: MonadIO m => DemoAuthorizationApp -> ExceptT Text m DemoAppEnv\nmkDemoAppEnv ia@(DemoAuthorizationApp idpAppConfig) = do\n  re <-\n    if isSupportPkce idpAppConfig\n      then fmap (second Just) (mkPkceAuthorizeRequest idpAppConfig)\n      else pure (mkAuthorizeRequest idpAppConfig, Nothing)\n  pure $ DemoAppEnv ia (def {authorizeAbsUri = fst re, authorizePkceCodeVerifier = snd re})\n'