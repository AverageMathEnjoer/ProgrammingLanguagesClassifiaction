b'/*\n    SPDX-FileCopyrightText: 2015-2017 Milian Wolff <mail@milianw.de>\n\n    SPDX-License-Identifier: LGPL-2.1-or-later\n*/\n\n#include "chartmodel.h"\n\n#include <KChartGlobal>\n#include <KChartLineAttributes>\n#include <KLocalizedString>\n\n#include <QBrush>\n#include <QDebug>\n#include <QPen>\n\n#include "util.h"\n\n#include <algorithm>\n\nnamespace {\nQColor colorForColumn(int column, int columnCount)\n{\n    // The total cost graph (column 0) is always red.\n    if (column == 0) {\n        return Qt::red;\n    } else {\n        return QColor::fromHsv((double(column + 1) / columnCount) * 255, 255, 255);\n    }\n}\n}\n\nChartModel::ChartModel(Type type, QObject* parent)\n    : QAbstractTableModel(parent)\n    , m_type(type)\n    , m_maxDatasetCount(11)\n{\n    qRegisterMetaType<ChartData>();\n}\n\nChartModel::~ChartModel() = default;\n\nChartModel::Type ChartModel::type() const\n{\n    return m_type;\n}\n\nQString ChartModel::typeString() const\n{\n    switch (m_type) {\n    case Allocations:\n        return i18n("Memory Allocations");\n    case Consumed:\n        return i18n("Memory Consumed");\n    case Temporary:\n        return i18n("Temporary Allocations");\n    default:\n        return QString();\n    }\n}\n\nQVariant ChartModel::headerData(int section, Qt::Orientation orientation, int role) const\n{\n    Q_ASSERT(orientation == Qt::Horizontal || section < columnCount());\n    if (orientation == Qt::Horizontal) {\n        if (role == KChart::DatasetPenRole) {\n            return QVariant::fromValue(m_columnDataSetPens.at(section));\n        } else if (role == KChart::DatasetBrushRole) {\n            return QVariant::fromValue(m_columnDataSetBrushes.at(section));\n        }\n\n        if (role == Qt::ToolTipRole) {\n            if (section == 0) {\n                return i18n("Elapsed Time");\n            }\n            return typeString();\n        } else if (role == Qt::DisplayRole) {\n            if (section == 0) {\n                switch (m_type) {\n                case Allocations:\n                    return i18n("Total Memory Allocations");\n                case Consumed:\n                    return i18n("Total Memory Consumption");\n                case Temporary:\n                    return i18n("Total Temporary Allocations");\n                }\n            } else {\n                auto id = m_data.labels.value(section / 2).functionId;\n                QString label = m_data.resultData->string(id);\n\n                // Experimental symbol name shortening, currently only truncating\n                // and left-justified labels. The length is also fixed and should\n                // be adjusted later on.\n                //\n                // The justified text is also a workaround to setTextAlignment as\n                // this does not seem to work on KChartLegend objects. This might\n                // be because it is not supported for these instances, as the re-\n                // ference suggests: https://doc.qt.io/qt-6/stylesheet-reference.html\n                // (see "text-align" entry).\n                int symbolNameLength = 60;\n\n                if (label.size() < symbolNameLength) {\n                    label = label.leftJustified(symbolNameLength);\n                } else if (label.size() > symbolNameLength) {\n                    label.truncate(symbolNameLength - 3);\n                    label = label.leftJustified(symbolNameLength, QLatin1Char(\'.\'));\n                }\n\n                label = label.rightJustified(symbolNameLength + 1);\n\n                return i18n("%1", label);\n            }\n        }\n    }\n\n    return {};\n}\n\nQVariant ChartModel::data(const QModelIndex& index, int role) const\n{\n    if (!index.isValid()) {\n        return {};\n    }\n    Q_ASSERT(index.row() >= 0 && index.row() < rowCount(index.parent()));\n    Q_ASSERT(index.column() >= 0 && index.column() < columnCount(index.parent()));\n    Q_ASSERT(!index.parent().isValid());\n\n    if (role == KChart::LineAttributesRole) {\n        KChart::LineAttributes attributes;\n        attributes.setDisplayArea(true);\n        if (index.column() > 1) {\n            attributes.setTransparency(127);\n        } else {\n            attributes.setTransparency(50);\n        }\n        return QVariant::fromValue(attributes);\n    }\n\n    if (role == KChart::DatasetPenRole) {\n        return QVariant::fromValue(m_columnDataSetPens.at(index.column()));\n    } else if (role == KChart::DatasetBrushRole) {\n        return QVariant::fromValue(m_columnDataSetBrushes.at(index.column()));\n    }\n\n    if (role != Qt::DisplayRole && role != Qt::ToolTipRole) {\n        return {};\n    }\n\n    const auto& data = m_data.rows.at(index.row());\n\n    int column = index.column();\n    if (role != Qt::ToolTipRole && column % 2 == 0) {\n        return data.timeStamp;\n    }\n    column = column / 2;\n    Q_ASSERT(column < ChartRows::MAX_NUM_COST);\n\n    const auto cost = data.cost[column];\n    if (role == Qt::ToolTipRole) {\n        const QString time = Util::formatTime(data.timeStamp);\n        auto byteCost = [cost]() -> QString {\n            const auto formatted = Util::formatBytes(cost);\n            if (cost > 1024) {\n                return i18nc("%1: the formatted byte size, e.g. \\"1.2KB\\", %2: the raw byte size, e.g. \\"1300\\"",\n                             "%1 (%2 bytes)", formatted, cost);\n            } else {\n                return formatted;\n            }\n        };\n        if (column == 0) {\n            switch (m_type) {\n            case Allocations:\n                return i18n("<qt>%1 allocations in total after %2</qt>", cost, time);\n            case Temporary:\n                return i18n("<qt>%1 temporary allocations in total after %2</qt>", cost, time);\n            case Consumed:\n                return i18n("<qt>%1 consumed in total after %2</qt>", byteCost(), time);\n            }\n        } else {\n            auto label = Util::toString(m_data.labels.value(column), *m_data.resultData, Util::Long);\n            switch (m_type) {\n            case Allocations:\n                return i18n("<qt>%2 allocations after %3 from:<p "\n                            "style=\'margin-left:10px;\'>%1</p></qt>",\n                            label, cost, time);\n            case Temporary:\n                return i18n("<qt>%2 temporary allocations after %3 from:<p "\n                            "style=\'margin-left:10px\'>%1</p></qt>",\n                            label, cost, time);\n            case Consumed:\n                return i18n("<qt>%2 consumed after %3 from:<p "\n                            "style=\'margin-left:10px\'>%1</p></qt>",\n                            label, byteCost(), time);\n            }\n        }\n        return {};\n    }\n\n    return cost;\n}\n\nint ChartModel::columnCount(const QModelIndex& /*parent*/) const\n{\n    return qMin(m_maxDatasetCount, m_data.labels.size()) * 2;\n}\n\nint ChartModel::rowCount(const QModelIndex& parent) const\n{\n    if (parent.isValid()) {\n        return 0;\n    } else {\n        return m_data.rows.size();\n    }\n}\n\nvoid ChartModel::setMaximumDatasetCount(int count)\n{\n    Q_ASSERT(count >= 0);\n\n    int currentColumns = qMin(m_data.labels.size(), m_maxDatasetCount);\n    int newColumnCount = qMin(m_data.labels.size(), count);\n\n    if (newColumnCount == currentColumns) {\n        return;\n    } else if (newColumnCount < currentColumns) {\n        beginRemoveColumns(QModelIndex(), newColumnCount * 2, currentColumns * 2 - 1);\n    } else {\n        beginInsertColumns(QModelIndex(), currentColumns * 2, newColumnCount * 2 - 1);\n    }\n\n    m_maxDatasetCount = count;\n    resetColors();\n\n    if (newColumnCount < currentColumns) {\n        endRemoveColumns();\n    } else {\n        endInsertColumns();\n    }\n    Q_ASSERT(columnCount() == newColumnCount * 2);\n}\n\nvoid ChartModel::resetColors()\n{\n    m_columnDataSetBrushes.clear();\n    m_columnDataSetPens.clear();\n    const auto columns = columnCount();\n    for (int i = 0; i < columns; ++i) {\n        auto color = colorForColumn(i, columns);\n        m_columnDataSetBrushes << QBrush(color);\n        m_columnDataSetPens << QPen(color);\n    }\n}\n\nvoid ChartModel::resetData(const ChartData& data)\n{\n    Q_ASSERT(data.resultData);\n    Q_ASSERT(data.labels.size() < ChartRows::MAX_NUM_COST);\n    beginResetModel();\n    m_data = data;\n    resetColors();\n    endResetModel();\n}\n\nvoid ChartModel::clearData()\n{\n    beginResetModel();\n    m_data = {};\n    m_columnDataSetBrushes = {};\n    m_columnDataSetPens = {};\n    endResetModel();\n}\n\nstruct CompareClosestToTime\n{\n    bool operator()(const qint64& lhs, const ChartRows& rhs) const\n    {\n        return lhs > rhs.timeStamp;\n    }\n    bool operator()(const ChartRows& lhs, const qint64& rhs) const\n    {\n        return lhs.timeStamp > rhs;\n    }\n};\n\nqint64 ChartModel::totalCostAt(qint64 timeStamp) const\n{\n    auto it = std::lower_bound(m_data.rows.rbegin(), m_data.rows.rend(), timeStamp, CompareClosestToTime());\n    if (it == m_data.rows.rend())\n        return 0;\n    return it->cost[0];\n}\n'