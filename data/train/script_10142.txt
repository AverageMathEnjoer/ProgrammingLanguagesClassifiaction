b'#\' Publication-ready volcano plots with enhanced colouring and labeling.\n#\'\n#\' Volcano plots represent a useful way to visualise the results of\n#\' differential expression analyses. Here, we present a highly-configurable\n#\' function that produces publication-ready volcano plots [@EnhancedVolcano].\n#\' \\code{EnhancedVolcano} will attempt to fit as many variable names in\n#\' the plot window as possible, thus avoiding \'clogging\' up the plot with\n#\' labels that could not otherwise have been read.\n#\'\n#\' @param toptable A data-frame of test statistics (if not, a data frame,\n#\'   an attempt will be made to convert it to one). Requires at least\n#\'   the following: column for variable names (can be rownames); a column\n#\'   for log2 fold changes; a column for nominal or adjusted p-value.\n#\' @param lab A column name in \\code{toptable} containing variable names.\n#\'    Can be \\code{rownames(toptable)}.\n#\' @param x A column name in \\code{toptable} containing log2 fold changes.\n#\' @param y A column name in \\code{toptable} containing nominal or adjusted\n#\'    p-values.\n#\' @param selectLab A vector containing a subset of lab.\n#\' @param xlim Limits of the x-axis.\n#\' @param ylim Limits of the y-axis.\n#\' @param xlab Label for x-axis.\n#\' @param ylab Label for y-axis.\n#\' @param axisLabSize Size of x- and y-axis labels.\n#\' @param title Plot title.\n#\' @param subtitle Plot subtitle.\n#\' @param caption Plot caption.\n#\' @param titleLabSize Size of plot title.\n#\' @param subtitleLabSize Size of plot subtitle.\n#\' @param captionLabSize Size of plot caption.\n#\' @param pCutoff Cut-off for statistical significance. A horizontal line\n#\'   will be drawn at -log10(pCutoff).\n#\' @param pCutoffCol Column name of statistical significance values to be used as\n#\'   the cut-off. A typical usage situation would be to pass nominal [un-adjusted]\n#\'   p-values as \'y\', but adjusted p-values as pCutoffCol. In this way, a\n#\'   plot is generated via -log10(unadjusted p-value), but cut-offs based on\n#\'   adjusted p-values.\n#\' @param FCcutoff Cut-off for absolute log2 fold-change. Vertical lines will\n#\'   be drawn at the negative and positive values of log2FCcutoff.\n#\' @param cutoffLineType Line type for \\code{FCcutoff} and \\code{pCutoff}\n#\'   (\'blank\', \'solid\', \'dashed\', \'dotted\', \'dotdash\', \'longdash\', \'twodash\').\n#\' @param cutoffLineCol Line colour for \\code{FCcutoff} and \\code{pCutoff}.\n#\' @param cutoffLineWidth Line width for \\code{FCcutoff} and \\code{pCutoff}.\n#\' @param pointSize Size of plotted points for each variable. Can be\n#\'   a single value or a vector of sizes.\n#\' @param labSize Size of labels for each variable.\n#\' @param labCol Colour of labels for each variable.\n#\' @param labFace Font face of labels for each variable.\n#\' @param boxedLabels Logical, indicating whether or not to draw labels in\n#\'   boxes.\n#\' @param parseLabels Logical, indicating whether or not to parse expressions\n#\'   in labels\n#\' @param shape Shape of the plotted points. Either a single value for\n#\'   all points, or 4 values corresponding to the default 4 legend labels\n#\'   specified by \\code{legendLabels}.\n#\' @param shapeCustom Named vector / key-value pairs that will over-ride the\n#\'   default shape scheme. The order must match that of \\code{toptable}.\n#\'   Names / keys relate to groups / categories; values relate to shape encodings.\n#\' @param col Colour shading for plotted points, corresponding to\n#\'   the default 4 legend labels specified by \\code{legendLabels}.\n#\' @param colCustom Named vector / key-value pairs that will over-ride the\n#\'   default colour scheme. The order must match that of \\code{toptable}.\n#\'   Names / keys relate to groups / categories; values relate to colour.\n#\' @param colAlpha Alpha for purposes of controlling colour transparency of\n#\'   variable points.\n#\' @param colGradient If activated, over-rides the default discrete colour scheme\n#\'   and replaces it with a continous scheme that shades based on nominal or \n#\'   adjusted p-value specified by \\code{y}. For example, c(\'red2\', \'blue2\').\n#\' @param colGradientBreaks Break-points for the two colours specified by\n#\'   colGradient.\n#\' @param colGradientLabels Labels for the break-points specified by\n#\'   colGradientBreaks.\n#\' @param colGradientLimits Limits of the colour scheme specified by\n#\'   colGradient, i.e., max and min possible p-values.\n#\' @param legendLabels Plot legend text labels.\n#\' @param legendPosition Position of legend (\'top\', \'bottom\', \'left\',\n#\'   \'right\').\n#\' @param legendLabSize Size of plot legend text.\n#\' @param legendIconSize Size of plot legend icons / symbols.\n#\' @param legendDropLevels Logical, drop unused factor levels from legend.\n#\' @param encircle A vector of variable names to encircle. Requires installation\n#\'   of package \\code{\\link[ggalt:geom_encircle]{ggalt}}.\n#\' @param encircleCol Colour of the encircled line.\n#\' @param encircleFill Colour fill of the encircled region.\n#\' @param encircleAlpha Alpha for purposes of controlling colour transparency of\n#\'   encircled region.\n#\' @param encircleSize Line width of the encircled line.\n#\' @param shade A vector of variable names to shade.\n#\' @param shadeFill Colour of shaded regions.\n#\' @param shadeAlpha Alpha for purposes of controlling colour transparency of\n#\'   shaded region.\n#\' @param shadeSize Size of the shade contour lines.\n#\' @param shadeBins Number of bins for the density of the shade.\n#\' @param drawConnectors Logical, indicating whether or not to connect plot\n#\'   labels to their corresponding points by line connectors.\n#\' @param widthConnectors Line width of connectors.\n#\' @param typeConnectors Have the arrow head open (\'open\') or filled (\'closed\')?\n#\' @param endsConnectors Which end of connectors to draw arrow head? (\'last\',\n#\'   \'first\', \'both\').\n#\' @param lengthConnectors Length (size) of the connector arrowheads.\n#\' @param colConnectors Line colour of connectors and line segments.\n#\' @param max.overlaps Equivalent of max.overlaps in ggrepel. Set to\n#\'   \'Inf\' to always display all labels when drawConnectors = TRUE.\n#\' @param maxoverlapsConnectors See max.overlaps.\n#\' @param min.segment.length When drawConnectors = TRUE, specifies the minimum\n#\'   length of the connector line segments.\n#\' @param directionConnectors direction in which to draw connectors.\n#\'   \'both\', \'x\', or \'y\'.\n#\' @param arrowheads Logical, indicating whether or not to draw arrow heads or\n#\'   or just have straight lines.\n#\' @param hline Draw one or more horizontal lines passing through this/these\n#\'   values on y-axis. For single values, only a single numerical value is\n#\'   necessary. For multiple lines, pass these as a vector, e.g., c(60,90).\n#\' @param hlineType Line type for \\code{hline} (\'blank\', \'solid\', \'dashed\', \'dotted\',\n#\'   \'dotdash\', \'longdash\', \'twodash\').\n#\' @param hlineCol Colour of \\code{hline}.\n#\' @param hlineWidth Width of \\code{hline}.\n#\' @param vline Draw one or more vertical lines passing through this/these\n#\'   values on x-axis. For single values, only a single numerical value is\n#\'   necessary. For multiple lines, pass these as a vector, e.g., c(60,90).\n#\' @param vlineType Line type for \\code{vline} (\'blank\', \'solid\', \'dashed\', \'dotted\',\n#\'   \'dotdash\', \'longdash\', \'twodash\').\n#\' @param vlineCol Colour of \\code{vline}.\n#\' @param vlineWidth Width of \\code{vline}.\n#\' @param gridlines.major Logical, indicating whether or not to draw major\n#\'   gridlines.\n#\' @param gridlines.minor Logical, indicating whether or not to draw minor\n#\'   gridlines.\n#\' @param border Add a border for just the x and y axes (\'partial\') or the\n#\'   entire plot grid (\'full\')?\n#\' @param borderWidth Width of the border on the x and y axes.\n#\' @param borderColour Colour of the border on the x and y axes. \n#\' @param raster Logical, indicating whether to rasterize the geom_point layer. \n#\'   Requires installation of \\code{\\link[ggrastr:geom_point_rast]{ggrastr}}.\n#\'\n#\' @details\n#\' Volcano plots represent a useful way to visualise the results of differential expression analyses. Here, we present a highly-configurable function that produces publication-ready volcano plots [@EnhancedVolcano]. \\code{EnhancedVolcano} will attempt to fit as many variable names in the plot window as possible, thus avoiding \'clogging\' up the plot with labels that could not otherwise have been read.\n#\'\n#\' @return A \\code{\\link{ggplot2}} object.\n#\'\n#\' @author Kevin Blighe <kevin@clinicalbioinformatics.co.uk>\n#\'\n#\' @examples\n#\' library(\'pasilla\')\n#\' pasCts <- system.file(\'extdata\', \'pasilla_gene_counts.tsv\',\n#\'   package=\'pasilla\', mustWork=TRUE)\n#\' pasAnno <- system.file(\'extdata\', \'pasilla_sample_annotation.csv\',\n#\'   package=\'pasilla\', mustWork=TRUE)\n#\' cts <- as.matrix(read.csv(pasCts,sep=\'\\t\',row.names=\'gene_id\'))\n#\' coldata <- read.csv(pasAnno, row.names=1)\n#\' coldata <- coldata[,c(\'condition\',\'type\')]\n#\' rownames(coldata) <- sub(\'fb\', \'\', rownames(coldata))\n#\' cts <- cts[, rownames(coldata)]\n#\' library(\'DESeq2\')\n#\' dds <- DESeqDataSetFromMatrix(countData = cts,\n#\'   colData = coldata,\n#\'   design = ~ condition)\n#\' \n#\' featureData <- data.frame(gene=rownames(cts))\n#\' mcols(dds) <- DataFrame(mcols(dds), featureData)\n#\' dds <- DESeq(dds)\n#\' res <- results(dds)\n#\' \n#\' EnhancedVolcano(res,\n#\'   lab = rownames(res),\n#\'   x = \'log2FoldChange\',\n#\'   y = \'pvalue\',\n#\'   pCutoff = 10e-4,\n#\'   FCcutoff = 1.333,\n#\'   xlim = c(-5.5, 5.5),\n#\'   ylim = c(0, -log10(10e-12)),\n#\'   pointSize = 1.5,\n#\'   labSize = 2.5,\n#\'   title = \'DESeq2 results\',\n#\'   subtitle = \'Differential expression\',\n#\'   caption = \'FC cutoff, 1.333; p-value cutoff, 10e-4\',\n#\'   legendPosition = "right",\n#\'   legendLabSize = 14,\n#\'   col = c(\'grey30\', \'forestgreen\', \'royalblue\', \'red2\'),\n#\'   colAlpha = 0.9,\n#\'   drawConnectors = TRUE,\n#\'   hline = c(10e-8),\n#\'   widthConnectors = 0.5)\n#\'\n#\' @import ggplot2\n#\' @import ggrepel\n#\' @importFrom methods is\n#\' \n#\' @export\nEnhancedVolcano <- function(\n  toptable,\n  lab,\n  x,\n  y,\n  selectLab = NULL,\n  xlim = c(min(toptable[[x]], na.rm=TRUE) - 1.5,\n    max(toptable[[x]], na.rm=TRUE) + 1.5),\n  ylim = c(0, max(-log10(toptable[[y]]), na.rm=TRUE) + 5),\n  xlab = bquote(~Log[2]~ "fold change"),\n  ylab = bquote(~-Log[10]~italic(P)),\n  axisLabSize = 18,\n  title = \'Volcano plot\',\n  subtitle = bquote(italic(EnhancedVolcano)),\n  caption = paste0(\'total = \', nrow(toptable), \' variables\'),\n  titleLabSize = 18,\n  subtitleLabSize = 14,\n  captionLabSize = 14,\n  pCutoff = 10e-6,\n  pCutoffCol = y,\n  FCcutoff = 1.0,\n  cutoffLineType = \'longdash\',\n  cutoffLineCol = \'black\',\n  cutoffLineWidth = 0.4,\n  pointSize = 2.0,\n  labSize = 5.0,\n  labCol = \'black\',\n  labFace = \'plain\',\n  boxedLabels = FALSE,\n  parseLabels = FALSE,\n  shape = 19,\n  shapeCustom = NULL,\n  col = c(\'grey30\', \'forestgreen\', \'royalblue\', \'red2\'),\n  colCustom = NULL,\n  colAlpha = 1/2,\n  colGradient = NULL,\n  colGradientBreaks = c(pCutoff, 1.0),\n  colGradientLabels = c(\'0\', \'1.0\'),\n  colGradientLimits = c(0, 1.0),\n  legendLabels = c(\'NS\', expression(Log[2]~FC),\n    \'p-value\', expression(p-value~and~log[2]~FC)),\n  legendPosition = \'top\',\n  legendLabSize = 14,\n  legendIconSize = 5.0,\n  legendDropLevels = TRUE,\n  encircle = NULL,\n  encircleCol = \'black\',\n  encircleFill = \'pink\',\n  encircleAlpha = 3/4,\n  encircleSize = 2.5,\n  shade = NULL,\n  shadeFill = \'grey\',\n  shadeAlpha = 1/2,\n  shadeSize = 0.01,\n  shadeBins = 2,\n  drawConnectors = FALSE,\n  widthConnectors = 0.5,\n  typeConnectors = \'closed\',\n  endsConnectors = \'first\',\n  lengthConnectors = unit(0.01, \'npc\'),\n  colConnectors = \'grey10\',\n  max.overlaps = 15,\n  maxoverlapsConnectors = NULL,\n  min.segment.length = 0,\n  directionConnectors = \'both\',\n  arrowheads = TRUE,\n  hline = NULL,\n  hlineType = \'longdash\',\n  hlineCol = \'black\',\n  hlineWidth = 0.4,\n  vline = NULL,\n  vlineType = \'longdash\',\n  vlineCol = \'black\',\n  vlineWidth = 0.4,\n  gridlines.major = TRUE,\n  gridlines.minor = TRUE,\n  border = \'partial\',\n  borderWidth = 0.8,\n  borderColour = \'black\', \n  raster = FALSE)\n{\n  if(!is.numeric(toptable[[x]])) {\n    stop(paste(x, \' is not numeric!\', sep=\'\'))\n  }\n\n  if(!is.numeric(toptable[[pCutoffCol]])) {\n    stop(paste(y, \' is not numeric!\', sep=\'\'))\n  }\n  \n  if (raster) {\n\n    has_ggrastr <- ! is(try(find.package("ggrastr"), silent=TRUE), "try-error")\n\n    if (has_ggrastr) {\n      geom_point <- ggrastr::geom_point_rast\n    } else {\n      warning("raster disabled, required package \\"ggrastr\\" not installed")\n    }\n  }\n\n  if (!is.null(maxoverlapsConnectors)) {\n    max.overlaps <- maxoverlapsConnectors\n  }\n\n  i <- xvals <- yvals <- Sig <- NULL\n\n  toptable <- as.data.frame(toptable)\n  toptable$Sig <- \'NS\'\n  toptable$Sig[(abs(toptable[[x]]) > FCcutoff)] <- \'FC\'\n\n  toptable$Sig[(toptable[[pCutoffCol]] < pCutoff)] <- \'P\'\n  toptable$Sig[(toptable[[pCutoffCol]] < pCutoff) &\n    (abs(toptable[[x]]) > FCcutoff)] <- \'FC_P\'\n  toptable$Sig <- factor(toptable$Sig,\n    levels=c(\'NS\',\'FC\',\'P\',\'FC_P\'))\n  # reset pCutoff to corresponding value on y\n  # allowing to draw hline at the correct\n  # threshold\n  if (pCutoffCol != y) {\n    pCutoff = max(\n      toptable[which(\n        toptable[pCutoffCol] <= pCutoff), y]\n      )\n  }\n  # some software programs return 0 for very low p-values\n  # These throw an error in EnhancedVolcano\n  # Detect these, issue warning, and convert these to\n  # machine-lowest value possible\n  #####\n  # New functionality in > v1.2:\n  # Now convert to 10^-1 lower than lowest non-zero p-value\n  if (min(toptable[[y]], na.rm=TRUE) == 0) {\n    # <= v1.2\n    #warning(paste("One or more P values is 0.",\n    #  "Converting to minimum possible value..."),\n    #  call. = FALSE)\n    #toptable[which(toptable[[y]] == 0), y] <- .Machine$double.xmin\n    warning(paste(\'One or more p-values is 0.\',\n      \'Converting to 10^-1 * current\',\n      \'lowest non-zero p-value...\'),\n      call. = FALSE)\n    toptable[which(toptable[[y]] == 0), y] <- min(\n      toptable[which(toptable[[y]] != 0), y],\n      na.rm = TRUE) * 10^-1\n  }\n\n  toptable$lab <- lab\n  toptable$xvals <- toptable[[x]]\n  toptable$yvals <- toptable[[y]]\n\n  # If user has supplied values in selectLab, convert labels to\n  # NA and then re-set with those in selectLab\n  if (!is.null(selectLab)) {\n    names.new <- rep(NA, length(toptable$lab))\n    indices <- which(toptable$lab %in% selectLab)\n    names.new[indices] <- toptable$lab[indices]\n    toptable$lab <- names.new\n  }\n\n  # create a base theme that will later be modified\n  th <- theme_bw(base_size = 24) +\n\n    theme(\n      legend.background = element_rect(),\n\n      # title, subtitle, and caption\n      plot.title = element_text(\n        angle = 0,\n        size = titleLabSize,\n        face = \'bold\',\n        vjust = 1),\n      plot.subtitle = element_text(\n        angle = 0,\n        size = subtitleLabSize,\n        face = \'plain\',\n        vjust = 1),\n      plot.caption = element_text(\n        angle = 0,\n        size = captionLabSize,\n        face = \'plain\',\n        vjust = 1),\n\n      # axis text\n      axis.text.x = element_text(\n        angle = 0,\n        size = axisLabSize,\n        vjust = 1),\n      axis.text.y = element_text(\n        angle = 0,\n        size = axisLabSize,\n        vjust = 0.5),\n      axis.title = element_text(\n        size = axisLabSize),\n\n      # legend\n      legend.position = legendPosition,\n      legend.key = element_blank(),\n      legend.key.size = unit(0.5, \'cm\'),\n      legend.text = element_text(\n        size = legendLabSize),\n      title = element_text(\n        size = legendLabSize),\n      legend.title = element_blank())\n\n  # Create the plot object differently based on whether colCustom \n  # and shapeCustom are NULL or not. This helps to avoid messing up\n  # the legend.\n  #\n  # 1, both colCustom and shapeCustom are activated\n  if (!is.null(colCustom) & !is.null(shapeCustom)) {\n\n    plot <- ggplot(toptable, aes(x=xvals, y=-log10(yvals))) + th +\n\n      # over-ride legend icon sizes for colour and shape.\n      # guide_legends are separate for colour and shape;\n      # so, legends will be drawn separate\n      guides(\n        colour = guide_legend(\n          order = 1,\n          override.aes = list(\n            size = legendIconSize)),\n        shape = guide_legend(\n          order = 2,\n          override.aes = list(\n            size = legendIconSize))) +\n\n      # include new shape and colour encodings as aes\n      geom_point(\n        aes(\n          color = factor(names(colCustom)),\n          shape = factor(names(shapeCustom))),\n        alpha = colAlpha,\n        size = pointSize,\n        na.rm = TRUE) +\n\n      # specify the colour and shape with the supplied encoding\n      scale_color_manual(values = colCustom) +\n      scale_shape_manual(values = shapeCustom)\n\n  # 2, only colCustom is activated and \'shape\' has just a single value\n  } else if (!is.null(colCustom) & is.null(shapeCustom) & length(shape) == 1) {\n\n    plot <- ggplot(toptable, aes(x=xvals, y=-log10(yvals))) + th +\n\n      # over-ride legend icon sizes for colour and shape.\n      # guide_legends are separate for colour and shape;\n      # so, legends will be drawn separate IF shape is also\n      # included as aes to geom_point (it is not, here)\n      guides(\n        colour = guide_legend(\n          order = 1,\n          override.aes = list(\n            size = legendIconSize)),\n        shape = guide_legend(\n          order = 2,\n          override.aes = list(\n            size = legendIconSize))) +\n\n      # include new colour encodings as aes.\n      # \'shape\' is included, but outside aes\n      geom_point(\n        aes(\n          color = factor(names(colCustom))),\n        alpha = colAlpha,\n        shape = shape,\n        size = pointSize,\n        na.rm = TRUE) +\n\n      # specify the colour with the supplied encoding\n      scale_color_manual(values = colCustom) +\n\n      # \'shape\' is not included as aes. Specifying guide = TRUE\n      # here will result in legends merging\n      scale_shape_manual(guide = TRUE)\n\n  # 3, only colCustom is activated and \'shape\' has 4 values\n  } else if (!is.null(colCustom) & is.null(shapeCustom) & length(shape) == 4) {\n\n    plot <- ggplot(toptable, aes(x=xvals, y=-log10(yvals))) + th +\n\n      # over-ride legend icon sizes for colour and shape.\n      # guide_legends are separate for colour and shape;\n      # so, legends will be drawn separate\n      guides(\n        colour = guide_legend(\n          order = 1,\n          override.aes = list(\n            size = legendIconSize)),\n        shape = guide_legend(\n          order = 2,\n          override.aes = list(\n            size = legendIconSize))) +\n\n      # include new colour encodings as aes.\n      # \'shape\' is included in aes and mapped to 4\n      # categories of NS, FC, P, FC_P\n      geom_point(\n        aes(\n          color = factor(names(colCustom)),\n          shape = Sig),\n        alpha = colAlpha,\n        size = pointSize,\n        na.rm = TRUE) +\n\n      # specify the colour with the supplied encoding\n      scale_color_manual(values = colCustom) +\n\n      # as it is included as aes, a separate legend\n      # for \'shape\' will be drawn. Here, over-ride that\n      # legend\n      scale_shape_manual(\n        values = c(\n          NS = shape[1],\n          FC = shape[2],\n          P = shape[3],\n          FC_P = shape[4]),\n        labels = c(\n          NS = legendLabels[1],\n          FC = legendLabels[2],\n          P = legendLabels[3],\n          FC_P = legendLabels[4]),\n        guide = TRUE,\n        drop = legendDropLevels)\n\n  # 4, only shapeCustom is activated\n  } else if (is.null(colCustom) & !is.null(shapeCustom)) {\n\n    if (is.null(colGradient)) {\n\n      plot <- ggplot(toptable, aes(x = xvals, y = -log10(yvals))) + th +\n\n        # over-ride legend icon sizes for colour and shape.\n        # guide_legends are separate for colour and shape;\n        # so, legends will be drawn separate\n        guides(\n          colour = guide_legend(\n            order = 1,\n            override.aes = list(\n              size = legendIconSize)),\n          shape = guide_legend(\n            order = 2,\n            override.aes = list(\n              size = legendIconSize))) +\n\n        # include new shape encodings as aes.\n        # Standard colour for NS, FC, P, FC_P,\n        # are added to aes, too.\n        geom_point(\n          aes(\n            color = Sig,\n            shape = factor(names(shapeCustom))),\n          alpha = colAlpha,\n          size = pointSize,\n          na.rm = TRUE) +\n\n        # as it is included as aes, a separate legend\n        # for \'colour\' will be drawn. Here, over-ride that\n        # legend\n        scale_color_manual(\n          values = c(\n            NS = col[1],\n            FC = col[2],\n            P = col[3],\n            FC_P = col[4]),\n          labels = c(\n            NS = legendLabels[1],\n            FC = legendLabels[2],\n            P = legendLabels[3],\n            FC_P = legendLabels[4]),\n          drop = legendDropLevels) +\n\n        # specify the shape with the supplied encoding\n        scale_shape_manual(values = shapeCustom)\n\n    } else {\n\n      plot <- ggplot(toptable, aes(x = xvals, y = -log10(yvals))) + th +\n\n        # over-ride legend icon sizes for colour and shape.\n        # guide_legends are separate for colour and shape;\n        # so, legends will be drawn separate\n        guides(\n          shape = guide_legend(\n            order = 2,\n            override.aes = list(\n              size = legendIconSize))) +\n\n        # include new shape encodings as aes.\n        # Standard colour for NS, FC, P, FC_P,\n        # are added to aes, too.\n        geom_point(\n          aes(\n            color = Sig,\n            shape = factor(names(shapeCustom))),\n          alpha = colAlpha,\n          size = pointSize,\n          na.rm = TRUE) +\n\n        scale_colour_gradient(\n          low = colGradient[1],\n          high = colGradient[2],\n          limits = colGradientLimits,\n          breaks = colGradientBreaks,\n          labels = colGradientLabels)\n\n        # specify the shape with the supplied encoding\n        scale_shape_manual(values = shapeCustom)\n\n    }\n\n  # 5, both colCustom and shapeCustom are null;\n  # only a single shape value specified\n  } else if (is.null(colCustom) & is.null(shapeCustom) & length(shape) == 1) {\n\n    if (is.null(colGradient)) {\n\n      plot <- ggplot(toptable, aes(x = xvals, y = -log10(yvals))) + th +\n\n        # over-ride legend icon sizes for colour and shape.\n        # including \'shape\' in the colour guide_legend here\n        # results in the legends merging\n        guides(colour = guide_legend(\n          order = 1,\n          override.aes = list(\n            shape = shape,\n            size = legendIconSize))) +\n\n        geom_point(\n          aes(color = Sig),\n          alpha = colAlpha,\n          shape = shape,\n          size = pointSize,\n          na.rm = TRUE) +\n\n        scale_color_manual(\n          values = c(\n            NS = col[1],\n            FC = col[2],\n            P = col[3],\n            FC_P = col[4]),\n          labels = c(\n            NS = legendLabels[1],\n            FC = legendLabels[2],\n            P = legendLabels[3],\n            FC_P = legendLabels[4]),\n          drop = legendDropLevels)\n\n    } else {\n\n      plot <- ggplot(toptable, aes(x = xvals, y = -log10(yvals))) + th +\n\n        geom_point(\n          aes(color = yvals),\n          alpha = colAlpha,\n          shape = shape,\n          size = pointSize,\n          na.rm = TRUE) +\n\n        scale_colour_gradient(\n          low = colGradient[1],\n          high = colGradient[2],\n          limits = colGradientLimits,\n          breaks = colGradientBreaks,\n          labels = colGradientLabels)\n    }\n\n  # 6, both colCustom and shapeCustom are null;\n  # four shape values are specified\n  } else if (is.null(colCustom) & is.null(shapeCustom) & length(shape) == 4) {\n\n    if (is.null(colGradient)) {\n      plot <- ggplot(toptable, aes(x = xvals, y = -log10(yvals))) + th +\n\n        # over-ride legend icon sizes for colour and shape.\n        # including \'shape\' in the colour guide_legend here\n        # results in the legends merging\n        guides(colour = guide_legend(\n          order = 1,\n          override.aes = list(\n            shape = c(\n              NS = shape[1],\n              FC = shape[2],\n              P = shape[3],\n              FC_P = shape[4]),\n            size = legendIconSize))) +\n\n        geom_point(\n          aes(\n            color = Sig,\n            shape = Sig),\n          alpha = colAlpha,\n          size = pointSize,\n          na.rm = TRUE) +\n\n        scale_color_manual(\n          values = c(\n            NS = col[1],\n            FC = col[2],\n            P = col[3],\n            FC_P = col[4]),\n          labels = c(\n            NS = legendLabels[1],\n            FC = legendLabels[2],\n            P = legendLabels[3],\n            FC_P = legendLabels[4]),\n          drop = legendDropLevels) +\n\n        scale_shape_manual(\n          values = c(\n            NS = shape[1],\n            FC = shape[2],\n            P = shape[3],\n            FC_P = shape[4]),\n          guide = FALSE,\n          drop = legendDropLevels)\n\n    } else {\n\n      plot <- ggplot(toptable, aes(x = xvals, y = -log10(yvals))) + th +\n\n        geom_point(\n          aes(\n            color = yvals,\n            shape = Sig),\n          alpha = colAlpha,\n          size = pointSize,\n          na.rm = TRUE) +\n\n        scale_colour_gradient(\n          low = colGradient[1],\n          high = colGradient[2],\n          limits = colGradientLimits,\n          breaks = colGradientBreaks,\n          labels = colGradientLabels) +\n\n        scale_shape_manual(\n          values = c(\n            NS = shape[1],\n            FC = shape[2],\n            P = shape[3],\n            FC_P = shape[4]),\n          guide = FALSE,\n          drop = legendDropLevels)\n\n    }\n  }\n\n  # add more elements to the plot\n  plot <- plot +\n\n    xlab(xlab) +\n    ylab(ylab) +\n\n    xlim(xlim[1], xlim[2]) +\n    ylim(ylim[1], ylim[2]) +\n\n    geom_vline(xintercept = c(-FCcutoff, FCcutoff),\n      linetype = cutoffLineType,\n      colour = cutoffLineCol,\n      size = cutoffLineWidth) +\n\n    geom_hline(yintercept = -log10(pCutoff),\n      linetype = cutoffLineType,\n      colour = cutoffLineCol,\n      size = cutoffLineWidth)\n\n  # add elements to the plot for title, subtitle, caption\n  plot <- plot + labs(title = title, \n    subtitle = subtitle, caption = caption)\n\n  # add elements to the plot for vlines and hlines\n  if (!is.null(vline)) {\n    plot <- plot + geom_vline(xintercept = vline,\n      linetype = vlineType,\n      colour = vlineCol,\n      size = vlineWidth)\n  }\n  if (!is.null(hline)) {\n    plot <- plot + geom_hline(yintercept = -log10(hline),\n      linetype = hlineType,\n      colour = hlineCol,\n      size = hlineWidth)\n  }\n\n  # Border around plot\n  if (border == \'full\') {\n    plot <- plot + theme(panel.border = element_rect(\n      colour = borderColour, fill = NA, size = borderWidth))\n  } else if (border == \'partial\') {\n    plot <- plot + theme(axis.line = element_line(\n      size = borderWidth, colour = borderColour),\n      panel.border = element_blank(),\n      panel.background = element_blank())\n  } else {\n    stop(\'Unrecognised value passed to \\\'border\\\'. Must be \\\'full\\\' or \\\'partial\\\'\')\n  }\n\n  # Gridlines\n  if (gridlines.major) {\n    plot <- plot + theme(panel.grid.major = element_line())\n  } else {\n    plot <- plot + theme(panel.grid.major = element_blank())\n  }\n  if (gridlines.minor) {\n    plot <- plot + theme(panel.grid.minor = element_line())\n  } else {\n    plot <- plot + theme(panel.grid.minor = element_blank())\n  }\n\n  # user has specified to draw with geom_text or geom_label?\n  if (!boxedLabels) {\n\n    # For labeling with geom_[text|label]_repel and\n    # geom_[text|label] with check_overlap = TRUE, 4 possible\n    # scenarios can arise\n    if (drawConnectors && is.null(selectLab)) {\n\n      if (arrowheads) {\n        arr <- arrow(length = lengthConnectors,\n          type = typeConnectors, ends = endsConnectors)\n      } else {\n        arr <- NULL\n      }\n\n      plot <- plot + geom_text_repel(\n        data = subset(toptable,\n          toptable[[y]] < pCutoff &\n            abs(toptable[[x]]) > FCcutoff),\n        aes(label = subset(toptable,\n          toptable[[y]] < pCutoff &\n            abs(toptable[[x]]) > FCcutoff)[["lab"]]),\n        xlim = c(NA, NA),\n        ylim = c(NA, NA),\n        size = labSize,\n        segment.color = colConnectors,\n        segment.size = widthConnectors,\n        arrow = arr,\n        colour = labCol,\n        fontface = labFace,\n        parse = parseLabels,\n        na.rm = TRUE,\n        direction = directionConnectors,\n        max.overlaps = max.overlaps,\n        min.segment.length = min.segment.length)\n\n    } else if (drawConnectors && !is.null(selectLab)) {\n\n      if (arrowheads) {\n        arr <- arrow(length = lengthConnectors,\n          type = typeConnectors, ends = endsConnectors)\n      } else {\n        arr <- NULL\n      }\n\n      plot <- plot + geom_text_repel(\n        data = subset(toptable,\n          !is.na(toptable[[\'lab\']])),\n        aes(label = subset(toptable,\n          !is.na(toptable[[\'lab\']]))[[\'lab\']]),\n        xlim = c(NA, NA),\n        ylim = c(NA, NA),\n        size = labSize,\n        segment.color = colConnectors,\n        segment.size = widthConnectors,\n        arrow = arr,\n        colour = labCol,\n        fontface = labFace,\n        parse = parseLabels,\n        na.rm = TRUE,\n        direction = directionConnectors,\n        max.overlaps = max.overlaps,\n        min.segment.length = min.segment.length)\n\n    } else if (!drawConnectors && !is.null(selectLab)) {\n\n      plot <- plot + geom_text(\n        data = subset(toptable,\n          !is.na(toptable[[\'lab\']])),\n        aes(\n          label = subset(toptable,\n            !is.na(toptable[[\'lab\']]))[[\'lab\']]),\n        size = labSize,\n        check_overlap = TRUE,\n        colour = labCol,\n        fontface = labFace,\n        parse = parseLabels,\n        na.rm = TRUE)\n\n    } else if (!drawConnectors && is.null(selectLab)) {\n\n      plot <- plot + geom_text(\n        data = subset(toptable,\n          toptable[[y]] < pCutoff &\n            abs(toptable[[x]]) > FCcutoff),\n        aes(label = subset(toptable,\n          toptable[[y]] < pCutoff &\n            abs(toptable[[x]]) > FCcutoff)[[\'lab\']]),\n        size = labSize,\n        check_overlap = TRUE,\n        colour = labCol,\n        fontface = labFace,\n        parse = parseLabels,\n        na.rm = TRUE)\n    }\n\n  } else {\n\n    # For labeling with geom_[text|label]_repel and\n    # geom_[text|label] with check_overlap = TRUE, 4 possible\n    # scenarios can arise\n    if (drawConnectors && is.null(selectLab)) {\n\n      if (arrowheads) {\n        arr <- arrow(length = lengthConnectors,\n          type = typeConnectors, ends = endsConnectors)\n      } else {\n        arr <- NULL\n      }\n\n      plot <- plot + geom_label_repel(\n        data = subset(toptable,\n          toptable[[y]] < pCutoff &\n            abs(toptable[[x]]) > FCcutoff),\n        aes(label = subset(toptable,\n          toptable[[y]]<pCutoff &\n            abs(toptable[[x]]) > FCcutoff)[[\'lab\']]),\n        xlim = c(NA, NA),\n        ylim = c(NA, NA),\n        size = labSize,\n        segment.color = colConnectors,\n        segment.size = widthConnectors,\n        arrow = arr,\n        colour = labCol,\n        fontface = labFace,\n        parse = parseLabels,\n        na.rm = TRUE,\n        direction = directionConnectors,\n        max.overlaps = max.overlaps,\n        min.segment.length = min.segment.length)\n\n    } else if (drawConnectors && !is.null(selectLab)) {\n\n      if (arrowheads) {\n        arr <- arrow(length = lengthConnectors,\n          type = typeConnectors, ends = endsConnectors)\n      } else {\n        arr <- NULL\n      }\n\n      plot <- plot + geom_label_repel(\n        data = subset(toptable,\n          !is.na(toptable[[\'lab\']])),\n        aes(label = subset(toptable,\n          !is.na(toptable[[\'lab\']]))[[\'lab\']]),\n        xlim = c(NA, NA),\n        ylim = c(NA, NA),\n        size = labSize,\n        segment.color = colConnectors,\n        segment.size = widthConnectors,\n        arrow = arr,\n        colour = labCol,\n        fontface = labFace,\n        parse = parseLabels,\n        na.rm = TRUE,\n        direction = directionConnectors,\n        max.overlaps = max.overlaps,\n        min.segment.length = min.segment.length)\n\n    } else if (!drawConnectors && !is.null(selectLab)) {\n\n      plot <- plot + geom_label(\n        data = subset(toptable,\n          !is.na(toptable[["lab"]])),\n        aes(\n          label = subset(toptable,\n            !is.na(toptable[[\'lab\']]))[[\'lab\']]),\n        size = labSize,\n        colour = labCol,\n        fontface = labFace,\n        parse = parseLabels,\n        na.rm = TRUE)\n\n    } else if (!drawConnectors && is.null(selectLab)) {\n\n      plot <- plot + geom_label(\n        data = subset(toptable,\n          toptable[[y]] < pCutoff &\n            abs(toptable[[x]]) > FCcutoff),\n        aes(label = subset(toptable,\n          toptable[[y]] < pCutoff &\n            abs(toptable[[x]]) > FCcutoff)[[\'lab\']]),\n        size = labSize,\n        colour = labCol,\n        fontface = labFace,\n        parse = parseLabels,\n        na.rm = TRUE)\n\n    }\n  }\n\n  # encircle\n  if (!is.null(encircle)) {\n\n    if (is(try(find.package("ggalt"), silent=TRUE), "try-error")) {\n      stop("Please install package \\"ggalt\\" to access the \\"encircle\\" features")\n    }\n\n    plot <- plot + \n      ggalt::geom_encircle(\n        data = subset(toptable,\n          rownames(toptable) %in% encircle),\n        colour = encircleCol,\n        fill = encircleFill,\n        alpha = encircleAlpha,\n        size = encircleSize,\n        show.legend = FALSE,\n        na.rm = TRUE)\n  }\n\n  # shade\n  if (!is.null(shade)) {\n    plot <- plot + \n      stat_density2d(\n        data = subset(toptable,\n          rownames(toptable) %in% shade),\n        fill = shadeFill,\n        alpha = shadeAlpha,\n        geom = \'polygon\',\n        contour = TRUE,\n        size = shadeSize,\n        bins = shadeBins,\n        show.legend = FALSE,\n        na.rm = TRUE)\n  }\n\n  plot <- plot + coord_cartesian(clip = \'off\')\n\n  return(plot)\n}\n'