b'{-# LANGUAGE GADTs #-}\n{-# LANGUAGE LambdaCase #-}\n{-# LANGUAGE Rank2Types #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n{-# OPTIONS_GHC -fno-warn-incomplete-uni-patterns #-}\n\nmodule Hoodle.Accessor where\n\nimport Control.Concurrent.STM (readTVarIO)\nimport Control.Lens (Lens\', set, view, (.~))\nimport Control.Monad.IO.Class (liftIO)\nimport qualified Control.Monad.State as St\nimport Data.Foldable (forM_)\nimport Data.Hoodle.Generic\n  ( ghoodleID,\n    gitems,\n  )\nimport Data.Hoodle.Select (gselSelected)\nimport qualified Data.IntMap as M\nimport qualified Data.Text as T\nimport qualified Data.Text.Encoding as TE\nimport Graphics.Hoodle.Render.Type\n  ( CanvasId,\n    RItem,\n    RenderCache,\n  )\nimport qualified Graphics.UI.Gtk as Gtk\nimport Hoodle.ModelAction.Layer (getCurrentLayer)\nimport Hoodle.Type\n  ( CanvasInfo,\n    FileStore (LocalDir, TempDir),\n    HoodleModeState (SelectState, ViewAppendState),\n    HoodleState,\n    MainCoroutine,\n    PenType,\n    UnitHoodle,\n    currentCanvasInfo,\n    currentPageNum,\n    currentUnit,\n    cvsInfoMap,\n    drawArea,\n    forBoth\',\n    getCanvasInfo,\n    getCurrentPageFromHoodleModeState,\n    getHoodle,\n    gtkUIManager,\n    hoodleFileControl,\n    hoodleFileName,\n    hoodleModeState,\n    pageArrangement,\n    penInfo,\n    penType,\n    renderCacheVar,\n    unboxBiAct,\n    unboxLens,\n    unitHoodles,\n    viewInfo,\n  )\nimport Hoodle.Type.Alias (EditMode, Page, SelectMode)\nimport Hoodle.Type.PageArrangement (PageNum (..))\nimport Hoodle.View.Coordinate\n  ( CanvasGeometry,\n    makeCanvasGeometry,\n  )\nimport Prelude hiding (mapM_)\n\n-- | update state\nupdateXState :: (HoodleState -> MainCoroutine HoodleState) -> MainCoroutine ()\nupdateXState action = St.put =<< action =<< St.get\n\n-- | update unitHoodle\nupdateUhdl :: (UnitHoodle -> MainCoroutine UnitHoodle) -> MainCoroutine ()\nupdateUhdl action = do\n  xst <- St.get\n  let uhdl = view (unitHoodles . currentUnit) xst\n  uhdl\' <- action uhdl\n  St.put (set (unitHoodles . currentUnit) uhdl\' xst)\n\n-- | update unitHoodle\npureUpdateUhdl :: (UnitHoodle -> UnitHoodle) -> MainCoroutine ()\npureUpdateUhdl func = do\n  xst <- St.get\n  let uhdl = (func . view (unitHoodles . currentUnit)) xst\n  St.put ((unitHoodles . currentUnit .~ uhdl) xst)\n\n-- |\ngetPenType :: MainCoroutine PenType\ngetPenType = St.gets (view (penInfo . penType))\n\n-- |\ngetCurrentPageCurr :: MainCoroutine (Page EditMode)\ngetCurrentPageCurr = do\n  xstate <- St.get\n  let uhdl = view (unitHoodles . currentUnit) xstate\n      hdlmodst = view hoodleModeState uhdl\n      cinfobox = view currentCanvasInfo uhdl\n  return $ forBoth\' unboxBiAct (`getCurrentPageFromHoodleModeState` hdlmodst) cinfobox\n\n-- |\ngetCurrentPageCvsId :: CanvasId -> MainCoroutine (Page EditMode)\ngetCurrentPageCvsId cid = do\n  xstate <- St.get\n  let uhdl = view (unitHoodles . currentUnit) xstate\n      hdlmodst = view hoodleModeState uhdl\n      cinfobox = getCanvasInfo cid uhdl\n  return $ forBoth\' unboxBiAct (`getCurrentPageFromHoodleModeState` hdlmodst) cinfobox\n\n-- |\ngetCurrentPageEitherFromHoodleModeState ::\n  CanvasInfo a -> HoodleModeState -> Either (Page EditMode) (Page SelectMode)\ngetCurrentPageEitherFromHoodleModeState cinfo hdlmodst =\n  let cpn = view currentPageNum cinfo\n      page = getCurrentPageFromHoodleModeState cinfo hdlmodst\n   in case hdlmodst of\n        ViewAppendState _hdl -> Left page\n        SelectState thdl ->\n          case view gselSelected thdl of\n            Nothing -> Left page\n            Just (n, tpage) ->\n              if cpn == n\n                then Right tpage\n                else Left page\n\n-- |\nrItmsInCurrLyr :: MainCoroutine [RItem]\nrItmsInCurrLyr = view gitems . getCurrentLayer <$> getCurrentPageCurr\n\n-- |\notherCanvas :: UnitHoodle -> [Int]\notherCanvas = M.keys . view cvsInfoMap\n\n-- | apply an action to all canvases\napplyActionToAllCVS :: (CanvasId -> MainCoroutine ()) -> MainCoroutine ()\napplyActionToAllCVS action = do\n  xstate <- St.get\n  let cinfoMap = view (unitHoodles . currentUnit . cvsInfoMap) xstate\n      keys = M.keys cinfoMap\n  forM_ keys action\n\n-- |\ngetCanvasGeometryCvsId :: CanvasId -> UnitHoodle -> IO CanvasGeometry\ngetCanvasGeometryCvsId cid uhdl = do\n  let cinfobox = getCanvasInfo cid uhdl\n      cpn = PageNum . view (unboxLens currentPageNum) $ cinfobox\n      canvas = view (unboxLens drawArea) cinfobox\n      fsingle :: CanvasInfo a -> IO CanvasGeometry\n      fsingle =\n        flip (makeCanvasGeometry cpn) canvas\n          . view (viewInfo . pageArrangement)\n  forBoth\' unboxBiAct fsingle cinfobox\n\n-- |\ngetGeometry4CurrCvs :: UnitHoodle -> IO CanvasGeometry\ngetGeometry4CurrCvs uhdl = do\n  let cinfobox = view currentCanvasInfo uhdl\n      cpn = PageNum . view (unboxLens currentPageNum) $ cinfobox\n      canvas = view (unboxLens drawArea) cinfobox\n      fsingle :: CanvasInfo a -> IO CanvasGeometry\n      fsingle =\n        flip (makeCanvasGeometry cpn) canvas\n          . view (viewInfo . pageArrangement)\n  forBoth\' unboxBiAct fsingle cinfobox\n\n-- | set toggle UI button to the corresponding HoodleState\nlensSetToggleUIForFlag ::\n  String ->\n  -- | lens for flag\n  Lens\' HoodleState Bool ->\n  HoodleState ->\n  IO Bool\nlensSetToggleUIForFlag toggleid lensforflag xstate =\n  let b = view lensforflag xstate in setToggleUIForFlag toggleid b xstate\n\n-- | set toggle UI button to the corresponding HoodleState\nsetToggleUIForFlag :: String -> Bool -> HoodleState -> IO Bool\nsetToggleUIForFlag toggleid b xstate = do\n  let ui = view gtkUIManager xstate\n  agr <-\n    Gtk.uiManagerGetActionGroups ui >>= \\case\n      [] -> error "No action group? "\n      y : _ -> return y\n  togglea <-\n    Gtk.actionGroupGetAction agr toggleid >>= \\(Just x) ->\n      return (Gtk.castToToggleAction x)\n  Gtk.toggleActionSetActive togglea b\n  return b\n\n-- |\nrenderCache :: MainCoroutine RenderCache\nrenderCache = liftIO . readTVarIO . view renderCacheVar =<< St.get\n\n-- |\ngetHoodleFilePath :: UnitHoodle -> Maybe FilePath\ngetHoodleFilePath = fileStore2Maybe . view (hoodleFileControl . hoodleFileName)\n\n-- |\nfileStore2Maybe :: FileStore -> Maybe FilePath\nfileStore2Maybe (LocalDir Nothing) = Nothing\nfileStore2Maybe (LocalDir (Just filename)) = Just filename\nfileStore2Maybe (TempDir filename) = Just filename\n\n-- |\ngetHoodleID :: UnitHoodle -> T.Text\ngetHoodleID = TE.decodeUtf8 . view ghoodleID . getHoodle\n'