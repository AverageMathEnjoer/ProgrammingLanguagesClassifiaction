b'{-# LANGUAGE DeriveLift, LambdaCase, ScopedTypeVariables #-}\n\nmodule TreeSitter.Symbol\n  ( TSSymbol\n  , fromTSSymbol\n  , SymbolType(..)\n  , Symbol(..)\n  , symbolToName\n  , toHaskellCamelCaseIdentifier\n  , toHaskellPascalCaseIdentifier\n  , escapeOperatorPunctuation\n  , camelCase\n  , capitalize\n  ) where\n\nimport           Data.Char (isAlpha, isControl, toUpper)\nimport           Data.Function ((&))\nimport qualified Data.HashSet as HashSet\nimport           Data.Ix (Ix)\nimport           Data.List.Split (condense, split, whenElt)\nimport           Data.Word (Word16)\nimport           Language.Haskell.TH.Syntax\n\ntype TSSymbol = Word16\n\n-- | Map a \'TSSymbol\' to the corresponding value of a \'Symbol\' datatype.\n--\n--   This should be used instead of \'toEnum\' to perform this conversion, because tree-sitter represents parse errors with the unsigned short @65535@, which is generally not contiguous with the other symbols.\nfromTSSymbol :: forall symbol. Symbol symbol => TSSymbol -> symbol\nfromTSSymbol symbol = toEnum (min (fromIntegral symbol) (fromEnum (maxBound :: symbol)))\n\n\ndata SymbolType = Regular | Anonymous | Auxiliary\n  deriving (Enum, Eq, Lift, Ord, Show)\n\nclass (Bounded s, Enum s, Ix s, Ord s, Show s) => Symbol s where\n  symbolType :: s -> SymbolType\n\n\nsymbolToName :: SymbolType -> String -> String\nsymbolToName ty name\n  = prefixHidden name\n  & toWords\n  & filter (not . all (== \'_\'))\n  & map escapeOperatorPunctuation\n  & (>>= capitalize)\n  & (prefix ++)\n  where\n    toWords = split (condense (whenElt (not . isAlpha)))\n\n    prefixHidden s@(\'_\':_) = "Hidden" ++ s\n    prefixHidden s         = s\n\n    prefix = case ty of\n      Regular   -> ""\n      Anonymous -> "Anon"\n      Auxiliary -> "Aux"\n\ntoHaskellCamelCaseIdentifier :: String -> String\ntoHaskellCamelCaseIdentifier = addTickIfNecessary . escapeOperatorPunctuation . camelCase\n\naddTickIfNecessary :: String -> String\naddTickIfNecessary s\n  | HashSet.member s reservedNames = s <> "\'"\n  | otherwise = s\n  where\n    reservedNames :: HashSet.HashSet String\n    reservedNames = HashSet.fromList [\n        "as", "case", "class", "data", "default", "deriving", "do", "forall",\n        "foreign", "hiding", "if", "then", "else", "import", "infix", "infixl",\n        "infixr", "instance", "let", "in", "mdo", "module", "newtype", "proc",\n        "qualified", "rec", "type", "where"\n      ]\n\ntoHaskellPascalCaseIdentifier :: String -> String\ntoHaskellPascalCaseIdentifier = addTickIfNecessary . capitalize . escapeOperatorPunctuation . camelCase\n\n-- Ensures that we generate valid Haskell identifiers from\n-- the literal characters used for infix operators and punctuation.\nescapeOperatorPunctuation :: String -> String\nescapeOperatorPunctuation = concatMap $ \\case\n  \'{\' -> "LBrace"\n  \'}\' -> "RBrace"\n  \'(\' -> "LParen"\n  \')\' -> "RParen"\n  \'.\' -> "Dot"\n  \':\' -> "Colon"\n  \',\' -> "Comma"\n  \'|\' -> "Pipe"\n  \';\' -> "Semicolon"\n  \'*\' -> "Star"\n  \'&\' -> "Ampersand"\n  \'=\' -> "Equal"\n  \'<\' -> "LAngle"\n  \'>\' -> "RAngle"\n  \'[\' -> "LBracket"\n  \']\' -> "RBracket"\n  \'+\' -> "Plus"\n  \'-\' -> "Minus"\n  \'/\' -> "Slash"\n  \'\\\\\' -> "Backslash"\n  \'^\' -> "Caret"\n  \'!\' -> "Bang"\n  \'%\' -> "Percent"\n  \'@\' -> "At"\n  \'~\' -> "Tilde"\n  \'?\' -> "Question"\n  \'`\' -> "Backtick"\n  \'#\' -> "Hash"\n  \'$\' -> "Dollar"\n  \'"\' -> "DQuote"\n  \'\\\'\' -> "SQuote"\n  \'\\t\' -> "Tab"\n  \'\\n\' -> "LF"\n  \'\\r\' -> "CR"\n  \' \' -> "Space"\n  other\n    | isControl other -> escapeOperatorPunctuation (show other)\n    | otherwise -> [other]\n\n-- | Convert a snake_case String to camelCase\ncamelCase :: String -> String\ncamelCase = go\n  where\n    go (\'_\':\'_\':xs) = "Underscore" <> go xs\n    go (\'_\':xs)     = go (capitalize xs)\n    go (x:xs)       = x : go xs\n    go ""           = ""\n\n-- | Capitalize a String\ncapitalize :: String -> String\ncapitalize (c:cs) = toUpper c : cs\ncapitalize []     = []\n'