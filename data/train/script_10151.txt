b'{-# LANGUAGE OverloadedStrings #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n\nmodule Hoodle.Config where\n\nimport Control.Concurrent (threadDelay)\nimport Control.Monad (unless)\nimport qualified Data.Configurator as C\nimport Data.Configurator.Types (Config, Worth (Required))\nimport System.Directory (doesFileExist)\nimport System.Environment (getEnv)\nimport System.FilePath ((</>))\n\nemptyConfigString :: String\nemptyConfigString = "\\n#config file for hoodle \\n "\n\nloadConfigFile :: IO Config\nloadConfigFile = do\n  homepath <- getEnv "HOME"\n  let dothoodle = homepath </> ".hoodle"\n  b <- doesFileExist dothoodle\n  unless b $ do\n    writeFile dothoodle emptyConfigString\n    threadDelay 1000000\n  C.load [Required "$(HOME)/.hoodle"]\n\ngetMaxUndo :: Config -> IO (Maybe Int)\ngetMaxUndo c = C.lookup c "maxundo"\n\ngetPenDevConfig :: Config -> IO (Maybe String, Maybe String, Maybe String, Maybe String)\ngetPenDevConfig c = do\n  mcore <- C.lookup c "core"\n  mstylus <- C.lookup c "stylus"\n  meraser <- C.lookup c "eraser"\n  mtouch <- C.lookup c "touch"\n  return (mcore, mstylus, meraser, mtouch)\n\ngetXInputConfig :: Config -> IO Bool\ngetXInputConfig c = do\n  (mxinput :: Maybe String) <- C.lookup c "xinput"\n  case mxinput of\n    Nothing -> return False\n    Just str -> case str of\n      "true" -> return True\n      "false" -> return False\n      _ -> error "cannot understand xinput in configfile"\n\ngetWidgetConfig :: Config -> IO (Bool, Bool)\ngetWidgetConfig c = do\n  (mpanzoom :: Maybe String) <- C.lookup c "PanZoomWidget"\n  (mlayer :: Maybe String) <- C.lookup c "LayerWidget"\n  let panzoom = maybe True (parseBool "PanZoomWidget") mpanzoom\n      layer = maybe True (parseBool "LayerWidget") mlayer\n  print ("WidgetConfig =" ++ show (panzoom, layer))\n  return (panzoom, layer)\n\nparseBool :: String -> String -> Bool\nparseBool msg str = case str of\n  "true" -> True\n  "false" -> False\n  _ -> error ("cannot understand " ++ msg ++ " in configfile")\n\ngetPenConfig :: Config -> IO Bool\ngetPenConfig c = do\n  (mvcursor :: Maybe String) <- C.lookup c "variablecursor"\n  let vcursor = maybe False (parseBool "variablecursor") mvcursor\n  return vcursor\n\n{-\ngetNetworkInfo :: Config -> IO (Maybe HoodleClipClientConfiguration)\ngetNetworkInfo c = do\n  (mserver :: Maybe String) <- C.lookup c "network.server"\n  (mclient :: Maybe String) <- C.lookup c "network.client"\n  return (HoodleClipClientConfiguration <$> mserver <*> mclient)\n-}\n'