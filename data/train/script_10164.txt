b'{-# OPTIONS_GHC -fno-warn-name-shadowing #-}\n{-# LANGUAGE RecordWildCards #-}\n{-# LANGUAGE NamedFieldPuns #-}\n{-# LANGUAGE PartialTypeSignatures #-}\n{-# LANGUAGE AllowAmbiguousTypes #-}\n\nmodule Database.Beam.Test.SQL\n  ( tests ) where\n\nimport Database.Beam.Test.Schema hiding (tests)\n\nimport Database.Beam\nimport Database.Beam.Backend.SQL (MockSqlBackend)\nimport Database.Beam.Backend.SQL.AST\n\nimport Data.Int\nimport Data.Time.Clock\nimport Data.Text (Text)\n\nimport Test.Tasty\nimport Test.Tasty.HUnit\n\ntests :: TestTree\ntests = testGroup "SQL generation tests"\n                  [ simpleSelect\n                  , simpleWhere\n                  , simpleJoin\n                  , selfJoin\n                  , leftJoin\n                  , leftJoinSingle\n                  , aggregates\n                  , orderBy\n\n                  , joinHaving\n\n                  , maybeFieldTypes\n\n                  , tableEquality\n                  , related\n                  , selectCombinators\n                  , limitOffset\n\n                  , existsTest\n\n                  , updateCurrent\n                  , updateNullable\n\n                  , noEmptyIns\n\n                  -- Regressions for github issues\n                  , testGroup "Regression tests"\n                    [ gh70OrderByInFirstJoinCausesIncorrectProjection\n                    ]\n                  ]\n\nselectMock :: Projectible (MockSqlBackend Command) res\n           => Q (MockSqlBackend Command) db QBaseScope res -> SqlSelect (MockSqlBackend Command) (QExprToIdentity res)\nselectMock = select\n\nupdateMock :: Beamable table\n           => DatabaseEntity (MockSqlBackend Command) db (TableEntity table)\n           -> (forall s. table (QField s) -> QAssignment (MockSqlBackend Command) s)\n           -> (forall s. table (QExpr (MockSqlBackend Command) s) -> QExpr (MockSqlBackend Command) s Bool)\n           -> SqlUpdate (MockSqlBackend Command) table\nupdateMock = update\n\n-- | Ensure simple select selects the right fields\n\nsimpleSelect :: TestTree\nsimpleSelect =\n  testCase "All fields are present in a simple all_ query" $\n  do SqlSelect Select { selectTable = SelectTable { .. }\n                      , .. } <- pure (selectMock (all_ (_employees employeeDbSettings)))\n\n     selectGrouping @?= Nothing\n     selectOrdering @?= []\n     selectWhere @?= Nothing\n     selectLimit @?= Nothing\n     selectOffset @?= Nothing\n     selectHaving @?= Nothing\n     selectQuantifier @?= Nothing\n\n     Just (FromTable (TableNamed (TableName Nothing "employees")) (Just (tblName, Nothing))) <- pure selectFrom\n\n     selectProjection @?= ProjExprs [ (ExpressionFieldName (QualifiedField tblName "first_name"), Just "res0")\n                                    , (ExpressionFieldName (QualifiedField tblName "last_name"), Just "res1")\n                                    , (ExpressionFieldName (QualifiedField tblName "phone_number"), Just "res2")\n                                    , (ExpressionFieldName (QualifiedField tblName "age"), Just "res3")\n                                    , (ExpressionFieldName (QualifiedField tblName "salary"), Just "res4")\n                                    , (ExpressionFieldName (QualifiedField tblName "hire_date"), Just "res5")\n                                    , (ExpressionFieldName (QualifiedField tblName "leave_date"), Just "res6")\n                                    , (ExpressionFieldName (QualifiedField tblName "created"), Just "res7") ]\n\n-- | Simple select with WHERE clause\n\nsimpleWhere :: TestTree\nsimpleWhere =\n  testCase "guard_ clauses are successfully translated into WHERE statements" $\n  do SqlSelect Select { selectTable = SelectTable { .. }\n                      , .. } <- pure $ selectMock $\n                                do e <- all_ (_employees employeeDbSettings)\n                                   guard_ (_employeeSalary e >. 120202 &&.\n                                           _employeeAge e <. 30 &&.\n                                           _employeeFirstName e ==. _employeeLastName e)\n                                   pure e\n     selectGrouping @?= Nothing\n     selectOrdering @?= []\n     selectLimit @?= Nothing\n     selectOffset @?= Nothing\n     selectHaving @?= Nothing\n     selectQuantifier @?= Nothing\n\n     Just (FromTable (TableNamed (TableName Nothing "employees")) (Just (employees, Nothing))) <- pure selectFrom\n\n     let salaryCond = ExpressionCompOp ">" Nothing (ExpressionFieldName (QualifiedField employees "salary")) (ExpressionValue (Value (120202 :: Double)))\n         ageCond = ExpressionCompOp "<" Nothing (ExpressionFieldName (QualifiedField employees "age")) (ExpressionValue (Value (30 :: Int32)))\n         nameCond = ExpressionCompOp "==" Nothing (ExpressionFieldName (QualifiedField employees "first_name")) (ExpressionFieldName (QualifiedField employees "last_name"))\n\n     selectWhere @?= Just (ExpressionBinOp "AND" salaryCond (ExpressionBinOp "AND" ageCond nameCond))\n\n-- | Ensure that multiple tables are correctly joined\n\nsimpleJoin :: TestTree\nsimpleJoin =\n  testCase "Introducing multiple tables results in an inner join" $\n  do SqlSelect Select { selectTable = SelectTable { .. }\n                      , .. } <- pure $ selectMock $\n                                do e <- all_ (_employees employeeDbSettings)\n                                   r <- all_ (_roles employeeDbSettings)\n                                   pure (_employeePhoneNumber e, _roleName r)\n\n     selectGrouping @?= Nothing\n     selectOrdering @?= []\n     selectWhere @?= Nothing\n     selectLimit @?= Nothing\n     selectOffset @?= Nothing\n     selectHaving @?= Nothing\n     selectQuantifier @?= Nothing\n\n     Just (InnerJoin (FromTable (TableNamed (TableName Nothing "employees")) (Just (employees, Nothing)))\n                     (FromTable (TableNamed (TableName Nothing "roles")) (Just (roles, Nothing)))\n                     Nothing) <- pure selectFrom\n\n     selectProjection @?= ProjExprs [ ( ExpressionFieldName (QualifiedField employees "phone_number"), Just "res0" )\n                                    , ( ExpressionFieldName (QualifiedField roles "name"), Just "res1") ]\n\n-- | Ensure that multiple joins on the same table are correctly referenced\n\nselfJoin :: TestTree\nselfJoin =\n  testCase "Table names are unique and properly used in self joins" $\n  do SqlSelect Select { selectTable = SelectTable { .. }\n                      , .. } <- pure $ selectMock $\n                                do e1 <- all_ (_employees employeeDbSettings)\n                                   e2 <- relatedBy_ (_employees employeeDbSettings)\n                                                    (\\e2 -> _employeeFirstName e1 ==. _employeeLastName e2)\n                                   e3 <- relatedBy_ (_employees employeeDbSettings)\n                                                    (\\e3 -> _employeePhoneNumber e1 ==. _employeeLastName e3 &&. _employeePhoneNumber e3 ==. _employeeFirstName e2)\n                                   pure (_employeeFirstName e1, _employeeLastName e2, _employeePhoneNumber e3)\n\n     selectGrouping @?= Nothing\n     selectOrdering @?= []\n     selectWhere @?= Nothing\n     selectLimit @?= Nothing\n     selectOffset @?= Nothing\n     selectHaving @?= Nothing\n     selectQuantifier @?= Nothing\n\n     Just (InnerJoin (InnerJoin (FromTable (TableNamed (TableName Nothing "employees")) (Just (e1, Nothing)))\n                                (FromTable (TableNamed (TableName Nothing "employees")) (Just (e2, Nothing)))\n                                (Just joinCondition12))\n                     (FromTable (TableNamed (TableName Nothing "employees")) (Just (e3, Nothing)))\n                     (Just joinCondition123)) <- pure selectFrom\n\n     assertBool "Table names are not unique" (e1 /= e2 && e1 /= e3 && e2 /= e3)\n     joinCondition12 @?= ExpressionCompOp "==" Nothing (ExpressionFieldName (QualifiedField e1 "first_name"))\n                                                       (ExpressionFieldName (QualifiedField e2 "last_name"))\n     joinCondition123 @?= ExpressionBinOp "AND" (ExpressionCompOp "==" Nothing (ExpressionFieldName (QualifiedField e1 "phone_number"))\n                                                  (ExpressionFieldName (QualifiedField e3 "last_name")))\n                            (ExpressionCompOp "==" Nothing (ExpressionFieldName (QualifiedField e3 "phone_number")) (ExpressionFieldName (QualifiedField e2 "first_name")))\n\n-- | Ensure that left joins are properly generated\n\nleftJoin :: TestTree\nleftJoin =\n  testCase "leftJoin_ generates the right join" $\n  do SqlSelect Select { selectTable = SelectTable { selectWhere = Nothing, selectFrom } } <-\n       pure $ selectMock $\n       do r <- all_ (_roles employeeDbSettings)\n          e <- leftJoin_ (all_ (_employees employeeDbSettings)) (\\e -> primaryKey e ==. _roleForEmployee r)\n          pure (e, r)\n\n     Just (LeftJoin (FromTable (TableNamed (TableName Nothing "roles")) (Just (roles, Nothing)))\n                    (FromTable (TableNamed (TableName Nothing "employees")) (Just (employees, Nothing)))\n                    (Just cond)) <- pure selectFrom\n\n     let andE = ExpressionBinOp "AND"\n         eqE = ExpressionCompOp "==" Nothing\n\n         firstNameCond = eqE (ExpressionFieldName (QualifiedField employees "first_name"))\n                             (ExpressionFieldName (QualifiedField roles "for_employee__first_name"))\n         lastNameCond = eqE (ExpressionFieldName (QualifiedField employees "last_name"))\n                            (ExpressionFieldName (QualifiedField roles "for_employee__last_name"))\n         createdCond = eqE (ExpressionFieldName (QualifiedField employees "created"))\n                           (ExpressionFieldName (QualifiedField roles "for_employee__created"))\n\n     cond @?= andE (andE firstNameCond lastNameCond) createdCond\n\n-- | Ensure that left joins which return a single column are properly typed. The\n--   point of this test is to test for compile-time errors. The same query\n--   should be generated as above.\n\nleftJoinSingle :: TestTree\nleftJoinSingle =\n  testCase "leftJoin_ generates the right join (single return value)" $\n  do SqlSelect Select { selectTable = SelectTable { selectWhere = Nothing, selectFrom } } <-\n       pure $ selectMock $\n       do r <- all_ (_roles employeeDbSettings)\n          e <- leftJoin_ (do e <- all_ (_employees employeeDbSettings)\n                             pure (primaryKey e, _employeeAge e))\n                         (\\(key, _) -> key ==. _roleForEmployee r)\n          pure (e, r)\n\n     Just (LeftJoin (FromTable (TableNamed (TableName Nothing "roles")) (Just (roles, Nothing)))\n                    (FromTable (TableNamed (TableName Nothing "employees")) (Just (employees, Nothing)))\n                    (Just cond)) <- pure selectFrom\n\n     let andE = ExpressionBinOp "AND"\n         eqE = ExpressionCompOp "==" Nothing\n\n         firstNameCond = eqE (ExpressionFieldName (QualifiedField employees "first_name"))\n                             (ExpressionFieldName (QualifiedField roles "for_employee__first_name"))\n         lastNameCond = eqE (ExpressionFieldName (QualifiedField employees "last_name"))\n                            (ExpressionFieldName (QualifiedField roles "for_employee__last_name"))\n         createdCond = eqE (ExpressionFieldName (QualifiedField employees "created"))\n                           (ExpressionFieldName (QualifiedField roles "for_employee__created"))\n\n     cond @?= andE (andE firstNameCond lastNameCond) createdCond\n\n-- | Ensure that aggregations cause the correct GROUP BY clause to be generated\n\naggregates :: TestTree\naggregates =\n  testGroup "Aggregate support"\n    [ basicAggregate\n    , basicHaving\n    , aggregateInJoin\n    , aggregateInJoinReverse\n    , aggregateOverTopLevel\n    , filterAfterTopLevelAggregate\n    , joinTopLevelAggregate\n    , joinTopLevelAggregate2 ]\n  where\n    basicAggregate =\n      testCase "Basic aggregate support" $\n      do SqlSelect Select { selectTable = SelectTable { .. }\n                          , selectLimit = Nothing, selectOffset = Nothing\n                          , selectOrdering = [] } <-\n           pure $ selectMock $\n           aggregate_ (\\e -> (group_ (_employeeAge e), max_ (charLength_ (_employeeFirstName e)))) $\n           do e <- all_ (_employees employeeDbSettings)\n              pure e\n\n         Just (FromTable (TableNamed (TableName Nothing "employees")) (Just (t0, Nothing))) <- pure selectFrom\n         selectProjection @?= ProjExprs [ ( ExpressionFieldName (QualifiedField t0 "age"), Just "res0" )\n                                        , ( ExpressionAgg "MAX" Nothing [ ExpressionCharLength (ExpressionFieldName (QualifiedField t0 "first_name")) ], Just "res1") ]\n         selectWhere @?= Nothing\n         selectGrouping @?= Just (Grouping [ ExpressionFieldName (QualifiedField t0 "age") ])\n         selectHaving @?= Nothing\n\n    basicHaving =\n      testCase "Basic HAVING support" $\n      do SqlSelect Select { selectTable = SelectTable { .. }\n                          , selectLimit = Nothing, selectOffset = Nothing\n                          , selectOrdering = [] } <-\n           pure $ selectMock $\n           do (age, maxNameLength) <- aggregate_ (\\e -> ( group_ (_employeeAge e)\n                                                        , fromMaybe_ 0 (max_ (as_ @Int32 (charLength_ (_employeeFirstName e))))) ) $\n                                      all_ (_employees employeeDbSettings)\n              guard_ (maxNameLength >. 42)\n              pure (age, maxNameLength)\n\n         Just (FromTable (TableNamed (TableName Nothing "employees")) (Just (t0, Nothing))) <- pure selectFrom\n         selectProjection @?= ProjExprs [ ( ExpressionFieldName (QualifiedField t0 "age"), Just "res0" )\n                                        , ( ExpressionCoalesce [ ExpressionAgg "MAX" Nothing [ ExpressionCharLength (ExpressionFieldName (QualifiedField t0 "first_name")) ]\n                                                               , ExpressionValue (Value (0 :: Int32)) ], Just "res1" ) ]\n         selectWhere @?= Nothing\n         selectGrouping @?= Just (Grouping [ ExpressionFieldName (QualifiedField t0 "age") ])\n         selectHaving @?= Just (ExpressionCompOp ">" Nothing\n                                (ExpressionCoalesce [ ExpressionAgg "MAX" Nothing [ ExpressionCharLength (ExpressionFieldName (QualifiedField t0 "first_name")) ]\n                                                    , ExpressionValue (Value (0 :: Int32)) ])\n                                (ExpressionValue (Value (42 :: Int32))))\n\n    aggregateInJoin =\n      testCase "Aggregate in JOIN" $\n      do SqlSelect Select { selectTable = SelectTable { .. }\n                          , selectLimit = Nothing, selectOffset = Nothing\n                          , selectOrdering = [] } <-\n           pure $ selectMock $\n           do (age, maxFirstNameLength) <- aggregate_ (\\e -> (group_ (_employeeAge e), max_ (charLength_ (_employeeFirstName e)))) $\n                                           all_ (_employees employeeDbSettings)\n              role <- all_ (_roles employeeDbSettings)\n              pure (age, maxFirstNameLength, _roleName role)\n\n         Just (InnerJoin (FromTable (TableFromSubSelect subselect) (Just (t0, Nothing)))\n                         (FromTable (TableNamed (TableName Nothing "roles")) (Just (t1, Nothing)))\n                         Nothing) <- pure selectFrom\n         selectProjection @?= ProjExprs [ (ExpressionFieldName (QualifiedField t0 "res0"), Just "res0")\n                                        , (ExpressionFieldName (QualifiedField t0 "res1"), Just "res1")\n                                        , (ExpressionFieldName (QualifiedField t1 "name"), Just "res2") ]\n         selectWhere @?= Nothing\n         selectGrouping @?= Nothing\n         selectHaving @?= Nothing\n\n         Select { selectTable = SelectTable { .. }\n                , selectLimit = Nothing, selectOffset = Nothing\n                , selectOrdering = [] } <- pure subselect\n         Just (FromTable (TableNamed (TableName Nothing "employees")) (Just (t0, Nothing))) <- pure selectFrom\n         selectProjection @?= ProjExprs [ (ExpressionFieldName (QualifiedField t0 "age"), Just "res0")\n                                        , (ExpressionAgg "MAX" Nothing [ExpressionCharLength (ExpressionFieldName (QualifiedField t0 "first_name"))], Just "res1") ]\n         selectWhere @?= Nothing\n         selectGrouping @?= Just (Grouping [ExpressionFieldName (QualifiedField t0 "age")])\n         selectHaving @?= Nothing\n\n    aggregateInJoinReverse =\n      testCase "Aggregate in JOIN (reverse order)" $\n      do SqlSelect Select { selectTable = SelectTable { .. }\n                          , selectLimit = Nothing, selectOffset = Nothing\n                          , selectOrdering = [] } <-\n           pure $ selectMock $\n           do role <- all_ (_roles employeeDbSettings)\n              (age, maxFirstNameLength) <- aggregate_ (\\e -> (group_ (_employeeAge e), max_ (charLength_ (_employeeFirstName e)))) $\n                                           all_ (_employees employeeDbSettings)\n              pure (age, maxFirstNameLength, _roleName role)\n\n         Just (InnerJoin (FromTable (TableNamed (TableName Nothing "roles")) (Just (t0, Nothing)))\n                         (FromTable (TableFromSubSelect subselect) (Just (t1, Nothing)))\n                         Nothing) <- pure selectFrom\n         selectProjection @?= ProjExprs [ (ExpressionFieldName (QualifiedField t1 "res0"), Just "res0")\n                                        , (ExpressionFieldName (QualifiedField t1 "res1"), Just "res1")\n                                        , (ExpressionFieldName (QualifiedField t0 "name"), Just "res2") ]\n         selectWhere @?= Nothing\n         selectGrouping @?= Nothing\n         selectHaving @?= Nothing\n\n         Select { selectTable = SelectTable { .. }\n                , selectLimit = Nothing, selectOffset = Nothing\n                , selectOrdering = [] } <- pure subselect\n         Just (FromTable (TableNamed (TableName Nothing "employees")) (Just (t0, Nothing))) <- pure selectFrom\n         selectProjection @?= ProjExprs [ (ExpressionFieldName (QualifiedField t0 "age"), Just "res0")\n                                        , (ExpressionAgg "MAX" Nothing [ExpressionCharLength (ExpressionFieldName (QualifiedField t0 "first_name"))], Just "res1") ]\n         selectWhere @?= Nothing\n         selectGrouping @?= Just (Grouping [ExpressionFieldName (QualifiedField t0 "age")])\n         selectHaving @?= Nothing\n\n    aggregateOverTopLevel =\n      testCase "Aggregate over top-level" $\n      do SqlSelect Select { selectTable = SelectTable { .. }\n                          , selectLimit = Nothing, selectOffset = Nothing\n                          , selectOrdering = [] } <-\n           pure $ selectMock $\n           aggregate_ (\\e -> (group_ (_employeeAge e), max_ (charLength_ (_employeeFirstName e)))) $\n           limit_ 10 (all_ (_employees employeeDbSettings))\n\n         Just (FromTable (TableFromSubSelect subselect) (Just (t0, Nothing))) <- pure selectFrom\n\n         selectProjection @?= ProjExprs [(ExpressionFieldName (QualifiedField t0 "res3"),Just "res0"),(ExpressionAgg "MAX" Nothing [ExpressionCharLength (ExpressionFieldName (QualifiedField t0 "res0"))], Just "res1")]\n         selectWhere @?= Nothing\n         selectGrouping @?= Just (Grouping [ExpressionFieldName (QualifiedField t0 "res3")])\n         selectHaving @?= Nothing\n\n         selectLimit subselect @?= Just 10\n         selectOffset subselect @?= Nothing\n         selectOrdering subselect @?= []\n\n         SelectTable {selectFrom = Just (FromTable (TableNamed (TableName Nothing "employees")) (Just (t0\', Nothing))), .. } <-\n             pure $ selectTable subselect\n\n         selectWhere @?= Nothing\n         selectGrouping @?= Nothing\n         selectHaving @?= Nothing\n         selectProjection @?=\n            ProjExprs [ (ExpressionFieldName (QualifiedField t0\' "first_name"), Just "res0")\n                      , (ExpressionFieldName (QualifiedField t0\' "last_name"),  Just "res1")\n                      , (ExpressionFieldName (QualifiedField t0\' "phone_number"), Just "res2")\n                      , (ExpressionFieldName (QualifiedField t0\' "age"), Just "res3")\n                      , (ExpressionFieldName (QualifiedField t0\' "salary"), Just "res4")\n                      , (ExpressionFieldName (QualifiedField t0\' "hire_date"), Just "res5")\n                      , (ExpressionFieldName (QualifiedField t0\' "leave_date"), Just "res6")\n                      , (ExpressionFieldName (QualifiedField t0\' "created"), Just "res7") ]\n\n--         assertFailure ("Select " ++ show s)\n\n    filterAfterTopLevelAggregate =\n      testCase "Filter after top-level aggregate" $\n      do SqlSelect Select { selectTable = SelectTable { .. }\n                          , selectLimit = Nothing, selectOffset = Nothing\n                          , selectOrdering = [] } <-\n           pure $ selectMock $\n           filter_ (\\(_, l) -> l <. 10 ||. l >. 20) $\n           aggregate_ (\\e -> ( group_ (_employeeAge e)\n                             , fromMaybe_ 0 (max_ (as_ @Int32 (charLength_ (_employeeFirstName e))))) ) $\n           limit_ 10 (all_ (_employees employeeDbSettings))\n         Just (FromTable (TableFromSubSelect subselect) (Just (t0, Nothing))) <- pure selectFrom\n\n         selectProjection @?= ProjExprs [ (ExpressionFieldName (QualifiedField t0 "res3"),Just "res0")\n                                        , (ExpressionCoalesce [ ExpressionAgg "MAX" Nothing [ExpressionCharLength (ExpressionFieldName (QualifiedField t0 "res0"))]\n                                                              , ExpressionValue (Value (0 :: Int32)) ], Just "res1")\n                                        ]\n         selectWhere @?= Nothing\n         selectGrouping @?= Just (Grouping [ExpressionFieldName (QualifiedField t0 "res3")])\n         selectHaving @?= Just (ExpressionBinOp "OR" (ExpressionCompOp "<" Nothing\n                                                      (ExpressionCoalesce [ ExpressionAgg "MAX" Nothing [ ExpressionCharLength (ExpressionFieldName (QualifiedField t0 "res0")) ]\n                                                                          , ExpressionValue (Value (0 :: Int32)) ])\n                                                      (ExpressionValue (Value (10 :: Int32))))\n                                                     (ExpressionCompOp ">" Nothing\n                                                      (ExpressionCoalesce [ ExpressionAgg "MAX" Nothing [ ExpressionCharLength (ExpressionFieldName (QualifiedField t0 "res0")) ]\n                                                                          , ExpressionValue (Value (0 :: Int32)) ])\n                                                      (ExpressionValue (Value (20 :: Int32)))))\n\n         selectLimit subselect @?= Just 10\n         selectOffset subselect @?= Nothing\n         selectOrdering subselect @?= []\n\n         SelectTable {selectFrom = Just (FromTable (TableNamed (TableName Nothing "employees")) (Just (t0\', Nothing))), .. } <-\n             pure $ selectTable subselect\n\n         selectWhere @?= Nothing\n         selectGrouping @?= Nothing\n         selectHaving @?= Nothing\n         selectProjection @?=\n            ProjExprs [ (ExpressionFieldName (QualifiedField t0\' "first_name"), Just "res0")\n                      , (ExpressionFieldName (QualifiedField t0\' "last_name"),  Just "res1")\n                      , (ExpressionFieldName (QualifiedField t0\' "phone_number"), Just "res2")\n                      , (ExpressionFieldName (QualifiedField t0\' "age"), Just "res3")\n                      , (ExpressionFieldName (QualifiedField t0\' "salary"), Just "res4")\n                      , (ExpressionFieldName (QualifiedField t0\' "hire_date"), Just "res5")\n                      , (ExpressionFieldName (QualifiedField t0\' "leave_date"), Just "res6")\n                      , (ExpressionFieldName (QualifiedField t0\' "created"), Just "res7") ]\n\n    joinTopLevelAggregate =\n      testCase "Join against top-level aggregate" $\n      do SqlSelect Select { selectTable = SelectTable { .. }\n                          , selectLimit = Nothing, selectOffset = Nothing\n                          , selectOrdering = [] } <-\n           pure $ selectMock $\n           do (lastName, firstNameLength) <-\n                  filter_ (\\(_, charLength) -> fromMaybe_ 0 charLength >. 10) $\n                  aggregate_ (\\e -> (group_ (_employeeLastName e), max_ (as_ @Int32 (charLength_ (_employeeFirstName e))))) $\n                  limit_ 10 (all_ (_employees employeeDbSettings))\n              role <- relatedBy_ (_roles employeeDbSettings) (\\r -> _roleName r ==. lastName)\n              pure (firstNameLength, role, lastName)\n\n         Just (InnerJoin (FromTable (TableFromSubSelect subselect) (Just (t0, Nothing)))\n                         (FromTable (TableNamed (TableName Nothing "roles")) (Just (t1, Nothing)))\n                         (Just joinCond) ) <-\n           pure selectFrom\n\n         joinCond @?= ExpressionCompOp "==" Nothing (ExpressionFieldName (QualifiedField t1 "name")) (ExpressionFieldName (QualifiedField t0 "res0"))\n         selectProjection @?= ProjExprs [ ( ExpressionFieldName (QualifiedField t0 "res1"), Just "res0" )\n                                        , ( ExpressionFieldName (QualifiedField t1 "for_employee__first_name"), Just "res1" )\n                                        , ( ExpressionFieldName (QualifiedField t1 "for_employee__last_name"), Just "res2" )\n                                        , ( ExpressionFieldName (QualifiedField t1 "for_employee__created"), Just "res3" )\n                                        , ( ExpressionFieldName (QualifiedField t1 "name"), Just "res4" )\n                                        , ( ExpressionFieldName (QualifiedField t1 "started"), Just "res5" )\n                                        , ( ExpressionFieldName (QualifiedField t0 "res0"), Just "res6" ) ]\n         selectWhere @?= Nothing\n         selectHaving @?= Nothing\n         selectGrouping @?= Nothing\n\n         Select { selectTable = SelectTable { .. }, selectLimit = Nothing\n                , selectOffset = Nothing, selectOrdering = [] } <-\n           pure subselect\n         Just (FromTable (TableFromSubSelect employeesSelect) (Just (t0\', Nothing))) <- pure selectFrom\n         selectWhere @?= Nothing\n         selectHaving @?= Just (ExpressionCompOp ">" Nothing (ExpressionCoalesce [ ExpressionAgg "MAX" Nothing [ExpressionCharLength (ExpressionFieldName (QualifiedField t0\' "res0"))]\n                                                                                 , ExpressionValue (Value (0 :: Int32)) ])\n                                                             (ExpressionValue (Value (10 :: Int32))))\n         selectGrouping @?= Just (Grouping [ (ExpressionFieldName (QualifiedField t0\' "res1")) ])\n         selectProjection @?= ProjExprs [ ( ExpressionFieldName (QualifiedField t0\' "res1"), Just "res0" )\n                                        , ( ExpressionAgg "MAX" Nothing [ExpressionCharLength (ExpressionFieldName (QualifiedField t0\' "res0"))], Just "res1" ) ]\n\n         Select { selectTable = SelectTable { .. }, selectLimit = Just 10\n                , selectOffset = Nothing, selectOrdering = [] } <-\n           pure employeesSelect\n         Just (FromTable (TableNamed (TableName Nothing "employees")) (Just (t0\'\', Nothing))) <- pure selectFrom\n\n         selectWhere @?= Nothing\n         selectHaving @?= Nothing\n         selectGrouping @?= Nothing\n         selectProjection @?= ProjExprs [ ( ExpressionFieldName (QualifiedField t0\'\' "first_name"), Just "res0" )\n                                        , ( ExpressionFieldName (QualifiedField t0\'\' "last_name"), Just "res1" )\n                                        , ( ExpressionFieldName (QualifiedField t0\'\' "phone_number"), Just "res2" )\n                                        , ( ExpressionFieldName (QualifiedField t0\'\' "age"), Just "res3" )\n                                        , ( ExpressionFieldName (QualifiedField t0\'\' "salary"), Just "res4" )\n                                        , ( ExpressionFieldName (QualifiedField t0\'\' "hire_date"), Just "res5" )\n                                        , ( ExpressionFieldName (QualifiedField t0\'\' "leave_date"), Just "res6" )\n                                        , ( ExpressionFieldName (QualifiedField t0\'\' "created"), Just "res7" ) ]\n\n    joinTopLevelAggregate2 =\n      testCase "Join against top-level aggregate (places reversed)" $\n      do SqlSelect Select { selectTable = SelectTable { .. }\n                          , selectLimit = Nothing, selectOffset = Nothing\n                          , selectOrdering = [] } <-\n           pure $ selectMock $\n           do role <- all_ (_roles employeeDbSettings)\n              (lastName, firstNameLength) <-\n                  filter_ (\\(_, charLength) -> charLength >. 10) $\n                  aggregate_ (\\e -> ( group_ (_employeeLastName e)\n                                    , fromMaybe_ 0 $ max_ (as_ @Int32 (charLength_ (_employeeFirstName e)))) ) $\n                  limit_ 10 (all_ (_employees employeeDbSettings))\n              guard_ (_roleName role ==. lastName)\n              pure (firstNameLength, role, lastName)\n\n         Just (InnerJoin (FromTable (TableNamed (TableName Nothing "roles")) (Just (t0, Nothing)))\n                         (FromTable (TableFromSubSelect subselect) (Just (t1, Nothing)))\n                         Nothing) <-\n           pure selectFrom\n         selectWhere @?= Just (ExpressionBinOp "AND"\n                               (ExpressionCompOp ">" Nothing (ExpressionFieldName (QualifiedField t1 "res1")) (ExpressionValue (Value (10 :: Int32))))\n                               (ExpressionCompOp "==" Nothing (ExpressionFieldName (QualifiedField t0 "name")) (ExpressionFieldName (QualifiedField t1 "res0"))))\n         selectProjection @?= ProjExprs [ ( ExpressionFieldName (QualifiedField t1 "res1"), Just "res0" )\n                                        , ( ExpressionFieldName (QualifiedField t0 "for_employee__first_name"), Just "res1" )\n                                        , ( ExpressionFieldName (QualifiedField t0 "for_employee__last_name"), Just "res2" )\n                                        , ( ExpressionFieldName (QualifiedField t0 "for_employee__created"), Just "res3" )\n                                        , ( ExpressionFieldName (QualifiedField t0 "name"), Just "res4" )\n                                        , ( ExpressionFieldName (QualifiedField t0 "started"), Just "res5" )\n                                        , ( ExpressionFieldName (QualifiedField t1 "res0"), Just "res6" ) ]\n         selectHaving @?= Nothing\n         selectGrouping @?= Nothing\n\n         Select { selectTable = SelectTable { .. }, selectLimit = Nothing\n                , selectOffset = Nothing, selectOrdering = [] } <-\n           pure subselect\n         Just (FromTable (TableFromSubSelect employeesSelect) (Just (t0\', Nothing))) <- pure selectFrom\n         selectWhere @?= Nothing\n         selectHaving @?= Nothing\n         selectGrouping @?= Just (Grouping [ (ExpressionFieldName (QualifiedField t0\' "res1")) ])\n         selectProjection @?= ProjExprs [ ( ExpressionFieldName (QualifiedField t0\' "res1"), Just "res0" )\n                                        , ( ExpressionCoalesce [ ExpressionAgg "MAX" Nothing [ExpressionCharLength (ExpressionFieldName (QualifiedField t0\' "res0"))]\n                                                               , ExpressionValue (Value (0 :: Int32)) ]\n                                          , Just "res1" ) ]\n\n         Select { selectTable = SelectTable { .. }, selectLimit = Just 10\n                , selectOffset = Nothing, selectOrdering = [] } <-\n           pure employeesSelect\n         Just (FromTable (TableNamed (TableName Nothing "employees")) (Just (t0\'\', Nothing))) <- pure selectFrom\n\n         selectWhere @?= Nothing\n         selectHaving @?= Nothing\n         selectGrouping @?= Nothing\n         selectProjection @?= ProjExprs [ ( ExpressionFieldName (QualifiedField t0\'\' "first_name"), Just "res0" )\n                                        , ( ExpressionFieldName (QualifiedField t0\'\' "last_name"), Just "res1" )\n                                        , ( ExpressionFieldName (QualifiedField t0\'\' "phone_number"), Just "res2" )\n                                        , ( ExpressionFieldName (QualifiedField t0\'\' "age"), Just "res3" )\n                                        , ( ExpressionFieldName (QualifiedField t0\'\' "salary"), Just "res4" )\n                                        , ( ExpressionFieldName (QualifiedField t0\'\' "hire_date"), Just "res5" )\n                                        , ( ExpressionFieldName (QualifiedField t0\'\' "leave_date"), Just "res6" )\n                                        , ( ExpressionFieldName (QualifiedField t0\'\' "created"), Just "res7" ) ]\n\n-- | ORDER BY\n\norderBy :: TestTree\norderBy =\n  testGroup "ORDER BY tests"\n            [ simpleOrdering\n            , orderCombination\n            , orderLimitsOffsets\n            , orderJoin\n            , orderJoinReversed ]\n  where\n    simpleOrdering =\n      testCase "Simple Ordering" $\n      do SqlSelect Select { selectTable = select\n                          , selectLimit = Just 100, selectOffset = Just 5\n                          , selectOrdering = ordering } <-\n           pure $ selectMock $\n           limit_ 100 $ offset_ 5 $\n           orderBy_ (asc_ . _roleStarted) $\n           all_ (_roles employeeDbSettings)\n         select @?= SelectTable { selectProjection =\n                                    ProjExprs [ ( ExpressionFieldName (QualifiedField "t0" "for_employee__first_name"), Just "res0" )\n                                              , ( ExpressionFieldName (QualifiedField "t0" "for_employee__last_name"), Just "res1" )\n                                              , ( ExpressionFieldName (QualifiedField "t0" "for_employee__created"), Just "res2" )\n                                              , ( ExpressionFieldName (QualifiedField "t0" "name"), Just "res3" )\n                                              , ( ExpressionFieldName (QualifiedField "t0" "started"), Just "res4" ) ]\n                                , selectFrom = Just (FromTable (TableNamed (TableName Nothing "roles")) (Just ("t0", Nothing)))\n                                , selectWhere = Nothing\n                                , selectGrouping = Nothing\n                                , selectHaving = Nothing\n                                , selectQuantifier = Nothing }\n         ordering @?= [ OrderingAsc (ExpressionFieldName (QualifiedField "t0" "started")) ]\n    orderCombination =\n      testCase "Order combined query" $\n      do SqlSelect Select { selectTable = select\n                          , selectLimit = Nothing, selectOffset = Nothing\n                          , selectOrdering = ordering } <-\n           pure $ selectMock $\n           orderBy_ (asc_ . _roleStarted) $\n           (all_ (_roles employeeDbSettings) `unionAll_`\n            all_ (_roles employeeDbSettings))\n\n         let expSelect =\n               SelectTable { selectProjection =\n                                    ProjExprs [ ( ExpressionFieldName (QualifiedField "t0" "for_employee__first_name"), Just "res0" )\n                                              , ( ExpressionFieldName (QualifiedField "t0" "for_employee__last_name"), Just "res1" )\n                                              , ( ExpressionFieldName (QualifiedField "t0" "for_employee__created"), Just "res2" )\n                                              , ( ExpressionFieldName (QualifiedField "t0" "name"), Just "res3" )\n                                              , ( ExpressionFieldName (QualifiedField "t0" "started"), Just "res4" ) ]\n                           , selectFrom = Just (FromTable (TableNamed (TableName Nothing "roles")) (Just ("t0", Nothing)))\n                           , selectWhere = Nothing\n                           , selectGrouping = Nothing\n                           , selectHaving = Nothing\n                           , selectQuantifier = Nothing }\n         select @?= UnionTables True expSelect expSelect\n         ordering @?= [ OrderingAsc (ExpressionFieldName (UnqualifiedField "res4")) ]\n\n    orderLimitsOffsets =\n      testCase "Order after LIMIT/OFFSET" $\n      do SqlSelect Select { selectTable = s\n                          , selectLimit = Nothing, selectOffset = Nothing\n                          , selectOrdering = ordering } <-\n           pure $ selectMock $\n           orderBy_ (asc_ . _roleStarted) $\n           limit_ 100 $ offset_ 5 $\n           all_ (_roles employeeDbSettings)\n\n         let rolesSelect =\n               SelectTable { selectProjection =\n                                    ProjExprs [ ( ExpressionFieldName (QualifiedField "t0" "for_employee__first_name"), Just "res0" )\n                                              , ( ExpressionFieldName (QualifiedField "t0" "for_employee__last_name"), Just "res1" )\n                                              , ( ExpressionFieldName (QualifiedField "t0" "for_employee__created"), Just "res2" )\n                                              , ( ExpressionFieldName (QualifiedField "t0" "name"), Just "res3" )\n                                              , ( ExpressionFieldName (QualifiedField "t0" "started"), Just "res4" ) ]\n                           , selectFrom = Just (FromTable (TableNamed (TableName Nothing "roles")) (Just ("t0", Nothing)))\n                           , selectWhere = Nothing\n                           , selectGrouping = Nothing\n                           , selectHaving = Nothing\n                           , selectQuantifier = Nothing }\n         s @?= SelectTable { selectProjection =\n                                    ProjExprs [ ( ExpressionFieldName (QualifiedField "t0" "res0"), Just "res0" )\n                                              , ( ExpressionFieldName (QualifiedField "t0" "res1"), Just "res1" )\n                                              , ( ExpressionFieldName (QualifiedField "t0" "res2"), Just "res2" )\n                                              , ( ExpressionFieldName (QualifiedField "t0" "res3"), Just "res3" )\n                                              , ( ExpressionFieldName (QualifiedField "t0" "res4"), Just "res4" ) ]\n                                , selectFrom = Just (FromTable (TableFromSubSelect (Select { selectTable = rolesSelect, selectLimit = Just 100\n                                                                                           , selectOffset = Just 5, selectOrdering = [] })) (Just ("t0", Nothing)))\n                                , selectWhere = Nothing\n                                , selectGrouping = Nothing\n                                , selectHaving = Nothing\n                                , selectQuantifier = Nothing }\n         ordering @?= [ OrderingAsc (ExpressionFieldName (QualifiedField "t0" "res4")) ]\n\n    orderJoin =\n      testCase "Order join" $\n      do SqlSelect Select { selectTable = select\n                          , selectLimit = Nothing, selectOffset = Nothing\n                          , selectOrdering = [] } <-\n           pure $ selectMock $\n           do oldestEmployees <- limit_ 10 $ orderBy_ ((,) <$> (asc_ <$> _employeeAge) <*> (desc_ <$> (charLength_ <$> _employeeFirstName))) $\n                                 all_ (_employees employeeDbSettings)\n              role <- relatedBy_ (_roles employeeDbSettings) (\\r -> _roleForEmployee r ==. primaryKey oldestEmployees)\n              pure (_employeeFirstName oldestEmployees, _employeeLastName oldestEmployees, _employeeAge oldestEmployees, _roleName role)\n\n         selectProjection select @?= ProjExprs [ ( ExpressionFieldName (QualifiedField "t0" "res0"), Just "res0" )\n                                               , ( ExpressionFieldName (QualifiedField "t0" "res1"), Just "res1" )\n                                               , ( ExpressionFieldName (QualifiedField "t0" "res3"), Just "res2" )\n                                               , ( ExpressionFieldName (QualifiedField "t1" "name"), Just "res3" ) ]\n         let subselectExp = Select { selectTable = subselectTableExp, selectLimit = Just 10, selectOffset = Nothing\n                                   , selectOrdering = [ OrderingAsc (ExpressionFieldName (QualifiedField "t0" "age"))\n                                                      , OrderingDesc (ExpressionCharLength (ExpressionFieldName (QualifiedField "t0" "first_name"))) ] }\n             subselectTableExp = SelectTable { selectProjection =\n                                                 ProjExprs [ ( ExpressionFieldName (QualifiedField "t0" "first_name"), Just "res0" )\n                                                           , ( ExpressionFieldName (QualifiedField "t0" "last_name"), Just "res1" )\n                                                           , ( ExpressionFieldName (QualifiedField "t0" "phone_number"), Just "res2" )\n                                                           , ( ExpressionFieldName (QualifiedField "t0" "age"), Just "res3" )\n                                                           , ( ExpressionFieldName (QualifiedField "t0" "salary"), Just "res4" )\n                                                           , ( ExpressionFieldName (QualifiedField "t0" "hire_date"), Just "res5" )\n                                                           , ( ExpressionFieldName (QualifiedField "t0" "leave_date"), Just "res6" )\n                                                           , ( ExpressionFieldName (QualifiedField "t0" "created"), Just "res7" ) ]\n                                             , selectFrom = Just (FromTable (TableNamed (TableName Nothing "employees")) (Just ("t0", Nothing)))\n                                             , selectWhere = Nothing\n                                             , selectGrouping = Nothing\n                                             , selectHaving = Nothing\n                                             , selectQuantifier = Nothing }\n             joinCondExp = ExpressionBinOp "AND" (ExpressionBinOp "AND" (ExpressionCompOp "==" Nothing (ExpressionFieldName (QualifiedField "t1" "for_employee__first_name"))\n                                                                                                       (ExpressionFieldName (QualifiedField "t0" "res0")))\n                                                                        (ExpressionCompOp "==" Nothing (ExpressionFieldName (QualifiedField "t1" "for_employee__last_name"))\n                                                                                                       (ExpressionFieldName (QualifiedField "t0" "res1"))))\n                                                 (ExpressionCompOp "==" Nothing (ExpressionFieldName (QualifiedField "t1" "for_employee__created"))\n                                                                                (ExpressionFieldName (QualifiedField "t0" "res7")))\n         selectFrom select @?= Just (InnerJoin (FromTable (TableFromSubSelect subselectExp) (Just ("t0", Nothing))) (FromTable (TableNamed (TableName Nothing "roles")) (Just ("t1", Nothing)))\n                                               (Just joinCondExp))\n         selectWhere select @?= Nothing\n         selectGrouping select @?= Nothing\n         selectHaving select @?= Nothing\n\n    orderJoinReversed =\n      testCase "Order join (reversed)" $\n      do SqlSelect Select { selectTable = s\n                          , selectLimit = Nothing, selectOffset = Nothing\n                          , selectOrdering = [] } <-\n           pure $ selectMock $\n           do role <- all_ (_roles employeeDbSettings)\n              oldestEmployees <- limit_ 10 $ orderBy_ ((,) <$> (asc_ <$> _employeeAge) <*> (desc_ <$> (charLength_ <$> _employeeFirstName))) $\n                                 all_ (_employees employeeDbSettings)\n              guard_ (_roleForEmployee role ==. primaryKey oldestEmployees)\n              pure (_employeeFirstName oldestEmployees, _employeeLastName oldestEmployees, _employeeAge oldestEmployees, _roleName role)\n\n         selectProjection s @?= ProjExprs [ ( ExpressionFieldName (QualifiedField "t1" "res0"), Just "res0" )\n                                          , ( ExpressionFieldName (QualifiedField "t1" "res1"), Just "res1" )\n                                          , ( ExpressionFieldName (QualifiedField "t1" "res3"), Just "res2" )\n                                          , ( ExpressionFieldName (QualifiedField "t0" "name"), Just "res3" ) ]\n         selectWhere s @?= Just (ExpressionBinOp "AND"\n                                  (ExpressionBinOp "AND"\n                                    (ExpressionCompOp "==" Nothing (ExpressionFieldName (QualifiedField "t0" "for_employee__first_name"))\n                                      (ExpressionFieldName (QualifiedField "t1" "res0")))\n                                    (ExpressionCompOp "==" Nothing (ExpressionFieldName (QualifiedField "t0" "for_employee__last_name"))\n                                      (ExpressionFieldName (QualifiedField "t1" "res1"))))\n                                  (ExpressionCompOp "==" Nothing (ExpressionFieldName (QualifiedField "t0" "for_employee__created"))\n                                    (ExpressionFieldName (QualifiedField "t1" "res7"))))\n         selectGrouping s @?= Nothing\n         selectHaving s @?= Nothing\n\n         let subselect = Select { selectTable = subselectTable, selectLimit = Just 10, selectOffset = Nothing\n                                , selectOrdering = [ OrderingAsc (ExpressionFieldName (QualifiedField "t0" "age"))\n                                                      , OrderingDesc (ExpressionCharLength (ExpressionFieldName (QualifiedField "t0" "first_name"))) ] }\n             subselectTable = SelectTable { selectProjection =\n                                                 ProjExprs [ ( ExpressionFieldName (QualifiedField "t0" "first_name"), Just "res0" )\n                                                           , ( ExpressionFieldName (QualifiedField "t0" "last_name"), Just "res1" )\n                                                           , ( ExpressionFieldName (QualifiedField "t0" "phone_number"), Just "res2" )\n                                                           , ( ExpressionFieldName (QualifiedField "t0" "age"), Just "res3" )\n                                                           , ( ExpressionFieldName (QualifiedField "t0" "salary"), Just "res4" )\n                                                           , ( ExpressionFieldName (QualifiedField "t0" "hire_date"), Just "res5" )\n                                                           , ( ExpressionFieldName (QualifiedField "t0" "leave_date"), Just "res6" )\n                                                           , ( ExpressionFieldName (QualifiedField "t0" "created"), Just "res7" ) ]\n                                             , selectFrom = Just (FromTable (TableNamed (TableName Nothing "employees")) (Just ("t0", Nothing)))\n                                             , selectWhere = Nothing\n                                             , selectGrouping = Nothing\n                                             , selectHaving = Nothing\n                                             , selectQuantifier = Nothing }\n         selectFrom s @?= Just (InnerJoin (FromTable (TableNamed (TableName Nothing "roles")) (Just ("t0", Nothing)))\n                                          (FromTable (TableFromSubSelect subselect) (Just ("t1", Nothing)))\n                                          Nothing)\n\n-- | HAVING clause should not be floated out of a join\n\njoinHaving :: TestTree\njoinHaving =\n  testCase "HAVING clause should not be floated out of a join" $\n  do SqlSelect Select { selectTable = SelectTable { .. }\n                      , selectLimit = Nothing, selectOffset = Nothing\n                      , selectOrdering = [] } <-\n       pure $ selectMock $\n       do (age, maxFirstNameLength) <- filter_ (\\(_, nameLength) -> fromMaybe_ 0 nameLength >=. 20) $\n                                       aggregate_ (\\e -> (group_ (_employeeAge e), max_ (as_ @Int32 (charLength_ (_employeeFirstName e))))) $\n                                       all_ (_employees employeeDbSettings)\n          role <- all_ (_roles employeeDbSettings)\n          pure (age, maxFirstNameLength, _roleName role)\n\n     Just (InnerJoin\n            (FromTable (TableFromSubSelect subselect) (Just (t0, Nothing)))\n            (FromTable (TableNamed (TableName Nothing "roles")) (Just (t1, Nothing)))\n            Nothing) <- pure selectFrom\n     selectProjection @?= ProjExprs [ (ExpressionFieldName (QualifiedField t0 "res0"), Just "res0")\n                                    , (ExpressionFieldName (QualifiedField t0 "res1"), Just "res1")\n                                    , (ExpressionFieldName (QualifiedField t1 "name"), Just "res2") ]\n     selectWhere @?= Nothing\n     selectGrouping @?= Nothing\n     selectHaving @?= Nothing\n\n     Select { selectTable = SelectTable { .. }\n            , selectLimit = Nothing, selectOffset = Nothing\n            , selectOrdering = [] } <- pure subselect\n     Just (FromTable (TableNamed (TableName Nothing "employees")) (Just (t0, Nothing))) <- pure selectFrom\n     selectProjection @?= ProjExprs [ (ExpressionFieldName (QualifiedField t0 "age"), Just "res0")\n                                    , (ExpressionAgg "MAX" Nothing [ExpressionCharLength (ExpressionFieldName (QualifiedField t0 "first_name"))], Just "res1") ]\n     selectWhere @?= Nothing\n     selectGrouping @?= Just (Grouping [ExpressionFieldName (QualifiedField t0 "age")])\n     selectHaving @?= Just (ExpressionCompOp ">=" Nothing\n                            (ExpressionCoalesce [ ExpressionAgg "MAX" Nothing [ExpressionCharLength (ExpressionFieldName (QualifiedField t0 "first_name"))]\n                                                , ExpressionValue (Value (0 :: Int32)) ])\n                            (ExpressionValue (Value (20 :: Int32))))\n\n-- | Ensure that isJustE and isNothingE work correctly for simple types\n\nmaybeFieldTypes :: TestTree\nmaybeFieldTypes =\n  testCase "Simple maybe field types" $\n  do SqlSelect Select { selectTable = SelectTable { selectWhere = Just selectWhere, selectFrom } } <- pure $ selectMock $ do\n       e <- all_ (_employees employeeDbSettings)\n       guard_ (isNothing_ (_employeeLeaveDate e))\n       pure e\n\n     Just (FromTable (TableNamed (TableName Nothing "employees")) (Just (employees, Nothing))) <- pure selectFrom\n     selectWhere @?= ExpressionIsNull (ExpressionFieldName (QualifiedField employees "leave_date"))\n\n-- | Ensure isJustE and isNothingE work correctly for table and composite types\n\n-- | Ensure maybeE works for simple types\n\n-- | Ensure equality works for tables\n\ntableEquality :: TestTree\ntableEquality =\n  testGroup "Equality comparisions among table expressions and table literals"\n   [ tableExprToTableExpr, tableExprToTableLiteral ]\n where\n   tableExprToTableExpr =\n     testCase "Equality comparison between two table expressions" $\n     do SqlSelect Select { selectTable = SelectTable { selectWhere = Just selectWhere, selectFrom } } <- pure $ selectMock $ do\n          d <- all_ (_departments employeeDbSettings)\n          guard_ (d ==. d)\n          pure d\n\n        Just (FromTable (TableNamed (TableName Nothing "departments")) (Just (depts, Nothing))) <- pure selectFrom\n\n        let andE = ExpressionBinOp "AND"; orE = ExpressionBinOp "OR"\n            eqE = ExpressionCompOp "==" Nothing\n\n            maybeEqE a b = ExpressionCase [ (andE (ExpressionIsNull a) (ExpressionIsNull b), ExpressionValue (Value True))\n                                          , (orE (ExpressionIsNull a) (ExpressionIsNull b), ExpressionValue (Value False))\n                                          ]\n                                          (eqE a b)\n\n            nameCond = eqE (ExpressionFieldName (QualifiedField depts "name"))\n                           (ExpressionFieldName (QualifiedField depts "name"))\n            firstNameCond = maybeEqE (ExpressionFieldName (QualifiedField depts "head__first_name"))\n                                (ExpressionFieldName (QualifiedField depts "head__first_name"))\n            lastNameCond = maybeEqE (ExpressionFieldName (QualifiedField depts "head__last_name"))\n                                    (ExpressionFieldName (QualifiedField depts "head__last_name"))\n            createdCond = maybeEqE (ExpressionFieldName (QualifiedField depts "head__created"))\n                                   (ExpressionFieldName (QualifiedField depts "head__created"))\n        selectWhere @?= andE (andE (andE nameCond firstNameCond) lastNameCond) createdCond\n\n   tableExprToTableLiteral =\n     testCase "Equality comparison between table expression and table literal" $\n     do now <- getCurrentTime\n\n        let exp = DepartmentT "Sales" (EmployeeId (Just "Jane") (Just "Smith") (Just now))\n        SqlSelect Select { selectTable = SelectTable { selectWhere = Just selectWhere, selectFrom } } <- pure $ selectMock $ do\n          d <- all_ (_departments employeeDbSettings)\n          guard_ (d ==. val_ exp)\n          pure d\n\n        Just (FromTable (TableNamed (TableName Nothing "departments")) (Just (depts, Nothing))) <- pure selectFrom\n\n        let andE = ExpressionBinOp "AND"; orE = ExpressionBinOp "OR"\n            eqE = ExpressionCompOp "==" Nothing\n\n            maybeEqE a b = ExpressionCase [ (andE (ExpressionIsNull a) (ExpressionIsNull b), ExpressionValue (Value True))\n                                          , (orE (ExpressionIsNull a) (ExpressionIsNull b), ExpressionValue (Value False))\n                                          ]\n                                          (eqE a b)\n\n            nameCond = eqE (ExpressionFieldName (QualifiedField depts "name"))\n                           (ExpressionValue (Value ("Sales" :: Text)))\n            firstNameCond = maybeEqE (ExpressionFieldName (QualifiedField depts "head__first_name"))\n                                     (ExpressionValue (Value ("Jane" :: Text)))\n            lastNameCond = maybeEqE (ExpressionFieldName (QualifiedField depts "head__last_name"))\n                                    (ExpressionValue (Value ("Smith" :: Text)))\n            createdCond = maybeEqE (ExpressionFieldName (QualifiedField depts "head__created"))\n                                  (ExpressionValue (Value now))\n        selectWhere @?= andE (andE (andE nameCond firstNameCond) lastNameCond) createdCond\n\n-- | Ensure related_ generates the correct ON conditions\n\nrelated :: TestTree\nrelated =\n  testCase "related_ generate the correct ON conditions" $\n  do SqlSelect Select{} <-\n       pure $ selectMock $\n       do r <- all_ (_roles employeeDbSettings)\n          e <- related_ (_employees employeeDbSettings) (_roleForEmployee r)\n          pure (e, r)\n\n     pure ()\n\n-- | Ensure select can be joined with UNION, INTERSECT, and EXCEPT\n\nselectCombinators :: TestTree\nselectCombinators =\n  testGroup "UNION, INTERSECT, EXCEPT support"\n    [ basicUnion\n    , fieldNamesCapturedCorrectly\n    , basicIntersect\n    , basicExcept\n    , equalProjectionsDontHaveSubSelects\n\n    , unionWithGuards ]\n  where\n    basicUnion =\n      testCase "Basic UNION support" $\n      do let -- leaveDates, hireDates :: Q _ _ s ( QExpr Expression s Text, QExpr Expression s (Maybe _) )\n             hireDates = do e <- all_ (_employees employeeDbSettings)\n                            pure (as_ @Text $ val_ "hire", just_ (_employeeHireDate e))\n             leaveDates = do e <- all_ (_employees employeeDbSettings)\n                             guard_ (isJust_ (_employeeLeaveDate e))\n                             pure (as_ @Text $ val_ "leave", _employeeLeaveDate e)\n         SqlSelect Select { selectTable = UnionTables False a b } <- pure (selectMock (union_ hireDates leaveDates))\n         a @?= SelectTable Nothing\n                           (ProjExprs [ (ExpressionValue (Value ("hire" :: Text)), Just "res0")\n                                      , (ExpressionFieldName (QualifiedField "t0" "hire_date"), Just "res1") ])\n                           (Just (FromTable (TableNamed (TableName Nothing "employees")) (Just ("t0", Nothing))))\n                           Nothing Nothing Nothing\n         b @?= SelectTable Nothing\n                           (ProjExprs [ (ExpressionValue (Value ("leave" :: Text)), Just "res0")\n                                      , (ExpressionFieldName (QualifiedField "t0" "leave_date"), Just "res1") ])\n                           (Just (FromTable (TableNamed (TableName Nothing "employees")) (Just ("t0", Nothing))))\n                           (Just (ExpressionIsNotNull (ExpressionFieldName (QualifiedField "t0" "leave_date"))))\n                           Nothing Nothing\n         pure ()\n\n    fieldNamesCapturedCorrectly =\n      testCase "UNION field names are propagated correctly" $\n      do let -- leaveDates, hireDates :: Q _ _ s ( QExpr Expression s Text, QExpr Expression s Int32, QExpr Expression s (Maybe _) )\n             hireDates = do e <- all_ (_employees employeeDbSettings)\n                            pure (as_ @Text $ val_ "hire", _employeeAge e, just_ (_employeeHireDate e))\n             leaveDates = do e <- all_ (_employees employeeDbSettings)\n                             guard_ (isJust_ (_employeeLeaveDate e))\n                             pure (as_ @Text $ val_ "leave", _employeeAge e, _employeeLeaveDate e)\n         SqlSelect Select { selectTable = SelectTable { .. }, selectLimit = Nothing, selectOffset = Nothing, selectOrdering = [] } <-\n           pure (selectMock $ do\n                    (type_, age, date) <- limit_ 10 (union_ hireDates leaveDates)\n                    guard_ (age <. 22)\n                    pure (type_, age + 23, date))\n\n         Just (FromTable (TableFromSubSelect subselect) (Just (subselectTbl, Nothing))) <- pure selectFrom\n         selectProjection @?= ProjExprs [ (ExpressionFieldName (QualifiedField subselectTbl "res0"), Just "res0")\n                                        , (ExpressionBinOp "+" (ExpressionFieldName (QualifiedField subselectTbl "res1"))\n                                                               (ExpressionValue (Value (23 :: Int32))), Just "res1")\n                                        , (ExpressionFieldName (QualifiedField subselectTbl "res2"), Just "res2") ]\n         selectHaving @?= Nothing\n         selectGrouping @?= Nothing\n         selectWhere @?= Just (ExpressionCompOp "<" Nothing (ExpressionFieldName (QualifiedField subselectTbl "res1")) (ExpressionValue (Value (22 :: Int32))))\n\n         Select { selectTable = UnionTables False hireDatesQuery leaveDatesQuery\n                , selectLimit = Just 10, selectOffset = Nothing\n                , selectOrdering = []  } <-\n           pure subselect\n\n         hireDatesQuery @?= SelectTable Nothing\n                                        (ProjExprs [ ( ExpressionValue (Value ("hire" :: Text)), Just "res0" )\n                                                   , ( ExpressionFieldName (QualifiedField "t0" "age"), Just "res1" )\n                                                   , ( ExpressionFieldName (QualifiedField "t0" "hire_date"), Just "res2" ) ])\n                                        (Just (FromTable (TableNamed (TableName Nothing "employees")) (Just ("t0", Nothing)))) Nothing Nothing Nothing\n         leaveDatesQuery @?= SelectTable Nothing\n                                         (ProjExprs [ ( ExpressionValue (Value ("leave" :: Text)), Just "res0" )\n                                                    , ( ExpressionFieldName (QualifiedField "t0" "age"), Just "res1")\n                                                    , ( ExpressionFieldName (QualifiedField "t0" "leave_date"), Just "res2") ])\n                                         (Just (FromTable (TableNamed (TableName Nothing "employees")) (Just ("t0", Nothing))))\n                                         (Just (ExpressionIsNotNull (ExpressionFieldName (QualifiedField "t0" "leave_date"))))\n                                         Nothing Nothing\n\n         pure ()\n\n    basicIntersect =\n      testCase "intersect_ generates INTERSECT combination" $\n      do let hireDates = do e <- all_ (_employees employeeDbSettings)\n                            pure (_employeeFirstName e, _employeeLastName e)\n             leaveDates = do e <- all_ (_employees employeeDbSettings)\n                             guard_ (isJust_ (_employeeLeaveDate e))\n                             pure (_employeeFirstName e, _employeeLastName e)\n         SqlSelect Select { selectTable = IntersectTables False _ _ } <- pure $ selectMock $ intersect_ hireDates leaveDates\n         pure ()\n\n    basicExcept =\n      testCase "except_ generates EXCEPT combination" $\n      do let hireDates = do e <- all_ (_employees employeeDbSettings)\n                            pure (_employeeFirstName e, _employeeLastName e)\n             leaveDates = do e <- all_ (_employees employeeDbSettings)\n                             guard_ (isJust_ (_employeeLeaveDate e))\n                             pure (_employeeFirstName e, _employeeLastName e)\n         SqlSelect Select { selectTable = ExceptTable False _ _ } <- pure $ selectMock $ except_ hireDates leaveDates\n         pure ()\n\n    equalProjectionsDontHaveSubSelects =\n      testCase "Equal projections dont have sub-selects" $\n      do let -- leaveDates, hireDates :: Q _ _ s ( QExpr Expression s Text, QExpr Expression s Text, QExpr Expression s Int32 )\n             hireDates = do e <- all_ (_employees employeeDbSettings)\n                            pure (_employeeFirstName e, _employeeLastName e, _employeeAge e)\n             leaveDates = do e <- all_ (_employees employeeDbSettings)\n                             guard_ (isJust_ (_employeeLeaveDate e))\n                             pure (_employeeFirstName e, _employeeLastName e, _employeeAge e)\n         SqlSelect Select { selectTable = ExceptTable False _ _ } <-\n             pure $ selectMock $ do\n               (firstName, lastName, age) <- except_ hireDates leaveDates\n               pure (firstName, (lastName, age))\n         pure ()\n\n    unionWithGuards =\n      testCase "UNION with guards" $\n      do let -- leaveDates, hireDates :: Q _ _ s ( QExpr Expression s Text, QExpr Expression s Int32, QExpr Expression s (Maybe _) )\n             hireDates = do e <- all_ (_employees employeeDbSettings)\n                            pure (as_ @Text $ val_ "hire", _employeeAge e, just_ (_employeeHireDate e))\n             leaveDates = do e <- all_ (_employees employeeDbSettings)\n                             guard_ (isJust_ (_employeeLeaveDate e))\n                             pure (as_ @Text $ val_ "leave", _employeeAge e, _employeeLeaveDate e)\n         SqlSelect Select { selectTable =\n                                SelectTable\n                                { selectFrom = Just (FromTable (TableFromSubSelect (Select (UnionTables False a b) [] Nothing Nothing)) (Just (t0, Nothing)))\n                                , selectProjection = proj\n                                , selectWhere = Just where_\n                                , selectGrouping = Nothing\n                                , selectHaving = Nothing\n                                , selectQuantifier = Nothing }\n                          , selectLimit = Nothing, selectOffset = Nothing\n                          , selectOrdering = [] } <- pure (selectMock (filter_ (\\(_, age, _) -> age <. 40) (union_ hireDates leaveDates)))\n         a @?= SelectTable Nothing\n                           (ProjExprs [ (ExpressionValue (Value ("hire" :: Text)), Just "res0")\n                                      , (ExpressionFieldName (QualifiedField "t0" "age"), Just "res1")\n                                      , (ExpressionFieldName (QualifiedField "t0" "hire_date"), Just "res2") ])\n                           (Just (FromTable (TableNamed (TableName Nothing "employees")) (Just ("t0", Nothing))))\n                           Nothing Nothing Nothing\n         b @?= SelectTable Nothing\n                           (ProjExprs [ (ExpressionValue (Value ("leave" :: Text)), Just "res0")\n                                      , (ExpressionFieldName (QualifiedField "t0" "age"), Just "res1")\n                                      , (ExpressionFieldName (QualifiedField "t0" "leave_date"), Just "res2") ])\n                           (Just (FromTable (TableNamed (TableName Nothing "employees")) (Just ("t0", Nothing))))\n                           (Just (ExpressionIsNotNull (ExpressionFieldName (QualifiedField "t0" "leave_date"))))\n                           Nothing Nothing\n\n         proj @?= ProjExprs [ ( ExpressionFieldName (QualifiedField t0 "res0"), Just "res0" )\n                            , ( ExpressionFieldName (QualifiedField t0 "res1"), Just "res1" )\n                            , ( ExpressionFieldName (QualifiedField t0 "res2"), Just "res2" ) ]\n         where_ @?= ExpressionCompOp "<" Nothing (ExpressionFieldName (QualifiedField "t0" "res1")) (ExpressionValue (Value (40 :: Int32)))\n         pure ()\n\n\n-- | Ensure simple selects can be used with limit_ and offset_\n\nlimitOffset :: TestTree\nlimitOffset =\n  testGroup "LIMIT/OFFSET support"\n  [ limitSupport, offsetSupport, limitOffsetSupport\n\n  , limitPlacedOnUnion ]\n  where\n    limitSupport =\n      testCase "Basic LIMIT support" $\n      do SqlSelect Select { selectLimit, selectOffset } <-\n           pure $ selectMock $ limit_ 100 $ limit_ 20 (all_ (_employees employeeDbSettings))\n\n         selectLimit @?= Just 20\n         selectOffset @?= Nothing\n\n    offsetSupport =\n      testCase "Basic OFFSET support" $\n      do SqlSelect Select { selectLimit, selectOffset } <-\n           pure $ selectMock $ offset_ 2 $ offset_ 100 (all_ (_employees employeeDbSettings))\n\n         selectLimit @?= Nothing\n         selectOffset @?= Just 102\n\n    limitOffsetSupport =\n      testCase "Basic LIMIT .. OFFSET .. support" $\n      do SqlSelect Select { selectLimit, selectOffset } <-\n           pure $ selectMock $ offset_ 2 $ limit_ 100 (all_ (_roles employeeDbSettings))\n\n         selectLimit @?= Just 98\n         selectOffset @?= Just 2\n\n    limitPlacedOnUnion =\n      testCase "LIMIT placed on UNION" $\n      do SqlSelect Select { selectOffset = Nothing, selectLimit = Just 10\n                          , selectOrdering = []\n                          , selectTable = UnionTables False a b } <-\n             pure $ selectMock $ limit_ 10 $ union_ (filter_ (\\e -> _employeeAge e <. 40) (all_ (_employees employeeDbSettings)))\n                                                (filter_ (\\e -> _employeeAge e >. 50) (do { e <- all_ (_employees employeeDbSettings); pure e { _employeeFirstName = _employeeLastName e, _employeeLastName = _employeeFirstName e} }))\n\n         selectProjection a @?= ProjExprs [ (ExpressionFieldName (QualifiedField "t0" "first_name"), Just "res0")\n                                          , (ExpressionFieldName (QualifiedField "t0" "last_name"), Just "res1")\n                                          , (ExpressionFieldName (QualifiedField "t0" "phone_number"), Just "res2")\n                                          , (ExpressionFieldName (QualifiedField "t0" "age"), Just "res3")\n                                          , (ExpressionFieldName (QualifiedField "t0" "salary"), Just "res4")\n                                          , (ExpressionFieldName (QualifiedField "t0" "hire_date"), Just "res5")\n                                          , (ExpressionFieldName (QualifiedField "t0" "leave_date"), Just "res6")\n                                          , (ExpressionFieldName (QualifiedField "t0" "created"), Just "res7") ]\n         selectFrom a @?= Just (FromTable (TableNamed (TableName Nothing "employees")) (Just ("t0", Nothing)))\n         selectWhere a @?= Just (ExpressionCompOp "<" Nothing (ExpressionFieldName (QualifiedField "t0" "age")) (ExpressionValue (Value (40 :: Int32))))\n         selectGrouping a @?= Nothing\n         selectHaving a @?= Nothing\n\n         selectProjection b @?= ProjExprs [ (ExpressionFieldName (QualifiedField "t0" "last_name"), Just "res0")\n                                          , (ExpressionFieldName (QualifiedField "t0" "first_name"), Just "res1")\n                                          , (ExpressionFieldName (QualifiedField "t0" "phone_number"), Just "res2")\n                                          , (ExpressionFieldName (QualifiedField "t0" "age"), Just "res3")\n                                          , (ExpressionFieldName (QualifiedField "t0" "salary"), Just "res4")\n                                          , (ExpressionFieldName (QualifiedField "t0" "hire_date"), Just "res5")\n                                          , (ExpressionFieldName (QualifiedField "t0" "leave_date"), Just "res6")\n                                          , (ExpressionFieldName (QualifiedField "t0" "created"), Just "res7") ]\n         selectFrom b @?= Just (FromTable (TableNamed (TableName Nothing "employees")) (Just ("t0", Nothing)))\n         selectWhere b @?= Just (ExpressionCompOp ">" Nothing (ExpressionFieldName (QualifiedField "t0" "age")) (ExpressionValue (Value (50 :: Int32))))\n         selectGrouping b @?= Nothing\n         selectHaving b @?= Nothing\n\n-- | Ensures exists predicates generate table names that do not overlap\n\nexistsTest :: TestTree\nexistsTest =\n  testGroup "EXISTS() tests"\n  [ existsInWhere ]\n  where\n    existsInWhere =\n      testCase "EXISTS() in WHERE" $\n      do SqlSelect Select { selectOffset = Nothing, selectLimit = Nothing\n                          , selectOrdering = []\n                          , selectTable = SelectTable { .. } } <-\n           pure  $ selectMock $ do\n             role <- all_ (_roles employeeDbSettings)\n             guard_ (not_ (exists_ (do dept <- all_ (_departments employeeDbSettings)\n                                       guard_ (_departmentName dept ==. _roleName role)\n                                       pure (as_ @Int32 1))))\n             pure role\n\n         let existsQuery = Select\n                         { selectOffset = Nothing, selectLimit = Nothing\n                         , selectOrdering = []\n                         , selectTable = SelectTable\n                                       { selectQuantifier = Nothing\n                                       , selectProjection = ProjExprs [ (ExpressionValue (Value (1 :: Int32)), Just "res0") ]\n                                       , selectGrouping = Nothing\n                                       , selectHaving = Nothing\n                                       , selectWhere = Just joinExpr\n                                       , selectFrom = Just (FromTable (TableNamed (TableName Nothing "departments")) (Just ("sub_t0", Nothing))) } }\n             joinExpr = ExpressionCompOp "==" Nothing (ExpressionFieldName (QualifiedField "sub_t0" "name"))\n                                                      (ExpressionFieldName (QualifiedField "t0" "name"))\n\n         selectGrouping @?= Nothing\n         selectWhere @?= Just (ExpressionUnOp "NOT" (ExpressionExists existsQuery))\n         selectHaving @?= Nothing\n         selectQuantifier @?= Nothing\n         selectFrom @?= Just (FromTable (TableNamed (TableName Nothing "roles")) (Just ("t0", Nothing)))\n\n-- | UPDATE can correctly get the current value\n\nupdateCurrent :: TestTree\nupdateCurrent =\n  testCase "UPDATE can use current value" $\n  do SqlUpdate _ (Update { .. }) <-\n       pure $ updateMock (_employees employeeDbSettings)\n                         (\\employee -> _employeeAge employee <-. current_ (_employeeAge employee) + 1)\n                         (\\employee -> _employeeFirstName employee ==. "Joe")\n\n     updateTable @?= (TableName Nothing "employees")\n     updateFields @?= [ (UnqualifiedField "age", ExpressionBinOp "+" (ExpressionFieldName (UnqualifiedField "age")) (ExpressionValue (Value (1 :: Int32)))) ]\n     updateWhere @?= Just (ExpressionCompOp "==" Nothing (ExpressionFieldName (UnqualifiedField "first_name")) (ExpressionValue (Value ("Joe" :: String))))\n\nupdateNullable :: TestTree\nupdateNullable =\n  testCase "UPDATE can correctly set a nullable field" $\n  do curTime <- getCurrentTime\n\n     let employeeKey :: PrimaryKey EmployeeT (Nullable Identity)\n         employeeKey = EmployeeId (Just "John") (Just "Smith") (Just curTime)\n\n     SqlUpdate _ (Update { .. }) <-\n       pure $ updateMock (_departments employeeDbSettings)\n                         (\\department -> _departmentHead department <-. val_ employeeKey)\n                         (\\department -> _departmentName department ==. "Sales")\n\n     updateTable @?= (TableName Nothing "departments")\n     updateFields @?= [ (UnqualifiedField "head__first_name", ExpressionValue (Value ("John" :: Text)))\n                      , (UnqualifiedField "head__last_name", ExpressionValue (Value ("Smith" :: Text)))\n                      , (UnqualifiedField "head__created", ExpressionValue (Value curTime)) ]\n     updateWhere @?= Just (ExpressionCompOp "==" Nothing\n                             (ExpressionFieldName (UnqualifiedField "name"))\n                             (ExpressionValue (Value ("Sales" :: String))))\n\n-- | Ensure empty IN operators transform into FALSE\n\nnoEmptyIns :: TestTree\nnoEmptyIns =\n  testCase "Empty INs are transformed to FALSE" $\n  do  SqlSelect Select { selectTable = SelectTable {..} } <-\n        pure $ selectMock $ do\n          e <- all_ (_employees employeeDbSettings)\n          guard_ (_employeeFirstName e `in_` [])\n          pure e\n\n      selectWhere @?= Just (ExpressionValue (Value False))\n\n-- | ORDER BY in first join causes incorrect projection in subquery\n\ngh70OrderByInFirstJoinCausesIncorrectProjection :: TestTree\ngh70OrderByInFirstJoinCausesIncorrectProjection =\n  testGroup "#70: ORDER BY as first join causes incorrect projection"\n    [ testCase "Simple" simple\n    , testCase "Grouping" grouping\n    , testCase "Top-level OFFSET 0" topLevelOffs0\n    ]\n  where\n    employees = "t0"; roles = "t1"\n\n    eqE = ExpressionCompOp "==" Nothing\n    andE = ExpressionBinOp "AND"\n\n    firstNameCond = eqE (ExpressionFieldName (QualifiedField roles "for_employee__first_name"))\n                        (ExpressionFieldName (QualifiedField employees "res0"))\n    lastNameCond = eqE (ExpressionFieldName (QualifiedField roles "for_employee__last_name"))\n                       (ExpressionFieldName (QualifiedField employees "res1"))\n    createdCond = eqE (ExpressionFieldName (QualifiedField roles "for_employee__created"))\n                      (ExpressionFieldName (QualifiedField employees "res7"))\n\n    simple =\n      do let employeesMakingSixFigures =\n               orderBy_ (\\e -> desc_ (_employeeAge e)) $\n               filter_ (\\e -> _employeeSalary e >=. 100000) $\n               all_ (_employees employeeDbSettings)\n\n             richEmployeesAndRoles = do\n               employee <- employeesMakingSixFigures\n               role <- all_ (_roles employeeDbSettings)\n               guard_ (_roleForEmployee role `references_` employee)\n               pure (_roleName role, employee)\n\n         SqlSelect Select { selectTable = SelectTable { .. }\n                          , .. } <-\n           pure $ selectMock richEmployeesAndRoles\n\n         selectProjection @?= ProjExprs\n             [ (ExpressionFieldName (QualifiedField roles "name")    , Just "res0")\n             , (ExpressionFieldName (QualifiedField employees "res0"), Just "res1")\n             , (ExpressionFieldName (QualifiedField employees "res1"), Just "res2")\n             , (ExpressionFieldName (QualifiedField employees "res2"), Just "res3")\n             , (ExpressionFieldName (QualifiedField employees "res3"), Just "res4")\n             , (ExpressionFieldName (QualifiedField employees "res4"), Just "res5")\n             , (ExpressionFieldName (QualifiedField employees "res5"), Just "res6")\n             , (ExpressionFieldName (QualifiedField employees "res6"), Just "res7")\n             , (ExpressionFieldName (QualifiedField employees "res7"), Just "res8")\n             ]\n         selectGrouping @?= Nothing\n         selectOrdering @?= []\n         selectLimit @?= Nothing\n         selectOffset @?= Nothing\n         selectHaving @?= Nothing\n\n         selectWhere @?= Just (andE (andE firstNameCond lastNameCond) createdCond)\n\n         Just (InnerJoin (FromTable (TableFromSubSelect subselect) (Just ("t0", Nothing)))\n                         (FromTable (TableNamed (TableName Nothing "roles")) (Just ("t1", Nothing)))\n                         Nothing) <- pure selectFrom\n\n         Select { selectTable = SelectTable { .. }\n                , .. } <- pure subselect\n\n         selectGrouping @?= Nothing\n         selectLimit @?= Nothing\n         selectOffset @?= Nothing\n         selectHaving @?= Nothing\n         selectOrdering @?= [ OrderingDesc (ExpressionFieldName (QualifiedField "t0" "age")) ]\n         selectWhere @?= Just (ExpressionCompOp ">=" Nothing\n                                 (ExpressionFieldName (QualifiedField "t0" "salary"))\n                                 (ExpressionValue (Value (100000 :: Double))))\n\n         selectProjection @?= ProjExprs\n           [ (ExpressionFieldName (QualifiedField "t0" "first_name")   , Just "res0")\n           , (ExpressionFieldName (QualifiedField "t0" "last_name")    , Just "res1")\n           , (ExpressionFieldName (QualifiedField "t0" "phone_number") , Just "res2")\n           , (ExpressionFieldName (QualifiedField "t0" "age")          , Just "res3")\n           , (ExpressionFieldName (QualifiedField "t0" "salary")       , Just "res4")\n           , (ExpressionFieldName (QualifiedField "t0" "hire_date")    , Just "res5")\n           , (ExpressionFieldName (QualifiedField "t0" "leave_date")   , Just "res6")\n           , (ExpressionFieldName (QualifiedField "t0" "created")      , Just "res7")\n           ]\n\n    grouping = do\n      let employeeNamesWhoMakeSixFiguresOnAverage =\n            orderBy_ (\\(fn, _) -> desc_ fn) $\n            filter_ (\\(_, sl) -> sl >=. val_ 100000) $\n            aggregate_ (\\e -> ( group_ (_employeeFirstName e)\n                              , fromMaybe_ 0 $ avg_ (_employeeSalary e) )) $\n            all_ (_employees employeeDbSettings)\n\n          richEmployeeNamesAndRoles = do\n            (fn, sl) <- employeeNamesWhoMakeSixFiguresOnAverage\n            role <- all_ (_roles employeeDbSettings)\n            let EmployeeId roleForEmployee_firstName _ _ = _roleForEmployee role\n            guard_ (roleForEmployee_firstName ==. fn)\n            pure (_roleName role, fn, sl)\n\n      SqlSelect Select { selectTable = SelectTable\n                                       { selectQuantifier = Nothing\n                                       , selectProjection = ProjExprs\n                                           [ (ExpressionFieldName (QualifiedField "t1" "name"), Just "res0")\n                                           , (ExpressionFieldName (QualifiedField "t0" "res0"), Just "res1")\n                                           , (ExpressionFieldName (QualifiedField "t0" "res1"), Just "res2")\n                                           ]\n                                       , selectGrouping = Nothing, selectHaving = Nothing\n                                       , selectWhere = Just selectWhere\n                                       , selectFrom = Just (InnerJoin (FromTable (TableFromSubSelect Select\n                                                                                 { selectTable =\n                                                                                   SelectTable { selectQuantifier = Nothing\n                                                                                               , selectWhere = Nothing\n                                                                                               , .. }\n                                                                                 , selectLimit = Nothing, selectOffset = Nothing\n                                                                                 , selectOrdering = selectOrdering }) (Just ("t0", Nothing)))\n                                                                    (FromTable (TableNamed (TableName Nothing "roles")) (Just ("t1", Nothing)))\n                                                                    Nothing) }\n                       , selectOrdering = []\n                       , selectLimit = Nothing , selectOffset = Nothing } <-\n        pure $ selectMock $ richEmployeeNamesAndRoles\n\n      selectWhere @?= firstNameCond\n      selectOrdering @?= [ OrderingDesc (ExpressionFieldName (QualifiedField "t0" "first_name")) ]\n      selectGrouping @?= Just (Grouping [ ExpressionFieldName (QualifiedField "t0" "first_name") ])\n      selectHaving @?= Just (ExpressionCompOp ">=" Nothing\n                              (ExpressionCoalesce\n                               [ ExpressionAgg "AVG" Nothing\n                                  [ ExpressionFieldName (QualifiedField "t0" "salary") ]\n                               , ExpressionValue (Value (0 :: Double)) ])\n                              (ExpressionValue (Value (100000 :: Double))))\n      selectProjection @?= ProjExprs\n        [ ( ExpressionFieldName (QualifiedField "t0" "first_name"), Just "res0" )\n        , ( ExpressionCoalesce\n            [ ExpressionAgg "AVG" Nothing\n              [ ExpressionFieldName (QualifiedField "t0" "salary") ]\n            , ExpressionValue (Value (0 :: Double)) ]\n          , Just "res1" )\n        ]\n\n    topLevelOffs0 = do\n      SqlSelect actual <-\n         pure $ selectMock $ do\n           e <-  orderBy_ (\\e -> desc_ (_employeeAge e)) $ offset_ 0 $\n                 filter_ (\\e -> _employeeSalary e >=. val_ 100000) $\n                 all_ (_employees employeeDbSettings)\n           role <- all_ (_roles employeeDbSettings)\n           let EmployeeId roleForEmployee_firstName _ _ = _roleForEmployee role\n           guard_ (roleForEmployee_firstName ==. _employeeFirstName e)\n           pure (_roleName role, _employeeFirstName e)\n\n      let expected =\n            Select { selectTable = SelectTable\n                     { selectQuantifier = Nothing\n                     , selectProjection = ProjExprs\n                       [ (ExpressionFieldName (QualifiedField "t1" "name"), Just "res0")\n                       , (ExpressionFieldName (QualifiedField "t0" "res0"), Just "res1")\n                       ]\n                     , selectGrouping = Nothing, selectHaving = Nothing\n                     , selectWhere = Just firstNameCond\n                     , selectFrom = Just (InnerJoin (FromTable\n                                                     (TableFromSubSelect Select\n                                                       { selectTable = SelectTable\n                                                         { selectQuantifier = Nothing\n                                                         , selectProjection = ProjExprs\n                                                           [ (ExpressionFieldName (QualifiedField "t0" "first_name")   , Just "res0")\n                                                           , (ExpressionFieldName (QualifiedField "t0" "last_name")    , Just "res1")\n                                                           , (ExpressionFieldName (QualifiedField "t0" "phone_number") , Just "res2")\n                                                           , (ExpressionFieldName (QualifiedField "t0" "age")          , Just "res3")\n                                                           , (ExpressionFieldName (QualifiedField "t0" "salary")       , Just "res4")\n                                                           , (ExpressionFieldName (QualifiedField "t0" "hire_date")    , Just "res5")\n                                                           , (ExpressionFieldName (QualifiedField "t0" "leave_date")   , Just "res6")\n                                                           , (ExpressionFieldName (QualifiedField "t0" "created")      , Just "res7")\n                                                           ]\n                                                         , selectWhere = Just (ExpressionCompOp ">=" Nothing\n                                                                               (ExpressionFieldName (QualifiedField "t0" "salary"))\n                                                                               (ExpressionValue (Value (100000 :: Double))))\n                                                         , selectFrom  = Just (FromTable (TableNamed (TableName Nothing "employees")) (Just ("t0", Nothing)))\n                                                         , selectGrouping = Nothing, selectHaving = Nothing }\n                                                       , selectLimit = Nothing, selectOffset = Just 0\n                                                       , selectOrdering = [ OrderingDesc (ExpressionFieldName (QualifiedField "t0" "age"))] }) (Just ("t0", Nothing)))\n                                           (FromTable (TableNamed (TableName Nothing "roles")) (Just ("t1", Nothing)))\n                                           Nothing) }\n                   , selectOrdering = []\n                   , selectLimit = Nothing , selectOffset = Nothing }\n\n      actual @?= expected\n'