b'{-# LANGUAGE CPP #-}\n{-# LANGUAGE LambdaCase #-}\n{-# LANGUAGE NamedFieldPuns #-}\n\n-- | More efficient query execution functions for @beam-postgres@. These\n-- functions use the @conduit@ package, to execute @beam-postgres@ statements in\n-- an arbitrary \'MonadIO\'. These functions may be more efficient for streaming\n-- operations than \'MonadBeam\'.\nmodule Database.Beam.Postgres.Conduit\n  ( streamingRunSelect\n  , runInsert\n  , streamingRunInsertReturning\n  , runUpdate\n  , streamingRunUpdateReturning\n  , runDelete\n  , streamingRunDeleteReturning\n  , executeStatement\n  , streamingRunQueryReturning\n  -- * Deprecated streaming variants\n  , runSelect\n  , runInsertReturning\n  , runUpdateReturning\n  , runDeleteReturning\n  , runQueryReturning\n  ) where\n\nimport           Database.Beam hiding (runInsert, runUpdate, runDelete)\nimport           Database.Beam.Postgres.Connection\nimport           Database.Beam.Postgres.Full\nimport           Database.Beam.Postgres.Syntax\nimport           Database.Beam.Postgres.Types\n\nimport           Control.Concurrent.MVar (takeMVar, putMVar)\nimport           Control.Exception.Base (bracket, throwIO)\nimport           Control.Exception.Lifted (finally)\nimport qualified Control.Exception.Lifted as Lifted\nimport qualified Control.Concurrent.MVar.Lifted as Lifted\nimport           Control.Monad.Trans.Control (MonadBaseControl)\n\nimport qualified Database.PostgreSQL.LibPQ as Pg hiding\n  (Connection, escapeStringConn, escapeIdentifier, escapeByteaConn, exec)\nimport qualified Database.PostgreSQL.LibPQ as Pq\nimport qualified Database.PostgreSQL.Simple as Pg\nimport qualified Database.PostgreSQL.Simple.Internal as Pg\nimport           Database.PostgreSQL.Simple.Internal (connectionHandle)\nimport qualified Database.PostgreSQL.Simple.Types as Pg (Query(..))\n\nimport qualified Conduit as C\nimport           Data.Int (Int64)\nimport           Data.Maybe (fromMaybe)\n#if !MIN_VERSION_base(4, 11, 0)\nimport           Data.Semigroup\n#endif\n\nimport qualified Control.Monad.Fail as Fail\n\n#if MIN_VERSION_conduit(1,3,0)\n#define CONDUIT_TRANSFORMER C.ConduitT\n#else\n#define CONDUIT_TRANSFORMER C.ConduitM\n#endif\n\n-- * @SELECT@\n\n-- | Run a PostgreSQL @SELECT@ statement in any \'C.MonadResource\'.\nstreamingRunSelect :: ( C.MonadResource m, Fail.MonadFail m, FromBackendRow Postgres a )\n                   => Pg.Connection -> SqlSelect Postgres a\n                   -> CONDUIT_TRANSFORMER () a m ()\nstreamingRunSelect conn (SqlSelect (PgSelectSyntax syntax)) =\n  streamingRunQueryReturning conn syntax\n\n-- | Run a PostgreSQL @SELECT@ statement in any \'MonadIO\'.\nrunSelect :: ( MonadIO m, Fail.MonadFail m, MonadBaseControl IO m, FromBackendRow Postgres a )\n          => Pg.Connection -> SqlSelect Postgres a\n          -> (CONDUIT_TRANSFORMER () a m () -> m b) -> m b\nrunSelect conn (SqlSelect (PgSelectSyntax syntax)) withSrc =\n  runQueryReturning conn syntax withSrc\n{-# DEPRECATED runSelect "Use streamingRunSelect" #-}\n\n\n-- * @INSERT@\n\n-- | Run a PostgreSQL @INSERT@ statement in any \'MonadIO\'. Returns the number of\n-- rows affected.\nrunInsert :: MonadIO m\n          => Pg.Connection -> SqlInsert Postgres tbl -> m Int64\nrunInsert _ SqlInsertNoRows = pure 0\nrunInsert conn (SqlInsert _ (PgInsertSyntax i)) =\n  executeStatement conn i\n\n-- | Run a PostgreSQL @INSERT ... RETURNING ...@ statement in any \'C.MonadResource\' and\n-- get a \'C.Source\' of the newly inserted rows.\nstreamingRunInsertReturning :: ( C.MonadResource m, Fail.MonadFail m, FromBackendRow Postgres a )\n                            => Pg.Connection\n                            -> PgInsertReturning a\n                            -> CONDUIT_TRANSFORMER () a m ()\nstreamingRunInsertReturning _ PgInsertReturningEmpty = pure ()\nstreamingRunInsertReturning conn (PgInsertReturning i) =\n    streamingRunQueryReturning conn i\n\n-- | Run a PostgreSQL @INSERT ... RETURNING ...@ statement in any \'MonadIO\' and\n-- get a \'C.Source\' of the newly inserted rows.\nrunInsertReturning :: ( MonadIO m, Fail.MonadFail m, MonadBaseControl IO m, FromBackendRow Postgres a )\n                   => Pg.Connection\n                   -> PgInsertReturning a\n                   -> (CONDUIT_TRANSFORMER () a m () -> m b)\n                   -> m b\nrunInsertReturning _ PgInsertReturningEmpty withSrc = withSrc (pure ())\nrunInsertReturning conn (PgInsertReturning i) withSrc =\n    runQueryReturning conn i withSrc\n{-# DEPRECATED runInsertReturning "Use streamingRunInsertReturning" #-}\n\n-- * @UPDATE@\n\n-- | Run a PostgreSQL @UPDATE@ statement in any \'MonadIO\'. Returns the number of\n-- rows affected.\nrunUpdate :: MonadIO m\n          => Pg.Connection -> SqlUpdate Postgres tbl -> m Int64\nrunUpdate _ SqlIdentityUpdate = pure 0\nrunUpdate conn (SqlUpdate _ (PgUpdateSyntax i)) =\n    executeStatement conn i\n\n-- | Run a PostgreSQL @UPDATE ... RETURNING ...@ statement in any \'C.MonadResource\' and\n-- get a \'C.Source\' of the newly updated rows.\nstreamingRunUpdateReturning :: ( C.MonadResource m, Fail.MonadFail m, FromBackendRow Postgres a)\n                            => Pg.Connection\n                            -> PgUpdateReturning a\n                            -> CONDUIT_TRANSFORMER () a m ()\nstreamingRunUpdateReturning _ PgUpdateReturningEmpty = pure ()\nstreamingRunUpdateReturning conn (PgUpdateReturning u) =\n  streamingRunQueryReturning conn u\n\n-- | Run a PostgreSQL @UPDATE ... RETURNING ...@ statement in any \'MonadIO\' and\n-- get a \'C.Source\' of the newly updated rows.\nrunUpdateReturning :: ( MonadIO m, Fail.MonadFail m, MonadBaseControl IO m, FromBackendRow Postgres a)\n                   => Pg.Connection\n                   -> PgUpdateReturning a\n                   -> (CONDUIT_TRANSFORMER () a m () -> m b)\n                   -> m b\nrunUpdateReturning _ PgUpdateReturningEmpty withSrc = withSrc (pure ())\nrunUpdateReturning conn (PgUpdateReturning u) withSrc =\n  runQueryReturning conn u withSrc\n{-# DEPRECATED runUpdateReturning "Use streamingRunUpdateReturning" #-}\n\n-- * @DELETE@\n\n-- | Run a PostgreSQL @DELETE@ statement in any \'MonadIO\'. Returns the number of\n-- rows affected.\nrunDelete :: MonadIO m\n          => Pg.Connection -> SqlDelete Postgres tbl\n          -> m Int64\nrunDelete conn (SqlDelete _ (PgDeleteSyntax d)) =\n    executeStatement conn d\n\n-- | Run a PostgreSQl @DELETE ... RETURNING ...@ statement in any\n-- \'C.MonadResource\' and get a \'C.Source\' of the deleted rows.\nstreamingRunDeleteReturning :: ( C.MonadResource m, Fail.MonadFail m, FromBackendRow Postgres a )\n                            => Pg.Connection -> PgDeleteReturning a\n                            -> CONDUIT_TRANSFORMER () a m ()\nstreamingRunDeleteReturning conn (PgDeleteReturning d) =\n  streamingRunQueryReturning conn d\n\n-- | Run a PostgreSQl @DELETE ... RETURNING ...@ statement in any\n-- \'MonadIO\' and get a \'C.Source\' of the deleted rows.\nrunDeleteReturning :: ( MonadIO m, Fail.MonadFail m, MonadBaseControl IO m, FromBackendRow Postgres a )\n                   => Pg.Connection -> PgDeleteReturning a\n                   -> (CONDUIT_TRANSFORMER () a m () -> m b) -> m b\nrunDeleteReturning conn (PgDeleteReturning d) withSrc =\n  runQueryReturning conn d withSrc\n{-# DEPRECATED runDeleteReturning "Use streamingRunDeleteReturning" #-}\n\n-- * Convenience functions\n\n-- | Run any DML statement. Return the number of rows affected\nexecuteStatement ::  MonadIO m => Pg.Connection -> PgSyntax -> m Int64\nexecuteStatement conn x =\n  liftIO $ do\n    syntax <- pgRenderSyntax conn x\n    Pg.execute_ conn (Pg.Query syntax)\n\n\n-- | Runs any query that returns a set of values\nstreamingRunQueryReturning\n  :: ( C.MonadResource m, Fail.MonadFail m, FromBackendRow Postgres r )\n  => Pg.Connection -> PgSyntax\n  -> CONDUIT_TRANSFORMER () r m ()\nstreamingRunQueryReturning (conn@Pg.Connection {connectionHandle}) x = do\n  syntax <- liftIO $ pgRenderSyntax conn x\n  -- We need to own the connection for the duration of the conduit\'s\n  -- lifetime, since it will be in a streaming state until we clean up\n  C.bracketP\n    (takeMVar connectionHandle)\n    (putMVar connectionHandle)\n    (\\conn\' -> do\n      success <- liftIO $\n        if Pg.isNullConnection conn\'\n        then throwIO Pg.disconnectedError\n        else Pg.sendQuery conn\' syntax\n\n      if success\n        then do\n          singleRowModeSet <- liftIO $ Pg.setSingleRowMode conn\'\n          if singleRowModeSet\n            then\n              C.bracketP\n                (pure ())\n                (\\_ -> gracefulShutdown conn\')\n                (\\_ -> streamResults conn conn\' Nothing)\n            else Fail.fail "Could not enable single row mode"\n        else do\n          errMsg <- fromMaybe "No libpq error provided" <$> liftIO (Pg.errorMessage conn\')\n          Fail.fail (show errMsg))\n\nstreamResults :: (Fail.MonadFail m, FromBackendRow Postgres r, MonadIO m) => Pg.Connection -> Pq.Connection -> Maybe [Pg.Field] -> C.ConduitT i r m ()\nstreamResults (conn@Pg.Connection {connectionHandle}) conn\' fields = do\n  nextRow <- liftIO (Pg.getResult conn\')\n  case nextRow of\n    Nothing -> pure ()\n    Just row ->\n      liftIO (Pg.resultStatus row) >>=\n      \\case\n        Pg.SingleTuple ->\n          do fields\' <- liftIO (maybe (getFields row) pure fields)\n             parsedRow <- liftIO $ bracket\n               (putMVar connectionHandle conn\')\n               (\\_ -> takeMVar connectionHandle)\n               (\\_ -> runPgRowReader conn 0 row fields\' fromBackendRow)\n             case parsedRow of\n               Left err -> liftIO (bailEarly conn\' row ("Could not read row: " <> show err))\n               Right parsedRow\' ->\n                 do C.yield parsedRow\'\n                    streamResults conn conn\' (Just fields\')\n        Pg.TuplesOk -> liftIO (finishQuery conn\')\n        Pg.EmptyQuery -> Fail.fail "No query"\n        Pg.CommandOk -> pure ()\n        status@Pg.BadResponse -> liftIO (Pg.throwResultError "streamResults" row status)\n        status@Pg.NonfatalError -> liftIO (Pg.throwResultError "streamResults" row status)\n        status@Pg.FatalError -> liftIO (Pg.throwResultError "streamResults" row status)\n        _ -> do errMsg <- liftIO (Pg.resultErrorMessage row)\n                Fail.fail ("Postgres error: " <> show errMsg)\n\nbailEarly :: Pq.Connection -> Pg.Result -> String -> IO a\nbailEarly conn\' row errorString = do\n  Pg.unsafeFreeResult row\n  cancelQuery conn\'\n  Fail.fail errorString\n\ncancelQuery :: Pq.Connection -> IO ()\ncancelQuery conn\' = do\n  cancel <- Pg.getCancel conn\'\n  case cancel of\n    Nothing -> pure ()\n    Just cancel\' -> do\n      res <- Pg.cancel cancel\'\n      case res of\n        Right () -> liftIO (finishQuery conn\')\n        Left err -> Fail.fail ("Could not cancel: " <> show err)\n\nfinishQuery :: Pq.Connection -> IO ()\nfinishQuery conn\' = do\n  nextRow <- Pg.getResult conn\'\n  case nextRow of\n    Nothing -> pure ()\n    Just _ -> finishQuery conn\'\n\ngracefulShutdown :: Pq.Connection -> IO ()\ngracefulShutdown conn\' = do\n  sts <- Pg.transactionStatus conn\'\n  case sts of\n    Pg.TransIdle -> pure ()\n    Pg.TransInTrans -> pure ()\n    Pg.TransInError -> pure ()\n    Pg.TransUnknown -> pure ()\n    Pg.TransActive -> cancelQuery conn\'\n\n-- | Runs any query that returns a set of values\nrunQueryReturning\n  :: ( MonadIO m, Fail.MonadFail m, MonadBaseControl IO m, Functor m, FromBackendRow Postgres r )\n  => Pg.Connection -> PgSyntax\n  -> (CONDUIT_TRANSFORMER () r m () -> m b)\n  -> m b\nrunQueryReturning (conn@Pg.Connection {connectionHandle}) x withSrc = do\n  syntax <- liftIO $ pgRenderSyntax conn x\n\n  Lifted.bracket\n    (Lifted.takeMVar connectionHandle)\n    (Lifted.putMVar connectionHandle)\n    (\\conn\' -> do\n      success <- liftIO $ Pg.sendQuery conn\' syntax\n      if success\n        then do\n          singleRowModeSet <- liftIO (Pg.setSingleRowMode conn\')\n          if singleRowModeSet\n             then withSrc (streamResults conn conn\' Nothing) `finally` (liftIO $ gracefulShutdown conn\')\n             else Fail.fail "Could not enable single row mode"\n        else do\n          errMsg <- fromMaybe "No libpq error provided" <$> liftIO (Pg.errorMessage conn\')\n          Fail.fail (show errMsg))\n{-# DEPRECATED runQueryReturning "Use streamingRunQueryReturning" #-}\n'