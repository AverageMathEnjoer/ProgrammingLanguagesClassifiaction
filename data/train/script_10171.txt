b'module Database.Beam.Migrate.Tool.Diff where\n\nimport           Prelude hiding (pred)\n\nimport           Database.Beam hiding (timestamp)\nimport           Database.Beam.Migrate hiding (p)\n\nimport           Database.Beam.Migrate.Backend\nimport           Database.Beam.Migrate.Log\nimport           Database.Beam.Migrate.Tool.Backend\nimport           Database.Beam.Migrate.Tool.CmdLine\nimport           Database.Beam.Migrate.Tool.Registry\n\nimport           Control.Exception\nimport           Control.Monad\n\nimport qualified Data.HashSet as HS\n\nimport           Data.Text (Text)\nimport qualified Data.Text as T\nimport           Data.UUID (UUID)\n\nimport           Text.Read\n\ndata NoRecordedSchemas = NoRecordedSchemas\n  deriving Show\ninstance Exception NoRecordedSchemas\n\ndata CouldNotFetchLog = CouldNotFetchLog DdlError\n  deriving Show\ninstance Exception CouldNotFetchLog\n\ndata CouldNotFetchConstraints = CouldNotFetchConstraints DdlError\n  deriving Show\ninstance Exception CouldNotFetchConstraints\n\ndata PredicateDiff\n  = PredicateDiff\n  { predicateDiffExpected :: HS.HashSet SomeDatabasePredicate\n  , predicateDiffActual :: HS.HashSet SomeDatabasePredicate\n  } deriving Show\n\npredicateDiffMissing, predicateDiffExtra :: PredicateDiff -> HS.HashSet SomeDatabasePredicate\npredicateDiffMissing (PredicateDiff expected actual) =\n  expected `HS.difference` actual\npredicateDiffExtra (PredicateDiff expected actual) =\n  actual `HS.difference` expected\n\ngenDiff :: MigrateCmdLine -> MigrationRegistry\n        -> Text -> Text\n        -> IO (ModuleName, PredicateDiff)\ngenDiff cmdLine reg actualSpec expSpec = do\n\n  actualSource <- parsePredicateFetchSourceSpec cmdLine reg actualSpec\n  expSource <- parsePredicateFetchSourceSpec cmdLine reg expSpec\n\n  be <-\n    case ( predicateFetchSourceBackend actualSource\n         , predicateFetchSourceBackend expSource ) of\n      (Nothing, Nothing) ->\n        fail "Predicate sources do not specify a backend"\n      (Just be, Nothing) -> pure be\n      (Nothing, Just be) -> pure be\n      (Just be, Just be\')\n        | be == be\' -> pure be\n        | otherwise -> fail ("Cannot compare schemas from two different backends: " ++ show (be, be\'))\n\n  (be,) <$> genDiffFromSources cmdLine reg (predicateSourceWithBackend be actualSource)\n                                           (predicateSourceWithBackend be expSource)\n\ngenDiffFromSources :: MigrateCmdLine -> MigrationRegistry\n                   -> PredicateFetchSource\n                   -> PredicateFetchSource\n                   -> IO PredicateDiff\ngenDiffFromSources cmdLine reg actualSource expSource =\n  do (_, actual)   <- getPredicatesFromSpec cmdLine reg actualSource\n     (_, expected) <- getPredicatesFromSpec cmdLine reg expSource\n\n     pure (PredicateDiff (HS.fromList expected) (HS.fromList actual))\n\nfilterBeamMigratePreds :: SomeBeamMigrationBackend -> [SomeDatabasePredicate] -> [SomeDatabasePredicate]\nfilterBeamMigratePreds (SomeBeamMigrationBackend (BeamMigrationBackend {} :: BeamMigrationBackend be m)) preds =\n  let beamMigrateDbSchema = collectChecks (beamMigratableDb @be @m)\n  in foldr (\\pred@(SomeDatabasePredicate pred\') preds\' ->\n              if pred `elem` preds\'\n              then filter (\\p@(SomeDatabasePredicate p\') -> p /= pred && not (predicateCascadesDropOn p\' pred\')) preds\'\n              else preds\')\n           preds beamMigrateDbSchema\n\ngetPredicatesFromSpec :: MigrateCmdLine -> MigrationRegistry\n                      -> PredicateFetchSource\n                      -> IO (Maybe UUID, [ SomeDatabasePredicate ])\ngetPredicatesFromSpec _ _ (PredicateFetchSourceCommit Nothing _) = fail "No backend to read commit with"\ngetPredicatesFromSpec cmdLine reg (PredicateFetchSourceCommit (Just modName) commitId) = do\n  SomeBeamMigrationBackend be <- loadBackend\' cmdLine modName\n\n  SchemaMetaData _ _ _ (Schema preds) <- readSchemaMetaData reg be commitId\n\n  let applicablePreds = predsForBackend be preds\n  pure (Just commitId, applicablePreds)\ngetPredicatesFromSpec cmdLine reg (PredicateFetchSourceDbHead (MigrationDatabase modName connStr) ref) = do\n  be@(SomeBeamMigrationBackend\n      (BeamMigrationBackend { backendGetDbConstraints = getCs\n                            , backendTransact = transact } ::\n          BeamMigrationBackend be m)) <-\n    loadBackend\' cmdLine modName\n\n  case ref of\n    Nothing -> do\n      cs <- transact connStr getCs\n      case cs of\n        Left err -> throwIO (CouldNotFetchConstraints err)\n        Right cs\' -> pure (Nothing, filterBeamMigratePreds be cs\')\n    Just fromHead -> do\n      logEntry <- transact connStr $\n                  runSelectReturningOne $ select $\n                  limit_ 1 $ offset_ (fromIntegral fromHead) $\n                  orderBy_ (desc_ . _logEntryId) $\n                  all_ (_beamMigrateLogEntries (beamMigrateDb @be @m))\n\n      case logEntry of\n        Left err -> throwIO (CouldNotFetchLog err)\n        Right Nothing -> throwIO NoRecordedSchemas\n        Right (Just logEntry\') ->\n          case readMaybe (T.unpack (_logEntryCommitId logEntry\')) of\n            Nothing -> throwIO (InvalidCommitId (_logEntryCommitId logEntry\'))\n            Just commitId ->\n              getPredicatesFromSpec cmdLine reg (PredicateFetchSourceCommit (Just modName) commitId)\ngetPredicatesFromSpec _ _ PredicateFetchSourceEmpty = pure (Nothing, [])\n\ndisplayDiff :: MigrateCmdLine\n            -> Text -> Text\n            -> Bool -> IO ()\ndisplayDiff cmdLine expected actual autogen = do\n  reg <- lookupRegistry cmdLine\n\n  (backendMod, diff) <- genDiff cmdLine reg actual expected\n\n  let missing = predicateDiffMissing diff\n      extra = predicateDiffExtra diff\n\n  if autogen\n    then displayScript cmdLine backendMod diff\n    else\n      if HS.null extra && HS.null missing\n      then putStrLn "Schemas match"\n      else do\n        when (not (HS.null extra)) $ do\n          putStrLn "The following constraints are extraneous:"\n          forM_ extra $ \\(SomeDatabasePredicate p\') ->\n            putStrLn ("  - " ++ englishDescription p\')\n        when (not (HS.null missing)) $ do\n          putStrLn "The following constraints are missing:"\n          forM_ missing $ \\(SomeDatabasePredicate p\') ->\n            putStrLn ("  - " ++ englishDescription p\')\n\ndisplayScript :: MigrateCmdLine -> ModuleName -> PredicateDiff -> IO ()\ndisplayScript cmdLine modName (PredicateDiff dest from) = do\n  SomeBeamMigrationBackend BeamMigrationBackend\n    { backendActionProvider = actionProvider\n    , backendRenderSyntax = renderCmd } <- loadBackend\' cmdLine modName\n\n  let solver = heuristicSolver actionProvider (HS.toList from) (HS.toList dest)\n\n  case finalSolution solver of\n    Candidates {} -> fail "Could not find appropriate migration between schemas."\n    Solved cmds ->\n      putStrLn (unlines (map (renderCmd . migrationCommand) cmds))\n'