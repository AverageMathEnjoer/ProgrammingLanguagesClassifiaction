b'\xef\xbb\xbfusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;\n\nnamespace Aerial\n{\n    public static class AssemblyVersion\n    {\n        /// <summary>\n        /// Gets the executing assembly.\n        /// </summary>\n        /// <value>The executing assembly.</value>\n        public static System.Reflection.Assembly ExecutingAssembly\n        {\n            get { return executingAssembly ?? (executingAssembly = System.Reflection.Assembly.GetExecutingAssembly()); }\n        }\n\n        private static System.Reflection.Assembly executingAssembly;\n\n        /// <summary>\n        /// Gets the executing assembly version.\n        /// </summary>\n        /// <value>The executing assembly version.</value>\n        public static System.Version ExecutingAssemblyVersion\n        {\n            get { return executingAssemblyVersion ?? (executingAssemblyVersion = ExecutingAssembly.GetName().Version); }\n        }\n        private static System.Version executingAssemblyVersion;\n\n        /// <summary>\n        /// Gets the compile date of the currently executing assembly.\n        /// </summary>\n        /// <value>The compile date.</value>\n        public static System.DateTime CompileDate\n        {\n            get\n            {\n                if (!compileDate.HasValue)\n                    compileDate = RetrieveLinkerTimestamp(ExecutingAssembly.Location);\n                return compileDate ?? new System.DateTime();\n            }\n        }\n        private static System.DateTime? compileDate;\n\n        /// <summary>\n        /// Retrieves the linker timestamp.\n        /// </summary>\n        /// <param name="filePath">The file path.</param>\n        /// <returns></returns>\n        /// <remarks>http://www.codinghorror.com/blog/2005/04/determining-build-date-the-hard-way.html</remarks>\n        private static System.DateTime RetrieveLinkerTimestamp(string filePath)\n        {\n            const int peHeaderOffset = 60;\n            const int linkerTimestampOffset = 8;\n            var b = new byte[2048];\n            System.IO.FileStream s = null;\n            try\n            {\n                s = new System.IO.FileStream(filePath, System.IO.FileMode.Open, System.IO.FileAccess.Read);\n                s.Read(b, 0, 2048);\n            }\n            finally\n            {\n                if (s != null)\n                    s.Close();\n            }\n            var dt = new DateTime(1970, 1, 1, 0, 0, 0).AddSeconds(BitConverter.ToInt32(b, BitConverter.ToInt32(b, peHeaderOffset) + linkerTimestampOffset));\n            return dt.AddHours(TimeZone.CurrentTimeZone.GetUtcOffset(dt).Hours);\n        }\n    }\n}\n'