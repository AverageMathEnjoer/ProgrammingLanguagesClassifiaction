b'// UVa1218 Perfect Service\n// Rujia Liu\n#include<cstdio>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nconst int maxn = 10000 + 5;\nconst int INF = 1000000000;\n\nvector<int> G[maxn], vertices;\nint p[maxn], d[maxn][3];\n\n// build a rooted tree and dfs sequence\nvoid dfs(int u, int fa) {\n  vertices.push_back(u);\n  p[u] = fa;\n  for(int i = 0; i < G[u].size(); i++) {\n    int v = G[u][i];\n    if(v != fa) dfs(v, u);\n  }\n}\n\nint main() {\n  int n;\n  while(scanf("%d", &n) == 1) {\n    for(int i = 0; i < n; i++) G[i].clear();\n    for(int i = 0; i < n-1; i++) {\n      int u, v;\n      scanf("%d%d", &u, &v); u--; v--;\n      G[u].push_back(v);\n      G[v].push_back(u);\n    }\n    vertices.clear();\n    dfs(0, -1);\n    for(int i = vertices.size()-1; i >= 0; i--) {\n      int u = vertices[i];\n      d[u][0] = 1; d[u][1] = 0;\n      for(int j = 0; j < G[u].size(); j++) {\n        int v = G[u][j];\n        if(v == p[u]) continue;\n        d[u][0] += min(d[v][0], d[v][1]); // u is server\n        d[u][1] += d[v][2]; // u is not server, u\'s father is server\n        if(d[u][0] > INF) d[u][0] = INF; // avoid overflow!\n        if(d[u][1] > INF) d[u][1] = INF;\n      }\n      d[u][2] = INF;\n      for(int j = 0; j < G[u].size(); j++) {\n        int v = G[u][j];\n        if(v == p[u]) continue;\n        d[u][2] = min(d[u][2], d[u][1] - d[v][2] + d[v][0]); // neither u or father is server\n      }\n    }\n    printf("%d\\n", min(d[0][0], d[0][2]));\n    scanf("%d", &n); // flag\n  }\n  return 0;\n}\n'