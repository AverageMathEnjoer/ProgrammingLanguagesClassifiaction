b'module Main where\n\nimport Control.DeepSeq (NFData, rnf)\nimport Control.Exception (evaluate)\nimport Data.Array (assocs, bounds)\nimport System.Random (mkStdGen, randomRs)\nimport Test.Tasty.Bench (Benchmark, Benchmarkable, bench, bgroup, defaultMain, nf)\nimport qualified Data.Graph as G\n\nmain :: IO ()\nmain = do\n  evaluate $ rnf allGs\n  defaultMain\n    [ bgroup "buildG" $ forGs allGs $ \\g -> nf (G.buildG (bounds (getG g))) (getEdges g)\n    , bgroup "graphFromEdges" $ forGs allGs $ nf ((\\(g, _, _) -> g) . G.graphFromEdges) . getAdjList\n    , bgroup "transposeG" $ forGs allGs $ nf G.transposeG . getG\n    , bgroup "dfs" $ forGs allGs $ nf (flip G.dfs [1]) . getG\n    , bgroup "dff" $ forGs allGs $ nf G.dff . getG\n    , bgroup "topSort" $ forGs allGs $ nf G.topSort . getG\n    , bgroup "scc" $ forGs allGs $ nf G.scc . getG\n    , bgroup "bcc" $ forGs allGs $ nf G.bcc . getG\n    , bgroup "stronglyConnCompR" $ forGs allGs $ nf G.stronglyConnCompR . getAdjList\n    ]\n  where\n    allGs = randGs ++ starGs ++ lineGs ++ maxDAGs\n    randGs = map (uncurry buildRandG) [(100, 1000), (100, 10000), (10000, 100000), (100000, 1000000)]\n    starGs = map buildStarG [100, 1000000]\n    lineGs = map buildLineG [100, 1000000]\n    maxDAGs = map buildMaxDAG [15, 1500]\n\n-- Note: In practice it does not make sense to run topSort or bcc on a random\n-- graph. For topSort the graph should be acyclic and for bcc the graph should\n-- be undirected. But these functions don\'t check or depend on these properties,\n-- so we can keep things simple and run them on random graphs in benchmarks.\n\nforGs :: [Graph] -> (Graph -> Benchmarkable) -> [Benchmark]\nforGs gs f = [bench (getLabel g) (f g) | g <- gs]\n\ndata Graph = Graph\n  { getLabel :: String\n  , getG :: G.Graph\n  , getEdges :: [(G.Vertex, G.Vertex)]\n  , getAdjList :: [(Int, G.Vertex, [G.Vertex])]\n  }\n\ninstance NFData Graph where\n  rnf (Graph label g edges adj) = rnf label `seq` rnf g `seq` rnf edges `seq` rnf adj\n\n-- Makes a Graph for benchmarks, from a label, vertex bounds, and the edge list.\nmakeG :: String -> G.Bounds -> [G.Edge] -> Graph\nmakeG label bnds edges =\n  let g = G.buildG bnds edges\n  in Graph label g edges [(u, u, vs) | (u, vs) <- assocs g]\n\n-- A graph with vertices [1..n] and m random edges.\nbuildRandG :: Int -> Int -> Graph\nbuildRandG n m = makeG label (1, n) edges\n  where\n    label = "rand,n=" ++ show n ++ ",m=" ++ show m\n    xs = randomRs (1, n) (mkStdGen 1)\n    (us, xs\') = splitAt m xs\n    vs = take m xs\'\n    edges = zip us vs\n\n-- A star graph, i.e. a graph with an edge from vertex 1 to every other vertex.\n-- This serves as an extreme case of a "wide" graph.\nbuildStarG :: Int -> Graph\nbuildStarG n = makeG label (1, n) [(1, i) | i <- [2..n]]\n  where\n    label = "star,n=" ++ show n\n\n-- A line graph, i.e. a graph with an edge from every vertex i to i+1. This\n-- serves an as extreme case of a "deep" graph.\nbuildLineG :: Int -> Graph\nbuildLineG n = makeG label (1, n) (zip [1..n-1] [2..])\n  where\n    label = "line,n=" ++ show n\n\n-- A maximal DAG. There is an edge from vertex i to j for every i, j when i < j.\n-- The number of edges is n * (n - 1) / 2.\nbuildMaxDAG :: Int -> Graph\nbuildMaxDAG n = makeG label (1, n) [(i, j) | i <- [1 .. n-1], j <- [i+1 .. n]]\n  where\n    label = "maxDAG,n=" ++ show n\n'