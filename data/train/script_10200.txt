b'#include <bits/stdc++.h>\n// #include "stdafx.h"\n// #pragma warning(disable : 4996) //_CRT_SECURE_NO_WARNINGS\nusing namespace std;\n#define gc getchar_unlocked\n#define fo(i,n) for(i=0;i<n;i++)\n#define Fo(i,k,n) for(i=k;k<n?i<n:i>n;k<n?i+=1:i-=1)\n#define ll long long\n#define si(x)\tscanf("%d",&x)\n#define sl(x)\tscanf("%lld",&x)\n#define ss(s)\tscanf("%s",s)\n#define pi(x)\tprintf("%d\\n",x)\n#define pl(x)\tprintf("%lld\\n",x)\n#define ps(s)\tprintf("%s\\n",s)\n#define deb(x) cout << #x << "=" << x << endl\n#define deb2(x, y) cout << #x << "=" << x << "," << #y << "=" << y << endl\n#define pb push_back\n#define mp make_pair\n#define F first\n#define S second\n#define all(x) x.begin(), x.end()\n#define clr(x) memset(x, 0, sizeof(x))\n#define sortall(x) sort(all(x))\n#define tr(it, a) for(auto it = a.begin(); it != a.end(); it++)\n#define PI 3.1415926535897932384626\ntypedef pair<int, int>\tpii;\ntypedef pair<ll, ll>\tpl;\ntypedef vector<int>\t\tvi;\ntypedef vector<ll>\t\tvl;\ntypedef vector<pii>\t\tvpii;\ntypedef vector<pl>\t\tvpl;\ntypedef vector<vi>\t\tvvi;\ntypedef vector<vl>\t\tvvl;\nint mpow(int base, int exp); \nvoid ipgraph(int m);\nvoid dfs(int u, int par);\nconst int mod = 1000000007;\nconst int N = 2e6, M = N;\n//=======================\nstruct node{\n\tll ans;\n\tint left, right, len;\n\tvoid leaf(int val){\n\t\tans = left = right = val;\n\t\tlen = 1;\n\t}\n\t\n\tvoid merge(node r, node l){\n\t\tans = r.ans + l.ans;\n\t\tlen = r.len + l.len;\n\t\t\n\t\tans += l.right * 1LL * r.left;\n\t\t\n\t\tleft = l.left;\n\t\tright = r.right;\n\t\t\n\t\tif(l.left == l.len) left += r.left;\n\t\tif(r.right == r.len) right += l.right;\n\t}\t\n\t\n};\nclass st{\n\tint n;\n\tnode* T;\n\tint* a;\n\tpublic:\n\t#define l(x) 2*x\n\t#define r(x) 2*x+1\n\t#define lpart left, lo, mid\n\t#define rpart right, mid+1, hi\n\tst() {}\n\tst(int x){\n\t\ta = new int[x];\n\t\tfor(int i = 0; i < x; i++) a[i] = 1;\n\t\tn = 1;\n\t\twhile(n <= x) n *= 2; n *= 2;\n\t\tT = new node[n];\n\t\tn = x;\n\t\tbuild(1, 0, n-1);\n\t}\n\tst(int *arr, int x){\n\t\ta = arr;\n\t\tn = 1;\n\t\twhile(n <= x) n *= 2; n *= 2;\n\t\tT = new node[n];\n\t\tn = x;\n\t\tbuild(1, 0, n-1);\n\t}\n\tvoid build(int id, int lo, int hi){\n\t\tif(lo == hi){\n\t\t\tT[id].leaf(a[lo]);\n\t\t\treturn;\n\t\t}\n\t\tint left = l(id), right = r(id), mid = (lo+hi)/2;\n\t\tbuild(lpart);\n\t\tbuild(rpart);\n\t\tT[id].merge(T[left], T[right]);\n\t}\n\tvoid update(int pos, int val){\n\t\tupdate(1, 0, n-1, pos, val);\n\t}\n\tvoid update(int id, int lo, int hi, int pos, int val){\n\t\tif(lo==hi and lo==pos){\n\t\t\ta[pos] = val;\n\t\t\tT[id].leaf(a[lo]);\n\t\t\treturn;\n\t\t}\n\t\tint left = l(id), right = r(id), mid = (lo+hi)/2;\n\t\tif(pos <= mid) update(lpart, pos, val);\n\t\telse update(rpart, pos, val);\n\t\tT[id].merge(T[left], T[right]);\n\t}\n\tll query(int x, int y){\n\t\treturn query(1, 0, n-1, x, y).ans;\n\t}\n\tnode query(int id, int lo, int hi, int x, int y){\n\t\tif(lo==x and hi==y){\n\t\t\treturn T[id];\n\t\t}\n\t\tint left = l(id), right = r(id), mid = (lo+hi)/2;\n\t\tif(y <= mid) return query(lpart, x, y);\n\t\telse if(x>mid) return query(rpart, x, y);\n\t\tnode L = query(lpart, x, mid);\n\t\tnode R = query(rpart, mid+1, y);\n\t\tnode res;\n\t\tres.merge(L, R);\n\t\treturn res;\n\t}\n};\n\nvi g[N];\nint a[N];\n\nint main()\n{\n\tios_base::sync_with_stdio(false);\n\tcin.tie(NULL);\n\tint i,n,k,j;\n\tint q, L, R, type, l, r, x, y;\n\tcin >> n >> q >> L >> R;\n\t\n\tL--;\n\t\n\tst A(n), B(n);\n\t\n\twhile(q--){\n\t\tcin >> type >> l >> r;\n\t\tif(type == 1){\n\t\t\tl--;\n\t\t\t//a[l] = r;\n\t\t\tif(r <= L) A.update(l, 1);\n\t\t\telse A.update(l, 0);\n\t\t\t\n\t\t\tif(r <= R) B.update(l, 1);\n\t\t\telse B.update(l, 0);\n\t\t}\n\t\telse{\n\t\t\tl--; r--;\n\t\t\tcout << B.query(l, r) - A.query(l, r) << endl;\n\t\t}\n\t\t\n\t}\n\treturn 0;\n} \n\n/* INPUT:\n5 6 1 10\n1 1 2\n2 1 5 \n1 3 11\n1 4 3\n2 3 5\n2 1 5\n*/\n'