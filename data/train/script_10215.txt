b'using System;\nusing System.Runtime;\nusing System.Runtime.InteropServices;\n\n#region A couple very basic things\nnamespace System\n{\n    public class Object\n    {\n#pragma warning disable 169\n        // The layout of object is a contract with the compiler.\n        private IntPtr m_pMethodTable;\n#pragma warning restore 169\n    }\n    public struct Void { }\n\n    // The layout of primitive types is special cased because it would be recursive.\n    // These really don\'t need any fields to work.\n    public struct Boolean { }\n    public struct Char { }\n    public struct SByte { }\n    public struct Byte { }\n    public struct Int16 { }\n    public struct UInt16 { }\n    public struct Int32 { }\n    public struct UInt32 { }\n    public struct Int64 { }\n    public struct UInt64 { }\n    public struct IntPtr { }\n    public struct UIntPtr { }\n    public struct Single { }\n    public struct Double { }\n\n    public abstract class ValueType { }\n    public abstract class Enum : ValueType { }\n\n    public struct Nullable<T> where T : struct { }\n    \n    public sealed class String { public readonly int Length; }\n    public abstract class Array { }\n    public abstract class Delegate { }\n    public abstract class MulticastDelegate : Delegate { }\n\n    public struct RuntimeTypeHandle { }\n    public struct RuntimeMethodHandle { }\n    public struct RuntimeFieldHandle { }\n\n    public class Attribute { }\n\n    public enum AttributeTargets { }\n\n    public sealed class AttributeUsageAttribute : Attribute\n    {\n        public AttributeUsageAttribute(AttributeTargets validOn) { }\n        public bool AllowMultiple { get; set; }\n        public bool Inherited { get; set; }\n    }\n\n    public class AppContext\n    {\n        public static void SetData(string s, object o) { }\n    }\n\n    namespace Runtime.CompilerServices\n    {\n        public class RuntimeHelpers\n        {\n            public static unsafe int OffsetToStringData => sizeof(IntPtr) + sizeof(int);\n        }\n    }\n}\nnamespace System.Runtime.InteropServices\n{\n    public sealed class DllImportAttribute : Attribute\n    {\n        public DllImportAttribute(string dllName) { }\n    }\n}\n#endregion\n\n#region Things needed by ILC\nnamespace System\n{\n    namespace Runtime\n    {\n        internal sealed class RuntimeExportAttribute : Attribute\n        {\n            public RuntimeExportAttribute(string entry) { }\n        }\n    }\n\n    class Array<T> : Array { }\n}\n\nnamespace Internal.Runtime.CompilerHelpers\n{\n    // A class that the compiler looks for that has helpers to initialize the\n    // process. The compiler can gracefully handle the helpers not being present,\n    // but the class itself being absent is unhandled. Let\'s add an empty class.\n    class StartupCodeHelpers\n    {\n        // A couple symbols the generated code will need we park them in this class\n        // for no particular reason. These aid in transitioning to/from managed code.\n        // Since we don\'t have a GC, the transition is a no-op.\n        [RuntimeExport("RhpReversePInvoke")]\n        static void RhpReversePInvoke(IntPtr frame) { }\n        [RuntimeExport("RhpReversePInvokeReturn")]\n        static void RhpReversePInvokeReturn(IntPtr frame) { }\n        [RuntimeExport("RhpPInvoke")]\n        static void RhpPInvoke(IntPtr frame) { }\n        [RuntimeExport("RhpPInvokeReturn")]\n        static void RhpPInvokeReturn(IntPtr frame) { }\n\n        [RuntimeExport("RhpFallbackFailFast")]\n        static void RhpFallbackFailFast() { while (true) ; }\n    }\n}\n#endregion\n\nunsafe class Program\n{\n    [DllImport("libc")]\n    static extern int printf(byte* fmt);\n\n    [DllImport("kernel32")]\n    static extern IntPtr GetStdHandle(int nStdHandle);\n\n    [DllImport("kernel32")]\n    static extern IntPtr WriteConsoleW(IntPtr hConsole, void* lpBuffer, int charsToWrite, out int charsWritten, void* reserved);\n\n#if !WINDOWS\n    // Export this as "main" so that we can link with the C runtime library properly.\n    // If the C runtime library is not initialized we can\'t even printf.\n    // This is not needed on Windows because we don\'t call the C runtime.\n    [RuntimeExport("main")]\n#endif\n    static int Main()\n    {\n        string hello = "Hello world!\\n";\n        fixed (char* pHello = hello)\n        {\n#if WINDOWS\n            WriteConsoleW(GetStdHandle(-11), pHello, hello.Length, out int _, null);\n#else\n            // Once C# has support for UTF-8 string literals, this can be simplified.\n            // https://github.com/dotnet/csharplang/issues/2911\n            // Since we don\'t have that, convert from UTF-16 to ASCII.\n            byte* pHelloASCII = stackalloc byte[hello.Length + 1];\n            for (int i = 0; i < hello.Length; i++)\n                pHelloASCII[i] = (byte)pHello[i];\n\n            printf(pHelloASCII);\n#endif\n        }\n\n        return 42;\n    }\n}\n'