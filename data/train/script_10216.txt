b'{-# LANGUAGE Rank2Types #-}\n-- |\n-- Copyright  : (c) Ivan Perez and Manuel Baerenz, 2016\n-- License    : BSD3\n-- Maintainer : ivan.perez@keera.co.uk\n--\n-- Monadic Stream Functions are synchronized stream functions with side\n-- effects.\n--\n-- \'MSF\'s are defined by a function\n-- @unMSF :: MSF m a b -> a -> m (b, MSF m a b)@\n-- that executes one step of a simulation, and produces an output in a monadic\n-- context, and a continuation to be used for future steps.\n--\n-- \'MSF\'s are a generalisation of the implementation mechanism used by Yampa,\n-- Wormholes and other FRP and reactive implementations.\n--\n-- This modules defines only the minimal core. By default, you should import\n-- "Data.MonadicStreamFunction.Core" or "Data.MonadicStreamFunction" whenever\n-- possible, and define your functions without accessing the MSF constuctor.\n-- Those modules, as well as other modules in dunai, also provide convenient\n-- instances. This module may be useful if you are extending dunai with\n-- functionality that cannot be (conveniently) expressed using the existing\n-- high-level API.\n\n-- NOTE TO IMPLEMENTORS:\n--\n-- This module contains the core. Only the core. It should be possible to\n-- define every function and type outside this module, except for the instances\n-- for ArrowLoop, ArrowChoice, etc., without access to the internal constructor\n-- for MSF and the function \'unMSF\'.\n--\n-- It\'s very hard to know what IS essential to framework and if we start adding\n-- all the functions and instances that *may* be useful in one module.\n--\n-- By separating some instances and functions in other modules, we can easily\n-- understand what is the essential idea and then analyse how it is affected by\n-- an extension. It also helps demonstrate that something works for MSFs +\n-- ArrowChoice, or MSFs + ArrowLoop, etc.\n--\n-- To address potential violations of basic design principles (like \'not having\n-- orphan instances\'), the main module Data.MonadicStreamFunction exports\n-- everything. Users should *never* import this module here individually, but\n-- the main module instead.\nmodule Data.MonadicStreamFunction.InternalCore where\n\n-- External imports\nimport Control.Category (Category (..))\nimport Prelude          hiding (id, sum, (.))\n\n-- * Definitions\n\n-- | Stepwise, side-effectful \'MSF\'s without implicit knowledge of time.\n--\n-- \'MSF\'s should be applied to streams or executed indefinitely or until they\n-- terminate. See \'reactimate\' and \'reactimateB\' for details. In general,\n-- calling the value constructor \'MSF\' or the function \'unMSF\' is discouraged.\ndata MSF m a b = MSF { unMSF :: a -> m (b, MSF m a b) }\n\n-- Instances\n\n-- | Instance definition for \'Category\'. Defines \'id\' and \'.\'.\ninstance Monad m => Category (MSF m) where\n  id = go\n    where\n      go = MSF $ \\a -> return (a, go)\n\n  sf2 . sf1 = MSF $ \\a -> do\n    (b, sf1\') <- unMSF sf1 a\n    (c, sf2\') <- unMSF sf2 b\n    let sf\' = sf2\' . sf1\'\n    c `seq` return (c, sf\')\n\n-- * Monadic computations and \'MSF\'s\n\n-- | Generic lifting of a morphism to the level of \'MSF\'s.\n--\n-- Natural transformation to the level of \'MSF\'s.\n--\n-- __Mathematical background:__ The type @a -> m (b, c)@ is a functor in @c@,\n-- and @MSF m a b@ is its greatest fixpoint, i.e. it is isomorphic to the type\n-- @a -> m (b, MSF m a b)@, by definition. The types @m@, @a@ and @b@ are\n-- parameters of the functor. Taking a fixpoint is functorial itself, meaning\n-- that a morphism (a natural transformation) of two such functors gives a\n-- morphism (an ordinary function) of their fixpoints.\n--\n-- This is in a sense the most general "abstract" lifting function, i.e. the\n-- most general one that only changes input, output and side effect types, and\n-- doesn\'t influence control flow. Other handling functions like exception\n-- handling or \'ListT\' broadcasting necessarily change control flow.\nmorphGS :: Monad m2\n        => (forall c . (a1 -> m1 (b1, c)) -> (a2 -> m2 (b2, c)))\n          -- ^ The natural transformation. @mi@, @ai@ and @bi@ for @i = 1, 2@\n          --   can be chosen freely, but @c@ must be universally quantified\n        -> MSF m1 a1 b1\n        -> MSF m2 a2 b2\nmorphGS morph msf = MSF $ \\a2 -> do\n  (b2, msf\') <- morph (unMSF msf) a2\n  return (b2, morphGS morph msf\')\n\n-- * Feedback loops\n\n-- | Well-formed looped connection of an output component as a future input.\nfeedback :: Monad m => c -> MSF m (a, c) (b, c) -> MSF m a b\nfeedback c sf = MSF $ \\a -> do\n  ((b\', c\'), sf\') <- unMSF sf (a, c)\n  return (b\', feedback c\' sf\')\n\n-- * Execution/simulation\n\n-- | Apply a monadic stream function to a list.\n--\n-- Because the result is in a monad, it may be necessary to traverse the whole\n-- list to evaluate the value in the results to WHNF.  For example, if the\n-- monad is the maybe monad, this may not produce anything if the \'MSF\'\n-- produces \'Nothing\' at any point, so the output stream cannot consumed\n-- progressively.\n--\n-- To explore the output progressively, use \'arrM\' and \'(>>>)\'\', together with\n-- some action that consumes/actuates on the output.\n--\n-- This is called \'runSF\' in Liu, Cheng, Hudak, "Causal Commutative Arrows and\n-- Their Optimization"\nembed :: Monad m => MSF m a b -> [a] -> m [b]\nembed _  []     = return []\nembed sf (a:as) = do\n  (b, sf\') <- unMSF sf a\n  bs       <- embed sf\' as\n  return (b:bs)\n\n-- | Run an \'MSF\' indefinitely passing a unit-carrying input stream.\nreactimate :: Monad m => MSF m () () -> m ()\nreactimate sf = do\n  (_, sf\') <- unMSF sf ()\n  reactimate sf\'\n'