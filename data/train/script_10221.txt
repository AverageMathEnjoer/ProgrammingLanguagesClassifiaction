b'{-# LANGUAGE RecordWildCards #-}\nimport Test.Tasty\nimport Test.Tasty.Options\nimport Test.Tasty.Providers as Tasty\nimport Test.Tasty.Runners as Tasty\nimport Test.Tasty.QuickCheck\nimport Test.Tasty.HUnit\nimport Data.Maybe\nimport Text.Regex.PCRE.Light.Char8\nimport Text.Printf\n\n(=~), (!~)\n  :: String -- ^ text\n  -> String -- ^ regex\n  -> Assertion\ntext =~ regexStr =\n  let\n    msg = printf "Expected /%s/, got %s" regexStr (show text)\n    -- NB show above the intentional -- to add quotes around the string and\n    -- escape newlines etc.\n  in assertBool msg $ match\' text regexStr\ntext !~ regexStr =\n  let\n    msg = printf "Did not expect /%s/, got %s" regexStr (show text)\n  in assertBool msg $ not $ match\' text regexStr\n\n-- note: the order of arguments is reversed relative to match from\n-- pcre-light, but consistent with =~ and !~\nmatch\' :: String -> String -> Bool\nmatch\' text regexStr =\n  let\n    regex = compile regexStr []\n  in\n    isJust $ match regex text []\n\nmain :: IO ()\nmain =\n  defaultMain $\n    testGroup "Unit tests for Test.Tasty.QuickCheck"\n      [ testCase "Success" $ do\n          Result{..} <- run\' $ \\x -> x >= (x :: Int)\n          -- there is no instance Show Outcome(\n          -- (because there is no instance Show SomeException),\n          -- so we can\'t use @?= for this\n          case resultOutcome of\n            Tasty.Success -> return ()\n            _ -> assertFailure $ show resultOutcome\n          resultDescription =~ "OK, passed 100 tests"\n          resultDescription !~ "Use .* to reproduce"\n\n      , testCase "Success, replay requested" $ do\n          Result{..} <- runReplay $ \\x -> x >= (x :: Int)\n          -- there is no instance Show Outcome(\n          -- (because there is no instance Show SomeException),\n          -- so we can\'t use @?= for this\n          case resultOutcome of\n            Tasty.Success -> return ()\n            _ -> assertFailure $ show resultOutcome\n          resultDescription =~ "OK, passed 100 tests"\n          resultDescription =~ "Use .* to reproduce"\n\n      , testCase "Unexpected failure" $ do\n          Result{..} <- run\' $ \\x -> x > (x :: Int)\n          case resultOutcome of\n            Tasty.Failure {} -> return ()\n            _ -> assertFailure $ show resultOutcome\n          resultDescription =~ "Failed"\n          resultDescription =~ "Use .* to reproduce"\n\n      , testCase "Gave up" $ do\n          Result{..} <- run\' $ \\x -> x > x ==> x > (x :: Int)\n          case resultOutcome of\n            Tasty.Failure {} -> return ()\n            _ -> assertFailure $ show resultOutcome\n          resultDescription =~ "Gave up"\n          resultDescription =~ "Use .* to reproduce"\n\n      , testCase "No expected failure" $ do\n          Result{..} <- run\' $ expectFailure $ \\x -> x >= (x :: Int)\n          case resultOutcome of\n            Tasty.Failure {} -> return ()\n            _ -> assertFailure $ show resultOutcome\n          resultDescription =~ "Failed.*expected failure"\n          resultDescription =~ "Use .* to reproduce"\n\n      ]\n\nrun\' :: Testable p => p -> IO Result\nrun\' p =\n  run\n    mempty -- options\n    (QC $ property p)\n    (const $ return ()) -- callback\n\nrunReplay :: Testable p => p -> IO Result\nrunReplay p =\n  run\n    (singleOption $ QuickCheckShowReplay True)\n    (QC $ property p)\n    (const $ return ())\n'