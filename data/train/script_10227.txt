b'{-# LANGUAGE FlexibleContexts #-}\n{-# LANGUAGE GADTs #-}\n{-# LANGUAGE QuasiQuotes #-}\n\nmodule Cachix.Client.URI\n  ( URI,\n    fromURIRef,\n    getScheme,\n    getHostname,\n    appendSubdomain,\n    getPortFor,\n    getPath,\n    requiresSSL,\n    parseURI,\n    serialize,\n    getBaseUrl,\n    defaultCachixURI,\n    defaultCachixBaseUrl,\n    UBS.Host (..),\n    UBS.Scheme (..),\n    UBS.Port (..),\n  )\nwhere\n\nimport Control.Monad (fail)\nimport qualified Data.Aeson as Aeson\nimport qualified Data.ByteString as BS\nimport qualified Data.ByteString.Char8 as Char8\nimport Data.Either.Validation (Validation (Failure, Success))\nimport qualified Data.Map.Strict as Map\nimport Data.Maybe (fromJust)\nimport qualified Dhall\nimport qualified Dhall.Core\nimport Protolude hiding (toS)\nimport Protolude.Conv\nimport Servant.Client\nimport qualified URI.ByteString as UBS\nimport qualified URI.ByteString.QQ as UBS\n\n-- Default URIs\n\ndefaultCachixURI :: URI\ndefaultCachixURI = fromURIRef [UBS.uri|https://cachix.org|]\n\ndefaultCachixBaseUrl :: BaseUrl\ndefaultCachixBaseUrl = getBaseUrl defaultCachixURI\n\nnewtype URI = URI {getUri :: UBS.URIRef UBS.Absolute}\n  deriving stock (Eq, Show)\n\nfromURIRef :: UBS.URIRef UBS.Absolute -> URI\nfromURIRef = URI\n\ngetScheme :: URI -> UBS.Scheme\ngetScheme = UBS.uriScheme . getUri\n\ngetHostname :: URI -> UBS.Host\ngetHostname = UBS.authorityHost . fromJust . UBS.uriAuthority . getUri\n\n-- TODO: lenses?\nappendSubdomain :: Text -> URI -> URI\nappendSubdomain domain uri =\n  let UBS.URI uScheme uAuthority uPath uQuery uFragment = getUri uri\n      UBS.Authority aUserInfo aHost aPort = fromJust uAuthority\n      newHost = UBS.Host $ toS domain <> "." <> UBS.hostBS aHost\n   in URI $\n        UBS.URI\n          uScheme\n          (Just (UBS.Authority aUserInfo newHost aPort))\n          uPath\n          uQuery\n          uFragment\n\ngetPortFor :: UBS.Scheme -> Maybe UBS.Port\ngetPortFor scheme = Map.lookup scheme UBS.httpDefaultPorts\n\ngetPath :: URI -> ByteString\ngetPath = UBS.uriPath . getUri\n\nrequiresSSL :: UBS.Scheme -> Bool\nrequiresSSL (UBS.Scheme "https") = True\nrequiresSSL _ = False\n\nparseURI :: ByteString -> Either UBS.URIParseError URI\nparseURI bs = fromURIRef <$> UBS.parseURI UBS.strictURIParserOptions bs\n\nserialize :: StringConv BS.ByteString s => URI -> s\nserialize = toS . UBS.serializeURIRef\' . getUri\n\ninstance Aeson.ToJSON URI where\n  toJSON (URI uri) = Aeson.String . toS . UBS.serializeURIRef\' $ uri\n\ninstance Aeson.FromJSON URI where\n  parseJSON = Aeson.withText "URI" $ \\text ->\n    either (fail . show) (return . URI) $\n      UBS.parseURI UBS.strictURIParserOptions (toS text)\n\ninstance Dhall.FromDhall URI where\n  autoWith opts =\n    Dhall.Decoder extract expected\n    where\n      textDecoder :: Dhall.Decoder Text\n      textDecoder = Dhall.autoWith opts\n\n      extract expression =\n        case Dhall.extract textDecoder expression of\n          Success x -> case UBS.parseURI UBS.strictURIParserOptions (toS x) of\n            Left exception -> Dhall.extractError (show exception)\n            Right path -> Success (fromURIRef path)\n          Failure e -> Failure e\n\n      expected = Dhall.expected textDecoder\n\ninstance Dhall.ToDhall URI where\n  injectWith opts = Dhall.Encoder embed declared\n    where\n      textEncoder :: Dhall.Encoder Text\n      textEncoder = Dhall.injectWith opts\n\n      embed (URI uri) = Dhall.embed textEncoder $ toS (UBS.serializeURIRef\' uri)\n\n      declared = Dhall.Core.Text\n\n-- | Partial function from URI to BaseUrl\n--\n-- TODO: We should error out during the parsing stage with a nice error.\n-- TODO: make getBaseUrl internal\ngetBaseUrl :: URI -> BaseUrl\ngetBaseUrl (URI uriref) =\n  case UBS.uriAuthority uriref of\n    Nothing -> panic "missing host in url"\n    Just authority ->\n      BaseUrl scheme hostname port path\n      where\n        scheme :: Scheme\n        scheme = case UBS.uriScheme uriref of\n          UBS.Scheme "http" -> Http\n          UBS.Scheme "https" -> Https\n          _ -> panic "uri can only be http/https"\n\n        hostname = toS $ UBS.hostBS (UBS.authorityHost authority)\n\n        port :: Int\n        port = maybe defaultPort UBS.portNumber $ UBS.authorityPort authority\n\n        defaultPort :: Int\n        defaultPort = case scheme of\n          Http -> 80\n          Https -> 443\n\n        path = toS $ removeTrailingSlash (UBS.uriPath uriref)\n\n        -- Servant expects the trailing slash to be removed\n        -- https://hackage.haskell.org/package/servant-client-core-0.19/docs/Servant-Client-Core.html#v:parseBaseUrl\n        removeTrailingSlash :: ByteString -> ByteString\n        removeTrailingSlash "" = ""\n        removeTrailingSlash str = case Char8.last str of\n          \'/\' -> Char8.init str\n          _ -> str\n'