b'// UVa1279 Asteroid Rangers\n// Rujia Liu\n#include<cstdio>\n#include<cmath>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nconst int maxn = 50 + 5;\nconst int maxks = maxn * (maxn+1) / 2;\nconst double eps = 1e-8;\n\nint n, nks;\n\n// event\nstruct Event {\n  double t;\n  int newks, oldks; // After event, newks will be smaller than oldks\n  Event(double t=0, int newks=0, int oldks=0) : t(t), newks(newks), oldks(oldks) {}\n  bool operator < (const Event& rhs) const {\n    return t - rhs.t < 0;\n  }\n};\nvector <Event> events;\n\nstruct KineticPoint {\n  double x, y, z; // initial position\n  double dx, dy, dz; // velocity\n  void read() {\n    scanf("%lf%lf%lf%lf%lf%lf", &x, &y, &z, &dx, &dy, &dz);\n  }\n} kp[maxn];\n\nstruct KineticSegment {\n  double a, b, c; // length is at^2+bt+c\n  int u, v; // end point IDs\n  bool operator < (const KineticSegment& rhs) const { // compare initial length\n    return c - rhs.c < 0;\n  }\n} ks[maxks];\n\ninline double sqr(double x) { return x * x; }\n\n// union-find\nint pa[maxn];\n\nvoid init_ufset() { for(int i = 0; i < n; i++) pa[i] = i; }\nint findset(int x) { return pa[x] != x ? pa[x] = findset(pa[x]) : x; }\n\nvoid make_segments() {\n  nks = 0;\n  for(int i = 0; i < n; i++)\n    for(int j = i+1; j < n; j++) {\n      // the square distance between point i and point j is sum{((kp[i].dx-kp[j].dx) * t + (kp[i].x-kp[j].x))^2}\n      // which can be re-written to at^2+bt+c. a>0, c>0\n      ks[nks].a = sqr(kp[i].dx-kp[j].dx) + sqr(kp[i].dy-kp[j].dy) + sqr(kp[i].dz-kp[j].dz);\n      ks[nks].b = 2*((kp[i].dx-kp[j].dx)*(kp[i].x-kp[j].x) + (kp[i].dy-kp[j].dy)*(kp[i].y-kp[j].y) + (kp[i].dz-kp[j].dz)*(kp[i].z-kp[j].z));\n      ks[nks].c = sqr(kp[i].x-kp[j].x) + sqr(kp[i].y-kp[j].y) + sqr(kp[i].z-kp[j].z);\n      ks[nks].u = i;\n      ks[nks].v = j;\n      nks++;\n    }\n  sort(ks, ks + nks);\n}\n\nvoid make_events() {\n  events.clear();\n  for(int i = 0; i < nks; i++)\n    for(int j = i+1; j < nks; j++) {\n      // when segment i\'s length is equal to segment j?\n      int s1 = i, s2 = j; \n      if (ks[s1].a - ks[s2].a < 0) s1 = j, s2 = i; // s1 is more steep (bigger a value)\n\n      double a = ks[s1].a - ks[s2].a;\n      double b = ks[s1].b - ks[s2].b;\n      double c = ks[s1].c - ks[s2].c;\n      if(fabs(a) < eps) { // bt + c = 0\n        if (fabs(b) < eps) continue; // no solution\n        if (b > 0) { swap(s1, s2); b = -b; c = -c; } // bt + c = 0, b < 0\n        if (c > 0) events.push_back(Event(-c / b, s1, s2)); // t > 0\n        continue;\n      }\n      double delta = b * b - 4 * a * c;\n      if (delta < eps) continue; // no solution\n      delta = sqrt(delta);\n      double t1 = -(b + delta) / (2 * a); // solution 1\n      double t2 = (delta - b) / (2 * a); // solution 2\n      if (t1 > 0) events.push_back(Event(t1, s1, s2)); // steep one will be smaller\n      if (t2 > 0) events.push_back(Event(t2, s2, s1)); // flat one will be smaller\n    }\n  sort(events.begin(), events.end());\n}\n\nint solve() {\n  int pos[maxks]; // pos[i] is the index of i-th segment in the MST. 0 means "not in MST"\n  int e[maxn];    // e[i] (i > 0) is the i-th edge in current MST. pos[e[i]] = i\n\n  // initial MST\n  init_ufset();\n  for(int i = 0; i < nks; i++) pos[i] = 0;\n  int idx = 0;\n  for(int i = 0; i < nks; i++) {\n    int u = findset(ks[i].u), v = findset(ks[i].v);\n    if (u != v) {\n      e[pos[i] = ++idx] = i; \n      pa[u] = v;\n    }\n    if(idx == n-1) break;\n  }\n\n  int ans = 1;\n  for(int i = 0; i < events.size(); i++) {\n    if(pos[events[i].oldks] && (!pos[events[i].newks])) {\n      init_ufset();\n      int oldpos = pos[events[i].oldks];\n      for(int j = 1; j < n; j++)\n        if (j != oldpos) {\n          int u = findset(ks[e[j]].u), v = findset(ks[e[j]].v);\n          if(u != v) pa[u] = v;\n        }\n      int u = findset(ks[events[i].newks].u), v = findset(ks[events[i].newks].v);\n      if(u != v) {\n        // new MST found! now replace oldks with newks\n        ans++;\n        pos[events[i].newks] = oldpos;\n        e[oldpos] = events[i].newks;\n        pos[events[i].oldks] = 0;\n      }\n    }\n  }\n  return ans;\n}\n\nint main() {\n  int kase = 0;\n  while(scanf("%d", &n) == 1) {\n    for(int i = 0; i < n; i++) kp[i].read();\n    make_segments();\n    make_events();\n    int ans = solve();\n    printf("Case %d: %d\\n", ++kase, ans);\n  }\n  return 0;\n}\n'