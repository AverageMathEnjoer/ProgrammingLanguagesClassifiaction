b'\xef\xbb\xbfusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.IO;\nnamespace qqzengip\n{\n    //###################################################################################\n    //#\n    //#  \xe6\x9c\x80\xe6\x96\xb0IP\xe5\x9c\xb0\xe5\x9d\x80\xe6\x95\xb0\xe6\x8d\xae\xe5\xba\x93 qqzeng-ip-db.dat\n    //#\t \xe6\xa0\xb7\xe4\xbe\x8b\xe8\xaf\xb4\xe6\x98\x8e\xef\xbc\x9ahttp://zengxiangzhan.cnblogs.com/p/qqzengipdb-dat.html\n    //#  2015 qqzeng.com  \xe9\x87\x87\xe7\x94\xa8\xe4\xba\x8c\xe5\x88\x86\xe9\x80\xbc\xe8\xbf\x91\xe6\x9f\xa5\xe6\x89\xbe \xe6\x80\xa7\xe8\x83\xbd\xe6\x8f\x90\xe5\x8d\x87\xe5\xbe\x88\xe5\xa4\xa7\n    //#\n    //###################################################################################\n    public class IpLocation\n    {\n        readonly string ipBinaryFilePath = "qqzeng-ip-db.dat";\n        readonly byte[] dataBuffer, indexBuffer;\n        readonly uint[] index = new uint[256];\n        readonly int dataLength;\n        public IpLocation()\n        {\n            try\n            {\n                FileInfo file = new FileInfo(ipBinaryFilePath);\n                dataBuffer = new byte[file.Length];\n                using (var fin = new FileStream(file.FullName, FileMode.Open, FileAccess.Read))\n                {\n                    fin.Read(dataBuffer, 0, dataBuffer.Length);\n                }\n                //\xe6\x96\x87\xe4\xbb\xb6\xe5\xa4\xb4   \xe4\xbb\x8e\xe9\x9b\xb6\xe5\xbc\x80\xe5\xa7\x8b\xe7\x9a\x84\xe5\xad\x97\xe8\x8a\x82\xe5\x81\x8f\xe7\xa7\xbb\xe9\x87\x8f \n                var offset_len = BytesToLong(dataBuffer[0], dataBuffer[1], dataBuffer[2], dataBuffer[3]); //Big Endian\n                indexBuffer = new byte[offset_len];\n                Array.Copy(dataBuffer, 4, indexBuffer, 0, offset_len);\n                dataLength = (int)offset_len;\n                for (int loop = 0; loop < 256; loop++)\n                {\n                    //\xe7\xb4\xa2\xe5\xbc\x95 \xe5\x9b\x9b\xe5\xad\x97\xe8\x8a\x82  LITTLE_ENDIAN\n                    index[loop] = BytesToLong(indexBuffer[loop * 4 + 3], indexBuffer[loop * 4 + 2], indexBuffer[loop * 4 + 1], indexBuffer[loop * 4]);\n                }\n            }\n            catch { }\n        }\n\n\n        public string[] Find(string ip)\n        {\n            var ips = ip.Split(\'.\');\n            uint ip_prefix = uint.Parse(ips[0]);\n            uint find_uint32 = BytesToLong(byte.Parse(ips[0]), byte.Parse(ips[1]), byte.Parse(ips[2]), byte.Parse(ips[3]));//BIG_ENDIAN\n            uint max_len = 0;\n            int resultOffset = -1;\n            int resultLegth = -1;\n            uint start = index[ip_prefix];\n            if (ip_prefix != 255)\n            {\n                max_len = index[ip_prefix + 1];\n            }\n            else\n            {\n                max_len = index[255];\n            }\n            uint num = max_len - start;\n            uint my_index = BinarySearch(start, max_len, find_uint32);\n            start = my_index * 8 + 1024;\n            resultOffset = (int)BytesToLong((byte)0, indexBuffer[start + 6], indexBuffer[start + 5], indexBuffer[start + 4]);//LITTLE_ENDIAN\n            resultLegth = 0xFF & indexBuffer[start + 7];// \xe9\x95\xbf\xe5\xba\xa6\n\n            if (resultOffset == -1 || resultLegth == -1)\n            {\n                return new string[] { "N/A" };\n            }\n            var areaBytes = new byte[resultLegth];\n            Array.Copy(dataBuffer, dataLength + resultOffset - 1024, areaBytes, 0, resultLegth);\n            return Encoding.UTF8.GetString(areaBytes).Split(\'\\t\');\n        }\n\n\n\n        /// <summary>\n        /// \xe4\xba\x8c\xe5\x88\x86\xe9\x80\xbc\xe8\xbf\x91\n        /// </summary>\n        public uint BinarySearch(uint low, uint high, uint k)\n        {\n            uint M = 0;\n            while (low <= high)\n            {\n                uint mid = (low + high) / 2;\n                uint endipNum = GetStartIp(mid);\n                if (endipNum >= k)\n                {\n                    M = mid; //mid\xe6\x9c\x89\xe5\x8f\xaf\xe8\x83\xbd\xe6\x98\xaf\xe8\xa7\xa3\n                    high = mid - 1;\n                }\n                else\n                    low = mid + 1;\n            }\n            return M;\n        }\n\n        public uint GetStartIp(uint left)\n        {\n            int start = (int)(1024 + left * 8);\n            uint endipNum = BytesToLong(indexBuffer[start + 0], indexBuffer[start + 1], indexBuffer[start + 2], indexBuffer[start + 3]);//BIG_ENDIAN     \n            return endipNum;\n        }\n\n        private static uint BytesToLong(byte a, byte b, byte c, byte d)\n        {\n\n            return ((uint)a << 24) | ((uint)b << 16) | ((uint)c << 8) | (uint)d;\n        }\n\n\n    }\n\n}\n'