b'using System.Diagnostics;\nusing System.Text;\n\nusing HANDLE = System.IntPtr;\nusing i64 = System.Int64;\nusing u32 = System.UInt32;\n\n\nnamespace CS_SQLite3\n{\n  public partial class CSSQLite\n  {\n\n    /*\n    ** 2005 November 29\n    **\n    ** The author disclaims copyright to this source code.  In place of\n    ** a legal notice, here is a blessing:\n    **\n    **    May you do good and not evil.\n    **    May you find forgiveness for yourself and forgive others.\n    **    May you share freely, never taking more than you give.\n    **\n    ******************************************************************************\n    **\n    ** This file contains OS interface code that is common to all\n    ** architectures.\n    **\n    ** $Id: os.c,v 1.127 2009/07/27 11:41:21 danielk1977 Exp $\n    **\n    *************************************************************************\n    **  Included in SQLite3 port to C#-SQLite;  2008 Noah B Hart\n    **  C#-SQLite is an independent reimplementation of the SQLite software library\n    **\n    **  $Header$\n    *************************************************************************\n    */\n    //#define _SQLITE_OS_C_ 1\n    //#include "sqliteInt.h"\n    //#undef _SQLITE_OS_C_\n\n    /*\n    ** The default SQLite sqlite3_vfs implementations do not allocate\n    ** memory (actually, os_unix.c allocates a small amount of memory\n    ** from within OsOpen()), but some third-party implementations may.\n    ** So we test the effects of a malloc() failing and the sqlite3OsXXX()\n    ** function returning SQLITE_IOERR_NOMEM using the DO_OS_MALLOC_TEST macro.\n    **\n    ** The following functions are instrumented for malloc() failure\n    ** testing:\n    **\n    **     sqlite3OsOpen()\n    **     sqlite3OsRead()\n    **     sqlite3OsWrite()\n    **     sqlite3OsSync()\n    **     sqlite3OsLock()\n    **\n    */\n#if (SQLITE_TEST) && !SQLITE_OS_WIN\n//#define DO_OS_MALLOC_TEST(x) if (!x || !sqlite3IsMemJournal(x)) {     \\\nvoid *pTstAlloc = sqlite3Malloc(10);                             \\\nif (!pTstAlloc) return SQLITE_IOERR_NOMEM;                       \\\n//sqlite3_free(pTstAlloc);                                         \\\n}\n#else\n    //#define DO_OS_MALLOC_TEST(x)\n    static void DO_OS_MALLOC_TEST( sqlite3_file x ) { }\n#endif\n\n\n    /*\n** The following routines are convenience wrappers around methods\n** of the sqlite3_file object.  This is mostly just syntactic sugar. All\n** of this would be completely automatic if SQLite were coded using\n** C++ instead of plain old C.\n*/\n    static int sqlite3OsClose( sqlite3_file pId )\n    {\n      int rc = SQLITE_OK;\n      if ( pId.pMethods != null )\n      {\n        rc = pId.pMethods.xClose( pId );\n        pId.pMethods = null;\n      }\n      return rc;\n    }\n    static int sqlite3OsRead( sqlite3_file id, byte[] pBuf, int amt, i64 offset )\n    {\n      DO_OS_MALLOC_TEST( id );\n      if ( pBuf == null ) pBuf = new byte[amt];\n      return id.pMethods.xRead( id, pBuf, amt, offset );\n    }\n    static int sqlite3OsWrite( sqlite3_file id, byte[] pBuf, int amt, i64 offset )\n    {\n      DO_OS_MALLOC_TEST( id );\n      return id.pMethods.xWrite( id, pBuf, amt, offset );\n    }\n    static int sqlite3OsTruncate( sqlite3_file id, i64 size )\n    {\n      return id.pMethods.xTruncate( id, size );\n    }\n    static int sqlite3OsSync( sqlite3_file id, int flags )\n    {\n      DO_OS_MALLOC_TEST( id );\n      return id.pMethods.xSync( id, flags );\n    }\n    static int sqlite3OsFileSize( sqlite3_file id, ref int pSize )\n    {\n      return id.pMethods.xFileSize( id, ref pSize );\n    }\n    static int sqlite3OsLock( sqlite3_file id, int lockType )\n    {\n      DO_OS_MALLOC_TEST( id );\n      return id.pMethods.xLock( id, lockType );\n    }\n    static int sqlite3OsUnlock( sqlite3_file id, int lockType )\n    {\n      return id.pMethods.xUnlock( id, lockType );\n    }\n    static int sqlite3OsCheckReservedLock( sqlite3_file id, ref int pResOut )\n    {\n      DO_OS_MALLOC_TEST( id );\n      return id.pMethods.xCheckReservedLock( id, ref pResOut );\n    }\n    static int sqlite3OsFileControl( sqlite3_file id, u32 op, ref int pArg )\n    {\n      return id.pMethods.xFileControl( id, (int)op, ref pArg );\n    }\n\n    static int sqlite3OsSectorSize( sqlite3_file id )\n    {\n      dxSectorSize xSectorSize = id.pMethods.xSectorSize;\n      return ( xSectorSize != null ? xSectorSize( id ) : SQLITE_DEFAULT_SECTOR_SIZE );\n    }\n    static int sqlite3OsDeviceCharacteristics( sqlite3_file id )\n    {\n      return id.pMethods.xDeviceCharacteristics( id );\n    }\n\n    /*\n    ** The next group of routines are convenience wrappers around the\n    ** VFS methods.\n    */\n    static int sqlite3OsOpen(\n    sqlite3_vfs pVfs,\n    string zPath,\n    sqlite3_file pFile,\n    int flags,\n    ref int pFlagsOut\n    )\n    {\n      int rc;\n      DO_OS_MALLOC_TEST( null );\n      rc = pVfs.xOpen( pVfs, zPath, pFile, flags, ref pFlagsOut );\n      Debug.Assert( rc == SQLITE_OK || pFile.pMethods == null );\n      return rc;\n    }\n    static int sqlite3OsDelete( sqlite3_vfs pVfs, string zPath, int dirSync )\n    {\n      return pVfs.xDelete( pVfs, zPath, dirSync );\n    }\n    static int sqlite3OsAccess( sqlite3_vfs pVfs, string zPath, int flags, ref int pResOut )\n    {\n      DO_OS_MALLOC_TEST( null );\n      return pVfs.xAccess( pVfs, zPath, flags, ref pResOut );\n    }\n    static int sqlite3OsFullPathname(\n    sqlite3_vfs pVfs,\n    string zPath,\n    int nPathOut,\n    StringBuilder zPathOut\n    )\n    {\n      return pVfs.xFullPathname( pVfs, zPath, nPathOut, zPathOut );\n    }\n#if !SQLITE_OMIT_LOAD_EXTENSION\n    static HANDLE sqlite3OsDlOpen( sqlite3_vfs pVfs, string zPath )\n    {\n      return pVfs.xDlOpen( pVfs, zPath );\n    }\n\n    static void sqlite3OsDlError( sqlite3_vfs pVfs, int nByte, ref string zBufOut )\n    {\n      pVfs.xDlError( pVfs, nByte, ref zBufOut );\n    }\n    static object sqlite3OsDlSym( sqlite3_vfs pVfs, HANDLE pHdle, ref string zSym )\n    {\n      return pVfs.xDlSym( pVfs, pHdle, zSym );\n    }\n    static void sqlite3OsDlClose( sqlite3_vfs pVfs, HANDLE pHandle )\n    {\n      pVfs.xDlClose( pVfs, pHandle );\n    }\n#endif\n    static int sqlite3OsRandomness( sqlite3_vfs pVfs, int nByte, ref byte[] zBufOut )\n    {\n      return pVfs.xRandomness( pVfs, nByte, ref zBufOut );\n    }\n    static int sqlite3OsSleep( sqlite3_vfs pVfs, int nMicro )\n    {\n      return pVfs.xSleep( pVfs, nMicro );\n    }\n    static int sqlite3OsCurrentTime( sqlite3_vfs pVfs, ref double pTimeOut )\n    {\n      return pVfs.xCurrentTime( pVfs, ref pTimeOut );\n    }\n\n    static int sqlite3OsOpenMalloc(\n    ref sqlite3_vfs pVfs,\n    string zFile,\n    ref sqlite3_file ppFile,\n    int flags,\n    ref int pOutFlags\n    )\n    {\n      int rc = SQLITE_NOMEM;\n      sqlite3_file pFile;\n      pFile = new sqlite3_file(); //sqlite3Malloc(ref pVfs.szOsFile);\n      if ( pFile != null )\n      {\n        rc = sqlite3OsOpen( pVfs, zFile, pFile, flags, ref pOutFlags );\n        if ( rc != SQLITE_OK )\n        {\n          pFile = null; // was  //sqlite3DbFree(db,ref  pFile);\n        }\n        else\n        {\n          ppFile = pFile;\n        }\n      }\n      return rc;\n    }\n    static int sqlite3OsCloseFree( sqlite3_file pFile )\n    {\n      int rc = SQLITE_OK;\n      Debug.Assert( pFile != null );\n      rc = sqlite3OsClose( pFile );\n      //sqlite3_free( ref  pFile );\n      return rc;\n    }\n\n    /*\n    ** The list of all registered VFS implementations.\n    */\n    static sqlite3_vfs vfsList;\n    //#define vfsList GLOBAL(sqlite3_vfs *, vfsList)\n\n    /*\n    ** Locate a VFS by name.  If no name is given, simply return the\n    ** first VFS on the list.\n    */\n    static bool isInit = false;\n\n    static sqlite3_vfs sqlite3_vfs_find( string zVfs )\n    {\n      sqlite3_vfs pVfs = null;\n#if SQLITE_THREADSAFE\nsqlite3_mutex mutex;\n#endif\n#if !SQLITE_OMIT_AUTOINIT\n      int rc = sqlite3_initialize();\n      if ( rc != 0 ) return null;\n#endif\n#if SQLITE_THREADSAFE\nmutex = sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_MASTER);\n#endif\n      sqlite3_mutex_enter( mutex );\n      for ( pVfs = vfsList ; pVfs != null ; pVfs = pVfs.pNext )\n      {\n        if ( zVfs == null || zVfs == "" ) break;\n        if ( zVfs == pVfs.zName ) break; //strcmp(zVfs, pVfs.zName) == null) break;\n      }\n      sqlite3_mutex_leave( mutex );\n      return pVfs;\n    }\n\n    /*\n    ** Unlink a VFS from the linked list\n    */\n    static void vfsUnlink( sqlite3_vfs pVfs )\n    {\n      Debug.Assert( sqlite3_mutex_held( sqlite3MutexAlloc( SQLITE_MUTEX_STATIC_MASTER ) ) );\n      if ( pVfs == null )\n      {\n        /* No-op */\n      }\n      else if ( vfsList == pVfs )\n      {\n        vfsList = pVfs.pNext;\n      }\n      else if ( vfsList != null )\n      {\n        sqlite3_vfs p = vfsList;\n        while ( p.pNext != null && p.pNext != pVfs )\n        {\n          p = p.pNext;\n        }\n        if ( p.pNext == pVfs )\n        {\n          p.pNext = pVfs.pNext;\n        }\n      }\n    }\n\n    /*\n    ** Register a VFS with the system.  It is harmless to register the same\n    ** VFS multiple times.  The new VFS becomes the default if makeDflt is\n    ** true.\n    */\n    static int sqlite3_vfs_register( sqlite3_vfs pVfs, int makeDflt )\n    {\n      sqlite3_mutex mutex;\n#if !SQLITE_OMIT_AUTOINIT\n      int rc = sqlite3_initialize();\n      if ( rc != 0 ) return rc;\n#endif\n      mutex = sqlite3MutexAlloc( SQLITE_MUTEX_STATIC_MASTER );\n      sqlite3_mutex_enter( mutex );\n      vfsUnlink( pVfs );\n      if ( makeDflt != 0 || vfsList == null )\n      {\n        pVfs.pNext = vfsList;\n        vfsList = pVfs;\n      }\n      else\n      {\n        pVfs.pNext = vfsList.pNext;\n        vfsList.pNext = pVfs;\n      }\n      Debug.Assert( vfsList != null );\n      sqlite3_mutex_leave( mutex );\n      return SQLITE_OK;\n    }\n\n    /*\n    ** Unregister a VFS so that it is no longer accessible.\n    */\n    static int sqlite3_vfs_unregister( sqlite3_vfs pVfs )\n    {\n#if SQLITE_THREADSAFE\nsqlite3_mutex mutex = sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_MASTER);\n#endif\n      sqlite3_mutex_enter( mutex );\n      vfsUnlink( pVfs );\n      sqlite3_mutex_leave( mutex );\n      return SQLITE_OK;\n    }\n  }\n}\n\n'