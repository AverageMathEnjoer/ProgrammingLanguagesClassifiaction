b'{-# LANGUAGE QuasiQuotes #-}\n\nmodule Cachix.Client.InstallationMode\n  ( InstallationMode (..),\n    NixEnv (..),\n    getInstallationMode,\n    addBinaryCache,\n    isTrustedUser,\n    getUser,\n    fromString,\n    toString,\n    UseOptions (..),\n  )\nwhere\n\nimport Cachix.Client.Config (Config)\nimport qualified Cachix.Client.Config as Config\nimport Cachix.Client.Exception (CachixException (..))\nimport qualified Cachix.Client.NetRc as NetRc\nimport qualified Cachix.Client.NixConf as NixConf\nimport qualified Cachix.Types.BinaryCache as BinaryCache\nimport qualified Data.Maybe\nimport Data.String.Here\nimport qualified Data.Text as T\nimport Protolude\nimport System.Directory (Permissions, createDirectoryIfMissing, getPermissions, writable)\nimport System.Environment (lookupEnv)\nimport System.FilePath (replaceFileName, (</>))\nimport System.Process (readProcessWithExitCode)\nimport Prelude (String)\n\ndata NixEnv = NixEnv\n  { isTrusted :: Bool,\n    isRoot :: Bool,\n    isNixOS :: Bool\n  }\n\n-- NOTE: update the list of options for --mode argument in OptionsParser.hs\ndata InstallationMode\n  = Install NixConf.NixConfLoc\n  | WriteNixOS\n  | UntrustedRequiresSudo\n  | UntrustedNixOS\n  deriving (Show, Eq)\n\ndata UseOptions = UseOptions\n  { useMode :: Maybe InstallationMode,\n    useNixOSFolder :: FilePath,\n    useOutputDirectory :: Maybe FilePath\n  }\n  deriving (Show)\n\nfromString :: String -> Maybe InstallationMode\nfromString "root-nixconf" = Just $ Install NixConf.Global\nfromString "user-nixconf" = Just $ Install NixConf.Local\nfromString "nixos" = Just WriteNixOS\nfromString "untrusted-requires-sudo" = Just UntrustedRequiresSudo\nfromString _ = Nothing\n\ntoString :: InstallationMode -> String\ntoString (Install NixConf.Global) = "root-nixconf"\ntoString (Install NixConf.Local) = "user-nixconf"\ntoString (Install (NixConf.Custom _)) = "custom-nixconf"\ntoString WriteNixOS = "nixos"\ntoString UntrustedRequiresSudo = "untrusted-requires-sudo"\ntoString UntrustedNixOS = "untrusted-nixos"\n\ngetInstallationMode :: NixEnv -> UseOptions -> InstallationMode\ngetInstallationMode nixenv useOptions\n  | (isRoot nixenv || isTrusted nixenv) && isJust (useOutputDirectory useOptions) = Install (NixConf.Custom $ Data.Maybe.fromJust $ useOutputDirectory useOptions)\n  | isJust (useMode useOptions) = Data.Maybe.fromJust $ useMode useOptions\n  | isNixOS nixenv && isRoot nixenv = WriteNixOS\n  | not (isNixOS nixenv) && isRoot nixenv = Install NixConf.Global\n  | isTrusted nixenv = Install NixConf.Local\n  | isNixOS nixenv = UntrustedNixOS\n  | otherwise = UntrustedRequiresSudo\n\n-- | Add a Binary cache to nix.conf, print nixos config or fail\naddBinaryCache :: Config -> BinaryCache.BinaryCache -> UseOptions -> InstallationMode -> IO ()\naddBinaryCache _ _ _ UntrustedNixOS = do\n  user <- getUser\n  throwIO $\n    MustBeRoot\n      [i|This user doesn\'t have permissions to configure binary caches.\n\nYou can either:\n\na) Run the same command as root to write NixOS configuration.\n\nb) Add the following to your configuration.nix to add your user as trusted \n   and then try again:\n\n  nix.settings.trusted-users = [ "root" "${user}" ];\n\n|]\naddBinaryCache _ _ _ UntrustedRequiresSudo = do\n  user <- getUser\n  throwIO $\n    MustBeRoot\n      [i|This user doesn\'t have permissions to configure binary caches.\n\nYou can either:\n\na) Run the same command as root to configure them globally.\n\nb) Run the following command to add your user as trusted \n   and then try again:\n\n  echo "trusted-users = root ${user}" | sudo tee -a /etc/nix/nix.conf && sudo pkill nix-daemon\n|]\naddBinaryCache config bc useOptions WriteNixOS =\n  nixosBinaryCache config bc useOptions\naddBinaryCache config bc _ (Install ncl) = do\n  -- TODO: might need locking one day\n  gnc <- NixConf.read NixConf.Global\n  (input, output) <-\n    case ncl of\n      NixConf.Global -> return ([gnc], gnc)\n      NixConf.Local -> do\n        lnc <- NixConf.read NixConf.Local\n        return ([gnc, lnc], lnc)\n      NixConf.Custom _ -> do\n        lnc <- NixConf.read ncl\n        return ([lnc], lnc)\n  let nixconf = fromMaybe (NixConf.NixConf []) output\n  netrcLocMaybe <- forM (guard $ not (BinaryCache.isPublic bc)) $ const $ addPrivateBinaryCacheNetRC config bc ncl\n  let addNetRCLine :: NixConf.NixConf -> NixConf.NixConf\n      addNetRCLine = fromMaybe identity $ do\n        netrcLoc <- netrcLocMaybe :: Maybe FilePath\n        -- We only add the netrc line for local user configs for now.\n        -- On NixOS we assume it will be picked up from the default location.\n        guard (ncl == NixConf.Local)\n        pure (NixConf.setNetRC $ toS netrcLoc)\n  NixConf.write ncl $ addNetRCLine $ NixConf.add bc (catMaybes input) nixconf\n  filename <- NixConf.getFilename ncl\n  putStrLn $ "Configured " <> BinaryCache.uri bc <> " binary cache in " <> toS filename\n\nnixosBinaryCache :: Config -> BinaryCache.BinaryCache -> UseOptions -> IO ()\nnixosBinaryCache config bc UseOptions {useNixOSFolder = baseDirectory} = do\n  _ <- try $ createDirectoryIfMissing True $ toS toplevel :: IO (Either SomeException ())\n  eitherPermissions <- try $ getPermissions (toS toplevel) :: IO (Either SomeException Permissions)\n  case eitherPermissions of\n    Left _ -> throwIO $ NixOSInstructions $ noEtcPermissionInstructions $ toS baseDirectory\n    Right permissions\n      | writable permissions -> installFiles\n      | otherwise -> throwIO $ NixOSInstructions $ noEtcPermissionInstructions $ toS baseDirectory\n  where\n    installFiles = do\n      writeFile (toS glueModuleFile) glueModule\n      writeFile (toS cacheModuleFile) cacheModule\n      unless (BinaryCache.isPublic bc) $ void $ addPrivateBinaryCacheNetRC config bc NixConf.Global\n      putText instructions\n    configurationNix :: Text\n    configurationNix = toS $ toS baseDirectory </> "configuration.nix"\n    namespace :: Text\n    namespace = "cachix"\n    toplevel :: Text\n    toplevel = toS $ toS baseDirectory </> toS namespace\n    glueModuleFile :: Text\n    glueModuleFile = toplevel <> ".nix"\n    cacheModuleFile :: Text\n    cacheModuleFile = toplevel <> "/" <> toS (BinaryCache.name bc) <> ".nix"\n    noEtcPermissionInstructions :: Text -> Text\n    noEtcPermissionInstructions dir =\n      [iTrim|\nCould not install NixOS configuration to ${dir} due to lack of write permissions.\n\nPass `--nixos-folder /etc/mynixos/` as an alternative location with write permissions.\n|]\n    instructions :: Text\n    instructions =\n      [iTrim|\nCachix configuration written to ${glueModuleFile}.\nBinary cache ${BinaryCache.name bc} configuration written to ${cacheModuleFile}.\n\nTo start using cachix add the following to your ${configurationNix}:\n\n    imports = [ ./cachix.nix ];\n\nThen run:\n\n    $ sudo nixos-rebuild switch\n|]\n    glueModule :: Text\n    glueModule =\n      [i|\n# WARN: this file will get overwritten by $ cachix use <name>\n{ pkgs, lib, ... }:\n\nlet\n  folder = ./cachix;\n  toImport = name: value: folder + ("/" + name);\n  filterCaches = key: value: value == "regular" && lib.hasSuffix ".nix" key;\n  imports = lib.mapAttrsToList toImport (lib.filterAttrs filterCaches (builtins.readDir folder));\nin {\n  inherit imports;\n  nix.settings.substituters = ["https://cache.nixos.org/"];\n}\n|]\n    cacheModule :: Text\n    cacheModule =\n      [i|\n{\n  nix = {\n    settings = {\n      substituters = [\n        "${BinaryCache.uri bc}"\n      ];\n      trusted-public-keys = [\n        ${T.intercalate " " (map (\\s -> "\\"" <> s <> "\\"") (BinaryCache.publicSigningKeys bc))}\n      ];\n    };\n  };\n}\n|]\n\n-- TODO: allow overriding netrc location\naddPrivateBinaryCacheNetRC :: Config -> BinaryCache.BinaryCache -> NixConf.NixConfLoc -> IO FilePath\naddPrivateBinaryCacheNetRC config bc nixconf = do\n  filename <- (`replaceFileName` "netrc") <$> NixConf.getFilename nixconf\n  authToken <- Config.getAuthTokenRequired config\n  let netrcfile = fromMaybe filename Nothing -- TODO: get netrc from nixconf\n  NetRc.add authToken [bc] netrcfile\n  putErrText $ "Configured private read access credentials in " <> toS filename\n  pure filename\n\nisTrustedUser :: [Text] -> IO Bool\nisTrustedUser users = do\n  user <- getUser\n  -- to detect single user installations\n  permissions <- getPermissions "/nix/store"\n  isInAGroup <- userInAnyGroup user\n  return $ writable permissions || user `elem` users || isInAGroup\n  where\n    groups :: [Text]\n    groups = map T.tail $ filter (\\u -> (fst <$> T.uncons u) == Just \'@\') users\n    userInAnyGroup :: Text -> IO Bool\n    userInAnyGroup user = do\n      isIn <- for groups $ checkUserInGroup user\n      return $ any identity isIn\n    checkUserInGroup :: Text -> Text -> IO Bool\n    checkUserInGroup user groupName = do\n      (_exitcode, out, _err) <- readProcessWithExitCode "id" ["-Gn", toS user] mempty\n      return $ groupName `T.isInfixOf` toS out\n\ngetUser :: IO Text\ngetUser = do\n  maybeUser <- lookupEnv "USER"\n  case maybeUser of\n    Nothing -> throwIO $ UserEnvNotSet "$USER must be set. If running in a container, try setting USER=root."\n    Just user -> return $ toS user\n'