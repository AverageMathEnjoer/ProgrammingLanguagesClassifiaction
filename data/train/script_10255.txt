b'{-# LANGUAGE OverloadedStrings #-}\n\nmodule Devices.Razer \n    ( setWaveRight\n    , setWaveLeft\n    , setFrame\n    , getMatrixDimensions\n    , setKeyboardBrightness\n    , getKeyboardBrightness\n    ) where \n\nimport Data.List (sort)\nimport Data.Int\nimport Data.Maybe\nimport Data.Binary as Binary\nimport Data.Binary.Put as Put\nimport Control.Monad\nimport qualified Data.ByteString.Lazy.Char8 as L8\nimport DBus\nimport DBus.Client\nimport Color\n\ndeviceAddress = "/org/razer/device/BY1750A44000357"\nmiscMethod    = "razer.device.misc"\n\n-- Need to do it multiple times because of hardware bug\ngetKeyboardBrightnessOnce :: Client -> IO Double\ngetKeyboardBrightnessOnce c = do\n    reply <- call_ c (methodCall deviceAddress "razer.device.lighting.brightness" "getBrightness") \n                    { methodCallDestination = Just "org.razer" }\n    let x:_ = (map (fromJust . fromVariant) (methodReturnBody reply)) :: [Double]\n    return x\n\ngetKeyboardBrightness :: Client -> IO Double\ngetKeyboardBrightness c = do\n    a <- getKeyboardBrightnessOnce c\n    b <- getKeyboardBrightnessOnce c\n    c <- getKeyboardBrightnessOnce c\n    return (max a (max b c))\n\nsetKeyboardBrightness :: Double -> Client -> IO ()\nsetKeyboardBrightness brightness c = do\n    call_ c (methodCall deviceAddress "razer.device.lighting.brightness" "setBrightness") \n            { methodCallDestination = Just "org.razer"\n            , methodCallBody = [toVariant brightness] }\n    return ()\n\nsetWaveRight :: Client -> IO ()\nsetWaveRight c = do\n    call_ c (methodCall deviceAddress "razer.device.lighting.chroma"  "setWave") \n            { methodCallDestination = Just "org.razer"\n            , methodCallBody = [toVariant (1 :: Int32)] }\n    return ()\n\nsetWaveLeft :: Client -> IO ()\nsetWaveLeft c = do\n    call_ c (methodCall deviceAddress "razer.device.lighting.chroma"  "setWave") \n            { methodCallDestination = Just "org.razer"\n            , methodCallBody = [toVariant (2 :: Int32)] }\n    return ()\n\nsetCustom :: Client -> IO ()\nsetCustom c = do\n    call_ c (methodCall deviceAddress "razer.device.lighting.chroma"  "setCustom") \n            { methodCallDestination = Just "org.razer" }\n    return ()\n\nsendCustom :: Frame -> Client -> IO ()\nsendCustom frame c = do\n    call_ c (methodCall deviceAddress "razer.device.lighting.chroma"  "setKeyRow") \n            { methodCallDestination = Just "org.razer" \n            , methodCallBody = [toVariant (encodeFrame frame)] }\n    return ()\n\nsetFrame :: Frame -> Client -> IO ()\nsetFrame f c = sendCustom f c >> setCustom c\n\ngetMatrixDimensions :: Client -> IO (Int32, Int32)\ngetMatrixDimensions c = do\n    reply <-call_ c (methodCall deviceAddress "razer.device.misc"  "getMatrixDimensions") \n                    { methodCallDestination = Just "org.razer" }\n    let [x:y:[]] = (map (fromJust . fromVariant) (methodReturnBody reply)) :: [[Int32]]\n    return (x, y)\n\n\nencodeFrame :: Frame -> L8.ByteString\nencodeFrame frame = Put.runPut (mapM_ putRow rowInfo)\n        where (h, w) = _dimensions frame\n              rowLastIndex = h - 1\n              rowInfo :: [(Word8, (Word8, [Color]))]\n              rowInfo = zip (replicate (fromIntegral h) (w - 1)) . zip [0..rowLastIndex] $ _keys frame\n\nputRow :: (Word8, (Word8, [Color])) -> Put\nputRow (rowEnd, (rowIndex, keys)) = index >> start >> end >> row\n    where index = putWord8 rowIndex\n          start = putWord8 0\n          end   = putWord8 rowEnd\n          row   = mapM_ putColor keys\n\nputColor :: Color -> Put\nputColor (r, g, b) = putWord8 r >> putWord8 g >> putWord8 b'