b'{-# LANGUAGE NoImplicitPrelude #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n\nmodule Course.Optional where\n\nimport qualified Control.Applicative as A\nimport qualified Control.Monad as M\nimport Course.Core\nimport qualified Prelude as P\n\n-- | The `Optional` data type contains 0 or 1 value.\n--\n-- It might be thought of as a list, with a maximum length of one.\ndata Optional a =\n  Full a\n  | Empty\n  deriving (Eq, Show)\n\n-- | Map the given function on the possible value.\n--\n-- >>> mapOptional (+1) Empty\n-- Empty\n--\n-- >>> mapOptional (+1) (Full 8)\n-- Full 9\nmapOptional ::\n  (a -> b)\n  -> Optional a\n  -> Optional b\nmapOptional =\n  error "todo: Course.Optional#mapOptional"\n\n-- | Bind the given function on the possible value.\n--\n-- >>> bindOptional Full Empty\n-- Empty\n--\n-- >>> bindOptional (\\n -> if even n then Full (n - 1) else Full (n + 1)) (Full 8)\n-- Full 7\n--\n-- >>> bindOptional (\\n -> if even n then Full (n - 1) else Full (n + 1)) (Full 9)\n-- Full 10\nbindOptional ::\n  (a -> Optional b)\n  -> Optional a\n  -> Optional b\nbindOptional =\n  error "todo: Course.Optional#bindOptional"\n\n-- | Return the possible value if it exists; otherwise, the second argument.\n--\n-- >>> Full 8 ?? 99\n-- 8\n--\n-- >>> Empty ?? 99\n-- 99\n(??) ::\n  Optional a\n  -> a\n  -> a\n(??) =\n  error "todo: Course.Optional#(??)"\n\n-- | Try the first optional for a value. If it has a value, use it; otherwise,\n-- use the second value.\n--\n-- >>> Full 8 <+> Empty\n-- Full 8\n--\n-- >>> Full 8 <+> Full 9\n-- Full 8\n--\n-- >>> Empty <+> Full 9\n-- Full 9\n--\n-- >>> Empty <+> Empty\n-- Empty\n(<+>) ::\n  Optional a\n  -> Optional a\n  -> Optional a\n(<+>) =\n  error "todo: Course.Optional#(<+>)"  \n\napplyOptional :: Optional (a -> b) -> Optional a -> Optional b\napplyOptional f a = bindOptional (\\f\' -> mapOptional f\' a) f\n\ntwiceOptional :: (a -> b -> c) -> Optional a -> Optional b -> Optional c\ntwiceOptional f = applyOptional . mapOptional f\n\ncontains :: Eq a => a -> Optional a -> Bool\ncontains _ Empty = False\ncontains a (Full z) = a == z\n\ninstance P.Functor Optional where\n  fmap =\n    M.liftM\n\ninstance A.Applicative Optional where\n  (<*>) =\n    M.ap\n  pure =\n    Full\n\ninstance P.Monad Optional where\n  (>>=) =\n    flip bindOptional\n  return =\n    Full\n'