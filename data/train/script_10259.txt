b'module Code.Build.Haskell where\n\nimport Code.Build\nimport Data.List\n\nrecord :: [(String, Code)] -> Code\nrecord []    = code "{}"\nrecord items = ("{ " <-> many ", ") |><| mkStack (map fst items) |><| many " = " |>+<| map snd items <-> "}"\n\nblock :: CodeList a => a -> Code\nblock = mkStack . codeList\n\nhsModule :: CodeList a => String -> a -> Code\nhsModule name c = "module" <++> name <++> "where" <-> block c\n\nhsType :: [String] -> String\nhsType = intercalate " -> "\n\nhsDecl :: Codeable a => String -> [String] -> a -> Code\nhsDecl n pars c | singleLine (code c) = n <++> unwords pars <++> "= " <+| c\n                | otherwise = n <++> unwords pars <++> "=" <-> indent 2 c\n\nfunction :: String -> String -> Code\nfunction n t = n <++> "::" <++> t\n\nhsLet :: (CodeList a, Codeable b) => a -> b -> Code\nhsLet decls f = ("let " <+| block decls) <-> "in " <+| code f\n\nhsArray :: CodeList a => a -> Code\nhsArray = surround "[" "]" . interleave ", "\n\nhsTuple :: CodeList a => a -> Code\nhsTuple = parenthesis . interleave ", "\n\nhsData :: String -> [String] -> Code\nhsData n cons = "data" <++> n <+| (" = " <-> many " | ") |><| block cons\n\nstring :: Codeable a => a -> Code\nstring = surround "\\"" "\\""\n\ninfix 2 .=.\n\n(.=.) :: Codeable b => String -> b -> Code\nv .=. c | singleLine (code c) = v <+> " = " <+| c\n        | otherwise           = v <+> " =" <-> indent 2 c\n'