b'{-# LANGUAGE TupleSections #-}\nmodule Rest.Gen.Docs\n  ( DocsContext (..)\n  , cdiv\n  , cls\n  , mkAllResources\n  , mkSingleResource\n  , resourcesInfo\n  , row\n  , subResourcesInfo\n  , writeDocs\n  ) where\n\nimport Prelude hiding (div, head, span, (.))\nimport qualified Prelude as P\n\nimport Control.Category ((.))\nimport Data.Foldable (forM_)\nimport Data.Function (on)\nimport Data.Hashable (hash)\nimport Data.List hiding (head, span)\nimport Data.String\nimport System.Directory\nimport System.FilePath\nimport Text.Blaze.Html\nimport Text.Blaze.Html5 hiding (map, meta, style)\nimport Text.Blaze.Html5.Attributes hiding (id, method, span, title)\nimport Text.Blaze.Html.Renderer.String\nimport Text.StringTemplate\nimport qualified Data.Label.Total            as L\nimport qualified Text.Blaze.Html5.Attributes as A\n\nimport Rest.Api (Router, Version)\nimport Rest.Gen.Base\nimport Rest.Gen.Utils\n\n-- | Information about the context in which a resource is contained\ndata DocsContext = DocsContext\n  { rootUrl        :: String\n  , contextVersion :: Version\n  , templates      :: String\n  } deriving (Eq, Show)\n\nwriteDocs :: DocsContext -> Router m s -> String -> IO ()\nwriteDocs context router loc =\n  do createDirectoryIfMissing True loc\n     let tree = apiSubtrees router\n     mkAllResources context tree >>= writeFile (loc </> "index.html")\n     mapM_ (writeSingleResource context loc) $ allSubResources tree\n\nwriteSingleResource :: DocsContext -> String -> ApiResource -> IO ()\nwriteSingleResource ctx loc r =\n  do let dr = loc </> intercalate "/" (resId r)\n     createDirectoryIfMissing True dr\n     mkSingleResource ctx r >>= writeFile (dr </> "index.html")\n\nmkAllResources :: DocsContext -> ApiResource -> IO String\nmkAllResources ctx tree =\n  do tmpls <- directoryGroup (templates ctx)\n     tmpl  <- maybe (putStrLn "Couldn\'t find template api-docs-all" >> return (newSTMP "")) return $\n                     getStringTemplate "api-docs-all" tmpls\n     return $ render\n            $ setManyAttrib\n                   [ ("listing"  , map (renderHtml . (\\v -> resourceLinkAnchor v (resourceDisp v))) . sort . allSubResourceIds $ tree) ]\n            $ setManyAttrib\n                   [ ("resources" , renderHtml $ subResourcesInfo ctx tree )\n                   , ("version"   , show $ contextVersion ctx  )\n                   , ("static"    , rootUrl ctx  )\n                   ]\n                   tmpl\n\nmkSingleResource :: DocsContext -> ApiResource -> IO String\nmkSingleResource ctx tree =\n  do tmpls <- directoryGroup (templates ctx)\n     tmpl  <- maybe (putStrLn "Couldn\'t find template api-docs-resource" >> return (newSTMP "")) return $\n                     getStringTemplate "api-docs-resource" tmpls\n     return $ render\n            $ setManyAttrib\n                   [ ("subresources", map (renderHtml . (\\v -> resourceLinkRemote (rootUrl ctx) v (resourceDisp v))) $ allResourceIds tree)\n                   , ("resource"    , resId tree)\n                   , ("parents"     , map (renderHtml . (\\v -> resourceLinkRemote (rootUrl ctx) v (toHtml $ last v))) $ tail $ inits (resId tree))\n                   , ("identifiers" , map renderHtml $ resourceIdentifiers (resLink tree) (resIdents tree))\n                   ]\n            $ setManyAttrib\n                   [ ("name"        , resName tree)\n                   , ("urls"        , renderHtml $ resourceTable tree)\n                   , ("description" , resDescription tree)\n                   , ("version"     , show $ contextVersion ctx)\n                   , ("static"      , rootUrl ctx  )\n                   ]\n                   tmpl\n\n-- | Helper functions for generating HTML\ncls :: String -> Attribute\ncls = class_ . toValue\n\ncdiv :: String -> Html -> Html\ncdiv s = div ! cls s\n\nrow :: Html -> Html\nrow = cdiv "row"\n\n-- | Recursively generate information for a resource structure\nresourcesInfo :: DocsContext -> ApiResource -> Html\nresourcesInfo ctx = foldTree $ \\it -> sequence_ . (resourceInfo ctx it :)\n\nsubResourcesInfo :: DocsContext -> ApiResource -> Html\nsubResourcesInfo ctx = foldTreeChildren sequence_ $ \\it -> sequence_ . (resourceInfo ctx it :)\n\n-- | Generate information for one resource\nresourceInfo :: DocsContext -> ApiResource -> Html\nresourceInfo ctx it = section $\n  do resourceAnchor (resId it)\n     row $ cdiv "span16 page-header resource-title" $ h1 $ resourceLinkRemote (rootUrl ctx) (resId it) $ resourceDisp (resId it)\n     row $\n      do cdiv "span10" $\n           do h2 $ toHtml "Description"\n              p $ toHtml $ resDescription it\n         cdiv "span6" $\n           do h2 $ toHtml "Identifiers"\n              p $ sequence_ $ intersperse br $ resourceIdentifiers (resLink it) (resIdents it)\n     br\n     resourceTable it\n\nresourceIdentifiers :: Link -> [Link] -> [Html]\nresourceIdentifiers lnk lnks =\n  case lnks of\n    [] -> [toHtml "No identifiers"]\n    ls -> map (linkHtml . (lnk ++)) ls\n\nresourceTable :: ApiResource -> Html\nresourceTable it =\n  let urlInfo = groupByFirst . concatMap (\\ai -> map (,itemInfo ai) $ flattenLast $ itemLink ai) $ resItems it\n  in table ! cls "bordered-table resource-table" $\n      do thead $ mapM_ (\\v -> th ! cls v $ toHtml v) ["URL", "Method", "Description", "Input", "Output", "Errors", "Parameters"]\n         tbody $ forM_ (zip [(1 :: Int)..] urlInfo) $ \\(n, (url, ais)) ->\n          do tr ! cls ("stripe-" ++ show (n `mod` 2) ++ " url-main-row") $ mapM_ td\n                     [ linkHtml url\n                     , toHtml $ show $ method $ P.head ais\n                     , toHtml $ mkActionDescription (resName it) $ P.head ais\n                     , dataDescriptions "None"  $ inputs $ P.head ais\n                     , dataDescriptions "None" $ outputs $ P.head ais\n                     , dataDescriptions "None" $ errors $ P.head ais\n                     , toHtml $ if null (params (P.head ais)) then "None" else intercalate ", " $ params $ P.head ais\n                     ]\n             forM_ (tail ais) $ \\ai ->\n                tr ! cls ("stripe-" ++ show (n `mod` 2) ++ " url-data-row") $ mapM_ td\n                     [ return ()\n                     , toHtml $ show $ method ai\n                     , toHtml $ mkActionDescription (resName it) ai\n                     , dataDescriptions "None"  (inputs ai)\n                     , dataDescriptions "None" (outputs ai)\n                     , dataDescriptions "None" (errors ai)\n                     , toHtml $ if null (params ai) then "None" else intercalate ", " $ params ai\n                     ]\n\n-- | Generate information for input/output data structure\ndataDescriptions :: String -> [DataDescription] -> Html\ndataDescriptions s []    = toHtml s\ndataDescriptions _ descs =\n  table ! cls "data-description" $\n    do tr $ forM_ descs $ \\dsc -> td $ toHtml . L.get (dataTypeDesc . meta) $ dsc\n       tr $ forM_ descs $ \\dsc -> td $\n        do forM_ (L.get (dataSchema  . meta) dsc) $ mkCode (typeLang (L.get (dataType . desc) dsc)) "Schema"\n           forM_ (L.get (dataExample . meta) dsc) $ mkCode (typeLang (L.get (dataType . desc) dsc)) "Example"\n  where typeLang XML  = "xml"\n        typeLang JSON = "js"\n        typeLang _    = ""\n\n-- | Helper function for setting the right attributes to make something collapsible.\n-- The javascript prt can be found in docs.js\n\nmkCode :: String -> String -> String -> Html\nmkCode lng cap cd =\n  let eid = "idv" ++ show (hash cd)\n  in do div ! cls "modal hide fade code" ! A.id (toValue eid) $\n          do cdiv "modal-header" $\n              do a ! href (toValue "#") ! cls "close" $ toHtml "x"\n                 h3 $ toHtml cap\n             cdiv "modal-body" $\n               div ! style (toValue "overflow:auto; max-height:600px") $\n                 pre ! cls ("prettyprint lang-" ++ lng) $ toHtml cd\n        button ! cls "btn open-modal"\n               ! customAttribute (fromString "data-controls-modal") (toValue eid)\n               ! customAttribute (fromString "data-backdrop") (toValue "true")\n               ! customAttribute (fromString "data-keyboard") (toValue "true")\n               $ toHtml cap\n\nresourceId :: ResourceId -> String\nresourceId = intercalate "."\n\nresourceDisp :: ResourceId -> Html\nresourceDisp = toHtml . intercalate "/"\n\nresourceLinkAnchor :: ResourceId -> Html -> Html\nresourceLinkAnchor rid = a ! cls "resource-link" ! href (toValue $ "#" ++ resourceId rid)\n\nresourceLinkRemote :: String -> ResourceId -> Html -> Html\nresourceLinkRemote rUrl rid = a ! cls "resource-link" ! href (toValue $ rUrl ++ intercalate "/" rid)\n\nresourceAnchor :: ResourceId -> Html\nresourceAnchor rid = a ! name (toValue $ resourceId rid) $ return ()\n\nlinkHtml :: Link -> Html\nlinkHtml =  mapM_ linkItem\n  where linkItem (LParam idf)   = toHtml ("/<" ++ idf ++ ">")\n        linkItem (LAccess lnks) = span ! class_ (toValue "link-block") $ sequence_ $ intersperse br\n                                   $ map linkHtml $ sortBy (flip compare `on` length) lnks\n        linkItem x              = toHtml ("/" ++ itemString x)\n'