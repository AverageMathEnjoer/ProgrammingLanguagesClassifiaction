b'/*\n    SPDX-FileCopyrightText: 2015-2019 Milian Wolff <mail@milianw.de>\n\n    SPDX-License-Identifier: LGPL-2.1-or-later\n*/\n\n#include "flamegraph.h"\n\n#include <cmath>\n\n#include <QAction>\n#include <QApplication>\n#include <QCheckBox>\n#include <QClipboard>\n#include <QComboBox>\n#include <QCursor>\n#include <QDebug>\n#include <QDoubleSpinBox>\n#include <QEvent>\n#include <QGraphicsRectItem>\n#include <QGraphicsScene>\n#include <QGraphicsView>\n#include <QLabel>\n#include <QLineEdit>\n#include <QMenu>\n#include <QPushButton>\n#include <QStyleOption>\n#include <QToolTip>\n#include <QVBoxLayout>\n#include <QWheelEvent>\n\n#include <KColorScheme>\n#include <KLocalizedString>\n#include <KStandardAction>\n#include <ThreadWeaver/ThreadWeaver>\n\n#include "resultdata.h"\n#include "util.h"\n\nenum CostType\n{\n    Allocations,\n    Temporary,\n    Peak,\n    Leaked,\n};\nQ_DECLARE_METATYPE(CostType)\n\nnamespace {\nenum SearchMatchType\n{\n    NoSearch,\n    NoMatch,\n    DirectMatch,\n    ChildMatch\n};\n}\n\nclass FrameGraphicsItem : public QGraphicsRectItem\n{\npublic:\n    FrameGraphicsItem(const qint64 cost, CostType costType, const Symbol& symbol,\n                      std::shared_ptr<const ResultData> resultData, FrameGraphicsItem* parent = nullptr);\n    FrameGraphicsItem(const qint64 cost, const Symbol& symbol, std::shared_ptr<const ResultData> resultData,\n                      FrameGraphicsItem* parent);\n\n    qint64 cost() const;\n    void setCost(qint64 cost);\n    Symbol symbol() const;\n\n    void paint(QPainter* painter, const QStyleOptionGraphicsItem* option, QWidget* widget = nullptr) override;\n\n    QString description() const;\n\n    bool match(const QString& searchValue) const;\n    void setSearchMatchType(SearchMatchType matchType);\n\nprotected:\n    void hoverEnterEvent(QGraphicsSceneHoverEvent* event) override;\n    void hoverLeaveEvent(QGraphicsSceneHoverEvent* event) override;\n\nprivate:\n    std::shared_ptr<const ResultData> m_resultData;\n    qint64 m_cost;\n    Symbol m_symbol;\n    CostType m_costType;\n    bool m_isHovered;\n    SearchMatchType m_searchMatch = NoSearch;\n};\n\nQ_DECLARE_METATYPE(FrameGraphicsItem*)\n\nFrameGraphicsItem::FrameGraphicsItem(const qint64 cost, CostType costType, const Symbol& symbol,\n                                     std::shared_ptr<const ResultData> resultData, FrameGraphicsItem* parent)\n    : QGraphicsRectItem(parent)\n    , m_resultData(std::move(resultData))\n    , m_cost(cost)\n    , m_symbol(symbol)\n    , m_costType(costType)\n    , m_isHovered(false)\n{\n    setFlag(QGraphicsItem::ItemIsSelectable);\n    setAcceptHoverEvents(true);\n}\n\nFrameGraphicsItem::FrameGraphicsItem(const qint64 cost, const Symbol& symbol,\n                                     std::shared_ptr<const ResultData> resultData, FrameGraphicsItem* parent)\n    : FrameGraphicsItem(cost, parent->m_costType, symbol, std::move(resultData), parent)\n{\n}\n\nqint64 FrameGraphicsItem::cost() const\n{\n    return m_cost;\n}\n\nvoid FrameGraphicsItem::setCost(qint64 cost)\n{\n    m_cost = cost;\n}\n\nSymbol FrameGraphicsItem::symbol() const\n{\n    return m_symbol;\n}\n\nvoid FrameGraphicsItem::paint(QPainter* painter, const QStyleOptionGraphicsItem* option, QWidget* /*widget*/)\n{\n    if (isSelected() || m_isHovered || m_searchMatch == DirectMatch) {\n        auto selectedColor = brush().color();\n        selectedColor.setAlpha(255);\n        painter->fillRect(rect(), selectedColor);\n    } else if (m_searchMatch == NoMatch) {\n        auto noMatchColor = brush().color();\n        noMatchColor.setAlpha(50);\n        painter->fillRect(rect(), noMatchColor);\n    } else { // default, when no search is running, or a sub-item is matched\n        painter->fillRect(rect(), brush());\n    }\n\n    const QPen oldPen = painter->pen();\n    auto pen = oldPen;\n    if (m_searchMatch != NoMatch) {\n        pen.setColor(brush().color());\n        if (isSelected()) {\n            pen.setWidth(2);\n        }\n        painter->setPen(pen);\n        painter->drawRect(rect());\n        painter->setPen(oldPen);\n    }\n\n    const int margin = 4;\n    const int width = rect().width() - 2 * margin;\n    if (width < option->fontMetrics.averageCharWidth() * 6) {\n        // text is too wide for the current LOD, don\'t paint it\n        return;\n    }\n\n    if (m_searchMatch == NoMatch) {\n        auto color = oldPen.color();\n        color.setAlpha(125);\n        pen.setColor(color);\n        painter->setPen(pen);\n    }\n\n    auto label = [this]() {\n        if (m_symbol.isValid()) {\n            return m_resultData->string(m_symbol.functionId);\n        }\n\n        // root\n        switch (m_costType) {\n        case Allocations:\n            return i18n("%1 allocations in total", m_cost);\n        case Temporary:\n            return i18n("%1 temporary allocations in total", m_cost);\n        case Peak:\n            return i18n("%1 peak memory consumption", Util::formatBytes(m_cost));\n        case Leaked:\n            return i18n("%1 leaked in total", Util::formatBytes(m_cost));\n        }\n        Q_UNREACHABLE();\n    }();\n\n    const int height = rect().height();\n    painter->drawText(margin + rect().x(), rect().y(), width, height,\n                      Qt::AlignVCenter | Qt::AlignLeft | Qt::TextSingleLine,\n                      option->fontMetrics.elidedText(label, Qt::ElideRight, width));\n\n    if (m_searchMatch == NoMatch) {\n        painter->setPen(oldPen);\n    }\n}\n\nvoid FrameGraphicsItem::hoverEnterEvent(QGraphicsSceneHoverEvent* event)\n{\n    QGraphicsRectItem::hoverEnterEvent(event);\n    m_isHovered = true;\n    update();\n}\n\nvoid FrameGraphicsItem::hoverLeaveEvent(QGraphicsSceneHoverEvent* event)\n{\n    QGraphicsRectItem::hoverLeaveEvent(event);\n    m_isHovered = false;\n    update();\n}\n\nQString FrameGraphicsItem::description() const\n{\n    const auto symbol = Util::toString(m_symbol, *m_resultData, Util::Short);\n\n    // we build the tooltip text on demand, which is much faster than doing that\n    // for potentially thousands of items when we load the data\n    if (!parentItem()) {\n        return symbol;\n    }\n\n    qint64 totalCost = 0;\n    {\n        auto item = this;\n        while (item->parentItem()) {\n            item = static_cast<const FrameGraphicsItem*>(item->parentItem());\n        }\n        totalCost = item->cost();\n    }\n    const auto fraction = Util::formatCostRelative(m_cost, totalCost);\n\n    QString tooltip;\n    switch (m_costType) {\n    case Allocations:\n        tooltip = i18nc("%1: number of allocations, %2: relative number, %3: function label",\n                        "%1 (%2%) allocations in %3 and below.", m_cost, fraction, symbol);\n        break;\n    case Temporary:\n        tooltip = i18nc("%1: number of temporary allocations, %2: relative number, "\n                        "%3 function label",\n                        "%1 (%2%) temporary allocations in %3 and below.", m_cost, fraction, symbol);\n        break;\n    case Peak:\n        tooltip = i18nc("%1: peak consumption in bytes, %2: relative number, %3: "\n                        "function label",\n                        "%1 (%2%) contribution to peak consumption in %3 and below.", Util::formatBytes(m_cost),\n                        fraction, symbol);\n        break;\n    case Leaked:\n        tooltip = i18nc("%1: leaked bytes, %2: relative number, %3: function label", "%1 (%2%) leaked in %3 and below.",\n                        Util::formatBytes(m_cost), fraction, symbol);\n        break;\n    }\n\n    return tooltip;\n}\n\nbool FrameGraphicsItem::match(const QString& searchValue) const\n{\n    auto match = [&](StringIndex index) {\n        return m_resultData->string(index).contains(searchValue, Qt::CaseInsensitive);\n    };\n    return match(m_symbol.functionId) || match(m_symbol.moduleId);\n}\n\nvoid FrameGraphicsItem::setSearchMatchType(SearchMatchType matchType)\n{\n    if (m_searchMatch != matchType) {\n        m_searchMatch = matchType;\n        update();\n    }\n}\n\nnamespace {\n\n/**\n * Generate a brush from the "mem" color space used in upstream FlameGraph.pl\n */\nQBrush brush()\n{\n    // intern the brushes, to reuse them across items which can be thousands\n    // otherwise we\'d end up with dozens of allocations and higher memory\n    // consumption\n    static const QVector<QBrush> brushes = []() -> QVector<QBrush> {\n        QVector<QBrush> brushes;\n        std::generate_n(std::back_inserter(brushes), 100, []() {\n            return QColor(0, 190 + 50 * qreal(rand()) / RAND_MAX, 210 * qreal(rand()) / RAND_MAX, 125);\n        });\n        return brushes;\n    }();\n    return brushes.at(rand() % brushes.size());\n}\n\n/**\n * Layout the flame graph and hide tiny items.\n */\nvoid layoutItems(FrameGraphicsItem* parent)\n{\n    const auto& parentRect = parent->rect();\n    const auto pos = parentRect.topLeft();\n    const qreal maxWidth = parentRect.width();\n    const qreal h = parentRect.height();\n    const qreal y_margin = 2.;\n    const qreal y = pos.y() - h - y_margin;\n    qreal x = pos.x();\n\n    const auto children = parent->childItems();\n    for (auto child : children) {\n        auto frameChild = static_cast<FrameGraphicsItem*>(child);\n        const qreal w = maxWidth * double(frameChild->cost()) / parent->cost();\n        frameChild->setVisible(w > 1);\n        if (frameChild->isVisible()) {\n            frameChild->setRect(QRectF(x, y, w, h));\n            layoutItems(frameChild);\n            x += w;\n        }\n    }\n}\n\nFrameGraphicsItem* findItemBySymbol(const QList<QGraphicsItem*>& items, const Symbol& symbol)\n{\n    for (auto item_ : items) {\n        auto item = static_cast<FrameGraphicsItem*>(item_);\n        if (item->symbol() == symbol) {\n            return item;\n        }\n    }\n    return nullptr;\n}\n\n/**\n * Convert the top-down graph into a tree of FrameGraphicsItem.\n */\nvoid toGraphicsItems(const std::shared_ptr<const ResultData>& resultData, const QVector<RowData>& data,\n                     FrameGraphicsItem* parent, int64_t AllocationData::*member, const double costThreshold,\n                     bool collapseRecursion)\n{\n    for (const auto& row : data) {\n        if (collapseRecursion && row.symbol.functionId && row.symbol == parent->symbol()) {\n            toGraphicsItems(resultData, row.children, parent, member, costThreshold, collapseRecursion);\n            continue;\n        }\n        auto item = findItemBySymbol(parent->childItems(), row.symbol);\n        if (!item) {\n            item = new FrameGraphicsItem(row.cost.*member, row.symbol, resultData, parent);\n            item->setPen(parent->pen());\n            item->setBrush(brush());\n        } else {\n            item->setCost(item->cost() + row.cost.*member);\n        }\n        if (item->cost() > costThreshold) {\n            toGraphicsItems(resultData, row.children, item, member, costThreshold, collapseRecursion);\n        }\n    }\n}\n\nint64_t AllocationData::*memberForType(CostType type)\n{\n    switch (type) {\n    case Allocations:\n        return &AllocationData::allocations;\n    case Temporary:\n        return &AllocationData::temporary;\n    case Peak:\n        return &AllocationData::peak;\n    case Leaked:\n        return &AllocationData::leaked;\n    }\n    Q_UNREACHABLE();\n}\n\nFrameGraphicsItem* parseData(const TreeData& data, CostType type, double costThreshold, bool collapseRecursion)\n{\n    auto member = memberForType(type);\n\n    const auto totalCost = data.resultData->totalCosts().*member;\n\n    KColorScheme scheme(QPalette::Active);\n    const QPen pen(scheme.foreground().color());\n\n    auto rootItem = new FrameGraphicsItem(totalCost, type, {}, data.resultData);\n    rootItem->setBrush(scheme.background());\n    rootItem->setPen(pen);\n    toGraphicsItems(data.resultData, data.rows, rootItem, member, totalCost * costThreshold / 100., collapseRecursion);\n    return rootItem;\n}\n\nstruct SearchResults\n{\n    SearchMatchType matchType = NoMatch;\n    qint64 directCost = 0;\n};\n\nSearchResults applySearch(FrameGraphicsItem* item, const QString& searchValue)\n{\n    SearchResults result;\n    if (searchValue.isEmpty()) {\n        result.matchType = NoSearch;\n    } else if (item->match(searchValue)) {\n        result.directCost += item->cost();\n        result.matchType = DirectMatch;\n    }\n\n    // recurse into the child items, we always need to update all items\n    for (auto* child : item->childItems()) {\n        auto* childFrame = static_cast<FrameGraphicsItem*>(child);\n        auto childMatch = applySearch(childFrame, searchValue);\n        if (result.matchType != DirectMatch\n            && (childMatch.matchType == DirectMatch || childMatch.matchType == ChildMatch)) {\n            result.matchType = ChildMatch;\n            result.directCost += childMatch.directCost;\n        }\n    }\n\n    item->setSearchMatchType(result.matchType);\n    return result;\n}\n}\n\nFlameGraph::FlameGraph(QWidget* parent)\n    : QWidget(parent)\n    , m_costSource(new QComboBox(this))\n    , m_scene(new QGraphicsScene(this))\n    , m_view(new QGraphicsView(this))\n    , m_displayLabel(new QLabel)\n    , m_searchResultsLabel(new QLabel)\n{\n    qRegisterMetaType<FrameGraphicsItem*>();\n\n    m_costSource->addItem(i18n("Memory Peak"), QVariant::fromValue(Peak));\n    m_costSource->setItemData(2,\n                              i18n("Show a flame graph over the contributions to the peak heap "\n                                   "memory consumption of your application."),\n                              Qt::ToolTipRole);\n    m_costSource->addItem(i18n("Leaked"), QVariant::fromValue(Leaked));\n    m_costSource->setItemData(3,\n                              i18n("Show a flame graph over the leaked heap memory of your application. "\n                                   "Memory is considered to be leaked when it never got deallocated. "),\n                              Qt::ToolTipRole);\n    m_costSource->addItem(i18n("Allocations"), QVariant::fromValue(Allocations));\n    m_costSource->setItemData(0,\n                              i18n("Show a flame graph over the number of allocations triggered by "\n                                   "functions in your code."),\n                              Qt::ToolTipRole);\n    m_costSource->addItem(i18n("Temporary Allocations"), QVariant::fromValue(Temporary));\n    m_costSource->setItemData(1,\n                              i18n("Show a flame graph over the number of temporary allocations "\n                                   "triggered by functions in your code. "\n                                   "Allocations are marked as temporary when they are immediately "\n                                   "followed by their deallocation."),\n                              Qt::ToolTipRole);\n    connect(m_costSource, static_cast<void (QComboBox::*)(int)>(&QComboBox::currentIndexChanged), this,\n            &FlameGraph::showData);\n    m_costSource->setToolTip(i18n("Select the data source that should be visualized in the flame graph."));\n\n    m_scene->setItemIndexMethod(QGraphicsScene::NoIndex);\n    m_view->setScene(m_scene);\n    m_view->viewport()->installEventFilter(this);\n    m_view->viewport()->setMouseTracking(true);\n    m_view->setFont(QFont(QStringLiteral("monospace")));\n\n    m_backButton = new QPushButton(this);\n    m_backButton->setIcon(QIcon::fromTheme(QStringLiteral("go-previous")));\n    m_backButton->setToolTip(QStringLiteral("Go back in symbol view history"));\n    m_forwardButton = new QPushButton(this);\n    m_forwardButton->setIcon(QIcon::fromTheme(QStringLiteral("go-next")));\n    m_forwardButton->setToolTip(QStringLiteral("Go forward in symbol view history"));\n\n    auto bottomUpCheckbox = new QCheckBox(i18n("Bottom-Up View"), this);\n    bottomUpCheckbox->setToolTip(i18n("Enable the bottom-up flame graph view. When this is unchecked, "\n                                      "the top-down view is enabled by default."));\n    bottomUpCheckbox->setChecked(m_showBottomUpData);\n    connect(bottomUpCheckbox, &QCheckBox::toggled, this, [this, bottomUpCheckbox] {\n        m_showBottomUpData = bottomUpCheckbox->isChecked();\n        showData();\n    });\n\n    auto collapseRecursionCheckbox = new QCheckBox(i18n("Collapse Recursion"), this);\n    collapseRecursionCheckbox->setChecked(m_collapseRecursion);\n    collapseRecursionCheckbox->setToolTip(i18n("Collapse stack frames for functions calling themselves. "\n                                               "When this is unchecked, recursive frames will be visualized "\n                                               "separately."));\n    connect(collapseRecursionCheckbox, &QCheckBox::toggled, this, [this, collapseRecursionCheckbox] {\n        m_collapseRecursion = collapseRecursionCheckbox->isChecked();\n        showData();\n    });\n\n    auto costThreshold = new QDoubleSpinBox(this);\n    costThreshold->setDecimals(2);\n    costThreshold->setMinimum(0);\n    costThreshold->setMaximum(99.90);\n    costThreshold->setPrefix(i18n("Cost Threshold: "));\n    costThreshold->setSuffix(QStringLiteral("%"));\n    costThreshold->setValue(m_costThreshold);\n    costThreshold->setSingleStep(0.01);\n    costThreshold->setToolTip(i18n("<qt>The cost threshold defines a fractional cut-off value. "\n                                   "Items with a relative cost below this value will not be shown in "\n                                   "the flame graph. This is done as an optimization to quickly generate "\n                                   "graphs for large data sets with low memory overhead. If you need more "\n                                   "details, decrease the threshold value, or set it to zero.</qt>"));\n    connect(costThreshold, static_cast<void (QDoubleSpinBox::*)(double)>(&QDoubleSpinBox::valueChanged), this,\n            [this](double threshold) {\n                m_costThreshold = threshold;\n                showData();\n            });\n\n    m_searchInput = new QLineEdit(this);\n    m_searchInput->setPlaceholderText(i18n("Search..."));\n    m_searchInput->setToolTip(i18n("<qt>Search the flame graph for a symbol.</qt>"));\n    m_searchInput->setClearButtonEnabled(true);\n    connect(m_searchInput, &QLineEdit::textChanged, this, &FlameGraph::setSearchValue);\n\n    auto controls = new QWidget(this);\n    controls->setLayout(new QHBoxLayout);\n    controls->layout()->addWidget(m_backButton);\n    controls->layout()->addWidget(m_forwardButton);\n    controls->layout()->addWidget(m_costSource);\n    controls->layout()->addWidget(bottomUpCheckbox);\n    controls->layout()->addWidget(collapseRecursionCheckbox);\n    controls->layout()->addWidget(costThreshold);\n    controls->layout()->addWidget(m_searchInput);\n\n    m_displayLabel->setWordWrap(true);\n    m_displayLabel->setTextInteractionFlags(m_displayLabel->textInteractionFlags() | Qt::TextSelectableByMouse);\n\n    m_searchResultsLabel->setWordWrap(true);\n    m_searchResultsLabel->setTextInteractionFlags(m_searchResultsLabel->textInteractionFlags()\n                                                  | Qt::TextSelectableByMouse);\n    m_searchResultsLabel->hide();\n\n    setLayout(new QVBoxLayout);\n    layout()->setContentsMargins(0, 0, 0, 0);\n    layout()->setSpacing(0);\n    layout()->addWidget(controls);\n    layout()->addWidget(m_view);\n    layout()->addWidget(m_displayLabel);\n    layout()->addWidget(m_searchResultsLabel);\n\n    m_backAction = KStandardAction::back(this, SLOT(navigateBack()), this);\n    addAction(m_backAction);\n    connect(m_backButton, &QPushButton::released, m_backAction, &QAction::trigger);\n\n    m_forwardAction = KStandardAction::forward(this, SLOT(navigateForward()), this);\n    addAction(m_forwardAction);\n    connect(m_forwardButton, &QPushButton::released, m_forwardAction, &QAction::trigger);\n\n    m_resetAction = new QAction(QIcon::fromTheme(QStringLiteral("go-first")), i18n("Reset View"), this);\n    m_resetAction->setShortcut(Qt::Key_Escape);\n    connect(m_resetAction, &QAction::triggered, this, [this]() { selectItem(0); });\n    addAction(m_resetAction);\n    updateNavigationActions();\n    m_view->setContextMenuPolicy(Qt::CustomContextMenu);\n    connect(m_view, &QWidget::customContextMenuRequested, this, [this](const QPoint& point) {\n        auto* menu = new QMenu(this);\n        menu->setAttribute(Qt::WA_DeleteOnClose, true);\n        if (auto item = static_cast<const FrameGraphicsItem*>(m_view->itemAt(point))) {\n            auto* action = menu->addAction(i18n("View Caller/Callee"));\n            connect(action, &QAction::triggered, this,\n                    [this, item]() { emit callerCalleeViewRequested(item->symbol()); });\n\n            auto* copy = menu->addAction(QIcon::fromTheme(QStringLiteral("edit-copy")), tr("Copy"));\n            connect(copy, &QAction::triggered, this, [item]() { qApp->clipboard()->setText(item->description()); });\n\n            menu->addSeparator();\n        }\n        menu->addActions(actions());\n        menu->popup(m_view->mapToGlobal(point));\n    });\n}\n\nFlameGraph::~FlameGraph() = default;\n\nbool FlameGraph::eventFilter(QObject* object, QEvent* event)\n{\n    bool ret = QObject::eventFilter(object, event);\n\n    if (event->type() == QEvent::MouseButtonRelease) {\n        QMouseEvent* mouseEvent = static_cast<QMouseEvent*>(event);\n        if (mouseEvent->button() == Qt::LeftButton) {\n            auto item = static_cast<FrameGraphicsItem*>(m_view->itemAt(mouseEvent->pos()));\n            if (item && item != m_selectionHistory.at(m_selectedItem)) {\n                selectItem(item);\n                if (m_selectedItem != m_selectionHistory.size() - 1) {\n                    m_selectionHistory.remove(m_selectedItem + 1, m_selectionHistory.size() - m_selectedItem - 1);\n                }\n                m_selectedItem = m_selectionHistory.size();\n                m_selectionHistory.push_back(item);\n                updateNavigationActions();\n            }\n        }\n    } else if (event->type() == QEvent::MouseMove) {\n        QMouseEvent* mouseEvent = static_cast<QMouseEvent*>(event);\n        auto item = static_cast<FrameGraphicsItem*>(m_view->itemAt(mouseEvent->pos()));\n        setTooltipItem(item);\n    } else if (event->type() == QEvent::Leave) {\n        setTooltipItem(nullptr);\n    } else if (event->type() == QEvent::Resize || event->type() == QEvent::Show) {\n        if (!m_rootItem) {\n            if (!m_buildingScene) {\n                showData();\n            }\n        } else {\n            selectItem(m_selectionHistory.at(m_selectedItem));\n        }\n        updateTooltip();\n    } else if (event->type() == QEvent::ToolTip) {\n        auto tooltip = m_displayLabel->toolTip();\n\n        if (m_tooltipItem != m_view->itemAt(m_view->mapFromGlobal(QCursor::pos()))) {\n            // don\'t show a tooltip when the cursor is in the empty region\n            tooltip.clear();\n        }\n\n        if (tooltip.isEmpty()) {\n            QToolTip::hideText();\n        } else {\n            QToolTip::showText(QCursor::pos(), QLatin1String("<qt>") + tooltip.toHtmlEscaped() + QLatin1String("</qt>"),\n                               this);\n        }\n        event->accept();\n        return true;\n    }\n    return ret;\n}\n\nvoid FlameGraph::setTopDownData(const TreeData& topDownData)\n{\n    m_topDownData = topDownData;\n\n    if (isVisible()) {\n        showData();\n    }\n}\n\nvoid FlameGraph::setBottomUpData(const TreeData& bottomUpData)\n{\n    m_bottomUpData = bottomUpData;\n}\n\nvoid FlameGraph::clearData()\n{\n    m_topDownData = {};\n    m_bottomUpData = {};\n\n    setData(nullptr);\n}\n\nvoid FlameGraph::showData()\n{\n    setData(nullptr);\n\n    using namespace ThreadWeaver;\n    auto data = m_showBottomUpData ? m_bottomUpData : m_topDownData;\n    if (!data.resultData)\n        return;\n\n    m_buildingScene = true;\n    bool collapseRecursion = m_collapseRecursion;\n    auto source = m_costSource->currentData().value<CostType>();\n    auto threshold = m_costThreshold;\n    stream() << make_job([data, source, threshold, collapseRecursion, this]() {\n        auto parsedData = parseData(data, source, threshold, collapseRecursion);\n        QMetaObject::invokeMethod(this, "setData", Qt::QueuedConnection, Q_ARG(FrameGraphicsItem*, parsedData));\n    });\n}\n\nvoid FlameGraph::setTooltipItem(const FrameGraphicsItem* item)\n{\n    if (!item && m_selectedItem != -1 && m_selectionHistory.at(m_selectedItem)) {\n        item = m_selectionHistory.at(m_selectedItem);\n        m_view->setCursor(Qt::ArrowCursor);\n    } else {\n        m_view->setCursor(Qt::PointingHandCursor);\n    }\n    m_tooltipItem = item;\n    updateTooltip();\n}\n\nvoid FlameGraph::updateTooltip()\n{\n    const auto text = m_tooltipItem ? m_tooltipItem->description() : QString();\n    m_displayLabel->setToolTip(text);\n    const auto metrics = m_displayLabel->fontMetrics();\n    m_displayLabel->setText(metrics.elidedText(text, Qt::ElideRight, m_displayLabel->width()));\n}\n\nvoid FlameGraph::setData(FrameGraphicsItem* rootItem)\n{\n    m_scene->clear();\n    m_buildingScene = false;\n    m_tooltipItem = nullptr;\n    m_rootItem = rootItem;\n    m_selectionHistory.clear();\n    m_selectionHistory.push_back(rootItem);\n    m_selectedItem = 0;\n    updateNavigationActions();\n    if (!rootItem) {\n        auto text = m_scene->addText(i18n("generating flame graph..."));\n        m_view->centerOn(text);\n        m_view->setCursor(Qt::BusyCursor);\n        return;\n    }\n\n    m_view->setCursor(Qt::ArrowCursor);\n    // layouting needs a root item with a given height, the rest will be\n    // overwritten later\n    rootItem->setRect(0, 0, 800, m_view->fontMetrics().height() + 4);\n    m_scene->addItem(rootItem);\n\n    if (!m_searchInput->text().isEmpty()) {\n        setSearchValue(m_searchInput->text());\n    }\n\n    if (isVisible()) {\n        selectItem(m_rootItem);\n    }\n}\n\nvoid FlameGraph::selectItem(int item)\n{\n    m_selectedItem = item;\n    updateNavigationActions();\n    selectItem(m_selectionHistory.at(m_selectedItem));\n}\n\nvoid FlameGraph::selectItem(FrameGraphicsItem* item)\n{\n    if (!item) {\n        return;\n    }\n\n    // scale item and its parents to the maximum available width\n    // also hide all siblings of the parent items\n    const auto rootWidth = m_view->viewport()->width() - 40;\n    auto parent = item;\n    while (parent) {\n        auto rect = parent->rect();\n        rect.setLeft(0);\n        rect.setWidth(rootWidth);\n        parent->setRect(rect);\n        if (parent->parentItem()) {\n            const auto children = parent->parentItem()->childItems();\n            for (auto sibling : children) {\n                sibling->setVisible(sibling == parent);\n            }\n        }\n        parent = static_cast<FrameGraphicsItem*>(parent->parentItem());\n    }\n\n    // then layout all items below the selected on\n    layoutItems(item);\n\n    // and make sure it\'s visible\n    m_view->centerOn(item);\n\n    setTooltipItem(item);\n}\n\nvoid FlameGraph::setSearchValue(const QString& value)\n{\n    if (!m_rootItem) {\n        return;\n    }\n\n    auto match = applySearch(m_rootItem, value);\n\n    if (value.isEmpty()) {\n        m_searchResultsLabel->hide();\n    } else {\n        QString label;\n        const auto costFraction = Util::formatCostRelative(match.directCost, m_rootItem->cost());\n        switch (m_costSource->currentData().value<CostType>()) {\n        case Allocations:\n        case Temporary:\n            label = i18n("%1 (%2% of total of %3) allocations matched by search.", match.directCost, costFraction,\n                         m_rootItem->cost());\n            break;\n        case Peak:\n        case Leaked:\n            label = i18n("%1 (%2% of total of %3) matched by search.", Util::formatBytes(match.directCost),\n                         costFraction, Util::formatBytes(m_rootItem->cost()));\n            break;\n        }\n        m_searchResultsLabel->setText(label);\n        m_searchResultsLabel->show();\n    }\n}\n\nvoid FlameGraph::navigateBack()\n{\n    if (m_selectedItem > 0) {\n        selectItem(m_selectedItem - 1);\n    }\n}\n\nvoid FlameGraph::navigateForward()\n{\n    if ((m_selectedItem + 1) < m_selectionHistory.size()) {\n        selectItem(m_selectedItem + 1);\n    }\n}\n\nvoid FlameGraph::updateNavigationActions()\n{\n    const bool hasItems = m_selectedItem > 0;\n    const bool isNotLastItem = m_selectedItem + 1 < m_selectionHistory.size();\n    m_backAction->setEnabled(hasItems);\n    m_forwardAction->setEnabled(isNotLastItem);\n    m_resetAction->setEnabled(hasItems);\n    m_backButton->setEnabled(hasItems);\n    m_forwardButton->setEnabled(isNotLastItem);\n}\n'