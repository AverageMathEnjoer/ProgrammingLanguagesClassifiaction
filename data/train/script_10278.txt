b"{-# LANGUAGE PolyKinds #-}\n{-# LANGUAGE UndecidableInstances #-}\nmodule Database.Beam.Backend.SQL\n  ( module Database.Beam.Backend.SQL.Row\n  , module Database.Beam.Backend.SQL.SQL2003\n  , module Database.Beam.Backend.SQL.Types\n\n  , MonadBeam(..)\n\n  , BeamSqlBackend\n  , BeamSqlBackendSyntax\n  , MockSqlBackend\n\n  , BeamSqlBackendIsString\n\n  , BeamSql99ExpressionBackend\n  , BeamSql99AggregationBackend\n  , BeamSql99ConcatExpressionBackend\n  , BeamSql99CommonTableExpressionBackend\n  , BeamSql99RecursiveCTEBackend\n  , BeamSql2003ExpressionBackend\n\n  , BeamSqlT021Backend\n  , BeamSqlT071Backend\n  , BeamSqlT611Backend\n  , BeamSqlT612Backend\n  , BeamSqlT614Backend\n  , BeamSqlT615Backend\n  , BeamSqlT616Backend\n  , BeamSqlT618Backend\n  , BeamSqlT621Backend\n  , BeamSql99DataTypeBackend\n\n  , BeamSqlBackendSupportsOuterJoin\n\n  , BeamSqlBackendSelectSyntax\n  , BeamSqlBackendInsertSyntax\n  , BeamSqlBackendInsertValuesSyntax\n  , BeamSqlBackendUpdateSyntax\n  , BeamSqlBackendDeleteSyntax\n  , BeamSqlBackendCastTargetSyntax\n  , BeamSqlBackendSelectTableSyntax\n  , BeamSqlBackendAggregationQuantifierSyntax\n  , BeamSqlBackendSetQuantifierSyntax\n  , BeamSqlBackendFromSyntax\n  , BeamSqlBackendTableNameSyntax\n\n  , BeamSqlBackendExpressionSyntax\n  , BeamSqlBackendDataTypeSyntax\n  , BeamSqlBackendFieldNameSyntax\n  , BeamSqlBackendExpressionQuantifierSyntax\n  , BeamSqlBackendValueSyntax\n  , BeamSqlBackendOrderingSyntax\n  , BeamSqlBackendGroupingSyntax\n\n  , BeamSqlBackendWindowFrameSyntax\n  , BeamSqlBackendWindowFrameBoundsSyntax\n  , BeamSqlBackendWindowFrameBoundSyntax\n\n  , BeamSql99BackendCTESyntax\n\n  , BeamSqlBackendCanSerialize\n  , BeamSqlBackendCanDeserialize\n  , BeamSqlBackendSupportsDataType\n  ) where\n\nimport           Database.Beam.Backend.SQL.SQL2003\nimport           Database.Beam.Backend.SQL.Row\nimport           Database.Beam.Backend.SQL.Types\nimport           Database.Beam.Backend.Types\n\nimport           Control.Monad.Cont\nimport           Control.Monad.Except\nimport qualified Control.Monad.RWS.Lazy as Lazy\nimport qualified Control.Monad.RWS.Strict as Strict\nimport           Control.Monad.Reader\nimport qualified Control.Monad.State.Lazy as Lazy\nimport qualified Control.Monad.Writer.Lazy as Lazy\nimport qualified Control.Monad.State.Strict as Strict\nimport qualified Control.Monad.Writer.Strict as Strict\n\nimport           Data.Kind (Type)\nimport           Data.Tagged (Tagged)\nimport           Data.Text (Text)\n\n-- * MonadBeam class\n\n-- | A class that ties together a monad with a particular backend\n--\n--   Provided here is a low-level interface for executing commands. The 'run*'\n--   functions are wrapped by the appropriate functions in 'Database.Beam.Query'.\n--\n--   This interface is very high-level and isn't meant to expose the full power\n--   of the underlying database. Namely, it only supports simple data retrieval\n--   strategies. More complicated strategies (for example, Postgres's @COPY@)\n--   are supported in individual backends. See the documentation of those\n--   backends for more details.\nclass (BeamBackend be, Monad m) =>\n  MonadBeam be m | m -> be where\n  {-# MINIMAL runReturningMany #-}\n\n  -- | Run a query determined by the given syntax, providing an action that will\n  --   be called to consume the results from the database (if any). The action\n  --   will get a reader action that can be used to fetch the next row. When\n  --   this reader action returns 'Nothing', there are no rows left to consume.\n  --   When the reader action returns, the database result is freed.\n  runReturningMany :: FromBackendRow be x\n                   => BeamSqlBackendSyntax be\n                      -- ^ The query to run\n                   -> (m (Maybe x) -> m a)\n                       -- ^ Reader action that will be called with a function to\n                       -- fetch the next row\n                   -> m a\n\n  -- | Run the given command and don't consume any results. Useful for DML\n  --   statements like INSERT, UPDATE, and DELETE, or DDL statements.\n  runNoReturn :: BeamSqlBackendSyntax be -> m ()\n  runNoReturn cmd =\n      runReturningMany cmd $ \\(_ :: m (Maybe ())) -> pure ()\n\n  -- | Run the given command and fetch the unique result. The result is\n  --   'Nothing' if either no results are returned or more than one result is\n  --   returned.\n  runReturningOne :: FromBackendRow be x => BeamSqlBackendSyntax be -> m (Maybe x)\n  runReturningOne cmd =\n      runReturningMany cmd $ \\next ->\n        do a <- next\n           case a of\n             Nothing -> pure Nothing\n             Just x -> do\n               a' <- next\n               case a' of\n                 Nothing -> pure (Just x)\n                 Just _ -> pure Nothing\n\n  -- | Run the given command and fetch the first result. The result is\n  --   'Nothing' if no results are returned.\n  --   This is not guaranteed to automatically limit the query to one result.\n  runReturningFirst :: FromBackendRow be x => BeamSqlBackendSyntax be -> m (Maybe x)\n  runReturningFirst cmd = runReturningMany cmd id\n\n  -- | Run the given command, collect all the results, and return them as a\n  --   list. May be more convenient than 'runReturningMany', but reads the entire\n  --   result set into memory.\n  runReturningList :: FromBackendRow be x => BeamSqlBackendSyntax be -> m [x]\n  runReturningList cmd =\n      runReturningMany cmd $ \\next ->\n          let collectM acc = do\n                a <- next\n                case a of\n                  Nothing -> pure (acc [])\n                  Just x -> collectM (acc . (x:))\n          in collectM id\n\ninstance MonadBeam be m => MonadBeam be (ExceptT e m) where\n    runReturningMany s a = ExceptT $ runReturningMany s (\\nextRow -> runExceptT (a (lift nextRow)))\n    runNoReturn = lift . runNoReturn\n    runReturningOne = lift . runReturningOne\n    runReturningList = lift . runReturningList\n\ninstance MonadBeam be m => MonadBeam be (ContT r m) where\n    runReturningMany s a = ContT $ \\r ->\n                           runReturningMany s (\\nextRow -> runContT (a (lift nextRow)) r)\n    runNoReturn = lift . runNoReturn\n    runReturningOne = lift . runReturningOne\n    runReturningList = lift . runReturningList\n\ninstance MonadBeam be m => MonadBeam be (ReaderT r m) where\n    runReturningMany s a = ReaderT $ \\r ->\n                           runReturningMany s (\\nextRow -> runReaderT (a (lift nextRow)) r)\n    runNoReturn = lift . runNoReturn\n    runReturningOne = lift . runReturningOne\n    runReturningList = lift . runReturningList\n\ninstance MonadBeam be m => MonadBeam be (Lazy.StateT s m) where\n    runReturningMany s a = Lazy.StateT $ \\st ->\n                           runReturningMany s (\\nextRow -> Lazy.runStateT (a (lift nextRow)) st)\n    runNoReturn = lift . runNoReturn\n    runReturningOne = lift . runReturningOne\n    runReturningList = lift . runReturningList\n\ninstance MonadBeam be m => MonadBeam be (Strict.StateT s m) where\n    runReturningMany s a = Strict.StateT $ \\st ->\n                           runReturningMany s (\\nextRow -> Strict.runStateT (a (lift nextRow)) st)\n    runNoReturn = lift . runNoReturn\n    runReturningOne = lift . runReturningOne\n    runReturningList = lift . runReturningList\n\ninstance (MonadBeam be m, Monoid s) => MonadBeam be (Lazy.WriterT s m) where\n    runReturningMany s a = Lazy.WriterT $\n                           runReturningMany s (\\nextRow -> Lazy.runWriterT (a (lift nextRow)))\n    runNoReturn = lift . runNoReturn\n    runReturningOne = lift . runReturningOne\n    runReturningList = lift . runReturningList\n\ninstance (MonadBeam be m, Monoid s) => MonadBeam be (Strict.WriterT s m) where\n    runReturningMany s a = Strict.WriterT $\n                           runReturningMany s (\\nextRow -> Strict.runWriterT (a (lift nextRow)))\n    runNoReturn = lift . runNoReturn\n    runReturningOne = lift . runReturningOne\n    runReturningList = lift . runReturningList\n\ninstance (MonadBeam be m, Monoid w) => MonadBeam be (Lazy.RWST r w s m) where\n    runReturningMany s a = Lazy.RWST $ \\r st ->\n                           runReturningMany s (\\nextRow -> Lazy.runRWST (a (lift nextRow)) r st)\n    runNoReturn = lift . runNoReturn\n    runReturningOne = lift . runReturningOne\n    runReturningList = lift . runReturningList\n\ninstance (MonadBeam be m, Monoid w) => MonadBeam be (Strict.RWST r w s m) where\n    runReturningMany s a = Strict.RWST $ \\r st ->\n                           runReturningMany s (\\nextRow -> Strict.runRWST (a (lift nextRow)) r st)\n    runNoReturn = lift . runNoReturn\n    runReturningOne = lift . runReturningOne\n    runReturningList = lift . runReturningList\n\n-- * BeamSqlBackend\n\n-- | Class for all Beam SQL backends\nclass ( -- Every SQL backend must be a beam backend\n        BeamBackend be\n\n        -- Every SQL backend must have a reasonable SQL92 semantics\n      , IsSql92Syntax (BeamSqlBackendSyntax be)\n      , Sql92SanityCheck (BeamSqlBackendSyntax be)\n\n        -- Needed for several combinators\n      , HasSqlValueSyntax (BeamSqlBackendValueSyntax be) Bool\n      , HasSqlValueSyntax (BeamSqlBackendValueSyntax be) SqlNull\n\n        -- Needed for the Eq instance on QGenExpr\n      , Eq (BeamSqlBackendExpressionSyntax be)\n      ) => BeamSqlBackend be\n\ntype family BeamSqlBackendSyntax be :: Type\n\n-- | Fake backend that cannot deserialize anything, but is useful for testing\ndata MockSqlBackend syntax\n\nclass Trivial a\ninstance Trivial a\n\ninstance BeamBackend (MockSqlBackend syntax) where\n  type BackendFromField (MockSqlBackend syntax) = Trivial\n\ninstance ( IsSql92Syntax syntax\n         , Sql92SanityCheck syntax\n\n           -- Needed for several combinators\n         , HasSqlValueSyntax (Sql92ValueSyntax syntax) Bool\n         , HasSqlValueSyntax (Sql92ValueSyntax syntax) SqlNull\n\n           -- Needed for the Eq instance on QGenExpr\n         , Eq (Sql92ExpressionSyntax syntax)\n         ) => BeamSqlBackend (MockSqlBackend syntax)\ntype instance BeamSqlBackendSyntax (MockSqlBackend syntax) = syntax\n\n-- | Type class for things which are text-like in this backend\nclass BeamSqlBackendIsString be text\ninstance BeamSqlBackendIsString be t => BeamSqlBackendIsString be (Tagged tag t)\ninstance BeamSqlBackendIsString (MockSqlBackend cmd) Text\ninstance BeamSqlBackendIsString (MockSqlBackend cmd) [Char]\n\ntype BeamSql99ExpressionBackend be = IsSql99ExpressionSyntax (BeamSqlBackendExpressionSyntax be)\ntype BeamSql99ConcatExpressionBackend be = IsSql99ConcatExpressionSyntax (BeamSqlBackendExpressionSyntax be)\ntype BeamSql99CommonTableExpressionBackend be =\n    ( BeamSqlBackend be\n    , IsSql99CommonTableExpressionSelectSyntax (BeamSqlBackendSelectSyntax be)\n    , IsSql99CommonTableExpressionSyntax (BeamSql99BackendCTESyntax be)\n    , Sql99CTESelectSyntax (BeamSql99BackendCTESyntax be) ~ BeamSqlBackendSelectSyntax be )\ntype BeamSql99RecursiveCTEBackend be=\n    ( BeamSql99CommonTableExpressionBackend be\n    , IsSql99RecursiveCommonTableExpressionSelectSyntax (BeamSqlBackendSelectSyntax be) )\ntype BeamSql99AggregationBackend be = IsSql99AggregationExpressionSyntax (BeamSqlBackendExpressionSyntax be)\ntype BeamSql2003ExpressionBackend be = ( IsSql2003ExpressionSyntax (BeamSqlBackendExpressionSyntax be)\n                                       , Sql2003SanityCheck (BeamSqlBackendSyntax be) )\n\ntype BeamSqlBackendSupportsOuterJoin be = IsSql92FromOuterJoinSyntax (BeamSqlBackendFromSyntax be)\n\ntype BeamSqlT021Backend be = IsSql2003BinaryAndVarBinaryDataTypeSyntax (BeamSqlBackendCastTargetSyntax be)\ntype BeamSqlT071Backend be = IsSql2008BigIntDataTypeSyntax (BeamSqlBackendCastTargetSyntax be)\ntype BeamSqlT611Backend be = IsSql2003ExpressionElementaryOLAPOperationsSyntax (BeamSqlBackendExpressionSyntax be)\ntype BeamSqlT612Backend be = IsSql2003ExpressionAdvancedOLAPOperationsSyntax (BeamSqlBackendExpressionSyntax be)\ntype BeamSqlT614Backend be = IsSql2003NtileExpressionSyntax (BeamSqlBackendExpressionSyntax be)\ntype BeamSqlT615Backend be = IsSql2003LeadAndLagExpressionSyntax (BeamSqlBackendExpressionSyntax be)\ntype BeamSqlT616Backend be = IsSql2003FirstValueAndLastValueExpressionSyntax (BeamSqlBackendExpressionSyntax be)\ntype BeamSqlT618Backend be = IsSql2003NthValueExpressionSyntax (BeamSqlBackendExpressionSyntax be)\ntype BeamSqlT621Backend be =\n  ( IsSql2003EnhancedNumericFunctionsExpressionSyntax (BeamSqlBackendExpressionSyntax be)\n  , IsSql2003EnhancedNumericFunctionsAggregationExpressionSyntax (BeamSqlBackendExpressionSyntax be) )\n\ntype BeamSql99DataTypeBackend be =\n    ( BeamSqlBackend be\n    , IsSql99DataTypeSyntax (BeamSqlBackendCastTargetSyntax be) )\n\ntype BeamSqlBackendSelectSyntax be = Sql92SelectSyntax (BeamSqlBackendSyntax be)\ntype BeamSqlBackendInsertSyntax be = Sql92InsertSyntax (BeamSqlBackendSyntax be)\ntype BeamSqlBackendInsertValuesSyntax be = Sql92InsertValuesSyntax (BeamSqlBackendInsertSyntax be)\ntype BeamSqlBackendExpressionSyntax be = Sql92ExpressionSyntax (BeamSqlBackendSyntax be)\ntype BeamSqlBackendDataTypeSyntax be = Sql92ExpressionCastTargetSyntax (BeamSqlBackendExpressionSyntax be)\ntype BeamSqlBackendFieldNameSyntax be = Sql92ExpressionFieldNameSyntax (BeamSqlBackendExpressionSyntax be)\ntype BeamSqlBackendUpdateSyntax be = Sql92UpdateSyntax (BeamSqlBackendSyntax be)\ntype BeamSqlBackendDeleteSyntax be = Sql92DeleteSyntax (BeamSqlBackendSyntax be)\ntype BeamSqlBackendCastTargetSyntax be\n    = Sql92ExpressionCastTargetSyntax (BeamSqlBackendExpressionSyntax be)\ntype BeamSqlBackendExpressionQuantifierSyntax be = Sql92ExpressionQuantifierSyntax (Sql92ExpressionSyntax (BeamSqlBackendSyntax be))\ntype BeamSqlBackendValueSyntax be = Sql92ValueSyntax (BeamSqlBackendSyntax be)\ntype BeamSqlBackendSetQuantifierSyntax be = Sql92SelectTableSetQuantifierSyntax (BeamSqlBackendSelectTableSyntax be)\ntype BeamSqlBackendAggregationQuantifierSyntax be = Sql92AggregationSetQuantifierSyntax (BeamSqlBackendExpressionSyntax be)\ntype BeamSqlBackendSelectTableSyntax be = Sql92SelectSelectTableSyntax (BeamSqlBackendSelectSyntax be)\ntype BeamSqlBackendFromSyntax be = Sql92SelectFromSyntax (BeamSqlBackendSelectSyntax be)\ntype BeamSqlBackendTableNameSyntax be =  Sql92TableSourceTableNameSyntax (Sql92FromTableSourceSyntax (BeamSqlBackendFromSyntax be))\ntype BeamSqlBackendOrderingSyntax be = Sql92SelectOrderingSyntax (BeamSqlBackendSelectSyntax be)\ntype BeamSqlBackendGroupingSyntax be = Sql92SelectTableGroupingSyntax (BeamSqlBackendSelectTableSyntax be)\n\ntype BeamSqlBackendWindowFrameSyntax be = Sql2003ExpressionWindowFrameSyntax (BeamSqlBackendExpressionSyntax be)\ntype BeamSqlBackendWindowFrameBoundsSyntax be = Sql2003WindowFrameBoundsSyntax (BeamSqlBackendWindowFrameSyntax be)\ntype BeamSqlBackendWindowFrameBoundSyntax be = Sql2003WindowFrameBoundsBoundSyntax (BeamSqlBackendWindowFrameBoundsSyntax be)\n\ntype BeamSql99BackendCTESyntax be = Sql99SelectCTESyntax (BeamSqlBackendSelectSyntax be)\n\ntype BeamSqlBackendCanSerialize be = HasSqlValueSyntax (BeamSqlBackendValueSyntax be)\ntype BeamSqlBackendCanDeserialize be = FromBackendRow be\ntype BeamSqlBackendSupportsDataType be x =\n  ( BeamSqlBackendCanDeserialize be x\n  , BeamSqlBackendCanSerialize be x )\n"