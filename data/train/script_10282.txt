b'module GameDisplay (displayGame) where\n\nimport qualified Data.Map as M\nimport GameModel\n\nfirstDigitOf :: Int -> Char\nfirstDigitOf i = if i >= 10 then \'1\' else \'0\'\n\nlastDigitOf :: Int -> Char\nlastDigitOf i = case i `mod` 10 of\n  0 -> \'0\'\n  1 -> \'1\'\n  2 -> \'2\'\n  3 -> \'3\'\n  4 -> \'4\'\n  5 -> \'5\'\n  6 -> \'6\'\n  7 -> \'7\'\n  8 -> \'8\'\n  _ -> \'9\'\n\nshowDigits :: Int -> String\nshowDigits i = [firstDigitOf i, lastDigitOf i]\n\ndisplayGame :: Game -> M.Map Coord Int -> String\ndisplayGame (Game { gameGridSize = gridSize, gameStatus = status }) cnt =\n    "   " ++ map firstDigitOf [0..(gridSize - 1)] ++ "\\n" ++\n    "   " ++ map lastDigitOf [0..(gridSize - 1)] ++ "\\n" ++\n    concat [(showDigits y) ++ " " ++ renderRow y ++ "\\n" |\n            y <- [0..(gridSize - 1)]]\n  where\n    renderCoord :: Coord -> String\n    renderCoord coord =\n      case M.lookup coord status of\n        Just (CellStatus CellKnown CellMine) -> "*"\n        Just (CellStatus CellKnown CellNotMine) ->\n          case M.lookup coord cnt of\n            Just 0 -> " "\n            Just 1 -> "1"\n            Just 2 -> "2"\n            Just 3 -> "3"\n            Just 4 -> "4"\n            Just 5 -> "5"\n            Just 6 -> "6"\n            Just 7 -> "7"\n            _ -> "8"\n        _ -> "?"\n    renderRow :: Int -> String\n    renderRow y =\n      concat [renderCoord (Coord x y) | x <- [0..(gridSize - 1)]]\n'