b'#include <bits/stdc++.h>\n// http://www.spoj.com/problems/QTREE/\nusing namespace std;\n#define gc getchar_unlocked\n#define fo(i,n) for(i=0;i<n;i++)\n#define Fo(i,k,n) for(i=k;k<n?i<n:i>n;k<n?i+=1:i-=1)\n#define ll long long\n#define si(x)\tscanf("%d",&x)\n#define sl(x)\tscanf("%lld",&x)\n#define ss(s)\tscanf("%s",s)\n#define pi(x)\tprintf("%d\\n",x)\n#define pl(x)\tprintf("%lld\\n",x)\n#define ps(s)\tprintf("%s\\n",s)\n#define deb(x) cout << #x << "=" << x << endl\n#define deb2(x, y) cout << #x << "=" << x << "," << #y << "=" << y << endl\n#define pb push_back\n#define mp make_pair\n#define F first\n#define S second\n#define all(x) x.begin(), x.end()\n#define clr(x) memset(x, 0, sizeof(x))\n#define sortall(x) sort(all(x))\n#define tr(it, a) for(auto it = a.begin(); it != a.end(); it++)\n#define PI 3.1415926535897932384626\ntypedef pair<int, int>\tpii;\ntypedef pair<ll, ll>\tpl;\ntypedef vector<int>\t\tvi;\ntypedef vector<ll>\t\tvl;\ntypedef vector<pii>\t\tvpii;\ntypedef vector<pl>\t\tvpl;\ntypedef vector<vi>\t\tvvi;\ntypedef vector<vl>\t\tvvl;\nint mpow(int base, int exp); \nvoid ipgraph(int m);\nvoid dfs(int u, int par);\nconst int mod = 1000000007;\nconst int N = 3e5, M = N;\n//=======================\nstruct node{int v, w, i;};\nvector<node> g[N];\nint a[N], pos[N], arr[N];\nint sz[N], lvl[N], rep[N];\nint P[N][20], n;\nint chainNo, ptr;\nint chainOf[N], chainHead[N];\nint tree[4*N];\n\nvoid dfs(int u, int par){\n    sz[u] = 1;\n    lvl[u] = 1+lvl[par];\n    P[u][0] = par;\n\tfor(node to:g[u]){\n\t\tint v = to.v;\n\t\tif (v == par) continue;\n\t\trep[to.i] = v;\n\t\tdfs(v, u);\n\t\tsz[u] += sz[v];\n\t}\n}\n\nint lca(int u, int v){\n    int i, lg;\n    if (lvl[u] < lvl[v]) swap(u, v);\n    for(lg = 0; (1<<lg) <= lvl[u]; lg++);\n    lg--;\n    for(i=lg; i>=0; i--){\n        if (lvl[u] - (1<<i) >= lvl[v])\n            u = P[u][i];\n    }\n    if (u == v) return u;\n    for(i=lg; i>=0; i--){\n        if (P[u][i] != -1 and P[u][i] != P[v][i])\n            u = P[u][i], v = P[v][i];\n    }\n    return P[u][0];\n}\nvoid init(){\n\tint i, j;\n\tFo(i, 0, n+1) g[i].clear();\n\tptr = 0, chainNo = 1;\n\tsz[0] = arr[0] = 0;\n\tlvl[0] = -1;\n\tFo(i, 0, n+1) {\n\t\tchainHead[i] = -1;\n\t\tpos[i] = arr[i] = 0;\n\t\tFo(j, 0, 20) P[i][j] = -1;\n\t}\n}\nint range_query(int rt, int lo, int hi, int x, int y){\n\tif(lo == x and hi == y) return tree[rt];\n\tint l = 2*rt, r = l+1, mid = (lo+hi)>>1;\n\tif(y <= mid) return range_query(l, lo, mid, x, y);\n\tif(x > mid) return range_query(r, mid+1, hi, x, y);\n\treturn max(range_query(l, lo, mid, x, mid), range_query(r, mid+1, hi, mid+1, y));\n}\nint query_up(int u, int v){\n\tif(u == v) return 0;\n\tif(lvl[u] < lvl[v]) swap(u, v);\n\tint uchain, vchain = chainOf[v];\n\tint ans = 0;\n\twhile(1){\n\t\tuchain = chainOf[u];\n\t\tif(uchain == vchain){\n\t\t\tif(u == v) return ans;\n\t\t\tans = max(ans, range_query(1, 0, ptr, pos[v]+1, pos[u]));\n\t\t\treturn ans;\n\t\t}\n\t\tans = max(ans, range_query(1, 0, ptr, pos[chainHead[uchain]], pos[u]));\n\t\tu = chainHead[uchain];\n\t\tu = P[u][0];\n\t}\n\treturn ans;\n}\nvoid hld(int u, int cost, int par){\n\tif(chainHead[chainNo] == -1) \n\t\tchainHead[chainNo] = u;\n\tchainOf[u] = chainNo;\n\tpos[u] = ++ptr;\n\tarr[ptr] = cost;\n\tint sc = 0, w;\n\tfor(node to: g[u]){\n\t\tint v = to.v;\n\t\tif(v == par) continue;\n\t\tif(sz[sc] < sz[v])sc = v, w = to.w;\n \t}\n\tif(sc) hld(sc, w, u);\n\tfor(node to: g[u]){\n\t\tint v = to.v;\n\t\tif(v == par or v == sc) continue;\n\t\tchainNo++;\n\t\thld(v, to.w, u);\n \t}\n}\nvoid build(int rt, int lo, int hi){\n\tif(lo == hi){\n\t\ttree[rt] = arr[lo];\n\t\treturn;\n\t}\n\tint l = 2*rt, r = l+1, mid = (lo+hi)>>1;\n\tbuild(l, lo, mid);\n\tbuild(r, mid+1, hi);\n\ttree[rt] = max(tree[l], tree[r]);\n}\nvoid update(int rt, int lo, int hi, int pos, int val){\n\tif(lo == hi){\n\t\ttree[rt] = val;\n\t\treturn;\n\t}\n\tint l = 2*rt, r = l+1, mid = (lo+hi)>>1;\n\tif(pos<=mid) update(l, lo, mid, pos, val);\n\telse update(r, 1+mid, hi, pos, val);\n\ttree[rt] = max(tree[l], tree[r]);\n}\n\nint query(int u, int v){\n\tint w = lca(u, v);\n\tint ans = max(query_up(u, w), query_up(v, w));\n\treturn ans;\n}\nvoid change(int i, int val){\n\tint u = rep[i];\n\tupdate(1, 0, ptr, pos[u], val);\n}\nvoid compute(){\n\tint i, j;\n\tdfs(1, 0);\n\tfor(i=1; i<20; i++){\n        Fo(j, 1, n+1)\n            if (P[j][i-1] != -1)\n                P[j][i] = P[P[j][i-1]][i-1];\n\t}\n\thld(1, 0, 0);\n\t//make segment tree now\n\tassert(ptr == n);\n\tbuild(1, 0, ptr);\n}\nvoid solve(){\n\tint i;\n\tsi(n);\n\tinit();\n\tint u, v, w;\n\tchar s[10];\n\tfo(i, n-1){\n\t\tsi(u);\n\t\tsi(v);\n\t\tsi(w);\n\t\tg[u].pb({v, w, i+1});\n\t\tg[v].pb({u, w, i+1});\n\t}\n\tcompute();\n\tss(s);\n\twhile(1){\n\t\tif(s[0] == \'D\') break;\n\t\tsi(u); si(v);\n\t\tif(s[0] == \'C\'){\n\t\t\tchange(u, v);\n\t\t}\n\t\telse{\n\t\t\tpi(query(u, v));\n\t\t}\n\t\tss(s);\n\t}\n}\nint main()\n{\n\tios_base::sync_with_stdio(false);\n\tcin.tie(NULL);\n\tint i,k,j;\n\tint t;\n\tsi(t);\n\twhile(t--) solve();\n\treturn 0;\n} \n'