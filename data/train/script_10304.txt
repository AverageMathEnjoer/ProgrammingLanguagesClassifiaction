b'/**\n * Copyright (C) 2019 Fernando Cejas Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the "License");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an "AS IS" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.fernandocejas.sample.core.functional\n\n/**\n * Represents a value of one of two possible types (a disjoint union).\n * Instances of [Either] are either an instance of [Left] or [Right].\n * FP Convention dictates that [Left] is used for "failure"\n * and [Right] is used for "success".\n *\n * @see Left\n * @see Right\n */\nsealed class Either<out L, out R> {\n    /** * Represents the left side of [Either] class which by convention is a "Failure". */\n    data class Left<out L>(val a: L) : Either<L, Nothing>()\n\n    /** * Represents the right side of [Either] class which by convention is a "Success". */\n    data class Right<out R>(val b: R) : Either<Nothing, R>()\n\n    /**\n     * Returns true if this is a Right, false otherwise.\n     * @see Right\n     */\n    val isRight get() = this is Right<R>\n\n    /**\n     * Returns true if this is a Left, false otherwise.\n     * @see Left\n     */\n    val isLeft get() = this is Left<L>\n\n    /**\n     * Creates a Left type.\n     * @see Left\n     */\n    fun <L> left(a: L) = Either.Left(a)\n\n\n    /**\n     * Creates a Left type.\n     * @see Right\n     */\n    fun <R> right(b: R) = Either.Right(b)\n\n    /**\n     * Applies fnL if this is a Left or fnR if this is a Right.\n     * @see Left\n     * @see Right\n     */\n    fun fold(fnL: (L) -> Any, fnR: (R) -> Any): Any =\n        when (this) {\n            is Left -> fnL(a)\n            is Right -> fnR(b)\n        }\n}\n\n/**\n * Composes 2 functions\n * See <a href="https://proandroiddev.com/kotlins-nothing-type-946de7d464fb">Credits to Alex Hart.</a>\n */\nfun <A, B, C> ((A) -> B).c(f: (B) -> C): (A) -> C = {\n    f(this(it))\n}\n\n/**\n * Right-biased flatMap() FP convention which means that Right is assumed to be the default case\n * to operate on. If it is Left, operations like map, flatMap, ... return the Left value unchanged.\n */\nfun <T, L, R> Either<L, R>.flatMap(fn: (R) -> Either<L, T>): Either<L, T> =\n    when (this) {\n        is Either.Left -> Either.Left(a)\n        is Either.Right -> fn(b)\n    }\n\n/**\n * Right-biased map() FP convention which means that Right is assumed to be the default case\n * to operate on. If it is Left, operations like map, flatMap, ... return the Left value unchanged.\n */\nfun <T, L, R> Either<L, R>.map(fn: (R) -> (T)): Either<L, T> = this.flatMap(fn.c(::right))\n\n/** Returns the value from this `Right` or the given argument if this is a `Left`.\n *  Right(12).getOrElse(17) RETURNS 12 and Left(12).getOrElse(17) RETURNS 17\n */\nfun <L, R> Either<L, R>.getOrElse(value: R): R =\n    when (this) {\n        is Either.Left -> value\n        is Either.Right -> b\n    }\n\n/**\n * Left-biased onFailure() FP convention dictates that when this class is Left, it\'ll perform\n * the onFailure functionality passed as a parameter, but, overall will still return an either\n * object so you chain calls.\n */\nfun <L, R> Either<L, R>.onFailure(fn: (failure: L) -> Unit): Either<L, R> =\n    this.apply { if (this is Either.Left) fn(a) }\n\n/**\n * Right-biased onSuccess() FP convention dictates that when this class is Right, it\'ll perform\n * the onSuccess functionality passed as a parameter, but, overall will still return an either\n * object so you chain calls.\n */\nfun <L, R> Either<L, R>.onSuccess(fn: (success: R) -> Unit): Either<L, R> =\n    this.apply { if (this is Either.Right) fn(b) }\n'