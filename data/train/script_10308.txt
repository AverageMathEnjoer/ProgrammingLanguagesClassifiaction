b'{-# LANGUAGE UndecidableInstances #-}\n{-# LANGUAGE DeriveAnyClass #-}\n\nmodule Database.Beam.Test.Schema\n  ( EmployeeT(..), DepartmentT(..)\n  , RoleT(..), FunnyT (..)\n  , EmployeeDb(..)\n  , PrimaryKey(..)\n\n  , DummyBackend\n\n  , employeeDbSettings\n\n  , tests ) where\n\nimport           Database.Beam\nimport           Database.Beam.Schema.Tables\nimport           Database.Beam.Backend\n\nimport           Data.Int\nimport           Data.List.NonEmpty ( NonEmpty((:|)) )\nimport           Data.Text (Text)\nimport qualified Data.Text as T\nimport           Data.Time.Clock (UTCTime)\n\nimport           Test.Tasty\nimport           Test.Tasty.HUnit\n\ntests :: TestTree\ntests = testGroup "Schema Tests"\n                  [ basicSchemaGeneration\n                  , ruleBasedRenaming\n                  , parametricBeamSchemaGeneration\n                  , parametricAndFixedNestedBeamsAreEquivalent\n--                  , automaticNestedFieldsAreUnset\n--                  , nullableForeignKeysGivenMaybeType\n                  , underscoresAreHandledGracefully ]\n--                  , dbSchemaGeneration ]\n--                  , dbSchemaModification ]\n\ndata DummyBackend\n\ninstance BeamBackend DummyBackend where\n  -- Pretty much everything we can shove in a database satisfies show\n  type BackendFromField DummyBackend = Show\n\ndata EmployeeT f\n  = EmployeeT\n  { _employeeFirstName :: Columnar f Text\n  , _employeeLastName  :: Columnar f Text\n  , _employeePhoneNumber :: Columnar f Text\n\n  , _employeeAge       :: Columnar f Int32\n  , _employeeSalary    :: Columnar f Double\n\n  , _employeeHireDate  :: Columnar f UTCTime\n  , _employeeLeaveDate :: Columnar f (Maybe UTCTime)\n\n  , _employeeCreated :: Columnar f UTCTime\n  } deriving Generic\ninstance Beamable EmployeeT\ninstance Table EmployeeT where\n  data PrimaryKey EmployeeT f = EmployeeId (Columnar f Text) (Columnar f Text) (Columnar f UTCTime)\n    deriving Generic\n  primaryKey e = EmployeeId (_employeeFirstName e) (_employeeLastName e) (_employeeCreated e)\ninstance Beamable (PrimaryKey EmployeeT)\nderiving instance Show (TableSettings EmployeeT)\nderiving instance Eq (TableSettings EmployeeT)\nderiving instance (Show (Columnar f Text), Show (Columnar f UTCTime)) => Show (PrimaryKey EmployeeT f)\nderiving instance (Eq (Columnar f Text), Eq (Columnar f  UTCTime)) => Eq (PrimaryKey EmployeeT f)\n\n-- * Verify that the schema is generated properly\n\nemployeeTableSchema :: TableSettings EmployeeT\nemployeeTableSchema = defTblFieldSettings\n\nexpectedEmployeeTableSchema :: TableSettings EmployeeT\nexpectedEmployeeTableSchema =\n  EmployeeT { _employeeFirstName = TableField (pure "_employeeFirstName") "first_name"\n            , _employeeLastName = TableField (pure "_employeeLastName") "last_name"\n            , _employeePhoneNumber = TableField (pure "_employeePhoneNumber") "phone_number"\n            , _employeeAge = TableField (pure "_employeeAge") "age"\n            , _employeeSalary = TableField (pure "_employeeSalary") "salary"\n            , _employeeHireDate = TableField (pure "_employeeHireDate") "hire_date"\n            , _employeeLeaveDate = TableField (pure "_employeeLeaveDate") "leave_date"\n            , _employeeCreated = TableField (pure "_employeeCreated") "created"\n            }\n\nbasicSchemaGeneration :: TestTree\nbasicSchemaGeneration =\n  testCase "Basic Schema Generation" $\n  do _employeeFirstName employeeTableSchema @?= _employeeFirstName expectedEmployeeTableSchema\n     _employeeLastName employeeTableSchema @?= _employeeLastName expectedEmployeeTableSchema\n     _employeePhoneNumber employeeTableSchema @?= _employeePhoneNumber expectedEmployeeTableSchema\n     _employeeAge employeeTableSchema @?= _employeeAge expectedEmployeeTableSchema\n     _employeeSalary employeeTableSchema @?= _employeeSalary expectedEmployeeTableSchema\n     _employeeHireDate employeeTableSchema @?= _employeeHireDate expectedEmployeeTableSchema\n     _employeeLeaveDate employeeTableSchema @?= _employeeLeaveDate expectedEmployeeTableSchema\n     _employeeCreated employeeTableSchema @?= _employeeCreated expectedEmployeeTableSchema\n\n-- * Ensure that automatic fields are unset when nesting\n\ndata RoleT f\n  = RoleT\n  { _roleForEmployee :: PrimaryKey EmployeeT f\n  , _roleName :: Columnar f Text\n  , _roleStarted :: Columnar f UTCTime }\n  deriving Generic\ninstance Beamable RoleT\ninstance Table RoleT where\n  data PrimaryKey RoleT f = RoleId (PrimaryKey EmployeeT f) (Columnar f UTCTime)\n    deriving Generic\n  primaryKey (RoleT e _ s) = RoleId e s\ninstance Beamable (PrimaryKey RoleT)\nderiving instance Show (TableSettings (PrimaryKey RoleT))\nderiving instance Eq (TableSettings (PrimaryKey RoleT))\n\n-- * Ensure that fields of a nullable primary key are given the proper Maybe type\n\ndata DepartmentT f\n  = DepartmentT\n  { _departmentName :: Columnar f Text\n  , _departmentHead :: PrimaryKey EmployeeT (Nullable f) -- ^ Departments may currently lack a department head\n  } deriving Generic\ninstance Beamable DepartmentT\ninstance Table DepartmentT where\n  data PrimaryKey DepartmentT f = DepartmentId (Columnar f Text) deriving Generic\n  primaryKey (DepartmentT name _) = DepartmentId name\ninstance Beamable (PrimaryKey DepartmentT)\nderiving instance Show (TableSettings DepartmentT)\nderiving instance Eq (TableSettings DepartmentT)\n\n-- nullableForeignKeysGivenMaybeType :: TestTree\n-- nullableForeignKeysGivenMaybeType =\n--   testCase "Nullable foreign keys are given maybe type" $\n--   do _departmentHead departmentTableSchema @?=\n--        EmployeeId (TableField "head__first_name" (DummyField True False (DummyFieldMaybe DummyFieldText)))\n--                   (TableField "head__last_name" (DummyField True False (DummyFieldMaybe DummyFieldText)))\n--                   (TableField "head__created" (DummyField True False (DummyFieldMaybe DummyFieldUTCTime)))\n\n-- * Ensure that fields with underscores are handled properly\n\ndata FunnyT f\n  = FunnyT\n  { funny_field1 :: Columnar f Text\n  , funny_field_2 :: Columnar f Text\n  , funny_first_name :: Columnar f Text\n  , _funny_lastName :: Columnar f Text\n  , _funny_middle_Name :: Columnar f Text\n  , ___ :: Columnar f Int32 }\n  deriving Generic\ninstance Beamable FunnyT\ninstance Table FunnyT where\n  data PrimaryKey FunnyT f = FunnyId (Columnar f Text) deriving Generic\n  primaryKey = FunnyId . funny_field1\ninstance Beamable (PrimaryKey FunnyT)\n\nfunnyTableSchema :: TableSettings FunnyT\nfunnyTableSchema = defTblFieldSettings\n\nunderscoresAreHandledGracefully :: TestTree\nunderscoresAreHandledGracefully =\n  testCase "Underscores in field names are handled gracefully" $\n  do let fieldNames = allBeamValues (\\(Columnar\' f) -> (_fieldPath f, _fieldName f)) funnyTableSchema\n     fieldNames @?= [ ( pure "funny_field1", "funny_field1")\n                    , ( pure "funny_field_2", "funny_field_2")\n                    , ( pure "funny_first_name", "funny_first_name")\n                    , ( pure "_funny_lastName", "funny_lastName")\n                    , ( pure "_funny_middle_Name", "funny_middle_Name")\n                    , ( pure "___", "___") ]\n\nruleBasedRenaming :: TestTree\nruleBasedRenaming =\n  testCase "Rule based renaming works correctly" $\n  do let (DatabaseEntity (DatabaseTable { dbTableSettings = funny })) = _funny employeeDbSettingsRuleMods\n         (DatabaseEntity (DatabaseTable { dbTableSettings = departments })) = _departments employeeDbSettingsRuleMods\n\n         funnyFieldNames = allBeamValues (\\(Columnar\' f) -> (_fieldPath f, _fieldName f)) funny\n         deptFieldNames = allBeamValues (\\(Columnar\' f) -> (_fieldPath f, _fieldName f)) departments\n\n     funnyFieldNames @?= [ ( pure "funny_field1", "pfx_funny_field1")\n                         , ( pure "funny_field_2", "pfx_funny_field_2")\n                         , ( pure "funny_first_name", "pfx_funny_first_name")\n                         , ( pure "_funny_lastName", "pfx_funny_lastName")\n                         , ( pure "_funny_middle_Name", "pfx_funny_middle_Name")\n                         , ( pure "___", "___") ]\n\n     deptFieldNames @?= [ (pure "_departmentName", "name")\n                        , ( "_departmentHead" :| [ "_employeeFirstName" ], "head__first_name")\n                        , ( "_departmentHead" :| [ "_employeeLastName" ], "head__last_name")\n                        , ( "_departmentHead" :| [ "_employeeCreated" ], "head__created") ]\n\n-- * Ensure it is possible to use nested paremetric beams\nparametricBeamSchemaGeneration :: TestTree\nparametricBeamSchemaGeneration =\n  testCase "Parametric schema generation" $\n  do let (DatabaseEntity (DatabaseTable { dbTableSettings = deptVehiculesA })) = _departmentVehiculesA employeeDbSettings\n         deptVehiculesFieldNamesA = allBeamValues (\\(Columnar\' f) -> (_fieldPath f, _fieldName f)) deptVehiculesA\n\n     deptVehiculesFieldNamesA @?= [ ( "_aDepartament" :| [ "_departmentName" ] , "departament__name")\n                                  , ( "_aRelatesTo"   :| [ "_vehiculeId" ], "relates_to__id")\n                                  , ( "_aRelatesTo"   :| [ "_vehiculeType" ], "relates_to__type")\n                                  , ( "_aRelatesTo"   :| [ "_numberOfWheels" ], "relates_to__of_wheels")\n                                  , ( "_aMetaInfo"    :| [ "_price" ], "meta_info__price")\n                                  ]\n\n-- * Ensure it doesn\'t matter whether we abstract over a beam\'s parameters, or if we them fixed.\nparametricAndFixedNestedBeamsAreEquivalent :: TestTree\nparametricAndFixedNestedBeamsAreEquivalent =\n  testCase "Parametric and fixed nested beams are equivalent" $\n  do let (DatabaseEntity (DatabaseTable { dbTableSettings = deptVehiculesA })) = _departmentVehiculesA employeeDbSettings\n         (DatabaseEntity (DatabaseTable { dbTableSettings = deptVehiculesB })) = _departmentVehiculesB employeeDbSettings\n         deptVehiculesFieldNamesA = allBeamValues (\\(Columnar\' f) -> _fieldName f) deptVehiculesA\n         deptVehiculesFieldNamesB = allBeamValues (\\(Columnar\' f) -> _fieldName f) deptVehiculesB\n\n     deptVehiculesFieldNamesB @?= deptVehiculesFieldNamesA\n\n\n-- `ADepartmentVehiculeT` and `BDepartmentVehiculeT` are equivalent, but one was using params while\n-- the other had its sub-beams fixed.\n\ntype ADepartmentVehiculeT  = DepartamentRelatedT VehiculeInformationT VehiculeT\ndata DepartamentRelatedT metaInfo prop f = DepartamentProperty\n      { _aDepartament  :: PrimaryKey DepartmentT f\n      , _aRelatesTo    :: prop f                -- checking we can nest both, nullable and non-nullable beams.\n      , _aMetaInfo     :: metaInfo (Nullable f)\n      } deriving Generic\n\ndata BDepartmentVehiculeT f = BDepartmentVehicule\n      { _bDepartament  :: PrimaryKey DepartmentT f\n      , _bRelatesTo    :: VehiculeT f\n      , _bMetaInfo     :: VehiculeInformationT (Nullable f)\n      } deriving Generic\n\ninstance (Beamable metaInfo, Beamable  prop) => Beamable (DepartamentRelatedT metaInfo prop)\n\n\ninstance (Table metaInfo, Table  prop) => Table    (DepartamentRelatedT metaInfo prop) where\n  data PrimaryKey (DepartamentRelatedT metaInfo prop) f = DepReKeyA (PrimaryKey DepartmentT f)\n                                                                    (PrimaryKey prop f)\n                                                                    deriving(Generic)\n  primaryKey = DepReKeyA <$> _aDepartament <*> (primaryKey._aRelatesTo)\n\ninstance (Table metaInfo, Table prop) => Beamable (PrimaryKey (DepartamentRelatedT metaInfo prop))\n\n\n\ndata VehiculeT f = VehiculeT\n      { _vehiculeId     :: C f Text\n      , _vehiculeType   :: C f Text\n      , _numberOfWheels :: C f Int32\n      } deriving Generic\n\ninstance Beamable VehiculeT\ninstance Beamable (PrimaryKey VehiculeT)\n\ninstance Table VehiculeT where\n     data PrimaryKey VehiculeT f = VehiculeId  (C f Text) deriving(Generic)\n     primaryKey = VehiculeId <$> _vehiculeId\n\ndata VehiculeInformationT f = VehiculeInformationT\n      { _price          :: C f Double\n      } deriving Generic\n\n\ninstance Beamable VehiculeInformationT\ninstance Beamable (PrimaryKey VehiculeInformationT)\n\ninstance Table VehiculeInformationT where\n     data PrimaryKey VehiculeInformationT f = VehiculeInformationKey  deriving(Generic)\n     primaryKey _ = VehiculeInformationKey\n\ninstance Beamable BDepartmentVehiculeT\ninstance Beamable (PrimaryKey BDepartmentVehiculeT)\ninstance Table BDepartmentVehiculeT where\n  data PrimaryKey BDepartmentVehiculeT f = DepReKeyB (PrimaryKey DepartmentT f)\n                                                     (PrimaryKey VehiculeT   f)\n                                                     deriving(Generic)\n  primaryKey = DepReKeyB <$> _bDepartament <*> (primaryKey._bRelatesTo)\n\ndata NoPrimaryKeyT f\n    = NoPrimaryKeyT\n    { _npkField1 :: C f Text\n    , _npkField2 :: C f Double\n    } deriving Generic\ninstance Beamable NoPrimaryKeyT\ninstance Table NoPrimaryKeyT where\n    data PrimaryKey NoPrimaryKeyT f = NoPrimaryKey\n        deriving Generic\n    primaryKey _ = NoPrimaryKey\ninstance Beamable (PrimaryKey NoPrimaryKeyT)\n\n-- * Database schema is derived correctly\n\ndata EmployeeDb f\n  = EmployeeDb\n    { _employees            :: f (TableEntity EmployeeT)\n    , _departments          :: f (TableEntity DepartmentT)\n    , _roles                :: f (TableEntity RoleT)\n    , _funny                :: f (TableEntity FunnyT)\n    , _departmentVehiculesA :: f (TableEntity ADepartmentVehiculeT)\n    , _departmentVehiculesB :: f (TableEntity BDepartmentVehiculeT)\n    , _noPrimaryKey         :: f (TableEntity NoPrimaryKeyT)\n    } deriving Generic\ninstance Database be EmployeeDb\n\nemployeeDbSettings :: DatabaseSettings be EmployeeDb\nemployeeDbSettings = defaultDbSettings\n\nemployeeDbSettingsRuleMods :: DatabaseSettings be EmployeeDb\nemployeeDbSettingsRuleMods = defaultDbSettings `withDbModification`\n                             renamingFields (\\field ->\n                                                let defName = defaultFieldName field\n                                                in case T.stripPrefix "funny" defName of\n                                                  Nothing -> defName\n                                                  Just _ -> "pfx_" <> defName)\n\n-- employeeDbSettingsModified :: DatabaseSettings EmployeeDb\n-- employeeDbSettingsModified =\n--   defaultDbSettings `withDbModifications`\n--   (modifyingDb { _employees = tableModification (\\_ -> "emps") tableFieldsModification\n--                , _departments = tableModification (\\_ -> "depts")\n--                                                   (tableFieldsModification\n--                                                     { _departmentName = fieldModification (\\_ -> "depts_name") id }) })\n\n-- dbSchemaGeneration :: TestTree\n-- dbSchemaGeneration =\n--   testCase "Database schema generation" $\n--   do let names = allTables (\\(DatabaseTable _ nm _) -> nm) employeeDbSettings\n--      names @?= [ "employees"\n--                , "departments"\n--                , "roles"\n--                , "funny" ]\n\n-- dbSchemaModification :: TestTree\n-- dbSchemaModification =\n--   testCase "Database schema modification" $\n--   do let names = allTables (\\(DatabaseTable _ nm _ ) -> nm) employeeDbSettingsModified\n--      names @?= [ "emps"\n--                , "depts"\n--                , "roles"\n--                , "funny" ]\n\n--      let DatabaseTable _ _ departmentT = _departments employeeDbSettingsModified\n--      departmentT @?= DepartmentT (TableField "depts_name" (DummyField False False DummyFieldText))\n--                                  (EmployeeId (TableField "head__first_name" (DummyField True False (DummyFieldMaybe DummyFieldText)))\n--                                              (TableField "head__last_name" (DummyField True False (DummyFieldMaybe DummyFieldText)))\n--                                              (TableField "head__created" (DummyField True False (DummyFieldMaybe DummyFieldUTCTime))))\n'