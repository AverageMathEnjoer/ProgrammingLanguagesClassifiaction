b'#include "../AssetsTools/TextureFileFormat.h"\n#include <crnlib.h>\n#include <crn_decomp.h>\n#include <thread>\n#include <vector>\n\n//Recursive ## macro evaluation (required for WRAPSUFFIX) needs extra layers\n//https://stackoverflow.com/a/1597129\n#define _CONCAT(a,b) a ## b\n#define _WN2(a, b) _CONCAT(a, b)\n#define _WN(NAME) _WN2(NAME,WRAPSUFFIX)\n#define API __declspec(dllexport)\n\nstatic crn_bool CrunchProcessCallback(crn_uint32 phase_index, crn_uint32 total_phases, crn_uint32 subphase_index, crn_uint32 total_subphases, void* pUser_data_ptr)\n{\n\t//int percentage_complete = (int)(.5f + (phase_index + float(subphase_index) / total_subphases) * 100.0f) / total_phases;\n\t//printf("\\b\\b\\b\\b\\b\\b\\b\\b\\b\\b\\b\\b\\b\\b\\b\\b\\bProcessing: %u%%", std::min(100, std::max(0, percentage_complete)));\n\treturn true;\n}\nAPI bool _WN(CrunchTextureData_RGBA32_)(TextureFile* pTex, const void* pRGBA32Buf,\n\tvoid* pOutBuf, QWORD& outputSize, int compressQuality, unsigned int curWidth, unsigned int curHeight)\n{\n\tcrn_comp_params compPars; compPars.clear();\n\tcompPars.m_width = curWidth;\n\tcompPars.m_height = curHeight;\n\tcompPars.m_levels = 1;//(mipMapOffsets.size() > cCRNMaxLevels) ? cCRNMaxLevels : (crn_uint32)mipMapOffsets.size();\n\tcompPars.m_file_type = cCRNFileTypeCRN;\n\tswitch (pTex->m_TextureFormat)\n\t{\n\tcase TexFmt_DXT1Crunched:\n\t\tcompPars.m_format = cCRNFmtDXT1;\n\t\tbreak;\n\tcase TexFmt_DXT5Crunched:\n\t\tcompPars.m_format = cCRNFmtDXT5;\n\t\tbreak;\n\tcase TexFmt_ETC_RGB4Crunched:\n\t\tcompPars.m_format = cCRNFmtETC1;\n\t\tpTex->extra.textureFormatVersion = 1;\n\t\tbreak;\n#ifdef HAS_ETC2\n\tcase TexFmt_ETC2_RGBA8Crunched:\n\t\tcompPars.m_format = cCRNFmtETC2A;\n\t\tpTex->extra.textureFormatVersion = 1;\n\t\tbreak;\n#endif\n\tdefault:\n\t\treturn false;\n\t}\n\tcompPars.m_pImages[0][0] = (crn_uint32*)pRGBA32Buf;\n\t//compPars.m_quality_level = 255;\n\tcompPars.m_num_helper_threads = 0;//(compressQuality >= 1) ? (compressQuality - 1) : 1;\n\tcompPars.m_pProgress_func = CrunchProcessCallback;\n\n\tuint32_t maxNumThreads = std::thread::hardware_concurrency();\n\tif (maxNumThreads == 0) maxNumThreads = 2;\n\t//16==cCRNMaxHelperThreads+1 for Unity, cCRNMaxHelperThreads for Legacy\n\t// (the legacy version constant was too high by one,\n\t//  since \'helper threads\' mean all threads but the main compression thread).\n\t//Assuming we can have 16 threads total.\n\tif (maxNumThreads > 16) maxNumThreads = 16;\n\tbool mt = false;\n\tswitch (compressQuality)\n\t{\n\tcase 1: compPars.m_num_helper_threads = maxNumThreads - 1; //normal mt\n\tcase 0: //normal\n\tdefault:\n\t\tcompPars.m_quality_level = 128;\n\t\tbreak;\n\tcase 3: compPars.m_num_helper_threads = maxNumThreads - 1; //very fast mt\n\tcase 2: //very fast\n\t\tcompPars.m_quality_level = 0; //cCRNMinQualityLevel\n\t\tbreak;\n\tcase 5: compPars.m_num_helper_threads = maxNumThreads - 1; //slow mt\n\tcase 4: //slow\n\t\tcompPars.m_quality_level = 255; //cCRNMaxQualityLevel\n\t\tbreak;\n\t}\n\tcompPars.m_userdata0 = CRNVERSION;\n\n\tcrn_mipmap_params mipPars; mipPars.clear();\n\tmipPars.m_gamma_filtering = false;\n\tmipPars.m_max_levels = (pTex->m_MipCount > cCRNMaxLevels) ? cCRNMaxLevels : pTex->m_MipCount;\n\tif (mipPars.m_max_levels < 1) mipPars.m_max_levels = 1;\n\tmipPars.m_mode = (pTex->m_MipCount > 1) ? cCRNMipModeGenerateMips : cCRNMipModeNoMips;\n\n\tcrn_uint32 crunchedQuality;\n\tfloat crunchedBitrate;\n\tcrn_uint32 crunchedSize;\n\n\tvoid* crnCompressed = crn_compress(compPars, mipPars, crunchedSize, &crunchedQuality, &crunchedBitrate);\n\tif (crnCompressed)\n\t{\n\t\tif (outputSize < crunchedSize)\n\t\t{\n\t\t\tcrn_free_block(crnCompressed);\n\t\t\toutputSize = 0;\n\t\t\treturn false;\n\t\t}\n\n\t\toutputSize = crunchedSize;\n\t\tmemcpy(pOutBuf, crnCompressed, crunchedSize);\n\n\t\tcrnd::crn_texture_info info;\n\t\tif (crnd::crnd_get_texture_info(crnCompressed, crunchedSize, &info))\n\t\t{\n\t\t\tpTex->m_MipCount = info.m_levels;\n\t\t}\n\n\t\tcrn_free_block(crnCompressed);\n\t\treturn true;\n\t}\n\telse\n\t{\n\t\toutputSize = 0;\n\t\treturn false;\n\t}\n}\nAPI bool _WN(DecrunchTextureData_)(TextureFile* pTex, std::vector<uint8_t>& decrunchBuf, TextureFormat &decrunchFormat)\n{\n\tpTex->m_MipCount = 1;\n\tcrnd::crn_texture_info tex_info;\n\tif (!crnd::crnd_get_texture_info(pTex->pPictureData, pTex->_pictureDataSize, &tex_info))\n\t\treturn false;\n\tswitch (pTex->m_TextureFormat)\n\t{\n\tcase TexFmt_DXT1Crunched:\n\t\tif (tex_info.m_format != cCRNFmtDXT1)\n\t\t\treturn false;\n\t\tdecrunchFormat = TexFmt_DXT1;\n\t\tbreak;\n\tcase TexFmt_DXT5Crunched:\n\t\tif (tex_info.m_format != cCRNFmtDXT5)\n\t\t\treturn false;\n\t\tdecrunchFormat = TexFmt_DXT5;\n\t\tbreak;\n\tcase TexFmt_ETC_RGB4Crunched:\n\t\tif (tex_info.m_format != cCRNFmtETC1)\n\t\t\treturn false;\n\t\tdecrunchFormat = TexFmt_ETC_RGB4;\n\t\tbreak;\n#ifdef HAS_ETC2\n\tcase TexFmt_ETC2_RGBA8Crunched:\n\t\tif (tex_info.m_format != cCRNFmtETC2A)\n\t\t\treturn false;\n\t\tdecrunchFormat = TexFmt_ETC2_RGBA8;\n\t\tbreak;\n#endif\n\tdefault:\n\t\treturn false;\n\t}\n\tcrn_uint32 blockCountX = (tex_info.m_width + 3) >> 2; if (!blockCountX) blockCountX = 1;\n\tcrn_uint32 blockCountY = (tex_info.m_height + 3) >> 2; if (!blockCountY) blockCountY = 1;\n\tcrn_uint32 row_pitch = blockCountX * crnd::crnd_get_bytes_per_dxt_block(tex_info.m_format);\n\tsize_t dataSize = (size_t)row_pitch * blockCountY;\n\tdecrunchBuf.resize(dataSize);\n\n\tcrnd::crnd_unpack_context ctx = crnd::crnd_unpack_begin(pTex->pPictureData, pTex->_pictureDataSize);\n\tvoid* bufptr = decrunchBuf.data();\n\tif (!crnd::crnd_unpack_level(ctx, &bufptr, (unsigned int)decrunchBuf.size(), row_pitch, 0))\n\t{\n\t\tdecrunchBuf.clear();\n\t\treturn false;\n\t}\n\treturn true;\n}\n'