b"{-# LANGUAGE TemplateHaskell #-}\n\nmodule Types\n  ( -- * view state\n    ViewState (..),\n    HasViewState (..),\n    emptyViewState,\n\n    -- * top-level logcat state\n    LogcatState (..),\n    HasLogcatState (..),\n    emptyLogcatState,\n  )\nwhere\n\nimport Control.Lens (makeClassy)\nimport Data.Fixed (Nano)\nimport Data.Map (Map)\nimport qualified Data.Map as Map (empty)\nimport Data.Sequence (Seq)\nimport qualified Data.Sequence as Seq (empty)\nimport GHC.RTS.Events (Event (..))\n\ndata ViewState = ViewState\n  { -- | start point of the timeline view\n    _viewTimeOrigin :: Nano\n  }\n\nmakeClassy ''ViewState\n\nemptyViewState :: ViewState\nemptyViewState = ViewState 0\n\ndata LogcatState = LogcatState\n  { _logcatEventStore :: Seq Event,\n    -- TODO: Queue should be a local state, not a global state, considering STM overhead.\n    _logcatEventQueue :: Seq Event,\n    _logcatEventHisto :: Map String Int,\n    _logcatLastEventTime :: Nano,\n    _logcatViewState :: ViewState\n  }\n\nmakeClassy ''LogcatState\n\nemptyLogcatState :: LogcatState\nemptyLogcatState =\n  LogcatState\n    { _logcatEventStore = Seq.empty,\n      _logcatEventQueue = Seq.empty,\n      _logcatEventHisto = Map.empty,\n      _logcatLastEventTime = 0,\n      _logcatViewState = emptyViewState\n    }\n"