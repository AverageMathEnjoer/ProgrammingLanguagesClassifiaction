b'// Copyright (c) 2022-2023 Manuel Schneider\n\n#include "albert/extensions/frontend.h"\n#include "albert/extensions/queryhandler.h"\n#include "albert/logging.h"\n#include "iconprovider.h"\n#include "itemsmodel.h"\n#include <QStringListModel>\n#include <QTimer>\nusing namespace std;\nusing namespace albert;\n\n\nclass IconCache\n{\n    map<pair<QString /*eid*/, QString /*iid*/>, QIcon> icon_cache;\n    QTimer cache_timer;\n\npublic:\n\n    IconCache()\n    {\n        cache_timer.setSingleShot(true);\n        QObject::connect(&cache_timer, &QTimer::timeout, [this](){\n            DEBG << "Clearing icon cache";\n            icon_cache.clear();\n        });\n    }\n\n    QIcon at(const pair<QString /*eid*/, QString /*iid*/> &key)\n    {\n        cache_timer.start(60000); // 1 minute\n        return icon_cache.at(key);\n    }\n\n    QIcon emplace(const pair<QString /*eid*/, QString /*iid*/> &key, const QIcon &icon)\n    {\n        return icon_cache.emplace(key, icon.isNull() ? QIcon(":unknown") : icon).first->second;\n    }\n};\n\n\nstatic IconProvider icon_provider;\nstatic IconCache icon_cache;\n\n\nint ItemsModel::rowCount(const QModelIndex &) const\n{\n    return (int)items.size();\n}\n\nQVariant ItemsModel::data(const QModelIndex &index, int role) const\n{\n    if (index.isValid()) {\n        const shared_ptr<Item> item = items[index.row()].second;\n\n        switch (role) {\n            case (int)ItemRoles::TextRole: return item->text();\n            case (int)ItemRoles::SubTextRole: return item->subtext();\n            case Qt::ToolTipRole: return QString("%1\\n%2").arg(item->text(), item->subtext());\n            case (int)ItemRoles::InputActionRole: return item->inputActionText();\n            case (int)ItemRoles::IconUrlsRole: return item->iconUrls();\n            case (int)ItemRoles::IconPathRole: qFatal("ItemsModel::data ItemRoles::IconPathRole not implemented");\n            case (int)ItemRoles::IconRole:\n            {\n                auto icon_key = make_pair(items[index.row()].first->id(), item->id());\n                try {\n                    return icon_cache.at(icon_key);\n                } catch (const out_of_range &) {\n                    return icon_cache.emplace(icon_key, icon_provider.getIcon(item->iconUrls()));\n                }\n            }\n        }\n    }\n    return {};\n}\n\nQHash<int, QByteArray> ItemsModel::roleNames() const\n{\n    return {\n        {(int)ItemRoles::TextRole, "itemTextRole"},\n        {(int)ItemRoles::SubTextRole, "itemSubTextRole"},\n        {(int)ItemRoles::IconPathRole, "itemIconRole"},\n        {(int)ItemRoles::InputActionRole, "itemInputActionRole"}\n    };\n}\n\nvoid ItemsModel::add(Extension *extension, shared_ptr<Item> &&item)\n{\n    beginInsertRows(QModelIndex(), (int)items.size(), (int)items.size());\n    items.emplace_back(extension, ::move(item));\n    endInsertRows();\n}\n\nvoid ItemsModel::add(Extension *extension, vector<shared_ptr<Item>> &&itemvec)\n{\n    if (itemvec.empty())\n        return;\n\n    beginInsertRows(QModelIndex(), (int)items.size(), (int)(items.size()+itemvec.size()-1));\n    items.reserve(items.size()+itemvec.size());\n    for (auto &&item : itemvec)\n        items.emplace_back(extension, ::move(item));\n    endInsertRows();\n}\n\nvoid ItemsModel::add(Extension *extension, const shared_ptr<Item> &item)\n{\n    beginInsertRows(QModelIndex(), (int)items.size(), (int)items.size());\n    items.emplace_back(extension, item);\n    endInsertRows();\n}\n\nvoid ItemsModel::add(Extension *extension, const vector<shared_ptr<Item>> &itemvec)\n{\n    if (itemvec.empty())\n        return;\n\n    beginInsertRows(QModelIndex(), (int)items.size(), (int)(items.size()+itemvec.size()-1));\n    items.reserve(items.size()+itemvec.size());\n    for (auto &item : itemvec)\n        items.emplace_back(extension, item);\n    endInsertRows();\n}\n\nvoid ItemsModel::add(vector<pair<Extension*,RankItem>>::iterator begin,\n                     vector<pair<Extension*,RankItem>>::iterator end)\n{\n    if (begin == end)\n        return;\n\n    beginInsertRows(QModelIndex(), (int)items.size(), (int)(items.size())+(int)(end-begin)-1);\n    items.reserve(items.size()+(size_t)(end-begin));\n    for (auto it = begin; it != end; ++it)\n        items.emplace_back(it->first, ::move(it->second.item));\n    endInsertRows();\n}\n\nQAbstractListModel *ItemsModel::buildActionsModel(uint i) const\n{\n    QStringList l;\n    for (const auto &a : items[i].second->actions())\n        l << a.text;\n    return new QStringListModel(l);\n}\n\nvoid ItemsModel::activate(uint i, uint a)\n{\n    if (i<items.size()){\n        auto &item = items[i];\n        auto actions = item.second->actions();\n        if (a<actions.size()){\n            auto &action = actions[a];\n            action.function();\n            emit activated(item.first->id(), item.second->id(), action.id);\n        }\n        else\n            WARN << "Activated action index is invalid.";\n    }\n    else\n        WARN << "Activated item index is invalid.";\n}\n'