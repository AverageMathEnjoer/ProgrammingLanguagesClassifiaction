b'\n-- | The @pgcrypto@ extension provides several cryptographic functions to\n-- Postgres. This module provides a @beam-postgres@ extension to access this\n-- functionality. For an example of usage, see the documentation for\n-- \'PgExtensionEntity\'.\nmodule Database.Beam.Postgres.PgCrypto\n  ( PgCrypto(..) ) where\n\nimport Database.Beam\nimport Database.Beam.Backend.SQL\n\nimport Database.Beam.Postgres.Extensions\nimport Database.Beam.Postgres.Extensions.Internal\n\nimport Data.Int\nimport Data.Text (Text)\nimport Data.ByteString (ByteString)\nimport Data.Vector (Vector)\nimport Data.UUID.Types (UUID)\n\n-- | Data type representing definitions contained in the @pgcrypto@ extension\n--\n-- Each field maps closely to the underlying @pgcrypto@ function, which are\n-- described in further detail in the\n-- <https://www.postgresql.org/docs/current/static/pgcrypto.html pgcrypto manual>.\ndata PgCrypto\n  = PgCrypto\n  { pgCryptoDigestText ::\n      forall ctxt s. LiftPg ctxt s (Text -> Text -> ByteString)\n  , pgCryptoDigestBytes ::\n      forall ctxt s. LiftPg ctxt s (ByteString -> Text -> ByteString)\n  , pgCryptoHmacText ::\n      forall ctxt s. LiftPg ctxt s (Text -> Text -> Text -> ByteString)\n  , pgCryptoHmacBytes ::\n      forall ctxt s. LiftPg ctxt s (ByteString -> Text -> Text -> ByteString)\n  , pgCryptoCrypt ::\n      forall ctxt s. LiftPg ctxt s (Text -> Text -> Text)\n  , pgCryptoGenSalt ::\n      forall ctxt s. LiftPg ctxt s (Text -> Maybe Int32 -> Text)\n\n  -- Pgp functions\n  , pgCryptoPgpSymEncrypt ::\n      forall ctxt s. LiftPg ctxt s (Text -> Text -> Maybe Text -> ByteString)\n  , pgCryptoPgpSymEncryptBytea ::\n      forall ctxt s. LiftPg ctxt s (ByteString -> Text -> Maybe Text -> ByteString)\n\n  , pgCryptoPgpSymDecrypt ::\n      forall ctxt s. LiftPg ctxt s (ByteString -> Text -> Maybe Text -> Text)\n  , pgCryptoPgpSymDecryptBytea ::\n      forall ctxt s. LiftPg ctxt s (ByteString -> Text -> Maybe Text -> ByteString)\n\n  , pgCryptoPgpPubEncrypt ::\n      forall ctxt s. LiftPg ctxt s (Text -> ByteString -> Maybe Text -> ByteString)\n  , pgCryptoPgpPubEncryptBytea ::\n      forall ctxt s. LiftPg ctxt s (ByteString -> ByteString -> Maybe Text -> ByteString)\n\n  , pgCryptoPgpPubDecrypt ::\n      forall ctxt s. LiftPg ctxt s (ByteString -> ByteString -> Maybe Text -> Maybe Text -> Text)\n  , pgCryptoPgpPubDecryptBytea ::\n      forall ctxt s. LiftPg ctxt s (ByteString -> ByteString -> Maybe Text -> Maybe Text -> ByteString)\n\n  , pgCryptoPgpKeyId ::\n      forall ctxt s. LiftPg ctxt s (ByteString -> Text)\n\n  , pgCryptoArmor ::\n      forall ctxt s. PgExpr ctxt s ByteString ->\n                     Maybe (PgExpr ctxt s (Vector Text), PgExpr ctxt s (Vector Text)) ->\n                     PgExpr ctxt s Text\n  , pgCryptoDearmor ::\n      forall ctxt s. LiftPg ctxt s (Text -> ByteString)\n\n-- TODO setof\n--  , pgCryptoPgpArmorHeaders ::\n--      forall ctxt s. LiftPg ctxt s (Text -> )\n\n  , pgCryptoGenRandomBytes ::\n      forall ctxt s i. Integral i => PgExpr ctxt s i -> PgExpr ctxt s ByteString\n  , pgCryptoGenRandomUUID ::\n      forall ctxt s. PgExpr ctxt s UUID\n  }\n\ninstance IsPgExtension PgCrypto where\n  pgExtensionName _ = "pgcrypto"\n  pgExtensionBuild = PgCrypto {\n    pgCryptoDigestText  =\n        \\(QExpr data_) (QExpr type_) -> QExpr (funcE "digest" <$> sequenceA [data_, type_]),\n    pgCryptoDigestBytes =\n        \\(QExpr data_) (QExpr type_) -> QExpr (funcE "digest" <$> sequenceA [data_, type_]),\n    pgCryptoHmacText =\n        \\(QExpr data_) (QExpr key) (QExpr type_) -> QExpr (funcE "hmac" <$> sequenceA [data_, key, type_]),\n    pgCryptoHmacBytes =\n        \\(QExpr data_) (QExpr key) (QExpr type_) -> QExpr (funcE "hmac" <$> sequenceA [data_, key, type_]),\n\n    pgCryptoCrypt =\n        \\(QExpr pw) (QExpr salt) ->\n           QExpr (funcE "crypt" <$> sequenceA [pw, salt]),\n    pgCryptoGenSalt =\n        \\(QExpr text) iterCount ->\n           QExpr (funcE "gen_salt" <$> sequenceA ([text] ++ maybe [] (\\(QExpr iterCount\') -> [iterCount\']) iterCount)),\n\n    pgCryptoPgpSymEncrypt =\n        \\(QExpr data_) (QExpr pw) options ->\n           QExpr (funcE "pgp_sym_encrypt" <$> sequenceA ([data_, pw] ++ maybe [] (\\(QExpr options\') -> [options\']) options)),\n    pgCryptoPgpSymEncryptBytea =\n        \\(QExpr data_) (QExpr pw) options ->\n           QExpr (funcE "pgp_sym_encrypt_bytea" <$> sequenceA ([data_, pw] ++ maybe [] (\\(QExpr options\') -> [options\']) options)),\n\n    pgCryptoPgpSymDecrypt =\n        \\(QExpr data_) (QExpr pw) options ->\n             QExpr\n             (funcE "pgp_sym_decrypt" <$> sequenceA ([data_, pw] ++ maybe [] (\\(QExpr options\') -> [options\']) options)),\n    pgCryptoPgpSymDecryptBytea =\n        \\(QExpr data_) (QExpr pw) options ->\n             QExpr\n             (funcE "pgp_sym_decrypt_bytea" <$> sequenceA ([data_, pw] ++ maybe [] (\\(QExpr options\') -> [options\']) options)),\n\n    pgCryptoPgpPubEncrypt =\n        \\(QExpr data_) (QExpr key) options ->\n             QExpr\n             (funcE "pgp_pub_encrypt" <$> sequenceA ([data_, key] ++ maybe [] (\\(QExpr options\') -> [options\']) options)),\n    pgCryptoPgpPubEncryptBytea =\n        \\(QExpr data_) (QExpr key) options ->\n             QExpr\n             (funcE "pgp_pub_encrypt_bytea" <$> sequenceA ([data_, key] ++ maybe [] (\\(QExpr options\') -> [options\']) options)),\n\n    pgCryptoPgpPubDecrypt =\n        \\(QExpr msg) (QExpr key) pw options ->\n              QExpr\n              (funcE "pgp_pub_decrypt" <$>\n                   sequenceA\n                   ( [msg, key] ++\n                     case (pw, options) of\n                       (Nothing, Nothing) -> []\n                       (Just (QExpr pw\'), Nothing) -> [pw\']\n                       (Nothing, Just (QExpr options\')) -> [ \\_ -> valueE (sqlValueSyntax ("" :: String))\n                                                           , options\' ]\n                       (Just (QExpr pw\'), Just (QExpr options\')) -> [pw\', options\'] )),\n    pgCryptoPgpPubDecryptBytea =\n        \\(QExpr msg) (QExpr key) pw options ->\n              QExpr $\n              (funcE "pgp_pub_decrypt_bytea" <$>\n                   sequenceA\n                   ( [msg, key] ++\n                     case (pw, options) of\n                       (Nothing, Nothing) -> []\n                       (Just (QExpr pw\'), Nothing) -> [pw\']\n                       (Nothing, Just (QExpr options\')) -> [ \\_ -> valueE (sqlValueSyntax ("" :: String))\n                                                           , options\' ]\n                       (Just (QExpr pw\'), Just (QExpr options\')) -> [pw\', options\'] )),\n\n    pgCryptoPgpKeyId =\n        \\(QExpr data_) -> QExpr (funcE "pgp_key_id" <$> sequenceA [data_]),\n\n    pgCryptoArmor =\n        \\(QExpr data_) keysData ->\n            QExpr (funcE "armor" <$> sequenceA\n                     ([data_] ++\n                      case keysData of\n                        Nothing -> []\n                        Just (QExpr keys, QExpr values) ->\n                          [keys, values])),\n    pgCryptoDearmor =\n        \\(QExpr data_) -> QExpr (funcE "dearmor" <$> sequenceA [data_]),\n\n    pgCryptoGenRandomBytes =\n        \\(QExpr count) ->\n            QExpr (funcE "gen_random_bytes" <$> sequenceA [count]),\n    pgCryptoGenRandomUUID =\n         QExpr (\\_ -> funcE "gen_random_uuid" [])\n    }\n'