b'{-# OPTIONS_GHC -fno-warn-type-defaults #-}\n{-# LANGUAGE NoImplicitPrelude #-}\n\nmodule Course.StateTSpec where\n\nimport qualified Prelude               as P (String, (++))\n\nimport           Test.Hspec            (Spec, describe, it, shouldBe)\nimport           Test.Hspec.QuickCheck (prop)\nimport           Test.QuickCheck       ((===))\n\nimport           Course.Applicative    (pure, (<*>))\nimport           Course.Core\nimport           Course.ExactlyOne     (ExactlyOne (..))\nimport           Course.Functor        ((<$>))\nimport           Course.Gens           (forAllLists)\nimport           Course.List           (List (..), flatMap, listh)\nimport           Course.Monad          ((=<<), (>>=))\nimport           Course.Optional       (Optional (..))\nimport           Course.State          (put, runState)\nimport           Course.StateT         (Logger (..), OptionalT (..),\n                                        StateT (..), distinct\', distinctF,\n                                        distinctG, getT, log1, putT,\n                                        runOptionalT, runState\', state\')\n\nspec :: Spec\nspec = do\n\n  describe "Functor" $ do\n    it "<$>" $ do\n      let\n        st =\n          StateT (\\s -> ((2, s) :. Nil))\n      runStateT ((+1) <$> st) 0 `shouldBe` ((3,0) :. Nil)\n\n  describe "Applicative" $ do\n    it "List (pure)" $ runStateT ((pure 2) :: StateT Int List Int) 0 `shouldBe` ((2,0) :. Nil)\n    it "List (<*>)" $ runStateT (pure (+2) <*> ((pure 2) :: StateT Int List Int)) 0 `shouldBe` ((4,0) :. Nil)\n    it "Optional" $ do\n      let\n        st =\n          StateT (\\s -> Full ((+2), s P.++ [1])) <*> (StateT (\\s -> Full (2, s P.++ [2])))\n      runStateT st [0] `shouldBe` Full (4,[0,1,2])\n    it "List" $ do\n      let\n        st =\n          StateT (\\s -> ((+2), s P.++ [1]) :. ((+3), s P.++ [1]) :. Nil)\n            <*> (StateT (\\s -> (2, s P.++ [2]) :. Nil))\n      runStateT st [0] `shouldBe` ((4,[0,1,2]) :. (5,[0,1,2]) :. Nil)\n\n  describe "Monad" $ do\n    it "bind const" $ do\n      let\n        s n =\n          StateT $ const (((), n) :. Nil)\n      runStateT (const (s 2) =<< s 1) 0 `shouldBe` (((), 2) :. Nil)\n    it "modify" $ do\n      let\n        modify f =\n          StateT (\\s -> pure ((), f s))\n      runStateT (modify (+1) >>= \\() -> modify (*2)) 7\n        `shouldBe`\n          (((), 16) :. Nil)\n\n  describe "state\'" $ do\n    it "lifts stately functions" $\n      runStateT (state\' $ runState $ put 1) 0 `shouldBe` ExactlyOne ((), 1)\n\n  describe "runState\'" $ do\n    it "runs identity states" $\n      runState\' (state\' $ runState $ put 1) 0 `shouldBe` ((),1)\n\n  describe "getTTest" $ do\n    it "returns it\'s input" $\n      runStateT (getT :: StateT Int List Int) 3 `shouldBe` ((3,3) :. Nil)\n\n  describe "putTTest" $ do\n    it "puts the state" $\n      runStateT (putT 2 :: StateT Int List ()) 0 `shouldBe` (((),2) :. Nil)\n\n  describe "distinct\'" $ do\n    prop "removes adjacent duplicates" $\n      forAllLists $ \\xs ->\n        distinct\' xs === distinct\' (flatMap (\\x -> x :. x :. Nil) xs)\n\n  describe "distinctF" $ do\n    it "Full case" $\n      distinctF (listh [1,2,3,2,1]) `shouldBe` Full (listh [1,2,3])\n    it "Empty case" $\n      distinctF (listh [1,2,3,2,1,101]) `shouldBe` Empty\n\n  describe "OptionalT" $ do\n    it "(<$>) for OptionalT" $\n      runOptionalT ((+1) <$> OptionalT (Full 1 :. Empty :. Nil))\n        `shouldBe`\n          (Full 2 :. Empty :. Nil)\n\n    describe "(<*>) for OptionalT" $ do\n      it "one" $ do\n        let\n          ot =\n            OptionalT Nil <*> OptionalT (Full 1 :. Full 2 :. Nil)\n        runOptionalT ot `shouldBe` (Nil :: List (Optional Int))\n      it "two" $ do\n        let\n          ot =\n            OptionalT (Full (+1) :. Full (+2) :. Nil) <*> OptionalT Nil\n        runOptionalT ot `shouldBe` (Nil :: List (Optional Int))\n      it "three" $ do\n        let\n          ot =\n            OptionalT (Empty :. Nil) <*> OptionalT (Empty :. Nil)\n        runOptionalT ot `shouldBe` (Empty :. Nil :: List (Optional Int))\n      it "four" $ do\n        let\n          ot =\n            OptionalT (Full (+1) :. Empty :. Nil) <*> OptionalT (Empty :. Nil)\n        runOptionalT ot `shouldBe` (Empty :. Empty :. Nil :: List (Optional Int))\n      it "five" $ do\n        let\n          ot =\n            OptionalT (Empty :. Nil) <*> OptionalT (Full 1 :. Full 2 :. Nil)\n        runOptionalT ot `shouldBe` (Empty :. Nil :: List (Optional Int))\n      it "six" $ do\n        let\n          ot =\n            OptionalT (Full (+1) :. Empty :. Nil) <*> OptionalT (Full 1 :. Full 2 :. Nil)\n        runOptionalT ot `shouldBe` (Full 2 :. Full 3 :. Empty :. Nil)\n      it "seven" $ do\n        let\n          ot =\n            OptionalT (Full (+1) :. Full (+2) :. Nil) <*> OptionalT (Full 1 :. Empty :. Nil)\n        runOptionalT ot `shouldBe` (Full 2 :. Empty :. Full 3 :. Empty :. Nil)\n\n    describe "OptionalT Monad" $ do\n      it "(=<<) for OptionalT" $ do\n        let\n          func a =\n            OptionalT (Full (a+1) :. Full (a+2) :. Nil)\n          ot =\n            func =<< OptionalT (Full 1 :. Empty :. Nil)\n        runOptionalT ot `shouldBe` (Full 2:.Full 3:.Empty:.Nil)\n\n  describe "Logger" $ do\n    it "(<$>) for Logger" $\n      (+3) <$> Logger (1 :. 2 :. Nil) 3 `shouldBe` Logger (1 :. 2 :. Nil) 6\n\n    describe "Applicative" $ do\n      it "pure" $\n        (pure "table" :: Logger Int P.String) `shouldBe` Logger Nil "table"\n      it "<*>" $\n        Logger (1:.2:.Nil) (+7) <*> Logger (3:.4:.Nil) 3\n          `shouldBe`\n            Logger (1:.2:.3:.4:.Nil) 10\n\n    describe "Functor" $ do\n      it "(=<<) for Logger" $ do\n        let\n          func a =\n            Logger (4:.5:.Nil) (a+3)\n        (func =<< Logger (1:.2:.Nil) 3)\n          `shouldBe`\n            Logger (1:.2:.4:.5:.Nil) 6\n\n  it "log1" $\n    log1 1 2 `shouldBe` Logger (1:.Nil) 2\n\n  describe "distinctG" $ do\n    it "Full case" $ do\n      let\n        expected =\n          Logger\n            (listh <$> ("even number: 2":."even number: 2":."even number: 6":.Nil))\n            (Full (1:.2:.3:.6:.Nil))\n      distinctG (1:.2:.3:.2:.6:.Nil) `shouldBe` expected\n    it "Empty case" $ do\n      let\n        expected =\n          Logger\n            (listh <$> ("even number: 2":."even number: 2":."even number: 6":."aborting > 100: 106":.Nil))\n            Empty\n      distinctG (listh [1,2,3,2,6,106]) `shouldBe` expected\n'