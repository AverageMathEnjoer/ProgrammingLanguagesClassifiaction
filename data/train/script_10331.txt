b'\xef\xbb\xbf// UVa10735 Euler Circuit\n// Rujia Liu\n#include<cstdio>\n#include<cstring>\n#include<queue>\n#include<algorithm>\nusing namespace std;\n\nconst int INF = 1000000000;\n\nstruct Edge {\n  int from, to, cap, flow;\n  Edge(int u, int v, int c, int f):from(u),to(v),cap(c),flow(f) {}\n};\n\nconst int maxn = 100+10;\n\nstruct EdmondsKarp {\n  int n, m;\n  vector<Edge> edges;    // \xe8\xbe\xb9\xe6\x95\xb0\xe7\x9a\x84\xe4\xb8\xa4\xe5\x80\x8d\n  vector<int> G[maxn];   // \xe9\x82\xbb\xe6\x8e\xa5\xe8\xa1\xa8\xef\xbc\x8cG[i][j]\xe8\xa1\xa8\xe7\xa4\xba\xe7\xbb\x93\xe7\x82\xb9i\xe7\x9a\x84\xe7\xac\xacj\xe6\x9d\xa1\xe8\xbe\xb9\xe5\x9c\xa8e\xe6\x95\xb0\xe7\xbb\x84\xe4\xb8\xad\xe7\x9a\x84\xe5\xba\x8f\xe5\x8f\xb7\n  int a[maxn];           // \xe5\xbd\x93\xe8\xb5\xb7\xe7\x82\xb9\xe5\x88\xb0i\xe7\x9a\x84\xe5\x8f\xaf\xe6\x94\xb9\xe8\xbf\x9b\xe9\x87\x8f\n  int p[maxn];           // \xe6\x9c\x80\xe7\x9f\xad\xe8\xb7\xaf\xe6\xa0\x91\xe4\xb8\x8ap\xe7\x9a\x84\xe5\x85\xa5\xe5\xbc\xa7\xe7\xbc\x96\xe5\x8f\xb7\n\n  void init(int n) {\n    for(int i = 0; i < n; i++) G[i].clear();\n    edges.clear();\n  }\n\n  void AddEdge(int from, int to, int cap) {\n    edges.push_back(Edge(from, to, cap, 0));\n    edges.push_back(Edge(to, from, 0, 0));\n    m = edges.size();\n    G[from].push_back(m-2);\n    G[to].push_back(m-1);\n  }\n\n  int Maxflow(int s, int t) {\n    int flow = 0;\n    for(;;) {\n      memset(a, 0, sizeof(a));\n      queue<int> Q;\n      Q.push(s);\n      a[s] = INF;\n      while(!Q.empty()) {\n        int x = Q.front(); Q.pop();\n        for(int i = 0; i < G[x].size(); i++) {\n          Edge& e = edges[G[x][i]];\n          if(!a[e.to] && e.cap > e.flow) {\n            p[e.to] = G[x][i];\n            a[e.to] = min(a[x], e.cap-e.flow);\n            Q.push(e.to);\n          }\n        }\n        if(a[t]) break;\n      }\n      if(!a[t]) break;\n      for(int u = t; u != s; u = edges[p[u]].from) {\n        edges[p[u]].flow += a[t];\n        edges[p[u]^1].flow -= a[t];\n      }\n      flow += a[t];\n    }\n    return flow;\n  }\n};\n\nEdmondsKarp g;\n\nconst int maxm = 500 + 5;\n\nint n, m, u[maxm], v[maxm], directed[maxm], id[maxm], diff[maxn];\n\n// for euler tour only\nvector<int> G[maxn];\nvector<int> vis[maxn];\nvector<int> path;\n\nvoid euler(int u) {\n  for(int i = 0; i < G[u].size(); i++)\n    if(!vis[u][i]) {\n      vis[u][i] = 1;\n      euler(G[u][i]);\n      path.push_back(G[u][i]+1);\n    }\n}\n\nvoid print_answer() {\n  // build the new graph\n  for(int i = 0; i < n; i++) { G[i].clear(); vis[i].clear(); }\n  for(int i = 0; i < m; i++) {\n    bool rev = false;\n    if(!directed[i] && g.edges[id[i]].flow > 0) rev = true;\n    if(!rev) { G[u[i]].push_back(v[i]); vis[u[i]].push_back(0); }\n    else { G[v[i]].push_back(u[i]); vis[v[i]].push_back(0); }\n  }\n\n  // print euler tour\n  path.clear();\n  euler(0);\n\n  printf("1");\n  for(int i = path.size()-1; i >= 0; i--) printf(" %d", path[i]);\n  printf("\\n");\n}\n\nint main() {\n  int T;\n  scanf("%d", &T);\n\n  while(T--) {\n    scanf("%d%d", &n, &m);\n    g.init(n+2);\n\n    memset(diff, 0, sizeof(diff));\n    for(int i = 0; i < m; i++) {\n      char dir[9];\n      scanf("%d%d%s", &u[i], &v[i], dir);\n      u[i]--; v[i]--;\n      directed[i] = (dir[0] == \'D\' ? 1 : 0);\n      diff[u[i]]++; diff[v[i]]--;\n      if(!directed[i]) { id[i] = g.edges.size(); g.AddEdge(u[i], v[i], 1); }\n    }\n\n    bool ok = true;\n    for(int i = 0; i < n; i++)\n      if(diff[i] % 2 != 0) { ok = false; break; }\n\n    int s = n, t = n+1;\n    if(ok) {\n      int sum = 0;\n      for(int i = 0; i < n; i++) {\n        if(diff[i] > 0) { g.AddEdge(s, i, diff[i]/2); sum += diff[i]/2; } // provide "out-degree"\n        if(diff[i] < 0) { g.AddEdge(i, t, -diff[i]/2); }\n      }\n      if(g.Maxflow(s, t) != sum) ok = false;\n    }\n\n    if(!ok) printf("No euler circuit exist\\n");\n    else print_answer(); // underlying graph is always connected\n\n    if(T) printf("\\n");\n  }\n  return 0;\n}\n'