b'{-# LANGUAGE AllowAmbiguousTypes #-}\n{-# LANGUAGE ExistentialQuantification #-}\n{-# LANGUAGE FlexibleContexts #-}\n{-# LANGUAGE InstanceSigs #-}\n{-# LANGUAGE TypeFamilies #-}\n{-# LANGUAGE TypeOperators #-}\n\nmodule Types where\n\nimport Data.Aeson\nimport Data.Default\nimport Data.Maybe\nimport Data.Text.Lazy (Text)\nimport Data.Text.Lazy qualified as TL\nimport Network.OAuth.OAuth2 hiding (RefreshToken)\nimport Network.OAuth2.Experiment\nimport Network.OAuth2.Provider.Auth0 qualified as IAuth0\nimport Network.OAuth2.Provider.AzureAD qualified as IAzureAD\nimport Network.OAuth2.Provider.Dropbox qualified as IDropbox\nimport Network.OAuth2.Provider.Facebook qualified as IFacebook\nimport Network.OAuth2.Provider.Fitbit qualified as IFitbit\nimport Network.OAuth2.Provider.Github qualified as IGithub\nimport Network.OAuth2.Provider.Google qualified as IGoogle\nimport Network.OAuth2.Provider.Linkedin qualified as ILinkedin\nimport Network.OAuth2.Provider.Okta qualified as IOkta\nimport Network.OAuth2.Provider.Slack qualified as ISlack\nimport Network.OAuth2.Provider.StackExchange qualified as IStackExchange\nimport Network.OAuth2.Provider.Twitter qualified as ITwitter\nimport Network.OAuth2.Provider.Weibo qualified as IWeibo\nimport Network.OAuth2.Provider.ZOHO qualified as IZOHO\nimport Text.Mustache\nimport Text.Mustache qualified as M\nimport Prelude hiding (id)\n\n-------------------------------------------------------------------------------\n\n-- * Demo Login User\n\n-------------------------------------------------------------------------------\n\nnewtype DemoLoginUser = DemoLoginUser\n  { loginUserName :: TL.Text\n  -- TODO: maybe email\n  }\n  deriving (Eq, Show)\n\nclass HasDemoLoginUser a where\n  toLoginUser :: IdpUserInfo a -> DemoLoginUser\n\ninstance HasDemoLoginUser IAuth0.Auth0 where\n  toLoginUser :: IAuth0.Auth0User -> DemoLoginUser\n  toLoginUser IAuth0.Auth0User {..} = DemoLoginUser {loginUserName = name}\n\ninstance HasDemoLoginUser IGoogle.Google where\n  toLoginUser :: IGoogle.GoogleUser -> DemoLoginUser\n  toLoginUser IGoogle.GoogleUser {..} = DemoLoginUser {loginUserName = name}\n\ninstance HasDemoLoginUser IZOHO.ZOHO where\n  toLoginUser resp =\n    let us = IZOHO.users resp\n     in case us of\n          [] -> DemoLoginUser {loginUserName = "ZOHO: no user found"}\n          (a : _) -> DemoLoginUser {loginUserName = IZOHO.fullName a}\n\ninstance HasDemoLoginUser IAzureAD.AzureAD where\n  toLoginUser :: IAzureAD.AzureADUser -> DemoLoginUser\n  toLoginUser ouser =\n    DemoLoginUser\n      { loginUserName = IAzureAD.email ouser <> " " <> IAzureAD.name ouser\n      }\n\ninstance HasDemoLoginUser IWeibo.Weibo where\n  toLoginUser :: IWeibo.WeiboUID -> DemoLoginUser\n  toLoginUser ouser = DemoLoginUser {loginUserName = TL.pack $ show $ IWeibo.uid ouser}\n\ninstance HasDemoLoginUser IDropbox.Dropbox where\n  toLoginUser :: IDropbox.DropboxUser -> DemoLoginUser\n  toLoginUser ouser = DemoLoginUser {loginUserName = IDropbox.displayName $ IDropbox.name ouser}\n\ninstance HasDemoLoginUser IFacebook.Facebook where\n  toLoginUser :: IFacebook.FacebookUser -> DemoLoginUser\n  toLoginUser ouser = DemoLoginUser {loginUserName = IFacebook.name ouser}\n\ninstance HasDemoLoginUser IFitbit.Fitbit where\n  toLoginUser :: IFitbit.FitbitUser -> DemoLoginUser\n  toLoginUser ouser = DemoLoginUser {loginUserName = IFitbit.userName ouser}\n\ninstance HasDemoLoginUser IGithub.Github where\n  toLoginUser :: IGithub.GithubUser -> DemoLoginUser\n  toLoginUser guser = DemoLoginUser {loginUserName = IGithub.name guser}\n\ninstance HasDemoLoginUser ILinkedin.Linkedin where\n  toLoginUser :: ILinkedin.LinkedinUser -> DemoLoginUser\n  toLoginUser ILinkedin.LinkedinUser {..} =\n    DemoLoginUser\n      { loginUserName = localizedFirstName <> " " <> localizedLastName\n      }\n\ninstance HasDemoLoginUser ITwitter.Twitter where\n  toLoginUser :: ITwitter.TwitterUserResp -> DemoLoginUser\n  toLoginUser ITwitter.TwitterUserResp {..} = DemoLoginUser {loginUserName = ITwitter.name twitterUserRespData}\n\ninstance HasDemoLoginUser IOkta.Okta where\n  toLoginUser :: IOkta.OktaUser -> DemoLoginUser\n  toLoginUser ouser = DemoLoginUser {loginUserName = IOkta.name ouser}\n\ninstance HasDemoLoginUser ISlack.Slack where\n  toLoginUser :: ISlack.SlackUser -> DemoLoginUser\n  toLoginUser ouser = DemoLoginUser {loginUserName = ISlack.name ouser}\n\ninstance HasDemoLoginUser IStackExchange.StackExchange where\n  toLoginUser :: IStackExchange.StackExchangeResp -> DemoLoginUser\n  toLoginUser IStackExchange.StackExchangeResp {..} =\n    case items of\n      [] -> DemoLoginUser {loginUserName = TL.pack "Cannot find stackexchange user"}\n      (user : _) -> DemoLoginUser {loginUserName = IStackExchange.displayName user}\n\n-------------------------------------------------------------------------------\n\n-- * Authorization Apps\n\n-------------------------------------------------------------------------------\n\n-- | Use for creating list of IDPs\n-- Heterogenous collections\n-- https://wiki.haskell.org/Heterogenous_collections\ndata DemoAuthorizationApp\n  = forall a b.\n    ( HasDemoLoginUser b\n    , FromJSON (IdpUserInfo b)\n    , \'AuthorizationCode ~ a\n    , HasPkceAuthorizeRequest a\n    , HasPkceTokenRequest a\n    , HasUserInfoRequest a\n    , HasIdpAppName a\n    , HasAuthorizeRequest a\n    , HasTokenRequest a\n    , HasRefreshTokenRequest a\n    ) =>\n    DemoAuthorizationApp (IdpApplication a b)\n\n-------------------------------------------------------------------------------\n\n-- * Env\n\n-------------------------------------------------------------------------------\n\ndata DemoAppPerAppSessionData = DemoAppPerAppSessionData\n  { loginUser :: Maybe DemoLoginUser\n  , oauth2Token :: Maybe OAuth2Token\n  , authorizePkceCodeVerifier :: Maybe CodeVerifier\n  , authorizeAbsUri :: TL.Text\n  }\n\ndata DemoAppEnv = DemoAppEnv DemoAuthorizationApp DemoAppPerAppSessionData\n\ninstance Default DemoAppPerAppSessionData where\n  def =\n    DemoAppPerAppSessionData\n      { loginUser = Nothing\n      , oauth2Token = Nothing\n      , authorizePkceCodeVerifier = Nothing\n      , authorizeAbsUri = ""\n      }\n\ninstance Show DemoAppEnv where\n  show :: DemoAppEnv -> String\n  show = TL.unpack . toLabel\n\ntoLabel :: DemoAppEnv -> TL.Text\ntoLabel (DemoAppEnv (DemoAuthorizationApp idpAppConfig) _) = getIdpAppName idpAppConfig\n\n-- simplify use case to only allow one idp instance for now.\ninstance Eq DemoAppEnv where\n  a == b = toLabel a == toLabel b\n\ninstance Ord DemoAppEnv where\n  a `compare` b = toLabel a `compare` toLabel b\n\nnewtype TemplateData = TemplateData\n  { idpTemplateData :: [DemoAppEnv]\n  }\n  deriving (Eq)\n\n-- * Mustache instances\n\ninstance ToMustache DemoAppEnv where\n  toMustache (DemoAppEnv (DemoAuthorizationApp idpAppConfig) DemoAppPerAppSessionData {..}) =\n    M.object\n      [ "codeFlowUri" ~> authorizeAbsUri\n      , "isLogin" ~> isJust loginUser\n      , "user" ~> loginUser\n      , "name" ~> TL.unpack (getIdpAppName idpAppConfig)\n      ]\n\ninstance ToMustache DemoLoginUser where\n  toMustache t\' =\n    M.object\n      ["name" ~> loginUserName t\']\n\ninstance ToMustache TemplateData where\n  toMustache td\' =\n    M.object\n      [ "idps" ~> idpTemplateData td\'\n      ]\n\n-------------------------------------------------------------------------------\n\n-- * HasIdpAppName\n\n-------------------------------------------------------------------------------\n\nclass HasIdpAppName (a :: GrantTypeFlow) where\n  getIdpAppName :: IdpApplication a i -> Text\n\ninstance HasIdpAppName \'ClientCredentials where\n  getIdpAppName :: IdpApplication \'ClientCredentials i -> Text\n  getIdpAppName ClientCredentialsIDPApplication {..} = idpAppName\n\ninstance HasIdpAppName \'ResourceOwnerPassword where\n  getIdpAppName :: IdpApplication \'ResourceOwnerPassword i -> Text\n  getIdpAppName ResourceOwnerPasswordIDPApplication {..} = idpAppName\n\ninstance HasIdpAppName \'AuthorizationCode where\n  getIdpAppName :: IdpApplication \'AuthorizationCode i -> Text\n  getIdpAppName AuthorizationCodeIdpApplication {..} = idpAppName\n'