b'-- Make a 2-D array of size z given a function f\nmkArray :: (Integral a) => (a -> a -> a) -> a -> [[a]]\nmkArray f z = [ [f x y | x <- [0..z]] | y <- [0..z]]\n\n-- Stringify a 1-D array\nformatArray :: (Show a, Integral a) => [a] -> String\nformatArray [] = ""\nformatArray (x:xs) = show x ++ "\\t" ++ formatArray xs\n\n-- Stringify a 2-D array\nformat2DArray :: (Show a, Integral a) => [[a]] -> String\nformat2DArray [] = ""\nformat2DArray (x:xs) = formatArray x ++ "\\n" ++ format2DArray xs\n\n-- In this function, all values from 0..z are represented   \nf1 :: Integral a => a -> a -> a\nf1 x y = x + y\n\n-- In this function, each value is represented only once.\nf2 :: Integral a => a -> a -> a\nf2 x y = 3*x + 27*y + y*y\n\n-- Jack\'s first solution\ninvert :: (Integral a) => (a -> a -> a) -> a -> [(a, a)]\ninvert f z = [(x, y) | x <- [0..z ], y <- [0..z ], f x  y == z]\n\n-- Theo\'s slight improvement\ninvert_b :: (Integral a) => (a -> a -> a) -> a -> [(a, a)]\ninvert_b f z = [(x, y) | x <- [0..z], y <- [0..z - x], f x y == z]\n\n-- Anne reduces it further\nfind_c :: (Integral a) => (a, a) -> (a -> a -> a) -> a -> [(a, a)]\nfind_c (u, v) f z = [(x, y) | x <- [u .. z ], y <- [v, v - 1..0], f x y == z]\n\ninvert_c :: (Integral a) => (a -> a -> a) -> a -> [(a, a)]\ninvert_c f z = find_c (0, z) f z\n\n-- And more efficiently\nfind_d :: (Integral a) => (a, a) -> (a -> a -> a) -> a -> [(a, a)]\nfind_d (u, v) f z\n    | u > z || v < 0   = []\n    | z\' < z           = find_d (u + 1, v) f z\n    | z\' == z          = (u, v) : find_d (u + 1, v - 1) f z\n    | z\' > z           = find_d (u, v - 1) f z\n    where z\' = f u v\n\ninvert_d :: (Integral a) => (a -> a -> a) -> a -> [(a, a)]\ninvert_d f z = find_d (0, z) f z\n\n-- Theo\'s improvement\nbsearch :: (Integral a) => (a -> a) -> (a, a) -> a -> a\nbsearch g (a, b) z\n    | a + 1 == b    = a\n    | g m <= z      = bsearch g (m, b) z\n    | otherwise     = bsearch g (a, m) z\n    where m = (a + b) `div` 2\n\nfind_e :: (Integral a) => (a, a) -> (a -> a -> a) -> a -> [(a, a)]\nfind_e (u, v) f z\n    | u > n || n < 0   = []\n    | z\' < z           = find_e (u + 1, v) f z\n    | z\' == z          = (u, v) : find_e (u + 1, v - 1) f z\n    | z\' > z           = find_e (u, v - 1) f z\n    where z\' = f u v\n          n = maximum (filter (\\x -> f x 0 <= z) [0 .. z ])\n\ninvert_e :: (Integral a) => (a -> a -> a) -> a -> [(a, a)]\ninvert_e f z = find_e (0, m) f z\n    where m = bsearch (\\y -> f 0 y) (-1, z + 1) z\n\n-- Final version\nfind_f :: (Integral a) => (a, a) -> (a, a) -> (a -> a -> a) -> a -> [(a, a)]\nfind_f (u, v) (r, s) f z\n    | u > r || v < s    = []\n    | v - s <= r - u    = rfind (bsearch (\\x -> f x q) (u - 1, r + 1) z)\n    | otherwise         = cfind (bsearch (\\y -> f p y) (s - 1, v + 1) z)\n    where p = (u + r) `div` 2\n          q = (v + s) `div` 2\n          rfind p = (if f p q == z then (p, q) : find_f (u, v) (p - 1, q + 1) f z\n                        else find_f (u, v) (p, q + 1) f z) ++\n                    find_f (p + 1, q - 1) (r , s) f z\n          cfind q = find_f (u, v) (p - 1, q + 1) f z ++\n                    (if f p q == z then(p, q) : find_f (p + 1, q - 1) (r , s) f z\n                        else find_f (p + 1, q) (r , s) f z)\n\ninvert_f :: (Integral a) => (a -> a -> a) -> a -> [(a, a)]\ninvert_f f z = find_f (0, m) (n, 0) f z\n    where m = bsearch (\\y -> f 0 y) (-1, z + 1) z\n          n = bsearch (\\x -> f x 0) (-1, z + 1) z\n\n\n'