b'/* \n * Fast QR Code generator library\n * \n * Copyright (c) Project Nayuki. (MIT License)\n * https://www.nayuki.io/page/fast-qr-code-generator-library\n * \n * Permission is hereby granted, free of charge, to any person obtaining a copy of\n * this software and associated documentation files (the "Software"), to deal in\n * the Software without restriction, including without limitation the rights to\n * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of\n * the Software, and to permit persons to whom the Software is furnished to do so,\n * subject to the following conditions:\n * - The above copyright notice and this permission notice shall be included in\n *   all copies or substantial portions of the Software.\n * - The Software is provided "as is", without warranty of any kind, express or\n *   implied, including but not limited to the warranties of merchantability,\n *   fitness for a particular purpose and noninfringement. In no event shall the\n *   authors or copyright holders be liable for any claim, damages or other\n *   liability, whether in an action of contract, tort or otherwise, arising from,\n *   out of or in connection with the Software or the use or other dealings in the\n *   Software.\n */\n\npackage io.nayuki.fastqrcodegen;\n\nimport java.util.Arrays;\nimport java.util.Objects;\n\n\n// Computes Reed-Solomon error correction codewords for given data codewords.\nfinal class ReedSolomonGenerator {\n\t\n\t// Use this memoizer to get instances of this class.\n\tpublic static final Memoizer<Integer,ReedSolomonGenerator> MEMOIZER\n\t\t= new Memoizer<>(ReedSolomonGenerator::new);\n\t\n\t\n\t// A table of size 256 * degree, where polynomialMultiply[i][j] = multiply(i, coefficients[j]).\n\t// \'coefficients\' is the temporary array computed in the constructor.\n\tprivate byte[][] polynomialMultiply;\n\t\n\t\n\t// Creates a Reed-Solomon ECC generator polynomial for the given degree.\n\tprivate ReedSolomonGenerator(int degree) {\n\t\tif (degree < 1 || degree > 255)\n\t\t\tthrow new IllegalArgumentException("Degree out of range");\n\t\t\n\t\t// The divisor polynomial, whose coefficients are stored from highest to lowest power.\n\t\t// For example, x^3 + 255x^2 + 8x + 93 is stored as the uint8 array {255, 8, 93}.\n\t\tbyte[] coefficients = new byte[degree];\n\t\tcoefficients[degree - 1] = 1;  // Start off with the monomial x^0\n\t\t\n\t\t// Compute the product polynomial (x - r^0) * (x - r^1) * (x - r^2) * ... * (x - r^{degree-1}),\n\t\t// and drop the highest monomial term which is always 1x^degree.\n\t\t// Note that r = 0x02, which is a generator element of this field GF(2^8/0x11D).\n\t\tint root = 1;\n\t\tfor (int i = 0; i < degree; i++) {\n\t\t\t// Multiply the current product by (x - r^i)\n\t\t\tfor (int j = 0; j < coefficients.length; j++) {\n\t\t\t\tcoefficients[j] = (byte)multiply(coefficients[j] & 0xFF, root);\n\t\t\t\tif (j + 1 < coefficients.length)\n\t\t\t\t\tcoefficients[j] ^= coefficients[j + 1];\n\t\t\t}\n\t\t\troot = multiply(root, 0x02);\n\t\t}\n\t\t\n\t\tpolynomialMultiply = new byte[256][degree];\n\t\tfor (int i = 0; i < polynomialMultiply.length; i++) {\n\t\t\tfor (int j = 0; j < degree; j++)\n\t\t\t\tpolynomialMultiply[i][j] = (byte)multiply(i, coefficients[j] & 0xFF);\n\t\t}\n\t}\n\t\n\t\n\t// Returns the error correction codeword for the given data polynomial and this divisor polynomial.\n\tpublic void getRemainder(byte[] data, int dataOff, int dataLen, byte[] result) {\n\t\tObjects.requireNonNull(data);\n\t\tObjects.requireNonNull(result);\n\t\tint degree = polynomialMultiply[0].length;\n\t\tassert result.length == degree;\n\t\t\n\t\tArrays.fill(result, (byte)0);\n\t\tfor (int i = dataOff, dataEnd = dataOff + dataLen; i < dataEnd; i++) {  // Polynomial division\n\t\t\tbyte[] table = polynomialMultiply[(data[i] ^ result[0]) & 0xFF];\n\t\t\tfor (int j = 0; j < degree - 1; j++)\n\t\t\t\tresult[j] = (byte)(result[j + 1] ^ table[j]);\n\t\t\tresult[degree - 1] = table[degree - 1];\n\t\t}\n\t}\n\t\n\t\n\t// Returns the product of the two given field elements modulo GF(2^8/0x11D). The arguments and result\n\t// are unsigned 8-bit integers. This could be implemented as a lookup table of 256*256 entries of uint8.\n\tprivate static int multiply(int x, int y) {\n\t\tassert x >> 8 == 0 && y >> 8 == 0;\n\t\t// Russian peasant multiplication\n\t\tint z = 0;\n\t\tfor (int i = 7; i >= 0; i--) {\n\t\t\tz = (z << 1) ^ ((z >>> 7) * 0x11D);\n\t\t\tz ^= ((y >>> i) & 1) * x;\n\t\t}\n\t\tassert z >>> 8 == 0;\n\t\treturn z;\n\t}\n\t\n}\n'