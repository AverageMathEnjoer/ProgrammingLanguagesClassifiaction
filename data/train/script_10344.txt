b"-- |\n-- Copyright  : (c) Ivan Perez and Manuel Baerenz, 2016\n-- License    : BSD3\n-- Maintainer : ivan.perez@keera.co.uk\n--\n-- Versions of arrow combinators that run things in parallel using 'par', if\n-- possible.\nmodule Data.MonadicStreamFunction.Parallel where\n\n-- External imports\nimport Control.Arrow (arr, (>>>))\nimport GHC.Conc      (par, pseq)\n\n-- Internal imports\nimport Data.MonadicStreamFunction              ()\nimport Data.MonadicStreamFunction.InternalCore (MSF (MSF, unMSF))\n\n-- | Run two 'MSF's in parallel, taking advantage of parallelism if possible.\n-- This is the parallel version of '***'.\n(*|*) :: Monad m => MSF m a b -> MSF m c d -> MSF m (a, c) (b, d)\nmsf1 *|* msf2 = MSF $ \\(a, c) -> do\n  (b, msf1') <- unMSF msf1 a\n  (d, msf2') <- unMSF msf2 c\n  b `par` d `pseq` return ((b, d), msf1' *|* msf2')\n\n-- | Parallel version of '&&&'.\n(&|&) :: Monad m => MSF m a b -> MSF m a c -> MSF m a (b, c)\nmsf1 &|& msf2 = arr (\\a -> (a, a)) >>> (msf1 *|* msf2)\n"