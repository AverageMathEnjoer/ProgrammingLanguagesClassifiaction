b'library(data.table)\nlibrary(babynames)\n\n# Get possible boy and girl names\npossible_names <- data.table(babynames)[year==2014, list(name, sex, n)][order(-n)]\nboy_names <- possible_names[sex=="M"]\ngirl_names <- possible_names[sex=="F"]\n\ngetUsers <- function(n=10, minDate=as.Date("2010-1-1"), maxDate=as.Date("2016-6-30"), seed=0){\n  # Build a data.table of users\n  \n  set.seed(seed)\n  users <- data.table(UserID = seq(1, n))\n  users[, Gender := sample(c("male", "female"), size=.N, replace=TRUE)]\n  users[Gender=="male", User := sample(boy_names$name, size=.N, replace=TRUE, prob=boy_names$n)]\n  users[Gender=="female", User := sample(girl_names$name, size=.N, replace=TRUE, prob=girl_names$n)]\n  users[, Registered := minDate + sample(as.integer(maxDate-minDate), size=.N, replace=TRUE)]\n  users[, Cancelled := Registered + sample(5000, size=.N, replace=TRUE)]\n  users[Cancelled > maxDate, Cancelled := NA]\n  \n  # Fix the column order\n  setcolorder(users, c("UserID", "User", "Gender", "Registered", "Cancelled"))\n  \n  return(users[])\n}\n\ngetProducts <- function(n=10, seed=0){\n  # Build a data.table of products\n  \n  if(n <= 26){\n    product_names <- CJ(LETTERS)[, Product := paste0(V1)]\n  } else if(n <= 26^2){\n    product_names <- CJ(LETTERS, LETTERS)[, Product := paste0(V1, V2)]\n  } else if(n <= 26^3){\n    product_names <- CJ(LETTERS, LETTERS, LETTERS)[, Product := paste0(V1, V2, V3)]\n  } else if(n <= 26^4){\n    product_names <- CJ(LETTERS, LETTERS, LETTERS, LETTERS)[, Product := paste0(V1, V2, V3, V4)]\n  } else if(n <= 26^5){\n    product_names <- CJ(LETTERS, LETTERS, LETTERS, LETTERS, LETTERS)[, Product := paste0(V1, V2, V3, V4, V5)]\n  } else if(n <= 26^6){\n    product_names <- CJ(LETTERS, LETTERS, LETTERS, LETTERS, LETTERS, LETTERS)[, Product := paste0(V1, V2, V3, V4, V5, V6)]\n  } else{\n    stop("n too large")\n  }\n  \n  set.seed(seed)\n  products <- data.table(ProductID = seq(1, n))\n  products[, Product := product_names$Product[1:n]]\n  products[, Price := round(exp(rlnorm(n=n, meanlog=1, sdlog=.3)), 2)]\n  \n  return(products[])\n}\n\ngetTransactions <- function(n=100, products, users, minDate=as.Date("2010-1-1"), maxDate=as.Date("2016-6-30"), \n                            orphanUsers=0, naUsers=0, seed=0){\n  # Build a data.table of users\n  # orphanUsers and naUsers should be in the range [0, 1] s.t. orphanUsers + naUsers <= 1\n  # If orphanUsers > 0, transactions will set the specified portion UserIDs to some IDs not in the users dataset\n  # If naUsers > 0, transactions will set the specified portion UserIDs to NA\n  \n  set.seed(seed)\n  transactions <- data.table(TransactionID = seq(1, n))\n  transactions[, ProductID := sample(products$ProductID, size=.N, replace=TRUE)]\n  transactions[, UserID := sample(users$UserID, size=.N, replace=TRUE)]\n  transactions[, TransactionDate := minDate + sample(as.integer(maxDate-minDate), size=.N, replace=TRUE)]\n  transactions[, Quantity := pmax(1L, rnbinom(n=.N, size=5, prob=.8))]\n  \n  # Helper function (see ?sample)\n  resample <- function(x, ...) x[sample.int(length(x), ...)] \n  \n  # Insert orphan users\n  orphanUsersMap <- transactions[sample(.N, round(orphanUsers * .N)), list(TransactionID)]\n  potentialNewUsers <- nrow(users) + sample(nrow(users), ceiling(orphanUsers * nrow(users)))\n  orphanUsersMap[, NewUserID := resample(potentialNewUsers, .N, replace=TRUE)]\n  transactions[orphanUsersMap, UserID := NewUserID, on="TransactionID"]\n  \n  # Insert naUsers\n  naUsersMap <- transactions[!orphanUsersMap, on="TransactionID"][sample(.N, round(naUsers * nrow(transactions))), list(TransactionID)]\n  transactions[naUsersMap, UserID := NA_integer_, on="TransactionID"]\n  \n  # Reset the TransactionIDs to match the transaction dates\n  setorder(transactions, "TransactionDate")\n  transactions[, TransactionID := .I]\n  \n  # Fix the column order\n  setcolorder(transactions, c("TransactionID", "TransactionDate", "UserID", "ProductID", "Quantity"))\n  \n  return(transactions[])\n}\n\ngetSessions <- function(n=100, users, minDate=as.Date("2010-1-1"), maxDate=as.Date("2016-6-30"), seed=0){\n  # Build a data.table of users\n  \n  set.seed(seed)\n  sessions <- data.table(SessionID = seq(1, n))\n  sessions[, UserID := sample(users$UserID, size=.N, replace=TRUE)]\n  sessions[, SessionDate := minDate + sample(as.integer(maxDate-minDate), size=.N, replace=TRUE)]\n  \n  # Reset the SessionID to match the session dates\n  setorder(sessions, "SessionDate")\n  sessions[, SessionID := .I]\n  \n  # Fix the column order\n  setcolorder(sessions, c("SessionID", "SessionDate", "UserID"))\n  \n  return(sessions[])\n}\n\nusers <- getUsers(5, seed=14)\nproducts <- getProducts(5, seed=0)\ntransactions <- getTransactions(10, products, users, orphanUsers=.1, naUsers=.1, seed=0)\nsessions <- getSessions(10, users, seed=0)\n\n#--------------------------------------------------\n# Check for good instructional data\n\ngetGoodData <- function(){\n  \n  for(i in 1:100){\n    print(i)\n    \n    users <- getUsers(5, seed=i)\n    products <- getProducts(5, seed=i)\n    transactions <- getTransactions(10, products, users, orphanUsers=.1, naUsers=.1, seed=i)\n    sessions <- getSessions(10, users, seed=i)\n    \n    # Are some users not in transactions?\n    test1 <- nrow(users[!transactions, on="UserID"]) > 0\n    \n    # Is there an instance of a user who has a session on the same day he registered?\n    test2 <- nrow(users[sessions, on=c("UserID", "Registered" = "SessionDate"), nomatch=0]) > 1\n    \n    if(test1 == TRUE & test2 == TRUE){\n      users <<- users\n      products <<- products\n      transactions <<- transactions\n      sessions <<- sessions\n      print(paste("Good key:", i))\n      \n      break\n    }\n  }\n}\n\ngetGoodData()\n\n#--------------------------------------------------\n# Save results to CSV\n\nwrite.csv(users, "Data/users.csv", row.names=FALSE)\nwrite.csv(products, "Data/products.csv", row.names=FALSE)\nwrite.csv(transactions, "Data/transactions.csv", row.names=FALSE)\nwrite.csv(sessions, "Data/sessions.csv", row.names=FALSE)\n\n'