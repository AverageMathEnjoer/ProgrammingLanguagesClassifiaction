b'-- % cabal install hspec\n-- % runghc <this_file>\n\nimport Nat\nimport Small\n\nmain :: IO ()\nmain = hspec $ do\n    describe "my_plus_n" $\n      prop "behaves as model" $ \\(Small m) (Small n) -> m >= 0 && n >= 0\n        ==> my_from_n (my_to_n m `my_plus_n` my_to_n n) == m + n\n    describe "my_minus_n" $\n      prop "behaves as model" $ \\(Small m) (Small n) -> m >= n && n >= 0\n        ==> my_from_n (my_to_n m `my_minus_n` my_to_n n) == m - n\n    describe "my_mul_n" $\n      prop "behaves as model" $ \\(Small m) (Small n) -> m >= 1 && n >= 1\n        ==> my_from_n (my_to_n m `my_mul_n` my_to_n n) == m * n\n    describe "my_lt_n" $\n      prop "behaves as model" $ \\(Small m) (Small n) -> m >= 0 && n >= 0\n        ==> my_to_n m `my_lt_n` my_to_n n == (m < n)\n    describe "my_divide_n" $\n      prop "behaves as model" $ \\(Small m) (Small n) -> m >= 0 && n >= 1\n        ==> my_from_n (my_to_n m `my_divide_n` my_to_n n) == m `div` n\n    describe "my_remainder_n" $\n      prop "behaves as model" $ \\(Small m) (Small n) -> m >= 0 && n >= 1\n        ==> my_from_n (my_to_n m `my_remainder_n` my_to_n n) == m `mod` n\n\nmy_plus_n :: Nat -> Nat -> Nat\nmy_plus_n m n\n  | my_isZero_n n = m\n  | otherwise     = my_plus1_n (m `my_plus_n` my_minus1_n n)\n\nmy_isOne_n :: Nat -> Bool\nmy_isOne_n n\n  | my_isZero_n n               = False\n  | my_isZero_n (my_minus1_n n) = True\n  | otherwise                   = False\n\nmy_mul_n :: Nat -> Nat -> Nat\nmy_mul_n m n\n  | my_isOne_n n = m\n  | otherwise    = my_mul_n m (my_minus1_n n) `my_plus_n` m\n\nmy_minus_n :: Nat -> Nat -> Nat\nmy_minus_n m n\n  | my_isZero_n n = m\n  | otherwise     = my_minus1_n (m `my_minus_n` my_minus1_n n)\n\nmy_lt_n :: Nat -> Nat -> Bool\nmy_lt_n m n\n  | my_isZero_n n = False\n  | my_isZero_n m = True\n  | otherwise = my_lt_n (my_minus1_n m) (my_minus1_n n)\n\nmy_divide_n :: Nat -> Nat -> Nat\nmy_divide_n m n\n  | m `my_lt_n` n = my_zero_n\n  | otherwise     = my_plus1_n ((m `my_minus_n` n) `my_divide_n` n)\n\nmy_remainder_n :: Nat -> Nat -> Nat\nmy_remainder_n m n\n  | m `my_lt_n` n = m\n  | otherwise     = my_remainder_n (m `my_minus_n` n) n\n'