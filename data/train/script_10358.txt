b'{-# LANGUAGE ScopedTypeVariables #-}\n\nmodule Cachix.Client.Retry\n  ( retryAll,\n    retryAllWithLogging,\n    endlessRetryPolicy,\n    endlessConstantRetryPolicy,\n  )\nwhere\n\nimport Control.Exception.Safe (Handler (..), MonadMask, isSyncException)\nimport Control.Retry (RetryPolicy, RetryPolicyM, RetryStatus, constantDelay, exponentialBackoff, limitRetries, logRetries, recoverAll, recovering, skipAsyncExceptions)\nimport Protolude hiding (Handler (..))\n\nretryAll :: (MonadIO m, MonadMask m) => (RetryStatus -> m a) -> m a\nretryAll =\n  recoverAll defaultRetryPolicy\n\n-- Catches all exceptions except async exceptions with logging support\nretryAllWithLogging :: (MonadIO m, MonadMask m) => RetryPolicyM m -> (Bool -> SomeException -> RetryStatus -> m ()) -> m a -> m a\nretryAllWithLogging retryPolicy logger action = recovering retryPolicy handlers $ const action\n  where\n    handlers = skipAsyncExceptions ++ [exitSuccessHandler, loggingHandler]\n    exitSuccessHandler :: MonadIO m => RetryStatus -> Handler m Bool\n    exitSuccessHandler _ = Handler $ \\(_ :: ExitCode) -> return False\n    loggingHandler = logRetries exceptionPredicate logger\n    exceptionPredicate = return . isSyncException\n\ndefaultRetryPolicy :: RetryPolicy\ndefaultRetryPolicy =\n  exponentialBackoff (1000 * 1000) <> limitRetries 5\n\nendlessConstantRetryPolicy :: RetryPolicy\nendlessConstantRetryPolicy =\n  constantDelay (1000 * 1000)\n\nendlessRetryPolicy :: RetryPolicy\nendlessRetryPolicy =\n  exponentialBackoff (1000 * 1000)\n'