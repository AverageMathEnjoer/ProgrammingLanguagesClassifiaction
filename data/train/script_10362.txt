b'{-# Language BangPatterns, CPP #-} \n{-# OPTIONS_GHC -fno-warn-name-shadowing -fwarn-unused-imports #-}\n-- -Wall \n\n-- A module for stream processing built on top of Control.Monad.Par\n-- \n-- (In the future we may want to look into the stream interface used by\n--  the stream fusion framework, or iteratees/conduits/pipes.)\n\n#define DEBUGSTREAMS\n\nmodule Control.Monad.Par.Stream \n ( \n   streamMap, streamScan, streamFold\n , countupWin, generate\n , runParList, toListSpin\n , measureRate, measureRateList\n , browseStream\n , Stream, Window, WStream\n )\nwhere\nimport Control.Monad\n-- import Control.Monad.Par as P\nimport Control.Monad.Par.Scheds.Trace \nimport qualified Control.Monad.Par.Scheds.TraceInternal as PI\nimport Control.Monad.Par.IList\nimport Control.DeepSeq\n\nimport Data.Array.Unboxed as U\nimport Data.Array.CArray as C\nimport Data.Int\n\nimport Foreign.Storable\n\nimport GHC.Conc as Conc\nimport System.IO\nimport GHC.IO (unsafePerformIO, unsafeDupablePerformIO, unsafeInterleaveIO)\n\nimport Debug.Trace\nimport Control.Monad.Par.Logging\n\n\ndebugflag = True\n\n--------------------------------------------------------------------------------\n-- Types\n\ntype Stream a = IVar (IList a)\n\n-- A windowed stream passes chunks of stream elements.\ntype WStream a = Stream (Window a)\n\n#define CARRAY\n#ifdef CARRAY\ntype Window a = CArray Int a\n#else\ntype Window a = U.UArray Int a\n#endif\n\n\n--------------------------------------------------------------------------------\n-- Stream Operators\n\n-- | This version applies a function to every element in a stream,\n--   exposing data parallelism and pipeline parallelism.\nstreamMapDP :: NFData b => (a -> b) -> Stream a -> Par (Stream b)\nstreamMapDP fn instrm = \n    do outstrm <- new\n       fork$ loop instrm outstrm\n       return outstrm\n where\n  loop instrm outstrm = \n   do \n      ilst <- get instrm\n      case ilst of \n\tNull -> put outstrm Null -- End of stream.\n\tCons h t -> \n\t  do newtl <- new\n\t     h\' <- spawn (return$ fn h)\n-- WARNING: This only makes sense with continuation-stealing..  With child stealing this will go crazy.\n\t     fork$ loop t newtl\n\t     h\'\' <- get h\'\n\t     put outstrm (Cons h\'\' newtl)\n\t     \n\n-- This version exposes pipeline parallelism but no data parallelism.\n-- It shouldn\'t be necessary if fork is sufficiently efficient and if\n-- work stealing is done right.\nstreamMap :: NFData b => (a -> b) -> Stream a -> Par (Stream b)\nstreamMap fn instrm = \n    do outstrm <- new\n       fork$ loop instrm outstrm\n       return outstrm\n where\n  loop instrm outstrm = \n   do \n      ilst <- get instrm\n      case ilst of \n\tNull -> put outstrm Null -- End of stream.\n\tCons h t -> \n\t  do newtl <- new\n\t     put outstrm (Cons (fn h) newtl)\n\t     loop t newtl\n\n\n-- | Applies a stateful kernel to the stream.  Output stream elements match input one-to-one.\n-- streamScan :: (NFData b, NFData c) => \nstreamScan :: (NFData a, NFData b, NFData c) =>  -- <- TEMP, don\'t need NFData a in general.\n\t      (a -> b -> (a,c)) -> a -> Stream b -> Par (Stream c)\nstreamScan fn initstate instrm = \n    do outstrm <- new\n       fork$ loop initstate instrm outstrm\n       return outstrm\n where\n#ifdef DEBUGSTREAMS\n  -- Create a task log for each unique input stream fed to this function:\n  tasklog = unsafeNewTaskSeries (nameFromValue instrm)\n#endif\n\n  loop state instrm outstrm = \n   do \n      ilst <- get instrm\n      case ilst of \n\tNull -> put outstrm Null -- End of stream.\n\tCons h t -> \n\t  do newtl <- new\n\t     let (newstate, outp) = \n#ifdef DEBUGSTREAMS\n\t\t                    timePure tasklog$ fn state h\n#else\n\t\t                    fn state h\n#endif\n\t     put outstrm (Cons outp newtl)\n\t     loop newstate t newtl\n\n-- TODO: streamMapM -- monadic version.  Define the non-monadic one in\n-- terms of it and watch for performance regression.\n\n\n-- TODO: More flexible version that passes an "emit" function to the\n-- kernel so that it may produce zero output elements or more than one.\n-- This also enables nested parallelism within the kernel.\n-- \n-- streamKernel :: ((c -> Par ()) -> a -> b -> Par ()) -> a -> Stream b -> Par (Stream c)\n--\n-- ALSO: Can have a "concat" operator for streams of lists where\n-- streamScan . concat rewrites to streamKernel perhaps...\n\n\n\n-- | Reduce a stream to a single value.  This function will not return\n--   until it reaches the end-of-stream.\nstreamFold :: (a -> b -> a) -> a -> Stream b -> Par a\nstreamFold fn acc instrm = \n   do ilst <- get instrm\n      case ilst of \n\tNull     -> return acc \n\tCons h t -> streamFold fn (fn acc h) t \n\n-- | Generate a stream of the given length by applying the function to each index (starting at zero).\n-- \n-- WARNING, this source calls yield, letting other par computations\n-- run, but there is no backpressure.  Thus if the source runs at a\n-- higher rate than its consumer, buffered stream elements accumulate.\ngenerate :: NFData a => Int -> (Int -> a) -> Par (Stream a)\n-- NOTE: I don\'t currently know of a good way to do backpressure\n-- directly in this system... but here are some other options: \n--\n--   (1) we can use timers and look at maximum sustained rate.  \n\n--   (2) Also, we can use coarse grained global barriers.  That is, we\n--       can produce some number of output elements, wait until quiescence\n--       of all Par computations, and then produce more.\n\n--   (3) We can register computations that should only execute when a\n--       worker goes idle.  This is a simple form of priority scheduling.\ngenerate size fn = \n   do outstrm <- new\n      fork$ loop (0::Int) outstrm\n      return outstrm\n where \n  loop n strm | n == size = \n\t  do when debugflag (print_$ " [generate] Done.  Produced "++ show size++" elements.\\n")\n\t     put strm Null\n             return ()\n  loop n strm = \n    do \n       newtl <- new\n       put strm (Cons (fn n) newtl)\n       PI.yield  -- This is necessary to avoid starving others when there\n\t\t-- aren\'t enough worker threads to go around.\n       loop (n+1) newtl\n\n\n-- | Create a [windowed] stream of consecutive integers.  Generates at\n--   least the target number of elements windowed into segments of a\n--   specified size.\ncountupWin :: (Storable a, NFData a, Num a) => \n              Int -> Int -> Par (WStream a)\ncountupWin bufsize target = \n   generate num fn\n where \n  num = case r of 0 -> q\n\t\t  _ -> q+1\n  (q,r) = quotRem target bufsize\n  fn n = \n   let start = n * bufsize in\n   array (start,start + bufsize-1)\n         [(i, fromIntegral (n + fromIntegral i)) \n\t  | i <- [start .. start + bufsize-1]]\n\n\n-- | Measure the real-time rate of a Stream.\nmeasureRate :: Stream a -> IO ()\nmeasureRate strm = \n  do lazyls <- toListSpin strm\n     measureRateList lazyls\n\n-- | Measure the real-time rate of a Stream that has been converted to a list.\nmeasureRateList :: [a] -> IO ()\nmeasureRateList lazyls = \n  do \n     t0 <- getTime\n     print_$ " [measureRate] Counting stream rate starting at time: "++ show t0\n     loop t0 t0 (0::Int64) (0::Int64) lazyls\n     \n where \n  loop _     _    _     n [] = \n    do print_$ " [measureRate] Hit end of stream after "++show n++" elements."\n       return ()\n\n  loop start time lastN n (h:t) = \n       do \n\t  time2 <- getTime\n\t  if time2 - time > oneSecond then do\n\t    (print_$ " [measureRate] current rate: "++show (n+1-lastN) ++ \n\t             "  Total elems&time "++ commaint (n+1)++ "  " ++commaint (time2-start))\n\t    loop start time2 (n+1) (n+1) t\n\t   else do\n\t    loop start time  lastN (n+1) t\n\n\n-- | Use the keyboard to interactively browse through stream elements.\nbrowseStream :: Show a => Stream a -> IO ()\nbrowseStream strm = \n  do putStrLn$ "[browseStream] Beginning interactive stream browser, press enter for more elements:"\n     ls <- toListSpin strm\n     loop 0 ls\n where \n  loop n ls = \n   do putStr$ show n ++ "# "\n      hFlush stdout\n      c <- getChar      \n      if c == \'\\EOT\' -- User presses ctrl D to exit.\n       then putStrLn$ "[browseStream] Ctrl-D pressed, exiting."\n       else case ls of \n             []    -> putStrLn$ "[browseStream] Reached end of stream after "++show n++" elements."\n             (h:t) -> do print h\n\t\t         loop (n+1) t\n\n\n--------------------------------------------------------------------------------\n-- Conversion:\n\n-- Convert a stream to a lazy list.  Spin wait (with yield) until stream elements are available.\ntoListSpin :: Stream a -> IO [a]\ntoListSpin strm = \n   do x <- PI.pollIVar strm\n      case x of\n        Nothing  -> do Conc.yield       -- run other GHC threads\n                       toListSpin strm  -- spin wait\n\tJust (ils) -> \n\t    case ils of \n\t      Null     -> return []\n\t      Cons h t -> return (h : unsafePerformIO (unsafeInterleaveIO (toListSpin t)))\n\n\n-- TODO: If it is unavailable we should help run the computation and then try again.\n-- This version will do runParAsync itself:\n\n-- Run a Par computation to produce a stream.  Convert that stream to a lazy list.\nrunParList :: Par (Stream a) -> [a]\nrunParList = \n  undefined\n-- runForList parcomp = loop (runParAsync parcomp) \n--  where \n--   loop strm = \n--    do x <- pollIVar strm\n--       case x of\n--         Nothing  -> \n-- \t    -- For now we just spin:\n-- \t    do yield -- run other GHC threads\n-- \t       loop strm\n-- \tJust (ils) -> \n-- \t    case ils of \n-- \t      Null     -> return []\n-- \t      Cons h t -> return (h : unsafePerformIO (unsafeInterleaveIO (loop t)))\n\n\n\n\n--------------------------------------------------------------------------------\n-- Helpers and Scrap:\n\nprint_ msg = trace msg $ return ()\n\n_unsafe_io :: IO a -> Par a\n_unsafe_io io =  let x = unsafePerformIO io in\n\t\t x `seq` return x\n\n_unsafe_dupable :: IO a -> Par a\n_unsafe_dupable io = \n  let x = unsafeDupablePerformIO io in \n  x `seq` return x\n\ninstance NFData (U.UArray a b) where \n  rnf !arr = ()\n\ninstance NFData (C.CArray a b) where \n  rnf !arr = ()\n'