b'#pragma once\n#include "AssimpMesh.h"\n#include <ColladaExporter.h> //assimp\n\nbool AddMeshToScene(aiScene &scene, Mesh &mesh, std::vector<std::string> &boneNames, bool unity5OrNewer)\n{\n\tif (!mesh.wasAbleToRead) return false;\n\tif (mesh.m_VertexData.m_Streams.size() == 0) return false;\n\tif (mesh.m_VertexData.m_Channels.size() < 6) return false;\n\tif (mesh.m_VertexData.m_Channels[0].dimension != 3) return false;\n\n\t//Unity 4.x sees a ColorRGBA as one DWORD, while Unity 5.x+ sees it as four UNORM8 (equivalent to raw color channel value).\n\tif (unity5OrNewer && mesh.m_VertexData.m_Channels[2].format == 2 && mesh.m_VertexData.m_Channels[2].dimension == 4)\n\t{\n\t\tmesh.m_VertexData.m_Channels[2].dimension = 1;\n\t\tmesh.m_VertexData.m_Channels[2].format = 11; //UINT32\n\t}\n\t\n\tif (scene.mRootNode == nullptr)\n\t\tscene.mRootNode = new aiNode("Root");\n\n\tvoid* pVertexDataEnd = &((uint8_t*)mesh.m_VertexData.m_DataSize)[mesh.m_VertexData.dataByteCount];\n\n\taiMesh **pNewMeshList = new aiMesh*[scene.mNumMeshes + mesh.m_SubMeshes.size()]();\n\tmemcpy(pNewMeshList, scene.mMeshes, scene.mNumMeshes * sizeof(aiMesh*));\n\tdelete[] scene.mMeshes;\n\tscene.mMeshes = pNewMeshList;\n\n\taiMaterial **pNewMatList = new aiMaterial*[scene.mNumMeshes + mesh.m_SubMeshes.size()]();\n\tmemcpy(pNewMatList, scene.mMaterials, scene.mNumMaterials * sizeof(aiMaterial*));\n\tdelete[] scene.mMaterials;\n\tscene.mMaterials = pNewMatList;\n\n\tbool blendShapeValid = mesh.m_Shapes.shapes.size() > 0\n\t\t&& mesh.m_Shapes.shapes.size() == mesh.m_Shapes.channels.size()\n\t\t&& mesh.m_Shapes.shapes.size() == mesh.m_Shapes.fullWeights.size()\n\t\t&& mesh.m_Shapes.vertices.size() == (mesh.m_Shapes.shapes.size() * mesh.m_Shapes.shapes[0].vertexCount);\n\tfor (size_t i = 1; i < mesh.m_Shapes.shapes.size(); i++)\n\t{\n\t\tif (mesh.m_Shapes.shapes[i].vertexCount != mesh.m_Shapes.shapes[0].vertexCount)\n\t\t{\n\t\t\tblendShapeValid = false;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tfor (size_t i = 0; i < mesh.m_SubMeshes.size(); i++)\n\t{\n\t\t//LOOP NOT DESIGNED TO continue/break!\n\t\tSubMesh &subMesh = mesh.m_SubMeshes[i];\n\t\taiMesh *pAiMesh = new aiMesh();\n\t\tpAiMesh->mName = mesh.m_Name;\n\t\tif (mesh.m_SubMeshes.size() > 0)\n\t\t{\n\t\t\tchar subTemp[16];\n\t\t\tsprintf_s(subTemp, "_sub%u", (unsigned int)i);\n\t\t\tpAiMesh->mName.Append(subTemp);\n\t\t}\n\t\tpAiMesh->mPrimitiveTypes = aiPrimitiveType_TRIANGLE;\n\t\tpAiMesh->mNumVertices = subMesh.vertexCount;\n\t\tfor (int j = 0; j < mesh.m_VertexData.m_Channels.size() && j < 8; j++)\n\t\t{\n\t\t\tChannelInfo &channel = mesh.m_VertexData.m_Channels[j];\n\t\t\tif (channel.dimension > 0 && channel.dimension <= 4 && channel.stream < mesh.m_VertexData.m_Streams.size())\n\t\t\t{\n\t\t\t\tStreamInfo &stream = mesh.m_VertexData.m_Streams[channel.stream];\n\t\t\t\tuint8_t channelElementSize = mesh.m_VertexData.ChannelElementSize(channel.format, unity5OrNewer);\n\t\t\t\tif ((channel.offset + channel.dimension * channelElementSize) <= stream.stride \n\t\t\t\t\t&& ((QWORD)stream.offset + (QWORD)stream.stride * (QWORD)subMesh.vertexCount) <= mesh.m_VertexData.dataByteCount)\n\t\t\t\t{\n\t\t\t\t\tvoid *channelDataBuffer = nullptr;\n\t\t\t\t\tint channelType = j;\n\t\t\t\t\tsize_t outElements = 0;\n\t\t\t\t\tswitch (j)\n\t\t\t\t\t{\n\t\t\t\t\tcase 0: //pos\n\t\t\t\t\t\tif (channel.dimension == 3 && mesh.m_VertexData.IsFloatFormat(channel.format, unity5OrNewer))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tpAiMesh->mVertices = new aiVector3D[subMesh.vertexCount];\n\t\t\t\t\t\t\tchannelDataBuffer = pAiMesh->mVertices;\n\t\t\t\t\t\t\toutElements = 3;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 1: //normal\n\t\t\t\t\t\tif (channel.dimension == 3 && mesh.m_VertexData.IsFloatFormat(channel.format, unity5OrNewer))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tpAiMesh->mNormals = new aiVector3D[subMesh.vertexCount];\n\t\t\t\t\t\t\tchannelDataBuffer = pAiMesh->mNormals;\n\t\t\t\t\t\t\toutElements = 3;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 2: //color\n\t\t\t\t\t\tif (channel.dimension == 1 && mesh.m_VertexData.IsUIntFormat(channel.format, unity5OrNewer))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tpAiMesh->mColors[0] = new aiColor4D[subMesh.vertexCount];\n\t\t\t\t\t\t\tchannelDataBuffer = pAiMesh->mColors[0];\n\t\t\t\t\t\t\toutElements = 4;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 3: //uv1\n\t\t\t\t\t\tif (channel.dimension <= 3 && mesh.m_VertexData.IsFloatFormat(channel.format, unity5OrNewer))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tpAiMesh->mNumUVComponents[0] = channel.dimension;\n\t\t\t\t\t\t\tpAiMesh->mTextureCoords[0] = new aiVector3D[subMesh.vertexCount];\n\t\t\t\t\t\t\tchannelDataBuffer = pAiMesh->mTextureCoords[0];\n\t\t\t\t\t\t\toutElements = 3;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 4: //uv2\n\t\t\t\t\t\tif (channel.dimension <= 3 && mesh.m_VertexData.IsFloatFormat(channel.format, unity5OrNewer))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tpAiMesh->mNumUVComponents[1] = channel.dimension;\n\t\t\t\t\t\t\tpAiMesh->mTextureCoords[1] = new aiVector3D[subMesh.vertexCount];\n\t\t\t\t\t\t\tchannelDataBuffer = pAiMesh->mTextureCoords[1];\n\t\t\t\t\t\t\toutElements = 3;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 5: //uv3 or tangent\n\t\t\t\t\t\tif (mesh.m_VertexData.m_Channels.size() > 6)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (channel.dimension <= 3 && mesh.m_VertexData.IsFloatFormat(channel.format, unity5OrNewer))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tpAiMesh->mNumUVComponents[2] = channel.dimension;\n\t\t\t\t\t\t\t\tpAiMesh->mTextureCoords[2] = new aiVector3D[subMesh.vertexCount];\n\t\t\t\t\t\t\t\tchannelDataBuffer = pAiMesh->mTextureCoords[2];\n\t\t\t\t\t\t\t\toutElements = 3;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tchannelType = 7; //tangent\n\t\t\t\t\t\t\tif (channel.dimension == 3 && mesh.m_VertexData.IsFloatFormat(channel.format, unity5OrNewer))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tpAiMesh->mTangents = new aiVector3D[subMesh.vertexCount];\n\t\t\t\t\t\t\t\tchannelDataBuffer = pAiMesh->mTangents;\n\t\t\t\t\t\t\t\toutElements = 3;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 6: //uv4\n\t\t\t\t\t\tif (channel.dimension <= 3 && mesh.m_VertexData.IsFloatFormat(channel.format, unity5OrNewer))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tpAiMesh->mNumUVComponents[3] = channel.dimension;\n\t\t\t\t\t\t\tpAiMesh->mTextureCoords[3] = new aiVector3D[subMesh.vertexCount];\n\t\t\t\t\t\t\tchannelDataBuffer = pAiMesh->mTextureCoords[3];\n\t\t\t\t\t\t\toutElements = 3;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 7: //tangent\n\t\t\t\t\t\tif (channel.dimension == 3 && mesh.m_VertexData.IsFloatFormat(channel.format, unity5OrNewer))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tpAiMesh->mTangents = new aiVector3D[subMesh.vertexCount];\n\t\t\t\t\t\t\tchannelDataBuffer = pAiMesh->mTangents;\n\t\t\t\t\t\t\toutElements = 3;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (channelDataBuffer != NULL)\n\t\t\t\t\t{\n\t\t\t\t\t\tfor (unsigned int k = subMesh.firstVertex; k < (subMesh.firstVertex+subMesh.vertexCount); k++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tuint8_t*pCurVertex = &((uint8_t*)mesh.m_VertexData.m_DataSize)[stream.offset + k * stream.stride + channel.offset];\n\t\t\t\t\t\t\tfloat inData[4] = {};\n\t\t\t\t\t\t\tif (channelType == 2) //color\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tuint8_t color[4] = {};\n\t\t\t\t\t\t\t\tmesh.m_VertexData.ConvertChannelUInt32(pCurVertex, channel.format, 1, (unsigned int*)&color[0], unity5OrNewer);\n\t\t\t\t\t\t\t\tfor (unsigned int l = 0; l < 4; l++)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tinData[l] = ((float)color[l]) / 255.0f;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tmesh.m_VertexData.ConvertChannelFloat(pCurVertex, channel.format, channel.dimension, inData, unity5OrNewer);\n\t\t\t\t\t\t\tmemcpy(&((uint8_t*)channelDataBuffer)[outElements * sizeof(float) * (k - subMesh.firstVertex)], inData, outElements * sizeof(float));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (pAiMesh->mVertices != NULL)\n\t\t{\n\t\t\tfor (unsigned int j = 0; j < subMesh.vertexCount; j++)\n\t\t\t{\n\t\t\t\t/*pAiMesh->mVertices[j].x *= subMesh.localAABB.m_Extent.x;\n\t\t\t\tpAiMesh->mVertices[j].y *= subMesh.localAABB.m_Extent.y;\n\t\t\t\tpAiMesh->mVertices[j].z *= subMesh.localAABB.m_Extent.z;\n\t\t\t\tpAiMesh->mVertices[j].x += subMesh.localAABB.m_Center.x;\n\t\t\t\tpAiMesh->mVertices[j].y += subMesh.localAABB.m_Center.y;\n\t\t\t\tpAiMesh->mVertices[j].z += subMesh.localAABB.m_Center.z;*/\n\t\t\t\t//TODO: Fix orientation\n\t\t\t\tpAiMesh->mVertices[j].x = -pAiMesh->mVertices[j].x;\n\t\t\t}\n\t\t}\n\t\tif (pAiMesh->mNormals != NULL)\n\t\t{\n\t\t\tfor (unsigned int j = 0; j < subMesh.vertexCount; j++)\n\t\t\t{\n\t\t\t\tpAiMesh->mNormals[j].x = -pAiMesh->mNormals[j].x;\n\t\t\t}\n\t\t}\n\t\tif (pAiMesh->mTangents != NULL)\n\t\t{\n\t\t\tfor (unsigned int j = 0; j < subMesh.vertexCount; j++)\n\t\t\t{\n\t\t\t\tpAiMesh->mTangents[j].x = -pAiMesh->mTangents[j].x;\n\t\t\t}\n\t\t\tpAiMesh->mBitangents = new aiVector3D[subMesh.vertexCount]();\n\t\t\tif (pAiMesh->mNormals != NULL)\n\t\t\t{\n\t\t\t\tfor (unsigned int j = 0; j < subMesh.vertexCount; j++)\n\t\t\t\t{\n\t\t\t\t\taiVector3D &tan = pAiMesh->mTangents[j];\n\t\t\t\t\taiVector3D &norm = pAiMesh->mNormals[j];\n\t\t\t\t\t//Cross product of tangent and normal.\n\t\t\t\t\t//TODO: Check if this needs a normalization!\n\t\t\t\t\tpAiMesh->mBitangents[j] = aiVector3D(tan.y * norm.z - tan.z * norm.y, tan.z * norm.x - tan.x * norm.z, tan.x * norm.y - tan.y * norm.x);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tpAiMesh->mNumFaces = subMesh.indexCount / 3;\n\t\tpAiMesh->mFaces = new aiFace[pAiMesh->mNumFaces]();\n\t\tsize_t curFaceIndex = 0;\n\n\t\tunsigned int firstIndex = subMesh.firstByte / ((mesh.m_IndexFormat == 1) ? 4 : 2);\n\t\tfor (unsigned int i = firstIndex; i < (firstIndex+subMesh.indexCount) && i < mesh.m_IndexBuffer.size(); i++)\n\t\t{\n\t\t\tif (curFaceIndex == pAiMesh->mNumFaces) break;\n\t\t\taiFace &curFace = pAiMesh->mFaces[curFaceIndex];\n\t\t\tif (!curFace.mIndices)\n\t\t\t\tcurFace.mIndices = new unsigned int[3];\n\t\t\tcurFace.mIndices[curFace.mNumIndices++] = mesh.m_IndexBuffer[i] + subMesh.baseVertex - subMesh.firstVertex;\n\n\t\t\tif (curFace.mNumIndices == 3)\n\t\t\t{\n\t\t\t\tif (subMesh.topology && (i&1))\n\t\t\t\t{\n\t\t\t\t\t//always switch the winding\n\t\t\t\t\t//curFace.mIndices is {idx0, idx1, idx2}.\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tunsigned int newIndices[3] = {curFace.mIndices[2], curFace.mIndices[1], curFace.mIndices[0]};\n\t\t\t\t\tmemcpy(curFace.mIndices, newIndices, 3 * sizeof(unsigned int));\n\t\t\t\t}\n\t\t\t\tcurFaceIndex++;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (blendShapeValid && mesh.m_Shapes.vertices.size() >= ((size_t)subMesh.firstVertex + subMesh.vertexCount))\n\t\t{\n\t\t\tpAiMesh->mNumAnimMeshes = (unsigned int)mesh.m_Shapes.shapes.size();\n\t\t\tpAiMesh->mAnimMeshes = new aiAnimMesh*[pAiMesh->mNumAnimMeshes];\n\t\t\tfor (unsigned int j = 0; j < pAiMesh->mNumAnimMeshes; j++)\n\t\t\t{\n\t\t\t\taiAnimMesh *pAiAnimMesh = new aiAnimMesh();\n\n\t\t\t\tpAiAnimMesh->mNumVertices = subMesh.vertexCount;\n\t\t\t\tpAiAnimMesh->mVertices = new aiVector3D[subMesh.vertexCount];\n\t\t\t\tif (mesh.m_Shapes.shapes[j].hasNormals)\n\t\t\t\t\tpAiAnimMesh->mNormals = new aiVector3D[subMesh.vertexCount];\n\t\t\t\tif (mesh.m_Shapes.shapes[j].hasTangents)\n\t\t\t\t{\n\t\t\t\t\tpAiAnimMesh->mTangents = new aiVector3D[subMesh.vertexCount];\n\t\t\t\t\tpAiAnimMesh->mBitangents = new aiVector3D[subMesh.vertexCount];\n\t\t\t\t}\n\t\t\t\tunsigned int firstVertex = mesh.m_Shapes.shapes[j].firstVertex + subMesh.firstVertex;\n\t\t\t\tfor (unsigned int k = 0; k < subMesh.vertexCount; k++)\n\t\t\t\t{\n\t\t\t\t\tBlendShapeVertex &curInVertex = mesh.m_Shapes.vertices[firstVertex + k];\n\t\t\t\t\t//TODO: Check if the SubMesh\'s localAABB has to be applied!\n\t\t\t\t\tpAiAnimMesh->mVertices[k] = aiVector3D(-curInVertex.vertex.x, curInVertex.vertex.y, curInVertex.vertex.z);\n\t\t\t\t\tif (mesh.m_Shapes.shapes[j].hasNormals)\n\t\t\t\t\t\tpAiAnimMesh->mNormals[k] = aiVector3D(-curInVertex.normal.x, curInVertex.normal.y, curInVertex.normal.z);\n\t\t\t\t\tif (mesh.m_Shapes.shapes[j].hasTangents)\n\t\t\t\t\t{\n\t\t\t\t\t\tpAiAnimMesh->mTangents[k] = aiVector3D(-curInVertex.tangent.x, curInVertex.tangent.y, curInVertex.tangent.z);\n\t\t\t\t\t\taiVector3D &tan = pAiAnimMesh->mTangents[k];\n\t\t\t\t\t\taiVector3D norm;\n\t\t\t\t\t\tif (mesh.m_Shapes.shapes[j].hasNormals)\n\t\t\t\t\t\t\tnorm = pAiAnimMesh->mNormals[k];\n\t\t\t\t\t\telse if (pAiMesh->mNormals)\n\t\t\t\t\t\t\tnorm = pAiMesh->mNormals[k];\n\t\t\t\t\t\tpAiAnimMesh->mBitangents[k] = aiVector3D(tan.y * norm.z - tan.z * norm.y, tan.z * norm.x - tan.x * norm.z, tan.x * norm.y - tan.y * norm.x);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tpAiAnimMesh->mWeight = mesh.m_Shapes.fullWeights[j] / 100.0f; //Seems to be a percentage for some reason\n\n\t\t\t\tchar nameHashStr[24];\n\t\t\t\tsprintf_s(nameHashStr, "%u_", mesh.m_Shapes.channels[j].nameHash);\n\t\t\t\tpAiAnimMesh->mName = nameHashStr;\n\t\t\t\tpAiAnimMesh->mName.Append(mesh.m_Shapes.channels[j].name);\n\n\t\t\t\tpAiMesh->mAnimMeshes[j] = pAiAnimMesh;\n\t\t\t}\n\t\t}\n\n\t\tif (mesh.m_BindPose.size() > 0 \n\t\t\t//&& (mesh.m_BindPose.size() == mesh.m_BoneNameHashes.size())\n\t\t\t&& mesh.m_Skin.size() >= ((size_t)subMesh.firstVertex + subMesh.vertexCount))\n\t\t{\n\t\t\tstd::vector<unsigned int> boneWeightCount = std::vector<unsigned int>(mesh.m_BindPose.size());\n\t\t\tbool hasAnyBones = false;\n\t\t\tfor (size_t i = subMesh.firstVertex; i < (subMesh.firstVertex + subMesh.vertexCount); i++)\n\t\t\t{\n\t\t\t\tBoneInfluence &curVertexSkin = mesh.m_Skin[i];\n\t\t\t\tfor (int j = 0; j < 4; j++)\n\t\t\t\t{\n\t\t\t\t\tif (curVertexSkin.weight[j] > 0.0f && curVertexSkin.boneIndex[j] < mesh.m_BindPose.size())\n\t\t\t\t\t{\n\t\t\t\t\t\tboneWeightCount[curVertexSkin.boneIndex[j]]++;\n\t\t\t\t\t\thasAnyBones = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (hasAnyBones)\n\t\t\t{\n\t\t\t\tunsigned int curBoneCount = 0;\n\t\t\t\tstd::vector<unsigned int> boneIndexMap = std::vector<unsigned int>(mesh.m_BindPose.size(), (unsigned int)-1);\n\t\t\t\tfor (size_t i = 0; i < mesh.m_BindPose.size(); i++)\n\t\t\t\t\tif (boneWeightCount[i])\n\t\t\t\t\t\tboneIndexMap[i] = curBoneCount++;\n\n\t\t\t\tpAiMesh->mNumBones = curBoneCount;\n\t\t\t\tpAiMesh->mBones = new aiBone*[curBoneCount];\n\t\t\t\tunsigned int curBoneIndex = 0;\n\t\t\t\tfor (size_t i = 0; i < mesh.m_BindPose.size(); i++)\n\t\t\t\t{\n\t\t\t\t\tif (boneWeightCount[i])\n\t\t\t\t\t{\n\t\t\t\t\t\taiBone *pAiBone = new aiBone();\n\t\t\t\t\t\tpAiBone->mWeights = new aiVertexWeight[boneWeightCount[i]]();\n\t\t\t\t\t\tMatrix4x4f &m = mesh.m_BindPose[i];\n\t\t\t\t\t\t//Let the transformation matrix be ((a1 a2 a3 a4) (b1 ...) ... (d1 d2 d3 d4)).\n\t\t\t\t\t\t//Since the vertex positions are flipped around the y-z-plane (x *= -1), \n\t\t\t\t\t\t//we need to 1) unflip it\n\t\t\t\t\t\t//   (i.e. negate transform.a1, b1, c1, which will be multiplied with the negated x coordinate => transformed as if x was not flipped)\n\t\t\t\t\t\t//and 2) flip it again after the transformation\n\t\t\t\t\t\t//   (i.e. multiply the transformation matrix with ((-1 0 0 0) (0 1 0 0) (0 0 1 0) (0 0 0 1)), which causes the resulting x coordinate to be flipped).\n\t\t\t\t\t\t//Fused together : a2, a3, a4, b1, c1 have to be negated in order to account for the negated x vertex coordinate.\n\t\t\t\t\t\tpAiBone->mOffsetMatrix = aiMatrix4x4\n\t\t\t\t\t\t\t(m.e[0][0], -m.e[0][1], -m.e[0][2], -m.e[0][3],\n\t\t\t\t\t\t\t-m.e[1][0], m.e[1][1], m.e[1][2], m.e[1][3],\n\t\t\t\t\t\t\t-m.e[2][0], m.e[2][1], m.e[2][2], m.e[2][3],\n\t\t\t\t\t\t\tm.e[3][0], m.e[3][1], m.e[3][2], m.e[3][3]);\n\t\t\t\t\t\tif (boneNames.size() > i)\n\t\t\t\t\t\t\tpAiBone->mName = boneNames[i];\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tchar boneNameTemp[16];\n\t\t\t\t\t\t\tif (mesh.m_BoneNameHashes.size() > i)\n\t\t\t\t\t\t\t\tsprintf_s(boneNameTemp, "%u", mesh.m_BoneNameHashes[i]);\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tsprintf_s(boneNameTemp, "i%u", (unsigned int)i);\n\t\t\t\t\t\t\tpAiBone->mName = boneNameTemp;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tpAiMesh->mBones[boneIndexMap[i]] = pAiBone;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (size_t i = subMesh.firstVertex; i < ((size_t)subMesh.firstVertex + subMesh.vertexCount); i++)\n\t\t\t\t{\n\t\t\t\t\tBoneInfluence &curVertexSkin = mesh.m_Skin[i];\n\t\t\t\t\tfor (int j = 0; j < 4; j++)\n\t\t\t\t\t{\n\t\t\t\t\t\tunsigned int targetIndex;\n\t\t\t\t\t\tif (curVertexSkin.weight[j] > 0 && curVertexSkin.boneIndex[j] < mesh.m_BindPose.size()\n\t\t\t\t\t\t\t&& (targetIndex = boneIndexMap[curVertexSkin.boneIndex[j]]) != (unsigned int)-1)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\taiBone *pAiTargetBone = pAiMesh->mBones[targetIndex];\n\t\t\t\t\t\t\taiVertexWeight &vertexWeight = pAiTargetBone->mWeights[pAiTargetBone->mNumWeights++];\n\t\t\t\t\t\t\tvertexWeight.mVertexId = (unsigned int)(i - subMesh.firstVertex);\n\t\t\t\t\t\t\tvertexWeight.mWeight = curVertexSkin.weight[j];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\taiMaterial *pAiMat = new aiMaterial();\n\t\tpAiMesh->mMaterialIndex = scene.mNumMaterials;\n\t\tscene.mMaterials[scene.mNumMaterials++] = pAiMat;\n\n\t\tscene.mMeshes[scene.mNumMeshes++] = pAiMesh;\n\t}\n\n\taiNode *pMeshNode = new aiNode(mesh.m_Name);\n\t/*aiMatrix4x4 translation; aiMatrix4x4 scaling;\n\taiMatrix4x4::Translation(aiVector3D(mesh.m_LocalAABB.m_Center.x, mesh.m_LocalAABB.m_Center.y, mesh.m_LocalAABB.m_Center.z), translation);\n\taiMatrix4x4::Scaling(aiVector3D(mesh.m_LocalAABB.m_Extent.x, mesh.m_LocalAABB.m_Extent.y, mesh.m_LocalAABB.m_Extent.z), scaling);\n\tpMeshNode->mTransformation = translation * scaling;*/\n\n\tpMeshNode->mNumMeshes = (unsigned int)mesh.m_SubMeshes.size();\n\tpMeshNode->mMeshes = new unsigned int[pMeshNode->mNumMeshes];\n\tfor (unsigned int i = 0; i < pMeshNode->mNumMeshes; i++)\n\t\tpMeshNode->mMeshes[i] = scene.mNumMeshes - pMeshNode->mNumMeshes + i;\n\n\tscene.mRootNode->addChildren(1, &pMeshNode);\n\n\treturn true;\n}\n\nbool WriteScene(aiScene &scene, IAssetsWriter *pWriter)\n{\n\tAssimp::ColladaExporter exporter(&scene, NULL, std::string(), std::string());\n\tchar *outputBuffer = new char[4096]();\n\t\n\texporter.mOutput.seekp(0, std::ios::end);\n\tsize_t fileSize = exporter.mOutput.tellp();\n\texporter.mOutput.seekg(0, std::ios::beg);\n\twhile (fileSize >= 4096)\n\t{\n\t\texporter.mOutput.read(outputBuffer, 4096);\n\t\tif (pWriter->Write(4096, outputBuffer) != 4096)\n\t\t{\n\t\t\tdelete[] outputBuffer;\n\t\t\treturn false;\n\t\t}\n\t\tfileSize -= 4096;\n\t}\n\tbool ret = true;\n\tif (fileSize > 0)\n\t{\n\t\texporter.mOutput.read(outputBuffer, fileSize);\n\t\tret = pWriter->Write(fileSize, outputBuffer) == fileSize;\n\t}\n\tdelete[] outputBuffer;\n\treturn ret;\n}\n\n\nvoid ComposeMatrix(Quaternionf &rotation, Vector3f &position, Vector3f &scale, aiMatrix4x4 &out)\n{\n\tout = aiMatrix4x4(aiVector3D(scale.x, scale.y, scale.z), aiQuaternion(rotation.w, rotation.x, rotation.y, rotation.z), aiVector3D(position.x, position.y, position.z));\n}'