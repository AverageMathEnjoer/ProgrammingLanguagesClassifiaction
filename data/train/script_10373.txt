b'{-# LANGUAGE AllowAmbiguousTypes #-}\nmodule Database.Beam.Postgres.Test.Marshal where\n\nimport           Database.Beam\nimport           Database.Beam.Backend.SQL\nimport           Database.Beam.Backend.SQL.BeamExtensions\nimport           Database.Beam.Migrate\nimport           Database.Beam.Migrate.Simple (autoMigrate)\nimport           Database.Beam.Postgres\nimport           Database.Beam.Postgres.Migrate (migrationBackend)\nimport           Database.Beam.Postgres.Test\n\nimport           Data.ByteString (ByteString)\nimport           Data.Functor.Classes\nimport           Data.Int\nimport qualified Data.Text as T\nimport           Data.Typeable\nimport           Data.UUID (UUID, fromWords)\nimport           Data.Word\n\nimport qualified Hedgehog\nimport           Hedgehog ((===))\nimport qualified Hedgehog.Gen as Gen\nimport qualified Hedgehog.Range as Range\n\nimport           Test.Tasty\nimport           Test.Tasty.HUnit\n\nimport           Unsafe.Coerce\n\ntextGen :: Hedgehog.Gen T.Text\ntextGen = Gen.text (Range.constant 0 1000) $ Gen.filter (/= \'\\NUL\') Gen.unicode\n\nuuidGen :: Hedgehog.Gen UUID\nuuidGen = fromWords <$> Gen.integral Range.constantBounded\n                    <*> Gen.integral Range.constantBounded\n                    <*> Gen.integral Range.constantBounded\n                    <*> Gen.integral Range.constantBounded\n\npointGen :: Hedgehog.Gen PgPoint\npointGen = PgPoint <$> Gen.double (Range.constant 0 1000)\n                   <*> Gen.double (Range.constant 0 1000)\n\nboxGen :: Hedgehog.Gen PgBox\nboxGen = do PgPoint x1 y1 <- pointGen\n            PgPoint x2 y2 <- pointGen\n            pure (PgBox (PgPoint (min x1 x2) (min y1 y2))\n                        (PgPoint (max x1 x2) (max y1 y2)))\n\nboxCmp :: PgBox -> PgBox -> Bool\nboxCmp (PgBox a1 b1) (PgBox a2 b2) =\n    (a1 `ptCmp` a2 && b1 `ptCmp` b2) ||\n    (a1 `ptCmp` b2 && b1 `ptCmp` a2)\n\nptCmp :: PgPoint -> PgPoint -> Bool\nptCmp (PgPoint x1 y1) (PgPoint x2 y2) =\n    x1 `dblCmp` x2 && y1 `dblCmp` y2\n\ndblCmp :: Double -> Double -> Bool\ndblCmp x y =\n    let ulp = abs ((unsafeCoerce x :: Int64) - (unsafeCoerce y :: Int64))\n    in ulp < 50\n\ntests :: IO ByteString -> TestTree\ntests postgresConn =\n    testGroup "Postgres Marshaling tests"\n    [ marshalTest Gen.bool postgresConn\n    , marshalTest (Gen.integral (Range.constantBounded @Int16))  postgresConn\n    , marshalTest (Gen.integral (Range.constantBounded @Int32))  postgresConn\n    , marshalTest (Gen.integral (Range.constantBounded @Int64))  postgresConn\n    , marshalTest (Gen.integral (Range.constantBounded @Word16)) postgresConn\n    , marshalTest (Gen.integral (Range.constantBounded @Word32)) postgresConn\n    , marshalTest (Gen.integral (Range.constantBounded @Word64)) postgresConn\n    , marshalTest textGen postgresConn\n    , marshalTest uuidGen postgresConn\n\n    , marshalTest\' (\\a b -> Hedgehog.assert (ptCmp a b))  pointGen postgresConn\n    , marshalTest\' (\\a b -> Hedgehog.assert (boxCmp a b)) boxGen   postgresConn\n\n    , marshalTest (Gen.maybe Gen.bool) postgresConn\n    , marshalTest (Gen.maybe (Gen.integral (Range.constantBounded @Int16)))  postgresConn\n    , marshalTest (Gen.maybe (Gen.integral (Range.constantBounded @Int32)))  postgresConn\n    , marshalTest (Gen.maybe (Gen.integral (Range.constantBounded @Int64)))  postgresConn\n    , marshalTest (Gen.maybe (Gen.integral (Range.constantBounded @Word16))) postgresConn\n    , marshalTest (Gen.maybe (Gen.integral (Range.constantBounded @Word32))) postgresConn\n    , marshalTest (Gen.maybe (Gen.integral (Range.constantBounded @Word64))) postgresConn\n    , marshalTest (Gen.maybe textGen) postgresConn\n    , marshalTest (Gen.maybe uuidGen) postgresConn\n\n    , marshalTest\' (\\a b -> Hedgehog.assert (liftEq ptCmp a b))  (Gen.maybe pointGen) postgresConn\n    , marshalTest\' (\\a b -> Hedgehog.assert (liftEq boxCmp a b)) (Gen.maybe boxGen) postgresConn\n\n--    , marshalTest (Gen.double  (Range.exponentialFloat 0 1e40))  postgresConn\n--    , marshalTest (Gen.integral (Range.constantBounded @Word))   postgresConn\n--    , marshalTest (Gen.integral (Range.constantBounded @Int))    postgresConn\n\n--    , marshalTest @Int8    postgresConn\n--    , marshalTest @Integer postgresConn\n--    , marshalTest @Word8   postgresConn\n--    , marshalTest @TL.Text postgresConn\n    -- TODO MORE!!!!\n    ]\n\ndata MarshalTable a f\n    = MarshalTable\n    { _marshalTableId    :: C f (SqlSerial Int32)\n    , _marshalTableEntry :: C f a\n    } deriving (Generic)\ninstance Beamable (MarshalTable a)\n\ninstance Typeable a => Table (MarshalTable a) where\n    data PrimaryKey (MarshalTable a) f = MarshalTableKey (C f (SqlSerial Int32))\n      deriving (Generic, Beamable)\n    primaryKey = MarshalTableKey . _marshalTableId\n\ndata MarshalDb a entity\n    = MarshalDb\n    { _marshalTbl :: entity (TableEntity (MarshalTable a))\n    } deriving (Generic)\ninstance Typeable a => Database Postgres (MarshalDb a)\n\nmarshalTest :: forall a\n             . ( Typeable a, Eq a, Show a\n               , BeamSqlBackendSupportsDataType Postgres a\n               , HasDefaultSqlDataType Postgres a\n               , HasNullableConstraint (NullableStatus a) Postgres )\n            => Hedgehog.Gen a -> IO ByteString -> TestTree\nmarshalTest = marshalTest\' (===)\n\nmarshalTest\' :: forall a\n              . ( Typeable a, Show a\n                , BeamSqlBackendSupportsDataType Postgres a\n                , HasDefaultSqlDataType Postgres a\n                , HasNullableConstraint (NullableStatus a) Postgres )\n             => (forall m. (Hedgehog.MonadTest m, HasCallStack) => a -> a -> m ()) -> Hedgehog.Gen a -> IO ByteString -> TestTree\nmarshalTest\' cmp gen postgresConn =\n  testCase ("Can marshal " ++ show (typeRep (Proxy @a))) $\n  withTestPostgres ("db_marshal_" <> show (typeRepFingerprint (typeRep (Proxy @a))))\n                   postgresConn $ \\conn -> do\n    let marshalDbSettings = defaultMigratableDbSettings @Postgres @(MarshalDb a)\n        marshalDb = unCheckDatabase marshalDbSettings\n\n    runBeamPostgres conn $ do\n      autoMigrate migrationBackend marshalDbSettings\n\n    putStrLn "\\n"\n\n    passes <- Hedgehog.check . Hedgehog.property $ do\n      a <- Hedgehog.forAll gen\n\n      [MarshalTable rowId v] <-\n        liftIO . runBeamPostgres conn $\n        runInsertReturningList $ insert (_marshalTbl marshalDb) $ insertExpressions [ MarshalTable default_ (val_ a) ]\n      v `cmp` a\n\n      Just (MarshalTable _ v\') <-\n          liftIO . runBeamPostgres conn $\n          runSelectReturningOne (lookup_ (_marshalTbl marshalDb) (MarshalTableKey rowId))\n      v\' `cmp` a\n\n    assertBool "Hedgehog test failed" passes\n\n'