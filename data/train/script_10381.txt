b'{-# LANGUAGE CPP #-}\n\n-- A quicksort benchmark for monad-par\n\nimport Control.Monad\nimport qualified Data.Vector.Unboxed as V\nimport qualified Data.Vector.Unboxed.Mutable as MV\nimport Data.Vector.Algorithms.Intro (sort)\n\nimport Data.List.Split (chunk)\nimport Data.List (intersperse)\n\nimport System.Random\nimport System.Environment\nimport Data.Time.Clock\nimport Text.Printf\nimport Control.Exception\n\n\n#ifdef PARSCHED \nimport PARSCHED\n#else\nimport Control.Monad.Par\n-- import Control.Monad.Par.Scheds.Trace\n#endif\n\nquicksortP :: Int -> V.Vector Int -> Par (V.Vector Int)\nquicksortP t vec  = if V.length vec <= t\n                    then return $ seqSort vec\n                    else\n                    -- just use the head as the pivot\n                    let pivot = V.head vec\n                        rest  = V.tail vec in\n                    -- since we\'re using unboxed Ints, unstable partition should be fine\n                    let (low, high) = V.unstablePartition (< pivot) vec in\n                    do\n                      lefti <- spawn_ $ quicksortP t low\n                      right <-          quicksortP t high\n                      left  <- get lefti\n                      return $ left V.++ right\n\nseqSort :: V.Vector Int -> V.Vector Int\nseqSort vec = V.create $ do \n                mut <- V.thaw vec\n                sort mut\n                return mut\n\n-- Create a vector containing the numbers [0,N) in random order.\nrandomPermutation :: Int -> StdGen -> V.Vector Int\nrandomPermutation len rng = \n  -- Annoyingly there is no MV.generate:\n  V.create (do v <- V.unsafeThaw$ V.generate len id\n               loop 0 v rng)\n  -- loop 0 (MV.generate len id)\n where \n  loop n vec g | n == len  = return vec\n\t       | otherwise = do \n    let (offset,g\') = randomR (0, len - n - 1) g\n--    MV.unsafeSwap vec n \n    MV.swap vec n (n + offset)\n    loop (n+1) vec g\'\n\n\ncommaint :: (Show a, Integral a) => a -> String\ncommaint n | n < 0 = "-" ++ commaint (-n)\ncommaint n = \n   reverse $ concat $\n   intersperse "," $ \n   chunk 3 $ reverse (show n)\n\n\n-- Main, based on mergesort main\n-- Usage: ./Main [size_expt] [t]\n-- t is the threshold for doing sequential sort\n-- expt controls the length of the vector to sort (length = 2^expt)\nmain = do args <- getArgs\n          let (size, t) = case args of\n                            []  -> (18, 2)\n                            [n] -> (read n, 2)\n                            [n, t] -> (read n, read t)\n\n          g <- getStdGen\n\n          putStrLn $ "Quick sorting " ++ commaint (2^size) ++\n                     " elements with threshold " ++ show t ++ \n                     ". First generate a random permutation: "\n\n          start <- getCurrentTime\n          let rands = randomPermutation (2^size) g\n          evaluate $ rands\n          evaluate $ rands V.! 0\n          end   <- getCurrentTime\n          printf "Creating vector took %0.3f sec. \\n"\n            ((fromRational $ toRational $ diffUTCTime end start) :: Double)\n\n          putStrLn "Executing monad-par based sort..."\n          start <- getCurrentTime\n          let sorted = runPar $ quicksortP t rands\n          putStr "Prefix of sorted list:\\n  "\n          print $ V.slice 0 8 sorted\n          end   <- getCurrentTime\n\n          let runningTime = ((fromRational $ toRational $ diffUTCTime end start) :: Double)\n          printf "Sorting vector took %0.3f sec.\\n" runningTime\n          putStrLn $ "SELFTIMED " ++ show runningTime\n          when (size <= 4) $ do\n            putStrLn$ "  Unsorted: " ++  show rands\n            putStrLn$ "  Sorted  : " ++  show sorted\n\n--prop_aqs :: [Int] -> Bool\n--prop_aqs xs = L.sort xs == (A.toList $ aqs (A.fromListBalanced xs))\n'