b'// Copyright (c) 2022-2023 Manuel Schneider\n\n#include "albert/albert.h"\n#include "albert/config.h"\n#include "albert/extensionregistry.h"\n#include "albert/extensions/frontend.h"\n#include "albert/logging.h"\n#include "nativepluginprovider.h"\n#include <QCoreApplication>\n#include <QDir>\n#include <QDirIterator>\n#include <QFileInfo>\n#include <QIcon>\n#include <QLabel>\n#include <QMessageBox>\n#include <QPluginLoader>\n#include <QSettings>\n#include <set>\nusing namespace std;\nusing namespace albert;\n\nstatic const char *CFG_FRONTEND_ID = "frontend";\nstatic const char *DEF_FRONTEND_ID = "widgetsboxmodel";\nstatic const QRegularExpression regex_iid = QRegularExpression(R"R(org.albert.PluginInterface/(\\d+).(\\d+))R");\nstatic const QRegularExpression regex_version = QRegularExpression(R"(^\\d+\\.\\d+$)");\nstatic const QRegularExpression regex_id = QRegularExpression("[a-z0-9_]");\n\nstatic NativePluginMetaData *current_meta_data = nullptr;\nstatic ExtensionRegistry *extension_registry = nullptr;\n\nstatic QStringList defaultPaths()\n{\n    QStringList default_paths;\n#if defined __linux__ || defined __FreeBSD__\n    QStringList dirs = {\n        QDir::home().filePath(".local/lib/"),\n        QDir::home().filePath(".local/lib64/"),\n        QFileInfo("/usr/local/lib/").canonicalFilePath(),\n        QFileInfo("/usr/local/lib64/").canonicalFilePath(),\n#if defined MULTIARCH_TUPLE\n        QFileInfo("/usr/lib/" MULTIARCH_TUPLE).canonicalFilePath(),\n#endif\n        QFileInfo("/usr/lib/").canonicalFilePath(),\n        QFileInfo("/usr/lib64/").canonicalFilePath(),\n    };\n    dirs.removeDuplicates();\n    for ( const QString& dir : dirs ) {\n        QFileInfo fileInfo = QFileInfo(QDir(dir).filePath("albert"));\n        if ( fileInfo.isDir() )\n            default_paths.push_back(fileInfo.canonicalFilePath());\n    }\n#elif defined __APPLE__\n    QDir d(QCoreApplication::applicationDirPath());\n    d.cd("../lib");\n    default_paths.push_back(d.canonicalPath()); // TODO deplopyment?\n    d.cd("../Resources");\n    default_paths.push_back(d.canonicalPath()); // TODO deplopyment?\n#elif defined _WIN32\n    qFatal("Not implemented");\n#endif\n    return default_paths;\n}\n\nNativePluginLoader::NativePluginLoader(NativePluginProvider *provider, ExtensionRegistry &registry, const QString &p)\n    : PluginLoader(p), provider_(provider), registry_(registry)\n{\n    QPluginLoader loader(path);\n\n    // Extract metadata\n\n    metadata_.iid = loader.metaData()["IID"].toString();\n    if (metadata_.iid.isEmpty())\n        throw runtime_error("Not an albert plugin");\n\n    auto rawMetadata = loader.metaData()["MetaData"].toObject();\n    metadata_.id = rawMetadata["id"].toString();\n    metadata_.version = rawMetadata["version"].toString();\n    metadata_.name = rawMetadata["name"].toString();\n    metadata_.description = rawMetadata["description"].toString();\n    metadata_.long_description = rawMetadata["long_description"].toString();\n    metadata_.license = rawMetadata["license"].toString();\n    metadata_.url = rawMetadata["url"].toString();\n    metadata_.maintainers = rawMetadata["maintainers"].toVariant().toStringList();\n    metadata_.runtime_dependencies = rawMetadata["runtime_dependencies"].toVariant().toStringList();\n    metadata_.binary_dependencies = rawMetadata["binary_dependencies"].toVariant().toStringList();\n    metadata_.third_party_credits = rawMetadata["credits"].toVariant().toStringList();\n    metadata_.frontend = rawMetadata["frontend"].toBool();\n    metadata_.user = !metadata_.frontend;\n\n    // Validate metadata\n\n    QStringList errors;\n\n    if (auto iid_match = regex_iid.match(metadata_.iid); !iid_match.hasMatch())\n        errors << QString("Invalid IID pattern: \'%1\'. Expected \'%2\'.")\n                      .arg(iid_match.captured(), iid_match.regularExpression().pattern());\n    else if (auto plugin_iid_major = iid_match.captured(1).toUInt(); plugin_iid_major != ALBERT_VERSION_MAJOR)\n            errors << QString("Incompatible major version: %1. Expected: %2.")\n                          .arg(plugin_iid_major).arg(ALBERT_VERSION_MAJOR);\n    else if (auto plugin_iid_minor = iid_match.captured(2).toUInt(); plugin_iid_minor > ALBERT_VERSION_MINOR)\n            errors << QString("Incompatible minor version: %1. Supported up to: %2.")\n                          .arg(plugin_iid_minor).arg(ALBERT_VERSION_MINOR);\n\n    if (!regex_version.match(metadata_.version).hasMatch())\n        errors << "Invalid version scheme. Use \'<version>.<patch>\'.";\n\n    if (!regex_id.match(metadata_.id).hasMatch())\n        errors << "Invalid plugin id. Use [a-z0-9_].";\n\n    if (metadata_.name.isEmpty())\n        errors << "\'name\' must not be empty.";\n\n    if (metadata_.description.isEmpty())\n        errors << "\'description\' must not be empty.";\n\n    // Finally set state based on errors\n\n    if (errors.isEmpty())\n        state_ = PluginState::Unloaded;\n    else{\n        WARN << QString("Plugin invalid: %1. (%2)").arg(errors.join(", "), path);\n        state_info_ = errors.join(", ");\n    }\n}\n\nNativePluginLoader::~NativePluginLoader()\n{\n    if (state_ == PluginState::Loaded)\n        NativePluginLoader::unload();\n}\n\nNativePluginInstance *NativePluginLoader::instance() const { return instance_; }\n\nNativePluginProvider *NativePluginLoader::provider() const { return provider_; }\n\nconst NativePluginMetaData &NativePluginLoader::metaData() const { return metadata_; }\n\nvoid NativePluginLoader::load()\n{\n    if (state_ == PluginState::Invalid)\n        qFatal("Loaded an invalid plugin.");\n    else if (state_ == PluginState::Loaded)\n        return;\n\n    QPluginLoader loader(path);\n    // Some python libs do not link against python. Export the python symbols to the main app.\n    loader.setLoadHints(QLibrary::ExportExternalSymbolsHint);// | QLibrary::PreventUnloadHint);\n    try {\n        // inject using static vars for default constructability\n        current_meta_data = &metadata_;\n        extension_registry = &registry_;\n\n        if (auto *instance = loader.instance()){\n            if ((instance_ = dynamic_cast<NativePluginInstance*>(instance))){\n                state_ = PluginState::Loaded;\n                state_info_.clear();\n                if (auto *e = dynamic_cast<Extension*>(instance))  // Auto registration\n                    registry_.add(e);\n                return;\n            } else\n                state_info_ = "Plugin is not of type Plugin";\n        } else\n            state_info_ = loader.errorString();\n    } catch (const exception& e) {\n        state_info_ = e.what();\n    } catch (...) {\n        state_info_ = "Unknown exception.";\n    }\n    state_ = PluginState::Unloaded;\n    loader.unload();\n}\n\nvoid NativePluginLoader::unload()\n{\n    if (state_ == PluginState::Invalid)\n        qFatal("Unloaded an invalid plugin.");\n    else if (state_ == PluginState::Unloaded)\n        return;\n\n    if (auto *e = dynamic_cast<Extension*>(instance_))  // Auto deregistration\n        registry_.remove(e);\n    QPluginLoader loader(path);\n    delete instance_;  // TODO this saves from segfaults but actually this is QPluginLoaders job\n    instance_ = nullptr;\n    loader.unload();\n    state_info_.clear();\n    state_ = PluginState::Unloaded;\n}\n\n\n// ///////////////////////////////////////////////////////////////////////////////////////////// //\n\n\nclass NativePluginInstance::Private\n{\npublic:\n    NativePluginMetaData &metaData = *current_meta_data;\n    ExtensionRegistry &registry = *extension_registry;\n};\n\nNativePluginInstance::NativePluginInstance(): d(std::make_unique<Private>()) {}\n\nNativePluginInstance::~NativePluginInstance() = default;\n\nExtensionRegistry &NativePluginInstance::registry()\n{\n    return d->registry;\n}\n\nconst NativePluginMetaData &NativePluginInstance::metaData() const { return d->metaData; }\n\n\n\n// ///////////////////////////////////////////////////////////////////////////////////////////// //\n\n\nQString ExtensionPlugin::id() const { return metaData().id; }\n\nQString ExtensionPlugin::name() const { return metaData().name; }\n\nQString ExtensionPlugin::description() const { return metaData().description; }\n\n\n// ///////////////////////////////////////////////////////////////////////////////////////////// //\n\n\nNativePluginProvider::NativePluginProvider(ExtensionRegistry &registry, const QStringList &additional_paths):\n    frontend_(nullptr)\n{\n    QStringList paths;\n    if (!additional_paths.isEmpty())\n        paths << additional_paths;\n    paths << defaultPaths();\n\n    for (const auto &path : paths) {\n        DEBG << "Searching native plugins in" << path;\n        QDirIterator dirIterator(path, QDir::Files);\n        while (dirIterator.hasNext()) {\n            try {\n                auto loader = make_unique<NativePluginLoader>(this, registry, dirIterator.next());\n                if (loader->metaData().frontend)\n                    frontend_plugins_.emplace_back(loader.get());\n                DEBG << "Found valid native plugin" << loader->path;\n                plugins_.push_back(::move(loader));\n            } catch (const runtime_error &e) {\n                DEBG << e.what() << dirIterator.filePath();\n            }\n        }\n    }\n\n    if (frontend_plugins_.empty())\n        qFatal("No frontends found.");\n}\n\nNativePluginProvider::~NativePluginProvider()\n{\n    for (auto &loader : plugins_)\n        if (loader->state() == PluginState::Loaded)\n            loader->unload();\n}\n\nvoid NativePluginProvider::loadFrontend()\n{\n    DEBG << "Loading frontend plugin\xe2\x80\xa6";\n\n    // Helper function loading frontend extensions\n    auto load_frontend = [](NativePluginLoader *loader) -> Frontend* {\n\n        if (loader->load(); loader->state() == PluginState::Loaded){\n            if (auto *f = dynamic_cast<Frontend*>(loader->instance()))\n                return f;\n            else{\n                DEBG << "Failed casting Plugin instance to Frontend*";\n                loader->unload();\n            }\n        } else\n            DEBG << loader->stateInfo();\n        return nullptr;  // Loading failed\n    };\n\n    // Try loading the configured frontend\n    auto cfg_frontend = QSettings(qApp->applicationName()).value(CFG_FRONTEND_ID, DEF_FRONTEND_ID).toString();\n    if (auto it = find_if(frontend_plugins_.begin(), frontend_plugins_.end(),\n                          [&](const NativePluginLoader *loader){ return cfg_frontend == loader->metaData().id; });\n            it == frontend_plugins_.end())\n        WARN << "Configured frontend does not exist: " << cfg_frontend;\n    else if (frontend_ = load_frontend(*it); frontend_)\n        return;\n    else\n        WARN << "Loading configured frontend failed. Try any other.";\n\n    for (auto &loader : frontend_plugins_)\n        if (frontend_ = load_frontend(loader); frontend_) {\n            WARN << QString("Using %1 instead.").arg(loader->metaData().id);\n            QSettings(qApp->applicationName()).setValue(CFG_FRONTEND_ID, loader->metaData().id);\n            return;\n        }\n    qFatal("Could not load any frontend.");\n}\n\nFrontend *NativePluginProvider::frontend() { return frontend_; }\n\nconst vector<NativePluginLoader*> &NativePluginProvider::frontendPlugins() { return frontend_plugins_; }\n\nvoid NativePluginProvider::setFrontend(uint index)\n{\n    auto id = frontend_plugins_[index]->metaData().id;\n    QSettings(qApp->applicationName()).setValue(CFG_FRONTEND_ID, id);\n    if (id != frontend_->id()){\n        QMessageBox msgBox(QMessageBox::Question, "Restart?",\n                           "Changing the frontend needs a restart. Do you want to restart Albert?",\n                           QMessageBox::Yes | QMessageBox::No);\n        if (msgBox.exec() == QMessageBox::Yes)\n            restart();\n    }\n}\n\n\n// Interfaces\n\nQString NativePluginProvider::id() const { return "pluginprovider"; }\n\nQString NativePluginProvider::name() const { return "Native plugin provider"; }\n\nQString NativePluginProvider::description() const { return "Loads native C++ albert plugins"; }\n\nvector<PluginLoader*> NativePluginProvider::plugins()\n{\n    vector<PluginLoader*> r;\n    for (const auto &loader : plugins_)\n        r.emplace_back(loader.get());\n    return r;\n}\n'