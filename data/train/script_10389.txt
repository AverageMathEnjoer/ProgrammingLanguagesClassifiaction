b'-- Implement ppong on the client side for WS\n-- TODO: upstream to https://github.com/jaspervdj/websockets/issues/159\nmodule Cachix.Deploy.WebsocketPong where\n\nimport Data.IORef (IORef)\nimport qualified Data.IORef as IORef\nimport Data.Time.Clock (UTCTime, diffUTCTime, getCurrentTime, nominalDiffTimeToSeconds)\nimport qualified Network.WebSockets as WS\nimport Protolude\n\ntype LastPongState = IORef UTCTime\n\ndata WebsocketPongTimeout\n  = WebsocketPongTimeout\n  deriving (Show)\n\ninstance Exception WebsocketPongTimeout\n\nnewState :: IO LastPongState\nnewState = do\n  now <- getCurrentTime\n  IORef.newIORef now\n\n-- everytime we send a ping we check if we also got a pong back\npingHandler :: LastPongState -> ThreadId -> Int -> IO ()\npingHandler pong threadID maxLastPing = do\n  last <- secondsSinceLastPong pong\n  when (last > maxLastPing) $\n    throwTo threadID WebsocketPongTimeout\n\nsecondsSinceLastPong :: LastPongState -> IO Int\nsecondsSinceLastPong pong = do\n  last <- IORef.readIORef pong\n  now <- getCurrentTime\n  return $ ceiling $ nominalDiffTimeToSeconds $ diffUTCTime now last\n\npongHandler :: LastPongState -> IO ()\npongHandler pong = do\n  now <- getCurrentTime\n  void $ IORef.atomicWriteIORef pong now\n\ninstallPongHandler :: LastPongState -> WS.ConnectionOptions -> WS.ConnectionOptions\ninstallPongHandler pong opts = opts {WS.connectionOnPong = pongHandler pong}\n'