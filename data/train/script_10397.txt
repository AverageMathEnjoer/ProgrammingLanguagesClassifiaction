b'{-# LANGUAGE GADTs #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n{-# LANGUAGE NoMonomorphismRestriction #-}\n\n-- | special actor for IO action\nmodule Control.Monad.Trans.Crtn.IOActor where\n\nimport Control.Monad.Reader (ReaderT (..))\nimport Control.Monad.Trans (MonadIO (liftIO))\nimport Control.Monad.Trans.Crtn (request)\nimport Control.Monad.Trans.Crtn.Object\n  ( Arg (..),\n    CObjT,\n    Res (Ign, Res),\n    SObjT,\n  )\n\n-- | first is\ndata IOOp e i o where\n  DoIOAction :: IOOp e ((e -> IO ()) -> IO ()) (Either String ())\n\ntype IOActor e m r = SObjT (IOOp e) m r\n\n-- |\ndoIOAction ::\n  (Monad m) =>\n  ((e -> IO ()) -> IO ()) ->\n  CObjT (IOOp e) m (Either String ())\ndoIOAction act = do\n  ans <- request (Arg DoIOAction act)\n  case ans of\n    Res DoIOAction r -> return r\n    Ign -> return (Left "error in doing doIOAction")\n\n-- |\nioactorgen :: (MonadIO m) => (e -> IO ()) -> SObjT (IOOp e) m ()\nioactorgen evhandler = ReaderT ioactorW\n  where\n    ioactorW (Arg DoIOAction act) = do\n      liftIO (act evhandler)\n      req <- request (Res DoIOAction (Right ()))\n      ioactorW req\n'