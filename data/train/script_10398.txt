b'\n{- | The benchmarking script:\n\nUSAGE:\n\n   ./run_benchmark [mode] [hsbencher options]\n\nWhere mode is \'desktop\', \'server\', or \'quick\'.\n\n-}\n\n{-# OPTIONS_GHC -fwarn-incomplete-patterns #-}\n\nmodule Main where\n\nimport qualified Data.Set as S\n\nimport GHC.Conc           (getNumProcessors)\nimport System.Environment (getEnvironment, getArgs, withArgs)\nimport System.IO.Unsafe   (unsafePerformIO)\nimport System.Console.GetOpt\n\nimport HSBencher.Types(BenchSpace(..), Benchmark(..), ParamSetting(..), DefaultParamMeaning(..),\n                       -- compileOptsOnly, enumerateBenchSpace, toCompileFlags,\n                       -- makeBuildID, BuildID,\n                       mkBenchmark\n                      )\nimport HSBencher.App (defaultMainWithBechmarks, all_cli_options)\n\n--------------------------------------------------------------------------------\n-- Main Script\n--------------------------------------------------------------------------------\n\ndata Mode = Server | Desktop | Quick      deriving (Show,Eq)\ndata Flag = SetMode Mode\n          | SetSched Sched\n          | Help\n          deriving (Show,Eq)\n                \noptions :: [OptDescr Flag]\noptions =\n     [ Option [] ["server"]  (NoArg (SetMode Server))  "server-sized benchmarks"\n     , Option [] ["desktop"] (NoArg (SetMode Desktop)) "desktop-sized benchmarks"\n     , Option [] ["quick"]   (NoArg (SetMode Quick))   "(default) quick testing"\n     , Option [\'h\'] ["help"] (NoArg Help)              "report this help message"\n\n     , Option [] ["sparks"]  (NoArg (SetSched Sparks)) "add this scheduler (default is all schedulers)"\n     , Option [] ["direct"]  (NoArg (SetSched Direct)) "add this scheduler "       \n     , Option [] ["trace"]   (NoArg (SetSched Trace))  "add this scheduler "\n     , Option [] ["trace-st"]   (NoArg (SetSched TraceST)) "scheduler with one transformer"\n       \n     , Option [] ["lvish"]   (NoArg (SetSched LVish))  "add this scheduler "\n     , Option [] ["lvish-state"] (NoArg (SetSched LVishState)) "scheduler with one transformer"\n     , Option [] ["lvish-rng"] (NoArg (SetSched LVishRNG)) "scheduler with one transformer"\n     , Option [] ["lvish-cancel"] (NoArg (SetSched LVishCancel)) "scheduler with one transformer"        \n     ]\n\nisSetSched (SetSched _) = True\nisSetSched _ = False\n\nmain :: IO ()\nmain = do\n  args <- getArgs\n  let (opts,nonopts,unrecog,errs) = getOpt\' Permute options args\n  -- The first arg is a kind of mode:\n\n  let help1 = usageInfo ("USAGE: run_benchmark [options]\\n"++\n                        "\\nFirst, specific options for this script are:\\n")\n                options\n      help2 = usageInfo (help1++"\\nAlso use the generic HSBencher options below:\\n")\n                        (concat $ map snd all_cli_options)\n\n      activeScheds0 = [ sched | SetSched sched <- opts ]\n      activeScheds = if null activeScheds0\n                     then defaultSchedSet\n                     else S.fromList activeScheds0\n  if Help `elem` opts || errs /= [] then\n    error help2\n   else do\n    let passthru = nonopts ++ unrecog\n        modes    = [ s | SetMode s <- opts ]\n    putStrLn$ "  [Bench script mode selection]: "++ show modes\n    putStrLn$ "  [Bench script Sched selection]: "++ show activeScheds\n    putStrLn$ "  [Note: passing through options to HSBencher]: "++unwords passthru\n    withArgs passthru $ \n     case modes of\n       [Desktop] -> defaultMainWithBechmarks (bls_desktop activeScheds)\n       [Server]  -> defaultMainWithBechmarks (bls_server activeScheds)\n       [Quick]   -> defaultMainWithBechmarks (bls_quick activeScheds)\n       []        -> defaultMainWithBechmarks (bls_quick activeScheds)\n       ls        -> error$ "Conflicting mode options: "++show ls\n    \n--------------------------------------------------------------------------------\n-- Here are the actual benchmarks:\n--------------------------------------------------------------------------------\n\nbls_quick :: S.Set Sched -> [Benchmark DefaultParamMeaning]\nbls_quick ss =\n ------------------------------------------------------------  \n -- Quick-test configuration:\n ------------------------------------------------------------    \n [ futbench "blackscholes" [] ss \n , ivbench  "nbody"        [] ss \n , futbench "mandel"       [] ss \n , futbench "coins"        [] ss \n\n   -- These don\'t match the naming convention at the moment:\n , futbench "matmult"      [] ss \n , futbench "sumeuler"     [] ss \n , futbench "sorting"      [] ss \n ]\n\nbls_desktop :: S.Set Sched -> [Benchmark DefaultParamMeaning]\nbls_desktop ss = \n ------------------------------------------------------------  \n -- Desktop configuration:\n ------------------------------------------------------------\n [ futbench "blackscholes" ["10000","15000000"] ss \n , ivbench  "nbody"        ["13000"] ss \n , futbench "mandel"       ["1024","1024","256"] ss \n , futbench "coins"        ["8", "1250"] ss \n\n   -- These don\'t match the naming convention at the moment:\n , futbench "matmult"      ["768", "0", "64"] ss \n , futbench "sumeuler"     ["38", "8000", "100"] ss \n , futbench "sorting"      ["cpu", "24", "8192"] ss \n ] ++ parfibRange ss\n\n-- | Parfib can vary wildly between schedulers. Thus we run it with a short timeout,\n-- and then we can simply look at what the maximum size each scheduler could handle\n-- under that threshold.\nparfibRange :: S.Set Sched -> [Benchmark DefaultParamMeaning]\nparfibRange ss =\n  [ (mkBenchmark ("src/parfib/generated.cabal") ["monad",arg] (futures ss)) \n      { progname= Just "microbench_parfib"\n      , benchTimeOut= Just 6.0 }\n  | arg <- map show [30,31,32,33,34,35,36,37,38,39,40]\n  ]\n\n-- # Version: server 1.6\n-- # I\'m attempting to keep track of changes to this config with the above number.\n-- # Note that changes to the benchmarks themselves also require changing\n-- # this version number.  However, ADDING new benchmarks does not require \n-- # a version bump.\n-- # \n-- # CHANGELOG:\n-- # \n-- # 1.2 - bringing up to date with benchlist.txt for paper.\n-- # 1.3 - changed mandel implementation\n-- # 1.4 - removed path prefixes for new cabal build system -ACF\n-- # 1.5 - prefixes back\n-- # 1.6 - up mergesort 24->25\nbls_server :: S.Set Sched -> [Benchmark DefaultParamMeaning]\nbls_server ss =\n [ futbench "blackscholes" ["10000","30000000"] ss \n , ivbench  "nbody"        ["25000"] ss \n , futbench "mandel"       (words "1024 1024 512") ss \n , futbench "coins"        ["8", "1600"] ss \n\n   -- These don\'t match the naming convention at the moment:\n , futbench "matmult"      (words "1024 0 64") ss \n , futbench "sumeuler"     (words "38 16000 100") ss \n , futbench "sorting"      ["cpu", "25", "8192"] ss \n ] ++ parfibRange ss\n\n-- Factor out boilerplate:\n\nfutbench :: String -> [String] -> S.Set Sched -> Benchmark DefaultParamMeaning\nfutbench dir args ss =\n   (mkBenchmark ("src/"++dir++"/generated.cabal")  args  (futures ss)) { progname=Just dir }   \n\nivbench :: String -> [String] -> S.Set Sched -> Benchmark DefaultParamMeaning\nivbench dir args ss =\n   (mkBenchmark ("src/"++dir++"/generated.cabal")  args  (ivars ss)) { progname=Just dir }   \n\n\n----------------------------------------\n-- Old, disabled benchmarks:\n----------------------------------------\n\n     -- binomial lattice?\n\n     -- ------------------------------------------------------------\n     -- TODO: Get distributed benchmarks integrated in here:\n     --       Although these should probably go in a separate file.\n     -- ------------------------------------------------------------\n     -- distributed/parfib_dist\n     -- distributed/mandel_dist dist pipes 1024a\n\n     -- ------------------------------------------------------------\n     -- Benchmarks that are have problems or have become neglected:\n     -- ------------------------------------------------------------\n\n     -- partree/partree futures 600 20\n\n     -- What should the arguments be here:\n     --  The compute times are highly unpredictable.... it\'s hard to find good inputs.\n     -- minimax/minimax futures nested ? ? \n     -- minimax/minimax futures monad  ? ? \n\n\n     -- We can measure parfib separately... it shouldn\'t be part of our\n     -- benchmark suite.\n     -- -----------------\n     -- Problems with this fib(38):\n     -- parfib_monad  futures monad  38\n     -- parfib_pseq   none           38\n     -- parfib_monad  futures nested 30\n\n\n     -- I don\'t think quicksort was every really fixed/tuned:\n     -- It looks like it is still generating random data as an AList and\n     -- getting stack overflows [2012.03.04]\n     -- -----------------\n     -- quicksort/parquicksort_monad futures 1500000\n     -- quicksort/parquicksort_pseq  none    1500000\n\n\n     -- We could include cholesky, but it is a bit annoying in that it\n     -- requires generated input files.  Also we\'d like to de-unsafePerformIO it:\n     -- -----------------\n     -- cholesky      default 1000 50 cholesky_matrix1000.dat\n\n\n     -- The whole asynchronous/streaming thing needs to be revisited at a later date.\n     -- -----------------\n     -- stream/disjoint_working_sets_pipeline Trace  monad  4 256 10 10000sx\n     -- stream/disjoint_working_sets_pipeline none   sparks 4 256 10 10000\n\n------------------------------------------------------------  \n-- Server configuration:\n------------------------------------------------------------    \n\n\n\ntest_metapar :: Bool\ntest_metapar = False\n\n--------------------------------------------------------------------------------\n-- Set up some common benchmark config spaces:\n--------------------------------------------------------------------------------\n\n-- | Benchmarks that only require futures, not ivars.\nfutures :: S.Set Sched -> BenchSpace DefaultParamMeaning\nfutures ss = defaultSettings$ varyThreads $\n          Or$ map dosched $ S.toList ss\n\n-- | Actually using ivars.  For now this just rules out the Sparks scheduler:\nivars :: S.Set Sched -> BenchSpace DefaultParamMeaning\nivars ss = defaultSettings$ varyThreads $\n          Or$ map dosched $ S.toList $\n          S.delete Sparks ss  -- This is the only one that can\'t support IVars.\n\ndefaultSettings :: BenchSpace DefaultParamMeaning -> BenchSpace DefaultParamMeaning\ndefaultSettings spc =\n  And [\n--        Set NoMeaning (CompileParam "--disable-documentation")\n--      , Set NoMeaning (CompileParam "--disable-library-profiling")\n--      , Set NoMeaning (CompileParam "--disable-executable-profiling")\n        Or [\n             -- 512K is the default:\n             Set NoMeaning (RuntimeParam "+RTS -s -qa -RTS") -- -A512K\n             -- Set NoMeaning (RuntimeParam "+RTS -s -qa -A20M -RTS")\n           ]\n      , spc]\n\n      -- rts = gc_stats_flag ++" "++\n      --       case numthreads of\n      --        0 -> unwords (pruneThreadedOpts (words ghc_RTS))\n      --        _ -> ghc_RTS  ++" -N"++show numthreads\n\n     --, ghc_RTS    =       get "GHC_RTS"   ("-qa " ++ gc_stats_flag) -- Default RTS flags.\n\n\n--------------------------------------------------------------------------------\n-- Supporting definitions:\n--------------------------------------------------------------------------------\n\n-- | Monad par schedulers:\ndata Sched \n   = Trace | TraceST \n   | Direct | Sparks   -- Basic monad-par\n   | SMP | NUMA                -- Meta-par\n   | LVish\n   | LVishRNG\n   | LVishState -- Add transformers...\n   | LVishCancel  \n   | None\n   -- | ContFree   -- Obsolete strawman.\n deriving (Eq, Show, Read, Ord, Enum, Bounded)\n\n-- | Realize a scheduler selection via a compile flag.\ndosched :: Sched -> BenchSpace DefaultParamMeaning\ndosched s = Set (Variant$ show s) $ CompileParam $ schedToCabalFlag s\n\n-- | By default, we usually don\'t test meta-par \ndefaultSchedSet :: S.Set Sched\ndefaultSchedSet = S.difference\n                  (S.fromList [minBound ..])\n                  (if test_metapar\n                   then S.fromList [None]\n                   else S.fromList [NUMA, SMP, None])\n\nschedToCabalFlag :: Sched -> String\nschedToCabalFlag s =\n  case s of\n    Trace  -> "-ftrace"\n    TraceST -> "-ftrace-st"\n    Direct -> "-fdirect"\n    Sparks -> "-fsparks"\n    SMP    -> "-fmeta-smp"\n    NUMA   -> "-fmeta-numa"\n    LVish  -> "-flvish"\n    LVishRNG   -> "-flvish-rng"\n    LVishCancel   -> "-flvish-cancel" \n    LVishState -> "-flvish-state"\n    None   -> ""\n\n-- TODO: make this an option:\nthreadSelection :: [Int]\nthreadSelection = unsafePerformIO $ do\n  env <- getEnvironment\n  p   <- getNumProcessors\n  case lookup "THREADS" env of\n    Just ls -> return$ map read $ words ls\n    -- Arbitrary default policy \n    Nothing\n      | p <= 16   -> return  [1 .. p]\n      | otherwise -> return$ 1 : [2,4 .. p]\n\n-- unsafeEnv = unsafePerformIO getEnvironment\n\n-- | Add variation from thread count.    \nvaryThreads :: BenchSpace DefaultParamMeaning -> BenchSpace DefaultParamMeaning\nvaryThreads conf = Or\n  [\n    -- Disabling unthreaded mode:\n    -- conf -- Unthreaded mode.\n    And [ Set NoMeaning (CompileParam "--ghc-options=\'-threaded\'")\n        , Or (map fn threadSelection)\n        , conf ]\n  ]\n where\n   fn n = Set (Threads n) $ RuntimeParam  ("+RTS -N"++ show n++" -RTS")\n\n'