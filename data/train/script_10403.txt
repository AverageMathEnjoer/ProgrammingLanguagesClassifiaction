b'#include <bits/stdc++.h>\nusing namespace std;\n#define gc getchar_unlocked\n#define fo(i,n) for(i=0;i<n;i++)\n#define Fo(i,k,n) for(i=k;k<n?i<n:i>n;k<n?i+=1:i-=1)\n#define ll long long\n#define si(x)\tscanf("%d",&x)\n#define sl(x)\tscanf("%lld",&x)\n#define ss(s)\tscanf("%s",s)\n#define pi(x)\tprintf("%d\\n",x)\n#define pl(x)\tprintf("%lld\\n",x)\n#define ps(s)\tprintf("%s\\n",s)\n#define pb push_back\n#define mp make_pair\n#define F first\n#define S second\n#define all(x) x.begin(), x.end()\n#define clr(x) memset(x, 0, sizeof(x))\n#define sortall(x) sort(all(x))\n#define tr(it, a) for(auto it = a.begin(); it != a.end(); it++)\n#define PI 3.1415926535897932384626\ntypedef pair<int, int>\tpii;\ntypedef pair<ll, ll>\tpll;\ntypedef vector<int>\t\tvi;\ntypedef vector<ll>\t\tvll;\ntypedef vector<pii>\t\tvpii;\ntypedef vector<pll>\t\tvpll;\ntypedef vector<vi>\t\tvvi;\ntypedef vector<vll>\t\tvvl;\nconst int mod = 1000000007;\nconst int N = 3e5+2;\nusing namespace std;\n int cnt[N];\ntypedef pair<int,int> pii;\n \nclass CompareByFirst\n{\npublic:\n\tbool operator()(const pii& p1, const pii& p2)const\n\t{\n\t\treturn p1.first < p2.first;\n\t}\n};\n \nclass CompareBySecond\n{\npublic:\n\tbool operator()(const pii& p1, const pii& p2)const\n\t{\n\t\treturn p1.second < p2.second;\n\t}\n};\n \nstruct QTNode\n{\t\n\tint left, right, bottom, top;\n\tint count;\n\tQTNode* child[2];\n\t\n\tvoid SplitData(vector<pii>& points, int first, int last, int level)\n\t{\n\t\tthis->count = last - first + 1;\t\n\t\t\n\t\tthis->left = points[first].first;\n\t\tthis->right = points[first].first;\n\t\tthis->bottom = points[first].second;\n\t\tthis->top = points[first].second;\t\t\n\t\t\n\t\tif(first == last)\n\t\t{\n\t\t\tthis->count = 1;\n\t\t\treturn;\n\t\t}\t\t\t\n\t\t\t\t\n\t\tfor(int i = first + 1; i <= last; i++)\n\t\t{\n\t\t\tthis->left = min(this->left, points[i].first);\n\t\t\tthis->top = max(this->top, points[i].second);\n\t\t\tthis->right = max(this->right, points[i].first);\n\t\t\tthis->bottom = min(this->bottom, points[i].second);\t\n\t\t}\t\t\n\t\t\t\t\t\t\t\t\n\t\tint mid = first + (last - first) / 2;\n\t\tif(level & 0x1)\n\t\t{\n\t\t\tnth_element(&points[first], &points[mid], &points[last + 1], CompareByFirst());\t\t\n\t\t}\n\t\telse\n\t\t{\t\n\t\t\tnth_element(&points[first], &points[mid], &points[last + 1], CompareBySecond());\t\t\n\t\t}\t\t\n\t\t\n\t\tchild[0] = new QTNode();\n\t\tchild[1] = new QTNode();\n\t\tchild[0]->SplitData(points, first, mid, level + 1);\n\t\tchild[1]->SplitData(points, mid + 1, last, level + 1);\t\t\t\t\t\t\n\t}\t\n\t\n\tint CountInRect(int _left, int _right, int _bottom, int _top)\n\t{\n\t\tif(\tthis->left >= _left and \n\t\t\tthis->right <= _right and \n\t\t\tthis->top <= _top and \n\t\t\tthis->bottom >= _bottom)\n\t\t{\n\t\t\treturn this->count;\n\t\t}\n\t\telse if(this->left <= _right and \n\t\t\t\tthis->right >= _left and\n\t\t\t\tthis->top >= _bottom and\n\t\t\t\tthis->bottom <= _top)\n\t\t{\n\t\t\treturn this->child[0]->CountInRect(_left, _right, _bottom, _top) + this->child[1]->CountInRect(_left, _right, _bottom, _top);\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn 0;\n\t\t}\n\t}\n\t\n\tvoid Traverse()\n\t{\n\t\tcout<<left<<","<<right<<"  "<<bottom<<","<<top<<" # "<<count<<endl;\n\t\tif(child[0])\n\t\t{\n\t\t\tchild[0]->Traverse();\n\t\t}\n\t\tif(child[1])\n\t\t{\n\t\t\tchild[1]->Traverse();\n\t\t}\n\t}\n};\n \nQTNode* buildQTree(vector<pair<int,int> >& points)\n{\n\tQTNode* root = new QTNode();\n\troot->SplitData(points,0,points.size() - 1, 0);\t\t\n\treturn root;\n}\n \ntemplate<typename T>\nvoid PrintSet(set<pii, T>& s)\n{\n\tfor(set<pii>::iterator i = s.begin(); i != s.end(); i++)\n\t{\n\t\tcout<<i->first<<":"<<i->second<<" ";\n\t}\n\tcout<<endl;\n}\nstruct node{\n\tpii u,v;\n\tint o;\n\tvoid read(){\n\t\tcin>>u.F>>u.S;\n\t\tcin>>v.F>>v.S;\n\t\tif(u > v) swap(u, v);\n\t\tfind();\n\t}\n\tvoid find(){\n\t\tif(u.F==v.F)o=1;\n\t\telse o=0;\n\t}\n}seg[N];\nmap<int,int> hai[2][N];\n void solve(){\n\n \tint i, n;\n \tcin>>n;\n\tll ans = 0;\n\tvpii interval[2][2];\n\tfo(i, n){\n\t\tseg[i].read();\n\t\tint x = seg[i].o;\n\t\tnode line = seg[i];\n        hai[x][line.u.F][line.u.S] = 1;\n        hai[x][line.v.F][line.v.S] = 1;\n\t\tif(x){\n\t\t\t// |\n\t\t\t// |   => x is constant\n\t\t\t// |\n\t\t\tinterval[x][0].pb({line.u.F, line.u.S});\n\t\t\tinterval[x][1].pb({line.v.F, line.v.S+1});\n\t\t\t\n            //cout<<x<<" "<<line.u.S<<" "<<line.v.S<<endl;\n\t\t}\t\n\t\telse{\n\t\t\tinterval[x][0].pb({line.u.F, line.u.S});\n\t\t\tinterval[x][1].pb({line.v.F+1, line.v.S});\n            // cout<<x<<" "<<line.u.F<<" "<<line.v.F<<endl;\n\t\t\t\n\t\t}\n\t}\n\tQTNode *qTree[2][2];\n\tqTree[0][0] = buildQTree(interval[0][0]);\n\tqTree[0][1] = buildQTree(interval[0][1]);\n\tqTree[1][0] = buildQTree(interval[1][0]);\n\tqTree[1][1] = buildQTree(interval[1][1]);\n\tfo(i, n){\n\t\tnode line = seg[i];\n\t\tint x = line.o;\n\t\tcnt[i] = qTree[1-x][0]->CountInRect(0, line.v.F, 0, line.v.S);\n\t\tcnt[i] -= qTree[1-x][1]->CountInRect(0, line.v.F, 0, line.v.S);\n       // cout<<1-x<<" ";\n\t\t//if(x){\n\t\t\tcnt[i] -= hai[1-x][line.u.F][line.u.S]+hai[1-x][line.v.F][line.v.S];\n           // cout<<line.u.S<<" "<<line.v.S<<endl;\n\t\t//}else{\n\t\t//\tcnt[i] -= hai[1][line.u.F]+hai[1][line.u.F];\n           // cout<<line.u.F<<" "<<line.v.F<<endl;\n\t\t//}\n\t\t\n\t\tans += cnt[i];\n\t}\n     cout<<endl;\n\tcout<<ans/2<<endl;\n\tfo(i, n) cout<<cnt[i]<<" ";\n \t\n }\nint main()\n{\n\tsolve();\n}\n \n \n'