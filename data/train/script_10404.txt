b'using System;\nusing System.Diagnostics;\nusing System.Text;\n\nusing i64 = System.Int64;\nusing u8 = System.Byte;\n\nnamespace CS_SQLite3\n{\n  public partial class CSSQLite\n  {\n    /*\n    ** 2003 April 6\n    **\n    ** The author disclaims copyright to this source code.  In place of\n    ** a legal notice, here is a blessing:\n    **\n    **    May you do good and not evil.\n    **    May you find forgiveness for yourself and forgive others.\n    **    May you share freely, never taking more than you give.\n    **\n    *************************************************************************\n    ** This file contains code used to implement the PRAGMA command.\n    **\n    ** $Id: pragma.c,v 1.214 2009/07/02 07:47:33 danielk1977 Exp $\n    **\n    *************************************************************************\n    **  Included in SQLite3 port to C#-SQLite;  2008 Noah B Hart\n    **  C#-SQLite is an independent reimplementation of the SQLite software library\n    **\n    **  $Header$\n    *************************************************************************\n    */\n    //#include "sqliteInt.h"\n\n    /* Ignore this whole file if pragmas are disabled\n    */\n#if !SQLITE_OMIT_PRAGMA\n\n    /*\n** Interpret the given string as a safety level.  Return 0 for OFF,\n** 1 for ON or NORMAL and 2 for FULL.  Return 1 for an empty or\n** unrecognized string argument.\n**\n** Note that the values returned are one less that the values that\n** should be passed into sqlite3BtreeSetSafetyLevel().  The is done\n** to support legacy SQL code.  The safety level used to be boolean\n** and older scripts may have used numbers 0 for OFF and 1 for ON.\n*/\n    static u8 getSafetyLevel( string z )\n    {\n      //                             /* 123456789 123456789 */\n      string zText = "onoffalseyestruefull";\n      int[] iOffset = new int[] { 0, 1, 2, 4, 9, 12, 16 };\n      int[] iLength = new int[] { 2, 2, 3, 5, 3, 4, 4 };\n      u8[] iValue = new u8[] { 1, 0, 0, 0, 1, 1, 2 };\n      int i, n;\n      if ( sqlite3Isdigit( z[0] ) )\n      {\n        return (u8)atoi( z );\n      }\n      n = sqlite3Strlen30( z );\n      for ( i = 0 ; i < ArraySize( iLength ) ; i++ )\n      {\n        if ( iLength[i] == n && sqlite3StrNICmp( zText.Substring( iOffset[i] ), z, n ) == 0 )\n        {\n          return iValue[i];\n        }\n      }\n      return 1;\n    }\n\n    /*\n    ** Interpret the given string as a boolean value.\n    */\n    static u8 getBoolean( string z )\n    {\n      return (u8)( getSafetyLevel( z ) & 1 );\n    }\n\n    /*\n    ** Interpret the given string as a locking mode value.\n    */\n    static int getLockingMode( string z )\n    {\n      if ( z != null )\n      {\n        if ( 0 == sqlite3StrICmp( z, "exclusive" ) ) return PAGER_LOCKINGMODE_EXCLUSIVE;\n        if ( 0 == sqlite3StrICmp( z, "normal" ) ) return PAGER_LOCKINGMODE_NORMAL;\n      }\n      return PAGER_LOCKINGMODE_QUERY;\n    }\n\n#if !SQLITE_OMIT_AUTOVACUUM\n    /*\n** Interpret the given string as an auto-vacuum mode value.\n**\n** The following strings, "none", "full" and "incremental" are\n** acceptable, as are their numeric equivalents: 0, 1 and 2 respectively.\n*/\n    static u8 getAutoVacuum( string z )\n    {\n      int i;\n      if ( 0 == sqlite3StrICmp( z, "none" ) ) return BTREE_AUTOVACUUM_NONE;\n      if ( 0 == sqlite3StrICmp( z, "full" ) ) return BTREE_AUTOVACUUM_FULL;\n      if ( 0 == sqlite3StrICmp( z, "incremental" ) ) return BTREE_AUTOVACUUM_INCR;\n      i = atoi( z );\n      return (u8)( ( i >= 0 && i <= 2 ) ? i : 0 );\n    }\n#endif // * if !SQLITE_OMIT_AUTOVACUUM */\n\n#if !SQLITE_OMIT_PAGER_PRAGMAS\n    /*\n** Interpret the given string as a temp db location. Return 1 for file\n** backed temporary databases, 2 for the Red-Black tree in memory database\n** and 0 to use the compile-time default.\n*/\n    static int getTempStore( string z )\n    {\n      if ( z[0] >= \'0\' && z[0] <= \'2\' )\n      {\n        return z[0] - \'0\';\n      }\n      else if ( sqlite3StrICmp( z, "file" ) == 0 )\n      {\n        return 1;\n      }\n      else if ( sqlite3StrICmp( z, "memory" ) == 0 )\n      {\n        return 2;\n      }\n      else\n      {\n        return 0;\n      }\n    }\n#endif // * SQLITE_PAGER_PRAGMAS */\n\n#if !SQLITE_OMIT_PAGER_PRAGMAS\n    /*\n** Invalidate temp storage, either when the temp storage is changed\n** from default, or when \'file\' and the temp_store_directory has changed\n*/\n    static int invalidateTempStorage( Parse pParse )\n    {\n      sqlite3 db = pParse.db;\n      if ( db.aDb[1].pBt != null )\n      {\n        if ( 0 == db.autoCommit || sqlite3BtreeIsInReadTrans( db.aDb[1].pBt ) )\n        {\n          sqlite3ErrorMsg( pParse, "temporary storage cannot be changed " +\n          "from within a transaction" );\n          return SQLITE_ERROR;\n        }\n        sqlite3BtreeClose( ref db.aDb[1].pBt );\n        db.aDb[1].pBt = null;\n        sqlite3ResetInternalSchema( db, 0 );\n      }\n      return SQLITE_OK;\n    }\n#endif // * SQLITE_PAGER_PRAGMAS */\n\n#if !SQLITE_OMIT_PAGER_PRAGMAS\n    /*\n** If the TEMP database is open, close it and mark the database schema\n** as needing reloading.  This must be done when using the SQLITE_TEMP_STORE\n** or DEFAULT_TEMP_STORE pragmas.\n*/\n    static int changeTempStorage( Parse pParse, string zStorageType )\n    {\n      int ts = getTempStore( zStorageType );\n      sqlite3 db = pParse.db;\n      if ( db.temp_store == ts ) return SQLITE_OK;\n      if ( invalidateTempStorage( pParse ) != SQLITE_OK )\n      {\n        return SQLITE_ERROR;\n      }\n      db.temp_store = (u8)ts;\n      return SQLITE_OK;\n    }\n#endif // * SQLITE_PAGER_PRAGMAS */\n\n    /*\n** Generate code to return a single integer value.\n*/\n    static void returnSingleInt( Parse pParse, string zLabel, i64 value )\n    {\n      Vdbe v = sqlite3GetVdbe( pParse );\n      int mem = ++pParse.nMem;\n      //i64* pI64 = sqlite3DbMallocRaw( pParse->db, sizeof( value ) );\n      //if ( pI64 )\n      //{\n      //  memcpy( pI64, &value, sizeof( value ) );\n      //}\n      //sqlite3VdbeAddOp4( v, OP_Int64, 0, mem, 0, (char*)pI64, P4_INT64 );\n      sqlite3VdbeAddOp4( v, OP_Int64, 0, mem, 0, value, P4_INT64 );\n      sqlite3VdbeSetNumCols( v, 1 );\n      sqlite3VdbeSetColName( v, 0, COLNAME_NAME, zLabel, SQLITE_STATIC );\n      sqlite3VdbeAddOp2( v, OP_ResultRow, mem, 1 );\n    }\n\n#if !SQLITE_OMIT_FLAG_PRAGMAS\n    /*\n** Check to see if zRight and zLeft refer to a pragma that queries\n** or changes one of the flags in db.flags.  Return 1 if so and 0 if not.\n** Also, implement the pragma.\n*/\n    struct sPragmaType\n    {\n      public string zName;  /* Name of the pragma */\n      public int mask;           /* Mask for the db.flags value */\n      public sPragmaType( string zName, int mask )\n      {\n        this.zName = zName;\n        this.mask = mask;\n      }\n    }\n    static int flagPragma( Parse pParse, string zLeft, string zRight )\n    {\n      sPragmaType[] aPragma = new sPragmaType[]{\nnew sPragmaType( "full_column_names",        SQLITE_FullColNames  ),\nnew sPragmaType( "short_column_names",       SQLITE_ShortColNames ),\nnew sPragmaType( "count_changes",            SQLITE_CountRows     ),\nnew sPragmaType( "empty_result_callbacks",   SQLITE_NullCallback  ),\nnew sPragmaType( "legacy_file_format",       SQLITE_LegacyFileFmt ),\nnew sPragmaType( "fullfsync",                SQLITE_FullFSync     ),\nnew sPragmaType(  "reverse_unordered_selects", SQLITE_ReverseOrder  ),\n#if SQLITE_DEBUG\nnew sPragmaType( "sql_trace",                SQLITE_SqlTrace      ),\nnew sPragmaType( "vdbe_listing",             SQLITE_VdbeListing   ),\nnew sPragmaType( "vdbe_trace",               SQLITE_VdbeTrace     ),\n#endif\n#if !SQLITE_OMIT_CHECK\nnew sPragmaType( "ignore_check_constraints", SQLITE_IgnoreChecks  ),\n#endif\n/* The following is VERY experimental */\nnew sPragmaType( "writable_schema",          SQLITE_WriteSchema|SQLITE_RecoveryMode ),\nnew sPragmaType( "omit_readlock",            SQLITE_NoReadlock    ),\n\n/* TODO: Maybe it shouldn\'t be possible to change the ReadUncommitted\n** flag if there are any active statements. */\nnew sPragmaType( "read_uncommitted",         SQLITE_ReadUncommitted ),\n};\n      int i;\n      sPragmaType p;\n      for ( i = 0 ; i < ArraySize( aPragma ) ; i++ )//, p++)\n      {\n        p = aPragma[i];\n        if ( sqlite3StrICmp( zLeft, p.zName ) == 0 )\n        {\n          sqlite3 db = pParse.db;\n          Vdbe v;\n          v = sqlite3GetVdbe( pParse );\n          Debug.Assert( v != null );  /* Already allocated by sqlite3Pragma() */\n          if ( ALWAYS( v ) )\n          {\n            if ( null == zRight )\n            {\n              returnSingleInt( pParse, p.zName, ( ( db.flags & p.mask ) != 0 ) ? 1 : 0 );\n            }\n            else\n            {\n              if ( getBoolean( zRight ) != 0 )\n              {\n                db.flags |= p.mask;\n              }\n              else\n              {\n                db.flags &= ~p.mask;\n              }\n\n              /* Many of the flag-pragmas modify the code generated by the SQL\n              ** compiler (eg. count_changes). So add an opcode to expire all\n              ** compiled SQL statements after modifying a pragma value.\n              */\n              sqlite3VdbeAddOp2( v, OP_Expire, 0, 0 );\n            }\n          }\n\n          return 1;\n        }\n      }\n      return 0;\n    }\n#endif // * SQLITE_OMIT_FLAG_PRAGMAS */\n\n    /*\n** Return a human-readable name for a constraint resolution action.\n*/\n    static string actionName( int action )\n    {\n      string zName;\n      switch ( action )\n      {\n        case OE_SetNull: zName = "SET NULL"; break;\n        case OE_SetDflt: zName = "SET DEFAULT"; break;\n        case OE_Cascade: zName = "CASCADE"; break;\n        default: zName = "RESTRICT";\n          Debug.Assert( action == OE_Restrict ); break;\n      }\n      return zName;\n    }\n\n    /*\n    ** Process a pragma statement.\n    **\n    ** Pragmas are of this form:\n    **\n    **      PRAGMA [database.]id [= value]\n    **\n    ** The identifier might also be a string.  The value is a string, and\n    ** identifier, or a number.  If minusFlag is true, then the value is\n    ** a number that was preceded by a minus sign.\n    **\n    ** If the left side is "database.id" then pId1 is the database name\n    ** and pId2 is the id.  If the left side is just "id" then pId1 is the\n    ** id and pId2 is any empty string.\n    */\n    class EncName\n    {\n      public string zName;\n      public u8 enc;\n\n      public EncName( string zName, u8 enc )\n      {\n        this.zName = zName;\n        this.enc = enc;\n      }\n    };\n\n    // OVERLOADS, so I don\'t need to rewrite parse.c\n    static void sqlite3Pragma( Parse pParse, Token pId1, Token pId2, int null_4, int minusFlag )\n    { sqlite3Pragma( pParse, pId1, pId2, null, minusFlag ); }\n    static void sqlite3Pragma(\n    Parse pParse,\n    Token pId1,        /* First part of [database.]id field */\n    Token pId2,        /* Second part of [database.]id field, or NULL */\n    Token pValue,      /* Token for <value>, or NULL */\n    int minusFlag     /* True if a \'-\' sign preceded <value> */\n    )\n    {\n      string zLeft = null;    /* Nul-terminated UTF-8 string <id> */\n      string zRight = null;   /* Nul-terminated UTF-8 string <value>, or NULL */\n      string zDb = null;      /* The database name */\n      Token pId = new Token();/* Pointer to <id> token */\n      int iDb;                /* Database index for <database> */\n      sqlite3 db = pParse.db;\n      Db pDb;\n      Vdbe v = pParse.pVdbe = sqlite3VdbeCreate( db );\n      if ( v == null ) return;\n      pParse.nMem = 2;\n\n      /* Interpret the [database.] part of the pragma statement. iDb is the\n      ** index of the database this pragma is being applied to in db.aDb[]. */\n      iDb = sqlite3TwoPartName( pParse, pId1, pId2, ref pId );\n      if ( iDb < 0 ) return;\n      pDb = db.aDb[iDb];\n\n      /* If the temp database has been explicitly named as part of the\n      ** pragma, make sure it is open.\n      */\n      if ( iDb == 1 && sqlite3OpenTempDatabase( pParse ) != 0 )\n      {\n        return;\n      }\n\n      zLeft = sqlite3NameFromToken( db, pId );\n      if ( zLeft == "" ) return;\n      if ( minusFlag != 0 )\n      {\n        zRight = ( pValue == null ) ? "" : sqlite3MPrintf( db, "-%T", pValue );\n      }\n      else\n      {\n        zRight = sqlite3NameFromToken( db, pValue );\n      }\n\n      Debug.Assert( pId2 != null );\n      zDb = pId2.n > 0 ? pDb.zName : null;\n#if !SQLITE_OMIT_AUTHORIZATION\nif ( sqlite3AuthCheck( pParse, SQLITE_PRAGMA, zLeft, zRight, zDb ) )\n{\ngoto pragma_out;\n}\n#endif\n#if !SQLITE_OMIT_PAGER_PRAGMAS\n      /*\n**  PRAGMA [database.]default_cache_size\n**  PRAGMA [database.]default_cache_size=N\n**\n** The first form reports the current persistent setting for the\n** page cache size.  The value returned is the maximum number of\n** pages in the page cache.  The second form sets both the current\n** page cache size value and the persistent page cache size value\n** stored in the database file.\n**\n** The default cache size is stored in meta-value 2 of page 1 of the\n** database file.  The cache size is actually the absolute value of\n** this memory location.  The sign of meta-value 2 determines the\n** synchronous setting.  A negative value means synchronous is off\n** and a positive value means synchronous is on.\n*/\n      if ( sqlite3StrICmp( zLeft, "default_cache_size" ) == 0 )\n      {\n        VdbeOpList[] getCacheSize = new VdbeOpList[]{\nnew VdbeOpList( OP_Transaction, 0, 0,        0),                         /* 0 */\nnew VdbeOpList( OP_ReadCookie,  0, 1,        BTREE_DEFAULT_CACHE_SIZE),  /* 1 */\nnew VdbeOpList( OP_IfPos,       1, 7,        0),\nnew VdbeOpList( OP_Integer,     0, 2,        0),\nnew VdbeOpList( OP_Subtract,    1, 2,        1),\nnew VdbeOpList( OP_IfPos,       1, 7,        0),\nnew VdbeOpList( OP_Integer,     0, 1,        0),  /* 6 */\nnew VdbeOpList( OP_ResultRow,   1, 1,        0),\n};\n        int addr;\n        if ( sqlite3ReadSchema( pParse ) != 0 ) goto pragma_out;\n        sqlite3VdbeUsesBtree( v, iDb );\n        if ( null == zRight )\n        {\n          sqlite3VdbeSetNumCols( v, 1 );\n          sqlite3VdbeSetColName( v, 0, COLNAME_NAME, "cache_size", SQLITE_STATIC );\n          pParse.nMem += 2;\n          addr = sqlite3VdbeAddOpList( v, getCacheSize.Length, getCacheSize );\n          sqlite3VdbeChangeP1( v, addr, iDb );\n          sqlite3VdbeChangeP1( v, addr + 1, iDb );\n          sqlite3VdbeChangeP1( v, addr + 6, SQLITE_DEFAULT_CACHE_SIZE );\n        }\n        else\n        {\n          int size = atoi( zRight );\n          if ( size < 0 ) size = -size;\n          sqlite3BeginWriteOperation( pParse, 0, iDb );\n          sqlite3VdbeAddOp2( v, OP_Integer, size, 1 );\n          sqlite3VdbeAddOp3( v, OP_ReadCookie, iDb, 2, BTREE_DEFAULT_CACHE_SIZE );\n          addr = sqlite3VdbeAddOp2( v, OP_IfPos, 2, 0 );\n          sqlite3VdbeAddOp2( v, OP_Integer, -size, 1 );\n          sqlite3VdbeJumpHere( v, addr );\n          sqlite3VdbeAddOp3( v, OP_SetCookie, iDb, BTREE_DEFAULT_CACHE_SIZE, 1 );\n          pDb.pSchema.cache_size = size;\n          sqlite3BtreeSetCacheSize( pDb.pBt, pDb.pSchema.cache_size );\n        }\n      }\n      else\n\n        /*\n        **  PRAGMA [database.]page_size\n        **  PRAGMA [database.]page_size=N\n        **\n        ** The first form reports the current setting for the\n        ** database page size in bytes.  The second form sets the\n        ** database page size value.  The value can only be set if\n        ** the database has not yet been created.\n        */\n        if ( sqlite3StrICmp( zLeft, "page_size" ) == 0 )\n        {\n          Btree pBt = pDb.pBt;\n          Debug.Assert( pBt != null );\n          if ( null == zRight )\n          {\n            int size = ALWAYS( pBt ) ? sqlite3BtreeGetPageSize( pBt ) : 0;\n            returnSingleInt( pParse, "page_size", size );\n          }\n          else\n          {\n            /* Malloc may fail when setting the page-size, as there is an internal\n            ** buffer that the pager module resizes using sqlite3_realloc().\n            */\n            db.nextPagesize = atoi( zRight );\n            if ( SQLITE_NOMEM == sqlite3BtreeSetPageSize( pBt, db.nextPagesize, -1, 0 ) )\n            {\n      ////        db.mallocFailed = 1;\n            }\n          }\n        }\n        else\n\n          /*\n          **  PRAGMA [database.]max_page_count\n          **  PRAGMA [database.]max_page_count=N\n          **\n          ** The first form reports the current setting for the\n          ** maximum number of pages in the database file.  The\n          ** second form attempts to change this setting.  Both\n          ** forms return the current setting.\n          */\n          if ( sqlite3StrICmp( zLeft, "max_page_count" ) == 0 )\n          {\n            Btree pBt = pDb.pBt;\n            int newMax = 0;\n            Debug.Assert( pBt != null );\n            if ( zRight != null )\n            {\n              newMax = atoi( zRight );\n            }\n            if ( ALWAYS( pBt ) )\n            {\n              newMax = (int)sqlite3BtreeMaxPageCount( pBt, newMax );\n            }\n            returnSingleInt( pParse, "max_page_count", newMax );\n          }\n          else\n\n            /*\n            **  PRAGMA [database.]page_count\n            **\n            ** Return the number of pages in the specified database.\n            */\n            if ( sqlite3StrICmp( zLeft, "page_count" ) == 0 )\n            {\n              int iReg;\n              if ( sqlite3ReadSchema( pParse ) != 0 ) goto pragma_out;\n              sqlite3CodeVerifySchema( pParse, iDb );\n              iReg = ++pParse.nMem;\n              sqlite3VdbeAddOp2( v, OP_Pagecount, iDb, iReg );\n              sqlite3VdbeAddOp2( v, OP_ResultRow, iReg, 1 );\n              sqlite3VdbeSetNumCols( v, 1 );\n              sqlite3VdbeSetColName( v, 0, COLNAME_NAME, "page_count", SQLITE_STATIC );\n            }\n            else\n\n              /*\n              **  PRAGMA [database.]page_count\n              **\n              ** Return the number of pages in the specified database.\n              */\n              if ( zLeft == "page_count" )\n              {\n                Vdbe _v;\n                int iReg;\n                _v = sqlite3GetVdbe( pParse );\n                if ( _v == null || sqlite3ReadSchema( pParse ) != 0 ) goto pragma_out;\n                sqlite3CodeVerifySchema( pParse, iDb );\n                iReg = ++pParse.nMem;\n                sqlite3VdbeAddOp2( _v, OP_Pagecount, iDb, iReg );\n                sqlite3VdbeAddOp2( _v, OP_ResultRow, iReg, 1 );\n                sqlite3VdbeSetNumCols( _v, 1 );\n                sqlite3VdbeSetColName( _v, 0, COLNAME_NAME, "page_count", SQLITE_STATIC );\n              }\n              else\n\n                /*\n                **  PRAGMA [database.]locking_mode\n                **  PRAGMA [database.]locking_mode = (normal|exclusive)\n                */\n                if ( sqlite3StrICmp( zLeft, "locking_mode" ) == 0 )\n                {\n                  string zRet = "normal";\n                  int eMode = getLockingMode( zRight );\n\n                  if ( pId2.n == 0 && eMode == PAGER_LOCKINGMODE_QUERY )\n                  {\n                    /* Simple "PRAGMA locking_mode;" statement. This is a query for\n                    ** the current default locking mode (which may be different to\n                    ** the locking-mode of the main database).\n                    */\n                    eMode = db.dfltLockMode;\n                  }\n                  else\n                  {\n                    Pager pPager;\n                    if ( pId2.n == 0 )\n                    {\n                      /* This indicates that no database name was specified as part\n                      ** of the PRAGMA command. In this case the locking-mode must be\n                      ** set on all attached databases, as well as the main db file.\n                      **\n                      ** Also, the sqlite3.dfltLockMode variable is set so that\n                      ** any subsequently attached databases also use the specified\n                      ** locking mode.\n                      */\n                      int ii;\n                      Debug.Assert( pDb == db.aDb[0] );\n                      for ( ii = 2 ; ii < db.nDb ; ii++ )\n                      {\n                        pPager = sqlite3BtreePager( db.aDb[ii].pBt );\n                        sqlite3PagerLockingMode( pPager, eMode );\n                      }\n                      db.dfltLockMode = (u8)eMode;\n                    }\n                    pPager = sqlite3BtreePager( pDb.pBt );\n                    eMode = sqlite3PagerLockingMode( pPager, eMode ) ? 1 : 0;\n                  }\n\n                  Debug.Assert( eMode == PAGER_LOCKINGMODE_NORMAL || eMode == PAGER_LOCKINGMODE_EXCLUSIVE );\n                  if ( eMode == PAGER_LOCKINGMODE_EXCLUSIVE )\n                  {\n                    zRet = "exclusive";\n                  }\n                  sqlite3VdbeSetNumCols( v, 1 );\n                  sqlite3VdbeSetColName( v, 0, COLNAME_NAME, "locking_mode", SQLITE_STATIC );\n                  sqlite3VdbeAddOp4( v, OP_String8, 0, 1, 0, zRet, 0 );\n                  sqlite3VdbeAddOp2( v, OP_ResultRow, 1, 1 );\n                }\n                else\n                  /*\n                  **  PRAGMA [database.]journal_mode\n                  **  PRAGMA [database.]journal_mode = (delete|persist|off|truncate|memory)\n                  */\n                  if ( zLeft == "journal_mode" )\n                  {\n                    int eMode;\n                    string[] azModeName = new string[] {\n"delete", "persist", "off", "truncate", "memory"\n};\n\n                    if ( null == zRight )\n                    {\n                      eMode = PAGER_JOURNALMODE_QUERY;\n                    }\n                    else\n                    {\n                      int n = sqlite3Strlen30( zRight );\n                      eMode = azModeName.Length - 1;//sizeof(azModeName)/sizeof(azModeName[0]) - 1;\n                      while ( eMode >= 0 && String.Compare( zRight, azModeName[eMode], true ) != 0 )\n                      {\n                        eMode--;\n                      }\n                    }\n                    if ( pId2.n == 0 && eMode == PAGER_JOURNALMODE_QUERY )\n                    {\n                      /* Simple "PRAGMA journal_mode;" statement. This is a query for\n                      ** the current default journal mode (which may be different to\n                      ** the journal-mode of the main database).\n                      */\n                      eMode = db.dfltJournalMode;\n                    }\n                    else\n                    {\n                      Pager pPager;\n                      if ( pId2.n == 0 )\n                      {\n                        /* This indicates that no database name was specified as part\n                        ** of the PRAGMA command. In this case the journal-mode must be\n                        ** set on all attached databases, as well as the main db file.\n                        **\n                        ** Also, the sqlite3.dfltJournalMode variable is set so that\n                        ** any subsequently attached databases also use the specified\n                        ** journal mode.\n                        */\n                        int ii;\n                        Debug.Assert( pDb == db.aDb[0] );\n                        for ( ii = 1 ; ii < db.nDb ; ii++ )\n                        {\n                          if ( db.aDb[ii].pBt != null )\n                          {\n                            pPager = sqlite3BtreePager( db.aDb[ii].pBt );\n                            sqlite3PagerJournalMode( pPager, eMode );\n                          }\n                        }\n                        db.dfltJournalMode = (u8)eMode;\n                      }\n                      pPager = sqlite3BtreePager( pDb.pBt );\n                      eMode = sqlite3PagerJournalMode( pPager, eMode );\n                    }\n                    Debug.Assert( eMode == PAGER_JOURNALMODE_DELETE\n                    || eMode == PAGER_JOURNALMODE_TRUNCATE\n                    || eMode == PAGER_JOURNALMODE_PERSIST\n                    || eMode == PAGER_JOURNALMODE_OFF\n                    || eMode == PAGER_JOURNALMODE_MEMORY );\n                    sqlite3VdbeSetNumCols( v, 1 );\n                    sqlite3VdbeSetColName( v, 0, COLNAME_NAME, "journal_mode", SQLITE_STATIC );\n                    sqlite3VdbeAddOp4( v, OP_String8, 0, 1, 0,\n                    azModeName[eMode], P4_STATIC );\n                    sqlite3VdbeAddOp2( v, OP_ResultRow, 1, 1 );\n                  }\n                  else\n\n                    /*\n                    **  PRAGMA [database.]journal_size_limit\n                    **  PRAGMA [database.]journal_size_limit=N\n                    **\n                    ** Get or set the size limit on rollback journal files.\n                    */\n                    if ( sqlite3StrICmp( zLeft, "journal_size_limit" ) == 0 )\n                    {\n                      Pager pPager = sqlite3BtreePager( pDb.pBt );\n                      i64 iLimit = -2;\n                      if ( !String.IsNullOrEmpty( zRight ) )\n                      {\n                        sqlite3Atoi64( zRight, ref iLimit );\n                        if ( iLimit < -1 ) iLimit = -1;\n                      }\n                      iLimit = sqlite3PagerJournalSizeLimit( pPager, iLimit );\n                      returnSingleInt( pParse, "journal_size_limit", iLimit );\n                    }\n                    else\n\n#endif // * SQLITE_OMIT_PAGER_PRAGMAS */\n\n                      /*\n**  PRAGMA [database.]auto_vacuum\n**  PRAGMA [database.]auto_vacuum=N\n**\n** Get or set the value of the database \'auto-vacuum\' parameter.\n** The value is one of:  0 NONE 1 FULL 2 INCREMENTAL\n*/\n#if !SQLITE_OMIT_AUTOVACUUM\n                      if ( sqlite3StrICmp( zLeft, "auto_vacuum" ) == 0 )\n                      {\n                        Btree pBt = pDb.pBt;\n                        Debug.Assert( pBt != null );\n                        if ( sqlite3ReadSchema( pParse ) != 0 )\n                        {\n                          goto pragma_out;\n                        }\n                        if ( null == zRight )\n                        {\n                          int auto_vacuum;\n                          if ( ALWAYS( pBt ) )\n                          {\n                            auto_vacuum = sqlite3BtreeGetAutoVacuum( pBt );\n                          }\n                          else\n                          {\n                            auto_vacuum = SQLITE_DEFAULT_AUTOVACUUM;\n                          }\n                          returnSingleInt( pParse, "auto_vacuum", auto_vacuum );\n                        }\n                        else\n                        {\n                          int eAuto = getAutoVacuum( zRight );\n                          Debug.Assert( eAuto >= 0 && eAuto <= 2 );\n                          db.nextAutovac = (u8)eAuto;\n                          if ( ALWAYS( eAuto >= 0 ) )\n                          {\n                            /* Call SetAutoVacuum() to set initialize the internal auto and\n                            ** incr-vacuum flags. This is required in case this connection\n                            ** creates the database file. It is important that it is created\n                            ** as an auto-vacuum capable db.\n                            */\n                            int rc = sqlite3BtreeSetAutoVacuum( pBt, eAuto );\n                            if ( rc == SQLITE_OK && ( eAuto == 1 || eAuto == 2 ) )\n                            {\n                              /* When setting the auto_vacuum mode to either "full" or\n                              ** "incremental", write the value of meta[6] in the database\n                              ** file. Before writing to meta[6], check that meta[3] indicates\n                              ** that this really is an auto-vacuum capable database.\n                              */\n                              VdbeOpList[] setMeta6 = new VdbeOpList[] {\nnew VdbeOpList( OP_Transaction,    0,               1,        0),    /* 0 */\nnew VdbeOpList( OP_ReadCookie,     0,               1,        BTREE_LARGEST_ROOT_PAGE),    /* 1 */\nnew VdbeOpList( OP_If,             1,               0,        0),    /* 2 */\nnew VdbeOpList( OP_Halt,           SQLITE_OK,       OE_Abort, 0),    /* 3 */\nnew VdbeOpList( OP_Integer,        0,               1,        0),    /* 4 */\nnew VdbeOpList( OP_SetCookie,      0,               BTREE_INCR_VACUUM, 1),    /* 5 */\n};\n                              int iAddr;\n                              iAddr = sqlite3VdbeAddOpList( v, ArraySize( setMeta6 ), setMeta6 );\n                              sqlite3VdbeChangeP1( v, iAddr, iDb );\n                              sqlite3VdbeChangeP1( v, iAddr + 1, iDb );\n                              sqlite3VdbeChangeP2( v, iAddr + 2, iAddr + 4 );\n                              sqlite3VdbeChangeP1( v, iAddr + 4, eAuto - 1 );\n                              sqlite3VdbeChangeP1( v, iAddr + 5, iDb );\n                              sqlite3VdbeUsesBtree( v, iDb );\n                            }\n                          }\n                        }\n                      }\n                      else\n#endif\n\n                        /*\n**  PRAGMA [database.]incremental_vacuum(N)\n**\n** Do N steps of incremental vacuuming on a database.\n*/\n#if !SQLITE_OMIT_AUTOVACUUM\n                        if ( sqlite3StrICmp( zLeft, "incremental_vacuum" ) == 0 )\n                        {\n                          int iLimit = 0, addr;\n                          if ( sqlite3ReadSchema( pParse ) != 0 )\n                          {\n                            goto pragma_out;\n                          }\n                          if ( zRight == null || !sqlite3GetInt32( zRight, ref iLimit ) || iLimit <= 0 )\n                          {\n                            iLimit = 0x7fffffff;\n                          }\n                          sqlite3BeginWriteOperation( pParse, 0, iDb );\n                          sqlite3VdbeAddOp2( v, OP_Integer, iLimit, 1 );\n                          addr = sqlite3VdbeAddOp1( v, OP_IncrVacuum, iDb );\n                          sqlite3VdbeAddOp1( v, OP_ResultRow, 1 );\n                          sqlite3VdbeAddOp2( v, OP_AddImm, 1, -1 );\n                          sqlite3VdbeAddOp2( v, OP_IfPos, 1, addr );\n                          sqlite3VdbeJumpHere( v, addr );\n                        }\n                        else\n#endif\n\n#if !SQLITE_OMIT_PAGER_PRAGMAS\n                          /*\n**  PRAGMA [database.]cache_size\n**  PRAGMA [database.]cache_size=N\n**\n** The first form reports the current local setting for the\n** page cache size.  The local setting can be different from\n** the persistent cache size value that is stored in the database\n** file itself.  The value returned is the maximum number of\n** pages in the page cache.  The second form sets the local\n** page cache size value.  It does not change the persistent\n** cache size stored on the disk so the cache size will revert\n** to its default value when the database is closed and reopened.\n** N should be a positive integer.\n*/\n                          if ( sqlite3StrICmp( zLeft, "cache_size" ) == 0 )\n                          {\n                            if ( sqlite3ReadSchema( pParse ) != 0 ) goto pragma_out;\n                            if ( null == zRight )\n                            {\n                              returnSingleInt( pParse, "cache_size", pDb.pSchema.cache_size );\n                            }\n                            else\n                            {\n                              int size = atoi( zRight );\n                              if ( size < 0 ) size = -size;\n                              pDb.pSchema.cache_size = size;\n                              sqlite3BtreeSetCacheSize( pDb.pBt, pDb.pSchema.cache_size );\n                            }\n                          }\n                          else\n\n                            /*\n                            **   PRAGMA temp_store\n                            **   PRAGMA temp_store = "default"|"memory"|"file"\n                            **\n                            ** Return or set the local value of the temp_store flag.  Changing\n                            ** the local value does not make changes to the disk file and the default\n                            ** value will be restored the next time the database is opened.\n                            **\n                            ** Note that it is possible for the library compile-time options to\n                            ** override this setting\n                            */\n                            if ( sqlite3StrICmp( zLeft, "temp_store" ) == 0 )\n                            {\n                              if ( zRight == null )\n                              {\n                                returnSingleInt( pParse, "temp_store", db.temp_store );\n                              }\n                              else\n                              {\n                                changeTempStorage( pParse, zRight );\n                              }\n                            }\n                            else\n\n                              /*\n                              **   PRAGMA temp_store_directory\n                              **   PRAGMA temp_store_directory = ""|"directory_name"\n                              **\n                              ** Return or set the local value of the temp_store_directory flag.  Changing\n                              ** the value sets a specific directory to be used for temporary files.\n                              ** Setting to a null string reverts to the default temporary directory search.\n                              ** If temporary directory is changed, then invalidateTempStorage.\n                              **\n                              */\n                              if ( sqlite3StrICmp( zLeft, "temp_store_directory" ) == 0 )\n                              {\n                                if ( null == zRight )\n                                {\n                                  if ( sqlite3_temp_directory != "" )\n                                  {\n                                    sqlite3VdbeSetNumCols( v, 1 );\n                                    sqlite3VdbeSetColName( v, 0, COLNAME_NAME,\n                                        "temp_store_directory", SQLITE_STATIC );\n                                    sqlite3VdbeAddOp4( v, OP_String8, 0, 1, 0, sqlite3_temp_directory, 0 );\n                                    sqlite3VdbeAddOp2( v, OP_ResultRow, 1, 1 );\n                                  }\n                                }\n                                else\n                                {\n#if !SQLITE_OMIT_WSD\n                                  if ( zRight.Length > 0 )\n                                  {\n                                    int rc;\n                                    int res = 0;\n                                    rc = sqlite3OsAccess( db.pVfs, zRight, SQLITE_ACCESS_READWRITE, ref res );\n                                    if ( rc != SQLITE_OK || res == 0 )\n                                    {\n                                      sqlite3ErrorMsg( pParse, "not a writable directory" );\n                                      goto pragma_out;\n                                    }\n                                  }\n                                  if ( SQLITE_TEMP_STORE == 0\n                                   || ( SQLITE_TEMP_STORE == 1 && db.temp_store <= 1 )\n                                   || ( SQLITE_TEMP_STORE == 2 && db.temp_store == 1 )\n                                  )\n                                  {\n                                    invalidateTempStorage( pParse );\n                                  }\n                                  //sqlite3_free( ref sqlite3_temp_directory );\n                                  if ( zRight.Length > 0 )\n                                  {\n                                    sqlite3_temp_directory = zRight;//sqlite3DbStrDup(0, zRight);\n                                  }\n                                  else\n                                  {\n                                    sqlite3_temp_directory = "";\n                                  }\n#endif //* SQLITE_OMIT_WSD */\n                                }\n                              }\n                              else\n\n#if !(SQLITE_ENABLE_LOCKING_STYLE)\n#  if (__APPLE__)\n//#    define SQLITE_ENABLE_LOCKING_STYLE 1\n#  else\n                                //#    define SQLITE_ENABLE_LOCKING_STYLE 0\n#  endif\n#endif\n#if SQLITE_ENABLE_LOCKING_STYLE\n/*\n**   PRAGMA [database.]lock_proxy_file\n**   PRAGMA [database.]lock_proxy_file = ":auto:"|"lock_file_path"\n**\n** Return or set the value of the lock_proxy_file flag.  Changing\n** the value sets a specific file to be used for database access locks.\n**\n*/\nif ( sqlite3StrICmp( zLeft, "lock_proxy_file" ) == 0 )\n{\nif ( zRight !="")\n{\nPager pPager = sqlite3BtreePager( pDb.pBt );\nint proxy_file_path = 0;\nsqlite3_file pFile = sqlite3PagerFile( pPager );\nsqlite3OsFileControl( pFile, SQLITE_GET_LOCKPROXYFILE,\nref proxy_file_path );\n\nif ( proxy_file_path!=0 )\n{\nsqlite3VdbeSetNumCols( v, 1 );\nsqlite3VdbeSetColName( v, 0, COLNAME_NAME,\n"lock_proxy_file", SQLITE_STATIC );\nsqlite3VdbeAddOp4( v, OP_String8, 0, 1, 0, proxy_file_path, 0 );\nsqlite3VdbeAddOp2( v, OP_ResultRow, 1, 1 );\n}\n}\nelse\n{\nPager pPager = sqlite3BtreePager( pDb.pBt );\nsqlite3_file pFile = sqlite3PagerFile( pPager );\nint res;\nint iDummy = 0;\nif ( zRight[0]!=0 )\n{\niDummy = zRight[0];\nres = sqlite3OsFileControl( pFile, SQLITE_SET_LOCKPROXYFILE,\nref iDummy );\n}\nelse\n{\nres = sqlite3OsFileControl( pFile, SQLITE_SET_LOCKPROXYFILE,\nref iDummy );\n}\nif ( res != SQLITE_OK )\n{\nsqlite3ErrorMsg( pParse, "failed to set lock proxy file" );\ngoto pragma_out;\n}\n}\n}\nelse\n#endif //* SQLITE_ENABLE_LOCKING_STYLE */\n\n                                /*\n**   PRAGMA [database.]synchronous\n**   PRAGMA [database.]synchronous=OFF|ON|NORMAL|FULL\n**\n** Return or set the local value of the synchronous flag.  Changing\n** the local value does not make changes to the disk file and the\n** default value will be restored the next time the database is\n** opened.\n*/\n                                if ( sqlite3StrICmp( zLeft, "synchronous" ) == 0 )\n                                {\n                                  if ( sqlite3ReadSchema( pParse ) != 0 ) goto pragma_out;\n                                  if ( null == zRight )\n                                  {\n                                    returnSingleInt( pParse, "synchronous", pDb.safety_level - 1 );\n                                  }\n                                  else\n                                  {\n                                    if ( 0 == db.autoCommit )\n                                    {\n                                      sqlite3ErrorMsg( pParse,\n                                        "Safety level may not be changed inside a transaction" );\n                                    }\n                                    else\n                                    {\n                                      pDb.safety_level = (byte)( getSafetyLevel( zRight ) + 1 );\n                                    }\n                                  }\n                                }\n                                else\n#endif // * SQLITE_OMIT_PAGER_PRAGMAS */\n\n#if !SQLITE_OMIT_FLAG_PRAGMAS\n                                  if ( flagPragma( pParse, zLeft, zRight ) != 0 )\n                                  {\n                                    /* The flagPragma() subroutine also generates any necessary code\n                                    ** there is nothing more to do here */\n                                  }\n                                  else\n#endif // * SQLITE_OMIT_FLAG_PRAGMAS */\n\n#if !SQLITE_OMIT_SCHEMA_PRAGMAS\n                                    /*\n**   PRAGMA table_info(<table>)\n**\n** Return a single row for each column of the named table. The columns of\n** the returned data set are:\n**\n** cid:        Column id (numbered from left to right, starting at 0)\n** name:       Column name\n** type:       Column declaration type.\n** notnull:    True if \'NOT NULL\' is part of column declaration\n** dflt_value: The default value for the column, if any.\n*/\n                                    if ( sqlite3StrICmp( zLeft, "table_info" ) == 0 && zRight != null )\n                                    {\n                                      Table pTab;\n                                      if ( sqlite3ReadSchema( pParse ) != 0 ) goto pragma_out;\n                                      pTab = sqlite3FindTable( db, zRight, zDb );\n                                      if ( pTab != null )\n                                      {\n                                        int i;\n                                        int nHidden = 0;\n                                        Column pCol;\n                                        sqlite3VdbeSetNumCols( v, 6 );\n                                        pParse.nMem = 6;\n                                        sqlite3VdbeSetColName( v, 0, COLNAME_NAME, "cid", SQLITE_STATIC );\n                                        sqlite3VdbeSetColName( v, 1, COLNAME_NAME, "name", SQLITE_STATIC );\n                                        sqlite3VdbeSetColName( v, 2, COLNAME_NAME, "type", SQLITE_STATIC );\n                                        sqlite3VdbeSetColName( v, 3, COLNAME_NAME, "notnull", SQLITE_STATIC );\n                                        sqlite3VdbeSetColName( v, 4, COLNAME_NAME, "dflt_value", SQLITE_STATIC );\n                                        sqlite3VdbeSetColName( v, 5, COLNAME_NAME, "pk", SQLITE_STATIC );\n                                        sqlite3ViewGetColumnNames( pParse, pTab );\n                                        for ( i = 0 ; i < pTab.nCol ; i++ )//, pCol++)\n                                        {\n                                          pCol = pTab.aCol[i];\n                                          if ( IsHiddenColumn( pCol ) )\n                                          {\n                                            nHidden++;\n                                            continue;\n                                          }\n                                          sqlite3VdbeAddOp2( v, OP_Integer, i - nHidden, 1 );\n                                          sqlite3VdbeAddOp4( v, OP_String8, 0, 2, 0, pCol.zName, 0 );\n                                          sqlite3VdbeAddOp4( v, OP_String8, 0, 3, 0,\n                                             pCol.zType != null ? pCol.zType : "", 0 );\n                                          sqlite3VdbeAddOp2( v, OP_Integer, ( pCol.notNull != 0 ? 1 : 0 ), 4 );\n                                          if ( pCol.zDflt != null )\n                                          {\n                                            sqlite3VdbeAddOp4( v, OP_String8, 0, 5, 0, pCol.zDflt, 0 );\n                                          }\n                                          else\n                                          {\n                                            sqlite3VdbeAddOp2( v, OP_Null, 0, 5 );\n                                          }\n                                          sqlite3VdbeAddOp2( v, OP_Integer, pCol.isPrimKey != 0 ? 1 : 0, 6 );\n                                          sqlite3VdbeAddOp2( v, OP_ResultRow, 1, 6 );\n                                        }\n                                      }\n                                    }\n                                    else\n\n                                      if ( sqlite3StrICmp( zLeft, "index_info" ) == 0 && zRight != null )\n                                      {\n                                        Index pIdx;\n                                        Table pTab;\n                                        if ( sqlite3ReadSchema( pParse ) != 0 ) goto pragma_out;\n                                        pIdx = sqlite3FindIndex( db, zRight, zDb );\n                                        if ( pIdx != null )\n                                        {\n                                          int i;\n                                          pTab = pIdx.pTable;\n                                          sqlite3VdbeSetNumCols( v, 3 );\n                                          pParse.nMem = 3;\n                                          sqlite3VdbeSetColName( v, 0, COLNAME_NAME, "seqno", SQLITE_STATIC );\n                                          sqlite3VdbeSetColName( v, 1, COLNAME_NAME, "cid", SQLITE_STATIC );\n                                          sqlite3VdbeSetColName( v, 2, COLNAME_NAME, "name", SQLITE_STATIC );\n                                          for ( i = 0 ; i < pIdx.nColumn ; i++ )\n                                          {\n                                            int cnum = pIdx.aiColumn[i];\n                                            sqlite3VdbeAddOp2( v, OP_Integer, i, 1 );\n                                            sqlite3VdbeAddOp2( v, OP_Integer, cnum, 2 );\n                                            Debug.Assert( pTab.nCol > cnum );\n                                            sqlite3VdbeAddOp4( v, OP_String8, 0, 3, 0, pTab.aCol[cnum].zName, 0 );\n                                            sqlite3VdbeAddOp2( v, OP_ResultRow, 1, 3 );\n                                          }\n                                        }\n                                      }\n                                      else\n\n                                        if ( sqlite3StrICmp( zLeft, "index_list" ) == 0 && zRight != null )\n                                        {\n                                          Index pIdx;\n                                          Table pTab;\n                                          if ( sqlite3ReadSchema( pParse ) != 0 ) goto pragma_out;\n                                          pTab = sqlite3FindTable( db, zRight, zDb );\n                                          if ( pTab != null )\n                                          {\n                                            v = sqlite3GetVdbe( pParse );\n                                            pIdx = pTab.pIndex;\n                                            if ( pIdx != null )\n                                            {\n                                              int i = 0;\n                                              sqlite3VdbeSetNumCols( v, 3 );\n                                              pParse.nMem = 3;\n                                              sqlite3VdbeSetColName( v, 0, COLNAME_NAME, "seq", SQLITE_STATIC );\n                                              sqlite3VdbeSetColName( v, 1, COLNAME_NAME, "name", SQLITE_STATIC );\n                                              sqlite3VdbeSetColName( v, 2, COLNAME_NAME, "unique", SQLITE_STATIC );\n                                              while ( pIdx != null )\n                                              {\n                                                sqlite3VdbeAddOp2( v, OP_Integer, i, 1 );\n                                                sqlite3VdbeAddOp4( v, OP_String8, 0, 2, 0, pIdx.zName, 0 );\n                                                sqlite3VdbeAddOp2( v, OP_Integer, ( pIdx.onError != OE_None ) ? 1 : 0, 3 );\n                                                sqlite3VdbeAddOp2( v, OP_ResultRow, 1, 3 );\n                                                ++i;\n                                                pIdx = pIdx.pNext;\n                                              }\n                                            }\n                                          }\n                                        }\n                                        else\n\n                                          if ( sqlite3StrICmp( zLeft, "database_list" ) == 0 )\n                                          {\n                                            int i;\n                                            if ( sqlite3ReadSchema( pParse ) != 0 ) goto pragma_out;\n                                            sqlite3VdbeSetNumCols( v, 3 );\n                                            pParse.nMem = 3;\n                                            sqlite3VdbeSetColName( v, 0, COLNAME_NAME, "seq", SQLITE_STATIC );\n                                            sqlite3VdbeSetColName( v, 1, COLNAME_NAME, "name", SQLITE_STATIC );\n                                            sqlite3VdbeSetColName( v, 2, COLNAME_NAME, "file", SQLITE_STATIC );\n                                            for ( i = 0 ; i < db.nDb ; i++ )\n                                            {\n                                              if ( db.aDb[i].pBt == null ) continue;\n                                              Debug.Assert( db.aDb[i].zName != null );\n                                              sqlite3VdbeAddOp2( v, OP_Integer, i, 1 );\n                                              sqlite3VdbeAddOp4( v, OP_String8, 0, 2, 0, db.aDb[i].zName, 0 );\n                                              sqlite3VdbeAddOp4( v, OP_String8, 0, 3, 0,\n                                                   sqlite3BtreeGetFilename( db.aDb[i].pBt ), 0 );\n                                              sqlite3VdbeAddOp2( v, OP_ResultRow, 1, 3 );\n                                            }\n                                          }\n                                          else\n\n                                            if ( sqlite3StrICmp( zLeft, "collation_list" ) == 0 )\n                                            {\n                                              int i = 0;\n                                              HashElem p;\n                                              sqlite3VdbeSetNumCols( v, 2 );\n                                              pParse.nMem = 2;\n                                              sqlite3VdbeSetColName( v, 0, COLNAME_NAME, "seq", SQLITE_STATIC );\n                                              sqlite3VdbeSetColName( v, 1, COLNAME_NAME, "name", SQLITE_STATIC );\n                                              for ( p = db.aCollSeq.first ; p != null ; p = p.next )//( p = sqliteHashFirst( db.aCollSeq ) ; p; p = sqliteHashNext( p ) )\n                                              {\n                                                CollSeq pColl = ( (CollSeq[])p.data )[0];// sqliteHashData( p );\n                                                sqlite3VdbeAddOp2( v, OP_Integer, i++, 1 );\n                                                sqlite3VdbeAddOp4( v, OP_String8, 0, 2, 0, pColl.zName, 0 );\n                                                sqlite3VdbeAddOp2( v, OP_ResultRow, 1, 2 );\n                                              }\n                                            }\n                                            else\n#endif // * SQLITE_OMIT_SCHEMA_PRAGMAS */\n\n#if !SQLITE_OMIT_FOREIGN_KEY\n                                              if ( sqlite3StrICmp( zLeft, "foreign_key_list" ) == 0 && zRight != null )\n                                              {\n                                                FKey pFK;\n                                                Table pTab;\n                                                if ( sqlite3ReadSchema( pParse ) != 0 ) goto pragma_out;\n                                                pTab = sqlite3FindTable( db, zRight, zDb );\n                                                if ( pTab != null )\n                                                {\n                                                  v = sqlite3GetVdbe( pParse );\n                                                  pFK = pTab.pFKey;\n                                                  if ( pFK != null )\n                                                  {\n                                                    int i = 0;\n                                                    sqlite3VdbeSetNumCols( v, 8 );\n                                                    pParse.nMem = 8;\n                                                    sqlite3VdbeSetColName( v, 0, COLNAME_NAME, "id", SQLITE_STATIC );\n                                                    sqlite3VdbeSetColName( v, 1, COLNAME_NAME, "seq", SQLITE_STATIC );\n                                                    sqlite3VdbeSetColName( v, 2, COLNAME_NAME, "table", SQLITE_STATIC );\n                                                    sqlite3VdbeSetColName( v, 3, COLNAME_NAME, "from", SQLITE_STATIC );\n                                                    sqlite3VdbeSetColName( v, 4, COLNAME_NAME, "to", SQLITE_STATIC );\n                                                    sqlite3VdbeSetColName( v, 5, COLNAME_NAME, "on_update", SQLITE_STATIC );\n                                                    sqlite3VdbeSetColName( v, 6, COLNAME_NAME, "on_delete", SQLITE_STATIC );\n                                                    sqlite3VdbeSetColName( v, 7, COLNAME_NAME, "match", SQLITE_STATIC );\n                                                    while ( pFK != null )\n                                                    {\n                                                      int j;\n                                                      for ( j = 0 ; j < pFK.nCol ; j++ )\n                                                      {\n                                                        string zCol = pFK.aCol[j].zCol;\n                                                        string zOnUpdate = actionName( pFK.updateConf );\n                                                        string zOnDelete = actionName( pFK.deleteConf );\n                                                        sqlite3VdbeAddOp2( v, OP_Integer, i, 1 );\n                                                        sqlite3VdbeAddOp2( v, OP_Integer, j, 2 );\n                                                        sqlite3VdbeAddOp4( v, OP_String8, 0, 3, 0, pFK.zTo, 0 );\n                                                        sqlite3VdbeAddOp4( v, OP_String8, 0, 4, 0,\n                                                                          pTab.aCol[pFK.aCol[j].iFrom].zName, 0 );\n                                                        sqlite3VdbeAddOp4( v, zCol != null ? OP_String8 : OP_Null, 0, 5, 0, zCol, 0 );\n                                                        sqlite3VdbeAddOp4( v, OP_String8, 0, 6, 0, zOnUpdate, 0 );\n                                                        sqlite3VdbeAddOp4( v, OP_String8, 0, 7, 0, zOnDelete, 0 );\n                                                        sqlite3VdbeAddOp4( v, OP_String8, 0, 8, 0, "NONE", 0 );\n                                                        sqlite3VdbeAddOp2( v, OP_ResultRow, 1, 8 );\n                                                      }\n                                                      ++i;\n                                                      pFK = pFK.pNextFrom;\n                                                    }\n                                                  }\n                                                }\n                                              }\n                                              else\n#endif // * !SQLITE_OMIT_FOREIGN_KEY) */\n\n#if !NDEBUG\n                                        if ( sqlite3StrICmp( zLeft, "parser_trace" ) == 0 )\n                                        {\n                                          if ( zRight != null )\n                                          {\n                                            if ( getBoolean( zRight ) != 0 )\n                                            {\n                                              sqlite3ParserTrace( Console.Out, "parser: " );\n                                            }\n                                            else\n                                            {\n                                              sqlite3ParserTrace( null, "" );\n                                            }\n                                          }\n                                        }\n                                        else\n#endif\n\n                                                /* Reinstall the LIKE and GLOB functions.  The variant of LIKE\n** used will be case sensitive or not depending on the RHS.\n*/\n                                                if ( sqlite3StrICmp( zLeft, "case_sensitive_like" ) == 0 )\n                                                {\n                                                  if ( zRight != null )\n                                                  {\n                                                    sqlite3RegisterLikeFunctions( db, getBoolean( zRight ) );\n                                                  }\n                                                }\n                                                else\n\n#if !SQLITE_INTEGRITY_CHECK_ERROR_MAX\n                                                  //const int SQLITE_INTEGRITY_CHECK_ERROR_MAX = 100;\n#endif\n\n#if !SQLITE_OMIT_INTEGRITY_CHECK\n                                                  /* Pragma "quick_check" is an experimental reduced version of\n** integrity_check designed to detect most database corruption\n** without most of the overhead of a full integrity-check.\n*/\n                                                  if ( sqlite3StrICmp( zLeft, "integrity_check" ) == 0\n                                                   || sqlite3StrICmp( zLeft, "quick_check" ) == 0\n                                                  )\n                                                  {\n                                                    const int SQLITE_INTEGRITY_CHECK_ERROR_MAX = 100;\n                                                    int i, j, addr, mxErr;\n\n                                                    /* Code that appears at the end of the integrity check.  If no error\n                                                    ** messages have been generated, output OK.  Otherwise output the\n                                                    ** error message\n                                                    */\n                                                    VdbeOpList[] endCode = new VdbeOpList[]  {\nnew VdbeOpList( OP_AddImm,      1, 0,        0),    /* 0 */\nnew                    VdbeOpList( OP_IfNeg,       1, 0,        0),    /* 1 */\nnew    VdbeOpList( OP_String8,     0, 3,        0),    /* 2 */\nnew  VdbeOpList( OP_ResultRow,   3, 1,        0),\n};\n\n                                                    bool isQuick = ( zLeft[0] == \'q\' );\n\n                                                    /* Initialize the VDBE program */\n                                                    if ( sqlite3ReadSchema( pParse ) != 0 ) goto pragma_out;\n                                                    pParse.nMem = 6;\n                                                    sqlite3VdbeSetNumCols( v, 1 );\n                                                    sqlite3VdbeSetColName( v, 0, COLNAME_NAME, "integrity_check", SQLITE_STATIC );\n\n                                                    /* Set the maximum error count */\n                                                    mxErr = SQLITE_INTEGRITY_CHECK_ERROR_MAX;\n                                                    if ( zRight != null )\n                                                    {\n                                                      mxErr = atoi( zRight );\n                                                      if ( mxErr <= 0 )\n                                                      {\n                                                        mxErr = SQLITE_INTEGRITY_CHECK_ERROR_MAX;\n                                                      }\n                                                    }\n                                                    sqlite3VdbeAddOp2( v, OP_Integer, mxErr, 1 );  /* reg[1] holds errors left */\n\n                                                    /* Do an integrity check on each database file */\n                                                    for ( i = 0 ; i < db.nDb ; i++ )\n                                                    {\n                                                      HashElem x;\n                                                      Hash pTbls;\n                                                      int cnt = 0;\n\n                                                      if ( OMIT_TEMPDB != 0 && i == 1 ) continue;\n\n                                                      sqlite3CodeVerifySchema( pParse, i );\n                                                      addr = sqlite3VdbeAddOp1( v, OP_IfPos, 1 ); /* Halt if out of errors */\n                                                      sqlite3VdbeAddOp2( v, OP_Halt, 0, 0 );\n                                                      sqlite3VdbeJumpHere( v, addr );\n\n                                                      /* Do an integrity check of the B-Tree\n                                                      **\n                                                      ** Begin by filling registers 2, 3, ... with the root pages numbers\n                                                      ** for all tables and indices in the database.\n                                                      */\n                                                      pTbls = db.aDb[i].pSchema.tblHash;\n                                                      for ( x = pTbls.first ; x != null ; x = x.next )\n                                                      {//          for(x=sqliteHashFirst(pTbls); x; x=sqliteHashNext(x)){\n                                                        Table pTab = (Table)x.data;// sqliteHashData( x );\n                                                        Index pIdx;\n                                                        sqlite3VdbeAddOp2( v, OP_Integer, pTab.tnum, 2 + cnt );\n                                                        cnt++;\n                                                        for ( pIdx = pTab.pIndex ; pIdx != null ; pIdx = pIdx.pNext )\n                                                        {\n                                                          sqlite3VdbeAddOp2( v, OP_Integer, pIdx.tnum, 2 + cnt );\n                                                          cnt++;\n                                                        }\n                                                      }\n\n                                                      /* Make sure sufficient number of registers have been allocated */\n                                                      if ( pParse.nMem < cnt + 4 )\n                                                      {\n                                                        pParse.nMem = cnt + 4;\n                                                      }\n\n                                                      /* Do the b-tree integrity checks */\n                                                      sqlite3VdbeAddOp3( v, OP_IntegrityCk, 2, cnt, 1 );\n                                                      sqlite3VdbeChangeP5( v, (u8)i );\n                                                      addr = sqlite3VdbeAddOp1( v, OP_IsNull, 2 );\n                                                      sqlite3VdbeAddOp4( v, OP_String8, 0, 3, 0,\n                                                         sqlite3MPrintf( db, "*** in database %s ***\\n", db.aDb[i].zName ),\n                                                         P4_DYNAMIC );\n                                                      sqlite3VdbeAddOp3( v, OP_Move, 2, 4, 1 );\n                                                      sqlite3VdbeAddOp3( v, OP_Concat, 4, 3, 2 );\n                                                      sqlite3VdbeAddOp2( v, OP_ResultRow, 2, 1 );\n                                                      sqlite3VdbeJumpHere( v, addr );\n\n                                                      /* Make sure all the indices are constructed correctly.\n                                                      */\n                                                      for ( x = pTbls.first ; x != null && !isQuick ; x = x.next )\n                                                      {\n                                                        ;//          for(x=sqliteHashFirst(pTbls); x && !isQuick; x=sqliteHashNext(x)){\n                                                        Table pTab = (Table)x.data;// sqliteHashData( x );\n                                                        Index pIdx;\n                                                        int loopTop;\n\n                                                        if ( pTab.pIndex == null ) continue;\n                                                        addr = sqlite3VdbeAddOp1( v, OP_IfPos, 1 );  /* Stop if out of errors */\n                                                        sqlite3VdbeAddOp2( v, OP_Halt, 0, 0 );\n                                                        sqlite3VdbeJumpHere( v, addr );\n                                                        sqlite3OpenTableAndIndices( pParse, pTab, 1, OP_OpenRead );\n                                                        sqlite3VdbeAddOp2( v, OP_Integer, 0, 2 );  /* reg(2) will count entries */\n                                                        loopTop = sqlite3VdbeAddOp2( v, OP_Rewind, 1, 0 );\n                                                        sqlite3VdbeAddOp2( v, OP_AddImm, 2, 1 );   /* increment entry count */\n                                                        for ( j = 0, pIdx = pTab.pIndex ; pIdx != null ; pIdx = pIdx.pNext, j++ )\n                                                        {\n                                                          int jmp2;\n                                                          VdbeOpList[] idxErr = new VdbeOpList[]  {\nnew VdbeOpList( OP_AddImm,      1, -1,  0),\nnew VdbeOpList( OP_String8,     0,  3,  0),    /* 1 */\nnew VdbeOpList( OP_Rowid,       1,  4,  0),\nnew VdbeOpList( OP_String8,     0,  5,  0),    /* 3 */\nnew VdbeOpList( OP_String8,     0,  6,  0),    /* 4 */\nnew VdbeOpList( OP_Concat,      4,  3,  3),\nnew VdbeOpList( OP_Concat,      5,  3,  3),\nnew VdbeOpList( OP_Concat,      6,  3,  3),\nnew VdbeOpList( OP_ResultRow,   3,  1,  0),\nnew VdbeOpList(  OP_IfPos,       1,  0,  0),    /* 9 */\nnew VdbeOpList(  OP_Halt,        0,  0,  0),\n};\n                                                          sqlite3GenerateIndexKey( pParse, pIdx, 1, 3, true );\n                                                          jmp2 = sqlite3VdbeAddOp3( v, OP_Found, j + 2, 0, 3 );\n                                                          addr = sqlite3VdbeAddOpList( v, ArraySize( idxErr ), idxErr );\n                                                          sqlite3VdbeChangeP4( v, addr + 1, "rowid ", SQLITE_STATIC );\n                                                          sqlite3VdbeChangeP4( v, addr + 3, " missing from index ", SQLITE_STATIC );\n                                                          sqlite3VdbeChangeP4( v, addr + 4, pIdx.zName, P4_STATIC );\n                                                          sqlite3VdbeJumpHere( v, addr + 9 );\n                                                          sqlite3VdbeJumpHere( v, jmp2 );\n                                                        }\n                                                        sqlite3VdbeAddOp2( v, OP_Next, 1, loopTop + 1 );\n                                                        sqlite3VdbeJumpHere( v, loopTop );\n                                                        for ( j = 0, pIdx = pTab.pIndex ; pIdx != null ; pIdx = pIdx.pNext, j++ )\n                                                        {\n                                                          VdbeOpList[] cntIdx = new VdbeOpList[] {\nnew VdbeOpList( OP_Integer,      0,  3,  0),\nnew VdbeOpList( OP_Rewind,       0,  0,  0),  /* 1 */\nnew VdbeOpList( OP_AddImm,       3,  1,  0),\nnew VdbeOpList( OP_Next,         0,  0,  0),  /* 3 */\nnew VdbeOpList( OP_Eq,           2,  0,  3),  /* 4 */\nnew VdbeOpList( OP_AddImm,       1, -1,  0),\nnew VdbeOpList( OP_String8,      0,  2,  0),  /* 6 */\nnew VdbeOpList( OP_String8,      0,  3,  0),  /* 7 */\nnew VdbeOpList( OP_Concat,       3,  2,  2),\nnew VdbeOpList( OP_ResultRow,    2,  1,  0),\n};\n                                                          addr = sqlite3VdbeAddOp1( v, OP_IfPos, 1 );\n                                                          sqlite3VdbeAddOp2( v, OP_Halt, 0, 0 );\n                                                          sqlite3VdbeJumpHere( v, addr );\n                                                          addr = sqlite3VdbeAddOpList( v, ArraySize( cntIdx ), cntIdx );\n                                                          sqlite3VdbeChangeP1( v, addr + 1, j + 2 );\n                                                          sqlite3VdbeChangeP2( v, addr + 1, addr + 4 );\n                                                          sqlite3VdbeChangeP1( v, addr + 3, j + 2 );\n                                                          sqlite3VdbeChangeP2( v, addr + 3, addr + 2 );\n                                                          sqlite3VdbeJumpHere( v, addr + 4 );\n                                                          sqlite3VdbeChangeP4( v, addr + 6,\n                                                                     "wrong # of entries in index ", P4_STATIC );\n                                                          sqlite3VdbeChangeP4( v, addr + 7, pIdx.zName, P4_STATIC );\n                                                        }\n                                                      }\n                                                    }\n                                                    addr = sqlite3VdbeAddOpList( v, ArraySize( endCode ), endCode );\n                                                    sqlite3VdbeChangeP2( v, addr, -mxErr );\n                                                    sqlite3VdbeJumpHere( v, addr + 1 );\n                                                    sqlite3VdbeChangeP4( v, addr + 2, "ok", P4_STATIC );\n                                                  }\n                                                  else\n#endif // * SQLITE_OMIT_INTEGRITY_CHECK */\n\n                                                    /*\n**   PRAGMA encoding\n**   PRAGMA encoding = "utf-8"|"utf-16"|"utf-16le"|"utf-16be"\n**\n** In its first form, this pragma returns the encoding of the main\n** database. If the database is not initialized, it is initialized now.\n**\n** The second form of this pragma is a no-op if the main database file\n** has not already been initialized. In this case it sets the default\n** encoding that will be used for the main database file if a new file\n** is created. If an existing main database file is opened, then the\n** default text encoding for the existing database is used.\n**\n** In all cases new databases created using the ATTACH command are\n** created to use the same default text encoding as the main database. If\n** the main database has not been initialized and/or created when ATTACH\n** is executed, this is done before the ATTACH operation.\n**\n** In the second form this pragma sets the text encoding to be used in\n** new database files created using this database handle. It is only\n** useful if invoked immediately after the main database i\n*/\n                                                    if ( sqlite3StrICmp( zLeft, "encoding" ) == 0 )\n                                                    {\n                                                      EncName[] encnames = new EncName[]  {\nnew EncName( "UTF8",     SQLITE_UTF8        ),\nnew EncName( "UTF-8",    SQLITE_UTF8        ),/* Must be element [1] */\nnew EncName( "UTF-16le", SQLITE_UTF16LE     ),/* Must be element [2] */\nnew EncName( "UTF-16be", SQLITE_UTF16BE     ), /* Must be element [3] */\nnew EncName( "UTF16le",  SQLITE_UTF16LE     ),\nnew EncName( "UTF16be",  SQLITE_UTF16BE     ),\nnew EncName( "UTF-16",   0                  ), /* SQLITE_UTF16NATIVE */\nnew EncName( "UTF16",    0                  ), /* SQLITE_UTF16NATIVE */\nnew EncName( null, 0 )\n};\n                                                      int iEnc;\n                                                      if ( null == zRight )\n                                                      {    /* "PRAGMA encoding" */\n                                                        if ( sqlite3ReadSchema( pParse ) != 0 ) goto pragma_out;\n                                                        sqlite3VdbeSetNumCols( v, 1 );\n                                                        sqlite3VdbeSetColName( v, 0, COLNAME_NAME, "encoding", SQLITE_STATIC );\n                                                        sqlite3VdbeAddOp2( v, OP_String8, 0, 1 );\n                                                        Debug.Assert( encnames[SQLITE_UTF8].enc == SQLITE_UTF8 );\n                                                        Debug.Assert( encnames[SQLITE_UTF16LE].enc == SQLITE_UTF16LE );\n                                                        Debug.Assert( encnames[SQLITE_UTF16BE].enc == SQLITE_UTF16BE );\n                                                        sqlite3VdbeChangeP4( v, -1, encnames[ENC( pParse.db )].zName, P4_STATIC );\n                                                        sqlite3VdbeAddOp2( v, OP_ResultRow, 1, 1 );\n                                                      }\n#if !SQLITE_OMIT_UTF16\nelse\n{                        /* "PRAGMA encoding = XXX" */\n/* Only change the value of sqlite.enc if the database handle is not\n** initialized. If the main database exists, the new sqlite.enc value\n** will be overwritten when the schema is next loaded. If it does not\n** already exists, it will be created to use the new encoding value.\n*/\nif (\n//!(DbHasProperty(db, 0, DB_SchemaLoaded)) ||\n//DbHasProperty(db, 0, DB_Empty)\n( db.flags & DB_SchemaLoaded ) != DB_SchemaLoaded || ( db.flags & DB_Empty ) == DB_Empty\n)\n{\nfor ( iEnc = 0 ; encnames[iEnc].zName != null ; iEnc++ )\n{\nif ( 0 == sqlite3StrICmp( zRight, encnames[iEnc].zName ) )\n{\npParse.db.aDbStatic[0].pSchema.enc = encnames[iEnc].enc != 0 ? encnames[iEnc].enc : SQLITE_UTF16NATIVE;\nbreak;\n}\n}\nif ( encnames[iEnc].zName == null )\n{\nsqlite3ErrorMsg( pParse, "unsupported encoding: %s", zRight );\n}\n}\n}\n#endif\n                                                    }\n                                                    else\n\n#if !SQLITE_OMIT_SCHEMA_VERSION_PRAGMAS\n                                                      /*\n**   PRAGMA [database.]schema_version\n**   PRAGMA [database.]schema_version = <integer>\n**\n**   PRAGMA [database.]user_version\n**   PRAGMA [database.]user_version = <integer>\n**\n** The pragma\'s schema_version and user_version are used to set or get\n** the value of the schema-version and user-version, respectively. Both\n** the schema-version and the user-version are 32-bit signed integers\n** stored in the database header.\n**\n** The schema-cookie is usually only manipulated internally by SQLite. It\n** is incremented by SQLite whenever the database schema is modified (by\n** creating or dropping a table or index). The schema version is used by\n** SQLite each time a query is executed to ensure that the internal cache\n** of the schema used when compiling the SQL query matches the schema of\n** the database against which the compiled query is actually executed.\n** Subverting this mechanism by using "PRAGMA schema_version" to modify\n** the schema-version is potentially dangerous and may lead to program\n** crashes or database corruption. Use with caution!\n**\n** The user-version is not used internally by SQLite. It may be used by\n** applications for any purpose.\n*/\n                                                      if ( sqlite3StrICmp( zLeft, "schema_version" ) == 0\n                                                       || sqlite3StrICmp( zLeft, "user_version" ) == 0\n                                                       || sqlite3StrICmp( zLeft, "freelist_count" ) == 0\n                                                      )\n                                                      {\n                                                        int iCookie;   /* Cookie index. 1 for schema-cookie, 6 for user-cookie. */\n                                                        sqlite3VdbeUsesBtree( v, iDb );\n                                                        switch ( zLeft[0] )\n                                                        {\n                                                          case \'f\':\n                                                          case \'F\':\n                                                            iCookie = BTREE_FREE_PAGE_COUNT;\n                                                            break;\n                                                          case \'s\':\n                                                          case \'S\':\n                                                            iCookie = BTREE_SCHEMA_VERSION;\n                                                            break;\n                                                          default:\n                                                            iCookie = BTREE_USER_VERSION;\n                                                            break;\n                                                        }\n\n                                                        if ( zRight != null && iCookie != BTREE_FREE_PAGE_COUNT )\n                                                        {\n                                                          /* Write the specified cookie value */\n                                                          VdbeOpList[] setCookie = new VdbeOpList[] {\nnew VdbeOpList( OP_Transaction,    0,  1,  0),    /* 0 */\nnew   VdbeOpList( OP_Integer,        0,  1,  0),    /* 1 */\nnew VdbeOpList( OP_SetCookie,      0,  0,  1),    /* 2 */\n};\n                                                          int addr = sqlite3VdbeAddOpList( v, ArraySize( setCookie ), setCookie );\n                                                          sqlite3VdbeChangeP1( v, addr, iDb );\n                                                          sqlite3VdbeChangeP1( v, addr + 1, atoi( zRight ) );\n                                                          sqlite3VdbeChangeP1( v, addr + 2, iDb );\n                                                          sqlite3VdbeChangeP2( v, addr + 2, iCookie );\n                                                        }\n                                                        else\n                                                        {\n                                                          /* Read the specified cookie value */\n                                                          VdbeOpList[] readCookie = new VdbeOpList[]  {\nnew VdbeOpList( OP_Transaction,     0,  0,  0),    /* 0 */\nnew VdbeOpList( OP_ReadCookie,      0,  1,  0),    /* 1 */\nnew VdbeOpList( OP_ResultRow,       1,  1,  0)\n};\n                                                          int addr = sqlite3VdbeAddOpList( v, readCookie.Length, readCookie );// ArraySize(readCookie), readCookie);\n                                                          sqlite3VdbeChangeP1( v, addr, iDb );\n                                                          sqlite3VdbeChangeP1( v, addr + 1, iDb );\n                                                          sqlite3VdbeChangeP3( v, addr + 1, iCookie );\n                                                          sqlite3VdbeSetNumCols( v, 1 );\n                                                          sqlite3VdbeSetColName( v, 0, COLNAME_NAME, zLeft, SQLITE_TRANSIENT );\n                                                        }\n                                                      }\n                                                      else if ( sqlite3StrICmp( zLeft, "reload_schema" ) == 0 )\n                                                      {\n                                                        /* force schema reloading*/\n                                                        sqlite3ResetInternalSchema( db, 0 );\n                                                      }\n                                                      else if ( sqlite3StrICmp( zLeft, "file_format" ) == 0 )\n                                                      {\n                                                        pDb.pSchema.file_format = (u8)atoi( zRight );\n                                                        sqlite3ResetInternalSchema( db, 0 );\n                                                      }\n\n                                                      else\n#endif // * SQLITE_OMIT_SCHEMA_VERSION_PRAGMAS */\n\n#if SQLITE_DEBUG || SQLITE_TEST\n                                                  /*\n** Report the current state of file logs for all databases\n*/\n                                                  if ( sqlite3StrICmp( zLeft, "lock_status" ) == 0 )\n                                                  {\n                                                    string[] azLockName = {\n"unlocked", "shared", "reserved", "pending", "exclusive"\n};\n                                                    int i;\n                                                    sqlite3VdbeSetNumCols( v, 2 );\n                                                    pParse.nMem = 2;\n                                                    sqlite3VdbeSetColName( v, 0, COLNAME_NAME, "database", SQLITE_STATIC );\n                                                    sqlite3VdbeSetColName( v, 1, COLNAME_NAME, "status", SQLITE_STATIC );\n                                                    for ( i = 0 ; i < db.nDb ; i++ )\n                                                    {\n                                                      Btree pBt;\n                                                      Pager pPager;\n                                                      string zState = "unknown";\n                                                      int j = 0;\n                                                      if ( db.aDb[i].zName == null ) continue;\n                                                      sqlite3VdbeAddOp4( v, OP_String8, 0, 1, 0, db.aDb[i].zName, P4_STATIC );\n                                                      pBt = db.aDb[i].pBt;\n                                                      if ( pBt == null || ( pPager = sqlite3BtreePager( pBt ) ) == null )\n                                                      {\n                                                        zState = "closed";\n                                                      }\n                                                      else if ( sqlite3_file_control( db, i != 0 ? db.aDb[i].zName : null,\n                                               SQLITE_FCNTL_LOCKSTATE, ref j ) == SQLITE_OK )\n                                                      {\n                                                        zState = azLockName[j];\n                                                      }\n                                                      sqlite3VdbeAddOp4( v, OP_String8, 0, 2, 0, zState, P4_STATIC );\n                                                      sqlite3VdbeAddOp2( v, OP_ResultRow, 1, 2 );\n                                                    }\n                                                  }\n                                                  else\n#endif\n\n#if SQLITE_HAS_CODEC\nif( sqlite3StrICmp(zLeft, "key")==0 && zRight ){\nsqlite3_key(db, zRight, sqlite3Strlen30(zRight));\n}else\nif( sqlite3StrICmp(zLeft, "rekey")==0 && zRight ){\nsqlite3_rekey(db, zRight, sqlite3Strlen30(zRight));\n}else\nif( zRight && (sqlite3StrICmp(zLeft, "hexkey")==0 ||\nsqlite3StrICmp(zLeft, "hexrekey")==0) ){\nint i, h1, h2;\nchar zKey[40];\nfor(i=0; (h1 = zRight[i])!=0 && (h2 = zRight[i+1])!=0; i+=2){\nh1 += 9*(1&(h1>>6));\nh2 += 9*(1&(h2>>6));\nzKey[i/2] = (h2 & 0x0f) | ((h1 & 0xf)<<4);\n}\nif( (zLeft[3] & 0xf)==0xb ){\nsqlite3_key(db, zKey, i/2);\n}else{\nsqlite3_rekey(db, zKey, i/2);\n}\n}else\n#endif\n#if SQLITE_HAS_CODEC || SQLITE_ENABLE_CEROD\nif( sqlite3StrICmp(zLeft, "activate_extensions")==0 ){\n#if SQLITE_HAS_CODEC\nif( sqlite3StrNICmp(zRight, "see-", 4)==0 ){\nextern void sqlite3_activate_see(const char*);\nsqlite3_activate_see(&zRight[4]);\n}\n#endif\n#if SQLITE_ENABLE_CEROD\nif( sqlite3StrNICmp(zRight, "cerod-", 6)==0 ){\nextern void sqlite3_activate_cerod(const char*);\nsqlite3_activate_cerod(&zRight[6]);\n}\n#endif\n}else\n#endif\n                                                      { /* Empty ELSE clause */}\n\n      /* Code an OP_Expire at the end of each PRAGMA program to cause\n      ** the VDBE implementing the pragma to expire. Most (all?) pragmas\n      ** are only valid for a single execution.\n      */\n      sqlite3VdbeAddOp2( v, OP_Expire, 1, 0 );\n\n      /*\n      ** Reset the safety level, in case the fullfsync flag or synchronous\n      ** setting changed.\n      */\n#if !SQLITE_OMIT_PAGER_PRAGMAS\n      if ( db.autoCommit != 0 )\n      {\n        sqlite3BtreeSetSafetyLevel( pDb.pBt, pDb.safety_level,\n          ( ( db.flags & SQLITE_FullFSync ) != 0 ) ? 1 : 0 );\n      }\n#endif\n    pragma_out:\n      //sqlite3DbFree( db, ref zLeft );\n      //sqlite3DbFree( db, ref zRight );\n      ;\n    }\n\n#endif // * SQLITE_OMIT_PRAGMA\n  }\n}\n'