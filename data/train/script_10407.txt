b'module Cachix.API.Signing\n  ( fingerprint,\n    passthroughSizeSink,\n    passthroughHashSinkB16,\n    passthroughHashSink,\n  )\nwhere\n\nimport Crypto.Hash\nimport qualified Data.ByteArray as BA\nimport Data.ByteArray.Encoding (Base (..), convertToBase)\nimport qualified Data.ByteString as BS\nimport Data.Conduit\nimport qualified Data.Conduit.Combinators as CC\nimport Data.IORef\nimport qualified Data.Text as T\nimport Protolude hiding (toS)\nimport Protolude.Conv\n\n-- perl/lib/Nix/Manifest.pm:fingerprintPath\n-- NB: references must be sorted\nfingerprint :: Text -> Text -> Integer -> [Text] -> ByteString\nfingerprint storePath narHash narSize references =\n  toS $\n    T.intercalate\n      ";"\n      ["1", storePath, narHash, show narSize, T.intercalate "," references]\n\n-- Useful sinks for streaming nars\nsizeSink :: MonadIO m => ConduitT ByteString o m Integer\nsizeSink = CC.foldM (\\p n -> return (p + fromIntegral (BS.length n))) 0\n\nhashSink :: MonadIO m => ConduitT ByteString o m (Context SHA256)\nhashSink = CC.foldM (\\p n -> return (hashUpdate p n)) hashInit\n\npassthroughSizeSink :: MonadIO m => IORef Integer -> ConduitT ByteString ByteString m ()\npassthroughSizeSink ioref = passthroughSink sizeSink (liftIO . writeIORef ioref)\n\npassthroughHashSinkBase :: MonadIO m => (Digest SHA256 -> ByteString) -> IORef ByteString -> ConduitT ByteString ByteString m ()\npassthroughHashSinkBase f ioref = passthroughSink hashSink (liftIO . writeIORef ioref . f . hashFinalize)\n\npassthroughHashSink :: MonadIO m => IORef ByteString -> ConduitT ByteString ByteString m ()\npassthroughHashSink = passthroughHashSinkBase BA.convert\n\npassthroughHashSinkB16 :: MonadIO m => IORef ByteString -> ConduitT ByteString ByteString m ()\npassthroughHashSinkB16 = passthroughHashSinkBase (convertToBase Base16)\n'