b'{-# LANGUAGE CPP #-}\n\n#ifdef STRICT\nimport Data.Map.Strict as Data.Map hiding (showTree, showTreeWith)\nimport Data.Map.Merge.Strict\n#else\nimport Data.Map.Lazy as Data.Map hiding (showTree, showTreeWith)\nimport Data.Map.Merge.Lazy\n#endif\nimport Data.Map.Internal (Map (..), link2, link, bin)\nimport Data.Map.Internal.Debug (showTree, showTreeWith, balanced)\n\nimport Control.Applicative (Const(Const, getConst), pure, (<$>), (<*>))\nimport Control.Monad.Trans.State.Strict\nimport Control.Monad.Trans.Class\nimport Control.Monad (liftM4, (<=<))\nimport Data.Functor.Identity (Identity(Identity, runIdentity))\nimport Data.Monoid\nimport Data.Maybe hiding (mapMaybe)\nimport qualified Data.Maybe as Maybe (mapMaybe)\nimport Data.Ord\nimport Data.Semigroup (Arg(..))\nimport Data.Function\nimport qualified Data.Foldable as Foldable\n#if MIN_VERSION_base(4,10,0)\nimport qualified Data.Bifoldable as Bifoldable\n#endif\nimport Prelude hiding (lookup, null, map, filter, foldr, foldl, take, drop, splitAt)\nimport qualified Prelude\n\nimport Data.List (nub,sort)\nimport qualified Data.List as List\nimport qualified Data.Set as Set\nimport Test.Tasty\nimport Test.Tasty.HUnit\nimport Test.Tasty.QuickCheck\nimport Test.QuickCheck.Function (apply)\nimport Test.QuickCheck.Poly (A, B)\nimport Control.Arrow (first)\n\ndefault (Int)\n\napply3 :: Fun (a,b,c) d -> a -> b -> c -> d\napply3 f a b c = apply f (a, b, c)\n\napply2 :: Fun (a,b) c -> a -> b -> c\napply2 f a b = apply f (a, b)\n\nmain :: IO ()\nmain = defaultMain $ testGroup "map-properties"\n         [ testCase "ticket4242" test_ticket4242\n         , testCase "index"      test_index\n         , testCase "size"       test_size\n         , testCase "size2"      test_size2\n         , testCase "member"     test_member\n         , testCase "notMember"  test_notMember\n         , testCase "lookup"     test_lookup\n         , testCase "findWithDefault"     test_findWithDefault\n         , testCase "lookupLT"   test_lookupLT\n         , testCase "lookupGT"   test_lookupGT\n         , testCase "lookupLE"   test_lookupLE\n         , testCase "lookupGE"   test_lookupGE\n         , testCase "empty" test_empty\n         , testCase "mempty" test_mempty\n         , testCase "singleton" test_singleton\n         , testCase "insert" test_insert\n         , testCase "insertWith" test_insertWith\n         , testCase "insertWithKey" test_insertWithKey\n         , testCase "insertLookupWithKey" test_insertLookupWithKey\n         , testCase "delete" test_delete\n         , testCase "adjust" test_adjust\n         , testCase "adjustWithKey" test_adjustWithKey\n         , testCase "update" test_update\n         , testCase "updateWithKey" test_updateWithKey\n         , testCase "updateLookupWithKey" test_updateLookupWithKey\n         , testCase "alter" test_alter\n         , testCase "at" test_at\n         , testCase "union" test_union\n         , testCase "mappend" test_mappend\n         , testCase "unionWith" test_unionWith\n         , testCase "unionWithKey" test_unionWithKey\n         , testCase "unions" test_unions\n         , testCase "mconcat" test_mconcat\n         , testCase "unionsWith" test_unionsWith\n         , testCase "difference" test_difference\n         , testCase "differenceWith" test_differenceWith\n         , testCase "differenceWithKey" test_differenceWithKey\n         , testCase "intersection" test_intersection\n         , testCase "intersectionWith" test_intersectionWith\n         , testCase "intersectionWithKey" test_intersectionWithKey\n         , testCase "map" test_map\n         , testCase "mapWithKey" test_mapWithKey\n         , testCase "mapAccum" test_mapAccum\n         , testCase "mapAccumWithKey" test_mapAccumWithKey\n         , testCase "mapAccumRWithKey" test_mapAccumRWithKey\n         , testCase "mapKeys" test_mapKeys\n         , testCase "mapKeysWith" test_mapKeysWith\n         , testCase "mapKeysMonotonic" test_mapKeysMonotonic\n         , testCase "elems" test_elems\n         , testCase "keys" test_keys\n         , testCase "assocs" test_assocs\n         , testCase "keysSet" test_keysSet\n         , testCase "argSet" test_argSet\n         , testCase "fromSet" test_fromSet\n         , testCase "fromArgSet" test_fromArgSet\n         , testCase "toList" test_toList\n         , testCase "fromList" test_fromList\n         , testCase "fromListWith" test_fromListWith\n         , testCase "fromListWithKey" test_fromListWithKey\n         , testCase "toAscList" test_toAscList\n         , testCase "toDescList" test_toDescList\n         , testCase "showTree" test_showTree\n         , testCase "showTree\'" test_showTree\'\n         , testCase "fromAscList" test_fromAscList\n         , testCase "fromAscListWith" test_fromAscListWith\n         , testCase "fromAscListWithKey" test_fromAscListWithKey\n         , testCase "fromDistinctAscList" test_fromDistinctAscList\n         , testCase "fromDistinctDescList" test_fromDistinctDescList\n         , testCase "filter" test_filter\n         , testCase "filterWithKey" test_filteWithKey\n         , testCase "partition" test_partition\n         , testCase "partitionWithKey" test_partitionWithKey\n         , testCase "mapMaybe" test_mapMaybe\n         , testCase "mapMaybeWithKey" test_mapMaybeWithKey\n         , testCase "mapEither" test_mapEither\n         , testCase "mapEitherWithKey" test_mapEitherWithKey\n         , testCase "split" test_split\n         , testCase "splitLookup" test_splitLookup\n         , testCase "isSubmapOfBy" test_isSubmapOfBy\n         , testCase "isSubmapOf" test_isSubmapOf\n         , testCase "isProperSubmapOfBy" test_isProperSubmapOfBy\n         , testCase "isProperSubmapOf" test_isProperSubmapOf\n         , testCase "lookupIndex" test_lookupIndex\n         , testCase "findIndex" test_findIndex\n         , testCase "elemAt" test_elemAt\n         , testCase "updateAt" test_updateAt\n         , testCase "deleteAt" test_deleteAt\n         , testCase "findMin" test_findMin\n         , testCase "findMax" test_findMax\n         , testCase "deleteMin" test_deleteMin\n         , testCase "deleteMax" test_deleteMax\n         , testCase "deleteFindMin" test_deleteFindMin\n         , testCase "deleteFindMax" test_deleteFindMax\n         , testCase "updateMin" test_updateMin\n         , testCase "updateMax" test_updateMax\n         , testCase "updateMinWithKey" test_updateMinWithKey\n         , testCase "updateMaxWithKey" test_updateMaxWithKey\n         , testCase "minView" test_minView\n         , testCase "maxView" test_maxView\n         , testCase "minViewWithKey" test_minViewWithKey\n         , testCase "maxViewWithKey" test_maxViewWithKey\n         , testCase "valid" test_valid\n         , testProperty "valid"                prop_valid\n         , testProperty "insert to singleton"  prop_singleton\n         , testProperty "insert"               prop_insert\n         , testProperty "insert then lookup"   prop_insertLookup\n         , testProperty "insert then delete"   prop_insertDelete\n         , testProperty "insert then delete2"  prop_insertDelete2\n         , testProperty "delete non member"    prop_deleteNonMember\n         , testProperty "deleteMin"            prop_deleteMin\n         , testProperty "deleteMax"            prop_deleteMax\n         , testProperty "split"                prop_split\n         , testProperty "splitRoot"            prop_splitRoot\n         , testProperty "split then link"      prop_link\n         , testProperty "split then link2"     prop_link2\n         , testProperty "union"                prop_union\n         , testProperty "union model"          prop_unionModel\n         , testProperty "union singleton"      prop_unionSingleton\n         , testProperty "union associative"    prop_unionAssoc\n         , testProperty "union+unionWith"      prop_unionWith\n         , testProperty "unionWith"            prop_unionWith2\n         , testProperty "union sum"            prop_unionSum\n         , testProperty "difference"           prop_difference\n         , testProperty "difference model"     prop_differenceModel\n         , testProperty "withoutKeys"          prop_withoutKeys\n         , testProperty "intersection"         prop_intersection\n         , testProperty "restrictKeys"         prop_restrictKeys\n         , testProperty "intersection model"   prop_intersectionModel\n         , testProperty "intersectionWith"     prop_intersectionWith\n         , testProperty "intersectionWithModel" prop_intersectionWithModel\n         , testProperty "intersectionWithKey"  prop_intersectionWithKey\n         , testProperty "intersectionWithKeyModel" prop_intersectionWithKeyModel\n         , testProperty "disjoint"             prop_disjoint\n         , testProperty "compose"              prop_compose\n         , testProperty "differenceMerge"   prop_differenceMerge\n         , testProperty "unionWithKeyMerge"   prop_unionWithKeyMerge\n         , testProperty "mergeWithKey model"   prop_mergeWithKeyModel\n         , testProperty "mergeA effects"       prop_mergeA_effects\n         , testProperty "fromAscList"          prop_ordered\n         , testProperty "fromDescList"         prop_rev_ordered\n         , testProperty "fromDistinctDescList" prop_fromDistinctDescList\n         , testProperty "fromList then toList" prop_list\n         , testProperty "toDescList"           prop_descList\n         , testProperty "toAscList+toDescList" prop_ascDescList\n         , testProperty "fromList"             prop_fromList\n         , testProperty "alter"                prop_alter\n         , testProperty "alterF/alter"         prop_alterF_alter\n         , testProperty "alterF/alter/noRULES" prop_alterF_alter_noRULES\n         , testProperty "alterF/lookup"        prop_alterF_lookup\n         , testProperty "alterF/lookup/noRULES" prop_alterF_lookup_noRULES\n         , testProperty "index"                prop_index\n         , testProperty "null"                 prop_null\n         , testProperty "member"               prop_member\n         , testProperty "notmember"            prop_notmember\n         , testProperty "lookup"               prop_lookup\n         , testProperty "find"                 prop_find\n         , testProperty "findWithDefault"      prop_findWithDefault\n         , testProperty "lookupLT"             prop_lookupLT\n         , testProperty "lookupGT"             prop_lookupGT\n         , testProperty "lookupLE"             prop_lookupLE\n         , testProperty "lookupGE"             prop_lookupGE\n         , testProperty "findIndex"            prop_findIndex\n         , testProperty "lookupIndex"          prop_lookupIndex\n         , testProperty "findMin"              prop_findMin\n         , testProperty "findMax"              prop_findMax\n         , testProperty "deleteMin"            prop_deleteMinModel\n         , testProperty "deleteMax"            prop_deleteMaxModel\n         , testProperty "filter"               prop_filter\n         , testProperty "partition"            prop_partition\n         , testProperty "map"                  prop_map\n         , testProperty "fmap"                 prop_fmap\n         , testProperty "mapkeys"              prop_mapkeys\n         , testProperty "split"                prop_splitModel\n         , testProperty "fold"                 prop_fold\n         , testProperty "foldMap"              prop_foldMap\n         , testProperty "foldMapWithKey"       prop_foldMapWithKey\n         , testProperty "foldr"                prop_foldr\n         , testProperty "foldrWithKey"         prop_foldrWithKey\n         , testProperty "foldr\'"               prop_foldr\'\n         , testProperty "foldrWithKey\'"        prop_foldrWithKey\'\n         , testProperty "foldl"                prop_foldl\n         , testProperty "foldlWithKey"         prop_foldlWithKey\n         , testProperty "foldl\'"               prop_foldl\'\n         , testProperty "foldlWithKey\'"        prop_foldlWithKey\'\n#if MIN_VERSION_base(4,10,0)\n         , testProperty "bifold"               prop_bifold\n         , testProperty "bifoldMap"            prop_bifoldMap\n         , testProperty "bifoldr"              prop_bifoldr\n         , testProperty "bifoldr\'"             prop_bifoldr\'\n         , testProperty "bifoldl"              prop_bifoldl\n         , testProperty "bifoldl\'"             prop_bifoldl\'\n#endif\n         , testProperty "keysSet"              prop_keysSet\n         , testProperty "argSet"               prop_argSet\n         , testProperty "fromSet"              prop_fromSet\n         , testProperty "fromArgSet"           prop_fromArgSet\n         , testProperty "takeWhileAntitone"    prop_takeWhileAntitone\n         , testProperty "dropWhileAntitone"    prop_dropWhileAntitone\n         , testProperty "spanAntitone"         prop_spanAntitone\n         , testProperty "take"                 prop_take\n         , testProperty "drop"                 prop_drop\n         , testProperty "splitAt"              prop_splitAt\n         , testProperty "lookupMin"            prop_lookupMin\n         , testProperty "lookupMax"            prop_lookupMax\n         ]\n\n{--------------------------------------------------------------------\n  Arbitrary, reasonably balanced trees\n--------------------------------------------------------------------}\n\n-- | The IsInt class lets us constrain a type variable to be Int in an entirely\n-- standard way. The constraint @ IsInt a @ is essentially equivalent to the\n-- GHC-only constraint @ a ~ Int @, but @ IsInt @ requires manual intervention\n-- to use. If ~ is ever standardized, we should certainly use it instead.\n-- Earlier versions used an Enum constraint, but this is confusing because\n-- not all Enum instances will work properly for the Arbitrary instance here.\nclass (Show a, Read a, Integral a, Arbitrary a) => IsInt a where\n  fromIntF :: f Int -> f a\n\ninstance IsInt Int where\n  fromIntF = id\n\n-- | Convert an Int to any instance of IsInt\nfromInt :: IsInt a => Int -> a\nfromInt = runIdentity . fromIntF . Identity\n\n{- We don\'t actually need this, but we can add it if we ever do\ntoIntF :: IsInt a => g a -> g Int\ntoIntF = unf . fromIntF . F $ id\n\nnewtype F g a b = F {unf :: g b -> a}\n\ntoInt :: IsInt a => a -> Int\ntoInt = runIdentity . toIntF . Identity -}\n\n\n-- How much the minimum key of an arbitrary map should vary\npositionFactor :: Int\npositionFactor = 1\n\n-- How much the gap between consecutive keys in an arbitrary\n-- map should vary\ngapRange :: Int\ngapRange = 5\n\ninstance (IsInt k, Arbitrary v) => Arbitrary (Map k v) where\n  arbitrary = sized (\\sz0 -> do\n        sz <- choose (0, sz0)\n        middle <- choose (-positionFactor * (sz + 1), positionFactor * (sz + 1))\n        let shift = (sz * (gapRange) + 1) `quot` 2\n            start = middle - shift\n        t <- evalStateT (mkArb step sz) start\n        if valid t then pure t else error "Test generated invalid tree!")\n    where\n      step = do\n        i <- get\n        diff <- lift $ choose (1, gapRange)\n        let i\' = i + diff\n        put i\'\n        pure (fromInt i\')\n\nclass Monad m => MonadGen m where\n  liftGen :: Gen a -> m a\ninstance MonadGen Gen where\n  liftGen = id\ninstance MonadGen m => MonadGen (StateT s m) where\n  liftGen = lift . liftGen\n\n-- | Given an action that produces successively larger keys and\n-- a size, produce a map of arbitrary shape with exactly that size.\nmkArb :: (MonadGen m, Arbitrary v) => m k -> Int -> m (Map k v)\nmkArb step n\n  | n <= 0 = return Tip\n  | n == 1 = do\n     k <- step\n     v <- liftGen arbitrary\n     return (singleton k v)\n  | n == 2 = do\n     dir <- liftGen arbitrary\n     p <- step\n     q <- step\n     vOuter <- liftGen arbitrary\n     vInner <- liftGen arbitrary\n     if dir\n       then return (Bin 2 q vOuter (singleton p vInner) Tip)\n       else return (Bin 2 p vOuter Tip (singleton q vInner))\n  | otherwise = do\n      -- This assumes a balance factor of delta = 3\n      let upper = (3*(n - 1)) `quot` 4\n      let lower = (n + 2) `quot` 4\n      ln <- liftGen $ choose (lower, upper)\n      let rn = n - ln - 1\n      liftM4 (\\lt x v rt -> Bin n x v lt rt) (mkArb step ln) step (liftGen arbitrary) (mkArb step rn)\n\n-- A type with a peculiar Eq instance designed to make sure keys\n-- come from where they\'re supposed to.\ndata OddEq a = OddEq a Bool deriving (Show)\ngetOddEq :: OddEq a -> (a, Bool)\ngetOddEq (OddEq a b) = (a, b)\ninstance Arbitrary a => Arbitrary (OddEq a) where\n  arbitrary = OddEq <$> arbitrary <*> arbitrary\ninstance Eq a => Eq (OddEq a) where\n  OddEq x _ == OddEq y _ = x == y\ninstance Ord a => Ord (OddEq a) where\n  OddEq x _ `compare` OddEq y _ = x `compare` y\n\n------------------------------------------------------------------------\n\ntype UMap = Map Int ()\ntype IMap = Map Int Int\ntype SMap = Map Int String\n\n----------------------------------------------------------------\n-- Unit tests\n----------------------------------------------------------------\n\ntest_ticket4242 :: Assertion\ntest_ticket4242 = (valid $ deleteMin $ deleteMin $ fromList [ (i, ()) | i <- [0,2,5,1,6,4,8,9,7,11,10,3] :: [Int] ]) @?= True\n\n----------------------------------------------------------------\n-- Operators\n\ntest_index :: Assertion\ntest_index = fromList [(5,\'a\'), (3,\'b\')] ! 5 @?= \'a\'\n\n----------------------------------------------------------------\n-- Query\n\ntest_size :: Assertion\ntest_size = do\n    null (empty)           @?= True\n    null (singleton 1 \'a\') @?= False\n\ntest_size2 :: Assertion\ntest_size2 = do\n    size empty                                   @?= 0\n    size (singleton 1 \'a\')                       @?= 1\n    size (fromList([(1,\'a\'), (2,\'c\'), (3,\'b\')])) @?= 3\n\ntest_member :: Assertion\ntest_member = do\n    member 5 (fromList [(5,\'a\'), (3,\'b\')]) @?= True\n    member 1 (fromList [(5,\'a\'), (3,\'b\')]) @?= False\n\ntest_notMember :: Assertion\ntest_notMember = do\n    notMember 5 (fromList [(5,\'a\'), (3,\'b\')]) @?= False\n    notMember 1 (fromList [(5,\'a\'), (3,\'b\')]) @?= True\n\ntest_lookup :: Assertion\ntest_lookup = do\n    employeeCurrency "John" @?= Just "Euro"\n    employeeCurrency "Pete" @?= Nothing\n  where\n    employeeDept = fromList([("John","Sales"), ("Bob","IT")])\n    deptCountry = fromList([("IT","USA"), ("Sales","France")])\n    countryCurrency = fromList([("USA", "Dollar"), ("France", "Euro")])\n    employeeCurrency :: String -> Maybe String\n    employeeCurrency name = do\n        dept <- lookup name employeeDept\n        country <- lookup dept deptCountry\n        lookup country countryCurrency\n\ntest_findWithDefault :: Assertion\ntest_findWithDefault = do\n    findWithDefault \'x\' 1 (fromList [(5,\'a\'), (3,\'b\')]) @?= \'x\'\n    findWithDefault \'x\' 5 (fromList [(5,\'a\'), (3,\'b\')]) @?= \'a\'\n\ntest_lookupLT :: Assertion\ntest_lookupLT = do\n    lookupLT 3 (fromList [(3,\'a\'), (5,\'b\')]) @?= Nothing\n    lookupLT 4 (fromList [(3,\'a\'), (5,\'b\')]) @?= Just (3, \'a\')\n\ntest_lookupGT :: Assertion\ntest_lookupGT = do\n    lookupGT 4 (fromList [(3,\'a\'), (5,\'b\')]) @?= Just (5, \'b\')\n    lookupGT 5 (fromList [(3,\'a\'), (5,\'b\')]) @?= Nothing\n\ntest_lookupLE :: Assertion\ntest_lookupLE = do\n    lookupLE 2 (fromList [(3,\'a\'), (5,\'b\')]) @?= Nothing\n    lookupLE 4 (fromList [(3,\'a\'), (5,\'b\')]) @?= Just (3, \'a\')\n    lookupLE 5 (fromList [(3,\'a\'), (5,\'b\')]) @?= Just (5, \'b\')\n\ntest_lookupGE :: Assertion\ntest_lookupGE = do\n    lookupGE 3 (fromList [(3,\'a\'), (5,\'b\')]) @?= Just (3, \'a\')\n    lookupGE 4 (fromList [(3,\'a\'), (5,\'b\')]) @?= Just (5, \'b\')\n    lookupGE 6 (fromList [(3,\'a\'), (5,\'b\')]) @?= Nothing\n\n----------------------------------------------------------------\n-- Construction\n\ntest_empty :: Assertion\ntest_empty = do\n    (empty :: UMap)  @?= fromList []\n    size empty @?= 0\n\ntest_mempty :: Assertion\ntest_mempty = do\n    (mempty :: UMap)  @?= fromList []\n    size (mempty :: UMap) @?= 0\n\ntest_singleton :: Assertion\ntest_singleton = do\n    singleton 1 \'a\'        @?= fromList [(1, \'a\')]\n    size (singleton 1 \'a\') @?= 1\n\ntest_insert :: Assertion\ntest_insert = do\n    insert 5 \'x\' (fromList [(5,\'a\'), (3,\'b\')]) @?= fromList [(3, \'b\'), (5, \'x\')]\n    insert 7 \'x\' (fromList [(5,\'a\'), (3,\'b\')]) @?= fromList [(3, \'b\'), (5, \'a\'), (7, \'x\')]\n    insert 5 \'x\' empty                         @?= singleton 5 \'x\'\n\ntest_insertWith :: Assertion\ntest_insertWith = do\n    insertWith (++) 5 "xxx" (fromList [(5,"a"), (3,"b")]) @?= fromList [(3, "b"), (5, "xxxa")]\n    insertWith (++) 7 "xxx" (fromList [(5,"a"), (3,"b")]) @?= fromList [(3, "b"), (5, "a"), (7, "xxx")]\n    insertWith (++) 5 "xxx" empty                         @?= singleton 5 "xxx"\n\ntest_insertWithKey :: Assertion\ntest_insertWithKey = do\n    insertWithKey f 5 "xxx" (fromList [(5,"a"), (3,"b")]) @?= fromList [(3, "b"), (5, "5:xxx|a")]\n    insertWithKey f 7 "xxx" (fromList [(5,"a"), (3,"b")]) @?= fromList [(3, "b"), (5, "a"), (7, "xxx")]\n    insertWithKey f 5 "xxx" empty                         @?= singleton 5 "xxx"\n  where\n    f key new_value old_value = (show key) ++ ":" ++ new_value ++ "|" ++ old_value\n\ntest_insertLookupWithKey :: Assertion\ntest_insertLookupWithKey = do\n    insertLookupWithKey f 5 "xxx" (fromList [(5,"a"), (3,"b")]) @?= (Just "a", fromList [(3, "b"), (5, "5:xxx|a")])\n    insertLookupWithKey f 2 "xxx" (fromList [(5,"a"), (3,"b")]) @?= (Nothing,fromList [(2,"xxx"),(3,"b"),(5,"a")])\n    insertLookupWithKey f 7 "xxx" (fromList [(5,"a"), (3,"b")]) @?= (Nothing,  fromList [(3, "b"), (5, "a"), (7, "xxx")])\n    insertLookupWithKey f 5 "xxx" empty                         @?= (Nothing,  singleton 5 "xxx")\n  where\n    f key new_value old_value = (show key) ++ ":" ++ new_value ++ "|" ++ old_value\n\n----------------------------------------------------------------\n-- Delete/Update\n\ntest_delete :: Assertion\ntest_delete = do\n    delete 5 (fromList [(5,"a"), (3,"b")]) @?= singleton 3 "b"\n    delete 7 (fromList [(5,"a"), (3,"b")]) @?= fromList [(3, "b"), (5, "a")]\n    delete 5 empty                         @?= (empty :: IMap)\n\ntest_adjust :: Assertion\ntest_adjust = do\n    adjust ("new " ++) 5 (fromList [(5,"a"), (3,"b")]) @?= fromList [(3, "b"), (5, "new a")]\n    adjust ("new " ++) 7 (fromList [(5,"a"), (3,"b")]) @?= fromList [(3, "b"), (5, "a")]\n    adjust ("new " ++) 7 empty                         @?= empty\n\ntest_adjustWithKey :: Assertion\ntest_adjustWithKey = do\n    adjustWithKey f 5 (fromList [(5,"a"), (3,"b")]) @?= fromList [(3, "b"), (5, "5:new a")]\n    adjustWithKey f 7 (fromList [(5,"a"), (3,"b")]) @?= fromList [(3, "b"), (5, "a")]\n    adjustWithKey f 7 empty                         @?= empty\n  where\n    f key x = (show key) ++ ":new " ++ x\n\ntest_update :: Assertion\ntest_update = do\n    update f 5 (fromList [(5,"a"), (3,"b")]) @?= fromList [(3, "b"), (5, "new a")]\n    update f 7 (fromList [(5,"a"), (3,"b")]) @?= fromList [(3, "b"), (5, "a")]\n    update f 3 (fromList [(5,"a"), (3,"b")]) @?= singleton 5 "a"\n  where\n    f x = if x == "a" then Just "new a" else Nothing\n\ntest_updateWithKey :: Assertion\ntest_updateWithKey = do\n    updateWithKey f 5 (fromList [(5,"a"), (3,"b")]) @?= fromList [(3, "b"), (5, "5:new a")]\n    updateWithKey f 7 (fromList [(5,"a"), (3,"b")]) @?= fromList [(3, "b"), (5, "a")]\n    updateWithKey f 3 (fromList [(5,"a"), (3,"b")]) @?= singleton 5 "a"\n where\n     f k x = if x == "a" then Just ((show k) ++ ":new a") else Nothing\n\ntest_updateLookupWithKey :: Assertion\ntest_updateLookupWithKey = do\n    updateLookupWithKey f 5 (fromList [(5,"a"), (3,"b")]) @?= (Just "5:new a", fromList [(3, "b"), (5, "5:new a")])\n    updateLookupWithKey f 7 (fromList [(5,"a"), (3,"b")]) @?= (Nothing,  fromList [(3, "b"), (5, "a")])\n    updateLookupWithKey f 3 (fromList [(5,"a"), (3,"b")]) @?= (Just "b", singleton 5 "a")\n  where\n    f k x = if x == "a" then Just ((show k) ++ ":new a") else Nothing\n\ntest_alter :: Assertion\ntest_alter = do\n    alter f 7 (fromList [(5,"a"), (3,"b")]) @?= fromList [(3, "b"), (5, "a")]\n    alter f 5 (fromList [(5,"a"), (3,"b")]) @?= singleton 3 "b"\n    alter g 7 (fromList [(5,"a"), (3,"b")]) @?= fromList [(3, "b"), (5, "a"), (7, "c")]\n    alter g 5 (fromList [(5,"a"), (3,"b")]) @?= fromList [(3, "b"), (5, "c")]\n  where\n    f _ = Nothing\n    g _ = Just "c"\n\ntest_at :: Assertion\ntest_at = do\n    employeeCurrency "John" @?= Just "Euro"\n    employeeCurrency "Pete" @?= Nothing\n    atAlter f 7 (fromList [(5,"a"), (3,"b")]) @?= fromList [(3, "b"), (5, "a")]\n    atAlter f 5 (fromList [(5,"a"), (3,"b")]) @?= singleton 3 "b"\n    atAlter g 7 (fromList [(5,"a"), (3,"b")]) @?= fromList [(3, "b"), (5, "a"), (7, "c")]\n    atAlter g 5 (fromList [(5,"a"), (3,"b")]) @?= fromList [(3, "b"), (5, "c")]\n  where\n    f _ = Nothing\n    g _ = Just "c"\n    employeeDept = fromList([("John","Sales"), ("Bob","IT")])\n    deptCountry = fromList([("IT","USA"), ("Sales","France")])\n    countryCurrency = fromList([("USA", "Dollar"), ("France", "Euro")])\n    employeeCurrency :: String -> Maybe String\n    employeeCurrency name = do\n        dept <- atLookup name employeeDept\n        country <- atLookup dept deptCountry\n        atLookup country countryCurrency\n\n-- This version of atAlter will rewrite to alterFIdentity\n-- if the rules fire.\natAlter :: Ord k => (Maybe a -> Maybe a) -> k -> Map k a -> Map k a\natAlter f k m = runIdentity (alterF (pure . f) k m)\n\n-- A version of atAlter that uses a private copy of Identity\n-- to ensure that the adjustF/Identity rules don\'t fire and\n-- we use the basic implementation.\natAlterNoRULES :: Ord k => (Maybe a -> Maybe a) -> k -> Map k a -> Map k a\natAlterNoRULES f k m = runIdent (alterF (Ident . f) k m)\n\nnewtype Ident a = Ident { runIdent :: a }\ninstance Functor Ident where\n  fmap f (Ident a) = Ident (f a)\n\natLookup :: Ord k => k -> Map k a -> Maybe a\natLookup k m = getConst (alterF Const k m)\n\natLookupNoRULES :: Ord k => k -> Map k a -> Maybe a\natLookupNoRULES k m = getConsty (alterF Consty k m)\n\nnewtype Consty a b = Consty { getConsty :: a}\ninstance Functor (Consty a) where\n  fmap _ (Consty a) = Consty a\n\n----------------------------------------------------------------\n-- Combine\n\ntest_union :: Assertion\ntest_union = union (fromList [(5, "a"), (3, "b")]) (fromList [(5, "A"), (7, "C")]) @?= fromList [(3, "b"), (5, "a"), (7, "C")]\n\ntest_mappend :: Assertion\ntest_mappend = mappend (fromList [(5, "a"), (3, "b")]) (fromList [(5, "A"), (7, "C")]) @?= fromList [(3, "b"), (5, "a"), (7, "C")]\n\ntest_unionWith :: Assertion\ntest_unionWith = unionWith (++) (fromList [(5, "a"), (3, "b")]) (fromList [(5, "A"), (7, "C")]) @?= fromList [(3, "b"), (5, "aA"), (7, "C")]\n\ntest_unionWithKey :: Assertion\ntest_unionWithKey = unionWithKey f (fromList [(5, "a"), (3, "b")]) (fromList [(5, "A"), (7, "C")]) @?= fromList [(3, "b"), (5, "5:a|A"), (7, "C")]\n  where\n    f key left_value right_value = (show key) ++ ":" ++ left_value ++ "|" ++ right_value\n\ntest_unions :: Assertion\ntest_unions = do\n    unions [(fromList [(5, "a"), (3, "b")]), (fromList [(5, "A"), (7, "C")]), (fromList [(5, "A3"), (3, "B3")])]\n        @?= fromList [(3, "b"), (5, "a"), (7, "C")]\n    unions [(fromList [(5, "A3"), (3, "B3")]), (fromList [(5, "A"), (7, "C")]), (fromList [(5, "a"), (3, "b")])]\n        @?= fromList [(3, "B3"), (5, "A3"), (7, "C")]\n\ntest_mconcat :: Assertion\ntest_mconcat = do\n    mconcat [(fromList [(5, "a"), (3, "b")]), (fromList [(5, "A"), (7, "C")]), (fromList [(5, "A3"), (3, "B3")])]\n        @?= fromList [(3, "b"), (5, "a"), (7, "C")]\n    mconcat [(fromList [(5, "A3"), (3, "B3")]), (fromList [(5, "A"), (7, "C")]), (fromList [(5, "a"), (3, "b")])]\n        @?= fromList [(3, "B3"), (5, "A3"), (7, "C")]\n\ntest_unionsWith :: Assertion\ntest_unionsWith = unionsWith (++) [(fromList [(5, "a"), (3, "b")]), (fromList [(5, "A"), (7, "C")]), (fromList [(5, "A3"), (3, "B3")])]\n     @?= fromList [(3, "bB3"), (5, "aAA3"), (7, "C")]\n\ntest_difference :: Assertion\ntest_difference = difference (fromList [(5, "a"), (3, "b")]) (fromList [(5, "A"), (7, "C")]) @?= singleton 3 "b"\n\ntest_differenceWith :: Assertion\ntest_differenceWith = differenceWith f (fromList [(5, "a"), (3, "b")]) (fromList [(5, "A"), (3, "B"), (7, "C")])\n     @?= singleton 3 "b:B"\n where\n   f al ar = if al== "b" then Just (al ++ ":" ++ ar) else Nothing\n\ntest_differenceWithKey :: Assertion\ntest_differenceWithKey = differenceWithKey f (fromList [(5, "a"), (3, "b")]) (fromList [(5, "A"), (3, "B"), (10, "C")])\n     @?= singleton 3 "3:b|B"\n  where\n    f k al ar = if al == "b" then Just ((show k) ++ ":" ++ al ++ "|" ++ ar) else Nothing\n\ntest_intersection :: Assertion\ntest_intersection = intersection (fromList [(5, "a"), (3, "b")]) (fromList [(5, "A"), (7, "C")]) @?= singleton 5 "a"\n\n\ntest_intersectionWith :: Assertion\ntest_intersectionWith = intersectionWith (++) (fromList [(5, "a"), (3, "b")]) (fromList [(5, "A"), (7, "C")]) @?= singleton 5 "aA"\n\ntest_intersectionWithKey :: Assertion\ntest_intersectionWithKey = intersectionWithKey f (fromList [(5, "a"), (3, "b")]) (fromList [(5, "A"), (7, "C")]) @?= singleton 5 "5:a|A"\n  where\n    f k al ar = (show k) ++ ":" ++ al ++ "|" ++ ar\n\n----------------------------------------------------------------\n-- Traversal\n\ntest_map :: Assertion\ntest_map = map (++ "x") (fromList [(5,"a"), (3,"b")]) @?= fromList [(3, "bx"), (5, "ax")]\n\ntest_mapWithKey :: Assertion\ntest_mapWithKey = mapWithKey f (fromList [(5,"a"), (3,"b")]) @?= fromList [(3, "3:b"), (5, "5:a")]\n  where\n    f key x = (show key) ++ ":" ++ x\n\ntest_mapAccum :: Assertion\ntest_mapAccum = mapAccum f "Everything: " (fromList [(5,"a"), (3,"b")]) @?= ("Everything: ba", fromList [(3, "bX"), (5, "aX")])\n  where\n    f a b = (a ++ b, b ++ "X")\n\ntest_mapAccumWithKey :: Assertion\ntest_mapAccumWithKey = mapAccumWithKey f "Everything:" (fromList [(5,"a"), (3,"b")]) @?= ("Everything: 3-b 5-a", fromList [(3, "bX"), (5, "aX")])\n  where\n    f a k b = (a ++ " " ++ (show k) ++ "-" ++ b, b ++ "X")\n\ntest_mapAccumRWithKey :: Assertion\ntest_mapAccumRWithKey = mapAccumRWithKey f "Everything:" (fromList [(5,"a"), (3,"b")]) @?= ("Everything: 5-a 3-b", fromList [(3, "bX"), (5, "aX")])\n  where\n    f a k b = (a ++ " " ++ (show k) ++ "-" ++ b, b ++ "X")\n\ntest_mapKeys :: Assertion\ntest_mapKeys = do\n    mapKeys (+ 1) (fromList [(5,"a"), (3,"b")])                        @?= fromList [(4, "b"), (6, "a")]\n    mapKeys (\\ _ -> 1) (fromList [(1,"b"), (2,"a"), (3,"d"), (4,"c")]) @?= singleton 1 "c"\n    mapKeys (\\ _ -> 3) (fromList [(1,"b"), (2,"a"), (3,"d"), (4,"c")]) @?= singleton 3 "c"\n\ntest_mapKeysWith :: Assertion\ntest_mapKeysWith = do\n    mapKeysWith (++) (\\ _ -> 1) (fromList [(1,"b"), (2,"a"), (3,"d"), (4,"c")]) @?= singleton 1 "cdab"\n    mapKeysWith (++) (\\ _ -> 3) (fromList [(1,"b"), (2,"a"), (3,"d"), (4,"c")]) @?= singleton 3 "cdab"\n\ntest_mapKeysMonotonic :: Assertion\ntest_mapKeysMonotonic = do\n    mapKeysMonotonic (+ 1) (fromList [(5,"a"), (3,"b")])          @?= fromList [(4, "b"), (6, "a")]\n    mapKeysMonotonic (\\ k -> k * 2) (fromList [(5,"a"), (3,"b")]) @?= fromList [(6, "b"), (10, "a")]\n    valid (mapKeysMonotonic (\\ k -> k * 2) (fromList [(5,"a"), (3,"b")])) @?= True\n    valid (mapKeysMonotonic (\\ _ -> 1)     (fromList [(5,"a"), (3,"b")])) @?= False\n\n----------------------------------------------------------------\n-- Conversion\n\ntest_elems :: Assertion\ntest_elems = do\n    elems (fromList [(5,"a"), (3,"b")]) @?= ["b","a"]\n    elems (empty :: UMap) @?= []\n\ntest_keys :: Assertion\ntest_keys = do\n    keys (fromList [(5,"a"), (3,"b")]) @?= [3,5]\n    keys (empty :: UMap) @?= []\n\ntest_assocs :: Assertion\ntest_assocs = do\n    assocs (fromList [(5,"a"), (3,"b")]) @?= [(3,"b"), (5,"a")]\n    assocs (empty :: UMap) @?= []\n\ntest_keysSet :: Assertion\ntest_keysSet = do\n    keysSet (fromList [(5,"a"), (3,"b")]) @?= Set.fromList [3,5]\n    keysSet (empty :: UMap) @?= Set.empty\n\ntest_argSet :: Assertion\ntest_argSet = do\n    argSet (fromList [(5,"a"), (3,"b")]) @?= Set.fromList [Arg 3 "b",Arg 5 "a"]\n    argSet (empty :: UMap) @?= Set.empty\n\ntest_fromSet :: Assertion\ntest_fromSet = do\n   fromSet (\\k -> replicate k \'a\') (Set.fromList [3, 5]) @?= fromList [(5,"aaaaa"), (3,"aaa")]\n   fromSet undefined Set.empty @?= (empty :: IMap)\n\ntest_fromArgSet :: Assertion\ntest_fromArgSet = do\n   fromArgSet (Set.fromList [Arg 3 "aaa", Arg 5 "aaaaa"]) @?= fromList [(5,"aaaaa"), (3,"aaa")]\n   fromArgSet Set.empty @?= (empty :: IMap)\n\n----------------------------------------------------------------\n-- Lists\n\ntest_toList :: Assertion\ntest_toList = do\n    toList (fromList [(5,"a"), (3,"b")]) @?= [(3,"b"), (5,"a")]\n    toList (empty :: SMap) @?= []\n\ntest_fromList :: Assertion\ntest_fromList = do\n    fromList [] @?= (empty :: SMap)\n    fromList [(5,"a"), (3,"b"), (5, "c")] @?= fromList [(5,"c"), (3,"b")]\n    fromList [(5,"c"), (3,"b"), (5, "a")] @?= fromList [(5,"a"), (3,"b")]\n\ntest_fromListWith :: Assertion\ntest_fromListWith = do\n    fromListWith (++) [(5,"a"), (5,"b"), (3,"b"), (3,"a"), (5,"a")] @?= fromList [(3, "ab"), (5, "aba")]\n    fromListWith (++) [] @?= (empty :: SMap)\n\ntest_fromListWithKey :: Assertion\ntest_fromListWithKey = do\n    fromListWithKey f [(5,"a"), (5,"b"), (3,"b"), (3,"a"), (5,"a")] @?= fromList [(3, "3ab"), (5, "5a5ba")]\n    fromListWithKey f [] @?= (empty :: SMap)\n  where\n    f k a1 a2 = (show k) ++ a1 ++ a2\n\n----------------------------------------------------------------\n-- Ordered lists\n\ntest_toAscList :: Assertion\ntest_toAscList = toAscList (fromList [(5,"a"), (3,"b")]) @?= [(3,"b"), (5,"a")]\n\ntest_toDescList :: Assertion\ntest_toDescList = toDescList (fromList [(5,"a"), (3,"b")]) @?= [(5,"a"), (3,"b")]\n\ntest_showTree :: Assertion\ntest_showTree =\n       (let t = fromDistinctAscList [(x,()) | x <- [1..5]]\n        in showTree t) @?= "4:=()\\n+--2:=()\\n|  +--1:=()\\n|  +--3:=()\\n+--5:=()\\n"\n\ntest_showTree\' :: Assertion\ntest_showTree\' =\n       (let t = fromDistinctAscList [(x,()) | x <- [1..5]]\n        in s t ) @?= "+--5:=()\\n|\\n4:=()\\n|\\n|  +--3:=()\\n|  |\\n+--2:=()\\n   |\\n   +--1:=()\\n"\n   where\n    showElem k x  = show k ++ ":=" ++ show x\n\n    s = showTreeWith showElem False True\n\n\ntest_fromAscList :: Assertion\ntest_fromAscList = do\n    fromAscList [(3,"b"), (5,"a")]          @?= fromList [(3, "b"), (5, "a")]\n    fromAscList [(3,"b"), (5,"a"), (5,"b")] @?= fromList [(3, "b"), (5, "b")]\n    valid (fromAscList [(3,"b"), (5,"a"), (5,"b")]) @?= True\n    valid (fromAscList [(5,"a"), (3,"b"), (5,"b")]) @?= False\n\ntest_fromAscListWith :: Assertion\ntest_fromAscListWith = do\n    fromAscListWith (++) [(3,"b"), (5,"a"), (5,"b")] @?= fromList [(3, "b"), (5, "ba")]\n    valid (fromAscListWith (++) [(3,"b"), (5,"a"), (5,"b")]) @?= True\n    valid (fromAscListWith (++) [(5,"a"), (3,"b"), (5,"b")]) @?= False\n\ntest_fromAscListWithKey :: Assertion\ntest_fromAscListWithKey = do\n    fromAscListWithKey f [(3,"b"), (5,"a"), (5,"b"), (5,"b")] @?= fromList [(3, "b"), (5, "5:b5:ba")]\n    valid (fromAscListWithKey f [(3,"b"), (5,"a"), (5,"b"), (5,"b")]) @?= True\n    valid (fromAscListWithKey f [(5,"a"), (3,"b"), (5,"b"), (5,"b")]) @?= False\n  where\n    f k a1 a2 = (show k) ++ ":" ++ a1 ++ a2\n\ntest_fromDistinctAscList :: Assertion\ntest_fromDistinctAscList = do\n    fromDistinctAscList [(3,"b"), (5,"a")] @?= fromList [(3, "b"), (5, "a")]\n    valid (fromDistinctAscList [(3,"b"), (5,"a")])          @?= True\n    valid (fromDistinctAscList [(3,"b"), (5,"a"), (5,"b")]) @?= False\n\ntest_fromDistinctDescList :: Assertion\ntest_fromDistinctDescList = do\n    fromDistinctDescList [(5,"a"), (3,"b")] @?= fromList [(3, "b"), (5, "a")]\n    valid (fromDistinctDescList [(5,"a"), (3,"b")])          @?= True\n    valid (fromDistinctDescList [(3,"b"), (5,"a"), (5,"b")]) @?= False\n\n----------------------------------------------------------------\n-- Filter\n\ntest_filter :: Assertion\ntest_filter = do\n    filter (> "a") (fromList [(5,"a"), (3,"b")]) @?= singleton 3 "b"\n    filter (> "x") (fromList [(5,"a"), (3,"b")]) @?= empty\n    filter (< "a") (fromList [(5,"a"), (3,"b")]) @?= empty\n\ntest_filteWithKey :: Assertion\ntest_filteWithKey = filterWithKey (\\k _ -> k > 4) (fromList [(5,"a"), (3,"b")]) @?= singleton 5 "a"\n\ntest_partition :: Assertion\ntest_partition = do\n    partition (> "a") (fromList [(5,"a"), (3,"b")]) @?= (singleton 3 "b", singleton 5 "a")\n    partition (< "x") (fromList [(5,"a"), (3,"b")]) @?= (fromList [(3, "b"), (5, "a")], empty)\n    partition (> "x") (fromList [(5,"a"), (3,"b")]) @?= (empty, fromList [(3, "b"), (5, "a")])\n\ntest_partitionWithKey :: Assertion\ntest_partitionWithKey = do\n    partitionWithKey (\\ k _ -> k > 3) (fromList [(5,"a"), (3,"b")]) @?= (singleton 5 "a", singleton 3 "b")\n    partitionWithKey (\\ k _ -> k < 7) (fromList [(5,"a"), (3,"b")]) @?= (fromList [(3, "b"), (5, "a")], empty)\n    partitionWithKey (\\ k _ -> k > 7) (fromList [(5,"a"), (3,"b")]) @?= (empty, fromList [(3, "b"), (5, "a")])\n\ntest_mapMaybe :: Assertion\ntest_mapMaybe = mapMaybe f (fromList [(5,"a"), (3,"b")]) @?= singleton 5 "new a"\n  where\n    f x = if x == "a" then Just "new a" else Nothing\n\ntest_mapMaybeWithKey :: Assertion\ntest_mapMaybeWithKey = mapMaybeWithKey f (fromList [(5,"a"), (3,"b")]) @?= singleton 3 "key : 3"\n  where\n    f k _ = if k < 5 then Just ("key : " ++ (show k)) else Nothing\n\ntest_mapEither :: Assertion\ntest_mapEither = do\n    mapEither f (fromList [(5,"a"), (3,"b"), (1,"x"), (7,"z")])\n        @?= (fromList [(3,"b"), (5,"a")], fromList [(1,"x"), (7,"z")])\n    mapEither (\\ a -> Right a) (fromList [(5,"a"), (3,"b"), (1,"x"), (7,"z")])\n        @?= ((empty :: SMap), fromList [(5,"a"), (3,"b"), (1,"x"), (7,"z")])\n where\n   f a = if a < "c" then Left a else Right a\n\ntest_mapEitherWithKey :: Assertion\ntest_mapEitherWithKey = do\n    mapEitherWithKey f (fromList [(5,"a"), (3,"b"), (1,"x"), (7,"z")])\n     @?= (fromList [(1,2), (3,6)], fromList [(5,"aa"), (7,"zz")])\n    mapEitherWithKey (\\_ a -> Right a) (fromList [(5,"a"), (3,"b"), (1,"x"), (7,"z")])\n     @?= ((empty :: SMap), fromList [(1,"x"), (3,"b"), (5,"a"), (7,"z")])\n  where\n    f k a = if k < 5 then Left (k * 2) else Right (a ++ a)\n\ntest_split :: Assertion\ntest_split = do\n    split 2 (fromList [(5,"a"), (3,"b")]) @?= (empty, fromList [(3,"b"), (5,"a")])\n    split 3 (fromList [(5,"a"), (3,"b")]) @?= (empty, singleton 5 "a")\n    split 4 (fromList [(5,"a"), (3,"b")]) @?= (singleton 3 "b", singleton 5 "a")\n    split 5 (fromList [(5,"a"), (3,"b")]) @?= (singleton 3 "b", empty)\n    split 6 (fromList [(5,"a"), (3,"b")]) @?= (fromList [(3,"b"), (5,"a")], empty)\n\ntest_splitLookup :: Assertion\ntest_splitLookup = do\n    splitLookup 2 (fromList [(5,"a"), (3,"b")]) @?= (empty, Nothing, fromList [(3,"b"), (5,"a")])\n    splitLookup 3 (fromList [(5,"a"), (3,"b")]) @?= (empty, Just "b", singleton 5 "a")\n    splitLookup 4 (fromList [(5,"a"), (3,"b")]) @?= (singleton 3 "b", Nothing, singleton 5 "a")\n    splitLookup 5 (fromList [(5,"a"), (3,"b")]) @?= (singleton 3 "b", Just "a", empty)\n    splitLookup 6 (fromList [(5,"a"), (3,"b")]) @?= (fromList [(3,"b"), (5,"a")], Nothing, empty)\n\n----------------------------------------------------------------\n-- Submap\n\ntest_isSubmapOfBy :: Assertion\ntest_isSubmapOfBy = do\n    isSubmapOfBy (==) (fromList [(\'a\',1)]) (fromList [(\'a\',1),(\'b\',2)]) @?= True\n    isSubmapOfBy (<=) (fromList [(\'a\',1)]) (fromList [(\'a\',1),(\'b\',2)]) @?= True\n    isSubmapOfBy (==) (fromList [(\'a\',1),(\'b\',2)]) (fromList [(\'a\',1),(\'b\',2)]) @?= True\n    isSubmapOfBy (==) (fromList [(\'a\',2)]) (fromList [(\'a\',1),(\'b\',2)]) @?= False\n    isSubmapOfBy (<)  (fromList [(\'a\',1)]) (fromList [(\'a\',1),(\'b\',2)]) @?= False\n    isSubmapOfBy (==) (fromList [(\'a\',1),(\'b\',2)]) (fromList [(\'a\',1)]) @?= False\n\ntest_isSubmapOf :: Assertion\ntest_isSubmapOf = do\n    isSubmapOf (fromList [(\'a\',1)]) (fromList [(\'a\',1),(\'b\',2)]) @?= True\n    isSubmapOf (fromList [(\'a\',1),(\'b\',2)]) (fromList [(\'a\',1),(\'b\',2)]) @?= True\n    isSubmapOf (fromList [(\'a\',2)]) (fromList [(\'a\',1),(\'b\',2)]) @?= False\n    isSubmapOf (fromList [(\'a\',1),(\'b\',2)]) (fromList [(\'a\',1)]) @?= False\n\ntest_isProperSubmapOfBy :: Assertion\ntest_isProperSubmapOfBy = do\n    isProperSubmapOfBy (==) (fromList [(1,1)]) (fromList [(1,1),(2,2)]) @?= True\n    isProperSubmapOfBy (<=) (fromList [(1,1)]) (fromList [(1,1),(2,2)]) @?= True\n    isProperSubmapOfBy (==) (fromList [(1,1),(2,2)]) (fromList [(1,1),(2,2)]) @?= False\n    isProperSubmapOfBy (==) (fromList [(1,1),(2,2)]) (fromList [(1,1)]) @?= False\n    isProperSubmapOfBy (<)  (fromList [(1,1)])       (fromList [(1,1),(2,2)]) @?= False\n\ntest_isProperSubmapOf :: Assertion\ntest_isProperSubmapOf = do\n    isProperSubmapOf (fromList [(1,1)]) (fromList [(1,1),(2,2)]) @?= True\n    isProperSubmapOf (fromList [(1,1),(2,2)]) (fromList [(1,1),(2,2)]) @?= False\n    isProperSubmapOf (fromList [(1,1),(2,2)]) (fromList [(1,1)]) @?= False\n\n----------------------------------------------------------------\n-- Indexed\n\ntest_lookupIndex :: Assertion\ntest_lookupIndex = do\n    isJust (lookupIndex 2 (fromList [(5,"a"), (3,"b")]))   @?= False\n    fromJust (lookupIndex 3 (fromList [(5,"a"), (3,"b")])) @?= 0\n    fromJust (lookupIndex 5 (fromList [(5,"a"), (3,"b")])) @?= 1\n    isJust (lookupIndex 6 (fromList [(5,"a"), (3,"b")]))   @?= False\n\ntest_findIndex :: Assertion\ntest_findIndex = do\n    findIndex 3 (fromList [(5,"a"), (3,"b")]) @?= 0\n    findIndex 5 (fromList [(5,"a"), (3,"b")]) @?= 1\n\ntest_elemAt :: Assertion\ntest_elemAt = do\n    elemAt 0 (fromList [(5,"a"), (3,"b")]) @?= (3,"b")\n    elemAt 1 (fromList [(5,"a"), (3,"b")]) @?= (5, "a")\n\ntest_updateAt :: Assertion\ntest_updateAt = do\n    updateAt (\\ _ _ -> Just "x") 0    (fromList [(5,"a"), (3,"b")]) @?= fromList [(3, "x"), (5, "a")]\n    updateAt (\\ _ _ -> Just "x") 1    (fromList [(5,"a"), (3,"b")]) @?= fromList [(3, "b"), (5, "x")]\n    updateAt (\\_ _  -> Nothing)  0    (fromList [(5,"a"), (3,"b")]) @?= singleton 5 "a"\n    updateAt (\\_ _  -> Nothing)  1    (fromList [(5,"a"), (3,"b")]) @?= singleton 3 "b"\n--    updateAt (\\_ _  -> Nothing)  7    (fromList [(5,"a"), (3,"b")]) @?= singleton 3 "b"\n\ntest_deleteAt :: Assertion\ntest_deleteAt = do\n    deleteAt 0  (fromList [(5,"a"), (3,"b")]) @?= singleton 5 "a"\n    deleteAt 1  (fromList [(5,"a"), (3,"b")]) @?= singleton 3 "b"\n\n----------------------------------------------------------------\n-- Min/Max\n\ntest_findMin :: Assertion\ntest_findMin = findMin (fromList [(5,"a"), (3,"b")]) @?= (3,"b")\n\ntest_findMax :: Assertion\ntest_findMax = findMax (fromList [(5,"a"), (3,"b")]) @?= (5,"a")\n\ntest_deleteMin :: Assertion\ntest_deleteMin = do\n    deleteMin (fromList [(5,"a"), (3,"b"), (7,"c")]) @?= fromList [(5,"a"), (7,"c")]\n    deleteMin (empty :: SMap) @?= empty\n\ntest_deleteMax :: Assertion\ntest_deleteMax = do\n    deleteMax (fromList [(5,"a"), (3,"b"), (7,"c")]) @?= fromList [(3,"b"), (5,"a")]\n    deleteMax (empty :: SMap) @?= empty\n\ntest_deleteFindMin :: Assertion\ntest_deleteFindMin = deleteFindMin (fromList [(5,"a"), (3,"b"), (10,"c")]) @?= ((3,"b"), fromList[(5,"a"), (10,"c")])\n\ntest_deleteFindMax :: Assertion\ntest_deleteFindMax = deleteFindMax (fromList [(5,"a"), (3,"b"), (10,"c")]) @?= ((10,"c"), fromList [(3,"b"), (5,"a")])\n\ntest_updateMin :: Assertion\ntest_updateMin = do\n    updateMin (\\ a -> Just ("X" ++ a)) (fromList [(5,"a"), (3,"b")]) @?= fromList [(3, "Xb"), (5, "a")]\n    updateMin (\\ _ -> Nothing)         (fromList [(5,"a"), (3,"b")]) @?= singleton 5 "a"\n\ntest_updateMax :: Assertion\ntest_updateMax = do\n    updateMax (\\ a -> Just ("X" ++ a)) (fromList [(5,"a"), (3,"b")]) @?= fromList [(3, "b"), (5, "Xa")]\n    updateMax (\\ _ -> Nothing)         (fromList [(5,"a"), (3,"b")]) @?= singleton 3 "b"\n\ntest_updateMinWithKey :: Assertion\ntest_updateMinWithKey = do\n    updateMinWithKey (\\ k a -> Just ((show k) ++ ":" ++ a)) (fromList [(5,"a"), (3,"b")]) @?= fromList [(3,"3:b"), (5,"a")]\n    updateMinWithKey (\\ _ _ -> Nothing)                     (fromList [(5,"a"), (3,"b")]) @?= singleton 5 "a"\n\ntest_updateMaxWithKey :: Assertion\ntest_updateMaxWithKey = do\n    updateMaxWithKey (\\ k a -> Just ((show k) ++ ":" ++ a)) (fromList [(5,"a"), (3,"b")]) @?= fromList [(3,"b"), (5,"5:a")]\n    updateMaxWithKey (\\ _ _ -> Nothing)                     (fromList [(5,"a"), (3,"b")]) @?= singleton 3 "b"\n\ntest_minView :: Assertion\ntest_minView = do\n    minView (fromList [(5,"a"), (3,"b")]) @?= Just ("b", singleton 5 "a")\n    minView (empty :: SMap) @?= Nothing\n\ntest_maxView :: Assertion\ntest_maxView = do\n    maxView (fromList [(5,"a"), (3,"b")]) @?= Just ("a", singleton 3 "b")\n    maxView (empty :: SMap) @?= Nothing\n\ntest_minViewWithKey :: Assertion\ntest_minViewWithKey = do\n    minViewWithKey (fromList [(5,"a"), (3,"b")]) @?= Just ((3,"b"), singleton 5 "a")\n    minViewWithKey (empty :: SMap) @?= Nothing\n\ntest_maxViewWithKey :: Assertion\ntest_maxViewWithKey = do\n    maxViewWithKey (fromList [(5,"a"), (3,"b")]) @?= Just ((5,"a"), singleton 3 "b")\n    maxViewWithKey (empty :: SMap) @?= Nothing\n\n----------------------------------------------------------------\n-- Debug\n\ntest_valid :: Assertion\ntest_valid = do\n    valid (fromAscList [(3,"b"), (5,"a")]) @?= True\n    valid (fromAscList [(5,"a"), (3,"b")]) @?= False\n\n----------------------------------------------------------------\n-- QuickCheck\n----------------------------------------------------------------\n\nprop_differenceMerge :: Fun (Int, A, B) (Maybe A) -> Map Int A -> Map Int B -> Property\nprop_differenceMerge f m1 m2 =\n  differenceWithKey (apply3 f) m1 m2 === merge preserveMissing dropMissing (zipWithMaybeMatched (apply3 f)) m1 m2\n\nprop_unionWithKeyMerge :: Fun (Int, A, A) A -> Map Int A -> Map Int A -> Property\nprop_unionWithKeyMerge f m1 m2 =\n  unionWithKey (apply3 f) m1 m2 === unionWithKey\' (apply3 f) m1 m2\n\nunionWithKey\' :: Ord k => (k -> a -> a -> a) -> Map k a -> Map k a -> Map k a\nunionWithKey\' f = merge preserveMissing preserveMissing $\n  zipWithMatched (\\k a b -> f k a b)\n\nprop_valid :: UMap -> Bool\nprop_valid t = valid t\n\nprop_singleton :: Int -> Int -> Bool\nprop_singleton k x = insert k x empty == singleton k x\n\nprop_insert :: Int -> UMap -> Bool\nprop_insert k t = valid $ insert k () t\n\nprop_insertLookup :: Int -> UMap -> Bool\nprop_insertLookup k t = lookup k (insert k () t) /= Nothing\n\nprop_insertDelete :: Int -> UMap -> Bool\nprop_insertDelete k t = valid $ delete k (insert k () t)\n\nprop_insertDelete2 :: Int -> UMap -> Property\nprop_insertDelete2 k t = (lookup k t == Nothing) ==> (delete k (insert k () t) == t)\n\nprop_deleteNonMember :: Int -> UMap -> Property\nprop_deleteNonMember k t = (lookup k t == Nothing) ==> (delete k t == t)\n\nprop_deleteMin :: UMap -> Bool\nprop_deleteMin t = valid $ deleteMin $ deleteMin t\n\nprop_deleteMax :: UMap -> Bool\nprop_deleteMax t = valid $ deleteMax $ deleteMax t\n\nprop_lookupMin :: IMap -> Property\nprop_lookupMin m = lookupMin m === (fst <$> minViewWithKey m)\n\nprop_lookupMax :: IMap -> Property\nprop_lookupMax m = lookupMax m === (fst <$> maxViewWithKey m)\n\n----------------------------------------------------------------\n\nprop_split :: Int -> UMap -> Bool\nprop_split k t = let (r,l) = split k t\n                 in (valid r, valid l) == (True, True)\n\nprop_splitRoot :: UMap -> Bool\nprop_splitRoot s = loop ls && (s == unions ls)\n where\n  ls = splitRoot s\n  loop [] = True\n  loop (s1:rst) = List.null\n                  [ (x,y) | x <- toList s1\n                          , y <- toList (unions rst)\n                          , x > y ]\n\nprop_link :: Int -> UMap -> Bool\nprop_link k t = let (l,r) = split k t\n                in valid (link k () l r)\n\nprop_link2 :: Int -> UMap -> Bool\nprop_link2 k t = let (l,r) = split k t\n                 in valid (link2 l r)\n\n----------------------------------------------------------------\n\nprop_union :: UMap -> UMap -> Bool\nprop_union t1 t2 = valid (union t1 t2)\n\nprop_unionModel :: [(Int,Int)] -> [(Int,Int)] -> Bool\nprop_unionModel xs ys\n  = sort (keys (union (fromList xs) (fromList ys)))\n    == sort (nub (Prelude.map fst xs ++ Prelude.map fst ys))\n\nprop_unionSingleton :: IMap -> Int -> Int -> Bool\nprop_unionSingleton t k x = union (singleton k x) t == insert k x t\n\nprop_unionAssoc :: IMap -> IMap -> IMap -> Bool\nprop_unionAssoc t1 t2 t3 = union t1 (union t2 t3) == union (union t1 t2) t3\n\nprop_unionWith :: IMap -> IMap -> Bool\nprop_unionWith t1 t2 = (union t1 t2 == unionWith (\\_ y -> y) t2 t1)\n\nprop_unionWith2 :: IMap -> IMap -> Bool\nprop_unionWith2 t1 t2 = valid (unionWithKey (\\_ x y -> x+y) t1 t2)\n\nprop_unionSum :: [(Int,Int)] -> [(Int,Int)] -> Bool\nprop_unionSum xs ys\n  = sum (elems (unionWith (+) (fromListWith (+) xs) (fromListWith (+) ys)))\n    == (sum (Prelude.map snd xs) + sum (Prelude.map snd ys))\n\nprop_difference :: IMap -> IMap -> Bool\nprop_difference t1 t2 = valid (difference t1 t2)\n\nprop_differenceModel :: [(Int,Int)] -> [(Int,Int)] -> Bool\nprop_differenceModel xs ys\n  = sort (keys (difference (fromListWith (+) xs) (fromListWith (+) ys)))\n    == sort ((List.\\\\) (nub (Prelude.map fst xs)) (nub (Prelude.map fst ys)))\n\nprop_restrictKeys :: IMap -> IMap -> Property\nprop_restrictKeys m s0 = valid restricted .&&. (m `restrictKeys` s === filterWithKey (\\k _ -> k `Set.member` s) m)\n  where\n    s = keysSet s0\n    restricted = restrictKeys m s\n\nprop_withoutKeys :: IMap -> IMap -> Property\nprop_withoutKeys m s0 = valid reduced .&&. (m `withoutKeys` s === filterWithKey (\\k _ -> k `Set.notMember` s) m)\n  where\n    s = keysSet s0\n    reduced = withoutKeys m s\n\nprop_intersection :: IMap -> IMap -> Bool\nprop_intersection t1 t2 = valid (intersection t1 t2)\n\nprop_intersectionModel :: [(Int,Int)] -> [(Int,Int)] -> Bool\nprop_intersectionModel xs ys\n  = sort (keys (intersection (fromListWith (+) xs) (fromListWith (+) ys)))\n    == sort (nub ((List.intersect) (Prelude.map fst xs) (Prelude.map fst ys)))\n\nprop_intersectionWith :: Fun (Int, Int) (Maybe Int) -> IMap -> IMap -> Bool\nprop_intersectionWith f t1 t2 = valid (intersectionWith (apply2 f) t1 t2)\n\nprop_intersectionWithModel :: [(Int,Int)] -> [(Int,Int)] -> Bool\nprop_intersectionWithModel xs ys\n  = toList (intersectionWith f (fromList xs\') (fromList ys\'))\n    == [(kx, f vx vy) | (kx, vx) <- List.sort xs\', (ky, vy) <- ys\', kx == ky]\n    where xs\' = List.nubBy ((==) `on` fst) xs\n          ys\' = List.nubBy ((==) `on` fst) ys\n          f l r = l + 2 * r\n\nprop_intersectionWithKey :: Fun (Int, Int, Int) (Maybe Int) -> IMap -> IMap -> Bool\nprop_intersectionWithKey f t1 t2 = valid (intersectionWithKey (apply3 f) t1 t2)\n\nprop_intersectionWithKeyModel :: [(Int,Int)] -> [(Int,Int)] -> Bool\nprop_intersectionWithKeyModel xs ys\n  = toList (intersectionWithKey f (fromList xs\') (fromList ys\'))\n    == [(kx, f kx vx vy) | (kx, vx) <- List.sort xs\', (ky, vy) <- ys\', kx == ky]\n    where xs\' = List.nubBy ((==) `on` fst) xs\n          ys\' = List.nubBy ((==) `on` fst) ys\n          f k l r = k + 2 * l + 3 * r\n\nprop_disjoint :: UMap -> UMap -> Property\nprop_disjoint m1 m2 = disjoint m1 m2 === null (intersection m1 m2)\n\nprop_compose :: IMap -> IMap -> Int -> Property\nprop_compose bc ab k = (compose bc ab !? k) === ((bc !?) <=< (ab !?)) k\n\nprop_mergeWithKeyModel :: [(Int,Int)] -> [(Int,Int)] -> Bool\nprop_mergeWithKeyModel xs ys\n  = and [ testMergeWithKey f keep_x keep_y\n        | f <- [ \\_k x1  _x2 -> Just x1\n               , \\_k _x1 x2  -> Just x2\n               , \\_k _x1 _x2 -> Nothing\n               , \\k  x1  x2  -> if k `mod` 2 == 0 then Nothing else Just (2 * x1 + 3 * x2)\n               ]\n        , keep_x <- [ True, False ]\n        , keep_y <- [ True, False ]\n        ]\n\n    where xs\' = List.nubBy ((==) `on` fst) xs\n          ys\' = List.nubBy ((==) `on` fst) ys\n\n          xm = fromList xs\'\n          ym = fromList ys\'\n\n          testMergeWithKey f keep_x keep_y\n            = toList (mergeWithKey f (keep keep_x) (keep keep_y) xm ym) == emulateMergeWithKey f keep_x keep_y\n              where keep False _ = empty\n                    keep True  m = m\n\n                    emulateMergeWithKey f keep_x keep_y\n                      = Maybe.mapMaybe combine (sort $ List.union (List.map fst xs\') (List.map fst ys\'))\n                        where combine k = case (List.lookup k xs\', List.lookup k ys\') of\n                                            (Nothing, Just y) -> if keep_y then Just (k, y) else Nothing\n                                            (Just x, Nothing) -> if keep_x then Just (k, x) else Nothing\n                                            (Just x, Just y) -> (\\v -> (k, v)) `fmap` f k x y\n\n          -- We prevent inlining testMergeWithKey to disable the SpecConstr\n          -- optimalization. There are too many call patterns here so several\n          -- warnings are issued if testMergeWithKey gets inlined.\n          {-# NOINLINE testMergeWithKey #-}\n\n-- This uses the instance\n--     Monoid a => Applicative ((,) a)\n-- to test that effects are sequenced in ascending key order.\nprop_mergeA_effects :: UMap -> UMap -> Property\nprop_mergeA_effects xs ys\n  = effects === sort effects\n  where\n    (effects, _m) = mergeA whenMissing whenMissing whenMatched xs ys\n    whenMissing = traverseMissing (\\k _ -> ([k], ()))\n    whenMatched = zipWithAMatched (\\k _ _ -> ([k], ()))\n\n----------------------------------------------------------------\n\nprop_ordered :: Property\nprop_ordered\n  = forAll (choose (5,100)) $ \\n ->\n    let xs = [(x,()) | x <- [0..n::Int]]\n    in fromAscList xs == fromList xs\n\nprop_rev_ordered :: Property\nprop_rev_ordered\n  = forAll (choose (5,100)) $ \\n ->\n    let xs = [(x,()) | x <- [0..n::Int]]\n    in fromDescList (reverse xs) == fromList xs\n\nprop_list :: [Int] -> Bool\nprop_list xs = (sort (nub xs) == [x | (x,()) <- toList (fromList [(x,()) | x <- xs])])\n\nprop_descList :: [Int] -> Bool\nprop_descList xs = (reverse (sort (nub xs)) == [x | (x,()) <- toDescList (fromList [(x,()) | x <- xs])])\n\nprop_fromDistinctDescList :: Int -> [A] -> Property\nprop_fromDistinctDescList top lst = valid converted .&&. (toList converted === reverse original) where\n  original = zip [top, (top-1)..0] lst\n  converted = fromDistinctDescList original\n\nprop_ascDescList :: [Int] -> Bool\nprop_ascDescList xs = toAscList m == reverse (toDescList m)\n  where m = fromList $ zip xs $ repeat ()\n\nprop_fromList :: [Int] -> Bool\nprop_fromList xs\n  = case fromList (zip xs xs) of\n      t -> t == fromAscList (zip sort_xs sort_xs) &&\n           t == fromDistinctAscList (zip nub_sort_xs nub_sort_xs) &&\n           t == List.foldr (uncurry insert) empty (zip xs xs)\n  where sort_xs = sort xs\n        nub_sort_xs = List.map List.head $ List.group sort_xs\n\n----------------------------------------------------------------\n\nprop_alter :: UMap -> Int -> Bool\nprop_alter t k = balanced t\' && case lookup k t of\n    Just _  -> (size t - 1) == size t\' && lookup k t\' == Nothing\n    Nothing -> (size t + 1) == size t\' && lookup k t\' /= Nothing\n  where\n    t\' = alter f k t\n    f Nothing   = Just ()\n    f (Just ()) = Nothing\n\nprop_alterF_alter :: Fun (Maybe Int) (Maybe Int) -> Int -> IMap -> Bool\nprop_alterF_alter f k m = valid altered && altered == alter (apply f) k m\n  where altered = atAlter (apply f) k m\n\nprop_alterF_alter_noRULES :: Fun (Maybe Int) (Maybe Int) -> Int -> IMap -> Bool\nprop_alterF_alter_noRULES f k m = valid altered &&\n                                  altered == alter (apply f) k m\n  where altered = atAlterNoRULES (apply f) k m\n\nprop_alterF_lookup :: Int -> IMap -> Bool\nprop_alterF_lookup k m = atLookup k m == lookup k m\n\nprop_alterF_lookup_noRULES :: Int -> IMap -> Bool\nprop_alterF_lookup_noRULES k m = atLookupNoRULES k m == lookup k m\n\n------------------------------------------------------------------------\n-- Compare against the list model (after nub on keys)\n\nprop_index :: [Int] -> Property\nprop_index xs = length xs > 0 ==>\n  let m  = fromList (zip xs xs)\n  in  xs == [ m ! i | i <- xs ]\n\nprop_null :: IMap -> Bool\nprop_null m = null m == (size m == 0)\n\nprop_member :: [Int] -> Int -> Bool\nprop_member xs n =\n  let m  = fromList (zip xs xs)\n  in all (\\k -> k `member` m == (k `elem` xs)) (n : xs)\n\nprop_notmember :: [Int] -> Int -> Bool\nprop_notmember xs n =\n  let m  = fromList (zip xs xs)\n  in all (\\k -> k `notMember` m == (k `notElem` xs)) (n : xs)\n\nprop_lookup :: [(Int, Int)] -> Int -> Bool\nprop_lookup xs n =\n  let xs\' = List.nubBy ((==) `on` fst) xs\n      m = fromList xs\'\n  in all (\\k -> lookup k m == List.lookup k xs\') (n : List.map fst xs\')\n\nprop_find :: [(Int, Int)] -> Bool\nprop_find xs =\n  let xs\' = List.nubBy ((==) `on` fst) xs\n      m = fromList xs\'\n  in all (\\(k, v) -> m ! k == v) xs\'\n\nprop_findWithDefault :: [(Int, Int)] -> Int -> Int -> Bool\nprop_findWithDefault xs n x =\n  let xs\' = List.nubBy ((==) `on` fst) xs\n      m = fromList xs\'\n  in all (\\k -> findWithDefault x k m == maybe x id (List.lookup k xs\')) (n : List.map fst xs\')\n\ntest_lookupSomething :: (Int -> Map Int Int -> Maybe (Int, Int)) -> (Int -> Int -> Bool) -> [(Int, Int)] -> Bool\ntest_lookupSomething lookup\' cmp xs =\n  let odd_sorted_xs = filter_odd $ sort $ List.nubBy ((==) `on` fst) xs\n      t = fromList odd_sorted_xs\n      test k = case List.filter ((`cmp` k) . fst) odd_sorted_xs of\n                 []             -> lookup\' k t == Nothing\n                 cs | 0 `cmp` 1 -> lookup\' k t == Just (last cs) -- we want largest such element\n                    | otherwise -> lookup\' k t == Just (head cs) -- we want smallest such element\n  in all test (List.map fst xs)\n\n  where filter_odd [] = []\n        filter_odd [_] = []\n        filter_odd (_ : o : xs) = o : filter_odd xs\n\nprop_lookupLT :: [(Int, Int)] -> Bool\nprop_lookupLT = test_lookupSomething lookupLT (<)\n\nprop_lookupGT :: [(Int, Int)] -> Bool\nprop_lookupGT = test_lookupSomething lookupGT (>)\n\nprop_lookupLE :: [(Int, Int)] -> Bool\nprop_lookupLE = test_lookupSomething lookupLE (<=)\n\nprop_lookupGE :: [(Int, Int)] -> Bool\nprop_lookupGE = test_lookupSomething lookupGE (>=)\n\nprop_findIndex :: [(Int, Int)] -> Property\nprop_findIndex ys = length ys > 0 ==>\n  let m = fromList ys\n  in  findIndex (fst (head ys)) m `seq` True\n\nprop_lookupIndex :: [(Int, Int)] -> Property\nprop_lookupIndex ys = length ys > 0 ==>\n  let m = fromList ys\n  in  isJust (lookupIndex (fst (head ys)) m)\n\nprop_findMin :: [(Int, Int)] -> Property\nprop_findMin ys = length ys > 0 ==>\n  let xs = List.nubBy ((==) `on` fst) ys\n      m  = fromList xs\n  in  findMin m == List.minimumBy (comparing fst) xs\n\nprop_findMax :: [(Int, Int)] -> Property\nprop_findMax ys = length ys > 0 ==>\n  let xs = List.nubBy ((==) `on` fst) ys\n      m  = fromList xs\n  in  findMax m == List.maximumBy (comparing fst) xs\n\nprop_deleteMinModel :: [(Int, Int)] -> Property\nprop_deleteMinModel ys = length ys > 0 ==>\n  let xs = List.nubBy ((==) `on` fst) ys\n      m  = fromList xs\n  in  toAscList (deleteMin m) == tail (sort xs)\n\nprop_deleteMaxModel :: [(Int, Int)] -> Property\nprop_deleteMaxModel ys = length ys > 0 ==>\n  let xs = List.nubBy ((==) `on` fst) ys\n      m  = fromList xs\n  in  toAscList (deleteMax m) == init (sort xs)\n\nprop_filter :: Fun Int Bool -> [(Int, Int)] -> Property\nprop_filter p ys = length ys > 0 ==>\n  let xs = List.nubBy ((==) `on` fst) ys\n      m  = fromList xs\n  in  filter (apply p) m == fromList (List.filter (apply p . snd) xs)\n\nprop_take :: Int -> Map Int Int -> Property\nprop_take n xs = valid taken .&&.\n                 taken === fromDistinctAscList (List.take n (toList xs))\n  where\n    taken = take n xs\n\nprop_drop :: Int -> Map Int Int -> Property\nprop_drop n xs = valid dropped .&&.\n                 dropped === fromDistinctAscList (List.drop n (toList xs))\n  where\n    dropped = drop n xs\n\nprop_splitAt :: Int -> Map Int Int -> Property\nprop_splitAt n xs = valid taken .&&.\n                    valid dropped .&&.\n                    taken === take n xs .&&.\n                    dropped === drop n xs\n  where\n    (taken, dropped) = splitAt n xs\n\nprop_takeWhileAntitone :: [(Either Int Int, Int)] -> Property\nprop_takeWhileAntitone xs\' = valid tw .&&. (tw === filterWithKey (\\k _ -> isLeft k) xs)\n  where\n    xs = fromList xs\'\n    tw = takeWhileAntitone isLeft xs\n\nprop_dropWhileAntitone :: [(Either Int Int, Int)] -> Property\nprop_dropWhileAntitone xs\' = valid tw .&&. (tw === filterWithKey (\\k _ -> not (isLeft k)) xs)\n  where\n    xs = fromList xs\'\n    tw = dropWhileAntitone isLeft xs\n\nprop_spanAntitone :: [(Either Int Int, Int)] -> Property\nprop_spanAntitone xs\' = valid tw .&&. valid dw\n                        .&&. (tw === takeWhileAntitone isLeft xs)\n                        .&&. (dw === dropWhileAntitone isLeft xs)\n  where\n    xs = fromList xs\'\n    (tw, dw) = spanAntitone isLeft xs\n\nisLeft :: Either a b -> Bool\nisLeft (Left _) = True\nisLeft _ = False\n\nprop_partition :: Fun Int Bool -> [(Int, Int)] -> Property\nprop_partition p ys = length ys > 0 ==>\n  let xs = List.nubBy ((==) `on` fst) ys\n      m  = fromList xs\n  in  partition (apply p) m == let (a,b) = (List.partition (apply p . snd) xs) in (fromList a, fromList b)\n\nprop_map :: Fun Int Int -> [(Int, Int)] -> Property\nprop_map f ys = length ys > 0 ==>\n  let xs = List.nubBy ((==) `on` fst) ys\n      m  = fromList xs\n  in  map (apply f) m == fromList [ (a, apply f b) | (a,b) <- xs ]\n\nprop_fmap :: Fun Int Int -> [(Int, Int)] -> Property\nprop_fmap f ys = length ys > 0 ==>\n  let xs = List.nubBy ((==) `on` fst) ys\n      m  = fromList xs\n  in  fmap (apply f) m == fromList [ (a, (apply f) b) | (a,b) <- xs ]\n\nprop_mapkeys :: Fun Int Int -> [(Int, Int)] -> Property\nprop_mapkeys f ys = length ys > 0 ==>\n  let xs = List.nubBy ((==) `on` fst) ys\n      m  = fromList xs\n  in  mapKeys (apply f) m == (fromList $ List.nubBy ((==) `on` fst) $ reverse [ (apply f a, b) | (a,b) <- sort xs])\n\nprop_splitModel :: Int -> [(Int, Int)] -> Property\nprop_splitModel n ys = length ys > 0 ==>\n  let xs = List.nubBy ((==) `on` fst) ys\n      (l, r) = split n $ fromList xs\n  in  toAscList l == sort [(k, v) | (k,v) <- xs, k < n] &&\n      toAscList r == sort [(k, v) | (k,v) <- xs, k > n]\n\nprop_fold :: Map Int A -> Property\nprop_fold = \\m -> Foldable.fold (f <$> m) === Foldable.fold (f <$> elems m)\n  where\n    f v = [v]\n\nprop_foldMap :: Map Int A -> Property\nprop_foldMap = \\m -> Foldable.foldMap f m === Foldable.foldMap f (elems m)\n  where\n    f v = [v]\n\nprop_foldMapWithKey :: Map Int A -> Property\nprop_foldMapWithKey = \\m -> foldMapWithKey (curry f) m === Foldable.foldMap f (toList m)\n  where\n    f kv = [kv]\n\n-- elems is implemented in terms of foldr, so we don\'t want to rely on it\n-- when we\'re trying to test foldr.\nprop_foldr :: Fun (A, B) B -> B -> [(Int, A)] -> Property\nprop_foldr c n ys = foldr c\' n m === Foldable.foldr c\' n (snd <$> xs)\n  where\n    c\' = curry (apply c)\n    xs = List.sortBy (comparing fst) (List.nubBy ((==) `on` fst) ys)\n    m  = fromList xs\n\n\n-- toList is implemented in terms of foldrWithKey, so we don\'t want to rely on it\n-- when we\'re trying to test foldrWithKey.\nprop_foldrWithKey :: Fun (Int, A, B) B -> B -> [(Int, A)] -> Property\nprop_foldrWithKey c n ys = foldrWithKey c\' n m === Foldable.foldr (uncurry c\') n xs\n  where\n    c\' k v acc = apply c (k, v, acc)\n    xs = List.sortBy (comparing fst) (List.nubBy ((==) `on` fst) ys)\n    m  = fromList xs\n\nprop_foldr\' :: Fun (A, B) B -> B -> Map Int A -> Property\nprop_foldr\' c n m = foldr\' c\' n m === Foldable.foldr\' c\' n (elems m)\n  where\n    c\' = curry (apply c)\n\nprop_foldrWithKey\' :: Fun (Int, A, B) B -> B -> Map Int A -> Property\nprop_foldrWithKey\' c n m = foldrWithKey\' c\' n m === Foldable.foldr\' (uncurry c\') n (toList m)\n  where\n    c\' k v acc = apply c (k, v, acc)\n\nprop_foldl :: Fun (B, A) B -> B -> Map Int A -> Property\nprop_foldl c n m = foldl c\' n m === Foldable.foldl c\' n (elems m)\n  where\n    c\' = curry (apply c)\n\nprop_foldlWithKey :: Fun (B, Int, A) B -> B -> Map Int A -> Property\nprop_foldlWithKey c n m = foldlWithKey c\' n m === Foldable.foldl (uncurry . c\') n (toList m)\n  where\n    c\' acc k v = apply c (acc, k, v)\n\nprop_foldl\' :: Fun (B, A) B -> B -> Map Int A -> Property\nprop_foldl\' c n m = foldl\' c\' n m === Foldable.foldl\' c\' n (elems m)\n  where\n    c\' = curry (apply c)\n\nprop_foldlWithKey\' :: Fun (B, Int, A) B -> B -> Map Int A -> Property\nprop_foldlWithKey\' c n m = foldlWithKey\' c\' n m === Foldable.foldl\' (uncurry . c\') n (toList m)\n  where\n    c\' acc k v = apply c (acc, k, v)\n\n#if MIN_VERSION_base(4,10,0)\nprop_bifold :: Map Int Int -> Property\nprop_bifold m = Bifoldable.bifold (mapKeys (:[]) ((:[]) <$> m)) === Foldable.fold ((\\(k,v) -> [k,v]) <$> toList m)\n\nprop_bifoldMap :: Map Int Int -> Property\nprop_bifoldMap m = Bifoldable.bifoldMap (:[]) (:[]) m === Foldable.foldMap (\\(k,v) -> [k,v]) (toList m)\n\nprop_bifoldr :: Fun (Int, B) B -> Fun (A, B) B -> B -> Map Int A -> Property\nprop_bifoldr ck cv n m = Bifoldable.bifoldr ck\' cv\' n m === Foldable.foldr c\' n (toList m)\n  where\n    ck\' = curry (apply ck)\n    cv\' = curry (apply cv)\n    (k,v) `c\'` acc = k `ck\'` (v `cv\'` acc)\n\nprop_bifoldr\' :: Fun (Int, B) B -> Fun (A, B) B -> B -> Map Int A -> Property\nprop_bifoldr\' ck cv n m = Bifoldable.bifoldr\' ck\' cv\' n m === Foldable.foldr\' c\' n (toList m)\n  where\n    ck\' = curry (apply ck)\n    cv\' = curry (apply cv)\n    (k,v) `c\'` acc = k `ck\'` (v `cv\'` acc)\n\nprop_bifoldl :: Fun (B, Int) B -> Fun (B, A) B -> B -> Map Int A -> Property\nprop_bifoldl ck cv n m = Bifoldable.bifoldl ck\' cv\' n m === Foldable.foldl c\' n (toList m)\n  where\n    ck\' = curry (apply ck)\n    cv\' = curry (apply cv)\n    acc `c\'` (k,v) = (acc `ck\'` k) `cv\'` v\n\nprop_bifoldl\' :: Fun (B, Int) B -> Fun (B, A) B -> B -> Map Int A -> Property\nprop_bifoldl\' ck cv n m = Bifoldable.bifoldl\' ck\' cv\' n m === Foldable.foldl\' c\' n (toList m)\n  where\n    ck\' = curry (apply ck)\n    cv\' = curry (apply cv)\n    acc `c\'` (k,v) = (acc `ck\'` k) `cv\'` v\n#endif\n\nprop_keysSet :: [(Int, Int)] -> Bool\nprop_keysSet xs =\n  keysSet (fromList xs) == Set.fromList (List.map fst xs)\n\nprop_argSet :: [(Int, Int)] -> Bool\nprop_argSet xs =\n  argSet (fromList xs) == Set.fromList (List.map (uncurry Arg) xs)\n\nprop_fromSet :: [(Int, Int)] -> Bool\nprop_fromSet ys =\n  let xs = List.nubBy ((==) `on` fst) ys\n  in fromSet (\\k -> fromJust $ List.lookup k xs) (Set.fromList $ List.map fst xs) == fromList xs\n\nprop_fromArgSet :: [(Int, Int)] -> Bool\nprop_fromArgSet ys =\n  let xs = List.nubBy ((==) `on` fst) ys\n  in fromArgSet (Set.fromList $ List.map (uncurry Arg) xs) == fromList xs\n'