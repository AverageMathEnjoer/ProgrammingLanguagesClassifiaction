b'{-# LANGUAGE UndecidableInstances #-}\n\n-- | Checked database types\nmodule Database.Beam.Migrate.Types.CheckedEntities where\n\nimport Database.Beam\nimport Database.Beam.Backend.SQL\nimport Database.Beam.Schema.Tables\n\nimport Database.Beam.Migrate.Checks\nimport Database.Beam.Migrate.Generics.Tables\nimport Database.Beam.Migrate.Types.Predicates\n\nimport Control.Applicative\nimport Control.Monad.Writer\nimport Control.Monad.Identity\n\nimport Data.Maybe\nimport Data.Proxy\nimport Data.Text (Text)\nimport Data.String\n\nimport GHC.Types\nimport GHC.Generics\n\nimport Lens.Micro (Lens\', (&), (^.), (.~), (%~))\n\n-- * Checked Database Entities\n\n-- | Like \'IsDatabaseEntity\' in @beam-core@, but for entities against which we\n-- can generate \'DatabasePredicate\'s. Conceptually, this is the same as\n-- \'IsDatabaseEntity\', but with one extra function to generate\n-- \'DatabasePredicate\'s from the description.\nclass IsDatabaseEntity be entity => IsCheckedDatabaseEntity be entity where\n  -- | The type of the descriptor for this checked entity. Usually this wraps\n  -- the corresponding \'DatabaseEntityDescriptor\' from \'IsDatabaseEntity\', along\n  -- with some mechanism for generating \'DatabasePredicate\'s.\n  data CheckedDatabaseEntityDescriptor be entity :: *\n\n  -- | Like \'DatabaseEntityDefaultRequirements\' but for checked entities\n  type CheckedDatabaseEntityDefaultRequirements be entity :: Constraint\n\n  -- | Produce the corresponding \'DatabaseEntityDescriptor\'\n  unCheck :: CheckedDatabaseEntityDescriptor be entity -> DatabaseEntityDescriptor be entity\n  unCheck d = d ^. unChecked\n\n  -- | A lens to access the internal unchecked descriptor\n  unChecked :: Lens\' (CheckedDatabaseEntityDescriptor be entity) (DatabaseEntityDescriptor be entity)\n\n  -- | Produce the set of \'DatabasePredicate\'s that apply to this entity\n  collectEntityChecks :: CheckedDatabaseEntityDescriptor be entity -> [ SomeDatabasePredicate ]\n\n  -- | Like \'dbEntityAuto\' but for checked databases. Most often, this wraps\n  -- \'dbEntityAuto\' and provides some means to generate \'DatabasePredicate\'s\n  checkedDbEntityAuto :: CheckedDatabaseEntityDefaultRequirements be entity\n                      => Text -> CheckedDatabaseEntityDescriptor be entity\n\n-- | Like \'DatabaseEntity\' but for checked databases\ndata CheckedDatabaseEntity be (db :: (* -> *) -> *) entityType where\n  CheckedDatabaseEntity :: IsCheckedDatabaseEntity be entityType\n                        => CheckedDatabaseEntityDescriptor be entityType\n                        -> [ SomeDatabasePredicate ]\n                        -> CheckedDatabaseEntity be db entityType\n\n-- | The type of a checked database descriptor. Conceptually, this is just a\n-- \'DatabaseSettings\' with a set of predicates. Use \'unCheckDatabase\' to get the\n-- regular \'DatabaseSettings\' object and \'collectChecks\' to access the\n-- predicates.\ntype CheckedDatabaseSettings be db = db (CheckedDatabaseEntity be db)\n\nrenameCheckedEntity :: (Text -> Text) -> EntityModification (CheckedDatabaseEntity be db) be ent\nrenameCheckedEntity renamer =\n  EntityModification (Endo (\\(CheckedDatabaseEntity desc checks) -> (CheckedDatabaseEntity (desc & unChecked . dbEntityName %~ renamer) checks)))\n\n-- | Convert a \'CheckedDatabaseSettings\' to a regular \'DatabaseSettings\'. The\n-- return value is suitable for use in any regular beam query or DML statement.\nunCheckDatabase :: forall be db. Database be db => CheckedDatabaseSettings be db -> DatabaseSettings be db\nunCheckDatabase db = runIdentity $ zipTables (Proxy @be) (\\(CheckedDatabaseEntity x _) _ -> pure $ DatabaseEntity (unCheck x)) db db\n\n-- | A @beam-migrate@ database schema is defined completely by the set of\n-- predicates that apply to it. This function allows you to access this\n-- definition for a \'CheckedDatabaseSettings\' object.\ncollectChecks :: forall be db. Database be  db => CheckedDatabaseSettings be db -> [ SomeDatabasePredicate ]\ncollectChecks db = let (_ :: CheckedDatabaseSettings be db, a) =\n                         runWriter $ zipTables (Proxy @be)\n                           (\\(CheckedDatabaseEntity entity cs :: CheckedDatabaseEntity be db entityType) b ->\n                              do tell (collectEntityChecks entity)\n                                 tell cs\n                                 pure b) db db\n                   in a\n\ninstance IsCheckedDatabaseEntity be (DomainTypeEntity ty) where\n  data CheckedDatabaseEntityDescriptor be (DomainTypeEntity ty) =\n    CheckedDatabaseDomainType (DatabaseEntityDescriptor be (DomainTypeEntity ty))\n                              [ DomainCheck ]\n  type CheckedDatabaseEntityDefaultRequirements be (DomainTypeEntity ty) =\n    DatabaseEntityDefaultRequirements be (DomainTypeEntity ty)\n\n  unChecked f (CheckedDatabaseDomainType x cks) = fmap (\\x\' -> CheckedDatabaseDomainType x\' cks) (f x)\n  collectEntityChecks (CheckedDatabaseDomainType dt domainChecks) =\n    map (\\(DomainCheck mkCheck) -> mkCheck (qname dt)) domainChecks\n  checkedDbEntityAuto domTypeName =\n    CheckedDatabaseDomainType (dbEntityAuto domTypeName) []\n\ninstance Beamable tbl => IsCheckedDatabaseEntity be (TableEntity tbl) where\n  data CheckedDatabaseEntityDescriptor be (TableEntity tbl) where\n    CheckedDatabaseTable :: Table tbl\n                         => DatabaseEntityDescriptor be (TableEntity tbl)\n                         -> [ TableCheck ]\n                         -> tbl (Const [FieldCheck])\n                         -> CheckedDatabaseEntityDescriptor be (TableEntity tbl)\n\n  type CheckedDatabaseEntityDefaultRequirements be (TableEntity tbl)  =\n    ( DatabaseEntityDefaultRequirements be (TableEntity tbl)\n    , Generic (tbl (Const [FieldCheck]))\n    , GMigratableTableSettings be (Rep (tbl Identity)) (Rep (tbl (Const [FieldCheck])))\n    , BeamSqlBackend be )\n\n  unChecked f (CheckedDatabaseTable x cks fcks) = fmap (\\x\' -> CheckedDatabaseTable x\' cks fcks) (f x)\n  collectEntityChecks (CheckedDatabaseTable dt tblChecks tblFieldChecks) =\n    catMaybes (map (\\(TableCheck mkCheck) -> mkCheck (qname dt) (dbTableSettings dt)) tblChecks) <>\n    execWriter (zipBeamFieldsM (\\(Columnar\' fd) c@(Columnar\' (Const fieldChecks)) ->\n                                    tell (map (\\(FieldCheck mkCheck) -> mkCheck (qname dt) (fd ^. fieldName)) fieldChecks) >>\n                                    pure c)\n                               (dbTableSettings dt) tblFieldChecks)\n\n  checkedDbEntityAuto tblTypeName =\n    let tblChecks =\n          [ TableCheck $ \\tblName _ ->\n              Just (SomeDatabasePredicate (TableExistsPredicate tblName))\n          , TableCheck $ \\tblName tblFields ->\n              case allBeamValues (\\(Columnar\' fd) -> fd ^. fieldName) (primaryKey tblFields) of\n                [] -> Nothing\n                pkFields -> Just (SomeDatabasePredicate (TableHasPrimaryKey tblName pkFields))\n          ]\n\n        fieldChecks = to (gDefaultTblSettingsChecks (Proxy @be) (Proxy @(Rep (tbl Identity))) False)\n    in CheckedDatabaseTable (dbEntityAuto tblTypeName) tblChecks fieldChecks\n\n-- | Purposefully opaque type describing how to modify a table field. Used to\n-- parameterize the second argument to \'modifyCheckedTable\'. For now, the only\n-- way to construct a value is the \'IsString\' instance, which allows you to\n-- rename the field.\ndata CheckedFieldModification tbl a\n  = CheckedFieldModification\n      (TableField tbl a -> TableField tbl a)\n      ([FieldCheck] -> [FieldCheck])\n\ncheckedFieldNamed :: Text -> CheckedFieldModification tbl a\ncheckedFieldNamed t = CheckedFieldModification (fieldName .~ t) id\n\ninstance IsString (CheckedFieldModification tbl a) where\n  fromString = checkedFieldNamed . fromString\n\ninstance Beamable tbl => RenamableWithRule (tbl (CheckedFieldModification tbl)) where\n  renamingFields renamer =\n    runIdentity $\n    zipBeamFieldsM (\\(Columnar\' _ :: Columnar\' Ignored x) (Columnar\' _ :: Columnar\' Ignored x) ->\n                       pure (Columnar\' (CheckedFieldModification (renameField (Proxy @(TableField tbl)) (Proxy @x) renamer) id :: CheckedFieldModification tbl x) ::\n                               Columnar\' (CheckedFieldModification tbl) x))\n                   (undefined :: TableSkeleton tbl) (undefined :: TableSkeleton tbl)\n\n-- | Modify a checked table.\n--\n--   The first argument is a function that takes the original table name as\n--   input and produces a new table name.\n--\n--   The second argument gives instructions on how to rename each field in the\n--   table. Use \'checkedTableModification\' to create a value of this type which\n--   does no renaming. Each field in the table supplied here has the type\n--   \'CheckedFieldModification\'. Most commonly, the programmer will use the\n--   @OverloadedStrings@ instance to provide a new name.\n--\n-- == Examples\n--\n--    Rename a table, without renaming any of its fields:\n--\n-- @\n-- modifyCheckedTable (\\_ -> "NewTblNm") checkedTableModification\n-- @\n--\n--    Modify a table, renaming the field called @_field1@ in Haskell to\n--    "FirstName". Note that below, @"FirstName"@ represents a\n--    \'CheckedFieldModification\' object.\n--\n-- @\n-- modifyCheckedTable id (checkedTableModification { _field1 = "FirstName" })\n-- @\n\nmodifyCheckedTable\n  :: ( Text -> Text )\n  -> tbl (CheckedFieldModification tbl)\n  -> EntityModification (CheckedDatabaseEntity be db) be (TableEntity tbl)\nmodifyCheckedTable renamer modFields =\n  EntityModification $ Endo $\n  \\(CheckedDatabaseEntity (CheckedDatabaseTable dt tblChecks fieldChecks) extraChecks) ->\n    let fields\' =\n          runIdentity $\n          zipBeamFieldsM (\\(Columnar\' (CheckedFieldModification fieldMod _)) (Columnar\' field) ->\n                             pure $ Columnar\' (fieldMod field))\n                         modFields (dbTableSettings dt)\n        fieldChecks\' =\n          runIdentity $\n          zipBeamFieldsM (\\(Columnar\' (CheckedFieldModification _ csMod)) (Columnar\' (Const cs)) ->\n                             pure $ Columnar\' (Const (csMod cs)))\n                         modFields fieldChecks\n    in CheckedDatabaseEntity (CheckedDatabaseTable\n                                (dt { dbTableCurrentName = renamer (dbTableCurrentName dt)\n                                    , dbTableSettings = fields\'})\n                                tblChecks fieldChecks\') extraChecks\n\n-- | Produce a table field modification that does nothing\n--\n--   Most commonly supplied as the second argument to \'modifyCheckedTable\' when\n--   you just want to rename the table, not the fields.\ncheckedTableModification :: forall tbl. Beamable tbl => tbl (CheckedFieldModification tbl)\ncheckedTableModification =\n  runIdentity $\n  zipBeamFieldsM (\\(Columnar\' _ :: Columnar\' Ignored x) (Columnar\' _ :: Columnar\' Ignored x) ->\n                    pure (Columnar\' (CheckedFieldModification id id :: CheckedFieldModification tbl x)))\n                 (undefined :: TableSkeleton tbl) (undefined :: TableSkeleton tbl)\n'