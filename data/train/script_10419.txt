b'{-# LANGUAGE CPP #-}\n{-# LANGUAGE BangPatterns #-}\n{-# LANGUAGE PatternGuards #-}\n#if defined(__GLASGOW_HASKELL__)\n{-# LANGUAGE DeriveLift #-}\n{-# LANGUAGE RoleAnnotations #-}\n{-# LANGUAGE StandaloneDeriving #-}\n{-# LANGUAGE Trustworthy #-}\n{-# LANGUAGE TypeFamilies #-}\n#endif\n#define USE_MAGIC_PROXY 1\n\n#ifdef USE_MAGIC_PROXY\n{-# LANGUAGE MagicHash #-}\n#endif\n\n{-# OPTIONS_HADDOCK not-home #-}\n\n#include "containers.h"\n\n#if !(WORD_SIZE_IN_BITS >= 61)\n#define DEFINE_ALTERF_FALLBACK 1\n#endif\n\n-----------------------------------------------------------------------------\n-- |\n-- Module      :  Data.Map.Internal\n-- Copyright   :  (c) Daan Leijen 2002\n--                (c) Andriy Palamarchuk 2008\n-- License     :  BSD-style\n-- Maintainer  :  libraries@haskell.org\n-- Portability :  portable\n--\n-- = WARNING\n--\n-- This module is considered __internal__.\n--\n-- The Package Versioning Policy __does not apply__.\n--\n-- The contents of this module may change __in any way whatsoever__\n-- and __without any warning__ between minor versions of this package.\n--\n-- Authors importing this module are expected to track development\n-- closely.\n--\n-- = Description\n--\n-- An efficient implementation of maps from keys to values (dictionaries).\n--\n-- Since many function names (but not the type name) clash with\n-- "Prelude" names, this module is usually imported @qualified@, e.g.\n--\n-- >  import Data.Map (Map)\n-- >  import qualified Data.Map as Map\n--\n-- The implementation of \'Map\' is based on /size balanced/ binary trees (or\n-- trees of /bounded balance/) as described by:\n--\n--    * Stephen Adams, \\"/Efficient sets: a balancing act/\\",\n--     Journal of Functional Programming 3(4):553-562, October 1993,\n--     <http://www.swiss.ai.mit.edu/~adams/BB/>.\n--    * J. Nievergelt and E.M. Reingold,\n--      \\"/Binary search trees of bounded balance/\\",\n--      SIAM journal of computing 2(1), March 1973.\n--\n--  Bounds for \'union\', \'intersection\', and \'difference\' are as given\n--  by\n--\n--    * Guy Blelloch, Daniel Ferizovic, and Yihan Sun,\n--      \\"/Just Join for Parallel Ordered Sets/\\",\n--      <https://arxiv.org/abs/1602.02120v3>.\n--\n-- Note that the implementation is /left-biased/ -- the elements of a\n-- first argument are always preferred to the second, for example in\n-- \'union\' or \'insert\'.\n--\n-- Operation comments contain the operation time complexity in\n-- the Big-O notation <http://en.wikipedia.org/wiki/Big_O_notation>.\n--\n-- @since 0.5.9\n-----------------------------------------------------------------------------\n\n-- [Note: Using INLINABLE]\n-- ~~~~~~~~~~~~~~~~~~~~~~~\n-- It is crucial to the performance that the functions specialize on the Ord\n-- type when possible. GHC 7.0 and higher does this by itself when it sees th\n-- unfolding of a function -- that is why all public functions are marked\n-- INLINABLE (that exposes the unfolding).\n\n\n-- [Note: Using INLINE]\n-- ~~~~~~~~~~~~~~~~~~~~\n-- For other compilers and GHC pre 7.0, we mark some of the functions INLINE.\n-- We mark the functions that just navigate down the tree (lookup, insert,\n-- delete and similar). That navigation code gets inlined and thus specialized\n-- when possible. There is a price to pay -- code growth. The code INLINED is\n-- therefore only the tree navigation, all the real work (rebalancing) is not\n-- INLINED by using a NOINLINE.\n--\n-- All methods marked INLINE have to be nonrecursive -- a \'go\' function doing\n-- the real work is provided.\n\n\n-- [Note: Type of local \'go\' function]\n-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n-- If the local \'go\' function uses an Ord class, it sometimes heap-allocates\n-- the Ord dictionary when the \'go\' function does not have explicit type.\n-- In that case we give \'go\' explicit type. But this slightly decrease\n-- performance, as the resulting \'go\' function can float out to top level.\n\n\n-- [Note: Local \'go\' functions and capturing]\n-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n-- As opposed to Map, when \'go\' function captures an argument, increased\n-- heap-allocation can occur: sometimes in a polymorphic function, the \'go\'\n-- floats out of its enclosing function and then it heap-allocates the\n-- dictionary and the argument. Maybe it floats out too late and strictness\n-- analyzer cannot see that these could be passed on stack.\n--\n\n-- [Note: Order of constructors]\n-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n-- The order of constructors of Map matters when considering performance.\n-- Currently in GHC 7.0, when type has 2 constructors, a forward conditional\n-- jump is made when successfully matching second constructor. Successful match\n-- of first constructor results in the forward jump not taken.\n-- On GHC 7.0, reordering constructors from Tip | Bin to Bin | Tip\n-- improves the benchmark by up to 10% on x86.\n\nmodule Data.Map.Internal (\n    -- * Map type\n      Map(..)          -- instance Eq,Show,Read\n    , Size\n\n    -- * Operators\n    , (!), (!?), (\\\\)\n\n    -- * Query\n    , null\n    , size\n    , member\n    , notMember\n    , lookup\n    , findWithDefault\n    , lookupLT\n    , lookupGT\n    , lookupLE\n    , lookupGE\n\n    -- * Construction\n    , empty\n    , singleton\n\n    -- ** Insertion\n    , insert\n    , insertWith\n    , insertWithKey\n    , insertLookupWithKey\n\n    -- ** Delete\\/Update\n    , delete\n    , adjust\n    , adjustWithKey\n    , update\n    , updateWithKey\n    , updateLookupWithKey\n    , alter\n    , alterF\n\n    -- * Combine\n\n    -- ** Union\n    , union\n    , unionWith\n    , unionWithKey\n    , unions\n    , unionsWith\n\n    -- ** Difference\n    , difference\n    , differenceWith\n    , differenceWithKey\n\n    -- ** Intersection\n    , intersection\n    , intersectionWith\n    , intersectionWithKey\n\n    -- ** Disjoint\n    , disjoint\n\n    -- ** Compose\n    , compose\n\n    -- ** General combining function\n    , SimpleWhenMissing\n    , SimpleWhenMatched\n    , runWhenMatched\n    , runWhenMissing\n    , merge\n    -- *** @WhenMatched@ tactics\n    , zipWithMaybeMatched\n    , zipWithMatched\n    -- *** @WhenMissing@ tactics\n    , mapMaybeMissing\n    , dropMissing\n    , preserveMissing\n    , preserveMissing\'\n    , mapMissing\n    , filterMissing\n\n    -- ** Applicative general combining function\n    , WhenMissing (..)\n    , WhenMatched (..)\n    , mergeA\n\n    -- *** @WhenMatched@ tactics\n    -- | The tactics described for \'merge\' work for\n    -- \'mergeA\' as well. Furthermore, the following\n    -- are available.\n    , zipWithMaybeAMatched\n    , zipWithAMatched\n\n    -- *** @WhenMissing@ tactics\n    -- | The tactics described for \'merge\' work for\n    -- \'mergeA\' as well. Furthermore, the following\n    -- are available.\n    , traverseMaybeMissing\n    , traverseMissing\n    , filterAMissing\n\n    -- ** Deprecated general combining function\n\n    , mergeWithKey\n\n    -- * Traversal\n    -- ** Map\n    , map\n    , mapWithKey\n    , traverseWithKey\n    , traverseMaybeWithKey\n    , mapAccum\n    , mapAccumWithKey\n    , mapAccumRWithKey\n    , mapKeys\n    , mapKeysWith\n    , mapKeysMonotonic\n\n    -- * Folds\n    , foldr\n    , foldl\n    , foldrWithKey\n    , foldlWithKey\n    , foldMapWithKey\n\n    -- ** Strict folds\n    , foldr\'\n    , foldl\'\n    , foldrWithKey\'\n    , foldlWithKey\'\n\n    -- * Conversion\n    , elems\n    , keys\n    , assocs\n    , keysSet\n    , argSet\n    , fromSet\n    , fromArgSet\n\n    -- ** Lists\n    , toList\n    , fromList\n    , fromListWith\n    , fromListWithKey\n\n    -- ** Ordered lists\n    , toAscList\n    , toDescList\n    , fromAscList\n    , fromAscListWith\n    , fromAscListWithKey\n    , fromDistinctAscList\n    , fromDescList\n    , fromDescListWith\n    , fromDescListWithKey\n    , fromDistinctDescList\n\n    -- * Filter\n    , filter\n    , filterWithKey\n\n    , takeWhileAntitone\n    , dropWhileAntitone\n    , spanAntitone\n\n    , restrictKeys\n    , withoutKeys\n    , partition\n    , partitionWithKey\n\n    , mapMaybe\n    , mapMaybeWithKey\n    , mapEither\n    , mapEitherWithKey\n\n    , split\n    , splitLookup\n    , splitRoot\n\n    -- * Submap\n    , isSubmapOf, isSubmapOfBy\n    , isProperSubmapOf, isProperSubmapOfBy\n\n    -- * Indexed\n    , lookupIndex\n    , findIndex\n    , elemAt\n    , updateAt\n    , deleteAt\n    , take\n    , drop\n    , splitAt\n\n    -- * Min\\/Max\n    , lookupMin\n    , lookupMax\n    , findMin\n    , findMax\n    , deleteMin\n    , deleteMax\n    , deleteFindMin\n    , deleteFindMax\n    , updateMin\n    , updateMax\n    , updateMinWithKey\n    , updateMaxWithKey\n    , minView\n    , maxView\n    , minViewWithKey\n    , maxViewWithKey\n\n    -- Used by the strict version\n    , AreWeStrict (..)\n    , atKeyImpl\n#ifdef __GLASGOW_HASKELL__\n    , atKeyPlain\n#endif\n    , bin\n    , balance\n    , balanceL\n    , balanceR\n    , delta\n    , insertMax\n    , link\n    , link2\n    , glue\n    , MaybeS(..)\n    , Identity(..)\n\n    -- Used by Map.Merge.Lazy\n    , mapWhenMissing\n    , mapWhenMatched\n    , lmapWhenMissing\n    , contramapFirstWhenMatched\n    , contramapSecondWhenMatched\n    , mapGentlyWhenMissing\n    , mapGentlyWhenMatched\n    ) where\n\nimport Data.Functor.Identity (Identity (..))\nimport Control.Applicative (liftA3)\nimport Data.Functor.Classes\nimport Data.Semigroup (stimesIdempotentMonoid)\nimport Data.Semigroup (Arg(..), Semigroup(stimes))\n#if !(MIN_VERSION_base(4,11,0))\nimport Data.Semigroup (Semigroup((<>)))\n#endif\nimport Control.Applicative (Const (..))\nimport Control.DeepSeq (NFData(rnf))\nimport Data.Bits (shiftL, shiftR)\nimport qualified Data.Foldable as Foldable\n#if MIN_VERSION_base(4,10,0)\nimport Data.Bifoldable\n#endif\nimport Utils.Containers.Internal.Prelude hiding\n  (lookup, map, filter, foldr, foldl, null, splitAt, take, drop)\nimport Prelude ()\n\nimport qualified Data.Set.Internal as Set\nimport Data.Set.Internal (Set)\nimport Utils.Containers.Internal.PtrEquality (ptrEq)\nimport Utils.Containers.Internal.StrictPair\nimport Utils.Containers.Internal.StrictMaybe\nimport Utils.Containers.Internal.BitQueue\n#ifdef DEFINE_ALTERF_FALLBACK\nimport Utils.Containers.Internal.BitUtil (wordSize)\n#endif\n\n#if __GLASGOW_HASKELL__\nimport GHC.Exts (build, lazy)\nimport Language.Haskell.TH.Syntax (Lift)\n-- See Note [ Template Haskell Dependencies ]\nimport Language.Haskell.TH ()\n#  ifdef USE_MAGIC_PROXY\nimport GHC.Exts (Proxy#, proxy# )\n#  endif\nimport qualified GHC.Exts as GHCExts\nimport Text.Read hiding (lift)\nimport Data.Data\nimport qualified Control.Category as Category\nimport Data.Coerce\n#endif\n\n\n{--------------------------------------------------------------------\n  Operators\n--------------------------------------------------------------------}\ninfixl 9 !,!?,\\\\ --\n\n-- | \\(O(\\log n)\\). Find the value at a key.\n-- Calls \'error\' when the element can not be found.\n--\n-- > fromList [(5,\'a\'), (3,\'b\')] ! 1    Error: element not in the map\n-- > fromList [(5,\'a\'), (3,\'b\')] ! 5 == \'a\'\n\n(!) :: Ord k => Map k a -> k -> a\n(!) m k = find k m\n#if __GLASGOW_HASKELL__\n{-# INLINE (!) #-}\n#endif\n\n-- | \\(O(\\log n)\\). Find the value at a key.\n-- Returns \'Nothing\' when the element can not be found.\n--\n-- prop> fromList [(5, \'a\'), (3, \'b\')] !? 1 == Nothing\n-- prop> fromList [(5, \'a\'), (3, \'b\')] !? 5 == Just \'a\'\n--\n-- @since 0.5.9\n\n(!?) :: Ord k => Map k a -> k -> Maybe a\n(!?) m k = lookup k m\n#if __GLASGOW_HASKELL__\n{-# INLINE (!?) #-}\n#endif\n\n-- | Same as \'difference\'.\n(\\\\) :: Ord k => Map k a -> Map k b -> Map k a\nm1 \\\\ m2 = difference m1 m2\n#if __GLASGOW_HASKELL__\n{-# INLINE (\\\\) #-}\n#endif\n\n{--------------------------------------------------------------------\n  Size balanced trees.\n--------------------------------------------------------------------}\n-- | A Map from keys @k@ to values @a@.\n--\n-- The \'Semigroup\' operation for \'Map\' is \'union\', which prefers\n-- values from the left operand. If @m1@ maps a key @k@ to a value\n-- @a1@, and @m2@ maps the same key to a different value @a2@, then\n-- their union @m1 <> m2@ maps @k@ to @a1@.\n\n-- See Note: Order of constructors\ndata Map k a  = Bin {-# UNPACK #-} !Size !k a !(Map k a) !(Map k a)\n              | Tip\n\ntype Size     = Int\n\n#ifdef __GLASGOW_HASKELL__\ntype role Map nominal representational\n#endif\n\n#ifdef __GLASGOW_HASKELL__\n-- | @since 0.6.6\nderiving instance (Lift k, Lift a) => Lift (Map k a)\n#endif\n\ninstance (Ord k) => Monoid (Map k v) where\n    mempty  = empty\n    mconcat = unions\n    mappend = (<>)\n\ninstance (Ord k) => Semigroup (Map k v) where\n    (<>)    = union\n    stimes  = stimesIdempotentMonoid\n\n#if __GLASGOW_HASKELL__\n\n{--------------------------------------------------------------------\n  A Data instance\n--------------------------------------------------------------------}\n\n-- This instance preserves data abstraction at the cost of inefficiency.\n-- We provide limited reflection services for the sake of data abstraction.\n\ninstance (Data k, Data a, Ord k) => Data (Map k a) where\n  gfoldl f z m   = z fromList `f` toList m\n  toConstr _     = fromListConstr\n  gunfold k z c  = case constrIndex c of\n    1 -> k (z fromList)\n    _ -> error "gunfold"\n  dataTypeOf _   = mapDataType\n  dataCast2 f    = gcast2 f\n\nfromListConstr :: Constr\nfromListConstr = mkConstr mapDataType "fromList" [] Prefix\n\nmapDataType :: DataType\nmapDataType = mkDataType "Data.Map.Internal.Map" [fromListConstr]\n\n#endif\n\n{--------------------------------------------------------------------\n  Query\n--------------------------------------------------------------------}\n-- | \\(O(1)\\). Is the map empty?\n--\n-- > Data.Map.null (empty)           == True\n-- > Data.Map.null (singleton 1 \'a\') == False\n\nnull :: Map k a -> Bool\nnull Tip      = True\nnull (Bin {}) = False\n{-# INLINE null #-}\n\n-- | \\(O(1)\\). The number of elements in the map.\n--\n-- > size empty                                   == 0\n-- > size (singleton 1 \'a\')                       == 1\n-- > size (fromList([(1,\'a\'), (2,\'c\'), (3,\'b\')])) == 3\n\nsize :: Map k a -> Int\nsize Tip              = 0\nsize (Bin sz _ _ _ _) = sz\n{-# INLINE size #-}\n\n\n-- | \\(O(\\log n)\\). Lookup the value at a key in the map.\n--\n-- The function will return the corresponding value as @(\'Just\' value)@,\n-- or \'Nothing\' if the key isn\'t in the map.\n--\n-- An example of using @lookup@:\n--\n-- > import Prelude hiding (lookup)\n-- > import Data.Map\n-- >\n-- > employeeDept = fromList([("John","Sales"), ("Bob","IT")])\n-- > deptCountry = fromList([("IT","USA"), ("Sales","France")])\n-- > countryCurrency = fromList([("USA", "Dollar"), ("France", "Euro")])\n-- >\n-- > employeeCurrency :: String -> Maybe String\n-- > employeeCurrency name = do\n-- >     dept <- lookup name employeeDept\n-- >     country <- lookup dept deptCountry\n-- >     lookup country countryCurrency\n-- >\n-- > main = do\n-- >     putStrLn $ "John\'s currency: " ++ (show (employeeCurrency "John"))\n-- >     putStrLn $ "Pete\'s currency: " ++ (show (employeeCurrency "Pete"))\n--\n-- The output of this program:\n--\n-- >   John\'s currency: Just "Euro"\n-- >   Pete\'s currency: Nothing\nlookup :: Ord k => k -> Map k a -> Maybe a\nlookup = go\n  where\n    go !_ Tip = Nothing\n    go k (Bin _ kx x l r) = case compare k kx of\n      LT -> go k l\n      GT -> go k r\n      EQ -> Just x\n#if __GLASGOW_HASKELL__\n{-# INLINABLE lookup #-}\n#else\n{-# INLINE lookup #-}\n#endif\n\n-- | \\(O(\\log n)\\). Is the key a member of the map? See also \'notMember\'.\n--\n-- > member 5 (fromList [(5,\'a\'), (3,\'b\')]) == True\n-- > member 1 (fromList [(5,\'a\'), (3,\'b\')]) == False\nmember :: Ord k => k -> Map k a -> Bool\nmember = go\n  where\n    go !_ Tip = False\n    go k (Bin _ kx _ l r) = case compare k kx of\n      LT -> go k l\n      GT -> go k r\n      EQ -> True\n#if __GLASGOW_HASKELL__\n{-# INLINABLE member #-}\n#else\n{-# INLINE member #-}\n#endif\n\n-- | \\(O(\\log n)\\). Is the key not a member of the map? See also \'member\'.\n--\n-- > notMember 5 (fromList [(5,\'a\'), (3,\'b\')]) == False\n-- > notMember 1 (fromList [(5,\'a\'), (3,\'b\')]) == True\n\nnotMember :: Ord k => k -> Map k a -> Bool\nnotMember k m = not $ member k m\n#if __GLASGOW_HASKELL__\n{-# INLINABLE notMember #-}\n#else\n{-# INLINE notMember #-}\n#endif\n\n-- | \\(O(\\log n)\\). Find the value at a key.\n-- Calls \'error\' when the element can not be found.\nfind :: Ord k => k -> Map k a -> a\nfind = go\n  where\n    go !_ Tip = error "Map.!: given key is not an element in the map"\n    go k (Bin _ kx x l r) = case compare k kx of\n      LT -> go k l\n      GT -> go k r\n      EQ -> x\n#if __GLASGOW_HASKELL__\n{-# INLINABLE find #-}\n#else\n{-# INLINE find #-}\n#endif\n\n-- | \\(O(\\log n)\\). The expression @(\'findWithDefault\' def k map)@ returns\n-- the value at key @k@ or returns default value @def@\n-- when the key is not in the map.\n--\n-- > findWithDefault \'x\' 1 (fromList [(5,\'a\'), (3,\'b\')]) == \'x\'\n-- > findWithDefault \'x\' 5 (fromList [(5,\'a\'), (3,\'b\')]) == \'a\'\nfindWithDefault :: Ord k => a -> k -> Map k a -> a\nfindWithDefault = go\n  where\n    go def !_ Tip = def\n    go def k (Bin _ kx x l r) = case compare k kx of\n      LT -> go def k l\n      GT -> go def k r\n      EQ -> x\n#if __GLASGOW_HASKELL__\n{-# INLINABLE findWithDefault #-}\n#else\n{-# INLINE findWithDefault #-}\n#endif\n\n-- | \\(O(\\log n)\\). Find largest key smaller than the given one and return the\n-- corresponding (key, value) pair.\n--\n-- > lookupLT 3 (fromList [(3,\'a\'), (5,\'b\')]) == Nothing\n-- > lookupLT 4 (fromList [(3,\'a\'), (5,\'b\')]) == Just (3, \'a\')\nlookupLT :: Ord k => k -> Map k v -> Maybe (k, v)\nlookupLT = goNothing\n  where\n    goNothing !_ Tip = Nothing\n    goNothing k (Bin _ kx x l r) | k <= kx = goNothing k l\n                                 | otherwise = goJust k kx x r\n\n    goJust !_ kx\' x\' Tip = Just (kx\', x\')\n    goJust k kx\' x\' (Bin _ kx x l r) | k <= kx = goJust k kx\' x\' l\n                                     | otherwise = goJust k kx x r\n#if __GLASGOW_HASKELL__\n{-# INLINABLE lookupLT #-}\n#else\n{-# INLINE lookupLT #-}\n#endif\n\n-- | \\(O(\\log n)\\). Find smallest key greater than the given one and return the\n-- corresponding (key, value) pair.\n--\n-- > lookupGT 4 (fromList [(3,\'a\'), (5,\'b\')]) == Just (5, \'b\')\n-- > lookupGT 5 (fromList [(3,\'a\'), (5,\'b\')]) == Nothing\nlookupGT :: Ord k => k -> Map k v -> Maybe (k, v)\nlookupGT = goNothing\n  where\n    goNothing !_ Tip = Nothing\n    goNothing k (Bin _ kx x l r) | k < kx = goJust k kx x l\n                                 | otherwise = goNothing k r\n\n    goJust !_ kx\' x\' Tip = Just (kx\', x\')\n    goJust k kx\' x\' (Bin _ kx x l r) | k < kx = goJust k kx x l\n                                     | otherwise = goJust k kx\' x\' r\n#if __GLASGOW_HASKELL__\n{-# INLINABLE lookupGT #-}\n#else\n{-# INLINE lookupGT #-}\n#endif\n\n-- | \\(O(\\log n)\\). Find largest key smaller or equal to the given one and return\n-- the corresponding (key, value) pair.\n--\n-- > lookupLE 2 (fromList [(3,\'a\'), (5,\'b\')]) == Nothing\n-- > lookupLE 4 (fromList [(3,\'a\'), (5,\'b\')]) == Just (3, \'a\')\n-- > lookupLE 5 (fromList [(3,\'a\'), (5,\'b\')]) == Just (5, \'b\')\nlookupLE :: Ord k => k -> Map k v -> Maybe (k, v)\nlookupLE = goNothing\n  where\n    goNothing !_ Tip = Nothing\n    goNothing k (Bin _ kx x l r) = case compare k kx of LT -> goNothing k l\n                                                        EQ -> Just (kx, x)\n                                                        GT -> goJust k kx x r\n\n    goJust !_ kx\' x\' Tip = Just (kx\', x\')\n    goJust k kx\' x\' (Bin _ kx x l r) = case compare k kx of LT -> goJust k kx\' x\' l\n                                                            EQ -> Just (kx, x)\n                                                            GT -> goJust k kx x r\n#if __GLASGOW_HASKELL__\n{-# INLINABLE lookupLE #-}\n#else\n{-# INLINE lookupLE #-}\n#endif\n\n-- | \\(O(\\log n)\\). Find smallest key greater or equal to the given one and return\n-- the corresponding (key, value) pair.\n--\n-- > lookupGE 3 (fromList [(3,\'a\'), (5,\'b\')]) == Just (3, \'a\')\n-- > lookupGE 4 (fromList [(3,\'a\'), (5,\'b\')]) == Just (5, \'b\')\n-- > lookupGE 6 (fromList [(3,\'a\'), (5,\'b\')]) == Nothing\nlookupGE :: Ord k => k -> Map k v -> Maybe (k, v)\nlookupGE = goNothing\n  where\n    goNothing !_ Tip = Nothing\n    goNothing k (Bin _ kx x l r) = case compare k kx of LT -> goJust k kx x l\n                                                        EQ -> Just (kx, x)\n                                                        GT -> goNothing k r\n\n    goJust !_ kx\' x\' Tip = Just (kx\', x\')\n    goJust k kx\' x\' (Bin _ kx x l r) = case compare k kx of LT -> goJust k kx x l\n                                                            EQ -> Just (kx, x)\n                                                            GT -> goJust k kx\' x\' r\n#if __GLASGOW_HASKELL__\n{-# INLINABLE lookupGE #-}\n#else\n{-# INLINE lookupGE #-}\n#endif\n\n{--------------------------------------------------------------------\n  Construction\n--------------------------------------------------------------------}\n-- | \\(O(1)\\). The empty map.\n--\n-- > empty      == fromList []\n-- > size empty == 0\n\nempty :: Map k a\nempty = Tip\n{-# INLINE empty #-}\n\n-- | \\(O(1)\\). A map with a single element.\n--\n-- > singleton 1 \'a\'        == fromList [(1, \'a\')]\n-- > size (singleton 1 \'a\') == 1\n\nsingleton :: k -> a -> Map k a\nsingleton k x = Bin 1 k x Tip Tip\n{-# INLINE singleton #-}\n\n{--------------------------------------------------------------------\n  Insertion\n--------------------------------------------------------------------}\n-- | \\(O(\\log n)\\). Insert a new key and value in the map.\n-- If the key is already present in the map, the associated value is\n-- replaced with the supplied value. \'insert\' is equivalent to\n-- @\'insertWith\' \'const\'@.\n--\n-- > insert 5 \'x\' (fromList [(5,\'a\'), (3,\'b\')]) == fromList [(3, \'b\'), (5, \'x\')]\n-- > insert 7 \'x\' (fromList [(5,\'a\'), (3,\'b\')]) == fromList [(3, \'b\'), (5, \'a\'), (7, \'x\')]\n-- > insert 5 \'x\' empty                         == singleton 5 \'x\'\n\n-- See Note: Type of local \'go\' function\n-- See Note: Avoiding worker/wrapper\ninsert :: Ord k => k -> a -> Map k a -> Map k a\ninsert kx0 = go kx0 kx0\n  where\n    -- Unlike insertR, we only get sharing here\n    -- when the inserted value is at the same address\n    -- as the present value. We try anyway; this condition\n    -- seems particularly likely to occur in \'union\'.\n    go :: Ord k => k -> k -> a -> Map k a -> Map k a\n    go orig !_  x Tip = singleton (lazy orig) x\n    go orig !kx x t@(Bin sz ky y l r) =\n        case compare kx ky of\n            LT | l\' `ptrEq` l -> t\n               | otherwise -> balanceL ky y l\' r\n               where !l\' = go orig kx x l\n            GT | r\' `ptrEq` r -> t\n               | otherwise -> balanceR ky y l r\'\n               where !r\' = go orig kx x r\n            EQ | x `ptrEq` y && (lazy orig `seq` (orig `ptrEq` ky)) -> t\n               | otherwise -> Bin sz (lazy orig) x l r\n#if __GLASGOW_HASKELL__\n{-# INLINABLE insert #-}\n#else\n{-# INLINE insert #-}\n#endif\n\n#ifndef __GLASGOW_HASKELL__\nlazy :: a -> a\nlazy a = a\n#endif\n\n-- [Note: Avoiding worker/wrapper]\n-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n-- \'insert\' has to go to great lengths to get pointer equality right and\n-- to prevent unnecessary allocation. The trouble is that GHC *really* wants\n-- to unbox the key and throw away the boxed one. This is bad for us, because\n-- we want to compare the pointer of the box we are given to the one already\n-- present if they compare EQ. It\'s also bad for us because it leads to the\n-- key being *reboxed* if it\'s actually stored in the map. Ugh! So we pass the\n-- \'go\' function *two copies* of the key we\'re given. One of them we use for\n-- comparisons; the other we keep in our pocket. To prevent worker/wrapper from\n-- messing with the copy in our pocket, we sprinkle about calls to the magical\n-- function \'lazy\'. This is all horrible, but it seems to work okay.\n\n\n-- Insert a new key and value in the map if it is not already present.\n-- Used by `union`.\n\n-- See Note: Type of local \'go\' function\n-- See Note: Avoiding worker/wrapper\ninsertR :: Ord k => k -> a -> Map k a -> Map k a\ninsertR kx0 = go kx0 kx0\n  where\n    go :: Ord k => k -> k -> a -> Map k a -> Map k a\n    go orig !_  x Tip = singleton (lazy orig) x\n    go orig !kx x t@(Bin _ ky y l r) =\n        case compare kx ky of\n            LT | l\' `ptrEq` l -> t\n               | otherwise -> balanceL ky y l\' r\n               where !l\' = go orig kx x l\n            GT | r\' `ptrEq` r -> t\n               | otherwise -> balanceR ky y l r\'\n               where !r\' = go orig kx x r\n            EQ -> t\n#if __GLASGOW_HASKELL__\n{-# INLINABLE insertR #-}\n#else\n{-# INLINE insertR #-}\n#endif\n\n-- | \\(O(\\log n)\\). Insert with a function, combining new value and old value.\n-- @\'insertWith\' f key value mp@\n-- will insert the pair (key, value) into @mp@ if key does\n-- not exist in the map. If the key does exist, the function will\n-- insert the pair @(key, f new_value old_value)@.\n--\n-- > insertWith (++) 5 "xxx" (fromList [(5,"a"), (3,"b")]) == fromList [(3, "b"), (5, "xxxa")]\n-- > insertWith (++) 7 "xxx" (fromList [(5,"a"), (3,"b")]) == fromList [(3, "b"), (5, "a"), (7, "xxx")]\n-- > insertWith (++) 5 "xxx" empty                         == singleton 5 "xxx"\n\ninsertWith :: Ord k => (a -> a -> a) -> k -> a -> Map k a -> Map k a\ninsertWith = go\n  where\n    -- We have no hope of making pointer equality tricks work\n    -- here, because lazy insertWith *always* changes the tree,\n    -- either adding a new entry or replacing an element with a\n    -- thunk.\n    go :: Ord k => (a -> a -> a) -> k -> a -> Map k a -> Map k a\n    go _ !kx x Tip = singleton kx x\n    go f !kx x (Bin sy ky y l r) =\n        case compare kx ky of\n            LT -> balanceL ky y (go f kx x l) r\n            GT -> balanceR ky y l (go f kx x r)\n            EQ -> Bin sy kx (f x y) l r\n\n#if __GLASGOW_HASKELL__\n{-# INLINABLE insertWith #-}\n#else\n{-# INLINE insertWith #-}\n#endif\n\n-- | A helper function for \'unionWith\'. When the key is already in\n-- the map, the key is left alone, not replaced. The combining\n-- function is flipped--it is applied to the old value and then the\n-- new value.\n\ninsertWithR :: Ord k => (a -> a -> a) -> k -> a -> Map k a -> Map k a\ninsertWithR = go\n  where\n    go :: Ord k => (a -> a -> a) -> k -> a -> Map k a -> Map k a\n    go _ !kx x Tip = singleton kx x\n    go f !kx x (Bin sy ky y l r) =\n        case compare kx ky of\n            LT -> balanceL ky y (go f kx x l) r\n            GT -> balanceR ky y l (go f kx x r)\n            EQ -> Bin sy ky (f y x) l r\n#if __GLASGOW_HASKELL__\n{-# INLINABLE insertWithR #-}\n#else\n{-# INLINE insertWithR #-}\n#endif\n\n-- | \\(O(\\log n)\\). Insert with a function, combining key, new value and old value.\n-- @\'insertWithKey\' f key value mp@\n-- will insert the pair (key, value) into @mp@ if key does\n-- not exist in the map. If the key does exist, the function will\n-- insert the pair @(key,f key new_value old_value)@.\n-- Note that the key passed to f is the same key passed to \'insertWithKey\'.\n--\n-- > let f key new_value old_value = (show key) ++ ":" ++ new_value ++ "|" ++ old_value\n-- > insertWithKey f 5 "xxx" (fromList [(5,"a"), (3,"b")]) == fromList [(3, "b"), (5, "5:xxx|a")]\n-- > insertWithKey f 7 "xxx" (fromList [(5,"a"), (3,"b")]) == fromList [(3, "b"), (5, "a"), (7, "xxx")]\n-- > insertWithKey f 5 "xxx" empty                         == singleton 5 "xxx"\n\n-- See Note: Type of local \'go\' function\ninsertWithKey :: Ord k => (k -> a -> a -> a) -> k -> a -> Map k a -> Map k a\ninsertWithKey = go\n  where\n    go :: Ord k => (k -> a -> a -> a) -> k -> a -> Map k a -> Map k a\n    go _ !kx x Tip = singleton kx x\n    go f kx x (Bin sy ky y l r) =\n        case compare kx ky of\n            LT -> balanceL ky y (go f kx x l) r\n            GT -> balanceR ky y l (go f kx x r)\n            EQ -> Bin sy kx (f kx x y) l r\n#if __GLASGOW_HASKELL__\n{-# INLINABLE insertWithKey #-}\n#else\n{-# INLINE insertWithKey #-}\n#endif\n\n-- | A helper function for \'unionWithKey\'. When the key is already in\n-- the map, the key is left alone, not replaced. The combining\n-- function is flipped--it is applied to the old value and then the\n-- new value.\ninsertWithKeyR :: Ord k => (k -> a -> a -> a) -> k -> a -> Map k a -> Map k a\ninsertWithKeyR = go\n  where\n    go :: Ord k => (k -> a -> a -> a) -> k -> a -> Map k a -> Map k a\n    go _ !kx x Tip = singleton kx x\n    go f kx x (Bin sy ky y l r) =\n        case compare kx ky of\n            LT -> balanceL ky y (go f kx x l) r\n            GT -> balanceR ky y l (go f kx x r)\n            EQ -> Bin sy ky (f ky y x) l r\n#if __GLASGOW_HASKELL__\n{-# INLINABLE insertWithKeyR #-}\n#else\n{-# INLINE insertWithKeyR #-}\n#endif\n\n-- | \\(O(\\log n)\\). Combines insert operation with old value retrieval.\n-- The expression (@\'insertLookupWithKey\' f k x map@)\n-- is a pair where the first element is equal to (@\'lookup\' k map@)\n-- and the second element equal to (@\'insertWithKey\' f k x map@).\n--\n-- > let f key new_value old_value = (show key) ++ ":" ++ new_value ++ "|" ++ old_value\n-- > insertLookupWithKey f 5 "xxx" (fromList [(5,"a"), (3,"b")]) == (Just "a", fromList [(3, "b"), (5, "5:xxx|a")])\n-- > insertLookupWithKey f 7 "xxx" (fromList [(5,"a"), (3,"b")]) == (Nothing,  fromList [(3, "b"), (5, "a"), (7, "xxx")])\n-- > insertLookupWithKey f 5 "xxx" empty                         == (Nothing,  singleton 5 "xxx")\n--\n-- This is how to define @insertLookup@ using @insertLookupWithKey@:\n--\n-- > let insertLookup kx x t = insertLookupWithKey (\\_ a _ -> a) kx x t\n-- > insertLookup 5 "x" (fromList [(5,"a"), (3,"b")]) == (Just "a", fromList [(3, "b"), (5, "x")])\n-- > insertLookup 7 "x" (fromList [(5,"a"), (3,"b")]) == (Nothing,  fromList [(3, "b"), (5, "a"), (7, "x")])\n\n-- See Note: Type of local \'go\' function\ninsertLookupWithKey :: Ord k => (k -> a -> a -> a) -> k -> a -> Map k a\n                    -> (Maybe a, Map k a)\ninsertLookupWithKey f0 k0 x0 = toPair . go f0 k0 x0\n  where\n    go :: Ord k => (k -> a -> a -> a) -> k -> a -> Map k a -> StrictPair (Maybe a) (Map k a)\n    go _ !kx x Tip = (Nothing :*: singleton kx x)\n    go f kx x (Bin sy ky y l r) =\n        case compare kx ky of\n            LT -> let !(found :*: l\') = go f kx x l\n                      !t\' = balanceL ky y l\' r\n                  in (found :*: t\')\n            GT -> let !(found :*: r\') = go f kx x r\n                      !t\' = balanceR ky y l r\'\n                  in (found :*: t\')\n            EQ -> (Just y :*: Bin sy kx (f kx x y) l r)\n#if __GLASGOW_HASKELL__\n{-# INLINABLE insertLookupWithKey #-}\n#else\n{-# INLINE insertLookupWithKey #-}\n#endif\n\n{--------------------------------------------------------------------\n  Deletion\n--------------------------------------------------------------------}\n-- | \\(O(\\log n)\\). Delete a key and its value from the map. When the key is not\n-- a member of the map, the original map is returned.\n--\n-- > delete 5 (fromList [(5,"a"), (3,"b")]) == singleton 3 "b"\n-- > delete 7 (fromList [(5,"a"), (3,"b")]) == fromList [(3, "b"), (5, "a")]\n-- > delete 5 empty                         == empty\n\n-- See Note: Type of local \'go\' function\ndelete :: Ord k => k -> Map k a -> Map k a\ndelete = go\n  where\n    go :: Ord k => k -> Map k a -> Map k a\n    go !_ Tip = Tip\n    go k t@(Bin _ kx x l r) =\n        case compare k kx of\n            LT | l\' `ptrEq` l -> t\n               | otherwise -> balanceR kx x l\' r\n               where !l\' = go k l\n            GT | r\' `ptrEq` r -> t\n               | otherwise -> balanceL kx x l r\'\n               where !r\' = go k r\n            EQ -> glue l r\n#if __GLASGOW_HASKELL__\n{-# INLINABLE delete #-}\n#else\n{-# INLINE delete #-}\n#endif\n\n-- | \\(O(\\log n)\\). Update a value at a specific key with the result of the provided function.\n-- When the key is not\n-- a member of the map, the original map is returned.\n--\n-- > adjust ("new " ++) 5 (fromList [(5,"a"), (3,"b")]) == fromList [(3, "b"), (5, "new a")]\n-- > adjust ("new " ++) 7 (fromList [(5,"a"), (3,"b")]) == fromList [(3, "b"), (5, "a")]\n-- > adjust ("new " ++) 7 empty                         == empty\n\nadjust :: Ord k => (a -> a) -> k -> Map k a -> Map k a\nadjust f = adjustWithKey (\\_ x -> f x)\n#if __GLASGOW_HASKELL__\n{-# INLINABLE adjust #-}\n#else\n{-# INLINE adjust #-}\n#endif\n\n-- | \\(O(\\log n)\\). Adjust a value at a specific key. When the key is not\n-- a member of the map, the original map is returned.\n--\n-- > let f key x = (show key) ++ ":new " ++ x\n-- > adjustWithKey f 5 (fromList [(5,"a"), (3,"b")]) == fromList [(3, "b"), (5, "5:new a")]\n-- > adjustWithKey f 7 (fromList [(5,"a"), (3,"b")]) == fromList [(3, "b"), (5, "a")]\n-- > adjustWithKey f 7 empty                         == empty\n\nadjustWithKey :: Ord k => (k -> a -> a) -> k -> Map k a -> Map k a\nadjustWithKey = go\n  where\n    go :: Ord k => (k -> a -> a) -> k -> Map k a -> Map k a\n    go _ !_ Tip = Tip\n    go f k (Bin sx kx x l r) =\n        case compare k kx of\n           LT -> Bin sx kx x (go f k l) r\n           GT -> Bin sx kx x l (go f k r)\n           EQ -> Bin sx kx (f kx x) l r\n#if __GLASGOW_HASKELL__\n{-# INLINABLE adjustWithKey #-}\n#else\n{-# INLINE adjustWithKey #-}\n#endif\n\n-- | \\(O(\\log n)\\). The expression (@\'update\' f k map@) updates the value @x@\n-- at @k@ (if it is in the map). If (@f x@) is \'Nothing\', the element is\n-- deleted. If it is (@\'Just\' y@), the key @k@ is bound to the new value @y@.\n--\n-- > let f x = if x == "a" then Just "new a" else Nothing\n-- > update f 5 (fromList [(5,"a"), (3,"b")]) == fromList [(3, "b"), (5, "new a")]\n-- > update f 7 (fromList [(5,"a"), (3,"b")]) == fromList [(3, "b"), (5, "a")]\n-- > update f 3 (fromList [(5,"a"), (3,"b")]) == singleton 5 "a"\n\nupdate :: Ord k => (a -> Maybe a) -> k -> Map k a -> Map k a\nupdate f = updateWithKey (\\_ x -> f x)\n#if __GLASGOW_HASKELL__\n{-# INLINABLE update #-}\n#else\n{-# INLINE update #-}\n#endif\n\n-- | \\(O(\\log n)\\). The expression (@\'updateWithKey\' f k map@) updates the\n-- value @x@ at @k@ (if it is in the map). If (@f k x@) is \'Nothing\',\n-- the element is deleted. If it is (@\'Just\' y@), the key @k@ is bound\n-- to the new value @y@.\n--\n-- > let f k x = if x == "a" then Just ((show k) ++ ":new a") else Nothing\n-- > updateWithKey f 5 (fromList [(5,"a"), (3,"b")]) == fromList [(3, "b"), (5, "5:new a")]\n-- > updateWithKey f 7 (fromList [(5,"a"), (3,"b")]) == fromList [(3, "b"), (5, "a")]\n-- > updateWithKey f 3 (fromList [(5,"a"), (3,"b")]) == singleton 5 "a"\n\n-- See Note: Type of local \'go\' function\nupdateWithKey :: Ord k => (k -> a -> Maybe a) -> k -> Map k a -> Map k a\nupdateWithKey = go\n  where\n    go :: Ord k => (k -> a -> Maybe a) -> k -> Map k a -> Map k a\n    go _ !_ Tip = Tip\n    go f k(Bin sx kx x l r) =\n        case compare k kx of\n           LT -> balanceR kx x (go f k l) r\n           GT -> balanceL kx x l (go f k r)\n           EQ -> case f kx x of\n                   Just x\' -> Bin sx kx x\' l r\n                   Nothing -> glue l r\n#if __GLASGOW_HASKELL__\n{-# INLINABLE updateWithKey #-}\n#else\n{-# INLINE updateWithKey #-}\n#endif\n\n-- | \\(O(\\log n)\\). Lookup and update. See also \'updateWithKey\'.\n-- The function returns changed value, if it is updated.\n-- Returns the original key value if the map entry is deleted.\n--\n-- > let f k x = if x == "a" then Just ((show k) ++ ":new a") else Nothing\n-- > updateLookupWithKey f 5 (fromList [(5,"a"), (3,"b")]) == (Just "5:new a", fromList [(3, "b"), (5, "5:new a")])\n-- > updateLookupWithKey f 7 (fromList [(5,"a"), (3,"b")]) == (Nothing,  fromList [(3, "b"), (5, "a")])\n-- > updateLookupWithKey f 3 (fromList [(5,"a"), (3,"b")]) == (Just "b", singleton 5 "a")\n\n-- See Note: Type of local \'go\' function\nupdateLookupWithKey :: Ord k => (k -> a -> Maybe a) -> k -> Map k a -> (Maybe a,Map k a)\nupdateLookupWithKey f0 k0 = toPair . go f0 k0\n where\n   go :: Ord k => (k -> a -> Maybe a) -> k -> Map k a -> StrictPair (Maybe a) (Map k a)\n   go _ !_ Tip = (Nothing :*: Tip)\n   go f k (Bin sx kx x l r) =\n          case compare k kx of\n               LT -> let !(found :*: l\') = go f k l\n                         !t\' = balanceR kx x l\' r\n                     in (found :*: t\')\n               GT -> let !(found :*: r\') = go f k r\n                         !t\' = balanceL kx x l r\'\n                     in (found :*: t\')\n               EQ -> case f kx x of\n                       Just x\' -> (Just x\' :*: Bin sx kx x\' l r)\n                       Nothing -> let !glued = glue l r\n                                  in (Just x :*: glued)\n#if __GLASGOW_HASKELL__\n{-# INLINABLE updateLookupWithKey #-}\n#else\n{-# INLINE updateLookupWithKey #-}\n#endif\n\n-- | \\(O(\\log n)\\). The expression (@\'alter\' f k map@) alters the value @x@ at @k@, or absence thereof.\n-- \'alter\' can be used to insert, delete, or update a value in a \'Map\'.\n-- In short : @\'lookup\' k (\'alter\' f k m) = f (\'lookup\' k m)@.\n--\n-- > let f _ = Nothing\n-- > alter f 7 (fromList [(5,"a"), (3,"b")]) == fromList [(3, "b"), (5, "a")]\n-- > alter f 5 (fromList [(5,"a"), (3,"b")]) == singleton 3 "b"\n-- >\n-- > let f _ = Just "c"\n-- > alter f 7 (fromList [(5,"a"), (3,"b")]) == fromList [(3, "b"), (5, "a"), (7, "c")]\n-- > alter f 5 (fromList [(5,"a"), (3,"b")]) == fromList [(3, "b"), (5, "c")]\n--\n-- Note that @\'adjust\' = alter . fmap@.\n\n-- See Note: Type of local \'go\' function\nalter :: Ord k => (Maybe a -> Maybe a) -> k -> Map k a -> Map k a\nalter = go\n  where\n    go :: Ord k => (Maybe a -> Maybe a) -> k -> Map k a -> Map k a\n    go f !k Tip = case f Nothing of\n               Nothing -> Tip\n               Just x  -> singleton k x\n\n    go f k (Bin sx kx x l r) = case compare k kx of\n               LT -> balance kx x (go f k l) r\n               GT -> balance kx x l (go f k r)\n               EQ -> case f (Just x) of\n                       Just x\' -> Bin sx kx x\' l r\n                       Nothing -> glue l r\n#if __GLASGOW_HASKELL__\n{-# INLINABLE alter #-}\n#else\n{-# INLINE alter #-}\n#endif\n\n-- Used to choose the appropriate alterF implementation.\ndata AreWeStrict = Strict | Lazy\n\n-- | \\(O(\\log n)\\). The expression (@\'alterF\' f k map@) alters the value @x@ at\n-- @k@, or absence thereof.  \'alterF\' can be used to inspect, insert, delete,\n-- or update a value in a \'Map\'.  In short: @\'lookup\' k \\<$\\> \'alterF\' f k m = f\n-- (\'lookup\' k m)@.\n--\n-- Example:\n--\n-- @\n-- interactiveAlter :: Int -> Map Int String -> IO (Map Int String)\n-- interactiveAlter k m = alterF f k m where\n--   f Nothing = do\n--      putStrLn $ show k ++\n--          " was not found in the map. Would you like to add it?"\n--      getUserResponse1 :: IO (Maybe String)\n--   f (Just old) = do\n--      putStrLn $ "The key is currently bound to " ++ show old ++\n--          ". Would you like to change or delete it?"\n--      getUserResponse2 :: IO (Maybe String)\n-- @\n--\n-- \'alterF\' is the most general operation for working with an individual\n-- key that may or may not be in a given map. When used with trivial\n-- functors like \'Identity\' and \'Const\', it is often slightly slower than\n-- more specialized combinators like \'lookup\' and \'insert\'. However, when\n-- the functor is non-trivial and key comparison is not particularly cheap,\n-- it is the fastest way.\n--\n-- Note on rewrite rules:\n--\n-- This module includes GHC rewrite rules to optimize \'alterF\' for\n-- the \'Const\' and \'Identity\' functors. In general, these rules\n-- improve performance. The sole exception is that when using\n-- \'Identity\', deleting a key that is already absent takes longer\n-- than it would without the rules. If you expect this to occur\n-- a very large fraction of the time, you might consider using a\n-- private copy of the \'Identity\' type.\n--\n-- Note: \'alterF\' is a flipped version of the @at@ combinator from\n-- @Control.Lens.At@.\n--\n-- @since 0.5.8\nalterF :: (Functor f, Ord k)\n       => (Maybe a -> f (Maybe a)) -> k -> Map k a -> f (Map k a)\nalterF f k m = atKeyImpl Lazy k f m\n\n#ifndef __GLASGOW_HASKELL__\n{-# INLINE alterF #-}\n#else\n{-# INLINABLE [2] alterF #-}\n\n-- We can save a little time by recognizing the special case of\n-- `Control.Applicative.Const` and just doing a lookup.\n{-# RULES\n"alterF/Const" forall k (f :: Maybe a -> Const b (Maybe a)) . alterF f k = \\m -> Const . getConst . f $ lookup k m\n #-}\n\n-- base 4.8 and above include Data.Functor.Identity, so we can\n-- save a pretty decent amount of time by handling it specially.\n{-# RULES\n"alterF/Identity" forall k f . alterF f k = atKeyIdentity k f\n #-}\n#endif\n\natKeyImpl :: (Functor f, Ord k) =>\n      AreWeStrict -> k -> (Maybe a -> f (Maybe a)) -> Map k a -> f (Map k a)\n#ifdef DEFINE_ALTERF_FALLBACK\natKeyImpl strict !k f m\n-- It doesn\'t seem sensible to worry about overflowing the queue\n-- if the word size is 61 or more. If I calculate it correctly,\n-- that would take a map with nearly a quadrillion entries.\n  | wordSize < 61 && size m >= alterFCutoff = alterFFallback strict k f m\n#endif\natKeyImpl strict !k f m = case lookupTrace k m of\n  TraceResult mv q -> (<$> f mv) $ \\ fres ->\n    case fres of\n      Nothing -> case mv of\n                   Nothing -> m\n                   Just old -> deleteAlong old q m\n      Just new -> case strict of\n         Strict -> new `seq` case mv of\n                      Nothing -> insertAlong q k new m\n                      Just _ -> replaceAlong q new m\n         Lazy -> case mv of\n                      Nothing -> insertAlong q k new m\n                      Just _ -> replaceAlong q new m\n\n{-# INLINE atKeyImpl #-}\n\n#ifdef DEFINE_ALTERF_FALLBACK\nalterFCutoff :: Int\n#if WORD_SIZE_IN_BITS == 32\nalterFCutoff = 55744454\n#else\nalterFCutoff = case wordSize of\n      30 -> 17637893\n      31 -> 31356255\n      32 -> 55744454\n      x -> (4^(x*2-2)) `quot` (3^(x*2-2))  -- Unlikely\n#endif\n#endif\n\ndata TraceResult a = TraceResult (Maybe a) {-# UNPACK #-} !BitQueue\n\n-- Look up a key and return a result indicating whether it was found\n-- and what path was taken.\nlookupTrace :: Ord k => k -> Map k a -> TraceResult a\nlookupTrace = go emptyQB\n  where\n    go :: Ord k => BitQueueB -> k -> Map k a -> TraceResult a\n    go !q !_ Tip = TraceResult Nothing (buildQ q)\n    go q k (Bin _ kx x l r) = case compare k kx of\n      LT -> (go $! q `snocQB` False) k l\n      GT -> (go $! q `snocQB` True) k r\n      EQ -> TraceResult (Just x) (buildQ q)\n\n#ifdef __GLASGOW_HASKELL__\n{-# INLINABLE lookupTrace #-}\n#else\n{-# INLINE lookupTrace #-}\n#endif\n\n-- Insert at a location (which will always be a leaf)\n-- described by the path passed in.\ninsertAlong :: BitQueue -> k -> a -> Map k a -> Map k a\ninsertAlong !_ kx x Tip = singleton kx x\ninsertAlong q kx x (Bin sz ky y l r) =\n  case unconsQ q of\n        Just (False, tl) -> balanceL ky y (insertAlong tl kx x l) r\n        Just (True,tl) -> balanceR ky y l (insertAlong tl kx x r)\n        Nothing -> Bin sz kx x l r  -- Shouldn\'t happen\n\n-- Delete from a location (which will always be a node)\n-- described by the path passed in.\n--\n-- This is fairly horrifying! We don\'t actually have any\n-- use for the old value we\'re deleting. But if GHC sees\n-- that, then it will allocate a thunk representing the\n-- Map with the key deleted before we have any reason to\n-- believe we\'ll actually want that. This transformation\n-- enhances sharing, but we don\'t care enough about that.\n-- So deleteAlong needs to take the old value, and we need\n-- to convince GHC somehow that it actually uses it. We\n-- can\'t NOINLINE deleteAlong, because that would prevent\n-- the BitQueue from being unboxed. So instead we pass the\n-- old value to a NOINLINE constant function and then\n-- convince GHC that we use the result throughout the\n-- computation. Doing the obvious thing and just passing\n-- the value itself through the recursion costs 3-4% time,\n-- so instead we convert the value to a magical zero-width\n-- proxy that\'s ultimately erased.\ndeleteAlong :: any -> BitQueue -> Map k a -> Map k a\ndeleteAlong old !q0 !m = go (bogus old) q0 m where\n#ifdef USE_MAGIC_PROXY\n  go :: Proxy# () -> BitQueue -> Map k a -> Map k a\n#else\n  go :: any -> BitQueue -> Map k a -> Map k a\n#endif\n  go !_ !_ Tip = Tip\n  go foom q (Bin _ ky y l r) =\n      case unconsQ q of\n        Just (False, tl) -> balanceR ky y (go foom tl l) r\n        Just (True, tl) -> balanceL ky y l (go foom tl r)\n        Nothing -> glue l r\n\n#ifdef USE_MAGIC_PROXY\n{-# NOINLINE bogus #-}\nbogus :: a -> Proxy# ()\nbogus _ = proxy#\n#else\n-- No point hiding in this case.\n{-# INLINE bogus #-}\nbogus :: a -> a\nbogus a = a\n#endif\n\n-- Replace the value found in the node described\n-- by the given path with a new one.\nreplaceAlong :: BitQueue -> a -> Map k a -> Map k a\nreplaceAlong !_ _ Tip = Tip -- Should not happen\nreplaceAlong q  x (Bin sz ky y l r) =\n      case unconsQ q of\n        Just (False, tl) -> Bin sz ky y (replaceAlong tl x l) r\n        Just (True,tl) -> Bin sz ky y l (replaceAlong tl x r)\n        Nothing -> Bin sz ky x l r\n\n#ifdef __GLASGOW_HASKELL__\natKeyIdentity :: Ord k => k -> (Maybe a -> Identity (Maybe a)) -> Map k a -> Identity (Map k a)\natKeyIdentity k f t = Identity $ atKeyPlain Lazy k (coerce f) t\n{-# INLINABLE atKeyIdentity #-}\n\natKeyPlain :: Ord k => AreWeStrict -> k -> (Maybe a -> Maybe a) -> Map k a -> Map k a\natKeyPlain strict k0 f0 t = case go k0 f0 t of\n    AltSmaller t\' -> t\'\n    AltBigger t\' -> t\'\n    AltAdj t\' -> t\'\n    AltSame -> t\n  where\n    go :: Ord k => k -> (Maybe a -> Maybe a) -> Map k a -> Altered k a\n    go !k f Tip = case f Nothing of\n                   Nothing -> AltSame\n                   Just x  -> case strict of\n                     Lazy -> AltBigger $ singleton k x\n                     Strict -> x `seq` (AltBigger $ singleton k x)\n\n    go k f (Bin sx kx x l r) = case compare k kx of\n                   LT -> case go k f l of\n                           AltSmaller l\' -> AltSmaller $ balanceR kx x l\' r\n                           AltBigger l\' -> AltBigger $ balanceL kx x l\' r\n                           AltAdj l\' -> AltAdj $ Bin sx kx x l\' r\n                           AltSame -> AltSame\n                   GT -> case go k f r of\n                           AltSmaller r\' -> AltSmaller $ balanceL kx x l r\'\n                           AltBigger r\' -> AltBigger $ balanceR kx x l r\'\n                           AltAdj r\' -> AltAdj $ Bin sx kx x l r\'\n                           AltSame -> AltSame\n                   EQ -> case f (Just x) of\n                           Just x\' -> case strict of\n                             Lazy -> AltAdj $ Bin sx kx x\' l r\n                             Strict -> x\' `seq` (AltAdj $ Bin sx kx x\' l r)\n                           Nothing -> AltSmaller $ glue l r\n{-# INLINE atKeyPlain #-}\n\ndata Altered k a = AltSmaller !(Map k a) | AltBigger !(Map k a) | AltAdj !(Map k a) | AltSame\n#endif\n\n#ifdef DEFINE_ALTERF_FALLBACK\n-- When the map is too large to use a bit queue, we fall back to\n-- this much slower version which uses a more "natural" implementation\n-- improved with Yoneda to avoid repeated fmaps. This works okayish for\n-- some operations, but it\'s pretty lousy for lookups.\nalterFFallback :: (Functor f, Ord k)\n   => AreWeStrict -> k -> (Maybe a -> f (Maybe a)) -> Map k a -> f (Map k a)\nalterFFallback Lazy k f t = alterFYoneda k (\\m q -> q <$> f m) t id\nalterFFallback Strict k f t = alterFYoneda k (\\m q -> q . forceMaybe <$> f m) t id\n  where\n    forceMaybe Nothing = Nothing\n    forceMaybe may@(Just !_) = may\n{-# NOINLINE alterFFallback #-}\n\nalterFYoneda :: Ord k =>\n      k -> (Maybe a -> (Maybe a -> b) -> f b) -> Map k a -> (Map k a -> b) -> f b\nalterFYoneda = go\n  where\n    go :: Ord k =>\n      k -> (Maybe a -> (Maybe a -> b) -> f b) -> Map k a -> (Map k a -> b) -> f b\n    go !k f Tip g = f Nothing $ \\ mx -> case mx of\n      Nothing -> g Tip\n      Just x -> g (singleton k x)\n    go k f (Bin sx kx x l r) g = case compare k kx of\n               LT -> go k f l (\\m -> g (balance kx x m r))\n               GT -> go k f r (\\m -> g (balance kx x l m))\n               EQ -> f (Just x) $ \\ mx\' -> case mx\' of\n                       Just x\' -> g (Bin sx kx x\' l r)\n                       Nothing -> g (glue l r)\n{-# INLINE alterFYoneda #-}\n#endif\n\n{--------------------------------------------------------------------\n  Indexing\n--------------------------------------------------------------------}\n-- | \\(O(\\log n)\\). Return the /index/ of a key, which is its zero-based index in\n-- the sequence sorted by keys. The index is a number from /0/ up to, but not\n-- including, the \'size\' of the map. Calls \'error\' when the key is not\n-- a \'member\' of the map.\n--\n-- > findIndex 2 (fromList [(5,"a"), (3,"b")])    Error: element is not in the map\n-- > findIndex 3 (fromList [(5,"a"), (3,"b")]) == 0\n-- > findIndex 5 (fromList [(5,"a"), (3,"b")]) == 1\n-- > findIndex 6 (fromList [(5,"a"), (3,"b")])    Error: element is not in the map\n\n-- See Note: Type of local \'go\' function\nfindIndex :: Ord k => k -> Map k a -> Int\nfindIndex = go 0\n  where\n    go :: Ord k => Int -> k -> Map k a -> Int\n    go !_   !_ Tip  = error "Map.findIndex: element is not in the map"\n    go idx k (Bin _ kx _ l r) = case compare k kx of\n      LT -> go idx k l\n      GT -> go (idx + size l + 1) k r\n      EQ -> idx + size l\n#if __GLASGOW_HASKELL__\n{-# INLINABLE findIndex #-}\n#endif\n\n-- | \\(O(\\log n)\\). Lookup the /index/ of a key, which is its zero-based index in\n-- the sequence sorted by keys. The index is a number from /0/ up to, but not\n-- including, the \'size\' of the map.\n--\n-- > isJust (lookupIndex 2 (fromList [(5,"a"), (3,"b")]))   == False\n-- > fromJust (lookupIndex 3 (fromList [(5,"a"), (3,"b")])) == 0\n-- > fromJust (lookupIndex 5 (fromList [(5,"a"), (3,"b")])) == 1\n-- > isJust (lookupIndex 6 (fromList [(5,"a"), (3,"b")]))   == False\n\n-- See Note: Type of local \'go\' function\nlookupIndex :: Ord k => k -> Map k a -> Maybe Int\nlookupIndex = go 0\n  where\n    go :: Ord k => Int -> k -> Map k a -> Maybe Int\n    go !_  !_ Tip  = Nothing\n    go idx k (Bin _ kx _ l r) = case compare k kx of\n      LT -> go idx k l\n      GT -> go (idx + size l + 1) k r\n      EQ -> Just $! idx + size l\n#if __GLASGOW_HASKELL__\n{-# INLINABLE lookupIndex #-}\n#endif\n\n-- | \\(O(\\log n)\\). Retrieve an element by its /index/, i.e. by its zero-based\n-- index in the sequence sorted by keys. If the /index/ is out of range (less\n-- than zero, greater or equal to \'size\' of the map), \'error\' is called.\n--\n-- > elemAt 0 (fromList [(5,"a"), (3,"b")]) == (3,"b")\n-- > elemAt 1 (fromList [(5,"a"), (3,"b")]) == (5, "a")\n-- > elemAt 2 (fromList [(5,"a"), (3,"b")])    Error: index out of range\n\nelemAt :: Int -> Map k a -> (k,a)\nelemAt !_ Tip = error "Map.elemAt: index out of range"\nelemAt i (Bin _ kx x l r)\n  = case compare i sizeL of\n      LT -> elemAt i l\n      GT -> elemAt (i-sizeL-1) r\n      EQ -> (kx,x)\n  where\n    sizeL = size l\n\n-- | \\(O(\\log n)\\). Take a given number of entries in key order, beginning\n-- with the smallest keys.\n--\n-- @\n-- take n = \'fromDistinctAscList\' . \'Prelude.take\' n . \'toAscList\'\n-- @\n--\n-- @since 0.5.8\n\ntake :: Int -> Map k a -> Map k a\ntake i m | i >= size m = m\ntake i0 m0 = go i0 m0\n  where\n    go i !_ | i <= 0 = Tip\n    go !_ Tip = Tip\n    go i (Bin _ kx x l r) =\n      case compare i sizeL of\n        LT -> go i l\n        GT -> link kx x l (go (i - sizeL - 1) r)\n        EQ -> l\n      where sizeL = size l\n\n-- | \\(O(\\log n)\\). Drop a given number of entries in key order, beginning\n-- with the smallest keys.\n--\n-- @\n-- drop n = \'fromDistinctAscList\' . \'Prelude.drop\' n . \'toAscList\'\n-- @\n--\n-- @since 0.5.8\ndrop :: Int -> Map k a -> Map k a\ndrop i m | i >= size m = Tip\ndrop i0 m0 = go i0 m0\n  where\n    go i m | i <= 0 = m\n    go !_ Tip = Tip\n    go i (Bin _ kx x l r) =\n      case compare i sizeL of\n        LT -> link kx x (go i l) r\n        GT -> go (i - sizeL - 1) r\n        EQ -> insertMin kx x r\n      where sizeL = size l\n\n-- | \\(O(\\log n)\\). Split a map at a particular index.\n--\n-- @\n-- splitAt !n !xs = (\'take\' n xs, \'drop\' n xs)\n-- @\n--\n-- @since 0.5.8\nsplitAt :: Int -> Map k a -> (Map k a, Map k a)\nsplitAt i0 m0\n  | i0 >= size m0 = (m0, Tip)\n  | otherwise = toPair $ go i0 m0\n  where\n    go i m | i <= 0 = Tip :*: m\n    go !_ Tip = Tip :*: Tip\n    go i (Bin _ kx x l r)\n      = case compare i sizeL of\n          LT -> case go i l of\n                  ll :*: lr -> ll :*: link kx x lr r\n          GT -> case go (i - sizeL - 1) r of\n                  rl :*: rr -> link kx x l rl :*: rr\n          EQ -> l :*: insertMin kx x r\n      where sizeL = size l\n\n-- | \\(O(\\log n)\\). Update the element at /index/, i.e. by its zero-based index in\n-- the sequence sorted by keys. If the /index/ is out of range (less than zero,\n-- greater or equal to \'size\' of the map), \'error\' is called.\n--\n-- > updateAt (\\ _ _ -> Just "x") 0    (fromList [(5,"a"), (3,"b")]) == fromList [(3, "x"), (5, "a")]\n-- > updateAt (\\ _ _ -> Just "x") 1    (fromList [(5,"a"), (3,"b")]) == fromList [(3, "b"), (5, "x")]\n-- > updateAt (\\ _ _ -> Just "x") 2    (fromList [(5,"a"), (3,"b")])    Error: index out of range\n-- > updateAt (\\ _ _ -> Just "x") (-1) (fromList [(5,"a"), (3,"b")])    Error: index out of range\n-- > updateAt (\\_ _  -> Nothing)  0    (fromList [(5,"a"), (3,"b")]) == singleton 5 "a"\n-- > updateAt (\\_ _  -> Nothing)  1    (fromList [(5,"a"), (3,"b")]) == singleton 3 "b"\n-- > updateAt (\\_ _  -> Nothing)  2    (fromList [(5,"a"), (3,"b")])    Error: index out of range\n-- > updateAt (\\_ _  -> Nothing)  (-1) (fromList [(5,"a"), (3,"b")])    Error: index out of range\n\nupdateAt :: (k -> a -> Maybe a) -> Int -> Map k a -> Map k a\nupdateAt f !i t =\n  case t of\n    Tip -> error "Map.updateAt: index out of range"\n    Bin sx kx x l r -> case compare i sizeL of\n      LT -> balanceR kx x (updateAt f i l) r\n      GT -> balanceL kx x l (updateAt f (i-sizeL-1) r)\n      EQ -> case f kx x of\n              Just x\' -> Bin sx kx x\' l r\n              Nothing -> glue l r\n      where\n        sizeL = size l\n\n-- | \\(O(\\log n)\\). Delete the element at /index/, i.e. by its zero-based index in\n-- the sequence sorted by keys. If the /index/ is out of range (less than zero,\n-- greater or equal to \'size\' of the map), \'error\' is called.\n--\n-- > deleteAt 0  (fromList [(5,"a"), (3,"b")]) == singleton 5 "a"\n-- > deleteAt 1  (fromList [(5,"a"), (3,"b")]) == singleton 3 "b"\n-- > deleteAt 2 (fromList [(5,"a"), (3,"b")])     Error: index out of range\n-- > deleteAt (-1) (fromList [(5,"a"), (3,"b")])  Error: index out of range\n\ndeleteAt :: Int -> Map k a -> Map k a\ndeleteAt !i t =\n  case t of\n    Tip -> error "Map.deleteAt: index out of range"\n    Bin _ kx x l r -> case compare i sizeL of\n      LT -> balanceR kx x (deleteAt i l) r\n      GT -> balanceL kx x l (deleteAt (i-sizeL-1) r)\n      EQ -> glue l r\n      where\n        sizeL = size l\n\n\n{--------------------------------------------------------------------\n  Minimal, Maximal\n--------------------------------------------------------------------}\n\nlookupMinSure :: k -> a -> Map k a -> (k, a)\nlookupMinSure k a Tip = (k, a)\nlookupMinSure _ _ (Bin _ k a l _) = lookupMinSure k a l\n\n-- | \\(O(\\log n)\\). The minimal key of the map. Returns \'Nothing\' if the map is empty.\n--\n-- > lookupMin (fromList [(5,"a"), (3,"b")]) == Just (3,"b")\n-- > lookupMin empty = Nothing\n--\n-- @since 0.5.9\n\nlookupMin :: Map k a -> Maybe (k,a)\nlookupMin Tip = Nothing\nlookupMin (Bin _ k x l _) = Just $! lookupMinSure k x l\n\n-- | \\(O(\\log n)\\). The minimal key of the map. Calls \'error\' if the map is empty.\n--\n-- > findMin (fromList [(5,"a"), (3,"b")]) == (3,"b")\n-- > findMin empty                            Error: empty map has no minimal element\n\nfindMin :: Map k a -> (k,a)\nfindMin t\n  | Just r <- lookupMin t = r\n  | otherwise = error "Map.findMin: empty map has no minimal element"\n\nlookupMaxSure :: k -> a -> Map k a -> (k, a)\nlookupMaxSure k a Tip = (k, a)\nlookupMaxSure _ _ (Bin _ k a _ r) = lookupMaxSure k a r\n\n-- | \\(O(\\log n)\\). The maximal key of the map. Returns \'Nothing\' if the map is empty.\n--\n-- > lookupMax (fromList [(5,"a"), (3,"b")]) == Just (5,"a")\n-- > lookupMax empty = Nothing\n--\n-- @since 0.5.9\n\nlookupMax :: Map k a -> Maybe (k, a)\nlookupMax Tip = Nothing\nlookupMax (Bin _ k x _ r) = Just $! lookupMaxSure k x r\n\n-- | \\(O(\\log n)\\). The maximal key of the map. Calls \'error\' if the map is empty.\n--\n-- > findMax (fromList [(5,"a"), (3,"b")]) == (5,"a")\n-- > findMax empty                            Error: empty map has no maximal element\n\nfindMax :: Map k a -> (k,a)\nfindMax t\n  | Just r <- lookupMax t = r\n  | otherwise = error "Map.findMax: empty map has no maximal element"\n\n-- | \\(O(\\log n)\\). Delete the minimal key. Returns an empty map if the map is empty.\n--\n-- > deleteMin (fromList [(5,"a"), (3,"b"), (7,"c")]) == fromList [(5,"a"), (7,"c")]\n-- > deleteMin empty == empty\n\ndeleteMin :: Map k a -> Map k a\ndeleteMin (Bin _ _  _ Tip r)  = r\ndeleteMin (Bin _ kx x l r)    = balanceR kx x (deleteMin l) r\ndeleteMin Tip                 = Tip\n\n-- | \\(O(\\log n)\\). Delete the maximal key. Returns an empty map if the map is empty.\n--\n-- > deleteMax (fromList [(5,"a"), (3,"b"), (7,"c")]) == fromList [(3,"b"), (5,"a")]\n-- > deleteMax empty == empty\n\ndeleteMax :: Map k a -> Map k a\ndeleteMax (Bin _ _  _ l Tip)  = l\ndeleteMax (Bin _ kx x l r)    = balanceL kx x l (deleteMax r)\ndeleteMax Tip                 = Tip\n\n-- | \\(O(\\log n)\\). Update the value at the minimal key.\n--\n-- > updateMin (\\ a -> Just ("X" ++ a)) (fromList [(5,"a"), (3,"b")]) == fromList [(3, "Xb"), (5, "a")]\n-- > updateMin (\\ _ -> Nothing)         (fromList [(5,"a"), (3,"b")]) == singleton 5 "a"\n\nupdateMin :: (a -> Maybe a) -> Map k a -> Map k a\nupdateMin f m\n  = updateMinWithKey (\\_ x -> f x) m\n\n-- | \\(O(\\log n)\\). Update the value at the maximal key.\n--\n-- > updateMax (\\ a -> Just ("X" ++ a)) (fromList [(5,"a"), (3,"b")]) == fromList [(3, "b"), (5, "Xa")]\n-- > updateMax (\\ _ -> Nothing)         (fromList [(5,"a"), (3,"b")]) == singleton 3 "b"\n\nupdateMax :: (a -> Maybe a) -> Map k a -> Map k a\nupdateMax f m\n  = updateMaxWithKey (\\_ x -> f x) m\n\n\n-- | \\(O(\\log n)\\). Update the value at the minimal key.\n--\n-- > updateMinWithKey (\\ k a -> Just ((show k) ++ ":" ++ a)) (fromList [(5,"a"), (3,"b")]) == fromList [(3,"3:b"), (5,"a")]\n-- > updateMinWithKey (\\ _ _ -> Nothing)                     (fromList [(5,"a"), (3,"b")]) == singleton 5 "a"\n\nupdateMinWithKey :: (k -> a -> Maybe a) -> Map k a -> Map k a\nupdateMinWithKey _ Tip                 = Tip\nupdateMinWithKey f (Bin sx kx x Tip r) = case f kx x of\n                                           Nothing -> r\n                                           Just x\' -> Bin sx kx x\' Tip r\nupdateMinWithKey f (Bin _ kx x l r)    = balanceR kx x (updateMinWithKey f l) r\n\n-- | \\(O(\\log n)\\). Update the value at the maximal key.\n--\n-- > updateMaxWithKey (\\ k a -> Just ((show k) ++ ":" ++ a)) (fromList [(5,"a"), (3,"b")]) == fromList [(3,"b"), (5,"5:a")]\n-- > updateMaxWithKey (\\ _ _ -> Nothing)                     (fromList [(5,"a"), (3,"b")]) == singleton 3 "b"\n\nupdateMaxWithKey :: (k -> a -> Maybe a) -> Map k a -> Map k a\nupdateMaxWithKey _ Tip                 = Tip\nupdateMaxWithKey f (Bin sx kx x l Tip) = case f kx x of\n                                           Nothing -> l\n                                           Just x\' -> Bin sx kx x\' l Tip\nupdateMaxWithKey f (Bin _ kx x l r)    = balanceL kx x l (updateMaxWithKey f r)\n\n-- | \\(O(\\log n)\\). Retrieves the minimal (key,value) pair of the map, and\n-- the map stripped of that element, or \'Nothing\' if passed an empty map.\n--\n-- > minViewWithKey (fromList [(5,"a"), (3,"b")]) == Just ((3,"b"), singleton 5 "a")\n-- > minViewWithKey empty == Nothing\n\nminViewWithKey :: Map k a -> Maybe ((k,a), Map k a)\nminViewWithKey Tip = Nothing\nminViewWithKey (Bin _ k x l r) = Just $\n  case minViewSure k x l r of\n    MinView km xm t -> ((km, xm), t)\n-- We inline this to give GHC the best possible chance of getting\n-- rid of the Maybe and pair constructors, as well as the thunk under\n-- the Just.\n{-# INLINE minViewWithKey #-}\n\n-- | \\(O(\\log n)\\). Retrieves the maximal (key,value) pair of the map, and\n-- the map stripped of that element, or \'Nothing\' if passed an empty map.\n--\n-- > maxViewWithKey (fromList [(5,"a"), (3,"b")]) == Just ((5,"a"), singleton 3 "b")\n-- > maxViewWithKey empty == Nothing\n\nmaxViewWithKey :: Map k a -> Maybe ((k,a), Map k a)\nmaxViewWithKey Tip = Nothing\nmaxViewWithKey (Bin _ k x l r) = Just $\n  case maxViewSure k x l r of\n    MaxView km xm t -> ((km, xm), t)\n-- See note on inlining at minViewWithKey\n{-# INLINE maxViewWithKey #-}\n\n-- | \\(O(\\log n)\\). Retrieves the value associated with minimal key of the\n-- map, and the map stripped of that element, or \'Nothing\' if passed an\n-- empty map.\n--\n-- > minView (fromList [(5,"a"), (3,"b")]) == Just ("b", singleton 5 "a")\n-- > minView empty == Nothing\n\nminView :: Map k a -> Maybe (a, Map k a)\nminView t = case minViewWithKey t of\n              Nothing -> Nothing\n              Just ~((_, x), t\') -> Just (x, t\')\n\n-- | \\(O(\\log n)\\). Retrieves the value associated with maximal key of the\n-- map, and the map stripped of that element, or \'Nothing\' if passed an\n-- empty map.\n--\n-- > maxView (fromList [(5,"a"), (3,"b")]) == Just ("a", singleton 3 "b")\n-- > maxView empty == Nothing\n\nmaxView :: Map k a -> Maybe (a, Map k a)\nmaxView t = case maxViewWithKey t of\n              Nothing -> Nothing\n              Just ~((_, x), t\') -> Just (x, t\')\n\n{--------------------------------------------------------------------\n  Union.\n--------------------------------------------------------------------}\n-- | The union of a list of maps:\n--   (@\'unions\' == \'Prelude.foldl\' \'union\' \'empty\'@).\n--\n-- > unions [(fromList [(5, "a"), (3, "b")]), (fromList [(5, "A"), (7, "C")]), (fromList [(5, "A3"), (3, "B3")])]\n-- >     == fromList [(3, "b"), (5, "a"), (7, "C")]\n-- > unions [(fromList [(5, "A3"), (3, "B3")]), (fromList [(5, "A"), (7, "C")]), (fromList [(5, "a"), (3, "b")])]\n-- >     == fromList [(3, "B3"), (5, "A3"), (7, "C")]\n\nunions :: (Foldable f, Ord k) => f (Map k a) -> Map k a\nunions ts\n  = Foldable.foldl\' union empty ts\n#if __GLASGOW_HASKELL__\n{-# INLINABLE unions #-}\n#endif\n\n-- | The union of a list of maps, with a combining operation:\n--   (@\'unionsWith\' f == \'Prelude.foldl\' (\'unionWith\' f) \'empty\'@).\n--\n-- > unionsWith (++) [(fromList [(5, "a"), (3, "b")]), (fromList [(5, "A"), (7, "C")]), (fromList [(5, "A3"), (3, "B3")])]\n-- >     == fromList [(3, "bB3"), (5, "aAA3"), (7, "C")]\n\nunionsWith :: (Foldable f, Ord k) => (a->a->a) -> f (Map k a) -> Map k a\nunionsWith f ts\n  = Foldable.foldl\' (unionWith f) empty ts\n#if __GLASGOW_HASKELL__\n{-# INLINABLE unionsWith #-}\n#endif\n\n-- | \\(O\\bigl(m \\log\\bigl(\\frac{n+1}{m+1}\\bigr)\\bigr), \\; m \\leq n\\).\n-- The expression (@\'union\' t1 t2@) takes the left-biased union of @t1@ and @t2@.\n-- It prefers @t1@ when duplicate keys are encountered,\n-- i.e. (@\'union\' == \'unionWith\' \'const\'@).\n--\n-- > union (fromList [(5, "a"), (3, "b")]) (fromList [(5, "A"), (7, "C")]) == fromList [(3, "b"), (5, "a"), (7, "C")]\n\nunion :: Ord k => Map k a -> Map k a -> Map k a\nunion t1 Tip  = t1\nunion t1 (Bin _ k x Tip Tip) = insertR k x t1\nunion (Bin _ k x Tip Tip) t2 = insert k x t2\nunion Tip t2 = t2\nunion t1@(Bin _ k1 x1 l1 r1) t2 = case split k1 t2 of\n  (l2, r2) | l1l2 `ptrEq` l1 && r1r2 `ptrEq` r1 -> t1\n           | otherwise -> link k1 x1 l1l2 r1r2\n           where !l1l2 = union l1 l2\n                 !r1r2 = union r1 r2\n#if __GLASGOW_HASKELL__\n{-# INLINABLE union #-}\n#endif\n\n{--------------------------------------------------------------------\n  Union with a combining function\n--------------------------------------------------------------------}\n-- | \\(O\\bigl(m \\log\\bigl(\\frac{n+1}{m+1}\\bigr)\\bigr), \\; m \\leq n\\). Union with a combining function.\n--\n-- > unionWith (++) (fromList [(5, "a"), (3, "b")]) (fromList [(5, "A"), (7, "C")]) == fromList [(3, "b"), (5, "aA"), (7, "C")]\n\nunionWith :: Ord k => (a -> a -> a) -> Map k a -> Map k a -> Map k a\n-- QuickCheck says pointer equality never happens here.\nunionWith _f t1 Tip = t1\nunionWith f t1 (Bin _ k x Tip Tip) = insertWithR f k x t1\nunionWith f (Bin _ k x Tip Tip) t2 = insertWith f k x t2\nunionWith _f Tip t2 = t2\nunionWith f (Bin _ k1 x1 l1 r1) t2 = case splitLookup k1 t2 of\n  (l2, mb, r2) -> case mb of\n      Nothing -> link k1 x1 l1l2 r1r2\n      Just x2 -> link k1 (f x1 x2) l1l2 r1r2\n    where !l1l2 = unionWith f l1 l2\n          !r1r2 = unionWith f r1 r2\n#if __GLASGOW_HASKELL__\n{-# INLINABLE unionWith #-}\n#endif\n\n-- | \\(O\\bigl(m \\log\\bigl(\\frac{n+1}{m+1}\\bigr)\\bigr), \\; m \\leq n\\).\n-- Union with a combining function.\n--\n-- > let f key left_value right_value = (show key) ++ ":" ++ left_value ++ "|" ++ right_value\n-- > unionWithKey f (fromList [(5, "a"), (3, "b")]) (fromList [(5, "A"), (7, "C")]) == fromList [(3, "b"), (5, "5:a|A"), (7, "C")]\n\nunionWithKey :: Ord k => (k -> a -> a -> a) -> Map k a -> Map k a -> Map k a\nunionWithKey _f t1 Tip = t1\nunionWithKey f t1 (Bin _ k x Tip Tip) = insertWithKeyR f k x t1\nunionWithKey f (Bin _ k x Tip Tip) t2 = insertWithKey f k x t2\nunionWithKey _f Tip t2 = t2\nunionWithKey f (Bin _ k1 x1 l1 r1) t2 = case splitLookup k1 t2 of\n  (l2, mb, r2) -> case mb of\n      Nothing -> link k1 x1 l1l2 r1r2\n      Just x2 -> link k1 (f k1 x1 x2) l1l2 r1r2\n    where !l1l2 = unionWithKey f l1 l2\n          !r1r2 = unionWithKey f r1 r2\n#if __GLASGOW_HASKELL__\n{-# INLINABLE unionWithKey #-}\n#endif\n\n{--------------------------------------------------------------------\n  Difference\n--------------------------------------------------------------------}\n\n-- We don\'t currently attempt to use any pointer equality tricks for\n-- \'difference\'. To do so, we\'d have to match on the first argument\n-- and split the second. Unfortunately, the proof of the time bound\n-- relies on doing it the way we do, and it\'s not clear whether that\n-- bound holds the other way.\n\n-- | \\(O\\bigl(m \\log\\bigl(\\frac{n+1}{m+1}\\bigr)\\bigr), \\; m \\leq n\\). Difference of two maps.\n-- Return elements of the first map not existing in the second map.\n--\n-- > difference (fromList [(5, "a"), (3, "b")]) (fromList [(5, "A"), (7, "C")]) == singleton 3 "b"\n\ndifference :: Ord k => Map k a -> Map k b -> Map k a\ndifference Tip _   = Tip\ndifference t1 Tip  = t1\ndifference t1 (Bin _ k _ l2 r2) = case split k t1 of\n  (l1, r1)\n    | size l1l2 + size r1r2 == size t1 -> t1\n    | otherwise -> link2 l1l2 r1r2\n    where\n      !l1l2 = difference l1 l2\n      !r1r2 = difference r1 r2\n#if __GLASGOW_HASKELL__\n{-# INLINABLE difference #-}\n#endif\n\n-- | \\(O\\bigl(m \\log\\bigl(\\frac{n+1}{m+1}\\bigr)\\bigr), \\; m \\leq n\\). Remove all keys in a \'Set\' from a \'Map\'.\n--\n-- @\n-- m \\`withoutKeys\\` s = \'filterWithKey\' (\\\\k _ -> k ``Set.notMember`` s) m\n-- m \\`withoutKeys\\` s = m ``difference`` \'fromSet\' (const ()) s\n-- @\n--\n-- @since 0.5.8\n\nwithoutKeys :: Ord k => Map k a -> Set k -> Map k a\nwithoutKeys Tip _ = Tip\nwithoutKeys m Set.Tip = m\nwithoutKeys m (Set.Bin _ k ls rs) = case splitMember k m of\n  (lm, b, rm)\n     | not b && lm\' `ptrEq` lm && rm\' `ptrEq` rm -> m\n     | otherwise -> link2 lm\' rm\'\n     where\n       !lm\' = withoutKeys lm ls\n       !rm\' = withoutKeys rm rs\n#if __GLASGOW_HASKELL__\n{-# INLINABLE withoutKeys #-}\n#endif\n\n-- | \\(O(n+m)\\). Difference with a combining function.\n-- When two equal keys are\n-- encountered, the combining function is applied to the values of these keys.\n-- If it returns \'Nothing\', the element is discarded (proper set difference). If\n-- it returns (@\'Just\' y@), the element is updated with a new value @y@.\n--\n-- > let f al ar = if al == "b" then Just (al ++ ":" ++ ar) else Nothing\n-- > differenceWith f (fromList [(5, "a"), (3, "b")]) (fromList [(5, "A"), (3, "B"), (7, "C")])\n-- >     == singleton 3 "b:B"\ndifferenceWith :: Ord k => (a -> b -> Maybe a) -> Map k a -> Map k b -> Map k a\ndifferenceWith f = merge preserveMissing dropMissing $\n       zipWithMaybeMatched (\\_ x y -> f x y)\n#if __GLASGOW_HASKELL__\n{-# INLINABLE differenceWith #-}\n#endif\n\n-- | \\(O(n+m)\\). Difference with a combining function. When two equal keys are\n-- encountered, the combining function is applied to the key and both values.\n-- If it returns \'Nothing\', the element is discarded (proper set difference). If\n-- it returns (@\'Just\' y@), the element is updated with a new value @y@.\n--\n-- > let f k al ar = if al == "b" then Just ((show k) ++ ":" ++ al ++ "|" ++ ar) else Nothing\n-- > differenceWithKey f (fromList [(5, "a"), (3, "b")]) (fromList [(5, "A"), (3, "B"), (10, "C")])\n-- >     == singleton 3 "3:b|B"\n\ndifferenceWithKey :: Ord k => (k -> a -> b -> Maybe a) -> Map k a -> Map k b -> Map k a\ndifferenceWithKey f =\n  merge preserveMissing dropMissing (zipWithMaybeMatched f)\n#if __GLASGOW_HASKELL__\n{-# INLINABLE differenceWithKey #-}\n#endif\n\n\n{--------------------------------------------------------------------\n  Intersection\n--------------------------------------------------------------------}\n-- | \\(O\\bigl(m \\log\\bigl(\\frac{n+1}{m+1}\\bigr)\\bigr), \\; m \\leq n\\). Intersection of two maps.\n-- Return data in the first map for the keys existing in both maps.\n-- (@\'intersection\' m1 m2 == \'intersectionWith\' \'const\' m1 m2@).\n--\n-- > intersection (fromList [(5, "a"), (3, "b")]) (fromList [(5, "A"), (7, "C")]) == singleton 5 "a"\n\nintersection :: Ord k => Map k a -> Map k b -> Map k a\nintersection Tip _ = Tip\nintersection _ Tip = Tip\nintersection t1@(Bin _ k x l1 r1) t2\n  | mb = if l1l2 `ptrEq` l1 && r1r2 `ptrEq` r1\n         then t1\n         else link k x l1l2 r1r2\n  | otherwise = link2 l1l2 r1r2\n  where\n    !(l2, mb, r2) = splitMember k t2\n    !l1l2 = intersection l1 l2\n    !r1r2 = intersection r1 r2\n#if __GLASGOW_HASKELL__\n{-# INLINABLE intersection #-}\n#endif\n\n-- | \\(O\\bigl(m \\log\\bigl(\\frac{n+1}{m+1}\\bigr)\\bigr), \\; m \\leq n\\). Restrict a \'Map\' to only those keys\n-- found in a \'Set\'.\n--\n-- @\n-- m \\`restrictKeys\\` s = \'filterWithKey\' (\\\\k _ -> k ``Set.member`` s) m\n-- m \\`restrictKeys\\` s = m ``intersection`` \'fromSet\' (const ()) s\n-- @\n--\n-- @since 0.5.8\nrestrictKeys :: Ord k => Map k a -> Set k -> Map k a\nrestrictKeys Tip _ = Tip\nrestrictKeys _ Set.Tip = Tip\nrestrictKeys m@(Bin _ k x l1 r1) s\n  | b = if l1l2 `ptrEq` l1 && r1r2 `ptrEq` r1\n        then m\n        else link k x l1l2 r1r2\n  | otherwise = link2 l1l2 r1r2\n  where\n    !(l2, b, r2) = Set.splitMember k s\n    !l1l2 = restrictKeys l1 l2\n    !r1r2 = restrictKeys r1 r2\n#if __GLASGOW_HASKELL__\n{-# INLINABLE restrictKeys #-}\n#endif\n\n-- | \\(O\\bigl(m \\log\\bigl(\\frac{n+1}{m+1}\\bigr)\\bigr), \\; m \\leq n\\). Intersection with a combining function.\n--\n-- > intersectionWith (++) (fromList [(5, "a"), (3, "b")]) (fromList [(5, "A"), (7, "C")]) == singleton 5 "aA"\n\nintersectionWith :: Ord k => (a -> b -> c) -> Map k a -> Map k b -> Map k c\n-- We have no hope of pointer equality tricks here because every single\n-- element in the result will be a thunk.\nintersectionWith _f Tip _ = Tip\nintersectionWith _f _ Tip = Tip\nintersectionWith f (Bin _ k x1 l1 r1) t2 = case mb of\n    Just x2 -> link k (f x1 x2) l1l2 r1r2\n    Nothing -> link2 l1l2 r1r2\n  where\n    !(l2, mb, r2) = splitLookup k t2\n    !l1l2 = intersectionWith f l1 l2\n    !r1r2 = intersectionWith f r1 r2\n#if __GLASGOW_HASKELL__\n{-# INLINABLE intersectionWith #-}\n#endif\n\n-- | \\(O\\bigl(m \\log\\bigl(\\frac{n+1}{m+1}\\bigr)\\bigr), \\; m \\leq n\\). Intersection with a combining function.\n--\n-- > let f k al ar = (show k) ++ ":" ++ al ++ "|" ++ ar\n-- > intersectionWithKey f (fromList [(5, "a"), (3, "b")]) (fromList [(5, "A"), (7, "C")]) == singleton 5 "5:a|A"\n\nintersectionWithKey :: Ord k => (k -> a -> b -> c) -> Map k a -> Map k b -> Map k c\nintersectionWithKey _f Tip _ = Tip\nintersectionWithKey _f _ Tip = Tip\nintersectionWithKey f (Bin _ k x1 l1 r1) t2 = case mb of\n    Just x2 -> link k (f k x1 x2) l1l2 r1r2\n    Nothing -> link2 l1l2 r1r2\n  where\n    !(l2, mb, r2) = splitLookup k t2\n    !l1l2 = intersectionWithKey f l1 l2\n    !r1r2 = intersectionWithKey f r1 r2\n#if __GLASGOW_HASKELL__\n{-# INLINABLE intersectionWithKey #-}\n#endif\n\n{--------------------------------------------------------------------\n  Disjoint\n--------------------------------------------------------------------}\n-- | \\(O\\bigl(m \\log\\bigl(\\frac{n+1}{m+1}\\bigr)\\bigr), \\; m \\leq n\\). Check whether the key sets of two\n-- maps are disjoint (i.e., their \'intersection\' is empty).\n--\n-- > disjoint (fromList [(2,\'a\')]) (fromList [(1,()), (3,())])   == True\n-- > disjoint (fromList [(2,\'a\')]) (fromList [(1,\'a\'), (2,\'b\')]) == False\n-- > disjoint (fromList [])        (fromList [])                 == True\n--\n-- @\n-- xs ``disjoint`` ys = null (xs ``intersection`` ys)\n-- @\n--\n-- @since 0.6.2.1\n\n-- See \'Data.Set.Internal.isSubsetOfX\' for some background\n-- on the implementation design.\ndisjoint :: Ord k => Map k a -> Map k b -> Bool\ndisjoint Tip _ = True\ndisjoint _ Tip = True\ndisjoint (Bin 1 k _ _ _) t = k `notMember` t\ndisjoint (Bin _ k _ l r) t\n  = not found && disjoint l lt && disjoint r gt\n  where\n    (lt,found,gt) = splitMember k t\n\n{--------------------------------------------------------------------\n  Compose\n--------------------------------------------------------------------}\n-- | Relate the keys of one map to the values of\n-- the other, by using the values of the former as keys for lookups\n-- in the latter.\n--\n-- Complexity: \\( O (n * \\log(m)) \\), where \\(m\\) is the size of the first argument\n--\n-- > compose (fromList [(\'a\', "A"), (\'b\', "B")]) (fromList [(1,\'a\'),(2,\'b\'),(3,\'z\')]) = fromList [(1,"A"),(2,"B")]\n--\n-- @\n-- (\'compose\' bc ab \'!?\') = (bc \'!?\') <=< (ab \'!?\')\n-- @\n--\n-- __Note:__ Prior to v0.6.4, "Data.Map.Strict" exposed a version of\n-- \'compose\' that forced the values of the output \'Map\'. This version does not\n-- force these values.\n--\n-- @since 0.6.3.1\ncompose :: Ord b => Map b c -> Map a b -> Map a c\ncompose bc !ab\n  | null bc = empty\n  | otherwise = mapMaybe (bc !?) ab\n\n-- | A tactic for dealing with keys present in one map but not the other in\n-- \'merge\' or \'mergeA\'.\n--\n-- A tactic of type @ WhenMissing f k x z @ is an abstract representation\n-- of a function of type @ k -> x -> f (Maybe z) @.\n--\n-- @since 0.5.9\n\ndata WhenMissing f k x y = WhenMissing\n  { missingSubtree :: Map k x -> f (Map k y)\n  , missingKey :: k -> x -> f (Maybe y)}\n\n-- | @since 0.5.9\ninstance (Applicative f, Monad f) => Functor (WhenMissing f k x) where\n  fmap = mapWhenMissing\n  {-# INLINE fmap #-}\n\n-- | @since 0.5.9\ninstance (Applicative f, Monad f)\n         => Category.Category (WhenMissing f k) where\n  id = preserveMissing\n  f . g = traverseMaybeMissing $\n    \\ k x -> missingKey g k x >>= \\y ->\n         case y of\n           Nothing -> pure Nothing\n           Just q -> missingKey f k q\n  {-# INLINE id #-}\n  {-# INLINE (.) #-}\n\n-- | Equivalent to @ ReaderT k (ReaderT x (MaybeT f)) @.\n--\n-- @since 0.5.9\ninstance (Applicative f, Monad f) => Applicative (WhenMissing f k x) where\n  pure x = mapMissing (\\ _ _ -> x)\n  f <*> g = traverseMaybeMissing $ \\k x -> do\n         res1 <- missingKey f k x\n         case res1 of\n           Nothing -> pure Nothing\n           Just r -> (pure $!) . fmap r =<< missingKey g k x\n  {-# INLINE pure #-}\n  {-# INLINE (<*>) #-}\n\n-- | Equivalent to @ ReaderT k (ReaderT x (MaybeT f)) @.\n--\n-- @since 0.5.9\ninstance (Applicative f, Monad f) => Monad (WhenMissing f k x) where\n  m >>= f = traverseMaybeMissing $ \\k x -> do\n         res1 <- missingKey m k x\n         case res1 of\n           Nothing -> pure Nothing\n           Just r -> missingKey (f r) k x\n  {-# INLINE (>>=) #-}\n\n-- | Map covariantly over a @\'WhenMissing\' f k x@.\n--\n-- @since 0.5.9\nmapWhenMissing :: (Applicative f, Monad f)\n               => (a -> b)\n               -> WhenMissing f k x a -> WhenMissing f k x b\nmapWhenMissing f t = WhenMissing\n    { missingSubtree = \\m -> missingSubtree t m >>= \\m\' -> pure $! fmap f m\'\n    , missingKey = \\k x -> missingKey t k x >>= \\q -> (pure $! fmap f q) }\n{-# INLINE mapWhenMissing #-}\n\n-- | Map covariantly over a @\'WhenMissing\' f k x@, using only a \'Functor f\'\n-- constraint.\nmapGentlyWhenMissing :: Functor f\n               => (a -> b)\n               -> WhenMissing f k x a -> WhenMissing f k x b\nmapGentlyWhenMissing f t = WhenMissing\n    { missingSubtree = \\m -> fmap f <$> missingSubtree t m\n    , missingKey = \\k x -> fmap f <$> missingKey t k x }\n{-# INLINE mapGentlyWhenMissing #-}\n\n-- | Map covariantly over a @\'WhenMatched\' f k x@, using only a \'Functor f\'\n-- constraint.\nmapGentlyWhenMatched :: Functor f\n               => (a -> b)\n               -> WhenMatched f k x y a -> WhenMatched f k x y b\nmapGentlyWhenMatched f t = zipWithMaybeAMatched $\n  \\k x y -> fmap f <$> runWhenMatched t k x y\n{-# INLINE mapGentlyWhenMatched #-}\n\n-- | Map contravariantly over a @\'WhenMissing\' f k _ x@.\n--\n-- @since 0.5.9\nlmapWhenMissing :: (b -> a) -> WhenMissing f k a x -> WhenMissing f k b x\nlmapWhenMissing f t = WhenMissing\n  { missingSubtree = \\m -> missingSubtree t (fmap f m)\n  , missingKey = \\k x -> missingKey t k (f x) }\n{-# INLINE lmapWhenMissing #-}\n\n-- | Map contravariantly over a @\'WhenMatched\' f k _ y z@.\n--\n-- @since 0.5.9\ncontramapFirstWhenMatched :: (b -> a)\n                          -> WhenMatched f k a y z\n                          -> WhenMatched f k b y z\ncontramapFirstWhenMatched f t = WhenMatched $\n  \\k x y -> runWhenMatched t k (f x) y\n{-# INLINE contramapFirstWhenMatched #-}\n\n-- | Map contravariantly over a @\'WhenMatched\' f k x _ z@.\n--\n-- @since 0.5.9\ncontramapSecondWhenMatched :: (b -> a)\n                           -> WhenMatched f k x a z\n                           -> WhenMatched f k x b z\ncontramapSecondWhenMatched f t = WhenMatched $\n  \\k x y -> runWhenMatched t k x (f y)\n{-# INLINE contramapSecondWhenMatched #-}\n\n-- | A tactic for dealing with keys present in one map but not the other in\n-- \'merge\'.\n--\n-- A tactic of type @ SimpleWhenMissing k x z @ is an abstract representation\n-- of a function of type @ k -> x -> Maybe z @.\n--\n-- @since 0.5.9\ntype SimpleWhenMissing = WhenMissing Identity\n\n-- | A tactic for dealing with keys present in both\n-- maps in \'merge\' or \'mergeA\'.\n--\n-- A tactic of type @ WhenMatched f k x y z @ is an abstract representation\n-- of a function of type @ k -> x -> y -> f (Maybe z) @.\n--\n-- @since 0.5.9\nnewtype WhenMatched f k x y z = WhenMatched\n  { matchedKey :: k -> x -> y -> f (Maybe z) }\n\n-- | Along with zipWithMaybeAMatched, witnesses the isomorphism between\n-- @WhenMatched f k x y z@ and @k -> x -> y -> f (Maybe z)@.\n--\n-- @since 0.5.9\nrunWhenMatched :: WhenMatched f k x y z -> k -> x -> y -> f (Maybe z)\nrunWhenMatched = matchedKey\n{-# INLINE runWhenMatched #-}\n\n-- | Along with traverseMaybeMissing, witnesses the isomorphism between\n-- @WhenMissing f k x y@ and @k -> x -> f (Maybe y)@.\n--\n-- @since 0.5.9\nrunWhenMissing :: WhenMissing f k x y -> k -> x -> f (Maybe y)\nrunWhenMissing = missingKey\n{-# INLINE runWhenMissing #-}\n\n-- | @since 0.5.9\ninstance Functor f => Functor (WhenMatched f k x y) where\n  fmap = mapWhenMatched\n  {-# INLINE fmap #-}\n\n-- | @since 0.5.9\ninstance (Monad f, Applicative f) => Category.Category (WhenMatched f k x) where\n  id = zipWithMatched (\\_ _ y -> y)\n  f . g = zipWithMaybeAMatched $\n            \\k x y -> do\n              res <- runWhenMatched g k x y\n              case res of\n                Nothing -> pure Nothing\n                Just r -> runWhenMatched f k x r\n  {-# INLINE id #-}\n  {-# INLINE (.) #-}\n\n-- | Equivalent to @ ReaderT k (ReaderT x (ReaderT y (MaybeT f))) @\n--\n-- @since 0.5.9\ninstance (Monad f, Applicative f) => Applicative (WhenMatched f k x y) where\n  pure x = zipWithMatched (\\_ _ _ -> x)\n  fs <*> xs = zipWithMaybeAMatched $ \\k x y -> do\n    res <- runWhenMatched fs k x y\n    case res of\n      Nothing -> pure Nothing\n      Just r -> (pure $!) . fmap r =<< runWhenMatched xs k x y\n  {-# INLINE pure #-}\n  {-# INLINE (<*>) #-}\n\n-- | Equivalent to @ ReaderT k (ReaderT x (ReaderT y (MaybeT f))) @\n--\n-- @since 0.5.9\ninstance (Monad f, Applicative f) => Monad (WhenMatched f k x y) where\n  m >>= f = zipWithMaybeAMatched $ \\k x y -> do\n    res <- runWhenMatched m k x y\n    case res of\n      Nothing -> pure Nothing\n      Just r -> runWhenMatched (f r) k x y\n  {-# INLINE (>>=) #-}\n\n-- | Map covariantly over a @\'WhenMatched\' f k x y@.\n--\n-- @since 0.5.9\nmapWhenMatched :: Functor f\n               => (a -> b)\n               -> WhenMatched f k x y a\n               -> WhenMatched f k x y b\nmapWhenMatched f (WhenMatched g) = WhenMatched $ \\k x y -> fmap (fmap f) (g k x y)\n{-# INLINE mapWhenMatched #-}\n\n-- | A tactic for dealing with keys present in both maps in \'merge\'.\n--\n-- A tactic of type @ SimpleWhenMatched k x y z @ is an abstract representation\n-- of a function of type @ k -> x -> y -> Maybe z @.\n--\n-- @since 0.5.9\ntype SimpleWhenMatched = WhenMatched Identity\n\n-- | When a key is found in both maps, apply a function to the\n-- key and values and use the result in the merged map.\n--\n-- @\n-- zipWithMatched :: (k -> x -> y -> z)\n--                -> SimpleWhenMatched k x y z\n-- @\n--\n-- @since 0.5.9\nzipWithMatched :: Applicative f\n               => (k -> x -> y -> z)\n               -> WhenMatched f k x y z\nzipWithMatched f = WhenMatched $ \\ k x y -> pure . Just $ f k x y\n{-# INLINE zipWithMatched #-}\n\n-- | When a key is found in both maps, apply a function to the\n-- key and values to produce an action and use its result in the merged map.\n--\n-- @since 0.5.9\nzipWithAMatched :: Applicative f\n                => (k -> x -> y -> f z)\n                -> WhenMatched f k x y z\nzipWithAMatched f = WhenMatched $ \\ k x y -> Just <$> f k x y\n{-# INLINE zipWithAMatched #-}\n\n-- | When a key is found in both maps, apply a function to the\n-- key and values and maybe use the result in the merged map.\n--\n-- @\n-- zipWithMaybeMatched :: (k -> x -> y -> Maybe z)\n--                     -> SimpleWhenMatched k x y z\n-- @\n--\n-- @since 0.5.9\nzipWithMaybeMatched :: Applicative f\n                    => (k -> x -> y -> Maybe z)\n                    -> WhenMatched f k x y z\nzipWithMaybeMatched f = WhenMatched $ \\ k x y -> pure $ f k x y\n{-# INLINE zipWithMaybeMatched #-}\n\n-- | When a key is found in both maps, apply a function to the\n-- key and values, perform the resulting action, and maybe use\n-- the result in the merged map.\n--\n-- This is the fundamental \'WhenMatched\' tactic.\n--\n-- @since 0.5.9\nzipWithMaybeAMatched :: (k -> x -> y -> f (Maybe z))\n                     -> WhenMatched f k x y z\nzipWithMaybeAMatched f = WhenMatched $ \\ k x y -> f k x y\n{-# INLINE zipWithMaybeAMatched #-}\n\n-- | Drop all the entries whose keys are missing from the other\n-- map.\n--\n-- @\n-- dropMissing :: SimpleWhenMissing k x y\n-- @\n--\n-- prop> dropMissing = mapMaybeMissing (\\_ _ -> Nothing)\n--\n-- but @dropMissing@ is much faster.\n--\n-- @since 0.5.9\ndropMissing :: Applicative f => WhenMissing f k x y\ndropMissing = WhenMissing\n  { missingSubtree = const (pure Tip)\n  , missingKey = \\_ _ -> pure Nothing }\n{-# INLINE dropMissing #-}\n\n-- | Preserve, unchanged, the entries whose keys are missing from\n-- the other map.\n--\n-- @\n-- preserveMissing :: SimpleWhenMissing k x x\n-- @\n--\n-- prop> preserveMissing = Merge.Lazy.mapMaybeMissing (\\_ x -> Just x)\n--\n-- but @preserveMissing@ is much faster.\n--\n-- @since 0.5.9\npreserveMissing :: Applicative f => WhenMissing f k x x\npreserveMissing = WhenMissing\n  { missingSubtree = pure\n  , missingKey = \\_ v -> pure (Just v) }\n{-# INLINE preserveMissing #-}\n\n-- | Force the entries whose keys are missing from\n-- the other map and otherwise preserve them unchanged.\n--\n-- @\n-- preserveMissing\' :: SimpleWhenMissing k x x\n-- @\n--\n-- prop> preserveMissing\' = Merge.Lazy.mapMaybeMissing (\\_ x -> Just $! x)\n--\n-- but @preserveMissing\'@ is quite a bit faster.\n--\n-- @since 0.5.9\npreserveMissing\' :: Applicative f => WhenMissing f k x x\npreserveMissing\' = WhenMissing\n  { missingSubtree = \\t -> pure $! forceTree t `seq` t\n  , missingKey = \\_ v -> pure $! Just $! v }\n{-# INLINE preserveMissing\' #-}\n\n-- Force all the values in a tree.\nforceTree :: Map k a -> ()\nforceTree (Bin _ _ v l r) = v `seq` forceTree l `seq` forceTree r `seq` ()\nforceTree Tip = ()\n\n-- | Map over the entries whose keys are missing from the other map.\n--\n-- @\n-- mapMissing :: (k -> x -> y) -> SimpleWhenMissing k x y\n-- @\n--\n-- prop> mapMissing f = mapMaybeMissing (\\k x -> Just $ f k x)\n--\n-- but @mapMissing@ is somewhat faster.\n--\n-- @since 0.5.9\nmapMissing :: Applicative f => (k -> x -> y) -> WhenMissing f k x y\nmapMissing f = WhenMissing\n  { missingSubtree = \\m -> pure $! mapWithKey f m\n  , missingKey = \\ k x -> pure $ Just (f k x) }\n{-# INLINE mapMissing #-}\n\n-- | Map over the entries whose keys are missing from the other map,\n-- optionally removing some. This is the most powerful \'SimpleWhenMissing\'\n-- tactic, but others are usually more efficient.\n--\n-- @\n-- mapMaybeMissing :: (k -> x -> Maybe y) -> SimpleWhenMissing k x y\n-- @\n--\n-- prop> mapMaybeMissing f = traverseMaybeMissing (\\k x -> pure (f k x))\n--\n-- but @mapMaybeMissing@ uses fewer unnecessary \'Applicative\' operations.\n--\n-- @since 0.5.9\nmapMaybeMissing :: Applicative f => (k -> x -> Maybe y) -> WhenMissing f k x y\nmapMaybeMissing f = WhenMissing\n  { missingSubtree = \\m -> pure $! mapMaybeWithKey f m\n  , missingKey = \\k x -> pure $! f k x }\n{-# INLINE mapMaybeMissing #-}\n\n-- | Filter the entries whose keys are missing from the other map.\n--\n-- @\n-- filterMissing :: (k -> x -> Bool) -> SimpleWhenMissing k x x\n-- @\n--\n-- prop> filterMissing f = Merge.Lazy.mapMaybeMissing $ \\k x -> guard (f k x) *> Just x\n--\n-- but this should be a little faster.\n--\n-- @since 0.5.9\nfilterMissing :: Applicative f\n              => (k -> x -> Bool) -> WhenMissing f k x x\nfilterMissing f = WhenMissing\n  { missingSubtree = \\m -> pure $! filterWithKey f m\n  , missingKey = \\k x -> pure $! if f k x then Just x else Nothing }\n{-# INLINE filterMissing #-}\n\n-- | Filter the entries whose keys are missing from the other map\n-- using some \'Applicative\' action.\n--\n-- > filterAMissing f = Merge.Lazy.traverseMaybeMissing $\n-- >   \\k x -> (\\b -> guard b *> Just x) <$> f k x\n--\n-- but this should be a little faster.\n--\n-- @since 0.5.9\nfilterAMissing :: Applicative f\n              => (k -> x -> f Bool) -> WhenMissing f k x x\nfilterAMissing f = WhenMissing\n  { missingSubtree = \\m -> filterWithKeyA f m\n  , missingKey = \\k x -> bool Nothing (Just x) <$> f k x }\n{-# INLINE filterAMissing #-}\n\n-- | This wasn\'t in Data.Bool until 4.7.0, so we define it here\nbool :: a -> a -> Bool -> a\nbool f _ False = f\nbool _ t True  = t\n\n-- | Traverse over the entries whose keys are missing from the other map.\n--\n-- @since 0.5.9\ntraverseMissing :: Applicative f\n                    => (k -> x -> f y) -> WhenMissing f k x y\ntraverseMissing f = WhenMissing\n  { missingSubtree = traverseWithKey f\n  , missingKey = \\k x -> Just <$> f k x }\n{-# INLINE traverseMissing #-}\n\n-- | Traverse over the entries whose keys are missing from the other map,\n-- optionally producing values to put in the result.\n-- This is the most powerful \'WhenMissing\' tactic, but others are usually\n-- more efficient.\n--\n-- @since 0.5.9\ntraverseMaybeMissing :: Applicative f\n                      => (k -> x -> f (Maybe y)) -> WhenMissing f k x y\ntraverseMaybeMissing f = WhenMissing\n  { missingSubtree = traverseMaybeWithKey f\n  , missingKey = f }\n{-# INLINE traverseMaybeMissing #-}\n\n-- | Merge two maps.\n--\n-- \'merge\' takes two \'WhenMissing\' tactics, a \'WhenMatched\'\n-- tactic and two maps. It uses the tactics to merge the maps.\n-- Its behavior is best understood via its fundamental tactics,\n-- \'mapMaybeMissing\' and \'zipWithMaybeMatched\'.\n--\n-- Consider\n--\n-- @\n-- merge (mapMaybeMissing g1)\n--              (mapMaybeMissing g2)\n--              (zipWithMaybeMatched f)\n--              m1 m2\n-- @\n--\n-- Take, for example,\n--\n-- @\n-- m1 = [(0, \\\'a\\\'), (1, \\\'b\\\'), (3, \\\'c\\\'), (4, \\\'d\\\')]\n-- m2 = [(1, "one"), (2, "two"), (4, "three")]\n-- @\n--\n-- \'merge\' will first \\"align\\" these maps by key:\n--\n-- @\n-- m1 = [(0, \\\'a\\\'), (1, \\\'b\\\'),               (3, \\\'c\\\'), (4, \\\'d\\\')]\n-- m2 =           [(1, "one"), (2, "two"),           (4, "three")]\n-- @\n--\n-- It will then pass the individual entries and pairs of entries\n-- to @g1@, @g2@, or @f@ as appropriate:\n--\n-- @\n-- maybes = [g1 0 \\\'a\\\', f 1 \\\'b\\\' "one", g2 2 "two", g1 3 \\\'c\\\', f 4 \\\'d\\\' "three"]\n-- @\n--\n-- This produces a \'Maybe\' for each key:\n--\n-- @\n-- keys =     0        1          2           3        4\n-- results = [Nothing, Just True, Just False, Nothing, Just True]\n-- @\n--\n-- Finally, the @Just@ results are collected into a map:\n--\n-- @\n-- return value = [(1, True), (2, False), (4, True)]\n-- @\n--\n-- The other tactics below are optimizations or simplifications of\n-- \'mapMaybeMissing\' for special cases. Most importantly,\n--\n-- * \'dropMissing\' drops all the keys.\n-- * \'preserveMissing\' leaves all the entries alone.\n--\n-- When \'merge\' is given three arguments, it is inlined at the call\n-- site. To prevent excessive inlining, you should typically use \'merge\'\n-- to define your custom combining functions.\n--\n--\n-- Examples:\n--\n-- prop> unionWithKey f = merge preserveMissing preserveMissing (zipWithMatched f)\n-- prop> intersectionWithKey f = merge dropMissing dropMissing (zipWithMatched f)\n-- prop> differenceWith f = merge preserveMissing dropMissing (zipWithMatched f)\n-- prop> symmetricDifference = merge preserveMissing preserveMissing (zipWithMaybeMatched $ \\ _ _ _ -> Nothing)\n-- prop> mapEachPiece f g h = merge (mapMissing f) (mapMissing g) (zipWithMatched h)\n--\n-- @since 0.5.9\nmerge :: Ord k\n             => SimpleWhenMissing k a c -- ^ What to do with keys in @m1@ but not @m2@\n             -> SimpleWhenMissing k b c -- ^ What to do with keys in @m2@ but not @m1@\n             -> SimpleWhenMatched k a b c -- ^ What to do with keys in both @m1@ and @m2@\n             -> Map k a -- ^ Map @m1@\n             -> Map k b -- ^ Map @m2@\n             -> Map k c\nmerge g1 g2 f m1 m2 = runIdentity $\n  mergeA g1 g2 f m1 m2\n{-# INLINE merge #-}\n\n-- | An applicative version of \'merge\'.\n--\n-- \'mergeA\' takes two \'WhenMissing\' tactics, a \'WhenMatched\'\n-- tactic and two maps. It uses the tactics to merge the maps.\n-- Its behavior is best understood via its fundamental tactics,\n-- \'traverseMaybeMissing\' and \'zipWithMaybeAMatched\'.\n--\n-- Consider\n--\n-- @\n-- mergeA (traverseMaybeMissing g1)\n--               (traverseMaybeMissing g2)\n--               (zipWithMaybeAMatched f)\n--               m1 m2\n-- @\n--\n-- Take, for example,\n--\n-- @\n-- m1 = [(0, \\\'a\\\'), (1, \\\'b\\\'), (3, \\\'c\\\'), (4, \\\'d\\\')]\n-- m2 = [(1, "one"), (2, "two"), (4, "three")]\n-- @\n--\n-- @mergeA@ will first \\"align\\" these maps by key:\n--\n-- @\n-- m1 = [(0, \\\'a\\\'), (1, \\\'b\\\'),               (3, \\\'c\\\'), (4, \\\'d\\\')]\n-- m2 =           [(1, "one"), (2, "two"),           (4, "three")]\n-- @\n--\n-- It will then pass the individual entries and pairs of entries\n-- to @g1@, @g2@, or @f@ as appropriate:\n--\n-- @\n-- actions = [g1 0 \\\'a\\\', f 1 \\\'b\\\' "one", g2 2 "two", g1 3 \\\'c\\\', f 4 \\\'d\\\' "three"]\n-- @\n--\n-- Next, it will perform the actions in the @actions@ list in order from\n-- left to right.\n--\n-- @\n-- keys =     0        1          2           3        4\n-- results = [Nothing, Just True, Just False, Nothing, Just True]\n-- @\n--\n-- Finally, the @Just@ results are collected into a map:\n--\n-- @\n-- return value = [(1, True), (2, False), (4, True)]\n-- @\n--\n-- The other tactics below are optimizations or simplifications of\n-- \'traverseMaybeMissing\' for special cases. Most importantly,\n--\n-- * \'dropMissing\' drops all the keys.\n-- * \'preserveMissing\' leaves all the entries alone.\n-- * \'mapMaybeMissing\' does not use the \'Applicative\' context.\n--\n-- When \'mergeA\' is given three arguments, it is inlined at the call\n-- site. To prevent excessive inlining, you should generally only use\n-- \'mergeA\' to define custom combining functions.\n--\n-- @since 0.5.9\nmergeA\n  :: (Applicative f, Ord k)\n  => WhenMissing f k a c -- ^ What to do with keys in @m1@ but not @m2@\n  -> WhenMissing f k b c -- ^ What to do with keys in @m2@ but not @m1@\n  -> WhenMatched f k a b c -- ^ What to do with keys in both @m1@ and @m2@\n  -> Map k a -- ^ Map @m1@\n  -> Map k b -- ^ Map @m2@\n  -> f (Map k c)\nmergeA\n    WhenMissing{missingSubtree = g1t, missingKey = g1k}\n    WhenMissing{missingSubtree = g2t}\n    (WhenMatched f) = go\n  where\n    go t1 Tip = g1t t1\n    go Tip t2 = g2t t2\n    go (Bin _ kx x1 l1 r1) t2 = case splitLookup kx t2 of\n      (l2, mx2, r2) -> case mx2 of\n          Nothing -> liftA3 (\\l\' mx\' r\' -> maybe link2 (link kx) mx\' l\' r\')\n                        l1l2 (g1k kx x1) r1r2\n          Just x2 -> liftA3 (\\l\' mx\' r\' -> maybe link2 (link kx) mx\' l\' r\')\n                        l1l2 (f kx x1 x2) r1r2\n        where\n          !l1l2 = go l1 l2\n          !r1r2 = go r1 r2\n{-# INLINE mergeA #-}\n\n\n{--------------------------------------------------------------------\n  MergeWithKey\n--------------------------------------------------------------------}\n\n-- | \\(O(n+m)\\). An unsafe general combining function.\n--\n-- WARNING: This function can produce corrupt maps and its results\n-- may depend on the internal structures of its inputs. Users should\n-- prefer \'merge\' or \'mergeA\'.\n--\n-- When \'mergeWithKey\' is given three arguments, it is inlined to the call\n-- site. You should therefore use \'mergeWithKey\' only to define custom\n-- combining functions. For example, you could define \'unionWithKey\',\n-- \'differenceWithKey\' and \'intersectionWithKey\' as\n--\n-- > myUnionWithKey f m1 m2 = mergeWithKey (\\k x1 x2 -> Just (f k x1 x2)) id id m1 m2\n-- > myDifferenceWithKey f m1 m2 = mergeWithKey f id (const empty) m1 m2\n-- > myIntersectionWithKey f m1 m2 = mergeWithKey (\\k x1 x2 -> Just (f k x1 x2)) (const empty) (const empty) m1 m2\n--\n-- When calling @\'mergeWithKey\' combine only1 only2@, a function combining two\n-- \'Map\'s is created, such that\n--\n-- * if a key is present in both maps, it is passed with both corresponding\n--   values to the @combine@ function. Depending on the result, the key is either\n--   present in the result with specified value, or is left out;\n--\n-- * a nonempty subtree present only in the first map is passed to @only1@ and\n--   the output is added to the result;\n--\n-- * a nonempty subtree present only in the second map is passed to @only2@ and\n--   the output is added to the result.\n--\n-- The @only1@ and @only2@ methods /must return a map with a subset (possibly empty) of the keys of the given map/.\n-- The values can be modified arbitrarily. Most common variants of @only1@ and\n-- @only2@ are \'id\' and @\'const\' \'empty\'@, but for example @\'map\' f@,\n-- @\'filterWithKey\' f@, or @\'mapMaybeWithKey\' f@ could be used for any @f@.\n\nmergeWithKey :: Ord k\n             => (k -> a -> b -> Maybe c)\n             -> (Map k a -> Map k c)\n             -> (Map k b -> Map k c)\n             -> Map k a -> Map k b -> Map k c\nmergeWithKey f g1 g2 = go\n  where\n    go Tip t2 = g2 t2\n    go t1 Tip = g1 t1\n    go (Bin _ kx x l1 r1) t2 =\n      case found of\n        Nothing -> case g1 (singleton kx x) of\n                     Tip -> link2 l\' r\'\n                     (Bin _ _ x\' Tip Tip) -> link kx x\' l\' r\'\n                     _ -> error "mergeWithKey: Given function only1 does not fulfill required conditions (see documentation)"\n        Just x2 -> case f kx x x2 of\n                     Nothing -> link2 l\' r\'\n                     Just x\' -> link kx x\' l\' r\'\n      where\n        (l2, found, r2) = splitLookup kx t2\n        l\' = go l1 l2\n        r\' = go r1 r2\n{-# INLINE mergeWithKey #-}\n\n{--------------------------------------------------------------------\n  Submap\n--------------------------------------------------------------------}\n-- | \\(O\\bigl(m \\log\\bigl(\\frac{n+1}{m+1}\\bigr)\\bigr), \\; m \\leq n\\).\n-- This function is defined as (@\'isSubmapOf\' = \'isSubmapOfBy\' (==)@).\n--\nisSubmapOf :: (Ord k,Eq a) => Map k a -> Map k a -> Bool\nisSubmapOf m1 m2 = isSubmapOfBy (==) m1 m2\n#if __GLASGOW_HASKELL__\n{-# INLINABLE isSubmapOf #-}\n#endif\n\n{- | \\(O\\bigl(m \\log\\bigl(\\frac{n+1}{m+1}\\bigr)\\bigr), \\; m \\leq n\\).\n The expression (@\'isSubmapOfBy\' f t1 t2@) returns \'True\' if\n all keys in @t1@ are in tree @t2@, and when @f@ returns \'True\' when\n applied to their respective values. For example, the following\n expressions are all \'True\':\n\n > isSubmapOfBy (==) (fromList [(\'a\',1)]) (fromList [(\'a\',1),(\'b\',2)])\n > isSubmapOfBy (<=) (fromList [(\'a\',1)]) (fromList [(\'a\',1),(\'b\',2)])\n > isSubmapOfBy (==) (fromList [(\'a\',1),(\'b\',2)]) (fromList [(\'a\',1),(\'b\',2)])\n\n But the following are all \'False\':\n\n > isSubmapOfBy (==) (fromList [(\'a\',2)]) (fromList [(\'a\',1),(\'b\',2)])\n > isSubmapOfBy (<)  (fromList [(\'a\',1)]) (fromList [(\'a\',1),(\'b\',2)])\n > isSubmapOfBy (==) (fromList [(\'a\',1),(\'b\',2)]) (fromList [(\'a\',1)])\n\n Note that @isSubmapOfBy (\\_ _ -> True) m1 m2@ tests whether all the keys\n in @m1@ are also keys in @m2@.\n\n-}\nisSubmapOfBy :: Ord k => (a->b->Bool) -> Map k a -> Map k b -> Bool\nisSubmapOfBy f t1 t2\n  = size t1 <= size t2 && submap\' f t1 t2\n#if __GLASGOW_HASKELL__\n{-# INLINABLE isSubmapOfBy #-}\n#endif\n\n-- Test whether a map is a submap of another without the *initial*\n-- size test. See Data.Set.Internal.isSubsetOfX for notes on\n-- implementation and analysis.\nsubmap\' :: Ord a => (b -> c -> Bool) -> Map a b -> Map a c -> Bool\nsubmap\' _ Tip _ = True\nsubmap\' _ _ Tip = False\nsubmap\' f (Bin 1 kx x _ _) t\n  = case lookup kx t of\n      Just y -> f x y\n      Nothing -> False\nsubmap\' f (Bin _ kx x l r) t\n  = case found of\n      Nothing -> False\n      Just y  -> f x y\n                 && size l <= size lt && size r <= size gt\n                 && submap\' f l lt && submap\' f r gt\n  where\n    (lt,found,gt) = splitLookup kx t\n#if __GLASGOW_HASKELL__\n{-# INLINABLE submap\' #-}\n#endif\n\n-- | \\(O\\bigl(m \\log\\bigl(\\frac{n+1}{m+1}\\bigr)\\bigr), \\; m \\leq n\\). Is this a proper submap? (ie. a submap but not equal).\n-- Defined as (@\'isProperSubmapOf\' = \'isProperSubmapOfBy\' (==)@).\nisProperSubmapOf :: (Ord k,Eq a) => Map k a -> Map k a -> Bool\nisProperSubmapOf m1 m2\n  = isProperSubmapOfBy (==) m1 m2\n#if __GLASGOW_HASKELL__\n{-# INLINABLE isProperSubmapOf #-}\n#endif\n\n{- | \\(O\\bigl(m \\log\\bigl(\\frac{n+1}{m+1}\\bigr)\\bigr), \\; m \\leq n\\). Is this a proper submap? (ie. a submap but not equal).\n The expression (@\'isProperSubmapOfBy\' f m1 m2@) returns \'True\' when\n @keys m1@ and @keys m2@ are not equal,\n all keys in @m1@ are in @m2@, and when @f@ returns \'True\' when\n applied to their respective values. For example, the following\n expressions are all \'True\':\n\n  > isProperSubmapOfBy (==) (fromList [(1,1)]) (fromList [(1,1),(2,2)])\n  > isProperSubmapOfBy (<=) (fromList [(1,1)]) (fromList [(1,1),(2,2)])\n\n But the following are all \'False\':\n\n  > isProperSubmapOfBy (==) (fromList [(1,1),(2,2)]) (fromList [(1,1),(2,2)])\n  > isProperSubmapOfBy (==) (fromList [(1,1),(2,2)]) (fromList [(1,1)])\n  > isProperSubmapOfBy (<)  (fromList [(1,1)])       (fromList [(1,1),(2,2)])\n\n\n-}\nisProperSubmapOfBy :: Ord k => (a -> b -> Bool) -> Map k a -> Map k b -> Bool\nisProperSubmapOfBy f t1 t2\n  = size t1 < size t2 && submap\' f t1 t2\n#if __GLASGOW_HASKELL__\n{-# INLINABLE isProperSubmapOfBy #-}\n#endif\n\n{--------------------------------------------------------------------\n  Filter and partition\n--------------------------------------------------------------------}\n-- | \\(O(n)\\). Filter all values that satisfy the predicate.\n--\n-- > filter (> "a") (fromList [(5,"a"), (3,"b")]) == singleton 3 "b"\n-- > filter (> "x") (fromList [(5,"a"), (3,"b")]) == empty\n-- > filter (< "a") (fromList [(5,"a"), (3,"b")]) == empty\n\nfilter :: (a -> Bool) -> Map k a -> Map k a\nfilter p m\n  = filterWithKey (\\_ x -> p x) m\n\n-- | \\(O(n)\\). Filter all keys\\/values that satisfy the predicate.\n--\n-- > filterWithKey (\\k _ -> k > 4) (fromList [(5,"a"), (3,"b")]) == singleton 5 "a"\n\nfilterWithKey :: (k -> a -> Bool) -> Map k a -> Map k a\nfilterWithKey _ Tip = Tip\nfilterWithKey p t@(Bin _ kx x l r)\n  | p kx x    = if pl `ptrEq` l && pr `ptrEq` r\n                then t\n                else link kx x pl pr\n  | otherwise = link2 pl pr\n  where !pl = filterWithKey p l\n        !pr = filterWithKey p r\n\n-- | \\(O(n)\\). Filter keys and values using an \'Applicative\'\n-- predicate.\nfilterWithKeyA :: Applicative f => (k -> a -> f Bool) -> Map k a -> f (Map k a)\nfilterWithKeyA _ Tip = pure Tip\nfilterWithKeyA p t@(Bin _ kx x l r) =\n  liftA3 combine (p kx x) (filterWithKeyA p l) (filterWithKeyA p r)\n  where\n    combine True pl pr\n      | pl `ptrEq` l && pr `ptrEq` r = t\n      | otherwise = link kx x pl pr\n    combine False pl pr = link2 pl pr\n\n-- | \\(O(\\log n)\\). Take while a predicate on the keys holds.\n-- The user is responsible for ensuring that for all keys @j@ and @k@ in the map,\n-- @j \\< k ==\\> p j \\>= p k@. See note at \'spanAntitone\'.\n--\n-- @\n-- takeWhileAntitone p = \'fromDistinctAscList\' . \'Data.List.takeWhile\' (p . fst) . \'toList\'\n-- takeWhileAntitone p = \'filterWithKey\' (\\k _ -> p k)\n-- @\n--\n-- @since 0.5.8\n\ntakeWhileAntitone :: (k -> Bool) -> Map k a -> Map k a\ntakeWhileAntitone _ Tip = Tip\ntakeWhileAntitone p (Bin _ kx x l r)\n  | p kx = link kx x l (takeWhileAntitone p r)\n  | otherwise = takeWhileAntitone p l\n\n-- | \\(O(\\log n)\\). Drop while a predicate on the keys holds.\n-- The user is responsible for ensuring that for all keys @j@ and @k@ in the map,\n-- @j \\< k ==\\> p j \\>= p k@. See note at \'spanAntitone\'.\n--\n-- @\n-- dropWhileAntitone p = \'fromDistinctAscList\' . \'Data.List.dropWhile\' (p . fst) . \'toList\'\n-- dropWhileAntitone p = \'filterWithKey\' (\\\\k _ -> not (p k))\n-- @\n--\n-- @since 0.5.8\n\ndropWhileAntitone :: (k -> Bool) -> Map k a -> Map k a\ndropWhileAntitone _ Tip = Tip\ndropWhileAntitone p (Bin _ kx x l r)\n  | p kx = dropWhileAntitone p r\n  | otherwise = link kx x (dropWhileAntitone p l) r\n\n-- | \\(O(\\log n)\\). Divide a map at the point where a predicate on the keys stops holding.\n-- The user is responsible for ensuring that for all keys @j@ and @k@ in the map,\n-- @j \\< k ==\\> p j \\>= p k@.\n--\n-- @\n-- spanAntitone p xs = (\'takeWhileAntitone\' p xs, \'dropWhileAntitone\' p xs)\n-- spanAntitone p xs = partitionWithKey (\\\\k _ -> p k) xs\n-- @\n--\n-- Note: if @p@ is not actually antitone, then @spanAntitone@ will split the map\n-- at some /unspecified/ point where the predicate switches from holding to not\n-- holding (where the predicate is seen to hold before the first key and to fail\n-- after the last key).\n--\n-- @since 0.5.8\n\nspanAntitone :: (k -> Bool) -> Map k a -> (Map k a, Map k a)\nspanAntitone p0 m = toPair (go p0 m)\n  where\n    go _ Tip = Tip :*: Tip\n    go p (Bin _ kx x l r)\n      | p kx = let u :*: v = go p r in link kx x l u :*: v\n      | otherwise = let u :*: v = go p l in u :*: link kx x v r\n\n-- | \\(O(n)\\). Partition the map according to a predicate. The first\n-- map contains all elements that satisfy the predicate, the second all\n-- elements that fail the predicate. See also \'split\'.\n--\n-- > partition (> "a") (fromList [(5,"a"), (3,"b")]) == (singleton 3 "b", singleton 5 "a")\n-- > partition (< "x") (fromList [(5,"a"), (3,"b")]) == (fromList [(3, "b"), (5, "a")], empty)\n-- > partition (> "x") (fromList [(5,"a"), (3,"b")]) == (empty, fromList [(3, "b"), (5, "a")])\n\npartition :: (a -> Bool) -> Map k a -> (Map k a,Map k a)\npartition p m\n  = partitionWithKey (\\_ x -> p x) m\n\n-- | \\(O(n)\\). Partition the map according to a predicate. The first\n-- map contains all elements that satisfy the predicate, the second all\n-- elements that fail the predicate. See also \'split\'.\n--\n-- > partitionWithKey (\\ k _ -> k > 3) (fromList [(5,"a"), (3,"b")]) == (singleton 5 "a", singleton 3 "b")\n-- > partitionWithKey (\\ k _ -> k < 7) (fromList [(5,"a"), (3,"b")]) == (fromList [(3, "b"), (5, "a")], empty)\n-- > partitionWithKey (\\ k _ -> k > 7) (fromList [(5,"a"), (3,"b")]) == (empty, fromList [(3, "b"), (5, "a")])\n\npartitionWithKey :: (k -> a -> Bool) -> Map k a -> (Map k a,Map k a)\npartitionWithKey p0 t0 = toPair $ go p0 t0\n  where\n    go _ Tip = (Tip :*: Tip)\n    go p t@(Bin _ kx x l r)\n      | p kx x    = (if l1 `ptrEq` l && r1 `ptrEq` r\n                     then t\n                     else link kx x l1 r1) :*: link2 l2 r2\n      | otherwise = link2 l1 r1 :*:\n                    (if l2 `ptrEq` l && r2 `ptrEq` r\n                     then t\n                     else link kx x l2 r2)\n      where\n        (l1 :*: l2) = go p l\n        (r1 :*: r2) = go p r\n\n-- | \\(O(n)\\). Map values and collect the \'Just\' results.\n--\n-- > let f x = if x == "a" then Just "new a" else Nothing\n-- > mapMaybe f (fromList [(5,"a"), (3,"b")]) == singleton 5 "new a"\n\nmapMaybe :: (a -> Maybe b) -> Map k a -> Map k b\nmapMaybe f = mapMaybeWithKey (\\_ x -> f x)\n\n-- | \\(O(n)\\). Map keys\\/values and collect the \'Just\' results.\n--\n-- > let f k _ = if k < 5 then Just ("key : " ++ (show k)) else Nothing\n-- > mapMaybeWithKey f (fromList [(5,"a"), (3,"b")]) == singleton 3 "key : 3"\n\nmapMaybeWithKey :: (k -> a -> Maybe b) -> Map k a -> Map k b\nmapMaybeWithKey _ Tip = Tip\nmapMaybeWithKey f (Bin _ kx x l r) = case f kx x of\n  Just y  -> link kx y (mapMaybeWithKey f l) (mapMaybeWithKey f r)\n  Nothing -> link2 (mapMaybeWithKey f l) (mapMaybeWithKey f r)\n\n-- | \\(O(n)\\). Traverse keys\\/values and collect the \'Just\' results.\n--\n-- @since 0.5.8\ntraverseMaybeWithKey :: Applicative f\n                     => (k -> a -> f (Maybe b)) -> Map k a -> f (Map k b)\ntraverseMaybeWithKey = go\n  where\n    go _ Tip = pure Tip\n    go f (Bin _ kx x Tip Tip) = maybe Tip (\\x\' -> Bin 1 kx x\' Tip Tip) <$> f kx x\n    go f (Bin _ kx x l r) = liftA3 combine (go f l) (f kx x) (go f r)\n      where\n        combine !l\' mx !r\' = case mx of\n          Nothing -> link2 l\' r\'\n          Just x\' -> link kx x\' l\' r\'\n\n-- | \\(O(n)\\). Map values and separate the \'Left\' and \'Right\' results.\n--\n-- > let f a = if a < "c" then Left a else Right a\n-- > mapEither f (fromList [(5,"a"), (3,"b"), (1,"x"), (7,"z")])\n-- >     == (fromList [(3,"b"), (5,"a")], fromList [(1,"x"), (7,"z")])\n-- >\n-- > mapEither (\\ a -> Right a) (fromList [(5,"a"), (3,"b"), (1,"x"), (7,"z")])\n-- >     == (empty, fromList [(5,"a"), (3,"b"), (1,"x"), (7,"z")])\n\nmapEither :: (a -> Either b c) -> Map k a -> (Map k b, Map k c)\nmapEither f m\n  = mapEitherWithKey (\\_ x -> f x) m\n\n-- | \\(O(n)\\). Map keys\\/values and separate the \'Left\' and \'Right\' results.\n--\n-- > let f k a = if k < 5 then Left (k * 2) else Right (a ++ a)\n-- > mapEitherWithKey f (fromList [(5,"a"), (3,"b"), (1,"x"), (7,"z")])\n-- >     == (fromList [(1,2), (3,6)], fromList [(5,"aa"), (7,"zz")])\n-- >\n-- > mapEitherWithKey (\\_ a -> Right a) (fromList [(5,"a"), (3,"b"), (1,"x"), (7,"z")])\n-- >     == (empty, fromList [(1,"x"), (3,"b"), (5,"a"), (7,"z")])\n\nmapEitherWithKey :: (k -> a -> Either b c) -> Map k a -> (Map k b, Map k c)\nmapEitherWithKey f0 t0 = toPair $ go f0 t0\n  where\n    go _ Tip = (Tip :*: Tip)\n    go f (Bin _ kx x l r) = case f kx x of\n      Left y  -> link kx y l1 r1 :*: link2 l2 r2\n      Right z -> link2 l1 r1 :*: link kx z l2 r2\n     where\n        (l1 :*: l2) = go f l\n        (r1 :*: r2) = go f r\n\n{--------------------------------------------------------------------\n  Mapping\n--------------------------------------------------------------------}\n-- | \\(O(n)\\). Map a function over all values in the map.\n--\n-- > map (++ "x") (fromList [(5,"a"), (3,"b")]) == fromList [(3, "bx"), (5, "ax")]\n\nmap :: (a -> b) -> Map k a -> Map k b\nmap f = go where\n  go Tip = Tip\n  go (Bin sx kx x l r) = Bin sx kx (f x) (go l) (go r)\n-- We use a `go` function to allow `map` to inline. This makes\n-- a big difference if someone uses `map (const x) m` instead\n-- of `x <$ m`; it doesn\'t seem to do any harm.\n\n#ifdef __GLASGOW_HASKELL__\n{-# NOINLINE [1] map #-}\n{-# RULES\n"map/map" forall f g xs . map f (map g xs) = map (f . g) xs\n"map/coerce" map coerce = coerce\n #-}\n#endif\n\n-- | \\(O(n)\\). Map a function over all values in the map.\n--\n-- > let f key x = (show key) ++ ":" ++ x\n-- > mapWithKey f (fromList [(5,"a"), (3,"b")]) == fromList [(3, "3:b"), (5, "5:a")]\n\nmapWithKey :: (k -> a -> b) -> Map k a -> Map k b\nmapWithKey _ Tip = Tip\nmapWithKey f (Bin sx kx x l r) = Bin sx kx (f kx x) (mapWithKey f l) (mapWithKey f r)\n\n#ifdef __GLASGOW_HASKELL__\n{-# NOINLINE [1] mapWithKey #-}\n{-# RULES\n"mapWithKey/mapWithKey" forall f g xs . mapWithKey f (mapWithKey g xs) =\n  mapWithKey (\\k a -> f k (g k a)) xs\n"mapWithKey/map" forall f g xs . mapWithKey f (map g xs) =\n  mapWithKey (\\k a -> f k (g a)) xs\n"map/mapWithKey" forall f g xs . map f (mapWithKey g xs) =\n  mapWithKey (\\k a -> f (g k a)) xs\n #-}\n#endif\n\n-- | \\(O(n)\\).\n-- @\'traverseWithKey\' f m == \'fromList\' \\<$\\> \'traverse\' (\\\\(k, v) -> (,) k \\<$\\> f k v) (\'toList\' m)@\n-- That is, behaves exactly like a regular \'traverse\' except that the traversing\n-- function also has access to the key associated with a value.\n--\n-- > traverseWithKey (\\k v -> if odd k then Just (succ v) else Nothing) (fromList [(1, \'a\'), (5, \'e\')]) == Just (fromList [(1, \'b\'), (5, \'f\')])\n-- > traverseWithKey (\\k v -> if odd k then Just (succ v) else Nothing) (fromList [(2, \'c\')])           == Nothing\ntraverseWithKey :: Applicative t => (k -> a -> t b) -> Map k a -> t (Map k b)\ntraverseWithKey f = go\n  where\n    go Tip = pure Tip\n    go (Bin 1 k v _ _) = (\\v\' -> Bin 1 k v\' Tip Tip) <$> f k v\n    go (Bin s k v l r) = liftA3 (flip (Bin s k)) (go l) (f k v) (go r)\n{-# INLINE traverseWithKey #-}\n\n-- | \\(O(n)\\). The function \'mapAccum\' threads an accumulating\n-- argument through the map in ascending order of keys.\n--\n-- > let f a b = (a ++ b, b ++ "X")\n-- > mapAccum f "Everything: " (fromList [(5,"a"), (3,"b")]) == ("Everything: ba", fromList [(3, "bX"), (5, "aX")])\n\nmapAccum :: (a -> b -> (a,c)) -> a -> Map k b -> (a,Map k c)\nmapAccum f a m\n  = mapAccumWithKey (\\a\' _ x\' -> f a\' x\') a m\n\n-- | \\(O(n)\\). The function \'mapAccumWithKey\' threads an accumulating\n-- argument through the map in ascending order of keys.\n--\n-- > let f a k b = (a ++ " " ++ (show k) ++ "-" ++ b, b ++ "X")\n-- > mapAccumWithKey f "Everything:" (fromList [(5,"a"), (3,"b")]) == ("Everything: 3-b 5-a", fromList [(3, "bX"), (5, "aX")])\n\nmapAccumWithKey :: (a -> k -> b -> (a,c)) -> a -> Map k b -> (a,Map k c)\nmapAccumWithKey f a t\n  = mapAccumL f a t\n\n-- | \\(O(n)\\). The function \'mapAccumL\' threads an accumulating\n-- argument through the map in ascending order of keys.\nmapAccumL :: (a -> k -> b -> (a,c)) -> a -> Map k b -> (a,Map k c)\nmapAccumL _ a Tip               = (a,Tip)\nmapAccumL f a (Bin sx kx x l r) =\n  let (a1,l\') = mapAccumL f a l\n      (a2,x\') = f a1 kx x\n      (a3,r\') = mapAccumL f a2 r\n  in (a3,Bin sx kx x\' l\' r\')\n\n-- | \\(O(n)\\). The function \'mapAccumRWithKey\' threads an accumulating\n-- argument through the map in descending order of keys.\nmapAccumRWithKey :: (a -> k -> b -> (a,c)) -> a -> Map k b -> (a,Map k c)\nmapAccumRWithKey _ a Tip = (a,Tip)\nmapAccumRWithKey f a (Bin sx kx x l r) =\n  let (a1,r\') = mapAccumRWithKey f a r\n      (a2,x\') = f a1 kx x\n      (a3,l\') = mapAccumRWithKey f a2 l\n  in (a3,Bin sx kx x\' l\' r\')\n\n-- | \\(O(n \\log n)\\).\n-- @\'mapKeys\' f s@ is the map obtained by applying @f@ to each key of @s@.\n--\n-- The size of the result may be smaller if @f@ maps two or more distinct\n-- keys to the same new key.  In this case the value at the greatest of the\n-- original keys is retained.\n--\n-- > mapKeys (+ 1) (fromList [(5,"a"), (3,"b")])                        == fromList [(4, "b"), (6, "a")]\n-- > mapKeys (\\ _ -> 1) (fromList [(1,"b"), (2,"a"), (3,"d"), (4,"c")]) == singleton 1 "c"\n-- > mapKeys (\\ _ -> 3) (fromList [(1,"b"), (2,"a"), (3,"d"), (4,"c")]) == singleton 3 "c"\n\nmapKeys :: Ord k2 => (k1->k2) -> Map k1 a -> Map k2 a\nmapKeys f = fromList . foldrWithKey (\\k x xs -> (f k, x) : xs) []\n#if __GLASGOW_HASKELL__\n{-# INLINABLE mapKeys #-}\n#endif\n\n-- | \\(O(n \\log n)\\).\n-- @\'mapKeysWith\' c f s@ is the map obtained by applying @f@ to each key of @s@.\n--\n-- The size of the result may be smaller if @f@ maps two or more distinct\n-- keys to the same new key.  In this case the associated values will be\n-- combined using @c@. The value at the greater of the two original keys\n-- is used as the first argument to @c@.\n--\n-- > mapKeysWith (++) (\\ _ -> 1) (fromList [(1,"b"), (2,"a"), (3,"d"), (4,"c")]) == singleton 1 "cdab"\n-- > mapKeysWith (++) (\\ _ -> 3) (fromList [(1,"b"), (2,"a"), (3,"d"), (4,"c")]) == singleton 3 "cdab"\n\nmapKeysWith :: Ord k2 => (a -> a -> a) -> (k1->k2) -> Map k1 a -> Map k2 a\nmapKeysWith c f = fromListWith c . foldrWithKey (\\k x xs -> (f k, x) : xs) []\n#if __GLASGOW_HASKELL__\n{-# INLINABLE mapKeysWith #-}\n#endif\n\n\n-- | \\(O(n)\\).\n-- @\'mapKeysMonotonic\' f s == \'mapKeys\' f s@, but works only when @f@\n-- is strictly monotonic.\n-- That is, for any values @x@ and @y@, if @x@ < @y@ then @f x@ < @f y@.\n-- /The precondition is not checked./\n-- Semi-formally, we have:\n--\n-- > and [x < y ==> f x < f y | x <- ls, y <- ls]\n-- >                     ==> mapKeysMonotonic f s == mapKeys f s\n-- >     where ls = keys s\n--\n-- This means that @f@ maps distinct original keys to distinct resulting keys.\n-- This function has better performance than \'mapKeys\'.\n--\n-- > mapKeysMonotonic (\\ k -> k * 2) (fromList [(5,"a"), (3,"b")]) == fromList [(6, "b"), (10, "a")]\n-- > valid (mapKeysMonotonic (\\ k -> k * 2) (fromList [(5,"a"), (3,"b")])) == True\n-- > valid (mapKeysMonotonic (\\ _ -> 1)     (fromList [(5,"a"), (3,"b")])) == False\n\nmapKeysMonotonic :: (k1->k2) -> Map k1 a -> Map k2 a\nmapKeysMonotonic _ Tip = Tip\nmapKeysMonotonic f (Bin sz k x l r) =\n    Bin sz (f k) x (mapKeysMonotonic f l) (mapKeysMonotonic f r)\n\n{--------------------------------------------------------------------\n  Folds\n--------------------------------------------------------------------}\n\n-- | \\(O(n)\\). Fold the values in the map using the given right-associative\n-- binary operator, such that @\'foldr\' f z == \'Prelude.foldr\' f z . \'elems\'@.\n--\n-- For example,\n--\n-- > elems map = foldr (:) [] map\n--\n-- > let f a len = len + (length a)\n-- > foldr f 0 (fromList [(5,"a"), (3,"bbb")]) == 4\nfoldr :: (a -> b -> b) -> b -> Map k a -> b\nfoldr f z = go z\n  where\n    go z\' Tip             = z\'\n    go z\' (Bin _ _ x l r) = go (f x (go z\' r)) l\n{-# INLINE foldr #-}\n\n-- | \\(O(n)\\). A strict version of \'foldr\'. Each application of the operator is\n-- evaluated before using the result in the next application. This\n-- function is strict in the starting value.\nfoldr\' :: (a -> b -> b) -> b -> Map k a -> b\nfoldr\' f z = go z\n  where\n    go !z\' Tip            = z\'\n    go z\' (Bin _ _ x l r) = go (f x $! go z\' r) l\n{-# INLINE foldr\' #-}\n\n-- | \\(O(n)\\). Fold the values in the map using the given left-associative\n-- binary operator, such that @\'foldl\' f z == \'Prelude.foldl\' f z . \'elems\'@.\n--\n-- For example,\n--\n-- > elems = reverse . foldl (flip (:)) []\n--\n-- > let f len a = len + (length a)\n-- > foldl f 0 (fromList [(5,"a"), (3,"bbb")]) == 4\nfoldl :: (a -> b -> a) -> a -> Map k b -> a\nfoldl f z = go z\n  where\n    go z\' Tip             = z\'\n    go z\' (Bin _ _ x l r) = go (f (go z\' l) x) r\n{-# INLINE foldl #-}\n\n-- | \\(O(n)\\). A strict version of \'foldl\'. Each application of the operator is\n-- evaluated before using the result in the next application. This\n-- function is strict in the starting value.\nfoldl\' :: (a -> b -> a) -> a -> Map k b -> a\nfoldl\' f z = go z\n  where\n    go !z\' Tip            = z\'\n    go z\' (Bin _ _ x l r) =\n      let !z\'\' = go z\' l\n      in go (f z\'\' x) r\n{-# INLINE foldl\' #-}\n\n-- | \\(O(n)\\). Fold the keys and values in the map using the given right-associative\n-- binary operator, such that\n-- @\'foldrWithKey\' f z == \'Prelude.foldr\' (\'uncurry\' f) z . \'toAscList\'@.\n--\n-- For example,\n--\n-- > keys map = foldrWithKey (\\k x ks -> k:ks) [] map\n--\n-- > let f k a result = result ++ "(" ++ (show k) ++ ":" ++ a ++ ")"\n-- > foldrWithKey f "Map: " (fromList [(5,"a"), (3,"b")]) == "Map: (5:a)(3:b)"\nfoldrWithKey :: (k -> a -> b -> b) -> b -> Map k a -> b\nfoldrWithKey f z = go z\n  where\n    go z\' Tip             = z\'\n    go z\' (Bin _ kx x l r) = go (f kx x (go z\' r)) l\n{-# INLINE foldrWithKey #-}\n\n-- | \\(O(n)\\). A strict version of \'foldrWithKey\'. Each application of the operator is\n-- evaluated before using the result in the next application. This\n-- function is strict in the starting value.\nfoldrWithKey\' :: (k -> a -> b -> b) -> b -> Map k a -> b\nfoldrWithKey\' f z = go z\n  where\n    go !z\' Tip              = z\'\n    go z\' (Bin _ kx x l r) = go (f kx x $! go z\' r) l\n{-# INLINE foldrWithKey\' #-}\n\n-- | \\(O(n)\\). Fold the keys and values in the map using the given left-associative\n-- binary operator, such that\n-- @\'foldlWithKey\' f z == \'Prelude.foldl\' (\\\\z\' (kx, x) -> f z\' kx x) z . \'toAscList\'@.\n--\n-- For example,\n--\n-- > keys = reverse . foldlWithKey (\\ks k x -> k:ks) []\n--\n-- > let f result k a = result ++ "(" ++ (show k) ++ ":" ++ a ++ ")"\n-- > foldlWithKey f "Map: " (fromList [(5,"a"), (3,"b")]) == "Map: (3:b)(5:a)"\nfoldlWithKey :: (a -> k -> b -> a) -> a -> Map k b -> a\nfoldlWithKey f z = go z\n  where\n    go z\' Tip              = z\'\n    go z\' (Bin _ kx x l r) = go (f (go z\' l) kx x) r\n{-# INLINE foldlWithKey #-}\n\n-- | \\(O(n)\\). A strict version of \'foldlWithKey\'. Each application of the operator is\n-- evaluated before using the result in the next application. This\n-- function is strict in the starting value.\nfoldlWithKey\' :: (a -> k -> b -> a) -> a -> Map k b -> a\nfoldlWithKey\' f z = go z\n  where\n    go !z\' Tip             = z\'\n    go z\' (Bin _ kx x l r) =\n      let !z\'\' = go z\' l\n      in go (f z\'\' kx x) r\n{-# INLINE foldlWithKey\' #-}\n\n-- | \\(O(n)\\). Fold the keys and values in the map using the given monoid, such that\n--\n-- @\'foldMapWithKey\' f = \'Prelude.fold\' . \'mapWithKey\' f@\n--\n-- This can be an asymptotically faster than \'foldrWithKey\' or \'foldlWithKey\' for some monoids.\n--\n-- @since 0.5.4\nfoldMapWithKey :: Monoid m => (k -> a -> m) -> Map k a -> m\nfoldMapWithKey f = go\n  where\n    go Tip             = mempty\n    go (Bin 1 k v _ _) = f k v\n    go (Bin _ k v l r) = go l `mappend` (f k v `mappend` go r)\n{-# INLINE foldMapWithKey #-}\n\n{--------------------------------------------------------------------\n  List variations\n--------------------------------------------------------------------}\n-- | \\(O(n)\\).\n-- Return all elements of the map in the ascending order of their keys.\n-- Subject to list fusion.\n--\n-- > elems (fromList [(5,"a"), (3,"b")]) == ["b","a"]\n-- > elems empty == []\n\nelems :: Map k a -> [a]\nelems = foldr (:) []\n\n-- | \\(O(n)\\). Return all keys of the map in ascending order. Subject to list\n-- fusion.\n--\n-- > keys (fromList [(5,"a"), (3,"b")]) == [3,5]\n-- > keys empty == []\n\nkeys  :: Map k a -> [k]\nkeys = foldrWithKey (\\k _ ks -> k : ks) []\n\n-- | \\(O(n)\\). An alias for \'toAscList\'. Return all key\\/value pairs in the map\n-- in ascending key order. Subject to list fusion.\n--\n-- > assocs (fromList [(5,"a"), (3,"b")]) == [(3,"b"), (5,"a")]\n-- > assocs empty == []\n\nassocs :: Map k a -> [(k,a)]\nassocs m\n  = toAscList m\n\n-- | \\(O(n)\\). The set of all keys of the map.\n--\n-- > keysSet (fromList [(5,"a"), (3,"b")]) == Data.Set.fromList [3,5]\n-- > keysSet empty == Data.Set.empty\n\nkeysSet :: Map k a -> Set.Set k\nkeysSet Tip = Set.Tip\nkeysSet (Bin sz kx _ l r) = Set.Bin sz kx (keysSet l) (keysSet r)\n\n-- | \\(O(n)\\). The set of all elements of the map contained in \'Arg\'s.\n--\n-- > argSet (fromList [(5,"a"), (3,"b")]) == Data.Set.fromList [Arg 3 "b",Arg 5 "a"]\n-- > argSet empty == Data.Set.empty\n\nargSet :: Map k a -> Set.Set (Arg k a)\nargSet Tip = Set.Tip\nargSet (Bin sz kx x l r) = Set.Bin sz (Arg kx x) (argSet l) (argSet r)\n\n-- | \\(O(n)\\). Build a map from a set of keys and a function which for each key\n-- computes its value.\n--\n-- > fromSet (\\k -> replicate k \'a\') (Data.Set.fromList [3, 5]) == fromList [(5,"aaaaa"), (3,"aaa")]\n-- > fromSet undefined Data.Set.empty == empty\n\nfromSet :: (k -> a) -> Set.Set k -> Map k a\nfromSet _ Set.Tip = Tip\nfromSet f (Set.Bin sz x l r) = Bin sz x (f x) (fromSet f l) (fromSet f r)\n\n-- | \\(O(n)\\). Build a map from a set of elements contained inside \'Arg\'s.\n--\n-- > fromArgSet (Data.Set.fromList [Arg 3 "aaa", Arg 5 "aaaaa"]) == fromList [(5,"aaaaa"), (3,"aaa")]\n-- > fromArgSet Data.Set.empty == empty\n\nfromArgSet :: Set.Set (Arg k a) -> Map k a\nfromArgSet Set.Tip = Tip\nfromArgSet (Set.Bin sz (Arg x v) l r) = Bin sz x v (fromArgSet l) (fromArgSet r)\n\n{--------------------------------------------------------------------\n  Lists\n--------------------------------------------------------------------}\n\n#ifdef __GLASGOW_HASKELL__\n-- | @since 0.5.6.2\ninstance (Ord k) => GHCExts.IsList (Map k v) where\n  type Item (Map k v) = (k,v)\n  fromList = fromList\n  toList   = toList\n#endif\n\n-- | \\(O(n \\log n)\\). Build a map from a list of key\\/value pairs. See also \'fromAscList\'.\n-- If the list contains more than one value for the same key, the last value\n-- for the key is retained.\n--\n-- If the keys of the list are ordered, linear-time implementation is used,\n-- with the performance equal to \'fromDistinctAscList\'.\n--\n-- > fromList [] == empty\n-- > fromList [(5,"a"), (3,"b"), (5, "c")] == fromList [(5,"c"), (3,"b")]\n-- > fromList [(5,"c"), (3,"b"), (5, "a")] == fromList [(5,"a"), (3,"b")]\n\n-- For some reason, when \'singleton\' is used in fromList or in\n-- create, it is not inlined, so we inline it manually.\nfromList :: Ord k => [(k,a)] -> Map k a\nfromList [] = Tip\nfromList [(kx, x)] = Bin 1 kx x Tip Tip\nfromList ((kx0, x0) : xs0) | not_ordered kx0 xs0 = fromList\' (Bin 1 kx0 x0 Tip Tip) xs0\n                           | otherwise = go (1::Int) (Bin 1 kx0 x0 Tip Tip) xs0\n  where\n    not_ordered _ [] = False\n    not_ordered kx ((ky,_) : _) = kx >= ky\n    {-# INLINE not_ordered #-}\n\n    fromList\' t0 xs = Foldable.foldl\' ins t0 xs\n      where ins t (k,x) = insert k x t\n\n    go !_ t [] = t\n    go _ t [(kx, x)] = insertMax kx x t\n    go s l xs@((kx, x) : xss) | not_ordered kx xss = fromList\' l xs\n                              | otherwise = case create s xss of\n                                  (r, ys, []) -> go (s `shiftL` 1) (link kx x l r) ys\n                                  (r, _,  ys) -> fromList\' (link kx x l r) ys\n\n    -- The create is returning a triple (tree, xs, ys). Both xs and ys\n    -- represent not yet processed elements and only one of them can be nonempty.\n    -- If ys is nonempty, the keys in ys are not ordered with respect to tree\n    -- and must be inserted using fromList\'. Otherwise the keys have been\n    -- ordered so far.\n    create !_ [] = (Tip, [], [])\n    create s xs@(xp : xss)\n      | s == 1 = case xp of (kx, x) | not_ordered kx xss -> (Bin 1 kx x Tip Tip, [], xss)\n                                    | otherwise -> (Bin 1 kx x Tip Tip, xss, [])\n      | otherwise = case create (s `shiftR` 1) xs of\n                      res@(_, [], _) -> res\n                      (l, [(ky, y)], zs) -> (insertMax ky y l, [], zs)\n                      (l, ys@((ky, y):yss), _) | not_ordered ky yss -> (l, [], ys)\n                                               | otherwise -> case create (s `shiftR` 1) yss of\n                                                   (r, zs, ws) -> (link ky y l r, zs, ws)\n#if __GLASGOW_HASKELL__\n{-# INLINABLE fromList #-}\n#endif\n\n-- | \\(O(n \\log n)\\). Build a map from a list of key\\/value pairs with a combining function. See also \'fromAscListWith\'.\n--\n-- > fromListWith (++) [(5,"a"), (5,"b"), (3,"b"), (3,"a"), (5,"a")] == fromList [(3, "ab"), (5, "aba")]\n-- > fromListWith (++) [] == empty\n\nfromListWith :: Ord k => (a -> a -> a) -> [(k,a)] -> Map k a\nfromListWith f xs\n  = fromListWithKey (\\_ x y -> f x y) xs\n#if __GLASGOW_HASKELL__\n{-# INLINABLE fromListWith #-}\n#endif\n\n-- | \\(O(n \\log n)\\). Build a map from a list of key\\/value pairs with a combining function. See also \'fromAscListWithKey\'.\n--\n-- > let f key new_value old_value = show key ++ ":" ++ new_value ++ "|" ++ old_value\n-- > fromListWithKey f [(5,"a"), (5,"b"), (3,"b"), (3,"a"), (5,"c")] == fromList [(3, "3:a|b"), (5, "5:c|5:b|a")]\n-- > fromListWithKey f [] == empty\n\nfromListWithKey :: Ord k => (k -> a -> a -> a) -> [(k,a)] -> Map k a\nfromListWithKey f xs\n  = Foldable.foldl\' ins empty xs\n  where\n    ins t (k,x) = insertWithKey f k x t\n#if __GLASGOW_HASKELL__\n{-# INLINABLE fromListWithKey #-}\n#endif\n\n-- | \\(O(n)\\). Convert the map to a list of key\\/value pairs. Subject to list fusion.\n--\n-- > toList (fromList [(5,"a"), (3,"b")]) == [(3,"b"), (5,"a")]\n-- > toList empty == []\n\ntoList :: Map k a -> [(k,a)]\ntoList = toAscList\n\n-- | \\(O(n)\\). Convert the map to a list of key\\/value pairs where the keys are\n-- in ascending order. Subject to list fusion.\n--\n-- > toAscList (fromList [(5,"a"), (3,"b")]) == [(3,"b"), (5,"a")]\n\ntoAscList :: Map k a -> [(k,a)]\ntoAscList = foldrWithKey (\\k x xs -> (k,x):xs) []\n\n-- | \\(O(n)\\). Convert the map to a list of key\\/value pairs where the keys\n-- are in descending order. Subject to list fusion.\n--\n-- > toDescList (fromList [(5,"a"), (3,"b")]) == [(5,"a"), (3,"b")]\n\ntoDescList :: Map k a -> [(k,a)]\ntoDescList = foldlWithKey (\\xs k x -> (k,x):xs) []\n\n-- List fusion for the list generating functions.\n#if __GLASGOW_HASKELL__\n-- The foldrFB and foldlFB are fold{r,l}WithKey equivalents, used for list fusion.\n-- They are important to convert unfused methods back, see mapFB in prelude.\nfoldrFB :: (k -> a -> b -> b) -> b -> Map k a -> b\nfoldrFB = foldrWithKey\n{-# INLINE[0] foldrFB #-}\nfoldlFB :: (a -> k -> b -> a) -> a -> Map k b -> a\nfoldlFB = foldlWithKey\n{-# INLINE[0] foldlFB #-}\n\n-- Inline assocs and toList, so that we need to fuse only toAscList.\n{-# INLINE assocs #-}\n{-# INLINE toList #-}\n\n-- The fusion is enabled up to phase 2 included. If it does not succeed,\n-- convert in phase 1 the expanded elems,keys,to{Asc,Desc}List calls back to\n-- elems,keys,to{Asc,Desc}List.  In phase 0, we inline fold{lr}FB (which were\n-- used in a list fusion, otherwise it would go away in phase 1), and let compiler\n-- do whatever it wants with elems,keys,to{Asc,Desc}List -- it was forbidden to\n-- inline it before phase 0, otherwise the fusion rules would not fire at all.\n{-# NOINLINE[0] elems #-}\n{-# NOINLINE[0] keys #-}\n{-# NOINLINE[0] toAscList #-}\n{-# NOINLINE[0] toDescList #-}\n{-# RULES "Map.elems" [~1] forall m . elems m = build (\\c n -> foldrFB (\\_ x xs -> c x xs) n m) #-}\n{-# RULES "Map.elemsBack" [1] foldrFB (\\_ x xs -> x : xs) [] = elems #-}\n{-# RULES "Map.keys" [~1] forall m . keys m = build (\\c n -> foldrFB (\\k _ xs -> c k xs) n m) #-}\n{-# RULES "Map.keysBack" [1] foldrFB (\\k _ xs -> k : xs) [] = keys #-}\n{-# RULES "Map.toAscList" [~1] forall m . toAscList m = build (\\c n -> foldrFB (\\k x xs -> c (k,x) xs) n m) #-}\n{-# RULES "Map.toAscListBack" [1] foldrFB (\\k x xs -> (k, x) : xs) [] = toAscList #-}\n{-# RULES "Map.toDescList" [~1] forall m . toDescList m = build (\\c n -> foldlFB (\\xs k x -> c (k,x) xs) n m) #-}\n{-# RULES "Map.toDescListBack" [1] foldlFB (\\xs k x -> (k, x) : xs) [] = toDescList #-}\n#endif\n\n{--------------------------------------------------------------------\n  Building trees from ascending/descending lists can be done in linear time.\n\n  Note that if [xs] is ascending that:\n    fromAscList xs       == fromList xs\n    fromAscListWith f xs == fromListWith f xs\n--------------------------------------------------------------------}\n-- | \\(O(n)\\). Build a map from an ascending list in linear time.\n-- /The precondition (input list is ascending) is not checked./\n--\n-- > fromAscList [(3,"b"), (5,"a")]          == fromList [(3, "b"), (5, "a")]\n-- > fromAscList [(3,"b"), (5,"a"), (5,"b")] == fromList [(3, "b"), (5, "b")]\n-- > valid (fromAscList [(3,"b"), (5,"a"), (5,"b")]) == True\n-- > valid (fromAscList [(5,"a"), (3,"b"), (5,"b")]) == False\n\nfromAscList :: Eq k => [(k,a)] -> Map k a\nfromAscList xs\n  = fromDistinctAscList (combineEq xs)\n  where\n  -- [combineEq f xs] combines equal elements with function [f] in an ordered list [xs]\n  combineEq xs\'\n    = case xs\' of\n        []     -> []\n        [x]    -> [x]\n        (x:xx) -> combineEq\' x xx\n\n  combineEq\' z [] = [z]\n  combineEq\' z@(kz,_) (x@(kx,xx):xs\')\n    | kx==kz    = combineEq\' (kx,xx) xs\'\n    | otherwise = z:combineEq\' x xs\'\n#if __GLASGOW_HASKELL__\n{-# INLINABLE fromAscList #-}\n#endif\n\n-- | \\(O(n)\\). Build a map from a descending list in linear time.\n-- /The precondition (input list is descending) is not checked./\n--\n-- > fromDescList [(5,"a"), (3,"b")]          == fromList [(3, "b"), (5, "a")]\n-- > fromDescList [(5,"a"), (5,"b"), (3,"b")] == fromList [(3, "b"), (5, "b")]\n-- > valid (fromDescList [(5,"a"), (5,"b"), (3,"b")]) == True\n-- > valid (fromDescList [(5,"a"), (3,"b"), (5,"b")]) == False\n--\n-- @since 0.5.8\n\nfromDescList :: Eq k => [(k,a)] -> Map k a\nfromDescList xs = fromDistinctDescList (combineEq xs)\n  where\n  -- [combineEq f xs] combines equal elements with function [f] in an ordered list [xs]\n  combineEq xs\'\n    = case xs\' of\n        []     -> []\n        [x]    -> [x]\n        (x:xx) -> combineEq\' x xx\n\n  combineEq\' z [] = [z]\n  combineEq\' z@(kz,_) (x@(kx,xx):xs\')\n    | kx==kz    = combineEq\' (kx,xx) xs\'\n    | otherwise = z:combineEq\' x xs\'\n#if __GLASGOW_HASKELL__\n{-# INLINABLE fromDescList #-}\n#endif\n\n-- | \\(O(n)\\). Build a map from an ascending list in linear time with a combining function for equal keys.\n-- /The precondition (input list is ascending) is not checked./\n--\n-- > fromAscListWith (++) [(3,"b"), (5,"a"), (5,"b")] == fromList [(3, "b"), (5, "ba")]\n-- > valid (fromAscListWith (++) [(3,"b"), (5,"a"), (5,"b")]) == True\n-- > valid (fromAscListWith (++) [(5,"a"), (3,"b"), (5,"b")]) == False\n\nfromAscListWith :: Eq k => (a -> a -> a) -> [(k,a)] -> Map k a\nfromAscListWith f xs\n  = fromAscListWithKey (\\_ x y -> f x y) xs\n#if __GLASGOW_HASKELL__\n{-# INLINABLE fromAscListWith #-}\n#endif\n\n-- | \\(O(n)\\). Build a map from a descending list in linear time with a combining function for equal keys.\n-- /The precondition (input list is descending) is not checked./\n--\n-- > fromDescListWith (++) [(5,"a"), (5,"b"), (3,"b")] == fromList [(3, "b"), (5, "ba")]\n-- > valid (fromDescListWith (++) [(5,"a"), (5,"b"), (3,"b")]) == True\n-- > valid (fromDescListWith (++) [(5,"a"), (3,"b"), (5,"b")]) == False\n--\n-- @since 0.5.8\n\nfromDescListWith :: Eq k => (a -> a -> a) -> [(k,a)] -> Map k a\nfromDescListWith f xs\n  = fromDescListWithKey (\\_ x y -> f x y) xs\n#if __GLASGOW_HASKELL__\n{-# INLINABLE fromDescListWith #-}\n#endif\n\n-- | \\(O(n)\\). Build a map from an ascending list in linear time with a\n-- combining function for equal keys.\n-- /The precondition (input list is ascending) is not checked./\n--\n-- > let f k a1 a2 = (show k) ++ ":" ++ a1 ++ a2\n-- > fromAscListWithKey f [(3,"b"), (5,"a"), (5,"b"), (5,"b")] == fromList [(3, "b"), (5, "5:b5:ba")]\n-- > valid (fromAscListWithKey f [(3,"b"), (5,"a"), (5,"b"), (5,"b")]) == True\n-- > valid (fromAscListWithKey f [(5,"a"), (3,"b"), (5,"b"), (5,"b")]) == False\n\nfromAscListWithKey :: Eq k => (k -> a -> a -> a) -> [(k,a)] -> Map k a\nfromAscListWithKey f xs\n  = fromDistinctAscList (combineEq f xs)\n  where\n  -- [combineEq f xs] combines equal elements with function [f] in an ordered list [xs]\n  combineEq _ xs\'\n    = case xs\' of\n        []     -> []\n        [x]    -> [x]\n        (x:xx) -> combineEq\' x xx\n\n  combineEq\' z [] = [z]\n  combineEq\' z@(kz,zz) (x@(kx,xx):xs\')\n    | kx==kz    = let yy = f kx xx zz in combineEq\' (kx,yy) xs\'\n    | otherwise = z:combineEq\' x xs\'\n#if __GLASGOW_HASKELL__\n{-# INLINABLE fromAscListWithKey #-}\n#endif\n\n-- | \\(O(n)\\). Build a map from a descending list in linear time with a\n-- combining function for equal keys.\n-- /The precondition (input list is descending) is not checked./\n--\n-- > let f k a1 a2 = (show k) ++ ":" ++ a1 ++ a2\n-- > fromDescListWithKey f [(5,"a"), (5,"b"), (5,"b"), (3,"b")] == fromList [(3, "b"), (5, "5:b5:ba")]\n-- > valid (fromDescListWithKey f [(5,"a"), (5,"b"), (5,"b"), (3,"b")]) == True\n-- > valid (fromDescListWithKey f [(5,"a"), (3,"b"), (5,"b"), (5,"b")]) == False\nfromDescListWithKey :: Eq k => (k -> a -> a -> a) -> [(k,a)] -> Map k a\nfromDescListWithKey f xs\n  = fromDistinctDescList (combineEq f xs)\n  where\n  -- [combineEq f xs] combines equal elements with function [f] in an ordered list [xs]\n  combineEq _ xs\'\n    = case xs\' of\n        []     -> []\n        [x]    -> [x]\n        (x:xx) -> combineEq\' x xx\n\n  combineEq\' z [] = [z]\n  combineEq\' z@(kz,zz) (x@(kx,xx):xs\')\n    | kx==kz    = let yy = f kx xx zz in combineEq\' (kx,yy) xs\'\n    | otherwise = z:combineEq\' x xs\'\n#if __GLASGOW_HASKELL__\n{-# INLINABLE fromDescListWithKey #-}\n#endif\n\n\n-- | \\(O(n)\\). Build a map from an ascending list of distinct elements in linear time.\n-- /The precondition is not checked./\n--\n-- > fromDistinctAscList [(3,"b"), (5,"a")] == fromList [(3, "b"), (5, "a")]\n-- > valid (fromDistinctAscList [(3,"b"), (5,"a")])          == True\n-- > valid (fromDistinctAscList [(3,"b"), (5,"a"), (5,"b")]) == False\n\n-- For some reason, when \'singleton\' is used in fromDistinctAscList or in\n-- create, it is not inlined, so we inline it manually.\nfromDistinctAscList :: [(k,a)] -> Map k a\nfromDistinctAscList [] = Tip\nfromDistinctAscList ((kx0, x0) : xs0) = go (1::Int) (Bin 1 kx0 x0 Tip Tip) xs0\n  where\n    go !_ t [] = t\n    go s l ((kx, x) : xs) = case create s xs of\n                                (r :*: ys) -> let !t\' = link kx x l r\n                                              in go (s `shiftL` 1) t\' ys\n\n    create !_ [] = (Tip :*: [])\n    create s xs@(x\' : xs\')\n      | s == 1 = case x\' of (kx, x) -> (Bin 1 kx x Tip Tip :*: xs\')\n      | otherwise = case create (s `shiftR` 1) xs of\n                      res@(_ :*: []) -> res\n                      (l :*: (ky, y):ys) -> case create (s `shiftR` 1) ys of\n                        (r :*: zs) -> (link ky y l r :*: zs)\n\n-- | \\(O(n)\\). Build a map from a descending list of distinct elements in linear time.\n-- /The precondition is not checked./\n--\n-- > fromDistinctDescList [(5,"a"), (3,"b")] == fromList [(3, "b"), (5, "a")]\n-- > valid (fromDistinctDescList [(5,"a"), (3,"b")])          == True\n-- > valid (fromDistinctDescList [(5,"a"), (5,"b"), (3,"b")]) == False\n--\n-- @since 0.5.8\n\n-- For some reason, when \'singleton\' is used in fromDistinctDescList or in\n-- create, it is not inlined, so we inline it manually.\nfromDistinctDescList :: [(k,a)] -> Map k a\nfromDistinctDescList [] = Tip\nfromDistinctDescList ((kx0, x0) : xs0) = go (1 :: Int) (Bin 1 kx0 x0 Tip Tip) xs0\n  where\n     go !_ t [] = t\n     go s r ((kx, x) : xs) = case create s xs of\n                               (l :*: ys) -> let !t\' = link kx x l r\n                                             in go (s `shiftL` 1) t\' ys\n\n     create !_ [] = (Tip :*: [])\n     create s xs@(x\' : xs\')\n       | s == 1 = case x\' of (kx, x) -> (Bin 1 kx x Tip Tip :*: xs\')\n       | otherwise = case create (s `shiftR` 1) xs of\n                       res@(_ :*: []) -> res\n                       (r :*: (ky, y):ys) -> case create (s `shiftR` 1) ys of\n                         (l :*: zs) -> (link ky y l r :*: zs)\n\n{-\n-- Functions very similar to these were used to implement\n-- hedge union, intersection, and difference algorithms that we no\n-- longer use. These functions, however, seem likely to be useful\n-- in their own right, so I\'m leaving them here in case we end up\n-- exporting them.\n\n{--------------------------------------------------------------------\n  [filterGt b t] filter all keys >[b] from tree [t]\n  [filterLt b t] filter all keys <[b] from tree [t]\n--------------------------------------------------------------------}\nfilterGt :: Ord k => k -> Map k v -> Map k v\nfilterGt !_ Tip = Tip\nfilterGt !b (Bin _ kx x l r) =\n  case compare b kx of LT -> link kx x (filterGt b l) r\n                       EQ -> r\n                       GT -> filterGt b r\n#if __GLASGOW_HASKELL__\n{-# INLINABLE filterGt #-}\n#endif\n\nfilterLt :: Ord k => k -> Map k v -> Map k v\nfilterLt !_ Tip = Tip\nfilterLt !b (Bin _ kx x l r) =\n  case compare kx b of LT -> link kx x l (filterLt b r)\n                       EQ -> l\n                       GT -> filterLt b l\n#if __GLASGOW_HASKELL__\n{-# INLINABLE filterLt #-}\n#endif\n-}\n\n{--------------------------------------------------------------------\n  Split\n--------------------------------------------------------------------}\n-- | \\(O(\\log n)\\). The expression (@\'split\' k map@) is a pair @(map1,map2)@ where\n-- the keys in @map1@ are smaller than @k@ and the keys in @map2@ larger than @k@.\n-- Any key equal to @k@ is found in neither @map1@ nor @map2@.\n--\n-- > split 2 (fromList [(5,"a"), (3,"b")]) == (empty, fromList [(3,"b"), (5,"a")])\n-- > split 3 (fromList [(5,"a"), (3,"b")]) == (empty, singleton 5 "a")\n-- > split 4 (fromList [(5,"a"), (3,"b")]) == (singleton 3 "b", singleton 5 "a")\n-- > split 5 (fromList [(5,"a"), (3,"b")]) == (singleton 3 "b", empty)\n-- > split 6 (fromList [(5,"a"), (3,"b")]) == (fromList [(3,"b"), (5,"a")], empty)\n\nsplit :: Ord k => k -> Map k a -> (Map k a,Map k a)\nsplit !k0 t0 = toPair $ go k0 t0\n  where\n    go k t =\n      case t of\n        Tip            -> Tip :*: Tip\n        Bin _ kx x l r -> case compare k kx of\n          LT -> let (lt :*: gt) = go k l in lt :*: link kx x gt r\n          GT -> let (lt :*: gt) = go k r in link kx x l lt :*: gt\n          EQ -> (l :*: r)\n#if __GLASGOW_HASKELL__\n{-# INLINABLE split #-}\n#endif\n\n-- | \\(O(\\log n)\\). The expression (@\'splitLookup\' k map@) splits a map just\n-- like \'split\' but also returns @\'lookup\' k map@.\n--\n-- > splitLookup 2 (fromList [(5,"a"), (3,"b")]) == (empty, Nothing, fromList [(3,"b"), (5,"a")])\n-- > splitLookup 3 (fromList [(5,"a"), (3,"b")]) == (empty, Just "b", singleton 5 "a")\n-- > splitLookup 4 (fromList [(5,"a"), (3,"b")]) == (singleton 3 "b", Nothing, singleton 5 "a")\n-- > splitLookup 5 (fromList [(5,"a"), (3,"b")]) == (singleton 3 "b", Just "a", empty)\n-- > splitLookup 6 (fromList [(5,"a"), (3,"b")]) == (fromList [(3,"b"), (5,"a")], Nothing, empty)\nsplitLookup :: Ord k => k -> Map k a -> (Map k a,Maybe a,Map k a)\nsplitLookup k0 m = case go k0 m of\n     StrictTriple l mv r -> (l, mv, r)\n  where\n    go :: Ord k => k -> Map k a -> StrictTriple (Map k a) (Maybe a) (Map k a)\n    go !k t =\n      case t of\n        Tip            -> StrictTriple Tip Nothing Tip\n        Bin _ kx x l r -> case compare k kx of\n          LT -> let StrictTriple lt z gt = go k l\n                    !gt\' = link kx x gt r\n                in StrictTriple lt z gt\'\n          GT -> let StrictTriple lt z gt = go k r\n                    !lt\' = link kx x l lt\n                in StrictTriple lt\' z gt\n          EQ -> StrictTriple l (Just x) r\n#if __GLASGOW_HASKELL__\n{-# INLINABLE splitLookup #-}\n#endif\n\n-- | \\(O(\\log n)\\). A variant of \'splitLookup\' that indicates only whether the\n-- key was present, rather than producing its value. This is used to\n-- implement \'intersection\' to avoid allocating unnecessary \'Just\'\n-- constructors.\nsplitMember :: Ord k => k -> Map k a -> (Map k a,Bool,Map k a)\nsplitMember k0 m = case go k0 m of\n     StrictTriple l mv r -> (l, mv, r)\n  where\n    go :: Ord k => k -> Map k a -> StrictTriple (Map k a) Bool (Map k a)\n    go !k t =\n      case t of\n        Tip            -> StrictTriple Tip False Tip\n        Bin _ kx x l r -> case compare k kx of\n          LT -> let StrictTriple lt z gt = go k l\n                    !gt\' = link kx x gt r\n                in StrictTriple lt z gt\'\n          GT -> let StrictTriple lt z gt = go k r\n                    !lt\' = link kx x l lt\n                in StrictTriple lt\' z gt\n          EQ -> StrictTriple l True r\n#if __GLASGOW_HASKELL__\n{-# INLINABLE splitMember #-}\n#endif\n\ndata StrictTriple a b c = StrictTriple !a !b !c\n\n{--------------------------------------------------------------------\n  Utility functions that maintain the balance properties of the tree.\n  All constructors assume that all values in [l] < [k] and all values\n  in [r] > [k], and that [l] and [r] are valid trees.\n\n  In order of sophistication:\n    [Bin sz k x l r]  The type constructor.\n    [bin k x l r]     Maintains the correct size, assumes that both [l]\n                      and [r] are balanced with respect to each other.\n    [balance k x l r] Restores the balance and size.\n                      Assumes that the original tree was balanced and\n                      that [l] or [r] has changed by at most one element.\n    [link k x l r]    Restores balance and size.\n\n  Furthermore, we can construct a new tree from two trees. Both operations\n  assume that all values in [l] < all values in [r] and that [l] and [r]\n  are valid:\n    [glue l r]        Glues [l] and [r] together. Assumes that [l] and\n                      [r] are already balanced with respect to each other.\n    [link2 l r]       Merges two trees and restores balance.\n--------------------------------------------------------------------}\n\n{--------------------------------------------------------------------\n  Link\n--------------------------------------------------------------------}\nlink :: k -> a -> Map k a -> Map k a -> Map k a\nlink kx x Tip r  = insertMin kx x r\nlink kx x l Tip  = insertMax kx x l\nlink kx x l@(Bin sizeL ky y ly ry) r@(Bin sizeR kz z lz rz)\n  | delta*sizeL < sizeR  = balanceL kz z (link kx x l lz) rz\n  | delta*sizeR < sizeL  = balanceR ky y ly (link kx x ry r)\n  | otherwise            = bin kx x l r\n\n\n-- insertMin and insertMax don\'t perform potentially expensive comparisons.\ninsertMax,insertMin :: k -> a -> Map k a -> Map k a\ninsertMax kx x t\n  = case t of\n      Tip -> singleton kx x\n      Bin _ ky y l r\n          -> balanceR ky y l (insertMax kx x r)\n\ninsertMin kx x t\n  = case t of\n      Tip -> singleton kx x\n      Bin _ ky y l r\n          -> balanceL ky y (insertMin kx x l) r\n\n{--------------------------------------------------------------------\n  [link2 l r]: merges two trees.\n--------------------------------------------------------------------}\nlink2 :: Map k a -> Map k a -> Map k a\nlink2 Tip r   = r\nlink2 l Tip   = l\nlink2 l@(Bin sizeL kx x lx rx) r@(Bin sizeR ky y ly ry)\n  | delta*sizeL < sizeR = balanceL ky y (link2 l ly) ry\n  | delta*sizeR < sizeL = balanceR kx x lx (link2 rx r)\n  | otherwise           = glue l r\n\n{--------------------------------------------------------------------\n  [glue l r]: glues two trees together.\n  Assumes that [l] and [r] are already balanced with respect to each other.\n--------------------------------------------------------------------}\nglue :: Map k a -> Map k a -> Map k a\nglue Tip r = r\nglue l Tip = l\nglue l@(Bin sl kl xl ll lr) r@(Bin sr kr xr rl rr)\n  | sl > sr = let !(MaxView km m l\') = maxViewSure kl xl ll lr in balanceR km m l\' r\n  | otherwise = let !(MinView km m r\') = minViewSure kr xr rl rr in balanceL km m l r\'\n\ndata MinView k a = MinView !k a !(Map k a)\ndata MaxView k a = MaxView !k a !(Map k a)\n\nminViewSure :: k -> a -> Map k a -> Map k a -> MinView k a\nminViewSure = go\n  where\n    go k x Tip r = MinView k x r\n    go k x (Bin _ kl xl ll lr) r =\n      case go kl xl ll lr of\n        MinView km xm l\' -> MinView km xm (balanceR k x l\' r)\n{-# NOINLINE minViewSure #-}\n\nmaxViewSure :: k -> a -> Map k a -> Map k a -> MaxView k a\nmaxViewSure = go\n  where\n    go k x l Tip = MaxView k x l\n    go k x l (Bin _ kr xr rl rr) =\n      case go kr xr rl rr of\n        MaxView km xm r\' -> MaxView km xm (balanceL k x l r\')\n{-# NOINLINE maxViewSure #-}\n\n-- | \\(O(\\log n)\\). Delete and find the minimal element.\n--\n-- > deleteFindMin (fromList [(5,"a"), (3,"b"), (10,"c")]) == ((3,"b"), fromList[(5,"a"), (10,"c")])\n-- > deleteFindMin empty                                      Error: can not return the minimal element of an empty map\n\ndeleteFindMin :: Map k a -> ((k,a),Map k a)\ndeleteFindMin t = case minViewWithKey t of\n  Nothing -> (error "Map.deleteFindMin: can not return the minimal element of an empty map", Tip)\n  Just res -> res\n\n-- | \\(O(\\log n)\\). Delete and find the maximal element.\n--\n-- > deleteFindMax (fromList [(5,"a"), (3,"b"), (10,"c")]) == ((10,"c"), fromList [(3,"b"), (5,"a")])\n-- > deleteFindMax empty                                      Error: can not return the maximal element of an empty map\n\ndeleteFindMax :: Map k a -> ((k,a),Map k a)\ndeleteFindMax t = case maxViewWithKey t of\n  Nothing -> (error "Map.deleteFindMax: can not return the maximal element of an empty map", Tip)\n  Just res -> res\n\n{--------------------------------------------------------------------\n  [balance l x r] balances two trees with value x.\n  The sizes of the trees should balance after decreasing the\n  size of one of them. (a rotation).\n\n  [delta] is the maximal relative difference between the sizes of\n          two trees, it corresponds with the [w] in Adams\' paper.\n  [ratio] is the ratio between an outer and inner sibling of the\n          heavier subtree in an unbalanced setting. It determines\n          whether a double or single rotation should be performed\n          to restore balance. It is corresponds with the inverse\n          of $\\alpha$ in Adam\'s article.\n\n  Note that according to the Adam\'s paper:\n  - [delta] should be larger than 4.646 with a [ratio] of 2.\n  - [delta] should be larger than 3.745 with a [ratio] of 1.534.\n\n  But the Adam\'s paper is erroneous:\n  - It can be proved that for delta=2 and delta>=5 there does\n    not exist any ratio that would work.\n  - Delta=4.5 and ratio=2 does not work.\n\n  That leaves two reasonable variants, delta=3 and delta=4,\n  both with ratio=2.\n\n  - A lower [delta] leads to a more \'perfectly\' balanced tree.\n  - A higher [delta] performs less rebalancing.\n\n  In the benchmarks, delta=3 is faster on insert operations,\n  and delta=4 has slightly better deletes. As the insert speedup\n  is larger, we currently use delta=3.\n\n--------------------------------------------------------------------}\ndelta,ratio :: Int\ndelta = 3\nratio = 2\n\n-- The balance function is equivalent to the following:\n--\n--   balance :: k -> a -> Map k a -> Map k a -> Map k a\n--   balance k x l r\n--     | sizeL + sizeR <= 1    = Bin sizeX k x l r\n--     | sizeR > delta*sizeL   = rotateL k x l r\n--     | sizeL > delta*sizeR   = rotateR k x l r\n--     | otherwise             = Bin sizeX k x l r\n--     where\n--       sizeL = size l\n--       sizeR = size r\n--       sizeX = sizeL + sizeR + 1\n--\n--   rotateL :: a -> b -> Map a b -> Map a b -> Map a b\n--   rotateL k x l r@(Bin _ _ _ ly ry) | size ly < ratio*size ry = singleL k x l r\n--                                     | otherwise               = doubleL k x l r\n--\n--   rotateR :: a -> b -> Map a b -> Map a b -> Map a b\n--   rotateR k x l@(Bin _ _ _ ly ry) r | size ry < ratio*size ly = singleR k x l r\n--                                     | otherwise               = doubleR k x l r\n--\n--   singleL, singleR :: a -> b -> Map a b -> Map a b -> Map a b\n--   singleL k1 x1 t1 (Bin _ k2 x2 t2 t3)  = bin k2 x2 (bin k1 x1 t1 t2) t3\n--   singleR k1 x1 (Bin _ k2 x2 t1 t2) t3  = bin k2 x2 t1 (bin k1 x1 t2 t3)\n--\n--   doubleL, doubleR :: a -> b -> Map a b -> Map a b -> Map a b\n--   doubleL k1 x1 t1 (Bin _ k2 x2 (Bin _ k3 x3 t2 t3) t4) = bin k3 x3 (bin k1 x1 t1 t2) (bin k2 x2 t3 t4)\n--   doubleR k1 x1 (Bin _ k2 x2 t1 (Bin _ k3 x3 t2 t3)) t4 = bin k3 x3 (bin k2 x2 t1 t2) (bin k1 x1 t3 t4)\n--\n-- It is only written in such a way that every node is pattern-matched only once.\n\nbalance :: k -> a -> Map k a -> Map k a -> Map k a\nbalance k x l r = case l of\n  Tip -> case r of\n           Tip -> Bin 1 k x Tip Tip\n           (Bin _ _ _ Tip Tip) -> Bin 2 k x Tip r\n           (Bin _ rk rx Tip rr@(Bin _ _ _ _ _)) -> Bin 3 rk rx (Bin 1 k x Tip Tip) rr\n           (Bin _ rk rx (Bin _ rlk rlx _ _) Tip) -> Bin 3 rlk rlx (Bin 1 k x Tip Tip) (Bin 1 rk rx Tip Tip)\n           (Bin rs rk rx rl@(Bin rls rlk rlx rll rlr) rr@(Bin rrs _ _ _ _))\n             | rls < ratio*rrs -> Bin (1+rs) rk rx (Bin (1+rls) k x Tip rl) rr\n             | otherwise -> Bin (1+rs) rlk rlx (Bin (1+size rll) k x Tip rll) (Bin (1+rrs+size rlr) rk rx rlr rr)\n\n  (Bin ls lk lx ll lr) -> case r of\n           Tip -> case (ll, lr) of\n                    (Tip, Tip) -> Bin 2 k x l Tip\n                    (Tip, (Bin _ lrk lrx _ _)) -> Bin 3 lrk lrx (Bin 1 lk lx Tip Tip) (Bin 1 k x Tip Tip)\n                    ((Bin _ _ _ _ _), Tip) -> Bin 3 lk lx ll (Bin 1 k x Tip Tip)\n                    ((Bin lls _ _ _ _), (Bin lrs lrk lrx lrl lrr))\n                      | lrs < ratio*lls -> Bin (1+ls) lk lx ll (Bin (1+lrs) k x lr Tip)\n                      | otherwise -> Bin (1+ls) lrk lrx (Bin (1+lls+size lrl) lk lx ll lrl) (Bin (1+size lrr) k x lrr Tip)\n           (Bin rs rk rx rl rr)\n              | rs > delta*ls  -> case (rl, rr) of\n                   (Bin rls rlk rlx rll rlr, Bin rrs _ _ _ _)\n                     | rls < ratio*rrs -> Bin (1+ls+rs) rk rx (Bin (1+ls+rls) k x l rl) rr\n                     | otherwise -> Bin (1+ls+rs) rlk rlx (Bin (1+ls+size rll) k x l rll) (Bin (1+rrs+size rlr) rk rx rlr rr)\n                   (_, _) -> error "Failure in Data.Map.balance"\n              | ls > delta*rs  -> case (ll, lr) of\n                   (Bin lls _ _ _ _, Bin lrs lrk lrx lrl lrr)\n                     | lrs < ratio*lls -> Bin (1+ls+rs) lk lx ll (Bin (1+rs+lrs) k x lr r)\n                     | otherwise -> Bin (1+ls+rs) lrk lrx (Bin (1+lls+size lrl) lk lx ll lrl) (Bin (1+rs+size lrr) k x lrr r)\n                   (_, _) -> error "Failure in Data.Map.balance"\n              | otherwise -> Bin (1+ls+rs) k x l r\n{-# NOINLINE balance #-}\n\n-- Functions balanceL and balanceR are specialised versions of balance.\n-- balanceL only checks whether the left subtree is too big,\n-- balanceR only checks whether the right subtree is too big.\n\n-- balanceL is called when left subtree might have been inserted to or when\n-- right subtree might have been deleted from.\nbalanceL :: k -> a -> Map k a -> Map k a -> Map k a\nbalanceL k x l r = case r of\n  Tip -> case l of\n           Tip -> Bin 1 k x Tip Tip\n           (Bin _ _ _ Tip Tip) -> Bin 2 k x l Tip\n           (Bin _ lk lx Tip (Bin _ lrk lrx _ _)) -> Bin 3 lrk lrx (Bin 1 lk lx Tip Tip) (Bin 1 k x Tip Tip)\n           (Bin _ lk lx ll@(Bin _ _ _ _ _) Tip) -> Bin 3 lk lx ll (Bin 1 k x Tip Tip)\n           (Bin ls lk lx ll@(Bin lls _ _ _ _) lr@(Bin lrs lrk lrx lrl lrr))\n             | lrs < ratio*lls -> Bin (1+ls) lk lx ll (Bin (1+lrs) k x lr Tip)\n             | otherwise -> Bin (1+ls) lrk lrx (Bin (1+lls+size lrl) lk lx ll lrl) (Bin (1+size lrr) k x lrr Tip)\n\n  (Bin rs _ _ _ _) -> case l of\n           Tip -> Bin (1+rs) k x Tip r\n\n           (Bin ls lk lx ll lr)\n              | ls > delta*rs  -> case (ll, lr) of\n                   (Bin lls _ _ _ _, Bin lrs lrk lrx lrl lrr)\n                     | lrs < ratio*lls -> Bin (1+ls+rs) lk lx ll (Bin (1+rs+lrs) k x lr r)\n                     | otherwise -> Bin (1+ls+rs) lrk lrx (Bin (1+lls+size lrl) lk lx ll lrl) (Bin (1+rs+size lrr) k x lrr r)\n                   (_, _) -> error "Failure in Data.Map.balanceL"\n              | otherwise -> Bin (1+ls+rs) k x l r\n{-# NOINLINE balanceL #-}\n\n-- balanceR is called when right subtree might have been inserted to or when\n-- left subtree might have been deleted from.\nbalanceR :: k -> a -> Map k a -> Map k a -> Map k a\nbalanceR k x l r = case l of\n  Tip -> case r of\n           Tip -> Bin 1 k x Tip Tip\n           (Bin _ _ _ Tip Tip) -> Bin 2 k x Tip r\n           (Bin _ rk rx Tip rr@(Bin _ _ _ _ _)) -> Bin 3 rk rx (Bin 1 k x Tip Tip) rr\n           (Bin _ rk rx (Bin _ rlk rlx _ _) Tip) -> Bin 3 rlk rlx (Bin 1 k x Tip Tip) (Bin 1 rk rx Tip Tip)\n           (Bin rs rk rx rl@(Bin rls rlk rlx rll rlr) rr@(Bin rrs _ _ _ _))\n             | rls < ratio*rrs -> Bin (1+rs) rk rx (Bin (1+rls) k x Tip rl) rr\n             | otherwise -> Bin (1+rs) rlk rlx (Bin (1+size rll) k x Tip rll) (Bin (1+rrs+size rlr) rk rx rlr rr)\n\n  (Bin ls _ _ _ _) -> case r of\n           Tip -> Bin (1+ls) k x l Tip\n\n           (Bin rs rk rx rl rr)\n              | rs > delta*ls  -> case (rl, rr) of\n                   (Bin rls rlk rlx rll rlr, Bin rrs _ _ _ _)\n                     | rls < ratio*rrs -> Bin (1+ls+rs) rk rx (Bin (1+ls+rls) k x l rl) rr\n                     | otherwise -> Bin (1+ls+rs) rlk rlx (Bin (1+ls+size rll) k x l rll) (Bin (1+rrs+size rlr) rk rx rlr rr)\n                   (_, _) -> error "Failure in Data.Map.balanceR"\n              | otherwise -> Bin (1+ls+rs) k x l r\n{-# NOINLINE balanceR #-}\n\n\n{--------------------------------------------------------------------\n  The bin constructor maintains the size of the tree\n--------------------------------------------------------------------}\nbin :: k -> a -> Map k a -> Map k a -> Map k a\nbin k x l r\n  = Bin (size l + size r + 1) k x l r\n{-# INLINE bin #-}\n\n\n{--------------------------------------------------------------------\n  Eq converts the tree to a list. In a lazy setting, this\n  actually seems one of the faster methods to compare two trees\n  and it is certainly the simplest :-)\n--------------------------------------------------------------------}\ninstance (Eq k,Eq a) => Eq (Map k a) where\n  t1 == t2  = (size t1 == size t2) && (toAscList t1 == toAscList t2)\n\n{--------------------------------------------------------------------\n  Ord\n--------------------------------------------------------------------}\n\ninstance (Ord k, Ord v) => Ord (Map k v) where\n    compare m1 m2 = compare (toAscList m1) (toAscList m2)\n\n{--------------------------------------------------------------------\n  Lifted instances\n--------------------------------------------------------------------}\n\n-- | @since 0.5.9\ninstance Eq2 Map where\n    liftEq2 eqk eqv m n =\n        size m == size n && liftEq (liftEq2 eqk eqv) (toList m) (toList n)\n\n-- | @since 0.5.9\ninstance Eq k => Eq1 (Map k) where\n    liftEq = liftEq2 (==)\n\n-- | @since 0.5.9\ninstance Ord2 Map where\n    liftCompare2 cmpk cmpv m n =\n        liftCompare (liftCompare2 cmpk cmpv) (toList m) (toList n)\n\n-- | @since 0.5.9\ninstance Ord k => Ord1 (Map k) where\n    liftCompare = liftCompare2 compare\n\n-- | @since 0.5.9\ninstance Show2 Map where\n    liftShowsPrec2 spk slk spv slv d m =\n        showsUnaryWith (liftShowsPrec sp sl) "fromList" d (toList m)\n      where\n        sp = liftShowsPrec2 spk slk spv slv\n        sl = liftShowList2 spk slk spv slv\n\n-- | @since 0.5.9\ninstance Show k => Show1 (Map k) where\n    liftShowsPrec = liftShowsPrec2 showsPrec showList\n\n-- | @since 0.5.9\ninstance (Ord k, Read k) => Read1 (Map k) where\n    liftReadsPrec rp rl = readsData $\n        readsUnaryWith (liftReadsPrec rp\' rl\') "fromList" fromList\n      where\n        rp\' = liftReadsPrec rp rl\n        rl\' = liftReadList rp rl\n\n{--------------------------------------------------------------------\n  Functor\n--------------------------------------------------------------------}\ninstance Functor (Map k) where\n  fmap f m  = map f m\n#ifdef __GLASGOW_HASKELL__\n  _ <$ Tip = Tip\n  a <$ (Bin sx kx _ l r) = Bin sx kx a (a <$ l) (a <$ r)\n#endif\n\n-- | Traverses in order of increasing key.\ninstance Traversable (Map k) where\n  traverse f = traverseWithKey (\\_ -> f)\n  {-# INLINE traverse #-}\n\n-- | Folds in order of increasing key.\ninstance Foldable.Foldable (Map k) where\n  fold = go\n    where go Tip = mempty\n          go (Bin 1 _ v _ _) = v\n          go (Bin _ _ v l r) = go l `mappend` (v `mappend` go r)\n  {-# INLINABLE fold #-}\n  foldr = foldr\n  {-# INLINE foldr #-}\n  foldl = foldl\n  {-# INLINE foldl #-}\n  foldMap f t = go t\n    where go Tip = mempty\n          go (Bin 1 _ v _ _) = f v\n          go (Bin _ _ v l r) = go l `mappend` (f v `mappend` go r)\n  {-# INLINE foldMap #-}\n  foldl\' = foldl\'\n  {-# INLINE foldl\' #-}\n  foldr\' = foldr\'\n  {-# INLINE foldr\' #-}\n  length = size\n  {-# INLINE length #-}\n  null   = null\n  {-# INLINE null #-}\n  toList = elems -- NB: Foldable.toList /= Map.toList\n  {-# INLINE toList #-}\n  elem = go\n    where go !_ Tip = False\n          go x (Bin _ _ v l r) = x == v || go x l || go x r\n  {-# INLINABLE elem #-}\n  maximum = start\n    where start Tip = error "Data.Foldable.maximum (for Data.Map): empty map"\n          start (Bin _ _ v l r) = go (go v l) r\n\n          go !m Tip = m\n          go m (Bin _ _ v l r) = go (go (max m v) l) r\n  {-# INLINABLE maximum #-}\n  minimum = start\n    where start Tip = error "Data.Foldable.minimum (for Data.Map): empty map"\n          start (Bin _ _ v l r) = go (go v l) r\n\n          go !m Tip = m\n          go m (Bin _ _ v l r) = go (go (min m v) l) r\n  {-# INLINABLE minimum #-}\n  sum = foldl\' (+) 0\n  {-# INLINABLE sum #-}\n  product = foldl\' (*) 1\n  {-# INLINABLE product #-}\n\n#if MIN_VERSION_base(4,10,0)\n-- | @since 0.6.3.1\ninstance Bifoldable Map where\n  bifold = go\n    where go Tip = mempty\n          go (Bin 1 k v _ _) = k `mappend` v\n          go (Bin _ k v l r) = go l `mappend` (k `mappend` (v `mappend` go r))\n  {-# INLINABLE bifold #-}\n  bifoldr f g z = go z\n    where go z\' Tip             = z\'\n          go z\' (Bin _ k v l r) = go (f k (g v (go z\' r))) l\n  {-# INLINE bifoldr #-}\n  bifoldl f g z = go z\n    where go z\' Tip             = z\'\n          go z\' (Bin _ k v l r) = go (g (f (go z\' l) k) v) r\n  {-# INLINE bifoldl #-}\n  bifoldMap f g t = go t\n    where go Tip = mempty\n          go (Bin 1 k v _ _) = f k `mappend` g v\n          go (Bin _ k v l r) = go l `mappend` (f k `mappend` (g v `mappend` go r))\n  {-# INLINE bifoldMap #-}\n#endif\n\ninstance (NFData k, NFData a) => NFData (Map k a) where\n    rnf Tip = ()\n    rnf (Bin _ kx x l r) = rnf kx `seq` rnf x `seq` rnf l `seq` rnf r\n\n{--------------------------------------------------------------------\n  Read\n--------------------------------------------------------------------}\ninstance (Ord k, Read k, Read e) => Read (Map k e) where\n#ifdef __GLASGOW_HASKELL__\n  readPrec = parens $ prec 10 $ do\n    Ident "fromList" <- lexP\n    xs <- readPrec\n    return (fromList xs)\n\n  readListPrec = readListPrecDefault\n#else\n  readsPrec p = readParen (p > 10) $ \\ r -> do\n    ("fromList",s) <- lex r\n    (xs,t) <- reads s\n    return (fromList xs,t)\n#endif\n\n{--------------------------------------------------------------------\n  Show\n--------------------------------------------------------------------}\ninstance (Show k, Show a) => Show (Map k a) where\n  showsPrec d m  = showParen (d > 10) $\n    showString "fromList " . shows (toList m)\n\n{--------------------------------------------------------------------\n  Utilities\n--------------------------------------------------------------------}\n\n-- | \\(O(1)\\).  Decompose a map into pieces based on the structure of the underlying\n-- tree.  This function is useful for consuming a map in parallel.\n--\n-- No guarantee is made as to the sizes of the pieces; an internal, but\n-- deterministic process determines this.  However, it is guaranteed that the pieces\n-- returned will be in ascending order (all elements in the first submap less than all\n-- elements in the second, and so on).\n--\n-- Examples:\n--\n-- > splitRoot (fromList (zip [1..6] [\'a\'..])) ==\n-- >   [fromList [(1,\'a\'),(2,\'b\'),(3,\'c\')],fromList [(4,\'d\')],fromList [(5,\'e\'),(6,\'f\')]]\n--\n-- > splitRoot empty == []\n--\n--  Note that the current implementation does not return more than three submaps,\n--  but you should not depend on this behaviour because it can change in the\n--  future without notice.\n--\n-- @since 0.5.4\nsplitRoot :: Map k b -> [Map k b]\nsplitRoot orig =\n  case orig of\n    Tip           -> []\n    Bin _ k v l r -> [l, singleton k v, r]\n{-# INLINE splitRoot #-}\n'