b'{-# LANGUAGE ScopedTypeVariables #-}\n\nimport Data.List\nimport Test.Hspec\nimport Test.Hspec.QuickCheck\n\n----------------------------------------------------------------\n\nmain :: IO ()\nmain = hspec $ do\n    describe "my_from_list" $\n        prop "contains elements in order" $ \\(es :: [Int]) ->\n            prop_ordered (my_from_list es) es\n    describe "my_member" $ do\n        prop "behaves like model" prop_member_model\n        prop "returns True for a memeber" prop_member\n\nprop_ordered :: Tree Int -> [Int] -> Expectation\nprop_ordered t es = inorder t `shouldBe` nub (sort es)\n\ninorder :: Tree a -> [a]\ninorder Leaf         = []\ninorder (Node l x r) = inorder l ++ [x] ++ inorder r\n\nprop_member :: [Int] -> Expectation\nprop_member [] = return ()\nprop_member es = and rs `shouldBe` True\n  where\n    t = from_list es\n    rs = [my_member e t | e <- es]\n\nprop_member_model :: Int -> [Int] -> Expectation\nprop_member_model x [] = my_member x Leaf `shouldBe` False\nprop_member_model x es = my_member x t `shouldBe` elem x es\n  where\n    t = from_list es\n\n-- This code is intentionally duplicated for the test of my_member.\n\nfrom_list :: Ord a => [a] -> Tree a\nfrom_list es = foldl ins Leaf es\n  where\n    ins :: Ord a => Tree a -> a -> Tree a\n    ins Leaf e = Node Leaf e Leaf\n    ins (Node l x r) e = case compare e x of\n        LT -> Node (ins l e) x r\n        EQ -> Node l e r\n        GT -> Node l x (ins r e)\n\n----------------------------------------------------------------\n\ndata Tree a = Leaf | Node (Tree a) a (Tree a) deriving (Eq,Show)\n\n----------------------------------------------------------------\n\nmy_member :: Ord a => a -> Tree a -> Bool\nmy_member _ Leaf = False\nmy_member e (Node l x r) = case compare e x of\n    LT -> my_member e l\n    EQ -> True\n    GT -> my_member e r\n\n----------------------------------------------------------------\n\nmy_insert :: Ord a => a -> Tree a -> Tree a\nmy_insert e Leaf = Node Leaf e Leaf\nmy_insert e (Node l x r) = case compare e x of\n    LT -> Node (my_insert e l) x r\n    EQ -> Node l e r\n    GT -> Node l x (my_insert e r)\n\n----------------------------------------------------------------\n\nmy_from_list :: Ord a => [a] -> Tree a\nmy_from_list es = foldl ins Leaf es\n  where\n    ins t e = my_insert e t\n\n----------------------------------------------------------------\n\nmy_show_tree :: Show a => Tree a -> String\nmy_show_tree t = my_show_tree\' t ""\n\nmy_show_tree\' :: Show a => Tree a -> String -> String\nmy_show_tree\' Leaf _               = ""\nmy_show_tree\' (Node Leaf x Leaf) _ = show x\nmy_show_tree\' (Node l x r) pref    =\n    show x ++ "\\n"\n ++ pref ++ "+" ++ my_show_tree\' l (pref ++ " ") ++ "\\n"\n ++ pref ++ "+" ++ my_show_tree\' r (pref ++ " ")\n'