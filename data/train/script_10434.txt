b'module Main where\n\nimport qualified Data.Map as M\n\n-- guzai\xe3\x81\x8cnabe\xe3\x81\xab\xe5\x85\xa5\xe3\x81\xa3\xe3\x81\xa6\xe3\x81\x84\xe3\x81\x9f\xe3\x82\x89\xe3\x81\x9d\xe3\x81\xae\xe5\x85\xb7\xe6\x9d\x90\xe3\x81\xae\xe5\x80\x8b\xe6\x95\xb0\xe3\x82\x92\xef\xbc\x91\xe6\xb8\x9b\xe3\x82\x89\xe3\x81\x99\xe3\x80\x81\n-- guzai\xe3\x81\xae\xe5\x80\x8b\xe6\x95\xb0\xe3\x81\x8c\xe3\x82\xbc\xe3\x83\xad\xe3\x81\xab\xe3\x81\xaa\xe3\x81\xa3\xe3\x81\x9f\xe3\x82\x89\xe3\x81\x9d\xe3\x81\xae\xe9\xa0\x85\xe7\x9b\xae\xe3\x82\x92Map\xe3\x81\x8b\xe3\x82\x89\xe6\xb6\x88\xe3\x81\x99\xe3\x80\x81\n-- \xe3\x82\x88\xe3\x81\x86\xe3\x81\xab\xe3\x80\x81\xe9\x96\xa2\xe6\x95\xb0eat\xe3\x82\x92\xe8\xbf\xbd\xe8\xa8\x98\xe3\x81\x97\xe3\x81\xa6\xe3\x81\x8f\xe3\x81\xa0\xe3\x81\x95\xe3\x81\x84\xe3\x80\x82\neat :: String ->  M.Map String Int -> M.Map String Int\neat guzai nabe = nabe\n\nparty ::   M.Map String Int -> IO ()\nparty nabe = do\n  putStrLn $ "Nabe: " ++ show nabe\n  order <- getLine\n  let newNabe = eat order nabe\n  if False -- \xe3\x81\x93\xe3\x81\x93\xe3\x81\xa7\xe3\x80\x81\xe9\x8d\x8b\xe3\x81\x8c\xe7\xa9\xba(null)\xe3\x81\x8b\xe3\x81\xa9\xe3\x81\x86\xe3\x81\x8b\xe3\x82\x92\xe5\x88\xa4\xe5\xae\x9a\xe3\x81\x97\xe3\x81\xa6\xe3\x81\x8f\xe3\x81\xa0\xe3\x81\x95\xe3\x81\x84\xe3\x80\x82\n    then putStrLn "The party is over!"\n    else party newNabe\n\nreadRecipe :: IO (M.Map String Int)\nreadRecipe = do\n  content <- readFile "recipe.txt"\n  -- content \xe3\x81\xae\xe5\x86\x85\xe5\xae\xb9\xe3\x82\x92\xe8\xa7\xa3\xe9\x87\x88\xe3\x81\x97\xe3\x81\xa6\xe3\x80\x81\xe3\x81\x8a\xe3\x81\x84\xe3\x81\x97\xe3\x81\x9d\xe3\x81\x86\xe3\x81\xaa\xe9\x8d\x8b\xe3\x81\xae\xe4\xb8\xad\xe8\xba\xab\xe3\x82\x92\xe4\xbd\x9c\xe3\x81\xa3\xe3\x81\xa6\xe3\x81\x8f\xe3\x81\xa0\xe3\x81\x95\xe3\x81\x84\xef\xbc\x81\n  return $ M.fromList [("Kuuki",1)]\n\nmain :: IO ()\nmain = do\n  initialNabe <- readRecipe\n  party initialNabe\n'