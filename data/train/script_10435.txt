b'/*\n * Copyright 2013 - 2016 Mario Arias\n *\n * Licensed under the Apache License, Version 2.0 (the "License");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * \thttp://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an "AS IS" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.funktionale.generators\n\nimport org.funktionale.memoization.memoize\nimport org.funktionale.partials.invoke\n\n\nval paramType: (Int) -> String = { i: Int -> "P$i" }.memoize()\n\nval outParamType: (Int) -> String = { i: Int -> "out P$i" }.memoize()\n\nval param = { i: Int -> "p$i" }.memoize()\n\nval paramWithParenthesis = { i: Int -> "(p$i)" }.memoize()\n\nval paramDeclaration = { i: Int -> "p$i: P$i" }.memoize()\n\nval paramDeclarationWithVal = { i: Int -> "val p$i: P$i" }.memoize()\n\nfun buildCompleteParams(paramType: (Int) -> String): (Int) -> String = { i: Int -> (1..i).mapTo(arrayListOf(), paramType).joinToString() }.memoize()\n\nval completeParams = buildCompleteParams(paramType)\n\nval completeOutParams = buildCompleteParams(outParamType)\n\nval callFunction = { i: Int, paramTemplate: (Int) -> String, separator: String -> (1..i).mapTo(arrayListOf(), paramTemplate).joinToString(separator = separator) }\n\nval callFunctionParams = callFunction(p2 = param)(p2 = ", ")\n\nval callFunctionParamsWithParenthesis = callFunction(p2 = paramWithParenthesis)(p2 = "")\n\nval closed = { i: Int -> (1..i).mapTo(arrayListOf()) { "}" }.joinToString(separator = " ") }\n\nval filteredParams = { i: Int, filtered: Int -> (1..i).filterNotTo(arrayListOf()) { it == filtered }.mapTo(arrayListOf(), paramType).joinToString() }\n\nval filteredDeclaredParams = { i: Int, filtered: Int -> (1..i).filterNotTo(arrayListOf()) { it == filtered }.mapTo(arrayListOf(), paramDeclaration).joinToString() }\n\nfun partially() {\n\n\t(1..22).forEach { i ->\n\n\t\t(1..i).forEach { j ->\n\t\t\tprintln(\n\t\t\t\t\t"""\nfun <${completeParams(i)}, R> ((${completeParams(i)}) -> R).partially$j(${paramDeclaration(j)}): (${filteredParams(i, j)}) -> R {\n    return { ${filteredDeclaredParams(i, j)} -> this(${callFunctionParams(i)}) }\n}""")\n\t\t}\n\n\t}\n}\n\nfun newPartially() {\n\n\tval partials: (Int, Int) -> String = { i: Int, parameter: Int ->\n\t\t(1..i).joinToString { num ->\n\t\t\tif (num == parameter) {\n\t\t\t\tparamDeclaration(num)\n\t\t\t} else {\n\t\t\t\t"partial$num: Partial<P$num> = partial()"\n\t\t\t}\n\t\t}\n\t}\n\n\t(2..22).forEach { i ->\n\t\t(1..i).forEach { j ->\n\t\t\tprintln("""\noperator @Suppress("UNUSED_PARAMETER") fun <${completeParams(i)}, R> ((${completeParams(i)}) -> R).invoke(${partials(i, j)}): (${filteredParams(i, j)}) -> R {\n    return { ${filteredDeclaredParams(i, j)} -> this(${callFunctionParams(i)}) }\n}""")\n\t\t}\n\t}\n}\n\n\nfun currying() {\n\n\tval returnType = { i: Int -> (1..i).mapTo(arrayListOf(), paramType).joinToString(separator = ") -> (", prefix = "(", postfix = ")") }\n\n\tval returned = { i: Int -> (1..i).mapTo(arrayListOf(), paramDeclaration).joinToString(separator = " -> { ") }\n\n\n\t(2..22).forEach { i ->\n\t\tprintln("""\nfun <${completeParams(i)}, R> ((${completeParams(i)}) -> R).curried(): ${returnType(i)} -> R {\n    return { ${returned(i)}  -> this(${callFunctionParams(i)}) ${closed(i)}\n}\n        """)\n\t}\n}\n\nfun uncurrying() {\n\n\tval receiverType = { i: Int -> (1..i).mapTo(arrayListOf(), paramType).joinToString(separator = ") -> (", prefix = "(", postfix = ")") }\n\n\tval returned = { i: Int -> (1..i).mapTo(arrayListOf(), paramDeclaration).joinToString(separator = ", ") }\n\n\n\t(2..22).forEach { i ->\n\t\tprintln("""\nfun<${completeParams(i)}, R> (${receiverType(i)} -> R).uncurried(): (${completeParams(i)}) -> R {\n    return { ${returned(i)}  -> this${callFunction(i, paramWithParenthesis, "")} }\n}\n        """)\n\t}\n}\n\nfun flip() {\n\n\tval returnType = { i: Int -> (i downTo 1).mapTo(arrayListOf(), paramType).joinToString(separator = ") -> (", prefix = "(", postfix = ")") }\n\n\tval returned = { i: Int -> (i downTo 1).mapTo(arrayListOf(), paramDeclaration).joinToString(separator = ") -> {(", prefix = "(", postfix = ")") }\n\n\tfun receptorType(i: Int, finalType: String): String {\n\t\treturn if (i > 0) {\n\t\t\treceptorType((i - 1), "Function1<P$i, $finalType>")\n\t\t} else {\n\t\t\tfinalType\n\t\t}\n\t}\n\n\t(2..22).forEach { i ->\n\t\tprintln("""\npublic fun <${completeParams(i)}, R> ${receptorType(i, "R")}.flip(): ${returnType(i)} -> R {\n    return {${returned(i)}  -> this${callFunctionParamsWithParenthesis(i)} ${closed(i)}\n}\n        """)\n\t}\n}\n\nfun reverse() {\n\n\tval returnType = { i: Int -> (i downTo 1).mapTo(arrayListOf(), paramType).joinToString(separator = ", ", prefix = "(", postfix = ")") }\n\n\tval returned = { i: Int -> (i downTo 1).mapTo(arrayListOf(), paramDeclaration).joinToString(separator = ", ") }\n\n\n\t(2..22).forEach { i ->\n\t\tprintln("""\nfun<${completeParams(i)}, R> ((${completeParams(i)}) -> R).reverse(): ${returnType(i)} -> R {\n\treturn { ${returned(i)}  -> this(${callFunctionParams(i)}) }\n}""")\n\t}\n}\n\nval anies = { i: Int ->\n\t(1..(i + 1)).mapTo(arrayListOf()) {\n\t\t"Any"\n\t}.joinToString(separator = ", ")\n}\n\nprivate fun javaFunClasses(i: Int): String {\n\n\n\treturn (0..i).mapTo(arrayListOf()) { j ->\n\t\t"javaClass<Function$j<${anies(j)}>>()"\n\t}.joinToString(separator = ",\\n")\n}\n\nfun functionClasses() {\n\tprintln("""\n    return array(${javaFunClasses(22)})\n""")\n}\n\nval callParamArray = { i: Int ->\n\t(0..(i - 1)).mapTo(arrayListOf()) {\n\t\t"args[$it]"\n\t}.joinToString(separator = ", ")\n}\n\n\nfun callFunctions() {\n\tprintln((1..22).mapTo(arrayListOf()) { i ->\n\t\t"$i -> (function!! as Function$i<${anies(i)}>)(${callParamArray(i)})"\n\t}.joinToString(separator = "\\n"))\n}\n\nfun String.capitalizeFirstCharacter(): String {\n\tval firstCharacter = this[0].toString().capitalize()\n\treturn firstCharacter + this.substring(1)\n}\n\nfun functionsForResultSet(vararg names: String) {\n\tnames.forEach { name ->\n\t\tprintln(\n\t\t\t\t"""\npublic val $name: GetFieldsToken<${name.capitalizeFirstCharacter()}?>\n        get(){\n            return GetFieldsToken(\n                    { columnName -> get${name.capitalizeFirstCharacter()}(columnName) },\n                    { columnIndex -> get${name.capitalizeFirstCharacter()}(columnIndex) })\n        }\n                """\n\t\t)\n\t}\n}\n\nfun memoizeKeys() {\n\n\tfun params(i: Int) = (1..i).mapTo(arrayListOf(), paramDeclarationWithVal).joinToString(", ")\n\n\tprintln((1..22).mapTo(arrayListOf()) { i ->\n\n\t\t"""\nprivate data class MemoizeKey$i<${completeOutParams(i)}, R>(${params(i)}) : MemoizedCall<(${completeParams(i)}) -> R, R> {\n    override fun invoke(f: (${completeParams(i)}) -> R) = f(${callFunctionParams(i)})\n}\n"""\n\n\t}.joinToString(separator = ""))\n}\n\nfun complement() {\n\tprintln((1..22).mapTo(arrayListOf()) { i ->\n\t\t"""\nfun <${completeParams(i)}> ((${completeParams(i)}) -> Boolean).complement(): (${completeParams(i)}) -> Boolean {\n    return { ${buildCompleteParams(paramDeclaration)(i)} -> !this(${buildCompleteParams(param)(i)}) }\n}\n"""\n\t}.joinToString(""))\n}\n\nfun memoizeFunctions() {\n\n\tfun params(i: Int) = (1..i).mapTo(arrayListOf(), paramDeclaration).joinToString(", ")\n\n\tprintln((1..22).mapTo(arrayListOf()) { i ->\n\t\t"""\nfun <${completeParams(i)}, R> ((${completeParams(i)}) -> R).memoize(): (${completeParams(i)}) -> R {\n    return object : (${completeParams(i)}) -> R {\n        private val m = MemoizedHandler<((${completeParams(i)}) -> R), MemoizeKey$i<${completeParams(i)}, R>, R>(this@memoize)\n        override fun invoke(${params(i)}) = m(MemoizeKey$i(${callFunctionParams(i)}))\n    }\n}\n"""\n\t}.joinToString(""))\n}\n\n//functionsForResultSet("boolean", "byte", "bytes", "characterStream", "clob", "date", "double", "float", "int", "long", "nCharacterStream", "nClob", "nString", "object", "ref", "rowId", "short", "SQLXML", "string", "time", "timestamp", "URL")\n\nfun f(): Array<String> {\n\tval xs = setOf("foo", "bar")\n\treturn xs.toArray()\n}\n\nfun main(args: Array<String>) {\n\t//setOf("foo", "bar").toArray().forEach { it -> println(it as String) }\n\t//partially()\n\t//newPartially()\n\t//    currying()\n\treverse()\n\t//uncurrying()\n\t//memoizeFunctions()\n\t//memoizeKeys()\n\t//complement()\n}\n\n\nfun <T> Set<T>.toArray(): Array<T> {\n\treturn toArray()\n}'