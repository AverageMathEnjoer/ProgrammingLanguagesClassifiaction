b'{-# LANGUAGE\n    CPP\n  , OverloadedStrings\n  , RankNTypes\n  , ScopedTypeVariables\n  #-}\n#if MIN_VERSION_base(4,9,0)\n{-# OPTIONS_GHC -Wno-redundant-constraints #-}\n#endif\nimport Control.Monad\nimport Control.Monad.Except\nimport Control.Monad.Identity\nimport Control.Monad.Reader\nimport Data.Aeson\nimport Data.Monoid\nimport Test.Framework (defaultMain)\nimport Test.Framework.Providers.HUnit (testCase)\nimport Test.HUnit (Assertion, assertEqual, assertFailure)\nimport qualified Data.HashMap.Strict  as H\n\nimport Rest hiding (input)\nimport Rest.Api hiding (route)\nimport Rest.Dictionary (Format (..), Ident (..))\nimport Rest.Driver.Perform (accept)\nimport Rest.Driver.Routing\nimport Rest.Driver.Types\nimport Rest.Resource\nimport qualified Rest.Api          as Rest\nimport qualified Rest.Container    as C\nimport qualified Rest.Driver.RestM as RM\nimport qualified Rest.Resource     as Res\nimport qualified Rest.Run          as Run\n\nmain :: IO ()\nmain =\n  defaultMain [ testCase "Top level listing." testListing\n              , testCase "Top level listing (trailing slash)." testListingTrailingSlash\n              , testCase "Top level singleton." testToplevelSingleton\n              , testCase "Unnamed single." testUnnamedSingle\n              , testCase "Unnamed multi." testUnnamedMulti\n              , testCase "Named singleton." testNamedSingleton\n              , testCase "Named single by." testNamedSingleBy\n              , testCase "Named listing." testNamedListing\n              , testCase "Named listing by." testNamedListingBy\n              , testCase "Create." testCreate\n              , testCase "Create with listing." testCreateWithListing\n              , testCase "Static action." testStaticAction\n              , testCase "Simple subresource." testSubresource\n              , testCase "Root router is skipped." testRootRouter\n              , testCase "Multi-PUT." testMultiPut\n              , testCase "Multi-POST" testMultiPost\n              , testCase "Accept headers." testAcceptHeaders\n              , testCase "Test listing count" testListingCount\n              ]\n\nlistResource :: Resource IO IO Void () Void\nlistResource = mkResourceId { name = "resource", schema = Schema (Just (Many ())) (Named []), list = listHandler }\n  where\n    listHandler () = mkListing id $ \\_ -> return []\n\ntestListing :: Assertion\ntestListing = checkRoute GET "resource" (Rest.root -/ Rest.route listResource)\n\ntestListingTrailingSlash :: Assertion\ntestListingTrailingSlash = checkRoute GET "resource/" (Rest.root -/ Rest.route listResource)\n\ntestToplevelSingleton :: Assertion\ntestToplevelSingleton = checkSingleRoute "resource" resource handler_\n  where\n    resource :: Resource IO IO () Void Void\n    resource = mkResourceId { name = "resource", schema = Schema (Just (Single ())) (Named []) }\n    handler_ = mkConstHandler id $ return ()\n\ntestUnnamedSingle :: Assertion\ntestUnnamedSingle = checkSingleRoute "resource/foo" resource handler_\n  where\n    resource :: Resource IO (ReaderT String IO) String Void Void\n    resource = mkResourceReader { name = "resource", schema = Schema Nothing (Unnamed (Single (Id StringId id))) }\n    handler_ = mkConstHandler stringO ask\n\ntestUnnamedMulti :: Assertion\ntestUnnamedMulti = checkRoute GET "resource/foo" (Rest.root -/ Rest.route resource)\n  where\n    resource :: Resource IO IO Void String Void\n    resource = mkResourceId { name = "resource", schema = Schema Nothing (Unnamed (Many (Id StringId id))), list = listHandler }\n    listHandler (s :: String) = mkListing xmlJsonO $ \\_rng -> return (void s)\n\ntestNamedSingleton :: Assertion\ntestNamedSingleton = checkSingleRoute "resource/foo" resource handler_\n  where\n    resource :: Resource IO IO () Void Void\n    resource = mkResourceId { name = "resource", schema = Schema Nothing (Named [("foo", Right (Single (Singleton ())))]) }\n    handler_ = mkConstHandler id $ return ()\n\ntestNamedSingleBy :: Assertion\ntestNamedSingleBy = checkSingleRoute "resource/foo/bar" resource handler_\n  where\n    resource :: Resource IO (ReaderT String IO) String Void Void\n    resource = mkResourceReader { name = "resource", schema = Schema Nothing (Named [("foo", Right (Single (By (Id StringId id))))]) }\n    handler_ = mkConstHandler stringO ask\n\ntestNamedListing :: Assertion\ntestNamedListing = checkRoute GET "resource/foo" (Rest.root -/ Rest.route resource)\n  where\n    resource :: Resource IO IO Void () Void\n    resource = mkResourceId { name = "resource", schema = Schema Nothing (Named [("foo", Right (Many (Singleton ())))]), list = listHandler }\n    listHandler () = mkListing id $ \\_rng -> return []\n\ntestNamedListingBy :: Assertion\ntestNamedListingBy = checkRoute GET "resource/foo/bar" (Rest.root -/ Rest.route resource)\n  where\n    resource :: Resource IO IO Void String Void\n    resource = mkResourceId { name = "resource", schema = Schema Nothing (Named [("foo", Right (Many (By (Id StringId id))))]), list = listHandler }\n    listHandler (s :: String) = mkListing xmlJsonO $ \\_rng -> return (void s)\n\ntestCreate :: Assertion\ntestCreate = checkRoute POST "resource" (root -/ Rest.route resource)\n  where\n    resource :: Resource IO IO Void Void Void\n    resource = mkResourceId { name = "resource", schema = Schema Nothing (Named []), create = Just createHandler }\n    createHandler = mkConstHandler id $ return ()\n\n-- This one was added because the list handler didn\'t correctly fall\n-- through to create, and testCreate didn\'t catch that because it\n-- contains no list handler.\n\ntestCreateWithListing :: Assertion\ntestCreateWithListing = checkRoutes [(GET, "resource"), (POST, "resource")] (Rest.root -/ Rest.route resource)\n  where\n    resource :: Resource IO IO Void () Void\n    resource = mkResourceId { name = "resource", schema = Schema (Just (Many ())) (Named []), list = listHandler, create = Just createHandler }\n    createHandler = mkConstHandler id $ return ()\n    listHandler () = mkListing id $ \\_rng -> return []\n\ntestStaticAction :: Assertion\ntestStaticAction = checkRoute POST "resource/action" (Rest.root -/ Rest.route resource)\n  where\n    resource :: Resource IO IO () Void ()\n    resource = mkResourceId { name = "resource", schema = Schema Nothing (Named [("action", Left ())]), statics = staticHandler }\n    staticHandler () = mkConstHandler id $ return ()\n\ntestSubresource :: Assertion\ntestSubresource = checkRoute GET "resource/single/subresource" (Rest.root -/ Rest.route resource --/ Rest.route subResource)\n  where\n    resource :: Resource IO IO () Void Void\n    resource = mkResourceId { name = "resource", schema = Schema Nothing (Named [("single", Right (Single (Singleton ())))]), get = Just getHandler }\n    subResource :: Resource IO IO Void () Void\n    subResource = mkResourceId { name = "subresource", schema = Schema (Just (Many ())) (Named []), list = listHandler }\n    getHandler = mkConstHandler id $ return ()\n    listHandler _ = mkListing id $ \\_rng -> return []\n\ntestRootRouter :: Assertion\ntestRootRouter = checkRoute GET "resource/single" (Rest.root -/ Rest.route resource)\n  where\n    resource :: Resource IO IO () Void Void\n    resource = mkResourceId { name = "resource", schema = Schema Nothing (Named [("single", Right (Single (Singleton ())))]), get = Just getHandler }\n    getHandler = mkConstHandler id $ return ()\n\ntestMultiPut :: Assertion\ntestMultiPut = checkRouteSuccess PUT "resource/foo" (Rest.root -/ Rest.route resource)\n  where\n    resource :: Resource IO (ReaderT String IO) String Void Void\n    resource = mkResourceReader\n      { name   = "resource"\n      , schema = Schema Nothing (Named [("foo", Right (Single (By (Id StringId id))))])\n      , update = Just (mkConstHandler xmlJsonO (fmap void ask))\n      }\n\ntestMultiPost :: Assertion\ntestMultiPost = checkRoute POST "" (Rest.root :: Rest.Router IO IO)\n\ntype Uri = String\n\ncheckSingleRoute :: (Applicative m, Monad m, Monad s)\n                 => Uri -> Resource m s sid mid aid -> Handler s -> Assertion\ncheckSingleRoute uri resource handler_ =\n  do checkRoute GET    uri (root -/ Rest.route resource { get = Just handler_ })\n     checkRoute PUT    uri (root -/ Rest.route resource { update = Just handler_ })\n     checkRoute DELETE uri (root -/ Rest.route resource { remove = Just handler_ })\n     checkRoute GET    (uri <> "/select") (root -/ Rest.route resource { selects = [("select", handler_)] })\n     checkRoute POST   (uri <> "/action") (root -/ Rest.route resource { actions = [("action", handler_)] })\n\ncheckRoute :: (Applicative m, Monad m) => Method -> Uri -> Rest.Router m s -> Assertion\ncheckRoute method uri router = checkRouteWithIgnoredMethods [method] router method uri\n\ncheckRoutes :: (Applicative m, Monad m) => [(Method, Uri)] -> Rest.Router m s -> Assertion\ncheckRoutes reqs router =\n  forM_ reqs $ uncurry $ checkRouteWithIgnoredMethods (map fst reqs) router\n\ncheckRouteWithIgnoredMethods :: (Applicative m, Monad m) => [Method] -> Rest.Router m s -> Method -> Uri -> Assertion\ncheckRouteWithIgnoredMethods ignoredMethods router method uri =\n  do checkRouteSuccess method uri router\n     forM_ (filter (not . (`elem` ignoredMethods)) allMethods) $ \\badMethod -> checkRouteFailure badMethod uri router\n     checkRouteFailure method (uri <> "/trailing") router\n\ncheckRouteFailure :: (Applicative m, Monad m) => Method -> Uri -> Rest.Router m s -> Assertion\ncheckRouteFailure method uri router =\n  case route (Just method) (splitUriString $ "v1.0/" <> uri) (Versioned [(Version 1 0 Nothing, Some1 router)]) of\n    Left _  -> return ()\n    Right _ -> assertFailure ("Should be no route to " ++ show method ++ " " ++ uri ++ ".")\n\ncheckRouteSuccess :: (Applicative m, Monad m) => Method -> Uri -> Rest.Router m s -> Assertion\ncheckRouteSuccess method uri router =\n  case route (Just method) (splitUriString $ "v1.0/" <> uri) (Versioned [(Version 1 0 Nothing, Some1 router)]) of\n    Left e  -> assertFailure ("No route to " ++ show method ++ " " ++ uri ++ ": " ++ show e)\n    Right _ -> return ()\n\nallMethods :: [Method]\nallMethods = [GET, PUT, POST, DELETE]\n\ntestAcceptHeaders :: Assertion\ntestAcceptHeaders =\n  do let fmt = accept (Just "text/json") Nothing Nothing\n     assertEqual "Accept json format." [JsonFormat] fmt\n\ntestListingCount :: Assertion\ntestListingCount = assertEqual "listing count" (Right $ C.List 0 5 [1..5::Int]) (eitherDecode bs)\n  where\n    (bs, _meta) = runIdentity . RM.runRestM input $ Run.apiToHandler api\n    input :: RM.RestInput\n    input = RM.emptyInput\n      { RM.parameters = H.fromList [("count", "5")]\n      , RM.paths      = splitUriString "resource"\n      , RM.headers    = H.fromList\n          [ ("Accept"      , "application/json")\n          , ("Content-Type", "application/json")\n          ]\n      }\n    api :: Api (RM.RestM Identity)\n    api = Unversioned (Some1 $ Rest.root -/ Rest.route resource)\n    resource :: Resource (RM.RestM Identity) (RM.RestM Identity) String () Void\n    resource = mkResourceId\n      { Res.name   = "resource"\n      , Res.schema = withListing () $ named []\n      , Res.list   = const listHandler\n      }\n      where\n      listHandler :: ListHandler (RM.RestM Identity)\n      listHandler = mkListing jsonO h\n        where\n          h :: Range -> ExceptT Reason_ (RM.RestM Identity) [Int]\n          h _rng = return [1..10]\n'