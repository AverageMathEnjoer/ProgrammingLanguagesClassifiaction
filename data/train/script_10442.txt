b'#include<iostream>\n#include<vector>\n#include<map>\n#include<assert.h>\n#include<algorithm>\nusing namespace std;\n\nclass Trie {\n  map<char, Trie*> m_keys = {}; // what are the next avail chars in trie node\n  int m_traversed = 0; // how many words in trie are proper prefix\n  bool m_isLeaf = 0; // is this trie node a leaf node i.e a word ends here\n  int m_depth = 0; // depth of trie node\n\npublic:\n  Trie() = default;\n  Trie(int depth): m_depth(depth) {}\n  int getDepth() { return m_depth; }\n  bool isKeyPresent(const char &c) { return m_keys.find(c) != m_keys.end(); }\n  bool isLeaf() { return m_isLeaf; }\n  void setLeaf() { m_isLeaf = 1; }\n  void add(const string &word);\n  int matchLength(const string &prefix); // returns the length of max prefix that exists in trie\n  vector<string> getAllWords();\n  vector<string> autoComplete(const string &prefix);\n  bool isPresent(const string &word);\n  void addKey(const char &c);\n  Trie *to(const char &c);\n};\n\ntemplate <typename T>\nvoid assertVectors(const vector<T>& lhs, const vector<T>& rhs) {\n  // for(auto e: lhs)\n  //   cout << e << " ";\n  // cout << endl;\n  // for(auto e: rhs)\n  //   cout << e << " ";\n  // cout << endl;\n  assert(lhs.size() == rhs.size());\n  for (int i = 0; i < lhs.size(); i++)\n  {\n    assert(lhs[i] == rhs[i]);\n  }\n}\n\nint main() {\n\n  Trie t;\n\n  vector<string> words = {"Rachit", "Ramesh", "Ankit", "Ankita", "Rachit1"};\n  sort(words.begin(), words.end());\n  for (auto w : words)\n  {\n    t.add(w);\n  }\n\n  assertVectors(t.autoComplete(""), words);\n  assertVectors(t.autoComplete("Ra"), {"Rachit", "Rachit1", "Ramesh"});\n  assertVectors(t.autoComplete("Rachit"), {"Rachit", "Rachit1"});\n  assertVectors(t.autoComplete("Rachit1"), {"Rachit1"});\n  assertVectors(t.autoComplete("Rachit12"), {});\n  \n  assert(t.isPresent(""));\n  assert(!t.isPresent("Racht"));\n  assert(t.isPresent("Rachit"));\n  assert(t.isPresent("Rachit1"));\n  assert(!t.isPresent("Rachit12"));\n\n  assert(t.matchLength("Ract") == 3);\n  assert(t.matchLength("") == 0);\n\n  return 0;\n}\n\n// add the given char to current Trie node\nvoid Trie::addKey(const char& c) {\n  if(!isKeyPresent(c)) {\n    m_keys[c] = new Trie(m_depth + 1);\n  }\n  m_traversed++;\n}\n\nTrie* Trie::to(const char& c) {\n  if(!isKeyPresent(c)) {\n    return NULL;\n  }\n  return m_keys[c];\n}\n\n// add the word to trie, duplicates are ignored\nvoid Trie::add(const string &word) {\n  Trie *cur = this;\n  for (char c: word)\n  {\n    cur->addKey(c);\n    cur = cur->to(c);\n  }\n  cur->setLeaf();\n}\n\n// returns the length of max prefix that exists in trie\nint Trie::matchLength(const string &prefix) {\n  Trie *cur = this;\n  int match = 0;\n  for (char c: prefix) {\n    if (cur->isKeyPresent(c)) {\n      match++;\n      cur = cur->to(c);\n    }\n    else {\n      return match;\n    }\n  }\n  return match;\n}\n\nvector<string> Trie::getAllWords() {\n  vector<string> ans = {};\n  for (auto it: m_keys) {\n    char c = it.first;\n    Trie *t = it.second;\n    if (t->isLeaf()) {\n      ans.push_back(string("") + c);\n    }\n    for (auto word: t->getAllWords()) {\n      ans.push_back(c + word);\n    }\n  }\n\n  return ans;\n}\n\nvector<string> Trie::autoComplete(const string &prefix) {\n  if (!isPresent(prefix)) {\n    return {};\n  }\n  vector<string> ans = {};\n\n  Trie *cur = this;\n  for (char c: prefix) {\n    if (cur->isKeyPresent(c)) {\n      cur = cur->to(c);\n    }\n    else {\n      break;\n    }\n  }\n\n  if (cur->isLeaf()) {\n    ans.push_back(prefix);\n  }\n\n  for (auto restWord: cur->getAllWords()) {\n    ans.push_back(prefix + restWord);\n  }\n  return ans;\n}\n\nbool Trie::isPresent(const string &word) {\n  return matchLength(word) == word.size();\n}\n'