b'\xef\xbb\xbfusing UnityEngine;\nusing System.Collections;\n\npublic partial class LightShafts : MonoBehaviour\n{\n\tpublic LightShaftsShadowmapMode m_ShadowmapMode = LightShaftsShadowmapMode.Dynamic;\n\tLightShaftsShadowmapMode m_ShadowmapModeOld = LightShaftsShadowmapMode.Dynamic;\n\tpublic Camera[] m_Cameras;\n\tpublic Camera m_CurrentCamera;\n\tbool m_ShadowmapDirty = true;\n\tpublic Vector3 m_Size = new Vector3(10, 10, 20);\n\tpublic float m_SpotNear = 0.1f;\n\tpublic float m_SpotFar = 1.0f;\n\tpublic LayerMask m_CullingMask = ~0;\n\tpublic LayerMask m_ColorFilterMask = 0;\n\tpublic float m_Brightness = 5;\n\tpublic float m_BrightnessColored = 5;\n\tpublic float m_Extinction = 0.5f;\n\tpublic float m_MinDistFromCamera = 0.0f;\n\t\n\tpublic int m_ShadowmapRes = 1024;\n\tCamera m_ShadowmapCamera;\n\tRenderTexture m_Shadowmap;\n\tpublic Shader m_DepthShader;\n\tRenderTexture m_ColorFilter;\n\tpublic Shader m_ColorFilterShader;\n\tpublic bool m_Colored = false;\n\tpublic float m_ColorBalance = 1.0f;\n\t\n\tpublic int m_EpipolarLines = 256;\n\tpublic int m_EpipolarSamples = 512;\n\tRenderTexture m_CoordEpi;\n\tRenderTexture m_DepthEpi;\n\tpublic Shader m_CoordShader;\n\tMaterial m_CoordMaterial;\n\tCamera m_CoordsCamera;\n\n\tRenderTexture m_InterpolationEpi;\n\tpublic Shader m_DepthBreaksShader;\n\tMaterial m_DepthBreaksMaterial;\n\n\tRenderTexture m_RaymarchedLightEpi;\n\tMaterial m_RaymarchMaterial;\n\tpublic Shader m_RaymarchShader;\n\n\tRenderTexture m_InterpolateAlongRaysEpi;\n\tpublic Shader m_InterpolateAlongRaysShader;\n\tMaterial m_InterpolateAlongRaysMaterial;\n\t\n\tRenderTexture m_SamplePositions;\n\tpublic Shader m_SamplePositionsShader;\n\tMaterial m_SamplePositionsMaterial;\n\tbool m_SamplePositionsShaderCompiles = false;\n\t\n\tpublic Shader m_FinalInterpolationShader;\n\tMaterial m_FinalInterpolationMaterial;\n\n\tpublic float m_DepthThreshold = 0.5f;\n\tpublic int m_InterpolationStep = 32;\n\n\tpublic bool m_ShowSamples = false;\n\tpublic bool m_ShowInterpolatedSamples = false;\n\tpublic float m_ShowSamplesBackgroundFade = 0.8f;\n\n\tpublic bool m_AttenuationCurveOn = false;\n\tpublic AnimationCurve m_AttenuationCurve;\n\tTexture2D m_AttenuationCurveTex;\n\n\tLight m_Light;\n\tLightType m_LightType = LightType.Directional;\n\tbool m_DX11Support = false;\n\tbool m_MinRequirements = false;\n\n\tvoid InitLUTs ()\n\t{\n\t\tif (m_AttenuationCurveTex)\n\t\t\treturn;\n\n\t\tm_AttenuationCurveTex = new Texture2D (256, 1, TextureFormat.ARGB32, false, true);\n\t\tm_AttenuationCurveTex.wrapMode = TextureWrapMode.Clamp;\n\t\tm_AttenuationCurveTex.hideFlags = HideFlags.HideAndDontSave;\n\n\t\tif (m_AttenuationCurve == null || m_AttenuationCurve.length == 0)\n\t\t\tm_AttenuationCurve = new AnimationCurve(new Keyframe(0, 1), new Keyframe(1, 1));\n\n\t\tif (m_AttenuationCurveTex)\n\t\t\tUpdateLUTs ();\n\t}\n\t\n\tpublic void UpdateLUTs ()\n\t{\n\t\tInitLUTs ();\n\n\t\tif (m_AttenuationCurve == null)\n\t\t\treturn;\n\n\t\tfor (int i = 0; i < 256; ++i)\n\t\t{\n\t\t\tfloat v = Mathf.Clamp (m_AttenuationCurve.Evaluate(i/255.0f), 0.0f, 1.0f);\n\t\t\tm_AttenuationCurveTex.SetPixel (i, 0, new Color(v,v,v,v));\n\t\t}\n\t\tm_AttenuationCurveTex.Apply ();\n\t}\n\t\n\tvoid InitRenderTexture(ref RenderTexture rt, int width, int height, int depth, RenderTextureFormat format, bool temp = true)\n\t{\n\t\tif (temp)\n\t\t{\n\t\t\trt = RenderTexture.GetTemporary(width, height, depth, format);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (rt != null)\n\t\t\t{\n\t\t\t\tif (rt.width == width && rt.height == height && rt.depth == depth && rt.format == format)\n\t\t\t\t\treturn;\n\n\t\t\t\trt.Release();\n\t\t\t\tDestroyImmediate(rt);\n\t\t\t}\n\n\t\t\trt = new RenderTexture(width, height, depth, format);\n\t\t\trt.hideFlags = HideFlags.HideAndDontSave;\n\t\t}\n\t}\n\n\tvoid InitShadowmap()\n\t{\n\t\tbool dynamic = (m_ShadowmapMode == LightShaftsShadowmapMode.Dynamic);\n\t\tif (dynamic && m_ShadowmapMode != m_ShadowmapModeOld)\n\t\t{\n\t\t\t// Destroy static render textures, we only need temp now\n\t\t\tif (m_Shadowmap)\n\t\t\t\tm_Shadowmap.Release();\n\t\t\tif (m_ColorFilter)\n\t\t\t\tm_ColorFilter.Release();\n\t\t}\n\t\tInitRenderTexture(ref m_Shadowmap, m_ShadowmapRes, m_ShadowmapRes, 24, RenderTextureFormat.RFloat, dynamic);\n\t\tm_Shadowmap.filterMode = FilterMode.Point;\n\t\tm_Shadowmap.wrapMode = TextureWrapMode.Clamp;\n\n\t\tif (m_Colored)\n\t\t\tInitRenderTexture(ref m_ColorFilter, m_ShadowmapRes, m_ShadowmapRes, 0, RenderTextureFormat.ARGB32, dynamic);\n\n\t\tm_ShadowmapModeOld = m_ShadowmapMode;\n\t}\n\n\tvoid ReleaseShadowmap()\n\t{\n\t\tif (m_ShadowmapMode == LightShaftsShadowmapMode.Static)\n\t\t\treturn;\n\n\t\tRenderTexture.ReleaseTemporary(m_Shadowmap);\n\t\tRenderTexture.ReleaseTemporary(m_ColorFilter);\n\t}\n\t\n\tvoid InitEpipolarTextures()\n\t{\n\t\tm_EpipolarLines = m_EpipolarLines < 8 ? 8 : m_EpipolarLines;\n\t\tm_EpipolarSamples = m_EpipolarSamples < 4 ? 4 : m_EpipolarSamples;\n\t\t\n\t\tInitRenderTexture(ref m_CoordEpi, m_EpipolarSamples, m_EpipolarLines, 0, RenderTextureFormat.RGFloat);\n\t\tm_CoordEpi.filterMode = FilterMode.Point;\n\t\tInitRenderTexture(ref m_DepthEpi, m_EpipolarSamples, m_EpipolarLines, 0, RenderTextureFormat.RFloat);\n\t\tm_DepthEpi.filterMode = FilterMode.Point;\n\t\tInitRenderTexture(ref m_InterpolationEpi, m_EpipolarSamples, m_EpipolarLines, 0, m_DX11Support ? RenderTextureFormat.RGInt : RenderTextureFormat.RGFloat);\n\t\tm_InterpolationEpi.filterMode = FilterMode.Point;\n\t\t\n\t\tInitRenderTexture(ref m_RaymarchedLightEpi, m_EpipolarSamples, m_EpipolarLines, 24, RenderTextureFormat.ARGBFloat);\n\t\tm_RaymarchedLightEpi.filterMode = FilterMode.Point;\n\t\tInitRenderTexture(ref m_InterpolateAlongRaysEpi, m_EpipolarSamples, m_EpipolarLines, 0, RenderTextureFormat.ARGBFloat);\n\t\tm_InterpolateAlongRaysEpi.filterMode = FilterMode.Point;\n\t}\n\t\n\tvoid InitMaterial(ref Material material, Shader shader)\n\t{\n\t\tif (material || !shader)\n\t\t\treturn;\n\t\tmaterial = new Material(shader);\n\t\tmaterial.hideFlags = HideFlags.HideAndDontSave;\n\t}\n\n\tvoid InitMaterials()\n\t{\n\t\tInitMaterial(ref m_FinalInterpolationMaterial, m_FinalInterpolationShader);\n\t\tInitMaterial(ref m_CoordMaterial, m_CoordShader);\n\t\tInitMaterial(ref m_SamplePositionsMaterial, m_SamplePositionsShader);\n\t\tInitMaterial(ref m_RaymarchMaterial, m_RaymarchShader);\n\t\tInitMaterial(ref m_DepthBreaksMaterial, m_DepthBreaksShader);\n\t\tInitMaterial(ref m_InterpolateAlongRaysMaterial, m_InterpolateAlongRaysShader);\n\t}\n\n\tMesh m_SpotMesh;\n\tfloat m_SpotMeshNear = -1;\n\tfloat m_SpotMeshFar = -1;\n\tfloat m_SpotMeshAngle = -1;\n\tfloat m_SpotMeshRange = -1;\n\n\tvoid InitSpotFrustumMesh()\n\t{\n\t\tif (!m_SpotMesh)\n\t\t{\n\t\t\tm_SpotMesh = new Mesh();\n\t\t\tm_SpotMesh.hideFlags = HideFlags.HideAndDontSave;\n\t\t}\n\n\t\tLight l = m_Light;\n\t\tif (m_SpotMeshNear != m_SpotNear || m_SpotMeshFar != m_SpotFar || m_SpotMeshAngle != l.spotAngle || m_SpotMeshRange != l.range)\n\t\t{\n\t\t\tfloat far = l.range * m_SpotFar;\n\t\t\tfloat near = l.range * m_SpotNear;\n\t\t\tfloat tan = Mathf.Tan(l.spotAngle * Mathf.Deg2Rad * 0.5f);\n\t\t\tfloat halfwidthfar = far * tan;\n\t\t\tfloat halfwidthnear = near * tan;\n\n\t\t\tVector3[] vertices = (m_SpotMesh.vertices != null && m_SpotMesh.vertices.Length == 8) ? m_SpotMesh.vertices : new Vector3[8];\n\t\t\tvertices[0] = new Vector3(-halfwidthfar,  -halfwidthfar,  far);\n\t\t\tvertices[1] = new Vector3( halfwidthfar,  -halfwidthfar,  far);\n\t\t\tvertices[2] = new Vector3( halfwidthfar,   halfwidthfar,  far);\n\t\t\tvertices[3] = new Vector3(-halfwidthfar,   halfwidthfar,  far);\n\t\t\tvertices[4] = new Vector3(-halfwidthnear, -halfwidthnear, near);\n\t\t\tvertices[5] = new Vector3( halfwidthnear, -halfwidthnear, near);\n\t\t\tvertices[6] = new Vector3( halfwidthnear,  halfwidthnear, near);\n\t\t\tvertices[7] = new Vector3(-halfwidthnear,  halfwidthnear, near);\n\t\t\tm_SpotMesh.vertices = vertices;\n\n\t\t\tif (m_SpotMesh.GetTopology( 0 ) != MeshTopology.Triangles || m_SpotMesh.triangles == null || m_SpotMesh.triangles.Length != 36)\n\t\t\t{\n\t\t\t\t//                          far           near          top           right         left          bottom\n\t\t\t\tint[] triangles = new int[]{0,1,2, 0,2,3, 6,5,4, 7,6,4, 3,2,6, 3,6,7, 2,1,5, 2,5,6, 0,3,7, 0,7,4, 5,1,0, 5,0,4};\n\t\t\t\tm_SpotMesh.triangles = triangles;\n\t\t\t}\n\n\t\t\tm_SpotMeshNear = m_SpotNear;\n\t\t\tm_SpotMeshFar = m_SpotFar;\n\t\t\tm_SpotMeshAngle = l.spotAngle;\n\t\t\tm_SpotMeshRange = l.range;\n\t\t}\n\t}\n\n\tpublic void UpdateLightType()\n\t{\n\t\tif (m_Light == null)\n\t\t\tm_Light = GetComponent<Light>();\n\t\t\n\t\tm_LightType = m_Light.type;\n\t}\n\n\tbool ShaderCompiles(Shader shader)\n\t{\n\t\tif (!shader.isSupported)\n\t\t{\n\t\t\tDebug.LogError("LightShafts\' " + shader.name + " didn\'t compile on this platform.");\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tpublic bool CheckMinRequirements()\n\t{\n\t\tm_DX11Support = SystemInfo.graphicsShaderLevel >= 50;\n\n\t\tm_MinRequirements = SystemInfo.graphicsShaderLevel >= 30;\n\t\tm_MinRequirements &= SystemInfo.supportsRenderTextures;\n\t\tm_MinRequirements &= SystemInfo.SupportsRenderTextureFormat(RenderTextureFormat.RGFloat);\n\t\tm_MinRequirements &= SystemInfo.SupportsRenderTextureFormat(RenderTextureFormat.RFloat);\n\n\t\tif (!m_MinRequirements)\n\t\t\tDebug.LogError("LightShafts require Shader Model 3.0 and render textures (including the RGFloat and RFloat) formats. Disabling.");\n\n\t\tbool shadersCompile = \tShaderCompiles(m_DepthShader) &&\n\t\t\t\t\t\t\t\tShaderCompiles(m_ColorFilterShader) &&\n\t\t\t\t\t\t\t\tShaderCompiles(m_CoordShader) &&\n\t\t\t\t\t\t\t\tShaderCompiles(m_DepthBreaksShader) &&\n\t\t\t\t\t\t\t\tShaderCompiles(m_RaymarchShader) &&\n\t\t\t\t\t\t\t\tShaderCompiles(m_InterpolateAlongRaysShader) &&\n\t\t\t\t\t\t\t\tShaderCompiles(m_FinalInterpolationShader);\n\n\t\tif (!shadersCompile)\n\t\t\tDebug.LogError("LightShafts require above shaders. Disabling.");\n\n\t\tm_MinRequirements &= shadersCompile;\n\n\t\tm_SamplePositionsShaderCompiles = m_SamplePositionsShader.isSupported;\n\n\t\treturn m_MinRequirements;\n\t}\n\n\tvoid InitResources()\n\t{\n\t\tUpdateLightType();\n\t\t\n\t\tInitMaterials();\n\t\tInitEpipolarTextures();\n\t\tInitLUTs();\n\t\tInitSpotFrustumMesh();\n\t}\n\n\tvoid ReleaseResources()\n\t{\n\t\tReleaseShadowmap();\n\t\tRenderTexture.ReleaseTemporary(m_CoordEpi);\n\t\tRenderTexture.ReleaseTemporary(m_DepthEpi);\n\t\tRenderTexture.ReleaseTemporary(m_InterpolationEpi);\n\t\tRenderTexture.ReleaseTemporary(m_RaymarchedLightEpi);\n\t\tRenderTexture.ReleaseTemporary(m_InterpolateAlongRaysEpi);\n\t}\n}\n'