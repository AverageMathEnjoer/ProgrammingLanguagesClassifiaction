b'module Network.Server.TicTacToe.Game where\n\nimport Data.TicTacToe\nimport Network.Server.Common.Env\nimport Network.Server.Common.HandleLens\nimport Network.Server.Common.Lens\nimport Network.Server.Common.Line\nimport Network.Server.Common.Ref\nimport Network.Server.TicTacToe.Loop\nimport Data.Char(isSpace, toLower, toUpper)\nimport Data.Function(on)\nimport Data.IORef(readIORef, atomicModifyIORef)\nimport Data.Maybe(fromMaybe)\nimport Data.Foldable(msum, find)\nimport Data.Set(Set)\nimport Control.Applicative((<$), (<$>))\nimport System.IO(hGetLine, hPutStrLn)\n\ntype FinishedGames =\n  [FinishedBoard]\n\ntype Game a =\n  IORefLoop Board (Board, FinishedGames) a\n\ndata Command =\n  Move Position\n  | Current\n  | Finished\n  | Chat String\n  | Turn\n  | At Position\n  | Unknown String\n  deriving (Eq, Show)\n\n-- |\n--\n-- >>> command "MOVE ne"\n-- Move NE\n--\n-- >>> command "MOVE 2"\n-- Move N\n--\n-- >>> command "GAME"\n-- Current\n--\n-- >>> command "FiniSHED"\n-- Finished\n--\n-- >>> command "CHAT hi"\n-- Chat "hi"\n--\n-- >>> command "Turn"\n-- Turn\n--\n-- >>> command "At 4"\n-- At W\n--\n-- >>> command "At C"\n-- At C\n--\n-- >>> command "At X"\n-- Unknown "At X"\n--\n-- >>> command "Move i"\n-- Unknown "Move i"\ncommand ::\n  String\n  -> Command\ncommand z =\n  let p l = reverse . dropWhile isSpace . reverse . dropWhile isSpace <$> prefixThen ((==) `on` toLower) l z\n  in Unknown z `fromMaybe` msum [\n                                  do m <- p "MOVE "\n                                     q <- sPosition m\n                                     return (Move q)\n                                , Current <$ p "GAME"\n                                , Finished <$ p "FINISHED"\n                                , Chat <$> p "CHAT"\n                                , Turn <$ p "TURN"\n                                , do a <- p "AT"\n                                     q <- sPosition a\n                                     return (At q)\n                                ]\n\n-- |\n--\n-- >>> sPosition "1"\n-- Just NW\n--\n-- > sPosition "E"\n-- Just E\n--\n-- > sPosition "sw"\n-- Just SW\n--\n-- > sPosition "x"\n-- Nothing\nsPosition ::\n  String\n  -> Maybe Position\nsPosition s =\n  let table = [\n                (\n                  ["1", "NW"]\n                , NW\n                )\n              , (\n                  ["2", "N"]\n                , N\n                )\n              , (\n                  ["3", "NE"]\n                , NE\n                )\n              , (\n                  ["4", "W"]\n                , W\n                )\n              , (\n                  ["5", "C"]\n                , C\n                )\n              , (\n                  ["6", "E"]\n                , E\n                )\n              , (\n                  ["7", "SW"]\n                , SW\n                )\n              , (\n                  ["8", "S"]\n                , S\n                )\n              , (\n                  ["9", "SE"]\n                , SE\n                )\n              ]\n      toUppers = map toUpper\n  in fmap snd . find (\\(t, _) -> elem (toUppers s) (toUppers <$> t)) $ table\n\ncurrentBoard ::\n  Game Board\ncurrentBoard =\n  initLoop $ \\env ->\n    readIORef (envvalL `getL` env)\n\nwithCurrentBoard ::\n  (Board -> (Board, a))\n  -> Game a\nwithCurrentBoard f =\n  initLoop $ \\env ->\n    atomicModifyIORef (envvalL `getL` env) f\n\nlastBoard ::\n  Game Board\nlastBoard =\n  Loop $ \\_ (s, t) ->\n    return (s, (s, t))\n\nputBoard ::\n  Board\n  -> Game ()\nputBoard s =\n  Loop $ \\_ (_, t) ->\n      return ((), (s, t))\n\nmodifyFinishedGames ::\n  (FinishedGames -> FinishedGames)\n  -> Game ()\nmodifyFinishedGames f =\n  Loop $ \\_ (s, t) -> return ((), (s, f t))\n\nfinishedGames ::\n  Game FinishedGames\nfinishedGames =\n  Loop $ \\_ (s, t) -> return (t, (s, t))\n\neGetLine ::\n  Game String\neGetLine =\n  initLoop (hGetLine . getL handleL)\n\nePutStrLn ::\n  String\n  -> Game ()\nePutStrLn s =\n  initLoop (\\env -> (hPutStrLn (handleL `getL` env) s))\n\nallClients ::\n  Game (Set Ref)\nallClients =\n  initLoop $ \\env -> (readIORef (clientsL `getL` env))\n\nprocess ::\n  Command\n  -> Game ()\nprocess =\n  error "todo"\n\ngame ::\n  Game x -- client accepted (post)\n  -> (String -> Game w) -- read line from client\n  -> IO a\ngame =\n  error "todo"\n\nplay ::\n  IO a\nplay =\n  game (currentBoard >>= pPutStrLn . show) (process . command)\n'