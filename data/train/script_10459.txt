b'#include "stdafx.h"\n#include "../AssetsTools/AssetTypeClass.h"\n#include <typeinfo>\n#include <assert.h>\n\nASSETSTOOLS_API AssetTypeValue::AssetTypeValue(EnumValueTypes type, void *valueContainer)\n{\n\t//freeValue = false;\n\tthis->type = type;\n\tSet(valueContainer);\n}\nASSETSTOOLS_API AssetTypeValue::AssetTypeValue(const AssetTypeValue &other)\n{\n\t//freeValue = false;\n\tthis->type = other.type;\n\tthis->value = other.value;\n}\nASSETSTOOLS_API void AssetTypeValue::Set(void *valueContainer, EnumValueTypes contType)\n{\n\tbool mismatch = false;\n\tmemset(&value, 0, sizeof(ValueTypes));\n\tswitch (this->type)\n\t{\n\t\tcase ValueType_None:\n\t\t\tbreak;\n\t\tcase ValueType_Bool:\n\t\t\tif (contType >= ValueType_None && contType <= ValueType_UInt64)\n\t\t\t\tvalue.asBool = *(bool*)valueContainer;\n\t\t\telse mismatch = true;\n\t\t\tbreak;\n\t\tcase ValueType_Int8:\n\t\tcase ValueType_UInt8:\n\t\t\tif (contType >= ValueType_None && contType <= ValueType_UInt64)\n\t\t\t\tvalue.asInt8 = *(char*)valueContainer;\n\t\t\telse mismatch = true;\n\t\t\tbreak;\n\t\tcase ValueType_Int16:\n\t\tcase ValueType_UInt16:\n\t\t\tif (contType == ValueType_None || (contType >= ValueType_Int16 && contType <= ValueType_UInt64))\n\t\t\t\tvalue.asInt16 = *(short*)valueContainer;\n\t\t\telse mismatch = true;\n\t\t\tbreak;\n\t\tcase ValueType_Int32:\n\t\tcase ValueType_UInt32:\n\t\t\tif (contType == ValueType_None || (contType >= ValueType_Int32 && contType <= ValueType_UInt64))\n\t\t\t\tvalue.asInt32 = *(int*)valueContainer;\n\t\t\telse mismatch = true;\n\t\t\tbreak;\n\t\tcase ValueType_Int64:\n\t\tcase ValueType_UInt64:\n\t\t\tif (contType == ValueType_None || (contType >= ValueType_Int64 && contType <= ValueType_UInt64))\n\t\t\t\tvalue.asInt64 = *(long long int*)valueContainer;\n\t\t\telse mismatch = true;\n\t\t\tbreak;\n\t\tcase ValueType_Float:\n\t\t\tif (contType == ValueType_None || contType == ValueType_Float)\n\t\t\t\tvalue.asFloat = *(float*)valueContainer;\n\t\t\telse mismatch = true;\n\t\t\tbreak;\n\t\tcase ValueType_Double:\n\t\t\tif (contType == ValueType_None || contType == ValueType_Double)\n\t\t\t\tvalue.asDouble = *(double*)valueContainer;\n\t\t\telse mismatch = true;\n\t\t\tbreak;\n\t\tcase ValueType_String:\n\t\t\tif (contType == ValueType_None || contType == ValueType_String)\n\t\t\t\tvalue.asString = (char*)valueContainer;\n\t\t\telse mismatch = true;\n\t\t\t//freeValue = freeIfPointer;\n\t\t\tbreak;\n\t\tcase ValueType_Array:\n\t\t\tif (contType == ValueType_None || contType == ValueType_Array)\n\t\t\t\tmemcpy(&this->value.asArray, valueContainer, sizeof(AssetTypeArray));\n\t\t\telse mismatch = true;\n\t\t\t//if (freeIfPointer)\n\t\t\t//\tfree(valueContainer);\n\t\t\tbreak;\n\t\tcase ValueType_ByteArray:\n\t\t\tif (contType == ValueType_None || contType == ValueType_ByteArray)\n\t\t\t\tmemcpy(&this->value.asByteArray, valueContainer, sizeof(AssetTypeByteArray));\n\t\t\telse mismatch = true;\n\t\t\tbreak;\n\t}\n\tif (mismatch)\n\t\tthrow AssetTypeValue_ConfusionError("AssetTypeValue::Set: Mismatching value type supplied.");\n}\nASSETSTOOLS_API AssetTypeValue::~AssetTypeValue()\n{\n\t/*if (freeValue && ((type == ValueType_String) || (type == ValueType_Array)))\n\t{\n\t\tfree(value.asString);\n\t\tvalue.asString = NULL;\n\t}*/\n}\n\nASSETSTOOLS_API AssetTypeValueField* AssetTypeValueField::operator[](const char* name) const\n{\n\tif (childrenCount == -1)\n\t\treturn GetDummyAssetTypeField();\n\tfor (uint32_t i = 0; i < childrenCount; i++)\n\t{\n\t\tif (pChildren[i]->templateField != NULL)\n\t\t{\n\t\t\tif (pChildren[i]->templateField->name == name)\n\t\t\t\treturn pChildren[i];\n\t\t}\n\t}\n\treturn GetDummyAssetTypeField();\n}\n\nASSETSTOOLS_API AssetTypeValueField* AssetTypeValueField::operator[](uint32_t index) const\n{\n\tif (childrenCount == -1)\n\t\treturn GetDummyAssetTypeField();\n\tif (index >= childrenCount)\n\t\treturn GetDummyAssetTypeField();\n\treturn pChildren[index];\n}\nASSETSTOOLS_API void AssetTypeValueField::Read(AssetTypeValue *pValue, AssetTypeTemplateField *pTemplate, uint32_t childrenCount, AssetTypeValueField **pChildren)\n{\n\tthis->value = pValue;\n\tthis->templateField = pTemplate;\n\tthis->childrenCount = childrenCount;\n\tthis->pChildren = pChildren;\n\t//char valueContainer[16];\n\t//value = new AssetTypeValue(templateField->type, valueContainer);\n}\nASSETSTOOLS_API QWORD AssetTypeValueField::Write(IAssetsWriter *pWriter, QWORD filePos, bool bigEndian)\n{\n\tQWORD qwValueTmp;\n\tfloat fValueTmp;\n\tdouble dValueTmp;\n\tuint32_t dwValueTmp;\n\tuint8_t byValueTmp;\n\tbool doPadding = this->templateField->align;\n\tif (this->templateField->children.empty()\n\t\t&& this->value != NULL && this->value->GetType() != ValueType_ByteArray)\n\t{\n\t\tswitch (this->templateField->valueType)\n\t\t{\n\t\t\tcase ValueType_Bool:\n\t\t\tcase ValueType_Int8:\n\t\t\tcase ValueType_UInt8:\n\t\t\t\tbyValueTmp = this->value->AsInt() & 0xFF;\n\t\t\t\tpWriter->Write(filePos, 1, &byValueTmp); filePos++;\n\t\t\t\tbreak;\n\t\t\tcase ValueType_Int16:\n\t\t\tcase ValueType_UInt16:\n\t\t\t\tdwValueTmp = this->value->AsInt() & 0xFFFF;\n\t\t\t\tif (bigEndian)\n\t\t\t\t\tSwapEndians_((dwValueTmp <<= 16));\n\t\t\t\tpWriter->Write(filePos, 2, &dwValueTmp); filePos+=2;\n\t\t\t\tbreak;\n\t\t\tcase ValueType_Int32:\n\t\t\tcase ValueType_UInt32:\n\t\t\t\tdwValueTmp = this->value->AsInt();\n\t\t\t\tif (bigEndian)\n\t\t\t\t\tSwapEndians_(dwValueTmp);\n\t\t\t\tpWriter->Write(filePos, 4, &dwValueTmp); filePos+=4;\n\t\t\t\tbreak;\n\t\t\tcase ValueType_Int64:\n\t\t\tcase ValueType_UInt64:\n\t\t\t\tqwValueTmp = this->value->AsInt64();\n\t\t\t\tif (bigEndian)\n\t\t\t\t\tSwapEndians_(qwValueTmp);\n\t\t\t\tpWriter->Write(filePos, 8, &qwValueTmp); filePos+=8;\n\t\t\t\tbreak;\n\t\t\tcase ValueType_Float:\n\t\t\t\tfValueTmp = this->value->AsFloat();\n\t\t\t\tif (bigEndian)\n\t\t\t\t\tSwapEndians_(fValueTmp);\n\t\t\t\tpWriter->Write(filePos, 4, &fValueTmp); filePos+=4;\n\t\t\t\tbreak;\n\t\t\tcase ValueType_Double:\n\t\t\t\tdValueTmp = this->value->AsDouble();\n\t\t\t\tif (bigEndian)\n\t\t\t\t\tSwapEndians_(dValueTmp);\n\t\t\t\tpWriter->Write(filePos, 8, &dValueTmp); filePos+=8;\n\t\t\t\tbreak;\n\t\t}\n\t}\n\telse if (this->value != NULL && this->value->GetType() == ValueType_String)\n\t{\n\t\tconst char *strVal = this->value->AsString();\n\t\tif (strVal == NULL)\n\t\t\tstrVal = "";\n\t\tuint32_t curStrLen = (uint32_t)strlen(strVal);\n\t\tdwValueTmp = curStrLen;\n\t\tif (bigEndian)\n\t\t\tSwapEndians_(dwValueTmp);\n\t\tpWriter->Write(filePos, 4, &dwValueTmp); filePos+=4;\n\t\tpWriter->Write(filePos, curStrLen, strVal); filePos+=curStrLen;\n\t\tif ((this->templateField->children.size() == 1) && this->templateField->children[0].align)\n\t\t\tdoPadding = true;\n\t}\n\telse if (this->value != NULL\n\t\t&& (this->value->GetType() == ValueType_Array || this->value->GetType() == ValueType_ByteArray))\n\t{\n\t\tif (this->value->GetType() == ValueType_ByteArray)\n\t\t{\n\t\t\tuint32_t curByteLen = this->value->AsByteArray()->size;\n\t\t\tdwValueTmp = curByteLen;\n\t\t\tif (bigEndian)\n\t\t\t\tSwapEndians_(dwValueTmp);\n\t\t\tpWriter->Write(filePos, 4, &dwValueTmp); filePos += 4;\n\t\t\tpWriter->Write(filePos, curByteLen, this->value->AsByteArray()->data); filePos += curByteLen;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tuint32_t curArrLen = this->value->AsArray()->size;\n\t\t\tdwValueTmp = curArrLen;\n\t\t\tpWriter->Write(filePos, 4, &dwValueTmp); filePos += 4;\n\t\t\tfor (uint32_t i = 0; i < curArrLen; i++)\n\t\t\t{\n\t\t\t\tfilePos = this->pChildren[i]->Write(pWriter, filePos, bigEndian);\n\t\t\t}\n\t\t}\n\t\tif ((this->templateField->children.size() == 1) && this->templateField->children[0].align)\n\t\t\tdoPadding = true; //For special case: String overwritten with ByteArray value.\n\t}\n\telse if (this->childrenCount > 0)\n\t{\n\t\tfor (uint32_t i = 0; i < this->childrenCount; i++)\n\t\t{\n\t\t\tfilePos = this->pChildren[i]->Write(pWriter, filePos, bigEndian);\n\t\t}\n\t}\n\tif (doPadding)\n\t{\n\t\tint paddingLen = 3-(((filePos&3)-1) & 3);\n\t\tif (paddingLen > 0)\n\t\t{\n\t\t\tdwValueTmp = 0;\n\t\t\tpWriter->Write(filePos, paddingLen, &dwValueTmp); filePos += paddingLen;\n\t\t}\n\t}\n\treturn filePos;\n}\nASSETSTOOLS_API QWORD AssetTypeValueField::GetByteSize(QWORD filePos)\n{\n\tbool doPadding = this->templateField->align;\n\tif ((this->templateField->children.empty()) && (this->value != NULL))\n\t{\n\t\tswitch (this->templateField->valueType)\n\t\t{\n\t\t\tcase ValueType_Bool:\n\t\t\tcase ValueType_Int8:\n\t\t\tcase ValueType_UInt8:\n\t\t\t\tfilePos++;\n\t\t\t\tbreak;\n\t\t\tcase ValueType_Int16:\n\t\t\tcase ValueType_UInt16:\n\t\t\t\tfilePos+=2;\n\t\t\t\tbreak;\n\t\t\tcase ValueType_Int32:\n\t\t\tcase ValueType_UInt32:\n\t\t\tcase ValueType_Float:\n\t\t\t\tfilePos+=4;\n\t\t\t\tbreak;\n\t\t\tcase ValueType_Int64:\n\t\t\tcase ValueType_UInt64:\n\t\t\tcase ValueType_Double:\n\t\t\t\tfilePos+=8;\n\t\t\t\tbreak;\n\t\t}\n\t}\n\telse if ((this->templateField->valueType == ValueType_String) && (this->value != NULL))\n\t{\n\t\tfilePos+=4 + strlen(this->value->AsString());\n\t\tif ((this->templateField->children.size() > 0) && this->templateField->children[0].align)\n\t\t\tdoPadding = true;\n\t}\n\telse if (this->templateField->isArray && (this->value != NULL))\n\t{\n\t\tfilePos += 4;\n\t\tif (!_stricmp(this->templateField->type.c_str(), "TypelessData"))\n\t\t\tfilePos += this->value->AsByteArray()->size;\n\t\telse\n\t\t{\n\t\t\tfor (uint32_t i = 0; i < this->value->AsArray()->size; i++)\n\t\t\t{\n\t\t\t\tfilePos = this->pChildren[i]->GetByteSize(filePos);\n\t\t\t}\n\t\t}\n\t}\n\telse if (this->childrenCount > 0)\n\t{\n\t\tfor (uint32_t i = 0; i < this->childrenCount; i++)\n\t\t{\n\t\t\tfilePos = this->pChildren[i]->GetByteSize(filePos);\n\t\t}\n\t}\n\tif (doPadding)\n\t\tfilePos = (filePos+3)&(~3);\n\treturn filePos;\n}\n\nvoid ClearAssetTypeValueField(AssetTypeValueField *pValueField)\n{\n\tfree(pValueField);\n}\n\nASSETSTOOLS_API bool AssetTypeValueField::IsDummy() const\n{\n\treturn (childrenCount == -1);\n}\n\nclass _DummyAssetTypeField : public AssetTypeValueField\n{\npublic:\n\t_DummyAssetTypeField()\n\t{\n\t\tthis->pChildren = NULL;\n\t\tthis->childrenCount = -1;\n\t\tthis->templateField = NULL;\n\t\tthis->value = NULL;\n\t}\n};\n\n_DummyAssetTypeField dummyAssetTypeField = _DummyAssetTypeField();\nAssetTypeValueField* GetDummyAssetTypeField()\n{\n\treturn &dummyAssetTypeField;\n}\n\nEnumValueTypes GetValueTypeByTypeName(const char *type)\n{\n\tEnumValueTypes ret = ValueType_None;\n\tif (!_stricmp(type, "string"))\n\t{\n\t\tret = ValueType_String;\n\t}\n\telse if (!_stricmp(type, "SInt8") || !_stricmp(type, "char"))\n\t{\n\t\tret = ValueType_Int8;\n\t}\n\telse if (!_stricmp(type, "UInt8") || !_stricmp(type, "unsigned char"))\n\t{\n\t\tret = ValueType_UInt8;\n\t}\n\telse if (!_stricmp(type, "SInt16") || !_stricmp(type, "short"))\n\t{\n\t\tret = ValueType_Int16;\n\t}\n\telse if (!_stricmp(type, "UInt16") || !_stricmp(type, "unsigned short"))\n\t{\n\t\tret = ValueType_UInt16;\n\t}\n\telse if (!_stricmp(type, "SInt32") || !_stricmp(type, "int") ||  !_stricmp(type, "Type*"))\n\t{\n\t\tret = ValueType_Int32;\n\t}\n\telse if (!_stricmp(type, "UInt32") || !_stricmp(type, "unsigned int"))\n\t{\n\t\tret = ValueType_UInt32;\n\t}\n\telse if (!_stricmp(type, "SInt64") || !_stricmp(type, "long"))\n\t{\n\t\tret = ValueType_Int64;\n\t}\n\telse if (!_stricmp(type, "UInt64") || !_stricmp(type, "FileSize") || !_stricmp(type, "unsigned long"))\n\t{\n\t\tret = ValueType_UInt64;\n\t}\n\telse if (!_stricmp(type, "float"))\n\t{\n\t\tret = ValueType_Float;\n\t}\n\telse if (!_stricmp(type, "double"))\n\t{\n\t\tret = ValueType_Double;\n\t}\n\telse if (!_stricmp(type, "bool"))\n\t{\n\t\tret = ValueType_Bool;\n\t}\n\treturn ret;\n}\n\nint _RecursiveGetValueFieldCount(AssetTypeTemplateField *pChild, IAssetsReader *pReader, QWORD maxFilePos, QWORD *pFilePos, size_t *pValueByteLen, size_t *pChildListLen, size_t *pRawDataLen, bool *pReadFailed, bool endianness)\n{\n\tQWORD filePos = *pFilePos;\n\tsize_t valueByteLen = *pValueByteLen;\n\tsize_t childListLen = *pChildListLen;\n\tsize_t rawDataLen = *pRawDataLen;\n\tint ret = 0;\n\tif (!(*pReadFailed))\n\t{\n\t\tret = 1;\n\t\tif (pChild->isArray && (pChild->children.size() == 2))\n\t\t{\n\t\t\tvalueByteLen += sizeof(AssetTypeValue);\n\t\t\tunsigned int arrayLen;\n\t\t\tif ((pChild->children[0].valueType == ValueType_Int32) || (pChild->children[0].valueType == ValueType_UInt32))\n\t\t\t{\n\t\t\t\tpReader->Read(filePos, 4, &arrayLen); filePos += 4;\n\t\t\t\tif (endianness)\n\t\t\t\t\tSwapEndians_(arrayLen);\n\t\t\t\tif (!_stricmp(pChild->type.c_str(), "TypelessData"))\n\t\t\t\t{\n\t\t\t\t\trawDataLen += arrayLen;\n\t\t\t\t\tfilePos += arrayLen;\n\t\t\t\t\tif (filePos > maxFilePos)\n\t\t\t\t\t{\n\t\t\t\t\t\t*pReadFailed = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tchildListLen += sizeof(AssetTypeValueField*) * arrayLen;\n\t\t\t\t\tfor (uint32_t i = 0; i < arrayLen; i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tret += _RecursiveGetValueFieldCount(&pChild->children[1], pReader, maxFilePos, &filePos, &valueByteLen, &childListLen, &rawDataLen, pReadFailed, endianness);\n\t\t\t\t\t\tif ((*pReadFailed) || (filePos > maxFilePos))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t*pReadFailed = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (pChild->align)\n\t\t\t\t\tfilePos = (filePos + 3) & (~3);\n\t\t\t}\n\t\t\telse\n\t\t\t\tassert(false);\n\t\t\t//else\n\t\t\t//\tMessageBox(0, TEXT("Invalid array value type!"), TEXT("ERROR"), 16);\n\t\t}\n\t\telse if (pChild->valueType == ValueType_String)\n\t\t{\n\t\t\tunsigned int stringLen;\n\t\t\tpReader->Read(filePos, 4, &stringLen); filePos += 4;\n\t\t\tif (endianness)\n\t\t\t\tSwapEndians_(stringLen);\n\t\t\tif ((filePos + stringLen) > maxFilePos)\n\t\t\t{\n\t\t\t\t*pReadFailed = true;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tfilePos += stringLen;\n\t\t\t\tif (pChild->align || ((pChild->children.size() > 0) && pChild->children[0].align))\n\t\t\t\t\tfilePos = (filePos+3)&(~3);\n\t\t\t\tvalueByteLen += (sizeof(AssetTypeValue) + stringLen + 1);\n\t\t\t}\n\t\t}\n\t\telse if (pChild->children.empty())\n\t\t{\n\t\t\tswitch (pChild->valueType)\n\t\t\t{\n\t\t\t\tcase ValueType_Bool:\n\t\t\t\tcase ValueType_Int8:\n\t\t\t\tcase ValueType_UInt8:\n\t\t\t\t\tfilePos++;\n\t\t\t\t\tbreak;\n\t\t\t\tcase ValueType_Int16:\n\t\t\t\tcase ValueType_UInt16:\n\t\t\t\t\tfilePos+=2;\n\t\t\t\t\tbreak;\n\t\t\t\tcase ValueType_Int32:\n\t\t\t\tcase ValueType_UInt32:\n\t\t\t\tcase ValueType_Float:\n\t\t\t\t\tfilePos+=4;\n\t\t\t\t\tbreak;\n\t\t\t\tcase ValueType_Int64:\n\t\t\t\tcase ValueType_UInt64:\n\t\t\t\tcase ValueType_Double:\n\t\t\t\t\tfilePos+=8;\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tvalueByteLen += sizeof(AssetTypeValue);\n\t\t\tif (pChild->align)\n\t\t\t\tfilePos = (filePos+3)&(~3);\n\t\t\tif (filePos > maxFilePos)\n\t\t\t{\n\t\t\t\t*pReadFailed = true;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tchildListLen += sizeof(AssetTypeValueField*) * pChild->children.size();\n\t\t\tfor (uint32_t i = 0; i < (uint32_t)pChild->children.size(); i++)\n\t\t\t{\n\t\t\t\tret += _RecursiveGetValueFieldCount(&pChild->children[i], pReader, maxFilePos, &filePos, &valueByteLen, &childListLen, &rawDataLen, pReadFailed, endianness);\n\t\t\t}\n\t\t\tif (pChild->align)\n\t\t\t\tfilePos = (filePos+3)&(~3);\n\t\t}\n\t}\n\t*pRawDataLen = rawDataLen;\n\t*pChildListLen = childListLen;\n\t*pValueByteLen = valueByteLen;\n\t*pFilePos = filePos;\n\treturn ret;\n}\nQWORD _RecursiveMakeValues(AssetTypeTemplateField *pTemplate, IAssetsReader *pReader, QWORD filePos, QWORD maxFilePos,\n\tAssetTypeValueField *pValueFields, uint32_t &valueFieldIndex, AssetTypeValue *&pCurValue, AssetTypeValueField**&pCurValueFieldList, \n\tuint8_t *&pCurRawData, bool bigEndian)\n{\n\tif (pTemplate->isArray)\n\t{\n\t\tif (pTemplate->children.size() == 2)\n\t\t{\n\t\t\tif ((pTemplate->children[0].valueType == ValueType_Int32) || (pTemplate->children[0].valueType == ValueType_UInt32))\n\t\t\t{\n\t\t\t\tunsigned int arrayLen;\n\t\t\t\tpReader->Read(filePos, 4, &arrayLen); filePos += 4;\n\t\t\t\tif (bigEndian)\n\t\t\t\t\tSwapEndians_(arrayLen);\n\t\t\t\tif (!_stricmp(pTemplate->type.c_str(), "TypelessData"))\n\t\t\t\t{\n\t\t\t\t\tAssetTypeByteArray _tmpArray;\n\t\t\t\t\t_tmpArray.size = arrayLen;\n\t\t\t\t\t_tmpArray.data = pCurRawData;\n\t\t\t\t\tpReader->Read(filePos, arrayLen, pCurRawData); filePos += arrayLen;\n\t\t\t\t\tif (filePos <= maxFilePos)\n\t\t\t\t\t{\n\t\t\t\t\t\tpCurRawData = &pCurRawData[arrayLen];\n\t\t\t\t\t\tAssetTypeValue _tmpValue = AssetTypeValue(ValueType_ByteArray, &_tmpArray);\n\t\t\t\t\t\tmemcpy(pCurValue, &_tmpValue, sizeof(AssetTypeValue));\n\t\t\t\t\t\tpValueFields[valueFieldIndex].Read(pCurValue, pTemplate, 0, NULL);\n\t\t\t\t\t\tvalueFieldIndex++;\n\t\t\t\t\t\tpCurValue = (AssetTypeValue*)((uintptr_t)pCurValue + sizeof(AssetTypeValue));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tAssetTypeArray _tmpArray;\n\t\t\t\t\t_tmpArray.size = arrayLen;\n\t\t\t\t\t//_tmpArray.dataField = &pValueFields[valueFieldIndex+1];\n\n\t\t\t\t\tAssetTypeValue _tmpValue = AssetTypeValue(ValueType_Array, &_tmpArray);\n\t\t\t\t\tmemcpy(pCurValue, &_tmpValue, sizeof(AssetTypeValue));\n\n\t\t\t\t\tAssetTypeValueField** arrayItemList = pCurValueFieldList;\n\t\t\t\t\tpCurValueFieldList = (AssetTypeValueField**)((uintptr_t)pCurValueFieldList + (sizeof(AssetTypeValueField*) * arrayLen));\n\t\t\t\t\tuint32_t curValueFieldIndex = 0;\n\n\t\t\t\t\tpValueFields[valueFieldIndex].Read(pCurValue, pTemplate, arrayLen, arrayItemList);\n\t\t\t\t\tpCurValue = (AssetTypeValue*)((uintptr_t)pCurValue + sizeof(AssetTypeValue));\n\t\t\t\t\tvalueFieldIndex++;\n\t\t\t\t\tfor (uint32_t i = 0; i < arrayLen; i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tarrayItemList[curValueFieldIndex] = &pValueFields[valueFieldIndex];\n\t\t\t\t\t\tfilePos = _RecursiveMakeValues(&pTemplate->children[1], pReader, filePos, maxFilePos, pValueFields, valueFieldIndex, pCurValue, pCurValueFieldList, pCurRawData, bigEndian);\n\t\t\t\t\t\tcurValueFieldIndex++;\n\t\t\t\t\t\tif (filePos > maxFilePos)\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (pTemplate->align)\n\t\t\t\t\tfilePos = (filePos + 3) & (~3);\n\t\t\t}\n\t\t\telse\n\t\t\t\tassert(false);\n\t\t\t//else\n\t\t\t//\tMessageBox(0, TEXT("Invalid array value type!"), TEXT("ERROR"), 16);\n\t\t}\n\t\telse\n\t\t\tassert(false);\n\t\t//else\n\t\t//\tMessageBox(0, TEXT("Invalid array!"), TEXT("ERROR"), 16);\n\t}\n\telse if (pTemplate->valueType == ValueType_String)\n\t{\n\t\tunsigned int stringLen;\n\t\tpReader->Read(filePos, 4, &stringLen); filePos += 4;\n\t\tif (bigEndian)\n\t\t\tSwapEndians_(stringLen);\n\t\tif ((filePos + stringLen) > maxFilePos)\n\t\t\tstringLen = (unsigned int)(maxFilePos - filePos);\n\t\tchar *stringLocation = (char*)((uintptr_t)pCurValue + sizeof(AssetTypeValue)); stringLocation[stringLen] = 0;\n\t\tpReader->Read(filePos, stringLen, stringLocation); filePos += stringLen;\n\t\tAssetTypeValue _tmpValue = AssetTypeValue(ValueType_String, stringLocation);\n\t\tmemcpy(pCurValue, &_tmpValue, sizeof(AssetTypeValue));\n\t\tpValueFields[valueFieldIndex].Read(pCurValue, pTemplate, 0, NULL);\n\t\t\n\t\tif (pTemplate->align || ((pTemplate->children.size() > 0) && pTemplate->children[0].align))\n\t\t\tfilePos = (filePos+3)&(~3);\n\t\tvalueFieldIndex++;\n\t\tpCurValue = (AssetTypeValue*)((uintptr_t)pCurValue + sizeof(AssetTypeValue) + stringLen + 1);\n\t}\n\telse if (pTemplate->children.empty())\n\t{\n\t\tchar _valueContainer[8] = {0,0,0,0,0,0,0,0};\n\t\tchar *valueContainer = _valueContainer;\n\t\tswitch (pTemplate->valueType)\n\t\t{\n\t\t\tcase ValueType_Bool:\n\t\t\tcase ValueType_Int8:\n\t\t\tcase ValueType_UInt8:\n\t\t\t\tpReader->Read(filePos, 1, valueContainer);\n\t\t\t\tfilePos++;\n\t\t\t\tbreak;\n\t\t\tcase ValueType_Int16:\n\t\t\tcase ValueType_UInt16:\n\t\t\t\tpReader->Read(filePos, 2, valueContainer);\n\t\t\t\tif (bigEndian)\n\t\t\t\t\tSwapEndians_(*(uint16_t*)valueContainer);\n\t\t\t\tfilePos+=2;\n\t\t\t\tbreak;\n\t\t\tcase ValueType_Int32:\n\t\t\tcase ValueType_UInt32:\n\t\t\tcase ValueType_Float:\n\t\t\t\tpReader->Read(filePos, 4, valueContainer);\n\t\t\t\tif (bigEndian)\n\t\t\t\t\tSwapEndians_(*(uint32_t*)valueContainer);\n\t\t\t\tfilePos+=4;\n\t\t\t\tbreak;\n\t\t\tcase ValueType_Int64:\n\t\t\tcase ValueType_UInt64:\n\t\t\tcase ValueType_Double:\n\t\t\t\tpReader->Read(filePos, 8, valueContainer);\n\t\t\t\tif (bigEndian)\n\t\t\t\t\tSwapEndians_(*(QWORD*)valueContainer);\n\t\t\t\tfilePos+=8;\n\t\t\t\tbreak;\n\t\t\tcase ValueType_String:\n\t\t\t\tfilePos = filePos;\n\t\t\t\tbreak;\n\t\t}\n\t\tif (pTemplate->align)\n\t\t\tfilePos = (filePos+3)&(~3);\n\t\tif (filePos <= maxFilePos)\n\t\t{\n\t\t\tAssetTypeValue _tmpValue = AssetTypeValue(pTemplate->valueType, valueContainer);\n\t\t\tmemcpy(pCurValue, &_tmpValue, sizeof(AssetTypeValue));\n\t\t\tpValueFields[valueFieldIndex].Read(pCurValue, pTemplate, 0, NULL);\n\t\t\tvalueFieldIndex++;\n\t\t\tpCurValue = (AssetTypeValue*)((uintptr_t)pCurValue + sizeof(AssetTypeValue));\n\t\t}\n\t}\n\telse\n\t{\n\t\tAssetTypeValueField** templateChildList = pCurValueFieldList;\n\t\tpCurValueFieldList = (AssetTypeValueField**)((uintptr_t)pCurValueFieldList + (sizeof(AssetTypeValueField*) * pTemplate->children.size()));\n\t\tuint32_t curValueFieldIndex = 0;\n\n\t\tpValueFields[valueFieldIndex].Read(NULL, pTemplate, (uint32_t)pTemplate->children.size(), templateChildList);\n\t\tvalueFieldIndex++;\n\n\t\tfor (uint32_t i = 0; i < (uint32_t)pTemplate->children.size(); i++)\n\t\t{\n\t\t\ttemplateChildList[curValueFieldIndex] = &pValueFields[valueFieldIndex];\n\t\t\tfilePos = _RecursiveMakeValues(&pTemplate->children[i], pReader, filePos, maxFilePos, pValueFields, valueFieldIndex, pCurValue, pCurValueFieldList, pCurRawData, bigEndian);\n\t\t\tcurValueFieldIndex++;\n\t\t}\n\t\tif (pTemplate->align)\n\t\t\tfilePos = (filePos+3)&(~3);\n\t}\n\treturn filePos;\n}\n\nASSETSTOOLS_API AssetTypeTemplateField::AssetTypeTemplateField()\n\t: valueType(ValueType_None),\n\tisArray(false), align(false), hasValue(false)\n{}\nASSETSTOOLS_API void AssetTypeTemplateField::Clear()\n{\n\tname.clear();\n\ttype.clear();\n\tchildren.clear();\n}\nASSETSTOOLS_API AssetTypeTemplateField::~AssetTypeTemplateField()\n{}\n\nASSETSTOOLS_API QWORD AssetTypeTemplateField::MakeValue(IAssetsReader *pReader, QWORD filePos, QWORD fileLen, AssetTypeValueField **ppValueField, bool endianness)\n{\n\tAssetTypeValue *newValue = NULL;\n\tQWORD tmpFilePos = filePos;\n\tsize_t newValueByteLen = 0; size_t childListByteLen = 0; size_t rawDataByteLen = 0;\n\t//Set to true if it goes EOF while reading an array; This allows parsing empty files and having them filled with zeros without risking crashes on invalid files. \n\tbool readFailed = false;\n\tint newChildrenCount = _RecursiveGetValueFieldCount(this, pReader, filePos+fileLen, &tmpFilePos, &newValueByteLen, &childListByteLen, &rawDataByteLen, &readFailed, endianness);\n\t//ppValueField will be set to pValueFieldMemory so the caller knows which pointer to free\n\tif (readFailed)\n\t{\n\t\t*ppValueField = NULL;\n\t\treturn filePos;\n\t}\n\tvoid *pValueFieldMemory = malloc((newChildrenCount * sizeof(AssetTypeValueField)) + newValueByteLen + childListByteLen + rawDataByteLen);\n\tif (pValueFieldMemory == NULL)\n\t{\n\t\t*ppValueField = NULL;\n\t\treturn filePos;\n\t}\n\tAssetTypeValueField *pValueFields = (AssetTypeValueField*)pValueFieldMemory;\n\tAssetTypeValue *pCurValue = (AssetTypeValue*)(&((uint8_t*)pValueFieldMemory)[newChildrenCount * sizeof(AssetTypeValueField)]);\n\n\tAssetTypeValueField **pCurValueList = (AssetTypeValueField**)(&((uint8_t*)pValueFieldMemory)[newChildrenCount * sizeof(AssetTypeValueField) + newValueByteLen]);\n\tuint8_t *pCurRawByte = (uint8_t*)(&((uint8_t*)pValueFieldMemory)[newChildrenCount * sizeof(AssetTypeValueField) + newValueByteLen + childListByteLen]);\n\n\tuint32_t valueFieldIndex = 0; \n\tfilePos = _RecursiveMakeValues(this, pReader, filePos, filePos+fileLen, pValueFields, valueFieldIndex, pCurValue, pCurValueList, pCurRawByte, endianness);\n\t//_RecursiveDumpValues(pValueFields, 0);\n\t*ppValueField = &pValueFields[0];\n\treturn filePos;\n}\n\nASSETSTOOLS_API bool AssetTypeTemplateField::From0D(Type_0D *pU5Type, uint32_t fieldIndex)\n{\n\tif (pU5Type->typeFieldsExCount <= fieldIndex)\n\t{\n\t\tmemset(this, 0, sizeof(AssetTypeTemplateField));\n\t\treturn false;\n\t}\n\tTypeField_0D *pTypeField = &pU5Type->pTypeFieldsEx[fieldIndex];\n\ttype = pTypeField->GetTypeString(pU5Type->pStringTable, pU5Type->stringTableLen);\n\tname = pTypeField->GetNameString(pU5Type->pStringTable, pU5Type->stringTableLen);\n\tif (!type.empty())\n\t\tvalueType = GetValueTypeByTypeName(type.c_str());\n\telse\n\t\tvalueType = ValueType_None;\n\tisArray = (pTypeField->isArray & 1) != 0;\n\tif (isArray)\n\t\tvalueType = ValueType_Array;\n\talign = (pTypeField->flags & 0x4000) != 0;\n\n\tsize_t newChildCount = 0; uint8_t directChildDepth = 0;\n\tfor (uint32_t i = fieldIndex+1; i < pU5Type->typeFieldsExCount; i++)\n\t{\n\t\tif (pU5Type->pTypeFieldsEx[i].depth <= pTypeField->depth)\n\t\t\tbreak;\n\t\tif (!directChildDepth)\n\t\t{\n\t\t\tdirectChildDepth = pU5Type->pTypeFieldsEx[i].depth;\n\t\t\tnewChildCount++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (pU5Type->pTypeFieldsEx[i].depth == directChildDepth)\n\t\t\t\tnewChildCount++;\n\t\t}\n\t}\n\thasValue = (newChildCount == 0);\n\tchildren.resize(newChildCount);\n\tsize_t childIndex = 0; bool ret = true;\n\tfor (uint32_t i = fieldIndex+1; i < pU5Type->typeFieldsExCount; i++)\n\t{\n\t\tif (pU5Type->pTypeFieldsEx[i].depth <= pTypeField->depth)\n\t\t\tbreak;\n\t\tif (pU5Type->pTypeFieldsEx[i].depth == directChildDepth)\n\t\t{\n\t\t\tif (!children[childIndex].From0D(pU5Type, i))\n\t\t\t\tret = false;\n\t\t\tchildIndex++;\n\t\t}\n\t}\n\treturn ret;\n}\nASSETSTOOLS_API bool AssetTypeTemplateField::FromClassDatabase(ClassDatabaseFile *pFile, ClassDatabaseType *pType, uint32_t fieldIndex)\n{\n\tif (pType->fields.size() <= fieldIndex)\n\t{\n\t\tmemset(this, 0, sizeof(AssetTypeTemplateField));\n\t\treturn false;\n\t}\n\tchildren.clear();\n\tClassDatabaseTypeField *pTypeField = &pType->fields[fieldIndex];\n\tisArray = (pTypeField->isArray & 1) != 0;\n\tname = pTypeField->fieldName.GetString(pFile);\n\ttype = pTypeField->typeName.GetString(pFile);\n\tif (!type.empty())\n\t\tvalueType = GetValueTypeByTypeName(type.c_str());\n\telse\n\t\tvalueType = ValueType_None;\n\talign = (pTypeField->flags2 & 0x4000) != 0;\n\n\tsize_t newChildCount = 0;\n\tuint8_t directChildDepth = 0;\n\tfor (uint32_t i = fieldIndex+1; i < pType->fields.size(); i++)\n\t{\n\t\tif (pType->fields[i].depth <= pTypeField->depth)\n\t\t\tbreak;\n\t\tif (!directChildDepth)\n\t\t{\n\t\t\tdirectChildDepth = pType->fields[i].depth;\n\t\t\tnewChildCount++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (pType->fields[i].depth == directChildDepth)\n\t\t\t\tnewChildCount++;\n\t\t}\n\t}\n\thasValue = (pType->fields.size() > (fieldIndex+1)) ? (newChildCount == 0) : true;\n\tchildren.resize(newChildCount);\n\tsize_t childIndex = 0; bool ret = true;\n\tfor (uint32_t i = fieldIndex+1; i < pType->fields.size(); i++)\n\t{\n\t\tif (pType->fields[i].depth <= pTypeField->depth)\n\t\t\tbreak;\n\t\tif (pType->fields[i].depth == directChildDepth)\n\t\t{\n\t\t\tif (!children[childIndex].FromClassDatabase(pFile, pType, i))\n\t\t\t\tret = false;\n\t\t\tchildIndex++;\n\t\t}\n\t}\n\treturn ret;\n}\nASSETSTOOLS_API bool AssetTypeTemplateField::From07(TypeField_07 *pTypeField)\n{\n\tisArray = pTypeField->arrayFlag != 0;\n\talign = (pTypeField->flags2 & 0x4000) != NULL;\n\tname = pTypeField->name;\n\ttype = pTypeField->type;\n\tif (!type.empty())\n\t\tvalueType = GetValueTypeByTypeName(type.c_str());\n\telse\n\t\tvalueType = ValueType_None;\n\n\thasValue = (pTypeField->childrenCount == 0);\n\tchildren.resize(pTypeField->childrenCount);\n\tbool ret = true;\n\tfor (uint32_t i = 0; i < pTypeField->childrenCount; i++)\n\t{\n\t\tif (!children[i].From07(&pTypeField->children[i]))\n\t\t\tret = false;\n\t}\n\treturn ret;\n}\nASSETSTOOLS_API bool AssetTypeTemplateField::AddChildren(uint32_t count)\n{\n\tif ((children.size() + count) < children.size()) //overflow\n\t\treturn false;\n\tchildren.resize(children.size() + count);\n\treturn true;\n}\nASSETSTOOLS_API AssetTypeTemplateField *AssetTypeTemplateField::SearchChild(const char* name)\n{\n\tfor (size_t i = 0; i < children.size(); i++)\n\t{\n\t\tif (children[i].name == name)\n\t\t\treturn &children[i];\n\t}\n\treturn NULL;\n}\n\nASSETSTOOLS_API AssetTypeInstance::AssetTypeInstance(uint32_t baseFieldCount, AssetTypeTemplateField **ppBaseFields, QWORD fileLen, IAssetsReader *pReader, bool bigEndian, QWORD filePos)\n{\n\tthis->baseFields.resize(baseFieldCount);\n\tthis->memoryToClear.resize(baseFieldCount);\n\tQWORD nullPos = filePos;\n\tfor (uint32_t i = 0; i < baseFieldCount; i++)\n\t{\n\t\tfilePos = ppBaseFields[i]->MakeValue(pReader, filePos, fileLen - (filePos - nullPos), &this->baseFields[i], bigEndian);\n\t\tthis->memoryToClear[i] = this->baseFields[i];\n\t\tif (this->baseFields[i] == NULL)\n\t\t{\n\t\t\tthis->baseFields.resize(i);\n\t\t\tthis->memoryToClear.resize(i);\n\t\t\tbreak;\n\t\t}\n\t}\n}\nASSETSTOOLS_API bool AssetTypeInstance::SetChildList(AssetTypeValueField *pValueField, AssetTypeValueField **pChildrenList, uint32_t childrenCount, bool freeMemory)\n{\n\tif (pValueField->GetChildrenList() == pChildrenList)\n\t{\n\t\tif (pValueField->GetChildrenCount() == childrenCount)\n\t\t\treturn true;\n\t\tpValueField->SetChildrenList(pChildrenList, childrenCount);\n\t\treturn true;\n\t}\n\tfor (size_t i = 0; i < this->memoryToClear.size(); i++)\n\t{\n\t\tif (this->memoryToClear[i] == pValueField->GetChildrenList())\n\t\t{\n\t\t\tfor (uint32_t _i = 0; _i < pValueField->GetChildrenCount(); _i++)\n\t\t\t{\n\t\t\t\tbool found = false; AssetTypeValueField *pTarget = pValueField->Get(_i);\n\t\t\t\tfor (uint32_t _k = 0; _k < childrenCount; _k++)\n\t\t\t\t{\n\t\t\t\t\tif (pTarget == pChildrenList[_k])\n\t\t\t\t\t{\n\t\t\t\t\t\tfound = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!found)\n\t\t\t\t{\n\t\t\t\t\tfor (size_t k = 0; k < this->memoryToClear.size(); k++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (this->memoryToClear[k] == pTarget)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tthis->memoryToClear.erase(this->memoryToClear.begin() + k);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfree(this->memoryToClear[i]);\n\t\t\tpValueField->SetChildrenList(pChildrenList, childrenCount);\n\t\t\tif (freeMemory)\n\t\t\t{\n\t\t\t\tthis->memoryToClear[i] = pChildrenList;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tthis->memoryToClear.erase(this->memoryToClear.begin() + i);\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t}\n\tpValueField->SetChildrenList(pChildrenList, childrenCount);\n\tif (freeMemory)\n\t{\n\t\tthis->memoryToClear.push_back(pChildrenList);\n\t}\n\treturn true;\n}\nASSETSTOOLS_API bool AssetTypeInstance::AddTempMemory(void *pMemory)\n{\n\tthis->memoryToClear.push_back(pMemory);\n\treturn true;\n}\nvoid AssetTypeInstance::Clear()\n{\n\tfor (size_t i = 0; i < this->memoryToClear.size(); i++)\n\t{\n\t\tif (this->memoryToClear[i])\n\t\t\tfree(this->memoryToClear[i]);\n\t}\n\tthis->memoryToClear.clear();\n\tthis->baseFields.clear();\n}\n\nASSETSTOOLS_API AssetTypeInstance::~AssetTypeInstance()\n{\n\tClear();\n}'