b'{-# LANGUAGE\n    DeriveDataTypeable\n  , DeriveFoldable\n  , DeriveFunctor\n  , DeriveGeneric\n  , DeriveTraversable\n  , GADTs\n  , NoImplicitPrelude\n  , ScopedTypeVariables\n  , StandaloneDeriving\n  #-}\nmodule Rest.Types.Error\n  ( DataError (..)\n  , DomainReason (..)\n  , Status (..)\n  , fromEither\n  , toEither\n  , Reason_\n  , Reason (..)\n  , SomeReason (..)\n  , ToResponseCode (..)\n  ) where\n\nimport Prelude.Compat\n\nimport Control.Monad (ap)\nimport Data.Aeson hiding (Success)\nimport Data.JSON.Schema (JSONSchema (..), gSchema)\nimport Data.Typeable\nimport GHC.Generics\nimport Generics.Generic.Aeson\nimport Generics.XmlPickler (gxpickle)\nimport Text.XML.HXT.Arrow.Pickle\nimport Text.XML.HXT.Arrow.Pickle.Schema\nimport Text.XML.HXT.Arrow.Pickle.Xml\nimport qualified Data.JSON.Schema as JSONSchema\n\nimport Rest.Types.Void\n\n-- Error utilities.\n\ndata DataError\n  = ParseError        String\n  | PrintError        String\n  | MissingField      String\n  | UnsupportedFormat String\n  deriving (Eq, Generic, Show)\n\nnewtype DomainReason a = DomainReason { reason :: a }\n  deriving (Eq, Generic, Functor, Foldable, Show, Traversable)\n\ninstance XmlPickler a => XmlPickler (DomainReason a) where\n  xpickle = xpWrap (DomainReason, reason) xpickle\n\ninstance ToJSON a => ToJSON (DomainReason a) where\n  toJSON (DomainReason e) = toJSON e\ninstance FromJSON a => FromJSON (DomainReason a) where\n  parseJSON = fmap DomainReason . parseJSON\n\ninstance JSONSchema a => JSONSchema (DomainReason a) where\n  schema = schema . fmap reason\n\ndata Status a b = Failure a | Success b\n  deriving (Eq, Show, Generic, Typeable, Functor, Foldable, Traversable)\n\ninstance (XmlPickler a, XmlPickler b) => XmlPickler (Status a b) where\n  xpickle = gxpickle\n\ninstance (ToJSON   a, ToJSON   b) => ToJSON   (Status a b) where toJSON    = gtoJson\ninstance (FromJSON a, FromJSON b) => FromJSON (Status a b) where parseJSON = gparseJson\n\ninstance (JSONSchema a, JSONSchema b) => JSONSchema (Status a b) where\n  schema = gSchema\n\nfromEither :: Either a b -> Status a b\nfromEither = either Failure Success\n\ntoEither :: Status a b -> Either a b\ntoEither (Success x) = Right x\ntoEither (Failure y) = Left  y\n\ntype Reason_ = Reason Void\n\ndata Reason a\n  -- Thrown in the router.\n  = UnsupportedRoute\n  | UnsupportedMethod\n  | UnsupportedVersion\n\n  -- Thrown during generic IO.\n  | IdentError   DataError\n  | HeaderError  DataError\n  | ParamError   DataError\n  | InputError   DataError\n  | OutputError  DataError\n\n  -- Generic errors thrown in specific handlers.\n  | NotFound\n  | NotAllowed\n  | AuthenticationFailed\n  | Busy\n  | Gone\n\n  -- Custom domain reasons.\n  | CustomReason (DomainReason a)\n  deriving (Eq, Generic, Show, Typeable, Functor, Foldable, Traversable)\n\ninstance Applicative Reason where\n  pure = return\n  (<*>) = ap\n\ninstance Monad Reason where\n  return a = CustomReason (DomainReason a)\n  r >>= f = case r of\n    CustomReason (DomainReason a) -> f a\n    UnsupportedRoute              -> UnsupportedRoute\n    UnsupportedMethod             -> UnsupportedMethod\n    UnsupportedVersion            -> UnsupportedVersion\n    IdentError   e                -> IdentError   e\n    HeaderError  e                -> HeaderError  e\n    ParamError   e                -> ParamError   e\n    InputError   e                -> InputError   e\n    OutputError  e                -> OutputError  e\n    NotFound                      -> NotFound\n    NotAllowed                    -> NotAllowed\n    AuthenticationFailed          -> AuthenticationFailed\n    Busy                          -> Busy\n    Gone                          -> Gone\n\ninstance XmlPickler DataError where xpickle = gxpickle\ninstance XmlPickler e => XmlPickler (Reason e) where xpickle = gxpickle\n\ninstance ToJSON DataError where toJSON = gtoJson\ninstance FromJSON DataError where parseJSON = gparseJson\ninstance ToJSON e => ToJSON (Reason e) where toJSON = gtoJson\ninstance FromJSON e => FromJSON (Reason e) where parseJSON = gparseJson\n\ninstance JSONSchema DataError where schema = gSchema\ninstance JSONSchema e => JSONSchema (Reason e) where schema = gSchema\n\ndata SomeReason where\n  SomeReason :: (XmlPickler e, JSONSchema e, ToJSON e) => Reason e -> SomeReason\n\nderiving instance Typeable SomeReason\n\ninstance XmlPickler SomeReason where\n  xpickle = PU\n    (\\(SomeReason e) st -> appPickle xpickle e st)\n    (throwMsg "Cannot unpickle SomeReason.")\n    Any\n\ninstance ToJSON SomeReason where toJSON (SomeReason r) = toJSON r\n\ninstance JSONSchema SomeReason where\n  schema _ = JSONSchema.Any\n\n-- | The response code that should be given for a type.\n-- This is currently only used for errors.\nclass ToResponseCode a where\n  toResponseCode :: a -> Int\n\ninstance ToResponseCode Void where\n  toResponseCode = magic\n\ninstance ToResponseCode a => ToResponseCode (Reason a) where\n  toResponseCode e =\n    case e of\n      NotFound                          -> 404\n      UnsupportedRoute                  -> 404\n      UnsupportedMethod                 -> 405\n      UnsupportedVersion                -> 404\n      NotAllowed                        -> 403\n      AuthenticationFailed              -> 401\n      Busy                              -> 503\n      Gone                              -> 410\n      OutputError (UnsupportedFormat _) -> 406\n      InputError  _                     -> 400\n      OutputError _                     -> 500\n      IdentError  _                     -> 400\n      HeaderError _                     -> 400\n      ParamError  _                     -> 400\n      CustomReason (DomainReason a)     -> toResponseCode a\n'