b'{-# LANGUAGE LambdaCase #-}\n{-# LANGUAGE MultiWayIf #-}\n{-# OPTIONS_GHC -fno-warn-incomplete-uni-patterns #-}\n\nmodule Hoodle.Coroutine.Select where\n\nimport Control.Lens (set, view, (.~), (^.))\nimport Control.Monad (void, when, (>=>))\nimport Control.Monad.Identity (runIdentity)\nimport Control.Monad.State (get, gets, liftIO)\nimport Data.Bifunctor (first, second)\nimport Data.Hoodle.BBox\n  ( BBox (..),\n    ULMaybe (..),\n    UnionBBox (..),\n    getBBox,\n    inflate,\n  )\nimport Data.Hoodle.Generic\n  ( GLayer (..),\n    gbuffer,\n    gitems,\n    glayers,\n  )\nimport Data.Hoodle.Select\n  ( gselAll,\n    gselSelected,\n  )\nimport qualified Data.IntMap as M\nimport qualified Data.Maybe as Maybe (fromMaybe)\nimport Data.Sequence (Seq, (|>))\nimport qualified Data.Sequence as Sq (empty)\nimport Data.Time.Clock\n  ( UTCTime,\n    getCurrentTime,\n  )\nimport Graphics.Hoodle.Render.Generic (cairoRenderOption)\nimport Graphics.Hoodle.Render.Type\n  ( InBBox (..),\n    InBBoxOption (..),\n    RItem (..),\n    hPage2RPage,\n    isStrkInRItem,\n    mkHPage,\n    selectedLayer,\n  )\nimport Graphics.Hoodle.Render.Type.HitTest\n  ( AlterList (..),\n    Hitted (..),\n    NotHitted (..),\n    TEitherAlterHitted (..),\n    getB,\n    isAnyHitted,\n    takeHitted,\n    takeLastFromHitted,\n  )\nimport Graphics.Hoodle.Render.Util (clipBBox)\nimport Graphics.Hoodle.Render.Util.HitTest\n  ( do2BBoxIntersect,\n    hltEmbeddedByBBox,\n    hltFilteredBy,\n    isPointInBBox,\n  )\nimport qualified Graphics.Rendering.Cairo as Cairo\nimport qualified Graphics.Rendering.Cairo.Matrix as Mat\nimport Hoodle.Accessor\n  ( getCurrentPageCvsId,\n    getCurrentPageEitherFromHoodleModeState,\n    pureUpdateUhdl,\n    rItmsInCurrLyr,\n    renderCache,\n  )\nimport Hoodle.Coroutine.Commit (commit_)\nimport Hoodle.Coroutine.ContextMenu (showContextMenu)\nimport Hoodle.Coroutine.Draw\n  ( invalidateAllInBBox,\n    invalidateTemp,\n    invalidateTempBasePage,\n    nextevent,\n    waitSomeEvent,\n  )\nimport Hoodle.Coroutine.Mode (modeChange)\nimport Hoodle.Coroutine.Pen\n  ( commonPenStart,\n    createTempRender,\n    penMoveAndUpInterPage,\n    penMoveAndUpOnly,\n    skipIfNotInSamePage,\n    switchActionEnteringDiffPage,\n  )\nimport Hoodle.Coroutine.Select.Clipboard (updateTempHoodleSelectM)\nimport Hoodle.Device\n  ( PenButton (PenButton1, PenButton3),\n    PointerCoord,\n  )\nimport Hoodle.ModelAction.Layer (getCurrentLayer)\nimport Hoodle.ModelAction.Page (updatePageAll)\nimport Hoodle.ModelAction.Pen\n  ( TempRender,\n    tempInfo,\n    tempSurfaceSrc,\n    tempSurfaceTgt,\n    updateTempRender,\n  )\nimport Hoodle.ModelAction.Select\n  ( Handle\n      ( HandleBL,\n        HandleBR,\n        HandleTL,\n        HandleTR\n      ),\n    ItmsNImg,\n    TempSelection,\n    changeItemStrokeColor,\n    changeItemStrokeWidth,\n    checkIfHandleGrasped,\n    deleteSelected,\n    drawTempSelectImage,\n    getDiffBBox,\n    getNewBBoxFromHandlePos,\n    getNewCoordTime,\n    getSelectedItms,\n    getULBBoxFromSelected,\n    hitInHandle,\n    hitInSelection,\n    hitLassoItem,\n    imageSurface,\n    makePageSelectMode,\n    mkItmsNImg,\n    scaleFromToBBox,\n    separateFS,\n    toggleCutCopyDelete,\n  )\nimport Hoodle.ModelAction.Select.Transform\n  ( changeItemBy,\n    changeSelectionBy,\n    changeSelectionByOffset,\n    offsetFunc,\n  )\nimport Hoodle.Type.Alias\n  ( Page,\n    SelectMode,\n  )\nimport Hoodle.Type.Canvas\n  ( CanvasId,\n    CanvasInfo,\n    canvasId,\n    currentPageNum,\n    forBoth\',\n    unboxBiAct,\n  )\nimport Hoodle.Type.Coroutine (MainCoroutine)\nimport Hoodle.Type.Enum\n  ( DrawFlag (Efficient),\n    PenColor,\n    SelectType (SelectHandToolWork, SelectLassoWork, SelectRectangleWork),\n  )\nimport Hoodle.Type.Event (UserEvent (PenUp, ToViewAppendMode))\nimport Hoodle.Type.HoodleState\n  ( HoodleModeState (SelectState),\n    IsOneTimeSelectMode\n      ( NoOneTimeSelectMode,\n        YesAfterSelect,\n        YesBeforeSelect\n      ),\n    UnitHoodle,\n    currentUnit,\n    getCanvasInfo,\n    getCurrentCanvasId,\n    gtkUIManager,\n    hoodleModeState,\n    isOneTimeSelectMode,\n    unitHoodles,\n  )\nimport Hoodle.Type.PageArrangement\n  ( CanvasCoordinate (..),\n    DesktopCoordinate (..),\n    PageCoordinate (..),\n    PageNum (..),\n  )\nimport Hoodle.View.Coordinate\n  ( CanvasGeometry (desktop2Canvas, page2Desktop),\n  )\nimport Hoodle.View.Draw\n  ( cairoXform4PageCoordinate,\n    mkXform4Page,\n    renderBoxSelection,\n    renderLasso,\n    renderSelectedItem,\n  )\n\n--\n-- import           Prelude hiding ((.), id)\n\n-- | For Selection mode from pen mode with 2nd pen button\ndealWithOneTimeSelectMode ::\n  -- | main action\n  MainCoroutine () ->\n  -- | terminating action\n  MainCoroutine () ->\n  MainCoroutine ()\ndealWithOneTimeSelectMode action terminator = do\n  uhdl <- gets (view (unitHoodles . currentUnit))\n  case view isOneTimeSelectMode uhdl of\n    NoOneTimeSelectMode -> action\n    YesBeforeSelect ->\n      action >> pureUpdateUhdl (isOneTimeSelectMode .~ YesAfterSelect)\n    YesAfterSelect -> do\n      terminator\n      pureUpdateUhdl (isOneTimeSelectMode .~ NoOneTimeSelectMode)\n      modeChange ToViewAppendMode\n\n-- | common main mouse pointer click entrance in selection mode.\n--   choose either starting new selection or move previously\n--   selected selection.\ncommonSelectStart ::\n  SelectType ->\n  PenButton ->\n  CanvasId ->\n  PointerCoord ->\n  MainCoroutine ()\ncommonSelectStart typ pbtn cid = case typ of\n  SelectHandToolWork -> (\\_ -> return ())\n  _ -> commonPenStart selectaction cid >=> const (return ())\n  where\n    selectaction cinfo pnum geometry (x, y) _ = do\n      itms <- rItmsInCurrLyr\n      ctime <- liftIO getCurrentTime\n      let newSelectAction _page =\n            dealWithOneTimeSelectMode\n              ( do\n                  tsel <- createTempRender geometry []\n                  case typ of\n                    SelectRectangleWork -> do\n                      newSelectRectangle\n                        cid\n                        pnum\n                        geometry\n                        itms\n                        (x, y)\n                        ((x, y), ctime)\n                        tsel\n                      return ()\n                    SelectLassoWork -> do\n                      newSelectLasso\n                        cinfo\n                        pnum\n                        geometry\n                        itms\n                        (x, y)\n                        ((x, y), ctime)\n                        (Sq.empty |> (x, y))\n                        tsel\n                      return ()\n                    _ -> return ()\n                  Cairo.surfaceFinish (tempSurfaceSrc tsel)\n                  showContextMenu (pnum, (x, y))\n              )\n              (return ())\n          action (Right tpage) | hitInHandle tpage (x, y) = do\n            let doesKeepRatio = case pbtn of\n                  PenButton1 -> True\n                  PenButton3 -> False\n                  _ -> False\n            case getULBBoxFromSelected tpage of\n              Middle bbox ->\n                maybe\n                  (return ())\n                  ( \\handle ->\n                      startResizeSelect\n                        doesKeepRatio\n                        handle\n                        cid\n                        pnum\n                        geometry\n                        bbox\n                        ((x, y), ctime)\n                        tpage\n                  )\n                  (checkIfHandleGrasped bbox (x, y))\n              _ -> return ()\n          action (Right tpage) | hitInSelection tpage (x, y) =\n            case pbtn of\n              PenButton1 -> startMoveSelect cid pnum geometry ((x, y), ctime) tpage\n              PenButton3 -> do\n                _ <- waitSomeEvent (\\case PenUp _ _ -> True; _ -> False)\n                showContextMenu (pnum, (x, y))\n              _ -> return ()\n          action (Right tpage) = newSelectAction (hPage2RPage tpage)\n          action (Left page) = newSelectAction page\n      uhdl <- gets (view (unitHoodles . currentUnit))\n      let hdlmodst = view hoodleModeState uhdl\n      let epage = getCurrentPageEitherFromHoodleModeState cinfo hdlmodst\n      action epage\n\n-- | main mouse pointer click entrance in rectangular selection mode.\n--   choose either starting new rectangular selection or move previously\n--   selected selection.\nselectRectStart :: PenButton -> CanvasId -> PointerCoord -> MainCoroutine ()\nselectRectStart = commonSelectStart SelectRectangleWork\n\n-- |\nnewSelectRectangle ::\n  CanvasId ->\n  PageNum ->\n  CanvasGeometry ->\n  [RItem] ->\n  (Double, Double) ->\n  ((Double, Double), UTCTime) ->\n  TempSelection ->\n  MainCoroutine ()\nnewSelectRectangle\n  cid\n  pnum\n  geometry\n  itms\n  orig\n  (prev, otime)\n  tempselection = do\n    r <- nextevent\n    xst <- get\n    cache <- renderCache\n    forBoth\' unboxBiAct (fsingle r xst cache) . getCanvasInfo cid . view (unitHoodles . currentUnit) $ xst\n    where\n      fsingle r xstate cache cinfo = penMoveAndUpOnly r pnum geometry defact (moveact cache) (upact xstate cinfo)\n      defact = newSelectRectangle cid pnum geometry itms orig (prev, otime) tempselection\n      moveact cache (_pcoord, (x, y)) = do\n        let bbox = BBox orig (x, y)\n            hittestbbox = hltEmbeddedByBBox bbox itms\n            hitteditms = takeHitted hittestbbox\n        page <- getCurrentPageCvsId cid\n        let (fitms, sitms) = separateFS $ getDiffBBox (tempInfo tempselection) hitteditms\n        (willUpdate, (ncoord, ntime)) <- liftIO $ getNewCoordTime (prev, otime) (x, y)\n        when ((not . null) fitms || (not . null) sitms) $ do\n          let xformfunc = cairoXform4PageCoordinate (mkXform4Page geometry pnum)\n              ulbbox = unUnion . mconcat . fmap (Union . Middle . flip inflate 5 . getBBox) $ fitms\n              xform = mkXform4Page geometry pnum\n              renderfunc = do\n                xformfunc\n                case ulbbox of\n                  Top -> do\n                    _ <- cairoRenderOption (InBBoxOption Nothing) cache cid (InBBox page, Just xform)\n                    mapM_ renderSelectedItem hitteditms\n                  Middle sbbox -> do\n                    let redrawee = filter (do2BBoxIntersect sbbox . getBBox) hitteditms\n                    _ <- cairoRenderOption (InBBoxOption (Just sbbox)) cache cid (InBBox page, Just xform)\n                    clipBBox (Just sbbox)\n                    mapM_ renderSelectedItem redrawee\n                  Bottom -> return ()\n                mapM_ renderSelectedItem sitms\n          liftIO $ updateTempRender tempselection renderfunc False\n        when willUpdate $\n          invalidateTemp\n            cid\n            (tempSurfaceSrc tempselection)\n            (renderBoxSelection bbox)\n        newSelectRectangle\n          cid\n          pnum\n          geometry\n          itms\n          orig\n          (ncoord, ntime)\n          tempselection {tempInfo = hitteditms}\n      upact xstate cinfo pcoord = do\n        let (_, (x, y)) =\n              runIdentity $\n                skipIfNotInSamePage\n                  pnum\n                  geometry\n                  pcoord\n                  (return (pcoord, prev))\n                  return\n            uhdl = view (unitHoodles . currentUnit) xstate\n            epage = getCurrentPageEitherFromHoodleModeState cinfo (view hoodleModeState uhdl)\n            cpn = view currentPageNum cinfo\n            bbox = BBox orig (x, y)\n            hittestbbox = hltEmbeddedByBBox bbox itms\n            selectitms = first unNotHitted hittestbbox\n            SelectState thdl = view hoodleModeState uhdl\n            newpage = case epage of\n              Left pagebbox -> makePageSelectMode pagebbox selectitms\n              Right tpage ->\n                let currlayer = view (glayers . selectedLayer) tpage\n                    newlayer = set gitems (TEitherAlterHitted (Right selectitms)) currlayer\n                    npage = set (glayers . selectedLayer) newlayer tpage\n                 in npage\n            newthdl = set gselSelected (Just (cpn, newpage)) thdl\n            ui = view gtkUIManager xstate\n        liftIO $ toggleCutCopyDelete ui (isAnyHitted selectitms)\n        uhdl\' <- liftIO (updatePageAll (SelectState newthdl) uhdl)\n        pureUpdateUhdl (const ((hoodleModeState .~ SelectState newthdl) uhdl\'))\n        commit_\n        invalidateAllInBBox Nothing Efficient\n\n-- | prepare for moving selection\nstartMoveSelect ::\n  CanvasId ->\n  PageNum ->\n  CanvasGeometry ->\n  ((Double, Double), UTCTime) ->\n  Page SelectMode ->\n  MainCoroutine ()\nstartMoveSelect cid pnum geometry ((x, y), ctime) tpage = do\n  cache <- renderCache\n  itmimage <- liftIO $ mkItmsNImg cache cid tpage\n  tsel <- createTempRender geometry itmimage\n  moveSelect cid pnum geometry (x, y) ((x, y), ctime) tsel\n  Cairo.surfaceFinish (tempSurfaceSrc tsel)\n  Cairo.surfaceFinish (tempSurfaceTgt tsel)\n  Cairo.surfaceFinish (imageSurface itmimage)\n  invalidateAllInBBox Nothing Efficient\n\n-- |\nmoveSelect ::\n  CanvasId ->\n  -- | starting pagenum\n  PageNum ->\n  CanvasGeometry ->\n  (Double, Double) ->\n  ((Double, Double), UTCTime) ->\n  TempRender ItmsNImg ->\n  MainCoroutine ()\nmoveSelect\n  cid\n  pnum\n  geometry\n  orig@(x0, y0)\n  (prev, otime)\n  tempselection = do\n    xst <- get\n    let uhdl = view (unitHoodles . currentUnit) xst\n    r <- nextevent\n    forBoth\' unboxBiAct (fsingle r uhdl) (getCanvasInfo cid uhdl)\n    where\n      fsingle r uhdl cinfo =\n        penMoveAndUpInterPage r pnum geometry defact moveact (upact uhdl cinfo)\n      defact = moveSelect cid pnum geometry orig (prev, otime) tempselection\n      moveact oldpgn pcpair@(newpgn, PageCoord (px, py)) = do\n        let (x, y)\n              | oldpgn == newpgn = (px, py)\n              | otherwise =\n                let DeskCoord (xo, yo) = page2Desktop geometry (oldpgn, PageCoord (0, 0))\n                    DeskCoord (xn, yn) = page2Desktop geometry pcpair\n                 in (xn - xo, yn - yo)\n        (willUpdate, (ncoord, ntime)) <- liftIO $ getNewCoordTime (prev, otime) (x, y)\n        when willUpdate $ do\n          let sfunc = offsetFunc (x - x0, y - y0)\n              xform =\n                unCvsCoord . desktop2Canvas geometry\n                  . page2Desktop geometry\n                  . (,) pnum\n                  . PageCoord\n              (c1, c2) = xform (sfunc (0, 0))\n              (a1\', a2\') = xform (sfunc (1, 0))\n              (a1, a2) = (a1\' - c1, a2\' - c2)\n              (b1\', b2\') = xform (sfunc (0, 1))\n              (b1, b2) = (b1\' - c1, b2\' - c2)\n              xformmat = Mat.Matrix a1 a2 b1 b2 c1 c2\n          invalidateTempBasePage\n            cid\n            (tempSurfaceSrc tempselection)\n            pnum\n            (drawTempSelectImage geometry tempselection xformmat)\n        moveSelect cid pnum geometry orig (ncoord, ntime) tempselection\n      upact :: UnitHoodle -> CanvasInfo a -> PointerCoord -> MainCoroutine ()\n      upact uhdl cinfo pcoord =\n        switchActionEnteringDiffPage\n          pnum\n          geometry\n          pcoord\n          (return ())\n          (chgaction uhdl cinfo)\n          (ordaction uhdl cinfo)\n      chgaction ::\n        UnitHoodle ->\n        CanvasInfo a ->\n        PageNum ->\n        (PageNum, PageCoordinate) ->\n        MainCoroutine ()\n      chgaction uhdl cinfo oldpgn (newpgn, PageCoord (x, y)) = do\n        let hdlmodst@(SelectState thdl) = view hoodleModeState uhdl\n            epage = getCurrentPageEitherFromHoodleModeState cinfo hdlmodst\n            cvsid = view canvasId cinfo\n        (uhdl1, nthdl1, selecteditms) <-\n          case epage of\n            Right oldtpage -> do\n              let itms = getSelectedItms oldtpage\n              let oldtpage\' = deleteSelected oldtpage\n              nthdl <- updateTempHoodleSelectM cvsid thdl oldtpage\' (unPageNum oldpgn)\n              uhdl\' <- liftIO (updatePageAll (SelectState nthdl) uhdl)\n              return (uhdl\', nthdl, itms)\n            Left _ -> error "this is impossible, in moveSelect"\n        let maction = do\n              page <- M.lookup (unPageNum newpgn) (view gselAll nthdl1)\n              let currlayer = getCurrentLayer page\n              let olditms = view gitems currlayer\n              let newitms = map (changeItemBy (offsetFunc (x - x0, y - y0))) selecteditms\n                  alist = olditms :- Hitted newitms :- Empty\n                  ntpage = makePageSelectMode page alist\n                  coroutineaction = do\n                    nthdl2 <- updateTempHoodleSelectM cvsid nthdl1 ntpage (unPageNum newpgn)\n                    liftIO (updatePageAll (SelectState nthdl2) uhdl1)\n              return coroutineaction\n        uhdl2 <- Maybe.fromMaybe (return uhdl1) maction\n        pureUpdateUhdl (const uhdl2)\n        commit_\n        invalidateAllInBBox Nothing Efficient\n      ----\n      ordaction uhdl cinfo _pgn (_cpn, PageCoord (x, y)) = do\n        let offset = (x - x0, y - y0)\n            hdlmodst@(SelectState thdl) = view hoodleModeState uhdl\n            epage = getCurrentPageEitherFromHoodleModeState cinfo hdlmodst\n            pagenum = view currentPageNum cinfo\n            cvsid = view canvasId cinfo\n        case epage of\n          Right tpage -> do\n            let newtpage = changeSelectionByOffset offset tpage\n            newthdl <- updateTempHoodleSelectM cvsid thdl newtpage pagenum\n            uhdl\' <- liftIO (updatePageAll (SelectState newthdl) uhdl)\n            pureUpdateUhdl (const uhdl\')\n            commit_\n          Left _ -> error "this is impossible, in moveSelect"\n        invalidateAllInBBox Nothing Efficient\n\n-- | prepare for resizing selection\nstartResizeSelect ::\n  -- | doesKeepRatio\n  Bool ->\n  -- | current selection handle\n  Handle ->\n  CanvasId ->\n  PageNum ->\n  CanvasGeometry ->\n  BBox ->\n  ((Double, Double), UTCTime) ->\n  Page SelectMode ->\n  MainCoroutine ()\nstartResizeSelect\n  doesKeepRatio\n  handle\n  cid\n  pnum\n  geometry\n  bbox\n  ((x, y), ctime)\n  tpage = do\n    cache <- renderCache\n    itmimage <- liftIO $ mkItmsNImg cache cid tpage\n    tsel <- createTempRender geometry itmimage\n    resizeSelect\n      doesKeepRatio\n      handle\n      cid\n      pnum\n      geometry\n      bbox\n      ((x, y), ctime)\n      tsel\n    Cairo.surfaceFinish (tempSurfaceSrc tsel)\n    Cairo.surfaceFinish (tempSurfaceTgt tsel)\n    Cairo.surfaceFinish (imageSurface itmimage)\n    invalidateAllInBBox Nothing Efficient\n\n-- |\nresizeSelect ::\n  -- | doesKeepRatio\n  Bool ->\n  -- | current selection handle\n  Handle ->\n  CanvasId ->\n  PageNum ->\n  CanvasGeometry ->\n  BBox ->\n  ((Double, Double), UTCTime) ->\n  TempRender ItmsNImg ->\n  MainCoroutine ()\nresizeSelect\n  doesKeepRatio\n  handle\n  cid\n  pnum\n  geometry\n  origbbox\n  (prev, otime)\n  tempselection = do\n    xst <- get\n    let uhdl = view (unitHoodles . currentUnit) xst\n    r <- nextevent\n    forBoth\' unboxBiAct (fsingle r uhdl) . getCanvasInfo cid $ uhdl\n    where\n      fsingle r uhdl cinfo = penMoveAndUpOnly r pnum geometry defact moveact (upact uhdl cinfo)\n      defact = resizeSelect doesKeepRatio handle cid pnum geometry origbbox (prev, otime) tempselection\n      moveact (_pcoord, (x, y)) = do\n        (willUpdate, (ncoord, ntime)) <- liftIO $ getNewCoordTime (prev, otime) (x, y)\n        when willUpdate $ do\n          let newbbox\' = getNewBBoxFromHandlePos handle origbbox (x, y)\n              newbbox =\n                if doesKeepRatio\n                  then\n                    let BBox (xo0, yo0) (xo1, yo1) = origbbox\n                        BBox (x0, y0) (x1, y1) = newbbox\'\n                        r = (yo1 - yo0) / (xo1 - xo0)\n                     in if\n                            | xo1 == xo0 -> newbbox\'\n                            | handle == HandleTL -> BBox (x0, y1 + (x0 - x1) * r) (x1, y1)\n                            | handle == HandleTR -> BBox (x0, y1 + (x0 - x1) * r) (x1, y1)\n                            | handle == HandleBL -> BBox (x0, y0) (x1, y0 + (x1 - x0) * r)\n                            | handle == HandleBR -> BBox (x0, y0) (x1, y0 + (x1 - x0) * r)\n                            | otherwise -> newbbox\'\n                  else newbbox\'\n              sfunc = scaleFromToBBox origbbox newbbox\n              xform = unCvsCoord . desktop2Canvas geometry . page2Desktop geometry . (,) pnum . PageCoord\n              (c1, c2) = xform (sfunc (0, 0))\n              (a1\', a2\') = xform (sfunc (1, 0))\n              (a1, a2) = (a1\' - c1, a2\' - c2)\n              (b1\', b2\') = xform (sfunc (0, 1))\n              (b1, b2) = (b1\' - c1, b2\' - c2)\n              xformmat = Mat.Matrix a1 a2 b1 b2 c1 c2\n          invalidateTemp cid (tempSurfaceSrc tempselection) (drawTempSelectImage geometry tempselection xformmat)\n        resizeSelect doesKeepRatio handle cid pnum geometry origbbox (ncoord, ntime) tempselection\n      upact uhdl cinfo pcoord = do\n        let (_, (x, y)) =\n              runIdentity $\n                skipIfNotInSamePage\n                  pnum\n                  geometry\n                  pcoord\n                  (return (pcoord, prev))\n                  return\n            newbbox\' = getNewBBoxFromHandlePos handle origbbox (x, y)\n            newbbox =\n              if doesKeepRatio\n                then\n                  let BBox (xo0, yo0) (xo1, yo1) = origbbox\n                      BBox (x0, y0) (x1, y1) = newbbox\'\n                      r = (yo1 - yo0) / (xo1 - xo0)\n                   in if\n                          | xo1 == xo0 || yo1 == yo0 -> newbbox\'\n                          | handle == HandleTL -> BBox (x0, y1 + (x0 - x1) * r) (x1, y1)\n                          | handle == HandleTR -> BBox (x0, y1 + (x0 - x1) * r) (x1, y1)\n                          | handle == HandleBL -> BBox (x0, y0) (x1, y0 + (x1 - x0) * r)\n                          | handle == HandleBR -> BBox (x0, y0) (x1, y0 + (x1 - x0) * r)\n                          | otherwise -> newbbox\'\n                else newbbox\'\n            hdlmodst@(SelectState thdl) = view hoodleModeState uhdl\n            epage = getCurrentPageEitherFromHoodleModeState cinfo hdlmodst\n            pagenum = view currentPageNum cinfo\n            cvsid = view canvasId cinfo\n        case epage of\n          Right tpage -> do\n            let sfunc = scaleFromToBBox origbbox newbbox\n                newtpage = changeSelectionBy sfunc tpage\n            newthdl <- updateTempHoodleSelectM cvsid thdl newtpage pagenum\n            uhdl\' <- liftIO (updatePageAll (SelectState newthdl) uhdl)\n            pureUpdateUhdl (const uhdl\')\n            commit_\n          Left _ -> error "this is impossible, in resizeSelect"\n        invalidateAllInBBox Nothing Efficient\n        return ()\n\n-- |\nselectPenColorChanged :: PenColor -> MainCoroutine ()\nselectPenColorChanged pcolor = do\n  uhdl <- gets (view (unitHoodles . currentUnit))\n  let cid = getCurrentCanvasId uhdl\n      SelectState thdl = view hoodleModeState uhdl\n      Just (n, tpage) = view gselSelected thdl\n      slayer = view (glayers . selectedLayer) tpage\n  case unTEitherAlterHitted . view gitems $ slayer of\n    Left _ -> return ()\n    Right alist -> do\n      let alist\' = second (Hitted . map (changeItemStrokeColor pcolor) . unHitted) alist\n          newlayer = Right alist\'\n          newpage = (glayers . selectedLayer .~ GLayer (slayer ^. gbuffer) (TEitherAlterHitted newlayer)) tpage\n      newthdl <- updateTempHoodleSelectM cid thdl newpage n\n      uhdl\' <- liftIO (updatePageAll (SelectState newthdl) uhdl)\n      pureUpdateUhdl (const uhdl\')\n      commit_\n      invalidateAllInBBox Nothing Efficient\n\n-- |\nselectPenWidthChanged :: Double -> MainCoroutine ()\nselectPenWidthChanged pwidth = do\n  xst <- get\n  let uhdl = view (unitHoodles . currentUnit) xst\n      cid = getCurrentCanvasId uhdl\n      SelectState thdl = view hoodleModeState uhdl\n      Just (n, tpage) = view gselSelected thdl\n      slayer = view (glayers . selectedLayer) tpage\n  case (unTEitherAlterHitted . view gitems) slayer of\n    Left _ -> return ()\n    Right alist -> do\n      let alist\' = second (Hitted . map (changeItemStrokeWidth pwidth) . unHitted) alist\n          newlayer = Right alist\'\n          newpage = set (glayers . selectedLayer) (GLayer (view gbuffer slayer) (TEitherAlterHitted newlayer)) tpage\n      newthdl <- updateTempHoodleSelectM cid thdl newpage n\n      uhdl\' <- liftIO (updatePageAll (SelectState newthdl) uhdl)\n      pureUpdateUhdl (const uhdl\')\n      commit_\n      invalidateAllInBBox Nothing Efficient\n\n-- | main mouse pointer click entrance in lasso selection mode.\n--   choose either starting new rectangular selection or move previously\n--   selected selection.\nselectLassoStart :: PenButton -> CanvasId -> PointerCoord -> MainCoroutine ()\nselectLassoStart p cid coord = void (commonSelectStart SelectLassoWork p cid coord)\n\n-- |\nnewSelectLasso ::\n  CanvasInfo a ->\n  PageNum ->\n  CanvasGeometry ->\n  [RItem] ->\n  (Double, Double) ->\n  ((Double, Double), UTCTime) ->\n  Seq (Double, Double) ->\n  TempSelection ->\n  MainCoroutine ()\nnewSelectLasso cvsInfo pnum geometry itms orig (prev, otime) lasso tsel = nextevent >>= flip fsingle cvsInfo\n  where\n    fsingle r cinfo = penMoveAndUpOnly r pnum geometry defact (moveact cinfo) (upact cinfo)\n    defact =\n      newSelectLasso\n        cvsInfo\n        pnum\n        geometry\n        itms\n        orig\n        (prev, otime)\n        lasso\n        tsel\n    moveact cinfo (_pcoord, (x, y)) = do\n      let nlasso = lasso |> (x, y)\n      (willUpdate, (ncoord, ntime)) <- liftIO $ getNewCoordTime (prev, otime) (x, y)\n      when willUpdate $ invalidateTemp (view canvasId cinfo) (tempSurfaceSrc tsel) (renderLasso geometry nlasso)\n      newSelectLasso cinfo pnum geometry itms orig (ncoord, ntime) nlasso tsel\n    upact cinfo pcoord = do\n      uhdl <- gets (view (unitHoodles . currentUnit))\n      let (_, (x, y)) = runIdentity $ skipIfNotInSamePage pnum geometry pcoord (return (pcoord, prev)) return\n          nlasso = lasso |> (x, y)\n          hdlmodst = view hoodleModeState uhdl\n          epage = getCurrentPageEitherFromHoodleModeState cinfo hdlmodst\n          cpn = view currentPageNum cinfo\n          hittestlasso1 = hltFilteredBy (hitLassoItem (nlasso |> orig)) itms\n          selectitms1 = first unNotHitted hittestlasso1\n          selecteditms1 = (concatMap unHitted . getB) selectitms1\n          hittestlasso2 = takeLastFromHitted . flip hltFilteredBy itms $\n            \\itm ->\n              (not . isStrkInRItem) itm\n                && isPointInBBox (getBBox itm) (x, y)\n          selectitms2 = first unNotHitted hittestlasso2\n          selectitms\n            | (not . null) selecteditms1 = selectitms1\n            | otherwise = selectitms2\n          SelectState thdl = view hoodleModeState uhdl\n          newpage = case epage of\n            Left pagebbox ->\n              let currlayer = getCurrentLayer pagebbox\n                  newlayer = GLayer (view gbuffer currlayer) (TEitherAlterHitted (Right selectitms))\n                  tpg = mkHPage pagebbox\n                  npg = set (glayers . selectedLayer) newlayer tpg\n               in npg\n            Right tpage ->\n              let currlayer = view (glayers . selectedLayer) tpage\n                  newlayer = GLayer (view gbuffer currlayer) (TEitherAlterHitted (Right selectitms))\n                  npage = set (glayers . selectedLayer) newlayer tpage\n               in npage\n          newthdl = set gselSelected (Just (cpn, newpage)) thdl\n      ui <- gets (view gtkUIManager)\n      liftIO $ toggleCutCopyDelete ui (isAnyHitted selectitms)\n      uhdl\' <- liftIO (updatePageAll (SelectState newthdl) uhdl)\n      pureUpdateUhdl (const ((hoodleModeState .~ SelectState newthdl) uhdl\'))\n      commit_\n      invalidateAllInBBox Nothing Efficient\n'