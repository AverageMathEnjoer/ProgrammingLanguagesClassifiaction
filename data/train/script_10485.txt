b'{-# LANGUAGE CPP #-}\nmodule Main where\n\nimport Control.DeepSeq (NFData, rnf)\nimport Control.Exception (evaluate)\nimport Data.Coerce (coerce)\nimport Data.Foldable (fold, foldl\', toList)\nimport Data.Monoid (All(..))\n#if MIN_VERSION_base(4,18,0)\nimport Data.Monoid (Sum(..))\nimport qualified Data.Foldable1 as Foldable1\n#endif\nimport Test.Tasty.Bench (Benchmark, Benchmarkable, bench, bgroup, defaultMain, whnf, nf)\nimport qualified Data.Tree as T\n\nmain :: IO ()\nmain = do\n  evaluate $ rnf ts `seq` rnf tsBool\n  defaultMain\n    [ bgroup "Foldable"\n      [ bgroup "fold" $ forTs tsBool $ whnf fold . (coerce :: T.Tree Bool -> T.Tree All)\n      , bgroup "foldMap" $ forTs tsBool $ whnf (foldMap All)\n      , bgroup "foldr_1" $ forTs tsBool $ whnf (foldr (&&) True)\n      , bgroup "foldr_2" $ forTs ts $ whnf (length . foldr (:) [])\n      , bgroup "foldr_3" $ forTs ts $ whnf (\\t -> foldr (\\x k acc -> if acc < 0 then acc else k $! acc + x) id t 0)\n      , bgroup "foldl\'" $ forTs ts $ whnf (foldl\' (+) 0)\n      , bgroup "foldr1" $ forTs tsBool $ whnf (foldr1 (&&))\n      , bgroup "foldl1" $ forTs ts $ whnf (foldl1 (+))\n      , bgroup "toList" $ forTs ts $ nf toList\n      , bgroup "elem" $ forTs ts $ whnf (elem 0)\n      , bgroup "maximum" $ forTs ts $ whnf maximum\n      , bgroup "sum" $ forTs ts $ whnf sum\n      ]\n#if MIN_VERSION_base(4,18,0)\n    , bgroup "Foldable1"\n      [ bgroup "fold1" $ forTs tsBool $ whnf Foldable1.fold1 . (coerce :: T.Tree Bool -> T.Tree All)\n      , bgroup "foldMap1" $ forTs tsBool $ whnf (Foldable1.foldMap1 All)\n      , bgroup "foldMap1\'" $ forTs ts $ whnf (Foldable1.foldMap1\' Sum)\n      , bgroup "toNonEmpty" $ forTs ts $ nf Foldable1.toNonEmpty\n      , bgroup "maximum" $ forTs ts $ whnf Foldable1.maximum\n      , bgroup "last" $ forTs ts $ whnf Foldable1.last\n      , bgroup "foldrMap1_1" $ forTs tsBool $ whnf (Foldable1.foldrMap1 id (&&))\n      , bgroup "foldrMap1_2" $ forTs ts $ whnf (length . Foldable1.foldrMap1 (:[]) (:))\n      , bgroup "foldlMap1\'" $ forTs ts $ whnf (Foldable1.foldlMap1\' id (+))\n      , bgroup "foldlMap1" $ forTs ts $ whnf (Foldable1.foldlMap1 id (+))\n      ]\n#endif\n    ]\n  where\n    ts = [binaryTree, lineTree] <*> [1000, 1000000]\n    tsBool = [t { getT = True <$ getT t } | t <- ts]\n\nforTs :: [Tree a] -> (T.Tree a -> Benchmarkable) -> [Benchmark]\nforTs ts f = [bench label (f t) | Tree label t <- ts]\n\ndata Tree a = Tree\n  { getLabel :: String\n  , getT :: T.Tree a\n  }\n\ninstance NFData a => NFData (Tree a) where\n  rnf (Tree label t) = rnf label `seq` rnf t\n\nbinaryTree :: Int -> Tree Int\nbinaryTree n = Tree label t\n  where\n    label = "bin,n=" ++ show n\n    t = T.unfoldTree (\\x -> (x, takeWhile (<=n) [2*x, 2*x+1])) 1\n\nlineTree :: Int -> Tree Int\nlineTree n = Tree label t\n  where\n    label = "line,n=" ++ show n\n    t = T.unfoldTree (\\x -> (x, [x+1 | x+1 <= n])) 1\n'