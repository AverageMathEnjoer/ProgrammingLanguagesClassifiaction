b'{-# LANGUAGE CPP #-}\nmodule IntSetValidity (valid) where\n\nimport Data.Bits (xor, (.&.))\nimport Data.IntSet.Internal\nimport Test.Tasty.QuickCheck (Property, counterexample, property, (.&&.))\nimport Utils.Containers.Internal.BitUtil (bitcount)\n\n{--------------------------------------------------------------------\n  Assertions\n--------------------------------------------------------------------}\n-- | Returns true iff the internal structure of the IntSet is valid.\nvalid :: IntSet -> Property\nvalid t =\n  counterexample "nilNeverChildOfBin" (nilNeverChildOfBin t) .&&.\n  counterexample "maskPowerOfTwo" (maskPowerOfTwo t) .&&.\n  counterexample "commonPrefix" (commonPrefix t) .&&.\n  counterexample "markRespected" (maskRespected t) .&&.\n  counterexample "tipsValid" (tipsValid t)\n\n-- Invariant: Nil is never found as a child of Bin.\nnilNeverChildOfBin :: IntSet -> Bool\nnilNeverChildOfBin t =\n  case t of\n    Nil -> True\n    Tip _ _ -> True\n    Bin _ _ l r -> noNilInSet l && noNilInSet r\n  where\n    noNilInSet t\' =\n      case t\' of\n        Nil -> False\n        Tip _ _ -> True\n        Bin _ _ l\' r\' -> noNilInSet l\' && noNilInSet r\'\n\n-- Invariant: The Mask is a power of 2.  It is the largest bit position at which\n--            two elements of the set differ.\nmaskPowerOfTwo :: IntSet -> Bool\nmaskPowerOfTwo t =\n  case t of\n    Nil -> True\n    Tip _ _ -> True\n    Bin _ m l r ->\n      bitcount 0 (fromIntegral m) == 1 && maskPowerOfTwo l && maskPowerOfTwo r\n\n-- Invariant: Prefix is the common high-order bits that all elements share to\n--            the left of the Mask bit.\ncommonPrefix :: IntSet -> Bool\ncommonPrefix t =\n  case t of\n    Nil -> True\n    Tip _ _ -> True\n    b@(Bin p _ l r) -> all (sharedPrefix p) (elems b) && commonPrefix l && commonPrefix r\n  where\n    sharedPrefix :: Prefix -> Int -> Bool\n    sharedPrefix p a = p == p .&. a\n\n-- Invariant: In Bin prefix mask left right, left consists of the elements that\n--            don\'t have the mask bit set; right is all the elements that do.\nmaskRespected :: IntSet -> Bool\nmaskRespected t =\n  case t of\n    Nil -> True\n    Tip _ _ -> True\n    Bin _ binMask l r ->\n      all (\\x -> zero x binMask) (elems l) &&\n      all (\\x -> not (zero x binMask)) (elems r) &&\n      maskRespected l &&\n      maskRespected r\n\n-- Invariant: The Prefix is zero for the last 5 (on 32 bit arches) or 6 bits\n--            (on 64 bit arches). The values of the set represented by a tip\n--            are the prefix plus the indices of the set bits in the bit map.\n--\n-- Note: Valid entries stored in tip omitted.\ntipsValid :: IntSet -> Bool\ntipsValid t =\n  case t of\n    Nil -> True\n    tip@(Tip p b) -> validTipPrefix p\n    Bin _ _ l r -> tipsValid l && tipsValid r\n\nvalidTipPrefix :: Prefix -> Bool\n#if WORD_SIZE_IN_BITS==32\n-- Last 5 bits of the prefix must be zero for 32 bit arches.\nvalidTipPrefix p = (0x0000001F .&. p) == 0\n#else\n-- Last 6 bits of the prefix must be zero for 64 bit arches.\nvalidTipPrefix p = (0x000000000000003F .&. p) == 0\n#endif\n'