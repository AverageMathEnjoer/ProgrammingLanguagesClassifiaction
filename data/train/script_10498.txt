b'// I2Cdev library collection - DS1307 I2C device class\n// Based on Maxim DS1307 datasheet, 2008\n// 11/13/2011 by Jeff Rowberg <jeff@rowberg.net>\n// Updates should (hopefully) always be available at https://github.com/jrowberg/i2cdevlib\n// I2C Device Library hosted at http://www.i2cdevlib.com\n//\n// Changelog:\n//     2011-11-13 - initial release\n//     2012-03-29 - alain.spineux@gmail.com: bug in getHours24() \n//                  am/pm is bit 0x20 instead of 0x80\n//\n\n/* ============================================\nI2Cdev device library code is placed under the MIT license\nCopyright (c) 2011 Jeff Rowberg\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the "Software"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n===============================================\n*/\n\n#include "DS1307.h"\n\n/** Default constructor, uses default I2C address.\n * @see DS1307_DEFAULT_ADDRESS\n */\nDS1307::DS1307() {\n    devAddr = DS1307_DEFAULT_ADDRESS;\n}\n\n/** Specific address constructor.\n * @param address I2C address\n * @see DS1307_DEFAULT_ADDRESS\n * @see DS1307_ADDRESS\n */\nDS1307::DS1307(uint8_t address) {\n    devAddr = address;\n}\n\n/** Power on and prepare for general usage.\n * This method reads the current 12/24-hour mode setting into the locally stored\n * variable so that it isn\'t accidentally changed by the setHour*() methods.\n */\nvoid DS1307::initialize() {\n    getMode(); // automatically sets internal "mode12" member variable\n    getClockRunning(); // automatically sets internal "clockHalt" member variable\n}\n\n/** Verify the I2C connection.\n * Make sure the device is connected and responds as expected.\n * @return True if connection is valid, false otherwise\n */\nbool DS1307::testConnection() {\n    if (I2Cdev::readByte(devAddr, DS1307_RA_SECONDS, buffer) == 1) {\n        return true;\n    }\n    return false;\n}\n\n// SECONDS register\nbool DS1307::getClockRunning() {\n    I2Cdev::readBit(devAddr, DS1307_RA_SECONDS, DS1307_SECONDS_CH_BIT, buffer);\n    clockHalt = buffer[0];\n    return !buffer[0];\n}\nvoid DS1307::setClockRunning(bool running) {\n    I2Cdev::writeBit(devAddr, DS1307_RA_SECONDS, DS1307_SECONDS_CH_BIT, !running);\n}\nuint8_t DS1307::getSeconds() {\n    // Byte: [7 = CH] [6:4 = 10SEC] [3:0 = 1SEC]\n    I2Cdev::readByte(devAddr, DS1307_RA_SECONDS, buffer);\n    clockHalt = buffer[0] & 0x80;\n    return (buffer[0] & 0x0F) + ((buffer[0] & 0x70) >> 4) * 10;\n}\nvoid DS1307::setSeconds(uint8_t seconds) {\n    if (seconds > 59) return;\n    uint8_t value = (clockHalt ? 0x80 : 0x00) + ((seconds / 10) << 4) + (seconds % 10);\n    I2Cdev::writeByte(devAddr, DS1307_RA_SECONDS, value);\n}\n\n// MINUTES register\nuint8_t DS1307::getMinutes() {\n    // Byte: [7 = 0] [6:4 = 10MIN] [3:0 = 1MIN]\n    I2Cdev::readByte(devAddr, DS1307_RA_MINUTES, buffer);\n    return (buffer[0] & 0x0F) + ((buffer[0] & 0x70) >> 4) * 10;\n}\nvoid DS1307::setMinutes(uint8_t minutes) {\n    if (minutes > 59) return;\n    uint8_t value = ((minutes / 10) << 4) + (minutes % 10);\n    I2Cdev::writeByte(devAddr, DS1307_RA_MINUTES, value);\n}\n\n// HOURS register\nuint8_t DS1307::getMode() {\n    I2Cdev::readBit(devAddr, DS1307_RA_HOURS, DS1307_HOURS_MODE_BIT, buffer);\n    mode12 = buffer[0];\n    return buffer[0];\n}\nvoid DS1307::setMode(uint8_t mode) {\n    I2Cdev::writeBit(devAddr, DS1307_RA_HOURS, DS1307_HOURS_MODE_BIT, mode);\n}\nuint8_t DS1307::getAMPM() {\n    I2Cdev::readBit(devAddr, DS1307_RA_HOURS, DS1307_HOURS_AMPM_BIT, buffer);\n    return buffer[0];\n}\nvoid DS1307::setAMPM(uint8_t ampm) {\n    I2Cdev::writeBit(devAddr, DS1307_RA_HOURS, DS1307_HOURS_AMPM_BIT, ampm);\n}\nuint8_t DS1307::getHours12() {\n    I2Cdev::readByte(devAddr, DS1307_RA_HOURS, buffer);\n    mode12 = buffer[0] & 0x40;\n    if (mode12) {\n        // bit 6 is high, 12-hour mode\n        // Byte: [5 = AM/PM] [4 = 10HR] [3:0 = 1HR]\n        return (buffer[0] & 0x0F) + ((buffer[0] & 0x10) >> 4) * 10;\n    } else {\n        // bit 6 is low, 24-hour mode (default)\n        // Byte: [5:4 = 10HR] [3:0 = 1HR]\n        uint8_t hours = (buffer[0] & 0x0F) + ((buffer[0] & 0x30) >> 4) * 10;\n\n        // convert 24-hour to 12-hour format, since that\'s what\'s requested\n        if (hours > 12) hours -= 12;\n        else if (hours == 0) hours = 12;\n        return hours;\n    }\n}\nvoid DS1307::setHours12(uint8_t hours, uint8_t ampm) {\n    if (hours > 12 || hours < 1) return;\n    if (mode12) {\n        // bit 6 is high, 12-hour mode\n        // Byte: [5 = AM/PM] [4 = 10HR] [3:0 = 1HR]\n        if (ampm > 0) ampm = 0x20;\n        uint8_t value = 0x40 + ampm + ((hours / 10) << 4) + (hours % 10);\n        I2Cdev::writeByte(devAddr, DS1307_RA_HOURS, value);\n    } else {\n        // bit 6 is low, 24-hour mode (default)\n        // Byte: [5:4 = 10HR] [3:0 = 1HR]\n        if (ampm > 0) hours += 12;\n        if (hours == 0) hours = 12; // 12 AM\n        else if (hours == 24) hours = 12; // 12 PM, after +12 adjustment\n        uint8_t value = ((hours / 10) << 4) + (hours % 10);\n        I2Cdev::writeByte(devAddr, DS1307_RA_HOURS, value);\n    }\n}\nuint8_t DS1307::getHours24() {\n    I2Cdev::readByte(devAddr, DS1307_RA_HOURS, buffer);\n    mode12 = buffer[0] & 0x40;\n    if (mode12) {\n        // bit 6 is high, 12-hour mode\n        // Byte: [5 = AM/PM] [4 = 10HR] [3:0 = 1HR]\n        uint8_t hours = (buffer[0] & 0x0F) + ((buffer[0] & 0x10) >> 4) * 10;\n\n        // convert 12-hour to 24-hour format, since that\'s what\'s requested\n        if (buffer[0] & 0x20) {\n            // currently PM\n            if (hours < 12) hours += 12;\n        } else {\n            // currently AM\n            if (hours == 12) hours = 0;\n        }\n        return hours;\n    } else {\n        // bit 6 is low, 24-hour mode (default)\n        // Byte: [5:4 = 10HR] [3:0 = 1HR]\n        return (buffer[0] & 0x0F) + ((buffer[0] & 0x30) >> 4) * 10;\n    }\n}\nvoid DS1307::setHours24(uint8_t hours) {\n    if (hours > 23) return;\n    if (mode12) {\n        // bit 6 is high, 12-hour mode\n        // Byte: [5 = AM/PM] [4 = 10HR] [3:0 = 1HR]\n        uint8_t ampm = 0;\n        if (hours > 11) ampm = 0x20;\n        if (hours > 12) hours -= 12;\n        else if (hours == 0) hours = 12;\n        uint8_t value = 0x40 + ampm + ((hours / 10) << 4) + (hours % 10);\n        I2Cdev::writeByte(devAddr, DS1307_RA_HOURS, value);\n    } else {\n        // bit 6 is low, 24-hour mode (default)\n        // Byte: [5:4 = 10HR] [3:0 = 1HR]\n        uint8_t value = ((hours / 10) << 4) + (hours % 10);\n        I2Cdev::writeByte(devAddr, DS1307_RA_HOURS, value);\n    }\n}\n\n// DAY register\nuint8_t DS1307::getDayOfWeek() {\n    I2Cdev::readBits(devAddr, DS1307_RA_DAY, DS1307_DAY_BIT, DS1307_DAY_LENGTH, buffer);\n    return buffer[0];\n}\nvoid DS1307::setDayOfWeek(uint8_t dow) {\n    if (dow < 1 || dow > 7) return;\n    I2Cdev::writeBits(devAddr, DS1307_RA_DAY, DS1307_DAY_BIT, DS1307_DAY_LENGTH, dow);\n}\n\n// DATE register\nuint8_t DS1307::getDay() {\n    // Byte: [7:6 = 0] [5:4 = 10DAY] [3:0 = 1DAY]\n    I2Cdev::readByte(devAddr, DS1307_RA_DATE, buffer);\n    return (buffer[0] & 0x0F) + ((buffer[0] & 0x30) >> 4) * 10;\n}\nvoid DS1307::setDay(uint8_t day) {\n    uint8_t value = ((day / 10) << 4) + (day % 10);\n    I2Cdev::writeByte(devAddr, DS1307_RA_DATE, value);\n}\n\n// MONTH register\nuint8_t DS1307::getMonth() {\n    // Byte: [7:5 = 0] [4 = 10MONTH] [3:0 = 1MONTH]\n    I2Cdev::readByte(devAddr, DS1307_RA_MONTH, buffer);\n    return (buffer[0] & 0x0F) + ((buffer[0] & 0x10) >> 4) * 10;\n}\nvoid DS1307::setMonth(uint8_t month) {\n    if (month < 1 || month > 12) return;\n    uint8_t value = ((month / 10) << 4) + (month % 10);\n    I2Cdev::writeByte(devAddr, DS1307_RA_MONTH, value);\n}\n\n// YEAR register\nuint16_t DS1307::getYear() {\n    I2Cdev::readByte(devAddr, DS1307_RA_YEAR, buffer);\n    return 2000 + (buffer[0] & 0x0F) + ((buffer[0] & 0xF0) >> 4) * 10;\n}\nvoid DS1307::setYear(uint16_t year) {\n    if (year < 2000) return;\n    year -= 2000;\n    uint8_t value = ((year / 10) << 4) + (year % 10);\n    I2Cdev::writeByte(devAddr, DS1307_RA_YEAR, value);\n}\n\n// CONTROL register\nbool DS1307::getFixedOutputLevel() {\n    I2Cdev::readBit(devAddr, DS1307_RA_CONTROL, DS1307_CONTROL_OUT_BIT, buffer);\n    return buffer[0];\n}\nvoid DS1307::setFixedOutputLevel(bool level) {\n    I2Cdev::writeBit(devAddr, DS1307_RA_CONTROL, DS1307_CONTROL_OUT_BIT, level);\n}\nbool DS1307::getSquareWaveEnabled() {\n    I2Cdev::readBit(devAddr, DS1307_RA_CONTROL, DS1307_CONTROL_SQWE_BIT, buffer);\n    return buffer[0];\n}\nvoid DS1307::setSquareWaveEnabled(bool enabled) {\n    I2Cdev::writeBit(devAddr, DS1307_RA_CONTROL, DS1307_CONTROL_SQWE_BIT, enabled);\n}\nuint8_t DS1307::getSquareWaveRate() {\n    I2Cdev::readBits(devAddr, DS1307_RA_CONTROL, DS1307_CONTROL_RS_BIT, DS1307_CONTROL_RS_LENGTH, buffer);\n    return buffer[0];\n}\nvoid DS1307::setSquareWaveRate(uint8_t rate) {\n    I2Cdev::writeBits(devAddr, DS1307_RA_CONTROL, DS1307_CONTROL_RS_BIT, DS1307_CONTROL_RS_LENGTH, rate);\n}\n\n// RAM registers\nuint8_t DS1307::getMemoryByte(uint8_t offset) {\n    if (offset > 55) return 0;\n    I2Cdev::readByte(devAddr, DS1307_RA_RAM + offset, buffer);\n    return buffer[0];\n}\nvoid DS1307::setMemoryByte(uint8_t offset, uint8_t value) {\n    if (offset > 55) return;\n    I2Cdev::writeByte(devAddr, DS1307_RA_RAM + offset, value);\n}\n\n// convenience methods\n\nvoid DS1307::getDate(uint16_t *year, uint8_t *month, uint8_t *day) {\n    *year = getYear();\n    *month = getMonth();\n    *day = getDay();\n}\nvoid DS1307::setDate(uint16_t year, uint8_t month, uint8_t day) {\n    setYear(year);\n    setMonth(month);\n    setDay(day);\n}\n\nvoid DS1307::getTime12(uint8_t *hours, uint8_t *minutes, uint8_t *seconds, uint8_t *ampm) {\n    *hours = getHours12();\n    *minutes = getMinutes();\n    *seconds = getSeconds();\n    *ampm = getAMPM();\n}\nvoid DS1307::setTime12(uint8_t hours, uint8_t minutes, uint8_t seconds, uint8_t ampm) {\n    // write seconds first to reset divider chain and give\n    // us 1 second to write remaining time info\n    setSeconds(seconds);\n    setMinutes(minutes);\n    setHours12(hours, ampm);\n}\n\nvoid DS1307::getTime24(uint8_t *hours, uint8_t *minutes, uint8_t *seconds) {\n    *hours = getHours24();\n    *minutes = getMinutes();\n    *seconds = getSeconds();\n}\nvoid DS1307::setTime24(uint8_t hours, uint8_t minutes, uint8_t seconds) {\n    // write seconds first to reset divider chain and give\n    // us 1 second to write remaining time info\n    setSeconds(seconds);\n    setMinutes(minutes);\n    setHours24(hours);\n}\n\nvoid DS1307::getDateTime12(uint16_t *year, uint8_t *month, uint8_t *day, uint8_t *hours, uint8_t *minutes, uint8_t *seconds, uint8_t *ampm) {\n    getTime12(hours, minutes, seconds, ampm);\n    getDate(year, month, day);\n}\nvoid DS1307::setDateTime12(uint16_t year, uint8_t month, uint8_t day, uint8_t hours, uint8_t minutes, uint8_t seconds, uint8_t ampm) {\n    setTime12(hours, minutes, seconds, ampm);\n    setDate(year, month, day);\n}\n\nvoid DS1307::getDateTime24(uint16_t *year, uint8_t *month, uint8_t *day, uint8_t *hours, uint8_t *minutes, uint8_t *seconds) {\n    getTime24(hours, minutes, seconds);\n    getDate(year, month, day);\n}\nvoid DS1307::setDateTime24(uint16_t year, uint8_t month, uint8_t day, uint8_t hours, uint8_t minutes, uint8_t seconds) {\n    setTime24(hours, minutes, seconds);\n    setDate(year, month, day);\n}\n\n#ifdef DS1307_INCLUDE_DATETIME_METHODS\n    DateTime DS1307::getDateTime() {\n        DateTime dt = DateTime(getYear(), getMonth(), getDay(), getHours24(), getMinutes(), getSeconds());\n        return dt;\n    }\n    void DS1307::setDateTime(DateTime dt) {\n        setSeconds(dt.second());\n        setMinutes(dt.minute());\n        setHours24(dt.hour());\n        setDay(dt.day());\n        setMonth(dt.month());\n        setYear(dt.year());\n    }\n#endif\n\n#ifdef DS1307_INCLUDE_DATETIME_CLASS\n    // DateTime class courtesy of public domain JeeLabs code\n    #include <avr/pgmspace.h>\n    #define SECONDS_PER_DAY 86400L\n    #define SECONDS_FROM_1970_TO_2000 946684800\n    \n    ////////////////////////////////////////////////////////////////////////////////\n    // utility code, some of this could be exposed in the DateTime API if needed\n    \n    static const uint8_t daysInMonth [] PROGMEM = { 31,28,31,30,31,30,31,31,30,31,30,31 };\n    \n    // number of days since 2000/01/01, valid for 2001..2099\n    static uint16_t date2days(uint16_t y, uint8_t m, uint8_t d) {\n        if (y >= 2000)\n            y -= 2000;\n        uint16_t days = d;\n        for (uint8_t i = 1; i < m; ++i)\n            days += pgm_read_byte(daysInMonth + i - 1);\n        if (m > 2 && y % 4 == 0)\n            ++days;\n        return days + 365 * y + (y + 3) / 4 - 1;\n    }\n    \n    static long time2long(uint16_t days, uint8_t h, uint8_t m, uint8_t s) {\n        return ((days * 24L + h) * 60 + m) * 60 + s;\n    }\n    \n    ////////////////////////////////////////////////////////////////////////////////\n    // DateTime implementation - ignores time zones and DST changes\n    // NOTE: also ignores leap seconds, see http://en.wikipedia.org/wiki/Leap_second\n    \n    DateTime::DateTime (uint32_t t) {\n      t -= SECONDS_FROM_1970_TO_2000;    // bring to 2000 timestamp from 1970\n    \n        ss = t % 60;\n        t /= 60;\n        mm = t % 60;\n        t /= 60;\n        hh = t % 24;\n        uint16_t days = t / 24;\n        uint8_t leap;\n        for (yOff = 0; ; ++yOff) {\n            leap = yOff % 4 == 0;\n            if (days < 365 + leap)\n                break;\n            days -= 365 + leap;\n        }\n        for (m = 1; ; ++m) {\n            uint8_t daysPerMonth = pgm_read_byte(daysInMonth + m - 1);\n            if (leap && m == 2)\n                ++daysPerMonth;\n            if (days < daysPerMonth)\n                break;\n            days -= daysPerMonth;\n        }\n        d = days + 1;\n    }\n    \n    DateTime::DateTime (uint16_t year, uint8_t month, uint8_t day, uint8_t hour, uint8_t min, uint8_t sec) {\n        if (year >= 2000)\n            year -= 2000;\n        yOff = year;\n        m = month;\n        d = day;\n        hh = hour;\n        mm = min;\n        ss = sec;\n    }\n    \n    static uint8_t conv2d(const char* p) {\n        uint8_t v = 0;\n        if (\'0\' <= *p && *p <= \'9\')\n            v = *p - \'0\';\n        return 10 * v + *++p - \'0\';\n    }\n    \n    // A convenient constructor for using "the compiler\'s time":\n    //   DateTime now (__DATE__, __TIME__);\n    // NOTE: using PSTR would further reduce the RAM footprint\n    DateTime::DateTime (const char* date, const char* time) {\n        // sample input: date = "Dec 26 2009", time = "12:34:56"\n        yOff = conv2d(date + 9);\n        // Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec \n        switch (date[0]) {\n            case \'J\': m = (date[1] == \'a\' ? 1 : (date[2] == \'n\' ? 6 : 7)); break;\n            case \'F\': m = 2; break;\n            case \'A\': m = date[2] == \'r\' ? 4 : 8; break;\n            case \'M\': m = date[2] == \'r\' ? 3 : 5; break;\n            case \'S\': m = 9; break;\n            case \'O\': m = 10; break;\n            case \'N\': m = 11; break;\n            case \'D\': m = 12; break;\n        }\n        d = conv2d(date + 4);\n        hh = conv2d(time);\n        mm = conv2d(time + 3);\n        ss = conv2d(time + 6);\n    }\n    \n    uint8_t DateTime::dayOfWeek() const {    \n        uint16_t day = secondstime() / SECONDS_PER_DAY;\n        return (day + 6) % 7; // Jan 1, 2000 is a Saturday, i.e. returns 6\n    }\n    \n    uint32_t DateTime::unixtime(void) const {\n        return secondstime() + SECONDS_FROM_1970_TO_2000;\n    }\n    \n    long DateTime::secondstime(void) const {\n        uint32_t t;\n        uint16_t days = date2days(yOff, m, d);\n        t = time2long(days, hh, mm, ss);    \n        return t;\n    }\n#endif\n'