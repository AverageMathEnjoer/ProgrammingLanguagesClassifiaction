b'{-# LANGUAGE DeriveTraversable #-}\n{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE StandaloneDeriving #-}\n{-# OPTIONS_GHC -fno-warn-incomplete-uni-patterns #-}\n\n-----------------------------------------------------------------------------\n\n-- |\n-- Module      : Data.Hoodle.Zipper\n-- Copyright   : (c) 2011-2013,2015 Ian-Woo Kim\n--\n-- License     : BSD3\n-- Maintainer  : Ian-Woo Kim <ianwookim@gmail.com>\n-- Stability   : experimental\n-- Portability : GHC\n--\n-- representing selection of hoodle type\nmodule Data.Hoodle.Zipper where\n\nimport Data.Foldable (foldr)\nimport Data.Sequence\n  ( Seq,\n    ViewL (..),\n    ViewR (..),\n    empty,\n    fromList,\n    length,\n    singleton,\n    splitAt,\n    viewl,\n    viewr,\n    zipWith,\n    (<|),\n    (><),\n    (|>),\n  )\nimport Prelude hiding (length, splitAt, zipWith)\n\n-- |\ntype NonEmptyList a = (a, [a])\n\n-- |\nnewtype SeqZipper a = SZ {unSZ :: (a, (Seq a, Seq a))}\n\n-- |\nderiving instance Functor SeqZipper\n\n-- |\n-- deriving instance Foldable SeqZipper\ninstance Foldable SeqZipper where\n  foldr f acc (SZ (x, (y1s, y2s))) = Data.Foldable.foldr f acc (y1s <> singleton x <> y2s)\n\n-- |\ninstance Applicative SeqZipper where\n  pure = singletonSZ\n  SZ (f, (f1s, f2s)) <*> SZ (x, (y1s, y2s)) = SZ (f x, (zipWith id f1s y1s, zipWith id f2s y2s))\n\n-- |\nderiving instance Traversable SeqZipper\n\n-- |\nsingletonSZ :: a -> SeqZipper a\nsingletonSZ x = SZ (x, (empty, empty))\n\n-- |\nlengthSZ :: SeqZipper a -> Int\nlengthSZ (SZ (_x, (x1s, x2s))) = Data.Sequence.length x1s + Data.Sequence.length x2s + 1\n\n-- |\ncurrIndex :: SeqZipper a -> Int\ncurrIndex (SZ (_x, (x1s, _x2s))) = Data.Sequence.length x1s\n\n-- |\nappendGoLast :: SeqZipper a -> a -> SeqZipper a\nappendGoLast (SZ (y, (y1s, y2s))) x = SZ (x, ((y1s |> y) >< y2s, empty))\n\n-- |\nappendDropSecond :: SeqZipper a -> a -> SeqZipper a\nappendDropSecond (SZ (y, (y1s, _y2s))) x = SZ (x, (y1s |> y, empty))\n\n-- |\nchopFirst :: SeqZipper a -> Maybe (SeqZipper a)\nchopFirst (SZ (y, (y1s, y2s))) =\n  case viewl y1s of\n    EmptyL -> case viewl y2s of\n      EmptyL -> Nothing\n      z :< zs -> Just (SZ (z, (empty, zs)))\n    _z :< zs -> Just (SZ (y, (zs, y2s)))\n\n-- |\nmoveLeft :: SeqZipper a -> Maybe (SeqZipper a)\nmoveLeft (SZ (x, (x1s, x2s))) =\n  case viewr x1s of\n    EmptyR -> Nothing\n    zs :> z -> Just (SZ (z, (zs, x <| x2s)))\n\n-- |\nmoveRight :: SeqZipper a -> Maybe (SeqZipper a)\nmoveRight (SZ (x, (x1s, x2s))) =\n  case viewl x2s of\n    EmptyL -> Nothing\n    z :< zs -> Just (SZ (z, (x1s |> x, zs)))\n\n-- |\nmoveTo :: Int -> SeqZipper a -> Maybe (SeqZipper a)\nmoveTo n orig@(SZ (x, (x1s, x2s))) =\n  let n_x1s = Data.Sequence.length x1s\n      n_x2s = Data.Sequence.length x2s\n      res\n        | n < 0 || n > n_x1s + n_x2s = Nothing\n        | n == n_x1s = Just orig\n        | n < n_x1s =\n          let (x1s1, x1s2) = splitAt n x1s\n              el :< rm = viewl x1s2\n           in Just (SZ (el, (x1s1, (rm |> x) >< x2s)))\n        | n > n_x1s =\n          let (x2s1, x2s2) = splitAt (n - n_x1s - 1) x2s\n              el :< rm = viewl x2s2\n           in Just (SZ (el, ((x1s |> x) >< x2s1, rm)))\n        | otherwise = error "error in moveTo"\n   in res\n\n-- |\ngoFirst :: SeqZipper a -> SeqZipper a\ngoFirst orig@(SZ (x, (x1s, x2s))) =\n  case viewl x1s of\n    EmptyL -> orig\n    z :< zs -> SZ (z, (empty, zs `mappend` (x <| x2s)))\n\n-- |\ngoLast :: SeqZipper a -> SeqZipper a\ngoLast orig@(SZ (x, (x1s, x2s))) =\n  case viewr x2s of\n    EmptyR -> orig\n    zs :> z -> SZ (z, ((x1s |> x) `mappend` zs, empty))\n\n-- |\ncurrent :: SeqZipper a -> a\ncurrent (SZ (x, (_, _))) = x\n\n-- |\nprev :: SeqZipper a -> Maybe a\nprev = fmap current . moveLeft\n\n-- |\nnext :: SeqZipper a -> Maybe a\nnext = fmap current . moveRight\n\n-- |\nreplace :: a -> SeqZipper a -> SeqZipper a\nreplace y (SZ (_x, zs)) = SZ (y, zs)\n\n-- |\ndeleteCurrent :: SeqZipper a -> Maybe (SeqZipper a)\ndeleteCurrent (SZ (_, (xs, ys))) =\n  case viewl ys of\n    EmptyL -> case viewr xs of\n      EmptyR -> Nothing\n      zs :> z -> Just (SZ (z, (zs, ys)))\n    z :< zs -> Just (SZ (z, (xs, zs)))\n\nfromNonEmptyList :: NonEmptyList a -> SeqZipper a\nfromNonEmptyList (x, xs) = SZ (x, (empty, fromList xs))\n\ntoSeq :: SeqZipper a -> Seq a\ntoSeq (SZ (x, (x1s, x2s))) = x1s >< (x <| x2s)\n\n-- |\ntype ZipperSelect = SeqZipper -- Select { zipper :: (Maybe :. SeqZipper) a }\n{- NoSelect { allelems :: [a] } | -}\n\n{-\n-- |\nderiving instance Functor ZipperSelect\n\n-- |\nderiving instance Foldable ZipperSelect\n\n-- |\nderiving instance Traversable ZipperSelect\n-}\n\n{-\n-- |\ninstance Listable (Maybe :. SeqZipper) where\n  fromList [] = O Nothing\n  fromList (x:xs) = O (Just (SZ (x, (empty,fromList xs))))\n--   toList (O Nothing) = []\n--   toList (O (Just (SZ (x,(xs,ys))))) = toList xs ++ (x : toList ys)\n\n-- |\ninstance Listable ZipperSelect where\n  fromList xs = Select (fromList xs) -- NoSelect xs\n--   toList (NoSelect xs) = xs\n--   toList (Select xs) = toList xs\n-}\n\n-- |\nselectFirst :: ZipperSelect a -> ZipperSelect a\nselectFirst = goFirst\n\n-- selectFirst (NoSelect []) = NoSelect []\n-- selectFirst (NoSelect lst@(_:_))  = Select . fromList $ lst\n-- selectFirst a@(Select (O Nothing)) = a -- NoSelect []\n-- (Select (O msz)) = Select . O $ return . goFirst =<<  msz\n'