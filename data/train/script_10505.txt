b'// Copyright (c) 2021-2023 Manuel Schneider\n\n#include "albert/extensions/queryhandler.h"\n#include "itemindex.h"\n#include "levenshtein.h"\n#include <QRegularExpression>\n#include <map>\n#include <algorithm>\n#include <utility>\n#include <mutex>\nusing namespace std;\nusing namespace albert;\nusing Score = RankItem::Score;\n\n\nstatic QStringList splitString(const QString &string, const QString &separators, bool case_sensitive = false)\n{\n    return ((!case_sensitive) ? string.toLower(): string).split(QRegularExpression(separators), Qt::SkipEmptyParts);\n}\n\nstatic vector<QString> ngrams_for_word(const QString &word, uint n)\n{\n    vector<QString> ngrams;\n    ngrams.reserve(word.size());\n    auto padded = QString("%1%2").arg(QString(n - 1, \' \'), word);\n    for (int i = 0; i < word.size(); ++i){\n        QString ngram{padded.mid(i, n)};\n        ngram.shrink_to_fit();\n        ngrams.emplace_back(ngram);\n    }\n    return ngrams;\n}\n\nItemIndex::ItemIndex(QString sep, bool cs, uint n_, uint etd)\n    : case_sensitive(cs), error_tolerance_divisor(etd), separators(std::move(sep)), n(n_)\n{\n}\n\nvoid ItemIndex::setItems(std::vector<albert::IndexItem> &&index_items)\n{\n    IndexData index_;\n\n    unordered_map<albert::Item*,Index> item_indices_;  // implicit unique\n    map<QString,WordIndexItem> word_index_;  // implicit lexicographical order\n\n    for (Index string_index = 0; string_index < (Index)index_items.size(); ++string_index) {\n\n        // Add item to the unique item index\n        auto item_index = (Index)index_.items.size();\n        auto [it, emplaced] = item_indices_.emplace(index_items[string_index].item.get(), item_index);\n        if (emplaced)\n            index_.items.emplace_back(::move(index_items[string_index].item));\n        else\n            item_index = it->second;\n\n        // Add a string index entry for each string. Store the maximal match length for scoring\n        QStringList &&words = splitString(index_items[string_index].string, separators, case_sensitive);\n        uint max_match_len = 0;\n        for (const auto& word : words)\n            max_match_len += word.size();\n        index_.strings.emplace_back(item_index, max_match_len);\n\n        // Add this string to the occurences in the word index.\n        for (Position pos = 0; pos < (Position)words.size(); ++pos)\n            word_index_[words[pos]].occurrences.emplace_back(string_index, pos);\n    }\n    index_.items.shrink_to_fit();\n    index_.strings.shrink_to_fit();\n\n    // Build the random access word index\n    for (auto &[word, word_index_item] : word_index_) {\n        word_index_item.word = word;\n        word_index_item.word.shrink_to_fit();\n        word_index_item.occurrences.shrink_to_fit();\n        index_.words.emplace_back(::move(word_index_item));\n    }\n    index_.words.shrink_to_fit();\n\n    if (error_tolerance_divisor){\n        // build q_gram_index\n        for (Index word_index = 0; word_index < (Index)index_.words.size(); ++word_index) {\n            vector<QString> ngrams(ngrams_for_word(index_.words[word_index].word, n));\n            for (Position pos = 0 ; pos < (Position)ngrams.size(); ++pos)\n                index_.ngrams[ngrams[pos]].emplace_back(word_index, pos);\n        }\n    }\n    for (auto &[_, word_refs] : index_.ngrams)\n        word_refs.shrink_to_fit();\n\n    unique_lock lock(mutex);\n    index = index_;\n}\n\nstd::vector<ItemIndex::WordMatch> ItemIndex::getWordMatches(const QString &word, const bool &isValid) const\n{\n    vector<WordMatch> matches;\n    const uint word_length = word.length();\n\n    // Get range of perfect prefix match words\n    const auto &[eq_begin, eq_end] = equal_range(index.words.cbegin(), index.words.cend(), WordIndexItem{word, {}},\n                                                 [l=word_length](const WordIndexItem &a, const WordIndexItem &b) {\n                                                     return QStringView{a.word}.left(l) < QStringView{b.word}.left(l);\n                                                 });\n\n    // Store perfect prefix match words\n    for (auto it = eq_begin; it != eq_end; ++it)\n        matches.emplace_back(*it, word_length);\n\n    // Get the (fuzzy) prefix matches\n    if (error_tolerance_divisor) {\n        Index prefix_match_first_id = eq_begin - index.words.begin();  // Ignore interval. closed begin [\n        Index prefix_match_last_id = eq_end - index.words.begin();  // Ignore interval. open end )\n\n        // Get the words referenced by each nGram and count the ngrams where position < word_length.\n        vector<QString> ngrams(ngrams_for_word(word, n));\n        unordered_map<Index,uint> word_match_counts;\n\n        for (const QString &n_gram: ngrams) {\n            try {\n                for (const auto &ngram_occ: index.ngrams.at(n_gram)) {\n                    // Exclude the existing perfect matches\n                    if (prefix_match_first_id <= ngram_occ.index && ngram_occ.index < prefix_match_last_id)\n                        continue;\n\n                    if (ngram_occ.position < static_cast<Position>(word_length))\n                        ++word_match_counts[ngram_occ.index];\n//                    else\n//                        break;  // wtf is this\n                }\n            }\n            catch (const out_of_range &)\n            {\n                // NOTE room for optimizations?\n            }\n        }\n\n        // Get the words referenced by the grams, filter by bound, compute edit distance, add match\n        // Do (cheap) preselection by mathematical bound. If there are less than |word_length|-\xce\xb4*n matching qGrams\n        // it is no match. If the common qGrams are less than |word|-\xce\xb4*q this implies that there are more errors\n        // than \xce\xb4.\n        uint allowed_errors = (uint)((float)word_length/(float)error_tolerance_divisor);\n        uint minimum_match_count = word_length - allowed_errors * n;\n        Levenshtein levenshtein;\n        for (const auto &[word_idx, ngram_count]: word_match_counts) {\n            if (ngram_count < minimum_match_count || !isValid)\n                continue;\n\n            if (auto edit_distance = levenshtein.computePrefixEditDistanceWithLimit(word, index.words[word_idx].word,\n                                                                                    allowed_errors);\n                    edit_distance > allowed_errors)\n                continue;\n            else\n                matches.emplace_back(index.words[word_idx], word_length-edit_distance);\n        }\n    }\n    return matches;\n}\n\nstd::vector<albert::RankItem> ItemIndex::search(const QString &string, const bool &isValid) const\n{\n    QStringList &&words = splitString(string, separators, case_sensitive);\n\n    unordered_map<Index,Score> result_map;\n    if (words.empty()){\n        for (const auto &string_index_item : index.strings){\n            auto score = (Score)(1.0/(double)string_index_item.max_match_len * RankItem::MAX_SCORE);\n            if(const auto &[it, success] = result_map.emplace(string_index_item.item, score); !success)\n                if (it->second < score)\n                    it->second = score;\n        }\n    }\n    else\n    {\n        struct StringMatch {\n            StringMatch(Index i, Position p, uint16_t ml)\n                    : index(i), position(p), match_len(ml){}\n            Index index; Position position; uint16_t match_len;\n        };\n\n        auto invert = [](const vector<WordMatch> &word_matches){\n            vector<StringMatch> string_matches;\n            for (const auto &word_match : word_matches)\n                for (const auto &occurrence : word_match.word_index_item.occurrences)\n                    string_matches.emplace_back(occurrence.index, occurrence.position, word_match.match_length);\n            sort(string_matches.begin(), string_matches.end(),\n                 [](const auto &l, const auto &r){ return l.index < r.index; });\n            return string_matches;\n        };\n\n        shared_lock lock(mutex);\n        vector<StringMatch> left_matches = invert(getWordMatches(words[0], isValid));\n\n        // In case of multiple words intersect. Todo: user chooses strategy\n        for (int w = 1; w < words.size(); ++w) {\n\n            if (!isValid || left_matches.empty())\n                return {};\n\n            vector<StringMatch> right_matches = invert(getWordMatches(words[w], isValid));\n\n            if (right_matches.empty())\n                return {};\n\n            vector<StringMatch> intermediate_matches;\n            for (auto lit = left_matches.cbegin(); lit != left_matches.cend();) {\n\n                // Build a range of upcoming left_matches with same index\n                auto elit = lit;\n                while(elit != left_matches.cend() && lit->index==elit->index)\n                    ++elit;\n\n                // Get the range of equal string matches on the right side\n                const auto &[eq_begin, eq_end] =\n                        equal_range(right_matches.cbegin(), right_matches.cend(), *lit,\n                                    [](const StringMatch &l, const StringMatch &r) { return l.index < r.index; });\n\n                // If no match on the right side continue with next leftmatch\n                if (eq_begin == eq_end){\n                    lit = elit;\n                    continue;\n                }\n\n                //\n                for (;lit != elit; ++lit)\n                    //for (const auto &right_matcht : std::ranges::subrange(eq_begin,eq_end))\n                    for (auto rit = eq_begin; rit != eq_end; ++rit)\n                        if (lit->position < rit->position)  // Sequence check\n                            intermediate_matches.emplace_back(rit->index, rit->position,\n                                                              rit->match_len + lit->match_len);\n\n            }\n\n            left_matches = ::move(intermediate_matches);\n        }\n\n        // Build the list of matched items with their highest scoring match\n        for (const auto &match : left_matches) {\n            auto score = (Score)((double)match.match_len / index.strings[match.index].max_match_len * RankItem::MAX_SCORE);\n            if (const auto &[it, success] = result_map.emplace(index.strings[match.index].item, score);\n                    !success && it->second < score) // update if exists\n                it->second = score;\n        }\n\n    }\n\n    // Convert results to return type\n    vector<albert::RankItem> result;\n    result.reserve(result_map.size());\n    for (const auto &[item_idx, score] : result_map)\n        result.emplace_back(index.items[item_idx], score);\n\n    return result;\n}\n'