b"data Tree = Leaf Int |\n            Fork Tree Tree\n            deriving (Show, Eq)\n\ntree_1 :: Tree\ntree_1 = Fork (Leaf 3) (Leaf 5)\n\ntree_2 :: Tree\ntree_2 = Fork \n            (Fork \n                (Fork (Leaf 8) (Leaf 2))\n                (Leaf 7))\n            (Fork \n                (Leaf 9)\n                (Fork (Leaf 6) \n                    (Fork (Leaf 3) (Leaf 5))))\n\ntree_3 :: Tree\ntree_3 = Fork \n            (Fork \n                (Fork \n                    (Leaf 1) \n                    (Leaf 2)) \n                (Leaf 3)) \n            (Fork \n                (Leaf 6) \n                (Fork \n                    (Leaf 5) (Leaf 4)))\n\ntree_4 :: Tree\ntree_4 = Fork \n            (Fork \n                (Fork \n                    (Leaf 1) \n                    (Fork \n                        (Leaf 2) \n                        (Fork \n                            (Leaf 3) \n                            (Leaf 6)))) \n                (Leaf 5)) \n            (Leaf 4)\n\n\nfringe :: Tree -> [Int]\nfringe (Leaf x) = [x]\nfringe (Fork u v) = fringe u ++ fringe v\n\ncost :: Tree -> Int\ncost (Leaf x) = x\ncost (Fork u v) = 1 + max (cost u) (cost v)\n\ntrees :: [Int] -> [Tree]\ntrees [x] = [Leaf x]\ntrees (x:xs) = concatMap (prefixes x) (trees xs)\n\nprefixes :: Int -> Tree -> [Tree] \nprefixes x t@(Leaf y)   = [Fork (Leaf x) t]\nprefixes x t@(Fork u v) = [Fork (Leaf x) t] ++\n                          [Fork u' v | u' <- prefixes x u]\n\n\n"