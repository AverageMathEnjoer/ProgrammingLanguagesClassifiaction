b'//http://codeforces.com/problemset/problem/723/E\n//EULER - TOUR  -> UNDIRECTED and DIRECTED GRAPH\n//for undirected i needed to mark edges that i have traversed\n#include <bits/stdc++.h>\nusing namespace std;\n#define gc getchar_unlocked\n#define fo(i,n) for(i=0;i<n;i++)\n#define Fo(i,k,n) for(i=k;i<n;i++)\n#define ll long long\n#define si(x)\tscanf("%d",&x)\n#define sl(x)\tscanf("%I64d",&x)\n#define ss(s)\tscanf("%s",s)\n#define pb push_back\n#define mp make_pair\n#define F first\n#define S second\n#define all(x) x.begin(), x.end()\n#define clr(x) memset(x, 0, sizeof(x))\n#define sortall(x) sort(all(x))\n#define tr(it, a) for(auto it = a.begin(); it != a.end(); it++)\n#define PI 3.1415926535897932384626\ntypedef pair<int, int>\tpii;\ntypedef pair<ll, ll>\tpll;\ntypedef vector<int>\t\tvi;\ntypedef vector<ll>\t\tvl;\ntypedef vector<pii>\t\tvpii;\ntypedef vector<pll>\t\tvpll;\ntypedef vector<vi>\t\tvvi;\ntypedef vector<vl>\t\tvvl;\nconst int mod = 1000000007;\nconst int N = 304;\nvpii g[N];\nset<int> has[N];\nll a[N], vis[N], cnt[N], in[N], mark[N*N];\nvi ans;\nint mpow(int base, int exp);\nvoid ipgraph(int n, int m);\nvoid dfs(int u, int par);\nvoid go(int u, int par){\n    vis[u] = 1;\n    while(cnt[u] < (int)g[u].size()){\n        cnt[u]++;\n        if (mark[g[u][cnt[u]-1].S]) continue;\n        else mark[g[u][cnt[u]-1].S] = 1, go(g[u][cnt[u]-1].F, u);\n    }\n    ans.pb(u);\n}\nint main()\n{\n\tios_base::sync_with_stdio(false);\n\tcin.tie(NULL);\n\tint n, m, t, i, u,j, v, w;\n\t//freopen("input.txt", "r". stdin);\n\t//freopen("output.txt", "w". stdout);\n\tcin>>t;\n\twhile(t--){\n        cin>>n>>m;\n        ans.clear();\n        Fo(i, 0, n+1) g[i].clear(), has[i].clear(), in[i] = cnt[i] = vis[i] = 0;\n        fo(i, m){\n            cin>>u>>v;\n            g[u].pb({v, i});\n            g[v].pb({u, i});\n            mark[i] = 0;\n            has[u].insert(v);\n            has[v].insert(u);\n            in[v]++;\n            in[u]++;\n        }\n        int x = m;\n        //add pseudo-vertex\n        int res = 0;\n        Fo(i, 1, n+1) res += 1 - (in[i]%2);\n        Fo(i, 0, n+1) if (in[i]&1) mark[x] = 0, g[i].pb({0, x}), g[0].pb({i, x++});\n\n        //graph has all vertices with even degree\n        //finding euler circuit makes sure all even degree vertices\n        //have equal no of incoming and outgoing edges\n        //later on removing extra edges we added\n        // will not affect even degree vertices :D\n        Fo(i, 1, n+1){\n            if (!vis[i]){\n                vis[i] = 1;\n                go(i, -1);\n                ans.pb(i);\n            }\n        }\n        cout<<res<<endl;\n        reverse(all(ans));\n        fo(i, (int)ans.size()-1){\n            if (1==0 or has[ans[i]].find(ans[i+1]) != has[ans[i]].end()){\n                cout<<ans[i]<<" "<<ans[i+1]<<endl;\n            }\n        }\n\n\t}\n\n\n\n\treturn 0;\n}\n\n'