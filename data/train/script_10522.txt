b'import Data.Char\nimport Data.List\nimport Data.List.Ordered\nimport Data.List.Split\n\ntype Cell = Int\ntype Grid = [(Cell, Cell)] \ntype Vehicle = Char\ntype Move = (Vehicle, Cell) \ntype State = Grid\ntype Path = ([Move], State) \ntype Frontier = [Path]\n\nblankGrid :: String\nblankGrid = replicate 36 \'.\'\n\ng1 :: Grid\ng1 = [  (17, 18), -- Special vehicle - i.e. our car.\n        (1, 15), \n        (2, 9), \n        (3, 10), \n        (4, 11), \n        (5, 6), \n        (12, 19), \n        (13, 27), \n        (24, 26), \n        (31, 38), \n        (33, 34), \n        (36, 37), \n        (40, 41)]\n\ng2 :: Grid\ng2 = [  (16, 17), -- Special vehicle - i.e. our car.\n        (1, 2),\n        (8, 22),\n        (29, 36),\n        (11, 25),\n        (38, 40),\n        (33, 34),\n        (6, 20)]\n\ndrawGrid :: Grid -> IO ()\ndrawGrid g = putStr $ intersperse \' \' $ "\\n" ++ unlines (chunksOf 6 $ showGrid g)\n\ncellToArrayPos :: Cell -> Int\ncellToArrayPos c = (c `div` 7) * 6 + (c `mod` 7) - 1\n\nvehiclePositions :: Grid -> [[Cell]]\nvehiclePositions  = map vehiclePos\n  where\n    vehiclePos (a, b) \n        | isHorizontal (a, b)   = map cellToArrayPos  [a .. b]\n        | otherwise             = map cellToArrayPos $ verticalPositions (a, b)\n\nverticalPositions :: (Cell, Cell) -> [Int]\nverticalPositions (a, b) \n    | b - a > 12    = [a, a + 7, b]\n    | b - a == 7    = [a, b]\n    | otherwise     = []\n\nshowVehicle :: (Char, [Int]) -> String\nshowVehicle (c, xs) = gridPoints xs 0\n  where\n    gridPoints [] n   = replicate (36 - n) \'.\'\n    gridPoints (x:xs) n = replicate (x - n) \'.\' ++ [c] ++ gridPoints xs (x + 1)\n\nsuperimpose :: String -> String -> String\nsuperimpose = zipWith combine\n  where\n    combine :: Char -> Char -> Char\n    combine topCh bottomCh\n        | topCh == \'.\' && bottomCh == \'.\'   = \'.\'\n        | topCh == \'.\' && bottomCh /= \'.\'   = bottomCh\n        | topCh /= \'.\' && bottomCh == \'.\'   = topCh\n        | topCh /= \'.\' && bottomCh /= \'.\'   = \'X\'\n\nshowGrid :: Grid -> String\nshowGrid g = foldl superimpose blankGrid vehicleGrids\n  where\n    vehicles = zip vehicleNames (vehiclePositions g)\n    vehicleGrids = map showVehicle vehicles\n\nvehicleNames :: String\nvehicleNames = "@" ++ [\'a\'..] -- The first vehicle is our special one - we mark it with an @.\n\n-- allocateNames :: Grid -> NamedGrid\n-- allocateNames g = zipWith (\\cell ch -> (fst cell, snd cell, ch)) g vehicleNames\n\nisVertical :: (Cell, Cell) -> Bool\nisVertical (c1, c2) = c2 - c1 > 6 \n\nisHorizontal :: (Cell, Cell) -> Bool\nisHorizontal (c1, c2) = c2 - c1 < 6 \n\noccupied :: Grid -> [Cell]\noccupied = foldr (merge . fillcells) []\n\nfillcells :: (Enum a, Num a, Ord a) => (a, a) -> [a]\nfillcells (r, f) = if r > f - 7 then [r .. f] else [r, r + 7 .. f]\n\nfreecells :: Grid -> [Cell] \nfreecells g = allcells \\\\ occupied g\n\nallcells :: [Cell]\nallcells = [c | c <- [1 .. 41], c `mod` 7 /= 0]\n\nmoves :: Grid -> [Move]\nmoves g = [(v, c) | (v, i) <- zip vehicleNames g, c <- adjs i, c `elem` fs]\n  where \n    fs :: [Cell]\n    fs = freecells g\n    adjs :: (Num a, Ord a) => (a, a) -> [a]\n    adjs (r, f) = if r > f - 7 then [f + 1, r - 1] else [f + 7,r - 7]\n\nmove :: Grid -> Move -> Grid\nmove g (v, c) = g1 ++ adjust i c:g2\n  where \n    (g1, i:g2)  = splitAt v1 g\n    v1          = if v == \'@\' then 0 else ord v - ord \'a\' + 1\n\nadjust :: (Num a, Ord a) => (a, a) -> a -> (a, a)\nadjust (r, f ) c\n    | r > f - 7 = if c > f then (r + 1, c) else (c, f - 1) \n    | otherwise = if c < r then (c, f - 7) else (r + 7, c)\n\nsolved :: Grid -> Bool \nsolved g = snd (head g) == 20\n\nbfsolve :: Grid -> Maybe [Move]\nbfsolve g = bfsearch [] [([], g)]\n\nbfsearch :: [State] -> Frontier -> Maybe [Move] \nbfsearch qs [] = Nothing\nbfsearch qs (p@(ms, q) : ps)\n    | solved q      = Just ms\n    | q `elem` qs   = bfsearch qs ps\n    | otherwise     = bfsearch (q:qs) (ps ++ succs p)\n\nsuccs :: Path -> [Path]\nsuccs (ms, q) = [(ms ++ [m], move q m) | m <- moves q]\n\nbfsolve\' :: Grid -> Maybe [Move]\nbfsolve\' g = bfsearch\' [] [] [([], g)]\n\nbfsearch\' :: [State] -> [Frontier] -> Frontier -> Maybe [Move] \nbfsearch\' qs [] [] = Nothing\nbfsearch\' qs pss [ ] = bfsearch\' qs [] (concat (reverse pss))\nbfsearch\' qs pss (p@(ms, q) : ps)\n    | solved q      = Just ms\n    | q `elem` qs   = bfsearch\' qs pss ps\n    | otherwise     = bfsearch\' (q:qs) (succs p:pss) ps\n\n\ndfsolve :: Grid -> Maybe [Move]\ndfsolve g = dfsearch [] [([], g)]\n\ndfsearch :: [State] -> Frontier -> Maybe [Move] \ndfsearch qs [] = Nothing\ndfsearch qs (p@(ms, q) : ps)\n    | solved q      = Just ms\n    | q `elem` qs   = dfsearch qs ps\n    | otherwise     = dfsearch (q:qs) (succs p ++ps)\n\n\n-- Planning\n\ntype Plan = [Move]\n\nnewplans :: Grid -> Plan -> [Plan]\nnewplans q ms = mkplans ms\n  where\n    mkplans ms \n        | null ms       = []\n        | m `elem` qms  = [ms]\n        | otherwise     = concat [mkplans (pms ++ ms) | pms <- premoves q m, all (notElem ms) pms]\n          where \n            m = head ms; qms = moves q\n\npremoves :: Grid -> Move -> [[Move]]\npremoves g (v, c) = freeingmoves c (blocker g c)\n\nfreeingmoves :: Cell -> (Vehicle, (Cell , Cell )) -> [[Move]]\nfreeingmoves c (v, (r, f))\n    | r > f - 7 = [[(v, j) | j <- [f + 1 .. c + n]] | c + n < k + 7] ++\n                  [[(v, j) | j <- [r - 1, r - 2 .. c - n]] | c - n > k]\n    | otherwise = [[(v, j) | j <- [r - 7, r - 14 .. c - m]] | c - m > 0] ++ \n                  [[(v, j) | j <- [f + 7, f + 14 .. c + m]] | c + m < 42]\n  where \n    (k, m, n) = (f - f `mod` 7, f -r + 7, f -r + 1)\n\nblocker :: Grid -> Cell -> (Vehicle, (Cell , Cell ))\nblocker g c = undefined\n\n'