b'/*\n    SPDX-FileCopyrightText: 2018 Milian Wolff <mail@milianw.de>\n\n    SPDX-License-Identifier: LGPL-2.1-or-later\n*/\n\n#include "3rdparty/catch.hpp"\n\n#include "tempfile.h"\n#include "tst_config.h"\n\n#include <benchutil.h>\n\n#include <dlfcn.h>\n\n#include <iostream>\n\nstatic_assert(RTLD_NOW == 0x2, "RTLD_NOW needs to equal 0x2");\n\nusing heaptrack_inject_t = void (*)(const char*);\nusing heaptrack_stop_t = void (*)();\n\nnamespace {\ntemplate <typename T>\nT resolveSymbol(void* handle, const char* symbol)\n{\n    return reinterpret_cast<T>(dlsym(handle, symbol));\n}\n\nheaptrack_inject_t resolveHeaptrackInject(void* handle)\n{\n    return resolveSymbol<heaptrack_inject_t>(handle, "heaptrack_inject");\n}\n\nheaptrack_stop_t resolveHeaptrackStop(void* handle)\n{\n    return resolveSymbol<heaptrack_stop_t>(handle, "heaptrack_stop");\n}\n\ntemplate <typename Load, typename Unload>\nvoid runInjectTest(Load load, Unload unload)\n{\n    REQUIRE(!resolveHeaptrackInject(RTLD_DEFAULT));\n    REQUIRE(!resolveHeaptrackStop(RTLD_DEFAULT));\n\n    auto* handle = load();\n    REQUIRE(handle);\n\n    auto* heaptrack_inject = resolveHeaptrackInject(handle);\n    REQUIRE(heaptrack_inject);\n\n    auto* heaptrack_stop = resolveHeaptrackStop(handle);\n    REQUIRE(heaptrack_stop);\n\n    TempFile file;\n\n    heaptrack_inject(file.fileName.c_str());\n\n    auto* p = malloc(100);\n    escape(p);\n    free(p);\n\n    heaptrack_stop();\n\n    unload(handle);\n\n    REQUIRE(!resolveHeaptrackInject(RTLD_DEFAULT));\n    REQUIRE(!resolveHeaptrackStop(RTLD_DEFAULT));\n\n    const auto contents = file.readContents();\n    REQUIRE(!contents.empty());\n    REQUIRE(contents.find("\\nA\\n") != std::string::npos);\n    REQUIRE(contents.find("\\n+") != std::string::npos);\n    REQUIRE(contents.find("\\n-") != std::string::npos);\n}\n}\n\nTEST_CASE ("inject via dlopen", "[inject]") {\n    runInjectTest(\n        []() -> void* {\n            dlerror(); // clear error\n            auto* handle = dlopen(HEAPTRACK_LIB_INJECT_SO, RTLD_NOW);\n            if (!handle) {\n                std::cerr << "DLOPEN FAILED: " << dlerror() << std::endl;\n            }\n            return handle;\n        },\n        [](void* handle) { dlclose(handle); });\n}\n\n#ifdef __USE_GNU\nTEST_CASE ("inject via dlmopen", "[inject]") {\n    runInjectTest(\n        []() -> void* {\n            dlerror(); // clear error\n            auto* handle = dlmopen(LM_ID_BASE, HEAPTRACK_LIB_INJECT_SO, RTLD_NOW);\n            if (!handle) {\n                std::cerr << "DLMOPEN FAILED: " << dlerror() << std::endl;\n            }\n            return handle;\n        },\n        [](void* handle) { dlclose(handle); });\n}\n#endif\n\nextern "C" {\n__attribute__((weak)) void* __libc_dlopen_mode(const char* filename, int flag);\n__attribute__((weak)) int __libc_dlclose(void* handle);\n}\n\nTEST_CASE ("inject via libc", "[inject]") {\n    if (!__libc_dlopen_mode) {\n        INFO("__libc_dlopen_mode symbol not available");\n        return;\n    }\n\n    REQUIRE(__libc_dlopen_mode);\n    runInjectTest([]() { return __libc_dlopen_mode(HEAPTRACK_LIB_INJECT_SO, 0x80000000 | 0x002); },\n                  [](void* handle) { __libc_dlclose(handle); });\n}\n'