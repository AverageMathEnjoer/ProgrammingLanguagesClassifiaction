b'-- | Operations for running IO operations asynchronously.\n\n-- These are the same as in the \'async\' package. We do not use\n-- \'async\' to avoid its dependencies.\n\n{- License for the \'async\' package\nCopyright (c) 2012, Simon Marlow\n\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n\n    * Redistributions of source code must retain the above copyright\n      notice, this list of conditions and the following disclaimer.\n\n    * Redistributions in binary form must reproduce the above\n      copyright notice, this list of conditions and the following\n      disclaimer in the documentation and/or other materials provided\n      with the distribution.\n\n    * Neither the name of Simon Marlow nor the names of other\n      contributors may be used to endorse or promote products derived\n      from this software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\nA PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\nOWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\nLIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\nTHEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n-}\n\n{-# LANGUAGE DeriveDataTypeable, MagicHash, UnboxedTuples #-}\n\nmodule Control.Concurrent.Async (\n  async, withAsync, wait, asyncThreadId, cancel, concurrently\n  ) where\n\nimport Control.Concurrent.STM\nimport Control.Exception\nimport Control.Concurrent\nimport Control.Monad\nimport Data.IORef\nimport Data.Typeable\nimport GHC.Conc\nimport GHC.Exts\nimport GHC.IO hiding (onException)\n\n-- | An asynchronous action spawned by \'async\' or \'withAsync\'.\n-- Asynchronous actions are executed in a separate thread, and\n-- operations are provided for waiting for asynchronous actions to\n-- complete and obtaining their results (see e.g. \'wait\').\n--\ndata Async a = Async\n  { asyncThreadId :: {-# UNPACK #-} !ThreadId\n                  -- ^ Returns the \'ThreadId\' of the thread running\n                  -- the given \'Async\'.\n  , _asyncWait    :: STM (Either SomeException a)\n  }\n\n-- | Spawn an asynchronous action in a separate thread.\nasync :: IO a -> IO (Async a)\nasync = inline asyncUsing rawForkIO\n\nasyncUsing :: (IO () -> IO ThreadId)\n           -> IO a -> IO (Async a)\nasyncUsing doFork = \\action -> do\n   var <- newEmptyTMVarIO\n   -- t <- forkFinally action (\\r -> atomically $ putTMVar var r)\n   -- slightly faster:\n   t <- mask $ \\restore ->\n          doFork $ try (restore action) >>= atomically . putTMVar var\n   return (Async t (readTMVar var))\n\n-- | Spawn an asynchronous action in a separate thread, and pass its\n-- @Async@ handle to the supplied function.  When the function returns\n-- or throws an exception, \'uninterruptibleCancel\' is called on the @Async@.\n--\n-- > withAsync action inner = mask $ \\restore -> do\n-- >   a <- async (restore action)\n-- >   restore (inner a) `finally` uninterruptibleCancel a\n--\n-- This is a useful variant of \'async\' that ensures an @Async@ is\n-- never left running unintentionally.\n--\n-- Note: a reference to the child thread is kept alive until the call\n-- to `withAsync` returns, so nesting many `withAsync` calls requires\n-- linear memory.\n--\nwithAsync :: IO a -> (Async a -> IO b) -> IO b\nwithAsync = inline withAsyncUsing rawForkIO\n\nwithAsyncUsing :: (IO () -> IO ThreadId)\n               -> IO a -> (Async a -> IO b) -> IO b\n-- The bracket version works, but is slow.  We can do better by\n-- hand-coding it:\nwithAsyncUsing doFork = \\action inner -> do\n  var <- newEmptyTMVarIO\n  mask $ \\restore -> do\n    t <- doFork $ try (restore action) >>= atomically . putTMVar var\n    let a = Async t (readTMVar var)\n    r <- restore (inner a) `catchAll` \\e -> do\n      uninterruptibleCancel a\n      throwIO e\n    uninterruptibleCancel a\n    return r\n\n-- | Wait for an asynchronous action to complete, and return its\n-- value.  If the asynchronous action threw an exception, then the\n-- exception is re-thrown by \'wait\'.\n--\n-- > wait = atomically . waitSTM\n--\n{-# INLINE wait #-}\nwait :: Async a -> IO a\nwait = tryAgain . atomically . waitSTM\n  where\n    -- See: https://github.com/simonmar/async/issues/14\n    tryAgain f = f `Control.Exception.catch` \\BlockedIndefinitelyOnSTM -> f\n\n-- | Wait for an asynchronous action to complete, and return either\n-- @Left e@ if the action raised an exception @e@, or @Right a@ if it\n-- returned a value @a@.\n--\n-- > waitCatch = atomically . waitCatchSTM\n--\n{-# INLINE waitCatch #-}\nwaitCatch :: Async a -> IO (Either SomeException a)\nwaitCatch = tryAgain . atomically . waitCatchSTM\n  where\n    -- See: https://github.com/simonmar/async/issues/14\n    tryAgain f = f `Control.Exception.catch` \\BlockedIndefinitelyOnSTM -> f\n\n-- | A version of \'wait\' that can be used inside an STM transaction.\n--\nwaitSTM :: Async a -> STM a\nwaitSTM a = do\n   r <- waitCatchSTM a\n   either throwSTM return r\n\n-- | A version of \'waitCatch\' that can be used inside an STM transaction.\n--\n{-# INLINE waitCatchSTM #-}\nwaitCatchSTM :: Async a -> STM (Either SomeException a)\nwaitCatchSTM (Async _ w) = w\n\n-- | Cancel an asynchronous action by throwing the @AsyncCancelled@\n-- exception to it, and waiting for the `Async` thread to quit.\n-- Has no effect if the \'Async\' has already completed.\n--\n-- > cancel a = throwTo (asyncThreadId a) AsyncCancelled <* waitCatch a\n--\n-- Note that \'cancel\' will not terminate until the thread the \'Async\'\n-- refers to has terminated. This means that \'cancel\' will block for\n-- as long said thread blocks when receiving an asynchronous exception.\n--\n-- For example, it could block if:\n--\n-- * It\'s executing a foreign call, and thus cannot receive the asynchronous\n-- exception;\n-- * It\'s executing some cleanup handler after having received the exception,\n-- and the handler is blocking.\n{-# INLINE cancel #-}\ncancel :: Async a -> IO ()\ncancel a@(Async t _) = throwTo t AsyncCancelled >> void (waitCatch a)\n\n-- | The exception thrown by `cancel` to terminate a thread.\ndata AsyncCancelled = AsyncCancelled\n  deriving (Show, Eq, Typeable)\n\ninstance Exception AsyncCancelled where\n#if __GLASGOW_HASKELL__ >= 708\n  fromException = asyncExceptionFromException\n  toException = asyncExceptionToException\n#endif\n\n-- | Cancel an asynchronous action\n--\n-- This is a variant of `cancel`, but it is not interruptible.\n{-# INLINE uninterruptibleCancel #-}\nuninterruptibleCancel :: Async a -> IO ()\nuninterruptibleCancel = uninterruptibleMask_ . cancel\n\n-- | Run two @IO@ actions concurrently, and return both results.  If\n-- either action throws an exception at any time, then the other\n-- action is \'cancel\'led, and the exception is re-thrown by\n-- \'concurrently\'.\n--\n-- > concurrently left right =\n-- >   withAsync left $ \\a ->\n-- >   withAsync right $ \\b ->\n-- >   waitBoth a b\nconcurrently :: IO a -> IO b -> IO (a,b)\nconcurrently left right = concurrently\' left right (collect [])\n  where\n    collect [Left a, Right b] _ = return (a,b)\n    collect [Right b, Left a] _ = return (a,b)\n    collect xs m = do\n        e <- m\n        case e of\n            Left ex -> throwIO ex\n            Right r -> collect (r:xs) m\n\nconcurrently\' :: IO a -> IO b\n             -> (IO (Either SomeException (Either a b)) -> IO r)\n             -> IO r\nconcurrently\' left right collect = do\n    done <- newEmptyMVar\n    mask $ \\restore -> do\n        -- Note: uninterruptibleMask here is because we must not allow\n        -- the putMVar in the exception handler to be interrupted,\n        -- otherwise the parent thread will deadlock when it waits for\n        -- the thread to terminate.\n        lid <- forkIO $ uninterruptibleMask_ $\n          restore (left >>= putMVar done . Right . Left)\n            `catchAll` (putMVar done . Left)\n        rid <- forkIO $ uninterruptibleMask_ $\n          restore (right >>= putMVar done . Right . Right)\n            `catchAll` (putMVar done . Left)\n\n        count <- newIORef (2 :: Int)\n        let takeDone = do\n                r <- takeMVar done      -- interruptible\n                -- Decrement the counter so we know how many takes are left.\n                -- Since only the parent thread is calling this, we can\n                -- use non-atomic modifications.\n                -- NB. do this *after* takeMVar, because takeMVar might be\n                -- interrupted.\n                modifyIORef count (subtract 1)\n                return r\n\n        let tryAgain f = f `Control.Exception.catch` \\BlockedIndefinitelyOnMVar -> f\n\n            stop = do\n                -- kill right before left, to match the semantics of\n                -- the version using withAsync. (#27)\n                uninterruptibleMask_ $ do\n                  count\' <- readIORef count\n                  -- we only need to use killThread if there are still\n                  -- children alive.  Note: forkIO here is because the\n                  -- child thread could be in an uninterruptible\n                  -- putMVar.\n                  when (count\' > 0) $\n                    void $ forkIO $ do\n                      throwTo rid AsyncCancelled\n                      throwTo lid AsyncCancelled\n                  -- ensure the children are really dead\n                  replicateM_ count\' (tryAgain $ takeMVar done)\n\n        r <- collect (tryAgain $ takeDone) `onException` stop\n        stop\n        return r\n\ncatchAll :: IO a -> (SomeException -> IO a) -> IO a\ncatchAll = Control.Exception.catch\n\n-- A version of forkIO that does not include the outer exception\n-- handler: saves a bit of time when we will be installing our own\n-- exception handler.\n{-# INLINE rawForkIO #-}\nrawForkIO :: IO () -> IO ThreadId\nrawForkIO action = IO $ \\ s ->\n   case (fork# (unIO action) s) of (# s1, tid #) -> (# s1, ThreadId tid #)\n'