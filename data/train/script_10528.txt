b'-- Make a 2-D array of size z given a function f\nmkArray :: (Enum a, Num a) => (a -> a -> a) -> a -> [[a]]\nmkArray f z = [ [f x y | x <- [0..z]] | y <- [0..z]]\n\n-- Stringify a 1-D array\nformatArray :: (Show a, Num a) => [a] -> String\nformatArray [] = ""\nformatArray (x:xs) = show x ++ "\\t" ++ formatArray xs\n\n-- Stringify a 2-D array\nformat2DArray :: (Show a, Num a) => [[a]] -> String\nformat2DArray [] = ""\nformat2DArray (x:xs) = formatArray x ++ "\\n" ++ format2DArray xs\n\n-- In this function, all values from 0..z are represented   \nf1 :: Num a => a -> a -> a\nf1 x y = x + y\n\n-- In this function, each value is represented only once.\nf2 :: Num a => a -> a -> a\nf2 x y = 3*x + 27*y + y*y\n\n-- Jack\'s first solution\ninvert :: (Enum a, Eq a, Num a) => (a -> a -> a) -> a -> [(a, a)]\ninvert f z = [(x, y) | x <- [0..z ], y <- [0..z ], f x  y == z]\n\n-- Theo\'s slight improvement\ninvert_b :: (Enum a, Eq a, Num a) => (a -> a -> a) -> a -> [(a, a)]\ninvert_b f z = [(x, y) | x <- [0..z], y <- [0..z - x], f x y == z]\n\n-- Anne reduces it further\nfind :: (Enum t, Eq t, Num t) => (t, t) -> (t -> t -> t) -> t -> [(t, t)]\nfind (u, v) f z = [(x, y) | x <- [u .. z ], y <- [v, v - 1..0], f x y == z]\n\ninvert_c :: (Enum a, Eq a, Num a) => (a -> a -> a) -> a -> [(a, a)]\ninvert_c f z = find (0, z) f z\n\n-- And more efficiently\nfind_d :: (Ord t, Enum t, Eq t, Num t) => (t, t) -> (t -> t -> t) -> t -> [(t, t)]\nfind_d (u, v) f z\n    | u > z || v < 0   = []\n    | z\' < z           = find_d (u + 1, v) f z\n    | z\' == z          = (u, v) : find_d (u + 1, v - 1) f z\n    | z\' > z           = find_d (u, v - 1) f z\n    where z\' = f u v\n\ninvert_d :: (Enum a, Eq a, Num a) => (a -> a -> a) -> a -> [(a, a)]\ninvert_d f z = find_d (0, z) f z\n'