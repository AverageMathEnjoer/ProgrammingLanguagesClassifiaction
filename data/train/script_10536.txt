b'{-# LANGUAGE OverloadedStrings #-}\n\n-- | Parsers for XRef\n\nmodule Pdf.Core.Parsers.XRef\n( startXRef\n, tableXRef\n, parseSubsectionHeader\n, parseTrailerAfterTable\n, parseTableEntry\n)\nwhere\n\nimport Pdf.Core.Object\nimport Pdf.Core.Parsers.Object\nimport Pdf.Core.Parsers.Util\n\nimport Data.Int\nimport Data.Attoparsec.ByteString (Parser)\nimport qualified Data.Attoparsec.ByteString.Char8 as P\nimport Control.Applicative (many)\n\n-- for doctest\n-- $setup\n-- >>> :set -XOverloadedStrings\n-- >>> import Data.Attoparsec.ByteString.Char8\n\n-- | Offset of the very last xref table\n--\n-- Before calling it, make sure your are currently somewhere near\n-- the end of pdf file. Otherwice it can eat all the memory.\n-- E.g. examine only the last 1KB\n--\n-- >>> parseOnly startXRef "anything...startxref\\n222\\n%%EOF...blah\\nstartxref\\n123\\n%%EOF"\n-- Right 123\nstartXRef :: Parser Int64\nstartXRef = do\n  res <- many $ do\n    _ <- P.manyTill P.anyChar $ P.string "startxref"\n    skipSpace\n    offset <- P.decimal\n    P.skipSpace\n    _ <- P.string "%%EOF"\n    return offset\n  case res of\n    [] -> fail "Trailer not found"\n    xs -> return $ last xs\n\n-- | When current input position points to xref stream\n-- (or doesn\'t point to xref at all), the parser will fail.\n-- When it points to xref table, the parser will succeed\n-- and input position will point to the first xref subsection\n--\n-- >>> parseOnly tableXRef "xref\\n"\n-- Right ()\n-- >>> parseOnly tableXRef "not xref"\n-- Left "Failed reading: takeWith"\ntableXRef :: Parser ()\ntableXRef = do\n  _ <- P.string "xref"\n  endOfLine\n\n-- | Parse subsection header, return (the first object index, number of object)\n--\n-- Input position will point to the first object\nparseSubsectionHeader :: Parser (Int, Int)\nparseSubsectionHeader = do\n  start <- P.decimal\n  skipSpace\n  count <- P.decimal\n  endOfLine\n  return (start, count)\n\n-- | Parse trailer located after XRef table\n--\n-- Input position should point to the \\"trailer\\" keyword\nparseTrailerAfterTable :: Parser Dict\nparseTrailerAfterTable = do\n  skipSpace\n  _ <- P.string "trailer"\n  endOfLine\n  skipSpace\n  parseDict\n\n-- | Parse XRef table entry. Returns offset, generation and whether the object is free.\nparseTableEntry :: Parser (Int64, Int, Bool)\nparseTableEntry = do\n  offset <- P.decimal\n  skipSpace\n  generation <- P.decimal\n  skipSpace\n  c <- P.anyChar\n  case c of\n    \'n\' -> return (offset, generation, False)\n    \'f\' -> return (offset, generation, True)\n    _ -> fail $ "error parsing XRef table entry: unknown char: " ++ [c]\n'