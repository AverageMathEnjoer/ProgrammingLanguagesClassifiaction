b'#\' gammaNUMCK2par\n#\'\n#\' Field comparisons for numeric variables. Two possible agreement patterns are considered:\n#\' 0 total disagreement, 2 agreement.\n#\' The distance between numbers is calculated using their absolute distance.\n#\'\n#\' @usage gammaNUMCK2par(matAp, matBp, n.cores, cut.a)\n#\'\n#\' @param matAp vector storing the comparison field in data set 1\n#\' @param matBp vector storing the comparison field in data set 2\n#\' @param n.cores Number of cores to parallelize over. Default is NULL.\n#\' @param cut.a Lower bound for full match. Default is 1\n#\'\n#\' @return \\code{gammaNUMCK2par} returns a list with the indices corresponding to each\n#\' matching pattern, which can be fed directly into \\code{tableCounts} and \\code{matchesLink}.\n#\'\n#\' @author Ted Enamorado <ted.enamorado@gmail.com>, Ben Fifield <benfifield@gmail.com>, and Kosuke Imai\n#\'\n#\' @examples\n#\' \\dontrun{\n#\' g1 <- gammaNUMCK2par(dfA$birthyear, dfB$birthyear)\n#\' }\n#\' @export\n\n## ------------------------\n## gammaNUMCK2par: Now it takes values 0, 2\n## This function applies gamma.k\n## in parallel\n## ------------------------\ngammaNUMCK2par <- function(matAp, matBp, n.cores = NULL, cut.a = 1) {\n    \n    if(any(class(matAp) %in% c("tbl_df", "data.table"))){\n        matAp <- as.data.frame(matAp)[,1]\n    }\n    if(any(class(matBp) %in% c("tbl_df", "data.table"))){\n        matBp <- as.data.frame(matBp)[,1]\n    }\n    \n    matAp[matAp == ""] <- NA\n    matBp[matBp == ""] <- NA\n\n    if(sum(is.na(matAp)) == length(matAp) | length(unique(matAp)) == 1){\n        cat("WARNING: You have no variation in this variable, or all observations are missing in dataset A.\\n")\n    }\n    if(sum(is.na(matBp)) == length(matBp) | length(unique(matBp)) == 1){\n        cat("WARNING: You have no variation in this variable, or all observations are missing in dataset B.\\n")\n    }\n    \n    if(is.null(n.cores)) {\n        n.cores <- detectCores() - 1\n    }\n\n    matrix.1 <- as.matrix(as.numeric(matAp))\n    matrix.2 <- as.matrix(as.numeric(matBp))\n\n    max <- max(max(matrix.1, na.rm = T), max(matrix.2, na.rm = T))   \n    end.points <- c((round((max), 0) + 1), (round(max + cut.a, 0) + 3))\n    matrix.1[is.na(matrix.1)] <- end.points[2]\n    matrix.2[is.na(matrix.2)] <- end.points[1]\n\n    u.values.1 <- unique(matrix.1)\n    u.values.2 <- unique(matrix.2)\n\n    n.slices1 <- max(round(length(u.values.1)/(10000), 0), 1) \n    n.slices2 <- max(round(length(u.values.2)/(10000), 0), 1) \n\n    limit.1 <- round(quantile((0:nrow(u.values.2)), p = seq(0, 1, 1/n.slices2)), 0)\n    limit.2 <- round(quantile((0:nrow(u.values.1)), p = seq(0, 1, 1/n.slices1)), 0)\n\n    temp.1 <- temp.2 <- list()\n\n    n.cores2 <- min(n.cores, n.slices1 * n.slices2)\n    \n    for(i in 1:n.slices2) {\n        temp.1[[i]] <- list(u.values.2[(limit.1[i]+1):limit.1[i+1]], limit.1[i])\n    }\n\n    for(i in 1:n.slices1) {\n        temp.2[[i]] <- list(u.values.1[(limit.2[i]+1):limit.2[i+1]], limit.2[i])\n    }\n\n    difference <- function(m, y, cut) {\n\n        x <- as.matrix(m[[1]])\n        e <- as.matrix(y[[1]])        \n\n        t <- calcPWDcpp(as.matrix(x), as.matrix(e))\n        t[ t == 0 ] <- cut[1]\n        t[ t > cut ] <- 0\n        t <- Matrix(t, sparse = T)\n        \n        t@x[t@x <= cut] <- 2; gc()       \t\n        slice.1 <- m[[2]]\n        slice.2 <- y[[2]]\n        indexes.2 <- which(t == 2, arr.ind = T)\n        indexes.2[, 1] <- indexes.2[, 1] + slice.2\n        indexes.2[, 2] <- indexes.2[, 2] + slice.1\n        list(indexes.2)\n    }\n\n    do <- expand.grid(1:n.slices2, 1:n.slices1)\n\n    if (n.cores2 == 1) \'%oper%\' <- foreach::\'%do%\'\n    else { \n        \'%oper%\' <- foreach::\'%dopar%\'\n        cl <- makeCluster(n.cores2)\n        registerDoParallel(cl)\n        on.exit(stopCluster(cl))\n    }\n\n    temp.f <- foreach(i = 1:nrow(do), .packages = c("Rcpp", "Matrix")) %oper% {\n        r1 <- do[i, 1]\n        r2 <- do[i, 2]\n        difference(temp.1[[r1]], temp.2[[r2]], cut.a)\n    }\n\n    gc()\n\n    reshape2 <- function(s) { s[[1]] }\n    temp.2 <- lapply(temp.f, reshape2)\n\n    indexes.2 <- do.call(\'rbind\', temp.2)\n\n    ht1 <- new.env(hash=TRUE)\n    ht2 <- new.env(hash=TRUE)\n\n    n.values.2 <- as.matrix(cbind(u.values.1[indexes.2[, 2]], u.values.2[indexes.2[, 1]]))\n    matches.2 <- lapply(seq_len(nrow(n.values.2)), function(i) n.values.2[i, ])\n\n    if(Sys.info()[[\'sysname\']] == \'Windows\') {\n        if (n.cores == 1) \'%oper%\' <- foreach::\'%do%\'\n        else { \n            \'%oper%\' <- foreach::\'%dopar%\'\n            cl <- makeCluster(n.cores)\n            registerDoParallel(cl)\n            on.exit(stopCluster(cl))\n        }\n\n        final.list2 <- foreach(i = 1:length(matches.2)) %oper% {\n            ht1 <- which(matrix.1 == matches.2[[i]][[1]]); ht2 <- which(matrix.2 == matches.2[[i]][[2]])\n            list(ht1, ht2)\n      \t}\n\n    } else {\n        no_cores <- n.cores\n        final.list2 <- mclapply(matches.2, function(s){\n            ht1 <- which(matrix.1 == s[1]); ht2 <- which(matrix.2 == s[2]);\n            list(ht1, ht2) }, mc.cores = getOption("mc.cores", no_cores))\n    }\n    \n    na.list <- list()\n    na.list[[1]] <- which(matrix.1 == end.points[2])\n    na.list[[2]] <- which(matrix.2 == end.points[1])\n\n    out <- list()\n    out[["matches2"]] <- final.list2\n    out[["nas"]] <- na.list\n    class(out) <- c("fastLink", "gammaNUMCK2par")\n    \n    return(out)\n}\n\n\n## ------------------------\n## End of gammaNUMKpar\n## ------------------------\n\n'