b'{-# LANGUAGE RankNTypes, NamedFieldPuns, BangPatterns,\n             ExistentialQuantification, CPP #-}\n{-# OPTIONS_GHC -Wall -fno-warn-name-shadowing -fwarn-unused-imports #-}\n\n{-\n\n  This alternate implementation of Par uses the existing thread/MVar\n  capabilities of GHC.  It therefore represents an attempt to do\n  monad-par style programming before monad-par itself was implemented.\n\n -}\n\n\nmodule Control.Monad.Par_Strawman (\n    Par, IVar,\n    runPar, runParAsync,\n    fork,\n    new, newFull, newFull_,\n    get,\n    put, put_,\n    pval,\n    spawn, spawn_,\n    parMap, parMapM, parMapReduceRange,\n\n  ) where\n\nimport Control.Concurrent\n\nimport Data.Traversable\nimport Control.Monad hiding (mapM, sequence, join)\nimport Prelude hiding (mapM, sequence, head,tail)\nimport Data.IORef\nimport System.IO.Unsafe\nimport Control.Concurrent\nimport GHC.Conc hiding ()\nimport Control.DeepSeq\nimport Control.Applicative\n-- import Text.Printf\n\n-- For testing only:\nimport Test.HUnit\nimport Control.Exception\n\n\n-- ---------------------------------------------------------------------------\n\n\ntype Par a = IO a\n\nrunPar = unsafePerformIO\nrunParAsync = runPar\n\n-- instance Applicative Par where\n--    (<*>) = ap\n--    pure  = return\n\ntype IVar a = MVar a\n\nfork :: Par () -> Par ()\nfork p = do forkIO p; return ()\n\nnew :: Par (MVar a)\nnew = newEmptyMVar\n\nnewFull :: NFData a => a -> Par (IVar a)\nnewFull x = deepseq x (newMVar x)\n\nnewFull_ :: a -> Par (IVar a)\nnewFull_ !x = newMVar x\n\nget :: IVar a -> Par a\nget = readMVar\n\nput_ :: IVar a -> a -> Par ()\nput_ v !a = putMVar v a\n\nput :: NFData a => IVar a -> a -> Par ()\nput v a = deepseq a (putMVar v a)\n\n--  < BEGIN DUPLICATED CODE >\n\n-- -----------------------------------------------------------------------------\n-- Derived functions\n\n-- | Like \'spawn\', but the result is only head-strict, not fully-strict.\nspawn_ :: Par a -> Par (IVar a)\nspawn_ p = do\n  r <- new\n  fork (p >>= put_ r)\n  return r\n\n-- | Like \'fork\', but returns an @IVar@ that can be used to query the\n-- result of the forked computation.\nspawn :: NFData a => Par a -> Par (IVar a)\nspawn p = do\n  r <- new\n  fork (p >>= put r)\n  return r\n\n-- | equivalent to @spawn . return@\npval :: NFData a => a -> Par (IVar a)\npval a = spawn (return a)\n\n-- -----------------------------------------------------------------------------\n-- Parallel maps over Traversable data structures\n\nparMap :: (Traversable t, NFData b) => (a -> b) -> t a -> Par (t b)\nparMap f xs = mapM (pval . f) xs >>= mapM get\n\nparMapM :: (Traversable t, NFData b) => (a -> Par b) -> t a -> Par (t b)\nparMapM f xs = mapM (spawn . f) xs >>= mapM get\n\n{-# SPECIALISE parMap  :: (NFData b) => (a -> b)     -> [a] -> Par [b] #-}\n{-# SPECIALISE parMapM :: (NFData b) => (a -> Par b) -> [a] -> Par [b] #-}\n\n\n-- | parMapReduceRange is similar to the "parallel for" construct\n--   found in many parallel programming models.\n--\nparMapReduceRange :: NFData a => Int -> Int -> Int -> (Int -> Par a) -> (a -> a -> Par a) -> a -> Par a\nparMapReduceRange threshold min max fn binop init = loop min max\n where\n  loop min max\n    | max - min <= threshold =\n\tlet mapred a b = do x <- fn b;\n\t\t\t    result <- a `binop` x\n\t\t\t    return result\n\tin foldM mapred init [min..max]\n\n    | otherwise  = do\n\tlet mid = min + ((max - min) `quot` 2)\n\trght <- spawn $ loop (mid+1) max\n\tl  <- loop  min    mid\n\tr  <- get rght\n\tlr <- l `binop` r\n\treturn lr\n\n-- TODO: A version that works for any splittable input domain.  In this case\n-- the "threshold" is a predicate on inputs.\n-- parMapReduceRangeGeneric :: (inp -> Bool) -> (inp -> Maybe (inp,inp)) -> inp ->\n\n'