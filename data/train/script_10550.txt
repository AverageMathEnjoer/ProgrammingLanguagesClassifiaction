b'module Cachix.Client.WatchStore\n  ( startWorkers,\n  )\nwhere\n\nimport Cachix.Client.Push\nimport qualified Cachix.Client.PushQueue as PushQueue\nimport qualified Control.Concurrent.STM.TBQueue as TBQueue\nimport Hercules.CNix.Store (Store)\nimport qualified Hercules.CNix.Store as Store\nimport Protolude\nimport System.FSNotify\nimport qualified System.Systemd.Daemon as Systemd\n\nstartWorkers :: Store -> Int -> PushParams IO () -> IO ()\nstartWorkers store numWorkers pushParams = do\n  void Systemd.notifyReady\n  withManager $ \\mgr -> PushQueue.startWorkers numWorkers (producer store mgr) pushParams\n\nproducer :: Store -> WatchManager -> PushQueue.Queue -> IO (IO ())\nproducer store mgr queue = do\n  putTextError "Watching /nix/store for new store paths ..."\n  watchDir mgr "/nix/store" filterOnlyStorePaths (queueStorePathAction store queue)\n\nqueueStorePathAction :: Store -> PushQueue.Queue -> Event -> IO ()\nqueueStorePathAction store queue (Removed lockFile _ _) = do\n  sp <- Store.parseStorePath store (encodeUtf8 $ toS $ dropLast 5 lockFile)\n  atomically $ TBQueue.writeTBQueue queue sp\nqueueStorePathAction _ _ _ = return ()\n\ndropLast :: Int -> [a] -> [a]\ndropLast index xs = take (length xs - index) xs\n\n-- we queue store paths after their lock has been removed\nfilterOnlyStorePaths :: ActionPredicate\nfilterOnlyStorePaths (Removed fp _ _)\n  | ".drv.lock" `isSuffixOf` fp = False\n  | ".lock" `isSuffixOf` fp = True\nfilterOnlyStorePaths _ = False\n\nputTextError :: Text -> IO ()\nputTextError = hPutStrLn stderr\n'