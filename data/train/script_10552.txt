b'{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE OverloadedStrings #-}\n\n-- ! BUILD_COMMAND: runhaskell --ghc-arg=-fglasgow-exts -XTypeFamilies -XOverloadedStrings -XPartialTypeSignatures -XTypeApplications -i../../beam-sqlite/examples -fno-warn-partial-type-signatures\n-- ! BUILD_DIR: beam-postgres/examples/\n\nmodule Main where\n\nimport Prelude hiding (lookup)\n\nimport Database.Beam\nimport Database.Beam.Backend.Types\nimport Database.Beam.Postgres hiding (insert, runInsert)\nimport qualified Database.Beam.Postgres as Pg\nimport Database.PostgreSQL.Simple\n\nimport Control.Monad\nimport Control.Exception\n\nimport Data.IORef\nimport Data.Monoid\nimport Data.Int\n\nimport Chinook.Schema\n\ndata BeamDone = BeamDone\n  deriving (Show)\ninstance Exception BeamDone\n\nexampleQuery :: (String -> Pg ()) -> Pg ()\nexampleQuery putStrLn = do\n  BEAM_PLACEHOLDER\n\nmain :: IO ()\nmain =\n  do chinook <- connectPostgreSQL "dbname=chinook"\n\n     stmts <- newIORef id\n\n     let onStmt s = modifyIORef stmts (. (s:))\n         record a = withDatabaseDebug (onStmt . (++ ";")) chinook a\n\n     handle (\\BeamDone -> pure ()) $\n       withTransaction chinook $ do\n         record $ exampleQuery (liftIO . onStmt . ("-- Output: " ++))\n         throwIO BeamDone\n\n     mkStmtList <- readIORef stmts\n     let stmtList = mkStmtList []\n\n     forM_ stmtList $ \\stmt -> do\n       putStrLn stmt\n'