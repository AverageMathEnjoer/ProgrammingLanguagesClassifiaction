b'// UVa12170 Easy Climb\n// Rujia Liu\n#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\ntypedef long long LL;\n\nconst int maxn = 100 + 5;\nconst int maxx = maxn*maxn*2;\nconst LL  INF = (1LL << 60);\n\nLL h[maxn], x[maxx], dp[2][maxx];\n\nint main () {\n  int T;\n  cin >> T;\n  while(T--) {\n    int n;\n    LL d;\n    cin >> n >> d;\n    for(int i = 0; i < n; i++) cin >> h[i];\n    if(abs(h[0] - h[n-1]) > (n-1)*d) {\n      cout << "impossible\\n";\n      continue;\n    }\n\n    // useful heights\n    int nx = 0;\n    for(int i = 0; i < n; i++)\n      for(int j = -n+1; j <= n-1; j++)\n        x[nx++] = h[i] + j*d;\n    sort(x, x+nx);\n    nx = unique(x, x+nx) - x;\n\n    // dp\n    int t = 0;\n    for(int i = 0; i < nx; i++) {\n      dp[0][i] = INF;\n      if(x[i] == h[0]) dp[0][i] = 0;\n    }\n    for(int i = 1; i < n; i++) {\n      int k = 0;\n      for(int j = 0; j < nx; j++) {\n        while(k < nx && x[k] < x[j]-d) k++;\n        while(k+1 < nx && x[k+1] <= x[j]+d && dp[t][k+1] <= dp[t][k]) k++; // min in sliding window\n        if(dp[t][k] == INF) dp[t^1][j] = INF; // (t, k) is not reachable\n        else dp[t^1][j] = dp[t][k] + abs(x[j] - h[i]);\n      }\n      t ^= 1;\n    }\n    for(int i = 0; i < nx; i++)\n      if(x[i] == h[n-1]) cout << dp[t][i] << "\\n";\n  }\n  return 0;\n}\n'