b'{-# LANGUAGE OverloadedStrings #-}\n\nmodule Main\n(\n  main\n)\nwhere\n\nimport Pdf.Core.Object\nimport Pdf.Core.Writer\nimport Pdf.Document\n\nimport qualified Test.Internal.Util as Internal.Util\n\nimport qualified Data.HashMap.Strict as HashMap\nimport Control.Exception (bracket, finally)\nimport Control.Monad\nimport System.IO\nimport qualified System.IO.Streams as Streams\nimport System.Directory (getTemporaryDirectory, removeFile)\nimport System.Timeout\n\nimport Test.Hspec\n\nmain :: IO ()\nmain = hspec $ do\n  Internal.Util.spec\n\n  describe "simple.pdf" $ do\n    it "should have title" $\n      withSimpleFile $ \\h -> do\n        pdf <- fromHandle h\n        doc <- document pdf\n        maybe_info <- documentInfo doc\n        title <-\n          case maybe_info of\n            Nothing -> return Nothing\n            Just info -> infoTitle info\n        title `shouldBe` Just "simple PDF file"\n\n  describe "nested_xobject" $ do\n    it "should have correct text" $ do\n      withPdfFile "test/files/nested_xobject.pdf" $ \\pdf -> do\n        doc <- document pdf\n        catalog <- documentCatalog doc\n        root <- catalogPageNode catalog\n        page <- pageNodePageByNum root 0\n        -- here timeout breaks infinite loop in case of a bug\n        txt <- timeout 5000000 $ pageExtractText page\n        txt `shouldBe` Just\n          "\\nHello World!!!\\nXObject is here\\nnested XObject is here"\n\n  describe "FontDescription with indirect fields" $ do\n    it "should have correct text" $ do\n      withPdfFile "test/files/indirect_font_desc_fields.pdf" $ \\pdf -> do\n        doc <- document pdf\n        catalog <- documentCatalog doc\n        root <- catalogPageNode catalog\n        page <- pageNodePageByNum root 0\n        -- here timeout breaks infinite loop in case of a bug\n        txt <- timeout 5000000 $ pageExtractText page\n        txt `shouldBe` Just\n          "\\nHello World!!!\\nXObject is here\\nnested XObject is here"\n\n-- | Generate simple PDF file for tests\nwithSimpleFile :: (Handle -> IO ()) -> IO ()\nwithSimpleFile action = do\n  dir <- getTemporaryDirectory\n  bracket\n    (openBinaryTempFile dir "simple.pdf")\n    (\\(path, h) -> hClose h `finally` removeFile path)\n    $ \\(_, h) -> do\n      out <- Streams.handleToOutputStream h\n\n      writer <- makeWriter out\n      writeHeader writer\n      deleteObject writer (R 0 1) 65535\n      forM_ objects $ \\(ref, obj) ->\n        writeObject writer ref obj\n      writeXRefTable writer 0 tr\n\n      action h\n  where\n  tr = HashMap.fromList\n    [ ("Size", Number $ fromIntegral $ length objects + 1)\n    , ("Info", Ref infoRef)\n    ]\n  info = HashMap.fromList\n    [ ("Title", String "simple PDF file")\n    ]\n  objects =\n    [ (infoRef, Dict info)\n    ]\n  infoRef = R 1 0\n'