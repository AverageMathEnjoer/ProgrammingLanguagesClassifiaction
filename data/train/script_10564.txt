b"{-# LANGUAGE PolyKinds #-}\n{-# LANGUAGE UndecidableInstances #-}\nmodule Database.Beam.Schema.Lenses\n    ( tableLenses\n    , TableLens(..)\n\n    , dbLenses ) where\n\nimport Database.Beam.Schema.Tables\n\nimport Control.Monad.Identity\n\nimport Data.Kind (Type)\nimport Data.Proxy\n\nimport GHC.Generics\n\nimport Lens.Micro hiding (to)\n\nclass GTableLenses t (m :: Type -> Type) a (lensType :: Type -> Type) where\n    gTableLenses :: Proxy a -> Lens' (t m) (a p) -> lensType ()\ninstance GTableLenses t m a al => GTableLenses t m (M1 s d a) (M1 s d al) where\n    gTableLenses (Proxy :: Proxy (M1 s d a)) lensToHere = M1 $ gTableLenses (Proxy :: Proxy a) (\\f -> lensToHere (\\(M1 x) -> M1 <$> f x))\ninstance (GTableLenses t m a aLens, GTableLenses t m b bLens) => GTableLenses t m (a :*: b) (aLens :*: bLens) where\n    gTableLenses (Proxy :: Proxy (a :*: b)) lensToHere = leftLenses :*: rightLenses\n        where leftLenses = gTableLenses (Proxy :: Proxy a) (\\f -> lensToHere (\\(a :*: b) -> (:*: b) <$> f a))\n              rightLenses = gTableLenses (Proxy :: Proxy b) (\\f -> lensToHere (\\(a :*: b) -> (a :*:) <$> f b))\ninstance Generic (t m) => GTableLenses t m (K1 R x) (K1 R (LensFor (t m) x)) where\n    gTableLenses _ lensToHere = K1 (LensFor (\\f -> lensToHere (\\(K1 x) -> K1 <$> f x)))\n\ninstance ( Generic (sub m)\n         , Generic (sub (Lenses t m))\n         , GTableLenses t m (Rep (sub m)) (Rep (sub (Lenses t m))) ) =>\n         GTableLenses t m (K1 R (sub m)) (K1 R (sub (Lenses t m))) where\n    gTableLenses _ lensToHere = K1 (to (gTableLenses (Proxy :: Proxy (Rep (sub m))) (\\f -> lensToHere (\\(K1 x) -> K1 . to <$> f (from x)))))\n\ninstance ( Generic (sub (Nullable m))\n         , Generic (sub (Nullable (Lenses t m)))\n         , GTableLenses t m (Rep (sub (Nullable m))) (Rep (sub (Nullable (Lenses t m))))) =>\n         GTableLenses t m (K1 R (sub (Nullable m))) (K1 R (sub (Nullable (Lenses t m)))) where\n    gTableLenses _ lensToHere = K1 (to (gTableLenses (Proxy :: Proxy (Rep (sub (Nullable m)))) (\\f -> lensToHere (\\(K1 x) -> K1 . to <$> f (from x)))))\n\ntableLenses' :: ( lensType ~ Lenses t f\n                , Generic (t lensType)\n                , Generic (t f)\n                , GTableLenses t f (Rep (t f)) (Rep (t lensType)) ) =>\n                 Proxy t -> Proxy f -> t lensType\ntableLenses' (Proxy :: Proxy t) (Proxy :: Proxy f) =\n    to (gTableLenses (Proxy :: Proxy (Rep (t f))) ((\\f x -> to <$> f (from x)) :: Lens' (t f) (Rep (t f) ())))\n\n-- | Automatically deduce lenses for a table over any column tag. lenses at\n--   global level by doing a top-level pattern match on 'tableLenses', replacing\n--   every column in the pattern with `LensFor <nameOfLensForField>'. The lenses\n--   are generated per-column, not per field in the record. Thus if you have\n--   nested 'Beamable' types, lenses are generated for each nested field.\n--\n--   For example,\n--\n-- > data AuthorT f = AuthorT\n-- >                { _authorEmail     :: Columnar f Text\n-- >                , _authorFirstName :: Columnar f Text\n-- >                , _authorLastName  :: Columnar f Text }\n-- >                  deriving Generic\n-- >\n-- > data BlogPostT f = BlogPost\n-- >                  { _blogPostSlug    :: Columnar f Text\n-- >                  , _blogPostBody    :: Columnar f Text\n-- >                  , _blogPostDate    :: Columnar f UTCTime\n-- >                  , _blogPostAuthor  :: PrimaryKey AuthorT f\n-- >                  , _blogPostTagline :: Columnar f (Maybe Text) }\n-- >                    deriving Generic\n-- > instance Table BlogPostT where\n-- >    data PrimaryKey BlogPostT f = BlogPostId (Columnar f Text)\n-- >    primaryKey = BlogPostId . _blogPostSlug\n-- > instance Table AuthorT where\n-- >    data PrimaryKey AuthorT f = AuthorId (Columnar f Text)\n-- >    primaryKey = AuthorId . _authorEmail\n--\n-- > BlogPost (LensFor blogPostSlug\n-- >          (LensFor blogPostBody)\n-- >          (LensFor blogPostDate)\n-- >          (AuthorId (LensFor blogPostAuthorEmail))\n-- >          (LensFor blogPostTagLine) = tableLenses\n--\n--   Note: In order to have GHC deduce the right type, you will need to turn off\n--   the monomorphism restriction. This is a part of the Haskell standard that\n--   specifies that top-level definitions must be inferred to have a monomorphic\n--   type. However, lenses need a polymorphic type to work properly. You can\n--   turn off the monomorphism restriction by enabling the\n--   'NoMonomorphismRestriction' extension. You can do this per-file by using\n--   the {-# LANGUAGE NoMonomorphismRestriction #-} pragma at the top of the\n--   file. You can also pass the @-XNoMonomorphismRestriction@ command line flag\n--   to GHC during compilation.\ntableLenses :: ( lensType ~ Lenses t f\n                , Generic (t lensType)\n                , Generic (t f)\n                , GTableLenses t f (Rep (t f)) (Rep (t lensType)) ) =>\n               t (Lenses t f)\ntableLenses = let res = tableLenses' (tProxy res) (fProxy res)\n\n                  tProxy :: t (Lenses t f) -> Proxy t\n                  tProxy _ = Proxy\n                  fProxy :: t (Lenses t f) -> Proxy f\n                  fProxy _ = Proxy\n              in res\n\nnewtype TableLens f db (x :: k) = TableLens (Lens' (db f) (f x))\n\nclass GDatabaseLenses outer structure lensType where\n    gDatabaseLenses :: Lens' outer (structure p) -> lensType ()\ninstance GDatabaseLenses db a al => GDatabaseLenses db (M1 s d a) (M1 s d al) where\n    gDatabaseLenses lensToHere = M1 $ gDatabaseLenses (\\f -> lensToHere (\\(M1 x) -> M1 <$> f x))\ninstance (GDatabaseLenses db a al, GDatabaseLenses db b bl) => GDatabaseLenses db (a :*: b) (al :*: bl) where\n    gDatabaseLenses lensToHere = leftLenses :*: rightLenses\n        where leftLenses = gDatabaseLenses (\\f -> lensToHere (\\(a :*: b) -> (:*: b) <$> f a))\n              rightLenses = gDatabaseLenses (\\f -> lensToHere (\\(a :*: b) -> (a :*:) <$> f b))\ninstance GDatabaseLenses (db f) (K1 R (f x))\n                                (K1 R (TableLens f db x)) where\n    gDatabaseLenses lensToHere = K1 (TableLens (\\f -> lensToHere (\\(K1 x) -> K1 <$> f x)))\n\n-- | Like 'tableLenses' but for types that are instances of 'Database'. Instead\n--   of pattern matching on 'LensFor', pattern match on 'TableLens'.\ndbLenses :: ( Generic (db (TableLens f db))\n            , Generic (db f)\n            , GDatabaseLenses (db f) (Rep (db f)) (Rep (db (TableLens f db))) )\n           => db (TableLens f db)\ndbLenses = fix $ \\(_ :: db (TableLens f db)) ->\n           to (gDatabaseLenses (\\f (x :: db f) -> to <$> f (from x)) :: Rep (db (TableLens f db)) ())\n"