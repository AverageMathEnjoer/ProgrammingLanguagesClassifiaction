b'import Data.List\r\nimport System.Environment (getArgs)\r\n\r\ntransform :: Ord a => [a] -> ([a], Int)\r\ntransform xs = (map last xss, position xs xss)\r\n  where \r\n    xss = sort (rots xs)\r\n\r\nposition :: Eq a => a -> [a] -> Int\r\nposition xs xss = length (takeWhile (/= xs) xss)\r\n\r\nrots :: [a] -> [[a]]\r\nrots xs = take (length xs) (iterate lrot xs)\r\n  where\r\n    lrot :: [a] -> [a]\r\n    lrot [] = []\r\n    lrot (y:ys) = ys ++ [y]\r\n\r\ntakeCols :: Int -> [[a]] -> [[a]]\r\ntakeCols j = map (take j)\r\n\r\nrecreate :: Ord a => Int -> [a] -> [[a]]\r\nrecreate 0 = map (const [])\r\nrecreate j = hdsort . consCol . fork (id, recreate (j - 1))\r\n\r\n\r\nhdsort :: Ord a => [[a]] -> [[a]]\r\nhdsort = sortBy cmp\r\n  where \r\n    cmp (x:xs) (y:ys) = compare x y\r\n\r\nconsCol :: ([a], [[a]]) -> [[a]]\r\nconsCol (xs, xss) = zipWith (:) xs xss\r\n\r\nfork :: (a -> b, a -> c) -> a -> (b, c)\r\nfork (f, g) x = (f x, g x)\r\n\r\n-- Note: in the book, it doesn\'t mention that the first argument to the first \r\n-- call of `recreate` needs to be the length of the transformed string.\r\nuntransform :: Ord a => ([a], Int) -> [a]\r\nuntransform (ys, k) = (recreate (length ys) ys) !! k \r\n\r\nmain :: IO ()\r\nmain = do\r\n    args <- getArgs\r\n    hContents <- readFile (head args)\r\n    let result = untransform $ transform hContents\r\n    putStrLn $ if result == hContents then\r\n        "matched"\r\n    else\r\n        "NOT MATCHED"\r\n'