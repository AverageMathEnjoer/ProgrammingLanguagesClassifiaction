b'module Hoodle.Coroutine.Commit where\n\nimport Control.Lens (set, view, (.~))\nimport Control.Monad.State (get, liftIO, put)\nimport Hoodle.Accessor (pureUpdateUhdl, updateUhdl)\nimport Hoodle.Coroutine.Draw (callRenderer_, invalidateAll)\nimport Hoodle.GUI.Reflect (reflectUIToggle)\nimport Hoodle.ModelAction.Page (updatePageAll)\nimport Hoodle.Type.Coroutine (MainCoroutine)\nimport Hoodle.Type.HoodleState\n  ( HoodleState,\n    currentUnit,\n    getCurrentCanvasId,\n    gtkUIManager,\n    hoodleModeState,\n    isSaved,\n    resetHoodleModeStateBuffers,\n    undoTable,\n    unitHoodles,\n  )\nimport Hoodle.Type.Undo (addToUndo, emptyUndo, getNextUndo, getPrevUndo)\nimport Hoodle.Util (msgShout)\n\n-- | save state and add the current status in undo history\ncommit :: HoodleState -> MainCoroutine ()\ncommit xstate = do\n  put xstate\n  let ui = view gtkUIManager xstate\n  liftIO $ reflectUIToggle ui "SAVEA" True\n  pureUpdateUhdl $ \\uhdl ->\n    let hdlmodst = view hoodleModeState uhdl\n        undotable = view undoTable uhdl\n        undotable\' = addToUndo undotable hdlmodst\n     in ((isSaved .~ False) . (undoTable .~ undotable\')) uhdl\n\n-- |\ncommit_ :: MainCoroutine ()\ncommit_ = get >>= commit\n\n-- |\nundo :: MainCoroutine ()\nundo = do\n  xstate <- get\n  let uhdl = view (unitHoodles . currentUnit) xstate\n  let utable = view undoTable uhdl\n  case getPrevUndo utable of\n    Nothing -> msgShout "no undo item yet"\n    Just (hdlmodst, newtable) -> do\n      let cid = getCurrentCanvasId uhdl\n      callRenderer_ $ resetHoodleModeStateBuffers cid hdlmodst\n      updateUhdl $ \\uhdl\' -> do\n        uhdl\'\' <- liftIO (updatePageAll hdlmodst uhdl\')\n        return $ ((hoodleModeState .~ hdlmodst) . (undoTable .~ newtable)) uhdl\'\'\n      invalidateAll\n\n-- |\nredo :: MainCoroutine ()\nredo = do\n  xstate <- get\n  let uhdl = view (unitHoodles . currentUnit) xstate\n      utable = view undoTable uhdl\n      cid = getCurrentCanvasId uhdl\n  case getNextUndo utable of\n    Nothing -> msgShout "no redo item"\n    Just (hdlmodst, newtable) -> do\n      callRenderer_ $ resetHoodleModeStateBuffers cid hdlmodst\n      updateUhdl $ \\uhdl\' -> do\n        uhdl\'\' <- liftIO (updatePageAll hdlmodst uhdl\')\n        let uhdl\'\'\' =\n              ( set hoodleModeState hdlmodst\n                  . set undoTable newtable\n              )\n                uhdl\'\'\n        return uhdl\'\'\'\n      invalidateAll\n\n-- |\nclearUndoHistory :: MainCoroutine ()\nclearUndoHistory = pureUpdateUhdl (undoTable .~ emptyUndo 1)\n'