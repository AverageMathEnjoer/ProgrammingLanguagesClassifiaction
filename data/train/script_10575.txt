b'module IntMapValidity (valid) where\n\nimport Data.Bits (xor, (.&.))\nimport Data.IntMap.Internal\nimport Test.Tasty.QuickCheck (Property, counterexample, property, (.&&.))\nimport Utils.Containers.Internal.BitUtil (bitcount)\n\n{--------------------------------------------------------------------\n  Assertions\n--------------------------------------------------------------------}\n-- | Returns true iff the internal structure of the IntMap is valid.\nvalid :: IntMap a -> Property\nvalid t =\n  counterexample "nilNeverChildOfBin" (nilNeverChildOfBin t) .&&.\n  counterexample "commonPrefix" (commonPrefix t) .&&.\n  counterexample "maskRespected" (maskRespected t)\n\n-- Invariant: Nil is never found as a child of Bin.\nnilNeverChildOfBin :: IntMap a  -> Bool\nnilNeverChildOfBin t =\n  case t of\n    Nil -> True\n    Tip _ _ -> True\n    Bin _ _ l r -> noNilInSet l && noNilInSet r\n  where\n    noNilInSet t\' =\n      case t\' of\n        Nil -> False\n        Tip _ _ -> True\n        Bin _ _ l\' r\' -> noNilInSet l\' && noNilInSet r\'\n\n-- Invariant: The Mask is a power of 2. It is the largest bit position at which\n--            two keys of the map differ.\nmaskPowerOfTwo :: IntMap a -> Bool\nmaskPowerOfTwo t =\n  case t of\n    Nil -> True\n    Tip _ _ -> True\n    Bin _ m l r ->\n      bitcount 0 (fromIntegral m) == 1 && maskPowerOfTwo l && maskPowerOfTwo r\n\n-- Invariant: Prefix is the common high-order bits that all elements share to\n--            the left of the Mask bit.\ncommonPrefix :: IntMap a -> Bool\ncommonPrefix t =\n  case t of\n    Nil -> True\n    Tip _ _ -> True\n    b@(Bin p _ l r) -> all (sharedPrefix p) (keys b) && commonPrefix l && commonPrefix r\n  where\n    sharedPrefix :: Prefix -> Int -> Bool\n    sharedPrefix p a = p == p .&. a\n\n-- Invariant: In Bin prefix mask left right, left consists of the elements that\n--            don\'t have the mask bit set; right is all the elements that do.\nmaskRespected :: IntMap a -> Bool\nmaskRespected t =\n  case t of\n    Nil -> True\n    Tip _ _ -> True\n    Bin _ binMask l r ->\n      all (\\x -> zero x binMask) (keys l) &&\n      all (\\x -> not (zero x binMask)) (keys r) &&\n      maskRespected l &&\n      maskRespected r\n'