b'{-# LANGUAGE OverloadedStrings #-}\n\n-- | Font dictionary\n\nmodule Pdf.Document.FontDict\n(\n  FontDict,\n  FontSubtype(..),\n  fontDictSubtype,\n  fontDictLoadInfo,\n)\nwhere\n\nimport Pdf.Core.Object\nimport Pdf.Core.Object.Util\nimport Pdf.Core.Exception\nimport Pdf.Core.Util\nimport Pdf.Core.Types\nimport qualified Pdf.Core.Name as Name\nimport Pdf.Content\n\nimport Pdf.Document.Pdf\nimport Pdf.Document.Internal.Types\n\nimport Data.Word\nimport Data.ByteString (ByteString)\nimport qualified Data.Vector as Vector\nimport qualified Data.HashMap.Strict as HashMap\nimport Control.Monad\nimport Control.Exception hiding (throw)\nimport qualified System.IO.Streams as Streams\nimport Data.Text.Encoding (decodeUtf8With)\nimport Data.Text.Encoding.Error (ignore)\nimport qualified Data.Text as Text\n\n-- | Font subtypes\ndata FontSubtype\n  = FontType0\n  | FontType1\n  | FontMMType1\n  | FontType3\n  | FontTrueType\n  deriving (Show, Eq)\n\n-- | Get font subtype\nfontDictSubtype :: FontDict -> IO FontSubtype\nfontDictSubtype (FontDict pdf dict) = do\n  obj <- sure (HashMap.lookup "Subtype" dict\n              `notice` "Subtype should exist")\n            >>= deref pdf\n  str <- sure $ nameValue obj `notice` "Subtype should be a name"\n  case str of\n    "Type0" -> return FontType0\n    "Type1" -> return FontType1\n    "MMType1" -> return FontMMType1\n    "Type3" -> return FontType3\n    "TrueType" -> return FontTrueType\n    _ -> throwIO $ Unexpected ("Unexpected font subtype: " ++ show str) []\n\n-- | Load font info for the font\nfontDictLoadInfo :: FontDict -> IO FontInfo\nfontDictLoadInfo fd@(FontDict pdf fontDict) = do\n  subtype <- fontDictSubtype fd\n  case subtype of\n    FontType0 -> FontInfoComposite <$> loadFontInfoComposite pdf fontDict\n    FontType3 -> do\n      fi <- loadFontInfoSimple pdf fontDict\n      obj <- sure (HashMap.lookup "FontMatrix" fontDict\n                    `notice` "FontMatrix should exist")\n              >>= deref pdf\n      arr <- sure $ arrayValue obj\n                    `notice` "FontMatrix should be an array"\n      fontMatrix <-\n        case mapM realValue (Vector.toList arr) of\n          Just [a, b, c, d, e, f] -> do\n            return $ Transform a b c d e f\n          Nothing -> throwIO $ Corrupted "FontMatrics should contain numbers" []\n          _ -> throwIO $ Corrupted "FontMatrix: wrong number of elements" []\n      return $ FontInfoSimple fi {\n        fiSimpleFontMatrix = fontMatrix\n        }\n    _ -> FontInfoSimple <$> loadFontInfoSimple pdf fontDict\n\nloadFontInfoComposite :: Pdf -> Dict -> IO FIComposite\nloadFontInfoComposite pdf fontDict = do\n  toUnicode <- loadUnicodeCMap pdf fontDict\n\n  descFont <- do\n    descFontObj <- sure (HashMap.lookup "DescendantFonts" fontDict\n                          `notice` "DescendantFonts should exist")\n                    >>= deref pdf\n    descFontArr <- sure $ arrayValue descFontObj\n        `notice` "DescendantFonts should be an array"\n    case Vector.toList descFontArr of\n      [o] -> do\n        o\' <- deref pdf o\n        sure $ dictValue o\'\n                `notice` "DescendantFonts element should be a dictionary"\n      _ -> throwIO $ Corrupted\n            "Unexpected value of DescendantFonts key in font dictionary" []\n\n  defaultWidth <-\n    case HashMap.lookup "DW" descFont of\n      Nothing -> return 1000\n      Just o -> do\n        o\' <- deref pdf o\n        sure $ realValue o\' `notice` "DW should be real"\n\n  widths <-\n    case HashMap.lookup "W" descFont of\n      Nothing -> return mempty\n      Just o -> do\n        o\' <- deref pdf o\n        arr <- sure (arrayValue o\' `notice` "W should be an array")\n          >>= Vector.mapM (deref pdf)\n        sure $ makeCIDFontWidths arr\n\n  fontDescriptor <- loadFontDescriptor pdf descFont\n\n  return $ FIComposite {\n    fiCompositeUnicodeCMap = toUnicode,\n    fiCompositeWidths = widths,\n    fiCompositeDefaultWidth = defaultWidth,\n    fiCompositeFontDescriptor = fontDescriptor\n    }\n\nloadFontInfoSimple :: Pdf -> Dict -> IO FISimple\nloadFontInfoSimple pdf fontDict = do\n  toUnicode <- loadUnicodeCMap pdf fontDict\n\n  encoding <-\n    case HashMap.lookup "Encoding" fontDict of\n      Just (Name "WinAnsiEncoding") -> return $ Just SimpleFontEncoding\n        { simpleFontBaseEncoding = FontBaseEncodingWinAnsi\n        , simpleFontDifferences = []\n        }\n      Just (Name "MacRomanEncoding") -> return $ Just SimpleFontEncoding\n        { simpleFontBaseEncoding = FontBaseEncodingMacRoman\n        , simpleFontDifferences = []\n        }\n      Just o -> do\n        o\' <- deref pdf o\n        encDict <- sure (dictValue o\'\n                      `notice` "Encoding should be a dictionary")\n        case HashMap.lookup "BaseEncoding" encDict of\n          Just (Name "WinAnsiEncoding") -> do\n            diffs <- loadEncodingDifferences pdf encDict\n            return $ Just SimpleFontEncoding\n              { simpleFontBaseEncoding = FontBaseEncodingWinAnsi\n              , simpleFontDifferences = diffs\n              }\n          Just (Name "MacRomanEncoding") -> do\n            diffs <- loadEncodingDifferences pdf encDict\n            return $ Just SimpleFontEncoding\n              { simpleFontBaseEncoding = FontBaseEncodingMacRoman\n              , simpleFontDifferences = diffs\n              }\n          Nothing -> do\n            diffs <- loadEncodingDifferences pdf encDict\n            return $ Just SimpleFontEncoding\n              -- XXX: should be StandardEncoding?\n              { simpleFontBaseEncoding = FontBaseEncodingWinAnsi\n              , simpleFontDifferences = diffs\n              }\n          _ -> return Nothing\n      _ -> return Nothing\n\n  widths <-\n    case HashMap.lookup "Widths" fontDict of\n      Nothing -> return Nothing\n      Just v -> do\n        v\' <- deref pdf v\n        array <- sure $ arrayValue v\'\n            `notice` "Widths should be an array"\n        widths <- forM (Vector.toList array) $ \\o ->\n          sure (realValue o `notice` "Widths elements should be real")\n        firstChar <- sure $ (HashMap.lookup "FirstChar" fontDict >>= intValue)\n                `notice` "FirstChar should be an integer"\n        lastChar <- sure $ (HashMap.lookup "LastChar" fontDict >>= intValue)\n                `notice` "LastChar should be an integer"\n        return $ Just (firstChar, lastChar, widths)\n\n  fontDescriptor <- loadFontDescriptor pdf fontDict\n\n  return $ FISimple\n    { fiSimpleUnicodeCMap = toUnicode\n    , fiSimpleEncoding = encoding\n    , fiSimpleWidths = widths\n    , fiSimpleFontMatrix = scale 0.001 0.001\n    , fiSimpleFontDescriptor = fontDescriptor\n    }\n\nloadEncodingDifferences :: Pdf -> Dict -> IO [(Word8, ByteString)]\nloadEncodingDifferences pdf dict = do\n  case HashMap.lookup "Differences" dict of\n    Nothing -> return []\n    Just v -> do\n      v\' <- deref pdf v\n      arr <- sure $ arrayValue v\'\n          `notice` "Differences should be an array"\n      case Vector.toList arr of\n        [] -> return []\n        (o : rest) -> do\n          n\' <- fromIntegral <$> (sure $ intValue o\n                  `notice` "Differences: the first element should be integer")\n          go [] n\' rest\n  where\n  go res _ [] = return res\n  go res n (o:rest) =\n    case o of\n      (Number _) -> do\n        n\' <- fromIntegral <$> (sure $ intValue o\n          `notice` "Differences: elements should be integers")\n        go res n\' rest\n      (Name name) -> go (((n, Name.toByteString name)) : res) (n + 1) rest\n      _ -> throwIO $ Corrupted\n        ("Differences array: unexpected object: " ++ show o) []\n\nloadUnicodeCMap :: Pdf -> Dict -> IO (Maybe UnicodeCMap)\nloadUnicodeCMap pdf fontDict =\n  case HashMap.lookup "ToUnicode" fontDict of\n    Nothing -> return Nothing\n    Just o -> do\n      ref <- sure $ refValue o\n        `notice` "ToUnicode should be a reference"\n      toUnicode <- lookupObject pdf ref\n      case toUnicode of\n        Stream s -> do\n          is <- streamContent pdf ref s\n          content <- mconcat <$> Streams.toList is\n          case parseUnicodeCMap content of\n            Left e -> throwIO $ Corrupted ("can\'t parse cmap: " ++ show e) []\n            Right cmap -> return $ Just cmap\n        _ -> throwIO $ Corrupted "ToUnicode: not a stream" []\n\n\nloadFontDescriptor :: Pdf -> Dict -> IO (Maybe FontDescriptor)\nloadFontDescriptor pdf fontDict = do\n  case HashMap.lookup "FontDescriptor" fontDict of\n    Nothing -> return Nothing\n    Just o -> do\n      ref <- sure $ refValue o\n             `notice` "FontDescriptor should be a reference"\n      fd <- (sure . (`notice` "FontDescriptor: not a dictionary") . dictValue) =<<\n            lookupObject pdf ref\n\n      fontName <- required "FontName" nameValue\' fd\n      fontFamily <- optional "FontFamily" stringValue fd\n      fontStretch <- optional "FontStretch" nameValue\' fd\n      fontWeight <- optional "FontWeight" intValue fd\n      flags <- required "Flags" int64Value fd\n      fontBBox <- optional "FontBBox"\n        (join . fmap (either (const Nothing) Just . rectangleFromArray) . arrayValue) fd\n      italicAngle <- required "ItalicAngle" realValue fd\n      ascent <- optional "Ascent" realValue fd\n      descent <- optional "Descent" realValue fd\n      leading <- optional "Leading" realValue fd\n      capHeight <- optional "CapHeight" realValue fd\n      xHeight <- optional "XHeight" realValue fd\n      stemV <- optional "StemV" realValue fd\n      stemH <- optional "StemH" realValue fd\n      avgWidth <- optional "AvgWidth" realValue fd\n      maxWidth <- optional "MaxWidth" realValue fd\n      missingWidth <- optional "MissingWidth" realValue fd\n      charSet <- optional "CharSet" stringValue fd\n\n      return $ Just $ FontDescriptor\n        { fdFontName = fontName\n        , fdFontFamily = fontFamily\n        , fdFontStretch = fontStretch\n        , fdFontWeight = fontWeight\n        , fdFlags = flags\n        , fdFontBBox = fontBBox\n        , fdItalicAngle = italicAngle\n        , fdDescent = descent\n        , fdAscent = ascent\n        , fdLeading = leading\n        , fdCapHeight = capHeight\n        , fdXHeight = xHeight\n        , fdStemV = stemV\n        , fdStemH = stemH\n        , fdAvgWidth = avgWidth\n        , fdMaxWidth = maxWidth\n        , fdMissingWidth = missingWidth\n        , fdCharSet = charSet\n        }\n  where\n    required = requiredInDict pdf "FontDescriptor"\n    optional = optionalInDict pdf "FontDescriptor"\n    nameValue\' = fmap Name.toByteString . nameValue\n\n-- | Parse a value from a required field of a dictionary. This will\n-- raise an exception if a) the field is not present or b) the field\n-- value has a false type.\nrequiredInDict :: Pdf    -- ^ in case the field is a reference\n               -> String -- ^ a context for a failure notice\n               -> Name   -- ^ name of dictionary field\n               -> (Object -> Maybe a) -- ^ function for type-casting the object\n               -> Dict                -- ^ the dictionary\n               -> IO a\nrequiredInDict pdf context key typeFun dict = do\n  case HashMap.lookup key dict of\n    Nothing -> throwIO $ Corrupted (context ++ ": " ++ msg ++ " should exist") []\n    Just oIn -> do\n      o <- deref pdf oIn\n      case typeFun o of\n        Nothing -> throwIO $ Corrupted (context ++ ": " ++ msg ++ " type failure") []\n        Just v -> return v\n  where\n    msg = Text.unpack $ decodeUtf8With ignore $ Name.toByteString key\n\n-- | Parse a value from an optional field of a dictionary. This will\n-- raise an exception if the field value has a false type.\noptionalInDict :: Pdf -> String -> Name -> (Object -> Maybe a) -> Dict -> IO (Maybe a)\noptionalInDict pdf context key typeFun dict =\n  case HashMap.lookup key dict of\n    Nothing -> return Nothing\n    Just oIn -> do\n      o <- deref pdf oIn\n      case typeFun o of\n        Nothing -> throwIO $ Corrupted (context ++ ": " ++ msg ++ " type failure") []\n        Just v -> return $ Just v\n  where\n    msg = Text.unpack $ decodeUtf8With ignore $ Name.toByteString key\n'