b'// Copyright (c) 2022 Manuel Schneider\n\n#include "albert/logging.h"\n#include "albert/util/timeprinter.hpp"\n#include "query.h"\n#include <QtConcurrent>\nusing namespace std;\nusing albert::Item;\n\nuint Query::query_count = 0;\n\nQuery::Query(const std::set<albert::FallbackHandler*>& fallback_handlers,\n             albert::TriggerQueryHandler *query_handler,\n             QString string,\n             QString trigger):\n        fallback_handlers_(fallback_handlers),\n        query_handler_(query_handler),\n        string_(std::move(string)),\n        trigger_(std::move(trigger)),\n        synopsis_(query_handler->synopsis()),\n        query_id(query_count++)\n{\n    connect(&future_watcher_, &decltype(future_watcher_)::finished, this, &Query::finished);\n}\n\nQuery::~Query()\n{\n    // Avoid segfaults when handler write on a deleted query\n    if (!future_watcher_.isFinished()) {\n        WARN << QString("Busy wait on query: #%1").arg(query_id);\n        future_watcher_.waitForFinished();\n    }\n    DEBG << QString("Query deleted. [#%1 \'%2\']").arg(query_id).arg(string_);\n}\n\nconst QString &Query::trigger() const { return trigger_; }\n\nconst QString &Query::string() const { return string_; }\n\nconst QString &Query::synopsis() const { return synopsis_; }\n\nvoid Query::run()\n{\n    future_watcher_.setFuture(QtConcurrent::run([this](){\n        albert::TimePrinter tp(QString("TIME: %1 \xc2\xb5s [\'%2\':\'%3\']").arg("%1", query_handler_->id(), this->string()));\n        try {\n            for (auto *fallback_handler : fallback_handlers_)\n                fallbacks_.add(fallback_handler, fallback_handler->fallbacks(QString("%1%2").arg(trigger_, string_)));\n            this->query_handler_->handleTriggerQuery(*this);\n        } catch (const exception &e){\n            WARN << "Handler thread threw" << e.what();\n        }\n    }));\n}\n\nvoid Query::cancel() { valid_ = false; }\n\nbool Query::isValid() const { return valid_; }\n\nbool Query::isFinished() const { return future_watcher_.isFinished(); }\n\nQAbstractListModel &Query::matches() { return matches_; }\n\nQAbstractListModel &Query::fallbacks() { return fallbacks_; }\n\nQAbstractListModel *Query::matchActions(uint i) const { return matches_.buildActionsModel(i); }\n\nQAbstractListModel *Query::fallbackActions(uint i) const { return fallbacks_.buildActionsModel(i); }\n \nvoid Query::activateMatch(uint i, uint a) { matches_.activate(i, a); }\n\nvoid Query::activateFallback(uint i, uint a) { fallbacks_.activate(i, a); }\n\nvoid Query::add(const shared_ptr<Item> &item) { matches_.add(query_handler_, item); }\n\nvoid Query::add(shared_ptr<Item> &&item) { matches_.add(query_handler_, ::move(item)); }\n\nvoid Query::add(const vector<shared_ptr<Item>> &items) { matches_.add(query_handler_, items); }\n\nvoid Query::add(vector<shared_ptr<Item>> &&items) { matches_.add(query_handler_, ::move(items)); }\n\n\n'