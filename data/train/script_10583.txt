b'using System.Diagnostics;\n\nnamespace CS_SQLite3\n{\n  public partial class CSSQLite\n  {\n    /*\n    ** 2009 March 3\n    **\n    ** The author disclaims copyright to this source code.  In place of\n    ** a legal notice, here is a blessing:\n    **\n    **    May you do good and not evil.\n    **    May you find forgiveness for yourself and forgive others.\n    **    May you share freely, never taking more than you give.\n    **\n    *************************************************************************\n    **\n    ** This file contains the implementation of the sqlite3_unlock_notify()\n    ** API method and its associated functionality.\n    **\n    ** $Id: notify.c,v 1.4 2009/04/07 22:06:57 drh Exp $\n    **\n    *************************************************************************\n    **  Included in SQLite3 port to C#-SQLite;  2008 Noah B Hart\n    **  C#-SQLite is an independent reimplementation of the SQLite software library\n    **\n    **  $Header$\n    *************************************************************************\n    */\n    //#include "sqliteInt.h"\n    //#include "btreeInt.h"\n\n    /* Omit this entire file if SQLITE_ENABLE_UNLOCK_NOTIFY is not defined. */\n#if SQLITE_ENABLE_UNLOCK_NOTIFY\n\n/*\n** Public interfaces:\n**\n**   sqlite3ConnectionBlocked()\n**   sqlite3ConnectionUnlocked()\n**   sqlite3ConnectionClosed()\n**   sqlite3_unlock_notify()\n*/\n\n//#define assertMutexHeld() \\\nassert( sqlite3_mutex_held(sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_MASTER)) )\n\n/*\n** Head of a linked list of all sqlite3 objects created by this process\n** for which either sqlite3.pBlockingConnection or sqlite3.pUnlockConnection\n** is not NULL. This variable may only accessed while the STATIC_MASTER\n** mutex is held.\n*/\nstatic sqlite3 *SQLITE_WSD sqlite3BlockedList = 0;\n\n#if !NDEBUG\n/*\n** This function is a complex assert() that verifies the following\n** properties of the blocked connections list:\n**\n**   1) Each entry in the list has a non-NULL value for either\n**      pUnlockConnection or pBlockingConnection, or both.\n**\n**   2) All entries in the list that share a common value for\n**      xUnlockNotify are grouped together.\n**\n**   3) If the argument db is not NULL, then none of the entries in the\n**      blocked connections list have pUnlockConnection or pBlockingConnection\n**      set to db. This is used when closing connection db.\n*/\nstatic void checkListProperties(sqlite3 *db){\nsqlite3 *p;\nfor(p=sqlite3BlockedList; p; p=p->pNextBlocked){\nint seen = 0;\nsqlite3 *p2;\n\n/* Verify property (1) */\nassert( p->pUnlockConnection || p->pBlockingConnection );\n\n/* Verify property (2) */\nfor(p2=sqlite3BlockedList; p2!=p; p2=p2->pNextBlocked){\nif( p2->xUnlockNotify==p->xUnlockNotify ) seen = 1;\nassert( p2->xUnlockNotify==p->xUnlockNotify || !seen );\nassert( db==0 || p->pUnlockConnection!=db );\nassert( db==0 || p->pBlockingConnection!=db );\n}\n}\n}\n#else\n//# define checkListProperties(x)\n#endif\n\n/*\n** Remove connection db from the blocked connections list. If connection\n** db is not currently a part of the list, this function is a no-op.\n*/\nstatic void removeFromBlockedList(sqlite3 *db){\nsqlite3 **pp;\nassertMutexHeld();\nfor(pp=&sqlite3BlockedList; *pp; pp = &(*pp)->pNextBlocked){\nif( *pp==db ){\n*pp = (*pp)->pNextBlocked;\nbreak;\n}\n}\n}\n\n/*\n** Add connection db to the blocked connections list. It is assumed\n** that it is not already a part of the list.\n*/\nstatic void addToBlockedList(sqlite3 *db){\nsqlite3 **pp;\nassertMutexHeld();\nfor(\npp=&sqlite3BlockedList;\n*pp && (*pp)->xUnlockNotify!=db->xUnlockNotify;\npp=&(*pp)->pNextBlocked\n);\ndb->pNextBlocked = *pp;\n*pp = db;\n}\n\n/*\n** Obtain the STATIC_MASTER mutex.\n*/\nstatic void enterMutex(){\nsqlite3_mutex_enter(sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_MASTER));\ncheckListProperties(0);\n}\n\n/*\n** Release the STATIC_MASTER mutex.\n*/\nstatic void leaveMutex(){\nassertMutexHeld();\ncheckListProperties(0);\nsqlite3_mutex_leave(sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_MASTER));\n}\n\n/*\n** Register an unlock-notify callback.\n**\n** This is called after connection "db" has attempted some operation\n** but has received an SQLITE_LOCKED error because another connection\n** (call it pOther) in the same process was busy using the same shared\n** cache.  pOther is found by looking at db->pBlockingConnection.\n**\n** If there is no blocking connection, the callback is invoked immediately,\n** before this routine returns.\n**\n** If pOther is already blocked on db, then report SQLITE_LOCKED, to indicate\n** a deadlock.\n**\n** Otherwise, make arrangements to invoke xNotify when pOther drops\n** its locks.\n**\n** Each call to this routine overrides any prior callbacks registered\n** on the same "db".  If xNotify==0 then any prior callbacks are immediately\n** cancelled.\n*/\nint sqlite3_unlock_notify(\nsqlite3 *db,\nvoid (*xNotify)(void **, int),\nvoid *pArg\n){\nint rc = SQLITE_OK;\n\nsqlite3_mutex_enter(db->mutex);\nenterMutex();\n\nif( xNotify==0 ){\nremoveFromBlockedList(db);\ndb->pUnlockConnection = 0;\ndb->xUnlockNotify = 0;\ndb->pUnlockArg = 0;\n}else if( 0==db->pBlockingConnection ){\n/* The blocking transaction has been concluded. Or there never was a\n** blocking transaction. In either case, invoke the notify callback\n** immediately.\n*/\nxNotify(&pArg, 1);\n}else{\nsqlite3 *p;\n\nfor(p=db->pBlockingConnection; p && p!=db; p=p->pUnlockConnection){}\nif( p ){\nrc = SQLITE_LOCKED;              /* Deadlock detected. */\n}else{\ndb->pUnlockConnection = db->pBlockingConnection;\ndb->xUnlockNotify = xNotify;\ndb->pUnlockArg = pArg;\nremoveFromBlockedList(db);\naddToBlockedList(db);\n}\n}\n\nleaveMutex();\nassert( !db->mallocFailed );\nsqlite3Error(db, rc, (rc?"database is deadlocked":0));\nsqlite3_mutex_leave(db->mutex);\nreturn rc;\n}\n\n/*\n** This function is called while stepping or preparing a statement\n** associated with connection db. The operation will return SQLITE_LOCKED\n** to the user because it requires a lock that will not be available\n** until connection pBlocker concludes its current transaction.\n*/\nvoid sqlite3ConnectionBlocked(sqlite3 *db, sqlite3 *pBlocker){\nenterMutex();\nif( db->pBlockingConnection==0 && db->pUnlockConnection==0 ){\naddToBlockedList(db);\n}\ndb->pBlockingConnection = pBlocker;\nleaveMutex();\n}\n\n/*\n** This function is called when\n** the transaction opened by database db has just finished. Locks held\n** by database connection db have been released.\n**\n** This function loops through each entry in the blocked connections\n** list and does the following:\n**\n**   1) If the sqlite3.pBlockingConnection member of a list entry is\n**      set to db, then set pBlockingConnection=0.\n**\n**   2) If the sqlite3.pUnlockConnection member of a list entry is\n**      set to db, then invoke the configured unlock-notify callback and\n**      set pUnlockConnection=0.\n**\n**   3) If the two steps above mean that pBlockingConnection==0 and\n**      pUnlockConnection==0, remove the entry from the blocked connections\n**      list.\n*/\nvoid sqlite3ConnectionUnlocked(sqlite3 *db){\nvoid (*xUnlockNotify)(void **, int) = 0; /* Unlock-notify cb to invoke */\nint nArg = 0;                            /* Number of entries in aArg[] */\nsqlite3 **pp;                            /* Iterator variable */\nvoid **aArg;               /* Arguments to the unlock callback */\nvoid **aDyn = 0;           /* Dynamically allocated space for aArg[] */\nvoid *aStatic[16];         /* Starter space for aArg[].  No malloc required */\n\naArg = aStatic;\nenterMutex();         /* Enter STATIC_MASTER mutex */\n\n/* This loop runs once for each entry in the blocked-connections list. */\nfor(pp=&sqlite3BlockedList; *pp; /* no-op */ ){\nsqlite3 *p = *pp;\n\n/* Step 1. */\nif( p->pBlockingConnection==db ){\np->pBlockingConnection = 0;\n}\n\n/* Step 2. */\nif( p->pUnlockConnection==db ){\nassert( p->xUnlockNotify );\nif( p->xUnlockNotify!=xUnlockNotify && nArg!=0 ){\nxUnlockNotify(aArg, nArg);\nnArg = 0;\n}\n\nsqlite3BeginBenignMalloc();\nassert( aArg==aDyn || (aDyn==0 && aArg==aStatic) );\nassert( nArg<=(int)ArraySize(aStatic) || aArg==aDyn );\nif( (!aDyn && nArg==(int)ArraySize(aStatic))\n|| (aDyn && nArg==(int)(sqlite3DbMallocSize(db, aDyn)/sizeof(void*)))\n){\n/* The aArg[] array needs to grow. */\nvoid **pNew = (void **)sqlite3Malloc(nArg*sizeof(void *)*2);\nif( pNew ){\nmemcpy(pNew, aArg, nArg*sizeof(void *));\n//sqlite3_free(aDyn);\naDyn = aArg = pNew;\n}else{\n/* This occurs when the array of context pointers that need to\n** be passed to the unlock-notify callback is larger than the\n** aStatic[] array allocated on the stack and the attempt to\n** allocate a larger array from the heap has failed.\n**\n** This is a difficult situation to handle. Returning an error\n** code to the caller is insufficient, as even if an error code\n** is returned the transaction on connection db will still be\n** closed and the unlock-notify callbacks on blocked connections\n** will go unissued. This might cause the application to wait\n** indefinitely for an unlock-notify callback that will never\n** arrive.\n**\n** Instead, invoke the unlock-notify callback with the context\n** array already accumulated. We can then clear the array and\n** begin accumulating any further context pointers without\n** requiring any dynamic allocation. This is sub-optimal because\n** it means that instead of one callback with a large array of\n** context pointers the application will receive two or more\n** callbacks with smaller arrays of context pointers, which will\n** reduce the applications ability to prioritize multiple\n** connections. But it is the best that can be done under the\n** circumstances.\n*/\nxUnlockNotify(aArg, nArg);\nnArg = 0;\n}\n}\nsqlite3EndBenignMalloc();\n\naArg[nArg++] = p->pUnlockArg;\nxUnlockNotify = p->xUnlockNotify;\np->pUnlockConnection = 0;\np->xUnlockNotify = 0;\np->pUnlockArg = 0;\n}\n\n/* Step 3. */\nif( p->pBlockingConnection==0 && p->pUnlockConnection==0 ){\n/* Remove connection p from the blocked connections list. */\n*pp = p->pNextBlocked;\np->pNextBlocked = 0;\n}else{\npp = &p->pNextBlocked;\n}\n}\n\nif( nArg!=0 ){\nxUnlockNotify(aArg, nArg);\n}\n//sqlite3_free(aDyn);\nleaveMutex();         /* Leave STATIC_MASTER mutex */\n}\n\n/*\n** This is called when the database connection passed as an argument is\n** being closed. The connection is removed from the blocked list.\n*/\nvoid sqlite3ConnectionClosed(sqlite3 *db){\nsqlite3ConnectionUnlocked(db);\nenterMutex();\nremoveFromBlockedList(db);\ncheckListProperties(db);\nleaveMutex();\n}\n#endif\n  }\n}\n'