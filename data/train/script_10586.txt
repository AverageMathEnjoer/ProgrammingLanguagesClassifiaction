b'#include <bits/stdc++.h>\nusing namespace std;\n#define gc getchar_unlocked\n#define fo(i,n) for(i=0;i<n;i++)\n#define Fo(i,k,n) for(i=k;k<n?i<n:i>n;k<n?i+=1:i-=1)\n#define ll long long\n#define si(x)\tscanf("%d",&x)\n#define sl(x)\tscanf("%I64d",&x)\n#define ss(s)\tscanf("%s",s)\n#define pb push_back\n#define mp make_pair\n#define F first\n#define S second\n#define all(x) x.begin(), x.end()\n#define clr(x) memset(x, 0, sizeof(x))\n#define sortall(x) sort(all(x))\n#define tr(it, a) for(auto it = a.begin(); it != a.end(); it++)\n#define PI 3.1415926535897932384626\ntypedef pair<int, int>\tpii;\ntypedef pair<ll, ll>\tpll;\ntypedef vector<int>\t\tvi;\ntypedef vector<ll>\t\tvl;\ntypedef vector<pii>\t\tvpii;\ntypedef vector<pll>\t\tvpll;\ntypedef vector<vi>\t\tvvi;\ntypedef vector<vl>\t\tvvl;\nconst int mod = 1000000007;\nint mpow(int base, int exp); \nvoid ipgraph(int n, int m);\nvoid dfs(int u, int par);\n//2d sparse table for max\n//0 based index\n//LGN = 1 + lg2(N)\n//LGM = 1 + lg2(M)\n\nconst int N = 1030;\nconst int M = 1030;\nconst int LGN = 11;\nconst int LGM = 11;\nvi g[N];\nint a[N][M];\nint dp[N][LGN][M][LGM];\nconst int MAXN = 2e6; //max(N, M)\nint lg2[MAXN];\nvoid pre(){\n\t//build lg2\n\tlg2[1] = 0;\n\tlg2[2] = 1;\n\tint val = 1, at = 4;\n\tint i;\n\tFo(i, 3, MAXN){\n\t\tif (i == at){\n\t\t\tat *= 2;\n\t\t\tval++;\n\t\t}\n\t\tlg2[i] = val;\n\t}\n}\nvoid build(int n, int m){\n\tint ir, ic, jr, jc;\n\t//unit cells\n\tfo(ir, n)\n\tfo(ic, m) dp[0][ir][0][ic] = a[ir][ic];\n\t\n\t//fill 1-d sparse table for all rows\n\tfo(ir, n)\n\t\tFo(jc, 1, LGM)\n\t\tfor(ic = 0; ic + (1<<jc) <= m; ic++)\n\t\t\tdp[0][ir][jc][ic] = max(dp[0][ir][jc-1][ic], dp[0][ir][jc-1][ic+(1<<(jc-1))]);\n\t\n\t//fill 2-d sparse table\n\tFo(jr, 1, LGN)\n\tfor(ir = 0; ir + (1<<jr) <= n; ir++)\n\t\tFo(jc, 0, LGN)\n\t\tfor(ic = 0; ic + (1<<jc) <= n; ic++)\n\t\t\tdp[jr][ir][jc][ic] = max( dp[jr-1][ir][jc][ic], dp[jr-1][ir+(1<<(jr-1))][jc][ic] );\n}\nint query(int x1, int y1, int x2, int y2){\n\tint k1 = lg2[x2-x1+1];\n\tint k2 = lg2[y2-y1+1];\n\tint a1 = 0, a2 = 0;\n\ta1 = max( dp[k1][x1][k2][y1], dp[k1][x1][k2][y2-(1<<k2)+1] );\n\ta2 = max( dp[k1][x2-(1<<k1)+1][k2][y1], dp[k1][x2-(1<<k1)+1][k2][y2-(1<<k2)+1] );\n\treturn max(a1, a2);\n}\nint main()\n{\n\tios_base::sync_with_stdio(false);\n\tcin.tie(NULL);\n\tint i,n,k,j,m;\n\tcin>>n>>m;\n\tfo(i,n)fo(j, m)cin>>a[i][j];\n\tbuild(n, m);\n\tcout<<query(1,2,2,3);\n\t\n\t\n\treturn 0;\n} \n\nint mpow(int base, int exp) {\n\tbase %= mod;\n\tint result = 1;\n\twhile (exp > 0) {\n\tif (exp & 1) result = ((ll)result * base) % mod;\n\tbase = ((ll)base * base) % mod;\n\texp >>= 1;\n\t}\n\treturn result;\n}\n\nvoid ipgraph(int n, int m){\n\tint i, u, v;\n\twhile(m--){\n\t\tcin>>u>>v;\n\t\tg[u-1].pb(v-1);\n\t\tg[v-1].pb(u-1);\n\t}\n}\n\nvoid dfs(int u, int par){\nfor(int v:g[u]){\n\tif (v == par) continue;\n\tdfs(v, u);\n}\n}#include <bits/stdc++.h>\nusing namespace std;\n#define gc getchar_unlocked\n#define fo(i,n) for(i=0;i<n;i++)\n#define Fo(i,k,n) for(i=k;k<n?i<n:i>n;k<n?i+=1:i-=1)\n#define ll long long\n#define si(x)\tscanf("%d",&x)\n#define sl(x)\tscanf("%I64d",&x)\n#define ss(s)\tscanf("%s",s)\n#define pb push_back\n#define mp make_pair\n#define F first\n#define S second\n#define all(x) x.begin(), x.end()\n#define clr(x) memset(x, 0, sizeof(x))\n#define sortall(x) sort(all(x))\n#define tr(it, a) for(auto it = a.begin(); it != a.end(); it++)\n#define PI 3.1415926535897932384626\ntypedef pair<int, int>\tpii;\ntypedef pair<ll, ll>\tpll;\ntypedef vector<int>\t\tvi;\ntypedef vector<ll>\t\tvl;\ntypedef vector<pii>\t\tvpii;\ntypedef vector<pll>\t\tvpll;\ntypedef vector<vi>\t\tvvi;\ntypedef vector<vl>\t\tvvl;\nconst int mod = 1000000007;\n\n//2d sparse table for max\n//0 based index\n//LGN = 1 + lg2(N)\n//LGM = 1 + lg2(M)\n\nconst int N = 1030;\nconst int M = 1030;\nconst int LGN = 11;\nconst int LGM = 11;\nvi g[N];\nint a[N][M];\nint dp[N][LGN][M][LGM];\nconst int MAXN = 2e6; //max(N, M)\nint lg2[MAXN];\nvoid pre(){\n\t//build lg2\n\tlg2[1] = 0;\n\tlg2[2] = 1;\n\tint val = 1, at = 4;\n\tint i;\n\tFo(i, 3, MAXN){\n\t\tif (i == at){\n\t\t\tat *= 2;\n\t\t\tval++;\n\t\t}\n\t\tlg2[i] = val;\n\t}\n}\nvoid build(int n, int m){\n\tpre();\n\tint ir, ic, jr, jc;\n\t//unit cells\n\tfo(ir, n)\n\tfo(ic, m) dp[0][ir][0][ic] = a[ir][ic];\n\t\n\t//fill 1-d sparse table for all rows\n\tfo(ir, n)\n\t\tFo(jc, 1, LGM)\n\t\tfor(ic = 0; ic + (1<<jc) <= m; ic++)\n\t\t\tdp[0][ir][jc][ic] = max(dp[0][ir][jc-1][ic], dp[0][ir][jc-1][ic+(1<<(jc-1))]);\n\t\n\t//fill 2-d sparse table\n\tFo(jr, 1, LGN)\n\tfor(ir = 0; ir + (1<<jr) <= n; ir++)\n\t\tFo(jc, 0, LGN)\n\t\tfor(ic = 0; ic + (1<<jc) <= m; ic++)\n\t\t\tdp[jr][ir][jc][ic] = max( dp[jr-1][ir][jc][ic], dp[jr-1][ir+(1<<(jr-1))][jc][ic] );\n}\nint query(int x1, int y1, int x2, int y2){\n\tint k1 = lg2[x2-x1+1];\n\tint k2 = lg2[y2-y1+1];\n\tint a1 = 0, a2 = 0;\n\ta1 = max( dp[k1][x1][k2][y1], dp[k1][x1][k2][y2-(1<<k2)+1] );\n\ta2 = max( dp[k1][x2-(1<<k1)+1][k2][y1], dp[k1][x2-(1<<k1)+1][k2][y2-(1<<k2)+1] );\n\treturn max(a1, a2);\n}\nint main()\n{\n\tios_base::sync_with_stdio(false);\n\tcin.tie(NULL);\n\tint i,n,k,j,m;\n\tcin>>n>>m;\n\tfo(i,n)fo(j, m)cin>>a[i][j];\n\tbuild(n, m);\n\tcout<<query(1,2,2,3);\n\t\n\t\n\treturn 0;\n} \n\n'