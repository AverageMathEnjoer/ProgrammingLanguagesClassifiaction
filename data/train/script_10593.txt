b'/*\n    SPDX-FileCopyrightText: 2015-2017 Milian Wolff <mail@milianw.de>\n\n    SPDX-License-Identifier: LGPL-2.1-or-later\n*/\n\n#include <QApplication>\n#include <QCommandLineParser>\n\n#include <kcoreaddons_version.h>\n#include <KAboutData>\n#include <KLocalizedString>\n\n#include "analyze/suppressions.h"\n#include "util/config.h"\n\n#include "gui_config.h"\n#include "mainwindow.h"\n#include "proxystyle.h"\n\n#include <KIconTheme>\n#include <QFile>\n#include <QResource>\n\n// FIXME: patch KIconTheme so that this isn\'t needed here\nvoid Q_DECL_UNUSED initRCCIconTheme()\n{\n    const QString iconThemeRcc = qApp->applicationDirPath() + QStringLiteral("/../share/icons/breeze/breeze-icons.rcc");\n    if (!QFile::exists(iconThemeRcc)) {\n        qWarning("cannot find icons rcc: %ls", qUtf16Printable(iconThemeRcc));\n        return;\n    }\n\n    const QString iconThemeName = QStringLiteral("kf5_rcc_theme");\n    const QString iconSubdir = QStringLiteral("/icons/") + iconThemeName;\n    if (!QResource::registerResource(iconThemeRcc, iconSubdir)) {\n        qWarning("Invalid rcc file: %ls", qUtf16Printable(iconThemeRcc));\n    }\n\n    if (!QFile::exists(QLatin1Char(\':\') + iconSubdir + QStringLiteral("/index.theme"))) {\n        qWarning("No index.theme found in %ls", qUtf16Printable(iconThemeRcc));\n        QResource::unregisterResource(iconThemeRcc, iconSubdir);\n    }\n\n    // Tell Qt about the theme\n    // Note that since qtbase commit a8621a3f8, this means the QPA (i.e. KIconLoader) will NOT be used.\n    QIcon::setThemeName(iconThemeName); // Qt looks under :/icons automatically\n    // Tell KIconTheme about the theme, in case KIconLoader is used directly\n    KIconTheme::forceThemeForTests(iconThemeName);\n}\n\nint main(int argc, char** argv)\n{\n    QApplication::setAttribute(Qt::AA_UseHighDpiPixmaps);\n\n    QApplication app(argc, argv);\n    app.setStyle(new ProxyStyle);\n\n#if APPIMAGE_BUILD\n    initRCCIconTheme();\n#endif\n\n    KLocalizedString::setApplicationDomain("heaptrack");\n\n    KAboutData aboutData(QStringLiteral("heaptrack_gui"), i18n("Heaptrack GUI"),\n                         QStringLiteral(HEAPTRACK_VERSION_STRING), i18n("A visualizer for heaptrack data files."),\n                         KAboutLicense::LGPL, i18n("Copyright 2015, Milian Wolff <mail@milianw.de>"), QString(),\n                         QStringLiteral("mail@milianw.de"));\n\n    aboutData.addAuthor(i18n("Milian Wolff"), i18n("Original author, maintainer"), QStringLiteral("mail@milianw.de"),\n                        QStringLiteral("http://milianw.de"));\n\n    aboutData.setOrganizationDomain("kde.org");\n#if KCOREADDONS_VERSION >= QT_VERSION_CHECK(5, 16, 0)\n    aboutData.setDesktopFileName(QStringLiteral("org.kde.heaptrack"));\n#endif\n    KAboutData::setApplicationData(aboutData);\n    app.setWindowIcon(QIcon(QStringLiteral(":/512-heaptrack_app_icon.png")));\n\n    QCommandLineParser parser;\n    aboutData.setupCommandLine(&parser);\n\n    QCommandLineOption diffOption{{QStringLiteral("d"), QStringLiteral("diff")},\n                                  i18n("Base profile data to compare other files to."),\n                                  QStringLiteral("<file>")};\n    parser.addOption(diffOption);\n    QCommandLineOption suppressionsOption {\n        {QStringLiteral("s"), QStringLiteral("suppressions")},\n        i18n("Load list of leak suppressions from the specified file. Specify one suppression per line, and start each "\n             "line with \'leak:\', i.e. use the LSAN suppression file format."),\n        QStringLiteral("<file>")};\n    parser.addOption(suppressionsOption);\n    QCommandLineOption disableEmbeddedSuppressionsOption {\n        {QStringLiteral("disable-embedded-suppressions")},\n        i18n("Ignore suppression definitions that are embedded into the heaptrack data file. By default, heaptrack "\n             "will copy the suppressions optionally defined via a `const char *__lsan_default_suppressions()` symbol "\n             "in the debuggee application.  These are then always applied when analyzing the data, unless this feature "\n             "is explicitly disabled using this command line option.")};\n    parser.addOption(disableEmbeddedSuppressionsOption);\n    QCommandLineOption disableBuiltinSuppressionsOption {\n        {QStringLiteral("disable-builtin-suppressions")},\n        i18n(\n            "Ignore suppression definitions that are built into heaptrack. By default, heaptrack will suppress certain "\n            "known leaks in common system libraries.")};\n    parser.addOption(disableBuiltinSuppressionsOption);\n    parser.addPositionalArgument(QStringLiteral("files"), i18n("Files to load"), i18n("[FILE...]"));\n\n    parser.process(app);\n    aboutData.processCommandLine(&parser);\n\n    bool parsedOk = false;\n    const auto suppressions = parseSuppressions(parser.value(suppressionsOption).toStdString(), &parsedOk);\n    if (!parsedOk) {\n        return 1;\n    }\n\n    auto createWindow = [&]() -> MainWindow* {\n        auto window = new MainWindow;\n        window->setAttribute(Qt::WA_DeleteOnClose);\n        window->setSuppressions(suppressions);\n        window->setDisableEmbeddedSuppressions(parser.isSet(disableEmbeddedSuppressionsOption));\n        window->setDisableBuiltinSuppressions(parser.isSet(disableBuiltinSuppressionsOption));\n        window->show();\n        return window;\n    };\n\n    const auto files = parser.positionalArguments();\n    for (const auto& file : files) {\n        createWindow()->loadFile(file, parser.value(diffOption));\n    }\n\n    if (files.isEmpty()) {\n        createWindow();\n    }\n\n#if APPIMAGE_BUILD\n    // cleanup the environment when we are running from within the AppImage\n    // to allow launching system applications using Qt without them loading\n    // the bundled Qt we ship in the AppImage\n    auto LD_LIBRARY_PATH = qgetenv("LD_LIBRARY_PATH");\n    LD_LIBRARY_PATH.remove(0, LD_LIBRARY_PATH.indexOf(\':\') + 1);\n    qputenv("LD_LIBRARY_PATH", LD_LIBRARY_PATH);\n#endif\n\n    return app.exec();\n}\n'