b'{-# LANGUAGE\n    CPP\n  , NoImplicitPrelude\n  , OverloadedStrings\n  , RankNTypes\n  #-}\n#if MIN_VERSION_base(4,9,0)\n{-# OPTIONS_GHC -Wno-redundant-constraints #-}\n#endif\nmodule Rest.Driver.Wai (apiToApplication) where\n\nimport Prelude.Compat\n\nimport Control.Arrow ((***))\nimport Control.Monad.Trans (lift)\nimport Network.HTTP.Types.Status (status200)\nimport Network.Mime (defaultMimeMap)\nimport Network.Wai\nimport qualified Data.ByteString.Char8 as Char8\nimport qualified Data.ByteString.Lazy  as Lazy\nimport qualified Data.CaseInsensitive  as CI\nimport qualified Data.HashMap.Strict   as HashMap\nimport qualified Data.Map              as Map\nimport qualified Data.Text             as Text\n\nimport Rest.Api (Api)\nimport Rest.Driver.RestM (RestInput (..), RestOutput (..), runRestM)\nimport Rest.Driver.Types (Run)\nimport qualified Rest.Driver.Types as Rest\nimport qualified Rest.Run          as Rest\n\napiToApplication :: (Applicative m, Monad m) => Run m IO -> Api m -> Application\napiToApplication run api req =\n#if MIN_VERSION_wai(3,0,0)\n  \\cont ->\n  do ri <- toRestInput req\n     (bs, ro) <- runRestM ri (Rest.apiToHandler\' (lift . run) api)\n     cont (fromRestOutput ro bs)\n#else\n  do ri <- toRestInput req\n     (bs, ro) <- runRestM ri (Rest.apiToHandler\' (lift . run) api)\n     return $ fromRestOutput ro bs\n#endif\n\ntoRestInput :: Request -> IO RestInput\ntoRestInput req =\n  do bs <- lazyRequestBody req\n     return RestInput\n       { headers    = HashMap.fromList\n                    . map (CI.mk . string . CI.original *** string)\n                    . requestHeaders\n                    $ req\n\n       , parameters = HashMap.fromList\n                    . map (string *** maybe "" string)\n                    . queryString\n                    $ req\n\n       , body       = bs\n\n       , method     = case requestMethod req of\n                        "GET"    -> Just Rest.GET\n                        "POST"   -> Just Rest.POST\n                        "PUT"    -> Just Rest.PUT\n                        "DELETE" -> Just Rest.DELETE\n                        _        -> Nothing\n\n       , paths      = text <$> filter (not . Text.null) (pathInfo req)\n\n       , mimeTypes  = HashMap.fromList\n                    . fmap (text *** string)\n                    $ Map.toList defaultMimeMap\n       }\n     where string = Char8.unpack\n           text   = Text.unpack\n\nfromRestOutput :: RestOutput -> Lazy.ByteString -> Response\nfromRestOutput (RestOutput hs rc) =\n  responseLBS (maybe status200 toEnum rc)\n              ((CI.mk . Char8.pack *** Char8.pack) <$> HashMap.toList hs)\n'