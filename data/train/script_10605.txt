b'{-# LANGUAGE DeriveAnyClass #-}\n{-# LANGUAGE UndecidableInstances #-}\n{-# LANGUAGE LambdaCase #-}\n{-# LANGUAGE EmptyCase #-}\nmodule Database.Beam.Postgres.CustomTypes\n    ( PgType, PgTypeCheck(..)\n    , PgDataTypeSchema\n\n    , IsPgCustomDataType(..)\n\n    , PgHasEnum(..)\n\n    , HasSqlValueSyntax, FromBackendRow\n\n    , pgCustomEnumSchema, pgBoundedEnumSchema\n\n    , pgCustomEnumActionProvider\n    , pgCreateEnumActionProvider\n    , pgDropEnumActionProvider\n\n    , pgChecksForTypeSchema\n\n    , pgEnumValueSyntax, pgParseEnum\n\n    , createEnum\n    , beamTypeForCustomPg\n    ) where\n\nimport           Database.Beam\nimport           Database.Beam.Schema.Tables\nimport           Database.Beam.Backend.SQL\nimport           Database.Beam.Migrate\nimport           Database.Beam.Postgres.Types\nimport           Database.Beam.Postgres.Syntax\n\nimport           Control.Monad\nimport           Control.Monad.Free.Church\nimport           Data.Aeson (object, (.=))\nimport qualified Data.ByteString.Char8 as BC\nimport           Data.Functor.Const\nimport qualified Data.HashSet as HS\nimport           Data.Proxy (Proxy(..))\n#if !MIN_VERSION_base(4,11,0)\nimport           Data.Semigroup\n#endif\nimport           Data.Text (Text)\nimport qualified Data.Text.Encoding as TE\n\nimport qualified Database.PostgreSQL.Simple.FromField as Pg\n\ndata PgType a\nnewtype PgTypeCheck = PgTypeCheck (Text -> SomeDatabasePredicate)\n\ndata PgDataTypeSchema a where\n    PgDataTypeEnum :: HasSqlValueSyntax PgValueSyntax a => [a] -> PgDataTypeSchema a\n\nclass IsPgCustomDataType a where\n    pgDataTypeName :: Proxy a -> Text\n    pgDataTypeDescription :: PgDataTypeSchema a\n\npgCustomEnumSchema :: HasSqlValueSyntax PgValueSyntax a => [a] -> PgDataTypeSchema a\npgCustomEnumSchema = PgDataTypeEnum\n\npgBoundedEnumSchema :: ( Enum a, Bounded a, HasSqlValueSyntax PgValueSyntax a )\n                    => PgDataTypeSchema a\npgBoundedEnumSchema = pgCustomEnumSchema [minBound..maxBound]\n\npgCustomEnumActionProvider :: ActionProvider Postgres\npgCustomEnumActionProvider = pgCreateEnumActionProvider <> pgDropEnumActionProvider\n\npgCreateEnumActionProvider :: ActionProvider Postgres\npgCreateEnumActionProvider =\n  ActionProvider $ \\findPre findPost ->\n  do enumP@(PgHasEnum nm vals) <- findPost\n     ensuringNot_ $\n      do (PgHasEnum beforeNm _) <- findPre\n         guard (beforeNm == nm)\n\n     let cmd = pgCreateEnumSyntax nm (fmap sqlValueSyntax vals)\n     pure (PotentialAction mempty (HS.fromList [p enumP])\n                           (pure (MigrationCommand cmd MigrationKeepsData))\n                           ("Create the enumeration " <> nm) 1)\n\npgDropEnumActionProvider :: ActionProvider Postgres\npgDropEnumActionProvider =\n  ActionProvider $ \\findPre findPost ->\n  do enumP@(PgHasEnum nm _) <- findPre\n     ensuringNot_ $\n      do (PgHasEnum afterNm _) <- findPost\n         guard (afterNm == nm)\n\n     let cmd = pgDropTypeSyntax nm\n     pure (PotentialAction (HS.fromList [p enumP]) mempty\n                           (pure (MigrationCommand cmd MigrationKeepsData))\n                           ("Drop the enumeration type " <> nm) 1)\n\npgChecksForTypeSchema :: PgDataTypeSchema a -> [ PgTypeCheck ]\npgChecksForTypeSchema (PgDataTypeEnum vals) =\n  let valTxts = map encodeToString vals\n\n      -- TODO better reporting\n      encodeToString val =\n        let PgValueSyntax (PgSyntax syntax) = sqlValueSyntax val\n        in runF syntax (\\_ -> error "Expecting a simple text encoding for enumeration type")\n                       (\\case\n                           EmitByteString "\'" next -> next\n                           EscapeString s _ -> TE.decodeUtf8 s -- TODO Make this more robust\n                           _ -> error "Expecting a simple text encoding for enumeration type")\n  in [ PgTypeCheck (\\nm -> p (PgHasEnum nm valTxts)) ]\n\ninstance IsDatabaseEntity Postgres (PgType a) where\n\n  data DatabaseEntityDescriptor Postgres (PgType a) where\n      PgTypeDescriptor :: Maybe Text -> Text -> PgDataTypeSyntax\n                       -> DatabaseEntityDescriptor Postgres (PgType a)\n\n  type DatabaseEntityDefaultRequirements Postgres (PgType a) =\n      ( HasSqlValueSyntax PgValueSyntax a\n      , FromBackendRow Postgres a\n      , IsPgCustomDataType a)\n\n  type DatabaseEntityRegularRequirements Postgres (PgType a) =\n      ( HasSqlValueSyntax PgValueSyntax a\n      , FromBackendRow Postgres a )\n\n  dbEntityName f (PgTypeDescriptor sch nm ty) = (\\nm\' -> PgTypeDescriptor sch nm\' ty) <$> f nm\n  dbEntitySchema f (PgTypeDescriptor sch nm ty) = PgTypeDescriptor <$> f sch <*> pure nm <*> pure ty\n  dbEntityAuto _ = PgTypeDescriptor Nothing typeName\n                                    (PgDataTypeSyntax (PgDataTypeDescrDomain typeName)\n                                                      (pgQuotedIdentifier typeName)\n                                                      (pgDataTypeJSON (object [ "customType" .= typeName])))\n      where\n        typeName = pgDataTypeName (Proxy @a)\n\ninstance IsCheckedDatabaseEntity Postgres (PgType a) where\n    data CheckedDatabaseEntityDescriptor Postgres (PgType a) where\n        CheckedPgTypeDescriptor :: DatabaseEntityDescriptor Postgres (PgType a)\n                                -> [ PgTypeCheck ]\n                                -> CheckedDatabaseEntityDescriptor Postgres (PgType a)\n    type CheckedDatabaseEntityDefaultRequirements Postgres (PgType a) =\n        DatabaseEntityDefaultRequirements Postgres (PgType a)\n\n    unChecked f (CheckedPgTypeDescriptor ty d) = fmap (\\ty\' -> CheckedPgTypeDescriptor ty\' d) (f ty)\n    collectEntityChecks (CheckedPgTypeDescriptor e chks) =\n        fmap (\\(PgTypeCheck mkCheck) -> mkCheck (getConst (dbEntityName Const e))) chks\n    checkedDbEntityAuto nm = CheckedPgTypeDescriptor (dbEntityAuto nm)\n                                                     (pgChecksForTypeSchema (pgDataTypeDescription @a))\n\ninstance RenamableWithRule (FieldRenamer (DatabaseEntityDescriptor Postgres (PgType a))) where\n    renamingFields _ = FieldRenamer id\n\ncreateEnum :: forall a db\n            . ( HasSqlValueSyntax PgValueSyntax a\n              , Enum a, Bounded a )\n           => Text -> Migration Postgres (CheckedDatabaseEntity Postgres db (PgType a))\ncreateEnum nm = do\n  upDown (pgCreateEnumSyntax nm (fmap sqlValueSyntax [minBound..(maxBound::a)]))\n         (Just (pgDropTypeSyntax nm))\n\n  let tyDesc = PgTypeDescriptor Nothing nm $\n               PgDataTypeSyntax (PgDataTypeDescrDomain nm)\n                                (pgQuotedIdentifier nm)\n                                (pgDataTypeJSON (object [ "customType" .= nm ]))\n\n  pure (CheckedDatabaseEntity\n          (CheckedPgTypeDescriptor tyDesc\n             (pgChecksForTypeSchema (PgDataTypeEnum [minBound..maxBound::a])))\n          [])\n\n\npgEnumValueSyntax :: (a -> String) -> a -> PgValueSyntax\npgEnumValueSyntax namer = sqlValueSyntax . namer\n\nnewtype PgRawString = PgRawString String\ninstance FromBackendRow Postgres PgRawString\ninstance Pg.FromField PgRawString where\n    fromField f Nothing = Pg.returnError Pg.UnexpectedNull f "When parsing enumeration string"\n    fromField _ (Just d) = pure (PgRawString (BC.unpack d))\n\npgParseEnum :: (Enum a, Bounded a) => (a -> String)\n            -> FromBackendRowM Postgres a\npgParseEnum namer =\n  let allNames = map (\\x -> (namer x, x)) [minBound..maxBound]\n  in do\n    PgRawString name <- fromBackendRow\n    case lookup name allNames of\n      Nothing -> fail ("Invalid postgres enumeration value: " ++ name)\n      Just  v -> pure v\n\nbeamTypeForCustomPg :: CheckedDatabaseEntity Postgres db (PgType a) -> DataType Postgres a\nbeamTypeForCustomPg (CheckedDatabaseEntity (CheckedPgTypeDescriptor (PgTypeDescriptor _ _ dt) _) _)\n    = DataType dt\n'