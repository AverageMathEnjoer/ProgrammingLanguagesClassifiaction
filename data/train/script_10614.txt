b'/*\n    SPDX-FileCopyrightText: 2014-2017 Milian Wolff <mail@milianw.de>\n\n    SPDX-License-Identifier: LGPL-2.1-or-later\n*/\n\n#include "libheaptrack.h"\n#include "util/config.h"\n#include "util/linewriter.h"\n\n#include <tsl/robin_map.h>\n\n#include <cstdlib>\n#include <cstring>\n\n#include <dlfcn.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <link.h>\n#include <unistd.h>\n\n#include <limits.h>\n#include <sys/mman.h>\n#include <sys/stat.h>\n\n#include <type_traits>\n\n/**\n * @file heaptrack_inject.cpp\n *\n * @brief Experimental support for symbol overloading after runtime injection.\n */\n\n#if ULONG_MAX == 0xffffffffffffffff\n#define WORDSIZE 64\n#elif ULONG_MAX == 0xffffffff\n#define WORDSIZE 32\n#endif\n\n#ifndef ELF_R_SYM\n#if WORDSIZE == 64\n#define ELF_R_SYM(i) ELF64_R_SYM(i)\n#elif WORDSIZE == 32\n#define ELF_R_SYM(i) ELF32_R_SYM(i)\n#else\n#error unsupported word size\n#endif\n#endif\n\n#ifndef ElfW\n#if WORDSIZE == 64\n#define ElfW(type) Elf64_##type\n#elif WORDSIZE == 32\n#define ElfW(type) Elf32_##type\n#else\n#error unsupported word size\n#endif\n#endif\n\n// NOTE: adding noexcept to C functions is a hard error in clang++\n//       (but not even a warning in GCC, even with -Wall)\n#if defined(__GNUC__) && !defined(__clang__)\n#define LIBC_FUN_ATTRS noexcept\n#else\n#define LIBC_FUN_ATTRS\n#endif\n\nextern "C" {\n\n// Foward declare mimalloc (https://github.com/microsoft/mimalloc) functions so we don\'t need to include its .h.\n__attribute__((weak)) void* mi_malloc(size_t size) LIBC_FUN_ATTRS;\n__attribute__((weak)) void* mi_calloc(size_t count, size_t size) LIBC_FUN_ATTRS;\n__attribute__((weak)) void* mi_realloc(void* p, size_t newsize) LIBC_FUN_ATTRS;\n__attribute__((weak)) void  mi_free(void* p) LIBC_FUN_ATTRS;\n\n}\n\nnamespace {\n\nnamespace Elf {\nusing Ehdr = ElfW(Ehdr);\nusing Shdr = ElfW(Shdr);\nusing Half = ElfW(Half);\nusing Addr = ElfW(Addr);\nusing Dyn = ElfW(Dyn);\nusing Rel = ElfW(Rel);\nusing Rela = ElfW(Rela);\nusing Sym = ElfW(Sym);\n#if WORDSIZE == 64\nusing Sxword = ElfW(Sxword);\nusing Xword = ElfW(Xword);\n#else\n// FreeBSD elf32.h doesn\'t define Elf32_Sxword or _Xword. This is used in struct\n// elftable, where it\'s used as a tag value. Our Elf32_Dyn uses Elf32_Sword there,\n// as does the Linux definition (and the standard); the El64_Dyn uses Sxword.\n//\n// Linux elf.h defines Elf32_Sxword as a 64-bit quantity, so let\'s do that\nusing Sxword = int64_t;\nusing Xword = uint64_t;\n#endif\n}\n\nvoid overwrite_symbols() noexcept;\n\nnamespace hooks {\n\nstruct malloc\n{\n    static constexpr auto name = "malloc";\n    static constexpr auto original = &::malloc;\n\n    static void* hook(size_t size) noexcept\n    {\n        auto ptr = original(size);\n        heaptrack_malloc(ptr, size);\n        return ptr;\n    }\n};\n\nstruct free\n{\n    static constexpr auto name = "free";\n    static constexpr auto original = &::free;\n\n    static void hook(void* ptr) noexcept\n    {\n        heaptrack_free(ptr);\n        original(ptr);\n    }\n};\n\nstruct realloc\n{\n    static constexpr auto name = "realloc";\n    static constexpr auto original = &::realloc;\n\n    static void* hook(void* ptr, size_t size) noexcept\n    {\n        auto inPtr = reinterpret_cast<uintptr_t>(ptr);\n        auto ret = original(ptr, size);\n        heaptrack_realloc2(inPtr, size, reinterpret_cast<uintptr_t>(ret));\n\n        return ret;\n    }\n};\n\nstruct calloc\n{\n    static constexpr auto name = "calloc";\n    static constexpr auto original = &::calloc;\n\n    static void* hook(size_t num, size_t size) noexcept\n    {\n        auto ptr = original(num, size);\n        heaptrack_malloc(ptr, num * size);\n        return ptr;\n    }\n};\n\n#if HAVE_CFREE\nstruct cfree\n{\n    static constexpr auto name = "cfree";\n    static constexpr auto original = &::cfree;\n\n    static void hook(void* ptr) noexcept\n    {\n        heaptrack_free(ptr);\n        original(ptr);\n    }\n};\n#endif\n\nstruct dlopen\n{\n    static constexpr auto name = "dlopen";\n    static constexpr auto original = &::dlopen;\n\n    static void* hook(const char* filename, int flag) noexcept\n    {\n        auto ret = original(filename, flag);\n        if (ret) {\n            heaptrack_invalidate_module_cache();\n            overwrite_symbols();\n        }\n        return ret;\n    }\n};\n\nstruct dlclose\n{\n    static constexpr auto name = "dlclose";\n    static constexpr auto original = &::dlclose;\n\n    static int hook(void* handle) noexcept\n    {\n        auto ret = original(handle);\n        if (!ret) {\n            heaptrack_invalidate_module_cache();\n        }\n        return ret;\n    }\n};\n\nstruct posix_memalign\n{\n    static constexpr auto name = "posix_memalign";\n    static constexpr auto original = &::posix_memalign;\n\n    static int hook(void** memptr, size_t alignment, size_t size) noexcept\n    {\n        auto ret = original(memptr, alignment, size);\n        if (!ret) {\n            heaptrack_malloc(*memptr, size);\n        }\n        return ret;\n    }\n};\n\n// mimalloc functions\nstruct mi_malloc\n{\n    static constexpr auto name = "mi_malloc";\n    static constexpr auto original = &::mi_malloc;\n\n    static void* hook(size_t size) noexcept\n    {\n        auto ptr = original(size);\n        heaptrack_malloc(ptr, size);\n        return ptr;\n    }\n};\n\nstruct mi_free\n{\n    static constexpr auto name = "mi_free";\n    static constexpr auto original = &::mi_free;\n\n    static void hook(void* ptr) noexcept\n    {\n        heaptrack_free(ptr);\n        original(ptr);\n    }\n};\n\nstruct mi_realloc\n{\n    static constexpr auto name = "mi_realloc";\n    static constexpr auto original = &::mi_realloc;\n\n    static void* hook(void* ptr, size_t size) noexcept\n    {\n        auto ret = original(ptr, size);\n        heaptrack_realloc(ptr, size, ret);\n        return ret;\n    }\n};\n\nstruct mi_calloc\n{\n    static constexpr auto name = "mi_calloc";\n    static constexpr auto original = &::mi_calloc;\n\n    static void* hook(size_t num, size_t size) noexcept\n    {\n        auto ptr = original(num, size);\n        heaptrack_malloc(ptr, num * size);\n        return ptr;\n    }\n};\n\ntemplate <typename Hook>\nbool hook(const char* symname, Elf::Addr addr, bool restore)\n{\n    static_assert(std::is_convertible<decltype(&Hook::hook), decltype(Hook::original)>::value,\n                  "hook is not compatible to original function");\n\n    if (strcmp(Hook::name, symname) != 0) {\n        return false;\n    }\n\n    // try to make the page read/write accessible, which is hackish\n    // but apparently required for some shared libraries\n    auto page = reinterpret_cast<void*>(addr & ~(0x1000 - 1));\n    mprotect(page, 0x1000, PROT_READ | PROT_WRITE);\n\n    // now write to the address\n    auto typedAddr = reinterpret_cast<typename std::remove_const<decltype(Hook::original)>::type*>(addr);\n    if (restore) {\n        // restore the original address on shutdown\n        *typedAddr = Hook::original;\n    } else {\n        // now actually inject our hook\n        *typedAddr = &Hook::hook;\n    }\n\n    return true;\n}\n\nvoid apply(const char* symname, Elf::Addr addr, bool restore)\n{\n    // TODO: use std::apply once we can rely on C++17\n    hook<malloc>(symname, addr, restore) || hook<free>(symname, addr, restore) || hook<realloc>(symname, addr, restore)\n        || hook<calloc>(symname, addr, restore)\n#if HAVE_CFREE\n        || hook<cfree>(symname, addr, restore)\n#endif\n        || hook<posix_memalign>(symname, addr, restore) || hook<dlopen>(symname, addr, restore)\n        || hook<dlclose>(symname, addr, restore)\n        // mimalloc functions\n        || hook<mi_malloc>(symname, addr, restore) || hook<mi_free>(symname, addr, restore) || hook<mi_realloc>(symname, addr, restore)\n        || hook<mi_calloc>(symname, addr, restore);\n}\n}\n\ntemplate <typename T, Elf::Sxword AddrTag, Elf::Sxword SizeTag>\nstruct elftable\n{\n    using type = T;\n    Elf::Addr table = 0;\n    Elf::Xword size = 0;\n\n    bool consume(const Elf::Dyn* dyn) noexcept\n    {\n        if (dyn->d_tag == AddrTag) {\n            table = dyn->d_un.d_ptr;\n            return true;\n        } else if (dyn->d_tag == SizeTag) {\n            size = dyn->d_un.d_val;\n            return true;\n        }\n        return false;\n    }\n\n    explicit operator bool() const noexcept\n    {\n        return table && size;\n    }\n\n    T* start(Elf::Addr tableOffset) const noexcept\n    {\n        return reinterpret_cast<T*>(table + tableOffset);\n    }\n\n    T* end(Elf::Addr tableOffset) const noexcept\n    {\n        return reinterpret_cast<T*>(table + tableOffset + size);\n    }\n};\n\nusing elf_string_table = elftable<const char, DT_STRTAB, DT_STRSZ>;\nusing elf_rel_table = elftable<Elf::Rel, DT_REL, DT_RELSZ>;\nusing elf_rela_table = elftable<Elf::Rela, DT_RELA, DT_RELASZ>;\nusing elf_jmprel_table = elftable<Elf::Rela, DT_JMPREL, DT_PLTRELSZ>;\nusing elf_symbol_table = elftable<const Elf::Sym, DT_SYMTAB, DT_SYMENT>;\n\ntemplate <typename Table>\nvoid try_overwrite_elftable(const Table& jumps, const elf_string_table& strings, const elf_symbol_table& symbols,\n                            const Elf::Addr base, const bool restore, const Elf::Xword symtabSize) noexcept\n{\n    Elf::Addr tableOffset =\n#ifdef __linux__\n        0; // Already has memory addresses\n#elif defined(__FreeBSD__)\n        base; // Only has ELF offsets\n#else\n#error port me\n#endif\n\n    const auto rela_start = jumps.start(tableOffset);\n    const auto rela_end = jumps.end(tableOffset);\n\n    const auto sym_start = symbols.start(tableOffset);\n    const auto sym_end = symbols.start(tableOffset + symtabSize);\n    const auto num_syms = static_cast<uintptr_t>(sym_end - sym_start);\n\n    const auto str_start = strings.start(tableOffset);\n    const auto str_end = strings.end(tableOffset);\n    const auto num_str = static_cast<uintptr_t>(str_end - str_start);\n\n    for (auto rela = rela_start; rela < rela_end; rela++) {\n        const auto sym_index = ELF_R_SYM(rela->r_info);\n        if (sym_index < 0 || sym_index >= num_syms) {\n            continue;\n        }\n\n        const auto str_index = sym_start[sym_index].st_name;\n        if (str_index < 0 || str_index >= num_str) {\n            continue;\n        }\n\n        const char* symname = str_start + str_index;\n\n        auto addr = rela->r_offset + base;\n        hooks::apply(symname, addr, restore);\n    }\n}\n\nvoid try_overwrite_symbols(const Elf::Dyn* dyn, const Elf::Addr base, const bool restore,\n                           const Elf::Xword symtabSize) noexcept\n{\n    elf_symbol_table symbols;\n    elf_rel_table rels;\n    elf_rela_table relas;\n    elf_jmprel_table jmprels;\n    elf_string_table strings;\n\n    // initialize the elf tables\n    for (; dyn->d_tag != DT_NULL; ++dyn) {\n        symbols.consume(dyn) || strings.consume(dyn) || rels.consume(dyn) || relas.consume(dyn) || jmprels.consume(dyn);\n    }\n\n    if (!symbols || !strings) {\n        return;\n    }\n\n    // find symbols to overwrite\n    if (rels) {\n        try_overwrite_elftable(rels, strings, symbols, base, restore, symtabSize);\n    }\n\n    if (relas) {\n        try_overwrite_elftable(relas, strings, symbols, base, restore, symtabSize);\n    }\n\n    if (jmprels) {\n        try_overwrite_elftable(jmprels, strings, symbols, base, restore, symtabSize);\n    }\n}\n\ntemplate <typename Cleanup>\nstruct ScopeGuard\n{\n    ScopeGuard(Cleanup cleanup)\n        : cleanup(std::move(cleanup))\n    {\n    }\n\n    ~ScopeGuard()\n    {\n        cleanup();\n    }\n\n    Cleanup cleanup;\n};\n\ntemplate <typename Cleanup>\nauto scopeGuard(Cleanup cleanup)\n{\n    return ScopeGuard<Cleanup>(std::move(cleanup));\n}\n\nElf::Xword symtabSize(const char* path)\n{\n    auto fd = open(path, O_RDONLY);\n    if (fd == -1) {\n        fprintf(stderr, "open failed: %s %s\\n", path, strerror(errno));\n        return 0;\n    }\n    auto closeOnExit = scopeGuard([fd]() { close(fd); });\n\n    struct stat stat_info;\n    if (fstat(fd, &stat_info) != 0) {\n        fprintf(stderr, "stat failed: %s %s\\n", path, strerror(errno));\n        return 0;\n    }\n\n    auto mapping = mmap(nullptr, stat_info.st_size, PROT_READ, MAP_SHARED, fd, 0);\n    auto unmapOnExit = scopeGuard([&]() { munmap(mapping, stat_info.st_size); });\n\n    const auto base = reinterpret_cast<ElfW(Addr)>(mapping);\n    const auto ehdr = reinterpret_cast<const ElfW(Ehdr)*>(base);\n    const auto shdr = reinterpret_cast<const ElfW(Shdr)*>(base + ehdr->e_shoff);\n\n    for (ElfW(Half) i = 0; i < ehdr->e_shnum; ++i) {\n        if (shdr[i].sh_type == SHT_DYNSYM) {\n            return shdr[i].sh_size;\n        }\n    }\n\n    fprintf(stderr, "failed to query symtab size: %s\\n", path);\n    return 0;\n}\n\nElf::Xword cachedSymtabSize(const char* path)\n{\n    if (!strlen(path)) {\n        path = "/proc/self/exe";\n    }\n\n    static tsl::robin_map<std::string, Elf::Xword> cache;\n\n    auto key = std::string(path);\n    auto it = cache.find(path);\n    if (it == cache.end()) {\n        it = cache.insert(it, {std::move(key), symtabSize(path)});\n    }\n    return it->second;\n}\n\nint iterate_phdrs(dl_phdr_info* info, size_t /*size*/, void* data) noexcept\n{\n    if (strstr(info->dlpi_name, "/libheaptrack_inject.so")) {\n        // prevent infinite recursion: do not overwrite our own symbols\n        return 0;\n    } else if (strstr(info->dlpi_name, "/ld-linux")) {\n        // prevent strange crashes due to overwriting the free symbol in ld-linux\n        // (doesn\'t seem to be necessary in FreeBSD\'s ld-elf)\n        return 0;\n    } else if (strstr(info->dlpi_name, "linux-vdso.so")) {\n        // don\'t overwrite anything within linux-vdso\n        return 0;\n    }\n\n    const auto symtabSize = cachedSymtabSize(info->dlpi_name);\n    for (auto phdr = info->dlpi_phdr, end = phdr + info->dlpi_phnum; phdr != end; ++phdr) {\n        if (phdr->p_type == PT_DYNAMIC) {\n            try_overwrite_symbols(reinterpret_cast<const Elf::Dyn*>(phdr->p_vaddr + info->dlpi_addr), info->dlpi_addr,\n                                  data != nullptr, symtabSize);\n        }\n    }\n    return 0;\n}\n\nvoid overwrite_symbols() noexcept\n{\n    dl_iterate_phdr(&iterate_phdrs, nullptr);\n}\n\nvoid restore_symbols() noexcept\n{\n    bool do_shutdown = true;\n    dl_iterate_phdr(&iterate_phdrs, &do_shutdown);\n}\n}\n\nextern "C" {\n// this function is called when heaptrack_inject is runtime injected via GDB\nvoid heaptrack_inject(const char* outputFileName) noexcept\n{\n    heaptrack_init(\n        outputFileName, &overwrite_symbols, [](LineWriter& out) { out.write("A\\n"); }, &restore_symbols);\n}\n}\n\n// alternatively, the code below may initialize heaptrack when we use\n// heaptrack_inject via LD_PRELOAD and have the right environment variables setup\nstruct HeaptrackInjectPreloadInitialization\n{\n    HeaptrackInjectPreloadInitialization()\n    {\n        const auto outputFileName = getenv("DUMP_HEAPTRACK_OUTPUT");\n        if (!outputFileName) {\n            // when the env var wasn\'t set, then this means we got runtime injected, don\'t do anything here\n            return;\n        }\n        heaptrack_init(outputFileName, &overwrite_symbols, nullptr, &restore_symbols);\n    }\n};\n\nstatic HeaptrackInjectPreloadInitialization heaptrackInjectPreloadInitialization;\n'