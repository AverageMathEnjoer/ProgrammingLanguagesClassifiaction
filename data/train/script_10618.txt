b'{-# LANGUAGE TemplateHaskell, DeriveDataTypeable #-}\n{-# OPTIONS_GHC -O2 -ddump-splices #-}\n\n-- Simple tests of distributed work stealing.\n----------------------------------------------\n\nimport System.Environment (getArgs)\nimport qualified Control.Monad.Par.Meta.Dist as D\n\nimport Control.Monad.IO.Class (liftIO)\nimport Control.Monad (mapM_)\n-- Tweaked version of CloudHaskell\'s closures:\nimport Remote2.Call (mkClosureRec, remotable)\n\nimport Control.Concurrent   (myThreadId, threadDelay)\nimport System.Process       (readProcess)\nimport System.Posix.Process (getProcessID)\nimport Data.Char            (isSpace)\nimport Data.Typeable\nimport Data.Binary \n\nimport qualified Data.ByteString.Char8 as BS\n\n-- import qualified Data.IntMap as M\n-- import qualified Data.Set as M\n--------------------------------------------------------------------------------\n\n\n-- A description of a fake work topology which is executed by sleeping\n-- (threadDelay) different amounts at different points.\n-- Presently this describes futures-only work:\ndata FakeWork = Work Time FakeWork\n\t      | Fork FakeWork FakeWork\n              | SyncAll FakeWork\n              | Nop\n\n--\t      | Spawn Id FakeWork FakeWork\n--              | Seq [FakeWork]\n--              | Sync Id FakeWork\n deriving (Eq,Show,Read,Typeable)\n-- All constructors take a continuation.              \n\ntype Time = Int -- Time in milliseconds\ntype Id   = Int\n\n-- A simple test that ensures a single steal for two workers:\n-- t1 = Spawn 11 (Work 101) $ \n--      Seq [Work 102, \n-- \t  Sync 11]\n     \nt1 = Fork (Work 101 Nop) $ \n     Work 102 $ \n     SyncAll Nop\n\nt2 = switcher 3 3 True\n\n-- This one alternates where the *real* work will be.\n--\n-- Takes number of switches.  Performs a shrinking number of work\n-- items per "straightaway":\nswitcher 1 m _     = Work 100 (SyncAll Nop)\nswitcher _ _ False = Work 101 (SyncAll Nop)\nswitcher n m True  = Work 102 $ switcher n (m-1) True\nswitcher n 1 b     = Fork (switcher (n-1) n b) \n\t\t          (switcher (n-1) n (not b))\n\n----------------------------------------------------------------------------------------------------\n\nrunTest :: FakeWork -> D.Par ()\n--runTest fw = theloop fw M.empty\nrunTest fw = theloop fw []\n\ntheloop fw ls =\n   case fw of \n     Nop -> return ()\n     Work t cont -> \n        do liftIO$ threadDelay (t * 1000)\n\t   liftIO$ putStrLn$ "Finished work "++show t\n\t   theloop cont ls\n--     Seq ls -> mapM_ theloop ls\n--     Spawn id fw cont -> \n     Fork child cont -> \n        do \n           iv <- D.longSpawn$  $(mkClosureRec \'runTest) child\n           -- Associate id with ivar\n--\t   theloop cont (M.insert id iv mp)\n\t   theloop cont (iv:ls)\n     SyncAll cont -> \n        do mapM_ D.get ls\n\t   theloop cont []\n\n-- Generate stub code for RPC:\nremotable [\'runTest]\n\n-- instance Serialize FakeWork where \n\ninstance Binary FakeWork where \n  put fw = put (show fw)\n--  get str = return (read (BS.unpack str))\n  get = get >>=  return . read\n\n\n----------------------------------------------------------------------------------------------------\n\nmain = do \n    [version] <- getArgs\n    case version of \n        "slave" -> D.runParSlaveWithTransport [__remoteCallMetaData] D.TCP\n        "master" -> do \t\n\t\t       D.runParDistWithTransport [__remoteCallMetaData] D.TCP (runTest t1)\n\t\t       putStrLn $ "Finished with work.  Calling SHUTDOWN..."\n                       D.shutdownDist\n\t\t       putStrLn $ "... returned from shutdown, apparently successful."\n\n        str -> error$"Unhandled mode: " ++ str\n'