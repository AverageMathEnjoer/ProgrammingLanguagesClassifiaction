b'// UVa10603 Fill\n// Rujia Liu\n#include<cstdio>\n#include<cstring>\n#include<queue>\nusing namespace std;\n\nstruct Node {\n  int v[3], dist;\n  bool operator < (const Node& rhs) const {\n    return dist > rhs.dist;\n  }\n};\n\nconst int maxn = 200 + 5;\nint mark[maxn][maxn], dist[maxn][maxn], cap[3], ans[maxn];\n\nvoid update_ans(const Node& u) {\n  for(int i = 0; i < 3; i++) {\n    int d = u.v[i];\n    if(ans[d] < 0 || u.dist < ans[d]) ans[d] = u.dist;\n  }\n}\n\nvoid solve(int a, int b, int c, int d) {\n  cap[0] = a; cap[1] = b; cap[2] = c;\n  memset(ans, -1, sizeof(ans));\n  memset(mark, 0, sizeof(mark));\n  memset(dist, -1, sizeof(dist));\n  priority_queue<Node> q;\n\n  Node start;\n  start.dist = 0;\n  start.v[0] = 0; start.v[1] = 0; start.v[2] = c;\n  q.push(start);\n\n  dist[0][0] = 0;\n  while(!q.empty()) {\n    Node u = q.top(); q.pop();\n    if(mark[u.v[0]][u.v[1]]) continue;\n    mark[u.v[0]][u.v[1]] = 1;\n    update_ans(u);\n    if(ans[d] >= 0) break;\n    for(int i = 0; i < 3; i++)\n      for(int j = 0; j < 3; j++) if(i != j) {\n        if(u.v[i] == 0 || u.v[j] == cap[j]) continue;\n        int amount = min(cap[j], u.v[i] + u.v[j]) - u.v[j];\n        Node u2;\n        memcpy(&u2, &u, sizeof(u));\n        u2.dist = u.dist + amount;\n        u2.v[i] -= amount;\n        u2.v[j] += amount;\n        int& D = dist[u2.v[0]][u2.v[1]];\n        if(D < 0 || u2.dist < D){\n          D = u2.dist;\n          q.push(u2);\n        }\n      }\n  }\n  while(d >= 0) {\n    if(ans[d] >= 0) {\n      printf("%d %d\\n", ans[d], d);\n      return;\n    }\n    d--;\n  }\n}\n\nint main() {\n  int T, a, b, c, d;\n  scanf("%d", &T);\n  while(T--) {\n    scanf("%d%d%d%d", &a, &b, &c, &d);\n    solve(a, b, c, d);\n  }\n  return 0;\n}\n'