b'{-# LANGUAGE ApplicativeDo #-}\n{-# LANGUAGE QuasiQuotes #-}\n\nmodule Cachix.Client.Config\n  ( -- CLI options\n    run,\n    parser,\n    Command (..),\n    CachixOptions (..),\n    -- Auth token helpers\n    getAuthTokenRequired,\n    getAuthTokenMaybe,\n    setAuthToken,\n    noAuthTokenError,\n    -- Config\n    getConfig,\n    readConfig,\n    writeConfig,\n    getDefaultFilename,\n    ConfigPath,\n    Config (..),\n    BinaryCacheConfig (..),\n    setBinaryCaches,\n  )\nwhere\n\nimport Cachix.Client.Config.Orphans ()\nimport Cachix.Client.Exception (CachixException (..))\nimport Cachix.Client.URI as URI\nimport qualified Control.Exception.Safe as Safe\nimport Data.Either.Extra (eitherToMaybe)\nimport Data.String.Here\nimport qualified Dhall\nimport qualified Dhall.Pretty\nimport qualified Options.Applicative as Opt\nimport qualified Prettyprinter as Pretty\nimport qualified Prettyprinter.Render.Text as Pretty\nimport Protolude hiding (toS)\nimport Protolude.Conv\nimport Servant.Auth.Client\nimport System.Directory\n  ( XdgDirectory (..),\n    createDirectoryIfMissing,\n    getXdgDirectory,\n  )\nimport System.Environment (lookupEnv)\nimport System.FilePath.Posix (takeDirectory)\nimport System.Posix.Files\n  ( ownerReadMode,\n    ownerWriteMode,\n    setFileMode,\n    unionFileModes,\n  )\n\ndata CachixOptions = CachixOptions\n  { host :: URI,\n    configPath :: ConfigPath,\n    verbose :: Bool\n  }\n  deriving (Show)\n\ndata Config = Config\n  { authToken :: Token,\n    hostname :: URI,\n    binaryCaches :: [BinaryCacheConfig]\n  }\n  deriving (Show, Generic, Dhall.ToDhall, Dhall.FromDhall)\n\ndata BinaryCacheConfig = BinaryCacheConfig\n  { name :: Text,\n    secretKey :: Text\n  }\n  deriving (Show, Generic, Dhall.FromDhall, Dhall.ToDhall)\n\ndefaultConfig :: Config\ndefaultConfig =\n  Config\n    { authToken = Token "",\n      hostname = URI.defaultCachixURI,\n      binaryCaches = []\n    }\n\nmergeWithDefault :: Text -> Text\nmergeWithDefault config =\n  serializeConfig defaultConfig <> " // " <> config\n\ntype ConfigPath = FilePath\n\ngetConfig :: ConfigPath -> IO Config\ngetConfig filename = do\n  userConfig <- readConfig filename\n  pure $ fromMaybe defaultConfig userConfig\n\nreadConfig :: ConfigPath -> IO (Maybe Config)\nreadConfig filename = fmap eitherToMaybe . Safe.tryIO $ do\n  userConfig <- readFile filename\n  let config = mergeWithDefault userConfig\n  Dhall.detailed (Dhall.input Dhall.auto config)\n\ngetDefaultFilename :: IO FilePath\ngetDefaultFilename = do\n  dir <- getXdgDirectory XdgConfig "cachix"\n  return $ dir <> "/cachix.dhall"\n\nserializeConfig :: Config -> Text\nserializeConfig =\n  Pretty.renderStrict\n    . Pretty.layoutPretty Pretty.defaultLayoutOptions\n    . Dhall.Pretty.prettyExpr\n    . Dhall.embed Dhall.inject\n\nwriteConfig :: ConfigPath -> Config -> IO ()\nwriteConfig filename config = do\n  let doc = Dhall.Pretty.prettyExpr $ Dhall.embed Dhall.inject config\n  createDirectoryIfMissing True (takeDirectory filename)\n  writeFile filename $ show doc\n  assureFilePermissions filename\n  putStrLn $ "Written to " <> filename\n\n-- chmod rw filepath\nassureFilePermissions :: FilePath -> IO ()\nassureFilePermissions fp =\n  setFileMode fp $ unionFileModes ownerReadMode ownerWriteMode\n\ngetAuthTokenFromConfig :: Config -> Maybe Token\ngetAuthTokenFromConfig = inspectToken . authToken\n  where\n    inspectToken (Token "") = Nothing\n    inspectToken token = Just token\n\ngetAuthTokenRequired :: Config -> IO Token\ngetAuthTokenRequired config = do\n  authTokenMaybe <- getAuthTokenMaybe config\n  case authTokenMaybe of\n    Just authtoken -> return authtoken\n    Nothing -> throwIO $ NoConfig $ toS noAuthTokenError\n\n-- get auth token from env variable or fallback to config\ngetAuthTokenMaybe :: Config -> IO (Maybe Token)\ngetAuthTokenMaybe config = do\n  maybeAuthToken <- lookupEnv "CACHIX_AUTH_TOKEN"\n  case maybeAuthToken of\n    Just token -> return $ Just $ Token (toS token)\n    Nothing -> return $ getAuthTokenFromConfig config\n\nnoAuthTokenError :: Text\nnoAuthTokenError =\n  [iTrim|\nStart by visiting https://app.cachix.org and create a personal/cache auth token.\n\nTo configure the token:\n\na) Via environment variable: \n\n$ export CACHIX_AUTH_TOKEN=<token...>\n\nb) Via configuration file:\n\n$ cachix authtoken <token...>\n  |]\n\n-- Setters\n\nsetAuthToken :: Token -> Config -> Config\nsetAuthToken token config = config {authToken = token}\n\nsetBinaryCaches :: [BinaryCacheConfig] -> Config -> Config\nsetBinaryCaches caches config = config {binaryCaches = binaryCaches config <> caches}\n\n-- CLI parsers\n\ndata Command\n  = Get GetCommand\n  | Set SetCommand\n  deriving (Show)\n\ndata GetCommand\n  = GetHostname\n  deriving (Show)\n\ndata SetCommand\n  = SetHostname URI\n  deriving (Show)\n\nrun :: CachixOptions -> Command -> IO ()\nrun CachixOptions {configPath} (Get cmd) = getConfigOption configPath cmd\nrun CachixOptions {configPath} (Set cmd) = setConfigOption configPath cmd\n\ngetConfigOption :: ConfigPath -> GetCommand -> IO ()\ngetConfigOption configPath cmd = do\n  config <- getConfig configPath\n  case cmd of\n    GetHostname -> putStrLn (URI.serialize (hostname config) :: Text)\n\nsetConfigOption :: ConfigPath -> SetCommand -> IO ()\nsetConfigOption configPath (SetHostname hostname) = do\n  config <- getConfig configPath\n  writeConfig configPath config {hostname}\n\nparser :: Opt.ParserInfo Command\nparser =\n  Opt.info (Opt.helper <*> commandParser) $\n    Opt.progDesc "Manage configuration settings for cachix"\n\ncommandParser :: Opt.Parser Command\ncommandParser =\n  Opt.subparser $\n    mconcat\n      [ Opt.command "get" $\n          Opt.info (Opt.helper <*> getConfigOptionParser) $\n            Opt.progDesc "Get a configuration option",\n        Opt.command "set" $\n          Opt.info (Opt.helper <*> setConfigOptionParser) $\n            Opt.progDesc "Set a configuration option"\n      ]\n\ngetConfigOptionParser :: Opt.Parser Command\ngetConfigOptionParser =\n  Opt.subparser $ Opt.metavar "KEY" <> mconcat (supportedOptions False)\n\nsetConfigOptionParser :: Opt.Parser Command\nsetConfigOptionParser =\n  Opt.subparser $ Opt.metavar "KEY VALUE" <> mconcat (supportedOptions True)\n\nsupportedOptions :: Bool -> [Opt.Mod Opt.CommandFields Command]\nsupportedOptions canModify =\n  [ Opt.command "hostname" $\n      Opt.info (Opt.helper <*> if canModify then fmap Set hostnameParser else pure (Get GetHostname)) $\n        Opt.progDesc "The hostname for the Cachix Deploy service."\n  ]\n\nhostnameParser :: Opt.Parser SetCommand\nhostnameParser = do\n  SetHostname\n    <$> Opt.argument uriOption (Opt.metavar "HOSTNAME")\n\nuriOption :: Opt.ReadM URI\nuriOption = Opt.eitherReader $ \\s ->\n  first show $ URI.parseURI (toS s)\n'