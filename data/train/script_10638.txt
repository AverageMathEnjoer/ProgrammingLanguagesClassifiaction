b'{-# LANGUAGE OverloadedStrings #-}\n\nmodule Main\n(\n  main\n)\nwhere\n\nimport Pdf.Core.Object\nimport Pdf.Core.Exception\nimport Pdf.Core.Writer\nimport Pdf.Document\nimport Pdf.Document.Internal.Types\n\nimport Data.IORef\nimport qualified Data.ByteString.Lazy as Lazy (ByteString)\nimport qualified Data.ByteString.Lazy as Lazy.ByteString\nimport qualified Data.Foldable as Foldable\nimport qualified Data.Vector as Vector\nimport qualified Data.IntSet as IntSet\nimport qualified Data.HashMap.Strict as HashMap\nimport Control.Monad\nimport Control.Exception\nimport System.Environment\nimport qualified System.IO.Streams as Streams\n\nmain :: IO ()\nmain = do\n  [input] <- getArgs\n  withPdfFile input $ \\pdf -> do\n    encrypted <- isEncrypted pdf\n    when encrypted $ do\n      ok <- setUserPassword pdf defaultUserPassword\n      unless ok $\n        error "Wrong password"\n\n    Document _ tr <- document pdf\n\n    writer <- makeWriter Streams.stdout\n\n    stateRef <- newIORef IntSet.empty\n    let\n        loop (Dict vals) = Foldable.forM_ vals loop\n        loop (Array vals) = Vector.forM_ vals loop\n        loop (Ref r@(R index _)) = do\n          -- check that the object is not already written.\n          -- necessary to prevent circles\n          member <- IntSet.member index <$> readIORef stateRef\n          if member\n            then return ()\n            else do\n              o <- lookupObject pdf r\n              case o of\n                Stream s -> do\n                  (d, dat) <- loadStream pdf r s\n                  writeStream writer r d dat\n                _ -> writeObject writer r o\n              modifyIORef stateRef $ IntSet.insert index\n              loop o\n        loop (Stream (S d _)) = loop (Dict d)\n        loop _ = return ()\n\n    writeHeader writer\n    -- traverse all the objects starting from trailer\n    -- and write out all the indirect objects found\n    loop (Dict tr)\n    -- There are no more xrefs, so clean prev key\n    writeXRefTable writer 0 (HashMap.delete "Prev" tr)\n\nloadStream :: Pdf -> Ref -> Stream -> IO (Dict, Lazy.ByteString)\nloadStream pdf ref s = do\n  res <- loadDecodedStream pdf ref s\n    `catch` \\Corrupted{} -> loadRawStream pdf ref s\n  return res\n\nloadDecodedStream :: Pdf -> Ref -> Stream -> IO (Dict, Lazy.ByteString)\nloadDecodedStream pdf ref s@(S d _) = do\n  is <- streamContent pdf ref s\n  cont <- Lazy.ByteString.fromChunks <$> Streams.toList is\n  -- update length and remove filter\n  let d\' = HashMap.insert "Length" (Number len)\n         . HashMap.delete "Filter"\n         $ d\n      len = fromIntegral (Lazy.ByteString.length cont)\n  return (d\', cont)\n\nloadRawStream :: Pdf -> Ref -> Stream -> IO (Dict, Lazy.ByteString)\nloadRawStream pdf r s@(S d _) = do\n  is <- rawStreamContent pdf r s\n  cont <- Lazy.ByteString.fromChunks <$> Streams.toList is\n  return (d, cont)\n'