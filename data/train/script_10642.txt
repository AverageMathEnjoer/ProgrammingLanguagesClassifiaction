b'#include "stdafx.h"\n#include "AssetViewModifyDialog.h"\n#include "AsyncTask.h"\n#include "resource.h"\n#include "ProgressDialog.h"\n#include "../libStringConverter/convert.h"\n#include "CreateEmptyValueField.h"\n#include "MonoBehaviourManager.h"\n#include "Win32PluginManager.h"\n#include <string>\n#include <WindowsX.h>\n\nclass AssetInstanceTask : public ITask\n{\n\tstd::shared_ptr<AssetViewModifyDialog> pDialog; //Maintain object lifetime.\n\tstd::list<AssetViewModifyDialog::AssetDeserializeDesc>::iterator itDeserializeDesc;\n\n\tstd::string name;\npublic:\n\tAssetInstanceTask(std::shared_ptr<AssetViewModifyDialog> pDialog, std::list<AssetViewModifyDialog::AssetDeserializeDesc>::iterator itDeserializeDesc)\n\t\t: pDialog(pDialog), itDeserializeDesc(itDeserializeDesc)\n\t{\n\t\tassert(itDeserializeDesc->asset.pFile != nullptr);\n\t\tname = "Deserialize asset : File ID " + std::to_string(static_cast<uint64_t>(itDeserializeDesc->asset.pFile->getFileID())) + \n\t\t\t", Path ID " + std::to_string(itDeserializeDesc->asset.pathID);\n\t}\n\tconst std::string &getName()\n\t{\n\t\treturn name;\n\t}\n\tTaskResult execute(TaskProgressManager &progressManager)\n\t{\n\t\tprogressManager.setProgress(0, 0);\n\t\tprogressManager.setProgressDesc("Generating the type template");\n\t\tbool missingScriptTypeInfo = false;\n\t\tif (!itDeserializeDesc->asset.pFile->MakeTemplateField(\n\t\t\t\t&itDeserializeDesc->templateBase, pDialog->appContext, \n\t\t\t\titDeserializeDesc->asset.getClassID(), itDeserializeDesc->asset.getMonoScriptID(), &itDeserializeDesc->asset,\n\t\t\t\tmissingScriptTypeInfo))\n\t\t{\n\t\t\tprogressManager.logMessage("Unable to generate the type template!");\n\t\t\treturn -1;\n\t\t}\n\t\tuint64_t size = itDeserializeDesc->asset.getDataSize();\n\t\tIAssetsReader_ptr pReader = itDeserializeDesc->asset.makeReader();\n\t\tif (!pReader)\n\t\t{\n\t\t\tprogressManager.logMessage("Unable to read the asset!");\n\t\t\treturn -2;\n\t\t}\n\t\tprogressManager.setProgressDesc("Deserializing the asset");\n\t\tAssetTypeTemplateField *pTemplateBase = &itDeserializeDesc->templateBase;\n\t\tstd::unique_ptr<AssetTypeInstance> pAssetInstance(\n\t\t\tnew AssetTypeInstance(1, &pTemplateBase, size, pReader.get(), itDeserializeDesc->asset.isBigEndian()));\n\t\t\n\t\tAssetTypeValueField *pInstanceBase = pAssetInstance->GetBaseField();\n\t\tif (pInstanceBase)\n\t\t{\n\t\t\titDeserializeDesc->pAssetInstance = std::move(pAssetInstance);\n\t\t\t//Assuming the caller sets a memory fence (e.g. with EnterCriticalSection) before notifying the main thread.\n\t\t\treturn missingScriptTypeInfo ? 1 : 0;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tprogressManager.logMessage("Unable to deserialize the asset!");\n\t\t\treturn -3;\n\t\t}\n\t}\n\tfriend class AssetViewModifyDialog;\n};\n\nAssetViewModifyDialog::AssetViewModifyDialog(AssetListDialog &assetListDialog, Win32AppContext &appContext, AssetIdentifier asset, std::string assetName)\n\t: assetListDialog(assetListDialog), appContext(appContext), assetName(std::move(assetName)),\n\thDialog(NULL), isDestroyed(false), registeredCallbackCounter(0), ignoreExpandNotifications(false),\n\thCurPopupMenu(NULL), hCurEditPopup(NULL), hCurEditPopupUpDown(NULL), hEditPopupItem(NULL), pEditValueField(nullptr), pEditAssetDesc(nullptr),\n\ttestItemHasTextcallbackActive(false), testItemHasTextcallbackResult(false)\n{\n\tassert(asset.pFile);\n\tassert(asset.pReplacer || asset.pAssetInfo);\n\n\tfindOrPrepareLoad(std::move(asset), MC_TLI_ROOT, nullptr);\n}\nAssetViewModifyDialog::~AssetViewModifyDialog()\n{\n\tif (this->hDialog)\n\t{\n\t\tSendMessage(this->hDialog, WM_CLOSE, 0, 0);\n\t\t//SetWindowLongPtr(this->hDialog, GWLP_USERDATA, 0);\n\t}\n}\nHWND AssetViewModifyDialog::_getTreeHandle(HWND hDialog)\n{\n\treturn GetDlgItem(hDialog, IDC_TYPETREE);\n}\n\nstatic void setTreeValueText(HWND hTree, MC_HTREELISTITEM hItem, AssetTypeValueField *pField)\n{\n\tTCHAR sprntTmp[64]; sprntTmp[0] = 0;\n\tTCHAR *convertedText = nullptr;\n\tconst TCHAR *text = nullptr;\n\tif (AssetTypeValue *pValue = pField->GetValue())\n\t{\n\t\tswitch (pValue->GetType())\n\t\t{\n\t\t\tcase ValueType_Bool\t\t:\n\t\t\t\ttext = (pValue->AsBool() ? TEXT("true") : TEXT("false"));\n\t\t\t\tbreak;\n\t\t\tcase ValueType_Int8\t\t:\n\t\t\tcase ValueType_UInt8\t:\n\t\t\tcase ValueType_Int16\t:\n\t\t\tcase ValueType_UInt16\t:\n\t\t\tcase ValueType_Int32\t:\n\t\t\t\t_stprintf_s(sprntTmp, TEXT("%d"), pValue->AsInt());\n\t\t\t\ttext = sprntTmp;\n\t\t\t\tbreak;\n\t\t\tcase ValueType_UInt32\t:\n\t\t\t\t_stprintf_s(sprntTmp, TEXT("%u"), pValue->AsUInt());\n\t\t\t\ttext = sprntTmp;\n\t\t\t\tbreak;\n\t\t\tcase ValueType_Int64\t:\n\t\t\t\t_stprintf_s(sprntTmp, TEXT("%lld"), pValue->AsInt64());\n\t\t\t\ttext = sprntTmp;\n\t\t\t\tbreak;\n\t\t\tcase ValueType_UInt64\t:\n\t\t\t\t_stprintf_s(sprntTmp, TEXT("%llu"), pValue->AsUInt64());\n\t\t\t\ttext = sprntTmp;\n\t\t\t\tbreak;\n\t\t\tcase ValueType_Float\t:\n\t\t\t\t_stprintf_s(sprntTmp, TEXT("%f"), pValue->AsFloat());\n\t\t\t\ttext = sprntTmp;\n\t\t\t\tbreak;\n\t\t\tcase ValueType_Double\t:\n\t\t\t\t_stprintf_s(sprntTmp, TEXT("%f"), pValue->AsDouble());\n\t\t\t\ttext = sprntTmp;\n\t\t\t\tbreak;\n\t\t\tcase ValueType_String\t:\n\t\t\t\tif (pValue->AsString())\n\t\t\t\t{\n\t\t\t\t\tstd::string valueString = std::string("\\"") + pValue->AsString() + "\\"";\n\t\t\t\t\tsize_t sizeTmp;\n\t\t\t\t\tconvertedText = _MultiByteToTCHAR(valueString.c_str(), sizeTmp);\n\t\t\t\t\ttext = convertedText;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase ValueType_Array\t:\n\t\t\t\t_stprintf_s(sprntTmp, TEXT("[%u]"), pValue->AsArray()->size);\n\t\t\t\ttext = sprntTmp;\n\t\t\t\tbreak;\n\t\t\tcase ValueType_ByteArray:\n\t\t\t\t_stprintf_s(sprntTmp, TEXT("[%u]"), pValue->AsByteArray()->size);\n\t\t\t\ttext = sprntTmp;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tif (text != nullptr)\n\t{\n\t\tMC_TLSUBITEM subItem;\n\t\tsubItem.fMask = MC_TLSIF_TEXT;\n\t\tsubItem.iSubItem = 1;\n\t\tsubItem.cchTextMax = 0;\n\t\tsubItem.pszText = const_cast<TCHAR*>(text);\n\t\tSendMessage(hTree, MC_TLM_SETSUBITEM, reinterpret_cast<WPARAM>(hItem), reinterpret_cast<LPARAM>(&subItem));\n\t}\n\tif (convertedText)\n\t{\n\t\t_FreeTCHAR(convertedText);\n\t}\n}\n\nMC_HTREELISTITEM AssetViewModifyDialog::addTreeItems(AssetDeserializeDesc *pAssetDesc, MC_HTREELISTITEM hParent, LPARAM parentLParam, \n\tAssetTypeValueField **pFields, size_t fieldCount, bool isPPtr, size_t startIdx)\n{\n\tHWND hTree = GetDlgItem(this->hDialog, IDC_TYPETREE);\n\tif (startIdx > 0 && SendMessage(hTree, MC_TLM_GETNEXTITEM, MC_TLGN_CHILD, (LPARAM)hParent) == NULL)\n\t\tstartIdx = 0; //Was never expanded.\n\n\tbool parentIsArray = false;\n\tauto arrayMappingIt = pAssetDesc->arrayMappingsByArray.end();\n\tif (AssetTypeValueField *pParentField = reinterpret_cast<AssetTypeValueField*>(parentLParam))\n\t{\n\t\tif (pParentField->GetValue() && pParentField->GetValue()->GetType() == ValueType_Array)\n\t\t{\n\t\t\tparentIsArray = true;\n\t\t\tauto insertResult = pAssetDesc->arrayMappingsByArray.insert(std::make_pair(pParentField, AssetDeserializeDesc::ArrayMappings()));\n\t\t\tarrayMappingIt = insertResult.first;\n\t\t\tassert(fieldCount <= pParentField->GetValue()->AsArray()->size);\n\t\t\tarrayMappingIt->second.treeItems.resize(pParentField->GetValue()->AsArray()->size);\n\t\t\tif (insertResult.second)\n\t\t\t{\n\t\t\t\tarrayMappingIt->second.itemToIndexMap.rehash(static_cast<size_t>(std::ceil(\n\t\t\t\t\tstatic_cast<double>(pParentField->GetValue()->AsArray()->size) / arrayMappingIt->second.itemToIndexMap.max_load_factor())));\n\t\t\t}\n\t\t}\n\t}\n\n\tstd::shared_ptr<CProgressIndicator> pProgressIndicator = std::make_shared<CProgressIndicator>(this->appContext.getMainWindow().getHInstance());\n\tif (pProgressIndicator->Start(hDialog, pProgressIndicator, 2000))\n\t{\n\t\tsize_t nTotal = fieldCount - startIdx;\n\t\tpProgressIndicator->SetStepRange(0, (nTotal > INT_MAX) ? INT_MAX : static_cast<unsigned int>(nTotal));\n\t\tpProgressIndicator->SetCancellable(true);\n\t\tpProgressIndicator->SetTitle("Adding fields to the View");\n\t}\n\telse\n\t{\n\t\tpProgressIndicator.reset();\n\t}\n\t\n\tSendMessage(hTree, WM_SETREDRAW, FALSE, 0);\n\n\tMC_HTREELISTITEM hLastItem = NULL;\n\t\n\tMC_TLINSERTSTRUCT insert;\n\tinsert.hParent = hParent;\n\tinsert.hInsertAfter = MC_TLI_LAST;\n\tinsert.item.fMask = MC_TLIF_CHILDREN | MC_TLIF_PARAM | MC_TLIF_TEXT;\n\tinsert.item.cchTextMax = 0;\n\tfor (size_t i = startIdx; i < fieldCount; i++)\n\t{\n\t\tif (pProgressIndicator && pProgressIndicator->IsCancelled())\n\t\t\tbreak;\n\t\tif (pProgressIndicator && i <= INT_MAX && (i % 101) == 0)\n\t\t{\n\t\t\tTCHAR descTmp[64];\n\t\t\t_stprintf_s(descTmp, TEXT("Adding field %llu/%llu"), \n\t\t\t\tstatic_cast<unsigned long long>(i - startIdx), static_cast<unsigned long long>(fieldCount - startIdx));\n\t\t\tpProgressIndicator->SetDescription(descTmp);\n\t\t\tpProgressIndicator->SetStepStatus(static_cast<unsigned int>(i - startIdx));\n\t\t}\n\t\tMC_HTREELISTITEM hCurParent = hParent;\n\t\tif (parentIsArray)\n\t\t{\n\t\t\tinsert.hParent = hParent;\n\t\t\tinsert.item.cChildren = 1; \n\t\t\tinsert.item.lParam = 0;\n\t\t\t//TCHAR sprntTmp[64]; sprntTmp[0] = 0;\n\t\t\t//_stprintf_s(sprntTmp, TEXT("[%llu]"), (unsigned long long)i);\n\t\t\t//insert.item.pszText = sprntTmp;\n\t\t\tinsert.item.pszText = MC_LPSTR_TEXTCALLBACK;\n\t\t\thCurParent = reinterpret_cast<MC_HTREELISTITEM>(SendMessage(hTree, MC_TLM_INSERTITEM, 0, reinterpret_cast<LPARAM>(&insert)));\n\t\t\tassert(hCurParent != NULL);\n\t\t\tif (hCurParent == NULL)\n\t\t\t\tbreak;\n\t\t\tarrayMappingIt->second.treeItems[i] = hCurParent;\n\t\t\tarrayMappingIt->second.itemToIndexMap[hCurParent] = static_cast<uint32_t>(i);\n\t\t}\n\t\tinsert.hParent = hCurParent;\n\t\tinsert.item.cChildren = (pFields[i]->GetChildrenCount() > 0) ? 1 : 0; \n\t\tinsert.item.lParam = reinterpret_cast<LPARAM>(pFields[i]);\n\t\tauto pTypeNameT = unique_MultiByteToTCHAR(pFields[i]->GetType().c_str());\n\t\tauto pFieldNameT = unique_MultiByteToTCHAR(pFields[i]->GetName().c_str());\n\t\tstd::basic_string<TCHAR> fullName = std::basic_string<TCHAR>(pTypeNameT.get()) + TEXT(" ") + pFieldNameT.get();\n\t\t//Requires a const_cast, since the item structure can also be used for text retrieval.\n\t\t//Should be safe, since the text is only read for MC_TLM_INSERTITEM.\n\t\tinsert.item.pszText = const_cast<TCHAR*>(fullName.c_str());\n\t\tMC_HTREELISTITEM hItem = reinterpret_cast<MC_HTREELISTITEM>(SendMessage(hTree, MC_TLM_INSERTITEM, 0, reinterpret_cast<LPARAM>(&insert)));\n\t\tassert(hItem != NULL);\n\t\tif (hItem == NULL)\n\t\t\tbreak;\n\t\thLastItem = hItem;\n\t\tsetTreeValueText(hTree, hItem, pFields[i]);\n\t}\n\tif (isPPtr)\n\t{\n\t\tinsert.item.cChildren = 1; \n\t\t//Use a null parameter for special items.\n\t\t// => The parent item is the PPtr. Retrieve via MC_TLM_GETNEXTITEM with MC_TLGN_PARENT.\n\t\tinsert.item.lParam = 0; \n\t\t//Requires a const_cast, since the item structure can also be used for text retrieval.\n\t\t//Should be safe, since the text is only read for MC_TLM_INSERTITEM.\n\t\tinsert.item.pszText = const_cast<TCHAR*>(TEXT("View asset"));\n\t\tMC_HTREELISTITEM hItem = reinterpret_cast<MC_HTREELISTITEM>(SendMessage(hTree, MC_TLM_INSERTITEM, 0, reinterpret_cast<LPARAM>(&insert)));\n\t}\n\tSendMessage(hTree, WM_SETREDRAW, TRUE, 0);\n\tif (pProgressIndicator != nullptr)\n\t{\n\t\tpProgressIndicator->End();\n\t\tpProgressIndicator->Free();\n\t}\n\treturn hLastItem;\n}\n\nvoid AssetViewModifyDialog::onCompletionMainThread(uintptr_t param1, uintptr_t param2)\n{\n\tAssetViewModifyDialog *pThis = reinterpret_cast<AssetViewModifyDialog*>(param1);\n\tauto ppInstanceTask = reinterpret_cast<std::shared_ptr<AssetInstanceTask>*>(param2);\n\tif (--pThis->registeredCallbackCounter == 0)\n\t\tpThis->appContext.taskManager.removeCallback(pThis);\n\tAssetDeserializeDesc *pAssetDesc = &*(*ppInstanceTask)->itDeserializeDesc;\n\tpAssetDesc->pLoadTask = nullptr;\n\tassert(pAssetDesc->pParent != nullptr || pAssetDesc->parentItem == MC_TLI_ROOT);\n\tbool closeAsset = false;\n\tbool reloadAsset = false;\n\tif (pAssetDesc->pendingClose)\n\t{\n\t\t//Remove this asset from the list, as the load task has now finished.\n\t\t//Invalidates pAssetDesc\n\t\tcloseAsset = true;\n\t}\n\telse if (pAssetDesc->pAssetInstance == nullptr\n\t\t|| pAssetDesc->pAssetInstance->GetBaseField()->IsDummy())\n\t{\n\t\tif (!pThis->isDestroyed && pThis->hDialog != NULL)\n\t\t{\n\t\t\tconst TCHAR *errorMessage = nullptr;\n\t\t\tswitch (pAssetDesc->loadTaskResult)\n\t\t\t{\n\t\t\t\tcase TaskResult_Canceled:\n\t\t\t\t\tbreak;\n\t\t\t\tcase -1:\n\t\t\t\t\terrorMessage = TEXT("Could not retrieve the type information for the asset view!");\n\t\t\t\t\tbreak;\n\t\t\t\tcase -2:\n\t\t\t\t\terrorMessage = TEXT("Unable to read the asset for viewing!");\n\t\t\t\t\tbreak;\n\t\t\t\tcase -3:\n\t\t\t\tdefault:\n\t\t\t\t\terrorMessage = TEXT("Unable to deserialize the asset for viewing!");\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (errorMessage != nullptr)\n\t\t\t\tMessageBox(pThis->hDialog, errorMessage, TEXT("Asset Bundle Extractor"), MB_ICONERROR);\n\t\t}\n\t\tcloseAsset = true;\n\t}\n\telse if (pAssetDesc->loadTaskResult == 1  //i.e. is missing MonoBehaviour type information\n\t\t&& !pAssetDesc->monoBehaviourInfoAsked)\n\t{\n\t\tAssetTypeValueField *pBaseField = pAssetDesc->pAssetInstance->GetBaseField();\n\t\tAssetTypeValueField *pFileIDField = pBaseField->Get("m_Script")->Get("m_FileID");\n\t\tstd::vector<std::shared_ptr<AssetsFileContextInfo>> typeAssets = { pAssetDesc->asset.pFile };\n\t\tbool foundScriptFile = false;\n\t\tif (!pFileIDField->IsDummy() && pFileIDField->GetValue() != nullptr && pFileIDField->GetValue()->GetType() == ValueType_Int32)\n\t\t{\n\t\t\tunsigned int absScriptFileID = pAssetDesc->asset.pFile->resolveRelativeFileID((unsigned int)pFileIDField->GetValue()->AsInt());\n\t\t\tstd::shared_ptr<AssetsFileContextInfo> scriptDefFileInfo\n\t\t\t\t= std::dynamic_pointer_cast<AssetsFileContextInfo>(pThis->appContext.getContextInfo(absScriptFileID));\n\t\t\tif (scriptDefFileInfo != nullptr)\n\t\t\t{\n\t\t\t\tfoundScriptFile = true;\n\t\t\t\tif (scriptDefFileInfo->getFileID() != pAssetDesc->asset.pFile->getFileID())\n\t\t\t\t\ttypeAssets.push_back(std::move(scriptDefFileInfo));\n\t\t\t}\n\t\t}\n\t\tif (foundScriptFile)\n\t\t{\n\t\t\tswitch (MessageBox(pThis->hDialog,\n\t\t\t\tTEXT("Class information needs to be extracted to show the complete asset data, and to not break the changed asset when saving.\\n")\n\t\t\t\tTEXT("Do you want to do this now?\\n")\n\t\t\t\tTEXT("Note: This currently does not work with il2cpp game builds."),\n\t\t\t\tTEXT("Asset Bundle Extractor"), MB_ICONWARNING | MB_YESNOCANCEL))\n\t\t\t{\n\t\t\tcase IDYES:\n\t\t\t\tpAssetDesc->monoBehaviourInfoAsked = true;\n\t\t\t\tif (GetAllScriptInformation(pThis->appContext, typeAssets))\n\t\t\t\t\treloadAsset = true;\n\t\t\t\telse\n\t\t\t\t\tcloseAsset = true;\n\t\t\t\tbreak;\n\t\t\tcase IDNO:\n\t\t\t\tbreak;\n\t\t\tcase IDCANCEL:\n\t\t\tdefault:\n\t\t\t\tcloseAsset = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif (closeAsset)\n\t{\n\t\tpThis->loadedAssets.erase((*ppInstanceTask)->itDeserializeDesc);\n\t\tif (!pThis->isDestroyed && pThis->loadedAssets.size() == 1)\n\t\t{\n\t\t\tassert(&pThis->loadedAssets.front() == pAssetDesc);\n\t\t\tpThis->assetListDialog.removeModifyDialog(pThis);\n\t\t\tpThis->isDestroyed = true;\n\t\t}\n\t}\n\telse if (reloadAsset)\n\t{\n\t\tpAssetDesc->pLoadTask = nullptr;\n\t\tpAssetDesc->pAssetInstance.reset();\n\t\tpThis->startLoadTask((*ppInstanceTask)->itDeserializeDesc, (*ppInstanceTask)->pDialog);\n\t}\n\telse\n\t{\n\t\tassert(pAssetDesc->pAssetInstance != nullptr);\n\t\tAssetTypeValueField *pBaseField = pAssetDesc->pAssetInstance->GetBaseField();\n\t\tMC_HTREELISTITEM hBaseItem = pThis->addTreeItems(pAssetDesc, pAssetDesc->parentItem, 0, &pBaseField, 1, false);\n\t\tpAssetDesc->baseItem = hBaseItem;\n\t\tpThis->loadedAssetsByBaseItem.insert(std::make_pair(hBaseItem, (*ppInstanceTask)->itDeserializeDesc));\n\t}\n\tdelete ppInstanceTask;\n}\ntypedef void(*CallbackProc)(uintptr_t,uintptr_t);\n\nvoid AssetViewModifyDialog::OnCompletion(std::shared_ptr<ITask>& pTask, TaskResult result)\n{\n\t//Not necessarily run from the main thread.\n\tif (std::shared_ptr<AssetInstanceTask> pInstanceTask = std::dynamic_pointer_cast<AssetInstanceTask>(pTask))\n\t{\n\t\tif (pInstanceTask->pDialog.get() != this)\n\t\t\treturn;\n\t\tassert(pInstanceTask->itDeserializeDesc->pLoadTask == pTask.get());\n\t\tpInstanceTask->itDeserializeDesc->loadTaskResult = result;\n\n\t\tCallbackProc callback = onCompletionMainThread;\n\t\tappContext.signalMainThread(AppContextMsg_DoMainThreadCallback,\n\t\t\tnew std::tuple<void(*)(uintptr_t, uintptr_t), uintptr_t, uintptr_t>(\n\t\t\t\tcallback,\n\t\t\t\treinterpret_cast<uintptr_t>(this),\n\t\t\t\treinterpret_cast<uintptr_t>(new std::shared_ptr<AssetInstanceTask>(pInstanceTask))));\n\t}\n}\nbool AssetViewModifyDialog::init(std::shared_ptr<AssetViewModifyDialog> &selfPtr, HWND hParentWnd)\n{\n\tassert(selfPtr.get() == this);\n\tassert(this->loadedAssets.size() == 1);\n\tassert(this->loadedAssets.front().pLoadTask == nullptr &&\n\t\tthis->loadedAssets.front().pAssetInstance == nullptr);\n\tif (this->loadedAssets.size() != 1)\n\t\treturn false;\n\treturn startLoadTask(this->loadedAssets.begin(), selfPtr);\n}\nstd::list<AssetViewModifyDialog::AssetDeserializeDesc>::iterator \n\tAssetViewModifyDialog::findOrPrepareLoad(AssetIdentifier asset, MC_HTREELISTITEM parentItem, AssetDeserializeDesc *pParentAsset,\n\t\tAssetTypeValueField *pPPtrField)\n{\n\tif (!asset.resolve(appContext))\n\t\treturn loadedAssets.end();\n\tunsigned int fileID = asset.pFile->getFileID();\n\tpathid_t pathID = asset.pathID;\n\n\tauto mapIt = loadedAssetsByPPtr.find(AssetAbsPPtr(fileID, pathID));\n\tif (mapIt != loadedAssetsByPPtr.end())\n\t\treturn mapIt->second;\n\n\tauto assetListEntryIt = loadedAssets.insert(loadedAssets.end(), AssetDeserializeDesc());\n\tassetListEntryIt->asset = std::move(asset);\n\tassetListEntryIt->parentItem = parentItem;\n\tassetListEntryIt->pParent = pParentAsset;\n\tif (pParentAsset != nullptr)\n\t{\n\t\tassert(pPPtrField != nullptr);\n\t\tpParentAsset->children.push_back(std::make_pair(pPPtrField, assetListEntryIt));\n\t}\n\telse\n\t\tassert(parentItem == MC_TLI_ROOT);\n\n\tloadedAssetsByPPtr.emplace(std::make_pair(AssetAbsPPtr(fileID, pathID), assetListEntryIt));\n\tif (pPPtrField != nullptr)\n\t\tloadedAssetsByPPtrField.emplace(std::make_pair(pPPtrField, assetListEntryIt));\n\treturn assetListEntryIt;\n}\nbool AssetViewModifyDialog::startLoadTask(std::list<AssetDeserializeDesc>::iterator assetEntry, std::shared_ptr<AssetViewModifyDialog> selfPtr)\n{\n\tif (assetEntry->pLoadTask != nullptr || assetEntry->pAssetInstance)\n\t\treturn true;\n\tif (this->isDestroyed)\n\t\treturn false;\n\tif (!selfPtr)\n\t{\n\t\tselfPtr = std::static_pointer_cast<AssetViewModifyDialog,AssetModifyDialog>(this->assetListDialog.getModifyDialogRef(this));\n\t\tif (!selfPtr)\n\t\t\treturn false;\n\t}\n\n\tstd::shared_ptr<AssetInstanceTask> pLoadTask = std::make_shared<AssetInstanceTask>(std::move(selfPtr), assetEntry);\n\tassetEntry->pLoadTask = pLoadTask.get();\n\n\tif (this->registeredCallbackCounter++ == 0)\n\t\tappContext.taskManager.addCallback(this);\n\tif (appContext.taskManager.enqueue(pLoadTask))\n\t\treturn true;\n\tif (--this->registeredCallbackCounter == 0)\n\t\tappContext.taskManager.removeCallback(this);\n\n\tassetEntry->pLoadTask = nullptr;\n\treturn false;\n}\nAssetViewModifyDialog::AssetDeserializeDesc *AssetViewModifyDialog::getAssetDescForItem(MC_HTREELISTITEM item)\n{\n\tHWND hTree = GetDlgItem(this->hDialog, IDC_TYPETREE);\n\tdo {\n\t\tauto mapIt = this->loadedAssetsByBaseItem.find(item);\n\t\tif (mapIt != this->loadedAssetsByBaseItem.end())\n\t\t\treturn &*mapIt->second;\n\t\titem = reinterpret_cast<MC_HTREELISTITEM>(SendMessage(hTree, MC_TLM_GETNEXTITEM, MC_TLGN_PARENT, reinterpret_cast<LPARAM>(item)));\n\t} while (item != NULL);\n\treturn nullptr;\n}\n//Called when the user requests to close the tab.\n//Returns true if there are unsaved changes, false otherwise.\n//If the function will return true and applyable is not null,\n// *applyable will be set to true iff applyNow() is assumed to succeed without further interaction\n// (e.g. all fields in the dialog have a valid value, ...).\n//The caller uses this info to decide whether and how it should display a confirmation dialog before proceeding.\nbool AssetViewModifyDialog::hasUnappliedChanges(bool *applyable)\n{\n\tbool ret = false;\n\tfor (auto assetIt = this->loadedAssets.begin(); assetIt != this->loadedAssets.end(); ++assetIt)\n\t{\n\t\tif (assetIt->hasChanged && assetIt->pAssetInstance != nullptr\n\t\t\t&& assetIt->pAssetInstance->GetBaseField(0) != nullptr\n\t\t\t&& assetIt->asset.pFile != nullptr)\n\t\t{\n\t\t\tret = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (ret && applyable) *applyable = true;\n\treturn ret;\n}\ntemplate<class ForwardIt>\nbool AssetViewModifyDialog::applyChangesIn(ForwardIt assetBegin, ForwardIt assetEnd)\n{\n\t//Check for conflicting changes, e.g. if the user changed the same asset in a different tab without closing this one.\n\tbool hasConflictingChanges = false;\n\tfor (auto assetIt = assetBegin; assetIt != assetEnd; ++assetIt)\n\t{\n\t\tAssetDeserializeDesc &assetDesc = *assetIt;\n\t\tif (assetDesc.hasChanged && assetDesc.pAssetInstance != nullptr\n\t\t\t&& assetDesc.pAssetInstance->GetBaseField(0) != nullptr\n\t\t\t&& assetDesc.asset.pFile != nullptr)\n\t\t{\n\t\t\tstd::shared_ptr<AssetsReplacer> pCurrentReplacer = assetDesc.asset.pFile->getReplacer(assetDesc.asset.pathID);\n\t\t\tif (pCurrentReplacer.get() != assetDesc.asset.pReplacer.get())\n\t\t\t{\n\t\t\t\thasConflictingChanges = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif (hasConflictingChanges)\n\t{\n\t\tHWND hParent = this->hDialog;\n\t\tif (hParent == NULL)\n\t\t\thParent = this->appContext.getMainWindow().getWindow();\n\t\tstd::string message = std::string("Applying changes in the tab <") + this->getTabName() + \n\t\t\tstd::string("> will overwrite existing changes.\\n Do you want to proceed anyway?");\n\t\tauto messageT = unique_MultiByteToTCHAR(message.c_str());\n\t\tswitch (MessageBox(hParent, messageT.get(), TEXT("Asset Bundle Extractor"), MB_YESNO))\n\t\t{\n\t\tcase IDYES:\n\t\t\tbreak;\n\t\tcase IDNO:\n\t\t\treturn false;\n\t\t}\n\t}\n\tfor (auto assetIt = assetBegin; assetIt != assetEnd; ++assetIt)\n\t{\n\t\tAssetDeserializeDesc &assetDesc = *assetIt;\n\t\tif (assetDesc.hasChanged && assetDesc.pAssetInstance != nullptr\n\t\t\t&& assetDesc.pAssetInstance->GetBaseField(0) != nullptr\n\t\t\t&& assetDesc.asset.pFile != nullptr)\n\t\t{\n\t\t\tIAssetsWriterToMemory *pWriter = Create_AssetsWriterToMemory();\n\t\t\tQWORD size = assetDesc.pAssetInstance->GetBaseField(0)->Write(pWriter, 0, assetDesc.asset.isBigEndian());\n\t\t\tsize_t bufferSize = 0;\n\t\t\tvoid *buffer = nullptr;\n\t\t\tif (pWriter->GetBuffer(buffer, bufferSize))\n\t\t\t{\n\t\t\t\tAssetsEntryReplacer *pReplacer = MakeAssetModifierFromMemory(\n\t\t\t\t\tassetDesc.asset.pFile->getFileID(), assetDesc.asset.pathID, \n\t\t\t\t\tassetDesc.asset.getClassID(), assetDesc.asset.getMonoScriptID(), \n\t\t\t\t\tbuffer, bufferSize, Free_AssetsWriterToMemory_DynBuf);\n\t\t\t\tassetDesc.asset.pReplacer.reset(pReplacer);\n\t\t\t\tassetDesc.asset.pFile->addReplacer(assetDesc.asset.pReplacer, this->appContext);\n\t\t\t\tassetDesc.hasChanged = false;\n\t\t\t\tassert(size == bufferSize);\n\t\t\t}\n\t\t\telse\n\t\t\t\tassert(false);\n\t\t}\n\t}\n\treturn true;\n}\n//std::vector<std::pair<AssetTypeValueField*, std::list<AssetDeserializeDesc>::iterator>>\n//Called when the user requests to apply the changes (e.g. selecting Apply, Save or Save All in the menu).\n//Returns whether the changes have been applied;\n// if true, the caller may continue closing the AssetModifyDialog.\n// if false, the caller may stop closing the AssetModifyDialog.\n//Note: applyChanges() is expected to notify the user about errors (e.g. via MessageBox).\nbool AssetViewModifyDialog::applyChanges()\n{\n\treturn this->applyChangesIn(this->loadedAssets.begin(), this->loadedAssets.end());\n}\nstd::string AssetViewModifyDialog::getTabName()\n{\n\tif (this->assetName.empty())\n\t{\n\t\tif (this->loadedAssets.size() >= 1)\n\t\t{\n\t\t\tAssetIdentifier &asset = this->loadedAssets.front().asset;\n\t\t\treturn std::format("View Asset (FileID {}, PathID {})",\n\t\t\t\tstatic_cast<uint64_t>(asset.pFile->getFileID()), std::to_string(asset.pathID));\n\t\t}\n\t\treturn "View Asset";\n\t}\n\tif (this->loadedAssets.size() >= 1)\n\t{\n\t\tAssetIdentifier& asset = this->loadedAssets.front().asset;\n\t\treturn std::format("View Asset \\"{}\\" (FileID {}, PathID {})", this->assetName,\n\t\t\tstatic_cast<uint64_t>(asset.pFile->getFileID()), std::to_string(asset.pathID));\n\t}\n\treturn "View Asset \\"" + this->assetName + "\\"";\n}\nHWND AssetViewModifyDialog::getWindowHandle()\n{\n\treturn hDialog;\n}\n//Called for unhandled WM_COMMAND messages. Returns true if this dialog has handled the request, false otherwise.\nbool AssetViewModifyDialog::onCommand(WPARAM wParam, LPARAM lParam)\n{\n\tint wmId = LOWORD(wParam);\n\treturn false;\n}\nvoid AssetViewModifyDialog::onHotkey(ULONG message, DWORD keyCode) //message : currently only WM_KEYDOWN; keyCode : VK_F3 for instance\n{\n\t\n}\nvoid AssetViewModifyDialog::onShow(HWND hParentWnd)\n{\n\tif (!this->hDialog)\n\t{\n\t\tthis->hDialog = CreateDialogParam(appContext.getMainWindow().getHInstance(), MAKEINTRESOURCE(IDD_ASSETVIEW), hParentWnd, AssetViewProc, (LPARAM)this);\n\t}\n\telse\n\t{\n\t\tSetParent(this->hDialog, hParentWnd);\n\t\tShowWindow(this->hDialog, SW_SHOW);\n\t}\n}\n//Called when the dialog is to be hidden, either because of a tab switch or while closing the tab.\nvoid AssetViewModifyDialog::onHide()\n{\n\tif (this->hDialog)\n\t{\n\t\tShowWindow(this->hDialog, SW_HIDE);\n\t\tSetParent(this->hDialog, NULL);\n\t\t//SendMessage(this->hDialog, WM_CLOSE, 0, 0);\n\t}\n}\n//Called when the tab is about to be destroyed.\nvoid AssetViewModifyDialog::onDestroy()\n{\n\tthis->isDestroyed = true;\n}\n\nINT_PTR CALLBACK AssetViewModifyDialog::AssetViewProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)\n{\n\tINT_PTR ret = (INT_PTR)FALSE;\n\tAssetViewModifyDialog *pThis = (AssetViewModifyDialog*)GetWindowLongPtr(hDlg, GWLP_USERDATA);\n\tswitch (message)\n\t{\n\tcase WM_CLOSE:\n\t\tif (pThis)\n\t\t\tpThis->hDialog = NULL;\n\t\tDestroyWindow(hDlg);\n\t\tret = (INT_PTR)TRUE;\n\t\tbreak;\n\tcase WM_INITDIALOG:\n\t\t{\n\t\t\tSetWindowLongPtr(hDlg, GWLP_USERDATA, lParam);\n\t\t\tpThis = (AssetViewModifyDialog*)lParam;\n\t\t\tpThis->testItemHasTextcallbackActive = false;\n\t\t\t{\n\t\t\t\tHWND hTree = GetDlgItem(hDlg, IDC_TYPETREE);\n\t\t\t\tMC_TLCOLUMN col;\n\t\t\t\tcol.fMask = MC_TLCF_TEXT | MC_TLCF_WIDTH;\n\t\t\t\tcol.pszText = const_cast<TCHAR*>(_T("Field"));\n\t\t\t\tcol.cx = 540;\n\t\t\t\tcol.cchTextMax = static_cast<int>(_tcslen(col.pszText)) + 1;\n\t\t\t\tSendMessage(hTree, MC_TLM_INSERTCOLUMN, 0, (LPARAM)&col);\n\t\t\t\tcol.pszText = const_cast<TCHAR*>(_T("Value"));\n\t\t\t\tcol.cchTextMax = static_cast<int>(_tcslen(col.pszText)) + 1;\n\t\t\t\tcol.cx = 160;\n\t\t\t\tSendMessage(hTree, MC_TLM_INSERTCOLUMN, 1, (LPARAM)&col);\n\n\t\t\t\tSetWindowSubclass(hTree, AssetTreeListSubclassProc, 0, reinterpret_cast<DWORD_PTR>(pThis));\n\t\t\t}\n\t\t\tPostMessage(hDlg, WM_SIZE, 0, 0);\n\t\t}\n\t\tbreak;\n\tcase WM_SIZE:\n\t\t{\n\t\t\tRECT client = {};\n\t\t\tGetClientRect(hDlg, &client);\n\t\t\tLONG clientWidth = client.right-client.left;\n\t\t\tLONG clientHeight = client.bottom-client.top;\n\t\t\tSetWindowPos(GetDlgItem(hDlg, IDC_TYPETREE), HWND_TOP, 5, 5, clientWidth - 10, clientHeight - 10,\n\t\t\t\tSWP_NOACTIVATE | SWP_NOOWNERZORDER | SWP_NOZORDER);\n\t\t}\n\t\tbreak;\n\tcase WM_DRAWITEM:\n\t\t{\n\n\t\t}\n\t\tbreak;\n\tcase WM_CONTEXTMENU:\n\t\tif (reinterpret_cast<HWND>(wParam) == GetDlgItem(hDlg, IDC_TYPETREE))\n\t\t{\n\t\t\tHWND hTree = reinterpret_cast<HWND>(wParam);\n\t\t\tPOINT screenClickPos;\n\t\t\tscreenClickPos.x = GET_X_LPARAM(lParam); //Screen area\n\t\t\tscreenClickPos.y = GET_Y_LPARAM(lParam);\n\t\t\tbool foundHitItem = false;\n\t\t\tMC_TLHITTESTINFO hitTestInfo = {};\n\t\t\thitTestInfo.pt.x = screenClickPos.x;\n\t\t\thitTestInfo.pt.y = screenClickPos.y;\n\t\t\tif (screenClickPos.x == -1 && screenClickPos.y == -1)\n\t\t\t{\n\t\t\t\thitTestInfo.hItem = reinterpret_cast<MC_HTREELISTITEM>(SendMessage(hTree, MC_TLM_GETNEXTITEM, MC_TLGN_CARET, NULL));\n\t\t\t\thitTestInfo.iSubItem = 0;\n\t\t\t\tif (hitTestInfo.hItem != NULL)\n\t\t\t\t{\t\n\t\t\t\t\tRECT itemRect = {};\n\t\t\t\t\titemRect.left = MC_TLIR_SELECTBOUNDS;\n\t\t\t\t\tif (SendMessage(hTree, MC_TLM_GETITEMRECT, reinterpret_cast<WPARAM>(hitTestInfo.hItem), reinterpret_cast<LPARAM>(&itemRect)))\n\t\t\t\t\t{\n\t\t\t\t\t\tscreenClickPos.x = itemRect.left + (itemRect.right - itemRect.left) / 2;\n\t\t\t\t\t\tscreenClickPos.y = itemRect.top + (itemRect.bottom - itemRect.top) / 2;\n\t\t\t\t\t\tif (ClientToScreen(hTree, &screenClickPos))\n\t\t\t\t\t\t\tfoundHitItem = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (ScreenToClient(hTree, &hitTestInfo.pt) &&\n\t\t\t\t\tSendMessage(hTree, MC_TLM_HITTEST, 0, reinterpret_cast<LPARAM>(&hitTestInfo)) != NULL)\n\t\t\t\t{\n\t\t\t\t\t//Select this item.\n\t\t\t\t\tMC_TLITEM item;\n\t\t\t\t\titem.fMask = MC_TLIF_STATE;\n\t\t\t\t\titem.state = MC_TLIS_SELECTED;\n\t\t\t\t\titem.stateMask = MC_TLIS_SELECTED;\n\t\t\t\t\tSendMessage(hTree, MC_TLM_SETITEM,  \n\t\t\t\t\t\treinterpret_cast<WPARAM>(hitTestInfo.hItem),\n\t\t\t\t\t\treinterpret_cast<LPARAM>(&item));\n\t\t\t\t\tfoundHitItem = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (foundHitItem)\n\t\t\t{\n\t\t\t\tassert(hitTestInfo.hItem != NULL);\n\t\t\t\tif (pThis->hCurEditPopup != NULL)\n\t\t\t\t\tpThis->doCloseEditPopup();\n\n\t\t\t\tMC_TLITEM item;\n\t\t\t\titem.fMask = MC_TLIF_PARAM;\n\t\t\t\titem.lParam = 0;\n\t\t\t\tif (!SendMessage(hTree, MC_TLM_GETITEM, \n\t\t\t\t\t\treinterpret_cast<WPARAM>(hitTestInfo.hItem),\n\t\t\t\t\t\treinterpret_cast<LPARAM>(&item)))\n\t\t\t\t\tbreak;\n\t\t\t\tif (item.lParam == 0 || hitTestInfo.hItem == (MC_HTREELISTITEM)SendMessage(hTree, MC_TLM_GETNEXTITEM, MC_TLGN_ROOT, NULL))\n\t\t\t\t{\n\t\t\t\t\t//if (hitTestInfo.iSubItem != 0)\n\t\t\t\t\t//\tbreak;\n\t\t\t\t\t//Array index PPtr [View asset] node or base node\n\t\t\t\t\tMC_HTREELISTITEM hParentItem = reinterpret_cast<MC_HTREELISTITEM>(\n\t\t\t\t\t\tSendMessage(hTree, MC_TLM_GETNEXTITEM, MC_TLGN_PARENT,\n\t\t\t\t\t\t\treinterpret_cast<LPARAM>(hitTestInfo.hItem)));\n\t\t\t\t\titem.fMask = MC_TLIF_PARAM;\n\t\t\t\t\titem.lParam = NULL;\n\t\t\t\t\tif ((hParentItem != NULL) && (!SendMessage(hTree, MC_TLM_GETITEM,\n\t\t\t\t\t\t\treinterpret_cast<WPARAM>(hParentItem),\n\t\t\t\t\t\t\treinterpret_cast<LPARAM>(&item))\n\t\t\t\t\t\t\t|| item.lParam == NULL))\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tAssetTypeValueField *pParentValueField = reinterpret_cast<AssetTypeValueField*>(item.lParam);\n\t\t\t\t\tAssetDeserializeDesc *pAssetDesc = pThis->getAssetDescForItem(hParentItem ? hParentItem : hitTestInfo.hItem);\n\t\t\t\t\tif (!pAssetDesc)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tbool isRootItem = (hParentItem == NULL);\n\n\t\t\t\t\tpThis->openContextMenuPopup(hTree, screenClickPos,\n\t\t\t\t\t\tisRootItem ? MC_TLI_ROOT : hitTestInfo.hItem, nullptr,\n\t\t\t\t\t\thParentItem, pParentValueField, \n\t\t\t\t\t\tpAssetDesc);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t//Normal nodes with a linked AssetTypeValueField.\n\t\t\t\t\tAssetTypeValueField *pValueField = reinterpret_cast<AssetTypeValueField*>(item.lParam);\n\t\t\t\t\tAssetDeserializeDesc *pAssetDesc = pThis->getAssetDescForItem(hitTestInfo.hItem);\n\t\t\t\t\tif (!pAssetDesc)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t\n\t\t\t\t\tpThis->openContextMenuPopup(hTree, screenClickPos,\n\t\t\t\t\t\thitTestInfo.hItem, pValueField, \n\t\t\t\t\t\tNULL, nullptr, //Don\'t retrieve the parent information (since it is not needed)\n\t\t\t\t\t\tpAssetDesc);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase WM_NOTIFY:\n\t\t{\n\t\t\tNMHDR *pNotifyHeader = reinterpret_cast<NMHDR*>(lParam);\n\t\t\tswitch (pNotifyHeader->code)\n\t\t\t{\n\t\t\t\tcase MC_TLN_GETDISPINFO:\n\t\t\t\t\tif (pNotifyHeader->hwndFrom == GetDlgItem(hDlg, IDC_TYPETREE) && !pThis->ignoreExpandNotifications)\n\t\t\t\t\t{\n\t\t\t\t\t\tMC_NMTLDISPINFO *pNotify = reinterpret_cast<MC_NMTLDISPINFO*>(lParam);\n\t\t\t\t\t\tif (pThis->testItemHasTextcallbackActive)\n\t\t\t\t\t\t\tpThis->testItemHasTextcallbackResult = (pNotify->item.fMask & MC_TLIF_TEXT) ? true : false;\n\t\t\t\t\t\tassert((pNotify->item.fMask & ~MC_TLIF_TEXT) == 0);\n\t\t\t\t\t\tif (pNotify->item.fMask & MC_TLIF_TEXT)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tMC_HTREELISTITEM hArrayItem = reinterpret_cast<MC_HTREELISTITEM>(\n\t\t\t\t\t\t\t\tSendMessage(pNotifyHeader->hwndFrom, MC_TLM_GETNEXTITEM, MC_TLGN_PARENT, reinterpret_cast<LPARAM>(pNotify->hItem)));\n\t\t\t\t\t\t\tif (hArrayItem == NULL)\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tMC_TLITEM item;\n\t\t\t\t\t\t\titem.fMask = MC_TLIF_PARAM;\n\t\t\t\t\t\t\titem.lParam = 0;\n\t\t\t\t\t\t\tif (!SendMessage(pNotifyHeader->hwndFrom, MC_TLM_GETITEM, \n\t\t\t\t\t\t\t\treinterpret_cast<WPARAM>(hArrayItem),\n\t\t\t\t\t\t\t\treinterpret_cast<LPARAM>(&item)) || item.lParam == NULL)\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tAssetDeserializeDesc *pAssetDesc = pThis->getAssetDescForItem(hArrayItem);\n\t\t\t\t\t\t\tif (pAssetDesc == nullptr)\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tauto mappingIt = pAssetDesc->arrayMappingsByArray.find(reinterpret_cast<AssetTypeValueField*>(item.lParam));\n\t\t\t\t\t\t\tif (mappingIt == pAssetDesc->arrayMappingsByArray.end())\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tauto indexMapIt = mappingIt->second.itemToIndexMap.find(pNotify->hItem);\n\t\t\t\t\t\t\tif (indexMapIt == mappingIt->second.itemToIndexMap.end())\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t//Get the text of an array index item.\n\t\t\t\t\t\t\t_stprintf_s(pThis->itemTextcallbackBuf, TEXT("[%u]"), indexMapIt->second);\n\t\t\t\t\t\t\tpNotify->item.pszText = pThis->itemTextcallbackBuf;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase MC_TLN_EXPANDED:\n\t\t\t\t\tif (pNotifyHeader->hwndFrom == GetDlgItem(hDlg, IDC_TYPETREE) && !pThis->ignoreExpandNotifications)\n\t\t\t\t\t{\n\t\t\t\t\t\tMC_NMTREELIST *pNotify = reinterpret_cast<MC_NMTREELIST*>(lParam);\n\t\t\t\t\t\tif (pNotify->action == MC_TLE_EXPAND)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t//Check if the child tree items already exist\n\t\t\t\t\t\t\tif (SendMessage(pNotify->hdr.hwndFrom, MC_TLM_GETNEXTITEM, MC_TLGN_CHILD, reinterpret_cast<LPARAM>(pNotify->hItemNew)) != NULL)\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tif (pNotify->lParamNew == 0)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif (pThis->testItemHasTextcallback(pNotify->hdr.hwndFrom, pNotify->hItemNew))\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t//Currently, only array index items use MC_LPSTR_TEXTCALLBACK.\n\t\t\t\t\t\t\t\t\t//Array index items should always have a child in the tree list.\n\t\t\t\t\t\t\t\t\tassert(false);\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t//Special case - PPtr "View asset" node\n\t\t\t\t\t\t\t\tMC_HTREELISTITEM hPPtrNode = reinterpret_cast<MC_HTREELISTITEM>(\n\t\t\t\t\t\t\t\t\tSendMessage(pNotify->hdr.hwndFrom, MC_TLM_GETNEXTITEM, MC_TLGN_PARENT, reinterpret_cast<LPARAM>(pNotify->hItemNew)));\n\t\t\t\t\t\t\t\tassert(hPPtrNode != NULL);\n\t\t\t\t\t\t\t\tif (hPPtrNode == NULL)\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t//Find the asset behind this PPtr.\n\t\t\t\t\t\t\t\tAssetDeserializeDesc *pAssetDesc = pThis->getAssetDescForItem(hPPtrNode);\n\t\t\t\t\t\t\t\tif (pAssetDesc == nullptr)\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\tMC_TLITEM item;\n\t\t\t\t\t\t\t\titem.fMask = MC_TLIF_PARAM;\n\t\t\t\t\t\t\t\titem.lParam = 0;\n\t\t\t\t\t\t\t\tSendMessage(pNotify->hdr.hwndFrom, MC_TLM_GETITEM, \n\t\t\t\t\t\t\t\t\treinterpret_cast<WPARAM>(hPPtrNode),\n\t\t\t\t\t\t\t\t\treinterpret_cast<LPARAM>(&item));\n\t\t\t\t\t\t\t\tif (AssetTypeValueField *pPPtrField = reinterpret_cast<AssetTypeValueField*>(item.lParam))\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t//Retrieve the relative File/Path ID.\n\t\t\t\t\t\t\t\t\tAssetTypeValueField *pFileIDField = pPPtrField->Get("m_FileID");\n\t\t\t\t\t\t\t\t\tAssetTypeValueField *pPathIDField = pPPtrField->Get("m_PathID");\n\t\t\t\t\t\t\t\t\tif (pFileIDField->GetValue() != nullptr && pPathIDField->GetValue() != nullptr)\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t//Initialize the AssetDeserializeDesc structure and add it to the list,\n\t\t\t\t\t\t\t\t\t\t// or find an existing structure for the target asset.\n\t\t\t\t\t\t\t\t\t\tauto newAssetDescIt = pThis->findOrPrepareLoad(AssetIdentifier(\n\t\t\t\t\t\t\t\t\t\t\t\tpAssetDesc->asset.pFile, //Reference source is the file containing the referring asset\n\t\t\t\t\t\t\t\t\t\t\t\tpFileIDField->GetValue()->AsUInt(), //Relative File ID for the referred asset\n\t\t\t\t\t\t\t\t\t\t\t\tpPathIDField->GetValue()->AsUInt64()),\n\t\t\t\t\t\t\t\t\t\t\tpNotify->hItemNew, pAssetDesc, pPPtrField);\n\t\t\t\t\t\t\t\t\t\tif (newAssetDescIt == pThis->loadedAssets.end())\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tMessageBox(hDlg, TEXT("Unable to resolve the target asset."), TEXT("Asset Bundle Extractor"), MB_ICONERROR);\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tif (newAssetDescIt->pLoadTask == nullptr && !newAssetDescIt->pAssetInstance)\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t//Enqueue a task to load the asset.\n\t\t\t\t\t\t\t\t\t\t\tpThis->startLoadTask(newAssetDescIt);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t//findOrPrepareLoad returned an existing asset that is either loading or has loaded already.\n\t\t\t\t\t\t\t\t\t\t\tMC_HTREELISTITEM itemToFocus = newAssetDescIt->parentItem;\n\t\t\t\t\t\t\t\t\t\t\tif (itemToFocus == MC_TLI_ROOT)\n\t\t\t\t\t\t\t\t\t\t\t\titemToFocus = reinterpret_cast<MC_HTREELISTITEM>(\n\t\t\t\t\t\t\t\t\t\t\t\t\tSendMessage(pNotify->hdr.hwndFrom, MC_TLM_GETNEXTITEM, MC_TLGN_ROOT, NULL));\n\t\t\t\t\t\t\t\t\t\t\tif (itemToFocus == NULL)\n\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t\t//Collapse the just expanded item again.\n\t\t\t\t\t\t\t\t\t\t\tSendMessage(pNotify->hdr.hwndFrom, MC_TLM_EXPAND, MC_TLE_COLLAPSE, reinterpret_cast<LPARAM>(pNotify->hItemNew));\n\t\t\t\t\t\t\t\t\t\t\t//Select and go to an existing "View asset" node for the target asset.\n\t\t\t\t\t\t\t\t\t\t\titem.fMask = MC_TLIF_STATE;\n\t\t\t\t\t\t\t\t\t\t\titem.state = MC_TLIS_SELECTED;\n\t\t\t\t\t\t\t\t\t\t\titem.stateMask = MC_TLIS_SELECTED;\n\t\t\t\t\t\t\t\t\t\t\tSendMessage(pNotify->hdr.hwndFrom, MC_TLM_SETITEM, \n\t\t\t\t\t\t\t\t\t\t\t\treinterpret_cast<WPARAM>(itemToFocus),\n\t\t\t\t\t\t\t\t\t\t\t\treinterpret_cast<LPARAM>(&item));\n\t\t\t\t\t\t\t\t\t\t\tSendMessage(pNotify->hdr.hwndFrom, MC_TLM_ENSUREVISIBLE, 0, reinterpret_cast<LPARAM>(itemToFocus));\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tAssetTypeValueField *pField = reinterpret_cast<AssetTypeValueField*>(pNotify->lParamNew);\n\n\t\t\t\t\t\t\t\t//Find the asset.\n\t\t\t\t\t\t\t\tAssetDeserializeDesc *pAssetDesc = pThis->getAssetDescForItem(pNotify->hItemNew);\n\t\t\t\t\t\t\t\tif (pAssetDesc == nullptr)\n\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\tbool isPPtr = false;\n\t\t\t\t\t\t\t\tconst char *typeName = pField->GetType().c_str();\n\t\t\t\t\t\t\t\tif (typeName && !strncmp(typeName, "PPtr<", 5))\n\t\t\t\t\t\t\t\t\tisPPtr = true;\n\t\t\t\t\t\t\t\tpThis->ignoreExpandNotifications = true;\n\t\t\t\t\t\t\t\t//Collapse the just expanded item again to prevent scrollbar redraw.\n\t\t\t\t\t\t\t\tSendMessage(pNotify->hdr.hwndFrom, MC_TLM_EXPAND, MC_TLE_COLLAPSE, reinterpret_cast<LPARAM>(pNotify->hItemNew));\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\tpThis->addTreeItems(pAssetDesc, pNotify->hItemNew, pNotify->lParamNew, pField->GetChildrenList(), pField->GetChildrenCount(), isPPtr);\n\n\t\t\t\t\t\t\t\t//Expand the item to redraw.\n\t\t\t\t\t\t\t\tSendMessage(pNotify->hdr.hwndFrom, MC_TLM_EXPAND, MC_TLE_EXPAND, reinterpret_cast<LPARAM>(pNotify->hItemNew));\n\t\t\t\t\t\t\t\tpThis->ignoreExpandNotifications = false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t//case UDN_DELTAPOS:\n\t\t\t\t//\tbreak;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n\treturn ret;\n}\nbool AssetViewModifyDialog::testItemHasTextcallback(HWND hTree, MC_HTREELISTITEM hItem)\n{\n\tMC_TLITEM item;\n\titem.fMask = MC_TLIF_TEXT;\n\titem.pszText = nullptr;\n\titem.cchTextMax = 0;\n\tthis->testItemHasTextcallbackResult = false;\n\tthis->testItemHasTextcallbackActive = true;\n\tSendMessage(hTree, MC_TLM_GETITEM, \n\t\treinterpret_cast<WPARAM>(hItem),\n\t\treinterpret_cast<LPARAM>(&item));\n\tthis->testItemHasTextcallbackActive = false;\n\treturn this->testItemHasTextcallbackResult;\n}\nstatic void FreeFieldRecursively(AssetTypeValueField *pField, std::unordered_set<uint8_t*> &allocatedMemory)\n{\n\tif (pField->GetValue() && pField->GetValue()->GetType() == ValueType_String)\n\t{\n\t\tauto memoryEntryIt = allocatedMemory.find(reinterpret_cast<uint8_t*>(pField->GetValue()->AsString()));\n\t\tif (memoryEntryIt != allocatedMemory.end())\n\t\t{\n\t\t\tdelete[] *memoryEntryIt;\n\t\t\tallocatedMemory.erase(memoryEntryIt);\n\t\t}\n\t}\n\tfor (DWORD i = 0; i < pField->GetChildrenCount(); i++)\n\t{\n\t\tFreeFieldRecursively(pField->Get(i), allocatedMemory);\n\t}\n\tAssetTypeValueField **pChildList = pField->GetChildrenList();\n\tauto fieldMemoryEntryIt = allocatedMemory.find(reinterpret_cast<uint8_t*>(pField));\n\tif (fieldMemoryEntryIt != allocatedMemory.end())\n\t{\n\t\tdelete[] *fieldMemoryEntryIt;\n\t\tallocatedMemory.erase(fieldMemoryEntryIt);\n\t}\n\tauto childListMemoryEntryIt = allocatedMemory.find(reinterpret_cast<uint8_t*>(pChildList));\n\tif (childListMemoryEntryIt != allocatedMemory.end())\n\t{\n\t\tdelete[] *childListMemoryEntryIt;\n\t\tallocatedMemory.erase(childListMemoryEntryIt);\n\t}\n}\nstd::vector<std::pair<AssetTypeValueField*, std::list<AssetViewModifyDialog::AssetDeserializeDesc>::iterator>> \nAssetViewModifyDialog::findAllSubtreeAssets(\n\tstd::list<AssetDeserializeDesc>::iterator itBaseAssetDesc,\n\tbool &hasUnappliedChanges,\n\tAssetTypeValueField *pBasePPtrField)\n{\n\tif (pBasePPtrField == nullptr && itBaseAssetDesc->pParent != nullptr)\n\t{\n\t\tbool foundSelf = false;\n\t\tfor (size_t k = 0; k < itBaseAssetDesc->pParent->children.size(); k++)\n\t\t{\n\t\t\tif (&*itBaseAssetDesc->pParent->children[k].second == &*itBaseAssetDesc)\n\t\t\t{\n\t\t\t\tpBasePPtrField = itBaseAssetDesc->pParent->children[k].first;\n\t\t\t\tfoundSelf = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tassert(foundSelf);\n\t}\n\t//Find all child assets of the asset.\n\thasUnappliedChanges = false;\n\tstd::vector<std::pair<AssetTypeValueField*, std::list<AssetDeserializeDesc>::iterator>> \n\t\trecursiveChildren(1, std::make_pair(pBasePPtrField, itBaseAssetDesc));\n\tstd::vector<size_t> idxStack(1, 0); //Initialize with {0}\n\tAssetDeserializeDesc *pCurDesc = &*itBaseAssetDesc;\n\tdo {\n\t\tassert(pCurDesc != nullptr);\n\t\tsize_t i = idxStack.back(); \n\t\tidxStack.pop_back();\n\t\tif (pCurDesc->hasChanged)\n\t\t\thasUnappliedChanges = true;\n\t\tif (i < pCurDesc->children.size())\n\t\t{\n\t\t\tassert(pCurDesc->children[i].second->pParent == pCurDesc);\n\t\t\tidxStack.push_back(i + 1);\n\t\t\tidxStack.push_back(0);\n\t\t\trecursiveChildren.push_back(pCurDesc->children[i]);\n\t\t\tpCurDesc = &*pCurDesc->children[i].second;\n\t\t}\n\t\telse\n\t\t\tpCurDesc = pCurDesc->pParent;\n\t} while (!idxStack.empty());\n\treturn recursiveChildren;\n}\nvoid AssetViewModifyDialog::closeAllSubtreeAssets(HWND hTree,\n\tstd::vector<std::pair<AssetTypeValueField*, std::list<AssetDeserializeDesc>::iterator>> subtreeAssets,\n\tAssetDeserializeDesc *pParentAsset)\n{\n\tassert(pParentAsset->pLoadTask == nullptr);\n\tfor (size_t i = 0; i < subtreeAssets.size(); i++)\n\t{\n\t\tassert(subtreeAssets[i].second->pParent != nullptr);\n\t\tif (subtreeAssets[i].second->pParent == pParentAsset)\n\t\t{\n\t\t\t//Delete the asset and its children from the tree list.\n\t\t\tSendMessage(hTree, MC_TLM_DELETEITEM, MC_TLDI_NONOTIFY, reinterpret_cast<LPARAM>(subtreeAssets[i].second->baseItem));\n\t\t\tassert(subtreeAssets[i].second->pLoadTask == nullptr);\n\t\t\tbool foundSelf = false;\n\t\t\tfor (size_t k = 0; k < subtreeAssets[i].second->pParent->children.size(); k++)\n\t\t\t{\n\t\t\t\tif (&*subtreeAssets[i].second->pParent->children[k].second == &*subtreeAssets[i].second)\n\t\t\t\t{\n\t\t\t\t\t//Delete this asset from its parent\'s child list.\n\t\t\t\t\tsubtreeAssets[i].second->pParent->children.erase(subtreeAssets[i].second->pParent->children.begin() + k);\n\t\t\t\t\tfoundSelf = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tassert(foundSelf);\n\t\t}\n\t}\n\t//Delete this asset from internal lists and maps. \n\tfor (size_t i = 0; i < subtreeAssets.size(); i++)\n\t{\n\t\tstd::list<AssetDeserializeDesc>::iterator itCurAsset = subtreeAssets[i].second;\n\t\tauto curAssetByBaseItemIt = this->loadedAssetsByBaseItem.find(itCurAsset->baseItem);\n\t\tif (curAssetByBaseItemIt != this->loadedAssetsByBaseItem.end())\n\t\t{\n\t\t\tassert(itCurAsset->pLoadTask == nullptr);\n\t\t\tassert(&*curAssetByBaseItemIt->second == &*itCurAsset);\n\t\t\tthis->loadedAssetsByBaseItem.erase(curAssetByBaseItemIt);\n\t\t}\n\t\telse\n\t\t\tassert(itCurAsset->pLoadTask != nullptr);\n\n\t\tauto curAssetByPPtrIt = this->loadedAssetsByPPtr.find(\n\t\t\tAssetAbsPPtr(itCurAsset->asset.pFile->getFileID(), \n\t\t\t\titCurAsset->asset.pathID));\n\t\tassert(curAssetByPPtrIt != this->loadedAssetsByPPtr.end());\n\t\tif (curAssetByPPtrIt != this->loadedAssetsByPPtr.end())\n\t\t{\n\t\t\tassert(&*curAssetByPPtrIt->second == &*itCurAsset);\n\t\t\tthis->loadedAssetsByPPtr.erase(curAssetByPPtrIt);\n\t\t}\n\n\t\tif (subtreeAssets[i].first != nullptr)\n\t\t{\n\t\t\tauto curAssetByPPtrFieldIt = this->loadedAssetsByPPtrField.find(subtreeAssets[i].first);\n\t\t\tassert(curAssetByPPtrFieldIt != this->loadedAssetsByPPtrField.end());\n\t\t\tif (curAssetByPPtrFieldIt != this->loadedAssetsByPPtrField.end())\n\t\t\t{\n\t\t\t\tassert(&*curAssetByPPtrFieldIt->second == &*itCurAsset);\n\t\t\t\tthis->loadedAssetsByPPtrField.erase(curAssetByPPtrFieldIt);\n\t\t\t}\n\t\t}\n\n\t\tif (itCurAsset->pLoadTask != nullptr)\n\t\t{\n\t\t\t//The asset will be deleted once the task is finished.\n\t\t\titCurAsset->pendingClose = true;\n\t\t\titCurAsset->pParent = nullptr;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t//Delete the asset.\n\t\t\tthis->loadedAssets.erase(itCurAsset);\n\t\t}\n\t}\n}\nvoid AssetViewModifyDialog::doCloseEditPopup()\n{\n\tbool updateValueText = false;\n\tbool addTreeListChildren = false;\n\tsize_t firstChildToAdd = 0;\n\tunion {\n\t\tuint64_t oldValue64u;\n\t\tint64_t oldValue64s;\n\t};\n\tbool hasOldIntValue = false;\n\tHWND hTree = GetDlgItem(this->hDialog, IDC_TYPETREE);\n\tif (this->hCurEditPopupUpDown != NULL)\n\t{\n\t\tBOOL gotValue = FALSE;\n\t\tint value = static_cast<int>(SendMessage(this->hCurEditPopupUpDown, UDM_GETPOS32, 0, reinterpret_cast<LPARAM>(&gotValue)));\n\t\tif (this->pEditValueField != nullptr && this->pEditValueField->GetValue() != nullptr)\n\t\t{\n\t\t\tswitch (this->pEditValueField->GetValue()->GetType())\n\t\t\t{\n\t\t\tcase ValueType_Int8:\n\t\t\tcase ValueType_UInt8:\n\t\t\tcase ValueType_Int16:\n\t\t\tcase ValueType_UInt16:\n\t\t\t\tassert(this->iEditPopupSubItem == 1);\n\t\t\t\tif (this->iEditPopupSubItem != 1)\n\t\t\t\t\tbreak;\n\t\t\t\toldValue64s = this->pEditValueField->GetValue()->AsInt();\n\t\t\t\thasOldIntValue = true;\n\t\t\t\tif (value != this->pEditValueField->GetValue()->AsInt())\n\t\t\t\t{\n\t\t\t\t\tthis->pEditValueField->GetValue()->Set(&value);\n\t\t\t\t\tupdateValueText = true;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase ValueType_Array:\n\t\t\t\tif (this->iEditPopupSubItem == 0 && value >= 0 && static_cast<DWORD>(value) < this->pEditValueField->GetValue()->AsArray()->size)\n\t\t\t\t{\n\t\t\t\t\t//Move array element.\n\t\t\t\t\tthis->moveArrayItem(hTree, this->pEditAssetDesc, this->pEditValueField, this->hEditPopupItem, static_cast<uint32_t>(value));\n\t\t\t\t}\n\t\t\t\telse if (this->iEditPopupSubItem == 1 && value > 0 && static_cast<DWORD>(value) > this->pEditValueField->GetValue()->AsArray()->size)\n\t\t\t\t{\n\t\t\t\t\t//Create one or several array elements.\n\t\t\t\t\tDWORD oldSize = this->pEditValueField->GetValue()->AsArray()->size;\n\t\t\t\t\tif (this->pEditValueField->GetTemplateField() == nullptr\n\t\t\t\t\t\t|| !this->pEditValueField->GetTemplateField()->isArray\n\t\t\t\t\t\t|| this->pEditValueField->GetTemplateField()->children.size() != 2)\n\t\t\t\t\t{\n\t\t\t\t\t\tMessageBox(this->hDialog, TEXT("Invalid array type information."), TEXT("Asset Bundle Extractor"), MB_ICONERROR);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tAssetTypeTemplateField *pArrayDataTemplate = &this->pEditValueField->GetTemplateField()->children[1];\n\t\t\t\t\tAssetTypeValueField **oldChildrenList = this->pEditValueField->GetChildrenList();\n\t\t\t\t\tstd::vector<std::unique_ptr<uint8_t[]>> newAllocatedMemory;\n\t\t\t\t\t//Allocate the new, larger child list.\n\t\t\t\t\tbool failed = false;\n\t\t\t\t\tuint8_t *newChildrenListMemory = new uint8_t[sizeof(AssetTypeValueField*) * value];\n\t\t\t\t\tAssetTypeValueField **newChildrenList = reinterpret_cast<AssetTypeValueField**>(newChildrenListMemory);\n\t\t\t\t\tnewAllocatedMemory.push_back(std::unique_ptr<uint8_t[]>(newChildrenListMemory));\n\t\t\t\t\t//Copy the old info to the new list.\n\t\t\t\t\tmemcpy(newChildrenList, oldChildrenList, sizeof(AssetTypeValueField*) * oldSize);\n\t\t\t\t\tfor (DWORD i = oldSize; i < static_cast<DWORD>(value); i++)\n\t\t\t\t\t{\n\t\t\t\t\t\t//Generate new empty array elements.\n\t\t\t\t\t\tnewChildrenList[i] = CreateEmptyValueFieldFromTemplate(pArrayDataTemplate, newAllocatedMemory);\n\t\t\t\t\t\tif (newChildrenList[i] == nullptr)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfailed = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (failed)\n\t\t\t\t\t{\n\t\t\t\t\t\tMessageBox(this->hDialog, TEXT("Failed to create new array elements."), TEXT("Asset Bundle Extractor"), MB_ICONERROR);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t//Update the child list.\n\t\t\t\t\tthis->pEditValueField->SetChildrenList(newChildrenList, static_cast<DWORD>(value));\n\t\t\t\t\tupdateValueText = true;\n\t\t\t\t\taddTreeListChildren = true;\n\t\t\t\t\tfirstChildToAdd = this->pEditValueField->GetValue()->AsArray()->size;\n\t\t\t\t\tthis->pEditValueField->GetValue()->AsArray()->size = static_cast<DWORD>(value);\n\t\t\t\t\t//Free the old child list memory (if possible).\n\t\t\t\t\tauto oldListIt = this->pEditAssetDesc->instanceModificationBuffers.find(reinterpret_cast<uint8_t*>(oldChildrenList));\n\t\t\t\t\tif (oldListIt != this->pEditAssetDesc->instanceModificationBuffers.end())\n\t\t\t\t\t{\n\t\t\t\t\t\tdelete[] *oldListIt;\n\t\t\t\t\t\tthis->pEditAssetDesc->instanceModificationBuffers.erase(oldListIt);\n\t\t\t\t\t}\n\t\t\t\t\t//Add all new allocated memory to the set.\n\t\t\t\t\tfor (std::unique_ptr<uint8_t[]>& pMem : newAllocatedMemory)\n\t\t\t\t\t\tthis->pEditAssetDesc->instanceModificationBuffers.insert(pMem.release());\n\t\t\t\t\t//Insert the new array elements to the tree list control.\n\t\t\t\t\taddTreeListChildren = true;\n\t\t\t\t\tfirstChildToAdd = oldSize;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\telse if (this->hCurEditPopup != NULL)\n\t{\n\t\t//Retrieve the value from the edit.\n\t\tint textLen = Edit_GetTextLength(this->hCurEditPopup);\n\t\tif (textLen >= 0 && textLen < INT_MAX)\n\t\t{\n\t\t\tstd::unique_ptr<TCHAR[]> textBuf(new TCHAR[textLen + 1]);\n\t\t\tint nCharacters = Edit_GetText(this->hCurEditPopup, textBuf.get(), textLen + 1);\n\t\t\tif (nCharacters <= textLen)\n\t\t\t\ttextBuf[nCharacters] = 0;\n\t\t\telse\n\t\t\t\ttextBuf[textLen] = 0;\n\t\t\tTCHAR *endPtr = nullptr;\n\t\t\tswitch (this->pEditValueField->GetValue()->GetType())\n\t\t\t{\n\t\t\tcase ValueType_Int32:\n\t\t\tcase ValueType_Int64:\n\t\t\t\t{\n\t\t\t\t\tassert(this->iEditPopupSubItem == 1);\n\t\t\t\t\tif (this->iEditPopupSubItem != 1)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tint64_t value = _tcstoi64(textBuf.get(), &endPtr, 0);\n\t\t\t\t\tif (endPtr == textBuf.get() || endPtr == nullptr)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\toldValue64s = this->pEditValueField->GetValue()->AsInt64();\n\t\t\t\t\thasOldIntValue = true;\n\t\t\t\t\tif (value != this->pEditValueField->GetValue()->AsInt64())\n\t\t\t\t\t{\n\t\t\t\t\t\tthis->pEditValueField->GetValue()->Set(&value);\n\t\t\t\t\t\tupdateValueText = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase ValueType_UInt32:\n\t\t\tcase ValueType_UInt64:\n\t\t\t\t{\n\t\t\t\t\tassert(this->iEditPopupSubItem == 1);\n\t\t\t\t\tif (this->iEditPopupSubItem != 1)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tuint64_t value = _tcstoui64(textBuf.get(), &endPtr, 0);\n\t\t\t\t\tif (endPtr == textBuf.get() || endPtr == nullptr)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\toldValue64u = this->pEditValueField->GetValue()->AsUInt64();\n\t\t\t\t\thasOldIntValue = true;\n\t\t\t\t\tif (value != this->pEditValueField->GetValue()->AsUInt64())\n\t\t\t\t\t{\n\t\t\t\t\t\tthis->pEditValueField->GetValue()->Set(&value);\n\t\t\t\t\t\tupdateValueText = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase ValueType_Float:\n\t\t\t\t{\n\t\t\t\t\tassert(this->iEditPopupSubItem == 1);\n\t\t\t\t\tif (this->iEditPopupSubItem != 1)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdouble valueD = _tcstod(textBuf.get(), &endPtr);\n\t\t\t\t\tif (endPtr == textBuf.get() || endPtr == nullptr)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tfloat value = static_cast<float>(valueD);\n\t\t\t\t\tif (value != this->pEditValueField->GetValue()->AsFloat())\n\t\t\t\t\t{\n\t\t\t\t\t\tthis->pEditValueField->GetValue()->Set(&value);\n\t\t\t\t\t\tupdateValueText = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase ValueType_Double:\n\t\t\t\t{\n\t\t\t\t\tassert(this->iEditPopupSubItem == 1);\n\t\t\t\t\tif (this->iEditPopupSubItem != 1)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdouble value = _tcstod(textBuf.get(), &endPtr);\n\t\t\t\t\tif (endPtr == textBuf.get() || endPtr == nullptr)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tif (value != this->pEditValueField->GetValue()->AsDouble())\n\t\t\t\t\t{\n\t\t\t\t\t\tthis->pEditValueField->GetValue()->Set(&value);\n\t\t\t\t\t\tupdateValueText = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase ValueType_String:\n\t\t\t\t{\n\t\t\t\t\tassert(this->iEditPopupSubItem == 1);\n\t\t\t\t\tif (this->iEditPopupSubItem != 1)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tsize_t newLen = 0;\n\t\t\t\t\tauto pNewUTF8 = unique_TCHARToMultiByte(textBuf.get(), newLen);\n\t\t\t\t\tchar *oldString = this->pEditValueField->GetValue()->AsString();\n\t\t\t\t\tif ((oldString == nullptr && newLen == 0)\n\t\t\t\t\t\t|| !strcmp(oldString, pNewUTF8.get()))\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t//Update the string value in the field, and manage the memory allocations.\n\t\t\t\t\tsetStringValue(this->pEditValueField, this->pEditAssetDesc, pNewUTF8.get(), newLen);\n\t\t\t\t\tupdateValueText = true;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif (updateValueText\n\t\t\t&& (this->pEditValueField->GetName() == "m_FileID"\n\t\t\t\t|| this->pEditValueField->GetName() == "m_PathID")\n\t\t\t&& hasOldIntValue\n\t\t)\n\t{\n\t\t//Find the [view asset] tree item, delete its subtree (if it exists) and the corresponding one or several AssetDeserializeDesc*\n\t\tHWND hTree = GetDlgItem(this->hDialog, IDC_TYPETREE);\n\t\tMC_HTREELISTITEM hPPtrBaseItem = reinterpret_cast<MC_HTREELISTITEM>(\n\t\t\tSendMessage(hTree, MC_TLM_GETNEXTITEM, MC_TLGN_PARENT, reinterpret_cast<LPARAM>(this->hEditPopupItem)));\n\t\tAssetTypeValueField *pPPtrBaseField = nullptr;\n\t\tif (hPPtrBaseItem != NULL)\n\t\t{\n\t\t\tMC_TLITEM item;\n\t\t\titem.fMask = MC_TLIF_PARAM;\n\t\t\titem.lParam = 0;\n\t\t\tif (SendMessage(hTree, MC_TLM_GETITEM, reinterpret_cast<WPARAM>(hPPtrBaseItem), reinterpret_cast<LPARAM>(&item)))\n\t\t\t{\n\t\t\t\tpPPtrBaseField = reinterpret_cast<AssetTypeValueField*>(item.lParam);\n\t\t\t}\n\t\t}\n\t\tMC_HTREELISTITEM hCurItem = this->hEditPopupItem;\n\t\tMC_HTREELISTITEM hChildItem = NULL;\n\t\tauto assetIt = this->loadedAssetsByBaseItem.end();\n\t\twhile ((hCurItem = reinterpret_cast<MC_HTREELISTITEM>(SendMessage(hTree, MC_TLM_GETNEXTITEM, MC_TLGN_NEXT, reinterpret_cast<LPARAM>(hCurItem))))\n\t\t\t\t!= NULL)\n\t\t{\n\t\t\thChildItem = reinterpret_cast<MC_HTREELISTITEM>(SendMessage(hTree, MC_TLM_GETNEXTITEM, MC_TLGN_CHILD, reinterpret_cast<LPARAM>(hCurItem)));\n\t\t\tif (hChildItem != NULL)\n\t\t\t{\n\t\t\t\tassetIt = this->loadedAssetsByBaseItem.find(hChildItem);\n\t\t\t\tif (assetIt != this->loadedAssetsByBaseItem.end())\n\t\t\t\t{\n\t\t\t\t\tassert(assetIt->second->pParent == this->pEditAssetDesc);\n\t\t\t\t\tif (assetIt->second->pParent == this->pEditAssetDesc)\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (assetIt != this->loadedAssetsByBaseItem.end() && pPPtrBaseField != nullptr)\n\t\t{\n\t\t\tbool hasUnappliedChanges;\n\t\t\tauto recursiveChildren = this->findAllSubtreeAssets(assetIt->second, hasUnappliedChanges, pPPtrBaseField);\n\t\t\tbool cancelledDelete = false;\n\t\t\tif (hasUnappliedChanges)\n\t\t\t{\n\t\t\t\tswitch (MessageBox(this->hDialog, TEXT("There are unsaved changes in assets below the changed PPtr.\\n")\n\t\t\t\t\tTEXT("Do you want save these changes before proceeding?"), TEXT("Asset Bundle Extractor"), MB_ICONWARNING | MB_YESNOCANCEL))\n\t\t\t\t{\n\t\t\t\tcase IDYES:\n\t\t\t\t\tassert(false); //TODO: Save changes\n\t\t\t\tcase IDNO:\n\t\t\t\t\tbreak;\n\t\t\t\tcase IDCANCEL:\n\t\t\t\t\tthis->pEditValueField->GetValue()->Set(&oldValue64u);\n\t\t\t\t\tupdateValueText = false;\n\t\t\t\t\tcancelledDelete = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!cancelledDelete)\n\t\t\t{\n\t\t\t\tthis->closeAllSubtreeAssets(hTree, recursiveChildren, this->pEditAssetDesc);\n\n\t\t\t\tSendMessage(hTree, MC_TLM_EXPAND, MC_TLE_COLLAPSE, reinterpret_cast<LPARAM>(hCurItem));\n\t\t\t\tMC_TLITEM item;\n\t\t\t\titem.fMask = MC_TLIF_CHILDREN;\n\t\t\t\titem.cChildren = 1;\n\t\t\t\tSendMessage(hTree, MC_TLM_SETITEM, reinterpret_cast<WPARAM>(hCurItem), reinterpret_cast<LPARAM>(&item));\n\t\t\t}\n\t\t}\n\t}\n\tif (updateValueText)\n\t{\n\t\tsetTreeValueText(hTree, this->hEditPopupItem, this->pEditValueField);\n\t\tpEditAssetDesc->hasChanged = true;\n\t\tif (addTreeListChildren)\n\t\t{\n\t\t\t//Add new children of pEditValueField to the tree list, starting with firstChildToAdd.\n\t\t\tthis->addTreeItems(this->pEditAssetDesc, this->hEditPopupItem, reinterpret_cast<LPARAM>(this->pEditValueField),\n\t\t\t\tthis->pEditValueField->GetChildrenList(), this->pEditValueField->GetChildrenCount(), false, firstChildToAdd);\n\t\t\t//Keep in mind that the user may have cancelled adding tree elements before (and with the new items).\n\t\t\t// => The tree list may have gaps.\n\t\t\t//    Additional functionality, such as moving array entries, must be able to handle that.\n\t\t}\n\t}\n\tif (this->hCurPopupMenu != NULL)\n\t{\n\t\tDestroyMenu(this->hCurPopupMenu);\n\t\tthis->hCurPopupMenu = NULL;\n\t}\n\tif (this->hCurEditPopupUpDown != NULL)\n\t{\n\t\tDestroyWindow(this->hCurEditPopupUpDown);\n\t\tthis->hCurEditPopupUpDown = NULL;\n\t}\n\tif (this->hCurEditPopup != NULL)\n\t{\n\t\tDestroyWindow(this->hCurEditPopup);\n\t\tthis->hCurEditPopup = NULL;\n\t}\n\tthis->pEditAssetDesc = nullptr;\n\tthis->pEditValueField = nullptr;\n\tthis->hEditPopupItem = NULL;\n}\nbool AssetViewModifyDialog::setByteArrayValue(FieldInfo fieldInfo, std::unique_ptr<uint8_t[]> data, size_t data_len)\n{\n\tif (fieldInfo.pValueField == nullptr\n\t\t|| fieldInfo.pValueField->GetValue() == nullptr\n\t\t|| data_len > std::numeric_limits<uint32_t>::max())\n\t\treturn false;\n\tauto mapIt = loadedAssetsByPPtr.find(fieldInfo.assetIDs);\n\tif (mapIt == loadedAssetsByPPtr.end())\n\t\treturn false;\n\tAssetDeserializeDesc* pAssetDesc = &(*mapIt->second);\n\n\tAssetTypeByteArray* pOldByteArray = fieldInfo.pValueField->GetValue()->AsByteArray();\n\tuint8_t* pOldByteArrayData = pOldByteArray ? pOldByteArray->data : nullptr;\n\tAssetTypeByteArray input;\n\tinput.data = data.release();\n\tinput.size = (uint32_t)data_len;\n\t(*fieldInfo.pValueField->GetValue()) = AssetTypeValue(ValueType_ByteArray, &input);\n\tfieldInfo.pValueField->SetChildrenList(nullptr, 0);\n\n\tpAssetDesc->hasChanged = true;\n\n\tif (pOldByteArrayData != nullptr)\n\t{\n\t\t//Free the old string memory, if possible.\n\t\tauto oldDataMemIt = pAssetDesc->instanceModificationBuffers.find(pOldByteArrayData);\n\t\tif (oldDataMemIt != pAssetDesc->instanceModificationBuffers.end())\n\t\t{\n\t\t\tdelete[] *oldDataMemIt;\n\t\t\tpAssetDesc->instanceModificationBuffers.erase(oldDataMemIt);\n\t\t}\n\t}\n\t//Add the new memory to the set.\n\tpAssetDesc->instanceModificationBuffers.insert(input.data);\n\n\tHWND hTree = getTreeHandle();\n\tif (hTree == NULL)\n\t\treturn true; //There is no need to update the tree if it doesn\'t exist.\n\n\t//Delete all child items (ByteArrays are shown without any child items in the tree list).\n\tMC_HTREELISTITEM childItem = reinterpret_cast<MC_HTREELISTITEM>(\n\t\t\tSendMessage(hTree, MC_TLM_GETNEXTITEM, MC_TLGN_CHILD, reinterpret_cast<LPARAM>(fieldInfo.treeListHandle)));\n\twhile (childItem != NULL)\n\t{\n\t\tMC_HTREELISTITEM nextChildItem = reinterpret_cast<MC_HTREELISTITEM>(\n\t\t\tSendMessage(hTree, MC_TLM_GETNEXTITEM, MC_TLGN_NEXT, reinterpret_cast<LPARAM>(childItem)));\n\t\tSendMessage(hTree, MC_TLM_DELETEITEM, MC_TLDI_NONOTIFY, reinterpret_cast<LPARAM>(childItem));\n\t\tchildItem = nextChildItem;\n\t}\n\t//Mark the new ByteArray item as having no children.\n\tMC_TLITEM tlItem = {};\n\ttlItem.fMask = MC_TLIF_CHILDREN;\n\ttlItem.cChildren = 0;\n\tSendMessage(hTree, MC_TLM_SETITEM, reinterpret_cast<WPARAM>(fieldInfo.treeListHandle), reinterpret_cast<LPARAM>(&tlItem));\n\n\treturn true;\n}\nbool AssetViewModifyDialog::setStringValue(AssetTypeValueField* pField, AssetDeserializeDesc* pAssetDesc, const char* str, size_t str_len)\n{\n\tif (pField->GetValue() == nullptr || pField->GetValue()->GetType() != ValueType_String)\n\t\treturn false;\n\tchar* oldString = pField->GetValue()->AsString();\n\tuint8_t* newStringValue = new uint8_t[(str_len + 1) * sizeof(str[0])];\n\tmemcpy(newStringValue, str, (str_len + 1) * sizeof(str[0]));\n\tpField->GetValue()->Set((char*)newStringValue, ValueType_String);\n\tpAssetDesc->hasChanged = true;\n\n\tif (oldString != nullptr)\n\t{\n\t\t//Free the old string memory, if possible.\n\t\tauto oldStringMemIt = pAssetDesc->instanceModificationBuffers.find(reinterpret_cast<uint8_t*>(oldString));\n\t\tif (oldStringMemIt != pAssetDesc->instanceModificationBuffers.end())\n\t\t{\n\t\t\tdelete[] *oldStringMemIt;\n\t\t\tpAssetDesc->instanceModificationBuffers.erase(oldStringMemIt);\n\t\t}\n\t}\n\t//Add the new memory to the set.\n\tpAssetDesc->instanceModificationBuffers.insert(newStringValue);\n\treturn true;\n}\nbool AssetViewModifyDialog::setStringValue(AssetTypeValueField* pValueField, AssetAbsPPtr assetIDs, const char* str, size_t str_len)\n{\n\tauto mapIt = loadedAssetsByPPtr.find(assetIDs);\n\tif (mapIt == loadedAssetsByPPtr.end())\n\t\treturn false;\n\treturn setStringValue(pValueField, &(*mapIt->second), str, str_len);\n}\nAssetViewModifyDialog::FieldInfo AssetViewModifyDialog::getNextChildFieldInfo(FieldInfo parentFieldInfo, FieldInfo prevFieldInfo)\n{\n\tif (parentFieldInfo.pValueField == nullptr)\n\t\treturn FieldInfo(); //Make sure we don\'t accidentally follow a PPtr.\n\tif (prevFieldInfo.pValueField == nullptr && parentFieldInfo.pValueField->GetValue() != nullptr)\n\t{\n\t\tif (parentFieldInfo.pValueField->GetValue()->GetType() == ValueType_Array\n\t\t\t|| parentFieldInfo.pValueField->GetValue()->GetType() == ValueType_ByteArray)\n\t\t\treturn FieldInfo(); //Not supported (yet).\n\t}\n\tHWND hTree = getTreeHandle();\n\tMC_HTREELISTITEM childItem = NULL;\n\tif (prevFieldInfo.treeListHandle == NULL)\n\t{\n\t\tchildItem = reinterpret_cast<MC_HTREELISTITEM>(\n\t\t\tSendMessage(hTree, MC_TLM_GETNEXTITEM, MC_TLGN_CHILD, reinterpret_cast<LPARAM>(parentFieldInfo.treeListHandle)));\n\t}\n\telse\n\t{\n\t\tchildItem = reinterpret_cast<MC_HTREELISTITEM>(\n\t\t\tSendMessage(hTree, MC_TLM_GETNEXTITEM, MC_TLGN_NEXT, reinterpret_cast<LPARAM>(prevFieldInfo.treeListHandle)));\n\t}\n\tif (childItem == NULL) return FieldInfo();\n\tAssetTypeValueField* pChildValueField = nullptr;\n\tMC_TLITEM item;\n\titem.fMask = MC_TLIF_PARAM;\n\titem.lParam = 0;\n\tif (SendMessage(hTree, MC_TLM_GETITEM, reinterpret_cast<WPARAM>(childItem), reinterpret_cast<LPARAM>(&item)))\n\t{\n\t\tpChildValueField = reinterpret_cast<AssetTypeValueField*>(item.lParam);\n\t}\n\treturn FieldInfo(pChildValueField, parentFieldInfo.assetIDs, childItem);\n}\nvoid AssetViewModifyDialog::updateValueFieldText(FieldInfo fieldInfo, bool markAsChanged)\n{\n\tif (markAsChanged)\n\t{\n\t\tauto mapIt = loadedAssetsByPPtr.find(fieldInfo.assetIDs);\n\t\tif (mapIt != loadedAssetsByPPtr.end())\n\t\t\tmapIt->second->hasChanged = true;\n\t}\n\tif (fieldInfo.treeListHandle == NULL)\n\t\treturn;\n\tHWND hTree = GetDlgItem(this->hDialog, IDC_TYPETREE);\n\tif (fieldInfo.pValueField != nullptr)\n\t\tsetTreeValueText(hTree, fieldInfo.treeListHandle, fieldInfo.pValueField);\n\n\tFieldInfo curChildField = FieldInfo();\n\twhile ((curChildField = getNextChildFieldInfo(fieldInfo, curChildField)).treeListHandle != NULL)\n\t{\n\t\tupdateValueFieldText(curChildField);\n\t}\n}\nvoid AssetViewModifyDialog::openEditPopup(HWND hTree, MC_HTREELISTITEM hItem, AssetTypeValueField *pValueField, AssetDeserializeDesc *pAssetDesc,\n\tint iSubItem)\n{\t\n\tRECT targetRect = {};\n\ttargetRect.top = iSubItem;\n\ttargetRect.left = MC_TLIR_BOUNDS;\n\tif (iSubItem == 0)\n\t{\n\t\ttargetRect.left = MC_TLIR_LABEL;\n\t\tif (!SendMessage(hTree, MC_TLM_GETITEMRECT, \n\t\t\treinterpret_cast<WPARAM>(hItem), reinterpret_cast<LPARAM>(&targetRect)))\n\t\t\treturn;\n\t\tRECT subRect = {};\n\t\tsubRect.top = 1;\n\t\tsubRect.left = MC_TLIR_BOUNDS;\n\t\tif (!SendMessage(hTree, MC_TLM_GETSUBITEMRECT, \n\t\t\treinterpret_cast<WPARAM>(hItem), reinterpret_cast<LPARAM>(&subRect)))\n\t\t\treturn;\n\t\ttargetRect.right = subRect.left;\n\t}\n\telse\n\t{\n\t\tif (!SendMessage(hTree, MC_TLM_GETSUBITEMRECT, \n\t\t\t\treinterpret_cast<WPARAM>(hItem), reinterpret_cast<LPARAM>(&targetRect)))\n\t\t\treturn;\n\t}\n\n\tint limitLow = 0;\n\tint limitHigh = 65535;\n\tthis->pEditAssetDesc = pAssetDesc;\n\tthis->pEditValueField = pValueField;\n\tthis->hEditPopupItem = hItem;\n\tthis->iEditPopupSubItem = iSubItem;\n\tswitch (pValueField->GetValue()->GetType())\n\t{\n\tcase ValueType_Bool:\n\t\t{\n\t\t\tassert(iSubItem == 1);\n\t\t\tif (iSubItem != 1)\n\t\t\t\tbreak;\n\t\t\t//Swap immediately.\n\t\t\tbool newValue = !pValueField->GetValue()->AsBool();\n\t\t\tpValueField->GetValue()->Set(&newValue);\n\t\t\tpAssetDesc->hasChanged = true;\n\n\t\t\tMC_TLSUBITEM subItem;\n\t\t\tsubItem.fMask = MC_TLSIF_TEXT;\n\t\t\tsubItem.iSubItem = 1;\n\t\t\tsubItem.cchTextMax = 0;\n\t\t\tsubItem.pszText = const_cast<TCHAR*>(newValue ? TEXT("true") : TEXT("false"));\n\t\t\tSendMessage(hTree, MC_TLM_SETSUBITEM, reinterpret_cast<WPARAM>(hItem), reinterpret_cast<LPARAM>(&subItem));\n\t\t}\n\t\tbreak;\n\tcase ValueType_Int8: limitHigh >>= 1; limitLow -= 127;   //For Int8:  limitHigh = 65535 >> 9 = 127;   limitLow = -127 + 32768 - 32768 = -127\n\tcase ValueType_UInt8: limitHigh >>= 7; limitLow += 32768;//For UInt8: limitHigh = 65535 >> 8 = 255;   limitLow = 32768 - 32768 = 0\n\tcase ValueType_Int16: limitHigh >>= 1; limitLow -= 32768;//For Int16: limitHigh = 65535 >> 1 = 32767; limitLow = -32768\n\tcase ValueType_UInt16:\n\t\t{\n\t\t\tassert(iSubItem == 1);\n\t\t\tif (iSubItem != 1)\n\t\t\t\tbreak;\n\t\t\tthis->hCurEditPopup = CreateWindowEx(WS_EX_CLIENTEDGE,\n\t\t\t\tWC_EDIT, NULL, ES_AUTOHSCROLL | WS_CHILD | WS_VISIBLE | ES_NUMBER | ES_LEFT, \n\t\t\t\ttargetRect.left, targetRect.top, targetRect.right - targetRect.left, targetRect.bottom - targetRect.top,\n\t\t\t\thTree, GetMenu(this->hDialog), this->appContext.getMainWindow().getHInstance(), NULL);\n\t\t\tthis->hCurEditPopupUpDown = CreateWindowEx(WS_EX_LTRREADING,\n\t\t\t\tUPDOWN_CLASS, NULL, WS_CHILD | WS_VISIBLE | UDS_AUTOBUDDY | UDS_SETBUDDYINT | UDS_ALIGNRIGHT | UDS_ARROWKEYS | UDS_HOTTRACK, \n\t\t\t\t0, 0, 0, 0, // Auto size the Up-Down Control\n\t\t\t\thTree, GetMenu(this->hDialog), this->appContext.getMainWindow().getHInstance(), NULL);\n\t\t\tSendMessage(this->hCurEditPopupUpDown, UDM_SETRANGE32, static_cast<INT_PTR>(limitLow), static_cast<INT_PTR>(limitHigh));\n\t\t\tSendMessage(this->hCurEditPopupUpDown, UDM_SETPOS32, 0, static_cast<INT_PTR>(pValueField->GetValue()->AsInt()));\n\t\t}\n\t\tbreak;\n\tcase ValueType_Int32:\n\tcase ValueType_UInt32:\n\tcase ValueType_Int64:\n\tcase ValueType_UInt64:\n\t\t{\n\t\t\tassert(iSubItem == 1);\n\t\t\tif (iSubItem != 1)\n\t\t\t\tbreak;\n\t\t\tthis->hCurEditPopup = CreateWindowEx(WS_EX_CLIENTEDGE,\n\t\t\t\tWC_EDIT, NULL, ES_AUTOHSCROLL | WS_CHILD | WS_VISIBLE | ES_NUMBER | ES_LEFT, \n\t\t\t\ttargetRect.left, targetRect.top, targetRect.right - targetRect.left, targetRect.bottom - targetRect.top,\n\t\t\t\thTree, GetMenu(this->hDialog), this->appContext.getMainWindow().getHInstance(), NULL);\n\t\t\tTCHAR valueText[32];\n\t\t\tif (pValueField->GetValue()->GetType() == ValueType_Int32\n\t\t\t\t|| pValueField->GetValue()->GetType() == ValueType_Int64)\n\t\t\t\t_stprintf_s(valueText, TEXT("%lld"), pValueField->GetValue()->AsInt64());\n\t\t\telse\n\t\t\t\t_stprintf_s(valueText, TEXT("%llu"), pValueField->GetValue()->AsUInt64());\n\t\t\tEdit_SetText(this->hCurEditPopup, valueText);\n\t\t}\n\t\tbreak;\n\tcase ValueType_Float:\n\tcase ValueType_Double:\n\t\t{\n\t\t\tassert(iSubItem == 1);\n\t\t\tif (iSubItem != 1)\n\t\t\t\tbreak;\n\t\t\tthis->hCurEditPopup = CreateWindowEx(WS_EX_CLIENTEDGE,\n\t\t\t\tWC_EDIT, NULL, ES_AUTOHSCROLL | WS_CHILD | WS_VISIBLE | ES_LEFT, \n\t\t\t\ttargetRect.left, targetRect.top, targetRect.right - targetRect.left, targetRect.bottom - targetRect.top,\n\t\t\t\thTree, GetMenu(this->hDialog), this->appContext.getMainWindow().getHInstance(), NULL);\n\t\t\tTCHAR valueText[64];\n\t\t\t_stprintf_s(valueText, TEXT("%f"), pValueField->GetValue()->AsDouble());\n\t\t\tEdit_SetText(this->hCurEditPopup, valueText);\n\t\t}\n\t\tbreak;\n\tcase ValueType_String:\n\t\tif (pValueField->GetValue()->AsString())\n\t\t{\n\t\t\tassert(iSubItem == 1);\n\t\t\tif (iSubItem != 1)\n\t\t\t\tbreak;\n\t\t\tthis->hCurEditPopup = CreateWindowEx(WS_EX_CLIENTEDGE,\n\t\t\t\tWC_EDIT, NULL, ES_AUTOHSCROLL | WS_CHILD | WS_VISIBLE | ES_LEFT, \n\t\t\t\ttargetRect.left, targetRect.top, targetRect.right - targetRect.left, targetRect.bottom - targetRect.top,\n\t\t\t\thTree, GetMenu(this->hDialog), this->appContext.getMainWindow().getHInstance(), NULL);\n\t\t\tauto pText = unique_MultiByteToTCHAR(pValueField->GetValue()->AsString());\n\t\t\tEdit_SetText(this->hCurEditPopup, pText.get());\n\t\t}\n\t\tbreak;\n\tcase ValueType_Array:\n\t\t{\n\t\t\tint32_t curVal = -1;\n\t\t\tint32_t rangeMin = -1;\n\t\t\tint32_t rangeMax = -1;\n\t\t\tif (pValueField->GetValue()->AsArray()->size >= static_cast<DWORD>(INT_MAX))\n\t\t\t\tbreak;\n\t\t\tif (iSubItem == 1)  //Value\n\t\t\t{\n\t\t\t\tcurVal = pValueField->GetValue()->AsArray()->size;\n\t\t\t\trangeMin = pValueField->GetValue()->AsArray()->size;\n\t\t\t\trangeMax = INT_MAX;\n\t\t\t}\n\t\t\telse if (iSubItem == 0) //hItem is an array item, while pValueField is the array base field.\n\t\t\t{\n\t\t\t\tassert(pValueField->GetValue()->AsArray()->size > 0);\n\t\t\t\tif (pValueField->GetValue()->AsArray()->size <= 1)\n\t\t\t\t\tbreak;\n\t\t\t\trangeMin = 0;\n\t\t\t\trangeMax = pValueField->GetValue()->AsArray()->size - 1;\n\t\t\t\tauto arrayMappingIt = pAssetDesc->arrayMappingsByArray.find(pValueField);\n\t\t\t\tif (arrayMappingIt == pAssetDesc->arrayMappingsByArray.end())\n\t\t\t\t\tbreak;\n\t\t\t\tauto indexMapIt = arrayMappingIt->second.itemToIndexMap.find(hItem);\n\t\t\t\tif (indexMapIt == arrayMappingIt->second.itemToIndexMap.end())\n\t\t\t\t\tbreak;\n\t\t\t\tcurVal = indexMapIt->second;\n\t\t\t}\n\t\t\telse\n\t\t\t\tbreak;\n\t\t\tthis->hCurEditPopup = CreateWindowEx(WS_EX_CLIENTEDGE,\n\t\t\t\tWC_EDIT, NULL, ES_AUTOHSCROLL | WS_CHILD | WS_VISIBLE | ES_NUMBER | ES_LEFT, \n\t\t\t\ttargetRect.left, targetRect.top, targetRect.right - targetRect.left, targetRect.bottom - targetRect.top,\n\t\t\t\thTree, GetMenu(this->hDialog), this->appContext.getMainWindow().getHInstance(), NULL);\n\t\t\tthis->hCurEditPopupUpDown = CreateWindowEx(WS_EX_LTRREADING,\n\t\t\t\tUPDOWN_CLASS, NULL, WS_CHILD | WS_VISIBLE | UDS_AUTOBUDDY | UDS_SETBUDDYINT | UDS_ALIGNRIGHT | UDS_ARROWKEYS | UDS_HOTTRACK, \n\t\t\t\t0, 0, 0, 0, // Auto size the Up-Down Control\n\t\t\t\thTree, GetMenu(this->hDialog), this->appContext.getMainWindow().getHInstance(), NULL);\n\t\t\tSendMessage(this->hCurEditPopupUpDown, UDM_SETRANGE32, rangeMin, rangeMax);\n\t\t\tSendMessage(this->hCurEditPopupUpDown, UDM_SETPOS32, 0, curVal);\n\t\t}\n\t\tbreak;\n\tcase ValueType_ByteArray:\n\t\t//Ignore (for now)\n\t\tbreak;\n\t}\n\tif (this->hCurEditPopup == NULL)\n\t\treturn;\n\tSetWindowSubclass(this->hCurEditPopup, EditPopupProc, 0, reinterpret_cast<DWORD_PTR>(this));\n\tSendMessage(this->hCurEditPopup, WM_SETFONT, (WPARAM)(HFONT)SendMessage(hTree, WM_GETFONT, 0, 0), FALSE);\n\tSetFocus(this->hCurEditPopup);\n}\n\nstd::vector<AssetTypeValueField*> AssetViewModifyDialog::findAllPPtrs(AssetTypeValueField *pBaseField, AssetIdentifier &asset)\n{\n\tstd::vector<AssetTypeValueField*> ret;\n\tif (pBaseField->IsDummy() ||\n\t\tasset.pFile == nullptr)\n\t\treturn ret;\n\t//Somewhat complex PPtr search algorithm.\n\t//The simplest way would be to (recursively) iterate through all AssetTypeValueFields.\n\t//To make sure the overhead does not explode if the asset has huge, unrelated arrays,\n\t// the corresponding type template is first searched\n\t// and \'search instructions\' are generated for the path to each PPtr.\n\t//Finally, the \'interpreter\' walks through these instructions,\n\t// looping if an Array is on the path (or several).\n\tstruct PPtrSearchInstr\n\t{\n\t\t//Amount of visited fields to leave.\n\t\t// - Before leaving an array, jump back to the instruction that entered the array if there are more elements.\n\t\tuint32_t nLeave;\n\t\t//Index of the next child field to visit.\n\t\tuint32_t entryChildIdx;\n\t\tPPtrSearchInstr()\n\t\t\t: nLeave(0), entryChildIdx(0)\n\t\t{}\n\t\tPPtrSearchInstr(uint32_t nLeave, uint32_t entryChildIdx)\n\t\t\t: nLeave(nLeave), entryChildIdx(entryChildIdx)\n\t\t{}\n\t};\n\tstruct TemplateStackEntry\n\t{\n\t\tAssetTypeTemplateField *pTemplate;\n\t\tsize_t nextChildIdx;\n\t\tTemplateStackEntry()\n\t\t\t: pTemplate(nullptr), nextChildIdx(0)\n\t\t{}\n\t\tTemplateStackEntry(AssetTypeTemplateField *pTemplate, size_t nextChildIdx)\n\t\t\t: pTemplate(pTemplate), nextChildIdx(nextChildIdx)\n\t\t{}\n\t};\n\tstd::vector<PPtrSearchInstr> searchInstructions; \n\tuint32_t curSearchInstructionDepth = 0;\n\tuint32_t searchInstructionPendingLeaves = 0;\n\tstd::vector<TemplateStackEntry> templateSearchStack;\n\ttemplateSearchStack.emplace_back(TemplateStackEntry(pBaseField->GetTemplateField(), 0));\n\twhile (!templateSearchStack.empty())\n\t{\n\t\tTemplateStackEntry stackEntry = templateSearchStack.back();\n\t\tbool leaveEntry = false;\n\t\tif (stackEntry.pTemplate->isArray)\n\t\t{\n\t\t\tif (stackEntry.nextChildIdx == 0 && stackEntry.pTemplate->children.size() == 2)\n\t\t\t{\n\t\t\t\t//Enter the first array element.\n\t\t\t\t//The search instruction interpreter handles array iteration implicitly.\n\t\t\t\t// It remembers the arrays it entered and the current array index.\n\t\t\t\t// When it is instructed to leave fields, it jumps back if an array to be left has further elements.\n\t\t\t\ttemplateSearchStack.back().nextChildIdx = 1;\n\t\t\t\ttemplateSearchStack.push_back(TemplateStackEntry(&stackEntry.pTemplate->children[1], 0));\n\t\t\t}\n\t\t\telse\n\t\t\t\tleaveEntry = true;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (stackEntry.nextChildIdx == 0 && //If it is a PPtr, its children aren\'t analyzed and therefore nextChildIdx always is 0.\n\t\t\t\t!strncmp(stackEntry.pTemplate->type.c_str(), "PPtr<", 5))\n\t\t\t{\n\t\t\t\tassert(curSearchInstructionDepth - searchInstructionPendingLeaves < templateSearchStack.size());\n\t\t\t\t//Add instructions to enter the PPtr.\n\t\t\t\tfor (size_t i = curSearchInstructionDepth - searchInstructionPendingLeaves; i < templateSearchStack.size() - 1; i++)\n\t\t\t\t{\n\t\t\t\t\tassert(templateSearchStack[i].nextChildIdx > 0);\n\t\t\t\t\t//Put the pending leave counter in the instruction, and enter the next child.\n\t\t\t\t\tsearchInstructions.emplace_back(\n\t\t\t\t\t\tPPtrSearchInstr(searchInstructionPendingLeaves,\n\t\t\t\t\t\t\t(uint32_t)(templateSearchStack[i].nextChildIdx - 1))\n\t\t\t\t\t);\n\t\t\t\t\tcurSearchInstructionDepth = curSearchInstructionDepth - searchInstructionPendingLeaves + 1;\n\t\t\t\t\tsearchInstructionPendingLeaves = 0;\n\t\t\t\t}\n\t\t\t\t//Leave the PPtr immediately, since there are no further PPtrs inside.\n\t\t\t\tleaveEntry = true;\n\t\t\t}\n\t\t\telse if (stackEntry.nextChildIdx < stackEntry.pTemplate->children.size())\n\t\t\t{\n\t\t\t\tassert(curSearchInstructionDepth - searchInstructionPendingLeaves <= templateSearchStack.size());\n\t\t\t\t//Enter the next child.\n\t\t\t\tsize_t nextChildIdx = stackEntry.nextChildIdx;\n\t\t\t\ttemplateSearchStack.back().nextChildIdx++;\n\t\t\t\ttemplateSearchStack.push_back(TemplateStackEntry(&stackEntry.pTemplate->children[nextChildIdx], 0));\n\t\t\t}\n\t\t\telse\n\t\t\t\tleaveEntry = true;\n\t\t}\n\t\tif (leaveEntry)\n\t\t{\n\t\t\tif (curSearchInstructionDepth - searchInstructionPendingLeaves >= templateSearchStack.size())\n\t\t\t{\n\t\t\t\t//\'Leave\' this node, in case it is entered at the state of the latest search instruction.\n\t\t\t\tassert(curSearchInstructionDepth - searchInstructionPendingLeaves == templateSearchStack.size());\n\t\t\t\tsearchInstructionPendingLeaves++;\n\t\t\t}\n\t\t\ttemplateSearchStack.pop_back();\n\t\t}\n\t}\n\t//Add an end instruction that leaves all open nodes plus the base node.\n\t// If the base node is a PPtr, the end instruction will be the only one.\n\t// If the end instruction wasn\'t there, the PPtr would not be processed.\n\tsearchInstructions.emplace_back(PPtrSearchInstr(curSearchInstructionDepth + 1, 0));\n\n\tstruct ExecArrayDesc\n\t{\n\t\tsize_t enterInstrIdx; //Instruction index that entered the first element of the array.\n\t\tuint32_t execStackDepth; //Index in execStack where the array value field is located.\n\t\tuint32_t curChildIdx; //Index of the current child.\n\t\tExecArrayDesc()\n\t\t\t: execStackDepth(0), enterInstrIdx(0), curChildIdx(0)\n\t\t{}\n\t\tExecArrayDesc(uint32_t execStackDepth, size_t enterInstrIdx)\n\t\t\t: execStackDepth(execStackDepth), enterInstrIdx(enterInstrIdx), curChildIdx(0)\n\t\t{}\n\t};\n\tstd::vector<ExecArrayDesc> openArrays;\n\tstd::vector<AssetTypeValueField*> execStack;\n\texecStack.push_back(pBaseField);\n\tfor (size_t ip = 0; ip < searchInstructions.size(); ip++)\n\t{\n\t\tassert(!execStack.empty());\n\t\tif (execStack.back()->GetType().starts_with("PPtr<"))\n\t\t{\n\t\t\t//Found a PPtr.\n\t\t\tAssetTypeValueField *pPPtrBase = execStack.back();\n\t\t\tAssetTypeValueField *pFileIDField = pPPtrBase->Get("m_FileID");\n\t\t\tAssetTypeValueField *pPathIDField = pPPtrBase->Get("m_PathID");\n\t\t\tif (!pFileIDField->IsDummy() && pFileIDField->GetValue() != nullptr &&\n\t\t\t\t!pPathIDField->IsDummy() && pPathIDField->GetValue() != nullptr &&\n\t\t\t\tpPathIDField->GetValue()->AsUInt64() != 0)\n\t\t\t{\n\t\t\t\t//The PPtr is non-empty.\n\t\t\t\tret.push_back(pPPtrBase);\n\t\t\t}\n\t\t}\n\t\t//Leave the specified amount of stack elements.\n\t\tuint32_t nLeaveLeft = searchInstructions[ip].nLeave;\n\t\tassert(nLeaveLeft <= execStack.size());\n\t\tif (nLeaveLeft > execStack.size())\n\t\t\tbreak;\n\t\t//If an array element is left (<=> the leave counter shrinks the stack at least to the array itself,\n\t\t//      i.e. so that afterwards [execStack.size <= array.execStackDepth + 1] holds),\n\t\t// check if there are further array elements.\n\t\twhile (!openArrays.empty() && execStack.size() - nLeaveLeft <= openArrays.back().execStackDepth + 1)\n\t\t{\n\t\t\t//Assert that an element of the outermost openArrays entry is in the stack.\n\t\t\t//If that were not the case, the openArrays entry should have been closed already.\n\t\t\tassert(execStack.size() > openArrays.back().execStackDepth);\n\t\t\tif (execStack.size() <= openArrays.back().execStackDepth)\n\t\t\t\treturn ret;\n\n\t\t\t//Leave the array element but not the array itself.\n\t\t\tuint32_t nCurLeave = static_cast<uint32_t>(execStack.size() - openArrays.back().execStackDepth - 1);\n\t\t\texecStack.erase(execStack.begin() + (execStack.size() - nCurLeave), execStack.end());\n\t\t\t//for (uint32_t iLeave = 0; iLeave < nCurLeave; iLeave++)\n\t\t\t//\texecStack.pop_back();\n\t\t\tnLeaveLeft -= nCurLeave;\n\t\t\tif (execStack[openArrays.back().execStackDepth]->GetChildrenCount() < openArrays.back().curChildIdx + 1)\n\t\t\t{\n\t\t\t\t//Continue with the instruction that entered the array element.\n\t\t\t\tip = openArrays.back().enterInstrIdx;\n\t\t\t\topenArrays.back().curChildIdx++;\n\t\t\t\tnLeaveLeft = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t//Close the openArrays entry and then check for the next openArrays entry, if it exists.\n\t\t\t\topenArrays.pop_back();\n\t\t\t}\n\t\t}\n\t\texecStack.erase(execStack.begin() + (execStack.size() - nLeaveLeft), execStack.end());\n\t\tif (execStack.empty())\n\t\t\tbreak;\n\t\tassert(!execStack.back()->IsDummy());\n\t\tif (execStack.back()->IsDummy())\n\t\t\tbreak;\n\t\tif (execStack.back()->GetTemplateField()->isArray)\n\t\t{\n\t\t\t//Open an array element.\n\t\t\tif (openArrays.empty() || openArrays.back().execStackDepth != execStack.size() - 1)\n\t\t\t{\n\t\t\t\t//Create the openArrays entry when entering the first element.\n\t\t\t\topenArrays.emplace_back(ExecArrayDesc(static_cast<uint32_t>(execStack.size() - 1), ip));\n\t\t\t}\n\t\t\texecStack.push_back(execStack.back()->Get(openArrays.back().curChildIdx));\n\t\t}\n\t\telse\n\t\t{\n\t\t\tassert(execStack.back()->GetChildrenCount() > searchInstructions[ip].entryChildIdx);\n\t\t\tif (execStack.back()->GetChildrenCount() <= searchInstructions[ip].entryChildIdx)\n\t\t\t\tbreak;\n\t\t\texecStack.push_back(execStack.back()->Get(searchInstructions[ip].entryChildIdx));\n\t\t}\n\t}\n\n\treturn ret;\n}\nbool AssetViewModifyDialog::moveArrayItem(HWND hTree, AssetDeserializeDesc *pAssetDesc, \n\tAssetTypeValueField *pArrayField, MC_HTREELISTITEM hItem, uint32_t newIndex)\n{\n\tauto arrayMappingIt = pAssetDesc->arrayMappingsByArray.find(pArrayField);\n\tif (arrayMappingIt == pAssetDesc->arrayMappingsByArray.end())\n\t\treturn false;\n\tauto indexMapIt = arrayMappingIt->second.itemToIndexMap.find(hItem);\n\tif (indexMapIt == arrayMappingIt->second.itemToIndexMap.end())\n\t\treturn false;\n\tif (static_cast<size_t>(newIndex) >= arrayMappingIt->second.treeItems.size())\n\t\tnewIndex = static_cast<uint32_t>(arrayMappingIt->second.treeItems.size() - 1);\n\tuint32_t oldIndex = indexMapIt->second;\n\n\t//Move the item in the array<=>item mappings.\n\tarrayMappingIt->second.moveItem(hItem, newIndex);\n\t//Move the item in the child list.\n\tAssetTypeValueField **pChildrenList = pArrayField->GetChildrenList();\n\tAssetTypeValueField *pMovedField = pChildrenList[oldIndex];\n\tif (newIndex < oldIndex)\n\t{\n\t\tmemmove(&pChildrenList[newIndex + 1], &pChildrenList[newIndex],\n\t\t\t(oldIndex - newIndex) * sizeof(AssetTypeValueField*));\n\t}\n\telse if (newIndex > oldIndex)\n\t{\n\t\tmemmove(&pChildrenList[oldIndex], &pChildrenList[oldIndex + 1],\n\t\t\t(newIndex - oldIndex) * sizeof(AssetTypeValueField*));\n\t}\n\tpChildrenList[newIndex] = pMovedField;\n\t//Move the item in the tree list control (after the item with the next smaller index, or as the first item).\n\tMC_HTREELISTITEM afterItem = MC_TLI_FIRST;\n\tfor (size_t _i = newIndex; _i > 0; _i--)\n\t{\n\t\tsize_t i = _i - 1;\n\t\tif (arrayMappingIt->second.treeItems[i] != NULL)\n\t\t{\n\t\t\tafterItem = arrayMappingIt->second.treeItems[i];\n\t\t\tbreak;\n\t\t}\n\t}\n\tSendMessage(hTree, MC_TLM_MOVEITEM, reinterpret_cast<WPARAM>(hItem), reinterpret_cast<LPARAM>(afterItem));\n\tpAssetDesc->hasChanged = true;\n\treturn true;\n}\nvoid AssetViewModifyDialog::openContextMenuPopup(HWND hTree, POINT clickPos,\n\t\tMC_HTREELISTITEM hItem, AssetTypeValueField *pValueField,\n\t\tMC_HTREELISTITEM hParentItem, AssetTypeValueField *pParentValueField,\n\t\tAssetDeserializeDesc *pAssetDesc)\n{\n\tstatic const uintptr_t ID_ARRAYENTRY_DELETE =    9001;\n\tstatic const uintptr_t ID_ARRAYENTRY_MOVEUP =    9002;\n\tstatic const uintptr_t ID_ARRAYENTRY_MOVEDOWN =  9003;\n\tstatic const uintptr_t ID_ARRAYENTRY_MOVE =      9004;\n\tstatic const uintptr_t ID_PPTRENTRY_NEWVIEWTAB = 9005;\n\tstatic const uintptr_t ID_PPTRENTRY_SHOWINLIST = 9006;\n\tif (pAssetDesc == nullptr || pAssetDesc->asset.pFile == nullptr)\n\t\treturn;\n\tif (this->hCurPopupMenu != NULL)\n\t{\n\t\tDestroyMenu(this->hCurPopupMenu);\n\t\tthis->hCurPopupMenu = NULL;\n\t}\n\tUINT popupMenuFlags = TPM_RETURNCMD | TPM_NONOTIFY;\n\tif (GetSystemMetrics(SM_MENUDROPALIGNMENT) != 0)\n\t\tpopupMenuFlags |= TPM_RIGHTALIGN | TPM_HORNEGANIMATION;\n\telse\n\t\tpopupMenuFlags |= TPM_HORPOSANIMATION;\n\tif (pValueField == nullptr)\n\t{\n\t\tif (hItem == NULL || (hItem != MC_TLI_ROOT && (hParentItem == NULL || pParentValueField == nullptr)))\n\t\t\treturn;\n\t\tif (hItem == MC_TLI_ROOT\n\t\t\t|| (pParentValueField != nullptr\n\t\t\t\t&& pParentValueField->GetType().starts_with("PPtr<")))\n\t\t{\n\t\t\tpathid_t pathID = 0;\n\t\t\tunsigned int absFileID = 0;\n\t\t\tif (hItem == MC_TLI_ROOT)\n\t\t\t{\n\t\t\t\tabsFileID = pAssetDesc->asset.pFile->getFileID();\n\t\t\t\tpathID = pAssetDesc->asset.pathID;\n\t\t\t}\n\t\t\telse if (pParentValueField != nullptr)\n\t\t\t{\n\t\t\t\tAssetTypeValueField* pFileIDField = pParentValueField->Get("m_FileID");\n\t\t\t\tAssetTypeValueField* pPathIDField = pParentValueField->Get("m_PathID");\n\t\t\t\tif (pFileIDField->GetValue() == nullptr || pPathIDField->GetValue() == nullptr)\n\t\t\t\t\treturn;\n\t\t\t\tunsigned int fileID = pFileIDField->GetValue()->AsUInt();\n\t\t\t\tpathID = pPathIDField->GetValue()->AsUInt64();\n\t\t\t\tabsFileID = pAssetDesc->asset.pFile->resolveRelativeFileID(fileID);\n\t\t\t}\n\t\t\tif (absFileID == 0 || pathID == 0)\n\t\t\t\treturn;\n\t\t\t//Handle PPtr \'[View asset]\' nodes.\n\t\t\tthis->hCurPopupMenu = CreatePopupMenu();\n\t\t\tif (this->hCurPopupMenu == NULL)\n\t\t\t\treturn;\n\t\t\tAppendMenu(this->hCurPopupMenu, MF_STRING, ID_PPTRENTRY_NEWVIEWTAB, TEXT("Show in &new tab"));\n\t\t\tAppendMenu(this->hCurPopupMenu, MF_STRING, ID_PPTRENTRY_SHOWINLIST, TEXT("Show in asset &list"));\n\t\t\tuintptr_t selectedId = static_cast<uintptr_t>(TrackPopupMenuEx(this->hCurPopupMenu, popupMenuFlags, clickPos.x, clickPos.y, this->hDialog, NULL));\n\t\t\tswitch (selectedId)\n\t\t\t{\n\t\t\tcase ID_PPTRENTRY_NEWVIEWTAB:\n\t\t\t\tif (!this->assetListDialog.openViewDataTab(absFileID, pathID))\n\t\t\t\t\tMessageBox(this->hDialog, TEXT("Unable to find the requested asset."), TEXT("Asset Bundle Extractor"), MB_ICONERROR);\n\t\t\t\tbreak;\n\t\t\tcase ID_PPTRENTRY_SHOWINLIST:\n\t\t\t\tif (this->assetListDialog.selectAsset(absFileID, pathID))\n\t\t\t\t\tthis->assetListDialog.switchToListTab();\n\t\t\t\telse\n\t\t\t\t\tMessageBox(this->hDialog, TEXT("Unable to find the requested asset."), TEXT("Asset Bundle Extractor"), MB_ICONERROR);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\telse if (pParentValueField != nullptr && pParentValueField->GetValue() && pParentValueField->GetValue()->AsArray())\n\t\t{\n\t\t\t//Handle Array index nodes.\n\t\t\tauto arrayMappingIt = pAssetDesc->arrayMappingsByArray.find(pParentValueField);\n\t\t\tif (arrayMappingIt == pAssetDesc->arrayMappingsByArray.end())\n\t\t\t\treturn;\n\t\t\tauto indexMapIt = arrayMappingIt->second.itemToIndexMap.find(hItem);\n\t\t\tif (indexMapIt == arrayMappingIt->second.itemToIndexMap.end())\n\t\t\t\treturn;\n\t\t\tif (indexMapIt->second > pParentValueField->GetChildrenCount())\n\t\t\t\treturn;\n\t\t\tassert(pParentValueField->GetChildrenCount() == pParentValueField->GetValue()->AsArray()->size);\n\n\t\t\tthis->hCurPopupMenu = CreatePopupMenu();\n\t\t\tif (this->hCurPopupMenu == NULL)\n\t\t\t\treturn;\n\t\t\tAppendMenu(this->hCurPopupMenu, MF_STRING, ID_ARRAYENTRY_MOVEUP, TEXT("Move array item &up"));\n\t\t\tAppendMenu(this->hCurPopupMenu, MF_STRING, ID_ARRAYENTRY_MOVE, TEXT("Move array item &to"));\n\t\t\tAppendMenu(this->hCurPopupMenu, MF_STRING, ID_ARRAYENTRY_MOVEDOWN, TEXT("Move array item &down"));\n\t\t\tAppendMenu(this->hCurPopupMenu, MF_STRING, ID_ARRAYENTRY_DELETE, TEXT("&Remove array item"));\n\t\t\tuintptr_t selectedId = static_cast<uintptr_t>(TrackPopupMenuEx(this->hCurPopupMenu, popupMenuFlags, clickPos.x, clickPos.y, this->hDialog, NULL));\n\t\t\t//Find again to prevent any issues from message handling during TrackPopupMenuEx.\n\t\t\tarrayMappingIt = pAssetDesc->arrayMappingsByArray.find(pParentValueField);\n\t\t\tif (arrayMappingIt == pAssetDesc->arrayMappingsByArray.end())\n\t\t\t\tselectedId = 0;\n\t\t\telse\n\t\t\t{\n\t\t\t\tindexMapIt = arrayMappingIt->second.itemToIndexMap.find(hItem);\n\t\t\t\tif (indexMapIt == arrayMappingIt->second.itemToIndexMap.end())\n\t\t\t\t\tselectedId = 0;\n\t\t\t}\n\t\t\tswitch (selectedId)\n\t\t\t{\n\t\t\tcase ID_ARRAYENTRY_MOVE:\n\t\t\t\tthis->openEditPopup(hTree, hItem, pParentValueField, pAssetDesc, 0);\n\t\t\t\tbreak;\n\t\t\tcase ID_ARRAYENTRY_MOVEUP:\n\t\t\tcase ID_ARRAYENTRY_MOVEDOWN:\n\t\t\t\t{\n\t\t\t\t\tuint32_t newIndex = indexMapIt->second;\n\t\t\t\t\tif (selectedId == ID_ARRAYENTRY_MOVEUP)\n\t\t\t\t\t\tnewIndex = (newIndex > 0) ? (newIndex - 1) : 0;\n\t\t\t\t\telse if (selectedId == ID_ARRAYENTRY_MOVEDOWN)\n\t\t\t\t\t\tnewIndex = (newIndex < pParentValueField->GetChildrenCount()-1) ? (newIndex + 1) : (pParentValueField->GetChildrenCount() - 1);\n\t\t\t\t\tthis->moveArrayItem(hTree, pAssetDesc, pParentValueField, hItem, newIndex);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase ID_ARRAYENTRY_DELETE:\n\t\t\t\t{\n\t\t\t\t\tuint32_t oldIndex = indexMapIt->second;\n\t\t\t\t\tAssetTypeValueField **pChildrenList = pParentValueField->GetChildrenList();\n\t\t\t\t\tAssetTypeValueField *pDeletedField = pChildrenList[oldIndex];\n\t\t\t\t\t\n\t\t\t\t\t//1. Check for PPtrs below the deleted array entry, where an asset could be loaded in the subtree.\n\t\t\t\t\tstd::vector<AssetTypeValueField*> pptrFields = findAllPPtrs(pDeletedField, pAssetDesc->asset);\n\t\t\t\t\t\n\t\t\t\t\t//2. For each PPtr candidate, find all subtree assets to be closed (=> AssetDeserializeDesc::children)\n\t\t\t\t\tbool hasUnappliedChanges = false;\n\t\t\t\t\tstd::vector<std::pair<AssetTypeValueField*, std::list<AssetDeserializeDesc>::iterator>> closedSubtreeAssets;\n\t\t\t\t\tfor (size_t i = 0; i < pptrFields.size(); i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tauto assetIt = this->loadedAssetsByPPtrField.find(pptrFields[i]);\n\t\t\t\t\t\tif (assetIt != this->loadedAssetsByPPtrField.end())\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tbool curHasUnappliedChanges;\n\t\t\t\t\t\t\tauto recursiveChildren = this->findAllSubtreeAssets(assetIt->second, curHasUnappliedChanges, pptrFields[i]);\n\t\t\t\t\t\t\tclosedSubtreeAssets.insert(closedSubtreeAssets.end(), recursiveChildren.begin(), recursiveChildren.end());\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t//3. If there are unsaved changes, ask.\n\t\t\t\t\tbool cancelledDelete = false;\n\t\t\t\t\tif (hasUnappliedChanges)\n\t\t\t\t\t{\n\t\t\t\t\t\tswitch (MessageBox(this->hDialog, TEXT("There are unsaved changes in assets opened below a PPtr.\\n")\n\t\t\t\t\t\t\tTEXT("Do you want save these changes before proceeding?"), TEXT("Asset Bundle Extractor"), MB_ICONWARNING | MB_YESNOCANCEL))\n\t\t\t\t\t\t{\n\t\t\t\t\t\tcase IDYES:\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tstd::vector<std::reference_wrapper<AssetDeserializeDesc>> assetsToApply;\n\t\t\t\t\t\t\t\tassetsToApply.reserve(closedSubtreeAssets.size());\n\t\t\t\t\t\t\t\tfor (size_t i = 0; i < closedSubtreeAssets.size(); ++i)\n\t\t\t\t\t\t\t\t\tassetsToApply.push_back(*closedSubtreeAssets[i].second);\n\t\t\t\t\t\t\t\tif (!this->applyChangesIn(assetsToApply.begin(), assetsToApply.end()))\n\t\t\t\t\t\t\t\t\tcancelledDelete = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase IDNO:\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase IDCANCEL:\n\t\t\t\t\t\t\tcancelledDelete = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (cancelledDelete)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t//4. Close the assets properly and remove them from all maps.\n\t\t\t\t\tthis->closeAllSubtreeAssets(hTree, closedSubtreeAssets, pAssetDesc);\n\n\t\t\t\t\t//5. Remove the array entry :\n\t\t\t\t\t//5a. Remove the entry from the array entry<->index mapping.\n\t\t\t\t\tarrayMappingIt->second.removeItem(hItem, oldIndex);\n\t\t\t\t\t//5b. Remove the entry field from the child list, and decrease the child list size (keeping the old and thereby oversized list memory).\n\t\t\t\t\tmemmove(&pChildrenList[oldIndex], &pChildrenList[oldIndex + 1],\n\t\t\t\t\t\t(pParentValueField->GetChildrenCount() - oldIndex - 1) * sizeof(AssetTypeValueField*));\n\t\t\t\t\tpParentValueField->SetChildrenList(pChildrenList, pParentValueField->GetChildrenCount() - 1);\n\t\t\t\t\tpParentValueField->GetValue()->AsArray()->size = pParentValueField->GetChildrenCount();\n\t\t\t\t\t//5c. Delete the item from the tree list before freeing its memory.\n\t\t\t\t\tSendMessage(hTree, MC_TLM_DELETEITEM, MC_TLDI_NONOTIFY, reinterpret_cast<LPARAM>(hItem));\n\t\t\t\t\t//5d. Free any additionally allocated memory for the deleted field (i.e. if it was added as a new array element).\n\t\t\t\t\tFreeFieldRecursively(pDeletedField, pAssetDesc->instanceModificationBuffers);\n\n\t\t\t\t\t//6. Update the array size text.\n\t\t\t\t\tsetTreeValueText(hTree, hParentItem, pParentValueField);\n\t\t\t\t\tpAssetDesc->hasChanged = true;\n\t\t\t\t\t\n\t\t\t\t\t//7. Select a new item and redraw the following items so the displayed indices are updated.\n\t\t\t\t\tRECT treeClientRect = {};\n\t\t\t\t\tGetClientRect(hTree, &treeClientRect);\n\t\t\t\t\tint curItemY = -1;\n\t\t\t\t\tint itemHeight = static_cast<int>(SendMessage(hTree, MC_TLM_GETITEMHEIGHT, 0, 0));\n\t\t\t\t\tif (itemHeight <= 0)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tbool foundNextItem = false;\n\t\t\t\t\tfor (size_t i = oldIndex; i < pParentValueField->GetChildrenCount(); i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tMC_HTREELISTITEM hCurItem = arrayMappingIt->second.treeItems[i];\n\t\t\t\t\t\tif (hCurItem == NULL)\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\tMC_TLITEM item;\n\t\t\t\t\t\titem.fMask = 0;\n\t\t\t\t\t\tif (curItemY == -1)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tRECT rect = {};\n\t\t\t\t\t\t\trect.left = MC_TLIR_BOUNDS;\n\t\t\t\t\t\t\tif (!SendMessage(hTree, MC_TLM_GETITEMRECT, reinterpret_cast<WPARAM>(hCurItem), reinterpret_cast<LPARAM>(&rect)))\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcurItemY = rect.top;\n\t\t\t\t\t\t\t//Select the next item. Visibility is ensured since the user selected the previous item at this location.\n\t\t\t\t\t\t\titem.fMask = MC_TLIF_STATE;\n\t\t\t\t\t\t\titem.state = MC_TLIS_SELECTED;\n\t\t\t\t\t\t\titem.stateMask = MC_TLIS_SELECTED;\n\t\t\t\t\t\t\tfoundNextItem = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t//Force an item redraw.\n\t\t\t\t\t\tSendMessage(hTree, MC_TLM_SETITEM, reinterpret_cast<WPARAM>(hCurItem), reinterpret_cast<LPARAM>(&item));\n\t\t\t\t\t\tcurItemY += itemHeight;\n\t\t\t\t\t\tif (curItemY > treeClientRect.bottom)\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (!foundNextItem)\n\t\t\t\t\t{\n\t\t\t\t\t\t//If we deleted the last visible item, select the new last item.\n\t\t\t\t\t\tMC_TLITEM item;\n\t\t\t\t\t\titem.fMask = MC_TLIF_STATE;\n\t\t\t\t\t\titem.state = MC_TLIS_SELECTED;\n\t\t\t\t\t\titem.stateMask = MC_TLIS_SELECTED;\n\t\t\t\t\t\tfor (size_t _i = oldIndex; _i > 0; _i--)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tsize_t i = _i - 1;\n\t\t\t\t\t\t\tMC_HTREELISTITEM hCurItem = arrayMappingIt->second.treeItems[i];\n\t\t\t\t\t\t\tif (hCurItem != NULL)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tSendMessage(hTree, MC_TLM_SETITEM, reinterpret_cast<WPARAM>(hCurItem), reinterpret_cast<LPARAM>(&item));\n\t\t\t\t\t\t\t\tSendMessage(hTree, MC_TLM_ENSUREVISIBLE, 0, reinterpret_cast<LPARAM>(hCurItem));\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t{\n\t\tif (hItem == NULL)\n\t\t\treturn;\n\t\t//Context menu behaviour for normal nodes defined by plugins.\n\t\tconst PluginMapping& plugins = appContext.getPlugins();\n\t\tauto citer = plugins.options.cbegin();\n\t\tstd::shared_ptr<IAssetViewEntryOptionProvider> pCurProvider;\n\t\tstd::vector<std::pair<std::string, std::unique_ptr<IOptionRunner>>> viableOptions;\n\t\twhile (citer = plugins.getNextOptionProvider<IAssetViewEntryOptionProvider>(citer, pCurProvider), pCurProvider != nullptr)\n\t\t{\n\t\t\tstd::string optionName;\n\t\t\tstd::unique_ptr<IOptionRunner> pRunner = pCurProvider->prepareForSelection(\n\t\t\t\tappContext, *this,\n\t\t\t\tFieldInfo(pValueField,\n\t\t\t\t\tAssetAbsPPtr(pAssetDesc->asset.pFile->getFileID(), pAssetDesc->asset.pathID),\n\t\t\t\t\thItem),\n\t\t\t\toptionName);\n\t\t\tif (pRunner != nullptr)\n\t\t\t{\n\t\t\t\tviableOptions.push_back({ std::move(optionName), std::move(pRunner) });\n\t\t\t}\n\t\t}\n\n\t\tsize_t sel = ShowContextMenu(viableOptions.size(), [&viableOptions](size_t i) {return viableOptions[i].first.c_str(); },\n\t\t\tpopupMenuFlags, clickPos.x, clickPos.y, this->hDialog,\n\t\t\tthis->hCurPopupMenu);\n\t\tif (sel != (size_t)-1)\n\t\t\t(*viableOptions[sel].second)(); //Let the plugin perform the action.\n\t}\n\tif (this->hCurPopupMenu != NULL)\n\t{\n\t\tDestroyMenu(this->hCurPopupMenu);\n\t\tthis->hCurPopupMenu = NULL;\n\t}\n}\n\nLRESULT CALLBACK AssetViewModifyDialog::AssetTreeListSubclassProc(HWND hWnd, UINT message, \n\tWPARAM wParam, LPARAM lParam, \n\tuintptr_t uIdSubclass, DWORD_PTR dwRefData)\n{\n\tAssetViewModifyDialog *pThis = reinterpret_cast<AssetViewModifyDialog*>(dwRefData);\n\tswitch (message)\n\t{\n\tcase WM_LBUTTONDBLCLK:\n\t\t{\n\t\t\tMC_TLHITTESTINFO hitTestInfo = {};\n\t\t\thitTestInfo.pt.x = GET_X_LPARAM(lParam); //Client area\n\t\t\thitTestInfo.pt.y = GET_Y_LPARAM(lParam);\n\t\t\tif (SendMessage(hWnd, MC_TLM_HITTEST, 0, reinterpret_cast<LPARAM>(&hitTestInfo)) != NULL && hitTestInfo.iSubItem == 1)\n\t\t\t{\n\t\t\t\tassert(hitTestInfo.hItem != NULL);\n\t\t\t\tif (pThis->hCurEditPopup != NULL)\n\t\t\t\t\tpThis->doCloseEditPopup();\n\t\t\t\t\n\t\t\t\tTCHAR textBuf[32]; textBuf[31] = 0;\n\t\t\t\tMC_TLITEM item;\n\t\t\t\titem.fMask = MC_TLIF_PARAM | MC_TLIF_TEXT;\n\t\t\t\titem.cchTextMax = 31;\n\t\t\t\titem.pszText = textBuf;\n\t\t\t\titem.lParam = 0;\n\t\t\t\tif (!SendMessage(hWnd, MC_TLM_GETITEM, \n\t\t\t\t\t\treinterpret_cast<WPARAM>(hitTestInfo.hItem),\n\t\t\t\t\t\treinterpret_cast<LPARAM>(&item)))\n\t\t\t\t\tbreak;\n\t\t\t\tif (item.lParam == 0)\n\t\t\t\t\tbreak;\n\n\t\t\t\tAssetTypeValueField *pValueField = reinterpret_cast<AssetTypeValueField*>(item.lParam);\n\t\t\t\tAssetDeserializeDesc *pAssetDesc = pThis->getAssetDescForItem(hitTestInfo.hItem);\n\t\t\t\tif (!pAssetDesc)\n\t\t\t\t\tbreak;\n\t\t\t\tif (!pValueField->GetValue())\n\t\t\t\t\tbreak;\n\t\t\t\t\n\t\t\t\tpThis->openEditPopup(hWnd, hitTestInfo.hItem, pValueField, pAssetDesc);\n\t\t\t\treturn (LRESULT)0;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase WM_NCDESTROY:\n\t\tRemoveWindowSubclass(hWnd, AssetTreeListSubclassProc, uIdSubclass);\n\t\tbreak;\n\t}\n    return DefSubclassProc(hWnd, message, wParam, lParam);\n}\n\nLRESULT CALLBACK AssetViewModifyDialog::EditPopupProc(HWND hWnd, UINT message, \n\tWPARAM wParam, LPARAM lParam, \n\tuintptr_t uIdSubclass, DWORD_PTR dwRefData)\n{\n\tAssetViewModifyDialog *pThis = (AssetViewModifyDialog*)dwRefData;\n\tswitch (message)\n\t{\n\tcase WM_KILLFOCUS:\n\t\t//if (wParam == WA_INACTIVE)\n\t\t{\n\t\t\tif (pThis->hCurEditPopup != NULL)\n\t\t\t\tpThis->doCloseEditPopup();\n\t\t}\n\t\tbreak;\n\tcase WM_KEYDOWN:\n\t\tif (LOWORD(wParam) == VK_ESCAPE || LOWORD(wParam) == VK_RETURN)\n\t\t{\n\t\t\tif (pThis->hCurEditPopup != NULL)\n\t\t\t\tpThis->doCloseEditPopup();\n\t\t}\n\t\tbreak;\n\tcase WM_NCDESTROY:\n\t\tRemoveWindowSubclass(hWnd, EditPopupProc, uIdSubclass);\n\t\tbreak;\n\t}\n    return DefSubclassProc(hWnd, message, wParam, lParam);\n}\n'