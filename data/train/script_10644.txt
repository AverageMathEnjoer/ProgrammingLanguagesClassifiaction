b'{-# LANGUAGE CPP #-}\n{-# LANGUAGE LambdaCase #-}\n{-# OPTIONS_GHC -fno-warn-incomplete-uni-patterns #-}\n\nmodule Hoodle.Coroutine.Minibuffer where\n\nimport Control.Lens (view)\nimport Control.Monad.State (get)\nimport Control.Monad.Trans (liftIO)\nimport Data.Foldable (Foldable (..), forM_, mapM_, toList)\nimport Data.Hoodle.Simple (Stroke (..))\nimport Data.Maybe (fromMaybe)\nimport Data.Sequence (Seq, ViewL (..), empty, singleton, viewl, (|>))\nimport Graphics.Hoodle.Render (renderStrk)\nimport qualified Graphics.Rendering.Cairo as Cairo\nimport qualified Graphics.UI.Gtk as Gtk\nimport Hoodle.Coroutine.Draw\n  ( invalidateInBBox,\n    nextevent,\n    waitSomeEvent,\n  )\nimport Hoodle.Device (PenButton (..), PointerCoord (..), getPointer)\nimport Hoodle.ModelAction.Pen (createNewStroke)\nimport Hoodle.Type.Canvas (defaultPenInfo, defaultPenWCS, penWidth)\nimport Hoodle.Type.Coroutine (MainCoroutine, doIOaction)\nimport Hoodle.Type.Enum (DrawFlag (Efficient))\nimport Hoodle.Type.Event\n  ( AllEvent (..),\n    MiniBufferEvent (..),\n    UserEvent (..),\n  )\nimport Hoodle.Type.HoodleState\n  ( deviceList,\n    gtkUIManager,\n  )\nimport Prelude hiding (length, mapM_)\n\ndrawMiniBufBkg :: Cairo.Render ()\ndrawMiniBufBkg = do\n  Cairo.setSourceRGBA 0.8 0.8 0.8 1\n  Cairo.rectangle 0 0 500 50\n  Cairo.fill\n  Cairo.setSourceRGBA 0.95 0.85 0.5 1\n  Cairo.rectangle 5 2 490 46\n  Cairo.fill\n  Cairo.setSourceRGBA 0 0 0 1\n  Cairo.setLineWidth 1.0\n  Cairo.rectangle 5 2 490 46\n  Cairo.stroke\n\ndrawMiniBuf :: (Foldable t) => t Stroke -> Cairo.Render ()\ndrawMiniBuf strks = drawMiniBufBkg >> mapM_ renderStrk strks\n\nminibufDialog :: String -> MainCoroutine (Either () [Stroke])\nminibufDialog msg = do\n  xst <- get\n  let dev = view deviceList xst\n  let ui = view gtkUIManager xst\n  agr <-\n    liftIO\n      ( Gtk.uiManagerGetActionGroups ui >>= \\case\n          [] -> error "No action group? "\n          y : _ -> return y\n      )\n  uxinputa <-\n    liftIO\n      ( Gtk.actionGroupGetAction agr "UXINPUTA" >>= \\(Just x) ->\n          return (Gtk.castToToggleAction x)\n      )\n  doesUseX11Ext <- liftIO $ Gtk.toggleActionGetActive uxinputa\n  doIOaction (action dev doesUseX11Ext)\n  minibufInit\n  where\n    action dev _doesUseX11Ext evhandler = do\n      dialog <- Gtk.dialogNew\n      msgLabel <- Gtk.labelNew (Just msg)\n      cvs <- Gtk.drawingAreaNew\n      Gtk.widgetSetSizeRequest cvs 500 50\n      _ <- cvs `Gtk.on` Gtk.draw $ do\n        -- __TODO__: purify this\n        drawwdw <-\n          liftIO $\n            Gtk.widgetGetWindow cvs >>= \\case\n              Just drawwdw -> pure drawwdw\n              _ -> error "minibufDialog: now canvas window"\n        liftIO (Gtk.renderWithDrawWindow drawwdw drawMiniBufBkg)\n        (liftIO . evhandler . UsrEv . MiniBuffer . MiniBufferInitialized) drawwdw\n      _ <- cvs `Gtk.on` Gtk.buttonPressEvent $\n        Gtk.tryEvent $ do\n          (mbtn, mp) <- getPointer dev\n          forM_ mp $ \\p -> do\n            let pbtn = fromMaybe PenButton1 mbtn\n            case pbtn of\n              TouchButton -> return ()\n              _ -> (liftIO . evhandler . UsrEv . MiniBuffer) (MiniBufferPenDown pbtn p)\n      _ <- cvs `Gtk.on` Gtk.buttonReleaseEvent $\n        Gtk.tryEvent $ do\n          (mbtn, mp) <- getPointer dev\n          forM_ mp $ \\p -> do\n            let pbtn = fromMaybe PenButton1 mbtn\n            case pbtn of\n              TouchButton -> return ()\n              _ -> (liftIO . evhandler . UsrEv . MiniBuffer) (MiniBufferPenUp p)\n      _ <- cvs `Gtk.on` Gtk.motionNotifyEvent $\n        Gtk.tryEvent $ do\n          (mbtn, mp) <- getPointer dev\n          forM_ mp $ \\p -> do\n            let pbtn = fromMaybe PenButton1 mbtn\n            case pbtn of\n              TouchButton -> return ()\n              _ -> (liftIO . evhandler . UsrEv . MiniBuffer) (MiniBufferPenMove p)\n      Gtk.widgetAddEvents cvs [Gtk.PointerMotionMask, Gtk.Button1MotionMask]\n      upper <- fmap Gtk.castToContainer (Gtk.dialogGetContentArea dialog)\n      vbox <- Gtk.vBoxNew False 0\n      Gtk.containerAdd upper vbox\n      hbox <- Gtk.hBoxNew False 0\n      Gtk.boxPackStart hbox msgLabel Gtk.PackGrow 0\n      Gtk.boxPackStart vbox hbox Gtk.PackGrow 0\n      Gtk.boxPackStart vbox cvs Gtk.PackNatural 0\n      _btnOk <- Gtk.dialogAddButton dialog "Ok" Gtk.ResponseOk\n      _btnCancel <- Gtk.dialogAddButton dialog "Cancel" Gtk.ResponseCancel\n      _btnText <- Gtk.dialogAddButton dialog "TextInput" (Gtk.ResponseUser 1)\n      Gtk.widgetShowAll dialog\n      res <- Gtk.dialogRun dialog\n      Gtk.widgetDestroy dialog\n      case res of\n        Gtk.ResponseOk -> return (UsrEv (OkCancel True))\n        Gtk.ResponseCancel -> return (UsrEv (OkCancel False))\n        Gtk.ResponseUser 1 -> return (UsrEv ChangeDialog)\n        _ -> return (UsrEv (OkCancel False))\n\nminibufInit :: MainCoroutine (Either () [Stroke])\nminibufInit =\n  waitSomeEvent (\\case MiniBuffer (MiniBufferInitialized _) -> True; _ -> False)\n    >>= ( \\case\n            MiniBuffer (MiniBufferInitialized drawwdw) -> do\n              srcsfc <-\n                liftIO\n                  ( Cairo.createImageSurface\n                      Cairo.FormatARGB32\n                      500\n                      50\n                  )\n              tgtsfc <-\n                liftIO\n                  ( Cairo.createImageSurface\n                      Cairo.FormatARGB32\n                      500\n                      50\n                  )\n              liftIO $ Cairo.renderWith srcsfc (drawMiniBuf empty)\n              liftIO $ invalidateMinibuf drawwdw srcsfc\n              minibufStart drawwdw (srcsfc, tgtsfc) empty\n            _ -> minibufInit\n        )\n\ninvalidateMinibuf :: Gtk.DrawWindow -> Cairo.Surface -> IO ()\ninvalidateMinibuf drawwdw tgtsfc =\n  Gtk.renderWithDrawWindow drawwdw $ do\n    Cairo.setSourceSurface tgtsfc 0 0\n    Cairo.setOperator Cairo.OperatorSource\n    Cairo.paint\n\nminibufStart ::\n  Gtk.DrawWindow ->\n  -- | (source, target)\n  (Cairo.Surface, Cairo.Surface) ->\n  Seq Stroke ->\n  MainCoroutine (Either () [Stroke])\nminibufStart drawwdw (srcsfc, tgtsfc) strks = do\n  r <- nextevent\n  case r of\n    UpdateCanvas cid -> do\n      invalidateInBBox Nothing Efficient cid\n      minibufStart drawwdw (srcsfc, tgtsfc) strks\n    OkCancel True -> (return . Right) (toList strks)\n    OkCancel False -> (return . Right) []\n    ChangeDialog -> return (Left ())\n    MiniBuffer (MiniBufferPenDown PenButton1 pcoord) -> do\n      ps <- onestroke drawwdw (srcsfc, tgtsfc) (singleton pcoord)\n      let nstrks = strks |> mkstroke ps\n      liftIO $ Cairo.renderWith srcsfc (drawMiniBuf nstrks)\n      minibufStart drawwdw (srcsfc, tgtsfc) nstrks\n    _ -> minibufStart drawwdw (srcsfc, tgtsfc) strks\n\nonestroke ::\n  Gtk.DrawWindow ->\n  -- | (source, target)\n  (Cairo.Surface, Cairo.Surface) ->\n  Seq PointerCoord ->\n  MainCoroutine (Seq PointerCoord)\nonestroke drawwdw (srcsfc, tgtsfc) pcoords = do\n  r <- nextevent\n  case r of\n    MiniBuffer (MiniBufferPenMove pcoord) -> do\n      let newpcoords = pcoords |> pcoord\n      liftIO $ do\n        drawstrokebit (srcsfc, tgtsfc) newpcoords\n        invalidateMinibuf drawwdw tgtsfc\n      onestroke drawwdw (srcsfc, tgtsfc) newpcoords\n    MiniBuffer (MiniBufferPenUp pcoord) -> return (pcoords |> pcoord)\n    _ -> onestroke drawwdw (srcsfc, tgtsfc) pcoords\n\ndrawstrokebit ::\n  (Cairo.Surface, Cairo.Surface) ->\n  Seq PointerCoord ->\n  IO ()\ndrawstrokebit (srcsfc, tgtsfc) ps =\n  Cairo.renderWith tgtsfc $ do\n    Cairo.setSourceSurface srcsfc 0 0\n    Cairo.setOperator Cairo.OperatorSource\n    Cairo.paint\n    case viewl ps of\n      p :< ps\' -> do\n        Cairo.setOperator Cairo.OperatorOver\n        Cairo.setSourceRGBA 0.0 0.0 0.0 1.0\n        Cairo.setLineWidth (view penWidth defaultPenWCS)\n        Cairo.moveTo (pointerX p) (pointerY p)\n        mapM_ (uncurry Cairo.lineTo . ((,) <$> pointerX <*> pointerY)) ps\'\n        Cairo.stroke\n      _ -> return ()\n\nmkstroke :: Seq PointerCoord -> Stroke\nmkstroke ps =\n  let xyzs = fmap ((,,) <$> pointerX <*> pointerY <*> const 1.0) ps\n      pinfo = defaultPenInfo\n   in createNewStroke pinfo xyzs\n'