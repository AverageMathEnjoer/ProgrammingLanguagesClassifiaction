b'package effectivejava.chapter11.item83;\n\n// Initialization styles - Pages 333-\npublic class Initialization {\n\n    // Normal initialization of an instance field4 - Page 282\n    private final FieldType field1 = computeFieldValue();\n\n    // Lazy initialization of instance field4 - synchronized accessor - Page 333\n    private FieldType field2;\n    private synchronized FieldType getField2() {\n        if (field2 == null)\n            field2 = computeFieldValue();\n        return field2;\n    }\n\n    // Lazy initialization holder class idiom for static fields - Page 334\n    private static class FieldHolder {\n        static final FieldType field = computeFieldValue();\n    }\n\n    private static FieldType getField() { return FieldHolder.field; }\n\n\n    // Double-check idiom for lazy initialization of instance fields - Page 334\n    private volatile FieldType field4;\n\n    // NOTE: The code for this method in the first printing had a serious error (see errata for details)!\n    private FieldType getField4() {\n        FieldType result = field4;\n        if (result != null)    // First check (no locking)\n            return result;\n\n        synchronized(this) {\n            if (field4 == null) // Second check (with locking)\n                field4 = computeFieldValue();\n            return field4;\n        }\n    }\n\n\n\n    // Single-check idiom - can cause repeated initialization! - Page 334\n    private volatile FieldType field5;\n\n    private FieldType getField5() {\n        FieldType result = field5;\n        if (result == null)\n            field5 = result = computeFieldValue();\n        return result;\n    }\n\n    private static FieldType computeFieldValue() {\n        return new FieldType();\n    }\n}\n'