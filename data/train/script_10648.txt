b'{-# LANGUAGE CPP #-}\n{-# LANGUAGE PatternGuards #-}\n{-# LANGUAGE TemplateHaskell #-}\n\n#include "containers.h"\n\nimport Data.Sequence.Internal\n  ( Sized (..)\n  , Seq (Seq)\n  , FingerTree(..)\n  , Node(..)\n  , Elem(..)\n  , Digit (..)\n  , node2\n  , node3\n  , deep )\n\nimport Data.Sequence\n\nimport Control.Applicative (Applicative(..), liftA2)\nimport Control.Arrow ((***))\nimport Control.Monad.Trans.State.Strict\nimport Data.Array (listArray)\nimport Data.Foldable (Foldable(foldl, foldl1, foldr, foldr1, foldMap, fold), toList, all, sum, foldl\', foldr\')\nimport Data.Functor ((<$>), (<$))\nimport Data.Maybe\nimport Data.Function (on)\nimport Data.Monoid (Monoid(..), All(..), Endo(..), Dual(..))\nimport Data.Semigroup (stimes, stimesMonoid)\nimport Data.Traversable (Traversable(traverse), sequenceA)\nimport Prelude hiding (\n  lookup, null, length, take, drop, splitAt,\n  foldl, foldl1, foldr, foldr1, scanl, scanl1, scanr, scanr1,\n  filter, reverse, replicate, zip, zipWith, zip3, zipWith3,\n  all, sum)\nimport qualified Prelude\nimport qualified Data.List\nimport Test.Tasty\nimport Test.Tasty.QuickCheck hiding ((><))\nimport Test.QuickCheck.Function (apply)\nimport Test.QuickCheck.Poly (A, OrdA, B, OrdB, C)\nimport Control.Monad.Zip (MonadZip (..))\nimport Control.DeepSeq (deepseq)\nimport Control.Monad.Fix (MonadFix (..))\nimport Test.Tasty.HUnit\nimport qualified Language.Haskell.TH.Syntax as TH\n\n\nmain :: IO ()\nmain = defaultMain $ testGroup "seq-properties"\n       [ test_lift\n#if MIN_VERSION_template_haskell(2,16,0)\n       , test_liftTyped\n#endif\n       , testProperty "fmap" prop_fmap\n       , testProperty "(<$)" prop_constmap\n       , testProperty "foldr" prop_foldr\n       , testProperty "foldr\'" prop_foldr\'\n       , testProperty "lazy foldr\'" prop_lazyfoldr\'\n       , testProperty "foldr1" prop_foldr1\n       , testProperty "foldl" prop_foldl\n       , testProperty "foldl\'" prop_foldl\'\n       , testProperty "lazy foldl\'" prop_lazyfoldl\'\n       , testProperty "foldl1" prop_foldl1\n       , testProperty "(==)" prop_equals\n       , testProperty "compare" prop_compare\n       , testProperty "mappend" prop_mappend\n       , testProperty "singleton" prop_singleton\n       , testProperty "(<|)" prop_cons\n       , testProperty "(|>)" prop_snoc\n       , testProperty "(><)" prop_append\n       , testProperty "fromList" prop_fromList\n       , testProperty "fromFunction" prop_fromFunction\n       , testProperty "fromArray" prop_fromArray\n       , testProperty "replicate" prop_replicate\n       , testProperty "replicateA" prop_replicateA\n       , testProperty "replicateM" prop_replicateM\n       , testProperty "iterateN" prop_iterateN\n       , testProperty "unfoldr" prop_unfoldr\n       , testProperty "unfoldl" prop_unfoldl\n       , testProperty "null" prop_null\n       , testProperty "length" prop_length\n       , testProperty "viewl" prop_viewl\n       , testProperty "viewr" prop_viewr\n       , testProperty "scanl" prop_scanl\n       , testProperty "scanl1" prop_scanl1\n       , testProperty "scanr" prop_scanr\n       , testProperty "scanr1" prop_scanr1\n       , testProperty "tails" prop_tails\n       , testProperty "inits" prop_inits\n       , testProperty "takeWhileL" prop_takeWhileL\n       , testProperty "takeWhileR" prop_takeWhileR\n       , testProperty "dropWhileL" prop_dropWhileL\n       , testProperty "dropWhileR" prop_dropWhileR\n       , testProperty "spanl" prop_spanl\n       , testProperty "spanr" prop_spanr\n       , testProperty "breakl" prop_breakl\n       , testProperty "breakr" prop_breakr\n       , testProperty "partition" prop_partition\n       , testProperty "filter" prop_filter\n       , testProperty "sort" prop_sort\n       , testProperty "sortStable" prop_sortStable\n       , testProperty "sortBy" prop_sortBy\n       , testProperty "sortOn" prop_sortOn\n       , testProperty "sortOnStable" prop_sortOnStable\n       , testProperty "unstableSort" prop_unstableSort\n       , testProperty "unstableSortBy" prop_unstableSortBy\n       , testProperty "unstableSortOn" prop_unstableSortOn\n       , testProperty "index" prop_index\n       , testProperty "(!?)" prop_safeIndex\n       , testProperty "adjust" prop_adjust\n       , testProperty "insertAt" prop_insertAt\n       , testProperty "deleteAt" prop_deleteAt\n       , testProperty "update" prop_update\n       , testProperty "take" prop_take\n       , testProperty "drop" prop_drop\n       , testProperty "splitAt" prop_splitAt\n       , testProperty "chunksOf" prop_chunksOf\n       , testProperty "elemIndexL" prop_elemIndexL\n       , testProperty "elemIndicesL" prop_elemIndicesL\n       , testProperty "elemIndexR" prop_elemIndexR\n       , testProperty "elemIndicesR" prop_elemIndicesR\n       , testProperty "findIndexL" prop_findIndexL\n       , testProperty "findIndicesL" prop_findIndicesL\n       , testProperty "findIndexR" prop_findIndexR\n       , testProperty "findIndicesR" prop_findIndicesR\n       , testProperty "foldlWithIndex" prop_foldlWithIndex\n       , testProperty "foldrWithIndex" prop_foldrWithIndex\n       , testProperty "mapWithIndex" prop_mapWithIndex\n       , testProperty "foldMapWithIndex/foldlWithIndex" prop_foldMapWithIndexL\n       , testProperty "foldMapWithIndex/foldrWithIndex" prop_foldMapWithIndexR\n       , testProperty "traverseWithIndex" prop_traverseWithIndex\n       , testProperty "reverse" prop_reverse\n       , testProperty "zip" prop_zip\n       , testProperty "zipWith" prop_zipWith\n       , testProperty "zip3" prop_zip3\n       , testProperty "zipWith3" prop_zipWith3\n       , testProperty "zip4" prop_zip4\n       , testProperty "zipWith4" prop_zipWith4\n       , testProperty "mzip-naturality" prop_mzipNaturality\n       , testProperty "mzip-preservation" prop_mzipPreservation\n       , testProperty "munzip-lazy" prop_munzipLazy\n       , testProperty "<*>" prop_ap\n       , testProperty "<*> NOINLINE" prop_ap_NOINLINE\n       , testProperty "liftA2" prop_liftA2\n       , testProperty "*>" prop_then\n       , testProperty "<*" prop_before\n       , testProperty "cycleTaking" prop_cycleTaking\n       , testProperty "intersperse" prop_intersperse\n       , testProperty ">>=" prop_bind\n       , testProperty "mfix" test_mfix\n       , testProperty "Empty pattern" prop_empty_pat\n       , testProperty "Empty constructor" prop_empty_con\n       , testProperty "Left view pattern" prop_viewl_pat\n       , testProperty "Left view constructor" prop_viewl_con\n       , testProperty "Right view pattern" prop_viewr_pat\n       , testProperty "Right view constructor" prop_viewr_con\n       , testProperty "stimes" prop_stimes\n       ]\n\n------------------------------------------------------------------------\n-- Arbitrary\n------------------------------------------------------------------------\n\ninstance Arbitrary a => Arbitrary (Seq a) where\n    arbitrary = Seq <$> arbitrary\n    shrink (Seq x) = map Seq (shrink x)\n\ninstance Arbitrary a => Arbitrary (Elem a) where\n    arbitrary = Elem <$> arbitrary\n\ninstance (Arbitrary a, Sized a) => Arbitrary (FingerTree a) where\n    arbitrary = sized arb\n      where\n        arb :: (Arbitrary b, Sized b) => Int -> Gen (FingerTree b)\n        arb 0 = return EmptyT\n        arb 1 = Single <$> arbitrary\n        arb n = do\n            pr <- arbitrary\n            sf <- arbitrary\n            let n_pr = Prelude.length (toList pr)\n            let n_sf = Prelude.length (toList sf)\n            -- adding n `div` 7 ensures that n_m >= 0, and makes more Singles\n            let n_m = max (n `div` 7) ((n - n_pr - n_sf) `div` 3)\n            m <- arb n_m\n            return $ deep pr m sf\n\n    shrink (Deep _ (One a) EmptyT (One b)) = [Single a, Single b]\n    shrink (Deep _ pr m sf) =\n        [deep pr\' m sf | pr\' <- shrink pr] ++\n        [deep pr m\' sf | m\' <- shrink m] ++\n        [deep pr m sf\' | sf\' <- shrink sf]\n    shrink (Single x) = map Single (shrink x)\n    shrink EmptyT = []\n\ninstance (Arbitrary a, Sized a) => Arbitrary (Node a) where\n    arbitrary = oneof [\n        node2 <$> arbitrary <*> arbitrary,\n        node3 <$> arbitrary <*> arbitrary <*> arbitrary]\n\n    shrink (Node2 _ a b) =\n        [node2 a\' b | a\' <- shrink a] ++\n        [node2 a b\' | b\' <- shrink b]\n    shrink (Node3 _ a b c) =\n        [node2 a b, node2 a c, node2 b c] ++\n        [node3 a\' b c | a\' <- shrink a] ++\n        [node3 a b\' c | b\' <- shrink b] ++\n        [node3 a b c\' | c\' <- shrink c]\n\ninstance Arbitrary a => Arbitrary (Digit a) where\n    arbitrary = oneof [\n        One <$> arbitrary,\n        Two <$> arbitrary <*> arbitrary,\n        Three <$> arbitrary <*> arbitrary <*> arbitrary,\n        Four <$> arbitrary <*> arbitrary <*> arbitrary <*> arbitrary]\n\n    shrink (One a) = map One (shrink a)\n    shrink (Two a b) = [One a, One b]\n    shrink (Three a b c) = [Two a b, Two a c, Two b c]\n    shrink (Four a b c d) = [Three a b c, Three a b d, Three a c d, Three b c d]\n\n------------------------------------------------------------------------\n-- Valid trees\n------------------------------------------------------------------------\n\nclass Valid a where\n    valid :: a -> Bool\n\ninstance Valid (Elem a) where\n    valid _ = True\n\ninstance Valid (Seq a) where\n    valid (Seq xs) = valid xs\n\ninstance (Sized a, Valid a) => Valid (FingerTree a) where\n    valid EmptyT = True\n    valid (Single x) = valid x\n    valid (Deep s pr m sf) =\n        s == size pr + size m + size sf && valid pr && valid m && valid sf\n\ninstance (Sized a, Valid a) => Valid (Node a) where\n    valid node = size node == sum (fmap size node) && all valid node\n\ninstance Valid a => Valid (Digit a) where\n    valid = all valid\n\n{--------------------------------------------------------------------\n  The general plan is to compare each function with a list equivalent.\n  Each operation should produce a valid tree representing the same\n  sequence as produced by its list counterpart on corresponding inputs.\n  (The list versions are often lazier, but these properties ignore\n  strictness.)\n--------------------------------------------------------------------}\n\n-- utilities for partial conversions\n\ninfix 4 ~=\n\n(~=) :: Eq a => Maybe a -> a -> Bool\n(~=) = maybe (const False) (==)\n\n-- Partial conversion of an output sequence to a list.\ntoList\' :: Seq a -> Maybe [a]\ntoList\' xs\n  | valid xs = Just (toList xs)\n  | otherwise = Nothing\n\ntoListList\' :: Seq (Seq a) -> Maybe [[a]]\ntoListList\' xss = toList\' xss >>= mapM toList\'\n\ntoListPair\' :: (Seq a, Seq b) -> Maybe ([a], [b])\ntoListPair\' (xs, ys) = (,) <$> toList\' xs <*> toList\' ys\n\n-- Extra "polymorphic" test type\nnewtype D = D{ unD :: Integer }\n  deriving ( Eq )\n\ninstance Show D where\n  showsPrec n (D x) = showsPrec n x\n\ninstance Arbitrary D where\n  arbitrary    = (D . (+1) . abs) `fmap` arbitrary\n  shrink (D x) = [ D x\' | x\' <- shrink x, x\' > 0 ]\n\ninstance CoArbitrary D where\n  coarbitrary = coarbitrary . unD\n\n-- instances\n\nprop_fmap :: Seq Int -> Bool\nprop_fmap xs =\n    toList\' (fmap f xs) ~= map f (toList xs)\n  where f = (+100)\n\nprop_constmap :: A -> Seq A -> Bool\nprop_constmap x xs =\n    toList\' (x <$ xs) ~= map (const x) (toList xs)\n\nprop_foldr :: Seq A -> Property\nprop_foldr xs =\n    foldr f z xs === Prelude.foldr f z (toList xs)\n  where\n    f = (:)\n    z = []\n\nprop_foldr\' :: Seq A -> Property\nprop_foldr\' xs =\n    foldr\' f z xs === foldr\' f z (toList xs)\n  where\n    f = (:)\n    z = []\n\nprop_lazyfoldr\' :: Seq () -> Property\nprop_lazyfoldr\' xs =\n    not (null xs) ==>\n    foldr\'\n        (\\e _ ->\n              e)\n        (error "Data.Sequence.foldr\': should be lazy in initial accumulator")\n        xs ===\n    ()\n\nprop_foldr1 :: Seq Int -> Property\nprop_foldr1 xs =\n    not (null xs) ==> foldr1 f xs == Data.List.foldr1 f (toList xs)\n  where f = (-)\n\nprop_foldl :: Seq A -> Property\nprop_foldl xs =\n    foldl f z xs === Prelude.foldl f z (toList xs)\n  where\n    f = flip (:)\n    z = []\n\nprop_foldl\' :: Seq A -> Property\nprop_foldl\' xs =\n    foldl\' f z xs === foldl\' f z (toList xs)\n  where\n    f = flip (:)\n    z = []\n\nprop_lazyfoldl\' :: Seq () -> Property\nprop_lazyfoldl\' xs =\n    not (null xs) ==>\n    foldl\'\n        (\\_ e ->\n              e)\n        (error "Data.Sequence.foldl\': should be lazy in initial accumulator")\n        xs ===\n    ()\n\nprop_foldl1 :: Seq Int -> Property\nprop_foldl1 xs =\n    not (null xs) ==> foldl1 f xs == Data.List.foldl1 f (toList xs)\n  where f = (-)\n\nprop_equals :: Seq OrdA -> Seq OrdA -> Bool\nprop_equals xs ys =\n    (xs == ys) == (toList xs == toList ys)\n\nprop_compare :: Seq OrdA -> Seq OrdA -> Bool\nprop_compare xs ys =\n    compare xs ys == compare (toList xs) (toList ys)\n\nprop_mappend :: Seq A -> Seq A -> Bool\nprop_mappend xs ys =\n    toList\' (mappend xs ys) ~= toList xs ++ toList ys\n\n-- * Construction\n\n{-\n    toList\' empty ~= []\n-}\n\nprop_singleton :: A -> Bool\nprop_singleton x =\n    toList\' (singleton x) ~= [x]\n\nprop_cons :: A -> Seq A -> Bool\nprop_cons x xs =\n    toList\' (x <| xs) ~= x : toList xs\n\nprop_snoc :: Seq A -> A -> Bool\nprop_snoc xs x =\n    toList\' (xs |> x) ~= toList xs ++ [x]\n\nprop_append :: Seq A -> Seq A -> Bool\nprop_append xs ys =\n    toList\' (xs >< ys) ~= toList xs ++ toList ys\n\nprop_fromList :: [A] -> Bool\nprop_fromList xs =\n    toList\' (fromList xs) ~= xs\n\nprop_fromFunction :: [A] -> Bool\nprop_fromFunction xs =\n    toList\' (fromFunction (Prelude.length xs) (xs!!)) ~= xs\n\nprop_fromArray :: [A] -> Bool\nprop_fromArray xs =\n    toList\' (fromArray (listArray (42, 42+Prelude.length xs-1) xs)) ~= xs\n\n-- ** Repetition\n\nprop_replicate :: NonNegative Int -> A -> Bool\nprop_replicate (NonNegative m) x =\n    toList\' (replicate n x) ~= Prelude.replicate n x\n  where n = m `mod` 10000\n\nprop_replicateA :: NonNegative Int -> Bool\nprop_replicateA (NonNegative m) =\n    traverse toList\' (replicateA n a) ~= sequenceA (Prelude.replicate n a)\n  where\n    n = m `mod` 10000\n    a = Action 1 0 :: M Int\n\nprop_replicateM :: NonNegative Int -> Bool\nprop_replicateM (NonNegative m) =\n    traverse toList\' (replicateM n a) ~= sequence (Prelude.replicate n a)\n  where\n    n = m `mod` 10000\n    a = Action 1 0 :: M Int\n\n-- ** Iterative construction\n\nprop_iterateN :: NonNegative Int -> Int -> Bool\nprop_iterateN (NonNegative m) x =\n    toList\' (iterateN n f x) ~= Prelude.take n (Prelude.iterate f x)\n  where\n    n = m `mod` 10000\n    f = (+1)\n\nprop_unfoldr :: [A] -> Bool\nprop_unfoldr z =\n    toList\' (unfoldr f z) ~= Data.List.unfoldr f z\n  where\n    f [] = Nothing\n    f (x:xs) = Just (x, xs)\n\nprop_unfoldl :: [A] -> Bool\nprop_unfoldl z =\n    toList\' (unfoldl f z) ~= Data.List.reverse (Data.List.unfoldr (fmap swap . f) z)\n  where\n    f [] = Nothing\n    f (x:xs) = Just (xs, x)\n    swap (x,y) = (y,x)\n\n-- * Deconstruction\n\n-- ** Queries\n\nprop_null :: Seq A -> Bool\nprop_null xs =\n    null xs == Prelude.null (toList xs)\n\nprop_length :: Seq A -> Bool\nprop_length xs =\n    length xs == Prelude.length (toList xs)\n\n-- ** Views\n\nprop_viewl :: Seq A -> Bool\nprop_viewl xs =\n    case viewl xs of\n    EmptyL ->   Prelude.null (toList xs)\n    x :< xs\' -> valid xs\' && toList xs == x : toList xs\'\n\nprop_viewr :: Seq A -> Bool\nprop_viewr xs =\n    case viewr xs of\n    EmptyR ->   Prelude.null (toList xs)\n    xs\' :> x -> valid xs\' && toList xs == toList xs\' ++ [x]\n\n-- * Scans\n\nprop_scanl :: [A] -> Seq A -> Bool\nprop_scanl z xs =\n    toList\' (scanl f z xs) ~= Data.List.scanl f z (toList xs)\n  where f = flip (:)\n\nprop_scanl1 :: Seq Int -> Property\nprop_scanl1 xs =\n    not (null xs) ==> toList\' (scanl1 f xs) ~= Data.List.scanl1 f (toList xs)\n  where f = (-)\n\nprop_scanr :: [A] -> Seq A -> Bool\nprop_scanr z xs =\n    toList\' (scanr f z xs) ~= Data.List.scanr f z (toList xs)\n  where f = (:)\n\nprop_scanr1 :: Seq Int -> Property\nprop_scanr1 xs =\n    not (null xs) ==> toList\' (scanr1 f xs) ~= Data.List.scanr1 f (toList xs)\n  where f = (-)\n\n-- * Sublists\n\nprop_tails :: Seq A -> Bool\nprop_tails xs =\n    toListList\' (tails xs) ~= Data.List.tails (toList xs)\n\nprop_inits :: Seq A -> Bool\nprop_inits xs =\n    toListList\' (inits xs) ~= Data.List.inits (toList xs)\n\n-- ** Sequential searches\n-- We use predicates with varying density.\n\nprop_takeWhileL :: Positive Int -> Seq Int -> Bool\nprop_takeWhileL (Positive n) xs =\n    toList\' (takeWhileL p xs) ~= Prelude.takeWhile p (toList xs)\n  where p x = x `mod` n == 0\n\nprop_takeWhileR :: Positive Int -> Seq Int -> Bool\nprop_takeWhileR (Positive n) xs =\n    toList\' (takeWhileR p xs) ~= Prelude.reverse (Prelude.takeWhile p (Prelude.reverse (toList xs)))\n  where p x = x `mod` n == 0\n\nprop_dropWhileL :: Positive Int -> Seq Int -> Bool\nprop_dropWhileL (Positive n) xs =\n    toList\' (dropWhileL p xs) ~= Prelude.dropWhile p (toList xs)\n  where p x = x `mod` n == 0\n\nprop_dropWhileR :: Positive Int -> Seq Int -> Bool\nprop_dropWhileR (Positive n) xs =\n    toList\' (dropWhileR p xs) ~= Prelude.reverse (Prelude.dropWhile p (Prelude.reverse (toList xs)))\n  where p x = x `mod` n == 0\n\nprop_spanl :: Positive Int -> Seq Int -> Bool\nprop_spanl (Positive n) xs =\n    toListPair\' (spanl p xs) ~= Data.List.span p (toList xs)\n  where p x = x `mod` n == 0\n\nprop_spanr :: Positive Int -> Seq Int -> Bool\nprop_spanr (Positive n) xs =\n    toListPair\' (spanr p xs) ~= (Prelude.reverse *** Prelude.reverse) (Data.List.span p (Prelude.reverse (toList xs)))\n  where p x = x `mod` n == 0\n\nprop_breakl :: Positive Int -> Seq Int -> Bool\nprop_breakl (Positive n) xs =\n    toListPair\' (breakl p xs) ~= Data.List.break p (toList xs)\n  where p x = x `mod` n == 0\n\nprop_breakr :: Positive Int -> Seq Int -> Bool\nprop_breakr (Positive n) xs =\n    toListPair\' (breakr p xs) ~= (Prelude.reverse *** Prelude.reverse) (Data.List.break p (Prelude.reverse (toList xs)))\n  where p x = x `mod` n == 0\n\nprop_partition :: Positive Int -> Seq Int -> Bool\nprop_partition (Positive n) xs =\n    toListPair\' (partition p xs) ~= Data.List.partition p (toList xs)\n  where p x = x `mod` n == 0\n\nprop_filter :: Positive Int -> Seq Int -> Bool\nprop_filter (Positive n) xs =\n    toList\' (filter p xs) ~= Prelude.filter p (toList xs)\n  where p x = x `mod` n == 0\n\n-- * Sorting\n\nprop_sort :: Seq OrdA -> Bool\nprop_sort xs =\n    toList\' (sort xs) ~= Data.List.sort (toList xs)\n\ndata UnstableOrd = UnstableOrd\n    { ordKey :: OrdA\n    , _ignored :: A\n    } deriving (Show)\n\ninstance Eq UnstableOrd where\n    x == y = compare x y == EQ\n\ninstance Ord UnstableOrd where\n    compare (UnstableOrd x _) (UnstableOrd y _) = compare x y\n\ninstance Arbitrary UnstableOrd where\n    arbitrary = liftA2 UnstableOrd arbitrary arbitrary\n    shrink (UnstableOrd x y) =\n        [ UnstableOrd x\' y\'\n        | (x\',y\') <- shrink (x, y) ]\n\nprop_sortStable :: Seq UnstableOrd -> Bool\nprop_sortStable xs =\n    (fmap . fmap) unignore (toList\' (sort xs)) ~=\n    fmap unignore (Data.List.sort (toList xs))\n  where\n    unignore (UnstableOrd x y) = (x, y)\n\nprop_sortBy :: Seq (OrdA, B) -> Bool\nprop_sortBy xs =\n    toList\' (sortBy f xs) ~= Data.List.sortBy f (toList xs)\n  where f (x1, _) (x2, _) = compare x1 x2\n\nprop_sortOn :: Fun A OrdB -> Seq A -> Bool\nprop_sortOn (Fun _ f) xs =\n    toList\' (sortOn f xs) ~= listSortOn f (toList xs)\n  where\n    listSortOn = Data.List.sortOn\n\nprop_sortOnStable :: Fun A UnstableOrd -> Seq A -> Bool\nprop_sortOnStable (Fun _ f) xs =\n    toList\' (sortOn f xs) ~= listSortOn f (toList xs)\n  where\n    listSortOn = Data.List.sortOn\n\nprop_unstableSort :: Seq OrdA -> Bool\nprop_unstableSort xs =\n    toList\' (unstableSort xs) ~= Data.List.sort (toList xs)\n\nprop_unstableSortBy :: Seq OrdA -> Bool\nprop_unstableSortBy xs =\n    toList\' (unstableSortBy compare xs) ~= Data.List.sort (toList xs)\n\nprop_unstableSortOn :: Fun A OrdB -> Seq A -> Property\nprop_unstableSortOn (Fun _ f) xs =\n    toList\' (unstableSortBy (compare `on` f) xs) === toList\' (unstableSortOn f xs)\n\n-- * Indexing\n\nprop_index :: Seq A -> Property\nprop_index xs =\n    not (null xs) ==> forAll (choose (0, length xs-1)) $ \\ i ->\n    index xs i == toList xs !! i\n\nprop_safeIndex :: Seq A -> Property\nprop_safeIndex xs =\n    forAll (choose (-3, length xs + 3)) $ \\i ->\n    ((i < 0 || i >= length xs) .&&. lookup i xs === Nothing) .||.\n    lookup i xs === Just (toList xs !! i)\n\nprop_insertAt :: A -> Seq A -> Property\nprop_insertAt x xs =\n  forAll (choose (-3, length xs + 3)) $ \\i ->\n      let res = insertAt i x xs\n      in valid res .&&. res === case splitAt i xs of (front, back) -> front >< x <| back\n\nprop_deleteAt :: Seq A -> Property\nprop_deleteAt xs =\n  forAll (choose (-3, length xs + 3)) $ \\i ->\n      let res = deleteAt i xs\n      in valid res .&&.\n          (((0 <= i && i < length xs) .&&. res === case splitAt i xs of (front, back) -> front >< drop 1 back)\n            .||. ((i < 0 || i >= length xs) .&&. res === xs))\n\nprop_adjust :: Int -> Int -> Seq Int -> Bool\nprop_adjust n i xs =\n    toList\' (adjust f i xs) ~= adjustList f i (toList xs)\n  where f = (+n)\n\nprop_update :: Int -> A -> Seq A -> Bool\nprop_update i x xs =\n    toList\' (update i x xs) ~= adjustList (const x) i (toList xs)\n\nprop_take :: Int -> Seq A -> Bool\nprop_take n xs =\n    toList\' (take n xs) ~= Prelude.take n (toList xs)\n\nprop_drop :: Int -> Seq A -> Bool\nprop_drop n xs =\n    toList\' (drop n xs) ~= Prelude.drop n (toList xs)\n\nprop_splitAt :: Int -> Seq A -> Bool\nprop_splitAt n xs =\n    toListPair\' (splitAt n xs) ~= Prelude.splitAt n (toList xs)\n\nprop_chunksOf :: Seq A -> Property\nprop_chunksOf xs =\n  forAll (choose (1, length xs + 3)) $ \\n ->\n    let chunks = chunksOf n xs\n    in valid chunks .&&.\n       conjoin [valid c .&&. 1 <= length c && length c <= n | c <- toList chunks] .&&.\n       fold chunks === xs\n\nadjustList :: (a -> a) -> Int -> [a] -> [a]\nadjustList f i xs =\n    [if j == i then f x else x | (j, x) <- Prelude.zip [0..] xs]\n\n-- ** Indexing with predicates\n-- The elem* tests have poor coverage, but for find* we use predicates\n-- of varying density.\n\nprop_elemIndexL :: A -> Seq A -> Bool\nprop_elemIndexL x xs =\n    elemIndexL x xs == Data.List.elemIndex x (toList xs)\n\nprop_elemIndicesL :: A -> Seq A -> Bool\nprop_elemIndicesL x xs =\n    elemIndicesL x xs == Data.List.elemIndices x (toList xs)\n\nprop_elemIndexR :: A -> Seq A -> Bool\nprop_elemIndexR x xs =\n    elemIndexR x xs == listToMaybe (Prelude.reverse (Data.List.elemIndices x (toList xs)))\n\nprop_elemIndicesR :: A -> Seq A -> Bool\nprop_elemIndicesR x xs =\n    elemIndicesR x xs == Prelude.reverse (Data.List.elemIndices x (toList xs))\n\nprop_findIndexL :: Positive Int -> Seq Int -> Bool\nprop_findIndexL (Positive n) xs =\n    findIndexL p xs == Data.List.findIndex p (toList xs)\n  where p x = x `mod` n == 0\n\nprop_findIndicesL :: Positive Int -> Seq Int -> Bool\nprop_findIndicesL (Positive n) xs =\n    findIndicesL p xs == Data.List.findIndices p (toList xs)\n  where p x = x `mod` n == 0\n\nprop_findIndexR :: Positive Int -> Seq Int -> Bool\nprop_findIndexR (Positive n) xs =\n    findIndexR p xs == listToMaybe (Prelude.reverse (Data.List.findIndices p (toList xs)))\n  where p x = x `mod` n == 0\n\nprop_findIndicesR :: Positive Int -> Seq Int -> Bool\nprop_findIndicesR (Positive n) xs =\n    findIndicesR p xs == Prelude.reverse (Data.List.findIndices p (toList xs))\n  where p x = x `mod` n == 0\n\n-- * Folds\n\nprop_foldlWithIndex :: [(Int, A)] -> Seq A -> Bool\nprop_foldlWithIndex z xs =\n    foldlWithIndex f z xs == Data.List.foldl (uncurry . f) z (Data.List.zip [0..] (toList xs))\n  where f ys n y = (n,y):ys\n\nprop_foldrWithIndex :: [(Int, A)] -> Seq A -> Bool\nprop_foldrWithIndex z xs =\n    foldrWithIndex f z xs == Data.List.foldr (uncurry f) z (Data.List.zip [0..] (toList xs))\n  where f n y ys = (n,y):ys\n\nprop_foldMapWithIndexL :: (Fun (B, Int, A) B) -> B -> Seq A -> Bool\nprop_foldMapWithIndexL (Fun _ f) z t = foldlWithIndex f\' z t ==\n  appEndo (getDual (foldMapWithIndex (\\i -> Dual . Endo . flip (flip f\' i)) t)) z\n  where f\' b i a = f (b, i, a)\n\nprop_foldMapWithIndexR :: (Fun (Int, A, B) B) -> B -> Seq A -> Bool\nprop_foldMapWithIndexR (Fun _ f) z t = foldrWithIndex f\' z t ==\n   appEndo (foldMapWithIndex (\\i -> Endo . f\' i) t) z\n  where f\' i a b = f (i, a, b)\n\n-- * Transformations\n\nprop_mapWithIndex :: Seq A -> Bool\nprop_mapWithIndex xs =\n    toList\' (mapWithIndex f xs) ~= map (uncurry f) (Data.List.zip [0..] (toList xs))\n  where f = (,)\n\nprop_traverseWithIndex :: Seq Int -> Bool\nprop_traverseWithIndex xs =\n    runState (traverseWithIndex (\\i x -> modify ((i,x) :)) xs) [] ==\n    runState (sequenceA . mapWithIndex (\\i x -> modify ((i,x) :)) $ xs) [] \n\nprop_reverse :: Seq A -> Bool\nprop_reverse xs =\n    toList\' (reverse xs) ~= Prelude.reverse (toList xs)\n\n-- ** Zips\n\nprop_zip :: Seq A -> Seq B -> Bool\nprop_zip xs ys =\n    toList\' (zip xs ys) ~= Prelude.zip (toList xs) (toList ys)\n\nprop_zipWith :: Seq A -> Seq B -> Bool\nprop_zipWith xs ys =\n    toList\' (zipWith f xs ys) ~= Prelude.zipWith f (toList xs) (toList ys)\n  where f = (,)\n\nprop_zip3 :: Seq A -> Seq B -> Seq C -> Bool\nprop_zip3 xs ys zs =\n    toList\' (zip3 xs ys zs) ~= Prelude.zip3 (toList xs) (toList ys) (toList zs)\n\nprop_zipWith3 :: Seq A -> Seq B -> Seq C -> Bool\nprop_zipWith3 xs ys zs =\n    toList\' (zipWith3 f xs ys zs) ~= Prelude.zipWith3 f (toList xs) (toList ys) (toList zs)\n  where f = (,,)\n\nprop_zip4 :: Seq A -> Seq B -> Seq C -> Seq Int -> Bool\nprop_zip4 xs ys zs ts =\n    toList\' (zip4 xs ys zs ts) ~= Data.List.zip4 (toList xs) (toList ys) (toList zs) (toList ts)\n\nprop_zipWith4 :: Seq A -> Seq B -> Seq C -> Seq Int -> Bool\nprop_zipWith4 xs ys zs ts =\n    toList\' (zipWith4 f xs ys zs ts) ~= Data.List.zipWith4 f (toList xs) (toList ys) (toList zs) (toList ts)\n  where f = (,,,)\n\n-- This comes straight from the MonadZip documentation\nprop_mzipNaturality :: Fun A C -> Fun B D -> Seq A -> Seq B -> Property\nprop_mzipNaturality f g sa sb =\n  fmap (apply f *** apply g) (mzip sa sb) ===\n  mzip (apply f <$> sa) (apply g <$> sb)\n\n-- This is a slight optimization of the MonadZip preservation\n-- law that works because sequences don\'t have any decorations.\nprop_mzipPreservation :: Fun A B -> Seq A -> Property\nprop_mzipPreservation f sa =\n  let sb = fmap (apply f) sa\n  in munzip (mzip sa sb) === (sa, sb)\n\n-- We want to ensure that\n--\n-- munzip xs = xs `seq` (fmap fst x, fmap snd x)\n--\n-- even in the presence of bottoms (alternatives are all balance-\n-- fragile).\nprop_munzipLazy :: Seq (Integer, B) -> Bool\nprop_munzipLazy pairs = deepseq ((`seq` ()) <$> repaired) True\n  where\n    partialpairs = mapWithIndex (\\i a -> update i err pairs) pairs\n    firstPieces = fmap (fst . munzip) partialpairs\n    repaired = mapWithIndex (\\i s -> update i 10000 s) firstPieces\n    err = error "munzip isn\'t lazy enough"\n\n-- Applicative operations\n\nprop_ap :: Seq A -> Seq B -> Bool\nprop_ap xs ys =\n    toList\' ((,) <$> xs <*> ys) ~= ( (,) <$> toList xs <*> toList ys )\n\nprop_ap_NOINLINE :: Seq A -> Seq B -> Bool\nprop_ap_NOINLINE xs ys =\n    toList\' (((,) <$> xs) `apNOINLINE` ys) ~= ( (,) <$> toList xs <*> toList ys )\n\n{-# NOINLINE apNOINLINE #-}\napNOINLINE :: Seq (a -> b) -> Seq a -> Seq b\napNOINLINE fs xs = fs <*> xs\n\nprop_liftA2 :: Seq A -> Seq B -> Property\nprop_liftA2 xs ys = valid q .&&.\n    toList q === liftA2 (,) (toList xs) (toList ys)\n  where\n    q = liftA2 (,) xs ys\n\nprop_then :: Seq A -> Seq B -> Bool\nprop_then xs ys =\n    toList\' (xs *> ys) ~= (toList xs *> toList ys)\n\n-- We take only the length of the second sequence because\n-- the implementation throws the rest away; there\'s no\n-- point wasting test cases varying other aspects of that\n-- argument.\nprop_before :: Seq A -> NonNegative Int -> Bool\nprop_before xs (NonNegative lys) =\n    toList\' (xs <* ys) ~= (toList xs <* toList ys)\n  where ys = replicate lys ()\n\nprop_intersperse :: A -> Seq A -> Bool\nprop_intersperse x xs =\n    toList\' (intersperse x xs) ~= Data.List.intersperse x (toList xs)\n\nprop_cycleTaking :: Int -> Seq A -> Property\nprop_cycleTaking n xs =\n    (n <= 0 || not (null xs)) ==> toList\' (cycleTaking n xs) ~= Data.List.take n (Data.List.cycle (toList xs))\n\nprop_empty_pat :: Seq A -> Bool\nprop_empty_pat xs@Empty = null xs\nprop_empty_pat xs = not (null xs)\n\nprop_empty_con :: Bool\nprop_empty_con = null Empty\n\nprop_viewl_pat :: Seq A -> Property\nprop_viewl_pat xs@(y :<| ys)\n  | z :< zs <- viewl xs = y === z .&&. ys === zs\n  | otherwise = property False\nprop_viewl_pat xs = property $ null xs\n\nprop_viewl_con :: A -> Seq A -> Property\nprop_viewl_con x xs = x :<| xs === x <| xs\n\nprop_viewr_pat :: Seq A -> Property\nprop_viewr_pat xs@(ys :|> y)\n  | zs :> z <- viewr xs = y === z .&&. ys === zs\n  | otherwise = property False\nprop_viewr_pat xs = property $ null xs\n\nprop_viewr_con :: Seq A -> A -> Property\nprop_viewr_con xs x = xs :|> x === xs |> x\n\n-- Monad operations\n\nprop_bind :: Seq A -> Fun A (Seq B) -> Bool\nprop_bind xs (Fun _ f) =\n    toList\' (xs >>= f) ~= (toList xs >>= toList . f)\n\n-- Semigroup operations\n\nprop_stimes :: NonNegative Int -> Seq A -> Property\nprop_stimes (NonNegative n) s =\n  stimes n s === stimesMonoid n s\n\n-- MonadFix operation\n\n-- It\'s exceedingly difficult to construct a proper QuickCheck\n-- property for mfix because the function passed to it must be\n-- lazy. The following property is really just a unit test in\n-- disguise, and not a terribly meaningful one.\ntest_mfix :: Property\ntest_mfix = toList resS === resL\n  where\n    facty :: (Int -> Int) -> Int -> Int\n    facty _ 0 = 1; facty f n = n * f (n - 1)\n\n    resS :: Seq Int\n    resS = fmap ($ 12) $ mfix (\\f -> fromList [facty f, facty (+1), facty (+2)])\n\n    resL :: [Int]\n    resL = fmap ($ 12) $ mfix (\\f -> [facty f, facty (+1), facty (+2)])\n\n-- Simple test monad\n\ndata M a = Action Int a\n    deriving (Eq, Show)\n\ninstance Functor M where\n    fmap f (Action n x) = Action n (f x)\n\ninstance Applicative M where\n    pure x = Action 0 x\n    Action m f <*> Action n x = Action (m+n) (f x)\n\ninstance Monad M where\n    Action m x >>= f = let Action n y = f x in Action (m+n) y\n\ninstance Foldable M where\n    foldMap f (Action _ x) = f x\n\ninstance Traversable M where\n    traverse f (Action n x) = Action n <$> f x\n\n-- ----------\n--\n-- Unit tests\n--\n-- ----------\n\ntest_lift :: TestTree\ntest_lift = testCase "lift" $ do\n  (mempty :: Seq Int) @=? $([| $(TH.lift (fromList [] :: Seq Integer)) |])\n  fromList [1..3 :: Int] @=? $([| $(TH.lift (fromList [1..3 :: Integer])) |])\n\n#if MIN_VERSION_template_haskell(2,16,0)\ntest_liftTyped :: TestTree\ntest_liftTyped = testCase "liftTyped" $ do\n  (mempty :: Seq Int) @=? $$([|| $$(TH.liftTyped (fromList [])) ||])\n  fromList [1..3 :: Int] @=? $$([|| $$(TH.liftTyped (fromList [1..3])) ||])\n#endif\n'