b'#include "stdafx.h"\n#include "MakeIconResource.h"\n\ntypedef struct\n{\n\tuint16_t idReserved; // Reserved (must be 0)\n\tuint16_t idType; // Resource type (1 for icons)\n\tuint16_t idCount; // How many images?\n} GRPICONDIR, *LPGRPICONDIR;\n#define SIZEOF_GRPICONDIR 6\ntypedef struct\n{\n\tuint8_t bWidth; // Width, in pixels, of the image\n\tuint8_t bHeight; // Height, in pixels, of the image\n\tuint8_t bColorCount; // Number of colors in image (0 if >=8bpp)\n\tuint8_t bReserved; // Reserved\n\tuint16_t wPlanes; // Color Planes\n\tuint16_t wBitCount; // Bits per pixel\n\tDWORD dwBytesInRes; // how many bytes in this resource?\n\tuint16_t nID; // the ID\n} GRPICONDIRENTRY, *LPGRPICONDIRENTRY; \n#define SIZEOF_GRPICONDIRENTRY 14\ntypedef struct\n{\n\tuint8_t bWidth; // Width, in pixels, of the image\n\tuint8_t bHeight; // Height, in pixels, of the image\n\tuint8_t bColorCount; // Number of colors in image (0 if >=8bpp)\n\tuint8_t bReserved; // Reserved\n\tuint16_t wPlanes; // Color Planes\n\tuint16_t wBitCount; // Bits per pixel\n\tDWORD dwBytesInRes; // how many bytes in this resource?\n\tDWORD dwOffset; //byte offset from .ico file base\n} GRPICONENTRY, *LPGRPICONENTRY; \n#define SIZEOF_GRPICONENTRY 16\nstatic bool MakeIconResource(const std::vector<uint8_t> &icoData, std::vector<uint8_t> &iconGroup, std::vector<std::vector<uint8_t>> &iconData)\n{\n\tconst LPGRPICONDIR pIconHeader = (const LPGRPICONDIR)icoData.data();\n\tif ((icoData.size() < SIZEOF_GRPICONDIR) || (icoData.size() < (SIZEOF_GRPICONDIR + pIconHeader->idCount * SIZEOF_GRPICONENTRY)))\n\t\treturn false;\n\tfor (uint16_t i = 0; i < pIconHeader->idCount; i++)\n\t{\n\t\tLPGRPICONENTRY pCurEntry = (LPGRPICONENTRY)&(icoData[SIZEOF_GRPICONDIR + i * SIZEOF_GRPICONENTRY]);\n\t\tif (icoData.size() < (pCurEntry->dwOffset + pCurEntry->dwBytesInRes))\n\t\t\treturn false;\n\t}\n\ticonGroup.resize(SIZEOF_GRPICONDIR + pIconHeader->idCount * SIZEOF_GRPICONDIRENTRY);\n\tmemcpy(iconGroup.data(), pIconHeader, SIZEOF_GRPICONDIR);\n\ticonData.resize(pIconHeader->idCount);\n\tfor (uint16_t i = 0; i < pIconHeader->idCount; i++)\n\t{\n\t\tLPGRPICONENTRY pCurEntry = (LPGRPICONENTRY)&(icoData[SIZEOF_GRPICONDIR + i * SIZEOF_GRPICONENTRY]);\n\t\tLPGRPICONDIRENTRY pCurDirEntry = (LPGRPICONDIRENTRY)&(iconGroup[SIZEOF_GRPICONDIR + i * SIZEOF_GRPICONDIRENTRY]);\n\t\tmemcpy(pCurDirEntry, pCurEntry, SIZEOF_GRPICONDIRENTRY - 2);\n\t\tpCurDirEntry->nID = i + 1;\n\t\ticonData[i].resize(pCurDirEntry->dwBytesInRes);\n\t\tmemcpy(iconData[i].data(), &(icoData[pCurEntry->dwOffset]), pCurEntry->dwBytesInRes);\n\t}\n\treturn true;\n}\nstatic bool MakeIconResource(std::vector<HICON> hIcons, std::vector<uint8_t> &iconGroup, std::vector<std::vector<uint8_t>>&iconData)\n{\n\t//http://www.codeproject.com/Articles/4945/UpdateResource?msg=2766314#xx2766314xx\n\n\tGRPICONDIR dirBase = {};\n\tdirBase.idReserved = 0; dirBase.idType = 1;\n\tdirBase.idCount = std::min<uint16_t>((uint16_t)hIcons.size(),0xFFFE);\n\tstd::vector<GRPICONDIRENTRY> dirEntries;\n\tdirEntries.resize(std::min<uint16_t>((uint16_t)hIcons.size(),0xFFFE));\n\ticonData.resize(std::min<uint16_t>((uint16_t)hIcons.size(),0xFFFE));\n\tfor (size_t i = 0; i < hIcons.size() && i < 0xFFFF; i++)\n\t{\n\t\tICONINFO info = {};\n\t\tGetIconInfo(hIcons[i], &info);\n\t\tBITMAP bitmapColorInfo = {};\n\t\tBITMAP bitmapMaskInfo = {};\n\t\tif (!GetObject(info.hbmColor, sizeof(bitmapColorInfo), &bitmapColorInfo))\n\t\t{\n\t\t\tDeleteObject(info.hbmColor);\n\t\t\tDeleteObject(info.hbmMask);\n\t\t\treturn false;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tbool hasAlpha = false;\n\t\t\tbool hasMask = GetObject(info.hbmMask, sizeof(bitmapMaskInfo), &bitmapMaskInfo) != 0 && !hasAlpha;\n\t\t\tif (hasMask && bitmapMaskInfo.bmBitsPixel != 1)\n\t\t\t\treturn false;\n\n\t\t\tGRPICONDIRENTRY &entry = dirEntries[i];\n\t\t\tentry.bWidth = (uint8_t)bitmapColorInfo.bmWidth;\n\t\t\tentry.bHeight = (uint8_t)bitmapColorInfo.bmHeight;\n\t\t\tentry.bColorCount = 0;//(bitmapColorInfo.bmBitsPixel >= 8) ? 0 : (1 << bitmapColorInfo.bmBitsPixel); Size of palette\n\t\t\tentry.bReserved = 0;\n\t\t\tentry.wPlanes = 1;//bitmapColorInfo.bmPlanes;\n\t\t\tentry.wBitCount = 32;//(hasMask || hasAlpha) ? 32 : 24;//bitmapColorInfo.bmBitsPixel;\n\t\t\tentry.nID = 1 + (uint16_t)i;\n\t\t\tDWORD xorStride = (((entry.bWidth * entry.wBitCount) + 31) & (~31)) >> 3;\n\t\t\tDWORD andStride = (((entry.bWidth * 1) + 31) & (~31)) >> 3; //There MUST be a mask in the icon, if hasMask == false, we fill this with 1\n\t\t\tentry.dwBytesInRes = sizeof(BITMAPINFOHEADER) + entry.bHeight * xorStride + entry.bHeight * andStride;//(DWORD)iconDataSize;\n\t\t\t//only width, height and color format info is stored in bitmapInfo\n\t\t\tstd::vector<COLORREF> colorBitsTmp(xorStride * entry.bHeight);\n\t\t\n\t\t\tHDC hDC = CreateCompatibleDC(NULL);\n\t\t\tBITMAPINFO bmpInfo = {};\n\t\t\tbmpInfo.bmiHeader.biSize = sizeof(BITMAPINFOHEADER);\n\t\t\tbmpInfo.bmiHeader.biBitCount = 0;\n\t\t\tbmpInfo.bmiHeader.biWidth = entry.bWidth;\n\t\t\tbmpInfo.bmiHeader.biHeight = entry.bHeight;\n\t\t\tbmpInfo.bmiHeader.biPlanes = 1;\n\t\t\tbmpInfo.bmiHeader.biBitCount = 32;//bitmapColorInfo.bmBitsPixel;\n\t\t\tbmpInfo.bmiHeader.biCompression = BI_RGB;\n\t\t\tbmpInfo.bmiHeader.biSizeImage = 0;\n\t\t\tSelectObject(hDC, info.hbmColor);\n\t\t\tint ret = GetDIBits(hDC, info.hbmColor, 0, entry.bHeight, colorBitsTmp.data(), &bmpInfo, DIB_RGB_COLORS);\n\t\t\tif (ret != entry.bHeight)\n\t\t\t{\n\t\t\t\tDeleteObject(info.hbmColor);\n\t\t\t\tif (hasMask)\n\t\t\t\t\tDeleteObject(info.hbmMask);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tstd::vector<uint8_t> outIconData(entry.dwBytesInRes);\n\t\t\tBITMAPINFOHEADER *rawIconData_Header = (BITMAPINFOHEADER*)outIconData.data();\n\t\t\tvoid *rawIconData_XOR = (void*)&(outIconData[sizeof(BITMAPINFOHEADER)]);\n\t\t\tvoid *rawIconData_AND = (void*)&(outIconData[sizeof(BITMAPINFOHEADER) + entry.bHeight * xorStride]);\n\t\t\tif (hasMask)\n\t\t\t{\n\t\t\t\tmemcpy(rawIconData_XOR, colorBitsTmp.data(), (entry.bWidth * entry.bHeight) * 4); //always 32bit per pixel\n\t\t\t\tstd::vector<uint8_t> bmpInfoBuf(sizeof(BITMAPINFOHEADER) + 256 * sizeof(RGBQUAD));\n\t\t\t\tBITMAPINFO *_bmpInfo = reinterpret_cast<BITMAPINFO*>(bmpInfoBuf.data());\n\t\t\t\t_bmpInfo->bmiHeader.biSize = sizeof(BITMAPINFOHEADER);\n\t\t\t\t_bmpInfo->bmiHeader.biWidth = entry.bWidth;\n\t\t\t\t_bmpInfo->bmiHeader.biHeight = entry.bHeight;\n\t\t\t\t_bmpInfo->bmiHeader.biPlanes = 1;\n\t\t\t\t_bmpInfo->bmiHeader.biBitCount = 1;//bitmapColorInfo.bmBitsPixel;\n\t\t\t\t_bmpInfo->bmiHeader.biCompression = BI_RGB;\n\t\t\t\t_bmpInfo->bmiHeader.biSizeImage = 0;\n\t\t\t\tSelectObject(hDC, info.hbmMask);\n\t\t\t\tif (GetDIBits(hDC, info.hbmMask, 0, entry.bHeight, colorBitsTmp.data(), _bmpInfo, DIB_RGB_COLORS) != entry.bHeight)\n\t\t\t\t{\n\t\t\t\t\tDeleteObject(info.hbmColor);\n\t\t\t\t\tif (hasMask)\n\t\t\t\t\t\tDeleteObject(info.hbmMask);\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tmemcpy(rawIconData_AND, colorBitsTmp.data(), entry.bHeight * andStride);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tmemcpy(rawIconData_XOR, colorBitsTmp.data(), (entry.bWidth * entry.bHeight) * 4); //always 32bit per pixel\n\t\t\t\tmemset(rawIconData_AND, 1, andStride * entry.bHeight); //always 32bit per pixel\n\t\t\t}\n\t\t\trawIconData_Header->biSize = sizeof(BITMAPINFOHEADER);\n\t\t\trawIconData_Header->biWidth = entry.bWidth;\n\t\t\trawIconData_Header->biHeight = entry.bHeight * 2; //once intended (1 bit per color times) to easily determine the size\n\t\t\trawIconData_Header->biPlanes = entry.wPlanes;\n\t\t\trawIconData_Header->biBitCount = entry.wBitCount;\n\t\t\trawIconData_Header->biCompression = 0;\n\t\t\trawIconData_Header->biSizeImage = 0;\n\t\t\trawIconData_Header->biXPelsPerMeter = 0;\n\t\t\trawIconData_Header->biYPelsPerMeter = 0;\n\t\t\trawIconData_Header->biClrUsed = 0;\n\t\t\trawIconData_Header->biClrImportant = 0;\n\n\t\t\tDeleteObject(info.hbmColor);\n\t\t\tif (hasMask)\n\t\t\t\tDeleteObject(info.hbmMask);\n\n\t\t\ticonData[i] = std::move(outIconData);\n\t\t}\n\t}\n\ticonGroup.resize(SIZEOF_GRPICONDIR + dirEntries.size() * SIZEOF_GRPICONDIRENTRY);\n\tmemcpy(iconGroup.data(), &dirBase, SIZEOF_GRPICONDIR);\n\tfor (size_t i = 0; i < dirEntries.size(); i++)\n\t\tmemcpy(&(iconGroup.data()[SIZEOF_GRPICONDIR + i * SIZEOF_GRPICONDIRENTRY]), &dirEntries[i], SIZEOF_GRPICONDIRENTRY);\n\treturn true;\n}\n\nbool SetProgramIconResource(const TCHAR *filePath, const std::vector<uint8_t> &iconFileData)\n{\n\tstd::vector<uint8_t> iconGroup;\n\tstd::vector<std::vector<uint8_t>> iconDataList;\n\tif (MakeIconResource(iconFileData, iconGroup, iconDataList))\n\t{\n\t\tHANDLE hUpdate = BeginUpdateResource(filePath, FALSE);\n\t\tif (hUpdate)\n\t\t{\n\t\t\t#define IDI_MODINSTALLER 102\n\t\t\t//UpdateResource(hUpdate, RT_ICON, MAKEINTRESOURCE(IDI_MODINSTALLER), \n\t\t\t//\tMAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL), userData->iconData, userData->iconDataSize);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\tUpdateResource(hUpdate, RT_GROUP_ICON, MAKEINTRESOURCE(IDI_MODINSTALLER), \n\t\t\t\tMAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL), iconGroup.data(), (DWORD)iconGroup.size());\n\t\t\tfor (size_t i = 0; i < iconDataList.size(); i++)\n\t\t\t{\n\t\t\t\tUpdateResource(hUpdate, RT_ICON, MAKEINTRESOURCE(1+i), \n\t\t\t\t\tMAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL), iconDataList[i].data(), (DWORD)iconDataList[i].size());\n\t\t\t}\n\t\t\t//UpdateResource(hUpdate, RT_ICON, MAKEINTRESOURCE(1), \n\t\t\t//\tMAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL), pIconData, iconDataLen);\n\t\t\tEndUpdateResource(hUpdate, FALSE);\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n'