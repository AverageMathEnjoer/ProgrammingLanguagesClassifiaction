b'// UVa1603 Square Destroyer\n// Rujia Liu\n// This code implements a variant of an algorithm presented in a book. It\'s simple yet efficient.\n// Readers are encouraged to experiment on other algorithms.\n// However, it\'s still slow for n=5 and m=0 (which is NOT in judge input)\n// If you really want an efficient solution, learn DLX (Algorithm X with dancing links)\n// DLX is well expained (with code) in my other book <<Beginning Algorithm Contests -- Training Guide>>\n#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<algorithm>\nusing namespace std;\n\nconst int maxs = 60; // number of squares: 25+16+9+4+1=55\nconst int maxm = 60; // number of matches: 2*5*(5+1)=60\n\nint n, exists[maxm]; // matches\nint s, size[maxs], fullsize[maxs], contains[maxs][maxm]; // squares\nint best;\n\ninline int row_match(int x, int y) {\n  return (2*n+1)*x+y;\n}\n\ninline int col_match(int x, int y) {\n  return (2*n+1)*x+n+y;\n}\n\n// number of matches in a full n*n grid\ninline int match_count(int n) {\n  return 2*n*(n+1);\n}\n\nvoid init() {\n  int m, v;\n  scanf("%d%d", &n, &m);\n  for(int i = 0; i < match_count(n); ++i) exists[i] = 1;\n  while(m--) {\n    scanf("%d", &v);\n    exists[v-1] = 0;\n  }\n\n  // collect full squares\n  s = 0;\n  memset(contains, 0, sizeof(contains));\n  for(int i = 1; i <= n; i++) // side length\n    for(int x = 0; x <= n-i; x++)\n      for(int y = 0; y <= n-i; y++) {\n        size[s] = 0;\n        fullsize[s] = 4*i; // number of matches in a complete square\n        for(int j = 0; j < i; j++) {\n          int a = row_match(x, y+j); // up\n          int b = row_match(x+i, y+j); // down\n          int c = col_match(x+j, y); // left\n          int d = col_match(x+j, y+i); // right\n          contains[s][a] = 1;\n          contains[s][b] = 1;\n          contains[s][c] = 1;\n          contains[s][d] = 1;\n          size[s] += exists[a] + exists[b] + exists[c] + exists[d]; // number of matches now\n        }\n        ++s;\n      }\n}\n\nint find_square() {\n  for(int i = 0; i < s; i++)\n    if(size[i] == fullsize[i]) return i;\n  return -1;\n}\n\nvoid dfs(int dep) {\n  if(dep >= best) return;\n\n  int k = find_square();\n  if(k == -1) {\n    best = dep;\n    return;\n  }\n\n  // remove a match in that square\n  for(int i = 0; i < match_count(n); i++)\n    if(contains[k][i]) {\n      for(int j = 0; j < s; j++)\n        if(contains[j][i]) size[j]--;\n      dfs(dep + 1);\n      for(int j = 0; j < s; j++)\n        if(contains[j][i]) size[j]++;\n    }\n}\n\nint main() {\n  int T;\n  scanf("%d", &T);\n  while(T--) {\n    init();\n    best = n*n;\n    dfs(0);\n    printf("%d\\n", best);\n  }\n  return 0;\n}\n'