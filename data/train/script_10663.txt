b'{-# LANGUAGE NamedFieldPuns, ScopedTypeVariables, BangPatterns #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n-- {-# LANGUAGE TypeSynonymInstances #-}\n{-# OPTIONS_GHC -fwarn-incomplete-patterns #-}\n\n-- | Parallel Engines (integrated engines and futures)\n\n-- TODO: The ideal would probably be for each child thread to have a state that the\n-- parent can check upon sync and decide whether to cancel or continue that child\n-- engine in the next round.\n\n-- TODO: A memoized Par computation would be safe and perhaps useful here.\n\n--------------------------------------------------------------------------------\nmodule Control.Monad.Par.Engines.Internal\n       (Fuel, ParEng,\n        runEng, contEng, \n        spawnEng, getE, fuelLeft, tick\n       )\n       where\n\n-- import Data.Word\n-- import Data.IntMap as M\nimport qualified Control.Monad.Par as P\n\nimport qualified Control.Monad.Par.Class as PC\nimport Control.Monad.State.Strict\n\nimport Debug.Trace\n\n--------------------------------------------------------------------------------\n-- Types\n--------------------------------------------------------------------------------\n\n-- Co-routines built on IVars communicate by passing IVars back and forth.  For the\n-- parallel engine abstraction, we communication is between parent and child\n-- threads. Each time an engine checks in with its parent it gets both more fuel and\n-- another IVar to use for the next round.\n\ntype Fuel = Int\n\n-- | A `ParEng` computation has both parallelism and finite fuel.\n--\n-- type ParEng a = StateT (EngState) P.Par a\nnewtype ParEng a = ParEng { unEng :: StateT (EngState) P.Par a } \n  deriving (Monad)\n           \ndata EngState =\n  EngState\n  { startFuel :: Fuel\n  , curFuel   :: Fuel\n  , parent    :: OutStanding \n    -- ^ The parent computation to which we yield control.\n  , children  :: [OutStanding] \n    -- ^ A list of children that have been forked but may or may\n    -- not have been synced.\n  }\n\n-- | An engine that is all synced up has no more outstanding threads to wait on, only\n-- stalled threads waiting to be restarted, plus a placeholder for the final result.\ndata EngSynced a = EngSynced [P.IVar Restart] (P.IVar a)\n\n-- | A message to restart a stalled thread contains new fuel and a fresh IVar to\n-- communicate with the parent in the next round.  This is used in the "downcall"\n-- from parent to child.\ndata Restart = Restart Fuel (P.IVar EngCheckin)\n\n-- | Check in with the parent thread by sending one of these.  The "upcall".\ndata EngCheckin = Finished [OutStanding]\n                  -- ^ Completed successfully with an answer.  But the answer is not\n                  --   here.  Rather, the payload contains any children that have\n                  --   been created by the engine and may not have been synced.\n                | FuelExhausted (P.IVar Restart) [OutStanding]\n                 -- ^ Need to do more work, blocking on this IVar waiting for more\n                 -- fuel.  Still return any children.\n\n-- | Outstanding threads, on the other hand, may or may not be finished with their\n-- work; we find out when they check in.\nnewtype OutStanding = OutStanding (P.IVar EngCheckin)\n\n-- | An engine result may or may not be ready yet.  Either way it returns handles for\n-- any downstream child-engines that were created.\n--\n-- Here we need an extra IVar if it IS ready, for reasons of internal system\n-- architecture.\ntype EngResult a = Either (EngStalled a) (P.IVar a, [OutStanding])\n\n-- | An engine whose main thread has run out of fuel, but still may have outstanding\n-- child computations.  It contains an extra IVar for the result.\ndata EngStalled a =\n  EngStalled\n  { restarter :: !(P.IVar Restart)    \n  , finalVal  :: !(P.IVar a)\n  , outstanding :: [OutStanding]\n  }\n-- But, of course,\n-- the engine may run out of fuel again, so *that* result is an "Either" too.\n-- data EngStalled a = EngStalled !(P.IVar Restart) !(P.IVar (EngResult a))\n\n-- | Blocking on a future in an enginized context must not prevent all\n-- threads/child-engines from checking in when the engine is synced.\nnewtype EngFuture a = EngFuture (P.IVar (FutureResult a))\n-- RRN: NOTE: I don\'t yet know how to handle arbitrary IVar programs, rather than\n-- just futures.  If we didn\'t need "EngSynced" then perhaps we could do it.\n\n-- | If a child computation blocks repeatedly we will end up with a CHAIN of IVars\n-- (several EngStalled objects) that we must chase to find the final answer.  This\n-- O(N) space usage is required due to the single-assignment nature of IVars.\ndata FutureResult a = FutureReady   !(P.IVar a)\n                    | FutureStalled !(P.IVar (FutureResult a))\n\n--------------------------------------------------------------------------------\n-- Implementation\n--------------------------------------------------------------------------------\n\ninstance PC.ParFuture EngFuture ParEng where\n  spawn_ (x::ParEng a) = do\n    curFuel <- fuelLeft\n    let (q,r) = curFuel `quotRem` 2\n        fuel  = q+r\n    fut <- spawnEng fuel x\n    tick fuel\n    return fut\n  get = getE \n--     undefined\n  \n\n-- | Running an engine either completes or returns a new engine with the remaining work.\n--   The returned engine may represent not just one, but many threads suspended.\nrunEng :: Fuel -> ParEng a -> P.Par (EngResult a)\nrunEng fuel (ParEng eng) = do\n  iv  <- P.new\n  res <- P.new\n  let wrapped = do z <- eng;\n                   EngState{parent=OutStanding ivp2,children} <- get\n                   lift$ P.put_ ivp2 (Finished children)\n                   lift$ P.put_ res z;\n                   return ()\n  -- In this case the \'runEng\' itself is a sort of parent to the engine:\n  ((), _finState) <- runStateT wrapped\n                              (EngState fuel fuel (OutStanding iv) [])\n  trace (" ... Done with runStateT, next wait for child checkin..") $ return ()\n  x <- P.get iv\n  trace (" ... Got child checkin..") $ return ()  \n  case x of\n    Finished newchld       -> return (Right (res, newchld))\n    FuelExhausted iv2 chld -> return (Left$ EngStalled iv2 res chld)\n\n-- | Counterpart to `runEng`.  Continue running an engine once it is stalled.\ncontEng :: Fuel -> EngStalled a -> P.Par (EngResult a)\ncontEng newfuel (EngStalled mainchld res allchlds) = do\n  nxt <- P.new\n\n  -- actives <- forM allchlds $ \\ (OutStanding iv) -> do\n  --   chkn <- P.get iv\n  --   case chkn of\n  --     Finished outs          -> return outs\n  --     FuelExhausted ths oths -> return (ths : oths)\n  -- let allActive = concat actives\n\n  let \n      loop [] acc = return acc\n      loop (OutStanding iv : tl) acc = do\n        chkn <- P.get iv\n        case chkn of\n          Finished outs          -> loop (outs ++ tl) acc\n          FuelExhausted ths oths -> loop (oths ++ tl) (ths : acc)\n  activeChlds <- loop allchlds []\n\n  -- TODO: Restart ALL children here.  Fairness and Liveness.\n  -- SIMPLEST POLICY, everyone gets at least ONE tick:\n  let len = length activeChlds\n      (q,r) = newfuel `quotRem` (len + 1)\n      loop2 _  [] = return ()\n      loop2 !ix (hd : tl) = do\n        let fuel = max 1 (q + if ix < r then 1 else 0)\n        P.put_ hd (Restart fuel nxt)\n        loop2 (ix+1) tl\n  loop2 0 activeChlds\n\n  \n  -- TODO: Parallel wakeup?\n  \n  P.put_ mainchld (Restart q nxt)\n  -- allchlds\n  \n  x <- P.get nxt\n  case x of\n   Finished newchld      -> return (Right (res, newchld))\n   FuelExhausted iv chld -> return (Left$ EngStalled iv res chld)\n          \n\n-- | How much fuel is remaining for use by the current thread.\nfuelLeft :: ParEng Fuel\nfuelLeft = ParEng$ fmap curFuel get\n\n-- | Fork a parallel child-engine.\n-- \n-- We don\'t explicitly handle the child computation running out of fuel here, rather,\n-- we are implicitly blocked either when we run out of fuel or when we block on the\n-- IVar-result of the child computation.\n--\n-- Spawning a child engine subtracts that amount of fuel from our own budget.  If the\n-- current fuel level is less than the requested amount, all the remaining fuel is\n-- used, but no exception is thrown.\nspawnEng :: forall a . Fuel -> ParEng a -> ParEng (EngFuture a)\nspawnEng fuel (ParEng eng) = ParEng $ do\n  EngState{curFuel=ours, children} <- get\n  let ours2  = max 0 (ours - fuel)\n      theirs = ours - ours2\n\n  -- TODO!  Tick here to stall out if we are exhausted of fuel!?\n  ans    <- lift P.new\n  rawans <- lift P.new  \n  ret    <- lift P.new\n--  newchildren <- lift P.new\n  lift$ P.fork $ evalStateT (do\n    val <- eng\n    -- At this point the engine has completed successfully... but may have spawned children.\n    -- lift$ P.put_ ans (Right val) -- DANGER!  Multiple PUTS.\n    lift$ P.put_ rawans val\n    EngState{parent=OutStanding ivp, children=chld2} <- get\n    -- TODO/FIXME: write out the CHILDREN to add to the parents outstanding list:\n    -- lift$ P.put_ newchildren children\n    lift$ P.put_ ivp (Finished chld2)\n    return ()\n    ) (EngState theirs theirs (OutStanding ret) [])\n\n  -- Register the new child engine in our state:\n  modify $ \\ st -> st{curFuel=ours2, children= OutStanding ret : children}\n\n\n  -- This thread checks on the \'ret\' ivar and translates its result to a result for\n  -- the \'ans\' IVar (if needed).  The two IVars can\'t be merged mainly because of\n  -- typing issues.  (Without sealing, we can\'t refer to the type var \'a\' in the\n  -- engine state.)\n  lift$ P.fork $ do \n        -- We wait for the child to finish or yield.  Note we are NOT the only thread\n        -- that will be getting this IVar.\n        childWaiting <- P.get ret\n        case childWaiting of\n          FuelExhausted _ _ ->  do \n            -- Here we create a placeholder for the final result.  However we DO NOT\n            -- concern ourselves with restarting the child.  That\'s not our job.\n            iv <- P.new\n            P.put_ ans (FutureStalled iv)\n\n          -- FIXME: What if the child stalls MULTIPLE times?\n          Finished _ -> P.put_ ans (FutureReady rawans)\n        \n  return (EngFuture ans)\n\n-- | Use N units of fuel.  This may cause us to run out and terminate.  The engine\n-- will not, however, go into \\"debt\\".  If the argument to `tick` is greater than\n-- the remaining fuel, the fuel goes to zero.\ntick :: Fuel -> ParEng ()\ntick decr = ParEng $ do\n  st0 <- get\n  let newfl = max 0 (curFuel st0 - decr)\n  put $ st0{curFuel=newfl}\n  when (newfl <= 0) $ \n     unEng yield\n\n-- | Report to the parent computation that we could not continue.  \nyield :: ParEng ()\nyield = ParEng$ do\n  EngState {parent, children} <- get  \n  -- Here we bounce control back to the whomever is running the engine or waiting\n  -- on the result.  We only resume when we are given more fuel.  \n  iv <- lift$ P.new\n  let OutStanding ivp = parent\n  lift$ P.put_ ivp (FuelExhausted iv children)\n  Restart fl iv2 <- lift$ P.get iv\n  -- When we wake up we inject the new fuel, and CLEAR the children.\n  modify $ \\ strec -> strec{curFuel=fl, parent=OutStanding iv2, children=[]}\n\n\n-- | Get the final result of a spawned engine.  Block until the child computation has\n-- either completed or run out of fuel and stalled.\ngetE :: forall a . EngFuture a -> ParEng a\ngetE (EngFuture iv) = ParEng $ do\n  -- If we use a raw P.get here, then we will block without reporting in to our\n  -- parent.  \n  res <- lift$ P.get iv\n  case res of\n    FutureReady ans -> lift$ P.get ans\n    -- What we get back in this case is the rest of the work for the *child*\n    -- computation.  We COULD spend our fuel trying to complete it, before ourselves\n    -- yielding.  But we might be racing with someone else to restart it, so for now\n    -- we just yield ourselves, discarding what remains of our fuel.\n    FutureStalled iv2 -> do unEng yield; unEng$ getE (EngFuture iv2)\n\n--------------------------------------------------------------------------------\n-- Tests:\n\n'