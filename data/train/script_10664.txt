b'module SumEulerPrimes where\n\nimport Data.List\n\nsumPhi n = sum (map phiOpt [1..n])\n\nphiOpt :: Int -> Int\nphiOpt 1 = 0\nphiOpt n = foldl (*) 1  [ (p-1)*p^(k-1)\n                          | (p,k) <- primefactors n ]\n\n-- factorise n to a list of (prime, multiplicity)\nprimefactors :: Int -> [(Int,Int)]\nprimefactors n | n <= 1    = []\n               | otherwise = primeList (primesIn primes n)\n\n-- gather identical primes in the list\nprimeList :: [Int] -> [(Int,Int)]\nprimeList ps = [ (x, length (filter (==x) ps))\n                 | x <- nub ps ]\n\n-- brute-force factorisation, using precomputed prime list\nprimesIn :: [Int] -> Int -> [Int]\nprimesIn [] _ = error "no primes left!"\nprimesIn ps@(p:rest) n | p > n          = []\n                       | n `mod` p == 0 = p:primesIn ps (n `div` p)\n                       | otherwise      = primesIn rest n\n\n-- prime numbers, by sieve of Eratosthenes\nprimes :: [Int]\nprimes = sieve [2..]\nsieve :: [Int] -> [Int]\nsieve [] = []\nsieve (x:xs) = x: (sieve (filter (not . multiple) xs))\n    where multiple y = rem y x == 0\n\n'