b'#r "../docs/fable-core/Fable.Core.dll"\nopen Fable.Core\nopen Fable.Import\nopen Fable.Import.Browser\n\n#load "CompileAndRun.fsx"\n\nlet getById<\'a when \'a :> HTMLElement> s = document.getElementById s :?> \'a\nlet stdinElement = getById<Browser.HTMLTextAreaElement>("stdinData")\nlet consoleElement = getById<Browser.HTMLTextAreaElement>("consoleContainer")\nlet compileConsole = getById<Browser.HTMLButtonElement>("compileAndRunButton")\nlet compileSpreadsheet = getById<Browser.HTMLButtonElement>("compileToSpreadsheetButton")\nlet spreadsheetCell = getById<Browser.HTMLTableDataCellElement>\nlet samplesPanel = getById<Browser.HTMLDivElement>("samples")\nlet spreadsheetPanel = getById<Browser.HTMLDivElement>("ExcelSheet")\n\n// make a function which will extract tokens from the stdinData element in order\nlet makeTokenGenerator() =\n  let stdinData = stdinElement.value\n  let tokenStream = stdinData.Split \' \' |> List.ofArray |> ref\n  let popStream() =\n    try List.head !tokenStream\n    finally tokenStream := List.tail !tokenStream\n  function\n    |"%i" ->\n      tokenStream := Seq.skipWhile (System.Int32.TryParse >> fst >> not) !tokenStream |> List.ofSeq\n      popStream()\n    |"%s" -> popStream()\n    |_ -> failwith "unrecognized or unsupported input format string"\n\nlet printToConsole s = \n  consoleElement.value <- consoleElement.value + s\ncompileConsole.onclick <- fun _ ->\n  consoleElement.value <- "> Excel_VM code.c\\n> code\\n"\n  getById<Browser.HTMLTextAreaElement>("codeContainer").value  // get input code\n   |> CompileAndRun.compileAndRun (fun _ _ _ -> ()) (makeTokenGenerator()) printToConsole  // compile and run\n  System.Object()\n  \nlet printToSheet s =\n  spreadsheetCell("B2").textContent <- spreadsheetCell("B2").textContent + s\nlet updateSheet (stacks:System.Collections.Generic.IDictionary<string, string list ref>) (heap:System.Collections.Generic.List<string>) (cmd:PseudoASM.Definition.PseudoASM) =\n  // stdin\n  spreadsheetCell("A2").textContent <- stdinElement.value\n  // instruction pointer\n  let instr = List.head !stacks.["A"]\n  spreadsheetCell("A3").textContent <- string ((int instr - 1) * 2)\n  spreadsheetCell("A4").textContent <- string (int instr * 2)\n  let cmdname, arg = cmd.CommandInfo.StringPair\n  spreadsheetCell("A5").textContent <- cmdname\n  spreadsheetCell("A6").textContent <- arg\n  // stack\n  spreadsheetCell("C3").textContent <- match !stacks.["B"] with x::_ -> x | [] -> ""\n  spreadsheetCell("C4").textContent <- string (List.length !stacks.["B"] + 1)\n  List.iteri (fun i e ->\n    if 5 + i < 20 then\n      spreadsheetCell("C" + string (5 + i)).textContent <- e\n   ) !stacks.["B"]\n  // heap\n  spreadsheetCell("B3").textContent <- if heap.Count = 0 then "" else heap.[heap.Count - 1]\n  spreadsheetCell("B4").textContent <- string (heap.Count + 1)\n  Seq.iteri (fun i e ->\n    if 5 + i < 20 then\n      spreadsheetCell("B" + string (5 + i)).textContent <- e\n   ) heap\n  // delay\n  let rec delay = function 0 -> () | n -> delay (n - 1)\n  delay 0\ncompileSpreadsheet.onclick <- fun _ ->\n  // disable samples panel, display spreadsheet panel\n  samplesPanel.style.display <- "none"\n  spreadsheetPanel.style.display <- "block"\n  // wipe spreadsheet\n  for e in 1..19 do\n    spreadsheetCell("A" + string e).textContent <- ""\n    spreadsheetCell("B" + string e).textContent <- ""\n    spreadsheetCell("C" + string e).textContent <- ""\n  spreadsheetCell("B2").textContent <- "stdout:\\n"\n  consoleElement.value <- "> Excel_VM code.c -outputExcelFile\\n"\n  getById<Browser.HTMLTextAreaElement>("codeContainer").value\n   |> CompileAndRun.compileAndRun updateSheet (makeTokenGenerator()) printToSheet\n  System.Object()'