b'--\n-- testing program for attoparsec and sax hoodle parser\n--\n\nimport Control.Monad (when)\nimport Data.Attoparsec.ByteString (parse)\nimport Data.Attoparsec.Types (IResult (Done))\nimport qualified Data.ByteString as B\nimport Data.Hoodle.Simple\n  ( Dimension (..),\n    Hoodle (..),\n    Page (..),\n  )\nimport Graphics.Hoodle.Render (renderPage)\nimport Graphics.Rendering.Cairo\n  ( renderWith,\n    showPage,\n    withPDFSurface,\n  )\nimport System.Environment (getArgs)\nimport Text.Hoodle.Parse.Attoparsec (hoodle)\n\n-- |\nmain :: IO ()\nmain = do\n  args <- getArgs\n  when (length args /= 3) $ error "parsertest mode filename (mode = atto/sax) outputfile"\n  when (head args == "atto") $\n    attoparsec (args !! 1) (args !! 2)\n\n-- | using attoparsec without any built-in xml support\nattoparsec :: FilePath -> FilePath -> IO ()\nattoparsec fp ofp = do\n  bstr <- B.readFile fp\n  let r = parse hoodle bstr\n  case r of\n    Done _ h -> renderjob h ofp --  print (length (hoodle_pages h))\n    _ -> print r\n\n-- |\nrenderjob :: Hoodle -> FilePath -> IO ()\nrenderjob h ofp = do\n  let p = head (hoodle_pages h)\n  let Dim width height = page_dim p\n  withPDFSurface ofp width height $ \\s ->\n    renderWith s $\n      (sequence1_ showPage . map renderPage . hoodle_pages) h\n\n-- | interleaving a monadic action between each pair of subsequent actions\nsequence1_ :: (Monad m) => m () -> [m ()] -> m ()\nsequence1_ _ [] = return ()\nsequence1_ _ [a] = a\nsequence1_ i (a : as) = a >> i >> sequence1_ i as\n\n{-\n-- | using sax (from xml-conduit)\nsax :: FilePath -> IO ()\nsax fp = do\n  r <- parseHoodleFile fp\n  case r of\n    Left err -> print err\n    Right h -> print (length (hoodle_pages h))\n-}\n'