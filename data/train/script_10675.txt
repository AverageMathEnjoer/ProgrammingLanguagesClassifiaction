b'{-# LANGUAGE DuplicateRecordFields #-}\n\nmodule Network.OIDC.WellKnown where\n\nimport Control.Monad.Except\nimport Control.Monad.IO.Class\nimport Data.Aeson\nimport Data.Bifunctor\nimport Data.ByteString.Lazy (ByteString)\nimport Data.ByteString.Lazy qualified as BSL\nimport Data.Text.Lazy (Text)\nimport Data.Text.Lazy qualified as TL\nimport Data.Text.Lazy.Encoding qualified as TL\nimport GHC.Generics\nimport Network.HTTP.Simple\nimport Network.HTTP.Types.Status\nimport URI.ByteString\n\n-- | Slim OpenID Configuration\n-- TODO: could add more fields to be complete.\ndata OpenIDConfiguration = OpenIDConfiguration\n  { issuer :: Text\n  , authorizationEndpoint :: Text\n  , tokenEndpoint :: Text\n  , userinfoEndpoint :: Text\n  , jwksUri :: Text\n  }\n  deriving (Generic)\n\ndata OpenIDConfigurationUris = OpenIDConfigurationUris\n  { authorizationUri :: URI\n  , tokenUri :: URI\n  , userinfoUri :: URI\n  , jwksUri :: URI\n  }\n  deriving (Generic)\n\ninstance FromJSON OpenIDConfiguration where\n  parseJSON = genericParseJSON defaultOptions {fieldLabelModifier = camelTo2 \'_\'}\n\nwellknownUrl :: TL.Text\nwellknownUrl = "/.well-known/openid-configuration"\n\nfetchWellKnown ::\n  MonadIO m =>\n  -- | Domain\n  TL.Text ->\n  ExceptT Text m OpenIDConfiguration\nfetchWellKnown domain = ExceptT $ do\n  let uri = "https://" <> domain <> wellknownUrl\n  req <- liftIO $ parseRequest (TL.unpack uri)\n  resp <- httpLbs req\n  return (handleWellKnownResponse resp)\n\nfetchWellKnownUris :: MonadIO m => TL.Text -> ExceptT Text m OpenIDConfigurationUris\nfetchWellKnownUris domain = do\n  OpenIDConfiguration {..} <- fetchWellKnown domain\n  withExceptT (TL.pack . show) $ do\n    ae <- ExceptT $ pure (parseURI strictURIParserOptions $ BSL.toStrict $ TL.encodeUtf8 authorizationEndpoint)\n    te <- ExceptT $ pure (parseURI strictURIParserOptions $ BSL.toStrict $ TL.encodeUtf8 tokenEndpoint)\n    ue <- ExceptT $ pure (parseURI strictURIParserOptions $ BSL.toStrict $ TL.encodeUtf8 userinfoEndpoint)\n    jwks <- ExceptT $ pure (parseURI strictURIParserOptions $ BSL.toStrict $ TL.encodeUtf8 jwksUri)\n    pure\n      OpenIDConfigurationUris\n        { authorizationUri = ae\n        , tokenUri = te\n        , userinfoUri = ue\n        , jwksUri = jwks\n        }\n\nhandleWellKnownResponse :: Response ByteString -> Either Text OpenIDConfiguration\nhandleWellKnownResponse resp = do\n  let rawBody = getResponseBody resp\n  let rStatus = getResponseStatus resp\n  if rStatus == status200\n    then first (("handleWellKnownResponse decode response failed: " <>) . TL.pack) (eitherDecode rawBody)\n    else Left $ "handleWellKnownResponse failed: " <> TL.pack (show rStatus) <> TL.decodeUtf8 rawBody\n'