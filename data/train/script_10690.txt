b'using System;\nusing System.Diagnostics;\nusing System.Text;\n\nusing Bitmask = System.UInt64;\nusing u8 = System.Byte;\nusing u16 = System.UInt16;\nusing u32 = System.UInt32;\n\nnamespace CS_SQLite3\n{\n  using sqlite3_int64 = System.Int64;\n  using MemJournal = CSSQLite.sqlite3_file;\n\n  public partial class CSSQLite\n  {\n    /*\n    ** 2007 August 22\n    **\n    ** The author disclaims copyright to this source code.  In place of\n    ** a legal notice, here is a blessing:\n    **\n    **    May you do good and not evil.\n    **    May you find forgiveness for yourself and forgive others.\n    **    May you share freely, never taking more than you give.\n    **\n    *************************************************************************\n    **\n    ** This file contains code use to implement an in-memory rollback journal.\n    ** The in-memory rollback journal is used to journal transactions for\n    ** ":memory:" databases and when the journal_mode=MEMORY pragma is used.\n    **\n    ** @(#) $Id: memjournal.c,v 1.12 2009/05/04 11:42:30 danielk1977 Exp $\n    **\n    *************************************************************************\n    **  Included in SQLite3 port to C#-SQLite;  2008 Noah B Hart\n    **  C#-SQLite is an independent reimplementation of the SQLite software library\n    **\n    **  $Header$\n    *************************************************************************\n    */\n\n    //#include "sqliteInt.h"\n\n    /* Forward references to internal structures */\n    //typedef struct MemJournal MemJournal;\n    //typedef struct FilePoint FilePoint;\n    //typedef struct FileChunk FileChunk;\n\n    /* Space to hold the rollback journal is allocated in increments of\n    ** this many bytes.\n    **\n    ** The size chosen is a little less than a power of two.  That way,\n    ** the FileChunk object will have a size that almost exactly fills\n    ** a power-of-two allocation.  This mimimizes wasted space in power-of-two\n    ** memory allocators.\n    */\n    //#define JOURNAL_CHUNKSIZE ((int)(1024-sizeof(FileChunk*)))\n    const int JOURNAL_CHUNKSIZE = 4096;\n\n    /* Macro to find the minimum of two numeric values.\n    */\n    //#if ! MIN\n    //# define MIN(x,y) ((x)<(y)?(x):(y))\n    //#endif\n    static int MIN( int x, int y ) { return ( x < y ) ? x : y; }\n    static int MIN( int x, u32 y ) { return ( x < y ) ? x : (int)y; }\n\n    /*\n    ** The rollback journal is composed of a linked list of these structures.\n    */\n    public class FileChunk\n    {\n      public FileChunk pNext;                             /* Next chunk in the journal */\n      public byte[] zChunk = new byte[JOURNAL_CHUNKSIZE]; /* Content of this chunk */\n    };\n\n    /*\n    ** An instance of this object serves as a cursor into the rollback journal.\n    ** The cursor can be either for reading or writing.\n    */\n    public class FilePoint\n    {\n      public int iOffset;           /* Offset from the beginning of the file */\n      public FileChunk pChunk;      /* Specific chunk into which cursor points */\n    };\n\n    /*\n    ** This subclass is a subclass of sqlite3_file.  Each open memory-journal\n    ** is an instance of this class.\n    */\n    public partial class sqlite3_file\n    {\n      //public sqlite3_io_methods pMethods; /* Parent class. MUST BE FIRST */\n      public FileChunk pFirst;              /* Head of in-memory chunk-list */\n      public FilePoint endpoint;            /* Pointer to the end of the file */\n      public FilePoint readpoint;           /* Pointer to the end of the last xRead() */\n    };\n\n    /*\n    ** Read data from the in-memory journal file.  This is the implementation\n    ** of the sqlite3_vfs.xRead method.\n    */\n    static int memjrnlRead(\n    sqlite3_file pJfd,     /* The journal file from which to read */\n    byte[] zBuf,           /* Put the results here */\n    int iAmt,              /* Number of bytes to read */\n    sqlite3_int64 iOfst    /* Begin reading at this offset */\n    )\n    {\n      MemJournal p = (MemJournal)pJfd;\n      byte[] zOut = zBuf;\n      int nRead = iAmt;\n      int iChunkOffset;\n      FileChunk pChunk;\n\n      /* SQLite never tries to read past the end of a rollback journal file */\n      Debug.Assert( iOfst + iAmt <= p.endpoint.iOffset );\n\n      if ( p.readpoint.iOffset != iOfst || iOfst == 0 )\n      {\n        int iOff = 0;\n        for ( pChunk = p.pFirst ;\n        ALWAYS( pChunk != null ) && ( iOff + JOURNAL_CHUNKSIZE ) <= iOfst ;\n        pChunk = pChunk.pNext\n        )\n        {\n          iOff += JOURNAL_CHUNKSIZE;\n        }\n      }\n      else\n      {\n        pChunk = p.readpoint.pChunk;\n      }\n\n      iChunkOffset = (int)( iOfst % JOURNAL_CHUNKSIZE );\n      int izOut = 0;\n      do\n      {\n        int iSpace = JOURNAL_CHUNKSIZE - iChunkOffset;\n        int nCopy = MIN( nRead, ( JOURNAL_CHUNKSIZE - iChunkOffset ) );\n        Buffer.BlockCopy( pChunk.zChunk, iChunkOffset, zOut, izOut, nCopy ); //memcpy( zOut, pChunk.zChunk[iChunkOffset], nCopy );\n        izOut += nCopy;// zOut += nCopy;\n        nRead -= iSpace;\n        iChunkOffset = 0;\n      } while ( nRead >= 0 && ( pChunk = pChunk.pNext ) != null && nRead > 0 );\n      p.readpoint.iOffset = (int)( iOfst + iAmt );\n      p.readpoint.pChunk = pChunk;\n\n      return SQLITE_OK;\n    }\n\n    /*\n    ** Write data to the file.\n    */\n    static int memjrnlWrite(\n    sqlite3_file pJfd,    /* The journal file into which to write */\n    byte[] zBuf,          /* Take data to be written from here */\n    int iAmt,             /* Number of bytes to write */\n    sqlite3_int64 iOfst   /* Begin writing at this offset into the file */\n    )\n    {\n      MemJournal p = (MemJournal)pJfd;\n      int nWrite = iAmt;\n      byte[] zWrite = zBuf;\n      int izWrite = 0;\n\n      /* An in-memory journal file should only ever be appended to. Random\n      ** access writes are not required by sqlite.\n      */\n      Debug.Assert( iOfst == p.endpoint.iOffset );\n      UNUSED_PARAMETER( iOfst );\n\n      while ( nWrite > 0 )\n      {\n        FileChunk pChunk = p.endpoint.pChunk;\n        int iChunkOffset = (int)( p.endpoint.iOffset % JOURNAL_CHUNKSIZE );\n        int iSpace = MIN( nWrite, JOURNAL_CHUNKSIZE - iChunkOffset );\n\n        if ( iChunkOffset == 0 )\n        {\n          /* New chunk is required to extend the file. */\n          FileChunk pNew = new FileChunk();// sqlite3_malloc( sizeof( FileChunk ) );\n          if ( null == pNew )\n          {\n            return SQLITE_IOERR_NOMEM;\n          }\n          pNew.pNext = null;\n          if ( pChunk != null )\n          {\n            Debug.Assert( p.pFirst != null );\n            pChunk.pNext = pNew;\n          }\n          else\n          {\n            Debug.Assert( null == p.pFirst );\n            p.pFirst = pNew;\n          }\n          p.endpoint.pChunk = pNew;\n        }\n\n        Buffer.BlockCopy( zWrite, izWrite, p.endpoint.pChunk.zChunk, iChunkOffset, iSpace ); //memcpy( &p.endpoint.pChunk.zChunk[iChunkOffset], zWrite, iSpace );\n        izWrite += iSpace;//zWrite += iSpace;\n        nWrite -= iSpace;\n        p.endpoint.iOffset += iSpace;\n      }\n\n      return SQLITE_OK;\n    }\n\n    /*\n    ** Truncate the file.\n    */\n    static int memjrnlTruncate( sqlite3_file pJfd, sqlite3_int64 size )\n    {\n      MemJournal p = (MemJournal)pJfd;\n      FileChunk pChunk;\n      Debug.Assert( size == 0 );\n      UNUSED_PARAMETER( size );\n      pChunk = p.pFirst;\n      while ( pChunk != null )\n      {\n        FileChunk pTmp = pChunk;\n        pChunk = pChunk.pNext;\n        //sqlite3_free( ref pTmp );\n      }\n      sqlite3MemJournalOpen( pJfd );\n      return SQLITE_OK;\n    }\n\n    /*\n    ** Close the file.\n    */\n    static int memjrnlClose( MemJournal pJfd )\n    {\n      memjrnlTruncate( pJfd, 0 );\n      return SQLITE_OK;\n    }\n\n\n    /*\n    ** Sync the file.\n    **\n    ** Syncing an in-memory journal is a no-op.  And, in fact, this routine\n    ** is never called in a working implementation.  This implementation\n    ** exists purely as a contingency, in case some malfunction in some other\n    ** part of SQLite causes Sync to be called by mistake.\n    */\n    static int memjrnlSync( sqlite3_file NotUsed, int NotUsed2 )\n    {   /*NO_TEST*/\n      UNUSED_PARAMETER2( NotUsed, NotUsed2 );                      /*NO_TEST*/\n      Debug.Assert( false );                                       /*NO_TEST*/\n      return SQLITE_OK;                                            /*NO_TEST*/\n    }                                                              /*NO_TEST*/\n\n    /*\n    ** Query the size of the file in bytes.\n    */\n    static int memjrnlFileSize( sqlite3_file pJfd, ref int pSize )\n    {\n      MemJournal p = (MemJournal)pJfd;\n      pSize = p.endpoint.iOffset;\n      return SQLITE_OK;\n    }\n\n    /*\n    ** Table of methods for MemJournal sqlite3_file object.\n    */\n    static sqlite3_io_methods MemJournalMethods = new sqlite3_io_methods(\n    1,                /* iVersion */\n    (dxClose)memjrnlClose,       /* xClose */\n    (dxRead)memjrnlRead,         /* xRead */\n    (dxWrite)memjrnlWrite,       /* xWrite */\n    (dxTruncate)memjrnlTruncate, /* xTruncate */\n    (dxSync)memjrnlSync,         /* xSync */\n    (dxFileSize)memjrnlFileSize, /* xFileSize */\n    null,                        /* xLock */\n    null,                        /* xUnlock */\n    null,                        /* xCheckReservedLock */\n    null,                        /* xFileControl */\n    null,                        /* xSectorSize */\n    null                         /* xDeviceCharacteristics */\n    );\n\n    /*\n    ** Open a journal file.\n    */\n    static void sqlite3MemJournalOpen( sqlite3_file pJfd )\n    {\n      MemJournal p = (MemJournal)pJfd;\n      //memset( p, 0, sqlite3MemJournalSize() );\n      p.pFirst = null;\n      p.endpoint = new FilePoint();\n      p.readpoint = new FilePoint();\n      p.pMethods = MemJournalMethods;\n    }\n\n    /*\n    ** Return true if the file-handle passed as an argument is\n    ** an in-memory journal\n    */\n    static bool sqlite3IsMemJournal( sqlite3_file pJfd )\n    {\n      return pJfd.pMethods == MemJournalMethods;\n    }\n\n    /*\n    ** Return the number of bytes required to store a MemJournal that uses vfs\n    ** pVfs to create the underlying on-disk files.\n    */\n    static int sqlite3MemJournalSize()\n    {\n      return 3096; // sizeof( MemJournal );\n    }\n  }\n}\n'