b'{-# LANGUAGE BangPatterns, CPP #-}\n{-# LANGUAGE ConstraintKinds #-}\n\nimport Control.Monad\nimport Control.DeepSeq\nimport Control.Exception\nimport Data.Complex\nimport System.Environment\nimport System.IO\n#ifdef ALIST\nimport Control.Monad.Par.AList as A\n#endif\n\n#ifdef PARSCHED \nimport PARSCHED\n#else\nimport Control.Monad.Par\n#endif\n\nimport qualified Data.Vector.Unboxed as V\n\n#ifdef WRITE_IMAGE\nimport Codec.Picture  -- JuicyPixels\nimport qualified Data.Vector.Storable as V\n#endif\n\n#ifdef NEW_GENERIC\nimport qualified Data.Par as C\nimport qualified Data.Par.Range as C\nimport Control.Par.Class\nparMapReduceRangeThresh :: (NFData a, ParFuture p, FutContents p a)\n                        => Int -> C.InclusiveRange -> (Int -> p a) -> (a -> a -> p a) -> a -> p a\nparMapReduceRangeThresh = C.parMapReduceThresh\n#else\nimport Control.Monad.Par.Combinator as C\n#endif\n\n\nmandel :: Int -> Complex Double -> Int\nmandel max_depth c = loop 0 0\n  where   \n   fn = magnitude\n   loop i !z\n    | i == max_depth = i\n    | fn(z) >= 2.0   = i\n    | otherwise      = loop (i+1) (z*z + c)\n\n\nthreshold = 1\n\n\ndata VecTree = Leaf (V.Vector Int)\n\t     | MkNode VecTree VecTree\n  deriving (Eq,Show)\n\n#if 0\ninstance V.Unbox a => NFData (V.Vector a) where\n  rnf v = rnf (V.length v)\n#endif\n\ninstance NFData VecTree where\n  rnf (Leaf v) = rnf v\n  rnf (MkNode v1 v2) = rnf v1 `seq` rnf v2\n\nleftmost (Leaf v)     = v\nleftmost (MkNode l _) = leftmost l\n\n#ifdef ALIST\nrunMandel :: Double -> Double -> Double -> Double -> Int -> Int -> Int -> Par (AList [Int])\nrunMandel minX minY maxX maxY winX winY max_depth = do\n  -- This version does a ROW at a time in parallel:\n  A.parBuildThreshM threshold (C.InclusiveRange 0 (winY-1)) $ \\y -> \n       do let l = [ mandelStep y x | x <- [0.. winX-1] ]\n          deepseq l (return l)\n\n#else\n-- RRN: Comment to handle LVish types too:\n-- runMandel :: Double -> Double -> Double -> Double -> Int -> Int -> Int -> Par VecTree\nrunMandel minX minY maxX maxY winX winY max_depth = do\n  -- Auto-partitioning version.  A bit worse:\n  -- C.parMapReduceRange (C.InclusiveRange 0 (winY-1)) \n  parMapReduceRangeThresh threshold (C.InclusiveRange 0 (winY-1)) \n     (\\y -> \n       do\n          let vec = V.generate winX (\\x -> mandelStep y x)\n          seq (vec V.! 0) $ \n           return (Leaf vec))\n     (\\ a b -> return$ MkNode a b)\n     (Leaf V.empty)\n#endif\n  where\n    mandelStep i j = mandel max_depth z\n        where z = ((fromIntegral j * r_scale) / fromIntegral winY + minY) :+\n                  ((fromIntegral i * c_scale) / fromIntegral winX + minX)\n    r_scale  =  maxY - minY  :: Double\n    c_scale =   maxX - minX  :: Double\n\n\n#ifdef WRITE_IMAGE\n-- makeImage :: Integer -> Integer -> Int -> A.AList [Int] -> Image PixelRGB8 \nmakeImage :: Int -> Int -> Int -> A.AList [Int] -> Image PixelRGB8 \nmakeImage x y depth ls =\n  -- This is a quite silly series of intermediate structures:\n  Image x y (V.fromList $ concat $ \n\t     Prelude.map prettyRGB $\n\t     concat$ A.toList ls)\n where \n   prettyRGB s = \n      let t = (fromIntegral (depth - s)) in \n--      PixelRGB8 (fromIntegral s) t t \n      [fromIntegral s, t, t]\n#endif\n\nsimple x y depth = runMandel (-2) (-2) 2 2 x y depth\n\n\n--------------------------------------------------------------------------------\n\n#ifdef ALIST\n-- A meaningless checksum.  This match the C++ CnC benchmark:\nmandelCheck :: AList [Int] -> Int -> Int -> Int\nmandelCheck als max_col max_depth = loop 0 als 0\n where \n -- Sum positions of the pixels that are equal to max_depth:\n loop i als !sum | A.null als = sum\n loop i als !sum = loop (i+1) (A.tail als)\n\t\t        (loop2 i 0 (A.head als) sum)\n loop2 i j []    !sum = sum\n loop2 i j (h:t) !sum | h == max_depth = loop2 i (j+1) t (sum + i*max_col + j)\n\t\t      | otherwise      = loop2 i (j+1) t  sum\n#endif\n\n -- This kind of checksum is much simpler:\ncheckSum :: VecTree -> Int\ncheckSum (Leaf vec) = V.foldl (+) 0 vec\ncheckSum (MkNode v1 v2) = checkSum v1 + checkSum v2  \n\n\nmain = do args <- getArgs\n\n          let (x,y,depth) = \n\t\tcase args of\n\t\t [] -> \n    --                 runPar $ simple 3 3 3\n                       -- Defaults recommended by Simon Marlow\n\t\t       -- (1024,1024,256)\n                       -- Note, this should do something very *quick* when called with no args:\n                       (3,3,3)\n\n\t\t [x,y,depth] -> \n    --\t\t   simple (read x) (read y) (read depth)\n\t\t       (read x, read y, read depth)\n\n\t\t -- [minX,minY,maxX,maxY,winX,winY,depth] ->\n\t\t --    runPar $ \n\t\t -- \t    runMandel (read minX) (read minY)\n\t\t -- \t\t      (read maxX) (read maxY)\n\t\t -- \t\t      (read winX) (read winY) (read depth)\n\n          let pixels = runPar$ simple x y depth\n\n          putStrLn$ "About to poke pixels to launch runPar:"\n          evaluate pixels\n          putStrLn$ "Should be done with runpar at this point."\n\n#ifdef WRITE_IMAGE\n\t  writePng "mandel_image.png" (makeImage (fromIntegral x) (fromIntegral y) depth pixels)\n\t  putStrLn$ "File written."\n          putStrLn$ "Checksum " ++ show (checkSumpixels y depth)\n#endif\n          putStrLn$ "Spot check, length of leftmost leaf: " ++ show (V.length (leftmost pixels))\n          return ()\n\n\n{-\n\n[2012.03.08] {Updated to use Vector}\n\nLooks like this was out of date in that it was still using AList.\nAList has never performed well enough, and sure enough, this test was\nfalling to ~50% productivity at >16 threads.\n\nHowever, simply replacing AList with vector is no good (14.4s for 512\n512 2048 as opposed to 15.5).  It is of course a quadratic copy at\nthat point.\n\n\n-}\n'