b'{-# OPTIONS_GHC -fno-warn-unticked-promoted-constructors#-}\n{-# LANGUAGE UndecidableInstances #-}\n{-# LANGUAGE CPP #-}\n\nmodule Database.Beam.Query.Internal where\n\nimport           Database.Beam.Backend.Types\nimport           Database.Beam.Backend.SQL\nimport           Database.Beam.Schema.Tables\n\nimport qualified Data.DList as DList\nimport           Data.Functor.Const\nimport           Data.String\nimport qualified Data.Text as T\nimport           Data.Typeable\nimport           Data.Vector.Sized (Vector)\nimport qualified Data.Vector.Sized as VS\n#if !MIN_VERSION_base(4, 11, 0)\nimport           Data.Semigroup\n#endif\n\nimport           Control.Monad.Free.Church\nimport           Control.Monad.State\nimport           Control.Monad.Writer\n\nimport           GHC.TypeLits\nimport           GHC.Types\n\nimport           Unsafe.Coerce\n\ntype ProjectibleInBackend be a =\n  ( Projectible be a\n  , ProjectibleValue be a )\n\ntype TablePrefix = T.Text\n\ndata QF be (db :: (Type -> Type) -> Type) s next where\n  QDistinct :: Projectible be r\n            => (r -> WithExprContext (BeamSqlBackendSetQuantifierSyntax be))\n            -> QM be db s r -> (r -> next) -> QF be db s next\n\n  QAll :: Projectible be r\n       => (TablePrefix -> T.Text -> BeamSqlBackendFromSyntax be)\n       -> (T.Text -> r)\n       -> (r -> Maybe (WithExprContext (BeamSqlBackendExpressionSyntax be)))\n       -> ((T.Text, r) -> next) -> QF be db s next\n\n  QArbitraryJoin :: Projectible be r\n                 => QM be db (QNested s) r\n                 -> T.Text -- Table namespace\n                 -> (BeamSqlBackendFromSyntax be -> BeamSqlBackendFromSyntax be ->\n                     Maybe (BeamSqlBackendExpressionSyntax be) ->\n                     BeamSqlBackendFromSyntax be)\n                 -> (r -> Maybe (WithExprContext (BeamSqlBackendExpressionSyntax be)))\n                 -> (r -> next)\n                 -> QF be db s next\n  QTwoWayJoin :: ( Projectible be a\n                 , Projectible be b )\n              => QM be db (QNested s) a\n              -> QM be db (QNested s) b\n              -> (BeamSqlBackendFromSyntax be -> BeamSqlBackendFromSyntax be ->\n                  Maybe (BeamSqlBackendExpressionSyntax be) ->\n                  BeamSqlBackendFromSyntax be)\n              -> ((a, b) -> Maybe (WithExprContext (BeamSqlBackendExpressionSyntax be)))\n              -> ((a, b) -> next)\n              -> QF be db s next\n\n  QSubSelect :: Projectible be r\n             => QM be db (QNested s) r -> (r -> next)\n             -> QF be db s next\n\n  QGuard :: WithExprContext (BeamSqlBackendExpressionSyntax be) -> next -> QF be db s next\n\n  QLimit  :: Projectible be r => Integer -> QM be db (QNested s) r -> (r -> next) -> QF be db s next\n  QOffset :: Projectible be r => Integer -> QM be db (QNested s) r -> (r -> next) -> QF be db s next\n\n  QSetOp :: Projectible be r\n         => (BeamSqlBackendSelectTableSyntax be -> BeamSqlBackendSelectTableSyntax be -> BeamSqlBackendSelectTableSyntax be)\n         -> QM be db (QNested s) r\n         -> QM be db (QNested s) r -> (r -> next)\n         -> QF be db s next\n\n  QOrderBy :: Projectible be r\n           => (r -> WithExprContext [ BeamSqlBackendOrderingSyntax be ])\n           -> QM be db (QNested s) r -> (r -> next) -> QF be db s next\n\n  QWindowOver :: ( ProjectibleWithPredicate WindowFrameContext be (WithExprContext (BeamSqlBackendWindowFrameSyntax\' be)) window\n                 , Projectible be r\n                 , Projectible be a )\n              => (r -> window) -> (r -> window -> a)\n              -> QM be db (QNested s) r -> (a -> next) -> QF be db s next\n\n  QAggregate :: ( Projectible be grouping\n                , Projectible be a )\n             => (a -> TablePrefix -> (Maybe (BeamSqlBackendGroupingSyntax be), grouping))\n             -> QM be db (QNested s) a\n             -> (grouping -> next)\n             -> QF be db s next\n\n  -- Force the building of a select statement, using the given builder\n  QForceSelect :: Projectible be r\n               => (r -> BeamSqlBackendSelectTableSyntax be -> [ BeamSqlBackendOrderingSyntax be ] ->\n                   Maybe Integer -> Maybe Integer -> BeamSqlBackendSelectSyntax be)\n               -> QM be db (QNested s) r\n               -> (r -> next)\n               -> QF be db s next\n\nderiving instance Functor (QF be db s)\n\ntype QM be db s = F (QF be db s)\n\n-- | The type of queries over the database `db` returning results of type `a`.\n-- The `s` argument is a threading argument meant to restrict cross-usage of\n-- `QExpr`s. \'syntax\' represents the SQL syntax that this query is building.\nnewtype Q be (db :: (Type -> Type) -> Type) s a\n  = Q { runQ :: QM be db s a }\n    deriving (Monad, Applicative, Functor)\n\ndata QInternal\ndata QNested s\n\ndata QField s ty\n  = QField\n  { qFieldShouldQualify :: !Bool\n  , qFieldTblName       :: !T.Text\n  , qFieldName          :: !T.Text }\n  deriving (Show, Eq, Ord)\n\nnewtype QAssignment be s\n  = QAssignment { unQAssignment :: [(BeamSqlBackendFieldNameSyntax be, BeamSqlBackendExpressionSyntax be)] }\n  deriving (Monoid, Semigroup)\n\nnewtype QFieldAssignment be tbl a\n  = QFieldAssignment (forall s. tbl (QExpr be s) -> Maybe (QExpr be s a))\n\n-- * QGenExpr type\n\ndata QAggregateContext\ndata QGroupingContext\ndata QValueContext\ndata QWindowingContext\ndata QWindowFrameContext\n\n-- | The type of lifted beam expressions that will yield the haskell type \'t\'.\n--\n--   \'context\' is a type-level representation of the types of expressions this\n--   can contain. For example, \'QAggregateContext\' represents expressions that\n--   may contain aggregates, and \'QWindowingContext\' represents expressions that\n--   may contain @OVER@.\n--\n--   \'syntax\' is the expression syntax being built (usually a type that\n--   implements \'IsSql92ExpressionSyntax\' at least, but not always).\n--\n--   \'s\' is a state threading parameter that prevents \'QExpr\'s from incompatible\n--   sources to be combined. For example, this is used to prevent monadic joins\n--   from depending on the result of previous joins (so-called @LATERAL@ joins).\nnewtype QGenExpr context be s t = QExpr (TablePrefix -> BeamSqlBackendExpressionSyntax be)\nnewtype QOrd be s t = QOrd (TablePrefix -> BeamSqlBackendOrderingSyntax be)\n\ntype WithExprContext a = TablePrefix -> a\n\n-- | \'QExpr\'s represent expressions not containing aggregates.\ntype QExpr = QGenExpr QValueContext\ntype QAgg = QGenExpr QAggregateContext\ntype QWindowExpr = QGenExpr QWindowingContext\ntype QGroupExpr = QGenExpr QGroupingContext\n--deriving instance Show syntax => Show (QGenExpr context syntax s t)\ninstance BeamSqlBackend be => Eq (QGenExpr context be s t) where\n  QExpr a == QExpr b = a "" == b ""\n\ninstance Retaggable (QGenExpr ctxt expr s) (QGenExpr ctxt expr s t) where\n  type Retag tag (QGenExpr ctxt expr s t) = Columnar (tag (QGenExpr ctxt expr s)) t\n  retag f e = case f (Columnar\' e) of\n                Columnar\' a -> a\n\nnewtype QWindow be s = QWindow (WithExprContext (BeamSqlBackendWindowFrameSyntax be))\nnewtype QFrameBounds be = QFrameBounds (Maybe (BeamSqlBackendWindowFrameBoundsSyntax be))\nnewtype QFrameBound be = QFrameBound (BeamSqlBackendWindowFrameBoundSyntax be)\n\nqBinOpE :: BeamSqlBackend be\n        => (BeamSqlBackendExpressionSyntax be ->\n            BeamSqlBackendExpressionSyntax be ->\n            BeamSqlBackendExpressionSyntax be)\n        -> QGenExpr context be s a -> QGenExpr context be s b\n        -> QGenExpr context be s c\nqBinOpE mkOpE (QExpr a) (QExpr b) = QExpr (mkOpE <$> a <*> b)\n\nunsafeRetype :: QGenExpr ctxt be s a -> QGenExpr ctxt be s a\'\nunsafeRetype (QExpr v) = QExpr v\n\ninstance ( BeamSqlBackend backend, BeamSqlBackendCanSerialize backend [Char] ) =>\n    IsString (QGenExpr context backend s T.Text) where\n    fromString = QExpr . pure . valueE . sqlValueSyntax\ninstance ( Num a, BeamSqlBackend be, BeamSqlBackendCanSerialize be a ) =>\n    Num (QGenExpr context be s a) where\n    fromInteger x = let res :: QGenExpr context be s a\n                        res = QExpr (pure (valueE (sqlValueSyntax (fromIntegral x :: a))))\n                    in res\n    QExpr a + QExpr b = QExpr (addE <$> a <*> b)\n    QExpr a - QExpr b = QExpr (subE <$> a <*> b)\n    QExpr a * QExpr b = QExpr (mulE <$> a <*> b)\n    negate (QExpr a) = QExpr (negateE <$> a)\n    abs (QExpr x) = QExpr (absE <$> x)\n    signum _ = error "signum: not defined for QExpr. Use CASE...WHEN"\n\ninstance ( Fractional a, BeamSqlBackend be, BeamSqlBackendCanSerialize be a ) =>\n  Fractional (QGenExpr context be s a) where\n\n  QExpr a / QExpr b = QExpr (divE <$> a <*> b)\n  recip = (1.0 /)\n\n  fromRational = QExpr . pure . valueE . sqlValueSyntax . (id :: a -> a) . fromRational\n\n-- * Sql Projections\n--\n\n-- | Typeclass for all haskell data types that can be used to create a projection in a SQL select\n-- statement. This includes all tables as well as all tuple classes. Projections are only defined on\n-- tuples up to size 5. If you need more, follow the implementations here.\n\nclass Typeable context => AggregateContext context\ninstance (IsAggregateContext a, Typeable a) => AggregateContext a\n\ntype family ContextName a :: Symbol\ntype instance ContextName QValueContext = "a value"\ntype instance ContextName QWindowingContext = "a window expression"\ntype instance ContextName QWindowFrameContext = "a window frame"\ntype instance ContextName QAggregateContext = "an aggregate"\ntype instance ContextName QGroupingContext = "an aggregate grouping"\n\ntype family IsAggregateContext a :: Constraint where\n    IsAggregateContext QAggregateContext = ()\n    IsAggregateContext QGroupingContext = ()\n    IsAggregateContext a = TypeError (\'Text "Non-aggregate expression where aggregate expected." :$$:\n                                      (\'Text "Got " :<>: \'Text (ContextName a) :<>: \'Text ". Expected an aggregate or a grouping") :$$:\n                                      AggregateContextSuggestion a)\n\ntype family AggregateContextSuggestion a :: ErrorMessage where\n    AggregateContextSuggestion QValueContext = \'Text "Perhaps you forgot to wrap a value expression with \'group_\'"\n    AggregateContextSuggestion QWindowingContext = \'Text "Perhaps you meant to use \'window_\' instead of \'aggregate_\'"\n    AggregateContextSuggestion b = \'Text ""\n\nclass Typeable context => ValueContext context\ninstance (IsValueContext a, Typeable a, a ~ QValueContext) => ValueContext a\n\nclass Typeable context => WindowFrameContext context\ninstance (Typeable context, IsWindowFrameContext context, context ~ QWindowFrameContext) =>\n  WindowFrameContext context\n\ntype family IsWindowFrameContext a :: Constraint where\n  IsWindowFrameContext QWindowFrameContext = ()\n  IsWindowFrameContext a = TypeError (\'Text "Expected window frame." :$$:\n                                      (\'Text "Got " :<>: \'Text (ContextName a) :<>: \'Text ". Expected a window frame"))\n\nclass AnyType a\ninstance AnyType a\n\ntype family IsValueContext a :: Constraint where\n    IsValueContext QValueContext = ()\n    IsValueContext a = TypeError (\'Text "Non-scalar context in projection" :$$:\n                                  (\'Text "Got " :<>: \'Text (ContextName a) :<>: \'Text ". Expected a value") :$$:\n                                  ValueContextSuggestion a)\n\ntype family ValueContextSuggestion a :: ErrorMessage where\n    ValueContextSuggestion QWindowingContext = \'Text "Use \'window_\' to projecct aggregate expressions to the value level"\n    ValueContextSuggestion QAggregateContext = (\'Text "Aggregate functions and groupings cannot be contained in value expressions." :$$:\n                                                \'Text "Use \'aggregate_\' to compute aggregations at the value level.")\n    ValueContextSuggestion QGroupingContext = ValueContextSuggestion QAggregateContext\n    ValueContextSuggestion _ = \'Text ""\n\ntype Projectible be = ProjectibleWithPredicate AnyType be (WithExprContext (BeamSqlBackendExpressionSyntax\' be))\ntype ProjectibleValue be = ProjectibleWithPredicate ValueContext be (WithExprContext (BeamSqlBackendExpressionSyntax\' be))\n\nclass ThreadRewritable (s :: Type) (a :: Type) | a -> s where\n  type WithRewrittenThread s (s\' :: Type) a :: Type\n\n  rewriteThread :: Proxy s\' -> a -> WithRewrittenThread s s\' a\ninstance Beamable tbl => ThreadRewritable s (tbl (QGenExpr ctxt syntax s)) where\n  type WithRewrittenThread s s\' (tbl (QGenExpr ctxt syntax s)) = tbl (QGenExpr ctxt syntax s\')\n  rewriteThread _ = changeBeamRep (\\(Columnar\' (QExpr a)) -> Columnar\' (QExpr a))\ninstance Beamable tbl => ThreadRewritable s (tbl (Nullable (QGenExpr ctxt syntax s))) where\n  type WithRewrittenThread s s\' (tbl (Nullable (QGenExpr ctxt syntax s))) = tbl (Nullable (QGenExpr ctxt syntax s\'))\n  rewriteThread _ = changeBeamRep (\\(Columnar\' (QExpr a)) -> Columnar\' (QExpr a))\ninstance ThreadRewritable s (QGenExpr ctxt syntax s a) where\n  type WithRewrittenThread s s\' (QGenExpr ctxt syntax s a) = QGenExpr ctxt syntax s\' a\n  rewriteThread _ (QExpr a) = QExpr a\ninstance ThreadRewritable s a => ThreadRewritable s [a] where\n  type WithRewrittenThread s s\' [a] = [WithRewrittenThread s s\' a]\n  rewriteThread s\' qs = map (rewriteThread s\') qs\ninstance (ThreadRewritable s a, KnownNat n) => ThreadRewritable s (Vector n a) where\n  type WithRewrittenThread s s\' (Vector n a) = Vector n (WithRewrittenThread s s\' a)\n  rewriteThread s\' qs = fmap (rewriteThread s\') qs\ninstance ( ThreadRewritable s a, ThreadRewritable s b ) =>\n  ThreadRewritable s (a, b) where\n  type WithRewrittenThread s s\' (a, b) = (WithRewrittenThread s s\' a, WithRewrittenThread s s\' b)\n  rewriteThread s\' (a, b) = (rewriteThread s\' a, rewriteThread s\' b)\ninstance ( ThreadRewritable s a, ThreadRewritable s b, ThreadRewritable s c ) =>\n  ThreadRewritable s (a, b, c) where\n  type WithRewrittenThread s s\' (a, b, c) =\n    (WithRewrittenThread s s\' a, WithRewrittenThread s s\' b, WithRewrittenThread s s\' c)\n  rewriteThread s\' (a, b, c) = (rewriteThread s\' a, rewriteThread s\' b, rewriteThread s\' c)\ninstance ( ThreadRewritable s a, ThreadRewritable s b, ThreadRewritable s c, ThreadRewritable s d ) =>\n  ThreadRewritable s (a, b, c, d) where\n  type WithRewrittenThread s s\' (a, b, c, d) =\n    (WithRewrittenThread s s\' a, WithRewrittenThread s s\' b, WithRewrittenThread s s\' c, WithRewrittenThread s s\' d)\n  rewriteThread s\' (a, b, c, d) =\n    (rewriteThread s\' a, rewriteThread s\' b, rewriteThread s\' c, rewriteThread s\' d)\ninstance ( ThreadRewritable s a, ThreadRewritable s b, ThreadRewritable s c, ThreadRewritable s d\n         , ThreadRewritable s e ) =>\n  ThreadRewritable s (a, b, c, d, e) where\n  type WithRewrittenThread s s\' (a, b, c, d, e) =\n    ( WithRewrittenThread s s\' a, WithRewrittenThread s s\' b, WithRewrittenThread s s\' c, WithRewrittenThread s s\' d\n    , WithRewrittenThread s s\' e )\n  rewriteThread s\' (a, b, c, d, e) =\n    ( rewriteThread s\' a, rewriteThread s\' b, rewriteThread s\' c, rewriteThread s\' d\n    , rewriteThread s\' e)\ninstance ( ThreadRewritable s a, ThreadRewritable s b, ThreadRewritable s c, ThreadRewritable s d\n         , ThreadRewritable s e, ThreadRewritable s f ) =>\n  ThreadRewritable s (a, b, c, d, e, f) where\n  type WithRewrittenThread s s\' (a, b, c, d, e, f) =\n    ( WithRewrittenThread s s\' a, WithRewrittenThread s s\' b, WithRewrittenThread s s\' c, WithRewrittenThread s s\' d\n    , WithRewrittenThread s s\' e, WithRewrittenThread s s\' f )\n  rewriteThread s\' (a, b, c, d, e, f) =\n    ( rewriteThread s\' a, rewriteThread s\' b, rewriteThread s\' c, rewriteThread s\' d\n    , rewriteThread s\' e, rewriteThread s\' f)\ninstance ( ThreadRewritable s a, ThreadRewritable s b, ThreadRewritable s c, ThreadRewritable s d\n         , ThreadRewritable s e, ThreadRewritable s f, ThreadRewritable s g ) =>\n  ThreadRewritable s (a, b, c, d, e, f, g) where\n  type WithRewrittenThread s s\' (a, b, c, d, e, f, g) =\n    ( WithRewrittenThread s s\' a, WithRewrittenThread s s\' b, WithRewrittenThread s s\' c, WithRewrittenThread s s\' d\n    , WithRewrittenThread s s\' e, WithRewrittenThread s s\' f, WithRewrittenThread s s\' g)\n  rewriteThread s\' (a, b, c, d, e, f, g) =\n    ( rewriteThread s\' a, rewriteThread s\' b, rewriteThread s\' c, rewriteThread s\' d\n    , rewriteThread s\' e, rewriteThread s\' f, rewriteThread s\' g )\ninstance ( ThreadRewritable s a, ThreadRewritable s b, ThreadRewritable s c, ThreadRewritable s d\n         , ThreadRewritable s e, ThreadRewritable s f, ThreadRewritable s g, ThreadRewritable s h ) =>\n  ThreadRewritable s (a, b, c, d, e, f, g, h) where\n  type WithRewrittenThread s s\' (a, b, c, d, e, f, g, h) =\n    ( WithRewrittenThread s s\' a, WithRewrittenThread s s\' b, WithRewrittenThread s s\' c, WithRewrittenThread s s\' d\n    , WithRewrittenThread s s\' e, WithRewrittenThread s s\' f, WithRewrittenThread s s\' g, WithRewrittenThread s s\' h)\n  rewriteThread s\' (a, b, c, d, e, f, g, h) =\n    ( rewriteThread s\' a, rewriteThread s\' b, rewriteThread s\' c, rewriteThread s\' d\n    , rewriteThread s\' e, rewriteThread s\' f, rewriteThread s\' g, rewriteThread s\' h )\n\nclass ContextRewritable a where\n  type WithRewrittenContext a ctxt :: Type\n\n  rewriteContext :: Proxy ctxt -> a -> WithRewrittenContext a ctxt\ninstance Beamable tbl => ContextRewritable (tbl (QGenExpr old syntax s)) where\n  type WithRewrittenContext (tbl (QGenExpr old syntax s)) ctxt = tbl (QGenExpr ctxt syntax s)\n\n  rewriteContext _ = changeBeamRep (\\(Columnar\' (QExpr a)) -> Columnar\' (QExpr a))\ninstance Beamable tbl => ContextRewritable (tbl (Nullable (QGenExpr old syntax s))) where\n  type WithRewrittenContext (tbl (Nullable (QGenExpr old syntax s))) ctxt = tbl (Nullable (QGenExpr ctxt syntax s))\n\n  rewriteContext _ = changeBeamRep (\\(Columnar\' (QExpr a)) -> Columnar\' (QExpr a))\ninstance ContextRewritable (QGenExpr old syntax s a) where\n  type WithRewrittenContext (QGenExpr old syntax s a) ctxt = QGenExpr ctxt syntax s a\n  rewriteContext _ (QExpr a) = QExpr a\ninstance ContextRewritable a => ContextRewritable [a] where\n  type WithRewrittenContext [a] ctxt = [ WithRewrittenContext a ctxt ]\n  rewriteContext p as = map (rewriteContext p) as\ninstance (ContextRewritable a, KnownNat n) => ContextRewritable (Vector n a) where\n  type WithRewrittenContext (Vector n a) ctxt = Vector n (WithRewrittenContext a ctxt)\n  rewriteContext p as = fmap (rewriteContext p) as\ninstance (ContextRewritable a, ContextRewritable b) => ContextRewritable (a, b) where\n  type WithRewrittenContext (a, b) ctxt = (WithRewrittenContext a ctxt, WithRewrittenContext b ctxt)\n  rewriteContext p (a, b) = (rewriteContext p a, rewriteContext p b)\ninstance (ContextRewritable a, ContextRewritable b, ContextRewritable c) => ContextRewritable (a, b, c) where\n  type WithRewrittenContext (a, b, c) ctxt = (WithRewrittenContext a ctxt, WithRewrittenContext b ctxt, WithRewrittenContext c ctxt)\n  rewriteContext p (a, b, c) = (rewriteContext p a, rewriteContext p b, rewriteContext p c)\ninstance ( ContextRewritable a, ContextRewritable b, ContextRewritable c\n         , ContextRewritable d ) => ContextRewritable (a, b, c, d) where\n  type WithRewrittenContext (a, b, c, d) ctxt =\n      ( WithRewrittenContext a ctxt, WithRewrittenContext b ctxt, WithRewrittenContext c ctxt\n      , WithRewrittenContext d ctxt )\n  rewriteContext p (a, b, c, d) = ( rewriteContext p a, rewriteContext p b, rewriteContext p c\n                                  , rewriteContext p d )\ninstance ( ContextRewritable a, ContextRewritable b, ContextRewritable c\n         , ContextRewritable d, ContextRewritable e ) =>\n    ContextRewritable (a, b, c, d, e) where\n  type WithRewrittenContext (a, b, c, d, e) ctxt =\n      ( WithRewrittenContext a ctxt, WithRewrittenContext b ctxt, WithRewrittenContext c ctxt\n      , WithRewrittenContext d ctxt, WithRewrittenContext e ctxt )\n  rewriteContext p (a, b, c, d, e) = ( rewriteContext p a, rewriteContext p b, rewriteContext p c\n                                     , rewriteContext p d, rewriteContext p e )\ninstance ( ContextRewritable a, ContextRewritable b, ContextRewritable c\n         , ContextRewritable d, ContextRewritable e, ContextRewritable f ) =>\n    ContextRewritable (a, b, c, d, e, f) where\n  type WithRewrittenContext (a, b, c, d, e, f) ctxt =\n      ( WithRewrittenContext a ctxt, WithRewrittenContext b ctxt, WithRewrittenContext c ctxt\n      , WithRewrittenContext d ctxt, WithRewrittenContext e ctxt, WithRewrittenContext f ctxt )\n  rewriteContext p (a, b, c, d, e, f) = ( rewriteContext p a, rewriteContext p b, rewriteContext p c\n                                        , rewriteContext p d, rewriteContext p e, rewriteContext p f )\ninstance ( ContextRewritable a, ContextRewritable b, ContextRewritable c\n         , ContextRewritable d, ContextRewritable e, ContextRewritable f\n         , ContextRewritable g ) =>\n    ContextRewritable (a, b, c, d, e, f, g) where\n  type WithRewrittenContext (a, b, c, d, e, f, g) ctxt =\n      ( WithRewrittenContext a ctxt, WithRewrittenContext b ctxt, WithRewrittenContext c ctxt\n      , WithRewrittenContext d ctxt, WithRewrittenContext e ctxt, WithRewrittenContext f ctxt\n      , WithRewrittenContext g ctxt )\n  rewriteContext p (a, b, c, d, e, f, g) =\n    ( rewriteContext p a, rewriteContext p b, rewriteContext p c\n    , rewriteContext p d, rewriteContext p e, rewriteContext p f\n    , rewriteContext p g )\ninstance ( ContextRewritable a, ContextRewritable b, ContextRewritable c\n         , ContextRewritable d, ContextRewritable e, ContextRewritable f\n         , ContextRewritable g, ContextRewritable h ) =>\n    ContextRewritable (a, b, c, d, e, f, g, h) where\n  type WithRewrittenContext (a, b, c, d, e, f, g, h) ctxt =\n      ( WithRewrittenContext a ctxt, WithRewrittenContext b ctxt, WithRewrittenContext c ctxt\n      , WithRewrittenContext d ctxt, WithRewrittenContext e ctxt, WithRewrittenContext f ctxt\n      , WithRewrittenContext g ctxt, WithRewrittenContext h ctxt )\n  rewriteContext p (a, b, c, d, e, f, g, h) =\n    ( rewriteContext p a, rewriteContext p b, rewriteContext p c\n    , rewriteContext p d, rewriteContext p e, rewriteContext p f\n    , rewriteContext p g, rewriteContext p h )\n\nnewtype BeamSqlBackendExpressionSyntax\' be\n  = BeamSqlBackendExpressionSyntax\'\n  { fromBeamSqlBackendExpressionSyntax :: BeamSqlBackendExpressionSyntax be\n  }\n\nnewtype BeamSqlBackendWindowFrameSyntax\' be\n  = BeamSqlBackendWindowFrameSyntax\'\n  { fromBeamSqlBackendWindowFrameSyntax :: BeamSqlBackendWindowFrameSyntax be\n  }\n\nclass ProjectibleWithPredicate (contextPredicate :: Type -> Constraint) be res a | a -> be where\n  project\' :: Monad m => Proxy contextPredicate -> Proxy (be, res)\n           -> (forall context. contextPredicate context =>\n               Proxy context -> Proxy be -> res -> m res)\n           -> a -> m a\n\n  projectSkeleton\' :: Monad m => Proxy contextPredicate -> Proxy (be, res)\n                   -> (forall context. contextPredicate context =>\n                       Proxy context -> Proxy be -> m res)\n                   -> m a\n\ninstance (Beamable t, contextPredicate context) => ProjectibleWithPredicate contextPredicate be (WithExprContext (BeamSqlBackendExpressionSyntax\' be)) (t (QGenExpr context be s)) where\n  project\' _ _ mutateM a =\n    zipBeamFieldsM (\\(Columnar\' (QExpr e)) _ ->\n                      Columnar\' . QExpr . fmap fromBeamSqlBackendExpressionSyntax <$> mutateM (Proxy @context) (Proxy @be) (BeamSqlBackendExpressionSyntax\' . e)) a a\n\n  projectSkeleton\' _ _ mkM =\n    zipBeamFieldsM (\\_ _ -> Columnar\' . QExpr . fmap fromBeamSqlBackendExpressionSyntax <$> mkM (Proxy @context)(Proxy @be))\n                   (tblSkeleton :: TableSkeleton t)\n                   (tblSkeleton :: TableSkeleton t)\n\ninstance (Beamable t, contextPredicate context) => ProjectibleWithPredicate contextPredicate be (WithExprContext (BeamSqlBackendExpressionSyntax\' be)) (t (Nullable (QGenExpr context be s))) where\n  project\' _ _ mutateM a =\n    zipBeamFieldsM (\\(Columnar\' (QExpr e)) _ ->\n                      Columnar\' . QExpr . fmap fromBeamSqlBackendExpressionSyntax <$> mutateM (Proxy @context) (Proxy @be) (BeamSqlBackendExpressionSyntax\' . e)) a a\n\n  projectSkeleton\' _ _ mkM =\n    zipBeamFieldsM (\\_ _ -> Columnar\' . QExpr . fmap fromBeamSqlBackendExpressionSyntax <$> mkM (Proxy @context)(Proxy @be))\n                   (tblSkeleton :: TableSkeleton t)\n                   (tblSkeleton :: TableSkeleton t)\n\n-- instance ProjectibleWithPredicate WindowFrameContext be (QWindow be s) where\n--   project\' _ be mutateM (QWindow a) =\n--     QWindow <$> mutateM (Proxy @QWindowFrameContext) be a\n\ninstance contextPredicate context => ProjectibleWithPredicate contextPredicate be (WithExprContext (BeamSqlBackendExpressionSyntax\' be)) (QGenExpr context be s a) where\n  project\' _ _ mkE (QExpr a) = QExpr . fmap fromBeamSqlBackendExpressionSyntax <$> mkE (Proxy @context) (Proxy @be) (BeamSqlBackendExpressionSyntax\' . a)\n  projectSkeleton\' _ _ mkM = QExpr . fmap fromBeamSqlBackendExpressionSyntax <$> mkM (Proxy @context) (Proxy @be)\n\ninstance contextPredicate QWindowFrameContext => ProjectibleWithPredicate contextPredicate be (WithExprContext (BeamSqlBackendWindowFrameSyntax\' be)) (QWindow be s) where\n  project\' _ _ mkW (QWindow w) = QWindow . fmap fromBeamSqlBackendWindowFrameSyntax <$> mkW (Proxy @QWindowFrameContext) (Proxy @be) (BeamSqlBackendWindowFrameSyntax\' . w)\n  projectSkeleton\' _ _ mkM = QWindow . fmap fromBeamSqlBackendWindowFrameSyntax <$> mkM (Proxy @QWindowFrameContext) (Proxy @be)\n\n-- instance ProjectibleWithPredicate contextPredicate be res a => ProjectibleWithPredicate contextPredicate be res [a] where\n--   project\' context be mkE as = traverse (project\' context be mkE) as\n\ninstance (ProjectibleWithPredicate contextPredicate be res a, KnownNat n) => ProjectibleWithPredicate contextPredicate be res (Vector n a) where\n  project\' context be mkE as = traverse (project\' context be mkE) as\n  projectSkeleton\' context be mkM = VS.replicateM (projectSkeleton\' context be mkM)\n\ninstance ( ProjectibleWithPredicate contextPredicate be res a, ProjectibleWithPredicate contextPredicate be res b ) =>\n  ProjectibleWithPredicate contextPredicate be res (a, b) where\n\n  project\' context be mkE (a, b) =\n    (,) <$> project\' context be mkE a <*> project\' context be mkE b\n  projectSkeleton\' context be mkM =\n    (,) <$> projectSkeleton\' context be mkM\n        <*> projectSkeleton\' context be mkM\n\ninstance ( ProjectibleWithPredicate contextPredicate be res a, ProjectibleWithPredicate contextPredicate be res b, ProjectibleWithPredicate contextPredicate be res c ) =>\n  ProjectibleWithPredicate contextPredicate be res (a, b, c) where\n\n  project\' context be mkE (a, b, c) =\n    (,,) <$> project\' context be mkE a <*> project\' context be mkE b <*> project\' context be mkE c\n  projectSkeleton\' context be mkM =\n    (,,) <$> projectSkeleton\' context be mkM\n         <*> projectSkeleton\' context be mkM\n         <*> projectSkeleton\' context be mkM\n\ninstance ( ProjectibleWithPredicate contextPredicate be res a, ProjectibleWithPredicate contextPredicate be res b, ProjectibleWithPredicate contextPredicate be res c\n         , ProjectibleWithPredicate contextPredicate be res d ) =>\n  ProjectibleWithPredicate contextPredicate be res (a, b, c, d) where\n\n  project\' context be mkE (a, b, c, d) =\n    (,,,) <$> project\' context be mkE a <*> project\' context be mkE b <*> project\' context be mkE c\n          <*> project\' context be mkE d\n  projectSkeleton\' context be mkM =\n    (,,,) <$> projectSkeleton\' context be mkM\n          <*> projectSkeleton\' context be mkM\n          <*> projectSkeleton\' context be mkM\n          <*> projectSkeleton\' context be mkM\n\ninstance ( ProjectibleWithPredicate contextPredicate be res a, ProjectibleWithPredicate contextPredicate be res b, ProjectibleWithPredicate contextPredicate be res c\n         , ProjectibleWithPredicate contextPredicate be res d, ProjectibleWithPredicate contextPredicate be res e ) =>\n  ProjectibleWithPredicate contextPredicate be res (a, b, c, d, e) where\n\n  project\' context be mkE (a, b, c, d, e) =\n    (,,,,) <$> project\' context be mkE a <*> project\' context be mkE b <*> project\' context be mkE c\n           <*> project\' context be mkE d <*> project\' context be mkE e\n  projectSkeleton\' context be mkM =\n    (,,,,) <$> projectSkeleton\' context be mkM\n           <*> projectSkeleton\' context be mkM\n           <*> projectSkeleton\' context be mkM\n           <*> projectSkeleton\' context be mkM\n           <*> projectSkeleton\' context be mkM\n\ninstance ( ProjectibleWithPredicate contextPredicate be res a, ProjectibleWithPredicate contextPredicate be res b, ProjectibleWithPredicate contextPredicate be res c\n         , ProjectibleWithPredicate contextPredicate be res d, ProjectibleWithPredicate contextPredicate be res e, ProjectibleWithPredicate contextPredicate be res f ) =>\n  ProjectibleWithPredicate contextPredicate be res (a, b, c, d, e, f) where\n\n  project\' context be  mkE (a, b, c, d, e, f) =\n    (,,,,,) <$> project\' context be mkE a <*> project\' context be mkE b <*> project\' context be mkE c\n            <*> project\' context be mkE d <*> project\' context be mkE e <*> project\' context be mkE f\n  projectSkeleton\' context be mkM =\n    (,,,,,) <$> projectSkeleton\' context be mkM\n            <*> projectSkeleton\' context be mkM\n            <*> projectSkeleton\' context be mkM\n            <*> projectSkeleton\' context be mkM\n            <*> projectSkeleton\' context be mkM\n            <*> projectSkeleton\' context be mkM\n\ninstance ( ProjectibleWithPredicate contextPredicate be res a, ProjectibleWithPredicate contextPredicate be res b, ProjectibleWithPredicate contextPredicate be res c\n         , ProjectibleWithPredicate contextPredicate be res d, ProjectibleWithPredicate contextPredicate be res e, ProjectibleWithPredicate contextPredicate be res f\n         , ProjectibleWithPredicate contextPredicate be res g ) =>\n  ProjectibleWithPredicate contextPredicate be res (a, b, c, d, e, f, g) where\n\n  project\' context be mkE (a, b, c, d, e, f, g) =\n    (,,,,,,) <$> project\' context be mkE a <*> project\' context be mkE b <*> project\' context be mkE c\n             <*> project\' context be mkE d <*> project\' context be mkE e <*> project\' context be mkE f\n             <*> project\' context be mkE g\n  projectSkeleton\' context be mkM =\n    (,,,,,,) <$> projectSkeleton\' context be mkM\n             <*> projectSkeleton\' context be mkM\n             <*> projectSkeleton\' context be mkM\n             <*> projectSkeleton\' context be mkM\n             <*> projectSkeleton\' context be mkM\n             <*> projectSkeleton\' context be mkM\n             <*> projectSkeleton\' context be mkM\n\ninstance ( ProjectibleWithPredicate contextPredicate be res a, ProjectibleWithPredicate contextPredicate be res b, ProjectibleWithPredicate contextPredicate be res c\n         , ProjectibleWithPredicate contextPredicate be res d, ProjectibleWithPredicate contextPredicate be res e, ProjectibleWithPredicate contextPredicate be res f\n         , ProjectibleWithPredicate contextPredicate be res g, ProjectibleWithPredicate contextPredicate be res h ) =>\n  ProjectibleWithPredicate contextPredicate be res (a, b, c, d, e, f, g, h) where\n\n  project\' context be mkE (a, b, c, d, e, f, g, h) =\n    (,,,,,,,) <$> project\' context be mkE a <*> project\' context be mkE b <*> project\' context be mkE c\n              <*> project\' context be mkE d <*> project\' context be mkE e <*> project\' context be mkE f\n              <*> project\' context be mkE g <*> project\' context be mkE h\n  projectSkeleton\' context be mkM =\n    (,,,,,,,) <$> projectSkeleton\' context be mkM\n              <*> projectSkeleton\' context be mkM\n              <*> projectSkeleton\' context be mkM\n              <*> projectSkeleton\' context be mkM\n              <*> projectSkeleton\' context be mkM\n              <*> projectSkeleton\' context be mkM\n              <*> projectSkeleton\' context be mkM\n              <*> projectSkeleton\' context be mkM\n\n-- TODO add projectSkeleton\'\ninstance Beamable t => ProjectibleWithPredicate AnyType () T.Text (t (QField s)) where\n  project\' _ be mutateM a =\n    zipBeamFieldsM (\\(Columnar\' f) _ ->\n                      Columnar\' <$> project\' (Proxy @AnyType) be mutateM f) a a\n\n  projectSkeleton\' _ _ mkM =\n    zipBeamFieldsM (\\_ _ -> Columnar\' . QField False "" <$> (mkM (Proxy @()) (Proxy @())))\n                   (tblSkeleton :: TableSkeleton t) (tblSkeleton :: TableSkeleton t)\n\ninstance Beamable t => ProjectibleWithPredicate AnyType () T.Text (t (Nullable (QField s))) where\n  project\' _ be mutateM a =\n    zipBeamFieldsM (\\(Columnar\' f) _ ->\n                      Columnar\' <$> project\' (Proxy @AnyType) be mutateM f) a a\n\n  projectSkeleton\' _ _ mkM =\n    zipBeamFieldsM (\\_ _ -> Columnar\' . QField False "" <$> mkM (Proxy @()) (Proxy @()))\n                   (tblSkeleton :: TableSkeleton t) (tblSkeleton :: TableSkeleton t)\n\ninstance Beamable t => ProjectibleWithPredicate AnyType () res (t (Const res)) where\n  project\' _ be mutateM a =\n    zipBeamFieldsM (\\(Columnar\' f) _ ->\n                      Columnar\' <$> project\' (Proxy @AnyType) be mutateM f) a a\n\n  projectSkeleton\' _ _ mkM =\n    zipBeamFieldsM (\\_ _ -> Columnar\' . Const <$> mkM (Proxy @()) (Proxy @()))\n                   (tblSkeleton :: TableSkeleton t) (tblSkeleton :: TableSkeleton t)\n\ninstance Beamable t => ProjectibleWithPredicate AnyType () T.Text (t (Nullable (Const T.Text))) where\n  project\' _ be mutateM a =\n    zipBeamFieldsM (\\(Columnar\' f) _ ->\n                      Columnar\' <$> project\' (Proxy @AnyType) be mutateM f) a a\n\n  projectSkeleton\' _ _ mkM =\n    zipBeamFieldsM (\\_ _ -> Columnar\' . Const <$> mkM (Proxy @()) (Proxy @()))\n                   (tblSkeleton :: TableSkeleton t) (tblSkeleton :: TableSkeleton t)\n\ninstance ProjectibleWithPredicate AnyType () res (Const res a) where\n  project\' _ _ mutateM (Const a) = Const <$> mutateM (Proxy @()) (Proxy @()) a\n\n  projectSkeleton\' _ _ mkM =\n    Const <$> mkM (Proxy @()) (Proxy @())\n\ninstance ProjectibleWithPredicate AnyType () T.Text (QField s a) where\n  project\' _ _ mutateM (QField q tbl f) =\n    fmap (QField q tbl)\n         (mutateM (Proxy @(QField s a)) (Proxy @()) f)\n\n  projectSkeleton\' _ _ mkM =\n    QField False "" <$> mkM (Proxy @()) (Proxy @())\n\nproject :: forall be a\n         . Projectible be a => Proxy be -> a -> WithExprContext [ BeamSqlBackendExpressionSyntax be ]\nproject _ = fmap (fmap fromBeamSqlBackendExpressionSyntax) . sequenceA . DList.toList . execWriter .\n            project\' (Proxy @AnyType) (Proxy @(be, WithExprContext (BeamSqlBackendExpressionSyntax\' be))) (\\_ _ e -> tell (DList.singleton e) >> pure e)\n\nreproject :: forall be a\n           . (BeamSqlBackend be, Projectible be a)\n          => Proxy be -> (Int -> BeamSqlBackendExpressionSyntax be) -> a -> a\nreproject _ mkField a =\n  evalState (project\' (Proxy @AnyType) (Proxy @(be, WithExprContext (BeamSqlBackendExpressionSyntax\' be))) (\\_ _ _ -> state (\\i -> (i, i + 1)) >>= pure . pure . BeamSqlBackendExpressionSyntax\' . mkField) a) 0\n\n-- | suitable as argument to \'QAll\' in the case of a table result\ntableFieldsToExpressions :: ( BeamSqlBackend be, Beamable table )\n                         => TableSettings table -> T.Text -> table (QGenExpr ctxt be s)\ntableFieldsToExpressions tblSettings newTblNm =\n    changeBeamRep (\\(Columnar\' f) -> Columnar\' (QExpr (\\_ -> fieldE (qualifiedField newTblNm (_fieldName f))))) tblSettings\n\nmkFieldsSkeleton :: forall be res m\n                  . (Projectible be res, MonadState Int m)\n                 => (Int -> m (WithExprContext (BeamSqlBackendExpressionSyntax\' be))) -> m res\nmkFieldsSkeleton go =\n    projectSkeleton\' (Proxy @AnyType) (Proxy @(be, WithExprContext (BeamSqlBackendExpressionSyntax\' be))) $ \\_ _ ->\n    do i <- get\n       put (i + 1)\n       go i\n\nmkFieldNames :: forall be res\n              . ( BeamSqlBackend be, Projectible be res )\n             => (T.Text -> BeamSqlBackendFieldNameSyntax be) -> (res, [ T.Text ])\nmkFieldNames mkField =\n    runWriter . flip evalStateT 0 $\n    mkFieldsSkeleton @be @res $ \\i -> do\n      let fieldName\' = fromString ("res" ++ show i)\n      tell [ fieldName\' ]\n      pure (\\_ -> BeamSqlBackendExpressionSyntax\' (fieldE (mkField fieldName\')))\n\ntableNameFromEntity :: IsSql92TableNameSyntax name\n                    => DatabaseEntityDescriptor be (TableEntity tbl)\n                    -> name\n\ntableNameFromEntity = tableName <$> dbTableSchema <*> dbTableCurrentName\n\nrescopeQ :: QM be db s res -> QM be db s\' res\nrescopeQ = unsafeCoerce\n'