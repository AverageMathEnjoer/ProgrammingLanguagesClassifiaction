b'#\' matchesLink\n#\'\n#\' matchesLink produces two dataframes that store\n#\' all the pairs that share a pattern that conforms\n#\' to the an interval of the Fellegi-Sunter\n#\' weights\n#\'\n#\' @usage matchesLink(gammalist, nobs.a, nobs.b, em, thresh, n.cores = NULL)\n#\'\n#\' @param gammalist A list of objects produced by either gammaKpar or\n#\' gammaCKpar. \n#\' @param nobs.a number of observations in dataset 1\n#\' @param nobs.b number of observations in dataset 2\n#\' @param em parameters obtained from the Expectation-Maximization algorithm under the MAR assumption. These estimates are\n#\' produced by emlinkMARmov\n#\' @param thresh is the interval of posterior zeta values for the agreements that we want to examine closer. Ranges between 0 and 1.\n#\' Can be a vector of length 1 (from specified value to 1) or 2 (from first specified value to second specified value).\n#\' @param n.cores Number of cores to parallelize over. Default is NULL.\n#\'\n#\' @return \\code{matchesLink} returns an nmatches X 2 matrix with the indices of the\n#\' matches rows in dataset A and dataset B.\n#\'\n#\' @author Ted Enamorado <ted.enamorado@gmail.com>, Ben Fifield <benfifield@gmail.com>, and Kosuke Imai\n#\'\n#\' @examples\n#\' \\dontrun{\n#\' ## Calculate gammas\n#\' g1 <- gammaCKpar(dfA$firstname, dfB$firstname)\n#\' g2 <- gammaCKpar(dfA$middlename, dfB$middlename)\n#\' g3 <- gammaCKpar(dfA$lastname, dfB$lastname)\n#\' g4 <- gammaKpar(dfA$birthyear, dfB$birthyear)\n#\'\n#\' ## Run tableCounts\n#\' tc <- tableCounts(list(g1, g2, g3, g4), nobs.a = nrow(dfA), nobs.b = nrow(dfB))\n#\'\n#\' ## Run EM\n#\' em <- emlinkMAR(tc)\n#\'\n#\' ## Get matches\n#\' ml <- matchesLink(list(g1, g2, g3, g4), nobs.a = nrow(dfA), nobs.b = nrow(dfB),\n#\' em = em, thresh = .95)\n#\' }\n#\'\n#\' @export\n\n## ------------------------\n## To recover the matches (their indices)\n## we use matchesLink\n## ------------------------\n\nmatchesLink <- function(gammalist, nobs.a, nobs.b, em, thresh, n.cores = NULL) {\n\n    if(is.null(n.cores)) {\n        n.cores <- detectCores() - 1\n    }\n\n    if(min(thresh) < 0 | max(thresh) > 1){\n        stop("The specified threshold values are not valid posterior probabilities. These must range between 0 and 1.")\n    }\n\n    ## Slicing the data:\n    n.slices1 <- max(round(as.numeric(nobs.a)/(10000), 0), 1) \n    n.slices2 <- max(round(as.numeric(nobs.b)/(10000), 0), 1) \n    nc <- min(n.cores, n.slices1 * n.slices2)\n\n    limit.1 <- round(quantile((0:nobs.a), p = seq(0, 1, 1/n.slices1)), 0)\n    limit.2 <- round(quantile((0:nobs.b), p = seq(0, 1, 1/n.slices2)), 0)\n\n    last1 <- length(limit.1)\n    last2 <- length(limit.2)\n\n    n.lim.1 <- limit.1[-1] - limit.1[-last1]\n    n.lim.2 <- limit.2[-1] - limit.2[-last2]\n\n    ## Get the correct cuts\n    em.obj <- data.frame(em$patterns.w)\n    em.obj$zeta.j <- em$zeta.j\n    em.obj <- em.obj[order(em.obj[, "weights"]), ]\n    l.t <- thresh[1]\n    u.t <- thresh[2]\n    \n    l.b <- suppressWarnings(min(em.obj$weights[em.obj$zeta.j >= l.t]))\n    if(is.na(u.t)){\n        u.b <- 1e10\n    }else{\n        u.b <- max(em.obj$weights[em.obj$zeta.j < u.t])\n    }\n\n    tablem <- em$patterns.w[em$patterns.w[, "weights"] >= l.b & em$patterns.w[, "weights"] < u.b, ]\n    list <- tablem\n    list[is.na(list)] <- 4\n\n    if(is.null(dim(list))) {\n        list <- t(as.matrix(list))\n    }\n\n    list <- list[, !colnames(list) %in% c("counts", "weights", "p.gamma.j.m", "p.gamma.j.u")]\n\n    if(is.null(dim(list))) {\n        list <- t(as.matrix(list))\n    }\n\n    ncol <- ncol(list)\n    power <- rep(NA, length(gammalist))\n    for(i in 1:length(gammalist)){\n        power[i] <- 1 + (i-1)*3\n    }\n    power.s <- power[1:ncol]\n    base <- 2^(power.s)\n    list <- t(base * t(list))\n    list.id <- rowSums(list)\n\n    ## Lists of indices:\n    ##     temp - exact\n    ##     ptemp - partial\n    ##     natemp - NAs\n    temp <- vector(mode = "list", length = length(gammalist))\n    ptemp <- vector(mode = "list", length = length(gammalist))\n    natemp <- vector(mode = "list", length = length(gammalist))\n    for(i in 1:length(gammalist)){\n        temp[[i]] <- gammalist[[i]]$matches2\n        if(!is.null(gammalist[[i]]$matches1)) {\n            ptemp[[i]] <- gammalist[[i]]$matches1\n        }\n        natemp[[i]] <- gammalist[[i]]$nas\n    }\n\n    ind.i <- 1:n.slices1\n    ind.j <- 1:n.slices2\n    ind <- as.matrix(expand.grid(ind.i, ind.j))\n\n    ## Run main function\n    if(Sys.info()[[\'sysname\']] == \'Darwin\') {\n        if (nc == 1) \'%oper%\' <- foreach::\'%do%\'\n        else { \n            \'%oper%\' <- foreach::\'%dopar%\'\n            cl <- makeCluster(nc)\n            registerDoParallel(cl)\n            on.exit(stopCluster(cl))\n        }\n\n        gammas <- foreach(i = 1:nrow(ind)) %oper% {\n            m_func_par(temp = temp, ptemp = ptemp, natemp = natemp,\n                       limit1 = limit.1, limit2 = limit.2,\n                       nlim1 = n.lim.1, nlim2 = n.lim.2,\n                       ind = as.matrix(t(ind[i, ])), listid = list.id,\n                       matchesLink = TRUE, threads = 1)\n      \t}\n        \n\tgammas_mat <- list()\n\tfor(i in 1:length(gammas)){\n            temp0 <- gammas[[i]]\t\n            temp1 <- as.matrix(lapply(temp0, function(x){\n                as.matrix(data.frame(x[[1]], x[[2]]))\n            }))\n            gammas_mat[[i]] <- temp1[[1]] \n        }\n\trm(temp0, temp1)\t\n\n        temp <- do.call(\'rbind\', gammas_mat)\n\n    } else {\n\n        gammas <- m_func_par(temp = temp, ptemp = ptemp, natemp = natemp,\n                             limit1 = limit.1, limit2 = limit.2,\n                             nlim1 = n.lim.1, nlim2 = n.lim.2,\n                             ind = ind, listid = list.id,\n                             matchesLink = TRUE, threads = nc)\n\n        gammas_mat <- lapply(gammas, function(x){\n            as.matrix(data.frame(x[[1]], x[[2]]))\n        })\n        \n        temp <- do.call(\'rbind\', gammas_mat)\n    }\n    \n    temp <- temp + 1\n    rm(gammas, gammas_mat); gc()\n\n    temp <- data.frame(inds.a = temp[,1], inds.b = temp[,2])\n    \n    class(temp) <- c("fastLink", "matchesLink")\n    \n    return(temp)\n}\n\n## ------------------------\n## End of matcheLink\n## ------------------------\n\n'