b'-- | This module allows to use SmallCheck properties in tasty.\n{-# LANGUAGE MultiParamTypeClasses, FlexibleInstances, FlexibleContexts,\n             TypeOperators, DeriveDataTypeable, TypeFamilies,\n             GeneralizedNewtypeDeriving #-}\nmodule Test.Tasty.SmallCheck\n  ( testProperty\n  , SmallCheckDepth(..)\n  , module Test.SmallCheck\n  ) where\n\nimport Test.Tasty.Providers\nimport Test.Tasty.Options\nimport qualified Test.SmallCheck as SC\nimport Test.SmallCheck hiding (smallCheck) -- for re-export\nimport Test.SmallCheck.Drivers as SC\nimport Control.Exception\nimport Control.Monad (when)\nimport Data.Typeable\nimport Data.IORef\nimport Options.Applicative (metavar)\nimport Text.Printf\n\n-- | Create a \'TestTree\' for a SmallCheck \'SC.Testable\' property\ntestProperty :: SC.Testable IO a => TestName -> a -> TestTree\ntestProperty name prop = singleTest name $ (SC.test prop :: SC.Property IO)\n\n-- | The \\"depth\\" parameter for SmallCheck\nnewtype SmallCheckDepth = SmallCheckDepth Int\n  deriving (Num, Ord, Eq, Real, Enum, Integral, Typeable)\n\ninstance IsOption SmallCheckDepth where\n  defaultValue = 5\n  parseValue = fmap SmallCheckDepth . safeRead\n  optionName = return "smallcheck-depth"\n  optionHelp = return "Depth to use for smallcheck tests"\n  optionCLParser = mkOptionCLParser $ metavar "NUMBER"\n\n-- | The maximum number of test cases to generate. Can be used as an\n-- alternative to setting \'SmallCheckDepth\'.\nnewtype SmallCheckMaxCount = SmallCheckMaxCount Int\n  deriving (Num, Ord, Eq, Real, Enum, Integral, Typeable)\n\ninstance IsOption SmallCheckMaxCount where\n  defaultValue = SmallCheckMaxCount maxBound -- disable by default\n  parseValue = fmap SmallCheckMaxCount . safeRead\n  optionName = return "smallcheck-max-count"\n  optionHelp = return "Maximum smallcheck test count"\n  optionCLParser = mkOptionCLParser $ metavar "NUMBER"\n\ninstance IsTest (SC.Property IO) where\n  testOptions = return\n    [ Option (Proxy :: Proxy SmallCheckDepth)\n    , Option (Proxy :: Proxy SmallCheckMaxCount)\n    ]\n\n  run opts prop yieldProgress = do\n    let\n      SmallCheckDepth depth = lookupOption opts\n      SmallCheckMaxCount maxCount = lookupOption opts\n\n    counter <- newIORef (0 :: Int, 0 :: Int)\n\n    let\n      hook quality = do\n        let\n          inc (total, bad) =\n            case quality of\n              GoodTest -> ((,) $! total + 1) bad\n              BadTest -> ((,) $! total + 1) $! bad + 1\n\n        count <- myAtomicModifyIORef\' counter (\\c -> let c\' = inc c in (c\', fst c\'))\n\n        when (count >= maxCount) $ throwIO Finish\n\n        -- submit progress data to tasty\n        yieldProgress $ Progress\n          { progressText = show count\n          , progressPercent = 0 -- we don\'t know the total number of tests\n          }\n\n    -- small check does not catch exceptions on its own, so lets do it\n    scResult <- try $ smallCheckWithHook depth hook prop\n\n    (total, bad) <- readIORef counter\n    let\n      desc\n        | bad == 0\n          = printf "%d tests completed" total\n        | otherwise\n          = printf "%d tests completed (but %d did not meet the condition)" total bad\n\n    return $\n      case scResult of\n        Left e\n          | Just Finish <- fromException e\n                       -> testPassed desc\n          | otherwise  -> testFailed $ show e\n        Right Nothing  -> testPassed desc\n        Right (Just f) -> testFailed $ ppFailure f\n\ndata Finish = Finish\n  deriving (Eq, Show)\n\ninstance Exception Finish\n\n-- Copied from base to stay compatible with GHC 7.4.\nmyAtomicModifyIORef\' :: IORef a -> (a -> (a,b)) -> IO b\nmyAtomicModifyIORef\' ref f = do\n    b <- atomicModifyIORef ref\n            (\\x -> let (a, b) = f x\n                    in (a, a `seq` b))\n    b `seq` return b\n'