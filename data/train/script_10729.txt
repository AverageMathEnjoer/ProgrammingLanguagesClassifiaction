b'-- NOTE: this module will be deprecated.\n\nmodule Graphics.Hoodle.Render.Util.HitTest\n  ( isPointInBBox, -- re-export\n    do2LinesIntersect, -- re-export\n    do2BBoxIntersect, -- re-export\n    isBBox2InBBox1, -- re-export\n    hltHittedByBBox, -- re-export\n    hltEmbeddedByBBox, -- re-export\n    hltHittedByLineRough, -- re-export\n    elimHitted, -- re-export\n    merge, -- re-export\n    getTotalBBox, -- re-export\n    --\n    doesLineHitStrk,\n    hltFilteredByStateT,\n    hltFilteredBy,\n    hltItmsHittedByLineStateT,\n    hltItmsHittedByLineFrmSelectedStateT,\n  )\nwhere\n\nimport Control.Monad.State (State, evalState, modify)\nimport Data.Hoodle.BBox (bbxed_content)\nimport Data.Hoodle.Simple\n  ( Stroke (Stroke, VWStroke, stroke_data),\n  )\nimport Data.Strict.Tuple (Pair ((:!:)))\nimport Graphics.Hoodle.Render.Type.HitTest\n  ( AlterList (Empty, (:-)),\n    RItemHitted,\n  )\nimport Graphics.Hoodle.Render.Type.Item\n  ( RItem (RItemStroke),\n  )\nimport Hoodle.HitTest\n  ( do2BBoxIntersect,\n    do2LinesIntersect,\n    elimHitted,\n    getTotalBBox,\n    hltEmbeddedByBBox,\n    hltHittedByBBox,\n    hltHittedByLineRough,\n    isBBox2InBBox1,\n    isPointInBBox,\n    merge,\n  )\nimport Hoodle.HitTest.Type\n  ( Hitted (..),\n    NotHitted (..),\n  )\n\n--------------------------\n-- hit test collections --\n--------------------------\n\n-- | previously, hitTestLineStroke\ndoesLineHitStrk :: ((Double, Double), (Double, Double)) -> Stroke -> Bool\ndoesLineHitStrk line1 str@(Stroke _t _c _w _d) = test (stroke_data str)\n  where\n    test [] = False\n    test [_] = False\n    test ((x0 :!: y0) : (x :!: y) : rest) =\n      do2LinesIntersect line1 ((x0, y0), (x, y))\n        || test ((x :!: y) : rest)\ndoesLineHitStrk line1 (VWStroke _t _c d) = test d\n  where\n    test [] = False\n    test [(_, _, _)] = False\n    test ((x0, y0, _) : (x, y, z) : rest) =\n      do2LinesIntersect line1 ((x0, y0), (x, y))\n        || test ((x, y, z) : rest)\n\n--------------------------------------------------------\n-- item filtering functions that results in AlterList --\n--------------------------------------------------------\n\n-- |\nhltFilteredByStateT ::\n  -- | hit test condition\n  (a -> Bool) ->\n  -- | strokes to test\n  [a] ->\n  State Bool (AlterList (NotHitted a) (Hitted a))\nhltFilteredByStateT test itms = do\n  let (nhit, rest) = break test itms\n      (hit, rest\') = span test rest\n  modify (|| (not . null) hit)\n  if null rest\'\n    then return (NotHitted nhit :- Hitted hit :- NotHitted [] :- Empty)\n    else return (NotHitted nhit :- Hitted hit :- hltFilteredBy test rest\')\n\n-- | highlight strokes filtered by a condition.\n--   previously mkHitTestAL\nhltFilteredBy ::\n  -- | hit test condition\n  (a -> Bool) ->\n  -- | strokes to test\n  [a] ->\n  AlterList (NotHitted a) (Hitted a)\nhltFilteredBy test is = evalState (hltFilteredByStateT test is) False\n\n-- |\nhltItmsHittedByLineStateT ::\n  ((Double, Double), (Double, Double)) ->\n  [RItem] ->\n  State Bool RItemHitted\nhltItmsHittedByLineStateT line = hltFilteredByStateT test\n  where\n    test (RItemStroke strk) = (doesLineHitStrk line . bbxed_content) strk\n    test _ = False\n\n-- |\nhltItmsHittedByLineFrmSelectedStateT ::\n  ((Double, Double), (Double, Double)) ->\n  RItemHitted ->\n  State Bool (AlterList (NotHitted RItem) RItemHitted)\nhltItmsHittedByLineFrmSelectedStateT _ Empty =\n  error "something is wrong, invariant broken"\nhltItmsHittedByLineFrmSelectedStateT _ (n :- Empty) = return (n :- Empty)\nhltItmsHittedByLineFrmSelectedStateT line (n :- h :- rest) = do\n  h\' <- hltItmsHittedByLineStateT line (unHitted h)\n  (n :-) . (h\' :-) <$> hltItmsHittedByLineFrmSelectedStateT line rest\n'