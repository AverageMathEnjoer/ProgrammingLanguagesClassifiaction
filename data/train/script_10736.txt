b'{-# LANGUAGE DeriveFunctor #-}\n{-# LANGUAGE RecordWildCards #-}\n{-# LANGUAGE StandaloneDeriving #-}\n\nmodule Hoodle.HitTest.Type\n  ( BBox (..),\n    BBoxed (..),\n    GetBBoxable (..),\n    AlterList (..),\n    NotHitted (..),\n    Hitted (..),\n    TAlterHitted,\n    TEitherAlterHitted (..),\n    getA,\n    getB,\n    interleave,\n    takeHitted,\n    isAnyHitted,\n  )\nwhere\n\nimport Control.Monad (liftM2)\nimport Data.Bifunctor (Bifunctor (..))\nimport Data.Serialize (Serialize (..))\nimport Prelude hiding (fst, snd)\n\n-- | bounding box type\ndata BBox = BBox\n  { bbox_upperleft :: (Double, Double),\n    bbox_lowerright :: (Double, Double)\n  }\n  deriving (Show, Eq, Ord)\n\ndata BBoxed a = BBoxed\n  { bbxed_content :: a,\n    bbxed_bbx :: BBox\n  }\n\nderiving instance (Show a) => Show (BBoxed a)\n\nderiving instance (Eq a) => Eq (BBoxed a)\n\nderiving instance (Ord a) => Ord (BBoxed a)\n\n-- | orphan instance for BBox\ninstance Serialize BBox where\n  put BBox {..} = put bbox_upperleft >> put bbox_lowerright\n  get = liftM2 BBox get get\n\n-- |\nclass GetBBoxable a where\n  getBBox :: a -> BBox\n\ninstance GetBBoxable (BBoxed a) where\n  getBBox = bbxed_bbx\n\n-- |\ndata AlterList a b = Empty | a :- AlterList b a\n  deriving (Show)\n\ninfixr 6 :-\n\ninstance Functor (AlterList a) where\n  fmap _ Empty = Empty\n  fmap _ (x :- Empty) = x :- Empty\n  fmap f (x :- (y :- ys)) = x :- (f y :- fmap f ys)\n\ninstance Bifunctor AlterList where\n  bimap _ _ Empty = Empty\n  bimap f g (x :- ys) = f x :- bimap g f ys\n\n-- |\ngetA :: AlterList a b -> [a]\ngetA Empty = []\ngetA (x :- xs) = x : getB xs\n\n-- |\ngetB :: AlterList a b -> [b]\ngetB Empty = []\ngetB (_x :- xs) = getA xs\n\n-- |\nnewtype NotHitted a = NotHitted {unNotHitted :: [a]}\n  deriving (Show, Functor)\n\n-- |\nnewtype Hitted a = Hitted {unHitted :: [a]}\n  deriving (Show, Functor)\n\n-- |\ninterleave :: (a -> c) -> (b -> c) -> AlterList a b -> [c]\ninterleave _fa _fb Empty = []\ninterleave fa fb (x :- xs) = fa x : interleave fb fa xs\n\n----\n\n-- |\ntype TAlterHitted a = AlterList [a] (Hitted a)\n\n-- |\nnewtype TEitherAlterHitted a = TEitherAlterHitted\n  { unTEitherAlterHitted :: Either [a] (TAlterHitted a)\n  }\n\n-- |\ntakeHitted :: AlterList x (Hitted a) -> [a]\ntakeHitted = concatMap unHitted . getB\n\n-- |\nisAnyHitted :: AlterList x (Hitted a) -> Bool\nisAnyHitted = not . null . takeHitted\n'