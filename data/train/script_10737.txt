b'#include "stdafx.h"\n#include "MonoBehaviourManager.h"\n#include "Win32AppContext.h"\n#include "FileDialog.h"\n#include "../AssetsTools/ClassDatabaseFile.h"\n#include "../AssetsTools/AssetsFileTable.h"\n#include "../AssetsTools/EngineVersion.h"\n#include "../libStringConverter/convert.h"\n#include <vector>\n#include "resource.h"\n#include <WindowsX.h>\n\nbool TryGetAssemblyFilePath(Win32AppContext &appContext, AssetsFileContextInfo &assetsFileInfo, const char *assemblyName, WCHAR *&path, bool allowUserDialog);\nvoid ShowMonoBehaviourExportErrors(HINSTANCE hInstance, HWND hParent, std::vector<unsigned char> &errorBuffer);\n\nstatic void AddAssemblyName(Win32AppContext &appContext, unsigned int assetsFileId, const char *scriptAssemblyName, std::vector<char*> &scannedAssemblies, std::vector<std::pair<EngineVersion,WCHAR*>> &assemblyNames)\n{\n\tbool exists = false;\n\tfor (size_t l = 0; l < scannedAssemblies.size(); l++)\n\t{\n\t\tif (!strcmp(scannedAssemblies[l], scriptAssemblyName))\n\t\t{\n\t\t\texists = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!exists)\n\t{\n\t\tsize_t curNameLen = strlen(scriptAssemblyName);\n\t\tfor (size_t i = 0; i < curNameLen; i++)\n\t\t{\n\t\t\t//Prevent format string injection.\n\t\t\tif (scriptAssemblyName[i] == \':\' || scriptAssemblyName[i] == \'|\')\n\t\t\t\treturn;\n\t\t}\n\t\tchar *curScannedName = new char[curNameLen+1];\n\t\tmemcpy(curScannedName, scriptAssemblyName, curNameLen+1);\n\t\tscannedAssemblies.push_back(curScannedName);\n\t\tWCHAR *pName;\n\t\tstd::shared_ptr<AssetsFileContextInfo> pAssetsInfo = std::dynamic_pointer_cast<AssetsFileContextInfo>(appContext.getContextInfo(assetsFileId));\n\t\tif (pAssetsInfo && TryGetAssemblyFilePath(appContext, *pAssetsInfo, scriptAssemblyName, pName, true))\n\t\t{\n\t\t\tEngineVersion version;\n\t\t\tif (pAssetsInfo->getAssetsFileContext() && pAssetsInfo->getAssetsFileContext()->getAssetsFile())\n\t\t\t\tversion = EngineVersion::parse(pAssetsInfo->getAssetsFileContext()->getAssetsFile()->typeTree.unityVersion);\n\t\t\tassemblyNames.push_back({ version, pName });\n\t\t}\n\t}\n}\n\nbool GetAllScriptInformation(Win32AppContext &appContext, std::vector<std::shared_ptr<AssetsFileContextInfo>> &assetsInfo)\n{\n\tstd::vector<AssetsFileContextInfo*> assetsFilesWithMonoScript;\n\tstd::vector<std::pair<EngineVersion, WCHAR*>> assemblyNames;\n\tstd::vector<char*> scannedAssemblies;\n\tbool useLongPathID = false;\n\tfor (size_t i = 0; i < assetsInfo.size(); i++)\n\t{\n\t\tAssetsFileContextInfo *pAssetsInfo = assetsInfo[i].get();\n\t\tbool isBigEndian = false;\n\t\tif (!pAssetsInfo || !pAssetsInfo->getAssetsFileContext() || !pAssetsInfo->getAssetsFileContext()->getAssetsFile()\n\t\t\t|| !pAssetsInfo->getEndianness(isBigEndian))\n\t\t\tcontinue;\n\t\t\n\t\tuseLongPathID = useLongPathID || (pAssetsInfo->getAssetsFileContext()->getAssetsFile()->header.format >= 0x0E);\n\t\tint scriptClassId = pAssetsInfo->GetClassByName("MonoScript");\n\t\tint managerClassId = pAssetsInfo->GetClassByName("MonoManager");\n\n\t\tAssetTypeTemplateField scriptBase;\n\t\tif (scriptClassId >= 0)\n\t\t\tpAssetsInfo->MakeTemplateField(&scriptBase, appContext, scriptClassId);\n\t\tAssetTypeTemplateField managerBase;\n\t\tif (managerClassId >= 0)\n\t\t\tpAssetsInfo->MakeTemplateField(&managerBase, appContext, managerClassId);\n\n\n\t\tif (scriptBase.children.size() > 0)\n\t\t{\n\t\t\tbool fileHasMonoScript = false;\n\t\t\tAssetIdentifier identifier;\n\t\t\tfor (AssetIterator iter(pAssetsInfo); !iter.isEnd(); ++iter)\n\t\t\t{\n\t\t\t\titer.get(identifier);\n\t\t\t\tif (identifier.resolve(appContext) && identifier.getClassID() == scriptClassId)\n\t\t\t\t{\n\t\t\t\t\tIAssetsReader_ptr pReader = identifier.makeReader();\n\t\t\t\t\tif (!pReader) continue;\n\t\t\t\t\tfileHasMonoScript = true;\n\t\t\t\t\tAssetTypeTemplateField *pTemplate = &scriptBase;\n\t\t\t\t\tAssetTypeInstance scriptInstance = AssetTypeInstance(1, &pTemplate,\n\t\t\t\t\t\tidentifier.getDataSize(), pReader.get(), isBigEndian);\n\t\t\t\t\t\n\t\t\t\t\tAssetTypeValueField *pScriptBase = scriptInstance.GetBaseField();\n\t\t\t\t\tAssetTypeValueField *pScriptAssemblyNameField; const char *scriptAssemblyName;\n\t\t\t\t\tif ((pScriptBase != NULL) && \n\t\t\t\t\t\t(pScriptAssemblyNameField = pScriptBase->Get("m_AssemblyName"))->GetValue()\n\t\t\t\t\t\t\t&& (scriptAssemblyName = pScriptAssemblyNameField->GetValue()->AsString()))\n\t\t\t\t\t{\n\t\t\t\t\t\tAddAssemblyName(appContext, pAssetsInfo->getFileID(), scriptAssemblyName, scannedAssemblies, assemblyNames);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (fileHasMonoScript)\n\t\t\t\tassetsFilesWithMonoScript.push_back(pAssetsInfo);\n\t\t}\n\t\tif (managerBase.children.size() > 0)\n\t\t{\n\t\t\tAssetIdentifier identifier;\n\t\t\tfor (AssetIterator iter(pAssetsInfo); !iter.isEnd(); ++iter)\n\t\t\t{\n\t\t\t\titer.get(identifier);\n\t\t\t\tif (identifier.resolve(appContext) && identifier.getClassID() == managerClassId)\n\t\t\t\t{\n\t\t\t\t\tIAssetsReader_ptr pReader = identifier.makeReader();\n\t\t\t\t\tif (!pReader) continue;\n\t\t\t\t\tAssetTypeTemplateField *pTemplate = &managerBase;\n\t\t\t\t\tAssetTypeInstance managerInstance = AssetTypeInstance(1, &pTemplate,\n\t\t\t\t\t\tidentifier.getDataSize(), pReader.get(), isBigEndian);\n\t\t\t\t\t\n\t\t\t\t\tAssetTypeValueField *pScriptBase = managerInstance.GetBaseField();\n\t\t\t\t\tAssetTypeValueField *pAssemblyNamesField;\n\t\t\t\t\tif ((pScriptBase != NULL) && \n\t\t\t\t\t\t(pAssemblyNamesField = pScriptBase->Get("m_AssemblyNames")->Get("Array"))->GetValue() &&\n\t\t\t\t\t\tpAssemblyNamesField->GetValue()->AsArray())\n\t\t\t\t\t{\n\t\t\t\t\t\tfor (unsigned int l = 0; l < pAssemblyNamesField->GetChildrenCount(); l++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tAssetTypeValue *pNameValue = pAssemblyNamesField->Get(l)->GetValue();\n\t\t\t\t\t\t\tchar *scriptAssemblyName;\n\t\t\t\t\t\t\tif (pNameValue && (scriptAssemblyName = pNameValue->AsString()))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tAddAssemblyName(appContext, pAssetsInfo->getFileID(), scriptAssemblyName, scannedAssemblies, assemblyNames);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor (size_t i = 0; i < scannedAssemblies.size(); i++)\n\t{\n\t\tdelete[] scannedAssemblies[i];\n\t}\n\n\tif (assemblyNames.size() > 0)\n\t{\n\t\tstd::shared_ptr<ClassDatabaseFile> pClassDb = CreateMonoBehaviourClassDb(appContext, assemblyNames, useLongPathID, true);\n\t\tfor (size_t i = 0; i < assemblyNames.size(); i++)\n\t\t{\n\t\t\tdelete[] assemblyNames[i].second;\n\t\t}\n\t\tif (pClassDb != nullptr)\n\t\t{\n\t\t\tif (assetsFilesWithMonoScript.empty())\n\t\t\t{\n\t\t\t\tfor (size_t i = 0; i < assetsInfo.size(); ++i)\n\t\t\t\t\tassetsInfo[i]->appendScriptDatabase(pClassDb);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tfor (size_t i = 0; i < assetsFilesWithMonoScript.size(); ++i)\n\t\t\t\t\tassetsFilesWithMonoScript[i]->appendScriptDatabase(pClassDb);\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t}\n\telse\n\t\tMessageBox(appContext.getMainWindow().getWindow(), TEXT("Unable to find any script assemblies!"), TEXT("Error"), 0);\n\treturn false;\n}\n\nbool TryGetAssemblyFilePath(Win32AppContext &appContext, AssetsFileContextInfo &assetsFileInfo, const char *assemblyName, WCHAR *&path, bool allowUserDialog)\n{\n\tif (!assetsFileInfo.getFileContext()\n\t\t|| !assetsFileInfo.getAssetsFileContext()\n\t\t|| !assetsFileInfo.getAssetsFileContext()->getAssetsFile())\n\t\treturn false;\n\n\tif (!assemblyName)\n\t\treturn false;\n\tsize_t wcAssemblyNameLen;\n\tauto wcAssemblyName = unique_MultiByteToWide(assemblyName, wcAssemblyNameLen);\n\tif (!wcAssemblyName)\n\t\treturn false;\n\n\tstd::wstring assemblyPath = std::wstring();\n\tstd::string assetsBaseFolder = assetsFileInfo.getAssetsFileContext()->getFileDirectoryPath();\n\tif (!assetsBaseFolder.empty())\n\t{\n\t\tsize_t wcBaseFolderLen;\n\t\tauto wcBaseFolder = unique_MultiByteToWide(assetsBaseFolder.c_str(), wcBaseFolderLen);\n\t\tif (wcBaseFolder)\n\t\t{\n\t\t\tassemblyPath = std::wstring(wcBaseFolder.get());\n\t\t\tif (assemblyPath.size() > 10 && !assemblyPath.compare(assemblyPath.size() - 10, std::string::npos, L"\\\\Resources"))\n\t\t\t\tassemblyPath += L"\\\\..";\n\t\t\tassemblyPath += L"\\\\Managed\\\\";\n\t\t\tassemblyPath += wcAssemblyName.get();\n\t\t}\n\t}\n\tbool foundFile = false;\n\tif (assemblyPath.size() > 0)\n\t{\n\t\tIAssetsReader *pTempReader = Create_AssetsReaderFromFile(assemblyPath.c_str(), true, RWOpenFlags_Immediately);\n\t\tif (pTempReader)\n\t\t{\n\t\t\tFree_AssetsReader(pTempReader);\n\t\t\tfoundFile = true;\n\t\t}\n\t}\n\tif (!foundFile)\n\t{\n\t\tif (allowUserDialog)\n\t\t{\n\t\t\tstd::vector<wchar_t> wcAssemblyNameEscaped; wcAssemblyNameEscaped.reserve(wcAssemblyNameLen);\n\t\t\tfor (size_t i = 0; i < wcAssemblyNameLen; ++i)\n\t\t\t{\n\t\t\t\tif (wcAssemblyName[i] == L\'|\' || wcAssemblyName[i] == L\':\' || wcAssemblyName[i] == L\'*\' || wcAssemblyName[i] == 0)\n\t\t\t\t{\n\t\t\t\t\twcAssemblyNameEscaped.clear();\n\t\t\t\t\twcAssemblyNameEscaped.push_back(L\'*\');\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\twcAssemblyNameEscaped.push_back(wcAssemblyName[i]);\n\t\t\t}\n\t\t\tWCHAR *filePathBuf = NULL;\n\t\t\tHRESULT result = ShowFileOpenDialog(\n\t\t\t\tappContext.getMainWindow().getWindow(),\n\t\t\t\t&filePathBuf, \n\t\t\t\t( std::wstring(wcAssemblyNameEscaped.begin(), wcAssemblyNameEscaped.end()) + L"|Assembly file:" ).c_str(),\n\t\t\t\tNULL,\n\t\t\t\twcAssemblyName.get(),\n\t\t\t\tL"Open the Assembly file",\n\t\t\t\tUABE_FILEDIALOG_FILE_GUID);\n\t\t\tif (SUCCEEDED(result))\n\t\t\t{\n\t\t\t\tassemblyPath = std::wstring(filePathBuf);\n\t\t\t\tFreeCOMFilePathBuf(&filePathBuf);\n\t\t\t\tfoundFile = true;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpath = new WCHAR[assemblyPath.size() + 1];\n\tmemcpy(path, assemblyPath.c_str(), (assemblyPath.size() + 1) * sizeof(WCHAR));\n\n\treturn foundFile;\n}\n\nstd::shared_ptr<ClassDatabaseFile> CreateMonoBehaviourClassDb(Win32AppContext &appContext, \n\tstd::vector<std::pair<EngineVersion, WCHAR*>> &assemblyFullNames,\n\tbool useLongPathID, bool allowUserDialog)\n{\n\tHANDLE stdoutReadPipe = INVALID_HANDLE_VALUE; HANDLE stdoutWritePipe = INVALID_HANDLE_VALUE;\n\tHANDLE stderrReadPipe = INVALID_HANDLE_VALUE; HANDLE stderrWritePipe = INVALID_HANDLE_VALUE;\n\tHANDLE stdinReadPipe = INVALID_HANDLE_VALUE; HANDLE stdinWritePipe = INVALID_HANDLE_VALUE;\n\tSECURITY_ATTRIBUTES secAttributes = {sizeof(SECURITY_ATTRIBUTES), NULL, TRUE};\n\tif (!CreatePipe(&stdoutReadPipe, &stdoutWritePipe, &secAttributes, 0) || \n\t\t!CreatePipe(&stderrReadPipe, &stderrWritePipe, &secAttributes, 0) || \n\t\t!CreatePipe(&stdinReadPipe, &stdinWritePipe, &secAttributes, 0))\n\t{\n\t\tif (stdinReadPipe != INVALID_HANDLE_VALUE)\n\t\t{\n\t\t\tCloseHandle(stdinReadPipe);\n\t\t\tCloseHandle(stdinWritePipe);\n\t\t}\n\t\tif (stderrReadPipe != INVALID_HANDLE_VALUE)\n\t\t{\n\t\t\tCloseHandle(stderrReadPipe);\n\t\t\tCloseHandle(stderrWritePipe);\n\t\t}\n\t\tif (allowUserDialog)\n\t\t\tMessageBox(appContext.getMainWindow().getWindow(), TEXT("Unable to create stdout/stderr pipes for the child process!"), TEXT("Asset Bundle Extractor"), 16);\n\t\treturn std::shared_ptr<ClassDatabaseFile>();\n\t}\n\tSetHandleInformation(stdoutReadPipe, HANDLE_FLAG_INHERIT, 0);\n\tSetHandleInformation(stderrReadPipe, HANDLE_FLAG_INHERIT, 0);\n\tSetHandleInformation(stdinWritePipe, HANDLE_FLAG_INHERIT, 0);\n\t\n\tstd::wstring typeTreeGeneratorApp;\n\t{\n\t\tstd::string baseDir = appContext.getBaseDir(); size_t baseDirWLen = 0;\n\t\tauto baseDirW = unique_MultiByteToWide(baseDir.c_str(), baseDirWLen);\n\n\t\ttypeTreeGeneratorApp = std::wstring(baseDirW.get(), baseDirW.get() + baseDirWLen) + L"\\\\Tools\\\\TypeTreeGenerator.exe";\n\t}\n\n\tstd::vector<wchar_t> commandLine;\n\t{\n\t\tstd::wstring _commandLine = std::wstring(L"TypeTreeGenerator -stdout -stdin -longpathid ") + (useLongPathID ? L"1" : L"0");\n\t\t/*for (size_t i = 0; i < assemblyFullNames.size(); i++)\n\t\t{\n\t\t\t_commandLine = _commandLine + L" -f \\"" + assemblyFullNames[i] + L"\\"";\n\t\t}*/\n\t\tcommandLine = std::vector<wchar_t>();\n\t\tcommandLine.resize(_commandLine.size() + 1); //include null-terminator\n\t\tmemcpy(commandLine.data(), _commandLine.c_str(), (_commandLine.size() + 1) * sizeof(wchar_t));\n\t}\n\tSTARTUPINFO startInfo = {}; PROCESS_INFORMATION procInfo = {};\n\tstartInfo.cb = sizeof(STARTUPINFO);\n\tstartInfo.dwFlags = STARTF_USESTDHANDLES;\n\tstartInfo.hStdError = stderrWritePipe;\n\tstartInfo.hStdOutput = stdoutWritePipe;\n\tstartInfo.hStdInput = stdinReadPipe;\n\n\tstd::vector<unsigned char> dataBuffer;\n\tstd::vector<unsigned char> errorBuffer;\n\tif (CreateProcess(typeTreeGeneratorApp.c_str(), commandLine.data(), NULL, NULL, TRUE, 0/*CREATE_NO_WINDOW*/, NULL, NULL, &startInfo, &procInfo))\n\t{\n\t\tCloseHandle(procInfo.hThread);\n\t\tstd::wstring commands = std::wstring();\n\t\tfor (size_t i = 0; i < assemblyFullNames.size(); i++)\n\t\t{\n\t\t\tcommands += L"-ver";\n\t\t\tcommands.push_back(0);\n\t\t\tcommands += std::to_wstring(assemblyFullNames[i].first.year);\n\t\t\tcommands.push_back(0);\n\t\t\tcommands += std::to_wstring(assemblyFullNames[i].first.release);\n\t\t\tcommands.push_back(0);\n\t\t\tcommands += L"-f";\n\t\t\tcommands.push_back(0);\n\t\t\tcommands += assemblyFullNames[i].second;\n\t\t\tcommands.push_back(0);\n\t\t}\n\t\tif (commands.size() == 0)\n\t\t\tcommands.push_back(0);\n\t\tcommands.push_back(0);\n\t\tDWORD written = 0;\n\t\tWriteFile(stdinWritePipe, commands.data(), (DWORD)(commands.size() * sizeof(wchar_t)), &written, NULL);\n\t\tbool repeatOnce = false;\n\t\twhile (true)\n\t\t{\n\t\t\tbool repeatOnce = false;\n\t\t\tif (WaitForSingleObject(procInfo.hProcess, 100) != WAIT_TIMEOUT)\n\t\t\t{\n\t\t\t\trepeatOnce = true;\n\t\t\t}\n\t\t\tDWORD avail = 0;\n\t\t\tif (PeekNamedPipe(stdoutReadPipe, NULL, 0, NULL, &avail, NULL) && avail > 0)\n\t\t\t{\n\t\t\t\tsize_t targetIndex = dataBuffer.size();\n\t\t\t\tdataBuffer.resize(dataBuffer.size() + avail);\n\t\t\t\tDWORD actuallyRead = 0;\n\t\t\t\tReadFile(stdoutReadPipe, &dataBuffer[targetIndex], avail, &actuallyRead, NULL);\n\t\t\t\tdataBuffer.resize(targetIndex + actuallyRead);\n\t\t\t}\n\t\t\tavail = 0;\n\t\t\tif (PeekNamedPipe(stderrReadPipe, NULL, 0, NULL, &avail, NULL) && avail > 0)\n\t\t\t{\n\t\t\t\tsize_t targetIndex = errorBuffer.size();\n\t\t\t\terrorBuffer.resize(errorBuffer.size() + avail);\n\t\t\t\tDWORD actuallyRead = 0;\n\t\t\t\tReadFile(stderrReadPipe, &errorBuffer[targetIndex], avail, &actuallyRead, NULL);\n\t\t\t\terrorBuffer.resize(targetIndex + actuallyRead);\n\t\t\t}\n\t\t\tif (repeatOnce)\n\t\t\t\tbreak;\n\t\t}\n\t\tTerminateProcess(procInfo.hProcess, 0); //Make sure it\'s really closed.\n\t\tCloseHandle(procInfo.hProcess);\n\t}\n\telse\n\t{\n\t\tif (allowUserDialog)\n\t\t{\n\t\t\tchar errorCodeBuf[128];\n\t\t\tsprintf_s(errorCodeBuf, "Unable to open Tools\\\\TypeTreeGenerator.exe (error %d)!", GetLastError());\n\t\t\tMessageBoxA(appContext.getMainWindow().getWindow(), errorCodeBuf, "Error", 16);\n\t\t}\t\n\t}\n\tCloseHandle(stdoutReadPipe);\n\tCloseHandle(stdoutWritePipe);\n\tCloseHandle(stderrReadPipe);\n\tCloseHandle(stderrWritePipe);\n\tCloseHandle(stdinReadPipe);\n\tCloseHandle(stdinWritePipe);\n\n\tstd::shared_ptr<ClassDatabaseFile> pClassDatabaseFile = std::make_shared<ClassDatabaseFile>();\n\tbool success = false;\n\tIAssetsReader *pReader = Create_AssetsReaderFromMemory(dataBuffer.data(), dataBuffer.size(), false);\n\tif (pReader)\n\t{\n\t\tsuccess = pClassDatabaseFile->Read(pReader);\n\t\tFree_AssetsReader(pReader);\n\t}\n\tif (!success)\n\t{\n\t\tif (allowUserDialog)\n\t\t{\n\t\t\tstd::wstring errorMessage = std::wstring(L"Unable to retrieve the script type database!");\n\t\t\tif (errorBuffer.size() > 0)\n\t\t\t{\n\t\t\t\t//Add a null terminator\n\t\t\t\terrorBuffer.push_back(0);\n\t\t\t\tsize_t strLen = 0;\n\t\t\t\tWCHAR *wideLog = _MultiByteToWide((char*)errorBuffer.data(), strLen);\n\t\t\t\tif (wideLog)\n\t\t\t\t{\n\t\t\t\t\terrorMessage = errorMessage + L"\\n" + wideLog;\n\t\t\t\t\t_FreeWCHAR(wideLog);\n\t\t\t\t}\n\t\t\t}\n\t\t\tMessageBoxW(appContext.getMainWindow().getWindow(), errorMessage.c_str(), L"Error", 16);\n\t\t}\n\t\tpClassDatabaseFile.reset();\n\t}\n\telse\n\t{\n\t\tif (errorBuffer.size() > 0 && allowUserDialog)\n\t\t{\n\t\t\tShowMonoBehaviourExportErrors(appContext.getMainWindow().getHInstance(), appContext.getMainWindow().getWindow(), errorBuffer);\n\t\t}\n\t}\n\treturn pClassDatabaseFile;\n}\n\nclass MonoBehavErrorDialogParam\n{\npublic:\n\tstruct ErrorDesc\n\t{\n\t\t//points to errorBuffer with byte lengths, UTF-16\n\t\tsize_t headerText_bufferOffset;\n\t\tsize_t excText_bufferOffset;\n\t\tunsigned int headerText_bufferLen;\n\t\tunsigned int excText_bufferLen;\n\t};\npublic:\n\tHWND hParentWnd;\n\tstd::vector<unsigned char> &errorBuffer;\n\tstd::vector<ErrorDesc> errorDescriptors;\npublic:\n\tMonoBehavErrorDialogParam(HWND hParentWnd, std::vector<unsigned char> &errorBuffer)\n\t\t: hParentWnd(hParentWnd), errorBuffer(errorBuffer)\n\t{\n\t}\n};\n\nstatic void GetErrorString(MonoBehavErrorDialogParam *pParam, size_t offset, unsigned int byteLen,\n\tstd::vector<wchar_t> &outString, bool pushback, bool nullchar = true)\n{\n\twchar_t *outBuf;\n\tif (pushback)\n\t{\n\t\tsize_t oldLen = outString.size();\n\t\toutString.resize(oldLen + (byteLen >> 1));\n\t\toutBuf = &outString.data()[oldLen];\n\t}\n\telse\n\t{\n\t\toutString.resize((byteLen >> 1));\n\t\toutBuf = outString.data();\n\t}\n\tmemcpy(outBuf, &pParam->errorBuffer.data()[offset], byteLen);\n\tif (nullchar)\n\t\toutString.push_back(0);\n}\n\nstatic void GetFullErrorString(MonoBehavErrorDialogParam *pParam, size_t errorIdx, \n\tstd::vector<wchar_t> &outString, bool pushback, bool nullchar=true)\n{\n\tMonoBehavErrorDialogParam::ErrorDesc &desc = pParam->errorDescriptors[errorIdx];\n\tGetErrorString(pParam, desc.headerText_bufferOffset, desc.headerText_bufferLen, outString, pushback, false);\n\toutString.push_back(L\' \');\n\toutString.push_back(L\':\');\n\toutString.push_back(L\'\\r\');\n\toutString.push_back(L\'\\n\');\n\tGetErrorString(pParam, desc.excText_bufferOffset, desc.excText_bufferLen, outString, true, nullchar);\n}\n\nstatic INT_PTR CALLBACK MonoBehavErrorDialogProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)\n{\n\tint wmId, wmEvent; bool all;\n\tUNREFERENCED_PARAMETER(lParam);\n\tswitch (message)\n\t{\n\tcase WM_INITDIALOG:\n\t\t{\n\t\t\tSetWindowLongPtr(hDlg, GWLP_USERDATA, lParam);\n\t\t\tMonoBehavErrorDialogParam *pParam = (MonoBehavErrorDialogParam*)lParam;\n\t\t\tHWND hErrorList = GetDlgItem(hDlg, IDC_ERRORLIST);\n\t\t\tif (hErrorList == NULL)\n\t\t\t\treturn (INT_PTR)FALSE;\n\t\t\tstd::vector<wchar_t> strBuffer;\n\t\t\tfor (size_t i = 0; i < pParam->errorDescriptors.size(); i++)\n\t\t\t{\n\t\t\t\tMonoBehavErrorDialogParam::ErrorDesc &desc = pParam->errorDescriptors[i];\n\t\t\t\tGetErrorString(pParam, desc.headerText_bufferOffset, desc.headerText_bufferLen, strBuffer, false);\n\t\t\t\tListBox_AddString(hErrorList, strBuffer.data());\n\t\t\t}\n\t\t}\n\t\treturn (INT_PTR)TRUE;\n\t\t\n\tcase WM_CLOSE:\n\tcase WM_DESTROY:\n\t\tEndDialog(hDlg, LOWORD(wParam));\n\t\treturn (INT_PTR)TRUE;\n\tcase WM_COMMAND:\n\t\twmId    = LOWORD(wParam);\n\t\twmEvent = HIWORD(wParam);\n\t\tall = true;\n\t\tswitch (wmId)\n\t\t{\n\t\t\tcase IDC_BTNVIEW:\n\t\t\t\t{\n\t\t\t\t\tMonoBehavErrorDialogParam *pParam = (MonoBehavErrorDialogParam*)GetWindowLongPtr(hDlg, GWLP_USERDATA);\n\t\t\t\t\tHWND hErrorList = GetDlgItem(hDlg, IDC_ERRORLIST);\n\t\t\t\t\tint selection = ListBox_GetCurSel(hErrorList);\n\t\t\t\t\tif ((selection >= 0) && ((unsigned int)selection < pParam->errorDescriptors.size()))\n\t\t\t\t\t{\n\t\t\t\t\t\tstd::vector<wchar_t> messageBuffer;\n\t\t\t\t\t\tGetFullErrorString(pParam, (size_t)selection, messageBuffer, false);\n\t\t\t\t\t\tMessageBoxW(hDlg, messageBuffer.data(), L"MonoBehaviour error", 0);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase IDC_BTNCOPY:\n\t\t\t\tall = false;\n\t\t\tcase IDC_BTNCOPYALL:\n\t\t\t\t{\n\t\t\t\t\tMonoBehavErrorDialogParam *pParam = (MonoBehavErrorDialogParam*)GetWindowLongPtr(hDlg, GWLP_USERDATA);\n\t\t\t\t\tHWND hErrorList = GetDlgItem(hDlg, IDC_ERRORLIST);\n\t\t\t\t\tint selection = ListBox_GetCurSel(hErrorList);\n\t\t\t\t\tstd::vector<wchar_t> messageBuffer;\n\t\t\t\t\tif (all)\n\t\t\t\t\t{\n\t\t\t\t\t\tfor (size_t i = 0; i < pParam->errorDescriptors.size(); i++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (i > 0)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tmessageBuffer.push_back(\'\\r\');\n\t\t\t\t\t\t\t\tmessageBuffer.push_back(\'\\n\');\n\t\t\t\t\t\t\t\tmessageBuffer.push_back(\'\\r\');\n\t\t\t\t\t\t\t\tmessageBuffer.push_back(\'\\n\');\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tGetFullErrorString(pParam, i, messageBuffer, true, false);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmessageBuffer.push_back(0);\n\t\t\t\t\t}\n\t\t\t\t\telse if ((selection >= 0) && ((unsigned int)selection < pParam->errorDescriptors.size()))\n\t\t\t\t\t\tGetFullErrorString(pParam, (size_t)selection, messageBuffer, false);\n\t\t\t\t\tHGLOBAL hClipboardMem = GlobalAlloc(GMEM_MOVEABLE, messageBuffer.size() * sizeof(wchar_t));\n\t\t\t\t\tvoid *pClipboardMem = nullptr;\n\t\t\t\t\tbool success = false;\n\t\t\t\t\tif ((hClipboardMem != nullptr) && ((pClipboardMem = GlobalLock(hClipboardMem)) != nullptr))\n\t\t\t\t\t{\n\t\t\t\t\t\tmemcpy(pClipboardMem, messageBuffer.data(), messageBuffer.size() * sizeof(wchar_t));\n\t\t\t\t\t\tGlobalUnlock(pClipboardMem);\n\t\t\t\t\t\tif (OpenClipboard(pParam->hParentWnd))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (SetClipboardData(CF_UNICODETEXT, hClipboardMem))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tCloseClipboard();\n\t\t\t\t\t\t\t\tsuccess = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tCloseClipboard();\n\t\t\t\t\t\t\t\tMessageBox(hDlg, L"Unable to change the clipboard data!", L"ERROR", 16);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tMessageBox(hDlg, L"Unable to open the clipboard!", L"ERROR", 16);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t\tMessageBox(hDlg, L"Unable to allocate the global clipboard buffer!", L"ERROR", 16);\n\t\t\t\t\tif (!success && hClipboardMem) \n\t\t\t\t\t\tGlobalFree(hClipboardMem);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase IDOK:\n\t\t\tcase IDCANCEL:\n\t\t\t\tEndDialog(hDlg, LOWORD(wParam));\n\t\t\t\treturn (INT_PTR)TRUE;\n\t\t}\n\t\tbreak;\n\t}\n\treturn (INT_PTR)FALSE;\n}\n\nvoid ShowMonoBehaviourExportErrors(HINSTANCE hInstance, HWND hParent, std::vector<unsigned char> &errorBuffer)\n{\n\t/*\n\terrorBuffer format : any number of error entries, each of which is\n\n\tstruct ErrorBufferEntry\n\t{\n\t\tunsigned int headerLen, excTextLen;\n\t\tunsigned char header[headerLen]; //UTF-16 buffer\n\t\tunsigned char excText[excTextLen]; //UTF-16 buffer\n\t};\n\t*/\n\tMonoBehavErrorDialogParam dlgParam(hParent, errorBuffer);\n\tsize_t bufferIndex = 0;\n\tunsigned char *errorBufferRaw = errorBuffer.data();\n\twhile ((bufferIndex + 8) < errorBuffer.size())\n\t{\n\t\tMonoBehavErrorDialogParam::ErrorDesc desc;\n\t\tdesc.headerText_bufferLen = *(unsigned int*)(&errorBufferRaw[bufferIndex]);\n\t\tdesc.excText_bufferLen = *(unsigned int*)(&errorBufferRaw[bufferIndex + 4]);\n\t\tdesc.headerText_bufferOffset = bufferIndex + 8;\n\t\tdesc.excText_bufferOffset = desc.headerText_bufferOffset + desc.headerText_bufferLen;\n\t\tif ((desc.excText_bufferOffset + desc.excText_bufferLen) <= errorBuffer.size() \n\t\t\t&& (desc.excText_bufferLen & 1) == 0\n\t\t\t&& (desc.headerText_bufferLen & 1) == 0)\n\t\t{\n\t\t\tdlgParam.errorDescriptors.push_back(desc);\n\t\t}\n\t\tbufferIndex = desc.excText_bufferOffset + desc.excText_bufferLen;\n\t}\n\tif (dlgParam.errorDescriptors.size() > 0)\n\t\tDialogBoxParam(hInstance, MAKEINTRESOURCE(IDD_MONOBEHAVERROR), hParent, MonoBehavErrorDialogProc, (LPARAM)&dlgParam);\n}'