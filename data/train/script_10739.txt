b'import Data.Int\nimport Data.Maybe\nimport Data.List\nimport Control.Monad\nimport qualified DBus.Client as DBus\nimport Control.Concurrent.Thread.Delay\nimport Data.Time.Clock\nimport Data.Time.Clock.POSIX\n\nimport System.Posix\nimport System.IO\nimport Data.Bits\n\nimport Devices.Razer\nimport Devices.System\nimport qualified Devices.I3 as I3\nimport Effects\nimport Color\nimport Keyboard\nimport SystemState\nimport qualified Devices.Yeelight as Bulb\n\nkeyboardUpdateDelay = 40000\nfrequentInfoUpdateRate = 0.4\ninfrequentInfoUpdateRate = 2.0\n\nstep previousUpdateTime previousTime dbus i3 dimensions cpu keyboardDaemonFile state = do\n    t <- getPOSIXTime\n\n    let keyboard = _keyboard state\n    let shouldUpdateInfo = t - previousUpdateTime > frequentInfoUpdateRate\n    cpu <- if shouldUpdateInfo \n                then updateCPUUsage (snd cpu)\n                else return cpu\n\n    let deltaTime = t - previousTime\n\n    inputSignals <- readAvailableInput keyboardDaemonFile []\n    let maybeSignal = getLatestModeSignal inputSignals\n                        \n    newLanguage <- if shouldSwitchLanguage inputSignals\n                        then case _language state of\n                            LangUS -> setLanguageRu >> return LangRU\n                            LangRU -> setLanguageUs >> return LangUS\n                        else return $ _language state\n\n    prevBrightness <- case maybeSignal of\n                            Just (Modifier _) -> do brightness <- getKeyboardBrightness dbus\n                                                    if (brightness < 99.9) \n                                                        then do setKeyboardBrightness 100.0 dbus\n                                                                return brightness\n                                                        else return $ _previousBrightness keyboard\n                            Just SignalDefault -> case _mode keyboard of\n                                                    LightingDefault -> return $ _previousBrightness keyboard\n                                                    _ -> do setKeyboardBrightness (_previousBrightness keyboard) dbus\n                                                            return $ _previousBrightness keyboard\n                            _ -> return $ _previousBrightness keyboard\n\n    newWorkspaces <- if shouldUpdateWorkspaces inputSignals \n                        then I3.getWorkspacesConfig i3\n                        else return $ _workspaces keyboard\n\n    newBulbBrightness <- handleBulbBrightness (_bulbBrightness state) inputSignals\n\n    let cpuTimeModifier = fst cpu * fst cpu * 5\n    let newState = \n            state { _keyboard = keyboard { _time = _time keyboard + realToFrac deltaTime * cpuTimeModifier\n                                         , _mode = fromMaybe (_mode keyboard) $ maybeSignal >>= signalToMode\n                                         , _workspaces = newWorkspaces \n                                         , _previousBrightness = prevBrightness }\n                  , _language = newLanguage\n                  , _bulbBrightness = newBulbBrightness }\n    let nextFrame = light (isJust maybeSignal || shouldUpdateWorkspaces inputSignals) \n                          dimensions newState\n\n    when (isJust nextFrame) $ setFrame (fromJust nextFrame) dbus\n    delay keyboardUpdateDelay\n\n    let newTime = if shouldUpdateInfo then t else previousUpdateTime\n    step newTime t dbus i3 dimensions cpu keyboardDaemonFile newState\n\nshouldUpdateWorkspaces :: [KeyboardSignal] -> Bool\nshouldUpdateWorkspaces = elem SignalUpdateWorkspaces\n\nshouldSwitchLanguage :: [KeyboardSignal] -> Bool\nshouldSwitchLanguage = elem SignalSwitchlang\n\nhandleBulbBrightness :: Int16 -> [KeyboardSignal] -> IO (Int16)\nhandleBulbBrightness prev signals = mapM handle signals >>= return . sum\n    where handle SignalIncreaseBulbBrightness = Bulb.increaseBrightness prev\n          handle SignalDecreaseBulbBrightness = Bulb.decreaseBrightness prev\n          handle _ = return 0\n\ngetLatestModeSignal :: [KeyboardSignal] -> Maybe KeyboardSignal\ngetLatestModeSignal (x:xs) = case x of \n                                Modifier a -> Just (Modifier a)\n                                SignalDefault -> Just SignalDefault\n                                _ -> getLatestModeSignal xs\n\ngetLatestModeSignal [] = Nothing\n\ngetKeyboardDaemonFile path = do\n    exists <- fileExist path\n    if not exists\n        then createNamedPipe path (ownerReadMode .|. ownerWriteMode .|. namedPipeMode)\n        else return ()\n    openFile path ReadMode\n\nreadAvailableInput f xs = do \n    ready <- hReady f\n    if ready then do char <- hGetChar f\n                     readAvailableInput f ((charToSignal char):xs)\n             else return xs\n\nmain = do\n    dbus <- DBus.connectSession\n    dimensions <- getMatrixDimensions dbus\n    brightness <- getKeyboardBrightness dbus\n\n    startTime <- getPOSIXTime\n    cpu <- getCPUUsage\n\n    i3 <- I3.connectI3\n    ws <- I3.getWorkspacesConfig i3\n\n    let filePath = "/etc/rasiel/keyboardrasiel"\n    keyboardDaemonFile <- getKeyboardDaemonFile filePath\n    setLanguageUs\n    let keyboardState = \n                KeyboardLightingState { _mode = LightingDefault\n                                      , _time = 0.0\n                                      , _workspaces = ws\n                                      , _previousBrightness = brightness}\n    let systemState = SystemState { _keyboard = keyboardState\n                                  , _language = LangUS\n                                  , _bulbBrightness = 100\n                                  }\n    step startTime startTime \n         dbus i3 \n         dimensions cpu \n         keyboardDaemonFile \n         systemState'