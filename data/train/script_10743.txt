b'##################################################################\n# polyFit: generate polynomial terms of data and fit models\n##################################################################\n\n# arguments:\n#   xy: dataframe, response variable is in the last column; in\n#      classification case (indicated by \'use\', this must be either \n#      an R factor or a numeric code for the various classes\n#   deg: the degree of the polynomial terms\n#   maxInteractDeg: the max degree of dummy and nondummy predictor variables\n#      interaction terms\n#   use: can be "lm" for linear regreesion, "glm" for logistic\n#      regression, or "mvrlm" for multivariate-response lm(); the\n#      latter two indicate a classification case\n#   glmMethod: which method ("all" for all-vs-all, "one" for one-vs-all,\n#      "multlog" for multinomial logistic regression)\n#      to use for multi-class classification\n#   cls:  R \'parallel\' cluster; currently not used\n\n# return: the object of class polyFit\n\n# note on RSpectra(): if the full set of eigenvectors is requested,\n# RSpectra() simply calls R\'s built-in eigen(), so we don\'t treat that\n# case here\n\n# NM, 09/19/18: removed dropout option, getting in the way and not\n# useful\n\npolyFit <- function(xy, deg, maxInteractDeg=deg, use = "lm", \n                    glmMethod="one", return_xy = FALSE, \n                    returnPoly = FALSE, noisy = TRUE)\n{\n\n  if (!use %in% c(\'lm\',\'glm\',\'mvrlm\'))\n     stop(\'"use" must be "lm", "glm", or "mvrlm"\')\n \n  nOrigFeatures <- ncol(xy) - 1\n  namesOrigFeatures <- colnames(xy[,1:nOrigFeatures,drop=FALSE])\n\n  xy <- complete(xy, noisy=noisy)\n  \n  xdata <- xy[,-ncol(xy),drop=FALSE]\n\n  y <- xy[,ncol(xy)]\n  if(is.character(y))\n    y <- as.factor(y)\n  # is this a classification problem?\n  classProblem <- is.factor(y) || use == \'mvrlm\'\n  if (classProblem) {\n     classes <- levels(y)\n     if (is.factor(y))  { # change to numeric code for the classes\n        y <- as.numeric(y)\n        numClasses <- 1:length(classes)\n        xy[,ncol(xy)] <- y\n     }\n  } else classes <- FALSE\n\n     k <- 0\n     tmp <- system.time(pMat <- getPoly(xdata, deg, maxInteractDeg))\n     if(noisy) message(\'getPoly time: \', max(tmp, na.rm = TRUE),\'\\n\\n\')\n     polyMat <- pMat$xdata\n\n  retainedNames <- pMat$retainedNames\n  modelFormula <- pMat$modelFormula\n  XtestFormula <- pMat$XtestFormula\n\n  # by now, polyMat is ready for input to lm() etc. in all cases\n\n  # this is the new xy, i.e. the polynomialized version of xy\n  plm.xy <- as.data.frame(cbind(polyMat,y), stringsAsFactors=TRUE)\n\n  # OK, getPoly() taken care of, now find the fit, to be\n  # assigned to ft\n\n  if (use == "lm") {\n    tmp <- system.time(\n       ft <- lm(y~., data = plm.xy)\n    )\n    if(noisy) message(\'lm() time: \', max(tmp, na.rm=TRUE),\'\\n\\n\')\n    glmMethod <- NULL\n  } else if (use == "glm" || use == \'mvrlm\') {\n       if (use == \'glm\') {\n          if (length(numClasses) == 2) {\n            plm.xy$y <- as.numeric(plm.xy$y == numClasses[1])\n            tmp <- system.time(ft <- glm(y~., family = binomial,data = plm.xy))\n            if(noisy) \n              message(\'2-class glm() time: \', max(tmp, na.rm = TRUE),\'\\n\\n\')\n            glmMethod <- NULL\n          }  # end 2-class case\n          else { # more than two classes\n            if (glmMethod == "all") { # all-vs-all\n              tmp <- system.time(ft <- polyAllVsAll(plm.xy, numClasses))\n              if(noisy) \n                message(\'all-vs-all glm() time: \', max(tmp,na.rm=TRUE),\'\\n\\n\')\n            } else if (glmMethod == "one") { # one-vs-all\n              tmp <- system.time(\n                 ft <- polyOneVsAll(plm.xy, numClasses) # cls could be passed here\n              )\n              glmOuts <- ft\n              if(noisy) \n                 message(\'one-vs-all glm() time: \', max(tmp,na.rm=TRUE),\'\\n\\n\')\n            } else if (glmMethod == "multlog") { # multinomial logistics\n              tmp <- system.time(\n              ft <- multinom(y~., plm.xy)\n              )\n              if(noisy) message(\'multlog time: \', max(tmp, na.rm = TRUE), \'\\n\')\n            }\n          } # more than two classes\n      # end \'glm\' case\n      }  else  {  # \'mvrlm\' case\n            # dms <- model.matrix(~ as.factor(y) - 1, y)\n            yf <- as.factor(y)\n            dms <- model.matrix(~yf-1)\n            dms <- as.data.frame(dms, stringsAsFactors=TRUE)\n            dxy <- cbind(plm.xy[,-ncol(plm.xy)],dms)\n            nms <- names(dms)\n            addnames <- paste0(nms,collapse=\',\')\n            frml <- paste0(\'cbind(\',addnames,\') ~ .,data=dxy\')\n            # somehow as.formula() has a problem here, so back to basics\n            cmd <- paste0(\'ft <- lm(\',frml,\')\')\n            eval(parse(text=cmd))\n      }\n\n  }  # end \'glm\'/\'mvrlm\' case\n\n  if (!exists(\'glmOuts\')) glmOuts <- NULL\n  \n  me <- list(xy = if(return_xy) xy else NULL, \n             degree=deg, \n             maxInteractDeg=maxInteractDeg, \n             use=use,\n             poly.xy = if(returnPoly) plm.xy else NULL, \n             fit=ft, \n             nOrigFeatures=nOrigFeatures,\n             namesOrigFeatures=namesOrigFeatures,\n             glmMethod=glmMethod,\n             classProblem=classProblem, \n             classes=classes, \n             retainedNames=retainedNames, \n             modelFormula=modelFormula, \n             XtestFormula=XtestFormula,\n             glmOuts=glmOuts)\n  class(me) <- "polyFit"\n  return(me)\n\n}\n\n\n\n'