b'{-# LANGUAGE InstanceSigs #-}\n\nmodule Parser\n    ( Parser (runP)\n    , ok\n    , isnot\n    , eof\n    , satisfy\n    , char\n    , string\n    , oneOf\n    ) where\n\nimport Control.Applicative (Alternative (..))\nimport Data.Bifunctor (first)\nimport Data.Foldable (asum)\n\nnewtype Parser a = Parser { runP :: String -> Maybe (a, String) }\n\ninstance Functor Parser where\n    fmap :: (a -> b) -> Parser a -> Parser b\n    fmap f (Parser parser) = Parser (fmap (first f) . parser)\n\ninstance Applicative Parser where\n    pure :: a -> Parser a\n    pure a = Parser $ \\s -> Just (a, s)\n\n    (<*>) :: Parser (a -> b) -> Parser a -> Parser b\n    Parser pf <*> Parser pa = Parser $ \\s -> pf s >>= \\(f, t) -> pa t >>= \\(a, r) -> Just (f a, r)\n\ninstance Alternative Parser where\n    empty :: Parser a\n    empty = Parser (const Nothing)\n\n    (<|>) :: Parser a -> Parser a -> Parser a\n    Parser p1 <|> Parser p2 = Parser $ \\s -> p1 s <|> p2 s\n\n-- always succeeds without consuming any input\nok :: Parser ()\nok = Parser $ \\s -> Just ((), s)\n\n-- fails w/o consuming any input if given parser succeeds,\n-- and succeeds if given parser fails\nisnot :: Parser a -> Parser ()\nisnot parser = Parser $ \\s -> case runP parser s of\n    Just _  -> Nothing\n    Nothing -> Just ((), s)\n\n-- checks of end of input stream\neof :: Parser ()\neof = Parser $ \\s -> case s of\n    [] -> Just ((), "")\n    _  -> Nothing\n\n-- consumes only single character and returns it if predicate is true\nsatisfy :: (Char -> Bool) -> Parser Char\nsatisfy p = Parser $ \\s -> case s of\n    []     -> Nothing\n    (x:xs) -> if p x then Just (x, xs) else Nothing\n\n-- consumes given character and returns it\nchar :: Char -> Parser Char\nchar c = satisfy (== c)\n\nstring :: String -> Parser String\nstring = traverse char\n\noneOf :: [String] -> Parser String  -- parse first matched string from list\noneOf = asum . map string\n'