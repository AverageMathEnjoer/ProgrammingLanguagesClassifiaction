b'/*\n    SPDX-FileCopyrightText: 2014-2017 Milian Wolff <mail@milianw.de>\n\n    SPDX-License-Identifier: LGPL-2.1-or-later\n*/\n\n#include "3rdparty/catch.hpp"\n#include "track/trace.h"\n\n#include <algorithm>\n\nusing namespace std;\n\nnamespace {\nbool __attribute__((noinline)) fill(Trace& trace, int depth, int skip)\n{\n    if (!depth) {\n        return trace.fill(skip);\n    } else {\n        return fill(trace, depth - 1, skip);\n    }\n}\n\nvoid validateTrace(const Trace& trace, int expectedSize)\n{\n    SECTION ("validate the trace size") {\n        REQUIRE(trace.size() == expectedSize);\n        REQUIRE(distance(trace.begin(), trace.end()) == trace.size());\n    }\n    SECTION ("validate trace contents") {\n        REQUIRE(find(trace.begin(), trace.end(), Trace::ip_t(0)) == trace.end());\n    }\n}\n}\n\nTEST_CASE ("getting backtrace traces", "[trace]") {\n    Trace trace;\n    validateTrace(trace, 0);\n\n    SECTION ("fill without skipping") {\n        REQUIRE(trace.fill(0));\n        const auto offset = trace.size();\n        REQUIRE(offset > 1);\n        validateTrace(trace, offset);\n\n        SECTION ("fill with skipping") {\n            for (auto skip : {0, 1, 2}) {\n                for (int i = 0; i < 2 * Trace::MAX_SIZE; ++i) {\n                    REQUIRE(fill(trace, i, skip));\n                    const auto expectedSize = min(i + offset + 1 - skip, static_cast<int>(Trace::MAX_SIZE) - skip);\n                    validateTrace(trace, expectedSize);\n                }\n            }\n        }\n    }\n}\n'