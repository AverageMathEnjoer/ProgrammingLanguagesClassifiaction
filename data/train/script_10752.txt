b'package com.bennyhuo.kotlin.coroutinesupdate\n\nimport android.os.Handler\nimport android.os.HandlerThread\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.channels.awaitClose\nimport kotlinx.coroutines.channels.trySendBlocking\nimport kotlinx.coroutines.flow.callbackFlow\nimport kotlinx.coroutines.flow.channelFlow\nimport kotlinx.coroutines.flow.collect\nimport kotlinx.coroutines.flow.flow\nimport java.util.concurrent.CopyOnWriteArrayList\nimport kotlin.concurrent.thread\n\nsuspend fun main() {\n    flowSamples()\n}\n\nsuspend fun flowSamples() {\n    flow {\n        emit(1)\n        emit(2)\n    }.collect {\n        println(it)\n    }\n\n    channelFlow {\n        send(1)\n        withContext(Dispatchers.IO) {\n            send(2)\n        }\n\n        thread {\n            trySendBlocking(3)\n        }.join()\n    }.collect {\n        println(it)\n    }\n\n    callbackFlow {\n        send(1)\n        withContext(Dispatchers.IO) {\n            send(2)\n        }\n\n        awaitClose {\n            // nothing to do.\n            println("closed")\n        }\n    }.collect {\n        println(it)\n    }\n}\n\nsuspend fun callbackFlowSample() {\n    val application = Application()\n    application.start()\n\n\n    val eventFlow = callbackFlow {\n        val callback = Application.Callback {\n            trySendBlocking(it)\n        }\n        application.registerCallback(callback)\n\n        awaitClose {\n            application.unregisterCallback(callback)\n        }\n    }\n\n    val scope = CoroutineScope(Dispatchers.IO)\n    scope.launch {\n        eventFlow.collect {\n            println(it)\n        }\n    }\n\n    delay(5000)\n    scope.cancel()\n\n    delay(10_000)\n    application.stop()\n}\n\n\nclass Application {\n\n    fun interface Callback {\n        fun onCallBack(value: Int)\n    }\n\n    private val handlerThread = HandlerThread("App")\n\n    private val handler by lazy {\n        handlerThread.start()\n        Handler(handlerThread.looper)\n    }\n\n    private val callbacks = CopyOnWriteArrayList<Callback>()\n\n    fun registerCallback(callback: Callback) {\n        this.callbacks += callback\n    }\n\n    fun unregisterCallback(callback: Callback) {\n        this.callbacks -= callback\n    }\n\n    fun start() {\n        runApp()\n    }\n\n    fun stop() {\n        handlerThread.quit()\n    }\n\n    private var eventId = 0\n\n    private fun runApp() {\n        this.callbacks.forEach {\n            it.onCallBack(eventId)\n        }\n\n        eventId++\n        handler.postDelayed(::runApp, 1000)\n    }\n\n}\n\n'