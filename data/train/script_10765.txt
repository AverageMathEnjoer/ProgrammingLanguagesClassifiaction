b'using System;\nusing System.Diagnostics;\nusing System.Text;\n\nnamespace CS_SQLite3\n{\n  using sqlite3_value = CSSQLite.Mem;\n\n  public partial class CSSQLite\n  {\n    /*\n    ** 2008 June 13\n    **\n    ** The author disclaims copyright to this source code.  In place of\n    ** a legal notice, here is a blessing:\n    **\n    **    May you do good and not evil.\n    **    May you find forgiveness for yourself and forgive others.\n    **    May you share freely, never taking more than you give.\n    **\n    *************************************************************************\n    **\n    ** This file contains definitions of global variables and contants.\n    **\n    ** $Id: global.c,v 1.12 2009/02/05 16:31:46 drh Exp $\n    **\n    *************************************************************************\n    **  Included in SQLite3 port to C#-SQLite;  2008 Noah B Hart\n    **  C#-SQLite is an independent reimplementation of the SQLite software library\n    **\n    **  $Header$\n    *************************************************************************\n    */\n    //#include "sqliteInt.h"\n\n\n    /* An array to map all upper-case characters into their corresponding\n    ** lower-case character.\n    **\n    ** SQLite only considers US-ASCII (or EBCDIC) characters.  We do not\n    ** handle case conversions for the UTF character set since the tables\n    ** involved are nearly as big or bigger than SQLite itself.\n    */\n    /* An array to map all upper-case characters into their corresponding\n    ** lower-case character.\n    */\n    static int[] sqlite3UpperToLower = new int[]  {\n#if SQLITE_ASCII\n0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16, 17,\n18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35,\n36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53,\n54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 97, 98, 99,100,101,102,103,\n104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,\n122, 91, 92, 93, 94, 95, 96, 97, 98, 99,100,101,102,103,104,105,106,107,\n108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,\n126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,\n144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,161,\n162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,\n180,181,182,183,184,185,186,187,188,189,190,191,192,193,194,195,196,197,\n198,199,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,\n216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,\n234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,\n252,253,254,255\n#endif\n#if SQLITE_EBCDIC\n0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, /* 0x */\n16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, /* 1x */\n32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, /* 2x */\n48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, /* 3x */\n64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, /* 4x */\n80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, /* 5x */\n96, 97, 66, 67, 68, 69, 70, 71, 72, 73,106,107,108,109,110,111, /* 6x */\n112, 81, 82, 83, 84, 85, 86, 87, 88, 89,122,123,124,125,126,127, /* 7x */\n128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143, /* 8x */\n144,145,146,147,148,149,150,151,152,153,154,155,156,157,156,159, /* 9x */\n160,161,162,163,164,165,166,167,168,169,170,171,140,141,142,175, /* Ax */\n176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191, /* Bx */\n192,129,130,131,132,133,134,135,136,137,202,203,204,205,206,207, /* Cx */\n208,145,146,147,148,149,150,151,152,153,218,219,220,221,222,223, /* Dx */\n224,225,162,163,164,165,166,167,168,169,232,203,204,205,206,207, /* Ex */\n239,240,241,242,243,244,245,246,247,248,249,219,220,221,222,255, /* Fx */\n#endif\n};\n\n    /*\n    ** The following 256 byte lookup table is used to support SQLites built-in\n    ** equivalents to the following standard library functions:\n    **\n    **   isspace()                        0x01\n    **   isalpha()                        0x02\n    **   isdigit()                        0x04\n    **   isalnum()                        0x06\n    **   isxdigit()                       0x08\n    **   toupper()                        0x20\n    **\n    ** Bit 0x20 is set if the mapped character requires translation to upper\n    ** case. i.e. if the character is a lower-case ASCII character.\n    ** If x is a lower-case ASCII character, then its upper-case equivalent\n    ** is (x - 0x20). Therefore toupper() can be implemented as:\n    **\n    **   (x & ~(map[x]&0x20))\n    **\n    ** Standard function tolower() is implemented using the sqlite3UpperToLower[]\n    ** array. tolower() is used more often than toupper() by SQLite.\n    **\n    ** SQLite\'s versions are identical to the standard versions assuming a\n    ** locale of "C". They are implemented as macros in sqliteInt.h.\n    */\n#if SQLITE_ASCII\n    static byte[] sqlite3CtypeMap = new byte[] {\n0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  /* 00..07    ........ */\n0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x00, 0x00,  /* 08..0f    ........ */\n0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  /* 10..17    ........ */\n0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  /* 18..1f    ........ */\n0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  /* 20..27     !"#$%&\' */\n0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  /* 28..2f    ()*+,-./ */\n0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c,  /* 30..37    01234567 */\n0x0c, 0x0c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  /* 38..3f    89:;<=>? */\n\n0x00, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x02,  /* 40..47    @ABCDEFG */\n0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02,  /* 48..4f    HIJKLMNO */\n0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02,  /* 50..57    PQRSTUVW */\n0x02, 0x02, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00,  /* 58..5f    XYZ[\\]^_ */\n0x00, 0x2a, 0x2a, 0x2a, 0x2a, 0x2a, 0x2a, 0x22,  /* 60..67    `abcdefg */\n0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,  /* 68..6f    hijklmno */\n0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,  /* 70..77    pqrstuvw */\n0x22, 0x22, 0x22, 0x00, 0x00, 0x00, 0x00, 0x00,  /* 78..7f    xyz{|}~. */\n\n0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  /* 80..87    ........ */\n0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  /* 88..8f    ........ */\n0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  /* 90..97    ........ */\n0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  /* 98..9f    ........ */\n0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  /* a0..a7    ........ */\n0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  /* a8..af    ........ */\n0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  /* b0..b7    ........ */\n0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  /* b8..bf    ........ */\n\n0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  /* c0..c7    ........ */\n0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  /* c8..cf    ........ */\n0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  /* d0..d7    ........ */\n0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  /* d8..df    ........ */\n0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  /* e0..e7    ........ */\n0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  /* e8..ef    ........ */\n0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  /* f0..f7    ........ */\n0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00   /* f8..ff    ........ */\n};\n#endif\n\n\n    /*\n** The following singleton contains the global configuration for\n** the SQLite library.\n*/\n    static Sqlite3Config sqlite3Config = new Sqlite3Config(\n    SQLITE_DEFAULT_MEMSTATUS, /* bMemstat */\n    1,                        /* bCoreMutex */\n    SQLITE_THREADSAFE == 1,   /* bFullMutex */\n    0x7ffffffe,               /* mxStrlen */\n    100,                      /* szLookaside */\n    500,                      /* nLookaside */\n    new sqlite3_mem_methods(),   /* m */\n    new sqlite3_mutex_methods( null, null, null, null, null, null, null, null, null ), /* mutex */\n    new sqlite3_pcache_methods(),/* pcache */\n    null,                      /* pHeap */\n    0,                         /* nHeap */\n    0, 0,                      /* mnHeap, mxHeap */\n    null,                      /* pScratch */\n    0,                         /* szScratch */\n    0,                         /* nScratch */\n    null,                      /* pPage */\n    0,                         /* szPage */\n    0,                         /* nPage */\n    0,                         /* mxParserStack */\n    false,                     /* sharedCacheEnabled */\n      /* All the rest need to always be zero */\n    0,                         /* isInit */\n    0,                         /* inProgress */\n    0,                         /* isMallocInit */\n    null,                      /* pInitMutex */\n    0                          /* nRefInitMutex */\n    );\n\n    /*\n    ** Hash table for global functions - functions common to all\n    ** database connections.  After initialization, this table is\n    ** read-only.\n    */\n    static FuncDefHash sqlite3GlobalFunctions;\n\n    /*\n    ** The value of the "pending" byte must be 0x40000000 (1 byte past the\n    ** 1-gibabyte boundary) in a compatible database.  SQLite never uses\n    ** the database page that contains the pending byte.  It never attempts\n    ** to read or write that page.  The pending byte page is set assign\n    ** for use by the VFS layers as space for managing file locks.\n    **\n    ** During testing, it is often desirable to move the pending byte to\n    ** a different position in the file.  This allows code that has to\n    ** deal with the pending byte to run on files that are much smaller\n    ** than 1 GiB.  The sqlite3_test_control() interface can be used to\n    ** move the pending byte.\n    **\n    ** IMPORTANT:  Changing the pending byte to any value other than\n    ** 0x40000000 results in an incompatible database file format!\n    ** Changing the pending byte during operating results in undefined\n    ** and dileterious behavior.\n    */\n    static int sqlite3PendingByte = 0x40000000;\n  }\n}\n'