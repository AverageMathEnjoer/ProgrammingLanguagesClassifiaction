b'/**\n * MIT License\n *\n * Copyright (c) 2017 Thibaut Goetghebuer-Planchon <tessil@gmx.com>\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the "Software"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n#define BOOST_TEST_DYN_LINK\n\n#include <tsl/robin_map.h>\n\n#include <boost/test/unit_test.hpp>\n#include <cstddef>\n#include <cstdlib>\n#include <functional>\n#include <limits>\n#include <stdexcept>\n#include <type_traits>\n#include <utility>\n\n#include "utils.h"\n\nstatic std::size_t nb_custom_allocs = 0;\n\ntemplate <typename T>\nclass custom_allocator\n{\npublic:\n    using value_type = T;\n    using pointer = T*;\n    using const_pointer = const T*;\n    using reference = T&;\n    using const_reference = const T&;\n    using size_type = std::size_t;\n    using difference_type = std::ptrdiff_t;\n    using propagate_on_container_move_assignment = std::true_type;\n\n    template <typename U>\n    struct rebind\n    {\n        using other = custom_allocator<U>;\n    };\n\n    custom_allocator() = default;\n    custom_allocator(const custom_allocator&) = default;\n\n    template <typename U>\n    custom_allocator(const custom_allocator<U>&)\n    {\n    }\n\n    pointer address(reference x) const noexcept\n    {\n        return &x;\n    }\n\n    const_pointer address(const_reference x) const noexcept\n    {\n        return &x;\n    }\n\n    pointer allocate(size_type n, const void* /*hint*/ = 0)\n    {\n        nb_custom_allocs++;\n\n        pointer ptr = static_cast<pointer>(std::malloc(n * sizeof(T)));\n        if (ptr == nullptr) {\n#ifdef TSL_RH_NO_EXCEPTIONS\n            std::abort();\n#else\n            throw std::bad_alloc();\n#endif\n        }\n\n        return ptr;\n    }\n\n    void deallocate(T* p, size_type /*n*/)\n    {\n        std::free(p);\n    }\n\n    size_type max_size() const noexcept\n    {\n        return std::numeric_limits<size_type>::max() / sizeof(value_type);\n    }\n\n    template <typename U, typename... Args>\n    void construct(U* p, Args&&... args)\n    {\n        ::new (static_cast<void*>(p)) U(std::forward<Args>(args)...);\n    }\n\n    template <typename U>\n    void destroy(U* p)\n    {\n        p->~U();\n    }\n};\n\ntemplate <class T, class U>\nbool operator==(const custom_allocator<T>&, const custom_allocator<U>&)\n{\n    return true;\n}\n\ntemplate <class T, class U>\nbool operator!=(const custom_allocator<T>&, const custom_allocator<U>&)\n{\n    return false;\n}\n\n// TODO Avoid overloading new to check number of global new\n// static std::size_t nb_global_new = 0;\n// void* operator new(std::size_t sz) {\n//     nb_global_new++;\n//     return std::malloc(sz);\n// }\n//\n// void operator delete(void* ptr) noexcept {\n//     std::free(ptr);\n// }\n\nBOOST_AUTO_TEST_SUITE(test_custom_allocator)\n\nBOOST_AUTO_TEST_CASE(test_custom_allocator_1)\n{\n    //    nb_global_new = 0;\n    nb_custom_allocs = 0;\n\n    tsl::robin_map<int, int, std::hash<int>, std::equal_to<int>, custom_allocator<std::pair<int, int>>> map;\n\n    const int nb_elements = 1000;\n    for (int i = 0; i < nb_elements; i++) {\n        map.insert({i, i * 2});\n    }\n\n    BOOST_CHECK_NE(nb_custom_allocs, 0);\n    //    BOOST_CHECK_EQUAL(nb_global_new, 0);\n}\n\nBOOST_AUTO_TEST_SUITE_END()\n'