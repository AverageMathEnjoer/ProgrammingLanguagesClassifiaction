b'using System;\nusing System.Diagnostics;\nusing System.Text;\n\nusing i64 = System.Int64;\nusing u8 = System.Byte;\nusing u32 = System.UInt32;\n\nusing Pgno = System.UInt32;\n\n\nnamespace CS_SQLite3\n{\n  using sqlite3_int64 = System.Int64;\n  using DbPage = CSSQLite.PgHdr;\n  public partial class CSSQLite\n  {\n    /*\n    ** 2009 January 28\n    **\n    ** The author disclaims copyright to this source code.  In place of\n    ** a legal notice, here is a blessing:\n    **\n    **    May you do good and not evil.\n    **    May you find forgiveness for yourself and forgive others.\n    **    May you share freely, never taking more than you give.\n    **\n    *************************************************************************\n    ** This file contains the implementation of the sqlite3_backup_XXX()\n    ** API functions and the related features.\n    **\n    ** $Id: backup.c,v 1.19 2009/07/06 19:03:13 drh Exp $\n    **\n    *************************************************************************\n    **  Included in SQLite3 port to C#-SQLite;  2008 Noah B Hart\n    **  C#-SQLite is an independent reimplementation of the SQLite software library\n    **\n    **  $Header$\n    *************************************************************************\n    */\n    //#include "sqliteInt.h"\n    //#include "btreeInt.h"\n\n    /* Macro to find the minimum of two numeric values.\n    */\n#if !MIN\n    //# define MIN(x,y) ((x)<(y)?(x):(y))\n#endif\n\n    /*\n** Structure allocated for each backup operation.\n*/\n    public class sqlite3_backup\n    {\n      public sqlite3 pDestDb;         /* Destination database handle */\n      public Btree pDest;             /* Destination b-tree file */\n      public u32 iDestSchema;         /* Original schema cookie in destination */\n      public int bDestLocked;         /* True once a write-transaction is open on pDest */\n\n      public Pgno iNext;              /* Page number of the next source page to copy */\n      public sqlite3 pSrcDb;          /* Source database handle */\n      public Btree pSrc;              /* Source b-tree file */\n\n      public int rc;                  /* Backup process error code */\n\n      /* These two variables are set by every call to backup_step(). They are\n      ** read by calls to backup_remaining() and backup_pagecount().\n      */\n      public Pgno nRemaining;         /* Number of pages left to copy */\n      public Pgno nPagecount;         /* Total number of pages to copy */\n\n      public int isAttached;          /* True once backup has been registered with pager */\n      public sqlite3_backup pNext;    /* Next backup associated with source pager */\n    };\n\n    /*\n    ** THREAD SAFETY NOTES:\n    **\n    **   Once it has been created using backup_init(), a single sqlite3_backup\n    **   structure may be accessed via two groups of thread-safe entry points:\n    **\n    **     * Via the sqlite3_backup_XXX() API function backup_step() and\n    **       backup_finish(). Both these functions obtain the source database\n    **       handle mutex and the mutex associated with the source BtShared\n    **       structure, in that order.\n    **\n    **     * Via the BackupUpdate() and BackupRestart() functions, which are\n    **       invoked by the pager layer to report various state changes in\n    **       the page cache associated with the source database. The mutex\n    **       associated with the source database BtShared structure will always\n    **       be held when either of these functions are invoked.\n    **\n    **   The other sqlite3_backup_XXX() API functions, backup_remaining() and\n    **   backup_pagecount() are not thread-safe functions. If they are called\n    **   while some other thread is calling backup_step() or backup_finish(),\n    **   the values returned may be invalid. There is no way for a call to\n    **   BackupUpdate() or BackupRestart() to interfere with backup_remaining()\n    **   or backup_pagecount().\n    **\n    **   Depending on the SQLite configuration, the database handles and/or\n    **   the Btree objects may have their own mutexes that require locking.\n    **   Non-sharable Btrees (in-memory databases for example), do not have\n    **   associated mutexes.\n    */\n\n    /*\n    ** Return a pointer corresponding to database zDb (i.e. "main", "temp")\n    ** in connection handle pDb. If such a database cannot be found, return\n    ** a NULL pointer and write an error message to pErrorDb.\n    **\n    ** If the "temp" database is requested, it may need to be opened by this\n    ** function. If an error occurs while doing so, return 0 and write an\n    ** error message to pErrorDb.\n    */\n    static Btree findBtree( sqlite3 pErrorDb, sqlite3 pDb, string zDb )\n    {\n      int i = sqlite3FindDbName( pDb, zDb );\n\n      if ( i == 1 )\n      {\n        Parse pParse;\n        int rc = 0;\n        pParse = new Parse();//sqlite3StackAllocZero(pErrorDb, sizeof(*pParse));\n        if ( pParse == null )\n        {\n          sqlite3Error( pErrorDb, SQLITE_NOMEM, "out of memory" );\n          rc = SQLITE_NOMEM;\n        }\n        else\n        {\n          pParse.db = pDb;\n          if ( sqlite3OpenTempDatabase( pParse ) != 0 )\n          {\n            sqlite3ErrorClear( pParse );\n            sqlite3Error( pErrorDb, pParse.rc, "%s", pParse.zErrMsg );\n            rc = SQLITE_ERROR;\n          }\n          //sqlite3StackFree( pErrorDb, pParse );\n        }\n        if ( rc != 0 )\n        {\n          return null;\n        }\n      }\n\n      if ( i < 0 )\n      {\n        sqlite3Error( pErrorDb, SQLITE_ERROR, "unknown database %s", zDb );\n        return null;\n      }\n\n      return pDb.aDb[i].pBt;\n    }\n\n    /*\n    ** Create an sqlite3_backup process to copy the contents of zSrcDb from\n    ** connection handle pSrcDb to zDestDb in pDestDb. If successful, return\n    ** a pointer to the new sqlite3_backup object.\n    **\n    ** If an error occurs, NULL is returned and an error code and error message\n    ** stored in database handle pDestDb.\n    */\n    public static sqlite3_backup sqlite3_backup_init(\n    sqlite3 pDestDb,                 /* Database to write to */\n    string zDestDb,                  /* Name of database within pDestDb */\n    sqlite3 pSrcDb,                  /* Database connection to read from */\n    string zSrcDb                    /* Name of database within pSrcDb */\n    )\n    {\n      sqlite3_backup p;                    /* Value to return */\n\n      /* Lock the source database handle. The destination database\n      ** handle is not locked in this routine, but it is locked in\n      ** sqlite3_backup_step(). The user is required to ensure that no\n      ** other thread accesses the destination handle for the duration\n      ** of the backup operation.  Any attempt to use the destination\n      ** database connection while a backup is in progress may cause\n      ** a malfunction or a deadlock.\n      */\n      sqlite3_mutex_enter( pSrcDb.mutex );\n      sqlite3_mutex_enter( pDestDb.mutex );\n\n      if ( pSrcDb == pDestDb )\n      {\n        sqlite3Error(\n        pDestDb, SQLITE_ERROR, "source and destination must be distinct"\n        );\n        p = null;\n      }\n      else\n      {\n        /* Allocate space for a new sqlite3_backup object */\n        p = new sqlite3_backup();// (sqlite3_backup)sqlite3_malloc( sizeof( sqlite3_backup ) );\n        //if ( null == p )\n        //{\n        //  sqlite3Error( pDestDb, SQLITE_NOMEM, 0 );\n        //}\n      }\n\n      /* If the allocation succeeded, populate the new object. */\n      if ( p != null )\n      {\n        // memset( p, 0, sizeof( sqlite3_backup ) );\n        p.pSrc = findBtree( pDestDb, pSrcDb, zSrcDb );\n        p.pDest = findBtree( pDestDb, pDestDb, zDestDb );\n        p.pDestDb = pDestDb;\n        p.pSrcDb = pSrcDb;\n        p.iNext = 1;\n        p.isAttached = 0;\n\n        if ( null == p.pSrc || null == p.pDest )\n        {\n          /* One (or both) of the named databases did not exist. An error has\n          ** already been written into the pDestDb handle. All that is left\n          ** to do here is free the sqlite3_backup structure.\n          */\n          //sqlite3_free( ref p );\n          p = null;\n        }\n      }\n\n      if ( p != null )\n      {\n        p.pSrc.nBackup++;\n      }\n\n      sqlite3_mutex_leave( pDestDb.mutex );\n      sqlite3_mutex_leave( pSrcDb.mutex );\n      return p;\n    }\n\n    /*\n    ** Argument rc is an SQLite error code. Return true if this error is\n    ** considered fatal if encountered during a backup operation. All errors\n    ** are considered fatal except for SQLITE_BUSY and SQLITE_LOCKED.\n    */\n    static bool isFatalError( int rc )\n    {\n      return ( rc != SQLITE_OK && rc != SQLITE_BUSY && ALWAYS( rc != SQLITE_LOCKED ) );\n    }\n\n    /*\n    ** Parameter zSrcData points to a buffer containing the data for\n    ** page iSrcPg from the source database. Copy this data into the\n    ** destination database.\n    */\n    static int backupOnePage( sqlite3_backup p, Pgno iSrcPg, byte[] zSrcData )\n    {\n      Pager pDestPager = sqlite3BtreePager( p.pDest );\n      int nSrcPgsz = sqlite3BtreeGetPageSize( p.pSrc );\n      int nDestPgsz = sqlite3BtreeGetPageSize( p.pDest );\n      int nCopy = MIN( nSrcPgsz, nDestPgsz );\n      i64 iEnd = (i64)iSrcPg * (i64)nSrcPgsz;\n\n      int rc = SQLITE_OK;\n      i64 iOff;\n\n      Debug.Assert( p.bDestLocked != 0 );\n      Debug.Assert( !isFatalError( p.rc ) );\n      Debug.Assert( iSrcPg != PENDING_BYTE_PAGE( p.pSrc.pBt ) );\n      Debug.Assert( zSrcData != null );\n\n      /* Catch the case where the destination is an in-memory database and the\n      ** page sizes of the source and destination differ.\n      */\n      if ( nSrcPgsz != nDestPgsz && sqlite3PagerIsMemdb( sqlite3BtreePager( p.pDest ) ) )\n      {\n        rc = SQLITE_READONLY;\n      }\n\n      /* This loop runs once for each destination page spanned by the source\n      ** page. For each iteration, variable iOff is set to the byte offset\n      ** of the destination page.\n      */\n      for ( iOff = iEnd - (i64)nSrcPgsz ; rc == SQLITE_OK && iOff < iEnd ; iOff += nDestPgsz )\n      {\n        DbPage pDestPg = null;\n        u32 iDest = (u32)( iOff / nDestPgsz ) + 1;\n        if ( iDest == PENDING_BYTE_PAGE( p.pDest.pBt ) ) continue;\n        if ( SQLITE_OK == ( rc = sqlite3PagerGet( pDestPager, iDest, ref pDestPg ) )\n        && SQLITE_OK == ( rc = sqlite3PagerWrite( pDestPg ) )\n        )\n        {\n          //string zIn = &zSrcData[iOff%nSrcPgsz];\n          byte[] zDestData = sqlite3PagerGetData( pDestPg );\n          //string zOut = &zDestData[iOff % nDestPgsz];\n\n          /* Copy the data from the source page into the destination page.\n          ** Then clear the Btree layer MemPage.isInit flag. Both this module\n          ** and the pager code use this trick (clearing the first byte\n          ** of the page \'extra\' space to invalidate the Btree layers\n          ** cached parse of the page). MemPage.isInit is marked\n          ** "MUST BE FIRST" for this purpose.\n          */\n          Buffer.BlockCopy( zSrcData, (int)( iOff % nSrcPgsz ), zDestData, (int)( iOff % nDestPgsz ), nCopy );// memcpy( zOut, zIn, nCopy );\n          sqlite3PagerGetExtra( pDestPg ).isInit = 0;// ( sqlite3PagerGetExtra( pDestPg ) )[0] = 0;\n        }\n        sqlite3PagerUnref( pDestPg );\n      }\n\n      return rc;\n    }\n\n    /*\n    ** If pFile is currently larger than iSize bytes, then truncate it to\n    ** exactly iSize bytes. If pFile is not larger than iSize bytes, then\n    ** this function is a no-op.\n    **\n    ** Return SQLITE_OK if everything is successful, or an SQLite error\n    ** code if an error occurs.\n    */\n    static int backupTruncateFile( sqlite3_file pFile, int iSize )\n    {\n      int iCurrent = 0;\n      int rc = sqlite3OsFileSize( pFile, ref iCurrent );\n      if ( rc == SQLITE_OK && iCurrent > iSize )\n      {\n        rc = sqlite3OsTruncate( pFile, iSize );\n      }\n      return rc;\n    }\n\n    /*\n    ** Register this backup object with the associated source pager for\n    ** callbacks when pages are changed or the cache invalidated.\n    */\n    static void attachBackupObject( sqlite3_backup p )\n    {\n      sqlite3_backup pp;\n      Debug.Assert( sqlite3BtreeHoldsMutex( p.pSrc ) );\n      pp = sqlite3PagerBackupPtr( sqlite3BtreePager( p.pSrc ) );\n      p.pNext = pp;\n      sqlite3BtreePager( p.pSrc ).pBackup = p; //*pp = p;\n      p.isAttached = 1;\n    }\n\n    /*\n    ** Copy nPage pages from the source b-tree to the destination.\n    */\n    public static int sqlite3_backup_step( sqlite3_backup p, int nPage )\n    {\n      int rc;\n\n      sqlite3_mutex_enter( p.pSrcDb.mutex );\n      sqlite3BtreeEnter( p.pSrc );\n      if ( p.pDestDb != null )\n      {\n        sqlite3_mutex_enter( p.pDestDb.mutex );\n      }\n\n      rc = p.rc;\n      if ( !isFatalError( rc ) )\n      {\n        Pager pSrcPager = sqlite3BtreePager( p.pSrc );    /* Source pager */\n        Pager pDestPager = sqlite3BtreePager( p.pDest );   /* Dest pager */\n        int ii;                            /* Iterator variable */\n        int nSrcPage = -1;                 /* Size of source db in pages */\n        int bCloseTrans = 0;               /* True if src db requires unlocking */\n\n        /* If the source pager is currently in a write-transaction, return\n        ** SQLITE_BUSY immediately.\n        */\n        if ( p.pDestDb != null && p.pSrc.pBt.inTransaction == TRANS_WRITE )\n        {\n          rc = SQLITE_BUSY;\n        }\n        else\n        {\n          rc = SQLITE_OK;\n        }\n\n        /* Lock the destination database, if it is not locked already. */\n        if ( SQLITE_OK == rc && p.bDestLocked == 0\n        && SQLITE_OK == ( rc = sqlite3BtreeBeginTrans( p.pDest, 2 ) )\n        )\n        {\n          p.bDestLocked = 1;\n          sqlite3BtreeGetMeta( p.pDest, BTREE_SCHEMA_VERSION, ref p.iDestSchema );\n        }\n\n        /* If there is no open read-transaction on the source database, open\n        ** one now. If a transaction is opened here, then it will be closed\n        ** before this function exits.\n        */\n        if ( rc == SQLITE_OK && !sqlite3BtreeIsInReadTrans( p.pSrc ) )\n        {\n          rc = sqlite3BtreeBeginTrans( p.pSrc, 0 );\n          bCloseTrans = 1;\n        }\n\n        /* Now that there is a read-lock on the source database, query the\n        ** source pager for the number of pages in the database.\n        */\n        if ( rc == SQLITE_OK )\n        {\n          rc = sqlite3PagerPagecount( pSrcPager, ref nSrcPage );\n        }\n        for ( ii = 0 ; ( nPage < 0 || ii < nPage ) && p.iNext <= (Pgno)nSrcPage && 0 == rc ; ii++ )\n        {\n          Pgno iSrcPg = p.iNext;                 /* Source page number */\n          if ( iSrcPg != PENDING_BYTE_PAGE( p.pSrc.pBt ) )\n          {\n            DbPage pSrcPg = null;                             /* Source page object */\n            rc = sqlite3PagerGet( pSrcPager, (u32)iSrcPg, ref pSrcPg );\n            if ( rc == SQLITE_OK )\n            {\n              rc = backupOnePage( p, iSrcPg, sqlite3PagerGetData( pSrcPg ) );\n              sqlite3PagerUnref( pSrcPg );\n            }\n          }\n          p.iNext++;\n        }\n        if ( rc == SQLITE_OK )\n        {\n          p.nPagecount = (u32)nSrcPage;\n          p.nRemaining = (u32)( nSrcPage + 1 - p.iNext );\n          if ( p.iNext > (Pgno)nSrcPage )\n          {\n            rc = SQLITE_DONE;\n          }\n          else if ( 0 == p.isAttached )\n          {\n            attachBackupObject( p );\n          }\n        }\n\n\n          /* Update the schema version field in the destination database. This\n          ** is to make sure that the schema-version really does change in\n          ** the case where the source and destination databases have the\n          ** same schema version.\n          */\n        if ( rc == SQLITE_DONE\n         && ( rc = sqlite3BtreeUpdateMeta( p.pDest, 1, p.iDestSchema + 1 ) ) == SQLITE_OK\n        )\n        {\n          int nSrcPagesize = sqlite3BtreeGetPageSize( p.pSrc );\n          int nDestPagesize = sqlite3BtreeGetPageSize( p.pDest );\n          int nDestTruncate;\n          if ( p.pDestDb != null )\n          {\n            sqlite3ResetInternalSchema( p.pDestDb, 0 );\n          }\n\n          /* Set nDestTruncate to the final number of pages in the destination\n          ** database. The complication here is that the destination page\n          ** size may be different to the source page size.\n          **\n          ** If the source page size is smaller than the destination page size,\n          ** round up. In this case the call to sqlite3OsTruncate() below will\n          ** fix the size of the file. However it is important to call\n          ** sqlite3PagerTruncateImage() here so that any pages in the\n          ** destination file that lie beyond the nDestTruncate page mark are\n          ** journalled by PagerCommitPhaseOne() before they are destroyed\n          ** by the file truncation.\n          */\n          if ( nSrcPagesize < nDestPagesize )\n          {\n            int ratio = nDestPagesize / nSrcPagesize;\n            nDestTruncate = ( nSrcPage + ratio - 1 ) / ratio;\n            if ( nDestTruncate == (int)PENDING_BYTE_PAGE( p.pDest.pBt ) )\n            {\n              nDestTruncate--;\n            }\n          }\n          else\n          {\n            nDestTruncate = nSrcPage * ( nSrcPagesize / nDestPagesize );\n          }\n          sqlite3PagerTruncateImage( pDestPager, (u32)nDestTruncate );\n\n          if ( nSrcPagesize < nDestPagesize )\n          {\n            /* If the source page-size is smaller than the destination page-size,\n            ** two extra things may need to happen:\n            **\n            **   * The destination may need to be truncated, and\n            **\n            **   * Data stored on the pages immediately following the\n            **     pending-byte page in the source database may need to be\n            **     copied into the destination database.\n            */\n            u32 iSize = (u32)nSrcPagesize * (u32)nSrcPage;\n            sqlite3_file pFile = sqlite3PagerFile( pDestPager );\n\n            Debug.Assert( pFile != null );\n            Debug.Assert( (i64)nDestTruncate * (i64)nDestPagesize >= iSize || (\n            nDestTruncate == (int)( PENDING_BYTE_PAGE( p.pDest.pBt ) - 1 )\n            && iSize >= PENDING_BYTE && iSize <= PENDING_BYTE + nDestPagesize\n            ) );\n            if ( SQLITE_OK == ( rc = sqlite3PagerCommitPhaseOne( pDestPager, null, true ) )\n            && SQLITE_OK == ( rc = backupTruncateFile( pFile, (int)iSize ) )\n            && SQLITE_OK == ( rc = sqlite3PagerSync( pDestPager ) )\n            )\n            {\n              i64 iOff;\n              i64 iEnd = MIN( PENDING_BYTE + nDestPagesize, iSize );\n              for (\n              iOff = PENDING_BYTE + nSrcPagesize ;\n              rc == SQLITE_OK && iOff < iEnd ;\n              iOff += nSrcPagesize\n              )\n              {\n                PgHdr pSrcPg = null;\n                u32 iSrcPg = (u32)( ( iOff / nSrcPagesize ) + 1 );\n                rc = sqlite3PagerGet( pSrcPager, iSrcPg, ref pSrcPg );\n                if ( rc == SQLITE_OK )\n                {\n                  byte[] zData = sqlite3PagerGetData( pSrcPg );\n                  rc = sqlite3OsWrite( pFile, zData, nSrcPagesize, iOff );\n                }\n                sqlite3PagerUnref( pSrcPg );\n              }\n            }\n          }\n          else\n          {\n            rc = sqlite3PagerCommitPhaseOne( pDestPager, null, false );\n          }\n\n          /* Finish committing the transaction to the destination database. */\n          if ( SQLITE_OK == rc\n          && SQLITE_OK == ( rc = sqlite3BtreeCommitPhaseTwo( p.pDest ) )\n          )\n          {\n            rc = SQLITE_DONE;\n          }\n        }\n\n        /* If bCloseTrans is true, then this function opened a read transaction\n        ** on the source database. Close the read transaction here. There is\n        ** no need to check the return values of the btree methods here, as\n        ** "committing" a read-only transaction cannot fail.\n        */\n        if ( bCloseTrans != 0 )\n        {\n#if !NDEBUG || SQLITE_COVERAGE_TEST\n          //TESTONLY( int rc2 );\n          //TESTONLY( rc2  = ) sqlite3BtreeCommitPhaseOne(p.pSrc, 0);\n          //TESTONLY( rc2 |= ) sqlite3BtreeCommitPhaseTwo(p.pSrc);\n          int rc2;\n          rc2 = sqlite3BtreeCommitPhaseOne( p.pSrc, "" );\n          rc2 |= sqlite3BtreeCommitPhaseTwo( p.pSrc );\n          Debug.Assert( rc2 == SQLITE_OK );\n#else\nsqlite3BtreeCommitPhaseOne(p.pSrc, null);\nsqlite3BtreeCommitPhaseTwo(p.pSrc);\n#endif\n        }\n\n        p.rc = rc;\n      }\n      if ( p.pDestDb != null )\n      {\n        sqlite3_mutex_leave( p.pDestDb.mutex );\n      }\n      sqlite3BtreeLeave( p.pSrc );\n      sqlite3_mutex_leave( p.pSrcDb.mutex );\n      return rc;\n    }\n\n    /*\n    ** Release all resources associated with an sqlite3_backup* handle.\n    */\n    public static int sqlite3_backup_finish( sqlite3_backup p )\n    {\n      sqlite3_backup pp;                 /* Ptr to head of pagers backup list */\n      sqlite3_mutex mutex;               /* Mutex to protect source database */\n      int rc;                            /* Value to return */\n\n      /* Enter the mutexes */\n      if ( p == null ) return SQLITE_OK;\n      sqlite3_mutex_enter( p.pSrcDb.mutex );\n      sqlite3BtreeEnter( p.pSrc );\n      mutex = p.pSrcDb.mutex;\n      if ( p.pDestDb != null )\n      {\n        sqlite3_mutex_enter( p.pDestDb.mutex );\n      }\n\n      /* Detach this backup from the source pager. */\n      if ( p.pDestDb != null )\n      {\n        p.pSrc.nBackup--;\n      }\n      if ( p.isAttached != 0 )\n      {\n        pp = sqlite3PagerBackupPtr( sqlite3BtreePager( p.pSrc ) );\n        while ( pp != p )\n        {\n          pp = ( pp ).pNext;\n        }\n        sqlite3BtreePager( p.pSrc ).pBackup = p.pNext;\n      }\n\n      /* If a transaction is still open on the Btree, roll it back. */\n      sqlite3BtreeRollback( p.pDest );\n\n      /* Set the error code of the destination database handle. */\n      rc = ( p.rc == SQLITE_DONE ) ? SQLITE_OK : p.rc;\n      sqlite3Error( p.pDestDb, rc, 0 );\n\n      /* Exit the mutexes and free the backup context structure. */\n      if ( p.pDestDb != null )\n      {\n        sqlite3_mutex_leave( p.pDestDb.mutex );\n      }\n      sqlite3BtreeLeave( p.pSrc );\n      if ( p.pDestDb != null )\n      {\n        //sqlite3_free( ref p );\n      }\n      sqlite3_mutex_leave( mutex );\n      return rc;\n    }\n\n    /*\n    ** Return the number of pages still to be backed up as of the most recent\n    ** call to sqlite3_backup_step().\n    */\n    static int sqlite3_backup_remaining( sqlite3_backup p )\n    {\n      return (int)p.nRemaining;\n    }\n\n    /*\n    ** Return the total number of pages in the source database as of the most\n    ** recent call to sqlite3_backup_step().\n    */\n    static int sqlite3_backup_pagecount( sqlite3_backup p )\n    {\n      return (int)p.nPagecount;\n    }\n\n    /*\n    ** This function is called after the contents of page iPage of the\n    ** source database have been modified. If page iPage has already been\n    ** copied into the destination database, then the data written to the\n    ** destination is now invalidated. The destination copy of iPage needs\n    ** to be updated with the new data before the backup operation is\n    ** complete.\n    **\n    ** It is assumed that the mutex associated with the BtShared object\n    ** corresponding to the source database is held when this function is\n    ** called.\n    */\n    static void sqlite3BackupUpdate( sqlite3_backup pBackup, Pgno iPage, byte[] aData )\n    {\n      sqlite3_backup p;                   /* Iterator variable */\n      for ( p = pBackup ; p != null ; p = p.pNext )\n      {\n        Debug.Assert( sqlite3_mutex_held( p.pSrc.pBt.mutex ) );\n        if ( !isFatalError( p.rc ) && iPage < p.iNext )\n        {\n          /* The backup process p has already copied page iPage. But now it\n          ** has been modified by a transaction on the source pager. Copy\n          ** the new data into the backup.\n          */\n          int rc = backupOnePage( p, iPage, aData );\n          Debug.Assert( rc != SQLITE_BUSY && rc != SQLITE_LOCKED );\n          if ( rc != SQLITE_OK )\n          {\n            p.rc = rc;\n          }\n        }\n      }\n    }\n\n    /*\n    ** Restart the backup process. This is called when the pager layer\n    ** detects that the database has been modified by an external database\n    ** connection. In this case there is no way of knowing which of the\n    ** pages that have been copied into the destination database are still\n    ** valid and which are not, so the entire process needs to be restarted.\n    **\n    ** It is assumed that the mutex associated with the BtShared object\n    ** corresponding to the source database is held when this function is\n    ** called.\n    */\n    static void sqlite3BackupRestart( sqlite3_backup pBackup )\n    {\n      sqlite3_backup p;                   /* Iterator variable */\n      for ( p = pBackup ; p != null ; p = p.pNext )\n      {\n        Debug.Assert( sqlite3_mutex_held( p.pSrc.pBt.mutex ) );\n        p.iNext = 1;\n      }\n    }\n\n#if !SQLITE_OMIT_VACUUM\n    /*\n** Copy the complete content of pBtFrom into pBtTo.  A transaction\n** must be active for both files.\n**\n** The size of file pTo may be reduced by this operation. If anything\n** goes wrong, the transaction on pTo is rolled back. If successful, the\n** transaction is committed before returning.\n*/\n    static int sqlite3BtreeCopyFile( Btree pTo, Btree pFrom )\n    {\n      int rc;\n      sqlite3_backup b;\n      sqlite3BtreeEnter( pTo );\n      sqlite3BtreeEnter( pFrom );\n\n      /* Set up an sqlite3_backup object. sqlite3_backup.pDestDb must be set\n      ** to 0. This is used by the implementations of sqlite3_backup_step()\n      ** and sqlite3_backup_finish() to detect that they are being called\n      ** from this function, not directly by the user.\n      */\n      b = new sqlite3_backup();// memset( &b, 0, sizeof( b ) );\n      b.pSrcDb = pFrom.db;\n      b.pSrc = pFrom;\n      b.pDest = pTo;\n      b.iNext = 1;\n\n      /* 0x7FFFFFFF is the hard limit for the number of pages in a database\n      ** file. By passing this as the number of pages to copy to\n      ** sqlite3_backup_step(), we can guarantee that the copy finishes\n      ** within a single call (unless an error occurs). The Debug.Assert() statement\n      ** checks this assumption - (p.rc) should be set to either SQLITE_DONE\n      ** or an error code.\n      */\n      sqlite3_backup_step( b, 0x7FFFFFFF );\n      Debug.Assert( b.rc != SQLITE_OK );\n      rc = sqlite3_backup_finish( b );\n      if ( rc == SQLITE_OK )\n      {\n        pTo.pBt.pageSizeFixed = false;\n      }\n\n      sqlite3BtreeLeave( pFrom );\n      sqlite3BtreeLeave( pTo );\n      return rc;\n    }\n#endif //* SQLITE_OMIT_VACUUM */\n  }\n}\n'