b'/*\n    SPDX-FileCopyrightText: 2021 Milian Wolff <mail@milianw.de>\n\n    SPDX-License-Identifier: LGPL-2.1-or-later\n*/\n\n#include "suppressions.h"\n\n#include <cstring>\n#include <fstream>\n#include <iostream>\n\n#include <boost/algorithm/string/trim.hpp>\n\nnamespace {\nstd::vector<std::string> parseSuppressionsFile(std::istream& input)\n{\n    std::vector<std::string> ret;\n    std::string line;\n    while (std::getline(input, line)) {\n        auto suppression = parseSuppression(line);\n        if (!suppression.empty()) {\n            ret.push_back(std::move(suppression));\n        }\n    }\n    return ret;\n}\n\n/**\n * This function is based on the TemplateMatch function found in\n *     llvm-project/compiler-rt/lib/sanitizer_common/sanitizer_common.cpp\n * The code was licensed under Apache License v2.0 with LLVM Exceptions\n */\nbool TemplateMatch(const char* templ, const char* str)\n{\n    if ((!str) || str[0] == 0)\n        return false;\n    bool start = false;\n    if (templ && templ[0] == \'^\') {\n        start = true;\n        templ++;\n    }\n    bool asterisk = false;\n    while (templ && templ[0]) {\n        if (templ[0] == \'*\') {\n            templ++;\n            start = false;\n            asterisk = true;\n            continue;\n        }\n        if (templ[0] == \'$\')\n            return str[0] == 0 || asterisk;\n        if (str[0] == 0)\n            return false;\n        char* tpos = (char*)strchr(templ, \'*\');\n        char* tpos1 = (char*)strchr(templ, \'$\');\n        if ((!tpos) || (tpos1 && tpos1 < tpos))\n            tpos = tpos1;\n        if (tpos)\n            tpos[0] = 0;\n        const char* str0 = str;\n        const char* spos = strstr(str, templ);\n        str = spos + strlen(templ);\n        templ = tpos;\n        if (tpos)\n            tpos[0] = tpos == tpos1 ? \'$\' : \'*\';\n        if (!spos)\n            return false;\n        if (start && spos != str0)\n            return false;\n        start = false;\n        asterisk = false;\n    }\n    return true;\n}\n}\n\nstd::string parseSuppression(std::string line)\n{\n    boost::trim(line, std::locale::classic());\n    if (line.empty() || line[0] == \'#\') {\n        // comment\n        return {};\n    } else if (line.compare(0, 5, "leak:") == 0) {\n        return line.substr(5);\n    }\n    std::cerr << "invalid suppression line: " << line << \'\\n\';\n    return {};\n}\n\nstd::vector<std::string> parseSuppressions(const std::string& suppressionFile, bool* ok)\n{\n    if (ok) {\n        *ok = true;\n    }\n\n    if (suppressionFile.empty()) {\n        return {};\n    }\n\n    auto stream = std::ifstream(suppressionFile);\n    if (!stream.is_open()) {\n        std::cerr << "failed to open suppression file: " << suppressionFile << \'\\n\';\n        if (ok) {\n            *ok = false;\n        }\n        return {};\n    }\n\n    return parseSuppressionsFile(stream);\n}\n\nbool matchesSuppression(const std::string& suppression, const std::string& haystack)\n{\n    return suppression == haystack || TemplateMatch(suppression.c_str(), haystack.c_str());\n}\n\nstd::vector<Suppression> builtinSuppressions()\n{\n    return {\n        // libc\n        {"__nss_module_allocate", 0, 0},\n        {"__gconv_read_conf", 0, 0},\n        {"__new_exitfn", 0, 0},\n        {"tzset_internal", 0, 0},\n        // dynamic linker\n        {"dl_open_worker", 0, 0},\n        // glib event loop\n        {"g_main_context_new", 0, 0},\n        {"g_main_context_new", 0, 0},\n        {"g_thread_self", 0, 0},\n    };\n}\n'