b'{-# LANGUAGE CPP #-}\n\nimport Control.Applicative\nimport Control.Exception (evaluate)\nimport Control.Monad (replicateM)\n\nimport Control.Monad.Par.Meta.SMPMergeSort\n\nimport qualified Data.Vector.Storable as V\nimport Data.Word (Word8, Word32)\n\nimport System.Environment\nimport System.Random.MWC    \n\nimport Control.DeepSeq\nimport Data.List\nimport Test.QuickCheck\nimport Test.QuickCheck.Monadic\n\nimport Criterion.Main hiding (run)\n\nimport Data.Time.Clock\nimport Text.Printf\n\n-- | Generate a random vector of unsigned integers where the length\n-- given is multiplied by 1024 to meet the constraints of the CUDA\n-- merge sort.\nmkRandomVec :: Int -> IO (V.Vector Word32)\nmkRandomVec k = withSystemRandom $ \\g -> uniformVector g (k*1024) :: IO (V.Vector Word32)\n\nparMergeSort :: V.Vector Word32 -> V.Vector Word32\nparMergeSort v = runPar $ get =<< spawnGPUMergeSort v\n\n-- | Sorts each vector individually, and then appends them together\n-- for a poor man\'s version of a parallel mergesort\nparMergeSortN :: [V.Vector Word32] -> V.Vector Word32\nparMergeSortN vs = runPar $ V.concat <$> mapM sortOne vs\n  where sortOne v = get =<< spawnGPUMergeSort v                   \n\nprop_parSortCorrect :: Positive Word8 -> Property       \nprop_parSortCorrect k = monadicIO $ do\n  unsorted <- run $ mkRandomVec (fromIntegral k)\n  let sorted = sort $!! V.toList unsorted\n  assert $ sorted == V.toList (parMergeSort unsorted)\n\n\n\nmain = do args <- getArgs          \n          case args of\n            ["test"] -> quickCheck prop_parSortCorrect\n            ("criterion":(k:args\')) -> do\n              v <- mkRandomVec (read k)\n              () <- evaluate $ V.foldl\' (flip seq) () v\n              withArgs args\' $ defaultMain [\n                  bench "parMergeSort" $ whnf (V.head . parMergeSort) v                  \n                ]\n            ("criterionN":(k:n:args\')) -> do\n              vs <- replicateM (read n) $ mkRandomVec (read k)\n              withArgs args\' $ defaultMain [\n                  bench "parMergeSortN" $ whnf (V.head . parMergeSortN) vs\n                ]\n            [k] -> do\n              v <- mkRandomVec (read k)\n              () <- evaluate $ V.foldl\' (flip seq) () v\n              start <- getCurrentTime\n              evaluate (V.head $ parMergeSort v)\n              end <- getCurrentTime\n              let runningTime = ((fromRational $ toRational $ diffUTCTime end start) :: Double)\n              printf "SELFTIMED: %s\\n" (show runningTime)\n            _ -> error "usage: cudaParMerge [ test | criterion k | criterionN k n | k ]"'