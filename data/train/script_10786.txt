b'{-# LANGUAGE GADTs #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n\nmodule Hoodle.Web.Type.Coroutine where\n\nimport Control.Concurrent.MVar (MVar)\nimport Control.Monad (liftM, void)\nimport Control.Monad.IO.Class (MonadIO (liftIO))\nimport Control.Monad.Trans.Class (lift)\nimport Control.Monad.Trans.Crtn (CrtnT, request, (<==|))\nimport qualified Control.Monad.Trans.Crtn.Driver as D\n  ( Driver,\n    DrvOp,\n  )\nimport Control.Monad.Trans.Crtn.Logger\n  ( LogInput,\n    LogOp (..),\n    LogServer,\n    MonadLog (..),\n  )\nimport Control.Monad.Trans.Crtn.Object (Arg (..), CObjT, EStT, Res (..), SObjBT, SObjT)\nimport Control.Monad.Trans.Crtn.World (WorldOp (..))\nimport Control.Monad.Trans.Except (runExceptT)\nimport Control.Monad.Trans.Reader (ReaderT (..))\nimport Control.Monad.Trans.State (StateT (..))\nimport Hoodle.Web.Type.Event (AllEvent (..))\nimport Hoodle.Web.Type.State (HoodleState)\nimport Hoodle.Web.Util (putStrLnAndFlush)\n\ndata MainOp i o where\n  DoEvent :: MainOp AllEvent ()\n\ndoEvent :: (Monad m) => AllEvent -> CObjT MainOp m ()\ndoEvent ev = request (Arg DoEvent ev) >> pure ()\n\ntype MainCoroutine = MainObjB\n\ntype MainObjB = SObjBT MainOp (EStT HoodleState WorldObjB)\n\ntype MainObj = SObjT MainOp (EStT HoodleState WorldObjB)\n\ntype WorldObj = SObjT (WorldOp AllEvent DriverB) DriverB\n\ntype WorldObjB = SObjBT (WorldOp AllEvent DriverB) DriverB\n\ntype Driver a = D.Driver AllEvent IO a\n\ntype DriverB = SObjBT (D.DrvOp AllEvent) IO\n\ntype EventVar = MVar (Maybe (Driver ()))\n\nsimplelogger :: (MonadLog m) => LogServer m ()\nsimplelogger = loggerW 0\n\n-- |\nloggerW :: forall m. (MonadLog m) => Int -> LogServer m ()\nloggerW num = ReaderT (f num)\n  where\n    f :: Int -> LogInput -> CrtnT (Res LogOp) (Arg LogOp) m ()\n    f n (Arg WriteLog msg) = do\n      lift (scribe ("log number " ++ show n ++ " : " ++ msg))\n      req\' <- request (Res WriteLog ())\n      f (n + 1) req\'\n\nerrorlog :: String -> IO ()\nerrorlog = putStrLnAndFlush\n\n-- |\nworld :: HoodleState -> MainObj () -> WorldObj ()\nworld xstate initmc = ReaderT staction\n  where\n    staction req = void $ runStateT erract xstate\n      where\n        erract = do\n          r <- runExceptT (go initmc req)\n          case r of\n            Left e -> liftIO (errorlog (show e))\n            Right _ -> pure ()\n    go ::\n      MainObj () ->\n      Arg (WorldOp AllEvent DriverB) ->\n      EStT HoodleState WorldObjB ()\n    go mcobj (Arg GiveEvent ev) = do\n      Right mcobj\' <- liftM (fmap fst) (mcobj <==| doEvent ev)\n      req <- lift $ lift $ request $ Res GiveEvent ()\n      go mcobj\' req\n    go mcobj (Arg FlushLog logobj) = do\n      -- -- disable log\n      -- Right logobj\' <- lift $ lift $ lift $ liftM (fmap fst) (logobj <==| writeLog ("[Log]"))\n      let logobj\' = logobj\n      req <- lift $ lift $ request $ Res FlushLog logobj\'\n      go mcobj req\n    go mcobj (Arg FlushQueue ()) = do\n      req <- lift $ lift $ request $ Res FlushQueue []\n      go mcobj req\n'