b'// UVa658 It\'s not a Bug, it\'s a Feature!\n// Rujia Liu\n#include<cstdio>\n#include<cstring>\n#include<queue>\nusing namespace std;\n\nstruct Node {\n  int bugs, dist;\n  bool operator < (const Node& rhs) const {\n    return dist > rhs.dist;\n  }\n};\n\nconst int maxn = 20;\nconst int maxm = 100 + 5;\nconst int INF = 1000000000;\n\nint n, m, t[maxm], dist[1<<maxn], mark[1<<maxn];\nchar before[maxm][maxn + 5], after[maxm][maxn + 5];\n\nint solve() {\n  for(int i = 0; i < (1<<n); i++) { mark[i] = 0; dist[i] = INF; }\n  priority_queue<Node> q;\n\n  Node start;\n  start.dist = 0;\n  start.bugs = (1<<n) - 1;\n  q.push(start);\n\n  dist[start.bugs] = 0;\n  while(!q.empty()) {\n    Node u = q.top(); q.pop();\n    if(u.bugs == 0) return u.dist;\n    if(mark[u.bugs]) continue;\n    mark[u.bugs] = 1;\n    for(int i = 0; i < m; i++) {\n      bool patchable = true;\n      for(int j = 0; j < n; j++) {\n        if(before[i][j] == \'-\' && (u.bugs & (1<<j))) { patchable = false; break; }\n        if(before[i][j] == \'+\' && !(u.bugs & (1<<j))) { patchable = false; break; }\n      }\n      if(!patchable) continue;\n\n      Node u2;\n      u2.dist = u.dist + t[i];\n      u2.bugs = u.bugs;\n      for(int j = 0; j < n; j++) {\n        if(after[i][j] == \'-\') u2.bugs &= ~(1<<j);\n        if(after[i][j] == \'+\') u2.bugs |= (1<<j);\n      }\n      int& D = dist[u2.bugs];\n      if(D < 0 || u2.dist < D) {\n        D = u2.dist;\n        q.push(u2);\n      }\n    }\n  }\n  return -1;\n}\n\nint main() {\n  int kase = 0;\n  while(scanf("%d%d", &n, &m) == 2 && n) {\n    for(int i = 0; i < m; i++) scanf("%d%s%s", &t[i], before[i], after[i]);\n    int ans = solve();\n    printf("Product %d\\n", ++kase);\n    if(ans < 0) printf("Bugs cannot be fixed.\\n\\n");\n    else printf("Fastest sequence takes %d seconds.\\n\\n", ans);\n  }\n  return 0;\n}\n'