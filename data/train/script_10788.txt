b'{-# LANGUAGE\n    CPP\n  , FlexibleContexts\n  , FlexibleInstances\n  , GADTs\n  , KindSignatures\n  , MultiParamTypeClasses\n  , NamedFieldPuns\n  , NoImplicitPrelude\n  , RankNTypes\n  , TypeSynonymInstances\n  #-}\n#if MIN_VERSION_base(4,9,0)\n{-# OPTIONS_GHC -Wno-redundant-constraints #-}\n#endif\n-- | A \'Resource\' type for representing a REST resource, as well as\n-- smart constructors for empty resources which can then be filled in\n-- using record updates.\nmodule Rest.Resource\n  ( Resource (..)\n  , mkResource\n  , mkResourceId\n  , mkResourceReader\n  , mkResourceReaderWith\n  , module Rest.Types.Void\n  ) where\n\nimport Prelude.Compat\n\nimport Control.Monad.Reader\n\nimport Rest.Handler\nimport Rest.Schema (Schema (..), Step (..))\nimport Rest.Types.Void\n\n-- * The @Resource@ type.\n\n-- | The \'Resource\' data type represents a single resource in a REST\n-- API. Handlers run in a monad @m@, while things below this resource\n-- run in @s@. The identifiers @sid@, @mid@ and @aid@ identify a\n-- single item, a listing and an action.\n\ndata Resource m s sid mid aid where\n  Resource :: (Applicative m, Monad m, Applicative s, Monad s) =>\n    { name        :: String                      -- ^ The name for this resource, used as a path segment in routing.\n    , description :: String                      -- ^ A description of the resource, used for documentation.\n    , schema      :: Schema sid mid aid          -- ^ The schema for routing and identification.\n    , private     :: Bool                        -- ^ Private resources are not documented, but they are exposed.\n    , enter       :: forall b. sid -> s b -> m b -- ^ How to run a subresource given an id.\n\n    , list        :: mid -> ListHandler m        -- ^ List handler, both toplevel and deeper (search).\n\n    , statics     :: aid -> Handler m            -- ^ Static actions, e.g. signin.\n\n    , get         :: Maybe (Handler s)           -- ^ Get a single resource identified by id.\n    , update      :: Maybe (Handler s)           -- ^ Update a single resource identified by id.\n    , remove      :: Maybe (Handler s)           -- ^ Delete a single resource identified by id.\n    , create      :: Maybe (Handler m)           -- ^ Create a single resource, generating a new id.\n    , actions     :: [(String, Handler s)]       -- ^ Actions performed on a single resource.\n    , selects     :: [(String, Handler s)]       -- ^ Properties of a single resource.\n    } -> Resource m s sid mid aid\n\n-- * Smart constructors for empty resources.\n\n-- | Create an empty resource given an \'enter\' function. It has no\n-- name, so if you wish to route to this resource, you should set one.\n\nmkResource :: (Applicative m, Monad m, Applicative s, Monad s) => (forall b. sid -> s b -> m b) -> Resource m s sid Void Void\nmkResource e = Resource\n  { name           = ""\n  , description    = ""\n  , schema         = Schema Nothing (Named [])\n  , private        = False\n  , enter          = e\n\n  , list           = magic\n\n  , statics        = magic\n\n  , get            = Nothing\n  , update         = Nothing\n  , remove         = Nothing\n  , create         = Nothing\n  , actions        = []\n  , selects        = []\n  }\n\n-- | Make a resource that doesn\'t add any information for\n-- subresources (i.e. \'enter\' is set to \'id\').\n\nmkResourceId :: (Applicative m, Monad m) => Resource m m sid Void Void\nmkResourceId = mkResource (const id)\n\n-- | Make a resource that provides the single resource identifier to\n-- its subresources.\n\nmkResourceReader :: (Applicative m, Monad m) => Resource m (ReaderT sid m) sid Void Void\nmkResourceReader = mkResourceReaderWith id\n\n-- | Make a resource that provides the single resource identifier to\n-- its subresources, by giving a conversion function to a \'ReaderT\'.\n-- If @s@ is a newtype around \'ReaderT\', for example, the function\n-- should unwrap the newtype.\n\nmkResourceReaderWith :: (Applicative m, Monad m, Applicative s, Monad s) => (forall b. s b -> ReaderT sid m b) -> Resource m s sid Void Void\nmkResourceReaderWith f = mkResource (\\a -> flip runReaderT a . f)\n'