b'{-# LANGUAGE LambdaCase #-}\n{-# LANGUAGE NamedFieldPuns #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n{-# OPTIONS_GHC -Werror -Wall #-}\n\n-- This checks unclean imports\n-- applies to GHC 8.8.\n\nmodule Main (main) where\n\nimport Control.Monad (unless)\nimport Control.Monad.IO.Class (liftIO)\nimport Data.Foldable (for_)\nimport DynFlags (DynFlags)\nimport qualified DynFlags\nimport qualified Extensions.Module as EM\nimport qualified Extensions.Types as E\nimport FastString (mkFastString)\nimport qualified GHC\nimport qualified GHC.Paths as GHC.Paths\nimport HsExtension (GhcPs)\nimport HsImpExp (ImportDecl (..))\nimport HsSyn (HsModule (..))\nimport Lexer (P (unP), ParseResult (..), mkPState)\nimport Module (moduleNameString)\nimport qualified Options.Applicative as OA\nimport Outputable (ppr, showSDoc)\nimport qualified Parser\nimport SrcLoc (mkRealSrcLoc, unLoc)\nimport StringBuffer (stringToStringBuffer)\nimport System.Exit (exitFailure)\n\nnewtype Options = Options {sourceFileName :: FilePath}\n\npOptions :: OA.Parser Options\npOptions =\n  Options\n    <$> OA.strOption (OA.long "input" <> OA.short \'i\' <> OA.help "source file")\n\nrunParser :: DynFlags -> String -> FilePath -> P a -> ParseResult a\nrunParser flags str filename parser = unP parser parseState\n  where\n    location = mkRealSrcLoc (mkFastString filename) 1 1\n    buffer = stringToStringBuffer str\n    parseState = mkPState flags buffer location\n\nisImplicitImport :: ImportDecl GhcPs -> Bool\nisImplicitImport (ImportDecl {ideclName, ideclQualified, ideclHiding})\n  | moduleNameString (unLoc ideclName) == "Prelude" = False\n  | ideclQualified = False\n  | Just (False, _) <- ideclHiding = False\n  | otherwise = True\nisImplicitImport _ = False\n\nmain :: IO ()\nmain = do\n  opts <- OA.execParser (OA.info pOptions mempty)\n  let srcfile = sourceFileName opts\n  putStrLn $ "checking " <> srcfile\n  contents <- readFile srcfile\n\n  eParsedExtensions <- EM.parseFile srcfile\n  case eParsedExtensions of\n    Left err -> print err\n    Right pexts -> do\n      let exts = E.parsedExtensionsAll pexts\n      GHC.runGhc (Just GHC.Paths.libdir) $ do\n        _env <- GHC.getSession\n        dflags <- GHC.getSessionDynFlags\n        let dflagsWithExts =\n              let addExts =\n                    foldr (.) id $\n                      fmap\n                        (\\case E.On e -> flip DynFlags.xopt_set e; E.Off e -> flip DynFlags.xopt_unset e)\n                        exts\n               in addExts dflags\n        let presult = runParser dflagsWithExts contents srcfile Parser.parseModule\n        case presult of\n          POk _ r -> liftIO $ do\n            let modu :: HsModule GhcPs\n                modu = unLoc r\n                implicitImports = filter (isImplicitImport . unLoc) $ hsmodImports modu\n            unless (null implicitImports) $ do\n              putStrLn "implicit imports"\n              putStrLn "----------------"\n              for_ implicitImports $ \\imp ->\n                putStrLn $ showSDoc dflags (ppr imp)\n              putStrLn "----------------"\n              exitFailure\n          _ -> do\n            liftIO $ putStrLn "Parse Failed"\n            liftIO exitFailure\n'