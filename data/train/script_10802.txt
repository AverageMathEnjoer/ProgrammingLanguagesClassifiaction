b'runDESeq2 <- function(e, retDDS=FALSE) {\n  counts <- exprs(e)\n  mode(counts) <- "integer"\n  dds <- DESeqDataSetFromMatrix(counts, DataFrame(pData(e)), ~ condition)\n  dds <- DESeq(dds, quiet=TRUE)\n  res <- results(dds)\n  logFC <- res$log2FoldChange\n  pval <- res$pvalue\n  padj <- res$padj\n  pval[is.na(pval)] <- 1\n  pval[rowSums(exprs(e)) == 0] <- NA\n  padj[is.na(padj)] <- 1\n  return(list(pval=pval, padj=padj, logFC=logFC))\n}\n\nrunDESeq2LRT <- function(e, retDDS=FALSE) {\n  counts <- exprs(e)\n  mode(counts) <- "integer"\n  dds <- DESeqDataSetFromMatrix(counts, DataFrame(pData(e)), ~ condition)\n  dds <- DESeq(dds,test="LRT",reduced=~1,quiet=TRUE)\n  res <- results(dds)\n  logFC <- res$log2FoldChange\n  pval <- res$pvalue\n  padj <- res$padj\n  pval[is.na(pval)] <- 1\n  pval[rowSums(exprs(e)) == 0] <- NA\n  padj[is.na(padj)] <- 1\n  return(list(pval=pval, padj=padj, logFC=logFC))\n}\n\nrunEdgeR <- function(e) {\n  design <- model.matrix(~ pData(e)$condition)\n  dgel <- DGEList(exprs(e))\n  dgel <- calcNormFactors(dgel)\n  ## dgel <- estimateGLMCommonDisp(dgel, design)\n  ## dgel <- estimateGLMTrendedDisp(dgel, design)\n  ## dgel <- estimateGLMTagwiseDisp(dgel, design)\n  dgel <- estimateDisp(dgel, design)\n  edger.fit <- glmFit(dgel, design)\n  edger.lrt <- glmLRT(edger.fit)\n  predlogFC <- predFC(exprs(e), design, offset=getOffset(dgel), dispersion=dgel$tagwise.dispersion)\n  predlogFC10 <- predFC(exprs(e), design, prior.count=10, offset=getOffset(dgel), dispersion=dgel$tagwise.dispersion)\n  pval <- edger.lrt$table$PValue\n  pval[rowSums(exprs(e)) == 0] <- NA\n  padj <- p.adjust(pval,method="BH")\n  padj[is.na(padj)] <- 1\n  list(pval=pval, padj=padj,\n       logFC=log2(exp(1)) * edger.fit$coefficients[,"pData(e)$conditionB"],\n       predlogFC=predlogFC[,"pData(e)$conditionB"],\n       predlogFC10=predlogFC10[,"pData(e)$conditionB"])\n}\n\nrunEdgeRRobust <- function(e) {\n  design <- model.matrix(~ pData(e)$condition)\n  dgel <- DGEList(exprs(e))\n  dgel <- calcNormFactors(dgel)\n  # settings for robust from robinson_lab/edgeR_robust/robust_simulation.R\n  dgel <- estimateGLMRobustDisp(dgel, design, maxit=6)\n  edger.fit <- glmFit(dgel, design)\n  edger.lrt <- glmLRT(edger.fit)\n  predlogFC <- predFC(exprs(e), design, offset=getOffset(dgel), dispersion=dgel$tagwise.dispersion)\n  pval <- edger.lrt$table$PValue\n  pval[rowSums(exprs(e)) == 0] <- NA\n  padj <- p.adjust(pval,method="BH")\n  padj[is.na(padj)] <- 1\n  list(pval=pval, padj=padj,\n       logFC=log2(exp(1)) * edger.fit$coefficients[,"pData(e)$conditionB"],\n       predlogFC=predlogFC[,"pData(e)$conditionB"])\n}\n\nrunDSS <- function(e) {\n  X <- as.matrix(exprs(e))\n  colnames(X) <- NULL\n  designs <- as.character(pData(e)$condition)\n  seqData <- newSeqCountSet(X, designs)\n  seqData <- estNormFactors(seqData)\n  seqData <- estDispersion(seqData)\n  # typically gives locfdr warnings about df\n  suppressWarnings({\n    result <- waldTest(seqData, "B", "A")\n  })\n  result <- result[match(rownames(seqData),rownames(result)),]\n  pval <- result$pval\n  pval[rowSums(exprs(e)) == 0] <- NA\n  # adjustment with BH (not the default FDR)\n  padj <- p.adjust(pval,method="BH")\n  padj[is.na(padj)] <- 1\n  list(pval=pval, padj=padj, logFC=( log2(exp(1)) * result$lfc ))\n}\n\nrunDSSFDR <- function(e) {\n  X <- as.matrix(exprs(e))\n  colnames(X) <- NULL\n  designs <- as.character(pData(e)$condition)\n  seqData <- newSeqCountSet(X, designs)\n  seqData <- estNormFactors(seqData)\n  seqData <- estDispersion(seqData)\n  # typically gives locfdr warnings about df\n  suppressWarnings({\n    result <- waldTest(seqData, "B", "A")\n  })\n  result <- result[match(rownames(seqData),rownames(result)),]\n  pval <- result$pval\n  pval[rowSums(exprs(e)) == 0] <- NA\n  padj <- result$fdr\n  padj[is.na(padj)] <- 1\n  list(pval=pval, padj=padj, logFC=( log2(exp(1)) * result$lfc ))\n}\n\nrunVoom <- function(e) {\n  design <- model.matrix(~ condition, pData(e))\n  dgel <- DGEList(exprs(e))\n  dgel <- calcNormFactors(dgel)\n  v <- voom(dgel,design,plot=FALSE)\n  fit <- lmFit(v,design)\n  fit <- eBayes(fit)\n  tt <- topTable(fit,coef=ncol(design),n=nrow(dgel),sort.by="none")\n  pval <- tt$P.Value \n  pval[rowSums(exprs(e)) == 0] <- NA\n  padj <- p.adjust(pval,method="BH")\n  padj[is.na(padj)] <- 1\n  list(pval=pval, padj=padj, logFC=tt$logFC)\n}\n\nrunSAMseq <- function(e) {\n  set.seed(1)\n  x <- exprs(e)\n  y <- pData(e)$condition\n  capture.output({\n    samfit <- SAMseq(x, y, resp.type = "Two class unpaired")\n  })\n  logFC <- log2(samfit$samr.obj$foldchange)\n  pval <- samr.pvalues.from.perms(samfit$samr.obj$tt, samfit$samr.obj$ttstar)\n  pval[rowSums(exprs(e)) == 0] <- NA\n  # adjustment with BH (not the default FDR)\n  padj <- p.adjust(pval,method="BH")\n  padj[is.na(padj)] <- 1\n  list(pval=pval,padj=padj,logFC=logFC)\n}\n\nrunSAMseqFDR <- function(e) {\n  set.seed(1)\n  x <- exprs(e)\n  y <- pData(e)$condition\n  capture.output({\n    samfit <- SAMseq(x, y, resp.type = "Two class unpaired", fdr.output=1)\n  })\n  padj <- rep(1,nrow(e))\n  idx <- as.numeric(samfit$siggenes.table$genes.up[,"Gene Name"])\n  padj[idx] <- 1/100 * as.numeric(samfit$siggenes.table$genes.up[,"q-value(%)"])\n  idx <- as.numeric(samfit$siggenes.table$genes.lo[,"Gene Name"])\n  padj[idx] <- 1/100 * as.numeric(samfit$siggenes.table$genes.lo[,"q-value(%)"])\n  logFC <- log2(samfit$samr.obj$foldchange)\n  pval <- rep(1,nrow(e))\n  list(pval=pval,padj=padj,logFC=logFC)\n}\n\nrunEBSeq <- function(e) {\n  sizes <- MedianNorm(exprs(e))\n  out <- capture.output({\n    suppressMessages({\n      res <- EBTest(Data = exprs(e),\n                    Conditions = pData(e)$condition,\n                    sizeFactors = sizes,\n                    maxround = 5)\n    })\n  })\n  padj <- rep(1, nrow(exprs(e)))\n  # we use 1 - PPDE for the FDR cutoff as this is recommended in the EBSeq vignette\n  padj[match(rownames(res$PPMat), rownames(e))] <- res$PPMat[,"PPEE"]\n  logFC <- rep(0, nrow(exprs(e)))\n  pval <- rep(1,nrow(e))\n  list(pval=pval, padj=padj, logFC=logFC)\n}\n'