b'{-# LANGUAGE Arrows #-}\n-- Part of this code is taken and adapted from:\n-- https://wiki.haskell.org/WxHaskell/Quick_start#Hello_world_in_wxHaskell\n--\n-- NOTE: Currently, there exists a problem with implementing push-based\n-- evaluation.\n--\n-- Ideas: using some monad or another arrow-based mechanism to remember\n-- values and not push unless its necessary. Maybe using arrow transformers\n-- instead of monad transformers, like Henrik suggested?\nmodule Main where\n\nimport Prelude hiding ((.))\nimport Control.Category\nimport Control.Monad\nimport Data.IORef\nimport Data.Maybe\nimport Data.MonadicStreamFunction hiding (trace)\nimport Data.MonadicStreamFunction.InternalCore\nimport Debug.Trace\nimport Graphics.UI.WX\n\nmain :: IO ()\nmain = start hello\n\nhello :: IO ()\nhello = do\n  f      <- frame      []\n  lenLbl <- staticText f [ text := "0" ]\n  entry1 <- textEntry  f []\n  entry2 <- textEntry  f []\n  quit   <- button     f [ text := "Quit", on command := close f ]\n\n  reactiveWXFieldRW entry1 text =:= (liftRW2 (reverse, reverse) (reactiveWXFieldRW entry2 text))\n  reactiveWXFieldRO entry1 text =:> (arr (show.length) >>> reactiveWXFieldWO lenLbl text)\n\n  set f [layout := margin 10 (column 5 [ floatCentre (widget lenLbl)\n                                       , floatCentre (widget entry1)\n                                       , floatCentre (widget entry2)\n                                       , floatCentre (widget quit)\n                                       ] )]\n\n\n-- * Auxiliary definitions\n\n-- ** MSF-related definitions and extensions\n\n-- | Run an MSF on an input sample step by step, using an IORef to store the\n-- continuation.\npushReactimate :: MSF IO a b -> IO (a -> IO b)\npushReactimate msf = do\n  msfRef <- newIORef msf\n  return $ \\a -> do\n              msf\' <- readIORef msfRef\n              (b, msf\'\') <- unMSF msf\' a\n              writeIORef msfRef msf\'\'\n              return b\n\n-- | Run one step of an MSF on () streams, internally storing the\n-- continuation.\npushReactimate_ :: MSF IO () () -> IO (IO ())\npushReactimate_ msf = do\n  f <- pushReactimate msf\n  return (void (f ()))\n\n-- ** Keera Hails\n\ntype ReactiveValueRO m a = (MStream m a, m () -> m ())\ntype ReactiveValueWO m a = MSink   m a\ntype ReactiveValueRW m a = (MStream m a, MSink m a, m () -> m ())\n\nliftRW2 :: Monad m => (a -> b, b -> a) -> ReactiveValueRW m a -> ReactiveValueRW m b\nliftRW2 (f, f\') (sg, sk, h) = (sg >>> arr f, arr f\' >>> sk, h)\n\n(=:=) :: (Show a, Eq a) => ReactiveValueRW IO a -> ReactiveValueRW IO a -> IO ()\n(sg1,sk1,h1) =:= (sg2, sk2, h2) = do\n  (sg1,h1) =:> sk2\n  (sg2,h2) =:> sk1\n\n(=:>) :: (Show a, Eq a) => ReactiveValueRO IO a -> ReactiveValueWO IO a -> IO ()\n(sg, h) =:> sk = h =<< pushReactimate_ (sg >>> sk)\n\n-- ** Auxiliary WX functions\nsetProp :: widget -> Attr widget attr -> attr -> IO ()\nsetProp c p v = set c [ p := v ]\n\n-- ** Keera Hails - WX bridge on top of Dunai\nreactiveWXFieldRO :: Updating widget => widget -> Attr widget attr -> ReactiveValueRO IO attr\nreactiveWXFieldRO widget attr =\n  ( constM (get widget attr)\n  , \\m -> set widget [ on update :~ (\\m1 -> m1 >> m) ]\n  )\n\nreactiveWXFieldWO :: Eq attr => widget -> Attr widget attr -> ReactiveValueWO IO attr\nreactiveWXFieldWO widget attr = arrM $ \\v -> do\n  o <- get widget attr\n  if v == o\n    then return ()\n    else setProp widget attr v\n\nreactiveWXFieldRW :: (Updating widget, Eq attr) => widget -> Attr widget attr -> ReactiveValueRW IO attr\nreactiveWXFieldRW widget attr = (sg, sk, h)\n where (sg, h) = reactiveWXFieldRO widget attr\n       sk      = reactiveWXFieldWO widget attr\n\npushify :: (Monad m, Eq a, Show a, Show b) => MSF m a b -> MSF m a b\npushify msf = feedback Nothing (pushify\' msf)\n\npushify\' :: (Eq a, Monad m, Show a, Show b)\n         => MSF m a b -> MSF m (a, Maybe (a, b)) (b, Maybe (a, b))\npushify\' msf = proc (a, mov) -> do\n  nv <- if Just a == (trace (show (a, mov)) $ fmap fst mov)\n          then returnA -< snd (fromJust mov)\n          else msf     -< a\n  returnA -< (nv, Just (a, nv))\n\nconstant :: Monad m => b -> MSF m a b\nconstant = arr . const\n\nvoidA :: Arrow a => a b c -> a b ()\nvoidA a = a >>> arr (const ())\n'