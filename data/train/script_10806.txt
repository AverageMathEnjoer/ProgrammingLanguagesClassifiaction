b'#include "stdafx.h"\n#include "BundleDialog.h"\n#include "MainWindow2.h"\n#include "resource.h"\n#include "../libStringConverter/convert.h"\n#include "FileDialog.h"\n#include <WindowsX.h>\n\nBundleDialog::~BundleDialog()\n{\n\tpContext->getMainWindow().unregisterEventHandler(eventHandlerHandle);\n}\nBundleDialog::BundleDialog(class Win32AppContext *pContext, HWND hParentWnd)\n\t: pContext(pContext), hParentWnd(hParentWnd), hDialog(NULL),\n\thCurEditPopup(NULL), iEditPopupItem(0), iEditPopupSubItem(0), nSelected(0),\n\tpCurFileEntry(nullptr)\n{\n\teventHandlerHandle = pContext->getMainWindow().registerEventHandler(this);\n}\n\nvoid BundleDialog::addFileContext(const std::pair<FileEntryUIInfo*,uintptr_t> &fileContext)\n{\n\tFileContextInfo *pContextInfo = fileContext.first->getContextInfoPtr();\n\tif (BundleFileContextInfo *pBundleInfo = dynamic_cast<BundleFileContextInfo*>(pContextInfo))\n\t{\n\t\tunsigned int fileID = pBundleInfo->getFileID();\n\t\tauto entryIt = fileEntries.find(fileID);\n\t\tassert(entryIt == fileEntries.end());\n\t\tif (entryIt == fileEntries.end())\n\t\t{\n\t\t\tfileEntries.insert(std::make_pair(fileID, fileContext.first));\n\t\t\tif (pCurFileEntry == nullptr || pCurFileEntry->getContextInfoPtr() == nullptr\n\t\t\t\t|| pBundleInfo->getFileID() < pCurFileEntry->getContextInfoPtr()->getFileID())\n\t\t\t{\n\t\t\t\tpCurFileEntry = fileContext.first;\n\t\t\t\tonUpdateCurrentFile();\n\t\t\t}\n\t\t}\n\t}\n\n}\nvoid BundleDialog::removeFileContext(FileEntryUIInfo *pContext)\n{\n\tFileContextInfo *pContextInfo = pContext->getContextInfoPtr();\n\tif (BundleFileContextInfo *pBundleInfo = dynamic_cast<BundleFileContextInfo*>(pContextInfo))\n\t{\n\t\tunsigned int fileID = pBundleInfo->getFileID();\n\t\tauto entryIt = fileEntries.find(fileID);\n\t\tassert(entryIt != fileEntries.end());\n\t\tassert(entryIt->second == pContext);\n\t\tif (entryIt != fileEntries.end())\n\t\t\tfileEntries.erase(entryIt);\n\t}\n\telse\n\t{\n\t\tfor (auto it = fileEntries.begin(); it != fileEntries.end(); ++it)\n\t\t{\n\t\t\tif (it->second == pContext)\n\t\t\t{\n\t\t\t\tfileEntries.erase(it);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif (pContext == pCurFileEntry)\n\t{\n\t\tif (!fileEntries.empty())\n\t\t\tpCurFileEntry = fileEntries.begin()->second;\n\t\telse\n\t\t\tpCurFileEntry = nullptr;\n\t\tonUpdateCurrentFile();\n\t}\n}\nEFileManipulateDialogType BundleDialog::getType()\n{\n\treturn FileManipulateDialog_Bundle;\n}\nHWND BundleDialog::getWindowHandle()\n{\n\treturn hDialog;\n}\nvoid BundleDialog::onHotkey(ULONG message, DWORD keyCode) //message : currently only WM_KEYDOWN; keyCode : VK_F3 for instance\n{\n\n}\nbool BundleDialog::onCommand(WPARAM wParam, LPARAM lParam) //Called for unhandled WM_COMMAND messages. Returns true if this dialog has handled the request, false otherwise.\n{\n\treturn false;\n}\nvoid BundleDialog::onShow()\n{\n\tif (!this->hDialog)\n\t{\n\t\tthis->hDialog = CreateDialogParam(pContext->getMainWindow().getHInstance(), MAKEINTRESOURCE(IDD_BUNDLEEDIT), hParentWnd, BundleDlgProc, (LPARAM)this);\n\t\tonUpdateCurrentFile();\n\t}\n}\nvoid BundleDialog::onHide()\n{\n\tif (this->hDialog)\n\t{\n\t\tif (this->hCurEditPopup != NULL)\n\t\t\tdoCloseEditPopup();\n\t\tSendMessage(this->hDialog, WM_CLOSE, 0, 0);\n\t}\n}\nbool BundleDialog::hasUnappliedChanges(bool *applyable)\n{\n\treturn false;\n}\nbool BundleDialog::applyChanges()\n{\n\treturn true;\n}\nbool BundleDialog::doesPreferNoAutoclose()\n{\n\treturn false;\n}\n\nstatic size_t getSelectedEntryIdx(HWND hList)\n{\n\tint listItem = ListView_GetNextItem(hList, -1, LVNI_SELECTED);\n\tif (listItem == -1)\n\t\treturn (size_t)-1;\n\t\t\n\tLVITEM item;\n\titem.mask = LVIF_PARAM;\n\titem.lParam = (LPARAM)-1;\n\titem.iItem = listItem;\n\titem.iSubItem = 0;\n\tListView_GetItem(hList, &item);\n\n\treturn (size_t)item.lParam;\n}\nvoid BundleDialog::importItem(bool addNew)\n{\n\tHWND hList = GetDlgItem(hDialog, IDC_ENTRYLIST);\n\tif (pCurFileEntry == nullptr || pCurFileEntry->getContextInfoPtr() == nullptr)\n\t\treturn;\n\tstd::shared_ptr<BundleFileContextInfo> pBundleInfo(\n\t\tpCurFileEntry->getContextInfo(),\n\t\tstatic_cast<BundleFileContextInfo*>(pCurFileEntry->getContextInfoPtr()));\n\n\tsize_t entryIdx = (size_t)-1;\n\tif (!addNew)\n\t{\n\t\tentryIdx = getSelectedEntryIdx(hList);\n\t\tassert(entryIdx == (size_t)-1 || entryIdx < pBundleInfo->getEntryCount());\n\t\tif (entryIdx >= pBundleInfo->getEntryCount() || entryIdx > UINT_MAX)\n\t\t\treturn;\n\t}\n\n\tWCHAR *filePathBuf = nullptr;\n\tif (FAILED(ShowFileOpenDialog(this->pContext->getMainWindow().getWindow(), \n\t\t&filePathBuf, L"*.*|All types:", nullptr, nullptr, TEXT("Import a bundle entry"),\n\t\tUABE_FILEDIALOG_FILE_GUID)))\n\t\treturn;\n\n\tif (!addNew)\n\t{\n\t\tstd::vector<unsigned int> fileIDByEntry;\n\t\tpBundleInfo->getChildFileIDs(fileIDByEntry);\n\t\tassert(fileIDByEntry.size() > entryIdx);\n\t\tif (fileIDByEntry[entryIdx] != 0 && !pContext->getMainWindow().CloseFile(fileIDByEntry[entryIdx]))\n\t\t\treturn;\n\t}\n\n\tstd::string fileName;\n\tfor (size_t _i = wcslen(filePathBuf); _i > 0; --_i)\n\t{\n\t\tsize_t i = _i - 1;\n\t\tif (filePathBuf[i] == L\'/\' || filePathBuf[i] == L\'\\\\\')\n\t\t{\n\t\t\tauto pFileName8 = unique_TCHARToMultiByte(&filePathBuf[i+1]);\n\t\t\tfileName.assign(pFileName8.get());\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tIAssetsReader *pReader = Create_AssetsReaderFromFile(filePathBuf, true, RWOpenFlags_Immediately);\n\tFreeCOMFilePathBuf(&filePathBuf);\n\tif (!pReader)\n\t{\n\t\tMessageBox(this->pContext->getMainWindow().getWindow(),\n\t\t\tTEXT("Unable to open the file to import!"),\n\t\t\tTEXT("Asset Bundle Extractor"),\n\t\t\tMB_ICONERROR);\n\t\treturn;\n\t}\n\tstd::shared_ptr<IAssetsReader> pReader_shared(pReader, Free_AssetsReader);\n\tbool isSerializedData = false;\n\t{\n\t\tstd::unique_ptr<AssetsFile> pAssetsFile(new AssetsFile(pReader_shared.get()));\n\t\tisSerializedData = pAssetsFile->VerifyAssetsFile();\n\t}\n\n\tif (addNew)\n\t{\n\t\tif (fileName.empty())\n\t\t\tfileName = std::string("New entry (") + std::to_string(pBundleInfo->getEntryCount()) + ")";\n\t\tentryIdx = pBundleInfo->addEntry(*this->pContext, pReader_shared, isSerializedData, fileName);\n\t}\n\telse\n\t\tpBundleInfo->overrideEntryReader(*this->pContext, entryIdx, pReader_shared, isSerializedData);\n\n\tpContext->getMainWindow().loadBundleEntry(pBundleInfo, (unsigned int)entryIdx);\n}\nvoid BundleDialog::exportItem()\n{\n\tHWND hList = GetDlgItem(hDialog, IDC_ENTRYLIST);\n\tif (pCurFileEntry == nullptr || pCurFileEntry->getContextInfoPtr() == nullptr)\n\t\treturn;\n\tBundleFileContextInfo *pBundleInfo = static_cast<BundleFileContextInfo*>(pCurFileEntry->getContextInfoPtr());\n\n\tsize_t entryIdx = getSelectedEntryIdx(hList);\n\tassert(entryIdx == (size_t)-1 || entryIdx < pBundleInfo->getEntryCount());\n\tif (entryIdx >= pBundleInfo->getEntryCount())\n\t\treturn;\n\n\tstd::string newName = pBundleInfo->getNewEntryName(entryIdx);\n\tauto pNewNameT = unique_MultiByteToTCHAR(newName.c_str());\n\tWCHAR *filePathBuf = nullptr;\n\tif (FAILED(ShowFileSaveDialog(this->pContext->getMainWindow().getWindow(),\n\t\t&filePathBuf, L"*.*|All types:", nullptr, pNewNameT.get(), TEXT("Export a bundle entry"),\n\t\tUABE_FILEDIALOG_FILE_GUID)))\n\t\treturn;\n\n\t//Note: Race condition possible (entries could be changed by some other thread).\n\t//-> Reader could change after having retrieved the name.\n\t//  (doesn\'t appear to be relevant, and will not cause too bad behavior).\n\n\tbool isModified;\n\tstd::shared_ptr<IAssetsReader> pReader = pBundleInfo->makeEntryReader(entryIdx, isModified);\n\tQWORD size = 0;\n\tif (pReader == nullptr || !pReader->Seek(AssetsSeek_End, 0) || !pReader->Tell(size) || !pReader->Seek(AssetsSeek_Begin, 0))\n\t{\n\t\tMessageBox(this->pContext->getMainWindow().getWindow(),\n\t\t\tTEXT("Unable to read the entry to export!"),\n\t\t\tTEXT("Asset Bundle Extractor"),\n\t\t\tMB_ICONERROR);\n\t\treturn;\n\t}\n\n\t//Slight abuse of BundleReplacers to copy from a reader to a writer. Should be fine, though.\n\tBundleReplacer *pReplacer = MakeBundleEntryModifier("", "", false, pReader, size, 0);\n\tbool result = pReplacer->Init(nullptr, nullptr, 0, 0, nullptr);\n\tif (!result)\n\t{\n\t\tMessageBox(this->pContext->getMainWindow().getWindow(),\n\t\t\tTEXT("An internal error occured."),\n\t\t\tTEXT("Asset Bundle Extractor"),\n\t\t\tMB_ICONERROR);\n\t\treturn;\n\t}\n\n\tIAssetsWriter *pWriter = Create_AssetsWriterToFile(filePathBuf, true, true, RWOpenFlags_Immediately);\n\tif (pWriter == nullptr)\n\t{\n\t\tFreeBundleReplacer(pReplacer);\n\t\tMessageBox(this->pContext->getMainWindow().getWindow(),\n\t\t\tTEXT("Unable to open the output file!"),\n\t\t\tTEXT("Asset Bundle Extractor"),\n\t\t\tMB_ICONERROR);\n\t\treturn;\n\t}\n\t\n\tQWORD written = pReplacer->Write(0, pWriter);\n\tFreeBundleReplacer(pReplacer);\n\tFree_AssetsWriter(pWriter);\n\tassert(written <= size);\n\tif (written < size)\n\t{\n\t\tMessageBox(this->pContext->getMainWindow().getWindow(),\n\t\t\tTEXT("Failed writing the output file!"),\n\t\t\tTEXT("Asset Bundle Extractor"),\n\t\t\tMB_ICONERROR);\n\t\treturn;\n\t}\n}\nvoid BundleDialog::removeItem()\n{\n\tHWND hList = GetDlgItem(hDialog, IDC_ENTRYLIST);\n\tif (pCurFileEntry == nullptr || pCurFileEntry->getContextInfoPtr() == nullptr)\n\t\treturn;\n\tstd::shared_ptr<BundleFileContextInfo> pBundleInfo(\n\t\tpCurFileEntry->getContextInfo(),\n\t\tstatic_cast<BundleFileContextInfo*>(pCurFileEntry->getContextInfoPtr()));\n\n\tsize_t entryIdx = getSelectedEntryIdx(hList);\n\tassert(entryIdx == (size_t)-1 || entryIdx < pBundleInfo->getEntryCount());\n\tif (entryIdx >= pBundleInfo->getEntryCount())\n\t\treturn;\n\n\tstd::vector<unsigned int> fileIDByEntry;\n\tpBundleInfo->getChildFileIDs(fileIDByEntry);\n\tif (fileIDByEntry[entryIdx] != 0 && !pContext->getMainWindow().CloseFile(fileIDByEntry[entryIdx]))\n\t\treturn;\n\n\tpBundleInfo->removeEntry(*this->pContext, entryIdx);\n}\n\nstatic void list_updateBundleName(HWND hList, int iItem, const char *name)\n{\n\tauto upText = unique_MultiByteToTCHAR(name);\n\tLVITEM item;\n\titem.mask = LVIF_TEXT;\n\titem.pszText = upText.get();\n\titem.iItem = iItem;\n\titem.iSubItem = 0;\n\tListView_SetItem(hList, &item);\n}\nstatic void list_updateBundleModified(HWND hList, int iItem, bool modified)\n{\n\tLVITEM item;\n\titem.mask = LVIF_TEXT;\n\titem.pszText = const_cast<TCHAR*>(modified ? TEXT("*") : TEXT(""));\n\titem.iItem = iItem;\n\titem.iSubItem = 1;\n\tListView_SetItem(hList, &item);\n}\n\nvoid BundleDialog::onUpdateCurrentFile()\n{\n\tHWND hList = GetDlgItem(hDialog, IDC_ENTRYLIST);\n\tListView_DeleteAllItems(hList);\n\tif (pCurFileEntry != nullptr && pCurFileEntry->getContextInfoPtr() != nullptr && pCurFileEntry->getContextInfoPtr()->getFileContext() != nullptr)\n\t{\n\t\tBundleFileContextInfo *pBundleInfo = static_cast<BundleFileContextInfo*>(pCurFileEntry->getContextInfoPtr());\n\t\t//Note: Race condition possible (entries could be changed by some other thread).\n\t\t//-> Index bounds are checked in the functions, and can only increase.\n\t\tsize_t numEntries = pBundleInfo->getEntryCount();\n\t\tint listViewCount = 0;\n\t\tfor (size_t i = 0; i < numEntries && i < INT_MAX; ++i)\n\t\t{\n\t\t\tbool hasChanged = pBundleInfo->entryHasChanged(i);\n\t\t\tstd::string newName = pBundleInfo->getNewEntryName(i);\n\t\t\tif (!pBundleInfo->entryIsRemoved(i))\n\t\t\t{\n\t\t\t\tLVITEM item;\n\t\t\t\titem.mask = LVIF_PARAM;\n\t\t\t\titem.lParam = (LPARAM)i;\n\t\t\t\titem.iItem = listViewCount;\n\t\t\t\titem.iSubItem = 0;\n\t\t\t\tListView_InsertItem(hList, &item);\n\n\t\t\t\tlist_updateBundleName(hList, listViewCount, newName.c_str());\n\t\t\t\tlist_updateBundleModified(hList, listViewCount, hasChanged);\n\n\t\t\t\tassert(listViewCount < INT_MAX);\n\t\t\t\tlistViewCount++;\n\t\t\t}\n\t\t}\n\t}\n}\n\ninline void doMoveWindow(HDWP &deferCtx, bool &retry, HWND hWnd, int x, int y, int w, int h)\n{\n\tif (deferCtx)\n\t{\n\t\tdeferCtx = DeferWindowPos(deferCtx, hWnd, HWND_TOP, x, y, w, h, SWP_NOACTIVATE | SWP_NOOWNERZORDER | SWP_NOZORDER);\n\t\tif (!deferCtx)\n\t\t\tretry = true;\n\t}\n\telse\n\t\tSetWindowPos(hWnd, HWND_TOP, x, y, w, h, SWP_NOACTIVATE | SWP_NOOWNERZORDER | SWP_NOZORDER);\n}\nstatic void onResize(HWND hDlg, bool defer = true)\n{\n\tHDWP deferCtx = defer ? BeginDeferWindowPos(12) : NULL;\n\tbool retry = false;\n\n\tRECT client = {};\n\tGetClientRect(hDlg, &client);\n\tint clientWidth = (int)(client.right-client.left);\n\tint clientHeight = (int)(client.bottom-client.top);\n\tint x = 19;\n\tint w = clientWidth - 16;\n\n\tdoMoveWindow(deferCtx, retry, GetDlgItem(hDlg, IDC_STATICTITLE),     x + 2,       10,                w - 4,    15);\n\tdoMoveWindow(deferCtx, retry, GetDlgItem(hDlg, IDC_ENTRYLIST),  x,           30,                w - 15,   clientHeight - 60 - 7);\n\tint btnDistance = std::max<int>(4, w - 25) / 4;\n\tint btnWidth = std::max<int>(1, btnDistance - 10);\n\tdoMoveWindow(deferCtx, retry, GetDlgItem(hDlg, IDC_BTNADD),     x + 5 + 0*btnDistance, clientHeight - 30, btnWidth, 25);\n\tdoMoveWindow(deferCtx, retry, GetDlgItem(hDlg, IDC_BTNIMPORT),  x + 5 + 1*btnDistance, clientHeight - 30, btnWidth, 25);\n\tdoMoveWindow(deferCtx, retry, GetDlgItem(hDlg, IDC_BTNEXPORT),  x + 5 + 2*btnDistance, clientHeight - 30, btnWidth, 25);\n\tdoMoveWindow(deferCtx, retry, GetDlgItem(hDlg, IDC_BTNREMOVE),  x + 5 + 3*btnDistance, clientHeight - 30, btnWidth, 25);\n\n\tif (defer)\n\t{\n\t\tif (retry || !EndDeferWindowPos(deferCtx))\n\t\t\tonResize(hDlg, false);\n\t\telse\n\t\t\tUpdateWindow(hDlg);\n\t\tdeferCtx = NULL;\n\t}\n\telse\n\t\tUpdateWindow(hDlg);\n\n}\n\nvoid BundleDialog::doCloseEditPopup(bool applyChanges)\n{\n\tif (applyChanges)\n\t{\n\t\tif (pCurFileEntry == nullptr || pCurFileEntry->getContextInfoPtr() == nullptr)\n\t\t{\n\t\t\tdoCloseEditPopup(false);\n\t\t\treturn;\n\t\t}\n\t\tBundleFileContextInfo *pBundleFileInfo = static_cast<BundleFileContextInfo*>(pCurFileEntry->getContextInfoPtr());\n\n\t\tHWND hList = GetDlgItem(hDialog, IDC_ENTRYLIST);\n\t\tLVITEM item;\n\t\titem.mask = LVIF_PARAM;\n\t\titem.lParam = (LPARAM)-1;\n\t\titem.iItem = iEditPopupItem;\n\t\titem.iSubItem = 0;\n\t\tListView_GetItem(hList, &item);\n\n\t\tsize_t entryIdx = (size_t)item.lParam;\n\t\tassert(entryIdx < pBundleFileInfo->getEntryCount());\n\t\tif (entryIdx >= pBundleFileInfo->getEntryCount())\n\t\t{\n\t\t\tdoCloseEditPopup(false);\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tswitch (iEditPopupSubItem)\n\t\t{\n\t\t\tcase 0: //Entry name\n\t\t\t\t{\n\t\t\t\t\tint nameLen = Edit_GetTextLength(hCurEditPopup);\n\t\t\t\t\tif (nameLen > 0 && nameLen < INT_MAX - 2)\n\t\t\t\t\t{\n\t\t\t\t\t\tstd::unique_ptr<TCHAR[]> nameT(new TCHAR[nameLen + 2]);\n\t\t\t\t\t\tnameT[0] = 0;\n\t\t\t\t\t\tnameT[nameLen + 1] = 0;\n\t\t\t\t\t\tEdit_GetText(hCurEditPopup, nameT.get(), nameLen + 1);\n\t\t\t\t\t\tsize_t name8Len = 0;\n\t\t\t\t\t\tauto name8 = unique_TCHARToMultiByte(nameT.get(), name8Len);\n\t\t\t\t\t\tpBundleFileInfo->renameEntry(*this->pContext, entryIdx, std::string(name8.get()));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tassert(false);\n\t\t}\n\t}\n\tDestroyWindow(hCurEditPopup);\n\thCurEditPopup = NULL;\n\tiEditPopupItem = iEditPopupSubItem = 0;\n}\n\nvoid BundleDialog::onOpenEditPopup()\n{\n\tif (pCurFileEntry == nullptr || pCurFileEntry->getContextInfoPtr() == nullptr)\n\t{\n\t\tdoCloseEditPopup(false);\n\t\treturn;\n\t}\n\tBundleFileContextInfo *pBundleInfo = static_cast<BundleFileContextInfo*>(pCurFileEntry->getContextInfoPtr());\n\n\tHWND hList = GetDlgItem(hDialog, IDC_ENTRYLIST);\n\tLVITEM item;\n\titem.mask = LVIF_PARAM;\n\titem.lParam = (LPARAM)-1;\n\titem.iItem = iEditPopupItem;\n\titem.iSubItem = 0;\n\tListView_GetItem(hList, &item);\n\t\n\tsize_t entryIdx = (size_t)item.lParam;\n\tassert(entryIdx < pBundleInfo->getEntryCount());\n\tif (entryIdx >= pBundleInfo->getEntryCount())\n\t{\n\t\tdoCloseEditPopup(false);\n\t\treturn;\n\t}\n\n\tswitch (iEditPopupSubItem)\n\t{\n\t\tcase 0: //Dependency name/text\n\t\t\t{\n\t\t\t\tstd::string name = pBundleInfo->getNewEntryName(entryIdx);\n\t\t\t\tauto pText = unique_MultiByteToTCHAR(name.c_str());\n\t\t\t\tEdit_SetText(hCurEditPopup, pText.get());\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tassert(false);\n\t}\n\t//Failure\n\tdoCloseEditPopup(false);\n}\n\nvoid BundleDialog::onChangeSelection()\n{\n\tEnableWindow(GetDlgItem(hDialog, IDC_BTNIMPORT), (this->nSelected > 0) ? TRUE : FALSE);\n\tEnableWindow(GetDlgItem(hDialog, IDC_BTNEXPORT), (this->nSelected > 0) ? TRUE : FALSE);\n\tEnableWindow(GetDlgItem(hDialog, IDC_BTNREMOVE), (this->nSelected > 0) ? TRUE : FALSE);\n}\n\nINT_PTR CALLBACK BundleDialog::BundleDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)\n{\n\tINT_PTR ret = (INT_PTR)FALSE;\n\tBundleDialog *pThis = (BundleDialog*)GetWindowLongPtr(hDlg, GWLP_USERDATA);\n\tswitch (message)\n\t{\n\tcase WM_DESTROY:\n\t\tbreak;\n\tcase WM_NCDESTROY:\n\t\tbreak;\n\tcase WM_CLOSE:\n\t\tif (pThis)\n\t\t\tpThis->hDialog = NULL;\n\t\tDestroyWindow(hDlg);\n\t\tret = (INT_PTR)TRUE;\n\t\tbreak;\n\tcase WM_INITDIALOG:\n\t\t{\n\t\t\tSetWindowLongPtr(hDlg, GWLP_USERDATA, lParam);\n\t\t\tpThis = (BundleDialog*)lParam;\n\n\t\t\tpThis->nSelected = 0;\n\t\t\tpThis->onChangeSelection();\n\n\t\t\tHWND hList = GetDlgItem(hDlg, IDC_ENTRYLIST);\n\t\t\t//Subclass the ListView to support item edit popups (via double click).\n\t\t\tSetWindowSubclass(hList, BundleListViewProc, 0, reinterpret_cast<DWORD_PTR>(pThis));\n\t\t\tListView_SetExtendedListViewStyle(hList, LVS_EX_FULLROWSELECT | LVS_EX_DOUBLEBUFFER);\n\t\t\tLVCOLUMN column;\n\t\t\tZeroMemory(&column, sizeof(LVCOLUMN));\n\t\t\tcolumn.mask = LVCF_TEXT | LVCF_WIDTH | LVCF_SUBITEM;\n\t\t\tcolumn.cx = 250;\n\t\t\tcolumn.pszText = const_cast<TCHAR*>(TEXT("File Name"));\n\t\t\tcolumn.iSubItem = 0;\n\t\t\tListView_InsertColumn(hList, 0, &column);\n\t\t\tcolumn.cx = 85;\n\t\t\tcolumn.pszText = const_cast<TCHAR*>(TEXT("Has changed"));\n\t\t\t//column.iSubItem = 1;\n\t\t\tListView_InsertColumn(hList, 1, &column);\n\n\t\t\tShowWindow(hDlg, SW_SHOW);\n\t\t\tPostMessage(hDlg, WM_SIZE, 0, 0);\n\t\t\tret = (INT_PTR)TRUE;\n\t\t}\n\t\tbreak;\n\tcase WM_SIZE:\n\t\tonResize(hDlg);\n\t\tbreak;\n\tcase WM_COMMAND:\n\t\tswitch (LOWORD(wParam))\n\t\t{\n\t\tcase IDC_BTNADD:\n\t\t\tif (pThis) pThis->importItem(true);\n\t\t\tret = (INT_PTR)TRUE;\n\t\t\tbreak;\n\t\tcase IDC_BTNIMPORT:\n\t\t\tif (pThis) pThis->importItem(false);\n\t\t\tret = (INT_PTR)TRUE;\n\t\t\tbreak;\n\t\tcase IDC_BTNEXPORT:\n\t\t\tif (pThis) pThis->exportItem();\n\t\t\tret = (INT_PTR)TRUE;\n\t\t\tbreak;\n\t\tcase IDC_BTNREMOVE:\n\t\t\tif (pThis) pThis->removeItem();\n\t\t\tret = (INT_PTR)TRUE;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase WM_NOTIFY:\n\t\t{\n\t\t\tHWND hList = GetDlgItem(hDlg, IDC_ENTRYLIST);\n\t\t\tNMLISTVIEW *pNotifyLV = (NMLISTVIEW*)lParam;\n\t\t\tif (pNotifyLV->hdr.hwndFrom != hList)\n\t\t\t\tbreak;\n\t\t\tswitch (pNotifyLV->hdr.code)\n\t\t\t{\n\t\t\t\tcase LVN_ITEMCHANGED:\n\t\t\t\t\t{\n\t\t\t\t\t\tNMLISTVIEW *pInfo = (NMLISTVIEW*)lParam;\n\t\t\t\t\t\tif (pThis)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif ((pInfo->uOldState ^ pInfo->uNewState) & LVIS_SELECTED)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tbool isSelected = (pInfo->uNewState & LVIS_SELECTED) ? true : false;\n\t\t\t\t\t\t\t\tint iItem = pInfo->iItem;\n\t\t\t\t\t\t\t\tif (iItem == -1)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tpThis->nSelected = (isSelected) ? ListView_GetItemCount(hList) : 0;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tif (isSelected)\n\t\t\t\t\t\t\t\t\t\tpThis->nSelected++;\n\t\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\t\tpThis->nSelected--;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tpThis->onChangeSelection();\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n\treturn ret;\n}\nLRESULT CALLBACK BundleDialog::BundleListViewProc(HWND hWnd, UINT message, \n\tWPARAM wParam, LPARAM lParam, \n\tuintptr_t uIdSubclass, DWORD_PTR dwRefData)\n{\n\tBundleDialog *pThis = (BundleDialog*)dwRefData;\n\tswitch (message)\n\t{\n\tcase WM_LBUTTONDBLCLK:\n\t\t{\n\t\t\tLVHITTESTINFO hitTestInfo = {};\n\t\t\thitTestInfo.pt.x = GET_X_LPARAM(lParam);\n\t\t\thitTestInfo.pt.y = GET_Y_LPARAM(lParam);\n\t\t\tif (ListView_SubItemHitTest(hWnd, &hitTestInfo) != -1 && hitTestInfo.iSubItem == 0)\n\t\t\t{\n\t\t\t\tif (pThis->hCurEditPopup != NULL)\n\t\t\t\t\tpThis->doCloseEditPopup();\n\t\t\t\tpThis->iEditPopupItem = hitTestInfo.iItem;\n\t\t\t\tpThis->iEditPopupSubItem = hitTestInfo.iSubItem;\n\t\t\t\t\n\t\t\t\tRECT targetRect = {};\n\t\t\t\tListView_GetSubItemRect(hWnd, hitTestInfo.iItem, hitTestInfo.iSubItem, LVIR_BOUNDS, &targetRect);\n\t\t\t\tif (hitTestInfo.iSubItem == 0)\n\t\t\t\t{\n\t\t\t\t\tpThis->hCurEditPopup = \n\t\t\t\t\t\tCreateWindow(WC_EDIT, TEXT(""), ES_AUTOHSCROLL | WS_CHILD | WS_VISIBLE, \n\t\t\t\t\t\t\ttargetRect.left, targetRect.top, targetRect.right - targetRect.left, targetRect.bottom - targetRect.top,\n\t\t\t\t\t\t\thWnd, GetMenu(hWnd), pThis->pContext->getMainWindow().getHInstance(), NULL);\n\t\t\t\t}\n\t\t\t\tSetWindowSubclass(pThis->hCurEditPopup, EditPopupProc, 0, reinterpret_cast<DWORD_PTR>(pThis));\n\t\t\t\tSendMessage(pThis->hCurEditPopup, WM_SETFONT, (WPARAM)(HFONT)SendMessage(hWnd, WM_GETFONT, 0, 0), FALSE);\n\t\t\t\tSetFocus(pThis->hCurEditPopup);\n\t\t\t\tpThis->onOpenEditPopup();\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase WM_NCDESTROY:\n\t\tRemoveWindowSubclass(hWnd, BundleListViewProc, uIdSubclass);\n\t\tbreak;\n\t}\n    return DefSubclassProc(hWnd, message, wParam, lParam);\n}\nLRESULT CALLBACK BundleDialog::EditPopupProc(HWND hWnd, UINT message, \n\tWPARAM wParam, LPARAM lParam, \n\tuintptr_t uIdSubclass, DWORD_PTR dwRefData)\n{\n\tBundleDialog *pThis = (BundleDialog*)dwRefData;\n\tswitch (message)\n\t{\n\tcase WM_KILLFOCUS:\n\t\t//if (wParam == WA_INACTIVE)\n\t\t{\n\t\t\tif (pThis->hCurEditPopup != NULL)\n\t\t\t\tpThis->doCloseEditPopup();\n\t\t}\n\t\tbreak;\n\tcase WM_KEYDOWN:\n\t\tif (LOWORD(wParam) == VK_ESCAPE || (pThis->iEditPopupSubItem != 0 && LOWORD(wParam) == VK_RETURN))\n\t\t{\n\t\t\tif (pThis->hCurEditPopup != NULL)\n\t\t\t\tpThis->doCloseEditPopup();\n\t\t}\n\t\tbreak;\n\tcase WM_NCDESTROY:\n\t\tRemoveWindowSubclass(hWnd, EditPopupProc, uIdSubclass);\n\t\tbreak;\n\t}\n    return DefSubclassProc(hWnd, message, wParam, lParam);\n}\n\nvoid BundleDialog::onUpdateBundleEntry(BundleFileContextInfo *info, size_t index)\n{\n\tif (this->hDialog == NULL || this->pCurFileEntry == nullptr || info != this->pCurFileEntry->getContextInfoPtr()\n\t\t|| info == nullptr || info->getFileContext() == nullptr)\n\t\treturn;\n\tHWND hList = GetDlgItem(hDialog, IDC_ENTRYLIST);\n\tBundleFileContextInfo *pBundleInfo = static_cast<BundleFileContextInfo*>(pCurFileEntry->getContextInfoPtr());\n\n\tint nListItems = ListView_GetItemCount(hList);\n\t\n\t//Retrieve a list of all dependencies in range that are already in the list.\n\tint iAffectedItem = -1;\n\tfor (int i = 0; i < nListItems; i++)\n\t{\n\t\tLVITEM item;\n\t\titem.mask = LVIF_PARAM;\n\t\titem.lParam = (LPARAM)-1;\n\t\titem.iItem = i;\n\t\titem.iSubItem = 0;\n\t\tListView_GetItem(hList, &item);\n\t\tif ((size_t)item.lParam == index)\n\t\t{\n\t\t\tiAffectedItem = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tbool hasChanged = pBundleInfo->entryHasChanged(index);\n\tstd::string newName = pBundleInfo->getNewEntryName(index);\n\tif (pBundleInfo->entryIsRemoved(index))\n\t{\n\t\tif (iAffectedItem != -1)\n\t\t{\n\t\t\tif (hCurEditPopup != NULL && iEditPopupItem == iAffectedItem)\n\t\t\t\tdoCloseEditPopup(false);\n\t\t\tListView_DeleteItem(hList, iAffectedItem);\n\t\t}\n\t}\n\telse if (iAffectedItem == -1)\n\t{\n\t\t//Add new element\n\t\tLVITEM item;\n\t\titem.mask = LVIF_PARAM;\n\t\titem.lParam = (LPARAM)index;\n\t\titem.iItem = nListItems;\n\t\titem.iSubItem = 0;\n\t\tListView_InsertItem(hList, &item);\n\n\t\tlist_updateBundleName(hList, nListItems, newName.c_str());\n\t\tlist_updateBundleModified(hList, nListItems, hasChanged);\n\t}\n\telse\n\t{\n\t\t//Change existing element\n\t\tif (hCurEditPopup != NULL && iEditPopupItem == iAffectedItem)\n\t\t\tdoCloseEditPopup(false);\n\t\tlist_updateBundleName(hList, iAffectedItem, newName.c_str());\n\t\tlist_updateBundleModified(hList, iAffectedItem, hasChanged);\n\t}\n}\n'