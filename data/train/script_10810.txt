b'using System;\nusing System.Diagnostics;\nusing System.Runtime.InteropServices;\nusing System.Text;\n\nnamespace CS_SQLite3\n{\n  using etByte = System.Boolean;\n  using i64 = System.Int64;\n  using u64 = System.UInt64;\n  using LONGDOUBLE_TYPE = System.Double;\n  using sqlite_u3264 = System.UInt64;\n  using va_list = System.Object;\n\n  public partial class CSSQLite\n  {\n    /*\n    ** The "printf" code that follows dates from the 1980\'s.  It is in\n    ** the public domain.  The original comments are included here for\n    ** completeness.  They are very out-of-date but might be useful as\n    ** an historical reference.  Most of the "enhancements" have been backed\n    ** out so that the functionality is now the same as standard printf().\n    **\n    ** $Id: printf.c,v 1.104 2009/06/03 01:24:54 drh Exp $\n    **\n    *************************************************************************\n    **  Included in SQLite3 port to C#-SQLite;  2008 Noah B Hart\n    **  C#-SQLite is an independent reimplementation of the SQLite software library\n    **\n    **  $Header$\n    *************************************************************************\n    **\n    **************************************************************************\n    **\n    ** The following modules is an enhanced replacement for the "printf" subroutines\n    ** found in the standard C library.  The following enhancements are\n    ** supported:\n    **\n    **      +  Additional functions.  The standard set of "printf" functions\n    **         includes printf, fprintf, sprintf, vprintf, vfprintf, and\n    **         vsprintf.  This module adds the following:\n    **\n    **           *  snprintf -- Works like sprintf, but has an extra argument\n    **                          which is the size of the buffer written to.\n    **\n    **           *  mprintf --  Similar to sprintf.  Writes output to memory\n    **                          obtained from malloc.\n    **\n    **           *  xprintf --  Calls a function to dispose of output.\n    **\n    **           *  nprintf --  No output, but returns the number of characters\n    **                          that would have been output by printf.\n    **\n    **           *  A v- version (ex: vsnprintf) of every function is also\n    **              supplied.\n    **\n    **      +  A few extensions to the formatting notation are supported:\n    **\n    **           *  The "=" flag (similar to "-") causes the output to be\n    **              be centered in the appropriately sized field.\n    **\n    **           *  The %b field outputs an integer in binary notation.\n    **\n    **           *  The %c field now accepts a precision.  The character output\n    **              is repeated by the number of times the precision specifies.\n    **\n    **           *  The %\' field works like %c, but takes as its character the\n    **              next character of the format string, instead of the next\n    **              argument.  For example,  printf("%.78\'-")  prints 78 minus\n    **              signs, the same as  printf("%.78c",\'-\').\n    **\n    **      +  When compiled using GCC on a SPARC, this version of printf is\n    **         faster than the library printf for SUN OS 4.1.\n    **\n    **      +  All functions are fully reentrant.\n    **\n    */\n    //#include "sqliteInt.h"\n\n    /*\n    ** Conversion types fall into various categories as defined by the\n    ** following enumeration.\n    */\n    //#define etRADIX       1 /* Integer types.  %d, %x, %o, and so forth */\n    //#define etFLOAT       2 /* Floating point.  %f */\n    //#define etEXP         3 /* Exponentional notation. %e and %E */\n    //#define etGENERIC     4 /* Floating or exponential, depending on exponent. %g */\n    //#define etSIZE        5 /* Return number of characters processed so far. %n */\n    //#define etSTRING      6 /* Strings. %s */\n    //#define etDYNSTRING   7 /* Dynamically allocated strings. %z */\n    //#define etPERCENT     8 /* Percent symbol. %% */\n    //#define etCHARX       9 /* Characters. %c */\n    ///* The rest are extensions, not normally found in printf() */\n    //#define etSQLESCAPE  10 /* Strings with \'\\\'\' doubled.  %q */\n    //#define etSQLESCAPE2 11 /* Strings with \'\\\'\' doubled and enclosed in \'\',\n    //                          NULL pointers replaced by SQL NULL.  %Q */\n    //#define etTOKEN      12 /* a pointer to a Token structure */\n    //#define etSRCLIST    13 /* a pointer to a SrcList */\n    //#define etPOINTER    14 /* The %p conversion */\n    //#define etSQLESCAPE3 15 /* %w -> Strings with \'\\"\' doubled */\n    //#define etORDINAL    16 /* %r -> 1st, 2nd, 3rd, 4th, etc.  English only */\n\n    //#define etINVALID     0 /* Any unrecognized conversion type */\n\n    const int etRADIX = 1; /* Integer types.  %d, %x, %o, and so forth */\n    const int etFLOAT = 2; /* Floating point.  %f */\n    const int etEXP = 3; /* Exponentional notation. %e and %E */\n    const int etGENERIC = 4; /* Floating or exponential, depending on exponent. %g */\n    const int etSIZE = 5; /* Return number of characters processed so far. %n */\n    const int etSTRING = 6; /* Strings. %s */\n    const int etDYNSTRING = 7; /* Dynamically allocated strings. %z */\n    const int etPERCENT = 8; /* Percent symbol. %% */\n    const int etCHARX = 9; /* Characters. %c */\n    /* The rest are extensions, not normally found in printf() */\n    const int etSQLESCAPE = 10; /* Strings with \'\\\'\' doubled.  %q */\n    const int etSQLESCAPE2 = 11; /* Strings with \'\\\'\' doubled and enclosed in \'\',\nNULL pointers replaced by SQL NULL.  %Q */\n    const int etTOKEN = 12; /* a pointer to a Token structure */\n    const int etSRCLIST = 13; /* a pointer to a SrcList */\n    const int etPOINTER = 14; /* The %p conversion */\n    const int etSQLESCAPE3 = 15; /* %w . Strings with \'\\"\' doubled */\n    const int etORDINAL = 16; /* %r . 1st, 2nd, 3rd, 4th, etc.  English only */\n    const int etINVALID = 0; /* Any unrecognized conversion type */\n\n    /*\n    ** An "etByte" is an 8-bit unsigned value.\n    */\n    //typedef unsigned char etByte;\n\n    /*\n    ** Each builtin conversion character (ex: the \'d\' in "%d") is described\n    ** by an instance of the following structure\n    */\n    public class et_info\n    {   /* Information about each format field */\n      public char fmttype;            /* The format field code letter */\n      public byte _base;             /* The _base for radix conversion */\n      public byte flags;            /* One or more of FLAG_ constants below */\n      public byte type;             /* Conversion paradigm */\n      public byte charset;          /* Offset into aDigits[] of the digits string */\n      public byte prefix;           /* Offset into aPrefix[] of the prefix string */\n      /*\n      * Constructor\n      */\n      public et_info( char fmttype,\n      byte _base,\n      byte flags,\n      byte type,\n      byte charset,\n      byte prefix\n      )\n      {\n        this.fmttype = fmttype;\n        this._base = _base;\n        this.flags = flags;\n        this.type = type;\n        this.charset = charset;\n        this.prefix = prefix;\n      }\n\n    }\n\n    /*\n    ** Allowed values for et_info.flags\n    */\n    const byte FLAG_SIGNED = 1;    /* True if the value to convert is signed */\n    const byte FLAG_INTERN = 2;    /* True if for internal use only */\n    const byte FLAG_STRING = 4;    /* Allow infinity precision */\n\n\n    /*\n    ** The following table is searched linearly, so it is good to put the\n    ** most frequently used conversion types first.\n    */\n    static string aDigits = "0123456789ABCDEF0123456789abcdef";\n    static string aPrefix = "-x0\\000X0";\n    static et_info[] fmtinfo = new et_info[] {\nnew et_info(  \'d\', 10, 1, etRADIX,      0,  0 ),\nnew et_info(   \'s\',  0, 4, etSTRING,     0,  0 ),\nnew et_info(   \'g\',  0, 1, etGENERIC,    30, 0 ),\nnew et_info(   \'z\',  0, 4, etDYNSTRING,  0,  0 ),\nnew et_info(   \'q\',  0, 4, etSQLESCAPE,  0,  0 ),\nnew et_info(   \'Q\',  0, 4, etSQLESCAPE2, 0,  0 ),\nnew et_info(   \'w\',  0, 4, etSQLESCAPE3, 0,  0 ),\nnew et_info(   \'c\',  0, 0, etCHARX,      0,  0 ),\nnew et_info(   \'o\',  8, 0, etRADIX,      0,  2 ),\nnew et_info(   \'u\', 10, 0, etRADIX,      0,  0 ),\nnew et_info(   \'x\', 16, 0, etRADIX,      16, 1 ),\nnew et_info(   \'X\', 16, 0, etRADIX,      0,  4 ),\n#if !SQLITE_OMIT_FLOATING_POINT\nnew et_info(   \'f\',  0, 1, etFLOAT,      0,  0 ),\nnew et_info(   \'e\',  0, 1, etEXP,        30, 0 ),\nnew et_info(   \'E\',  0, 1, etEXP,        14, 0 ),\nnew et_info(   \'G\',  0, 1, etGENERIC,    14, 0 ),\n#endif\nnew et_info(   \'i\', 10, 1, etRADIX,      0,  0 ),\nnew et_info(   \'n\',  0, 0, etSIZE,       0,  0 ),\nnew et_info(   \'%\',  0, 0, etPERCENT,    0,  0 ),\nnew et_info(   \'p\', 16, 0, etPOINTER,    0,  1 ),\n\n/* All the rest have the FLAG_INTERN bit set and are thus for internal\n** use only */\nnew et_info(   \'T\',  0, 2, etTOKEN,      0,  0 ),\nnew et_info(   \'S\',  0, 2, etSRCLIST,    0,  0 ),\nnew et_info(   \'r\', 10, 3, etORDINAL,    0,  0 ),\n};\n    /*\n    ** If SQLITE_OMIT_FLOATING_POINT is defined, then none of the floating point\n    ** conversions will work.\n    */\n#if  !SQLITE_OMIT_FLOATING_POINT\n    /*\n** "*val" is a double such that 0.1 <= *val < 10.0\n** Return the ascii code for the leading digit of *val, then\n** multiply "*val" by 10.0 to renormalize.\n**\n** Example:\n**     input:     *val = 3.14159\n**     output:    *val = 1.4159    function return = \'3\'\n**\n** The counter *cnt is incremented each time.  After counter exceeds\n** 16 (the number of significant digits in a 64-bit float) \'0\' is\n** always returned.\n*/\n    static char et_getdigit( ref LONGDOUBLE_TYPE val, ref int cnt )\n    {\n      int digit;\n      LONGDOUBLE_TYPE d;\n      if ( cnt++ >= 16 ) return \'\\0\';\n      digit = (int)val;\n      d = digit;\n      //digit += \'0\';\n      val = ( val - d ) * 10.0;\n      return (char)digit;\n    }\n#endif // * SQLITE_OMIT_FLOATING_POINT */\n\n    /*\n** Append N space characters to the given string buffer.\n*/\n    static void appendSpace( StrAccum pAccum, int N )\n    {\n      //static const char zSpaces[] = "                             ";\n      //while( N>=zSpaces.Length-1 ){\n      //  sqlite3StrAccumAppend(pAccum, zSpaces, zSpaces.Length-1);\n      //  N -= zSpaces.Length-1;\n      //}\n      //if( N>0 ){\n      //  sqlite3StrAccumAppend(pAccum, zSpaces, N);\n      //}\n      pAccum.zText.AppendFormat( "{0," + N + "}", "" );\n    }\n\n    /*\n    ** On machines with a small stack size, you can redefine the\n    ** SQLITE_PRINT_BUF_SIZE to be less than 350.\n    */\n#if !SQLITE_PRINT_BUF_SIZE\n# if (SQLITE_SMALL_STACK)\nconst int SQLITE_PRINT_BUF_SIZE = 50;\n# else\n    const int SQLITE_PRINT_BUF_SIZE = 350;\n#endif\n#endif\n    const int etBUFSIZE = SQLITE_PRINT_BUF_SIZE; /* Size of the output buffer */\n\n    /*\n    ** The root program.  All variations call this core.\n    **\n    ** INPUTS:\n    **   func   This is a pointer to a function taking three arguments\n    **            1. A pointer to anything.  Same as the "arg" parameter.\n    **            2. A pointer to the list of characters to be output\n    **               (Note, this list is NOT null terminated.)\n    **            3. An integer number of characters to be output.\n    **               (Note: This number might be zero.)\n    **\n    **   arg    This is the pointer to anything which will be passed as the\n    **          first argument to "func".  Use it for whatever you like.\n    **\n    **   fmt    This is the format string, as in the usual print.\n    **\n    **   ap     This is a pointer to a list of arguments.  Same as in\n    **          vfprint.\n    **\n    ** OUTPUTS:\n    **          The return value is the total number of characters sent to\n    **          the function "func".  Returns -1 on a error.\n    **\n    ** Note that the order in which automatic variables are declared below\n    ** seems to make a big difference in determining how fast this beast\n    ** will run.\n    */\n    static void sqlite3VXPrintf(\n    StrAccum pAccum,             /* Accumulate results here */\n    int useExtended,             /* Allow extended %-conversions */\n    string fmt,                   /* Format string */\n    va_list[] ap                   /* arguments */\n    )\n    {\n      int c;                     /* Next character in the format string */\n      int bufpt;                 /* Pointer to the conversion buffer */\n      int precision;             /* Precision of the current field */\n      int length;                /* Length of the field */\n      int idx;                   /* A general purpose loop counter */\n      int width;                 /* Width of the current field */\n      etByte flag_leftjustify;   /* True if "-" flag is present */\n      etByte flag_plussign;      /* True if "+" flag is present */\n      etByte flag_blanksign;     /* True if " " flag is present */\n      etByte flag_alternateform; /* True if "#" flag is present */\n      etByte flag_altform2;      /* True if "!" flag is present */\n      etByte flag_zeropad;       /* True if field width constant starts with zero */\n      etByte flag_long;          /* True if "l" flag is present */\n      etByte flag_longlong;      /* True if the "ll" flag is present */\n      etByte done;               /* Loop termination flag */\n      i64 longvalue;\n      LONGDOUBLE_TYPE realvalue; /* Value for real types */\n      et_info infop;      /* Pointer to the appropriate info structure */\n      char[] buf = new char[etBUFSIZE];       /* Conversion buffer */\n      char prefix;                /* Prefix character.  "+" or "-" or " " or \'\\0\'. */\n      byte xtype = 0;             /* Conversion paradigm */\n      // Not used in C# -- string zExtra;              /* Extra memory used for etTCLESCAPE conversions */\n#if !SQLITE_OMIT_FLOATING_POINT\n      int exp, e2;                /* exponent of real numbers */\n      double rounder;             /* Used for rounding floating point values */\n      etByte flag_dp;             /* True if decimal point should be shown */\n      etByte flag_rtz;            /* True if trailing zeros should be removed */\n      etByte flag_exp;            /* True to force display of the exponent */\n      int nsd;                    /* Number of significant digits returned */\n#endif\n      length = 0;\n      bufpt = 0;\n      int _fmt = 0; // Work around string pointer\n      fmt += \'\\0\';\n\n      for ( ; _fmt <= fmt.Length && ( c = fmt[_fmt] ) != 0 ; ++_fmt )\n      {\n        if ( c != \'%\' )\n        {\n          int amt;\n          bufpt = _fmt;\n          amt = 1;\n          while ( _fmt < fmt.Length && ( c = ( fmt[++_fmt] ) ) != \'%\' && c != 0 ) amt++;\n          sqlite3StrAccumAppend( pAccum, fmt.Substring( bufpt, amt ), amt );\n          if ( c == 0 ) break;\n        }\n        if ( _fmt < fmt.Length && ( c = ( fmt[++_fmt] ) ) == 0 )\n        {\n          sqlite3StrAccumAppend( pAccum, "%", 1 );\n          break;\n        }\n        /* Find out what flags are present */\n        flag_leftjustify = flag_plussign = flag_blanksign =\n        flag_alternateform = flag_altform2 = flag_zeropad = false;\n        done = false;\n        do\n        {\n          switch ( c )\n          {\n            case \'-\': flag_leftjustify = true; break;\n            case \'+\': flag_plussign = true; break;\n            case \' \': flag_blanksign = true; break;\n            case \'#\': flag_alternateform = true; break;\n            case \'!\': flag_altform2 = true; break;\n            case \'0\': flag_zeropad = true; break;\n            default: done = true; break;\n          }\n        } while ( !done && _fmt < fmt.Length - 1 && ( c = ( fmt[++_fmt] ) ) != 0 );\n        /* Get the field width */\n        width = 0;\n        if ( c == \'*\' )\n        {\n          width = (int)va_arg( ap, "int" );\n          if ( width < 0 )\n          {\n            flag_leftjustify = true;\n            width = -width;\n          }\n          c = fmt[++_fmt];\n        }\n        else\n        {\n          while ( c >= \'0\' && c <= \'9\' )\n          {\n            width = width * 10 + c - \'0\';\n            c = fmt[++_fmt];\n          }\n        }\n        if ( width > etBUFSIZE - 10 )\n        {\n          width = etBUFSIZE - 12;\n        }\n        /* Get the precision */\n        if ( c == \'.\' )\n        {\n          precision = 0;\n          c = fmt[++_fmt];\n          if ( c == \'*\' )\n          {\n            precision = (int)va_arg( ap, "int" );\n            if ( precision < 0 ) precision = -precision;\n            c = fmt[++_fmt];\n          }\n          else\n          {\n            while ( c >= \'0\' && c <= \'9\' )\n            {\n              precision = precision * 10 + c - \'0\';\n              c = fmt[++_fmt];\n            }\n          }\n        }\n        else\n        {\n          precision = -1;\n        }\n        /* Get the conversion type modifier */\n        if ( c == \'l\' )\n        {\n          flag_long = true;\n          c = fmt[++_fmt];\n          if ( c == \'l\' )\n          {\n            flag_longlong = true;\n            c = fmt[++_fmt];\n          }\n          else\n          {\n            flag_longlong = false;\n          }\n        }\n        else\n        {\n          flag_long = flag_longlong = false;\n        }\n        /* Fetch the info entry for the field */\n        infop = fmtinfo[0];\n        xtype = etINVALID;\n        for ( idx = 0 ; idx < ArraySize( fmtinfo ) ; idx++ )\n        {\n          if ( c == fmtinfo[idx].fmttype )\n          {\n            infop = fmtinfo[idx];\n            if ( useExtended != 0 || ( infop.flags & FLAG_INTERN ) == 0 )\n            {\n              xtype = infop.type;\n            }\n            else\n            {\n              return;\n            }\n            break;\n          }\n        }\n        //zExtra = null;\n\n        /* Limit the precision to prevent overflowing buf[] during conversion */\n        if ( precision > etBUFSIZE - 40 && ( infop.flags & FLAG_STRING ) == 0 )\n        {\n          precision = etBUFSIZE - 40;\n        }\n\n        /*\n        ** At this point, variables are initialized as follows:\n        **\n        **   flag_alternateform          TRUE if a \'#\' is present.\n        **   flag_altform2               TRUE if a \'!\' is present.\n        **   flag_plussign               TRUE if a \'+\' is present.\n        **   flag_leftjustify            TRUE if a \'-\' is present or if the\n        **                               field width was negative.\n        **   flag_zeropad                TRUE if the width began with 0.\n        **   flag_long                   TRUE if the letter \'l\' (ell) prefixed\n        **                               the conversion character.\n        **   flag_longlong               TRUE if the letter \'ll\' (ell ell) prefixed\n        **                               the conversion character.\n        **   flag_blanksign              TRUE if a \' \' is present.\n        **   width                       The specified field width.  This is\n        **                               always non-negative.  Zero is the default.\n        **   precision                   The specified precision.  The default\n        **                               is -1.\n        **   xtype                       The class of the conversion.\n        **   infop                       Pointer to the appropriate info struct.\n        */\n        switch ( xtype )\n        {\n          case etPOINTER:\n            flag_longlong = true;// char*.Length == sizeof(i64);\n            flag_long = false;// char*.Length == sizeof(long);\n            /* Fall through into the next case */\n            goto case etRADIX;\n          case etORDINAL:\n          case etRADIX:\n            if ( ( infop.flags & FLAG_SIGNED ) != 0 )\n            {\n              i64 v;\n              if ( flag_longlong )\n              {\n                v = (long)va_arg( ap, "i64" );\n              }\n              else if ( flag_long )\n              {\n                v = (long)va_arg( ap, "long int" );\n              }\n              else\n              {\n                v = (int)va_arg( ap, "int" );\n              }\n              if ( v < 0 )\n              {\n                longvalue = -v;\n                prefix = \'-\';\n              }\n              else\n              {\n                longvalue = v;\n                if ( flag_plussign ) prefix = \'+\';\n                else if ( flag_blanksign ) prefix = \' \';\n                else prefix = \'\\0\';\n              }\n            }\n            else\n            {\n              if ( flag_longlong )\n              {\n                longvalue = (i64)va_arg( ap, "longlong int" );\n              }\n              else if ( flag_long )\n              {\n                longvalue = (i64)va_arg( ap, "long int" );\n              }\n              else\n              {\n                longvalue = (i64)va_arg( ap, "long" );\n              }\n              prefix = \'\\0\';\n            }\n            if ( longvalue == 0 ) flag_alternateform = false;\n            if ( flag_zeropad && precision < width - ( ( prefix != \'\\0\' ) ? 1 : 0 ) )\n            {\n              precision = width - ( ( prefix != \'\\0\' ) ? 1 : 0 );\n            }\n            bufpt = buf.Length;//[etBUFSIZE-1];\n            char[] _bufOrd = null;\n            if ( xtype == etORDINAL )\n            {\n              char[] zOrd = "thstndrd".ToCharArray();\n              int x = (int)( longvalue % 10 );\n              if ( x >= 4 || ( longvalue / 10 ) % 10 == 1 )\n              {\n                x = 0;\n              }\n              _bufOrd = new char[2];\n              _bufOrd[0] = zOrd[x * 2];\n              _bufOrd[1] = zOrd[x * 2 + 1];\n              //bufpt -= 2;\n            }\n            {\n\n              char[] _buf;\n              switch ( infop._base )\n              {\n                case 16:\n                  _buf = longvalue.ToString( "x" ).ToCharArray();\n                  break;\n                case 8:\n                  _buf = Convert.ToString( (long)longvalue, 8 ).ToCharArray();\n                  break;\n                default:\n                  {\n                    if ( flag_zeropad )\n                      _buf = longvalue.ToString( new string( \'0\', width - ( ( prefix != \'\\0\' ) ? 1 : 0 ) ) ).ToCharArray();\n                    else\n                      _buf = longvalue.ToString().ToCharArray();\n                  }\n                  break;\n              }\n              bufpt = buf.Length - _buf.Length - ( _bufOrd == null ? 0 : 2 );\n              Array.Copy( _buf, 0, buf, bufpt, _buf.Length );\n              if ( _bufOrd != null )\n              {\n                buf[buf.Length - 1] = _bufOrd[1];\n                buf[buf.Length - 2] = _bufOrd[0];\n              }\n              //char* cset;      /* Use registers for speed */\n              //int _base;\n              //cset = aDigits[infop.charset];\n              //_base = infop._base;\n              //do\n              //{ /* Convert to ascii */\n              //   *(--bufpt) = cset[longvalue % (ulong)_base];\n              //  longvalue = longvalue / (ulong)_base;\n              //} while (longvalue > 0);\n            }\n            length = buf.Length - bufpt;//length = (int)(&buf[etBUFSIZE-1]-bufpt);\n            for ( idx = precision - length ; idx > 0 ; idx-- )\n            {\n              buf[( --bufpt )] = \'0\';                             /* Zero pad */\n            }\n            if ( prefix != \'\\0\' ) buf[--bufpt] = prefix;   /* Add sign */\n            if ( flag_alternateform && infop.prefix != 0 )\n            {      /* Add "0" or "0x" */\n              int pre;\n              char x;\n              pre = infop.prefix;\n              for ( ; ( x = aPrefix[pre] ) != 0 ; pre++ ) buf[--bufpt] = x;\n            }\n            length = buf.Length - bufpt;//length = (int)(&buf[etBUFSIZE-1]-bufpt);\n            break;\n          case etFLOAT:\n          case etEXP:\n          case etGENERIC:\n            realvalue = (double)va_arg( ap, "double" );\n#if !SQLITE_OMIT_FLOATING_POINT\n            if ( precision < 0 ) precision = 6;         /* Set default precision */\n            if ( precision > etBUFSIZE / 2 - 10 ) precision = etBUFSIZE / 2 - 10;\n            if ( realvalue < 0.0 )\n            {\n              realvalue = -realvalue;\n              prefix = \'-\';\n            }\n            else\n            {\n              if ( flag_plussign ) prefix = \'+\';\n              else if ( flag_blanksign ) prefix = \' \';\n              else prefix = \'\\0\';\n            }\n            if ( xtype == etGENERIC && precision > 0 ) precision--;\n#if FALSE\n/* Rounding works like BSD when the constant 0.4999 is used.  Wierd! */\nfor(idx=precision, rounder=0.4999; idx>0; idx--, rounder*=0.1);\n#else\n            /* It makes more sense to use 0.5 */\n            for ( idx = precision, rounder = 0.5 ; idx > 0 ; idx--, rounder *= 0.1 ) { }\n#endif\n            if ( xtype == etFLOAT ) realvalue += rounder;\n            /* Normalize realvalue to within 10.0 > realvalue >= 1.0 */\n            exp = 0;\n            double d = 0;\n            if ( Double.IsNaN( realvalue ) || !( Double.TryParse( Convert.ToString( realvalue ), out d ) ) )//if( sqlite3IsNaN((double)realvalue) )\n            {\n              buf = "NaN".ToCharArray();\n              length = 3;\n              break;\n            }\n            if ( realvalue > 0.0 )\n            {\n              while ( realvalue >= 1e32 && exp <= 350 ) { realvalue *= 1e-32; exp += 32; }\n              while ( realvalue >= 1e8 && exp <= 350 ) { realvalue *= 1e-8; exp += 8; }\n              while ( realvalue >= 10.0 && exp <= 350 ) { realvalue *= 0.1; exp++; }\n              while ( realvalue < 1e-8 ) { realvalue *= 1e8; exp -= 8; }\n              while ( realvalue < 1.0 ) { realvalue *= 10.0; exp--; }\n              if ( exp > 350 )\n              {\n                if ( prefix == \'-\' )\n                {\n                  buf = "-Inf".ToCharArray();\n                  bufpt = 4;\n                }\n                else if ( prefix == \'+\' )\n                {\n                  buf = "+Inf".ToCharArray();\n                  bufpt = 4;\n                }\n                else\n                {\n                  buf = "Inf".ToCharArray();\n                  bufpt = 3;\n                }\n                length = sqlite3Strlen30( bufpt );// sqlite3Strlen30(bufpt);\n                bufpt = 0;\n                break;\n              }\n            }\n            bufpt = 0;\n            /*\n            ** If the field type is etGENERIC, then convert to either etEXP\n            ** or etFLOAT, as appropriate.\n            */\n            flag_exp = xtype == etEXP;\n            if ( xtype != etFLOAT )\n            {\n              realvalue += rounder;\n              if ( realvalue >= 10.0 ) { realvalue *= 0.1; exp++; }\n            }\n            if ( xtype == etGENERIC )\n            {\n              flag_rtz = !flag_alternateform;\n              if ( exp < -4 || exp > precision )\n              {\n                xtype = etEXP;\n              }\n              else\n              {\n                precision = precision - exp;\n                xtype = etFLOAT;\n              }\n            }\n            else\n            {\n              flag_rtz = false;\n            }\n            if ( xtype == etEXP )\n            {\n              e2 = 0;\n            }\n            else\n            {\n              e2 = exp;\n            }\n            nsd = 0;\n            flag_dp = ( precision > 0 ? true : false ) | flag_alternateform | flag_altform2;\n            /* The sign in front of the number */\n            if ( prefix != \'\\0\' )\n            {\n              buf[bufpt++] = prefix;\n            }\n            /* Digits prior to the decimal point */\n            if ( e2 < 0 )\n            {\n              buf[bufpt++] = \'0\';\n            }\n            else\n            {\n              for ( ; e2 >= 0 ; e2-- )\n              {\n                buf[bufpt++] = (char)( et_getdigit( ref realvalue, ref nsd ) + \'0\' ); // *(bufpt++) = et_getdigit(ref realvalue, ref nsd);\n              }\n\n            }\n            /* The decimal point */\n            if ( flag_dp )\n            {\n              buf[bufpt++] = \'.\';\n            }\n            /* "0" digits after the decimal point but before the first\n            ** significant digit of the number */\n            for ( e2++ ; e2 < 0 ; precision--, e2++ )\n            {\n              Debug.Assert( precision > 0 );\n              buf[bufpt++] = \'0\';\n            }\n            /* Significant digits after the decimal point */\n            while ( ( precision-- ) > 0 )\n            {\n              buf[bufpt++] = (char)( et_getdigit( ref realvalue, ref nsd ) + \'0\' ); // *(bufpt++) = et_getdigit(&realvalue, nsd);\n            }\n            /* Remove trailing zeros and the "." if no digits follow the "." */\n            if ( flag_rtz && flag_dp )\n            {\n              while ( buf[bufpt - 1] == \'0\' ) buf[--bufpt] = \'\\0\';\n              Debug.Assert( bufpt > 0 );\n              if ( buf[bufpt - 1] == \'.\' )\n              {\n                if ( flag_altform2 )\n                {\n                  buf[( bufpt++ )] = \'0\';\n                }\n                else\n                {\n                  buf[( --bufpt )] = \'0\';\n                }\n              }\n            }\n            /* Add the "eNNN" suffix */\n            if ( flag_exp || xtype == etEXP )\n            {\n              buf[bufpt++] = aDigits[infop.charset];\n              if ( exp < 0 )\n              {\n                buf[bufpt++] = \'-\'; exp = -exp;\n              }\n              else\n              {\n                buf[bufpt++] = \'+\';\n              }\n              if ( exp >= 100 )\n              {\n                buf[bufpt++] = (char)( exp / 100 + \'0\' );                /* 100\'s digit */\n                exp %= 100;\n              }\n              buf[bufpt++] = (char)( exp / 10 + \'0\' );                     /* 10\'s digit */\n              buf[bufpt++] = (char)( exp % 10 + \'0\' );                     /* 1\'s digit */\n            }\n            //bufpt = 0;\n\n            /* The converted number is in buf[] and zero terminated. Output it.\n            ** Note that the number is in the usual order, not reversed as with\n            ** integer conversions. */\n            length = bufpt;//length = (int)(bufpt-buf);\n            bufpt = 0;\n\n            /* Special case:  Add leading zeros if the flag_zeropad flag is\n            ** set and we are not left justified */\n            if ( flag_zeropad && !flag_leftjustify && length < width )\n            {\n              int i;\n              int nPad = width - length;\n              for ( i = width ; i >= nPad ; i-- )\n              {\n                buf[bufpt + i] = buf[bufpt + i - nPad];\n              }\n              i = ( prefix != \'\\0\' ? 1 : 0 );\n              while ( nPad-- != 0 ) buf[( bufpt++ ) + i] = \'0\';\n              length = width;\n              bufpt = 0;\n            }\n#endif\n            break;\n          case etSIZE:\n            ap[0] = pAccum.nChar; // *(va_arg(ap,int*)) = pAccum.nChar;\n            length = width = 0;\n            break;\n          case etPERCENT:\n            buf[0] = \'%\';\n            bufpt = 0;\n            length = 1;\n            break;\n          case etCHARX:\n            c = (char)va_arg( ap, "char" );\n            buf[0] = (char)c;\n            if ( precision >= 0 )\n            {\n              for ( idx = 1 ; idx < precision ; idx++ ) buf[idx] = (char)c;\n              length = precision;\n            }\n            else\n            {\n              length = 1;\n            }\n            bufpt = 0;\n            break;\n          case etSTRING:\n          case etDYNSTRING:\n            bufpt = 0;//\n            string bufStr = (string)va_arg( ap, "string" );\n            if ( bufStr.Length > buf.Length ) buf = new char[bufStr.Length];\n            bufStr.ToCharArray().CopyTo( buf, 0 );\n            bufpt = bufStr.Length;\n            if ( bufpt == 0 )\n            {\n              buf[0] = \'\\0\';\n            }\n            else if ( xtype == etDYNSTRING )\n            {\n              //              zExtra = bufpt;\n            }\n            if ( precision >= 0 )\n            {\n              for ( length = 0 ; length < precision && length < bufStr.Length && buf[length] != 0 ; length++ ) { }\n              //length += precision;\n            }\n            else\n            {\n              length = sqlite3Strlen30( bufpt );\n            }\n            bufpt = 0;\n            break;\n          case etSQLESCAPE:\n          case etSQLESCAPE2:\n          case etSQLESCAPE3:\n            {\n              int i; int j; int n;\n              bool isnull;\n              bool needQuote;\n              char ch;\n              char q = ( ( xtype == etSQLESCAPE3 ) ? \'"\' : \'\\\'\' );   /* Quote character */\n              string escarg = (string)va_arg( ap, "char*" ) + \'\\0\';\n              isnull = ( escarg == "" || escarg == "NULL\\0" );\n              if ( isnull ) escarg = ( xtype == etSQLESCAPE2 ) ? "NULL\\0" : "(NULL)\\0";\n              for ( i = n = 0 ; ( ch = escarg[i] ) != 0 ; i++ )\n              {\n                if ( ch == q ) n++;\n              }\n              needQuote = !isnull && ( xtype == etSQLESCAPE2 );\n              n += i + 1 + ( needQuote ? 2 : 0 );\n              if ( n > etBUFSIZE )\n              {\n                buf = new char[n];//bufpt = zExtra = sqlite3Malloc(n);\n                //if ( bufpt == 0 )\n                //{\n                //  pAccum->mallocFailed = 1;\n                //  return;\n                //}\n                bufpt = 0; //Start of Buffer\n              }\n              else\n              {\n                //bufpt = buf;\n                bufpt = 0; //Start of Buffer\n              }\n              j = 0;\n              if ( needQuote ) buf[bufpt + j++] = q;\n              for ( i = 0 ; ( ch = escarg[i] ) != 0 ; i++ )\n              {\n                buf[bufpt + j++] = ch;\n                if ( ch == q ) buf[bufpt + j++] = ch;\n              }\n              if ( needQuote ) buf[bufpt + j++] = q;\n              buf[bufpt + j] = \'\\0\';\n              length = j;\n              /* The precision is ignored on %q and %Q */\n              /* if( precision>=0 && precision<length ) length = precision; */\n              break;\n            }\n          case etTOKEN:\n            {\n              Token pToken = (Token)va_arg( ap, "Token" );\n              if ( pToken != null )\n              {\n                sqlite3StrAccumAppend( pAccum, pToken.z.ToString(), (int)pToken.n );\n              }\n              length = width = 0;\n              break;\n            }\n          case etSRCLIST:\n            {\n              SrcList pSrc = (SrcList)va_arg( ap, "SrcList" );\n              int k = (int)va_arg( ap, "int" );\n              SrcList_item pItem = pSrc.a[k];\n              Debug.Assert( k >= 0 && k < pSrc.nSrc );\n              if ( pItem.zDatabase != null )\n              {\n                sqlite3StrAccumAppend( pAccum, pItem.zDatabase, -1 );\n                sqlite3StrAccumAppend( pAccum, ".", 1 );\n              }\n              sqlite3StrAccumAppend( pAccum, pItem.zName, -1 );\n              length = width = 0;\n              break;\n            }\n          default:\n            {\n              Debug.Assert( xtype == etINVALID );\n              return;\n            }\n        }/* End switch over the format type */\n        /*\n        ** The text of the conversion is pointed to by "bufpt" and is\n        ** "length" characters long.  The field width is "width".  Do\n        ** the output.\n        */\n        if ( !flag_leftjustify )\n        {\n          int nspace;\n          nspace = width - length;// -2;\n          if ( nspace > 0 )\n          {\n            appendSpace( pAccum, nspace );\n          }\n        }\n        if ( length > 0 )\n        {\n          sqlite3StrAccumAppend( pAccum, new string( buf, bufpt, length ), length );\n        }\n        if ( flag_leftjustify )\n        {\n          int nspace;\n          nspace = width - length;\n          if ( nspace > 0 )\n          {\n            appendSpace( pAccum, nspace );\n          }\n        }\n        //if( zExtra ){\n        //  //sqlite3DbFree(db,ref  zExtra);\n        //}\n      }/* End for loop over the format string */\n    } /* End of function */\n\n    /*\n    ** Append N bytes of text from z to the StrAccum object.\n    */\n\n    static void sqlite3StrAccumAppend( StrAccum p, string z, int N )\n    {\n      Debug.Assert( z != null || N == 0 );\n      if ( p.tooBig != 0 )//|| p.mallocFailed != 0 )\n      {\n        testcase( p.tooBig );\n        //testcase( p.mallocFailed );\n        return;\n      }\n      if ( N < 0 )\n      {\n        N = sqlite3Strlen30( z );\n      }\n      if ( N == 0 || NEVER( z == null ) )\n      {\n        return;\n      }\n      //if ( p.nChar + N >= p.nAlloc )\n      //{\n      //  char* zNew;\n      //  if ( !p.useMalloc )\n      //  {\n      //    p.tooBig = 1;\n      //    N = p.nAlloc - p.nChar - 1;\n      //    if ( N <= 0 )\n      //    {\n      //      return;\n      //    }\n      //  }\n      //  else\n      //  {\n      //    i64 szNew = p.nChar;\n      //    szNew += N + 1;\n      //    if ( szNew > p.mxAlloc )\n      //    {\n      //      sqlite3StrAccumReset( p );\n      //      p.tooBig = 1;\n      //      return;\n      //    }\n      //    else\n      //    {\n      //      p.nAlloc = (int)szNew;\n      //    }\n      //    zNew = sqlite3DbMalloc( p.nAlloc );\n      //    if ( zNew )\n      //    {\n      //      memcpy( zNew, p.zText, p.nChar );\n      //      sqlite3StrAccumReset( p );\n      //      p.zText = zNew;\n      //    }\n      //    else\n      //    {\n      //      p.mallocFailed = 1;\n      //      sqlite3StrAccumReset( p );\n      //      return;\n      //    }\n      //  }\n      //}\n      //memcpy( &p.zText[p.nChar], z, N );\n      p.zText.Append( z.Substring( 0, N <= z.Length ? N : z.Length ) );\n      p.nChar += N;\n    }\n\n    /*\n    ** Finish off a string by making sure it is zero-terminated.\n    ** Return a pointer to the resulting string.  Return a NULL\n    ** pointer if any kind of error was encountered.\n    */\n    static string sqlite3StrAccumFinish( StrAccum p )\n    {\n      //if (p.zText.Length > 0)\n      //{\n      //  p.zText[p.nChar] = 0;\n      //  if (p.useMalloc && p.zText == p.zBase)\n      //  {\n      //    p.zText = sqlite3DbMalloc(p.nChar + 1);\n      //    if (p.zText)\n      //    {\n      //      memcpy(p.zText, p.zBase, p.nChar + 1);\n      //    }\n      //    else\n      //    {\n      //      p.mallocFailed = 1;\n      //    }\n      //  }\n      //}\n      return p.zText.ToString();\n    }\n\n    /*\n    ** Reset an StrAccum string.  Reclaim all malloced memory.\n    */\n    static void sqlite3StrAccumReset( StrAccum p )\n    {\n      if ( p.zText.ToString() != p.zBase.ToString() )\n      {\n        //sqlite3DbFree( p.db, ref p.zText );\n      }\n      p.zText = new StringBuilder();\n    }\n\n    /*\n    ** Initialize a string accumulator\n    */\n    static void sqlite3StrAccumInit( StrAccum p, StringBuilder zBase, int n, int mx )\n    {\n      p.zText = p.zBase = zBase;\n      p.db = null;\n      p.nChar = 0;\n      p.nAlloc = n;\n      p.mxAlloc = mx;\n      p.useMalloc = 1;\n      p.tooBig = 0;\n      //p.mallocFailed = 0;\n    }\n\n    /*\n    ** Print into memory obtained from sqliteMalloc().  Use the internal\n    ** %-conversion extensions.\n    */\n    static string sqlite3VMPrintf( sqlite3 db, string zFormat, params va_list[] ap )\n    {\n      if ( zFormat == null ) return null;\n      if ( ap.Length == 0 ) return zFormat;\n      string z;\n      StringBuilder zBase = new StringBuilder( SQLITE_PRINT_BUF_SIZE );\n      StrAccum acc = new StrAccum();\n      Debug.Assert( db != null );\n      sqlite3StrAccumInit( acc, zBase, zBase.Capacity, //zBase).Length;\n      db.aLimit[SQLITE_LIMIT_LENGTH] );\n      acc.db = db;\n      sqlite3VXPrintf( acc, 1, zFormat, ap );\n      z = sqlite3StrAccumFinish( acc );\n//      if ( acc.mallocFailed != 0 )\n//      {\n//////        db.mallocFailed = 1;\n//      }\n      return z;\n    }\n\n    /*\n    ** Print into memory obtained from sqliteMalloc().  Use the internal\n    ** %-conversion extensions.\n    */\n    static string sqlite3MPrintf( sqlite3 db, string zFormat, params va_list[] ap )\n    {\n      //va_list ap;\n      string z;\n      va_start( ap, zFormat );\n      z = sqlite3VMPrintf( db, zFormat, ap );\n      va_end( ap );\n      return z;\n    }\n\n    /*\n    ** Like sqlite3MPrintf(), but call //sqlite3DbFree() on zStr after formatting\n    ** the string and before returnning.  This routine is intended to be used\n    ** to modify an existing string.  For example:\n    **\n    **       x = sqlite3MPrintf(db, x, "prefix %s suffix", x);\n    **\n    */\n    static string sqlite3MAppendf( sqlite3 db, string zStr, string zFormat, params  va_list[] ap )\n    {\n      //va_list ap;\n      string z;\n      va_start( ap, zFormat );\n      z = sqlite3VMPrintf( db, zFormat, ap );\n      va_end( ap );\n      //sqlite3DbFree( db, zStr );\n      return z;\n    }\n\n    /*\n    ** Print into memory obtained from sqlite3Malloc().  Omit the internal\n    ** %-conversion extensions.\n    */\n    static string sqlite3_vmprintf( string zFormat, params  va_list[] ap )\n    {\n      string z;\n      StringBuilder zBase = new StringBuilder( SQLITE_PRINT_BUF_SIZE );\n      StrAccum acc = new StrAccum();\n#if !SQLITE_OMIT_AUTOINIT\n      if ( sqlite3_initialize() != 0 ) return "";\n#endif\n      sqlite3StrAccumInit( acc, zBase, zBase.Length, SQLITE_PRINT_BUF_SIZE );//zBase).Length;\n      sqlite3VXPrintf( acc, 0, zFormat, ap );\n      z = sqlite3StrAccumFinish( acc );\n      return z;\n    }\n\n    /*\n    ** Print into memory obtained from sqlite3Malloc()().  Omit the internal\n    ** %-conversion extensions.\n    */\n    public static string sqlite3_mprintf( string zFormat, params va_list[] ap )\n    { //, ...){\n      //va_list ap;\n      string z;\n#if  !SQLITE_OMIT_AUTOINIT\n      if ( sqlite3_initialize() != 0 ) return "";\n#endif\n      va_start( ap, zFormat );\n      z = sqlite3_vmprintf( zFormat, ap );\n      va_end( ap );\n      return z;\n    }\n\n    /*\n    ** sqlite3_snprintf() works like snprintf() except that it ignores the\n    ** current locale settings.  This is important for SQLite because we\n    ** are not able to use a "," as the decimal point in place of "." as\n    ** specified by some locales.\n    */\n    public static string sqlite3_snprintf( int n, ref StringBuilder zBuf, string zFormat, params va_list[] ap )\n    {\n      StringBuilder zBase = new StringBuilder( SQLITE_PRINT_BUF_SIZE );\n      //va_list ap;\n      StrAccum acc = new StrAccum();\n\n      if ( n <= 0 )\n      {\n        return zBuf.ToString();\n      }\n      sqlite3StrAccumInit( acc, zBase, n, 0 );\n      acc.useMalloc = 0;\n      va_start( ap, zFormat );\n      sqlite3VXPrintf( acc, 0, zFormat, ap );\n      va_end( ap );\n      zBuf.Length = 0;\n      zBuf.Append( sqlite3StrAccumFinish( acc ) );\n      if ( n - 1 < zBuf.Length ) zBuf.Length = n - 1;\n      return zBuf.ToString();\n    }\n\n    public static string sqlite3_snprintf( int n, ref string zBuf, string zFormat, params va_list[] ap )\n    {\n      string z;\n      StringBuilder zBase = new StringBuilder( SQLITE_PRINT_BUF_SIZE );\n      //va_list ap;\n      StrAccum acc = new StrAccum();\n\n      if ( n <= 0 )\n      {\n        return zBuf;\n      }\n      sqlite3StrAccumInit( acc, zBase, n, 0 );\n      acc.useMalloc = 0;\n      va_start( ap, zFormat );\n      sqlite3VXPrintf( acc, 0, zFormat, ap );\n      va_end( ap );\n      z = sqlite3StrAccumFinish( acc );\n      return ( zBuf = z );\n    }\n\n#if SQLITE_DEBUG || DEBUG || TRACE\n    /*\n** A version of printf() that understands %lld.  Used for debugging.\n** The printf() built into some versions of windows does not understand %lld\n** and segfaults if you give it a long long int.\n*/\n    static void sqlite3DebugPrintf( string zFormat, params va_list[] ap )\n    {\n      //va_list ap;\n      StrAccum acc = new StrAccum();\n      StringBuilder zBuf = new StringBuilder( SQLITE_PRINT_BUF_SIZE );\n      sqlite3StrAccumInit( acc, zBuf, zBuf.Capacity, 0 );\n      acc.useMalloc = 0;\n      va_start( ap, zFormat );\n      sqlite3VXPrintf( acc, 0, zFormat, ap );\n      va_end( ap );\n      sqlite3StrAccumFinish( acc );\n      Console.Write( zBuf.ToString() );\n      //fflush(stdout);\n    }\n#endif\n  }\n}\n'