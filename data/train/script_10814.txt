b'{-# OPTIONS_GHC -fno-warn-type-defaults #-}\n{-# LANGUAGE NoImplicitPrelude #-}\n\nmodule Course.ListSpec where\n\nimport qualified Prelude               as P (length)\n\nimport           Test.Hspec            (Spec, describe, it, shouldBe)\nimport           Test.Hspec.QuickCheck (prop)\nimport           Test.QuickCheck       (forAllShrink)\n\nimport           Course.Core\nimport           Course.Gens           (forAllLists, genIntegerAndList, genList,\n                                        genListOfLists, genThreeLists,\n                                        genTwoLists, shrinkIntegerAndList,\n                                        shrinkList, shrinkListOfLists,\n                                        shrinkThreeLists, shrinkTwoLists)\nimport           Course.List           (List (..), filter, find, flatMap,\n                                        flatten, flattenAgain, foldLeft, headOr,\n                                        hlist, infinity, largeList, length,\n                                        lengthGT4, listh, map, produce, product,\n                                        reverse, seqOptional, sum, take, (++))\nimport           Course.Optional       (Optional (..))\n\nspec :: Spec\nspec = do\n  describe "headOr" $ do\n    it "headOr on non-empty list" $ headOr 3 (1 :. 2 :. Nil) `shouldBe` 1\n    it "headOr on empty list" $ headOr 3 Nil `shouldBe` 3\n    prop "headOr on infinity always 0" $ \\x -> x `headOr` infinity == 0\n    prop "headOr on empty list always the default" $ \\x -> x `headOr` Nil == (x :: Integer)\n\n  describe "productTest" $ do\n    it "product of empty list" $ product Nil `shouldBe` 1\n    it "product of 1..3" $ product (1 :. 2 :. 3 :. Nil) `shouldBe` 6\n    it "product of 1..4" $ product (1 :. 2 :. 3 :. 4 :. Nil) `shouldBe` 24\n\n  describe "sum" $ do\n    it "sum 1..3" $ sum (1 :. 2 :. 3 :. Nil) `shouldBe` 6\n    it "sum 1..4" $ sum (1 :. 2 :. 3 :. 4 :. Nil) `shouldBe` 10\n    prop "subtracting each element in a list from its sum is always 0" $\n      forAllShrink genList shrinkList (\\x -> foldLeft (-) (sum x) x == 0)\n\n  describe "length" $ do\n    it "length 1..3" $ length (1 :. 2 :. 3 :. Nil) `shouldBe` 3\n    prop "summing a list of 1s is equal to its length" $\n      forAllLists (\\x -> P.length (hlist x) == length x)\n\n  describe "map" $ do\n    it "add 10 on list" $\n      map (+10) (1 :. 2 :. 3 :. Nil) `shouldBe` (11 :. 12 :. 13 :. Nil)\n    prop "headOr after map" $\n      \\x -> headOr (x :: Integer) (map (+1) infinity) == 1\n    prop "map id is id" $\n      forAllLists (\\x -> map id x == x)\n\n  describe "filter" $ do\n    it "filter even" $\n      filter even (1 :. 2 :. 3 :. 4 :. 5 :. Nil) `shouldBe` (2 :. 4 :. Nil)\n    prop "filter (const True) is identity (headOr)" $\n      \\x -> headOr x (filter (const True) infinity) == 0\n    prop "filter (const True) is identity" $\n      forAllLists (\\x -> filter (const True) x == x)\n    prop "filter (const False) is the empty list" $\n      forAllLists (\\x -> filter (const False) x == Nil)\n\n  describe "(++)" $ do\n    it "(1..6)" $\n      (1 :. 2 :. 3 :. Nil) ++ (4 :. 5 :. 6 :. Nil) `shouldBe` listh [1,2,3,4,5,6]\n    prop "append empty to infinite" $\n      \\x -> headOr x (Nil ++ infinity) == 0\n    prop "append anything to infinity" $\n       forAllShrink genIntegerAndList shrinkIntegerAndList (\\(x, y) -> headOr x (y ++ infinity) == headOr 0 y)\n    prop "associativity" $\n      forAllShrink genThreeLists shrinkThreeLists (\\(x,y,z) -> (x ++ y) ++ z == x ++ (y ++ z))\n    prop "append to empty list" $\n      forAllLists (\\x -> x ++ Nil == x)\n\n  describe "flatten" $ do\n    it "(1..9)" $\n      flatten ((1 :. 2 :. 3 :. Nil) :. (4 :. 5 :. 6 :. Nil) :. (7 :. 8 :. 9 :. Nil) :. Nil) `shouldBe` listh [1,2,3,4,5,6,7,8,9]\n    prop "flatten (infinity :. y)" $\n      forAllShrink genIntegerAndList shrinkIntegerAndList (\\(x, y) -> headOr x (flatten (infinity :. y :. Nil)) == 0)\n    prop "flatten (y :. infinity)" $\n      forAllShrink genIntegerAndList shrinkIntegerAndList (\\(x, y) -> headOr x (flatten (y :. infinity :. Nil)) == headOr 0 y)\n    prop "sum of lengths == length of flattened" $\n      forAllShrink genListOfLists shrinkListOfLists (\\x -> sum (map length x) == length (flatten x))\n\n  describe "flatMap" $ do\n    it "lists of Integer" $\n      flatMap (\\x -> x :. x + 1 :. x + 2 :. Nil) (1 :. 2 :. 3 :. Nil) `shouldBe` listh [1,2,3,2,3,4,3,4,5]\n    prop "flatMap id flattens a list of lists" $\n      forAllShrink genIntegerAndList shrinkIntegerAndList (\\(x, y) -> headOr x (flatMap id (infinity :. y :. Nil)) == 0)\n    prop "flatMap id on a list of lists take 2" $\n      forAllShrink genIntegerAndList shrinkIntegerAndList (\\(x, y) -> headOr x (flatMap id (y :. infinity :. Nil)) == headOr 0 y)\n    prop "flatMap id == flatten" $\n      forAllShrink genListOfLists shrinkListOfLists (\\x -> flatMap id x == flatten x)\n\n  describe "flattenAgain" $ do\n    prop "lists of Integer" $\n      forAllShrink genListOfLists shrinkListOfLists (\\x -> flatten x == flattenAgain x)\n\n  describe "seqOptional" $ do\n    it "all Full" $\n      seqOptional (Full 1 :. Full 10 :. Nil) `shouldBe` Full (1 :. 10 :. Nil)\n    it "empty list" $\n      let empty = Nil :: List (Optional Integer)\n       in seqOptional empty `shouldBe` Full Nil\n    it "contains Empty" $\n      seqOptional (Full 1 :. Full 10 :. Empty :. Nil) `shouldBe` Empty\n    it "Empty at head of infinity" $\n      seqOptional (Empty :. map Full infinity) `shouldBe` Empty\n\n  describe "find" $ do\n    it "find no matches" $\n      find even (1 :. 3 :. 5 :. Nil) `shouldBe` Empty\n    it "empty list" $ find even Nil `shouldBe` Empty\n    it "find only even" $\n      find even (1 :. 2 :. 3 :. 5 :. Nil) `shouldBe` Full 2\n    it "find first, not second even" $\n      find even (1 :. 2 :. 3 :. 4 :. 5 :. Nil) `shouldBe` Full 2\n    it "find on infinite list" $\n      find (const True) infinity `shouldBe` Full 0\n\n  describe "lengthGT4" $ do\n    it "list of length 3" $\n      lengthGT4 (1 :. 3 :. 5 :. Nil) `shouldBe` False\n    it "empty list" $\n      lengthGT4 Nil `shouldBe` False\n    it "list of length 5" $\n      lengthGT4 (1 :. 2 :. 3 :. 4 :. 5 :. Nil) `shouldBe` True\n    it "infinite list" $\n      lengthGT4 infinity `shouldBe` True\n\n  describe "reverse" $ do\n    it "empty list" $\n      reverse Nil `shouldBe` (Nil :: List Integer)\n    it "reverse . reverse on largeList" $\n      take 1 (reverse (reverse largeList)) `shouldBe` (1 :. Nil)\n    prop "reverse then append is same as append then reverse" $\n      forAllShrink genTwoLists shrinkTwoLists (\\(x, y) -> reverse x ++ reverse y == reverse (y ++ x))\n    prop "" $\n      forAllLists (\\x -> reverse (x :. Nil) == x :. Nil)\n\n  describe "produce" $ do\n    it "increment" $\n      let (x:.y:.z:.w:._) = produce (+1) 0\n       in (x:.y:.z:.w:.Nil) `shouldBe` (0:.1:.2:.3:.Nil)\n    it "double" $\n      let (x:.y:.z:.w:._) = produce (*2) 1\n       in (x:.y:.z:.w:.Nil) `shouldBe` (1:.2:.4:.8:.Nil)\n'