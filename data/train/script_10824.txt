b'\xef\xbb\xbf// \xe5\x85\xab\xe6\x95\xb0\xe7\xa0\x81\xef\xbc\x8c\xe4\xbd\xbf\xe7\x94\xa8\xe5\x93\x88\xe5\xb8\x8c\xe8\xa1\xa8\xef\xbc\x88\xe7\xab\x9e\xe8\xb5\x9b\xe4\xb8\xad\xe6\x9c\x80\xe5\xb8\xb8\xe7\x94\xa8\xef\xbc\x89\n// Rujia Liu\n\n#include<cstdio>\n#include<cstring>\n#include<set>\nusing namespace std;\n\ntypedef int State[9];\nconst int MAXSTATE = 1000000;\nState st[MAXSTATE], goal;\nint dist[MAXSTATE];\n\nconst int MAXHASHSIZE = 1000003;\nint head[MAXHASHSIZE], next[MAXSTATE];\nvoid init_lookup_table() { memset(head, 0, sizeof(head)); }\nint hash(State& s) {\n  int v = 0;\n  for(int i = 0; i < 9; i++) v = v * 10 + s[i];\n  return v % MAXHASHSIZE;\n}\nint try_to_insert(int s) {\n  int h = hash(st[s]);\n  int u = head[h];\n  while(u) {\n    if(memcmp(st[u], st[s], sizeof(st[s])) == 0) return 0;\n    u = next[u];\n  }\n  next[s] = head[h];\n  head[h] = s;\n  return 1;\n}\n\nconst int dx[] = {-1, 1, 0, 0};\nconst int dy[] = {0, 0, -1, 1};\nint bfs() {\n  init_lookup_table();\n  int front = 1, rear = 2;\n  while(front < rear) {\n    State& s = st[front];\n    if(memcmp(goal, s, sizeof(s)) == 0) return front;\n    int z;\n    for(z = 0; z < 9; z++) if(!s[z]) break;\n    int x = z/3, y = z%3;\n    for(int d = 0; d < 4; d++) {\n      int newx = x + dx[d];\n      int newy = y + dy[d];\n      int newz = newx * 3 + newy;\n      if(newx >= 0 && newx < 3 && newy >= 0 && newy < 3) {\n        State& t = st[rear];\n        memcpy(&t, &s, sizeof(s));\n        t[newz] = s[z];\n        t[z] = s[newz];\n        dist[rear] = dist[front] + 1;\n        if(try_to_insert(rear)) rear++;\n      }\n    }\n    front++;\n  }\n  return 0;\n}\n\nint main() {\n  for(int i = 0; i < 9; i++)\n    scanf("%d", &st[1][i]);\n  for(int i = 0; i < 9; i++)\n    scanf("%d", &goal[i]);\n  int ans = bfs();\n  if(ans > 0) printf("%d\\n", dist[ans]);\n  else printf("-1\\n");\n  return 0;\n}\n'