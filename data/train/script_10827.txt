b'{-# LANGUAGE CPP #-}\n{-# OPTIONS -Wall #-}\n--\n-- Euler totient function (strategic version).\n-- Orig taken from "Research Directions in Parallel Functional Programming",\n-- Chapter "Performance Monitoring", Nathan Charles and Colin Runciman.\n--\n-- (c) 2001 Hans-Wolfgang Loidl\n--\n-- modifications by Jost Berthold, 07/2008:\n--    ported to current GHC = hierarchical libraries\n--    removed some dead (unused) code\n--    simplified/secured usage\n--    included a reference computation (using prime numbers)\n--    tested best version (JFP_Final) against two "equivalents" using\n--          strategies\n--\n---------------------------------------------------------------------------\n\nmodule Main where\nimport System.Environment (getArgs)\nimport Control.Monad (when)\nimport ListAux -- split/join functions, put in new module\nimport SumEulerPrimes\n#ifdef NEW_GENERIC\nimport qualified Data.Par as C\n#else\nimport qualified Control.Monad.Par.Combinator as C\n#endif\n#ifdef PARSCHED \nimport PARSCHED\n#else\nimport Control.Monad.Par\n#endif\n\n\n---------------------------------------------------------------------------\n-- Generic clustering routines\n\n-- Classes\n-- maybe: class (Functor c) => MMonad c where { ... mmap = fmap } \nclass MMonad c where\n  munit  :: a -> c a\n  mjoin  :: c (c a) ->  c a\n  mmap   :: (a -> b) -> c a -> c b\n\nclass (MMonad c) => MMonadPlus c where\n  mzero :: c a\n  mplus :: c a -> c a -> c a\n\nclass (MMonad c) => Cluster c where\n  cluster    :: Int -> c a -> c (c a)\n  decluster  :: c (c a) -> c a\n  lift       :: (c a -> b) -> (c (c a) -> (c b))\n  -- default defs\n  --cluster = ???\n  decluster = mjoin\n  lift      = mmap\n\n-- Instances\ninstance MMonad [] where\n  munit x = [x]\n  mjoin   = concat\n  mmap    = map\n\ninstance Cluster [] where\n  cluster   = splitAtN\n\n---------------------------------------------------------------------------\n\nusage :: String\nusage = "Usage: <program> version size chunksize"\n        ++"\\nFor versions see source code."\n\nmain :: IO ()\nmain = do args <- getArgs\n          let \n            lenArgs = length args\n          when (lenArgs < 3) \n                   (putStrLn (usage ++ "\\n(using defaults: 38,500,20)"))\n          let \n            argDef :: Read a => Int -> a -> a\n            argDef m defVal | m < lenArgs = read (args!!m)\n                            | otherwise   = defVal\n            x, n, c :: Int\n            x = argDef 0 38   -- which sumEuler to use\n            n = argDef 1 500  -- size of the interval\n            c = argDef 2 20   -- chunksize\n            -- parallel computation\n            (res, _str) = case x of\n\n                    _ -> (sumEuler_monadpar c n, "monad-par version")\n#if 0\n                    ------------------\n                    -- BEST VERSION:\n                    38 -> (sumEulerJFP_Final c n, "JFP_Final paper version (splitAtN)")\n                    -- VERSIONS TO TEST ADDITIONALLY:\n--\t\t    48 -> (sumEulerS8 c n,   "parallel w/ parChunkFoldMap strategy")\n--\t\t    58 -> (sumEulerS8\' c n,   "parallel w/ parChunkFold\'Map strategy")                    \n                    8 -> (sumEulerJFP c n, "JFP paper version (splitAtN)")\n                    ------------------\n                    0 -> (sumEuler_seq n,   "sequential")\n                    1 -> (sumEulerS1 n,     "parallel w/ parList strategy")\n                    -- not bad:\n                    2 -> (sumEulerS2 c n,   "parallel w/ parListChunk")\n\t\t    3 -> (sumEulerChunk c n,"parallel w/ chunkify")\n\t\t    4 -> (sumEulerShuffle c n,"parallel w/ shuffle")\n\t\t    5 -> (sumEulerCluster c n,"parallel w/ generic clustering")\n                    -- not bad:\n\t\t    6 -> (sumEulerS6 c n,   "parallel w/ parListChunk over reversed list")\n--\t\t    7 -> (sumEulerS7 c n,   "parallel w/ parChunkFoldMap strategy")\n                    18 -> (sumEulerJFP1 c n, "JFP1 paper version (splitIntoChunks)")\n                    28 -> (sumEulerJFP0 c n, "JFP0 paper version (explicit list comprh)")\n--                    9 -> (sumEulerStepList c n, "parallel w/ seqStepList for strategic shuffling")\n                    _ -> error "undefined version."\n#endif\n\n          putStrLn ("sumEuler [" ++ show base ++ ".." ++ show (base+n) ++ "] = " ++ show res)\n\n          -- reference implementation (which is rather fast)\n          let expected = sumPhi n\n          when False $ putStrLn ("Expected result: " ++ show expected)\n\n---------------------------------------------------------------------------\n-- main computation function in many variants\n\n-- HERE: best versions in contrast\n\n#if 0\nsumEulerJFP  :: Int -> Int -> Int\nsumEulerJFP c n = sum (map (sum . map euler) (splitAtN c (mkList n))\n                       `using` parList rdeepseq)   \n\nsumEulerJFP_Final  :: Int -> Int -> Int\nsumEulerJFP_Final c n = sum ([(sum . map euler) x | x <- splitAtN c [n,n-1..0]]\n                            `using` parList rdeepseq)   \n#endif\n\nsumEuler_monadpar :: Int -> Int -> Int\nsumEuler_monadpar _ n = runPar $\n--   sum `fmap` parMap (sum . map euler) (splitAtN c [n,n-1..0])\n   sum `fmap` C.parMap euler [n,n-1..0]\n\n\n-- -- using a fold-of-map strategy w/ folding inside a chunk\n-- sumEulerS8 :: Int -> Int -> Int\n-- sumEulerS8 c n  = parChunkFoldMap c rnf (+) euler (mkList n)\n-- \n-- -- using a fold-of-map strategy w/ STRICT LEFT-folding inside a chunk\n-- sumEulerS8\' :: Int -> Int -> Int\n-- sumEulerS8\' c n  = parChunkFoldMap\' c rnf (+) euler (mkList n)\n-- \n-- -- parallel fold-of-map with chunking over fold and map\n-- parChunkFoldMap :: (NFData b) => Int -> Strategy b -> \n--                                  (b -> b -> b) -> (a -> b) -> [a] -> b\n-- parChunkFoldMap c s f g xs = foldl1 f (map (foldl1 f . map g) \n-- \t\t                           (splitAtN c xs)\n-- \t\t                       `using` parList s)\t\n-- \n-- -- parallel fold-of-map with chunking over fold and map\n-- parChunkFoldMap\' :: (NFData b) => Int -> Strategy b -> \n--                                  (b -> b -> b) -> (a -> b) -> [a] -> b\n-- parChunkFoldMap\' c s f g xs = foldl1\' f (map (foldl1\' f . map g) \n-- \t\t                           (splitAtN c xs)\n-- \t\t                       `using` parList s)\t\n\n#if 0\n-----------------------------------------------------------------------\n-- OTHER VARIANTS\n\n-- strategic function application\nsumEulerS1 :: Int -> Int\nsumEulerS1 n  = sum ( map euler (mkList n)\n                        `using` \n\t                parList rdeepseq )\n\n-- NUKED:\n-- sumEulerS1 c n  = sum $|| (parListChunk c rnf) $ map euler $ mkList $ n\n\n-- naive parallel version w/ parList\nsumEulerS2 :: Int -> Int -> Int\nsumEulerS2 c n  = sum ( map euler (mkList n)\n                        `using` \n\t                parListChunk c rdeepseq )\n\n-- using a parallel fold over a chunkified list\nsumEulerS6 :: Int -> Int -> Int\nsumEulerS6 c n  = sum (map (sum . map euler) (splitAtN c (mkList n))\n\t\t       `using` parList rdeepseq)\t\n\n-- -- using a fold-of-map strategy over a chunkified list\n-- sumEulerS7 :: Int -> Int -> Int\n-- sumEulerS7 c n  = parFoldChunkMap c rnf (+) euler (mkList n)\n\n-- explicit restructuring\nsumEulerChunk :: Int -> Int -> Int\nsumEulerChunk c n  = sum (parMap rdeepseq ( \\ xs -> sum (map euler xs)) \n                                     (splitAtN c (mkList n)))\n\n-- using generic clustering functions\nsumEulerCluster :: Int -> Int -> Int\nsumEulerCluster c n = sum ((lift worker) (cluster c (mkList n)) \n                           `using` parList rdeepseq)\n                      where worker = sum . map euler\n\n-- using a shuffling to improve load balance\nsumEulerShuffle :: Int -> Int -> Int\nsumEulerShuffle c n  = sum ((map worker) (unshuffle (noFromSize c n) (mkList n))\n                           `using` parList rdeepseq)\n                       where worker = sum . map euler\n\nnoFromSize :: Int -> Int -> Int\nnoFromSize c n | n `mod` c == 0 = n `div` c \n               | otherwise      = n `div` c + 1\n\n-- -- Evaluates every n-th element in the list starting with the first elem\n-- seqStepList :: Int -> Strategy a -> Strategy [a]\n-- seqStepList _ _strat []    = ()\n-- seqStepList n strat (x:xs) = strat x `pseq` (seqStepList n strat (drop (n-1) xs))\n-- \n-- seqStepList\' :: Int -> Strategy a -> Strategy [a]\n-- -- seqStepList\' _ strat [] = ()\n-- seqStepList\' n strat xs = parList (\\ i -> seqStepList n strat (drop i xs)) [0..n-1]\n-- \n-- sumEulerStepList :: Int -> Int -> Int\n-- sumEulerStepList c n  = sum ( map euler (mkList n)\n--                               `using` \n-- \t                      seqStepList\' n\' rnf )\n--                        where --worker = sum . map euler\n--                              n\' = if n `mod` c == 0 then n `div` c else (n `div` c)+1\n\n-- ---------------------------------------------------------------------------\n-- Variants of the code for the JFP paper\n-- ---------------------------------------------------------------------------\n\nsumEulerJFP0  :: Int -> Int -> Int\nsumEulerJFP0 c n = sum ([ (sum . map euler) [ c*i+j | j <- [0..c-1], c*i+j<=n ]\n                        | i <- [0..(n+c-1) `div` c - 1] ]\n                       `using` parList rdeepseq)   \n\nsumEulerJFP1  :: Int -> Int -> Int\nsumEulerJFP1 c n = sum (map (sum . map euler) (splitIntoChunks c n)\n                        `using` parList rdeepseq)   \n\n#endif\n\nsplitIntoChunks :: Int -> Int -> [[Int]]\nsplitIntoChunks c n = [ [ c*i+j | j <- [0..c-1], c*i+j<=n ]\n                      | i <- [0..(n+c-1) `div` c - 1] ]\n\n-- boring sequential version\nsumEuler_seq :: Int -> Int\nsumEuler_seq = sum . map euler . mkList \n\n---------------------------------------------------------------------------\n-- smallest input for euler\nbase :: Int\nbase = 0\n\n-- produce a list of input values\nmkList :: Int -> [Int]\nmkList = reverse . enumFromTo base . (+ base)\n-- random numbers\n-- mkList seed n = take n (randoms seed)\n\n---------------------------------------------------------------------------\n-- main fct\n\neuler :: Int -> Int\neuler n = length (filter (relprime n) [1..(n-1)])\n\n---------------------------------------------------------------------------\n-- orig code from Nathan\n{-\neuler :: Int -> Int\neuler n = let\n            relPrimes = let\n                          numbers = [1..(n-1)]\n                        in\n                          numbers `par` (filter (relprime n) numbers)\n          in\n            (spine relPrimes) `par` (length relPrimes)\n-}\n\n---------------------------------------------------------------------------\n-- aux fcts\n\nhcf :: Int -> Int -> Int\nhcf x 0 = x\nhcf x y = hcf y (rem x y)\n\nrelprime :: Int -> Int -> Bool\nrelprime x y = hcf x y == 1\n\n'