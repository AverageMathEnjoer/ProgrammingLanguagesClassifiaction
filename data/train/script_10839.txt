b'// Copyright (c) 2022-2023 Manuel Schneider\n\n#include "albert/extensions/queryhandler.h"\n#include "queryengine.h"\n#include "triggerwidget.h"\n#include <QHeaderView>\n#include <QTableView>\n#include <QVBoxLayout>\nusing namespace albert;\nusing namespace std;\n\nenum class Column {\n    Name,\n    Trigger,\n    Description\n};\n\nclass TriggerModel : public QAbstractTableModel, ExtensionWatcher<TriggerQueryHandler>\n{\npublic:\n    struct Entry\n    {\n        TriggerQueryHandler *handler;\n        QString trigger;\n        bool enabled;\n    };\n    vector<TriggerQueryHandler *> handlers;\n    QueryEngine &engine;\n\n    explicit TriggerModel(QueryEngine &qe, ExtensionRegistry &er) :\n            ExtensionWatcher<TriggerQueryHandler>(er), engine(qe)\n    {\n        for (auto &[id, handler]: registry.extensions<TriggerQueryHandler>())\n            handlers.emplace_back(handler);\n        ::sort(begin(handlers), end(handlers),\n               [](const auto &a, const auto &b) { return a->name() < b->name(); });\n\n    }\n\n    void onAdd(TriggerQueryHandler *t) override\n    {\n        auto it = lower_bound(begin(handlers), end(handlers), t,\n                              [](const auto &a, const auto &b) { return a->name() < b->name(); });\n        auto i = std::distance(begin(handlers), it);\n        beginInsertRows(QModelIndex(), i, i);\n        handlers.insert(it, t);\n        endInsertRows();\n    }\n\n    void onRem(TriggerQueryHandler *t) override\n    {\n        handlers.erase(remove(handlers.begin(), handlers.end(), t), handlers.end());\n    }\n\n    int rowCount(const QModelIndex &) const override\n    {\n        return (int) handlers.size();\n    }\n\n    int columnCount(const QModelIndex &) const override\n    {\n        return 3;\n    }\n\n    QVariant data(const QModelIndex &index, int role) const override\n    {\n        if (index.column() == (int) Column::Name) {\n            if (role == Qt::DisplayRole)\n                return handlers[index.row()]->name();\n\n        } else if (index.column() == (int) Column::Description) {\n            if (role == Qt::DisplayRole)\n                return handlers[index.row()]->description();\n\n        } else if (index.column() == (int) Column::Trigger) {\n            auto &handler = handlers[index.row()];\n            if (role == Qt::DisplayRole) {\n                return QString(engine.handlerConfig().at(handler).trigger).replace(" ", "\xe2\x80\xa2");  //\xe1\x9a\x80\n\n            } else if (role == Qt::EditRole) {\n                return engine.handlerConfig().at(handler).trigger;\n\n            } else if (role == Qt::ToolTipRole) {\n                QStringList sl;\n                auto config = engine.handlerConfig().at(handler);\n                if (!handler->allowTriggerRemap())\n                    sl << "This extension does not allow trigger remapping.";\n                if (config.enabled && engine.activeTriggers().at(config.trigger) != handler)\n                    sl << QString("Trigger conflict: \'%1\' reserved by extension \'%2\'.")\n                            .arg(config.trigger, engine.activeTriggers().at(config.trigger)->name());\n                if (!sl.isEmpty())\n                    return sl.join(" ");\n\n            } else if (role == Qt::CheckStateRole) {\n                return engine.handlerConfig().at(handler).enabled ? Qt::Checked : Qt::Unchecked;\n\n            } else if (role == Qt::FontRole) {\n                if (!handler->allowTriggerRemap()) {\n                    QFont f;\n                    f.setItalic(true);\n                    return f;\n                }\n\n            } else if (role == Qt::ForegroundRole) {\n                auto config = engine.handlerConfig().at(handler);\n                if (!config.enabled)\n                    return QColor(Qt::gray);\n                else if (engine.activeTriggers().at(config.trigger) != handler)\n                    return QColor(Qt::red);\n\n            }\n        }\n        return {};\n    }\n\n    bool setData(const QModelIndex &idx, const QVariant &value, int role) override\n    {\n        if (idx.column() == (int) Column::Trigger) {\n            if (role == Qt::EditRole) {\n\n                if (value.toString().isEmpty())\n                    return false;\n\n                engine.setTrigger(handlers[idx.row()], value.toString());\n                emit dataChanged(index(0, (int) Column::Trigger),\n                                 index((int) handlers.size(), (int) Column::Trigger),\n                                 {Qt::DisplayRole});\n                return true;\n            } else if (role == Qt::CheckStateRole) {\n                engine.setEnabled(handlers[idx.row()],\n                                  static_cast<Qt::CheckState>(value.toUInt()) == Qt::Checked);\n                emit dataChanged(index(0, (int) Column::Trigger),\n                                 index((int) handlers.size(), (int) Column::Trigger),\n                                 {Qt::DisplayRole});\n                return true;\n            }\n        }\n        return false;\n    }\n\n    QVariant headerData(int section, Qt::Orientation, int role) const override\n    {\n        if (role == Qt::DisplayRole)\n            switch ((Column) section) {\n                case Column::Name:\n                    return "Extension";\n                case Column::Trigger:\n                    return "Trigger";\n                case Column::Description:\n                    return "Description";\n            }\n        return {};\n    }\n\n    Qt::ItemFlags flags(const QModelIndex &index) const override\n    {\n        switch ((Column) index.column()) {\n            case Column::Name:\n            case Column::Description:\n                return Qt::ItemIsEnabled | Qt::ItemIsSelectable;\n            case Column::Trigger:\n                if (handlers[index.row()]->allowTriggerRemap())\n                    return Qt::ItemIsEnabled | Qt::ItemIsSelectable | Qt::ItemIsUserCheckable | Qt::ItemIsEditable;\n                else\n                    return Qt::ItemIsEnabled | Qt::ItemIsSelectable | Qt::ItemIsUserCheckable;\n            default:\n                return {};\n        }\n    }\n};\n\nTriggerWidget::TriggerWidget(QueryEngine &qe, ExtensionRegistry &er)\n    : model(new TriggerModel(qe, er))\n{\n    verticalHeader()->setSectionResizeMode(QHeaderView::ResizeToContents);\n    verticalHeader()->hide();\n\n    horizontalHeader()->setSectionResizeMode(QHeaderView::ResizeToContents);\n    horizontalHeader()->setStretchLastSection(true);\n    horizontalHeader()->setSectionsClickable(false);\n\n    setShowGrid(false);\n    setFrameShape(QFrame::NoFrame);\n    setAlternatingRowColors(true);\n    setModel(model.get());\n    setSelectionBehavior(QAbstractItemView::SelectRows);\n    setSelectionMode(QAbstractItemView::SingleSelection);\n    setEditTriggers(QTableView::DoubleClicked|QTableView::SelectedClicked|QTableView::EditKeyPressed);\n\n    connect(selectionModel(), &QItemSelectionModel::currentChanged, this,\n            [this](const QModelIndex &current, const QModelIndex&){\n        blockSignals(true);\n        setCurrentIndex(model->index(current.row(), (int)Column::Trigger));\n        blockSignals(false);\n    });\n\n    connect(this, &QTableView::activated, this, [this](const QModelIndex &index){\n        edit(model->index(index.row(), (int)Column::Trigger));\n    });\n}\n\n\nTriggerWidget::~TriggerWidget() = default;\n'