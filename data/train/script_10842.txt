b'{-# LANGUAGE OverloadedStrings #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n{-# LANGUAGE PatternGuards #-}\n\n-- | Flate decode filter\n\nmodule Pdf.Core.Stream.Filter.FlateDecode\n(\n  flateDecode\n)\nwhere\n\nimport Data.Word\nimport Data.ByteString (ByteString)\nimport qualified Data.ByteString as ByteString\nimport qualified Data.HashMap.Strict as HashMap\nimport Control.Exception hiding (throw)\nimport System.IO.Streams (InputStream)\nimport qualified System.IO.Streams as Streams\n\nimport Pdf.Core.Exception\nimport Pdf.Core.Object\nimport Pdf.Core.Object.Util\nimport Pdf.Core.Stream.Filter.Type\n\n-- | Vary basic implementation. Only PNG-UP prediction is implemented\n--\n-- Nothing when zlib is disabled via cabal flag\nflateDecode :: Maybe StreamFilter\nflateDecode = Just StreamFilter\n  { filterName = "FlateDecode"\n  , filterDecode = decode\n  }\n\ndecode :: Maybe Dict -> InputStream ByteString -> IO (InputStream ByteString)\ndecode Nothing is = Streams.decompress is\ndecode (Just dict) is =\n  case HashMap.lookup "Predictor" dict of\n    Nothing -> Streams.decompress is\n    Just o | Just val <- intValue o ->\n      Streams.decompress is >>= unpredict dict val\n    _ -> throwIO $ Corrupted "Predictor should be an integer" []\n\nunpredict :: Dict\n          -> Int\n          -> InputStream ByteString\n          -> IO (InputStream ByteString)\nunpredict _ 1 is = return is\nunpredict dict 12 is = message "unpredict" $\n  case HashMap.lookup "Columns" dict of\n    Nothing -> throwIO $ Corrupted "Column is missing" []\n    Just o\n      | Just cols <- intValue o\n      -> unpredict12 (cols + 1) is\n    _ -> throwIO $ Corrupted "Column should be an integer" []\nunpredict _ p _ = throwIO $ Unexpected ("Unsupported predictor: " ++ show p) []\n\n-- | PGN-UP prediction\n--\n-- TODO: Hacky solution, rewrite it\nunpredict12 :: Int -> InputStream ByteString -> IO (InputStream ByteString)\nunpredict12 cols is\n  = Streams.toList is\n  >>= Streams.fromList . return\n                       . ByteString.pack\n                       . step (replicate cols 0) []\n                       . concatMap ByteString.unpack\n  where\n  step :: [Word8] -> [Word8] -> [Word8] -> [Word8]\n  step _ _ [] = []\n  step (c:cs) [] (_:xs) = step cs [c] xs\n  step (c:cs) (p:ps) (x:xs) = (x + p) : step cs (c:(x + p):ps) xs\n  step [] ps xs = step (reverse ps) [] xs\n'