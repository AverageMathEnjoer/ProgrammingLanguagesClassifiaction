b'{-# LANGUAGE CPP #-}\n#if !defined(TESTING) && defined(__GLASGOW_HASKELL__)\n{-# LANGUAGE Safe #-}\n#endif\n#ifdef __GLASGOW_HASKELL__\n{-# LANGUAGE DataKinds #-}\n{-# LANGUAGE FlexibleContexts #-}\n{-# LANGUAGE MonoLocalBinds #-}\n#endif\n\n#include "containers.h"\n\n-----------------------------------------------------------------------------\n-- |\n-- Module      :  Data.IntMap\n-- Copyright   :  (c) Daan Leijen 2002\n--                (c) Andriy Palamarchuk 2008\n-- License     :  BSD-style\n-- Maintainer  :  libraries@haskell.org\n-- Portability :  portable\n--\n-- An efficient implementation of maps from integer keys to values\n-- (dictionaries).\n--\n-- This module re-exports the value lazy "Data.IntMap.Lazy" API, plus\n-- several deprecated value strict functions. Please note that these functions\n-- have different strictness properties than those in "Data.IntMap.Strict":\n-- they only evaluate the result of the combining function. For example, the\n-- default value to \'insertWith\'\' is only evaluated if the combining function\n-- is called and uses it.\n--\n-- These modules are intended to be imported qualified, to avoid name\n-- clashes with Prelude functions, e.g.\n--\n-- >  import Data.IntMap (IntMap)\n-- >  import qualified Data.IntMap as IntMap\n--\n-- The implementation is based on /big-endian patricia trees/.  This data\n-- structure performs especially well on binary operations like \'union\'\n-- and \'intersection\'.  However, my benchmarks show that it is also\n-- (much) faster on insertions and deletions when compared to a generic\n-- size-balanced map implementation (see "Data.Map").\n--\n--    * Chris Okasaki and Andy Gill,  \\"/Fast Mergeable Integer Maps/\\",\n--      Workshop on ML, September 1998, pages 77-86,\n--      <http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.37.5452>\n--\n--    * D.R. Morrison, \\"/PATRICIA -- Practical Algorithm To Retrieve Information Coded In Alphanumeric/\\",\n--      Journal of the ACM, 15(4), October 1968, pages 514-534.\n--\n-- Operation comments contain the operation time complexity in\n-- the Big-O notation <http://en.wikipedia.org/wiki/Big_O_notation>.\n-- Many operations have a worst-case complexity of \\(O(\\min(n,W))\\).\n-- This means that the operation can become linear in the number of\n-- elements with a maximum of \\(W\\) -- the number of bits in an \'Int\'\n-- (32 or 64).\n-----------------------------------------------------------------------------\n\nmodule Data.IntMap\n    ( module Data.IntMap.Lazy\n#ifdef __GLASGOW_HASKELL__\n-- For GHC, we disable these, pending removal. For anything else,\n-- we just don\'t define them at all.\n    , insertWith\'\n    , insertWithKey\'\n    , fold\n    , foldWithKey\n#endif\n    ) where\n\nimport Data.IntMap.Lazy\n\n#ifdef __GLASGOW_HASKELL__\nimport Utils.Containers.Internal.TypeError\n\n-- | This function is being removed and is no longer usable.\n-- Use \'Data.IntMap.Strict.insertWith\'\ninsertWith\' :: Whoops "Data.IntMap.insertWith\' is gone. Use Data.IntMap.Strict.insertWith."\n            => (a -> a -> a) -> Key -> a -> IntMap a -> IntMap a\ninsertWith\' _ _ _ _ = undefined\n\n-- | This function is being removed and is no longer usable.\n-- Use \'Data.IntMap.Strict.insertWithKey\'.\ninsertWithKey\' :: Whoops "Data.IntMap.insertWithKey\' is gone. Use Data.IntMap.Strict.insertWithKey."\n               => (Key -> a -> a -> a) -> Key -> a -> IntMap a -> IntMap a\ninsertWithKey\' _ _ _ _ = undefined\n\n-- | This function is being removed and is no longer usable.\n-- Use \'Data.IntMap.Lazy.foldr\'.\nfold :: Whoops "Data.IntMap.fold\' is gone. Use Data.IntMap.foldr or Prelude.foldr."\n     => (a -> b -> b) -> b -> IntMap a -> b\nfold _ _ _ = undefined\n\n-- | This function is being removed and is no longer usable.\n-- Use \'foldrWithKey\'.\nfoldWithKey :: Whoops "Data.IntMap.foldWithKey is gone. Use foldrWithKey."\n            => (Key -> a -> b -> b) -> b -> IntMap a -> b\nfoldWithKey _ _ _ = undefined\n#endif\n'