b'context("results")\ntest_that("results works as expected and throws errors", {\n  ## test contrasts\n  set.seed(1)\n  dds <- makeExampleDESeqDataSet(n=200,m=12)\n  dds$condition <- factor(rep(1:3,each=4))\n  dds$group <- factor(rep(1:2,length=ncol(dds)))\n  dds$foo <- rep(c("lo","hi"),each=6)\n  counts(dds)[1,] <- rep(c(100L,200L,800L),each=4)\n\n  design(dds) <- ~ group + condition\n\n  # calling results too early\n  expect_error(results(dds))\n\n  sizeFactors(dds) <- rep(1, ncol(dds))\n  dds <- DESeq(dds)\n  head(coef(dds))\n  res <- results(dds)\n  show.res <- capture.output(show(res))\n  summary.res <- capture.output(summary(res))\n\n  # various results error checking\n  expect_error(results(dds, test="LRT"))\n  expect_error(results(dds, altHypothesis="lessAbs"))\n  expect_error(results(dds, name=c("Intercept","group1")))\n  expect_error(results(dds, contrast=c("foo","B","A")))\n  expect_error(results(dds, contrast=c("condition","4","1")))\n  expect_error(results(dds, test="foo"))\n  expect_error(results(dds, contrast=FALSE))\n  expect_error(results(dds, contrast=letters[1:4]))\n  expect_error(results(dds, contrast=c("condition","1","1")))\n  results(dds, independentFiltering=FALSE)\n  results(dds, contrast=list("condition_2_vs_1"))\n  expect_error(results(dds, contrast=list("condition_2_vs_1","condition_3_vs_1","condition_3_vs_1")))\n  expect_error(results(dds, contrast=list("condition_2_vs_1",1)))\n  expect_error(results(dds, contrast=list("condition_2_vs_1","foo")))\n  expect_error(results(dds, contrast=list("condition_2_vs_1","condition_2_vs_1")))\n  expect_error(results(dds, contrast=list(character(), character())))\n  expect_error(results(dds, contrast=rep(0, 6)))\n  expect_error(results(dds, contrast=c("foo","lo","hi")), "factor")\n  \n  expect_equal(results(dds,contrast=c("condition","1","3"))[1,2], -3, tolerance=1e-6)\n  expect_equal(results(dds,contrast=c("condition","1","2"))[1,2], -1, tolerance=1e-6)\n  expect_equal(results(dds,contrast=c("condition","2","3"))[1,2], -2, tolerance=1e-6)\n\n  # test a number of contrast as list options\n  expect_equal(results(dds,\n                       contrast=list("condition_3_vs_1","condition_2_vs_1"))[1,2],\n               2, tolerance=1e-6)\n  results(dds, contrast=list("condition_3_vs_1","condition_2_vs_1"), listValues=c(.5,-.5))\n  results(dds, contrast=list("condition_3_vs_1",character()))\n  results(dds, contrast=list("condition_3_vs_1",character()), listValues=c(.5,-.5))\n  results(dds, contrast=list(character(),"condition_2_vs_1"))\n  results(dds, contrast=list(character(),"condition_2_vs_1"), listValues=c(.5,-.5))\n\n  # test no prior on intercept\n  expect_equivalent(attr(dds,"betaPriorVar"), rep(1e6, 4))\n\n  # test thresholding\n  resLFC <- results(dds, lfcThreshold=log2(1.5))\n  results(dds, lfcThreshold=1, altHypothesis="lessAbs")\n  results(dds, lfcThreshold=1, altHypothesis="greater")\n  results(dds, lfcThreshold=1, altHypothesis="less")\n\n  dds3 <- DESeq(dds, betaPrior=TRUE)\n  expect_error(results(dds3, lfcThreshold=1, altHypothesis="lessAbs"))\n})\n\ntest_that("results: designs with zero intercept", {\n  # test some special cases for results()\n  # using designs with +0 \n  set.seed(1)\n  dds <- makeExampleDESeqDataSet(n=100,m=12)\n  dds$condition <- factor(rep(1:3,each=4))\n  dds$group <- factor(rep(1:2,length=ncol(dds)))\n\n  counts(dds)[1,] <- rep(c(100L,200L,400L),each=4)\n\n  design(dds) <- ~ condition + 0\n  dds <- DESeq(dds, betaPrior=FALSE)\n\n  expect_equal(results(dds)[1,2], 2, tolerance=.1)\n  expect_equal(results(dds, contrast=c("condition","2","1"))[1,2], 1, tolerance=.1)\n  expect_equal(results(dds, contrast=c("condition","3","2"))[1,2], 1, tolerance=.1)\n  expect_equal(results(dds, contrast=c("condition","1","3"))[1,2], -2, tolerance=.1)\n  expect_equal(results(dds, contrast=c("condition","1","2"))[1,2], -1, tolerance=.1)\n  expect_equal(results(dds, contrast=c("condition","2","3"))[1,2], -1, tolerance=.1)\n  expect_error(results(dds, contrast=c("condition","4","1")))\n\n  design(dds) <- ~ group + condition + 0\n  dds <- DESeq(dds, betaPrior=FALSE)\n\n  expect_equal(results(dds)[1,2], 2, tolerance=.1)\n  expect_equal(results(dds, contrast=c("condition","2","1"))[1,2], 1, tolerance=.1)\n  expect_equal(results(dds, contrast=c("condition","3","2"))[1,2], 1, tolerance=.1)\n  expect_equal(results(dds, contrast=c("condition","1","3"))[1,2], -2, tolerance=.1)\n  expect_equal(results(dds, contrast=c("condition","1","2"))[1,2], -1, tolerance=.1)\n  expect_equal(results(dds, contrast=c("condition","2","3"))[1,2], -1, tolerance=.1)\n})\n\ntest_that("results: likelihood ratio test", {\n  set.seed(1)\n  dds <- makeExampleDESeqDataSet(n=100)\n  dds$group <- factor(rep(1:2,6))\n  design(dds) <- ~ group + condition\n  dds <- DESeq(dds, test="LRT", reduced=~group)\n\n  expect_true(!all(results(dds,name="condition_B_vs_A")$stat ==\n              results(dds,name="condition_B_vs_A",test="Wald")$stat))\n\n  # LFC are already MLE\n  expect_error(results(dds, addMLE=TRUE))\n  expect_error(results(dds, lfcThreshold=1, test="LRT"))\n\n  expect_true(all(results(dds, test="LRT", contrast=c("group","1","2"))$log2FoldChange ==\n              -1 * results(dds, test="LRT", contrast=c("group","2","1"))$log2FoldChange))\n})\n\ntest_that("results basics regarding format, saveCols, tidy, MLE, remove are working", {\n  dds <- makeExampleDESeqDataSet(n=100)\n  mcols(dds)$score <- 1:100\n  dds <- DESeq(dds)\n\n  # try saving metadata columns\n  res <- results(dds, saveCols=4) # integer\n  res <- results(dds, saveCols="score") # character\n  res <- results(dds, format="GRanges", saveCols=4)\n  \n  expect_warning(results(dds, format="GRangesList"))\n\n  rowRanges(dds) <- as(rowRanges(dds), "GRangesList")\n  dds <- DESeq(dds)\n  expect_message(results(dds, format="GRanges"))\n\n  # check tidy-ness\n  res <- results(dds, tidy=TRUE)\n  expect_true(colnames(res)[1] == "row")\n  expect_true(is(res, "data.frame"))\n\n  # test MLE and \'name\'\n  dds2 <- DESeq(dds, betaPrior=TRUE)\n  results(dds2, addMLE=TRUE)\n  expect_error(results(dds, name="condition_B_vs_A", addMLE=TRUE))\n\n  # test remove results\n  dds <- removeResults(dds)\n  expect_true(!any(mcols(mcols(dds))$type == "results"))\n})\n\ntest_that("custom filters can be provided to results()", {\n  # try a custom filter function\n  set.seed(1)\n  dds <- makeExampleDESeqDataSet(n=200, m=4, betaSD=rep(c(0,2),c(150,50)))\n  dds <- DESeq(dds)\n  res <- results(dds)\n  method <- "BH"\n  alpha <- 0.1\n\n  customFilt <- function(res, filter, alpha, method) {\n    if (missing(filter)) {\n      filter <- res$baseMean\n    }\n    theta <- 0:10/10\n    cutoff <- quantile(filter, theta)\n    numRej <- sapply(cutoff, function(x) sum(p.adjust(res$pvalue[filter > x]) < alpha, na.rm=TRUE))\n    threshold <- theta[which(numRej == max(numRej))[1]]\n    res$padj <- numeric(nrow(res))\n    idx <- filter > quantile(filter, threshold)\n    res$padj[!idx] <- NA\n    res$padj[idx] <- p.adjust(res$pvalue[idx], method=method)\n    res\n  }\n\n  resCustom <- results(dds, filterFun=customFilt)\n  #plot(res$padj, resCustom$padj);abline(0,1)\n})\n'