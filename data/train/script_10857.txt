b'/*\n * Copyright 2013 - 2016 Mario Arias\n *\n * Licensed under the Apache License, Version 2.0 (the "License");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * \thttp://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an "AS IS" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.funktionale.either\n\nimport org.funktionale.collections.prependTo\nimport org.funktionale.either.Either.Left\nimport org.funktionale.either.Either.Right\nimport org.funktionale.option.Option\nimport org.funktionale.utils.hashCodeForNullable\n\nsealed class Either<out L, out R> : EitherLike {\n\n    companion object {\n        fun <L> left(left: L): Left<L, Nothing> = Left(left)\n        fun <R> right(right: R): Right<Nothing, R> = Right(right)\n    }\n\n    fun left(): LeftProjection<L, R> = LeftProjection(this)\n    fun right(): RightProjection<L, R> = RightProjection(this)\n\n    operator abstract fun component1(): L?\n    operator abstract fun component2(): R?\n\n    fun toDisjunction(): Disjunction<L, R> = when (this) {\n        is Right -> Disjunction.Right(r)\n        is Left -> Disjunction.Left(l)\n    }\n\n    fun <X> fold(fl: (L) -> X, fr: (R) -> X): X = when (this) {\n        is Left -> fl(l)\n        is Right -> fr(r)\n    }\n\n    fun swap(): Either<R, L> = when (this) {\n        is Left -> Right(this.l)\n        is Right -> Left(this.r)\n    }\n\n    class Left<out L, out R>(val l: L) : Either<L, R>(), LeftLike {\n        override fun component1(): L = l\n        override fun component2(): R? = null\n\n        override fun equals(other: Any?): Boolean = when (other) {\n            is Left<*, *> -> l == other.l\n            else -> false\n\n        }\n\n        override fun hashCode(): Int = l.hashCodeForNullable(43) { a, b -> a * b }\n\n        override fun toString(): String = "Either.Left($l)"\n    }\n\n    class Right<out L, out R>(val r: R) : Either<L, R>(), RightLike {\n        override fun component1(): L? = null\n        override fun component2(): R = r\n\n        override fun equals(other: Any?): Boolean = when (other) {\n            is Right<*, *> -> r == other.r\n            else -> false\n        }\n\n        override fun hashCode(): Int = r.hashCodeForNullable(43) { a, b -> a * b }\n\n        override fun toString(): String = "Either.Right($r)"\n    }\n}\n\nfun <T> Either<T, T>.merge(): T = when (this) {\n    is Left -> this.l\n    is Right -> this.r\n}\n\nfun <L, R> Pair<L, R>.toLeft(): Left<L, R> = Left(this.component1())\n\nfun <L, R> Pair<L, R>.toRight(): Right<L, R> = Right(this.component2())\n\ninline fun <T> eitherTry(body: () -> T): Either<Throwable, T> = try {\n    Right(body())\n} catch(t: Throwable) {\n    Left(t)\n}\n\nfun <T, L, R> List<T>.eitherTraverse(f: (T) -> Either<L, R>): Either<L, List<R>> = foldRight(Right(emptyList())) { i: T, accumulator: Either<L, List<R>> ->\n    val either = f(i)\n    when (either) {\n        is Right -> either.right().map(accumulator) { head: R, tail: List<R> ->\n            head prependTo tail\n        }\n        is Left -> Left(either.l)\n    }\n}\n\nfun <L, R> List<Either<L, R>>.eitherSequential(): Either<L, List<R>> = eitherTraverse { it: Either<L, R> -> it }\n\ninline fun <X, T> Option<T>.toEitherRight(left: () -> X): Either<X, T> = if (isEmpty()) {\n    Left(left())\n} else {\n    Right(get())\n}\n\ninline fun <X, T> Option<T>.toEitherLeft(right: () -> X): Either<T, X> = if (isEmpty()) {\n    Right(right())\n} else {\n    Left(get())\n}'