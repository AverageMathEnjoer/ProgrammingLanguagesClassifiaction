b'using System;\nusing System.Diagnostics;\nusing System.Text;\n\nusing u8 = System.Byte;\n\nnamespace CS_SQLite3\n{\n  using sqlite3_int64 = System.Int64;\n\n  public partial class CSSQLite\n  {\n    /*\n    ** 2005 July 8\n    **\n    ** The author disclaims copyright to this source code.  In place of\n    ** a legal notice, here is a blessing:\n    **\n    **    May you do good and not evil.\n    **    May you find forgiveness for yourself and forgive others.\n    **    May you share freely, never taking more than you give.\n    **\n    *************************************************************************\n    ** This file contains code associated with the ANALYZE command.\n    **\n    ** @(#) $Id: analyze.c,v 1.52 2009/04/16 17:45:48 drh Exp $\n    **\n    *************************************************************************\n    **  Included in SQLite3 port to C#-SQLite;  2008 Noah B Hart\n    **  C#-SQLite is an independent reimplementation of the SQLite software library\n    **\n    **  $Header$\n    *************************************************************************\n    **  Included in SQLite3 port to C#-SQLite;  2008 Noah B Hart\n    **  C#-SQLite is an independent reimplementation of the SQLite software library\n    **\n    **  $Header$\n    *************************************************************************\n    */\n#if !SQLITE_OMIT_ANALYZE\n    //#include "sqliteInt.h"\n\n    /*\n    ** This routine generates code that opens the sqlite_stat1 table on cursor\n    ** iStatCur.\n    **\n    ** If the sqlite_stat1 tables does not previously exist, it is created.\n    ** If it does previously exist, all entires associated with table zWhere\n    ** are removed.  If zWhere==0 then all entries are removed.\n    */\n    static void openStatTable(\n    Parse pParse,       /* Parsing context */\n    int iDb,            /* The database we are looking in */\n    int iStatCur,       /* Open the sqlite_stat1 table on this cursor */\n    string zWhere       /* Delete entries associated with this table */\n    )\n    {\n      sqlite3 db = pParse.db;\n      Db pDb;\n      int iRootPage;\n      u8 createStat1 = 0;\n      Table pStat;\n      Vdbe v = sqlite3GetVdbe( pParse );\n\n      if ( v == null ) return;\n      Debug.Assert( sqlite3BtreeHoldsAllMutexes( db ) );\n      Debug.Assert( sqlite3VdbeDb( v ) == db );\n      pDb = db.aDb[iDb];\n      if ( ( pStat = sqlite3FindTable( db, "sqlite_stat1", pDb.zName ) ) == null )\n      {\n        /* The sqlite_stat1 tables does not exist.  Create it.\n        ** Note that a side-effect of the CREATE TABLE statement is to leave\n        ** the rootpage of the new table in register pParse.regRoot.  This is\n        ** important because the OpenWrite opcode below will be needing it. */\n        sqlite3NestedParse( pParse,\n        "CREATE TABLE %Q.sqlite_stat1(tbl,idx,stat)",\n        pDb.zName\n        );\n        iRootPage = pParse.regRoot;\n        createStat1 = 1;  /* Cause rootpage to be taken from top of stack */\n      }\n      else if ( zWhere != null )\n      {\n        /* The sqlite_stat1 table exists.  Delete all entries associated with\n        ** the table zWhere. */\n        sqlite3NestedParse( pParse,\n        "DELETE FROM %Q.sqlite_stat1 WHERE tbl=%Q",\n        pDb.zName, zWhere\n        );\n        iRootPage = pStat.tnum;\n      }\n      else\n      {\n        /* The sqlite_stat1 table already exists.  Delete all rows. */\n        iRootPage = pStat.tnum;\n        sqlite3VdbeAddOp2( v, OP_Clear, pStat.tnum, iDb );\n      }\n\n      /* Open the sqlite_stat1 table for writing. Unless it was created\n      ** by this vdbe program, lock it for writing at the shared-cache level.\n      ** If this vdbe did create the sqlite_stat1 table, then it must have\n      ** already obtained a schema-lock, making the write-lock redundant.\n      */\n      if ( createStat1 == 0 )\n      {\n        sqlite3TableLock( pParse, iDb, iRootPage, 1, "sqlite_stat1" );\n      }\n      sqlite3VdbeAddOp3( v, OP_OpenWrite, iStatCur, iRootPage, iDb );\n      sqlite3VdbeChangeP4( v, -1, (int)3, P4_INT32 );\n      sqlite3VdbeChangeP5( v, createStat1 );\n    }\n\n    /*\n    ** Generate code to do an analysis of all indices associated with\n    ** a single table.\n    */\n    static void analyzeOneTable(\n    Parse pParse,    /* Parser context */\n    Table pTab,      /* Table whose indices are to be analyzed */\n    int iStatCur,    /* Index of VdbeCursor that writes the sqlite_stat1 table */\n    int iMem         /* Available memory locations begin here */\n    )\n    {\n      Index pIdx;      /* An index to being analyzed */\n      int iIdxCur;     /* Index of VdbeCursor for index being analyzed */\n      int nCol;        /* Number of columns in the index */\n      Vdbe v;          /* The virtual machine being built up */\n      int i;           /* Loop counter */\n      int topOfLoop;   /* The top of the loop */\n      int endOfLoop;   /* The end of the loop */\n      int addr;        /* The address of an instruction */\n      int iDb;         /* Index of database containing pTab */\n\n      v = sqlite3GetVdbe( pParse );\n      if ( v == null || NEVER( pTab == null ) || pTab.pIndex == null )\n      {\n        /* Do no analysis for tables that have no indices */\n        return;\n      }\n      Debug.Assert( sqlite3BtreeHoldsAllMutexes( pParse.db ) );\n      iDb = sqlite3SchemaToIndex( pParse.db, pTab.pSchema );\n      Debug.Assert( iDb >= 0 );\n#if !SQLITE_OMIT_AUTHORIZATION\nif( sqlite3AuthCheck(pParse, SQLITE_ANALYZE, pTab.zName, 0,\npParse.db.aDb[iDb].zName ) ){\nreturn;\n}\n#endif\n\n      /* Establish a read-lock on the table at the shared-cache level. */\n      sqlite3TableLock( pParse, iDb, pTab.tnum, 0, pTab.zName );\n\n      iIdxCur = pParse.nTab++;\n      for ( pIdx = pTab.pIndex ; pIdx != null ; pIdx = pIdx.pNext )\n      {\n        KeyInfo pKey = sqlite3IndexKeyinfo( pParse, pIdx );\n        int regFields;    /* Register block for building records */\n        int regRec;       /* Register holding completed record */\n        int regTemp;      /* Temporary use register */\n        int regCol;       /* Content of a column from the table being analyzed */\n        int regRowid;     /* Rowid for the inserted record */\n        int regF2;\n\n        /* Open a cursor to the index to be analyzed\n        */\n        Debug.Assert( iDb == sqlite3SchemaToIndex( pParse.db, pIdx.pSchema ) );\n        nCol = pIdx.nColumn;\n        sqlite3VdbeAddOp4( v, OP_OpenRead, iIdxCur, pIdx.tnum, iDb,\n        pKey, P4_KEYINFO_HANDOFF );\n#if SQLITE_DEBUG\n        VdbeComment( v, "%s", pIdx.zName );\n#endif\n        regFields = iMem + nCol * 2;\n        regTemp = regRowid = regCol = regFields + 3;\n        regRec = regCol + 1;\n        if ( regRec > pParse.nMem )\n        {\n          pParse.nMem = regRec;\n        }\n\n        /* Memory cells are used as follows:\n        **\n        **    mem[iMem]:             The total number of rows in the table.\n        **    mem[iMem+1]:           Number of distinct values in column 1\n        **    ...\n        **    mem[iMem+nCol]:        Number of distinct values in column N\n        **    mem[iMem+nCol+1]       Last observed value of column 1\n        **    ...\n        **    mem[iMem+nCol+nCol]:   Last observed value of column N\n        **\n        ** Cells iMem through iMem+nCol are initialized to 0.  The others\n        ** are initialized to NULL.\n        */\n        for ( i = 0 ; i <= nCol ; i++ )\n        {\n          sqlite3VdbeAddOp2( v, OP_Integer, 0, iMem + i );\n        }\n        for ( i = 0 ; i < nCol ; i++ )\n        {\n          sqlite3VdbeAddOp2( v, OP_Null, 0, iMem + nCol + i + 1 );\n        }\n\n        /* Do the analysis.\n        */\n        endOfLoop = sqlite3VdbeMakeLabel( v );\n        sqlite3VdbeAddOp2( v, OP_Rewind, iIdxCur, endOfLoop );\n        topOfLoop = sqlite3VdbeCurrentAddr( v );\n        sqlite3VdbeAddOp2( v, OP_AddImm, iMem, 1 );\n        for ( i = 0 ; i < nCol ; i++ )\n        {\n          sqlite3VdbeAddOp3( v, OP_Column, iIdxCur, i, regCol );\n          sqlite3VdbeAddOp3( v, OP_Ne, regCol, 0, iMem + nCol + i + 1 );\n          /**** TODO:  add collating sequence *****/\n          sqlite3VdbeChangeP5( v, SQLITE_JUMPIFNULL );\n        }\n        sqlite3VdbeAddOp2( v, OP_Goto, 0, endOfLoop );\n        for ( i = 0 ; i < nCol ; i++ )\n        {\n          sqlite3VdbeJumpHere( v, topOfLoop + 2 * ( i + 1 ) );\n          sqlite3VdbeAddOp2( v, OP_AddImm, iMem + i + 1, 1 );\n          sqlite3VdbeAddOp3( v, OP_Column, iIdxCur, i, iMem + nCol + i + 1 );\n        }\n        sqlite3VdbeResolveLabel( v, endOfLoop );\n        sqlite3VdbeAddOp2( v, OP_Next, iIdxCur, topOfLoop );\n        sqlite3VdbeAddOp1( v, OP_Close, iIdxCur );\n\n        /* Store the results.\n        **\n        ** The result is a single row of the sqlite_stat1 table.  The first\n        ** two columns are the names of the table and index.  The third column\n        ** is a string composed of a list of integer statistics about the\n        ** index.  The first integer in the list is the total number of entries\n        ** in the index.  There is one additional integer in the list for each\n        ** column of the table.  This additional integer is a guess of how many\n        ** rows of the table the index will select.  If D is the count of distinct\n        ** values and K is the total number of rows, then the integer is computed\n        ** as:\n        **\n        **        I = (K+D-1)/D\n        **\n        ** If K==0 then no entry is made into the sqlite_stat1 table.\n        ** If K>0 then it is always the case the D>0 so division by zero\n        ** is never possible.\n        */\n        addr = sqlite3VdbeAddOp1( v, OP_IfNot, iMem );\n        sqlite3VdbeAddOp4( v, OP_String8, 0, regFields, 0, pTab.zName, 0 );\n        sqlite3VdbeAddOp4( v, OP_String8, 0, regFields + 1, 0, pIdx.zName, 0 );\n        regF2 = regFields + 2;\n        sqlite3VdbeAddOp2( v, OP_SCopy, iMem, regF2 );\n        for ( i = 0 ; i < nCol ; i++ )\n        {\n          sqlite3VdbeAddOp4( v, OP_String8, 0, regTemp, 0, \' \', 0 );\n          sqlite3VdbeAddOp3( v, OP_Concat, regTemp, regF2, regF2 );\n          sqlite3VdbeAddOp3( v, OP_Add, iMem, iMem + i + 1, regTemp );\n          sqlite3VdbeAddOp2( v, OP_AddImm, regTemp, -1 );\n          sqlite3VdbeAddOp3( v, OP_Divide, iMem + i + 1, regTemp, regTemp );\n          sqlite3VdbeAddOp1( v, OP_ToInt, regTemp );\n          sqlite3VdbeAddOp3( v, OP_Concat, regTemp, regF2, regF2 );\n        }\n        sqlite3VdbeAddOp4( v, OP_MakeRecord, regFields, 3, regRec, new byte[] { (byte)\'a\', (byte)\'a\', (byte)\'a\' }, 0 );\n        sqlite3VdbeAddOp2( v, OP_NewRowid, iStatCur, regRowid );\n        sqlite3VdbeAddOp3( v, OP_Insert, iStatCur, regRec, regRowid );\n        sqlite3VdbeChangeP5( v, OPFLAG_APPEND );\n        sqlite3VdbeJumpHere( v, addr );\n      }\n    }\n\n    /*\n    ** Generate code that will cause the most recent index analysis to\n    ** be laoded into internal hash tables where is can be used.\n    */\n    static void loadAnalysis( Parse pParse, int iDb )\n    {\n      Vdbe v = sqlite3GetVdbe( pParse );\n      if ( v != null )\n      {\n        sqlite3VdbeAddOp1( v, OP_LoadAnalysis, iDb );\n      }\n    }\n\n    /*\n    ** Generate code that will do an analysis of an entire database\n    */\n    static void analyzeDatabase( Parse pParse, int iDb )\n    {\n      sqlite3 db = pParse.db;\n      Schema pSchema = db.aDb[iDb].pSchema;    /* Schema of database iDb */\n      HashElem k;\n      int iStatCur;\n      int iMem;\n\n      sqlite3BeginWriteOperation( pParse, 0, iDb );\n      iStatCur = pParse.nTab++;\n      openStatTable( pParse, iDb, iStatCur, null );\n      iMem = pParse.nMem + 1;\n      //for(k=sqliteHashFirst(pSchema.tblHash); k; k=sqliteHashNext(k)){\n      for ( k = pSchema.tblHash.first ; k != null ; k = k.next )\n      {\n        Table pTab = (Table)k.data;// sqliteHashData( k );\n        analyzeOneTable( pParse, pTab, iStatCur, iMem );\n      }\n      loadAnalysis( pParse, iDb );\n    }\n\n    /*\n    ** Generate code that will do an analysis of a single table in\n    ** a database.\n    */\n    static void analyzeTable( Parse pParse, Table pTab )\n    {\n      int iDb;\n      int iStatCur;\n\n      Debug.Assert( pTab != null );\n      Debug.Assert( sqlite3BtreeHoldsAllMutexes( pParse.db ) );\n      iDb = sqlite3SchemaToIndex( pParse.db, pTab.pSchema );\n      sqlite3BeginWriteOperation( pParse, 0, iDb );\n      iStatCur = pParse.nTab++;\n      openStatTable( pParse, iDb, iStatCur, pTab.zName );\n      analyzeOneTable( pParse, pTab, iStatCur, pParse.nMem + 1 );\n      loadAnalysis( pParse, iDb );\n    }\n\n    /*\n    ** Generate code for the ANALYZE command.  The parser calls this routine\n    ** when it recognizes an ANALYZE command.\n    **\n    **        ANALYZE                            -- 1\n    **        ANALYZE  <database>                -- 2\n    **        ANALYZE  ?<database>.?<tablename>  -- 3\n    **\n    ** Form 1 causes all indices in all attached databases to be analyzed.\n    ** Form 2 analyzes all indices the single database named.\n    ** Form 3 analyzes all indices associated with the named table.\n    */\n    // OVERLOADS, so I don\'t need to rewrite parse.c\n    static void sqlite3Analyze( Parse pParse, int null_2, int null_3 )\n    { sqlite3Analyze( pParse, null, null ); }\n    static void sqlite3Analyze( Parse pParse, Token pName1, Token pName2 )\n    {\n      sqlite3 db = pParse.db;\n      int iDb;\n      int i;\n      string z, zDb;\n      Table pTab;\n      Token pTableName = null;\n\n      /* Read the database schema. If an error occurs, leave an error message\n      ** and code in pParse and return NULL. */\n      Debug.Assert( sqlite3BtreeHoldsAllMutexes( pParse.db ) );\n      if ( SQLITE_OK != sqlite3ReadSchema( pParse ) )\n      {\n        return;\n      }\n\n      Debug.Assert( pName2 != null || pName1 == null );\n      if ( pName1 == null )\n      {\n        /* Form 1:  Analyze everything */\n        for ( i = 0 ; i < db.nDb ; i++ )\n        {\n          if ( i == 1 ) continue;  /* Do not analyze the TEMP database */\n          analyzeDatabase( pParse, i );\n        }\n      }\n      else if ( pName2.n == 0 )\n      {\n        /* Form 2:  Analyze the database or table named */\n        iDb = sqlite3FindDb( db, pName1 );\n        if ( iDb >= 0 )\n        {\n          analyzeDatabase( pParse, iDb );\n        }\n        else\n        {\n          z = sqlite3NameFromToken( db, pName1 );\n          if ( z != null )\n          {\n            pTab = sqlite3LocateTable( pParse, 0, z, null );\n            //sqlite3DbFree( db, ref z );\n            if ( pTab != null )\n            {\n              analyzeTable( pParse, pTab );\n            }\n          }\n        }\n      }\n      else\n      {\n        /* Form 3: Analyze the fully qualified table name */\n        iDb = sqlite3TwoPartName( pParse, pName1, pName2, ref  pTableName );\n        if ( iDb >= 0 )\n        {\n          zDb = db.aDb[iDb].zName;\n          z = sqlite3NameFromToken( db, pTableName );\n          if ( z != null )\n          {\n            pTab = sqlite3LocateTable( pParse, 0, z, zDb );\n            //sqlite3DbFree( db, ref z );\n            if ( pTab != null )\n            {\n              analyzeTable( pParse, pTab );\n            }\n          }\n        }\n      }\n    }\n\n    /*\n    ** Used to pass information from the analyzer reader through to the\n    ** callback routine.\n    */\n    //typedef struct analysisInfo analysisInfo;\n    public struct analysisInfo\n    {\n      public sqlite3 db;\n      public string zDatabase;\n    };\n\n    /*\n    ** This callback is invoked once for each index when reading the\n    ** sqlite_stat1 table.\n    **\n    **     argv[0] = name of the index\n    **     argv[1] = results of analysis - on integer for each column\n    */\n    static int analysisLoader( object pData, sqlite3_int64 argc, object Oargv, object NotUsed )\n    {\n      string[] argv = (string[])Oargv;\n      analysisInfo pInfo = (analysisInfo)pData;\n      Index pIndex;\n      int i, c;\n      int v;\n      string z;\n\n      Debug.Assert( argc == 2 );\n      UNUSED_PARAMETER2( NotUsed, argc );\n      if ( argv == null || argv[0] == null || argv[1] == null )\n      {\n        return 0;\n      }\n      pIndex = sqlite3FindIndex( pInfo.db, argv[0], pInfo.zDatabase );\n      if ( pIndex == null )\n      {\n        return 0;\n      }\n      z = argv[1];\n      int zIndex = 0;\n      for ( i = 0 ; z != null && i <= pIndex.nColumn ; i++ )\n      {\n        v = 0;\n        while ( zIndex < z.Length && ( c = z[zIndex] ) >= \'0\' && c <= \'9\' )\n        {\n          v = v * 10 + c - \'0\';\n          zIndex++;\n        }\n        pIndex.aiRowEst[i] = v;\n        if ( zIndex < z.Length && z[zIndex] == \' \' ) zIndex++;\n      }\n      return 0;\n    }\n\n    /*\n    ** Load the content of the sqlite_stat1 table into the index hash tables.\n    */\n    static int sqlite3AnalysisLoad( sqlite3 db, int iDb )\n    {\n      analysisInfo sInfo;\n      HashElem i;\n      string zSql;\n      int rc;\n\n      Debug.Assert( iDb >= 0 && iDb < db.nDb );\n      Debug.Assert( db.aDb[iDb].pBt != null );\n      Debug.Assert( sqlite3BtreeHoldsMutex( db.aDb[iDb].pBt ) );\n      /* Clear any prior statistics */\n      //for(i=sqliteHashFirst(&db.aDb[iDb].pSchema.idxHash);i;i=sqliteHashNext(i)){\n      for ( i = db.aDb[iDb].pSchema.idxHash.first ; i != null ; i = i.next )\n      {\n        Index pIdx = (Index)i.data;// sqliteHashData( i );\n        sqlite3DefaultRowEst( pIdx );\n      }\n\n      /* Check to make sure the sqlite_stat1 table exists */\n      sInfo.db = db;\n      sInfo.zDatabase = db.aDb[iDb].zName;\n      if ( sqlite3FindTable( db, "sqlite_stat1", sInfo.zDatabase ) == null )\n      {\n        return SQLITE_ERROR;\n      }\n\n\n      /* Load new statistics out of the sqlite_stat1 table */\n      zSql = sqlite3MPrintf( db, "SELECT idx, stat FROM %Q.sqlite_stat1",\n      sInfo.zDatabase );\n      if ( zSql == null )\n      {\n        rc = SQLITE_NOMEM;\n      }\n      else\n      {\n        sqlite3SafetyOff( db );\n        rc = sqlite3_exec( db, zSql, (dxCallback)analysisLoader, sInfo, 0 );\n        sqlite3SafetyOn( db );\n        //sqlite3DbFree( db, ref zSql );\n//        if ( rc == SQLITE_NOMEM ) db.mallocFailed = 1;\n      }\n      return rc;\n    }\n\n\n#endif // * SQLITE_OMIT_ANALYZE */\n  }\n}\n'