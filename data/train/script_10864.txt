b'/*\n* Copyright (C) 2014 The CyanogenMod Project\n*\n* Licensed under the Apache License, Version 2.0 (the "License");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n* http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an "AS IS" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\npackage com.naman14.timber.provider;\n\nimport android.content.ContentValues;\nimport android.content.Context;\nimport android.database.Cursor;\nimport android.database.sqlite.SQLiteDatabase;\nimport android.view.animation.AccelerateInterpolator;\nimport android.view.animation.Interpolator;\n\nimport java.util.HashSet;\nimport java.util.Iterator;\n\n/**\n * This database tracks the number of play counts for an individual song.  This is used to drive\n * the top played tracks as well as the playlist images\n */\npublic class SongPlayCount {\n    // how many weeks worth of playback to track\n    private static final int NUM_WEEKS = 52;\n    private static SongPlayCount sInstance = null;\n    // interpolator curve applied for measuring the curve\n    private static Interpolator sInterpolator = new AccelerateInterpolator(1.5f);\n    // how high to multiply the interpolation curve\n    private static int INTERPOLATOR_HEIGHT = 50;\n    // how high the base value is. The ratio of the Height to Base is what really matters\n    private static int INTERPOLATOR_BASE = 25;\n    private static int ONE_WEEK_IN_MS = 1000 * 60 * 60 * 24 * 7;\n    private static String WHERE_ID_EQUALS = SongPlayCountColumns.ID + "=?";\n    private MusicDB mMusicDatabase = null;\n    // number of weeks since epoch time\n    private int mNumberOfWeeksSinceEpoch;\n\n    // used to track if we\'ve walkd through the db and updated all the rows\n    private boolean mDatabaseUpdated;\n\n    /**\n     * Constructor of <code>RecentStore</code>\n     *\n     * @param context The {@link android.content.Context} to use\n     */\n    public SongPlayCount(final Context context) {\n        mMusicDatabase = MusicDB.getInstance(context);\n\n        long msSinceEpoch = System.currentTimeMillis();\n        mNumberOfWeeksSinceEpoch = (int) (msSinceEpoch / ONE_WEEK_IN_MS);\n\n        mDatabaseUpdated = false;\n    }\n\n    /**\n     * @param context The {@link android.content.Context} to use\n     * @return A new instance of this class.\n     */\n    public static final synchronized SongPlayCount getInstance(final Context context) {\n        if (sInstance == null) {\n            sInstance = new SongPlayCount(context.getApplicationContext());\n        }\n        return sInstance;\n    }\n\n    /**\n     * Calculates the score of the song given the play counts\n     *\n     * @param playCounts an array of the # of times a song has been played for each week\n     *                   where playCounts[N] is the # of times it was played N weeks ago\n     * @return the score\n     */\n    private static float calculateScore(final int[] playCounts) {\n        if (playCounts == null) {\n            return 0;\n        }\n\n        float score = 0;\n        for (int i = 0; i < Math.min(playCounts.length, NUM_WEEKS); i++) {\n            score += playCounts[i] * getScoreMultiplierForWeek(i);\n        }\n\n        return score;\n    }\n\n    /**\n     * Gets the column name for each week #\n     *\n     * @param week number\n     * @return the column name\n     */\n    private static String getColumnNameForWeek(final int week) {\n        return SongPlayCountColumns.WEEK_PLAY_COUNT + String.valueOf(week);\n    }\n\n    /**\n     * Gets the score multiplier for each week\n     *\n     * @param week number\n     * @return the multiplier to apply\n     */\n    private static float getScoreMultiplierForWeek(final int week) {\n        return sInterpolator.getInterpolation(1 - (week / (float) NUM_WEEKS)) * INTERPOLATOR_HEIGHT\n                + INTERPOLATOR_BASE;\n    }\n\n    /**\n     * For some performance gain, return a static value for the column index for a week\n     * WARNIGN: This function assumes you have selected all columns for it to work\n     *\n     * @param week number\n     * @return column index of that week\n     */\n    private static int getColumnIndexForWeek(final int week) {\n        // ID, followed by the weeks columns\n        return 1 + week;\n    }\n\n    public void onCreate(final SQLiteDatabase db) {\n        // create the play count table\n        // WARNING: If you change the order of these columns\n        // please update getColumnIndexForWeek\n        StringBuilder builder = new StringBuilder();\n        builder.append("CREATE TABLE IF NOT EXISTS ");\n        builder.append(SongPlayCountColumns.NAME);\n        builder.append("(");\n        builder.append(SongPlayCountColumns.ID);\n        builder.append(" INT UNIQUE,");\n\n        for (int i = 0; i < NUM_WEEKS; i++) {\n            builder.append(getColumnNameForWeek(i));\n            builder.append(" INT DEFAULT 0,");\n        }\n\n        builder.append(SongPlayCountColumns.LAST_UPDATED_WEEK_INDEX);\n        builder.append(" INT NOT NULL,");\n\n        builder.append(SongPlayCountColumns.PLAYCOUNTSCORE);\n        builder.append(" REAL DEFAULT 0);");\n\n        db.execSQL(builder.toString());\n    }\n\n    public void onUpgrade(final SQLiteDatabase db, final int oldVersion, final int newVersion) {\n        // No upgrade path needed yet\n    }\n\n    public void onDowngrade(SQLiteDatabase db, int oldVersion, int newVersion) {\n        // If we ever have downgrade, drop the table to be safe\n        db.execSQL("DROP TABLE IF EXISTS " + SongPlayCountColumns.NAME);\n        onCreate(db);\n    }\n\n    /**\n     * Increases the play count of a song by 1\n     *\n     * @param songId The song id to increase the play count\n     */\n    public void bumpSongCount(final long songId) {\n        if (songId < 0) {\n            return;\n        }\n\n        final SQLiteDatabase database = mMusicDatabase.getWritableDatabase();\n        updateExistingRow(database, songId, true);\n    }\n\n    /**\n     * This creates a new entry that indicates a song has been played once as well as its score\n     *\n     * @param database a writeable database\n     * @param songId   the id of the track\n     */\n    private void createNewPlayedEntry(final SQLiteDatabase database, final long songId) {\n        // no row exists, create a new one\n        float newScore = getScoreMultiplierForWeek(0);\n        int newPlayCount = 1;\n\n        final ContentValues values = new ContentValues(3);\n        values.put(SongPlayCountColumns.ID, songId);\n        values.put(SongPlayCountColumns.PLAYCOUNTSCORE, newScore);\n        values.put(SongPlayCountColumns.LAST_UPDATED_WEEK_INDEX, mNumberOfWeeksSinceEpoch);\n        values.put(getColumnNameForWeek(0), newPlayCount);\n\n        database.insert(SongPlayCountColumns.NAME, null, values);\n    }\n\n    /**\n     * This function will take a song entry and update it to the latest week and increase the count\n     * for the current week by 1 if necessary\n     *\n     * @param database  a writeable database\n     * @param id        the id of the track to bump\n     * @param bumpCount whether to bump the current\'s week play count by 1 and adjust the score\n     */\n    private void updateExistingRow(final SQLiteDatabase database, final long id, boolean bumpCount) {\n        String stringId = String.valueOf(id);\n\n        // begin the transaction\n        database.beginTransaction();\n\n        // get the cursor of this content inside the transaction\n        final Cursor cursor = database.query(SongPlayCountColumns.NAME, null, WHERE_ID_EQUALS,\n                new String[]{stringId}, null, null, null);\n\n        // if we have a result\n        if (cursor != null && cursor.moveToFirst()) {\n            // figure how many weeks since we last updated\n            int lastUpdatedIndex = cursor.getColumnIndex(SongPlayCountColumns.LAST_UPDATED_WEEK_INDEX);\n            int lastUpdatedWeek = cursor.getInt(lastUpdatedIndex);\n            int weekDiff = mNumberOfWeeksSinceEpoch - lastUpdatedWeek;\n\n            // if it\'s more than the number of weeks we track, delete it and create a new entry\n            if (Math.abs(weekDiff) >= NUM_WEEKS) {\n                // this entry needs to be dropped since it is too outdated\n                deleteEntry(database, stringId);\n                if (bumpCount) {\n                    createNewPlayedEntry(database, id);\n                }\n            } else if (weekDiff != 0) {\n                // else, shift the weeks\n                int[] playCounts = new int[NUM_WEEKS];\n\n                if (weekDiff > 0) {\n                    // time is shifted forwards\n                    for (int i = 0; i < NUM_WEEKS - weekDiff; i++) {\n                        playCounts[i + weekDiff] = cursor.getInt(getColumnIndexForWeek(i));\n                    }\n                } else if (weekDiff < 0) {\n                    // time is shifted backwards (by user) - nor typical behavior but we\n                    // will still handle it\n\n                    // since weekDiff is -ve, NUM_WEEKS + weekDiff is the real # of weeks we have to\n                    // transfer.  Then we transfer the old week i - weekDiff to week i\n                    // for example if the user shifted back 2 weeks, ie -2, then for 0 to\n                    // NUM_WEEKS + (-2) we set the new week i = old week i - (-2) or i+2\n                    for (int i = 0; i < NUM_WEEKS + weekDiff; i++) {\n                        playCounts[i] = cursor.getInt(getColumnIndexForWeek(i - weekDiff));\n                    }\n                }\n\n                // bump the count\n                if (bumpCount) {\n                    playCounts[0]++;\n                }\n\n                float score = calculateScore(playCounts);\n\n                // if the score is non-existant, then delete it\n                if (score < .01f) {\n                    deleteEntry(database, stringId);\n                } else {\n                    // create the content values\n                    ContentValues values = new ContentValues(NUM_WEEKS + 2);\n                    values.put(SongPlayCountColumns.LAST_UPDATED_WEEK_INDEX, mNumberOfWeeksSinceEpoch);\n                    values.put(SongPlayCountColumns.PLAYCOUNTSCORE, score);\n\n                    for (int i = 0; i < NUM_WEEKS; i++) {\n                        values.put(getColumnNameForWeek(i), playCounts[i]);\n                    }\n\n                    // update the entry\n                    database.update(SongPlayCountColumns.NAME, values, WHERE_ID_EQUALS,\n                            new String[]{stringId});\n                }\n            } else if (bumpCount) {\n                // else no shifting, just update the scores\n                ContentValues values = new ContentValues(2);\n\n                // increase the score by a single score amount\n                int scoreIndex = cursor.getColumnIndex(SongPlayCountColumns.PLAYCOUNTSCORE);\n                float score = cursor.getFloat(scoreIndex) + getScoreMultiplierForWeek(0);\n                values.put(SongPlayCountColumns.PLAYCOUNTSCORE, score);\n\n                // increase the play count by 1\n                values.put(getColumnNameForWeek(0), cursor.getInt(getColumnIndexForWeek(0)) + 1);\n\n                // update the entry\n                database.update(SongPlayCountColumns.NAME, values, WHERE_ID_EQUALS,\n                        new String[]{stringId});\n            }\n\n            cursor.close();\n        } else if (bumpCount) {\n            // if we have no existing results, create a new one\n            createNewPlayedEntry(database, id);\n        }\n\n        database.setTransactionSuccessful();\n        database.endTransaction();\n    }\n\n    public void deleteAll() {\n        final SQLiteDatabase database = mMusicDatabase.getWritableDatabase();\n        database.delete(SongPlayCountColumns.NAME, null, null);\n    }\n\n    /**\n     * Gets a cursor containing the top songs played.  Note this only returns songs that have been\n     * played at least once in the past NUM_WEEKS\n     *\n     * @param numResults number of results to limit by.  If <= 0 it returns all results\n     * @return the top tracks\n     */\n    public Cursor getTopPlayedResults(int numResults) {\n        updateResults();\n\n        final SQLiteDatabase database = mMusicDatabase.getReadableDatabase();\n        return database.query(SongPlayCountColumns.NAME, new String[]{SongPlayCountColumns.ID},\n                null, null, null, null, SongPlayCountColumns.PLAYCOUNTSCORE + " DESC",\n                (numResults <= 0 ? null : String.valueOf(numResults)));\n    }\n\n    /**\n     * Given a list of ids, it sorts the results based on the most played results\n     *\n     * @param ids list\n     * @return sorted list - this may be smaller than the list passed in for performance reasons\n     */\n    public long[] getTopPlayedResultsForList(long[] ids) {\n        final int MAX_NUMBER_SONGS_TO_ANALYZE = 250;\n\n        if (ids == null || ids.length == 0) {\n            return null;\n        }\n\n        HashSet<Long> uniqueIds = new HashSet<Long>(ids.length);\n\n        // create the list of ids to select against\n        StringBuilder selection = new StringBuilder();\n        selection.append(SongPlayCountColumns.ID);\n        selection.append(" IN (");\n\n        // add the first element to handle the separator case for the first element\n        uniqueIds.add(ids[0]);\n        selection.append(ids[0]);\n\n        for (int i = 1; i < ids.length; i++) {\n            // if the new id doesn\'t exist\n            if (uniqueIds.add(ids[i])) {\n                // append a separator\n                selection.append(",");\n\n                // append the id\n                selection.append(ids[i]);\n\n                // for performance reasons, only look at a certain number of songs\n                // in case their playlist is ridiculously large\n                if (uniqueIds.size() >= MAX_NUMBER_SONGS_TO_ANALYZE) {\n                    break;\n                }\n            }\n        }\n\n        // close out the selection\n        selection.append(")");\n\n        long[] sortedList = new long[uniqueIds.size()];\n\n        // now query for the songs\n        final SQLiteDatabase database = mMusicDatabase.getReadableDatabase();\n        Cursor topSongsCursor = null;\n        int idx = 0;\n\n        try {\n            topSongsCursor = database.query(SongPlayCountColumns.NAME,\n                    new String[]{SongPlayCountColumns.ID}, selection.toString(), null, null,\n                    null, SongPlayCountColumns.PLAYCOUNTSCORE + " DESC");\n\n            if (topSongsCursor != null && topSongsCursor.moveToFirst()) {\n                do {\n                    // for each id found, add it to the list and remove it from the unique ids\n                    long id = topSongsCursor.getLong(0);\n                    sortedList[idx++] = id;\n                    uniqueIds.remove(id);\n                } while (topSongsCursor.moveToNext());\n            }\n        } finally {\n            if (topSongsCursor != null) {\n                topSongsCursor.close();\n                topSongsCursor = null;\n            }\n        }\n\n        // append the remaining items - these are songs that haven\'t been played recently\n        Iterator<Long> iter = uniqueIds.iterator();\n        while (iter.hasNext()) {\n            sortedList[idx++] = iter.next();\n        }\n\n        return sortedList;\n    }\n\n    /**\n     * This updates all the results for the getTopPlayedResults so that we can get an\n     * accurate list of the top played results\n     */\n    private synchronized void updateResults() {\n        if (mDatabaseUpdated) {\n            return;\n        }\n\n        final SQLiteDatabase database = mMusicDatabase.getWritableDatabase();\n\n        database.beginTransaction();\n\n        int oldestWeekWeCareAbout = mNumberOfWeeksSinceEpoch - NUM_WEEKS + 1;\n        // delete rows we don\'t care about anymore\n        database.delete(SongPlayCountColumns.NAME, SongPlayCountColumns.LAST_UPDATED_WEEK_INDEX\n                + " < " + oldestWeekWeCareAbout, null);\n\n        // get the remaining rows\n        Cursor cursor = database.query(SongPlayCountColumns.NAME,\n                new String[]{SongPlayCountColumns.ID},\n                null, null, null, null, null);\n\n        if (cursor != null && cursor.moveToFirst()) {\n            // for each row, update it\n            do {\n                updateExistingRow(database, cursor.getLong(0), false);\n            } while (cursor.moveToNext());\n\n            cursor.close();\n            cursor = null;\n        }\n\n        mDatabaseUpdated = true;\n        database.setTransactionSuccessful();\n        database.endTransaction();\n    }\n\n    /**\n     * @param songId The song Id to remove.\n     */\n    public void removeItem(final long songId) {\n        final SQLiteDatabase database = mMusicDatabase.getWritableDatabase();\n        deleteEntry(database, String.valueOf(songId));\n    }\n\n    /**\n     * Deletes the entry\n     *\n     * @param database database to use\n     * @param stringId id to delete\n     */\n    private void deleteEntry(final SQLiteDatabase database, final String stringId) {\n        database.delete(SongPlayCountColumns.NAME, WHERE_ID_EQUALS, new String[]{stringId});\n    }\n\n    public interface SongPlayCountColumns {\n\n        /* Table name */\n        String NAME = "songplaycount";\n\n        /* Song IDs column */\n        String ID = "songid";\n\n        /* Week Play Count */\n        String WEEK_PLAY_COUNT = "week";\n\n        /* Weeks since Epoch */\n        String LAST_UPDATED_WEEK_INDEX = "weekindex";\n\n        /* Play count */\n        String PLAYCOUNTSCORE = "playcountscore";\n    }\n}\n'