b'#include "../UABE_Generic/PluginManager.h"\n#include "../UABE_Generic/FileContextInfo.h"\n#include "../UABE_Generic/AppContext.h"\n//#include "../AssetsTools/TextureFileFormat.h"\n#include "../AssetsTools/AssetsReplacer.h"\n#include "../AssetsTools/AssetsFileTable.h"\n#include "../AssetsTools/ResourceManagerFile.h"\n\n#include <fmod.hpp>\n\n#include <tchar.h>\n#include <filesystem>\n\n#include "wavfile.h"\n\nenum AudioType_U4\n{\n\tAudioType_UNKNOWN=0,\n\tAudioType_ACC=1,\n\tAudioType_AIFF=2,\n\tAudioType_IT=10,\n\tAudioType_MOD=12,\n\tAudioType_MPEG=13, //.mp3\n\tAudioType_OGGVORBIS=14, //.ogg\n\tAudioType_S3M=0x11,\n\tAudioType_WAV=0x14,\n\tAudioType_XM=0x15,\n\tAudioType_XMA=0x16,\n\tAudioType_VAG=0x17,\n\tAudioType_AUDIOQUEUE=0x18,\n\tAudioType_MAX\n};\nuint8_t AudioTypeIndexTable[AudioType_MAX] = {\n\t0, 1, 2, 0, 0, 0, 0, 0, 0, 0, 3, 0, 4, 5, 6, 0, 0, 7, 0, 0, 8, 9, 10, 11, 12\n};\nconst char *AudioTypeExtensions[13] = {\n\t"", //0\n\t".acc",\n\t".aiff",\n\t"",\n\t".mod",\n\t".mp3",\n\t".ogg", //6\n\t".s3m",\n\t".wav",\n\t".xm",\n\t".xma",\n\t".vag",\n\t""\n};\nconst wchar_t *AudioTypeExtensionsW[13] = {\n\tL"", //0\n\tL".acc",\n\tL".aiff",\n\tL"",\n\tL".mod",\n\tL".mp3",\n\tL".ogg", //6\n\tL".s3m",\n\tL".wav",\n\tL".xm",\n\tL".xma",\n\tL".vag",\n\tL""\n};\nconst wchar_t *AudioTypeFileFilters[13] = {\n\tL"*.*|Unknown file format", //0\n\tL"*.acc|Advanced Audio Coding file",\n\tL"*.aiff|Audio Interchange File",\n\tL"*.*|Impulse tracker audio file",\n\tL"*.mod|Fasttracker .MOD file",\n\tL"*.mp3:*.mp2|MPEG audio file",\n\tL"*.ogg|Ogg vorbis container file", //6\n\tL"*.s3m|ScreamTracker 3 file",\n\tL"*.wav|Wave file",\n\tL"*.xm|FastTracker 2 XM file",\n\tL"*.xma|Xbox360 XMA file",\n\tL"*.vag|PlayStation ADPCM file",\n\tL"*.*|AudioQueue file"\n};\nenum AudioCompressionFormat_U4\n{\n\tAudioCompressionFormat_PCM, //header-less\n\tAudioCompressionFormat_Vorbis, //.ogg\n\tAudioCompressionFormat_ADPCM, //headerless\n\tAudioCompressionFormat_MP3, //.mp3\n\tAudioCompressionFormat_VAG, //.vag\n\tAudioCompressionFormat_HEVAG, //no idea\n\tAudioCompressionFormat_XMA, //no idea\n\tAudioCompressionFormat_AAC  //.3gp or .aac\n};\nFMOD_RESULT _stdcall SoundEndCallback(FMOD_CHANNELCONTROL *channelcontrol, FMOD_CHANNELCONTROL_TYPE controltype, FMOD_CHANNELCONTROL_CALLBACK_TYPE callbacktype, void *commanddata1, void *commanddata2)\n{\n\tif (callbacktype == FMOD_CHANNELCONTROL_CALLBACK_END)\n\t{\n\t\treturn FMOD_ERR_FILE_EOF;\n\t}\n\treturn FMOD_OK;\n}\n\n\nclass AudioClipExportTask : public AssetExportTask\n{\n\tAppContext& appContext;\n\tTypeTemplateCache templateCache;\n\n\tstatic void closeFMODSystem(FMOD::System* pSystem)\n\t{\n\t\tpSystem->release();\n\t}\n\tstd::unique_ptr<FMOD::System, decltype(closeFMODSystem)*> pFMODSystem;\npublic:\n\tAudioClipExportTask(AppContext& appContext,\n\t\tstd::vector<AssetUtilDesc> _assets, std::string _baseDir,\n\t\tbool stopOnError = false)\n\n\t\t: AssetExportTask(std::move(_assets), "Export AudioClip data", "", std::move(_baseDir), stopOnError),\n\t\tappContext(appContext),\n\t\tpFMODSystem(nullptr, &closeFMODSystem)\n\t{\n\t\tFMOD::System* pFMODSystem = NULL;\n\t\t//createFunc((FMOD_SYSTEM**)&pFMODSystem)\n\t\tif (FMOD::System_Create(&pFMODSystem) == FMOD_OK)\n\t\t{\n\t\t\tthis->pFMODSystem.reset(pFMODSystem);\n\t\t\tpFMODSystem->setOutput(FMOD_OUTPUTTYPE_NOSOUND_NRT);\n\t\t\tpFMODSystem->init(16, FMOD_INIT_NORMAL, NULL);\n\t\t}\n\t}\n\n\tbool exportAsset(AssetUtilDesc& desc, std::string path, std::optional<std::reference_wrapper<TaskProgressManager>> progressManager)\n\t{\n\t\tif (desc.asset.pFile == nullptr)\n\t\t\tthrow AssetUtilError("Unable to find the target .assets file.");\n\n\t\tIAssetsReader_ptr pAssetReader = desc.asset.makeReader();\n\t\tif (pAssetReader == nullptr)\n\t\t\tthrow AssetUtilError("Unable to read the asset.");\n\t\tQWORD assetSize = 0;\n\t\tif (!pAssetReader->Seek(AssetsSeek_End, 0) || !pAssetReader->Tell(assetSize) || !pAssetReader->Seek(AssetsSeek_Begin, 0))\n\t\t\tthrow AssetUtilError("Unable to read the asset.");\n\n\t\tAssetTypeTemplateField& templateBase = templateCache.getTemplateField(appContext, desc.asset,\n\t\t\t[](AssetTypeTemplateField& templateBase) {\n\t\t\t\tfor (size_t i = 0; i < templateBase.children.size(); i++)\n\t\t\t\t{\n\t\t\t\t\tif (templateBase.children[i].children.size() > 0 && templateBase.children[i].name == "m_AudioData")\n\t\t\t\t\t{\n\t\t\t\t\t\ttemplateBase.children[i].children[0].type = "TypelessData"; //Improve deserialization performance for U4 audio clips\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\t\tAssetTypeTemplateField* pTemplateBase = &templateBase;\n\t\t\n\n\t\tAssetTypeInstance assetInstance(1, &pTemplateBase, assetSize, pAssetReader.get(), desc.asset.isBigEndian());\n\t\tAssetTypeValueField* pBaseField = assetInstance.GetBaseField();\n\t\tif (pBaseField == nullptr || pBaseField->IsDummy())\n\t\t\tthrow AssetUtilError("Unable to deserialize the asset.");\n\n\t\t\n\t\tAssetTypeValueField* formatField = pBaseField->Get("m_Format");\n\t\tAssetTypeValueField* typeField = pBaseField->Get("m_Type");\n\t\tAssetTypeValueField* nameField = pBaseField->Get("m_Name");\n\t\tAssetTypeValueField* streamField = pBaseField->Get("m_Stream");\n\t\tAssetTypeValueField* dataField = pBaseField->Get("m_AudioData")->Get(0U);\n\n\t\tif (!nameField->IsDummy() && !formatField->IsDummy() && !nameField->IsDummy() && !dataField->IsDummy()) //Unity 3/4\n\t\t{\n\t\t\tint streamType = 1;\n\t\t\tif (!streamField->IsDummy())\n\t\t\t\tstreamType = streamField->GetValue()->AsInt();\n\t\t\tstd::shared_ptr<IAssetsReader> pStreamReader = nullptr;\n\t\t\tQWORD streamSize = 0;\n\t\t\tif (streamType == 2 && !desc.assetsFileName.empty())\n\t\t\t{\n\t\t\t\t//TODO: Make sure this actually works (is based on legacy plugin code, API has been revamped in the meantime).\n\t\t\t\t//  It appears like the data Array size is set to the resource size, but the in-asset Array just contains the 4 bytes size?\n\t\t\t\t//  If so, this would most certainly cause trouble with deserialization.\n\t\t\t\tstd::string streamDataFileName = desc.assetsFileName + ".resS";\n\n\t\t\t\tif (dataField->GetValue()->AsByteArray()->size < 4)\n\t\t\t\t\tthrow AssetUtilError("The streamed data file is invalid.");\n\n\t\t\t\tQWORD streamFileOffset = *(uint32_t*)dataField->GetValue()->AsByteArray()->data;\n\t\t\t\tQWORD streamSize = dataField->GetValue()->AsByteArray()->size;\n\n\t\t\t\tstd::shared_ptr<ResourcesFileContextInfo> streamResourcesContextInfo;\n\t\t\t\tstreamResourcesContextInfo = FindResourcesFile(appContext, streamDataFileName, desc.asset, progressManager);\n\t\t\t\t//Non-null guaranteed by FindResourcesFile (AssetUtilError thrown otherwise).\n\n\t\t\t\tpStreamReader = streamResourcesContextInfo->getResource(streamResourcesContextInfo,\n\t\t\t\t\tstreamFileOffset,\n\t\t\t\t\tstreamSize);\n\t\t\t\tif (pStreamReader == nullptr)\n\t\t\t\t\tthrow AssetUtilError("Unable to locate the audio resource.");\n\t\t\t}\n\n\t\t\tchar* audioClipName = nameField->GetValue()->AsString();\n\t\t\tunsigned int audioClipFormat = (unsigned int)formatField->GetValue()->AsInt();\n\t\t\tunsigned int audioClipType = (unsigned int)typeField->GetValue()->AsInt();\n\t\t\tif (audioClipType >= AudioType_MAX)\n\t\t\t\taudioClipType = 0;\n\t\t\tconst char* audioClipExtension = AudioTypeExtensions[AudioTypeIndexTable[audioClipType]];\n\t\t\tstd::string fullOutputPath = path + audioClipExtension;\n\n\t\t\tstd::unique_ptr<IAssetsWriter> pWriter(Create_AssetsWriterToFile(fullOutputPath.c_str(), true, true, RWOpenFlags_Immediately));\n\t\t\tif (pWriter == nullptr)\n\t\t\t\tthrow AssetUtilError("Unable to create the output file.");\n\t\t\tif (pStreamReader)\n\t\t\t{\n\t\t\t\tstd::unique_ptr<AssetsEntryReplacer> copier(MakeAssetModifierFromReader(0, 0, -1, 0xFFFF, pStreamReader.get(), streamSize));\n\t\t\t\tif (copier->Write(0, pWriter.get()) != streamSize)\n\t\t\t\t\tthrow AssetUtilError("Unable to copy data from the audio resource to the output file.");\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tQWORD size = dataField->GetValue()->AsByteArray()->size;\n\t\t\t\tif (pWriter->Write(size, dataField->GetValue()->AsByteArray()->data) != size)\n\t\t\t\t\tthrow AssetUtilError("Unable to write data to the output file.");\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t\telse //Unity 5 and newer\n\t\t{\n\t\t\tAssetTypeValueField* bitsPerSampleField = pBaseField->Get("m_BitsPerSample");\n\t\t\tAssetTypeValueField* frequencyField = pBaseField->Get("m_Frequency");\n\t\t\tAssetTypeValueField* channelsField = pBaseField->Get("m_Channels");\n\t\t\tAssetTypeValueField* resource = pBaseField->Get("m_Resource");\n\t\t\tif (bitsPerSampleField->IsDummy() || nameField->IsDummy() || resource->IsDummy()\n\t\t\t\t|| frequencyField->IsDummy() || channelsField->IsDummy())\n\t\t\t{\n\t\t\t\tthrow AssetUtilError("Unexpected AudioClip asset format.");\n\t\t\t}\n\t\t\tAssetTypeValueField* sourceField = resource->Get("m_Source");\n\t\t\tAssetTypeValueField* offsetField = resource->Get("m_Offset");\n\t\t\tAssetTypeValueField* sizeField = resource->Get("m_Size");\n\t\t\tif ((sourceField->IsDummy() || offsetField->IsDummy() || sizeField->IsDummy())\n\t\t\t\t|| stricmp(sourceField->GetType().c_str(), "string")\n\t\t\t\t|| (stricmp(offsetField->GetType().c_str(), "UInt64") && stricmp(offsetField->GetType().c_str(), "FileSize"))\n\t\t\t\t|| stricmp(sizeField->GetType().c_str(), "UInt64")\n\t\t\t\t|| stricmp(frequencyField->GetType().c_str(), "int") || stricmp(channelsField->GetType().c_str(), "int"))\n\t\t\t{\n\t\t\t\tthrow AssetUtilError("Unexpected AudioClip asset format.");\n\t\t\t}\n\n\t\t\tchar* sourceFileName = sourceField->GetValue()->AsString();\n\t\t\tQWORD soundOffset = offsetField->GetValue()->AsUInt64();\n\t\t\tQWORD soundSize = sizeField->GetValue()->AsUInt64();\n\t\t\tif (soundSize > std::numeric_limits<size_t>::max())\n\t\t\t\tthrow AssetUtilError("Resource size out of range.");\n\n\t\t\tstd::shared_ptr<ResourcesFileContextInfo> streamResourcesContextInfo;\n\t\t\tstreamResourcesContextInfo = FindResourcesFile(appContext, sourceFileName, desc.asset, progressManager);\n\t\t\t//Non-null guaranteed by FindResourcesFile (AssetUtilError thrown otherwise).\n\n\t\t\tstd::shared_ptr<IAssetsReader> pStreamReader = streamResourcesContextInfo->getResource(streamResourcesContextInfo,\n\t\t\t\tsoundOffset,\n\t\t\t\tsoundSize);\n\t\t\tif (pStreamReader == nullptr)\n\t\t\t\tthrow AssetUtilError("Unable to locate the audio resource.");\n\n\t\t\t//May consider alternatives to the proprietary FMOD API, e.g. vgmstream\'s parser\n\t\t\t//-> https://github.com/vgmstream/vgmstream/blob/master/src/meta/fsb5.c\n\n\t\t\tstd::unique_ptr<FMOD::System, decltype(closeFMODSystem)*> _pFMODSystem_raii(nullptr, closeFMODSystem);\n\n\t\t\tFMOD::System* pFMODSystem = this->pFMODSystem.get();\n\t\t\tif (!pFMODSystem)\n\t\t\t{\n\t\t\t\tif (FMOD::System_Create(&pFMODSystem) != FMOD_OK)\n\t\t\t\t\tthrow AssetUtilError("Unable to initialize FMOD.");\n\t\t\t\t_pFMODSystem_raii.reset(pFMODSystem);\n\t\t\t\t//pFMODSystem->setOutput(FMOD_OUTPUTTYPE_WAVWRITER_NRT);\n\t\t\t\t//pFMODSystem->init(16, FMOD_INIT_NORMAL, cOutFilePath);\n\t\t\t\tpFMODSystem->setOutput(FMOD_OUTPUTTYPE_NOSOUND_NRT);\n\t\t\t\tpFMODSystem->init(16, FMOD_INIT_NORMAL, NULL);\n\t\t\t}\n\t\t\tvoid* rawBuffer = NULL; unsigned int rawBufferLen = 0;\n\t\t\tstd::vector<uint8_t> soundBuffer(soundSize);\n\t\t\tif (pStreamReader->Read(0, (QWORD)soundSize, soundBuffer.data()) != soundSize)\n\t\t\t\tthrow AssetUtilError("Unable to read data from the audio resource.");\n\n\t\t\tFMOD::Sound* pSound = NULL;\n\t\t\tFMOD_CREATESOUNDEXINFO soundLenInfo;\n\t\t\tmemset(&soundLenInfo, 0, sizeof(FMOD_CREATESOUNDEXINFO));\n\t\t\tsoundLenInfo.cbsize = sizeof(FMOD_CREATESOUNDEXINFO);\n\t\t\tsoundLenInfo.length = (unsigned int)soundSize;\n\t\t\tsoundLenInfo.format = (FMOD_SOUND_FORMAT)0;\n\t\t\tsoundLenInfo.suggestedsoundtype = (FMOD_SOUND_TYPE)8;\n\t\t\tif (pFMODSystem->createSound((char*)soundBuffer.data(), FMOD_OPENMEMORY, &soundLenInfo, &pSound) == FMOD_OK)\n\t\t\t{\n\t\t\t\tauto closeFMODSound = [](FMOD::Sound* pSound)\n\t\t\t\t{\n\t\t\t\t\tpSound->release();\n\t\t\t\t};\n\t\t\t\tstd::unique_ptr<FMOD::Sound, decltype(closeFMODSound)> _pSound_raii(pSound, closeFMODSound);\n\n\t\t\t\tpSound->setMode(FMOD_LOOP_OFF);\n\t\t\t\tpSound->setLoopCount(-1);\n\t\t\t\tFMOD::Sound* pSubSound = NULL;\n\t\t\t\tif (pSound->getSubSound(0, &pSubSound) != FMOD_OK)\n\t\t\t\t\tthrow AssetUtilError("Unable to get the sub sound.");\n\n\t\t\t\tpSubSound->setMode(FMOD_LOOP_OFF);\n\t\t\t\tpSubSound->setLoopCount(-1);\n\t\t\t\t//uint32_t bitsPerSample = (uint32_t)bitsPerSampleField->GetValue()->AsInt();\n\t\t\t\t//FMOD_SOUND_FORMAT rawFormat;\n\t\t\t\t//switch (bitsPerSample)\n\t\t\t\t//{\n\t\t\t\t//... rawFormat = ...\n\t\t\t\t//}\n\t\t\t\tunsigned int sampleByteCount = 0;\n\t\t\t\tpSubSound->getLength(&sampleByteCount, FMOD_TIMEUNIT_PCMBYTES);\n\n\t\t\t\tstd::string fullOutputPath = path + ".wav";\n\t\t\t\tstd::unique_ptr<IAssetsWriter> pFileWriter(Create_AssetsWriterToFile(fullOutputPath.c_str(), true, true, RWOpenFlags_Immediately));\n\t\t\t\tif (pFileWriter == nullptr)\n\t\t\t\t\tthrow AssetUtilError("Unable to open the output file.");\n\t\t\t\tif (!wavfile_open(pFileWriter.get(), WAVFILE_SOUND_FORMAT::PCM_16bit,\n\t\t\t\t\t(uint32_t)frequencyField->GetValue()->AsInt(),\n\t\t\t\t\t(uint32_t)channelsField->GetValue()->AsInt()))\n\t\t\t\t\tthrow AssetUtilError("Unable to open the output file.");\n\n\t\t\t\tvoid* pData = NULL; unsigned int dataLen = 0;\n\t\t\t\tvoid* pData2; unsigned int dataLen2;\n\t\t\t\tpSubSound->lock(0, sampleByteCount, &pData, &pData2, &dataLen, &dataLen2);\n\t\t\t\tif (pData && dataLen)\n\t\t\t\t{\n\t\t\t\t\twavfile_write(pFileWriter.get(), pData, dataLen);\n\t\t\t\t}\n\t\t\t\tpSubSound->unlock(pData, pData2, dataLen, dataLen2);\n\t\t\t\twavfile_close(pFileWriter.get());\n\t\t\t}\n\t\t\telse if ((soundSize > 12) && !memcmp(&soundBuffer.data()[4], "ftypmp42", 8))\n\t\t\t{\n\t\t\t\tstd::string fullOutputPath = path + ".m4a";\n\t\t\t\tstd::unique_ptr<IAssetsWriter> pFileWriter(Create_AssetsWriterToFile(fullOutputPath.c_str(), true, true, RWOpenFlags_Immediately));\n\t\t\t\tif (pFileWriter == nullptr)\n\t\t\t\t\tthrow AssetUtilError("Unable to open the output file.");\n\t\t\t\tif (pFileWriter->Write(soundSize, soundBuffer.data()) != soundSize)\n\t\t\t\t\tthrow AssetUtilError("Unable to write data to the output file.");\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tthrow AssetUtilError("Unable to recognize the audio data format.");\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t\tthrow AssetUtilError("Unrecognized AudioClip asset format.");\n\t}\n};\n\nstatic bool SupportsElements(AppContext& appContext, std::vector<AssetUtilDesc>& elements)\n{\n\tauto checkAudioClass = [&appContext](AssetsFileContextInfo* pFile, int32_t classID)\n\t{\n\t\tAssetTypeTemplateField templateBase;\n\t\tif (!pFile->MakeTemplateField(&templateBase, appContext, classID))\n\t\t\treturn false;\n\t\tif (templateBase.SearchChild("m_Name")\n\t\t\t&& templateBase.SearchChild("m_Format")\n\t\t\t&& templateBase.SearchChild("m_Type")\n\t\t\t&& templateBase.SearchChild("m_Stream")\n\t\t\t&& templateBase.SearchChild("m_Type")\n\t\t\t&& templateBase.SearchChild("m_AudioData")\n\t\t\t&& templateBase.SearchChild("m_AudioData")->SearchChild("Array"))\n\t\t\treturn true; //Unity 3/4\n\t\tif (templateBase.SearchChild("m_Name")\n\t\t\t&& templateBase.SearchChild("m_BitsPerSample")\n\t\t\t&& templateBase.SearchChild("m_Frequency")\n\t\t\t&& templateBase.SearchChild("m_Channels")\n\t\t\t&& templateBase.SearchChild("m_Resource"))\n\t\t{\n\t\t\tAssetTypeTemplateField& frequencyField = *templateBase.SearchChild("m_Frequency");\n\t\t\tAssetTypeTemplateField& channelsField = *templateBase.SearchChild("m_Channels");\n\t\t\tAssetTypeTemplateField& resourceField = *templateBase.SearchChild("m_Resource");\n\t\t\tAssetTypeTemplateField* pSourceField = resourceField.SearchChild("m_Source");\n\t\t\tAssetTypeTemplateField* pOffsetField = resourceField.SearchChild("m_Offset");\n\t\t\tAssetTypeTemplateField* pSizeField = resourceField.SearchChild("m_Size");\n\t\t\tif (pSourceField\n\t\t\t\t&& !stricmp(pSourceField->type.c_str(), "string")\n\t\t\t\t&& pOffsetField\n\t\t\t\t&& (!stricmp(pOffsetField->type.c_str(), "UInt64") || !stricmp(pOffsetField->type.c_str(), "FileSize"))\n\t\t\t\t&& pSizeField\n\t\t\t\t&& !stricmp(pSizeField->type.c_str(), "UInt64")\n\t\t\t\t&& !stricmp(frequencyField.type.c_str(), "int")\n\t\t\t\t&& !stricmp(channelsField.type.c_str(), "int"))\n\t\t\t\treturn true; //Unity 5..2021+\n\t\t}\n\t\treturn false;\n\t};\n\n\tstd::unordered_map<AssetsFileContextInfo*, int32_t> audioClassIDs;\n\tfor (size_t i = 0; i < elements.size(); i++)\n\t{\n\t\tif (elements[i].asset.pFile == nullptr)\n\t\t\treturn false;\n\t\tAssetsFileContextInfo* pFile = elements[i].asset.pFile.get();\n\t\tauto classIDsit = audioClassIDs.find(pFile);\n\t\tint32_t audioClipClassID = -1;\n\t\tif (classIDsit == audioClassIDs.end())\n\t\t{\n\t\t\taudioClipClassID = pFile->GetClassByName("AudioClip");\n\t\t\taudioClassIDs[pFile] = audioClipClassID;\n\t\t\tif (!checkAudioClass(pFile, audioClipClassID))\n\t\t\t\treturn false;\n\t\t}\n\t\telse\n\t\t\taudioClipClassID = classIDsit->second;\n\t\tif (audioClipClassID == -1)\n\t\t\treturn false;\n\t\tint32_t classId = elements[i].asset.getClassID();\n\t\tif (classId != audioClipClassID)\n\t\t\treturn false;\n\t}\n\treturn true;\n}\nclass AudioClipExportProvider : public IAssetOptionProviderGeneric\n{\npublic:\n\tclass Runner : public IOptionRunner\n\t{\n\t\tAppContext& appContext;\n\t\tstd::vector<AssetUtilDesc> selection;\n\tpublic:\n\t\tRunner(AppContext& appContext, std::vector<AssetUtilDesc> _selection)\n\t\t\t: appContext(appContext), selection(std::move(_selection))\n\t\t{}\n\t\tvoid operator()()\n\t\t{\n\t\t\tstd::string exportLocation = appContext.QueryAssetExportLocation(selection, "", "*|Varying audio format:");\n\t\t\tif (!exportLocation.empty())\n\t\t\t{\n\t\t\t\tauto pTask = std::make_shared<AudioClipExportTask>(appContext, std::move(selection), std::move(exportLocation));\n\t\t\t\tappContext.taskManager.enqueue(pTask);\n\t\t\t}\n\t\t}\n\t};\n\tEAssetOptionType getType()\n\t{\n\t\treturn EAssetOptionType::Export;\n\t}\n\tstd::unique_ptr<IOptionRunner> prepareForSelection(\n\t\tclass AppContext& appContext,\n\t\tstd::vector<struct AssetUtilDesc> selection,\n\t\tstd::string& optionName)\n\t{\n\t\tif (!SupportsElements(appContext, selection))\n\t\t\treturn nullptr;\n\t\toptionName = "Export audio";\n\t\treturn std::make_unique<Runner>(appContext, std::move(selection));\n\t}\n};\n\nclass AudioClipPluginDesc : public IPluginDesc\n{\n\tstd::vector<std::shared_ptr<IOptionProvider>> pProviders;\npublic:\n\tAudioClipPluginDesc()\n\t{\n\t\tpProviders = { std::make_shared<AudioClipExportProvider>() };\n\t}\n\tstd::string getName()\n\t{\n\t\treturn "AudioClip";\n\t}\n\tstd::string getAuthor()\n\t{\n\t\treturn "";\n\t}\n\tstd::string getDescriptionText()\n\t{\n\t\treturn "Export AudioClip assets.";\n\t}\n\t//The IPluginDesc object should keep a reference to the returned options, as the caller may keep only std::weak_ptrs.\n\t//Note: May be called early, e.g. before program UI initialization.\n\tstd::vector<std::shared_ptr<IOptionProvider>> getPluginOptions(class AppContext& appContext)\n\t{\n\t\treturn pProviders;\n\t}\n};\n\nIPluginDesc* GetUABEPluginDesc1(size_t sizeof_AppContext, size_t sizeof_BundleFileContextInfo)\n{\n\tif (sizeof_AppContext != sizeof(AppContext) || sizeof_BundleFileContextInfo != sizeof(BundleFileContextInfo))\n\t{\n\t\tassert(false);\n\t\treturn nullptr;\n\t}\n\treturn new AudioClipPluginDesc();\n}\n'