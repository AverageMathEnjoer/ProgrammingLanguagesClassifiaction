b'{-# LANGUAGE CPP #-}\n#include "containers.h"\n\nmodule Data.Map.Internal.Debug where\n\nimport Data.Map.Internal (Map (..), size, delta)\nimport Control.Monad (guard)\n\n-- | \\(O(n \\log n)\\). Show the tree that implements the map. The tree is shown\n-- in a compressed, hanging format. See \'showTreeWith\'.\nshowTree :: (Show k,Show a) => Map k a -> String\nshowTree m\n  = showTreeWith showElem True False m\n  where\n    showElem k x  = show k ++ ":=" ++ show x\n\n\n{- | \\(O(n \\log n)\\). The expression (@\'showTreeWith\' showelem hang wide map@) shows\n the tree that implements the map. Elements are shown using the @showElem@ function. If @hang@ is\n \'True\', a /hanging/ tree is shown otherwise a rotated tree is shown. If\n @wide@ is \'True\', an extra wide version is shown.\n\n>  Map> let t = fromDistinctAscList [(x,()) | x <- [1..5]]\n>  Map> putStrLn $ showTreeWith (\\k x -> show (k,x)) True False t\n>  (4,())\n>  +--(2,())\n>  |  +--(1,())\n>  |  +--(3,())\n>  +--(5,())\n>\n>  Map> putStrLn $ showTreeWith (\\k x -> show (k,x)) True True t\n>  (4,())\n>  |\n>  +--(2,())\n>  |  |\n>  |  +--(1,())\n>  |  |\n>  |  +--(3,())\n>  |\n>  +--(5,())\n>\n>  Map> putStrLn $ showTreeWith (\\k x -> show (k,x)) False True t\n>  +--(5,())\n>  |\n>  (4,())\n>  |\n>  |  +--(3,())\n>  |  |\n>  +--(2,())\n>     |\n>     +--(1,())\n\n-}\nshowTreeWith :: (k -> a -> String) -> Bool -> Bool -> Map k a -> String\nshowTreeWith showelem hang wide t\n  | hang      = (showsTreeHang showelem wide [] t) ""\n  | otherwise = (showsTree showelem wide [] [] t) ""\n\nshowsTree :: (k -> a -> String) -> Bool -> [String] -> [String] -> Map k a -> ShowS\nshowsTree showelem wide lbars rbars t\n  = case t of\n      Tip -> showsBars lbars . showString "|\\n"\n      Bin _ kx x Tip Tip\n          -> showsBars lbars . showString (showelem kx x) . showString "\\n"\n      Bin _ kx x l r\n          -> showsTree showelem wide (withBar rbars) (withEmpty rbars) r .\n             showWide wide rbars .\n             showsBars lbars . showString (showelem kx x) . showString "\\n" .\n             showWide wide lbars .\n             showsTree showelem wide (withEmpty lbars) (withBar lbars) l\n\nshowsTreeHang :: (k -> a -> String) -> Bool -> [String] -> Map k a -> ShowS\nshowsTreeHang showelem wide bars t\n  = case t of\n      Tip -> showsBars bars . showString "|\\n"\n      Bin _ kx x Tip Tip\n          -> showsBars bars . showString (showelem kx x) . showString "\\n"\n      Bin _ kx x l r\n          -> showsBars bars . showString (showelem kx x) . showString "\\n" .\n             showWide wide bars .\n             showsTreeHang showelem wide (withBar bars) l .\n             showWide wide bars .\n             showsTreeHang showelem wide (withEmpty bars) r\n\nshowWide :: Bool -> [String] -> String -> String\nshowWide wide bars\n  | wide      = showString (concat (reverse bars)) . showString "|\\n"\n  | otherwise = id\n\nshowsBars :: [String] -> ShowS\nshowsBars bars\n  = case bars of\n      [] -> id\n      _ : tl -> showString (concat (reverse tl)) . showString node\n\nnode :: String\nnode           = "+--"\n\nwithBar, withEmpty :: [String] -> [String]\nwithBar bars   = "|  ":bars\nwithEmpty bars = "   ":bars\n\n{--------------------------------------------------------------------\n  Assertions\n--------------------------------------------------------------------}\n-- | \\(O(n)\\). Test if the internal map structure is valid.\n--\n-- > valid (fromAscList [(3,"b"), (5,"a")]) == True\n-- > valid (fromAscList [(5,"a"), (3,"b")]) == False\n\nvalid :: Ord k => Map k a -> Bool\nvalid t\n  = balanced t && ordered t && validsize t\n\n-- | Test if the keys are ordered correctly.\nordered :: Ord a => Map a b -> Bool\nordered t\n  = bounded (const True) (const True) t\n  where\n    bounded lo hi t\'\n      = case t\' of\n          Tip              -> True\n          Bin _ kx _ l r  -> (lo kx) && (hi kx) && bounded lo (<kx) l && bounded (>kx) hi r\n\n-- | Test if a map obeys the balance invariants.\nbalanced :: Map k a -> Bool\nbalanced t\n  = case t of\n      Tip            -> True\n      Bin _ _ _ l r  -> (size l + size r <= 1 || (size l <= delta*size r && size r <= delta*size l)) &&\n                        balanced l && balanced r\n\n-- | Test if each node of a map reports its size correctly.\nvalidsize :: Map a b -> Bool\nvalidsize t = case slowSize t of\n      Nothing -> False\n      Just _ -> True\n  where\n    slowSize Tip = Just 0\n    slowSize (Bin sz _ _ l r) = do\n            ls <- slowSize l\n            rs <- slowSize r\n            guard (sz == ls + rs + 1)\n            return sz\n'