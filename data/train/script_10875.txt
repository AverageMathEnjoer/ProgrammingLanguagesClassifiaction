b'{-# LANGUAGE PackageImports, CPP, GeneralizedNewtypeDeriving,\n             DeriveDataTypeable #-}\n\n-- | Type definition and some helpers.  This is used mainly by\n-- Direct.hs but can also be used by other modules that want access to\n-- the internals of the scheduler (i.e. the private `Par` type constructor).\n\nmodule Control.Monad.Par.Scheds.DirectInternal where\n\n#if !MIN_VERSION_base(4,6,0)\nimport Prelude hiding (catch)\n#endif\n\nimport Control.Applicative\nimport "mtl" Control.Monad.Cont as C\nimport qualified "mtl" Control.Monad.Reader as RD\nimport "mtl" Control.Monad.Trans (liftIO)\n\nimport qualified System.Random.MWC as Random\n\nimport Control.Concurrent hiding (yield)\nimport GHC.Conc\nimport Data.IORef\nimport qualified Data.Set as S\nimport Data.Word (Word64)\nimport Data.Concurrent.Deque.Class (WSDeque)\nimport Control.Monad.Fix (MonadFix (mfix))\n#if MIN_VERSION_base(4,9,0)\nimport GHC.IO.Unsafe (unsafeDupableInterleaveIO)\n#else\nimport System.IO.Unsafe (unsafeInterleaveIO)\n#endif\n\n#ifdef USE_CHASELEV\n#warning "Note: using Chase-Lev lockfree workstealing deques..."\nimport Data.Concurrent.Deque.ChaseLev.DequeInstance\nimport Data.Concurrent.Deque.ChaseLev as R\n#endif\n\nimport Data.Typeable (Typeable)\nimport Control.Exception (Exception, throwIO, BlockedIndefinitelyOnMVar (..),\n                          catch)\n\n-- Our monad stack looks like this:\n--      ---------\n--        ContT\n--       ReaderT\n--         IO\n--      ---------\n-- The ReaderT monad is there for retrieving the scheduler given the\n-- fact that the API calls do not get it as an argument.\n--\n-- Note that the result type for continuations is unit.  Forked\n-- computations return nothing.\n--\nnewtype Par a = Par { unPar :: C.ContT () ROnly a }\n    deriving (Functor, Applicative, Monad, MonadCont, RD.MonadReader Sched)\ntype ROnly = RD.ReaderT Sched IO\n\ninstance MonadFix Par where\n  mfix = fixPar\n\n-- | Take the monadic fixpoint of a \'Par\' computation. This is\n-- the definition of \'mfix\' for \'Par\'. Throws \'FixParException\'\n-- if the result is demanded strictly within the computation.\nfixPar :: (a -> Par a) -> Par a\n-- We do this IO-style, rather than ST-style, in order to get a\n-- consistent exception type. Using the ST-style mfix, a strict\n-- argument could lead us to *either* a <<loop>> exception *or*\n-- (if the wrong sort of computation gets re-run) a "multiple-put"\n-- error.\nfixPar f = Par $ ContT $ \\ar -> RD.ReaderT $ \\sched -> do\n  mv <- newEmptyMVar\n  ans <- unsafeDupableInterleaveIO (readMVar mv `catch`\n      \\ ~BlockedIndefinitelyOnMVar -> throwIO FixParException)\n  flip RD.runReaderT sched $\n    runContT (unPar (f ans)) $ \\a -> liftIO (putMVar mv a) >> ar a\n\n#if !MIN_VERSION_base(4,9,0)\nunsafeDupableInterleaveIO :: IO a -> IO a\nunsafeDupableInterleaveIO = unsafeInterleaveIO\n#endif\n\ndata FixParException = FixParException deriving (Show, Typeable)\ninstance Exception FixParException\n\ntype SessionID = Word64\n\n-- An ID along with a flag to signal completion:\ndata Session = Session SessionID (HotVar Bool)\n\ndata Sched = Sched\n    {\n      ---- Per worker ----\n      no       :: {-# UNPACK #-} !Int,\n      workpool :: WSDeque (Par ()),\n      rng      :: HotVar Random.GenIO, -- Random number gen for work stealing.\n      isMain :: Bool, -- Are we the main/master thread?\n\n      -- The stack of nested sessions that THIS worker is participating in.\n      -- When a session finishes, the worker can return to its Haskell\n      -- calling context (it\'s "real" continuation).\n      sessions :: HotVar [Session],\n      -- (1) This is always non-empty, containing at least the root\n      --     session corresponding to the anonymous system workers.\n      -- (2) The original invocation of runPar also counts as a session\n      --     and pushes a second\n      -- (3) Nested runPar invocations may push further sessions onto the stack.\n\n      ---- Global data: ----\n      idle     :: HotVar [MVar Bool], -- waiting idle workers\n      scheds   :: [Sched],            -- A global list of schedulers.\n\n      -- Any thread that enters runPar (original or nested) registers\n      -- itself in this global list.  When the list becomes null,\n      -- worker threads may shut down or at least go idle.\n      activeSessions :: HotVar (S.Set SessionID),\n\n      -- A counter to support unique session IDs:\n      sessionCounter :: HotVar SessionID\n     }\n\n\n--------------------------------------------------------------------------------\n-- Helpers #1:  Atomic Variables\n--------------------------------------------------------------------------------\n-- TEMP: Experimental\n\n#ifndef HOTVAR\n#define HOTVAR 1\n#endif\nnewHotVar      :: a -> IO (HotVar a)\nmodifyHotVar   :: HotVar a -> (a -> (a,b)) -> IO b\nmodifyHotVar_  :: HotVar a -> (a -> a) -> IO ()\nwriteHotVar    :: HotVar a -> a -> IO ()\nreadHotVar     :: HotVar a -> IO a\n-- readHotVarRaw  :: HotVar a -> m a\n-- writeHotVarRaw :: HotVar a -> m a\n\n{-# INLINE newHotVar     #-}\n{-# INLINE modifyHotVar  #-}\n{-# INLINE modifyHotVar_ #-}\n{-# INLINE readHotVar    #-}\n{-# INLINE writeHotVar   #-}\n\n\n#if HOTVAR == 1\ntype HotVar a = IORef a\nnewHotVar     = newIORef\nmodifyHotVar  = atomicModifyIORef\nmodifyHotVar_ v fn = atomicModifyIORef v (\\a -> (fn a, ()))\nreadHotVar    = readIORef\nwriteHotVar   = writeIORef\ninstance Show (IORef a) where\n  show _ref = "<ioref>"\n\nwriteHotVarRaw :: HotVar a -> a -> IO ()\n-- hotVarTransaction = id\nhotVarTransaction = error "Transactions not currently possible for IO refs"\nreadHotVarRaw :: HotVar a -> IO a\nreadHotVarRaw  = readHotVar\nwriteHotVarRaw = writeHotVar\n\n\n#elif HOTVAR == 2\n#warning "Using MVars for hot atomic variables."\n-- This uses MVars that are always full with *something*\ntype HotVar a = MVar a\nnewHotVar   x = do v <- newMVar; putMVar v x; return v\nmodifyHotVar  v fn = modifyMVar  v (return . fn)\nmodifyHotVar_ v fn = modifyMVar_ v (return . fn)\nreadHotVar    = readMVar\nwriteHotVar v x = do swapMVar v x; return ()\ninstance Show (MVar a) where\n  show _ref = "<mvar>"\n\n-- hotVarTransaction = id\n-- We could in theory do this by taking the mvar to grab the lock.\n-- But we\'d need some temporary storage....\nhotVarTransaction = error "Transactions not currently possible for MVars"\nreadHotVarRaw  = readHotVar\nwriteHotVarRaw = writeHotVar\n\n\n#elif HOTVAR == 3\n#warning "Using TVars for hot atomic variables."\n-- Simon Marlow said he saw better scaling with TVars (surprise to me):\ntype HotVar a = TVar a\nnewHotVar = newTVarIO\nmodifyHotVar  tv fn = atomically (do x <- readTVar tv\n\t\t\t\t     let (x2,b) = fn x\n\t\t\t\t     writeTVar tv x2\n\t\t\t\t     return b)\nmodifyHotVar_ tv fn = atomically (do x <- readTVar tv; writeTVar tv (fn x))\nreadHotVar x = atomically $ readTVar x\nwriteHotVar v x = atomically $ writeTVar v x\ninstance Show (TVar a) where\n  show ref = "<tvar>"\n\nhotVarTransaction = atomically\nreadHotVarRaw  = readTVar\nwriteHotVarRaw = writeTVar\n\n#endif\n'