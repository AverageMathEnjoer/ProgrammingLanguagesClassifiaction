b'using System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Text;\n\nnamespace Asn1 {\n\npublic static class AsnIO {\n\n\tpublic static byte[] FindDER(byte[] buf)\n\t{\n\t\treturn FindBER(buf, true);\n\t}\n\n\tpublic static byte[] FindBER(byte[] buf)\n\t{\n\t\treturn FindBER(buf, false);\n\t}\n\n\t/*\n\t * Find a BER/DER object in the provided buffer. If the data is\n\t * not already in the right format, conversion to string then\n\t * Base64 decoding is attempted; in the latter case, PEM headers\n\t * are detected and skipped. In any case, the returned buffer\n\t * must begin with a well-formed tag and length, corresponding to\n\t * the object length.\n\t *\n\t * If \'strictDER\' is true, then the function furthermore insists\n\t * on the object to use a defined DER length.\n\t *\n\t * The returned buffer may be the source buffer itself, or a newly\n\t * allocated buffer.\n\t *\n\t * On error, null is returned.\n\t */\n\tpublic static byte[] FindBER(byte[] buf, bool strictDER)\n\t{\n\t\tstring pemType = null;\n\t\treturn FindBER(buf, strictDER, out pemType);\n\t}\n\n\t/*\n\t * Find a BER/DER object in the provided buffer. If the data is\n\t * not already in the right format, conversion to string then\n\t * Base64 decoding is attempted; in the latter case, PEM headers\n\t * are detected and skipped. In any case, the returned buffer\n\t * must begin with a well-formed tag and length, corresponding to\n\t * the object length.\n\t *\n\t * If \'strictDER\' is true, then the function furthermore insists\n\t * on the object to use a defined DER length.\n\t *\n\t * If the source was detected to use PEM, then the object type\n\t * indicated by the PEM header is written in \'pemType\'; otherwise,\n\t * that variable is set to null.\n\t *\n\t * The returned buffer may be the source buffer itself, or a newly\n\t * allocated buffer.\n\t *\n\t * On error, null is returned.\n\t */\n\tpublic static byte[] FindBER(byte[] buf,\n\t\tbool strictDER, out string pemType)\n\t{\n\t\tpemType = null;\n\n\t\t/*\n\t\t * If it is already (from the outside) a BER object,\n\t\t * return it.\n\t\t */\n\t\tif (LooksLikeBER(buf, strictDER)) {\n\t\t\treturn buf;\n\t\t}\n\n\t\t/*\n\t\t * Convert the blob to a string. We support UTF-16 with\n\t\t * and without a BOM, UTF-8 with and without a BOM, and\n\t\t * ASCII-compatible encodings. Non-ASCII characters get\n\t\t * truncated.\n\t\t */\n\t\tif (buf.Length < 3) {\n\t\t\treturn null;\n\t\t}\n\t\tstring str = null;\n\t\tif ((buf.Length & 1) == 0) {\n\t\t\tif (buf[0] == 0xFE && buf[1] == 0xFF) {\n\t\t\t\t// Starts with big-endian UTF-16 BOM\n\t\t\t\tstr = ConvertBi(buf, 2, true);\n\t\t\t} else if (buf[0] == 0xFF && buf[1] == 0xFE) {\n\t\t\t\t// Starts with little-endian UTF-16 BOM\n\t\t\t\tstr = ConvertBi(buf, 2, false);\n\t\t\t} else if (buf[0] == 0) {\n\t\t\t\t// First byte is 0 -> big-endian UTF-16\n\t\t\t\tstr = ConvertBi(buf, 0, true);\n\t\t\t} else if (buf[1] == 0) {\n\t\t\t\t// Second byte is 0 -> little-endian UTF-16\n\t\t\t\tstr = ConvertBi(buf, 0, false);\n\t\t\t}\n\t\t}\n\t\tif (str == null) {\n\t\t\tif (buf[0] == 0xEF\n\t\t\t\t&& buf[1] == 0xBB\n\t\t\t\t&& buf[2] == 0xBF)\n\t\t\t{\n\t\t\t\t// Starts with UTF-8 BOM\n\t\t\t\tstr = ConvertMono(buf, 3);\n\t\t\t} else {\n\t\t\t\t// Assumed ASCII-compatible mono-byte encoding\n\t\t\t\tstr = ConvertMono(buf, 0);\n\t\t\t}\n\t\t}\n\t\tif (str == null) {\n\t\t\treturn null;\n\t\t}\n\n\t\t/*\n\t\t * Try to detect a PEM header and footer; if we find both\n\t\t * then we remove both, keeping only the characters that\n\t\t * occur in between.\n\t\t */\n\t\tint p = str.IndexOf("-----BEGIN ");\n\t\tint q = str.IndexOf("-----END ");\n\t\tif (p >= 0 && q >= 0) {\n\t\t\tp += 11;\n\t\t\tint r = str.IndexOf((char)10, p) + 1;\n\t\t\tint px = str.IndexOf(\'-\', p);\n\t\t\tif (px > 0 && px < r && r > 0 && r <= q) {\n\t\t\t\tpemType = string.Copy(str.Substring(p, px - p));\n\t\t\t\tstr = str.Substring(r, q - r);\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * Convert from Base64.\n\t\t */\n\t\ttry {\n\t\t\tbuf = Convert.FromBase64String(str);\n\t\t\tif (LooksLikeBER(buf, strictDER)) {\n\t\t\t\treturn buf;\n\t\t\t}\n\t\t} catch {\n\t\t\t// ignored: not Base64\n\t\t}\n\n\t\t/*\n\t\t * Decoding failed.\n\t\t */\n\t\treturn null;\n\t}\n\n\t/* =============================================================== */\n\n\t/*\n\t * Decode a tag; returned value is true on success, false otherwise.\n\t * On success, \'off\' is updated to point to the first byte after\n\t * the tag.\n\t */\n\tstatic bool DecodeTag(byte[] buf, int lim, ref int off)\n\t{\n\t\tint p = off;\n\t\tif (p >= lim) {\n\t\t\treturn false;\n\t\t}\n\t\tint v = buf[p ++];\n\t\tif ((v & 0x1F) == 0x1F) {\n\t\t\tdo {\n\t\t\t\tif (p >= lim) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tv = buf[p ++];\n\t\t\t} while ((v & 0x80) != 0);\n\t\t}\n\t\toff = p;\n\t\treturn true;\n\t}\n\n\t/*\n\t * Decode a BER length. Returned value is:\n\t *   -2   no decodable length\n\t *   -1   indefinite length\n\t *    0+  definite length\n\t * If a definite or indefinite length could be decoded, then \'off\'\n\t * is updated to point to the first byte after the length.\n\t */\n\tstatic int DecodeLength(byte[] buf, int lim, ref int off)\n\t{\n\t\tint p = off;\n\t\tif (p >= lim) {\n\t\t\treturn -2;\n\t\t}\n\t\tint v = buf[p ++];\n\t\tif (v < 0x80) {\n\t\t\toff = p;\n\t\t\treturn v;\n\t\t} else if (v == 0x80) {\n\t\t\toff = p;\n\t\t\treturn -1;\n\t\t}\n\t\tv &= 0x7F;\n\t\tif ((lim - p) < v) {\n\t\t\treturn -2;\n\t\t}\n\t\tint acc = 0;\n\t\twhile (v -- > 0) {\n\t\t\tif (acc > 0x7FFFFF) {\n\t\t\t\treturn -2;\n\t\t\t}\n\t\t\tacc = (acc << 8) + buf[p ++];\n\t\t}\n\t\toff = p;\n\t\treturn acc;\n\t}\n\n\t/*\n\t * Get the length, in bytes, of the object in the provided\n\t * buffer. The object begins at offset \'off\' but does not extend\n\t * farther than offset \'lim\'. If no such BER object can be\n\t * decoded, then -1 is returned. The returned length includes\n\t * that of the tag and length fields.\n\t */\n\tstatic int BERLength(byte[] buf, int lim, int off)\n\t{\n\t\tint orig = off;\n\t\tif (!DecodeTag(buf, lim, ref off)) {\n\t\t\treturn -1;\n\t\t}\n\t\tint len = DecodeLength(buf, lim, ref off);\n\t\tif (len >= 0) {\n\t\t\tif (len > (lim - off)) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn off + len - orig;\n\t\t} else if (len < -1) {\n\t\t\treturn -1;\n\t\t}\n\n\t\t/*\n\t\t * Indefinite length: we must do some recursive exploration.\n\t\t * End of structure is marked by a "null tag": object has\n\t\t * total length 2 and its tag byte is 0.\n\t\t */\n\t\tfor (;;) {\n\t\t\tint slen = BERLength(buf, lim, off);\n\t\t\tif (slen < 0) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\toff += slen;\n\t\t\tif (slen == 2 && buf[off] == 0) {\n\t\t\t\treturn off - orig;\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic bool LooksLikeBER(byte[] buf, bool strictDER)\n\t{\n\t\treturn LooksLikeBER(buf, 0, buf.Length, strictDER);\n\t}\n\n\tstatic bool LooksLikeBER(byte[] buf, int off, int len, bool strictDER)\n\t{\n\t\tint lim = off + len;\n\t\tint objLen = BERLength(buf, lim, off);\n\t\tif (objLen != len) {\n\t\t\treturn false;\n\t\t}\n\t\tif (strictDER) {\n\t\t\tDecodeTag(buf, lim, ref off);\n\t\t\treturn DecodeLength(buf, lim, ref off) >= 0;\n\t\t} else {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tstatic string ConvertMono(byte[] buf, int off)\n\t{\n\t\tint len = buf.Length - off;\n\t\tchar[] tc = new char[len];\n\t\tfor (int i = 0; i < len; i ++) {\n\t\t\tint v = buf[off + i];\n\t\t\tif (v < 1 || v > 126) {\n\t\t\t\tv = \'?\';\n\t\t\t}\n\t\t\ttc[i] = (char)v;\n\t\t}\n\t\treturn new string(tc);\n\t}\n\n\tstatic string ConvertBi(byte[] buf, int off, bool be)\n\t{\n\t\tint len = buf.Length - off;\n\t\tif ((len & 1) != 0) {\n\t\t\treturn null;\n\t\t}\n\t\tlen >>= 1;\n\t\tchar[] tc = new char[len];\n\t\tfor (int i = 0; i < len; i ++) {\n\t\t\tint b0 = buf[off + (i << 1) + 0];\n\t\t\tint b1 = buf[off + (i << 1) + 1];\n\t\t\tint v = be ? ((b0 << 8) + b1) : (b0 + (b1 << 8));\n\t\t\tif (v < 1 || v > 126) {\n\t\t\t\tv = \'?\';\n\t\t\t}\n\t\t\ttc[i] = (char)v;\n\t\t}\n\t\treturn new string(tc);\n\t}\n}\n\n}\n'