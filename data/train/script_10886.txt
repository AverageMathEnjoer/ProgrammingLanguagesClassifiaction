b'{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{-# LANGUAGE UndecidableInstances #-}\n{-# LANGUAGE CPP #-}\n\n-- | Postgres extensions are run-time loadable plugins that can extend Postgres\n-- functionality. Extensions are part of the database schema.\n--\n-- Beam fully supports including Postgres extensions in Beam databases. The\n-- \'PgExtensionEntity\' type constructor can be used to declare the existence of\n-- the extension in a particular backend. @beam-postgres@ provides predicates\n-- and checks for @beam-migrate@ which allow extensions to be included as\n-- regular parts of beam migrations.\nmodule Database.Beam.Postgres.Extensions where\n\nimport           Database.Beam\nimport           Database.Beam.Schema.Tables\n\nimport           Database.Beam.Postgres.Types\nimport           Database.Beam.Postgres.Syntax\n\nimport           Database.Beam.Migrate\n\nimport           Control.Monad\n\nimport           Data.Aeson\nimport qualified Data.HashSet as HS\nimport           Data.Hashable (Hashable)\nimport           Data.Proxy\nimport           Data.Text (Text)\n#if !MIN_VERSION_base(4, 11, 0)\nimport           Data.Semigroup\n#endif\n\n-- *** Embedding extensions in databases\n\n-- | Represents an extension in a database.\n--\n-- For example, to include the "Database.Beam.Postgres.PgCrypto" extension in a\n-- database,\n--\n-- @\n-- import Database.Beam.Postgres.PgCrypto\n--\n-- data MyDatabase entity\n--     = MyDatabase\n--     { _table1 :: entity (TableEntity Table1)\n--     , _cryptoExtension :: entity (PgExtensionEntity PgCrypto)\n--     }\n--\n-- migratableDbSettings :: CheckedDatabaseSettings Postgres MyDatabase\n-- migratableDbSettings = defaultMigratableDbSettings\n--\n-- dbSettings :: DatabaseSettings Postgres MyDatabase\n-- dbSettings = unCheckDatabase migratableDbSettings\n-- @\n--\n-- Note that our database now only works in the \'Postgres\' backend.\n--\n-- Extensions are implemented as records of functions and values that expose\n-- extension functionality. For example, the @pgcrypto@ extension (implemented\n-- by \'PgCrypto\') provides cryptographic functions. Thus, \'PgCrypto\' is a record\n-- of functions over \'QGenExpr\' which wrap the underlying postgres\n-- functionality.\n--\n-- You get access to these functions by retrieving them from the entity in the\n-- database.\n--\n-- For example, to use the @pgcrypto@ extension in the database above:\n--\n-- @\n-- let PgCrypto { pgCryptoDigestText = digestText\n--              , pgCryptoCrypt = crypt } = getPgExtension (_cryptoExtension dbSettings)\n-- in fmap_ (\\tbl -> (tbl, crypt (_field1 tbl) (_salt tbl))) (all_ (table1 dbSettings))\n-- @\n--\n-- To implement your own extension, create a record type, and implement the\n-- \'IsPgExtension\' type class.\ndata PgExtensionEntity extension\n\n-- | Type class implemented by any Postgresql extension\nclass IsPgExtension extension where\n  -- | Return the name of this extension. This should be the string that is\n  -- passed to @CREATE EXTENSION@. For example, \'PgCrypto\' returns @"pgcrypto"@.\n  pgExtensionName :: Proxy extension -> Text\n\n  -- | Return a value of this extension type. This should fill in all fields in\n  -- the record. For example, \'PgCrypto\' builds a record where each function\n  -- wraps the underlying Postgres one.\n  pgExtensionBuild :: extension\n\n-- | There are no fields to rename when defining entities\ninstance RenamableWithRule (FieldRenamer (DatabaseEntityDescriptor Postgres (PgExtensionEntity e))) where\n  renamingFields _ = FieldRenamer id\n\ninstance IsDatabaseEntity Postgres (PgExtensionEntity extension) where\n\n  data DatabaseEntityDescriptor Postgres (PgExtensionEntity extension) where\n    PgDatabaseExtension :: IsPgExtension extension\n                        => Text\n                        -> extension\n                        -> DatabaseEntityDescriptor Postgres (PgExtensionEntity extension)\n  type DatabaseEntityDefaultRequirements Postgres (PgExtensionEntity extension) =\n    ( IsPgExtension extension )\n  type DatabaseEntityRegularRequirements Postgres (PgExtensionEntity extension) =\n    ( IsPgExtension extension )\n\n  dbEntityName f (PgDatabaseExtension nm ext) = fmap (\\nm\' -> PgDatabaseExtension nm\' ext) (f nm)\n  dbEntitySchema _ n = pure n\n  dbEntityAuto _ = PgDatabaseExtension (pgExtensionName (Proxy @extension)) pgExtensionBuild\n\ninstance IsCheckedDatabaseEntity Postgres (PgExtensionEntity extension) where\n  newtype CheckedDatabaseEntityDescriptor Postgres (PgExtensionEntity extension) =\n    CheckedPgExtension (DatabaseEntityDescriptor Postgres (PgExtensionEntity extension))\n  type CheckedDatabaseEntityDefaultRequirements Postgres (PgExtensionEntity extension) =\n    DatabaseEntityRegularRequirements Postgres (PgExtensionEntity extension)\n\n  unChecked f (CheckedPgExtension ext) = CheckedPgExtension <$> f ext\n  collectEntityChecks (CheckedPgExtension (PgDatabaseExtension {})) =\n    [ SomeDatabasePredicate (PgHasExtension (pgExtensionName (Proxy @extension))) ]\n  checkedDbEntityAuto = CheckedPgExtension . dbEntityAuto\n\n-- | Get the extension record from a database entity. See the documentation for\n-- \'PgExtensionEntity\'.\ngetPgExtension :: DatabaseEntity Postgres db (PgExtensionEntity extension)\n               -> extension\ngetPgExtension (DatabaseEntity (PgDatabaseExtension _ ext)) = ext\n\n-- *** Migrations support for extensions\n\n-- | \'Migration\' representing the Postgres @CREATE EXTENSION@ command. Because\n-- the extension name is statically known by the extension type and\n-- \'IsPgExtension\' type class, this simply produces the checked extension\n-- entity.\n--\n-- If you need to use the extension in subsequent migration steps, use\n-- \'getPgExtension\' and \'unCheck\' to get access to the underlying\n-- \'DatabaseEntity\'.\npgCreateExtension :: forall extension db\n                   . IsPgExtension extension\n                  => Migration Postgres (CheckedDatabaseEntity Postgres db (PgExtensionEntity extension))\npgCreateExtension =\n  let entity = checkedDbEntityAuto ""\n      extName = pgExtensionName (Proxy @extension)\n  in upDown (pgCreateExtensionSyntax extName) Nothing >>\n     pure (CheckedDatabaseEntity entity (collectEntityChecks entity))\n\n-- | \'Migration\' representing the Postgres @DROP EXTENSION@. After this\n-- executes, you should expect any further uses of the extension to fail.\n-- Unfortunately, without linear types, we cannot check this.\npgDropExtension :: forall extension\n                 . CheckedDatabaseEntityDescriptor Postgres (PgExtensionEntity extension)\n                -> Migration Postgres ()\npgDropExtension (CheckedPgExtension (PgDatabaseExtension {})) =\n  upDown (pgDropExtensionSyntax (pgExtensionName (Proxy @extension))) Nothing\n\n\n-- | Postgres-specific database predicate asserting the existence of an\n-- extension in the database. The \'pgExtensionActionProvider\' properly provides\n-- @CREATE EXTENSION@ and @DROP EXTENSION@ statements to the migration finder.\nnewtype PgHasExtension = PgHasExtension Text {- Extension Name -}\n  deriving (Show, Eq, Generic, Hashable)\ninstance DatabasePredicate PgHasExtension where\n  englishDescription (PgHasExtension extName) =\n    "Postgres extension " ++ show extName ++ " is loaded"\n\n  predicateSpecificity _ = PredicateSpecificityOnlyBackend "postgres"\n  serializePredicate (PgHasExtension nm) =\n    object [ "has-postgres-extension" .= nm ]\n\npgExtensionActionProvider :: ActionProvider Postgres\npgExtensionActionProvider = pgCreateExtensionProvider <> pgDropExtensionProvider\n\npgCreateExtensionProvider, pgDropExtensionProvider :: ActionProvider Postgres\n\npgCreateExtensionProvider =\n  ActionProvider $ \\findPre findPost ->\n  do extP@(PgHasExtension ext) <- findPost\n     ensuringNot_ $\n       do PgHasExtension ext\' <- findPre\n          guard (ext == ext\')\n\n     let cmd = pgCreateExtensionSyntax ext\n     pure (PotentialAction mempty (HS.fromList [p extP])\n                           (pure (MigrationCommand cmd MigrationKeepsData))\n                           ("Load the postgres extension " <> ext) 1)\n\npgDropExtensionProvider =\n  ActionProvider $ \\findPre findPost ->\n  do extP@(PgHasExtension ext) <- findPre\n     ensuringNot_ $\n       do PgHasExtension ext\' <- findPost\n          guard (ext == ext\')\n\n     let cmd = pgDropExtensionSyntax ext\n     pure (PotentialAction (HS.fromList [p extP]) mempty\n                           (pure (MigrationCommand cmd MigrationKeepsData))\n                           ("Unload the postgres extension " <> ext) 1)\n'