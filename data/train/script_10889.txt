b'#include "stdafx.h"\n#include "resource.h"\n#include "MainWindow2.h"\n#include "Win32AppContext.h"\n#include "AssetListDialog.h"\n#include "AssetDependDialog.h"\n#include "BundleDialog.h"\n#include "FileDialog.h"\n#include "TypeDatabaseEditor.h"\n#include "TypeDbPackageEditor.h"\n#include "MonoBehaviourManager.h"\n#include "ModInstallerEditor2.h"\n#include "ModPackageLoader.h"\n#include "AddAssetDialog.h"\n#include "Win32TaskStatusTracker.h"\n#include "../libStringConverter/convert.h"\n\n#include <string>\n#include <assert.h>\n#include <Psapi.h>\n#include <mctrl.h>\n#include <WindowsX.h>\n\nIFileManipulateDialogFactory::IFileManipulateDialogFactory()\n{}\nIFileManipulateDialogFactory::~IFileManipulateDialogFactory()\n{}\n\nDefaultFileDialogFactory::DefaultFileDialogFactory(class Win32AppContext *pContext)\n\t: pContext(pContext)//, pAssetListDialog(nullptr)\n{}\n\nDefaultFileDialogFactory::~DefaultFileDialogFactory()\n{\n}\nstd::shared_ptr<IFileManipulateDialog> DefaultFileDialogFactory::construct(EFileManipulateDialogType type, HWND hParent)\n{\n\tswitch (type)\n\t{\n\tcase FileManipulateDialog_AssetList:\n\t\treturn std::make_shared<AssetListDialog>(pContext, hParent);\n\tcase FileManipulateDialog_AssetsDependencies:\n\t\treturn std::make_shared<AssetDependDialog>(pContext, hParent);\n\tcase FileManipulateDialog_Bundle:\n\t\treturn std::make_shared<BundleDialog>(pContext, hParent);\n\tdefault:\n\t\treturn nullptr;\n\t}\n}\n\n\nFileManipulateDialogInfo::FileManipulateDialogInfo()\n\t: pEntry(nullptr), hTreeItem(NULL), param(0)\n{\n\tb_isFileManipulateDialogInfo = true;\n}\nFileManipulateDialogInfo::~FileManipulateDialogInfo()\n{\n}\n\nFileEntryUIInfo::FileEntryUIInfo(MC_HTREELISTITEM hTreeItem, const std::string &fullName, bool isFilePath) :\n\t\tfailed(false), pending(true), pContextInfo(nullptr), shortNameIndex(0),\n\t\thTreeItem(hTreeItem), standardDialogsCount(0)\n{\n\tb_isFileManipulateDialogInfo = false;\n\tthis->fullName.assign(fullName);\n\tif (isFilePath)\n\t{\n\t\tconst char *fullNameC = this->fullName.c_str();\n\t\tfor (shortNameIndex = fullName.size(); shortNameIndex > 0; shortNameIndex--)\n\t\t{\n\t\t\tif (fullNameC[shortNameIndex-1] == \'/\' || fullNameC[shortNameIndex-1] == \'\\\\\')\n\t\t\t\tbreak;\n\t\t}\n\t}\n}\nFileEntryUIInfo::~FileEntryUIInfo()\n{\n\t//Note that the destructor is also called during emplace_back, i.e. after a move constructor call.\n\tif (!pending)\n\t\tsetContextInfo(std::shared_ptr<FileContextInfo>(nullptr));\n}\n\nUIDisposableCache::UIDisposableCache()\n\t: nRefs(0)\n{}\nUIDisposableCache::~UIDisposableCache()\n{}\nvoid UIDisposableCache::incRef()\n{\n\tassert(nRefs != UINT_MAX);\n\t++nRefs;\n}\nvoid UIDisposableCache::decRef()\n{\n\tassert(nRefs != 0);\n\tif (--nRefs == 0)\n\t\tdelete this;\n}\n\n\nvoid MainWindowEventHandler::onUpdateContainers(AssetsFileContextInfo *pFile)\n{}\nvoid MainWindowEventHandler::onChangeAsset(AssetsFileContextInfo *pFile, pathid_t pathID, bool wasRemoved)\n{}\nvoid MainWindowEventHandler::onUpdateDependencies(AssetsFileContextInfo *info, size_t from, size_t to)\n{}\nvoid MainWindowEventHandler::onUpdateBundleEntry(BundleFileContextInfo *pFile, size_t index)\n{}\n\nstatic const HANDLE uabeDlgProp = (HANDLE)(uintptr_t)(GetCurrentProcessId() | 0x80000000);\n\nMainWindow2::MainWindow2(HINSTANCE hInstance) :\n\tpContext(nullptr), hDlg(NULL), hMenu(NULL),\n\thInstance(hInstance),\n\thContainersDlg(NULL), activeManipDlgTab(0), hHotkeyHook(NULL),\n\tmainPanelSplitter(0.3f, 0.15f, 0.8f),\n\tfileTreeColumnRatio(0.8f), fileEntryCountersByType(),\n\tignoreTreeSelChanges(false), skipDeselectOnTabChange(false),\n\tdecompressTargetDir_cancel(false)\n{\n}\n\nbool MainWindow2::Initialize()\n{\n\tif (!pDialogFactory)\n\t\tpDialogFactory.reset(new DefaultFileDialogFactory(this->pContext));\n\tWNDCLASSEX windowClass = {};\n\twindowClass.cbSize = sizeof(windowClass);\n\tif (!GetClassInfoEx(hInstance, TEXT("msctls_progress32_dblclk"), &windowClass)\n\t\t&& GetClassInfoEx(NULL, TEXT("msctls_progress32"), &windowClass))\n\t{\n\t\twindowClass.hInstance = hInstance;\n\t\twindowClass.lpszMenuName = nullptr;\n\t\twindowClass.lpszClassName = TEXT("msctls_progress32_dblclk");\n\t\twindowClass.style |= CS_DBLCLKS;\n\t\tRegisterClassEx(&windowClass);\n\t}\n\tthis->hDlg = CreateDialogParam(hInstance, MAKEINTRESOURCE(IDD_MAIN), NULL, DlgProc, (LPARAM)this);\n\treturn (this->hDlg != NULL);\n}\nint MainWindow2::HandleMessages()\n{\n\tMSG msg = {}; \n\t//HACCEL hAccelTable;\n\t//hAccelTable = LoadAccelerators(hInstance, MAKEINTRESOURCE(IDC_ASSETBUNDLEEXTRACTOR));\n\n\twhile (GetMessage(&msg, NULL, 0, 0))\n\t{\n\t\tif (IsDialogMessage(this->hDlg, &msg))// || TranslateAccelerator(msg.hwnd, hAccelTable, &msg))\n\t\t\tcontinue;\n\t\tIFileManipulateDialog *pActiveManipDlg = this->getActiveManipDlg();\n\t\tif (pActiveManipDlg && IsDialogMessage(pActiveManipDlg->getWindowHandle(), &msg))\n\t\t\tcontinue;\n\t\tWin32TaskStatusTracker* pStatusTracker = dynamic_cast<Win32TaskStatusTracker*>(this->pStatusTracker.get());\n\t\tif (pStatusTracker && pStatusTracker->getDialog() != NULL && IsDialogMessage(pStatusTracker->getDialog(), &msg))\n\t\t\tcontinue;\n\t\t//TranslateMessage(&msg);\n\t\tDispatchMessage(&msg);\n\t}\n\tpStatusTracker.reset();\n\treturn (int)msg.wParam;\n}\n\nstatic MC_HTREELISTITEM insertEntry(HWND hTree, MC_HTREELISTITEM parent, const std::string &name)\n{\n    MC_TLINSERTSTRUCT insertStruct;\n\tinsertStruct.hParent = parent;\n\tinsertStruct.hInsertAfter = MC_TLI_LAST;\n\tinsertStruct.item.fMask = MC_TLIF_TEXT;\n\tsize_t nameLenT;\n\tTCHAR *tcText = _MultiByteToTCHAR(name.c_str(), nameLenT);\n\tinsertStruct.item.pszText = tcText;\n\tinsertStruct.item.cchTextMax = (int)(nameLenT + 1);\n\t\n    MC_HTREELISTITEM hItem = (MC_HTREELISTITEM)SendMessage(hTree, MC_TLM_INSERTITEM, 0, (LPARAM)&insertStruct);\n\t_FreeTCHAR(tcText);\n\treturn hItem;\n}\nstatic MC_HTREELISTITEM insertPendingEntry(HWND hTree, MC_HTREELISTITEM parent, const std::string &fileName)\n{\n\treturn insertEntry(hTree, parent, "Pending : " + fileName);\n}\nstatic void updateEntryInfoRef(HWND hTree, MC_HTREELISTITEM hTreeItem, ITreeParameter &info)\n{\n\tMC_TLITEM item;\n\titem.fMask = MC_TLIF_PARAM;\n\titem.lParam = (LPARAM)&info;\n\t\n\tSendMessage(hTree, MC_TLM_SETITEM, (WPARAM)hTreeItem, (LPARAM)&item);\n}\nstatic void updateEntryName(HWND hTree, MC_HTREELISTITEM hTreeItem, const std::string &newName)\n{\n\tMC_TLITEM item;\n\titem.fMask = MC_TLIF_TEXT;\n\tsize_t nameLenT;\n\tTCHAR *tcText = _MultiByteToTCHAR(newName.c_str(), nameLenT);\n\titem.pszText = tcText;\n\titem.cchTextMax = (int)(nameLenT + 1);\n\t\n\tSendMessage(hTree, MC_TLM_SETITEM, (WPARAM)hTreeItem, (LPARAM)&item);\n\n\t_FreeTCHAR(tcText);\n}\nstatic void setEntryFileID(HWND hTree, MC_HTREELISTITEM hTreeItem, unsigned int fileID)\n{\n\tTCHAR fileIDBuf[20]; fileIDBuf[19] = 0;\n\t_stprintf_s(fileIDBuf, TEXT("%u"), fileID);\n\tMC_TLSUBITEMW subitemInfo;\n\tsubitemInfo.fMask = MC_TLSIF_TEXT;\n\tsubitemInfo.iSubItem = 1;\n\tsubitemInfo.pszText = fileIDBuf;\n\tsubitemInfo.cchTextMax = sizeof(fileIDBuf) / sizeof(TCHAR);\n\tSendMessage(hTree, MC_TLM_SETSUBITEM, (WPARAM)hTreeItem, (LPARAM)&subitemInfo);\n}\nstatic ITreeParameter *getEntryParam(HWND hTree, MC_HTREELISTITEM hTreeItem)\n{\n\tMC_TLITEM item;\n\titem.fMask = MC_TLIF_PARAM;\n\titem.lParam = 0;\n\tif (!SendMessage(hTree, MC_TLM_GETITEM, (WPARAM)hTreeItem, (LPARAM)&item))\n\t\titem.lParam = 0;\n\treturn (ITreeParameter*)item.lParam;\n}\nstatic bool getEntryParam_TreeItem(ITreeParameter *pTreeParameter, MC_HTREELISTITEM &hTreeItem)\n{\n\thTreeItem = nullptr;\n\tif (pTreeParameter)\n\t{\n\t\tif (pTreeParameter->isFileEntryInfo())\n\t\t\thTreeItem = pTreeParameter->asFileEntryInfo()->hTreeItem;\n\t\telse if (pTreeParameter->isFileManipulateDialogInfo())\n\t\t\thTreeItem = pTreeParameter->asFileManipulateDialogInfo()->hTreeItem;\n\t\telse\n\t\t\treturn false;\n\t}\n\telse\n\t\treturn false;\n\treturn true;\n}\nstatic FileEntryUIInfo *getEntryParam_FileEntryInfo(ITreeParameter *pTreeParameter, bool &isPrimaryDialog)\n{\n\tif (pTreeParameter)\n\t{\n\t\tisPrimaryDialog = false;\n\t\tif (pTreeParameter->isFileEntryInfo())\n\t\t{\n\t\t\tisPrimaryDialog = true;\n\t\t\treturn pTreeParameter->asFileEntryInfo();\n\t\t}\n\t\telse if (pTreeParameter->isFileManipulateDialogInfo())\n\t\t{\n\t\t\tFileManipulateDialogInfo *pInfo = pTreeParameter->asFileManipulateDialogInfo();\n\t\t\tFileEntryUIInfo *pEntry = pInfo->pEntry;\n\t\t\tif (pInfo == &pEntry->standardDialogs[0])\n\t\t\t\tisPrimaryDialog = true;\n\t\t\treturn pEntry;\n\t\t}\n\t}\n\telse\n\t\tisPrimaryDialog = true;\n\treturn nullptr;\n}\nstatic void setHasChildren(HWND hTree, MC_HTREELISTITEM hTreeItem, bool hasChildren)\n{\n\tMC_TLITEM item;\n\titem.fMask = MC_TLIF_CHILDREN;\n\titem.cChildren = hasChildren ? 1 : 0;\n\t\n\tSendMessage(hTree, MC_TLM_SETITEM, (WPARAM)hTreeItem, (LPARAM)&item);\n}\nbool getSelectItem(HWND hTree, MC_HTREELISTITEM hTreeItem)\n{\n\tMC_TLITEM item;\n\titem.fMask = MC_TLIF_STATE;\n\titem.stateMask = TVIS_SELECTED;\n\titem.state = 0;\n\tif (SendMessage(hTree, MC_TLM_GETITEM, (WPARAM)hTreeItem, (LPARAM)&item))\n\t\treturn ((item.state & TVIS_SELECTED) != 0);\n\treturn false;\n}\nstatic void setSelectItem(HWND hTree, MC_HTREELISTITEM hTreeItem, bool select)\n{\n\tMC_TLITEM item;\n\titem.fMask = MC_TLIF_STATE;\n\titem.stateMask = TVIS_SELECTED;\n\titem.state = select ? TVIS_SELECTED : 0;\n\t\n\tSendMessage(hTree, MC_TLM_SETITEM, (WPARAM)hTreeItem, (LPARAM)&item);\n}\ninline MC_HTREELISTITEM MCTreeList_GetNextSelection(HWND hTree, MC_HTREELISTITEM curItem = NULL)\n{\n\treturn (MC_HTREELISTITEM)SendMessage(hTree, MC_TLM_GETNEXTITEM, MC_TLGN_CARET, (LPARAM)curItem);\n}\ninline MC_HTREELISTITEM MCTreeList_DeleteItem(HWND hTree, MC_HTREELISTITEM item)\n{\n\treturn (MC_HTREELISTITEM)SendMessage(hTree, MC_TLM_DELETEITEM, 0, (LPARAM)item);\n}\nstatic void DeleteFileEntry_TreeItems(HWND hTree, FileEntryUIInfo *pEntryInfo)\n{\n\t//Deleting the parent item also deletes the children.\n\tMCTreeList_DeleteItem(hTree, pEntryInfo->hTreeItem);\n}\n\nLRESULT CALLBACK MainWindow2::KeyboardHookProc(int nCode, WPARAM wParam, LPARAM lParam)\n{\n    LRESULT nResult = 1;\n    if(nCode == HC_ACTION && wParam == PM_REMOVE)\n    {\n        MSG *p = (MSG*) lParam;\n\t\tHWND hForeground = GetForegroundWindow();\n\t\tDWORD wndProcessId = 0;\n\t\tGetWindowThreadProcessId(hForeground, &wndProcessId);\n\t\tif(p->message == WM_KEYDOWN && hForeground != NULL\n\t\t\t&& GetProp(hForeground, TEXT("UABE")) == uabeDlgProp && wndProcessId == GetCurrentProcessId())\n\t\t{\n\t\t\tMainWindow2 *pThis = (MainWindow2*)GetWindowLongPtr(hForeground, GWLP_USERDATA);\n\t\t\tif (pThis->getActiveManipDlg() != nullptr)\n\t\t\t{\n\t\t\t\tPostMessage(pThis->hDlg, WM_APP+1, (DWORD)p->wParam, (LPARAM)p->message);\n\t\t\t}\n\t\t}\n    }\n    if(nCode < 0 || nResult)\n        return CallNextHookEx(NULL,nCode,wParam,lParam);\n    return nResult;\n}\nvoid MainWindow2::OnSelectClassDbDialogFinished()\n{\n\tif (!fileEntriesPendingForDbSelection.empty())\n\t{\n\t\t//Apply the user choice for the first pending file entry.\n\t\tDbSelectionQueueEntry entry = this->fileEntriesPendingForDbSelection.front();\n\t\tthis->fileEntriesPendingForDbSelection.pop_front();\n\t\tauto pClassDatabase = this->pSelectClassDbDialog->getClassDatabaseResult_Move();\n\t\tif (entry.pEntry != nullptr && pClassDatabase != nullptr)\n\t\t{\n\t\t\tAssetsFileContextInfo *pTargetEntry = dynamic_cast<AssetsFileContextInfo*>(entry.pEntry->pContextInfo.get());\n\t\t\tClassDatabaseFile_sharedptr pClassDatabaseShared(std::move(pClassDatabase));\n\t\t\tif (this->pSelectClassDbDialog->isRememberForVersion())\n\t\t\t\tthis->databaseFilesByEngineVersion[this->pSelectClassDbDialog->getEngineVersion()] = pClassDatabaseShared;\n\t\t\telse\n\t\t\t{\n\t\t\t\t//Remove old engine version defaults.\n\t\t\t\tauto databaseIt = this->databaseFilesByEngineVersion.find(this->pSelectClassDbDialog->getEngineVersion());\n\t\t\t\tif (databaseIt != this->databaseFilesByEngineVersion.end())\n\t\t\t\t\tthis->databaseFilesByEngineVersion.erase(databaseIt);\n\t\t\t}\n\t\t\tif (this->pSelectClassDbDialog->isRememberForAll())\n\t\t\t\tthis->defaultDatabaseFile = pClassDatabaseShared;\n\t\t\telse\n\t\t\t\tthis->defaultDatabaseFile.reset(); //Remove the general default.\n\t\t\tpTargetEntry->SetClassDatabase(std::move(pClassDatabaseShared));\n\t\t}\n\t}\n\tthis->pSelectClassDbDialog.reset();\n\t//Take care of the remaining file entries waiting for database selection.\n\twhile (!this->fileEntriesPendingForDbSelection.empty())\n\t{\n\t\tDbSelectionQueueEntry &entry = this->fileEntriesPendingForDbSelection.front();\n\t\tif (entry.pEntry == nullptr)\n\t\t{\n\t\t\tthis->fileEntriesPendingForDbSelection.pop_front();\n\t\t\tcontinue;\n\t\t}\n\t\tAssetsFileContextInfo *pContextInfo = dynamic_cast<AssetsFileContextInfo*>(entry.pEntry->pContextInfo.get());\n\t\tif (this->TryFindClassDatabase(pContextInfo)) //If new defaults can solve this entry, there is no need to open a dialog.\n\t\t\tthis->fileEntriesPendingForDbSelection.pop_front();\n\t\telse\n\t\t{\n\t\t\tthis->OpenClassDatabaseSelection(pContextInfo, entry.reason_DatabaseNotFound);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nvoid MainWindow2::onGCTick()\n{\n\tPROCESS_MEMORY_COUNTERS memCounters = {};\n\tmemCounters.cb = sizeof(PROCESS_MEMORY_COUNTERS);\n\tsize_t memoryToFree = this->pContext->getGCMemoryLimit() / 2;\n\tassert(memoryToFree > 0);\n\tif (GetProcessMemoryInfo(GetCurrentProcess(), &memCounters, memCounters.cb)\n\t\t&& memCounters.PagefileUsage >= this->pContext->getGCMemoryLimit()\n\t\t&& memoryToFree > 0)\n\t{\n\t\tstruct ErasableElementDesc\n\t\t{\n\t\t\tstd::list<UIDisposableCacheRef<>> *pList;\n\t\t\tstd::list<UIDisposableCacheRef<>>::iterator it;\n\t\t\ttime_t lastUseTime;\n\t\t};\n\t\tstd::vector<ErasableElementDesc> erasableElements;\n\t\tunsigned int minAge = this->pContext->getGCMinAge();\n\t\ttime_t now = time(nullptr);\n\t\tfor (auto cacheListIt = this->disposableCacheElements.begin(); \n\t\t\tcacheListIt != this->disposableCacheElements.end(); \n\t\t\t++cacheListIt)\n\t\t{\n\t\t\tfor (auto cacheElemIt = cacheListIt->second.begin();\n\t\t\t\tcacheElemIt != cacheListIt->second.end();\n\t\t\t\t++cacheElemIt)\n\t\t\t{\n\t\t\t\tif (!cacheElemIt->get()->isInUse())\n\t\t\t\t{\n\t\t\t\t\ttime_t lastUseTime = cacheElemIt->get()->getLastUseTime();\n\t\t\t\t\t//Assuming time_t is in seconds since some reference time (which is the case for POSIX and Win32)\n\t\t\t\t\tif (lastUseTime < now && now - lastUseTime >= minAge)\n\t\t\t\t\t{\n\t\t\t\t\t\tErasableElementDesc desc = {&cacheListIt->second, cacheElemIt, lastUseTime};\n\t\t\t\t\t\terasableElements.push_back(std::move(desc));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tstruct\n\t\t{\n\t\t\tbool operator()(ErasableElementDesc &a, ErasableElementDesc &b) const\n\t\t\t{   \n\t\t\t\treturn a.lastUseTime < b.lastUseTime;\n\t\t\t}   \n\t\t} useTimeComparator_Ascending;\n\t\t//Sort the erasable elements by their use time, so that the least recently used element is first.\n\t\tstd::sort(erasableElements.begin(), erasableElements.end(), useTimeComparator_Ascending);\n\t\tsize_t estimatedFreedMemory = 0;\n\t\tfor (size_t i = 0; i < erasableElements.size() && estimatedFreedMemory < memoryToFree; i++)\n\t\t{\n\t\t\testimatedFreedMemory += erasableElements[i].it->get()->approxMemory();\n\t\t\terasableElements[i].pList->erase(erasableElements[i].it);\n\t\t}\n\t}\n}\nbool askUserApplyChangeBeforeInstaller(HWND hParent);\nstatic INT_PTR CALLBACK AboutDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)\n{\n\tUNREFERENCED_PARAMETER(lParam);\n\tswitch (message)\n\t{\n\tcase WM_INITDIALOG:\n\t\treturn (INT_PTR)TRUE;\n\n\tcase WM_COMMAND:\n\t\tif (LOWORD(wParam) == IDOK || LOWORD(wParam) == IDCANCEL)\n\t\t{\n\t\t\tEndDialog(hDlg, LOWORD(wParam));\n\t\t\treturn (INT_PTR)TRUE;\n\t\t}\n\t\tbreak;\n\t}\n\treturn (INT_PTR)FALSE;\n}\nINT_PTR CALLBACK MainWindow2::DlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)\n{\n\tint wmId, wmEvent;\n\tUNREFERENCED_PARAMETER(lParam);\n\tINT_PTR ret = (INT_PTR)FALSE;\n\tMainWindow2 *pThis = (MainWindow2*)GetWindowLongPtr(hDlg, GWLP_USERDATA);\n\tif (pThis && pThis->mainPanelSplitter.handleWin32Message(hDlg, message, wParam, lParam))\n\t{\n\t\tif (pThis->mainPanelSplitter.shouldResize())\n\t\t\tpThis->onResize();\n\t\treturn (message == WM_SETCURSOR) ? (INT_PTR)TRUE : (INT_PTR)0;\n\t}\n\tswitch (message)\n\t{\n\tcase WM_APP+0: //New messages available.\n\t\tif (pThis && pThis->pContext)\n\t\t{\n\t\t\tpThis->pContext->handleMessages();\n\t\t}\n\t\tret = (INT_PTR)TRUE;\n\t\tbreak;\n\tcase WM_APP+1:\n\t\tif (pThis)\n\t\t{\n\t\t\tIFileManipulateDialog *pManipDlg = pThis->getActiveManipDlg();\n\t\t\tif (pManipDlg)\n\t\t\t\tpManipDlg->onHotkey((ULONG)lParam, (DWORD)wParam);\n\t\t}\n\t\tret = (INT_PTR)TRUE;\n\t\tbreak;\n\tcase WM_APP+2: //SelectClassDbDialog finished\n\t\tif (pThis && pThis->pSelectClassDbDialog)\n\t\t{\n\t\t\tpThis->OnSelectClassDbDialogFinished();\n\t\t}\n\t\tret = (INT_PTR)TRUE;\n\t\tbreak;\n\tcase WM_CLOSE:\n\t\t{\n\t\t\tif (pThis->onCloseProgramCommand())\n\t\t\t{\n\t\t\t\tDestroyWindow(hDlg);\n\t\t\t\tret = (INT_PTR)TRUE;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase WM_DESTROY:\n\t\t{\n\t\t\tif (pThis)\n\t\t\t{\n\t\t\t\tSetWindowLongPtr(hDlg, GWLP_USERDATA, 0);\n\t\t\t\tDestroyMenu(pThis->hMenu);\n\t\t\t\tKillTimer(hDlg, (uintptr_t)0);\n\t\t\t\tpThis->hDlg = NULL;\n\t\t\t\tpThis->hMenu = NULL;\n\n\t\t\t\tif (pThis->hContainersDlg != NULL)\n\t\t\t\t{\n\t\t\t\t\tCloseWindow(pThis->hContainersDlg);\n\t\t\t\t\tpThis->hContainersDlg = NULL;\n\t\t\t\t}\n\t\t\t\t//FreeAssetsInfo(pThis);\n\t\t\t\t//FreeMonoBehaviourClassDbs();\n\t\t\t}\n\n\t\t\tPostQuitMessage(0);\n\t\t}\n\t\tbreak;\n\tcase WM_NCDESTROY:\n\t\t{\n\t\t\tRemoveProp(hDlg, TEXT("UABE"));\n\t\t\tif (pThis)\n\t\t\t\tUnhookWindowsHookEx(pThis->hHotkeyHook);\n\t\t}\n\t\tbreak;\n\tcase WM_TIMER:\n\t\t{\n\t\t\tif (wParam == (uintptr_t)0 && pThis)\n\t\t\t{\n\t\t\t\tpThis->onGCTick();\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase WM_INITDIALOG:\n\t\t{\n\t\t\tSetWindowLongPtr(hDlg, GWLP_USERDATA, lParam);\n\t\t\tSetProp(hDlg, TEXT("UABE"), uabeDlgProp);\n\t\t\tpThis = (MainWindow2*)lParam;\n\t\t\tpThis->pStatusTracker.reset(new Win32TaskStatusTracker(*pThis->pContext, GetDlgItem(hDlg, IDC_PROGMAIN), GetDlgItem(hDlg, IDC_SPROGDESC)));\n\n\t\t\tpThis->mainPanelSplitter.setSplitterWindow(GetDlgItem(hDlg, IDC_CONTENTSEPARATE));\n\t\t\tpThis->mainPanelSplitter.handleWin32Message(hDlg, message, wParam, lParam);\n\n\t\t\tpThis->hHotkeyHook = SetWindowsHookEx(WH_GETMESSAGE, KeyboardHookProc, NULL, GetCurrentThreadId());\n\t\t\tSetWindowSubclass(GetDlgItem(hDlg, IDC_PROGMAIN), ProgSubclassProc, 0, (DWORD_PTR)pThis);\n\t\t\t\n\n\t\t\tpThis->hMenu = LoadMenu(pThis->hInstance, MAKEINTRESOURCE(IDC_MAINMENU));\n\t\t\tSetMenu(hDlg, pThis->hMenu);\n\t\t\tEnableMenuItem(pThis->hMenu, IDM_FILE_APPLY, MF_GRAYED);\n\t\t\tEnableMenuItem(pThis->hMenu, IDM_FILE_SAVE, MF_GRAYED);\n\t\t\tEnableMenuItem(pThis->hMenu, IDM_FILE_SAVEALL, MF_GRAYED);\n\n\t\t\t{\n\t\t\t\tHWND hTree = GetDlgItem(hDlg, IDC_TREEFILES);\n\t\t\t\tMC_TLCOLUMN col;\n\t\t\t\tcol.fMask = MC_TLCF_TEXT;\n\t\t\t\tcol.pszText = const_cast<TCHAR*>(_T("Files and Components"));\n\t\t\t\tcol.cchTextMax = (int)(_tcslen(col.pszText) + 1);\n\t\t\t\tSendMessage(hTree, MC_TLM_INSERTCOLUMN, 0, (LPARAM)&col);\n\t\t\t\tcol.pszText = const_cast<TCHAR*>(_T("File ID"));\n\t\t\t\tcol.cchTextMax = (int)(_tcslen(col.pszText) + 1);\n\t\t\t\tSendMessage(hTree, MC_TLM_INSERTCOLUMN, 1, (LPARAM)&col);\n\t\t\t\t//Enable child multiselect\n\t\t\t\tSendMessage(hTree, MC_TLM_SETCUSTOMSTYLE, (1 << 0), 0);\n\t\t\t}\n\t\t\t{\n\t\t\t\tHWND hTabsControl = GetDlgItem(hDlg, IDC_MANIPDLGTABS);\n\t\t\t\tMC_MTITEMWIDTH widths;\n\t\t\t\twidths.dwDefWidth = 0;\n\t\t\t\twidths.dwMinWidth = 90;\n\t\t\t\tSendMessage(hTabsControl, MC_MTM_SETITEMWIDTH, 0, (LPARAM) &widths);\n\t\t\t\tSendMessage(hTabsControl, MC_MTM_SETCUSTOMSTYLE, (WPARAM) MC_MTCS_OPENBTN, 0);\n\t\t\t}\n\n\t\t\tpThis->ignoreTreeSelChanges = false;\n\t\t\tpThis->skipDeselectOnTabChange = false;\n\t\t\t\n\t\t\tShowWindow(hDlg, SW_SHOW);\n\t\t\tPostMessage(hDlg, WM_SIZE, 0, 0);\n\t\t\t//Cache GC timer\n\t\t\tSetTimer(hDlg, (uintptr_t)0, 2000, NULL);\n\t\t\tret = (INT_PTR)TRUE;\n\t\t}\n\t\tbreak;\n\tcase WM_SIZE:\n\t\tif (pThis)\n\t\t{\n\t\t\tpThis->onResize();\n\t\t\tret = (INT_PTR)TRUE;\n\t\t}\n\t\tbreak;\n\tcase WM_GETMINMAXINFO:\n\t\t{\n\t\t\tLPMINMAXINFO pMinMax = (LPMINMAXINFO)lParam;\n\t\t\tpMinMax->ptMinTrackSize.x = 400;\n\t\t\tpMinMax->ptMinTrackSize.y = 400;\n\t\t\tret = (INT_PTR)TRUE;\n\t\t}\n\t\tbreak;\n\tcase WM_NOTIFY:\n\t\tif (pThis && pThis->pContext)\n\t\t{\n\t\t\tswitch (((NMHDR*)lParam)->code)\n\t\t\t{\n\t\t\tcase MC_TLN_SELCHANGED:\n\t\t\t\tif (((NMHDR*)lParam)->hwndFrom == GetDlgItem(hDlg, IDC_TREEFILES))\n\t\t\t\t{\n\t\t\t\t\t//Style MC_TLS_MULTISELECT makes the hItemOld/hItemNew fields meaningless, \n\t\t\t\t\t//   i.e. we need to iterate over the selection and compare with the old one manually.\n\t\t\t\t\tif (!pThis->ignoreTreeSelChanges)\n\t\t\t\t\t\tpThis->onChangeFileSelection();\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase MC_MTN_OPENITEM:\n\t\t\t\tif (((NMHDR*)lParam)->hwndFrom == GetDlgItem(hDlg, IDC_MANIPDLGTABS))\n\t\t\t\t{\n\t\t\t\t\tpThis->doOpenTab();\n\t\t\t\t\tSetWindowLongPtr(hDlg, DWLP_MSGRESULT, TRUE);\n\t\t\t\t\treturn (INT_PTR)TRUE; //Prevent tab deletion.\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase MC_MTN_CLOSEITEM:\n\t\t\t\tif (((NMHDR*)lParam)->hwndFrom == GetDlgItem(hDlg, IDC_MANIPDLGTABS))\n\t\t\t\t{\n\t\t\t\t\tMC_NMMTCLOSEITEM *pNotification = (MC_NMMTCLOSEITEM*)lParam;\n\t\t\t\t\tif (!pThis->preDeleteTab(pNotification))\n\t\t\t\t\t\tSetWindowLongPtr(hDlg, DWLP_MSGRESULT, TRUE);\n\t\t\t\t\treturn (INT_PTR)TRUE; //Prevent tab deletion.\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase MC_MTN_DELETEITEM:\n\t\t\t\tif (((NMHDR*)lParam)->hwndFrom == GetDlgItem(hDlg, IDC_MANIPDLGTABS))\n\t\t\t\t{\n\t\t\t\t\tMC_NMMTDELETEITEM *pNotification = (MC_NMMTDELETEITEM*)lParam;\n\t\t\t\t\tpThis->onDeleteTab(pNotification);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase MC_MTN_SELCHANGE:\n\t\t\t\tif (((NMHDR*)lParam)->hwndFrom == GetDlgItem(hDlg, IDC_MANIPDLGTABS))\n\t\t\t\t{\n\t\t\t\t\tMC_NMMTSELCHANGE *pNotification = (MC_NMMTSELCHANGE*)lParam;\n\t\t\t\t\tpThis->onSwitchTabs(pNotification);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase NM_RCLICK:\n\t\t\t\tif (((NMHDR*)lParam)->hwndFrom == GetDlgItem(hDlg, IDC_MANIPDLGTABS))\n\t\t\t\t{\n\t\t\t\t\t//TODO: Handle tab right click.\n\t\t\t\t\t//Use MC_MTM_HITTEST to find out which tab is being clicked.\n\t\t\t\t\t// -> MC_MTM_HITTEST expects the control client position of the mouse position (=> GetCursorPos(&pos) and ScreenToClient(((NMHDR*)lParam)->hwndFrom, &pos)).\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase MC_MTN_DELETEALLITEMS:\n\t\t\t\tif (((NMHDR*)lParam)->hwndFrom == GetDlgItem(hDlg, IDC_MANIPDLGTABS))\n\t\t\t\t{\n\t\t\t\t\tSetWindowLongPtr(hDlg, DWLP_MSGRESULT, TRUE);\n\t\t\t\t\treturn (INT_PTR)TRUE;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase WM_COMMAND:\n\t\twmId    = LOWORD(wParam);\n\t\twmEvent = HIWORD(wParam);\n\t\tif (pThis != nullptr && pThis->pContext != nullptr)\n\t\t{\n\t\t\tswitch (wmId)\n\t\t\t{\n\t\t\tcase IDM_VIEW_ADDASSET:\n\t\t\t\t{\n\t\t\t\t\tAddAssetDialog dlg(*pThis->pContext);\n\t\t\t\t\tdlg.open();\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase IDM_FILE_OPEN:\n\t\t\t\tpThis->onOpenFileCommand();\n\t\t\t\tbreak;\n\t\t\tcase IDM_FILE_CLOSE:\n\t\t\t\tpThis->onCloseFileCommand();\n\t\t\t\tbreak;\n\t\t\tcase IDM_EXIT:\n\t\t\t\tPostMessage(hDlg, WM_CLOSE, 0, 0);\n\t\t\t\tbreak;\n\t\t\tcase IDM_FILE_SAVE:\n\t\t\t\tif (IFileManipulateDialog *pActiveManipDlg = pThis->getActiveManipDlg())\n\t\t\t\t\tpActiveManipDlg->onCommand(MAKEWPARAM(IDM_FILE_APPLY,wmEvent), lParam);\n\t\t\t\tif (ManipDlgDesc *pCurTab = pThis->getActiveManipDlgDesc())\n\t\t\t\t{\n\t\t\t\t\tfor (size_t i = 0; i < pCurTab->selection.size(); i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (pCurTab->selection[i] == nullptr) continue;\n\t\t\t\t\t\tFileEntryUIInfo *pUIInfo = nullptr;\n\t\t\t\t\t\tif (pCurTab->selection[i]->isFileManipulateDialogInfo())\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tFileManipulateDialogInfo *pDlgInfo = pCurTab->selection[i]->asFileManipulateDialogInfo();\n\t\t\t\t\t\t\tpUIInfo = pDlgInfo->pEntry;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (pCurTab->selection[i]->isFileEntryInfo())\n\t\t\t\t\t\t\tpUIInfo = pCurTab->selection[i]->asFileEntryInfo();\n\t\t\t\t\t\tif (pUIInfo != nullptr)\n\t\t\t\t\t\t\tpThis->onSaveFileRequest(pUIInfo);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase IDM_FILE_SAVEALL:\n\t\t\t\t{\n\t\t\t\t\tfor (size_t iTab = 0; iTab < pThis->manipDlgTabs.size(); iTab++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (pThis->manipDlgTabs[iTab].pCurManipDlg)\n\t\t\t\t\t\t\tpThis->manipDlgTabs[iTab].pCurManipDlg->onCommand(wParam, lParam);\n\t\t\t\t\t}\n\t\t\t\t\tauto &fileEntryUIList = pThis->getFileEntries();\n\t\t\t\t\tfor (auto curIt = fileEntryUIList.begin(); curIt != fileEntryUIList.end(); ++curIt)\n\t\t\t\t\t{\n\t\t\t\t\t\tpThis->onSaveFileRequest(&*curIt);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase IDM_FILE_OPENUABESAVEFILE:\n\t\t\t\t{\n\t\t\t\t\tWin32ModPackageLoader loader(*pThis->pContext);\n\t\t\t\t\tloader.open();\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase IDM_VIEW_PROGRESS:\n\t\t\t\tif (auto pStatusTracker = dynamic_cast<Win32TaskStatusTracker*>(pThis->pStatusTracker.get()))\n\t\t\t\t\tpStatusTracker->open();\n\t\t\t\tbreak;\n\t\t\tcase IDM_MODMAKER_CREATESTANDALONE:\n\t\t\tcase IDM_MODMAKER_CREATEPACKAGE:\n\t\t\t\t{\n\t\t\t\t\t//First ask the user to apply (or not apply) changes to be visible in the installer data.\n\t\t\t\t\tbool choseApplyAllChanges = false;\n\t\t\t\t\tfor (size_t iTab = 0; iTab < pThis->manipDlgTabs.size(); iTab++)\n\t\t\t\t\t{\n\t\t\t\t\t\tManipDlgDesc& desc = pThis->manipDlgTabs[iTab];\n\t\t\t\t\t\tif (desc.pCurManipDlg && desc.pCurManipDlg->hasUnappliedChanges())\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (!choseApplyAllChanges && !askUserApplyChangeBeforeInstaller(hDlg))\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tchoseApplyAllChanges = true;\n\t\t\t\t\t\t\tdesc.pCurManipDlg->applyChanges();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tWin32ModInstallerEditor editor(*pThis->pContext, pThis->pContext->contextInfo, \n\t\t\t\t\t\t(wmId == IDM_MODMAKER_CREATESTANDALONE) ? ModDataSaveType_Installer : ModDataSaveType_PackageFile);\n\t\t\t\t\teditor.open();\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase IDM_TOOLS_EDITTYPEDATABASE:\n\t\t\t\tOpenTypeDatabaseEditor(pThis->hInstance, pThis->hDlg);\n\t\t\t\tbreak;\n\t\t\tcase IDM_TOOLS_EDITTYPEPACKAGE:\n\t\t\t\tOpenTypeDbPackageEditor(pThis->hInstance, pThis->hDlg);\n\t\t\t\tbreak;\n\t\t\tcase IDM_TOOLS_GETSCRIPTINFORMATION:\n\t\t\t\t{\n\t\t\t\t\tstd::unordered_set<unsigned int> addedFileIDs;\n\t\t\t\t\tstd::vector<std::shared_ptr<AssetsFileContextInfo>> assetsInfo;\n\t\t\t\t\t//Add all selected .assets files and their direct dependencies.\n\t\t\t\t\t//-> If a selected .assets file has a MonoBehavior,\n\t\t\t\t\t//   it may have a reference to another .assets file with the corresponding MonoScript.\n\t\t\t\t\tif (ManipDlgDesc *pCurTab = pThis->getActiveManipDlgDesc())\n\t\t\t\t\t{\n\t\t\t\t\t\tfor (size_t i = 0; i < pCurTab->selection.size(); i++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (pCurTab->selection[i] == nullptr) continue;\n\t\t\t\t\t\t\tFileEntryUIInfo *pUIInfo = nullptr;\n\t\t\t\t\t\t\tif (pCurTab->selection[i]->isFileManipulateDialogInfo())\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tFileManipulateDialogInfo *pDlgInfo = pCurTab->selection[i]->asFileManipulateDialogInfo();\n\t\t\t\t\t\t\t\tpUIInfo = pDlgInfo->pEntry;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if (pCurTab->selection[i]->isFileEntryInfo())\n\t\t\t\t\t\t\t\tpUIInfo = pCurTab->selection[i]->asFileEntryInfo();\n\t\t\t\t\t\t\t//Retrieve the context info, and try to convert it to an AssetsFileContextInfo.\n\t\t\t\t\t\t\tauto pFile = std::dynamic_pointer_cast<AssetsFileContextInfo>(pUIInfo->getContextInfo());\n\t\t\t\t\t\t\t//If this is an AssetsFileContextInfo and not inserted yet, proceed.\n\t\t\t\t\t\t\tif (pFile == nullptr || !addedFileIDs.insert(pFile->getFileID()).second) continue;\n\n\t\t\t\t\t\t\tconst std::vector<unsigned int> references = pFile->getReferences();\n\t\t\t\t\t\t\tfor (size_t i = 0; i < references.size(); ++i)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t//Same as above, but for the direct references.\n\t\t\t\t\t\t\t\tauto pFile = std::dynamic_pointer_cast<AssetsFileContextInfo>(pThis->pContext->getContextInfo(references[i]));\n\t\t\t\t\t\t\t\tif (pFile == nullptr || !addedFileIDs.insert(pFile->getFileID()).second) continue;\n\t\t\t\t\t\t\t\tassetsInfo.push_back(std::move(pFile));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tassetsInfo.push_back(std::move(pFile));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tGetAllScriptInformation(*pThis->pContext, assetsInfo);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase IDC_CKBUNDLES:\n\t\t\tcase IDC_CKASSETS:\n\t\t\tcase IDC_CKRESOURCES:\n\t\t\tcase IDC_CKGENERICS:\n\t\t\tcase IDC_CKSELALL:\n\t\t\t\tif (wmEvent == BN_CLICKED)\n\t\t\t\t\tpThis->onClickSelectionCheckbox(wmId, Button_GetCheck((HWND)lParam));\n\t\t\t\tbreak;\n\t\t\tcase IDM_HELP_ABOUT:\n\t\t\t\tDialogBox(pThis->hInstance, MAKEINTRESOURCE(IDD_ABOUTBOX), hDlg, AboutDlgProc);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t//Let the manipulate dialog handle the command first.\n\t\t\t\t//(NOTE: This should be done for any menu item that can be overridden)\n\t\t\t\tif (IFileManipulateDialog *pActiveManipDlg = pThis->getActiveManipDlg())\n\t\t\t\t\tret = (pActiveManipDlg->onCommand(wParam, lParam) ? 1 : 0);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n\treturn ret;\n}\nLRESULT CALLBACK MainWindow2::ProgSubclassProc(HWND hWnd, UINT message,\n\tWPARAM wParam, LPARAM lParam,\n\tuintptr_t uIdSubclass, DWORD_PTR dwRefData)\n{\n\tMainWindow2* pThis = (MainWindow2*)dwRefData;\n\tswitch (message)\n\t{\n\tcase WM_LBUTTONDBLCLK:\n\t\tif (auto pStatusTracker = dynamic_cast<Win32TaskStatusTracker*>(pThis->pStatusTracker.get()))\n\t\t\tpStatusTracker->open();\n\t\treturn (LRESULT)0;\n\t}\n\treturn DefSubclassProc(hWnd, message, wParam, lParam);\n}\n\ninline void doMoveWindow(HDWP &deferCtx, bool &retry, HWND hWnd, int x, int y, int w, int h)\n{\n\tif (deferCtx)\n\t{\n\t\tdeferCtx = DeferWindowPos(deferCtx, hWnd, HWND_TOP, x, y, w, h, SWP_NOACTIVATE | SWP_NOOWNERZORDER | SWP_NOZORDER);\n\t\tif (!deferCtx)\n\t\t\tretry = true;\n\t}\n\telse\n\t\tSetWindowPos(hWnd, HWND_TOP, x, y, w, h, SWP_NOACTIVATE | SWP_NOOWNERZORDER | SWP_NOZORDER);\n}\nvoid MainWindow2::doOpenTab()\n{\n\tHWND hTabsControl = GetDlgItem(hDlg, IDC_MANIPDLGTABS);\n\tsize_t newTabIdx = this->manipDlgTabs.size();\n\tthis->manipDlgTabs.emplace_back(ManipDlgDesc());\n\n\tMC_MTITEM newItem = {};\n\tnewItem.dwMask = MC_MTIF_TEXT | MC_MTIF_PARAM;\n\tTCHAR sprntTmp[36];\n\t_stprintf_s(sprntTmp, TEXT("Tab %u"), (unsigned int)this->manipDlgTabs.size()); //TODO: Proper names\n\tnewItem.pszText = sprntTmp;\n\tnewItem.lParam = (LPARAM)newTabIdx;\n\tSendMessage(hTabsControl, MC_MTM_INSERTITEM, (WPARAM)newTabIdx, (LPARAM)&newItem);\n\tSendMessage(hTabsControl, MC_MTM_SETCURSEL, (WPARAM)newTabIdx, 0); //Also sends a SELCHANGE notification.\n}\nbool MainWindow2::preDeleteTab(MC_NMMTCLOSEITEM *pNotification)\n{\n\tHWND hTabsControl = pNotification->hdr.hwndFrom;\n\tif (pNotification->iItem >= 0 && pNotification->iItem < this->manipDlgTabs.size())\n\t{\n\t\tMC_MTITEM itemInfo = {};\n\t\titemInfo.dwMask = MC_MTIF_PARAM;\n\t\t//Retrieve the index of the tab in pThis->manipDlgTabs.\n\t\tSendMessage(hTabsControl, MC_MTM_GETITEM, (WPARAM)pNotification->iItem, (LPARAM)&itemInfo);\n\t\tsize_t internalItemIdx = (size_t)itemInfo.lParam;\n\t\tassert(internalItemIdx < this->manipDlgTabs.size());\n\n\t\tif (internalItemIdx < this->manipDlgTabs.size() && this->manipDlgTabs[internalItemIdx].pCurManipDlg != nullptr)\n\t\t{\n\t\t\tIFileManipulateDialog *pDialog = this->manipDlgTabs[internalItemIdx].pCurManipDlg.get();\n\t\t\tbool changesApplyable = false;\n\t\t\tif (pDialog->hasUnappliedChanges(&changesApplyable))\n\t\t\t{\n\t\t\t\tSendMessage(hTabsControl, MC_MTM_SETCURSEL, (WPARAM)pNotification->iItem, 0);\n\t\t\t\tif (changesApplyable)\n\t\t\t\t{\n\t\t\t\t\tswitch (MessageBox(this->hDlg, \n\t\t\t\t\t\tTEXT("This tab has unsaved changes.\\nDo you want to apply the changes before closing the tab?"), \n\t\t\t\t\t\tTEXT("Asset Bundle Extractor"), \n\t\t\t\t\t\tMB_YESNOCANCEL | MB_ICONWARNING | MB_DEFBUTTON3))\n\t\t\t\t\t{\n\t\t\t\t\tcase IDYES:\n\t\t\t\t\t\tif (pDialog->applyChanges())\n\t\t\t\t\t\t\treturn true; //Close tab (changes applied).\n\t\t\t\t\t\treturn false; //Don\'t close tab (changes not applied).\n\t\t\t\t\tcase IDNO:\n\t\t\t\t\t\treturn true; //Close tab without saving.\n\t\t\t\t\tcase IDCANCEL:\n\t\t\t\t\t\treturn false; //Don\'t close tab.\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (IDYES == MessageBox(this->hDlg, \n\t\t\t\t\tTEXT("This tab has unsaved changes.\\nDo you want to close the tab anyway and discard any unsaved changes?"), \n\t\t\t\t\tTEXT("Asset Bundle Extractor"), \n\t\t\t\t\tMB_YESNO | MB_ICONWARNING | MB_DEFBUTTON2))\n\t\t\t\t{\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t\tassert(false);\n\treturn true;\n}\nvoid MainWindow2::onDeleteTab(MC_NMMTDELETEITEM *pNotification)\n{\n\tHWND hTabsControl = pNotification->hdr.hwndFrom;\n\tif (pNotification->iItem >= 0 && pNotification->iItem < this->manipDlgTabs.size())\n\t{\n\t\tMC_MTITEM itemInfo = {};\n\t\titemInfo.dwMask = MC_MTIF_PARAM;\n\t\t//Retrieve the index of the tab in pThis->manipDlgTabs.\n\t\tSendMessage(hTabsControl, MC_MTM_GETITEM, (WPARAM)pNotification->iItem, (LPARAM)&itemInfo);\n\t\tsize_t internalItemIdx = (size_t)itemInfo.lParam;\n\t\tassert(internalItemIdx < this->manipDlgTabs.size());\n\t\t//Fix the pThis->manipDlgTabs indices in the tab control user data to account for pThis->manipDlgTabs.erase(...).\n\t\tfor (size_t i = 0; i < this->manipDlgTabs.size(); i++)\n\t\t{\n\t\t\tif (i == pNotification->iItem)\n\t\t\t\tcontinue;\n\t\t\titemInfo.dwMask = MC_MTIF_PARAM;\n\t\t\tif (SendMessage(hTabsControl, MC_MTM_GETITEM, (WPARAM)i, (LPARAM)&itemInfo)\n\t\t\t\t&& ((size_t)itemInfo.lParam) > internalItemIdx)\n\t\t\t{\n\t\t\t\titemInfo.dwMask = MC_MTIF_PARAM;\n\t\t\t\titemInfo.lParam--;\n\t\t\t\tSendMessage(hTabsControl, MC_MTM_SETITEM, (WPARAM)i, (LPARAM)&itemInfo);\n\t\t\t}\n\t\t}\n\t\tif (internalItemIdx == this->activeManipDlgTab)\n\t\t{\n\t\t\t//If there are at least two tabs, another tab should be selected by mCtrl at this point.\n\t\t\tassert(this->manipDlgTabs.size() == 1);\n\t\t\tif (this->activeManipDlgTab == internalItemIdx\n\t\t\t\t&& this->manipDlgTabs[internalItemIdx].pCurManipDlg != nullptr)\n\t\t\t{\n\t\t\t\tthis->manipDlgTabs[internalItemIdx].pCurManipDlg->onHide(); //Hide the tab if necessary.\n\t\t\t\tInvalidateRect(hDlg, NULL, TRUE); //TODO: Redraw only the manipulate dialog area.\n\t\t\t}\n\t\t}\n\t\tthis->manipDlgTabs.erase(this->manipDlgTabs.begin() + internalItemIdx);\n\t\tif (this->activeManipDlgTab > internalItemIdx)\n\t\t{\n\t\t\tthis->activeManipDlgTab--;\n\t\t\t//The active tab must still be in range if there is at least one item.\n\t\t\tassert(this->activeManipDlgTab >= 0);\n\t\t\tassert(this->manipDlgTabs.empty() || this->activeManipDlgTab < this->manipDlgTabs.size());\n\t\t}\n\t}\n\telse\n\t\tassert(false);\n}\nvoid MainWindow2::onSwitchTabs(MC_NMMTSELCHANGE *pNotification)\n{\n\t//Handle tab selection change.\n\tHWND hTree = GetDlgItem(hDlg, IDC_TREEFILES);\n\tHWND hTabsControl = pNotification->hdr.hwndFrom;\n\tassert(pNotification->iItemNew != pNotification->iItemOld);\n\tbool redraw = false;\n\t//Deselect the old tab. \n\tif (pNotification->iItemOld >= 0 && pNotification->iItemOld < this->manipDlgTabs.size())\n\t{\n\t\tMC_MTITEM itemInfo = {};\n\t\titemInfo.dwMask = MC_MTIF_PARAM;\n\t\t//Retrieve the index of the tab in pThis->manipDlgTabs.\n\t\tSendMessage(hTabsControl, MC_MTM_GETITEM, (WPARAM)pNotification->iItemOld, (LPARAM)&itemInfo);\n\t\tsize_t internalOldItemIdx = (size_t)itemInfo.lParam;\n\t\tassert(internalOldItemIdx < this->manipDlgTabs.size());\n\n\t\tManipDlgDesc *pOldTabDesc = &this->manipDlgTabs[internalOldItemIdx]; //this->getActiveManipDlgDesc();\n\t\tif (pOldTabDesc)\n\t\t{\n\t\t\tif (pOldTabDesc->pCurManipDlg)\n\t\t\t{\n\t\t\t\tpOldTabDesc->pCurManipDlg->onHide();\n\t\t\t\tInvalidateRect(hDlg, NULL, TRUE); //TODO: Redraw only the manipulate dialog area.\n\t\t\t\tredraw = true;\n\t\t\t}\n\t\t\tif (!this->skipDeselectOnTabChange)\n\t\t\t{\n\t\t\t\tassert(internalOldItemIdx == this->activeManipDlgTab);\n\t\t\t\t//Undo the file selections in the tree list.\n\t\t\t\tthis->ignoreTreeSelChanges = true;\n\t\t\t\tfor (size_t i = 0; i < pOldTabDesc->selection.size(); i++)\n\t\t\t\t{\n\t\t\t\t\tMC_HTREELISTITEM hTreeItem;\n\t\t\t\t\tif (getEntryParam_TreeItem(pOldTabDesc->selection[i], hTreeItem))\n\t\t\t\t\t\tsetSelectItem(hTree, hTreeItem, false);\n\t\t\t\t}\n\t\t\t\tthis->ignoreTreeSelChanges = false;\n\t\t\t\tthis->activeManipDlgTab = SIZE_MAX; //Deselect\n\t\t\t\tstd::vector<ITreeParameter*> emptySelection;\n\t\t\t\tthis->doUpdateSelectionCheckboxes(emptySelection);\n\t\t\t}\n\t\t}\n\t}\n\t//Select the new tab.\n\tif (pNotification->iItemNew >= 0 && pNotification->iItemNew < this->manipDlgTabs.size())\n\t{\n\t\tMC_MTITEM itemInfo = {};\n\t\titemInfo.dwMask = MC_MTIF_PARAM;\n\t\t//Retrieve the index of the tab in pThis->manipDlgTabs.\n\t\tSendMessage(hTabsControl, MC_MTM_GETITEM, (WPARAM)pNotification->iItemNew, (LPARAM)&itemInfo);\n\t\tsize_t internalNewItemIdx = (size_t)itemInfo.lParam;\n\t\tassert(internalNewItemIdx < this->manipDlgTabs.size());\n\n\t\tthis->activeManipDlgTab = internalNewItemIdx; //Select\n\t\tManipDlgDesc *pNewTabDesc = this->getActiveManipDlgDesc();\n\t\tif (!this->skipDeselectOnTabChange)\n\t\t{\n\t\t\t//Redo the file selections in the tree list.\n\t\t\tthis->ignoreTreeSelChanges = true;\n\t\t\tfor (size_t i = 0; i < pNewTabDesc->selection.size(); i++)\n\t\t\t{\n\t\t\t\tMC_HTREELISTITEM hTreeItem;\n\t\t\t\tif (getEntryParam_TreeItem(pNewTabDesc->selection[i], hTreeItem))\n\t\t\t\t\tsetSelectItem(hTree, hTreeItem, true);\n\t\t\t}\n\t\t\tthis->ignoreTreeSelChanges = false;\n\t\t}\n\t\tif (pNewTabDesc->pCurManipDlg)\n\t\t{\n\t\t\tpNewTabDesc->pCurManipDlg->onShow();\n\t\t\tthis->onResize();\n\t\t\tredraw = true;\n\t\t}\n\t\tif (!this->skipDeselectOnTabChange)\n\t\t\tthis->doUpdateSelectionCheckboxes(pNewTabDesc->selection);\n\t}\n\tif (redraw)\n\t\tInvalidateRect(hDlg, NULL, TRUE); //TODO: Redraw only the manipulate dialog area.\n}\nvoid MainWindow2::onResize(bool defer)\n{\n\tRECT client = {};\n\tGetClientRect(hDlg, &client);\n\tlong width = client.right-client.left;\n\tlong height = client.bottom-client.top;\n\n\tHDWP deferCtx = defer ? BeginDeferWindowPos(11) : NULL;\n\tbool retry = false;\n\n\tlong fontHeight = 16;\n\tlong bottomPanelHeight = 25;\n\tlong bottomPanelTop = height - bottomPanelHeight;\n\tlong bottomLeftPanelLeft = 7;\n\tlong bottomLeftPanelWidth = std::min<long>((width - bottomLeftPanelLeft) / 3, 125);\n\tlong bottomRightPanelLeft = bottomLeftPanelWidth + 7;\n\tlong bottomRightPanelWidth = width - bottomRightPanelLeft - 7;\n\tdoMoveWindow(deferCtx, retry, GetDlgItem(hDlg, IDC_PROGSEPARATE), -2, bottomPanelTop, 2 + bottomLeftPanelLeft + bottomLeftPanelWidth, bottomPanelHeight);\n\tdoMoveWindow(deferCtx, retry, GetDlgItem(hDlg, IDC_PROGMAIN), bottomLeftPanelLeft, bottomPanelTop + 3, bottomLeftPanelWidth - 7, bottomPanelHeight - 6);\n\tdoMoveWindow(deferCtx, retry, GetDlgItem(hDlg, IDC_PROGSEPARATE2), bottomRightPanelLeft, bottomPanelTop, (width + 2) - bottomRightPanelLeft, bottomPanelHeight);\n\tdoMoveWindow(deferCtx, retry, GetDlgItem(hDlg, IDC_SPROGDESC), bottomRightPanelLeft + 3, bottomPanelTop + 4, bottomRightPanelWidth - 3, fontHeight);\n\t\n\tlong leftPanelTop = 4;\n\tlong leftPanelLeft = 7;\n\tlong leftPanelWidth = (long)(width * this->mainPanelSplitter.getLeftOrTopPanelRatio() - leftPanelLeft);\n\tlong leftPanelClientWidth = leftPanelWidth - 5;\n\tlong panelHeight = height - bottomPanelHeight;\n\t{\n\t\tlong curCheckboxLeft = leftPanelLeft;\n\t\tstatic const long checkboxHeight = 16;\n\t\tstatic const long ckBundlesWidth = 60;\n\t\tstatic const long ckAssetsWidth = 60;\n\t\tstatic const long ckResourcesWidth = 76;\n\t\tstatic const long ckGenericsWidth = 60;\n\n\t\tstatic const long ckSelAllWidth = 60;\n\n\t\tdoMoveWindow(deferCtx, retry, GetDlgItem(hDlg, IDC_CKBUNDLES), curCheckboxLeft, leftPanelTop, std::min<long>(ckBundlesWidth, leftPanelClientWidth - curCheckboxLeft), checkboxHeight);\n\t\tcurCheckboxLeft += ckBundlesWidth;\n\t\tif ((curCheckboxLeft + ckAssetsWidth) > leftPanelClientWidth && curCheckboxLeft > leftPanelLeft)\n\t\t{\n\t\t\tleftPanelTop += checkboxHeight + 4;\n\t\t\tcurCheckboxLeft = leftPanelLeft;\n\t\t}\n\t\tdoMoveWindow(deferCtx, retry, GetDlgItem(hDlg, IDC_CKASSETS), curCheckboxLeft, leftPanelTop, std::min<long>(ckAssetsWidth, leftPanelClientWidth - curCheckboxLeft), checkboxHeight);\n\t\tcurCheckboxLeft += ckAssetsWidth;\n\t\tif ((curCheckboxLeft + ckResourcesWidth) > leftPanelClientWidth && curCheckboxLeft > leftPanelLeft)\n\t\t{\n\t\t\tleftPanelTop += checkboxHeight + 4;\n\t\t\tcurCheckboxLeft = leftPanelLeft;\n\t\t}\n\t\tdoMoveWindow(deferCtx, retry, GetDlgItem(hDlg, IDC_CKRESOURCES), curCheckboxLeft, leftPanelTop, std::min<long>(ckResourcesWidth, leftPanelClientWidth - curCheckboxLeft), checkboxHeight);\n\t\tcurCheckboxLeft += ckResourcesWidth;\n\t\tif ((curCheckboxLeft + ckGenericsWidth) > leftPanelClientWidth && curCheckboxLeft > leftPanelLeft)\n\t\t{\n\t\t\tleftPanelTop += checkboxHeight + 4;\n\t\t\tcurCheckboxLeft = leftPanelLeft;\n\t\t}\n\n\t\tdoMoveWindow(deferCtx, retry, GetDlgItem(hDlg, IDC_CKGENERICS), curCheckboxLeft, leftPanelTop, std::min<long>(ckGenericsWidth, leftPanelClientWidth - curCheckboxLeft), checkboxHeight);\n\t\tleftPanelTop += checkboxHeight + 4;\n\t\tcurCheckboxLeft = leftPanelLeft;\n\n\t\tdoMoveWindow(deferCtx, retry, GetDlgItem(hDlg, IDC_CKSELALL), curCheckboxLeft, leftPanelTop, std::min<long>(ckSelAllWidth, leftPanelClientWidth - curCheckboxLeft), checkboxHeight);\n\t\tleftPanelTop += checkboxHeight + 4;\n\t}\n\t\n\tHWND hTree = GetDlgItem(hDlg, IDC_TREEFILES);\n\t{\n\t\t//Calculate relative column sizes for the file tree list.\n\t\tMC_TLCOLUMN col;\n\t\tcol.fMask = MC_TLCF_WIDTH;\n\t\tcol.cx = 1;\n\t\tSendMessage(hTree, MC_TLM_GETCOLUMN, 0, (LPARAM)&col);\n\t\tint cxTree = col.cx;\n\t\tcol.fMask = MC_TLCF_WIDTH;\n\t\tcol.cx = 1;\n\t\tSendMessage(hTree, MC_TLM_GETCOLUMN, 1, (LPARAM)&col);\n\t\tint cxFileID = col.cx;\n\t\tRECT treeClientRect = {};\n\t\tGetClientRect(hTree, &treeClientRect);\n\t\tLONG actualWidth = treeClientRect.right - treeClientRect.left - 1;\n\t\tint totalWidth = cxTree + cxFileID;\n\t\tif (cxTree > 0 && cxFileID > 0 && actualWidth > 0)\n\t\t{\n\t\t\tcxTree = (int)(cxTree * ((float)totalWidth / (float)actualWidth));\n\t\t\tcxFileID = (int)(cxFileID * ((float)totalWidth / (float)actualWidth));\n\t\t\tthis->fileTreeColumnRatio = (float)cxTree / (float)actualWidth;\n\t\t\tif (this->fileTreeColumnRatio < 0.75f) this->fileTreeColumnRatio = 0.75f;\n\t\t\telse if (this->fileTreeColumnRatio > 0.95f) this->fileTreeColumnRatio = 0.95f;\n\t\t}\n\t}\n\tlong leftPanelHeight = (bottomPanelTop - 4) - leftPanelTop;\n\tdoMoveWindow(deferCtx, retry, hTree, leftPanelLeft, leftPanelTop, leftPanelClientWidth, leftPanelHeight);\n\n\tlong contentPanelLeft = leftPanelLeft + leftPanelWidth, contentPanelTop = 10;\n\tlong contentPanelWidth = width - contentPanelLeft;\n\tlong contentPanelHeight = panelHeight - 20;\n\tdoMoveWindow(deferCtx, retry, GetDlgItem(hDlg, IDC_CONTENTSEPARATE), contentPanelLeft, -2, contentPanelWidth + 2, panelHeight + 2);\n\t\n\tHWND hTabsControl = GetDlgItem(hDlg, IDC_MANIPDLGTABS);\n\tlong tabsControlBottom = std::min<int>(24, panelHeight);\n\tdoMoveWindow(deferCtx, retry, hTabsControl, contentPanelLeft + 1, 0, contentPanelWidth, tabsControlBottom - 0);\n\n\tif (defer)\n\t{\n\t\tif (retry || !EndDeferWindowPos(deferCtx))\n\t\t\tonResize(false);\n\t\tdeferCtx = NULL;\n\t}\n\t//For some reason, using the deferred method for the child dialog silently makes no window resize.\n\tif (IFileManipulateDialog *pCurManipDlg = this->getActiveManipDlg())\n\t{\n\t\t//GetWindowRect(hTabsControl, &tabsRect);\n\t\tRECT tabsRect = {};\n\t\ttabsRect.left = 0; tabsRect.right = contentPanelWidth;\n\t\ttabsRect.top = tabsControlBottom + 1; tabsRect.bottom = panelHeight;\n\t\t//TabCtrl_AdjustRect(hTabsControl, FALSE, &tabsRect);\n\t\tMoveWindow(pCurManipDlg->getWindowHandle(), \n\t\t\ttabsRect.left,\t\t\t\t\ttabsRect.top, \n\t\t\ttabsRect.right-tabsRect.left,\ttabsRect.bottom-tabsRect.top, TRUE);\n\t}\n\t\n\tUpdateWindow(hDlg);\n\t//InvalidateRect(GetDlgItem(hDlg, IDC_PROGMAIN), NULL, TRUE);\n\t//InvalidateRect(GetDlgItem(hDlg, IDC_SPROGDESC), NULL, TRUE);\n\t//InvalidateRect(GetDlgItem(hDlg, IDC_TREEFILES), NULL, TRUE);\n\t//InvalidateRect(hDlg, NULL, TRUE);\n\n\t//Resize the file tree control\'s main column.\n\tRECT treeClientRect = {};\n\tGetClientRect(hTree, &treeClientRect);\n\tMC_TLCOLUMN col;\n\tcol.fMask = MC_TLCF_WIDTH;\n\tcol.cx = (int)((treeClientRect.right - treeClientRect.left - 1) * fileTreeColumnRatio);\n\tSendMessage(hTree, MC_TLM_SETCOLUMN, 0, (LPARAM)&col);\n\tcol.cx = (int)((treeClientRect.right - treeClientRect.left - 1) * (1.0 - fileTreeColumnRatio));\n\tSendMessage(hTree, MC_TLM_SETCOLUMN, 1, (LPARAM)&col);\n}\ninline bool manipDlgIsCompatibleWith(IFileManipulateDialog *pDialog, ITreeParameter *newItem)\n{\n\tbool tmp;\n\tFileEntryUIInfo *pNewFileEntryInfo = getEntryParam_FileEntryInfo(newItem, tmp);\n\treturn (pNewFileEntryInfo\n\t\t&& newItem->isFileManipulateDialogInfo()\n\t\t&& newItem->asFileManipulateDialogInfo()->type == pDialog->getType());\n}\n\ninline bool getSelectionType(ITreeParameter *pSel, EFileContextType &type, bool onlyPrimaryDialogOrFileEntry)\n{\n\ttype = FileContext_COUNT;\n\tbool tmp;\n\tif (FileEntryUIInfo *pSelFileEntryInfo = getEntryParam_FileEntryInfo(pSel, tmp))\n\t{\n\t\tif (!pSelFileEntryInfo->pending && pSelFileEntryInfo->pContextInfo\n\t\t\t&& pSelFileEntryInfo->pContextInfo->getFileContext()\n\t\t\t&& (!onlyPrimaryDialogOrFileEntry ||\n\t\t\t\tpSelFileEntryInfo->standardDialogsCount <= 0 ||\n\t\t\t\t&pSelFileEntryInfo->standardDialogs[0] == pSel))\n\t\t{\n\t\t\ttype = pSelFileEntryInfo->pContextInfo->getFileContext()->getType();\n\t\t\tif (type < (EFileContextType)0 || type >= FileContext_COUNT)\n\t\t\t\treturn false;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\nvoid MainWindow2::onClickSelectionCheckbox(unsigned int checkboxID, int checkState)\n{\n\tHWND hTree = GetDlgItem(this->hDlg, IDC_TREEFILES);\n\n\tEFileContextType fileContextType;\n\tswitch (checkboxID)\n\t{\n\tcase IDC_CKBUNDLES:\n\t\tfileContextType = FileContext_Bundle;\n\t\tbreak;\n\tcase IDC_CKASSETS:\n\t\tfileContextType = FileContext_Assets;\n\t\tbreak;\n\tcase IDC_CKRESOURCES:\n\t\tfileContextType = FileContext_Resources;\n\t\tbreak;\n\tcase IDC_CKGENERICS:\n\t\tfileContextType = FileContext_Generic;\n\t\tbreak;\n\tcase IDC_CKSELALL:\n\t\t{\n\t\t\tthis->ignoreTreeSelChanges = true;\n\t\t\tif (checkState == BST_CHECKED)\n\t\t\t{\n\t\t\t\tfor (auto fileIt = fileEntries.begin(); fileIt != fileEntries.end(); ++fileIt)\n\t\t\t\t{\n\t\t\t\t\tif (fileIt->hTreeItem)\n\t\t\t\t\t\tsetSelectItem(hTree, fileIt->hTreeItem, true);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tMC_HTREELISTITEM selection = NULL;\n\t\t\t\twhile ((selection = MCTreeList_GetNextSelection(hTree, selection)) != NULL)\n\t\t\t\t{\n\t\t\t\t\tsetSelectItem(hTree, selection, false);\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis->ignoreTreeSelChanges = false;\n\t\t\tthis->onChangeFileSelection();\n\t\t}\n\t\treturn;\n\tdefault:\n\t\treturn;\n\t}\n\tbool selectionUpdated = false;\n\tswitch (checkState)\n\t{\n\tcase BST_INDETERMINATE:\n\t\tButton_SetCheck(GetDlgItem(hDlg, checkboxID), BST_UNCHECKED);\n\t\t//Fall through to the unchecked case.\n\tcase BST_UNCHECKED:\n\t\tif (ManipDlgDesc *pTab = getActiveManipDlgDesc())\n\t\t{\n\t\t\tthis->ignoreTreeSelChanges = true;\n\t\t\tfor (size_t i = 0; i < pTab->selection.size(); i++)\n\t\t\t{\n\t\t\t\tEFileContextType type;\n\t\t\t\tif (getSelectionType(pTab->selection[i], type, false) && type == fileContextType)\n\t\t\t\t{\n\t\t\t\t\tbool tmp;\n\t\t\t\t\tif (FileEntryUIInfo *pSelFileEntryInfo = getEntryParam_FileEntryInfo(pTab->selection[i], tmp))\n\t\t\t\t\t{\n\t\t\t\t\t\tselectionUpdated = true;\n\t\t\t\t\t\tsetSelectItem(hTree, pSelFileEntryInfo->hTreeItem, false);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis->ignoreTreeSelChanges = false;\n\t\t}\n\t\tbreak;\n\tcase BST_CHECKED:\n\t\t{\n\t\t\tthis->ignoreTreeSelChanges = true;\n\t\t\tfor (auto fileIt = fileEntries.begin(); fileIt != fileEntries.end(); ++fileIt)\n\t\t\t{\n\t\t\t\tEFileContextType type;\n\t\t\t\tif (fileIt->hTreeItem && getSelectionType(&*fileIt, type, false) && type == fileContextType)\n\t\t\t\t{\n\t\t\t\t\tselectionUpdated = true;\n\t\t\t\t\tsetSelectItem(hTree, fileIt->hTreeItem, true);\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis->ignoreTreeSelChanges = false;\n\t\t}\n\t\tbreak;\n\t}\n\tif (selectionUpdated)\n\t\tthis->onChangeFileSelection();\n}\nvoid MainWindow2::doUpdateSelectionCheckboxes(const std::vector<ITreeParameter*> &selections)\n{\n\tstd::array<size_t, FileContext_COUNT> selectionCountersByType = {};\n\tfor (size_t i = 0; i < selections.size(); i++)\n\t{\n\t\tEFileContextType type;\n\t\tif (getSelectionType(selections[i], type, true))\n\t\t\tselectionCountersByType[type]++;\n\t}\n\t\n\tstatic const int entryTypeDlgItems[] = {IDC_CKBUNDLES, IDC_CKASSETS, IDC_CKRESOURCES, IDC_CKGENERICS};\n\tassert(fileEntryCountersByType.size() == selectionCountersByType.size());\n\tassert(fileEntryCountersByType.size() == sizeof(entryTypeDlgItems) / sizeof(int));\n\tsize_t selectionSum = 0;\n\tfor (size_t i = 0; i < fileEntryCountersByType.size()\n\t\t&& i < selectionCountersByType.size()\n\t\t&& i < sizeof(entryTypeDlgItems) / sizeof(int); i++)\n\t{\n\t\tHWND hCheckbox = GetDlgItem(this->hDlg, entryTypeDlgItems[i]);\n\t\tselectionSum += selectionCountersByType[i];\n\t\tif (selectionCountersByType[i] > 0)\n\t\t{\n\t\t\tassert(selectionCountersByType[i] <= fileEntryCountersByType[i]);\n\t\t\tif (selectionCountersByType[i] >= fileEntryCountersByType[i])\n\t\t\t\tButton_SetCheck(hCheckbox, BST_CHECKED);\n\t\t\telse\n\t\t\t\tButton_SetCheck(hCheckbox, BST_INDETERMINATE);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tButton_SetCheck(hCheckbox, BST_UNCHECKED);\n\t\t}\n\t}\n\tHWND hSelAllCheckbox = GetDlgItem(this->hDlg, IDC_CKSELALL);\n\tif (selectionSum > 0)\n\t{\n\t\tassert(selectionSum <= fileEntries.size());\n\t\tif (selectionSum >= fileEntries.size())\n\t\t\tButton_SetCheck(hSelAllCheckbox, BST_CHECKED);\n\t\telse\n\t\t\tButton_SetCheck(hSelAllCheckbox, BST_UNCHECKED);\n\t}\n\telse\n\t\tButton_SetCheck(hSelAllCheckbox, BST_UNCHECKED);\n}\nvoid MainWindow2::selectFileContext(unsigned int fileID, bool preventOpenNewTab)\n{\n\tHWND hTree = GetDlgItem(hDlg, IDC_TREEFILES);\n\tFileContextInfo_ptr pContextInfo = this->pContext->getContextInfo(fileID);\n\tif (pContextInfo == nullptr)\n\t\treturn;\n\tauto fileUIEntryIt = this->fileEntriesByContextInfo.find(pContextInfo.get());\n\tif (fileUIEntryIt == this->fileEntriesByContextInfo.end())\n\t\treturn;\n\tManipDlgDesc *pCurTabDesc = this->getActiveManipDlgDesc();\n\tFileManipulateDialogInfo *pDialogInfo = nullptr;\n\tfor (auto iter = fileUIEntryIt->second->getDialogsIterator(); !iter.end(); ++iter)\n\t{\n\t\tif (pCurTabDesc == nullptr || pCurTabDesc->pCurManipDlg == nullptr || \n\t\t\titer->type == pCurTabDesc->pCurManipDlg->getType())\n\t\t{\n\t\t\tpDialogInfo = &*iter;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (pDialogInfo != nullptr && pDialogInfo->hTreeItem != NULL)\n\t{\n\t\tMC_TLITEM item;\n\t\titem.fMask = MC_TLIF_STATE;\n\t\titem.state = MC_TLIS_SELECTED;\n\t\titem.stateMask = MC_TLIS_SELECTED;\n\t\tthis->oneshot_applySelectionToCurrentTab = preventOpenNewTab;\n\t\tSendMessage(hTree, MC_TLM_SETITEM, reinterpret_cast<WPARAM>(pDialogInfo->hTreeItem), reinterpret_cast<LPARAM>(&item));\n\t\tthis->oneshot_applySelectionToCurrentTab = false;\n\t}\n}\nbool MainWindow2::loadBundleEntry(std::shared_ptr<BundleFileContextInfo> pBundleInfo, unsigned int bundleEntryIdx)\n{\n\tHWND hTree = GetDlgItem(hDlg, IDC_TREEFILES);\n\tauto fileUIEntryIt = this->fileEntriesByContextInfo.find(pBundleInfo.get());\n\tif (fileUIEntryIt == this->fileEntriesByContextInfo.end())\n\t\treturn false;\n\tstd::shared_ptr<ITask> pTask = pContext->CreateBundleEntryOpenTask(pBundleInfo, bundleEntryIdx);\n\tif (!pTask)\n\t{\n\t\tif (!pBundleInfo->entryIsRemoved(bundleEntryIdx))\n\t\t\tMessageBox(this->hDlg, TEXT("Failed to read the bundle entry."), TEXT("UABE"), 16);\n\t\treturn false;\n\t}\n\tchar entryNameBuf[32];\n\tstd::string entryName = pBundleInfo->getNewEntryName(bundleEntryIdx);\n\tif (entryName.empty())\n\t{\n\t\tsprintf_s(entryNameBuf, "Entry %u", bundleEntryIdx);\n\t\tentryName = entryNameBuf;\n\t}\n\tMC_HTREELISTITEM treeItem = insertPendingEntry(hTree, fileUIEntryIt->second->hTreeItem, entryName);\n\n\tfileEntries.emplace_back(FileEntryUIInfo(treeItem, entryName, false));\n\tfileEntries.back().myiter = --fileEntries.end();\n\n\tupdateEntryInfoRef(hTree, treeItem, fileEntries.back());\n\tupdateEntryName(hTree, treeItem, std::string("Pending : ") + entryName);\n\tpendingFileEntriesByTask.insert(std::make_pair(pTask.get(), &fileEntries.back()));\n\n\tif (!this->pContext->taskManager.enqueue(pTask))\n\t{\n\t\tOnFileEntryLoadFailure(pTask.get(), std::string("Failed to enqueue the file open task."));\n\t\treturn false;\n\t}\n\treturn true;\n}\nvoid MainWindow2::onChangeFileSelection()\n{\n\tHWND hTabsControl = GetDlgItem(hDlg, IDC_MANIPDLGTABS);\n\tManipDlgDesc *pCurTabDesc = this->getActiveManipDlgDesc();\n\tif (!pCurTabDesc && this->manipDlgTabs.size() > 0)\n\t{\n\t\t//Choose the last tab.\n\t\tMC_MTITEM itemInfo = {};\n\t\titemInfo.dwMask = MC_MTIF_PARAM;\n\t\t//Retrieve the index of the tab in pThis->manipDlgTabs.\n\t\tSendMessage(hTabsControl, MC_MTM_GETITEM, (WPARAM)(this->manipDlgTabs.size() - 1), (LPARAM)&itemInfo);\n\t\tsize_t internalItemIdx = (size_t)itemInfo.lParam;\n\t\tassert(internalItemIdx < this->manipDlgTabs.size());\n\t\tif (internalItemIdx < this->manipDlgTabs.size())\n\t\t{\n\t\t\t//Select the tab.\n\t\t\tSendMessage(hTabsControl, MC_MTM_SETCURSEL, (WPARAM)(this->manipDlgTabs.size() - 1), (LPARAM)0); //wParam:idx\n\t\t\tthis->activeManipDlgTab = internalItemIdx;\n\t\t\tpCurTabDesc = &this->manipDlgTabs[internalItemIdx];\n\t\t}\n\t}\n\t//May want to fine-tune the \'auto-close tab or don\'t\' / \'auto-open new tab\' behavior.\n\t//-> What if the user selects just one additional file, while the tab returns true on hasUnappliedChanges or doesPreferNoAutoclose?\n\t//   Problem could be that new tabs are opened too easily when not desired.\n\t// Could be quite cumbersome and error-prone to handle in detail.\n\tif (!pCurTabDesc\n\t\t|| (pCurTabDesc->pCurManipDlg\n\t\t\t&& (pCurTabDesc->pCurManipDlg->hasUnappliedChanges() || pCurTabDesc->pCurManipDlg->doesPreferNoAutoclose()))\n\t\t\t&& !this->oneshot_applySelectionToCurrentTab)\n\t{\n\t\tsize_t newTabIdx = this->manipDlgTabs.size();\n\t\t//Note: Manipulating manipDlgTabs invalidates pCurTabDesc.\n\t\tthis->manipDlgTabs.emplace_back(ManipDlgDesc());\n\t\tthis->activeManipDlgTab = newTabIdx;\n\t\tpCurTabDesc = &this->manipDlgTabs[newTabIdx];\n\n\t\tthis->skipDeselectOnTabChange = true;\n\n\t\tMC_MTITEM newItem = {};\n\t\tnewItem.dwMask = MC_MTIF_TEXT | MC_MTIF_PARAM;\n\t\tTCHAR sprntTmp[36];\n\t\t_stprintf_s(sprntTmp, TEXT("Tab %u"), (unsigned int)(newTabIdx + 1)); //TODO: Proper names\n\t\tnewItem.pszText = sprntTmp;\n\t\tnewItem.lParam = (LPARAM)newTabIdx;\n\t\tSendMessage(hTabsControl, MC_MTM_INSERTITEM, (WPARAM)newTabIdx, (LPARAM)&newItem);\n\t\tSendMessage(hTabsControl, MC_MTM_SETCURSEL, (WPARAM)newTabIdx, (LPARAM)0); //wParam:idx\n\n\t\tthis->skipDeselectOnTabChange = false;\n\t}\n\n\tHWND hTree = GetDlgItem(hDlg, IDC_TREEFILES);\n\tstd::vector<ITreeParameter*> newSelection;\n\tMC_HTREELISTITEM selection = NULL;\n\twhile ((selection = MCTreeList_GetNextSelection(hTree, selection)) != NULL)\n\t{\n\t\tITreeParameter *pCurParam = getEntryParam(hTree, selection);\n\t\tnewSelection.push_back(pCurParam);\n\t}\n\tbool selectionIsSaveable = false;\n\tfor (size_t i = 0; i < newSelection.size(); ++i)\n\t{\n\t\tbool tmp;\n\t\tFileEntryUIInfo *pNewFileEntryInfo = getEntryParam_FileEntryInfo(newSelection[i], tmp);\n\t\tif (pNewFileEntryInfo != nullptr\n\t\t\t&& pNewFileEntryInfo->getContextInfoPtr() != nullptr\n\t\t\t&& pNewFileEntryInfo->getContextInfoPtr()->getParentFileID() == 0\n\t\t\t&& pNewFileEntryInfo->getContextInfoPtr()->hasAnyChanges(*this->pContext))\n\t\t{\n\t\t\tselectionIsSaveable = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\tEnableMenuItem(getMenu(), IDM_FILE_SAVE, selectionIsSaveable ? MF_ENABLED : MF_GRAYED);\n\tdoUpdateSelectionCheckboxes(newSelection);\n\tif (pCurTabDesc->pCurManipDlg)\n\t{\n\t\t//Find the FileEntryUIInfo entries that were selected and those that were deselected.\n\t\t//-> Add/remove these from the active manipulate dialog.\n\t\t//Assuming the selections are both sorted by the tree view order.\n\n\t\t//Count the amount of selected dialog info entries for the current dialog.\n\t\tsize_t nShownSelections = 0;\n\n\t\tauto addFileContextsToDialog = [&newSelection, pCurTabDesc](size_t start, size_t limit, FileEntryUIInfo* pCurFileEntryInfo = nullptr)\n\t\t{\n\t\t\tsize_t n = 0;\n\t\t\tFileEntryUIInfo* pLastAddedFileEntry = nullptr; bool tmp;\n\t\t\tfor (size_t i = start; i < limit; i++)\n\t\t\t{\n\t\t\t\tITreeParameter* newParam = newSelection[i];\n\t\t\t\tFileEntryUIInfo* pNewFileEntryInfo = getEntryParam_FileEntryInfo(newParam, tmp);\n\t\t\t\tif (pNewFileEntryInfo\n\t\t\t\t\t&& pNewFileEntryInfo != pCurFileEntryInfo\n\t\t\t\t\t&& pNewFileEntryInfo != pLastAddedFileEntry\n\t\t\t\t\t&& newParam->isFileManipulateDialogInfo()\n\t\t\t\t\t&& newParam->asFileManipulateDialogInfo()->type == pCurTabDesc->pCurManipDlg->getType())\n\t\t\t\t{\n\t\t\t\t\t//Add a new file context to this dialog.\n\t\t\t\t\tFileManipulateDialogInfo* pNewDialogInfo = newParam->asFileManipulateDialogInfo();\n\t\t\t\t\tpCurTabDesc->pCurManipDlg->addFileContext(\n\t\t\t\t\t\tstd::make_pair(pNewFileEntryInfo, pNewDialogInfo->param));\n\t\t\t\t\tn++;\n\t\t\t\t\tpLastAddedFileEntry = pNewFileEntryInfo;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn n;\n\t\t};\n\n\t\tsize_t curIdx = pCurTabDesc->selection.size(), newIdx = newSelection.size();\n\t\tbool tmp;\n\t\tFileEntryUIInfo *pLastFileEntryInfo = nullptr;\n\t\tfor (; curIdx > 0; curIdx--)\n\t\t{\n\t\t\tITreeParameter *curParam = pCurTabDesc->selection[curIdx-1];\n\t\t\tFileEntryUIInfo *pCurFileEntryInfo = getEntryParam_FileEntryInfo(curParam, tmp);\n\t\t\tif (!pCurFileEntryInfo || pCurFileEntryInfo == pLastFileEntryInfo\n\t\t\t\t|| !curParam->isFileManipulateDialogInfo()\n\t\t\t\t|| curParam->asFileManipulateDialogInfo()->type != pCurTabDesc->pCurManipDlg->getType())\n\t\t\t\t//Ignore entries that are removed/handled already and those with a different dialog type.\n\t\t\t\tcontinue;\n\t\t\tsize_t addLimit = newIdx;\n\t\t\tbool fileEntryInfoFound = false;\n\t\t\tfor (; newIdx > 0; newIdx--)\n\t\t\t{\n\t\t\t\tITreeParameter *newParam = newSelection[newIdx-1];\n\t\t\t\tif (newParam == curParam)\n\t\t\t\t{\n\t\t\t\t\t//Found the same tree parameter (i.e. a tree view entry).\n\t\t\t\t\tfileEntryInfoFound = true;\n\t\t\t\t}\n\t\t\t\telse if (FileEntryUIInfo *pNewFileEntryInfo = getEntryParam_FileEntryInfo(newParam, tmp))\n\t\t\t\t{\n\t\t\t\t\tif (pNewFileEntryInfo->pending)\n\t\t\t\t\t{\n\t\t\t\t\t\t//Pending selected items can only be added later, once loaded.\n\t\t\t\t\t\t//Set the selection entry to nullptr so it will not be treated as added.\n\t\t\t\t\t\tnewSelection[newIdx-1] = nullptr;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (pNewFileEntryInfo == pLastFileEntryInfo)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (fileEntryInfoFound)\n\t\t\t\t\t\t\tbreak; //Went past the last item with the same file.\n\t\t\t\t\t\t//Skip this tree entry in the new selections list,\n\t\t\t\t\t\t// since one entry with this file was handled in the last iteration of the outer loop.\n\t\t\t\t\t\tcontinue; \n\t\t\t\t\t}\n\t\t\t\t\tif (pCurFileEntryInfo && pNewFileEntryInfo == pCurFileEntryInfo)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (newParam->isFileManipulateDialogInfo()\n\t\t\t\t\t\t  && newParam->asFileManipulateDialogInfo()->type == curParam->asFileManipulateDialogInfo()->type)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t//New tree parameter is a dialog structure of the same type that refers to the same file.\n\t\t\t\t\t\t\tfileEntryInfoFound = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse if (fileEntryInfoFound)\n\t\t\t\t\t\tbreak; //Went past the last item with the same file.\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!fileEntryInfoFound)\n\t\t\t{\n\t\t\t\t//Do not add any new elements (yet), since we can\'t tell which elements are new :\n\t\t\t\t//  the old selection is no proper anchor to determine what is new since it has been deleted.\n\t\t\t\tnewIdx = addLimit;\n\t\t\t}\n\t\t\tnShownSelections += addFileContextsToDialog(newIdx, addLimit, pCurFileEntryInfo);\n\t\t\tif (!fileEntryInfoFound)\n\t\t\t{\n\t\t\t\t//Remove the file context from the dialog since no matching tree element is selected anymore.\n\t\t\t\tpCurTabDesc->pCurManipDlg->removeFileContext(pCurFileEntryInfo);\n\t\t\t\t//The dialog may have closed itself after removing a file context.\n\t\t\t\tif (!pCurTabDesc->pCurManipDlg)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse\n\t\t\t\tnShownSelections++; //This entry still is shown.\n\t\t\tpLastFileEntryInfo = pCurFileEntryInfo;\n\t\t}\n\t\tFileEntryUIInfo *pLastAddedFileEntry = nullptr;\n\t\tif (pCurTabDesc->pCurManipDlg)\n\t\t\tnShownSelections += addFileContextsToDialog(0, newIdx, pLastFileEntryInfo);\n\t\tif (nShownSelections == 0)\n\t\t{\n\t\t\t//If none of the new selections apply to the current dialog, close the dialog.\n\t\t\tif (pCurTabDesc->pCurManipDlg)\n\t\t\t{\n\t\t\t\tpCurTabDesc->pCurManipDlg->onHide();\n\t\t\t\tpCurTabDesc->pCurManipDlg.reset();\n\t\t\t\tInvalidateRect(hDlg, NULL, TRUE); //TODO: Redraw only the manipulate dialog area.\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\t//If at least one file is shown in the dialog, there should be a matching selection.\n\t\t\tassert(newSelection.size() > 0); \n\t\t}\n\t}\n\n\tif (!pCurTabDesc->pCurManipDlg)\n\t{\n\t\tif (newSelection.size() > 0)\n\t\t{\n\t\t\tstd::set<EFileManipulateDialogType> possibleDialogTypes;\n\t\t\tfor (size_t i = 0; i < newSelection.size(); i++)\n\t\t\t{\n\t\t\t\tITreeParameter *curParam = newSelection[i];\n\t\t\t\tif (!curParam) continue;\n\t\t\t\tif (FileManipulateDialogInfo *pDialogInfo = curParam->asFileManipulateDialogInfo())\n\t\t\t\t{\n\t\t\t\t\tif (pDialogInfo->type != FileManipulateDialog_Other)\n\t\t\t\t\t\tpossibleDialogTypes.insert(pDialogInfo->type);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!possibleDialogTypes.empty())\n\t\t\t{\n\t\t\t\t//TODO : Handle the case where several dialog types are possible for the selection.\n\t\t\t\t//Option A : Display a notification dialog so the user selects only the entries they want.\n\t\t\t\t//Option B : Display a selection for a dialog type to use.\n\t\t\t\tEFileManipulateDialogType targetDialogType = *(possibleDialogTypes.begin());\n\t\t\t\tFileEntryUIInfo *pLastAddedFileEntry = nullptr;\n\t\t\t\tfor (size_t i = 0; i < newSelection.size(); i++)\n\t\t\t\t{\n\t\t\t\t\tITreeParameter *curParam = newSelection[i];\n\t\t\t\t\tbool tmp;\n\t\t\t\t\tFileEntryUIInfo *pCurFileEntry = getEntryParam_FileEntryInfo(curParam, tmp);\n\t\t\t\t\tif (!pCurFileEntry || pCurFileEntry == pLastAddedFileEntry)\n\t\t\t\t\t\tcontinue; //Only add one dialog info per file.\n\t\t\t\t\tif (FileManipulateDialogInfo *pDialogInfo = curParam->asFileManipulateDialogInfo())\n\t\t\t\t\t{\n\t\t\t\t\t\tif (pDialogInfo->type == targetDialogType)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (!pCurTabDesc->pCurManipDlg)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t//Create the dialog type if necessary.\n\t\t\t\t\t\t\t\t//TODO: Move the factory to the MainWindow2 class instead.\n\t\t\t\t\t\t\t\tif (!(pCurTabDesc->pCurManipDlg = this->pDialogFactory->construct(\n\t\t\t\t\t\t\t\t\t\tpDialogInfo->type, GetDlgItem(hDlg, IDC_CONTENTSEPARATE))))//hTabsControl))))\n\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tpCurTabDesc->pCurManipDlg->selfPtr = pCurTabDesc->pCurManipDlg;\n\t\t\t\t\t\t\tpCurTabDesc->pCurManipDlg->addFileContext(std::make_pair(pCurFileEntry, pDialogInfo->param));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tpLastAddedFileEntry = pCurFileEntry;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tpCurTabDesc->selection.swap(newSelection);\n\t\tif (pCurTabDesc->pCurManipDlg)\n\t\t{\n\t\t\t//Show the new dialog and size it properly.\n\t\t\tpCurTabDesc->pCurManipDlg->onShow();\n\t\t\tthis->onResize();\n\t\t\tSetFocus(hTree);\n\t\t}\n\t}\n\telse\n\t{\n\t\tpCurTabDesc->selection.swap(newSelection);\n\t}\n}\nvoid MainWindow2::addPendingBaseFileEntry(ITask *pTask, const std::string &path)\n{\n\tHWND hTree = GetDlgItem(this->hDlg, IDC_TREEFILES);\n\tMC_HTREELISTITEM treeItem = insertPendingEntry(hTree, NULL, path);\n\n\tfileEntries.emplace_back(FileEntryUIInfo(treeItem, path, true));\n\tfileEntries.back().myiter = --fileEntries.end();\n\n\tupdateEntryInfoRef(hTree, treeItem, fileEntries.back());\n\tupdateEntryName(hTree, treeItem, std::string("Pending : ") + fileEntries.back().getShortName());\n\tpendingFileEntriesByTask.insert(std::make_pair(pTask, &fileEntries.back()));\n}\nvoid MainWindow2::onOpenFileCommand()\n{\n\t//assert(this->pContext);\n\tstd::vector<char*> filePaths;\n\tHRESULT hr = ShowFileOpenDialogMultiSelect(this->hDlg, filePaths,\n\t\t"*.*|All types:*.unity3d|Bundle file:*.assets|Assets file", NULL, NULL,\n\t\t"Select the files to open",\n\t\tUABE_FILEDIALOG_FILE_GUID);\n\tif (SUCCEEDED(hr))\n\t{\n\t\tHWND hTree = GetDlgItem(this->hDlg, IDC_TREEFILES);\n\t\tfor (size_t i = 0; i < filePaths.size(); i++)\n\t\t{\n\t\t\tstd::string pathString(filePaths[i]);\n\t\t\tstd::shared_ptr<ITask> pTask = this->pContext->CreateFileOpenTask(pathString);\n\t\t\tif (!pTask)\n\t\t\t\tMessageBox(this->hDlg, TEXT("Failed to open the file."), TEXT("UABE"), 16);\n\t\t\telse\n\t\t\t{\n\t\t\t\taddPendingBaseFileEntry(pTask.get(), pathString);\n\n\t\t\t\tif (!this->pContext->taskManager.enqueue(pTask))\n\t\t\t\t\tOnFileEntryLoadFailure(pTask.get(), std::string("Failed to enqueue the file open task."));\n\t\t\t}\n\t\t}\n\t\tFreeFilePathsMultiSelect(filePaths);\n\t}\n}\nvoid MainWindow2::OnFindClassDatabaseFailure(AssetsFileContextInfo *pAssetsFileInfo, ClassDatabasePackage &package)\n{\n\tif (pAssetsFileInfo->getAssetsFileContext() && pAssetsFileInfo->getAssetsFileContext()->getAssetsFile())\n\t{\n\t\tif (!TryFindClassDatabase(pAssetsFileInfo))\n\t\t{\n\t\t\tauto entryIt = fileEntriesByContextInfo.find(pAssetsFileInfo);\n\t\t\tif (entryIt != fileEntriesByContextInfo.end())\n\t\t\t{\n\t\t\t\tfileEntriesPendingForDbSelection.push_back(DbSelectionQueueEntry(entryIt->second, true));\n\t\t\t\tif (pSelectClassDbDialog == nullptr)\n\t\t\t\t{\n\t\t\t\t\tOpenClassDatabaseSelection(pAssetsFileInfo, true);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\nbool MainWindow2::TryFindClassDatabase(AssetsFileContextInfo *pAssetsFileInfo)\n{\n\tconst char *targetVersion = pAssetsFileInfo->getAssetsFileContext()->getAssetsFile()->typeTree.unityVersion;\n\tfor (auto it = databaseFilesByEngineVersion.begin(); it != databaseFilesByEngineVersion.end(); ++it)\n\t{\n\t\tif (!it->first.compare(targetVersion))\n\t\t{\n\t\t\tpAssetsFileInfo->SetClassDatabase(it->second);\n\t\t\treturn true;\n\t\t}\n\t}\n\tif (defaultDatabaseFile != nullptr)\n\t{\n\t\tpAssetsFileInfo->SetClassDatabase(defaultDatabaseFile);\n\t\treturn true;\n\t}\n\treturn false;\n}\nvoid MainWindow2::OpenClassDatabaseSelection(AssetsFileContextInfo *pAssetsFileInfo, bool reason_DatabaseNotFound)\n{\n\tconst char *targetVersion = pAssetsFileInfo->getAssetsFileContext()->getAssetsFile()->typeTree.unityVersion;\n\tpSelectClassDbDialog.reset(new SelectClassDbDialog(hInstance, hDlg, pContext->classPackage));\n\tpSelectClassDbDialog->setAffectedFileName(pAssetsFileInfo->getFileName());\n\tpSelectClassDbDialog->setDialogReason(reason_DatabaseNotFound);\n\tpSelectClassDbDialog->setEngineVersion(std::string(targetVersion));\n\tHWND hSelectDialogWnd = pSelectClassDbDialog->ShowModeless(WM_APP+2);\n\tif (hSelectDialogWnd == NULL) pSelectClassDbDialog.reset();\n\tassert(hSelectDialogWnd != NULL);\n}\n\nvoid MainWindow2::OnRemoveContextInfo(FileContextInfo *info)\n{\n\tauto cacheIt = disposableCacheElements.find(info);\n\tif (cacheIt != disposableCacheElements.end())\n\t\tdisposableCacheElements.erase(cacheIt);\n\twhile (!fileEntriesPendingForDbSelection.empty() && fileEntriesPendingForDbSelection.front().pEntry == nullptr)\n\t\tfileEntriesPendingForDbSelection.pop_front(); //Cleanup\n\tfileEntriesByContextInfo.erase(info);\n\t//info->decRef(); //Reference from FileEntryUIInfo\n}\nvoid MainWindow2::OnUpdateContainers(AssetsFileContextInfo *pFile)\n{\n\tfor (auto handlerIt = eventHandlers.begin(); handlerIt != eventHandlers.end(); ++handlerIt)\n\t{\n\t\t(*handlerIt)->onUpdateContainers(pFile);\n\t}\n}\nvoid MainWindow2::OnUpdateDependencies(AssetsFileContextInfo *pFile, size_t from, size_t to)\n{\n\tfor (auto handlerIt = eventHandlers.begin(); handlerIt != eventHandlers.end(); ++handlerIt)\n\t{\n\t\t(*handlerIt)->onUpdateDependencies(pFile, from, to);\n\t}\n}\nvoid MainWindow2::OnChangeAsset(AssetsFileContextInfo *pFile, pathid_t pathID, bool wasRemoved)\n{\n\tfor (auto handlerIt = eventHandlers.begin(); handlerIt != eventHandlers.end(); ++handlerIt)\n\t{\n\t\t(*handlerIt)->onChangeAsset(pFile, pathID, wasRemoved);\n\t}\n}\nvoid MainWindow2::OnChangeBundleEntry(BundleFileContextInfo *pFile, size_t index)\n{\n\tthis->updateBundleEntryName(pFile, index, pFile->getNewEntryName(index));\n\tfor (auto handlerIt = eventHandlers.begin(); handlerIt != eventHandlers.end(); ++handlerIt)\n\t{\n\t\t(*handlerIt)->onUpdateBundleEntry(pFile, index);\n\t}\n}\nvoid MainWindow2::hideManipulateDialog(IFileManipulateDialog *pDialog)\n{\n\tif (this->activeManipDlgTab < this->manipDlgTabs.size() && \n\t\tthis->manipDlgTabs[this->activeManipDlgTab].pCurManipDlg.get() == pDialog &&\n\t\tpDialog != nullptr)\n\t{\n\t\tpDialog->onHide();\n\t\tthis->manipDlgTabs[this->activeManipDlgTab].pCurManipDlg = nullptr;\n\t\tInvalidateRect(hDlg, NULL, TRUE); //TODO: Redraw only the manipulate dialog area.\n\t}\n}\nvoid MainWindow2::CloseUIFileEntry(FileEntryUIInfo *info, HWND hTree)\n{\n\tauto cacheIt = disposableCacheElements.find(info);\n\tif (cacheIt != disposableCacheElements.end())\n\t\tdisposableCacheElements.erase(cacheIt);\n\n\tif (hTree == NULL)\n\t\thTree = GetDlgItem(this->hDlg, IDC_TREEFILES);\n\n\tDeleteFileEntry_TreeItems(hTree, info);\n\tfor (size_t iTab = 0; iTab < this->manipDlgTabs.size(); iTab++)\n\t{\n\t\tManipDlgDesc &desc = this->manipDlgTabs[iTab];\n\t\tfor (size_t iSel = 0; iSel < desc.selection.size(); iSel++)\n\t\t{\n\t\t\tbool tmp; \n\t\t\tITreeParameter *pCurSelection = desc.selection[iSel];\n\t\t\tif (pCurSelection && getEntryParam_FileEntryInfo(pCurSelection, tmp) == info)\n\t\t\t{\n\t\t\t\tif (desc.pCurManipDlg)\n\t\t\t\t\tdesc.pCurManipDlg->removeFileContext(info);\n\t\t\t\tdesc.selection[iSel] = nullptr;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t//Remove references from the class database selection queue.\n\tfor (auto it = fileEntriesPendingForDbSelection.begin(); it != fileEntriesPendingForDbSelection.end(); ++it)\n\t{\n\t\tif (it->pEntry == info)\n\t\t\tit->pEntry = nullptr;\n\t}\n\t//Additionally, cancel the active cldb selection dialog if it refers to a closed file.\n\tif (!fileEntriesPendingForDbSelection.empty() && fileEntriesPendingForDbSelection.front().pEntry == nullptr\n\t\t&& pSelectClassDbDialog != nullptr)\n\t\tpSelectClassDbDialog->ForceCancel();\n\n\tfileEntries.erase(info->myiter);\n}\nbool MainWindow2::fileHasUnappliedChanges(FileEntryUIInfo *pFileInfo)\n{\n\tfor (size_t iTab = 0; iTab < this->manipDlgTabs.size(); iTab++)\n\t{\n\t\tbool isSelectedInTab = false;\n\t\tManipDlgDesc &desc = this->manipDlgTabs[iTab];\n\t\tif (!desc.pCurManipDlg)\n\t\t\tcontinue;\n\t\tfor (size_t iSel = 0; iSel < desc.selection.size(); iSel++)\n\t\t{\n\t\t\tbool tmp; \n\t\t\tITreeParameter *pCurSelection = desc.selection[iSel];\n\t\t\tif (pCurSelection && getEntryParam_FileEntryInfo(pCurSelection, tmp) == pFileInfo)\n\t\t\t{\n\t\t\t\tisSelectedInTab = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (isSelectedInTab && desc.pCurManipDlg && desc.pCurManipDlg->hasUnappliedChanges())\n\t\t\treturn true;\n\t}\n\treturn false;\n}\nbool MainWindow2::fileHasUnsavedChanges(FileEntryUIInfo *pFileInfo)\n{\n\treturn pFileInfo->pContextInfo && pFileInfo->pContextInfo->hasNewChanges(*pContext);\n}\n//Returns true if the user chose to proceed anyway.\nstatic bool askUserApplyChangeBeforeInstaller(HWND hParent)\n{\n\treturn IDYES == MessageBox(hParent,\n\t\tTEXT("There are unapplied changes in an open tab.\\nDo you want to apply these changes before creating an installer?"),\n\t\tTEXT("Asset Bundle Extractor"), MB_YESNO | MB_ICONWARNING | MB_DEFBUTTON2);\n}\n//Returns true if the user chose to proceed anyway.\nstatic bool warnUserOnUnappliedFileChange(HWND hParent, bool onSelectedFile)\n{\n\treturn IDYES == MessageBox(hParent,\n\t\tonSelectedFile ?\n\t\t\tTEXT("A tab that uses this file has unapplied changes.\\nDo you want to proceed anyway?") :\n\t\t\tTEXT("A tab that uses an opened file has unapplied changes.\\nDo you want to proceed anyway?"),\n\t\tTEXT("Asset Bundle Extractor"), MB_YESNO | MB_ICONWARNING | MB_DEFBUTTON2);\n}\n//Returns true if the user chose to proceed anyway.\nstatic bool warnUserOnUnsavedFileChange(HWND hParent, bool onSelectedFile)\n{\n\treturn IDYES == MessageBox(hParent,\n\t\tonSelectedFile ? TEXT("The file has unapplied changes.\\nDo you want to proceed anyway?")\n\t\t: TEXT("A file has unapplied changes.\\nDo you want to proceed anyway?"),\n\t\tTEXT("Asset Bundle Extractor"), MB_YESNO | MB_ICONWARNING | MB_DEFBUTTON2);\n}\nbool MainWindow2::CloseFile(unsigned int fileID)\n{\n\tFileContextInfo_ptr pContextInfo = this->pContext->getContextInfo(fileID);\n\tif (pContextInfo == nullptr)\n\t\treturn false;\n\tauto fileUIEntryIt = this->fileEntriesByContextInfo.find(pContextInfo.get());\n\tif (fileUIEntryIt == this->fileEntriesByContextInfo.end())\n\t\treturn false;\n\treturn CloseFile(fileUIEntryIt->second);\n}\nbool MainWindow2::CloseFile(FileEntryUIInfo *info, HWND hTree)\n{\n\tif (hTree == NULL)\n\t\thTree = GetDlgItem(this->hDlg, IDC_TREEFILES);\n\tbool choseToProceedUnapplied = false, choseToProceedUnsaved = false;\n\tif (!choseToProceedUnapplied && fileHasUnappliedChanges(info))\n\t{\n\t\tif (warnUserOnUnappliedFileChange(this->hDlg, true))\n\t\t\tchoseToProceedUnapplied = true;\n\t\telse\n\t\t\treturn false;\n\t}\n\tif (!choseToProceedUnsaved && fileHasUnsavedChanges(info))\n\t{\n\t\tif (warnUserOnUnsavedFileChange(this->hDlg, true))\n\t\t\tchoseToProceedUnsaved = true;\n\t\telse\n\t\t\treturn false;\n\t}\n\tstd::list<FileEntryUIInfo*> selectedEntries;\n\tselectedEntries.push_back(info);\n\tfor (auto it = selectedEntries.begin(); it != selectedEntries.end(); )\n\t{\n\t\tFileEntryUIInfo *pEntryInfo = *it;\n\t\tif (pEntryInfo->pending)\n\t\t{\n\t\t\tbool taskRunning;\n\t\t\tif (this->pContext->taskManager.cancel(pEntryInfo->getTask(), &taskRunning) && !taskRunning)\n\t\t\t{\n\t\t\t\t//The task did not start and therefore will not issue a finish callback.\n\t\t\t\tpendingFileEntriesByTask.erase(pEntryInfo->getTask());\n\t\t\t\tdelete pEntryInfo->getTask();\n\t\t\t\t\n\t\t\t\tCloseUIFileEntry(pEntryInfo, hTree);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tstd::shared_ptr<FileContextInfo> pFileContextInfo = pEntryInfo->getContextInfo();\n\t\t\tif (pFileContextInfo)\n\t\t\t{\n\t\t\t\tstd::vector<unsigned int> childFileIDs;\n\t\t\t\tpFileContextInfo->getChildFileIDs(childFileIDs);\n\t\t\t\tauto firstChildIt = it;\n\t\t\t\tfor (size_t k = 0; k < childFileIDs.size(); k++)\n\t\t\t\t{\n\t\t\t\t\tif (childFileIDs[k] == 0)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t//TODO: Handle pending child entries properly\n\t\t\t\t\tstd::shared_ptr<FileContextInfo> pCurChild = pContext->getContextInfo(childFileIDs[k]);\n\t\t\t\t\tauto childEntryInfoIt = fileEntriesByContextInfo.find(pCurChild.get());\n\t\t\t\t\tif (childEntryInfoIt != fileEntriesByContextInfo.end())\n\t\t\t\t\t{\n\t\t\t\t\t\t//Note: If there are >2 nesting levels for opened files,\n\t\t\t\t\t\t//         we may end up having some of the sub-files closed even if the user decides to cancel now.\n\t\t\t\t\t\tif (!choseToProceedUnapplied && fileHasUnappliedChanges(childEntryInfoIt->second))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (warnUserOnUnappliedFileChange(this->hDlg, true))\n\t\t\t\t\t\t\t\tchoseToProceedUnapplied = true;\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!choseToProceedUnsaved && fileHasUnsavedChanges(childEntryInfoIt->second))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (warnUserOnUnsavedFileChange(this->hDlg, true))\n\t\t\t\t\t\t\t\tchoseToProceedUnsaved = true;\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t//Insert before firstChildIt and update firstChildIt.\n\t\t\t\t\t\tfirstChildIt = selectedEntries.insert(firstChildIt, childEntryInfoIt->second);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (firstChildIt != it)\n\t\t\t\t{\n\t\t\t\t\t//If this entry has children, close those first. This entry will be revisited afterwards.\n\t\t\t\t\tit = firstChildIt;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (pFileContextInfo->getFileContext())\n\t\t\t\t{\n\t\t\t\t\tEFileContextType type = pFileContextInfo->getFileContext()->getType();\n\t\t\t\t\tif (type >= (EFileContextType)0 && type < FileContext_COUNT)\n\t\t\t\t\t{\n\t\t\t\t\t\tassert(this->fileEntryCountersByType[type] > 0);\n\t\t\t\t\t\tthis->fileEntryCountersByType[type]--;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tCloseUIFileEntry(pEntryInfo, hTree);\n\n\t\t\tif (pFileContextInfo)\n\t\t\t{\n\t\t\t\tpContext->RemoveContextInfo(pFileContextInfo.get());\n\t\t\t}\n\t\t}\n\t\t//No need to keep the old entry. \n\t\tit = selectedEntries.erase(it);\n\t}\n#ifdef _DEBUG\n\tassert(selectedEntries.empty());\n#endif\n\treturn true;\n}\nvoid MainWindow2::onCloseFileCommand()\n{\n\tHWND hTree = GetDlgItem(this->hDlg, IDC_TREEFILES);\n\tsize_t nSelectionsLast = 0;\n\tbool continueClose = false;\n\tdo\n\t{\n\t\tstd::vector<MC_HTREELISTITEM> selections;\n\t\tMC_HTREELISTITEM selection = NULL;\n\t\twhile ((selection = MCTreeList_GetNextSelection(hTree, selection)) != NULL)\n\t\t\tselections.push_back(selection);\n\t\tif (selections.empty())\n\t\t\tbreak;\n\n\t\tcontinueClose = false;\n\t\tfor (size_t i = 0; i < selections.size(); i++)\n\t\t{\n\t\t\tselection = selections[i];\n\t\t\tsetSelectItem(hTree, selection, false);\n\n\t\t\tITreeParameter *pEntryParam = getEntryParam(hTree, selection);\n\t\t\tbool isCloseable;\n\t\t\tFileEntryUIInfo *pEntryInfo = getEntryParam_FileEntryInfo(pEntryParam, isCloseable);\n\t\t\t\n\t\t\tif (pEntryInfo)\n\t\t\t{\n\t\t\t\tsize_t oldFileCount = fileEntries.size();\n\t\t\t\tif (isCloseable && !CloseFile(pEntryInfo, hTree))\n\t\t\t\t\treturn;\n\t\t\t\tif (fileEntries.size() != oldFileCount)\n\t\t\t\t{\n\t\t\t\t\tcontinueClose = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (isCloseable)\n\t\t\t\t{\n\t\t\t\t\tMCTreeList_DeleteItem(hTree, selection);\n\t\t\t\t\tcontinueClose = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t} while (continueClose);\n}\nbool MainWindow2::onCloseProgramCommand()\n{\n\tbool choseToProceedUnapplied = false, choseToProceedUnsaved = false;\n\tfor (FileEntryUIInfo& entryInfo : getFileEntries())\n\t{\n\t\tif (!choseToProceedUnapplied && fileHasUnappliedChanges(&entryInfo))\n\t\t{\n\t\t\tif (warnUserOnUnappliedFileChange(this->hDlg, false))\n\t\t\t\tchoseToProceedUnapplied = true;\n\t\t\telse\n\t\t\t\treturn false;\n\t\t}\n\t\tif (!choseToProceedUnsaved && fileHasUnsavedChanges(&entryInfo))\n\t\t{\n\t\t\tif (warnUserOnUnsavedFileChange(this->hDlg, false))\n\t\t\t\tchoseToProceedUnsaved = true;\n\t\t\telse\n\t\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\nvoid MainWindow2::onSaveFileRequest(FileEntryUIInfo *pUIInfo)\n{\n\tassert(pUIInfo != nullptr);\n\tif (pUIInfo->pContextInfo && pUIInfo->pContextInfo->hasAnyChanges(*this->pContext))\n\t{\n\t\tstd::string defaultFilePath = pUIInfo->pContextInfo->getFileContext()->getFilePath();\n\t\tif (!defaultFilePath.empty())\n\t\t\t\tdefaultFilePath += "-mod";\n\t\tif (pUIInfo->pContextInfo->getParentFileID() != 0)\n\t\t{\n\t\t\t//Ignore bundled files here.\n\t\t}\n\t\telse\n\t\t{\n\t\t\tsize_t tmp;\n\t\t\tTCHAR *defaultFilePathT = (defaultFilePath.empty() ? nullptr : _MultiByteToTCHAR(defaultFilePath.c_str(), tmp));\n\t\t\tWCHAR *saveFilePath = nullptr;\n\t\t\tHRESULT hr = ShowFileSaveDialog(this->hDlg, &saveFilePath,\n\t\t\t\tTEXT("*.*|File:"), nullptr, defaultFilePathT,\n\t\t\t\tTEXT("Save changes"),\n\t\t\t\tUABE_FILEDIALOG_FILE_GUID);\n\t\t\tif (defaultFilePathT != nullptr)\n\t\t\t\t_FreeTCHAR(defaultFilePathT);\n\t\t\tif (SUCCEEDED(hr))\n\t\t\t{\n\t\t\t\tIAssetsWriter *pWriter = Create_AssetsWriterToFile(saveFilePath, true, true, RWOpenFlags_Immediately);\n\t\t\t\tFreeCOMFilePathBuf(&saveFilePath);\n\t\t\t\tif (pWriter == nullptr)\n\t\t\t\t\tMessageBox(this->hDlg, TEXT("Unable to open the selected file for writing!"), TEXT("Asset Bundle Extractor"), MB_ICONERROR);\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tuint64_t size = pUIInfo->pContextInfo->write(*this->pContext, pWriter, 0, true);\n\t\t\t\t\tFree_AssetsWriter(pWriter);\n\t\t\t\t\tswitch (pUIInfo->pContextInfo->getFileContext()->getType())\n\t\t\t\t\t{\n\t\t\t\t\tcase FileContext_Assets:\n\t\t\t\t\tcase FileContext_Bundle:\n\t\t\t\t\t\tif (size == 0)\n\t\t\t\t\t\t\tMessageBox(this->hDlg, TEXT("An error occured while saving the file!"), TEXT("Asset Bundle Extractor"), MB_ICONERROR);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic std::string formatNameFor(FileContextInfo *pContextInfo, FileEntryUIInfo *pUIInfo)\n{\n\tif (pContextInfo == nullptr || pContextInfo->getFileContext() == nullptr)\n\t\treturn std::string("Pending : ") + pUIInfo->getShortName();\n\tassert(!pUIInfo->pending);\n\tassert(pUIInfo->pContextInfo.get() == pContextInfo);\n\tconst char *nameSuffix = "";\n\tswitch (pContextInfo->getFileContext()->getType())\n\t{\n\tcase FileContext_Assets:\n\t\tnameSuffix = " (Assets)";\n\t\tbreak;\n\tcase FileContext_Bundle:\n\t\tnameSuffix = " (Bundle)";\n\t\tbreak;\n\tcase FileContext_Resources:\n\t\tnameSuffix = " (Resources)";\n\t\tbreak;\n\tcase FileContext_Generic:\n\t\tnameSuffix = " (Generic)";\n\t\tbreak;\n\t}\n\treturn std::string(pUIInfo->getShortName()) + nameSuffix;\n}\n\nvoid MainWindow2::updateBundleEntryName(BundleFileContextInfo *pBundleInfo, size_t bundleEntryIdx, std::string newName)\n{\n\tstd::vector<unsigned int> childFileIDs;\n\tpBundleInfo->getChildFileIDs(childFileIDs);\n\tif (bundleEntryIdx >= childFileIDs.size())\n\t\treturn;\n\tFileEntryUIInfo *pEntry = nullptr;\n\tFileContextInfo_ptr pChildInfo = nullptr;\n\tif (childFileIDs[bundleEntryIdx] != 0)\n\t{\n\t\tpChildInfo = this->pContext->getContextInfo(childFileIDs[bundleEntryIdx]);\n\t\tif (pChildInfo != nullptr)\n\t\t{\n\t\t\tauto uiEntryIt = fileEntriesByContextInfo.find(pChildInfo.get());\n\t\t\tif (uiEntryIt != fileEntriesByContextInfo.end())\n\t\t\t\tpEntry = uiEntryIt->second;\n\t\t}\n\t}\n\telse\n\t{\n\t\tfor (auto it = pendingFileEntriesByTask.begin(); it != pendingFileEntriesByTask.end(); ++it)\n\t\t{\n\t\t\tauto pFileOpenTask = dynamic_cast<AppContext::FileOpenTask*>(it->first);\n\t\t\tif (pFileOpenTask->parentFileID == pBundleInfo->getFileID() && pFileOpenTask->directoryEntryIdx == bundleEntryIdx)\n\t\t\t{\n\t\t\t\tpEntry = it->second;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif (pEntry == nullptr)\n\t\treturn;\n\tpEntry->updateName(std::move(newName));\n\t\n\tHWND hTree = GetDlgItem(this->hDlg, IDC_TREEFILES);\n\tupdateEntryName(hTree, pEntry->hTreeItem, formatNameFor(pChildInfo.get(), pEntry));\n}\n\nbool MainWindow2::OnFileEntryLoadSuccess(ITask *pTask, std::shared_ptr<FileContextInfo> &pContextInfo, TaskResult result)\n{\n\tif (getMenu() != NULL)\n\t\tEnableMenuItem(getMenu(), IDM_FILE_SAVEALL, MF_ENABLED);\n\tauto entryIt = pendingFileEntriesByTask.find(pTask);\n\tif (entryIt == pendingFileEntriesByTask.end()\n\t\t&& pTask != nullptr && pContextInfo != nullptr && pContextInfo->getFileContext()\n\t\t&& pContextInfo->getParentFileID() == 0)\n\t{\n\t\tthis->addPendingBaseFileEntry(pTask, pContextInfo->getFileContext()->getFilePath());\n\t\tentryIt = pendingFileEntriesByTask.find(pTask);\n\t}\n\tif (entryIt != pendingFileEntriesByTask.end())\n\t{\n\t\tFileEntryUIInfo &entry = *(entryIt->second);\n\t\tpendingFileEntriesByTask.erase(pTask);\n\t\tentry.failed = false;\n\t\tentry.pending = false;\n\t\tentry.pContextInfo = nullptr;\n\t\tentry.setContextInfo(pContextInfo);\n\t\t//entry.pContextInfo = pContextInfo;\n\t\t//pContextInfo->incRef(); //Reference from FileEntryUIInfo\n\t\tfileEntriesByContextInfo.insert(std::make_pair(pContextInfo.get(), &entry));\n\t\t\n\t\tHWND hTree = GetDlgItem(this->hDlg, IDC_TREEFILES);\n\n\t\tsetEntryFileID(hTree, entry.hTreeItem, pContextInfo->getFileID());\n\t\tIFileContext *pFileContext = pContextInfo->getFileContext();\n\t\tswitch (pFileContext->getType())\n\t\t{\n\t\tcase FileContext_Assets:\n\t\t\t{\n\t\t\t\tEAssetsFileOpenStatus openStatus = static_cast<EAssetsFileOpenStatus>(result);\n\t\t\t\tfileEntryCountersByType[FileContext_Assets]++;\n\n\t\t\t\t\n\t\t\t\tassert(entry.standardDialogsCount == 0);\n\t\t\t\tassert(entry.standardDialogsCount < entry.standardDialogs.size());\n\t\t\t\tentry.standardDialogsCount = 0;\n\t\t\t\tFileManipulateDialogInfo &assetsDialog = entry.standardDialogs[entry.standardDialogsCount++];\n\t\t\t\tassetsDialog.hTreeItem = entry.hTreeItem;\n\t\t\t\tassetsDialog.pEntry = &entry;\n\t\t\t\tassetsDialog.type = FileManipulateDialog_AssetList;\n\t\t\t\tupdateEntryInfoRef(hTree, assetsDialog.hTreeItem, assetsDialog); //Intentional so the tree item is linked to the dialog action.\n\t\t\t\t\n\t\t\t\tassert(entry.standardDialogsCount < entry.standardDialogs.size());\n\t\t\t\tFileManipulateDialogInfo &dependenciesDialog = entry.standardDialogs[entry.standardDialogsCount++];\n\t\t\t\tdependenciesDialog.hTreeItem = insertEntry(hTree, entry.hTreeItem, std::string("Dependencies"));\n\t\t\t\tdependenciesDialog.pEntry = &entry;\n\t\t\t\tdependenciesDialog.type = FileManipulateDialog_AssetsDependencies;\n\t\t\t\tupdateEntryInfoRef(hTree, dependenciesDialog.hTreeItem, dependenciesDialog);\n\t\t\t\t\t\n\t\t\t\tassert(entry.standardDialogsCount < entry.standardDialogs.size());\n\t\t\t\tFileManipulateDialogInfo &containersDialog = entry.standardDialogs[entry.standardDialogsCount++];\n\t\t\t\tcontainersDialog.hTreeItem = insertEntry(hTree, entry.hTreeItem, std::string("Containers"));\n\t\t\t\tcontainersDialog.pEntry = &entry;\n\t\t\t\tcontainersDialog.type = FileManipulateDialog_AssetsContainers;\n\t\t\t\tupdateEntryInfoRef(hTree, containersDialog.hTreeItem, containersDialog);\n\t\t\t\t\n\t\t\t\tassert(entry.standardDialogsCount < entry.standardDialogs.size());\n\t\t\t\tFileManipulateDialogInfo &altAssetsDialog = entry.standardDialogs[entry.standardDialogsCount++];\n\t\t\t\taltAssetsDialog.hTreeItem = insertEntry(hTree, entry.hTreeItem, std::string("Assets"));\n\t\t\t\taltAssetsDialog.pEntry = &entry;\n\t\t\t\taltAssetsDialog.type = FileManipulateDialog_AssetList;\n\t\t\t\tupdateEntryInfoRef(hTree, altAssetsDialog.hTreeItem, altAssetsDialog);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase FileContext_Bundle:\n\t\t\t{\n\t\t\t\tEBundleFileOpenStatus openStatus = static_cast<EBundleFileOpenStatus>(result);\n\t\t\t\tstd::shared_ptr<BundleFileContextInfo> pBundleInfo = std::static_pointer_cast<BundleFileContextInfo, FileContextInfo>(pContextInfo);\n\n\t\t\t\tif (openStatus == BundleFileOpenStatus_CompressedDirectory ||\n\t\t\t\t\topenStatus == BundleFileOpenStatus_CompressedData)\n\t\t\t\t{\n\t\t\t\t\tentry.pending = true;\n\t\t\t\t\tentry.pContextInfo = nullptr;\n\t\t\t\t\tfileEntriesByContextInfo.erase(pContextInfo.get());\n\n\t\t\t\t\tif (decompressTargetDir.empty())\n\t\t\t\t\t{\n\t\t\t\t\t\t//Let the user select a decompression output directory.\n\t\t\t\t\t\tWCHAR *folderPath = nullptr;\n\t\t\t\t\t\tif (decompressTargetDir_cancel ||\n\t\t\t\t\t\t\t!ShowFolderSelectDialog(this->hDlg, &folderPath, L"Select a decompression output directory", UABE_FILEDIALOG_FILE_GUID))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tdecompressTargetDir_cancel = (pendingFileEntriesByTask.empty()) ? false : true;\n\t\t\t\t\t\t\tupdateEntryName(hTree, entry.hTreeItem, std::string("Failed : ") + entry.getShortName() + " (Compressed Bundle)");\n\t\t\t\t\t\t\tentry.failed = true;\n\t\t\t\t\t\t\tentry.pending = false;\n\t\t\t\t\t\t\tentry.openLogText += "Decompression was cancelled\\n";\n\t\t\t\t\t\t\treturn false; //Remove the bundle from the AppContext.\n\t\t\t\t\t\t}\n\t\t\t\t\t\tauto folderPathUTF8 = unique_WideToMultiByte(folderPath);\n\t\t\t\t\t\tdecompressTargetDir_cancel = false;\n\t\t\t\t\t\tdecompressTargetDir.assign(folderPathUTF8.get());\n\t\t\t\t\t\tFreeCOMFilePathBuf(&folderPath);\n\t\t\t\t\t}\n\t\t\t\t\tupdateEntryName(hTree, entry.hTreeItem, std::string(entry.getShortName()) + " (Compressed Bundle)");\n\t\t\t\t\tstd::shared_ptr<ITask> pDecompressTask = pBundleInfo->EnqueueDecompressTask(*pContext, pBundleInfo,\n\t\t\t\t\t\tdecompressTargetDir + "\\\\" + pBundleInfo->getFileName() + "-decompressed");\n\t\t\t\t\tif (pendingFileEntriesByTask.empty())\n\t\t\t\t\t\tdecompressTargetDir.clear();\n\t\t\t\t\tif (pDecompressTask == nullptr)\n\t\t\t\t\t{\n\t\t\t\t\t\tentry.failed = true;\n\t\t\t\t\t\tentry.pending = false;\n\t\t\t\t\t\tupdateEntryName(hTree, entry.hTreeItem, std::string("Failed : ") + entry.getShortName() + " (Compressed Bundle)");\n\t\t\t\t\t\tentry.openLogText += "Failed to enqueue decompression\\n";\n\t\t\t\t\t\treturn false; //Remove the bundle from the AppContext.\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tpendingFileEntriesByTask.insert(std::make_pair(pDecompressTask.get(), &entry));\n\t\t\t\t\t}\n\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\n\t\t\t\tfileEntryCountersByType[FileContext_Bundle]++;\n\n\t\t\t\tBundleFileContext *pBundleContext = pBundleInfo->getBundleFileContext();\n\t\t\t\tif (pBundleInfo->getEntryCount() > 0)\n\t\t\t\t\tsetHasChildren(hTree, entry.hTreeItem, true);\n\t\t\t\tassert(pBundleInfo->getEntryCount() <= UINT_MAX);\n\t\t\t\tfor (size_t i = 0; i < pBundleInfo->getEntryCount(); i++)\n\t\t\t\t{\n\t\t\t\t\tthis->loadBundleEntry(pBundleInfo, (unsigned int)i);\n\t\t\t\t}\n\n\t\t\t\tassert(entry.standardDialogsCount == 0);\n\t\t\t\tassert(entry.standardDialogsCount < entry.standardDialogs.size());\n\t\t\t\tentry.standardDialogsCount = 0;\n\t\t\t\tFileManipulateDialogInfo &bundleDialog = entry.standardDialogs[entry.standardDialogsCount++];\n\t\t\t\tbundleDialog.hTreeItem = entry.hTreeItem;\n\t\t\t\tbundleDialog.pEntry = &entry;\n\t\t\t\tbundleDialog.type = FileManipulateDialog_Bundle;\n\t\t\t\tupdateEntryInfoRef(hTree, bundleDialog.hTreeItem, bundleDialog); //Intentional so the tree item is linked to the dialog action.\n\t\t\t}\n\t\t\tbreak;\n\t\tcase FileContext_Resources:\n\t\t\t{\n\t\t\t\tEResourcesFileOpenStatus openStatus = static_cast<EResourcesFileOpenStatus>(result);\n\t\t\t\tfileEntryCountersByType[FileContext_Resources]++;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase FileContext_Generic:\n\t\t\t{\n\t\t\t\tEGenericFileOpenStatus openStatus = static_cast<EGenericFileOpenStatus>(result);\n\t\t\t\tfileEntryCountersByType[FileContext_Generic]++;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tupdateEntryName(hTree, entry.hTreeItem, formatNameFor(pContextInfo.get(), &entry));\n\t\tif (pendingFileEntriesByTask.empty())\n\t\t{\n\t\t\t//Forget the decompress target directory once all files are loaded.\n\t\t\tdecompressTargetDir_cancel = false;\n\t\t\tdecompressTargetDir.clear();\n\t\t}\n\t\tif (getSelectItem(hTree, entry.hTreeItem))\n\t\t{\n\t\t\t//If the item is selected and just finished loading, the manipulate dialog has to be created or notified.\n\t\t\tthis->onChangeFileSelection();\n\t\t}\n\t\telse\n\t\t{\n\t\t\t//The selection checkboxes have to be updated in case a new file has loaded that is not selected.\n\t\t\t// -> deselect IDC_CKSELALL, make type-specific check boxes indeterminate.\n\t\t\tstd::vector<ITreeParameter*> newSelection;\n\t\t\tMC_HTREELISTITEM selection = NULL;\n\t\t\twhile ((selection = MCTreeList_GetNextSelection(hTree, selection)) != NULL)\n\t\t\t{\n\t\t\t\tITreeParameter *pCurParam = getEntryParam(hTree, selection);\n\t\t\t\tnewSelection.push_back(pCurParam);\n\t\t\t}\n\t\t\tthis->doUpdateSelectionCheckboxes(newSelection);\n\t\t}\n\t\treturn true;\n\t}\n\treturn false;\n}\nvoid MainWindow2::OnFileEntryLoadFailure(ITask *pTask, std::string logText)\n{\n\tauto entryIt = pendingFileEntriesByTask.find(pTask);\n\tif (entryIt != pendingFileEntriesByTask.end())\n\t{\n\t\tFileEntryUIInfo &entry = *(entryIt->second);\n\t\tpendingFileEntriesByTask.erase(pTask);\n\t\tentry.failed = true;\n\t\tentry.pending = false;\n\t\tentry.pContextInfo = nullptr;\n\t\tlogText.swap(entry.openLogText);\n\n\t\tHWND hTree = GetDlgItem(this->hDlg, IDC_TREEFILES);\n\t\tupdateEntryName(hTree, entry.hTreeItem, std::string("Failed : ") + entry.getShortName());\n\t}\n}\nvoid MainWindow2::OnDecompressSuccess(BundleFileContextInfo::DecompressTask *pTask)\n{\n\tstd::shared_ptr<FileContextInfo> pContextInfo = std::static_pointer_cast<FileContextInfo, BundleFileContextInfo>(pTask->getFileContextInfo());\n\tif (!OnFileEntryLoadSuccess(pTask, pContextInfo, BundleFileOpenStatus_OK))\n\t\tpContext->RemoveContextInfo(pContextInfo.get());\n}\nvoid MainWindow2::OnDecompressFailure(BundleFileContextInfo::DecompressTask *pTask)\n{\n\tauto entryIt = pendingFileEntriesByTask.find(pTask);\n\tif (entryIt != pendingFileEntriesByTask.end())\n\t{\n\t\tFileEntryUIInfo &entry = *(entryIt->second);\n\t\tpendingFileEntriesByTask.erase(pTask);\n\t\tentry.failed = true;\n\t\tentry.pending = false;\n\t\tentry.pContextInfo = nullptr;\n\n\t\tHWND hTree = GetDlgItem(this->hDlg, IDC_TREEFILES);\n\t\tupdateEntryName(hTree, entry.hTreeItem, std::string("Failed : ") + entry.getShortName() + " (Compressed Bundle)");\n\t}\n\tpContext->RemoveContextInfo(pTask->getFileContextInfo().get());\n}\n\nMainWindow2::~MainWindow2(void)\n{\n\t//Remove objects that may unregister main window event handlers during destruction\n\t// before the event handlers list is cleared.\n\tdisposableCacheElements.clear();\n\tfileEntriesByContextInfo.clear();\n\tpendingFileEntriesByTask.clear();\n\tfileEntries.clear();\n\tmanipDlgTabs.clear();\n\n\tpDialogFactory.reset();\n\n\tpStatusTracker.reset();\n\n\tassert(eventHandlers.empty());\n}\n\nIFileManipulateDialog::IFileManipulateDialog()\n{}\nIFileManipulateDialog::~IFileManipulateDialog()\n{}\n'