b'{-# LANGUAGE CPP #-}\n{-# LANGUAGE BangPatterns #-}\nmodule Main where\n\nimport Control.Applicative (Const(Const, getConst), pure)\nimport Control.DeepSeq (rnf)\nimport Control.Exception (evaluate)\nimport Test.Tasty.Bench (bench, defaultMain, whnf, nf)\nimport Data.Functor.Identity (Identity(..))\nimport Data.List (foldl\')\nimport qualified Data.Map as M\nimport qualified Data.Map.Strict as MS\nimport Data.Map (alterF)\nimport Data.Maybe (fromMaybe)\nimport Data.Functor ((<$))\nimport Data.Coerce\nimport Prelude hiding (lookup)\n\nmain = do\n    let m = M.fromAscList elems :: M.Map Int Int\n        m_even = M.fromAscList elems_even :: M.Map Int Int\n        m_odd = M.fromAscList elems_odd :: M.Map Int Int\n    evaluate $ rnf [m, m_even, m_odd]\n    defaultMain\n        [ bench "lookup absent" $ whnf (lookup evens) m_odd\n        , bench "lookup present" $ whnf (lookup evens) m_even\n        , bench "map" $ whnf (M.map (+ 1)) m\n        , bench "map really" $ nf (M.map (+ 2)) m\n        , bench "<$" $ whnf ((1 :: Int) <$) m\n        , bench "<$ really" $ nf ((2 :: Int) <$) m\n        , bench "alterF lookup absent" $ whnf (atLookup evens) m_odd\n        , bench "alterF lookup present" $ whnf (atLookup evens) m_even\n        , bench "alterF no rules lookup absent" $ whnf (atLookupNoRules evens) m_odd\n        , bench "alterF no rules lookup present" $ whnf (atLookupNoRules evens) m_even\n        , bench "insert absent" $ whnf (ins elems_even) m_odd\n        , bench "insert present" $ whnf (ins elems_even) m_even\n        , bench "alterF insert absent" $ whnf (atIns elems_even) m_odd\n        , bench "alterF insert present" $ whnf (atIns elems_even) m_even\n        , bench "alterF no rules insert absent" $ whnf (atInsNoRules elems_even) m_odd\n        , bench "alterF no rules insert present" $ whnf (atInsNoRules elems_even) m_even\n        , bench "delete absent" $ whnf (del evens) m_odd\n        , bench "delete present" $ whnf (del evens) m\n        , bench "alterF delete absent" $ whnf (atDel evens) m_odd\n        , bench "alterF delete present" $ whnf (atDel evens) m\n        , bench "alterF no rules delete absent" $ whnf (atDelNoRules evens) m_odd\n        , bench "alterF no rules delete present" $ whnf (atDelNoRules evens) m\n        , bench "alter absent"  $ whnf (alt id evens) m_odd\n        , bench "alter insert"  $ whnf (alt (const (Just 1)) evens) m_odd\n        , bench "alter update"  $ whnf (alt id evens) m_even\n        , bench "alter delete"  $ whnf (alt (const Nothing) evens) m\n        , bench "alterF alter absent" $ whnf (atAlt id evens) m_odd\n        , bench "alterF alter insert" $ whnf (atAlt (const (Just 1)) evens) m_odd\n        , bench "alterF alter update" $ whnf (atAlt id evens) m_even\n        , bench "alterF alter delete" $ whnf (atAlt (const Nothing) evens) m\n        , bench "alterF no rules alter absent" $ whnf (atAltNoRules id evens) m_odd\n        , bench "alterF no rules alter insert" $ whnf (atAltNoRules (const (Just 1)) evens) m_odd\n        , bench "alterF no rules alter update" $ whnf (atAltNoRules id evens) m_even\n        , bench "alterF no rules alter delete" $ whnf (atAltNoRules (const Nothing) evens) m\n        , bench "insertWith absent" $ whnf (insWith elems_even) m_odd\n        , bench "insertWith present" $ whnf (insWith elems_even) m_even\n        , bench "insertWith\' absent" $ whnf (insWith\' elems_even) m_odd\n        , bench "insertWith\' present" $ whnf (insWith\' elems_even) m_even\n        , bench "insertWithKey absent" $ whnf (insWithKey elems_even) m_odd\n        , bench "insertWithKey present" $ whnf (insWithKey elems_even) m_even\n        , bench "insertWithKey\' absent" $ whnf (insWithKey\' elems_even) m_odd\n        , bench "insertWithKey\' present" $ whnf (insWithKey\' elems_even) m_even\n        , bench "insertLookupWithKey absent" $ whnf (insLookupWithKey elems_even) m_odd\n        , bench "insertLookupWithKey present" $ whnf (insLookupWithKey elems_even) m_even\n        , bench "insertLookupWithKey\' absent" $ whnf (insLookupWithKey\' elems_even) m_odd\n        , bench "insertLookupWithKey\' present" $ whnf (insLookupWithKey\' elems_even) m_even\n        , bench "mapWithKey" $ whnf (M.mapWithKey (+)) m\n        , bench "foldlWithKey" $ whnf (ins elems) m\n        , bench "foldlWithKey\'" $ whnf (M.foldlWithKey\' sum 0) m\n        , bench "foldrWithKey" $ whnf (M.foldrWithKey consPair []) m\n        , bench "foldrWithKey\'" $ whnf (M.foldrWithKey\' consPair []) m\n        , bench "update absent" $ whnf (upd Just evens) m_odd\n        , bench "update present" $ whnf (upd Just evens) m_even\n        , bench "update delete" $ whnf (upd (const Nothing) evens) m\n        , bench "updateLookupWithKey absent" $ whnf (upd\' Just evens) m_odd\n        , bench "updateLookupWithKey present" $ whnf (upd\' Just evens) m_even\n        , bench "updateLookupWithKey delete" $ whnf (upd\' (const Nothing) evens) m\n        , bench "mapMaybe" $ whnf (M.mapMaybe maybeDel) m\n        , bench "mapMaybeWithKey" $ whnf (M.mapMaybeWithKey (const maybeDel)) m\n        , bench "lookupIndex" $ whnf (lookupIndex keys) m\n        , bench "union" $ whnf (M.union m_even) m_odd\n        , bench "difference" $ whnf (M.difference m) m_even\n        , bench "intersection" $ whnf (M.intersection m) m_even\n        , bench "split" $ whnf (M.split (bound `div` 2)) m\n        , bench "fromList" $ whnf M.fromList elems\n        , bench "fromList-desc" $ whnf M.fromList (reverse elems)\n        , bench "fromAscList" $ whnf M.fromAscList elems\n        , bench "fromDistinctAscList" $ whnf M.fromDistinctAscList elems\n        , bench "minView" $ whnf (\\m\' -> case M.minViewWithKey m\' of {Nothing -> 0; Just ((k,v),m\'\') -> k+v+M.size m\'\'}) (M.fromAscList $ zip [1..10::Int] [100..110::Int])\n        ]\n  where\n    bound = 2^12\n    elems = zip keys values\n    elems_even = zip evens evens\n    elems_odd = zip odds odds\n    keys = [1..bound]\n    evens = [2,4..bound]\n    odds = [1,3..bound]\n    values = [1..bound]\n    sum k v1 v2 = k + v1 + v2\n    consPair k v xs = (k, v) : xs\n\nadd3 :: Int -> Int -> Int -> Int\nadd3 x y z = x + y + z\n{-# INLINE add3 #-}\n\nlookup :: [Int] -> M.Map Int Int -> Int\nlookup xs m = foldl\' (\\n k -> fromMaybe n (M.lookup k m)) 0 xs\n\natLookup :: [Int] -> M.Map Int Int -> Int\natLookup xs m = foldl\' (\\n k -> fromMaybe n (getConst (alterF Const k m))) 0 xs\n\nnewtype Consty a b = Consty { getConsty :: a }\ninstance Functor (Consty a) where\n  fmap _ (Consty a) = Consty a\n\natLookupNoRules :: [Int] -> M.Map Int Int -> Int\natLookupNoRules xs m = foldl\' (\\n k -> fromMaybe n (getConsty (alterF Consty k m))) 0 xs\n\nlookupIndex :: [Int] -> M.Map Int Int -> Int\nlookupIndex xs m = foldl\' (\\n k -> fromMaybe n (M.lookupIndex k m)) 0 xs\n\nins :: [(Int, Int)] -> M.Map Int Int -> M.Map Int Int\nins xs m = foldl\' (\\m (k, v) -> M.insert k v m) m xs\n\natIns :: [(Int, Int)] -> M.Map Int Int -> M.Map Int Int\natIns xs m = foldl\' (\\m (k, v) -> runIdentity (alterF (\\_ -> Identity (Just v)) k m)) m xs\n\nnewtype Ident a = Ident { runIdent :: a }\ninstance Functor Ident where\n  fmap = coerce\n\natInsNoRules :: [(Int, Int)] -> M.Map Int Int -> M.Map Int Int\natInsNoRules xs m = foldl\' (\\m (k, v) -> runIdent (alterF (\\_ -> Ident (Just v)) k m)) m xs\n\ninsWith :: [(Int, Int)] -> M.Map Int Int -> M.Map Int Int\ninsWith xs m = foldl\' (\\m (k, v) -> M.insertWith (+) k v m) m xs\n\ninsWithKey :: [(Int, Int)] -> M.Map Int Int -> M.Map Int Int\ninsWithKey xs m = foldl\' (\\m (k, v) -> M.insertWithKey add3 k v m) m xs\n\ninsWith\' :: [(Int, Int)] -> M.Map Int Int -> M.Map Int Int\ninsWith\' xs m = foldl\' (\\m (k, v) -> MS.insertWith (+) k v m) m xs\n\ninsWithKey\' :: [(Int, Int)] -> M.Map Int Int -> M.Map Int Int\ninsWithKey\' xs m = foldl\' (\\m (k, v) -> MS.insertWithKey add3 k v m) m xs\n\ndata PairS a b = PS !a !b\n\ninsLookupWithKey :: [(Int, Int)] -> M.Map Int Int -> (Int, M.Map Int Int)\ninsLookupWithKey xs m = let !(PS a b) = foldl\' f (PS 0 m) xs in (a, b)\n  where\n    f (PS n m) (k, v) = let !(n\', m\') = M.insertLookupWithKey add3 k v m\n                        in PS (fromMaybe 0 n\' + n) m\'\n\ninsLookupWithKey\' :: [(Int, Int)] -> M.Map Int Int -> (Int, M.Map Int Int)\ninsLookupWithKey\' xs m = let !(PS a b) = foldl\' f (PS 0 m) xs in (a, b)\n  where\n    f (PS n m) (k, v) = let !(n\', m\') = MS.insertLookupWithKey add3 k v m\n                        in PS (fromMaybe 0 n\' + n) m\'\n\ndel :: [Int] -> M.Map Int Int -> M.Map Int Int\ndel xs m = foldl\' (\\m k -> M.delete k m) m xs\n\natDel :: [Int] -> M.Map Int Int -> M.Map Int Int\natDel xs m = foldl\' (\\m k -> runIdentity (alterF (\\_ -> Identity Nothing) k m)) m xs\n\natDelNoRules :: [Int] -> M.Map Int Int -> M.Map Int Int\natDelNoRules xs m = foldl\' (\\m k -> runIdent (alterF (\\_ -> Ident Nothing) k m)) m xs\n\nupd :: (Int -> Maybe Int) -> [Int] -> M.Map Int Int -> M.Map Int Int\nupd f xs m = foldl\' (\\m k -> M.update f k m) m xs\n\nupd\' :: (Int -> Maybe Int) -> [Int] -> M.Map Int Int -> M.Map Int Int\nupd\' f xs m = foldl\' (\\m k -> snd $ M.updateLookupWithKey (\\_ a -> f a) k m) m xs\n\nalt :: (Maybe Int -> Maybe Int) -> [Int] -> M.Map Int Int -> M.Map Int Int\nalt f xs m = foldl\' (\\m k -> M.alter f k m) m xs\n\natAlt :: (Maybe Int -> Maybe Int) -> [Int] -> M.Map Int Int -> M.Map Int Int\natAlt f xs m = foldl\' (\\m k -> runIdentity (alterF (Identity . f) k m)) m xs\n\natAltNoRules :: (Maybe Int -> Maybe Int) -> [Int] -> M.Map Int Int -> M.Map Int Int\natAltNoRules f xs m = foldl\' (\\m k -> runIdent (alterF (Ident . f) k m)) m xs\n\nmaybeDel :: Int -> Maybe Int\nmaybeDel n | n `mod` 3 == 0 = Nothing\n           | otherwise      = Just n\n'