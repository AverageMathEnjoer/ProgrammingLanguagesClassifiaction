b'using System;\nusing System.Diagnostics;\nusing System.IO;\n\nusing i16 = System.Int16;\nusing i64 = System.Int64;\n\nusing u8 = System.Byte;\nusing u16 = System.UInt16;\nusing u32 = System.UInt32;\n\nusing Pgno = System.UInt32;\n\nnamespace CS_SQLite3\n{\n  using System.Text;\n  using DbPage = CSSQLite.PgHdr;\n  public partial class CSSQLite\n  {\n    /*\n    ** 2001 September 15\n    **\n    ** The author disclaims copyright to this source code.  In place of\n    ** a legal notice, here is a blessing:\n    **\n    **    May you do good and not evil.\n    **    May you find forgiveness for yourself and forgive others.\n    **    May you share freely, never taking more than you give.\n    **\n    *************************************************************************\n    ** This is the implementation of the page cache subsystem or "pager".\n    **\n    ** The pager is used to access a database disk file.  It implements\n    ** atomic commit and rollback through the use of a journal file that\n    ** is separate from the database file.  The pager also implements file\n    ** locking to prevent two processes from writing the same database\n    ** file simultaneously, or one process from reading the database while\n    ** another is writing.\n    **\n    ** @(#) $Id: pager.c,v 1.629 2009/08/10 17:48:57 drh Exp $\n    **\n    *************************************************************************\n    **  Included in SQLite3 port to C#-SQLite;  2008 Noah B Hart\n    **  C#-SQLite is an independent reimplementation of the SQLite software library\n    **\n    **  $Header$\n    *************************************************************************\n    */\n#if !SQLITE_OMIT_DISKIO\n    //#include "sqliteInt.h"\n\n\n    /*\n    ** Macros for troubleshooting.  Normally turned off\n    */\n#if TRACE\n\n    static bool sqlite3PagerTrace = false;  /* True to enable tracing */\n    //#define sqlite3DebugPrintf printf\n    //#define PAGERTRACE(X)     if( sqlite3PagerTrace ){ sqlite3DebugPrintf X; }\n    static void PAGERTRACE( string T, params object[] ap ) { if ( sqlite3PagerTrace )sqlite3DebugPrintf( T, ap ); }\n#else\n//#define PAGERTRACE(X)\nstatic void PAGERTRACE( string T, params object[] ap ) { }\n#endif\n\n    /*\n** The following two macros are used within the PAGERTRACE() macros above\n** to print out file-descriptors.\n**\n** PAGERID() takes a pointer to a Pager struct as its argument. The\n** associated file-descriptor is returned. FILEHANDLEID() takes an sqlite3_file\n** struct as its argument.\n*/\n    //#define PAGERID(p) ((int)(p.fd))\n    static int PAGERID( Pager p ) { return p.GetHashCode(); }\n\n    //#define FILEHANDLEID(fd) ((int)fd)\n    static int FILEHANDLEID( sqlite3_file fd ) { return fd.GetHashCode(); }\n\n    /*\n    ** The page cache as a whole is always in one of the following\n    ** states:\n    **\n    **   PAGER_UNLOCK        The page cache is not currently reading or\n    **                       writing the database file.  There is no\n    **                       data held in memory.  This is the initial\n    **                       state.\n    **\n    **   PAGER_SHARED        The page cache is reading the database.\n    **                       Writing is not permitted.  There can be\n    **                       multiple readers accessing the same database\n    **                       file at the same time.\n    **\n    **   PAGER_RESERVED      This process has reserved the database for writing\n    **                       but has not yet made any changes.  Only one process\n    **                       at a time can reserve the database.  The original\n    **                       database file has not been modified so other\n    **                       processes may still be reading the on-disk\n    **                       database file.\n    **\n    **   PAGER_EXCLUSIVE     The page cache is writing the database.\n    **                       Access is exclusive.  No other processes or\n    **                       threads can be reading or writing while one\n    **                       process is writing.\n    **\n    **   PAGER_SYNCED        The pager moves to this state from PAGER_EXCLUSIVE\n    **                       after all dirty pages have been written to the\n    **                       database file and the file has been synced to\n    **                       disk. All that remains to do is to remove or\n    **                       truncate the journal file and the transaction\n    **                       will be committed.\n    **\n    ** The page cache comes up in PAGER_UNLOCK.  The first time a\n    ** sqlite3PagerGet() occurs, the state transitions to PAGER_SHARED.\n    ** After all pages have been released using sqlite_page_unref(),\n    ** the state transitions back to PAGER_UNLOCK.  The first time\n    ** that sqlite3PagerWrite() is called, the state transitions to\n    ** PAGER_RESERVED.  (Note that sqlite3PagerWrite() can only be\n    ** called on an outstanding page which means that the pager must\n    ** be in PAGER_SHARED before it transitions to PAGER_RESERVED.)\n    ** PAGER_RESERVED means that there is an open rollback journal.\n    ** The transition to PAGER_EXCLUSIVE occurs before any changes\n    ** are made to the database file, though writes to the rollback\n    ** journal occurs with just PAGER_RESERVED.  After an sqlite3PagerRollback()\n    ** or sqlite3PagerCommitPhaseTwo(), the state can go back to PAGER_SHARED,\n    ** or it can stay at PAGER_EXCLUSIVE if we are in exclusive access mode.\n    */\n    const int PAGER_UNLOCK = 0;\n    const int PAGER_SHARED = 1;   /* same as SHARED_LOCK */\n    const int PAGER_RESERVED = 2;   /* same as RESERVED_LOCK */\n    const int PAGER_EXCLUSIVE = 4;   /* same as EXCLUSIVE_LOCK */\n    const int PAGER_SYNCED = 5;\n\n    /*\n    ** A macro used for invoking the codec if there is one\n    */\n#if SQLITE_HAS_CODEC\n//# define CODEC1(P,D,N,X,E) \\\nif( P->xCodec && P->xCodec(P->pCodec,D,N,X)==0 ){ E; }\n//# define CODEC2(P,D,N,X,E,O) \\\nif( P->xCodec==0 ){ O=(char*)D; }else \\\nif( (O=(char*)(P->xCodec(P->pCodec,D,N,X)))==0 ){ E; }\n#else\n    //# define CODEC1(P,D,N,X,E)   /* NO-OP */\n    //# define CODEC2(P,D,N,X,E,O) O=(char*)D\n    static void CODEC2( Pager P, byte[] D, uint N, int X, int E, ref byte[] O ) { O = D; }\n#endif\n\n    /*\n** The maximum allowed sector size. 64KiB. If the xSectorsize() method \n** returns a value larger than this, then MAX_SECTOR_SIZE is used instead.\n** This could conceivably cause corruption following a power failure on\n** such a system. This is currently an undocumented limit.\n*/\n    //#define MAX_SECTOR_SIZE 0x10000\n    const int MAX_SECTOR_SIZE = 0x10000;\n\n    /*\n    ** An instance of the following structure is allocated for each active\n    ** savepoint and statement transaction in the system. All such structures\n    ** are stored in the Pager.aSavepoint[] array, which is allocated and\n    ** resized using sqlite3Realloc().\n    **\n    ** When a savepoint is created, the PagerSavepoint.iHdrOffset field is\n    ** set to 0. If a journal-header is written into the main journal while\n    ** the savepoint is active, then iHdrOffset is set to the byte offset\n    ** immediately following the last journal record written into the main\n    ** journal before the journal-header. This is required during savepoint\n    ** rollback (see pagerPlaybackSavepoint()).\n    */\n    //typedef struct PagerSavepoint PagerSavepoint;\n    public class PagerSavepoint\n    {\n      public i64 iOffset;                 /* Starting offset in main journal */\n      public i64 iHdrOffset;              /* See above */\n      public Bitvec pInSavepoint;         /* Set of pages in this savepoint */\n      public Pgno nOrig;                  /* Original number of pages in file */\n      public Pgno iSubRec;                /* Index of first record in sub-journal */\n      public static implicit operator bool( PagerSavepoint b )\n      {\n        return ( b != null );\n      }\n    };\n\n\n    /*\n    ** A open page cache is an instance of the following structure.\n    **\n    ** errCode\n    **\n    **   Pager.errCode may be set to SQLITE_IOERR, SQLITE_CORRUPT, or\n    **   or SQLITE_FULL. Once one of the first three errors occurs, it persists\n    **   and is returned as the result of every major pager API call.  The\n    **   SQLITE_FULL return code is slightly different. It persists only until the\n    **   next successful rollback is performed on the pager cache. Also,\n    **   SQLITE_FULL does not affect the sqlite3PagerGet() and sqlite3PagerLookup()\n    **   APIs, they may still be used successfully.\n    **\n    ** dbSizeValid, dbSize, dbOrigSize, dbFileSize\n    **\n    **   Managing the size of the database file in pages is a little complicated.\n    **   The variable Pager.dbSize contains the number of pages that the database\n    **   image currently contains. As the database image grows or shrinks this\n    **   variable is updated. The variable Pager.dbFileSize contains the number\n    **   of pages in the database file. This may be different from Pager.dbSize\n    **   if some pages have been appended to the database image but not yet written\n    **   out from the cache to the actual file on disk. Or if the image has been\n    **   truncated by an incremental-vacuum operation. The Pager.dbOrigSize variable\n    **   contains the number of pages in the database image when the current\n    **   transaction was opened. The contents of all three of these variables is\n    **   only guaranteed to be correct if the boolean Pager.dbSizeValid is true.\n    **\n    **   TODO: Under what conditions is dbSizeValid set? Cleared?\n    **\n    ** changeCountDone\n    **\n    **   This boolean variable is used to make sure that the change-counter\n    **   (the 4-byte header field at byte offset 24 of the database file) is\n    **   not updated more often than necessary.\n    **\n    **   It is set to true when the change-counter field is updated, which\n    **   can only happen if an exclusive lock is held on the database file.\n    **   It is cleared (set to false) whenever an exclusive lock is\n    **   relinquished on the database file. Each time a transaction is committed,\n    **   The changeCountDone flag is inspected. If it is true, the work of\n    **   updating the change-counter is omitted for the current transaction.\n    **\n    **   This mechanism means that when running in exclusive mode, a connection\n    **   need only update the change-counter once, for the first transaction\n    **   committed.\n    **\n    ** dbModified\n    **\n    **   The dbModified flag is set whenever a database page is dirtied.\n    **   It is cleared at the end of each transaction.\n    **\n    **   It is used when committing or otherwise ending a transaction. If\n    **   the dbModified flag is clear then less work has to be done.\n    **\n    ** journalStarted\n    **\n    **   This flag is set whenever the the main journal is synced.\n    **\n    **   The point of this flag is that it must be set after the\n    **   first journal header in a journal file has been synced to disk.\n    **   After this has happened, new pages appended to the database\n    **   do not need the PGHDR_NEED_SYNC flag set, as they do not need\n    **   to wait for a journal sync before they can be written out to\n    **   the database file (see function pager_write()).\n    **\n    ** setMaster\n    **\n    **   This variable is used to ensure that the master journal file name\n    **   (if any) is only written into the journal file once.\n    **\n    **   When committing a transaction, the master journal file name (if any)\n    **   may be written into the journal file while the pager is still in\n    **   PAGER_RESERVED state (see CommitPhaseOne() for the action). It\n    **   then attempts to upgrade to an exclusive lock. If this attempt\n    **   fails, then SQLITE_BUSY may be returned to the user and the user\n    **   may attempt to commit the transaction again later (calling\n    **   CommitPhaseOne() again). This flag is used to ensure that the\n    **   master journal name is only written to the journal file the first\n    **   time CommitPhaseOne() is called.\n    **\n    ** doNotSync\n    **\n    **   This variable is set and cleared by sqlite3PagerWrite().\n    **\n    ** needSync\n    **\n    **   TODO: It might be easier to set this variable in writeJournalHdr()\n    **   and writeMasterJournal() only. Change its meaning to "unsynced data\n    **   has been written to the journal".\n    **\n    ** subjInMemory\n    **\n    **   This is a boolean variable. If true, then any required sub-journal\n    **   is opened as an in-memory journal file. If false, then in-memory\n    **   sub-journals are only used for in-memory pager files.\n    */\n    public class Pager\n    {\n      public sqlite3_vfs pVfs;           /* OS functions to use for IO */\n      public bool exclusiveMode;         /* Boolean. True if locking_mode==EXCLUSIVE */\n      public u8 journalMode;             /* On of the PAGER_JOURNALMODE_* values */\n      public u8 useJournal;              /* Use a rollback journal on this file */\n      public u8 noReadlock;              /* Do not bother to obtain readlocks */\n      public bool noSync;                /* Do not sync the journal if true */\n      public bool fullSync;              /* Do extra syncs of the journal for robustness */\n      public int sync_flags;             /* One of SYNC_NORMAL or SYNC_FULL */\n      public bool tempFile;              /* zFilename is a temporary file */\n      public bool readOnly;              /* True for a read-only database */\n      public bool alwaysRollback;        /* Disable DontRollback() for all pages */\n      public u8 memDb;                   /* True to inhibit all file I/O */\n      /* The following block contains those class members that are dynamically\n      ** modified during normal operations. The other variables in this structure\n      ** are either constant throughout the lifetime of the pager, or else\n      ** used to store configuration parameters that affect the way the pager\n      ** operates.\n      **\n      ** The \'state\' variable is described in more detail along with the\n      ** descriptions of the values it may take - PAGER_UNLOCK etc. Many of the\n      ** other variables in this block are described in the comment directly\n      ** above this class definition.\n      */\n      public u8 state;                   /* PAGER_UNLOCK, _SHARED, _RESERVED, etc. */\n      public bool dbModified;            /* True if there are any changes to the Db */\n      public bool needSync;              /* True if an fsync() is needed on the journal */\n      public bool journalStarted;        /* True if header of journal is synced */\n      public bool changeCountDone;       /* Set after incrementing the change-counter */\n      public int setMaster;              /* True if a m-j name has been written to jrnl */\n      public bool doNotSync;             /* Boolean. While true, do not spill the cache */\n      public bool dbSizeValid;           /* Set when dbSize is correct */\n      public u8 subjInMemory;            /* True to use in-memory sub-journals */\n      public Pgno dbSize;                /* Number of pages in the database */\n      public Pgno dbOrigSize;            /* dbSize before the current transaction */\n      public Pgno dbFileSize;            /* Number of pages in the database file */\n      public int errCode;                /* One of several kinds of errors */\n      public int nRec;                   /* Pages journalled since last j-header written */\n      public u32 cksumInit;              /* Quasi-random value added to every checksum */\n      public u32 nSubRec;                /* Number of records written to sub-journal */\n      public Bitvec pInJournal;          /* One bit for each page in the database file */\n      public sqlite3_file fd;            /* File descriptor for database */\n      public sqlite3_file jfd;           /* File descriptor for main journal */\n      public sqlite3_file sjfd;          /* File descriptor for sub-journal */\n      public i64 journalOff;             /* Current write offset in the journal file */\n      public i64 journalHdr;             /* Byte offset to previous journal header */\n      public PagerSavepoint[] aSavepoint;/* Array of active savepoints */\n      public int nSavepoint;             /* Number of elements in aSavepoint[] */\n      public u8[] dbFileVers = new u8[16];/* Changes whenever database file changes */\n      public u32 sectorSize;             /* Assumed sector size during rollback */\n\n      public u16 nExtra;                 /* Add this many bytes to each in-memory page */\n      public i16 nReserve;               /* Number of unused bytes at end of each page */\n      public u32 vfsFlags;               /* Flags for sqlite3_vfs.xOpen() */\n      public int pageSize;               /* Number of bytes in a page */\n      public Pgno mxPgno;                /* Maximum allowed size of the database */\n      public string zFilename;           /* Name of the database file */\n      public string zJournal;            /* Name of the journal file */\n      public dxBusyHandler xBusyHandler; /* Function to call when busy */\n      public object pBusyHandlerArg;     /* Context argument for xBusyHandler */\n#if SQLITE_TEST || DEBUG\n      public int nHit, nMiss;              /* Cache hits and missing */\n      public int nRead, nWrite;            /* Database pages read/written */\n#else\n      public int nHit;\n#endif\n      public dxReiniter xReiniter; //(DbPage*,int);/* Call this routine when reloading pages */\n#if SQLITE_HAS_CODEC\nvoid *(*xCodec)(void*,void*,Pgno,int); /* Routine for en/decoding data */\nvoid (*xCodecSizeChng)(void*,int,int); /* Notify of page size changes */\nvoid (*xCodecFree)(void*);             /* Destructor for the codec */\nvoid *pCodec;               /* First argument to xCodec... methods */\n#endif\n      public byte[] pTmpSpace;               /* Pager.pageSize bytes of space for tmp use */\n      public i64 journalSizeLimit;           /* Size limit for persistent journal files */\n      public PCache pPCache;                 /* Pointer to page cache object */\n      public sqlite3_backup pBackup;         /* Pointer to list of ongoing backup processes */\n    };\n\n    /*\n    ** The following global variables hold counters used for\n    ** testing purposes only.  These variables do not exist in\n    ** a non-testing build.  These variables are not thread-safe.\n    */\n#if SQLITE_TEST\n    //static int sqlite3_pager_readdb_count = 0;    /* Number of full pages read from DB */\n    //static int sqlite3_pager_writedb_count = 0;   /* Number of full pages written to DB */\n    //static int sqlite3_pager_writej_count = 0;    /* Number of pages written to journal */\n    static void PAGER_INCR( ref int v ) { v++; }\n#else\n//# define PAGER_INCR(v)\n    static void PAGER_INCR(ref int v) {}\n#endif\n\n    /*\n** Journal files begin with the following magic string.  The data\n** was obtained from /dev/random.  It is used only as a sanity check.\n**\n** Since version 2.8.0, the journal format contains additional sanity\n** checking information.  If the power fails while the journal is being\n** written, semi-random garbage data might appear in the journal\n** file after power is restored.  If an attempt is then made\n** to roll the journal back, the database could be corrupted.  The additional\n** sanity checking data is an attempt to discover the garbage in the\n** journal and ignore it.\n**\n** The sanity checking information for the new journal format consists\n** of a 32-bit checksum on each page of data.  The checksum covers both\n** the page number and the pPager.pageSize bytes of data for the page.\n** This cksum is initialized to a 32-bit random value that appears in the\n** journal file right after the header.  The random initializer is important,\n** because garbage data that appears at the end of a journal is likely\n** data that was once in other files that have now been deleted.  If the\n** garbage data came from an obsolete journal file, the checksums might\n** be correct.  But by initializing the checksum to random value which\n** is different for every journal, we minimize that risk.\n*/\n    static byte[] aJournalMagic = new byte[] {\n0xd9, 0xd5, 0x05, 0xf9, 0x20, 0xa1, 0x63, 0xd7,\n};\n    /*\n    ** The size of the of each page record in the journal is given by\n    ** the following macro.\n    */\n    //#define JOURNAL_PG_SZ(pPager)  ((pPager.pageSize) + 8)\n    static int JOURNAL_PG_SZ( Pager pPager )\n    { return ( pPager.pageSize + 8 ); }\n\n    /*\n    ** The journal header size for this pager. This is usually the same\n    ** size as a single disk sector. See also setSectorSize().\n    */\n    //#define JOURNAL_HDR_SZ(pPager) (pPager.sectorSize)\n    static u32 JOURNAL_HDR_SZ( Pager pPager )\n    { return ( pPager.sectorSize ); }\n\n    /*\n    ** The macro MEMDB is true if we are dealing with an in-memory database.\n    ** We do this as a macro so that if the SQLITE_OMIT_MEMORYDB macro is set,\n    ** the value of MEMDB will be a constant and the compiler will optimize\n    ** out code that would never execute.\n    */\n#if SQLITE_OMIT_MEMORYDB\n//# define MEMDB 0\n    const int MEMDB = 0;\n#else\n    //# define MEMDB pPager.memDb\n#endif\n\n    /*\n** The maximum legal page number is (2^31 - 1).\n*/\n    //#define PAGER_MAX_PGNO 2147483647\n    const int PAGER_MAX_PGNO = 2147483647;\n\n#if !NDEBUG\n    /*\n** Usage:\n**\n**   assert( assert_pager_state(pPager) );\n*/\n    static bool assert_pager_state( Pager pPager )\n    {\n\n      /* A temp-file is always in PAGER_EXCLUSIVE or PAGER_SYNCED state. */\n      Debug.Assert( pPager.tempFile == false || pPager.state >= PAGER_EXCLUSIVE );\n\n      /* The changeCountDone flag is always set for temp-files */\n      Debug.Assert( pPager.tempFile == false || pPager.changeCountDone );\n\n      return true;\n    }\n#else\n    static bool assert_pager_state(Pager pPager) { return true; }\n#endif\n\n    /*\n** Return true if it is necessary to write page *pPg into the sub-journal.\n** A page needs to be written into the sub-journal if there exists one\n** or more open savepoints for which:\n**\n**   * The page-number is less than or equal to PagerSavepoint.nOrig, and\n**   * The bit corresponding to the page-number is not set in\n**     PagerSavepoint.pInSavepoint.\n*/\n    static bool subjRequiresPage( PgHdr pPg )\n    {\n      u32 pgno = pPg.pgno;\n      Pager pPager = pPg.pPager;\n      int i;\n      for ( i = 0 ; i < pPager.nSavepoint ; i++ )\n      {\n        PagerSavepoint p = pPager.aSavepoint[i];\n        if ( p.nOrig >= pgno && 0 == sqlite3BitvecTest( p.pInSavepoint, pgno ) )\n        {\n          return true;\n        }\n      }\n      return false;\n    }\n\n    /*\n    ** Return true if the page is already in the journal file.\n    */\n    static bool pageInJournal( PgHdr pPg )\n    {\n      return sqlite3BitvecTest( pPg.pPager.pInJournal, pPg.pgno ) != 0;\n    }\n\n    /*\n    ** Read a 32-bit integer from the given file descriptor.  Store the integer\n    ** that is read in pRes.  Return SQLITE_OK if everything worked, or an\n    ** error code is something goes wrong.\n    **\n    ** All values are stored on disk as big-endian.\n    */\n    static int read32bits( sqlite3_file fd, int offset, ref int pRes )\n    {\n      u32 u32_pRes = 0;\n      int rc = read32bits( fd, offset, ref u32_pRes );\n      pRes = (int)u32_pRes; return rc;\n    }\n    static int read32bits( sqlite3_file fd, i64 offset, ref u32 pRes )\n    {\n      int rc = read32bits( fd, (int)offset, ref pRes );\n      return rc;\n    }\n    static int read32bits( sqlite3_file fd, int offset, ref u32 pRes )\n    {\n      byte[] ac = new byte[4];\n      int rc = sqlite3OsRead( fd, ac, ac.Length, offset );\n      if ( rc == SQLITE_OK )\n      {\n        pRes = sqlite3Get4byte( ac );\n      }\n      return rc;\n    }\n\n    /*\n    ** Write a 32-bit integer into a string buffer in big-endian byte order.\n    */\n    //#define put32bits(A,B)  sqlite3sqlite3Put4byte((u8*)A,B)\n    static void put32bits( string ac, int offset, int val )\n    {\n      byte[] A = new byte[4];\n      A[0] = (byte)ac[offset + 0];\n      A[1] = (byte)ac[offset + 1];\n      A[2] = (byte)ac[offset + 2];\n      A[3] = (byte)ac[offset + 3];\n      sqlite3Put4byte( A, 0, val );\n    }\n    static void put32bits( byte[] ac, int offset, int val )\n    { sqlite3Put4byte( ac, offset, (u32)val ); }\n    static void put32bits( byte[] ac, u32 val )\n    { sqlite3Put4byte( ac, 0U, val ); }\n    static void put32bits( byte[] ac, int offset, u32 val )\n    { sqlite3Put4byte( ac, offset, val ); }\n\n    /*\n    ** Write a 32-bit integer into the given file descriptor.  Return SQLITE_OK\n    ** on success or an error code is something goes wrong.\n    */\n    static int write32bits( sqlite3_file fd, i64 offset, u32 val )\n    {\n      byte[] ac = new byte[4];\n      put32bits( ac, val );\n      return sqlite3OsWrite( fd, ac, 4, offset );\n    }\n\n    /*\n    ** The argument to this macro is a file descriptor (type sqlite3_file*).\n    ** Return 0 if it is not open, or non-zero (but not 1) if it is.\n    **\n    ** This is so that expressions can be written as:\n    **\n    **   if( isOpen(pPager.jfd) ){ ...\n    **\n    ** instead of\n    **\n    **   if( pPager.jfd->pMethods ){ ...\n    */\n    //#define isOpen(pFd) ((pFd)->pMethods)\n    static bool isOpen( sqlite3_file pFd ) { return pFd.pMethods != null; }\n\n    /*\n    ** If file pFd is open, call sqlite3OsUnlock() on it.\n    */\n    static int osUnlock( sqlite3_file pFd, int eLock )\n    {\n      if ( pFd.pMethods == null )\n      {\n        return SQLITE_OK;\n      }\n      return sqlite3OsUnlock( pFd, eLock );\n    }\n\n    /*\n    ** This function determines whether or not the atomic-write optimization\n    ** can be used with this pager. The optimization can be used if:\n    **\n    **  (a) the value returned by OsDeviceCharacteristics() indicates that\n    **      a database page may be written atomically, and\n    **  (b) the value returned by OsSectorSize() is less than or equal\n    **      to the page size.\n    **\n    ** The optimization is also always enabled for temporary files. It is\n    ** an error to call this function if pPager is opened on an in-memory\n    ** database.\n    **\n    ** If the optimization cannot be used, 0 is returned. If it can be used,\n    ** then the value returned is the size of the journal file when it\n    ** contains rollback data for exactly one page.\n    */\n#if SQLITE_ENABLE_ATOMIC_WRITE\nstatic int jrnlBufferSize(Pager *pPager){\nassert( 0==MEMDB );\nif( !pPager.tempFile ){\nint dc;                           /* Device characteristics */\nint nSector;                      /* Sector size */\nint szPage;                       /* Page size */\n\nassert( isOpen(pPager.fd) );\ndc = sqlite3OsDeviceCharacteristics(pPager.fd);\nnSector = pPager.sectorSize;\nszPage = pPager.pageSize;\n\nassert(SQLITE_IOCAP_ATOMIC512==(512>>8));\nassert(SQLITE_IOCAP_ATOMIC64K==(65536>>8));\nif( 0==(dc&(SQLITE_IOCAP_ATOMIC|(szPage>>8)) || nSector>szPage) ){\nreturn 0;\n}\n}\n\nreturn JOURNAL_HDR_SZ(pPager) + JOURNAL_PG_SZ(pPager);\n}\n#endif\n\n    /*\n** If SQLITE_CHECK_PAGES is defined then we do some sanity checking\n** on the cache using a hash function.  This is used for testing\n** and debugging only.\n*/\n#if SQLITE_CHECK_PAGES\n/*\n** Return a 32-bit hash of the page data for pPage.\n*/\nstatic u32 pager_datahash(int nByte, unsigned char pData){\nu32 hash = 0;\nint i;\nfor(i=0; i<nByte; i++){\nhash = (hash*1039) + pData[i];\n}\nreturn hash;\n}\nstatic void pager_pagehash(PgHdr pPage){\nreturn pager_datahash(pPage.pPager.pageSize, (unsigned char *)pPage.pData);\n}\nstatic u32 pager_set_pagehash(PgHdr pPage){\npPage.pageHash = pager_pagehash(pPage);\n}\n\n/*\n** The CHECK_PAGE macro takes a PgHdr* as an argument. If SQLITE_CHECK_PAGES\n** is defined, and NDEBUG is not defined, an Debug.Assert() statement checks\n** that the page is either dirty or still matches the calculated page-hash.\n*/\n//#define CHECK_PAGE(x) checkPage(x)\nstatic void checkPage(PgHdr pPg){\nPager pPager = pPg.pPager;\nDebug.Assert( !pPg.pageHash || pPager.errCode\n|| (pPg.flags&PGHDR_DIRTY) || pPg.pageHash==pager_pagehash(pPg) );\npPg.pageHash==pager_pagehash(pPg) );\n}\n\n#else\n    //#define pager_datahash(X,Y)  0\n    static int pager_datahash( int X, byte[] Y ) { return 0; }\n\n    //#define pager_pagehash(X)  0\n    static int pager_pagehash( PgHdr X ) { return 0; }\n\n    //#define CHECK_PAGE(x)\n#endif //* SQLITE_CHECK_PAGES */\n\n\n    /*\n** When this is called the journal file for pager pPager must be open.\n** This function attempts to read a master journal file name from the\n** end of the file and, if successful, copies it into memory supplied\n** by the caller. See comments above writeMasterJournal() for the format\n** used to store a master journal file name at the end of a journal file.\n**\n** zMaster must point to a buffer of at least nMaster bytes allocated by\n** the caller. This should be sqlite3_vfs.mxPathname+1 (to ensure there is\n** enough space to write the master journal name). If the master journal\n** name in the journal is longer than nMaster bytes (including a\n** nul-terminator), then this is handled as if no master journal name\n** were present in the journal.\n**\n** If a master journal file name is present at the end of the journal\n** file, then it is copied into the buffer pointed to by zMaster. A\n** nul-terminator byte is appended to the buffer following the master\n** journal file name.\n**\n** If it is determined that no master journal file name is present\n** zMaster[0] is set to 0 and SQLITE_OK returned.\n**\n** If an error occurs while reading from the journal file, an SQLite\n** error code is returned.\n*/\n    static int readMasterJournal( sqlite3_file pJrnl, byte[] zMaster, u32 nMaster )\n    {\n      int rc;                       /* Return code */\n      int len = 0;                  /* Length in bytes of master journal name */\n      int szJ = 0;                  /* Total size in bytes of journal file pJrnl */\n      int cksum = 0;                /* MJ checksum value read from journal */\n      int u;                        /* Unsigned loop counter */\n      byte[] aMagic = new byte[8];  /* A buffer to hold the magic header */\n\n      zMaster[0] = 0;\n\n      if ( SQLITE_OK != ( rc = sqlite3OsFileSize( pJrnl, ref szJ ) )\n      || szJ < 16\n      || SQLITE_OK != ( rc = read32bits( pJrnl, szJ - 16, ref len ) )\n      || len >= nMaster\n      || SQLITE_OK != ( rc = read32bits( pJrnl, szJ - 12, ref cksum ) )\n      || SQLITE_OK != ( rc = sqlite3OsRead( pJrnl, aMagic, 8, szJ - 8 ) )\n      || memcmp( aMagic, aJournalMagic, 8 ) != 0\n      || SQLITE_OK != ( rc = sqlite3OsRead( pJrnl, zMaster, len, szJ - 16 - len ) )\n      )\n      {\n        return rc;\n      }\n\n      /* See if the checksum matches the master journal name */\n      for ( u = 0 ; u < len ; u++ )\n      {\n        cksum -= zMaster[u];\n      }\n      if ( cksum != 0 )\n      {\n        /* If the checksum doesn\'t add up, then one or more of the disk sectors\n        ** containing the master journal filename is corrupted. This means\n        ** definitely roll back, so just return SQLITE_OK and report a (nul)\n        ** master-journal filename.\n        */\n        len = 0;\n      }\n      if ( len == 0 ) zMaster[0] = 0;\n\n      return SQLITE_OK;\n    }\n\n    /*\n    ** Return the offset of the sector boundary at or immediately\n    ** following the value in pPager.journalOff, assuming a sector\n    ** size of pPager.sectorSize bytes.\n    **\n    ** i.e for a sector size of 512:\n    **\n    **   Pager.journalOff          Return value\n    **   ---------------------------------------\n    **   0                         0\n    **   512                       512\n    **   100                       512\n    **   2000                      2048\n    **\n    */\n    static i64 journalHdrOffset( Pager pPager )\n    {\n      i64 offset = 0;\n      i64 c = pPager.journalOff;\n      if ( c != 0 )\n      {\n        offset = (int)( ( ( c - 1 ) / pPager.sectorSize + 1 ) * pPager.sectorSize );//offset = ((c-1)/JOURNAL_HDR_SZ(pPager) + 1) * JOURNAL_HDR_SZ(pPager);\n      }\n      Debug.Assert( offset % pPager.sectorSize == 0 ); //Debug.Assert(offset % JOURNAL_HDR_SZ(pPager) == 0);\n      Debug.Assert( offset >= c );\n      Debug.Assert( ( offset - c ) < pPager.sectorSize );//Debug.Assert( (offset-c)<JOURNAL_HDR_SZ(pPager) );\n      return offset;\n    }\n    static void seekJournalHdr( Pager pPager )\n    {\n      pPager.journalOff = journalHdrOffset( pPager );\n    }\n\n    /*\n    ** The journal file must be open when this function is called.\n    **\n    ** This function is a no-op if the journal file has not been written to\n    ** within the current transaction (i.e. if Pager.journalOff==0).\n    **\n    ** If doTruncate is non-zero or the Pager.journalSizeLimit variable is\n    ** set to 0, then truncate the journal file to zero bytes in size. Otherwise,\n    ** zero the 28-byte header at the start of the journal file. In either case,\n    ** if the pager is not in no-sync mode, sync the journal file immediately\n    ** after writing or truncating it.\n    **\n    ** If Pager.journalSizeLimit is set to a positive, non-zero value, and\n    ** following the truncation or zeroing described above the size of the\n    ** journal file in bytes is larger than this value, then truncate the\n    ** journal file to Pager.journalSizeLimit bytes. The journal file does\n    ** not need to be synced following this operation.\n    **\n    ** If an IO error occurs, abandon processing and return the IO error code.\n    ** Otherwise, return SQLITE_OK.\n    */\n    static int zeroJournalHdr( Pager pPager, int doTruncate )\n    {\n      int rc = SQLITE_OK;                               /* Return code */\n      Debug.Assert( isOpen( pPager.jfd ) );\n\n      if ( pPager.journalOff != 0 )\n      {\n        i64 iLimit = pPager.journalSizeLimit;           /* Local cache of jsl */\n        IOTRACE( "JZEROHDR %p\\n", pPager );\n        if ( doTruncate != 0 || iLimit == 0 )\n        {\n          rc = sqlite3OsTruncate( pPager.jfd, 0 );\n        }\n        else\n        {\n          byte[] zeroHdr = new byte[28];// = {0};\n          rc = sqlite3OsWrite( pPager.jfd, zeroHdr, zeroHdr.Length, 0 );\n        }\n        if ( rc == SQLITE_OK && !pPager.noSync )\n        {\n          rc = sqlite3OsSync( pPager.jfd, SQLITE_SYNC_DATAONLY | pPager.sync_flags );\n        }\n\n        /* At this point the transaction is committed but the write lock\n        ** is still held on the file. If there is a size limit configured for\n        ** the persistent journal and the journal file currently consumes more\n        ** space than that limit allows for, truncate it now. There is no need\n        ** to sync the file following this operation.\n        */\n        if ( rc == SQLITE_OK && iLimit > 0 )\n        {\n          int sz = 0;\n          rc = sqlite3OsFileSize( pPager.jfd, ref sz );\n          if ( rc == SQLITE_OK && sz > iLimit )\n          {\n            rc = sqlite3OsTruncate( pPager.jfd, (int)iLimit );\n          }\n        }\n      }\n      return rc;\n    }\n\n    /*\n    ** The journal file must be open when this routine is called. A journal\n    ** header (JOURNAL_HDR_SZ bytes) is written into the journal file at the\n    ** current location.\n    **\n    ** The format for the journal header is as follows:\n    ** - 8 bytes: Magic identifying journal format.\n    ** - 4 bytes: Number of records in journal, or -1 no-sync mode is on.\n    ** - 4 bytes: Random number used for page hash.\n    ** - 4 bytes: Initial database page count.\n    ** - 4 bytes: Sector size used by the process that wrote this journal.\n    ** - 4 bytes: Database page size.\n    **\n    ** Followed by (JOURNAL_HDR_SZ - 28) bytes of unused space.\n    */\n    static int writeJournalHdr( Pager pPager )\n    {\n\n      int rc = SQLITE_OK;                 /* Return code */\n      byte[] zHeader = pPager.pTmpSpace;  /* Temporary space used to build header */\n      u32 nHeader = (u32)pPager.pageSize; /* Size of buffer pointed to by zHeader */\n      u32 nWrite;                         /* Bytes of header sector written */\n      int ii;                             /* Loop counter */\n\n      Debug.Assert( isOpen( pPager.jfd ) );      /* Journal file must be open. */\n\n      if ( nHeader > JOURNAL_HDR_SZ( pPager ) )\n      {\n        nHeader = JOURNAL_HDR_SZ( pPager );\n      }\n      /* If there are active savepoints and any of them were created\n      ** since the most recent journal header was written, update the\n      ** PagerSavepoint.iHdrOffset fields now.\n      */\n      for ( ii = 0 ; ii < pPager.nSavepoint ; ii++ )\n      {\n        if ( pPager.aSavepoint[ii].iHdrOffset == 0 )\n        {\n          pPager.aSavepoint[ii].iHdrOffset = pPager.journalOff;\n        }\n      }\n      pPager.journalHdr = pPager.journalOff = journalHdrOffset( pPager );\n\n      /*\n      ** Write the nRec Field - the number of page records that follow this\n      ** journal header. Normally, zero is written to this value at this time.\n      ** After the records are added to the journal (and the journal synced,\n      ** if in full-sync mode), the zero is overwritten with the true number\n      ** of records (see syncJournal()).\n      **\n      ** A faster alternative is to write 0xFFFFFFFF to the nRec field. When\n      ** reading the journal this value tells SQLite to assume that the\n      ** rest of the journal file contains valid page records. This assumption\n      ** is dangerous, as if a failure occurred whilst writing to the journal\n      ** file it may contain some garbage data. There are two scenarios\n      ** where this risk can be ignored:\n      **\n      **   * When the pager is in no-sync mode. Corruption can follow a\n      **     power failure in this case anyway.\n      **\n      **   * When the SQLITE_IOCAP_SAFE_APPEND flag is set. This guarantees\n      **     that garbage data is never appended to the journal file.\n      */\n      Debug.Assert( isOpen( pPager.fd ) || pPager.noSync );\n      if ( ( pPager.noSync ) || ( pPager.journalMode == PAGER_JOURNALMODE_MEMORY )\n      || ( sqlite3OsDeviceCharacteristics( pPager.fd ) & SQLITE_IOCAP_SAFE_APPEND ) != 0\n      )\n      {\n        aJournalMagic.CopyTo( zHeader, 0 );// memcpy(zHeader, aJournalMagic, sizeof(aJournalMagic));\n        put32bits( zHeader, aJournalMagic.Length, 0xffffffff );\n      }\n      else\n      {\n        zHeader[0] = 0;\n        put32bits( zHeader, aJournalMagic.Length, 0 );\n      }\n\n      /* The random check-hash initialiser */\n      i64 i64Temp = 0;\n      sqlite3_randomness( sizeof( i64 ), ref i64Temp );\n      pPager.cksumInit = (u32)i64Temp;\n      put32bits( zHeader, aJournalMagic.Length + 4, pPager.cksumInit );\n      /* The initial database size */\n      put32bits( zHeader, aJournalMagic.Length + 8, pPager.dbOrigSize );\n      /* The assumed sector size for this process */\n      put32bits( zHeader, aJournalMagic.Length + 12, pPager.sectorSize );\n      /* The page size */\n      put32bits( zHeader, aJournalMagic.Length + 16, (u32)pPager.pageSize );\n\n      /* Initializing the tail of the buffer is not necessary.  Everything\n      ** works find if the following memset() is omitted.  But initializing\n      ** the memory prevents valgrind from complaining, so we are willing to\n      ** take the performance hit.\n      */\n      //  memset(&zHeader[sizeof(aJournalMagic)+20], 0,\n      //  nHeader-(sizeof(aJournalMagic)+20));\n      Array.Clear( zHeader, aJournalMagic.Length + 20, (int)nHeader - ( aJournalMagic.Length + 20 ) );\n\n      /* In theory, it is only necessary to write the 28 bytes that the\n      ** journal header consumes to the journal file here. Then increment the\n      ** Pager.journalOff variable by JOURNAL_HDR_SZ so that the next\n      ** record is written to the following sector (leaving a gap in the file\n      ** that will be implicitly filled in by the OS).\n      **\n      ** However it has been discovered that on some systems this pattern can\n      ** be significantly slower than contiguously writing data to the file,\n      ** even if that means explicitly writing data to the block of\n      ** (JOURNAL_HDR_SZ - 28) bytes that will not be used. So that is what\n      ** is done.\n      **\n      ** The loop is required here in case the sector-size is larger than the\n      ** database page size. Since the zHeader buffer is only Pager.pageSize\n      ** bytes in size, more than one call to sqlite3OsWrite() may be required\n      ** to populate the entire journal header sector.\n      */\n      for ( nWrite = 0 ; rc == SQLITE_OK && nWrite < JOURNAL_HDR_SZ( pPager ) ; nWrite += nHeader )\n      {\n        IOTRACE( "JHDR %p %lld %d\\n", pPager, pPager.journalHdr, nHeader );\n        rc = sqlite3OsWrite( pPager.jfd, zHeader, (int)nHeader, pPager.journalOff );\n        pPager.journalOff += (int)nHeader;\n      }\n      return rc;\n    }\n\n    /*\n    ** The journal file must be open when this is called. A journal header file\n    ** (JOURNAL_HDR_SZ bytes) is read from the current location in the journal\n    ** file. The current location in the journal file is given by\n    ** pPager.journalOff. See comments above function writeJournalHdr() for\n    ** a description of the journal header format.\n    **\n    ** If the header is read successfully, *pNRec is set to the number of\n    ** page records following this header and *pDbSize is set to the size of the\n    ** database before the transaction began, in pages. Also, pPager.cksumInit\n    ** is set to the value read from the journal header. SQLITE_OK is returned\n    ** in this case.\n    **\n    ** If the journal header file appears to be corrupted, SQLITE_DONE is\n    ** returned and *pNRec and *PDbSize are undefined.  If JOURNAL_HDR_SZ bytes\n    ** cannot be read from the journal file an error code is returned.\n    */\n    static int readJournalHdr(\n    Pager pPager,               /* Pager object */\n    int isHot,\n    i64 journalSize,            /* Size of the open journal file in bytes */\n    ref u32 pNRec,              /* OUT: Value read from the nRec field */\n    ref u32 pDbSize             /* OUT: Value of original database size field */\n    )\n    {\n      int rc;                      /* Return code */\n      byte[] aMagic = new byte[8]; /* A buffer to hold the magic header */\n      i64 iHdrOff;                 /* Offset of journal header being read */\n\n      Debug.Assert( isOpen( pPager.jfd ) );      /* Journal file must be open. */\n\n      /* Advance Pager.journalOff to the start of the next sector. If the\n      ** journal file is too small for there to be a header stored at this\n      ** point, return SQLITE_DONE.\n      */\n      pPager.journalOff = journalHdrOffset( pPager );\n      if ( pPager.journalOff + JOURNAL_HDR_SZ( pPager ) > journalSize )\n      {\n        return SQLITE_DONE;\n      }\n      iHdrOff = pPager.journalOff;\n\n      /* Read in the first 8 bytes of the journal header. If they do not match\n      ** the  magic string found at the start of each journal header, return\n      ** SQLITE_DONE. If an IO error occurs, return an error code. Otherwise,\n      ** proceed.\n      */\n      if ( isHot != 0 || iHdrOff != pPager.journalHdr )\n      {\n        rc = sqlite3OsRead( pPager.jfd, aMagic, aMagic.Length, iHdrOff );\n        if ( rc != 0 )\n        {\n          return rc;\n        }\n        if ( memcmp( aMagic, aJournalMagic, aMagic.Length ) != 0 )\n        {\n          return SQLITE_DONE;\n        }\n      }\n      /* Read the first three 32-bit fields of the journal header: The nRec\n      ** field, the checksum-initializer and the database size at the start\n      ** of the transaction. Return an error code if anything goes wrong.\n      */\n      if ( SQLITE_OK != ( rc = read32bits( pPager.jfd, iHdrOff + 8, ref pNRec ) )\n      || SQLITE_OK != ( rc = read32bits( pPager.jfd, iHdrOff + 12, ref pPager.cksumInit ) )\n      || SQLITE_OK != ( rc = read32bits( pPager.jfd, iHdrOff + 16, ref pDbSize ) )\n      )\n      {\n        return rc;\n      }\n\n      if ( pPager.journalOff == 0 )\n      {\n        u32 iPageSize = 0;           /* Page-size field of journal header */\n        u32 iSectorSize = 0;         /* Sector-size field of journal header */\n        u16 iPageSize16;             /* Copy of iPageSize in 16-bit variable */\n\n        /* Read the page-size and sector-size journal header fields. */\n        if ( SQLITE_OK != ( rc = read32bits( pPager.jfd, iHdrOff + 20, ref iSectorSize ) )\n        || SQLITE_OK != ( rc = read32bits( pPager.jfd, iHdrOff + 24, ref iPageSize ) )\n        )\n        {\n          return rc;\n        }\n\n        /* Check that the values read from the page-size and sector-size fields\n        ** are within range. To be \'in range\', both values need to be a power\n        ** of two greater than or equal to 512, and not greater than their\n        ** respective compile time maximum limits.\n        */\n        if ( iPageSize < 512 || iSectorSize < 512\n        || iPageSize > SQLITE_MAX_PAGE_SIZE || iSectorSize > MAX_SECTOR_SIZE\n        || ( ( iPageSize - 1 ) & iPageSize ) != 0 || ( ( iSectorSize - 1 ) & iSectorSize ) != 0\n        )\n        {\n          /* If the either the page-size or sector-size in the journal-header is\n          ** invalid, then the process that wrote the journal-header must have\n          ** crashed before the header was synced. In this case stop reading\n          ** the journal file here.\n          */\n          return SQLITE_DONE;\n        }\n\n        /* Update the page-size to match the value read from the journal.\n        ** Use a testcase() macro to make sure that malloc failure within\n        ** PagerSetPagesize() is tested.\n        */\n        iPageSize16 = (u16)iPageSize;\n        rc = sqlite3PagerSetPagesize( pPager, ref iPageSize16, -1 );\n        testcase( rc != SQLITE_OK );\n        Debug.Assert( rc != SQLITE_OK || iPageSize16 == (u16)iPageSize );\n\n        /* Update the assumed sector-size to match the value used by\n        ** the process that created this journal. If this journal was\n        ** created by a process other than this one, then this routine\n        ** is being called from within pager_playback(). The local value\n        ** of Pager.sectorSize is restored at the end of that routine.\n        */\n        pPager.sectorSize = iSectorSize;\n      }\n\n      pPager.journalOff += (int)JOURNAL_HDR_SZ( pPager );\n      return rc;\n    }\n\n    /*\n    ** Write the supplied master journal name into the journal file for pager\n    ** pPager at the current location. The master journal name must be the last\n    ** thing written to a journal file. If the pager is in full-sync mode, the\n    ** journal file descriptor is advanced to the next sector boundary before\n    ** anything is written. The format is:\n    **\n    **   + 4 bytes: PAGER_MJ_PGNO.\n    **   + N bytes: Master journal filename in utf-8.\n    **   + 4 bytes: N (length of master journal name in bytes, no nul-terminator).\n    **   + 4 bytes: Master journal name checksum.\n    **   + 8 bytes: aJournalMagic[].\n    **\n    ** The master journal page checksum is the sum of the bytes in the master\n    ** journal name, where each byte is interpreted as a signed 8-bit integer.\n    **\n    ** If zMaster is a NULL pointer (occurs for a single database transaction),\n    ** this call is a no-op.\n    */\n    static int writeMasterJournal( Pager pPager, string zMaster )\n    {\n      int rc;                          /* Return code */\n      int nMaster;                     /* Length of string zMaster */\n      i64 iHdrOff;                     /* Offset of header in journal file */\n      int jrnlSize = 0;                  /* Size of journal file on disk */\n      u32 cksum = 0;                   /* Checksum of string zMaster */\n\n      if ( null == zMaster || pPager.setMaster != 0\n      || pPager.journalMode == PAGER_JOURNALMODE_MEMORY\n      || pPager.journalMode == PAGER_JOURNALMODE_OFF\n      )\n      {\n        return SQLITE_OK;\n      }\n\n      pPager.setMaster = 1;\n      Debug.Assert( isOpen( pPager.jfd ) );\n\n      /* Calculate the length in bytes and the checksum of zMaster */\n      for ( nMaster = 0 ; nMaster < zMaster.Length && zMaster[nMaster] != 0 ; nMaster++ )\n      {\n        cksum += zMaster[nMaster];\n      }\n\n      /* If in full-sync mode, advance to the next disk sector before writing\n      ** the master journal name. This is in case the previous page written to\n      ** the journal has already been synced.\n      */\n      if ( pPager.fullSync )\n      {\n        pPager.journalOff = journalHdrOffset( pPager );\n      }\n      iHdrOff = pPager.journalOff;\n      /* Write the master journal data to the end of the journal file. If\n      ** an error occurs, return the error code to the caller.\n      */\n      if ( ( 0 != ( rc = write32bits( pPager.jfd, iHdrOff, (u32)PAGER_MJ_PGNO( pPager ) ) ) )\n      || ( 0 != ( rc = sqlite3OsWrite( pPager.jfd, Encoding.UTF8.GetBytes( zMaster ), nMaster, iHdrOff + 4 ) ) )\n      || ( 0 != ( rc = write32bits( pPager.jfd, iHdrOff + 4 + nMaster, (u32)nMaster ) ) )\n      || ( 0 != ( rc = write32bits( pPager.jfd, iHdrOff + 4 + nMaster + 4, cksum ) ) )\n      || ( 0 != ( rc = sqlite3OsWrite( pPager.jfd, aJournalMagic, 8, iHdrOff + 4 + nMaster + 8 ) ) )\n      )\n      {\n        return rc;\n      }\n      pPager.journalOff += ( nMaster + 20 );\n      pPager.needSync = !pPager.noSync;\n\n      /* If the pager is in peristent-journal mode, then the physical\n      ** journal-file may extend past the end of the master-journal name\n      ** and 8 bytes of magic data just written to the file. This is\n      ** dangerous because the code to rollback a hot-journal file\n      ** will not be able to find the master-journal name to determine\n      ** whether or not the journal is hot.\n      **\n      ** Easiest thing to do in this scenario is to truncate the journal\n      ** file to the required size.\n      */\n      if ( SQLITE_OK == ( rc = sqlite3OsFileSize( pPager.jfd, ref jrnlSize ) )\n      && jrnlSize > pPager.journalOff\n      )\n      {\n        rc = sqlite3OsTruncate( pPager.jfd, pPager.journalOff );\n      }\n\n      return rc;\n    }\n\n    /*\n    ** Find a page in the hash table given its page number. Return\n    ** a pointer to the page or NULL if the requested page is not\n    ** already in memory.\n    */\n    static PgHdr pager_lookup( Pager pPager, u32 pgno )\n    {\n      PgHdr p = null;                         /* Return value */\n      /* It is not possible for a call to PcacheFetch() with createFlag==0 to\n      ** fail, since no attempt to allocate dynamic memory will be made.\n      */\n      sqlite3PcacheFetch( pPager.pPCache, pgno, 0, ref p );\n      return p;\n    }\n\n    /*\n    ** Unless the pager is in error-state, discard all in-memory pages. If\n    ** the pager is in error-state, then this call is a no-op.\n    **\n    ** TODO: Why can we not reset the pager while in error state?\n    */\n    static void pager_reset( Pager pPager )\n    {\n      if ( SQLITE_OK == pPager.errCode )\n      {\n        sqlite3BackupRestart( pPager.pBackup );\n        sqlite3PcacheClear( pPager.pPCache );\n        pPager.dbSizeValid = false;\n      }\n    }\n\n    /*\n    ** Free all structures in the Pager.aSavepoint[] array and set both\n    ** Pager.aSavepoint and Pager.nSavepoint to zero. Close the sub-journal\n    ** if it is open and the pager is not in exclusive mode.\n    */\n    static void releaseAllSavepoints( Pager pPager )\n    {\n      int ii;               /* Iterator for looping through Pager.aSavepoint */\n      for ( ii = 0 ; ii < pPager.nSavepoint ; ii++ )\n      {\n        sqlite3BitvecDestroy( ref pPager.aSavepoint[ii].pInSavepoint );\n      }\n      if ( !pPager.exclusiveMode || sqlite3IsMemJournal( pPager.sjfd ) )\n      {\n        sqlite3OsClose( pPager.sjfd );\n      }\n      //sqlite3_free( ref pPager.aSavepoint );\n      pPager.aSavepoint = null;\n      pPager.nSavepoint = 0;\n      pPager.nSubRec = 0;\n    }\n\n    /*\n    ** Set the bit number pgno in the PagerSavepoint.pInSavepoint\n    ** bitvecs of all open savepoints. Return SQLITE_OK if successful\n    ** or SQLITE_NOMEM if a malloc failure occurs.\n    */\n    static int addToSavepointBitvecs( Pager pPager, u32 pgno )\n    {\n      int ii;                   /* Loop counter */\n      int rc = SQLITE_OK;       /* Result code */\n\n      for ( ii = 0 ; ii < pPager.nSavepoint ; ii++ )\n      {\n        PagerSavepoint p = pPager.aSavepoint[ii];\n        if ( pgno <= p.nOrig )\n        {\n          rc |= sqlite3BitvecSet( p.pInSavepoint, pgno );\n          testcase( rc == SQLITE_NOMEM );\n          Debug.Assert( rc == SQLITE_OK || rc == SQLITE_NOMEM );\n        }\n      }\n      return rc;\n    }\n\n    /*\n    ** Unlock the database file. This function is a no-op if the pager\n    ** is in exclusive mode.\n    **\n    ** If the pager is currently in error state, discard the contents of\n    ** the cache and reset the Pager structure internal state. If there is\n    ** an open journal-file, then the next time a shared-lock is obtained\n    ** on the pager file (by this or any other process), it will be\n    ** treated as a hot-journal and rolled back.\n    */\n    static void pager_unlock( Pager pPager )\n    {\n      if ( !pPager.exclusiveMode )\n      {\n        int rc;                      /* Return code */\n\n        /* Always close the journal file when dropping the database lock.\n        ** Otherwise, another connection with journal_mode=delete might\n        ** delete the file out from under us.\n        */\n        sqlite3OsClose( pPager.jfd );\n        sqlite3BitvecDestroy( ref pPager.pInJournal );\n        pPager.pInJournal = null;\n        releaseAllSavepoints( pPager );\n\n        /* If the file is unlocked, somebody else might change it. The\n        ** values stored in Pager.dbSize etc. might become invalid if\n        ** this happens. TODO: Really, this doesn\'t need to be cleared\n        ** until the change-counter check fails in PagerSharedLock().\n        */\n        pPager.dbSizeValid = false;\n        rc = osUnlock( pPager.fd, NO_LOCK );\n        if ( rc != 0 )\n        {\n          pPager.errCode = rc;\n        }\n        IOTRACE( "UNLOCK %p\\n", pPager );\n        /* If Pager.errCode is set, the contents of the pager cache cannot be\n        ** trusted. Now that the pager file is unlocked, the contents of the\n        ** cache can be discarded and the error code safely cleared.\n        */\n        if ( pPager.errCode != 0 )\n        {\n          if ( rc == SQLITE_OK )\n          {\n            pPager.errCode = SQLITE_OK;\n          }\n          pager_reset( pPager );\n        }\n\n        pPager.changeCountDone = false;\n        pPager.state = PAGER_UNLOCK;\n      }\n    }\n\n    /*\n    ** This function should be called when an IOERR, CORRUPT or FULL error\n    ** may have occurred. The first argument is a pointer to the pager\n    ** structure, the second the error-code about to be returned by a pager\n    ** API function. The value returned is a copy of the second argument\n    ** to this function.\n    **\n    ** If the second argument is SQLITE_IOERR, SQLITE_CORRUPT, or SQLITE_FULL\n    ** the error becomes persistent. Until the persisten error is cleared,\n    ** subsequent API calls on this Pager will immediately return the same\n    ** error code.\n    **\n    ** A persistent error indicates that the contents of the pager-cache\n    ** cannot be trusted. This state can be cleared by completely discarding\n    ** the contents of the pager-cache. If a transaction was active when\n    ** the persistent error occurred, then the rollback journal may need\n    ** to be replayed to restore the contents of the database file (as if\n    ** it were a hot-journal).\n    */\n    static int pager_error( Pager pPager, int rc )\n    {\n      int rc2 = rc & 0xff;\n      Debug.Assert(  rc==SQLITE_OK ||\n#if SQLITE_OMIT_MEMORYDB\n0==MEMDB\n#else\n 0 == pPager.memDb\n#endif\n );\n      Debug.Assert(\n      pPager.errCode == SQLITE_FULL ||\n      pPager.errCode == SQLITE_OK ||\n      ( pPager.errCode & 0xff ) == SQLITE_IOERR\n      );\n      if (\n      rc2 == SQLITE_FULL || rc2 == SQLITE_IOERR )\n      {\n        pPager.errCode = rc;\n      }\n      return rc;\n    }\n\n    /*\n    ** Execute a rollback if a transaction is active and unlock the\n    ** database file.\n    **\n    ** If the pager has already entered the error state, do not attempt\n    ** the rollback at this time. Instead, pager_unlock() is called. The\n    ** call to pager_unlock() will discard all in-memory pages, unlock\n    ** the database file and clear the error state. If this means that\n    ** there is a hot-journal left in the file-system, the next connection\n    ** to obtain a shared lock on the pager (which may be this one) will\n    ** roll it back.\n    **\n    ** If the pager has not already entered the error state, but an IO or\n    ** malloc error occurs during a rollback, then this will itself cause\n    ** the pager to enter the error state. Which will be cleared by the\n    ** call to pager_unlock(), as described above.\n    */\n    static void pagerUnlockAndRollback( Pager pPager )\n    {\n      if ( pPager.errCode == SQLITE_OK && pPager.state >= PAGER_RESERVED )\n      {\n        sqlite3BeginBenignMalloc();\n        sqlite3PagerRollback( pPager );\n        sqlite3EndBenignMalloc();\n      }\n      pager_unlock( pPager );\n    }\n\n    /*\n    ** This routine ends a transaction. A transaction is usually ended by\n    ** either a COMMIT or a ROLLBACK operation. This routine may be called\n    ** after rollback of a hot-journal, or if an error occurs while opening\n    ** the journal file or writing the very first journal-header of a\n    ** database transaction.\n    **\n    ** If the pager is in PAGER_SHARED or PAGER_UNLOCK state when this\n    ** routine is called, it is a no-op (returns SQLITE_OK).\n    **\n    ** Otherwise, any active savepoints are released.\n    **\n    ** If the journal file is open, then it is "finalized". Once a journal\n    ** file has been finalized it is not possible to use it to roll back a\n    ** transaction. Nor will it be considered to be a hot-journal by this\n    ** or any other database connection. Exactly how a journal is finalized\n    ** depends on whether or not the pager is running in exclusive mode and\n    ** the current journal-mode (Pager.journalMode value), as follows:\n    **\n    **   journalMode==MEMORY\n    **     Journal file descriptor is simply closed. This destroys an\n    **     in-memory journal.\n    **\n    **   journalMode==TRUNCATE\n    **     Journal file is truncated to zero bytes in size.\n    **\n    **   journalMode==PERSIST\n    **     The first 28 bytes of the journal file are zeroed. This invalidates\n    **     the first journal header in the file, and hence the entire journal\n    **     file. An invalid journal file cannot be rolled back.\n    **\n    **   journalMode==DELETE\n    **     The journal file is closed and deleted using sqlite3OsDelete().\n    **\n    **     If the pager is running in exclusive mode, this method of finalizing\n    **     the journal file is never used. Instead, if the journalMode is\n    **     DELETE and the pager is in exclusive mode, the method described under\n    **     journalMode==PERSIST is used instead.\n    **\n    ** After the journal is finalized, if running in non-exclusive mode, the\n    ** pager moves to PAGER_SHARED state (and downgrades the lock on the\n    ** database file accordingly).\n    **\n    ** If the pager is running in exclusive mode and is in PAGER_SYNCED state,\n    ** it moves to PAGER_EXCLUSIVE. No locks are downgraded when running in\n    ** exclusive mode.\n    **\n    ** SQLITE_OK is returned if no error occurs. If an error occurs during\n    ** any of the IO operations to finalize the journal file or unlock the\n    ** database then the IO error code is returned to the user. If the\n    ** operation to finalize the journal file fails, then the code still\n    ** tries to unlock the database file if not in exclusive mode. If the\n    ** unlock operation fails as well, then the first error code related\n    ** to the first error encountered (the journal finalization one) is\n    ** returned.\n    */\n    static int pager_end_transaction( Pager pPager, int hasMaster )\n    {\n      int rc = SQLITE_OK;     /* Error code from journal finalization operation */\n      int rc2 = SQLITE_OK;    /* Error code from db file unlock operation */\n      if ( pPager.state < PAGER_RESERVED )\n      {\n        return SQLITE_OK;\n      }\n      releaseAllSavepoints( pPager );\n      Debug.Assert( isOpen( pPager.jfd ) || pPager.pInJournal == null );\n      if ( isOpen( pPager.jfd ) )\n      {\n\n        /* Finalize the journal file. */\n        if ( sqlite3IsMemJournal( pPager.jfd ) )\n        {\n          Debug.Assert( pPager.journalMode == PAGER_JOURNALMODE_MEMORY );\n          sqlite3OsClose( pPager.jfd );\n        }\n        else if ( pPager.journalMode == PAGER_JOURNALMODE_TRUNCATE )\n        {\n          if ( pPager.journalOff == 0 )\n          {\n            rc = SQLITE_OK;\n          }\n          else\n          {\n            rc = sqlite3OsTruncate( pPager.jfd, 0 );\n          }\n          pPager.journalOff = 0;\n          pPager.journalStarted = false;\n        }\n        else if ( pPager.exclusiveMode\n        || pPager.journalMode == PAGER_JOURNALMODE_PERSIST\n        )\n        {\n          rc = zeroJournalHdr( pPager, hasMaster );\n          pager_error( pPager, rc );\n          pPager.journalOff = 0;\n          pPager.journalStarted = false;\n        }\n        else\n        {\n          /* This branch may be executed with Pager.journalMode==MEMORY if\n          ** a hot-journal was just rolled back. In this case the journal\n          ** file should be closed and deleted. If this connection writes to\n          ** the database file, it will do so using an in-memory journal.  */\n          Debug.Assert( pPager.journalMode == PAGER_JOURNALMODE_DELETE\n               || pPager.journalMode == PAGER_JOURNALMODE_MEMORY\n          );\n          sqlite3OsClose( pPager.jfd );\n          if ( !pPager.tempFile )\n          {\n            rc = sqlite3OsDelete( pPager.pVfs, pPager.zJournal, 0 );\n          }\n        }\n#if SQLITE_CHECK_PAGES\nsqlite3PcacheIterateDirty(pPager.pPCache, pager_set_pagehash);\n#endif\n        sqlite3PcacheCleanAll( pPager.pPCache );\n\n        sqlite3BitvecDestroy( ref pPager.pInJournal );\n        pPager.pInJournal = null;\n        pPager.nRec = 0;\n      }\n\n      if ( !pPager.exclusiveMode )\n      {\n        rc2 = osUnlock( pPager.fd, SHARED_LOCK );\n        pPager.state = PAGER_SHARED;\n        pPager.changeCountDone = false;\n      }\n      else if ( pPager.state == PAGER_SYNCED )\n      {\n        pPager.state = PAGER_EXCLUSIVE;\n      }\n      pPager.setMaster = 0;\n      pPager.needSync = false;\n      pPager.dbModified = false;\n\n      /* TODO: Is this optimal? Why is the db size invalidated here\n      ** when the database file is not unlocked? */\n      pPager.dbOrigSize = 0;\n      sqlite3PcacheTruncate( pPager.pPCache, pPager.dbSize );\n      if (\n#if SQLITE_OMIT_MEMORYDB\n0==MEMDB\n#else\n 0 == pPager.memDb\n#endif\n )\n      {\n        pPager.dbSizeValid = false;\n      }\n      return ( rc == SQLITE_OK ? rc2 : rc );\n    }\n\n    /*\n    ** Parameter aData must point to a buffer of pPager.pageSize bytes\n    ** of data. Compute and return a checksum based ont the contents of the\n    ** page of data and the current value of pPager.cksumInit.\n    **\n    ** This is not a real checksum. It is really just the sum of the\n    ** random initial value (pPager.cksumInit) and every 200th byte\n    ** of the page data, starting with byte offset (pPager.pageSize%200).\n    ** Each byte is interpreted as an 8-bit unsigned integer.\n    **\n    ** Changing the formula used to compute this checksum results in an\n    ** incompatible journal file format.\n    **\n    ** If journal corruption occurs due to a power failure, the most likely\n    ** scenario is that one end or the other of the record will be changed.\n    ** It is much less likely that the two ends of the journal record will be\n    ** correct and the middle be corrupt.  Thus, this "checksum" scheme,\n    ** though fast and simple, catches the mostly likely kind of corruption.\n    */\n    static u32 pager_cksum( Pager pPager, byte[] aData )\n    {\n      u32 cksum = pPager.cksumInit;         /* Checksum value to return */\n      int i = pPager.pageSize - 200;        /* Loop counter */\n      while ( i > 0 )\n      {\n        cksum += aData[i];\n        i -= 200;\n      }\n      return cksum;\n    }\n\n    /*\n    ** Read a single page from either the journal file (if isMainJrnl==1) or\n    ** from the sub-journal (if isMainJrnl==0) and playback that page.\n    ** The page begins at offset *pOffset into the file. The *pOffset\n    ** value is increased to the start of the next page in the journal.\n    **\n    ** The isMainJrnl flag is true if this is the main rollback journal and\n    ** false for the statement journal.  The main rollback journal uses\n    ** checksums - the statement journal does not.\n    **\n    ** If the page number of the page record read from the (sub-)journal file\n    ** is greater than the current value of Pager.dbSize, then playback is\n    ** skipped and SQLITE_OK is returned.\n    **\n    ** If pDone is not NULL, then it is a record of pages that have already\n    ** been played back.  If the page at *pOffset has already been played back\n    ** (if the corresponding pDone bit is set) then skip the playback.\n    ** Make sure the pDone bit corresponding to the *pOffset page is set\n    ** prior to returning.\n    **\n    ** If the page record is successfully read from the (sub-)journal file\n    ** and played back, then SQLITE_OK is returned. If an IO error occurs\n    ** while reading the record from the (sub-)journal file or while writing\n    ** to the database file, then the IO error code is returned. If data\n    ** is successfully read from the (sub-)journal file but appears to be\n    ** corrupted, SQLITE_DONE is returned. Data is considered corrupted in\n    ** two circumstances:\n    **\n    **   * If the record page-number is illegal (0 or PAGER_MJ_PGNO), or\n    **   * If the record is being rolled back from the main journal file\n    **     and the checksum field does not match the record content.\n    **\n    ** Neither of these two scenarios are possible during a savepoint rollback.\n    **\n    ** If this is a savepoint rollback, then memory may have to be dynamically\n    ** allocated by this function. If this is the case and an allocation fails,\n    ** SQLITE_NOMEM is returned.\n    */\n    static int pager_playback_one_page(\n    Pager pPager,                /* The pager being played back */\n    int isMainJrnl,              /* True for main rollback journal. False for Stmt jrnl */\n    int isUnsync,                /* True if reading from unsynced main journal */\n    ref i64 pOffset,             /* Offset of record to playback */\n    int isSavepnt,               /* True for a savepoint rollback */\n    Bitvec pDone                 /* Bitvec of pages already played back */\n    )\n    {\n      int rc;\n      PgHdr pPg;                   /* An existing page in the cache */\n      Pgno pgno = 0;               /* The page number of a page in journal */\n      u32 cksum = 0;               /* Checksum used for sanity checking */\n      u8[] aData;                  /* Temporary storage for the page */\n      sqlite3_file jfd;            /* The file descriptor for the journal file */\n\n      Debug.Assert( ( isMainJrnl & ~1 ) == 0 );   /* isMainJrnl is 0 or 1 */\n      Debug.Assert( ( isSavepnt & ~1 ) == 0 );    /* isSavepnt is 0 or 1 */\n      Debug.Assert( isMainJrnl != 0 || pDone != null );        /* pDone always used on sub-journals */\n      Debug.Assert( isSavepnt != 0 || pDone == null );    /* pDone never used on non-savepoint */\n\n      aData = pPager.pTmpSpace;\n      Debug.Assert( aData != null );         /* Temp storage must have already been allocated */\n\n      /* Read the page number and page data from the journal or sub-journal\n      ** file. Return an error code to the caller if an IO error occurs.\n      */\n      jfd = isMainJrnl != 0 ? pPager.jfd : pPager.sjfd;\n\n      rc = read32bits( jfd, pOffset, ref pgno );\n      if ( rc != SQLITE_OK ) return rc;\n      rc = sqlite3OsRead( jfd, aData, pPager.pageSize, ( pOffset ) + 4 );\n      if ( rc != SQLITE_OK ) return rc;\n      pOffset += pPager.pageSize + 4 + isMainJrnl * 4;\n\n      /* Sanity checking on the page.  This is more important that I originally\n      ** thought.  If a power failure occurs while the journal is being written,\n      ** it could cause invalid data to be written into the journal.  We need to\n      ** detect this invalid data (with high probability) and ignore it.\n      */\n      if ( pgno == 0 || pgno == PAGER_MJ_PGNO( pPager ) )\n      {\n        Debug.Assert( 0 == isSavepnt );\n        return SQLITE_DONE;\n      }\n      if ( pgno > pPager.dbSize || sqlite3BitvecTest( pDone, pgno ) != 0 )\n      {\n        return SQLITE_OK;\n      }\n      if ( isMainJrnl != 0 )\n      {\n        rc = read32bits( jfd, ( pOffset ) - 4, ref cksum );\n        if ( rc != 0 ) return rc;\n        if ( 0 == isSavepnt && pager_cksum( pPager, aData ) != cksum )\n        {\n          return SQLITE_DONE;\n        }\n      }\n\n      if ( pDone != null && ( rc = sqlite3BitvecSet( pDone, pgno ) ) != SQLITE_OK )\n      {\n        return rc;\n      }\n\n      Debug.Assert( pPager.state == PAGER_RESERVED || pPager.state >= PAGER_EXCLUSIVE );\n\n      /* If the pager is in RESERVED state, then there must be a copy of this\n      ** page in the pager cache. In this case just update the pager cache,\n      ** not the database file. The page is left marked dirty in this case.\n      **\n      ** An exception to the above rule: If the database is in no-sync mode\n      ** and a page is moved during an incremental vacuum then the page may\n      ** not be in the pager cache. Later: if a malloc() or IO error occurs\n      ** during a Movepage() call, then the page may not be in the cache\n      ** either. So the condition described in the above paragraph is not\n      ** Debug.Assert()able.\n      **\n      ** If in EXCLUSIVE state, then we update the pager cache if it exists\n      ** and the main file. The page is then marked not dirty.\n      **\n      ** Ticket #1171:  The statement journal might contain page content that is\n      ** different from the page content at the start of the transaction.\n      ** This occurs when a page is changed prior to the start of a statement\n      ** then changed again within the statement.  When rolling back such a\n      ** statement we must not write to the original database unless we know\n      ** for certain that original page contents are synced into the main rollback\n      ** journal.  Otherwise, a power loss might leave modified data in the\n      ** database file without an entry in the rollback journal that can\n      ** restore the database to its original form.  Two conditions must be\n      ** met before writing to the database files. (1) the database must be\n      ** locked.  (2) we know that the original page content is fully synced\n      ** in the main journal either because the page is not in cache or else\n      ** the page is marked as needSync==0.\n      **\n      ** 2008-04-14:  When attempting to vacuum a corrupt database file, it\n      ** is possible to fail a statement on a database that does not yet exist.\n      ** Do not attempt to write if database file has never been opened.\n      */\n      pPg = pager_lookup( pPager, pgno );\n      Debug.Assert( pPg != null ||\n#if SQLITE_OMIT_MEMORYDB\n0==MEMDB\n#else\n pPager.memDb == 0\n#endif\n );\n\n\n      PAGERTRACE( "PLAYBACK %d page %d hash(%08x) %s\\n",\n      PAGERID( pPager ), pgno, pager_datahash( pPager.pageSize, aData ),\n      ( isMainJrnl != 0 ? "main-journal" : "sub-journal" )\n      );\n      if ( ( pPager.state >= PAGER_EXCLUSIVE )\n      && ( pPg == null || 0 == ( pPg.flags & PGHDR_NEED_SYNC ) )\n      && isOpen( pPager.fd )\n      && 0 == isUnsync\n      )\n      {\n        i64 ofst = ( pgno - 1 ) * (i64)pPager.pageSize;\n        rc = sqlite3OsWrite( pPager.fd, aData, pPager.pageSize, ofst );\n        if ( pgno > pPager.dbFileSize )\n        {\n          pPager.dbFileSize = (u32)pgno;\n        }\n        if ( pPager.pBackup != null )\n        {\n#if SQLITE_HAS_CODEC\nCODEC1( pPager, aData, pgno, 3, rc = SQLITE_NOMEM );\n#endif\n          sqlite3BackupUpdate( pPager.pBackup, pgno, aData );\n#if SQLITE_HAS_CODEC\nCODEC1( pPager, aData, pgno, 0, rc = SQLITE_NOMEM );\n#endif\n        }\n      }\n      else if ( 0 == isMainJrnl && pPg == null )\n      {\n        /* If this is a rollback of a savepoint and data was not written to\n        ** the database and the page is not in-memory, there is a potential\n        ** problem. When the page is next fetched by the b-tree layer, it\n        ** will be read from the database file, which may or may not be\n        ** current.\n        **\n        ** There are a couple of different ways this can happen. All are quite\n        ** obscure. When running in synchronous mode, this can only happen\n        ** if the page is on the free-list at the start of the transaction, then\n        ** populated, then moved using sqlite3PagerMovepage().\n        **\n        ** The solution is to add an in-memory page to the cache containing\n        ** the data just read from the sub-journal. Mark the page as dirty\n        ** and if the pager requires a journal-sync, then mark the page as\n        ** requiring a journal-sync before it is written.\n        */\n        Debug.Assert( isSavepnt != 0 );\n        if ( ( rc = sqlite3PagerAcquire( pPager, (u32)pgno, ref pPg, 1 ) ) != SQLITE_OK )\n        {\n          return rc;\n        }\n        pPg.flags &= ~PGHDR_NEED_READ;\n        sqlite3PcacheMakeDirty( pPg );\n      }\n      if ( pPg != null )\n      {\n        /* No page should ever be explicitly rolled back that is in use, except\n        ** for page 1 which is held in use in order to keep the lock on the\n        ** database active. However such a page may be rolled back as a result\n        ** of an internal error resulting in an automatic call to\n        ** sqlite3PagerRollback().\n        */\n        byte[] pData = pPg.pData;\n        Buffer.BlockCopy( aData, 0, pData, 0, pPager.pageSize );// memcpy(pData, aData, pPager.pageSize);\n        pPager.xReiniter( pPg );\n        if ( isMainJrnl != 0 && ( 0 == isSavepnt || pOffset <= pPager.journalHdr ) )\n        {\n          /* If the contents of this page were just restored from the main\n          ** journal file, then its content must be as they were when the\n          ** transaction was first opened. In this case we can mark the page\n          ** as clean, since there will be no need to write it out to the.\n          **\n          ** There is one exception to this rule. If the page is being rolled\n          ** back as part of a savepoint (or statement) rollback from an\n          ** unsynced portion of the main journal file, then it is not safe\n          ** to mark the page as clean. This is because marking the page as\n          ** clean will clear the PGHDR_NEED_SYNC flag. Since the page is\n          ** already in the journal file (recorded in Pager.pInJournal) and\n          ** the PGHDR_NEED_SYNC flag is cleared, if the page is written to\n          ** again within this transaction, it will be marked as dirty but\n          ** the PGHDR_NEED_SYNC flag will not be set. It could then potentially\n          ** be written out into the database file before its journal file\n          ** segment is synced. If a crash occurs during or following this,\n          ** database corruption may ensue.\n          */\n\n          sqlite3PcacheMakeClean( pPg );\n        }\n#if SQLITE_CHECK_PAGES\npPg.pageHash = pager_pagehash(pPg);\n#endif\n        /* If this was page 1, then restore the value of Pager.dbFileVers.\n** Do this before any decoding. */\n        if ( pgno == 1 )\n        {\n          Buffer.BlockCopy( pData, 24, pPager.dbFileVers, 0, pPager.dbFileVers.Length ); //memcpy(pPager.dbFileVers, ((u8*)pData)[24], sizeof(pPager.dbFileVers));\n        }\n\n        /* Decode the page just read from disk */\n#if SQLITE_HAS_CODEC\nCODEC1(pPager, pData, pPg.pgno, 3, rc=SQLITE_NOMEM);\n#endif\n        sqlite3PcacheRelease( pPg );\n      }\n      return rc;\n    }\n\n    /*\n    ** Parameter zMaster is the name of a master journal file. A single journal\n    ** file that referred to the master journal file has just been rolled back.\n    ** This routine checks if it is possible to delete the master journal file,\n    ** and does so if it is.\n    **\n    ** Argument zMaster may point to Pager.pTmpSpace. So that buffer is not\n    ** available for use within this function.\n    **\n    ** When a master journal file is created, it is populated with the names\n    ** of all of its child journals, one after another, formatted as utf-8\n    ** encoded text. The end of each child journal file is marked with a\n    ** nul-terminator byte (0x00). i.e. the entire contents of a master journal\n    ** file for a transaction involving two databases might be:\n    **\n    **   "/home/bill/a.db-journal\\x00/home/bill/b.db-journal\\x00"\n    **\n    ** A master journal file may only be deleted once all of its child\n    ** journals have been rolled back.\n    **\n    ** This function reads the contents of the master-journal file into\n    ** memory and loops through each of the child journal names. For\n    ** each child journal, it checks if:\n    **\n    **   * if the child journal exists, and if so\n    **   * if the child journal contains a reference to master journal\n    **     file zMaster\n    **\n    ** If a child journal can be found that matches both of the criteria\n    ** above, this function returns without doing anything. Otherwise, if\n    ** no such child journal can be found, file zMaster is deleted from\n    ** the file-system using sqlite3OsDelete().\n    **\n    ** If an IO error within this function, an error code is returned. This\n    ** function allocates memory by calling sqlite3Malloc(). If an allocation\n    ** fails, SQLITE_NOMEM is returned. Otherwise, if no IO or malloc errors\n    ** occur, SQLITE_OK is returned.\n    **\n    ** TODO: This function allocates a single block of memory to load\n    ** the entire contents of the master journal file. This could be\n    ** a couple of kilobytes or so - potentially larger than the page\n    ** size.\n    */\n    static int pager_delmaster( Pager pPager, string zMaster )\n    {\n      sqlite3_vfs pVfs = pPager.pVfs;\n      int rc;                       /* Return code */\n      sqlite3_file pMaster;         /* Malloc\'d master-journal file descriptor */\n      sqlite3_file pJournal;        /* Malloc\'d child-journal file descriptor */\n      string zMasterJournal = null; /* Contents of master journal file */\n      i64 nMasterJournal;           /* Size of master journal file */\n\n      /* Allocate space for both the pJournal and pMaster file descriptors.\n      ** If successful, open the master journal file for reading.\n      */\n      pMaster = new sqlite3_file();// (sqlite3_file*)sqlite3MallocZero( pVfs.szOsFile * 2 );\n      pJournal = new sqlite3_file();// (sqlite3_file*)( ( (u8*)pMaster ) + pVfs.szOsFile );\n      if ( null == pMaster )\n      {\n        rc = SQLITE_NOMEM;\n      }\n      else\n      {\n        const int flags = ( SQLITE_OPEN_READONLY | SQLITE_OPEN_MASTER_JOURNAL );\n        int iDummy = 0;\n        rc = sqlite3OsOpen( pVfs, zMaster, pMaster, flags, ref  iDummy );\n      }\n      if ( rc != SQLITE_OK ) goto delmaster_out;\n\n      Debugger.Break();    //TODO --\n      //rc = sqlite3OsFileSize( pMaster, &nMasterJournal );\n      //if ( rc != SQLITE_OK ) goto delmaster_out;\n\n      //if ( nMasterJournal > 0 )\n      //{\n      //  char* zJournal;\n      //  char* zMasterPtr = 0;\n      //  int nMasterPtr = pVfs.mxPathname + 1;\n\n      //  /* Load the entire master journal file into space obtained from\n      //  ** sqlite3_malloc() and pointed to by zMasterJournal.\n      //  */\n      //  zMasterJournal = sqlite3Malloc((int)nMasterJournal + nMasterPtr + 1);\n      //  if ( !zMasterJournal )\n      //  {\n      //    rc = SQLITE_NOMEM;\n      //    goto delmaster_out;\n      //  }\n      //  zMasterPtr = &zMasterJournal[nMasterJournal+1];\n      //  rc = sqlite3OsRead( pMaster, zMasterJournal, (int)nMasterJournal, 0 );\n      //  if ( rc != SQLITE_OK ) goto delmaster_out;\n      //  zMasterJournal[nMasterJournal] = 0;\n\n\n      //  zJournal = zMasterJournal;\n      //  while ( ( zJournal - zMasterJournal ) < nMasterJournal )\n      //  {\n      //    int exists;\n      //    rc = sqlite3OsAccess( pVfs, zJournal, SQLITE_ACCESS_EXISTS, &exists );\n      //    if ( rc != SQLITE_OK )\n      //    {\n      //      goto delmaster_out;\n      //    }\n      //    if ( exists )\n      //    {\n      //      /* One of the journals pointed to by the master journal exists.\n      //      ** Open it and check if it points at the master journal. If\n      //      ** so, return without deleting the master journal file.\n      //      */\n      //      int c;\n      //      int flags = ( SQLITE_OPEN_READONLY | SQLITE_OPEN_MAIN_JOURNAL );\n      //      rc = sqlite3OsOpen( pVfs, zJournal, pJournal, flags, 0 );\n      //      if ( rc != SQLITE_OK )\n      //      {\n      //        goto delmaster_out;\n      //      }\n\n      //      rc = readMasterJournal( pJournal, zMasterPtr, nMasterPtr );\n      //      sqlite3OsClose( pJournal );\n      //      if ( rc != SQLITE_OK )\n      //      {\n      //        goto delmaster_out;\n      //      }\n\n      //      c = zMasterPtr[0] != 0 && strcmp( zMasterPtr, zMaster ) == 0;\n      //      if ( c )\n      //      {\n      //        /* We have a match. Do not delete the master journal file. */\n      //        goto delmaster_out;\n      //      }\n      //    }\n      //    zJournal += ( sqlite3Strlen30( zJournal ) + 1 );\n      //  }\n      //}\n\n      //rc = sqlite3OsDelete( pVfs, zMaster, 0 );\n\n\n      goto delmaster_out;\ndelmaster_out:\n      if ( zMasterJournal != null )\n      {\n        //sqlite3_free( ref zMasterJournal );\n      }\n      if ( pMaster != null )\n      {\n        sqlite3OsClose( pMaster );\n        Debug.Assert( !isOpen( pJournal ) );\n      }\n      //sqlite3_free( ref  pMaster );\n      return rc;\n    }\n\n\n\n    /*\n    ** This function is used to change the actual size of the database\n    ** file in the file-system. This only happens when committing a transaction,\n    ** or rolling back a transaction (including rolling back a hot-journal).\n    **\n    ** If the main database file is not open, or an exclusive lock is not\n    ** held, this function is a no-op. Otherwise, the size of the file is\n    ** changed to nPage pages (nPage*pPager.pageSize bytes). If the file\n    ** on disk is currently larger than nPage pages, then use the VFS\n    ** xTruncate() method to truncate it.\n    **\n    ** Or, it might might be the case that the file on disk is smaller than\n    ** nPage pages. Some operating system implementations can get confused if\n    ** you try to truncate a file to some size that is larger than it\n    ** currently is, so detect this case and write a single zero byte to\n    ** the end of the new file instead.\n    **\n    ** If successful, return SQLITE_OK. If an IO error occurs while modifying\n    ** the database file, return the error code to the caller.\n    */\n    static int pager_truncate( Pager pPager, u32 nPage )\n    {\n      int rc = SQLITE_OK;\n      if ( pPager.state >= PAGER_EXCLUSIVE && isOpen( pPager.fd ) )\n      {\n        int currentSize = 0; int newSize;\n        /* TODO: Is it safe to use Pager.dbFileSize here? */\n        rc = sqlite3OsFileSize( pPager.fd, ref currentSize );\n        newSize = (int)( pPager.pageSize * nPage );\n        if ( rc == SQLITE_OK && currentSize != newSize )\n        {\n          if ( currentSize > newSize )\n          {\n            rc = sqlite3OsTruncate( pPager.fd, newSize );\n          }\n          else\n          {\n            rc = sqlite3OsWrite( pPager.fd, new byte[1], 1, newSize - 1 );\n          }\n          if ( rc == SQLITE_OK )\n          {\n            pPager.dbSize = nPage;\n          }\n        }\n      }\n      return rc;\n    }\n\n    /*\n    ** Set the value of the Pager.sectorSize variable for the given\n    ** pager based on the value returned by the xSectorSize method\n    ** of the open database file. The sector size will be used used\n    ** to determine the size and alignment of journal header and\n    ** master journal pointers within created journal files.\n    **\n    ** For temporary files the effective sector size is always 512 bytes.\n    **\n    ** Otherwise, for non-temporary files, the effective sector size is\n    ** the value returned by the xSectorSize() method rounded up to 512 if\n    ** it is less than 512, or rounded down to MAX_SECTOR_SIZE if it\n    ** is greater than MAX_SECTOR_SIZE.\n    */\n    static void setSectorSize( Pager pPager )\n    {\n      Debug.Assert( isOpen( pPager.fd ) || pPager.tempFile );\n      if ( !pPager.tempFile )\n      {\n        /* Sector size doesn\'t matter for temporary files. Also, the file\n        ** may not have been opened yet, in which case the OsSectorSize()\n        ** call will segfault.\n        */\n        pPager.sectorSize = (u32)sqlite3OsSectorSize( pPager.fd );\n      }\n      if ( pPager.sectorSize < 512 )\n      {\n        Debug.Assert( MAX_SECTOR_SIZE >= 512 );\n        pPager.sectorSize = 512;\n      }\n      if ( pPager.sectorSize > MAX_SECTOR_SIZE )\n      {\n        pPager.sectorSize = MAX_SECTOR_SIZE;\n      }\n    }\n\n\n    /*\n    ** Playback the journal and thus restore the database file to\n    ** the state it was in before we started making changes.\n    **\n    ** The journal file format is as follows:\n    **\n    **  (1)  8 byte prefix.  A copy of aJournalMagic[].\n    **  (2)  4 byte big-endian integer which is the number of valid page records\n    **       in the journal.  If this value is 0xffffffff, then compute the\n    **       number of page records from the journal size.\n    **  (3)  4 byte big-endian integer which is the initial value for the\n    **       sanity checksum.\n    **  (4)  4 byte integer which is the number of pages to truncate the\n    **       database to during a rollback.\n    **  (5)  4 byte big-endian integer which is the sector size.  The header\n    **       is this many bytes in size.\n    **  (6)  4 byte big-endian integer which is the page case.\n    **  (7)  4 byte integer which is the number of bytes in the master journal\n    **       name.  The value may be zero (indicate that there is no master\n    **       journal.)\n    **  (8)  N bytes of the master journal name.  The name will be nul-terminated\n    **       and might be shorter than the value read from (5).  If the first byte\n    **       of the name is \\000 then there is no master journal.  The master\n    **       journal name is stored in UTF-8.\n    **  (9)  Zero or more pages instances, each as follows:\n    **        +  4 byte page number.\n    **        +  pPager.pageSize bytes of data.\n    **        +  4 byte checksum\n    **\n    ** When we speak of the journal header, we mean the first 8 items above.\n    ** Each entry in the journal is an instance of the 9th item.\n    **\n    ** Call the value from the second bullet "nRec".  nRec is the number of\n    ** valid page entries in the journal.  In most cases, you can compute the\n    ** value of nRec from the size of the journal file.  But if a power\n    ** failure occurred while the journal was being written, it could be the\n    ** case that the size of the journal file had already been increased but\n    ** the extra entries had not yet made it safely to disk.  In such a case,\n    ** the value of nRec computed from the file size would be too large.  For\n    ** that reason, we always use the nRec value in the header.\n    **\n    ** If the nRec value is 0xffffffff it means that nRec should be computed\n    ** from the file size.  This value is used when the user selects the\n    ** no-sync option for the journal.  A power failure could lead to corruption\n    ** in this case.  But for things like temporary table (which will be\n    ** deleted when the power is restored) we don\'t care.\n    **\n    ** If the file opened as the journal file is not a well-formed\n    ** journal file then all pages up to the first corrupted page are rolled\n    ** back (or no pages if the journal header is corrupted). The journal file\n    ** is then deleted and SQLITE_OK returned, just as if no corruption had\n    ** been encountered.\n    **\n    ** If an I/O or malloc() error occurs, the journal-file is not deleted\n    ** and an error code is returned.\n    **\n    ** The isHot parameter indicates that we are trying to rollback a journal\n    ** that might be a hot journal.  Or, it could be that the journal is\n    ** preserved because of JOURNALMODE_PERSIST or JOURNALMODE_TRUNCATE.\n    ** If the journal really is hot, reset the pager cache prior rolling\n    ** back any content.  If the journal is merely persistent, no reset is\n    ** needed.\n    */\n    static int pager_playback( Pager pPager, int isHot )\n    {\n      sqlite3_vfs pVfs = pPager.pVfs;\n      int szJ = 0;             /* Size of the journal file in bytes */\n      u32 nRec = 0;            /* Number of Records in the journal */\n      u32 u;                   /* Unsigned loop counter */\n      u32 mxPg = 0;            /* Size of the original file in pages */\n      int rc;                  /* Result code of a subroutine */\n      int res = 1;             /* Value returned by sqlite3OsAccess() */\n      byte[] zMaster = null;   /* Name of master journal file if any */\n      int needPagerReset;      /* True to reset page prior to first page rollback */\n\n      /* Figure out how many records are in the journal.  Abort early if\n      ** the journal is empty.\n      */\n      Debug.Assert( isOpen( pPager.jfd ) );\n      rc = sqlite3OsFileSize( pPager.jfd, ref szJ );\n      if ( rc != SQLITE_OK || szJ == 0 )\n      {\n        goto end_playback;\n      }\n\n      /* Read the master journal name from the journal, if it is present.\n      ** If a master journal file name is specified, but the file is not\n      ** present on disk, then the journal is not hot and does not need to be\n      ** played back.\n      **\n      ** TODO: Technically the following is an error because it assumes that\n      ** buffer Pager.pTmpSpace is (mxPathname+1) bytes or larger. i.e. that\n      ** (pPager.pageSize >= pPager.pVfs->mxPathname+1). Using os_unix.c,\n      **  mxPathname is 512, which is the same as the minimum allowable value\n      ** for pageSize.\n      */\n      zMaster = new byte[pPager.pVfs.mxPathname + 1];// pPager.pTmpSpace );\n      rc = readMasterJournal( pPager.jfd, zMaster, (u32)pPager.pVfs.mxPathname + 1 );\n      if ( rc == SQLITE_OK && zMaster[0] != 0 )\n      {\n        rc = sqlite3OsAccess( pVfs, Encoding.UTF8.GetString( zMaster ), SQLITE_ACCESS_EXISTS, ref res );\n      } zMaster = null;\n      if ( rc != SQLITE_OK || res == 0 )\n      {\n        goto end_playback;\n      }\n      pPager.journalOff = 0;\n      needPagerReset = isHot;\n\n      /* This loop terminates either when a readJournalHdr() or\n      ** pager_playback_one_page() call returns SQLITE_DONE or an IO error\n      ** occurs.\n      */\n      while ( true )\n      {\n        int isUnsync = 0;\n\n        /* Read the next journal header from the journal file.  If there are\n        ** not enough bytes left in the journal file for a complete header, or\n        ** it is corrupted, then a process must of failed while writing it.\n        ** This indicates nothing more needs to be rolled back.\n        */\n        rc = readJournalHdr( pPager, isHot, szJ, ref nRec, ref mxPg );\n        if ( rc != SQLITE_OK )\n        {\n          if ( rc == SQLITE_DONE )\n          {\n            rc = SQLITE_OK;\n          }\n          goto end_playback;\n        }\n\n        /* If nRec is 0xffffffff, then this journal was created by a process\n        ** working in no-sync mode. This means that the rest of the journal\n        ** file consists of pages, there are no more journal headers. Compute\n        ** the value of nRec based on this assumption.\n        */\n        if ( nRec == 0xffffffff )\n        {\n          Debug.Assert( pPager.journalOff == JOURNAL_HDR_SZ( pPager ) );\n          nRec = (u32)( ( szJ - JOURNAL_HDR_SZ( pPager ) ) / JOURNAL_PG_SZ( pPager ) );\n        }\n\n        /* If nRec is 0 and this rollback is of a transaction created by this\n        ** process and if this is the final header in the journal, then it means\n        ** that this part of the journal was being filled but has not yet been\n        ** synced to disk.  Compute the number of pages based on the remaining\n        ** size of the file.\n        **\n        ** The third term of the test was added to fix ticket #2565.\n        ** When rolling back a hot journal, nRec==0 always means that the next\n        ** chunk of the journal contains zero pages to be rolled back.  But\n        ** when doing a ROLLBACK and the nRec==0 chunk is the last chunk in\n        ** the journal, it means that the journal might contain additional\n        ** pages that need to be rolled back and that the number of pages\n        ** should be computed based on the journal file size.\n        */\n        if ( nRec == 0 && 0 == isHot &&\n        pPager.journalHdr + JOURNAL_HDR_SZ( pPager ) == pPager.journalOff )\n        {\n          nRec = (u32)( ( szJ - pPager.journalOff ) / JOURNAL_PG_SZ( pPager ) );\n          isUnsync = 1;\n        }\n\n        /* If this is the first header read from the journal, truncate the\n        ** database file back to its original size.\n        */\n        if ( pPager.journalOff == JOURNAL_HDR_SZ( pPager ) )\n        {\n          rc = pager_truncate( pPager, mxPg );\n          if ( rc != SQLITE_OK )\n          {\n            goto end_playback;\n          }\n          pPager.dbSize = mxPg;\n        }\n\n        /* Copy original pages out of the journal and back into the\n        ** database file and/or page cache.\n        */\n        for ( u = 0 ; u < nRec ; u++ )\n        {\n          if ( needPagerReset != 0 )\n          {\n            pager_reset( pPager );\n            needPagerReset = 0;\n          }\n          rc = pager_playback_one_page( pPager, 1, isUnsync, ref pPager.journalOff, 0, null );\n          if ( rc != SQLITE_OK )\n          {\n            if ( rc == SQLITE_DONE )\n            {\n              rc = SQLITE_OK;\n              pPager.journalOff = szJ;\n              break;\n            }\n            else\n            {\n              /* If we are unable to rollback, quit and return the error\n              ** code.  This will cause the pager to enter the error state\n              ** so that no further harm will be done.  Perhaps the next\n              ** process to come along will be able to rollback the database.\n              */\n              goto end_playback;\n            }\n          }\n        }\n      }\n      /*NOTREACHED*/\n      Debugger.Break();\n\nend_playback:\n      /* Following a rollback, the database file should be back in its original\n      ** state prior to the start of the transaction, so invoke the\n      ** SQLITE_FCNTL_DB_UNCHANGED file-control method to disable the\n      ** assertion that the transaction counter was modified.\n      */\n      int iDummy = 0;\n      Debug.Assert(\n      pPager.fd.pMethods == null ||\n      sqlite3OsFileControl( pPager.fd, SQLITE_FCNTL_DB_UNCHANGED, ref iDummy ) >= SQLITE_OK\n      );\n\n      /* If this playback is happening automatically as a result of an IO or\n      ** malloc error that occurred after the change-counter was updated but\n      ** before the transaction was committed, then the change-counter\n      ** modification may just have been reverted. If this happens in exclusive\n      ** mode, then subsequent transactions performed by the connection will not\n      ** update the change-counter at all. This may lead to cache inconsistency\n      ** problems for other processes at some point in the future. So, just\n      ** in case this has happened, clear the changeCountDone flag now.\n      */\n      pPager.changeCountDone = pPager.tempFile;\n\n      if ( rc == SQLITE_OK )\n      {\n        zMaster = new byte[pPager.pVfs.mxPathname + 1];//pPager.pTmpSpace );\n        rc = readMasterJournal( pPager.jfd, zMaster, (u32)pPager.pVfs.mxPathname + 1 );\n        testcase( rc != SQLITE_OK );\n      }\n      if ( rc == SQLITE_OK )\n      {\n        rc = pager_end_transaction( pPager, zMaster[0] != \'\\0\' ? 1 : 0 );\n        testcase( rc != SQLITE_OK );\n      }\n      if ( rc == SQLITE_OK && zMaster[0] != \'\\0\' && res != 0 )\n      {\n        /* If there was a master journal and this routine will return success,\n        ** see if it is possible to delete the master journal.\n        */\n        rc = pager_delmaster( pPager, Encoding.UTF8.GetString( zMaster ) );\n        testcase( rc != SQLITE_OK );\n      }\n\n      /* The Pager.sectorSize variable may have been updated while rolling\n      ** back a journal created by a process with a different sector size\n      ** value. Reset it to the correct value for this process.\n      */\n      setSectorSize( pPager );\n      return rc;\n    }\n\n    /*\n    ** Playback savepoint pSavepoint. Or, if pSavepoint==NULL, then playback\n    ** the entire master journal file. The case pSavepoint==NULL occurs when\n    ** a ROLLBACK TO command is invoked on a SAVEPOINT that is a transaction\n    ** savepoint.\n    **\n    ** When pSavepoint is not NULL (meaning a non-transaction savepoint is\n    ** being rolled back), then the rollback consists of up to three stages,\n    ** performed in the order specified:\n    **\n    **   * Pages are played back from the main journal starting at byte\n    **     offset PagerSavepoint.iOffset and continuing to\n    **     PagerSavepoint.iHdrOffset, or to the end of the main journal\n    **     file if PagerSavepoint.iHdrOffset is zero.\n    **\n    **   * If PagerSavepoint.iHdrOffset is not zero, then pages are played\n    **     back starting from the journal header immediately following\n    **     PagerSavepoint.iHdrOffset to the end of the main journal file.\n    **\n    **   * Pages are then played back from the sub-journal file, starting\n    **     with the PagerSavepoint.iSubRec and continuing to the end of\n    **     the journal file.\n    **\n    ** Throughout the rollback process, each time a page is rolled back, the\n    ** corresponding bit is set in a bitvec structure (variable pDone in the\n    ** implementation below). This is used to ensure that a page is only\n    ** rolled back the first time it is encountered in either journal.\n    **\n    ** If pSavepoint is NULL, then pages are only played back from the main\n    ** journal file. There is no need for a bitvec in this case.\n    **\n    ** In either case, before playback commences the Pager.dbSize variable\n    ** is reset to the value that it held at the start of the savepoint\n    ** (or transaction). No page with a page-number greater than this value\n    ** is played back. If one is encountered it is simply skipped.\n    */\n    static int pagerPlaybackSavepoint( Pager pPager, PagerSavepoint pSavepoint )\n    {\n      i64 szJ;                 /* Effective size of the main journal */\n      i64 iHdrOff;             /* End of first segment of main-journal records */\n      int rc = SQLITE_OK;      /* Return code */\n      Bitvec pDone = null;     /* Bitvec to ensure pages played back only once */\n\n      Debug.Assert( pPager.state >= PAGER_SHARED );\n      /* Allocate a bitvec to use to store the set of pages rolled back */\n      if ( pSavepoint != null )\n      {\n        pDone = sqlite3BitvecCreate( pSavepoint.nOrig );\n        if ( null == pDone )\n        {\n          return SQLITE_NOMEM;\n        }\n      }\n\n      /* Set the database size back to the value it was before the savepoint\n      ** being reverted was opened.\n      */\n      pPager.dbSize = pSavepoint != null ? pSavepoint.nOrig : pPager.dbOrigSize;\n\n      /* Use pPager.journalOff as the effective size of the main rollback\n      ** journal.  The actual file might be larger than this in\n      ** PAGER_JOURNALMODE_TRUNCATE or PAGER_JOURNALMODE_PERSIST.  But anything\n      ** past pPager.journalOff is off-limits to us.\n      */\n      szJ = pPager.journalOff;\n\n      /* Begin by rolling back records from the main journal starting at\n      ** PagerSavepoint.iOffset and continuing to the next journal header.\n      ** There might be records in the main journal that have a page number\n      ** greater than the current database size (pPager.dbSize) but those\n      ** will be skipped automatically.  Pages are added to pDone as they\n      ** are played back.\n      */\n      if ( pSavepoint != null )\n      {\n        iHdrOff = pSavepoint.iHdrOffset != 0 ? pSavepoint.iHdrOffset : szJ;\n        pPager.journalOff = pSavepoint.iOffset;\n        while ( rc == SQLITE_OK && pPager.journalOff < iHdrOff )\n        {\n          rc = pager_playback_one_page( pPager, 1, 0, ref pPager.journalOff, 1, pDone );\n        }\n        Debug.Assert( rc != SQLITE_DONE );\n      }\n      else\n      {\n        pPager.journalOff = 0;\n      }\n\n      /* Continue rolling back records out of the main journal starting at\n      ** the first journal header seen and continuing until the effective end\n      ** of the main journal file.  Continue to skip out-of-range pages and\n      ** continue adding pages rolled back to pDone.\n      */\n      while ( rc == SQLITE_OK && pPager.journalOff < szJ )\n      {\n        u32 ii;            /* Loop counter */\n        u32 nJRec = 0;     /* Number of Journal Records */\n        u32 dummy = 0;\n        rc = readJournalHdr( pPager, 0, (int)szJ, ref nJRec, ref dummy );\n        Debug.Assert( rc != SQLITE_DONE );\n\n        /*\n        ** The "pPager.journalHdr+JOURNAL_HDR_SZ(pPager)==pPager.journalOff"\n        ** test is related to ticket #2565.  See the discussion in the\n        ** pager_playback() function for additional information.\n        */\n        if ( nJRec == 0\n        && pPager.journalHdr + JOURNAL_HDR_SZ( pPager ) == pPager.journalOff\n        )\n        {\n          nJRec = (u32)( ( szJ - pPager.journalOff ) / JOURNAL_PG_SZ( pPager ) );\n        }\n        for ( ii = 0 ; rc == SQLITE_OK && ii < nJRec && pPager.journalOff < szJ ; ii++ )\n        {\n          rc = pager_playback_one_page( pPager, 1, 0, ref pPager.journalOff, 1, pDone );\n        }\n        Debug.Assert( rc != SQLITE_DONE );\n      }\n      Debug.Assert( rc != SQLITE_OK || pPager.journalOff == szJ );\n\n      /* Finally,  rollback pages from the sub-journal.  Page that were\n      ** previously rolled back out of the main journal (and are hence in pDone)\n      ** will be skipped.  Out-of-range pages are also skipped.\n      */\n      if ( pSavepoint != null )\n      {\n        u32 ii;            /* Loop counter */\n        i64 offset = pSavepoint.iSubRec * ( 4 + pPager.pageSize );\n        for ( ii = pSavepoint.iSubRec ; rc == SQLITE_OK && ii < pPager.nSubRec ; ii++ )\n        {\n          Debug.Assert( offset == ii * ( 4 + pPager.pageSize ) );\n          rc = pager_playback_one_page( pPager, 0, 0, ref offset, 1, pDone );\n        }\n        Debug.Assert( rc != SQLITE_DONE );\n      }\n\n      sqlite3BitvecDestroy( ref pDone );\n      if ( rc == SQLITE_OK )\n      {\n        pPager.journalOff = (int)szJ;\n      }\n      return rc;\n    }\n\n    /*\n    ** Change the maximum number of in-memory pages that are allowed.\n    */\n    static void sqlite3PagerSetCachesize( Pager pPager, int mxPage )\n    {\n      sqlite3PcacheSetCachesize( pPager.pPCache, mxPage );\n    }\n\n    /*\n    ** Adjust the robustness of the database to damage due to OS crashes\n    ** or power failures by changing the number of syncs()s when writing\n    ** the rollback journal.  There are three levels:\n    **\n    **    OFF       sqlite3OsSync() is never called.  This is the default\n    **              for temporary and transient files.\n    **\n    **    NORMAL    The journal is synced once before writes begin on the\n    **              database.  This is normally adequate protection, but\n    **              it is theoretically possible, though very unlikely,\n    **              that an inopertune power failure could leave the journal\n    **              in a state which would cause damage to the database\n    **              when it is rolled back.\n    **\n    **    FULL      The journal is synced twice before writes begin on the\n    **              database (with some additional information - the nRec field\n    **              of the journal header - being written in between the two\n    **              syncs).  If we assume that writing a\n    **              single disk sector is atomic, then this mode provides\n    **              assurance that the journal will not be corrupted to the\n    **              point of causing damage to the database during rollback.\n    **\n    ** Numeric values associated with these states are OFF==1, NORMAL=2,\n    ** and FULL=3.\n    */\n#if !SQLITE_OMIT_PAGER_PRAGMAS\n    static void sqlite3PagerSetSafetyLevel( Pager pPager, int level, bool bFullFsync )\n    {\n      pPager.noSync = ( level == 1 || pPager.tempFile );\n      pPager.fullSync = ( level == 3 && !pPager.tempFile );\n      pPager.sync_flags = bFullFsync ? SQLITE_SYNC_FULL : SQLITE_SYNC_NORMAL;\n      if ( pPager.noSync ) pPager.needSync = false;\n    }\n#endif\n\n    /*\n** The following global variable is incremented whenever the library\n** attempts to open a temporary file.  This information is used for\n** testing and analysis only.\n*/\n#if SQLITE_TEST\n    //static int sqlite3_opentemp_count = 0;\n#endif\n\n    /*\n** Open a temporary file.\n**\n** Write the file descriptor into *pFile. Return SQLITE_OK on success\n** or some other error code if we fail. The OS will automatically\n** delete the temporary file when it is closed.\n**\n** The flags passed to the VFS layer xOpen() call are those specified\n** by parameter vfsFlags ORed with the following:\n**\n**     SQLITE_OPEN_READWRITE\n**     SQLITE_OPEN_CREATE\n**     SQLITE_OPEN_EXCLUSIVE\n**     SQLITE_OPEN_DELETEONCLOSE\n*/\n    static int pagerOpentemp(\n    Pager pPager,           /* The pager object */\n    ref sqlite3_file pFile, /* Write the file descriptor here */\n    int vfsFlags            /* Flags passed through to the VFS */\n    )\n    {\n      int rc;               /* Return code */\n\n#if SQLITE_TEST\n      sqlite3_opentemp_count.iValue++;  /* Used for testing and analysis only */\n#endif\n\n      vfsFlags |= SQLITE_OPEN_READWRITE | SQLITE_OPEN_CREATE |\n      SQLITE_OPEN_EXCLUSIVE | SQLITE_OPEN_DELETEONCLOSE;\n      int dummy = 0;\n      rc = sqlite3OsOpen( pPager.pVfs, null, pFile, vfsFlags, ref dummy );\n      Debug.Assert( rc != SQLITE_OK || isOpen( pFile ) );\n      return rc;\n    }\n\n    /*\n    ** Set the busy handler function.\n    **\n    ** The pager invokes the busy-handler if sqlite3OsLock() returns\n    ** SQLITE_BUSY when trying to upgrade from no-lock to a SHARED lock,\n    ** or when trying to upgrade from a RESERVED lock to an EXCLUSIVE\n    ** lock. It does *not* invoke the busy handler when upgrading from\n    ** SHARED to RESERVED, or when upgrading from SHARED to EXCLUSIVE\n    ** (which occurs during hot-journal rollback). Summary:\n    **\n    **   Transition                        | Invokes xBusyHandler\n    **   --------------------------------------------------------\n    **   NO_LOCK       -> SHARED_LOCK      | Yes\n    **   SHARED_LOCK   -> RESERVED_LOCK    | No\n    **   SHARED_LOCK   -> EXCLUSIVE_LOCK   | No\n    **   RESERVED_LOCK -> EXCLUSIVE_LOCK   | Yes\n    **\n    ** If the busy-handler callback returns non-zero, the lock is\n    ** retried. If it returns zero, then the SQLITE_BUSY error is\n    ** returned to the caller of the pager API function.\n    */\n\n    static void sqlite3PagerSetBusyhandler(\n    Pager pPager,                         /* Pager object */\n    dxBusyHandler xBusyHandler,           /* Pointer to busy-handler function */\n      //int (*xBusyHandler)(void *),\n    object pBusyHandlerArg                /* Argument to pass to xBusyHandler */\n    )\n    {\n      pPager.xBusyHandler = xBusyHandler;\n      pPager.pBusyHandlerArg = pBusyHandlerArg;\n    }\n\n    /*\n    ** Report the current page size and number of reserved bytes back\n    ** to the codec.\n    */\n#if SQLITE_HAS_CODEC\nstatic void pagerReportSize(Pager *pPager){\nif( pPager->xCodecSizeChng ){\npPager->xCodecSizeChng(pPager->pCodec, pPager->pageSize,\n(int)pPager->nReserve);\n}\n}\n#else\n    //# define pagerReportSize(X)     /* No-op if we do not support a codec */\n    static void pagerReportSize( Pager pPager ) { }\n#endif\n\n    /*\n** Change the page size used by the Pager object. The new page size\n** is passed in *pPageSize.\n**\n** If the pager is in the error state when this function is called, it\n** is a no-op. The value returned is the error state error code (i.e.\n** one of SQLITE_IOERR, SQLITE_CORRUPT or SQLITE_FULL).\n**\n** Otherwise, if all of the following are true:\n**\n**   * the new page size (value of *pPageSize) is valid (a power\n**     of two between 512 and SQLITE_MAX_PAGE_SIZE, inclusive), and\n**\n**   * there are no outstanding page references, and\n**\n**   * the database is either not an in-memory database or it is\n**     an in-memory database that currently consists of zero pages.\n**\n** then the pager object page size is set to *pPageSize.\n**\n** If the page size is changed, then this function uses sqlite3PagerMalloc()\n** to obtain a new Pager.pTmpSpace buffer. If this allocation attempt\n** fails, SQLITE_NOMEM is returned and the page size remains unchanged.\n** In all other cases, SQLITE_OK is returned.\n**\n** If the page size is not changed, either because one of the enumerated\n** conditions above is not true, the pager was in error state when this\n** function was called, or because the memory allocation attempt failed,\n** then *pPageSize is set to the old, retained page size before returning.\n*/\n    static int sqlite3PagerSetPagesize( Pager pPager, ref u16 pPageSize, int nReserve )\n    {\n      int rc = pPager.errCode;\n      if ( rc == SQLITE_OK )\n      {\n        int pageSize = pPageSize;\n        Debug.Assert( pageSize == 0 || ( pageSize >= 512 && pageSize <= SQLITE_MAX_PAGE_SIZE ) );\n        if ( ( pPager.memDb == 0 || pPager.dbSize == 0 )\n         && sqlite3PcacheRefCount( pPager.pPCache ) == 0\n         && pageSize !=0 && pageSize != pPager.pageSize\n            )\n        {\n          //PgHdr pNew = sqlite3PageMalloc( pageSize );\n          //if ( pNew == null )\n          //{\n          //  rc = SQLITE_NOMEM;\n          //}\n          //else\n          {\n            pager_reset( pPager );\n            pPager.pageSize = pageSize;\n            //sqlite3PageFree( ref  pPager.pTmpSpace );\n            pPager.pTmpSpace = new byte[pageSize];// pNew;\n            sqlite3PcacheSetPageSize( pPager.pPCache, pageSize );\n          }\n        }\n        pPageSize = (u16)pPager.pageSize;\n        if ( nReserve < 0 ) nReserve = pPager.nReserve;\n        Debug.Assert( nReserve >= 0 && nReserve < 1000 );\n        pPager.nReserve = (i16)nReserve;\n        pagerReportSize( pPager );\n      }\n      return rc;\n    }\n\n    /*\n    ** Return a pointer to the "temporary page" buffer held internally\n    ** by the pager.  This is a buffer that is big enough to hold the\n    ** entire content of a database page.  This buffer is used internally\n    ** during rollback and will be overwritten whenever a rollback\n    ** occurs.  But other modules are free to use it too, as long as\n    ** no rollbacks are happening.\n    */\n    static byte[] sqlite3PagerTempSpace( Pager pPager )\n    {\n      return pPager.pTmpSpace;\n    }\n\n    /*\n    ** Attempt to set the maximum database page count if mxPage is positive.\n    ** Make no changes if mxPage is zero or negative.  And never reduce the\n    ** maximum page count below the current size of the database.\n    **\n    ** Regardless of mxPage, return the current maximum page count.\n    */\n    static long sqlite3PagerMaxPageCount( Pager pPager, int mxPage )\n    {\n      if ( mxPage > 0 )\n      {\n        pPager.mxPgno = (Pgno)mxPage;\n      }\n      int idummy = 0;\n      sqlite3PagerPagecount( pPager, ref idummy );\n      return pPager.mxPgno;\n    }\n\n    /*\n    ** The following set of routines are used to disable the simulated\n    ** I/O error mechanism.  These routines are used to avoid simulated\n    ** errors in places where we do not care about errors.\n    **\n    ** Unless -DSQLITE_TEST=1 is used, these routines are all no-ops\n    ** and generate no code.\n    */\n#if SQLITE_TEST\n    //extern int sqlite3_io_error_pending;\n    //extern int sqlite3_io_error_hit;\n    static int saved_cnt;\n    static void disable_simulated_io_errors()\n    {\n      saved_cnt = sqlite3_io_error_pending.iValue;\n      sqlite3_io_error_pending.iValue = -1;\n    }\n    static void enable_simulated_io_errors()\n    {\n      sqlite3_io_error_pending.iValue = saved_cnt;\n    }\n#else\n//# define disable_simulated_io_errors()\n//# define enable_simulated_io_errors()\n#endif\n\n    /*\n** Read the first N bytes from the beginning of the file into memory\n** that pDest points to.\n**\n** If the pager was opened on a transient file (zFilename==""), or\n** opened on a file less than N bytes in size, the output buffer is\n** zeroed and SQLITE_OK returned. The rationale for this is that this\n** function is used to read database headers, and a new transient or\n** zero sized database has a header than consists entirely of zeroes.\n**\n** If any IO error apart from SQLITE_IOERR_SHORT_READ is encountered,\n** the error code is returned to the caller and the contents of the\n** output buffer undefined.\n*/\n    static int sqlite3PagerReadFileheader( Pager pPager, int N, byte[] pDest )\n    {\n      int rc = SQLITE_OK;\n      Array.Clear( pDest, 0, N ); //memset(pDest, 0, N);\n      Debug.Assert( isOpen( pPager.fd ) || pPager.tempFile );\n      if ( isOpen( pPager.fd ) )\n      {\n        IOTRACE( "DBHDR %p 0 %d\\n", pPager, N );\n        rc = sqlite3OsRead( pPager.fd, pDest, N, 0 );\n        if ( rc == SQLITE_IOERR_SHORT_READ )\n        {\n          rc = SQLITE_OK;\n        }\n      }\n      return rc;\n    }\n\n    /*\n    ** Return the total number of pages in the database file associated\n    ** with pPager. Normally, this is calculated as (<db file size>/<page-size>).\n    ** However, if the file is between 1 and <page-size> bytes in size, then\n    ** this is considered a 1 page file.\n    **\n    ** If the pager is in error state when this function is called, then the\n    ** error state error code is returned and *pnPage left unchanged. Or,\n    ** if the file system has to be queried for the size of the file and\n    ** the query attempt returns an IO error, the IO error code is returned\n    ** and *pnPage is left unchanged.\n    **\n    ** Otherwise, if everything is successful, then SQLITE_OK is returned\n    ** and *pnPage is set to the number of pages in the database.\n    */\n    static int sqlite3PagerPagecount( Pager pPager, ref int pnPage )\n    {\n      int nPage;               /* Value to return via *pnPage */\n\n      /* If the pager is already in the error state, return the error code. */\n      if ( pPager.errCode != 0 )\n      {\n        return pPager.errCode;\n      }\n\n      /* Determine the number of pages in the file. Store this in nPage. */\n      if ( pPager.dbSizeValid )\n      {\n        nPage = (int)pPager.dbSize;\n      }\n      else\n      {\n        int rc;                 /* Error returned by OsFileSize() */\n        int n = 0;              /* File size in bytes returned by OsFileSize() */\n\n        Debug.Assert( isOpen( pPager.fd ) || pPager.tempFile );\n        if ( isOpen( pPager.fd ) && ( 0 != ( rc = sqlite3OsFileSize( pPager.fd, ref n ) ) ) )\n        {\n          pager_error( pPager, rc );\n          return rc;\n        }\n        if ( n > 0 && n < pPager.pageSize )\n        {\n          nPage = 1;\n        }\n        else\n        {\n          nPage = n / pPager.pageSize;\n        }\n        if ( pPager.state != PAGER_UNLOCK )\n        {\n          pPager.dbSize = (Pgno)nPage;\n          pPager.dbFileSize = (Pgno)nPage;\n          pPager.dbSizeValid = true;\n        }\n      }\n\n      /* If the current number of pages in the file is greater than the\n      ** configured maximum pager number, increase the allowed limit so\n      ** that the file can be read.\n      */\n      if ( nPage > pPager.mxPgno )\n      {\n        pPager.mxPgno = (Pgno)nPage;\n      }\n\n      /* Set the output variable and return SQLITE_OK */\n      //  if( pnPage ){\n      pnPage = nPage;\n      //}\n      return SQLITE_OK;\n    }\n\n    /*\n    ** Try to obtain a lock of type locktype on the database file. If\n    ** a similar or greater lock is already held, this function is a no-op\n    ** (returning SQLITE_OK immediately).\n    **\n    ** Otherwise, attempt to obtain the lock using sqlite3OsLock(). Invoke\n    ** the busy callback if the lock is currently not available. Repeat\n    ** until the busy callback returns false or until the attempt to\n    ** obtain the lock succeeds.\n    **\n    ** Return SQLITE_OK on success and an error code if we cannot obtain\n    ** the lock. If the lock is obtained successfully, set the Pager.state\n    ** variable to locktype before returning.\n    */\n    static int pager_wait_on_lock( Pager pPager, int locktype )\n    {\n      int rc;                              /* Return code */\n\n      /* The OS lock values must be the same as the Pager lock values */\n      Debug.Assert( PAGER_SHARED == SHARED_LOCK );\n      Debug.Assert( PAGER_RESERVED == RESERVED_LOCK );\n      Debug.Assert( PAGER_EXCLUSIVE == EXCLUSIVE_LOCK );\n\n      /* If the file is currently unlocked then the size must be unknown */\n      Debug.Assert( pPager.state >= PAGER_SHARED || pPager.dbSizeValid == false );\n\n      /* Check that this is either a no-op (because the requested lock is\n      ** already held, or one of the transistions that the busy-handler\n      ** may be invoked during, according to the comment above\n      ** sqlite3PagerSetBusyhandler().\n      */\n      Debug.Assert( ( pPager.state >= locktype )\n      || ( pPager.state == PAGER_UNLOCK && locktype == PAGER_SHARED )\n      || ( pPager.state == PAGER_RESERVED && locktype == PAGER_EXCLUSIVE )\n      );\n\n      if ( pPager.state >= locktype )\n      {\n        rc = SQLITE_OK;\n      }\n      else\n      {\n        do\n        {\n          rc = sqlite3OsLock( pPager.fd, locktype );\n        } while ( rc == SQLITE_BUSY && pPager.xBusyHandler( pPager.pBusyHandlerArg ) != 0 );\n        if ( rc == SQLITE_OK )\n        {\n          pPager.state = (u8)locktype;\n          IOTRACE( "LOCK %p %d\\n", pPager, locktype );\n        }\n      }\n      return rc;\n    }\n\n/*\n** Function assertTruncateConstraint(pPager) checks that one of the \n** following is true for all dirty pages currently in the page-cache:\n**\n**   a) The page number is less than or equal to the size of the \n**      current database image, in pages, OR\n**\n**   b) if the page content were written at this time, it would not\n**      be necessary to write the current content out to the sub-journal\n**      (as determined by function subjRequiresPage()).\n**\n** If the condition asserted by this function were not true, and the\n** dirty page were to be discarded from the cache via the pagerStress()\n** routine, pagerStress() would not write the current page content to\n** the database file. If a savepoint transaction were rolled back after\n** this happened, the correct behaviour would be to restore the current\n** content of the page. However, since this content is not present in either\n** the database file or the portion of the rollback journal and \n** sub-journal rolled back the content could not be restored and the\n** database image would become corrupt. It is therefore fortunate that \n** this circumstance cannot arise.\n*/\n#if SQLITE_DEBUG\n    static void assertTruncateConstraintCb( PgHdr pPg )\n    {\n      Debug.Assert( ( pPg.flags & PGHDR_DIRTY ) != 0 );\n      Debug.Assert( !subjRequiresPage( pPg ) || pPg.pgno <= pPg.pPager.dbSize );\n    }\n    static void assertTruncateConstraint( Pager pPager )\n    {\n      sqlite3PcacheIterateDirty( pPager.pPCache, assertTruncateConstraintCb );\n    }\n#else\n//# define assertTruncateConstraint(pPager)\n    static void assertTruncateConstraintCb(PgHdr pPg) { }\n    static void assertTruncateConstraint(Pager pPager) { }\n#endif\n\n/*\n    ** Truncate the in-memory database file image to nPage pages. This\n    ** function does not actually modify the database file on disk. It\n    ** just sets the internal state of the pager object so that the\n    ** truncation will be done when the current transaction is committed.\n    */\n    static void sqlite3PagerTruncateImage( Pager pPager, u32 nPage )\n    {\n      Debug.Assert( pPager.dbSizeValid );\n      Debug.Assert( pPager.dbSize >= nPage );\n      Debug.Assert( pPager.state >= PAGER_RESERVED );\n      pPager.dbSize = nPage;\n      assertTruncateConstraint( pPager );\n    }\n\n    /*\n    ** Shutdown the page cache.  Free all memory and close all files.\n    **\n    ** If a transaction was in progress when this routine is called, that\n    ** transaction is rolled back.  All outstanding pages are invalidated\n    ** and their memory is freed.  Any attempt to use a page associated\n    ** with this page cache after this function returns will likely\n    ** result in a coredump.\n    **\n    ** This function always succeeds. If a transaction is active an attempt\n    ** is made to roll it back. If an error occurs during the rollback\n    ** a hot journal may be left in the filesystem but no error is returned\n    ** to the caller.\n    */\n    static int sqlite3PagerClose( Pager pPager )\n    {\n#if SQLITE_TEST\n      disable_simulated_io_errors();\n#endif\n      sqlite3BeginBenignMalloc();\n      pPager.errCode = 0;\n      pPager.exclusiveMode = false;\n      pager_reset( pPager );\n      if (\n#if SQLITE_OMIT_MEMORYDB\n1==MEMDB\n#else\n 1 == pPager.memDb\n#endif\n )\n      {\n        pager_unlock( pPager );\n      }\n      else\n      {\n        /* Set Pager.journalHdr to -1 for the benefit of the pager_playback()\n        ** call which may be made from within pagerUnlockAndRollback(). If it\n        ** is not -1, then the unsynced portion of an open journal file may\n        ** be played back into the database. If a power failure occurs while\n        ** this is happening, the database may become corrupt.\n        */\n        pPager.journalHdr = -1;\n        pagerUnlockAndRollback( pPager );\n      }\n      sqlite3EndBenignMalloc();\n#if SQLITE_TEST\n      enable_simulated_io_errors();\n#endif\n\n      PAGERTRACE( "CLOSE %d\\n", PAGERID( pPager ) );\n      IOTRACE( "CLOSE %p\\n", pPager );\n      sqlite3OsClose( pPager.fd );\n      //sqlite3_free( ref  pPager.pTmpSpace );\n      sqlite3PcacheClose( pPager.pPCache );\n\n#if SQLITE_HAS_CODEC\nif( pPager->xCodecFree ) pPager->xCodecFree(pPager->pCodec);\n#endif\n      Debug.Assert( null == pPager.aSavepoint && !pPager.pInJournal );\n      Debug.Assert( !isOpen( pPager.jfd ) && !isOpen( pPager.sjfd ) );\n\n      //sqlite3_free( ref  pPager );\n      return SQLITE_OK;\n    }\n\n#if !NDEBUG || SQLITE_TEST\n    /*\n** Return the page number for page pPg.\n*/\n    static Pgno sqlite3PagerPagenumber( DbPage pPg )\n    {\n      return pPg.pgno;\n    }\n#else\nstatic Pgno sqlite3PagerPagenumber( DbPage pPg )    {      return pPg.pgno;    }\n#endif\n\n\n    /*\n** Increment the reference count for page pPg.\n*/\n    static void sqlite3PagerRef( DbPage pPg )\n    {\n      sqlite3PcacheRef( pPg );\n    }\n\n    /*\n    ** Sync the journal. In other words, make sure all the pages that have\n    ** been written to the journal have actually reached the surface of the\n    ** disk and can be restored in the event of a hot-journal rollback.\n    **\n    ** If the Pager.needSync flag is not set, then this function is a\n    ** no-op. Otherwise, the actions required depend on the journal-mode\n    ** and the device characteristics of the the file-system, as follows:\n    **\n    **   * If the journal file is an in-memory journal file, no action need\n    **     be taken.\n    **\n    **   * Otherwise, if the device does not support the SAFE_APPEND property,\n    **     then the nRec field of the most recently written journal header\n    **     is updated to contain the number of journal records that have\n    **     been written following it. If the pager is operating in full-sync\n    **     mode, then the journal file is synced before this field is updated.\n    **\n    **   * If the device does not support the SEQUENTIAL property, then\n    **     journal file is synced.\n    **\n    ** Or, in pseudo-code:\n    **\n    **   if( NOT <in-memory journal> ){\n    **     if( NOT SAFE_APPEND ){\n    **       if( <full-sync mode> ) xSync(<journal file>);\n    **       <update nRec field>\n    **     }\n    **     if( NOT SEQUENTIAL ) xSync(<journal file>);\n    **   }\n    **\n    ** The Pager.needSync flag is never be set for temporary files, or any\n    ** file operating in no-sync mode (Pager.noSync set to non-zero).\n    **\n    ** If successful, this routine clears the PGHDR_NEED_SYNC flag of every\n    ** page currently held in memory before returning SQLITE_OK. If an IO\n    ** error is encountered, then the IO error code is returned to the caller.\n    */\n    static int syncJournal( Pager pPager )\n    {\n      if ( pPager.needSync )\n      {\n        Debug.Assert( !pPager.tempFile );\n        if ( pPager.journalMode != PAGER_JOURNALMODE_MEMORY )\n        {\n          int rc = SQLITE_OK;\n          int iDc = sqlite3OsDeviceCharacteristics( pPager.fd );\n          Debug.Assert( isOpen( pPager.jfd ) );\n\n          if ( 0 == ( iDc & SQLITE_IOCAP_SAFE_APPEND ) )\n          {\n            /* This block deals with an obscure problem. If the last connection\n            ** that wrote to this database was operating in persistent-journal\n            ** mode, then the journal file may at this point actually be larger\n            ** than Pager.journalOff bytes. If the next thing in the journal\n            ** file happens to be a journal-header (written as part of the\n            ** previous connections transaction), and a crash or power-failure\n            ** occurs after nRec is updated but before this connection writes\n            ** anything else to the journal file (or commits/rolls back its\n            ** transaction), then SQLite may become confused when doing the\n            ** hot-journal rollback following recovery. It may roll back all\n            ** of this connections data, then proceed to rolling back the old,\n            ** out-of-date data that follows it. Database corruption.\n            **\n            ** To work around this, if the journal file does appear to contain\n            ** a valid header following Pager.journalOff, then write a 0x00\n            ** byte to the start of it to prevent it from being recognized.\n            **\n            ** Variable iNextHdrOffset is set to the offset at which this\n            ** problematic header will occur, if it exists. aMagic is used\n            ** as a temporary buffer to inspect the first couple of bytes of\n            ** the potential journal header.\n            */\n            i64 iNextHdrOffset;\n            u8[] aMagic = new u8[8];\n            u8[] zHeader = new u8[aJournalMagic.Length + 4];\n            aJournalMagic.CopyTo( zHeader, 0 );// memcpy(zHeader, aJournalMagic, sizeof(aJournalMagic));\n            put32bits( zHeader, aJournalMagic.Length, pPager.nRec );\n            iNextHdrOffset = journalHdrOffset( pPager );\n            rc = sqlite3OsRead( pPager.jfd, aMagic, 8, iNextHdrOffset );\n            if ( rc == SQLITE_OK && 0 == memcmp( aMagic, aJournalMagic, 8 ) )\n            {\n              u8[] zerobyte = new u8[1];\n              rc = sqlite3OsWrite( pPager.jfd, zerobyte, 1, iNextHdrOffset );\n            }\n            if ( rc != SQLITE_OK && rc != SQLITE_IOERR_SHORT_READ )\n            {\n              return rc;\n            }\n\n            /* Write the nRec value into the journal file header. If in\n            ** full-synchronous mode, sync the journal first. This ensures that\n            ** all data has really hit the disk before nRec is updated to mark\n            ** it as a candidate for rollback.\n            **\n            ** This is not required if the persistent media supports the\n            ** SAFE_APPEND property. Because in this case it is not possible\n            ** for garbage data to be appended to the file, the nRec field\n            ** is populated with 0xFFFFFFFF when the journal header is written\n            ** and never needs to be updated.\n            */\n            if ( pPager.fullSync && 0 == ( iDc & SQLITE_IOCAP_SEQUENTIAL ) )\n            {\n\n              PAGERTRACE( "SYNC journal of %d\\n", PAGERID( pPager ) );\n              IOTRACE( "JSYNC %p\\n", pPager );\n              rc = sqlite3OsSync( pPager.jfd, pPager.sync_flags );\n              if ( rc != SQLITE_OK ) return rc;\n            }\n            IOTRACE( "JHDR %p %lld\\n", pPager, pPager.journalHdr );\n            rc = sqlite3OsWrite(\n            pPager.jfd, zHeader, zHeader.Length, pPager.journalHdr\n            );\n            if ( rc != SQLITE_OK ) return rc;\n          }\n          if ( 0 == ( iDc & SQLITE_IOCAP_SEQUENTIAL ) )\n          {\n\n            PAGERTRACE( "SYNC journal of %d\\n", PAGERID( pPager ) );\n            IOTRACE( "JSYNC %p\\n", pPager );\n            rc = sqlite3OsSync( pPager.jfd, pPager.sync_flags |\n            ( pPager.sync_flags == SQLITE_SYNC_FULL ? SQLITE_SYNC_DATAONLY : 0 )\n            );\n            if ( rc != SQLITE_OK ) return rc;\n          }\n        }\n\n        /* The journal file was just successfully synced. Set Pager.needSync\n        ** to zero and clear the PGHDR_NEED_SYNC flag on all pagess.\n        */\n        pPager.needSync = false;\n        pPager.journalStarted = true;\n        sqlite3PcacheClearSyncFlags( pPager.pPCache );\n      }\n      return SQLITE_OK;\n    }\n\n    /*\n    ** The argument is the first in a linked list of dirty pages connected\n    ** by the PgHdr.pDirty pointer. This function writes each one of the\n    ** in-memory pages in the list to the database file. The argument may\n    ** be NULL, representing an empty list. In this case this function is\n    ** a no-op.\n    **\n    ** The pager must hold at least a RESERVED lock when this function\n    ** is called. Before writing anything to the database file, this lock\n    ** is upgraded to an EXCLUSIVE lock. If the lock cannot be obtained,\n    ** SQLITE_BUSY is returned and no data is written to the database file.\n    **\n    ** If the pager is a temp-file pager and the actual file-system file\n    ** is not yet open, it is created and opened before any data is\n    ** written out.\n    **\n    ** Once the lock has been upgraded and, if necessary, the file opened,\n    ** the pages are written out to the database file in list order. Writing\n    ** a page is skipped if it meets either of the following criteria:\n    **\n    **   * The page number is greater than Pager.dbSize, or\n    **   * The PGHDR_DONT_WRITE flag is set on the page.\n    **\n    ** If writing out a page causes the database file to grow, Pager.dbFileSize\n    ** is updated accordingly. If page 1 is written out, then the value cached\n    ** in Pager.dbFileVers[] is updated to match the new value stored in\n    ** the database file.\n    **\n    ** If everything is successful, SQLITE_OK is returned. If an IO error\n    ** occurs, an IO error code is returned. Or, if the EXCLUSIVE lock cannot\n    ** be obtained, SQLITE_BUSY is returned.\n    */\n    static int pager_write_pagelist( PgHdr pList )\n    {\n      Pager pPager;                        /* Pager object */\n      int rc;                              /* Return code */\n\n      if (NEVER( pList == null )) return SQLITE_OK;\n      pPager = pList.pPager;\n\n      /* At this point there may be either a RESERVED or EXCLUSIVE lock on the\n      ** database file. If there is already an EXCLUSIVE lock, the following\n      ** call is a no-op.\n      **\n      ** Moving the lock from RESERVED to EXCLUSIVE actually involves going\n      ** through an intermediate state PENDING.   A PENDING lock prevents new\n      ** readers from attaching to the database but is unsufficient for us to\n      ** write.  The idea of a PENDING lock is to prevent new readers from\n      ** coming in while we wait for existing readers to clear.\n      **\n      ** While the pager is in the RESERVED state, the original database file\n      ** is unchanged and we can rollback without having to playback the\n      ** journal into the original database file.  Once we transition to\n      ** EXCLUSIVE, it means the database file has been changed and any rollback\n      ** will require a journal playback.\n      */\n      Debug.Assert( pPager.state >= PAGER_RESERVED );\n      rc = pager_wait_on_lock( pPager, EXCLUSIVE_LOCK );\n      /* If the file is a temp-file has not yet been opened, open it now. It\n      ** is not possible for rc to be other than SQLITE_OK if this branch\n      ** is taken, as pager_wait_on_lock() is a no-op for temp-files.\n      */\n      if ( !isOpen( pPager.fd ) )\n      {\n        Debug.Assert( pPager.tempFile && rc == SQLITE_OK );\n        rc = pagerOpentemp( pPager, ref  pPager.fd, (int)pPager.vfsFlags );\n      }\n\n      while ( rc == SQLITE_OK && pList )\n      {\n        Pgno pgno = pList.pgno;\n\n        /* If there are dirty pages in the page cache with page numbers greater\n        ** than Pager.dbSize, this means sqlite3PagerTruncateImage() was called to\n        ** make the file smaller (presumably by auto-vacuum code). Do not write\n        ** any such pages to the file.\n        **\n        ** Also, do not write out any page that has the PGHDR_DONT_WRITE flag\n        ** set (set by sqlite3PagerDontWrite()).\n        */\n        if ( pList.pgno <= pPager.dbSize && 0 == ( pList.flags & PGHDR_DONT_WRITE ) )\n        {\n          i64 offset = ( pList.pgno - 1 ) * (i64)pPager.pageSize;      /* Offset to write */\n          byte[] pData = null;                                   /* Data to write */\n\n          /* Encode the database */\n          CODEC2( pPager, pList.pData, pgno, 6, SQLITE_NOMEM, ref pData );//     CODEC2(pPager, pList->pData, pgno, 6, return SQLITE_NOMEM, pData);\n\n          /* Write out the page data. */\n          rc = sqlite3OsWrite( pPager.fd, pData, pPager.pageSize, offset );\n          /* If page 1 was just written, update Pager.dbFileVers to match\n          ** the value now stored in the database file. If writing this\n          ** page caused the database file to grow, update dbFileSize.\n          */\n          if ( pgno == 1 )\n          {\n            Buffer.BlockCopy( pData, 24, pPager.dbFileVers, 0, pPager.dbFileVers.Length );// memcpy(pPager.dbFileVers, pData[24], pPager.dbFileVers).Length;\n          }\n          if ( pgno > pPager.dbFileSize )\n          {\n            pPager.dbFileSize = pgno;\n          }\n          /* Update any backup objects copying the contents of this pager. */\n          sqlite3BackupUpdate( pPager.pBackup, pgno, pList.pData );\n\n\n          PAGERTRACE( "STORE %d page %d hash(%08x)\\n",\n          PAGERID( pPager ), pgno, pager_pagehash( pList ) );\n          IOTRACE( "PGOUT %p %d\\n", pPager, pgno );\n#if SQLITE_TEST\n          int iValue;\n          iValue = sqlite3_pager_writedb_count.iValue;\n          PAGER_INCR( ref iValue );\n          sqlite3_pager_writedb_count.iValue = iValue;\n\n          PAGER_INCR( ref pPager.nWrite );\n#endif\n        }\n        else\n        {\n\n          PAGERTRACE( "NOSTORE %d page %d\\n", PAGERID( pPager ), pgno );\n        }\n#if SQLITE_CHECK_PAGES\npList.pageHash = pager_pagehash(pList);\n#endif\n        pList = pList.pDirty;\n      }\n      return rc;\n    }\n\n    /*\n    ** Append a record of the current state of page pPg to the sub-journal.\n    ** It is the callers responsibility to use subjRequiresPage() to check\n    ** that it is really required before calling this function.\n    **\n    ** If successful, set the bit corresponding to pPg.pgno in the bitvecs\n    ** for all open savepoints before returning.\n    **\n    ** This function returns SQLITE_OK if everything is successful, an IO\n    ** error code if the attempt to write to the sub-journal fails, or\n    ** SQLITE_NOMEM if a malloc fails while setting a bit in a savepoint\n    ** bitvec.\n    */\n    static int subjournalPage( PgHdr pPg )\n    {\n      int rc = SQLITE_OK;\n      Pager pPager = pPg.pPager;\n      if ( isOpen( pPager.sjfd ) )\n      {\n        byte[] pData = pPg.pData;\n        i64 offset = pPager.nSubRec * ( 4 + pPager.pageSize );\n        byte[] pData2 = null;\n\n        CODEC2( pPager, pData, pPg.pgno, 7, SQLITE_NOMEM, ref pData2 );//CODEC2(pPager, pData, pPg.pgno, 7, return SQLITE_NOMEM, pData2);\n        PAGERTRACE( "STMT-JOURNAL %d page %d\\n", PAGERID( pPager ), pPg.pgno );\n        Debug.Assert( pageInJournal( pPg ) || pPg.pgno > pPager.dbOrigSize );\n        rc = write32bits( pPager.sjfd, offset, pPg.pgno );\n        if ( rc == SQLITE_OK )\n        {\n          rc = sqlite3OsWrite( pPager.sjfd, pData2, pPager.pageSize, offset + 4 );\n        }\n      }\n      if ( rc == SQLITE_OK )\n      {\n        pPager.nSubRec++;\n        Debug.Assert( pPager.nSavepoint > 0 );\n        rc = addToSavepointBitvecs( pPager, pPg.pgno );\n      }\n      return rc;\n    }\n\n    /*\n    ** This function is called by the pcache layer when it has reached some\n    ** soft memory limit. The first argument is a pointer to a Pager object\n    ** (cast as a void*). The pager is always \'purgeable\' (not an in-memory\n    ** database). The second argument is a reference to a page that is\n    ** currently dirty but has no outstanding references. The page\n    ** is always associated with the Pager object passed as the first\n    ** argument.\n    **\n    ** The job of this function is to make pPg clean by writing its contents\n    ** out to the database file, if possible. This may involve syncing the\n    ** journal file.\n    **\n    ** If successful, sqlite3PcacheMakeClean() is called on the page and\n    ** SQLITE_OK returned. If an IO error occurs while trying to make the\n    ** page clean, the IO error code is returned. If the page cannot be\n    ** made clean for some other reason, but no error occurs, then SQLITE_OK\n    ** is returned by sqlite3PcacheMakeClean() is not called.\n    */\n    static int pagerStress( object p, PgHdr pPg )\n    {\n      Pager pPager = (Pager)p;\n      int rc = SQLITE_OK;\n\n      Debug.Assert( pPg.pPager == pPager );\n      Debug.Assert( ( pPg.flags & PGHDR_DIRTY ) != 0 );\n\n      /* The doNotSync flag is set by the sqlite3PagerWrite() function while it\n      ** is journalling a set of two or more database pages that are stored\n      ** on the same disk sector. Syncing the journal is not allowed while\n      ** this is happening as it is important that all members of such a\n      ** set of pages are synced to disk together. So, if the page this function\n      ** is trying to make clean will require a journal sync and the doNotSync\n      ** flag is set, return without doing anything. The pcache layer will\n      ** just have to go ahead and allocate a new page buffer instead of\n      ** reusing pPg.\n      **\n      ** Similarly, if the pager has already entered the error state, do not\n      ** try to write the contents of pPg to disk.\n      */\n      if ( NEVER( pPager.errCode !=0)\n       || ( pPager.doNotSync && (pPg.flags & PGHDR_NEED_SYNC )!=0)\n      )\n      {\n        return SQLITE_OK;\n      }\n\n      /* Sync the journal file if required. */\n      if ( ( pPg.flags & PGHDR_NEED_SYNC ) != 0 )\n      {\n        rc = syncJournal( pPager );\n        if ( rc == SQLITE_OK && pPager.fullSync &&\n        !( pPager.journalMode == PAGER_JOURNALMODE_MEMORY ) &&\n        0 == ( sqlite3OsDeviceCharacteristics( pPager.fd ) & SQLITE_IOCAP_SAFE_APPEND )\n        )\n        {\n          pPager.nRec = 0;\n          rc = writeJournalHdr( pPager );\n        }\n      }\n\n      /* If the page number of this page is larger than the current size of\n      ** the database image, it may need to be written to the sub-journal.\n      ** This is because the call to pager_write_pagelist() below will not\n      ** actually write data to the file in this case.\n      **\n      ** Consider the following sequence of events:\n      **\n      **   BEGIN;\n      **     <journal page X>\n      **     <modify page X>\n      **     SAVEPOINT sp;\n      **       <shrink database file to Y pages>\n      **       pagerStress(page X)\n      **     ROLLBACK TO sp;\n      **\n      ** If (X>Y), then when pagerStress is called page X will not be written\n      ** out to the database file, but will be dropped from the cache. Then,\n      ** following the "ROLLBACK TO sp" statement, reading page X will read\n      ** data from the database file. This will be the copy of page X as it\n      ** was when the transaction started, not as it was when "SAVEPOINT sp"\n      ** was executed.\n      **\n      ** The solution is to write the current data for page X into the\n      ** sub-journal file now (if it is not already there), so that it will\n      ** be restored to its current value when the "ROLLBACK TO sp" is\n      ** executed.\n      */\n      if ( NEVER(\n           rc == SQLITE_OK && pPg.pgno > pPager.dbSize && subjRequiresPage( pPg )\n       ) )\n      {\n        rc = subjournalPage( pPg );\n      }\n\n      /* Write the contents of the page out to the database file. */\n      if ( rc == SQLITE_OK )\n      {\n        pPg.pDirty = null;\n        rc = pager_write_pagelist( pPg );\n      }\n\n      /* Mark the page as clean. */\n      if ( rc == SQLITE_OK )\n      {\n        PAGERTRACE( "STRESS %d page %d\\n", PAGERID( pPager ), pPg.pgno );\n        sqlite3PcacheMakeClean( pPg );\n      }\n\n      return pager_error( pPager, rc );\n    }\n\n\n    /*\n    ** Allocate and initialize a new Pager object and put a pointer to it\n    ** in *ppPager. The pager should eventually be freed by passing it\n    ** to sqlite3PagerClose().\n    **\n    ** The zFilename argument is the path to the database file to open.\n    ** If zFilename is NULL then a randomly-named temporary file is created\n    ** and used as the file to be cached. Temporary files are be deleted\n    ** automatically when they are closed. If zFilename is ":memory:" then\n    ** all information is held in cache. It is never written to disk.\n    ** This can be used to implement an in-memory database.\n    **\n    ** The nExtra parameter specifies the number of bytes of space allocated\n    ** along with each page reference. This space is available to the user\n    ** via the sqlite3PagerGetExtra() API.\n    **\n    ** The flags argument is used to specify properties that affect the\n    ** operation of the pager. It should be passed some bitwise combination\n    ** of the PAGER_OMIT_JOURNAL and PAGER_NO_READLOCK flags.\n    **\n    ** The vfsFlags parameter is a bitmask to pass to the flags parameter\n    ** of the xOpen() method of the supplied VFS when opening files.\n    **\n    ** If the pager object is allocated and the specified file opened\n    ** successfully, SQLITE_OK is returned and *ppPager set to point to\n    ** the new pager object. If an error occurs, *ppPager is set to NULL\n    ** and error code returned. This function may return SQLITE_NOMEM\n    ** (sqlite3Malloc() is used to allocate memory), SQLITE_CANTOPEN or\n    ** various SQLITE_IO_XXX errors.\n    */\n    static int sqlite3PagerOpen(\n    sqlite3_vfs pVfs,        /* The virtual file system to use */\n    ref Pager ppPager,       /* OUT: Return the Pager structure here */\n    string zFilename,        /* Name of the database file to open */\n    int nExtra,              /* Extra bytes append to each in-memory page */\n    int flags,               /* flags controlling this file */\n    int vfsFlags,            /* flags passed through to sqlite3_vfs.xOpen() */\n    dxReiniter xReinit       /* Function to reinitialize pages */  \n    )\n    {\n      u8 pPtr;\n      Pager pPager = null;     /* Pager object to allocate and return */\n      int rc = SQLITE_OK;      /* Return code */\n      u8 tempFile = 0;         /* True for temp files (incl. in-memory files) */ // Needs to be u8 for later tests\n      u8 memDb = 0;            /* True if this is an in-memory file */\n      bool readOnly = false;   /* True if this is a read-only file */\n      int journalFileSize;     /* Bytes to allocate for each journal fd */\n      StringBuilder zPathname = null; /* Full path to database file */\n      int nPathname = 0;       /* Number of bytes in zPathname */\n      bool useJournal = ( flags & PAGER_OMIT_JOURNAL ) == 0; /* False to omit journal */\n      bool noReadlock = ( flags & PAGER_NO_READLOCK ) != 0;  /* True to omit read-lock */\n      int pcacheSize = sqlite3PcacheSize();       /* Bytes to allocate for PCache */\n      u16 szPageDflt = SQLITE_DEFAULT_PAGE_SIZE;  /* Default page size */\n\n      /* Figure out how much space is required for each journal file-handle\n      ** (there are two of them, the main journal and the sub-journal). This\n      ** is the maximum space required for an in-memory journal file handle\n      ** and a regular journal file-handle. Note that a "regular journal-handle"\n      ** may be a wrapper capable of caching the first portion of the journal\n      ** file in memory to implement the atomic-write optimization (see\n      ** source file journal.c).\n      */\n      if ( sqlite3JournalSize( pVfs ) > sqlite3MemJournalSize() )\n      {\n        journalFileSize = ROUND8( sqlite3JournalSize( pVfs ) );\n      }\n      else\n      {\n        journalFileSize = ROUND8( sqlite3MemJournalSize() );\n      }\n\n      /* Set the output variable to NULL in case an error occurs. */\n      ppPager = null;\n\n      /* Compute and store the full pathname in an allocated buffer pointed\n      ** to by zPathname, length nPathname. Or, if this is a temporary file,\n      ** leave both nPathname and zPathname set to 0.\n      */\n      if ( !String.IsNullOrEmpty( zFilename ) )\n      {\n        nPathname = pVfs.mxPathname + 1;\n        zPathname = new StringBuilder( nPathname * 2 );// sqlite3Malloc( nPathname * 2 );\n        if ( zPathname == null )\n        {\n          return SQLITE_NOMEM;\n        }\n#if !SQLITE_OMIT_MEMORYDB\n        if ( zFilename == ":memory:" )//if( strcmp(zFilename,":memory:")==null )\n        {\n          memDb = 1;\n          zPathname.Length = 0;\n        }\n        else\n#endif\n        {\n          //zPathname[0] = 0; /* Make sure initialized even if FullPathname() fails */\n          rc = sqlite3OsFullPathname( pVfs, zFilename, nPathname, zPathname );\n        }\n\n        nPathname = sqlite3Strlen30( zPathname );\n        if ( rc == SQLITE_OK && nPathname + 8 > pVfs.mxPathname )\n        {\n          /* This branch is taken when the journal path required by\n          ** the database being opened will be more than pVfs.mxPathname\n          ** bytes in length. This means the database cannot be opened,\n          ** as it will not be possible to open the journal file or even\n          ** check for a hot-journal before reading.\n          */\n          rc = SQLITE_CANTOPEN;\n        }\n        if ( rc != SQLITE_OK )\n        {\n          //sqlite3_free( ref zPathname );\n          return rc;\n        }\n      }\n\n      /* Allocate memory for the Pager structure, PCache object, the\n      ** three file descriptors, the database file name and the journal\n      ** file name. The layout in memory is as follows:\n      **\n      **     Pager object                    (sizeof(Pager) bytes)\n      **     PCache object                   (sqlite3PcacheSize() bytes)\n      **     Database file handle            (pVfs.szOsFile bytes)\n      **     Sub-journal file handle         (journalFileSize bytes)\n      **     Main journal file handle        (journalFileSize bytes)\n      **     Database file name              (nPathname+1 bytes)\n      **     Journal file name               (nPathname+8+1 bytes)\n      */\n      //pPtr = (u8 *)sqlite3MallocZero(\n      //  ROUND8(sizeof(*pPager)) +           /* Pager structure */\n      //  ROUND8(pcacheSize)      +           /* PCache object */\n      //  ROUND8(pVfs.szOsFile)   +           /* The main db file */\n      //  journalFileSize * 2 +       /* The two journal files */\n      //  nPathname + 1 +             /* zFilename */\n      //  nPathname + 8 + 1           /* zJournal */\n      //);\n      //  assert( EIGHT_BYTE_ALIGNMENT(SQLITE_INT_TO_PTR(journalFileSize)));\n      //if( !pPtr ){\n      //  //sqlite3_free(zPathname);\n      //  return SQLITE_NOMEM;\n      //}\n      pPager = new Pager();//(Pager*)(pPtr);\n      pPager.pPCache = new PCache();//(PCache*)(pPtr += ROUND8(sizeof(*pPager)));\n      pPager.fd = new sqlite3_file();//(sqlite3_file*)(pPtr += ROUND8(pcacheSize));\n      pPager.sjfd = new sqlite3_file();//(sqlite3_file*)(pPtr += ROUND8(pVfs->szOsFile));\n      pPager.jfd = new sqlite3_file();//(sqlite3_file*)(pPtr += journalFileSize);\n      //pPager.zFilename =    (char*)(pPtr += journalFileSize);\n      //assert( EIGHT_BYTE_ALIGNMENT(pPager->jfd) );\n\n      /* Fill in the Pager.zFilename and Pager.zJournal buffers, if required. */\n      if ( zPathname != null )\n      {\n        //pPager.zJournal =   (char*)(pPtr += nPathname + 1);\n        //memcpy(pPager.zFilename, zPathname, nPathname);\n        pPager.zFilename = zPathname.ToString();\n        //memcpy(pPager.zJournal, zPathname, nPathname);\n        //memcpy(&pPager.zJournal[nPathname], "-journal", 8);\n        pPager.zJournal = pPager.zFilename + "-journal";\n        if ( pPager.zFilename.Length==0) pPager.zJournal = "";\n        //sqlite3_free( ref zPathname );\n      }\n      else\n      {\n        pPager.zFilename = "";\n      }\n      pPager.pVfs = pVfs;\n      pPager.vfsFlags = (u32)vfsFlags;\n\n      /* Open the pager file.\n      */\n      if (!String.IsNullOrEmpty(zFilename) && 0 == memDb)\n      {\n        int fout = 0;                    /* VFS flags returned by xOpen() */\n        rc = sqlite3OsOpen( pVfs, pPager.zFilename, pPager.fd, vfsFlags, ref fout );\n        readOnly = ( fout & SQLITE_OPEN_READONLY ) != 0;\n\n        /* If the file was successfully opened for read/write access,\n        ** choose a default page size in case we have to create the\n        ** database file. The default page size is the maximum of:\n        **\n        **    + SQLITE_DEFAULT_PAGE_SIZE,\n        **    + The value returned by sqlite3OsSectorSize()\n        **    + The largest page size that can be written atomically.\n        */\n        if ( rc == SQLITE_OK && !readOnly )\n        {\n          setSectorSize( pPager );\n          Debug.Assert( SQLITE_DEFAULT_PAGE_SIZE <= SQLITE_MAX_DEFAULT_PAGE_SIZE );\n          if ( szPageDflt < pPager.sectorSize )\n          {\n            if ( pPager.sectorSize > SQLITE_MAX_DEFAULT_PAGE_SIZE )\n            {\n              szPageDflt = SQLITE_MAX_DEFAULT_PAGE_SIZE;\n            }\n            else\n            {\n              szPageDflt = (u16)pPager.sectorSize;\n            }\n          }\n#if SQLITE_ENABLE_ATOMIC_WRITE\n{\nint iDc = sqlite3OsDeviceCharacteristics(pPager.fd);\nint ii;\nDebug.Assert(SQLITE_IOCAP_ATOMIC512==(512>>8));\nDebug.Assert(SQLITE_IOCAP_ATOMIC64K==(65536>>8));\nDebug.Assert(SQLITE_MAX_DEFAULT_PAGE_SIZE<=65536);\nfor(ii=szPageDflt; ii<=SQLITE_MAX_DEFAULT_PAGE_SIZE; ii=ii*2){\nif( iDc&(SQLITE_IOCAP_ATOMIC|(ii>>8)) ){\nszPageDflt = ii;\n}\n}\n}\n#endif\n        }\n      }\n      else\n      {\n        /* If a temporary file is requested, it is not opened immediately.\n        ** In this case we accept the default page size and delay actually\n        ** opening the file until the first call to OsWrite().\n        **\n        ** This branch is also run for an in-memory database. An in-memory\n        ** database is the same as a temp-file that is never written out to\n        ** disk and uses an in-memory rollback journal.\n        */\n        tempFile = 1;\n        pPager.state = PAGER_EXCLUSIVE;\n        readOnly = ( vfsFlags & SQLITE_OPEN_READONLY ) != 0;\n      }\n\n      /* The following call to PagerSetPagesize() serves to set the value of\n      ** Pager.pageSize and to allocate the Pager.pTmpSpace buffer.\n      */\n      if ( rc == SQLITE_OK )\n      {\n        Debug.Assert( pPager.memDb == 0 );\n        rc = sqlite3PagerSetPagesize( pPager, ref szPageDflt, -1 );\n        testcase( rc != SQLITE_OK );\n      }\n\n      /* If an error occurred in either of the blocks above, free the\n      ** Pager structure and close the file.\n      */\n      if ( rc != SQLITE_OK )\n      {\n        Debug.Assert( null == pPager.pTmpSpace );\n        sqlite3OsClose( pPager.fd );\n        //sqlite3_free( ref pPager );\n        return rc;\n      }\n\n      /* Initialize the PCache object. */\n      Debug.Assert( nExtra < 1000 );\n      nExtra = ROUND8( nExtra );\n      sqlite3PcacheOpen(szPageDflt, nExtra, 0 == memDb,\n      0 == memDb ? (dxStress)pagerStress : null, pPager, pPager.pPCache);\n\n      PAGERTRACE( "OPEN %d %s\\n", FILEHANDLEID( pPager.fd ), pPager.zFilename );\n      IOTRACE( "OPEN %p %s\\n", pPager, pPager.zFilename );\n      pPager.useJournal = (u8)( useJournal ? 1 : 0 );\n      pPager.noReadlock = (u8)( noReadlock && readOnly ? 1 : 0 );\n      /* pPager.stmtOpen = 0; */\n      /* pPager.stmtInUse = 0; */\n      /* pPager.nRef = 0; */\n      pPager.dbSizeValid = memDb!=0;\n      /* pPager.stmtSize = 0; */\n      /* pPager.stmtJSize = 0; */\n      /* pPager.nPage = 0; */\n      pPager.mxPgno = SQLITE_MAX_PAGE_COUNT;\n      /* pPager.state = PAGER_UNLOCK; */\n      Debug.Assert( pPager.state == ( tempFile != 0 ? PAGER_EXCLUSIVE : PAGER_UNLOCK ) );\n      /* pPager.errMask = 0; */\n      pPager.tempFile = tempFile != 0;\n      Debug.Assert( tempFile == PAGER_LOCKINGMODE_NORMAL\n      || tempFile == PAGER_LOCKINGMODE_EXCLUSIVE );\n      Debug.Assert( PAGER_LOCKINGMODE_EXCLUSIVE == 1 );\n      pPager.exclusiveMode = tempFile != 0;\n      pPager.changeCountDone = pPager.tempFile;\n      pPager.memDb = memDb;\n      pPager.readOnly = readOnly;\n      /* pPager.needSync = 0; */\n      Debug.Assert( useJournal || pPager.tempFile );\n      pPager.noSync = pPager.tempFile;\n      pPager.fullSync = pPager.noSync;\n      pPager.sync_flags = SQLITE_SYNC_NORMAL;\n      /* pPager.pFirst = 0; */\n      /* pPager.pFirstSynced = 0; */\n      /* pPager.pLast = 0; */\n      pPager.nExtra = (u16)nExtra;\n      pPager.journalSizeLimit = SQLITE_DEFAULT_JOURNAL_SIZE_LIMIT;\n      Debug.Assert( isOpen( pPager.fd ) || tempFile != 0 );\n      setSectorSize( pPager );\n      if ( !useJournal )\n      {\n        pPager.journalMode = PAGER_JOURNALMODE_OFF;\n      }\n      else if ( memDb != 0 )\n      {\n        pPager.journalMode = PAGER_JOURNALMODE_MEMORY;\n      }\n      /* pPager.xBusyHandler = 0; */\n      /* pPager.pBusyHandlerArg = 0; */\n      pPager.xReiniter = xReinit;\n      /* memset(pPager.aHash, 0, sizeof(pPager.aHash)); */\n      ppPager = pPager;\n      return SQLITE_OK;\n    }\n\n\n\n    /*\n    ** This function is called after transitioning from PAGER_UNLOCK to\n    ** PAGER_SHARED state. It tests if there is a hot journal present in\n    ** the file-system for the given pager. A hot journal is one that\n    ** needs to be played back. According to this function, a hot-journal\n    ** file exists if the following criteria are met:\n    **\n    **   * The journal file exists in the file system, and\n    **   * No process holds a RESERVED or greater lock on the database file, and\n    **   * The database file itself is greater than 0 bytes in size, and\n    **   * The first byte of the journal file exists and is not 0x00.\n    **\n    ** If the current size of the database file is 0 but a journal file\n    ** exists, that is probably an old journal left over from a prior\n    ** database with the same name. In this case the journal file is\n    ** just deleted using OsDelete, *pExists is set to 0 and SQLITE_OK\n    ** is returned.\n    **\n    ** This routine does not check if there is a master journal filename\n    ** at the end of the file. If there is, and that master journal file\n    ** does not exist, then the journal file is not really hot. In this\n    ** case this routine will return a false-positive. The pager_playback()\n    ** routine will discover that the journal file is not really hot and\n    ** will not roll it back.\n    **\n    ** If a hot-journal file is found to exist, *pExists is set to 1 and\n    ** SQLITE_OK returned. If no hot-journal file is present, *pExists is\n    ** set to 0 and SQLITE_OK returned. If an IO error occurs while trying\n    ** to determine whether or not a hot-journal file exists, the IO error\n    ** code is returned and the value of *pExists is undefined.\n    */\n    static int hasHotJournal( Pager pPager, ref int pExists )\n    {\n      sqlite3_vfs pVfs = pPager.pVfs;\n      int rc;                       /* Return code */\n      int exists = 0;               /* True if a journal file is present */\n      Debug.Assert( pPager != null );\n      Debug.Assert( pPager.useJournal != 0 );\n      Debug.Assert( pPager.state <= PAGER_SHARED );\n\n      pExists = 0;\n\n      rc = sqlite3OsAccess( pVfs, pPager.zJournal, SQLITE_ACCESS_EXISTS, ref exists );\n      if ( rc == SQLITE_OK && exists != 0 )\n      {\n        int locked = 0;                 /* True if some process holds a RESERVED lock */\n\n        /* Race condition here:  Another process might have been holding the\n        ** the RESERVED lock and have a journal open at the sqlite3OsAccess()\n        ** call above, but then delete the journal and drop the lock before\n        ** we get to the following sqlite3OsCheckReservedLock() call.  If that\n        ** is the case, this routine might think there is a hot journal when\n        ** in fact there is none.  This results in a false-positive which will\n        ** be dealt with by the playback routine.  Ticket #3883.\n        */\n        rc = sqlite3OsCheckReservedLock( pPager.fd, ref locked );\n        if ( rc == SQLITE_OK && locked == 0 )\n        {\n          int nPage = 0;\n\n          /* Check the size of the database file. If it consists of 0 pages,\n          ** then delete the journal file. See the header comment above for\n          ** the reasoning here.  Delete the obsolete journal file under\n          ** a RESERVED lock to avoid race conditions and to avoid violating\n          ** [H33020].\n          */\n          rc = sqlite3PagerPagecount( pPager, ref nPage );\n          if ( rc == SQLITE_OK )\n          {\n            if ( nPage == 0 )\n            {\n              sqlite3BeginBenignMalloc();\n              if ( sqlite3OsLock( pPager.fd, RESERVED_LOCK ) == SQLITE_OK )\n              {\n                sqlite3OsDelete( pVfs, pPager.zJournal, 0 );\n                sqlite3OsUnlock( pPager.fd, SHARED_LOCK );\n              }\n              sqlite3EndBenignMalloc();\n            }\n            else\n            {\n              /* The journal file exists and no other connection has a reserved\n              ** or greater lock on the database file. Now check that there is\n              ** at least one non-zero bytes at the start of the journal file.\n              ** If there is, then we consider this journal to be hot. If not,\n              ** it can be ignored.\n              */\n              int f = SQLITE_OPEN_READONLY | SQLITE_OPEN_MAIN_JOURNAL;\n              rc = sqlite3OsOpen( pVfs, pPager.zJournal, pPager.jfd, f, ref f );\n              if ( rc == SQLITE_OK )\n              {\n                u8[] first = new u8[1];\n                rc = sqlite3OsRead( pPager.jfd, first, 1, 0 );\n                if ( rc == SQLITE_IOERR_SHORT_READ )\n                {\n                  rc = SQLITE_OK;\n                }\n                sqlite3OsClose( pPager.jfd );\n                pExists = ( first[0] != 0 ) ? 1 : 0;\n              }\n              else if ( rc == SQLITE_CANTOPEN )\n              {\n                /* If we cannot open the rollback journal file in order to see if\n                ** its has a zero header, that might be due to an I/O error, or\n                ** it might be due to the race condition described above and in\n                ** ticket #3883.  Either way, assume that the journal is hot.\n                ** This might be a false positive.  But if it is, then the\n                ** automatic journal playback and recovery mechanism will deal\n                ** with it under an EXCLUSIVE lock where we do not need to\n                ** worry so much with race conditions.\n                */\n                pExists = 1;\n                rc = SQLITE_OK;\n              }\n            }\n          }\n        }\n      }\n      return rc;\n    }\n\n\n    /*\n    ** Read the content for page pPg out of the database file and into\n    ** pPg->pData. A shared lock or greater must be held on the database\n    ** file before this function is called.\n    **\n    ** If page 1 is read, then the value of Pager.dbFileVers[] is set to\n    ** the value read from the database file.\n    **\n    ** If an IO error occurs, then the IO error is returned to the caller.\n    ** Otherwise, SQLITE_OK is returned.\n    */\n    static int readDbPage( PgHdr pPg )\n    {\n      Pager pPager = pPg.pPager;   /* Pager object associated with page pPg */\n      Pgno pgno = pPg.pgno;        /* Page number to read */\n      int rc;                      /* Return code */\n      i64 iOffset;                 /* Byte offset of file to read from */\n#if SQLITE_OMIT_MEMORYDB\nDebug.Assert(  pPager.state>=PAGER_SHARED && 0==MEMDB );\n#endif\n      Debug.Assert( isOpen( pPager.fd ) );\n      Debug.Assert( pPager.fd.pMethods != null || pPager.tempFile );\n      if ( NEVER(!isOpen( pPager.fd ) ))\n      {\n        Debug.Assert( pPager.tempFile );\n        pPg.pData = new u8[pPager.pageSize];//memset(pPg->pData, 0, pPager.pageSize);\n        return SQLITE_OK;\n      }\n      iOffset = ( pgno - 1 ) * (i64)pPager.pageSize;\n      rc = sqlite3OsRead( pPager.fd, pPg.pData, pPager.pageSize, iOffset );\n      if ( rc == SQLITE_IOERR_SHORT_READ )\n      {\n        rc = SQLITE_OK;\n      }\n      if ( pgno == 1 )\n      {\n        //u8 *dbFileVers = &((u8*)pPg->pData)[24];\n        //memcpy(&pPager.dbFileVers, dbFileVers, sizeof(pPager.dbFileVers));\n        Buffer.BlockCopy( pPg.pData, 24, pPager.dbFileVers, 0, pPager.dbFileVers.Length );\n      }\n#if SQLITE_HAS_CODEC\nCODEC1(pPager, pPg.pData, pPg.pgno, 3, rc = SQLITE_NOMEM);\n#endif\n#if SQLITE_TEST\n      int iValue;\n      iValue = sqlite3_pager_readdb_count.iValue;\n      PAGER_INCR( ref iValue );\n      sqlite3_pager_readdb_count.iValue = iValue;\n\n      PAGER_INCR( ref pPager.nRead );\n#endif\n      IOTRACE( "PGIN %p %d\\n", pPager, pgno );\n      PAGERTRACE( "FETCH %d page %d hash(%08x)\\n",\n      PAGERID( pPager ), pgno, pager_pagehash( pPg ) );\n      return rc;\n    }\n\n\n    /*\n    ** This function is called to obtain a shared lock on the database file.\n    ** It is illegal to call sqlite3PagerAcquire() until after this function\n    ** has been successfully called. If a shared-lock is already held when\n    ** this function is called, it is a no-op.\n    **\n    ** The following operations are also performed by this function.\n    **\n    **   1) If the pager is currently in PAGER_UNLOCK state (no lock held\n    **      on the database file), then an attempt is made to obtain a\n    **      SHARED lock on the database file. Immediately after obtaining\n    **      the SHARED lock, the file-system is checked for a hot-journal,\n    **      which is played back if present. Following any hot-journal\n    **      rollback, the contents of the cache are validated by checking\n    **      the \'change-counter\' field of the database file header and\n    **      discarded if they are found to be invalid.\n    **\n    **   2) If the pager is running in exclusive-mode, and there are currently\n    **      no outstanding references to any pages, and is in the error state,\n    **      then an attempt is made to clear the error state by discarding\n    **      the contents of the page cache and rolling back any open journal\n    **      file.\n    **\n    ** If the operation described by (2) above is not attempted, and if the\n    ** pager is in an error state other than SQLITE_FULL when this is called,\n    ** the error state error code is returned. It is permitted to read the\n    ** database when in SQLITE_FULL error state.\n    **\n    ** Otherwise, if everything is successful, SQLITE_OK is returned. If an\n    ** IO error occurs while locking the database, checking for a hot-journal\n    ** file or rolling back a journal file, the IO error code is returned.\n    */\n    static int sqlite3PagerSharedLock( Pager pPager )\n    {\n      int rc = SQLITE_OK;               /* Return code */\n      bool isErrorReset = false;        /* True if recovering from error state */\n\n      if ( pPager.errCode != 0 )\n      {\n        if ( isOpen( pPager.jfd ) || !String.IsNullOrEmpty( pPager.zJournal ) )\n        {\n          isErrorReset = true;\n        }\n        pPager.errCode = SQLITE_OK;\n        pager_reset( pPager );\n      }\n\n      if ( pPager.state == PAGER_UNLOCK || isErrorReset )\n      {\n        sqlite3_vfs pVfs = pPager.pVfs;\n        int isHotJournal = 0;\n        Debug.Assert(\n#if SQLITE_OMIT_MEMORYDB\n0==MEMDB\n#else\n 0 == pPager.memDb\n#endif\n );\n        Debug.Assert( sqlite3PcacheRefCount( pPager.pPCache ) == 0 );\n        if ( pPager.noReadlock != 0 )\n        {\n          Debug.Assert( pPager.readOnly );\n          pPager.state = PAGER_SHARED;\n        }\n        else\n        {\n          rc = pager_wait_on_lock( pPager, SHARED_LOCK );\n          if ( rc != SQLITE_OK )\n          {\n            Debug.Assert( pPager.state == PAGER_UNLOCK );\n            return pager_error( pPager, rc );\n          }\n        }\n        Debug.Assert( pPager.state >= SHARED_LOCK );\n\n        /* If a journal file exists, and there is no RESERVED lock on the\n        ** database file, then it either needs to be played back or deleted.\n        */\n        if ( !isErrorReset )\n        {\n          Debug.Assert( pPager.state <= PAGER_SHARED );\n          rc = hasHotJournal( pPager, ref isHotJournal );\n          if ( rc != SQLITE_OK )\n          {\n            goto failed;\n          }\n        }\n        if ( isErrorReset || isHotJournal != 0 )\n        {\n          /* Get an EXCLUSIVE lock on the database file. At this point it is\n          ** important that a RESERVED lock is not obtained on the way to the\n          ** EXCLUSIVE lock. If it were, another process might open the\n          ** database file, detect the RESERVED lock, and conclude that the\n          ** database is safe to read while this process is still rolling the\n          ** hot-journal back.\n          **\n          ** Because the intermediate RESERVED lock is not requested, any\n          ** other process attempting to access the database file will get to\n          ** this point in the code and fail to obtain its own EXCLUSIVE lock\n          ** on the database file.\n          */\n          if ( pPager.state < EXCLUSIVE_LOCK )\n          {\n            rc = sqlite3OsLock( pPager.fd, EXCLUSIVE_LOCK );\n            if ( rc != SQLITE_OK )\n            {\n              rc = pager_error( pPager, rc );\n              goto failed;\n            }\n            pPager.state = PAGER_EXCLUSIVE;\n          }\n          /* Open the journal for read/write access. This is because in\n          ** exclusive-access mode the file descriptor will be kept open and\n          ** possibly used for a transaction later on. On some systems, the\n          ** OsTruncate() call used in exclusive-access mode also requires\n          ** a read/write file handle.\n          */\n          if ( !isOpen( pPager.jfd ) )\n          {\n            int res = 0;\n            rc = sqlite3OsAccess( pVfs, pPager.zJournal, SQLITE_ACCESS_EXISTS, ref res );\n            if ( rc == SQLITE_OK )\n            {\n              if ( res != 0 )\n              {\n                int fout = 0;\n                int f = SQLITE_OPEN_READWRITE | SQLITE_OPEN_MAIN_JOURNAL;\n                Debug.Assert( !pPager.tempFile );\n                rc = sqlite3OsOpen( pVfs, pPager.zJournal, pPager.jfd, f, ref fout );\n                Debug.Assert( rc != SQLITE_OK || isOpen( pPager.jfd ) );\n                if ( rc == SQLITE_OK && ( fout & SQLITE_OPEN_READONLY ) != 0 )\n                {\n                  rc = SQLITE_CANTOPEN;\n                  sqlite3OsClose( pPager.jfd );\n                }\n              }\n              else\n              {\n                /* If the journal does not exist, it usually means that some\n                ** other connection managed to get in and roll it back before\n                ** this connection obtained the exclusive lock above. Or, it\n                ** may mean that the pager was in the error-state when this\n                ** function was called and the journal file does not exist.  */\n                rc = pager_end_transaction( pPager, 0 );\n              }\n            }\n          }\n          if ( rc != SQLITE_OK )\n          {\n            goto failed;\n          }\n\n          /* TODO: Why are these cleared here? Is it necessary? */\n          pPager.journalStarted = false;\n          pPager.journalOff = 0;\n          pPager.setMaster = 0;\n          pPager.journalHdr = 0;\n\n          /* Playback and delete the journal.  Drop the database write\n          ** lock and reacquire the read lock. Purge the cache before\n          ** playing back the hot-journal so that we don\'t end up with\n          ** an inconsistent cache.\n          */\n          if ( isOpen( pPager.jfd ) )\n          {\n            rc = pager_playback( pPager, 1 );\n            if ( rc != SQLITE_OK )\n            {\n              rc = pager_error( pPager, rc );\n              goto failed;\n            }\n          }\n          Debug.Assert( ( pPager.state == PAGER_SHARED )\n          || ( pPager.exclusiveMode && pPager.state > PAGER_SHARED )\n          );\n        }\n\n        if ( pPager.pBackup != null || sqlite3PcachePagecount( pPager.pPCache ) > 0 )\n        {\n          /* The shared-lock has just been acquired on the database file\n          ** and there are already pages in the cache (from a previous\n          ** read or write transaction).  Check to see if the database\n          ** has been modified.  If the database has changed, flush the\n          ** cache.\n          **\n          ** Database changes is detected by looking at 15 bytes beginning\n          ** at offset 24 into the file.  The first 4 of these 16 bytes are\n          ** a 32-bit counter that is incremented with each change.  The\n          ** other bytes change randomly with each file change when\n          ** a codec is in use.\n          **\n          ** There is a vanishingly small chance that a change will not be\n          ** detected.  The chance of an undetected change is so small that\n          ** it can be neglected.\n          */\n          byte[] dbFileVers = new byte[pPager.dbFileVers.Length];\n          int idummy = 0;\n          sqlite3PagerPagecount( pPager, ref  idummy );\n\n          if ( pPager.errCode != 0 )\n          {\n            rc = pPager.errCode;\n            goto failed;\n          }\n\n          Debug.Assert( pPager.dbSizeValid );\n          if ( pPager.dbSize > 0 )\n          {\n            IOTRACE( "CKVERS %p %d\\n", pPager, dbFileVers.Length );\n            rc = sqlite3OsRead( pPager.fd, dbFileVers, dbFileVers.Length, 24 );\n            if ( rc != SQLITE_OK )\n            {\n              goto failed;\n            }\n          }\n          else\n          {\n            dbFileVers = new byte[dbFileVers.Length]; //memset(dbFileVers, 0, dbFileVers).Length;\n          }\n\n          // This loop is very short -- so only minor performance hit\n          for ( int i = 0 ; i < dbFileVers.Length ; i++ )             //if (memcmp(pPager.dbFileVers, dbFileVers, dbFileVers).Length != 0)\n            if ( pPager.dbFileVers[i] != dbFileVers[i] )\n            {\n              pager_reset( pPager );\n              break;\n            }\n        }\n        Debug.Assert( pPager.exclusiveMode || pPager.state == PAGER_SHARED );\n      }\n\nfailed:\n      if ( rc != SQLITE_OK )\n      {\n        /* pager_unlock() is a no-op for exclusive mode and in-memory databases. */\n        pager_unlock( pPager );\n      }\n      return rc;\n    }\n\n    /*\n    ** If the reference count has reached zero, rollback any active\n    ** transaction and unlock the pager.\n    **\n    ** Except, in locking_mode=EXCLUSIVE when there is nothing to in\n    ** the rollback journal, the unlock is not performed and there is\n    ** nothing to rollback, so this routine is a no-op.\n    */\n    static void pagerUnlockIfUnused( Pager pPager )\n    {\n      if ( ( sqlite3PcacheRefCount( pPager.pPCache ) == 0 )\n      && ( !pPager.exclusiveMode || pPager.journalOff > 0 ) )\n      {\n        pagerUnlockAndRollback( pPager );\n      }\n    }\n\n    /*\n    ** Acquire a reference to page number pgno in pager pPager (a page\n    ** reference has type DbPage*). If the requested reference is\n    ** successfully obtained, it is copied to *ppPage and SQLITE_OK returned.\n    **\n    ** If the requested page is already in the cache, it is returned.\n    ** Otherwise, a new page object is allocated and populated with data\n    ** read from the database file. In some cases, the pcache module may\n    ** choose not to allocate a new page object and may reuse an existing\n    ** object with no outstanding references.\n    **\n    ** The extra data appended to a page is always initialized to zeros the\n    ** first time a page is loaded into memory. If the page requested is\n    ** already in the cache when this function is called, then the extra\n    ** data is left as it was when the page object was last used.\n    **\n    ** If the database image is smaller than the requested page or if a\n    ** non-zero value is passed as the noContent parameter and the\n    ** requested page is not already stored in the cache, then no\n    ** actual disk read occurs. In this case the memory image of the\n    ** page is initialized to all zeros.\n    **\n    ** If noContent is true, it means that we do not care about the contents\n    ** of the page. This occurs in two seperate scenarios:\n    **\n    **   a) When reading a free-list leaf page from the database, and\n    **\n    **   b) When a savepoint is being rolled back and we need to load\n    **      a new page into the cache to populate with the data read\n    **      from the savepoint journal.\n    **\n    ** If noContent is true, then the data returned is zeroed instead of\n    ** being read from the database. Additionally, the bits corresponding\n    ** to pgno in Pager.pInJournal (bitvec of pages already written to the\n    ** journal file) and the PagerSavepoint.pInSavepoint bitvecs of any open\n    ** savepoints are set. This means if the page is made writable at any\n    ** point in the future, using a call to sqlite3PagerWrite(), its contents\n    ** will not be journaled. This saves IO.\n    **\n    ** The acquisition might fail for several reasons.  In all cases,\n    ** an appropriate error code is returned and *ppPage is set to NULL.\n    **\n    ** See also sqlite3PagerLookup().  Both this routine and Lookup() attempt\n    ** to find a page in the in-memory cache first.  If the page is not already\n    ** in memory, this routine goes to disk to read it in whereas Lookup()\n    ** just returns 0.  This routine acquires a read-lock the first time it\n    ** has to go to disk, and could also playback an old journal if necessary.\n    ** Since Lookup() never goes to disk, it never has to deal with locks\n    ** or journal files.\n    */\n\n    // Under C# from the header file\n    //#define sqlite3PagerGet(A,B,C) sqlite3PagerAcquire(A,B,C,0)\n\n    static int sqlite3PagerGet(\n    Pager pPager,       /* The pager open on the database file */\n    u32 pgno,          /* Page number to fetch */\n    ref DbPage ppPage   /* Write a pointer to the page here */\n    )\n    {\n      return sqlite3PagerAcquire( pPager, pgno, ref ppPage, 0 );\n    }\n\n    static int sqlite3PagerAcquire(\n    Pager pPager,      /* The pager open on the database file */\n    u32 pgno,          /* Page number to fetch */\n    ref DbPage ppPage, /* Write a pointer to the page here */\n    u8 noContent     /* Do not bother reading content from disk if true */\n    )\n    {\n      int rc;\n      PgHdr pPg = null;\n\n      Debug.Assert( assert_pager_state( pPager ) );\n      Debug.Assert( pPager.state > PAGER_UNLOCK );\n      if ( pgno == 0 )\n      {\n#if SQLITE_DEBUG\n        return SQLITE_CORRUPT_BKPT();\n#else\nreturn SQLITE_CORRUPT_BKPT;\n#endif\n      }\n\n  /* If the pager is in the error state, return an error immediately. \n  ** Otherwise, request the page from the PCache layer. */\n  if( pPager.errCode!=SQLITE_OK && pPager.errCode!=SQLITE_FULL ){\n    rc = pPager.errCode;\n  }else{\n    rc = sqlite3PcacheFetch(pPager.pPCache, pgno, 1,ref  ppPage);\n  }\n\n  if( rc!=SQLITE_OK ){\n    /* Either the call to sqlite3PcacheFetch() returned an error or the\n    ** pager was already in the error-state when this function was called.\n    ** Set pPg to 0 and jump to the exception handler.  */\n    pPg = null;\n    goto pager_acquire_err;\n  }\n  Debug.Assert( (ppPage).pgno==pgno );\n  Debug.Assert( (ppPage).pPager==pPager || (ppPage).pPager==null );\n\n  if ( ( ppPage ).pPager != null )\n  {\n    /* In this case the pcache already contains an initialized copy of\n    ** the page. Return without further ado.  */\n    Debug.Assert( pgno <= PAGER_MAX_PGNO && pgno != PAGER_MJ_PGNO( pPager ) );\n    PAGER_INCR( ref pPager.nHit );\n    return SQLITE_OK;\n\n  }\n  else\n  {\n    /* The pager cache has created a new page. Its content needs to \n    ** be initialized.  */\n    int nMax = 0;\n#if SQLITE_TEST\n    PAGER_INCR( ref pPager.nMiss );\n#endif\n    pPg = ppPage;\n    pPg.pPager = pPager;\n    pPg.pExtra = new MemPage();//memset(pPg.pExtra, 0, pPager.nExtra);\n\n    /* The maximum page number is 2^31. Return SQLITE_CORRUPT if a page\n    ** number greater than this, or the unused locking-page, is requested. */\n    if ( pgno > PAGER_MAX_PGNO || pgno == PAGER_MJ_PGNO( pPager ) )\n    {\n#if SQLITE_DEBUG\n      rc = SQLITE_CORRUPT_BKPT();\n#else\n      rc = SQLITE_CORRUPT_BKPT;\n#endif\n      goto pager_acquire_err;\n    }\n    rc = sqlite3PagerPagecount( pPager, ref nMax );\n    if ( rc != SQLITE_OK )\n    {\n      goto pager_acquire_err;\n    }\n\n    if ( nMax < (int)pgno ||\n#if SQLITE_OMIT_MEMORYDB\n1==MEMDB\n#else\n pPager.memDb != 0\n#endif\n || noContent != 0 )\n    {\n      if ( pgno > pPager.mxPgno )\n      {\n        rc = SQLITE_FULL;\n        goto pager_acquire_err;\n      }\n      if ( noContent != 0 )\n      {\n        /* Failure to set the bits in the InJournal bit-vectors is benign.\n        ** It merely means that we might do some extra work to journal a\n        ** page that does not need to be journaled.  Nevertheless, be sure\n        ** to test the case where a malloc error occurs while trying to set\n        ** a bit in a bit vector.\n        */\n        sqlite3BeginBenignMalloc();\n        if ( pgno <= pPager.dbOrigSize )\n        {\n#if !NDEBUG || SQLITE_COVERAGE_TEST\n          rc = sqlite3BitvecSet( pPager.pInJournal, pgno );          //TESTONLY( rc = ) sqlite3BitvecSet(pPager.pInJournal, pgno);\n#else\nsqlite3BitvecSet(pPager.pInJournal, pgno);\n#endif\n              testcase( rc == SQLITE_NOMEM );\n            }\n#if !NDEBUG || SQLITE_COVERAGE_TEST\n            rc = addToSavepointBitvecs( pPager, pgno ); //TESTONLY( rc = ) addToSavepointBitvecs(pPager, pgno);\n#else\naddToSavepointBitvecs(pPager, pgno);\n#endif\n\n            testcase( rc == SQLITE_NOMEM );\n            sqlite3EndBenignMalloc();\n          }\n          else\n          {\n            //memset(pPg->pData, 0, pPager.pageSize);\n            Array.Clear( pPg.pData, 0, pPager.pageSize );\n          }\n          IOTRACE( "ZERO %p %d\\n", pPager, pgno );\n        }\n        else\n        {\n          Debug.Assert( pPg.pPager == pPager );\n          rc = readDbPage( pPg );\n          if ( rc != SQLITE_OK )\n          {\ngoto pager_acquire_err;          }\n        }\n\n#if SQLITE_CHECK_PAGES\npPg.pageHash = pager_pagehash(pPg);\n#endif\n      }\n      return SQLITE_OK;\n\n      pager_acquire_err:\n      Debug.Assert( rc != SQLITE_OK );\n      if ( pPg!=null )\n      {\n        sqlite3PcacheDrop( pPg );\n      }\n      pagerUnlockIfUnused( pPager );\n\n      ppPage = null;\n      return rc;\n    }\n\n    /*\n    ** Acquire a page if it is already in the in-memory cache.  Do\n    ** not read the page from disk.  Return a pointer to the page,\n    ** or 0 if the page is not in cache. Also, return 0 if the\n    ** pager is in PAGER_UNLOCK state when this function is called,\n    ** or if the pager is in an error state other than SQLITE_FULL.\n    **\n    ** See also sqlite3PagerGet().  The difference between this routine\n    ** and sqlite3PagerGet() is that _get() will go to the disk and read\n    ** in the page if the page is not already in cache.  This routine\n    ** returns NULL if the page is not in cache or if a disk I/O error\n    ** has ever happened.\n    */\n    static DbPage sqlite3PagerLookup( Pager pPager, u32 pgno )\n    {\n      PgHdr pPg = null;\n\n      Debug.Assert( pPager != null );\n      Debug.Assert( pgno != 0 );\n      Debug.Assert( pPager.pPCache != null );\n      Debug.Assert( pPager.state > PAGER_UNLOCK );\n      sqlite3PcacheFetch( pPager.pPCache, pgno, 0, ref pPg );\n\n      return pPg;\n    }\n\n    /*\n    ** Release a page reference.\n    **\n    ** If the number of references to the page drop to zero, then the\n    ** page is added to the LRU list.  When all references to all pages\n    ** are released, a rollback occurs and the lock on the database is\n    ** removed.\n    */\n    static void sqlite3PagerUnref( DbPage pPg )\n    {\n      if ( pPg != null )\n      {\n        Pager pPager = pPg.pPager;\n        sqlite3PcacheRelease( pPg );\n        pagerUnlockIfUnused( pPager );\n      }\n    }\n\n    /*\n    ** If the main journal file has already been opened, ensure that the\n    ** sub-journal file is open too. If the main journal is not open,\n    ** this function is a no-op.\n    **\n    ** SQLITE_OK is returned if everything goes according to plan.\n    ** An SQLITE_IOERR_XXX error code is returned if a call to\n    ** sqlite3OsOpen() fails.\n    */\n    static int openSubJournal( Pager pPager )\n    {\n      int rc = SQLITE_OK;\n      if ( isOpen( pPager.jfd ) && !isOpen( pPager.sjfd ) )\n      {\n        if ( pPager.journalMode == PAGER_JOURNALMODE_MEMORY || pPager.subjInMemory != 0 )\n        {\n          sqlite3MemJournalOpen( pPager.sjfd );\n        }\n        else\n        {\n          rc = pagerOpentemp( pPager, ref pPager.sjfd, SQLITE_OPEN_SUBJOURNAL );\n        }\n      }\n      return rc;\n    }\n\n    /*\n    ** This function is called at the start of every write transaction.\n    ** There must already be a RESERVED or EXCLUSIVE lock on the database\n    ** file when this routine is called.\n    **\n    ** Open the journal file for pager pPager and write a journal header\n    ** to the start of it. If there are active savepoints, open the sub-journal\n    ** as well. This function is only used when the journal file is being\n    ** opened to write a rollback log for a transaction. It is not used\n    ** when opening a hot journal file to roll it back.\n    **\n    ** If the journal file is already open (as it may be in exclusive mode),\n    ** then this function just writes a journal header to the start of the\n    ** already open file.\n    **\n    ** Whether or not the journal file is opened by this function, the\n    ** Pager.pInJournal bitvec structure is allocated.\n    **\n    ** Return SQLITE_OK if everything is successful. Otherwise, return\n    ** SQLITE_NOMEM if the attempt to allocate Pager.pInJournal fails, or\n    ** an IO error code if opening or writing the journal file fails.\n    */\n    static int pager_open_journal( Pager pPager )\n    {\n      int rc = SQLITE_OK;                        /* Return code */\n      sqlite3_vfs pVfs = pPager.pVfs;            /* Local cache of vfs pointer */\n\n      Debug.Assert( pPager.state >= PAGER_RESERVED );\n      Debug.Assert( pPager.useJournal != 0 );\n      Debug.Assert( pPager.pInJournal == null );\n      Debug.Assert( pPager.journalMode != PAGER_JOURNALMODE_OFF );\n\n      /* If already in the error state, this function is a no-op.  But on\n      ** the other hand, this routine is never called if we are already in\n      ** an error state. */\n      if ( NEVER( pPager.errCode )!=0 ) return pPager.errCode;\n\n      /* TODO: Is it really possible to get here with dbSizeValid==0? If not,\n      ** the call to PagerPagecount() can be removed.\n      */\n      testcase( pPager.dbSizeValid == false );\n      int idummy = 0; sqlite3PagerPagecount( pPager, ref idummy );\n\n      pPager.pInJournal = sqlite3BitvecCreate( pPager.dbSize );// sqlite3MallocZero(pPager.dbSize / 8 + 1);\n      if ( pPager.pInJournal == null )\n      {\n        return SQLITE_NOMEM;\n      }\n\n      /* Open the journal file if it is not already open. */\n      if ( !isOpen( pPager.jfd ) )\n      {\n        if ( pPager.journalMode == PAGER_JOURNALMODE_MEMORY )\n        {\n          sqlite3MemJournalOpen( pPager.jfd );\n        }\n        else\n        {\n          int flags =                   /* VFS flags to open journal file */\n          SQLITE_OPEN_READWRITE | SQLITE_OPEN_CREATE |\n          ( pPager.tempFile ?\n          ( SQLITE_OPEN_DELETEONCLOSE | SQLITE_OPEN_TEMP_JOURNAL ) :\n          ( SQLITE_OPEN_MAIN_JOURNAL )\n          );\n#if SQLITE_ENABLE_ATOMIC_WRITE\nrc = sqlite3JournalOpen(\npVfs, pPager.zJournal, pPager.jfd, flags, jrnlBufferSize(pPager)\n);\n#else\n          int int0 = 0;\n          rc = sqlite3OsOpen( pVfs, pPager.zJournal, pPager.jfd, flags, ref int0 );\n#endif\n        }\n        Debug.Assert( rc != SQLITE_OK || isOpen( pPager.jfd ) );\n      }\n\n      /* Write the first journal header to the journal file and open\n      ** the sub-journal if necessary.\n      */\n      if ( rc == SQLITE_OK )\n      {\n        /* TODO: Check if all of these are really required. */\n        pPager.dbOrigSize = pPager.dbSize;\n        pPager.journalStarted = false;\n        pPager.needSync = false;\n        pPager.nRec = 0;\n        pPager.journalOff = 0;\n        pPager.setMaster = 0;\n        pPager.journalHdr = 0;\n        rc = writeJournalHdr( pPager );\n      }\n      if ( rc == SQLITE_OK && pPager.nSavepoint != 0 )\n      {\n        rc = openSubJournal( pPager );\n      }\n\n      if ( rc != SQLITE_OK )\n      {\n        sqlite3BitvecDestroy( ref pPager.pInJournal );\n        pPager.pInJournal = null;\n      }\n      return rc;\n    }\n\n    /*\n    ** Begin a write-transaction on the specified pager object. If a\n    ** write-transaction has already been opened, this function is a no-op.\n    **\n    ** If the exFlag argument is false, then acquire at least a RESERVED\n    ** lock on the database file. If exFlag is true, then acquire at least\n    ** an EXCLUSIVE lock. If such a lock is already held, no locking\n    ** functions need be called.\n    **\n    ** If this is not a temporary or in-memory file and, the journal file is\n    ** opened if it has not been already. For a temporary file, the opening\n    ** of the journal file is deferred until there is an actual need to\n    ** write to the journal. TODO: Why handle temporary files differently?\n    **\n    ** If the journal file is opened (or if it is already open), then a\n    ** journal-header is written to the start of it.\n    **\n    ** If the subjInMemory argument is non-zero, then any sub-journal opened\n    ** within this transaction will be opened as an in-memory file. This\n    ** has no effect if the sub-journal is already opened (as it may be when\n    ** running in exclusive mode) or if the transaction does not require a\n    ** sub-journal. If the subjInMemory argument is zero, then any required\n    ** sub-journal is implemented in-memory if pPager is an in-memory database,\n    ** or using a temporary file otherwise.\n    */\n    static int sqlite3PagerBegin( Pager pPager, bool exFlag, int subjInMemory )\n    {\n      int rc = SQLITE_OK;\n      Debug.Assert( pPager.state != PAGER_UNLOCK );\n      pPager.subjInMemory = (u8)subjInMemory;\n      if ( pPager.state == PAGER_SHARED )\n      {\n        Debug.Assert( pPager.pInJournal == null );\n#if SQLITE_OMIT_MEMORYDB\nDebug.Assert( 0==MEMDB && !pPager.tempFile );\n#endif\n        /* Obtain a RESERVED lock on the database file. If the exFlag parameter\n** is true, then immediately upgrade this to an EXCLUSIVE lock. The\n** busy-handler callback can be used when upgrading to the EXCLUSIVE\n** lock, but not when obtaining the RESERVED lock.\n*/\n        rc = sqlite3OsLock( pPager.fd, RESERVED_LOCK );\n        if ( rc == SQLITE_OK )\n        {\n          pPager.state = PAGER_RESERVED;\n          if ( exFlag )\n          {\n            rc = pager_wait_on_lock( pPager, EXCLUSIVE_LOCK );\n          }\n        }\n\n        /* If the required locks were successfully obtained, open the journal\n        ** file and write the first journal-header to it.\n        */\n        if ( rc == SQLITE_OK && pPager.journalMode != PAGER_JOURNALMODE_OFF )\n        {\n          rc = pager_open_journal( pPager );\n        }\n      }\n      else if ( isOpen( pPager.jfd ) && pPager.journalOff == 0 )\n      {\n        /* This happens when the pager was in exclusive-access mode the last\n        ** time a (read or write) transaction was successfully concluded\n        ** by this connection. Instead of deleting the journal file it was\n        ** kept open and either was truncated to 0 bytes or its header was\n        ** overwritten with zeros.\n        */\n        Debug.Assert( pPager.nRec == 0 );\n        Debug.Assert( pPager.dbOrigSize == 0 );\n        Debug.Assert( pPager.pInJournal == null );\n        rc = pager_open_journal( pPager );\n      }\n      PAGERTRACE( "TRANSACTION %d\\n", PAGERID( pPager ) );\n      Debug.Assert( !isOpen( pPager.jfd ) || pPager.journalOff > 0 || rc != SQLITE_OK );\n      if ( rc != SQLITE_OK )\n      {\n        Debug.Assert( !pPager.dbModified );\n        /* Ignore any IO error that occurs within pager_end_transaction(). The\n        ** purpose of this call is to reset the internal state of the pager\n        ** sub-system. It doesn\'t matter if the journal-file is not properly\n        ** finalized at this point (since it is not a valid journal file anyway).\n        */\n        pager_end_transaction( pPager, 0 );\n      }\n      return rc;\n    }\n\n    /*\n    ** Mark a single data page as writeable. The page is written into the\n    ** main journal or sub-journal as required. If the page is written into\n    ** one of the journals, the corresponding bit is set in the\n    ** Pager.pInJournal bitvec and the PagerSavepoint.pInSavepoint bitvecs\n    ** of any open savepoints as appropriate.\n    */\n    static int pager_write( PgHdr pPg )\n    {\n      byte[] pData = pPg.pData;\n      Pager pPager = pPg.pPager;\n      int rc = SQLITE_OK;\n\n      /* This routine is not called unless a transaction has already been\n      ** started.\n      */\n      Debug.Assert( pPager.state >= PAGER_RESERVED );\n\n      /* If an error has been previously detected, we should not be\n      ** calling this routine.  Repeat the error for robustness.\n      */\n      if (NEVER(pPager.errCode) != 0) return pPager.errCode;\n\n      /* Higher-level routines never call this function if database is not\n      ** writable.  But check anyway, just for robustness. */\n      if ( NEVER( pPager.readOnly ) ) return SQLITE_PERM;\n      Debug.Assert( 0 == pPager.setMaster );\n\n#if SQLITE_CHECK_PAGES\nCHECK_PAGE(pPg);\n#endif\n      /* Mark the page as dirty.  If the page has already been written\n** to the journal then we can return right away.\n*/\n      sqlite3PcacheMakeDirty( pPg );\n      if ( pageInJournal( pPg ) && !subjRequiresPage( pPg ) )\n      {\n        pPager.dbModified = true;\n      }\n      else\n      {\n\n        /* If we get this far, it means that the page needs to be\n        ** written to the transaction journal or the ckeckpoint journal\n        ** or both.\n        **\n        ** Higher level routines should have already started a transaction,\n        ** which means they have acquired the necessary locks and opened\n        ** a rollback journal.  Double-check to makes sure this is the case.\n        */\n        rc = sqlite3PagerBegin( pPager, false, pPager.subjInMemory );\n        if (NEVER( rc != SQLITE_OK ))\n        {\n          return rc;\n        }\n        if ( !isOpen( pPager.jfd ) && pPager.journalMode != PAGER_JOURNALMODE_OFF )\n        {\n          Debug.Assert( pPager.useJournal != 0 );\n          rc = pager_open_journal( pPager );\n          if ( rc != SQLITE_OK ) return rc;\n        }\n        pPager.dbModified = true;\n\n        /* The transaction journal now exists and we have a RESERVED or an\n        ** EXCLUSIVE lock on the main database file.  Write the current page to\n        ** the transaction journal if it is not there already.\n        */\n        if ( !pageInJournal( pPg ) && isOpen( pPager.jfd ) )\n        {\n          if ( pPg.pgno <= pPager.dbOrigSize )\n          {\n            u32 cksum;\n            byte[] pData2 = null;\n\n            /* We should never write to the journal file the page that\n            ** contains the database locks.  The following Debug.Assert verifies\n            ** that we do not. */\n            Debug.Assert( pPg.pgno != ( ( PENDING_BYTE / ( pPager.pageSize ) ) + 1 ) );//PAGER_MJ_PGNO(pPager) );\n            CODEC2( pPager, pData, pPg.pgno, 7, SQLITE_NOMEM, ref pData2 );//        CODEC2(pPager, pData, pPg->pgno, 7, return SQLITE_NOMEM, pData2);\n            cksum = pager_cksum( pPager, pData2 );\n            rc = write32bits( pPager.jfd, pPager.journalOff, (u32)pPg.pgno );\n            if ( rc == SQLITE_OK )\n            {\n              rc = sqlite3OsWrite( pPager.jfd, pData2, pPager.pageSize,\n              pPager.journalOff + 4 );\n              pPager.journalOff += pPager.pageSize + 4;\n            }\n            if ( rc == SQLITE_OK )\n            {\n              rc = write32bits( pPager.jfd, pPager.journalOff, (u32)cksum );\n              pPager.journalOff += 4;\n            }\n            IOTRACE( "JOUT %p %d %lld %d\\n", pPager, pPg.pgno,\n            pPager.journalOff, pPager.pageSize );\n#if SQLITE_TEST\n            int iValue;\n            iValue = sqlite3_pager_writej_count.iValue;\n            PAGER_INCR( ref  iValue );\n            sqlite3_pager_writej_count.iValue = iValue;\n#endif\n            PAGERTRACE( "JOURNAL %d page %d needSync=%d hash(%08x)\\n",\n            PAGERID( pPager ), pPg.pgno,\n            ( ( pPg.flags & PGHDR_NEED_SYNC ) != 0 ? 1 : 0 ), pager_pagehash( pPg ) );\n            /* Even if an IO or diskfull error occurred while journalling the\n            ** page in the block above, set the need-sync flag for the page.\n            ** Otherwise, when the transaction is rolled back, the logic in\n            ** playback_one_page() will think that the page needs to be restored\n            ** in the database file. And if an IO error occurs while doing so,\n            ** then corruption may follow.\n            */\n            if ( !pPager.noSync )\n            {\n              pPg.flags |= PGHDR_NEED_SYNC;\n              pPager.needSync = true;\n            }\n\n            /* An error has occurred writing to the journal file. The\n            ** transaction will be rolled back by the layer above.\n            */\n            if ( rc != SQLITE_OK )\n            {\n              return rc;\n            }\n\n            pPager.nRec++;\n            Debug.Assert( pPager.pInJournal != null );\n            rc = sqlite3BitvecSet( pPager.pInJournal, pPg.pgno );\n            testcase( rc == SQLITE_NOMEM );\n            Debug.Assert( rc == SQLITE_OK || rc == SQLITE_NOMEM );\n            rc |= addToSavepointBitvecs( pPager, pPg.pgno );\n            if ( rc != SQLITE_OK )\n            {\n              Debug.Assert( rc == SQLITE_NOMEM );\n              return rc;\n            }\n          }\n          else\n          {\n            if ( !pPager.journalStarted && !pPager.noSync )\n            {\n              pPg.flags |= PGHDR_NEED_SYNC;\n              pPager.needSync = true;\n            }\n            PAGERTRACE( "APPEND %d page %d needSync=%d\\n",\n            PAGERID( pPager ), pPg.pgno,\n            ( ( pPg.flags & PGHDR_NEED_SYNC ) != 0 ? 1 : 0 ) );\n          }\n        }\n\n        /* If the statement journal is open and the page is not in it,\n        ** then write the current page to the statement journal.  Note that\n        ** the statement journal format differs from the standard journal format\n        ** in that it omits the checksums and the header.\n        */\n        if ( subjRequiresPage( pPg ) )\n        {\n          rc = subjournalPage( pPg );\n        }\n      }\n\n      /* Update the database size and return.\n      */\n      Debug.Assert( pPager.state >= PAGER_SHARED );\n      if ( pPager.dbSize < (int)pPg.pgno )\n      {\n        pPager.dbSize = pPg.pgno;\n      }\n      return rc;\n    }\n\n    /*\n    ** Mark a data page as writeable. This routine must be called before\n    ** making changes to a page. The caller must check the return value\n    ** of this function and be careful not to change any page data unless\n    ** this routine returns SQLITE_OK.\n    **\n    ** The difference between this function and pager_write() is that this\n    ** function also deals with the special case where 2 or more pages\n    ** fit on a single disk sector. In this case all co-resident pages\n    ** must have been written to the journal file before returning.\n    **\n    ** If an error occurs, SQLITE_NOMEM or an IO error code is returned\n    ** as appropriate. Otherwise, SQLITE_OK.\n    */\n    static int sqlite3PagerWrite( DbPage pDbPage )\n    {\n      int rc = SQLITE_OK;\n\n      PgHdr pPg = pDbPage;\n      Pager pPager = pPg.pPager;\n      u32 nPagePerSector = (u32)( pPager.sectorSize / pPager.pageSize );\n\n      if ( nPagePerSector > 1 )\n      {\n        int nPageCount = 0;      /* Total number of pages in database file */\n        u32 pg1;                 /* First page of the sector pPg is located on. */\n        u32 nPage;               /* Number of pages starting at pg1 to journal */\n        int ii;                  /* Loop counter */\n        bool needSync = false;   /* True if any page has PGHDR_NEED_SYNC */\n\n        /* Set the doNotSync flag to 1. This is because we cannot allow a journal\n        ** header to be written between the pages journaled by this function.\n        */\n        Debug.Assert(\n#if SQLITE_OMIT_MEMORYDB\n0==MEMDB\n#else\n 0 == pPager.memDb\n#endif\n );\n        Debug.Assert( !pPager.doNotSync );\n        pPager.doNotSync = true;\n\n        /* This trick assumes that both the page-size and sector-size are\n        ** an integer power of 2. It sets variable pg1 to the identifier\n        ** of the first page of the sector pPg is located on.\n        */\n        pg1 = (u32)( ( pPg.pgno - 1 ) & ~( nPagePerSector - 1 ) ) + 1;\n\n        sqlite3PagerPagecount( pPager, ref nPageCount );\n        if ( pPg.pgno > nPageCount )\n        {\n          nPage = (u32)( pPg.pgno - pg1 ) + 1;\n        }\n        else if ( ( pg1 + nPagePerSector - 1 ) > nPageCount )\n        {\n          nPage = (u32)( nPageCount + 1 - pg1 );\n        }\n        else\n        {\n          nPage = nPagePerSector;\n        }\n        Debug.Assert( nPage > 0 );\n        Debug.Assert( pg1 <= pPg.pgno );\n        Debug.Assert( ( pg1 + nPage ) > pPg.pgno );\n\n        for ( ii = 0 ; ii < nPage && rc == SQLITE_OK ; ii++ )\n        {\n          u32 pg = (u32)( pg1 + ii );\n          PgHdr pPage = new PgHdr();\n          if ( pg == pPg.pgno || sqlite3BitvecTest( pPager.pInJournal, pg ) == 0 )\n          {\n            if ( pg != ( ( PENDING_BYTE / ( pPager.pageSize ) ) + 1 ) ) //PAGER_MJ_PGNO(pPager))\n            {\n              rc = sqlite3PagerGet( pPager, pg, ref pPage );\n              if ( rc == SQLITE_OK )\n              {\n                rc = pager_write( pPage );\n                if ( ( pPage.flags & PGHDR_NEED_SYNC ) != 0 )\n                {\n                  needSync = true;\n                  Debug.Assert( pPager.needSync );\n\n                }\n                sqlite3PagerUnref( pPage );\n              }\n            }\n          }\n          else if ( ( pPage = pager_lookup( pPager, pg ) ) != null )\n          {\n            if ( ( pPage.flags & PGHDR_NEED_SYNC ) != 0 )\n            {\n              needSync = true;\n            }\n            sqlite3PagerUnref( pPage );\n          }\n        }\n\n        /* If the PGHDR_NEED_SYNC flag is set for any of the nPage pages\n        ** starting at pg1, then it needs to be set for all of them. Because\n        ** writing to any of these nPage pages may damage the others, the\n        ** journal file must contain sync()ed copies of all of them\n        ** before any of them can be written out to the database file.\n        */\n        if ( rc == SQLITE_OK && needSync )\n        {\n          Debug.Assert(\n#if SQLITE_OMIT_MEMORYDB\n0==MEMDB\n#else\n 0 == pPager.memDb\n#endif\n && pPager.noSync == false );\n          for ( ii = 0 ; ii < nPage ; ii++ )\n          {\n            PgHdr pPage = pager_lookup( pPager, (u32)( pg1 + ii ) );\n            if ( pPage != null )\n            {\n              pPage.flags |= PGHDR_NEED_SYNC;\n              sqlite3PagerUnref( pPage );\n            }\n          }\n          Debug.Assert( pPager.needSync );\n        }\n\n        Debug.Assert( pPager.doNotSync );\n        pPager.doNotSync = false;\n      }\n      else\n      {\n        rc = pager_write( pDbPage );\n      }\n      return rc;\n    }\n\n    /*\n    ** Return TRUE if the page given in the argument was previously passed\n    ** to sqlite3PagerWrite().  In other words, return TRUE if it is ok\n    ** to change the content of the page.\n    */\n#if !NDEBUG\n    static bool sqlite3PagerIswriteable( DbPage pPg )\n    {\n      return ( pPg.flags & PGHDR_DIRTY ) != 0;\n    }\n#else\nstatic bool sqlite3PagerIswriteable( DbPage pPg ) { return true; }\n#endif\n\n    /*\n** A call to this routine tells the pager that it is not necessary to\n** write the information on page pPg back to the disk, even though\n** that page might be marked as dirty.  This happens, for example, when\n** the page has been added as a leaf of the freelist and so its\n** content no longer matters.\n**\n** The overlying software layer calls this routine when all of the data\n** on the given page is unused. The pager marks the page as clean so\n** that it does not get written to disk.\n**\n** Tests show that this optimization can quadruple the speed of large\n** DELETE operations.\n*/\n    static void sqlite3PagerDontWrite( PgHdr pPg )\n    {\n      Pager pPager = pPg.pPager;\n\n      if ( ( pPg.flags & PGHDR_DIRTY ) != 0 && pPager.nSavepoint == 0 )\n      {\n        PAGERTRACE( "DONT_WRITE page %d of %d\\n", pPg.pgno, PAGERID( pPager ) );\n        IOTRACE( "CLEAN %p %d\\n", pPager, pPg.pgno );\n        pPg.flags |= PGHDR_DONT_WRITE;\n#if SQLITE_CHECK_PAGES\npPg.pageHash = pager_pagehash(pPg);\n#endif\n      }\n    }\n\n    /*\n    ** This routine is called to increment the value of the database file\n    ** change-counter, stored as a 4-byte big-endian integer starting at\n    ** byte offset 24 of the pager file.\n    **\n    ** If the isDirectMode flag is zero, then this is done by calling\n    ** sqlite3PagerWrite() on page 1, then modifying the contents of the\n    ** page data. In this case the file will be updated when the current\n    ** transaction is committed.\n    **\n    ** The isDirectMode flag may only be non-zero if the library was compiled\n    ** with the SQLITE_ENABLE_ATOMIC_WRITE macro defined. In this case,\n    ** if isDirect is non-zero, then the database file is updated directly\n    ** by writing an updated version of page 1 using a call to the\n    ** sqlite3OsWrite() function.\n    */\n    static int pager_incr_changecounter( Pager pPager, bool isDirectMode )\n    {\n      int rc = SQLITE_OK;\n\n      /* Declare and initialize constant integer \'isDirect\'. If the\n      ** atomic-write optimization is enabled in this build, then isDirect\n      ** is initialized to the value passed as the isDirectMode parameter\n      ** to this function. Otherwise, it is always set to zero.\n      **\n      ** The idea is that if the atomic-write optimization is not\n      ** enabled at compile time, the compiler can omit the tests of\n      ** \'isDirect\' below, as well as the block enclosed in the\n      ** "if( isDirect )" condition.\n      */\n#if !SQLITE_ENABLE_ATOMIC_WRITE\n//# define DIRECT_MODE 0\n      bool DIRECT_MODE = false;\n      Debug.Assert( isDirectMode == false );\n      UNUSED_PARAMETER( isDirectMode );\n#else\n//# define DIRECT_MODE isDirectMode\nint DIRECT_MODE = isDirectMode;\n#endif\n\n      Debug.Assert( pPager.state >= PAGER_RESERVED );\n      if ( !pPager.changeCountDone && ALWAYS(pPager.dbSize > 0 ))\n      {\n        PgHdr pPgHdr = null;            /* Reference to page 1 */\n        u32 change_counter;           /* Initial value of change-counter field */\n\n        Debug.Assert( !pPager.tempFile && isOpen( pPager.fd ) );\n\n        /* Open page 1 of the file for writing. */\n        rc = sqlite3PagerGet( pPager, 1, ref pPgHdr );\n        Debug.Assert( pPgHdr == null || rc == SQLITE_OK );\n\n        /* If page one was fetched successfully, and this function is not\n        ** operating in direct-mode, make page 1 writable.  When not in \n        ** direct mode, page 1 is always held in cache and hence the PagerGet()\n        ** above is always successful - hence the ALWAYS on rc==SQLITE_OK.\n        */\n        if ( !DIRECT_MODE && ALWAYS( rc == SQLITE_OK ) )\n        {\n          rc = sqlite3PagerWrite( pPgHdr );\n        }\n\n        if ( rc == SQLITE_OK )\n        {\n          /* Increment the value just read and write it back to byte 24. */\n          change_counter = sqlite3Get4byte( pPager.dbFileVers );\n          change_counter++;\n          put32bits( pPgHdr.pData, 24, change_counter );\n\n          /* If running in direct mode, write the contents of page 1 to the file. */\n          if ( DIRECT_MODE  )\n          {\n            u8[] zBuf = pPgHdr.pData;\n            Debug.Assert( pPager.dbFileSize > 0 );\n            rc = sqlite3OsWrite( pPager.fd, zBuf, pPager.pageSize, 0 );\n\n            if ( rc == SQLITE_OK )\n            {\n              pPager.changeCountDone = true;\n            }\n          }\n          else\n          {\n            pPager.changeCountDone = true;\n          }\n        }\n\n        /* Release the page reference. */\n        sqlite3PagerUnref( pPgHdr );\n      }\n      return rc;\n    }\n\n    /*\n    ** Sync the pager file to disk. This is a no-op for in-memory files\n    ** or pages with the Pager.noSync flag set.\n    **\n    ** If successful, or called on a pager for which it is a no-op, this\n    ** function returns SQLITE_OK. Otherwise, an IO error code is returned.\n    */\n    static int sqlite3PagerSync( Pager pPager )\n    {\n      int rc;                             /* Return code */\n      Debug.Assert( \n#if SQLITE_OMIT_MEMORYDB\n0 == MEMDB\n#else\n0 == pPager.memDb \n#endif\n);\n      if ( pPager.noSync )\n      {\n        rc = SQLITE_OK;\n      }\n      else\n      {\n        rc = sqlite3OsSync( pPager.fd, pPager.sync_flags );\n      }\n      return rc;\n    }\n\n    /*\n    ** Sync the database file for the pager pPager. zMaster points to the name\n    ** of a master journal file that should be written into the individual\n    ** journal file. zMaster may be NULL, which is interpreted as no master\n    ** journal (a single database transaction).\n    **\n    ** This routine ensures that:\n    **\n    **   * The database file change-counter is updated,\n    **   * the journal is synced (unless the atomic-write optimization is used),\n    **   * all dirty pages are written to the database file,\n    **   * the database file is truncated (if required), and\n    **   * the database file synced.\n    **\n    ** The only thing that remains to commit the transaction is to finalize\n    ** (delete, truncate or zero the first part of) the journal file (or\n    ** delete the master journal file if specified).\n    **\n    ** Note that if zMaster==NULL, this does not overwrite a previous value\n    ** passed to an sqlite3PagerCommitPhaseOne() call.\n    **\n    ** If the final parameter - noSync - is true, then the database file itself\n    ** is not synced. The caller must call sqlite3PagerSync() directly to\n    ** sync the database file before calling CommitPhaseTwo() to delete the\n    ** journal file in this case.\n    */\n    static int sqlite3PagerCommitPhaseOne(\n    Pager pPager,         /* Pager object */\n    string zMaster,       /* If not NULL, the master journal name */\n    bool noSync           /* True to omit the xSync on the db file */\n    )\n    {\n      int rc = SQLITE_OK;             /* Return code */\n\n      /* The dbOrigSize is never set if journal_mode=OFF */\n      Debug.Assert( pPager.journalMode != PAGER_JOURNALMODE_OFF || pPager.dbOrigSize == 0 );\n\n      /* If a prior error occurred, this routine should not be called.  ROLLBACK\n      ** is the appropriate response to an error, not COMMIT.  Guard against\n      ** coding errors by repeating the prior error. */\n      if (NEVER(pPager.errCode) != 0) return pPager.errCode;\n\n      PAGERTRACE( "DATABASE SYNC: File=%s zMaster=%s nSize=%d\\n",\n      pPager.zFilename, zMaster, pPager.dbSize );\n\n      if ( \n#if SQLITE_OMIT_MEMORYDB\n 0 != MEMDB\n#else\n 0 != pPager.memDb\n#endif\n && pPager.dbModified )\n      {\n        /* If this is an in-memory db, or no pages have been written to, or this\n        ** function has already been called, it is mostly a no-op.  However, any\n        ** backup in progress needs to be restarted.\n        */\n        sqlite3BackupRestart( pPager.pBackup );\n      }\n      else if ( pPager.state != PAGER_SYNCED && pPager.dbModified )\n      {\n\n        /* The following block updates the change-counter. Exactly how it\n        ** does this depends on whether or not the atomic-update optimization\n        ** was enabled at compile time, and if this transaction meets the\n        ** runtime criteria to use the operation:\n        **\n        **    * The file-system supports the atomic-write property for\n        **      blocks of size page-size, and\n        **    * This commit is not part of a multi-file transaction, and\n        **    * Exactly one page has been modified and store in the journal file.\n        **\n        ** If the optimization was not enabled at compile time, then the\n        ** pager_incr_changecounter() function is called to update the change\n        ** counter in \'indirect-mode\'. If the optimization is compiled in but\n        ** is not applicable to this transaction, call sqlite3JournalCreate()\n        ** to make sure the journal file has actually been created, then call\n        ** pager_incr_changecounter() to update the change-counter in indirect\n        ** mode.\n        **\n        ** Otherwise, if the optimization is both enabled and applicable,\n        ** then call pager_incr_changecounter() to update the change-counter\n        ** in \'direct\' mode. In this case the journal file will never be\n        ** created for this transaction.\n        */\n#if SQLITE_ENABLE_ATOMIC_WRITE\nPgHdr *pPg;\nDebug.Assert( isOpen(pPager.jfd) || pPager.journalMode==PAGER_JOURNALMODE_OFF );\nif( !zMaster && isOpen(pPager.jfd)\n&& pPager.journalOff==jrnlBufferSize(pPager)\n&& pPager.dbSize>=pPager.dbFileSize\n&& (0==(pPg = sqlite3PcacheDirtyList(pPager.pPCache)) || 0==pPg.pDirty)\n){\n/* Update the db file change counter via the direct-write method. The\n** following call will modify the in-memory representation of page 1\n** to include the updated change counter and then write page 1\n** directly to the database file. Because of the atomic-write\n** property of the host file-system, this is safe.\n*/\nrc = pager_incr_changecounter(pPager, 1);\n}else{\nrc = sqlite3JournalCreate(pPager.jfd);\nif( rc==SQLITE_OK ){\nrc = pager_incr_changecounter(pPager, 0);\n}\n}\n#else\n        rc = pager_incr_changecounter( pPager, false );\n#endif\n        if ( rc != SQLITE_OK ) goto commit_phase_one_exit;\n\n        /* If this transaction has made the database smaller, then all pages\n        ** being discarded by the truncation must be written to the journal\n        ** file. This can only happen in auto-vacuum mode.\n        **\n        ** Before reading the pages with page numbers larger than the\n        ** current value of Pager.dbSize, set dbSize back to the value\n        ** that it took at the start of the transaction. Otherwise, the\n        ** calls to sqlite3PagerGet() return zeroed pages instead of\n        ** reading data from the database file.\n        **\n        ** When journal_mode==OFF the dbOrigSize is always zero, so this\n        ** block never runs if journal_mode=OFF.\n        */\n#if !SQLITE_OMIT_AUTOVACUUM\n        if ( pPager.dbSize < pPager.dbOrigSize\n        && ALWAYS(pPager.journalMode != PAGER_JOURNALMODE_OFF)\n        )\n        {\n          Pgno i;                                   /* Iterator variable */\n          Pgno iSkip = PAGER_MJ_PGNO( pPager ); /* Pending lock page */\n          Pgno dbSize = pPager.dbSize;       /* Database image size */\n          pPager.dbSize = pPager.dbOrigSize;\n          for ( i = dbSize + 1 ; i <= pPager.dbOrigSize ; i++ )\n          {\n            if ( 0 == sqlite3BitvecTest( pPager.pInJournal, i ) && i != iSkip )\n            {\n              PgHdr pPage = null;             /* Page to journal */\n              rc = sqlite3PagerGet( pPager, i, ref pPage );\n              if ( rc != SQLITE_OK ) goto commit_phase_one_exit;\n              rc = sqlite3PagerWrite( pPage );\n              sqlite3PagerUnref( pPage );\n              if ( rc != SQLITE_OK ) goto commit_phase_one_exit;\n            }\n          }\n          pPager.dbSize = dbSize;\n        }\n#endif\n\n        /* Write the master journal name into the journal file. If a master\n** journal file name has already been written to the journal file,\n** or if zMaster is NULL (no master journal), then this call is a no-op.\n*/\n        rc = writeMasterJournal( pPager, zMaster );\n        if ( rc != SQLITE_OK ) goto commit_phase_one_exit;\n\n        /* Sync the journal file. If the atomic-update optimization is being\n        ** used, this call will not create the journal file or perform any\n        ** real IO.\n        */\n        rc = syncJournal( pPager );\n        if ( rc != SQLITE_OK ) goto commit_phase_one_exit;\n\n        /* Write all dirty pages to the database file. */\n        rc = pager_write_pagelist( sqlite3PcacheDirtyList( pPager.pPCache ) );\n        if ( rc != SQLITE_OK )\n        {\n          Debug.Assert( rc != SQLITE_IOERR_BLOCKED );\n          goto commit_phase_one_exit;\n        }\n        sqlite3PcacheCleanAll( pPager.pPCache );\n\n        /* If the file on disk is not the same size as the database image,\n        ** then use pager_truncate to grow or shrink the file here.\n        */\n        if ( pPager.dbSize != pPager.dbFileSize )\n        {\n          Pgno nNew = (Pgno)( pPager.dbSize - ( pPager.dbSize == PAGER_MJ_PGNO( pPager ) ? 1 : 0 ) );\n          Debug.Assert( pPager.state >= PAGER_EXCLUSIVE );\n          rc = pager_truncate( pPager, nNew );\n          if ( rc != SQLITE_OK ) goto commit_phase_one_exit;\n        }\n\n        /* Finally, sync the database file. */\n        if ( !pPager.noSync && !noSync )\n        {\n          rc = sqlite3OsSync( pPager.fd, pPager.sync_flags );\n        }\n        IOTRACE( "DBSYNC %p\\n", pPager );\n        pPager.state = PAGER_SYNCED;\n      }\n\ncommit_phase_one_exit:\n      return rc;\n    }\n\n\n    /*\n    ** When this function is called, the database file has been completely\n    ** updated to reflect the changes made by the current transaction and\n    ** synced to disk. The journal file still exists in the file-system\n    ** though, and if a failure occurs at this point it will eventually\n    ** be used as a hot-journal and the current transaction rolled back.\n    **\n    ** This function finalizes the journal file, either by deleting,\n    ** truncating or partially zeroing it, so that it cannot be used\n    ** for hot-journal rollback. Once this is done the transaction is\n    ** irrevocably committed.\n    **\n    ** If an error occurs, an IO error code is returned and the pager\n    ** moves into the error state. Otherwise, SQLITE_OK is returned.\n    */\n    static int sqlite3PagerCommitPhaseTwo( Pager pPager )\n    {\n      int rc = SQLITE_OK;                 /* Return code */\n\n      /* This routine should not be called if a prior error has occurred.\n      ** But if (due to a coding error elsewhere in the system) it does get\n      ** called, just return the same error code without doing anything. */\n      if (NEVER(pPager.errCode) != 0) return pPager.errCode;\n\n      /* This function should not be called if the pager is not in at least\n      ** PAGER_RESERVED state. And indeed SQLite never does this. But it is\n      ** nice to have this defensive test here anyway.\n      */\n      if ( NEVER( pPager.state < PAGER_RESERVED ) ) return SQLITE_ERROR;\n\n      /* An optimization. If the database was not actually modified during\n      ** this transaction, the pager is running in exclusive-mode and is\n      ** using persistent journals, then this function is a no-op.\n      **\n      ** The start of the journal file currently contains a single journal\n      ** header with the nRec field set to 0. If such a journal is used as\n      ** a hot-journal during hot-journal rollback, 0 changes will be made\n      ** to the database file. So there is no need to zero the journal\n      ** header. Since the pager is in exclusive mode, there is no need\n      ** to drop any locks either.\n      */\n      if ( pPager.dbModified == false && pPager.exclusiveMode\n      && pPager.journalMode == PAGER_JOURNALMODE_PERSIST\n      )\n      {\n        Debug.Assert( pPager.journalOff == JOURNAL_HDR_SZ( pPager ) );\n        return SQLITE_OK;\n      }\n      PAGERTRACE( "COMMIT %d\\n", PAGERID( pPager ) );\n      Debug.Assert( pPager.state == PAGER_SYNCED ||\n#if SQLITE_OMIT_MEMORYDB\n 1 == MEMDB\n#else\n 1 == pPager.memDb\n#endif\n || !pPager.dbModified );\n      rc = pager_end_transaction( pPager, pPager.setMaster );\n      return pager_error( pPager, rc );\n    }\n\n    /*\n    ** Rollback all changes. The database falls back to PAGER_SHARED mode.\n    **\n    ** This function performs two tasks:\n    **\n    **   1) It rolls back the journal file, restoring all database file and\n    **      in-memory cache pages to the state they were in when the transaction\n    **      was opened, and\n    **   2) It finalizes the journal file, so that it is not used for hot\n    **      rollback at any point in the future.\n    **\n    ** subject to the following qualifications:\n    **\n    ** * If the journal file is not yet open when this function is called,\n    **   then only (2) is performed. In this case there is no journal file\n    **   to roll back.\n    **\n    ** * If in an error state other than SQLITE_FULL, then task (1) is\n    **   performed. If successful, task (2). Regardless of the outcome\n    **   of either, the error state error code is returned to the caller\n    **   (i.e. either SQLITE_IOERR or SQLITE_CORRUPT).\n    **\n    ** * If the pager is in PAGER_RESERVED state, then attempt (1). Whether\n    **   or not (1) is succussful, also attempt (2). If successful, return\n    **   SQLITE_OK. Otherwise, enter the error state and return the first\n    **   error code encountered.\n    **\n    **   In this case there is no chance that the database was written to.\n    **   So is safe to finalize the journal file even if the playback\n    **   (operation 1) failed. However the pager must enter the error state\n    **   as the contents of the in-memory cache are now suspect.\n    **\n    ** * Finally, if in PAGER_EXCLUSIVE state, then attempt (1). Only\n    **   attempt (2) if (1) is successful. Return SQLITE_OK if successful,\n    **   otherwise enter the error state and return the error code from the\n    **   failing operation.\n    **\n    **   In this case the database file may have been written to. So if the\n    **   playback operation did not succeed it would not be safe to finalize\n    **   the journal file. It needs to be left in the file-system so that\n    **   some other process can use it to restore the database state (by\n    **   hot-journal rollback).\n    */\n    static int sqlite3PagerRollback( Pager pPager )\n    {\n      int rc = SQLITE_OK;                  /* Return code */\n      PAGERTRACE( "ROLLBACK %d\\n", PAGERID( pPager ) );\n      if ( !pPager.dbModified || !isOpen( pPager.jfd ) )\n      {\n        rc = pager_end_transaction( pPager, pPager.setMaster );\n      }\n      else if ( pPager.errCode != 0 && pPager.errCode != SQLITE_FULL )\n      {\n        if ( pPager.state >= PAGER_EXCLUSIVE )\n        {\n          pager_playback( pPager, 0 );\n        }\n        rc = pPager.errCode;\n      }\n      else\n      {\n        if ( pPager.state == PAGER_RESERVED )\n        {\n          int rc2;\n          rc = pager_playback( pPager, 0 );\n          rc2 = pager_end_transaction( pPager, pPager.setMaster );\n          if ( rc == SQLITE_OK )\n          {\n            rc = rc2;\n          }\n        }\n        else\n        {\n          rc = pager_playback( pPager, 0 );\n        }\n\n        if (\n#if SQLITE_OMIT_MEMORYDB\n0==MEMDB\n#else\n 0 == pPager.memDb\n#endif\n )\n        {\n          pPager.dbSizeValid = false;\n        }\n        /* If an error occurs during a ROLLBACK, we can no longer trust the pager\n        ** cache. So call pager_error() on the way out to make any error\n        ** persistent.\n        */\n        rc = pager_error( pPager, rc );\n      }\n      return rc;\n    }\n\n    /*\n    ** Return TRUE if the database file is opened read-only.  Return FALSE\n    ** if the database is (in theory) writable.\n    */\n    static bool sqlite3PagerIsreadonly( Pager pPager )\n    {\n      return pPager.readOnly;\n    }\n\n    /*\n    ** Return the number of references to the pager.\n    */\n    static int sqlite3PagerRefcount( Pager pPager )\n    {\n      return sqlite3PcacheRefCount( pPager.pPCache );\n    }\n\n    /*\n    ** Return the number of references to the specified page.\n    */\n    static int sqlite3PagerPageRefcount( DbPage pPage )\n    {\n      return sqlite3PcachePageRefcount( pPage );\n    }\n\n\n#if SQLITE_TEST\n    /*\n** This routine is used for testing and analysis only.\n*/\n    static int[] sqlite3PagerStats( Pager pPager )\n    {\n      int[] a = new int[11];\n      a[0] = sqlite3PcacheRefCount( pPager.pPCache );\n      a[1] = sqlite3PcachePagecount( pPager.pPCache );\n      a[2] = sqlite3PcacheGetCachesize( pPager.pPCache );\n      a[3] = pPager.dbSizeValid ? (int)pPager.dbSize : -1;\n      a[4] = pPager.state;\n      a[5] = pPager.errCode;\n      a[6] = pPager.nHit;\n      a[7] = pPager.nMiss;\n      a[8] = 0;  /* Used to be pPager.nOvfl */\n      a[9] = pPager.nRead;\n      a[10] = pPager.nWrite;\n      return a;\n    }\n#endif\n\n    /*\n** Return true if this is an in-memory pager.\n*/\n    static bool sqlite3PagerIsMemdb( Pager pPager )\n    {\n#if SQLITE_OMIT_MEMORYDB\n      return MEMDB != 0;\n#else\n      return pPager.memDb != 0;\n#endif\n    }\n\n    /*\n    ** Check that there are at least nSavepoint savepoints open. If there are\n    ** currently less than nSavepoints open, then open one or more savepoints\n    ** to make up the difference. If the number of savepoints is already\n    ** equal to nSavepoint, then this function is a no-op.\n    **\n    ** If a memory allocation fails, SQLITE_NOMEM is returned. If an error\n    ** occurs while opening the sub-journal file, then an IO error code is\n    ** returned. Otherwise, SQLITE_OK.\n    */\n    static int sqlite3PagerOpenSavepoint( Pager pPager, int nSavepoint )\n    {\n      int rc = SQLITE_OK;                      /* Return code */\n      int nCurrent = pPager.nSavepoint;        /* Current number of savepoints */\n\n      if ( nSavepoint > nCurrent && pPager.useJournal != 0 )\n      {\n        int ii;                 /* Iterator variable */\n        PagerSavepoint[] aNew;  /* New Pager.aSavepoint array */\n\n        /* Either there is no active journal or the sub-journal is open or\n        ** the journal is always stored in memory */\n        Debug.Assert( pPager.nSavepoint == 0 || isOpen( pPager.sjfd ) ||\n        pPager.journalMode == PAGER_JOURNALMODE_MEMORY );\n\n        /* Grow the Pager.aSavepoint array using realloc(). Return SQLITE_NOMEM\n        ** if the allocation fails. Otherwise, zero the new portion in case a\n        ** malloc failure occurs while populating it in the for(...) loop below.\n        */\n        //aNew = (PagerSavepoint *)sqlite3Realloc(\n        //    pPager->aSavepoint, sizeof(PagerSavepoint)*nSavepoint\n        //);\n        Array.Resize( ref pPager.aSavepoint, nSavepoint );\n        aNew = pPager.aSavepoint;\n        //if( null==aNew ){\n        //  return SQLITE_NOMEM;\n        //}\n        // memset(&aNew[nCurrent], 0, (nSavepoint-nCurrent) * sizeof(PagerSavepoint));\n        // pPager.aSavepoint = aNew;\n        pPager.nSavepoint = nSavepoint;\n\n        /* Populate the PagerSavepoint structures just allocated. */\n        for ( ii = nCurrent ; ii < nSavepoint ; ii++ )\n        {\n          Debug.Assert( pPager.dbSizeValid );\n          aNew[ii] = new PagerSavepoint();\n          aNew[ii].nOrig = pPager.dbSize;\n          if ( isOpen( pPager.jfd ) && ALWAYS(pPager.journalOff > 0 ))\n          {\n            aNew[ii].iOffset = pPager.journalOff;\n          }\n          else\n          {\n            aNew[ii].iOffset = (int)JOURNAL_HDR_SZ( pPager );\n          }\n          aNew[ii].iSubRec = pPager.nSubRec;\n          aNew[ii].pInSavepoint = sqlite3BitvecCreate( pPager.dbSize );\n          if ( null == aNew[ii].pInSavepoint )\n          {\n            return SQLITE_NOMEM;\n          }\n        }\n\n        /* Open the sub-journal, if it is not already opened. */\n        rc = openSubJournal( pPager );\n        assertTruncateConstraint( pPager );\n      }\n\n      return rc;\n    }\n\n    /*\n    ** This function is called to rollback or release (commit) a savepoint.\n    ** The savepoint to release or rollback need not be the most recently\n    ** created savepoint.\n    **\n    ** Parameter op is always either SAVEPOINT_ROLLBACK or SAVEPOINT_RELEASE.\n    ** If it is SAVEPOINT_RELEASE, then release and destroy the savepoint with\n    ** index iSavepoint. If it is SAVEPOINT_ROLLBACK, then rollback all changes\n    ** that have occurred since the specified savepoint was created.\n    **\n    ** The savepoint to rollback or release is identified by parameter\n    ** iSavepoint. A value of 0 means to operate on the outermost savepoint\n    ** (the first created). A value of (Pager.nSavepoint-1) means operate\n    ** on the most recently created savepoint. If iSavepoint is greater than\n    ** (Pager.nSavepoint-1), then this function is a no-op.\n    **\n    ** If a negative value is passed to this function, then the current\n    ** transaction is rolled back. This is different to calling\n    ** sqlite3PagerRollback() because this function does not terminate\n    ** the transaction or unlock the database, it just restores the\n    ** contents of the database to its original state.\n    **\n    ** In any case, all savepoints with an index greater than iSavepoint\n    ** are destroyed. If this is a release operation (op==SAVEPOINT_RELEASE),\n    ** then savepoint iSavepoint is also destroyed.\n    **\n    ** This function may return SQLITE_NOMEM if a memory allocation fails,\n    ** or an IO error code if an IO error occurs while rolling back a\n    ** savepoint. If no errors occur, SQLITE_OK is returned.\n    */\n    static int sqlite3PagerSavepoint( Pager pPager, int op, int iSavepoint )\n    {\n      int rc = SQLITE_OK;\n\n      Debug.Assert( op == SAVEPOINT_RELEASE || op == SAVEPOINT_ROLLBACK );\n      Debug.Assert( iSavepoint >= 0 || op == SAVEPOINT_ROLLBACK );\n\n      if ( iSavepoint < pPager.nSavepoint )\n      {\n        int ii;        /* Iterator variable */\n        int nNew;      /* Number of remaining savepoints after this op. */\n\n        /* Figure out how many savepoints will still be active after this\n        ** operation. Store this value in nNew. Then free resources associated\n        ** with any savepoints that are destroyed by this operation.\n        */\n        nNew = iSavepoint + ( ( op == SAVEPOINT_ROLLBACK ) ? 1 : 0 );\n        for ( ii = nNew ; ii < pPager.nSavepoint ; ii++ )\n        {\n          sqlite3BitvecDestroy( ref pPager.aSavepoint[ii].pInSavepoint );\n        }\n        pPager.nSavepoint = nNew;\n\n        /* If this is a rollback operation, playback the specified savepoint.\n        ** If this is a temp-file, it is possible that the journal file has\n        ** not yet been opened. In this case there have been no changes to\n        ** the database file, so the playback operation can be skipped.\n        */\n        if ( op == SAVEPOINT_ROLLBACK && isOpen( pPager.jfd ) )\n        {\n          PagerSavepoint pSavepoint = ( nNew == 0 ) ? null : pPager.aSavepoint[nNew - 1];\n          rc = pagerPlaybackSavepoint( pPager, pSavepoint );\n          Debug.Assert( rc != SQLITE_DONE );\n        }\n\n        /* If this is a release of the outermost savepoint, truncate\n        ** the sub-journal to zero bytes in size. */\n        if ( nNew == 0 && op == SAVEPOINT_RELEASE && isOpen( pPager.sjfd ) )\n        {\n          Debug.Assert( rc == SQLITE_OK );\n          rc = sqlite3OsTruncate( pPager.sjfd, 0 );\n          pPager.nSubRec = 0;\n        }\n      }\n      return rc;\n    }\n\n    /*\n    ** Return the full pathname of the database file.\n    */\n    static string sqlite3PagerFilename( Pager pPager )\n    {\n      return pPager.zFilename;\n    }\n\n    /*\n    ** Return the VFS structure for the pager.\n    */\n    static sqlite3_vfs sqlite3PagerVfs( Pager pPager )\n    {\n      return pPager.pVfs;\n    }\n\n    /*\n    ** Return the file handle for the database file associated\n    ** with the pager.  This might return NULL if the file has\n    ** not yet been opened.\n    */\n    static sqlite3_file sqlite3PagerFile( Pager pPager )\n    {\n      return pPager.fd;\n    }\n\n    /*\n    ** Return the full pathname of the journal file.\n    */\n    static string sqlite3PagerJournalname( Pager pPager )\n    {\n      return pPager.zJournal;\n    }\n\n    /*\n    ** Return true if fsync() calls are disabled for this pager.  Return FALSE\n    ** if fsync()s are executed normally.\n    */\n    static bool sqlite3PagerNosync( Pager pPager )\n    {\n      return pPager.noSync;\n    }\n\n#if SQLITE_HAS_CODEC\n/*\n** Set or retrieve the codec for this pager\n*/\nstatic void sqlite3PagerSetCodec(\nPager *pPager,\nvoid *(*xCodec)(void*,void*,Pgno,int),\nvoid (*xCodecSizeChng)(void*,int,int),\nvoid (*xCodecFree)(void*),\nvoid *pCodec\n){\nif( pPager->xCodecFree ) pPager->xCodecFree(pPager->pCodec);\npPager->xCodec = xCodec;\npPager->xCodecSizeChng = xCodecSizeChng;\npPager->xCodecFree = xCodecFree;\npPager->pCodec = pCodec;\npagerReportSize(pPager);\n}\nstatic void *sqlite3PagerGetCodec(Pager *pPager){\nreturn pPager->pCodec;\n}\n#endif\n\n#if !SQLITE_OMIT_AUTOVACUUM\n    /*\n** Move the page pPg to location pgno in the file.\n**\n** There must be no references to the page previously located at\n** pgno (which we call pPgOld) though that page is allowed to be\n** in cache.  If the page previously located at pgno is not already\n** in the rollback journal, it is not put there by by this routine.\n**\n** References to the page pPg remain valid. Updating any\n** meta-data associated with pPg (i.e. data stored in the nExtra bytes\n** allocated along with the page) is the responsibility of the caller.\n**\n** A transaction must be active when this routine is called. It used to be\n** required that a statement transaction was not active, but this restriction\n** has been removed (CREATE INDEX needs to move a page when a statement\n** transaction is active).\n**\n** If the fourth argument, isCommit, is non-zero, then this page is being\n** moved as part of a database reorganization just before the transaction\n** is being committed. In this case, it is guaranteed that the database page\n** pPg refers to will not be written to again within this transaction.\n**\n** This function may return SQLITE_NOMEM or an IO error code if an error\n** occurs. Otherwise, it returns SQLITE_OK.\n*/\n    static int sqlite3PagerMovepage( Pager pPager, DbPage pPg, u32 pgno, int isCommit )\n    {\n      PgHdr pPgOld;                /* The page being overwritten. */\n      u32 needSyncPgno = 0;        /* Old value of pPg.pgno, if sync is required */\n      int rc;                      /* Return code */\n      Pgno origPgno;               /* The original page number */\n\n      Debug.Assert( pPg.nRef > 0 );\n\n      /* If the page being moved is dirty and has not been saved by the latest\n      ** savepoint, then save the current contents of the page into the\n      ** sub-journal now. This is required to handle the following scenario:\n      **\n      **   BEGIN;\n      **     <journal page X, then modify it in memory>\n      **     SAVEPOINT one;\n      **       <Move page X to location Y>\n      **     ROLLBACK TO one;\n      **\n      ** If page X were not written to the sub-journal here, it would not\n      ** be possible to restore its contents when the "ROLLBACK TO one"\n      ** statement were is processed.\n      **\n      ** subjournalPage() may need to allocate space to store pPg.pgno into\n      ** one or more savepoint bitvecs. This is the reason this function\n      ** may return SQLITE_NOMEM.\n      */\n      if ( ( pPg.flags & PGHDR_DIRTY ) != 0\n      && subjRequiresPage( pPg )\n      && SQLITE_OK != ( rc = subjournalPage( pPg ) )\n      )\n      {\n        return rc;\n      }\n\n      PAGERTRACE( "MOVE %d page %d (needSync=%d) moves to %d\\n",\n      PAGERID( pPager ), pPg.pgno, ( pPg.flags & PGHDR_NEED_SYNC ) != 0 ? 1 : 0, pgno );\n      IOTRACE( "MOVE %p %d %d\\n", pPager, pPg.pgno, pgno );\n\n      /* If the journal needs to be sync()ed before page pPg.pgno can\n      ** be written to, store pPg.pgno in local variable needSyncPgno.\n      **\n      ** If the isCommit flag is set, there is no need to remember that\n      ** the journal needs to be sync()ed before database page pPg.pgno\n      ** can be written to. The caller has already promised not to write to it.\n      */\n      if ( ( ( pPg.flags & PGHDR_NEED_SYNC ) != 0 ) && 0 == isCommit )\n      {\n        needSyncPgno = pPg.pgno;\n        Debug.Assert( pageInJournal( pPg ) || pPg.pgno > pPager.dbOrigSize );\n        Debug.Assert( ( pPg.flags & PGHDR_DIRTY ) != 0 );\n        Debug.Assert( pPager.needSync );\n      }\n\n      /* If the cache contains a page with page-number pgno, remove it\n      ** from its hash chain. Also, if the PgHdr.needSync was set for\n      ** page pgno before the \'move\' operation, it needs to be retained\n      ** for the page moved there.\n      */\n      pPg.flags &= ~PGHDR_NEED_SYNC;\n      pPgOld = pager_lookup( pPager, pgno );\n      Debug.Assert( null == pPgOld || pPgOld.nRef == 1 );\n      if ( pPgOld != null )\n      {\n        pPg.flags |= ( pPgOld.flags & PGHDR_NEED_SYNC );\n        sqlite3PcacheDrop( pPgOld );\n      }\n\n      origPgno = pPg.pgno;\n      sqlite3PcacheMove( pPg, pgno );\n      sqlite3PcacheMakeDirty( pPg );\n      pPager.dbModified = true;\n\n      if ( needSyncPgno != 0 )\n      {\n        /* If needSyncPgno is non-zero, then the journal file needs to be\n        ** sync()ed before any data is written to database file page needSyncPgno.\n        ** Currently, no such page exists in the page-cache and the\n        ** "is journaled" bitvec flag has been set. This needs to be remedied by\n        ** loading the page into the pager-cache and setting the PgHdr.needSync\n        ** flag.\n        **\n        ** If the attempt to load the page into the page-cache fails, (due\n        ** to a malloc() or IO failure), clear the bit in the pInJournal[]\n        ** array. Otherwise, if the page is loaded and written again in\n        ** this transaction, it may be written to the database file before\n        ** it is synced into the journal file. This way, it may end up in\n        ** the journal file twice, but that is not a problem.\n        **\n        ** The sqlite3PagerGet() call may cause the journal to sync. So make\n        ** sure the Pager.needSync flag is set too.\n        */\n        PgHdr pPgHdr = null;\n        Debug.Assert( pPager.needSync );\n        rc = sqlite3PagerGet( pPager, needSyncPgno, ref pPgHdr );\n        if ( rc != SQLITE_OK )\n        {\n          if ( needSyncPgno <= pPager.dbOrigSize )\n          {\n            Debug.Assert( pPager.pTmpSpace != null );\n            u32[] pTemp = new u32[pPager.pTmpSpace.Length];\n            sqlite3BitvecClear( pPager.pInJournal, needSyncPgno, pTemp );//pPager.pTmpSpace );\n          }\n          return rc;\n        }\n        pPager.needSync = true;\n        Debug.Assert( pPager.noSync == false &&\n#if SQLITE_OMIT_MEMORYDB\n0==MEMDB\n#else\n 0 == pPager.memDb\n#endif\n );\n        pPgHdr.flags |= PGHDR_NEED_SYNC;\n        sqlite3PcacheMakeDirty( pPgHdr );\n        sqlite3PagerUnref( pPgHdr );\n      }\n\n      /*\n      ** For an in-memory database, make sure the original page continues\n      ** to exist, in case the transaction needs to roll back.  We allocate\n      ** the page now, instead of at rollback, because we can better deal\n      ** with an out-of-memory error now.  Ticket #3761.\n      */\n      if (\n#if SQLITE_OMIT_MEMORYDB\nMEMDB != 0\n#else\n pPager.memDb != 0\n#endif\n )\n      {\n        DbPage pNew = null;\n        rc = sqlite3PagerAcquire( pPager, origPgno, ref pNew, 1 );\n        if ( rc != SQLITE_OK )\n        {\n          sqlite3PcacheMove( pPg, origPgno );\n          return rc;\n        }\n        sqlite3PagerUnref( pNew );\n      }\n      return SQLITE_OK;\n    }\n#endif\n\n    /*\n** Return a pointer to the data for the specified page.\n*/\n    static byte[] sqlite3PagerGetData( DbPage pPg )\n    {\n      Debug.Assert( pPg.nRef > 0 || pPg.pPager.memDb != 0 );\n      return pPg.pData;\n    }\n\n    /*\n    ** Return a pointer to the Pager.nExtra bytes of "extra" space\n    ** allocated along with the specified page.\n    */\n    static MemPage sqlite3PagerGetExtra( DbPage pPg )\n    {\n      return pPg.pExtra;\n    }\n\n    /*\n    ** Get/set the locking-mode for this pager. Parameter eMode must be one\n    ** of PAGER_LOCKINGMODE_QUERY, PAGER_LOCKINGMODE_NORMAL or\n    ** PAGER_LOCKINGMODE_EXCLUSIVE. If the parameter is not _QUERY, then\n    ** the locking-mode is set to the value specified.\n    **\n    ** The returned value is either PAGER_LOCKINGMODE_NORMAL or\n    ** PAGER_LOCKINGMODE_EXCLUSIVE, indicating the current (possibly updated)\n    ** locking-mode.\n    */\n    static bool sqlite3PagerLockingMode( Pager pPager, int eMode )\n    {\n      Debug.Assert( eMode == PAGER_LOCKINGMODE_QUERY\n      || eMode == PAGER_LOCKINGMODE_NORMAL\n      || eMode == PAGER_LOCKINGMODE_EXCLUSIVE );\n      Debug.Assert( PAGER_LOCKINGMODE_QUERY < 0 );\n      Debug.Assert( PAGER_LOCKINGMODE_NORMAL >= 0 && PAGER_LOCKINGMODE_EXCLUSIVE >= 0 );\n      if ( eMode >= 0 && !pPager.tempFile )\n      {\n        pPager.exclusiveMode = eMode != 0;\n      }\n      return pPager.exclusiveMode;\n    }\n\n    /*\n    ** Get/set the journal-mode for this pager. Parameter eMode must be one of:\n    **\n    **    PAGER_JOURNALMODE_QUERY\n    **    PAGER_JOURNALMODE_DELETE\n    **    PAGER_JOURNALMODE_TRUNCATE\n    **    PAGER_JOURNALMODE_PERSIST\n    **    PAGER_JOURNALMODE_OFF\n    **    PAGER_JOURNALMODE_MEMORY\n    **\n    ** If the parameter is not _QUERY, then the journal_mode is set to the\n    ** value specified if the change is allowed.  The change is disallowed\n    ** for the following reasons:\n    **\n    **   *  An in-memory database can only have its journal_mode set to _OFF\n    **      or _MEMORY.\n    **\n    **   *  The journal mode may not be changed while a transaction is active.\n    **\n    ** The returned indicate the current (possibly updated) journal-mode.\n    */\n    static int sqlite3PagerJournalMode( Pager pPager, int eMode )\n    {\n      Debug.Assert( eMode == PAGER_JOURNALMODE_QUERY\n      || eMode == PAGER_JOURNALMODE_DELETE\n      || eMode == PAGER_JOURNALMODE_TRUNCATE\n      || eMode == PAGER_JOURNALMODE_PERSIST\n      || eMode == PAGER_JOURNALMODE_OFF\n      || eMode == PAGER_JOURNALMODE_MEMORY );\n      Debug.Assert( PAGER_JOURNALMODE_QUERY < 0 );\n      if ( eMode >= 0\n      && (\n#if SQLITE_OMIT_MEMORYDB\n0==MEMDB\n#else\n 0 == pPager.memDb\n#endif\n || eMode == PAGER_JOURNALMODE_MEMORY\n      || eMode == PAGER_JOURNALMODE_OFF )\n      && !pPager.dbModified\n      && ( !isOpen( pPager.jfd ) || 0 == pPager.journalOff )\n      )\n      {\n        if ( isOpen( pPager.jfd ) )\n        {\n          sqlite3OsClose( pPager.jfd );\n        }\n        pPager.journalMode = (u8)eMode;\n      }\n      return (int)pPager.journalMode;\n    }\n\n    /*\n    ** Get/set the size-limit used for persistent journal files.\n    **\n    ** Setting the size limit to -1 means no limit is enforced.\n    ** An attempt to set a limit smaller than -1 is a no-op.\n    */\n    static i64 sqlite3PagerJournalSizeLimit( Pager pPager, i64 iLimit )\n    {\n      if ( iLimit >= -1 )\n      {\n        pPager.journalSizeLimit = iLimit;\n      }\n      return pPager.journalSizeLimit;\n    }\n\n    /*\n    ** Return a pointer to the pPager.pBackup variable. The backup module\n    ** in backup.c maintains the content of this variable. This module\n    ** uses it opaquely as an argument to sqlite3BackupRestart() and\n    ** sqlite3BackupUpdate() only.\n    */\n    static sqlite3_backup sqlite3PagerBackupPtr( Pager pPager )\n    {\n      return pPager.pBackup;\n    }\n#endif // * SQLITE_OMIT_DISKIO */\n  }\n}\n'