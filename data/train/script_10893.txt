b'#include <bits/stdc++.h>\nusing namespace std;\n#define gc getchar_unlocked\n#define fo(i,n) for(i=0;i<n;i++)\n#define Fo(i,k,n) for(i=k;i<n;i++)\n#define ll long long\n#define si(x)\tscanf("%d",&x)\n#define sl(x)\tscanf("%I64d",&x)\n#define ss(s)\tscanf("%s",s)\n#define pb push_back\n#define mp make_pair\n#define F first\n#define S second\n#define all(x) x.begin(), x.end()\n#define clr(x) memset(x, 0, sizeof(x))\n#define sortall(x) sort(all(x))\n#define tr(it, a) for(auto it = a.begin(); it != a.end(); it++)\n#define PI 3.1415926535897932384626\ntypedef pair<int, int>\tpii;\ntypedef pair<ll, ll>\tpll;\ntypedef vector<int>\t\tvi;\ntypedef vector<ll>\t\tvl;\ntypedef vector<pii>\t\tvpii;\ntypedef vector<pll>\t\tvpll;\ntypedef vector<vi>\t\tvvi;\ntypedef vector<vl>\t\tvvl;\nconst ll mod = 1e16;\nconst int N = 1004, M = 1e5+3;\nvi g[M];\nvpii tic[M];\n\n//BEGINS\n//LCA implemented with sparse table..\n//dp[u][i] gives uth node se 2^i length ke parent tak min value in node.\nll dp[M][20];\nint lvl[M], P[M][20];\nint vis[N];\n\nvoid dfs(int u, int p){\n\tP[u][0] = p;\n\tlvl[u] = 1+lvl[p];\n\tfor(int v: g[u]){\n\t\tif (v != p) dfs(v, u);\n\t}\n}\nll get(int u, int l){\n    int lg = 0, i;\n    if (l == 1) return dp[u][0];\n    //cout<<"from "<<u<<" seg of size "<<l<<" ";\n    int nlev = lvl[u]-l+1;\n    while( (1<<lg) <= l ) lg++;\n    lg--;\n    ll ans = mod;\n    for(i = lg; i>=0; i--){\n        if (lvl[u] - (1<<i) + 1 >= nlev )\n            ans = min(ans, dp[u][i]), u = P[u][i];\n    }\n    return ans;\n}\n\n\nint main()\n{\n\tios_base::sync_with_stdio(false);\n\tcin.tie(NULL);\n\tif (0){\n        freopen("input.txt", "r", stdin);\n        freopen("output.txt", "w", stdout);\n    }\n\tint i,n,k,j,m,u,v,w,x;\n\tint t;\n\tcin>>n>>m;\n    fo(i, n-1){\n        cin>>u>>v;\n        g[v].pb(u);\n        g[u].pb(v);\n    }\n    fo(i, m){\n        cin>>u>>k>>w;\n        tic[u].pb({k, w});\n    }\n    Fo(i, 0, 20)\n        Fo(j, 0, n+1) P[j][i] = -1;\n    lvl[0] = -1;\n    dfs(1, 0);\n\n    Fo(i, 1, 20){\n        Fo(j, 1, n+1){\n            if (P[j][i-1] != -1)\n                P[j][i] = P[P[j][i-1]][i-1];\n        }\n    }\n\n    int q;\n    cin >> q;\n    set<pii> city;\n    Fo(i, 1, n+1) city.insert({lvl[i], i});\n    tr(it, city){\n        pii cur = *it;\n        int lev = cur.F;\n        u = cur.S;\n        if (u == 1){\n            //cout<<1<<" "<<0<<endl;\n            dp[u][0] = 0;\n            continue;\n        }\n        dp[u][0] = mod;\n\t//Find dp[u][0] using dp[p[u][0]][*]\n        for(pii t: tic[u]){\n            int dis = min(lev, t.F); ll w = t.S;\n            dp[u][0] = min(dp[u][0], w + get(P[u][0], dis));\n        }\n        //cout<<u<<" "<<dp[u][0]<<endl;\n\t//DYNAMIC UPDATION\n        Fo(i, 1, 20){\n            if (P[u][i-1] != -1){\n                dp[u][i] = min(dp[u][i-1], dp[P[u][i-1]][i-1]);\n            }\n            else\n                dp[u][i] = dp[u][i-1];\n        }\n    }\n    fo(i, q){\n        cin>>x;\n        cout<<dp[x][0]<<endl;\n    }\n\n\n\treturn 0;\n}\n\n\n'