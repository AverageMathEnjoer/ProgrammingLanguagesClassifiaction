b'//intersection of horizontal and vertical lines https://www.codechef.com/NOV16/problems/URBANDEV\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp> \n#include <ext/pb_ds/tree_policy.hpp> \n#include <ext/pb_ds/detail/standard_policies.hpp>\nusing namespace std;\nusing namespace __gnu_pbds;\ntypedef tree<int,null_type,greater<int>,rb_tree_tag,tree_order_statistics_node_update> ordered_set;\ntypedef tree<pair<int, int>,null_type,less<pair<int, int>>,rb_tree_tag,tree_order_statistics_node_update> ordered_mset;\n#define gc getchar_unlocked\n#define fo(i,n) for(i=0;i<n;i++)\n#define Fo(i,k,n) for(i=k;k<n?i<n:i>n;k<n?i+=1:i-=1)\n#define ll long long\n#define si(x)\tscanf("%d",&x)\n#define sl(x)\tscanf("%lld",&x)\n#define ss(s)\tscanf("%s",s)\n#define pi(x)\tprintf("%d\\n",x)\n#define pl(x)\tprintf("%lld\\n",x)\n#define ps(s)\tprintf("%s\\n",s)\n#define pb push_back\n#define mp make_pair\n#define F first\n#define S second\n#define all(x) x.begin(), x.end()\n#define clr(x) memset(x, 0, sizeof(x))\n#define sortall(x) sort(all(x))\n#define tr(it, a) for(auto it = a.begin(); it != a.end(); it++)\n#define PI 3.1415926535897932384626\ntypedef pair<int, int>\tpii;\ntypedef pair<ll, ll>\tpll;\ntypedef vector<int>\t\tvi;\ntypedef vector<ll>\t\tvll;\ntypedef vector<pii>\t\tvpii;\ntypedef vector<pll>\t\tvpll;\ntypedef vector<vi>\t\tvvi;\ntypedef vector<vll>\t\tvvl;\nconst int mod = 1000000007;\nconst int N = 1e5+12;\nusing namespace std;\n int cnt[N];\ntypedef pair<int,int> pii;\n \nclass CBF\n{\npublic:\n\tbool operator()(const pii& p1, const pii& p2)const\n\t{\n\t\treturn p1.first < p2.first;\n\t}\n};\n \n \nvi lo[N], hi[N];\nvector< pair<int, pii> > ver[N];\nset<int> events;\nunordered_map<int, int> hai[2][N];\n#define x1 u.F\n#define y1 u.S\n#define x2 v.F\n#define y2 v.S\nint n;\n\nstruct node{\n\tpii u,v;\n\tint o;\n\tvoid read(int i){\n\t\tsi(u.F); si(u.S);\n\t\tsi(v.F); si(v.S);\n        events.insert(x1);\n        events.insert(x2);\n        if(u.S > v.S or u.F > v.F) swap(u, v);\n\t\tfind(i);\n\t}\n\tvoid find(int pos){\n\t\tif(u.F==v.F){\n\t\t\to=1;\n\t\t\tver[u.F].pb({pos, {u.S, v.S}});\n\t\t}\n\t\telse{ \n\t\t\to=0; \n\t\t\tlo[u.F].pb(u.S);\n\t\t\thi[v.F].pb(v.S);\n\t\t}\n        hai[o][u.F][u.S] = 1;\n        \n        hai[o][v.F][v.S] = 1;\n\t}\n    void change(int i){\n       swap(x1, y1); swap(x2, y2);\n        if(u.S > v.S or u.F > v.F) swap(u, v);\n\t\tfind(i);\n    }\n}seg[N];\n\nvoid input(){\n    int i;\n    si(n);\n\tfo(i, n){\n\t\tseg[i].read(i); cnt[i] = 0;\n\t}\n    \n}\nvoid reset(){\n    int i;\n  //  fo(i, N) hai[0][i].clear(), hai[1][i].clear();\n    fo(i, N) lo[i].clear(), hi[i].clear(), ver[i].clear();\n    events.clear();\n    fo(i, n) seg[i].change(i), events.insert(seg[i].x1), events.insert(seg[i].x2);    \n    \n}\nint T = 1;\nint inf = mod;\nvoid solve(){\n \tint i;\n \t\n\tll ans = 0;\n    \n\tordered_mset con;\n     int xx;\n \n\tfor(int xx: events){\n        //cout<<"AT "<<xx<<endl;\n\t\tfor(int y: lo[xx])\n            con.insert({y, T++});\n\t\t\n        if(con.empty())continue;\n\t\t\n\t\tfor(pair<int, pii> line: ver[xx]){\n\t\t\tint j = line.F;\n\t\t\tpii span = line.S;\n\t\t\tcnt[j] += con.order_of_key({span.S, inf})\n                    - con.order_of_key({span.F-1, inf});\n            //cout<<"LINE "<<span.F<<" "<<span.S<<" intersects with "<<cnt[j]<<endl;\n\t\t\t\n\t\t}\n        for(int y: hi[xx])\n            con.erase(con.lower_bound({y, 0}));\t\t\n\t}\n   \n \n }\nint main()\n{\n     int i;\n\n    input();\n    fo(i, n){\n      int o = seg[i].o;\n      cnt[i] -= hai[1-o][seg[i].x1][seg[i].y1];\n      cnt[i] -= hai[1-o][seg[i].x2][seg[i].y2];\n      \n    }\n\tsolve();\n    reset();\n    //clr(cnt);\n    solve();\n   \n    ll ans = 0;\n    fo(i, n) ans += cnt[i];\n    ans /= 2;\n    pl(ans);\n\tfo(i, n) printf("%d ",cnt[i]);\n}'