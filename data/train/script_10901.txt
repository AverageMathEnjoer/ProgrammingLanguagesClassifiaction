b'using System;\nusing System.Diagnostics;\n\nusing i64 = System.Int64;\n\nnamespace CS_SQLite3\n{\n  public partial class CSSQLite\n  {\n    /*\n    ** 2001 September 15\n    **\n    ** The author disclaims copyright to this source code.  In place of\n    ** a legal notice, here is a blessing:\n    **\n    **    May you do good and not evil.\n    **    May you find forgiveness for yourself and forgive others.\n    **    May you share freely, never taking more than you give.\n    **\n    *************************************************************************\n    ** This file contains the sqlite3_get_table() and //sqlite3_free_table()\n    ** interface routines.  These are just wrappers around the main\n    ** interface routine of sqlite3_exec().\n    **\n    ** These routines are in a separate files so that they will not be linked\n    ** if they are not used.\n    **\n    ** $Id: table.c,v 1.39 2009/01/19 20:49:10 drh Exp $\n    **\n    *************************************************************************\n    **  Included in SQLite3 port to C#-SQLite;  2008 Noah B Hart\n    **  C#-SQLite is an independent reimplementation of the SQLite software library\n    **\n    **  $Header$\n    *************************************************************************\n    */\n    //#include "sqliteInt.h"\n    //#include <stdlib.h>\n    //#include <string.h>\n\n#if !SQLITE_OMIT_GET_TABLE\n\n/*\n** This structure is used to pass data from sqlite3_get_table() through\n** to the callback function is uses to build the result.\n*/\nclass TabResult {\npublic string[] azResult;\npublic string zErrMsg;\npublic int nResult;\npublic int nAlloc;\npublic int nRow;\npublic int nColumn;\npublic int nData;\npublic int rc;\n};\n\n/*\n** This routine is called once for each row in the result table.  Its job\n** is to fill in the TabResult structure appropriately, allocating new\n** memory as necessary.\n*/\npublic static int sqlite3_get_table_cb( object pArg, i64 nCol, object Oargv, object Ocolv )\n{\nstring[] argv = (string[])Oargv;\nstring[]colv = (string[])Ocolv;\nTabResult p = (TabResult)pArg;\nint need;\nint i;\nstring z;\n\n/* Make sure there is enough space in p.azResult to hold everything\n** we need to remember from this invocation of the callback.\n*/\nif( p.nRow==0 && argv!=null ){\nneed = (int)nCol*2;\n}else{\nneed = (int)nCol;\n}\nif( p.nData + need >= p.nAlloc ){\nstring[] azNew;\np.nAlloc = p.nAlloc*2 + need + 1;\nazNew = new string[p.nAlloc];//sqlite3_realloc( p.azResult, sizeof(char*)*p.nAlloc );\nif( azNew==null ) goto malloc_failed;\np.azResult = azNew;\n}\n\n/* If this is the first row, then generate an extra row containing\n** the names of all columns.\n*/\nif( p.nRow==0 ){\np.nColumn = (int)nCol;\nfor(i=0; i<nCol; i++){\nz = sqlite3_mprintf("%s", colv[i]);\nif( z==null ) goto malloc_failed;\np.azResult[p.nData++ -1] = z;\n}\n}else if( p.nColumn!=nCol ){\n//sqlite3_free(ref p.zErrMsg);\np.zErrMsg = sqlite3_mprintf(\n"sqlite3_get_table() called with two or more incompatible queries"\n);\np.rc = SQLITE_ERROR;\nreturn 1;\n}\n\n/* Copy over the row data\n*/\nif( argv!=null ){\nfor(i=0; i<nCol; i++){\nif( argv[i]==null ){\nz = null;\n}else{\nint n = sqlite3Strlen30(argv[i])+1;\n//z = sqlite3_malloc( n );\n//if( z==0 ) goto malloc_failed;\nz= argv[i];//memcpy(z, argv[i], n);\n}\np.azResult[p.nData++ -1] = z;\n}\np.nRow++;\n}\nreturn 0;\n\nmalloc_failed:\np.rc = SQLITE_NOMEM;\nreturn 1;\n}\n\n/*\n** Query the database.  But instead of invoking a callback for each row,\n** malloc() for space to hold the result and return the entire results\n** at the conclusion of the call.\n**\n** The result that is written to ***pazResult is held in memory obtained\n** from malloc().  But the caller cannot free this memory directly.\n** Instead, the entire table should be passed to //sqlite3_free_table() when\n** the calling procedure is finished using it.\n*/\npublic static int sqlite3_get_table(\nsqlite3 db,               /* The database on which the SQL executes */\nstring zSql,              /* The SQL to be executed */\nref string[] pazResult,   /* Write the result table here */\nref int pnRow,            /* Write the number of rows in the result here */\nref int pnColumn,         /* Write the number of columns of result here */\nref string pzErrMsg       /* Write error messages here */\n){\nint rc;\nTabResult res = new TabResult();\n\npazResult = null;\npnColumn = 0;\npnRow = 0;\npzErrMsg = "";\nres.zErrMsg = "";\nres.nResult = 0;\nres.nRow = 0;\nres.nColumn = 0;\nres.nData = 1;\nres.nAlloc = 20;\nres.rc = SQLITE_OK;\nres.azResult = new string[res.nAlloc];// sqlite3_malloc( sizeof( char* ) * res.nAlloc );\nif( res.azResult==null ){\ndb.errCode = SQLITE_NOMEM;\nreturn SQLITE_NOMEM;\n}\nres.azResult[0] = null;\nrc = sqlite3_exec(db, zSql, (dxCallback) sqlite3_get_table_cb, res, ref pzErrMsg);\n//Debug.Assert( sizeof(res.azResult[0])>= sizeof(res.nData) );\n//res.azResult = SQLITE_INT_TO_PTR( res.nData );\nif( (rc&0xff)==SQLITE_ABORT ){\n//sqlite3_free_table(ref res.azResult[1] );\nif( res.zErrMsg !=""){\nif( pzErrMsg !=null ){\n//sqlite3_free(ref pzErrMsg);\npzErrMsg = sqlite3_mprintf("%s",res.zErrMsg);\n}\n//sqlite3_free(ref res.zErrMsg);\n}\ndb.errCode = res.rc;  /* Assume 32-bit assignment is atomic */\nreturn res.rc;\n}\n//sqlite3_free(ref res.zErrMsg);\nif( rc!=SQLITE_OK ){\n//sqlite3_free_table(ref res.azResult[1]);\nreturn rc;\n}\nif( res.nAlloc>res.nData ){\nstring[] azNew;\nArray.Resize(ref res.azResult, res.nData-1);//sqlite3_realloc( res.azResult, sizeof(char*)*(res.nData+1) );\n//if( azNew==null ){\n//  //sqlite3_free_table(ref res.azResult[1]);\n//  db.errCode = SQLITE_NOMEM;\n//  return SQLITE_NOMEM;\n//}\nres.nAlloc = res.nData+1;\n//res.azResult = azNew;\n}\npazResult = res.azResult;\npnColumn = res.nColumn;\npnRow = res.nRow;\nreturn rc;\n}\n\n/*\n** This routine frees the space the sqlite3_get_table() malloced.\n*/\nstatic void //sqlite3_free_table(\nref string azResult            /* Result returned from from sqlite3_get_table() */\n){\nif( azResult !=null){\nint i, n;\n//azResult--;\n//Debug.Assert( azResult!=0 );\n//n = SQLITE_PTR_TO_INT(azResult[0]);\n//for(i=1; i<n; i++){ if( azResult[i] ) //sqlite3_free(azResult[i]); }\n//sqlite3_free(ref azResult);\n}\n}\n\n#endif //* SQLITE_OMIT_GET_TABLE */\n  }\n}\n'