b"import Data.List\r\nimport Debug.Trace\r\n\r\ndebug = flip trace\r\n\r\nmaxtail :: Ord a => [a] -> [a]\r\nmaxtail = foldl op []\r\n\r\nop :: Ord a => [a] -> a -> [a]\r\nop ys x = maximum [zs ++ [x] | zs <- borders ys]\r\n\r\n-- Borders\r\n\r\nborders :: Ord a => [a] -> [[a]]\r\nborders [] = [[]]\r\nborders xs = xs : borders (border xs)\r\n\r\n-- Border\r\n\r\nafter :: Eq a => [a] -> [a] -> [a]\r\nafter [] ys = ys\r\nafter xs [] = xs\r\nafter (x:xs) (y:ys) \r\n    | x == y = after xs ys\r\n    | otherwise = (x:xs)\r\n\r\nbefore :: Eq a => [a] -> [a] -> [a]\r\nbefore xs ys = reverse $ after (reverse xs) (reverse ys)\r\n\r\nborder :: Ord a => [a] -> [a]\r\nborder xs\r\n    | xs == []                  = []\r\n    | length(xs) == 1           = []\r\n    | ys_after_zs == []         = []\r\n    | head(ys_after_zs) < x     = border (zs ++ [x])\r\n    | head(ys_after_zs) == x    = (zs ++ [x])\r\n    | head(ys_after_zs) > x     = border (zs ++ [x])\r\n  where \r\n    ys = init xs \r\n    x = last xs \r\n    zs = border ys \r\n    ys_after_zs = (ys `after` zs) \r\n\r\n-- Cocktail\r\n\r\nmaxtail' :: Ord a => [a] -> [a]\r\nmaxtail' = uncurry (++) . cocktail'\r\n\r\ncocktail' :: Ord a => [a] -> ([a], [a])\r\ncocktail' = foldl op' ([], [])\r\n\r\nop' :: Ord a => ([a], [a]) -> a -> ([a], [a])\r\nop' (zs, ws) x \r\n    | null ws   = ([], [x])\r\n    | w < x     = cocktail' (zs ++ [x])\r\n    | w == x    = (zs ++ [x], tail ws ++ [x])\r\n    | w > x     = ([], zs ++ ws ++ [x])\r\n  where \r\n    w = head ws\r\n\r\n-- Reducing the problem size\r\n\r\nmaxtail'' :: Ord a => [a] -> [a]\r\nmaxtail'' = uncurry (++) . cocktail''\r\n\r\ncocktail'' :: Ord a => [a] -> ([a], [a])\r\ncocktail'' = foldl op'' ([], [])\r\n\r\nop'' (zs, ws) x \r\n    | null ws   = ([], [x])\r\n    | w < x     = cocktail'' (take r zs ++ [x])\r\n    | w == x    = (zs ++ [x], tail ws ++ [x])\r\n    | w > x     = ([], zs ++ ws ++ [x])\r\n  where \r\n    w = head ws\r\n    r = (length zs) `mod` (length ws)\r\n"