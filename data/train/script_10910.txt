b'// UVa1671 History of Languages\n// Rujia Liu\n//\n// This is Problem 12-1 of <<Beginning Algorithm Contests>> 2nd edition\n//\n// We want to test whether A intersects with ~B (finalA = 1, finalB = 0), or B intersects with ~A (finalA = 0, finalB = 1)\n// So we can do a single DFS instead of two, checking finalA XOR finals B=1\n#include<cstdio>\n#include<cstring>\nusing namespace std;\n\nconst int maxn = 2000 + 5;\nconst int maxt = 26;\n\n// Note: state 0 is a dummy state, other states\' number is increased by 1\nstruct DFA {\n  int n;\n  int is_final[maxn];\n  int next[maxn][maxt];\n  void read(int t) {\n    scanf("%d", &n);\n    for(int i = 1; i <= n; i++) {\n      scanf("%d", &is_final[i]);\n      for(int c = 0; c < t; c++) {\n        int s;\n        scanf("%d", &s);\n        next[i][c] = s+1;\n      }\n    }\n    is_final[0] = 0; // dummy state is not final\n  }\n}A, B;\n\nint vis[maxn][maxn], kase, t;\n\n// try to find a common string starting from (s1, s2)\nbool dfs(int s1, int s2) {\n  vis[s1][s2] = kase;\n  if(A.is_final[s1] ^ B.is_final[s2]) return true;\n  for(int i = 0; i < t; i++) {\n    int nexta = A.next[s1][i];\n    int nextb = B.next[s2][i];\n    if(vis[nexta][nextb] != kase && dfs(nexta, nextb)) return true;\n  }\n  return false;\n}\n\nint main() {\n  kase = 0;\n  memset(vis, 0, sizeof(vis));\n  while(scanf("%d", &t) == 1 && t) {\n    A.read(t);\n    B.read(t);\n    printf("Case #%d: ", ++kase);\n    if(dfs(1, 1)) printf("No\\n");\n    else printf("Yes\\n");\n  }\n  return 0;\n}\n'