b'\xef\xbb\xbfusing Asn1;\nusing System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Net;\n\nnamespace Rubeus\n{\n    //TGS-REQ         ::= [APPLICATION 12] KDC-REQ\n\n    //KDC-REQ         ::= SEQUENCE {\n    //    -- NOTE: first tag is [1], not [0]\n    //    pvno            [1] INTEGER (5) ,\n    //    msg-type        [2] INTEGER (12 -- TGS),\n    //    padata          [3] SEQUENCE OF PA-DATA OPTIONAL\n    //                        -- NOTE: not empty --,\n    //                          in this case, it\'s an AP-REQ\n    //    req-body        [4] KDC-REQ-BODY\n    //}\n\n    public class TGS_REQ\n    {\n        public static byte[] NewTGSReq(string userName, string domain, string sname, Ticket providedTicket, byte[] clientKey, Interop.KERB_ETYPE paEType, Interop.KERB_ETYPE requestEType = Interop.KERB_ETYPE.subkey_keymaterial, bool renew = false, string s4uUser = "", bool enterprise = false, bool roast = false, bool opsec = false, bool unconstrained = false, KRB_CRED tgs = null, string targetDomain = "", bool u2u = false)\n        {\n            TGS_REQ req;\n            if (u2u)\n                req = new TGS_REQ(!u2u);\n            else\n                req = new TGS_REQ(!opsec);\n\n            if (!opsec && !u2u)\n            {\n                // set the username\n                req.req_body.cname.name_string.Add(userName);\n            }\n\n            // get domain from service for cross domain requests\n            // if not requesting a cross domain TGT (krbtgt)\n            string[] parts = sname.Split(\'/\');\n            if (String.IsNullOrEmpty(targetDomain))\n            {\n                if (!(roast) && (parts.Length > 1) && (parts[0] != "krbtgt") && (tgs == null) && parts[0] != "kadmin")\n                {\n                    if (parts[1].Split(\'.\').Length > 2)\n                    {\n                        targetDomain = parts[1].Substring(parts[1].IndexOf(\'.\') + 1);\n\n                        // remove port when SPN is in format \'svc/domain.com:1234\'\n                        string[] targetParts = targetDomain.Split(\':\');\n                        if (targetParts.Length > 1)\n                        {\n                            targetDomain = targetParts[0];\n                        }\n                    }\n                    if (String.IsNullOrEmpty(targetDomain))\n                        targetDomain = domain;\n                }\n                else if (enterprise)\n                {\n                    targetDomain = sname.Split(\'@\')[1];\n                }\n                else\n                {\n                    targetDomain = domain;\n                }\n            }\n\n            // the realm (domain) the user exists in\n            req.req_body.realm = targetDomain.ToUpper();\n\n            // add in our encryption types\n            if (requestEType == Interop.KERB_ETYPE.subkey_keymaterial)\n            {\n                // normal behavior\n                req.req_body.etypes.Add(Interop.KERB_ETYPE.aes256_cts_hmac_sha1);\n                req.req_body.etypes.Add(Interop.KERB_ETYPE.aes128_cts_hmac_sha1);\n                req.req_body.etypes.Add(Interop.KERB_ETYPE.rc4_hmac);\n                req.req_body.etypes.Add(Interop.KERB_ETYPE.rc4_hmac_exp);\n                //req.req_body.etypes.Add(Interop.KERB_ETYPE.des_cbc_crc);\n            }\n            // real traffic have these etypes except when requesting a TGT, then only \n            else if ((opsec) && (parts.Length > 1) && (parts[0] != "krbtgt"))\n            {\n                req.req_body.etypes.Add(Interop.KERB_ETYPE.aes256_cts_hmac_sha1);\n                req.req_body.etypes.Add(Interop.KERB_ETYPE.aes128_cts_hmac_sha1);\n                req.req_body.etypes.Add(Interop.KERB_ETYPE.rc4_hmac);\n                req.req_body.etypes.Add(Interop.KERB_ETYPE.rc4_hmac_exp);\n                req.req_body.etypes.Add(Interop.KERB_ETYPE.old_exp);\n            }\n            else\n            {\n                // add in the supported etype specified\n                req.req_body.etypes.Add(requestEType);\n            }\n\n            if (!String.IsNullOrEmpty(s4uUser))\n            {\n                // constrained delegation yo\'\n                if (u2u)\n                {\n                    req.req_body.kdcOptions = req.req_body.kdcOptions | Interop.KdcOptions.CANONICALIZE | Interop.KdcOptions.ENCTKTINSKEY | Interop.KdcOptions.FORWARDABLE | Interop.KdcOptions.RENEWABLE | Interop.KdcOptions.RENEWABLEOK;\n                    req.req_body.sname.name_string.Add(sname);\n                    req.req_body.sname.name_type = Interop.PRINCIPAL_TYPE.NT_UNKNOWN;\n                }\n                else\n                {\n                    req.req_body.sname.name_type = Interop.PRINCIPAL_TYPE.NT_PRINCIPAL;\n                    req.req_body.sname.name_string.Add(userName);\n                }\n\n                if (!opsec)\n                    req.req_body.kdcOptions = req.req_body.kdcOptions | Interop.KdcOptions.ENCTKTINSKEY;\n\n                if (opsec)\n                    req.req_body.etypes.Add(Interop.KERB_ETYPE.old_exp);\n            }\n            else if (u2u)\n            {\n                req.req_body.kdcOptions = req.req_body.kdcOptions | Interop.KdcOptions.CANONICALIZE | Interop.KdcOptions.ENCTKTINSKEY | Interop.KdcOptions.FORWARDABLE | Interop.KdcOptions.RENEWABLE | Interop.KdcOptions.RENEWABLEOK;\n                req.req_body.sname.name_string.Add(sname);\n                req.req_body.sname.name_type = Interop.PRINCIPAL_TYPE.NT_PRINCIPAL;\n            }\n            else\n            {\n                if (enterprise)\n                {\n                    // KRB_NT-ENTERPRISE = 10\n                    //      userPrincipalName\n                    //      sAMAccountName\n                    //      sAMAccountName@DomainNetBIOSName\n                    //      sAMAccountName@DomainFQDN\n                    //      DomainNetBIOSName\\sAMAccountName\n                    //      DomainFQDN\\sAMAccountName\n                    req.req_body.sname.name_type = Interop.PRINCIPAL_TYPE.NT_ENTERPRISE;\n                    req.req_body.sname.name_string.Add(sname);\n                    req.req_body.kdcOptions = req.req_body.kdcOptions | Interop.KdcOptions.CANONICALIZE;\n                }\n                else if (parts.Length == 1)\n                {\n                    // KRB_NT_SRV_INST = 2\n                    //      service and other unique instance (e.g. krbtgt)\n                    req.req_body.sname.name_type = Interop.PRINCIPAL_TYPE.NT_SRV_INST;\n                    req.req_body.sname.name_string.Add(sname);\n                    req.req_body.sname.name_string.Add(domain);\n                }\n                else if (parts.Length == 2)\n                {\n                    // KRB_NT_SRV_INST = 2\n                    //      SPN (sname/server.domain.com)\n                    req.req_body.sname.name_type = Interop.PRINCIPAL_TYPE.NT_SRV_INST;\n                    req.req_body.sname.name_string.Add(parts[0]);\n                    req.req_body.sname.name_string.Add(parts[1]);\n                }\n                else if (parts.Length == 3)\n                {\n                    // KRB_NT_SRV_HST = 3\n                    //      SPN (sname/server.domain.com/blah)\n                    req.req_body.sname.name_type = Interop.PRINCIPAL_TYPE.NT_SRV_HST;\n                    req.req_body.sname.name_string.Add(parts[0]);\n                    req.req_body.sname.name_string.Add(parts[1]);\n                    req.req_body.sname.name_string.Add(parts[2]);\n                }\n                else\n                {\n                    Console.WriteLine("[X] Error: invalid TGS_REQ sname \'{0}\'", sname);\n                }\n            }\n\n            if (renew)\n            {\n                req.req_body.kdcOptions = req.req_body.kdcOptions | Interop.KdcOptions.RENEW;\n            }\n\n            if (tgs!=null)\n            {\n                req.req_body.additional_tickets.Add(tgs.tickets[0]);\n                if (!u2u)\n                {\n                    req.req_body.kdcOptions = req.req_body.kdcOptions | Interop.KdcOptions.CONSTRAINED_DELEGATION | Interop.KdcOptions.CANONICALIZE;\n                    req.req_body.kdcOptions = req.req_body.kdcOptions & ~Interop.KdcOptions.RENEWABLEOK;\n                }\n            }\n\n            // needed for authenticator checksum\n            byte[] cksum_Bytes = null;\n\n            // opsec complete the request body before the creation of the AP-REQ\n            if (opsec)\n            {\n                // set correct flags based on type of request\n                req.req_body.kdcOptions = req.req_body.kdcOptions | Interop.KdcOptions.CANONICALIZE;\n                if (!unconstrained)\n                    req.req_body.kdcOptions = req.req_body.kdcOptions & ~Interop.KdcOptions.RENEWABLEOK;\n                if (unconstrained)\n                    req.req_body.kdcOptions = req.req_body.kdcOptions | Interop.KdcOptions.FORWARDED;\n\n                // get hostname and hostname of SPN\n                string hostName = Dns.GetHostName().ToUpper();\n                string targetHostName;\n                if (parts.Length > 1)\n                {\n                    targetHostName = parts[1].Substring(0, parts[1].IndexOf(\'.\')).ToUpper();\n                }\n                else\n                {\n                    targetHostName = hostName;\n                }\n\n                // create enc-authorization-data if target host is not the local machine\n                if ((hostName != targetHostName) && String.IsNullOrEmpty(s4uUser) && (!unconstrained))\n                {\n                    ADIfRelevant ifrelevant = new ADIfRelevant();\n                    ADRestrictionEntry restrictions = new ADRestrictionEntry();\n                    ADKerbLocal kerbLocal = new ADKerbLocal();\n                    ifrelevant.ADData.Add(restrictions);\n                    ifrelevant.ADData.Add(kerbLocal);\n                    AsnElt authDataSeq = ifrelevant.Encode();\n                    authDataSeq = AsnElt.Make(AsnElt.SEQUENCE, authDataSeq);\n                    byte[] authorizationDataBytes = authDataSeq.Encode();\n                    byte[] enc_authorization_data = Crypto.KerberosEncrypt(paEType, Interop.KRB_KEY_USAGE_TGS_REQ_ENC_AUTHOIRZATION_DATA, clientKey, authorizationDataBytes);\n                    req.req_body.enc_authorization_data = new EncryptedData((Int32)paEType, enc_authorization_data);\n                }\n\n                // S4U requests have a till time of 15 minutes in the future\n                if (!String.IsNullOrEmpty(s4uUser))\n                {\n                    DateTime till = DateTime.Now;\n                    till = till.AddMinutes(15);\n                    req.req_body.till = till;\n                }\n\n                // encode req_body for authenticator cksum\n                AsnElt req_Body_ASN = req.req_body.Encode();\n                AsnElt req_Body_ASNSeq = AsnElt.Make(AsnElt.SEQUENCE, new[] { req_Body_ASN });\n                req_Body_ASNSeq = AsnElt.MakeImplicit(AsnElt.CONTEXT, 4, req_Body_ASNSeq);\n                byte[] req_Body_Bytes = req_Body_ASNSeq.CopyValue();\n                cksum_Bytes = Crypto.KerberosChecksum(clientKey, req_Body_Bytes, Interop.KERB_CHECKSUM_ALGORITHM.KERB_CHECKSUM_RSA_MD5);\n            }\n\n            // create the PA-DATA that contains the AP-REQ w/ appropriate authenticator/etc.\n            PA_DATA padata = new PA_DATA(domain, userName, providedTicket, clientKey, paEType, opsec, cksum_Bytes);\n            req.padata.Add(padata);\n\n\n            // moved so all PA-DATA sections are inserted after the request body has been completed, this is useful when\n            // forming opsec requests as they require a checksum of the request body within the authenticator and the \n            // PADATA-TGS-REQ should go before the other PA-DATA sections\n            if (opsec && (!String.IsNullOrEmpty(s4uUser)))\n            {\n                // real packets seem to lowercase the domain in these 2 PA_DATA\'s\n                domain = domain.ToLower();\n\n                // PA_S4U_X509_USER commented out until we get the checksum working\n                PA_DATA s4upadata = new PA_DATA(clientKey, s4uUser, domain, req.req_body.nonce, paEType);\n                req.padata.Add(s4upadata);\n            }\n\n            // add final S4U PA-DATA\n            if (!String.IsNullOrEmpty(s4uUser))\n            {\n                // constrained delegation yo\'\n                PA_DATA s4upadata = new PA_DATA(clientKey, s4uUser, domain);\n                req.padata.Add(s4upadata);\n            }\n            else if (opsec)\n            {\n                PA_DATA padataoptions = new PA_DATA(false, true, false, false);\n                req.padata.Add(padataoptions);\n            }\n            else if ((tgs != null) && !u2u)\n            {\n                PA_DATA pac_options = new PA_DATA(false, false, false, true);\n                req.padata.Add(pac_options);\n            }\n\n            return req.Encode().Encode();\n        }\n\n        // To request a TGS for a foreign KRBTGT, requires 2 different domains\n        public static byte[] NewTGSReq(string userName, string domain, string targetDomain, Ticket providedTicket, byte[] clientKey, Interop.KERB_ETYPE paEType, Interop.KERB_ETYPE requestEType)\n        {\n            // foreign domain "TGT" request\n            TGS_REQ req = new TGS_REQ(cname: false);\n\n            // create the PA-DATA that contains the AP-REQ w/ appropriate authenticator/etc.\n            PA_DATA padata = new PA_DATA(domain, userName, providedTicket, clientKey, paEType);\n            req.padata.Add(padata);\n\n            req.req_body.realm = domain;\n\n            // add in our encryption types\n            if (requestEType == Interop.KERB_ETYPE.subkey_keymaterial)\n            {\n                // normal behavior\n                req.req_body.etypes.Add(Interop.KERB_ETYPE.aes256_cts_hmac_sha1);\n                req.req_body.etypes.Add(Interop.KERB_ETYPE.aes128_cts_hmac_sha1);\n                req.req_body.etypes.Add(Interop.KERB_ETYPE.rc4_hmac);\n                req.req_body.etypes.Add(Interop.KERB_ETYPE.rc4_hmac_exp);\n                //req.req_body.etypes.Add(Interop.KERB_ETYPE.des_cbc_crc);\n            }\n            else\n            {\n                // add in the supported etype specified\n                req.req_body.etypes.Add(requestEType);\n            }\n\n            PA_DATA padataoptions = new PA_DATA(false, true, false, false);\n            req.padata.Add(padataoptions);\n\n            req.req_body.sname.name_type = Interop.PRINCIPAL_TYPE.NT_SRV_INST;\n            req.req_body.sname.name_string.Add("krbtgt");\n            req.req_body.sname.name_string.Add(targetDomain);\n\n            req.req_body.kdcOptions = req.req_body.kdcOptions | Interop.KdcOptions.CANONICALIZE | Interop.KdcOptions.FORWARDABLE;\n            req.req_body.kdcOptions = req.req_body.kdcOptions & ~Interop.KdcOptions.RENEWABLEOK & ~Interop.KdcOptions.RENEW;\n\n            return req.Encode().Encode();\n        }\n\n        // maybe the function above can be combined with this one?\n        public static byte[] NewTGSReq(string userName, string targetUser, Ticket providedTicket, byte[] clientKey, Interop.KERB_ETYPE paEType, Interop.KERB_ETYPE requestEType, bool cross = true, string requestDomain = "")\n        {\n            // cross domain "S4U2Self" requests\n            TGS_REQ req = new TGS_REQ(cname: false);\n\n            // get domains\n            string domain = userName.Split(\'@\')[1];\n            string targetDomain = targetUser.Split(\'@\')[1];\n\n            // create the PA-DATA that contains the AP-REQ w/ appropriate authenticator/etc.\n            PA_DATA padata = new PA_DATA(domain, userName.Split(\'@\')[0], providedTicket, clientKey, paEType);\n            req.padata.Add(padata);\n\n            // which domain is the "local" domain for this TGS\n            if (cross)\n            {\n                if (String.IsNullOrEmpty(requestDomain))\n                    requestDomain = targetDomain;\n\n                req.req_body.realm = requestDomain;\n            }\n            else\n            {\n                req.req_body.realm = domain;\n            }\n\n            // add in our encryption types\n            if (requestEType == Interop.KERB_ETYPE.subkey_keymaterial)\n            {\n                // normal behavior\n                req.req_body.etypes.Add(Interop.KERB_ETYPE.aes256_cts_hmac_sha1);\n                req.req_body.etypes.Add(Interop.KERB_ETYPE.aes128_cts_hmac_sha1);\n                req.req_body.etypes.Add(Interop.KERB_ETYPE.rc4_hmac);\n                req.req_body.etypes.Add(Interop.KERB_ETYPE.rc4_hmac_exp);\n                //req.req_body.etypes.Add(Interop.KERB_ETYPE.des_cbc_crc);\n            }\n            else\n            {\n                // add in the supported etype specified\n                req.req_body.etypes.Add(requestEType);\n            }\n\n            PA_DATA s4upadata = new PA_DATA(clientKey, targetUser, targetDomain);\n            req.padata.Add(s4upadata);\n\n            req.req_body.sname.name_type = Interop.PRINCIPAL_TYPE.NT_ENTERPRISE;\n            req.req_body.sname.name_string.Add(userName);\n\n            req.req_body.kdcOptions = req.req_body.kdcOptions | Interop.KdcOptions.CANONICALIZE | Interop.KdcOptions.FORWARDABLE;\n            req.req_body.kdcOptions = req.req_body.kdcOptions & ~Interop.KdcOptions.RENEWABLEOK & ~Interop.KdcOptions.RENEW;\n\n            return req.Encode().Encode();\n        }\n\n        public static byte[] NewTGSReq(byte[] kirbi)\n        {\n            // take a supplied .kirbi TGT cred and build a TGS_REQ\n\n            return null;\n        }\n\n        \n        public TGS_REQ(bool cname = true)\n        {\n            // default, for creation\n            pvno = 5;\n\n            // msg-type        [2] INTEGER (12 -- TGS)\n            msg_type = (long)Interop.KERB_MESSAGE_TYPE.TGS_REQ;\n\n            padata = new List<PA_DATA>();\n\n            // added ability to remove cname from TGS request\n            // seemed to be useful for cross domain stuff\n            // didn\'t see a cname in "real" S4U request traffic\n            req_body = new KDCReqBody(c: cname);\n        }\n\n        public AsnElt Encode()\n        {\n            // pvno            [1] INTEGER (5)\n            AsnElt pvnoAsn = AsnElt.MakeInteger(pvno);\n            AsnElt pvnoSeq = AsnElt.Make(AsnElt.SEQUENCE, new[] { pvnoAsn });\n            pvnoSeq = AsnElt.MakeImplicit(AsnElt.CONTEXT, 1, pvnoSeq);\n\n\n            // msg-type        [2] INTEGER (12 -- TGS -- )\n            AsnElt msg_type_ASN = AsnElt.MakeInteger(msg_type);\n            AsnElt msg_type_ASNSeq = AsnElt.Make(AsnElt.SEQUENCE, new[] { msg_type_ASN });\n            msg_type_ASNSeq = AsnElt.MakeImplicit(AsnElt.CONTEXT, 2, msg_type_ASNSeq);\n\n\n            // padata          [3] SEQUENCE OF PA-DATA OPTIONAL\n            List<AsnElt> padatas = new List<AsnElt>();\n            foreach (PA_DATA pa in padata)\n            {\n                padatas.Add(pa.Encode());\n            }\n            AsnElt padata_ASNSeq = AsnElt.Make(AsnElt.SEQUENCE, padatas.ToArray());\n            AsnElt padata_ASNSeq2 = AsnElt.Make(AsnElt.SEQUENCE, new[] { padata_ASNSeq });\n            padata_ASNSeq = AsnElt.MakeImplicit(AsnElt.CONTEXT, 3, padata_ASNSeq2);\n            \n\n            // req-body        [4] KDC-REQ-BODY\n            AsnElt req_Body_ASN = req_body.Encode();\n            AsnElt req_Body_ASNSeq = AsnElt.Make(AsnElt.SEQUENCE, new[] { req_Body_ASN });\n            req_Body_ASNSeq = AsnElt.MakeImplicit(AsnElt.CONTEXT, 4, req_Body_ASNSeq);\n\n\n            // encode it all into a sequence\n            AsnElt[] total = new[] { pvnoSeq, msg_type_ASNSeq, padata_ASNSeq, req_Body_ASNSeq };\n            AsnElt seq = AsnElt.Make(AsnElt.SEQUENCE, total);\n\n            // TGS-REQ         ::= [APPLICATION 12] KDC-REQ\n            //  put it all together and tag it with 10\n            AsnElt totalSeq = AsnElt.Make(AsnElt.SEQUENCE, new[] { seq });\n            totalSeq = AsnElt.MakeImplicit(AsnElt.APPLICATION, 12, totalSeq);\n\n            return totalSeq;\n        }\n\n        public long pvno { get; set; }\n\n        public long msg_type { get; set; }\n\n        public List<PA_DATA> padata { get; set; }\n\n        public KDCReqBody req_body { get; set; }\n    }\n}\n'