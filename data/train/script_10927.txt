b'module System.Nix.Base32 (encode) where\n\n-- Copied from hnix-store-core until there\'s a new release\n\nimport qualified Data.ByteString as BS\nimport qualified Data.Text as T\nimport qualified Data.Vector as V\nimport Protolude\n\n-- | Encode a \'BS.ByteString\' in Nix\'s base32 encoding\nencode :: BS.ByteString -> T.Text\nencode c = T.pack $ map char32 [nChar - 1, nChar - 2 .. 0]\n  where\n    digits32 = V.fromList "0123456789abcdfghijklmnpqrsvwxyz"\n    -- Each base32 character gives us 5 bits of information, while\n    -- each byte gives is 8. Because \'div\' rounds down, we need to add\n    -- one extra character to the result, and because of that extra 1\n    -- we need to subtract one from the number of bits in the\n    -- bytestring to cover for the case where the number of bits is\n    -- already a factor of 5. Thus, the + 1 outside of the \'div\' and\n    -- the - 1 inside of it.\n    nChar = fromIntegral $ ((BS.length c * 8 - 1) `div` 5) + 1\n    byte = BS.index c . fromIntegral\n    -- May need to switch to a more efficient calculation at some\n    -- point.\n    bAsInteger :: Integer\n    bAsInteger =\n      sum\n        [ fromIntegral (byte j) * (256 ^ j)\n          | j <- [0 .. BS.length c - 1]\n        ]\n    char32 :: Integer -> Char\n    char32 i = digits32 V.! digitInd\n      where\n        digitInd =\n          fromIntegral $\n            bAsInteger\n              `div` (32 ^ i)\n              `mod` 32\n'