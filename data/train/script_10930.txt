b'using System;\nusing System.Diagnostics;\n\nusing u8 = System.Byte;\nusing u32 = System.UInt32;\n\nnamespace CS_SQLite3\n{\n  using sqlite3_value = CSSQLite.Mem;\n\n  public partial class CSSQLite\n  {\n    /*\n    ** 2001 September 15\n    **\n    ** The author disclaims copyright to this source code.  In place of\n    ** a legal notice, here is a blessing:\n    **\n    **    May you do good and not evil.\n    **    May you find forgiveness for yourself and forgive others.\n    **    May you share freely, never taking more than you give.\n    **\n    *************************************************************************\n    ** This file contains C code routines that are called by the parser\n    ** to handle UPDATE statements.\n    **\n    ** $Id: update.c,v 1.207 2009/08/08 18:01:08 drh Exp $\n    **\n    *************************************************************************\n    **  Included in SQLite3 port to C#-SQLite;  2008 Noah B Hart\n    **  C#-SQLite is an independent reimplementation of the SQLite software library\n    **\n    **  $Header$\n    *************************************************************************\n    */\n    //#include "sqliteInt.h"\n\n#if !SQLITE_OMIT_VIRTUALTABLE\n/* Forward declaration */\n//static void updateVirtualTable(\n//Parse pParse,       /* The parsing context */\n//SrcList pSrc,       /* The virtual table to be modified */\n//Table pTab,         /* The virtual table */\n//ExprList pChanges,  /* The columns to change in the UPDATE statement */\n//Expr pRowidExpr,    /* Expression used to recompute the rowid */\n//int aXRef,          /* Mapping from columns of pTab to entries in pChanges */\n//Expr pWhere         /* WHERE clause of the UPDATE statement */\n//);\n#endif // * SQLITE_OMIT_VIRTUALTABLE */\n\n    /*\n** The most recently coded instruction was an OP_Column to retrieve the\n** i-th column of table pTab. This routine sets the P4 parameter of the\n** OP_Column to the default value, if any.\n**\n** The default value of a column is specified by a DEFAULT clause in the\n** column definition. This was either supplied by the user when the table\n** was created, or added later to the table definition by an ALTER TABLE\n** command. If the latter, then the row-records in the table btree on disk\n** may not contain a value for the column and the default value, taken\n** from the P4 parameter of the OP_Column instruction, is returned instead.\n** If the former, then all row-records are guaranteed to include a value\n** for the column and the P4 value is not required.\n**\n** Column definitions created by an ALTER TABLE command may only have\n** literal default values specified: a number, null or a string. (If a more\n** complicated default expression value was provided, it is evaluated\n** when the ALTER TABLE is executed and one of the literal values written\n** into the sqlite_master table.)\n**\n** Therefore, the P4 parameter is only required if the default value for\n** the column is a literal number, string or null. The sqlite3ValueFromExpr()\n** function is capable of transforming these types of expressions into\n** sqlite3_value objects.\n**\n** If parameter iReg is not negative, code an OP_RealAffinity instruction\n** on register iReg. This is used when an equivalent integer value is\n** stored in place of an 8-byte floating point value in order to save\n** space.\n*/\n    static void sqlite3ColumnDefault( Vdbe v, Table pTab, int i, int iReg )\n    {\n      Debug.Assert( pTab != null );\n      if ( null == pTab.pSelect )\n      {\n        sqlite3_value pValue = new sqlite3_value();\n        int enc = ENC( sqlite3VdbeDb( v ) );\n        Column pCol = pTab.aCol[i];\n#if SQLITE_DEBUG\n        VdbeComment( v, "%s.%s", pTab.zName, pCol.zName );\n#endif\n        Debug.Assert( i < pTab.nCol );\n        sqlite3ValueFromExpr( sqlite3VdbeDb( v ), pCol.pDflt, enc,\n        pCol.affinity, ref pValue );\n        if ( pValue != null )\n        {\n          sqlite3VdbeChangeP4( v, -1, pValue, P4_MEM );\n        }\n#if !SQLITE_OMIT_FLOATING_POINT\n        if ( iReg >= 0 && pTab.aCol[i].affinity == SQLITE_AFF_REAL )\n        {\n          sqlite3VdbeAddOp1( v, OP_RealAffinity, iReg );\n        }\n#endif\n      }\n    }\n\n    /*\n    ** Process an UPDATE statement.\n    **\n    **   UPDATE OR IGNORE table_wxyz SET a=b, c=d WHERE e<5 AND f NOT NULL;\n    **          \\_______/ \\________/     \\______/       \\________________/\n    *            onError   pTabList      pChanges             pWhere\n    */\n    static void sqlite3Update(\n    Parse pParse,         /* The parser context */\n    SrcList pTabList,     /* The table in which we should change things */\n    ExprList pChanges,    /* Things to be changed */\n    Expr pWhere,          /* The WHERE clause.  May be null */\n    int onError           /* How to handle constraint errors */\n    )\n    {\n      int i, j;                   /* Loop counters */\n      Table pTab;                 /* The table to be updated */\n      int addr = 0;               /* VDBE instruction address of the start of the loop */\n      WhereInfo pWInfo;           /* Information about the WHERE clause */\n      Vdbe v;                     /* The virtual database engine */\n      Index pIdx;                 /* For looping over indices */\n      int nIdx;                   /* Number of indices that need updating */\n      int iCur;                   /* VDBE Cursor number of pTab */\n      sqlite3 db;                 /* The database structure */\n      int[] aRegIdx = null;       /* One register assigned to each index to be updated */\n      int[] aXRef = null;         /* aXRef[i] is the index in pChanges.a[] of the\n** an expression for the i-th column of the table.\n** aXRef[i]==-1 if the i-th column is not changed. */\n      bool chngRowid;             /* True if the record number is being changed */\n      Expr pRowidExpr = null;     /* Expression defining the new record number */\n      bool openAll = false;       /* True if all indices need to be opened */\n      AuthContext sContext;       /* The authorization context */\n      NameContext sNC;            /* The name-context to resolve expressions in */\n      int iDb;                    /* Database containing the table being updated */\n      int j1;                     /* Addresses of jump instructions */\n      u8 okOnePass;               /* True for one-pass algorithm without the FIFO */\n\n#if !SQLITE_OMIT_TRIGGER\n      bool isView = false;         /* Trying to update a view */\n      Trigger pTrigger;            /* List of triggers on pTab, if required */\n#endif\n      int iBeginAfterTrigger = 0;  /* Address of after trigger program */\n      int iEndAfterTrigger = 0;    /* Exit of after trigger program */\n      int iBeginBeforeTrigger = 0; /* Address of before trigger program */\n      int iEndBeforeTrigger = 0;   /* Exit of before trigger program */\n      u32 old_col_mask = 0;        /* Mask of OLD.* columns in use */\n      u32 new_col_mask = 0;        /* Mask of NEW.* columns in use */\n\n      int newIdx = -1;             /* index of trigger "new" temp table       */\n      int oldIdx = -1;             /* index of trigger "old" temp table       */\n\n      /* Register Allocations */\n      int regRowCount = 0;         /* A count of rows changed */\n      int regOldRowid;             /* The old rowid */\n      int regNewRowid;             /* The new rowid */\n      int regData;                 /* New data for the row */\n      int regRowSet = 0;           /* Rowset of rows to be updated */\n\n      sContext = new AuthContext(); //memset( &sContext, 0, sizeof( sContext ) );\n      db = pParse.db;\n      if ( pParse.nErr != 0 /*|| db.mallocFailed != 0 */ )\n      {\n        goto update_cleanup;\n      }\n      Debug.Assert( pTabList.nSrc == 1 );\n\n      /* Locate the table which we want to update.\n      */\n      pTab = sqlite3SrcListLookup( pParse, pTabList );\n      if ( pTab == null ) goto update_cleanup;\n      iDb = sqlite3SchemaToIndex( pParse.db, pTab.pSchema );\n\n      /* Figure out if we have any triggers and if the table being\n      ** updated is a view\n      */\n#if !SQLITE_OMIT_TRIGGER\n      int iDummy = 0;\n      pTrigger = sqlite3TriggersExist( pParse, pTab, TK_UPDATE, pChanges, ref iDummy );\n      isView = pTab.pSelect != null;\n#else\nconst Trigger pTrigger = null;\n#if !SQLITE_OMIT_VIEW\nconst bool isView = false;\n#endif\n#endif\n#if SQLITE_OMIT_VIEW\n//    # undef isView\nconst bool isView = false;\n#endif\n\n      if ( sqlite3ViewGetColumnNames( pParse, pTab ) != 0 )\n      {\n        goto update_cleanup;\n      }\n      if ( sqlite3IsReadOnly( pParse, pTab, ( pTrigger != null ? 1 : 0 ) ) )\n      {\n        goto update_cleanup;\n      }\n      aXRef = new int[pTab.nCol];// sqlite3DbMallocRaw(db, sizeof(int) * pTab.nCol);\n      //if ( aXRef == null ) goto update_cleanup;\n      for ( i = 0 ; i < pTab.nCol ; i++ ) aXRef[i] = -1;\n\n      /* If there are FOR EACH ROW triggers, allocate cursors for the\n      ** special OLD and NEW tables\n      */\n      if ( pTrigger != null )\n      {\n        newIdx = pParse.nTab++;\n        oldIdx = pParse.nTab++;\n      }\n\n      /* Allocate a cursors for the main database table and for all indices.\n      ** The index cursors might not be used, but if they are used they\n      ** need to occur right after the database cursor.  So go ahead and\n      ** allocate enough space, just in case.\n      */\n      pTabList.a[0].iCursor = iCur = pParse.nTab++;\n      for ( pIdx = pTab.pIndex ; pIdx != null ; pIdx = pIdx.pNext )\n      {\n        pParse.nTab++;\n      }\n\n      /* Initialize the name-context */\n      sNC = new NameContext();// memset(&sNC, 0, sNC).Length;\n      sNC.pParse = pParse;\n      sNC.pSrcList = pTabList;\n\n      /* Resolve the column names in all the expressions of the\n      ** of the UPDATE statement.  Also find the column index\n      ** for each column to be updated in the pChanges array.  For each\n      ** column to be updated, make sure we have authorization to change\n      ** that column.\n      */\n      chngRowid = false;\n      for ( i = 0 ; i < pChanges.nExpr ; i++ )\n      {\n        if ( sqlite3ResolveExprNames( sNC, ref pChanges.a[i].pExpr ) != 0 )\n        {\n          goto update_cleanup;\n        }\n        for ( j = 0 ; j < pTab.nCol ; j++ )\n        {\n          if ( sqlite3StrICmp( pTab.aCol[j].zName, pChanges.a[i].zName ) == 0 )\n          {\n            if ( j == pTab.iPKey )\n            {\n              chngRowid = true;\n              pRowidExpr = pChanges.a[i].pExpr;\n            }\n            aXRef[j] = i;\n            break;\n          }\n        }\n        if ( j >= pTab.nCol )\n        {\n          if ( sqlite3IsRowid( pChanges.a[i].zName ) )\n          {\n            chngRowid = true;\n            pRowidExpr = pChanges.a[i].pExpr;\n          }\n          else\n          {\n            sqlite3ErrorMsg( pParse, "no such column: %s", pChanges.a[i].zName );\n            goto update_cleanup;\n          }\n        }\n#if !SQLITE_OMIT_AUTHORIZATION\n{\nint rc;\nrc = sqlite3AuthCheck(pParse, SQLITE_UPDATE, pTab.zName,\npTab.aCol[j].zName, db.aDb[iDb].zName);\nif( rc==SQLITE_DENY ){\ngoto update_cleanup;\n}else if( rc==SQLITE_IGNORE ){\naXRef[j] = -1;\n}\n}\n#endif\n      }\n\n      /* Allocate memory for the array aRegIdx[].  There is one entry in the\n      ** array for each index associated with table being updated.  Fill in\n      ** the value with a register number for indices that are to be used\n      ** and with zero for unused indices.\n      */\n      for ( nIdx = 0, pIdx = pTab.pIndex ; pIdx != null ; pIdx = pIdx.pNext, nIdx++ ) { }\n      if ( nIdx > 0 )\n      {\n        aRegIdx = new int[nIdx]; // sqlite3DbMallocRaw(db, Index*.Length * nIdx);\n        if ( aRegIdx == null ) goto update_cleanup;\n      }\n      for ( j = 0, pIdx = pTab.pIndex ; pIdx != null ; pIdx = pIdx.pNext, j++ )\n      {\n        int reg;\n        if ( chngRowid )\n        {\n          reg = ++pParse.nMem;\n        }\n        else\n        {\n          reg = 0;\n          for ( i = 0 ; i < pIdx.nColumn ; i++ )\n          {\n            if ( aXRef[pIdx.aiColumn[i]] >= 0 )\n            {\n              reg = ++pParse.nMem;\n              break;\n            }\n          }\n        }\n        aRegIdx[j] = reg;\n      }\n\n      /* Allocate a block of register used to store the change record\n      ** sent to sqlite3GenerateConstraintChecks().  There are either\n      ** one or two registers for holding the rowid.  One rowid register\n      ** is used if chngRowid is false and two are used if chngRowid is\n      ** true.  Following these are pTab.nCol register holding column\n      ** data.\n      */\n      regOldRowid = regNewRowid = pParse.nMem + 1;\n      pParse.nMem += pTab.nCol + 1;\n      if ( chngRowid )\n      {\n        regNewRowid++;\n        pParse.nMem++;\n      }\n      regData = regNewRowid + 1;\n\n\n      /* Begin generating code.\n      */\n      v = sqlite3GetVdbe( pParse );\n      if ( v == null ) goto update_cleanup;\n      if ( pParse.nested == 0 ) sqlite3VdbeCountChanges( v );\n      sqlite3BeginWriteOperation( pParse, 1, iDb );\n\n#if !SQLITE_OMIT_VIRTUALTABLE\n/* Virtual tables must be handled separately */\nif ( IsVirtual( pTab ) )\n{\nupdateVirtualTable( pParse, pTabList, pTab, pChanges, pRowidExpr, aXRef, pWhere );\npWhere = null;\npTabList = null;\ngoto update_cleanup;\n}\n#endif\n\n      /* Start the view context\n*/\n#if !SQLITE_OMIT_AUTHORIZATION\nif( isView ){\nsqlite3AuthContextPush(pParse, sContext, pTab.zName);\n}\n#endif\n      /* Generate the code for triggers.\n*/\n      if ( pTrigger != null )\n      {\n        int iGoto;\n\n        /* Create pseudo-tables for NEW and OLD\n        */\n        sqlite3VdbeAddOp3( v, OP_OpenPseudo, oldIdx, 0, pTab.nCol );\n        sqlite3VdbeAddOp3( v, OP_OpenPseudo, newIdx, 0, pTab.nCol );\n\n        iGoto = sqlite3VdbeAddOp2( v, OP_Goto, 0, 0 );\n        addr = sqlite3VdbeMakeLabel( v );\n        iBeginBeforeTrigger = sqlite3VdbeCurrentAddr( v );\n        if ( sqlite3CodeRowTrigger( pParse, pTrigger, TK_UPDATE, pChanges,\n        TRIGGER_BEFORE, pTab, newIdx, oldIdx, onError, addr,\n        ref old_col_mask, ref new_col_mask ) != 0 )\n        {\n          goto update_cleanup;\n        }\n        iEndBeforeTrigger = sqlite3VdbeAddOp2( v, OP_Goto, 0, 0 );\n        iBeginAfterTrigger = sqlite3VdbeCurrentAddr( v );\n#if !SQLITE_OMIT_TRIGGER\n        if ( sqlite3CodeRowTrigger( pParse, pTrigger, TK_UPDATE, pChanges, TRIGGER_AFTER, pTab,\n        newIdx, oldIdx, onError, addr, ref old_col_mask, ref new_col_mask ) != 0 )\n        {\n          goto update_cleanup;\n        }\n#endif\n        iEndAfterTrigger = sqlite3VdbeAddOp2( v, OP_Goto, 0, 0 );\n        sqlite3VdbeJumpHere( v, iGoto );\n      }\n\n      /* If we are trying to update a view, realize that view into\n      ** a ephemeral table.\n      */\n#if !(SQLITE_OMIT_VIEW) && !(SQLITE_OMIT_TRIGGER)\n      if ( isView )\n      {\n        sqlite3MaterializeView( pParse, pTab, pWhere, iCur );\n      }\n#endif\n\n      /* Resolve the column names in all the expressions in the\n** WHERE clause.\n*/\n      if ( sqlite3ResolveExprNames( sNC, ref pWhere ) != 0 )\n      {\n        goto update_cleanup;\n      }\n\n      /* Begin the database scan\n      */\n      sqlite3VdbeAddOp2( v, OP_Null, 0, regOldRowid );\n      ExprList NullOrderby = null;\n      pWInfo = sqlite3WhereBegin( pParse, pTabList, pWhere, ref NullOrderby, WHERE_ONEPASS_DESIRED );\n      if ( pWInfo == null ) goto update_cleanup;\n      okOnePass = pWInfo.okOnePass;\n\n      /* Remember the rowid of every item to be updated.\n      */\n      sqlite3VdbeAddOp2( v, OP_Rowid, iCur, regOldRowid );\n      if ( 0 == okOnePass )\n      {\n        regRowSet = ++pParse.nMem;\n        sqlite3VdbeAddOp2( v, OP_RowSetAdd, regRowSet, regOldRowid );\n      }\n\n      /* End the database scan loop.\n      */\n      sqlite3WhereEnd( pWInfo );\n\n      /* Initialize the count of updated rows\n      */\n      if ( ( db.flags & SQLITE_CountRows ) != 0 && pParse.trigStack == null )\n      {\n        regRowCount = ++pParse.nMem;\n        sqlite3VdbeAddOp2( v, OP_Integer, 0, regRowCount );\n      }\n\n      if ( !isView )\n      {\n        /*\n        ** Open every index that needs updating.  Note that if any\n        ** index could potentially invoke a REPLACE conflict resolution\n        ** action, then we need to open all indices because we might need\n        ** to be deleting some records.\n        */\n        if ( 0 == okOnePass ) sqlite3OpenTable( pParse, iCur, iDb, pTab, OP_OpenWrite );\n        if ( onError == OE_Replace )\n        {\n          openAll = true;\n        }\n        else\n        {\n          openAll = false;\n          for ( pIdx = pTab.pIndex ; pIdx != null ; pIdx = pIdx.pNext )\n          {\n            if ( pIdx.onError == OE_Replace )\n            {\n              openAll = true;\n              break;\n            }\n          }\n        }\n        for ( i = 0, pIdx = pTab.pIndex ; pIdx != null ; pIdx = pIdx.pNext, i++ )\n        {\n          if ( openAll || aRegIdx[i] > 0 )\n          {\n            KeyInfo pKey = sqlite3IndexKeyinfo( pParse, pIdx );\n            sqlite3VdbeAddOp4( v, OP_OpenWrite, iCur + i + 1, pIdx.tnum, iDb,\n            pKey, P4_KEYINFO_HANDOFF );\n            Debug.Assert( pParse.nTab > iCur + i + 1 );\n          }\n        }\n      }\n\n      /* Jump back to this point if a trigger encounters an IGNORE constraint. */\n      if ( pTrigger != null )\n      {\n        sqlite3VdbeResolveLabel( v, addr );\n      }\n\n      /* Top of the update loop */\n      if ( okOnePass != 0 )\n      {\n        int a1 = sqlite3VdbeAddOp1( v, OP_NotNull, regOldRowid );\n        addr = sqlite3VdbeAddOp0( v, OP_Goto );\n        sqlite3VdbeJumpHere( v, a1 );\n      }\n      else\n      {\n        addr = sqlite3VdbeAddOp3( v, OP_RowSetRead, regRowSet, 0, regOldRowid );\n      }\n\n      if ( pTrigger != null )\n      {\n        int regRowid;\n        int regRow;\n        int regCols;\n\n        /* Make cursor iCur point to the record that is being updated.\n        */\n        sqlite3VdbeAddOp3( v, OP_NotExists, iCur, addr, regOldRowid );\n\n        /* Generate the OLD table\n        */\n        regRowid = sqlite3GetTempReg( pParse );\n        regRow = sqlite3GetTempReg( pParse );\n        sqlite3VdbeAddOp2( v, OP_Rowid, iCur, regRowid );\n        if ( old_col_mask == 0 )\n        {\n          sqlite3VdbeAddOp2( v, OP_Null, 0, regRow );\n        }\n        else\n        {\n          sqlite3VdbeAddOp2( v, OP_RowData, iCur, regRow );\n        }\n        sqlite3VdbeAddOp3( v, OP_Insert, oldIdx, regRow, regRowid );\n\n        /* Generate the NEW table\n        */\n        if ( chngRowid )\n        {\n          sqlite3ExprCodeAndCache( pParse, pRowidExpr, regRowid );\n          sqlite3VdbeAddOp1( v, OP_MustBeInt, regRowid );\n        }\n        else\n        {\n          sqlite3VdbeAddOp2( v, OP_Rowid, iCur, regRowid );\n        }\n        regCols = sqlite3GetTempRange( pParse, pTab.nCol );\n        for ( i = 0 ; i < pTab.nCol ; i++ )\n        {\n          if ( i == pTab.iPKey )\n          {\n            sqlite3VdbeAddOp2( v, OP_Null, 0, regCols + i );\n            continue;\n          }\n          j = aXRef[i];\n          if ( ( i < 32 && ( new_col_mask & ( (u32)1 << i ) ) != 0 ) || new_col_mask == 0xffffffff )\n          {\n            if ( j < 0 )\n            {\n              sqlite3VdbeAddOp3( v, OP_Column, iCur, i, regCols + i );\n              sqlite3ColumnDefault( v, pTab, i, -1 );\n            }\n            else\n            {\n              sqlite3ExprCodeAndCache( pParse, pChanges.a[j].pExpr, regCols + i );\n            }\n          }\n          else\n          {\n            sqlite3VdbeAddOp2( v, OP_Null, 0, regCols + i );\n          }\n        }\n        sqlite3VdbeAddOp3( v, OP_MakeRecord, regCols, pTab.nCol, regRow );\n        if ( !isView )\n        {\n          sqlite3TableAffinityStr( v, pTab );\n          sqlite3ExprCacheAffinityChange( pParse, regCols, pTab.nCol );\n        }\n        sqlite3ReleaseTempRange( pParse, regCols, pTab.nCol );\n        /* if( pParse.nErr ) goto update_cleanup; */\n        sqlite3VdbeAddOp3( v, OP_Insert, newIdx, regRow, regRowid );\n        sqlite3ReleaseTempReg( pParse, regRowid );\n        sqlite3ReleaseTempReg( pParse, regRow );\n\n        sqlite3VdbeAddOp2( v, OP_Goto, 0, iBeginBeforeTrigger );\n        sqlite3VdbeJumpHere( v, iEndBeforeTrigger );\n      }\n\n      if ( !isView )\n      {\n\n        /* Loop over every record that needs updating.  We have to load\n        ** the old data for each record to be updated because some columns\n        ** might not change and we will need to copy the old value.\n        ** Also, the old data is needed to delete the old index entries.\n        ** So make the cursor point at the old record.\n        */\n        sqlite3VdbeAddOp3( v, OP_NotExists, iCur, addr, regOldRowid );\n\n        /* If the record number will change, push the record number as it\n        ** will be after the update. (The old record number is currently\n        ** on top of the stack.)\n        */\n        if ( chngRowid )\n        {\n          sqlite3ExprCode( pParse, pRowidExpr, regNewRowid );\n          sqlite3VdbeAddOp1( v, OP_MustBeInt, regNewRowid );\n        }\n\n        /* Compute new data for this record.\n        */\n        for ( i = 0 ; i < pTab.nCol ; i++ )\n        {\n          if ( i == pTab.iPKey )\n          {\n            sqlite3VdbeAddOp2( v, OP_Null, 0, regData + i );\n            continue;\n          }\n          j = aXRef[i];\n          if ( j < 0 )\n          {\n            sqlite3VdbeAddOp3( v, OP_Column, iCur, i, regData + i );\n            sqlite3ColumnDefault( v, pTab, i, regData + i );\n          }\n          else\n          {\n            sqlite3ExprCode( pParse, pChanges.a[j].pExpr, regData + i );\n          }\n        }\n\n        /* Do constraint checks\n        */\n        iDummy = 0;\n        sqlite3GenerateConstraintChecks( pParse, pTab, iCur, regNewRowid,\n           aRegIdx, chngRowid, true,\n           onError, addr, ref iDummy );\n\n        /* Delete the old indices for the current record.\n        */\n        j1 = sqlite3VdbeAddOp3( v, OP_NotExists, iCur, 0, regOldRowid );\n        sqlite3GenerateRowIndexDelete( pParse, pTab, iCur, aRegIdx );\n\n        /* If changing the record number, delete the old record.\n        */\n        if ( chngRowid )\n        {\n          sqlite3VdbeAddOp2( v, OP_Delete, iCur, 0 );\n        }\n        sqlite3VdbeJumpHere( v, j1 );\n\n        /* Create the new index entries and the new record.\n        */\n        sqlite3CompleteInsertion( pParse, pTab, iCur, regNewRowid,\n        aRegIdx, true, -1, false, false );\n      }\n\n      /* Increment the row counter\n      */\n      if ( ( db.flags & SQLITE_CountRows ) != 0 && pParse.trigStack == null )\n      {\n        sqlite3VdbeAddOp2( v, OP_AddImm, regRowCount, 1 );\n      }\n\n      /* If there are triggers, close all the cursors after each iteration\n      ** through the loop.  The fire the after triggers.\n      */\n      if ( pTrigger != null )\n      {\n        sqlite3VdbeAddOp2( v, OP_Goto, 0, iBeginAfterTrigger );\n        sqlite3VdbeJumpHere( v, iEndAfterTrigger );\n      }\n\n      /* Repeat the above with the next record to be updated, until\n      ** all record selected by the WHERE clause have been updated.\n      */\n      sqlite3VdbeAddOp2( v, OP_Goto, 0, addr );\n      sqlite3VdbeJumpHere( v, addr );\n\n      /* Close all tables */\n      for ( i = 0, pIdx = pTab.pIndex ; pIdx != null ; pIdx = pIdx.pNext, i++ )\n      {\n        if ( openAll || aRegIdx[i] > 0 )\n        {\n          sqlite3VdbeAddOp2( v, OP_Close, iCur + i + 1, 0 );\n        }\n      }\n      sqlite3VdbeAddOp2( v, OP_Close, iCur, 0 );\n      if ( pTrigger != null )\n      {\n        sqlite3VdbeAddOp2( v, OP_Close, newIdx, 0 );\n        sqlite3VdbeAddOp2( v, OP_Close, oldIdx, 0 );\n      }\n\n      /* Update the sqlite_sequence table by storing the content of the\n      ** maximum rowid counter values recorded while inserting into\n      ** autoincrement tables.\n      */\n      if ( pParse.nested == 0 && pParse.trigStack == null )\n      {\n        sqlite3AutoincrementEnd( pParse );\n      }\n\n      /*\n      ** Return the number of rows that were changed. If this routine is\n      ** generating code because of a call to sqlite3NestedParse(), do not\n      ** invoke the callback function.\n      */\n      if ( ( db.flags & SQLITE_CountRows ) != 0 && pParse.trigStack == null && pParse.nested == 0 )\n      {\n        sqlite3VdbeAddOp2( v, OP_ResultRow, regRowCount, 1 );\n        sqlite3VdbeSetNumCols( v, 1 );\n        sqlite3VdbeSetColName( v, 0, COLNAME_NAME, "rows updated", SQLITE_STATIC );\n      }\n\nupdate_cleanup:\n#if !SQLITE_OMIT_AUTHORIZATION\nsqlite3AuthContextPop(sContext);\n#endif\n      //sqlite3DbFree( db, ref  aRegIdx );\n      //sqlite3DbFree( db, ref  aXRef );\n      sqlite3SrcListDelete( db, ref pTabList );\n      sqlite3ExprListDelete( db, ref pChanges );\n      sqlite3ExprDelete( db, ref pWhere );\n      return;\n    }\n\n#if !SQLITE_OMIT_VIRTUALTABLE\n/*\n** Generate code for an UPDATE of a virtual table.\n**\n** The strategy is that we create an ephemerial table that contains\n** for each row to be changed:\n**\n**   (A)  The original rowid of that row.\n**   (B)  The revised rowid for the row. (note1)\n**   (C)  The content of every column in the row.\n**\n** Then we loop over this ephemeral table and for each row in\n** the ephermeral table call VUpdate.\n**\n** When finished, drop the ephemeral table.\n**\n** (note1) Actually, if we know in advance that (A) is always the same\n** as (B) we only store (A), then duplicate (A) when pulling\n** it out of the ephemeral table before calling VUpdate.\n*/\nstatic void updateVirtualTable(\nParse pParse,       /* The parsing context */\nSrcList pSrc,       /* The virtual table to be modified */\nTable pTab,         /* The virtual table */\nExprList pChanges,  /* The columns to change in the UPDATE statement */\nExpr pRowid,        /* Expression used to recompute the rowid */\nint aXRef,          /* Mapping from columns of pTab to entries in pChanges */\nExpr pWhere         /* WHERE clause of the UPDATE statement */\n)\n{\nVdbe v = pParse.pVdbe;  /* Virtual machine under construction */\nExprList pEList = 0;     /* The result set of the SELECT statement */\nSelect pSelect = 0;      /* The SELECT statement */\nExpr pExpr;              /* Temporary expression */\nint ephemTab;             /* Table holding the result of the SELECT */\nint i;                    /* Loop counter */\nint addr;                 /* Address of top of loop */\nint iReg;                 /* First register in set passed to OP_VUpdate */\nsqlite3 db = pParse.db; /* Database connection */\nconst char *pVTab = (const char*)sqlite3GetVTable(db, pTab);\nSelectDest dest;\n\n/* Construct the SELECT statement that will find the new values for\n** all updated rows.\n*/\npEList = sqlite3ExprListAppend(pParse, 0,\nsqlite3CreateIdExpr(pParse, "_rowid_"));\nif( pRowid ){\npEList = sqlite3ExprListAppend(pParse, pEList,\nsqlite3ExprDup(db, pRowid,0), 0);\n}\nDebug.Assert( pTab.iPKey<0 );\nfor(i=0; i<pTab.nCol; i++){\nif( aXRef[i]>=0 ){\npExpr = sqlite3ExprDup(db, pChanges.a[aXRef[i]].pExpr,0);\n}else{\npExpr = sqlite3CreateIdExpr(pParse, pTab.aCol[i].zName);\n}\npEList = sqlite3ExprListAppend(pParse, pEList, pExpr);\n}\npSelect = sqlite3SelectNew(pParse, pEList, pSrc, pWhere, 0, 0, 0, 0, 0, 0);\n\n/* Create the ephemeral table into which the update results will\n** be stored.\n*/\nDebug.Assert( v );\nephemTab = pParse.nTab++;\nsqlite3VdbeAddOp2(v, OP_OpenEphemeral, ephemTab, pTab.nCol+1+(pRowid!=0));\n\n/* fill the ephemeral table\n*/\nsqlite3SelectDestInit(dest, SRT_Table, ephemTab);\nsqlite3Select(pParse, pSelect, ref dest);\n\n/* Generate code to scan the ephemeral table and call VUpdate. */\niReg = ++pParse.nMem;\npParse.nMem += pTab.nCol+1;\naddr = sqlite3VdbeAddOp2(v, OP_Rewind, ephemTab, 0);\nsqlite3VdbeAddOp3(v, OP_Column,  ephemTab, 0, iReg);\nsqlite3VdbeAddOp3(v, OP_Column, ephemTab, (pRowid\n1:0), iReg+1);\nfor(i=0; i<pTab.nCol; i++){\nsqlite3VdbeAddOp3(v, OP_Column, ephemTab, i+1+(pRowid!=0), iReg+2+i);\n}\nsqlite3VtabMakeWritable(pParse, pTab);\nsqlite3VdbeAddOp4(v, OP_VUpdate, 0, pTab.nCol+2, iReg, pVTab, P4_VTAB);\nsqlite3VdbeAddOp2(v, OP_Next, ephemTab, addr+1);\nsqlite3VdbeJumpHere(v, addr);\nsqlite3VdbeAddOp2(v, OP_Close, ephemTab, 0);\n\n/* Cleanup */\nsqlite3SelectDelete(pSelect);\n}\n#endif // * SQLITE_OMIT_VIRTUALTABLE */\n\n    /* Make sure "isView" gets undefined in case this file becomes part of\n** the amalgamation - so that subsequent files do not see isView as a\n** macro. */\n    //#undef isView\n  }\n}\n'