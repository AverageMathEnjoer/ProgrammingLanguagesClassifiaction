b'{-# LANGUAGE Arrows #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n{-# LANGUAGE MultiWayIf #-}\nimport Data.MonadicStreamFunction\nimport Data.MonadicStreamFunction.Core (MSF (unMSF))\nimport Control.Monad.Trans.MSF\nimport Control.Monad.Trans.Class\nimport Data.Functor.Identity\n\ntype DTime = Double\n\ndata Event a = Event a | NoEvent\n\n-- * Synchronous time transformations\n\n-- | Transform the time domain in a synchronous, uni-directional way, applying\n-- a transformation that may depend on the past and on the input.\ntimeTransformMSF :: Monad m\n                 => MSF (ReaderT t1 m) a (t1 -> t2)\n                 -> MSF (ReaderT t2 m) a b\n                 -> MSF (ReaderT t1 m) a b\ntimeTransformMSF timeSF sf = MSF $ \\a -> do\n  (f, timeSF\') <- unMSF timeSF a\n  (b, sf\')     <- withReaderT f (unMSF sf a)\n  return (b, timeTransformMSF timeSF\' sf\')\n\n-- | Transform the time domain in a synchronous, uni-directional way, applying\n-- a point-wise (time-wise) pure transformation.\ntimeTransformF :: Monad m\n               => (t1 -> t2)\n               -> MSF (ReaderT t2 m) a b\n               -> MSF (ReaderT t1 m) a b\ntimeTransformF f = timeTransformMSF (constant f)\n\n-- | Run an MSF with a fixed time delta.\nrunAtFixedR :: Monad m => DTime -> MSF (ReaderT DTime m) a b -> MSF (ReaderT DTime m) a b\nrunAtFixedR dt = timeTransformF (const dt)\n\n-- | Run an MSF with a maximum time delta.\nrunAtMaxR :: Monad m => DTime -> MSF (ReaderT DTime m) a b ->  MSF (ReaderT DTime m) a b\nrunAtMaxR dt = timeTransformF (min dt)\n\n-- | Run an MSF with a minimum time delta.\nrunAtMinR :: Monad m => DTime -> MSF (ReaderT DTime m) a b -> MSF (ReaderT DTime m) a b\nrunAtMinR dt = timeTransformF (max dt)\n\n-- * Asynchronous time transformations\n\n-- ** Types\n\n-- | An asynchronous MSF that may product output even when there is no input.\ntype AsyncMSF m a b = MSF m (Maybe a) b\n\n-- type SelfClockingMSF m a b =\n--   MSF (WriterT (DTime, Bool) (ReaderT DTime m)) a b\n\n-- | An MSF with internal clocking information.\ntype SelfClockingMSF m a b =\n  MSF (StateT (DTime, Bool) (ReaderT DTime m)) a b\n\n-- ** Execution\n\n-- runAtFixedS :: b -> DTime -> MSF (ReaderT DTime m) a b -> SelfClockingMSF m a b\n-- runAtFixedS b dt msf = timeTransformF (const dt) msf\n--\n-- runAtMaxS :: DTime -> MSF (ReaderT DTime m) a b -> SelfClockingMSF m a b\n-- runAtMaxS dt msf = timeTransformF (min dt) msf\n--\n-- runAtMinS :: DTime -> MSF (ReaderT DTime m) a b -> SelfClockingMSF m a b\n-- runAtMinS dt msf = timeTransformF (max dt) msf\n\n-- | Make an MSF asynchronous. The default initial value is used for the output\n-- until a first @Just@ value is received, and then the last output is cached.\nmkAsyncMSF :: Monad m => b -> MSF  m a b -> MSF m (Maybe a) b\nmkAsyncMSF b0 msf = MSF $ \\ma ->\n  case ma of\n    Nothing -> return (b0, mkAsyncMSF b0 msf)\n    Just a  -> do\n      (b, msf\') <- unMSF msf a\n      return (b, mkAsyncMSF b msf\')\n\n-- | Run an MSF with clocking information multiple times, possibly outputing\n-- several results.\nrunSelfClocking :: Monad m => SelfClockingMSF m a b -> MSF (ReaderT DTime m) a [(DTime, b)]\nrunSelfClocking msf = MSF $ \\a -> do\n  runSelfClocking\' msf a []\n\nrunSelfClocking\' :: Monad m\n                 => SelfClockingMSF m a b\n                 -> a\n                 -> [(DTime, b)]\n                 -> ReaderT DTime m ([(DTime, b)], MSF (ReaderT DTime m) a [(DTime, b)])\nrunSelfClocking\' msf a acc = do\n  dt <- ask\n  ((b, msf\'), (dt\', last)) <- runStateT (unMSF msf a) (0, False)\n  let acc\' = acc ++ [(dt\', b)]\n  if last\n    then return (acc\', runSelfClocking msf\')\n    else withReaderT (\\x -> x - dt\') (runSelfClocking\' msf\' a acc\')\n\n-- | Run an MSF with clocking information multiple times, possibly outputing\n-- several results, by merging the results.\nresample :: Monad m\n         => (DTime -> [(DTime, b)] -> b)\n         -> SelfClockingMSF m a b\n         -> MSF (ReaderT DTime m) a b\nresample f msf = (curDT &&& runSelfClocking msf) >>> arr (uncurry f)\n\ncurDT :: Monad m => MSF (ReaderT DTime m) a DTime\ncurDT = arrM (\\_ -> ask)\n\n-- | Make an msf that runs on a binary clock that may or may not tick.\n--\n-- This is extremely similar to @mkAsyncMSF@, but that one has the option\n-- embedded in the value and this one has it embedded in the clock.\npossiblyRun :: Monad m => b -> MSF m a b -> MSF (ReaderT Bool m) a b\npossiblyRun b0 msf = MSF $ \\a -> do\n  run <- ask\n  if run\n    then do (b, msf\') <- lift (unMSF msf a)\n            return (b, possiblyRun b msf\')\n    else return (b0, possiblyRun b0 msf )\n\n-- | Monad for pure MSFs on a discrete (binary) clock.\ntype DiscreteMonad = Reader Bool\n\n-- | Monad for MSFs on a discrete (binary) clock.\ntype ContinuousMonad = WriterT Bool (Reader DTime)\n\n-- discreteIntoContinuous :: b -> MSF m a b -> MSF (ReaderT DTime m) a b\n-- discreteIntoContinuous b0 msf = undefined\n--\n-- discreteCatchingUp :: b -> MSF m a b -> MSF (ReaderT Bool m) a b\n-- discreteCatchingUp b0 msf = undefined\n\n-- | Different forms of discrete-continuous board synchronization\nsyncBoards :: forall m a b c\n           .  Monad m\n           => MSF m a b\n           -> MSF (StateT Bool (ReaderT DTime m)) b c\n           -> MSF (ReaderT DTime m) a c\nsyncBoards msfDiscrete msfCont = MSF $ \\a -> do\n  (b, msfD\') <- lift $ unMSF msfDiscrete a\n  let r :: StateT Bool (ReaderT DTime m) (c, MSF (StateT Bool (ReaderT DTime m)) b c)\n      r = unMSF msfCont b\n\n      r2 :: (ReaderT DTime m) ((c, MSF (StateT Bool (ReaderT DTime m)) b c), Bool)\n      r2 = runStateT r True\n\n  ((c, msfC\'), finished) <- r2\n  return (c, syncBoards\' (finished, b) msfD\' msfC\')\n\nsyncBoards\' :: Monad m\n            => (Bool, b)\n            -> MSF m a b\n            -> MSF (StateT Bool (ReaderT DTime m)) b c\n            -> MSF (ReaderT DTime m) a c\nsyncBoards\' (finished,b0) msfDiscrete msfCont = MSF $ \\a -> do\n  (b, msfD\') <- if finished\n                  then lift $ unMSF msfDiscrete a\n                  else return (b0, msfDiscrete)\n  ((c, msfC\'), finished\') <- runStateT (unMSF msfCont b) True\n  return (c, syncBoards\' (finished\', b) msfD\' msfC\')\n\n-- * Auxiliary operations\nconstant :: Arrow a => c -> a b c\nconstant = arr . const\n\n-- * Examples\n\n-- | Run an MSF with a frequency cap of 60FPS. If the time delta is more than\n-- 60, it is executed at 60FPS once and indicated in the monad that more steps\n-- can be executed.\ngame60FPS\' :: MSF (Reader DTime) a b -> SelfClockingMSF Identity a b\ngame60FPS\' game = MSF $ \\a -> do\n  dt <- lift $ ask\n  let realDT = min dt (1 / 60)\n      lastStep = dt < (1 / 60)\n  put (realDT, lastStep)\n  (output, game\' ) <- lift $ withReader (const realDT) (unMSF game a)\n  return (output, game60FPS\' game\')\n\nreverseDTime :: MSF (Reader DTime) a b -> MSF (Reader DTime) a b\nreverseDTime = timeTransformF ((-1)*)\n\ntype History a = [(DTime, a)]\n\nlastSample :: History a -> (DTime, a)\nlastSample as = last as\n\ncache :: ((DTime, a) -> Maybe (DTime, a) -> DTime -> a) -> MSF (Reader DTime) a a\ncache interpolate = cache\' interpolate [] 0\n\n-- | Possible bug if initial dt is zero\ncache\' :: ((DTime, a) -> Maybe (DTime, a) -> DTime -> a) -> History a -> DTime -> MSF (Reader DTime) a a\ncache\' interpolate history globalDTime = MSF $ \\a -> do\n  dt <- ask\n  if (dt == 0)\n    then return (snd $ lastSample history, cache\' interpolate history globalDTime)\n    else -- dt <  0\n         let globalDTime\' = globalDTime + dt\n             sample = sampleAt interpolate history globalDTime\'\n             history\' = discardAfter history globalDTime\'\n             history\'\' = addSample  history\' globalDTime\' sample\n         in return (sample, cache\' interpolate history\'\' globalDTime\')\n  -- where\n  --   tf a | dt == 0 = (cache\' interpolate history globalDTime, snd $ lastSample history)\n  --        | dt <  0 = let globalDTime\' = globalDTime + dt\n  --                        sample = sampleAt interpolate history globalDTime\'\n  --                        history\' = discardAfter history globalDTime\'\n  --                        history\'\' = addSample  history\' globalDTime\' sample\n  --                    in (cache\' interpolate history\'\' globalDTime\', sample)\n\nsampleAt :: ((DTime, a) -> Maybe (DTime, a) -> DTime -> a) -> History a -> DTime -> a\nsampleAt interpolate history time = sampleAt\' interpolate time (head history) (tail history)\nsampleAt\' interpolate time (t0, a0) [] = interpolate (t0, a0) Nothing time\nsampleAt\' interpolate time (t0, a0) ((t1,a1):hs)\n  | time >= t0 && time <= t1 = interpolate (t0, a0) (Just (t1, a1)) time\n  | otherwise                = sampleAt\' interpolate time (t1,a1) hs\n\ndiscardAfter :: History a -> DTime -> History a\ndiscardAfter history time = filter (\\(t, a) -> t <= time) history\n\naddSample :: History a -> DTime -> a -> History a\naddSample history time sample = addSample\' time sample history\n\naddSample\' :: DTime -> a -> History a -> History a\naddSample\' time sample [] = [(time, sample)]\naddSample\' time sample h@((t1,a1):hs)\n  | t1 == time = (time, sample):hs\n  | t1 >  time = (time, sample):h\n  | otherwise  = (t1,a1) : addSample\' time sample hs\n\nrevSwitch :: MSF (Reader DTime) a (b, Event c) -> (c -> MSF (Reader DTime) a b) -> MSF (Reader DTime) a b\nrevSwitch msf k = MSF $ \\a -> do\n  ((b0, e), sf1) <- unMSF msf a\n  case e of\n     NoEvent  -> return (b0, switchAux sf1 k)\n     Event c0 -> do (b1, sf2) <- unMSF (k c0) a\n                    return (b1, switchingPoint sf1 k b1 sf2)\n    -- where\n    --     tf0 a0 =\n    --         case tf10 a0 of\n    --             (sf1, (b0, NoEvent))  -> (switchAux sf1 k, b0)\n    --             (sf1, (_,  Event c0)) -> switchingPoint sf1 k (sfTF (k c0) a0)\n\n where\n        switchingPoint :: MSF (Reader DTime) a (b, Event c) -> (c -> MSF (Reader DTime) a b) -> b -> MSF (Reader DTime) a b -> MSF (Reader DTime) a b\n        switchingPoint sf1 k b sfN\' = MSF $ \\a -> do\n           dt <- ask\n           if | dt < 0  -> unMSF (switchAux sf1 k) a\n              | dt > 0  -> do (b1, sfN\'\') <- unMSF sfN\' a\n                              return (b1, switchingPoint\' sf1 k dt b1 sfN\'\')\n              | dt == 0 -> return (b, switchingPoint sf1 k b sfN\')\n          -- where sf\' = MSF tf\'\n          --       tf\' dt a = if | dt < 0  -> unMSF (switchAux sf1 k) dt a\n          --                                  -- let (sf1\', b\') = unMSF sf1 dt a\n          --                                  -- in (switchAux sf1\' k, b\')\n          --                     | dt > 0  -> switchingPoint\' sf1 k dt (unMSF sfN\' dt a)\n          --                     | dt == 0 -> switchingPoint sf1 k (sfN\', b)\n\n        switchingPoint\' :: MSF (Reader DTime) a (b, Event c) -> (c -> MSF (Reader DTime) a b) -> DTime -> b -> MSF (Reader DTime) a b -> MSF (Reader DTime) a b\n        switchingPoint\' sf1 k accumDT b sfN\' = MSF $ \\a -> do\n          dt <- ask\n          let dt\' = dt + accumDT\n          if | dt < 0  ->\n                           if | dt\' < 0  -> withReaderT (const dt\') (unMSF (switchAux sf1 k) a)\n                              | dt\' > 0  -> dt\' `seq` do (b1, sfN\'\') <- unMSF sfN\' a\n                                                         return (b1, switchingPoint\' sf1 k dt\' b1 sfN\'\')\n                              | dt\' == 0 -> return (b, switchingPoint\' sf1 k accumDT b sfN\')\n              | dt > 0  -> dt\' `seq` do (b1, sfN\'\') <- unMSF sfN\' a\n                                        return (b1, switchingPoint\' sf1 k dt\' b1 sfN\'\')\n              | dt == 0 -> return (b, switchingPoint\' sf1 k accumDT b sfN\')\n\n\n        switchAux :: MSF (Reader DTime) a (b, Event c) -> (c -> MSF (Reader DTime) a b) -> MSF (Reader DTime) a b\n        switchAux sf1 k = MSF $ \\a -> do\n          ((b, e), sf1\') <- unMSF sf1 a\n          case e of\n           NoEvent -> return (b, switchAux sf1\' k)\n           Event c -> do (b1, sf1\'\') <- unMSF (k c) a\n                         return (b1, switchingPoint sf1 k b1 sf1\'\')\n\ncheckpoint :: MSF (Reader DTime) a (b, Event (), Event ()) -> MSF (Reader DTime) a b\ncheckpoint sf = MSF $ \\a -> do\n   ((b, advance, reset), sf\') <- unMSF sf a\n   case reset of\n        Event () -> error "loop"\n        NoEvent -> let pt = case advance of\n                              Event () -> Left sf\'\n                              NoEvent  -> Right sf\n                   in return (b, checkpoint\' pt sf\')\n\ncheckpoint\' :: Either (MSF (Reader DTime) a (b, Event (), Event ())) (MSF (Reader DTime) a (b, Event (), Event ()))\n            -> (MSF (Reader DTime) a (b, Event (), Event ()))\n            -> MSF (Reader DTime) a b\ncheckpoint\' rstPt sf\' = MSF $ \\a -> do\n   ((b, advance, reset), sf\'\') <- unMSF sf\' a\n   case reset of\n     Event () -> case rstPt of\n                   Left sf\'\'\' -> unMSF (checkpoint\' rstPt sf\'\'\') a\n                   Right sf   -> unMSF (checkpoint sf) a\n     NoEvent -> let pt = case advance of\n                           Event () -> Left sf\'\'\n                           NoEvent -> rstPt\n                in return (b, checkpoint\' pt sf\'\')\n\nforgetPast :: Monad m => MSF (ReaderT DTime m) a b -> MSF (ReaderT DTime m) a b\nforgetPast sf = MSF $ \\a -> do\n   (b, sf\') <- unMSF sf a\n   return (b, forgetPast\' 0 sf\')\n\nforgetPast\' :: Monad m => DTime -> MSF (ReaderT DTime m) a b -> MSF (ReaderT DTime m) a b\nforgetPast\' time sf\' = MSF $ \\a -> do\n  dt <- ask\n  let time\' = time + dt\n  -- trace (show time\') $\n  if time\' < 0\n    then do (b, sf\'\') <- withReaderT (const (-time)) (unMSF sf\' a)\n            return (b, forgetPast\' 0 sf\'\')\n    else do (b, sf\'\') <- unMSF sf\' a\n            return (b, forgetPast\' time\' sf\'\')\n\nalwaysForward :: MSF (Reader DTime) a b -> MSF (Reader DTime) a b\nalwaysForward = timeTransformF (\\dt -> max dt (-dt))\n\nlimitHistory :: DTime -> MSF (Reader DTime) a b -> MSF (Reader DTime) a b\nlimitHistory time sf = MSF $ \\a -> do\n  (b, sf\') <- unMSF sf a\n  return (b, limitHistory\' 0 time sf\')\n\nlimitHistory\' :: DTime -> DTime -> MSF (Reader DTime) a b -> MSF (Reader DTime) a b\nlimitHistory\' curT maxT sf\' = MSF $ \\a -> do\n  dt <- ask\n  let curT\' = curT + dt\n      time\' = if curT\' > maxT then maxT else curT\'\n  -- trace (show (dt, curT, maxT, maxMaxT)) $\n  if time\' < 0\n    then do (b, sf\'\') <- withReaderT (\\_ -> -curT) (unMSF sf\' a)\n            return (b, limitHistory\' 0 maxT sf\'\')\n    else do (b, sf\'\') <- unMSF sf\' a\n            return (b, limitHistory\' time\' maxT sf\'\')\n\nclocked :: MSF (Reader DTime) a DTime -> MSF (Reader DTime) a b -> MSF (Reader DTime) a b\nclocked clockSF sf = MSF $ \\a -> do\n  (b, sf\')  <- unMSF sf a\n  (_, cSF\') <- unMSF clockSF a\n  return (b, clocked\' cSF\' sf\')\n\nclocked\' :: MSF (Reader DTime) a DTime -> MSF (Reader DTime) a b -> MSF (Reader DTime) a b\nclocked\' clockSF sf = MSF $ \\a -> do\n  (dt\', cSF\') <- unMSF clockSF a\n  (b, sf\')    <- withReaderT (\\_ -> dt\')  (unMSF sf a)\n  return (b, clocked\' cSF\' sf\')\n'