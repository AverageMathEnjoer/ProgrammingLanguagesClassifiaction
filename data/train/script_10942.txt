b'#\' @rdname DESeqDataSet\n#\' @export\nsetClass("DESeqDataSet",\n         contains = "RangedSummarizedExperiment",\n         representation = representation( \n           design = "ANY",\n           dispersionFunction = "function"))\n\nsetValidity("DESeqDataSet", function(object) {\n  if (! ("counts" %in% assayNames(object)) )\n    return( "the assays slot must contain a matrix named \'counts\'" )\n  if ( !is.numeric( counts(object) ) )\n    return( "the count data is not numeric" )\n  if ( any( is.na( counts(object) ) ) )\n    return( "NA values are not allowed in the count matrix" )\n  if ( !is.integer( counts(object) ) )\n    return( "the count data is not in integer mode" )\n  if ( any( counts(object) < 0 ) )\n    return( "the count data contains negative values" )\n\n  design <- design(object)\n  # \'design\' is either a formula or matrix\n  stopifnot(is(design, "formula") | is(design, "matrix"))\n\n  if (is(design, "formula")) {\n    designVars <- all.vars(design)\n    if (!all(designVars %in% names(colData(object)))) {\n      return("all variables in design formula must be columns in colData")\n    }\n    designVarsClass <- sapply(designVars, function(v) class(colData(object)[[v]]))\n    if (any(designVarsClass == "character")) {\n      return("variables in design formula are character vectors.\n  convert these columns of colData(object) to factors before including in the design formula")\n    }\n    designFactors <- designVars[designVarsClass == "factor"]\n    # levels would duplicate after make.names()\n    if (any(sapply(designFactors,function(v) {\n      factor.lvls <- levels(colData(object)[[v]])\n      factor.nms <- make.names(factor.lvls)\n      any(duplicated(factor.nms))\n    }))) {\n      return("levels of factors in the design have non-unique level names after make.names() is applied.\n  best to only use letters and numbers for levels of factors in the design")\n    }\n    # levels contain characters other than letters, numbers, and underscore\n    if (any(sapply(designFactors,function(v) {\n      factor.lvls <- levels(colData(object)[[v]])\n      any(!grepl("^[A-Za-z0-9_.]+$",factor.lvls))\n    }))) {\n      # just a warning for now\n      message("  Note: levels of factors in the design contain characters other than\n  letters, numbers, \'_\' and \'.\'. It is recommended (but not required) to use\n  only letters, numbers, and delimiters \'_\' or \'.\', as these are safe characters\n  for column names in R. [This is a message, not a warning or an error]")\n    }\n  } else if (is(design, "matrix")) {\n    # TODO add some more tests for if \'design\' is matrix\n    stopifnot(nrow(design) == ncol(object))\n  }\n  \n  TRUE\n})\n  \n#\' DESeqDataSet object and constructors\n#\'\n#\' \\code{DESeqDataSet} is a subclass of \\code{RangedSummarizedExperiment},\n#\' used to store the input values, intermediate calculations and results of an\n#\' analysis of differential expression.  The \\code{DESeqDataSet} class\n#\' enforces non-negative integer values in the "counts" matrix stored as\n#\' the first element in the assay list.\n#\' In addition, a formula which specifies the design of the experiment must be provided.\n#\' The constructor functions create a DESeqDataSet object\n#\' from various types of input:\n#\' a RangedSummarizedExperiment, a matrix, count files generated by\n#\' the python package HTSeq, or a list from the tximport function in the\n#\' tximport package.\n#\' See the vignette for examples of construction from different types.\n#\'\n#\' Note on the error message "assay colnames() must be NULL or equal colData rownames()":\n#\' this means that the colnames of countData are different than the rownames of colData.\n#\' Fix this with: \\code{colnames(countData) <- NULL}\n#\'\n#\' @param se a \\code{RangedSummarizedExperiment} with columns of variables\n#\' indicating sample information in \\code{colData},\n#\' and the counts as the first element in the assays list, which will\n#\' be renamed "counts". A \\code{RangedSummarizedExperiment} object can be\n#\' generated by the function \\code{summarizeOverlaps} in the GenomicAlignments\n#\' package.\n#\' @param design a \\code{formula} or \\code{matrix}.\n#\' the \\code{formula} expresses how the counts for each gene\n#\' depend on the variables in \\code{colData}. Many R \\code{formula} are valid,\n#\' including designs with multiple variables, e.g., \\code{~ group + condition},\n#\' and designs with interactions, e.g., \\code{~ genotype + treatment + genotype:treatment}.\n#\' See \\code{\\link{results}} for a variety of designs and how to extract results tables.\n#\' By default, the functions in this package will use \n#\' the last variable in the formula for building results tables and plotting.\n#\' \\code{~ 1} can be used for no design, although users need to remember\n#\' to switch to another design for differential testing.\n#\' @param countData for matrix input: a matrix of non-negative integers\n#\' @param colData for matrix input: a \\code{DataFrame} or \\code{data.frame} with at least a single column.\n#\' Rows of colData correspond to columns of countData\n#\' @param tidy for matrix input: whether the first column of countData is the rownames for the count matrix\n#\' @param sampleTable for htseq-count: a \\code{data.frame} with three or more columns. Each row\n#\' describes one sample. The first column is the sample name, the second column\n#\' the file name of the count file generated by htseq-count, and the remaining\n#\' columns are sample metadata which will be stored in \\code{colData}\n#\' @param txi for tximport: the simple list output of the \\code{tximport} function\n#\' @param directory for htseq-count: the directory relative to which the filenames are specified. defaults to current directory\n#\' @param ignoreRank use of this argument is reserved for DEXSeq developers only.\n#\' Users will immediately encounter an error upon trying to estimate dispersion\n#\' using a design with a model matrix which is not full rank.\n#\' @param ... arguments provided to \\code{SummarizedExperiment} including rowRanges and metadata. Note that\n#\' for Bioconductor 3.1, rowRanges must be a GRanges or GRangesList, with potential metadata columns\n#\' as a DataFrame accessed and stored with \\code{mcols}. If a user wants to store metadata columns\n#\' about the rows of the countData, but does not have GRanges or GRangesList information,\n#\' first construct the DESeqDataSet without rowRanges and then add the DataFrame with \\code{mcols(dds)}.\n#\' \n#\' @return A DESeqDataSet object.\n#\' \n#\' @aliases DESeqDataSet DESeqDataSet-class DESeqDataSetFromMatrix DESeqDataSetFromHTSeqCount\n#\'\n#\' @references See \\url{http://www-huber.embl.de/users/anders/HTSeq} for htseq-count\n#\'\n#\' @docType class\n#\'\n#\' @examples\n#\'\n#\' countData <- matrix(1:100,ncol=4)\n#\' condition <- factor(c("A","A","B","B"))\n#\' dds <- DESeqDataSetFromMatrix(countData, DataFrame(condition), ~ condition)\n#\'\n#\' @rdname DESeqDataSet\n#\' @importFrom utils packageVersion\n#\' @export\nDESeqDataSet <- function(se, design, ignoreRank=FALSE) {\n  if (!is(se, "RangedSummarizedExperiment")) {\n    if (is(se, "SummarizedExperiment")) {\n      se <- as(se, "RangedSummarizedExperiment")\n    } else {\n      stop("\'se\' must be a RangedSummarizedExperiment object")\n    }\n  }\n  if (is.null(assayNames(se)) || assayNames(se)[1] != "counts") {\n    # check if "counts" are in another assay spot:\n    if (length(assayNames(se)) > 1) {\n      if ("counts" %in% assayNames(se)[-1]) {\n        stop("\'counts\' assay is not the first in assays list, re-arrange so that \'counts\' is first")\n      }\n    }\n    message("renaming the first element in assays to \'counts\'")\n    assayNames(se)[1] <- "counts"\n  }\n  # special tximeta processing\n  if ("tximetaInfo" %in% names(metadata(se))) {\n    se <- processTximeta(se)\n  }  \n  # before validity check, try to convert assay to integer mode\n  if (any(is.na(assay(se))))\n    stop("NA values are not allowed in the count matrix")\n  if (any(assay(se) < 0)) {\n    stop("some values in assay are negative")\n  }\n  if (!is.integer(assay(se))) {\n    if (!is.numeric(assay(se))) {\n      stop(paste("counts matrix should be numeric, currently it has mode:", mode(assay(se))))\n    }\n    if (any(round(assay(se)) != assay(se))) {\n      stop("some values in assay are not integers")\n    }\n    message("converting counts to integer mode")\n    mode(assay(se)) <- "integer"\n  }\n\n  if (all(assay(se) == 0)) {\n    stop("all samples have 0 counts for all genes. check the counting script.")\n  }\n  \n  if (all(rowSums(assay(se) == assay(se)[,1]) == ncol(se))) {\n    warning("all genes have equal values for all samples. will not be able to perform differential analysis")\n  }\n\n  if (any(duplicated(rownames(se)))) {\n    warning(sum(duplicated(rownames(se)))," duplicate rownames were renamed by adding numbers")\n    rnms <- rownames(se)\n    dups <- unique(rnms[duplicated(rnms)])\n    for (rn in dups) {\n      idx <- which(rnms == rn)\n      rnms[idx[-1]] <- paste(rnms[idx[-1]], c(seq_len(length(idx) - 1)), sep=".")\n    }\n    rownames(se) <- rnms\n  }\n\n  if (is(design, "formula")) {\n    designVars <- all.vars(design)\n    if (!all(designVars %in% names(colData(se)))) {\n      stop("all variables in design formula must be columns in colData")\n    }\n    for (v in designVars) {\n      if (any(is.na(colData(se)[[v]])))\n        stop(paste("variables in design formula cannot contain NA:", v))\n    }\n    \n    designVarsClass <- sapply(designVars, function(v) class(colData(se)[[v]])[1])\n\n    if (any(designVarsClass == "character")) {\n      warning("some variables in design formula are characters, converting to factors")\n      for (v in designVars[designVarsClass == "character"]) {\n        colData(se)[[v]] <- factor(colData(se)[[v]])\n      }\n    }\n    \n    if (length(designVars) == 1) {\n      var <- colData(se)[[designVars]]\n      if (all(var == var[1])) {\n        stop("design has a single variable, with all samples having the same value.\n  use instead a design of \'~ 1\'. estimateSizeFactors, rlog and the VST can then be used")\n      }\n    }\n\n    designVarsNumeric <- sapply(designVars, function(v) is.numeric(colData(se)[[v]]))\n    if (any(designVarsNumeric)) {\n      msgIntVars <- FALSE\n      msgCenterScale <- FALSE\n      for (v in designVars[designVarsNumeric]) {\n        if (all(colData(se)[[v]] == round(colData(se)[[v]]))) {\n          msgIntVars <- TRUE\n        }\n        if (mean(colData(se)[[v]]) > 5 | sd(colData(se)[[v]]) > 5) {\n          msgCenterScale <- TRUE\n        }\n      }\n      if (msgIntVars) {\n        message("  the design formula contains one or more numeric variables with integer values,\n  specifying a model with increasing fold change for higher values.\n  did you mean for this to be a factor? if so, first convert\n  this variable to a factor using the factor() function")\n      }\n      if (msgCenterScale) {\n        message("  the design formula contains one or more numeric variables that have mean or\n  standard deviation larger than 5 (an arbitrary threshold to trigger this message).\n  Including numeric variables with large mean can induce collinearity with the intercept.\n  Users should center and scale numeric variables in the design to improve GLM convergence.")\n      }\n    }\n\n    if (any(designVarsClass == "ordered")) {\n      stop("the design formula contains an ordered factor. The internal steps\ndo not work on ordered factors as a formula. Instead you should provide a matrix to\nthe \'design\' slot or to the \'full\' argument of DESeq(), constructed using model.matrix.")\n    }\n    \n    designFactors <- designVars[designVarsClass == "factor"]\n    missingLevels <- sapply(designFactors, function(v) any(table(colData(se)[[v]]) == 0))\n    if (any(missingLevels)) {\n      message("factor levels were dropped which had no samples")\n      for (v in designFactors[missingLevels]) {\n        colData(se)[[v]] <- droplevels(colData(se)[[v]])\n      }\n    }\n    \n    singleLevel <- sapply(designFactors, function(v) all(colData(se)[[v]] == colData(se)[[v]][1]))\n    if (any(singleLevel)) {\n      stop("design contains one or more variables with all samples having the same value,\n  remove these variables from the design")\n    }\n    \n    # if the last variable in the design formula is a\n    # factor, and has a level \'control\', check if it is\n    # the reference level and if not print a message\n    lastDV <- length(designVars)\n    if (length(designVars) > 0 && designVarsClass[lastDV] == "factor") {\n      lastDVLvls <- levels(colData(se)[[designVars[lastDV]]])\n      controlSynonyms <- c("control","Control","CONTROL")\n      for (cSyn in controlSynonyms) {\n        if (cSyn %in% lastDVLvls) {\n          if (cSyn != lastDVLvls[1]) {\n            message(paste0("  it appears that the last variable in the design formula, \'",designVars[lastDV],"\',\n  has a factor level, \'",cSyn,"\', which is not the reference level. we recommend\n  to use factor(...,levels=...) or relevel() to set this as the reference level\n  before proceeding. for more information, please see the \'Note on factor levels\'\n  in vignette(\'DESeq2\')."))\n          }\n        }\n      }\n    }\n\n    modelMatrix <- stats::model.matrix.default(design, data=as.data.frame(colData(se)))\n  } else if (is(design, "matrix")) {\n    modelMatrix <- design\n  } else {\n    stop("\'design\' should be a formula or a matrix")\n  }\n\n  if (!ignoreRank) {\n    checkFullRank(modelMatrix)\n  }\n  \n  # Add columns on the columns\n  mcolsCols <- DataFrame(type=rep("input",ncol(colData(se))),\n                         description=rep("",ncol(colData(se))))\n  mcols(colData(se)) <- if (is.null(mcols(colData(se)))) {\n    mcolsCols\n  } else if (all(names(mcols(colData(se))) == c("type","description"))) {\n    mcolsCols\n  } else {\n    cbind(mcols(colData(se)), mcolsCols)\n  }\n  \n  object <- new("DESeqDataSet", se, design = design)\n                                 \n  # now we know we have at least an empty GRanges or GRangesList for rowRanges\n  # so we can create a metadata column \'type\' for the mcols\n  # and we label any incoming columns as \'input\'\n\n  # this is metadata columns on the rows\n  mcolsRows <- DataFrame(type=rep("input",ncol(mcols(object))),\n                         description=rep("",ncol(mcols(object))))\n  mcols(mcols(object)) <- if (is.null(mcols(mcols(object)))) {\n    mcolsRows\n  } else if (all(names(mcols(mcols(object))) == c("type","description"))) {\n    mcolsRows\n  } else {\n    cbind(mcols(mcols(object)), mcolsRows)\n  }\n\n  # stash the package version\n  metadata(object)[["version"]] <- packageVersion("DESeq2")\n  \n  return(object)\n}\n\n#\' @rdname DESeqDataSet\n#\' @export\nDESeqDataSetFromMatrix <- function( countData, colData, design, tidy=FALSE, ignoreRank=FALSE, ... )\n{\n  \n  if (tidy) {\n    stopifnot(ncol(countData) > 1)\n    rownms <- as.character(countData[,1])\n    countData <- countData[,-1,drop=FALSE]\n    rownames(countData) <- rownms\n  }\n\n  # check that these agree in number\n  stopifnot(ncol(countData) == nrow(colData))\n\n  if (is(countData, "data.frame")) {\n    if (any(sapply(countData, is, "factor"))) {\n      warning("\\n\\n  \'countData\' is a data.frame with one or more factor columns.\n  Be aware that converting directly to numeric can lead to errors.\n  Provide matrices of integers to avoid this error.")\n    }\n  }\n  \n  # we expect a matrix of counts, which are non-negative integers\n  countData <- as.matrix( countData )\n\n  if (is(colData,"data.frame"))\n    colData <- as(colData, "DataFrame")\n  \n  # check if the rownames of colData are simply in different order\n  # than the colnames of the countData, if so throw an error\n  # as the user probably should investigate what\'s wrong\n  if (!is.null(rownames(colData)) & !is.null(colnames(countData))) {\n    if (all(sort(rownames(colData)) == sort(colnames(countData)))) {\n      if (!all(rownames(colData) == colnames(countData))) {\n        stop(paste("rownames of the colData:\n  ",paste(rownames(colData),collapse=","),"\n  are not in the same order as the colnames of the countData:\n  ",paste(colnames(countData),collapse=",")))\n      }\n    }\n  }\n  if (is.null(rownames(colData)) & !is.null(colnames(countData))) {\n    rownames(colData) <- colnames(countData)\n  }\n  \n  se <- SummarizedExperiment(assays = SimpleList(counts=countData), colData = colData, ...)\n  object <- DESeqDataSet(se, design = design, ignoreRank)\n\n  return(object)\n}\n\n#\' @rdname DESeqDataSet\n#\' @export\nDESeqDataSetFromHTSeqCount <- function( sampleTable, directory=".", design, ignoreRank=FALSE, ...) \n{\n  sampleTable <- as.data.frame(sampleTable) # in case tibble or data.table are provided\n  if (missing(design)) stop("design is missing")\n  l <- lapply( as.character( sampleTable[,2] ), function(fn) read.table( file.path( directory, fn ), fill=TRUE ) )\n  if( ! all( sapply( l, function(a) all( a$V1 == l[[1]]$V1 ) ) ) )\n    stop( "Gene IDs (first column) differ between files." )\n  # select last column of \'a\', works even if htseq was run with \'--additional-attr\'\n  tbl <- sapply( l, function(a) a[,ncol(a)] )\n  colnames(tbl) <- sampleTable[,1]\n  rownames(tbl) <- l[[1]]$V1\n  rownames(sampleTable) <- sampleTable[,1]\n  oldSpecialNames <- c("no_feature","ambiguous","too_low_aQual","not_aligned","alignment_not_unique")\n  # either starts with two underscores\n  # or is one of the old special names (htseq-count backward compatability)\n  specialRows <- (substr(rownames(tbl),1,1) == "_") | rownames(tbl) %in% oldSpecialNames\n  tbl <- tbl[ !specialRows, , drop=FALSE ]\n  object <- DESeqDataSetFromMatrix(countData=tbl,colData=sampleTable[,-(1:2),drop=FALSE],design=design,ignoreRank, ...)\n  return(object)\n}   \n\n#\' @rdname DESeqDataSet\n#\' @export\nDESeqDataSetFromTximport <- function(txi, colData, design, ...) \n{\n  stopifnot(is(txi, "list"))\n  counts <- round(txi$counts)\n  mode(counts) <- "integer"\n  object <- DESeqDataSetFromMatrix(countData=counts, colData=colData, design=design, ...)\n  stopifnot(txi$countsFromAbundance %in% c("no","scaledTPM","lengthScaledTPM"))\n  if (txi$countsFromAbundance %in% c("scaledTPM","lengthScaledTPM")) {\n    message("using just counts from tximport")\n  } else {\n    message("using counts and average transcript lengths from tximport")\n    lengths <- txi$length\n    stopifnot(all(lengths > 0))\n    dimnames(lengths) <- dimnames(object)\n    assays(object)[["avgTxLength"]] <- lengths\n  }\n  return(object)\n}   \n\n\n#\' @rdname DESeqResults\n#\' @export\nsetClass("DESeqResults",\n         contains="DFrame",\n         representation = representation( \n           priorInfo = "list")\n         )\n\n#\' DESeqResults object and constructor\n#\'\n#\' This constructor function would not typically be used by "end users".\n#\' This simple class indirectly extends the DataFrame class defined in the\n#\' S4Vectors package to allow other packages to write methods for results\n#\' objects from the DESeq2 package. It is used by \\code{\\link{results}}\n#\' to wrap up the results table.\n#\'\n#\' @param DataFrame a DataFrame of results, standard column names are:\n#\' baseMean, log2FoldChange, lfcSE, stat, pvalue, padj.\n#\' @param priorInfo a list giving information on the log fold change prior\n#\'\n#\' @return a DESeqResults object\n#\' @docType class\n#\' @aliases DESeqResults-class\n#\' @rdname DESeqResults\n#\' @export\nDESeqResults <- function(DataFrame, priorInfo=list()) {\n  new("DESeqResults", DataFrame, priorInfo=priorInfo)\n}\n\n#\' @rdname DESeqTransform\n#\' @export\nsetClass("DESeqTransform", contains="RangedSummarizedExperiment")\n\n#\' DESeqTransform object and constructor\n#\'\n#\' This constructor function would not typically be used by "end users".\n#\' This simple class extends the RangedSummarizedExperiment class of the\n#\' SummarizedExperiment package.\n#\' It is used by \\code{\\link{rlog}} and\n#\' \\code{\\link{varianceStabilizingTransformation}}\n#\' to wrap up the results into a class for downstream methods,\n#\' such as \\code{\\link{plotPCA}}.\n#\' \n#\' @param SummarizedExperiment a RangedSummarizedExperiment\n#\'\n#\' @return a DESeqTransform object\n#\' @docType class\n#\' @aliases DESeqTransform-class\n#\' @rdname DESeqTransform\n#\' @export\nDESeqTransform <- function(SummarizedExperiment) {\n  se <- SummarizedExperiment\n  if (!is(se, "RangedSummarizedExperiment")) {\n    if (is(se, "SummarizedExperiment")) {\n      se <- as(se, "RangedSummarizedExperiment")\n    } else {\n      stop("\'SummarizedExperiment\' must be a RangedSummarizedExperiment object")\n    }\n  }\n  new("DESeqTransform", se)\n}\n\n# unexported helper function\nprocessTximeta <- function(se) {\n  assay(se) <- round(assay(se))\n  mode(assay(se)) <- "integer"\n  stopifnot("countsFromAbundance" %in% names(metadata(se)))\n  cfa <- metadata(se)$countsFromAbundance\n  stopifnot(cfa %in% c("no","scaledTPM","lengthScaledTPM"))\n  lengthPresent <- "length" %in% assayNames(se)\n  if (cfa %in% c("scaledTPM","lengthScaledTPM")) {\n    message("using just counts from tximeta")\n  } else {\n    if (lengthPresent) {\n      message("using counts and average transcript lengths from tximeta")\n      stopifnot(all(assays(se)$length > 0))\n      anms <- assayNames(se)\n      assayNames(se)[anms == "length"] <- "avgTxLength"\n    } else {\n      message("length assay is missing, using original counts without length adjustment")\n    }\n  }\n  return(se)\n}\n'