b'{-# LANGUAGE  OverloadedStrings #-}\n{-# LANGUAGE PatternGuards #-}\n\n-- | Stream related tools\n\nmodule Pdf.Core.Stream\n(\n  StreamFilter,\n  knownFilters,\n  readStream,\n  rawStreamContent,\n  decodedStreamContent,\n  decodeStream\n)\nwhere\n\nimport Pdf.Core.Exception\nimport Pdf.Core.Object\nimport Pdf.Core.Parsers.Object\nimport Pdf.Core.Stream.Filter.Type\nimport Pdf.Core.Stream.Filter.FlateDecode\nimport Pdf.Core.IO.Buffer (Buffer)\nimport qualified Pdf.Core.IO.Buffer as Buffer\n\nimport Data.Int\nimport Data.Maybe\nimport Data.ByteString (ByteString)\nimport qualified Data.Vector as Vector\nimport qualified Data.HashMap.Strict as HashMap\nimport Control.Monad\nimport Control.Exception hiding (throw)\nimport System.IO.Streams (InputStream)\nimport qualified System.IO.Streams as Streams\nimport qualified System.IO.Streams.Attoparsec as Streams\n\n-- | Read \'Stream\' from stream\n--\n-- We need to pass current position here to calculate stream data offset\nreadStream :: InputStream ByteString -> Int64 -> IO Stream\nreadStream is off = do\n  (is\', counter) <- Streams.countInput is\n  (_, obj) <- Streams.parseFromStream parseIndirectObject is\'\n    `catch` \\(Streams.ParseException msg) -> throwIO (Corrupted msg [])\n  case obj of\n    Stream (S dict _) -> do\n      off\' <- counter\n      return (S dict (off + off\'))\n    _ -> throwIO $ Streams.ParseException ("stream expected, but got: "\n                                          ++ show obj)\n\n-- | All stream filters implemented by the toolbox\n--\n-- Right now it contains only FlateDecode filter\nknownFilters :: [StreamFilter]\nknownFilters = catMaybes [flateDecode]\n\n-- | Raw stream content.\n-- Filters are not applyed\n--\n-- The \'InputStream\' returned is valid only until the next \'bufferSeek\'\n--\n-- Note: \\"Length\\" could be an indirect object, but we don\'t want\n-- to read indirect objects here. So we require length to be provided\nrawStreamContent :: Buffer\n                 -> Int           -- ^ stream length\n                 -> Int64         -- ^ stream offset\n                                  -- The payload is offset of stream data\n                 -> IO (InputStream ByteString)\nrawStreamContent buf len off = do\n  Buffer.seek buf off\n  Streams.takeBytes (fromIntegral len) (Buffer.toInputStream buf)\n\n-- | Decode stream content\n--\n-- It should be already decrypted\n--\n-- The \'InputStream\' is valid only until the next \'bufferSeek\'\ndecodeStream :: [StreamFilter]\n             -> Stream -> InputStream ByteString\n             -> IO (InputStream ByteString)\ndecodeStream filters (S dict _) istream =\n  buildFilterList dict >>= foldM decode istream\n  where\n  decode is (name, params) = do\n    f <- findFilter name\n    filterDecode f params is\n  findFilter name =\n    case filter ((== name) . filterName) filters of\n      [] -> throwIO $ Corrupted "Filter not found" []\n      (f : _) -> return f\n\nbuildFilterList :: Dict -> IO [(Name, Maybe Dict)]\nbuildFilterList dict = do\n  let f = fromMaybe Null $ HashMap.lookup "Filter" dict\n      p = fromMaybe Null $ HashMap.lookup "DecodeParms" dict\n  case (f, p) of\n    (Null, _) -> return []\n    (Name fd, Null) -> return [(fd, Nothing)]\n    (Name fd, Dict pd) -> return [(fd, Just pd)]\n    (Name fd, Array arr)\n      | [Dict pd] <- Vector.toList arr\n      -> return [(fd, Just pd)]\n    (Array fa, Null) -> do\n      fa\' <- forM (Vector.toList fa) $ \\o ->\n        case o of\n          Name n -> return n\n          _ -> throwIO $ Corrupted ("Filter should be a Name") []\n      return $ zip fa\' (repeat Nothing)\n    (Array fa, Array pa) | Vector.length fa == Vector.length pa -> do\n      fa\' <- forM (Vector.toList fa) $ \\o ->\n        case o of\n          Name n -> return n\n          _ -> throwIO $ Corrupted ("Filter should be a Name") []\n      pa\' <- forM (Vector.toList pa) $ \\o ->\n        case o of\n          Dict d -> return d\n          _ -> throwIO $ Corrupted ("DecodeParams should be a dictionary") []\n      return $ zip fa\' (map Just pa\')\n    _ -> throwIO $ Corrupted ("Can\'t handle Filter and DecodeParams: ("\n                            ++ show f ++ ", " ++ show p ++ ")") []\n\n-- | Decoded stream content\n--\n-- The \'InputStream\' is valid only until the next \'bufferSeek\'\n--\n-- Note: \\"Length\\" could be an indirect object, that is why\n-- we cann\'t read it ourself\ndecodedStreamContent :: Buffer\n                     -> [StreamFilter]\n                     -> (InputStream ByteString -> IO (InputStream ByteString))\n                     -- ^ decryptor\n                     -> Int\n                     -- ^ stream length\n                     -> Stream\n                     -- ^ stream with offset\n                     -> IO (InputStream ByteString)\ndecodedStreamContent buf filters decryptor len s@(S _ off) =\n  rawStreamContent buf len off >>=\n  decryptor >>=\n  decodeStream filters s\n'