b'module Main where\n\nimport Data.List (nub, nubBy)\nimport Data.Containers.ListUtils\nimport Test.Tasty\nimport Test.Tasty.QuickCheck\nimport Test.QuickCheck.Function (apply)\nimport Test.QuickCheck.Poly (A, OrdA, B, OrdB, C)\n\nmain :: IO ()\nmain = defaultMain $ testGroup "listutils-properties"\n         [ testProperty "nubOrd" prop_nubOrd\n         , testProperty "nubOrdOn" prop_nubOrdOn\n         , testProperty "nubOrdOn fusion" prop_nubOrdOnFusion\n         , testProperty "nubInt" prop_nubInt\n         , testProperty "nubIntOn" prop_nubIntOn\n         , testProperty "nubIntOn fusion" prop_nubIntOnFusion\n         ]\n\n\nprop_nubOrd :: [OrdA] -> Property\nprop_nubOrd xs = nubOrd xs === nub xs\n\nprop_nubInt :: [Int] -> Property\nprop_nubInt xs = nubInt xs === nub xs\n\nprop_nubOrdOn :: Fun A OrdB -> [A] -> Property\nprop_nubOrdOn f\' xs =\n  nubOrdOn f xs === nubBy (\\x y -> f x == f y) xs\n  where f = apply f\'\n\nprop_nubIntOn :: Fun A Int -> [A] -> Property\nprop_nubIntOn f\' xs =\n  nubIntOn f xs === nubBy (\\x y -> f x == f y) xs\n  where f = apply f\'\n\nprop_nubOrdOnFusion :: Fun B C\n                    -> Fun B OrdB\n                    -> Fun A B\n                    -> [A] -> Property\nprop_nubOrdOnFusion f\' g\' h\' xs =\n  (map f . nubOrdOn g . map h $ xs)\n    === (map f . nubBy (\\x y -> g x == g y) . map h $ xs)\n  where\n    f = apply f\'\n    g = apply g\'\n    h = apply h\'\n\nprop_nubIntOnFusion :: Fun B C\n                    -> Fun B Int\n                    -> Fun A B\n                    -> [A] -> Property\nprop_nubIntOnFusion f\' g\' h\' xs =\n  (map f . nubIntOn g . map h $ xs)\n    === (map f . nubBy (\\x y -> g x == g y) . map h $ xs)\n  where\n    f = apply f\'\n    g = apply g\'\n    h = apply h\'\n'