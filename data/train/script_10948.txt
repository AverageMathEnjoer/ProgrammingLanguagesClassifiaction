b'/**\n * MIT License\n *\n * Copyright (c) 2017 Thibaut Goetghebuer-Planchon <tessil@gmx.com>\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the "Software"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n#define BOOST_TEST_DYN_LINK\n\n#include <tsl/robin_set.h>\n\n#include <boost/mpl/list.hpp>\n#include <boost/test/unit_test.hpp>\n#include <cstddef>\n#include <cstdint>\n#include <functional>\n#include <memory>\n#include <string>\n#include <tuple>\n#include <utility>\n\n#include "utils.h"\n\nBOOST_AUTO_TEST_SUITE(test_robin_set)\n\nusing test_types =\n    boost::mpl::list<tsl::robin_set<std::int64_t>, tsl::robin_set<std::string>,\n                     tsl::robin_set<self_reference_member_test>, tsl::robin_set<move_only_test>,\n                     tsl::robin_pg_set<self_reference_member_test>,\n                     tsl::robin_set<move_only_test, std::hash<move_only_test>, std::equal_to<move_only_test>,\n                                    std::allocator<move_only_test>, true, tsl::rh::prime_growth_policy>,\n                     tsl::robin_set<self_reference_member_test, std::hash<self_reference_member_test>,\n                                    std::equal_to<self_reference_member_test>,\n                                    std::allocator<self_reference_member_test>, true, tsl::rh::mod_growth_policy<>>,\n                     tsl::robin_set<move_only_test, std::hash<move_only_test>, std::equal_to<move_only_test>,\n                                    std::allocator<move_only_test>, false, tsl::rh::mod_growth_policy<>>>;\n\nBOOST_AUTO_TEST_CASE_TEMPLATE(test_insert, HSet, test_types)\n{\n    // insert x values, insert them again, check values\n    using key_t = typename HSet::key_type;\n\n    const std::size_t nb_values = 1000;\n    HSet set;\n    typename HSet::iterator it;\n    bool inserted;\n\n    for (std::size_t i = 0; i < nb_values; i++) {\n        std::tie(it, inserted) = set.insert(utils::get_key<key_t>(i));\n\n        BOOST_CHECK_EQUAL(*it, utils::get_key<key_t>(i));\n        BOOST_CHECK(inserted);\n    }\n    BOOST_CHECK_EQUAL(set.size(), nb_values);\n\n    for (std::size_t i = 0; i < nb_values; i++) {\n        std::tie(it, inserted) = set.insert(utils::get_key<key_t>(i));\n\n        BOOST_CHECK_EQUAL(*it, utils::get_key<key_t>(i));\n        BOOST_CHECK(!inserted);\n    }\n\n    for (std::size_t i = 0; i < nb_values; i++) {\n        it = set.find(utils::get_key<key_t>(i));\n\n        BOOST_CHECK_EQUAL(*it, utils::get_key<key_t>(i));\n    }\n}\n\nBOOST_AUTO_TEST_CASE(test_compare)\n{\n    const tsl::robin_set<std::string> set1 = {"a", "e", "d", "c", "b"};\n    const tsl::robin_set<std::string> set1_copy = {"e", "c", "b", "a", "d"};\n    const tsl::robin_set<std::string> set2 = {"e", "c", "b", "a", "d", "f"};\n    const tsl::robin_set<std::string> set3 = {"e", "c", "b", "a"};\n    const tsl::robin_set<std::string> set4 = {"a", "e", "d", "c", "z"};\n\n    BOOST_CHECK(set1 == set1_copy);\n    BOOST_CHECK(set1_copy == set1);\n\n    BOOST_CHECK(set1 != set2);\n    BOOST_CHECK(set2 != set1);\n\n    BOOST_CHECK(set1 != set3);\n    BOOST_CHECK(set3 != set1);\n\n    BOOST_CHECK(set1 != set4);\n    BOOST_CHECK(set4 != set1);\n\n    BOOST_CHECK(set2 != set3);\n    BOOST_CHECK(set3 != set2);\n\n    BOOST_CHECK(set2 != set4);\n    BOOST_CHECK(set4 != set2);\n\n    BOOST_CHECK(set3 != set4);\n    BOOST_CHECK(set4 != set3);\n}\n\nBOOST_AUTO_TEST_CASE(test_insert_pointer)\n{\n    // Test added mainly to be sure that the code compiles with MSVC due to a bug\n    // in the compiler. See robin_hash::insert_value_impl for details.\n    std::string value;\n    std::string* value_ptr = &value;\n\n    tsl::robin_set<std::string*> set;\n    set.insert(value_ptr);\n    set.emplace(value_ptr);\n\n    BOOST_CHECK_EQUAL(set.size(), 1);\n    BOOST_CHECK_EQUAL(**set.begin(), value);\n}\n\n/**\n * serialize and deserialize\n */\nBOOST_AUTO_TEST_CASE(test_serialize_deserialize)\n{\n    // insert x values; delete some values; serialize set; deserialize in new set;\n    // check equal. for deserialization, test it with and without hash\n    // compatibility.\n    const std::size_t nb_values = 1000;\n\n    tsl::robin_set<move_only_test> set;\n    for (std::size_t i = 0; i < nb_values + 40; i++) {\n        set.insert(utils::get_key<move_only_test>(i));\n    }\n\n    for (std::size_t i = nb_values; i < nb_values + 40; i++) {\n        set.erase(utils::get_key<move_only_test>(i));\n    }\n    BOOST_CHECK_EQUAL(set.size(), nb_values);\n\n    serializer serial;\n    set.serialize(serial);\n\n    deserializer dserial(serial.str());\n    auto set_deserialized = decltype(set)::deserialize(dserial, true);\n    BOOST_CHECK(set == set_deserialized);\n\n    deserializer dserial2(serial.str());\n    set_deserialized = decltype(set)::deserialize(dserial2, false);\n    BOOST_CHECK(set_deserialized == set);\n}\n\nBOOST_AUTO_TEST_SUITE_END()\n'