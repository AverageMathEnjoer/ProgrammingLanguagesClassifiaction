b"{-# LANGUAGE\n    DataKinds\n  , GADTs\n  , ScopedTypeVariables\n  , TypeFamilies\n  #-}\nmodule Rest.Container\n  ( module Rest.Types.Container\n  , listI\n  , listO\n  , mappingI\n  , mappingO\n  , statusO\n  , reasonE\n  , defaultE\n  ) where\n\nimport Data.Maybe\n\nimport Rest.Dictionary\nimport Rest.Error\nimport Rest.StringMap.HashMap.Strict\nimport Rest.Types.Container\nimport Rest.Types.Void\n\nlistI :: Inputs i -> Maybe (Inputs ('Just (List (FromMaybe () i))))\nlistI None       = Just (Dicts [XmlI, JsonI])\nlistI (Dicts is) =\n  case mapMaybe listDictI is of\n    []  -> Nothing\n    lis -> Just (Dicts lis)\n  where\n    listDictI :: Input a -> Maybe (Input (List a))\n    listDictI XmlI  = Just XmlI\n    listDictI JsonI = Just JsonI\n    listDictI _     = Nothing\n\nlistO :: Outputs o -> Maybe (Outputs ('Just (List (FromMaybe () o))))\nlistO None       = Just (Dicts [XmlO, JsonO])\nlistO (Dicts os) =\n  case mapMaybe listDictO os of\n    []  -> Nothing\n    los -> Just (Dicts los)\n  where\n    listDictO :: Output a -> Maybe (Output (List a))\n    listDictO XmlO  = Just XmlO\n    listDictO JsonO = Just JsonO\n    listDictO _     = Nothing\n\nmappingI :: forall i i'. i ~ FromMaybe () i' => Inputs i' -> Maybe (Inputs ('Just (StringHashMap String i)))\nmappingI None       = Just (Dicts [XmlI, JsonI])\nmappingI (Dicts is) =\n  case mapMaybe mappingDictI is of\n    []  -> Nothing\n    mis -> Just (Dicts mis)\n  where\n    mappingDictI :: Input i -> Maybe (Input (StringHashMap String i))\n    mappingDictI XmlI  = Just XmlI\n    mappingDictI JsonI = Just JsonI\n    mappingDictI _     = Nothing\n\nmappingO :: forall o o'. o ~ FromMaybe () o' => Outputs o' -> Maybe (Outputs ('Just (StringHashMap String o)))\nmappingO None       = Just (Dicts [XmlO, JsonO])\nmappingO (Dicts os) =\n  case mapMaybe mappingDictO os of\n    []  -> Nothing\n    mos -> Just (Dicts mos)\n  where\n    mappingDictO :: Output o -> Maybe (Output (StringHashMap String o))\n    mappingDictO XmlO  = Just XmlO\n    mappingDictO JsonO = Just JsonO\n    mappingDictO _     = Nothing\n\nstatusO :: (e ~ FromMaybe Void e', o ~ FromMaybe () o')\n        => Errors e' -> Outputs o' -> Maybe (Outputs ('Just (Status e o)))\nstatusO None       None       = Just (Dicts [XmlO, JsonO])\nstatusO None       (Dicts os) = mkStatusDict [XmlE, JsonE] os\nstatusO (Dicts es) None       = mkStatusDict es           [XmlO, JsonO]\nstatusO (Dicts es) (Dicts os) = mkStatusDict es           os\n\nmkStatusDict :: forall e o. [Error e] -> [Output o] -> Maybe (Outputs ('Just (Status e o)))\nmkStatusDict es os =\n    case mapMaybe mappingDictO (es `intersect` os) of\n      []  -> Nothing\n      sos -> Just (Dicts sos)\n    where\n      mappingDictO :: (Error e, Output o) -> Maybe (Output (Status e o))\n      mappingDictO (XmlE , XmlO ) = Just XmlO\n      mappingDictO (JsonE, JsonO) = Just JsonO\n      mappingDictO _              = Nothing\n\nintersect :: [Error e] -> [Output o] -> [(Error e, Output o)]\nintersect [] _  = []\nintersect _  [] = []\nintersect es os = [ (e, o) | e <- es, o <- os, e `eq` o ]\n  where\n    XmlE  `eq` XmlO  = True\n    JsonE `eq` JsonO = True\n    _     `eq` _     = False\n\nreasonE :: e ~ FromMaybe Void e' => Errors e' -> Errors ('Just (Reason e))\nreasonE None       = Dicts [XmlE, JsonE]\nreasonE (Dicts es) = Dicts (map reasonDictE es)\n  where\n    reasonDictE :: Error a -> Error (Reason a)\n    reasonDictE XmlE  = XmlE\n    reasonDictE JsonE = JsonE\n\ndefaultE :: Errors ('Just Reason_)\ndefaultE = Dicts [XmlE, JsonE]\n"