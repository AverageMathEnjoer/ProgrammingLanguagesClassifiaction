b'{-# LANGUAGE LambdaCase #-}\n{-# LANGUAGE MultiWayIf #-}\n{-# OPTIONS_GHC -fno-warn-overlapping-patterns #-}\n\n-- |\n-- Module      : Hoodle.Widget.PanZoom\n-- Copyright   : (c) 2013-2015 Ian-Woo Kim\n--\n-- License     : BSD3\n-- Maintainer  : Ian-Woo Kim <ianwookim@gmail.com>\n-- Stability   : experimental\n-- Portability : GHC\n--\n-- Pan-Zoom widget drawing and action\nmodule Hoodle.Widget.PanZoom where\n\nimport Control.Lens (over, set, view, (.~))\nimport Control.Monad (void, when)\nimport Control.Monad.Identity (Identity (..))\nimport Control.Monad.State (get, gets, liftIO, modify)\nimport Data.Hoodle.BBox (BBox (..))\nimport Data.Hoodle.Simple (Dimension (..))\nimport Data.List (delete)\nimport Data.Time.Clock\n  ( UTCTime,\n    getCurrentTime,\n  )\nimport Graphics.Hoodle.Render.Util.HitTest (isPointInBBox)\nimport qualified Graphics.Rendering.Cairo as Cairo\nimport Hoodle.Accessor\n  ( getCanvasGeometryCvsId,\n    lensSetToggleUIForFlag,\n    pureUpdateUhdl,\n    renderCache,\n  )\nimport Hoodle.Coroutine.Draw\n  ( invalidate,\n    invalidateAll,\n    invalidateInBBox,\n    nextevent,\n    updateFlagFromToggleUI,\n    waitSomeEvent,\n  )\nimport Hoodle.Coroutine.Page (canvasZoomUpdateGenRenderCvsId)\nimport Hoodle.Coroutine.Pen (processWithDefTimeInterval)\nimport Hoodle.Coroutine.Scroll (moveViewPortBy)\nimport Hoodle.Device\n  ( PointerCoord,\n    dev_touch_str,\n  )\nimport Hoodle.ModelAction.Page (zoomRatioFrmRelToCurr)\nimport Hoodle.Type.Canvas\n  ( CanvasId,\n    CanvasInfo,\n    canvasWidgets,\n    currentPageNum,\n    drawArea,\n    forBoth,\n    forBoth\',\n    pageArrangement,\n    unboxBiAct,\n    unboxBiXform,\n    unboxLens,\n    viewInfo,\n  )\nimport Hoodle.Type.Coroutine (MainCoroutine, doIOaction)\nimport Hoodle.Type.Enum (DrawFlag (Efficient))\nimport Hoodle.Type.Event\n  ( AllEvent (UsrEv),\n    UserEvent\n      ( ActionOrdered,\n        PenMove,\n        PenUp,\n        TouchMove,\n        TouchUp\n      ),\n  )\nimport Hoodle.Type.HoodleState\n  ( currentCanvas,\n    currentCanvasInfo,\n    currentUnit,\n    deviceList,\n    doesNotInvalidate,\n    doesUseTouch,\n    getCanvasInfo,\n    getHoodle,\n    setCanvasInfo,\n    settings,\n    unitHoodles,\n  )\nimport Hoodle.Type.PageArrangement\n  ( CanvasCoordinate (..),\n    CanvasDimension (..),\n    DesktopCoordinate (..),\n    PageNum (..),\n    ZoomMode (Zoom),\n  )\nimport Hoodle.Type.Widget\n  ( WidgetItem (PanZoomWidget),\n    allWidgets,\n    doesUsePanZoomWidget,\n    panZoomWidgetConfig,\n    panZoomWidgetPosition,\n    panZoomWidgetTouchIsZoom,\n    widgetConfig,\n  )\nimport Hoodle.View.Coordinate\n  ( CanvasGeometry\n      ( canvas2Desktop,\n        canvasDim,\n        desktop2Canvas,\n        desktop2Page,\n        page2Desktop\n      ),\n    device2Desktop,\n    makeCanvasGeometry,\n  )\nimport Hoodle.View.Draw\n  ( canvasImageSurface,\n    doubleBufferFlush,\n    drawWidgets,\n    renderPanZoomWidget,\n    virtualDoubleBufferDraw,\n  )\nimport System.Process (readProcess)\n\n--\n\ndata PanZoomMode = Moving | Zooming | Panning Bool\n\ndata PanZoomTouch = TouchMode | PenMode\n  deriving (Show, Eq, Ord)\n\ncheckPointerInPanZoom ::\n  (CanvasId, CanvasInfo a, CanvasGeometry) ->\n  PointerCoord ->\n  Maybe (Maybe (PanZoomMode, (CanvasCoordinate, CanvasCoordinate)))\ncheckPointerInPanZoom (_cid, cinfo, geometry) pcoord\n  | b =\n    let oxy@(CvsCoord (x, y)) = (desktop2Canvas geometry . device2Desktop geometry) pcoord\n        owxy@(CvsCoord (x0, y0)) = view (canvasWidgets . panZoomWidgetConfig . panZoomWidgetPosition) cinfo\n        obbox = BBox (x0, y0) (x0 + 100, y0 + 100)\n        pbbox1 = BBox (x0 + 10, y0 + 10) (x0 + 50, y0 + 90)\n        pbbox2 = BBox (x0 + 50, y0 + 10) (x0 + 90, y0 + 90)\n        pbbox3 = BBox (x0, y0) (x0 + 10, y0 + 10)\n        zbbox = BBox (x0 + 30, y0 + 30) (x0 + 70, y0 + 70)\n     in if isPointInBBox obbox (x, y)\n          then\n            let mmode\n                  | isPointInBBox zbbox (x, y) = Just (Zooming, (oxy, owxy))\n                  | isPointInBBox pbbox1 (x, y) = Just (Panning False, (oxy, owxy))\n                  | isPointInBBox pbbox2 (x, y) = Just (Panning True, (oxy, owxy))\n                  | isPointInBBox pbbox3 (x, y) = Nothing\n                  | otherwise = Just (Moving, (oxy, owxy))\n             in Just mmode\n          else Nothing\n  | otherwise = Nothing\n  where\n    b = view (canvasWidgets . widgetConfig . doesUsePanZoomWidget) cinfo\n\n-- |\nstartPanZoomWidget ::\n  PanZoomTouch ->\n  (CanvasId, CanvasInfo a, CanvasGeometry) ->\n  Maybe (PanZoomMode, (CanvasCoordinate, CanvasCoordinate)) ->\n  MainCoroutine ()\nstartPanZoomWidget tchmode (cid, cinfo, geometry) mmode = do\n  modify (doesNotInvalidate .~ True)\n  xst <- get\n  cache <- renderCache\n  let hdl = (getHoodle . view (unitHoodles . currentUnit)) xst\n  case mmode of\n    Nothing -> togglePanZoom cid\n    Just (mode, (oxy, owxy)) -> do\n      (srcsfc, Dim wsfc hsfc) <- case mode of\n        Moving -> liftIO (canvasImageSurface cache cid Nothing geometry hdl)\n        Zooming -> liftIO (canvasImageSurface cache cid (Just 1) geometry hdl)\n        Panning _ -> liftIO (canvasImageSurface cache cid (Just 1) geometry hdl)\n      -- need to draw other widgets here\n      let otherwidgets = delete PanZoomWidget allWidgets\n      liftIO $\n        Cairo.renderWith\n          srcsfc\n          (drawWidgets otherwidgets hdl cinfo Nothing)\n      -- end : need to draw other widgets here ^^^\n      tgtsfc <-\n        liftIO $\n          Cairo.createImageSurface\n            Cairo.FormatARGB32\n            (floor wsfc)\n            (floor hsfc)\n      ctime <- liftIO getCurrentTime\n      manipulatePZW (tchmode, mode) cid geometry (srcsfc, tgtsfc) owxy oxy ctime\n      liftIO $ Cairo.surfaceFinish srcsfc\n      liftIO $ Cairo.surfaceFinish tgtsfc\n  modify (doesNotInvalidate .~ False)\n  invalidateAll\n\n-- |\nfindZoomXform ::\n  Dimension ->\n  ((Double, Double), (Double, Double), (Double, Double)) ->\n  (Double, (Double, Double))\nfindZoomXform (Dim w h) ((xo, yo), (x0, _y0), (x, _y)) =\n  let tx = x - x0\n      ztx = 1 + tx / 200\n      zx\n        | ztx > 2 = 2\n        | ztx < 0.5 = 0.5\n        | otherwise = ztx\n      z = zx\n      xtrans = (1 - z) * xo / z - w\n      ytrans = (1 - z) * yo / z - h\n   in (z, (xtrans, ytrans))\n\n-- |\nfindPanXform ::\n  Dimension ->\n  ((Double, Double), (Double, Double)) ->\n  (Double, Double)\nfindPanXform (Dim w h) ((x0, y0), (x, y)) =\n  let tx = x - x0\n      ty = y - y0\n      dx\n        | tx > w = w\n        | tx < (-w) = -w\n        | otherwise = tx\n      dy\n        | ty > h = h\n        | ty < (-h) = -h\n        | otherwise = ty\n   in (dx - w, dy - h)\n\n-- | manipulate Pan-Zoom widget until released when grabbing the widget\nmanipulatePZW ::\n  (PanZoomTouch, PanZoomMode) ->\n  CanvasId ->\n  CanvasGeometry ->\n  -- | (Source, Target)\n  (Cairo.Surface, Cairo.Surface) ->\n  -- | original widget position\n  CanvasCoordinate ->\n  -- | where pen pressed\n  CanvasCoordinate ->\n  UTCTime ->\n  MainCoroutine ()\nmanipulatePZW\n  fullmode@(tchmode, mode)\n  cid\n  geometry\n  (srcsfc, tgtsfc)\n  owxy@(CvsCoord (xw, yw))\n  oxy@(CvsCoord (x0, y0))\n  otime = do\n    r <- nextevent\n    case r of\n      PenMove _ pcoord -> if tchmode /= PenMode then again otime else moveact pcoord\n      TouchMove _ pcoord ->\n        if tchmode /= TouchMode\n          then again otime\n          else do\n            b <- gets (view (settings . doesUseTouch))\n            when b $ moveact pcoord\n      PenUp _ pcoord -> if tchmode /= PenMode then again otime else upact pcoord\n      TouchUp _ pcoord ->\n        if tchmode /= TouchMode\n          then again otime\n          else do\n            b <- gets (view (settings . doesUseTouch))\n            when b $ upact pcoord\n      _ -> again otime\n    where\n      again = manipulatePZW fullmode cid geometry (srcsfc, tgtsfc) owxy oxy\n      moveact pcoord =\n        processWithDefTimeInterval\n          again\n          ( \\ctime ->\n              movingRender mode cid geometry (srcsfc, tgtsfc) owxy oxy pcoord\n                >> manipulatePZW fullmode cid geometry (srcsfc, tgtsfc) owxy oxy ctime\n          )\n          otime\n      upact pcoord = do\n        case mode of\n          Zooming -> do\n            let CvsCoord (x, y) = (desktop2Canvas geometry . device2Desktop geometry) pcoord\n                CanvasDimension cdim = canvasDim geometry\n                ccoord@(CvsCoord (xo, yo)) = CvsCoord (xw + 50, yw + 50)\n                (z, (_, _)) = findZoomXform cdim ((xo, yo), (x0, y0), (x, y))\n                nratio = zoomRatioFrmRelToCurr geometry z\n                mpnpgxy = (desktop2Page geometry . canvas2Desktop geometry) ccoord\n            canvasZoomUpdateGenRenderCvsId (return ()) cid (Just (Zoom nratio)) Nothing\n            case mpnpgxy of\n              Nothing -> return ()\n              Just pnpgxy -> do\n                uhdl <- gets (view (unitHoodles . currentUnit))\n                geom\' <- liftIO $ getCanvasGeometryCvsId cid uhdl\n                let DeskCoord (xd, yd) = page2Desktop geom\' pnpgxy\n                    DeskCoord (xd0, yd0) = canvas2Desktop geom\' ccoord\n                moveViewPortBy (return ()) cid (\\(xorig, yorig) -> (xorig + xd - xd0, yorig + yd - yd0))\n          Panning _ -> do\n            let (x_d, y_d) = (unDeskCoord . device2Desktop geometry) pcoord\n                (x0_d, y0_d) =\n                  (unDeskCoord . canvas2Desktop geometry)\n                    (CvsCoord (x0, y0))\n                (dx_d, dy_d) =\n                  let (dx_d1, dy_d1) = (x_d - x0_d, y_d - y0_d)\n                   in if\n                          | abs dx_d1 < 25 -> (0, dy_d1)\n                          | abs dy_d1 < 25 -> (dx_d1, 0)\n                          | otherwise -> (dx_d1, dy_d1)\n            moveViewPortBy (return ()) cid (\\(xorig, yorig) -> (xorig - dx_d, yorig - dy_d))\n          _ -> return ()\n        invalidate cid\n\n-- |\nmovingRender ::\n  PanZoomMode ->\n  CanvasId ->\n  CanvasGeometry ->\n  (Cairo.Surface, Cairo.Surface) ->\n  CanvasCoordinate ->\n  CanvasCoordinate ->\n  PointerCoord ->\n  MainCoroutine ()\nmovingRender mode cid geometry (srcsfc, tgtsfc) (CvsCoord (xw, yw)) (CvsCoord (x0, y0)) pcoord = do\n  let CvsCoord (x, y) = (desktop2Canvas geometry . device2Desktop geometry) pcoord\n  uhdl <- gets (view (unitHoodles . currentUnit))\n  case mode of\n    Moving -> do\n      let CanvasDimension (Dim cw ch) = canvasDim geometry\n          cinfobox = getCanvasInfo cid uhdl\n          nposx\n            | xw + x - x0 < -50 = -50\n            | xw + x - x0 > cw - 50 = cw - 50\n            | otherwise = xw + x - x0\n          nposy\n            | yw + y - y0 < -50 = -50\n            | yw + y - y0 > ch - 50 = ch - 50\n            | otherwise = yw + y - y0\n          nwpos = CvsCoord (nposx, nposy)\n          changeact :: CanvasInfo a -> CanvasInfo a\n          changeact = set (canvasWidgets . panZoomWidgetConfig . panZoomWidgetPosition) nwpos\n          ncinfobox = (runIdentity . forBoth unboxBiXform (return . changeact)) cinfobox\n          isTouchZoom = view (unboxLens (canvasWidgets . panZoomWidgetConfig . panZoomWidgetTouchIsZoom)) cinfobox\n      pureUpdateUhdl $ setCanvasInfo (cid, ncinfobox)\n      virtualDoubleBufferDraw srcsfc tgtsfc (return ()) (renderPanZoomWidget isTouchZoom Nothing nwpos)\n    Zooming -> do\n      let cinfobox = getCanvasInfo cid uhdl\n      let pos = runIdentity (forBoth\' unboxBiAct (return . view (canvasWidgets . panZoomWidgetConfig . panZoomWidgetPosition)) cinfobox)\n      let (xo, yo) = (xw + 50, yw + 50)\n          CanvasDimension cdim = canvasDim geometry\n          (z, (xtrans, ytrans)) = findZoomXform cdim ((xo, yo), (x0, y0), (x, y))\n          isTouchZoom = view (unboxLens (canvasWidgets . panZoomWidgetConfig . panZoomWidgetTouchIsZoom)) cinfobox\n      virtualDoubleBufferDraw\n        srcsfc\n        tgtsfc\n        (Cairo.save >> Cairo.scale z z >> Cairo.translate xtrans ytrans)\n        (Cairo.restore >> renderPanZoomWidget isTouchZoom Nothing pos)\n    Panning b -> do\n      let cinfobox = getCanvasInfo cid uhdl\n          CanvasDimension cdim = canvasDim geometry\n          (xtrans, ytrans) = findPanXform cdim ((x0, y0), (x, y))\n      let CanvasDimension (Dim cw ch) = canvasDim geometry\n          nposx\n            | xw + x - x0 < -50 = -50\n            | xw + x - x0 > cw - 50 = cw - 50\n            | otherwise = xw + x - x0\n          nposy\n            | yw + y - y0 < -50 = -50\n            | yw + y - y0 > ch - 50 = ch - 50\n            | otherwise = yw + y - y0\n          nwpos =\n            if b\n              then CvsCoord (nposx, nposy)\n              else runIdentity (forBoth\' unboxBiAct (return . view (canvasWidgets . panZoomWidgetConfig . panZoomWidgetPosition)) cinfobox)\n          ncinfobox = set (unboxLens (canvasWidgets . panZoomWidgetConfig . panZoomWidgetPosition)) nwpos cinfobox\n          isTouchZoom = view (unboxLens (canvasWidgets . panZoomWidgetConfig . panZoomWidgetTouchIsZoom)) cinfobox\n      pureUpdateUhdl $ setCanvasInfo (cid, ncinfobox)\n      virtualDoubleBufferDraw\n        srcsfc\n        tgtsfc\n        (Cairo.save >> Cairo.translate xtrans ytrans)\n        (Cairo.restore >> renderPanZoomWidget isTouchZoom Nothing nwpos)\n  --\n  xst2 <- get\n  let cinfobox = getCanvasInfo cid . view (unitHoodles . currentUnit) $ xst2\n  liftIO $ forBoth\' unboxBiAct (doubleBufferFlush tgtsfc) cinfobox\n\n-- |\ntogglePanZoom :: CanvasId -> MainCoroutine ()\ntogglePanZoom cid = do\n  pureUpdateUhdl $ \\uhdl ->\n    let cinfobox = getCanvasInfo cid uhdl\n        ncinfobox = over (unboxLens (canvasWidgets . widgetConfig . doesUsePanZoomWidget)) not cinfobox\n     in setCanvasInfo (cid, ncinfobox) uhdl\n  invalidateInBBox Nothing Efficient cid\n\n-- |\ntouchStart :: CanvasId -> PointerCoord -> MainCoroutine ()\ntouchStart cid pcoord = forBoth\' unboxBiAct chk =<< gets (getCanvasInfo cid . view (unitHoodles . currentUnit))\n  where\n    chk :: CanvasInfo a -> MainCoroutine ()\n    chk cinfo = do\n      let cvs = view drawArea cinfo\n          pnum = (PageNum . view currentPageNum) cinfo\n          arr = view (viewInfo . pageArrangement) cinfo\n      geometry <- liftIO $ makeCanvasGeometry pnum arr cvs\n      let triplet = (cid, cinfo, geometry)\n          oxy@(CvsCoord (x, y)) = (desktop2Canvas geometry . device2Desktop geometry) pcoord\n          CvsCoord (x0, y0) = view (canvasWidgets . panZoomWidgetConfig . panZoomWidgetPosition) cinfo\n          obbox = BBox (x0, y0) (x0 + 100, y0 + 100)\n      xst <- get\n      if isPointInBBox obbox (x, y)\n        then do\n          pureUpdateUhdl $ \\uhdl ->\n            let changeact :: CanvasInfo a -> CanvasInfo a\n                changeact = over (canvasWidgets . panZoomWidgetConfig . panZoomWidgetTouchIsZoom) not\n                ncinfobox = runIdentity . forBoth unboxBiXform (return . changeact) . getCanvasInfo cid $ uhdl\n             in setCanvasInfo (cid, ncinfobox) uhdl\n          invalidateInBBox Nothing Efficient cid\n        else do\n          let b = view (settings . doesUseTouch) xst\n              isZoomTouch = view (canvasWidgets . panZoomWidgetConfig . panZoomWidgetTouchIsZoom) cinfo\n          if b\n            then\n              if isZoomTouch\n                then startPanZoomWidget TouchMode triplet (Just (Zooming, (oxy, oxy)))\n                else startPanZoomWidget TouchMode triplet (Just (Panning False, (oxy, oxy)))\n            else do\n              let devlst = view deviceList xst\n              doIOaction $ \\_ -> do\n                _ <- lensSetToggleUIForFlag "HANDA" (settings . doesUseTouch) xst\n                -- ad hoc\n                let touchstr = dev_touch_str devlst\n                when (touchstr /= "touch") $\n                  void $\n                    readProcess\n                      "xinput"\n                      ["disable", dev_touch_str devlst]\n                      ""\n                --\n                return (UsrEv ActionOrdered)\n              void $ waitSomeEvent (\\case TouchUp _ _ -> True; _ -> False)\n\ntoggleTouch :: MainCoroutine ()\ntoggleTouch = do\n  _ <- updateFlagFromToggleUI "HANDA" (settings . doesUseTouch)\n  xst <- get\n  let devlst = view deviceList xst\n      uhdl = view (unitHoodles . currentUnit) xst\n      (cid, _cinfobox) = view currentCanvas uhdl\n  when (view (settings . doesUseTouch) xst) $ do\n    -- ad hoc\n    let touchstr = dev_touch_str devlst\n    when (touchstr /= "touch") $\n      void $ liftIO $ readProcess "xinput" ["enable", dev_touch_str devlst] ""\n    --\n    pureUpdateUhdl $\n      ( currentCanvasInfo\n          . unboxLens (canvasWidgets . widgetConfig . doesUsePanZoomWidget)\n      )\n        .~ True\n    invalidateInBBox Nothing Efficient cid\n    return ()\n'