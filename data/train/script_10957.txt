b'-- % cabal install hspec\n-- % runghc <this_file>\n\nimport Small\n\nmain :: IO ()\nmain = hspec $ do\n    describe "my_lt" $\n      prop "behaves as model" $ \\(Small m) (Small n) -> m >= 0 && n >= 0\n        ==> my_lt m n == (m < n)\n    describe "my_lteq" $\n      prop "behaves as model" $ \\(Small m) (Small n) -> m >= 0 && n >= 0\n        ==> my_lteq m n == (m <= n)\n    describe "my_even" $\n      prop "behaves as model" $ \\(Small n) -> n >= 0\n        ==> my_even n == even n\n    describe "my_divide" $\n      prop "behaves as model" $ \\(Small m) (Small n) -> m >= 0 && n >= 1\n        ==> my_divide m n == m `div` n\n    describe "my_gt" $\n      prop "behaves as model" $ \\(Small m) (Small n) -> m >= 0 && n >= 0\n        ==> my_gt m n == (m > n)\n    describe "my_gteq" $\n      prop "behaves as model" $ \\(Small m) (Small n) -> m >= 0 && n >= 0\n        ==> my_gteq m n == (m >= n)\n    describe "my_odd" $\n      prop "behaves as model" $ \\(Small n) -> n >= 0\n        ==> my_odd n == odd n\n    describe "my_remainder" $\n      prop "behaves as model" $ \\(Small m) (Small n) -> m >= 0 && n >= 1\n        ==> my_remainder m n == m `mod` n\n    describe "my_divide_iter" $\n      prop "behaves as model" $ \\(Small m) (Small n) -> m >= 0 && n >= 1\n        ==> my_divide_iter m n == m `div` n\n\nmy_lt :: Integer -> Integer -> Bool\nmy_lt _ 0 = False\nmy_lt 0 _ = True\nmy_lt m n = my_lt (m - 1) (n - 1)\n\nmy_lteq :: Integer -> Integer -> Bool\nmy_lteq 0 _ = True\nmy_lteq _ 0 = False\nmy_lteq m n = my_lteq (m - 1) (n - 1)\n\nmy_even :: Integer -> Bool\nmy_even 0 = True\nmy_even 1 = False\nmy_even n = my_even (n - 2)\n\nmy_divide :: Integer -> Integer -> Integer\nmy_divide m n\n  | m < n     = 0\n  | otherwise = my_divide (m - n) n + 1\n\nmy_gt :: Integer -> Integer -> Bool\nmy_gt 0 _ = False\nmy_gt _ 0 = True\nmy_gt m n = my_gt (m - 1) (n - 1)\n\nmy_gteq :: Integer -> Integer -> Bool\nmy_gteq _ 0 = True\nmy_gteq 0 _ = False\nmy_gteq m n = my_gteq (m - 1) (n - 1)\n\nmy_odd :: Integer -> Bool\nmy_odd 0 = False\nmy_odd 1 = True\nmy_odd n = my_odd (n - 2)\n\nmy_remainder :: Integer -> Integer -> Integer\nmy_remainder m n\n  | m < n     = m\n  | otherwise = my_remainder (m - n) n\n\nmy_divide_iter :: Integer -> Integer -> Integer\nmy_divide_iter x y = iter x y 0\n  where\n    iter :: Integer -> Integer -> Integer -> Integer\n    iter m n acc\n      | m < n     = acc\n      | otherwise = iter (m - n) n (acc + 1)\n'