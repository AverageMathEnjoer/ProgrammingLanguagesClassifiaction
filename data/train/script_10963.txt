b'#include "stdafx.h"\n#include "AssetsFileFormat.h"\n#include "AssetBundleFileTable.h"\n#include "AssetsFileReader.h"\n#include "AssetTypeClass.h"\n\n#define fmread(target,count) {memcpy(target, &((uint8_t*)data)[*filePos], count); *filePos = *filePos + count;}\n#define fmwrite(source,count) {if ((filePos+count)>bufferLen){return false;} memcpy(&((uint8_t*)buffer)[filePos], source, count); filePos = filePos + count;}\n#define _fmalign(fpos) (fpos + 3) & ~3\n#define fmalign() {*filePos = _fmalign(*filePos);}\n#define fmwalign() {int newFilePos = _fmalign(filePos); memset(&((uint8_t*)buffer)[filePos], 0, newFilePos-filePos); filePos = newFilePos;}\n\nchar _nullChar = 0;\nASSETSTOOLS_API void AssetBundleAsset::FlushChanges()\n{\n\tif (isRead && unityVersion == -1)\n\t{\n\t\tAssetTypeValueField *pFile = pAssetType->GetBaseField();\n\t\t\n\t\tAssetTypeValueField *pPreloadTable = pFile ? pFile->Get("m_PreloadTable")->Get(0U) : NULL;\n\t\tif (pPreloadTable && (preloadArrayLen > pPreloadTable->GetChildrenCount()))\n\t\t{\n\t\t\t//AssetTypeInstance::SetChildList frees this memory\n\t\t\tvoid *pNewValueList = malloc(preloadArrayLen * (3 * sizeof(AssetTypeValueField*) + 3 * sizeof(AssetTypeValueField) + 2 * sizeof(AssetTypeValue)));\n\t\t\tif (pNewValueList != NULL)\n\t\t\t{\n\t\t\t\tAssetTypeValueField** basePointerList = (AssetTypeValueField**)pNewValueList;\n\t\t\t\tAssetTypeValueField** varPointerList = (AssetTypeValueField**)(&((uint8_t*)pNewValueList)[preloadArrayLen * sizeof(AssetTypeValueField*)]);\n\t\t\t\tAssetTypeValueField* valueFields = (AssetTypeValueField*)(&((uint8_t*)pNewValueList)[preloadArrayLen * 3 * sizeof(AssetTypeValueField*)]);\n\t\t\t\tAssetTypeValue* values = (AssetTypeValue*)(&((uint8_t*)pNewValueList)[preloadArrayLen * (3 * sizeof(AssetTypeValueField*) + 3 * sizeof(AssetTypeValueField))]);\n\n\t\t\t\tfor (uint32_t i = 0; i < preloadArrayLen; i++)\n\t\t\t\t{\n\t\t\t\t\tbasePointerList[i] = &valueFields[i*3];\n\n\t\t\t\t\tvarPointerList[i*2] = &valueFields[i*3+1];\n\t\t\t\t\tvarPointerList[i*2+1] = &valueFields[i*3+2];\n\n\t\t\t\t\tvalueFields[i*3].Read(NULL, &pPreloadTable->GetTemplateField()->children[1], 2, &varPointerList[i*2]); //data\n\n\t\t\t\t\tvalueFields[i*3+1].Read(&values[i*2], &pPreloadTable->GetTemplateField()->children[1].children[0], 0, NULL); //fileID\n\t\t\t\t\tvalueFields[i*3+2].Read(&values[i*2+1], &pPreloadTable->GetTemplateField()->children[1].children[1], 0, NULL); //pathID\n\n\t\t\t\t\tvalues[i*2] = AssetTypeValue(pPreloadTable->GetTemplateField()->children[1].children[0].valueType, &preloadArray[i].fileId);\n\t\t\t\t\tvalues[i*2+1] = AssetTypeValue(pPreloadTable->GetTemplateField()->children[1].children[1].valueType, &preloadArray[i].pathId);\n\t\t\t\t}\n\n\t\t\t\tpAssetType->SetChildList(pPreloadTable, basePointerList, preloadArrayLen, true);\n\t\t\t\tif (pPreloadTable->GetValue() != NULL)\n\t\t\t\t\tpPreloadTable->GetValue()->AsArray()->size = preloadArrayLen;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpPreloadTable->SetChildrenList(pPreloadTable->GetChildrenList(), pPreloadTable->GetChildrenCount());\n\t\t\tif (pPreloadTable->GetValue() != NULL)\n\t\t\t\tpPreloadTable->GetValue()->AsArray()->size = preloadArrayLen;\n\t\t\tfor (uint32_t i = 0; i < preloadArrayLen; i++)\n\t\t\t{\n\t\t\t\t{\n\t\t\t\t\tAssetTypeValue valueTmp = AssetTypeValue(pPreloadTable->GetTemplateField()->children[1].children[0].valueType, &preloadArray[i].fileId);\n\t\t\t\t\tmemcpy(pPreloadTable->Get(i)->Get(0U)->GetValue(), &valueTmp, sizeof(AssetTypeValue));\n\t\t\t\t}\n\t\t\t\t{\n\t\t\t\t\tAssetTypeValue valueTmp = AssetTypeValue(pPreloadTable->GetTemplateField()->children[1].children[1].valueType, &preloadArray[i].pathId);\n\t\t\t\t\tmemcpy(pPreloadTable->Get(i)->Get(1)->GetValue(), &valueTmp, sizeof(AssetTypeValue));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tAssetTypeValueField *pContainerTable = pFile->Get("m_Container")->Get(0U);\n\t\tif (containerArrayLen > pPreloadTable->GetChildrenCount())\n\t\t{\n\t\t\t//AssetTypeInstance::SetChildList frees this memory\n\t\t\tvoid *pNewValueList = malloc(\n\t\t\t\tcontainerArrayLen * (8 * sizeof(AssetTypeValueField*) + 8 * sizeof(AssetTypeValueField) + 5 * sizeof(AssetTypeValue))\n\t\t\t\t+ 1);\n\t\t\tif (pNewValueList != NULL)\n\t\t\t{\n\t\t\t\tAssetTypeValueField** dataPointerList = (AssetTypeValueField**)pNewValueList;\n\t\t\t\tAssetTypeValueField** varPointerList = (AssetTypeValueField**)(&((uint8_t*)pNewValueList)[containerArrayLen * sizeof(AssetTypeValueField*)]);\n\t\t\t\tAssetTypeValueField* valueFields = (AssetTypeValueField*)(&((uint8_t*)pNewValueList)[containerArrayLen * 8 * sizeof(AssetTypeValueField*)]);\n\t\t\t\tAssetTypeValue* values = (AssetTypeValue*)(&((uint8_t*)pNewValueList)[containerArrayLen * (8 * sizeof(AssetTypeValueField*) + 8 * sizeof(AssetTypeValueField))]);\n\t\t\t\tchar* nullChar = (char*)(&((uint8_t*)pNewValueList)[containerArrayLen * (8 * sizeof(AssetTypeValueField*) + 8 * sizeof(AssetTypeValueField) + 5 * sizeof(AssetTypeValue))]);\n\t\t\t\tnullChar[0] = 0;\n\n\t\t\t\tfor (uint32_t i = 0; i < containerArrayLen; i++)\n\t\t\t\t{\n\t\t\t\t\tdataPointerList[i] = &valueFields[i*8];\n\n\t\t\t\t\tvarPointerList[i*7] = &valueFields[i*8+1]; //data.first (string)\n\t\t\t\t\tvarPointerList[i*7+1] = &valueFields[i*8+2]; //data.second (AssetInfo)\n\n\t\t\t\t\tvarPointerList[i*7+2] = &valueFields[i*8+3]; //data.second.preloadIndex\n\t\t\t\t\tvarPointerList[i*7+3] = &valueFields[i*8+4]; //data.second.preloadSize\n\t\t\t\t\tvarPointerList[i*7+4] = &valueFields[i*8+5]; //data.second.asset (PPtr<Object>)\n\n\t\t\t\t\tvarPointerList[i*7+5] = &valueFields[i*8+6]; //data.second.asset.fileID\n\t\t\t\t\tvarPointerList[i*7+6] = &valueFields[i*8+7]; //data.second.asset.pathID\n\n\t\t\t\t\tvalueFields[i*8].Read(NULL, &pContainerTable->GetTemplateField()->children[1], 2, &varPointerList[i*7]); //data\n\n\t\t\t\t\tvalueFields[i*8+1].Read(&values[i*5], &pContainerTable->GetTemplateField()->children[1].children[0], 0, NULL); //data.first (string)\n\t\t\t\t\tvalueFields[i*8+2].Read(NULL, &pContainerTable->GetTemplateField()->children[1].children[1], 3, &varPointerList[i*7+2]); //data.second (AssetInfo)\n\t\t\t\t\tvalueFields[i*8+3].Read(&values[i*5+1], &pContainerTable->GetTemplateField()->children[1].children[1].children[0], 0, NULL); //data.second.preloadIndex\n\t\t\t\t\tvalueFields[i*8+4].Read(&values[i*5+2], &pContainerTable->GetTemplateField()->children[1].children[1].children[1], 0, NULL); //data.second.preloadSize\n\t\t\t\t\tvalueFields[i*8+5].Read(NULL, &pContainerTable->GetTemplateField()->children[1].children[1].children[2], 2, &varPointerList[i*7+5]); //data.second.asset (PPtr<Object>)\n\t\t\t\t\tvalueFields[i*8+6].Read(&values[i*5+3], &pContainerTable->GetTemplateField()->children[1].children[1].children[2].children[0], 0, NULL); //data.second.asset.fileID\n\t\t\t\t\tvalueFields[i*8+7].Read(&values[i*5+4], &pContainerTable->GetTemplateField()->children[1].children[1].children[2].children[1], 0, NULL); //data.second.asset.pathID\n\n\t\t\t\t\tchar *curName = containerArray[i].name;\n\t\t\t\t\tif (curName == NULL)\n\t\t\t\t\t\tcurName = nullChar;\n\t\t\t\t\tvalues[i*5] = AssetTypeValue(ValueType_String, curName);\n\t\t\t\t\tvalues[i*5+1] = AssetTypeValue(pContainerTable->GetTemplateField()->children[1].children[1].children[0].valueType, &containerArray[i].preloadIndex);\n\t\t\t\t\tvalues[i*5+2] = AssetTypeValue(pContainerTable->GetTemplateField()->children[1].children[1].children[1].valueType, &containerArray[i].preloadSize);\n\t\t\t\t\tvalues[i*5+3] = AssetTypeValue(pContainerTable->GetTemplateField()->children[1].children[1].children[2].children[0].valueType, &containerArray[i].ids.fileId);\n\t\t\t\t\tvalues[i*5+4] = AssetTypeValue(pContainerTable->GetTemplateField()->children[1].children[1].children[2].children[1].valueType, &containerArray[i].ids.pathId);\n\t\t\t\t}\n\n\t\t\t\tpAssetType->SetChildList(pContainerTable, dataPointerList, containerArrayLen, true);\n\t\t\t\tif (pContainerTable->GetValue() != NULL)\n\t\t\t\t\tpContainerTable->GetValue()->AsArray()->size = containerArrayLen;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpContainerTable->SetChildrenList(pContainerTable->GetChildrenList(), pContainerTable->GetChildrenCount());\n\t\t\tif (pContainerTable->GetValue() != NULL)\n\t\t\t\tpContainerTable->GetValue()->AsArray()->size = containerArrayLen;\n\t\t\tfor (uint32_t i = 0; i < containerArrayLen; i++)\n\t\t\t{\n\t\t\t\t{\n\t\t\t\t\tchar *curName = containerArray[i].name;\n\t\t\t\t\tif (curName == NULL)\n\t\t\t\t\t\tcurName = &_nullChar;\n\t\t\t\t\tAssetTypeValue valueTmp = AssetTypeValue(pContainerTable->GetTemplateField()->children[1].children[0].valueType, curName);\n\t\t\t\t\tmemcpy(pContainerTable->Get(i)->Get(0U)->GetValue(), &valueTmp, sizeof(AssetTypeValue));\n\t\t\t\t}\n\t\t\t\t{\n\t\t\t\t\tAssetTypeValue valueTmp = AssetTypeValue(\n\t\t\t\t\t\tpContainerTable->GetTemplateField()->children[1].children[1].children[0].valueType, &containerArray[i].preloadIndex);\n\t\t\t\t\tmemcpy(pContainerTable->Get(i)->Get(1)->Get(0U)->GetValue(), &valueTmp, sizeof(AssetTypeValue));\n\t\t\t\t}\n\t\t\t\t{\n\t\t\t\t\tAssetTypeValue valueTmp = AssetTypeValue(\n\t\t\t\t\t\tpContainerTable->GetTemplateField()->children[1].children[1].children[1].valueType, &containerArray[i].preloadSize);\n\t\t\t\t\tmemcpy(pContainerTable->Get(i)->Get(1)->Get(1)->GetValue(), &valueTmp, sizeof(AssetTypeValue));\n\t\t\t\t}\n\t\t\t\t{\n\t\t\t\t\tAssetTypeValue valueTmp = AssetTypeValue(\n\t\t\t\t\t\tpContainerTable->GetTemplateField()->children[1].children[1].children[2].children[0].valueType, &containerArray[i].ids.fileId);\n\t\t\t\t\tmemcpy(pContainerTable->Get(i)->Get(1)->Get(2)->Get(0U)->GetValue(), &valueTmp, sizeof(AssetTypeValue));\n\t\t\t\t}\n\t\t\t\t{\n\t\t\t\t\tAssetTypeValue valueTmp = AssetTypeValue(\n\t\t\t\t\t\tpContainerTable->GetTemplateField()->children[1].children[1].children[2].children[1].valueType, &containerArray[i].ids.pathId);\n\t\t\t\t\tmemcpy(pContainerTable->Get(i)->Get(1)->Get(2)->Get(1)->GetValue(), &valueTmp, sizeof(AssetTypeValue));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nASSETSTOOLS_API bool AssetBundleAsset::WriteBundleFile(void *buffer, size_t bufferLen, size_t *size, bool bigEndian)\n{\n\tif (!isRead || !pAssetType->GetBaseField())\n\t\treturn false;\n\tif (unityVersion == -1)\n\t{\n\t\tIAssetsWriter *pWriter = Create_AssetsWriterToMemory(buffer, (QWORD)bufferLen);\n\t\tif (pWriter == NULL)\n\t\t\treturn false;\n\t\t*size = (int)pAssetType->GetBaseField()->Write(pWriter, 0, bigEndian);\n\t\tFree_AssetsWriter(pWriter);\n\t\treturn true;\n\t}\n\tint filePos = 0;\n\tint iTmp = (int)strlen(name);\n\tfmwrite(&iTmp, 4);\n\tfmwrite(name, iTmp);\n\tfmwalign();\n\n\tfmwrite(&preloadArrayLen, 4);\n\tfor (uint32_t i = 0; i < preloadArrayLen; i++)\n\t{\n\t\tfmwrite(&preloadArray[i].fileId, 4);\n\t\tfmwrite(&preloadArray[i].pathId, ((unityVersion>=0x0E)?8:4));\n\t}\n\n\tfmwrite(&containerArrayLen, 4);\n\tfor (uint32_t i = 0; i < containerArrayLen; i++)\n\t{\n\t\tContainerData *cd = &containerArray[i];\n\n\t\tif (cd->name != NULL)\n\t\t{\n\t\t\tiTmp = (int)strlen(cd->name);\n\t\t\tfmwrite(&iTmp, 4);\n\t\t\tfmwrite(cd->name, iTmp);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tiTmp = 0;\n\t\t\tfmwrite(&iTmp, 4);\n\t\t}\n\t\tfmwalign();\n\n\t\tfmwrite(&cd->preloadIndex, 4);\n\t\tfmwrite(&cd->preloadSize, 4);\n\t\tfmwrite(&cd->ids.fileId, 4);\n\t\tfmwrite(&cd->ids.pathId, ((unityVersion>=0x0E)?8:4));\n\t}\n\n\t{\n\t\tContainerData *cd = &mainAsset;\n\n\t\tfmwrite(&cd->preloadIndex, 4);\n\t\tfmwrite(&cd->preloadSize, 4);\n\t\tfmwrite(&cd->ids.fileId, 4);\n\t\tfmwrite(&cd->ids.pathId, ((unityVersion>=0x0E)?8:4));\n\t}\n\t\n\tif (unityVersion < 0x0E)\n\t{\n\t\tfmwrite(&scriptCompatibilityArrayLen, 4);\n\t\tfor (int i = 0; i < scriptCompatibilityArrayLen; i++)\n\t\t{\n\t\t\tScriptCompatibilityData *scd = &scriptCompatibilityArray[i];\n\n\t\t\tiTmp = (int)strlen(scd->className);\n\t\t\tfmwrite(&iTmp, 4);\n\t\t\tfmwrite(scd->className, iTmp);\n\t\t\tfmwalign();\n\n\t\t\tiTmp = (int)strlen(scd->namespaceName);\n\t\t\tfmwrite(&iTmp, 4);\n\t\t\tfmwrite(scd->namespaceName, iTmp);\n\t\t\tfmwalign();\n\n\t\t\tiTmp = (int)strlen(scd->assemblyName);\n\t\t\tfmwrite(&iTmp, 4);\n\t\t\tfmwrite(scd->assemblyName, iTmp);\n\t\t\tfmwalign();\n\n\t\t\tfmwrite(&scd->hash, 4);\n\t\t}\n\t\n\t\tfmwrite(&classCompatibilityArrayLen, 4);\n\t\tfor (int i = 0; i < classCompatibilityArrayLen; i++)\n\t\t{\n\t\t\tfmwrite(&classCompatibilityArray[i].first, 4);\n\t\t\tfmwrite(&classCompatibilityArray[i].second, 4);\n\t\t}\n\t}\n\n\tfmwrite(&runtimeCompatibility, 4);\n\n\tif (unityVersion >= 0x0E)\n\t{\n\t\tiTmp = (int)strlen(assetBundleName);\n\t\tfmwrite(&iTmp, 4);\n\t\tfmwrite(assetBundleName, iTmp);\n\t\tfmwalign();\n\n\t\tfmwrite(&dependenciesArrayLen, 4);\n\t\tfor (int i = 0; i < dependenciesArrayLen; i++)\n\t\t{\n\t\t\tiTmp = (int)strlen(dependencies[i]);\n\t\t\tfmwrite(&iTmp, 4);\n\t\t\tfmwrite(dependencies[i], iTmp);\n\t\t\tfmwalign();\n\t\t}\n\n\t\tiTmp = (int)isStreamedSceneAssetBundle;\n\t\tfmwrite(&iTmp, 4);\n\t}\n\n\t*size = filePos;\n\treturn true;\n}\n\nASSETSTOOLS_API int AssetBundleAsset::GetFileSize()\n{\n\tif (!isRead || !this->pAssetType->GetBaseField())\n\t\treturn -1;\n\tif (unityVersion == -1)\n\t{\n\t\treturn (int)this->pAssetType->GetBaseField()->GetByteSize();//this->pBaseValueField->GetByteSize();\n\t}\n\tint ret = 0;\n\tret += 4; //strlen(name)\n\tif (name)\n\t\tret += _fmalign(strlen(name));\n\tret += 4; //preloadArrayLen\n\tif (preloadArray)\n\t\tret += preloadArrayLen * ((unityVersion>=0x0E)?12:8);\n\tret += 4; //containerArrayLen\n\tif (containerArray)\n\t{\n\t\tfor (uint32_t i = 0; i < containerArrayLen; i++)\n\t\t{\n\t\t\tret += 4; //strlen(name)\n\t\t\tif (containerArray[i].name)\n\t\t\t\tret += _fmalign(strlen(containerArray[i].name));\n\t\t}\n\t\tret += (8 + ((unityVersion>=0x0E)?12:8)) * containerArrayLen;\n\t}\n\n\tret += (8 + ((unityVersion>=0x0E)?12:8));\n\t\n\tif (unityVersion < 0x0E)\n\t{\n\t\tret += 4; //scriptCompatibilityArrayLen\n\t\tif (scriptCompatibilityArray)\n\t\t{\n\t\t\tfor (int i = 0; i < scriptCompatibilityArrayLen; i++)\n\t\t\t{\n\t\t\t\tScriptCompatibilityData *sca = &scriptCompatibilityArray[i];\n\t\t\t\tret += 4; //strlen(className)\n\t\t\t\tif (sca->className)\n\t\t\t\t\tret += _fmalign(strlen(sca->className));\n\t\t\t\tret += 4; //strlen(namespaceName)\n\t\t\t\tif (sca->namespaceName)\n\t\t\t\t\tret += _fmalign(strlen(sca->namespaceName));\n\t\t\t\tret += 4; //strlen(assemblyName)\n\t\t\t\tif (sca->assemblyName)\n\t\t\t\t\tret += _fmalign(strlen(sca->assemblyName));\n\n\t\t\t\tret += 4; //hash\n\t\t\t}\n\t\t}\n\n\t\tret += 4; //classCompatibilityArrayLen\n\t\tif (classCompatibilityArray)\n\t\t\tret += classCompatibilityArrayLen * sizeof(ClassCompatibilityData);\n\t}\n\n\tret += 4; //runtimeCompatibility\n\n\tif (unityVersion >= 0x0E)\n\t{\n\t\tret += 4; //strlen(assetBundleName)\n\t\tif (assetBundleName != NULL)\n\t\t\tret += _fmalign(strlen(assetBundleName));\n\n\t\tret += 4; //dependenciesArrayLen\n\t\tfor (int i = 0; i < dependenciesArrayLen; i++)\n\t\t{\n\t\t\tret += 4; //strlen(dependencies[i])\n\t\t\tif (dependencies[i] != NULL)\n\t\t\t\tret += _fmalign(strlen(dependencies[i]));\n\t\t}\n\n\t\tret += _fmalign(1); //isStreamedSceneAssetBundle\n\t}\n\treturn ret;\n}\n\nASSETSTOOLS_API AssetBundleAsset::AssetBundleAsset()\n{\n\tisModified = false;\n\tisRead = false;\n\tunityVersion = 0;\n\tpAssetType = NULL;\n\t//pBaseValueField = NULL;\n\tname = NULL;\n\tpreloadArrayLen = 0;\n\tpreloadArray = NULL;\n\tcontainerArrayLen = 0;\n\tcontainerArray = NULL;\n\tmemset(&mainAsset, 0, sizeof(ContainerData));\n\tscriptCompatibilityArrayLen = 0;\n\tscriptCompatibilityArray = NULL;\n\tclassCompatibilityArrayLen = 0;\n\tclassCompatibilityArray = NULL;\n\truntimeCompatibility = 0;\n\tassetBundleName = NULL;\n\tdependenciesArrayLen = 0;\n\tdependencies = NULL;\n}\n\nASSETSTOOLS_API void AssetBundleAsset::Clear()\n{\n\tif (!isRead)\n\t\treturn;\n\tisRead = false;\n\tif (pAssetType != NULL)\n\t{\n\t\tdelete pAssetType; pAssetType = NULL;\n\t}\n\tif (name != NULL)\n\t{\n\t\tdelete[] name; name = NULL;\n\t}\n\tif (preloadArray != NULL)\n\t{\n\t\tdelete[] preloadArray; preloadArray = NULL;\n\t\tpreloadArrayLen = 0;\n\t}\n\tif (containerArray != NULL)\n\t{\n\t\tfor (uint32_t i = 0; i < containerArrayLen; i++)\n\t\t{\n\t\t\tif (containerArray[i].name != NULL)\n\t\t\t\tdelete[] containerArray[i].name;\n\t\t}\n\t\tdelete[] containerArray; containerArray = NULL;\n\t\tcontainerArrayLen = 0;\n\t}\n\tif (scriptCompatibilityArray != NULL)\n\t{\n\t\tfor (int i = 0; i < scriptCompatibilityArrayLen; i++)\n\t\t{\n\t\t\tScriptCompatibilityData *sca = &scriptCompatibilityArray[i];\n\t\t\tif (sca->className != NULL)\n\t\t\t\tdelete[] sca->className;\n\t\t\tif (sca->namespaceName != NULL)\n\t\t\t\tdelete[] sca->namespaceName;\n\t\t\tif (sca->assemblyName != NULL)\n\t\t\t\tdelete[] sca->assemblyName;\n\t\t}\n\t\tdelete[] scriptCompatibilityArray; scriptCompatibilityArray = NULL;\n\t\tscriptCompatibilityArrayLen = 0;\n\t}\n\tif (classCompatibilityArray != NULL)\n\t{\n\t\tdelete[] classCompatibilityArray; classCompatibilityArray = NULL;\n\t\tclassCompatibilityArrayLen = 0;\n\t}\n\tif (assetBundleName != NULL)\n\t{\n\t\tdelete[] assetBundleName; assetBundleName = NULL;\n\t}\n\tif (dependencies != NULL)\n\t{\n\t\tfor (int i = 0; i < dependenciesArrayLen; i++)\n\t\t\tdelete[] dependencies[i];\n\t\tdelete[] dependencies; dependencies = NULL;\n\t\tdependenciesArrayLen = 0;\n\t}\n}\n\nASSETSTOOLS_API AssetBundleAsset::~AssetBundleAsset()\n{\n\tthis->Clear();\n}\n\nASSETSTOOLS_API bool AssetBundleAsset::ReadBundleFile(void *data, size_t dataLen, size_t *filePos, AssetTypeTemplateField *pBaseField, bool bigEndian)\n{\n\tClear();\n\tunityVersion = -1;\n\tIAssetsReader *pReader = Create_AssetsReaderFromMemory(data, dataLen, false);\n\tif (pReader == NULL)\n\t\treturn false;\n\n\tAssetTypeInstance *pType = new AssetTypeInstance(1, &pBaseField, (QWORD)dataLen, pReader, bigEndian);\n\t//pBaseField->MakeValue(pReader, 0, &pFile);\n\tFree_AssetsReader(pReader);\n\t//this->pBaseValueField = pFile;\n\tAssetTypeValueField *pFile = pType->GetBaseField();\n\tif (!pFile || pFile->IsDummy())\n\t{\n\t\tdelete pType;\n\t\treturn false;\n\t}\n\tthis->pAssetType = pType;\n\n\tAssetTypeValue *nameValue = (*pFile)["m_Name"]->GetValue();\n\tif (nameValue != NULL)\n\t{\n\t\tchar *nameString = nameValue->AsString();\n\t\tname = new char[strlen(nameString)+1];\n\t\tstrcpy(name, nameString);\n\t\t//name = nameValue->AsString();\n\t}\n\telse\n\t\tname = NULL;\n\tAssetTypeValueField *preloadTable = pFile->Get("m_PreloadTable")->Get(0U); //Base.m_PreloadTable.Array\n\tif (preloadTable->IsDummy())\n\t\tpreloadArrayLen = 0;\n\telse\n\t\tpreloadArrayLen = preloadTable->GetChildrenCount();\n\tpreloadArray = new PreloadData[preloadArrayLen];\n\tfor (uint32_t i = 0; i < preloadArrayLen; i++)\n\t{\n\t\tAssetTypeValueField *dataItem = preloadTable->Get(i);\n\t\tAssetTypeValueField *fileIDItem = (*dataItem)["m_FileID"];\n\t\tAssetTypeValueField *pathIDItem = (*dataItem)["m_PathID"];\n\t\tif (fileIDItem->GetValue())\n\t\t\tpreloadArray[i].fileId = fileIDItem->GetValue()->AsInt();\n\t\telse\n\t\t\tpreloadArray[i].fileId = 0;\n\t\tif (pathIDItem->GetValue())\n\t\t\tpreloadArray[i].pathId = pathIDItem->GetValue()->AsInt64();\n\t\telse\n\t\t\tpreloadArray[i].pathId = 0;\n\t}\n\n\tAssetTypeValueField *pContainerList = pFile->Get("m_Container")->Get(0U);\n\tif (pContainerList->IsDummy())\n\t\tcontainerArrayLen = 0;\n\telse\n\t\tcontainerArrayLen = pContainerList->GetChildrenCount();\n\tcontainerArray = new ContainerData[containerArrayLen];\n\tmemset(containerArray, 0, containerArrayLen * sizeof(ContainerData));\n\tfor (uint32_t i = 0; i < containerArrayLen; i++)\n\t{\n\t\tAssetTypeValueField *dataItem = pContainerList->Get(i);\n\t\tAssetTypeValueField *nameItem = (*dataItem)["first"];\n\t\tif (nameItem->GetValue())\n\t\t{\n\t\t\tchar *nameString = nameItem->GetValue()->AsString();\n\t\t\tcontainerArray[i].name = new char[strlen(nameString)+1];\n\t\t\tstrcpy(containerArray[i].name, nameString);\n\t\t\t//containerArray[i].name = nameItem->GetValue()->AsString();\n\t\t}\n\t\telse\n\t\t\tcontainerArray[i].name = NULL;\n\t\tAssetTypeValueField *assetItem = (*dataItem)["second"];\n\t\tAssetTypeValueField *preloadIndexItem = (*assetItem)["preloadIndex"];\n\t\tif (preloadIndexItem->GetValue())\n\t\t\tcontainerArray[i].preloadIndex = preloadIndexItem->GetValue()->AsInt();\n\t\tAssetTypeValueField *preloadSizeItem = (*assetItem)["preloadSize"];\n\t\tif (preloadSizeItem->GetValue())\n\t\t\tcontainerArray[i].preloadSize = preloadSizeItem->GetValue()->AsInt();\n\t\tAssetTypeValueField *fileIDItem = (*assetItem)["asset"]->Get("m_FileID");\n\t\tif (fileIDItem->GetValue())\n\t\t\tcontainerArray[i].ids.fileId = fileIDItem->GetValue()->AsInt();\n\t\tAssetTypeValueField *pathIDItem = (*assetItem)["asset"]->Get("m_PathID");\n\t\tif (pathIDItem->GetValue())\n\t\t\tcontainerArray[i].ids.pathId = pathIDItem->GetValue()->AsInt64();\n\t}\n\n\t{//main asset\n\t\t\n\t\tAssetTypeValueField *mainAssetItem = pFile->Get("m_MainAsset");\n\t\tmainAsset.name = NULL;\n\n\t\tAssetTypeValueField *preloadIndexItem = (*mainAssetItem)["preloadIndex"];\n\t\tif (preloadIndexItem->GetValue())\n\t\t\tmainAsset.preloadIndex = preloadIndexItem->GetValue()->AsInt();\n\t\tAssetTypeValueField *preloadSizeItem = (*mainAssetItem)["preloadSize"];\n\t\tif (preloadSizeItem->GetValue())\n\t\t\tmainAsset.preloadSize = preloadSizeItem->GetValue()->AsInt();\n\t\tAssetTypeValueField *fileIDItem = (*mainAssetItem)["asset"]->Get("m_FileID");\n\t\tif (fileIDItem->GetValue())\n\t\t\tmainAsset.ids.fileId = fileIDItem->GetValue()->AsInt();\n\t\tAssetTypeValueField *pathIDItem = (*mainAssetItem)["asset"]->Get("m_PathID");\n\t\tif (pathIDItem->GetValue())\n\t\t\tmainAsset.ids.pathId = pathIDItem->GetValue()->AsInt64();\n\t}\n\tAssetTypeValueField *runtimeCompatibilityItem = pFile->Get("m_RuntimeCompatibility");\n\tif (runtimeCompatibilityItem->GetValue())\n\t\truntimeCompatibility = runtimeCompatibilityItem->GetValue()->AsUInt();\n\tisRead = true;\n\treturn true;\n}\nASSETSTOOLS_API void AssetBundleAsset::ReadBundleFile(void *data, size_t dataLen, size_t *filePos, int assetsVersion, bool bigEndian)\n{\n\tClear();\n\tunityVersion = assetsVersion;\n\tisModified = false;\n\t{\n\t\tint nameSize; fmread(&nameSize, 4);\n\t\tif (bigEndian)\n\t\t\tSwapEndians_(nameSize);\n\t\tname = new char[nameSize+1];\n\t\tfmread(name, nameSize); name[nameSize] = 0;\n\t\tfmalign();\n\t}\n\n\tfmread(&preloadArrayLen, 4);\n\tif (bigEndian)\n\t\tSwapEndians_(preloadArrayLen);\n\tpreloadArray = new PreloadData[preloadArrayLen];\n\tfor (uint32_t i = 0; i < preloadArrayLen; i++)\n\t{\n\t\tfmread(&preloadArray[i].fileId, 4);\n\t\tif (bigEndian)\n\t\t\tSwapEndians_(preloadArray[i].fileId);\n\t\tpreloadArray[i].pathId = 0;\n\t\tif (assetsVersion>=0x0E)\n\t\t{\n\t\t\tfmread(&preloadArray[i].pathId, 8);\n\t\t\tif (bigEndian)\n\t\t\t\tSwapEndians_(preloadArray[i].pathId);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfmread(&preloadArray[i].pathId, 4);\n\t\t\tif (bigEndian)\n\t\t\t\tSwapEndians_(*(uint32_t*)&preloadArray[i].pathId);\n\t\t}\n\t}\n\n\tfmread(&containerArrayLen, 4);\n\tif (bigEndian)\n\t\tSwapEndians_(containerArrayLen);\n\tcontainerArray = new ContainerData[containerArrayLen];\n\tfor (uint32_t i = 0; i < containerArrayLen; i++)\n\t{\n\t\tint assetNameSize; fmread(&assetNameSize, 4);\n\t\tif (bigEndian)\n\t\t\tSwapEndians_(assetNameSize);\n\t\tchar *assetName = new char[assetNameSize+1];\n\t\tfmread(assetName, assetNameSize); assetName[assetNameSize] = 0;\n\t\tcontainerArray[i].name = assetName;\n\t\tfmalign();\n\n\t\tfmread(&containerArray[i].preloadIndex, 4);\n\t\tif (bigEndian)\n\t\t\tSwapEndians_(containerArray[i].preloadIndex);\n\t\tfmread(&containerArray[i].preloadSize, 4);\n\t\tif (bigEndian)\n\t\t\tSwapEndians_(containerArray[i].preloadSize);\n\t\tfmread(&containerArray[i].ids.fileId, 4);\n\t\tif (bigEndian)\n\t\t\tSwapEndians_(containerArray[i].ids.fileId);\n\t\tcontainerArray[i].ids.pathId = 0;\n\t\tif (assetsVersion>=0x0E)\n\t\t{\n\t\t\tfmread(&containerArray[i].ids.pathId, 8);\n\t\t\tif (bigEndian)\n\t\t\t\tSwapEndians_(containerArray[i].ids.pathId);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfmread(&containerArray[i].ids.pathId, 4);\n\t\t\tif (bigEndian)\n\t\t\t\tSwapEndians_(*(uint32_t*)&containerArray[i].ids.pathId);\n\t\t}\n\t}\n\n\t{//main asset\n\t\tmainAsset.name = NULL;\n\t\tfmread(&mainAsset.preloadIndex, 4);\n\t\tif (bigEndian)\n\t\t\tSwapEndians_(mainAsset.preloadIndex);\n\t\tfmread(&mainAsset.preloadSize, 4);\n\t\tif (bigEndian)\n\t\t\tSwapEndians_(mainAsset.preloadSize);\n\t\tfmread(&mainAsset.ids.fileId, 4);\n\t\tif (bigEndian)\n\t\t\tSwapEndians_(mainAsset.ids.fileId);\n\t\tmainAsset.ids.pathId = 0;\n\t\tif (assetsVersion>=0x0E)\n\t\t{\n\t\t\tfmread(&mainAsset.ids.pathId, 8);\n\t\t\tif (bigEndian)\n\t\t\t\tSwapEndians_(mainAsset.ids.pathId);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfmread(&mainAsset.ids.pathId, 4);\n\t\t\tif (bigEndian)\n\t\t\t\tSwapEndians_(*(uint32_t*)&mainAsset.ids.pathId);\n\t\t}\n\t}\n\n\tif (assetsVersion < 0x0E)\n\t{\n\t\tfmread(&scriptCompatibilityArrayLen, 4);\n\t\tif (bigEndian)\n\t\t\tSwapEndians_(scriptCompatibilityArrayLen);\n\t\tscriptCompatibilityArray = new ScriptCompatibilityData[scriptCompatibilityArrayLen];\n\t\tfor (int i = 0; i < scriptCompatibilityArrayLen; i++)\n\t\t{\n\t\t\tint classNameSize; fmread(&classNameSize, 4);\n\t\t\tif (bigEndian)\n\t\t\t\tSwapEndians_(classNameSize);\n\t\t\tchar *className = new char[classNameSize+1];\n\t\t\tfmread(className, classNameSize); className[classNameSize] = 0;\n\t\t\tscriptCompatibilityArray[i].className = className;\n\t\t\tfmalign();\n\n\t\t\tint nameSpaceSize; fmread(&nameSpaceSize, 4);\n\t\t\tif (bigEndian)\n\t\t\t\tSwapEndians_(nameSpaceSize);\n\t\t\tchar *nameSpace = new char[nameSpaceSize+1];\n\t\t\tfmread(nameSpace, nameSpaceSize); nameSpace[nameSpaceSize] = 0;\n\t\t\tscriptCompatibilityArray[i].namespaceName = nameSpace;\n\t\t\tfmalign();\n\n\t\t\tint assemblyNameSize; fmread(&assemblyNameSize, 4);\n\t\t\tif (bigEndian)\n\t\t\t\tSwapEndians_(assemblyNameSize);\n\t\t\tchar *assemblyName = new char[assemblyNameSize+1];\n\t\t\tfmread(assemblyName, assemblyNameSize); assemblyName[assemblyNameSize] = 0;\n\t\t\tscriptCompatibilityArray[i].assemblyName = assemblyName;\n\t\t\tfmalign();\n\n\t\t\tunsigned int hash; fmread(&hash, 4);\n\t\t\tif (bigEndian)\n\t\t\t\tSwapEndians_(hash);\n\t\t\tscriptCompatibilityArray[i].hash = hash;\n\t\t}\n\n\t\tfmread(&classCompatibilityArrayLen, 4);\n\t\tif (bigEndian)\n\t\t\tSwapEndians_(classCompatibilityArrayLen);\n\t\tclassCompatibilityArray = new ClassCompatibilityData[classCompatibilityArrayLen];\n\t\tfor (int i = 0; i < classCompatibilityArrayLen; i++)\n\t\t{\n\t\t\tfmread(&classCompatibilityArray[i].first, 4);\n\t\t\tif (bigEndian)\n\t\t\t\tSwapEndians_(classCompatibilityArray[i].first);\n\t\t\tfmread(&classCompatibilityArray[i].second, 4);\n\t\t\tif (bigEndian)\n\t\t\t\tSwapEndians_(classCompatibilityArray[i].second);\n\t\t}\n\t}\n\telse\n\t{\n\t\tscriptCompatibilityArrayLen = 0;\n\t\tscriptCompatibilityArray = NULL;\n\t\tclassCompatibilityArrayLen = 0;\n\t\tclassCompatibilityArray = NULL;\n\t}\n\tfmread(&this->runtimeCompatibility, 4);\n\tif (bigEndian)\n\t\tSwapEndians_(this->runtimeCompatibility);\n\tif (assetsVersion >= 0x0E)\n\t{\n\t\tint assetBundleNameSize; fmread(&assetBundleNameSize, 4);\n\t\tif (bigEndian)\n\t\t\tSwapEndians_(assetBundleNameSize);\n\t\tassetBundleName = new char[assetBundleNameSize+1];\n\t\tfmread(assetBundleName, assetBundleNameSize); assetBundleName[assetBundleNameSize] = 0;\n\t\tfmalign();\n\n\t\tfmread(&dependenciesArrayLen, 4);\n\t\tif (bigEndian)\n\t\t\tSwapEndians_(dependenciesArrayLen);\n\t\tdependencies = new char*[dependenciesArrayLen];\n\t\tfor (int i = 0; i < dependenciesArrayLen; i++)\n\t\t{\n\t\t\tint dependencyNameSize; fmread(&dependencyNameSize, 4);\n\t\t\tif (bigEndian)\n\t\t\t\tSwapEndians_(dependencyNameSize);\n\t\t\tdependencies[i] = new char[dependencyNameSize+1];\n\t\t\tfmread(dependencies[i], dependencyNameSize); dependencies[i][dependencyNameSize] = 0;\n\t\t\tfmalign();\n\t\t}\n\n\t\tfmread(&isStreamedSceneAssetBundle, 1);\n\t\tuint32_t dwTmp;\n\t\tfmread(&dwTmp, 3);\n\t}\n\tisRead = true;\n}\n\n\nASSETSTOOLS_API void ASSETBUNDLEASSET_DecreaseIndexRefs(AssetBundleAsset *pFile, int iToRemove)\n{\n\tfor (uint32_t i = 0; i < pFile->containerArrayLen; i++)\n\t{\n\t\tContainerData *cd = &pFile->containerArray[i];\n\t\tint minIndex = cd->preloadIndex;\n\t\tif ((minIndex > iToRemove))\n\t\t{\n\t\t\tcd->preloadIndex--;\n\t\t}\n\t}\n}\nASSETSTOOLS_API void ASSETBUNDLEASSET_IncreaseIndexRefs(AssetBundleAsset *pFile, int iToAdd)\n{\n\tfor (uint32_t i = 0; i < pFile->containerArrayLen; i++)\n\t{\n\t\tContainerData *cd = &pFile->containerArray[i];\n\t\tint minIndex = cd->preloadIndex;\n\t\tif ((minIndex >= iToAdd))\n\t\t{\n\t\t\tcd->preloadIndex++;\n\t\t}\n\t}\n}\nASSETSTOOLS_API void ASSETBUNDLEASSET_Optimize(AssetBundleAsset *pFile)\n{\n\tfor (uint32_t i = 0; i < pFile->preloadArrayLen; i++)\n\t{\n\t\tPreloadData *pd = &pFile->preloadArray[i];\n\t\tbool found = false;\n\t\tfor (uint32_t k = 0; k < pFile->containerArrayLen; k++)\n\t\t{\n\t\t\tContainerData *cd = &pFile->containerArray[k];\n\t\t\tuint32_t minIndex = (uint32_t)cd->preloadIndex;\n\t\t\tuint32_t maxIndex = (uint32_t)(minIndex + cd->preloadSize - 1);\n\t\t\tif (minIndex > maxIndex)\n\t\t\t\tcontinue;\n\t\t\tif ((i >= minIndex) && (i <= maxIndex))\n\t\t\t{\n\t\t\t\tfound = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!found)\n\t\t{\n\t\t\tASSETBUNDLEASSET_DecreaseIndexRefs(pFile, i);\n\t\t\tPreloadData *newPd = new PreloadData[pFile->preloadArrayLen-1];\n\t\t\tif (i > 0)\n\t\t\t\tmemcpy(newPd, pFile->preloadArray, sizeof(PreloadData) * (i-1));\n\t\t\tfor (uint32_t _i = i+1; _i < pFile->preloadArrayLen; _i++)\n\t\t\t\tmemcpy(&newPd[_i-1], &pFile->preloadArray[_i], sizeof(PreloadData));\n\t\t\tpFile->preloadArrayLen--;\n\t\t\tdelete[] pFile->preloadArray;\n\t\t\tpFile->preloadArray = newPd;\n\t\t\ti--;\n\t\t}\n\t}\n}\nASSETSTOOLS_API int ASSETBUNDLEASSET_GetRefCount(AssetBundleAsset *pFile, int preloadIndex)\n{\n\tint ret = 0;\n\tbool found = false;\n\tfor (uint32_t k = 0; k < pFile->containerArrayLen; k++)\n\t{\n\t\tContainerData *cd = &pFile->containerArray[k];\n\t\tint minIndex = cd->preloadIndex;\n\t\tint maxIndex = minIndex + cd->preloadSize - 1;\n\t\tif (minIndex > maxIndex)\n\t\t\tcontinue;\n\t\tif ((preloadIndex >= minIndex) && (preloadIndex <= maxIndex))\n\t\t{\n\t\t\tret++;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn ret;\n}\n\nASSETSTOOLS_API int AssetBundleAsset::AddContainer(ContainerData *cd)\n{\n\tPreloadData *newPd = new PreloadData[preloadArrayLen+1];\n\tmemcpy(newPd, preloadArray, sizeof(PreloadData) * preloadArrayLen);\n\n\tnewPd[preloadArrayLen].fileId = cd->ids.fileId;\n\tnewPd[preloadArrayLen].pathId = cd->ids.pathId;\n\tint preloadIndex = preloadArrayLen;\n\n\tpreloadArrayLen++;\n\tdelete[] preloadArray;\n\tpreloadArray = newPd;\n\n\tContainerData *newCd = new ContainerData[containerArrayLen+1];\n\tmemcpy(newCd, containerArray, sizeof(ContainerData) * containerArrayLen);\n\n\tnewCd[containerArrayLen].preloadIndex = preloadIndex;\n\tnewCd[containerArrayLen].preloadSize = 1;\n\tnewCd[containerArrayLen].name = cd->name;\n\tmemcpy(&newCd[containerArrayLen].ids, &cd->ids, sizeof(PreloadData));\n\n\tcontainerArrayLen++;\n\tdelete[] containerArray;\n\tcontainerArray = newCd;\n\n\treturn (preloadArrayLen-1);\n}\nASSETSTOOLS_API void AssetBundleAsset::UpdatePreloadArray(uint32_t containerIndex)\n{\n\tif ((containerArrayLen > containerIndex) && (containerIndex >= 0))\n\t{\n\t\tContainerData *cd = &containerArray[containerIndex];\n\t\tif (preloadArrayLen > (uint32_t)cd->preloadIndex)\n\t\t{\n\t\t\tif (ASSETBUNDLEASSET_GetRefCount(this, cd->preloadIndex) == 1)\n\t\t\t{\n\t\t\t\tpreloadArray[cd->preloadIndex].fileId = cd->ids.fileId;\n\t\t\t\tpreloadArray[cd->preloadIndex].pathId = cd->ids.pathId;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tPreloadData *newPd = new PreloadData[preloadArrayLen+cd->preloadSize];\n\t\t\t\tmemcpy(newPd, preloadArray, sizeof(PreloadData)*preloadArrayLen);\n\t\t\t\tmemcpy(&newPd[preloadArrayLen], &newPd[cd->preloadIndex], sizeof(PreloadData)*cd->preloadSize);\n\n\t\t\t\tnewPd[preloadArrayLen].fileId = cd->ids.fileId;\n\t\t\t\tnewPd[preloadArrayLen].pathId = cd->ids.pathId;\n\t\t\t\tcd->preloadIndex = preloadArrayLen;\n\t\t\t\tpreloadArrayLen += cd->preloadSize;\n\n\t\t\t\tdelete[] preloadArray;\n\t\t\t\tpreloadArray = newPd;\n\n\t\t\t\tASSETBUNDLEASSET_Optimize(this);\n\t\t\t}\n\t\t}\n\t}\n}\nASSETSTOOLS_API void AssetBundleAsset::RemoveContainer(uint32_t index)\n{\n\tif ((containerArrayLen > index) && index >= 0)\n\t{\n\t\tContainerData *newCd = new ContainerData[containerArrayLen-1];\n\n\t\tif (index > 0)\n\t\t\tmemcpy(newCd, containerArray, sizeof(ContainerData) * (index));\n\t\tfor (uint32_t _i = index+1; _i < containerArrayLen; _i++)\n\t\t\tmemcpy(&newCd[_i-1], &containerArray[_i], sizeof(ContainerData));\n\n\t\tcontainerArrayLen--;\n\t\tdelete[] containerArray;\n\t\tcontainerArray = newCd;\n\t\tASSETBUNDLEASSET_Optimize(this);\n\t}\n}'