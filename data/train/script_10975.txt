b'{-# LANGUAGE ScopedTypeVariables, RankNTypes, GeneralizedNewtypeDeriving #-}\n\n-- Testing a concept here.\n\nimport Control.Monad.State.Strict\nimport Control.Monad.ST\nimport Data.STRef\nimport Unsafe.Coerce (unsafeCoerce)\nimport Debug.Trace (trace)\n\nnewtype MyST s a = MyST ((StateT Status (ST s)) a)\n--  deriving (MonadState Status)\n\n-- When the computation is closed, no more binds are allowed.  Nobody\n-- else is allowed to compute in this context.\ndata Status = Open | Closed  \n  deriving Show\n\nunMyST (MyST a) = a\n\ninstance Monad (MyST s) where \n  return x = MyST (return x)\n  -- Whenever the status is set to closed, binding further computations becomes an error:\n  MyST m >>= (f :: a -> MyST s b) = MyST st\n    where \n      st :: (StateT Status (ST s)) b\n      st = do\n        v1 <- m\n        state <- get         \n        case trace ("[!!!] Checking status... it\'s: "++show state) state of \n          Open   -> unMyST (f v1)\n          Closed -> error "Attempt to extend closed MyST computation."\n\nrunMyST :: forall a . ((forall ss . MyST ss a) -> a)\nrunMyST (MyST m) = runST (unsafeCoerce st)\n where \n--   st :: ST s2 a \n--   st :: ST ss a\n   st = evalStateT m Open\n\n\n----------------------------------------------------------------------------------------------------\n\ncloseIt :: MyST s ()\ncloseIt = MyST$ put Closed \n\nforkIt :: (forall s1 . MyST s1 ()) -> (forall s2 . MyST s2 ()) -> MyST s ()\nforkIt (MyST child1) (MyST child2) = MyST $ do\n  -- This would fork the children...\n  -- Then close off the computation:\n  put Closed\n\n\n-- Example 1, close the computation and then try to do something else.\nex1 :: MyST s String\nex1 = do \n--  newSTRef "hmm"\n--  newSTRef "hmm"\n  closeIt\n  return "hello"\n\n\n-- Example 2, close at the end.  This is allowed.\nex2 :: MyST s ()\nex2 = do \n  return "hello"  \n  return "hello"  \n  return "hello"  \n  closeIt\n  \n'