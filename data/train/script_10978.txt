b'using System;\nusing System.Diagnostics;\nusing System.Text;\n\nusing i64 = System.Int64;\nusing u8 = System.Byte;\nusing u32 = System.UInt32;\n\nusing Pgno = System.UInt32;\n\nnamespace CS_SQLite3\n{\n  using sqlite3_int64 = System.Int64;\n\n  public partial class CSSQLite\n  {\n    /*\n    ** 2008 December 3\n    **\n    ** The author disclaims copyright to this source code.  In place of\n    ** a legal notice, here is a blessing:\n    **\n    **    May you do good and not evil.\n    **    May you find forgiveness for yourself and forgive others.\n    **    May you share freely, never taking more than you give.\n    **\n    *************************************************************************\n    **\n    ** This module implements an object we call a "RowSet".\n    **\n    ** The RowSet object is a collection of rowids.  Rowids\n    ** are inserted into the RowSet in an arbitrary order.  Inserts\n    ** can be intermixed with tests to see if a given rowid has been\n    ** previously inserted into the RowSet.\n    **\n    ** After all inserts are finished, it is possible to extract the\n    ** elements of the RowSet in sorted order.  Once this extraction\n    ** process has started, no new elements may be inserted.\n    **\n    ** Hence, the primitive operations for a RowSet are:\n    **\n    **    CREATE\n    **    INSERT\n    **    TEST\n    **    SMALLEST\n    **    DESTROY\n    **\n    ** The CREATE and DESTROY primitives are the constructor and destructor,\n    ** obviously.  The INSERT primitive adds a new element to the RowSet.\n    ** TEST checks to see if an element is already in the RowSet.  SMALLEST\n    ** extracts the least value from the RowSet.\n    **\n    ** The INSERT primitive might allocate additional memory.  Memory is\n    ** allocated in chunks so most INSERTs do no allocation.  There is an\n    ** upper bound on the size of allocated memory.  No memory is freed\n    ** until DESTROY.\n    **\n    ** The TEST primitive includes a "batch" number.  The TEST primitive\n    ** will only see elements that were inserted before the last change\n    ** in the batch number.  In other words, if an INSERT occurs between\n    ** two TESTs where the TESTs have the same batch nubmer, then the\n    ** value added by the INSERT will not be visible to the second TEST.\n    ** The initial batch number is zero, so if the very first TEST contains\n    ** a non-zero batch number, it will see all prior INSERTs.\n    **\n    ** No INSERTs may occurs after a SMALLEST.  An assertion will fail if\n    ** that is attempted.\n    **\n    ** The cost of an INSERT is roughly constant.  (Sometime new memory\n    ** has to be allocated on an INSERT.)  The cost of a TEST with a new\n    ** batch number is O(NlogN) where N is the number of elements in the RowSet.\n    ** The cost of a TEST using the same batch number is O(logN).  The cost\n    ** of the first SMALLEST is O(NlogN).  Second and subsequent SMALLEST\n    ** primitives are constant time.  The cost of DESTROY is O(N).\n    **\n    ** There is an added cost of O(N) when switching between TEST and\n    ** SMALLEST primitives.\n    **\n    **\n    ** $Id: rowset.c,v 1.7 2009/05/22 01:00:13 drh Exp $\n    **\n    *************************************************************************\n    **  Included in SQLite3 port to C#-SQLite;  2008 Noah B Hart\n    **  C#-SQLite is an independent reimplementation of the SQLite software library\n    **\n    **  $Header$\n    *************************************************************************\n    */\n    //#include "sqliteInt.h"\n\n    /*\n    ** Target size for allocation chunks.\n    */\n    //#define ROWSET_ALLOCATION_SIZE 1024\n    const int ROWSET_ALLOCATION_SIZE = 1024;\n    /*\n    ** The number of rowset entries per allocation chunk.\n    */\n    //#define ROWSET_ENTRY_PER_CHUNK  \\\n    //                     ((ROWSET_ALLOCATION_SIZE-8)/sizeof(struct RowSetEntry))\n    const int ROWSET_ENTRY_PER_CHUNK = 63;\n\n    /*\n    ** Each entry in a RowSet is an instance of the following object.\n    */\n    public class RowSetEntry\n    {\n      public i64 v;                /* ROWID value for this entry */\n      public RowSetEntry pRight;   /* Right subtree (larger entries) or list */\n      public RowSetEntry pLeft;    /* Left subtree (smaller entries) */\n    };\n\n    /*\n    ** Index entries are allocated in large chunks (instances of the\n    ** following structure) to reduce memory allocation overhead.  The\n    ** chunks are kept on a linked list so that they can be deallocated\n    ** when the RowSet is destroyed.\n    */\n    public class RowSetChunk\n    {\n      public RowSetChunk pNextChunk;             /* Next chunk on list of them all */\n      public RowSetEntry[] aEntry = new RowSetEntry[ROWSET_ENTRY_PER_CHUNK]; /* Allocated entries */\n    };\n\n    /*\n    ** A RowSet in an instance of the following structure.\n    **\n    ** A typedef of this structure if found in sqliteInt.h.\n    */\n    public class RowSet\n    {\n      public RowSetChunk pChunk;            /* List of all chunk allocations */\n      public sqlite3 db;                    /* The database connection */\n      public RowSetEntry pEntry;            /* /* List of entries using pRight */\n      public RowSetEntry pLast;             /* Last entry on the pEntry list */\n      public RowSetEntry[] pFresh;          /* Source of new entry objects */\n      public RowSetEntry pTree;             /* Binary tree of entries */\n      public int nFresh;                    /* Number of objects on pFresh */\n      public bool isSorted;                 /* True if pEntry is sorted */\n      public u8 iBatch;                     /* Current insert batch */\n\n      public RowSet( sqlite3 db, int N )\n      {\n        this.pChunk = null;\n        this.db = db;\n        this.pEntry = null;\n        this.pLast = null;\n        this.pFresh = new RowSetEntry[N];\n        this.pTree = null;\n        this.nFresh = N;\n        this.isSorted = true;\n        this.iBatch = 0;\n      }\n    };\n\n    /*\n    ** Turn bulk memory into a RowSet object.  N bytes of memory\n    ** are available at pSpace.  The db pointer is used as a memory context\n    ** for any subsequent allocations that need to occur.\n    ** Return a pointer to the new RowSet object.\n    **\n    ** It must be the case that N is sufficient to make a Rowset.  If not\n    ** an assertion fault occurs.\n    **\n    ** If N is larger than the minimum, use the surplus as an initial\n    ** allocation of entries available to be filled.\n    */\n    static RowSet sqlite3RowSetInit( sqlite3 db, object pSpace, u32 N )\n    {\n      RowSet p = new RowSet( db, (int)N );\n      //Debug.Assert(N >= ROUND8(sizeof(*p)) );\n      //  p = pSpace;\n      //  p.pChunk = 0;\n      //  p.db = db;\n      //  p.pEntry = 0;\n      //  p.pLast = 0;\n      //  p.pTree = 0;\n      //  p.pFresh =(struct RowSetEntry*)(ROUND8(sizeof(*p)) + (char*)p);\n      //  p.nFresh = (u16)((N - ROUND8(sizeof(*p)))/sizeof(struct RowSetEntry));\n      //  p.isSorted = 1;\n      //  p.iBatch = 0;\n      return p;\n    }\n\n    /*\n    ** Deallocate all chunks from a RowSet.  This frees all memory that\n    ** the RowSet has allocated over its lifetime.  This routine is\n    ** the destructor for the RowSet.\n    */\n    static void sqlite3RowSetClear( RowSet p )\n    {\n      RowSetChunk pChunk, pNextChunk;\n      for ( pChunk = p.pChunk ; pChunk != null ; pChunk = pNextChunk )\n      {\n        pNextChunk = pChunk.pNextChunk;\n        //sqlite3DbFree( p.db, ref pChunk );\n      }\n      p.pChunk = null;\n      p.nFresh = 0;\n      p.pEntry = null;\n      p.pLast = null;\n      p.pTree = null;\n      p.isSorted = true;\n    }\n\n    /*\n    ** Insert a new value into a RowSet.\n    **\n    ** The mallocFailed flag of the database connection is set if a\n    ** memory allocation fails.\n    */\n    static void sqlite3RowSetInsert( RowSet p, i64 rowid )\n    {\n      RowSetEntry pEntry;       /* The new entry */\n      RowSetEntry pLast;        /* The last prior entry */\n      Debug.Assert( p != null );\n      if ( p.nFresh == 0 )\n      {\n        RowSetChunk pNew;\n        pNew = new RowSetChunk();//sqlite3DbMallocRaw(p.db, sizeof(*pNew));\n        if ( pNew == null )\n        {\n          return;\n        }\n        pNew.pNextChunk = p.pChunk;\n        p.pChunk = pNew;\n        p.pFresh = pNew.aEntry;\n        p.nFresh = ROWSET_ENTRY_PER_CHUNK;\n      }\n      p.pFresh[p.pFresh.Length - p.nFresh] = new RowSetEntry();\n      pEntry = p.pFresh[p.pFresh.Length - p.nFresh];\n      p.nFresh--;\n      pEntry.v = rowid;\n      pEntry.pRight = null;\n      pLast = p.pLast;\n      if ( pLast != null )\n      {\n        if ( p.isSorted && rowid <= pLast.v )\n        {\n          p.isSorted = false;\n        }\n        pLast.pRight = pEntry;\n      }\n      else\n      {\n        Debug.Assert( p.pEntry == null );/* Fires if INSERT after SMALLEST */\n        p.pEntry = pEntry;\n      }\n      p.pLast = pEntry;\n    }\n\n    /*\n    ** Merge two lists of RowSetEntry objects.  Remove duplicates.\n    **\n    ** The input lists are connected via pRight pointers and are\n    ** assumed to each already be in sorted order.\n    */\n    static RowSetEntry rowSetMerge(\n    RowSetEntry pA,    /* First sorted list to be merged */\n    RowSetEntry pB     /* Second sorted list to be merged */\n    )\n    {\n      RowSetEntry head = new RowSetEntry();\n      RowSetEntry pTail;\n\n      pTail = head;\n      while ( pA != null && pB != null )\n      {\n        Debug.Assert( pA.pRight == null || pA.v <= pA.pRight.v );\n        Debug.Assert( pB.pRight == null || pB.v <= pB.pRight.v );\n        if ( pA.v < pB.v )\n        {\n          pTail.pRight = pA;\n          pA = pA.pRight;\n          pTail = pTail.pRight;\n        }\n        else if ( pB.v < pA.v )\n        {\n          pTail.pRight = pB;\n          pB = pB.pRight;\n          pTail = pTail.pRight;\n        }\n        else\n        {\n          pA = pA.pRight;\n        }\n      }\n      if ( pA != null )\n      {\n        Debug.Assert( pA.pRight == null || pA.v <= pA.pRight.v );\n        pTail.pRight = pA;\n      }\n      else\n      {\n        Debug.Assert( pB == null || pB.pRight == null || pB.v <= pB.pRight.v );\n        pTail.pRight = pB;\n      }\n      return head.pRight;\n    }\n\n    /*\n    ** Sort all elements on the pEntry list of the RowSet into ascending order.\n    */\n    static void rowSetSort( RowSet p )\n    {\n      u32 i;\n      RowSetEntry pEntry;\n      RowSetEntry[] aBucket = new RowSetEntry[40];\n\n      Debug.Assert( p.isSorted == false );\n      //memset(aBucket, 0, sizeof(aBucket));\n      while ( p.pEntry != null )\n      {\n        pEntry = p.pEntry;\n        p.pEntry = pEntry.pRight;\n        pEntry.pRight = null;\n        for ( i = 0 ; aBucket[i] != null ; i++ )\n        {\n          pEntry = rowSetMerge( aBucket[i], pEntry );\n          aBucket[i] = null;\n        }\n        aBucket[i] = pEntry;\n      }\n      pEntry = null;\n      for ( i = 0 ; i < aBucket.Length ; i++ )//sizeof(aBucket)/sizeof(aBucket[0])\n      {\n        pEntry = rowSetMerge( pEntry, aBucket[i] );\n      }\n      p.pEntry = pEntry;\n      p.pLast = null;\n      p.isSorted = true;\n    }\n\n    /*\n    ** The input, pIn, is a binary tree (or subtree) of RowSetEntry objects.\n    ** Convert this tree into a linked list connected by the pRight pointers\n    ** and return pointers to the first and last elements of the new list.\n    */\n    static void rowSetTreeToList(\n    RowSetEntry pIn,            /* Root of the input tree */\n    ref RowSetEntry ppFirst,    /* Write head of the output list here */\n    ref RowSetEntry ppLast      /* Write tail of the output list here */\n    )\n    {\n      Debug.Assert( pIn != null );\n      if ( pIn.pLeft != null )\n      {\n        RowSetEntry p = new RowSetEntry();\n        rowSetTreeToList( pIn.pLeft, ref  ppFirst, ref  p );\n        p.pRight = pIn;\n      }\n      else\n      {\n        ppFirst = pIn;\n      }\n      if ( pIn.pRight != null )\n      {\n        rowSetTreeToList( pIn.pRight, ref  pIn.pRight, ref   ppLast );\n      }\n      else\n      {\n        ppLast = pIn;\n      }\n      Debug.Assert( ( ppLast ).pRight == null );\n    }\n\n\n    /*\n    ** Convert a sorted list of elements (connected by pRight) into a binary\n    ** tree with depth of iDepth.  A depth of 1 means the tree contains a single\n    ** node taken from the head of *ppList.  A depth of 2 means a tree with\n    ** three nodes.  And so forth.\n    **\n    ** Use as many entries from the input list as required and update the\n    ** *ppList to point to the unused elements of the list.  If the input\n    ** list contains too few elements, then construct an incomplete tree\n    ** and leave *ppList set to NULL.\n    **\n    ** Return a pointer to the root of the constructed binary tree.\n    */\n    static RowSetEntry rowSetNDeepTree(\n    ref RowSetEntry ppList,\n    int iDepth\n    )\n    {\n      RowSetEntry p;         /* Root of the new tree */\n      RowSetEntry pLeft;     /* Left subtree */\n      if ( ppList == null )\n      {\n        return null;\n      }\n      if ( iDepth == 1 )\n      {\n        p = ppList;\n        ppList = p.pRight;\n        p.pLeft = p.pRight = null;\n        return p;\n      }\n      pLeft = rowSetNDeepTree( ref ppList, iDepth - 1 );\n      p = ppList;\n      if ( p == null )\n      {\n        return pLeft;\n      }\n      p.pLeft = pLeft;\n      ppList = p.pRight;\n      p.pRight = rowSetNDeepTree( ref ppList, iDepth - 1 );\n      return p;\n    }\n\n    /*\n    ** Convert a sorted list of elements into a binary tree. Make the tree\n    ** as deep as it needs to be in order to contain the entire list.\n    */\n    static RowSetEntry rowSetListToTree( RowSetEntry pList )\n    {\n      int iDepth;          /* Depth of the tree so far */\n      RowSetEntry p;       /* Current tree root */\n      RowSetEntry pLeft;   /* Left subtree */\n\n      Debug.Assert( pList != null );\n      p = pList;\n      pList = p.pRight;\n      p.pLeft = p.pRight = null;\n      for ( iDepth = 1 ; pList != null ; iDepth++ )\n      {\n        pLeft = p;\n        p = pList;\n        pList = p.pRight;\n        p.pLeft = pLeft;\n        p.pRight = rowSetNDeepTree( ref pList, iDepth );\n      }\n      return p;\n    }\n\n    /*\n    ** Convert the list in p.pEntry into a sorted list if it is not\n    ** sorted already.  If there is a binary tree on p.pTree, then\n    ** convert it into a list too and merge it into the p.pEntry list.\n    */\n    static void rowSetToList( RowSet p )\n    {\n      if ( !p.isSorted )\n      {\n        rowSetSort( p );\n      }\n      if ( p.pTree != null )\n      {\n        RowSetEntry pHead = new RowSetEntry(), pTail = new RowSetEntry();\n        rowSetTreeToList( p.pTree, ref  pHead, ref  pTail );\n        p.pTree = null;\n        p.pEntry = rowSetMerge( p.pEntry, pHead );\n      }\n    }\n\n    /*\n    ** Extract the smallest element from the RowSet.\n    ** Write the element into *pRowid.  Return 1 on success.  Return\n    ** 0 if the RowSet is already empty.\n    **\n    ** After this routine has been called, the sqlite3RowSetInsert()\n    ** routine may not be called again.\n    */\n    static int sqlite3RowSetNext( RowSet p, ref i64 pRowid )\n    {\n      rowSetToList( p );\n      if ( p.pEntry != null )\n      {\n        pRowid = p.pEntry.v;\n        p.pEntry = p.pEntry.pRight;\n        if ( p.pEntry == null )\n        {\n          sqlite3RowSetClear( p );\n        }\n        return 1;\n      }\n      else\n      {\n        return 0;\n      }\n    }\n\n    /*\n    ** Check to see if element iRowid was inserted into the the rowset as\n    ** part of any insert batch prior to iBatch.  Return 1 or 0.\n    */\n    static int sqlite3RowSetTest( RowSet pRowSet, u8 iBatch, sqlite3_int64 iRowid )\n    {\n      RowSetEntry p;\n      if ( iBatch != pRowSet.iBatch )\n      {\n        if ( pRowSet.pEntry != null )\n        {\n          rowSetToList( pRowSet );\n          pRowSet.pTree = rowSetListToTree( pRowSet.pEntry );\n          pRowSet.pEntry = null;\n          pRowSet.pLast = null;\n        }\n        pRowSet.iBatch = iBatch;\n      }\n      p = pRowSet.pTree;\n      while ( p != null )\n      {\n        if ( p.v < iRowid )\n        {\n          p = p.pRight;\n        }\n        else if ( p.v > iRowid )\n        {\n          p = p.pLeft;\n        }\n        else\n        {\n          return 1;\n        }\n      }\n      return 0;\n    }\n\n  }\n}\n'