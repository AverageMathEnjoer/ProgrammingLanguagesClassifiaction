b'using System;\nusing System.Diagnostics;\nusing System.Text;\n\nusing i64 = System.Int64;\nusing u8 = System.Byte;\nusing u16 = System.UInt16;\nusing u32 = System.UInt32;\nusing u64 = System.UInt64;\nusing sqlite3_int64 = System.Int64;\nusing Pgno = System.UInt32;\nnamespace CS_SQLite3\n{\n  using DbPage = CSSQLite.PgHdr;\n\n  public partial class CSSQLite\n  {\n    /*\n    ** 2004 April 6\n    **\n    ** The author disclaims copyright to this source code.  In place of\n    ** a legal notice, here is a blessing:\n    **\n    **    May you do good and not evil.\n    **    May you find forgiveness for yourself and forgive others.\n    **    May you share freely, never taking more than you give.\n    **\n    *************************************************************************\n    ** $Id: btree.c,v 1.705 2009/08/10 03:57:58 shane Exp $\n    *************************************************************************\n    **  Included in SQLite3 port to C#-SQLite;  2008 Noah B Hart\n    **  C#-SQLite is an independent reimplementation of the SQLite software library\n    **\n    **  $Header$\n    *************************************************************************\n    **\n    ** This file implements a external (disk-based) database using BTrees.\n    ** See the header comment on "btreeInt.h" for additional information.\n    ** Including a description of file format and an overview of operation.\n    */\n    //#include "btreeInt.h"\n\n    /*\n    ** The header string that appears at the beginning of every\n    ** SQLite database.\n    */\n    static string zMagicHeader = SQLITE_FILE_HEADER;\n\n    /*\n    ** Set this global variable to 1 to enable tracing using the TRACE\n    ** macro.\n    */\n#if TRACE \nstatic bool sqlite3BtreeTrace=false;  /* True to enable tracing */\n//# define TRACE(X)  if(sqlite3BtreeTrace){printf X;fflush(stdout);}\nstatic void TRACE(string X, params object[] ap) { if (sqlite3BtreeTrace)  printf(X, ap); }\n#else\n    //# define TRACE(X)\n    static void TRACE(string X, params object[] ap) { }\n#endif\n\n\n\n#if !SQLITE_OMIT_SHARED_CACHE\n/*\n** A list of BtShared objects that are eligible for participation\n** in shared cache.  This variable has file scope during normal builds,\n** but the test harness needs to access it so we make it global for\n** test builds.\n**\n** Access to this variable is protected by SQLITE_MUTEX_STATIC_MASTER.\n*/\n#if SQLITE_TEST\nBtShared *SQLITE_WSD sqlite3SharedCacheList = 0;\n#else\nstatic BtShared *SQLITE_WSD sqlite3SharedCacheList = 0;\n#endif\n#endif //* SQLITE_OMIT_SHARED_CACHE */\n\n#if !SQLITE_OMIT_SHARED_CACHE\n/*\n** Enable or disable the shared pager and schema features.\n**\n** This routine has no effect on existing database connections.\n** The shared cache setting effects only future calls to\n** sqlite3_open(), sqlite3_open16(), or sqlite3_open_v2().\n*/\nint sqlite3_enable_shared_cache(int enable){\nsqlite3GlobalConfig.sharedCacheEnabled = enable;\nreturn SQLITE_OK;\n}\n#endif\n\n\n\n#if SQLITE_OMIT_SHARED_CACHE\n    /*\n** The functions querySharedCacheTableLock(), setSharedCacheTableLock(),\n** and clearAllSharedCacheTableLocks()\n** manipulate entries in the BtShared.pLock linked list used to store\n** shared-cache table level locks. If the library is compiled with the\n** shared-cache feature disabled, then there is only ever one user\n** of each BtShared structure and so this locking is not necessary.\n** So define the lock related functions as no-ops.\n*/\n    //#define querySharedCacheTableLock(a,b,c) SQLITE_OK\n    static int querySharedCacheTableLock(Btree p, Pgno iTab, u8 eLock) { return SQLITE_OK; }\n\n    //#define setSharedCacheTableLock(a,b,c) SQLITE_OK\n    //#define clearAllSharedCacheTableLocks(a)\n    static void clearAllSharedCacheTableLocks(Btree a) { }\n    //#define downgradeAllSharedCacheTableLocks(a)\n    static void downgradeAllSharedCacheTableLocks(Btree a) { }\n    //#define hasSharedCacheTableLock(a,b,c,d) 1\n    static bool hasSharedCacheTableLock(Btree a, Pgno b, int c, int d) { return true; }\n    //#define hasReadConflicts(a, b) 0\n    static bool hasReadConflicts(Btree a, Pgno b) { return false; }\n#endif\n\n#if !SQLITE_OMIT_SHARED_CACHE\n\n#if SQLITE_DEBUG\n/*\n** This function is only used as part of an Debug.Assert() statement. It checks\n** that connection p holds the required locks to read or write to the\n** b-tree with root page iRoot. If so, true is returned. Otherwise, false.\n** For example, when writing to a table b-tree with root-page iRoot via\n** Btree connection pBtree:\n**\n**    Debug.Assert( hasSharedCacheTableLock(pBtree, iRoot, 0, WRITE_LOCK) );\n**\n** When writing to an index b-tree that resides in a sharable database, the\n** caller should have first obtained a lock specifying the root page of\n** the corresponding table b-tree. This makes things a bit more complicated,\n** as this module treats each b-tree as a separate structure. To determine\n** the table b-tree corresponding to the index b-tree being written, this\n** function has to search through the database schema.\n**\n** Instead of a lock on the b-tree rooted at page iRoot, the caller may\n** hold a write-lock on the schema table (root page 1). This is also\n** acceptable.\n*/\nstatic int hasSharedCacheTableLock(\nBtree pBtree,         /* Handle that must hold lock */\nPgno iRoot,            /* Root page of b-tree */\nint isIndex,           /* True if iRoot is the root of an index b-tree */\nint eLockType          /* Required lock type (READ_LOCK or WRITE_LOCK) */\n){\nSchema pSchema = (Schema *)pBtree.pBt.pSchema;\nPgno iTab = 0;\nBtLock pLock;\n\n/* If this b-tree database is not shareable, or if the client is reading\n** and has the read-uncommitted flag set, then no lock is required.\n** In these cases return true immediately.  If the client is reading\n** or writing an index b-tree, but the schema is not loaded, then return\n** true also. In this case the lock is required, but it is too difficult\n** to check if the client actually holds it. This doesn\'t happen very\n** often.  */\nif( (pBtree.sharable==null)\n|| (eLockType==READ_LOCK && (pBtree.db.flags & SQLITE_ReadUncommitted))\n|| (isIndex && (!pSchema || (pSchema.flags&DB_SchemaLoaded)==null ))\n){\nreturn 1;\n}\n\n/* Figure out the root-page that the lock should be held on. For table\n** b-trees, this is just the root page of the b-tree being read or\n** written. For index b-trees, it is the root page of the associated\n** table.  */\nif( isIndex ){\nHashElem p;\nfor(p=sqliteHashFirst(pSchema.idxHash); p!=null; p=sqliteHashNext(p)){\nIndex pIdx = (Index *)sqliteHashData(p);\nif( pIdx.tnum==(int)iRoot ){\niTab = pIdx.pTable.tnum;\n}\n}\n}else{\niTab = iRoot;\n}\n\n/* Search for the required lock. Either a write-lock on root-page iTab, a\n** write-lock on the schema table, or (if the client is reading) a\n** read-lock on iTab will suffice. Return 1 if any of these are found.  */\nfor(pLock=pBtree.pBt.pLock; pLock; pLock=pLock.pNext){\nif( pLock.pBtree==pBtree\n&& (pLock.iTable==iTab || (pLock.eLock==WRITE_LOCK && pLock.iTable==1))\n&& pLock.eLock>=eLockType\n){\nreturn 1;\n}\n}\n\n/* Failed to find the required lock. */\nreturn 0;\n}\n\n/*\n** This function is also used as part of Debug.Assert() statements only. It\n** returns true if there exist one or more cursors open on the table\n** with root page iRoot that do not belong to either connection pBtree\n** or some other connection that has the read-uncommitted flag set.\n**\n** For example, before writing to page iRoot:\n**\n**    Debug.Assert( !hasReadConflicts(pBtree, iRoot) );\n*/\nstatic int hasReadConflicts(Btree pBtree, Pgno iRoot){\nBtCursor p;\nfor(p=pBtree.pBt.pCursor; p!=null; p=p.pNext){\nif( p.pgnoRoot==iRoot\n&& p.pBtree!=pBtree\n&& 0==(p.pBtree.db.flags & SQLITE_ReadUncommitted)\n){\nreturn 1;\n}\n}\nreturn 0;\n}\n#endif    //* #if SQLITE_DEBUG */\n\n/*\n** Query to see if btree handle p may obtain a lock of type eLock\n** (READ_LOCK or WRITE_LOCK) on the table with root-page iTab. Return\n** SQLITE_OK if the lock may be obtained (by calling\n** setSharedCacheTableLock()), or SQLITE_LOCKED if not.\n*/\nstatic int querySharedCacheTableLock(Btree p, Pgno iTab, u8 eLock){\nBtShared pBt = p.pBt;\nBtLock pIter;\n\nDebug.Assert( sqlite3BtreeHoldsMutex(p) );\nDebug.Assert( eLock==READ_LOCK || eLock==WRITE_LOCK );\nDebug.Assert( p.db!=null );\nDebug.Assert( !(p.db.flags&SQLITE_ReadUncommitted)||eLock==WRITE_LOCK||iTab==1 );\n\n/* If requesting a write-lock, then the Btree must have an open write\n** transaction on this file. And, obviously, for this to be so there\n** must be an open write transaction on the file itself.\n*/\nDebug.Assert( eLock==READ_LOCK || (p==pBt.pWriter && p.inTrans==TRANS_WRITE) );\nDebug.Assert( eLock==READ_LOCK || pBt.inTransaction==TRANS_WRITE );\n\n/* This is a no-op if the shared-cache is not enabled */\nif( !p.sharable ){\nreturn SQLITE_OK;\n}\n\n/* If some other connection is holding an exclusive lock, the\n** requested lock may not be obtained.\n*/\nif( pBt.pWriter!=p && pBt.isExclusive ){\nsqlite3ConnectionBlocked(p.db, pBt.pWriter.db);\nreturn SQLITE_LOCKED_SHAREDCACHE;\n}\n\nfor(pIter=pBt.pLock; pIter; pIter=pIter.pNext){\n/* The condition (pIter.eLock!=eLock) in the following if(...)\n** statement is a simplification of:\n**\n**   (eLock==WRITE_LOCK || pIter.eLock==WRITE_LOCK)\n**\n** since we know that if eLock==WRITE_LOCK, then no other connection\n** may hold a WRITE_LOCK on any table in this file (since there can\n** only be a single writer).\n*/\nDebug.Assert( pIter.eLock==READ_LOCK || pIter.eLock==WRITE_LOCK );\nDebug.Assert( eLock==READ_LOCK || pIter.pBtree==p || pIter.eLock==READ_LOCK);\nif( pIter.pBtree!=p && pIter.iTable==iTab && pIter.eLock!=eLock ){\nsqlite3ConnectionBlocked(p.db, pIter.pBtree.db);\nif( eLock==WRITE_LOCK ){\nDebug.Assert( p==pBt.pWriter );\npBt.isPending = 1;\n}\nreturn SQLITE_LOCKED_SHAREDCACHE;\n}\n}\nreturn SQLITE_OK;\n}\n#endif //* !SQLITE_OMIT_SHARED_CACHE */\n\n#if !SQLITE_OMIT_SHARED_CACHE\n/*\n** Add a lock on the table with root-page iTable to the shared-btree used\n** by Btree handle p. Parameter eLock must be either READ_LOCK or\n** WRITE_LOCK.\n**\n** This function assumes the following:\n**\n**   (a) The specified b-tree connection handle is connected to a sharable\n**       b-tree database (one with the BtShared.sharable) flag set, and\n**\n**   (b) No other b-tree connection handle holds a lock that conflicts\n**       with the requested lock (i.e. querySharedCacheTableLock() has\n**       already been called and returned SQLITE_OK).\n**\n** SQLITE_OK is returned if the lock is added successfully. SQLITE_NOMEM\n** is returned if a malloc attempt fails.\n*/\nstatic int setSharedCacheTableLock(Btree p, Pgno iTable, u8 eLock){\nBtShared pBt = p.pBt;\nBtLock pLock = 0;\nBtLock pIter;\n\nDebug.Assert( sqlite3BtreeHoldsMutex(p) );\nDebug.Assert( eLock==READ_LOCK || eLock==WRITE_LOCK );\nDebug.Assert( p.db!=null );\n\n/* A connection with the read-uncommitted flag set will never try to\n** obtain a read-lock using this function. The only read-lock obtained\n** by a connection in read-uncommitted mode is on the sqlite_master\n** table, and that lock is obtained in BtreeBeginTrans().  */\nDebug.Assert( 0==(p.db.flags&SQLITE_ReadUncommitted) || eLock==WRITE_LOCK );\n\n/* This function should only be called on a sharable b-tree after it\n** has been determined that no other b-tree holds a conflicting lock.  */\nDebug.Assert( p.sharable );\nDebug.Assert( SQLITE_OK==querySharedCacheTableLock(p, iTable, eLock) );\n\n/* First search the list for an existing lock on this table. */\nfor(pIter=pBt.pLock; pIter; pIter=pIter.pNext){\nif( pIter.iTable==iTable && pIter.pBtree==p ){\npLock = pIter;\nbreak;\n}\n}\n\n/* If the above search did not find a BtLock struct associating Btree p\n** with table iTable, allocate one and link it into the list.\n*/\nif( !pLock ){\npLock = (BtLock *)sqlite3MallocZero(sizeof(BtLock));\nif( !pLock ){\nreturn SQLITE_NOMEM;\n}\npLock.iTable = iTable;\npLock.pBtree = p;\npLock.pNext = pBt.pLock;\npBt.pLock = pLock;\n}\n\n/* Set the BtLock.eLock variable to the maximum of the current lock\n** and the requested lock. This means if a write-lock was already held\n** and a read-lock requested, we don\'t incorrectly downgrade the lock.\n*/\nDebug.Assert( WRITE_LOCK>READ_LOCK );\nif( eLock>pLock.eLock ){\npLock.eLock = eLock;\n}\n\nreturn SQLITE_OK;\n}\n#endif //* !SQLITE_OMIT_SHARED_CACHE */\n\n#if !SQLITE_OMIT_SHARED_CACHE\n/*\n** Release all the table locks (locks obtained via calls to\n** the setSharedCacheTableLock() procedure) held by Btree handle p.\n**\n** This function assumes that handle p has an open read or write\n** transaction. If it does not, then the BtShared.isPending variable\n** may be incorrectly cleared.\n*/\nstatic void clearAllSharedCacheTableLocks(Btree p){\nBtShared pBt = p.pBt;\nBtLock **ppIter = &pBt.pLock;\n\nDebug.Assert( sqlite3BtreeHoldsMutex(p) );\nDebug.Assert( p.sharable || 0==*ppIter );\nDebug.Assert( p.inTrans>0 );\n\nwhile( ppIter ){\nBtLock pLock = ppIter;\nDebug.Assert( pBt.isExclusive==null || pBt.pWriter==pLock.pBtree );\nDebug.Assert( pLock.pBtree.inTrans>=pLock.eLock );\nif( pLock.pBtree==p ){\nppIter = pLock.pNext;\nDebug.Assert( pLock.iTable!=1 || pLock==&p.lock );\nif( pLock.iTable!=1 ){\npLock=null;//sqlite3_free(ref pLock);\n}\n}else{\nppIter = &pLock.pNext;\n}\n}\n\nDebug.Assert( pBt.isPending==null || pBt.pWriter );\nif( pBt.pWriter==p ){\npBt.pWriter = 0;\npBt.isExclusive = 0;\npBt.isPending = 0;\n}else if( pBt.nTransaction==2 ){\n/* This function is called when connection p is concluding its\n** transaction. If there currently exists a writer, and p is not\n** that writer, then the number of locks held by connections other\n** than the writer must be about to drop to zero. In this case\n** set the isPending flag to 0.\n**\n** If there is not currently a writer, then BtShared.isPending must\n** be zero already. So this next line is harmless in that case.\n*/\npBt.isPending = 0;\n}\n}\n\n/*\n** This function changes all write-locks held by connection p to read-locks.\n*/\nstatic void downgradeAllSharedCacheTableLocks(Btree p){\nBtShared pBt = p.pBt;\nif( pBt.pWriter==p ){\nBtLock pLock;\npBt.pWriter = 0;\npBt.isExclusive = 0;\npBt.isPending = 0;\nfor(pLock=pBt.pLock; pLock; pLock=pLock.pNext){\nDebug.Assert( pLock.eLock==READ_LOCK || pLock.pBtree==p );\npLock.eLock = READ_LOCK;\n}\n}\n}\n\n#endif //* SQLITE_OMIT_SHARED_CACHE */\n\n    //static void releasePage(MemPage pPage);  /* Forward reference */\n\n    /*\n    ** Verify that the cursor holds a mutex on the BtShared\n    */\n#if !NDEBUG\n    static bool cursorHoldsMutex(BtCursor p)\n    {\n      return sqlite3_mutex_held(p.pBt.mutex);\n    }\n#else\nstatic bool cursorHoldsMutex(BtCursor p) { return true; }\n#endif\n\n\n#if !SQLITE_OMIT_INCRBLOB\n/*\n** Invalidate the overflow page-list cache for cursor pCur, if any.\n*/\nstatic void invalidateOverflowCache(BtCursor pCur){\nDebug.Assert( cursorHoldsMutex(pCur) );\n//sqlite3_free(ref pCur.aOverflow);\npCur.aOverflow = null;\n}\n\n/*\n** Invalidate the overflow page-list cache for all cursors opened\n** on the shared btree structure pBt.\n*/\nstatic void invalidateAllOverflowCache(BtShared pBt){\nBtCursor p;\nDebug.Assert( sqlite3_mutex_held(pBt.mutex) );\nfor(p=pBt.pCursor; p!=null; p=p.pNext){\ninvalidateOverflowCache(p);\n}\n}\n\n/*\n** This function is called before modifying the contents of a table\n** b-tree to invalidate any incrblob cursors that are open on the\n** row or one of the rows being modified.\n**\n** If argument isClearTable is true, then the entire contents of the\n** table is about to be deleted. In this case invalidate all incrblob\n** cursors open on any row within the table with root-page pgnoRoot.\n**\n** Otherwise, if argument isClearTable is false, then the row with\n** rowid iRow is being replaced or deleted. In this case invalidate\n** only those incrblob cursors open on this specific row.\n*/\nstatic void invalidateIncrblobCursors(\nBtree pBtree,          /* The database file to check */\ni64 iRow,               /* The rowid that might be changing */\nint isClearTable        /* True if all rows are being deleted */\n){\nBtCursor p;\nBtShared pBt = pBtree.pBt;\nDebug.Assert( sqlite3BtreeHoldsMutex(pBtree) );\nfor(p=pBt.pCursor; p!=null; p=p.pNext){\nif( p.isIncrblobHandle && (isClearTable || p.info.nKey==iRow) ){\np.eState = CURSOR_INVALID;\n}\n}\n}\n\n#else\n    //#define invalidateOverflowCache(x)\n    static void invalidateOverflowCache(BtCursor pCur) { }\n    //#define invalidateAllOverflowCache(x)\n    static void invalidateAllOverflowCache(BtShared pBt) { }\n    //#define invalidateIncrblobCursors(x,y,z)\n    static void invalidateIncrblobCursors(Btree x, i64 y, int z) { }\n\n#endif\n\n    /*\n** Set bit pgno of the BtShared.pHasContent bitvec. This is called\n** when a page that previously contained data becomes a free-list leaf\n** page.\n**\n** The BtShared.pHasContent bitvec exists to work around an obscure\n** bug caused by the interaction of two useful IO optimizations surrounding\n** free-list leaf pages:\n**\n**   1) When all data is deleted from a page and the page becomes\n**      a free-list leaf page, the page is not written to the database\n**      (as free-list leaf pages contain no meaningful data). Sometimes\n**      such a page is not even journalled (as it will not be modified,\n**      why bother journalling it?).\n**\n**   2) When a free-list leaf page is reused, its content is not read\n**      from the database or written to the journal file (why should it\n**      be, if it is not at all meaningful?).\n**\n** By themselves, these optimizations work fine and provide a handy\n** performance boost to bulk delete or insert operations. However, if\n** a page is moved to the free-list and then reused within the same\n** transaction, a problem comes up. If the page is not journalled when\n** it is moved to the free-list and it is also not journalled when it\n** is extracted from the free-list and reused, then the original data\n** may be lost. In the event of a rollback, it may not be possible\n** to restore the database to its original configuration.\n**\n** The solution is the BtShared.pHasContent bitvec. Whenever a page is\n** moved to become a free-list leaf page, the corresponding bit is\n** set in the bitvec. Whenever a leaf page is extracted from the free-list,\n** optimization 2 above is ommitted if the corresponding bit is already\n** set in BtShared.pHasContent. The contents of the bitvec are cleared\n** at the end of every transaction.\n*/\n    static int btreeSetHasContent(BtShared pBt, Pgno pgno)\n    {\n      int rc = SQLITE_OK;\n      if (null == pBt.pHasContent)\n      {\n        int nPage = 100;\n        sqlite3PagerPagecount(pBt.pPager, ref nPage);\n        /* If sqlite3PagerPagecount() fails there is no harm because the\n        ** nPage variable is unchanged from its default value of 100 */\n        pBt.pHasContent = sqlite3BitvecCreate((u32)nPage);\n        if (null == pBt.pHasContent)\n        {\n          rc = SQLITE_NOMEM;\n        }\n      }\n      if (rc == SQLITE_OK && pgno <= sqlite3BitvecSize(pBt.pHasContent))\n      {\n        rc = sqlite3BitvecSet(pBt.pHasContent, pgno);\n      }\n      return rc;\n    }\n\n    /*\n    ** Query the BtShared.pHasContent vector.\n    **\n    ** This function is called when a free-list leaf page is removed from the\n    ** free-list for reuse. It returns false if it is safe to retrieve the\n    ** page from the pager layer with the \'no-content\' flag set. True otherwise.\n    */\n    static bool btreeGetHasContent(BtShared pBt, Pgno pgno)\n    {\n      Bitvec p = pBt.pHasContent;\n      return (p != null && (pgno > sqlite3BitvecSize(p) || sqlite3BitvecTest(p, pgno) != 0));\n    }\n\n    /*\n    ** Clear (destroy) the BtShared.pHasContent bitvec. This should be\n    ** invoked at the conclusion of each write-transaction.\n    */\n    static void btreeClearHasContent(BtShared pBt)\n    {\n      sqlite3BitvecDestroy(ref pBt.pHasContent);\n      pBt.pHasContent = null;\n    }\n\n    /*\n    ** Save the current cursor position in the variables BtCursor.nKey\n    ** and BtCursor.pKey. The cursor\'s state is set to CURSOR_REQUIRESEEK.\n    **\n    ** The caller must ensure that the cursor is valid (has eState==CURSOR_VALID)\n    ** prior to calling this routine.\n    */\n    static int saveCursorPosition(BtCursor pCur)\n    {\n      int rc;\n\n      Debug.Assert(CURSOR_VALID == pCur.eState);\n      Debug.Assert(null == pCur.pKey);\n      Debug.Assert(cursorHoldsMutex(pCur));\n\n      rc = sqlite3BtreeKeySize(pCur, ref pCur.nKey);\n      Debug.Assert(rc == SQLITE_OK);  /* KeySize() cannot fail */\n\n      /* If this is an intKey table, then the above call to BtreeKeySize()\n      ** stores the integer key in pCur.nKey. In this case this value is\n      ** all that is required. Otherwise, if pCur is not open on an intKey\n      ** table, then malloc space for and store the pCur.nKey bytes of key\n      ** data.\n      */\n      if (0 == pCur.apPage[0].intKey)\n      {\n        byte[] pKey = new byte[pCur.nKey];//void pKey = sqlite3Malloc( (int)pCur.nKey );\n        //if( pKey !=null){\n        rc = sqlite3BtreeKey(pCur, 0, (u32)pCur.nKey, pKey);\n        if (rc == SQLITE_OK)\n        {\n          pCur.pKey = pKey;\n        }\n        //else{\n        //  sqlite3_free(ref pKey);\n        //}\n        //}else{\n        //  rc = SQLITE_NOMEM;\n        //}\n      }\n      Debug.Assert(0 == pCur.apPage[0].intKey || null == pCur.pKey);\n\n      if (rc == SQLITE_OK)\n      {\n        int i;\n        for (i = 0; i <= pCur.iPage; i++)\n        {\n          releasePage(pCur.apPage[i]);\n          pCur.apPage[i] = null;\n        }\n        pCur.iPage = -1;\n        pCur.eState = CURSOR_REQUIRESEEK;\n      }\n\n      invalidateOverflowCache(pCur);\n      return rc;\n    }\n\n    /*\n    ** Save the positions of all cursors except pExcept open on the table\n    ** with root-page iRoot. Usually, this is called just before cursor\n    ** pExcept is used to modify the table (BtreeDelete() or BtreeInsert()).\n    */\n    static int saveAllCursors(BtShared pBt, Pgno iRoot, BtCursor pExcept)\n    {\n      BtCursor p;\n      Debug.Assert(sqlite3_mutex_held(pBt.mutex));\n      Debug.Assert(pExcept == null || pExcept.pBt == pBt);\n      for (p = pBt.pCursor; p != null; p = p.pNext)\n      {\n        if (p != pExcept && (0 == iRoot || p.pgnoRoot == iRoot) &&\n        p.eState == CURSOR_VALID)\n        {\n          int rc = saveCursorPosition(p);\n          if (SQLITE_OK != rc)\n          {\n            return rc;\n          }\n        }\n      }\n      return SQLITE_OK;\n    }\n\n    /*\n    ** Clear the current cursor position.\n    */\n    static void sqlite3BtreeClearCursor(BtCursor pCur)\n    {\n      Debug.Assert(cursorHoldsMutex(pCur));\n      //sqlite3_free(ref pCur.pKey);\n      pCur.pKey = null;\n      pCur.eState = CURSOR_INVALID;\n    }\n\n    /*\n    ** In this version of BtreeMoveto, pKey is a packed index record\n    ** such as is generated by the OP_MakeRecord opcode.  Unpack the\n    ** record and then call BtreeMovetoUnpacked() to do the work.\n    */\n    static int btreeMoveto(\n    BtCursor pCur,     /* Cursor open on the btree to be searched */\n    byte[] pKey,       /* Packed key if the btree is an index */\n    i64 nKey,          /* Integer key for tables.  Size of pKey for indices */\n    int bias,          /* Bias search to the high end */\n    ref int pRes       /* Write search results here */\n    )\n    {\n      int rc;                    /* Status code */\n      UnpackedRecord pIdxKey;   /* Unpacked index key */\n      UnpackedRecord aSpace = new UnpackedRecord();//char aSpace[150]; /* Temp space for pIdxKey - to avoid a malloc */\n\n      if (pKey != null)\n      {\n        Debug.Assert(nKey == (i64)(int)nKey);\n        pIdxKey = sqlite3VdbeRecordUnpack(pCur.pKeyInfo, (int)nKey, pKey,\n        aSpace, 16);//sizeof( aSpace ) );\n        if (pIdxKey == null) return SQLITE_NOMEM;\n      }\n      else\n      {\n        pIdxKey = null;\n      }\n      rc = sqlite3BtreeMovetoUnpacked(pCur, pIdxKey, nKey, bias != 0 ? 1 : 0, ref pRes);\n\n      if (pKey != null)\n      {\n        sqlite3VdbeDeleteUnpackedRecord(pIdxKey);\n      }\n      return rc;\n    }\n\n    /*\n    ** Restore the cursor to the position it was in (or as close to as possible)\n    ** when saveCursorPosition() was called. Note that this call deletes the\n    ** saved position info stored by saveCursorPosition(), so there can be\n    ** at most one effective restoreCursorPosition() call after each\n    ** saveCursorPosition().\n    */\n    static int btreeRestoreCursorPosition(BtCursor pCur)\n    {\n      int rc;\n      Debug.Assert(cursorHoldsMutex(pCur));\n      Debug.Assert(pCur.eState >= CURSOR_REQUIRESEEK);\n      if (pCur.eState == CURSOR_FAULT)\n      {\n        return pCur.skipNext;\n      }\n      pCur.eState = CURSOR_INVALID;\n      rc = btreeMoveto(pCur, pCur.pKey, pCur.nKey, 0, ref pCur.skipNext);\n      if (rc == SQLITE_OK)\n      {\n        //sqlite3_free(ref pCur.pKey);\n        pCur.pKey = null;\n        Debug.Assert(pCur.eState == CURSOR_VALID || pCur.eState == CURSOR_INVALID);\n      }\n      return rc;\n    }\n\n    //#define restoreCursorPosition(p) \\\n    //  (p.eState>=CURSOR_REQUIRESEEK ? \\\n    //         btreeRestoreCursorPosition(p) : \\\n    //         SQLITE_OK)\n    static int restoreCursorPosition(BtCursor pCur)\n    {\n      if ( pCur.eState >= CURSOR_REQUIRESEEK )\n        return btreeRestoreCursorPosition( pCur );\n      else\n        return SQLITE_OK;\n    }\n\n    /*\n    ** Determine whether or not a cursor has moved from the position it\n    ** was last placed at.  Cursors can move when the row they are pointing\n    ** at is deleted out from under them.\n    **\n    ** This routine returns an error code if something goes wrong.  The\n    ** integer pHasMoved is set to one if the cursor has moved and 0 if not.\n    */\n    static int sqlite3BtreeCursorHasMoved(BtCursor pCur, ref int pHasMoved)\n    {\n      int rc;\n\n      rc = restoreCursorPosition(pCur);\n      if (rc != 0)\n      {\n        pHasMoved = 1;\n        return rc;\n      }\n      if (pCur.eState != CURSOR_VALID || pCur.skipNext != 0)\n      {\n        pHasMoved = 1;\n      }\n      else\n      {\n        pHasMoved = 0;\n      }\n      return SQLITE_OK;\n    }\n\n#if !SQLITE_OMIT_AUTOVACUUM\n    /*\n** Given a page number of a regular database page, return the page\n** number for the pointer-map page that contains the entry for the\n** input page number.\n*/\n    static Pgno ptrmapPageno(BtShared pBt, Pgno pgno)\n    {\n      int nPagesPerMapPage;\n      Pgno iPtrMap, ret;\n      Debug.Assert(sqlite3_mutex_held(pBt.mutex));\n      nPagesPerMapPage = (pBt.usableSize / 5) + 1;\n      iPtrMap = (Pgno)((pgno - 2) / nPagesPerMapPage);\n      ret = (Pgno)( iPtrMap * nPagesPerMapPage ) + 2;\n      if (ret == PENDING_BYTE_PAGE(pBt))\n      {\n        ret++;\n      }\n      return ret;\n    }\n\n    /*\n    ** Write an entry into the pointer map.\n    **\n    ** This routine updates the pointer map entry for page number \'key\'\n    ** so that it maps to type \'eType\' and parent page number \'pgno\'.\n    **\n    ** If pRC is initially non-zero (non-SQLITE_OK) then this routine is\n    ** a no-op.  If an error occurs, the appropriate error code is written\n    ** into pRC.\n    */\n    static void ptrmapPut(BtShared pBt, Pgno key, u8 eType, Pgno parent, ref int pRC)\n    {\n      DbPage pDbPage = new PgHdr(); /* The pointer map page */\n      u8[] pPtrmap;                 /* The pointer map data */\n      Pgno iPtrmap;                 /* The pointer map page number */\n      int offset;                   /* Offset in pointer map page */\n      int rc;                       /* Return code from subfunctions */\n\n      if (pRC != 0) return;\n\n      Debug.Assert(sqlite3_mutex_held(pBt.mutex));\n      /* The master-journal page number must never be used as a pointer map page */\n      Debug.Assert(false == PTRMAP_ISPAGE(pBt, PENDING_BYTE_PAGE(pBt)));\n\n      Debug.Assert(pBt.autoVacuum);\n      if (key == 0)\n      {\n#if SQLITE_DEBUG || DEBUG\n        pRC = SQLITE_CORRUPT_BKPT();\n#else\npRC = SQLITE_CORRUPT_BKPT;\n#endif\n        return;\n      }\n      iPtrmap = PTRMAP_PAGENO(pBt, key);\n      rc = sqlite3PagerGet(pBt.pPager, iPtrmap, ref pDbPage);\n      if (rc != SQLITE_OK)\n      {\n        pRC = rc;\n        return;\n      }\n      offset = (int)PTRMAP_PTROFFSET(iPtrmap, key);\n      if (offset < 0)\n      {\n#if SQLITE_DEBUG || DEBUG\n        pRC = SQLITE_CORRUPT_BKPT();\n#else\npRC = SQLITE_CORRUPT_BKPT;\n#endif\n        goto ptrmap_exit;\n      }\n      pPtrmap = sqlite3PagerGetData(pDbPage);\n\n      if (eType != pPtrmap[offset] || sqlite3Get4byte(pPtrmap, offset + 1) != parent)\n      {\n        TRACE("PTRMAP_UPDATE: %d->(%d,%d)\\n", key, eType, parent);\n        pRC = rc = sqlite3PagerWrite(pDbPage);\n        if (rc == SQLITE_OK)\n        {\n          pPtrmap[offset] = eType;\n          sqlite3Put4byte(pPtrmap, offset + 1, parent);\n        }\n      }\n\n    ptrmap_exit:\n      sqlite3PagerUnref(pDbPage);\n    }\n\n    /*\n    ** Read an entry from the pointer map.\n    **\n    ** This routine retrieves the pointer map entry for page \'key\', writing\n    ** the type and parent page number to pEType and pPgno respectively.\n    ** An error code is returned if something goes wrong, otherwise SQLITE_OK.\n    */\n    static int ptrmapGet(BtShared pBt, Pgno key, ref u8 pEType, ref Pgno pPgno)\n    {\n      DbPage pDbPage = new PgHdr();/* The pointer map page */\n      int iPtrmap;                 /* Pointer map page index */\n      u8[] pPtrmap;                /* Pointer map page data */\n      int offset;                  /* Offset of entry in pointer map */\n      int rc;\n\n      Debug.Assert(sqlite3_mutex_held(pBt.mutex));\n\n      iPtrmap = (int)PTRMAP_PAGENO(pBt, key);\n      rc = sqlite3PagerGet(pBt.pPager, (u32)iPtrmap, ref pDbPage);\n      if (rc != 0)\n      {\n        return rc;\n      }\n      pPtrmap = sqlite3PagerGetData(pDbPage);\n\n      offset = (int)PTRMAP_PTROFFSET((u32)iPtrmap, key);\n      // Under C# pEType will always exist. No need to test; //\n      //Debug.Assert( pEType != 0 );\n      pEType = pPtrmap[offset];\n      // Under C# pPgno will always exist. No need to test; //\n      //if ( pPgno != 0 )\n      pPgno = sqlite3Get4byte(pPtrmap, offset + 1);\n\n      sqlite3PagerUnref(pDbPage);\n      if (pEType < 1 || pEType > 5)\n#if SQLITE_DEBUG || DEBUG\n        return SQLITE_CORRUPT_BKPT();\n#else\nreturn SQLITE_CORRUPT_BKPT;\n#endif\n      return SQLITE_OK;\n    }\n\n#else //* if defined SQLITE_OMIT_AUTOVACUUM */\n//#define ptrmapPut(w,x,y,z,rc)\n//#define ptrmapGet(w,x,y,z) SQLITE_OK\n//#define ptrmapPutOvflPtr(x, y, rc)\n#endif\n\n    /*\n** Given a btree page and a cell index (0 means the first cell on\n** the page, 1 means the second cell, and so forth) return a pointer\n** to the cell content.\n**\n** This routine works only for pages that do not contain overflow cells.\n*/\n    //#define findCell(P,I) \\\n    //  ((P).aData + ((P).maskPage & get2byte((P).aData[(P).cellOffset+2*(I)])))\n    static int findCell(MemPage pPage, int iCell)\n    {\n      return get2byte(pPage.aData, (pPage).cellOffset + 2 * (iCell));\n    }\n    /*\n    ** This a more complex version of findCell() that works for\n    ** pages that do contain overflow cells.\n    */\n    static int findOverflowCell(MemPage pPage, int iCell)\n    {\n      int i;\n      Debug.Assert(sqlite3_mutex_held(pPage.pBt.mutex));\n      for (i = pPage.nOverflow - 1; i >= 0; i--)\n      {\n        int k;\n        _OvflCell pOvfl;\n        pOvfl = pPage.aOvfl[i];\n        k = pOvfl.idx;\n        if (k <= iCell)\n        {\n          if (k == iCell)\n          {\n            //return pOvfl.pCell;\n            return -i - 1; // Negative Offset means overflow cells\n          }\n          iCell--;\n        }\n      }\n      return findCell(pPage, iCell);\n    }\n\n    /*\n    ** Parse a cell content block and fill in the CellInfo structure.  There\n    ** are two versions of this function.  btreeParseCell() takes a\n    ** cell index as the second argument and btreeParseCellPtr()\n    ** takes a pointer to the body of the cell as its second argument.\n    **\n    ** Within this file, the parseCell() macro can be called instead of\n    ** btreeParseCellPtr(). Using some compilers, this will be faster.\n    */\n    //OVERLOADS\n    static void btreeParseCellPtr(\n    MemPage pPage,        /* Page containing the cell */\n    int iCell,            /* Pointer to the cell text. */\n    ref CellInfo pInfo        /* Fill in this structure */\n    )\n    { btreeParseCellPtr(pPage, pPage.aData, iCell, ref pInfo); }\n    static void btreeParseCellPtr(\n    MemPage pPage,        /* Page containing the cell */\n    byte[] pCell,         /* The actual data */\n    ref CellInfo pInfo        /* Fill in this structure */\n    )\n    { btreeParseCellPtr( pPage, pCell, 0, ref pInfo ); }\n    static void btreeParseCellPtr(\n    MemPage pPage,         /* Page containing the cell */\n    u8[] pCell,            /* Pointer to the cell text. */\n    int iCell,             /* Pointer to the cell text. */\n    ref CellInfo pInfo         /* Fill in this structure */\n    )\n    {\n      u16 n;                  /* Number bytes in cell content header */\n      u32 nPayload = 0;           /* Number of bytes of cell payload */\n\n      Debug.Assert(sqlite3_mutex_held(pPage.pBt.mutex));\n\n      pInfo.pCell = pCell;\n      pInfo.iCell = iCell;\n      Debug.Assert(pPage.leaf == 0 || pPage.leaf == 1);\n      n = pPage.childPtrSize;\n      Debug.Assert(n == 4 - 4 * pPage.leaf);\n      if (pPage.intKey != 0)\n      {\n        if (pPage.hasData != 0)\n        {\n          n += (u16)getVarint32(pCell, iCell + n, ref nPayload);\n        }\n        else\n        {\n          nPayload = 0;\n        }\n        n += (u16)getVarint(pCell, iCell + n, ref pInfo.nKey);\n        pInfo.nData = nPayload;\n      }\n      else\n      {\n        pInfo.nData = 0;\n        n += (u16)getVarint32(pCell, iCell + n, ref nPayload);\n        pInfo.nKey = nPayload;\n      }\n      pInfo.nPayload = nPayload;\n      pInfo.nHeader = n;\n      testcase(nPayload == pPage.maxLocal);\n      testcase(nPayload == pPage.maxLocal + 1);\n      if (likely(nPayload <= pPage.maxLocal))\n      {\n        /* This is the (easy) common case where the entire payload fits\n        ** on the local page.  No overflow is required.\n        */\n        int nSize;          /* Total size of cell content in bytes */\n        nSize = (int)nPayload + n;\n        pInfo.nLocal = (u16)nPayload;\n        pInfo.iOverflow = 0;\n        if ((nSize & ~3) == 0)\n        {\n          nSize = 4;        /* Minimum cell size is 4 */\n        }\n        pInfo.nSize = (u16)nSize;\n      }\n      else\n      {\n        /* If the payload will not fit completely on the local page, we have\n        ** to decide how much to store locally and how much to spill onto\n        ** overflow pages.  The strategy is to minimize the amount of unused\n        ** space on overflow pages while keeping the amount of local storage\n        ** in between minLocal and maxLocal.\n        **\n        ** Warning:  changing the way overflow payload is distributed in any\n        ** way will result in an incompatible file format.\n        */\n        int minLocal;  /* Minimum amount of payload held locally */\n        int maxLocal;  /* Maximum amount of payload held locally */\n        int surplus;   /* Overflow payload available for local storage */\n\n        minLocal = pPage.minLocal;\n        maxLocal = pPage.maxLocal;\n        surplus = (int)(minLocal + (nPayload - minLocal) % (pPage.pBt.usableSize - 4));\n        testcase(surplus == maxLocal);\n        testcase(surplus == maxLocal + 1);\n        if (surplus <= maxLocal)\n        {\n          pInfo.nLocal = (u16)surplus;\n        }\n        else\n        {\n          pInfo.nLocal = (u16)minLocal;\n        }\n        pInfo.iOverflow = (u16)(pInfo.nLocal + n);\n        pInfo.nSize = (u16)(pInfo.iOverflow + 4);\n      }\n    }\n    //#define parseCell(pPage, iCell, pInfo) \\\n    //  btreeParseCellPtr((pPage), findCell((pPage), (iCell)), (pInfo))\n    static void parseCell( MemPage pPage, int iCell, ref CellInfo pInfo )\n    {\n      btreeParseCellPtr( ( pPage ), findCell( ( pPage ), ( iCell ) ), ref ( pInfo ) );\n    }\n\n    static void btreeParseCell(\n    MemPage pPage,         /* Page containing the cell */\n    int iCell,              /* The cell index.  First cell is 0 */\n    ref CellInfo pInfo         /* Fill in this structure */\n    )\n    {\n      parseCell( pPage, iCell, ref pInfo );\n    }\n\n    /*\n    ** Compute the total number of bytes that a Cell needs in the cell\n    ** data area of the btree-page.  The return number includes the cell\n    ** data header and the local payload, but not any overflow page or\n    ** the space used by the cell pointer.\n    */\n    // Alternative form for C#\n    static u16 cellSizePtr(MemPage pPage, int iCell)\n    {\n      CellInfo info = new CellInfo();\n      byte[] pCell = new byte[13];// Minimum Size = (2 bytes of Header  or (4) Child Pointer) + (maximum of) 9 bytes data\n      if (iCell < 0)// Overflow Cell\n        Buffer.BlockCopy(pPage.aOvfl[-(iCell + 1)].pCell, 0, pCell, 0, pCell.Length < pPage.aOvfl[-(iCell + 1)].pCell.Length ? pCell.Length : pPage.aOvfl[-(iCell + 1)].pCell.Length);\n      else if (iCell >= pPage.aData.Length + 1 - pCell.Length)\n        Buffer.BlockCopy(pPage.aData, iCell, pCell, 0, pPage.aData.Length - iCell);\n      else\n        Buffer.BlockCopy(pPage.aData, iCell, pCell, 0, pCell.Length);\n      btreeParseCellPtr( pPage, pCell, ref info );\n      return info.nSize;\n    }\n\n    // Alternative form for C#\n    static u16 cellSizePtr(MemPage pPage, byte[] pCell, int offset)\n    {\n      CellInfo info = new CellInfo();\n      byte[] pTemp = new byte[pCell.Length];\n      Buffer.BlockCopy(pCell, offset, pTemp, 0, pCell.Length - offset);\n      btreeParseCellPtr( pPage, pTemp, ref info );\n      return info.nSize;\n    }\n\n    static u16 cellSizePtr(MemPage pPage, u8[] pCell)\n    {\n      int _pIter = pPage.childPtrSize; //u8 pIter = &pCell[pPage.childPtrSize];\n      u32 nSize = 0;\n\n#if SQLITE_DEBUG || DEBUG\n      /* The value returned by this function should always be the same as\n** the (CellInfo.nSize) value found by doing a full parse of the\n** cell. If SQLITE_DEBUG is defined, an Debug.Assert() at the bottom of\n** this function verifies that this invariant is not violated. */\n      CellInfo debuginfo = new CellInfo();\n      btreeParseCellPtr(pPage, pCell, ref debuginfo);\n#else\n      CellInfo debuginfo = new CellInfo();\n#endif\n\n      if (pPage.intKey != 0)\n      {\n        int pEnd;\n        if (pPage.hasData != 0)\n        {\n          _pIter += getVarint32(pCell, ref nSize);// pIter += getVarint32( pIter, ref nSize );\n        }\n        else\n        {\n          nSize = 0;\n        }\n\n        /* pIter now points at the 64-bit integer key value, a variable length\n        ** integer. The following block moves pIter to point at the first byte\n        ** past the end of the key value. */\n        pEnd = _pIter + 9;//pEnd = &pIter[9];\n        while (((pCell[_pIter++]) & 0x80) != 0 && _pIter < pEnd) ;//while( (pIter++)&0x80 && pIter<pEnd );\n      }\n      else\n      {\n        _pIter += getVarint32(pCell, _pIter, ref nSize); //pIter += getVarint32( pIter, ref nSize );\n      }\n\n      testcase(nSize == pPage.maxLocal);\n      testcase(nSize == pPage.maxLocal + 1);\n      if (nSize > pPage.maxLocal)\n      {\n        int minLocal = pPage.minLocal;\n        nSize = (u32)(minLocal + (nSize - minLocal) % (pPage.pBt.usableSize - 4));\n        testcase(nSize == pPage.maxLocal);\n        testcase(nSize == pPage.maxLocal + 1);\n        if (nSize > pPage.maxLocal)\n        {\n          nSize = (u32)minLocal;\n        }\n        nSize += 4;\n      }\n      nSize += (uint)_pIter;//nSize += (u32)(pIter - pCell);\n\n      /* The minimum size of any cell is 4 bytes. */\n      if (nSize < 4)\n      {\n        nSize = 4;\n      }\n\n      Debug.Assert(nSize == debuginfo.nSize);\n      return (u16)nSize;\n    }\n#if !NDEBUG || DEBUG\n    static u16 cellSize(MemPage pPage, int iCell)\n    {\n      return cellSizePtr(pPage, findCell(pPage, iCell));\n    }\n#else\nstatic int cellSize(MemPage pPage, int iCell) { return -1; }\n#endif\n\n#if !SQLITE_OMIT_AUTOVACUUM\n    /*\n** If the cell pCell, part of page pPage contains a pointer\n** to an overflow page, insert an entry into the pointer-map\n** for the overflow page.\n*/\n    static void ptrmapPutOvflPtr(MemPage pPage, int pCell, ref int pRC)\n    {\n      if (pRC != 0) return;\n      CellInfo info = new CellInfo();\n      Debug.Assert(pCell != 0);\n      btreeParseCellPtr( pPage, pCell, ref info );\n      Debug.Assert((info.nData + (pPage.intKey != 0 ? 0 : info.nKey)) == info.nPayload);\n      if (info.iOverflow != 0)\n      {\n        Pgno ovfl = sqlite3Get4byte(pPage.aData, pCell, info.iOverflow);\n        ptrmapPut(pPage.pBt, ovfl, PTRMAP_OVERFLOW1, pPage.pgno, ref pRC);\n      }\n    }\n\n    static void ptrmapPutOvflPtr(MemPage pPage, u8[] pCell, ref int pRC)\n    {\n      if (pRC != 0) return;\n      CellInfo info = new CellInfo();\n      Debug.Assert(pCell != null);\n      btreeParseCellPtr( pPage, pCell, ref info );\n      Debug.Assert((info.nData + (pPage.intKey != 0 ? 0 : info.nKey)) == info.nPayload);\n      if (info.iOverflow != 0)\n      {\n        Pgno ovfl = sqlite3Get4byte(pCell, info.iOverflow);\n        ptrmapPut(pPage.pBt, ovfl, PTRMAP_OVERFLOW1, pPage.pgno, ref pRC);\n      }\n    }\n#endif\n\n\n    /*\n** Defragment the page given.  All Cells are moved to the\n** end of the page and all free space is collected into one\n** big FreeBlk that occurs in between the header and cell\n** pointer array and the cell content area.\n*/\n    static int defragmentPage(MemPage pPage)\n    {\n      int i;                     /* Loop counter */\n      int pc;                    /* Address of a i-th cell */\n      int addr;                  /* Offset of first byte after cell pointer array */\n      int hdr;                   /* Offset to the page header */\n      int size;                  /* Size of a cell */\n      int usableSize;            /* Number of usable bytes on a page */\n      int cellOffset;            /* Offset to the cell pointer array */\n      int cbrk;                  /* Offset to the cell content area */\n      int nCell;                 /* Number of cells on the page */\n      byte[] data;               /* The page data */\n      byte[] temp;               /* Temp area for cell content */\n      int iCellFirst;            /* First allowable cell index */\n      int iCellLast;             /* Last possible cell index */\n\n\n      Debug.Assert(sqlite3PagerIswriteable(pPage.pDbPage));\n      Debug.Assert(pPage.pBt != null);\n      Debug.Assert(pPage.pBt.usableSize <= SQLITE_MAX_PAGE_SIZE);\n      Debug.Assert(pPage.nOverflow == 0);\n      Debug.Assert(sqlite3_mutex_held(pPage.pBt.mutex));\n      temp = sqlite3PagerTempSpace(pPage.pBt.pPager);\n      data = pPage.aData;\n      hdr = pPage.hdrOffset;\n      cellOffset = pPage.cellOffset;\n      nCell = pPage.nCell;\n      Debug.Assert(nCell == get2byte(data, hdr + 3));\n      usableSize = pPage.pBt.usableSize;\n      cbrk = get2byte(data, hdr + 5);\n      Buffer.BlockCopy(data, cbrk, temp, cbrk, usableSize - cbrk);//memcpy( temp[cbrk], ref data[cbrk], usableSize - cbrk );\n      cbrk = usableSize;\n      iCellFirst = cellOffset + 2 * nCell;\n      iCellLast = usableSize - 4;\n      for (i = 0; i < nCell; i++)\n      {\n        int pAddr;     /* The i-th cell pointer */\n        pAddr = cellOffset + i * 2; // &data[cellOffset + i * 2];\n        pc = get2byte(data, pAddr);\n        testcase(pc == iCellFirst);\n        testcase(pc == iCellLast);\n#if !(SQLITE_ENABLE_OVERSIZE_CELL_CHECK)\n/* These conditions have already been verified in btreeInitPage()\n** if SQLITE_ENABLE_OVERSIZE_CELL_CHECK is defined\n*/\nif( pc<iCellFirst || pc>iCellLast ){\n#if SQLITE_DEBUG || DEBUG\nreturn SQLITE_CORRUPT_BKPT();\n#else\nreturn SQLITE_CORRUPT_BKPT;\n#endif\n}\n#endif\n        Debug.Assert(pc >= iCellFirst && pc <= iCellLast);\n        size = cellSizePtr(pPage, temp, pc);\n        cbrk -= size;\n#if (SQLITE_ENABLE_OVERSIZE_CELL_CHECK)\n        if (cbrk < iCellFirst)\n        {\n#if SQLITE_DEBUG || DEBUG\n          return SQLITE_CORRUPT_BKPT();\n#else\nreturn SQLITE_CORRUPT_BKPT;\n#endif\n        }\n#else\nif( cbrk<iCellFirst || pc+size>usableSize ){\n#if SQLITE_DEBUG || DEBUG\nreturn SQLITE_CORRUPT_BKPT();\n#else\nreturn SQLITE_CORRUPT_BKPT;\n#endif\n}\n#endif\n        Debug.Assert(cbrk + size <= usableSize && cbrk >= iCellFirst);\n        testcase(cbrk + size == usableSize);\n        testcase(pc + size == usableSize);\n        Buffer.BlockCopy(temp, pc, data, cbrk, size);//memcpy(data[cbrk], ref temp[pc], size);\n        put2byte(data, pAddr, cbrk);\n      }\n      Debug.Assert(cbrk >= iCellFirst);\n      put2byte(data, hdr + 5, cbrk);\n      data[hdr + 1] = 0;\n      data[hdr + 2] = 0;\n      data[hdr + 7] = 0;\n      addr = cellOffset + 2 * nCell;\n      Array.Clear(data, addr, cbrk - addr);  //memset(data[iCellFirst], 0, cbrk-iCellFirst);\n      Debug.Assert(sqlite3PagerIswriteable(pPage.pDbPage));\n      if (cbrk - iCellFirst != pPage.nFree)\n      {\n#if SQLITE_DEBUG || DEBUG\n        return SQLITE_CORRUPT_BKPT();\n#else\nreturn SQLITE_CORRUPT_BKPT;\n#endif\n      }\n      return SQLITE_OK;\n    }\n\n    /*\n    ** Allocate nByte bytes of space from within the B-Tree page passed\n    ** as the first argument. Write into pIdx the index into pPage.aData[]\n    ** of the first byte of allocated space. Return either SQLITE_OK or\n    ** an error code (usually SQLITE_CORRUPT).\n    **\n    ** The caller guarantees that there is sufficient space to make the\n    ** allocation.  This routine might need to defragment in order to bring\n    ** all the space together, however.  This routine will avoid using\n    ** the first two bytes past the cell pointer area since presumably this\n    ** allocation is being made in order to insert a new cell, so we will\n    ** also end up needing a new cell pointer.\n    */\n    static int allocateSpace(MemPage pPage, int nByte, ref int pIdx)\n    {\n      int hdr = pPage.hdrOffset;  /* Local cache of pPage.hdrOffset */\n      u8[] data = pPage.aData;    /* Local cache of pPage.aData */\n      int nFrag;                  /* Number of fragmented bytes on pPage */\n      int top;                    /* First byte of cell content area */\n      int gap;                    /* First byte of gap between cell pointers and cell content */\n      int rc;                     /* Integer return code */\n\n      Debug.Assert(sqlite3PagerIswriteable(pPage.pDbPage));\n      Debug.Assert(pPage.pBt != null);\n      Debug.Assert(sqlite3_mutex_held(pPage.pBt.mutex));\n      Debug.Assert(nByte >= 0);  /* Minimum cell size is 4 */\n      Debug.Assert(pPage.nFree >= nByte);\n      Debug.Assert(pPage.nOverflow == 0);\n      Debug.Assert(nByte < pPage.pBt.usableSize - 8);\n\n      nFrag = data[hdr + 7];\n      Debug.Assert(pPage.cellOffset == hdr + 12 - 4 * pPage.leaf);\n      gap = pPage.cellOffset + 2 * pPage.nCell;\n      top = get2byte(data, hdr + 5);\n      if (gap > top)\n#if SQLITE_DEBUG || DEBUG\n        return SQLITE_CORRUPT_BKPT();\n#else\nreturn SQLITE_CORRUPT_BKPT;\n#endif\n      testcase(gap + 2 == top);\n      testcase(gap + 1 == top);\n      testcase(gap == top);\n\n      if (nFrag >= 60)\n      {\n        /* Always defragment highly fragmented pages */\n        rc = defragmentPage(pPage);\n        if (rc != 0) return rc;\n        top = get2byte(data, hdr + 5);\n      }\n      else if (gap + 2 <= top)\n      {\n        /* Search the freelist looking for a free slot big enough to satisfy\n        ** the request. The allocation is made from the first free slot in\n        ** the list that is large enough to accomadate it.\n        */\n        int pc, addr;\n        for (addr = hdr + 1; (pc = get2byte(data, addr)) > 0; addr = pc)\n        {\n          int size = get2byte(data, pc + 2);     /* Size of free slot */\n          if (size >= nByte)\n          {\n            int x = size - nByte;\n            testcase(x == 4);\n            testcase(x == 3);\n            if (x < 4)\n            {\n              /* Remove the slot from the free-list. Update the number of\n              ** fragmented bytes within the page. */\n              data[addr + 0] = data[pc + 0]; data[addr + 1] = data[pc + 1]; //memcpy( data[addr], ref data[pc], 2 );\n              data[hdr + 7] = (u8)(nFrag + x);\n            }\n            else\n            {\n              /* The slot remains on the free-list. Reduce its size to account\n              ** for the portion used by the new allocation. */\n              put2byte(data, pc + 2, x);\n            }\n            pIdx = pc + x;\n            return SQLITE_OK;\n          }\n        }\n      }\n\n      /* Check to make sure there is enough space in the gap to satisfy\n      ** the allocation.  If not, defragment.\n      */\n      testcase(gap + 2 + nByte == top);\n      if (gap + 2 + nByte > top)\n      {\n        rc = defragmentPage(pPage);\n        if (rc != 0) return rc;\n        top = get2byte(data, hdr + 5);\n        Debug.Assert(gap + nByte <= top);\n      }\n\n\n      /* Allocate memory from the gap in between the cell pointer array\n      ** and the cell content area.  The btreeInitPage() call has already\n      ** validated the freelist.  Given that the freelist is valid, there\n      ** is no way that the allocation can extend off the end of the page.\n      ** The Debug.Assert() below verifies the previous sentence.\n      */\n      top -= nByte;\n      put2byte(data, hdr + 5, top);\n      Debug.Assert(top + nByte <= pPage.pBt.usableSize);\n      pIdx = top;\n      return SQLITE_OK;\n    }\n\n    /*\n    ** Return a section of the pPage.aData to the freelist.\n    ** The first byte of the new free block is pPage.aDisk[start]\n    ** and the size of the block is "size" bytes.\n    **\n    ** Most of the effort here is involved in coalesing adjacent\n    ** free blocks into a single big free block.\n    */\n    static int freeSpace(MemPage pPage, int start, int size)\n    {\n      int addr, pbegin, hdr;\n      int iLast;                        /* Largest possible freeblock offset */\n      byte[] data = pPage.aData;\n\n      Debug.Assert(pPage.pBt != null);\n      Debug.Assert(sqlite3PagerIswriteable(pPage.pDbPage));\n      Debug.Assert(start >= pPage.hdrOffset + 6 + pPage.childPtrSize);\n      Debug.Assert((start + size) <= pPage.pBt.usableSize);\n      Debug.Assert(sqlite3_mutex_held(pPage.pBt.mutex));\n      Debug.Assert(size >= 0);   /* Minimum cell size is 4 */\n\n#if SQLITE_SECURE_DELETE\n/* Overwrite deleted information with zeros when the SECURE_DELETE\n** option is enabled at compile-time */\nmemset(data[start], 0, size);\n#endif\n\n      /* Add the space back into the linked list of freeblocks.  Note that\n** even though the freeblock list was checked by btreeInitPage(),\n** btreeInitPage() did not detect overlapping cells or\n** freeblocks that overlapped cells.   Nor does it detect when the\n** cell content area exceeds the value in the page header.  If these\n** situations arise, then subsequent insert operations might corrupt\n** the freelist.  So we do need to check for corruption while scanning\n** the freelist.\n*/\n      hdr = pPage.hdrOffset;\n      addr = hdr + 1;\n      iLast = pPage.pBt.usableSize - 4;\n      Debug.Assert(start <= iLast);\n      while ((pbegin = get2byte(data, addr)) < start && pbegin > 0)\n      {\n        if (pbegin < addr + 4)\n        {\n#if SQLITE_DEBUG || DEBUG\n          return SQLITE_CORRUPT_BKPT();\n#else\nreturn SQLITE_CORRUPT_BKPT;\n#endif\n        }\n        addr = pbegin;\n      }\n      if (pbegin > iLast)\n      {\n#if SQLITE_DEBUG || DEBUG\n        return SQLITE_CORRUPT_BKPT();\n#else\nreturn SQLITE_CORRUPT_BKPT;\n#endif\n      }\n      Debug.Assert(pbegin > addr || pbegin == 0);\n      put2byte(data, addr, start);\n      put2byte(data, start, pbegin);\n      put2byte(data, start + 2, size);\n      pPage.nFree = (u16)(pPage.nFree + size);\n\n      /* Coalesce adjacent free blocks */\n      addr = hdr + 1;\n      while ((pbegin = get2byte(data, addr)) > 0)\n      {\n        int pnext, psize, x;\n        Debug.Assert(pbegin > addr);\n        Debug.Assert(pbegin <= pPage.pBt.usableSize - 4);\n        pnext = get2byte(data, pbegin);\n        psize = get2byte(data, pbegin + 2);\n        if (pbegin + psize + 3 >= pnext && pnext > 0)\n        {\n          int frag = pnext - (pbegin + psize);\n          if ((frag < 0) || (frag > (int)data[hdr + 7]))\n          {\n#if SQLITE_DEBUG || DEBUG\n            return SQLITE_CORRUPT_BKPT();\n#else\nreturn SQLITE_CORRUPT_BKPT;\n#endif\n          }\n          data[hdr + 7] -= (u8)frag;\n          x = get2byte(data, pnext);\n          put2byte(data, pbegin, x);\n          x = pnext + get2byte(data, pnext + 2) - pbegin;\n          put2byte(data, pbegin + 2, x);\n        }\n        else\n        {\n          addr = pbegin;\n        }\n      }\n\n      /* If the cell content area begins with a freeblock, remove it. */\n      if (data[hdr + 1] == data[hdr + 5] && data[hdr + 2] == data[hdr + 6])\n      {\n        int top;\n        pbegin = get2byte(data, hdr + 1);\n        put2byte(data, hdr + 1, get2byte(data, pbegin)); //memcpy( data[hdr + 1], ref data[pbegin], 2 );\n        top = get2byte(data, hdr + 5) + get2byte(data, pbegin + 2);\n        put2byte(data, hdr + 5, top);\n      }\n      Debug.Assert(sqlite3PagerIswriteable(pPage.pDbPage));\n      return SQLITE_OK;\n    }\n\n    /*\n    ** Decode the flags byte (the first byte of the header) for a page\n    ** and initialize fields of the MemPage structure accordingly.\n    **\n    ** Only the following combinations are supported.  Anything different\n    ** indicates a corrupt database files:\n    **\n    **         PTF_ZERODATA\n    **         PTF_ZERODATA | PTF_LEAF\n    **         PTF_LEAFDATA | PTF_INTKEY\n    **         PTF_LEAFDATA | PTF_INTKEY | PTF_LEAF\n    */\n    static int decodeFlags(MemPage pPage, int flagByte)\n    {\n      BtShared pBt;     /* A copy of pPage.pBt */\n\n      Debug.Assert(pPage.hdrOffset == (pPage.pgno == 1 ? 100 : 0));\n      Debug.Assert(sqlite3_mutex_held(pPage.pBt.mutex));\n      pPage.leaf = (u8)(flagByte >> 3); Debug.Assert(PTF_LEAF == 1 << 3);\n      flagByte &= ~PTF_LEAF;\n      pPage.childPtrSize = (u8)(4 - 4 * pPage.leaf);\n      pBt = pPage.pBt;\n      if (flagByte == (PTF_LEAFDATA | PTF_INTKEY))\n      {\n        pPage.intKey = 1;\n        pPage.hasData = pPage.leaf;\n        pPage.maxLocal = pBt.maxLeaf;\n        pPage.minLocal = pBt.minLeaf;\n      }\n      else if (flagByte == PTF_ZERODATA)\n      {\n        pPage.intKey = 0;\n        pPage.hasData = 0;\n        pPage.maxLocal = pBt.maxLocal;\n        pPage.minLocal = pBt.minLocal;\n      }\n      else\n      {\n#if SQLITE_DEBUG || DEBUG\n        return SQLITE_CORRUPT_BKPT();\n#else\nreturn SQLITE_CORRUPT_BKPT;\n#endif\n      }\n      return SQLITE_OK;\n    }\n\n    /*\n    ** Initialize the auxiliary information for a disk block.\n    **\n    ** Return SQLITE_OK on success.  If we see that the page does\n    ** not contain a well-formed database page, then return\n    ** SQLITE_CORRUPT.  Note that a return of SQLITE_OK does not\n    ** guarantee that the page is well-formed.  It only shows that\n    ** we failed to detect any corruption.\n    */\n    static int btreeInitPage(MemPage pPage)\n    {\n\n      Debug.Assert(pPage.pBt != null);\n      Debug.Assert(sqlite3_mutex_held(pPage.pBt.mutex));\n      Debug.Assert(pPage.pgno == sqlite3PagerPagenumber(pPage.pDbPage));\n      Debug.Assert(pPage == sqlite3PagerGetExtra(pPage.pDbPage));\n      Debug.Assert(pPage.aData == sqlite3PagerGetData(pPage.pDbPage));\n\n      if (0 == pPage.isInit)\n      {\n        u16 pc;            /* Address of a freeblock within pPage.aData[] */\n        u8 hdr;            /* Offset to beginning of page header */\n        u8[] data;         /* Equal to pPage.aData */\n        BtShared pBt;      /* The main btree structure */\n        u16 usableSize;    /* Amount of usable space on each page */\n        u16 cellOffset;    /* Offset from start of page to first cell pointer */\n        u16 nFree;         /* Number of unused bytes on the page */\n        u16 top;           /* First byte of the cell content area */\n        int iCellFirst;    /* First allowable cell or freeblock offset */\n        int iCellLast;     /* Last possible cell or freeblock offset */\n\n        pBt = pPage.pBt;\n\n        hdr = pPage.hdrOffset;\n        data = pPage.aData;\n        if (decodeFlags(pPage, data[hdr]) != 0)\n#if SQLITE_DEBUG || DEBUG\n          return SQLITE_CORRUPT_BKPT();\n#else\nreturn SQLITE_CORRUPT_BKPT;\n#endif\n        Debug.Assert(pBt.pageSize >= 512 && pBt.pageSize <= 32768);\n        pPage.maskPage = (u16)(pBt.pageSize - 1);\n        pPage.nOverflow = 0;\n        usableSize = pBt.usableSize;\n        pPage.cellOffset = (cellOffset = (u16)(hdr + 12 - 4 * pPage.leaf));\n        top = (u16)get2byte(data, hdr + 5);\n        pPage.nCell = (u16)(get2byte(data, hdr + 3));\n        if (pPage.nCell > MX_CELL(pBt))\n        {\n          /* To many cells for a single page.  The page must be corrupt */\n#if SQLITE_DEBUG || DEBUG\n          return SQLITE_CORRUPT_BKPT();\n#else\nreturn SQLITE_CORRUPT_BKPT;\n#endif\n        }\n        testcase(pPage.nCell == MX_CELL(pBt));\n\n        /* A malformed database page might cause us to read past the end\n        ** of page when parsing a cell.\n        **\n        ** The following block of code checks early to see if a cell extends\n        ** past the end of a page boundary and causes SQLITE_CORRUPT to be\n        ** returned if it does.\n        */\n        iCellFirst = cellOffset + 2 * pPage.nCell;\n        iCellLast = usableSize - 4;\n#if (SQLITE_ENABLE_OVERSIZE_CELL_CHECK)\n        {\n          int i;            /* Index into the cell pointer array */\n          int sz;           /* Size of a cell */\n\n          if (0 == pPage.leaf) iCellLast--;\n          for (i = 0; i < pPage.nCell; i++)\n          {\n            pc = (u16)get2byte(data, cellOffset + i * 2);\n            testcase(pc == iCellFirst);\n            testcase(pc == iCellLast);\n            if (pc < iCellFirst || pc > iCellLast)\n            {\n#if SQLITE_DEBUG || DEBUG\n              return SQLITE_CORRUPT_BKPT();\n#else\nreturn SQLITE_CORRUPT_BKPT;\n#endif\n            }\n            sz = cellSizePtr(pPage, data, pc);\n            testcase(pc + sz == usableSize);\n            if (pc + sz > usableSize)\n            {\n#if SQLITE_DEBUG || DEBUG\n              return SQLITE_CORRUPT_BKPT();\n#else\nreturn SQLITE_CORRUPT_BKPT;\n#endif\n            }\n          }\n          if (0 == pPage.leaf) iCellLast++;\n        }\n#endif\n\n        /* Compute the total free space on the page */\n        pc = (u16)get2byte(data, hdr + 1);\n        nFree = (u16)(data[hdr + 7] + top);\n        while (pc > 0)\n        {\n          u16 next, size;\n          if (pc < iCellFirst || pc > iCellLast)\n          {\n            /* Free block is off the page */\n#if SQLITE_DEBUG || DEBUG\n            return SQLITE_CORRUPT_BKPT();\n#else\nreturn SQLITE_CORRUPT_BKPT;\n#endif\n          }\n          next = (u16)get2byte(data, pc);\n          size = (u16)get2byte(data, pc + 2);\n          if (next > 0 && next <= pc + size + 3)\n          {\n            /* Free blocks must be in ascending order */\n#if SQLITE_DEBUG || DEBUG\n            return SQLITE_CORRUPT_BKPT();\n#else\nreturn SQLITE_CORRUPT_BKPT;\n#endif\n          }\n          nFree = (u16)(nFree + size);\n          pc = next;\n        }\n\n        /* At this point, nFree contains the sum of the offset to the start\n        ** of the cell-content area plus the number of free bytes within\n        ** the cell-content area. If this is greater than the usable-size\n        ** of the page, then the page must be corrupted. This check also\n        ** serves to verify that the offset to the start of the cell-content\n        ** area, according to the page header, lies within the page.\n        */\n        if (nFree > usableSize)\n        {\n#if SQLITE_DEBUG || DEBUG\n          return SQLITE_CORRUPT_BKPT();\n#else\nreturn SQLITE_CORRUPT_BKPT;\n#endif\n        }\n        pPage.nFree = (u16)(nFree - iCellFirst);\n        pPage.isInit = 1;\n      }\n      return SQLITE_OK;\n    }\n\n    /*\n    ** Set up a raw page so that it looks like a database page holding\n    ** no entries.\n    */\n    static void zeroPage(MemPage pPage, int flags)\n    {\n      byte[] data = pPage.aData;\n      BtShared pBt = pPage.pBt;\n      u8 hdr = pPage.hdrOffset;\n      u16 first;\n\n      Debug.Assert(sqlite3PagerPagenumber(pPage.pDbPage) == pPage.pgno);\n      Debug.Assert(sqlite3PagerGetExtra(pPage.pDbPage) == pPage);\n      Debug.Assert(sqlite3PagerGetData(pPage.pDbPage) == data);\n      Debug.Assert(sqlite3PagerIswriteable(pPage.pDbPage));\n      Debug.Assert(sqlite3_mutex_held(pBt.mutex));\n      /*memset(data[hdr], 0, pBt.usableSize - hdr);*/\n      data[hdr] = (u8)flags;\n      first = (u16)(hdr + 8 + 4 * ((flags & PTF_LEAF) == 0 ? 1 : 0));\n      Array.Clear(data, hdr + 1, 4);//memset(data[hdr+1], 0, 4);\n      data[hdr + 7] = 0;\n      put2byte(data, hdr + 5, pBt.usableSize);\n      pPage.nFree = (u16)(pBt.usableSize - first);\n      decodeFlags(pPage, flags);\n      pPage.hdrOffset = hdr;\n      pPage.cellOffset = first;\n      pPage.nOverflow = 0;\n      Debug.Assert(pBt.pageSize >= 512 && pBt.pageSize <= 32768);\n      pPage.maskPage = (u16)(pBt.pageSize - 1);\n      pPage.nCell = 0;\n      pPage.isInit = 1;\n    }\n\n\n    /*\n    ** Convert a DbPage obtained from the pager into a MemPage used by\n    ** the btree layer.\n    */\n    static MemPage btreePageFromDbPage(DbPage pDbPage, Pgno pgno, BtShared pBt)\n    {\n      MemPage pPage = (MemPage)sqlite3PagerGetExtra(pDbPage);\n      pPage.aData = sqlite3PagerGetData(pDbPage);\n      pPage.pDbPage = pDbPage;\n      pPage.pBt = pBt;\n      pPage.pgno = pgno;\n      pPage.hdrOffset = (u8)(pPage.pgno == 1 ? 100 : 0);\n      return pPage;\n    }\n\n    /*\n    ** Get a page from the pager.  Initialize the MemPage.pBt and\n    ** MemPage.aData elements if needed.\n    **\n    ** If the noContent flag is set, it means that we do not care about\n    ** the content of the page at this time.  So do not go to the disk\n    ** to fetch the content.  Just fill in the content with zeros for now.\n    ** If in the future we call sqlite3PagerWrite() on this page, that\n    ** means we have started to be concerned about content and the disk\n    ** read should occur at that point.\n    */\n    static int btreeGetPage(\n    BtShared pBt,        /* The btree */\n    Pgno pgno,           /* Number of the page to fetch */\n    ref MemPage ppPage,  /* Return the page in this parameter */\n    int noContent        /* Do not load page content if true */\n    )\n    {\n      int rc;\n      DbPage pDbPage = new PgHdr();\n\n      Debug.Assert(sqlite3_mutex_held(pBt.mutex));\n      rc = sqlite3PagerAcquire(pBt.pPager, pgno, ref pDbPage, (u8)noContent);\n      if (rc != 0) return rc;\n      ppPage = btreePageFromDbPage(pDbPage, pgno, pBt);\n      return SQLITE_OK;\n    }\n\n    /*\n    ** Retrieve a page from the pager cache. If the requested page is not\n    ** already in the pager cache return NULL. Initialize the MemPage.pBt and\n    ** MemPage.aData elements if needed.\n    */\n    static MemPage btreePageLookup(BtShared pBt, Pgno pgno)\n    {\n      DbPage pDbPage;\n      Debug.Assert(sqlite3_mutex_held(pBt.mutex));\n      pDbPage = sqlite3PagerLookup(pBt.pPager, pgno);\n      if (pDbPage)\n      {\n        return btreePageFromDbPage(pDbPage, pgno, pBt);\n      }\n      return null;\n    }\n\n    /*\n    ** Return the size of the database file in pages. If there is any kind of\n    ** error, return ((unsigned int)-1).\n    */\n    static Pgno pagerPagecount(BtShared pBt)\n    {\n      int nPage = -1;\n      int rc;\n      Debug.Assert(pBt.pPage1 != null);\n      rc = sqlite3PagerPagecount(pBt.pPager, ref nPage);\n      Debug.Assert(rc == SQLITE_OK || nPage == -1);\n      return (Pgno)nPage;\n    }\n\n    /*\n    ** Get a page from the pager and initialize it.  This routine is just a\n    ** convenience wrapper around separate calls to btreeGetPage() and\n    ** btreeInitPage().\n    **\n    ** If an error occurs, then the value ppPage is set to is undefined. It\n    ** may remain unchanged, or it may be set to an invalid value.\n    */\n    static int getAndInitPage(\n    BtShared pBt,          /* The database file */\n    Pgno pgno,             /* Number of the page to get */\n    ref MemPage ppPage     /* Write the page pointer here */\n    )\n    {\n      int rc;\n#if !NDEBUG || SQLITE_COVERAGE_TEST\n      Pgno iLastPg = pagerPagecount(pBt);//  TESTONLY( Pgno iLastPg = pagerPagecount(pBt); )\n#else\nconst Pgno iLastPg = Pgno.MaxValue;\n#endif\n      Debug.Assert(sqlite3_mutex_held(pBt.mutex));\n\n      rc = btreeGetPage(pBt, pgno, ref ppPage, 0);\n      if (rc == SQLITE_OK)\n      {\n        rc = btreeInitPage(ppPage);\n        if (rc != SQLITE_OK)\n        {\n          releasePage(ppPage);\n        }\n      }\n\n      /* If the requested page number was either 0 or greater than the page\n      ** number of the last page in the database, this function should return\n      ** SQLITE_CORRUPT or some other error (i.e. SQLITE_FULL). Check that this\n      ** is the case.  */\n      Debug.Assert((pgno > 0 && pgno <= iLastPg) || rc != SQLITE_OK);\n      testcase(pgno == 0);\n      testcase(pgno == iLastPg);\n\n      return rc;\n    }\n\n    /*\n    ** Release a MemPage.  This should be called once for each prior\n    ** call to btreeGetPage.\n    */\n    static void releasePage(MemPage pPage)\n    {\n      if (pPage != null)\n      {\n        Debug.Assert(pPage.nOverflow == 0 || sqlite3PagerPageRefcount(pPage.pDbPage) > 1);\n        Debug.Assert(pPage.aData != null);\n        Debug.Assert(pPage.pBt != null);\n        Debug.Assert(sqlite3PagerGetExtra(pPage.pDbPage) == pPage);\n        Debug.Assert(sqlite3PagerGetData(pPage.pDbPage) == pPage.aData);\n        Debug.Assert(sqlite3_mutex_held(pPage.pBt.mutex));\n        sqlite3PagerUnref(pPage.pDbPage);\n      }\n    }\n\n    /*\n    ** During a rollback, when the pager reloads information into the cache\n    ** so that the cache is restored to its original state at the start of\n    ** the transaction, for each page restored this routine is called.\n    **\n    ** This routine needs to reset the extra data section at the end of the\n    ** page to agree with the restored data.\n    */\n    static void pageReinit(DbPage pData)\n    {\n      MemPage pPage;\n      pPage = sqlite3PagerGetExtra(pData);\n      Debug.Assert(sqlite3PagerPageRefcount(pData) > 0);\n      if (pPage.isInit != 0)\n      {\n        Debug.Assert(sqlite3_mutex_held(pPage.pBt.mutex));\n        pPage.isInit = 0;\n        if (sqlite3PagerPageRefcount(pData) > 1)\n        {\n          /* pPage might not be a btree page;  it might be an overflow page\n          ** or ptrmap page or a free page.  In those cases, the following\n          ** call to btreeInitPage() will likely return SQLITE_CORRUPT.\n          ** But no harm is done by this.  And it is very important that\n          ** btreeInitPage() be called on every btree page so we make\n          ** the call for every page that comes in for re-initing. */\n          btreeInitPage(pPage);\n        }\n      }\n    }\n\n    /*\n    ** Invoke the busy handler for a btree.\n    */\n    static int btreeInvokeBusyHandler(object pArg)\n    {\n      BtShared pBt = (BtShared)pArg;\n      Debug.Assert(pBt.db != null);\n      Debug.Assert(sqlite3_mutex_held(pBt.db.mutex));\n      return sqlite3InvokeBusyHandler(pBt.db.busyHandler);\n    }\n\n    /*\n    ** Open a database file.\n    **\n    ** zFilename is the name of the database file.  If zFilename is NULL\n    ** a new database with a random name is created.  This randomly named\n    ** database file will be deleted when sqlite3BtreeClose() is called.\n    ** If zFilename is ":memory:" then an in-memory database is created\n    ** that is automatically destroyed when it is closed.\n    **\n    ** If the database is already opened in the same database connection\n    ** and we are in shared cache mode, then the open will fail with an\n    ** SQLITE_CONSTRAINT error.  We cannot allow two or more BtShared\n    ** objects in the same database connection since doing so will lead\n    ** to problems with locking.\n    */\n    static int sqlite3BtreeOpen(\n    string zFilename,       /* Name of the file containing the BTree database */\n    sqlite3 db,             /* Associated database handle */\n    ref Btree ppBtree,      /* Pointer to new Btree object written here */\n    int flags,              /* Options */\n    int vfsFlags            /* Flags passed through to sqlite3_vfs.xOpen() */\n    )\n    {\n      sqlite3_vfs pVfs;             /* The VFS to use for this btree */\n      BtShared pBt = null;          /* Shared part of btree structure */\n      Btree p;                      /* Handle to return */\n      sqlite3_mutex mutexOpen = null;  /* Prevents a race condition. Ticket #3537 */\n      int rc = SQLITE_OK;            /* Result code from this function */\n      u8 nReserve;                   /* Byte of unused space on each page */\n      byte[] zDbHeader = new byte[100]; /* Database header content */\n\n      /* Set the variable isMemdb to true for an in-memory database, or\n      ** false for a file-based database. This symbol is only required if\n      ** either of the shared-data or autovacuum features are compiled\n      ** into the library.\n      */\n#if !(SQLITE_OMIT_SHARED_CACHE) || !(SQLITE_OMIT_AUTOVACUUM)\n#if SQLITE_OMIT_MEMORYDB\nbool isMemdb = false;\n#else\n      bool isMemdb = zFilename == ":memory:";\n#endif\n#endif\n\n      Debug.Assert(db != null);\n      Debug.Assert(sqlite3_mutex_held(db.mutex));\n\n      pVfs = db.pVfs;\n      p = new Btree();//sqlite3MallocZero(sizeof(Btree));\n      //if( !p ){\n      //  return SQLITE_NOMEM;\n      //}\n      p.inTrans = TRANS_NONE;\n      p.db = db;\n#if !SQLITE_OMIT_SHARED_CACHE\np.lock.pBtree = p;\np.lock.iTable = 1;\n#endif\n\n#if !(SQLITE_OMIT_SHARED_CACHE) && !(SQLITE_OMIT_DISKIO)\n/*\n** If this Btree is a candidate for shared cache, try to find an\n** existing BtShared object that we can share with\n*/\nif( isMemdb==null && zFilename && zFilename[0] ){\nif( sqlite3GlobalConfig.sharedCacheEnabled ){\nint nFullPathname = pVfs.mxPathname+1;\nstring zFullPathname = sqlite3Malloc(nFullPathname);\nsqlite3_mutex *mutexShared;\np.sharable = 1;\nif( !zFullPathname ){\np = null;//sqlite3_free(ref p);\nreturn SQLITE_NOMEM;\n}\nsqlite3OsFullPathname(pVfs, zFilename, nFullPathname, zFullPathname);\nmutexOpen = sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_OPEN);\nsqlite3_mutex_enter(mutexOpen);\nmutexShared = sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_MASTER);\nsqlite3_mutex_enter(mutexShared);\nfor(pBt=GLOBAL(BtShared*,sqlite3SharedCacheList); pBt; pBt=pBt.pNext){\nDebug.Assert( pBt.nRef>0 );\nif( 0==strcmp(zFullPathname, sqlite3PagerFilename(pBt.pPager))\n&& sqlite3PagerVfs(pBt.pPager)==pVfs ){\nint iDb;\nfor(iDb=db.nDb-1; iDb>=0; iDb--){\nBtree pExisting = db.aDb[iDb].pBt;\nif( pExisting && pExisting.pBt==pBt ){\nsqlite3_mutex_leave(mutexShared);\nsqlite3_mutex_leave(mutexOpen);\nzFullPathname = null;//sqlite3_free(ref zFullPathname);\np=null;//sqlite3_free(ref p);\nreturn SQLITE_CONSTRAINT;\n}\n}\np.pBt = pBt;\npBt.nRef++;\nbreak;\n}\n}\nsqlite3_mutex_leave(mutexShared);\nzFullPathname=null;//sqlite3_free(ref zFullPathname);\n}\n#if SQLITE_DEBUG\nelse{\n/* In debug mode, we mark all persistent databases as sharable\n** even when they are not.  This exercises the locking code and\n** gives more opportunity for asserts(sqlite3_mutex_held())\n** statements to find locking problems.\n*/\np.sharable = 1;\n}\n#endif\n}\n#endif\n      if (pBt == null)\n      {\n        /*\n        ** The following asserts make sure that structures used by the btree are\n        ** the right size.  This is to guard against size changes that result\n        ** when compiling on a different architecture.\n        */\n        Debug.Assert(sizeof(i64) == 8 || sizeof(i64) == 4);\n        Debug.Assert(sizeof(u64) == 8 || sizeof(u64) == 4);\n        Debug.Assert(sizeof(u32) == 4);\n        Debug.Assert(sizeof(u16) == 2);\n        Debug.Assert(sizeof(Pgno) == 4);\n\n        pBt = new BtShared();//sqlite3MallocZero( sizeof(pBt) );\n        //if( pBt==null ){\n        //  rc = SQLITE_NOMEM;\n        //  goto btree_open_out;\n        //}\n        rc = sqlite3PagerOpen(pVfs, ref pBt.pPager, zFilename,\n        EXTRA_SIZE, flags, vfsFlags, pageReinit);\n        if (rc == SQLITE_OK)\n        {\n          rc = sqlite3PagerReadFileheader(pBt.pPager, zDbHeader.Length, zDbHeader);\n        }\n        if (rc != SQLITE_OK)\n        {\n          goto btree_open_out;\n        }\n        pBt.db = db;\n        sqlite3PagerSetBusyhandler(pBt.pPager, btreeInvokeBusyHandler, pBt);\n        p.pBt = pBt;\n\n        pBt.pCursor = null;\n        pBt.pPage1 = null;\n        pBt.readOnly = sqlite3PagerIsreadonly(pBt.pPager);\n        pBt.pageSize = (u16)get2byte(zDbHeader, 16);\n        if (pBt.pageSize < 512 || pBt.pageSize > SQLITE_MAX_PAGE_SIZE\n        || ((pBt.pageSize - 1) & pBt.pageSize) != 0)\n        {\n          pBt.pageSize = 0;\n#if !SQLITE_OMIT_AUTOVACUUM\n          /* If the magic name ":memory:" will create an in-memory database, then\n** leave the autoVacuum mode at 0 (do not auto-vacuum), even if\n** SQLITE_DEFAULT_AUTOVACUUM is true. On the other hand, if\n** SQLITE_OMIT_MEMORYDB has been defined, then ":memory:" is just a\n** regular file-name. In this case the auto-vacuum applies as per normal.\n*/\n          if (zFilename != "" && !isMemdb)\n          {\n            pBt.autoVacuum = (SQLITE_DEFAULT_AUTOVACUUM != 0);\n            pBt.incrVacuum = (SQLITE_DEFAULT_AUTOVACUUM == 2);\n          }\n#endif\n          nReserve = 0;\n        }\n        else\n        {\n          nReserve = zDbHeader[20];\n          pBt.pageSizeFixed = true;\n#if !SQLITE_OMIT_AUTOVACUUM\n          pBt.autoVacuum = sqlite3Get4byte(zDbHeader, 36 + 4 * 4) != 0;\n          pBt.incrVacuum = sqlite3Get4byte(zDbHeader, 36 + 7 * 4) != 0;\n#endif\n        }\n        rc = sqlite3PagerSetPagesize(pBt.pPager, ref pBt.pageSize, nReserve);\n        if (rc != 0) goto btree_open_out;\n        pBt.usableSize = (u16)(pBt.pageSize - nReserve);\n        Debug.Assert((pBt.pageSize & 7) == 0);  /* 8-byte alignment of pageSize */\n\n#if !(SQLITE_OMIT_SHARED_CACHE) && !(SQLITE_OMIT_DISKIO)\n/* Add the new BtShared object to the linked list sharable BtShareds.\n*/\nif( p.sharable ){\nsqlite3_mutex *mutexShared;\npBt.nRef = 1;\nmutexShared = sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_MASTER);\nif( SQLITE_THREADSAFE && sqlite3GlobalConfig.bCoreMutex ){\npBt.mutex = sqlite3MutexAlloc(SQLITE_MUTEX_FAST);\nif( pBt.mutex==null ){\nrc = SQLITE_NOMEM;\ndb.mallocFailed = 0;\ngoto btree_open_out;\n}\n}\nsqlite3_mutex_enter(mutexShared);\npBt.pNext = GLOBAL(BtShared*,sqlite3SharedCacheList);\nGLOBAL(BtShared*,sqlite3SharedCacheList) = pBt;\nsqlite3_mutex_leave(mutexShared);\n}\n#endif\n      }\n\n#if !(SQLITE_OMIT_SHARED_CACHE) && !(SQLITE_OMIT_DISKIO)\n/* If the new Btree uses a sharable pBtShared, then link the new\n** Btree into the list of all sharable Btrees for the same connection.\n** The list is kept in ascending order by pBt address.\n*/\nif( p.sharable ){\nint i;\nBtree pSib;\nfor(i=0; i<db.nDb; i++){\nif( (pSib = db.aDb[i].pBt)!=null && pSib.sharable ){\nwhile( pSib.pPrev ){ pSib = pSib.pPrev; }\nif( p.pBt<pSib.pBt ){\np.pNext = pSib;\np.pPrev = 0;\npSib.pPrev = p;\n}else{\nwhile( pSib.pNext && pSib.pNext.pBt<p.pBt ){\npSib = pSib.pNext;\n}\np.pNext = pSib.pNext;\np.pPrev = pSib;\nif( p.pNext ){\np.pNext.pPrev = p;\n}\npSib.pNext = p;\n}\nbreak;\n}\n}\n}\n#endif\n      ppBtree = p;\n\n    btree_open_out:\n      if (rc != SQLITE_OK)\n      {\n        if (pBt != null && pBt.pPager != null)\n        {\n          sqlite3PagerClose(pBt.pPager);\n        }\n        pBt = null; //    sqlite3_free(ref pBt);\n        p = null; //    sqlite3_free(ref p);\n        ppBtree = null;\n      }\n      if (mutexOpen != null)\n      {\n        Debug.Assert(sqlite3_mutex_held(mutexOpen));\n        sqlite3_mutex_leave(mutexOpen);\n      }\n      return rc;\n    }\n\n    /*\n    ** Decrement the BtShared.nRef counter.  When it reaches zero,\n    ** remove the BtShared structure from the sharing list.  Return\n    ** true if the BtShared.nRef counter reaches zero and return\n    ** false if it is still positive.\n    */\n    static bool removeFromSharingList(BtShared pBt)\n    {\n#if !SQLITE_OMIT_SHARED_CACHE\nsqlite3_mutex pMaster;\nBtShared pList;\nbool removed = false;\n\nDebug.Assert( sqlite3_mutex_notheld(pBt.mutex) );\npMaster = sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_MASTER);\nsqlite3_mutex_enter(pMaster);\npBt.nRef--;\nif( pBt.nRef<=0 ){\nif( GLOBAL(BtShared*,sqlite3SharedCacheList)==pBt ){\nGLOBAL(BtShared*,sqlite3SharedCacheList) = pBt.pNext;\n}else{\npList = GLOBAL(BtShared*,sqlite3SharedCacheList);\nwhile( ALWAYS(pList) && pList.pNext!=pBt ){\npList=pList.pNext;\n}\nif( ALWAYS(pList) ){\npList.pNext = pBt.pNext;\n}\n}\nif( SQLITE_THREADSAFE ){\nsqlite3_mutex_free(pBt.mutex);\n}\nremoved = true;\n}\nsqlite3_mutex_leave(pMaster);\nreturn removed;\n#else\n      return true;\n#endif\n    }\n\n    /*\n    ** Make sure pBt.pTmpSpace points to an allocation of\n    ** MX_CELL_SIZE(pBt) bytes.\n    */\n    static void allocateTempSpace(BtShared pBt)\n    {\n      if (null == pBt.pTmpSpace)\n      {\n        pBt.pTmpSpace = new byte[pBt.pageSize]; //sqlite3PageMalloc( pBt.pageSize );\n      }\n    }\n\n    /*\n    ** Free the pBt.pTmpSpace allocation\n    */\n    static void freeTempSpace(BtShared pBt)\n    {\n      //sqlite3PageFree(ref pBt.pTmpSpace);\n      pBt.pTmpSpace = null;\n    }\n\n    /*\n** Close an open database and invalidate all cursors.\n*/\n    static int sqlite3BtreeClose(ref Btree p)\n    {\n      BtShared pBt = p.pBt;\n      BtCursor pCur;\n\n      /* Close all cursors opened via this handle.  */\n      Debug.Assert(sqlite3_mutex_held(p.db.mutex));\n      sqlite3BtreeEnter(p);\n      pCur = pBt.pCursor;\n      while (pCur != null)\n      {\n        BtCursor pTmp = pCur;\n        pCur = pCur.pNext;\n        if (pTmp.pBtree == p)\n        {\n          sqlite3BtreeCloseCursor(pTmp);\n        }\n      }\n\n      /* Rollback any active transaction and free the handle structure.\n      ** The call to sqlite3BtreeRollback() drops any table-locks held by\n      ** this handle.\n      */\n      sqlite3BtreeRollback(p);\n      sqlite3BtreeLeave(p);\n\n      /* If there are still other outstanding references to the shared-btree\n      ** structure, return now. The remainder of this procedure cleans\n      ** up the shared-btree.\n      */\n      Debug.Assert(p.wantToLock == 0 && !p.locked);\n      if (!p.sharable || removeFromSharingList(pBt))\n      {\n        /* The pBt is no longer on the sharing list, so we can access\n        ** it without having to hold the mutex.\n        **\n        ** Clean out and delete the BtShared object.\n        */\n        Debug.Assert(null == pBt.pCursor);\n        sqlite3PagerClose(pBt.pPager);\n        if (pBt.xFreeSchema != null && pBt.pSchema != null)\n        {\n          pBt.xFreeSchema(pBt.pSchema);\n        }\n        pBt.pSchema = null;// sqlite3_free( ref pBt.pSchema );\n        //freeTempSpace(pBt);\n        pBt = null; //sqlite3_free(ref pBt);\n      }\n\n#if !SQLITE_OMIT_SHARED_CACHE\nDebug.Assert( p.wantToLock==null );\nDebug.Assert( p.locked==null );\nif( p.pPrev ) p.pPrev.pNext = p.pNext;\nif( p.pNext ) p.pNext.pPrev = p.pPrev;\n#endif\n\n      //sqlite3_free(ref p);\n      return SQLITE_OK;\n    }\n\n    /*\n    ** Change the limit on the number of pages allowed in the cache.\n    **\n    ** The maximum number of cache pages is set to the absolute\n    ** value of mxPage.  If mxPage is negative, the pager will\n    ** operate asynchronously - it will not stop to do fsync()s\n    ** to insure data is written to the disk surface before\n    ** continuing.  Transactions still work if synchronous is off,\n    ** and the database cannot be corrupted if this program\n    ** crashes.  But if the operating system crashes or there is\n    ** an abrupt power failure when synchronous is off, the database\n    ** could be left in an inconsistent and unrecoverable state.\n    ** Synchronous is on by default so database corruption is not\n    ** normally a worry.\n    */\n    static int sqlite3BtreeSetCacheSize(Btree p, int mxPage)\n    {\n      BtShared pBt = p.pBt;\n      Debug.Assert(sqlite3_mutex_held(p.db.mutex));\n      sqlite3BtreeEnter(p);\n      sqlite3PagerSetCachesize(pBt.pPager, mxPage);\n      sqlite3BtreeLeave(p);\n      return SQLITE_OK;\n    }\n\n    /*\n    ** Change the way data is synced to disk in order to increase or decrease\n    ** how well the database resists damage due to OS crashes and power\n    ** failures.  Level 1 is the same as asynchronous (no syncs() occur and\n    ** there is a high probability of damage)  Level 2 is the default.  There\n    ** is a very low but non-zero probability of damage.  Level 3 reduces the\n    ** probability of damage to near zero but with a write performance reduction.\n    */\n#if !SQLITE_OMIT_PAGER_PRAGMAS\n    static int sqlite3BtreeSetSafetyLevel(Btree p, int level, int fullSync)\n    {\n      BtShared pBt = p.pBt;\n      Debug.Assert(sqlite3_mutex_held(p.db.mutex));\n      sqlite3BtreeEnter(p);\n      sqlite3PagerSetSafetyLevel(pBt.pPager, level, fullSync != 0);\n      sqlite3BtreeLeave(p);\n      return SQLITE_OK;\n    }\n#endif\n\n    /*\n** Return TRUE if the given btree is set to safety level 1.  In other\n** words, return TRUE if no sync() occurs on the disk files.\n*/\n    static int sqlite3BtreeSyncDisabled(Btree p)\n    {\n      BtShared pBt = p.pBt;\n      int rc;\n      Debug.Assert(sqlite3_mutex_held(p.db.mutex));\n      sqlite3BtreeEnter(p);\n      Debug.Assert(pBt != null && pBt.pPager != null);\n      rc = sqlite3PagerNosync(pBt.pPager) ? 1 : 0;\n      sqlite3BtreeLeave(p);\n      return rc;\n    }\n\n#if !(SQLITE_OMIT_PAGER_PRAGMAS) || !(SQLITE_OMIT_VACUUM)\n    /*\n** Change the default pages size and the number of reserved bytes per page.\n** Or, if the page size has already been fixed, return SQLITE_READONLY\n** without changing anything.\n**\n** The page size must be a power of 2 between 512 and 65536.  If the page\n** size supplied does not meet this constraint then the page size is not\n** changed.\n**\n** Page sizes are constrained to be a power of two so that the region\n** of the database file used for locking (beginning at PENDING_BYTE,\n** the first byte past the 1GB boundary, 0x40000000) needs to occur\n** at the beginning of a page.\n**\n** If parameter nReserve is less than zero, then the number of reserved\n** bytes per page is left unchanged.\n**\n** If the iFix!=null then the pageSizeFixed flag is set so that the page size\n** and autovacuum mode can no longer be changed.\n*/\n    static int sqlite3BtreeSetPageSize(Btree p, int pageSize, int nReserve, int iFix)\n    {\n      int rc = SQLITE_OK;\n      BtShared pBt = p.pBt;\n      Debug.Assert(nReserve >= -1 && nReserve <= 255);\n      sqlite3BtreeEnter(p);\n      if (pBt.pageSizeFixed)\n      {\n        sqlite3BtreeLeave(p);\n        return SQLITE_READONLY;\n      }\n      if (nReserve < 0)\n      {\n        nReserve = pBt.pageSize - pBt.usableSize;\n      }\n      Debug.Assert(nReserve >= 0 && nReserve <= 255);\n      if (pageSize >= 512 && pageSize <= SQLITE_MAX_PAGE_SIZE &&\n      ((pageSize - 1) & pageSize) == 0)\n      {\n        Debug.Assert((pageSize & 7) == 0);\n        Debug.Assert(null == pBt.pPage1 && null == pBt.pCursor);\n        pBt.pageSize = (u16)pageSize;\n        //        freeTempSpace(pBt);\n      }\n      rc = sqlite3PagerSetPagesize(pBt.pPager, ref pBt.pageSize, nReserve);\n      pBt.usableSize = (u16)(pBt.pageSize - nReserve);\n      if (iFix != 0) pBt.pageSizeFixed = true;\n      sqlite3BtreeLeave(p);\n      return rc;\n    }\n\n    /*\n    ** Return the currently defined page size\n    */\n    static int sqlite3BtreeGetPageSize(Btree p)\n    {\n      return p.pBt.pageSize;\n    }\n\n    /*\n    ** Return the number of bytes of space at the end of every page that\n    ** are intentually left unused.  This is the "reserved" space that is\n    ** sometimes used by extensions.\n    */\n    static int sqlite3BtreeGetReserve(Btree p)\n    {\n      int n;\n      sqlite3BtreeEnter(p);\n      n = p.pBt.pageSize - p.pBt.usableSize;\n      sqlite3BtreeLeave(p);\n      return n;\n    }\n\n    /*\n    ** Set the maximum page count for a database if mxPage is positive.\n    ** No changes are made if mxPage is 0 or negative.\n    ** Regardless of the value of mxPage, return the maximum page count.\n    */\n    static int sqlite3BtreeMaxPageCount(Btree p, int mxPage)\n    {\n      int n;\n      sqlite3BtreeEnter(p);\n      n = (int)sqlite3PagerMaxPageCount(p.pBt.pPager, mxPage);\n      sqlite3BtreeLeave(p);\n      return n;\n    }\n#endif //* !(SQLITE_OMIT_PAGER_PRAGMAS) || !(SQLITE_OMIT_VACUUM) */\n\n    /*\n** Change the \'auto-vacuum\' property of the database. If the \'autoVacuum\'\n** parameter is non-zero, then auto-vacuum mode is enabled. If zero, it\n** is disabled. The default value for the auto-vacuum property is\n** determined by the SQLITE_DEFAULT_AUTOVACUUM macro.\n*/\n    static int sqlite3BtreeSetAutoVacuum(Btree p, int autoVacuum)\n    {\n#if SQLITE_OMIT_AUTOVACUUM\nreturn SQLITE_READONLY;\n#else\n      BtShared pBt = p.pBt;\n      int rc = SQLITE_OK;\n      u8 av = (u8)autoVacuum;\n\n      sqlite3BtreeEnter(p);\n      if (pBt.pageSizeFixed && (av != 0) != pBt.autoVacuum)\n      {\n        rc = SQLITE_READONLY;\n      }\n      else\n      {\n        pBt.autoVacuum = av != 0;\n        pBt.incrVacuum = av == 2;\n      }\n      sqlite3BtreeLeave(p);\n      return rc;\n#endif\n    }\n\n    /*\n    ** Return the value of the \'auto-vacuum\' property. If auto-vacuum is\n    ** enabled 1 is returned. Otherwise 0.\n    */\n    static int sqlite3BtreeGetAutoVacuum(Btree p)\n    {\n#if SQLITE_OMIT_AUTOVACUUM\nreturn BTREE_AUTOVACUUM_NONE;\n#else\n      int rc;\n      sqlite3BtreeEnter(p);\n      rc = (\n      (!p.pBt.autoVacuum) ? BTREE_AUTOVACUUM_NONE :\n      (!p.pBt.incrVacuum) ? BTREE_AUTOVACUUM_FULL :\n      BTREE_AUTOVACUUM_INCR\n      );\n      sqlite3BtreeLeave(p);\n      return rc;\n#endif\n    }\n\n\n    /*\n    ** Get a reference to pPage1 of the database file.  This will\n    ** also acquire a readlock on that file.\n    **\n    ** SQLITE_OK is returned on success.  If the file is not a\n    ** well-formed database file, then SQLITE_CORRUPT is returned.\n    ** SQLITE_BUSY is returned if the database is locked.  SQLITE_NOMEM\n    ** is returned if we run out of memory.\n    */\n    static int lockBtree(BtShared pBt)\n    {\n      int rc;\n      MemPage pPage1 = new MemPage();\n      int nPage = 0;\n\n      Debug.Assert(sqlite3_mutex_held(pBt.mutex));\n      Debug.Assert(pBt.pPage1 == null);\n      rc = sqlite3PagerSharedLock(pBt.pPager);\n      if (rc != SQLITE_OK) return rc;\n      rc = btreeGetPage(pBt, 1, ref pPage1, 0);\n      if (rc != SQLITE_OK) return rc;\n\n      /* Do some checking to help insure the file we opened really is\n      ** a valid database file.\n      */\n      rc = sqlite3PagerPagecount(pBt.pPager, ref nPage);\n      if (rc != SQLITE_OK)\n      {\n        goto page1_init_failed;\n      }\n      else if (nPage > 0)\n      {\n        int pageSize;\n        int usableSize;\n        u8[] page1 = pPage1.aData;\n        rc = SQLITE_NOTADB;\n        if (memcmp(page1, zMagicHeader, 16) != 0)\n        {\n          goto page1_init_failed;\n        }\n        if (page1[18] > 1)\n        {\n          pBt.readOnly = true;\n        }\n        if (page1[19] > 1)\n        {\n          goto page1_init_failed;\n        }\n\n        /* The maximum embedded fraction must be exactly 25%.  And the minimum\n        ** embedded fraction must be 12.5% for both leaf-data and non-leaf-data.\n        ** The original design allowed these amounts to vary, but as of\n        ** version 3.6.0, we require them to be fixed.\n        */\n        if (memcmp(page1, 21, "\\x0040\\x0020\\x0020", 3) != 0)//   "\\100\\040\\040"\n        {\n          goto page1_init_failed;\n        }\n        pageSize = get2byte(page1, 16);\n        if (((pageSize - 1) & pageSize) != 0 || pageSize < 512 ||\n        (SQLITE_MAX_PAGE_SIZE < 32768 && pageSize > SQLITE_MAX_PAGE_SIZE)\n        )\n        {\n          goto page1_init_failed;\n        }\n        Debug.Assert((pageSize & 7) == 0);\n        usableSize = pageSize - page1[20];\n        if (pageSize != pBt.pageSize)\n        {\n          /* After reading the first page of the database assuming a page size\n          ** of BtShared.pageSize, we have discovered that the page-size is\n          ** actually pageSize. Unlock the database, leave pBt.pPage1 at\n          ** zero and return SQLITE_OK. The caller will call this function\n          ** again with the correct page-size.\n          */\n          releasePage(pPage1);\n          pBt.usableSize = (u16)usableSize;\n          pBt.pageSize = (u16)pageSize;\n          //          freeTempSpace(pBt);\n          rc = sqlite3PagerSetPagesize(pBt.pPager, ref pBt.pageSize,\n          pageSize - usableSize);\n          return rc;\n        }\n        if (usableSize < 480)\n        {\n          goto page1_init_failed;\n        }\n        pBt.pageSize = (u16)pageSize;\n        pBt.usableSize = (u16)usableSize;\n#if !SQLITE_OMIT_AUTOVACUUM\n        pBt.autoVacuum = (sqlite3Get4byte(page1, 36 + 4 * 4) != 0);\n        pBt.incrVacuum = (sqlite3Get4byte(page1, 36 + 7 * 4) != 0);\n#endif\n      }\n\n      /* maxLocal is the maximum amount of payload to store locally for\n      ** a cell.  Make sure it is small enough so that at least minFanout\n      ** cells can will fit on one page.  We assume a 10-byte page header.\n      ** Besides the payload, the cell must store:\n      **     2-byte pointer to the cell\n      **     4-byte child pointer\n      **     9-byte nKey value\n      **     4-byte nData value\n      **     4-byte overflow page pointer\n      ** So a cell consists of a 2-byte poiner, a header which is as much as\n      ** 17 bytes long, 0 to N bytes of payload, and an optional 4 byte overflow\n      ** page pointer.\n      */\n      pBt.maxLocal = (u16)((pBt.usableSize - 12) * 64 / 255 - 23);\n      pBt.minLocal = (u16)((pBt.usableSize - 12) * 32 / 255 - 23);\n      pBt.maxLeaf = (u16)(pBt.usableSize - 35);\n      pBt.minLeaf = (u16)((pBt.usableSize - 12) * 32 / 255 - 23);\n      Debug.Assert(pBt.maxLeaf + 23 <= MX_CELL_SIZE(pBt));\n      pBt.pPage1 = pPage1;\n      return SQLITE_OK;\n\n    page1_init_failed:\n      releasePage(pPage1);\n      pBt.pPage1 = null;\n      return rc;\n    }\n\n    /*\n    ** If there are no outstanding cursors and we are not in the middle\n    ** of a transaction but there is a read lock on the database, then\n    ** this routine unrefs the first page of the database file which\n    ** has the effect of releasing the read lock.\n    **\n    ** If there is a transaction in progress, this routine is a no-op.\n    */\n    static void unlockBtreeIfUnused(BtShared pBt)\n    {\n      Debug.Assert(sqlite3_mutex_held(pBt.mutex));\n      Debug.Assert(pBt.pCursor == null || pBt.inTransaction > TRANS_NONE);\n      if (pBt.inTransaction == TRANS_NONE && pBt.pPage1 != null)\n      {\n        Debug.Assert(pBt.pPage1.aData != null);\n        Debug.Assert(sqlite3PagerRefcount(pBt.pPager) == 1);\n        Debug.Assert(pBt.pPage1.aData != null);\n        releasePage(pBt.pPage1);\n        pBt.pPage1 = null;\n      }\n    }\n\n    /*\n    ** If pBt points to an empty file then convert that empty file\n    ** into a new empty database by initializing the first page of\n    ** the database.\n    */\n    static int newDatabase(BtShared pBt)\n    {\n      MemPage pP1;\n      byte[] data;\n      int rc;\n      int nPage = 0;\n\n      Debug.Assert(sqlite3_mutex_held(pBt.mutex));\n      /* The database size has already been measured and cached, so failure\n      ** is impossible here.  If the original size measurement failed, then\n      ** processing aborts before entering this routine. */\n      rc = sqlite3PagerPagecount(pBt.pPager, ref nPage);\n      if (NEVER(rc != SQLITE_OK) || nPage > 0)\n      {\n        return rc;\n      }\n      pP1 = pBt.pPage1;\n      Debug.Assert(pP1 != null);\n      data = pP1.aData;\n      rc = sqlite3PagerWrite(pP1.pDbPage);\n      if (rc != 0) return rc;\n      Buffer.BlockCopy(Encoding.UTF8.GetBytes(zMagicHeader), 0, data, 0, 16);// memcpy(data, zMagicHeader, sizeof(zMagicHeader));\n      Debug.Assert(zMagicHeader.Length == 16);\n      put2byte(data, 16, pBt.pageSize);\n      data[18] = 1;\n      data[19] = 1;\n      Debug.Assert(pBt.usableSize <= pBt.pageSize && pBt.usableSize + 255 >= pBt.pageSize);\n      data[20] = (u8)(pBt.pageSize - pBt.usableSize);\n      data[21] = 64;\n      data[22] = 32;\n      data[23] = 32;\n      //memset(&data[24], 0, 100-24);\n      zeroPage(pP1, PTF_INTKEY | PTF_LEAF | PTF_LEAFDATA);\n      pBt.pageSizeFixed = true;\n#if !SQLITE_OMIT_AUTOVACUUM\n      Debug.Assert(pBt.autoVacuum == true || pBt.autoVacuum == false);\n      Debug.Assert(pBt.incrVacuum == true || pBt.incrVacuum == false);\n      sqlite3Put4byte(data, 36 + 4 * 4, pBt.autoVacuum ? 1 : 0);\n      sqlite3Put4byte(data, 36 + 7 * 4, pBt.incrVacuum ? 1 : 0);\n#endif\n      return SQLITE_OK;\n    }\n\n    /*\n    ** Attempt to start a new transaction. A write-transaction\n    ** is started if the second argument is nonzero, otherwise a read-\n    ** transaction.  If the second argument is 2 or more and exclusive\n    ** transaction is started, meaning that no other process is allowed\n    ** to access the database.  A preexisting transaction may not be\n    ** upgraded to exclusive by calling this routine a second time - the\n    ** exclusivity flag only works for a new transaction.\n    **\n    ** A write-transaction must be started before attempting any\n    ** changes to the database.  None of the following routines\n    ** will work unless a transaction is started first:\n    **\n    **      sqlite3BtreeCreateTable()\n    **      sqlite3BtreeCreateIndex()\n    **      sqlite3BtreeClearTable()\n    **      sqlite3BtreeDropTable()\n    **      sqlite3BtreeInsert()\n    **      sqlite3BtreeDelete()\n    **      sqlite3BtreeUpdateMeta()\n    **\n    ** If an initial attempt to acquire the lock fails because of lock contention\n    ** and the database was previously unlocked, then invoke the busy handler\n    ** if there is one.  But if there was previously a read-lock, do not\n    ** invoke the busy handler - just return SQLITE_BUSY.  SQLITE_BUSY is\n    ** returned when there is already a read-lock in order to avoid a deadlock.\n    **\n    ** Suppose there are two processes A and B.  A has a read lock and B has\n    ** a reserved lock.  B tries to promote to exclusive but is blocked because\n    ** of A\'s read lock.  A tries to promote to reserved but is blocked by B.\n    ** One or the other of the two processes must give way or there can be\n    ** no progress.  By returning SQLITE_BUSY and not invoking the busy callback\n    ** when A already has a read lock, we encourage A to give up and let B\n    ** proceed.\n    */\n    static int sqlite3BtreeBeginTrans(Btree p, int wrflag)\n    {\n      BtShared pBt = p.pBt;\n      int rc = SQLITE_OK;\n\n      sqlite3BtreeEnter(p);\n      btreeIntegrity(p);\n\n      /* If the btree is already in a write-transaction, or it\n      ** is already in a read-transaction and a read-transaction\n      ** is requested, this is a no-op.\n      */\n      if (p.inTrans == TRANS_WRITE || (p.inTrans == TRANS_READ && 0 == wrflag))\n      {\n        goto trans_begun;\n      }\n\n      /* Write transactions are not possible on a read-only database */\n      if (pBt.readOnly && wrflag != 0)\n      {\n        rc = SQLITE_READONLY;\n        goto trans_begun;\n      }\n\n#if !SQLITE_OMIT_SHARED_CACHE\n/* If another database handle has already opened a write transaction\n** on this shared-btree structure and a second write transaction is\n** requested, return SQLITE_LOCKED.\n*/\nif( (wrflag && pBt.inTransaction==TRANS_WRITE) || pBt.isPending ){\nsqlite3 pBlock = pBt.pWriter.db;\n}else if( wrflag>1 ){\nBtLock pIter;\nfor(pIter=pBt.pLock; pIter; pIter=pIter.pNext){\nif( pIter.pBtree!=p ){\npBlock = pIter.pBtree.db;\nbreak;\n}\n}\n}\nif( pBlock ){\nsqlite3ConnectionBlocked(p.db, pBlock);\nrc = SQLITE_LOCKED_SHAREDCACHE;\ngoto trans_begun;\n}\n#endif\n\n      /* Any read-only or read-write transaction implies a read-lock on\n** page 1. So if some other shared-cache client already has a write-lock\n** on page 1, the transaction cannot be opened. */\n      rc = querySharedCacheTableLock(p, MASTER_ROOT, READ_LOCK);\n      if (SQLITE_OK != rc) goto trans_begun;\n\n      do\n      {\n        /* Call lockBtree() until either pBt.pPage1 is populated or\n        ** lockBtree() returns something other than SQLITE_OK. lockBtree()\n        ** may return SQLITE_OK but leave pBt.pPage1 set to 0 if after\n        ** reading page 1 it discovers that the page-size of the database\n        ** file is not pBt.pageSize. In this case lockBtree() will update\n        ** pBt.pageSize to the page-size of the file on disk.\n        */\n        while (pBt.pPage1 == null && SQLITE_OK == (rc = lockBtree(pBt))) ;\n\n        if (rc == SQLITE_OK && wrflag != 0)\n        {\n          if (pBt.readOnly)\n          {\n            rc = SQLITE_READONLY;\n          }\n          else\n          {\n            rc = sqlite3PagerBegin(pBt.pPager, wrflag > 1, sqlite3TempInMemory(p.db) ? 1 : 0);\n            if (rc == SQLITE_OK)\n            {\n              rc = newDatabase(pBt);\n            }\n          }\n        }\n\n        if (rc != SQLITE_OK)\n        {\n          unlockBtreeIfUnused(pBt);\n        }\n      } while (rc == SQLITE_BUSY && pBt.inTransaction == TRANS_NONE &&\n      btreeInvokeBusyHandler(pBt) != 0);\n\n      if (rc == SQLITE_OK)\n      {\n        if (p.inTrans == TRANS_NONE)\n        {\n          pBt.nTransaction++;\n#if !SQLITE_OMIT_SHARED_CACHE\nif( p.sharable ){\nDebug.Assert( p.lock.pBtree==p && p.lock.iTable==1 );\np.lock.eLock = READ_LOCK;\np.lock.pNext = pBt.pLock;\npBt.pLock = &p.lock;\n}\n#endif\n        }\n        p.inTrans = (wrflag != 0 ? TRANS_WRITE : TRANS_READ);\n        if (p.inTrans > pBt.inTransaction)\n        {\n          pBt.inTransaction = p.inTrans;\n        }\n#if !SQLITE_OMIT_SHARED_CACHE\nif( wrflag ){\nDebug.Assert( !pBt.pWriter );\npBt.pWriter = p;\npBt.isExclusive = (u8)(wrflag>1);\n}\n#endif\n      }\n\n\n    trans_begun:\n      if (rc == SQLITE_OK && wrflag != 0)\n      {\n        /* This call makes sure that the pager has the correct number of\n        ** open savepoints. If the second parameter is greater than 0 and\n        ** the sub-journal is not already open, then it will be opened here.\n        */\n        rc = sqlite3PagerOpenSavepoint(pBt.pPager, p.db.nSavepoint);\n      }\n\n      btreeIntegrity(p);\n      sqlite3BtreeLeave(p);\n      return rc;\n    }\n\n#if !SQLITE_OMIT_AUTOVACUUM\n\n    /*\n** Set the pointer-map entries for all children of page pPage. Also, if\n** pPage contains cells that point to overflow pages, set the pointer\n** map entries for the overflow pages as well.\n*/\n    static int setChildPtrmaps(MemPage pPage)\n    {\n      int i;                             /* Counter variable */\n      int nCell;                         /* Number of cells in page pPage */\n      int rc;                            /* Return code */\n      BtShared pBt = pPage.pBt;\n      u8 isInitOrig = pPage.isInit;\n      Pgno pgno = pPage.pgno;\n\n      Debug.Assert(sqlite3_mutex_held(pPage.pBt.mutex));\n      rc = btreeInitPage(pPage);\n      if (rc != SQLITE_OK)\n      {\n        goto set_child_ptrmaps_out;\n      }\n      nCell = pPage.nCell;\n\n      for (i = 0; i < nCell; i++)\n      {\n        int pCell = findCell(pPage, i);\n\n        ptrmapPutOvflPtr(pPage, pCell, ref rc);\n\n        if (0 == pPage.leaf)\n        {\n          Pgno childPgno = sqlite3Get4byte(pPage.aData, pCell);\n          ptrmapPut(pBt, childPgno, PTRMAP_BTREE, pgno, ref rc);\n        }\n      }\n\n      if (0 == pPage.leaf)\n      {\n        Pgno childPgno = sqlite3Get4byte(pPage.aData, pPage.hdrOffset + 8);\n        ptrmapPut(pBt, childPgno, PTRMAP_BTREE, pgno, ref rc);\n      }\n\n    set_child_ptrmaps_out:\n      pPage.isInit = isInitOrig;\n      return rc;\n    }\n\n    /*\n    ** Somewhere on pPage is a pointer to page iFrom.  Modify this pointer so\n    ** that it points to iTo. Parameter eType describes the type of pointer to\n    ** be modified, as  follows:\n    **\n    ** PTRMAP_BTREE:     pPage is a btree-page. The pointer points at a child\n    **                   page of pPage.\n    **\n    ** PTRMAP_OVERFLOW1: pPage is a btree-page. The pointer points at an overflow\n    **                   page pointed to by one of the cells on pPage.\n    **\n    ** PTRMAP_OVERFLOW2: pPage is an overflow-page. The pointer points at the next\n    **                   overflow page in the list.\n    */\n    static int modifyPagePointer(MemPage pPage, Pgno iFrom, Pgno iTo, u8 eType)\n    {\n      Debug.Assert(sqlite3_mutex_held(pPage.pBt.mutex));\n      Debug.Assert(sqlite3PagerIswriteable(pPage.pDbPage));\n      if (eType == PTRMAP_OVERFLOW2)\n      {\n        /* The pointer is always the first 4 bytes of the page in this case.  */\n        if (sqlite3Get4byte(pPage.aData) != iFrom)\n        {\n#if SQLITE_DEBUG || DEBUG\n          return SQLITE_CORRUPT_BKPT();\n#else\nreturn SQLITE_CORRUPT_BKPT;\n#endif\n        }\n        sqlite3Put4byte(pPage.aData, iTo);\n      }\n      else\n      {\n        u8 isInitOrig = pPage.isInit;\n        int i;\n        int nCell;\n\n        btreeInitPage(pPage);\n        nCell = pPage.nCell;\n\n        for (i = 0; i < nCell; i++)\n        {\n          int pCell = findCell(pPage, i);\n          if (eType == PTRMAP_OVERFLOW1)\n          {\n            CellInfo info = new CellInfo();\n            btreeParseCellPtr( pPage, pCell, ref info );\n            if (info.iOverflow != 0)\n            {\n              if (iFrom == sqlite3Get4byte(pPage.aData, pCell, info.iOverflow))\n              {\n                sqlite3Put4byte(pPage.aData, pCell + info.iOverflow, (int)iTo);\n                break;\n              }\n            }\n          }\n          else\n          {\n            if (sqlite3Get4byte(pPage.aData, pCell) == iFrom)\n            {\n              sqlite3Put4byte(pPage.aData, pCell, (int)iTo);\n              break;\n            }\n          }\n        }\n\n        if (i == nCell)\n        {\n          if (eType != PTRMAP_BTREE ||\n          sqlite3Get4byte(pPage.aData, pPage.hdrOffset + 8) != iFrom)\n          {\n#if SQLITE_DEBUG || DEBUG\n            return SQLITE_CORRUPT_BKPT();\n#else\nreturn SQLITE_CORRUPT_BKPT;\n#endif\n          }\n          sqlite3Put4byte(pPage.aData, pPage.hdrOffset + 8, iTo);\n        }\n\n        pPage.isInit = isInitOrig;\n      }\n      return SQLITE_OK;\n    }\n\n\n    /*\n    ** Move the open database page pDbPage to location iFreePage in the\n    ** database. The pDbPage reference remains valid.\n    **\n    ** The isCommit flag indicates that there is no need to remember that\n    ** the journal needs to be sync()ed before database page pDbPage.pgno\n    ** can be written to. The caller has already promised not to write to that\n    ** page.\n    */\n    static int relocatePage(\n    BtShared pBt,           /* Btree */\n    MemPage pDbPage,        /* Open page to move */\n    u8 eType,                /* Pointer map \'type\' entry for pDbPage */\n    Pgno iPtrPage,           /* Pointer map \'page-no\' entry for pDbPage */\n    Pgno iFreePage,          /* The location to move pDbPage to */\n    int isCommit             /* isCommit flag passed to sqlite3PagerMovepage */\n    )\n    {\n      MemPage pPtrPage = new MemPage();   /* The page that contains a pointer to pDbPage */\n      Pgno iDbPage = pDbPage.pgno;\n      Pager pPager = pBt.pPager;\n      int rc;\n\n      Debug.Assert(eType == PTRMAP_OVERFLOW2 || eType == PTRMAP_OVERFLOW1 ||\n      eType == PTRMAP_BTREE || eType == PTRMAP_ROOTPAGE);\n      Debug.Assert(sqlite3_mutex_held(pBt.mutex));\n      Debug.Assert(pDbPage.pBt == pBt);\n\n      /* Move page iDbPage from its current location to page number iFreePage */\n      TRACE("AUTOVACUUM: Moving %d to free page %d (ptr page %d type %d)\\n",\n      iDbPage, iFreePage, iPtrPage, eType);\n      rc = sqlite3PagerMovepage(pPager, pDbPage.pDbPage, iFreePage, isCommit);\n      if (rc != SQLITE_OK)\n      {\n        return rc;\n      }\n      pDbPage.pgno = iFreePage;\n\n      /* If pDbPage was a btree-page, then it may have child pages and/or cells\n      ** that point to overflow pages. The pointer map entries for all these\n      ** pages need to be changed.\n      **\n      ** If pDbPage is an overflow page, then the first 4 bytes may store a\n      ** pointer to a subsequent overflow page. If this is the case, then\n      ** the pointer map needs to be updated for the subsequent overflow page.\n      */\n      if (eType == PTRMAP_BTREE || eType == PTRMAP_ROOTPAGE)\n      {\n        rc = setChildPtrmaps(pDbPage);\n        if (rc != SQLITE_OK)\n        {\n          return rc;\n        }\n      }\n      else\n      {\n        Pgno nextOvfl = sqlite3Get4byte(pDbPage.aData);\n        if (nextOvfl != 0)\n        {\n          ptrmapPut(pBt, nextOvfl, PTRMAP_OVERFLOW2, iFreePage, ref rc);\n          if (rc != SQLITE_OK)\n          {\n            return rc;\n          }\n        }\n      }\n\n      /* Fix the database pointer on page iPtrPage that pointed at iDbPage so\n      ** that it points at iFreePage. Also fix the pointer map entry for\n      ** iPtrPage.\n      */\n      if (eType != PTRMAP_ROOTPAGE)\n      {\n        rc = btreeGetPage(pBt, iPtrPage, ref pPtrPage, 0);\n        if (rc != SQLITE_OK)\n        {\n          return rc;\n        }\n        rc = sqlite3PagerWrite(pPtrPage.pDbPage);\n        if (rc != SQLITE_OK)\n        {\n          releasePage(pPtrPage);\n          return rc;\n        }\n        rc = modifyPagePointer(pPtrPage, iDbPage, iFreePage, eType);\n        releasePage(pPtrPage);\n        if (rc == SQLITE_OK)\n        {\n          ptrmapPut(pBt, iFreePage, eType, iPtrPage, ref rc);\n        }\n      }\n      return rc;\n    }\n\n    /* Forward declaration required by incrVacuumStep(). */\n    //static int allocateBtreePage(BtShared *, MemPage **, Pgno *, Pgno, u8);\n\n    /*\n    ** Perform a single step of an incremental-vacuum. If successful,\n    ** return SQLITE_OK. If there is no work to do (and therefore no\n    ** point in calling this function again), return SQLITE_DONE.\n    **\n    ** More specificly, this function attempts to re-organize the\n    ** database so that the last page of the file currently in use\n    ** is no longer in use.\n    **\n    ** If the nFin parameter is non-zero, this function assumes\n    ** that the caller will keep calling incrVacuumStep() until\n    ** it returns SQLITE_DONE or an error, and that nFin is the\n    ** number of pages the database file will contain after this\n    ** process is complete.  If nFin is zero, it is assumed that\n    ** incrVacuumStep() will be called a finite amount of times\n    ** which may or may not empty the freelist.  A full autovacuum\n    ** has nFin>0.  A "PRAGMA incremental_vacuum" has nFin==null.\n    */\n    static int incrVacuumStep(BtShared pBt, Pgno nFin, Pgno iLastPg)\n    {\n      Pgno nFreeList;           /* Number of pages still on the free-list */\n\n      Debug.Assert(sqlite3_mutex_held(pBt.mutex));\n      Debug.Assert(iLastPg > nFin);\n\n      if (!PTRMAP_ISPAGE(pBt, iLastPg) && iLastPg != PENDING_BYTE_PAGE(pBt))\n      {\n        int rc;\n        u8 eType = 0;\n        Pgno iPtrPage = 0;\n\n        nFreeList = sqlite3Get4byte(pBt.pPage1.aData, 36);\n        if (nFreeList == 0)\n        {\n          return SQLITE_DONE;\n        }\n\n        rc = ptrmapGet(pBt, iLastPg, ref eType, ref iPtrPage);\n        if (rc != SQLITE_OK)\n        {\n          return rc;\n        }\n        if (eType == PTRMAP_ROOTPAGE)\n        {\n#if SQLITE_DEBUG || DEBUG\n          return SQLITE_CORRUPT_BKPT();\n#else\nreturn SQLITE_CORRUPT_BKPT;\n#endif\n        }\n\n        if (eType == PTRMAP_FREEPAGE)\n        {\n          if (nFin == 0)\n          {\n            /* Remove the page from the files free-list. This is not required\n            ** if nFin is non-zero. In that case, the free-list will be\n            ** truncated to zero after this function returns, so it doesn\'t\n            ** matter if it still contains some garbage entries.\n            */\n            Pgno iFreePg = 0;\n            MemPage pFreePg = new MemPage();\n            rc = allocateBtreePage(pBt, ref pFreePg, ref iFreePg, iLastPg, 1);\n            if (rc != SQLITE_OK)\n            {\n              return rc;\n            }\n            Debug.Assert(iFreePg == iLastPg);\n            releasePage(pFreePg);\n          }\n        }\n        else\n        {\n          Pgno iFreePg = 0;             /* Index of free page to move pLastPg to */\n          MemPage pLastPg = new MemPage();\n\n          rc = btreeGetPage(pBt, iLastPg, ref pLastPg, 0);\n          if (rc != SQLITE_OK)\n          {\n            return rc;\n          }\n\n          /* If nFin is zero, this loop runs exactly once and page pLastPg\n          ** is swapped with the first free page pulled off the free list.\n          **\n          ** On the other hand, if nFin is greater than zero, then keep\n          ** looping until a free-page located within the first nFin pages\n          ** of the file is found.\n          */\n          do\n          {\n            MemPage pFreePg = new MemPage();\n            rc = allocateBtreePage(pBt, ref pFreePg, ref iFreePg, 0, 0);\n            if (rc != SQLITE_OK)\n            {\n              releasePage(pLastPg);\n              return rc;\n            }\n            releasePage(pFreePg);\n          } while (nFin != 0 && iFreePg > nFin);\n          Debug.Assert(iFreePg < iLastPg);\n\n          rc = sqlite3PagerWrite(pLastPg.pDbPage);\n          if (rc == SQLITE_OK)\n          {\n            rc = relocatePage(pBt, pLastPg, eType, iPtrPage, iFreePg, (nFin != 0) ? 1 : 0);\n          }\n          releasePage(pLastPg);\n          if (rc != SQLITE_OK)\n          {\n            return rc;\n          }\n        }\n      }\n\n      if (nFin == 0)\n      {\n        iLastPg--;\n        while (iLastPg == PENDING_BYTE_PAGE(pBt) || PTRMAP_ISPAGE(pBt, iLastPg))\n        {\n          if (PTRMAP_ISPAGE(pBt, iLastPg))\n          {\n            MemPage pPg = new MemPage();\n            int rc = btreeGetPage(pBt, iLastPg, ref pPg, 0);\n            if (rc != SQLITE_OK)\n            {\n              return rc;\n            }\n            rc = sqlite3PagerWrite(pPg.pDbPage);\n            releasePage(pPg);\n            if (rc != SQLITE_OK)\n            {\n              return rc;\n            }\n          }\n          iLastPg--;\n        }\n        sqlite3PagerTruncateImage(pBt.pPager, iLastPg);\n      }\n      return SQLITE_OK;\n    }\n\n    /*\n    ** A write-transaction must be opened before calling this function.\n    ** It performs a single unit of work towards an incremental vacuum.\n    **\n    ** If the incremental vacuum is finished after this function has run,\n    ** SQLITE_DONE is returned. If it is not finished, but no error occurred,\n    ** SQLITE_OK is returned. Otherwise an SQLite error code.\n    */\n    static int sqlite3BtreeIncrVacuum(Btree p)\n    {\n      int rc;\n      BtShared pBt = p.pBt;\n\n      sqlite3BtreeEnter(p);\n      Debug.Assert(pBt.inTransaction == TRANS_WRITE && p.inTrans == TRANS_WRITE);\n      if (!pBt.autoVacuum)\n      {\n        rc = SQLITE_DONE;\n      }\n      else\n      {\n        invalidateAllOverflowCache(pBt);\n        rc = incrVacuumStep(pBt, 0, pagerPagecount(pBt));\n      }\n      sqlite3BtreeLeave(p);\n      return rc;\n    }\n\n    /*\n    ** This routine is called prior to sqlite3PagerCommit when a transaction\n    ** is commited for an auto-vacuum database.\n    **\n    ** If SQLITE_OK is returned, then pnTrunc is set to the number of pages\n    ** the database file should be truncated to during the commit process.\n    ** i.e. the database has been reorganized so that only the first pnTrunc\n    ** pages are in use.\n    */\n    static int autoVacuumCommit(BtShared pBt)\n    {\n      int rc = SQLITE_OK;\n      Pager pPager = pBt.pPager;\n      // VVA_ONLY( int nRef = sqlite3PagerRefcount(pPager) );\n#if !NDEBUG || DEBUG\n      int nRef = sqlite3PagerRefcount(pPager);\n#else\nint nRef=0;\n#endif\n\n\n      Debug.Assert(sqlite3_mutex_held(pBt.mutex));\n      invalidateAllOverflowCache(pBt);\n      Debug.Assert(pBt.autoVacuum);\n      if (!pBt.incrVacuum)\n      {\n        Pgno nFin;         /* Number of pages in database after autovacuuming */\n        Pgno nFree;        /* Number of pages on the freelist initially */\n        Pgno nPtrmap;      /* Number of PtrMap pages to be freed */\n        Pgno iFree;        /* The next page to be freed */\n        int nEntry;        /* Number of entries on one ptrmap page */\n        Pgno nOrig;        /* Database size before freeing */\n\n        nOrig = pagerPagecount(pBt);\n        if (PTRMAP_ISPAGE(pBt, nOrig) || nOrig == PENDING_BYTE_PAGE(pBt))\n        {\n          /* It is not possible to create a database for which the final page\n          ** is either a pointer-map page or the pending-byte page. If one\n          ** is encountered, this indicates corruption.\n          */\n#if SQLITE_DEBUG || DEBUG\n          return SQLITE_CORRUPT_BKPT();\n#else\nreturn SQLITE_CORRUPT_BKPT;\n#endif\n        }\n\n        nFree = sqlite3Get4byte(pBt.pPage1.aData, 36);\n        nEntry = pBt.usableSize / 5;\n        nPtrmap = (Pgno)(( nFree - nOrig + PTRMAP_PAGENO( pBt, nOrig ) + (Pgno)nEntry ) / nEntry);\n        nFin = nOrig - nFree - nPtrmap;\n        if (nOrig > PENDING_BYTE_PAGE(pBt) && nFin < PENDING_BYTE_PAGE(pBt))\n        {\n          nFin--;\n        }\n        while (PTRMAP_ISPAGE(pBt, nFin) || nFin == PENDING_BYTE_PAGE(pBt))\n        {\n          nFin--;\n        }\n        if (nFin > nOrig)\n#if SQLITE_DEBUG || DEBUG\n          return SQLITE_CORRUPT_BKPT();\n#else\nreturn SQLITE_CORRUPT_BKPT;\n#endif\n\n        for (iFree = nOrig; iFree > nFin && rc == SQLITE_OK; iFree--)\n        {\n          rc = incrVacuumStep(pBt, nFin, iFree);\n        }\n        if ((rc == SQLITE_DONE || rc == SQLITE_OK) && nFree > 0)\n        {\n          rc = SQLITE_OK;\n          rc = sqlite3PagerWrite(pBt.pPage1.pDbPage);\n          sqlite3Put4byte(pBt.pPage1.aData, 32, 0);\n          sqlite3Put4byte(pBt.pPage1.aData, 36, 0);\n          sqlite3PagerTruncateImage(pBt.pPager, nFin);\n        }\n        if (rc != SQLITE_OK)\n        {\n          sqlite3PagerRollback(pPager);\n        }\n      }\n\n      Debug.Assert(nRef == sqlite3PagerRefcount(pPager));\n      return rc;\n    }\n\n#else //* ifndef SQLITE_OMIT_AUTOVACUUM */\n//# define setChildPtrmaps(x) SQLITE_OK\n#endif\n\n    /*\n** This routine does the first phase of a two-phase commit.  This routine\n** causes a rollback journal to be created (if it does not already exist)\n** and populated with enough information so that if a power loss occurs\n** the database can be restored to its original state by playing back\n** the journal.  Then the contents of the journal are flushed out to\n** the disk.  After the journal is safely on oxide, the changes to the\n** database are written into the database file and flushed to oxide.\n** At the end of this call, the rollback journal still exists on the\n** disk and we are still holding all locks, so the transaction has not\n** committed.  See sqlite3BtreeCommitPhaseTwo() for the second phase of the\n** commit process.\n**\n** This call is a no-op if no write-transaction is currently active on pBt.\n**\n** Otherwise, sync the database file for the btree pBt. zMaster points to\n** the name of a master journal file that should be written into the\n** individual journal file, or is NULL, indicating no master journal file\n** (single database transaction).\n**\n** When this is called, the master journal should already have been\n** created, populated with this journal pointer and synced to disk.\n**\n** Once this is routine has returned, the only thing required to commit\n** the write-transaction for this database file is to delete the journal.\n*/\n    static int sqlite3BtreeCommitPhaseOne(Btree p, string zMaster)\n    {\n      int rc = SQLITE_OK;\n      if (p.inTrans == TRANS_WRITE)\n      {\n        BtShared pBt = p.pBt;\n        sqlite3BtreeEnter(p);\n#if !SQLITE_OMIT_AUTOVACUUM\n        if (pBt.autoVacuum)\n        {\n          rc = autoVacuumCommit(pBt);\n          if (rc != SQLITE_OK)\n          {\n            sqlite3BtreeLeave(p);\n            return rc;\n          }\n        }\n#endif\n        rc = sqlite3PagerCommitPhaseOne(pBt.pPager, zMaster, false);\n        sqlite3BtreeLeave(p);\n      }\n      return rc;\n    }\n\n    /*\n    ** This function is called from both BtreeCommitPhaseTwo() and BtreeRollback()\n    ** at the conclusion of a transaction.\n    */\n    static void btreeEndTransaction(Btree p)\n    {\n      BtShared pBt = p.pBt;\n      BtCursor pCsr;\n      Debug.Assert(sqlite3BtreeHoldsMutex(p));\n\n      /* Search for a cursor held open by this b-tree connection. If one exists,\n      ** then the transaction will be downgraded to a read-only transaction\n      ** instead of actually concluded. A subsequent call to CommitPhaseTwo()\n      ** or Rollback() will finish the transaction and unlock the database.  */\n      for (pCsr = pBt.pCursor; pCsr != null && pCsr.pBtree != p; pCsr = pCsr.pNext) ;\n      Debug.Assert(pCsr == null || p.inTrans > TRANS_NONE);\n\n      btreeClearHasContent(pBt);\n      if (pCsr != null)\n      {\n        downgradeAllSharedCacheTableLocks(p);\n        p.inTrans = TRANS_READ;\n      }\n      else\n      {\n        /* If the handle had any kind of transaction open, decrement the\n        ** transaction count of the shared btree. If the transaction count\n        ** reaches 0, set the shared state to TRANS_NONE. The unlockBtreeIfUnused()\n        ** call below will unlock the pager.  */\n        if (p.inTrans != TRANS_NONE)\n        {\n          clearAllSharedCacheTableLocks(p);\n          pBt.nTransaction--;\n          if (0 == pBt.nTransaction)\n          {\n            pBt.inTransaction = TRANS_NONE;\n          }\n        }\n\n        /* Set the current transaction state to TRANS_NONE and unlock the\n        ** pager if this call closed the only read or write transaction.  */\n        p.inTrans = TRANS_NONE;\n        unlockBtreeIfUnused(pBt);\n      }\n\n      btreeIntegrity(p);\n    }\n\n    /*\n    ** Commit the transaction currently in progress.\n    **\n    ** This routine implements the second phase of a 2-phase commit.  The\n    ** sqlite3BtreeCommitPhaseOne() routine does the first phase and should\n    ** be invoked prior to calling this routine.  The sqlite3BtreeCommitPhaseOne()\n    ** routine did all the work of writing information out to disk and flushing the\n    ** contents so that they are written onto the disk platter.  All this\n    ** routine has to do is delete or truncate or zero the header in the\n    ** the rollback journal (which causes the transaction to commit) and\n    ** drop locks.\n    **\n    ** This will release the write lock on the database file.  If there\n    ** are no active cursors, it also releases the read lock.\n    */\n    static int sqlite3BtreeCommitPhaseTwo(Btree p)\n    {\n      BtShared pBt = p.pBt;\n\n      sqlite3BtreeEnter(p);\n      btreeIntegrity(p);\n\n      /* If the handle has a write-transaction open, commit the shared-btrees\n      ** transaction and set the shared state to TRANS_READ.\n      */\n      if (p.inTrans == TRANS_WRITE)\n      {\n        int rc;\n        Debug.Assert(pBt.inTransaction == TRANS_WRITE);\n        Debug.Assert(pBt.nTransaction > 0);\n        rc = sqlite3PagerCommitPhaseTwo(pBt.pPager);\n        if (rc != SQLITE_OK)\n        {\n          sqlite3BtreeLeave(p);\n          return rc;\n        }\n        pBt.inTransaction = TRANS_READ;\n      }\n\n      btreeEndTransaction(p);\n      sqlite3BtreeLeave(p);\n      return SQLITE_OK;\n    }\n\n    /*\n    ** Do both phases of a commit.\n    */\n    static int sqlite3BtreeCommit(Btree p)\n    {\n      int rc;\n      sqlite3BtreeEnter(p);\n      rc = sqlite3BtreeCommitPhaseOne(p, null);\n      if (rc == SQLITE_OK)\n      {\n        rc = sqlite3BtreeCommitPhaseTwo(p);\n      }\n      sqlite3BtreeLeave(p);\n      return rc;\n    }\n\n#if !NDEBUG || DEBUG\n    /*\n** Return the number of write-cursors open on this handle. This is for use\n** in Debug.Assert() expressions, so it is only compiled if NDEBUG is not\n** defined.\n**\n** For the purposes of this routine, a write-cursor is any cursor that\n** is capable of writing to the databse.  That means the cursor was\n** originally opened for writing and the cursor has not be disabled\n** by having its state changed to CURSOR_FAULT.\n*/\n    static int countWriteCursors(BtShared pBt)\n    {\n      BtCursor pCur;\n      int r = 0;\n      for (pCur = pBt.pCursor; pCur != null; pCur = pCur.pNext)\n      {\n        if (pCur.wrFlag != 0 && pCur.eState != CURSOR_FAULT) r++;\n      }\n      return r;\n    }\n#else\nstatic int countWriteCursors(BtShared pBt) { return -1; }\n#endif\n\n    /*\n** This routine sets the state to CURSOR_FAULT and the error\n** code to errCode for every cursor on BtShared that pBtree\n** references.\n**\n** Every cursor is tripped, including cursors that belong\n** to other database connections that happen to be sharing\n** the cache with pBtree.\n**\n** This routine gets called when a rollback occurs.\n** All cursors using the same cache must be tripped\n** to prevent them from trying to use the btree after\n** the rollback.  The rollback may have deleted tables\n** or moved root pages, so it is not sufficient to\n** save the state of the cursor.  The cursor must be\n** invalidated.\n*/\n    static void sqlite3BtreeTripAllCursors(Btree pBtree, int errCode)\n    {\n      BtCursor p;\n      sqlite3BtreeEnter(pBtree);\n      for (p = pBtree.pBt.pCursor; p != null; p = p.pNext)\n      {\n        int i;\n        sqlite3BtreeClearCursor(p);\n        p.eState = CURSOR_FAULT;\n        p.skipNext = errCode;\n        for (i = 0; i <= p.iPage; i++)\n        {\n          releasePage(p.apPage[i]);\n          p.apPage[i] = null;\n        }\n      }\n      sqlite3BtreeLeave(pBtree);\n    }\n\n    /*\n    ** Rollback the transaction in progress.  All cursors will be\n    ** invalided by this operation.  Any attempt to use a cursor\n    ** that was open at the beginning of this operation will result\n    ** in an error.\n    **\n    ** This will release the write lock on the database file.  If there\n    ** are no active cursors, it also releases the read lock.\n    */\n    static int sqlite3BtreeRollback(Btree p)\n    {\n      int rc;\n      BtShared pBt = p.pBt;\n      MemPage pPage1 = new MemPage();\n\n      sqlite3BtreeEnter(p);\n      rc = saveAllCursors(pBt, 0, null);\n#if !SQLITE_OMIT_SHARED_CACHE\nif( rc!=SQLITE_OK ){\n/* This is a horrible situation. An IO or malloc() error occurred whilst\n** trying to save cursor positions. If this is an automatic rollback (as\n** the result of a constraint, malloc() failure or IO error) then\n** the cache may be internally inconsistent (not contain valid trees) so\n** we cannot simply return the error to the caller. Instead, abort\n** all queries that may be using any of the cursors that failed to save.\n*/\nsqlite3BtreeTripAllCursors(p, rc);\n}\n#endif\n      btreeIntegrity(p);\n\n      if (p.inTrans == TRANS_WRITE)\n      {\n        int rc2;\n\n        Debug.Assert(TRANS_WRITE == pBt.inTransaction);\n        rc2 = sqlite3PagerRollback(pBt.pPager);\n        if (rc2 != SQLITE_OK)\n        {\n          rc = rc2;\n        }\n\n        /* The rollback may have destroyed the pPage1.aData value.  So\n        ** call btreeGetPage() on page 1 again to make\n        ** sure pPage1.aData is set correctly. */\n        if (btreeGetPage(pBt, 1, ref pPage1, 0) == SQLITE_OK)\n        {\n          releasePage(pPage1);\n        }\n        Debug.Assert(countWriteCursors(pBt) == 0);\n        pBt.inTransaction = TRANS_READ;\n      }\n\n      btreeEndTransaction(p);\n      sqlite3BtreeLeave(p);\n      return rc;\n    }\n\n    /*\n    ** Start a statement subtransaction. The subtransaction can can be rolled\n    ** back independently of the main transaction. You must start a transaction\n    ** before starting a subtransaction. The subtransaction is ended automatically\n    ** if the main transaction commits or rolls back.\n    **\n    ** Statement subtransactions are used around individual SQL statements\n    ** that are contained within a BEGIN...COMMIT block.  If a constraint\n    ** error occurs within the statement, the effect of that one statement\n    ** can be rolled back without having to rollback the entire transaction.\n    **\n    ** A statement sub-transaction is implemented as an anonymous savepoint. The\n    ** value passed as the second parameter is the total number of savepoints,\n    ** including the new anonymous savepoint, open on the B-Tree. i.e. if there\n    ** are no active savepoints and no other statement-transactions open,\n    ** iStatement is 1. This anonymous savepoint can be released or rolled back\n    ** using the sqlite3BtreeSavepoint() function.\n    */\n    static int sqlite3BtreeBeginStmt(Btree p, int iStatement)\n    {\n      int rc;\n      BtShared pBt = p.pBt;\n      sqlite3BtreeEnter(p);\n      Debug.Assert(p.inTrans == TRANS_WRITE);\n      Debug.Assert(!pBt.readOnly);\n      Debug.Assert(iStatement > 0);\n      Debug.Assert(iStatement > p.db.nSavepoint);\n      if (NEVER(p.inTrans != TRANS_WRITE || pBt.readOnly))\n      {\n        rc = SQLITE_INTERNAL;\n      }\n      else\n      {\n        Debug.Assert(pBt.inTransaction == TRANS_WRITE);\n        /* At the pager level, a statement transaction is a savepoint with\n        ** an index greater than all savepoints created explicitly using\n        ** SQL statements. It is illegal to open, release or rollback any\n        ** such savepoints while the statement transaction savepoint is active.\n        */\n        rc = sqlite3PagerOpenSavepoint(pBt.pPager, iStatement);\n      }\n      sqlite3BtreeLeave(p);\n      return rc;\n    }\n\n    /*\n    ** The second argument to this function, op, is always SAVEPOINT_ROLLBACK\n    ** or SAVEPOINT_RELEASE. This function either releases or rolls back the\n    ** savepoint identified by parameter iSavepoint, depending on the value\n    ** of op.\n    **\n    ** Normally, iSavepoint is greater than or equal to zero. However, if op is\n    ** SAVEPOINT_ROLLBACK, then iSavepoint may also be -1. In this case the\n    ** contents of the entire transaction are rolled back. This is different\n    ** from a normal transaction rollback, as no locks are released and the\n    ** transaction remains open.\n    */\n    static int sqlite3BtreeSavepoint(Btree p, int op, int iSavepoint)\n    {\n      int rc = SQLITE_OK;\n      if (p != null && p.inTrans == TRANS_WRITE)\n      {\n        BtShared pBt = p.pBt;\n        Debug.Assert(op == SAVEPOINT_RELEASE || op == SAVEPOINT_ROLLBACK);\n        Debug.Assert(iSavepoint >= 0 || (iSavepoint == -1 && op == SAVEPOINT_ROLLBACK));\n        sqlite3BtreeEnter(p);\n        rc = sqlite3PagerSavepoint(pBt.pPager, op, iSavepoint);\n        if (rc == SQLITE_OK)\n        {\n          rc = newDatabase(pBt);\n        }\n        sqlite3BtreeLeave(p);\n      }\n      return rc;\n    }\n\n    /*\n    ** Create a new cursor for the BTree whose root is on the page\n    ** iTable. If a read-only cursor is requested, it is assumed that\n    ** the caller already has at least a read-only transaction open\n    ** on the database already. If a write-cursor is requested, then\n    ** the caller is assumed to have an open write transaction.\n    **\n    ** If wrFlag==null, then the cursor can only be used for reading.\n    ** If wrFlag==1, then the cursor can be used for reading or for\n    ** writing if other conditions for writing are also met.  These\n    ** are the conditions that must be met in order for writing to\n    ** be allowed:\n    **\n    ** 1:  The cursor must have been opened with wrFlag==1\n    **\n    ** 2:  Other database connections that share the same pager cache\n    **     but which are not in the READ_UNCOMMITTED state may not have\n    **     cursors open with wrFlag==null on the same table.  Otherwise\n    **     the changes made by this write cursor would be visible to\n    **     the read cursors in the other database connection.\n    **\n    ** 3:  The database must be writable (not on read-only media)\n    **\n    ** 4:  There must be an active transaction.\n    **\n    ** No checking is done to make sure that page iTable really is the\n    ** root page of a b-tree.  If it is not, then the cursor acquired\n    ** will not work correctly.\n    **\n    ** It is assumed that the sqlite3BtreeCursorSize() bytes of memory\n    ** pointed to by pCur have been zeroed by the caller.\n    */\n    static int btreeCursor(\n    Btree p,                              /* The btree */\n    int iTable,                           /* Root page of table to open */\n    int wrFlag,                           /* 1 to write. 0 read-only */\n    KeyInfo pKeyInfo,                     /* First arg to comparison function */\n    BtCursor pCur                         /* Space for new cursor */\n    )\n    {\n      BtShared pBt = p.pBt;                 /* Shared b-tree handle */\n\n      Debug.Assert(sqlite3BtreeHoldsMutex(p));\n      Debug.Assert(wrFlag == 0 || wrFlag == 1);\n\n      /* The following Debug.Assert statements verify that if this is a sharable\n      ** b-tree database, the connection is holding the required table locks,\n      ** and that no other connection has any open cursor that conflicts with\n      ** this lock.  */\n      Debug.Assert(hasSharedCacheTableLock(p, (u32)iTable, pKeyInfo != null ? 1 : 0, wrFlag + 1));\n      Debug.Assert(wrFlag == 0 || !hasReadConflicts(p, (u32)iTable));\n\n      /* Assert that the caller has opened the required transaction. */\n      Debug.Assert(p.inTrans > TRANS_NONE);\n      Debug.Assert(wrFlag == 0 || p.inTrans == TRANS_WRITE);\n      Debug.Assert(pBt.pPage1 != null && pBt.pPage1.aData != null);\n\n      if (NEVER(wrFlag != 0 && pBt.readOnly))\n      {\n        return SQLITE_READONLY;\n      }\n      if (iTable == 1 && pagerPagecount(pBt) == 0)\n      {\n        return SQLITE_EMPTY;\n      }\n\n      /* Now that no other errors can occur, finish filling in the BtCursor\n      ** variables and link the cursor into the BtShared list.  */\n      pCur.pgnoRoot = (Pgno)iTable;\n      pCur.iPage = -1;\n      pCur.pKeyInfo = pKeyInfo;\n      pCur.pBtree = p;\n      pCur.pBt = pBt;\n      pCur.wrFlag = (u8)wrFlag;\n      pCur.pNext = pBt.pCursor;\n      if (pCur.pNext != null)\n      {\n        pCur.pNext.pPrev = pCur;\n      }\n      pBt.pCursor = pCur;\n      pCur.eState = CURSOR_INVALID;\n      pCur.cachedRowid = 0;\n      return SQLITE_OK;\n    }\n    static int sqlite3BtreeCursor(\n    Btree p,                                   /* The btree */\n    int iTable,                                /* Root page of table to open */\n    int wrFlag,                                /* 1 to write. 0 read-only */\n    KeyInfo pKeyInfo,                          /* First arg to xCompare() */\n    BtCursor pCur                              /* Write new cursor here */\n    )\n    {\n      int rc;\n      sqlite3BtreeEnter(p);\n      rc = btreeCursor(p, iTable, wrFlag, pKeyInfo, pCur);\n      sqlite3BtreeLeave(p);\n      return rc;\n    }\n\n    /*\n    ** Return the size of a BtCursor object in bytes.\n    **\n    ** This interfaces is needed so that users of cursors can preallocate\n    ** sufficient storage to hold a cursor.  The BtCursor object is opaque\n    ** to users so they cannot do the sizeof() themselves - they must call\n    ** this routine.\n    */\n    static int sqlite3BtreeCursorSize()\n    {\n      return -1; // Not Used --  sizeof( BtCursor );\n    }\n    /*\n    ** Set the cached rowid value of every cursor in the same database file\n    ** as pCur and having the same root page number as pCur.  The value is\n    ** set to iRowid.\n    **\n    ** Only positive rowid values are considered valid for this cache.\n    ** The cache is initialized to zero, indicating an invalid cache.\n    ** A btree will work fine with zero or negative rowids.  We just cannot\n    ** cache zero or negative rowids, which means tables that use zero or\n    ** negative rowids might run a little slower.  But in practice, zero\n    ** or negative rowids are very uncommon so this should not be a problem.\n    */\n    static void sqlite3BtreeSetCachedRowid(BtCursor pCur, sqlite3_int64 iRowid)\n    {\n      BtCursor p;\n      for (p = pCur.pBt.pCursor; p != null; p = p.pNext)\n      {\n        if (p.pgnoRoot == pCur.pgnoRoot) p.cachedRowid = iRowid;\n      }\n      Debug.Assert(pCur.cachedRowid == iRowid);\n    }\n\n    /*\n    ** Return the cached rowid for the given cursor.  A negative or zero\n    ** return value indicates that the rowid cache is invalid and should be\n    ** ignored.  If the rowid cache has never before been set, then a\n    ** zero is returned.\n    */\n    static sqlite3_int64 sqlite3BtreeGetCachedRowid(BtCursor pCur)\n    {\n      return pCur.cachedRowid;\n    }\n\n    /*\n    ** Close a cursor.  The read lock on the database file is released\n    ** when the last cursor is closed.\n    */\n    static int sqlite3BtreeCloseCursor(BtCursor pCur)\n    {\n      Btree pBtree = pCur.pBtree;\n      if (pBtree != null)\n      {\n        int i;\n        BtShared pBt = pCur.pBt;\n        sqlite3BtreeEnter(pBtree);\n        sqlite3BtreeClearCursor(pCur);\n        if (pCur.pPrev != null)\n        {\n          pCur.pPrev.pNext = pCur.pNext;\n        }\n        else\n        {\n          pBt.pCursor = pCur.pNext;\n        }\n        if (pCur.pNext != null)\n        {\n          pCur.pNext.pPrev = pCur.pPrev;\n        }\n        for (i = 0; i <= pCur.iPage; i++)\n        {\n          releasePage(pCur.apPage[i]);\n        }\n        unlockBtreeIfUnused(pBt);\n        invalidateOverflowCache(pCur);\n        /* sqlite3_free(ref pCur); */\n        sqlite3BtreeLeave(pBtree);\n      }\n      return SQLITE_OK;\n    }\n\n    /*\n    ** Make sure the BtCursor* given in the argument has a valid\n    ** BtCursor.info structure.  If it is not already valid, call\n    ** btreeParseCell() to fill it in.\n    **\n    ** BtCursor.info is a cache of the information in the current cell.\n    ** Using this cache reduces the number of calls to btreeParseCell().\n    **\n    ** 2007-06-25:  There is a bug in some versions of MSVC that cause the\n    ** compiler to crash when getCellInfo() is implemented as a macro.\n    ** But there is a measureable speed advantage to using the macro on gcc\n    ** (when less compiler optimizations like -Os or -O0 are used and the\n    ** compiler is not doing agressive inlining.)  So we use a real function\n    ** for MSVC and a macro for everything else.  Ticket #2457.\n    */\n#if !NDEBUG\n    static void assertCellInfo(BtCursor pCur)\n    {\n      CellInfo info;\n      int iPage = pCur.iPage;\n      info = new CellInfo();//memset(info, 0, sizeof(info));\n      btreeParseCell(pCur.apPage[iPage], pCur.aiIdx[iPage], ref info);\n      Debug.Assert(info.Equals(pCur.info));//memcmp(info, pCur.info, sizeof(info))==0 );\n    }\n#else\n//  #define assertCellInfo(x)\nstatic void assertCellInfo(BtCursor pCur) { }\n#endif\n#if _MSC_VER\n    /* Use a real function in MSVC to work around bugs in that compiler. */\n    static void getCellInfo(BtCursor pCur)\n    {\n      if (pCur.info.nSize == 0)\n      {\n        int iPage = pCur.iPage;\n        btreeParseCell( pCur.apPage[iPage], pCur.aiIdx[iPage], ref pCur.info );\n        pCur.validNKey = true;\n      }\n      else\n      {\n        assertCellInfo(pCur);\n      }\n    }\n#else //* if not _MSC_VER */\n/* Use a macro in all other compilers so that the function is inlined */\n//#define getCellInfo(pCur)                                                      \\\n//  if( pCur.info.nSize==null ){                                                   \\\n//    int iPage = pCur.iPage;                                                   \\\n//    btreeParseCell(pCur.apPage[iPage],pCur.aiIdx[iPage],&pCur.info); \\\n//    pCur.validNKey = true;                                                       \\\n//  }else{                                                                       \\\n//    assertCellInfo(pCur);                                                      \\\n//  }\n#endif //* _MSC_VER */\n\n#if !NDEBUG  //* The next routine used only within Debug.Assert() statements */\n    /*\n** Return true if the given BtCursor is valid.  A valid cursor is one\n** that is currently pointing to a row in a (non-empty) table.\n** This is a verification routine is used only within Debug.Assert() statements.\n*/\n    static bool sqlite3BtreeCursorIsValid(BtCursor pCur)\n    {\n      return pCur != null && pCur.eState == CURSOR_VALID;\n    }\n#else\nstatic bool sqlite3BtreeCursorIsValid(BtCursor pCur) { return true; }\n#endif //* NDEBUG */\n\n    /*\n** Set pSize to the size of the buffer needed to hold the value of\n** the key for the current entry.  If the cursor is not pointing\n** to a valid entry, pSize is set to 0.\n**\n** For a table with the INTKEY flag set, this routine returns the key\n** itself, not the number of bytes in the key.\n**\n** The caller must position the cursor prior to invoking this routine.\n**\n** This routine cannot fail.  It always returns SQLITE_OK.\n*/\n    static int sqlite3BtreeKeySize(BtCursor pCur, ref i64 pSize)\n    {\n      Debug.Assert(cursorHoldsMutex(pCur));\n      Debug.Assert(pCur.eState == CURSOR_INVALID || pCur.eState == CURSOR_VALID);\n      if (pCur.eState != CURSOR_VALID)\n      {\n        pSize = 0;\n      }\n      else\n      {\n        getCellInfo(pCur);\n        pSize = pCur.info.nKey;\n      }\n      return SQLITE_OK;\n    }\n\n    /*\n    ** Set pSize to the number of bytes of data in the entry the\n    ** cursor currently points to.\n    **\n    ** The caller must guarantee that the cursor is pointing to a non-NULL\n    ** valid entry.  In other words, the calling procedure must guarantee\n    ** that the cursor has Cursor.eState==CURSOR_VALID.\n    **\n    ** Failure is not possible.  This function always returns SQLITE_OK.\n    ** It might just as well be a procedure (returning void) but we continue\n    ** to return an integer result code for historical reasons.\n    */\n    static int sqlite3BtreeDataSize(BtCursor pCur, ref u32 pSize)\n    {\n      Debug.Assert(cursorHoldsMutex(pCur));\n      Debug.Assert(pCur.eState == CURSOR_VALID);\n      getCellInfo(pCur);\n      pSize = pCur.info.nData;\n      return SQLITE_OK;\n    }\n\n    /*\n    ** Given the page number of an overflow page in the database (parameter\n    ** ovfl), this function finds the page number of the next page in the\n    ** linked list of overflow pages. If possible, it uses the auto-vacuum\n    ** pointer-map data instead of reading the content of page ovfl to do so.\n    **\n    ** If an error occurs an SQLite error code is returned. Otherwise:\n    **\n    ** The page number of the next overflow page in the linked list is\n    ** written to pPgnoNext. If page ovfl is the last page in its linked\n    ** list, pPgnoNext is set to zero.\n    **\n    ** If ppPage is not NULL, and a reference to the MemPage object corresponding\n    ** to page number pOvfl was obtained, then ppPage is set to point to that\n    ** reference. It is the responsibility of the caller to call releasePage()\n    ** on ppPage to free the reference. In no reference was obtained (because\n    ** the pointer-map was used to obtain the value for pPgnoNext), then\n    ** ppPage is set to zero.\n    */\n    static int getOverflowPage(\n    BtShared pBt,               /* The database file */\n    Pgno ovfl,                  /* Current overflow page number */\n    ref MemPage ppPage,         /* OUT: MemPage handle (may be NULL) */\n    ref Pgno pPgnoNext          /* OUT: Next overflow page number */\n    )\n    {\n      Pgno next = 0;\n      MemPage pPage = null;\n      int rc = SQLITE_OK;\n\n      Debug.Assert(sqlite3_mutex_held(pBt.mutex));\n      // Debug.Assert( pPgnoNext);\n\n#if !SQLITE_OMIT_AUTOVACUUM\n      /* Try to find the next page in the overflow list using the\n** autovacuum pointer-map pages. Guess that the next page in\n** the overflow list is page number (ovfl+1). If that guess turns\n** out to be wrong, fall back to loading the data of page\n** number ovfl to determine the next page number.\n*/\n      if (pBt.autoVacuum)\n      {\n        Pgno pgno = 0;\n        Pgno iGuess = ovfl + 1;\n        u8 eType = 0;\n\n        while (PTRMAP_ISPAGE(pBt, iGuess) || iGuess == PENDING_BYTE_PAGE(pBt))\n        {\n          iGuess++;\n        }\n\n        if (iGuess <= pagerPagecount(pBt))\n        {\n          rc = ptrmapGet(pBt, iGuess, ref eType, ref pgno);\n          if (rc == SQLITE_OK && eType == PTRMAP_OVERFLOW2 && pgno == ovfl)\n          {\n            next = iGuess;\n            rc = SQLITE_DONE;\n          }\n        }\n      }\n#endif\n\n      Debug.Assert(next == 0 || rc == SQLITE_DONE);\n      if (rc == SQLITE_OK)\n      {\n        rc = btreeGetPage(pBt, ovfl, ref pPage, 0);\n        Debug.Assert(rc == SQLITE_OK || pPage == null);\n        if (rc == SQLITE_OK)\n        {\n          next = sqlite3Get4byte(pPage.aData);\n        }\n      }\n\n      pPgnoNext = next;\n      if (ppPage != null)\n      {\n        ppPage = pPage;\n      }\n      else\n      {\n        releasePage(pPage);\n      }\n      return (rc == SQLITE_DONE ? SQLITE_OK : rc);\n    }\n\n    /*\n    ** Copy data from a buffer to a page, or from a page to a buffer.\n    **\n    ** pPayload is a pointer to data stored on database page pDbPage.\n    ** If argument eOp is false, then nByte bytes of data are copied\n    ** from pPayload to the buffer pointed at by pBuf. If eOp is true,\n    ** then sqlite3PagerWrite() is called on pDbPage and nByte bytes\n    ** of data are copied from the buffer pBuf to pPayload.\n    **\n    ** SQLITE_OK is returned on success, otherwise an error code.\n    */\n    static int copyPayload(\n    byte[] pPayload,           /* Pointer to page data */\n    u32 payloadOffset,         /* Offset into page data */\n    byte[] pBuf,               /* Pointer to buffer */\n    u32 pBufOffset,            /* Offset into buffer */\n    u32 nByte,                 /* Number of bytes to copy */\n    int eOp,                   /* 0 . copy from page, 1 . copy to page */\n    DbPage pDbPage             /* Page containing pPayload */\n    )\n    {\n      if (eOp != 0)\n      {\n        /* Copy data from buffer to page (a write operation) */\n        int rc = sqlite3PagerWrite(pDbPage);\n        if (rc != SQLITE_OK)\n        {\n          return rc;\n        }\n        Buffer.BlockCopy(pBuf, (int)pBufOffset, pPayload, (int)payloadOffset, (int)nByte);// memcpy( pPayload, pBuf, nByte );\n      }\n      else\n      {\n        /* Copy data from page to buffer (a read operation) */\n        Buffer.BlockCopy(pPayload, (int)payloadOffset, pBuf, (int)pBufOffset, (int)nByte);//memcpy(pBuf, pPayload, nByte);\n      }\n      return SQLITE_OK;\n    }\n    //static int copyPayload(\n    //  byte[] pPayload,           /* Pointer to page data */\n    //  byte[] pBuf,               /* Pointer to buffer */\n    //  int nByte,                 /* Number of bytes to copy */\n    //  int eOp,                   /* 0 -> copy from page, 1 -> copy to page */\n    //  DbPage pDbPage             /* Page containing pPayload */\n    //){\n    //  if( eOp!=0 ){\n    //    /* Copy data from buffer to page (a write operation) */\n    //    int rc = sqlite3PagerWrite(pDbPage);\n    //    if( rc!=SQLITE_OK ){\n    //      return rc;\n    //    }\n    //    memcpy(pPayload, pBuf, nByte);\n    //  }else{\n    //    /* Copy data from page to buffer (a read operation) */\n    //    memcpy(pBuf, pPayload, nByte);\n    //  }\n    //  return SQLITE_OK;\n    //}\n\n    /*\n    ** This function is used to read or overwrite payload information\n    ** for the entry that the pCur cursor is pointing to. If the eOp\n    ** parameter is 0, this is a read operation (data copied into\n    ** buffer pBuf). If it is non-zero, a write (data copied from\n    ** buffer pBuf).\n    **\n    ** A total of "amt" bytes are read or written beginning at "offset".\n    ** Data is read to or from the buffer pBuf.\n    **\n    ** The content being read or written might appear on the main page\n    ** or be scattered out on multiple overflow pages.\n    **\n    ** If the BtCursor.isIncrblobHandle flag is set, and the current\n    ** cursor entry uses one or more overflow pages, this function\n    ** allocates space for and lazily popluates the overflow page-list\n    ** cache array (BtCursor.aOverflow). Subsequent calls use this\n    ** cache to make seeking to the supplied offset more efficient.\n    **\n    ** Once an overflow page-list cache has been allocated, it may be\n    ** invalidated if some other cursor writes to the same table, or if\n    ** the cursor is moved to a different row. Additionally, in auto-vacuum\n    ** mode, the following events may invalidate an overflow page-list cache.\n    **\n    **   * An incremental vacuum,\n    **   * A commit in auto_vacuum="full" mode,\n    **   * Creating a table (may require moving an overflow page).\n    */\n    static int accessPayload(\n    BtCursor pCur,      /* Cursor pointing to entry to read from */\n    u32 offset,         /* Begin reading this far into payload */\n    u32 amt,            /* Read this many bytes */\n    byte[] pBuf,        /* Write the bytes into this buffer */\n    int eOp             /* zero to read. non-zero to write. */\n    )\n    {\n      u32 pBufOffset = 0;\n      byte[] aPayload;\n      int rc = SQLITE_OK;\n      u32 nKey;\n      int iIdx = 0;\n      MemPage pPage = pCur.apPage[pCur.iPage]; /* Btree page of current entry */\n      BtShared pBt = pCur.pBt;                  /* Btree this cursor belongs to */\n\n      Debug.Assert(pPage != null);\n      Debug.Assert(pCur.eState == CURSOR_VALID);\n      Debug.Assert(pCur.aiIdx[pCur.iPage] < pPage.nCell);\n      Debug.Assert(cursorHoldsMutex(pCur));\n\n      getCellInfo(pCur);\n      aPayload = pCur.info.pCell; //pCur.info.pCell + pCur.info.nHeader;\n      nKey = (u32)(pPage.intKey != 0 ? 0 : (int)pCur.info.nKey);\n\n      if (NEVER(offset + amt > nKey + pCur.info.nData)\n      || pCur.info.nLocal > pBt.usableSize//&aPayload[pCur.info.nLocal] > &pPage.aData[pBt.usableSize]\n      )\n      {\n        /* Trying to read or write past the end of the data is an error */\n#if SQLITE_DEBUG || DEBUG\n        return SQLITE_CORRUPT_BKPT();\n#else\nreturn SQLITE_CORRUPT_BKPT;\n#endif\n      }\n\n      /* Check if data must be read/written to/from the btree page itself. */\n      if (offset < pCur.info.nLocal)\n      {\n        int a = (int)amt;\n        if (a + offset > pCur.info.nLocal)\n        {\n          a = (int)(pCur.info.nLocal - offset);\n        }\n        rc = copyPayload(aPayload, (u32)(offset + pCur.info.iCell + pCur.info.nHeader), pBuf, pBufOffset, (u32)a, eOp, pPage.pDbPage);\n        offset = 0;\n        pBufOffset += (u32)a; //pBuf += a;\n        amt -= (u32)a;\n      }\n      else\n      {\n        offset -= pCur.info.nLocal;\n      }\n\n      if (rc == SQLITE_OK && amt > 0)\n      {\n        u32 ovflSize = (u32)(pBt.usableSize - 4);  /* Bytes content per ovfl page */\n        Pgno nextPage;\n\n        nextPage = sqlite3Get4byte(aPayload, pCur.info.nLocal + pCur.info.iCell + pCur.info.nHeader);\n\n#if !SQLITE_OMIT_INCRBLOB\n/* If the isIncrblobHandle flag is set and the BtCursor.aOverflow[]\n** has not been allocated, allocate it now. The array is sized at\n** one entry for each overflow page in the overflow chain. The\n** page number of the first overflow page is stored in aOverflow[0],\n** etc. A value of 0 in the aOverflow[] array means "not yet known"\n** (the cache is lazily populated).\n*/\nif( pCur.isIncrblobHandle && !pCur.aOverflow ){\nint nOvfl = (pCur.info.nPayload-pCur.info.nLocal+ovflSize-1)/ovflSize;\npCur.aOverflow = (Pgno *)sqlite3MallocZero(sizeof(Pgno)*nOvfl);\n/* nOvfl is always positive.  If it were zero, fetchPayload would have\n** been used instead of this routine. */\nif( ALWAYS(nOvfl) && !pCur.aOverflow ){\nrc = SQLITE_NOMEM;\n}\n}\n\n/* If the overflow page-list cache has been allocated and the\n** entry for the first required overflow page is valid, skip\n** directly to it.\n*/\nif( pCur.aOverflow && pCur.aOverflow[offset/ovflSize] ){\niIdx = (offset/ovflSize);\nnextPage = pCur.aOverflow[iIdx];\noffset = (offset%ovflSize);\n}\n#endif\n\n        for (; rc == SQLITE_OK && amt > 0 && nextPage != 0; iIdx++)\n        {\n\n#if !SQLITE_OMIT_INCRBLOB\n/* If required, populate the overflow page-list cache. */\nif( pCur.aOverflow ){\nDebug.Assert(!pCur.aOverflow[iIdx] || pCur.aOverflow[iIdx]==nextPage);\npCur.aOverflow[iIdx] = nextPage;\n}\n#endif\n\n          MemPage MemPageDummy = null;\n          if (offset >= ovflSize)\n          {\n            /* The only reason to read this page is to obtain the page\n            ** number for the next page in the overflow chain. The page\n            ** data is not required. So first try to lookup the overflow\n            ** page-list cache, if any, then fall back to the getOverflowPage()\n            ** function.\n            */\n#if !SQLITE_OMIT_INCRBLOB\nif( pCur.aOverflow && pCur.aOverflow[iIdx+1] ){\nnextPage = pCur.aOverflow[iIdx+1];\n} else\n#endif\n            rc = getOverflowPage(pBt, nextPage, ref  MemPageDummy, ref nextPage);\n            offset -= ovflSize;\n          }\n          else\n          {\n            /* Need to read this page properly. It contains some of the\n            ** range of data that is being read (eOp==null) or written (eOp!=null).\n            */\n            DbPage pDbPage = new PgHdr();\n            int a = (int)amt;\n            rc = sqlite3PagerGet(pBt.pPager, nextPage, ref pDbPage);\n            if (rc == SQLITE_OK)\n            {\n              aPayload = sqlite3PagerGetData(pDbPage);\n              nextPage = sqlite3Get4byte(aPayload);\n              if (a + offset > ovflSize)\n              {\n                a = (int)(ovflSize - offset);\n              }\n              rc = copyPayload(aPayload, offset + 4, pBuf, pBufOffset, (u32)a, eOp, pDbPage);\n              sqlite3PagerUnref(pDbPage);\n              offset = 0;\n              amt -= (u32)a;\n              pBufOffset += (u32)a;//pBuf += a;\n            }\n          }\n        }\n      }\n\n      if (rc == SQLITE_OK && amt > 0)\n      {\n#if SQLITE_DEBUG || DEBUG\n        return SQLITE_CORRUPT_BKPT();\n#else\nreturn SQLITE_CORRUPT_BKPT;\n#endif\n      }\n      return rc;\n    }\n\n    /*\n    ** Read part of the key associated with cursor pCur.  Exactly\n    ** "amt" bytes will be transfered into pBuf[].  The transfer\n    ** begins at "offset".\n    **\n    ** The caller must ensure that pCur is pointing to a valid row\n    ** in the table.\n    **\n    ** Return SQLITE_OK on success or an error code if anything goes\n    ** wrong.  An error is returned if "offset+amt" is larger than\n    ** the available payload.\n    */\n    static int sqlite3BtreeKey(BtCursor pCur, u32 offset, u32 amt, byte[] pBuf)\n    {\n      Debug.Assert(cursorHoldsMutex(pCur));\n      Debug.Assert(pCur.eState == CURSOR_VALID);\n      Debug.Assert(pCur.iPage >= 0 && pCur.apPage[pCur.iPage] != null);\n      Debug.Assert(pCur.aiIdx[pCur.iPage] < pCur.apPage[pCur.iPage].nCell);\n      return accessPayload(pCur, offset, amt, pBuf, 0);\n    }\n\n    /*\n    ** Read part of the data associated with cursor pCur.  Exactly\n    ** "amt" bytes will be transfered into pBuf[].  The transfer\n    ** begins at "offset".\n    **\n    ** Return SQLITE_OK on success or an error code if anything goes\n    ** wrong.  An error is returned if "offset+amt" is larger than\n    ** the available payload.\n    */\n    static int sqlite3BtreeData(BtCursor pCur, u32 offset, u32 amt, byte[] pBuf)\n    {\n      int rc;\n\n#if !SQLITE_OMIT_INCRBLOB\nif ( pCur.eState==CURSOR_INVALID ){\nreturn SQLITE_ABORT;\n}\n#endif\n\n      Debug.Assert(cursorHoldsMutex(pCur));\n      rc = restoreCursorPosition(pCur);\n      if (rc == SQLITE_OK)\n      {\n        Debug.Assert(pCur.eState == CURSOR_VALID);\n        Debug.Assert(pCur.iPage >= 0 && pCur.apPage[pCur.iPage] != null);\n        Debug.Assert(pCur.aiIdx[pCur.iPage] < pCur.apPage[pCur.iPage].nCell);\n        rc = accessPayload(pCur, offset, amt, pBuf, 0);\n      }\n      return rc;\n    }\n\n    /*\n    ** Return a pointer to payload information from the entry that the\n    ** pCur cursor is pointing to.  The pointer is to the beginning of\n    ** the key if skipKey==null and it points to the beginning of data if\n    ** skipKey==1.  The number of bytes of available key/data is written\n    ** into pAmt.  If pAmt==null, then the value returned will not be\n    ** a valid pointer.\n    **\n    ** This routine is an optimization.  It is common for the entire key\n    ** and data to fit on the local page and for there to be no overflow\n    ** pages.  When that is so, this routine can be used to access the\n    ** key and data without making a copy.  If the key and/or data spills\n    ** onto overflow pages, then accessPayload() must be used to reassemble\n    ** the key/data and copy it into a preallocated buffer.\n    **\n    ** The pointer returned by this routine looks directly into the cached\n    ** page of the database.  The data might change or move the next time\n    ** any btree routine is called.\n    */\n    static byte[] fetchPayload(\n    BtCursor pCur,   /* Cursor pointing to entry to read from */\n    ref int pAmt,    /* Write the number of available bytes here */\n    ref int outOffset, /* Offset into Buffer */\n    bool skipKey    /* read beginning at data if this is true */\n    )\n    {\n      byte[] aPayload;\n      MemPage pPage;\n      u32 nKey;\n      u32 nLocal;\n\n      Debug.Assert(pCur != null && pCur.iPage >= 0 && pCur.apPage[pCur.iPage] != null);\n      Debug.Assert(pCur.eState == CURSOR_VALID);\n      Debug.Assert(cursorHoldsMutex(pCur));\n      outOffset = -1;\n      pPage = pCur.apPage[pCur.iPage];\n      Debug.Assert(pCur.aiIdx[pCur.iPage] < pPage.nCell);\n      if (NEVER(pCur.info.nSize == 0))\n      {\n        btreeParseCell(pCur.apPage[pCur.iPage], pCur.aiIdx[pCur.iPage],\n        ref pCur.info );\n      }\n      //aPayload = pCur.info.pCell;\n      //aPayload += pCur.info.nHeader;\n      aPayload = new byte[pCur.info.nSize - pCur.info.nHeader];\n      if (pPage.intKey != 0)\n      {\n        nKey = 0;\n      }\n      else\n      {\n        nKey = (u32)pCur.info.nKey;\n      }\n      if ( skipKey )\n      {\n        //aPayload += nKey;\n        outOffset = (int)( pCur.info.iCell + pCur.info.nHeader + nKey );\n        Buffer.BlockCopy( pCur.info.pCell, outOffset, aPayload, 0, (int)( pCur.info.nSize - pCur.info.nHeader - nKey ) );\n        nLocal = pCur.info.nLocal - nKey;\n      }\n      else\n      {\n        outOffset = (int)( pCur.info.iCell + pCur.info.nHeader );\n        Buffer.BlockCopy( pCur.info.pCell, outOffset, aPayload, 0, pCur.info.nSize - pCur.info.nHeader );\n        nLocal = pCur.info.nLocal;\n        Debug.Assert( nLocal <= nKey );\n      }\n      pAmt = (int)nLocal;\n      return aPayload;\n    }\n\n    /*\n    ** For the entry that cursor pCur is point to, return as\n    ** many bytes of the key or data as are available on the local\n    ** b-tree page.  Write the number of available bytes into pAmt.\n    **\n    ** The pointer returned is ephemeral.  The key/data may move\n    ** or be destroyed on the next call to any Btree routine,\n    ** including calls from other threads against the same cache.\n    ** Hence, a mutex on the BtShared should be held prior to calling\n    ** this routine.\n    **\n    ** These routines is used to get quick access to key and data\n    ** in the common case where no overflow pages are used.\n    */\n    static byte[] sqlite3BtreeKeyFetch( BtCursor pCur, ref int pAmt, ref int outOffset )\n    {\n      byte[] p = null;\n      Debug.Assert( sqlite3_mutex_held( pCur.pBtree.db.mutex ) );\n      Debug.Assert( cursorHoldsMutex( pCur ) );\n      if ( ALWAYS( pCur.eState == CURSOR_VALID ) )\n      {\n        p = fetchPayload( pCur, ref pAmt, ref outOffset, false );\n      }\n      return p;\n    }\n    static byte[] sqlite3BtreeDataFetch( BtCursor pCur, ref int pAmt, ref int outOffset )\n    {\n      byte[] p = null;\n      Debug.Assert( sqlite3_mutex_held( pCur.pBtree.db.mutex ) );\n      Debug.Assert( cursorHoldsMutex( pCur ) );\n      if ( ALWAYS( pCur.eState == CURSOR_VALID ) )\n      {\n        p = fetchPayload( pCur, ref pAmt, ref outOffset, true );\n      }\n      return p;\n    }\n\n    /*\n    ** Move the cursor down to a new child page.  The newPgno argument is the\n    ** page number of the child page to move to.\n    **\n    ** This function returns SQLITE_CORRUPT if the page-header flags field of\n    ** the new child page does not match the flags field of the parent (i.e.\n    ** if an intkey page appears to be the parent of a non-intkey page, or\n    ** vice-versa).\n    */\n    static int moveToChild(BtCursor pCur, u32 newPgno)\n    {\n      int rc;\n      int i = pCur.iPage;\n      MemPage pNewPage = new MemPage();\n      BtShared pBt = pCur.pBt;\n\n      Debug.Assert(cursorHoldsMutex(pCur));\n      Debug.Assert(pCur.eState == CURSOR_VALID);\n      Debug.Assert(pCur.iPage < BTCURSOR_MAX_DEPTH);\n      if (pCur.iPage >= (BTCURSOR_MAX_DEPTH - 1))\n      {\n#if SQLITE_DEBUG || DEBUG\n        return SQLITE_CORRUPT_BKPT();\n#else\nreturn SQLITE_CORRUPT_BKPT;\n#endif\n      }\n      rc = getAndInitPage(pBt, newPgno, ref pNewPage);\n      if (rc != 0) return rc;\n      pCur.apPage[i + 1] = pNewPage;\n      pCur.aiIdx[i + 1] = 0;\n      pCur.iPage++;\n\n      pCur.info.nSize = 0;\n      pCur.validNKey = false;\n      if (pNewPage.nCell < 1 || pNewPage.intKey != pCur.apPage[i].intKey)\n      {\n#if SQLITE_DEBUG || DEBUG\n        return SQLITE_CORRUPT_BKPT();\n#else\nreturn SQLITE_CORRUPT_BKPT;\n#endif\n      }\n      return SQLITE_OK;\n    }\n\n#if !NDEBUG\n    /*\n** Page pParent is an internal (non-leaf) tree page. This function\n** asserts that page number iChild is the left-child if the iIdx\'th\n** cell in page pParent. Or, if iIdx is equal to the total number of\n** cells in pParent, that page number iChild is the right-child of\n** the page.\n*/\n    static void assertParentIndex(MemPage pParent, int iIdx, Pgno iChild)\n    {\n      Debug.Assert(iIdx <= pParent.nCell);\n      if (iIdx == pParent.nCell)\n      {\n        Debug.Assert(sqlite3Get4byte(pParent.aData, pParent.hdrOffset + 8) == iChild);\n      }\n      else\n      {\n        Debug.Assert(sqlite3Get4byte(pParent.aData, findCell(pParent, iIdx)) == iChild);\n      }\n    }\n#else\n//#  define assertParentIndex(x,y,z)\nstatic void assertParentIndex(MemPage pParent, int iIdx, Pgno iChild) { }\n#endif\n\n    /*\n** Move the cursor up to the parent page.\n**\n** pCur.idx is set to the cell index that contains the pointer\n** to the page we are coming from.  If we are coming from the\n** right-most child page then pCur.idx is set to one more than\n** the largest cell index.\n*/\n    static void moveToParent(BtCursor pCur)\n    {\n      Debug.Assert(cursorHoldsMutex(pCur));\n      Debug.Assert(pCur.eState == CURSOR_VALID);\n      Debug.Assert(pCur.iPage > 0);\n      Debug.Assert(pCur.apPage[pCur.iPage] != null);\n      assertParentIndex(\n      pCur.apPage[pCur.iPage - 1],\n      pCur.aiIdx[pCur.iPage - 1],\n      pCur.apPage[pCur.iPage].pgno\n      );\n      releasePage(pCur.apPage[pCur.iPage]);\n      pCur.iPage--;\n      pCur.info.nSize = 0;\n      pCur.validNKey = false;\n    }\n\n    /*\n    ** Move the cursor to point to the root page of its b-tree structure.\n    **\n    ** If the table has a virtual root page, then the cursor is moved to point\n    ** to the virtual root page instead of the actual root page. A table has a\n    ** virtual root page when the actual root page contains no cells and a\n    ** single child page. This can only happen with the table rooted at page 1.\n    **\n    ** If the b-tree structure is empty, the cursor state is set to\n    ** CURSOR_INVALID. Otherwise, the cursor is set to point to the first\n    ** cell located on the root (or virtual root) page and the cursor state\n    ** is set to CURSOR_VALID.\n    **\n    ** If this function returns successfully, it may be assumed that the\n    ** page-header flags indicate that the [virtual] root-page is the expected\n    ** kind of b-tree page (i.e. if when opening the cursor the caller did not\n    ** specify a KeyInfo structure the flags byte is set to 0x05 or 0x0D,\n    ** indicating a table b-tree, or if the caller did specify a KeyInfo\n    ** structure the flags byte is set to 0x02 or 0x0A, indicating an index\n    ** b-tree).\n    */\n    static int moveToRoot(BtCursor pCur)\n    {\n      MemPage pRoot;\n      int rc = SQLITE_OK;\n      Btree p = pCur.pBtree;\n      BtShared pBt = p.pBt;\n\n      Debug.Assert(cursorHoldsMutex(pCur));\n      Debug.Assert(CURSOR_INVALID < CURSOR_REQUIRESEEK);\n      Debug.Assert(CURSOR_VALID < CURSOR_REQUIRESEEK);\n      Debug.Assert(CURSOR_FAULT > CURSOR_REQUIRESEEK);\n      if (pCur.eState >= CURSOR_REQUIRESEEK)\n      {\n        if (pCur.eState == CURSOR_FAULT)\n        {\n          Debug.Assert(pCur.skipNext != SQLITE_OK);\n          return pCur.skipNext;\n        }\n        sqlite3BtreeClearCursor(pCur);\n      }\n\n      if (pCur.iPage >= 0)\n      {\n        int i;\n        for (i = 1; i <= pCur.iPage; i++)\n        {\n          releasePage(pCur.apPage[i]);\n        }\n        pCur.iPage = 0;\n      }\n      else\n      {\n        rc = getAndInitPage(pBt, pCur.pgnoRoot, ref pCur.apPage[0]);\n        if (rc != SQLITE_OK)\n        {\n          pCur.eState = CURSOR_INVALID;\n          return rc;\n        }\n        pCur.iPage = 0;\n\n        /* If pCur.pKeyInfo is not NULL, then the caller that opened this cursor\n        ** expected to open it on an index b-tree. Otherwise, if pKeyInfo is\n        ** NULL, the caller expects a table b-tree. If this is not the case,\n        ** return an SQLITE_CORRUPT error.  */\n        Debug.Assert(pCur.apPage[0].intKey == 1 || pCur.apPage[0].intKey == 0);\n        if ((pCur.pKeyInfo == null) != (pCur.apPage[0].intKey != 0))\n        {\n#if SQLITE_DEBUG || DEBUG\n          return SQLITE_CORRUPT_BKPT();\n#else\nreturn SQLITE_CORRUPT_BKPT;\n#endif\n        }\n      }\n\n      /* Assert that the root page is of the correct type. This must be the\n      ** case as the call to this function that loaded the root-page (either\n      ** this call or a previous invocation) would have detected corruption\n      ** if the assumption were not true, and it is not possible for the flags\n      ** byte to have been modified while this cursor is holding a reference\n      ** to the page.  */\n      pRoot = pCur.apPage[0];\n      Debug.Assert(pRoot.pgno == pCur.pgnoRoot);\n      Debug.Assert(pRoot.isInit != 0 && (pCur.pKeyInfo == null) == (pRoot.intKey != 0));\n\n      pCur.aiIdx[0] = 0;\n      pCur.info.nSize = 0;\n      pCur.atLast = 0;\n      pCur.validNKey = false;\n\n      if (pRoot.nCell == 0 && 0 == pRoot.leaf)\n      {\n        Pgno subpage;\n        if (pRoot.pgno != 1)\n#if SQLITE_DEBUG || DEBUG\n          return SQLITE_CORRUPT_BKPT();\n#else\nreturn SQLITE_CORRUPT_BKPT;\n#endif\n        subpage = sqlite3Get4byte(pRoot.aData, pRoot.hdrOffset + 8);\n        pCur.eState = CURSOR_VALID;\n        rc = moveToChild(pCur, subpage);\n      }\n      else\n      {\n        pCur.eState = ((pRoot.nCell > 0) ? CURSOR_VALID : CURSOR_INVALID);\n      }\n      return rc;\n    }\n\n    /*\n    ** Move the cursor down to the left-most leaf entry beneath the\n    ** entry to which it is currently pointing.\n    **\n    ** The left-most leaf is the one with the smallest key - the first\n    ** in ascending order.\n    */\n    static int moveToLeftmost(BtCursor pCur)\n    {\n      Pgno pgno;\n      int rc = SQLITE_OK;\n      MemPage pPage;\n\n      Debug.Assert(cursorHoldsMutex(pCur));\n      Debug.Assert(pCur.eState == CURSOR_VALID);\n      while (rc == SQLITE_OK && 0 == (pPage = pCur.apPage[pCur.iPage]).leaf)\n      {\n        Debug.Assert(pCur.aiIdx[pCur.iPage] < pPage.nCell);\n        pgno = sqlite3Get4byte(pPage.aData, findCell(pPage, pCur.aiIdx[pCur.iPage]));\n        rc = moveToChild(pCur, pgno);\n      }\n      return rc;\n    }\n\n    /*\n    ** Move the cursor down to the right-most leaf entry beneath the\n    ** page to which it is currently pointing.  Notice the difference\n    ** between moveToLeftmost() and moveToRightmost().  moveToLeftmost()\n    ** finds the left-most entry beneath the *entry* whereas moveToRightmost()\n    ** finds the right-most entry beneath the page*.\n    **\n    ** The right-most entry is the one with the largest key - the last\n    ** key in ascending order.\n    */\n    static int moveToRightmost(BtCursor pCur)\n    {\n      Pgno pgno;\n      int rc = SQLITE_OK;\n      MemPage pPage = null;\n\n      Debug.Assert(cursorHoldsMutex(pCur));\n      Debug.Assert(pCur.eState == CURSOR_VALID);\n      while (rc == SQLITE_OK && 0 == (pPage = pCur.apPage[pCur.iPage]).leaf)\n      {\n        pgno = sqlite3Get4byte(pPage.aData, pPage.hdrOffset + 8);\n        pCur.aiIdx[pCur.iPage] = pPage.nCell;\n        rc = moveToChild(pCur, pgno);\n      }\n      if (rc == SQLITE_OK)\n      {\n        pCur.aiIdx[pCur.iPage] = (u16)(pPage.nCell - 1);\n        pCur.info.nSize = 0;\n        pCur.validNKey = false;\n      }\n      return rc;\n    }\n\n    /* Move the cursor to the first entry in the table.  Return SQLITE_OK\n    ** on success.  Set pRes to 0 if the cursor actually points to something\n    ** or set pRes to 1 if the table is empty.\n    */\n    static int sqlite3BtreeFirst(BtCursor pCur, ref int pRes)\n    {\n      int rc;\n\n      Debug.Assert(cursorHoldsMutex(pCur));\n      Debug.Assert(sqlite3_mutex_held(pCur.pBtree.db.mutex));\n      rc = moveToRoot(pCur);\n      if (rc == SQLITE_OK)\n      {\n        if (pCur.eState == CURSOR_INVALID)\n        {\n          Debug.Assert(pCur.apPage[pCur.iPage].nCell == 0);\n          pRes = 1;\n          rc = SQLITE_OK;\n        }\n        else\n        {\n          Debug.Assert(pCur.apPage[pCur.iPage].nCell > 0);\n          pRes = 0;\n          rc = moveToLeftmost(pCur);\n        }\n      }\n      return rc;\n    }\n\n    /* Move the cursor to the last entry in the table.  Return SQLITE_OK\n    ** on success.  Set pRes to 0 if the cursor actually points to something\n    ** or set pRes to 1 if the table is empty.\n    */\n    static int sqlite3BtreeLast(BtCursor pCur, ref int pRes)\n    {\n      int rc;\n\n      Debug.Assert(cursorHoldsMutex(pCur));\n      Debug.Assert(sqlite3_mutex_held(pCur.pBtree.db.mutex));\n\n      /* If the cursor already points to the last entry, this is a no-op. */\n      if (CURSOR_VALID == pCur.eState && pCur.atLast != 0)\n      {\n#if SQLITE_DEBUG\n        /* This block serves to Debug.Assert() that the cursor really does point\n** to the last entry in the b-tree. */\n        int ii;\n        for (ii = 0; ii < pCur.iPage; ii++)\n        {\n          Debug.Assert(pCur.aiIdx[ii] == pCur.apPage[ii].nCell);\n        }\n        Debug.Assert(pCur.aiIdx[pCur.iPage] == pCur.apPage[pCur.iPage].nCell - 1);\n        Debug.Assert(pCur.apPage[pCur.iPage].leaf != 0);\n#endif\n        return SQLITE_OK;\n      }\n\n      rc = moveToRoot(pCur);\n      if (rc == SQLITE_OK)\n      {\n        if (CURSOR_INVALID == pCur.eState)\n        {\n          Debug.Assert(pCur.apPage[pCur.iPage].nCell == 0);\n          pRes = 1;\n        }\n        else\n        {\n          Debug.Assert(pCur.eState == CURSOR_VALID);\n          pRes = 0;\n          rc = moveToRightmost(pCur);\n          pCur.atLast = (u8)(rc == SQLITE_OK ? 1 : 0);\n        }\n      }\n      return rc;\n    }\n\n    /* Move the cursor so that it points to an entry near the key\n    ** specified by pIdxKey or intKey.   Return a success code.\n    **\n    ** For INTKEY tables, the intKey parameter is used.  pIdxKey\n    ** must be NULL.  For index tables, pIdxKey is used and intKey\n    ** is ignored.\n    **\n    ** If an exact match is not found, then the cursor is always\n    ** left pointing at a leaf page which would hold the entry if it\n    ** were present.  The cursor might point to an entry that comes\n    ** before or after the key.\n    **\n    ** An integer is written into pRes which is the result of\n    ** comparing the key with the entry to which the cursor is\n    ** pointing.  The meaning of the integer written into\n    ** pRes is as follows:\n    **\n    **     pRes<0      The cursor is left pointing at an entry that\n    **                  is smaller than intKey/pIdxKey or if the table is empty\n    **                  and the cursor is therefore left point to nothing.\n    **\n    **     pRes==null     The cursor is left pointing at an entry that\n    **                  exactly matches intKey/pIdxKey.\n    **\n    **     pRes>0      The cursor is left pointing at an entry that\n    **                  is larger than intKey/pIdxKey.\n    **\n    */\n    static int sqlite3BtreeMovetoUnpacked(\n    BtCursor pCur,           /* The cursor to be moved */\n    UnpackedRecord pIdxKey,  /* Unpacked index key */\n    i64 intKey,              /* The table key */\n    int biasRight,           /* If true, bias the search to the high end */\n    ref int pRes             /* Write search results here */\n    )\n    {\n      int rc;\n\n      Debug.Assert(cursorHoldsMutex(pCur));\n      Debug.Assert(sqlite3_mutex_held(pCur.pBtree.db.mutex));\n      // Not needed in C# // Debug.Assert( pRes != 0 );\n      Debug.Assert((pIdxKey == null) == (pCur.pKeyInfo == null));\n\n      /* If the cursor is already positioned at the point we are trying\n      ** to move to, then just return without doing any work */\n      if (pCur.eState == CURSOR_VALID && pCur.validNKey\n      && pCur.apPage[0].intKey != 0\n      )\n      {\n        if (pCur.info.nKey == intKey)\n        {\n          pRes = 0;\n          return SQLITE_OK;\n        }\n        if (pCur.atLast != 0 && pCur.info.nKey < intKey)\n        {\n          pRes = -1;\n          return SQLITE_OK;\n        }\n      }\n\n      rc = moveToRoot(pCur);\n      if (rc != 0)\n      {\n        return rc;\n      }\n      Debug.Assert(pCur.apPage[pCur.iPage] != null);\n      Debug.Assert(pCur.apPage[pCur.iPage].isInit != 0);\n      Debug.Assert(pCur.apPage[pCur.iPage].nCell > 0 || pCur.eState == CURSOR_INVALID);\n      if (pCur.eState == CURSOR_INVALID)\n      {\n        pRes = -1;\n        Debug.Assert(pCur.apPage[pCur.iPage].nCell == 0);\n        return SQLITE_OK;\n      }\n      Debug.Assert(pCur.apPage[0].intKey != 0 || pIdxKey != null);\n      for (; ; )\n      {\n        int lwr, upr;\n        Pgno chldPg;\n        MemPage pPage = pCur.apPage[pCur.iPage];\n        int c;\n\n        /* pPage.nCell must be greater than zero. If this is the root-page\n        ** the cursor would have been INVALID above and this for(;;) loop\n        ** not run. If this is not the root-page, then the moveToChild() routine\n        ** would have already detected db corruption. Similarly, pPage must\n        ** be the right kind (index or table) of b-tree page. Otherwise\n        ** a moveToChild() or moveToRoot() call would have detected corruption.  */\n        Debug.Assert(pPage.nCell > 0);\n        Debug.Assert(pPage.intKey == ((pIdxKey == null) ? 1 : 0));\n        lwr = 0;\n        upr = pPage.nCell - 1;\n        if (biasRight != 0)\n        {\n          pCur.aiIdx[pCur.iPage] = (u16)upr;\n        }\n        else\n        {\n          pCur.aiIdx[pCur.iPage] = (u16)((upr + lwr) / 2);\n        }\n        for (; ; )\n        {\n          int idx = pCur.aiIdx[pCur.iPage]; /* Index of current cell in pPage */\n          int pCell;                        /* Pointer to current cell in pPage */\n\n          pCur.info.nSize = 0;\n          pCell = findCell(pPage, idx) + pPage.childPtrSize;\n          if (pPage.intKey != 0)\n          {\n            i64 nCellKey = 0;\n            if (pPage.hasData != 0)\n            {\n              u32 Dummy0 = 0;\n              pCell += getVarint32(pPage.aData, pCell, ref Dummy0);\n            }\n            getVarint(pPage.aData, pCell, ref nCellKey);\n            if (nCellKey == intKey)\n            {\n              c = 0;\n            }\n            else if (nCellKey < intKey)\n            {\n              c = -1;\n            }\n            else\n            {\n              Debug.Assert(nCellKey > intKey);\n              c = +1;\n            }\n            pCur.validNKey = true;\n            pCur.info.nKey = nCellKey;\n          }\n          else\n          {\n            /* The maximum supported page-size is 32768 bytes. This means that\n            ** the maximum number of record bytes stored on an index B-Tree\n            ** page is at most 8198 bytes, which may be stored as a 2-byte\n            ** varint. This information is used to attempt to avoid parsing\n            ** the entire cell by checking for the cases where the record is\n            ** stored entirely within the b-tree page by inspecting the first\n            ** 2 bytes of the cell.\n            */\n            int nCell = pPage.aData[pCell + 0]; //pCell[0];\n            if (0 == (nCell & 0x80) && nCell <= pPage.maxLocal)\n            {\n              /* This branch runs if the record-size field of the cell is a\n              ** single byte varint and the record fits entirely on the main\n              ** b-tree page.  */\n              c = sqlite3VdbeRecordCompare(nCell, pPage.aData, pCell + 1, pIdxKey); //c = sqlite3VdbeRecordCompare( nCell, (void*)&pCell[1], pIdxKey );\n            }\n            else if (0 == (pPage.aData[pCell + 1] & 0x80)//!(pCell[1] & 0x80)\n            && (nCell = ((nCell & 0x7f) << 7) + pPage.aData[pCell + 1]) <= pPage.maxLocal//pCell[1])<=pPage.maxLocal\n            )\n            {\n              /* The record-size field is a 2 byte varint and the record\n              ** fits entirely on the main b-tree page.  */\n              c = sqlite3VdbeRecordCompare(nCell, pPage.aData, pCell + 2, pIdxKey); //c = sqlite3VdbeRecordCompare( nCell, (void*)&pCell[2], pIdxKey );\n            }\n            else\n            {\n              /* The record flows over onto one or more overflow pages. In\n              ** this case the whole cell needs to be parsed, a buffer allocated\n              ** and accessPayload() used to retrieve the record into the\n              ** buffer before VdbeRecordCompare() can be called. */\n              u8[] pCellKey;\n              u8[] pCellBody = new u8[pPage.aData.Length - pCell + pPage.childPtrSize];\n              Buffer.BlockCopy(pPage.aData, pCell - pPage.childPtrSize, pCellBody, 0, pCellBody.Length);//          u8 * const pCellBody = pCell - pPage->childPtrSize;\n              btreeParseCellPtr( pPage, pCellBody, ref pCur.info );\n              nCell = (int)pCur.info.nKey;\n              pCellKey = new byte[nCell]; //sqlite3Malloc( nCell );\n              //if ( pCellKey == null )\n              //{\n              //  rc = SQLITE_NOMEM;\n              //  goto moveto_finish;\n              //}\n              rc = accessPayload(pCur, 0, (u32)nCell, pCellKey, 0);\n              c = sqlite3VdbeRecordCompare(nCell, pCellKey, pIdxKey);\n              pCellKey = null;// sqlite3_free( ref pCellKey );\n              if (rc != 0) goto moveto_finish;\n            }\n          }\n          if (c == 0)\n          {\n            if (pPage.intKey != 0 && 0 == pPage.leaf)\n            {\n              lwr = idx;\n              upr = lwr - 1;\n              break;\n            }\n            else\n            {\n              pRes = 0;\n              rc = SQLITE_OK;\n              goto moveto_finish;\n            }\n          }\n          if (c < 0)\n          {\n            lwr = idx + 1;\n          }\n          else\n          {\n            upr = idx - 1;\n          }\n          if (lwr > upr)\n          {\n            break;\n          }\n          pCur.aiIdx[pCur.iPage] = (u16)((lwr + upr) / 2);\n        }\n        Debug.Assert(lwr == upr + 1);\n        Debug.Assert(pPage.isInit != 0);\n        if (pPage.leaf != 0)\n        {\n          chldPg = 0;\n        }\n        else if (lwr >= pPage.nCell)\n        {\n          chldPg = sqlite3Get4byte(pPage.aData, pPage.hdrOffset + 8);\n        }\n        else\n        {\n          chldPg = sqlite3Get4byte(pPage.aData, findCell(pPage, lwr));\n        }\n        if (chldPg == 0)\n        {\n          Debug.Assert(pCur.aiIdx[pCur.iPage] < pCur.apPage[pCur.iPage].nCell);\n          pRes = c;\n          rc = SQLITE_OK;\n          goto moveto_finish;\n        }\n        pCur.aiIdx[pCur.iPage] = (u16)lwr;\n        pCur.info.nSize = 0;\n        pCur.validNKey = false;\n        rc = moveToChild(pCur, chldPg);\n        if (rc != 0) goto moveto_finish;\n      }\n    moveto_finish:\n      return rc;\n    }\n\n\n    /*\n    ** Return TRUE if the cursor is not pointing at an entry of the table.\n    **\n    ** TRUE will be returned after a call to sqlite3BtreeNext() moves\n    ** past the last entry in the table or sqlite3BtreePrev() moves past\n    ** the first entry.  TRUE is also returned if the table is empty.\n    */\n    static bool sqlite3BtreeEof(BtCursor pCur)\n    {\n      /* TODO: What if the cursor is in CURSOR_REQUIRESEEK but all table entries\n      ** have been deleted? This API will need to change to return an error code\n      ** as well as the boolean result value.\n      */\n      return (CURSOR_VALID != pCur.eState);\n    }\n\n    /*\n    ** Advance the cursor to the next entry in the database.  If\n    ** successful then set pRes=0.  If the cursor\n    ** was already pointing to the last entry in the database before\n    ** this routine was called, then set pRes=1.\n    */\n    static int sqlite3BtreeNext(BtCursor pCur, ref int pRes)\n    {\n      int rc;\n      int idx;\n      MemPage pPage;\n\n      Debug.Assert(cursorHoldsMutex(pCur));\n      rc = restoreCursorPosition(pCur);\n      if (rc != SQLITE_OK)\n      {\n        return rc;\n      }\n      // Not needed in C# // Debug.Assert( pRes != 0 );\n      if (CURSOR_INVALID == pCur.eState)\n      {\n        pRes = 1;\n        return SQLITE_OK;\n      }\n      if (pCur.skipNext > 0)\n      {\n        pCur.skipNext = 0;\n        pRes = 0;\n        return SQLITE_OK;\n      }\n      pCur.skipNext = 0;\n\n      pPage = pCur.apPage[pCur.iPage];\n      idx = ++pCur.aiIdx[pCur.iPage];\n      Debug.Assert(pPage.isInit != 0);\n      Debug.Assert(idx <= pPage.nCell);\n\n      pCur.info.nSize = 0;\n      pCur.validNKey = false;\n      if (idx >= pPage.nCell)\n      {\n        if (0 == pPage.leaf)\n        {\n          rc = moveToChild(pCur, sqlite3Get4byte(pPage.aData, pPage.hdrOffset + 8));\n          if (rc != 0) return rc;\n          rc = moveToLeftmost(pCur);\n          pRes = 0;\n          return rc;\n        }\n        do\n        {\n          if (pCur.iPage == 0)\n          {\n            pRes = 1;\n            pCur.eState = CURSOR_INVALID;\n            return SQLITE_OK;\n          }\n          moveToParent(pCur);\n          pPage = pCur.apPage[pCur.iPage];\n        } while (pCur.aiIdx[pCur.iPage] >= pPage.nCell);\n        pRes = 0;\n        if (pPage.intKey != 0)\n        {\n          rc = sqlite3BtreeNext(pCur, ref pRes);\n        }\n        else\n        {\n          rc = SQLITE_OK;\n        }\n        return rc;\n      }\n      pRes = 0;\n      if (pPage.leaf != 0)\n      {\n        return SQLITE_OK;\n      }\n      rc = moveToLeftmost(pCur);\n      return rc;\n    }\n\n\n    /*\n    ** Step the cursor to the back to the previous entry in the database.  If\n    ** successful then set pRes=0.  If the cursor\n    ** was already pointing to the first entry in the database before\n    ** this routine was called, then set pRes=1.\n    */\n    static int sqlite3BtreePrevious(BtCursor pCur, ref int pRes)\n    {\n      int rc;\n      MemPage pPage;\n\n      Debug.Assert(cursorHoldsMutex(pCur));\n      rc = restoreCursorPosition(pCur);\n      if (rc != SQLITE_OK)\n      {\n        return rc;\n      }\n      pCur.atLast = 0;\n      if (CURSOR_INVALID == pCur.eState)\n      {\n        pRes = 1;\n        return SQLITE_OK;\n      }\n      if (pCur.skipNext < 0)\n      {\n        pCur.skipNext = 0;\n        pRes = 0;\n        return SQLITE_OK;\n      }\n      pCur.skipNext = 0;\n\n      pPage = pCur.apPage[pCur.iPage];\n      Debug.Assert(pPage.isInit != 0);\n      if (0 == pPage.leaf)\n      {\n        int idx = pCur.aiIdx[pCur.iPage];\n        rc = moveToChild(pCur, sqlite3Get4byte(pPage.aData, findCell(pPage, idx)));\n        if (rc != 0)\n        {\n          return rc;\n        }\n        rc = moveToRightmost(pCur);\n      }\n      else\n      {\n        while (pCur.aiIdx[pCur.iPage] == 0)\n        {\n          if (pCur.iPage == 0)\n          {\n            pCur.eState = CURSOR_INVALID;\n            pRes = 1;\n            return SQLITE_OK;\n          }\n          moveToParent(pCur);\n        }\n        pCur.info.nSize = 0;\n        pCur.validNKey = false;\n\n        pCur.aiIdx[pCur.iPage]--;\n        pPage = pCur.apPage[pCur.iPage];\n        if (pPage.intKey != 0 && 0 == pPage.leaf)\n        {\n          rc = sqlite3BtreePrevious(pCur, ref pRes);\n        }\n        else\n        {\n          rc = SQLITE_OK;\n        }\n      }\n      pRes = 0;\n      return rc;\n    }\n\n    /*\n    ** Allocate a new page from the database file.\n    **\n    ** The new page is marked as dirty.  (In other words, sqlite3PagerWrite()\n    ** has already been called on the new page.)  The new page has also\n    ** been referenced and the calling routine is responsible for calling\n    ** sqlite3PagerUnref() on the new page when it is done.\n    **\n    ** SQLITE_OK is returned on success.  Any other return value indicates\n    ** an error.  ppPage and pPgno are undefined in the event of an error.\n    ** Do not invoke sqlite3PagerUnref() on ppPage if an error is returned.\n    **\n    ** If the "nearby" parameter is not 0, then a (feeble) effort is made to\n    ** locate a page close to the page number "nearby".  This can be used in an\n    ** attempt to keep related pages close to each other in the database file,\n    ** which in turn can make database access faster.\n    **\n    ** If the "exact" parameter is not 0, and the page-number nearby exists\n    ** anywhere on the free-list, then it is guarenteed to be returned. This\n    ** is only used by auto-vacuum databases when allocating a new table.\n    */\n    static int allocateBtreePage(\n    BtShared pBt,\n    ref MemPage ppPage,\n    ref Pgno pPgno,\n    Pgno nearby,\n    u8 exact\n    )\n    {\n      MemPage pPage1;\n      int rc;\n      u32 n;     /* Number of pages on the freelist */\n      u32 k;     /* Number of leaves on the trunk of the freelist */\n      MemPage pTrunk = null;\n      MemPage pPrevTrunk = null;\n      Pgno mxPage;     /* Total size of the database file */\n\n      Debug.Assert(sqlite3_mutex_held(pBt.mutex));\n      pPage1 = pBt.pPage1;\n      mxPage = pagerPagecount(pBt);\n      n = sqlite3Get4byte(pPage1.aData, 36);\n      testcase(n == mxPage - 1);\n      if (n >= mxPage)\n      {\n#if SQLITE_DEBUG || DEBUG\n        return SQLITE_CORRUPT_BKPT();\n#else\nreturn SQLITE_CORRUPT_BKPT;\n#endif\n      }\n      if (n > 0)\n      {\n        /* There are pages on the freelist.  Reuse one of those pages. */\n        Pgno iTrunk;\n        u8 searchList = 0; /* If the free-list must be searched for \'nearby\' */\n\n        /* If the \'exact\' parameter was true and a query of the pointer-map\n        ** shows that the page \'nearby\' is somewhere on the free-list, then\n        ** the entire-list will be searched for that page.\n        */\n#if !SQLITE_OMIT_AUTOVACUUM\n        if (exact != 0 && nearby <= mxPage)\n        {\n          u8 eType = 0;\n          Debug.Assert(nearby > 0);\n          Debug.Assert(pBt.autoVacuum);\n          u32 Dummy0 = 0; rc = ptrmapGet(pBt, nearby, ref eType, ref Dummy0);\n          if (rc != 0) return rc;\n          if (eType == PTRMAP_FREEPAGE)\n          {\n            searchList = 1;\n          }\n          pPgno = nearby;\n        }\n#endif\n\n        /* Decrement the free-list count by 1. Set iTrunk to the index of the\n** first free-list trunk page. iPrevTrunk is initially 1.\n*/\n        rc = sqlite3PagerWrite(pPage1.pDbPage);\n        if (rc != 0) return rc;\n        sqlite3Put4byte(pPage1.aData, (u32)36, n - 1);\n\n        /* The code within this loop is run only once if the \'searchList\' variable\n        ** is not true. Otherwise, it runs once for each trunk-page on the\n        ** free-list until the page \'nearby\' is located.\n        */\n        do\n        {\n          pPrevTrunk = pTrunk;\n          if (pPrevTrunk != null)\n          {\n            iTrunk = sqlite3Get4byte(pPrevTrunk.aData, 0);\n          }\n          else\n          {\n            iTrunk = sqlite3Get4byte(pPage1.aData, 32);\n          }\n          testcase(iTrunk == mxPage);\n          if (iTrunk > mxPage)\n          {\n#if SQLITE_DEBUG || DEBUG\n            rc = SQLITE_CORRUPT_BKPT();\n#else\nrc = SQLITE_CORRUPT_BKPT;\n#endif\n          }\n          else\n          {\n            rc = btreeGetPage(pBt, iTrunk, ref pTrunk, 0);\n          }\n          if (rc != 0)\n          {\n            pTrunk = null;\n            goto end_allocate_page;\n          }\n\n          k = sqlite3Get4byte(pTrunk.aData, 4);\n          if (k == 0 && 0 == searchList)\n          {\n            /* The trunk has no leaves and the list is not being searched.\n            ** So extract the trunk page itself and use it as the newly\n            ** allocated page */\n            Debug.Assert(pPrevTrunk == null);\n            rc = sqlite3PagerWrite(pTrunk.pDbPage);\n            if (rc != 0)\n            {\n              goto end_allocate_page;\n            }\n            pPgno = iTrunk;\n            Buffer.BlockCopy(pTrunk.aData, 0, pPage1.aData, 32, 4);//memcpy( pPage1.aData[32], ref pTrunk.aData[0], 4 );\n            ppPage = pTrunk;\n            pTrunk = null;\n            TRACE("ALLOCATE: %d trunk - %d free pages left\\n", pPgno, n - 1);\n          }\n          else if (k > (u32)(pBt.usableSize / 4 - 2))\n          {\n            /* Value of k is out of range.  Database corruption */\n#if SQLITE_DEBUG || DEBUG\n            rc = SQLITE_CORRUPT_BKPT();\n#else\nrc =  SQLITE_CORRUPT_BKPT;\n#endif\n            goto end_allocate_page;\n#if !SQLITE_OMIT_AUTOVACUUM\n          }\n          else if (searchList != 0 && nearby == iTrunk)\n          {\n            /* The list is being searched and this trunk page is the page\n            ** to allocate, regardless of whether it has leaves.\n            */\n            Debug.Assert(pPgno == iTrunk);\n            ppPage = pTrunk;\n            searchList = 0;\n            rc = sqlite3PagerWrite(pTrunk.pDbPage);\n            if (rc != 0)\n            {\n              goto end_allocate_page;\n            }\n            if (k == 0)\n            {\n              if (null == pPrevTrunk)\n              {\n                //memcpy(pPage1.aData[32], pTrunk.aData[0], 4);\n                pPage1.aData[32 + 0] = pTrunk.aData[0 + 0];\n                pPage1.aData[32 + 1] = pTrunk.aData[0 + 1];\n                pPage1.aData[32 + 2] = pTrunk.aData[0 + 2];\n                pPage1.aData[32 + 3] = pTrunk.aData[0 + 3];\n              }\n              else\n              {\n                //memcpy(pPrevTrunk.aData[0], pTrunk.aData[0], 4);\n                pPrevTrunk.aData[0 + 0] = pTrunk.aData[0 + 0];\n                pPrevTrunk.aData[0 + 1] = pTrunk.aData[0 + 1];\n                pPrevTrunk.aData[0 + 2] = pTrunk.aData[0 + 2];\n                pPrevTrunk.aData[0 + 3] = pTrunk.aData[0 + 3];\n              }\n            }\n            else\n            {\n              /* The trunk page is required by the caller but it contains\n              ** pointers to free-list leaves. The first leaf becomes a trunk\n              ** page in this case.\n              */\n              MemPage pNewTrunk = new MemPage();\n              Pgno iNewTrunk = sqlite3Get4byte(pTrunk.aData, 8);\n              if (iNewTrunk > mxPage)\n              {\n#if SQLITE_DEBUG || DEBUG\n                rc = SQLITE_CORRUPT_BKPT();\n#else\nrc = SQLITE_CORRUPT_BKPT;\n#endif\n                goto end_allocate_page;\n              }\n              testcase(iNewTrunk == mxPage);\n              rc = btreeGetPage(pBt, iNewTrunk, ref pNewTrunk, 0);\n              if (rc != SQLITE_OK)\n              {\n                goto end_allocate_page;\n              }\n              rc = sqlite3PagerWrite(pNewTrunk.pDbPage);\n              if (rc != SQLITE_OK)\n              {\n                releasePage(pNewTrunk);\n                goto end_allocate_page;\n              }\n              //memcpy(pNewTrunk.aData[0], pTrunk.aData[0], 4);\n              pNewTrunk.aData[0 + 0] = pTrunk.aData[0 + 0];\n              pNewTrunk.aData[0 + 1] = pTrunk.aData[0 + 1];\n              pNewTrunk.aData[0 + 2] = pTrunk.aData[0 + 2];\n              pNewTrunk.aData[0 + 3] = pTrunk.aData[0 + 3];\n              sqlite3Put4byte(pNewTrunk.aData, (u32)4, (u32)(k - 1));\n              Buffer.BlockCopy(pTrunk.aData, 12, pNewTrunk.aData, 8, (int)(k - 1) * 4);//memcpy( pNewTrunk.aData[8], ref pTrunk.aData[12], ( k - 1 ) * 4 );\n              releasePage(pNewTrunk);\n              if (null == pPrevTrunk)\n              {\n                Debug.Assert(sqlite3PagerIswriteable(pPage1.pDbPage));\n                sqlite3Put4byte(pPage1.aData, (u32)32, iNewTrunk);\n              }\n              else\n              {\n                rc = sqlite3PagerWrite(pPrevTrunk.pDbPage);\n                if (rc != 0)\n                {\n                  goto end_allocate_page;\n                }\n                sqlite3Put4byte(pPrevTrunk.aData, (u32)0, iNewTrunk);\n              }\n            }\n            pTrunk = null;\n            TRACE("ALLOCATE: %d trunk - %d free pages left\\n", pPgno, n - 1);\n#endif\n          }\n          else if (k > 0)\n          {\n            /* Extract a leaf from the trunk */\n            u32 closest;\n            Pgno iPage;\n            byte[] aData = pTrunk.aData;\n            rc = sqlite3PagerWrite(pTrunk.pDbPage);\n            if (rc != 0)\n            {\n              goto end_allocate_page;\n            }\n            if (nearby > 0)\n            {\n              u32 i;\n              int dist;\n              closest = 0;\n              dist = (int)(sqlite3Get4byte(aData, 8) - nearby);\n              if (dist < 0) dist = -dist;\n              for (i = 1; i < k; i++)\n              {\n                int d2 = (int)(sqlite3Get4byte(aData, 8 + i * 4) - nearby);\n                if (d2 < 0) d2 = -d2;\n                if (d2 < dist)\n                {\n                  closest = i;\n                  dist = d2;\n                }\n              }\n            }\n            else\n            {\n              closest = 0;\n            }\n\n            iPage = sqlite3Get4byte(aData, 8 + closest * 4);\n            testcase(iPage == mxPage);\n            if (iPage > mxPage)\n            {\n#if SQLITE_DEBUG || DEBUG\n              rc = SQLITE_CORRUPT_BKPT();\n#else\nrc = SQLITE_CORRUPT_BKPT;\n#endif\n              goto end_allocate_page;\n            }\n            testcase(iPage == mxPage);\n            if (0 == searchList || iPage == nearby)\n            {\n              int noContent;\n              pPgno = iPage;\n              TRACE("ALLOCATE: %d was leaf %d of %d on trunk %d" +\n              ": %d more free pages\\n",\n              pPgno, closest + 1, k, pTrunk.pgno, n - 1);\n              if (closest < k - 1)\n              {\n                Buffer.BlockCopy(aData, (int)(4 + k * 4), aData, 8 + (int)closest * 4, 4);//memcpy( aData[8 + closest * 4], ref aData[4 + k * 4], 4 );\n              }\n              sqlite3Put4byte(aData, (u32)4, (k - 1));// sqlite3Put4byte( aData, 4, k - 1 );\n              Debug.Assert(sqlite3PagerIswriteable(pTrunk.pDbPage));\n              noContent = !btreeGetHasContent(pBt, pPgno) ? 1 : 0;\n              rc = btreeGetPage(pBt, pPgno, ref ppPage, noContent);\n              if (rc == SQLITE_OK)\n              {\n                rc = sqlite3PagerWrite((ppPage).pDbPage);\n                if (rc != SQLITE_OK)\n                {\n                  releasePage(ppPage);\n                }\n              }\n              searchList = 0;\n            }\n          }\n          releasePage(pPrevTrunk);\n          pPrevTrunk = null;\n        } while (searchList != 0);\n      }\n      else\n      {\n        /* There are no pages on the freelist, so create a new page at the\n        ** end of the file */\n        int nPage = (int)pagerPagecount(pBt);\n        pPgno = (u32)nPage + 1;\n\n        if (pPgno == PENDING_BYTE_PAGE(pBt))\n        {\n          (pPgno)++;\n        }\n\n#if !SQLITE_OMIT_AUTOVACUUM\n        if (pBt.autoVacuum && PTRMAP_ISPAGE(pBt, pPgno))\n        {\n          /* If pPgno refers to a pointer-map page, allocate two new pages\n          ** at the end of the file instead of one. The first allocated page\n          ** becomes a new pointer-map page, the second is used by the caller.\n          */\n          MemPage pPg = null;\n          TRACE("ALLOCATE: %d from end of file (pointer-map page)\\n", pPgno);\n          Debug.Assert(pPgno != PENDING_BYTE_PAGE(pBt));\n          rc = btreeGetPage(pBt, pPgno, ref pPg, 0);\n          if (rc == SQLITE_OK)\n          {\n            rc = sqlite3PagerWrite(pPg.pDbPage);\n            releasePage(pPg);\n          }\n          if (rc != 0) return rc;\n          (pPgno)++;\n          if (pPgno == PENDING_BYTE_PAGE(pBt)) { (pPgno)++; }\n        }\n#endif\n\n        Debug.Assert(pPgno != PENDING_BYTE_PAGE(pBt));\n        rc = btreeGetPage(pBt, pPgno, ref ppPage, 0);\n        if (rc != 0) return rc;\n        rc = sqlite3PagerWrite((ppPage).pDbPage);\n        if (rc != SQLITE_OK)\n        {\n          releasePage(ppPage);\n        }\n        TRACE("ALLOCATE: %d from end of file\\n", pPgno);\n      }\n\n      Debug.Assert(pPgno != PENDING_BYTE_PAGE(pBt));\n\n    end_allocate_page:\n      releasePage(pTrunk);\n      releasePage(pPrevTrunk);\n      if (rc == SQLITE_OK)\n      {\n        if (sqlite3PagerPageRefcount((ppPage).pDbPage) > 1)\n        {\n          releasePage(ppPage);\n#if SQLITE_DEBUG || DEBUG\n          return SQLITE_CORRUPT_BKPT();\n#else\nreturn SQLITE_CORRUPT_BKPT;\n#endif\n        }\n        (ppPage).isInit = 0;\n      }\n      else\n      {\n        ppPage = null;\n      }\n      return rc;\n    }\n\n    /*\n    ** This function is used to add page iPage to the database file free-list.\n    ** It is assumed that the page is not already a part of the free-list.\n    **\n    ** The value passed as the second argument to this function is optional.\n    ** If the caller happens to have a pointer to the MemPage object\n    ** corresponding to page iPage handy, it may pass it as the second value.\n    ** Otherwise, it may pass NULL.\n    **\n    ** If a pointer to a MemPage object is passed as the second argument,\n    ** its reference count is not altered by this function.\n    */\n    static int freePage2(BtShared pBt, MemPage pMemPage, Pgno iPage)\n    {\n      MemPage pTrunk = null;                /* Free-list trunk page */\n      Pgno iTrunk = 0;                    /* Page number of free-list trunk page */\n      MemPage pPage1 = pBt.pPage1;      /* Local reference to page 1 */\n      MemPage pPage;                     /* Page being freed. May be NULL. */\n      int rc;                             /* Return Code */\n      int nFree;                          /* Initial number of pages on free-list */\n\n      Debug.Assert(sqlite3_mutex_held(pBt.mutex));\n      Debug.Assert(iPage > 1);\n      Debug.Assert(null == pMemPage || pMemPage.pgno == iPage);\n\n      if (pMemPage != null)\n      {\n        pPage = pMemPage;\n        sqlite3PagerRef(pPage.pDbPage);\n      }\n      else\n      {\n        pPage = btreePageLookup(pBt, iPage);\n      }\n\n      /* Increment the free page count on pPage1 */\n      rc = sqlite3PagerWrite(pPage1.pDbPage);\n      if (rc != 0) goto freepage_out;\n      nFree = (int)sqlite3Get4byte(pPage1.aData, 36);\n      sqlite3Put4byte(pPage1.aData, 36, nFree + 1);\n\n#if SQLITE_SECURE_DELETE\n/* If the SQLITE_SECURE_DELETE compile-time option is enabled, then\n** always fully overwrite deleted information with zeros.\n*/\nif( (!pPage && (rc = btreeGetPage(pBt, iPage, ref pPage, 0)))\n||            (rc = sqlite3PagerWrite(pPage.pDbPage))\n){\ngoto freepage_out;\n}\nmemset(pPage.aData, 0, pPage.pBt.pageSize);\n#endif\n\n      /* If the database supports auto-vacuum, write an entry in the pointer-map\n** to indicate that the page is free.\n*/\n#if !SQLITE_OMIT_AUTOVACUUM //   if ( ISAUTOVACUUM )\n      if (pBt.autoVacuum)\n#else\nif (false)\n#endif\n      {\n        ptrmapPut(pBt, iPage, PTRMAP_FREEPAGE, 0, ref rc);\n        if (rc != 0) goto freepage_out;\n      }\n\n      /* Now manipulate the actual database free-list structure. There are two\n      ** possibilities. If the free-list is currently empty, or if the first\n      ** trunk page in the free-list is full, then this page will become a\n      ** new free-list trunk page. Otherwise, it will become a leaf of the\n      ** first trunk page in the current free-list. This block tests if it\n      ** is possible to add the page as a new free-list leaf.\n      */\n      if (nFree != 0)\n      {\n        u32 nLeaf;                /* Initial number of leaf cells on trunk page */\n\n        iTrunk = sqlite3Get4byte(pPage1.aData, 32);\n        rc = btreeGetPage(pBt, iTrunk, ref pTrunk, 0);\n        if (rc != SQLITE_OK)\n        {\n          goto freepage_out;\n        }\n\n        nLeaf = sqlite3Get4byte(pTrunk.aData, 4);\n        Debug.Assert(pBt.usableSize > 32);\n        if (nLeaf > (u32)pBt.usableSize / 4 - 2)\n        {\n#if SQLITE_DEBUG || DEBUG\n          rc = SQLITE_CORRUPT_BKPT();\n#else\nrc = SQLITE_CORRUPT_BKPT;\n#endif\n          goto freepage_out;\n        }\n        if (nLeaf < (u32)pBt.usableSize / 4 - 8)\n        {\n          /* In this case there is room on the trunk page to insert the page\n          ** being freed as a new leaf.\n          **\n          ** Note that the trunk page is not really full until it contains\n          ** usableSize/4 - 2 entries, not usableSize/4 - 8 entries as we have\n          ** coded.  But due to a coding error in versions of SQLite prior to\n          ** 3.6.0, databases with freelist trunk pages holding more than\n          ** usableSize/4 - 8 entries will be reported as corrupt.  In order\n          ** to maintain backwards compatibility with older versions of SQLite,\n          ** we will continue to restrict the number of entries to usableSize/4 - 8\n          ** for now.  At some point in the future (once everyone has upgraded\n          ** to 3.6.0 or later) we should consider fixing the conditional above\n          ** to read "usableSize/4-2" instead of "usableSize/4-8".\n          */\n          rc = sqlite3PagerWrite(pTrunk.pDbPage);\n          if (rc == SQLITE_OK)\n          {\n            sqlite3Put4byte(pTrunk.aData, (u32)4, nLeaf + 1);\n            sqlite3Put4byte(pTrunk.aData, (u32)8 + nLeaf * 4, iPage);\n#if !SQLITE_SECURE_DELETE\n            if (pPage != null)\n            {\n              sqlite3PagerDontWrite(pPage.pDbPage);\n            }\n#endif\n            rc = btreeSetHasContent(pBt, iPage);\n          }\n          TRACE("FREE-PAGE: %d leaf on trunk page %d\\n", iPage, pTrunk.pgno);\n          goto freepage_out;\n        }\n      }\n\n      /* If control flows to this point, then it was not possible to add the\n      ** the page being freed as a leaf page of the first trunk in the free-list.\n      ** Possibly because the free-list is empty, or possibly because the\n      ** first trunk in the free-list is full. Either way, the page being freed\n      ** will become the new first trunk page in the free-list.\n      */\n      if (pPage == null && SQLITE_OK != (rc = btreeGetPage(pBt, iPage, ref pPage, 0)))\n      {\n        goto freepage_out;\n      }\n      rc = sqlite3PagerWrite(pPage.pDbPage);\n      if (rc != SQLITE_OK)\n      {\n        goto freepage_out;\n      }\n      sqlite3Put4byte(pPage.aData, iTrunk);\n      sqlite3Put4byte(pPage.aData, 4, 0);\n      sqlite3Put4byte(pPage1.aData, (u32)32, iPage);\n      TRACE("FREE-PAGE: %d new trunk page replacing %d\\n", pPage.pgno, iTrunk);\n\n    freepage_out:\n      if (pPage != null)\n      {\n        pPage.isInit = 0;\n      }\n      releasePage(pPage);\n      releasePage(pTrunk);\n      return rc;\n    }\n    static void freePage(MemPage pPage, ref int pRC)\n    {\n      if ((pRC) == SQLITE_OK)\n      {\n        pRC = freePage2(pPage.pBt, pPage, pPage.pgno);\n      }\n    }\n\n    /*\n    ** Free any overflow pages associated with the given Cell.\n    */\n    static int clearCell(MemPage pPage, int pCell)\n    {\n      BtShared pBt = pPage.pBt;\n      CellInfo info = new CellInfo();\n      Pgno ovflPgno;\n      int rc;\n      int nOvfl;\n      u16 ovflPageSize;\n\n      Debug.Assert(sqlite3_mutex_held(pPage.pBt.mutex));\n      btreeParseCellPtr( pPage, pCell, ref info );\n      if (info.iOverflow == 0)\n      {\n        return SQLITE_OK;  /* No overflow pages. Return without doing anything */\n      }\n      ovflPgno = sqlite3Get4byte(pPage.aData, pCell, info.iOverflow);\n      Debug.Assert(pBt.usableSize > 4);\n      ovflPageSize = (u16)(pBt.usableSize - 4);\n      nOvfl = (int)((info.nPayload - info.nLocal + ovflPageSize - 1) / ovflPageSize);\n      Debug.Assert(ovflPgno == 0 || nOvfl > 0);\n      while (nOvfl-- != 0)\n      {\n        Pgno iNext = 0;\n        MemPage pOvfl = null;\n        if (ovflPgno < 2 || ovflPgno > pagerPagecount(pBt))\n        {\n          /* 0 is not a legal page number and page 1 cannot be an\n          ** overflow page. Therefore if ovflPgno<2 or past the end of the\n          ** file the database must be corrupt. */\n#if SQLITE_DEBUG || DEBUG\n          return SQLITE_CORRUPT_BKPT();\n#else\nreturn SQLITE_CORRUPT_BKPT;\n#endif\n        }\n        if (nOvfl != 0)\n        {\n          rc = getOverflowPage(pBt, ovflPgno, ref pOvfl, ref iNext);\n          if (rc != 0) return rc;\n        }\n        rc = freePage2(pBt, pOvfl, ovflPgno);\n        if (pOvfl != null)\n        {\n          sqlite3PagerUnref(pOvfl.pDbPage);\n        }\n        if (rc != 0) return rc;\n        ovflPgno = iNext;\n      }\n      return SQLITE_OK;\n    }\n\n    /*\n    ** Create the byte sequence used to represent a cell on page pPage\n    ** and write that byte sequence into pCell[].  Overflow pages are\n    ** allocated and filled in as necessary.  The calling procedure\n    ** is responsible for making sure sufficient space has been allocated\n    ** for pCell[].\n    **\n    ** Note that pCell does not necessary need to point to the pPage.aData\n    ** area.  pCell might point to some temporary storage.  The cell will\n    ** be constructed in this temporary area then copied into pPage.aData\n    ** later.\n    */\n    static int fillInCell(\n    MemPage pPage,            /* The page that contains the cell */\n    byte[] pCell,             /* Complete text of the cell */\n    byte[] pKey, i64 nKey,    /* The key */\n    byte[] pData, int nData,  /* The data */\n    int nZero,                /* Extra zero bytes to append to pData */\n    ref int pnSize            /* Write cell size here */\n    )\n    {\n      int nPayload;\n      u8[] pSrc; int pSrcIndex = 0;\n      int nSrc, n, rc;\n      int spaceLeft;\n      MemPage pOvfl = null;\n      MemPage pToRelease = null;\n      byte[] pPrior; int pPriorIndex = 0;\n      byte[] pPayload; int pPayloadIndex = 0;\n      BtShared pBt = pPage.pBt;\n      Pgno pgnoOvfl = 0;\n      int nHeader;\n      CellInfo info = new CellInfo();\n\n      Debug.Assert(sqlite3_mutex_held(pPage.pBt.mutex));\n\n      /* pPage is not necessarily writeable since pCell might be auxiliary\n      ** buffer space that is separate from the pPage buffer area */\n      // TODO -- Determine if the following Assert is needed under c#\n      //Debug.Assert( pCell < pPage.aData || pCell >= &pPage.aData[pBt.pageSize]\n      //          || sqlite3PagerIswriteable(pPage.pDbPage) );\n\n      /* Fill in the header. */\n      nHeader = 0;\n      if (0 == pPage.leaf)\n      {\n        nHeader += 4;\n      }\n      if (pPage.hasData != 0)\n      {\n        nHeader += (int)putVarint(pCell, nHeader, (int)(nData + nZero)); //putVarint( pCell[nHeader], nData + nZero );\n      }\n      else\n      {\n        nData = nZero = 0;\n      }\n      nHeader += putVarint(pCell, nHeader, (u64)nKey); //putVarint( pCell[nHeader], *(u64*)&nKey );\n      btreeParseCellPtr( pPage, pCell, ref info );\n      Debug.Assert(info.nHeader == nHeader);\n      Debug.Assert(info.nKey == nKey);\n      Debug.Assert(info.nData == (u32)(nData + nZero));\n\n      /* Fill in the payload */\n      nPayload = nData + nZero;\n      if (pPage.intKey != 0)\n      {\n        pSrc = pData;\n        nSrc = nData;\n        nData = 0;\n      }\n      else\n      {\n        if (NEVER(nKey > 0x7fffffff || pKey == null))\n        {\n#if SQLITE_DEBUG || DEBUG\n          return SQLITE_CORRUPT_BKPT();\n#else\nreturn SQLITE_CORRUPT_BKPT;\n#endif\n        }\n        nPayload += (int)nKey;\n        pSrc = pKey;\n        nSrc = (int)nKey;\n      }\n      pnSize = info.nSize;\n      spaceLeft = info.nLocal;\n      //  pPayload = &pCell[nHeader];\n      pPayload = pCell;\n      pPayloadIndex = nHeader;\n      //  pPrior = &pCell[info.iOverflow];\n      pPrior = pCell;\n      pPriorIndex = info.iOverflow;\n\n      while (nPayload > 0)\n      {\n        if (spaceLeft == 0)\n        {\n#if !SQLITE_OMIT_AUTOVACUUM\n          Pgno pgnoPtrmap = pgnoOvfl; /* Overflow page pointer-map entry page */\n          if (pBt.autoVacuum)\n          {\n            do\n            {\n              pgnoOvfl++;\n            } while (\n            PTRMAP_ISPAGE(pBt, pgnoOvfl) || pgnoOvfl == PENDING_BYTE_PAGE(pBt)\n            );\n          }\n#endif\n          rc = allocateBtreePage(pBt, ref pOvfl, ref pgnoOvfl, pgnoOvfl, 0);\n#if !SQLITE_OMIT_AUTOVACUUM\n          /* If the database supports auto-vacuum, and the second or subsequent\n** overflow page is being allocated, add an entry to the pointer-map\n** for that page now.\n**\n** If this is the first overflow page, then write a partial entry\n** to the pointer-map. If we write nothing to this pointer-map slot,\n** then the optimistic overflow chain processing in clearCell()\n** may misinterpret the uninitialised values and delete the\n** wrong pages from the database.\n*/\n          if (pBt.autoVacuum && rc == SQLITE_OK)\n          {\n            u8 eType = (u8)(pgnoPtrmap != 0 ? PTRMAP_OVERFLOW2 : PTRMAP_OVERFLOW1);\n            ptrmapPut(pBt, pgnoOvfl, eType, pgnoPtrmap, ref rc);\n            if (rc != 0)\n            {\n              releasePage(pOvfl);\n            }\n          }\n#endif\n          if (rc != 0)\n          {\n            releasePage(pToRelease);\n            return rc;\n          }\n\n          /* If pToRelease is not zero than pPrior points into the data area\n          ** of pToRelease.  Make sure pToRelease is still writeable. */\n          Debug.Assert(pToRelease == null || sqlite3PagerIswriteable(pToRelease.pDbPage));\n\n          /* If pPrior is part of the data area of pPage, then make sure pPage\n          ** is still writeable */\n          // TODO -- Determine if the following Assert is needed under c#\n          //Debug.Assert( pPrior < pPage.aData || pPrior >= &pPage.aData[pBt.pageSize]\n          //      || sqlite3PagerIswriteable(pPage.pDbPage) );\n\n          sqlite3Put4byte(pPrior, pPriorIndex, pgnoOvfl);\n          releasePage(pToRelease);\n          pToRelease = pOvfl;\n          pPrior = pOvfl.aData; pPriorIndex = 0;\n          sqlite3Put4byte(pPrior, 0);\n          pPayload = pOvfl.aData; pPayloadIndex = 4; //&pOvfl.aData[4];\n          spaceLeft = pBt.usableSize - 4;\n        }\n        n = nPayload;\n        if (n > spaceLeft) n = spaceLeft;\n\n        /* If pToRelease is not zero than pPayload points into the data area\n        ** of pToRelease.  Make sure pToRelease is still writeable. */\n        Debug.Assert(pToRelease == null || sqlite3PagerIswriteable(pToRelease.pDbPage));\n\n        /* If pPayload is part of the data area of pPage, then make sure pPage\n        ** is still writeable */\n        // TODO -- Determine if the following Assert is needed under c#\n        //Debug.Assert( pPayload < pPage.aData || pPayload >= &pPage.aData[pBt.pageSize]\n        //        || sqlite3PagerIswriteable(pPage.pDbPage) );\n\n        if (nSrc > 0)\n        {\n          if (n > nSrc) n = nSrc;\n          Debug.Assert(pSrc != null);\n          Buffer.BlockCopy(pSrc, pSrcIndex, pPayload, pPayloadIndex, n);//memcpy(pPayload, pSrc, n);\n        }\n        else\n        {\n          byte[] pZeroBlob = new byte[n]; // memset(pPayload, 0, n);\n          Buffer.BlockCopy(pZeroBlob, 0, pPayload, pPayloadIndex, n);\n        }\n        nPayload -= n;\n        pPayloadIndex += n;// pPayload += n;\n        pSrcIndex += n;// pSrc += n;\n        nSrc -= n;\n        spaceLeft -= n;\n        if (nSrc == 0)\n        {\n          nSrc = nData;\n          pSrc = pData;\n        }\n      }\n      releasePage(pToRelease);\n      return SQLITE_OK;\n    }\n\n    /*\n    ** Remove the i-th cell from pPage.  This routine effects pPage only.\n    ** The cell content is not freed or deallocated.  It is assumed that\n    ** the cell content has been copied someplace else.  This routine just\n    ** removes the reference to the cell from pPage.\n    **\n    ** "sz" must be the number of bytes in the cell.\n    */\n    static void dropCell(MemPage pPage, int idx, int sz, ref int pRC)\n    {\n      int i;          /* Loop counter */\n      int pc;         /* Offset to cell content of cell being deleted */\n      u8[] data;      /* pPage.aData */\n      int ptr;        /* Used to move bytes around within data[] */\n      int rc;         /* The return code */\n      int hdr;        /* Beginning of the header.  0 most pages.  100 page 1 */\n\n      if (pRC != 0) return;\n\n      Debug.Assert(idx >= 0 && idx < pPage.nCell);\n      Debug.Assert(sz == cellSize(pPage, idx));\n      Debug.Assert(sqlite3PagerIswriteable(pPage.pDbPage));\n      Debug.Assert(sqlite3_mutex_held(pPage.pBt.mutex));\n      data = pPage.aData;\n      ptr = pPage.cellOffset + 2 * idx; //ptr = &data[pPage.cellOffset + 2 * idx];\n      pc = get2byte(data, ptr);\n      hdr = pPage.hdrOffset;\n      testcase(pc == get2byte(data, hdr + 5));\n      testcase(pc + sz == pPage.pBt.usableSize);\n      if (pc < get2byte(data, hdr + 5) || pc + sz > pPage.pBt.usableSize)\n      {\n#if SQLITE_DEBUG || DEBUG\n        pRC = SQLITE_CORRUPT_BKPT();\n#else\npRC = SQLITE_CORRUPT_BKPT;\n#endif\n\n        return;\n      }\n      rc = freeSpace(pPage, pc, sz);\n      if (rc != 0)\n      {\n        pRC = rc;\n        return;\n      }\n      //for ( i = idx + 1 ; i < pPage.nCell ; i++, ptr += 2 )\n      //{\n      //  ptr[0] = ptr[2];\n      //  ptr[1] = ptr[3];\n      //}\n      Buffer.BlockCopy(data, ptr + 2, data, ptr, (pPage.nCell - 1 - idx) * 2);\n      pPage.nCell--;\n      data[pPage.hdrOffset + 3] = (byte)(pPage.nCell >> 8); data[pPage.hdrOffset + 4] = (byte)(pPage.nCell); //put2byte( data, hdr + 3, pPage.nCell );\n      pPage.nFree += 2;\n    }\n\n    /*\n    ** Insert a new cell on pPage at cell index "i".  pCell points to the\n    ** content of the cell.\n    **\n    ** If the cell content will fit on the page, then put it there.  If it\n    ** will not fit, then make a copy of the cell content into pTemp if\n    ** pTemp is not null.  Regardless of pTemp, allocate a new entry\n    ** in pPage.aOvfl[] and make it point to the cell content (either\n    ** in pTemp or the original pCell) and also record its index.\n    ** Allocating a new entry in pPage.aCell[] implies that\n    ** pPage.nOverflow is incremented.\n    **\n    ** If nSkip is non-zero, then do not copy the first nSkip bytes of the\n    ** cell. The caller will overwrite them after this function returns. If\n    ** nSkip is non-zero, then pCell may not point to an invalid memory location\n    ** (but pCell+nSkip is always valid).\n    */\n    static void insertCell(\n    MemPage pPage,      /* Page into which we are copying */\n    int i,              /* New cell becomes the i-th cell of the page */\n    u8[] pCell,         /* Content of the new cell */\n    int sz,             /* Bytes of content in pCell */\n    u8[] pTemp,         /* Temp storage space for pCell, if needed */\n    Pgno iChild,        /* If non-zero, replace first 4 bytes with this value */\n    ref int pRC         /* Read and write return code from here */\n    )\n    {\n      int idx = 0;      /* Where to write new cell content in data[] */\n      int j;            /* Loop counter */\n      int end;          /* First byte past the last cell pointer in data[] */\n      int ins;          /* Index in data[] where new cell pointer is inserted */\n      int cellOffset;   /* Address of first cell pointer in data[] */\n      u8[] data;        /* The content of the whole page */\n      u8 ptr;           /* Used for moving information around in data[] */\n\n      int nSkip = (iChild != 0 ? 4 : 0);\n\n      if (pRC != 0) return;\n\n      Debug.Assert(i >= 0 && i <= pPage.nCell + pPage.nOverflow);\n      Debug.Assert(pPage.nCell <= MX_CELL(pPage.pBt) && MX_CELL(pPage.pBt) <= 5460);\n      Debug.Assert(pPage.nOverflow <= ArraySize(pPage.aOvfl));\n      Debug.Assert(sz == cellSizePtr(pPage, pCell));\n      Debug.Assert(sqlite3_mutex_held(pPage.pBt.mutex));\n      if (pPage.nOverflow != 0 || sz + 2 > pPage.nFree)\n      {\n        if (pTemp != null)\n        {\n          Buffer.BlockCopy(pCell, nSkip, pTemp, nSkip, sz - nSkip);//memcpy(pTemp+nSkip, pCell+nSkip, sz-nSkip);\n          pCell = pTemp;\n        }\n        if (iChild != 0)\n        {\n          sqlite3Put4byte(pCell, iChild);\n        }\n        j = pPage.nOverflow++;\n        Debug.Assert(j < pPage.aOvfl.Length);//(int)(sizeof(pPage.aOvfl)/sizeof(pPage.aOvfl[0])) );\n        pPage.aOvfl[j].pCell = pCell;\n        pPage.aOvfl[j].idx = (u16)i;\n      }\n      else\n      {\n        int rc = sqlite3PagerWrite(pPage.pDbPage);\n        if (rc != SQLITE_OK)\n        {\n          pRC = rc;\n          return;\n        }\n        Debug.Assert(sqlite3PagerIswriteable(pPage.pDbPage));\n        data = pPage.aData;\n        cellOffset = pPage.cellOffset;\n        end = cellOffset + 2 * pPage.nCell;\n        ins = cellOffset + 2 * i;\n        rc = allocateSpace(pPage, sz, ref idx);\n        if (rc != 0) { pRC = rc; return; }\n        /* The allocateSpace() routine guarantees the following two properties\n        ** if it returns success */\n        Debug.Assert(idx >= end + 2);\n        Debug.Assert(idx + sz <= pPage.pBt.usableSize);\n        pPage.nCell++;\n        pPage.nFree -= (u16)(2 + sz);\n        Buffer.BlockCopy(pCell, nSkip, data, idx + nSkip, sz - nSkip); //memcpy( data[idx + nSkip], pCell + nSkip, sz - nSkip );\n        if (iChild != 0)\n        {\n          sqlite3Put4byte(data, idx, iChild);\n        }\n        //for(j=end, ptr=&data[j]; j>ins; j-=2, ptr-=2){\n        //  ptr[0] = ptr[-2];\n        //  ptr[1] = ptr[-1];\n        //}\n        for (j = end  ; j > ins; j -= 2)\n        {\n          data[j + 0] = data[j - 2];\n          data[j + 1] = data[j - 1];\n        }\n        put2byte(data, ins, idx);\n        put2byte(data, pPage.hdrOffset + 3, pPage.nCell);\n#if !SQLITE_OMIT_AUTOVACUUM\n        if (pPage.pBt.autoVacuum)\n        {\n          /* The cell may contain a pointer to an overflow page. If so, write\n          ** the entry for the overflow page into the pointer map.\n          */\n          ptrmapPutOvflPtr(pPage, pCell, ref pRC);\n        }\n#endif\n      }\n    }\n\n    /*\n    ** Add a list of cells to a page.  The page should be initially empty.\n    ** The cells are guaranteed to fit on the page.\n    */\n    static void assemblePage(\n    MemPage pPage,    /* The page to be assemblied */\n    int nCell,        /* The number of cells to add to this page */\n    u8[] apCell,      /* Pointer to a single the cell bodies */\n    int[] aSize       /* Sizes of the cells bodie*/\n    )\n    {\n      int i;            /* Loop counter */\n      int pCellptr;     /* Address of next cell pointer */\n      int cellbody;     /* Address of next cell body */\n      byte[] data = pPage.aData;          /* Pointer to data for pPage */\n      int hdr = pPage.hdrOffset;          /* Offset of header on pPage */\n      int nUsable = pPage.pBt.usableSize; /* Usable size of page */\n\n      Debug.Assert(pPage.nOverflow == 0);\n      Debug.Assert(sqlite3_mutex_held(pPage.pBt.mutex));\n      Debug.Assert(nCell >= 0 && nCell <= MX_CELL(pPage.pBt) && MX_CELL(pPage.pBt) <= 5460);\n      Debug.Assert(sqlite3PagerIswriteable(pPage.pDbPage));\n\n      /* Check that the page has just been zeroed by zeroPage() */\n      Debug.Assert(pPage.nCell == 0);\n      Debug.Assert(get2byte(data, hdr + 5) == nUsable);\n\n      pCellptr = pPage.cellOffset + nCell * 2; //data[pPage.cellOffset + nCell * 2];\n      cellbody = nUsable;\n      for (i = nCell - 1; i >= 0; i--)\n      {\n        pCellptr -= 2;\n        cellbody -= aSize[i];\n        put2byte(data, pCellptr, cellbody);\n        Buffer.BlockCopy(apCell, 0, data, cellbody, aSize[i]);//          memcpy(data[cellbody], apCell[i], aSize[i]);\n      }\n      put2byte(data, hdr + 3, nCell);\n      put2byte(data, hdr + 5, cellbody);\n      pPage.nFree -= (u16)(nCell * 2 + nUsable - cellbody);\n      pPage.nCell = (u16)nCell;\n    }\n    static void assemblePage(\n    MemPage pPage,    /* The page to be assemblied */\n    int nCell,        /* The number of cells to add to this page */\n    u8[][] apCell,    /* Pointers to cell bodies */\n    u16[] aSize,      /* Sizes of the cells */\n    int offset        /* Offset into the cell bodies, for c#  */\n    )\n    {\n      int i;            /* Loop counter */\n      int pCellptr;      /* Address of next cell pointer */\n      int cellbody;     /* Address of next cell body */\n      byte[] data = pPage.aData;          /* Pointer to data for pPage */\n      int hdr = pPage.hdrOffset;          /* Offset of header on pPage */\n      int nUsable = pPage.pBt.usableSize; /* Usable size of page */\n\n      Debug.Assert(pPage.nOverflow == 0);\n      Debug.Assert(sqlite3_mutex_held(pPage.pBt.mutex));\n      Debug.Assert(nCell >= 0 && nCell <= MX_CELL(pPage.pBt) && MX_CELL(pPage.pBt) <= 5460);\n      Debug.Assert(sqlite3PagerIswriteable(pPage.pDbPage));\n\n      /* Check that the page has just been zeroed by zeroPage() */\n      Debug.Assert(pPage.nCell == 0);\n      Debug.Assert(get2byte(data, hdr + 5) == nUsable);\n\n      pCellptr = pPage.cellOffset + nCell * 2; //data[pPage.cellOffset + nCell * 2];\n      cellbody = nUsable;\n      for (i = nCell - 1; i >= 0; i--)\n      {\n        pCellptr -= 2;\n        cellbody -= aSize[i + offset];\n        put2byte(data, pCellptr, cellbody);\n        Buffer.BlockCopy(apCell[offset + i], 0, data, cellbody, aSize[i + offset]);//          memcpy(&data[cellbody], apCell[i], aSize[i]);\n      }\n      put2byte(data, hdr + 3, nCell);\n      put2byte(data, hdr + 5, cellbody);\n      pPage.nFree -= (u16)(nCell * 2 + nUsable - cellbody);\n      pPage.nCell = (u16)nCell;\n    }\n\n    static void assemblePage(\n    MemPage pPage,    /* The page to be assemblied */\n    int nCell,        /* The number of cells to add to this page */\n    u8[] apCell,      /* Pointers to cell bodies */\n    u16[] aSize       /* Sizes of the cells */\n    )\n    {\n      int i;            /* Loop counter */\n      int pCellptr;     /* Address of next cell pointer */\n      int cellbody;     /* Address of next cell body */\n      u8[] data = pPage.aData;             /* Pointer to data for pPage */\n      int hdr = pPage.hdrOffset;           /* Offset of header on pPage */\n      int nUsable = pPage.pBt.usableSize; /* Usable size of page */\n\n      Debug.Assert(pPage.nOverflow == 0);\n      Debug.Assert(sqlite3_mutex_held(pPage.pBt.mutex));\n      Debug.Assert(nCell >= 0 && nCell <= MX_CELL(pPage.pBt) && MX_CELL(pPage.pBt) <= 5460);\n      Debug.Assert(sqlite3PagerIswriteable(pPage.pDbPage));\n\n      /* Check that the page has just been zeroed by zeroPage() */\n      Debug.Assert(pPage.nCell == 0);\n      Debug.Assert(get2byte(data, hdr + 5) == nUsable);\n\n      pCellptr = pPage.cellOffset + nCell * 2; //&data[pPage.cellOffset + nCell * 2];\n      cellbody = nUsable;\n      for (i = nCell - 1; i >= 0; i--)\n      {\n        pCellptr -= 2;\n        cellbody -= aSize[i];\n        put2byte(data, pCellptr, cellbody);\n        Buffer.BlockCopy(apCell, 0, data, cellbody, aSize[i]);//memcpy( data[cellbody], apCell[i], aSize[i] );\n      }\n      put2byte(data, hdr + 3, nCell);\n      put2byte(data, hdr + 5, cellbody);\n      pPage.nFree -= (u16)(nCell * 2 + nUsable - cellbody);\n      pPage.nCell = (u16)nCell;\n    }\n\n    /*\n    ** The following parameters determine how many adjacent pages get involved\n    ** in a balancing operation.  NN is the number of neighbors on either side\n    ** of the page that participate in the balancing operation.  NB is the\n    ** total number of pages that participate, including the target page and\n    ** NN neighbors on either side.\n    **\n    ** The minimum value of NN is 1 (of course).  Increasing NN above 1\n    ** (to 2 or 3) gives a modest improvement in SELECT and DELETE performance\n    ** in exchange for a larger degradation in INSERT and UPDATE performance.\n    ** The value of NN appears to give the best results overall.\n    */\n    public const int NN = 1;              /* Number of neighbors on either side of pPage */\n    public const int NB = (NN * 2 + 1);   /* Total pages involved in the balance */\n\n#if !SQLITE_OMIT_QUICKBALANCE\n    /*\n** This version of balance() handles the common special case where\n** a new entry is being inserted on the extreme right-end of the\n** tree, in other words, when the new entry will become the largest\n** entry in the tree.\n**\n** Instead of trying to balance the 3 right-most leaf pages, just add\n** a new page to the right-hand side and put the one new entry in\n** that page.  This leaves the right side of the tree somewhat\n** unbalanced.  But odds are that we will be inserting new entries\n** at the end soon afterwards so the nearly empty page will quickly\n** fill up.  On average.\n**\n** pPage is the leaf page which is the right-most page in the tree.\n** pParent is its parent.  pPage must have a single overflow entry\n** which is also the right-most entry on the page.\n**\n** The pSpace buffer is used to store a temporary copy of the divider\n** cell that will be inserted into pParent. Such a cell consists of a 4\n** byte page number followed by a variable length integer. In other\n** words, at most 13 bytes. Hence the pSpace buffer must be at\n** least 13 bytes in size.\n*/\n    static int balance_quick(MemPage pParent, MemPage pPage, u8[] pSpace)\n    {\n      BtShared pBt = pPage.pBt;    /* B-Tree Database */\n      MemPage pNew = new MemPage();/* Newly allocated page */\n      int rc;                      /* Return Code */\n      Pgno pgnoNew = 0;              /* Page number of pNew */\n\n      Debug.Assert(sqlite3_mutex_held(pPage.pBt.mutex));\n      Debug.Assert(sqlite3PagerIswriteable(pParent.pDbPage));\n      Debug.Assert(pPage.nOverflow == 1);\n\n      if (pPage.nCell <= 0)\n#if SQLITE_DEBUG || DEBUG\n        return SQLITE_CORRUPT_BKPT();\n#else\nreturn SQLITE_CORRUPT_BKPT;\n#endif\n\n      /* Allocate a new page. This page will become the right-sibling of\n** pPage. Make the parent page writable, so that the new divider cell\n** may be inserted. If both these operations are successful, proceed.\n*/\n      rc = allocateBtreePage(pBt, ref pNew, ref pgnoNew, 0, 0);\n\n      if (rc == SQLITE_OK)\n      {\n\n        int pOut = 4;//u8 pOut = &pSpace[4];\n        u8[] pCell = pPage.aOvfl[0].pCell;\n        int[] szCell = new int[1]; szCell[0] = cellSizePtr(pPage, pCell);\n        int pStop;\n\n        Debug.Assert(sqlite3PagerIswriteable(pNew.pDbPage));\n        Debug.Assert(pPage.aData[0] == (PTF_INTKEY | PTF_LEAFDATA | PTF_LEAF));\n        zeroPage(pNew, PTF_INTKEY | PTF_LEAFDATA | PTF_LEAF);\n        assemblePage(pNew, 1, pCell, szCell);\n\n        /* If this is an auto-vacuum database, update the pointer map\n        ** with entries for the new page, and any pointer from the\n        ** cell on the page to an overflow page. If either of these\n        ** operations fails, the return code is set, but the contents\n        ** of the parent page are still manipulated by thh code below.\n        ** That is Ok, at this point the parent page is guaranteed to\n        ** be marked as dirty. Returning an error code will cause a\n        ** rollback, undoing any changes made to the parent page.\n        */\n#if !SQLITE_OMIT_AUTOVACUUM //   if ( ISAUTOVACUUM )\n        if (pBt.autoVacuum)\n#else\nif (false)\n#endif\n        {\n          ptrmapPut(pBt, pgnoNew, PTRMAP_BTREE, pParent.pgno, ref rc);\n          if (szCell[0] > pNew.minLocal)\n          {\n            ptrmapPutOvflPtr(pNew, pCell, ref rc);\n          }\n        }\n\n        /* Create a divider cell to insert into pParent. The divider cell\n        ** consists of a 4-byte page number (the page number of pPage) and\n        ** a variable length key value (which must be the same value as the\n        ** largest key on pPage).\n        **\n        ** To find the largest key value on pPage, first find the right-most\n        ** cell on pPage. The first two fields of this cell are the\n        ** record-length (a variable length integer at most 32-bits in size)\n        ** and the key value (a variable length integer, may have any value).\n        ** The first of the while(...) loops below skips over the record-length\n        ** field. The second while(...) loop copies the key value from the\n        ** cell on pPage into the pSpace buffer.\n        */\n        int iCell = findCell(pPage, pPage.nCell - 1); //pCell = findCell( pPage, pPage.nCell - 1 );\n        pCell = pPage.aData;\n        int _pCell = iCell;\n        pStop = _pCell + 9; //pStop = &pCell[9];\n        while (((pCell[_pCell++]) & 0x80) != 0 && _pCell < pStop) ; //while ( ( *( pCell++ ) & 0x80 ) && pCell < pStop ) ;\n        pStop = _pCell + 9;//pStop = &pCell[9];\n        while (((pSpace[pOut++] = pCell[_pCell++]) & 0x80) != 0 && _pCell < pStop) ; //while ( ( ( *( pOut++ ) = *( pCell++ ) ) & 0x80 ) && pCell < pStop ) ;\n\n        /* Insert the new divider cell into pParent. */\n        insertCell(pParent, pParent.nCell, pSpace, pOut, //(int)(pOut-pSpace),\n        null, pPage.pgno, ref rc);\n\n        /* Set the right-child pointer of pParent to point to the new page. */\n        sqlite3Put4byte(pParent.aData, pParent.hdrOffset + 8, pgnoNew);\n\n        /* Release the reference to the new page. */\n        releasePage(pNew);\n      }\n\n      return rc;\n    }\n#endif //* SQLITE_OMIT_QUICKBALANCE */\n\n#if FALSE\n/*\n** This function does not contribute anything to the operation of SQLite.\n** it is sometimes activated temporarily while debugging code responsible\n** for setting pointer-map entries.\n*/\nstatic int ptrmapCheckPages(MemPage **apPage, int nPage){\nint i, j;\nfor(i=0; i<nPage; i++){\nPgno n;\nu8 e;\nMemPage pPage = apPage[i];\nBtShared pBt = pPage.pBt;\nDebug.Assert( pPage.isInit!=0 );\n\nfor(j=0; j<pPage.nCell; j++){\nCellInfo info;\nu8 *z;\n\nz = findCell(pPage, j);\nbtreeParseCellPtr(pPage, z,  info);\nif( info.iOverflow ){\nPgno ovfl = sqlite3Get4byte(z[info.iOverflow]);\nptrmapGet(pBt, ovfl, ref e, ref n);\nDebug.Assert( n==pPage.pgno && e==PTRMAP_OVERFLOW1 );\n}\nif( 0==pPage.leaf ){\nPgno child = sqlite3Get4byte(z);\nptrmapGet(pBt, child, ref e, ref n);\nDebug.Assert( n==pPage.pgno && e==PTRMAP_BTREE );\n}\n}\nif( 0==pPage.leaf ){\nPgno child = sqlite3Get4byte(pPage.aData,pPage.hdrOffset+8]);\nptrmapGet(pBt, child, ref e, ref n);\nDebug.Assert( n==pPage.pgno && e==PTRMAP_BTREE );\n}\n}\nreturn 1;\n}\n#endif\n\n    /*\n** This function is used to copy the contents of the b-tree node stored\n** on page pFrom to page pTo. If page pFrom was not a leaf page, then\n** the pointer-map entries for each child page are updated so that the\n** parent page stored in the pointer map is page pTo. If pFrom contained\n** any cells with overflow page pointers, then the corresponding pointer\n** map entries are also updated so that the parent page is page pTo.\n**\n** If pFrom is currently carrying any overflow cells (entries in the\n** MemPage.aOvfl[] array), they are not copied to pTo.\n**\n** Before returning, page pTo is reinitialized using btreeInitPage().\n**\n** The performance of this function is not critical. It is only used by\n** the balance_shallower() and balance_deeper() procedures, neither of\n** which are called often under normal circumstances.\n*/\n    static void copyNodeContent(MemPage pFrom, MemPage pTo, ref int pRC)\n    {\n      if ((pRC) == SQLITE_OK)\n      {\n        BtShared pBt = pFrom.pBt;\n        u8[] aFrom = pFrom.aData;\n        u8[] aTo = pTo.aData;\n        int iFromHdr = pFrom.hdrOffset;\n        int iToHdr = ((pTo.pgno == 1) ? 100 : 0);\n#if !NDEBUG || SQLITE_COVERAGE_TEST || DEBUG\n        int rc;//    TESTONLY(int rc;)\n#else\nint rc=0;\n#endif\n        int iData;\n\n\n        Debug.Assert(pFrom.isInit != 0);\n        Debug.Assert(pFrom.nFree >= iToHdr);\n        Debug.Assert(get2byte(aFrom, iFromHdr + 5) <= pBt.usableSize);\n\n        /* Copy the b-tree node content from page pFrom to page pTo. */\n        iData = get2byte(aFrom, iFromHdr + 5);\n        Buffer.BlockCopy(aFrom, iData, aTo, iData, pBt.usableSize - iData);//memcpy(aTo[iData], ref aFrom[iData], pBt.usableSize-iData);\n        Buffer.BlockCopy(aFrom, iFromHdr, aTo, iToHdr, pFrom.cellOffset + 2 * pFrom.nCell);//memcpy(aTo[iToHdr], ref aFrom[iFromHdr], pFrom.cellOffset + 2*pFrom.nCell);\n\n        /* Reinitialize page pTo so that the contents of the MemPage structure\n        ** match the new data. The initialization of pTo "cannot" fail, as the\n        ** data copied from pFrom is known to be valid.  */\n        pTo.isInit = 0;\n#if !NDEBUG || SQLITE_COVERAGE_TEST || DEBUG\n        rc = btreeInitPage(pTo);//TESTONLY(rc = ) btreeInitPage(pTo);\n#else\nbtreeInitPage(pTo);\n#endif\n        Debug.Assert(rc == SQLITE_OK);\n\n        /* If this is an auto-vacuum database, update the pointer-map entries\n        ** for any b-tree or overflow pages that pTo now contains the pointers to.\n        */\n#if !SQLITE_OMIT_AUTOVACUUM //   if ( ISAUTOVACUUM )\n        if (pBt.autoVacuum)\n#else\nif (false)\n#endif\n        {\n          pRC = setChildPtrmaps(pTo);\n        }\n      }\n    }\n\n    /*\n    ** This routine redistributes cells on the iParentIdx\'th child of pParent\n    ** (hereafter "the page") and up to 2 siblings so that all pages have about the\n    ** same amount of free space. Usually a single sibling on either side of the\n    ** page are used in the balancing, though both siblings might come from one\n    ** side if the page is the first or last child of its parent. If the page\n    ** has fewer than 2 siblings (something which can only happen if the page\n    ** is a root page or a child of a root page) then all available siblings\n    ** participate in the balancing.\n    **\n    ** The number of siblings of the page might be increased or decreased by\n    ** one or two in an effort to keep pages nearly full but not over full.\n    **\n    ** Note that when this routine is called, some of the cells on the page\n    ** might not actually be stored in MemPage.aData[]. This can happen\n    ** if the page is overfull. This routine ensures that all cells allocated\n    ** to the page and its siblings fit into MemPage.aData[] before returning.\n    **\n    ** In the course of balancing the page and its siblings, cells may be\n    ** inserted into or removed from the parent page (pParent). Doing so\n    ** may cause the parent page to become overfull or underfull. If this\n    ** happens, it is the responsibility of the caller to invoke the correct\n    ** balancing routine to fix this problem (see the balance() routine).\n    **\n    ** If this routine fails for any reason, it might leave the database\n    ** in a corrupted state. So if this routine fails, the database should\n    ** be rolled back.\n    **\n    ** The third argument to this function, aOvflSpace, is a pointer to a\n    ** buffer big enough to hold one page. If while inserting cells into the parent\n    ** page (pParent) the parent page becomes overfull, this buffer is\n    ** used to store the parent\'s overflow cells. Because this function inserts\n    ** a maximum of four divider cells into the parent page, and the maximum\n    ** size of a cell stored within an internal node is always less than 1/4\n    ** of the page-size, the aOvflSpace[] buffer is guaranteed to be large\n    ** enough for all overflow cells.\n    **\n    ** If aOvflSpace is set to a null pointer, this function returns\n    ** SQLITE_NOMEM.\n    */\n    static int balance_nonroot(\n    MemPage pParent,               /* Parent page of siblings being balanced */\n    int iParentIdx,                /* Index of "the page" in pParent */\n    u8[] aOvflSpace,               /* page-size bytes of space for parent ovfl */\n    int isRoot                     /* True if pParent is a root-page */\n    )\n    {\n      BtShared pBt;                /* The whole database */\n      int nCell = 0;               /* Number of cells in apCell[] */\n      int nMaxCells = 0;           /* Allocated size of apCell, szCell, aFrom. */\n      int nNew = 0;                /* Number of pages in apNew[] */\n      int nOld;                    /* Number of pages in apOld[] */\n      int i, j, k;                 /* Loop counters */\n      int nxDiv;                   /* Next divider slot in pParent.aCell[] */\n      int rc = SQLITE_OK;          /* The return code */\n      u16 leafCorrection;          /* 4 if pPage is a leaf.  0 if not */\n      int leafData;                /* True if pPage is a leaf of a LEAFDATA tree */\n      int usableSpace;             /* Bytes in pPage beyond the header */\n      int pageFlags;               /* Value of pPage.aData[0] */\n      int subtotal;                /* Subtotal of bytes in cells on one page */\n      //int iSpace1 = 0;             /* First unused byte of aSpace1[] */\n      int iOvflSpace = 0;          /* First unused byte of aOvflSpace[] */\n      int szScratch;               /* Size of scratch memory requested */\n      MemPage[] apOld = new MemPage[NB];    /* pPage and up to two siblings */\n      MemPage[] apCopy = new MemPage[NB];   /* Private copies of apOld[] pages */\n      MemPage[] apNew = new MemPage[NB + 2];/* pPage and up to NB siblings after balancing */\n      int pRight;                  /* Location in parent of right-sibling pointer */\n      int[] apDiv = new int[NB - 1];        /* Divider cells in pParent */\n      int[] cntNew = new int[NB + 2];       /* Index in aCell[] of cell after i-th page */\n      int[] szNew = new int[NB + 2];        /* Combined size of cells place on i-th page */\n      u8[][] apCell = null;                 /* All cells begin balanced */\n      u16[] szCell;                         /* Local size of all cells in apCell[] */\n      //u8[] aSpace1;                         /* Space for copies of dividers cells */\n      Pgno pgno;                   /* Temp var to store a page number in */\n\n      pBt = pParent.pBt;\n      Debug.Assert(sqlite3_mutex_held(pBt.mutex));\n      Debug.Assert(sqlite3PagerIswriteable(pParent.pDbPage));\n\n#if FALSE\nTRACE("BALANCE: begin page %d child of %d\\n", pPage.pgno, pParent.pgno);\n#endif\n\n      /* At this point pParent may have at most one overflow cell. And if\n** this overflow cell is present, it must be the cell with\n** index iParentIdx. This scenario comes about when this function\n** is called (indirectly) from sqlite3BtreeDelete().\n*/\n      Debug.Assert(pParent.nOverflow == 0 || pParent.nOverflow == 1);\n      Debug.Assert(pParent.nOverflow == 0 || pParent.aOvfl[0].idx == iParentIdx);\n\n      //if( !aOvflSpace ){\n      //  return SQLITE_NOMEM;\n      //}\n\n      /* Find the sibling pages to balance. Also locate the cells in pParent\n      ** that divide the siblings. An attempt is made to find NN siblings on\n      ** either side of pPage. More siblings are taken from one side, however,\n      ** if there are fewer than NN siblings on the other side. If pParent\n      ** has NB or fewer children then all children of pParent are taken.\n      **\n      ** This loop also drops the divider cells from the parent page. This\n      ** way, the remainder of the function does not have to deal with any\n      ** overflow cells in the parent page, since if any existed they will\n      ** have already been removed.\n      */\n      i = pParent.nOverflow + pParent.nCell;\n      if (i < 2)\n      {\n        nxDiv = 0;\n        nOld = i + 1;\n      }\n      else\n      {\n        nOld = 3;\n        if (iParentIdx == 0)\n        {\n          nxDiv = 0;\n        }\n        else if (iParentIdx == i)\n        {\n          nxDiv = i - 2;\n        }\n        else\n        {\n          nxDiv = iParentIdx - 1;\n        }\n        i = 2;\n      }\n      if ((i + nxDiv - pParent.nOverflow) == pParent.nCell)\n      {\n        pRight = pParent.hdrOffset + 8; //&pParent.aData[pParent.hdrOffset + 8];\n      }\n      else\n      {\n        pRight = findCell(pParent, i + nxDiv - pParent.nOverflow);\n      }\n      pgno = sqlite3Get4byte(pParent.aData, pRight);\n      while (true)\n      {\n        rc = getAndInitPage(pBt, pgno, ref apOld[i]);\n        if (rc != 0)\n        {\n          apOld = new MemPage[i + 1];//memset(apOld, 0, (i+1)*sizeof(MemPage*));\n          goto balance_cleanup;\n        }\n        nMaxCells += 1 + apOld[i].nCell + apOld[i].nOverflow;\n        if ((i--) == 0) break;\n\n        if (i + nxDiv == pParent.aOvfl[0].idx && pParent.nOverflow != 0)\n        {\n          apDiv[i] = 0;// = pParent.aOvfl[0].pCell;\n          pgno = sqlite3Get4byte(pParent.aOvfl[0].pCell, apDiv[i]);\n          szNew[i] = cellSizePtr(pParent, apDiv[i]);\n          pParent.nOverflow = 0;\n        }\n        else\n        {\n          apDiv[i] = findCell(pParent, i + nxDiv - pParent.nOverflow);\n          pgno = sqlite3Get4byte(pParent.aData, apDiv[i]);\n          szNew[i] = cellSizePtr(pParent, apDiv[i]);\n\n          /* Drop the cell from the parent page. apDiv[i] still points to\n          ** the cell within the parent, even though it has been dropped.\n          ** This is safe because dropping a cell only overwrites the first\n          ** four bytes of it, and this function does not need the first\n          ** four bytes of the divider cell. So the pointer is safe to use\n          ** later on.\n          **\n          ** Unless SQLite is compiled in secure-delete mode. In this case,\n          ** the dropCell() routine will overwrite the entire cell with zeroes.\n          ** In this case, temporarily copy the cell into the aOvflSpace[]\n          ** buffer. It will be copied out again as soon as the aSpace[] buffer\n          ** is allocated.  */\n#if SQLITE_SECURE_DELETE\nmemcpy(aOvflSpace[apDiv[i]-pParent.aData], apDiv[i], szNew[i]);\napDiv[i] = &aOvflSpace[apDiv[i]-pParent.aData];\n#endif\n          dropCell(pParent, i + nxDiv - pParent.nOverflow, szNew[i], ref rc);\n        }\n      }\n\n      /* Make nMaxCells a multiple of 4 in order to preserve 8-byte\n      ** alignment */\n      nMaxCells = (nMaxCells + 3) & ~3;\n\n      /*\n      ** Allocate space for memory structures\n      */\n      //k = pBt.pageSize + ROUND8(sizeof(MemPage));\n      //szScratch =\n      //     nMaxCells*sizeof(u8*)                       /* apCell */\n      //   + nMaxCells*sizeof(u16)                       /* szCell */\n      //   + pBt.pageSize                               /* aSpace1 */\n      //   + k*nOld;                                     /* Page copies (apCopy) */\n      apCell = new byte[nMaxCells][];//apCell = sqlite3ScratchMalloc( szScratch );\n      //if( apCell==null ){\n      //  rc = SQLITE_NOMEM;\n      //  goto balance_cleanup;\n      //}\n      szCell = new u16[nMaxCells];//(u16*)&apCell[nMaxCells];\n      //aSpace1 = new byte[pBt.pageSize * (nMaxCells)];//  aSpace1 = (u8*)&szCell[nMaxCells];\n      //Debug.Assert( EIGHT_BYTE_ALIGNMENT(aSpace1) );\n\n      /*\n      ** Load pointers to all cells on sibling pages and the divider cells\n      ** into the local apCell[] array.  Make copies of the divider cells\n      ** into space obtained from aSpace1[] and remove the the divider Cells\n      ** from pParent.\n      **\n      ** If the siblings are on leaf pages, then the child pointers of the\n      ** divider cells are stripped from the cells before they are copied\n      ** into aSpace1[].  In this way, all cells in apCell[] are without\n      ** child pointers.  If siblings are not leaves, then all cell in\n      ** apCell[] include child pointers.  Either way, all cells in apCell[]\n      ** are alike.\n      **\n      ** leafCorrection:  4 if pPage is a leaf.  0 if pPage is not a leaf.\n      **       leafData:  1 if pPage holds key+data and pParent holds only keys.\n      */\n      leafCorrection = (u16)(apOld[0].leaf * 4);\n      leafData = apOld[0].hasData;\n      for (i = 0; i < nOld; i++)\n      {\n        int limit;\n\n        /* Before doing anything else, take a copy of the i\'th original sibling\n        ** The rest of this function will use data from the copies rather\n        ** that the original pages since the original pages will be in the\n        ** process of being overwritten.  */\n        //MemPage pOld = apCopy[i] = (MemPage*)&aSpace1[pBt.pageSize + k*i];\n        //memcpy(pOld, apOld[i], sizeof(MemPage));\n        //pOld.aData = (void*)&pOld[1];\n        //memcpy(pOld.aData, apOld[i].aData, pBt.pageSize);\n        MemPage pOld = apCopy[i] = apOld[i].Copy();\n\n        limit = pOld.nCell + pOld.nOverflow;\n        for (j = 0; j < limit; j++)\n        {\n          Debug.Assert(nCell < nMaxCells);\n          //apCell[nCell] = findOverflowCell( pOld, j );\n          //szCell[nCell] = cellSizePtr( pOld, apCell, nCell );\n          int iFOFC = findOverflowCell(pOld, j);\n          szCell[nCell] = cellSizePtr(pOld, iFOFC);\n          // Copy the Data Locally\n          apCell[nCell] = new u8[szCell[nCell]];\n          if (iFOFC < 0)  // Overflow Cell\n            Buffer.BlockCopy(pOld.aOvfl[-(iFOFC + 1)].pCell, 0, apCell[nCell], 0, szCell[nCell]);\n          else\n            Buffer.BlockCopy(pOld.aData, iFOFC, apCell[nCell], 0, szCell[nCell]);\n          nCell++;\n        }\n        if (i < nOld - 1 && 0 == leafData)\n        {\n          u16 sz = (u16)szNew[i];\n          byte[] pTemp = new byte[sz + leafCorrection];\n          Debug.Assert(nCell < nMaxCells);\n          szCell[nCell] = sz;\n          //pTemp = &aSpace1[iSpace1];\n          //iSpace1 += sz;\n          Debug.Assert(sz <= pBt.pageSize / 4);\n          //Debug.Assert(iSpace1 <= pBt.pageSize);\n          Buffer.BlockCopy(pParent.aData, apDiv[i], pTemp, 0, sz);//memcpy( pTemp, apDiv[i], sz );\n          apCell[nCell] = new byte[sz];\n          Buffer.BlockCopy(pTemp, leafCorrection, apCell[nCell], 0, sz);//apCell[nCell] = pTemp + leafCorrection;\n          Debug.Assert(leafCorrection == 0 || leafCorrection == 4);\n          szCell[nCell] = (u16)(szCell[nCell] - leafCorrection);\n          if (0 == pOld.leaf)\n          {\n            Debug.Assert(leafCorrection == 0);\n            Debug.Assert(pOld.hdrOffset == 0);\n            /* The right pointer of the child page pOld becomes the left\n            ** pointer of the divider cell */\n            Buffer.BlockCopy(pOld.aData, 8, apCell[nCell], 0, 4);//memcpy( apCell[nCell], ref pOld.aData[8], 4 );\n          }\n          else\n          {\n            Debug.Assert(leafCorrection == 4);\n            if (szCell[nCell] < 4)\n            {\n              /* Do not allow any cells smaller than 4 bytes. */\n              szCell[nCell] = 4;\n            }\n          }\n          nCell++;\n        }\n      }\n\n      /*\n      ** Figure out the number of pages needed to hold all nCell cells.\n      ** Store this number in "k".  Also compute szNew[] which is the total\n      ** size of all cells on the i-th page and cntNew[] which is the index\n      ** in apCell[] of the cell that divides page i from page i+1.\n      ** cntNew[k] should equal nCell.\n      **\n      ** Values computed by this block:\n      **\n      **           k: The total number of sibling pages\n      **    szNew[i]: Spaced used on the i-th sibling page.\n      **   cntNew[i]: Index in apCell[] and szCell[] for the first cell to\n      **              the right of the i-th sibling page.\n      ** usableSpace: Number of bytes of space available on each sibling.\n      **\n      */\n      usableSpace = pBt.usableSize - 12 + leafCorrection;\n      for (subtotal = k = i = 0; i < nCell; i++)\n      {\n        Debug.Assert(i < nMaxCells);\n        subtotal += szCell[i] + 2;\n        if (subtotal > usableSpace)\n        {\n          szNew[k] = subtotal - szCell[i];\n          cntNew[k] = i;\n          if (leafData != 0) { i--; }\n          subtotal = 0;\n          k++;\n          if (k > NB + 1) { rc = SQLITE_CORRUPT; goto balance_cleanup; }\n        }\n      }\n      szNew[k] = subtotal;\n      cntNew[k] = nCell;\n      k++;\n\n      /*\n      ** The packing computed by the previous block is biased toward the siblings\n      ** on the left side.  The left siblings are always nearly full, while the\n      ** right-most sibling might be nearly empty.  This block of code attempts\n      ** to adjust the packing of siblings to get a better balance.\n      **\n      ** This adjustment is more than an optimization.  The packing above might\n      ** be so out of balance as to be illegal.  For example, the right-most\n      ** sibling might be completely empty.  This adjustment is not optional.\n      */\n      for (i = k - 1; i > 0; i--)\n      {\n        int szRight = szNew[i];  /* Size of sibling on the right */\n        int szLeft = szNew[i - 1]; /* Size of sibling on the left */\n        int r;              /* Index of right-most cell in left sibling */\n        int d;              /* Index of first cell to the left of right sibling */\n\n        r = cntNew[i - 1] - 1;\n        d = r + 1 - leafData;\n        Debug.Assert(d < nMaxCells);\n        Debug.Assert(r < nMaxCells);\n        while (szRight == 0 || szRight + szCell[d] + 2 <= szLeft - (szCell[r] + 2))\n        {\n          szRight += szCell[d] + 2;\n          szLeft -= szCell[r] + 2;\n          cntNew[i - 1]--;\n          r = cntNew[i - 1] - 1;\n          d = r + 1 - leafData;\n        }\n        szNew[i] = szRight;\n        szNew[i - 1] = szLeft;\n      }\n\n      /* Either we found one or more cells (cntnew[0])>0) or pPage is\n      ** a virtual root page.  A virtual root page is when the real root\n      ** page is page 1 and we are the only child of that page.\n      */\n      Debug.Assert(cntNew[0] > 0 || (pParent.pgno == 1 && pParent.nCell == 0));\n\n      TRACE("BALANCE: old: %d %d %d  ",\n      apOld[0].pgno,\n      nOld >= 2 ? apOld[1].pgno : 0,\n      nOld >= 3 ? apOld[2].pgno : 0\n      );\n\n      /*\n      ** Allocate k new pages.  Reuse old pages where possible.\n      */\n      if (apOld[0].pgno <= 1)\n      {\n        rc = SQLITE_CORRUPT;\n        goto balance_cleanup;\n      }\n      pageFlags = apOld[0].aData[0];\n      for (i = 0; i < k; i++)\n      {\n        MemPage pNew = new MemPage();\n        if (i < nOld)\n        {\n          pNew = apNew[i] = apOld[i];\n          apOld[i] = null;\n          rc = sqlite3PagerWrite(pNew.pDbPage);\n          nNew++;\n          if (rc != 0) goto balance_cleanup;\n        }\n        else\n        {\n          Debug.Assert(i > 0);\n          rc = allocateBtreePage(pBt, ref pNew, ref pgno, pgno, 0);\n          if (rc != 0) goto balance_cleanup;\n          apNew[i] = pNew;\n          nNew++;\n\n          /* Set the pointer-map entry for the new sibling page. */\n#if !SQLITE_OMIT_AUTOVACUUM //   if ( ISAUTOVACUUM )\n          if (pBt.autoVacuum)\n#else\nif (false)\n#endif\n          {\n            ptrmapPut(pBt, pNew.pgno, PTRMAP_BTREE, pParent.pgno, ref rc);\n            if (rc != SQLITE_OK)\n            {\n              goto balance_cleanup;\n            }\n          }\n        }\n      }\n\n      /* Free any old pages that were not reused as new pages.\n      */\n      while (i < nOld)\n      {\n        freePage(apOld[i], ref rc);\n        if (rc != 0) goto balance_cleanup;\n        releasePage(apOld[i]);\n        apOld[i] = null;\n        i++;\n      }\n\n      /*\n      ** Put the new pages in accending order.  This helps to\n      ** keep entries in the disk file in order so that a scan\n      ** of the table is a linear scan through the file.  That\n      ** in turn helps the operating system to deliver pages\n      ** from the disk more rapidly.\n      **\n      ** An O(n^2) insertion sort algorithm is used, but since\n      ** n is never more than NB (a small constant), that should\n      ** not be a problem.\n      **\n      ** When NB==3, this one optimization makes the database\n      ** about 25% faster for large insertions and deletions.\n      */\n      for (i = 0; i < k - 1; i++)\n      {\n        int minV = (int)apNew[i].pgno;\n        int minI = i;\n        for (j = i + 1; j < k; j++)\n        {\n          if (apNew[j].pgno < (u32)minV)\n          {\n            minI = j;\n            minV = (int)apNew[j].pgno;\n          }\n        }\n        if (minI > i)\n        {\n          int t;\n          MemPage pT;\n          t = (int)apNew[i].pgno;\n          pT = apNew[i];\n          apNew[i] = apNew[minI];\n          apNew[minI] = pT;\n        }\n      }\n      TRACE("new: %d(%d) %d(%d) %d(%d) %d(%d) %d(%d)\\n",\n      apNew[0].pgno, szNew[0],\n      nNew >= 2 ? apNew[1].pgno : 0, nNew >= 2 ? szNew[1] : 0,\n      nNew >= 3 ? apNew[2].pgno : 0, nNew >= 3 ? szNew[2] : 0,\n      nNew >= 4 ? apNew[3].pgno : 0, nNew >= 4 ? szNew[3] : 0,\n      nNew >= 5 ? apNew[4].pgno : 0, nNew >= 5 ? szNew[4] : 0);\n\n      Debug.Assert(sqlite3PagerIswriteable(pParent.pDbPage));\n      sqlite3Put4byte(pParent.aData, pRight, apNew[nNew - 1].pgno);\n\n      /*\n      ** Evenly distribute the data in apCell[] across the new pages.\n      ** Insert divider cells into pParent as necessary.\n      */\n      j = 0;\n      for (i = 0; i < nNew; i++)\n      {\n        /* Assemble the new sibling page. */\n        MemPage pNew = apNew[i];\n        Debug.Assert(j < nMaxCells);\n        zeroPage(pNew, pageFlags);\n        assemblePage(pNew, cntNew[i] - j, apCell, szCell, j);\n        Debug.Assert(pNew.nCell > 0 || (nNew == 1 && cntNew[0] == 0));\n        Debug.Assert(pNew.nOverflow == 0);\n\n        j = cntNew[i];\n\n        /* If the sibling page assembled above was not the right-most sibling,\n        ** insert a divider cell into the parent page.\n        */\n        Debug.Assert(i < nNew - 1 || j == nCell);\n        if (j < nCell)\n        {\n          u8[] pCell;\n          u8[] pTemp;\n          int sz;\n\n          Debug.Assert(j < nMaxCells);\n          pCell = apCell[j];\n          sz = szCell[j] + leafCorrection;\n          pTemp = new byte[sz];//&aOvflSpace[iOvflSpace];\n          if (0 == pNew.leaf)\n          {\n            Buffer.BlockCopy(pCell, 0, pNew.aData, 8, 4);//memcpy( pNew.aData[8], pCell, 4 );\n          }\n          else if (leafData != 0)\n          {\n            /* If the tree is a leaf-data tree, and the siblings are leaves,\n            ** then there is no divider cell in apCell[]. Instead, the divider\n            ** cell consists of the integer key for the right-most cell of\n            ** the sibling-page assembled above only.\n            */\n            CellInfo info = new CellInfo();\n            j--;\n            btreeParseCellPtr( pNew, apCell[j], ref info );\n            pCell = pTemp;\n            sz = 4 + putVarint( pCell, 4, (u64)info.nKey );\n            pTemp = null;\n          }\n          else\n          {\n            //------------ pCell -= 4;\n            byte[] _pCell_4 = new byte[pCell.Length + 4];\n            Buffer.BlockCopy(pCell, 0, _pCell_4, 4, pCell.Length);\n            pCell = _pCell_4;\n            //\n            /* Obscure case for non-leaf-data trees: If the cell at pCell was\n            ** previously stored on a leaf node, and its reported size was 4\n            ** bytes, then it may actually be smaller than this\n            ** (see btreeParseCellPtr(), 4 bytes is the minimum size of\n            ** any cell). But it is important to pass the correct size to\n            ** insertCell(), so reparse the cell now.\n            **\n            ** Note that this can never happen in an SQLite data file, as all\n            ** cells are at least 4 bytes. It only happens in b-trees used\n            ** to evaluate "IN (SELECT ...)" and similar clauses.\n            */\n            if (szCell[j] == 4)\n            {\n              Debug.Assert(leafCorrection == 4);\n              sz = cellSizePtr(pParent, pCell);\n            }\n          }\n          iOvflSpace += sz;\n          Debug.Assert(sz <= pBt.pageSize / 4);\n          Debug.Assert(iOvflSpace <= pBt.pageSize);\n          insertCell(pParent, nxDiv, pCell, sz, pTemp, pNew.pgno, ref rc);\n          if (rc != SQLITE_OK) goto balance_cleanup;\n          Debug.Assert(sqlite3PagerIswriteable(pParent.pDbPage));\n\n          j++;\n          nxDiv++;\n        }\n      }\n      Debug.Assert(j == nCell);\n      Debug.Assert(nOld > 0);\n      Debug.Assert(nNew > 0);\n      if ((pageFlags & PTF_LEAF) == 0)\n      {\n        Buffer.BlockCopy(apCopy[nOld - 1].aData, 8, apNew[nNew - 1].aData, 8, 4); //u8* zChild = &apCopy[nOld - 1].aData[8];\n        //memcpy( apNew[nNew - 1].aData[8], zChild, 4 );\n      }\n\n      if (isRoot != 0 && pParent.nCell == 0 && pParent.hdrOffset <= apNew[0].nFree)\n      {\n        /* The root page of the b-tree now contains no cells. The only sibling\n        ** page is the right-child of the parent. Copy the contents of the\n        ** child page into the parent, decreasing the overall height of the\n        ** b-tree structure by one. This is described as the "balance-shallower"\n        ** sub-algorithm in some documentation.\n        **\n        ** If this is an auto-vacuum database, the call to copyNodeContent()\n        ** sets all pointer-map entries corresponding to database image pages\n        ** for which the pointer is stored within the content being copied.\n        **\n        ** The second Debug.Assert below verifies that the child page is defragmented\n        ** (it must be, as it was just reconstructed using assemblePage()). This\n        ** is important if the parent page happens to be page 1 of the database\n        ** image.  */\n        Debug.Assert(nNew == 1);\n        Debug.Assert(apNew[0].nFree ==\n        (get2byte(apNew[0].aData, 5) - apNew[0].cellOffset - apNew[0].nCell * 2)\n        );\n        copyNodeContent(apNew[0], pParent, ref rc);\n        freePage(apNew[0], ref rc);\n      }\n      else\n#if !SQLITE_OMIT_AUTOVACUUM //   if ( ISAUTOVACUUM )\n        if (pBt.autoVacuum)\n#else\nif (false)\n#endif\n        {\n          /* Fix the pointer-map entries for all the cells that were shifted around.\n          ** There are several different types of pointer-map entries that need to\n          ** be dealt with by this routine. Some of these have been set already, but\n          ** many have not. The following is a summary:\n          **\n          **   1) The entries associated with new sibling pages that were not\n          **      siblings when this function was called. These have already\n          **      been set. We don\'t need to worry about old siblings that were\n          **      moved to the free-list - the freePage() code has taken care\n          **      of those.\n          **\n          **   2) The pointer-map entries associated with the first overflow\n          **      page in any overflow chains used by new divider cells. These\n          **      have also already been taken care of by the insertCell() code.\n          **\n          **   3) If the sibling pages are not leaves, then the child pages of\n          **      cells stored on the sibling pages may need to be updated.\n          **\n          **   4) If the sibling pages are not internal intkey nodes, then any\n          **      overflow pages used by these cells may need to be updated\n          **      (internal intkey nodes never contain pointers to overflow pages).\n          **\n          **   5) If the sibling pages are not leaves, then the pointer-map\n          **      entries for the right-child pages of each sibling may need\n          **      to be updated.\n          **\n          ** Cases 1 and 2 are dealt with above by other code. The next\n          ** block deals with cases 3 and 4 and the one after that, case 5. Since\n          ** setting a pointer map entry is a relatively expensive operation, this\n          ** code only sets pointer map entries for child or overflow pages that have\n          ** actually moved between pages.  */\n          MemPage pNew = apNew[0];\n          MemPage pOld = apCopy[0];\n          int nOverflow = pOld.nOverflow;\n          int iNextOld = pOld.nCell + nOverflow;\n          int iOverflow = (nOverflow != 0 ? pOld.aOvfl[0].idx : -1);\n          j = 0;                             /* Current \'old\' sibling page */\n          k = 0;                             /* Current \'new\' sibling page */\n          for (i = 0; i < nCell; i++)\n          {\n            int isDivider = 0;\n            while (i == iNextOld)\n            {\n              /* Cell i is the cell immediately following the last cell on old\n              ** sibling page j. If the siblings are not leaf pages of an\n              ** intkey b-tree, then cell i was a divider cell. */\n              pOld = apCopy[++j];\n              iNextOld = i + (0 == leafData ? 1 : 0) + pOld.nCell + pOld.nOverflow;\n              if (pOld.nOverflow != 0)\n              {\n                nOverflow = pOld.nOverflow;\n                iOverflow = i + (0 == leafData ? 1 : 0 )+ pOld.aOvfl[0].idx;\n              }\n              isDivider = 0 == leafData ? 1 : 0;\n            }\n\n            Debug.Assert(nOverflow > 0 || iOverflow < i);\n            Debug.Assert(nOverflow < 2 || pOld.aOvfl[0].idx == pOld.aOvfl[1].idx - 1);\n            Debug.Assert(nOverflow < 3 || pOld.aOvfl[1].idx == pOld.aOvfl[2].idx - 1);\n            if (i == iOverflow)\n            {\n              isDivider = 1;\n              if ((--nOverflow) > 0)\n              {\n                iOverflow++;\n              }\n            }\n\n            if (i == cntNew[k])\n            {\n              /* Cell i is the cell immediately following the last cell on new\n              ** sibling page k. If the siblings are not leaf pages of an\n              ** intkey b-tree, then cell i is a divider cell.  */\n              pNew = apNew[++k];\n              if (0 == leafData) continue;\n            }\n            Debug.Assert(j < nOld);\n            Debug.Assert(k < nNew);\n\n            /* If the cell was originally divider cell (and is not now) or\n            ** an overflow cell, or if the cell was located on a different sibling\n            ** page before the balancing, then the pointer map entries associated\n            ** with any child or overflow pages need to be updated.  */\n            if (isDivider != 0 || pOld.pgno != pNew.pgno)\n            {\n              if (0 == leafCorrection)\n              {\n                ptrmapPut(pBt, sqlite3Get4byte(apCell[i]), PTRMAP_BTREE, pNew.pgno, ref rc);\n              }\n              if (szCell[i] > pNew.minLocal)\n              {\n                ptrmapPutOvflPtr(pNew, apCell[i], ref rc);\n              }\n            }\n          }\n\n          if (0 == leafCorrection)\n          {\n            for (i = 0; i < nNew; i++)\n            {\n              u32 key = sqlite3Get4byte(apNew[i].aData, 8);\n              ptrmapPut(pBt, key, PTRMAP_BTREE, apNew[i].pgno, ref rc);\n            }\n          }\n\n#if FALSE\n/* The ptrmapCheckPages() contains Debug.Assert() statements that verify that\n** all pointer map pages are set correctly. This is helpful while\n** debugging. This is usually disabled because a corrupt database may\n** cause an Debug.Assert() statement to fail.  */\nptrmapCheckPages(apNew, nNew);\nptrmapCheckPages(pParent, 1);\n#endif\n        }\n\n      Debug.Assert(pParent.isInit != 0);\n      TRACE("BALANCE: finished: old=%d new=%d cells=%d\\n",\n      nOld, nNew, nCell);\n\n    /*\n    ** Cleanup before returning.\n    */\n    balance_cleanup:\n      //sqlite3ScratchFree( ref apCell );\n      for (i = 0; i < nOld; i++)\n      {\n        releasePage(apOld[i]);\n      }\n      for (i = 0; i < nNew; i++)\n      {\n        releasePage(apNew[i]);\n      }\n\n      return rc;\n    }\n\n\n    /*\n    ** This function is called when the root page of a b-tree structure is\n    ** overfull (has one or more overflow pages).\n    **\n    ** A new child page is allocated and the contents of the current root\n    ** page, including overflow cells, are copied into the child. The root\n    ** page is then overwritten to make it an empty page with the right-child\n    ** pointer pointing to the new page.\n    **\n    ** Before returning, all pointer-map entries corresponding to pages\n    ** that the new child-page now contains pointers to are updated. The\n    ** entry corresponding to the new right-child pointer of the root\n    ** page is also updated.\n    **\n    ** If successful, ppChild is set to contain a reference to the child\n    ** page and SQLITE_OK is returned. In this case the caller is required\n    ** to call releasePage() on ppChild exactly once. If an error occurs,\n    ** an error code is returned and ppChild is set to 0.\n    */\n    static int balance_deeper(MemPage pRoot, ref MemPage ppChild)\n    {\n      int rc;                        /* Return value from subprocedures */\n      MemPage pChild = null;           /* Pointer to a new child page */\n      Pgno pgnoChild = 0;            /* Page number of the new child page */\n      BtShared pBt = pRoot.pBt;    /* The BTree */\n\n      Debug.Assert(pRoot.nOverflow > 0);\n      Debug.Assert(sqlite3_mutex_held(pBt.mutex));\n\n      /* Make pRoot, the root page of the b-tree, writable. Allocate a new\n      ** page that will become the new right-child of pPage. Copy the contents\n      ** of the node stored on pRoot into the new child page.\n      */\n      rc = sqlite3PagerWrite(pRoot.pDbPage);\n      if (rc == SQLITE_OK)\n      {\n        rc = allocateBtreePage(pBt, ref pChild, ref pgnoChild, pRoot.pgno, 0);\n        copyNodeContent(pRoot, pChild, ref rc);\n#if !SQLITE_OMIT_AUTOVACUUM //   if ( ISAUTOVACUUM )\n        if (pBt.autoVacuum)\n#else\nif (false)\n#endif\n        {\n          ptrmapPut(pBt, pgnoChild, PTRMAP_BTREE, pRoot.pgno, ref rc);\n        }\n      }\n      if (rc != 0)\n      {\n        ppChild = null;\n        releasePage(pChild);\n        return rc;\n      }\n      Debug.Assert(sqlite3PagerIswriteable(pChild.pDbPage));\n      Debug.Assert(sqlite3PagerIswriteable(pRoot.pDbPage));\n      Debug.Assert(pChild.nCell == pRoot.nCell);\n\n      TRACE("BALANCE: copy root %d into %d\\n", pRoot.pgno, pChild.pgno);\n\n      /* Copy the overflow cells from pRoot to pChild */\n      Array.Copy(pRoot.aOvfl, pChild.aOvfl, pRoot.nOverflow);//memcpy(pChild.aOvfl, pRoot.aOvfl, pRoot.nOverflow*sizeof(pRoot.aOvfl[0]));\n      pChild.nOverflow = pRoot.nOverflow;\n\n      /* Zero the contents of pRoot. Then install pChild as the right-child. */\n      zeroPage(pRoot, pChild.aData[0] & ~PTF_LEAF);\n      sqlite3Put4byte(pRoot.aData, pRoot.hdrOffset + 8, pgnoChild);\n\n      ppChild = pChild;\n      return SQLITE_OK;\n    }\n\n    /*\n    ** The page that pCur currently points to has just been modified in\n    ** some way. This function figures out if this modification means the\n    ** tree needs to be balanced, and if so calls the appropriate balancing\n    ** routine. Balancing routines are:\n    **\n    **   balance_quick()\n    **   balance_deeper()\n    **   balance_nonroot()\n    */\n    static int balance(BtCursor pCur)\n    {\n      int rc = SQLITE_OK;\n      int nMin = pCur.pBt.usableSize * 2 / 3;\n      u8[] aBalanceQuickSpace = new u8[13];\n      u8[] pFree = null;\n\n#if !NDEBUG || SQLITE_COVERAGE_TEST || DEBUG\n      int balance_quick_called = 0;//TESTONLY( int balance_quick_called = 0 );\n      int balance_deeper_called = 0;//TESTONLY( int balance_deeper_called = 0 );\n#else\nint balance_quick_called = 0;\nint balance_deeper_called = 0;\n#endif\n\n      do\n      {\n        int iPage = pCur.iPage;\n        MemPage pPage = pCur.apPage[iPage];\n\n        if (iPage == 0)\n        {\n          if (pPage.nOverflow != 0)\n          {\n            /* The root page of the b-tree is overfull. In this case call the\n            ** balance_deeper() function to create a new child for the root-page\n            ** and copy the current contents of the root-page to it. The\n            ** next iteration of the do-loop will balance the child page.\n            */\n            Debug.Assert((balance_deeper_called++) == 0);\n            rc = balance_deeper(pPage, ref pCur.apPage[1]);\n            if (rc == SQLITE_OK)\n            {\n              pCur.iPage = 1;\n              pCur.aiIdx[0] = 0;\n              pCur.aiIdx[1] = 0;\n              Debug.Assert(pCur.apPage[1].nOverflow != 0);\n            }\n          }\n          else\n          {\n            break;\n          }\n        }\n        else if (pPage.nOverflow == 0 && pPage.nFree <= nMin)\n        {\n          break;\n        }\n        else\n        {\n          MemPage pParent = pCur.apPage[iPage - 1];\n          int iIdx = pCur.aiIdx[iPage - 1];\n\n          rc = sqlite3PagerWrite(pParent.pDbPage);\n          if (rc == SQLITE_OK)\n          {\n#if !SQLITE_OMIT_QUICKBALANCE\n            if (pPage.hasData != 0\n            && pPage.nOverflow == 1\n            && pPage.aOvfl[0].idx == pPage.nCell\n            && pParent.pgno != 1\n            && pParent.nCell == iIdx\n            )\n            {\n              /* Call balance_quick() to create a new sibling of pPage on which\n              ** to store the overflow cell. balance_quick() inserts a new cell\n              ** into pParent, which may cause pParent overflow. If this\n              ** happens, the next interation of the do-loop will balance pParent\n              ** use either balance_nonroot() or balance_deeper(). Until this\n              ** happens, the overflow cell is stored in the aBalanceQuickSpace[]\n              ** buffer.\n              **\n              ** The purpose of the following Debug.Assert() is to check that only a\n              ** single call to balance_quick() is made for each call to this\n              ** function. If this were not verified, a subtle bug involving reuse\n              ** of the aBalanceQuickSpace[] might sneak in.\n              */\n              Debug.Assert((balance_quick_called++) == 0);\n              rc = balance_quick(pParent, pPage, aBalanceQuickSpace);\n            }\n            else\n#endif\n            {\n              /* In this case, call balance_nonroot() to redistribute cells\n              ** between pPage and up to 2 of its sibling pages. This involves\n              ** modifying the contents of pParent, which may cause pParent to\n              ** become overfull or underfull. The next iteration of the do-loop\n              ** will balance the parent page to correct this.\n              **\n              ** If the parent page becomes overfull, the overflow cell or cells\n              ** are stored in the pSpace buffer allocated immediately below.\n              ** A subsequent iteration of the do-loop will deal with this by\n              ** calling balance_nonroot() (balance_deeper() may be called first,\n              ** but it doesn\'t deal with overflow cells - just moves them to a\n              ** different page). Once this subsequent call to balance_nonroot()\n              ** has completed, it is safe to release the pSpace buffer used by\n              ** the previous call, as the overflow cell data will have been\n              ** copied either into the body of a database page or into the new\n              ** pSpace buffer passed to the latter call to balance_nonroot().\n              */\n              u8[] pSpace = new u8[pCur.pBt.pageSize];// u8 pSpace = sqlite3PageMalloc( pCur.pBt.pageSize );\n              rc = balance_nonroot(pParent, iIdx, pSpace, iPage == 1 ? 1 : 0);\n              //if (pFree != null)\n              //{\n              //  /* If pFree is not NULL, it points to the pSpace buffer used\n              //  ** by a previous call to balance_nonroot(). Its contents are\n              //  ** now stored either on real database pages or within the\n              //  ** new pSpace buffer, so it may be safely freed here. */\n              //  sqlite3PageFree(ref pFree);\n              //}\n\n              /* The pSpace buffer will be freed after the next call to\n              ** balance_nonroot(), or just before this function returns, whichever\n              ** comes first. */\n              pFree = pSpace;\n            }\n          }\n\n          pPage.nOverflow = 0;\n\n          /* The next iteration of the do-loop balances the parent page. */\n          releasePage(pPage);\n          pCur.iPage--;\n        }\n      } while (rc == SQLITE_OK);\n\n      //if (pFree != null)\n      //{\n      //  sqlite3PageFree(ref pFree);\n      //}\n      return rc;\n    }\n\n\n    /*\n    ** Insert a new record into the BTree.  The key is given by (pKey,nKey)\n    ** and the data is given by (pData,nData).  The cursor is used only to\n    ** define what table the record should be inserted into.  The cursor\n    ** is left pointing at a random location.\n    **\n    ** For an INTKEY table, only the nKey value of the key is used.  pKey is\n    ** ignored.  For a ZERODATA table, the pData and nData are both ignored.\n    **\n    ** If the seekResult parameter is non-zero, then a successful call to\n    ** MovetoUnpacked() to seek cursor pCur to (pKey, nKey) has already\n    ** been performed. seekResult is the search result returned (a negative\n    ** number if pCur points at an entry that is smaller than (pKey, nKey), or\n    ** a positive value if pCur points at an etry that is larger than\n    ** (pKey, nKey)).\n    **\n    ** If the seekResult parameter is 0, then cursor pCur may point to any\n    ** entry or to no entry at all. In this case this function has to seek\n    ** the cursor before the new key can be inserted.\n    */\n    static int sqlite3BtreeInsert(\n    BtCursor pCur,                /* Insert data into the table of this cursor */\n    byte[] pKey, i64 nKey,        /* The key of the new record */\n    byte[] pData, int nData,      /* The data of the new record */\n    int nZero,                     /* Number of extra 0 bytes to append to data */\n    int appendBias,                /* True if this is likely an append */\n    int seekResult                 /* Result of prior MovetoUnpacked() call */\n    )\n    {\n      int rc;\n      int loc = seekResult;\n      int szNew = 0;\n      int idx;\n      MemPage pPage;\n      Btree p = pCur.pBtree;\n      BtShared pBt = p.pBt;\n      int oldCell;\n      byte[] newCell = null;\n\n      if (pCur.eState == CURSOR_FAULT)\n      {\n        Debug.Assert(pCur.skipNext != SQLITE_OK);\n        return pCur.skipNext;\n      }\n\n      Debug.Assert(cursorHoldsMutex(pCur));\n      Debug.Assert(pCur.wrFlag != 0 && pBt.inTransaction == TRANS_WRITE && !pBt.readOnly);\n      Debug.Assert(hasSharedCacheTableLock(p, pCur.pgnoRoot, pCur.pKeyInfo != null ? 1 : 0, 2));\n\n      /* Assert that the caller has been consistent. If this cursor was opened\n      ** expecting an index b-tree, then the caller should be inserting blob\n      ** keys with no associated data. If the cursor was opened expecting an\n      ** intkey table, the caller should be inserting integer keys with a\n      ** blob of associated data.  */\n      Debug.Assert((pKey == null) == (pCur.pKeyInfo == null));\n\n      /* If this is an insert into a table b-tree, invalidate any incrblob\n      ** cursors open on the row being replaced (assuming this is a replace\n      ** operation - if it is not, the following is a no-op).  */\n      if (pCur.pKeyInfo == null)\n      {\n        invalidateIncrblobCursors(p, nKey, 0);\n      }\n\n      /* Save the positions of any other cursors open on this table.\n      **\n      ** In some cases, the call to btreeMoveto() below is a no-op. For\n      ** example, when inserting data into a table with auto-generated integer\n      ** keys, the VDBE layer invokes sqlite3BtreeLast() to figure out the\n      ** integer key to use. It then calls this function to actually insert the\n      ** data into the intkey B-Tree. In this case btreeMoveto() recognizes\n      ** that the cursor is already where it needs to be and returns without\n      ** doing any work. To avoid thwarting these optimizations, it is important\n      ** not to clear the cursor here.\n      */\n      rc = saveAllCursors(pBt, pCur.pgnoRoot, pCur);\n      if (rc != 0) return rc;\n      if (0 == loc)\n      {\n        rc = btreeMoveto(pCur, pKey, nKey, appendBias, ref loc);\n        if (rc != 0) return rc;\n      }\n      Debug.Assert(pCur.eState == CURSOR_VALID || (pCur.eState == CURSOR_INVALID && loc != 0));\n\n      pPage = pCur.apPage[pCur.iPage];\n      Debug.Assert(pPage.intKey != 0 || nKey >= 0);\n      Debug.Assert(pPage.leaf != 0 || 0 == pPage.intKey);\n\n      TRACE("INSERT: table=%d nkey=%lld ndata=%d page=%d %s\\n",\n      pCur.pgnoRoot, nKey, nData, pPage.pgno,\n      loc == 0 ? "overwrite" : "new entry");\n      Debug.Assert(pPage.isInit != 0);\n      allocateTempSpace(pBt);\n      newCell = pBt.pTmpSpace;\n      //if (newCell == null) return SQLITE_NOMEM;\n      rc = fillInCell(pPage, newCell, pKey, nKey, pData, nData, nZero, ref szNew);\n      if (rc != 0) goto end_insert;\n      Debug.Assert(szNew == cellSizePtr(pPage, newCell));\n      Debug.Assert(szNew <= MX_CELL_SIZE(pBt));\n      idx = pCur.aiIdx[pCur.iPage];\n      if (loc == 0)\n      {\n        u16 szOld;\n        Debug.Assert(idx < pPage.nCell);\n        rc = sqlite3PagerWrite(pPage.pDbPage);\n        if (rc != 0)\n        {\n          goto end_insert;\n        }\n        oldCell = findCell(pPage, idx);\n        if (0 == pPage.leaf)\n        {\n          //memcpy(newCell, oldCell, 4);\n          newCell[0] = pPage.aData[oldCell + 0];\n          newCell[1] = pPage.aData[oldCell + 1];\n          newCell[2] = pPage.aData[oldCell + 2];\n          newCell[3] = pPage.aData[oldCell + 3];\n        }\n        szOld = cellSizePtr(pPage, oldCell);\n        rc = clearCell(pPage, oldCell);\n        dropCell(pPage, idx, szOld, ref rc);\n        if (rc != 0) goto end_insert;\n      }\n      else if (loc < 0 && pPage.nCell > 0)\n      {\n        Debug.Assert(pPage.leaf != 0);\n        idx = ++pCur.aiIdx[pCur.iPage];\n      }\n      else\n      {\n        Debug.Assert(pPage.leaf != 0);\n      }\n      insertCell(pPage, idx, newCell, szNew, null, 0, ref rc);\n      Debug.Assert(rc != SQLITE_OK || pPage.nCell > 0 || pPage.nOverflow > 0);\n\n      /* If no error has occured and pPage has an overflow cell, call balance()\n      ** to redistribute the cells within the tree. Since balance() may move\n      ** the cursor, zero the BtCursor.info.nSize and BtCursor.validNKey\n      ** variables.\n      **\n      ** Previous versions of SQLite called moveToRoot() to move the cursor\n      ** back to the root page as balance() used to invalidate the contents\n      ** of BtCursor.apPage[] and BtCursor.aiIdx[]. Instead of doing that,\n      ** set the cursor state to "invalid". This makes common insert operations\n      ** slightly faster.\n      **\n      ** There is a subtle but important optimization here too. When inserting\n      ** multiple records into an intkey b-tree using a single cursor (as can\n      ** happen while processing an "INSERT INTO ... SELECT" statement), it\n      ** is advantageous to leave the cursor pointing to the last entry in\n      ** the b-tree if possible. If the cursor is left pointing to the last\n      ** entry in the table, and the next row inserted has an integer key\n      ** larger than the largest existing key, it is possible to insert the\n      ** row without seeking the cursor. This can be a big performance boost.\n      */\n      pCur.info.nSize = 0;\n      pCur.validNKey = false;\n      if (rc == SQLITE_OK && pPage.nOverflow != 0)\n      {\n        rc = balance(pCur);\n\n        /* Must make sure nOverflow is reset to zero even if the balance()\n        ** fails. Internal data structure corruption will result otherwise.\n        ** Also, set the cursor state to invalid. This stops saveCursorPosition()\n        ** from trying to save the current position of the cursor.  */\n        pCur.apPage[pCur.iPage].nOverflow = 0;\n        pCur.eState = CURSOR_INVALID;\n      }\n      Debug.Assert(pCur.apPage[pCur.iPage].nOverflow == 0);\n\n    end_insert:\n      return rc;\n    }\n\n    /*\n    ** Delete the entry that the cursor is pointing to.  The cursor\n    ** is left pointing at a arbitrary location.\n    */\n    static int sqlite3BtreeDelete(BtCursor pCur)\n    {\n      Btree p = pCur.pBtree;\n      BtShared pBt = p.pBt;\n      int rc;                             /* Return code */\n      MemPage pPage;                      /* Page to delete cell from */\n      int pCell;                          /* Pointer to cell to delete */\n      int iCellIdx;                       /* Index of cell to delete */\n      int iCellDepth;                     /* Depth of node containing pCell */\n\n      Debug.Assert(cursorHoldsMutex(pCur));\n      Debug.Assert(pBt.inTransaction == TRANS_WRITE);\n      Debug.Assert(!pBt.readOnly);\n      Debug.Assert(pCur.wrFlag != 0);\n      Debug.Assert(hasSharedCacheTableLock(p, pCur.pgnoRoot, pCur.pKeyInfo != null ? 1 : 0, 2));\n      Debug.Assert(!hasReadConflicts(p, pCur.pgnoRoot));\n\n      if (NEVER(pCur.aiIdx[pCur.iPage] >= pCur.apPage[pCur.iPage].nCell)\n      || NEVER(pCur.eState != CURSOR_VALID)\n      )\n      {\n        return SQLITE_ERROR;  /* Something has gone awry. */\n      }\n\n      /* If this is a delete operation to remove a row from a table b-tree,\n      ** invalidate any incrblob cursors open on the row being deleted.  */\n      if (pCur.pKeyInfo == null)\n      {\n        invalidateIncrblobCursors(p, pCur.info.nKey, 0);\n      }\n\n      iCellDepth = pCur.iPage;\n      iCellIdx = pCur.aiIdx[iCellDepth];\n      pPage = pCur.apPage[iCellDepth];\n      pCell = findCell(pPage, iCellIdx);\n\n      /* If the page containing the entry to delete is not a leaf page, move\n      ** the cursor to the largest entry in the tree that is smaller than\n      ** the entry being deleted. This cell will replace the cell being deleted\n      ** from the internal node. The \'previous\' entry is used for this instead\n      ** of the \'next\' entry, as the previous entry is always a part of the\n      ** sub-tree headed by the child page of the cell being deleted. This makes\n      ** balancing the tree following the delete operation easier.  */\n      if (0 == pPage.leaf)\n      {\n        int notUsed = 0;\n        rc = sqlite3BtreePrevious(pCur, ref notUsed);\n        if (rc != 0) return rc;\n      }\n\n      /* Save the positions of any other cursors open on this table before\n      ** making any modifications. Make the page containing the entry to be\n      ** deleted writable. Then free any overflow pages associated with the\n      ** entry and finally remove the cell itself from within the page.\n      */\n      rc = saveAllCursors(pBt, pCur.pgnoRoot, pCur);\n      if (rc != 0) return rc;\n      rc = sqlite3PagerWrite(pPage.pDbPage);\n      if (rc != 0) return rc;\n      rc = clearCell(pPage, pCell);\n      dropCell(pPage, iCellIdx, cellSizePtr(pPage, pCell), ref rc);\n      if (rc != 0) return rc;\n\n      /* If the cell deleted was not located on a leaf page, then the cursor\n      ** is currently pointing to the largest entry in the sub-tree headed\n      ** by the child-page of the cell that was just deleted from an internal\n      ** node. The cell from the leaf node needs to be moved to the internal\n      ** node to replace the deleted cell.  */\n      if (0 == pPage.leaf)\n      {\n        MemPage pLeaf = pCur.apPage[pCur.iPage];\n        int nCell;\n        Pgno n = pCur.apPage[iCellDepth + 1].pgno;\n        //byte[] pTmp;\n\n        pCell = findCell(pLeaf, pLeaf.nCell - 1);\n        nCell = cellSizePtr(pLeaf, pCell);\n        Debug.Assert(MX_CELL_SIZE(pBt) >= nCell);\n\n        //allocateTempSpace(pBt);\n        //pTmp = pBt.pTmpSpace;\n\n        rc = sqlite3PagerWrite(pLeaf.pDbPage);\n        byte[] pNext_4 = new byte[nCell + 4];\n        Buffer.BlockCopy(pLeaf.aData, pCell - 4, pNext_4, 0, nCell + 4);\n        insertCell(pPage, iCellIdx, pNext_4, nCell + 4, null, n, ref rc); //insertCell( pPage, iCellIdx, pCell - 4, nCell + 4, pTmp, n, ref rc );\n        dropCell(pLeaf, pLeaf.nCell - 1, nCell, ref rc);\n        if (rc != 0) return rc;\n      }\n\n      /* Balance the tree. If the entry deleted was located on a leaf page,\n      ** then the cursor still points to that page. In this case the first\n      ** call to balance() repairs the tree, and the if(...) condition is\n      ** never true.\n      **\n      ** Otherwise, if the entry deleted was on an internal node page, then\n      ** pCur is pointing to the leaf page from which a cell was removed to\n      ** replace the cell deleted from the internal node. This is slightly\n      ** tricky as the leaf node may be underfull, and the internal node may\n      ** be either under or overfull. In this case run the balancing algorithm\n      ** on the leaf node first. If the balance proceeds far enough up the\n      ** tree that we can be sure that any problem in the internal node has\n      ** been corrected, so be it. Otherwise, after balancing the leaf node,\n      ** walk the cursor up the tree to the internal node and balance it as\n      ** well.  */\n      rc = balance(pCur);\n      if (rc == SQLITE_OK && pCur.iPage > iCellDepth)\n      {\n        while (pCur.iPage > iCellDepth)\n        {\n          releasePage(pCur.apPage[pCur.iPage--]);\n        }\n        rc = balance(pCur);\n      }\n\n      if (rc == SQLITE_OK)\n      {\n        moveToRoot(pCur);\n      }\n      return rc;\n    }\n\n    /*\n    ** Create a new BTree table.  Write into piTable the page\n    ** number for the root page of the new table.\n    **\n    ** The type of type is determined by the flags parameter.  Only the\n    ** following values of flags are currently in use.  Other values for\n    ** flags might not work:\n    **\n    **     BTREE_INTKEY|BTREE_LEAFDATA     Used for SQL tables with rowid keys\n    **     BTREE_ZERODATA                  Used for SQL indices\n    */\n    static int btreeCreateTable(Btree p, ref int piTable, int flags)\n    {\n      BtShared pBt = p.pBt;\n      MemPage pRoot = new MemPage();\n      Pgno pgnoRoot = 0;\n      int rc;\n\n      Debug.Assert(sqlite3BtreeHoldsMutex(p));\n      Debug.Assert(pBt.inTransaction == TRANS_WRITE);\n      Debug.Assert(!pBt.readOnly);\n\n#if SQLITE_OMIT_AUTOVACUUM\nrc = allocateBtreePage(pBt, ref pRoot, ref pgnoRoot, 1, 0);\nif( rc !=0){\nreturn rc;\n}\n#else\n      if (pBt.autoVacuum)\n      {\n        Pgno pgnoMove = 0;                    /* Move a page here to make room for the root-page */\n        MemPage pPageMove = new MemPage();  /* The page to move to. */\n\n        /* Creating a new table may probably require moving an existing database\n        ** to make room for the new tables root page. In case this page turns\n        ** out to be an overflow page, delete all overflow page-map caches\n        ** held by open cursors.\n        */\n        invalidateAllOverflowCache(pBt);\n\n        /* Read the value of meta[3] from the database to determine where the\n        ** root page of the new table should go. meta[3] is the largest root-page\n        ** created so far, so the new root-page is (meta[3]+1).\n        */\n        sqlite3BtreeGetMeta(p, BTREE_LARGEST_ROOT_PAGE, ref pgnoRoot);\n        pgnoRoot++;\n\n        /* The new root-page may not be allocated on a pointer-map page, or the\n        ** PENDING_BYTE page.\n        */\n        while (pgnoRoot == PTRMAP_PAGENO(pBt, pgnoRoot) ||\n        pgnoRoot == PENDING_BYTE_PAGE(pBt))\n        {\n          pgnoRoot++;\n        }\n        Debug.Assert(pgnoRoot >= 3);\n\n        /* Allocate a page. The page that currently resides at pgnoRoot will\n        ** be moved to the allocated page (unless the allocated page happens\n        ** to reside at pgnoRoot).\n        */\n        rc = allocateBtreePage(pBt, ref pPageMove, ref pgnoMove, pgnoRoot, 1);\n        if (rc != SQLITE_OK)\n        {\n          return rc;\n        }\n\n        if (pgnoMove != pgnoRoot)\n        {\n          /* pgnoRoot is the page that will be used for the root-page of\n          ** the new table (assuming an error did not occur). But we were\n          ** allocated pgnoMove. If required (i.e. if it was not allocated\n          ** by extending the file), the current page at position pgnoMove\n          ** is already journaled.\n          */\n          u8 eType = 0;\n          Pgno iPtrPage = 0;\n\n          releasePage(pPageMove);\n\n          /* Move the page currently at pgnoRoot to pgnoMove. */\n          rc = btreeGetPage(pBt, pgnoRoot, ref pRoot, 0);\n          if (rc != SQLITE_OK)\n          {\n            return rc;\n          }\n          rc = ptrmapGet(pBt, pgnoRoot, ref eType, ref iPtrPage);\n          if (eType == PTRMAP_ROOTPAGE || eType == PTRMAP_FREEPAGE)\n          {\n#if SQLITE_DEBUG || DEBUG\n            rc = SQLITE_CORRUPT_BKPT();\n#else\nrc = SQLITE_CORRUPT_BKPT;\n#endif\n          }\n          if (rc != SQLITE_OK)\n          {\n            releasePage(pRoot);\n            return rc;\n          }\n          Debug.Assert(eType != PTRMAP_ROOTPAGE);\n          Debug.Assert(eType != PTRMAP_FREEPAGE);\n          rc = relocatePage(pBt, pRoot, eType, iPtrPage, pgnoMove, 0);\n          releasePage(pRoot);\n\n          /* Obtain the page at pgnoRoot */\n          if (rc != SQLITE_OK)\n          {\n            return rc;\n          }\n          rc = btreeGetPage(pBt, pgnoRoot, ref pRoot, 0);\n          if (rc != SQLITE_OK)\n          {\n            return rc;\n          }\n          rc = sqlite3PagerWrite(pRoot.pDbPage);\n          if (rc != SQLITE_OK)\n          {\n            releasePage(pRoot);\n            return rc;\n          }\n        }\n        else\n        {\n          pRoot = pPageMove;\n        }\n\n        /* Update the pointer-map and meta-data with the new root-page number. */\n        ptrmapPut(pBt, pgnoRoot, PTRMAP_ROOTPAGE, 0, ref rc);\n        if (rc != 0)\n        {\n          releasePage(pRoot);\n          return rc;\n        }\n        rc = sqlite3BtreeUpdateMeta(p, 4, pgnoRoot);\n        if (rc != 0)\n        {\n          releasePage(pRoot);\n          return rc;\n        }\n\n      }\n      else\n      {\n        rc = allocateBtreePage(pBt, ref pRoot, ref pgnoRoot, 1, 0);\n        if (rc != 0) return rc;\n      }\n#endif\n      Debug.Assert(sqlite3PagerIswriteable(pRoot.pDbPage));\n      zeroPage(pRoot, flags | PTF_LEAF);\n      sqlite3PagerUnref(pRoot.pDbPage);\n      piTable = (int)pgnoRoot;\n      return SQLITE_OK;\n    }\n    static int sqlite3BtreeCreateTable(Btree p, ref int piTable, int flags)\n    {\n      int rc;\n      sqlite3BtreeEnter(p);\n      rc = btreeCreateTable(p, ref piTable, flags);\n      sqlite3BtreeLeave(p);\n      return rc;\n    }\n\n    /*\n    ** Erase the given database page and all its children.  Return\n    ** the page to the freelist.\n    */\n    static int clearDatabasePage(\n    BtShared pBt,         /* The BTree that contains the table */\n    Pgno pgno,            /* Page number to clear */\n    int freePageFlag,     /* Deallocate page if true */\n    ref int pnChange\n    )\n    {\n      MemPage pPage = new MemPage();\n      int rc;\n      byte[] pCell;\n      int i;\n\n      Debug.Assert(sqlite3_mutex_held(pBt.mutex));\n      if (pgno > pagerPagecount(pBt))\n      {\n#if SQLITE_DEBUG || DEBUG\n        return SQLITE_CORRUPT_BKPT();\n#else\nreturn SQLITE_CORRUPT_BKPT;\n#endif\n      }\n\n      rc = getAndInitPage(pBt, pgno, ref pPage);\n      if (rc != 0) return rc;\n      for (i = 0; i < pPage.nCell; i++)\n      {\n        int iCell = findCell(pPage, i); pCell = pPage.aData; //        pCell = findCell( pPage, i );\n        if (0 == pPage.leaf)\n        {\n          rc = clearDatabasePage(pBt, sqlite3Get4byte(pCell, iCell), 1, ref pnChange);\n          if (rc != 0) goto cleardatabasepage_out;\n        }\n        rc = clearCell(pPage, iCell);\n        if (rc != 0) goto cleardatabasepage_out;\n      }\n      if (0 == pPage.leaf)\n      {\n        rc = clearDatabasePage(pBt, sqlite3Get4byte(pPage.aData, 8), 1, ref pnChange);\n        if (rc != 0) goto cleardatabasepage_out;\n      }\n      else //if (pnChange != 0)\n      {\n        //Debug.Assert(pPage.intKey != 0);\n        pnChange += pPage.nCell;\n      }\n      if (freePageFlag != 0)\n      {\n        freePage(pPage, ref rc);\n      }\n      else if ((rc = sqlite3PagerWrite(pPage.pDbPage)) == 0)\n      {\n        zeroPage(pPage, pPage.aData[0] | PTF_LEAF);\n      }\n\n    cleardatabasepage_out:\n      releasePage(pPage);\n      return rc;\n    }\n\n    /*\n    ** Delete all information from a single table in the database.  iTable is\n    ** the page number of the root of the table.  After this routine returns,\n    ** the root page is empty, but still exists.\n    **\n    ** This routine will fail with SQLITE_LOCKED if there are any open\n    ** read cursors on the table.  Open write cursors are moved to the\n    ** root of the table.\n    **\n    ** If pnChange is not NULL, then table iTable must be an intkey table. The\n    ** integer value pointed to by pnChange is incremented by the number of\n    ** entries in the table.\n    */\n    static int sqlite3BtreeClearTable(Btree p, int iTable, ref int pnChange)\n    {\n      int rc;\n      BtShared pBt = p.pBt;\n      sqlite3BtreeEnter(p);\n      Debug.Assert(p.inTrans == TRANS_WRITE);\n\n      /* Invalidate all incrblob cursors open on table iTable (assuming iTable\n      ** is the root of a table b-tree - if it is not, the following call is\n      ** a no-op).  */\n      invalidateIncrblobCursors(p, 0, 1);\n\n      rc = saveAllCursors(pBt, (Pgno)iTable, null);\n      if (SQLITE_OK == rc)\n      {\n        rc = clearDatabasePage(pBt, (Pgno)iTable, 0, ref pnChange);\n      }\n      sqlite3BtreeLeave(p);\n      return rc;\n    }\n\n    /*\n    ** Erase all information in a table and add the root of the table to\n    ** the freelist.  Except, the root of the principle table (the one on\n    ** page 1) is never added to the freelist.\n    **\n    ** This routine will fail with SQLITE_LOCKED if there are any open\n    ** cursors on the table.\n    **\n    ** If AUTOVACUUM is enabled and the page at iTable is not the last\n    ** root page in the database file, then the last root page\n    ** in the database file is moved into the slot formerly occupied by\n    ** iTable and that last slot formerly occupied by the last root page\n    ** is added to the freelist instead of iTable.  In this say, all\n    ** root pages are kept at the beginning of the database file, which\n    ** is necessary for AUTOVACUUM to work right.  piMoved is set to the\n    ** page number that used to be the last root page in the file before\n    ** the move.  If no page gets moved, piMoved is set to 0.\n    ** The last root page is recorded in meta[3] and the value of\n    ** meta[3] is updated by this procedure.\n    */\n    static int btreeDropTable(Btree p, Pgno iTable, ref int piMoved)\n    {\n      int rc;\n      MemPage pPage = null;\n      BtShared pBt = p.pBt;\n\n      Debug.Assert(sqlite3BtreeHoldsMutex(p));\n      Debug.Assert(p.inTrans == TRANS_WRITE);\n\n      /* It is illegal to drop a table if any cursors are open on the\n      ** database. This is because in auto-vacuum mode the backend may\n      ** need to move another root-page to fill a gap left by the deleted\n      ** root page. If an open cursor was using this page a problem would\n      ** occur.\n      **\n      ** This error is caught long before control reaches this point.\n      */\n      if (NEVER(pBt.pCursor))\n      {\n        sqlite3ConnectionBlocked(p.db, pBt.pCursor.pBtree.db);\n        return SQLITE_LOCKED_SHAREDCACHE;\n      }\n\n      rc = btreeGetPage(pBt, (Pgno)iTable, ref pPage, 0);\n      if (rc != 0) return rc;\n      int Dummy0 = 0; rc = sqlite3BtreeClearTable(p, (int)iTable, ref Dummy0);\n      if (rc != 0)\n      {\n        releasePage(pPage);\n        return rc;\n      }\n\n      piMoved = 0;\n\n      if (iTable > 1)\n      {\n#if SQLITE_OMIT_AUTOVACUUM\nfreePage(pPage, ref rc);\nreleasePage(pPage);\n#else\n        if (pBt.autoVacuum)\n        {\n          Pgno maxRootPgno = 0;\n          sqlite3BtreeGetMeta(p, BTREE_LARGEST_ROOT_PAGE, ref maxRootPgno);\n\n          if (iTable == maxRootPgno)\n          {\n            /* If the table being dropped is the table with the largest root-page\n            ** number in the database, put the root page on the free list.\n            */\n            freePage(pPage, ref rc);\n            releasePage(pPage);\n            if (rc != SQLITE_OK)\n            {\n              return rc;\n            }\n          }\n          else\n          {\n            /* The table being dropped does not have the largest root-page\n            ** number in the database. So move the page that does into the\n            ** gap left by the deleted root-page.\n            */\n            MemPage pMove = new MemPage();\n            releasePage(pPage);\n            rc = btreeGetPage(pBt, maxRootPgno, ref pMove, 0);\n            if (rc != SQLITE_OK)\n            {\n              return rc;\n            }\n            rc = relocatePage(pBt, pMove, PTRMAP_ROOTPAGE, 0, iTable, 0);\n            releasePage(pMove);\n            if (rc != SQLITE_OK)\n            {\n              return rc;\n            }\n            pMove = null;\n            rc = btreeGetPage(pBt, maxRootPgno, ref pMove, 0);\n            freePage(pMove, ref rc);\n            releasePage(pMove);\n            if (rc != SQLITE_OK)\n            {\n              return rc;\n            }\n            piMoved = (int)maxRootPgno;\n          }\n\n          /* Set the new \'max-root-page\' value in the database header. This\n          ** is the old value less one, less one more if that happens to\n          ** be a root-page number, less one again if that is the\n          ** PENDING_BYTE_PAGE.\n          */\n          maxRootPgno--;\n          while (maxRootPgno == PENDING_BYTE_PAGE(pBt)\n          || PTRMAP_ISPAGE(pBt, maxRootPgno))\n          {\n            maxRootPgno--;\n          }\n          Debug.Assert(maxRootPgno != PENDING_BYTE_PAGE(pBt));\n\n          rc = sqlite3BtreeUpdateMeta(p, 4, maxRootPgno);\n        }\n        else\n        {\n          freePage(pPage, ref rc);\n          releasePage(pPage);\n        }\n#endif\n      }\n      else\n      {\n        /* If sqlite3BtreeDropTable was called on page 1.\n        ** This really never should happen except in a corrupt\n        ** database.\n        */\n        zeroPage(pPage, PTF_INTKEY | PTF_LEAF);\n        releasePage(pPage);\n      }\n      return rc;\n    }\n    static int sqlite3BtreeDropTable(Btree p, int iTable, ref int piMoved)\n    {\n      int rc;\n      sqlite3BtreeEnter(p);\n      rc = btreeDropTable(p, (u32)iTable, ref piMoved);\n      sqlite3BtreeLeave(p);\n      return rc;\n    }\n\n\n    /*\n    ** This function may only be called if the b-tree connection already\n    ** has a read or write transaction open on the database.\n    **\n    ** Read the meta-information out of a database file.  Meta[0]\n    ** is the number of free pages currently in the database.  Meta[1]\n    ** through meta[15] are available for use by higher layers.  Meta[0]\n    ** is read-only, the others are read/write.\n    **\n    ** The schema layer numbers meta values differently.  At the schema\n    ** layer (and the SetCookie and ReadCookie opcodes) the number of\n    ** free pages is not visible.  So Cookie[0] is the same as Meta[1].\n    */\n    static void sqlite3BtreeGetMeta(Btree p, int idx, ref u32 pMeta)\n    {\n      BtShared pBt = p.pBt;\n\n      sqlite3BtreeEnter(p);\n      Debug.Assert(p.inTrans > TRANS_NONE);\n      Debug.Assert(SQLITE_OK == querySharedCacheTableLock(p, MASTER_ROOT, READ_LOCK));\n      Debug.Assert(pBt.pPage1 != null);\n      Debug.Assert(idx >= 0 && idx <= 15);\n\n      pMeta = sqlite3Get4byte(pBt.pPage1.aData, 36 + idx * 4);\n\n      /* If auto-vacuum is disabled in this build and this is an auto-vacuum\n      ** database, mark the database as read-only.  */\n#if SQLITE_OMIT_AUTOVACUUM\nif( idx==BTREE_LARGEST_ROOT_PAGE && pMeta>0 ) pBt.readOnly = 1;\n#endif\n\n      sqlite3BtreeLeave(p);\n    }\n\n    /*\n    ** Write meta-information back into the database.  Meta[0] is\n    ** read-only and may not be written.\n    */\n    static int sqlite3BtreeUpdateMeta(Btree p, int idx, u32 iMeta)\n    {\n      BtShared pBt = p.pBt;\n      byte[] pP1;\n      int rc;\n      Debug.Assert(idx >= 1 && idx <= 15);\n      sqlite3BtreeEnter(p);\n      Debug.Assert(p.inTrans == TRANS_WRITE);\n      Debug.Assert(pBt.pPage1 != null);\n      pP1 = pBt.pPage1.aData;\n      rc = sqlite3PagerWrite(pBt.pPage1.pDbPage);\n      if (rc == SQLITE_OK)\n      {\n        sqlite3Put4byte(pP1, 36 + idx * 4, iMeta);\n#if !SQLITE_OMIT_AUTOVACUUM\n        if (idx == BTREE_INCR_VACUUM)\n        {\n          Debug.Assert(pBt.autoVacuum || iMeta == 0);\n          Debug.Assert(iMeta == 0 || iMeta == 1);\n          pBt.incrVacuum = iMeta != 0;\n        }\n#endif\n      }\n      sqlite3BtreeLeave(p);\n      return rc;\n    }\n\n#if !SQLITE_OMIT_BTREECOUNT\n    /*\n** The first argument, pCur, is a cursor opened on some b-tree. Count the\n** number of entries in the b-tree and write the result to pnEntry.\n**\n** SQLITE_OK is returned if the operation is successfully executed.\n** Otherwise, if an error is encountered (i.e. an IO error or database\n** corruption) an SQLite error code is returned.\n*/\n    static int sqlite3BtreeCount(BtCursor pCur, ref i64 pnEntry)\n    {\n      i64 nEntry = 0;                      /* Value to return in pnEntry */\n      int rc;                              /* Return code */\n      rc = moveToRoot(pCur);\n\n      /* Unless an error occurs, the following loop runs one iteration for each\n      ** page in the B-Tree structure (not including overflow pages).\n      */\n      while (rc == SQLITE_OK)\n      {\n        int iIdx;                          /* Index of child node in parent */\n        MemPage pPage;                    /* Current page of the b-tree */\n\n        /* If this is a leaf page or the tree is not an int-key tree, then\n        ** this page contains countable entries. Increment the entry counter\n        ** accordingly.\n        */\n        pPage = pCur.apPage[pCur.iPage];\n        if (pPage.leaf != 0 || 0 == pPage.intKey)\n        {\n          nEntry += pPage.nCell;\n        }\n\n        /* pPage is a leaf node. This loop navigates the cursor so that it\n        ** points to the first interior cell that it points to the parent of\n        ** the next page in the tree that has not yet been visited. The\n        ** pCur.aiIdx[pCur.iPage] value is set to the index of the parent cell\n        ** of the page, or to the number of cells in the page if the next page\n        ** to visit is the right-child of its parent.\n        **\n        ** If all pages in the tree have been visited, return SQLITE_OK to the\n        ** caller.\n        */\n        if (pPage.leaf != 0)\n        {\n          do\n          {\n            if (pCur.iPage == 0)\n            {\n              /* All pages of the b-tree have been visited. Return successfully. */\n              pnEntry = nEntry;\n              return SQLITE_OK;\n            }\n            moveToParent(pCur);\n          } while (pCur.aiIdx[pCur.iPage] >= pCur.apPage[pCur.iPage].nCell);\n\n          pCur.aiIdx[pCur.iPage]++;\n          pPage = pCur.apPage[pCur.iPage];\n        }\n\n        /* Descend to the child node of the cell that the cursor currently\n        ** points at. This is the right-child if (iIdx==pPage.nCell).\n        */\n        iIdx = pCur.aiIdx[pCur.iPage];\n        if (iIdx == pPage.nCell)\n        {\n          rc = moveToChild(pCur, sqlite3Get4byte(pPage.aData, pPage.hdrOffset + 8));\n        }\n        else\n        {\n          rc = moveToChild(pCur, sqlite3Get4byte(pPage.aData, findCell(pPage, iIdx)));\n        }\n      }\n\n      /* An error has occurred. Return an error code. */\n      return rc;\n    }\n#endif\n\n    /*\n** Return the pager associated with a BTree.  This routine is used for\n** testing and debugging only.\n*/\n    static Pager sqlite3BtreePager(Btree p)\n    {\n      return p.pBt.pPager;\n    }\n\n#if !SQLITE_OMIT_INTEGRITY_CHECK\n    /*\n** Append a message to the error message string.\n*/\n    static void checkAppendMsg(\n    IntegrityCk pCheck,\n    string zMsg1,\n    string zFormat,\n    params object[] ap\n    )\n    {\n      //va_list ap;\n      if (0 == pCheck.mxErr) return;\n      pCheck.mxErr--;\n      pCheck.nErr++;\n      va_start(ap, zFormat);\n      if (pCheck.errMsg.nChar != 0)\n      {\n        sqlite3StrAccumAppend(pCheck.errMsg, "\\n", 1);\n      }\n      if (!String.IsNullOrEmpty(zMsg1))\n      {\n        sqlite3StrAccumAppend(pCheck.errMsg, zMsg1, -1);\n      }\n      sqlite3VXPrintf(pCheck.errMsg, 1, zFormat, ap);\n      va_end(ap);\n      //if( pCheck.errMsg.mallocFailed ){\n      //  pCheck.mallocFailed = 1;\n      //}\n    }\n#endif //* SQLITE_OMIT_INTEGRITY_CHECK */\n\n#if !SQLITE_OMIT_INTEGRITY_CHECK\n    /*\n** Add 1 to the reference count for page iPage.  If this is the second\n** reference to the page, add an error message to pCheck.zErrMsg.\n** Return 1 if there are 2 ore more references to the page and 0 if\n** if this is the first reference to the page.\n**\n** Also check that the page number is in bounds.\n*/\n    static int checkRef(IntegrityCk pCheck, Pgno iPage, string zContext)\n    {\n      if (iPage == 0) return 1;\n      if (iPage > pCheck.nPage)\n      {\n        checkAppendMsg(pCheck, zContext, "invalid page number %d", iPage);\n        return 1;\n      }\n      if (pCheck.anRef[iPage] == 1)\n      {\n        checkAppendMsg(pCheck, zContext, "2nd reference to page %d", iPage);\n        return 1;\n      }\n      return ((pCheck.anRef[iPage]++) > 1) ? 1 : 0;\n    }\n\n#if !SQLITE_OMIT_AUTOVACUUM\n    /*\n** Check that the entry in the pointer-map for page iChild maps to\n** page iParent, pointer type ptrType. If not, append an error message\n** to pCheck.\n*/\n    static void checkPtrmap(\n    IntegrityCk pCheck,    /* Integrity check context */\n    Pgno iChild,           /* Child page number */\n    u8 eType,              /* Expected pointer map type */\n    Pgno iParent,          /* Expected pointer map parent page number */\n    string zContext        /* Context description (used for error msg) */\n    )\n    {\n      int rc;\n      u8 ePtrmapType = 0;\n      Pgno iPtrmapParent = 0;\n\n      rc = ptrmapGet(pCheck.pBt, iChild, ref ePtrmapType, ref iPtrmapParent);\n      if (rc != SQLITE_OK)\n      {\n        //if( rc==SQLITE_NOMEM || rc==SQLITE_IOERR_NOMEM ) pCheck.mallocFailed = 1;\n        checkAppendMsg(pCheck, zContext, "Failed to read ptrmap key=%d", iChild);\n        return;\n      }\n\n      if (ePtrmapType != eType || iPtrmapParent != iParent)\n      {\n        checkAppendMsg(pCheck, zContext,\n        "Bad ptr map entry key=%d expected=(%d,%d) got=(%d,%d)",\n        iChild, eType, iParent, ePtrmapType, iPtrmapParent);\n      }\n    }\n#endif\n\n    /*\n** Check the integrity of the freelist or of an overflow page list.\n** Verify that the number of pages on the list is N.\n*/\n    static void checkList(\n    IntegrityCk pCheck,  /* Integrity checking context */\n    int isFreeList,       /* True for a freelist.  False for overflow page list */\n    int iPage,            /* Page number for first page in the list */\n    int N,                /* Expected number of pages in the list */\n    string zContext        /* Context for error messages */\n    )\n    {\n      int i;\n      int expected = N;\n      int iFirst = iPage;\n      while (N-- > 0 && pCheck.mxErr != 0)\n      {\n        DbPage pOvflPage = new PgHdr();\n        byte[] pOvflData;\n        if (iPage < 1)\n        {\n          checkAppendMsg(pCheck, zContext,\n          "%d of %d pages missing from overflow list starting at %d",\n          N + 1, expected, iFirst);\n          break;\n        }\n        if (checkRef(pCheck, (u32)iPage, zContext) != 0) break;\n        if (sqlite3PagerGet(pCheck.pPager, (Pgno)iPage, ref pOvflPage) != 0)\n        {\n          checkAppendMsg(pCheck, zContext, "failed to get page %d", iPage);\n          break;\n        }\n        pOvflData = sqlite3PagerGetData(pOvflPage);\n        if (isFreeList != 0)\n        {\n          int n = (int)sqlite3Get4byte(pOvflData, 4);\n#if !SQLITE_OMIT_AUTOVACUUM\n          if (pCheck.pBt.autoVacuum)\n          {\n            checkPtrmap(pCheck, (u32)iPage, PTRMAP_FREEPAGE, 0, zContext);\n          }\n#endif\n          if (n > pCheck.pBt.usableSize / 4 - 2)\n          {\n            checkAppendMsg(pCheck, zContext,\n            "freelist leaf count too big on page %d", iPage);\n            N--;\n          }\n          else\n          {\n            for (i = 0; i < n; i++)\n            {\n              Pgno iFreePage = sqlite3Get4byte(pOvflData, 8 + i * 4);\n#if !SQLITE_OMIT_AUTOVACUUM\n              if (pCheck.pBt.autoVacuum)\n              {\n                checkPtrmap(pCheck, iFreePage, PTRMAP_FREEPAGE, 0, zContext);\n              }\n#endif\n              checkRef(pCheck, iFreePage, zContext);\n            }\n            N -= n;\n          }\n        }\n#if !SQLITE_OMIT_AUTOVACUUM\n        else\n        {\n          /* If this database supports auto-vacuum and iPage is not the last\n          ** page in this overflow list, check that the pointer-map entry for\n          ** the following page matches iPage.\n          */\n          if (pCheck.pBt.autoVacuum && N > 0)\n          {\n            i = (int)sqlite3Get4byte(pOvflData);\n            checkPtrmap(pCheck, (u32)i, PTRMAP_OVERFLOW2, (u32)iPage, zContext);\n          }\n        }\n#endif\n        iPage = (int)sqlite3Get4byte(pOvflData);\n        sqlite3PagerUnref(pOvflPage);\n      }\n    }\n#endif //* SQLITE_OMIT_INTEGRITY_CHECK */\n\n#if !SQLITE_OMIT_INTEGRITY_CHECK\n    /*\n** Do various sanity checks on a single page of a tree.  Return\n** the tree depth.  Root pages return 0.  Parents of root pages\n** return 1, and so forth.\n**\n** These checks are done:\n**\n**      1.  Make sure that cells and freeblocks do not overlap\n**          but combine to completely cover the page.\n**  NO  2.  Make sure cell keys are in order.\n**  NO  3.  Make sure no key is less than or equal to zLowerBound.\n**  NO  4.  Make sure no key is greater than or equal to zUpperBound.\n**      5.  Check the integrity of overflow pages.\n**      6.  Recursively call checkTreePage on all children.\n**      7.  Verify that the depth of all children is the same.\n**      8.  Make sure this page is at least 33% full or else it is\n**          the root of the tree.\n*/\n    static int checkTreePage(\n    IntegrityCk pCheck,  /* Context for the sanity check */\n    int iPage,            /* Page number of the page to check */\n    string zParentContext  /* Parent context */\n    )\n    {\n      MemPage pPage = new MemPage();\n      int i, rc, depth, d2, pgno, cnt;\n      int hdr, cellStart;\n      int nCell;\n      u8[] data;\n      BtShared pBt;\n      int usableSize;\n      string zContext = "";//[100];\n      byte[] hit = null;\n\n\n      sqlite3_snprintf(200, ref zContext, "Page %d: ", iPage);\n\n      /* Check that the page exists\n      */\n      pBt = pCheck.pBt;\n      usableSize = pBt.usableSize;\n      if (iPage == 0) return 0;\n      if (checkRef(pCheck, (u32)iPage, zParentContext) != 0) return 0;\n      if ((rc = btreeGetPage(pBt, (Pgno)iPage, ref pPage, 0)) != 0)\n      {\n        checkAppendMsg(pCheck, zContext,\n        "unable to get the page. error code=%d", rc);\n        return 0;\n      }\n\n      /* Clear MemPage.isInit to make sure the corruption detection code in\n      ** btreeInitPage() is executed.  */\n      pPage.isInit = 0;\n      if ((rc = btreeInitPage(pPage)) != 0)\n      {\n        Debug.Assert(rc == SQLITE_CORRUPT);  /* The only possible error from InitPage */\n        checkAppendMsg(pCheck, zContext,\n        "btreeInitPage() returns error code %d", rc);\n        releasePage(pPage);\n        return 0;\n      }\n\n      /* Check out all the cells.\n      */\n      depth = 0;\n      for (i = 0; i < pPage.nCell && pCheck.mxErr != 0; i++)\n      {\n        u8[] pCell;\n        u32 sz;\n        CellInfo info = new CellInfo();\n\n        /* Check payload overflow pages\n        */\n        sqlite3_snprintf(200, ref zContext,\n        "On tree page %d cell %d: ", iPage, i);\n        int iCell = findCell(pPage, i); //pCell = findCell( pPage, i );\n        pCell = pPage.aData;\n        btreeParseCellPtr( pPage, iCell, ref info ); //btreeParseCellPtr( pPage, pCell, info );\n        sz = info.nData;\n        if (0 == pPage.intKey) sz += (u32)info.nKey;\n        Debug.Assert(sz == info.nPayload);\n        if ((sz > info.nLocal)\n          //&& (pCell[info.iOverflow]<=&pPage.aData[pBt.usableSize])\n        )\n        {\n          int nPage = (int)(sz - info.nLocal + usableSize - 5) / (usableSize - 4);\n          Pgno pgnoOvfl = sqlite3Get4byte(pCell, iCell, info.iOverflow);\n#if !SQLITE_OMIT_AUTOVACUUM\n          if (pBt.autoVacuum)\n          {\n            checkPtrmap(pCheck, pgnoOvfl, PTRMAP_OVERFLOW1, (u32)iPage, zContext);\n          }\n#endif\n          checkList(pCheck, 0, (int)pgnoOvfl, nPage, zContext);\n        }\n\n        /* Check sanity of left child page.\n        */\n        if (0 == pPage.leaf)\n        {\n          pgno = (int)sqlite3Get4byte(pCell, iCell); //sqlite3Get4byte( pCell );\n#if !SQLITE_OMIT_AUTOVACUUM\n          if (pBt.autoVacuum)\n          {\n            checkPtrmap(pCheck, (u32)pgno, PTRMAP_BTREE, (u32)iPage, zContext);\n          }\n#endif\n          d2 = checkTreePage(pCheck, pgno, zContext);\n          if (i > 0 && d2 != depth)\n          {\n            checkAppendMsg(pCheck, zContext, "Child page depth differs");\n          }\n          depth = d2;\n        }\n      }\n      if (0 == pPage.leaf)\n      {\n        pgno = (int)sqlite3Get4byte(pPage.aData, pPage.hdrOffset + 8);\n        sqlite3_snprintf(200, ref zContext,\n        "On page %d at right child: ", iPage);\n#if !SQLITE_OMIT_AUTOVACUUM\n        if (pBt.autoVacuum)\n        {\n          checkPtrmap(pCheck, (u32)pgno, PTRMAP_BTREE, (u32)iPage, "");\n        }\n#endif\n        checkTreePage(pCheck, pgno, zContext);\n      }\n\n      /* Check for complete coverage of the page\n      */\n      data = pPage.aData;\n      hdr = pPage.hdrOffset;\n      hit = new byte[pBt.pageSize]; //sqlite3PageMalloc( pBt.pageSize );\n      //if( hit==null ){\n      //  pCheck.mallocFailed = 1;\n      //}else\n      {\n        u16 contentOffset = (u16)get2byte(data, hdr + 5);\n        Debug.Assert(contentOffset <= usableSize);  /* Enforced by btreeInitPage() */\n        //memset(hit+contentOffset, 0, usableSize-contentOffset);\n        //memset(hit, 1, contentOffset);\n        for (int iLoop = contentOffset - 1; iLoop >= 0; iLoop--) hit[iLoop] = 1;\n        nCell = get2byte(data, hdr + 3);\n        cellStart = hdr + 12 - 4 * pPage.leaf;\n        for (i = 0; i < nCell; i++)\n        {\n          int pc = get2byte(data, cellStart + i * 2);\n          u16 size = 1024;\n          int j;\n          if (pc <= usableSize - 4)\n          {\n            size = cellSizePtr(pPage, data, pc);\n          }\n          if ((pc + size - 1) >= usableSize)\n          {\n            checkAppendMsg(pCheck, null,\n            "Corruption detected in cell %d on page %d", i, iPage, 0);\n          }\n          else\n          {\n            for (j = pc + size - 1; j >= pc; j--) hit[j]++;\n          }\n        }\n        i = get2byte(data, hdr + 1);\n        while (i > 0)\n        {\n          int size, j;\n          Debug.Assert(i <= usableSize - 4);     /* Enforced by btreeInitPage() */\n          size = get2byte(data, i + 2);\n          Debug.Assert(i + size <= usableSize);  /* Enforced by btreeInitPage() */\n          for (j = i + size - 1; j >= i; j--) hit[j]++;\n          j = get2byte(data, i);\n          Debug.Assert(j == 0 || j > i + size);  /* Enforced by btreeInitPage() */\n          Debug.Assert(j <= usableSize - 4);   /* Enforced by btreeInitPage() */\n          i = j;\n        }\n        for (i = cnt = 0; i < usableSize; i++)\n        {\n          if (hit[i] == 0)\n          {\n            cnt++;\n          }\n          else if (hit[i] > 1)\n          {\n            checkAppendMsg(pCheck, "",\n            "Multiple uses for byte %d of page %d", i, iPage);\n            break;\n          }\n        }\n        if (cnt != data[hdr + 7])\n        {\n          checkAppendMsg(pCheck, null,\n          "Fragmentation of %d bytes reported as %d on page %d",\n          cnt, data[hdr + 7], iPage);\n        }\n      }\n      //      sqlite3PageFree(ref hit);\n      releasePage(pPage);\n      return depth + 1;\n    }\n#endif //* SQLITE_OMIT_INTEGRITY_CHECK */\n\n#if !SQLITE_OMIT_INTEGRITY_CHECK\n    /*\n** This routine does a complete check of the given BTree file.  aRoot[] is\n** an array of pages numbers were each page number is the root page of\n** a table.  nRoot is the number of entries in aRoot.\n**\n** A read-only or read-write transaction must be opened before calling\n** this function.\n**\n** Write the number of error seen in pnErr.  Except for some memory\n** allocation errors,  an error message held in memory obtained from\n** malloc is returned if pnErr is non-zero.  If pnErr==null then NULL is\n** returned.  If a memory allocation error occurs, NULL is returned.\n*/\n    static string sqlite3BtreeIntegrityCheck(\n    Btree p,       /* The btree to be checked */\n    int[] aRoot,   /* An array of root pages numbers for individual trees */\n    int nRoot,     /* Number of entries in aRoot[] */\n    int mxErr,     /* Stop reporting errors after this many */\n    ref int pnErr  /* Write number of errors seen to this variable */\n    )\n    {\n      Pgno i;\n      int nRef;\n      IntegrityCk sCheck = new IntegrityCk();\n      BtShared pBt = p.pBt;\n      StringBuilder zErr = new StringBuilder(100);//char zErr[100];\n\n\n      sqlite3BtreeEnter(p);\n      Debug.Assert(p.inTrans > TRANS_NONE && pBt.inTransaction > TRANS_NONE);\n      nRef = sqlite3PagerRefcount(pBt.pPager);\n      sCheck.pBt = pBt;\n      sCheck.pPager = pBt.pPager;\n      sCheck.nPage = pagerPagecount(sCheck.pBt);\n      sCheck.mxErr = mxErr;\n      sCheck.nErr = 0;\n      //sCheck.mallocFailed = 0;\n      pnErr = 0;\n      if (sCheck.nPage == 0)\n      {\n        sqlite3BtreeLeave(p);\n        return "";\n      }\n      sCheck.anRef = new int[sCheck.nPage + 1];//sqlite3Malloc( (sCheck.nPage+1)*sizeof(sCheck.anRef[0]) );\n      //if( !sCheck.anRef ){\n      //  pnErr = 1;\n      //  sqlite3BtreeLeave(p);\n      //  return 0;\n      //}\n      // for (i = 0; i <= sCheck.nPage; i++) { sCheck.anRef[i] = 0; }\n      i = PENDING_BYTE_PAGE(pBt);\n      if (i <= sCheck.nPage)\n      {\n        sCheck.anRef[i] = 1;\n      }\n      sqlite3StrAccumInit(sCheck.errMsg, zErr, zErr.Capacity, 20000);\n\n      /* Check the integrity of the freelist\n      */\n      checkList(sCheck, 1, (int)sqlite3Get4byte(pBt.pPage1.aData, 32),\n      (int)sqlite3Get4byte(pBt.pPage1.aData, 36), "Main freelist: ");\n\n      /* Check all the tables.\n      */\n      for (i = 0; (int)i < nRoot && sCheck.mxErr != 0; i++)\n      {\n        if (aRoot[i] == 0) continue;\n#if !SQLITE_OMIT_AUTOVACUUM\n        if (pBt.autoVacuum && aRoot[i] > 1)\n        {\n          checkPtrmap(sCheck, (u32)aRoot[i], PTRMAP_ROOTPAGE, 0, "");\n        }\n#endif\n        checkTreePage(sCheck, aRoot[i], "List of tree roots: ");\n      }\n\n      /* Make sure every page in the file is referenced\n      */\n      for (i = 1; i <= sCheck.nPage && sCheck.mxErr != 0; i++)\n      {\n#if SQLITE_OMIT_AUTOVACUUM\nif( sCheck.anRef[i]==null ){\ncheckAppendMsg(sCheck, 0, "Page %d is never used", i);\n}\n#else\n        /* If the database supports auto-vacuum, make sure no tables contain\n** references to pointer-map pages.\n*/\n        if (sCheck.anRef[i] == 0 &&\n        (PTRMAP_PAGENO(pBt, i) != i || !pBt.autoVacuum))\n        {\n          checkAppendMsg(sCheck, null, "Page %d is never used", i);\n        }\n        if (sCheck.anRef[i] != 0 &&\n        (PTRMAP_PAGENO(pBt, i) == i && pBt.autoVacuum))\n        {\n          checkAppendMsg(sCheck, null, "Pointer map page %d is referenced", i);\n        }\n#endif\n      }\n\n      /* Make sure this analysis did not leave any unref() pages.\n      ** This is an internal consistency check; an integrity check\n      ** of the integrity check.\n      */\n      if (NEVER(nRef != sqlite3PagerRefcount(pBt.pPager)))\n      {\n        checkAppendMsg(sCheck, null,\n        "Outstanding page count goes from %d to %d during this analysis",\n        nRef, sqlite3PagerRefcount(pBt.pPager)\n        );\n      }\n\n      /* Clean  up and report errors.\n      */\n      sqlite3BtreeLeave(p);\n      sCheck.anRef = null;// sqlite3_free( ref sCheck.anRef );\n      //if( sCheck.mallocFailed ){\n      //  sqlite3StrAccumReset(sCheck.errMsg);\n      //  pnErr = sCheck.nErr+1;\n      //  return 0;\n      //}\n      pnErr = sCheck.nErr;\n      if (sCheck.nErr == 0) sqlite3StrAccumReset(sCheck.errMsg);\n      return sqlite3StrAccumFinish(sCheck.errMsg);\n    }\n#endif //* SQLITE_OMIT_INTEGRITY_CHECK */\n\n    /*\n** Return the full pathname of the underlying database file.\n**\n** The pager filename is invariant as long as the pager is\n** open so it is safe to access without the BtShared mutex.\n*/\n    static string sqlite3BtreeGetFilename(Btree p)\n    {\n      Debug.Assert(p.pBt.pPager != null);\n      return sqlite3PagerFilename(p.pBt.pPager);\n    }\n\n    /*\n    ** Return the pathname of the journal file for this database. The return\n    ** value of this routine is the same regardless of whether the journal file\n    ** has been created or not.\n    **\n    ** The pager journal filename is invariant as long as the pager is\n    ** open so it is safe to access without the BtShared mutex.\n    */\n    static string sqlite3BtreeGetJournalname(Btree p)\n    {\n      Debug.Assert(p.pBt.pPager != null);\n      return sqlite3PagerJournalname(p.pBt.pPager);\n    }\n\n    /*\n    ** Return non-zero if a transaction is active.\n    */\n    static bool sqlite3BtreeIsInTrans(Btree p)\n    {\n      Debug.Assert(p == null || sqlite3_mutex_held(p.db.mutex));\n      return (p != null && (p.inTrans == TRANS_WRITE));\n    }\n\n    /*\n    ** Return non-zero if a read (or write) transaction is active.\n    */\n    static bool sqlite3BtreeIsInReadTrans(Btree p)\n    {\n      Debug.Assert(p != null);\n      Debug.Assert(sqlite3_mutex_held(p.db.mutex));\n      return p.inTrans != TRANS_NONE;\n    }\n\n    static bool sqlite3BtreeIsInBackup(Btree p)\n    {\n      Debug.Assert(p != null);\n      Debug.Assert(sqlite3_mutex_held(p.db.mutex));\n      return p.nBackup != 0;\n    }\n\n    /*\n    ** This function returns a pointer to a blob of memory associated with\n    ** a single shared-btree. The memory is used by client code for its own\n    ** purposes (for example, to store a high-level schema associated with\n    ** the shared-btree). The btree layer manages reference counting issues.\n    **\n    ** The first time this is called on a shared-btree, nBytes bytes of memory\n    ** are allocated, zeroed, and returned to the caller. For each subsequent\n    ** call the nBytes parameter is ignored and a pointer to the same blob\n    ** of memory returned.\n    **\n    ** If the nBytes parameter is 0 and the blob of memory has not yet been\n    ** allocated, a null pointer is returned. If the blob has already been\n    ** allocated, it is returned as normal.\n    **\n    ** Just before the shared-btree is closed, the function passed as the\n    ** xFree argument when the memory allocation was made is invoked on the\n    ** blob of allocated memory. This function should not call sqlite3_free(ref )\n    ** on the memory, the btree layer does that.\n    */\n    static Schema sqlite3BtreeSchema(Btree p, int nBytes, dxFreeSchema xFree)\n    {\n      BtShared pBt = p.pBt;\n      sqlite3BtreeEnter(p);\n      if (null == pBt.pSchema && nBytes != 0)\n      {\n        pBt.pSchema = new Schema();//sqlite3MallocZero(nBytes);\n        pBt.xFreeSchema = xFree;\n      }\n      sqlite3BtreeLeave(p);\n      return pBt.pSchema;\n    }\n\n    /*\n    ** Return SQLITE_LOCKED_SHAREDCACHE if another user of the same shared\n    ** btree as the argument handle holds an exclusive lock on the\n    ** sqlite_master table. Otherwise SQLITE_OK.\n    */\n    static int sqlite3BtreeSchemaLocked(Btree p)\n    {\n      int rc;\n      Debug.Assert(sqlite3_mutex_held(p.db.mutex));\n      sqlite3BtreeEnter(p);\n      rc = querySharedCacheTableLock(p, MASTER_ROOT, READ_LOCK);\n      Debug.Assert(rc == SQLITE_OK || rc == SQLITE_LOCKED_SHAREDCACHE);\n      sqlite3BtreeLeave(p);\n      return rc;\n    }\n\n\n#if !SQLITE_OMIT_SHARED_CACHE\n/*\n** Obtain a lock on the table whose root page is iTab.  The\n** lock is a write lock if isWritelock is true or a read lock\n** if it is false.\n*/\nint sqlite3BtreeLockTable(Btree p, int iTab, u8 isWriteLock){\nint rc = SQLITE_OK;\nDebug.Assert( p.inTrans!=TRANS_NONE );\nif( p.sharable ){\nu8 lockType = READ_LOCK + isWriteLock;\nDebug.Assert( READ_LOCK+1==WRITE_LOCK );\nDebug.Assert( isWriteLock==null || isWriteLock==1 );\n\nsqlite3BtreeEnter(p);\nrc = querySharedCacheTableLock(p, iTab, lockType);\nif( rc==SQLITE_OK ){\nrc = setSharedCacheTableLock(p, iTab, lockType);\n}\nsqlite3BtreeLeave(p);\n}\nreturn rc;\n}\n#endif\n\n#if !SQLITE_OMIT_INCRBLOB\n/*\n** Argument pCsr must be a cursor opened for writing on an\n** INTKEY table currently pointing at a valid table entry.\n** This function modifies the data stored as part of that entry.\n**\n** Only the data content may only be modified, it is not possible to\n** change the length of the data stored. If this function is called with\n** parameters that attempt to write past the end of the existing data,\n** no modifications are made and SQLITE_CORRUPT is returned.\n*/\nint sqlite3BtreePutData(BtCursor pCsr, u32 offset, u32 amt, void *z){\nint rc;\nDebug.Assert( cursorHoldsMutex(pCsr) );\nDebug.Assert( sqlite3_mutex_held(pCsr.pBtree.db.mutex) );\nDebug.Assert( pCsr.isIncrblobHandle );\n\nrc = restoreCursorPosition(pCsr);\nif( rc!=SQLITE_OK ){\nreturn rc;\n}\nDebug.Assert( pCsr.eState!=CURSOR_REQUIRESEEK );\nif( pCsr.eState!=CURSOR_VALID ){\nreturn SQLITE_ABORT;\n}\n\n/* Check some assumptions:\n**   (a) the cursor is open for writing,\n**   (b) there is a read/write transaction open,\n**   (c) the connection holds a write-lock on the table (if required),\n**   (d) there are no conflicting read-locks, and\n**   (e) the cursor points at a valid row of an intKey table.\n*/\nif( !pCsr.wrFlag ){\nreturn SQLITE_READONLY;\n}\nDebug.Assert( !pCsr.pBt.readOnly && pCsr.pBt.inTransaction==TRANS_WRITE );\nDebug.Assert( hasSharedCacheTableLock(pCsr.pBtree, pCsr.pgnoRoot, 0, 2) );\nDebug.Assert( !hasReadConflicts(pCsr.pBtree, pCsr.pgnoRoot) );\nDebug.Assert( pCsr.apPage[pCsr.iPage].intKey );\n\nreturn accessPayload(pCsr, offset, amt, (byte[] *)z, 1);\n}\n\n/*\n** Set a flag on this cursor to cache the locations of pages from the\n** overflow list for the current row. This is used by cursors opened\n** for incremental blob IO only.\n**\n** This function sets a flag only. The actual page location cache\n** (stored in BtCursor.aOverflow[]) is allocated and used by function\n** accessPayload() (the worker function for sqlite3BtreeData() and\n** sqlite3BtreePutData()).\n*/\nvoid sqlite3BtreeCacheOverflow(BtCursor pCur){\nDebug.Assert( cursorHoldsMutex(pCur) );\nDebug.Assert( sqlite3_mutex_held(pCur.pBtree.db.mutex) );\nDebug.Assert(!pCur.isIncrblobHandle);\nDebug.Assert(!pCur.aOverflow);\npCur.isIncrblobHandle = 1;\n}\n#endif\n  }\n}\n'