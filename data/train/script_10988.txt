b'\xef\xbb\xbfusing System;\nusing System.ComponentModel;\nusing System.Globalization;\nusing System.Runtime.InteropServices;\n\nnamespace SweetPotato {\n    internal class ImpersonationToken {\n        // Constants that are going to be used during our procedure.\n        public static uint SE_PRIVILEGE_ENABLED = 0x00000002;\n        public static uint STANDARD_RIGHTS_REQUIRED = 0x000F0000;\n        public static uint STANDARD_RIGHTS_READ = 0x00020000;\n        public static uint TOKEN_ASSIGN_PRIMARY = 0x00000001;\n        public static uint TOKEN_DUPLICATE = 0x00000002;\n        public static uint TOKEN_IMPERSONATE = 0x00000004;\n        public static uint TOKEN_QUERY = 0x00000008;\n        public static uint TOKEN_QUERY_SOURCE = 0x00000010;\n        public static uint TOKEN_ADJUST_PRIVILEGES = 0x00000020;\n        public static uint TOKEN_ADJUST_GROUPS = 0x00000040;\n        public static uint TOKEN_ADJUST_DEFAULT = 0x00000080;\n        public static uint TOKEN_ADJUST_SESSIONID = 0x00000100;\n        public static uint TOKEN_READ = STANDARD_RIGHTS_READ | TOKEN_QUERY;\n        public static uint TOKEN_ALL_ACCESS = STANDARD_RIGHTS_REQUIRED | TOKEN_ASSIGN_PRIMARY | TOKEN_DUPLICATE | TOKEN_IMPERSONATE | TOKEN_QUERY | TOKEN_QUERY_SOURCE | TOKEN_ADJUST_PRIVILEGES | TOKEN_ADJUST_GROUPS | TOKEN_ADJUST_DEFAULT | TOKEN_ADJUST_SESSIONID;\n        public static uint MAXIMUM_ALLOWED = 0x02000000;\n\n        public static uint DETACHED_PROCESS = 0x00000008;\n        public static uint CREATE_NEW_CONSOLE = 0x00000010;\n\n\n        public enum SECURITY_IMPERSONATION_LEVEL {\n            SecurityAnonymous,\n            SecurityIdentification,\n            SecurityImpersonation,\n            SecurityDelegation\n        }\n\n        public enum TOKEN_TYPE {\n            TokenPrimary = 1,\n            TokenImpersonation\n        }\n\n        [StructLayout(LayoutKind.Sequential)]\n        internal struct LUID {\n            internal Int32 LowPart;\n            internal UInt32 HighPart;\n        }\n\n        [StructLayout(LayoutKind.Sequential)]\n        internal struct TOKEN_PRIVILEGES {\n            internal Int32 PrivilegeCount;\n            internal LUID Luid;\n            internal UInt32 Attributes;\n        }\n\n        // This also works with CharSet.Ansi as long as the calling function uses the same character set.\n        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]\n        public struct STARTUPINFO {\n            public Int32 cb;\n            public string lpReserved;\n            public string lpDesktop;\n            public string lpTitle;\n            public Int32 dwX;\n            public Int32 dwY;\n            public Int32 dwXSize;\n            public Int32 dwYSize;\n            public Int32 dwXCountChars;\n            public Int32 dwYCountChars;\n            public Int32 dwFillAttribute;\n            public Int32 dwFlags;\n            public Int16 wShowWindow;\n            public Int16 cbReserved2;\n            public IntPtr lpReserved2;\n            public IntPtr hStdInput;\n            public IntPtr hStdOutput;\n            public IntPtr hStdError;\n        }\n\n        [StructLayout(LayoutKind.Sequential)]\n        public struct PROCESS_INFORMATION {\n            public IntPtr hProcess;\n            public IntPtr hThread;\n            public int dwProcessId;\n            public int dwThreadId;\n        }\n\n        public enum LogonFlags {\n            WithProfile = 1,\n            NetCredentialsOnly\n        }\n\n        public enum CreationFlags {\n            DefaultErrorMode = 0x04000000,\n            DetachedProcess = 0x00000008,\n            NewConsole = 0x00000010,\n            NewProcessGroup = 0x00000200,\n            SeparateWOWVDM = 0x00000800,\n            Suspended = 0x00000004,\n            UnicodeEnvironment = 0x00000400,\n            ExtendedStartupInfoPresent = 0x00080000\n        }\n\n        public enum SecurityEntity {\n            SE_CREATE_TOKEN_NAME,\n            SE_ASSIGNPRIMARYTOKEN_NAME,\n            SE_LOCK_MEMORY_NAME,\n            SE_INCREASE_QUOTA_NAME,\n            SE_UNSOLICITED_INPUT_NAME,\n            SE_MACHINE_ACCOUNT_NAME,\n            SE_TCB_NAME,\n            SE_SECURITY_NAME,\n            SE_TAKE_OWNERSHIP_NAME,\n            SE_LOAD_DRIVER_NAME,\n            SE_SYSTEM_PROFILE_NAME,\n            SE_SYSTEMTIME_NAME,\n            SE_PROF_SINGLE_PROCESS_NAME,\n            SE_INC_BASE_PRIORITY_NAME,\n            SE_CREATE_PAGEFILE_NAME,\n            SE_CREATE_PERMANENT_NAME,\n            SE_BACKUP_NAME,\n            SE_RESTORE_NAME,\n            SE_SHUTDOWN_NAME,\n            SE_DEBUG_NAME,\n            SE_AUDIT_NAME,\n            SE_SYSTEM_ENVIRONMENT_NAME,\n            SE_CHANGE_NOTIFY_NAME,\n            SE_REMOTE_SHUTDOWN_NAME,\n            SE_UNDOCK_NAME,\n            SE_SYNC_AGENT_NAME,\n            SE_ENABLE_DELEGATION_NAME,\n            SE_MANAGE_VOLUME_NAME,\n            SE_IMPERSONATE_NAME,\n            SE_CREATE_GLOBAL_NAME,\n            SE_CREATE_SYMBOLIC_LINK_NAME,\n            SE_INC_WORKING_SET_NAME,\n            SE_RELABEL_NAME,\n            SE_TIME_ZONE_NAME,\n            SE_TRUSTED_CREDMAN_ACCESS_NAME\n        }\n\n        [DllImport("advapi32", SetLastError = true, CharSet = CharSet.Unicode)]\n        public static extern bool CreateProcessWithTokenW(IntPtr hToken, LogonFlags dwLogonFlags, string lpApplicationName, string lpCommandLine,\n            CreationFlags dwCreationFlags, IntPtr lpEnvironment, string lpCurrentDirectory, [In] ref STARTUPINFO lpStartupInfo, out PROCESS_INFORMATION lpProcessInformation);\n\n        [DllImport("advapi32.dll", SetLastError = true, CharSet = CharSet.Unicode)]\n        public static extern bool CreateProcessAsUserW(IntPtr hToken, string lpApplicationName, string lpCommandLine, IntPtr lpProcessAttributes, IntPtr lpThreadAttributes,\n            bool bInheritHandles, uint dwCreationFlags, IntPtr lpEnvironment, string lpCurrentDirectory, ref STARTUPINFO lpStartupInfo, out PROCESS_INFORMATION lpProcessInformation);\n\n        [DllImport("kernel32.dll")]\n        public static extern uint WTSGetActiveConsoleSessionId();\n\n        [DllImport("advapi32.dll", CharSet = CharSet.Unicode, SetLastError = true)]\n        [return: MarshalAs(UnmanagedType.Bool)]\n        internal static extern bool LookupPrivilegeValue(string lpsystemname, string lpname, [MarshalAs(UnmanagedType.Struct)] ref LUID lpLuid);\n\n        [DllImport("advapi32.dll", CharSet = CharSet.Unicode, SetLastError = true)]\n        [return: MarshalAs(UnmanagedType.Bool)]\n        internal static extern bool AdjustTokenPrivileges(IntPtr tokenhandle,\n                                 [MarshalAs(UnmanagedType.Bool)] bool disableAllPrivileges,\n                                 [MarshalAs(UnmanagedType.Struct)]ref TOKEN_PRIVILEGES newstate,\n                                 uint bufferlength, IntPtr previousState, IntPtr returnlength);\n        // OpenProcessToken\n        [DllImport("advapi32.dll", SetLastError = true)]\n        [return: MarshalAs(UnmanagedType.Bool)]\n        public static extern bool OpenProcessToken(IntPtr ProcessHandle, UInt32 DesiredAccess, out IntPtr TokenHandle);\n\n        [DllImport("advapi32.dll", SetLastError = true)]\n        public static extern bool OpenThreadToken(IntPtr ThreadHandle, uint DesiredAccess, bool OpenAsSelf, out IntPtr TokenHandle);\n\n        [DllImport("advapi32.dll", CharSet = CharSet.Auto, SetLastError = true)]\n        public extern static bool DuplicateTokenEx(IntPtr hExistingToken, uint dwDesiredAccess, IntPtr lpTokenAttributes,\n            SECURITY_IMPERSONATION_LEVEL ImpersonationLevel, TOKEN_TYPE TokenType, out IntPtr phNewToken);\n\n        [DllImport("advapi32.dll", SetLastError = true)]\n        public static extern bool SetThreadToken(IntPtr pHandle, IntPtr hToken);\n\n        [DllImport("kernel32.dll", SetLastError = true)]\n        public static extern IntPtr GetCurrentProcess();\n\n        [DllImport("kernel32.dll")]\n        public static extern IntPtr GetCurrentThread();\n\n        [DllImport("kernel32.dll", CharSet = CharSet.Auto, SetLastError = true)]\n        [return: MarshalAs(UnmanagedType.Bool)]\n        internal static extern Boolean CloseHandle(IntPtr hObject);\n\n        [DllImport("userenv.dll", SetLastError = true)]\n        public static extern bool CreateEnvironmentBlock(out IntPtr lpEnvironment, IntPtr hToken, bool bInherit);\n\n        private static string GetSecurityEntityValue(SecurityEntity securityEntity) {\n            switch (securityEntity) {\n                case SecurityEntity.SE_ASSIGNPRIMARYTOKEN_NAME:\n                    return "SeAssignPrimaryTokenPrivilege";\n                case SecurityEntity.SE_AUDIT_NAME:\n                    return "SeAuditPrivilege";\n                case SecurityEntity.SE_BACKUP_NAME:\n                    return "SeBackupPrivilege";\n                case SecurityEntity.SE_CHANGE_NOTIFY_NAME:\n                    return "SeChangeNotifyPrivilege";\n                case SecurityEntity.SE_CREATE_GLOBAL_NAME:\n                    return "SeCreateGlobalPrivilege";\n                case SecurityEntity.SE_CREATE_PAGEFILE_NAME:\n                    return "SeCreatePagefilePrivilege";\n                case SecurityEntity.SE_CREATE_PERMANENT_NAME:\n                    return "SeCreatePermanentPrivilege";\n                case SecurityEntity.SE_CREATE_SYMBOLIC_LINK_NAME:\n                    return "SeCreateSymbolicLinkPrivilege";\n                case SecurityEntity.SE_CREATE_TOKEN_NAME:\n                    return "SeCreateTokenPrivilege";\n                case SecurityEntity.SE_DEBUG_NAME:\n                    return "SeDebugPrivilege";\n                case SecurityEntity.SE_ENABLE_DELEGATION_NAME:\n                    return "SeEnableDelegationPrivilege";\n                case SecurityEntity.SE_IMPERSONATE_NAME:\n                    return "SeImpersonatePrivilege";\n                case SecurityEntity.SE_INC_BASE_PRIORITY_NAME:\n                    return "SeIncreaseBasePriorityPrivilege";\n                case SecurityEntity.SE_INCREASE_QUOTA_NAME:\n                    return "SeIncreaseQuotaPrivilege";\n                case SecurityEntity.SE_INC_WORKING_SET_NAME:\n                    return "SeIncreaseWorkingSetPrivilege";\n                case SecurityEntity.SE_LOAD_DRIVER_NAME:\n                    return "SeLoadDriverPrivilege";\n                case SecurityEntity.SE_LOCK_MEMORY_NAME:\n                    return "SeLockMemoryPrivilege";\n                case SecurityEntity.SE_MACHINE_ACCOUNT_NAME:\n                    return "SeMachineAccountPrivilege";\n                case SecurityEntity.SE_MANAGE_VOLUME_NAME:\n                    return "SeManageVolumePrivilege";\n                case SecurityEntity.SE_PROF_SINGLE_PROCESS_NAME:\n                    return "SeProfileSingleProcessPrivilege";\n                case SecurityEntity.SE_RELABEL_NAME:\n                    return "SeRelabelPrivilege";\n                case SecurityEntity.SE_REMOTE_SHUTDOWN_NAME:\n                    return "SeRemoteShutdownPrivilege";\n                case SecurityEntity.SE_RESTORE_NAME:\n                    return "SeRestorePrivilege";\n                case SecurityEntity.SE_SECURITY_NAME:\n                    return "SeSecurityPrivilege";\n                case SecurityEntity.SE_SHUTDOWN_NAME:\n                    return "SeShutdownPrivilege";\n                case SecurityEntity.SE_SYNC_AGENT_NAME:\n                    return "SeSyncAgentPrivilege";\n                case SecurityEntity.SE_SYSTEM_ENVIRONMENT_NAME:\n                    return "SeSystemEnvironmentPrivilege";\n                case SecurityEntity.SE_SYSTEM_PROFILE_NAME:\n                    return "SeSystemProfilePrivilege";\n                case SecurityEntity.SE_SYSTEMTIME_NAME:\n                    return "SeSystemtimePrivilege";\n                case SecurityEntity.SE_TAKE_OWNERSHIP_NAME:\n                    return "SeTakeOwnershipPrivilege";\n                case SecurityEntity.SE_TCB_NAME:\n                    return "SeTcbPrivilege";\n                case SecurityEntity.SE_TIME_ZONE_NAME:\n                    return "SeTimeZonePrivilege";\n                case SecurityEntity.SE_TRUSTED_CREDMAN_ACCESS_NAME:\n                    return "SeTrustedCredManAccessPrivilege";\n                case SecurityEntity.SE_UNDOCK_NAME:\n                    return "SeUndockPrivilege";\n                default:\n                    throw new ArgumentOutOfRangeException(typeof(SecurityEntity).Name);\n            }\n        }\n\n        public static bool EnablePrivilege(SecurityEntity securityEntity) {\n            const int ERROR_NOT_ALL_ASSIGNED = 1300;\n\n            if (!Enum.IsDefined(typeof(SecurityEntity), securityEntity))\n                throw new InvalidEnumArgumentException("securityEntity", (int)securityEntity, typeof(SecurityEntity));\n\n            var securityEntityValue = GetSecurityEntityValue(securityEntity);\n            try {\n                var locallyUniqueIdentifier = new LUID();\n\n                if (LookupPrivilegeValue(null, securityEntityValue, ref locallyUniqueIdentifier)) {\n                    var TOKEN_PRIVILEGES = new TOKEN_PRIVILEGES();\n                    TOKEN_PRIVILEGES.PrivilegeCount = 1;\n                    TOKEN_PRIVILEGES.Attributes = SE_PRIVILEGE_ENABLED;\n                    TOKEN_PRIVILEGES.Luid = locallyUniqueIdentifier;\n\n                    var tokenHandle = IntPtr.Zero;\n                    try {\n                        var currentProcess = GetCurrentProcess();\n                        if (OpenProcessToken(currentProcess, TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, out tokenHandle)) {\n                            if (AdjustTokenPrivileges(tokenHandle, false,\n                                                ref TOKEN_PRIVILEGES,\n               1024, IntPtr.Zero, IntPtr.Zero)) {\n                                var lastError = Marshal.GetLastWin32Error();\n                                if (lastError == ERROR_NOT_ALL_ASSIGNED) {\n                                    //Not likley to have the privilege\n                                    return false;\n                                } else if (lastError != 0) {\n                                    var win32Exception = new Win32Exception();\n                                    throw new InvalidOperationException("AdjustTokenPrivileges failed.", win32Exception);\n                                } else {\n                                    return true;\n                                }\n                            } else {\n                                var win32Exception = new Win32Exception();\n                                throw new InvalidOperationException("AdjustTokenPrivileges failed.", win32Exception);\n                            }\n                        } else {\n                            var win32Exception = new Win32Exception();\n\n                            var exceptionMessage = string.Format(CultureInfo.InvariantCulture,\n                                                "OpenProcessToken failed. CurrentProcess: {0}",\n                                                currentProcess.ToInt32());\n\n                            throw new InvalidOperationException(exceptionMessage, win32Exception);\n                        }\n                    } finally {\n                        if (tokenHandle != IntPtr.Zero)\n                            CloseHandle(tokenHandle);\n                    }\n                } else {\n                    var win32Exception = new Win32Exception();\n\n                    var exceptionMessage = string.Format(CultureInfo.InvariantCulture,\n                                        "LookupPrivilegeValue failed. SecurityEntityValue: {0}",\n                                        securityEntityValue);\n\n                    throw new InvalidOperationException(exceptionMessage, win32Exception);\n                }\n            } catch (Exception e) {\n                var exceptionMessage = string.Format(CultureInfo.InvariantCulture,\n                                 "GrandPrivilege failed. SecurityEntity: {0}",\n                                 securityEntityValue);\n\n                throw new InvalidOperationException(exceptionMessage, e);\n            }\n        }\n    }\n}'