b'\xef\xbb\xbf#load "packages/FsLab/FsLab.fsx"\n\n#load "parseScripts.fs"\n\nopen FSharp.Data\nopen System\nopen System.IO\nopen StarWars.ParseScripts\nopen System.Text.RegularExpressions\n\n/// Extract interactions between characters from the individual scripts\nlet characters = \n    let stdCharacters = File.ReadAllLines(__SOURCE_DIRECTORY__ + "/data/characters.csv") \n    let allNames =\n        [| 0 .. scriptUrls.Length-1 |]\n        |> Array.collect\n            (fun ep -> \n                Seq.append aliasesForEpisodes.[ep].Keys aliasesForEpisodes.[ep].Values \n                |> Array.ofSeq)\n    stdCharacters \n    |> Array.append allNames \n    |> Array.map (fun s -> s.ToLower())\n    |> Array.distinct\n\n// Some names occur also as a part of other words - check for that as well\n// problematic names: Han, Sola\nlet containsName (scene:string) (name:string) = \n   scene.Contains(name) && (\n     Regex.IsMatch(scene,"[^a-z]+" + name + "[^a-z]+") ||\n     Regex.IsMatch(scene,"^" + name + "[^a-z]+") ||\n     Regex.IsMatch(scene,"[^a-z]+" + name + "$"))\n\n/// Create JSON network\nlet getJsonNetwork nodes links =\n    let jsonNodes = \n        nodes\n        |> Seq.map (fun (name, count) -> \n            JsonValue.Record \n                [| "name", JsonValue.String name; \n                   "value", JsonValue.Number (decimal (count+1))\n                   "colour", JsonValue.String (getCharacterColour name)|] )\n        |> Array.ofSeq\n        |> JsonValue.Array\n    // translate links from names to idxs\n    let nodeIdxs = Seq.mapi (fun i (name, count) -> name, i) nodes |> dict\n    let jsonLinks = \n        links\n        |> Seq.map (fun ((n1, n2), value) -> \n            JsonValue.Record [| "source", JsonValue.Number (decimal nodeIdxs.[n1]); \n                "target", JsonValue.Number (decimal nodeIdxs.[n2]);\n                "value", JsonValue.Number (decimal value)|])\n        |> Array.ofSeq\n        |> JsonValue.Array\n    (JsonValue.Record [| "nodes", jsonNodes  ; "links", jsonLinks |]).ToString()\n\nlet getMentionsNetwork includeRobots countThreshold episodeIdx = \n    let episode, url = scriptUrls.[episodeIdx]\n    let script = getScriptElement url\n    let scriptParts = script.Elements()\n\n    let mainScript = \n        scriptParts\n        |> Seq.map (fun element -> element.ToString())\n        |> Seq.toArray\n\n    // Now every element of the list is a single scene\n    let scenes = \n        splitByScene mainScript [] |> List.rev\n\n    let interactions = \n        scenes\n        |> List.map (fun scene -> \n            let lscene = \n                scene |> Array.map (fun s -> s.ToLower()) // some names contain lower-case characters\n            characters\n            |> Array.filter (characterCheck episodeIdx)\n            |> Array.map (fun name -> \n                lscene \n                |> Array.map (fun contents -> if containsName contents name then Some name else None )\n                |> Array.choose id)\n            |> Array.concat\n            |> Array.choose (fun name -> \n                let newName = mapName episodeIdx (name.ToUpper())\n                if includeRobots then Some newName\n                elif \n                    newName = "R2-D2" \n                    || newName = "C-3PO"\n                    || newName = "BB-8"\n                    then None else Some newName)\n            |> Array.distinct )\n//        |> List.mapi (fun i cs -> \n//            if (cs |> Array.contains "SNOKE") && (cs |> Array.contains "CHEWBACCA") then printfn "%d" i \n//            cs)\n        |> List.filter (Array.isEmpty >> not)\n\n    // Create weighted network\n    let nodes = \n        interactions \n        |> Seq.collect id\n        |> Seq.countBy id        \n        |> Seq.filter (fun (name, count) -> count >= countThreshold)\n    let nodeLookup = nodes |> Seq.map fst |> set\n\n    let links = \n        interactions \n        |> List.collect (fun sceneNames -> \n            [ for i in 0..sceneNames.Length - 1 do \n                for j in i+1..sceneNames.Length - 1 do\n                  let n1 = sceneNames.[i]\n                  let n2 = sceneNames.[j]\n                  if nodeLookup.Contains(n1) && nodeLookup.Contains(n2) then\n                     yield min n1 n2, max n1 n2 ])\n        |> Seq.countBy id\n        |> Array.ofSeq\n\n    nodes, links\n\nlet generateMentionsNetwork episodeIdx =     \n    let nodes, links = getMentionsNetwork true 0 episodeIdx\n    File.WriteAllText(__SOURCE_DIRECTORY__ + "/networks/starwars-episode-" + string (episodeIdx + 1) + "-mentions.json",\n        getJsonNetwork nodes links)\n\nfor i in 0..5 do generateMentionsNetwork i\ngenerateMentionsNetwork 6\n\n// =====================================================================\n// Generate global network\n\nlet includeRobots = true\nlet countThreshold = 0\nlet linkThreshold = 0\nlet nodes, links = \n    [0..6] |> List.map (getMentionsNetwork includeRobots 0) |> List.unzip\nlet summarizeEpisodes data =\n    data \n    |> Seq.collect id \n    |> Seq.groupBy fst\n    |> Seq.map (fun (name, episodeCounts) -> name, episodeCounts |> Seq.sumBy snd)\n\nlet allNodes = \n    summarizeEpisodes nodes \n    |> Seq.filter (fun (name, count) -> count >= countThreshold)\nlet nodeLookup = allNodes |> Seq.map fst |> set\n\nlet allLinks = \n    summarizeEpisodes links\n    |> Seq.filter (fun ((n1, n2), _) -> nodeLookup.Contains(n1) && nodeLookup.Contains(n2))\n    |> Seq.filter (fun ((n1, n2), count) -> count > linkThreshold)\n\nFile.WriteAllText(__SOURCE_DIRECTORY__ + "/networks/starwars-full-mentions.json",\n    getJsonNetwork allNodes allLinks)\n\n// ===============================================================\n// Get timelines of mentions for each character\n\n/// Get indices of scenes where individual characters appear (where they are mentioned).\nlet getSceneAppearances episodeIdx = \n    let episode, url = scriptUrls.[episodeIdx]\n    let script = getScriptElement url\n    let scriptParts = script.Elements()\n\n    let mainScript = \n        scriptParts\n        |> Seq.map (fun element -> element.ToString())\n        |> Seq.toArray\n\n    // Now every element of the list is a single scene\n    let scenes = \n        splitByScene mainScript [] |> List.rev\n    let totalScenes = scenes.Length\n\n    scenes\n    |> List.mapi (fun sceneIdx scene -> \n        let lscene = \n            scene |> Array.map (fun s -> s.ToLower()) // some names contain lower-case characters\n        characters\n        |> Array.filter (characterCheck episodeIdx)\n        |> Array.map (fun name -> \n            lscene \n            |> Array.map (fun contents -> if containsName contents name then Some name else None )\n            |> Array.choose id)\n        |> Array.concat\n        |> Array.map (fun name -> mapName episodeIdx (name.ToUpper()))\n        |> Seq.distinct \n        |> Seq.map (fun name -> sceneIdx, name)\n        |> List.ofSeq)\n    |> List.collect id,\n    totalScenes\n\nlet appearances = \n    [0 .. 6]\n    |> List.map getSceneAppearances\n    |> List.mapi (fun episodeIdx (sceneAppearances, total) ->\n        sceneAppearances \n        |> List.map (fun (scene, name) -> \n            float episodeIdx + float scene / float total, name))\n    |> List.collect id\n    |> Seq.groupBy snd\n    |> Seq.map (fun (name, inScenes) -> name, inScenes |> Seq.map fst |> Array.ofSeq)       \n    |> Array.ofSeq  \n\n// Save appearances as pseudo-csv file\nlet appearancesFilename = __SOURCE_DIRECTORY__ + "/data/charactersPerScene.csv"\nlet appearsString =\n    appearances\n    |> Array.map (fun (name, appears) -> \n        appears |> Array.map string |> Array.append [|name|] |> String.concat ",")\nFile.WriteAllLines(appearancesFilename, appearsString)\n    '