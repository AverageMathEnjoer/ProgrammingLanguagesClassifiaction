b'-- THIS MODULE WILL BE REMOVED AFTER REVIEW.\n\nmodule Hoodle.ModelAction.Network where\n\n{-\nimport Control.Monad\nimport Data.Aeson.Encode as E\nimport Data.Aeson.Parser\nimport Data.Aeson.Types\nimport qualified Data.Attoparsec as A\nimport qualified Data.ByteString as B\nimport qualified Data.ByteString.Char8 as SC\nimport qualified Data.ByteString.Lazy.Char8 as C\nimport Data.Time.Clock\nimport Data.UUID\nimport Data.UUID.V5\nimport Data.Xournal.BBox\nimport Data.Xournal.Generic\nimport Data.Xournal.Simple\nimport Debug.Trace\nimport Hoodle.NetworkClipboard.Client.Config\nimport Hoodle.NetworkClipboard.Type\nimport Hoodle.Type.Clipboard\nimport Network.HTTP.Enumerator\nimport Network.HTTP.Types hiding (statusCode)\nimport System.Directory\nimport System.FilePath\nimport Unsafe.Coerce\n-}\n\n{-\ntype Url = String\n\nnextUUID :: HoodleClipClientConfiguration -> IO UUID\nnextUUID mc = do\n  let c = hoodleclipClientURL mc\n  t <- getCurrentTime\n  return . generateNamed namespaceURL . B.unpack . SC.pack $ c ++ "/" ++ show t\n\nstartCreate :: HoodleClipClientConfiguration -> [Stroke] -> IO ()\nstartCreate mc strs = do\n  putStrLn "job started"\n  cwd <- getCurrentDirectory\n  let url = hoodleclipServerURL mc\n  uuid <- nextUUID mc\n  let info =\n        HoodleClipInfo\n          { hoodleclip_uuid = uuid,\n            hoodleclip_strokes = strs\n          }\n  response <- hoodleclipToServer url ("uploadhoodleclip") methodPost info\n  -- putStrLn $ show response\n  return ()\n\n{-\n  case A.parseOnly json jsonstr of\n    Left str -> error str\n    Right jsonstrokes ->\n      case parse parseJSON jsonstrokes of\n        Error str2 -> error str2\n        Success strokes -> do\n-}\n\nstartCurrent :: HoodleClipClientConfiguration -> IO (Maybe HoodleClipInfo)\nstartCurrent mc = do\n  putStrLn $ "currentclip"\n  let url = hoodleclipServerURL mc\n  r <- jsonFromServer url ("currentclip") methodGet\n  -- putStrLn $ show r\n  case r of\n    Right (Success v\') ->\n      case (parse parseJSON v\' :: Result HoodleClipInfo) of\n        Success hinfo -> return (Just hinfo)\n        _ -> return Nothing\n    _ -> return Nothing\n\nstartGet :: HoodleClipClientConfiguration -> String -> IO ()\nstartGet mc idee = do\n  putStrLn $ "get " ++ idee\n  let url = hoodleclipServerURL mc\n  r <- jsonFromServer url ("hoodleclip" </> idee) methodGet\n  -- putStrLn $ show r\n  case r of\n    Right v -> case v of\n      Success v\' -> putStrLn $ show (parse parseJSON v\' :: Result HoodleClipInfo)\n      _ -> return ()\n    Left _ -> return ()\n\n{-\nstartPut :: HoodleClipClientConfiguration\n         -> String  -- ^ hoodleclip idee\n         -> String  -- ^ hoodleclip name\n         -> IO ()\nstartPut mc idee jsonstr = do\n  putStrLn "job started"\n  cwd <- getCurrentDirectory\n  let url = hoodleclipServerURL mc\n  case A.parseOnly json (SC.pack jsonstr) of\n    Left str -> error str\n    Right jsonstrokes ->\n      case parse parseJSON jsonstrokes of\n        Error str2 -> error str2\n        Success strokes -> do\n          let info = case fromString idee of\n                       Nothing -> error "strange in startPut"\n                       Just idee\' -> HoodleClipInfo { hoodleclip_uuid = idee\'\n                                                      , hoodleclip_strokes = strokes }\n          response <- hoodleclipToServer url ("hoodleclip" </> idee) methodPut info\n          putStrLn $ show response\n-}\n\n{-\nstartDelete :: HoodleClipClientConfiguration -> String -> IO ()\nstartDelete mc idee = do\n  putStrLn "job started"\n  let url = hoodleclipServerURL mc\n  r <- jsonFromServer url ("hoodleclip" </> idee) methodDelete\n  putStrLn $ show r\n-}\n\nstartGetList :: HoodleClipClientConfiguration -> IO ()\nstartGetList mc = do\n  putStrLn "getlist: "\n  let url = hoodleclipServerURL mc\n  r <- jsonFromServer url ("listhoodleclip") methodGet\n  putStrLn $ show r\n\njsonFromServer :: Url -> String -> Method -> IO (Either String (Result Value))\njsonFromServer url api mthd = do\n  request <- parseUrl (url </> api)\n  withManager $ \\manager -> do\n    let requestjson =\n          request\n            { method = mthd,\n              requestHeaders = [("Accept", "application/json; charset=utf-8")]\n            }\n    r <- httpLbs requestjson manager\n    if statusCode r == 200\n      then return . parseJson . SC.concat . C.toChunks . responseBody $ r\n      else return (Left $ "status code : " ++ show (statusCode r))\n\nhoodleclipToServer :: Url -> String -> Method -> HoodleClipInfo -> IO (Either String (Result Value))\nhoodleclipToServer url api mthd mi = do\n  {-  let mijson = E.encode (toJSON mi)\n        strict_mijson = C.toChunks mijson\n    putStrLn $ show $ length strict_mijson\n    return $ Left "test" -}\n  -- Temporarily\n\n  request <- parseUrl (url </> api)\n  withManager $ \\manager -> do\n    let mijson = E.encode (toJSON mi)\n        myrequestbody = RequestBodyLBS mijson\n    let requestjson =\n          request\n            { method = mthd,\n              requestHeaders = [("Accept", "application/json; charset=utf-8")],\n              requestBody = myrequestbody\n            }\n    r <- httpLbs requestjson manager\n    if statusCode r == 200\n      then return . parseJson . SC.concat . C.toChunks . responseBody $ r\n      else return (Left $ "status code : " ++ show (statusCode r))\n\nparseJson :: (FromJSON a) => SC.ByteString -> Either String (Result a)\nparseJson bs =\n  let resultjson = trace (SC.unpack bs) $ A.parse json bs\n   in case resultjson of\n        (A.Done rest rjson) -> return (parse parseJSON rjson)\n        _ -> Left "parseJson"\n\ntestHoodleClipClientConfiguration =\n  HoodleClipClientConfiguration\n    { hoodleclipServerURL = "http://localhost:7800",\n      hoodleclipClientURL = "susy"\n    }\n\ncopyContentsToNetworkClipboard :: HoodleClipClientConfiguration -> Clipboard -> IO ()\ncopyContentsToNetworkClipboard ncconf clip = do\n  if not . isEmpty $ clip\n    then do\n      let strs = fmap gToStroke . getClipContents $ clip\n      startCreate ncconf strs\n    else putStrLn "no clipboard content"\n\ngetContentsFromNetworkClipboard :: HoodleClipClientConfiguration -> IO (Maybe Clipboard)\ngetContentsFromNetworkClipboard ncconf = do\n  r <- startCurrent ncconf\n  let mclip = fmap (Clipboard . fmap gFromStroke . hoodleclip_strokes) r\n  return mclip\n-}\n'