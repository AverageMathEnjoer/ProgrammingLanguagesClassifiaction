b'using System;\nusing System.Diagnostics;\nusing System.Text;\n\nusing Pgno = System.UInt32;\nusing u8 = System.Byte;\nusing u32 = System.UInt32;\n\nnamespace CS_SQLite3\n{\n  public partial class CSSQLite\n  {\n    /*\n    ** 2001 September 15\n    **\n    ** The author disclaims copyright to this source code.  In place of\n    ** a legal notice, here is a blessing:\n    **\n    **    May you do good and not evil.\n    **    May you find forgiveness for yourself and forgive others.\n    **    May you share freely, never taking more than you give.\n    **\n    *************************************************************************\n    ** This file contains C code routines that are called by the parser\n    ** to handle INSERT statements in SQLite.\n    **\n    ** $Id: insert.c,v 1.270 2009/07/24 17:58:53 danielk1977 Exp $\n    **\n    *************************************************************************\n    **  Included in SQLite3 port to C#-SQLite;  2008 Noah B Hart\n    **  C#-SQLite is an independent reimplementation of the SQLite software library\n    **\n    **  $Header$\n    *************************************************************************\n    */\n    //#include "sqliteInt.h"\n\n    /*\n    ** Generate code that will open a table for reading.\n    */\n    static void sqlite3OpenTable(\n    Parse p,       /* Generate code into this VDBE */\n    int iCur,       /* The cursor number of the table */\n    int iDb,        /* The database index in sqlite3.aDb[] */\n    Table pTab,    /* The table to be opened */\n    int opcode      /* OP_OpenRead or OP_OpenWrite */\n    )\n    {\n      Vdbe v;\n      if ( IsVirtual( pTab ) ) return;\n      v = sqlite3GetVdbe( p );\n      Debug.Assert( opcode == OP_OpenWrite || opcode == OP_OpenRead );\n      sqlite3TableLock( p, iDb, pTab.tnum, ( opcode == OP_OpenWrite ) ? (byte)1 : (byte)0, pTab.zName );\n      sqlite3VdbeAddOp3( v, opcode, iCur, pTab.tnum, iDb );\n      sqlite3VdbeChangeP4( v, -1, ( pTab.nCol ), P4_INT32 );//SQLITE_INT_TO_PTR( pTab.nCol ), P4_INT32 );\n      VdbeComment( v, "%s", pTab.zName );\n    }\n\n    /*\n    ** Set P4 of the most recently inserted opcode to a column affinity\n    ** string for index pIdx. A column affinity string has one character\n    ** for each column in the table, according to the affinity of the column:\n    **\n    **  Character      Column affinity\n    **  ------------------------------\n    **  \'a\'            TEXT\n    **  \'b\'            NONE\n    **  \'c\'            NUMERIC\n    **  \'d\'            INTEGER\n    **  \'e\'            REAL\n    **\n    ** An extra \'b\' is appended to the end of the string to cover the\n    ** rowid that appears as the last column in every index.\n    */\n    static void sqlite3IndexAffinityStr( Vdbe v, Index pIdx )\n    {\n      if ( pIdx.zColAff == null || pIdx.zColAff[0] == \'\\0\' )\n      {\n        /* The first time a column affinity string for a particular index is\n        ** required, it is allocated and populated here. It is then stored as\n        ** a member of the Index structure for subsequent use.\n        **\n        ** The column affinity string will eventually be deleted by\n        ** sqliteDeleteIndex() when the Index structure itself is cleaned\n        ** up.\n        */\n        int n;\n        Table pTab = pIdx.pTable;\n        sqlite3 db = sqlite3VdbeDb( v );\n        StringBuilder pIdx_zColAff = new StringBuilder( pIdx.nColumn + 2 );// (char *)sqlite3Malloc(pIdx->nColumn+2);\n        if ( pIdx_zColAff == null )\n        {\n  ////        db.mallocFailed = 1;\n          return;\n        }\n        for ( n = 0 ; n < pIdx.nColumn ; n++ )\n        {\n          pIdx_zColAff.Append( pTab.aCol[pIdx.aiColumn[n]].affinity );\n        }\n        pIdx_zColAff.Append( SQLITE_AFF_NONE );\n        pIdx_zColAff.Append( \'\\0\' );\n        pIdx.zColAff = pIdx_zColAff.ToString();\n      }\n      sqlite3VdbeChangeP4( v, -1, pIdx.zColAff, 0 );\n    }\n\n    /*\n    ** Set P4 of the most recently inserted opcode to a column affinity\n    ** string for table pTab. A column affinity string has one character\n    ** for each column indexed by the index, according to the affinity of the\n    ** column:\n    **\n    **  Character      Column affinity\n    **  ------------------------------\n    **  \'a\'            TEXT\n    **  \'b\'            NONE\n    **  \'c\'            NUMERIC\n    **  \'d\'            INTEGER\n    **  \'e\'            REAL\n    */\n    static void sqlite3TableAffinityStr( Vdbe v, Table pTab )\n    {\n      /* The first time a column affinity string for a particular table\n      ** is required, it is allocated and populated here. It is then\n      ** stored as a member of the Table structure for subsequent use.\n      **\n      ** The column affinity string will eventually be deleted by\n      ** sqlite3DeleteTable() when the Table structure itself is cleaned up.\n      */\n      if ( pTab.zColAff == null )\n      {\n        StringBuilder zColAff;\n        int i;\n        sqlite3 db = sqlite3VdbeDb( v );\n\n        zColAff = new StringBuilder( pTab.nCol + 1 );// (char*)sqlite3Malloc(db, pTab.nCol + 1);\n        if ( zColAff == null )\n        {\n  ////        db.mallocFailed = 1;\n          return;\n        }\n\n        for ( i = 0 ; i < pTab.nCol ; i++ )\n        {\n          zColAff.Append( pTab.aCol[i].affinity );\n        }\n        //zColAff.Append( \'\\0\' );\n\n        pTab.zColAff = zColAff.ToString();\n      }\n\n      sqlite3VdbeChangeP4( v, -1, pTab.zColAff, 0 );\n    }\n\n    /*\n    ** Return non-zero if the table pTab in database iDb or any of its indices\n    ** have been opened at any point in the VDBE program beginning at location\n    ** iStartAddr throught the end of the program.  This is used to see if\n    ** a statement of the form  "INSERT INTO <iDb, pTab> SELECT ..." can\n    ** run without using temporary table for the results of the SELECT.\n    */\n    static bool readsTable(Parse p, int iStartAddr, int iDb, Table pTab )\n    {\n      Vdbe v = sqlite3GetVdbe( p );\n      int i;\n      int iEnd = sqlite3VdbeCurrentAddr( v );\n#if !SQLITE_OMIT_VIRTUALTABLE\n  VTable pVTab = IsVirtual(pTab) ? sqlite3GetVTable(p,db, pTab) : null;\n#endif\n\n      for ( i = iStartAddr ; i < iEnd ; i++ )\n      {\n        VdbeOp pOp = sqlite3VdbeGetOp( v, i );\n        Debug.Assert( pOp != null );\n        if ( pOp.opcode == OP_OpenRead && pOp.p3 == iDb )\n        {\n          Index pIndex;\n          int tnum = pOp.p2;\n          if ( tnum == pTab.tnum )\n          {\n            return true;\n          }\n          for ( pIndex = pTab.pIndex ; pIndex != null ; pIndex = pIndex.pNext )\n          {\n            if ( tnum == pIndex.tnum )\n            {\n              return true;\n            }\n          }\n        }\n#if !SQLITE_OMIT_VIRTUALTABLE\nif( pOp.opcode==OP_VOpen && pOp.p4.pVtab==pVTab){\nDebug.Assert( pOp.p4.pVtab!=0 );\nDebug.Assert( pOp.p4type==P4_VTAB );\nreturn true;\n}\n#endif\n      }\n      return false;\n    }\n\n#if !SQLITE_OMIT_AUTOINCREMENT\n    /*\n** Locate or create an AutoincInfo structure associated with table pTab\n** which is in database iDb.  Return the register number for the register\n** that holds the maximum rowid.\n**\n** There is at most one AutoincInfo structure per table even if the\n** same table is autoincremented multiple times due to inserts within\n** triggers.  A new AutoincInfo structure is created if this is the\n** first use of table pTab.  On 2nd and subsequent uses, the original\n** AutoincInfo structure is used.\n**\n** Three memory locations are allocated:\n**\n**   (1)  Register to hold the name of the pTab table.\n**   (2)  Register to hold the maximum ROWID of pTab.\n**   (3)  Register to hold the rowid in sqlite_sequence of pTab\n**\n** The 2nd register is the one that is returned.  That is all the\n** insert routine needs to know about.\n*/\n    static int autoIncBegin(\n    Parse pParse,      /* Parsing context */\n    int iDb,            /* Index of the database holding pTab */\n    Table pTab         /* The table we are writing to */\n    )\n    {\n      int memId = 0;      /* Register holding maximum rowid */\n      if ( ( pTab.tabFlags & TF_Autoincrement ) != 0 )\n      {\n        AutoincInfo pInfo;\n\n        pInfo = pParse.pAinc;\n        while ( pInfo != null && pInfo.pTab != pTab ) { pInfo = pInfo.pNext; }\n        if ( pInfo == null )\n        {\n          pInfo = new AutoincInfo();//sqlite3DbMallocRaw(pParse.db, sizeof(*pInfo));\n          if ( pInfo == null ) return 0;\n          pInfo.pNext = pParse.pAinc;\n          pParse.pAinc = pInfo;\n          pInfo.pTab = pTab;\n          pInfo.iDb = iDb;\n          pParse.nMem++;                  /* Register to hold name of table */\n          pInfo.regCtr = ++pParse.nMem;  /* Max rowid register */\n          pParse.nMem++;                  /* Rowid in sqlite_sequence */\n        }\n        memId = pInfo.regCtr;\n      }\n      return memId;\n    }\n\n    /*\n    ** This routine generates code that will initialize all of the\n    ** register used by the autoincrement tracker.\n    */\n    static void sqlite3AutoincrementBegin( Parse pParse )\n    {\n      AutoincInfo p;            /* Information about an AUTOINCREMENT */\n      sqlite3 db = pParse.db;  /* The database connection */\n      Db pDb;                   /* Database only autoinc table */\n      int memId;                 /* Register holding max rowid */\n      int addr;                  /* A VDBE address */\n      Vdbe v = pParse.pVdbe;   /* VDBE under construction */\n\n      Debug.Assert( v != null );   /* We failed long ago if this is not so */\n      for ( p = pParse.pAinc ; p != null ; p = p.pNext )\n      {\n        pDb = db.aDb[p.iDb];\n        memId = p.regCtr;\n        sqlite3OpenTable( pParse, 0, p.iDb, pDb.pSchema.pSeqTab, OP_OpenRead );\n        addr = sqlite3VdbeCurrentAddr( v );\n        sqlite3VdbeAddOp4( v, OP_String8, 0, memId - 1, 0, p.pTab.zName, 0 );\n        sqlite3VdbeAddOp2( v, OP_Rewind, 0, addr + 9 );\n        sqlite3VdbeAddOp3( v, OP_Column, 0, 0, memId );\n        sqlite3VdbeAddOp3( v, OP_Ne, memId - 1, addr + 7, memId );\n        sqlite3VdbeChangeP5( v, SQLITE_JUMPIFNULL );\n        sqlite3VdbeAddOp2( v, OP_Rowid, 0, memId + 1 );\n        sqlite3VdbeAddOp3( v, OP_Column, 0, 1, memId );\n        sqlite3VdbeAddOp2( v, OP_Goto, 0, addr + 9 );\n        sqlite3VdbeAddOp2( v, OP_Next, 0, addr + 2 );\n        sqlite3VdbeAddOp2( v, OP_Integer, 0, memId );\n        sqlite3VdbeAddOp0( v, OP_Close );\n      }\n    }\n\n    /*\n    ** Update the maximum rowid for an autoincrement calculation.\n    **\n    ** This routine should be called when the top of the stack holds a\n    ** new rowid that is about to be inserted.  If that new rowid is\n    ** larger than the maximum rowid in the memId memory cell, then the\n    ** memory cell is updated.  The stack is unchanged.\n    */\n    static void autoIncStep( Parse pParse, int memId, int regRowid )\n    {\n      if ( memId > 0 )\n      {\n        sqlite3VdbeAddOp2( pParse.pVdbe, OP_MemMax, memId, regRowid );\n      }\n    }\n\n    /*\n    ** This routine generates the code needed to write autoincrement\n    ** maximum rowid values back into the sqlite_sequence register.\n    ** Every statement that might do an INSERT into an autoincrement\n    ** table (either directly or through triggers) needs to call this\n    ** routine just before the "exit" code.\n    */\n    static void sqlite3AutoincrementEnd( Parse pParse )\n    {\n      AutoincInfo p;\n      Vdbe v = pParse.pVdbe;\n      sqlite3 db = pParse.db;\n\n      Debug.Assert( v != null );\n      for ( p = pParse.pAinc ; p != null ; p = p.pNext )\n      {\n        Db pDb = db.aDb[p.iDb];\n        int j1, j2, j3, j4, j5;\n        int iRec;\n        int memId = p.regCtr;\n\n        iRec = sqlite3GetTempReg( pParse );\n        sqlite3OpenTable( pParse, 0, p.iDb, pDb.pSchema.pSeqTab, OP_OpenWrite );\n        j1 = sqlite3VdbeAddOp1( v, OP_NotNull, memId + 1 );\n        j2 = sqlite3VdbeAddOp0( v, OP_Rewind );\n        j3 = sqlite3VdbeAddOp3( v, OP_Column, 0, 0, iRec );\n        j4 = sqlite3VdbeAddOp3( v, OP_Eq, memId - 1, 0, iRec );\n        sqlite3VdbeAddOp2( v, OP_Next, 0, j3 );\n        sqlite3VdbeJumpHere( v, j2 );\n        sqlite3VdbeAddOp2( v, OP_NewRowid, 0, memId + 1 );\n        j5 = sqlite3VdbeAddOp0( v, OP_Goto );\n        sqlite3VdbeJumpHere( v, j4 );\n        sqlite3VdbeAddOp2( v, OP_Rowid, 0, memId + 1 );\n        sqlite3VdbeJumpHere( v, j1 );\n        sqlite3VdbeJumpHere( v, j5 );\n        sqlite3VdbeAddOp3( v, OP_MakeRecord, memId - 1, 2, iRec );\n        sqlite3VdbeAddOp3( v, OP_Insert, 0, iRec, memId + 1 );\n        sqlite3VdbeChangeP5( v, OPFLAG_APPEND );\n        sqlite3VdbeAddOp0( v, OP_Close );\n        sqlite3ReleaseTempReg( pParse, iRec );\n      }\n    }\n#else\n/*\n** If SQLITE_OMIT_AUTOINCREMENT is defined, then the three routines\n** above are all no-ops\n*/\n//# define autoIncBegin(A,B,C) (0)\n//# define autoIncStep(A,B,C)\n#endif // * SQLITE_OMIT_AUTOINCREMENT */\n\n\n    /* Forward declaration */\n    //static int xferOptimization(\n    //  Parse pParse,        /* Parser context */\n    //  Table pDest,         /* The table we are inserting into */\n    //  Select pSelect,      /* A SELECT statement to use as the data source */\n    //  int onError,          /* How to handle constraint errors */\n    //  int iDbDest           /* The database of pDest */\n    //);\n\n    /*\n    ** This routine is call to handle SQL of the following forms:\n    **\n    **    insert into TABLE (IDLIST) values(EXPRLIST)\n    **    insert into TABLE (IDLIST) select\n    **\n    ** The IDLIST following the table name is always optional.  If omitted,\n    ** then a list of all columns for the table is substituted.  The IDLIST\n    ** appears in the pColumn parameter.  pColumn is NULL if IDLIST is omitted.\n    **\n    ** The pList parameter holds EXPRLIST in the first form of the INSERT\n    ** statement above, and pSelect is NULL.  For the second form, pList is\n    ** NULL and pSelect is a pointer to the select statement used to generate\n    ** data for the insert.\n    **\n    ** The code generated follows one of four templates.  For a simple\n    ** select with data coming from a VALUES clause, the code executes\n    ** once straight down through.  Pseudo-code follows (we call this\n    ** the "1st template"):\n    **\n    **         open write cursor to <table> and its indices\n    **         puts VALUES clause expressions onto the stack\n    **         write the resulting record into <table>\n    **         cleanup\n    **\n    ** The three remaining templates assume the statement is of the form\n    **\n    **   INSERT INTO <table> SELECT ...\n    **\n    ** If the SELECT clause is of the restricted form "SELECT * FROM <table2>" -\n    ** in other words if the SELECT pulls all columns from a single table\n    ** and there is no WHERE or LIMIT or GROUP BY or ORDER BY clauses, and\n    ** if <table2> and <table1> are distinct tables but have identical\n    ** schemas, including all the same indices, then a special optimization\n    ** is invoked that copies raw records from <table2> over to <table1>.\n    ** See the xferOptimization() function for the implementation of this\n    ** template.  This is the 2nd template.\n    **\n    **         open a write cursor to <table>\n    **         open read cursor on <table2>\n    **         transfer all records in <table2> over to <table>\n    **         close cursors\n    **         foreach index on <table>\n    **           open a write cursor on the <table> index\n    **           open a read cursor on the corresponding <table2> index\n    **           transfer all records from the read to the write cursors\n    **           close cursors\n    **         end foreach\n    **\n    ** The 3rd template is for when the second template does not apply\n    ** and the SELECT clause does not read from <table> at any time.\n    ** The generated code follows this template:\n    **\n    **         EOF <- 0\n    **         X <- A\n    **         goto B\n    **      A: setup for the SELECT\n    **         loop over the rows in the SELECT\n    **           load values into registers R..R+n\n    **           yield X\n    **         end loop\n    **         cleanup after the SELECT\n    **         EOF <- 1\n    **         yield X\n    **         goto A\n    **      B: open write cursor to <table> and its indices\n    **      C: yield X\n    **         if EOF goto D\n    **         insert the select result into <table> from R..R+n\n    **         goto C\n    **      D: cleanup\n    **\n    ** The 4th template is used if the insert statement takes its\n    ** values from a SELECT but the data is being inserted into a table\n    ** that is also read as part of the SELECT.  In the third form,\n    ** we have to use a intermediate table to store the results of\n    ** the select.  The template is like this:\n    **\n    **         EOF <- 0\n    **         X <- A\n    **         goto B\n    **      A: setup for the SELECT\n    **         loop over the tables in the SELECT\n    **           load value into register R..R+n\n    **           yield X\n    **         end loop\n    **         cleanup after the SELECT\n    **         EOF <- 1\n    **         yield X\n    **         halt-error\n    **      B: open temp table\n    **      L: yield X\n    **         if EOF goto M\n    **         insert row from R..R+n into temp table\n    **         goto L\n    **      M: open write cursor to <table> and its indices\n    **         rewind temp table\n    **      C: loop over rows of intermediate table\n    **           transfer values form intermediate table into <table>\n    **         end loop\n    **      D: cleanup\n    */\n    // OVERLOADS, so I don\'t need to rewrite parse.c\n    static void sqlite3Insert( Parse pParse, SrcList pTabList, int null_3, int null_4, IdList pColumn, int onError )\n    { sqlite3Insert( pParse, pTabList, null, null, pColumn, onError ); }\n    static void sqlite3Insert( Parse pParse, SrcList pTabList, int null_3, Select pSelect, IdList pColumn, int onError )\n    { sqlite3Insert( pParse, pTabList, null, pSelect, pColumn, onError ); }\n    static void sqlite3Insert( Parse pParse, SrcList pTabList, ExprList pList, int null_4, IdList pColumn, int onError )\n    { sqlite3Insert( pParse, pTabList, pList, null, pColumn, onError ); }\n    static void sqlite3Insert(\n    Parse pParse,        /* Parser context */\n    SrcList pTabList,    /* Name of table into which we are inserting */\n    ExprList pList,      /* List of values to be inserted */\n    Select pSelect,      /* A SELECT statement to use as the data source */\n    IdList pColumn,      /* Column names corresponding to IDLIST. */\n    int onError        /* How to handle constraint errors */\n    )\n    {\n      sqlite3 db;           /* The main database structure */\n      Table pTab;           /* The table to insert into.  aka TABLE */\n      string zTab;          /* Name of the table into which we are inserting */\n      string zDb;           /* Name of the database holding this table */\n      int i = 0;\n      int j = 0;\n      int idx = 0;            /* Loop counters */\n      Vdbe v;               /* Generate code into this virtual machine */\n      Index pIdx;           /* For looping over indices of the table */\n      int nColumn;          /* Number of columns in the data */\n      int nHidden = 0;      /* Number of hidden columns if TABLE is virtual */\n      int baseCur = 0;      /* VDBE VdbeCursor number for pTab */\n      int keyColumn = -1;   /* Column that is the INTEGER PRIMARY KEY */\n      int endOfLoop = 0;      /* Label for the end of the insertion loop */\n      bool useTempTable = false; /* Store SELECT results in intermediate table */\n      int srcTab = 0;       /* Data comes from this temporary cursor if >=0 */\n      int addrInsTop = 0;   /* Jump to label "D" */\n      int addrCont = 0;     /* Top of insert loop. Label "C" in templates 3 and 4 */\n      int addrSelect = 0;   /* Address of coroutine that implements the SELECT */\n      SelectDest dest;      /* Destination for SELECT on rhs of INSERT */\n      int newIdx = -1;      /* VdbeCursor for the NEW pseudo-table */\n      int iDb;              /* Index of database holding TABLE */\n      Db pDb;               /* The database containing table being inserted into */\n      bool appendFlag = false;   /* True if the insert is likely to be an append */\n\n      /* Register allocations */\n      int regFromSelect = 0;  /* Base register for data coming from SELECT */\n      int regAutoinc = 0;   /* Register holding the AUTOINCREMENT counter */\n      int regRowCount = 0;  /* Memory cell used for the row counter */\n      int regIns;           /* Block of regs holding rowid+data being inserted */\n      int regRowid;         /* registers holding insert rowid */\n      int regData;          /* register holding first column to insert */\n      int regRecord;        /* Holds the assemblied row record */\n      int regEof = 0;       /* Register recording end of SELECT data */\n      int[] aRegIdx = null; /* One register allocated to each index */\n\n\n#if !SQLITE_OMIT_TRIGGER\n      bool isView = false;        /* True if attempting to insert into a view */\n      Trigger pTrigger;           /* List of triggers on pTab, if required */\n      int tmask = 0;              /* Mask of trigger times */\n#endif\n\n      db = pParse.db;\n      dest = new SelectDest();// memset( &dest, 0, sizeof( dest ) );\n\n      if ( pParse.nErr != 0 /*|| db.mallocFailed != 0 */ )\n      {\n        goto insert_cleanup;\n      }\n\n      /* Locate the table into which we will be inserting new information.\n      */\n      Debug.Assert( pTabList.nSrc == 1 );\n      zTab = pTabList.a[0].zName;\n      if ( NEVER( zTab == null ) ) goto insert_cleanup;\n      pTab = sqlite3SrcListLookup( pParse, pTabList );\n      if ( pTab == null )\n      {\n        goto insert_cleanup;\n      }\n      iDb = sqlite3SchemaToIndex( db, pTab.pSchema );\n      Debug.Assert( iDb < db.nDb );\n      pDb = db.aDb[iDb];\n      zDb = pDb.zName;\n#if !SQLITE_OMIT_AUTHORIZATION\nif( sqlite3AuthCheck(pParse, SQLITE_INSERT, pTab.zName, 0, zDb) ){\ngoto insert_cleanup;\n}\n#endif\n      /* Figure out if we have any triggers and if the table being\n** inserted into is a view\n*/\n#if !SQLITE_OMIT_TRIGGER\n      pTrigger = sqlite3TriggersExist( pParse, pTab, TK_INSERT, null, ref tmask );\n      isView = pTab.pSelect != null;\n#else\n//# define pTrigger 0\n//# define tmask 0\nbool isView = false;\n#endif\n#if  SQLITE_OMIT_VIEW\n//# undef isView\nisView = false;\n#endif\n      Debug.Assert( ( pTrigger != null && tmask != 0 ) || ( pTrigger == null && tmask == 0 ) );\n\n#if !SQLITE_OMIT_VIEW\n      /* If pTab is really a view, make sure it has been initialized.\n      ** ViewGetColumnNames() is a no-op if pTab is not a view (or virtual\n      ** module table).\n      */\n      if ( sqlite3ViewGetColumnNames( pParse, pTab ) != -0 )\n      {\n        goto insert_cleanup;\n      }\n#endif\n\n      /* Ensure that:\n      *  (a) the table is not read-only, \n      *  (b) that if it is a view then ON INSERT triggers exist\n      */\n      if ( sqlite3IsReadOnly( pParse, pTab, tmask ) )\n      {\n        goto insert_cleanup;\n      }\n\n      /* Allocate a VDBE\n      */\n      v = sqlite3GetVdbe( pParse );\n      if ( v == null ) goto insert_cleanup;\n      if ( pParse.nested == 0 ) sqlite3VdbeCountChanges( v );\n      sqlite3BeginWriteOperation( pParse, ( pSelect != null || pTrigger != null ) ? 1 : 0, iDb );\n\n      /* if there are row triggers, allocate a temp table for new.* references. */\n      if ( pTrigger != null )\n      {\n        newIdx = pParse.nTab++;\n      }\n\n#if !SQLITE_OMIT_XFER_OPT\n      /* If the statement is of the form\n**\n**       INSERT INTO <table1> SELECT * FROM <table2>;\n**\n** Then special optimizations can be applied that make the transfer\n** very fast and which reduce fragmentation of indices.\n**\n** This is the 2nd template.\n*/\n      if ( pColumn == null && xferOptimization( pParse, pTab, pSelect, onError, iDb ) != 0 )\n      {\n        Debug.Assert( null == pTrigger );\n        Debug.Assert( pList == null );\n        goto insert_end;\n      }\n#endif // * SQLITE_OMIT_XFER_OPT */\n\n      /* If this is an AUTOINCREMENT table, look up the sequence number in the\n** sqlite_sequence table and store it in memory cell regAutoinc.\n*/\n      regAutoinc = autoIncBegin( pParse, iDb, pTab );\n\n      /* Figure out how many columns of data are supplied.  If the data\n      ** is coming from a SELECT statement, then generate a co-routine that\n      ** produces a single row of the SELECT on each invocation.  The\n      ** co-routine is the common header to the 3rd and 4th templates.\n      */\n      if ( pSelect != null )\n      {\n        /* Data is coming from a SELECT.  Generate code to implement that SELECT\n        ** as a co-routine.  The code is common to both the 3rd and 4th\n        ** templates:\n        **\n        **         EOF <- 0\n        **         X <- A\n        **         goto B\n        **      A: setup for the SELECT\n        **         loop over the tables in the SELECT\n        **           load value into register R..R+n\n        **           yield X\n        **         end loop\n        **         cleanup after the SELECT\n        **         EOF <- 1\n        **         yield X\n        **         halt-error\n        **\n        ** On each invocation of the co-routine, it puts a single row of the\n        ** SELECT result into registers dest.iMem...dest.iMem+dest.nMem-1.\n        ** (These output registers are allocated by sqlite3Select().)  When\n        ** the SELECT completes, it sets the EOF flag stored in regEof.\n        */\n        int rc = 0, j1;\n\n        regEof = ++pParse.nMem;\n        sqlite3VdbeAddOp2( v, OP_Integer, 0, regEof );      /* EOF <- 0 */\n#if SQLITE_DEBUG\n        VdbeComment( v, "SELECT eof flag" );\n#endif\n        sqlite3SelectDestInit( dest, SRT_Coroutine, ++pParse.nMem );\n        addrSelect = sqlite3VdbeCurrentAddr( v ) + 2;\n        sqlite3VdbeAddOp2( v, OP_Integer, addrSelect - 1, dest.iParm );\n        j1 = sqlite3VdbeAddOp2( v, OP_Goto, 0, 0 );\n#if SQLITE_DEBUG\n        VdbeComment( v, "Jump over SELECT coroutine" );\n#endif\n        /* Resolve the expressions in the SELECT statement and execute it. */\n        rc = sqlite3Select( pParse, pSelect, ref dest );\n        Debug.Assert( pParse.nErr == 0 || rc != 0 );\n        if ( rc != 0 || NEVER( pParse.nErr != 0 ) /*|| db.mallocFailed != 0 */ )\n        {\n          goto insert_cleanup;\n        }\n        sqlite3VdbeAddOp2( v, OP_Integer, 1, regEof );         /* EOF <- 1 */\n        sqlite3VdbeAddOp1( v, OP_Yield, dest.iParm );   /* yield X */\n        sqlite3VdbeAddOp2( v, OP_Halt, SQLITE_INTERNAL, OE_Abort );\n#if SQLITE_DEBUG\n        VdbeComment( v, "End of SELECT coroutine" );\n#endif\n        sqlite3VdbeJumpHere( v, j1 );                          /* label B: */\n\n        regFromSelect = dest.iMem;\n        Debug.Assert( pSelect.pEList != null );\n        nColumn = pSelect.pEList.nExpr;\n        Debug.Assert( dest.nMem == nColumn );\n\n        /* Set useTempTable to TRUE if the result of the SELECT statement\n        ** should be written into a temporary table (template 4).  Set to\n        ** FALSE if each* row of the SELECT can be written directly into\n        ** the destination table (template 3).\n        **\n        ** A temp table must be used if the table being updated is also one\n        ** of the tables being read by the SELECT statement.  Also use a\n        ** temp table in the case of row triggers.\n        */\n        if ( pTrigger != null || readsTable( pParse, addrSelect, iDb, pTab ) )\n        {\n          useTempTable = true;\n        }\n\n        if ( useTempTable )\n        {\n          /* Invoke the coroutine to extract information from the SELECT\n          ** and add it to a transient table srcTab.  The code generated\n          ** here is from the 4th template:\n          **\n          **      B: open temp table\n          **      L: yield X\n          **         if EOF goto M\n          **         insert row from R..R+n into temp table\n          **         goto L\n          **      M: ...\n          */\n          int regRec;      /* Register to hold packed record */\n          int regTempRowid;    /* Register to hold temp table ROWID */\n          int addrTop;     /* Label "L" */\n          int addrIf;      /* Address of jump to M */\n\n          srcTab = pParse.nTab++;\n          regRec = sqlite3GetTempReg( pParse );\n          regTempRowid = sqlite3GetTempReg( pParse );\n          sqlite3VdbeAddOp2( v, OP_OpenEphemeral, srcTab, nColumn );\n          addrTop = sqlite3VdbeAddOp1( v, OP_Yield, dest.iParm );\n          addrIf = sqlite3VdbeAddOp1( v, OP_If, regEof );\n          sqlite3VdbeAddOp3( v, OP_MakeRecord, regFromSelect, nColumn, regRec );\n          sqlite3VdbeAddOp2( v, OP_NewRowid, srcTab, regTempRowid );\n          sqlite3VdbeAddOp3( v, OP_Insert, srcTab, regRec, regTempRowid );\n          sqlite3VdbeAddOp2( v, OP_Goto, 0, addrTop );\n          sqlite3VdbeJumpHere( v, addrIf );\n          sqlite3ReleaseTempReg( pParse, regRec );\n          sqlite3ReleaseTempReg( pParse, regTempRowid );\n        }\n      }\n      else\n      {\n        /* This is the case if the data for the INSERT is coming from a VALUES\n        ** clause\n        */\n        NameContext sNC;\n        sNC = new NameContext();// memset( &sNC, 0, sNC ).Length;\n        sNC.pParse = pParse;\n        srcTab = -1;\n        Debug.Assert( !useTempTable );\n        nColumn = pList != null ? pList.nExpr : 0;\n        for ( i = 0 ; i < nColumn ; i++ )\n        {\n          if ( sqlite3ResolveExprNames( sNC, ref pList.a[i].pExpr ) != 0 )\n          {\n            goto insert_cleanup;\n          }\n        }\n      }\n\n      /* Make sure the number of columns in the source data matches the number\n      ** of columns to be inserted into the table.\n      */\n      if ( IsVirtual( pTab ) )\n      {\n        for ( i = 0 ; i < pTab.nCol ; i++ )\n        {\n          nHidden += ( IsHiddenColumn( pTab.aCol[i] ) ? 1 : 0 );\n        }\n      }\n      if ( pColumn == null && nColumn != 0 && nColumn != ( pTab.nCol - nHidden ) )\n      {\n        sqlite3ErrorMsg( pParse,\n        "table %S has %d columns but %d values were supplied",\n        pTabList, 0, pTab.nCol - nHidden, nColumn );\n        goto insert_cleanup;\n      }\n      if ( pColumn != null && nColumn != pColumn.nId )\n      {\n        sqlite3ErrorMsg( pParse, "%d values for %d columns", nColumn, pColumn.nId );\n        goto insert_cleanup;\n      }\n\n      /* If the INSERT statement included an IDLIST term, then make sure\n      ** all elements of the IDLIST really are columns of the table and\n      ** remember the column indices.\n      **\n      ** If the table has an INTEGER PRIMARY KEY column and that column\n      ** is named in the IDLIST, then record in the keyColumn variable\n      ** the index into IDLIST of the primary key column.  keyColumn is\n      ** the index of the primary key as it appears in IDLIST, not as\n      ** is appears in the original table.  (The index of the primary\n      ** key in the original table is pTab.iPKey.)\n      */\n      if ( pColumn != null )\n      {\n        for ( i = 0 ; i < pColumn.nId ; i++ )\n        {\n          pColumn.a[i].idx = -1;\n        }\n        for ( i = 0 ; i < pColumn.nId ; i++ )\n        {\n          for ( j = 0 ; j < pTab.nCol ; j++ )\n          {\n            if ( sqlite3StrICmp( pColumn.a[i].zName, pTab.aCol[j].zName ) == 0 )\n            {\n              pColumn.a[i].idx = j;\n              if ( j == pTab.iPKey )\n              {\n                keyColumn = i;\n              }\n              break;\n            }\n          }\n          if ( j >= pTab.nCol )\n          {\n            if ( sqlite3IsRowid( pColumn.a[i].zName ) )\n            {\n              keyColumn = i;\n            }\n            else\n            {\n              sqlite3ErrorMsg( pParse, "table %S has no column named %s",\n              pTabList, 0, pColumn.a[i].zName );\n              pParse.nErr++;\n              goto insert_cleanup;\n            }\n          }\n        }\n      }\n\n      /* If there is no IDLIST term but the table has an integer primary\n      ** key, the set the keyColumn variable to the primary key column index\n      ** in the original table definition.\n      */\n      if ( pColumn == null && nColumn > 0 )\n      {\n        keyColumn = pTab.iPKey;\n      }\n\n      /* Open the temp table for FOR EACH ROW triggers\n      */\n      if ( pTrigger != null )\n      {\n        sqlite3VdbeAddOp3( v, OP_OpenPseudo, newIdx, 0, pTab.nCol );\n      }\n\n      /* Initialize the count of rows to be inserted\n      */\n      if ( ( db.flags & SQLITE_CountRows ) != 0 )\n      {\n        regRowCount = ++pParse.nMem;\n        sqlite3VdbeAddOp2( v, OP_Integer, 0, regRowCount );\n      }\n\n      /* If this is not a view, open the table and and all indices */\n      if ( !isView )\n      {\n        int nIdx;\n\n        baseCur = pParse.nTab;\n        nIdx = sqlite3OpenTableAndIndices( pParse, pTab, baseCur, OP_OpenWrite );\n        aRegIdx = new int[nIdx + 1];// sqlite3DbMallocRaw( db, sizeof( int ) * ( nIdx + 1 ) );\n        if ( aRegIdx == null )\n        {\n          goto insert_cleanup;\n        }\n        for ( i = 0 ; i < nIdx ; i++ )\n        {\n          aRegIdx[i] = ++pParse.nMem;\n        }\n      }\n\n      /* This is the top of the main insertion loop */\n      if ( useTempTable )\n      {\n        /* This block codes the top of loop only.  The complete loop is the\n        ** following pseudocode (template 4):\n        **\n        **         rewind temp table\n        **      C: loop over rows of intermediate table\n        **           transfer values form intermediate table into <table>\n        **         end loop\n        **      D: ...\n        */\n        addrInsTop = sqlite3VdbeAddOp1( v, OP_Rewind, srcTab );\n        addrCont = sqlite3VdbeCurrentAddr( v );\n      }\n      else if ( pSelect != null )\n      {\n        /* This block codes the top of loop only.  The complete loop is the\n        ** following pseudocode (template 3):\n        **\n        **      C: yield X\n        **         if EOF goto D\n        **         insert the select result into <table> from R..R+n\n        **         goto C\n        **      D: ...\n        */\n        addrCont = sqlite3VdbeAddOp1( v, OP_Yield, dest.iParm );\n        addrInsTop = sqlite3VdbeAddOp1( v, OP_If, regEof );\n      }\n\n      /* Allocate registers for holding the rowid of the new row,\n      ** the content of the new row, and the assemblied row record.\n      */\n      regRecord = ++pParse.nMem;\n      regRowid = regIns = pParse.nMem + 1;\n      pParse.nMem += pTab.nCol + 1;\n      if ( IsVirtual( pTab ) )\n      {\n        regRowid++;\n        pParse.nMem++;\n      }\n      regData = regRowid + 1;\n\n      /* Run the BEFORE and INSTEAD OF triggers, if there are any\n      */\n      endOfLoop = sqlite3VdbeMakeLabel( v );\n#if !SQLITE_OMIT_TRIGGER\n      if ( ( tmask & TRIGGER_BEFORE ) != 0 )\n      {\n        int regTrigRowid;\n        int regCols;\n        int regRec;\n\n        /* build the NEW.* reference row.  Note that if there is an INTEGER\n        ** PRIMARY KEY into which a NULL is being inserted, that NULL will be\n        ** translated into a unique ID for the row.  But on a BEFORE trigger,\n        ** we do not know what the unique ID will be (because the insert has\n        ** not happened yet) so we substitute a rowid of -1\n        */\n        regTrigRowid = sqlite3GetTempReg( pParse );\n        if ( keyColumn < 0 )\n        {\n          sqlite3VdbeAddOp2( v, OP_Integer, -1, regTrigRowid );\n        }\n        else\n        {\n          int j1;\n          if ( useTempTable )\n          {\n            sqlite3VdbeAddOp3( v, OP_Column, srcTab, keyColumn, regTrigRowid );\n          }\n          else\n          {\n            Debug.Assert( pSelect == null );  /* Otherwise useTempTable is true */\n            sqlite3ExprCode( pParse, pList.a[keyColumn].pExpr, regTrigRowid );\n          }\n          j1 = sqlite3VdbeAddOp1( v, OP_NotNull, regTrigRowid );\n          sqlite3VdbeAddOp2( v, OP_Integer, -1, regTrigRowid );\n          sqlite3VdbeJumpHere( v, j1 );\n          sqlite3VdbeAddOp1( v, OP_MustBeInt, regTrigRowid );\n        }\n        /* Cannot have triggers on a virtual table. If it were possible,\n        ** this block would have to account for hidden column.\n        */\n        Debug.Assert( !IsVirtual( pTab ) );\n        /* Create the new column data\n        */\n        regCols = sqlite3GetTempRange( pParse, pTab.nCol );\n        for ( i = 0 ; i < pTab.nCol ; i++ )\n        {\n          if ( pColumn == null )\n          {\n            j = i;\n          }\n          else\n          {\n            for ( j = 0 ; j < pColumn.nId ; j++ )\n            {\n              if ( pColumn.a[j].idx == i ) break;\n            }\n          }\n          if ( pColumn != null && j >= pColumn.nId )\n          {\n            sqlite3ExprCode( pParse, pTab.aCol[i].pDflt, regCols + i );\n          }\n          else if ( useTempTable )\n          {\n            sqlite3VdbeAddOp3( v, OP_Column, srcTab, j, regCols + i );\n          }\n          else\n          {\n            Debug.Assert( pSelect == null ); /* Otherwise useTempTable is true */\n            sqlite3ExprCodeAndCache( pParse, pList.a[j].pExpr, regCols + i );\n          }\n        }\n        regRec = sqlite3GetTempReg( pParse );\n        sqlite3VdbeAddOp3( v, OP_MakeRecord, regCols, pTab.nCol, regRec );\n\n        /* If this is an INSERT on a view with an INSTEAD OF INSERT trigger,\n        ** do not attempt any conversions before assembling the record.\n        ** If this is a real table, attempt conversions as required by the\n        ** table column affinities.\n        */\n        if ( !isView )\n        {\n          sqlite3TableAffinityStr( v, pTab );\n        }\n        sqlite3VdbeAddOp3( v, OP_Insert, newIdx, regRec, regTrigRowid );\n        sqlite3ReleaseTempReg( pParse, regRec );\n        sqlite3ReleaseTempReg( pParse, regTrigRowid );\n        sqlite3ReleaseTempRange( pParse, regCols, pTab.nCol );\n\n        /* Fire BEFORE or INSTEAD OF triggers */\n        u32 Ref0_1 = 0;\n        u32 Ref0_2 = 0;\n        if ( sqlite3CodeRowTrigger( pParse, pTrigger, TK_INSERT, null, TRIGGER_BEFORE,\n        pTab, newIdx, -1, onError, endOfLoop, ref Ref0_1, ref Ref0_2 ) != 0 )\n        {\n          goto insert_cleanup;\n        }\n      }\n#endif\n\n      /* Push the record number for the new entry onto the stack.  The\n** record number is a randomly generate integer created by NewRowid\n** except when the table has an INTEGER PRIMARY KEY column, in which\n** case the record number is the same as that column.\n*/\n      if ( !isView )\n      {\n        if ( IsVirtual( pTab ) )\n        {\n          /* The row that the VUpdate opcode will delete: none */\n          sqlite3VdbeAddOp2( v, OP_Null, 0, regIns );\n        }\n        if ( keyColumn >= 0 )\n        {\n          if ( useTempTable )\n          {\n            sqlite3VdbeAddOp3( v, OP_Column, srcTab, keyColumn, regRowid );\n          }\n          else if ( pSelect != null )\n          {\n            sqlite3VdbeAddOp2( v, OP_SCopy, regFromSelect + keyColumn, regRowid );\n          }\n          else\n          {\n            VdbeOp pOp;\n            sqlite3ExprCode( pParse, pList.a[keyColumn].pExpr, regRowid );\n            pOp = sqlite3VdbeGetOp( v, -1 );\n            if ( ALWAYS( pOp != null ) && pOp.opcode == OP_Null && !IsVirtual( pTab ) )\n            {\n              appendFlag = true;\n              pOp.opcode = OP_NewRowid;\n              pOp.p1 = baseCur;\n              pOp.p2 = regRowid;\n              pOp.p3 = regAutoinc;\n            }\n          }\n          /* If the PRIMARY KEY expression is NULL, then use OP_NewRowid\n          ** to generate a unique primary key value.\n          */\n          if ( !appendFlag )\n          {\n            int j1;\n            if ( !IsVirtual( pTab ) )\n            {\n              j1 = sqlite3VdbeAddOp1( v, OP_NotNull, regRowid );\n              sqlite3VdbeAddOp3( v, OP_NewRowid, baseCur, regRowid, regAutoinc );\n              sqlite3VdbeJumpHere( v, j1 );\n            }\n            else\n            {\n              j1 = sqlite3VdbeCurrentAddr( v );\n              sqlite3VdbeAddOp2( v, OP_IsNull, regRowid, j1 + 2 );\n            }\n            sqlite3VdbeAddOp1( v, OP_MustBeInt, regRowid );\n          }\n        }\n        else if ( IsVirtual( pTab ) )\n        {\n          sqlite3VdbeAddOp2( v, OP_Null, 0, regRowid );\n        }\n        else\n        {\n          sqlite3VdbeAddOp3( v, OP_NewRowid, baseCur, regRowid, regAutoinc );\n          appendFlag = true;\n        }\n        autoIncStep( pParse, regAutoinc, regRowid );\n\n        /* Push onto the stack, data for all columns of the new entry, beginning\n        ** with the first column.\n        */\n        nHidden = 0;\n        for ( i = 0 ; i < pTab.nCol ; i++ )\n        {\n          int iRegStore = regRowid + 1 + i;\n          if ( i == pTab.iPKey )\n          {\n            /* The value of the INTEGER PRIMARY KEY column is always a NULL.\n            ** Whenever this column is read, the record number will be substituted\n            ** in its place.  So will fill this column with a NULL to avoid\n            ** taking up data space with information that will never be used. */\n            sqlite3VdbeAddOp2( v, OP_Null, 0, iRegStore );\n            continue;\n          }\n          if ( pColumn == null )\n          {\n            if ( IsHiddenColumn( pTab.aCol[i] ) )\n            {\n              Debug.Assert( IsVirtual( pTab ) );\n              j = -1;\n              nHidden++;\n            }\n            else\n            {\n              j = i - nHidden;\n            }\n          }\n          else\n          {\n            for ( j = 0 ; j < pColumn.nId ; j++ )\n            {\n              if ( pColumn.a[j].idx == i ) break;\n            }\n          }\n          if ( j < 0 || nColumn == 0 || ( pColumn != null && j >= pColumn.nId ) )\n          {\n            sqlite3ExprCode( pParse, pTab.aCol[i].pDflt, iRegStore );\n          }\n          else if ( useTempTable )\n          {\n            sqlite3VdbeAddOp3( v, OP_Column, srcTab, j, iRegStore );\n          }\n          else if ( pSelect != null )\n          {\n            sqlite3VdbeAddOp2( v, OP_SCopy, regFromSelect + j, iRegStore );\n          }\n          else\n          {\n            sqlite3ExprCode( pParse, pList.a[j].pExpr, iRegStore );\n          }\n        }\n\n        /* Generate code to check constraints and generate index keys and\n        ** do the insertion.\n        */\n#if !SQLITE_OMIT_VIRTUALTABLE\n    if( IsVirtual(pTab) ){\n      const char *pVTab = (const char *)sqlite3GetVTable(db, pTab);\n      sqlite3VtabMakeWritable(pParse, pTab);\n      sqlite3VdbeAddOp4(v, OP_VUpdate, 1, pTab->nCol+2, regIns, pVTab, P4_VTAB);\n    }else\n#endif\n        {\n          int isReplace = 0;    /* Set to true if constraints may cause a replace */\n          sqlite3GenerateConstraintChecks( pParse, pTab, baseCur, regIns, aRegIdx,\n          keyColumn >= 0, false, onError, endOfLoop, ref isReplace\n          );\n          sqlite3CompleteInsertion(\n          pParse, pTab, baseCur, regIns, aRegIdx, false,\n          ( tmask & TRIGGER_AFTER ) != 0 ? newIdx : -1, appendFlag, isReplace == 0\n          );\n        }\n      }\n\n      /* Update the count of rows that are inserted\n      */\n      if ( ( db.flags & SQLITE_CountRows ) != 0 )\n      {\n        sqlite3VdbeAddOp2( v, OP_AddImm, regRowCount, 1 );\n      }\n\n#if !SQLITE_OMIT_TRIGGER\n      if ( pTrigger != null )\n      {\n        /* Code AFTER triggers */\n        u32 Ref0_1 = 0;\n        u32 Ref0_2 = 0;\n        if ( sqlite3CodeRowTrigger( pParse, pTrigger, TK_INSERT, null, TRIGGER_AFTER,\n        pTab, newIdx, -1, onError, endOfLoop, ref Ref0_1, ref Ref0_2 ) != 0 )\n        {\n          goto insert_cleanup;\n        }\n      }\n#endif\n\n      /* The bottom of the main insertion loop, if the data source\n** is a SELECT statement.\n*/\n      sqlite3VdbeResolveLabel( v, endOfLoop );\n      if ( useTempTable )\n      {\n        sqlite3VdbeAddOp2( v, OP_Next, srcTab, addrCont );\n        sqlite3VdbeJumpHere( v, addrInsTop );\n        sqlite3VdbeAddOp1( v, OP_Close, srcTab );\n      }\n      else if ( pSelect != null )\n      {\n        sqlite3VdbeAddOp2( v, OP_Goto, 0, addrCont );\n        sqlite3VdbeJumpHere( v, addrInsTop );\n      }\n\n      if ( !IsVirtual( pTab ) && !isView )\n      {\n        /* Close all tables opened */\n        sqlite3VdbeAddOp1( v, OP_Close, baseCur );\n        for ( idx = 1, pIdx = pTab.pIndex ; pIdx != null ; pIdx = pIdx.pNext, idx++ )\n        {\n          sqlite3VdbeAddOp1( v, OP_Close, idx + baseCur );\n        }\n      }\n\ninsert_end:\n      /* Update the sqlite_sequence table by storing the content of the\n      ** maximum rowid counter values recorded while inserting into\n      ** autoincrement tables.\n      */\n      if ( pParse.nested == 0 && pParse.trigStack == null )\n      {\n        sqlite3AutoincrementEnd( pParse );\n      }\n\n      /*\n      ** Return the number of rows inserted. If this routine is\n      ** generating code because of a call to sqlite3NestedParse(), do not\n      ** invoke the callback function.\n      */\n      if ( ( db.flags & SQLITE_CountRows ) != 0 && pParse.nested == 0 && pParse.trigStack == null )\n      {\n        sqlite3VdbeAddOp2( v, OP_ResultRow, regRowCount, 1 );\n        sqlite3VdbeSetNumCols( v, 1 );\n        sqlite3VdbeSetColName( v, 0, COLNAME_NAME, "rows inserted", SQLITE_STATIC );\n      }\n\ninsert_cleanup:\n      sqlite3SrcListDelete( db, ref pTabList );\n      sqlite3ExprListDelete( db, ref pList );\n      sqlite3SelectDelete( db, ref pSelect );\n      sqlite3IdListDelete( db, ref pColumn );\n      //sqlite3DbFree( db, ref aRegIdx );\n    }\n\n    /*\n    ** Generate code to do constraint checks prior to an INSERT or an UPDATE.\n    **\n    ** The input is a range of consecutive registers as follows:\n    **\n    **    1.  The rowid of the row to be updated before the update.  This\n    **        value is omitted unless we are doing an UPDATE that involves a\n    **        change to the record number or writing to a virtual table.\n    **\n    **    2.  The rowid of the row after the update.\n    **\n    **    3.  The data in the first column of the entry after the update.\n    **\n    **    i.  Data from middle columns...\n    **\n    **    N.  The data in the last column of the entry after the update.\n    **\n    ** The regRowid parameter is the index of the register containing (2).\n    **\n    ** The old rowid shown as entry (1) above is omitted unless both isUpdate\n    ** and rowidChng are 1.  isUpdate is true for UPDATEs and false for\n    ** INSERTs.  RowidChng means that the new rowid is explicitly specified by\n    ** the update or insert statement.  If rowidChng is false, it means that\n    ** the rowid is computed automatically in an insert or that the rowid value\n    ** is not modified by the update.\n    **\n    ** The code generated by this routine store new index entries into\n    ** registers identified by aRegIdx[].  No index entry is created for\n    ** indices where aRegIdx[i]==0.  The order of indices in aRegIdx[] is\n    ** the same as the order of indices on the linked list of indices\n    ** attached to the table.\n    **\n    ** This routine also generates code to check constraints.  NOT NULL,\n    ** CHECK, and UNIQUE constraints are all checked.  If a constraint fails,\n    ** then the appropriate action is performed.  There are five possible\n    ** actions: ROLLBACK, ABORT, FAIL, REPLACE, and IGNORE.\n    **\n    **  Constraint type  Action       What Happens\n    **  ---------------  ----------   ----------------------------------------\n    **  any              ROLLBACK     The current transaction is rolled back and\n    **                                sqlite3_exec() returns immediately with a\n    **                                return code of SQLITE_CONSTRAINT.\n    **\n    **  any              ABORT        Back out changes from the current command\n    **                                only (do not do a complete rollback) then\n    **                                cause sqlite3_exec() to return immediately\n    **                                with SQLITE_CONSTRAINT.\n    **\n    **  any              FAIL         Sqlite_exec() returns immediately with a\n    **                                return code of SQLITE_CONSTRAINT.  The\n    **                                transaction is not rolled back and any\n    **                                prior changes are retained.\n    **\n    **  any              IGNORE       The record number and data is popped from\n    **                                the stack and there is an immediate jump\n    **                                to label ignoreDest.\n    **\n    **  NOT NULL         REPLACE      The NULL value is replace by the default\n    **                                value for that column.  If the default value\n    **                                is NULL, the action is the same as ABORT.\n    **\n    **  UNIQUE           REPLACE      The other row that conflicts with the row\n    **                                being inserted is removed.\n    **\n    **  CHECK            REPLACE      Illegal.  The results in an exception.\n    **\n    ** Which action to take is determined by the overrideError parameter.\n    ** Or if overrideError==OE_Default, then the pParse.onError parameter\n    ** is used.  Or if pParse.onError==OE_Default then the onError value\n    ** for the constraint is used.\n    **\n    ** The calling routine must open a read/write cursor for pTab with\n    ** cursor number "baseCur".  All indices of pTab must also have open\n    ** read/write cursors with cursor number baseCur+i for the i-th cursor.\n    ** Except, if there is no possibility of a REPLACE action then\n    ** cursors do not need to be open for indices where aRegIdx[i]==0.\n    */\n    static void sqlite3GenerateConstraintChecks(\n    Parse pParse,       /* The parser context */\n    Table pTab,         /* the table into which we are inserting */\n    int baseCur,        /* Index of a read/write cursor pointing at pTab */\n    int regRowid,       /* Index of the range of input registers */\n    int[] aRegIdx,      /* Register used by each index.  0 for unused indices */\n    bool rowidChng,     /* True if the rowid might collide with existing entry */\n    bool isUpdate,      /* True for UPDATE, False for INSERT */\n    int overrideError,  /* Override onError to this if not OE_Default */\n    int ignoreDest,     /* Jump to this label on an OE_Ignore resolution */\n    ref int pbMayReplace   /* OUT: Set to true if constraint may cause a replace */\n    )\n    {\n\n      int i;               /* loop counter */\n      Vdbe v;              /* VDBE under constrution */\n      int nCol;            /* Number of columns */\n      int onError;         /* Conflict resolution strategy */\n      int j1;              /* Addresss of jump instruction */\n      int j2 = 0, j3;      /* Addresses of jump instructions */\n      int regData;         /* Register containing first data column */\n      int iCur;            /* Table cursor number */\n      Index pIdx;         /* Pointer to one of the indices */\n      bool seenReplace = false; /* True if REPLACE is used to resolve INT PK conflict */\n      bool hasTwoRowids = ( isUpdate && rowidChng );\n\n      v = sqlite3GetVdbe( pParse );\n      Debug.Assert( v != null );\n      Debug.Assert( pTab.pSelect == null );  /* This table is not a VIEW */\n      nCol = pTab.nCol;\n      regData = regRowid + 1;\n\n\n      /* Test all NOT NULL constraints.\n      */\n      for ( i = 0 ; i < nCol ; i++ )\n      {\n        if ( i == pTab.iPKey )\n        {\n          continue;\n        }\n        onError = pTab.aCol[i].notNull;\n        if ( onError == OE_None ) continue;\n        if ( overrideError != OE_Default )\n        {\n          onError = overrideError;\n        }\n        else if ( onError == OE_Default )\n        {\n          onError = OE_Abort;\n        }\n        if ( onError == OE_Replace && pTab.aCol[i].pDflt == null )\n        {\n          onError = OE_Abort;\n        }\n        Debug.Assert( onError == OE_Rollback || onError == OE_Abort || onError == OE_Fail\n        || onError == OE_Ignore || onError == OE_Replace );\n        switch ( onError )\n        {\n          case OE_Rollback:\n          case OE_Abort:\n          case OE_Fail:\n            {\n              string zMsg;\n              j1 = sqlite3VdbeAddOp3( v, OP_HaltIfNull,\n                          SQLITE_CONSTRAINT, onError, regData + i );\n              zMsg = sqlite3MPrintf( pParse.db, "%s.%s may not be NULL",\n              pTab.zName, pTab.aCol[i].zName );\n              sqlite3VdbeChangeP4( v, -1, zMsg, P4_DYNAMIC );\n              break;\n            }\n          case OE_Ignore:\n            {\n              sqlite3VdbeAddOp2( v, OP_IsNull, regData + i, ignoreDest );\n              break;\n            }\n          default:\n            {\n              Debug.Assert( onError == OE_Replace );\n              j1 = sqlite3VdbeAddOp1( v, OP_NotNull, regData + i );\n              sqlite3ExprCode( pParse, pTab.aCol[i].pDflt, regData + i );\n              sqlite3VdbeJumpHere( v, j1 );\n              break;\n            }\n        }\n      }\n\n      /* Test all CHECK constraints\n      */\n#if !SQLITE_OMIT_CHECK\n      if ( pTab.pCheck != null && ( pParse.db.flags & SQLITE_IgnoreChecks ) == 0 )\n      {\n        int allOk = sqlite3VdbeMakeLabel( v );\n        pParse.ckBase = regData;\n        sqlite3ExprIfTrue( pParse, pTab.pCheck, allOk, SQLITE_JUMPIFNULL );\n        onError = overrideError != OE_Default ? overrideError : OE_Abort;\n        if ( onError == OE_Ignore )\n        {\n          sqlite3VdbeAddOp2( v, OP_Goto, 0, ignoreDest );\n        }\n        else\n        {\n          sqlite3VdbeAddOp2( v, OP_Halt, SQLITE_CONSTRAINT, onError );\n        }\n        sqlite3VdbeResolveLabel( v, allOk );\n      }\n#endif // * !SQLITE_OMIT_CHECK) */\n\n      /* If we have an INTEGER PRIMARY KEY, make sure the primary key\n** of the new record does not previously exist.  Except, if this\n** is an UPDATE and the primary key is not changing, that is OK.\n*/\n      if ( rowidChng )\n      {\n        onError = pTab.keyConf;\n        if ( overrideError != OE_Default )\n        {\n          onError = overrideError;\n        }\n        else if ( onError == OE_Default )\n        {\n          onError = OE_Abort;\n        }\n\n        if ( onError != OE_Replace || pTab.pIndex != null )\n        {\n          if ( isUpdate )\n          {\n            j2 = sqlite3VdbeAddOp3( v, OP_Eq, regRowid, 0, regRowid - 1 );\n          }\n          j3 = sqlite3VdbeAddOp3( v, OP_NotExists, baseCur, 0, regRowid );\n          switch ( onError )\n          {\n            default:\n              {\n                onError = OE_Abort;\n                /* Fall thru into the next case */\n              }\n              goto case OE_Rollback;\n            case OE_Rollback:\n            case OE_Abort:\n            case OE_Fail:\n              {\n                sqlite3VdbeAddOp4( v, OP_Halt, SQLITE_CONSTRAINT, onError, 0,\n                   "PRIMARY KEY must be unique", P4_STATIC );\n                break;\n              }\n            case OE_Replace:\n              {\n                sqlite3GenerateRowIndexDelete( pParse, pTab, baseCur, 0 );\n                seenReplace = true;\n                break;\n              }\n            case OE_Ignore:\n              {\n                Debug.Assert( !seenReplace );\n                sqlite3VdbeAddOp2( v, OP_Goto, 0, ignoreDest );\n                break;\n              }\n          }\n          sqlite3VdbeJumpHere( v, j3 );\n          if ( isUpdate )\n          {\n            sqlite3VdbeJumpHere( v, j2 );\n          }\n        }\n      }\n\n      /* Test all UNIQUE constraints by creating entries for each UNIQUE\n      ** index and making sure that duplicate entries do not already exist.\n      ** Add the new records to the indices as we go.\n      */\n      for ( iCur = 0, pIdx = pTab.pIndex ; pIdx != null ; pIdx = pIdx.pNext, iCur++ )\n      {\n        int regIdx;\n        int regR;\n\n        if ( aRegIdx[iCur] == 0 ) continue;  /* Skip unused indices */\n\n        /* Create a key for accessing the index entry */\n        regIdx = sqlite3GetTempRange( pParse, pIdx.nColumn + 1 );\n        for ( i = 0 ; i < pIdx.nColumn ; i++ )\n        {\n          int idx = pIdx.aiColumn[i];\n          if ( idx == pTab.iPKey )\n          {\n            sqlite3VdbeAddOp2( v, OP_SCopy, regRowid, regIdx + i );\n          }\n          else\n          {\n            sqlite3VdbeAddOp2( v, OP_SCopy, regData + idx, regIdx + i );\n          }\n        }\n        sqlite3VdbeAddOp2( v, OP_SCopy, regRowid, regIdx + i );\n        sqlite3VdbeAddOp3( v, OP_MakeRecord, regIdx, pIdx.nColumn + 1, aRegIdx[iCur] );\n        sqlite3IndexAffinityStr( v, pIdx );\n        sqlite3ExprCacheAffinityChange( pParse, regIdx, pIdx.nColumn + 1 );\n\n        /* Find out what action to take in case there is an indexing conflict */\n        onError = pIdx.onError;\n        if ( onError == OE_None )\n        {\n          sqlite3ReleaseTempRange( pParse, regIdx, pIdx.nColumn + 1 );\n          continue;  /* pIdx is not a UNIQUE index */\n        }\n\n        if ( overrideError != OE_Default )\n        {\n          onError = overrideError;\n        }\n        else if ( onError == OE_Default )\n        {\n          onError = OE_Abort;\n        }\n        if ( seenReplace )\n        {\n          if ( onError == OE_Ignore ) onError = OE_Replace;\n          else if ( onError == OE_Fail ) onError = OE_Abort;\n        }\n\n\n        /* Check to see if the new index entry will be unique */\n        regR = sqlite3GetTempReg( pParse );\n        sqlite3VdbeAddOp2( v, OP_SCopy, regRowid - ( hasTwoRowids ? 1 : 0 ), regR );\n        j3 = sqlite3VdbeAddOp4( v, OP_IsUnique, baseCur + iCur + 1, 0,\n        regR, regIdx,//regR, SQLITE_INT_TO_PTR(regIdx),\n        P4_INT32 );\n        sqlite3ReleaseTempRange( pParse, regIdx, pIdx.nColumn + 1 );\n\n        /* Generate code that executes if the new index entry is not unique */\n        Debug.Assert( onError == OE_Rollback || onError == OE_Abort || onError == OE_Fail\n        || onError == OE_Ignore || onError == OE_Replace );\n        switch ( onError )\n        {\n          case OE_Rollback:\n          case OE_Abort:\n          case OE_Fail:\n            {\n              int j;\n              StrAccum errMsg = new StrAccum();\n              string zSep;\n              string zErr;\n\n              sqlite3StrAccumInit( errMsg, new StringBuilder( 200 ), 0, 200 );\n              errMsg.db = pParse.db;\n              zSep = pIdx.nColumn > 1 ? "columns " : "column ";\n              for ( j = 0 ; j < pIdx.nColumn ; j++ )\n              {\n                string zCol = pTab.aCol[pIdx.aiColumn[j]].zName;\n                sqlite3StrAccumAppend( errMsg, zSep, -1 );\n                zSep = ", ";\n                sqlite3StrAccumAppend( errMsg, zCol, -1 );\n              }\n              sqlite3StrAccumAppend( errMsg,\n              pIdx.nColumn > 1 ? " are not unique" : " is not unique", -1 );\n              zErr = sqlite3StrAccumFinish( errMsg );\n              sqlite3VdbeAddOp4( v, OP_Halt, SQLITE_CONSTRAINT, onError, 0, zErr, 0 );\n              //sqlite3DbFree( errMsg.db, zErr );\n              break;\n            }\n          case OE_Ignore:\n            {\n              Debug.Assert( !seenReplace );\n              sqlite3VdbeAddOp2( v, OP_Goto, 0, ignoreDest );\n              break;\n            }\n          default:\n            {\n              Debug.Assert( onError == OE_Replace );\n              sqlite3GenerateRowDelete( pParse, pTab, baseCur, regR, 0 );\n              seenReplace = true;\n              break;\n            }\n        }\n        sqlite3VdbeJumpHere( v, j3 );\n        sqlite3ReleaseTempReg( pParse, regR );\n      }\n      //if ( pbMayReplace )\n      {\n        pbMayReplace = seenReplace ? 1 : 0;\n      }\n    }\n\n    /*\n    ** This routine generates code to finish the INSERT or UPDATE operation\n    ** that was started by a prior call to sqlite3GenerateConstraintChecks.\n    ** A consecutive range of registers starting at regRowid contains the\n    ** rowid and the content to be inserted.\n    **\n    ** The arguments to this routine should be the same as the first six\n    ** arguments to sqlite3GenerateConstraintChecks.\n    */\n    static void sqlite3CompleteInsertion(\n    Parse pParse,       /* The parser context */\n    Table pTab,         /* the table into which we are inserting */\n    int baseCur,        /* Index of a read/write cursor pointing at pTab */\n    int regRowid,       /* Range of content */\n    int[] aRegIdx,      /* Register used by each index.  0 for unused indices */\n    bool isUpdate,      /* True for UPDATE, False for INSERT */\n    int newIdx,         /* Index of NEW table for triggers.  -1 if none */\n    bool appendBias,    /* True if this is likely to be an append */\n    bool useSeekResult  /* True to set the USESEEKRESULT flag on OP_[Idx]Insert */\n    )\n    {\n      int i;\n      Vdbe v;\n      int nIdx;\n      Index pIdx;\n      u8 pik_flags;\n      int regData;\n      int regRec;\n\n      v = sqlite3GetVdbe( pParse );\n      Debug.Assert( v != null );\n      Debug.Assert( pTab.pSelect == null );  /* This table is not a VIEW */\n      for ( nIdx = 0, pIdx = pTab.pIndex ; pIdx != null ; pIdx = pIdx.pNext, nIdx++ ) { }\n      for ( i = nIdx - 1 ; i >= 0 ; i-- )\n      {\n        if ( aRegIdx[i] == 0 ) continue;\n        sqlite3VdbeAddOp2( v, OP_IdxInsert, baseCur + i + 1, aRegIdx[i] );\n        if ( useSeekResult )\n        {\n          sqlite3VdbeChangeP5( v, OPFLAG_USESEEKRESULT );\n        }\n      }\n      regData = regRowid + 1;\n      regRec = sqlite3GetTempReg( pParse );\n      sqlite3VdbeAddOp3( v, OP_MakeRecord, regData, pTab.nCol, regRec );\n      sqlite3TableAffinityStr( v, pTab );\n      sqlite3ExprCacheAffinityChange( pParse, regData, pTab.nCol );\n#if !SQLITE_OMIT_TRIGGER\n      if ( newIdx >= 0 )\n      {\n        sqlite3VdbeAddOp3( v, OP_Insert, newIdx, regRec, regRowid );\n      }\n#endif\n      if ( pParse.nested != 0 )\n      {\n        pik_flags = 0;\n      }\n      else\n      {\n        pik_flags = OPFLAG_NCHANGE;\n        pik_flags |= ( isUpdate ? OPFLAG_ISUPDATE : OPFLAG_LASTROWID );\n      }\n      if ( appendBias )\n      {\n        pik_flags |= OPFLAG_APPEND;\n      }\n      if ( useSeekResult )\n      {\n        pik_flags |= OPFLAG_USESEEKRESULT;\n      }\n      sqlite3VdbeAddOp3( v, OP_Insert, baseCur, regRec, regRowid );\n      if ( pParse.nested == 0 )\n      {\n        sqlite3VdbeChangeP4( v, -1, pTab.zName, P4_STATIC );\n      }\n      sqlite3VdbeChangeP5( v, pik_flags );\n    }\n\n    /*\n    ** Generate code that will open cursors for a table and for all\n    ** indices of that table.  The "baseCur" parameter is the cursor number used\n    ** for the table.  Indices are opened on subsequent cursors.\n    **\n    ** Return the number of indices on the table.\n    */\n    static int sqlite3OpenTableAndIndices(\n    Parse pParse,   /* Parsing context */\n    Table pTab,     /* Table to be opened */\n    int baseCur,    /* VdbeCursor number assigned to the table */\n    int op          /* OP_OpenRead or OP_OpenWrite */\n    )\n    {\n      int i;\n      int iDb;\n      Index pIdx;\n      Vdbe v;\n\n      if ( IsVirtual( pTab ) ) return 0;\n      iDb = sqlite3SchemaToIndex( pParse.db, pTab.pSchema );\n      v = sqlite3GetVdbe( pParse );\n      Debug.Assert( v != null );\n      sqlite3OpenTable( pParse, baseCur, iDb, pTab, op );\n      for ( i = 1, pIdx = pTab.pIndex ; pIdx != null ; pIdx = pIdx.pNext, i++ )\n      {\n        KeyInfo pKey = sqlite3IndexKeyinfo( pParse, pIdx );\n        Debug.Assert( pIdx.pSchema == pTab.pSchema );\n        sqlite3VdbeAddOp4( v, op, i + baseCur, pIdx.tnum, iDb,\n        pKey, P4_KEYINFO_HANDOFF );\n#if SQLITE_DEBUG\n        VdbeComment( v, "%s", pIdx.zName );\n#endif\n      }\n      if ( pParse.nTab < baseCur + i )\n      {\n        pParse.nTab = baseCur + i;\n      }\n      return i - 1;\n    }\n\n\n#if  SQLITE_TEST\n    /*\n** The following global variable is incremented whenever the\n** transfer optimization is used.  This is used for testing\n** purposes only - to make sure the transfer optimization really\n** is happening when it is suppose to.\n*/\n    //static int sqlite3_xferopt_count = 0;\n#endif // * SQLITE_TEST */\n\n\n#if !SQLITE_OMIT_XFER_OPT\n    /*\n** Check to collation names to see if they are compatible.\n*/\n    static bool xferCompatibleCollation( string z1, string z2 )\n    {\n      if ( z1 == null )\n      {\n        return z2 == null;\n      }\n      if ( z2 == null )\n      {\n        return false;\n      }\n      return sqlite3StrICmp( z1, z2 ) == 0;\n    }\n\n\n    /*\n    ** Check to see if index pSrc is compatible as a source of data\n    ** for index pDest in an insert transfer optimization.  The rules\n    ** for a compatible index:\n    **\n    **    *   The index is over the same set of columns\n    **    *   The same DESC and ASC markings occurs on all columns\n    **    *   The same onError processing (OE_Abort, OE_Ignore, etc)\n    **    *   The same collating sequence on each column\n    */\n    static bool xferCompatibleIndex( Index pDest, Index pSrc )\n    {\n      int i;\n      Debug.Assert( pDest != null && pSrc != null );\n      Debug.Assert( pDest.pTable != pSrc.pTable );\n      if ( pDest.nColumn != pSrc.nColumn )\n      {\n        return false;   /* Different number of columns */\n      }\n      if ( pDest.onError != pSrc.onError )\n      {\n        return false;   /* Different conflict resolution strategies */\n      }\n      for ( i = 0 ; i < pSrc.nColumn ; i++ )\n      {\n        if ( pSrc.aiColumn[i] != pDest.aiColumn[i] )\n        {\n          return false;   /* Different columns indexed */\n        }\n        if ( pSrc.aSortOrder[i] != pDest.aSortOrder[i] )\n        {\n          return false;   /* Different sort orders */\n        }\n        if ( !xferCompatibleCollation( pSrc.azColl[i], pDest.azColl[i] ) )\n        {\n          return false;   /* Different collating sequences */\n        }\n      }\n\n      /* If no test above fails then the indices must be compatible */\n      return true;\n    }\n\n    /*\n    ** Attempt the transfer optimization on INSERTs of the form\n    **\n    **     INSERT INTO tab1 SELECT * FROM tab2;\n    **\n    ** This optimization is only attempted if\n    **\n    **    (1)  tab1 and tab2 have identical schemas including all the\n    **         same indices and constraints\n    **\n    **    (2)  tab1 and tab2 are different tables\n    **\n    **    (3)  There must be no triggers on tab1\n    **\n    **    (4)  The result set of the SELECT statement is "*"\n    **\n    **    (5)  The SELECT statement has no WHERE, HAVING, ORDER BY, GROUP BY,\n    **         or LIMIT clause.\n    **\n    **    (6)  The SELECT statement is a simple (not a compound) select that\n    **         contains only tab2 in its FROM clause\n    **\n    ** This method for implementing the INSERT transfers raw records from\n    ** tab2 over to tab1.  The columns are not decoded.  Raw records from\n    ** the indices of tab2 are transfered to tab1 as well.  In so doing,\n    ** the resulting tab1 has much less fragmentation.\n    **\n    ** This routine returns TRUE if the optimization is attempted.  If any\n    ** of the conditions above fail so that the optimization should not\n    ** be attempted, then this routine returns FALSE.\n    */\n    static int xferOptimization(\n    Parse pParse,         /* Parser context */\n    Table pDest,          /* The table we are inserting into */\n    Select pSelect,       /* A SELECT statement to use as the data source */\n    int onError,          /* How to handle constraint errors */\n    int iDbDest           /* The database of pDest */\n    )\n    {\n      ExprList pEList;                 /* The result set of the SELECT */\n      Table pSrc;                      /* The table in the FROM clause of SELECT */\n      Index pSrcIdx, pDestIdx;         /* Source and destination indices */\n      SrcList_item pItem;              /* An element of pSelect.pSrc */\n      int i;                           /* Loop counter */\n      int iDbSrc;                      /* The database of pSrc */\n      int iSrc, iDest;                 /* Cursors from source and destination */\n      int addr1, addr2;                /* Loop addresses */\n      int emptyDestTest;               /* Address of test for empty pDest */\n      int emptySrcTest;                /* Address of test for empty pSrc */\n      Vdbe v;                          /* The VDBE we are building */\n      KeyInfo pKey;                    /* Key information for an index */\n      int regAutoinc;                  /* Memory register used by AUTOINC */\n      bool destHasUniqueIdx = false;   /* True if pDest has a UNIQUE index */\n      int regData, regRowid;           /* Registers holding data and rowid */\n\n      if ( pSelect == null )\n      {\n        return 0;   /* Must be of the form  INSERT INTO ... SELECT ... */\n      }\n#if !SQLITE_OMIT_TRIGGER\n      if ( sqlite3TriggerList( pParse, pDest ) != null )\n      {\n        return 0;   /* tab1 must not have triggers */\n      }\n#endif\n\n      if ( ( pDest.tabFlags & TF_Virtual ) != 0 )\n      {\n        return 0;   /* tab1 must not be a virtual table */\n      }\n      if ( onError == OE_Default )\n      {\n        onError = OE_Abort;\n      }\n      if ( onError != OE_Abort && onError != OE_Rollback )\n      {\n        return 0;   /* Cannot do OR REPLACE or OR IGNORE or OR FAIL */\n      }\n      Debug.Assert( pSelect.pSrc != null );   /* allocated even if there is no FROM clause */\n      if ( pSelect.pSrc.nSrc != 1 )\n      {\n        return 0;   /* FROM clause must have exactly one term */\n      }\n      if ( pSelect.pSrc.a[0].pSelect != null )\n      {\n        return 0;   /* FROM clause cannot contain a subquery */\n      }\n      if ( pSelect.pWhere != null )\n      {\n        return 0;   /* SELECT may not have a WHERE clause */\n      }\n      if ( pSelect.pOrderBy != null )\n      {\n        return 0;   /* SELECT may not have an ORDER BY clause */\n      }\n      /* Do not need to test for a HAVING clause.  If HAVING is present but\n      ** there is no ORDER BY, we will get an error. */\n      if ( pSelect.pGroupBy != null )\n      {\n        return 0;   /* SELECT may not have a GROUP BY clause */\n      }\n      if ( pSelect.pLimit != null )\n      {\n        return 0;   /* SELECT may not have a LIMIT clause */\n      }\n      Debug.Assert( pSelect.pOffset == null );  /* Must be so if pLimit==0 */\n      if ( pSelect.pPrior != null )\n      {\n        return 0;   /* SELECT may not be a compound query */\n      }\n      if ( ( pSelect.selFlags & SF_Distinct ) != 0 )\n      {\n        return 0;   /* SELECT may not be DISTINCT */\n      }\n      pEList = pSelect.pEList;\n      Debug.Assert( pEList != null );\n      if ( pEList.nExpr != 1 )\n      {\n        return 0;   /* The result set must have exactly one column */\n      }\n      Debug.Assert( pEList.a[0].pExpr != null );\n      if ( pEList.a[0].pExpr.op != TK_ALL )\n      {\n        return 0;   /* The result set must be the special operator "*" */\n      }\n\n      /* At this point we have established that the statement is of the\n      ** correct syntactic form to participate in this optimization.  Now\n      ** we have to check the semantics.\n      */\n      pItem = pSelect.pSrc.a[0];\n      pSrc = sqlite3LocateTable( pParse, 0, pItem.zName, pItem.zDatabase );\n      if ( pSrc == null )\n      {\n        return 0;   /* FROM clause does not contain a real table */\n      }\n      if ( pSrc == pDest )\n      {\n        return 0;   /* tab1 and tab2 may not be the same table */\n      }\n      if ( ( pSrc.tabFlags & TF_Virtual ) != 0 )\n      {\n        return 0;   /* tab2 must not be a virtual table */\n      }\n      if ( pSrc.pSelect != null )\n      {\n        return 0;   /* tab2 may not be a view */\n      }\n      if ( pDest.nCol != pSrc.nCol )\n      {\n        return 0;   /* Number of columns must be the same in tab1 and tab2 */\n      }\n      if ( pDest.iPKey != pSrc.iPKey )\n      {\n        return 0;   /* Both tables must have the same INTEGER PRIMARY KEY */\n      }\n      for ( i = 0 ; i < pDest.nCol ; i++ )\n      {\n        if ( pDest.aCol[i].affinity != pSrc.aCol[i].affinity )\n        {\n          return 0;    /* Affinity must be the same on all columns */\n        }\n        if ( !xferCompatibleCollation( pDest.aCol[i].zColl, pSrc.aCol[i].zColl ) )\n        {\n          return 0;    /* Collating sequence must be the same on all columns */\n        }\n        if ( pDest.aCol[i].notNull != 0 && pSrc.aCol[i].notNull == 0 )\n        {\n          return 0;    /* tab2 must be NOT NULL if tab1 is */\n        }\n      }\n      for ( pDestIdx = pDest.pIndex ; pDestIdx != null ; pDestIdx = pDestIdx.pNext )\n      {\n        if ( pDestIdx.onError != OE_None )\n        {\n          destHasUniqueIdx = true;\n        }\n        for ( pSrcIdx = pSrc.pIndex ; pSrcIdx != null ; pSrcIdx = pSrcIdx.pNext )\n        {\n          if ( xferCompatibleIndex( pDestIdx, pSrcIdx ) ) break;\n        }\n        if ( pSrcIdx == null )\n        {\n          return 0;    /* pDestIdx has no corresponding index in pSrc */\n        }\n      }\n#if !SQLITE_OMIT_CHECK\n      if ( pDest.pCheck != null && !sqlite3ExprCompare( pSrc.pCheck, pDest.pCheck ) )\n      {\n        return 0;   /* Tables have different CHECK constraints.  Ticket #2252 */\n      }\n#endif\n\n      /* If we get this far, it means either:\n**\n**    *   We can always do the transfer if the table contains an\n**        an integer primary key\n**\n**    *   We can conditionally do the transfer if the destination\n**        table is empty.\n*/\n#if  SQLITE_TEST\n      sqlite3_xferopt_count.iValue++;\n#endif\n      iDbSrc = sqlite3SchemaToIndex( pParse.db, pSrc.pSchema );\n      v = sqlite3GetVdbe( pParse );\n      sqlite3CodeVerifySchema( pParse, iDbSrc );\n      iSrc = pParse.nTab++;\n      iDest = pParse.nTab++;\n      regAutoinc = autoIncBegin( pParse, iDbDest, pDest );\n      sqlite3OpenTable( pParse, iDest, iDbDest, pDest, OP_OpenWrite );\n      if ( ( pDest.iPKey < 0 && pDest.pIndex != null ) || destHasUniqueIdx )\n      {\n        /* If tables do not have an INTEGER PRIMARY KEY and there\n        ** are indices to be copied and the destination is not empty,\n        ** we have to disallow the transfer optimization because the\n        ** the rowids might change which will mess up indexing.\n        **\n        ** Or if the destination has a UNIQUE index and is not empty,\n        ** we also disallow the transfer optimization because we cannot\n        ** insure that all entries in the union of DEST and SRC will be\n        ** unique.\n        */\n        addr1 = sqlite3VdbeAddOp2( v, OP_Rewind, iDest, 0 );\n        emptyDestTest = sqlite3VdbeAddOp2( v, OP_Goto, 0, 0 );\n        sqlite3VdbeJumpHere( v, addr1 );\n      }\n      else\n      {\n        emptyDestTest = 0;\n      }\n      sqlite3OpenTable( pParse, iSrc, iDbSrc, pSrc, OP_OpenRead );\n      emptySrcTest = sqlite3VdbeAddOp2( v, OP_Rewind, iSrc, 0 );\n      regData = sqlite3GetTempReg( pParse );\n      regRowid = sqlite3GetTempReg( pParse );\n      if ( pDest.iPKey >= 0 )\n      {\n        addr1 = sqlite3VdbeAddOp2( v, OP_Rowid, iSrc, regRowid );\n        addr2 = sqlite3VdbeAddOp3( v, OP_NotExists, iDest, 0, regRowid );\n        sqlite3VdbeAddOp4( v, OP_Halt, SQLITE_CONSTRAINT, onError, 0,\n        "PRIMARY KEY must be unique", P4_STATIC );\n        sqlite3VdbeJumpHere( v, addr2 );\n        autoIncStep( pParse, regAutoinc, regRowid );\n      }\n      else if ( pDest.pIndex == null )\n      {\n        addr1 = sqlite3VdbeAddOp2( v, OP_NewRowid, iDest, regRowid );\n      }\n      else\n      {\n        addr1 = sqlite3VdbeAddOp2( v, OP_Rowid, iSrc, regRowid );\n        Debug.Assert( ( pDest.tabFlags & TF_Autoincrement ) == 0 );\n      }\n      sqlite3VdbeAddOp2( v, OP_RowData, iSrc, regData );\n      sqlite3VdbeAddOp3( v, OP_Insert, iDest, regData, regRowid );\n      sqlite3VdbeChangeP5( v, OPFLAG_NCHANGE | OPFLAG_LASTROWID | OPFLAG_APPEND );\n      sqlite3VdbeChangeP4( v, -1, pDest.zName, 0 );\n      sqlite3VdbeAddOp2( v, OP_Next, iSrc, addr1 );\n      for ( pDestIdx = pDest.pIndex ; pDestIdx != null ; pDestIdx = pDestIdx.pNext )\n      {\n        for ( pSrcIdx = pSrc.pIndex ; pSrcIdx != null ; pSrcIdx = pSrcIdx.pNext )\n        {\n          if ( xferCompatibleIndex( pDestIdx, pSrcIdx ) ) break;\n        }\n        Debug.Assert( pSrcIdx != null );\n        sqlite3VdbeAddOp2( v, OP_Close, iSrc, 0 );\n        sqlite3VdbeAddOp2( v, OP_Close, iDest, 0 );\n        pKey = sqlite3IndexKeyinfo( pParse, pSrcIdx );\n        sqlite3VdbeAddOp4( v, OP_OpenRead, iSrc, pSrcIdx.tnum, iDbSrc,\n        pKey, P4_KEYINFO_HANDOFF );\n#if SQLITE_DEBUG\n        VdbeComment( v, "%s", pSrcIdx.zName );\n#endif\n        pKey = sqlite3IndexKeyinfo( pParse, pDestIdx );\n        sqlite3VdbeAddOp4( v, OP_OpenWrite, iDest, pDestIdx.tnum, iDbDest,\n        pKey, P4_KEYINFO_HANDOFF );\n#if SQLITE_DEBUG\n        VdbeComment( v, "%s", pDestIdx.zName );\n#endif\n        addr1 = sqlite3VdbeAddOp2( v, OP_Rewind, iSrc, 0 );\n        sqlite3VdbeAddOp2( v, OP_RowKey, iSrc, regData );\n        sqlite3VdbeAddOp3( v, OP_IdxInsert, iDest, regData, 1 );\n        sqlite3VdbeAddOp2( v, OP_Next, iSrc, addr1 + 1 );\n        sqlite3VdbeJumpHere( v, addr1 );\n      }\n      sqlite3VdbeJumpHere( v, emptySrcTest );\n      sqlite3ReleaseTempReg( pParse, regRowid );\n      sqlite3ReleaseTempReg( pParse, regData );\n      sqlite3VdbeAddOp2( v, OP_Close, iSrc, 0 );\n      sqlite3VdbeAddOp2( v, OP_Close, iDest, 0 );\n      if ( emptyDestTest != 0 )\n      {\n        sqlite3VdbeAddOp2( v, OP_Halt, SQLITE_OK, 0 );\n        sqlite3VdbeJumpHere( v, emptyDestTest );\n        sqlite3VdbeAddOp2( v, OP_Close, iDest, 0 );\n        return 0;\n      }\n      else\n      {\n        return 1;\n      }\n    }\n#endif // * SQLITE_OMIT_XFER_OPT */\n    /* Make sure "isView" gets undefined in case this file becomes part of\n** the amalgamation - so that subsequent files do not see isView as a\n** macro. */\n    //#undef isView\n  }\n}\n'