b'using System.Diagnostics;\nusing System.Text;\n\nnamespace CS_SQLite3\n{\n  using sqlite3_int64 = System.Int64;\n  using sqlite3_u3264 = System.UInt64;\n\n  public partial class CSSQLite\n  {\n    /*\n    ** 2001 September 15\n    **\n    ** The author disclaims copyright to this source code.  In place of\n    ** a legal notice, here is a blessing:\n    **\n    **    May you do good and not evil.\n    **    May you find forgiveness for yourself and forgive others.\n    **    May you share freely, never taking more than you give.\n    **\n    *************************************************************************\n    **\n    ** Memory allocation functions used throughout sqlite.\n    **\n    ** $Id: malloc.c,v 1.66 2009/07/17 11:44:07 drh Exp $\n    **\n    *************************************************************************\n    **  Included in SQLite3 port to C#-SQLite;  2008 Noah B Hart\n    **  C#-SQLite is an independent reimplementation of the SQLite software library\n    **\n    **  $Header$\n    *************************************************************************\n    */\n    //#include "sqliteInt.h"\n    //#include <stdarg.h>\n\n#if FALSE\n    /*\n    ** This routine runs when the memory allocator sees that the\n    ** total memory allocation is about to exceed the soft heap\n    ** limit.\n    */\n    static void softHeapLimitEnforcer(\n    object NotUsed,\n    sqlite3_int64 NotUsed2,\n    int allocSize\n    )\n    {\n      UNUSED_PARAMETER2( NotUsed, NotUsed2 );\n      sqlite3_release_memory( allocSize );\n    }\n\n    /*\n    ** Set the soft heap-size limit for the library. Passing a zero or\n    ** negative value indicates no limit.\n    */\n    static void sqlite3_soft_heap_limit( int n )\n    {\n      long iLimit;\n      int overage;\n      if ( n < 0 )\n      {\n        iLimit = 0;\n      }\n      else\n      {\n        iLimit = n;\n      }\n      sqlite3_initialize();\n      if ( iLimit > 0 )\n      {\n        sqlite3MemoryAlarm( (dxalarmCallback)softHeapLimitEnforcer, 0, iLimit );\n      }\n      else\n      {\n        sqlite3MemoryAlarm( null, null, 0 );\n      }\n      overage = (int)( sqlite3_memory_used() - n );\n      if ( overage > 0 )\n      {\n        sqlite3_release_memory( overage );\n      }\n    }\n\n    /*\n    ** Attempt to release up to n bytes of non-essential memory currently\n    ** held by SQLite. An example of non-essential memory is memory used to\n    ** cache database pages that are not currently in use.\n    */\n    static int sqlite3_release_memory( int n )\n    {\n#if  SQLITE_ENABLE_MEMORY_MANAGEMENT\nint nRet = 0;\n#if FALSE\nnRet += sqlite3VdbeReleaseMemory(n);\n#endif\nnRet += sqlite3PcacheReleaseMemory(n-nRet);\nreturn nRet;\n#else\n      UNUSED_PARAMETER( n );\n      return SQLITE_OK;\n#endif\n    }\n\n    /*\n    ** State information local to the memory allocation subsystem.\n    */\n    public class Mem0Global\n    {\n      /* Number of free pages for scratch and page-cache memory */\n      public int nScratchFree;\n      public int nPageFree;\n\n      public sqlite3_mutex mutex;         /* Mutex to serialize access */\n\n      /*\n      ** The alarm callback and its arguments.  The mem0.mutex lock will\n      ** be held while the callback is running.  Recursive calls into\n      ** the memory subsystem are allowed, but no new callbacks will be\n      ** issued.\n      */\n      public sqlite3_int64 alarmThreshold;\n      public dxalarmCallback alarmCallback; // (*alarmCallback)(void*, sqlite3_int64,int);\n      public object alarmArg;\n\n      /*\n      ** Pointers to the end of  sqlite3GlobalConfig.pScratch and\n      **  sqlite3GlobalConfig.pPage to a block of memory that records\n      ** which pages are available.\n      */\n      public int[] aScratchFree;\n      public int[] aPageFree;\n\n      public Mem0Global() { }\n\n      public Mem0Global( int nScratchFree, int nPageFree, sqlite3_mutex mutex, sqlite3_int64 alarmThreshold, dxalarmCallback alarmCallback, object alarmArg, int alarmBusy, int[] aScratchFree, int[] aPageFree )\n      {\n        this.nScratchFree = nScratchFree;\n        this.nPageFree = nPageFree;\n        this.mutex = mutex;\n        this.alarmThreshold = alarmThreshold;\n        this.alarmCallback = alarmCallback;\n        this.alarmArg = alarmArg;\n        this.alarmBusy = alarmBusy;\n        this.aScratchFree = aScratchFree;\n        this.aPageFree = aPageFree;\n      }\n    }\n    static Mem0Global mem0 = new Mem0Global( 0, null, 0, null, null, 0, null, null );\n\n    //#define mem0 GLOBAL(struct Mem0Global, mem0)\n\n\n    /*\n    ** Initialize the memory allocation subsystem.\n    */\n    static int sqlite3MallocInit()\n    {\n      if ( sqlite3GlobalConfig.m.xMalloc == null )\n      {\n        sqlite3MemSetDefault();\n      }\n      mem0 = new Mem0Global(); //memset(&mem0, 0, sizeof(mem0));\n      if ( sqlite3GlobalConfig.bCoreMutex )\n      {\n        mem0.mutex = sqlite3MutexAlloc( SQLITE_MUTEX_STATIC_MEM );\n      }\n      if ( sqlite3GlobalConfig.pScratch != null && sqlite3GlobalConfig.szScratch >= 100\n      && sqlite3GlobalConfig.nScratch >= 0 )\n      {\n        Debugger.Break(); // TODO --\n\n        //  int i;\n        //  sqlite3GlobalConfig.szScratch = ROUNDDOWN8(sqlite3GlobalConfig.szScratch-4);\n        //  mem0.aScratchFree = (u32*)&((char*) sqlite3GlobalConfig.pScratch)\n        //                [ sqlite3GlobalConfig.szScratch* sqlite3GlobalConfig.nScratch];\n        //  for(i=0; i< sqlite3GlobalConfig.nScratch; i++){ mem0.aScratchFree[i] = i; }\n        //  mem0.nScratchFree =  sqlite3GlobalConfig.nScratch;\n      }\n      else\n      {\n        sqlite3GlobalConfig.pScratch = null;\n        sqlite3GlobalConfig.szScratch = 0;\n      }\n      if ( sqlite3GlobalConfig.pPage != null && sqlite3GlobalConfig.szPage >= 512\n      && sqlite3GlobalConfig.nPage >= 1 )\n      {\n        int i;\n        int overhead;\n        int sz = ROUNDDOWN8( sqlite3GlobalConfig.szPage );\n        int n = sqlite3GlobalConfig.nPage;\n        overhead = ( 4 * n + sz - 1 ) / sz;\n        sqlite3GlobalConfig.nPage -= overhead;\n        mem0.aPageFree = new int[sqlite3GlobalConfig.szPage * sqlite3GlobalConfig.nPage];\n        //  mem0.aPageFree = (u32*)&((char*) sqlite3GlobalConfig.pPage)\n        //                [ sqlite3GlobalConfig.szPage* sqlite3GlobalConfig.nPage];\n        for ( i = 0 ; i < sqlite3GlobalConfig.nPage ; i++ ) { mem0.aPageFree[i] = i; }\n        mem0.nPageFree = sqlite3GlobalConfig.nPage;\n      }\n      else\n      {\n        sqlite3GlobalConfig.pPage = null;\n        sqlite3GlobalConfig.szPage = 0;\n      }\n      return sqlite3GlobalConfig.m.xInit( sqlite3GlobalConfig.m.pAppData );\n    }\n\n    /*\n    ** Deinitialize the memory allocation subsystem.\n    */\n    static void sqlite3MallocEnd()\n    {\n      if ( sqlite3GlobalConfig.m.xShutdown != null )\n      {\n        sqlite3GlobalConfig.m.xShutdown( sqlite3GlobalConfig.m.pAppData );\n        mem0 = new Mem0Global();//memset(&mem0, 0, sizeof(mem0));\n      }\n    }\n    /*\n    ** Return the amount of memory currently checked out.\n    */\n    static sqlite3_int64 sqlite3_memory_used()\n    {\n      int n = 0, mx = 0;\n      sqlite3_int64 res;\n      sqlite3_status( SQLITE_STATUS_MEMORY_USED, ref n, ref mx, 0 );\n      res = (sqlite3_int64)n;  /* Work around bug in Borland C. Ticket #3216 */\n      return res;\n    }\n\n    /*\n    ** Return the maximum amount of memory that has ever been\n    ** checked out since either the beginning of this process\n    ** or since the most recent reset.\n    */\n    static sqlite3_int64 sqlite3_memory_highwater( int resetFlag )\n    {\n      int n = 0, mx = 0;\n      sqlite3_int64 res;\n      sqlite3_status( SQLITE_STATUS_MEMORY_USED, ref n, ref mx, 0 );\n      res = (sqlite3_int64)mx;  /* Work around bug in Borland C. Ticket #3216 */\n      return res;\n    }\n\n    /*\n    ** Change the alarm callback\n    */\n    static int sqlite3MemoryAlarm(\n    dxalarmCallback xCallback, //void(*xCallback)(void pArg, sqlite3_int64 used,int N),\n    object pArg,\n    sqlite3_int64 iThreshold\n    )\n    {\n      sqlite3_mutex_enter( mem0.mutex );\n      mem0.alarmCallback = xCallback;\n      mem0.alarmArg = pArg;\n      mem0.alarmThreshold = iThreshold;\n      sqlite3_mutex_leave( mem0.mutex );\n      return SQLITE_OK;\n    }\n\n#if !SQLITE_OMIT_DEPRECATED\n    /*\n** Deprecated external interface.  Internal/core SQLite code\n** should call sqlite3MemoryAlarm.\n*/\n    static int sqlite3_memory_alarm(\n    dxalarmCallback xCallback, //void(*xCallback)(void *pArg, sqlite3_int64 used,int N),\n    object pArg,\n    sqlite3_int64 iThreshold\n    )\n    {\n      return sqlite3MemoryAlarm( xCallback, pArg, iThreshold );\n    }\n#endif\n\n\n    /*\n** Trigger the alarm\n*/\n    static void sqlite3MallocAlarm( int nByte )\n    {\n      Debugger.Break(); // TODO --\n      //dxCallback xCallback; //void (*xCallback)(void*,sqlite3_int64,int);\n      //sqlite3_int64 nowUsed;\n      //object pArg;\n      //if( mem0.alarmCallback==0 ) return;\n      //xCallback = mem0.alarmCallback;\n      //nowUsed = sqlite3StatusValue(SQLITE_STATUS_MEMORY_USED);\n      //pArg = mem0.alarmArg;\n      //mem0.alarmCallback = null;\n      //sqlite3_mutex_leave(mem0.mutex);\n      //xCallback(pArg, nowUsed, nByte);\n      //sqlite3_mutex_enter(mem0.mutex);\n      //mem0.alarmCallback = xCallback;\n      //mem0.alarmArg = pArg;\n      }\n\n    /*\n    ** Do a memory allocation with statistics and alarms.  Assume the\n    ** lock is already held.\n    */\n    static int mallocWithAlarm( int n, ref byte[] pp )\n    {\n      int nFull;\n      byte[] p;\n      Debug.Assert( sqlite3_mutex_held( mem0.mutex ) );\n      nFull = sqlite3GlobalConfig.m.xRoundup( n );\n      sqlite3StatusSet( SQLITE_STATUS_MALLOC_SIZE, n );\n      if ( mem0.alarmCallback != null )\n      {\n        int nUsed = sqlite3StatusValue( SQLITE_STATUS_MEMORY_USED );\n        if ( nUsed + nFull >= mem0.alarmThreshold )\n        {\n          sqlite3MallocAlarm( nFull );\n        }\n      }\n      p = sqlite3GlobalConfig.m.xMalloc( nFull );\n      if ( p == null && mem0.alarmCallback != null )\n      {\n        sqlite3MallocAlarm( nFull );\n        p = sqlite3GlobalConfig.m.xMalloc( nFull );\n      }\n      if ( p != null )\n      {\n        nFull = sqlite3MallocSize( p );\n        sqlite3StatusAdd( SQLITE_STATUS_MEMORY_USED, nFull );\n      }\n      pp = p;\n      return nFull;\n    }\n\n    /*\n    ** Allocate memory.  This routine is like sqlite3_malloc() except that it\n    ** assumes the memory subsystem has already been initialized.\n    */\n    static byte[] sqlite3Malloc( int n )\n    {\n      byte[] p = null;\n      if ( n <= 0 || n >= 0x7fffff00 )\n      {\n        /* A memory allocation of a number of bytes which is near the maximum\n        ** signed integer value might cause an integer overflow inside of the\n        ** xMalloc().  Hence we limit the maximum size to 0x7fffff00, giving\n        ** 255 bytes of overhead.  SQLite itself will never use anything near\n        ** this amount.  The only way to reach the limit is with sqlite3_malloc() */\n        p = null;\n      }\n      else if ( sqlite3GlobalConfig.bMemstat )\n      {\n        sqlite3_mutex_enter( mem0.mutex );\n        mallocWithAlarm( n, ref p );\n        sqlite3_mutex_leave( mem0.mutex );\n      }\n      else\n      {\n        p = sqlite3GlobalConfig.m.xMalloc( n );\n      }\n      return p;\n    }\n\n    /*\n    ** This version of the memory allocation is for use by the application.\n    ** First make sure the memory subsystem is initialized, then do the\n    ** allocation.\n    */\n    static byte[] sqlite3_malloc( int n )\n    {\n#if !SQLITE_OMIT_AUTOINIT\n      if ( sqlite3_initialize() != 0 ) return null;\n#endif\n      return sqlite3Malloc( n );\n    }\n\n    /*\n    ** Each thread may only have a single outstanding allocation from\n    ** xScratchMalloc().  We verify this constraint in the single-threaded\n    ** case by setting scratchAllocOut to 1 when an allocation\n    ** is outstanding clearing it when the allocation is freed.\n    */\n#if !SQLITE_THREADSAFE && !NDEBUG\n    static int scratchAllocOut = 0;\n#endif\n\n\n    /*\n** Allocate memory that is to be used and released right away.\n** This routine is similar to alloca() in that it is not intended\n** for situations where the memory might be held long-term.  This\n** routine is intended to get memory to old large transient data\n** structures that would not normally fit on the stack of an\n** embedded processor.\n*/\n    byte[] sqlite3ScratchMalloc( int n )\n    {\n      byte[] p = null;\n      Debug.Assert( n > 0 );\n\n#if !SQLITE_THREADSAFE && !NDEBUG\n      /* Verify that no more than one scratch allocation per thread\n** is outstanding at one time.  (This is only checked in the\n** single-threaded case since checking in the multi-threaded case\n** would be much more complicated.) */\n      Debug.Assert( scratchAllocOut == 0 );\n#endif\n\n      if ( sqlite3GlobalConfig.szScratch < n )\n      {\n        goto scratch_overflow;\n      }\n      else\n      {\n        sqlite3_mutex_enter( mem0.mutex );\n        if ( mem0.nScratchFree == 0 )\n        {\n          sqlite3_mutex_leave( mem0.mutex );\n          goto scratch_overflow;\n        }\n        else\n        {\n          Debugger.Break(); // TODO --\n          //int i;\n          //i = mem0.aScratchFree[--mem0.nScratchFree];\n          //i *=  sqlite3GlobalConfig.szScratch;\n          //sqlite3StatusAdd(SQLITE_STATUS_SCRATCH_USED, 1);\n          //sqlite3StatusSet(SQLITE_STATUS_SCRATCH_SIZE, n);\n          //sqlite3_mutex_leave(mem0.mutex);\n          //p = (void*)&((char*) sqlite3GlobalConfig.pScratch)[i];\n          //assert(  (((u8*)p - (u8*)0) & 7)==0 );\n        }\n      }\n#if !SQLITE_THREADSAFE && !NDEBUG\n      scratchAllocOut = p != null ? 1 : 0;\n#endif\n\n      return p;\n\nscratch_overflow:\n      if ( sqlite3GlobalConfig.bMemstat )\n      {\n        sqlite3_mutex_enter( mem0.mutex );\n        sqlite3StatusSet( SQLITE_STATUS_SCRATCH_SIZE, n );\n        n = mallocWithAlarm( n, ref p );\n        if ( p != null ) sqlite3StatusAdd( SQLITE_STATUS_SCRATCH_OVERFLOW, n );\n        sqlite3_mutex_leave( mem0.mutex );\n      }\n      else\n      {\n        p = sqlite3GlobalConfig.m.xMalloc( n );\n      }\n#if !SQLITE_THREADSAFE && !NDEBUG\n      scratchAllocOut = ( p != null ) ? 1 : 0;\n#endif\n      return p;\n    }\n    static void //sqlite3ScratchFree( ref byte[][] p ) { p = null; }\n    static void //sqlite3ScratchFree( ref byte[] p )\n    {\n      if ( p != null )\n      {\n\n#if !SQLITE_THREADSAFE && !NDEBUG\n        /* Verify that no more than one scratch allocation per thread\n** is outstanding at one time.  (This is only checked in the\n** single-threaded case since checking in the multi-threaded case\n** would be much more complicated.) */\n        Debug.Assert( scratchAllocOut == 1 );\n        scratchAllocOut = 0;\n#endif\n        Debugger.Break(); // TODO --\n        //if(  sqlite3GlobalConfig.pScratch==null\n        //       || p< sqlite3GlobalConfig.pScratch\n        //       || p>=(void*)mem0.aScratchFree ){\n        //  if(  sqlite3GlobalConfig.bMemstat ){\n        //    int iSize = sqlite3MallocSize(p);\n        //    sqlite3_mutex_enter(mem0.mutex);\n        //    sqlite3StatusAdd(SQLITE_STATUS_SCRATCH_OVERFLOW, -iSize);\n        //    sqlite3StatusAdd(SQLITE_STATUS_MEMORY_USED, -iSize);\n        //     sqlite3GlobalConfig.m.xFree(p);\n        //    sqlite3_mutex_leave(mem0.mutex);\n        //  }else{\n        //     sqlite3GlobalConfig.m.xFree(p);\n        //  }\n        //}else{\n        //  int i;\n        //  i = (int)((u8*)p - (u8*)sqlite3GlobalConfig.pScratch);\n        //  i /=  sqlite3GlobalConfig.szScratch;\n        //  Debug.Assert(i>=0 && i< sqlite3GlobalConfig.nScratch );\n        //  sqlite3_mutex_enter(mem0.mutex);\n        //  Debug.Assert(mem0.nScratchFree< (u32)sqlite3GlobalConfig.nScratch );\n        //  mem0.aScratchFree[mem0.nScratchFree++] = i;\n        //  sqlite3StatusAdd(SQLITE_STATUS_SCRATCH_USED, -1);\n        //  sqlite3_mutex_leave(mem0.mutex);\n        //}\n      }\n    }\n\n    /*\n    ** TRUE if p is a lookaside memory allocation from db\n    */\n#if !SQLITE_OMIT_LOOKASIDE\nstatic bool isLookaside( sqlite3 db, object p )\n{\nreturn db != null && p >= db.lookaside.pStart && p < db.lookaside.pEnd;\n}\n#else\n    //#define isLookaside(A,B) 0\n    static bool isLookaside( sqlite3 db, object p )\n    {\n      return false;\n    }\n#endif\n\n    /*\n** Return the size of a memory allocation previously obtained from\n** sqlite3Malloc() or sqlite3_malloc().\n*/\n    static int sqlite3MallocSize( byte[] p )\n    {\n      return sqlite3GlobalConfig.m.xSize( p );\n    }\n\n    int sqlite3DbMallocSize( sqlite3 db, byte[] p )\n    {\n      Debug.Assert( db == null || sqlite3_mutex_held( db.mutex ) );\n      if ( isLookaside( db, p ) )\n      {\n        return db.lookaside.sz;\n      }\n      else\n      {\n        return sqlite3GlobalConfig.m.xSize( p );\n      }\n    }\n\n    /*\n    ** Free memory previously obtained from sqlite3Malloc().\n    */\n    // -- overloads ---------------------------------------\n    static void //sqlite3_free( ref string x )\n    { x = null; }\n\n    static void //sqlite3_free<T>( ref T x ) where T : class\n    { x = null; }\n\n    static void //sqlite3_free( ref byte[] p )\n    {\n      if ( p == null ) return;\n      if ( sqlite3GlobalConfig.bMemstat )\n      {\n        sqlite3_mutex_enter( mem0.mutex );\n        sqlite3StatusAdd( SQLITE_STATUS_MEMORY_USED, -sqlite3MallocSize( p ) );\n        sqlite3GlobalConfig.m.xFree( ref  p );\n        sqlite3_mutex_leave( mem0.mutex );\n      }\n      else\n      {\n        Debugger.Break(); // TODO --    sqlite3GlobalConfig.m.xFree(p);\n      }\n    }\n    /*\n    ** Free memory that might be associated with a particular database\n    ** connection.\n    */\n    // -- overloads ---------------------------------------\n    static void //sqlite3DbFree( sqlite3 db, ref string x )\n    {\n      Debug.Assert( db == null || sqlite3_mutex_held( db.mutex ) );\n      x = null;\n    }\n    static void //sqlite3DbFree( sqlite3 db, ref byte[] x )\n    {\n      Debug.Assert( db == null || sqlite3_mutex_held( db.mutex ) );\n      x = null;\n    }\n    static void //sqlite3DbFree( sqlite3 db, ref int[] x )\n    {\n      Debug.Assert( db == null || sqlite3_mutex_held( db.mutex ) );\n      x = null;\n    }\n    static void //sqlite3DbFree( sqlite3 db, ref StringBuilder x )\n    {\n      Debug.Assert( db == null || sqlite3_mutex_held( db.mutex ) );\n      x = null;\n    }\n    static void //sqlite3DbFree<T>( sqlite3 db, ref T p ) where T : class\n    {\n      Debug.Assert( db == null || sqlite3_mutex_held( db.mutex ) );\n      p = null;\n    }\n    static void //sqlite3DbFree( sqlite3 db, object p )\n    {\n      Debug.Assert( db == null || sqlite3_mutex_held( db.mutex ) );\n      if ( isLookaside( db, p ) )\n      {\n        LookasideSlot pBuf = (LookasideSlot)p;\n        pBuf.pNext = db.lookaside.pFree;\n        db.lookaside.pFree = pBuf;\n        db.lookaside.nOut--;\n      }\n      else\n      {\n        //sqlite3_free( ref p );\n      }\n    }\n\n    /*\n    ** Change the size of an existing memory allocation\n    */\n    static byte[] sqlite3Realloc( byte[] pOld, int nBytes )\n    {\n      int nOld, nNew;\n      byte[] pNew = null;\n      if ( pOld == null )\n      {\n        return sqlite3Malloc( nBytes );\n      }\n      if ( nBytes <= 0 )\n      {\n        //sqlite3_free( ref  pOld );\n        return null;\n      }\n      if ( nBytes >= 0x7fffff00 )\n      {\n        /* The 0x7ffff00 limit term is explained in comments on sqlite3Malloc() */\n        return null;\n      }\n      nOld = sqlite3MallocSize( pOld );\n      if ( sqlite3GlobalConfig.bMemstat )\n      {\n        sqlite3_mutex_enter( mem0.mutex );\n        sqlite3StatusSet( SQLITE_STATUS_MALLOC_SIZE, nBytes );\n        nNew = sqlite3GlobalConfig.m.xRoundup( nBytes );\n        if ( nOld == nNew )\n        {\n          pNew = pOld;\n        }\n        else\n        {\n          if ( sqlite3StatusValue( SQLITE_STATUS_MEMORY_USED ) + nNew - nOld >=\n          mem0.alarmThreshold )\n          {\n            sqlite3MallocAlarm( nNew - nOld );\n          }\n          Debugger.Break(); // TODO --\n          //pNew =  sqlite3GlobalConfig.m.xRealloc(pOld, nNew);\n          //if( pNew==0 && mem0.alarmCallback ){\n          //  sqlite3MallocAlarm(nBytes);\n          //  pNew =  sqlite3GlobalConfig.m.xRealloc(pOld, nNew);\n          //}\n          if ( pNew != null )\n          {\n            nNew = sqlite3MallocSize( pNew );\n            sqlite3StatusAdd( SQLITE_STATUS_MEMORY_USED, nNew - nOld );\n          }\n        }\n        sqlite3_mutex_leave( mem0.mutex );\n      }\n      else\n      {\n        Debugger.Break(); // TODO --pNew =  sqlite3GlobalConfig.m.xRealloc(ref pOld, nBytes);\n      }\n      return pNew;\n    }\n\n    /*\n    ** The public interface to sqlite3Realloc.  Make sure that the memory\n    ** subsystem is initialized prior to invoking sqliteRealloc.\n    */\n    static byte[] sqlite3_realloc( object pOld, int n )\n    {\n#if !SQLITE_OMIT_AUTOINIT\n      if ( sqlite3_initialize() != 0 ) return null;\n#endif\n      return sqlite3Realloc( (byte[])pOld, n );\n    }\n\n\n    /*\n    ** Allocate and zero memory.\n    */\n    static byte[] sqlite3MallocZero( int n )\n    {\n      byte[] p = sqlite3Malloc( n );\n      if ( p != null )\n      {\n        //memset(p, 0, n);\n      }\n      return p;\n    }\n\n    /*\n    ** Allocate and zero memory.  If the allocation fails, make\n    ** the mallocFailed flag in the connection pointer.\n    */\n    static byte[] sqlite3DbMallocZero( sqlite3 db, int n )\n    {\n      byte[] p = sqlite3DbMallocRaw( db, n );\n      if ( p != null )\n      {\n        //  memset(p, 0, n);\n      }\n      return p;\n    }\n\n    /*\n    ** Allocate and zero memory.  If the allocation fails, make\n    ** the mallocFailed flag in the connection pointer.\n    **\n    ** If db!=0 and db->mallocFailed is true (indicating a prior malloc\n    ** failure on the same database connection) then always return 0.\n    ** Hence for a particular database connection, once malloc starts\n    ** failing, it fails consistently until mallocFailed is reset.\n    ** This is an important assumption.  There are many places in the\n    ** code that do things like this:\n    **\n    **         int *a = (int*)sqlite3DbMallocRaw(db, 100);\n    **         int *b = (int*)sqlite3DbMallocRaw(db, 200);\n    **         if( b ) a[10] = 9;\n    **\n    ** In other words, if a subsequent malloc (ex: "b") worked, it is assumed\n    ** that all prior mallocs (ex: "a") worked too.\n    */\n    static byte[] sqlite3DbMallocRaw( sqlite3 db, int n )\n    {\n      byte[] p;\n      Debug.Assert( db == null || sqlite3_mutex_held( db.mutex ) );\n#if !SQLITE_OMIT_LOOKASIDE\nif( db ){\nLookasideSlot pBuf;\nif( db.mallocFailed !=0{\nreturn 0;\n}\nif( db.lookaside.bEnabled && n<=db.lookaside.sz\n&& (pBuf = db.lookaside.pFree)!=0 ){\ndb.lookaside.pFree = pBuf.pNext;\ndb.lookaside.nOut++;\nif( db.lookaside.nOut>db.lookaside.mxOut ){\ndb.lookaside.mxOut = db.lookaside.nOut;\n}\nreturn (void*)pBuf;\n}\n}\n#else\n      if ( db != null && db.mallocFailed != 0 )\n      {\n        return null;\n      }\n#endif\n      p = sqlite3Malloc( n );\n      if ( null == p && db != null )\n      {\n////        db.mallocFailed = 1;\n      }\n      return p;\n    }\n\n    /*\n    ** Resize the block of memory pointed to by p to n bytes. If the\n    ** resize fails, set the mallocFailed flag inthe connection object.\n    */\n    static object sqlite3DbRealloc( sqlite3 db, object p, int n )\n    {\n      return p;\n      //  void pNew = 0;\n      //assert( db!=0 );\n      //assert( sqlite3_mutex_held(db->mutex) );\n      //  if( db.mallocFailed==0 ){\n      //    if( p==0 ){\n      //      return sqlite3DbMallocRaw(db, n);\n      //    }\n      //    if( isLookaside(db, p) ){\n      //      if( n<=db.lookaside.sz ){\n      //        return p;\n      //      }\n      //      pNew = sqlite3DbMallocRaw(db, n);\n      //      if( pNew ){\n      //        memcpy(pNew, p, db.lookaside.sz);\n      //        //sqlite3DbFree(db, p);\n      //      }\n      //    }else{\n      //      pNew = sqlite3_realloc(p, n);\n      //      if( null==pNew ){\n      //////        db.mallocFailed = 1;\n      //      }\n      //    }\n      //  }\n      //  return pNew;\n    }\n\n    /*\n    ** Attempt to reallocate p.  If the reallocation fails, then free p\n    ** and set the mallocFailed flag in the database connection.\n    */\n    //static     void sqlite3DbReallocOrFree(sqlite3 db, object p, int n){\n    //  object pNew;\n    //  pNew = "";//sqlite3DbRealloc(db, p, n);\n    //      if( pNew ==null){\n    //        //sqlite3DbFree(db,ref  p);\n    //      }\n    //      return pNew;\n    //    }\n\n    /*\n    ** Make a copy of a string in memory obtained from sqliteMalloc(). These\n    ** functions call sqlite3MallocRaw() directly instead of sqliteMalloc(). This\n    ** is because when memory debugging is turned on, these two functions are\n    ** called via macros that record the current file and line number in the\n    ** ThreadData structure.\n    */\n    //char *sqlite3DbStrDup(sqlite3 db, const char *z){\n    //  char *zNew;\n    //  size_t n;\n    //  if( z==0 ){\n    //    return 0;\n    //  }\n    //  n = sqlite3Strlen30(z) + 1;\n    //  assert( (n&0x7fffffff)==n );\n    //  zNew = sqlite3DbMallocRaw(db, (int)n);\n    //  if( zNew ){\n    //    memcpy(zNew, z, n);\n    //  }\n    //  return zNew;\n    //}\n    //char *sqlite3DbStrNDup(sqlite3 *db, const char *z, int n){\n    //  char *zNew;\n    //  if( z==0 ){\n    //    return 0;\n    //  }\n    //  assert( (n&0x7fffffff)==n );\n    //  zNew = sqlite3DbMallocRaw(db, n+1);\n    //  if( zNew ){\n    //    memcpy(zNew, z, n);\n    //    zNew[n] = 0;\n    //  }\n    //  return zNew;\n    //}\n\n#endif\n    /*\n    ** Create a string from the zFromat argument and the va_list that follows.\n    ** Store the string in memory obtained from sqliteMalloc() and make pz\n    ** point to that string.\n    */\n    static void sqlite3SetString( ref byte[] pz, sqlite3 db, string zFormat, params string[] ap )\n    {\n      string sz = "";\n      sqlite3SetString( ref sz, db, zFormat, ap );\n      pz = Encoding.UTF8.GetBytes( sz );\n    }\n    static void sqlite3SetString( ref string pz, sqlite3 db, string zFormat, byte[] ap )\n    { sqlite3SetString( ref pz, db, zFormat, Encoding.UTF8.GetString( ap ) ); }\n\n    static void sqlite3SetString( ref string pz, sqlite3 db, string zFormat, params string[] ap )\n    {\n      //va_list ap;\n      string z;\n\n      va_start( ap, zFormat );\n      z = sqlite3VMPrintf( db, zFormat, ap );\n      va_end( ap );\n      //sqlite3DbFree( db, ref pz );\n      pz = z;\n    }\n\n    /*\n    ** This function must be called before exiting any API function (i.e.\n    ** returning control to the user) that has called sqlite3_malloc or\n    ** sqlite3_realloc.\n    **\n    ** The returned value is normally a copy of the second argument to this\n    ** function. However, if a malloc() failure has occurred since the previous\n    ** invocation SQLITE_NOMEM is returned instead.\n    **\n    ** If the first argument, db, is not NULL and a malloc() error has occurred,\n    ** then the connection error-code (the value returned by sqlite3_errcode())\n    ** is set to SQLITE_NOMEM.\n    */\n    static int sqlite3ApiExit( int zero, int rc )\n    {\n      sqlite3 db = null;\n      return sqlite3ApiExit( db, rc );\n    }\n\n    static int sqlite3ApiExit( sqlite3 db, int rc )\n    {\n      /* If the db handle is not NULL, then we must hold the connection handle\n      ** mutex here. Otherwise the read (and possible write) of db.mallocFailed\n      ** is unsafe, as is the call to sqlite3Error().\n      */\n      Debug.Assert( db == null || sqlite3_mutex_held( db.mutex ) );\n      if ( /*db != null && db.mallocFailed != 0 || */ rc == SQLITE_IOERR_NOMEM )\n      {\n        sqlite3Error( db, SQLITE_NOMEM, "" );\n        //db.mallocFailed = 0;\n        rc = SQLITE_NOMEM;\n      }\n      return rc & ( db != null ? db.errMask : 0xff );\n    }\n  }\n}\n'