b'// UVa1380 A Scheduling Problem\n// Rujia Liu\n#include<iostream>\n#include<string>\n#include<cstring>\n#include<sstream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nconst int maxn = 200 + 5;\nconst int INF = 1000000000;\n\nstruct Edge {\n  int u, v, d; // d=1 means u->v, d=2 means v->u, d=0 means u-v\n  Edge(int u=0, int v=0, int d=0):u(u),v(v),d(d){}\n};\n\nvector<Edge> edges[maxn];\nint n, root, maxlen, f[maxn], g[maxn], have_father[maxn];\n\n// maximal length of a DIRECTED path starting from u\nint dfs(int u) {\n  int ans = 0;\n  for(int i = 0; i < edges[u].size(); i++) {\n    int v = edges[u][i].v;\n    if(edges[u][i].d == 1)\n      ans = max(ans, dfs(v)+1);\n  }\n  return ans;\n}\n\nbool read_data() {\n  bool have_data = false;\n  int a, b;\n  n = 0;\n  for(int i = 0; i < maxn; i++) edges[i].clear();\n  memset(have_father, 0, sizeof(have_father));\n\n  while(cin >> a && a){\n    string str;\n    have_data = true;\n    if(a > n) n = a;\n    while(cin >> str && str != "0"){\n      int len = str.length();\n      char dir = str[len-1];\n      if(dir == \'d\' || dir == \'u\') str = str.substr(0, len-1);\n      stringstream ss(str);\n      ss >> b; // b is a\'s son\n      if(b > n) n = b;\n      have_father[b] = 1;\n      if(dir == \'d\'){\n        edges[a].push_back(Edge(a, b, 1)); // forward\n        edges[b].push_back(Edge(b, a, 2)); // backward\n      }else if(dir == \'u\'){\n        edges[a].push_back(Edge(a, b, 2));\n        edges[b].push_back(Edge(b, a, 1));\n      }else{\n        edges[a].push_back(Edge(a, b, 0)); // it\'s a rooted tree, so we don\'t store edge to father\n      }\n    }\n  }\n  if(have_data) {\n    for(int i = 1; i <= n; i++)\n      if(!have_father[i] && !edges[i].empty()) { root = i; break; }\n  }\n  return have_data;\n}\n\nstruct UndirectedSon {\n  int w, f, g;\n  UndirectedSon(int w=0, int f=0, int g=0):w(w),f(f),g(g){}\n};\n\nbool cmp_f(const UndirectedSon& w1, const UndirectedSon& w2) {\n  return w1.f < w2.f;\n}\n\nbool cmp_g(const UndirectedSon& w1, const UndirectedSon& w2) {\n  return w1.g < w2.g;\n}\n\n// calculate f[i] and g[i]\n// return true iff f[i] < INF\n// f[i] is the minimal length of the longest "->u" path if all subtree paths have length <= maxlen\n// g[i] is the minimal length of the longest "u->" path if all subtree paths have length <= maxlen\n// f[i] = g[i] = INF if "all subtree paths have length <= maxlen" cannot be satisfied\nbool dp(int i, int fa) {\n  if(edges[i].empty()) {\n    f[i] = g[i] = 0;\n    return true;\n  }\n  vector<UndirectedSon> sons;\n  int f0 = 0, g0 = 0; // f\'[i] and g\'[i] for directed sons\n\n  // let f\'[i] = max{f[w] | w->i}+1, g\'[i] = max{g[w] | i->w}+1\n  // then we should change some undirected edges to ->u or u-> edges so that f\'[i]+g\'[i] <= maxlen\n  // then f[i] is the minimal f\'[i] under this condition, and g[i] is the minimal g\'[i]\n  for(int k = 0; k < edges[i].size(); k++) {\n    int w = edges[i][k].v;\n    if(w == fa) continue;\n    dp(w, i);\n    int d = edges[i][k].d;\n    if(d == 0) sons.push_back(UndirectedSon(w, f[w], g[w]));\n    else if(d == 1) g0 = max(g0, g[w]+1);\n    else f0 = max(f0, f[w]+1);\n  }\n  // If there is no undirected edges, we\'re done\n  if(sons.empty()) {\n    f[i] = f0; g[i] = g0;\n    if(f[i] + g[i] > maxlen) { f[i] = g[i] = INF; }\n    return f[i] < INF;\n  }\n\n  f[i] = g[i] = INF;\n\n  // to calculate f[i], we sort f[w] of undirected sons in increasing order and make first p edges to w->i\n  // then we calculate f\'[i] and g\'[i], check for f\'[i]+g\'[i] <= maxlen and update answer\n  int s = sons.size();\n  sort(sons.begin(), sons.end(), cmp_f);\n  int maxg[maxn]; // maxg[i] is max{sons[i].g, sons[i+1].g, ...}\n  maxg[s-1] = sons[s-1].g;\n  for(int k = s-2; k >= 0; k--)\n    maxg[k] = max(sons[k].g, maxg[k+1]);\n  for(int p = 0; p <= sons.size(); p++) {\n    int ff = f0, gg = g0;\n    if(p > 0) ff = max(ff, sons[p-1].f+1);\n    if(p < sons.size()) gg = max(gg, maxg[p]+1);\n    if(ff + gg <= maxlen) f[i] = min(f[i], ff);\n  }\n\n  // g[i] is similar\n  sort(sons.begin(), sons.end(), cmp_g);\n  int maxf[maxn]; // maxf[i] is max{sons[i].f, sons[i+1].f, ...}\n  maxf[s-1] = sons[s-1].f;\n  for(int k = s-2; k >= 0; k--)\n    maxf[k] = max(sons[k].f, maxf[k+1]);\n  for(int p = 0; p <= sons.size(); p++) {\n    int ff = f0, gg = g0;\n    if(p > 0) gg = max(gg, sons[p-1].g+1);\n    if(p < sons.size()) ff = max(ff, maxf[p]+1);\n    if(ff + gg <= maxlen) g[i] = min(g[i], gg);\n  }\n\n  return f[i] < INF;\n}\n\nint main() {\n  while(read_data()) {    \n    maxlen = 0;\n    for(int i = 1; i <= n; i++) maxlen = max(maxlen, dfs(i));\n    // Note: the problem asks for the number of nodes in path, but all the "lengths" above mean "number of edges"\n    if(dp(root, -1)) cout << maxlen+1 << "\\n"; \n    else cout << maxlen+2 << "\\n";\n  }\n  return 0;\n}\n'