b'#include "stdafx.h"\n#include "../AssetsTools/BundleReplacer.h"\n#include "../AssetsTools/AssetsFileTable.h"\n#include "InternalBundleReplacer.h"\n#include <unordered_map>\n\n//class BundleEntryRemover : public BundleReplacer\n//{\n\tBundleEntryRemover::BundleEntryRemover(const char *name, unsigned int bundleListIndex)\n\t{\n\t\tthis->bundleListIndex = bundleListIndex;\n\t\tif (name)\n\t\t{\n\t\t\tsize_t nameLen = strlen(name);\n\t\t\toriginalEntryName = new char[nameLen + 1];\n\t\t\tmemcpy(originalEntryName, name, nameLen+1);\n\t\t}\n\t\telse\n\t\t\toriginalEntryName = NULL;\n\t}\n\tBundleReplacementType BundleEntryRemover::GetType() { return BundleReplacement_Remove; }\n\tBundleEntryRemover::~BundleEntryRemover()\n\t{\n\t\tif (originalEntryName)\n\t\t\tdelete[] originalEntryName;\n\t}\n\t\t\n\tunsigned int BundleEntryRemover::GetBundleListIndex() { return bundleListIndex; }\n\n\tconst char *BundleEntryRemover::GetOriginalEntryName() { return originalEntryName; }\n\tconst char *BundleEntryRemover::GetEntryName() { return originalEntryName; }\n\n\tQWORD BundleEntryRemover::GetSize() { return 0; }\n\n\tbool BundleEntryRemover::Init(AssetBundleFile *pBundleFile,\n\t\tIAssetsReader *pEntryReader,\n\t\tQWORD entryPos, QWORD entrySize,\n\t\tClassDatabaseFile *typeMeta){return true;}\n\tvoid BundleEntryRemover::Uninit(){}\n\n\tQWORD BundleEntryRemover::Write(QWORD pos, IAssetsWriter *pWriter) {return pos;}\n\tQWORD BundleEntryRemover::WriteReplacer(QWORD pos, IAssetsWriter *pWriter)\n\t{\n\t\tuint16_t replacerType = BundleReplacer_BundleEntryRemover;\n\t\tpos += pWriter->Write(pos, 2, &replacerType);\n\t\tuint8_t fileVersion = 1;\n\t\tpos += pWriter->Write(pos, 1, &fileVersion);\n\n\t\tuint8_t hasOriginalName = (this->originalEntryName != nullptr) ? 1 : 0;\n\t\tpos += pWriter->Write(pos, 1, &hasOriginalName);\n\t\tif (hasOriginalName)\n\t\t{\n\t\t\tuint16_t originalNameLen = (uint16_t)strlen(this->originalEntryName);\n\t\t\tpos += pWriter->Write(pos, 2, &originalNameLen);\n\t\t\tpos += pWriter->Write(pos, originalNameLen, originalEntryName);\n\t\t}\n\t\treturn pos;\n\t}\n\n\tbool BundleEntryRemover::HasSerializedData() { return false; }\n\t\n\tbool BundleEntryRemover::RequiresEntryReader() { return false; }\n//};\n\n//class BundleEntryRenamer : public BundleReplacer\n//{\n\tBundleEntryRenamer::BundleEntryRenamer(const char *oldName, const char *newName, unsigned int bundleListIndex, bool hasSerializedData)\n\t{\n\t\tthis->bundleListIndex = bundleListIndex;\n\t\tif (oldName)\n\t\t{\n\t\t\tsize_t nameLen = strlen(oldName);\n\t\t\toriginalEntryName = new char[nameLen + 1];\n\t\t\tmemcpy(originalEntryName, oldName, nameLen+1);\n\t\t}\n\t\telse\n\t\t\toriginalEntryName = NULL;\n\t\tif (newName)\n\t\t{\n\t\t\tsize_t nameLen = strlen(newName);\n\t\t\tnewEntryName = new char[nameLen + 1];\n\t\t\tmemcpy(newEntryName, newName, nameLen+1);\n\t\t}\n\t\telse\n\t\t\tnewEntryName = originalEntryName;\n\t\tthis->hasSerializedData = hasSerializedData;\n\t}\n\tBundleReplacementType BundleEntryRenamer::GetType() { return BundleReplacement_Rename; }\n\tBundleEntryRenamer::~BundleEntryRenamer()\n\t{\n\t\tif (newEntryName && (newEntryName != originalEntryName))\n\t\t\tdelete[] newEntryName;\n\t\tif (originalEntryName)\n\t\t\tdelete[] originalEntryName;\n\t}\n\t\t\n\tunsigned int BundleEntryRenamer::GetBundleListIndex() { return bundleListIndex; }\n\n\tconst char *BundleEntryRenamer::GetOriginalEntryName() { return originalEntryName; }\n\tconst char *BundleEntryRenamer::GetEntryName() { return newEntryName; }\n\n\tQWORD BundleEntryRenamer::GetSize() { return (QWORD)-1; }\n\n\tbool BundleEntryRenamer::Init(AssetBundleFile *pBundleFile,\n\t\tIAssetsReader *pEntryReader,\n\t\tQWORD entryPos, QWORD entrySize,\n\t\tClassDatabaseFile *typeMeta){return true;}\n\tvoid BundleEntryRenamer::Uninit(){}\n\n\tQWORD BundleEntryRenamer::Write(QWORD pos, IAssetsWriter *pWriter) {return pos;}\n\tQWORD BundleEntryRenamer::WriteReplacer(QWORD pos, IAssetsWriter *pWriter)\n\t{\n\t\tuint16_t replacerType = BundleReplacer_BundleEntryRenamer;\n\t\tpos += pWriter->Write(pos, 2, &replacerType);\n\t\tuint8_t fileVersion = 1;\n\t\tpos += pWriter->Write(pos, 1, &fileVersion);\n\n\t\tuint8_t hasOriginalName = (this->originalEntryName != nullptr) ? 1 : 0;\n\t\tpos += pWriter->Write(pos, 1, &hasOriginalName);\n\t\tif (hasOriginalName)\n\t\t{\n\t\t\tuint16_t originalNameLen = (uint16_t)strlen(this->originalEntryName);\n\t\t\tpos += pWriter->Write(pos, 2, &originalNameLen);\n\t\t\tpos += pWriter->Write(pos, originalNameLen, originalEntryName);\n\t\t}\n\t\t\n\t\tuint8_t hasNewName = (this->newEntryName != nullptr) ? 1 : 0;\n\t\tpos += pWriter->Write(pos, 1, &hasNewName);\n\t\tif (hasNewName)\n\t\t{\n\t\t\tuint16_t newNameLen = (uint16_t)strlen(newEntryName);\n\t\t\tpos += pWriter->Write(pos, 2, &newNameLen);\n\t\t\tpos += pWriter->Write(pos, newNameLen, newEntryName);\n\t\t}\n\n\t\tuint8_t temp = hasSerializedData ? 1 : 0;\n\t\tpos += pWriter->Write(pos, 1, &temp);\n\t\treturn pos;\n\t}\n\n\tbool BundleEntryRenamer::HasSerializedData() { return hasSerializedData; }\n\t\n\tbool BundleEntryRenamer::RequiresEntryReader() { return false; }\n//};\n\n//class BundleEntryModifier : public BundleEntryRenamer\n//{\n\tBundleEntryModifier::BundleEntryModifier(const char *oldName, const char *newName, unsigned int bundleListIndex, bool hasSerializedData, \n\t\tstd::shared_ptr<IAssetsReader> pReader, QWORD size, QWORD readerPos, \n\t\tsize_t copyBufferLen)\n\t\t: BundleEntryRenamer(oldName, newName, bundleListIndex, hasSerializedData)\n\t{\n\t\tthis->pReader = std::move(pReader);\n\t\tthis->size = size;\n\t\tthis->readerPos = readerPos;\n\t\tthis->copyBufferLen = copyBufferLen;\n\t}\n\tBundleReplacementType BundleEntryModifier::GetType() { return BundleReplacement_AddOrModify; }\n\tBundleEntryModifier::~BundleEntryModifier()\n\t{}\n\n\tQWORD BundleEntryModifier::GetSize() { return size; }\n\n\tbool BundleEntryModifier::Init(AssetBundleFile *pBundleFile,\n\t\tIAssetsReader *pEntryReader,\n\t\tQWORD entryPos, QWORD entrySize,\n\t\tClassDatabaseFile *typeMeta){return true;}\n\tvoid BundleEntryModifier::Uninit(){}\n\n\tQWORD BundleEntryModifier::Write(QWORD writerPos, IAssetsWriter *pWriter)\n\t{\n\t\tQWORD curReaderPos = readerPos;\n\t\tuint8_t stackCopyBuffer[1024]; size_t actualBufferLen = copyBufferLen;\n\t\tvoid *pCopyBuffer = NULL;\n\t\tif (copyBufferLen)\n\t\t\tpCopyBuffer = malloc(copyBufferLen);\n\t\tif (!pCopyBuffer)\n\t\t{\n\t\t\tpCopyBuffer = stackCopyBuffer;\n\t\t\tactualBufferLen = 1024;\n\t\t}\n\n\t\tQWORD remainingSize = size;\n\t\twhile (remainingSize)\n\t\t{\n\t\t\tsize_t curSize = (remainingSize > actualBufferLen) ? actualBufferLen : remainingSize;\n\t\t\tQWORD len = pReader->Read(curReaderPos, curSize, pCopyBuffer);\n\t\t\tcurReaderPos += len;\n\t\t\twriterPos += pWriter->Write(writerPos, len, pCopyBuffer);\n\t\t\tremainingSize -= len;\n\t\t\tif (!len)\n\t\t\t\tbreak; //read error\n\t\t}\n\n\t\tif (pCopyBuffer != stackCopyBuffer)\n\t\t\tfree(pCopyBuffer);\n\t\treturn writerPos;\n\t}\n\tQWORD BundleEntryModifier::WriteReplacer(QWORD pos, IAssetsWriter *pWriter)\n\t{\n\t\tuint16_t replacerType = BundleReplacer_BundleEntryModifier;\n\t\tpos += pWriter->Write(pos, 2, &replacerType);\n\t\tuint8_t fileVersion = 1;\n\t\tpos += pWriter->Write(pos, 1, &fileVersion);\n\n\t\tuint8_t hasOriginalName = (this->originalEntryName != nullptr) ? 1 : 0;\n\t\tpos += pWriter->Write(pos, 1, &hasOriginalName);\n\t\tif (hasOriginalName)\n\t\t{\n\t\t\tuint16_t originalNameLen = (uint16_t)strlen(this->originalEntryName);\n\t\t\tpos += pWriter->Write(pos, 2, &originalNameLen);\n\t\t\tpos += pWriter->Write(pos, originalNameLen, originalEntryName);\n\t\t}\n\t\t\n\t\tuint8_t hasNewName = (this->newEntryName != nullptr) ? 1 : 0;\n\t\tpos += pWriter->Write(pos, 1, &hasNewName);\n\t\tif (hasNewName)\n\t\t{\n\t\t\tuint16_t newNameLen = (uint16_t)strlen(newEntryName);\n\t\t\tpos += pWriter->Write(pos, 2, &newNameLen);\n\t\t\tpos += pWriter->Write(pos, newNameLen, newEntryName);\n\t\t}\n\n\t\tuint8_t temp = hasSerializedData ? 1 : 0;\n\t\tpos += pWriter->Write(pos, 1, &temp);\n\n\t\tpos += pWriter->Write(pos, 8, &size);\n\t\tpos = Write(pos, pWriter);\n\t\treturn pos;\n\t}\n//};\n\n//class BundleEntryModifierFromMem : public BundleEntryRenamer\n//{\n\tBundleEntryModifierFromMem::BundleEntryModifierFromMem(const char *oldName, const char *newName, unsigned int bundleListIndex, bool hasSerializedData, \n\t\tvoid *pMem, size_t size, cbFreeMemoryResource freeResourceCallback)\n\t\t: BundleEntryRenamer(oldName, newName, bundleListIndex, hasSerializedData)\n\t{\n\t\tthis->pMem = pMem;\n\t\tthis->size = size;\n\t\tthis->freeResourceCallback = freeResourceCallback;\n\t}\n\tBundleReplacementType BundleEntryModifierFromMem::GetType() { return BundleReplacement_AddOrModify; }\n\tBundleEntryModifierFromMem::~BundleEntryModifierFromMem()\n\t{\n\t\tif (pMem && freeResourceCallback)\n\t\t{\n\t\t\tfreeResourceCallback(pMem);\n\t\t\tpMem = NULL;\n\t\t\tfreeResourceCallback = NULL;\n\t\t\tsize = 0;\n\t\t}\n\t}\n\n\tQWORD BundleEntryModifierFromMem::GetSize() { return size; }\n\n\tbool BundleEntryModifierFromMem::Init(AssetBundleFile *pBundleFile,\n\t\tIAssetsReader *pEntryReader,\n\t\tQWORD entryPos, QWORD entrySize,\n\t\tClassDatabaseFile *typeMeta){return true;}\n\tvoid BundleEntryModifierFromMem::Uninit(){}\n\n\tQWORD BundleEntryModifierFromMem::Write(QWORD writerPos, IAssetsWriter *pWriter)\n\t{\n\t\treturn writerPos + pWriter->Write(writerPos, size, pMem);\n\t}\n\tQWORD BundleEntryModifierFromMem::WriteReplacer(QWORD pos, IAssetsWriter *pWriter)\n\t{\n\t\tuint16_t replacerType = BundleReplacer_BundleEntryModifierFromMem;\n\t\tpos += pWriter->Write(pos, 2, &replacerType);\n\t\tuint8_t fileVersion = 1;\n\t\tpos += pWriter->Write(pos, 1, &fileVersion);\n\n\t\tuint8_t hasOriginalName = (this->originalEntryName != nullptr) ? 1 : 0;\n\t\tpos += pWriter->Write(pos, 1, &hasOriginalName);\n\t\tif (hasOriginalName)\n\t\t{\n\t\t\tuint16_t originalNameLen = (uint16_t)strlen(this->originalEntryName);\n\t\t\tpos += pWriter->Write(pos, 2, &originalNameLen);\n\t\t\tpos += pWriter->Write(pos, originalNameLen, originalEntryName);\n\t\t}\n\t\t\n\t\tuint8_t hasNewName = (this->newEntryName != nullptr) ? 1 : 0;\n\t\tpos += pWriter->Write(pos, 1, &hasNewName);\n\t\tif (hasNewName)\n\t\t{\n\t\t\tuint16_t newNameLen = (uint16_t)strlen(newEntryName);\n\t\t\tpos += pWriter->Write(pos, 2, &newNameLen);\n\t\t\tpos += pWriter->Write(pos, newNameLen, newEntryName);\n\t\t}\n\n\t\tuint8_t temp = hasSerializedData ? 1 : 0;\n\t\tpos += pWriter->Write(pos, 1, &temp);\n\n\t\tQWORD qwSize = size;\n\t\tpos += pWriter->Write(pos, 8, &qwSize);\n\t\tpos = Write(pos, pWriter);\n\t\treturn pos;\n\t}\n//};\n\n//class BundleEntryModifierFromAssets : public BundleEntryRenamer\n//{\n\tBundleEntryModifierFromAssets::BundleEntryModifierFromAssets(const char *oldName, const char *newName, unsigned int bundleListIndex, \n\t\tAssetsFile *pAssetsFile, AssetsReplacer **pReplacers, size_t replacerCount, uint32_t fileId)\n\t\t: BundleEntryRenamer(oldName, newName, bundleListIndex, true)\n\t{\n\t\tthis->pAssetsFile = pAssetsFile;\n\t\tthis->pReplacers.assign(&pReplacers[0], &pReplacers[replacerCount]);\n\t\tthis->fileId = fileId;\n\t\tthis->freeAssetsFile = false;\n\t\tthis->typeMeta = NULL;\n\t}\n\tBundleEntryModifierFromAssets::BundleEntryModifierFromAssets(const char *oldName, const char *newName, unsigned int bundleListIndex, \n\t\tstd::shared_ptr<ClassDatabaseFile> typeMeta, std::vector<std::shared_ptr<AssetsReplacer>> pReplacers, uint32_t fileId)\n\t\t: BundleEntryRenamer(oldName, newName, bundleListIndex, true)\n\t{\n\t\tthis->pAssetsFile = nullptr;\n\t\tthis->typeMeta = typeMeta.get();\n\t\tthis->typeMeta_shared = std::move(typeMeta);\n\t\tthis->pReplacers.resize(pReplacers.size());\n\t\tfor (size_t i = 0; i < pReplacers.size(); i++)\n\t\t\tthis->pReplacers[i] = pReplacers[i].get();\n\t\tthis->pReplacers_shared = std::move(pReplacers);\n\t\tthis->freeAssetsFile = false;\n\t\tthis->fileId = fileId;\n\t}\n\tBundleReplacementType BundleEntryModifierFromAssets::GetType() { return BundleReplacement_AddOrModify; }\n\tBundleEntryModifierFromAssets::~BundleEntryModifierFromAssets()\n\t{\n\t\tUninit();\n\t}\n\n\t//Relatively precise; returns all raw asset sizes, the size plus alignment of the file table, the header size and the dependencies list size.\n\t//Does not count the TypeTree size and ignores dependency list replacers.\n\tQWORD BundleEntryModifierFromAssets::GetSize()\n\t{\n\t\tif (!pAssetsFile)\n\t\t\treturn 0;\n\t\tQWORD ret = pAssetsFile->header.GetSizeBytes();\n\t\tret += 5;\n\t\tAssetsFileDependencyList dependencyList = pAssetsFile->dependencies;\n\t\t\t\n\t\tAssetsFileTable fileTable = AssetsFileTable(pAssetsFile);\n\t\tfor (size_t i = 0; i < fileTable.assetFileInfoCount; i++)\n\t\t{\n\t\t\tQWORD pathId = fileTable.pAssetFileInfo[i].index;\n\t\t\tQWORD fileSize = fileTable.pAssetFileInfo[i].curFileSize;\n\t\t\tbool isModified = false, isDeleted = false;\n\t\t\tfor (size_t k = pReplacers.size(); k > 0; k--)\n\t\t\t{\n\t\t\t\tif (pReplacers[k-1]->GetType() == AssetsReplacement_Dependencies)\n\t\t\t\t{\n\t\t\t\t\tAssetsDependenciesReplacer* pDepReplacer =\n\t\t\t\t\t\treinterpret_cast<AssetsDependenciesReplacer*>(pReplacers[k - 1]);\n\t\t\t\t\tconst std::vector<AssetsFileDependency> &dependencies = pDepReplacer->GetDependencies();\n\t\t\t\t\tdependencyList.pDependencies = const_cast<AssetsFileDependency*>(dependencies.data());\n\t\t\t\t\tdependencyList.dependencyCount = (uint32_t)dependencies.size();\n\t\t\t\t}\n\t\t\t\tif (pReplacers[k-1]->GetType() != AssetsReplacement_AddOrModify\n\t\t\t\t\t&& pReplacers[k-1]->GetType() != AssetsReplacement_Remove)\n\t\t\t\t\tcontinue;\n\t\t\t\tAssetsEntryReplacer *pReplacer = reinterpret_cast<AssetsEntryReplacer*>(pReplacers[k-1]);\n\t\t\t\tif (pathId == pReplacer->GetPathID())\n\t\t\t\t{\n\t\t\t\t\tif (!isModified && (pReplacer->GetType() == AssetsReplacement_AddOrModify))\n\t\t\t\t\t{\n\t\t\t\t\t\tfileSize = pReplacer->GetSize();\n\t\t\t\t\t\tisModified = true;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (pReplacer->GetType() == AssetsReplacement_Remove)\n\t\t\t\t\t{\n\t\t\t\t\t\tisDeleted = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!isDeleted)\n\t\t\t\tret += ((fileSize + 3) & (~3)) + ((fileTable.pAssetFileInfo[i].GetSize(pAssetsFile->header.format) + 3) & (~3));\n\t\t}\n\n\t\tfor (uint32_t i = 0; i < dependencyList.dependencyCount; i++)\n\t\t{\n\t\t\tret += strlen(dependencyList.pDependencies[i].assetPath) + 1;\n\t\t\tret += strlen(dependencyList.pDependencies[i].bufferedPath) + 1;\n\t\t\tret += 20; //GUID and type\n\t\t}\n\n\t\treturn ret;\n\t}\n\n\tbool BundleEntryModifierFromAssets::Init(AssetBundleFile *pBundleFile,\n\t\tIAssetsReader *pEntryReader,\n\t\tQWORD entryPos, QWORD entrySize,\n\t\tClassDatabaseFile *typeMeta)\n\t{\n\t\tUninit();\n\t\tif (pAssetsFile)\n\t\t\treturn true;\n\t\tif (pEntryReader == nullptr)\n\t\t\treturn false;\n\t\tpEntryReader = Create_AssetsReaderFromReaderRange(pEntryReader, entryPos, entrySize);\n\t\tpAssetsFile = new AssetsFile(pEntryReader);\n\t\tif (!pAssetsFile->VerifyAssetsFile())\n\t\t{\n\t\t\tFree_AssetsReader(pEntryReader);\n\t\t\tdelete pAssetsFile;\n\t\t\tpAssetsFile = NULL;\n\t\t\treturn false;\n\t\t}\n\t\tfreeAssetsFile = true;\n\t\tif (this->typeMeta == nullptr)\n\t\t\tthis->typeMeta = typeMeta;\n\t\treturn true;\n\t}\n\tvoid BundleEntryModifierFromAssets::Uninit()\n\t{\n\t\tif (pAssetsFile && freeAssetsFile)\n\t\t{\n\t\t\tFree_AssetsReader(pAssetsFile->pReader);\n\t\t\tdelete pAssetsFile;\n\t\t\tpAssetsFile = NULL;\n\t\t\tfreeAssetsFile = false;\n\t\t}\n\t}\n\n\tQWORD BundleEntryModifierFromAssets::Write(QWORD writerPos, IAssetsWriter *pWriter)\n\t{\n\t\treturn pAssetsFile->Write(pWriter, writerPos, pReplacers.data(), pReplacers.size(), fileId, typeMeta);\n\t}\n\tQWORD BundleEntryModifierFromAssets::WriteReplacer(QWORD pos, IAssetsWriter *pWriter)\n\t{\n\t\tuint16_t replacerType = BundleReplacer_BundleEntryModifierFromAssets;\n\t\tpos += pWriter->Write(pos, 2, &replacerType);\n\t\tuint8_t fileVersion = 1;\n\t\tpos += pWriter->Write(pos, 1, &fileVersion);\n\n\t\tuint8_t hasOriginalName = (this->originalEntryName != nullptr) ? 1 : 0;\n\t\tpos += pWriter->Write(pos, 1, &hasOriginalName);\n\t\tif (hasOriginalName)\n\t\t{\n\t\t\tuint16_t originalNameLen = (uint16_t)strlen(this->originalEntryName);\n\t\t\tpos += pWriter->Write(pos, 2, &originalNameLen);\n\t\t\tpos += pWriter->Write(pos, originalNameLen, originalEntryName);\n\t\t}\n\t\t\n\t\tuint8_t hasNewName = (this->newEntryName != nullptr) ? 1 : 0;\n\t\tpos += pWriter->Write(pos, 1, &hasNewName);\n\t\tif (hasNewName)\n\t\t{\n\t\t\tuint16_t newNameLen = (uint16_t)strlen(newEntryName);\n\t\t\tpos += pWriter->Write(pos, 2, &newNameLen);\n\t\t\tpos += pWriter->Write(pos, newNameLen, newEntryName);\n\t\t}\n\n\t\tbool temp = true;\n\t\tpos += pWriter->Write(pos, 1, &temp);\n\n\t\tQWORD ullReplacerCount = pReplacers.size();\n\t\tpos += pWriter->Write(pos, 8, &ullReplacerCount);\n\t\tfor (size_t i = 0; i < pReplacers.size(); i++)\n\t\t{\n\t\t\tpos = pReplacers[i]->WriteReplacer(pos, pWriter);\n\t\t}\n\t\treturn pos;\n\t}\n\tAssetsReplacer **BundleEntryModifierFromAssets::GetReplacers(size_t &count)\n\t{\n\t\tcount = pReplacers.size();\n\t\treturn pReplacers.data();\n\t}\n\tAssetsFile *BundleEntryModifierFromAssets::GetAssignedAssetsFile()\n\t{\n\t\treturn pAssetsFile;\n\t}\n\tuint32_t BundleEntryModifierFromAssets::GetFileID()\n\t{\n\t\treturn fileId;\n\t}\n\t\n\tbool BundleEntryModifierFromAssets::RequiresEntryReader() { return true; }\n//};\n\n//class BundleEntryModifierFromBundle : public BundleEntryRenamer\n//{\n\tBundleEntryModifierFromBundle::BundleEntryModifierFromBundle(const char *oldName, const char *newName, unsigned int bundleListIndex, \n\t\t\tBundleReplacer **pReplacers, size_t replacerCount)\n\t\t: BundleEntryRenamer(oldName, newName, bundleListIndex, true)\n\t{\n\t\tthis->pBundleFile = nullptr;\n\t\tthis->pBundleReader = nullptr;\n\t\tthis->pReplacers.assign(&pReplacers[0], &pReplacers[replacerCount]);\n\t\tthis->freeBundleFile = false;\n\t\tthis->typeMeta = nullptr;\n\t}\n\tBundleEntryModifierFromBundle::BundleEntryModifierFromBundle(const char *oldName, const char *newName, unsigned int bundleListIndex,\n\t\t\tstd::vector<std::unique_ptr<BundleReplacer>> pReplacers)\n\t\t: BundleEntryRenamer(oldName, newName, bundleListIndex, true)\n\t{\n\t\tthis->pBundleFile = nullptr;\n\t\tthis->pBundleReader = nullptr;\n\t\tthis->pReplacers.resize(pReplacers.size());\n\t\tfor (size_t i = 0; i < pReplacers.size(); i++)\n\t\t\tthis->pReplacers[i] = pReplacers[i].get();\n\t\tthis->pReplacers_unique = std::move(pReplacers);\n\t\tthis->freeBundleFile = false;\n\t\tthis->typeMeta = NULL;\n\t}\n\tBundleReplacementType BundleEntryModifierFromBundle::GetType() { return BundleReplacement_AddOrModify; }\n\tBundleEntryModifierFromBundle::~BundleEntryModifierFromBundle()\n\t{\n\t\tUninit();\n\t}\n\n\t//Returns a rough estimate of the new file size.\n\tQWORD BundleEntryModifierFromBundle::GetSize()\n\t{\n\t\tif (!pBundleFile)\n\t\t\treturn 0;\n\t\tQWORD ret = 0;\n\t\tuint32_t directorySize = 0;\n\t\tif (pBundleFile->bundleHeader3.fileVersion == 3)\n\t\t{\n\t\t\tret += 128 + pBundleFile->bundleHeader3.blockCount * 8;\n\t\t\tdirectorySize = (pBundleFile->assetsLists3 != nullptr) ? pBundleFile->assetsLists3->count : 0;\n\t\t}\n\t\telse if (pBundleFile->bundleHeader6.fileVersion >= 6)\n\t\t{\n\t\t\tret += pBundleFile->bundleHeader6.GetFileDataOffset();\n\t\t\tif ((pBundleFile->bundleHeader6.flags & 0x80) != 0)\n\t\t\t\tret += pBundleFile->bundleHeader6.decompressedSize;\n\t\t\tdirectorySize = (pBundleFile->bundleInf6 != nullptr) ? pBundleFile->bundleInf6->directoryCount : 0;\n\t\t}\n\t\tstd::vector<BundleReplacer*> newReplacers;\n\t\tstd::vector<BundleReplacer*> directoryToReplacerMapping(directorySize);\n\t\tfor (size_t i = 0; i < this->pReplacers.size(); i++)\n\t\t{\n\t\t\tunsigned int listIndex = this->pReplacers[i]->GetBundleListIndex();\n\t\t\tif (listIndex < directorySize)\n\t\t\t\tdirectoryToReplacerMapping[listIndex] = this->pReplacers[i];\n\t\t\telse if (this->pReplacers[i]->GetType() == BundleReplacement_AddOrModify)\n\t\t\t\tnewReplacers.push_back(this->pReplacers[i]);\n\t\t}\n\n\t\tfor (uint32_t i = 0; i < directorySize; i++)\n\t\t{\n\t\t\tQWORD entryByteLen = 0;\n\t\t\tconst char *newEntryName = nullptr;\n\t\t\tif (pBundleFile->bundleHeader3.fileVersion == 3)\n\t\t\t{\n\t\t\t\tentryByteLen = pBundleFile->assetsLists3->ppEntries[i]->length;\n\t\t\t\tnewEntryName = pBundleFile->assetsLists3->ppEntries[i]->name;\n\t\t\t}\n\t\t\telse if (pBundleFile->bundleHeader3.fileVersion >= 6)\n\t\t\t{\n\t\t\t\tentryByteLen = pBundleFile->bundleInf6->dirInf[i].decompressedSize;\n\t\t\t\tnewEntryName = pBundleFile->bundleInf6->dirInf[i].name;\n\t\t\t}\n\t\t\tif (directoryToReplacerMapping[i] == nullptr)\n\t\t\t{ }\n\t\t\telse if (directoryToReplacerMapping[i]->GetType() == BundleReplacement_AddOrModify)\n\t\t\t{\n\t\t\t\tQWORD entrySizeVal = directoryToReplacerMapping[i]->GetSize();\n\t\t\t\tif (entrySizeVal != (QWORD)-1)\n\t\t\t\t\tentryByteLen = entrySizeVal;\n\t\t\t}\n\t\t\telse if (directoryToReplacerMapping[i]->GetType() == BundleReplacement_Remove)\n\t\t\t\tcontinue;\n\t\t\t\n\t\t\tif (directoryToReplacerMapping[i] != nullptr)\n\t\t\t{\n\t\t\t\tconst char *replacerNewName = directoryToReplacerMapping[i]->GetEntryName();\n\t\t\t\tif (replacerNewName != nullptr)\n\t\t\t\t\tnewEntryName = replacerNewName;\n\t\t\t}\n\t\t\tret += ((newEntryName == nullptr) ? 0 : strlen(newEntryName)) + 20;\n\t\t\tret += entryByteLen + 16;\n\t\t}\n\t\tfor (size_t i = 0; i < newReplacers.size(); i++)\n\t\t{\n\t\t\tconst char *newEntryName = newReplacers[i]->GetEntryName();\n\t\t\tQWORD entryByteLen = newReplacers[i]->GetSize();\n\t\t\tif (entryByteLen == (QWORD)-1) \n\t\t\t\tentryByteLen = 0;\n\t\t\tret += ((newEntryName == nullptr) ? 0 : strlen(newEntryName)) + 20;\n\t\t\tret += entryByteLen + 16;\n\t\t}\n\n\t\treturn ret;\n\t}\n\n\tbool BundleEntryModifierFromBundle::Init(AssetBundleFile *pBundleFile,\n\t\tIAssetsReader *pEntryReader,\n\t\tQWORD entryPos, QWORD entrySize,\n\t\tClassDatabaseFile *typeMeta)\n\t{\n\t\tUninit();\n\t\tif (pEntryReader == nullptr)\n\t\t\treturn false;\n\t\tthis->pBundleReader = Create_AssetsReaderFromReaderRange(pEntryReader, entryPos, entrySize);\n\t\tthis->pBundleFile = new AssetBundleFile();\n\t\tif (!this->pBundleFile->Read(this->pBundleReader) || \n\t\t\t(this->pBundleFile->bundleHeader3.fileVersion == 3 && this->pBundleFile->assetsLists3 == nullptr) ||\n\t\t\t(this->pBundleFile->bundleHeader6.fileVersion >= 6 && this->pBundleFile->bundleInf6 == nullptr) ||\n\t\t\t(this->pBundleFile->bundleHeader6.fileVersion < 6 && this->pBundleFile->bundleHeader3.fileVersion != 3))\n\t\t{\n\t\t\tFree_AssetsReader(this->pBundleReader);\n\t\t\tthis->pBundleReader = nullptr;\n\t\t\tdelete this->pBundleFile;\n\t\t\tthis->pBundleFile = nullptr;\n\t\t\treturn false;\n\t\t}\n\t\tthis->freeBundleFile = true;\n\t\tthis->typeMeta = typeMeta;\n\t\t//Call Init for all child bundle replacers.\n\t\tfor (size_t i = 0; i < this->pReplacers.size(); i++)\n\t\t{\n\t\t\tthis->pReplacers[i]->Uninit();\n\t\t\tunsigned int bundleListIdx = this->pReplacers[i]->GetBundleListIndex();\n\t\t\tuint64_t bundleEntryPos = 0, bundleEntryLen = 0;\n\t\t\tif (bundleListIdx == (unsigned int)-1)\n\t\t\t{\n\t\t\t\tconst char *entryName = this->pReplacers[i]->GetOriginalEntryName();\n\t\t\t\tif (entryName == nullptr)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (this->pBundleFile->bundleHeader3.fileVersion == 3)\n\t\t\t\t{\n\t\t\t\t\tfor (uint32_t iDirEntry = 0; iDirEntry < this->pBundleFile->assetsLists3->count; iDirEntry++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (!strcmp(entryName, this->pBundleFile->assetsLists3->ppEntries[iDirEntry]->name))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tbundleListIdx = iDirEntry;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (this->pBundleFile->bundleHeader6.fileVersion >= 6)\n\t\t\t\t{\n\t\t\t\t\tfor (uint32_t iDirEntry = 0; iDirEntry < this->pBundleFile->bundleInf6->directoryCount; iDirEntry++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (!strcmp(entryName, this->pBundleFile->bundleInf6->dirInf[iDirEntry].name))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tbundleListIdx = iDirEntry;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (bundleListIdx == (unsigned int)-1)\n\t\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (this->pBundleFile->bundleHeader3.fileVersion == 3)\n\t\t\t{\n\t\t\t\tbundleEntryPos = this->pBundleFile->assetsLists3->ppEntries[bundleListIdx]->GetAbsolutePos(pBundleFile);\n\t\t\t\tbundleEntryLen = this->pBundleFile->assetsLists3->ppEntries[bundleListIdx]->length;\n\t\t\t}\n\t\t\telse if (this->pBundleFile->bundleHeader6.fileVersion >= 6)\n\t\t\t{\n\t\t\t\tbundleEntryPos = this->pBundleFile->bundleInf6->dirInf[bundleListIdx].GetAbsolutePos(pBundleFile);\n\t\t\t\tbundleEntryLen = this->pBundleFile->bundleInf6->dirInf[bundleListIdx].decompressedSize;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tassert(false);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tthis->pReplacers[i]->Init(this->pBundleFile, this->pBundleReader, bundleEntryPos, bundleEntryLen, typeMeta);\n\t\t}\n\t\treturn true;\n\t}\n\tvoid BundleEntryModifierFromBundle::Uninit()\n\t{\n\t\tfor (size_t i = 0; i < this->pReplacers.size(); i++)\n\t\t\tthis->pReplacers[i]->Uninit();\n\t\tif (this->pBundleFile && freeBundleFile)\n\t\t{\n\t\t\tFree_AssetsReader(this->pBundleReader);\n\t\t\tdelete this->pBundleFile;\n\t\t\tfreeBundleFile = false;\n\t\t}\n\t\tthis->pBundleReader = nullptr;\n\t\tthis->pBundleFile = nullptr;\n\t}\n\n\tQWORD BundleEntryModifierFromBundle::Write(QWORD writerPos, IAssetsWriter *pWriter)\n\t{\n\t\tIAssetsWriterToWriterOffset *pWriterWrapper = Create_AssetsWriterToWriterOffset(pWriter, writerPos);\n\t\tpBundleFile->Write(this->pBundleReader, pWriterWrapper, this->pReplacers.data(), this->pReplacers.size(), nullptr, this->typeMeta);\n\t\tQWORD ret = writerPos;\n\t\tpWriterWrapper->Tell(ret);\n\t\tFree_AssetsWriter(pWriterWrapper);\n\t\treturn ret + writerPos;\n\t}\n\tQWORD BundleEntryModifierFromBundle::WriteReplacer(QWORD pos, IAssetsWriter *pWriter)\n\t{\n\t\tuint16_t replacerType = BundleReplacer_BundleEntryModifierFromBundle;\n\t\tpos += pWriter->Write(pos, 2, &replacerType);\n\t\tuint8_t fileVersion = 1;\n\t\tpos += pWriter->Write(pos, 1, &fileVersion);\n\n\t\tuint8_t hasOriginalName = (this->originalEntryName != nullptr) ? 1 : 0;\n\t\tpos += pWriter->Write(pos, 1, &hasOriginalName);\n\t\tif (hasOriginalName)\n\t\t{\n\t\t\tuint16_t originalNameLen = (uint16_t)strlen(this->originalEntryName);\n\t\t\tpos += pWriter->Write(pos, 2, &originalNameLen);\n\t\t\tpos += pWriter->Write(pos, originalNameLen, originalEntryName);\n\t\t}\n\t\t\n\t\tuint8_t hasNewName = (this->newEntryName != nullptr) ? 1 : 0;\n\t\tpos += pWriter->Write(pos, 1, &hasNewName);\n\t\tif (hasNewName)\n\t\t{\n\t\t\tuint16_t newNameLen = (uint16_t)strlen(newEntryName);\n\t\t\tpos += pWriter->Write(pos, 2, &newNameLen);\n\t\t\tpos += pWriter->Write(pos, newNameLen, newEntryName);\n\t\t}\n\n\t\tbool temp = true;\n\t\tpos += pWriter->Write(pos, 1, &temp);\n\n\t\tQWORD ullReplacerCount = this->pReplacers.size();\n\t\tpos += pWriter->Write(pos, 8, &ullReplacerCount);\n\t\tfor (size_t i = 0; i < this->pReplacers.size(); i++)\n\t\t{\n\t\t\tpos = pReplacers[i]->WriteReplacer(pos, pWriter);\n\t\t}\n\t\treturn pos;\n\t}\n\tBundleReplacer **BundleEntryModifierFromBundle::GetReplacers(size_t &count)\n\t{\n\t\tcount = this->pReplacers.size();\n\t\treturn this->pReplacers.data();\n\t}\n\t\n\tbool BundleEntryModifierFromBundle::RequiresEntryReader() { return true; }\n//};\n\n//class BundleEntryModifierByResources : public BundleEntryRenamer\n//{\n\tBundleEntryModifierByResources::BundleEntryModifierByResources(const char* oldName, const char* newName, unsigned int bundleListIndex,\n\t\tstd::vector<ReplacedResourceDesc> _resources,\n\t\tsize_t copyBufferLen)\n\t\t: BundleEntryRenamer(oldName, newName, bundleListIndex, false)\n\t{\n\t\tthis->resources = std::move(_resources);\n\t\tthis->copyBufferLen = copyBufferLen;\n\t}\n\tBundleReplacementType BundleEntryModifierByResources::GetType() { return BundleReplacement_AddOrModify; }\n\tBundleEntryModifierByResources::~BundleEntryModifierByResources()\n\t{}\n\n\tQWORD BundleEntryModifierByResources::GetSize() { return getSize(); }\n\n\tbool BundleEntryModifierByResources::Init(AssetBundleFile* pBundleFile,\n\t\tIAssetsReader* pEntryReader,\n\t\tQWORD entryPos, QWORD entrySize,\n\t\tClassDatabaseFile* typeMeta)\n\t{\n\t\tthis->pEntryReader = pEntryReader;\n\t\tthis->entryPos = entryPos;\n\t\tthis->entrySize = entrySize;\n\t\treturn (pEntryReader != nullptr || !RequiresEntryReader());\n\t}\n\tvoid BundleEntryModifierByResources::Uninit()\n\t{\n\t\tthis->pEntryReader = nullptr;\n\t}\n\tbool BundleEntryModifierByResources::RequiresEntryReader()\n\t{\n\t\tfor (size_t i = 0; i < resources.size(); ++i)\n\t\t{\n\t\t\tif (resources[i].fromOriginalFile)\n\t\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tQWORD BundleEntryModifierByResources::Write(QWORD writerPos, IAssetsWriter* pWriter)\n\t{\n\t\tstd::vector<uint8_t> zeroBuffer;\n\t\tQWORD writerPos_pre = writerPos;\n\t\tfor (size_t i = 0; i < resources.size(); ++i)\n\t\t{\n\t\t\tIAssetsReader* pReader = nullptr;\n\t\t\tQWORD readerPos = 0, readerRange = 0;\n\t\t\tif (resources[i].reader != nullptr)\n\t\t\t{\n\t\t\t\tpReader = resources[i].reader.get();\n\t\t\t\treaderPos = resources[i].inRangeBegin;\n\t\t\t\treaderRange = resources[i].rangeSize;\n\t\t\t}\n\t\t\telse if (resources[i].fromOriginalFile)\n\t\t\t{\n\t\t\t\tpReader = pEntryReader;\n\t\t\t\treaderPos = entryPos + resources[i].inRangeBegin;\n\t\t\t\treaderRange = resources[i].rangeSize;\n\t\t\t\tif (resources[i].inRangeBegin + readerRange > entrySize)\n\t\t\t\t{\n\t\t\t\t\tif (resources[i].inRangeBegin > entrySize)\n\t\t\t\t\t\treaderRange = 0;\n\t\t\t\t\telse\n\t\t\t\t\t\treaderRange = entrySize - resources[i].inRangeBegin;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (readerRange > 0 && pReader != nullptr)\n\t\t\t{\n\t\t\t\tBundleEntryModifier tmpCopier(nullptr, nullptr, (unsigned int)-1, false,\n\t\t\t\t\tstd::shared_ptr<IAssetsReader>(pReader, [](IAssetsReader*) {}),\n\t\t\t\t\treaderRange, readerPos, copyBufferLen);\n\t\t\t\twriterPos = tmpCopier.Write(writerPos, pWriter);\n\t\t\t}\n\t\t\tQWORD remaining = (resources[i].outRangeBegin + resources[i].rangeSize) - (writerPos - writerPos_pre);\n\t\t\tif (resources.size() > (i + 1) && resources[i + 1].outRangeBegin > (writerPos - writerPos_pre))\n\t\t\t{\n\t\t\t\tremaining = resources[i + 1].outRangeBegin - (writerPos - writerPos_pre);\n\t\t\t}\n\t\t\tzeroBuffer.resize((size_t)std::min<QWORD>(copyBufferLen, remaining), 0);\n\t\t\twhile (remaining > 0)\n\t\t\t{\n\t\t\t\tsize_t curCopyDepth = (size_t)std::min<QWORD>(copyBufferLen, remaining);\n\t\t\t\tQWORD written = pWriter->Write(writerPos, curCopyDepth, zeroBuffer.data());\n\t\t\t\tif (written == 0)\n\t\t\t\t\treturn writerPos;\n\t\t\t\twriterPos += written;\n\t\t\t\tassert(written <= remaining);\n\t\t\t\tremaining -= written;\n\t\t\t}\n\t\t}\n\t\treturn writerPos;\n\t}\n\tQWORD BundleEntryModifierByResources::WriteReplacer(QWORD pos, IAssetsWriter* pWriter)\n\t{\n\t\tuint16_t replacerType = BundleReplacer_BundleEntryModifierByResources;\n\t\tpos += pWriter->Write(pos, 2, &replacerType);\n\t\tuint8_t fileVersion = 1;\n\t\tpos += pWriter->Write(pos, 1, &fileVersion);\n\n\t\tuint8_t hasOriginalName = (this->originalEntryName != nullptr) ? 1 : 0;\n\t\tpos += pWriter->Write(pos, 1, &hasOriginalName);\n\t\tif (hasOriginalName)\n\t\t{\n\t\t\tuint16_t originalNameLen = (uint16_t)strlen(this->originalEntryName);\n\t\t\tpos += pWriter->Write(pos, 2, &originalNameLen);\n\t\t\tpos += pWriter->Write(pos, originalNameLen, originalEntryName);\n\t\t}\n\n\t\tuint8_t hasNewName = (this->newEntryName != nullptr) ? 1 : 0;\n\t\tpos += pWriter->Write(pos, 1, &hasNewName);\n\t\tif (hasNewName)\n\t\t{\n\t\t\tuint16_t newNameLen = (uint16_t)strlen(newEntryName);\n\t\t\tpos += pWriter->Write(pos, 2, &newNameLen);\n\t\t\tpos += pWriter->Write(pos, newNameLen, newEntryName);\n\t\t}\n\n\t\tuint8_t temp = hasSerializedData ? 1 : 0;\n\t\tpos += pWriter->Write(pos, 1, &temp);\n\n\t\tuint32_t numResources = (uint32_t)std::min<size_t>(resources.size(), std::numeric_limits<uint32_t>::max());\n\t\tpos += pWriter->Write(pos, 4, &numResources);\n\n\t\tuint32_t i = 0;\n\t\tuint64_t curRangePos = 0;\n\t\tfor (auto resIt = resources.begin(); resIt != resources.end() && i < numResources; ++resIt, ++i)\n\t\t{\n\t\t\tassert(resIt->outRangeBegin == curRangePos);\n\t\t\tpos += pWriter->Write(pos, 8, &resIt->rangeSize);\n\n\t\t\tuint8_t resourceFlags =\n\t\t\t\t((resIt->reader != nullptr) ? (1 << 0) : 0)\n\t\t\t\t| ((resIt->fromOriginalFile) ? (1 << 1) : 0);\n\t\t\tpos += pWriter->Write(pos, 1, &resourceFlags);\n\n\t\t\tif (resIt->reader != nullptr)\n\t\t\t{\n\t\t\t\tBundleEntryModifier tmpCopier(nullptr, nullptr, (unsigned int)-1, false,\n\t\t\t\t\tresIt->reader,\n\t\t\t\t\tresIt->rangeSize, resIt->inRangeBegin, copyBufferLen);\n\t\t\t\tpos = tmpCopier.Write(pos, pWriter);\n\t\t\t}\n\t\t\tif (resIt->fromOriginalFile)\n\t\t\t{\n\t\t\t\tpos += pWriter->Write(pos, 8, &resIt->inRangeBegin);\n\t\t\t}\n\n\t\t\tcurRangePos += resIt->rangeSize;\n\t\t}\n\t\treturn pos;\n\t}\n//};\n\nvoid _cdecl FreeMemoryResource_ReadBundleReplacer(void *pResource)\n{\n\tif (pResource)\n\t\tfree(pResource);\n}\n//On allocation error for the names, it returns a valid replacer with NULL names (or doesn\'t return because the new operator fails)\nstatic BundleReplacer *ReadBundleReplacer(QWORD &pos, IAssetsReader *pReader, std::shared_ptr<IAssetsReader> ref_pReader, bool prefReplacerInMemory)\n{\n\tuint16_t replacerType = 0xFFFF;\n\tpos += pReader->Read(pos, 2, &replacerType);\n\tif (replacerType >= BundleReplacer_MAX)\n\t\treturn NULL;\n\tuint8_t replacerFileVersion = 0;\n\tpos += pReader->Read(pos, 1, &replacerFileVersion);\n\tuint8_t hasOriginalName = 1;\n\tif (replacerFileVersion >= 1)\n\t\tpos += pReader->Read(pos, 1, &hasOriginalName);\n\tuint16_t originalNameLen = 0;\n\tstd::unique_ptr<char[]> originalName;\n\tif (hasOriginalName)\n\t{\n\t\tpos += pReader->Read(pos, 2, &originalNameLen);\n\t\toriginalName.reset(new char[(uint32_t)originalNameLen + 1]);\n\t\tpos += pReader->Read(pos, originalNameLen, originalName.get());\n\t\toriginalName[originalNameLen] = 0;\n\t}\n\tstd::unique_ptr<char[]> newName;\n\tuint16_t newNameLen = 0;\n\tbool hasSerializedData = false;\n\tif (replacerType != BundleReplacer_BundleEntryRemover)\n\t{\n\t\tuint8_t hasNewName = 1;\n\t\tif (replacerFileVersion >= 1)\n\t\t\tpos += pReader->Read(pos, 1, &hasNewName);\n\t\tif (hasNewName)\n\t\t{\n\t\t\tpos += pReader->Read(pos, 2, &newNameLen);\n\t\t\tnewName.reset(new char[(uint32_t)newNameLen + 1]);\n\t\t\tpos += pReader->Read(pos, newNameLen, newName.get());\n\t\t\tnewName[newNameLen] = 0;\n\t\t}\n\n\t\tpos += pReader->Read(pos, 1, &hasSerializedData);\n\t}\n\n\tswitch (replacerType)\n\t{\n\tcase BundleReplacer_BundleEntryRemover:\n\t\t{\n\t\t\tif (replacerFileVersion > 1)\n\t\t\t\treturn NULL;\n\t\t\tBundleReplacer *ret = new BundleEntryRemover(originalName.get(), (unsigned int)-1);\n\t\t\treturn ret;\n\t\t}\n\tcase BundleReplacer_BundleEntryRenamer:\n\t\t{\n\t\t\tif (replacerFileVersion > 1)\n\t\t\t\treturn NULL;\n\t\t\tBundleReplacer *ret = new BundleEntryRenamer(originalName.get(), newName.get(), (unsigned int)-1, hasSerializedData);\n\t\t\treturn ret;\n\t\t}\n\tcase BundleReplacer_BundleEntryModifier:\n\tcase BundleReplacer_BundleEntryModifierFromMem:\n\t\t{\n\t\t\tif (replacerFileVersion > 1)\n\t\t\t\treturn NULL;\n\t\t\tQWORD size = 0;\n\t\t\tpos += pReader->Read(pos, 8, &size);\n\t\t\tBundleReplacer *ret = NULL;\n\t\t\tif (prefReplacerInMemory)\n\t\t\t{\n\t\t\t\tvoid *pMem = malloc(size);\n\t\t\t\tif (pMem)\n\t\t\t\t{\n\t\t\t\t\tQWORD actualRead = pReader->Read(pos, size, pMem);\n\t\t\t\t\tmemset(&((uint8_t*)pMem)[actualRead], 0, size - actualRead);\n\t\t\t\t\tret = new BundleEntryModifierFromMem(originalName.get(), newName.get(), (unsigned int)-1, hasSerializedData, pMem, size, \n\t\t\t\t\t\tFreeMemoryResource_ReadBundleReplacer);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!ret)\n\t\t\t{\n\t\t\t\tstruct {\n\t\t\t\t\tvoid operator()(IAssetsReader*){}\n\t\t\t\t} nullDeleter;\n\t\t\t\tstd::shared_ptr<IAssetsReader> inner_pReader = ref_pReader;\n\t\t\t\tif (inner_pReader == nullptr)\n\t\t\t\t\tinner_pReader = std::shared_ptr<IAssetsReader>(pReader, nullDeleter);\n\t\t\t\telse\n\t\t\t\t\tinner_pReader = std::shared_ptr<IAssetsReader>(inner_pReader, pReader);\n\t\t\t\tret = new BundleEntryModifier(originalName.get(), newName.get(), (unsigned int)-1, hasSerializedData, inner_pReader, size, pos, 0);\n\t\t\t}\n\t\t\tpos += size;\n\t\t\treturn ret;\n\t\t}\n\tcase BundleReplacer_BundleEntryModifierFromAssets:\n\t\t{\n\t\t\tif (replacerFileVersion > 1)\n\t\t\t\treturn NULL;\n\t\t\tQWORD ullReplacerCount = 0;\n\t\t\tpos += pReader->Read(pos, 8, &ullReplacerCount);\n\t\t\tsize_t replacerCount = (size_t)ullReplacerCount;\n\t\t\tstd::vector<std::shared_ptr<AssetsReplacer>> pReplacers(replacerCount);\n\t\t\tfor (size_t i = 0; i < replacerCount; i++)\n\t\t\t{\n\t\t\t\tif (ref_pReader)\n\t\t\t\t\tpReplacers[i].reset(ReadAssetsReplacer(pos, ref_pReader));\n\t\t\t\telse\n\t\t\t\t\tpReplacers[i].reset(ReadAssetsReplacer(pos, pReader));\n\t\t\t}\n\t\t\tBundleReplacer *ret = \n\t\t\t\tnew BundleEntryModifierFromAssets(originalName.get(), newName.get(), (unsigned int)-1, NULL, std::move(pReplacers), (uint32_t)-1);\n\t\t\treturn ret;\n\t\t}\n\tcase BundleReplacer_BundleEntryModifierFromBundle:\n\t\t{\n\t\t\tif (replacerFileVersion > 1)\n\t\t\t\treturn NULL;\n\t\t\tQWORD ullReplacerCount = 0;\n\t\t\tpos += pReader->Read(pos, 8, &ullReplacerCount);\n\t\t\tsize_t replacerCount = (size_t)ullReplacerCount;\n\t\t\tstd::vector<std::unique_ptr<BundleReplacer>> pReplacers(replacerCount);\n\t\t\tfor (size_t i = 0; i < replacerCount; i++)\n\t\t\t{\n\t\t\t\tif (ref_pReader)\n\t\t\t\t\tpReplacers[i].reset(ReadBundleReplacer(pos, ref_pReader));\n\t\t\t\telse\n\t\t\t\t\tpReplacers[i].reset(ReadBundleReplacer(pos, pReader));\n\t\t\t}\n\t\t\tBundleReplacer *ret = \n\t\t\t\tnew BundleEntryModifierFromBundle(originalName.get(), newName.get(), (unsigned int)-1, std::move(pReplacers));\n\t\t\treturn ret;\n\t\t}\n\tcase BundleReplacer_BundleEntryModifierByResources:\n\t\t{\n\t\t\tif (replacerFileVersion > 1)\n\t\t\t\treturn NULL;\n\t\t\tuint32_t resourceCount = 0;\n\t\t\tpos += pReader->Read(pos, 4, &resourceCount);\n\t\t\tstd::vector<ReplacedResourceDesc> resources;\n\t\t\tresources.resize(resourceCount);\n\t\t\tuint64_t curPos = 0;\n\t\t\tfor (uint32_t i = 0; i < resourceCount; ++i)\n\t\t\t{\n\t\t\t\tresources[i].outRangeBegin = curPos;\n\t\t\t\tpos += pReader->Read(pos, 8, &resources[i].rangeSize);\n\t\t\t\tresources[i].fromOriginalFile = false;\n\t\t\t\tuint8_t resourceFlags = 0;\n\t\t\t\tpos += pReader->Read(pos, 1, &resourceFlags);\n\t\t\t\tif (resourceFlags & (1 << 0))\n\t\t\t\t{\n\t\t\t\t\t//Resource is defined by following data.\n\t\t\t\t\tif (prefReplacerInMemory)\n\t\t\t\t\t{\n\t\t\t\t\t\tvoid* pMem = malloc(resources[i].rangeSize);\n\t\t\t\t\t\tif (pMem)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tQWORD actualRead = pReader->Read(pos, resources[i].rangeSize, pMem);\n\t\t\t\t\t\t\tmemset(&((uint8_t*)pMem)[actualRead], 0, resources[i].rangeSize - actualRead);\n\t\t\t\t\t\t\tresources[i].reader = std::shared_ptr<IAssetsReader>(\n\t\t\t\t\t\t\t\tCreate_AssetsReaderFromMemory(pMem, resources[i].rangeSize, false, [](void* buf) {if (buf)free(buf); }));\n\t\t\t\t\t\t\tresources[i].inRangeBegin = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!resources[i].reader)\n\t\t\t\t\t{\n\t\t\t\t\t\tstruct {\n\t\t\t\t\t\t\tvoid operator()(IAssetsReader*) {}\n\t\t\t\t\t\t} nullDeleter;\n\t\t\t\t\t\tstd::shared_ptr<IAssetsReader> inner_pReader = ref_pReader;\n\t\t\t\t\t\tif (inner_pReader == nullptr)\n\t\t\t\t\t\t\tresources[i].reader = std::shared_ptr<IAssetsReader>(pReader, nullDeleter);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tresources[i].reader = std::shared_ptr<IAssetsReader>(inner_pReader, pReader);\n\t\t\t\t\t\tresources[i].inRangeBegin = pos;\n\t\t\t\t\t}\n\t\t\t\t\tpos += resources[i].rangeSize;\n\t\t\t\t}\n\t\t\t\tif (resourceFlags & (1 << 1))\n\t\t\t\t{\n\t\t\t\t\t//Resource starts at an offset of its reader\n\t\t\t\t\t// (only used if based on some resource in the original file).\n\t\t\t\t\tuint64_t inRangeBegin = 0;\n\t\t\t\t\tpos += pReader->Read(pos, 8, &inRangeBegin);\n\t\t\t\t\tif (resources[i].reader == nullptr)\n\t\t\t\t\t{\n\t\t\t\t\t\tresources[i].inRangeBegin = inRangeBegin;\n\t\t\t\t\t\tresources[i].fromOriginalFile = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcurPos += resources[i].rangeSize;\n\t\t\t}\n\t\t\tBundleReplacer *ret = \n\t\t\t\tnew BundleEntryModifierByResources(originalName.get(), newName.get(), (unsigned int)-1, std::move(resources), 0);\n\t\t\treturn ret;\n\t\t}\n\t}\n\treturn NULL;\n}\nASSETSTOOLS_API BundleReplacer *ReadBundleReplacer(QWORD &pos, IAssetsReader *pReader, bool prefReplacerInMemory)\n{\n\treturn ReadBundleReplacer(pos, pReader, nullptr, prefReplacerInMemory);\n}\nASSETSTOOLS_API BundleReplacer *ReadBundleReplacer(QWORD &pos, std::shared_ptr<IAssetsReader> pReader, bool prefReplacerInMemory)\n{\n\tIAssetsReader *_pReader = pReader.get();\n\treturn ReadBundleReplacer(pos, _pReader, std::move(pReader), prefReplacerInMemory);\n}\nASSETSTOOLS_API BundleReplacer *MakeBundleEntryRemover(const char *name, \n\tunsigned int bundleListIndex)\n{\n\treturn new BundleEntryRemover(name, bundleListIndex);\n}\nASSETSTOOLS_API BundleReplacer *MakeBundleEntryRenamer(const char *oldName, const char *newName, bool hasSerializedData, \n\tunsigned int bundleListIndex)\n{\n\treturn new BundleEntryRenamer(oldName, newName, bundleListIndex, hasSerializedData);\n}\nASSETSTOOLS_API BundleReplacer *MakeBundleEntryModifier(const char *oldName, const char *newName, bool hasSerializedData, \n\tIAssetsReader *pReader, cbFreeReaderResource freeReaderCallback, QWORD size, QWORD readerPos, \n\tsize_t copyBufferLen,\n\tunsigned int bundleListIndex)\n{\n\tstruct {\n\t\tvoid operator()(IAssetsReader*){}\n\t} nullDeleter;\n\tstd::shared_ptr<IAssetsReader> pReader_shared;\n\tif (freeReaderCallback == nullptr)\n\t\tpReader_shared = std::shared_ptr<IAssetsReader>(pReader, nullDeleter);\n\telse\n\t\tpReader_shared = std::shared_ptr<IAssetsReader>(pReader, freeReaderCallback);\n\treturn new BundleEntryModifier(oldName, newName, bundleListIndex, hasSerializedData, std::move(pReader_shared), size, readerPos, copyBufferLen);\n}\nASSETSTOOLS_API BundleReplacer *MakeBundleEntryModifier(const char *oldName, const char *newName, bool hasSerializedData, \n\tstd::shared_ptr<IAssetsReader> pReader, QWORD size, QWORD readerPos, \n\tsize_t copyBufferLen,\n\tunsigned int bundleListIndex)\n{\n\treturn new BundleEntryModifier(oldName, newName, bundleListIndex, hasSerializedData, std::move(pReader), size, readerPos, copyBufferLen);\n}\nASSETSTOOLS_API BundleReplacer *MakeBundleEntryModifierFromMem(const char *oldName, const char *newName, bool hasSerializedData, \n\tvoid *pMem, size_t size,\n\tunsigned int bundleListIndex, cbFreeMemoryResource freeResourceCallback)\n{\n\treturn new BundleEntryModifierFromMem(oldName, newName, bundleListIndex, hasSerializedData,\n\t\tpMem, size, freeResourceCallback);\n}\nASSETSTOOLS_API BundleReplacer *MakeBundleEntryModifierFromAssets(const char *oldName, const char *newName, \n\tAssetsFile *pAssetsFile, AssetsReplacer **pReplacers, size_t replacerCount, uint32_t fileId,\n\tunsigned int bundleListIndex)\n{\n\treturn new BundleEntryModifierFromAssets(oldName, newName, bundleListIndex,\n\t\tpAssetsFile, pReplacers, replacerCount, fileId);\n}\nASSETSTOOLS_API std::unique_ptr<BundleReplacer> MakeBundleEntryModifierFromAssets(const char *oldName, const char *newName, \n\tstd::shared_ptr<ClassDatabaseFile> typeMeta, std::vector<std::shared_ptr<AssetsReplacer>> pReplacers, uint32_t fileId,\n\tunsigned int bundleListIndex)\n{\n\treturn std::unique_ptr<BundleReplacer>(new BundleEntryModifierFromAssets(oldName, newName, bundleListIndex,\n\t\tstd::move(typeMeta), std::move(pReplacers), fileId));\n}\nASSETSTOOLS_API BundleReplacer *MakeBundleEntryModifierFromBundle(const char *oldName, const char *newName, \n\tBundleReplacer **pReplacers, size_t replacerCount, \n\tunsigned int bundleListIndex)\n{\n\treturn new BundleEntryModifierFromBundle(oldName, newName, bundleListIndex, pReplacers, replacerCount);\n}\nASSETSTOOLS_API std::unique_ptr<BundleReplacer> MakeBundleEntryModifierFromBundle(const char *oldName, const char *newName, \n\tstd::vector<std::unique_ptr<BundleReplacer>> pReplacers, \n\tunsigned int bundleListIndex)\n{\n\treturn std::unique_ptr<BundleReplacer>(\n\t\tnew BundleEntryModifierFromBundle(oldName, newName, bundleListIndex, std::move(pReplacers)));\n}\nASSETSTOOLS_API std::unique_ptr<BundleReplacer> MakeBundleEntryModifierByResources(const char* oldName, const char* newName,\n\tstd::vector<ReplacedResourceDesc> resources, size_t copyBufferLen,\n\tunsigned int bundleListIndex)\n{\n\treturn std::unique_ptr<BundleReplacer>(\n\t\tnew BundleEntryModifierByResources(oldName, newName, bundleListIndex, std::move(resources), copyBufferLen));\n}\nASSETSTOOLS_API void FreeBundleReplacer(BundleReplacer *pReplacer)\n{\n\tdelete pReplacer;\n}\n\n//Tries to create a reader from a BundleReplacer.\n//Works only for replacers created through MakeBundleEntryModifier or MakeBundleEntryModifierFromMem.\n//For other kinds of replacers, nullptr will be returned.\n//-> For MakeBundleEntryModifier, the internal reader will be reused.\n//-> For MakeBundleEntryModifierFromMem, the internal buffer will be reused and the returned shared_ptr will also keep a BundleReplacer reference.\nASSETSTOOLS_API std::shared_ptr<IAssetsReader> MakeReaderFromBundleEntryModifier(std::shared_ptr<BundleReplacer> pReplacer)\n{\n\tif (BundleEntryModifierFromMem *pEntryModifier = dynamic_cast<BundleEntryModifierFromMem*>(pReplacer.get()))\n\t{\n\t\tstruct {\n\t\t\tstd::shared_ptr<BundleReplacer> pReplacer;\n\t\t\tvoid operator()(IAssetsReader* pReader) { Free_AssetsReader(pReader); pReplacer.reset(); }\n\t\t} deleter;\n\t\tdeleter.pReplacer = pReplacer;\n\t\treturn std::shared_ptr<IAssetsReader>(\n\t\t\tCreate_AssetsReaderFromMemory(pEntryModifier->pMem, pEntryModifier->size, false),\n\t\t\tdeleter);\n\t}\n\telse if (BundleEntryModifier *pEntryModifier = dynamic_cast<BundleEntryModifier*>(pReplacer.get()))\n\t{\n\t\tstruct {\n\t\t\tstd::shared_ptr<IAssetsReader> pSourceReader;\n\t\t\tvoid operator()(IAssetsReader* pReader) { Free_AssetsReader(pReader); pSourceReader.reset(); }\n\t\t} deleter;\n\t\tdeleter.pSourceReader = pEntryModifier->pReader;\n\t\treturn std::shared_ptr<IAssetsReader>(\n\t\t\tCreate_AssetsReaderFromReaderRange(pEntryModifier->pReader.get(), pEntryModifier->readerPos, pEntryModifier->size, true),\n\t\t\tdeleter);\n\t}\n\treturn nullptr;\n}\n\n'