b'{-# OPTIONS_GHC -fwarn-incomplete-patterns #-}\nmodule Database.Beam.Query\n    ( -- * Query type\n      module Database.Beam.Query.Types\n\n    -- ** Query expression contexts\n    -- | A context is a type-level value that signifies where an expression can\n    --   be used. For example, \'QExpr\' corresponds to \'QGenExpr\'s that result in\n    --   values. In reality, \'QExpr\' is really \'QGenExpr\' parameterized over the\n    --   \'QValueContext\'. Similarly, \'QAgg\' represents expressions that contain\n    --   aggregates, but it is just \'QGenExpr\' parameterized over\n    --   \'QAggregateContext\'\n    , QAggregateContext, QGroupingContext, QValueContext\n    , QWindowingContext, QWindowFrameContext\n\n    , QGenExprTable, QExprTable\n\n    , QAssignment, QField, QFieldAssignment\n\n    , QBaseScope\n\n\n    , module Database.Beam.Query.Combinators\n    , module Database.Beam.Query.Extensions\n\n    , module Database.Beam.Query.Relationships\n\n    , module Database.Beam.Query.CTE\n\n    , module Database.Beam.Query.Extract\n\n    -- * Operators\n    , module Database.Beam.Query.Operator\n\n    -- ** ANSI SQL Booleans\n    , isTrue_, isNotTrue_\n    , isFalse_, isNotFalse_\n    , isUnknown_, isNotUnknown_\n    , unknownAs_, sqlBool_\n    , possiblyNullBool_\n    , fromPossiblyNullBool_\n\n    -- ** Unquantified comparison operators\n    , HasSqlEqualityCheck(..), HasSqlQuantifiedEqualityCheck(..)\n    , HasTableEquality\n    , SqlEq(..), SqlOrd(..), SqlIn(..)\n    , HasSqlInTable(..)\n    , inQuery_\n\n    -- ** Quantified Comparison Operators #quantified-comparison-operator#\n    , SqlEqQuantified(..), SqlOrdQuantified(..)\n    , QQuantified\n    , anyOf_, allOf_, anyIn_, allIn_\n    , between_\n\n    , module Database.Beam.Query.Aggregate\n\n    , module Database.Beam.Query.CustomSQL\n\n    , module Database.Beam.Query.DataTypes\n\n    -- * SQL Command construction and execution\n    -- ** @SELECT@\n    , SqlSelect(..)\n    , select, selectWith, lookup_\n    , runSelectReturningList\n    , runSelectReturningOne\n    , runSelectReturningFirst\n    , dumpSqlSelect\n\n    -- ** @INSERT@\n    , SqlInsert(..)\n    , insert, insertOnly\n    , runInsert\n\n    , SqlInsertValues(..)\n    , insertExpressions\n    , insertValues\n    , insertFrom\n    , insertData\n\n    -- ** @UPDATE@\n    , SqlUpdate(..)\n    , update, save\n    , update\', save\'\n    , updateTable, updateTable\'\n    , set, setFieldsTo\n    , toNewValue, toOldValue, toUpdatedValue\n    , toUpdatedValueMaybe\n    , updateRow, updateTableRow\n    , updateRow\', updateTableRow\'\n    , runUpdate\n\n    -- ** @DELETE@\n    , SqlDelete(..)\n    , delete\n    , runDelete ) where\n\nimport Prelude hiding (lookup)\n\nimport Database.Beam.Query.Aggregate\nimport Database.Beam.Query.Combinators\nimport Database.Beam.Query.CTE ( With, ReusableQ, selecting, reuse )\nimport qualified Database.Beam.Query.CTE as CTE\nimport Database.Beam.Query.CustomSQL\nimport Database.Beam.Query.DataTypes\nimport Database.Beam.Query.Extensions\nimport Database.Beam.Query.Extract\nimport Database.Beam.Query.Internal\nimport Database.Beam.Query.Operator\nimport Database.Beam.Query.Ord\nimport Database.Beam.Query.Relationships\nimport Database.Beam.Query.Types (QGenExpr) -- hide QGenExpr constructor\nimport Database.Beam.Query.Types hiding (QGenExpr)\n\nimport Database.Beam.Backend.SQL\nimport Database.Beam.Backend.SQL.Builder\nimport Database.Beam.Schema.Tables\n\nimport Control.Monad.Identity\nimport Control.Monad.Writer\nimport Control.Monad.State.Strict\n\nimport Data.Kind (Type)\nimport Data.Functor.Const (Const(..))\nimport Data.Text (Text)\nimport Data.Proxy\n\nimport Lens.Micro ((^.))\n\n-- * Query\n\ndata QBaseScope\n\n-- | A version of the table where each field is a \'QGenExpr\'\ntype QGenExprTable ctxt be s tbl = tbl (QGenExpr ctxt be s)\n\ntype QExprTable be s tbl = QGenExprTable QValueContext be s tbl\n\n-- * SELECT\n\n-- | Represents a select statement in the given backend, returning\n-- rows of type \'a\'.\nnewtype SqlSelect be a\n    = SqlSelect (BeamSqlBackendSelectSyntax be)\n\n-- | Build a \'SqlSelect\' for the given \'Q\'.\nselect :: forall be db res\n        . ( BeamSqlBackend be, HasQBuilder be, Projectible be res )\n       => Q be db QBaseScope res -> SqlSelect be (QExprToIdentity res)\nselect q =\n  SqlSelect (buildSqlQuery "t" q)\n\n-- | Create a \'SqlSelect\' for a query which may have common table\n-- expressions. See the documentation of \'With\' for more details.\nselectWith :: forall be db res\n            . ( BeamSqlBackend be, BeamSql99CommonTableExpressionBackend be\n              , HasQBuilder be, Projectible be res )\n           => With be db (Q be db QBaseScope res) -> SqlSelect be (QExprToIdentity res)\nselectWith (CTE.With mkQ) =\n    let (q, (recursiveness, ctes)) = evalState (runWriterT mkQ) 0\n    in case recursiveness of\n         CTE.Nonrecursive -> SqlSelect (withSyntax ctes\n                                                   (buildSqlQuery "t" q))\n         CTE.Recursive    -> SqlSelect (withRecursiveSyntax ctes\n                                                            (buildSqlQuery "t" q))\n\n-- | Convenience function to generate a \'SqlSelect\' that looks up a table row\n--   given a primary key.\nlookup_ :: ( Database be db, Table table\n\n           , BeamSqlBackend be, HasQBuilder be\n           , SqlValableTable be (PrimaryKey table)\n           , HasTableEquality be (PrimaryKey table)\n           )\n        => DatabaseEntity be db (TableEntity table)\n        -> PrimaryKey table Identity\n        -> SqlSelect be (table Identity)\nlookup_ tbl tblKey =\n  select $\n  filter_ (\\t -> pk t ==. val_ tblKey) $\n  all_ tbl\n\n-- | Run a \'SqlSelect\' in a \'MonadBeam\' and get the results as a list\nrunSelectReturningList ::\n  (MonadBeam be m, BeamSqlBackend be, FromBackendRow be a) =>\n  SqlSelect be a -> m [ a ]\nrunSelectReturningList (SqlSelect s) =\n  runReturningList (selectCmd s)\n\n-- | Run a \'SqlSelect\' in a \'MonadBeam\' and get the unique result, if there is\n--   one. Both no results as well as more than one result cause this to return\n--   \'Nothing\'.\nrunSelectReturningOne ::\n  (MonadBeam be m, BeamSqlBackend be, FromBackendRow be a) =>\n  SqlSelect be a -> m (Maybe a)\nrunSelectReturningOne (SqlSelect s) =\n  runReturningOne (selectCmd s)\n\n-- | Run a \'SqlSelect\' in a \'MonadBeam\' and get the first result, if there is\n--   one.\n--   This is not guaranteed to automatically limit the query to one result.\nrunSelectReturningFirst ::\n  (MonadBeam be m, BeamSqlBackend be, FromBackendRow be a) =>\n  SqlSelect be a -> m (Maybe a)\nrunSelectReturningFirst (SqlSelect s) =\n  runReturningFirst (selectCmd s)\n\n-- | Use a special debug syntax to print out an ANSI Standard @SELECT@ statement\n--   that may be generated for a given \'Q\'.\ndumpSqlSelect :: Projectible (MockSqlBackend SqlSyntaxBuilder) res\n              => Q (MockSqlBackend SqlSyntaxBuilder) db QBaseScope res -> IO ()\ndumpSqlSelect q =\n    let SqlSelect s = select q\n    in putStrLn (renderSql s)\n\n-- * INSERT\n\n-- | Represents a SQL @INSERT@ command that has not yet been run\ndata SqlInsert be (table :: (Type -> Type) -> Type)\n  = SqlInsert !(TableSettings table) !(BeamSqlBackendInsertSyntax be)\n  | SqlInsertNoRows\n\n-- | Generate a \'SqlInsert\' over only certain fields of a table\ninsertOnly :: ( BeamSqlBackend be, ProjectibleWithPredicate AnyType () Text (QExprToField r) )\n           => DatabaseEntity be db (TableEntity table)\n              -- ^ Table to insert into\n           -> (table (QField s) -> QExprToField r)\n           -> SqlInsertValues be r\n              -- ^ Values to insert. See \'insertValues\', \'insertExpressions\', \'insertData\', and \'insertFrom\' for possibilities.\n           -> SqlInsert be table\ninsertOnly _ _ SqlInsertValuesEmpty = SqlInsertNoRows\ninsertOnly (DatabaseEntity dt@(DatabaseTable {})) mkProj (SqlInsertValues vs) =\n    SqlInsert (dbTableSettings dt) (insertStmt (tableNameFromEntity dt) proj vs)\n  where\n    tblFields = changeBeamRep (\\(Columnar\' fd) -> Columnar\' (QField False (dbTableCurrentName dt) (fd ^. fieldName)))\n                              (dbTableSettings dt)\n    proj = execWriter (project\' (Proxy @AnyType) (Proxy @((), Text))\n                                (\\_ _ f -> tell [f] >> pure f)\n                                (mkProj tblFields))\n\n-- | Generate a \'SqlInsert\' given a table and a source of values.\ninsert :: ( BeamSqlBackend be, ProjectibleWithPredicate AnyType () Text (table (QField s)) )\n       => DatabaseEntity be db (TableEntity table)\n          -- ^ Table to insert into\n       -> SqlInsertValues be (table (QExpr be s))\n          -- ^ Values to insert. See \'insertValues\', \'insertExpressions\', and \'insertFrom\' for possibilities.\n       -> SqlInsert be table\ninsert tbl values = insertOnly tbl id values\n\n-- | Run a \'SqlInsert\' in a \'MonadBeam\'\nrunInsert :: (BeamSqlBackend be, MonadBeam be m)\n          => SqlInsert be table -> m ()\nrunInsert SqlInsertNoRows = pure ()\nrunInsert (SqlInsert _ i) = runNoReturn (insertCmd i)\n\n-- | Represents a source of values that can be inserted into a table shaped like\n--   \'tbl\'.\ndata SqlInsertValues be proj\n    = SqlInsertValues (BeamSqlBackendInsertValuesSyntax be)\n    | SqlInsertValuesEmpty\n\n-- | Build a \'SqlInsertValues\' from series of expressions in tables\ninsertExpressions :: forall be table s\n                   . ( BeamSqlBackend be, Beamable table )\n                  => (forall s\'. [ table (QExpr be s\') ])\n                  -> SqlInsertValues be (table (QExpr be s))\ninsertExpressions tbls =\n  case sqlExprs of\n    [] -> SqlInsertValuesEmpty\n    _  -> SqlInsertValues (insertSqlExpressions sqlExprs)\n    where\n      sqlExprs = map mkSqlExprs tbls\n\n      mkSqlExprs :: forall s\'. table (QExpr be s\') -> [ BeamSqlBackendExpressionSyntax be ]\n      mkSqlExprs = allBeamValues (\\(Columnar\' (QExpr x)) -> x "t")\n\n-- | Build a \'SqlInsertValues\' from concrete table values\ninsertValues :: forall be table s\n              . ( BeamSqlBackend be, Beamable table\n                , FieldsFulfillConstraint (BeamSqlBackendCanSerialize be) table )\n             => [ table Identity ]\n             -> SqlInsertValues be (table (QExpr be s))\ninsertValues x = insertExpressions (map val_ x :: forall s\'. [table (QExpr be s\') ])\n\n-- | Build a \'SqlInsertValues\' from arbitrarily shaped data containing expressions\ninsertData :: forall be r\n            . ( Projectible be r, BeamSqlBackend be )\n           => [ r ] -> SqlInsertValues be r\ninsertData rows =\n  case rows of\n    [] -> SqlInsertValuesEmpty\n    _  -> SqlInsertValues (insertSqlExpressions (map (\\row -> project (Proxy @be) row "t") rows))\n\n-- | Build a \'SqlInsertValues\' from a \'SqlSelect\' that returns the same table\ninsertFrom :: ( BeamSqlBackend be, HasQBuilder be\n              , Projectible be r )\n           => Q be db QBaseScope r\n           -> SqlInsertValues be r\ninsertFrom s = SqlInsertValues (insertFromSql (buildSqlQuery "t" s))\n\n-- * UPDATE\n\n-- | Represents a SQL @UPDATE@ statement for the given @table@.\ndata SqlUpdate be (table :: (Type -> Type) -> Type)\n  = SqlUpdate !(TableSettings table) !(BeamSqlBackendUpdateSyntax be)\n  | SqlIdentityUpdate -- An update with no assignments\n\n-- | Build a \'SqlUpdate\' given a table, a list of assignments, and a way to\n--   build a @WHERE@ clause.\n--\n--   An internal implementation for \'update\' and \'update\'\' functions.\n--   Allows to choose boolean type in the @WHERE@ clause.\nupdateImpl :: forall bool table db be\n            . ( BeamSqlBackend be, Beamable table )\n           => DatabaseEntity be db (TableEntity table)\n              -- ^ The table to insert into\n           -> (forall s. table (QField s) -> QAssignment be s)\n              -- ^ A sequence of assignments to make.\n           -> (forall s. table (QExpr be s) -> QExpr be s bool)\n              -- ^ Build a @WHERE@ clause given a table containing expressions\n           -> SqlUpdate be table\nupdateImpl (DatabaseEntity dt@(DatabaseTable {})) mkAssignments mkWhere =\n  case assignments of\n    [] -> SqlIdentityUpdate\n    _  -> SqlUpdate (dbTableSettings dt)\n                    (updateStmt (tableNameFromEntity dt)\n                       assignments (Just (where_ "t")))\n  where\n    QAssignment assignments = mkAssignments tblFields\n    QExpr where_ = mkWhere tblFieldExprs\n\n    tblFields = changeBeamRep (\\(Columnar\' fd) -> Columnar\' (QField False (dbTableCurrentName dt) (fd ^. fieldName)))\n                              (dbTableSettings dt)\n    tblFieldExprs = changeBeamRep (\\(Columnar\' (QField _ _ nm)) -> Columnar\' (QExpr (pure (fieldE (unqualifiedField nm))))) tblFields\n\n-- | Build a \'SqlUpdate\' given a table, a list of assignments, and a way to\n--   build a @WHERE@ clause.\n--\n--   Use \'update\'\' for comparisons with \'SqlBool\'.\n--\n--   See the \'(<-.)\' operator for ways to build assignments. The argument to the\n--   second argument is a the table parameterized over \'QField\', which\n--   represents the left hand side of assignments. Sometimes, you\'d like to also\n--   get the current value of a particular column. You can use the \'current_\'\n--   function to convert a \'QField\' to a \'QExpr\'.\nupdate :: ( BeamSqlBackend be, Beamable table )\n       => DatabaseEntity be db (TableEntity table)\n          -- ^ The table to insert into\n       -> (forall s. table (QField s) -> QAssignment be s)\n          -- ^ A sequence of assignments to make.\n       -> (forall s. table (QExpr be s) -> QExpr be s Bool)\n          -- ^ Build a @WHERE@ clause given a table containing expressions\n       -> SqlUpdate be table\nupdate = updateImpl @Bool\n\n-- | Build a \'SqlUpdate\' given a table, a list of assignments, and a way to\n--   build a @WHERE@ clause.\n--\n--   Uses a \'SqlBool\' comparison. Use \'update\' for comparisons with \'Bool\'.\n--\n--   See the \'(<-.)\' operator for ways to build assignments. The argument to the\n--   second argument is a the table parameterized over \'QField\', which\n--   represents the left hand side of assignments. Sometimes, you\'d like to also\n--   get the current value of a particular column. You can use the \'current_\'\n--   function to convert a \'QField\' to a \'QExpr\'.\nupdate\' :: ( BeamSqlBackend be, Beamable table )\n        => DatabaseEntity be db (TableEntity table)\n           -- ^ The table to insert into\n        -> (forall s. table (QField s) -> QAssignment be s)\n           -- ^ A sequence of assignments to make.\n        -> (forall s. table (QExpr be s) -> QExpr be s SqlBool)\n           -- ^ Build a @WHERE@ clause given a table containing expressions\n        -> SqlUpdate be table\nupdate\' = updateImpl @SqlBool\n\n-- | A specialization of \'update\' that matches the given (already existing) row.\n--\n--   Use \'updateRow\'\' for an internal \'SqlBool\' comparison.\nupdateRow :: ( BeamSqlBackend be, Table table\n             , HasTableEquality be (PrimaryKey table)\n             , SqlValableTable be (PrimaryKey table) )\n          => DatabaseEntity be db (TableEntity table)\n             -- ^ The table to insert into\n          -> table Identity\n             -- ^ The row to update\n          -> (forall s. table (QField s) -> QAssignment be s)\n             -- ^ A sequence of assignments to make.\n          -> SqlUpdate be table\nupdateRow tbl row assignments =\n  update tbl assignments (references_ (val_ (pk row)))\n\n-- | A specialization of \'update\'\' that matches the given (already existing) row.\n--\n--   Use \'updateRow\' for an internal \'Bool\' comparison.\nupdateRow\' :: ( BeamSqlBackend be, Table table\n              , HasTableEquality be (PrimaryKey table)\n              , SqlValableTable be (PrimaryKey table) )\n           => DatabaseEntity be db (TableEntity table)\n              -- ^ The table to insert into\n           -> table Identity\n              -- ^ The row to update\n           -> (forall s. table (QField s) -> QAssignment be s)\n              -- ^ A sequence of assignments to make.\n           -> SqlUpdate be table\nupdateRow\' tbl row assignments =\n  update\' tbl assignments (references_\' (val_ (pk row)))\n\n-- | A specialization of \'update\' that is more convenient for normal tables.\n--\n--   An internal implementation of \'updateTable\' and \'updateTable\'\' functions.\n--   Allows choosing between \'Bool\' and \'SqlBool\'.\nupdateTableImpl :: forall bool table db be\n                 . ( BeamSqlBackend be, Beamable table )\n                => DatabaseEntity be db (TableEntity table)\n                   -- ^ The table to update\n                -> table (QFieldAssignment be table)\n                   -- ^ Updates to be made (use \'set\' to construct an empty field)\n                -> (forall s. table (QExpr be s) -> QExpr be s bool)\n                -> SqlUpdate be table\nupdateTableImpl tblEntity assignments mkWhere =\n  let mkAssignments :: forall s. table (QField s) -> QAssignment be s\n      mkAssignments tblFields =\n        let tblExprs = changeBeamRep (\\(Columnar\' fd) -> Columnar\' (current_ fd)) tblFields\n        in execWriter $\n           zipBeamFieldsM\n             (\\(Columnar\' field :: Columnar\' (QField s) a)\n               c@(Columnar\' (QFieldAssignment mkAssignment)) ->\n                case mkAssignment tblExprs of\n                  Nothing -> pure c\n                  Just newValue -> do\n                    tell (field <-. newValue)\n                    pure c)\n             tblFields assignments\n\n  in updateImpl tblEntity mkAssignments mkWhere\n\n-- | A specialization of \'update\' that is more convenient for normal tables.\n--\n--   Use \'updateTable\'\' for comparisons with \'SqlBool\'.\nupdateTable :: forall table db be\n             . ( BeamSqlBackend be, Beamable table )\n            => DatabaseEntity be db (TableEntity table)\n               -- ^ The table to update\n            -> table (QFieldAssignment be table)\n               -- ^ Updates to be made (use \'set\' to construct an empty field)\n            -> (forall s. table (QExpr be s) -> QExpr be s Bool)\n            -> SqlUpdate be table\nupdateTable = updateTableImpl @Bool\n\n-- | A specialization of \'update\'\' that is more convenient for normal tables.\n--\n--   Use \'updateTable\' for comparisons with \'Bool\'.\nupdateTable\' :: forall table db be\n              . ( BeamSqlBackend be, Beamable table )\n             => DatabaseEntity be db (TableEntity table)\n                -- ^ The table to update\n             -> table (QFieldAssignment be table)\n                -- ^ Updates to be made (use \'set\' to construct an empty field)\n             -> (forall s. table (QExpr be s) -> QExpr be s SqlBool)\n             -> SqlUpdate be table\nupdateTable\' = updateTableImpl @SqlBool\n\n-- | Convenience form of \'updateTable\' that generates a @WHERE@ clause\n-- that matches only the already existing entity.\n--\n-- Use \'updateTableRow\'\' for an internal \'SqlBool\' comparison.\nupdateTableRow :: ( BeamSqlBackend be, Table table\n                  , HasTableEquality be (PrimaryKey table)\n                  , SqlValableTable be (PrimaryKey table) )\n               => DatabaseEntity be db (TableEntity table)\n                  -- ^ The table to update\n               -> table Identity\n                  -- ^ The row to update\n               -> table (QFieldAssignment be table)\n                  -- ^ Updates to be made (use \'set\' to construct an empty field)\n               -> SqlUpdate be table\nupdateTableRow tbl row assignments =\n  updateTable tbl assignments (references_ (val_ (pk row)))\n\n-- | Convenience form of \'updateTable\'\' that generates a @WHERE@ clause\n-- that matches only the already existing entity.\n--\n-- Uses \'update\'\' with a \'SqlBool\' comparison.\n-- Use \'updateTableRow\' for an internal \'Bool\' comparison.\nupdateTableRow\' :: ( BeamSqlBackend be, Table table\n                   , HasTableEquality be (PrimaryKey table)\n                   , SqlValableTable be (PrimaryKey table) )\n                => DatabaseEntity be db (TableEntity table)\n                   -- ^ The table to update\n                -> table Identity\n                   -- ^ The row to update\n                -> table (QFieldAssignment be table)\n                   -- ^ Updates to be made (use \'set\' to construct an empty field)\n                -> SqlUpdate be table\nupdateTableRow\' tbl row assignments =\n  updateTable\' tbl assignments (references_\' (val_ (pk row)))\n\nset :: forall table be table\'. Beamable table => table (QFieldAssignment be table\')\nset = changeBeamRep (\\_ -> Columnar\' (QFieldAssignment (\\_ -> Nothing))) (tblSkeleton :: TableSkeleton table)\n\nsetFieldsTo :: forall table be table\'\n             . Table table => (forall s. table (QExpr be s)) -> table (QFieldAssignment be table\')\nsetFieldsTo tbl =\n\n  runIdentity $\n  zipBeamFieldsM (\\(Columnar\' (Const columnIx))\n                   (Columnar\' (QExpr newValue)) ->\n                    if columnIx `elem` primaryKeyIndices\n                    then pure $ Columnar\' toOldValue\n                    else pure $ Columnar\' (toNewValue (QExpr newValue)))\n                 indexedTable tbl\n\n  where\n    indexedTable :: table (Const Int)\n    indexedTable =\n      flip evalState 0 $\n      zipBeamFieldsM (\\_ _ -> do\n                         n <- get\n                         put (n + 1)\n                         return (Columnar\' (Const n)))\n        (tblSkeleton :: TableSkeleton table) (tblSkeleton :: TableSkeleton table)\n\n    primaryKeyIndices :: [ Int ]\n    primaryKeyIndices = allBeamValues (\\(Columnar\' (Const ix)) -> ix) (primaryKey indexedTable)\n\n-- | Use with \'set\' to set a field to an explicit new value that does\n-- not depend on any other value\ntoNewValue :: (forall s. QExpr be s a) -> QFieldAssignment be table a\ntoNewValue newVal = toUpdatedValue (\\_ -> newVal)\n\n-- | Use with \'set\' to not modify the field\ntoOldValue :: QFieldAssignment be table a\ntoOldValue = toUpdatedValueMaybe (\\_ -> Nothing)\n\n-- | Use with \'set\' to set a field to a new value that is calculated\n-- based on one or more fields from the existing row\ntoUpdatedValue :: (forall s. table (QExpr be s) -> QExpr be s a) -> QFieldAssignment be table a\ntoUpdatedValue mkNewVal = toUpdatedValueMaybe (Just <$> mkNewVal)\n\n-- | Use with \'set\' to optionally set a fiield to a new value,\n-- calculated based on one or more fields from the existing row\ntoUpdatedValueMaybe :: (forall s. table (QExpr be s) -> Maybe (QExpr be s a)) -> QFieldAssignment be table a\ntoUpdatedValueMaybe = QFieldAssignment\n\n-- | Generate a \'SqlUpdate\' that will update the given table row with the given value.\n--\n--   The SQL @UPDATE@ that is generated will set every non-primary key field for\n--   the row where each primary key field is exactly what is given.\n--\n--   Note: This is a pure SQL @UPDATE@ command. This does not upsert or merge values.\n--\n--   Use \'save\'\' for an internal \'SqlBool\' comparison.\nsave :: forall table be db.\n        ( Table table\n        , BeamSqlBackend be\n\n        , SqlValableTable be (PrimaryKey table)\n        , SqlValableTable be table\n\n        , HasTableEquality be (PrimaryKey table)\n        )\n     => DatabaseEntity be db (TableEntity table)\n        -- ^ Table to update\n     -> table Identity\n        -- ^ Value to set to\n     -> SqlUpdate be table\nsave tbl v =\n  updateTableRow tbl v\n    (setFieldsTo (val_ v))\n\n-- | Generate a \'SqlUpdate\' that will update the given table row with the given value.\n-- This is a variant using \'update\'\' and a \'SqlBool\' comparison.\n--\n--   The SQL @UPDATE@ that is generated will set every non-primary key field for\n--   the row where each primary key field is exactly what is given.\n--\n--   Note: This is a pure SQL @UPDATE@ command. This does not upsert or merge values.\n--\n--   Use \'save\' for an internal \'Bool\' comparison.\nsave\' :: forall table be db.\n         ( Table table\n         , BeamSqlBackend be\n\n         , SqlValableTable be (PrimaryKey table)\n         , SqlValableTable be table\n\n         , HasTableEquality be (PrimaryKey table)\n         )\n      => DatabaseEntity be db (TableEntity table)\n         -- ^ Table to update\n      -> table Identity\n         -- ^ Value to set to\n      -> SqlUpdate be table\nsave\' tbl v =\n  updateTableRow\' tbl v\n    (setFieldsTo (val_ v))\n\n-- | Run a \'SqlUpdate\' in a \'MonadBeam\'.\nrunUpdate :: (BeamSqlBackend be, MonadBeam be m)\n          => SqlUpdate be tbl -> m ()\nrunUpdate (SqlUpdate _ u) = runNoReturn (updateCmd u)\nrunUpdate SqlIdentityUpdate = pure ()\n\n-- * DELETE\n\n-- | Represents a SQL @DELETE@ statement for the given @table@\ndata SqlDelete be (table :: (Type -> Type) -> Type)\n  = SqlDelete !(TableSettings table) !(BeamSqlBackendDeleteSyntax be)\n\n-- | Build a \'SqlDelete\' from a table and a way to build a @WHERE@ clause\ndelete :: forall be db table\n        . BeamSqlBackend be\n       => DatabaseEntity be db (TableEntity table)\n          -- ^ Table to delete from\n       -> (forall s. (forall s\'. table (QExpr be s\')) -> QExpr be s Bool)\n          -- ^ Build a @WHERE@ clause given a table containing expressions\n       -> SqlDelete be table\ndelete (DatabaseEntity dt@(DatabaseTable {})) mkWhere =\n  SqlDelete (dbTableSettings dt)\n            (deleteStmt (tableNameFromEntity dt) alias (Just (where_ "t")))\n  where\n    supportsAlias = deleteSupportsAlias (Proxy @(BeamSqlBackendDeleteSyntax be))\n\n    tgtName = "delete_target"\n    alias = if supportsAlias then Just tgtName else Nothing\n    mkField = if supportsAlias then qualifiedField tgtName else unqualifiedField\n\n    QExpr where_ = mkWhere (changeBeamRep (\\(Columnar\' fd) -> Columnar\' (QExpr (pure (fieldE (mkField (fd ^. fieldName))))))\n                             (dbTableSettings dt))\n\n-- | Run a \'SqlDelete\' in a \'MonadBeam\'\nrunDelete :: (BeamSqlBackend be, MonadBeam be m)\n          => SqlDelete be table -> m ()\nrunDelete (SqlDelete _ d) = runNoReturn (deleteCmd d)\n'