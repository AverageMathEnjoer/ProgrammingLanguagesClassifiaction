b'#include "AssetContainerList.h"\n#include <algorithm>\n#include <assert.h>\n\n\nclass ContainerPPtrIdx : public ContainerPPtr\n{\npublic:\n\tunsigned int containerIdx;\n\tContainerPPtrIdx(ResourceManager_PPtr &rsrcPPtr, unsigned int containerIdx = -1)\n\t\t: ContainerPPtr((unsigned int)rsrcPPtr.fileId, rsrcPPtr.pathId), containerIdx(containerIdx)\n\t{}\n\tContainerPPtrIdx(PreloadData &preloadPPtr, unsigned int containerIdx = -1)\n\t\t: ContainerPPtr((unsigned int)preloadPPtr.fileId, preloadPPtr.pathId), containerIdx(containerIdx)\n\t{}\n\tContainerPPtrIdx(unsigned int fileID, long long int pathID, unsigned int containerIdx = -1)\n\t\t: ContainerPPtr(fileID, pathID), containerIdx(containerIdx)\n\t{}\n};\nnamespace std\n{\n    template<> struct hash<ContainerPPtrIdx>\n    {\n        std::size_t operator()(ContainerPPtrIdx const& pptr) const\n\t\t{\n\t\t\treturn hash<ContainerPPtr>()(pptr);\n\t\t}\n    };\n}\n\ninline void prepareContainerEntry(ContainerData &containerData, ContainerEntry &containerEntry, size_t firstDep, size_t dependenciesSize)\n{\n\tcontainerEntry.name.assign(containerData.name);\n\tcontainerEntry.fileID = (unsigned int)containerData.ids.fileId;\n\tcontainerEntry.pathID = containerData.ids.pathId;\n\n\tcontainerEntry.firstDependencyIdx = firstDep + (unsigned int)containerData.preloadIndex;\n\tcontainerEntry.dependencyCount = (unsigned int)containerData.preloadSize;\n\tif (containerEntry.firstDependencyIdx >= dependenciesSize)\n\t{\n\t\tcontainerEntry.firstDependencyIdx = dependenciesSize;\n\t\tcontainerEntry.dependencyCount = 0;\n\t}\n\telse if (containerEntry.firstDependencyIdx + (size_t)containerEntry.dependencyCount > dependenciesSize)\n\t{\n\t\tcontainerEntry.dependencyCount = dependenciesSize - containerEntry.firstDependencyIdx;\n\t}\n}\n\nAssetContainerList::AssetContainerList()\n\t: pDependencies(new std::vector<ContainerDependencyEntry>()),\n\t  dependencySet(1 << 14,\n\t\thash_ContainerDependencyLookupEntry(*pDependencies),\n\t\tequality_ContainerDependencyLookupEntry(*pDependencies))\n{\n}\nAssetContainerList &AssetContainerList::operator=(AssetContainerList &&other)\n{\n\tcontainers = std::move(other.containers);\n\tcontainerMap = std::move(other.containerMap);\n\tdependencyStackHistory = std::move(other.dependencyStackHistory);\n\tpDependencies = std::move(other.pDependencies);\n\tdependencySet = std::move(other.dependencySet);\n\treturn (*this);\n}\nAssetContainerList::~AssetContainerList()\n{\n}\nbool AssetContainerList::LoadFrom(AssetBundleAsset &fileTable)\n{\n\tsize_t containerStart = this->containers.size();\n\tif (containerStart >= (0xFFFFFFFF - fileTable.containerArrayLen - 1)) //Count the potential main asset container.\n\t{\n\t\tassert(false);\n#ifdef _DEBUG\n\t\t//MessageBoxA(NULL, "AssetContainerList::LoadFrom : Containers overflow.", "UABE", 16);\n#endif\n\t\treturn false;\n\t}\n\tsize_t firstDep = this->pDependencies->size();\n\tif (firstDep >= (0xFFFFFFFF - fileTable.preloadArrayLen))\n\t{\n\t\tassert(false);\n#ifdef _DEBUG\n\t\t//MessageBoxA(NULL, "AssetContainerList::LoadFrom : Dependencies overflow.", "UABE", 16);\n#endif\n\t\treturn false;\n\t}\n\tsize_t stackHistoryStart = this->dependencyStackHistory.size();\n\tif (stackHistoryStart >= (0xFFFFFFFF - fileTable.containerArrayLen - 1)) //Count the potential main asset container.\n\t{\n\t\tassert(false);\n#ifdef _DEBUG\n\t\t//MessageBoxA(NULL, "AssetContainerList::LoadFrom : Stack history overflow.", "UABE", 16);\n#endif\n\t\treturn false;\n\t}\n\n\t//Insert the preload entries.\n\tthis->pDependencies->reserve(fileTable.preloadArrayLen);\n\tfor (unsigned int k = 0; k < fileTable.preloadArrayLen; k++)\n\t{\n\t\tPreloadData &prelDep = fileTable.preloadArray[k];\n\t\tthis->pDependencies->push_back(ContainerDependencyEntry((unsigned int)prelDep.fileId, prelDep.pathId, (unsigned int)stackHistoryStart, 0));\n\t\t//Link the dependency into dependencySet for quick lookup.\n\t\tunsigned int curMatchIdx = this->dependencySet.insert(ContainerDependencyLookupEntry((unsigned int)(firstDep + k))).first->lastRefIdx;\n\t\tif (curMatchIdx != (firstDep + k))\n\t\t{\n\t\t\twhile ((*this->pDependencies)[curMatchIdx].nextOccurrence != 0)\n\t\t\t\tcurMatchIdx = (*this->pDependencies)[curMatchIdx].nextOccurrence;\n\t\t\t(*this->pDependencies)[curMatchIdx].nextOccurrence = (unsigned int)(firstDep + k);\n\t\t}\n\t}\n\n\t//Temporary helpers to simplify the process of correcting activeStackHistorySize in dependencies.\n\tstd::vector<unsigned int> dependencyStackPopLocations; dependencyStackPopLocations.reserve(fileTable.containerArrayLen + 1);\n\tstd::vector<unsigned int> dependencyStackPushLocations; dependencyStackPushLocations.reserve(fileTable.containerArrayLen + 1);\n\n\t//Insert the containers and prepare dependencyStackHistory.\n\tthis->dependencyStackHistory.reserve(this->dependencyStackHistory.size() + fileTable.containerArrayLen + 1);\n\tthis->containers.resize(this->containers.size() + fileTable.containerArrayLen);\n\tfor (unsigned int i = 0; i < fileTable.containerArrayLen; i++)\n\t{\n\t\tContainerData &containerData = fileTable.containerArray[i];\n\t\tsize_t newIndex = containerStart + i;\n\t\tContainerEntry &containerEntry = this->containers[newIndex];\n\t\tprepareContainerEntry(containerData, containerEntry, firstDep, this->pDependencies->size());\n\t\tif (containerEntry.dependencyCount > 0)\n\t\t{\n\t\t\tthis->dependencyStackHistory.push_back((unsigned int)newIndex);\n\t\t\tdependencyStackPushLocations.push_back((unsigned int)containerEntry.firstDependencyIdx);\n\t\t\tdependencyStackPopLocations.push_back((unsigned int)(containerEntry.firstDependencyIdx + containerEntry.dependencyCount));\n\t\t\t//This loop should work, however this would result in O(N*M) performance (N : container count, M : average dependency count),\n\t\t\t// which would defeat the point of this data structure - N*M can be quite large in practice.\n\t\t\t//For this reason, two internal vectors are used to mark the push and pop locations, \n\t\t\t// by which the stack depth is calculated (see below).\n\t\t\t//for (unsigned int k = 0; k < containerEntry.dependencyCount; k++)\n\t\t\t//\tthis->dependencies[containerEntry.firstDependencyIdx + k].activeStackHistorySize++;\n\t\t}\n\t\tunsigned int curMatchIdx = this->containerMap.insert(std::make_pair(ContainerPPtr(containerEntry.fileID, containerEntry.pathID),(unsigned int)newIndex)).first->second;\n\t\tif (curMatchIdx != newIndex)\n\t\t{\n\t\t\twhile (this->containers[curMatchIdx].nextOccurrence != 0)\n\t\t\t\tcurMatchIdx = this->containers[curMatchIdx].nextOccurrence;\n\t\t\tthis->containers[curMatchIdx].nextOccurrence = (unsigned int)newIndex;\n\t\t}\n\t}\n\t//Insert the main asset container, if needed.\n\tif (fileTable.mainAsset.ids.pathId != 0)\n\t{\n\t\tContainerData &containerData = fileTable.mainAsset;\n\t\tthis->containers.resize(this->containers.size() + 1);\n\t\tsize_t newIndex = this->containers.size() - 1;\n\t\tContainerEntry &containerEntry = this->containers[newIndex];\n\t\tprepareContainerEntry(containerData, containerEntry, firstDep, this->pDependencies->size());\n\t\tif (containerEntry.dependencyCount > 0)\n\t\t{\n\t\t\tthis->dependencyStackHistory.push_back((unsigned int)newIndex);\n\t\t\tdependencyStackPushLocations.push_back((unsigned int)containerEntry.firstDependencyIdx);\n\t\t\tdependencyStackPopLocations.push_back((unsigned int)(containerEntry.firstDependencyIdx + containerEntry.dependencyCount));\n\t\t\t//for (unsigned int k = 0; k < containerEntry.dependencyCount; k++)\n\t\t\t//\tthis->dependencies[containerEntry.firstDependencyIdx + k].activeStackHistorySize++;\n\t\t}\n\t\tunsigned int curMatchIdx = this->containerMap.insert(std::make_pair(ContainerPPtr(containerEntry.fileID, containerEntry.pathID),(unsigned int)newIndex)).first->second;\n\t\tif (curMatchIdx != newIndex)\n\t\t{\n\t\t\twhile (this->containers[curMatchIdx].nextOccurrence != 0)\n\t\t\t\tcurMatchIdx = this->containers[curMatchIdx].nextOccurrence;\n\t\t\tthis->containers[curMatchIdx].nextOccurrence = (unsigned int)newIndex;\n\t\t}\n\t}\n\n\t//Sort the new elements of dependencyStackHistory by firstDependencyIdx.\n    struct StackHistoryComparer {\n\t\tstd::vector<ContainerEntry> &containers;\n\t\tStackHistoryComparer(std::vector<ContainerEntry> &containers)\n\t\t\t: containers(containers)\n\t\t{}\n        inline bool operator()(unsigned int a, unsigned int b) const\n        {\n\t\t\treturn containers[a].firstDependencyIdx < containers[b].firstDependencyIdx;\n        }\n    };\n\tStackHistoryComparer stackHistoryComparer = StackHistoryComparer(this->containers);\n\t//Sort dependencyStackHistory, so this->containers[this->dependencyStackHistory[i]].firstDependencyIdx is sorted ascendingly.\n\tstd::sort(this->dependencyStackHistory.begin() + stackHistoryStart, this->dependencyStackHistory.end(), stackHistoryComparer);\n\tstd::sort(dependencyStackPopLocations.begin(), dependencyStackPopLocations.end());\n\tstd::sort(dependencyStackPushLocations.begin(), dependencyStackPushLocations.end());\n\n\t//Fix the dependency stack history indices in dependencies.\n\tsize_t stackRefUpdate_UpperBound = this->pDependencies->size();\n\tfor (size_t _i = this->dependencyStackHistory.size(); _i > stackHistoryStart; _i--)\n\t{\n\t\tsize_t i = _i - 1;\n\t\tsize_t firstDependencyIdx = this->containers[this->dependencyStackHistory[i]].firstDependencyIdx;\n\t\tfor (size_t k = firstDependencyIdx; k < stackRefUpdate_UpperBound; k++)\n\t\t{\n\t\t\t(*this->pDependencies)[k].activeStackHistory = (unsigned int)(i);\n\t\t}\n\t\tstackRefUpdate_UpperBound = firstDependencyIdx;\n\t}\n\t\n\tbool shownBugMessage = false;\n\t//Fix the stack depths in dependencies.\n\tif (dependencyStackPushLocations.size() > 0)\n\t{\n\t\tsize_t start = dependencyStackPushLocations[0];\n\t\tunsigned int curDepth = 1;\n\t\tsize_t pushIdx = 1;\n\t\tsize_t popIdx = 0;\n\t\tfor (size_t i = start; i < this->pDependencies->size(); i++)\n\t\t{\n\t\t\twhile (pushIdx < dependencyStackPushLocations.size() && i >= dependencyStackPushLocations[pushIdx])\n\t\t\t{\n\t\t\t\tcurDepth++;\n\t\t\t\tpushIdx++;\n\t\t\t}\n\t\t\twhile (popIdx < dependencyStackPopLocations.size() && i >= dependencyStackPopLocations[popIdx])\n\t\t\t{\n\t\t\t\tif (curDepth == 0)\n\t\t\t\t{\n\t\t\t\t\tif (!shownBugMessage)\n\t\t\t\t\t{\n\t\t\t\t\t\tassert(false);\n#ifdef _DEBUG\n\t\t\t\t\t\t//MessageBox(NULL, TEXT("An error occured walking the container dependency stack."), TEXT("UABE"), 16); \n#endif\n\t\t\t\t\t}\n\t\t\t\t\tshownBugMessage = true;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tcurDepth--;\n\t\t\t\tpopIdx++;\n\t\t\t}\n\t\t\t(*this->pDependencies)[i].activeStackHistorySize = curDepth;\n\t\t}\n\t}\n\treturn true;\n}\nbool AssetContainerList::LoadFrom(ResourceManagerFile &resourceFile)\n{\n\tsize_t containerStart = this->containers.size();\n\tstd::unordered_set<ContainerPPtrIdx> containerSetTemp;\n\t//Copy containers.\n\tunsigned int containerArrayLen = resourceFile.containers.size();\n\tif (containerArrayLen > 0x7FFFFFFF) containerArrayLen = 0x7FFFFFFF;\n\tthis->containers.resize(this->containers.size() + containerArrayLen);\n\tfor (unsigned int i = 0; i < containerArrayLen; i++)\n\t{\n\t\tthis->containers[containerStart + i].name.assign(resourceFile.containers[i].name);\n\t\tthis->containers[containerStart + i].dependencyCount = 0;\n\t\tthis->containers[containerStart + i].firstDependencyIdx = 0;\n\t\tContainerPPtrIdx pptr(resourceFile.containers[i].ids, i);\n\t\tthis->containers[containerStart + i].fileID = pptr.fileID;\n\t\tthis->containers[containerStart + i].pathID = pptr.pathID;\n\t\tcontainerSetTemp.insert(pptr);\n\n\t\tunsigned int curMatchIdx = this->containerMap.insert(std::make_pair(ContainerPPtr(pptr.fileID, pptr.pathID),(unsigned int)(containerStart + i))).first->second;\n\t\tif (curMatchIdx != (containerStart + i))\n\t\t{\n\t\t\twhile (this->containers[curMatchIdx].nextOccurrence != 0)\n\t\t\t\tcurMatchIdx = this->containers[curMatchIdx].nextOccurrence;\n\t\t\tthis->containers[curMatchIdx].nextOccurrence = (unsigned int)(containerStart + i);\n\t\t}\n\t}\n\t//Copy dependencies.\n\tunsigned int dependenciesArrayLen = resourceFile.dependencyLists.size();\n\tif (dependenciesArrayLen > 0x7FFFFFFF) dependenciesArrayLen = 0x7FFFFFFF;\n\tfor (unsigned int i = 0; i < dependenciesArrayLen; i++)\n\t{\n\t\tResourceManager_AssetDependencies &rsrcDepList = resourceFile.dependencyLists[i];\n\t\tunsigned int nextContainerIdx = (unsigned int)(this->containers.size() - containerStart);\n\t\tconst ContainerPPtrIdx &pptr = *containerSetTemp.insert(ContainerPPtrIdx(rsrcDepList.asset, nextContainerIdx)).first;\n\t\tsize_t containerIdx = containerStart + pptr.containerIdx;\n\t\tif (pptr.containerIdx == nextContainerIdx) //New item, treat like a container with an empty name.\n\t\t{\n\t\t\tthis->containers.resize(this->containers.size() + 1);\n\t\t\tthis->containers[containerIdx].fileID = pptr.fileID;\n\t\t\tthis->containers[containerIdx].pathID = pptr.pathID;\n\t\t}\n\t\tif (this->containers[containerIdx].dependencyCount != 0)\n\t\t{\n\t\t\t//We are doomed.\n\t\t\t//This means that there are multiple dependency lists for the same PPtr.\n\t\t\tassert(false);\n#ifdef _DEBUG\n\t\t\t//MessageBoxA(NULL, "AssetContainerList::LoadFrom : ResourceManager asset has multiple dependency lists for the same asset.", "UABE", 16);\n\t\t\t//This break intentionally is for debug mode only. There may be a use to continue if the following dependency lists are for new PPtrs.\n\t\t\tbreak;\n#endif\n\t\t\t//Otherwise : Silent ignore.\n\t\t}\n\t\telse if (containerIdx > 0xFFFFFFFEU || rsrcDepList.dependencies.size() > 0xFFFFFFFEU && this->pDependencies->size() > (0xFFFFFFFEU - rsrcDepList.dependencies.size()))\n\t\t{\n\t\t\t//This is strange.\n\t\t\t//If there were this many containers and/or dependencies, they would take at least ~100GiB.\n\t\t\tassert(false);\n#ifdef _DEBUG\n\t\t\t//MessageBoxA(NULL, "AssetContainerList::LoadFrom : Containers or dependencies overflow.", "UABE", 16);\n#endif\n\t\t\tbreak;\n\t\t}\n\t\telse if (this->dependencyStackHistory.size() > 0xFFFFFFFFU)\n\t\t{\n\t\t\t//Should not happen after the previous checks.\n\t\t\tassert(false);\n#ifdef _DEBUG\n\t\t\t//MessageBoxA(NULL, "AssetContainerList::LoadFrom : Stack history overflow.", "UABE", 16);\n#endif\n\t\t\tbreak;\n\t\t}\n\t\telse if (rsrcDepList.dependencies.size() > 0)\n\t\t{\n\t\t\tthis->containers[containerIdx].firstDependencyIdx = this->pDependencies->size();\n\t\t\tthis->containers[containerIdx].dependencyCount = rsrcDepList.dependencies.size();\n\t\t\tthis->dependencyStackHistory.push_back((unsigned int)containerIdx);\n\t\t\tunsigned int stackHistorySize = (unsigned int)this->dependencyStackHistory.size();\n\n\t\t\tsize_t firstDep = this->pDependencies->size();\n\t\t\tthis->pDependencies->reserve(rsrcDepList.dependencies.size());\n\t\t\tfor (unsigned int k = 0; k < rsrcDepList.dependencies.size(); k++)\n\t\t\t{\n\t\t\t\tResourceManager_PPtr &rsrcDep = rsrcDepList.dependencies[k];\n\t\t\t\t//Due to the way ResourceManager assets are structured, we have no overlapping dependency list parts.\n\t\t\t\tthis->pDependencies->push_back(ContainerDependencyEntry((unsigned int)rsrcDep.fileId, rsrcDep.pathId, stackHistorySize - 1, 1));\n\t\t\t\t//Link the dependency into dependencySet for quick lookup.\n\t\t\t\tunsigned int curMatchIdx = this->dependencySet.insert(ContainerDependencyLookupEntry((unsigned int)(firstDep + k))).first->lastRefIdx;\n\t\t\t\tif (curMatchIdx != (firstDep + k))\n\t\t\t\t{\n\t\t\t\t\twhile ((*this->pDependencies)[curMatchIdx].nextOccurrence != 0)\n\t\t\t\t\t\tcurMatchIdx = (*this->pDependencies)[curMatchIdx].nextOccurrence;\n\t\t\t\t\t(*this->pDependencies)[curMatchIdx].nextOccurrence = (unsigned int)(firstDep + k);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\n\nstd::vector<const ContainerEntry*> AssetContainerList::getContainers(unsigned int fileID, long long pathID) const\n{\n\tstd::vector<const ContainerEntry*> ret;\n\tauto result = containerMap.find(ContainerPPtr(fileID, pathID));\n\tif (result != containerMap.end())\n\t{\n\t\tunsigned int entryIdx = result->second;\n\t\tdo {\n\t\t\tconst ContainerEntry &entry = this->containers[entryIdx];\n\t\t\tret.push_back(&entry);\n\t\t\tentryIdx = entry.nextOccurrence;\n\t\t} while (entryIdx != 0);\n\t}\n\treturn ret;\n}\n\nvoid AssetContainerList::getContainersFor(std::vector<const ContainerEntry*> &ret, unsigned int dependencyIdx) const\n{\n\tunsigned int remStackDepth = (*this->pDependencies)[dependencyIdx].activeStackHistorySize;\n\tfor (unsigned int i = (*this->pDependencies)[dependencyIdx].activeStackHistory; i != (unsigned int)-1 && remStackDepth > 0; i--)\n\t{\n\t\tconst ContainerEntry &entry = this->containers[this->dependencyStackHistory[i]];\n\t\tif (entry.firstDependencyIdx + entry.dependencyCount >= dependencyIdx)\n\t\t{\n\t\t\tret.push_back(&entry);\n\t\t\tremStackDepth--;\n\t\t}\n\t}\n\tassert(remStackDepth == 0);\n}\n\nstatic thread_local unsigned int curVirtualContainerLookupPlaceholder_fileID;\nstatic thread_local long long curVirtualContainerLookupPlaceholder_pathID;\n\nstd::vector<const ContainerEntry*> AssetContainerList::getParentContainers(unsigned int fileID, long long pathID) const\n{\n\tstd::size_t targetHash = std::hash<ContainerDependencyEntry>()(ContainerDependencyEntry(fileID, pathID, 0, 0));\n\tstd::vector<const ContainerEntry*> ret;\n\n\t//Set the thread local placeholder PPtr for the hash and equality functions to use.\n\t// -> We aren\'t allowed (and shouldn\'t) insert anything into dependencySet in this function,\n\t//       so we define UINT_MAX as a placeholder index\n\t//       that the hasher and equality pred of dependencySet translate to curVirtualContainerLookupPlaceholder.\n\tcurVirtualContainerLookupPlaceholder_fileID = fileID;\n\tcurVirtualContainerLookupPlaceholder_pathID = pathID;\n\n\tauto dependencySetIt = dependencySet.find(ContainerDependencyLookupEntry(UINT_MAX));\n\n\tif (dependencySetIt != dependencySet.end())\n\t{\n\t\tunsigned int curMatchIdx = dependencySetIt->lastRefIdx;\n\t\tconst ContainerDependencyEntry &entry = (*this->pDependencies)[dependencySetIt->lastRefIdx];\n\t\tassert(entry.fileID == fileID && entry.pathID == pathID);\n\t\tif (entry.fileID == fileID && entry.pathID == pathID)\n\t\t{\n\t\t\tgetContainersFor(ret, curMatchIdx);\n\t\t\twhile ((curMatchIdx = (*this->pDependencies)[curMatchIdx].nextOccurrence) != 0)\n\t\t\t\tgetContainersFor(ret, curMatchIdx);\n\t\t}\n\t}\n\treturn ret;\n}\n\nnamespace std\n{\n    std::size_t hash<ContainerPPtr>::operator()(ContainerPPtr const& pptr) const\n    {\n\t\tstatic std::hash<unsigned int> uintHash;\n\t\tstatic std::hash<long long int> llHash;\n\t\t//static std::hash<size_t> sizetHash;\n        size_t fidHash = uintHash(pptr.fileID);\n\t\tsize_t pidHash = llHash(pptr.pathID);\n        return (fidHash << 1) ^ pidHash; //sizetHash((fidHash << 1) ^ pidHash);\n    }\n    std::size_t hash<ContainerDependencyEntry>::operator()(ContainerDependencyEntry const& pptr) const\n    {\n\t\tstatic std::hash<unsigned int> uintHash;\n\t\tstatic std::hash<long long int> llHash;\n\t\t//static std::hash<size_t> sizetHash;\n        size_t fidHash = uintHash(pptr.fileID);\n\t\tsize_t pidHash = llHash(pptr.pathID);\n        return (fidHash << 1) ^ pidHash; //sizetHash((fidHash << 1) ^ pidHash);\n    }\n}\n\nhash_ContainerDependencyLookupEntry::hash_ContainerDependencyLookupEntry(std::vector<ContainerDependencyEntry> &dependencies)\n\t\t: pDependencies(&dependencies)\n{}\nstd::size_t hash_ContainerDependencyLookupEntry::operator()(ContainerDependencyLookupEntry const& entry) const\n{\n\tif (entry.lastRefIdx == UINT_MAX)\n\t\treturn std::hash<ContainerPPtr>()(ContainerPPtr(curVirtualContainerLookupPlaceholder_fileID, curVirtualContainerLookupPlaceholder_pathID));\n\treturn entryHash((*pDependencies)[entry.lastRefIdx]);\n}\n\nequality_ContainerDependencyLookupEntry::equality_ContainerDependencyLookupEntry(std::vector<ContainerDependencyEntry> &dependencies)\n\t\t: pDependencies(&dependencies)\n{}\nbool equality_ContainerDependencyLookupEntry::operator()(ContainerDependencyLookupEntry const& entryrefA, ContainerDependencyLookupEntry const& entryrefB) const\n{\n\tContainerPPtr pptrA = ContainerPPtr(curVirtualContainerLookupPlaceholder_fileID, curVirtualContainerLookupPlaceholder_pathID);\n\tif (entryrefA.lastRefIdx != UINT_MAX)\n\t{\n\t\tContainerDependencyEntry const &entryA = (*pDependencies)[entryrefA.lastRefIdx];\n\t\tpptrA.fileID = entryA.fileID;\n\t\tpptrA.pathID = entryA.pathID;\n\t}\n\tContainerPPtr pptrB = ContainerPPtr(curVirtualContainerLookupPlaceholder_fileID, curVirtualContainerLookupPlaceholder_pathID);\n\tif (entryrefB.lastRefIdx != UINT_MAX)\n\t{\n\t\tContainerDependencyEntry const &entryB = (*pDependencies)[entryrefB.lastRefIdx];\n\t\tpptrB.fileID = entryB.fileID;\n\t\tpptrB.pathID = entryB.pathID;\n\t}\n\treturn (pptrA.fileID == pptrB.fileID && pptrA.pathID == pptrB.pathID);\n}\n'