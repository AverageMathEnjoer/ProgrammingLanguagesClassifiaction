b'{-# LANGUAGE CPP #-}\n{-# LANGUAGE UndecidableInstances #-}\n-- | This module implements an AST type for SQL92. It allows us to realize\n--   the call structure of the builders defined in "Database.Beam.Backend.SQL.SQL92"\nmodule Database.Beam.Backend.SQL.AST where\n\nimport Prelude hiding (Ordering)\n\nimport Database.Beam.Backend.Internal.Compat\nimport Database.Beam.Backend.SQL.SQL92\nimport Database.Beam.Backend.SQL.SQL99\nimport Database.Beam.Backend.SQL.SQL2003\nimport Database.Beam.Backend.SQL.Types\n\nimport Data.Text (Text)\nimport Data.ByteString (ByteString)\nimport Data.Time\nimport Data.Word (Word16, Word32, Word64)\nimport Data.Typeable\nimport Data.Int\nimport GHC.TypeLits\n\ndata Command\n  = SelectCommand Select\n  | InsertCommand Insert\n  | UpdateCommand Update\n  | DeleteCommand Delete\n  deriving (Show, Eq)\n\ninstance IsSql92Syntax Command where\n  type Sql92SelectSyntax Command = Select\n  type Sql92UpdateSyntax Command = Update\n  type Sql92InsertSyntax Command = Insert\n  type Sql92DeleteSyntax Command = Delete\n\n  selectCmd = SelectCommand\n  insertCmd = InsertCommand\n  updateCmd = UpdateCommand\n  deleteCmd = DeleteCommand\n\ndata Select\n    = Select\n    { selectTable :: SelectTable\n    , selectOrdering   :: [ Ordering ]\n    , selectLimit, selectOffset :: Maybe Integer }\n    deriving (Show, Eq)\n\ninstance IsSql92SelectSyntax Select where\n  type Sql92SelectSelectTableSyntax Select = SelectTable\n  type Sql92SelectOrderingSyntax Select = Ordering\n\n  selectStmt = Select\n\ndata SelectTable\n  = SelectTable\n  { selectQuantifier :: Maybe SetQuantifier\n  , selectProjection :: Projection\n  , selectFrom       :: Maybe From\n  , selectWhere      :: Maybe Expression\n  , selectGrouping   :: Maybe Grouping\n  , selectHaving     :: Maybe Expression }\n  | UnionTables Bool SelectTable SelectTable\n  | IntersectTables Bool SelectTable SelectTable\n  | ExceptTable Bool SelectTable SelectTable\n  deriving (Show, Eq)\n\ninstance IsSql92SelectTableSyntax SelectTable where\n  type Sql92SelectTableSelectSyntax SelectTable = Select\n  type Sql92SelectTableExpressionSyntax SelectTable = Expression\n  type Sql92SelectTableProjectionSyntax SelectTable = Projection\n  type Sql92SelectTableFromSyntax SelectTable = From\n  type Sql92SelectTableGroupingSyntax SelectTable = Grouping\n  type Sql92SelectTableSetQuantifierSyntax SelectTable = SetQuantifier\n\n  selectTableStmt = SelectTable\n  unionTables = UnionTables\n  intersectTables = IntersectTables\n  exceptTable = ExceptTable\n\ndata Insert\n  = Insert\n  { insertTable :: TableName\n  , insertFields :: [ Text ]\n  , insertValues :: InsertValues }\n  deriving (Show, Eq)\n\ninstance IsSql92InsertSyntax Insert where\n  type Sql92InsertValuesSyntax Insert = InsertValues\n  type Sql92InsertTableNameSyntax Insert = TableName\n\n  insertStmt = Insert\n\ndata InsertValues\n  = InsertValues\n  { insertValuesExpressions :: [ [ Expression ] ] }\n  | InsertSelect\n  { insertSelectStmt :: Select }\n  deriving (Show, Eq)\n\ninstance IsSql92InsertValuesSyntax InsertValues where\n  type Sql92InsertValuesExpressionSyntax InsertValues = Expression\n  type Sql92InsertValuesSelectSyntax InsertValues = Select\n\n  insertSqlExpressions = InsertValues\n  insertFromSql = InsertSelect\n\ndata Update\n  = Update\n  { updateTable :: TableName\n  , updateFields :: [ (FieldName, Expression) ]\n  , updateWhere :: Maybe Expression }\n  deriving (Show, Eq)\n\ninstance IsSql92UpdateSyntax Update where\n  type Sql92UpdateTableNameSyntax Update = TableName\n  type Sql92UpdateFieldNameSyntax Update = FieldName\n  type Sql92UpdateExpressionSyntax Update = Expression\n\n  updateStmt = Update\n\ndata Delete\n  = Delete\n  { deleteTable :: TableName\n  , deleteAlias :: Maybe Text\n  , deleteWhere :: Maybe Expression }\n  deriving (Show, Eq)\n\ninstance IsSql92DeleteSyntax Delete where\n  type Sql92DeleteTableNameSyntax Delete = TableName\n  type Sql92DeleteExpressionSyntax Delete = Expression\n\n  deleteStmt = Delete\n  deleteSupportsAlias _ = True\n\ndata FieldName\n  = QualifiedField Text Text\n  | UnqualifiedField Text\n  deriving (Show, Eq)\n\ninstance IsSql92FieldNameSyntax FieldName where\n  qualifiedField = QualifiedField\n  unqualifiedField = UnqualifiedField\n\ndata ComparatorQuantifier\n  = ComparatorQuantifierAny\n  | ComparatorQuantifierAll\n  deriving (Show, Eq)\n\ninstance IsSql92QuantifierSyntax ComparatorQuantifier where\n  quantifyOverAll = ComparatorQuantifierAll\n  quantifyOverAny = ComparatorQuantifierAny\n\ndata ExtractField\n  = ExtractFieldTimeZoneHour\n  | ExtractFieldTimeZoneMinute\n\n  | ExtractFieldDateTimeYear\n  | ExtractFieldDateTimeMonth\n  | ExtractFieldDateTimeDay\n  | ExtractFieldDateTimeHour\n  | ExtractFieldDateTimeMinute\n  | ExtractFieldDateTimeSecond\n  deriving (Show, Eq)\n\ndata DataType\n  = DataTypeChar Bool {- Varying -} (Maybe Word) (Maybe Text)\n  | DataTypeNationalChar Bool (Maybe Word)\n  | DataTypeBit Bool (Maybe Word)\n  | DataTypeNumeric (Maybe (Word, Maybe Word))\n  | DataTypeDecimal (Maybe (Word, Maybe Word))\n  | DataTypeInteger\n  | DataTypeSmallInt\n  | DataTypeBigInt\n  | DataTypeFloat (Maybe Word)\n  | DataTypeReal\n  | DataTypeDoublePrecision\n  | DataTypeDate\n  | DataTypeTime (Maybe Word) {- time fractional seconds precision -} Bool {- With time zone -}\n  | DataTypeTimeStamp (Maybe Word) Bool\n  | DataTypeInterval ExtractField\n  | DataTypeIntervalFromTo ExtractField ExtractField\n  | DataTypeBoolean\n\n  | DataTypeBinaryLargeObject\n  | DataTypeCharacterLargeObject\n\n  | DataTypeArray DataType Int\n  | DataTypeRow [ (Text, DataType) ]\n\n  | DataTypeDomain Text\n  deriving (Show, Eq)\n\ninstance IsSql92DataTypeSyntax DataType where\n  domainType = DataTypeDomain\n  charType = DataTypeChar False\n  varCharType = DataTypeChar True\n  nationalCharType = DataTypeNationalChar False\n  nationalVarCharType = DataTypeNationalChar True\n  bitType = DataTypeBit False\n  varBitType = DataTypeBit True\n  numericType = DataTypeNumeric\n  decimalType = DataTypeDecimal\n  intType = DataTypeInteger\n  smallIntType = DataTypeSmallInt\n  floatType = DataTypeFloat\n  doubleType = DataTypeDoublePrecision\n  realType = DataTypeReal\n\n  dateType = DataTypeDate\n  timeType = DataTypeTime\n  timestampType = DataTypeTimeStamp\n\ninstance IsSql99DataTypeSyntax DataType where\n  characterLargeObjectType = DataTypeCharacterLargeObject\n  binaryLargeObjectType = DataTypeCharacterLargeObject\n  booleanType = DataTypeBoolean\n  arrayType = DataTypeArray\n  rowType = DataTypeRow\n\ninstance IsSql2008BigIntDataTypeSyntax DataType where\n  bigIntType = DataTypeBigInt\n\ndata SetQuantifier\n  = SetQuantifierAll | SetQuantifierDistinct\n  deriving (Show, Eq)\n\ninstance IsSql92AggregationSetQuantifierSyntax SetQuantifier where\n  setQuantifierDistinct = SetQuantifierDistinct\n  setQuantifierAll = SetQuantifierAll\n\ndata Expression\n  = ExpressionValue Value\n  | ExpressionDefault\n  | ExpressionRow [ Expression ]\n\n  | ExpressionIn Expression [ Expression ]\n  | ExpressionInSelect Expression Select\n\n  | ExpressionIsNull Expression\n  | ExpressionIsNotNull Expression\n  | ExpressionIsTrue Expression\n  | ExpressionIsNotTrue Expression\n  | ExpressionIsFalse Expression\n  | ExpressionIsNotFalse Expression\n  | ExpressionIsUnknown Expression\n  | ExpressionIsNotUnknown Expression\n\n  | ExpressionCase [(Expression, Expression)] Expression\n  | ExpressionCoalesce [Expression]\n  | ExpressionNullIf Expression Expression\n\n  | ExpressionFieldName FieldName\n\n  | ExpressionBetween Expression Expression Expression\n  | ExpressionBinOp Text Expression Expression\n  | ExpressionCompOp Text (Maybe ComparatorQuantifier) Expression Expression\n  | ExpressionUnOp Text Expression\n\n  | ExpressionPosition Expression Expression\n  | ExpressionCast Expression DataType\n  | ExpressionExtract ExtractField Expression\n  | ExpressionCharLength Expression\n  | ExpressionOctetLength Expression\n  | ExpressionBitLength Expression\n  | ExpressionAbs Expression\n  | ExpressionLower Expression\n  | ExpressionUpper Expression\n  | ExpressionTrim Expression\n\n  | ExpressionNamedFunction Text\n  | ExpressionFunctionCall Expression [ Expression ]\n  | ExpressionInstanceField Expression Text\n  | ExpressionRefField Expression Text\n\n  | ExpressionCountAll\n  | ExpressionAgg Text (Maybe SetQuantifier) [ Expression ]\n  | ExpressionBuiltinFunction Text [ Expression ]\n\n  | ExpressionSubquery Select\n  | ExpressionUnique Select\n  | ExpressionDistinct Select\n  | ExpressionExists Select\n\n  | ExpressionOver Expression WindowFrame\n\n  | ExpressionCurrentTimestamp\n  deriving (Show, Eq)\n\ninstance IsSql92ExtractFieldSyntax ExtractField where\n  secondsField = ExtractFieldDateTimeSecond\n  minutesField = ExtractFieldDateTimeMinute\n  hourField = ExtractFieldDateTimeHour\n  dayField = ExtractFieldDateTimeDay\n  monthField = ExtractFieldDateTimeMonth\n  yearField = ExtractFieldDateTimeYear\n\ninstance IsSql92ExpressionSyntax Expression where\n  type Sql92ExpressionQuantifierSyntax Expression = ComparatorQuantifier\n  type Sql92ExpressionValueSyntax Expression = Value\n  type Sql92ExpressionSelectSyntax Expression = Select\n  type Sql92ExpressionFieldNameSyntax Expression = FieldName\n  type Sql92ExpressionCastTargetSyntax Expression = DataType\n  type Sql92ExpressionExtractFieldSyntax Expression = ExtractField\n\n  valueE = ExpressionValue\n  rowE = ExpressionRow\n\n  isNullE = ExpressionIsNull\n  isNotNullE = ExpressionIsNotNull\n  isTrueE = ExpressionIsTrue\n  isNotTrueE = ExpressionIsNotTrue\n  isFalseE = ExpressionIsFalse\n  isNotFalseE = ExpressionIsNotFalse\n  isUnknownE = ExpressionIsUnknown\n  isNotUnknownE = ExpressionIsNotUnknown\n\n  caseE = ExpressionCase\n  coalesceE = ExpressionCoalesce\n  nullIfE = ExpressionNullIf\n  positionE = ExpressionPosition\n  extractE = ExpressionExtract\n  castE = ExpressionCast\n\n  fieldE = ExpressionFieldName\n\n  betweenE = ExpressionBetween\n  andE = ExpressionBinOp "AND"\n  orE = ExpressionBinOp "OR"\n\n  eqE = ExpressionCompOp "=="\n  neqE = ExpressionCompOp "<>"\n  ltE = ExpressionCompOp "<"\n  gtE = ExpressionCompOp ">"\n  leE = ExpressionCompOp "<="\n  geE = ExpressionCompOp ">="\n  addE = ExpressionBinOp "+"\n  subE = ExpressionBinOp "-"\n  mulE = ExpressionBinOp "*"\n  divE = ExpressionBinOp "/"\n  modE = ExpressionBinOp "%"\n  likeE = ExpressionBinOp "LIKE"\n  overlapsE = ExpressionBinOp "OVERLAPS"\n\n  notE = ExpressionUnOp "NOT"\n  negateE = ExpressionUnOp "-"\n\n  charLengthE = ExpressionCharLength\n  octetLengthE = ExpressionOctetLength\n  bitLengthE = ExpressionBitLength\n  absE = ExpressionAbs\n  lowerE = ExpressionLower\n  upperE = ExpressionUpper\n  trimE = ExpressionTrim\n\n  subqueryE = ExpressionSubquery\n  uniqueE = ExpressionUnique\n  existsE = ExpressionExists\n\n  currentTimestampE = ExpressionCurrentTimestamp\n\n  defaultE = ExpressionDefault\n  inE = ExpressionIn\n  inSelectE = ExpressionInSelect\n\ninstance IsSql99FunctionExpressionSyntax Expression where\n  functionNameE = ExpressionNamedFunction\n  functionCallE = ExpressionFunctionCall\n\ninstance IsSql99ExpressionSyntax Expression where\n  distinctE = ExpressionDistinct\n  similarToE = ExpressionBinOp "SIMILAR TO"\n  instanceFieldE = ExpressionInstanceField\n  refFieldE = ExpressionRefField\n\ninstance IsSql92AggregationExpressionSyntax Expression where\n  type Sql92AggregationSetQuantifierSyntax Expression = SetQuantifier\n\n  countAllE = ExpressionCountAll\n  countE q = ExpressionAgg "COUNT" q . pure\n  sumE q   = ExpressionAgg "SUM" q . pure\n  minE q   = ExpressionAgg "MIN" q . pure\n  maxE q   = ExpressionAgg "MAX" q . pure\n  avgE q   = ExpressionAgg "AVG" q . pure\n\ninstance IsSql99AggregationExpressionSyntax Expression where\n  everyE q = ExpressionAgg "EVERY" q . pure\n  someE q  = ExpressionAgg "SOME" q . pure\n  anyE q   = ExpressionAgg "ANY" q . pure\n\ninstance IsSql2003EnhancedNumericFunctionsExpressionSyntax Expression where\n  lnE    = ExpressionBuiltinFunction "LN" . pure\n  expE   = ExpressionBuiltinFunction "EXP" . pure\n  sqrtE  = ExpressionBuiltinFunction "SQRT" . pure\n  ceilE  = ExpressionBuiltinFunction "CEIL" . pure\n  floorE = ExpressionBuiltinFunction "FLOOR" . pure\n  powerE a b = ExpressionBuiltinFunction "POWER" [a, b]\n\ninstance IsSql2003EnhancedNumericFunctionsAggregationExpressionSyntax Expression where\n  stddevPopE q  = ExpressionAgg "STDDEV_POP" q . pure\n  stddevSampE q = ExpressionAgg "STDDEV_SAMP" q . pure\n  varPopE q     = ExpressionAgg "VAR_POP" q . pure\n  varSampE q    = ExpressionAgg "VAR_SAMP" q . pure\n\n  covarPopE q a b      = ExpressionAgg "COVAR_POP" q [a, b]\n  covarSampE q a b     = ExpressionAgg "COVAR_SAMP" q [a, b]\n  corrE q a b          = ExpressionAgg "CORR" q [a, b]\n  regrSlopeE q a b     = ExpressionAgg "REGR_SLOPE" q [a, b]\n  regrInterceptE q a b = ExpressionAgg "REGR_INTERCEPT" q [a, b]\n  regrCountE q a b     = ExpressionAgg "REGR_COUNT" q [a, b]\n  regrRSquaredE q a b  = ExpressionAgg "REGR_R2" q [a, b]\n  regrAvgXE q a b      = ExpressionAgg "REGR_AVGX" q [a, b]\n  regrAvgYE q a b      = ExpressionAgg "REGR_AVGY" q [a, b]\n  regrSXXE q a b       = ExpressionAgg "REGR_SXX" q [a, b]\n  regrSXYE q a b       = ExpressionAgg "REGR_SXY" q [a, b]\n  regrSYYE q a b       = ExpressionAgg "REGR_SYY" q [a, b]\n\ninstance IsSql2003NtileExpressionSyntax Expression where\n  ntileE = ExpressionAgg "NTILE" Nothing . pure\n\ninstance IsSql2003LeadAndLagExpressionSyntax Expression where\n  leadE x Nothing Nothing   = ExpressionAgg "LEAD" Nothing [x]\n  leadE x (Just y) Nothing  = ExpressionAgg "LEAD" Nothing [x, y]\n  leadE x (Just y) (Just z) = ExpressionAgg "LEAD" Nothing [x, y, z]\n  leadE x Nothing (Just z)  = ExpressionAgg "LEAD" Nothing [x, ExpressionValue (Value (1 :: Int)), z]\n\n  lagE x Nothing Nothing  = ExpressionAgg "LAG" Nothing [x]\n  lagE x (Just y) Nothing = ExpressionAgg "LAG" Nothing [x, y]\n  lagE x (Just y) (Just z) = ExpressionAgg "LAG" Nothing [x, y, z]\n  lagE x Nothing (Just z)  = ExpressionAgg "LAG" Nothing [x, ExpressionValue (Value (1 :: Int)), z]\n\ninstance IsSql2003NthValueExpressionSyntax Expression where\n  nthValueE a b = ExpressionAgg "NTH_VALUE" Nothing [a, b]\n\ninstance IsSql2003ExpressionSyntax Expression where\n  type Sql2003ExpressionWindowFrameSyntax Expression = WindowFrame\n\n  overE = ExpressionOver\n  rowNumberE = ExpressionAgg "ROW_NUMBER" Nothing []\n\nnewtype Projection\n  = ProjExprs [ (Expression, Maybe Text ) ]\n  deriving (Show, Eq)\n\ninstance IsSql92ProjectionSyntax Projection where\n  type Sql92ProjectionExpressionSyntax Projection = Expression\n\n  projExprs = ProjExprs\n\ndata Ordering\n  = OrderingAsc Expression\n  | OrderingDesc Expression\n  deriving (Show, Eq)\n\ninstance IsSql92OrderingSyntax Ordering where\n  type Sql92OrderingExpressionSyntax Ordering = Expression\n\n  ascOrdering = OrderingAsc\n  descOrdering = OrderingDesc\n\nnewtype Grouping = Grouping [ Expression ] deriving (Show, Eq)\n\ninstance IsSql92GroupingSyntax Grouping where\n  type Sql92GroupingExpressionSyntax Grouping = Expression\n\n  groupByExpressions = Grouping\n\ndata TableName = TableName (Maybe Text) Text\n  deriving (Show, Eq, Ord)\n\ninstance IsSql92TableNameSyntax TableName where\n  tableName = TableName\n\ndata TableSource\n  = TableNamed TableName\n  | TableFromSubSelect Select\n  | TableFromValues [ [ Expression ] ]\n  deriving (Show, Eq)\n\ninstance IsSql92TableSourceSyntax TableSource where\n  type Sql92TableSourceSelectSyntax TableSource = Select\n  type Sql92TableSourceExpressionSyntax TableSource = Expression\n  type Sql92TableSourceTableNameSyntax TableSource = TableName\n\n  tableNamed = TableNamed\n  tableFromSubSelect = TableFromSubSelect\n  tableFromValues = TableFromValues\n\ndata From\n  = FromTable TableSource (Maybe (Text, Maybe [Text]))\n  | InnerJoin From From (Maybe Expression)\n  | LeftJoin From From (Maybe Expression)\n  | RightJoin From From (Maybe Expression)\n  | OuterJoin From From (Maybe Expression)\n  deriving (Show, Eq)\n\ninstance IsSql92FromSyntax From where\n  type Sql92FromTableSourceSyntax From = TableSource\n  type Sql92FromExpressionSyntax From = Expression\n\n  fromTable = FromTable\n  innerJoin = InnerJoin\n  leftJoin = LeftJoin\n  rightJoin = RightJoin\n\ndata Value where\n  Value :: (Show a, Eq a, Typeable a) => a -> Value\n\n#define VALUE_SYNTAX_INSTANCE(ty) instance HasSqlValueSyntax Value ty where { sqlValueSyntax = Value }\nVALUE_SYNTAX_INSTANCE(Int16)\nVALUE_SYNTAX_INSTANCE(Int32)\nVALUE_SYNTAX_INSTANCE(Int64)\nVALUE_SYNTAX_INSTANCE(Word16)\nVALUE_SYNTAX_INSTANCE(Word32)\nVALUE_SYNTAX_INSTANCE(Word64)\nVALUE_SYNTAX_INSTANCE(Integer)\nVALUE_SYNTAX_INSTANCE(String)\nVALUE_SYNTAX_INSTANCE(Text)\nVALUE_SYNTAX_INSTANCE(ByteString)\nVALUE_SYNTAX_INSTANCE(LocalTime)\nVALUE_SYNTAX_INSTANCE(UTCTime)\nVALUE_SYNTAX_INSTANCE(Day)\nVALUE_SYNTAX_INSTANCE(TimeOfDay)\nVALUE_SYNTAX_INSTANCE(SqlNull)\nVALUE_SYNTAX_INSTANCE(Double)\nVALUE_SYNTAX_INSTANCE(Bool)\n\ninstance TypeError (PreferExplicitSize Int Int32) => HasSqlValueSyntax Value Int where\n  sqlValueSyntax = Value\n\ninstance TypeError (PreferExplicitSize Word Word32) => HasSqlValueSyntax Value Word where\n  sqlValueSyntax = Value\n\ninstance HasSqlValueSyntax Value x => HasSqlValueSyntax Value (Maybe x) where\n  sqlValueSyntax (Just x) = sqlValueSyntax x\n  sqlValueSyntax Nothing = sqlValueSyntax SqlNull\n\ninstance Eq Value where\n  Value a == Value b =\n    case cast a of\n      Just a\' -> a\' == b\n      Nothing -> False\ninstance Show Value where\n  showsPrec prec (Value a) =\n    showParen (prec > app_prec) $\n    ("Value " ++ ).\n    showsPrec (app_prec + 1) a\n    where app_prec = 10\n\n-- Window functions\n\ndata WindowFrame\n  = WindowFrame\n  { windowFramePartitions :: Maybe [Expression]\n  , windowFrameOrdering   ::  Maybe [Ordering]\n  , windowFrameBounds     :: Maybe WindowFrameBounds\n  } deriving (Show, Eq)\n\ninstance IsSql2003WindowFrameSyntax WindowFrame where\n  type Sql2003WindowFrameExpressionSyntax WindowFrame = Expression\n  type Sql2003WindowFrameOrderingSyntax WindowFrame = Ordering\n  type Sql2003WindowFrameBoundsSyntax WindowFrame = WindowFrameBounds\n\n  frameSyntax = WindowFrame\n\ndata WindowFrameBounds\n  = WindowFrameBounds\n  { boundsFrom :: WindowFrameBound\n  , boundsTo   :: Maybe WindowFrameBound\n  } deriving (Show, Eq)\n\ninstance IsSql2003WindowFrameBoundsSyntax WindowFrameBounds where\n  type Sql2003WindowFrameBoundsBoundSyntax WindowFrameBounds = WindowFrameBound\n\n  fromToBoundSyntax = WindowFrameBounds\n\ndata WindowFrameBound\n  = WindowFrameUnbounded\n  | WindowFrameBoundNRows Int\n  deriving (Show, Eq)\n\ninstance IsSql2003WindowFrameBoundSyntax WindowFrameBound where\n  unboundedSyntax = WindowFrameUnbounded\n  nrowsBoundSyntax = WindowFrameBoundNRows\n\n'