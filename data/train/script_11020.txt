b'\xef\xbb\xbfusing Kerberos.NET.Crypto;\nusing System.Security.Cryptography;\n\nnamespace Rubeus {\n\n    public class KDCKeyAgreement {\n\n        public byte[] P { get { return Oakley.Group14.Prime; } }\n        public byte[] G { get { return Oakley.Group14.Generator; } }\n        public byte[] Q { get { return Oakley.Group14.Factor; } }\n        public byte[] Y {get { return diffieHellman.PublicKey.PublicComponent; } }\n\n        ManagedDiffieHellmanOakley14 diffieHellman = new ManagedDiffieHellmanOakley14();\n\n        public KDCKeyAgreement() {                   \n        }\n\n        private static byte[] CalculateIntegrity(byte count, byte[] data) {\n\n            byte[] input = new byte[data.Length + 1];\n            input[0] = count;\n            data.CopyTo(input, 1);\n\n            using (SHA1CryptoServiceProvider sha1 = new SHA1CryptoServiceProvider()) { \n                return sha1.ComputeHash(input);\n            }            \n        }\n\n        private static byte[] kTruncate(int k, byte[] x) {\n\n            int numberOfBytes = k;\n            byte[] result = new byte[numberOfBytes];\n\n            int count = 0;\n            byte[] filler = CalculateIntegrity((byte)count, x);\n\n            int position = 0;\n\n            for (int i = 0; i < numberOfBytes; i++) {\n                if (position < filler.Length) {\n                    result[i] = filler[position];\n                    position++;\n                } else {\n                    count++;\n                    filler = CalculateIntegrity((byte)count, x);\n                    position = 0;\n                    result[i] = filler[position];\n                    position++;\n                }\n            }\n\n            return result;\n        }\n  \n        public byte[] GenerateKey(byte[] otherPublicKey, byte[] clientNonce, byte[] serverNonce, int size) {\n\n            DiffieHellmanKey diffieHellmanKey = new DiffieHellmanKey();\n            diffieHellmanKey.PublicComponent = otherPublicKey;\n            diffieHellmanKey.KeyLength = otherPublicKey.Length;\n            diffieHellmanKey.Type = AsymmetricKeyType.Public;\n\n            diffieHellman.ImportPartnerKey(diffieHellmanKey);\n            byte[] sharedSecret = diffieHellman.GenerateAgreement();\n        \n            byte[] x = new byte[sharedSecret.Length + clientNonce.Length + serverNonce.Length];\n\n            sharedSecret.CopyTo(x, 0);\n            clientNonce.CopyTo(x, sharedSecret.Length);\n            serverNonce.CopyTo(x, sharedSecret.Length + clientNonce.Length);                    \n          \n            return kTruncate(size, x);\n        }\n    }\n}\n'