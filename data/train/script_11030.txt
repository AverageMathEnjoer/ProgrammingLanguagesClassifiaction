b'package com.naman14.timber.widgets;\n\nimport android.content.Context;\nimport android.content.res.TypedArray;\nimport android.graphics.Bitmap;\nimport android.graphics.BitmapShader;\nimport android.graphics.Canvas;\nimport android.graphics.Color;\nimport android.graphics.ColorFilter;\nimport android.graphics.Matrix;\nimport android.graphics.Paint;\nimport android.graphics.RectF;\nimport android.graphics.Shader;\nimport android.graphics.drawable.BitmapDrawable;\nimport android.graphics.drawable.ColorDrawable;\nimport android.graphics.drawable.Drawable;\nimport android.net.Uri;\nimport androidx.annotation.ColorRes;\nimport androidx.annotation.DrawableRes;\nimport androidx.core.content.ContextCompat;\nimport android.util.AttributeSet;\nimport android.widget.ImageView;\n\nimport com.naman14.timber.R;\n\npublic class CircleImageView extends ImageView {\n\n    private static final ScaleType SCALE_TYPE = ScaleType.CENTER_CROP;\n\n    private static final Bitmap.Config BITMAP_CONFIG = Bitmap.Config.ARGB_8888;\n    private static final int COLORDRAWABLE_DIMENSION = 2;\n\n    private static final int DEFAULT_BORDER_WIDTH = 0;\n    private static final int DEFAULT_BORDER_COLOR = Color.BLACK;\n    private static final boolean DEFAULT_BORDER_OVERLAY = false;\n\n    private final RectF mDrawableRect = new RectF();\n    private final RectF mBorderRect = new RectF();\n\n    private final Matrix mShaderMatrix = new Matrix();\n    private final Paint mBitmapPaint = new Paint();\n    private final Paint mBorderPaint = new Paint();\n\n    private int mBorderColor = DEFAULT_BORDER_COLOR;\n    private int mBorderWidth = DEFAULT_BORDER_WIDTH;\n\n    private Bitmap mBitmap;\n    private BitmapShader mBitmapShader;\n    private int mBitmapWidth;\n    private int mBitmapHeight;\n\n    private float mDrawableRadius;\n    private float mBorderRadius;\n\n    private ColorFilter mColorFilter;\n\n    private boolean mReady;\n    private boolean mSetupPending;\n    private boolean mBorderOverlay;\n\n    public CircleImageView(Context context) {\n        super(context);\n\n        init();\n    }\n\n    public CircleImageView(Context context, AttributeSet attrs) {\n        this(context, attrs, 0);\n    }\n\n    public CircleImageView(Context context, AttributeSet attrs, int defStyle) {\n        super(context, attrs, defStyle);\n\n        TypedArray a = context.obtainStyledAttributes(attrs, R.styleable.CircleImageView, defStyle, 0);\n\n        mBorderWidth = a.getDimensionPixelSize(R.styleable.CircleImageView_border_width, DEFAULT_BORDER_WIDTH);\n        mBorderColor = a.getColor(R.styleable.CircleImageView_border_color, DEFAULT_BORDER_COLOR);\n        mBorderOverlay = a.getBoolean(R.styleable.CircleImageView_border_overlay, DEFAULT_BORDER_OVERLAY);\n\n        a.recycle();\n\n        init();\n    }\n\n    private void init() {\n        super.setScaleType(SCALE_TYPE);\n        mReady = true;\n\n        if (mSetupPending) {\n            setup();\n            mSetupPending = false;\n        }\n    }\n\n    @Override\n    public ScaleType getScaleType() {\n        return SCALE_TYPE;\n    }\n\n    @Override\n    public void setScaleType(ScaleType scaleType) {\n        if (scaleType != SCALE_TYPE) {\n            throw new IllegalArgumentException(String.format("ScaleType %s not supported.", scaleType));\n        }\n    }\n\n    @Override\n    public void setAdjustViewBounds(boolean adjustViewBounds) {\n        if (adjustViewBounds) {\n            throw new IllegalArgumentException("adjustViewBounds not supported.");\n        }\n    }\n\n    @Override\n    protected void onDraw(Canvas canvas) {\n        if (getDrawable() == null) {\n            return;\n        }\n\n        canvas.drawCircle(getWidth() / 2, getHeight() / 2, mDrawableRadius, mBitmapPaint);\n        if (mBorderWidth != 0) {\n            canvas.drawCircle(getWidth() / 2, getHeight() / 2, mBorderRadius, mBorderPaint);\n        }\n    }\n\n    @Override\n    protected void onSizeChanged(int w, int h, int oldw, int oldh) {\n        super.onSizeChanged(w, h, oldw, oldh);\n        setup();\n    }\n\n    public int getBorderColor() {\n        return mBorderColor;\n    }\n\n    public void setBorderColor(int borderColor) {\n        if (borderColor == mBorderColor) {\n            return;\n        }\n\n        mBorderColor = borderColor;\n        mBorderPaint.setColor(mBorderColor);\n        invalidate();\n    }\n\n    public void setBorderColorResource(@ColorRes int borderColorRes) {\n        setBorderColor(ContextCompat.getColor(getContext(), borderColorRes));\n    }\n\n    public int getBorderWidth() {\n        return mBorderWidth;\n    }\n\n    public void setBorderWidth(int borderWidth) {\n        if (borderWidth == mBorderWidth) {\n            return;\n        }\n\n        mBorderWidth = borderWidth;\n        setup();\n    }\n\n    public boolean isBorderOverlay() {\n        return mBorderOverlay;\n    }\n\n    public void setBorderOverlay(boolean borderOverlay) {\n        if (borderOverlay == mBorderOverlay) {\n            return;\n        }\n\n        mBorderOverlay = borderOverlay;\n        setup();\n    }\n\n    @Override\n    public void setImageBitmap(Bitmap bm) {\n        super.setImageBitmap(bm);\n        mBitmap = bm;\n        setup();\n    }\n\n    @Override\n    public void setImageDrawable(Drawable drawable) {\n        super.setImageDrawable(drawable);\n        mBitmap = getBitmapFromDrawable(drawable);\n        setup();\n    }\n\n    @Override\n    public void setImageResource(@DrawableRes int resId) {\n        super.setImageResource(resId);\n        mBitmap = getBitmapFromDrawable(getDrawable());\n        setup();\n    }\n\n    @Override\n    public void setImageURI(Uri uri) {\n        super.setImageURI(uri);\n        mBitmap = getBitmapFromDrawable(getDrawable());\n        setup();\n    }\n\n    @Override\n    public void setColorFilter(ColorFilter cf) {\n        if (cf == mColorFilter) {\n            return;\n        }\n\n        mColorFilter = cf;\n        mBitmapPaint.setColorFilter(mColorFilter);\n        invalidate();\n    }\n\n    private Bitmap getBitmapFromDrawable(Drawable drawable) {\n        if (drawable == null) {\n            return null;\n        }\n\n        if (drawable instanceof BitmapDrawable) {\n            return ((BitmapDrawable) drawable).getBitmap();\n        }\n\n        try {\n            Bitmap bitmap;\n\n            if (drawable instanceof ColorDrawable) {\n                bitmap = Bitmap.createBitmap(COLORDRAWABLE_DIMENSION, COLORDRAWABLE_DIMENSION, BITMAP_CONFIG);\n            } else {\n                bitmap = Bitmap.createBitmap(drawable.getIntrinsicWidth(), drawable.getIntrinsicHeight(), BITMAP_CONFIG);\n            }\n\n            Canvas canvas = new Canvas(bitmap);\n            drawable.setBounds(0, 0, canvas.getWidth(), canvas.getHeight());\n            drawable.draw(canvas);\n            return bitmap;\n        } catch (OutOfMemoryError e) {\n            return null;\n        }\n    }\n\n    private void setup() {\n        if (!mReady) {\n            mSetupPending = true;\n            return;\n        }\n\n        if (mBitmap == null) {\n            return;\n        }\n\n        mBitmapShader = new BitmapShader(mBitmap, Shader.TileMode.CLAMP, Shader.TileMode.CLAMP);\n\n        mBitmapPaint.setAntiAlias(true);\n        mBitmapPaint.setShader(mBitmapShader);\n\n        mBorderPaint.setStyle(Paint.Style.STROKE);\n        mBorderPaint.setAntiAlias(true);\n        mBorderPaint.setColor(mBorderColor);\n        mBorderPaint.setStrokeWidth(mBorderWidth);\n\n        mBitmapHeight = mBitmap.getHeight();\n        mBitmapWidth = mBitmap.getWidth();\n\n        mBorderRect.set(0, 0, getWidth(), getHeight());\n        mBorderRadius = Math.min((mBorderRect.height() - mBorderWidth) / 2, (mBorderRect.width() - mBorderWidth) / 2);\n\n        mDrawableRect.set(mBorderRect);\n        if (!mBorderOverlay) {\n            mDrawableRect.inset(mBorderWidth, mBorderWidth);\n        }\n        mDrawableRadius = Math.min(mDrawableRect.height() / 2, mDrawableRect.width() / 2);\n\n        updateShaderMatrix();\n        invalidate();\n    }\n\n    private void updateShaderMatrix() {\n        float scale;\n        float dx = 0;\n        float dy = 0;\n\n        mShaderMatrix.set(null);\n\n        if (mBitmapWidth * mDrawableRect.height() > mDrawableRect.width() * mBitmapHeight) {\n            scale = mDrawableRect.height() / (float) mBitmapHeight;\n            dx = (mDrawableRect.width() - mBitmapWidth * scale) * 0.5f;\n        } else {\n            scale = mDrawableRect.width() / (float) mBitmapWidth;\n            dy = (mDrawableRect.height() - mBitmapHeight * scale) * 0.5f;\n        }\n\n        mShaderMatrix.setScale(scale, scale);\n        mShaderMatrix.postTranslate((int) (dx + 0.5f) + mDrawableRect.left, (int) (dy + 0.5f) + mDrawableRect.top);\n\n        mBitmapShader.setLocalMatrix(mShaderMatrix);\n    }\n\n}\n'