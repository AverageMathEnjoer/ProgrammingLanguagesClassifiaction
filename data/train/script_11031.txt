b'/*\r\n  Barometer library V1.0\r\n  2010 Copyright (c) Seeed Technology Inc.  All right reserved.\r\n \r\n  Original Author: LG\r\n  \r\n  This library is free software; you can redistribute it and/or\r\n  modify it under the terms of the GNU Lesser General Public\r\n  License as published by the Free Software Foundation; either\r\n  version 2.1 of the License, or (at your option) any later version.\r\n\r\n  This library is distributed in the hope that it will be useful,\r\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n  Lesser General Public License for more details.\r\n\r\n  You should have received a copy of the GNU Lesser General Public\r\n  License along with this library; if not, write to the Free Software\r\n  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\r\n*/\r\n#include "BMP180.h"\r\n#include <Wire.h>\r\n#include <Arduino.h>\r\n\r\nvoid BMP180::init(void)\r\n{\r\n    Wire.begin();\r\n    ac1 = bmp180ReadInt(0xAA);\r\n    ac2 = bmp180ReadInt(0xAC);\r\n    ac3 = bmp180ReadInt(0xAE);\r\n    ac4 = bmp180ReadInt(0xB0);\r\n    ac5 = bmp180ReadInt(0xB2);\r\n    ac6 = bmp180ReadInt(0xB4);\r\n    b1 = bmp180ReadInt(0xB6);\r\n    b2 = bmp180ReadInt(0xB8);\r\n    mb = bmp180ReadInt(0xBA);\r\n    mc = bmp180ReadInt(0xBC);\r\n    md = bmp180ReadInt(0xBE);\r\n}\r\n// Read 1 byte from the BMP085 at \'address\'\r\n// Return: the read byte;\r\nchar BMP180::bmp180Read(unsigned char address)\r\n{\r\n    //Wire.begin();\r\n    unsigned char data;\r\n    Wire.beginTransmission(BMP180_ADDRESS);\r\n    Wire.write(address);\r\n    Wire.endTransmission();\r\n\r\n    Wire.requestFrom(BMP180_ADDRESS, 1);\r\n    while(!Wire.available());\r\n    return Wire.read();\r\n}\r\n// Read 2 bytes from the BMP085\r\n// First byte will be from \'address\'\r\n// Second byte will be from \'address\'+1\r\nint BMP180::bmp180ReadInt(unsigned char address)\r\n{\r\n    unsigned char msb, lsb;\r\n    Wire.beginTransmission(BMP180_ADDRESS);\r\n    Wire.write(address);\r\n    Wire.endTransmission();\r\n    Wire.requestFrom(BMP180_ADDRESS, 2);\r\n    while(Wire.available()<2);\r\n    msb = Wire.read();\r\n    lsb = Wire.read();\r\n    return (int) msb<<8 | lsb;\r\n}\r\n// Read the uncompensated temperature value\r\nunsigned int BMP180::bmp180ReadUT()\r\n{\r\n  unsigned int ut;\r\n  Wire.beginTransmission(BMP180_ADDRESS);\r\n  Wire.write(0xF4);\r\n  Wire.write(0x2E);\r\n  Wire.endTransmission();\r\n  delay(5);\r\n  ut = bmp180ReadInt(0xF6);\r\n  return ut;\r\n}\r\n// Read the uncompensated pressure value\r\nunsigned long BMP180::bmp180ReadUP()\r\n{\r\n    unsigned char msb, lsb, xlsb;\r\n    unsigned long up = 0;\r\n    Wire.beginTransmission(BMP180_ADDRESS);\r\n    Wire.write(0xF4);\r\n    Wire.write(0x34 + (OSS<<6));\r\n    Wire.endTransmission();\r\n    delay(2 + (3<<OSS));\r\n\r\n    // Read register 0xF6 (MSB), 0xF7 (LSB), and 0xF8 (XLSB)\r\n    msb = bmp180Read(0xF6);\r\n    lsb = bmp180Read(0xF7);\r\n    xlsb = bmp180Read(0xF8);\r\n    up = (((unsigned long) msb << 16) | ((unsigned long) lsb << 8) | (unsigned long) xlsb) >> (8-OSS);\r\n    return up;\r\n}\r\nvoid BMP180::writeRegister(int deviceAddress, byte address, byte val)\r\n{\r\n    Wire.beginTransmission(deviceAddress); // start transmission to device \r\n    Wire.write(address);       // send register address\r\n    Wire.write(val);         // send value to write\r\n    Wire.endTransmission();     // end transmission\r\n}\r\nint BMP180::readRegister(int deviceAddress, byte address)\r\n{\r\n    int v;\r\n    Wire.beginTransmission(deviceAddress);\r\n    Wire.write(address); // register to read\r\n    Wire.endTransmission();\r\n\r\n    Wire.requestFrom(deviceAddress, 1); // read a byte\r\n\r\n    while(!Wire.available()) {\r\n    // waiting\r\n    }\r\n\r\n    v = Wire.read();\r\n    return v;\r\n}\r\nfloat BMP180::calcAltitude(float pressure)\r\n{\r\n    float A = pressure/101325;\r\n    float B = 1/5.25588;\r\n    float C = pow(A,B);\r\n    C = 1 - C;\r\n    C = C /0.0000225577;\r\n    return C;\r\n}\r\nfloat BMP180::bmp180GetTemperature(unsigned int ut)\r\n{\r\n    long x1, x2;\r\n\r\n    x1 = (((long)ut - (long)ac6)*(long)ac5) >> 15;\r\n    x2 = ((long)mc << 11)/(x1 + md);\r\n    PressureCompensate = x1 + x2;\r\n\r\n    float temp = ((PressureCompensate + 8)>>4);\r\n    temp = temp /10;\r\n\r\n    return temp;\r\n}\r\nlong BMP180::bmp180GetPressure(unsigned long up)\r\n{\r\n    long x1, x2, x3, b3, b6, p;\r\n    unsigned long b4, b7;\r\n    b6 = PressureCompensate - 4000;\r\n    x1 = (b2 * (b6 * b6)>>12)>>11;\r\n    x2 = (ac2 * b6)>>11;\r\n    x3 = x1 + x2;\r\n    b3 = (((((long)ac1)*4 + x3)<<OSS) + 2)>>2;\r\n\r\n    // Calculate B4\r\n    x1 = (ac3 * b6)>>13;\r\n    x2 = (b1 * ((b6 * b6)>>12))>>16;\r\n    x3 = ((x1 + x2) + 2)>>2;\r\n    b4 = (ac4 * (unsigned long)(x3 + 32768))>>15;\r\n\r\n    b7 = ((unsigned long)(up - b3) * (50000>>OSS));\r\n    if (b7 < 0x80000000)\r\n    p = (b7<<1)/b4;\r\n    else\r\n    p = (b7/b4)<<1;\r\n\r\n    x1 = (p>>8) * (p>>8);\r\n    x1 = (x1 * 3038)>>16;\r\n    x2 = (-7357 * p)>>16;\r\n    p += (x1 + x2 + 3791)>>4;\r\n\r\n    long temp = p;\r\n    return temp;\r\n}\r\n\r\n'