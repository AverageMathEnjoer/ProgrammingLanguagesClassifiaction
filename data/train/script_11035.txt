b'#include "stdafx.h"\n#include "../AssetsTools/ClassDatabaseFile.h"\n#include "../AssetsTools/AssetsFileReader.h"\n#include "../AssetsTools/AssetTypeClass.h"\n#include "../libCompression/lz4.h"\n#include "..\\inc\\LZMA\\LzmaLib.h"\n#define WIN32_LEAN_AND_MEAN\n#define NOMINMAX\n#include <Windows.h>\n#include <WinCrypt.h>\n#pragma comment(lib, "Advapi32.lib")\n\nASSETSTOOLS_API const char *ClassDatabaseFileString::GetString(ClassDatabaseFile *pFile)\n{\n\tif (!fromStringTable)\n\t\treturn str.string;\n\tif (str.stringTableOffset >= pFile->header.stringTableLen)\n\t\treturn "";\n\treturn &pFile->stringTable[str.stringTableOffset];\n}\nASSETSTOOLS_API QWORD ClassDatabaseFileString::Read(IAssetsReader *pReader, QWORD filePos)\n{\n\tfromStringTable = true;\n\tpReader->Read(filePos, 4, &str.stringTableOffset);\n\treturn (filePos+4);\n}\nASSETSTOOLS_API QWORD ClassDatabaseFileString::Write(IAssetsWriter *pWriter, QWORD filePos)\n{\n\tpWriter->Write(filePos, 4, &str.stringTableOffset);\n\treturn (filePos+4);\n}\n\nASSETSTOOLS_API QWORD ClassDatabaseTypeField::Read(IAssetsReader *pReader, QWORD filePos, int version)\n{\n\tfilePos = typeName.Read(pReader, filePos);\n\tfilePos = fieldName.Read(pReader, filePos);\n\tpReader->Read(filePos, 1, &depth); filePos++;\n\tpReader->Read(filePos, 1, &isArray); filePos++;\n\tpReader->Read(filePos, 4, &size); filePos+=4;\n\tthis->version = 1;\n\tif (version < 1)\n\t{\n\t\tuint32_t index; \n\t\tpReader->Read(filePos, 4, &index); filePos+=4;\n\t\tif (index & 0x80000000)\n\t\t{\n\t\t\tpReader->Read(filePos, 2, &this->version); filePos+=2;\n\t\t}\n\t}\n\telse if (version >= 3)\n\t{\n\t\tpReader->Read(filePos, 2, &this->version); filePos+=2;\n\t}\n\tpReader->Read(filePos, 4, &flags2); filePos+=4;\n\treturn filePos;\n}\nASSETSTOOLS_API QWORD ClassDatabaseTypeField::Write(IAssetsWriter *pWriter, QWORD filePos, int version)\n{\n\tfilePos = typeName.Write(pWriter, filePos);\n\tfilePos = fieldName.Write(pWriter, filePos);\n\tpWriter->Write(filePos, 1, &depth); filePos++;\n\tpWriter->Write(filePos, 1, &isArray); filePos++;\n\tpWriter->Write(filePos, 4, &size); filePos+=4;\n\t//pWriter->Write(filePos, 4, &index); filePos+=4;\n\tif (version >= 3)\n\t{\n\t\tpWriter->Write(filePos, 2, &this->version); filePos+=2;\n\t}\n\tpWriter->Write(filePos, 4, &flags2); filePos+=4;\n\treturn filePos;\n}\n\nASSETSTOOLS_API ClassDatabaseType::ClassDatabaseType()\n{\n\tbaseClass = -1;\n\tclassId = -1;\n\t//ZeroMemory(&name, sizeof(ClassDatabaseFileString));\n\tthis->fields = std::vector<ClassDatabaseTypeField>();\n\tthis->fields.reserve(1);\n}\nASSETSTOOLS_API ClassDatabaseType::ClassDatabaseType(const ClassDatabaseType& other)\n{\n\tbaseClass = other.baseClass;\n\tclassId = other.classId;\n\tmemcpy(&name, &other.name, sizeof(ClassDatabaseFileString));\n\tmemcpy(&assemblyFileName, &other.assemblyFileName, sizeof(ClassDatabaseFileString));\n\tfields.reserve(other.fields.size());\n\tfor (size_t i = 0; i < other.fields.size(); i++)\n\t\tfields.push_back(ClassDatabaseTypeField(other.fields[i]));\n}\nclass AssetTypeTemplateField;\nint _RecursiveAddTemplateFieldToClassDatabase(std::vector<ClassDatabaseTypeField> &list, uint8_t depth, AssetTypeTemplateField *pTemplate)\n{\n\tlist.resize(list.size() + 1);\n\tClassDatabaseTypeField &ownField = list[list.size() - 1];\n\townField.fieldName.fromStringTable = false;\n\townField.fieldName.str.string = pTemplate->name.c_str();\n\townField.typeName.fromStringTable = false;\n\townField.typeName.str.string = pTemplate->type.c_str();\n\townField.depth = depth;\n\townField.isArray = pTemplate->isArray;\n\townField.size = 0;\n\tif (pTemplate->isArray & 1)\n\t\townField.size = -1;\n\telse\n\t{\n\t\tswitch (GetValueTypeByTypeName(pTemplate->type.c_str()))\n\t\t{\n\t\t\tcase ValueType_Bool:\n\t\t\tcase ValueType_Int8:\n\t\t\tcase ValueType_UInt8:\n\t\t\t\townField.size = 1;\n\t\t\t\tbreak;\n\t\t\tcase ValueType_Int16:\n\t\t\tcase ValueType_UInt16:\n\t\t\t\townField.size = 2;\n\t\t\t\tbreak;\n\t\t\tcase ValueType_Int32:\n\t\t\tcase ValueType_UInt32:\n\t\t\tcase ValueType_Float:\n\t\t\t\townField.size = 4;\n\t\t\t\tbreak;\n\t\t\tcase ValueType_Int64:\n\t\t\tcase ValueType_UInt64:\n\t\t\tcase ValueType_Double:\n\t\t\t\townField.size = 8;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\townField.size = 0;\n\t\t}\n\t}\n\townField.version = 1;\n\townField.flags2 = pTemplate->align ? 0x4000 : 0;\n\tif (depth < 255)\n\t{\n\t\tfor (uint32_t i = 0; i < pTemplate->children.size(); i++)\n\t\t{\n\t\t\tint curSize = _RecursiveAddTemplateFieldToClassDatabase(list, depth + 1, &pTemplate->children[i]);\n\t\t\tif (!(ownField.isArray & 1) && (ownField.size != -1))\n\t\t\t{\n\t\t\t\tif (curSize == -1)\n\t\t\t\t\townField.size = -1;\n\t\t\t\telse\n\t\t\t\t\townField.size += curSize;\n\t\t\t}\n\t\t}\n\t}\n\treturn ownField.size;\n}\nASSETSTOOLS_API bool ClassDatabaseType::FromTemplateField(int classId, int baseClass, AssetTypeTemplateField *pTemplateBase)\n{\n\tif (!pTemplateBase) return false;\n\tthis->classId = classId;\n\tthis->baseClass = baseClass;\n\tthis->name.fromStringTable = false;\n\tthis->name.str.string = pTemplateBase->type.c_str();\n\tthis->assemblyFileName.fromStringTable = false;\n\tthis->assemblyFileName.str.string = "";\n\tthis->fields.clear();\n\t_RecursiveAddTemplateFieldToClassDatabase(this->fields, 0, pTemplateBase);\n\treturn true;\n}\nASSETSTOOLS_API ClassDatabaseType::~ClassDatabaseType()\n{\n\t/*if (freeStrings)\n\t{\n\t\tif (!name.fromStringTable && name.str.string != NULL)\n\t\t{\n\t\t\tfree(const_cast<char*>(name.str.string));\n\t\t\tname.str.string = NULL;\n\t\t}\n\t\tif (!assemblyFileName.fromStringTable && assemblyFileName.str.string != NULL)\n\t\t{\n\t\t\tfree(const_cast<char*>(assemblyFileName.str.string));\n\t\t\tassemblyFileName.str.string = NULL;\n\t\t}\n\t\tfor (size_t i = 0; i < fields.size(); i++)\n\t\t{\n\t\t\tClassDatabaseTypeField &field = fields[i];\n\t\t\tif (!field.fieldName.fromStringTable && field.fieldName.str.string != NULL)\n\t\t\t{\n\t\t\t\tfree(const_cast<char*>(field.fieldName.str.string));\n\t\t\t\tfield.fieldName.str.string = NULL;\n\t\t\t}\n\t\t\tif (!field.typeName.fromStringTable && field.typeName.str.string != NULL)\n\t\t\t{\n\t\t\t\tfree(const_cast<char*>(field.typeName.str.string));\n\t\t\t\tfield.typeName.str.string = NULL;\n\t\t\t}\n\t\t}\n\t}*/\n\t//if (this->fields.size() > 0)\n\t//\tthis->fields.clear();\n}\nASSETSTOOLS_API QWORD ClassDatabaseType::Read(IAssetsReader *pReader, QWORD filePos, int version, uint8_t flags)\n{\n\tuint32_t fieldCount;\n\tpReader->Read(filePos, 4, &classId); filePos+=4;\n\tpReader->Read(filePos, 4, &baseClass); filePos+=4;\n\tfilePos = name.Read(pReader, filePos);\n\tif (flags & 1)\n\t\tfilePos = assemblyFileName.Read(pReader, filePos);\n\telse\n\t{\n\t\tassemblyFileName.str.string = NULL;\n\t\tassemblyFileName.fromStringTable = false;\n\t}\n\tpReader->Read(filePos, 4, &fieldCount); filePos+=4;\n\n\t/*fields = (ClassDatabaseTypeField*)malloc(sizeof(ClassDatabaseTypeField) * fieldCount);\n\tif (fields == NULL)\n\t{\n\t\tfor (uint32_t i = 0; i < fieldCount; i++)\n\t\t\tfilePos = ClassDatabaseTypeField().Read(reader, readerPar, filePos);\n\t\tfieldCount = 0;\n\t}\n\tfor (uint32_t i = 0; i < fieldCount; i++)\n\t{\n\t\tfilePos = fields[i].Read(reader, readerPar, filePos);\n\t}*/\n\tfields.reserve(fieldCount);\n\tfor (uint32_t i = 0; i < fieldCount; i++)\n\t{\n\t\tClassDatabaseTypeField field;\n\t\tfilePos = field.Read(pReader, filePos, version);\n\t\tfields.push_back(field);\n\t}\n\treturn filePos;\n}\nASSETSTOOLS_API QWORD ClassDatabaseType::Write(IAssetsWriter *pWriter, QWORD filePos, int version, uint8_t flags)\n{\n\tuint32_t fieldCount = (uint32_t)fields.size();\n\n\tpWriter->Write(filePos, 4, &classId); filePos+=4;\n\tpWriter->Write(filePos, 4, &baseClass); filePos+=4;\n\tfilePos = name.Write(pWriter, filePos);\n\tif (flags & 1)\n\t\tfilePos = assemblyFileName.Write(pWriter, filePos);\n\tpWriter->Write(filePos, 4, &fieldCount); filePos+=4;\n\n\tfor (uint32_t i = 0; i < fieldCount; i++)\n\t{\n\t\tfilePos = fields[i].Write(pWriter, filePos, version);\n\t}\n\treturn filePos;\n}\nASSETSTOOLS_API Hash128 ClassDatabaseType::MakeTypeHash(ClassDatabaseFile *pDatabaseFile)\n{\n\tHash128 ret = {};\n\tHCRYPTPROV hContext;\n\tif (!CryptAcquireContext(&hContext, NULL, NULL, PROV_RSA_FULL, CRYPT_VERIFYCONTEXT))\n\t\treturn ret;\n\tHCRYPTHASH hHash;\n\tif (!CryptCreateHash(hContext, CALG_MD4, 0, 0, &hHash))\n\t{\n\t\tCryptReleaseContext(hContext, 0);\n\t\treturn ret;\n\t}\n\tfor (size_t k = 0; k < fields.size(); k++)\n\t{\n\t\tconst char *typeName = fields[k].typeName.GetString(pDatabaseFile);\n\t\tconst char *fieldName = fields[k].fieldName.GetString(pDatabaseFile);\n\t\tuint32_t size = fields[k].size;\n\t\tuint32_t isArray = fields[k].isArray;\n\t\tuint32_t version = fields[k].version;\n\t\tuint32_t flag = fields[k].flags2 & 0x4000;\n\t\tCryptHashData(hHash, (const uint8_t*)typeName, strlen(typeName), 0);\n\t\tCryptHashData(hHash, (const uint8_t*)fieldName, strlen(fieldName), 0);\n\t\tCryptHashData(hHash, (const uint8_t*)&size, 4, 0);\n\t\tCryptHashData(hHash, (const uint8_t*)&isArray, 4, 0);\n\t\tCryptHashData(hHash, (const uint8_t*)&version, 4, 0);\n\t\tCryptHashData(hHash, (const uint8_t*)&flag, 4, 0);\n\t}\n\tDWORD len = 16;\n\tCryptGetHashParam(hHash, HP_HASHVAL, ret.bValue, &len, 0); //if it returns FALSE, it still needs to be freed\n\tCryptDestroyHash(hHash);\n\tCryptReleaseContext(hContext, 0);\n\treturn ret;\n}\n\nASSETSTOOLS_API Hash128 MakeScriptID(const char *scriptName, const char *scriptNamespace, const char *scriptAssembly)\n{\n\tHash128 ret = {};\n\tHCRYPTPROV hContext;\n\tif (!CryptAcquireContext(&hContext, NULL, NULL, PROV_RSA_FULL, CRYPT_VERIFYCONTEXT))\n\t\treturn ret;\n\tHCRYPTHASH hHash;\n\tif (!CryptCreateHash(hContext, CALG_MD4, 0, 0, &hHash))\n\t{\n\t\tCryptReleaseContext(hContext, 0);\n\t\treturn ret;\n\t}\n\tCryptHashData(hHash, (const uint8_t*)scriptName, strlen(scriptName), 0);\n\tCryptHashData(hHash, (const uint8_t*)scriptNamespace, strlen(scriptNamespace), 0);\n\tCryptHashData(hHash, (const uint8_t*)scriptAssembly, strlen(scriptAssembly), 0);\n\tDWORD len = 16;\n\tCryptGetHashParam(hHash, HP_HASHVAL, ret.bValue, &len, 0); //if it returns FALSE, it still needs to be freed\n\tCryptDestroyHash(hHash);\n\tCryptReleaseContext(hContext, 0);\n\treturn ret;\n}\n\nASSETSTOOLS_API QWORD ClassDatabaseFileHeader::Read(IAssetsReader *pReader, QWORD filePos)\n{\n\tif (!pReader->Read(filePos, 4, header))\n\t\treturn 0;\n\tif (memcmp(header, "cldb", 4))\n\t\treturn 0;\n\tfilePos += 4;\n\tpReader->Read(filePos, 1, &fileVersion); filePos++;\n\tif (fileVersion >= 4)\n\t{\n\t\tpReader->Read(filePos, 1, &flags); filePos++;\n\t}\n\telse\n\t\tflags = 0;\n\tif (fileVersion >= 2)\n\t{\n\t\tpReader->Read(filePos, 1, &compressionType); filePos++;\n\t\tpReader->Read(filePos, 4, &compressedSize); filePos+=4;\n\t\tpReader->Read(filePos, 4, &uncompressedSize); filePos+=4;\n\t}\n\telse\n\t{\n\t\tcompressionType = 0;\n\t\tcompressedSize = uncompressedSize = 0;\n\t}\n\tif (fileVersion == 0)\n\t{\n\t\tuint8_t assetsVersionCount;\n\t\tpReader->Read(filePos, 1, &assetsVersionCount); filePos++;\n\t\tfilePos += assetsVersionCount;\n\t}\n\telse\n\t{\n\t\tpReader->Read(filePos, 1, &unityVersionCount); filePos++;\n\t\tQWORD firstVersionPos = filePos;\n\t\tsize_t bufferLen = unityVersionCount * sizeof(char*);\n\t\tfor (uint32_t i = 0; i < unityVersionCount; i++)\n\t\t{\n\t\t\tuint8_t byTmp;\n\t\t\tpReader->Read(filePos, 1, &byTmp); filePos++;\n\t\t\tfilePos += byTmp;\n\t\t\tbufferLen += (byTmp+1); //plus null-terminator\n\t\t}\n\t\tQWORD postVersionPos = filePos;\n\t\tpUnityVersions = (char**)malloc(bufferLen);\n\t\tif (pUnityVersions != NULL)\n\t\t{\n\t\t\tsize_t bufferPos = unityVersionCount * sizeof(char*);\n\t\t\tfilePos = firstVersionPos;\n\t\t\tfor (uint32_t i = 0; i < unityVersionCount; i++)\n\t\t\t{\n\t\t\t\tchar *charBuffer = &((char*)pUnityVersions)[bufferPos];\n\t\t\t\tpUnityVersions[i] = charBuffer;\n\t\t\t\tuint8_t byTmp;\n\t\t\t\tpReader->Read(filePos, 1, &byTmp); filePos++;\n\t\t\t\tpReader->Read(filePos, byTmp, charBuffer);\n\t\t\t\tcharBuffer[byTmp] = 0;\n\t\t\t\tfilePos += byTmp;\n\t\t\t\tbufferPos += (byTmp+1); //plus null-terminator\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\tunityVersionCount = 0;\n\n\t}\n\tpReader->Read(filePos, 4, &stringTableLen); filePos+=4;\n\tpReader->Read(filePos, 4, &stringTablePos); filePos+=4;\n\treturn filePos;\n}\nASSETSTOOLS_API QWORD ClassDatabaseFileHeader::Write(IAssetsWriter *pWriter, QWORD filePos)\n{\n\tpWriter->Write(filePos, 4, "cldb"); filePos += 4;\n\tpWriter->Write(filePos, 1, &fileVersion); filePos++;\n\tif (fileVersion >= 4)\n\t{\n\t\tpWriter->Write(filePos, 1, &flags); filePos++;\n\t}\n\tif (fileVersion >= 2)\n\t{\n\t\tpWriter->Write(filePos, 1, &compressionType); filePos++;\n\t\tpWriter->Write(filePos, 4, &compressedSize); filePos+=4;\n\t\tpWriter->Write(filePos, 4, &uncompressedSize); filePos+=4;\n\t}\n\tpWriter->Write(filePos, 1, &unityVersionCount); filePos++;\n\tfor (uint32_t i = 0; i < unityVersionCount; i++)\n\t{\n\t\tuint8_t byTmp = (uint8_t)strlen(pUnityVersions[i]);\n\t\tpWriter->Write(filePos, 1, &byTmp); filePos++;\n\t\tpWriter->Write(filePos, byTmp, pUnityVersions[i]); filePos+=byTmp;\n\t}\n\tpWriter->Write(filePos, 4, &stringTableLen); filePos+=4;\n\tpWriter->Write(filePos, 4, &stringTablePos); filePos+=4;\n\treturn filePos;\n}\n\nASSETSTOOLS_API QWORD ClassDatabaseFile::Read(IAssetsReader *pReader, QWORD filePos)\n{\n\tvalid = false;\n\tthis->dontFreeStringTable = false;\n\tchar *uncompressedBuf = NULL;\n\tQWORD _filePos = header.Read(pReader, filePos);\n\tif (_filePos == filePos)\n\t\treturn filePos;\n\tfilePos = _filePos;\n\tQWORD postHeaderPos = filePos;\n\tQWORD compressedFilePos = filePos;\n\t\n\tif (header.compressionType && header.compressionType < 3)\n\t{\n\t\tchar *compressedBuf = (char*)malloc(header.compressedSize);\n\t\tif (!compressedBuf)\n\t\t\treturn postHeaderPos + header.compressedSize;\n\t\tif (pReader->Read(filePos, header.compressedSize, compressedBuf) != header.compressedSize)\n\t\t{\n\t\t\tfree(compressedBuf);\n\t\t\treturn postHeaderPos + header.compressedSize;\n\t\t}\n\t\tcompressedFilePos = filePos + header.compressedSize;\n\t\t//add 1 to see if it decompresses more bytes than the header says there are\n\t\tuncompressedBuf = (char*)malloc(header.uncompressedSize + 1);\n\t\tif (!uncompressedBuf)\n\t\t{\n\t\t\tfree(compressedBuf);\n\t\t\treturn postHeaderPos + header.compressedSize;\n\t\t}\n\t\tuint32_t uncompressedSize = 0;\n\t\tif (header.compressionType == 1)\n\t\t{\n#ifdef _WITHOUT_LZ4\n\t\t\tfree(compressedBuf);\n\t\t\treturn postHeaderPos + header.compressedSize;\n#else\n\t\t\tuncompressedSize = (uint32_t)LZ4_decompress_safe(compressedBuf, uncompressedBuf, header.compressedSize, header.uncompressedSize + 1);\n#endif\n\t\t}\n\t\telse if (header.compressionType == 2 && header.compressedSize > LZMA_PROPS_SIZE)\n\t\t{\n\t\t\tsize_t lz_uncompressedSize = header.uncompressedSize;\n\t\t\tsize_t compressedWithoutProps = header.compressedSize - LZMA_PROPS_SIZE;\n\t\t\tint result = LzmaUncompress((Byte*)uncompressedBuf, &lz_uncompressedSize,\n\t\t\t\t(Byte*)&compressedBuf[LZMA_PROPS_SIZE], &compressedWithoutProps,\n\t\t\t\t(Byte*)compressedBuf, LZMA_PROPS_SIZE);\n\t\t\tif (result == SZ_OK)\n\t\t\t\tuncompressedSize = (uint32_t)lz_uncompressedSize;\n\t\t}\n\t\tfree(compressedBuf);\n\t\tif (uncompressedSize != header.uncompressedSize)\n\t\t{\n\t\t\tfree(uncompressedBuf);\n\t\t\treturn postHeaderPos + header.compressedSize;\n\t\t}\n\t\tpReader = Create_AssetsReaderFromMemory(uncompressedBuf, header.uncompressedSize, false);\n\t\tif (pReader == NULL)\n\t\t{\n\t\t\tfree(uncompressedBuf);\n\t\t\treturn postHeaderPos + header.compressedSize;\n\t\t}\n\t\tfilePos = 0;\n\t}\n\n\tuint32_t classCount;\n\tpReader->Read(filePos, 4, &classCount); filePos += 4;\n\tclasses.clear();\n\tclasses.resize(classCount);\n\tfor (uint32_t i = 0; i < classCount; i++)\n\t{\n\t\tfilePos = classes[i].Read(pReader, filePos, header.fileVersion, header.flags);\n\t}\n\t/*classes = (ClassDatabaseType*)malloc(sizeof(ClassDatabaseType) * classCount);\n\tif (classes == NULL)\n\t{\n\t\tfor (uint32_t i = 0; i < classCount; i++)\n\t\t\tfilePos = ClassDatabaseType().Read(reader, readerPar, filePos);\n\t\tclassCount = 0;\n\t}\n\tfor (uint32_t i = 0; i < classCount; i++)\n\t{\n\t\tfilePos = classes[i].Read(reader, readerPar, filePos);\n\t}*/\n\n\tstringTable = (char*)malloc((header.stringTableLen + 1) * sizeof(char));\n\tif (stringTable == NULL)\n\t{\n\t\tif (uncompressedBuf)\n\t\t{\n\t\t\tFree_AssetsReader(pReader);\n\t\t\tfree(uncompressedBuf);\n\t\t}\n\t\treturn postHeaderPos + header.compressedSize;\n\t}\n\tif (pReader->Read(header.stringTablePos, header.stringTableLen, stringTable) != header.stringTableLen)\n\t{\n\t\tif (uncompressedBuf)\n\t\t{\n\t\t\tFree_AssetsReader(pReader);\n\t\t\tfree(uncompressedBuf);\n\t\t}\n\t\treturn postHeaderPos + header.compressedSize;\n\t}\n\tstringTable[header.stringTableLen] = 0;\n\tfilePos += header.stringTableLen;\n\t\n\tif (uncompressedBuf)\n\t{\n\t\tFree_AssetsReader(pReader);\n\t\tfree(uncompressedBuf);\n\t}\n\n\tvalid = true;\n\treturn postHeaderPos + header.compressedSize;\n}\nASSETSTOOLS_API bool ClassDatabaseFile::Read(IAssetsReader *pReader)\n{\n\tRead(pReader, 0ULL);\n\treturn valid;\n}\n\nenum EStringTableWriter_AddString_OptModes\n{\n\t//better result without AddStringsOptimized and less memory overhead but slower than hash table\n\tStringTableWriter_Opt_LinearSearch, \n\t//memory overhead of 512KiB(32)/1MiB(64) + sizeof(size_t) * stringCount; only better than linear with AddStringsOptimized called before\n\tStringTableWriter_Opt_HashTableSearch,\n};\nstruct StringTableOptTmp\n{\n\tsize_t strLen;\n\tconst char *str;\n\tStringTableOptTmp *parent;\n};\nstruct StringTableHashEntryTmp\n{\n\tsize_t matchCount;\n\tStringTableOptTmp **matches;\n};\nclass StringTableWriter\n{\n\tchar *stringTable;\n\tsize_t stringTableBufferLen;\n\tsize_t stringTableLen;\n\t//EStringTableWriter_AddString_OptModes optMode;\n\tstruct StringTableHashEntry\n\t{\n\t\tsize_t matchCount;\n\t\tsize_t *matches; //offsets into stringTable\n\t}* stringHashTable; //only for making AddString optimization faster (searching for double entries)\npublic:\n\tStringTableWriter(EStringTableWriter_AddString_OptModes optMode = StringTableWriter_Opt_LinearSearch)\n\t{\n\t\tstringTable = NULL;\n\t\tstringTableLen = stringTableBufferLen = 0;\n\t\t//this->optMode = optMode;\n\t\tif (optMode == StringTableWriter_Opt_HashTableSearch)\n\t\t{\n\t\t\tstringHashTable = (StringTableHashEntry*)malloc(sizeof(StringTableHashEntry) * (MAXWORD+1)); //1 MiB\n\t\t\tmemset(stringHashTable, 0, sizeof(StringTableHashEntry) * (MAXWORD+1));\n\t\t}\n\t\telse\n\t\t{\n\t\t\tstringHashTable = NULL;\n\t\t}\n\t}\n\t//linear only\n\tStringTableWriter(char *stringTable, size_t stringTableLen)\n\t{\n\t\tthis->stringTable = stringTable;\n\t\tthis->stringTableLen = this->stringTableBufferLen = stringTableLen;\n\t\tthis->stringHashTable = NULL;\n\t}\n\t~StringTableWriter()\n\t{\n\t\tif (stringHashTable)\n\t\t\tfree(stringHashTable);\n\t}\n\t//a small bit smaller stringtables than only AddStrings (1260485 vs. 1261082 Bytes) but A LOT slower (~0:02 vs. ~1:35)\n\tbool AddStringsOptimized(const char **strings, size_t count)\n\t{\n\t\tsize_t stringCount = count;\n\t\tStringTableHashEntryTmp *_TmpStringHashTable = NULL;\n\t\t//StringTableHashEntryTmp *_TmpStringHashTable = (StringTableHashEntryTmp*)malloc(sizeof(StringTableHashEntryTmp) * (MAXWORD+1)); //1 MiB\n\t\t//memset(_TmpStringHashTable, 0, sizeof(StringTableHashEntryTmp) * (MAXWORD+1));\n\t\tStringTableOptTmp *_TmpStringTable = (StringTableOptTmp*)malloc(sizeof(StringTableOptTmp) * stringCount);\n\t\tif (_TmpStringTable)\n\t\t{\n\t\t\tif (!_TmpStringHashTable)\n\t\t\t{\n\t\t\t\tsize_t curStringIndex = 0;\n\t\t\t\tfor (uint32_t i = 0; i < stringCount; i++)\n\t\t\t\t{\n\t\t\t\t\t_TmpStringTable[curStringIndex].str = strings[i];\n\t\t\t\t\t_TmpStringTable[curStringIndex].strLen = (_TmpStringTable[curStringIndex].str ? strlen(_TmpStringTable[curStringIndex].str) : 0);\n\t\t\t\t\t_TmpStringTable[curStringIndex].parent = NULL;\n\t\t\t\t\tcurStringIndex++;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tsize_t curStringIndex = 0;\n\t\t\t\tfor (uint32_t i = 0; i < stringCount; i++)\n\t\t\t\t{\n\t\t\t\t\t_TmpStringTable[curStringIndex].str = strings[i];\n\t\t\t\t\t_TmpStringTable[curStringIndex].strLen = (_TmpStringTable[curStringIndex].str ? strlen(_TmpStringTable[curStringIndex].str) : 0);\n\t\t\t\t\t_TmpStringTable[curStringIndex].parent = NULL;\n\t\t\t\t\tcurStringIndex++;\n\t\t\t\t\tif (_TmpStringTable[curStringIndex-1].str)\n\t\t\t\t\t{\n\t\t\t\t\t\tStringTableHashEntryTmp *hashEntry = \n\t\t\t\t\t\t\t&_TmpStringHashTable[_TmpStringTable[curStringIndex-1].strLen ? (*(const uint16_t*)strings[i]) : 0];\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tbool isDuplicate = false;\n\t\t\t\t\t\t\tfor (uint32_t l = 0; l < hashEntry->matchCount; l++)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif ((hashEntry->matches[l]->strLen == _TmpStringTable[curStringIndex-1].strLen) &&\n\t\t\t\t\t\t\t\t\t!memcmp(_TmpStringTable[curStringIndex-1].str, \n\t\t\t\t\t\t\t\t\t\thashEntry->matches[l]->str, \n\t\t\t\t\t\t\t\t\t\thashEntry->matches[l]->strLen * sizeof(char)))\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t_TmpStringTable[curStringIndex-1].parent = hashEntry->matches[l];\n\t\t\t\t\t\t\t\t\tisDuplicate = true;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (isDuplicate)\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!hashEntry->matchCount || !((hashEntry->matchCount + 1) & 3))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tvoid *tmp = realloc(hashEntry->matches, ((hashEntry->matchCount + 5) & (~3)) * sizeof(void*));\n\t\t\t\t\t\t\tif (!tmp)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif (hashEntry->matches)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tfree(hashEntry->matches);\n\t\t\t\t\t\t\t\t\thashEntry->matches = NULL;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\thashEntry->matchCount = 0;\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\thashEntry->matches = (StringTableOptTmp**)tmp;\n\t\t\t\t\t\t}\n\t\t\t\t\t\thashEntry->matches[hashEntry->matchCount] = &_TmpStringTable[curStringIndex-1];\n\t\t\t\t\t\thashEntry->matchCount++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (uint32_t i = 0; i < (MAXWORD+1); i++)\n\t\t\t\t\tif (_TmpStringHashTable[i].matches)\n\t\t\t\t\t\tfree(_TmpStringHashTable[i].matches);\n\t\t\t\tfree(_TmpStringHashTable);\n\t\t\t}\n\t\t\tfor (uint32_t i = 0; i < stringCount; i++)\n\t\t\t{\n\t\t\t\tif (_TmpStringTable[i].str == NULL)\n\t\t\t\t\tcontinue;\n\t\t\t\tfor (uint32_t k = 0; k < stringCount; k++)\n\t\t\t\t{\n\t\t\t\t\tif ((k == i) || (_TmpStringTable[k].strLen > _TmpStringTable[i].strLen))\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif ((_TmpStringTable[k].str == NULL) || (_TmpStringTable[k].parent != NULL))\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t//for (size_t l = 0; l <= (_TmpStringTable[i].strLen - _TmpStringTable[k].strLen); l++)\n\t\t\t\t\t{\n\t\t\t\t\t\tconst char *cmpTarget = &_TmpStringTable[i].str[_TmpStringTable[i].strLen-_TmpStringTable[k].strLen];\n\t\t\t\t\t\tif (!memcmp( _TmpStringTable[k].str, cmpTarget, (_TmpStringTable[k].strLen+1) * sizeof(char)))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t_TmpStringTable[k].str = cmpTarget;\n\t\t\t\t\t\t\t_TmpStringTable[k].parent = &_TmpStringTable[i];\n\t\t\t\t\t\t\t//break;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (uint32_t i = 0; i < stringCount; i++)\n\t\t\t{\n\t\t\t\tif (_TmpStringTable[i].str && !_TmpStringTable[i].parent)\n\t\t\t\t{\n\t\t\t\t\tAddString(_TmpStringTable[i].str, false);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfree(_TmpStringTable);\n\t\t\treturn true;\n\t\t}\n\t\telse\n\t\t\treturn false;\n\t\t//MessageBox(NULL, TEXT("Out of memory while optimizing the string table!"), TEXT("ERROR"), 0);\n\t}\n\tsize_t AddString(const char *string, bool optimize)\n\t{\n\t\tif (string == NULL)\n\t\t\treturn 0;\n\t\tsize_t strLen = strlen(string);\n\t\tuint16_t hash = 0;\n\t\tfor (size_t i = 0; i < strLen; i++)\n\t\t\thash += string[i];\n\t\t//uint16_t hash = strLen ? (*(const uint16_t*)string) : 0;\n\t\tif (optimize)\n\t\t{\n\t\t\tif (stringHashTable)\n\t\t\t{\n\t\t\t\t//only detects 100% equal strings -> best if AddStringsOptimized was called before\n\t\t\t\tStringTableHashEntry *pHashEntry = &stringHashTable[hash];\n\t\t\t\tfor (size_t i = 0; i < pHashEntry->matchCount; i++)\n\t\t\t\t\tif (!strncmp(&stringTable[pHashEntry->matches[i]], string, strLen+1))\n\t\t\t\t\t\treturn pHashEntry->matches[i];\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tfor (size_t i = 0; i < stringTableLen; i++)\n\t\t\t\t\tif (!strncmp(&stringTable[i], string, strLen+1))\n\t\t\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t\tsize_t ret = stringTableLen;\n\t\tif ((stringTableLen+strLen+1) > stringTableBufferLen)\n\t\t{\n\t\t\tchar *pNewStringTable = (char*)realloc(stringTable, stringTableBufferLen=((stringTableLen+strLen+1)+15)&(~15));\n\t\t\tif (!pNewStringTable)\n\t\t\t\treturn -1;\n\t\t\tstringTable = pNewStringTable;\n\t\t}\n\t\tif (stringHashTable)\n\t\t{\n\t\t\t//if out of memory, it works less efficiently (depending on how many of the matches arrays are affected)\n\t\t\tStringTableHashEntry *pHashEntry = &stringHashTable[hash];\n\t\t\tbool resized = true;\n\t\t\tif (!pHashEntry->matchCount || !((pHashEntry->matchCount + 1) & 3))\n\t\t\t{\n\t\t\t\tsize_t *tmp = (size_t*)realloc(pHashEntry->matches, ((pHashEntry->matchCount + 5) & (~3)) * sizeof(size_t));\n\t\t\t\tif (!tmp)\n\t\t\t\t{\n\t\t\t\t\tif (pHashEntry->matches)\n\t\t\t\t\t\tfree(pHashEntry->matches);\n\t\t\t\t\tpHashEntry->matchCount = 0;\n\t\t\t\t\tresized = false;\n\t\t\t\t}\n\t\t\t\tpHashEntry->matches = (size_t*)tmp;\n\t\t\t}\n\t\t\tif (resized)\n\t\t\t{\n\t\t\t\tpHashEntry->matches[pHashEntry->matchCount] = stringTableLen;\n\t\t\t\tpHashEntry->matchCount++;\n\t\t\t}\n\t\t}\n\t\tstrncpy(&stringTable[ret], string, strLen+1);\n\t\tstringTableLen += (strLen+1);\n\t\treturn ret;\n\t}\n\tchar *GetStringTable()\n\t{\n\t\treturn stringTable;\n\t}\n\tsize_t GetStringTableLen()\n\t{\n\t\treturn stringTableLen;\n\t}\n};\nASSETSTOOLS_API QWORD ClassDatabaseFile::Write(IAssetsWriter *pWriter, QWORD filePos, int optimizeStringTable, uint32_t compress, bool writeStringTable)\n{\n\tuint32_t classCount = (uint32_t)classes.size();\n\tif (writeStringTable)\n\t{\n\t\tStringTableWriter strTableWriter;\n\t\t//puts only the strings that can\'t be interpreted as a part of another string into the string table\n\t\tif (optimizeStringTable == 2)\n\t\t{\n\t\t\tsize_t stringCount = classCount;\n\t\t\tfor (uint32_t i = 0; i < classCount; i++)\n\t\t\t{\n\t\t\t\tClassDatabaseType *pType = &classes[i];\n\t\t\t\tstringCount += ((uint32_t)pType->fields.size()) * 2;\n\t\t\t}\n\t\t\tconst char **stringList = (const char**)malloc(sizeof(char*) * stringCount);\n\t\t\tbool optResult = false;\n\t\t\tif (stringList)\n\t\t\t{\n\t\t\t\tsize_t curStringIndex = 0;\n\t\t\t\tfor (uint32_t i = 0; i < classCount; i++)\n\t\t\t\t{\n\t\t\t\t\tClassDatabaseType *pType = &classes[i];\n\t\t\t\t\tstringList[curStringIndex] = pType->name.GetString(this);\n\t\t\t\t\tcurStringIndex++;\n\t\t\t\t\tfor (uint32_t k = 0; k < (uint32_t)pType->fields.size(); k++)\n\t\t\t\t\t{\n\t\t\t\t\t\tstringList[curStringIndex] = pType->fields[k].fieldName.GetString(this);\n\t\t\t\t\t\tcurStringIndex++;\n\t\t\t\t\t\tstringList[curStringIndex] = pType->fields[k].typeName.GetString(this);\n\t\t\t\t\t\tcurStringIndex++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\toptResult = strTableWriter.AddStringsOptimized(stringList, curStringIndex);\n\t\t\t\tfree(stringList);\n\t\t\t}\n\t\t\tif (!optResult)\n\t\t\t\tMessageBox(NULL, TEXT("Out of memory while optimizing the string table!"), TEXT("ERROR"), 0);\n\t\t}\n\t\tfor (uint32_t i = 0; i < classCount; i++)\n\t\t{\n\t\t\tClassDatabaseType *pType = &classes[i];\n\t\t\tpType->name.str.stringTableOffset = (uint32_t)strTableWriter.AddString(pType->name.GetString(this), optimizeStringTable ? true : false);\n\t\t\tpType->name.fromStringTable = true;\n\t\t\tpType->assemblyFileName.str.stringTableOffset = (uint32_t)strTableWriter.AddString(pType->assemblyFileName.GetString(this), optimizeStringTable ? true : false);\n\t\t\tpType->assemblyFileName.fromStringTable = true;\n\t\t\tfor (uint32_t k = 0; k < pType->fields.size(); k++)\n\t\t\t{\n\t\t\t\tClassDatabaseTypeField *pTypeField = &pType->fields[k];\n\t\t\t\tpTypeField->fieldName.str.stringTableOffset = (uint32_t)strTableWriter.AddString(pTypeField->fieldName.GetString(this), optimizeStringTable ? true : false);\n\t\t\t\tpTypeField->fieldName.fromStringTable = true;\n\t\t\t\tpTypeField->typeName.str.stringTableOffset = (uint32_t)strTableWriter.AddString(pTypeField->typeName.GetString(this), optimizeStringTable ? true : false);\n\t\t\t\tpTypeField->typeName.fromStringTable = true;\n\t\t\t}\n\t\t}\n\t\tif (!this->dontFreeStringTable && this->stringTable != NULL)\n\t\t\tfree(this->stringTable);\n\t\tthis->stringTable = strTableWriter.GetStringTable();\n\t\theader.stringTableLen = (uint32_t)strTableWriter.GetStringTableLen();\n\t\tthis->dontFreeStringTable = false;\n\t}\n\n\tQWORD headerPos = filePos;\n\tif (compress > 2)\n\t\tcompress = 0;\n#ifdef _WITHOUT_LZ4\n\tif (compress == 1)\n\t\tcompress = 0;\n#endif\n#if (ClassDatabaseFileVersion==2)\n\tif (!compress)\n\t\theader.fileVersion = 1;\n\telse\n#endif\n#if (ClassDatabaseFileVersion==3)||(ClassDatabaseFileVersion==4)\n\tbool needsVersion3 = false;\n\tfor (size_t i = 0; i < this->classes.size(); i++)\n\t{\n\t\tClassDatabaseType &curType = this->classes[i];\n\t\tfor (size_t k = 0; k < curType.fields.size(); k++)\n\t\t{\n\t\t\tif (curType.fields[k].version != 1)\n\t\t\t{\n\t\t\t\tneedsVersion3 = true;\n\t\t\t\tgoto goto_post_checkNeeds3;\n\t\t\t}\n\t\t}\n\t}\ngoto_post_checkNeeds3:\n\tif (!needsVersion3)\n\t\theader.fileVersion = compress ? 2 : 1;\n\telse\n#endif\n#if (ClassDatabaseFileVersion==4)\n\t\theader.fileVersion = 3;\n\tif (header.flags)\n#endif\n\t\theader.fileVersion = ClassDatabaseFileVersion;\n\theader.compressionType = compress;// ? ClassDatabaseCompressionType : 0;\n\tfilePos = header.Write(pWriter, filePos);\n\tQWORD postHeaderPos = filePos;\n\tIAssetsWriter *pDataWriter = pWriter;\n\tif (compress)\n\t{\n\t\tIAssetsWriter *pMemWriter = Create_AssetsWriterToMemory();\n\t\tif (!pMemWriter)\n\t\t{\n\t\t\t//we don\'t want to throw an error here, so silently don\'t compress the file\n\t\t\theader.compressionType = 0;\n\t\t\tcompress = false;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpDataWriter = pMemWriter;\n\t\t\tfilePos = 0;\n\t\t}\n\t}\n\n\tpDataWriter->Write(filePos, 4, &classCount); filePos += 4;\n\tfor (uint32_t i = 0; i < classCount; i++)\n\t{\n\t\tfilePos = classes[i].Write(pDataWriter, filePos, header.fileVersion, header.flags);\n\t}\n\theader.stringTablePos = (uint32_t)filePos;\n\tif (writeStringTable && (header.stringTableLen > 0))\n\t\tstringTable[header.stringTableLen-1] = 0;\n\tpDataWriter->Write(header.stringTablePos, header.stringTableLen, stringTable);\n\tfilePos += header.stringTableLen;\n\theader.uncompressedSize = filePos - (compress ? 0 : postHeaderPos); //doesn\'t include the header\n\n\tif (compress)\n\t{\n\t\tsize_t memWriterPos; void *memWriterBuf = NULL;\n\t\t((IAssetsWriterToMemory*)pDataWriter)->GetBuffer(memWriterBuf, memWriterPos);\n\t\tif (!memWriterBuf || (memWriterPos != filePos))\n\t\t{\n\t\t\tFree_AssetsWriter(pDataWriter);\n\t\t\tcompress = false;\n\t\t\treturn 0; //the memory writer went out of memory, we can\'t change that\n\t\t}\n\t\tuint32_t maxSize;\n\t\tif (compress == 2)\n\t\t\tmaxSize = (uint32_t)(memWriterPos + memWriterPos / 3 + 128 + LZMA_PROPS_SIZE);\n#ifndef _WITHOUT_LZ4\n\t\telse\n\t\t\tmaxSize = (uint32_t)LZ4_compressBound((int)filePos);\n#endif\n\t\tvoid *compressBuf = malloc(maxSize);\n\t\tif (compressBuf)\n\t\t{\n#ifndef _WITHOUT_LZ4\n\t\t\tif (compress == 1)\n\t\t\t\theader.compressedSize = (uint32_t)LZ4_compress_default((char*)memWriterBuf, (char*)compressBuf, (int)memWriterPos, maxSize);\n\t\t\telse \n#endif\n\t\t\tif (compress == 2)\n\t\t\t{\n\t\t\t\tsize_t destLen = maxSize - LZMA_PROPS_SIZE; size_t propsLen = LZMA_PROPS_SIZE;\n\t\t\t\tint result = LzmaCompress(\n\t\t\t\t\t&((uint8_t*)compressBuf)[LZMA_PROPS_SIZE], &destLen, \n\t\t\t\t\t(uint8_t*)memWriterBuf, memWriterPos, \n\t\t\t\t\t(uint8_t*)compressBuf, &propsLen, \n\t\t\t\t\t-1, 0, -1, -1, -1, -1, -1);\n\t\t\t\tif ((propsLen != LZMA_PROPS_SIZE) || (result != SZ_OK))\n\t\t\t\t\theader.compressedSize = 0;\n\t\t\t\telse\n\t\t\t\t\theader.compressedSize = (uint32_t)(destLen + propsLen);\n\t\t\t}\n\t\t\telse\n\t\t\t\theader.compressedSize = 0;\n\t\t}\n\t\tif (!compressBuf || !header.compressedSize)\n\t\t{\n\t\t\t//out of memory or compression failure, but we can still write the uncompressed data\n\t\t\theader.compressionType = 0;\n\t\t\tcompress = false;\n\t\t\tpWriter->Write(postHeaderPos, memWriterPos, memWriterBuf);\n\t\t\tFree_AssetsWriter(pDataWriter);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t//compression succeeded\n\t\t\tFree_AssetsWriter(pDataWriter);\n\t\t\tpWriter->Write(postHeaderPos, header.compressedSize, compressBuf);\n\t\t}\n\t\tif (compressBuf)\n\t\t\tfree(compressBuf);\n\t}\n\telse\n\t\theader.compressedSize = header.uncompressedSize;\n\theader.Write(pWriter, headerPos);\n\n\treturn postHeaderPos + header.compressedSize;\n}\nASSETSTOOLS_API bool ClassDatabaseFile::IsValid()\n{\n\treturn valid;\n}\n\nASSETSTOOLS_API bool ClassDatabaseFile::InsertFrom(ClassDatabaseFile *pOther, ClassDatabaseType *pType)\n{\n\tif (this->dontFreeStringTable)\n\t\treturn false;\n\tStringTableWriter strTableWriter = StringTableWriter(this->stringTable, this->header.stringTableLen);\n\n\tclasses.resize(classes.size()+1);\n\tClassDatabaseType &newType = classes[classes.size()-1];\n\tnewType.baseClass = pType->baseClass;\n\tnewType.classId = pType->classId;\n\tsize_t typeNameOffset = strTableWriter.AddString(pType->name.GetString(pOther), true);\n\tnewType.name.fromStringTable = true;\n\tnewType.name.str.stringTableOffset = typeNameOffset;\n\tnewType.fields.resize(pType->fields.size());\n\tfor (size_t i = 0; i < pType->fields.size(); i++)\n\t{\n\t\tClassDatabaseTypeField &ownField = newType.fields[i];\n\t\tClassDatabaseTypeField &otherField = pType->fields[i];\n\t\tsize_t nameOffset = strTableWriter.AddString(otherField.fieldName.GetString(pOther), true);\n\t\tsize_t typeOffset = strTableWriter.AddString(otherField.typeName.GetString(pOther), true);\n\t\t\n\t\townField.typeName.fromStringTable = true;\n\t\townField.typeName.str.stringTableOffset = typeOffset;\n\t\townField.fieldName.fromStringTable = true;\n\t\townField.fieldName.str.stringTableOffset = nameOffset;\n\t\townField.depth = otherField.depth;\n\t\townField.isArray = otherField.isArray;\n\t\townField.size = otherField.size;\n\t\townField.version = otherField.version;\n\t\townField.flags2 = otherField.flags2;\n\t}\n\tthis->stringTable = strTableWriter.GetStringTable();\n\tthis->header.stringTableLen = strTableWriter.GetStringTableLen();\n\treturn true;\n}\n\nASSETSTOOLS_API ClassDatabaseFile::ClassDatabaseFile()\n{\n\tthis->stringTable = NULL;\n\tthis->valid = false; this->dontFreeStringTable = false;\n\t//ZeroMemory(this, sizeof(ClassDatabaseFile));\n\t//this->classes = std::vector<ClassDatabaseType>();\n}\nASSETSTOOLS_API ClassDatabaseFile &ClassDatabaseFile::operator=(const ClassDatabaseFile& other)\n{\n\tvalid = other.valid;\n\tmemcpy(&header, &other.header, sizeof(ClassDatabaseFileHeader));\n\tif (header.unityVersionCount > 0)\n\t{\n\t\tsize_t newListLen = header.unityVersionCount * sizeof(char*);\n\t\tfor (uint32_t i = 0; i < header.unityVersionCount; i++)\n\t\t\tnewListLen += strlen(header.pUnityVersions[i])+1;\n\t\theader.pUnityVersions = (char**)malloc(newListLen);\n\t\tif (header.pUnityVersions == NULL)\n\t\t{\n\t\t\theader.unityVersionCount = 0;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tsize_t stringPos = header.unityVersionCount * sizeof(char*);\n\t\t\tfor (uint32_t i = 0; i < other.header.unityVersionCount; i++)\n\t\t\t{\n\t\t\t\theader.pUnityVersions[i] = &((char*)header.pUnityVersions)[stringPos];\n\t\t\t\tsize_t strLen = strlen(other.header.pUnityVersions[i]);\n\t\t\t\tmemcpy(header.pUnityVersions[i], other.header.pUnityVersions[i], strLen+1);\n\t\t\t\tstringPos += (strLen+1);\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t\theader.pUnityVersions = NULL;\n\tstringTable = (char*)malloc(header.stringTableLen);\n\tif (stringTable == NULL)\n\t\theader.stringTableLen = 0;\n\telse\n\t\tmemcpy(stringTable, other.stringTable, header.stringTableLen);\n\n\tclasses.reserve(other.classes.size());\n\tfor (size_t i = 0; i < other.classes.size(); i++)\n\t\tclasses.push_back(ClassDatabaseType(other.classes[i]));\n\treturn (*this);\n}\nASSETSTOOLS_API ClassDatabaseFile::ClassDatabaseFile(const ClassDatabaseFile& other)\n{\n\t(*this) = other;\n}\nASSETSTOOLS_API ClassDatabaseFile::ClassDatabaseFile(ClassDatabaseFile&& other)\n{\n\tvalid = other.valid;\n\tdontFreeStringTable = other.dontFreeStringTable;\n\theader = other.header;\n\tother.header.unityVersionCount = 0;\n\tother.header.pUnityVersions = nullptr;\n\tclasses.swap(other.classes);\n\tstringTable = other.stringTable;\n\tother.stringTable = nullptr;\n}\nASSETSTOOLS_API void ClassDatabaseFile::Clear()\n{\n\t/*if ((header.assetsVersions != NULL) && (header.assetsVersions != (uint8_t*)&header._tmp))\n\t{\n\t\tfree(header.assetsVersions);\n\t\theader.assetsVersions = NULL;\n\t}*/\n\tif (header.pUnityVersions != NULL)\n\t{\n\t\tfree(header.pUnityVersions);\n\t\theader.pUnityVersions = NULL;\n\t\theader.unityVersionCount = 0;\n\t}\n\t/*if (classes != NULL)\n\t{\n\t\tfor (uint32_t i = 0; i < classCount; i++)\n\t\t{\n\t\t\tif (classes[i].fields != NULL)\n\t\t\t\tfree(classes[i].fields);\n\t\t}\n\t\tfree(classes);\n\t\tclasses = NULL;\n\t\tclassCount = 0;\n\t}*/\n\tif (!this->dontFreeStringTable && stringTable != NULL)\n\t{\n\t\tfree(stringTable);\n\t\tstringTable = NULL;\n\t\theader.stringTableLen = 0;\n\t}\n\tclasses.clear();\n}\nASSETSTOOLS_API ClassDatabaseFile::~ClassDatabaseFile()\n{\n\tClear();\n}\n\nASSETSTOOLS_API void FreeClassDatabase_Dummy(ClassDatabaseFile *pFile)\n{}\n\nASSETSTOOLS_API QWORD ClassDatabasePackageHeader::Read(IAssetsReader *pReader, QWORD filePos)\n{\n\tif (pReader->Read(filePos, 4, &magic[0]) != 4)\n\t\treturn 0;\n\tfilePos += 4;\n\tif (memcmp(&magic[0], "CLPK", 4))\n\t\treturn 0;\n\tif (pReader->Read(-1, 1, &fileVersion) != 1)\n\t\treturn 0;\n\tfilePos += 1;\n\n\tif (fileVersion > 1)\n\t\treturn 0;\n\n\tif (pReader->Read(-1, 1, &compressionType) != 1)\n\t\treturn 0;\n\tfilePos += 1;\n\tif (pReader->Read(-1, 4, &stringTableOffset) != 4)\n\t\treturn 0;\n\tfilePos += 4;\n\tif (pReader->Read(-1, 4, &stringTableLenUncompressed) != 4)\n\t\treturn 0;\n\tfilePos += 4;\n\tif (pReader->Read(-1, 4, &stringTableLenCompressed) != 4)\n\t\treturn 0;\n\tfilePos += 4;\n\tif (fileVersion >= 1)\n\t{\n\t\tif (pReader->Read(-1, 4, &fileBlockSize) != 4)\n\t\t\treturn 0;\n\t\tfilePos += 4;\n\t}\n\telse\n\t\tfileBlockSize = 0;\n\tif (pReader->Read(-1, 4, &fileCount) != 4)\n\t\treturn 0;\n\tfilePos += 4;\n\tfiles.clear();\n\tfiles.reserve(fileCount);\n\tfor (uint32_t i = 0; i < fileCount; i++)\n\t{\n\t\tClassDatabaseFileRef ref;\n\t\tif (pReader->Read(-1, 4, &ref.offset) != 4)\n\t\t\treturn 0;\n\t\tfilePos += 4;\n\t\tif (pReader->Read(-1, 4, &ref.length) != 4)\n\t\t\treturn 0;\n\t\tfilePos += 4;\n\t\tif (pReader->Read(-1, 15, &ref.name[0]) != 15)\n\t\t\treturn 0;\n\t\tref.name[15] = 0;\n\t\tfilePos += 15;\n\t\tfiles.push_back(ref);\n\t}\n\treturn filePos;\n}\nASSETSTOOLS_API QWORD ClassDatabasePackageHeader::Write(IAssetsWriter *pWriter, QWORD filePos)\n{\n\tif (pWriter->Write(filePos, 4, "CLPK") != 4)\n\t\treturn 0;\n\tfilePos += 4;\n\tif (pWriter->Write(-1, 1, &fileVersion) != 1)\n\t\treturn 0;\n\tfilePos += 1;\n\tif (pWriter->Write(-1, 1, &compressionType) != 1)\n\t\treturn 0;\n\tfilePos += 1;\n\tif (fileVersion > 1)\n\t\treturn 0;\n\tif (pWriter->Write(-1, 4, &stringTableOffset) != 4)\n\t\treturn 0;\n\tfilePos += 4;\n\tif (pWriter->Write(-1, 4, &stringTableLenUncompressed) != 4)\n\t\treturn 0;\n\tfilePos += 4;\n\tif (pWriter->Write(-1, 4, &stringTableLenCompressed) != 4)\n\t\treturn 0;\n\tfilePos += 4;\n\tif (fileVersion >= 1)\n\t{\n\t\tif (pWriter->Write(-1, 4, &fileBlockSize) != 4)\n\t\t\treturn 0;\n\t\tfilePos += 4;\n\t}\n\tif (pWriter->Write(-1, 4, &fileCount) != 4)\n\t\treturn 0;\n\tfilePos += 4;\n\tfor (uint32_t i = 0; i < fileCount; i++)\n\t{\n\t\tClassDatabaseFileRef &ref = files[i];\n\t\tif (pWriter->Write(-1, 4, &ref.offset) != 4)\n\t\t\treturn 0;\n\t\tfilePos += 4;\n\t\tif (pWriter->Write(-1, 4, &ref.length) != 4)\n\t\t\treturn 0;\n\t\tfilePos += 4;\n\t\tif (pWriter->Write(-1, 15, &ref.name[0]) != 15)\n\t\t\treturn 0;\n\t\tfilePos += 15;\n\t}\n\treturn filePos;\n}\n\nASSETSTOOLS_API void ClassDatabasePackage::Clear()\n{\n\tif (files)\n\t{\n\t\tfor (uint32_t i = 0; i < header.fileCount; i++)\n\t\t{\n\t\t\tif (files[i])\n\t\t\t\tdelete files[i];\n\t\t}\n\t\tdelete[] files;\n\t\tfiles = NULL;\n\t}\n\tif (stringTable)\n\t{\n\t\tfree(stringTable);\n\t\tstringTable = NULL;\n\t}\n}\nASSETSTOOLS_API bool ClassDatabasePackage::Read(IAssetsReader *pReader)\n{\n\tClear();\n\tvalid = false;\n\tQWORD filePos = header.Read(pReader, 0);\n\tif (filePos == 0)\n\t{\n\t\tClear();\n\t\treturn false;\n\t}\n\tuint8_t compressAlgo = header.compressionType & 0x1F;\n\n\tIAssetsReader *pDatabasesReader = pReader;\n\tchar *databasesBuf = nullptr;\n\tif (header.compressionType & 0x80) //Compress files in one block\n\t{\n\t\tQWORD compressedSize = (QWORD)header.stringTableOffset - filePos;\n\t\tchar *compressedBuf = (char*)malloc((size_t)compressedSize);\n\t\tif (!compressedBuf)\n\t\t{\n\t\t\tClear();\n\t\t\treturn false;\n\t\t}\n\t\tif (pReader->Read(filePos, compressedSize, compressedBuf) != compressedSize)\n\t\t{\n\t\t\tfree(compressedBuf);\n\t\t\tClear();\n\t\t\treturn false;\n\t\t}\n\t\tif (compressAlgo == 0 || (header.compressionType & 0x20))\n\t\t{\n\t\t\tpDatabasesReader = Create_AssetsReaderFromMemory(compressedBuf, (size_t)compressedSize, false);\n\t\t\tdatabasesBuf = compressedBuf;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tdatabasesBuf = (char*)malloc(header.fileBlockSize);\n\t\t\tif (!databasesBuf)\n\t\t\t{\n\t\t\t\tfree(compressedBuf);\n\t\t\t\tClear();\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tuint32_t uncompressedSize = 0;\n\t\t\tif (compressAlgo == 1)\n\t\t\t{\n#ifdef _WITHOUT_LZ4\n\t\t\t\tfree(compressedBuf);\n\t\t\t\tClear();\n\t\t\t\treturn false;\n#else\n\t\t\t\tuncompressedSize = (uint32_t)LZ4_decompress_safe(\n\t\t\t\t\tcompressedBuf, databasesBuf, \n\t\t\t\t\tcompressedSize, header.fileBlockSize\n\t\t\t\t);\n#endif\n\t\t\t}\n\t\t\telse if (compressAlgo == 2 && compressedSize > LZMA_PROPS_SIZE)\n\t\t\t{\n\t\t\t\tsize_t lz_uncompressedSize = header.fileBlockSize;\n\t\t\t\tsize_t compressedWithoutProps = compressedSize - LZMA_PROPS_SIZE;\n\t\t\t\tint result = LzmaUncompress((Byte*)databasesBuf, &lz_uncompressedSize,\n\t\t\t\t\t(Byte*)&compressedBuf[LZMA_PROPS_SIZE], &compressedWithoutProps,\n\t\t\t\t\t(Byte*)compressedBuf, LZMA_PROPS_SIZE);\n\t\t\t\tif (result == SZ_OK)\n\t\t\t\t\tuncompressedSize = (uint32_t)lz_uncompressedSize;\n\t\t\t}\n\t\t\tfree(compressedBuf);\n\t\t\tif (uncompressedSize != header.fileBlockSize)\n\t\t\t{\n\t\t\t\tfree(databasesBuf);\n\t\t\t\tClear();\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tpDatabasesReader = Create_AssetsReaderFromMemory(databasesBuf, (size_t)header.fileBlockSize, false);\n\t\t}\n\t}\n\tfiles = new PClassDatabaseFile[header.fileCount];\n\tZeroMemory(files, header.fileCount * sizeof(PClassDatabaseFile));\n\tfor (uint32_t i = 0; i < header.fileCount; i++)\n\t{\n\t\tfiles[i] = new ClassDatabaseFile();\n\t\tIAssetsReader *pTempReader = Create_AssetsReaderFromReaderRange(pDatabasesReader, header.files[i].offset, header.files[i].length);\n\t\tif (!pTempReader || !files[i]->Read(pTempReader))\n\t\t{\n\t\t\tClear();\n\t\t\treturn false;\n\t\t}\n\t\tif (files[i]->stringTable != NULL)\n\t\t{\n\t\t\tfree(files[i]->stringTable);\n\t\t\tfiles[i]->stringTable = NULL;\n\t\t}\n\t\tFree_AssetsReader(pTempReader);\n\t}\n\tif (databasesBuf)\n\t{\n\t\tfree(databasesBuf);\n\t\tFree_AssetsReader(pDatabasesReader);\n\t}\n\n\n\tthis->stringTable = (char*)malloc(header.stringTableLenUncompressed);\n\tif (!this->stringTable)\n\t{\n\t\tClear();\n\t\treturn false;\n\t}\n\tchar *compressedBuf;\n\tif (header.compressionType != 0)\n\t\tcompressedBuf = (char*)malloc(header.stringTableLenCompressed);\n\telse\n\t{\n\t\theader.stringTableLenCompressed = header.stringTableLenUncompressed;\n\t\tcompressedBuf = this->stringTable;\n\t}\n\tif (!compressedBuf)\n\t{\n\t\tClear();\n\t\treturn false;\n\t}\n\tif (pReader->Read(header.stringTableOffset, header.stringTableLenCompressed, compressedBuf) != header.stringTableLenCompressed)\n\t{\n\t\tif (header.compressionType != 0) free(compressedBuf);\n\t\tClear();\n\t\treturn false;\n\t}\n\tif (compressAlgo != 0 && !(header.compressionType & 0x40))\n\t{\n\t\tuint32_t uncompressedSize = 0;\n\t\tif (compressAlgo == 1)\n\t\t{\n#ifdef _WITHOUT_LZ4\n\t\t\tfree(compressedBuf);\n\t\t\tClear();\n\t\t\treturn false;\n#else\n\t\t\tuncompressedSize = (uint32_t)LZ4_decompress_safe(\n\t\t\t\tcompressedBuf, this->stringTable, \n\t\t\t\theader.stringTableLenCompressed, header.stringTableLenUncompressed\n\t\t\t);\n#endif\n\t\t}\n\t\telse if (compressAlgo == 2 && header.stringTableLenCompressed > LZMA_PROPS_SIZE)\n\t\t{\n\t\t\tsize_t lz_uncompressedSize = header.stringTableLenUncompressed;\n\t\t\tsize_t compressedWithoutProps = header.stringTableLenCompressed - LZMA_PROPS_SIZE;\n\t\t\tint result = LzmaUncompress((Byte*)this->stringTable, &lz_uncompressedSize,\n\t\t\t\t(Byte*)&compressedBuf[LZMA_PROPS_SIZE], &compressedWithoutProps,\n\t\t\t\t(Byte*)compressedBuf, LZMA_PROPS_SIZE);\n\t\t\tif (result == SZ_OK)\n\t\t\t\tuncompressedSize = (uint32_t)lz_uncompressedSize;\n\t\t}\n\t\tfree(compressedBuf);\n\t\tif (uncompressedSize != header.stringTableLenUncompressed)\n\t\t{\n\t\t\tClear();\n\t\t\treturn false;\n\t\t}\n\t}\n\tfor (uint32_t i = 0; i < header.fileCount; i++)\n\t{\n\t\tfiles[i]->dontFreeStringTable = true;\n\t\tfiles[i]->stringTable = this->stringTable;\n\t\tfiles[i]->header.stringTableLen = this->header.stringTableLenUncompressed;\n\t}\n\treturn (valid = true);\n}\n\n//success == false -> wrote uncompressed data\nstatic bool CompressToWriter(QWORD filePos, IAssetsWriter *pWriter, \n\tvoid *uncompressedBuf, uint32_t uncompressedLen, uint8_t compressAlgo,\n\tuint32_t &compressedLen)\n{\n\tbool success = true;\n\tuint32_t maxSize;\n\tif (compressAlgo == 2)\n\t\tmaxSize = (uint32_t)(uncompressedLen + uncompressedLen / 3 + 128 + LZMA_PROPS_SIZE);\n\telse\n#ifdef _WITHOUT_LZ4\n\t\treturn false;\n#else\n\t\tmaxSize = (uint32_t)LZ4_compressBound((int)uncompressedLen);\n#endif\n\tvoid *compressBuf = malloc(maxSize);\n\tif (compressBuf)\n\t{\n#ifndef _WITHOUT_LZ4\n\t\tif (compressAlgo == 1)\n\t\t\tcompressedLen = (uint32_t)LZ4_compress_default((char*)uncompressedBuf, (char*)compressBuf, (int)uncompressedLen, maxSize);\n\t\telse \n#endif\n\t\tif (compressAlgo == 2)\n\t\t{\n\t\t\tsize_t destLen = maxSize - LZMA_PROPS_SIZE; size_t propsLen = LZMA_PROPS_SIZE;\n\t\t\tint result = LzmaCompress(\n\t\t\t\t&((uint8_t*)compressBuf)[LZMA_PROPS_SIZE], &destLen, \n\t\t\t\t(uint8_t*)uncompressedBuf, uncompressedLen, \n\t\t\t\t(uint8_t*)compressBuf, &propsLen, \n\t\t\t\t-1, 0, -1, -1, -1, -1, -1);\n\t\t\tif ((propsLen != LZMA_PROPS_SIZE) || (result != SZ_OK))\n\t\t\t\tcompressedLen = 0;\n\t\t\telse\n\t\t\t\tcompressedLen = (uint32_t)(destLen + propsLen);\n\t\t}\n\t\telse\n\t\t\tcompressedLen = 0;\n\t}\n\tif (!compressBuf || !compressedLen)\n\t{\n\t\t//out of memory or compression failure, but we can still write the uncompressed data\n\t\tsuccess = false;\n\t\tcompressedLen = uncompressedLen;\n\t\tpWriter->Write(filePos, uncompressedLen, uncompressedBuf);\n\t}\n\telse\n\t{\n\t\t//compression succeeded\n\t\tpWriter->Write(filePos, compressedLen, compressBuf);\n\t}\n\tif (compressBuf)\n\t\tfree(compressBuf);\n\treturn success;\n}\nASSETSTOOLS_API QWORD ClassDatabasePackage::Write(IAssetsWriter *pWriter, QWORD filePos, int optimizeStringTable, uint32_t compress)\n{\n\tcompress = (((compress & 0x1F) > 2) ? 0 : (compress & 0x1F)) | (compress & 0xE0);\n\tuint8_t compressAlgo = compress & 0x1F;\n\theader.compressionType = compress;\n#if ClassDatabasePackageVersion == 1\n\theader.fileVersion = ((compress & 0xE0) != 0) ? 1 : 0;\n#else\n\theader.fileVersion = ClassDatabasePackageVersion;\n#endif\n\n\tStringTableWriter strTableWriter;\n\tif (optimizeStringTable == 2)\n\t{\n\t\tsize_t stringCount = 0;\n\t\tfor (uint32_t i = 0; i < header.fileCount; i++)\n\t\t{\n\t\t\tfor (uint32_t k = 0; k < (uint32_t)this->files[i]->classes.size(); k++)\n\t\t\t{\n\t\t\t\tClassDatabaseType *pType = &this->files[i]->classes[k];\n\t\t\t\tstringCount += 1 + ((uint32_t)pType->fields.size()) * 2;\n\t\t\t}\n\t\t}\n\t\tconst char **stringList = (const char**)malloc(sizeof(char*) * stringCount);\n\t\tbool optResult = false;\n\t\tif (stringList)\n\t\t{\n\t\t\tsize_t curStringIndex = 0;\n\t\t\tfor (uint32_t i = 0; i < header.fileCount; i++)\n\t\t\t{\n\t\t\t\tClassDatabaseFile *pCurFile = this->files[i];\n\t\t\t\tfor (uint32_t k = 0; k < (uint32_t)pCurFile->classes.size(); k++)\n\t\t\t\t{\n\t\t\t\t\tClassDatabaseType *pType = &pCurFile->classes[k];\n\t\t\t\t\tstringList[curStringIndex] = pType->name.GetString(pCurFile);\n\t\t\t\t\tcurStringIndex++;\n\t\t\t\t\tfor (uint32_t l = 0; l < (uint32_t)pType->fields.size(); l++)\n\t\t\t\t\t{\n\t\t\t\t\t\tstringList[curStringIndex] = pType->fields[l].fieldName.GetString(pCurFile);\n\t\t\t\t\t\tcurStringIndex++;\n\t\t\t\t\t\tstringList[curStringIndex] = pType->fields[l].typeName.GetString(pCurFile);\n\t\t\t\t\t\tcurStringIndex++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\toptResult = strTableWriter.AddStringsOptimized(stringList, curStringIndex);\n\t\t\tfree(stringList);\n\t\t}\n\t\tif (!optResult)\n\t\t\tMessageBox(NULL, TEXT("Out of memory while optimizing the string table!"), TEXT("ERROR"), 0);\n\t}\n\tfor (uint32_t i = 0; i < header.fileCount; i++)\n\t{\n\t\tfor (uint32_t k = 0; k < (uint32_t)this->files[i]->classes.size(); k++)\n\t\t{\n\t\t\tClassDatabaseType *pType = (ClassDatabaseType*)&this->files[i]->classes[k];\n\t\t\tpType->name.str.stringTableOffset = (uint32_t)strTableWriter.AddString(pType->name.GetString(this->files[i]), optimizeStringTable ? true : false);\n\t\t\tpType->name.fromStringTable = true;\n\t\t\tfor (uint32_t l = 0; l < (uint32_t)pType->fields.size(); l++)\n\t\t\t{\n\t\t\t\tpType->fields[l].fieldName.str.stringTableOffset = \n\t\t\t\t\t(uint32_t)strTableWriter.AddString(pType->fields[l].fieldName.GetString(this->files[i]), optimizeStringTable ? true : false);\n\t\t\t\tpType->fields[l].fieldName.fromStringTable = true;\n\t\t\t\tpType->fields[l].typeName.str.stringTableOffset = \n\t\t\t\t\t(uint32_t)strTableWriter.AddString(pType->fields[l].typeName.GetString(this->files[i]), optimizeStringTable ? true : false);\n\t\t\t\tpType->fields[l].typeName.fromStringTable = true;\n\t\t\t}\n\t\t}\n\t}\n\tif (this->stringTable)\n\t{\n\t\tfree(this->stringTable);\n\t\tthis->stringTable = NULL;\n\t}\n\tthis->stringTable = strTableWriter.GetStringTable();\n\theader.stringTableLenUncompressed = (uint32_t)strTableWriter.GetStringTableLen();\n\tQWORD headerPos = filePos;\n\tfilePos = header.Write(pWriter, filePos);\n\n\t{\n\t\tIAssetsWriter *pFileWriter = pWriter;\n\t\tIAssetsWriterToMemory *pBlockWriter = nullptr;\n\t\tQWORD blockFilePos = filePos;\n\t\tif ((compress & 0x80) && !(compress & 0x20))\n\t\t{\n\t\t\tpBlockWriter = Create_AssetsWriterToMemory();\n\t\t\tpFileWriter = pBlockWriter;\n\t\t\tblockFilePos = 0;\n\t\t}\n\t\tfor (uint32_t i = 0; i < header.fileCount; i++)\n\t\t{\n\t\t\tif (!this->files[i]->dontFreeStringTable)\n\t\t\t{\n\t\t\t\tthis->files[i]->dontFreeStringTable = true;\n\t\t\t\tif (this->files[i]->stringTable)\n\t\t\t\t\tfree(this->files[i]->stringTable);\n\t\t\t}\n\t\t\tthis->files[i]->stringTable = this->stringTable;\n\t\t\tthis->files[i]->header.stringTableLen = 0; //temporarily for writing\n\t\t\theader.files[i].offset = (uint32_t)blockFilePos;\n\t\t\tblockFilePos = this->files[i]->Write(pFileWriter, blockFilePos, false, (compress & 0x80) ? 0 : compressAlgo, false);\n\t\t\theader.files[i].length = (uint32_t)blockFilePos - header.files[i].offset;\n\t\t\tthis->files[i]->header.stringTableLen = header.stringTableLenUncompressed;\n\t\t}\n\t\tif (compress & 0x80)\n\t\t{\n\t\t\theader.fileBlockSize = (uint32_t)blockFilePos;\n\n\t\t\tvoid *pBlockBuffer = nullptr; size_t blockBufferSize = 0;\n\t\t\tif (!pBlockWriter->GetBuffer(pBlockBuffer, blockBufferSize))\n\t\t\t{\n\t\t\t\tMessageBox(NULL, TEXT("Unable to retrieve the raw class databases!"), TEXT("ERROR"), 0);\n\t\t\t\theader.fileBlockSize = 0;\n\t\t\t}\n\n\t\t\tuint32_t compressedLen = 0;\n\t\t\tif (!CompressToWriter(filePos, pWriter, pBlockBuffer, header.fileBlockSize, compressAlgo, compressedLen))\n\t\t\t\theader.compressionType |= 0x20;\n\t\t\tfilePos += compressedLen;\n\n\t\t\tFree_AssetsWriter(pBlockWriter);\n\t\t}\n\t}\n\n\tQWORD stringTablePos = filePos;\n\theader.stringTableOffset = (uint32_t)stringTablePos;\n\theader.stringTableLenCompressed = header.stringTableLenUncompressed;\n\tmemcpy(&header.magic[0], "CLPK", 4);\n\tif (compressAlgo && (compress & 0x40) == 0)\n\t{\n\t\tif (!CompressToWriter(filePos, pWriter, this->stringTable, header.stringTableLenUncompressed, compressAlgo, header.stringTableLenCompressed))\n\t\t\theader.compressionType |= 0x40;\n\t}\n\telse\n\t\tpWriter->Write(stringTablePos, header.stringTableLenUncompressed, this->stringTable);\n\theader.Write(pWriter, headerPos);\n\treturn stringTablePos + header.stringTableLenCompressed;\n}\nASSETSTOOLS_API bool ClassDatabasePackage::RemoveFile(uint32_t index)\n{\n\tif (index >= header.fileCount)\n\t\treturn false;\n\tif (files == NULL)\n\t\treturn false;\n\theader.files.erase(header.files.begin() + index);\n\tClassDatabaseFile **newFiles = new PClassDatabaseFile[(header.fileCount - 1)];\n\tmemcpy(newFiles, files, sizeof(ClassDatabaseFile*) * index);\n\tmemcpy(&newFiles[index], &files[index+1], sizeof(ClassDatabaseFile*) * (header.fileCount - index - 1));\n\tdelete files[index];\n\tdelete[] files;\n\tfiles = newFiles;\n\theader.fileCount--;\n\treturn true;\n}\nASSETSTOOLS_API bool ClassDatabasePackage::ImportFile(IAssetsReader *pReader)\n{\n\tClassDatabaseFile **newFiles = new PClassDatabaseFile[(header.fileCount + 1)];\n\tmemcpy(newFiles, files, sizeof(ClassDatabaseFile*) * header.fileCount);\n\tClassDatabaseFile *pFile = new ClassDatabaseFile();\n\tif (!pFile->Read(pReader))\n\t{\n\t\tdelete pFile;\n\t\tdelete[] newFiles;\n\t\treturn false;\n\t}\n\tnewFiles[header.fileCount] = pFile;\n\tdelete[] files;\n\tfiles = newFiles;\n\tClassDatabaseFileRef fileRef;\n\tfileRef.length = fileRef.offset = 0;\n\tmemset(fileRef.name, 0, 16);\n\theader.files.push_back(fileRef);\n\theader.fileCount++;\n\treturn true;\n}\nASSETSTOOLS_API bool ClassDatabasePackage::IsValid()\n{\n\treturn valid;\n}\n\t\nASSETSTOOLS_API ClassDatabasePackage::~ClassDatabasePackage()\n{\n\tClear();\n}'