b'{-# LANGUAGE MultiParamTypeClasses, FunctionalDependencies, CPP,\n             FlexibleInstances, UndecidableInstances #-}\n-- UndecidableInstances\n\n{-|\n    This module establishes a class hierarchy that captures the\n    interfaces of @Par@ monads.  There are two layers: simple futures\n    (\'ParFuture\') and full @IVars@ (\'ParIVar\').  All @Par@ monads are\n    expected to implement the former, some also implement the latter.\n\n    For more documentation of the programming model, see\n\n    * The "Control.Monad.Par" module in the @monad-par@ package.\n\n    * The wiki\\/tutorial (<http://www.haskell.org/haskellwiki/Par_Monad:_A_Parallelism_Tutorial>)\n\n    * The original paper (<http://www.cs.indiana.edu/~rrnewton/papers/haskell2011_monad-par.pdf>)\n\n    * Tutorial slides (<http://community.haskell.org/~simonmar/slides/CUFP.pdf>)\n\n    * Other slides (<http://www.cs.ox.ac.uk/ralf.hinze/WG2.8/28/slides/simon.pdf>, <http://www.cs.indiana.edu/~rrnewton/talks/2011_HaskellSymposium_ParMonad.pdf>)\n\n -}\n--\n\nmodule Control.Monad.Par.Class\n  (\n  -- * Futures\n    ParFuture(..)\n  -- * IVars\n  , ParIVar(..)\n\n    -- RRN: Not releasing this interface until there is a nice implementation of it:\n    --  Channels (Streams)\n    --  , ParChan(..)\n\n  , NFData() -- This is reexported.\n  )\nwhere\n\nimport Control.DeepSeq\n\n--------------------------------------------------------------------------------\n\n-- | @ParFuture@ captures the class of Par monads which support\n--   futures.  This level of functionality subsumes @par@/@pseq@ and is\n--   similar to the "Control.Parallel.Strategies.Eval" monad.\n--\n--   A minimal implementation consists of `spawn_` and `get`.\n--   However, for monads that are also a member of `ParIVar` it is\n--   typical to simply define `spawn` in terms of `fork`, `new`, and `put`.\nclass Monad m => ParFuture future m | m -> future where\n  -- | Create a potentially-parallel computation, and return a /future/\n  -- (or /promise/) that can be used to query the result of the forked\n  -- computataion.\n  --\n  -- >  spawn p = do\n  -- >    r <- new\n  -- >    fork (p >>= put r)\n  -- >    return r\n  --\n  spawn  :: NFData a => m a -> m (future a)\n\n  -- | Like \'spawn\', but the result is only head-strict, not fully-strict.\n  spawn_ :: m a -> m (future a)\n\n  -- | Wait for the result of a future, and then return it.\n  get    :: future a -> m a\n\n  -- | Spawn a pure (rather than monadic) computation.  Fully-strict.\n  --\n  -- >  spawnP = spawn . return\n  spawnP :: NFData a =>   a -> m (future a)\n\n  -- Default implementations:\n  spawn  p = spawn_ (do x <- p; deepseq x (return x))\n  spawnP a = spawn (return a)\n\n\n--------------------------------------------------------------------------------\n\n-- | @ParIVar@ builds on futures by adding full /anyone-writes, anyone-reads/ IVars.\n--   These are more expressive but may not be supported by all distributed schedulers.\n--\n-- A minimal implementation consists of `fork`, `put_`, and `new`.\nclass ParFuture ivar m  => ParIVar ivar m | m -> ivar where\n  -- | Forks a computation to happen in parallel.  The forked\n  -- computation may exchange values with other computations using\n  -- @IVar@s.\n  fork :: m () -> m ()\n\n  -- | creates a new @IVar@\n  new  :: m (ivar a)\n\n  -- | put a value into a @IVar@.  Multiple \'put\'s to the same @IVar@\n  -- are not allowed, and result in a runtime error.\n  --\n  -- \'put\' fully evaluates its argument, which therefore must be an\n  -- instance of \'NFData\'.  The idea is that this forces the work to\n  -- happen when we expect it, rather than being passed to the consumer\n  -- of the @IVar@ and performed later, which often results in less\n  -- parallelism than expected.\n  --\n  -- Sometimes partial strictness is more appropriate: see \'put_\'.\n  --\n  put  :: NFData a => ivar a -> a -> m ()\n  put v a = deepseq a (put_ v a)\n\n  -- | like \'put\', but only head-strict rather than fully-strict.\n  put_ :: ivar a -> a -> m ()\n\n  -- Extra API routines that have default implementations:\n\n  -- | creates a new @IVar@ that contains a value\n  newFull :: NFData a => a -> m (ivar a)\n  newFull a = deepseq a (newFull_ a)\n\n  -- | creates a new @IVar@ that contains a value (head-strict only)\n  newFull_ ::  a -> m (ivar a)\n  newFull_ a = do v <- new\n                  -- This is usually inefficient!\n                  put_ v a\n                  return v\n\n--------------------------------------------------------------------------------\n\n-- class ParYieldable ??\n  -- TODO: I think we should add yield officially:\n\n  -- Allows other parallel computations to progress.  (should not be\n  -- necessary in most cases).\n  --  yield  :: m ()\n\n\n--------------------------------------------------------------------------------\n\n-- | @ParChan@ provides communication via streams of values between\n--   computations in a Par monad.  Channels in this case are split\n--   into separate send and receive ports.\n--\n--   The critical thing to know about @Chan@s in @Par@ monads is that\n--   while the @recv@ method destructively advances the position of\n--   the consumer\'s \\"cursor\\" in the stream, this is only observable\n--   in the /local/ @Par@ thread.  That is, at @fork@ points it is\n--   necessary to give the child computation a separate set of stream\n--   cursors so that it observes the same sequences as the parent.\n{-\nclass Monad m => ParChan snd rcv m | m -> snd, m -> rcv where\n   -- | Create a new communication channel, with separate send and receive ports.\n   newChan :: m (snd a, rcv a)\n   -- | Receive a message on a channel in a synchronous, blocking manner.\n   recv    :: rcv a -> m a\n   -- | Send a message on a channel.  This may or may not block.\n   send    :: snd a -> a -> m ()\n-}\n\n\n----------------------------------------------------------------------------------------------------\n\n-- t1 :: P.Par Int\n-- If the ParIVar => ParFuture instance exists the following is sufficient:\n_t1 :: (ParFuture v m) => m Int\n_t1 = do\n  x <- spawn (return 3)\n  get x\n\n_t2 :: (ParIVar v m) => m Int\n_t2 = do\n  x <- new\n  put x "hi"\n  return 3\n\n\n-- TODO: SPECIALIZE generic routines for the default par monad (and possibly ParRNG)?\n\n--  SPECIALISE parMap  :: (NFData b) => (a -> b)     -> [a] -> Par [b]\n-- SPECIALISE parMapM :: (NFData b) => (a -> Par b) -> [a] -> Par [b]\n'