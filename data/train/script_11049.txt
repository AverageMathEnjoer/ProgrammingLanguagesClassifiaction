b'// UVa1673 str2int\n// Rujia Liu\n//\n// This is Problem 12-3 of <<Beginning Algorithm Contests>> 2nd edition\n//\n// Note that we\'re using the "big string method", as explained in the book.\n// It\'s slightly less efficient than the official "multiple string DAWG" because we need to explicitly store \'$\' edges.\n// However, it\'s conceptually cleaner, and easier to understand.\n#include <cstdio>\n#include <cstring>\nusing namespace std;\n\nconst int maxc = 11; // 10 digits and \'$\'\nconst int maxn = 100000 + 10;\n\nstruct DAWG {\n  struct Node {\n    Node *fa, *next[maxc];\n    int len;\n    int id, pos;\n    Node(){}\n    Node(int len):fa(0),len(len){\n      memset(next, 0, sizeof(next));\n    }\n  };\n\n  Node node[maxn*2], *root, *last;\n  int tot;\n\n  Node *newnode(const Node& u) {\n    node[tot] = u;\n    node[tot].id = tot;\n    return &node[tot++];\n  }\n  Node* newnode(int len) { return newnode(Node(len)); }\n  Node* newnode(Node *p) { return newnode(*p); }\n\n  void init() {\n    tot = 0;\n    root = last = newnode(0);\n    node[0].pos = 0;\n  }\n\n  void add(int x,int len) {\n    Node *p = last, *np = newnode(p->len + 1);\n    np->pos = len;\n    last = np;\n    for(; p && !p->next[x];p = p->fa)\n        p->next[x] = np;\n    if(!p) { np->fa = root; return; }\n\n    Node *q = p->next[x];\n    if(q->len == p->len + 1) { np->fa = q; return; }\n\n    Node *nq = newnode(q);\n    nq->len = p->len + 1;\n    q->fa = nq;\n    np->fa = nq;\n    for(; p && p->next[x] == q; p = p->fa)\n        p->next[x] = nq;\n  }\n};\n\n\n/////// problem related\n\nconst int MOD = 2012;\n\nchar s[maxn];\nint topo[maxn*2], topocnt[maxn*2], sum[maxn*2], cnt[maxn*2];\nDAWG g;\n\nint main() {\n  int n;\n  while(scanf("%d", &n) == 1) {\n    g.init();\n    int totlen = 0;\n    for(int i = 0; i < n; i++) {\n      scanf("%s", s);\n      int len = strlen(s);\n      if(i > 0) g.add(10, ++totlen); // $\n      for(int j = 0; j < len; j++) {\n        g.add(s[j] - \'0\', ++totlen); // regular edges\n      }\n    }\n\n    // topology sort\n    for(int i = 0; i <= totlen; i++)\n      topocnt[i] = 0;\n    for(int i = 0; i < g.tot; i++)\n      topocnt[g.node[i].len]++;\n    for(int i = 1; i <= totlen; i++)\n      topocnt[i] += topocnt[i-1];\n    for(int i = 0; i < g.tot; i++)\n      topo[--topocnt[g.node[i].len]] = i;\n\n    int ans = 0;\n    for(int i = 0; i < g.tot; i++)\n      cnt[i] = sum[i] = 0;\n    cnt[0] = 1;\n    for(int i = 0; i < g.tot; i++) {\n      int fa = topo[i];\n      DAWG::Node* u = &g.node[fa];\n      for(int j = 0; j < 10; j++) {\n        if(i == 0 && j == 0) continue;\n        if(u->next[j]) {\n          int son = u->next[j]->id;\n          cnt[son] = (cnt[son] + cnt[fa]) % MOD;\n          sum[son] = (sum[son] + sum[fa]*10 + cnt[fa]*j) % MOD;\n        }\n      }\n      ans = (ans + sum[fa]) % MOD;\n    }\n    printf("%d\\n", ans);\n  }\n  return 0;\n}\n'