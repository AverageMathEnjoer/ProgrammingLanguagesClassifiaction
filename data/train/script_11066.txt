b'\xef\xbb\xbf// Chapter 10: K-means clustering\n#load "KMeansClustering.fs"\nopen MachineLearning.KMeansClustering\n\n// test on standard data\nlet rng = new System.Random()\nlet centroids = [ [| 0.; 0.; 0. |]; [| 20.; 30.; 40. |]; [| -40.; -50.; -60. |] ]\n// Create 50 points centered around each Centroid\nlet data = [ \n    for centroid in centroids do\n        for i in 1 .. 50 -> \n            Array.map (fun x -> x + 5. * (rng.NextDouble() - 0.5)) centroid ]\n\nlet factory = randomCentroids<float[]> rng\nlet identifiedCentroids, classifier = kmeans euclidean factory avgCentroid data 3\nprintfn "Centroids identified"\nidentifiedCentroids \n|> List.iter (fun c -> \n    printfn ""\n    printf "Centroid: "\n    Array.iter (fun x -> printf "%.2f " x) c)\n\n// Just for quicks, I wondered if I could cluster strings\n\n// Levenshtein distance between strings, lifted from:\n// http://en.wikibooks.org/wiki/Algorithm_implementation/Strings/Levenshtein_distance#F.23\nlet inline min3 one two three = \n    if one < two && one < three then one\n    elif two < three then two\n    else three\n\nlet wagnerFischerLazy (s: string) (t: string) =\n    let m = s.Length\n    let n = t.Length\n    let d = Array2D.create (m+1) (n+1) -1\n    let rec dist =\n        function\n        | i, 0 -> i\n        | 0, j -> j\n        | i, j when d.[i,j] <> -1 -> d.[i,j]\n        | i, j ->\n            let dval = \n                if s.[i-1] = t.[j-1] then dist (i-1, j-1)\n                else\n                    min3\n                        (dist (i-1, j)   + 1) // a deletion\n                        (dist (i,   j-1) + 1) // an insertion\n                        (dist (i-1, j-1) + 1) // a substitution\n            d.[i, j] <- dval; dval \n    dist (m, n)\n\n// Centroid update: pick the word in the cluster that\n// has the lowest maximum distance to the others\nlet wordCentroid (current: string) (sample: string seq) =\n    let size = Seq.length sample\n    match size with\n    | 0 -> current\n    | _ ->\n        sample\n        |> Seq.map (fun word -> \n            let worst = \n                sample \n                |> Seq.map (fun s -> wagnerFischerLazy s word) \n                |> Seq.max\n            word, worst)\n        |> Seq.minBy snd\n        |> fst\n\n// Create a sample of words, based on three roots:\n// http://www.learnthat.org/word_lists/view/12933\n// http://www.learnthat.org/word_lists/view/13077\n// http://www.learnthat.org/word_lists/view/12932\nlet words = [ \n    "AUTOBIOGRAPHER"; "AUTOBIOGRAPHICAL"; "AUTOBIOGRAPHY"; "AUTOGRAPH"; "BIBLIOGRAPHIC"; "BIBLIOGRAPHY"; "CALLIGRAPHY"; "CARTOGRAPHY"; "CRYPTOGRAPHY"; "GRAPH"; "HISTORIOGRAPHY"; "PARAGRAPH"; "SEISMOGRAPH"; "STENOGRAPHER"; "TELEGRAPH"; "TELEGRAPHIC"; "BIBLIOGRAPHICAL"; "STEREOGRAPH"; \n    "DESCRIBABLE"; "DESCRIBE"; "DESCRIBER"; "DESCRIPTION"; "DESCRIPTIVE"; "INDESCRIBABLE"; "INSCRIBE"; "INSCRIPTION"; "POSTSCRIPT"; "PRESCRIBE"; "PRESCRIPTION"; "PRESCRIPTIVE"; "SCRIBAL"; "SCRIBBLE"; "SCRIBE"; "SCRIBBLER"; "SCRIPT"; "SCRIPTURE"; "SCRIPTWRITER"; "SUPERSCRIPT"; "TRANSCRIBE"; "TYPESCRIPT"; "TRANSCRIPTION"; "DESCRIPTOR";\n    "ANAGRAM"; "CABLEGRAM"; "CRYPTOGRAM"; "GRAMMAR"; "GRAMMARIAN"; "GRAMMATICAL"; "MONOGRAM"; "RADIOGRAM"; "TELEGRAM"; "UNGRAMMATICAL"; "AEROGRAM" ]\n\nlet wordDistance w1 w2 = wagnerFischerLazy w1 w2 |> (float)\nlet wordFactory = randomCentroids<string> rng\n\nlet identifiedWords, wordClassifier = kmeans wordDistance wordFactory wordCentroid words 3\n\nprintfn ""\nprintfn "Words identified"\nidentifiedWords |> List.iter (fun w -> printfn "%s" w)\nprintfn "Classification of sample words"\nwords |> List.iter (fun w -> printfn "%s -> %s" w (wordClassifier w))'