b'// OO features\nopen System\n\ntype Person(age, firstname, surname) =    \n    let fullName = sprintf "%s %s" firstname surname\n\n    member __.PrintFullName() =\n        printfn "%s is %d years old" fullName age\n    \n    member this.Age = age\n    member that.Name = fullName\n    member val FavouriteColour = System.Drawing.Color.Green with get,set\n\n\ntype IQuack = \n    abstract member Quack : unit -> unit\n\n// A class that implements interfaces and overrides methods\ntype Duck() =\n    interface IQuack with\n        member this.Quack() = printfn "QUACK!"\n\nmodule Quackers =\n    let superQuack =\n        { new IQuack with\n            member this.Quack() = printfn "What type of animal am I?" }\n        \n\n[<AbstractClass>]\ntype Employee(name:string) =\n    member __.Name = name\n    abstract member Work : unit -> string\n    member this.DoWork() =\n        printfn "%s is working hard: %s!" name (this.Work())\n\ntype ProjectManager(name:string) =\n    inherit Employee(name)\n    override this.Work() = "Creating a project plan"\n\n// Exception Handling\nmodule Exceptions =\n    let riskyCode() =\n        raise(ApplicationException())\n        ()\n    let runSafely() =\n        try riskyCode()\n        with\n        | :? ApplicationException as ex -> printfn "Got an application exception! %O" ex\n        | :? System.MissingFieldException as ex -> printfn "Got a missing field exception! %O" ex\n        | ex -> printfn "Got some other type of exception! %O" ex\n\n\n// Resource Management\nmodule ResourceManagement =\n    let createDisposable() =\n        printfn "Created!"\n        { new IDisposable with member __.Dispose() = printfn "Disposed!" }\n    \n    let foo() =\n        use x = createDisposable()\n        printfn "inside!"\n    \n    let bar() =\n        using (createDisposable()) (fun x ->\n            printfn "inside!")\n\n// Casting\nmodule Casting =\n    let anException = Exception()\n    let upcastToObject = anException :> obj\n    let upcastToAppException = anException :> ApplicationException\n    let downcastToAppException = anException :?> ApplicationException\n    let downcastToString = anException :?> string\n\n// Active Patterns\nmodule ActivePatterns =\n    let (|Long|Medium|Short|) (value:string) =\n        if value.Length < 5 then Short\n        elif value.Length < 10 then Medium\n        else Long\n\n    match "Hello" with\n    | Short -> "This is a short string!"\n    | Medium -> "This is a medium string!"\n    | Long -> "This is a long string!"\n\n// Lazy Computations\nmodule Lazy =\n    let lazyText =\n        lazy\n            let x = 5 + 5\n            printfn "%O: Hello! Answer is %d" System.DateTime.UtcNow x\n            x\n    \n    let text = lazyText.Value\n    let text2 = lazyText.Value\n\n// Recursion\nmodule Recursion =\n    let rec factorial number total =\n        if number = 1 then total\n        else\n            printfn "Number %d" number\n            factorial (number - 1) (total * number)\n    \n    factorial 5 1'