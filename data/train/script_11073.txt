b'{-# LANGUAGE BangPatterns #-}\nmodule Main where\n\nimport Control.DeepSeq (rnf)\nimport Control.Exception (evaluate)\nimport Test.Tasty.Bench (bench, defaultMain, whnf)\nimport Data.List (foldl\')\nimport qualified Data.IntMap as M\nimport qualified Data.IntMap.Strict as MS\nimport Data.Maybe (fromMaybe)\nimport Prelude hiding (lookup)\n\nmain = do\n    let m     = M.fromAscList elems_hits   :: M.IntMap Int\n    let m\'    = M.fromAscList elems_mid    :: M.IntMap Int\n    let m\'\'   = M.fromAscList elems_most   :: M.IntMap Int\n    let m\'\'\'  = M.fromAscList elems_misses :: M.IntMap Int\n    let m\'\'\'\' = M.fromAscList elems_mixed  :: M.IntMap Int\n    evaluate $ rnf [m, m\', m\'\', m\'\'\', m\'\'\'\']\n    defaultMain\n        [ bench "lookup_hits" $ whnf (lookup keys) m\n        , bench "lookup_half" $ whnf (lookup keys) m\'\n        , bench "lookup_most" $ whnf (lookup keys) m\'\'\n        , bench "lookup_misses" $ whnf (lookup keys\'\') m\'\'\'\n        , bench "lookup_mixed" $ whnf (lookup keys) m\'\'\'\'\n        , bench "insert" $ whnf (ins elems) M.empty\n        , bench "insertWith empty" $ whnf (insWith elems) M.empty\n        , bench "insertWith update" $ whnf (insWith elems) m\n        , bench "insertWith\' empty" $ whnf (insWith\' elems) M.empty\n        , bench "insertWith\' update" $ whnf (insWith\' elems) m\n        , bench "insertWithKey empty" $ whnf (insWithKey elems) M.empty\n        , bench "insertWithKey update" $ whnf (insWithKey elems) m\n        , bench "insertWithKey\' empty" $ whnf (insWithKey\' elems) M.empty\n        , bench "insertWithKey\' update" $ whnf (insWithKey\' elems) m\n        , bench "insertLookupWithKey empty" $ whnf (insLookupWithKey elems) M.empty\n        , bench "insertLookupWithKey update" $ whnf (insLookupWithKey elems) m\n        , bench "map" $ whnf (M.map (+ 1)) m\n        , bench "mapWithKey" $ whnf (M.mapWithKey (+)) m\n        , bench "foldlWithKey" $ whnf (ins elems) m\n        , bench "foldlWithKey\'" $ whnf (M.foldlWithKey\' sum 0) m\n        , bench "foldrWithKey" $ whnf (M.foldrWithKey consPair []) m\n        , bench "delete" $ whnf (del keys) m\n        , bench "update" $ whnf (upd keys) m\n        , bench "updateLookupWithKey" $ whnf (upd\' keys) m\n        , bench "alter"  $ whnf (alt keys) m\n        , bench "mapMaybe" $ whnf (M.mapMaybe maybeDel) m\n        , bench "mapMaybeWithKey" $ whnf (M.mapMaybeWithKey (const maybeDel)) m\n        , bench "fromList" $ whnf M.fromList elems\n        , bench "fromAscList" $ whnf M.fromAscList elems\n        , bench "fromDistinctAscList" $ whnf M.fromDistinctAscList elems\n        , bench "minView" $ whnf (maybe 0 (\\((k,v), m) -> k+v+M.size m) . M.minViewWithKey)\n                    (M.fromList $ zip [1..10] [1..10])\n        , bench "spanAntitone" $ whnf (M.spanAntitone (<key_mid)) m\n        , bench "split" $ whnf (M.split key_mid) m\n        , bench "splitLookup" $ whnf (M.splitLookup key_mid) m\n        ]\n  where\n    elems = elems_hits\n    elems_hits   = zip keys values\n    elems_mid    = zip (map (+ (2^12 `div` 2)) keys) values\n    elems_most   = zip (map (+ (2^12 `div` 10)) keys) values\n    elems_misses = zip (map (\\x-> x * 2 + 1) keys) values\n    elems_mixed = zip mixedKeys values\n    --------------------------------------------------------\n    keys = [1..2^12]\n    keys\' = fmap (+ 1000000) keys\n    keys\'\' = fmap (* 2) [1..2^12]\n    mixedKeys = interleave keys keys\'\n    values = [1..2^12]\n    key_mid = 2^11\n    --------------------------------------------------------\n    sum k v1 v2 = k + v1 + v2\n    consPair k v xs = (k, v) : xs\n\n------------------------------------------------------------\nadd3 :: Int -> Int -> Int -> Int\nadd3 x y z = x + y + z\n{-# INLINE add3 #-}\n\nlookup :: [Int] -> M.IntMap Int -> Int\nlookup xs m = foldl\' (\\n k -> fromMaybe n (M.lookup k m)) 0 xs\n\nins :: [(Int, Int)] -> M.IntMap Int -> M.IntMap Int\nins xs m = foldl\' (\\m (k, v) -> M.insert k v m) m xs\n\ninsWith :: [(Int, Int)] -> M.IntMap Int -> M.IntMap Int\ninsWith xs m = foldl\' (\\m (k, v) -> M.insertWith (+) k v m) m xs\n\ninsWithKey :: [(Int, Int)] -> M.IntMap Int -> M.IntMap Int\ninsWithKey xs m = foldl\' (\\m (k, v) -> M.insertWithKey add3 k v m) m xs\n\ninsWith\' :: [(Int, Int)] -> M.IntMap Int -> M.IntMap Int\ninsWith\' xs m = foldl\' (\\m (k, v) -> MS.insertWith (+) k v m) m xs\n\ninsWithKey\' :: [(Int, Int)] -> M.IntMap Int -> M.IntMap Int\ninsWithKey\' xs m = foldl\' (\\m (k, v) -> MS.insertWithKey add3 k v m) m xs\n\ndata PairS a b = PS !a !b\n\ninsLookupWithKey :: [(Int, Int)] -> M.IntMap Int -> (Int, M.IntMap Int)\ninsLookupWithKey xs m = let !(PS a b) = foldl\' f (PS 0 m) xs in (a, b)\n  where\n    f (PS n m) (k, v) = let !(n\', m\') = M.insertLookupWithKey add3 k v m\n                        in PS (fromMaybe 0 n\' + n) m\'\n\ndel :: [Int] -> M.IntMap Int -> M.IntMap Int\ndel xs m = foldl\' (\\m k -> M.delete k m) m xs\n\nupd :: [Int] -> M.IntMap Int -> M.IntMap Int\nupd xs m = foldl\' (\\m k -> M.update Just k m) m xs\n\nupd\' :: [Int] -> M.IntMap Int -> M.IntMap Int\nupd\' xs m = foldl\' (\\m k -> snd $ M.updateLookupWithKey (\\_ a -> Just a) k m) m xs\n\nalt :: [Int] -> M.IntMap Int -> M.IntMap Int\nalt xs m = foldl\' (\\m k -> M.alter id k m) m xs\n\nmaybeDel :: Int -> Maybe Int\nmaybeDel n | n `mod` 3 == 0 = Nothing\n           | otherwise      = Just n\n\n------------------------------------------------------------\ninterleave :: [Int] -> [Int] -> [Int]\ninterleave [] ys = ys\ninterleave (x:xs) (y:ys) = x : y : interleave xs ys\n'