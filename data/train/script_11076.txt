b'{-# LANGUAGE OverloadedStrings #-}\n\nmodule Test.UnicodeCMap\n(\n  spec,\n)\nwhere\n\nimport Pdf.Content.UnicodeCMap\n\nimport Data.Either\nimport qualified Data.List as List\nimport qualified Data.Map as Map\nimport Data.Maybe\nimport qualified Data.ByteString as ByteString\nimport Test.Hspec\n\nspec :: Spec\nspec = describe "UnicodeCMap" $ do\n  parseUnicodeCMapSpec\n  unicodeCMapDecodeGlyphSpec\n  unicodeCMapNextGlyphSpec\n\nparseUnicodeCMapSpec :: Spec\nparseUnicodeCMapSpec = describe "parseUnicodeCMap" $ do\n  it "should parse trivial cmap" $ do\n    let input = ByteString.concat\n          [ "0 begincodespacerange\\n"\n          , "0 beginbfchar\\n"\n          , "0 beginbfrange\\n"\n          ]\n        res = parseUnicodeCMap input\n    res `shouldSatisfy` isRight\n\n  it "should parse codespace ranges" $ do\n    let input = ByteString.concat\n          [ "1 begincodespacerange\\n"\n          , "<0000> <FFFF>\\n"\n          , "0 beginbfchar\\n"\n          , "0 beginbfrange\\n"\n          ]\n        res = parseUnicodeCMap input\n    fmap unicodeCMapCodeRanges res `shouldBe`\n      Right [ (ByteString.pack [0, 0], ByteString.pack [255, 255])]\n\n  it "should parse chars" $ do\n    let input = ByteString.concat\n          [ "0 begincodespacerange\\n"\n          , "1 beginbfchar\\n"\n          , "<3A51> <D840DC3E>\\n"\n          , "0 beginbfrange\\n"\n          ]\n        res = parseUnicodeCMap input\n    fmap unicodeCMapChars res `shouldBe`\n      Right (Map.fromList [(14929,"\\131134")])\n\n  it "should parse multiple chars" $ do\n    let input = ByteString.concat\n          [ "0 begincodespacerange\\n"\n          , "1 beginbfchar\\n"\n          , "<25> <00660066>\\n"\n          , "endbfchar\\n"\n          , "1 beginbfchar\\n"\n          , "<26> <0066006c>\\n"\n          , "endbfchar\\n"\n          , "0 beginbfrange\\n"\n          ]\n        res = parseUnicodeCMap input\n    fmap unicodeCMapChars res `shouldBe`\n      Right (Map.fromList [(37,"ff"), (38, "fl")])\n\n  it "should parse ranges" $ do\n    let input = ByteString.concat\n          [ "0 begincodespacerange\\n"\n          , "0 beginbfchar\\n"\n          , "1 beginbfrange\\n"\n          , "<0000> <005E> <0020>\\n"\n          ]\n        res = parseUnicodeCMap input\n    fmap unicodeCMapRanges res `shouldBe`\n      Right [(0,94,\' \')]\n\n  it "should parse multiple ranges" $ do\n    let input = ByteString.concat\n          [ "0 begincodespacerange\\n"\n          , "0 beginbfchar\\n"\n          , "1 beginbfrange\\n"\n          , "<21> <21> <0045>\\n"\n          , "endbfrange\\n"\n          , "1 beginbfrange\\n"\n          , "<22> <22> <0073>\\n"\n          , "endbfrange\\n"\n          ]\n        res = parseUnicodeCMap input\n    fmap (List.sort . unicodeCMapRanges) res `shouldBe`\n      Right (List.sort [(33,33,\'E\'), (34, 34, \'s\')])\n\n  it "should parse array ranges into char map" $ do\n    let input = ByteString.concat\n          [ "0 begincodespacerange\\n"\n          , "0 beginbfchar\\n"\n          , "1 beginbfrange\\n"\n          , "<005F> <0061> [<00660066> <00660069> <00660066006C>]\\n"\n          ]\n        res = parseUnicodeCMap input\n    fmap unicodeCMapChars res `shouldBe`\n      Right (Map.fromList [(95,"ff"),(96,"fi"),(97,"ffl")])\n\n  it "should allow spaces in hex numbers" $ do\n    let input = ByteString.concat\n          [ "1 begincodespacerange\\n"\n          , "<0000> <FF FF>\\n"\n          , "0 beginbfchar\\n"\n          , "0 beginbfrange\\n"\n          ]\n        res = parseUnicodeCMap input\n    fmap unicodeCMapCodeRanges res `shouldBe`\n      Right [ (ByteString.pack [0, 0], ByteString.pack [255, 255])]\n\nunicodeCMapDecodeGlyphSpec :: Spec\nunicodeCMapDecodeGlyphSpec = describe "unicodeCMapDecodeGlyph" $ do\n  it "should take glyph from char map if possible" $ do\n    let cmap = UnicodeCMap [] charMap []\n        charMap = Map.fromList [(42, "hello")]\n\n    let res = unicodeCMapDecodeGlyph cmap 42\n    res `shouldBe` Just "hello"\n\n  it "should be able to decode the first glyph from a range" $ do\n    let cmap = UnicodeCMap [] mempty [(10, 15, \'1\')]\n\n    let res = unicodeCMapDecodeGlyph cmap 10\n    res `shouldBe` Just "1"\n\n  it "should be able to decode the last glyph from a range" $ do\n    let cmap = UnicodeCMap [] mempty [(10, 15, \'1\')]\n\n    let res = unicodeCMapDecodeGlyph cmap 15\n    res `shouldBe` Just "6"\n\n  it "should be able to decode a glyph from a middle of a range" $ do\n    let cmap = UnicodeCMap [] mempty [(10, 15, \'1\')]\n\n    let res = unicodeCMapDecodeGlyph cmap 11\n    res `shouldBe` Just "2"\n\n  it "should not decode a glyph before a range" $ do\n    let cmap = UnicodeCMap [] mempty [(10, 15, \'1\')]\n\n    let res = unicodeCMapDecodeGlyph cmap 9\n    res `shouldBe` Nothing\n\n  it "should not decode a glyph after a range" $ do\n    let cmap = UnicodeCMap [] mempty [(10, 15, \'1\')]\n\n    let res = unicodeCMapDecodeGlyph cmap 16\n    res `shouldBe` Nothing\n\nunicodeCMapNextGlyphSpec :: Spec\nunicodeCMapNextGlyphSpec = describe "unicodeCMapNextGlyph" $ do\n  it "correctly handles multibyte ranges" $ do\n    let cmap = UnicodeCMap [("\\0\\0", "\\1\\1")] mempty []\n    let (code, rest) = fromJust $ unicodeCMapNextGlyph cmap "\\1\\0rest"\n    rest `shouldBe` rest\n    code `shouldBe` 256\n'