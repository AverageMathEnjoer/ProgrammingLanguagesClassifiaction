b'module Rest.Gen.Base.ApiTree\n  ( ApiAction (..)\n  , ApiResource (..)\n  , allResourceIds\n  , allSubResourceIds\n  , allSubResources\n  , allSubTrees\n  , allTrees\n  , apiResources\n  , apiSubtrees\n  , apiTree\n  , apiTree\'\n  , cleanName\n  , defaultTree\n  , foldTree\n  , foldTreeChildren\n  , hasAccessor\n  , mkFuncParts\n  , noPrivate\n  , resIdents\n  , sortTree\n  , subResourceIds\n  , subResourceNames\n  ) where\n\nimport Data.Char\nimport Data.Function\nimport Data.List\nimport Data.Maybe\n\nimport Rest.Api (Router (..), Some1 (..))\nimport Rest.Gen.Base.ActionInfo\nimport Rest.Gen.Base.Link\nimport Rest.Gen.Utils\nimport qualified Rest.Resource as Res\n\ndata ApiAction =\n  ApiAction\n    { itemResource :: ResourceId\n    , itemLink     :: Link\n    , itemInfo     :: ActionInfo\n    } deriving (Show, Eq)\n\ndata ApiResource =\n  TreeItem\n    { resName        :: String\n    , resId          :: ResourceId\n    , resParents     :: ResourceId\n    , resLink        :: Link\n    , resAccessors   :: [Accessor]\n    , resPrivate     :: Bool\n    , resItems       :: [ApiAction]\n    , resDescription :: String\n    , subResources   :: [ApiResource]\n    } deriving (Show, Eq)\n\nresIdents :: ApiResource -> [Link]\nresIdents = return . accessLink . resAccessors\n\napiSubtrees :: Router m s -> ApiResource\napiSubtrees (Embed _ routes) = defaultTree { subResources = map (\\(Some1 r) -> apiTree r) routes }\n\napiTree :: Router m s -> ApiResource\napiTree = apiTree\' [] []\n\napiTree\' :: ResourceId -> Link -> Router m s -> ApiResource\napiTree\' rid lnk (Embed r routes) =\n    let myId  = rid ++ [Res.name r]\n        myLnk = lnk ++ [LResource (Res.name r)]\n        as    = resourceToAccessors r\n    in TreeItem\n        { resName        = Res.name r\n        , resId          = myId\n        , resParents     = rid\n        , resLink        = myLnk\n        , resAccessors   = as\n        , resPrivate     = Res.private r\n        , resItems       = [ ApiAction myId (myLnk ++ link ai) ai | ai <- resourceToActionInfo r ]\n        , resDescription = Res.description r\n        , subResources   = map (\\(Some1 chd) -> apiTree\' myId (myLnk ++ [LAccess [accessLink as]]) chd) routes\n        }\n\ndefaultTree :: ApiResource\ndefaultTree = TreeItem "" [] [] [] [] False [] "" []\n\n-- | Traversing ApiResources\nfoldTree :: (ApiResource -> [a] -> a) -> ApiResource -> a\nfoldTree f tr = f tr (map (foldTree f) (subResources tr))\n\nfoldTreeChildren :: ([a] -> a) -> (ApiResource -> [a] -> a) -> ApiResource -> a\nfoldTreeChildren f1 f2 = f1 . map (foldTree f2) . subResources\n\nnoPrivate :: ApiResource -> ApiResource\nnoPrivate = foldTree $ \\it subs -> it { subResources = filter (not . resPrivate) subs }\n\nsortTree :: ApiResource -> ApiResource\nsortTree = foldTree $ \\it subs -> it { subResources = sortBy (compare `on` resName) subs }\n\nallTrees :: ApiResource -> [ApiResource]\nallTrees = foldTree $ \\it subs -> it : concat subs\n\nallSubTrees :: ApiResource -> [ApiResource]\nallSubTrees = foldTreeChildren concat $ \\it subs -> it : concat subs\n\napiResources :: ApiResource -> [ResourceId]\napiResources = foldTree $ \\it subs -> map (resName it:) ([] : concat subs)\n\nallResources :: ApiResource -> [ApiResource]\nallResources = foldTree $ \\it -> (it:) . concat\n\nallSubResources :: ApiResource -> [ApiResource]\nallSubResources = foldTreeChildren concat $ \\it -> (it:) . concat\n\nallResourceIds :: ApiResource -> [ResourceId]\nallResourceIds = map resId . allResources\n\nallSubResourceIds :: ApiResource -> [ResourceId]\nallSubResourceIds = map resId . allSubResources\n\nsubResourceNames :: ApiResource -> [String]\nsubResourceNames = map resName . subResources\n\nsubResourceIds :: ApiResource -> [ResourceId]\nsubResourceIds = map resId . subResources\n\nhasAccessor :: ApiResource -> Bool\nhasAccessor = not . null . resIdents\n\n-- | Extra functions for generation\nmkFuncParts :: ApiAction -> [String]\nmkFuncParts (ApiAction _ _ ai) = concatMap cleanName parts\n  where\n      parts = case actionType ai of\n                Retrieve   -> let nm = get ++ by ++ target\n                              in if null nm then ["access"] else nm\n                Create     -> ["create"]     ++ by ++ target\n                -- Should be delete, but delete is a JS keyword and causes problems in collect.\n                Delete     -> ["remove"]     ++ by ++ target\n                DeleteMany -> ["removeMany"] ++ by ++ target\n                List       -> ["list"]       ++ by ++ target\n                Update     -> ["save"]       ++ by ++ target\n                UpdateMany -> ["saveMany"]   ++ by ++ target\n                Modify     -> if resDir ai == "" then ["do"] else [resDir ai]\n\n      target = if resDir ai == ""                then [] else [resDir ai]\n      by     = if null target\n               ||    isNothing (ident ai)\n                  && actionType ai /= UpdateMany\n                  && actionType ai /= DeleteMany then [] else ["by"]\n      get    = if isAccessor ai                  then [] else ["get"]\n\ncleanName :: String -> [String]\ncleanName ""         = [""]\ncleanName (\'-\':v:rs) = [] : mapHead (mapHead toUpper) (cleanName (v: rs))\ncleanName (x : xs) | isAlphaNum x = mapHead (x:) $ cleanName xs\n                   | otherwise    = cleanName xs\n'