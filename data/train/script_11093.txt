b'#include "stdafx.h"\n#include "../inc/half.hpp"\n#include "TextureFileFormat.h"\n#include <texgenpack.h>\n#include <ispc_texcomp.h>\n#include <astcenc.h>\n#include <CrnlibWrap.h>\n#define WIN32_LEAN_AND_MEAN\n#define NOMINMAX\n#include <Windows.h>\n#include <assert.h>\n#include <thread>\n\nstruct HalfFloat\n{\n\tunsigned short half;\n\t//http://stackoverflow.com/questions/6162651/half-precision-floating-point-in-java/6162687#6162687\n\tinline float toFloat()\n\t{\n\t\treturn half_float::detail::half2float(half);\n\t}\n\tinline void toHalf(float f)\n\t{\n\t\thalf = half_float::detail::float2half<std::round_to_nearest>(f);\n\t}\n};\nstruct RGB9e5Float\n{\n\tunsigned __int32 value;\n\tinline void toRGB9e5(float in[3])\n\t{\n\t\tstatic const float highestFloat = 65408.0;\n\n\t\tfloat r = in[0];\n\t\tfloat g = in[1];\n\t\tfloat b = in[2];\n\n\t\tif (r <= 0.0) r = 0.0;\n\t\telse if (r >= highestFloat) r = highestFloat;\n\n\t\tif (g <= 0.0) g = 0.0;\n\t\telse if (g >= highestFloat) g = highestFloat;\n\t\t\n\t\tif (b <= 0.0) b = 0.0;\n\t\telse if (b >= highestFloat) b = highestFloat;\n\n\t\tfloat tempColor;\n\t\tif (r > g) tempColor = r;\n\t\telse tempColor = g;\n\t\tif (tempColor <= b) tempColor = b;\n\t\t\n\t\tint tempExponent = (int)( ((*((unsigned int*)(&tempColor)) >> 23) & 0xFF) - 127 );\n\t\tif (tempExponent < -16) tempExponent = -16;\n\t\ttempExponent += 16;\n\t\tint curExponentVal = tempExponent - 24;\n\t\tint exponentVal = curExponentVal;\n\t\tif (curExponentVal < 0) curExponentVal = -curExponentVal;\n\t\tif (curExponentVal < 0) curExponentVal = std::numeric_limits<int>::max();\n\t\t\n\t\tfloat factorA = 2.0F;\n\t\tfloat factorB = 1.0F;\n\t\twhile (curExponentVal & 1)\n\t\t{\n\t\t\tif (curExponentVal & 1)\n\t\t\t\tfactorB *= factorA;\n\t\t\tfactorA *= factorA;\n\t\t\tcurExponentVal >>= 1;\n\t\t}\n\t\t\n\t\tfloat factorC;\n\t\tif (exponentVal < 0)\n\t\t\tfactorC = 1.0 / factorB;\n\t\telse\n\t\t\tfactorC = factorB;\n\n\t\ttempColor /= factorC;\n\t\tif ( ((int)floor((double)tempColor + 0.5)) == 512 )\n\t\t{\n\t\t\tfactorC *= 2.0;\n\t\t\ttempExponent++;\n\t\t}\n\n\t\tunsigned int newValue = tempExponent;\n\t\tnewValue <<= 9;\n\t\tnewValue |= ((unsigned int)floorf((b / factorC) + 0.5)) & 0x1FF;\n\t\tnewValue <<= 9;\n\t\tnewValue |= ((unsigned int)floorf((g / factorC) + 0.5)) & 0x1FF;\n\t\tnewValue <<= 9;\n\t\tnewValue |= ((unsigned int)floorf((r / factorC) + 0.5)) & 0x1FF;\n\n\t\tvalue = newValue;\n\t}\n\tinline void toFloat(float out[3])\n\t{\n\t\tunsigned int tempFloat_Int = ((value >> 4) & 0x0F800000) + 0x33800000;\n\t\tfloat exponentFloat = *((float*)&tempFloat_Int);\n\t\tout[0] = (float)(value & 0x1FF) * exponentFloat;\n\t\tout[1] = (float)((value >> 9) & 0x1FF) * exponentFloat;\n\t\tout[2] = (float)((value >> 18) & 0x1FF) * exponentFloat;\n\t}\n};\n\nenum TextureFileFields //enumeration for the array that stores the fields in ReadTextureFile\n{\n\t//fields that aren\'t in all versions\n\tTextureFileField_MipCount,\n\tTextureFileField_MipMap,\n\tTextureFileField_ReadAllowed,\n\t//fields that always must be there\n\tTextureFileField_Name,\n\tTextureFileField_Width,\n\tTextureFileField_Height,\n\tTextureFileField_CompleteImageSize,\n\tTextureFileField_TextureFormat,\n\tTextureFileField_IsReadable,\n\tTextureFileField_ImageCount,\n\tTextureFileField_TextureDimension,\n\tTextureFileField_FilterMode,\n\tTextureFileField_Aniso,\n\tTextureFileField_MipBias,\n\tTextureFileField_WrapMode, //except me (since U2017.1), replaced by WrapU&V&W\n\tTextureFileField_LightmapFormat,\n\tTextureFileField_ColorSpace, //and me (before U3.5)\n\tTextureFileField_ImageData,\n\t//fields added in later versions\n\tTextureFileField_StreamingInfo_offset,\n\tTextureFileField_StreamingInfo_size,\n\tTextureFileField_StreamingInfo_path,\n\tTextureFileField_WrapU,\n\tTextureFileField_WrapV,\n\tTextureFileField_WrapW,\n\tTextureFileField_ForcedFallbackFormat,\n\tTextureFileField_DownscaleFallback,\n\tTextureFileField_StreamingMipmaps,\n\tTextureFileField_StreamingMipmapsPriority,\n\tTextureFileField_IgnoreMasterTextureLimit,\n\tTextureFileField_IsPreProcessed,\n\tTextureFileField_MipsStripped,\n\tTextureFileField_IsAlphaChannelOptional,\n\tTextureFileField_PlatformBlob,\n\tTextureFileField_Max\n};\nASSETSTOOLS_API void PreprocessTextureTemplate(AssetTypeTemplateField& templateBase)\n{\n\tif (AssetTypeTemplateField* pPlatformBlobField = templateBase.SearchChild("m_PlatformBlob"))\n\t{\n\t\tif (AssetTypeTemplateField* pArrayField = pPlatformBlobField->SearchChild("Array"))\n\t\t\tpArrayField->type = "TypelessData"; //Treat as byte array instead of generic array to lower the overhead.\n\t}\n}\nASSETSTOOLS_API bool ReadTextureFile(TextureFile *pOutTex, AssetTypeValueField *pBaseField)\n{\n\t//Last checked: 2021.2.17f1\n\tAssetTypeValueField *fields[TextureFileField_Max] = \n\t{\n\t\tpBaseField->Get("m_MipCount"), //added in U5.2\n\t\tpBaseField->Get("m_MipMap"), //removed in U5.2\n\t\tpBaseField->Get("m_ReadAllowed"), //removed in U5.5\n\n\t\tpBaseField->Get("m_Name"),\n\t\tpBaseField->Get("m_Width"),\n\t\tpBaseField->Get("m_Height"),\n\t\tpBaseField->Get("m_CompleteImageSize"), //Since 2020.1: unsigned int, before: int\n\t\tpBaseField->Get("m_TextureFormat"),\n\t\tpBaseField->Get("m_IsReadable"),\n\t\tpBaseField->Get("m_ImageCount"),\n\t\tpBaseField->Get("m_TextureDimension"),\n\t\tpBaseField->Get("m_TextureSettings")->Get("m_FilterMode"),\n\t\tpBaseField->Get("m_TextureSettings")->Get("m_Aniso"),\n\t\tpBaseField->Get("m_TextureSettings")->Get("m_MipBias"),\n\t\tpBaseField->Get("m_TextureSettings")->Get("m_WrapMode"), //removed in U2017.1\n\t\tpBaseField->Get("m_LightmapFormat"),\n\t\tpBaseField->Get("m_ColorSpace"), //added in U3.5\n\t\tpBaseField->Get("image data"),\n\n\t\t//added in U5.3\n\t\tpBaseField->Get("m_StreamData")->Get("offset"), //Since 2020.1: UInt64, before: unsigned int\n\t\tpBaseField->Get("m_StreamData")->Get("size"),\n\t\tpBaseField->Get("m_StreamData")->Get("path"),\n\t\t//added in U2017.1\n\t\tpBaseField->Get("m_TextureSettings")->Get("m_WrapU"),\n\t\tpBaseField->Get("m_TextureSettings")->Get("m_WrapV"),\n\t\tpBaseField->Get("m_TextureSettings")->Get("m_WrapW"),\n\t\t//added in U2017.3\n\t\tpBaseField->Get("m_ForcedFallbackFormat"),\n\t\tpBaseField->Get("m_DownscaleFallback"),\n\t\t//added in U2018.2\n\t\tpBaseField->Get("m_StreamingMipmaps"),\n\t\tpBaseField->Get("m_StreamingMipmapsPriority"),\n\t\t//added in U2019.3\n\t\tpBaseField->Get("m_IgnoreMasterTextureLimit"), //bool\n\t\t//added in U2019.4\n\t\tpBaseField->Get("m_IsPreProcessed"), //bool\n\t\t//added in U2020.1\n\t\tpBaseField->Get("m_MipsStripped"), //int\n\t\t//added in U2020.2\n\t\tpBaseField->Get("m_IsAlphaChannelOptional"), //bool\n\t\tpBaseField->Get("m_PlatformBlob")->Get("Array"), //Array(UInt8) or TypelessData(UInt8) after PreprocessTextureTemplate.\n\t};\n\tfor (int i = TextureFileField_Name; i < TextureFileField_StreamingInfo_offset; i++)\n\t{\n\t\t//color space added in U3.5, wrap mode removed in U2017.1\n\t\tif (fields[i]->IsDummy() && i != TextureFileField_ColorSpace && i != TextureFileField_WrapMode)\n\t\t\treturn false;\n\t}\n\tif (fields[TextureFileField_StreamingInfo_offset]->IsDummy() != fields[TextureFileField_StreamingInfo_size]->IsDummy() ||\n\t\tfields[TextureFileField_StreamingInfo_size]->IsDummy() != fields[TextureFileField_StreamingInfo_path]->IsDummy())\n\t\treturn false;\n\tif (fields[TextureFileField_WrapMode]->IsDummy() == (fields[TextureFileField_WrapU]->IsDummy() ||\n\t\tfields[TextureFileField_WrapV]->IsDummy() || fields[TextureFileField_WrapW]->IsDummy()))\n\t\treturn false;\n\tif (!fields[TextureFileField_MipCount]->IsDummy())\n\t{\n\t\tpOutTex->m_MipCount = fields[TextureFileField_MipCount]->GetValue()->AsInt();\n\t\tpOutTex->m_MipMap = pOutTex->m_MipCount > 1;\n\t}\n\telse if (!fields[TextureFileField_MipMap]->IsDummy())\n\t{\n\t\tpOutTex->m_MipCount = -1; //unknown\n\t\tpOutTex->m_MipMap = fields[TextureFileField_MipMap]->GetValue()->AsBool();\n\t}\n\telse\n\t\treturn false;\n\tpOutTex->m_Name = fields[TextureFileField_Name]->GetValue()->AsString();\n\tpOutTex->m_ForcedFallbackFormat = fields[TextureFileField_ForcedFallbackFormat]->IsDummy() \n\t\t? 0 : fields[TextureFileField_ForcedFallbackFormat]->GetValue()->AsInt();\n\tpOutTex->m_DownscaleFallback = fields[TextureFileField_DownscaleFallback]->IsDummy() \n\t\t? false : fields[TextureFileField_DownscaleFallback]->GetValue()->AsBool();\n\tpOutTex->m_IsAlphaChannelOptional = fields[TextureFileField_IsAlphaChannelOptional]->IsDummy()\n\t\t? false : fields[TextureFileField_IsAlphaChannelOptional]->GetValue()->AsBool();\n\tpOutTex->m_Width = fields[TextureFileField_Width]->GetValue()->AsUInt();\n\tpOutTex->m_Height = fields[TextureFileField_Height]->GetValue()->AsUInt();\n\tpOutTex->m_CompleteImageSize = fields[TextureFileField_CompleteImageSize]->GetValue()->AsUInt();\n\tpOutTex->m_MipsStripped = fields[TextureFileField_MipsStripped]->IsDummy()\n\t\t? 0 : fields[TextureFileField_MipsStripped]->GetValue()->AsInt();\n\tpOutTex->m_TextureFormat = fields[TextureFileField_TextureFormat]->GetValue()->AsUInt();\n\tpOutTex->m_IsReadable = fields[TextureFileField_IsReadable]->GetValue()->AsBool();\n\tpOutTex->m_IsPreProcessed = fields[TextureFileField_IsPreProcessed]->IsDummy()\n\t\t? 0 : fields[TextureFileField_IsPreProcessed]->GetValue()->AsBool();\n\tpOutTex->m_ReadAllowed = fields[TextureFileField_ReadAllowed]->IsDummy()\n\t\t? true : fields[TextureFileField_ReadAllowed]->GetValue()->AsBool();\n\tpOutTex->m_IgnoreMasterTextureLimit = fields[TextureFileField_IgnoreMasterTextureLimit]->IsDummy()\n\t\t? 0 : fields[TextureFileField_IgnoreMasterTextureLimit]->GetValue()->AsBool();\n\tpOutTex->m_StreamingMipmaps = fields[TextureFileField_StreamingMipmaps]->IsDummy()\n\t\t? true : fields[TextureFileField_StreamingMipmaps]->GetValue()->AsBool();\n\tpOutTex->m_StreamingMipmapsPriority = fields[TextureFileField_StreamingMipmapsPriority]->IsDummy()\n\t\t? 0 : fields[TextureFileField_StreamingMipmapsPriority]->GetValue()->AsInt();\n\tpOutTex->m_ImageCount = fields[TextureFileField_ImageCount]->GetValue()->AsInt();\n\tpOutTex->m_TextureDimension = fields[TextureFileField_TextureDimension]->GetValue()->AsInt();\n\tpOutTex->m_TextureSettings.m_FilterMode = fields[TextureFileField_FilterMode]->GetValue()->AsInt();\n\tpOutTex->m_TextureSettings.m_Aniso = fields[TextureFileField_Aniso]->GetValue()->AsInt();\n\tpOutTex->m_TextureSettings.m_MipBias = fields[TextureFileField_MipBias]->GetValue()->AsFloat();\n\tpOutTex->m_TextureSettings.m_WrapMode = fields[TextureFileField_WrapMode]->IsDummy()\n\t\t? 0 : fields[TextureFileField_WrapMode]->GetValue()->AsInt();\n\tpOutTex->m_TextureSettings.m_WrapU = fields[TextureFileField_WrapU]->IsDummy()\n\t\t? 0 : fields[TextureFileField_WrapU]->GetValue()->AsInt();\n\tpOutTex->m_TextureSettings.m_WrapV = fields[TextureFileField_WrapV]->IsDummy()\n\t\t? 0 : fields[TextureFileField_WrapV]->GetValue()->AsInt();\n\tpOutTex->m_TextureSettings.m_WrapW = fields[TextureFileField_WrapW]->IsDummy()\n\t\t? 0 : fields[TextureFileField_WrapW]->GetValue()->AsInt();\n\tpOutTex->m_LightmapFormat = fields[TextureFileField_LightmapFormat]->GetValue()->AsInt();\n\tif (!fields[TextureFileField_ColorSpace]->IsDummy())\n\t\tpOutTex->m_ColorSpace = fields[TextureFileField_ColorSpace]->GetValue()->AsInt();\n\telse\n\t\tpOutTex->m_ColorSpace = 0;\n\tpOutTex->m_PlatformBlob.clear();\n\tif (!fields[TextureFileField_PlatformBlob]->IsDummy())\n\t{\n\t\tif (auto* pByteArray = fields[TextureFileField_PlatformBlob]->GetValue()->AsByteArray())\n\t\t\tpOutTex->m_PlatformBlob.assign(&pByteArray->data[0], &pByteArray->data[pByteArray->size]);\n\t\telse if (auto* pArray = fields[TextureFileField_PlatformBlob]->GetValue()->AsArray())\n\t\t{\n\t\t\tif (pArray->size == fields[TextureFileField_PlatformBlob]->GetChildrenCount())\n\t\t\t{\n\t\t\t\tpOutTex->m_PlatformBlob.resize(pArray->size);\n\t\t\t\tfor (unsigned int i = 0; i < pArray->size; ++i)\n\t\t\t\t{\n\t\t\t\t\tauto *pCurByteField = fields[TextureFileField_PlatformBlob]->Get(i);\n\t\t\t\t\tif (pCurByteField->GetValue() && pCurByteField->GetValue()->GetType() == ValueType_UInt8)\n\t\t\t\t\t\tpOutTex->m_PlatformBlob[i] = (uint8_t)pCurByteField->GetValue()->AsUInt();\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t\tassert(false);\n\t\t}\n\t}\n\tpOutTex->_pictureDataSize = fields[TextureFileField_ImageData]->GetValue()->AsByteArray()->size;\n\tpOutTex->pPictureData = fields[TextureFileField_ImageData]->GetValue()->AsByteArray()->data;\n\tmemcpy(pOutTex->pPictureData, pOutTex->pPictureData, pOutTex->_pictureDataSize);\n\tif (!fields[TextureFileField_StreamingInfo_offset]->IsDummy())\n\t{\n\t\tpOutTex->m_StreamData.offset = fields[TextureFileField_StreamingInfo_offset]->GetValue()->AsUInt64();\n\t\tpOutTex->m_StreamData.size = fields[TextureFileField_StreamingInfo_size]->GetValue()->AsUInt();\n\t\tpOutTex->m_StreamData.path = fields[TextureFileField_StreamingInfo_path]->GetValue()->AsString();\n\t}\n\telse\n\t{\n\t\tpOutTex->m_StreamData.offset = pOutTex->m_StreamData.size = 0;\n\t\tpOutTex->m_StreamData.path.clear();\n\t}\n\tpOutTex->extra.textureFormatVersion = 0;\n\treturn true;\n}\nASSETSTOOLS_API bool WriteTextureFile(TextureFile *pInTex, AssetTypeValueField *pBaseField,\n\tstd::vector<std::unique_ptr<uint8_t[]>>& allocatedMemory)\n{\n\tAssetTypeValueField *fields[] = \n\t{\n\t\tpBaseField->Get("m_MipCount"), //added in U5.2\n\t\tpBaseField->Get("m_MipMap"), //not in U5.2\n\t\tpBaseField->Get("m_ReadAllowed"), //removed in U5.5\n\n\t\tpBaseField->Get("m_Name"),\n\t\tpBaseField->Get("m_Width"),\n\t\tpBaseField->Get("m_Height"),\n\t\tpBaseField->Get("m_CompleteImageSize"),\n\t\tpBaseField->Get("m_TextureFormat"),\n\t\tpBaseField->Get("m_IsReadable"),\n\t\tpBaseField->Get("m_ImageCount"),\n\t\tpBaseField->Get("m_TextureDimension"),\n\t\tpBaseField->Get("m_TextureSettings")->Get("m_FilterMode"),\n\t\tpBaseField->Get("m_TextureSettings")->Get("m_Aniso"),\n\t\tpBaseField->Get("m_TextureSettings")->Get("m_MipBias"),\n\t\tpBaseField->Get("m_TextureSettings")->Get("m_WrapMode"), //removed in U2017.1\n\t\tpBaseField->Get("m_LightmapFormat"),\n\t\tpBaseField->Get("m_ColorSpace"), //added in U3.5\n\t\tpBaseField->Get("image data"),\n\n\t\t//added in U5.3\n\t\tpBaseField->Get("m_StreamData")->Get("offset"), \n\t\tpBaseField->Get("m_StreamData")->Get("size"),\n\t\tpBaseField->Get("m_StreamData")->Get("path"),\n\t\t//added in U2017.1\n\t\tpBaseField->Get("m_TextureSettings")->Get("m_WrapU"),\n\t\tpBaseField->Get("m_TextureSettings")->Get("m_WrapV"),\n\t\tpBaseField->Get("m_TextureSettings")->Get("m_WrapW"),\n\t\t//added in U2017.3\n\t\tpBaseField->Get("m_ForcedFallbackFormat"),\n\t\tpBaseField->Get("m_DownscaleFallback"),\n\t\t//added in U2018.2\n\t\tpBaseField->Get("m_StreamingMipmaps"),\n\t\tpBaseField->Get("m_StreamingMipmapsPriority"),\n\t\t//added in U2019.3\n\t\tpBaseField->Get("m_IgnoreMasterTextureLimit"), //bool\n\t\t//added in U2019.4\n\t\tpBaseField->Get("m_IsPreProcessed"), //bool\n\t\t//added in U2020.1\n\t\tpBaseField->Get("m_MipsStripped"), //int\n\t\t//added in U2020.2\n\t\tpBaseField->Get("m_IsAlphaChannelOptional"), //bool\n\t\tpBaseField->Get("m_PlatformBlob")->Get("Array"), //Array(UInt8) or TypelessData(UInt8) after PreprocessTextureTemplate.\n\t};\n\tfor (int i = TextureFileField_Name; i < TextureFileField_StreamingInfo_offset; i++)\n\t{\n\t\t//color space added in U3.5, wrap mode removed in U2017.1\n\t\tif (fields[i]->IsDummy() && i != TextureFileField_ColorSpace && i != TextureFileField_WrapMode)\n\t\t\treturn false;\n\t}\n\tif (fields[TextureFileField_StreamingInfo_offset]->IsDummy() != fields[TextureFileField_StreamingInfo_size]->IsDummy() ||\n\t\tfields[TextureFileField_StreamingInfo_size]->IsDummy() != fields[TextureFileField_StreamingInfo_path]->IsDummy())\n\t\treturn false;\n\tif (fields[TextureFileField_WrapMode]->IsDummy() == (fields[TextureFileField_WrapU]->IsDummy() ||\n\t\tfields[TextureFileField_WrapV]->IsDummy() || fields[TextureFileField_WrapW]->IsDummy()))\n\t\treturn false;\n\tif (fields[TextureFileField_StreamingMipmaps]->IsDummy() != fields[TextureFileField_StreamingMipmapsPriority]->IsDummy())\n\t\treturn false;\n\tif (!fields[TextureFileField_MipCount]->IsDummy())\n\t{\n\t\tfields[TextureFileField_MipCount]->GetValue()->Set(&pInTex->m_MipCount, ValueType_Int32);\n\t}\n\telse if (!fields[TextureFileField_MipMap]->IsDummy())\n\t{\n\t\tfields[TextureFileField_MipMap]->GetValue()->Set(&pInTex->m_MipMap, ValueType_Bool);\n\t}\n\telse\n\t\treturn false;\n\n\tfields[TextureFileField_Name]->GetValue()->Set(const_cast<char*>(pInTex->m_Name.c_str()));\n\n\tif (!fields[TextureFileField_ForcedFallbackFormat]->IsDummy())\n\t\tfields[TextureFileField_ForcedFallbackFormat]->GetValue()->Set(&pInTex->m_ForcedFallbackFormat, ValueType_Int32);\n\tif (!fields[TextureFileField_DownscaleFallback]->IsDummy())\n\t\tfields[TextureFileField_DownscaleFallback]->GetValue()->Set(&pInTex->m_DownscaleFallback, ValueType_Bool);\n\tif (!fields[TextureFileField_IsAlphaChannelOptional]->IsDummy())\n\t\tfields[TextureFileField_IsAlphaChannelOptional]->GetValue()->Set(&pInTex->m_IsAlphaChannelOptional, ValueType_Bool);\n\n\tfields[TextureFileField_Width]->GetValue()->Set(&pInTex->m_Width, ValueType_UInt32);\n\tfields[TextureFileField_Height]->GetValue()->Set(&pInTex->m_Height, ValueType_UInt32);\n\tfields[TextureFileField_CompleteImageSize]->GetValue()->Set(&pInTex->m_CompleteImageSize, ValueType_UInt32);\n\tif (!fields[TextureFileField_MipsStripped]->IsDummy())\n\t\tfields[TextureFileField_MipsStripped]->GetValue()->Set(&pInTex->m_MipsStripped, ValueType_Int32);\n\tfields[TextureFileField_TextureFormat]->GetValue()->Set(&pInTex->m_TextureFormat, ValueType_UInt32);\n\tfields[TextureFileField_IsReadable]->GetValue()->Set(&pInTex->m_IsReadable, ValueType_Bool);\n\tif (!fields[TextureFileField_IsPreProcessed]->IsDummy())\n\t\tfields[TextureFileField_IsPreProcessed]->GetValue()->Set(&pInTex->m_IsPreProcessed, ValueType_Bool);\n\tif (!fields[TextureFileField_ReadAllowed]->IsDummy())\n\t\tfields[TextureFileField_ReadAllowed]->GetValue()->Set(&pInTex->m_ReadAllowed, ValueType_Bool);\n\tif (!fields[TextureFileField_IgnoreMasterTextureLimit]->IsDummy())\n\t\tfields[TextureFileField_IgnoreMasterTextureLimit]->GetValue()->Set(&pInTex->m_IgnoreMasterTextureLimit, ValueType_Bool);\n\tif (!fields[TextureFileField_StreamingMipmaps]->IsDummy())\n\t{\n\t\tfields[TextureFileField_StreamingMipmaps]->GetValue()->Set(&pInTex->m_StreamingMipmaps, ValueType_Bool);\n\t\tfields[TextureFileField_StreamingMipmapsPriority]->GetValue()->Set(&pInTex->m_StreamingMipmapsPriority, ValueType_Int32);\n\t}\n\tfields[TextureFileField_ImageCount]->GetValue()->Set(&pInTex->m_ImageCount, ValueType_Int32);\n\tfields[TextureFileField_TextureDimension]->GetValue()->Set(&pInTex->m_TextureDimension, ValueType_Int32);\n\tfields[TextureFileField_FilterMode]->GetValue()->Set(&pInTex->m_TextureSettings.m_FilterMode, ValueType_Int32);\n\tfields[TextureFileField_Aniso]->GetValue()->Set(&pInTex->m_TextureSettings.m_Aniso, ValueType_Int32);\n\tfields[TextureFileField_MipBias]->GetValue()->Set(&pInTex->m_TextureSettings.m_MipBias, ValueType_Float);\n\tif (!fields[TextureFileField_WrapMode]->IsDummy())\n\t\tfields[TextureFileField_WrapMode]->GetValue()->Set(&pInTex->m_TextureSettings.m_WrapMode, ValueType_Int32);\n\telse\n\t{\n\t\tfields[TextureFileField_WrapU]->GetValue()->Set(&pInTex->m_TextureSettings.m_WrapU, ValueType_Int32);\n\t\tfields[TextureFileField_WrapV]->GetValue()->Set(&pInTex->m_TextureSettings.m_WrapV, ValueType_Int32);\n\t\tfields[TextureFileField_WrapW]->GetValue()->Set(&pInTex->m_TextureSettings.m_WrapW, ValueType_Int32);\n\t}\n\tfields[TextureFileField_LightmapFormat]->GetValue()->Set(&pInTex->m_LightmapFormat, ValueType_Int32);\n\tif (!fields[TextureFileField_ColorSpace]->IsDummy()) //color space added in U3.5\n\t\tfields[TextureFileField_ColorSpace]->GetValue()->Set(&pInTex->m_ColorSpace, ValueType_Int32);\n\tif (!fields[TextureFileField_PlatformBlob]->IsDummy())\n\t{\n\t\t//Create an AssetTypeValue of type ByteArray.\n\t\tuint8_t* valueMem = new uint8_t[sizeof(AssetTypeValue)];\n\t\tallocatedMemory.emplace_back(valueMem);\n\t\tAssetTypeValue* pNewValue = (AssetTypeValue*)valueMem;\n\t\tAssetTypeByteArray byteArray = {};\n\t\tbyteArray.data = pInTex->m_PlatformBlob.data();\n\t\tbyteArray.size = (uint32_t)std::min<size_t>(pInTex->m_PlatformBlob.size(), std::numeric_limits<uint32_t>::max());\n\t\t*pNewValue = AssetTypeValue(ValueType_ByteArray, &byteArray);\n\t\t//Assign it to the field.\n\t\tfields[TextureFileField_PlatformBlob]->Read(pNewValue,\n\t\t\tfields[TextureFileField_PlatformBlob]->GetTemplateField(),\n\t\t\t0, nullptr);\n\t}\n\tAssetTypeByteArray byteArray;\n\tbyteArray.size = pInTex->_pictureDataSize;\n\tbyteArray.data = pInTex->pPictureData;\n\tfields[TextureFileField_ImageData]->GetValue()->Set(&byteArray, ValueType_ByteArray);\n\tif (!fields[TextureFileField_StreamingInfo_offset]->IsDummy())\n\t{\n\t\tfields[TextureFileField_StreamingInfo_offset]->GetValue()->Set(&pInTex->m_StreamData.offset, ValueType_UInt64);\n\t\tfields[TextureFileField_StreamingInfo_size]->GetValue()->Set(&pInTex->m_StreamData.size, ValueType_UInt32);\n\t\tfields[TextureFileField_StreamingInfo_path]->GetValue()->Set(const_cast<char*>(pInTex->m_StreamData.path.c_str()), ValueType_String);\n\t}\n\treturn true;\n}\n#include "EngineVersion.h"\nbool SupportsTextureFormat(AssetsFile *pAssetsFile, TextureFormat texFmt, int &version)\n{\n\tEngineVersion engineVersion = EngineVersion::parse(pAssetsFile->typeTree.unityVersion);\n\tif (engineVersion.year >= 2019\n\t\t|| pAssetsFile->header.format > 19) //>= 2019.1\n\t\tversion = 2;\n\telse if ((engineVersion.year == 2017 && engineVersion.release >= 3) || engineVersion.year > 2017\n\t\t|| pAssetsFile->header.format > 17) //>= 2017.3\n\t\tversion = 1;\n\telse\n\t\tversion = 0;\n\n\tswitch (texFmt)\n\t{\n\t\tcase TexFmt_Alpha8:\n\t\tcase TexFmt_ARGB4444:\n\t\tcase TexFmt_RGB24:\n\t\tcase TexFmt_RGBA32:\n\t\tcase TexFmt_ARGB32:\n\t\tcase TexFmt_RGB565:\n\t\tcase TexFmt_DXT1:\n\t\t\treturn true;\n\t\tcase TexFmt_DXT5:\n\t\t\treturn engineVersion.year >= 2; //actually excludes Unity 2 (up to format 6) because Unity 3.0 (format 8) is the first one with a version name embedded\n\t\tcase TexFmt_PVRTC_RGB2:\n\t\tcase TexFmt_PVRTC_RGBA2:\n\t\tcase TexFmt_PVRTC_RGB4:\n\t\tcase TexFmt_PVRTC_RGBA4:\n\t\t\treturn engineVersion.year > 2 || (engineVersion.year == 2 && engineVersion.release >= 6); //same as above\n\t\tcase TexFmt_ETC_RGB4:\n\t\t\treturn engineVersion.year >= 3;\n\t\tcase TexFmt_ATC_RGB4:\n\t\tcase TexFmt_ATC_RGBA8:\n\t\t\treturn (engineVersion.year >= 4 && engineVersion.year <= 2017) || (engineVersion.year == 3 && engineVersion.release >= 4);\n\t\tcase TexFmt_BGRA32Old:\n\t\t\treturn (engineVersion.year == 4 && engineVersion.release < 5) || (engineVersion.year == 3 && engineVersion.release >= 4);\n\t\tcase TexFmt_UNUSED38:\n\t\tcase TexFmt_UNUSED39:\n\t\tcase TexFmt_UNUSED40:\n\t\t\treturn engineVersion.year == 4 || (engineVersion.year == 3 && engineVersion.release >= 5);\n\t\tcase TexFmt_RGBA4444:\n\t\t\treturn engineVersion.year > 4 || (engineVersion.year == 4 && engineVersion.release >= 1);\n\t\tcase TexFmt_BGRA32New:\n\t\tcase TexFmt_EAC_R:\n\t\tcase TexFmt_EAC_R_SIGNED:\n\t\tcase TexFmt_EAC_RG:\n\t\tcase TexFmt_EAC_RG_SIGNED:\n\t\tcase TexFmt_ETC2_RGB4:\n\t\tcase TexFmt_ETC2_RGBA1:\n\t\tcase TexFmt_ETC2_RGBA8:\n\t\tcase TexFmt_ASTC_RGB_4x4:  //version >= 2: TexFmt_ASTC_4x4\n\t\tcase TexFmt_ASTC_RGB_5x5:  //version >= 2: TexFmt_ASTC_5x5\n\t\tcase TexFmt_ASTC_RGB_6x6:  //version >= 2: TexFmt_ASTC_6x6\n\t\tcase TexFmt_ASTC_RGB_8x8:  //version >= 2: TexFmt_ASTC_8x8\n\t\tcase TexFmt_ASTC_RGB_10x10://version >= 2: TexFmt_ASTC_10x10\n\t\tcase TexFmt_ASTC_RGB_12x12://version >= 2: TexFmt_ASTC_12x12\n\t\t\treturn engineVersion.year > 4 || (engineVersion.year == 4 && engineVersion.release >= 5);\n\t\tcase TexFmt_ASTC_RGBA_4x4:\n\t\tcase TexFmt_ASTC_RGBA_5x5:\n\t\tcase TexFmt_ASTC_RGBA_6x6:\n\t\tcase TexFmt_ASTC_RGBA_8x8:\n\t\tcase TexFmt_ASTC_RGBA_10x10:\n\t\tcase TexFmt_ASTC_RGBA_12x12:\n\t\t\treturn (engineVersion.year > 4 || (engineVersion.year == 4 && engineVersion.release >= 5)) && engineVersion.year < 2019;\n\t\tcase TexFmt_R16:\n\t\tcase TexFmt_RHalf:\n\t\tcase TexFmt_RGHalf:\n\t\tcase TexFmt_RGBAHalf:\n\t\tcase TexFmt_RFloat:\n\t\tcase TexFmt_RGFloat:\n\t\tcase TexFmt_RGBAFloat:\n\t\tcase TexFmt_YUV2:\n\t\tcase TexFmt_DXT1Crunched:\n\t\tcase TexFmt_DXT5Crunched:\n\t\t\treturn engineVersion.year >= 5;\n\t\tcase TexFmt_ETC_RGB4_3DS:\n\t\tcase TexFmt_ETC_RGBA8_3DS:\n\t\t\treturn engineVersion.year >= 5 && (engineVersion.year < 2018 || (engineVersion.year == 2018 && engineVersion.release < 3));\n\t\tcase TexFmt_BC6H:\n\t\tcase TexFmt_BC7:\n\t\tcase TexFmt_BC4:\n\t\tcase TexFmt_BC5:\n\t\t\treturn engineVersion.year > 5 || (engineVersion.year == 5 && engineVersion.release >= 5);\n\t\tcase TexFmt_RGB9e5Float:\n\t\t\treturn engineVersion.year > 5 || (engineVersion.year == 5 && engineVersion.release >= 6);\n\t\tcase TexFmt_RG16:\n\t\tcase TexFmt_R8:\n\t\t\treturn engineVersion.year > 2017 || (engineVersion.year == 2017 && engineVersion.release >= 1);\n\t\tcase TexFmt_ETC_RGB4Crunched:\n\t\tcase TexFmt_ETC2_RGBA8Crunched:\n\t\t\treturn engineVersion.year > 2017 || (engineVersion.year == 2017 && engineVersion.release >= 3);\n\t\tcase TexFmt_ASTC_HDR_4x4:\n\t\tcase TexFmt_ASTC_HDR_5x5:\n\t\tcase TexFmt_ASTC_HDR_6x6:\n\t\tcase TexFmt_ASTC_HDR_8x8:\n\t\tcase TexFmt_ASTC_HDR_10x10:\n\t\tcase TexFmt_ASTC_HDR_12x12:\n\t\t\treturn engineVersion.year >= 2019;\n\t\tcase TexFmt_RG32:\n\t\tcase TexFmt_RGB48:\n\t\tcase TexFmt_RGBA64:\n\t\t\treturn engineVersion.year > 2020 || (engineVersion.year == 2020 && engineVersion.release >= 2);\n\t\tdefault:\n\t\t\treturn false;\n\t}\n}\n\n#include <squish.h>\n\n#define _24to32(in) (in + 0x000000FF)\nvoid Write24BitTo(uint32_t in, void *buf)\n{\n\t((uint8_t*)buf)[2] = (uint8_t)((in & 0xFF000000) >> 24);\n\t((uint8_t*)buf)[1] = (uint8_t)((in & 0x00FF0000) >> 16);\n\t((uint8_t*)buf)[0] = (uint8_t)((in & 0x0000FF00) >> 8);\n}\nvoid Write24To32BitTo(uint32_t in, void *buf)\n{\n\t((uint32_t*)buf)[0] = (in & 0xFFFFFF00) + 0x000000FF;\n}\nvoid Write32BitTo(uint32_t in, void *buf)\n{\n\t((uint32_t*)buf)[0] = in;\n}\ntypedef void(__cdecl *_WritePixelFormatTo)(uint32_t, void*);\n\nstruct UncompressedColorChannel //not more than 8bit per channel\n{\n\tuint32_t mask; //mask of the color channel in the byte\n\tchar shift; //amount of bits to lshift to compress = amount of bits to rshift to decompress\n};\nstruct UncompressedTextureFormat\n{\n\tUncompressedColorChannel red, green, blue, alpha;\n};\n\nbool Uncompressed_ToRGBA32(TextureFile *pTex, void *pOutBuf)\n{\n\tswitch (pTex->m_TextureFormat)\n\t{\n\t\tcase TexFmt_RGB24:\n\t\t{\n\t\t\tif (pTex->_pictureDataSize < (pTex->m_Width * pTex->m_Height * 3))\n\t\t\t\treturn false;\n\t\t\tfor (unsigned int i = 0; i < (pTex->m_Width * pTex->m_Height); i++)\n\t\t\t{\n\t\t\t\t((uint8_t*)pOutBuf)[i * 4 + 0] = pTex->pPictureData[i * 3 + 0]; //R\n\t\t\t\t((uint8_t*)pOutBuf)[i * 4 + 1] = pTex->pPictureData[i * 3 + 1]; //G\n\t\t\t\t((uint8_t*)pOutBuf)[i * 4 + 2] = pTex->pPictureData[i * 3 + 2]; //B\n\t\t\t\t((uint8_t*)pOutBuf)[i * 4 + 3] = 255; //A\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t\tcase TexFmt_RGBA32:\n\t\t{\n\t\t\tif (pTex->_pictureDataSize < (pTex->m_Width * pTex->m_Height * 4))\n\t\t\t\treturn false;\n\t\t\tmemcpy(pOutBuf, pTex->pPictureData, (pTex->m_Width * pTex->m_Height) * 4);\n\t\t}\n\t\tbreak;\n\t\tcase TexFmt_BGRA32Old:\n\t\tcase TexFmt_BGRA32New:\n\t\t{\n\t\t\tif (pTex->_pictureDataSize < (pTex->m_Width * pTex->m_Height * 4))\n\t\t\t\treturn false;\n\t\t\tfor (unsigned int i = 0; i < (pTex->m_Width * pTex->m_Height); i++)\n\t\t\t{\n\t\t\t\t((uint8_t*)pOutBuf)[i * 4 + 0] = pTex->pPictureData[i * 4 + 2]; //R\n\t\t\t\t((uint8_t*)pOutBuf)[i * 4 + 1] = pTex->pPictureData[i * 4 + 1]; //G\n\t\t\t\t((uint8_t*)pOutBuf)[i * 4 + 2] = pTex->pPictureData[i * 4 + 0]; //B\n\t\t\t\t((uint8_t*)pOutBuf)[i * 4 + 3] = pTex->pPictureData[i * 4 + 3]; //A\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t\tcase TexFmt_ARGB32:\n\t\t{\n\t\t\tif (pTex->_pictureDataSize < (pTex->m_Width * pTex->m_Height * 4))\n\t\t\t\treturn false;\n\t\t\tfor (unsigned int i = 0; i < (pTex->m_Width * pTex->m_Height); i++)\n\t\t\t{\n\t\t\t\t((uint8_t*)pOutBuf)[i * 4 + 0] = pTex->pPictureData[i * 4 + 1]; //R\n\t\t\t\t((uint8_t*)pOutBuf)[i * 4 + 1] = pTex->pPictureData[i * 4 + 2]; //G\n\t\t\t\t((uint8_t*)pOutBuf)[i * 4 + 2] = pTex->pPictureData[i * 4 + 3]; //B\n\t\t\t\t((uint8_t*)pOutBuf)[i * 4 + 3] = pTex->pPictureData[i * 4 + 0]; //A\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t\tcase TexFmt_ARGB4444:\n\t\t{\n\t\t\tif (pTex->_pictureDataSize < (pTex->m_Width * pTex->m_Height * 2))\n\t\t\t\treturn false;\n\t\t\t//GBAR\n\t\t\tfor (unsigned int i = 0; i < (pTex->m_Width * pTex->m_Height); i++)\n\t\t\t{\n\t\t\t\t((uint8_t*)pOutBuf)[i * 4 + 1] = (pTex->pPictureData[i * 2] & 0xF0) | (pTex->pPictureData[i * 2] >> 4); //| 0x0F; //G\n\t\t\t\t((uint8_t*)pOutBuf)[i * 4 + 2] = ((pTex->pPictureData[i * 2] & 0x0F) << 4) | (pTex->pPictureData[i * 2] & 0x0F); //| 0x0F; //B\n\t\t\t\t((uint8_t*)pOutBuf)[i * 4 + 3] = (pTex->pPictureData[i * 2 + 1] & 0xF0) | (pTex->pPictureData[i * 2 + 1] >> 4); //| 0x0F; //A\n\t\t\t\t((uint8_t*)pOutBuf)[i * 4 + 0] = ((pTex->pPictureData[i * 2 + 1] & 0x0F) << 4) | (pTex->pPictureData[i * 2 + 1] & 0x0F); //| 0x0F; //R\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t\tcase TexFmt_RGBA4444:\n\t\t{\n\t\t\tif (pTex->_pictureDataSize < (pTex->m_Width * pTex->m_Height * 2))\n\t\t\t\treturn false;\n\t\t\t//BARG\n\t\t\tfor (unsigned int i = 0; i < (pTex->m_Width * pTex->m_Height); i++)\n\t\t\t{\n\t\t\t\t((uint8_t*)pOutBuf)[i * 4 + 2] = (pTex->pPictureData[i * 2] & 0xF0) | (pTex->pPictureData[i * 2] >> 4); //| 0x0F; //B\n\t\t\t\t((uint8_t*)pOutBuf)[i * 4 + 3] = ((pTex->pPictureData[i * 2] & 0x0F) << 4) | (pTex->pPictureData[i * 2] & 0x0F); //| 0x0F; //A\n\t\t\t\t((uint8_t*)pOutBuf)[i * 4 + 0] = (pTex->pPictureData[i * 2 + 1] & 0xF0) | (pTex->pPictureData[i * 2 + 1] >> 4); //| 0x0F; //R\n\t\t\t\t((uint8_t*)pOutBuf)[i * 4 + 1] = ((pTex->pPictureData[i * 2 + 1] & 0x0F) << 4) | (pTex->pPictureData[i * 2 + 1] & 0x0F); //| 0x0F; //G\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t\tcase TexFmt_RGB565:\n\t\t\t//the R/G/B values won\'t be changed, so colors will look different in 8 bits per color \n\t\t{\n\t\t\tif (pTex->_pictureDataSize < (pTex->m_Width * pTex->m_Height * 2))\n\t\t\t\treturn false;\n\t\t\t//g3(low)b5g3(high)r5\n\t\t\tfor (unsigned int i = 0; i < (pTex->m_Width * pTex->m_Height); i++)\n\t\t\t{\n\t\t\t\tuint16_t rgb565 = *(uint16_t*)(&pTex->pPictureData[i * 2]);\n\t\t\t\t//rgb565 = ((rgb565 & 0xFF00) >> 8) | ((rgb565 & 0x00FF) << 8); \n\t\t\t\tuint8_t r5 = (rgb565 >> 11) & 31;\n\t\t\t\tuint8_t g6 = (rgb565 >> 5) & 63;\n\t\t\t\tuint8_t b5 = (rgb565) & 31;\n\n\t\t\t\t//multiply by 17 -> for maximum 5bit red we get maximum 8bit red, for minimum 5bit red we get minimum 8bit red\n\t\t\t\t((uint8_t*)pOutBuf)[i * 4 + 0] = (r5 << 3) | (r5 & 7);// | 7; \n\t\t\t\t((uint8_t*)pOutBuf)[i * 4 + 1] = (g6 << 2) | (g6 & 3);// | 3;\n\t\t\t\t((uint8_t*)pOutBuf)[i * 4 + 2] = (b5 << 3) | (b5 & 7);// | 7;\n\t\t\t\t((uint8_t*)pOutBuf)[i * 4 + 3] = 255; //A\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t\tcase TexFmt_Alpha8:\n\t\t{\n\t\t\tif (pTex->_pictureDataSize < (pTex->m_Width * pTex->m_Height * 1))\n\t\t\t\treturn false;\n\t\t\tfor (unsigned int i = 0; i < (pTex->m_Width * pTex->m_Height); i++)\n\t\t\t{\n\t\t\t\t((uint8_t*)pOutBuf)[i * 4 + 0] = 255;\n\t\t\t\t((uint8_t*)pOutBuf)[i * 4 + 1] = 255;\n\t\t\t\t((uint8_t*)pOutBuf)[i * 4 + 2] = 255;\n\t\t\t\t((uint8_t*)pOutBuf)[i * 4 + 3] = pTex->pPictureData[i]; //A\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t\tcase TexFmt_RHalf:\n\t\t{\n\t\t\tif (pTex->_pictureDataSize < (pTex->m_Width * pTex->m_Height * 2))\n\t\t\t\treturn false;\n\t\t\tfor (unsigned int i = 0; i < (pTex->m_Width * pTex->m_Height); i++)\n\t\t\t{\n\t\t\t\tfloat red = ((HalfFloat*)&pTex->pPictureData[i * 2])->toFloat();\n\n\t\t\t\t//Cut off values outside the SDR range.\n\t\t\t\tif (red >= 1.0F) red = 1.0F;\n\t\t\t\telse if (red <= 0.0F) red = 0.0F;\n\n\t\t\t\t((uint8_t*)pOutBuf)[i * 4 + 0] = (uint8_t)(red * 255.0F); //R\n\t\t\t\t((uint8_t*)pOutBuf)[i * 4 + 1] = 0; //G\n\t\t\t\t((uint8_t*)pOutBuf)[i * 4 + 2] = 0; //B\n\t\t\t\t((uint8_t*)pOutBuf)[i * 4 + 3] = 255; //A\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t\tcase TexFmt_RGHalf:\n\t\t{\n\t\t\tif (pTex->_pictureDataSize < (pTex->m_Width * pTex->m_Height * 4))\n\t\t\t\treturn false;\n\t\t\tfor (unsigned int i = 0; i < (pTex->m_Width * pTex->m_Height); i++)\n\t\t\t{\n\t\t\t\tfloat colors[2];\n\t\t\t\tcolors[0] = ((HalfFloat*)&pTex->pPictureData[i * 4])->toFloat();\n\t\t\t\tcolors[1] = ((HalfFloat*)&pTex->pPictureData[i * 4 + 2])->toFloat();\n\n\t\t\t\t//Cut off values outside the SDR range.\n\t\t\t\tfor (unsigned int j = 0; j < 2; j++)\n\t\t\t\t{\n\t\t\t\t\tif (colors[j] >= 1.0F) colors[j] = 1.0F;\n\t\t\t\t\telse if (colors[j] <= 0.0F) colors[j] = 0.0F;\n\t\t\t\t}\n\n\t\t\t\t((uint8_t*)pOutBuf)[i * 4 + 0] = (uint8_t)(colors[0] * 255.0F); //R\n\t\t\t\t((uint8_t*)pOutBuf)[i * 4 + 1] = (uint8_t)(colors[1] * 255.0F); //G\n\t\t\t\t((uint8_t*)pOutBuf)[i * 4 + 2] = 0; //B\n\t\t\t\t((uint8_t*)pOutBuf)[i * 4 + 3] = 255; //A\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t\tcase TexFmt_RGBAHalf:\n\t\t{\n\t\t\tif (pTex->_pictureDataSize < (pTex->m_Width * pTex->m_Height * 8))\n\t\t\t\treturn false;\n\t\t\tfor (unsigned int i = 0; i < (pTex->m_Width * pTex->m_Height); i++)\n\t\t\t{\n\t\t\t\tfloat colors[4];\n\t\t\t\tcolors[0] = ((HalfFloat*)&pTex->pPictureData[i * 8])->toFloat();\n\t\t\t\tcolors[1] = ((HalfFloat*)&pTex->pPictureData[i * 8 + 2])->toFloat();\n\t\t\t\tcolors[2] = ((HalfFloat*)&pTex->pPictureData[i * 8 + 4])->toFloat();\n\t\t\t\tcolors[3] = ((HalfFloat*)&pTex->pPictureData[i * 8 + 6])->toFloat();\n\n\t\t\t\t//Cut off values outside the SDR range.\n\t\t\t\tfor (unsigned int j = 0; j < 4; j++)\n\t\t\t\t{\n\t\t\t\t\tif (colors[j] >= 1.0F) colors[j] = 1.0F;\n\t\t\t\t\telse if (colors[j] <= 0.0F) colors[j] = 0.0F;\n\t\t\t\t}\n\n\t\t\t\t((uint8_t*)pOutBuf)[i * 4 + 0] = (uint8_t)(colors[0] * 255.0F); //R\n\t\t\t\t((uint8_t*)pOutBuf)[i * 4 + 1] = (uint8_t)(colors[1] * 255.0F); //G\n\t\t\t\t((uint8_t*)pOutBuf)[i * 4 + 2] = (uint8_t)(colors[2] * 255.0F); //B\n\t\t\t\t((uint8_t*)pOutBuf)[i * 4 + 3] = (uint8_t)(colors[3] * 255.0F); //A\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t\tcase TexFmt_RFloat:\n\t\t{\n\t\t\tif (pTex->_pictureDataSize < (pTex->m_Width * pTex->m_Height * 4))\n\t\t\t\treturn false;\n\t\t\tfor (unsigned int i = 0; i < (pTex->m_Width * pTex->m_Height); i++)\n\t\t\t{\n\t\t\t\tfloat red = *(float*)&pTex->pPictureData[i * 4];\n\n\t\t\t\t//Cut off values outside the SDR range.\n\t\t\t\tif (red >= 1.0F) red = 1.0F;\n\t\t\t\telse if (red <= 0.0F) red = 0.0F;\n\n\t\t\t\t((uint8_t*)pOutBuf)[i * 4 + 0] = (uint8_t)(red * 255.0F); //R\n\t\t\t\t((uint8_t*)pOutBuf)[i * 4 + 1] = 0; //G\n\t\t\t\t((uint8_t*)pOutBuf)[i * 4 + 2] = 0; //B\n\t\t\t\t((uint8_t*)pOutBuf)[i * 4 + 3] = 255; //A\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t\tcase TexFmt_RGFloat:\n\t\t{\n\t\t\tif (pTex->_pictureDataSize < (pTex->m_Width * pTex->m_Height * 8))\n\t\t\t\treturn false;\n\t\t\tfor (unsigned int i = 0; i < (pTex->m_Width * pTex->m_Height); i++)\n\t\t\t{\n\t\t\t\tfloat colors[2];\n\t\t\t\tcolors[0] = *(float*)&pTex->pPictureData[i * 8]; //R\n\t\t\t\tcolors[1] = *(float*)&pTex->pPictureData[i * 8 + 4]; //G\n\n\t\t\t\t//Cut off values outside the SDR range.\n\t\t\t\tfor (unsigned int j = 0; j < 2; j++)\n\t\t\t\t{\n\t\t\t\t\tif (colors[j] >= 1.0F) colors[j] = 1.0F;\n\t\t\t\t\telse if (colors[j] <= 0.0F) colors[j] = 0.0F;\n\t\t\t\t}\n\n\t\t\t\t((uint8_t*)pOutBuf)[i * 4 + 0] = (uint8_t)(colors[0] * 255.0F); //R\n\t\t\t\t((uint8_t*)pOutBuf)[i * 4 + 1] = (uint8_t)(colors[1] * 255.0F); //G\n\t\t\t\t((uint8_t*)pOutBuf)[i * 4 + 2] = 0; //B\n\t\t\t\t((uint8_t*)pOutBuf)[i * 4 + 3] = 255; //A\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t\tcase TexFmt_RGBAFloat:\n\t\t{\n\t\t\tif (pTex->_pictureDataSize < (pTex->m_Width * pTex->m_Height * 16))\n\t\t\t\treturn false;\n\t\t\tfor (unsigned int i = 0; i < (pTex->m_Width * pTex->m_Height); i++)\n\t\t\t{\n\t\t\t\tfloat colors[4];\n\t\t\t\tcolors[0] = *(float*)&pTex->pPictureData[i * 16]; //R\n\t\t\t\tcolors[1] = *(float*)&pTex->pPictureData[i * 16 + 4]; //G\n\t\t\t\tcolors[2] = *(float*)&pTex->pPictureData[i * 16 + 8]; //B\n\t\t\t\tcolors[3] = *(float*)&pTex->pPictureData[i * 16 + 12]; //A\n\n\t\t\t\t//Cut off values outside the SDR range.\n\t\t\t\tfor (unsigned int j = 0; j < 4; j++)\n\t\t\t\t{\n\t\t\t\t\tif (colors[j] >= 1.0F) colors[j] = 1.0F;\n\t\t\t\t\telse if (colors[j] <= 0.0F) colors[j] = 0.0F;\n\t\t\t\t}\n\n\t\t\t\t((uint8_t*)pOutBuf)[i * 4 + 0] = (uint8_t)(colors[0] * 255.0F); //R\n\t\t\t\t((uint8_t*)pOutBuf)[i * 4 + 1] = (uint8_t)(colors[1] * 255.0F); //G\n\t\t\t\t((uint8_t*)pOutBuf)[i * 4 + 2] = (uint8_t)(colors[2] * 255.0F); //B\n\t\t\t\t((uint8_t*)pOutBuf)[i * 4 + 3] = (uint8_t)(colors[3] * 255.0F); //A\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t\tcase TexFmt_RGB9e5Float:\n\t\t{\n\t\t\tif (pTex->_pictureDataSize < (pTex->m_Width * pTex->m_Height * 4))\n\t\t\t\treturn false;\n\t\t\tfor (unsigned int i = 0; i < (pTex->m_Width * pTex->m_Height); i++)\n\t\t\t{\n\t\t\t\tRGB9e5Float rgbFloat;\n\t\t\t\trgbFloat.value = *(unsigned int*)&pTex->pPictureData[i * 4];\n\t\t\t\tfloat colors[3] = {};\n\t\t\t\trgbFloat.toFloat(colors);\n\n\t\t\t\t//Cut off values outside the SDR range.\n\t\t\t\tfor (unsigned int j = 0; j < 3; j++)\n\t\t\t\t{\n\t\t\t\t\tif (colors[j] >= 1.0F) colors[j] = 1.0F;\n\t\t\t\t\telse if (colors[j] <= 0.0F) colors[j] = 0.0F;\n\t\t\t\t}\n\n\t\t\t\t((uint8_t*)pOutBuf)[i * 4 + 0] = (uint8_t)(colors[0] * 255.0F); //R\n\t\t\t\t((uint8_t*)pOutBuf)[i * 4 + 1] = (uint8_t)(colors[1] * 255.0F); //G\n\t\t\t\t((uint8_t*)pOutBuf)[i * 4 + 2] = (uint8_t)(colors[2] * 255.0F); //B\n\t\t\t\t((uint8_t*)pOutBuf)[i * 4 + 3] = 255; //A\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t\tcase TexFmt_R8:\n\t\t{\n\t\t\tif (pTex->_pictureDataSize < (pTex->m_Width * pTex->m_Height * 1))\n\t\t\t\treturn false;\n\t\t\tfor (unsigned int i = 0; i < (pTex->m_Width * pTex->m_Height); i++)\n\t\t\t{\n\t\t\t\t((uint8_t*)pOutBuf)[i * 4 + 0] = pTex->pPictureData[i]; //R\n\t\t\t\t((uint8_t*)pOutBuf)[i * 4 + 1] = 0; //G\n\t\t\t\t((uint8_t*)pOutBuf)[i * 4 + 2] = 0; //B\n\t\t\t\t((uint8_t*)pOutBuf)[i * 4 + 3] = 255; //A\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t\tcase TexFmt_R16:\n\t\t{\n\t\t\tif (pTex->_pictureDataSize < (pTex->m_Width * pTex->m_Height * 2))\n\t\t\t\treturn false;\n\t\t\tfor (unsigned int i = 0; i < (pTex->m_Width * pTex->m_Height); i++)\n\t\t\t{\n\t\t\t\t((uint8_t*)pOutBuf)[i * 4 + 0] = (*(uint16_t*)&pTex->pPictureData[i*2]) >> 8; //R\n\t\t\t\t((uint8_t*)pOutBuf)[i * 4 + 1] = 0; //G\n\t\t\t\t((uint8_t*)pOutBuf)[i * 4 + 2] = 0; //B\n\t\t\t\t((uint8_t*)pOutBuf)[i * 4 + 3] = 255; //A\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t\tcase TexFmt_RG16:\n\t\t{\n\t\t\tif (pTex->_pictureDataSize < (pTex->m_Width * pTex->m_Height * 2))\n\t\t\t\treturn false;\n\t\t\tfor (unsigned int i = 0; i < (pTex->m_Width * pTex->m_Height); i++)\n\t\t\t{\n\t\t\t\t((uint8_t*)pOutBuf)[i * 4 + 0] = pTex->pPictureData[i * 2]; //R\n\t\t\t\t((uint8_t*)pOutBuf)[i * 4 + 1] = pTex->pPictureData[i * 2 + 1]; //G\n\t\t\t\t((uint8_t*)pOutBuf)[i * 4 + 2] = 0; //B\n\t\t\t\t((uint8_t*)pOutBuf)[i * 4 + 3] = 255; //A\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t\tcase TexFmt_RG32:\n\t\t{\n\t\t\tif (pTex->_pictureDataSize < (pTex->m_Width * pTex->m_Height * 4))\n\t\t\t\treturn false;\n\t\t\tfor (unsigned int i = 0; i < (pTex->m_Width * pTex->m_Height); i++)\n\t\t\t{\n\t\t\t\t((uint8_t*)pOutBuf)[i * 4 + 0] = (*(uint16_t*)&pTex->pPictureData[i * 4 + 0]) >> 8; //R\n\t\t\t\t((uint8_t*)pOutBuf)[i * 4 + 1] = (*(uint16_t*)&pTex->pPictureData[i * 4 + 2]) >> 8; //G\n\t\t\t\t((uint8_t*)pOutBuf)[i * 4 + 2] = 0; //B\n\t\t\t\t((uint8_t*)pOutBuf)[i * 4 + 3] = 255; //A\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t\tcase TexFmt_RGB48:\n\t\t{\n\t\t\tif (pTex->_pictureDataSize < (pTex->m_Width * pTex->m_Height * 6))\n\t\t\t\treturn false;\n\t\t\tfor (unsigned int i = 0; i < (pTex->m_Width * pTex->m_Height); i++)\n\t\t\t{\n\t\t\t\t((uint8_t*)pOutBuf)[i * 4 + 0] = (*(uint16_t*)&pTex->pPictureData[i * 6 + 0]) >> 8; //R\n\t\t\t\t((uint8_t*)pOutBuf)[i * 4 + 1] = (*(uint16_t*)&pTex->pPictureData[i * 6 + 2]) >> 8; //G\n\t\t\t\t((uint8_t*)pOutBuf)[i * 4 + 2] = (*(uint16_t*)&pTex->pPictureData[i * 6 + 4]) >> 8; //B\n\t\t\t\t((uint8_t*)pOutBuf)[i * 4 + 3] = 255; //A\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t\tcase TexFmt_RGBA64:\n\t\t{\n\t\t\tif (pTex->_pictureDataSize < (pTex->m_Width * pTex->m_Height * 8))\n\t\t\t\treturn false;\n\t\t\tfor (unsigned int i = 0; i < (pTex->m_Width * pTex->m_Height); i++)\n\t\t\t{\n\t\t\t\t((uint8_t*)pOutBuf)[i * 4 + 0] = (*(uint16_t*)&pTex->pPictureData[i * 8 + 0]) >> 8; //R\n\t\t\t\t((uint8_t*)pOutBuf)[i * 4 + 1] = (*(uint16_t*)&pTex->pPictureData[i * 8 + 2]) >> 8; //G\n\t\t\t\t((uint8_t*)pOutBuf)[i * 4 + 2] = (*(uint16_t*)&pTex->pPictureData[i * 8 + 4]) >> 8; //B\n\t\t\t\t((uint8_t*)pOutBuf)[i * 4 + 3] = (*(uint16_t*)&pTex->pPictureData[i * 8 + 6]) >> 8; //A\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t\tdefault:\n\t\t\treturn false;\n\t}\n\treturn true;\n}\n\nint highestAlpha = 0;\nbool Compressed_ToRGBA32(TextureFile *pTex, void *pOutBuf)\n{\n\t//pvrtexture::PixelType pvr_pxType;\n\tswitch (pTex->m_TextureFormat)\n\t{\n\t\tcase TexFmt_ETC_RGB4Crunched:\n\t\tcase TexFmt_ETC2_RGBA8Crunched:\n\t\tcase TexFmt_DXT1Crunched:\n\t\tcase TexFmt_DXT5Crunched:\n\t\t{\n\t\t\tstd::vector<uint8_t> decrunchBuf;\n\t\t\tTextureFormat decrunchFormat = (TextureFormat)0;\n\t\t\tif (pTex->extra.textureFormatVersion >= 1)\n\t\t\t{\n\t\t\t\tif (!DecrunchTextureData_Unity(pTex, decrunchBuf, decrunchFormat))\n\t\t\t\t\treturn false;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (!DecrunchTextureData_Legacy(pTex, decrunchBuf, decrunchFormat))\n\t\t\t\t\treturn false;\n\t\t\t}\n\t\t\tbool ret = false;\n\t\t\t{\n\t\t\t\tuint32_t origFormat = pTex->m_TextureFormat;\n\t\t\t\tuint8_t* pOrigBuf = pTex->pPictureData;\n\t\t\t\tuint32_t origSize = pTex->_pictureDataSize;\n\t\t\t\tuint32_t origCompleteSize = pTex->m_CompleteImageSize;\n\n\t\t\t\tpTex->m_TextureFormat = (uint32_t)decrunchFormat;\n\t\t\t\tpTex->pPictureData = decrunchBuf.data();\n\t\t\t\tpTex->_pictureDataSize = (uint32_t)decrunchBuf.size();\n\t\t\t\tpTex->m_CompleteImageSize = (uint32_t)decrunchBuf.size();\n\n\t\t\t\tret = Compressed_ToRGBA32(pTex, pOutBuf);\n\n\t\t\t\tpTex->m_TextureFormat = origFormat;\n\t\t\t\tpTex->pPictureData = pOrigBuf;\n\t\t\t\tpTex->_pictureDataSize = origSize;\n\t\t\t\tpTex->m_CompleteImageSize = origCompleteSize;\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t\tbreak;\n\t\tcase TexFmt_DXT1:\n\t\tcase TexFmt_DXT5:\n\t\t{\n\t\t\tpTex->m_MipCount = 1;\n\t\t\tvoid *DXTBuf = pTex->pPictureData; size_t DXTBufLen = pTex->_pictureDataSize;\n\t\t\tint squishDXTType; TextureFormat dxtTextureFormat;\n\t\t\tif (pTex->m_TextureFormat == TexFmt_DXT1)\n\t\t\t{\n\t\t\t\tdxtTextureFormat = TexFmt_DXT1;\n\t\t\t\tsquishDXTType = squish::kDxt1;\n\t\t\t}\n\t\t\telse if (pTex->m_TextureFormat == TexFmt_DXT5)\n\t\t\t{\n\t\t\t\tdxtTextureFormat = TexFmt_DXT5;\n\t\t\t\tsquishDXTType = squish::kDxt5;\n\t\t\t}\n\t\t\tif (pTex->_pictureDataSize < (size_t)GetCompressedTextureDataSize(pTex->m_Width, pTex->m_Height, dxtTextureFormat))\n\t\t\t\treturn false;\n\t\t\tsquish::DecompressImage((squish::u8*)pOutBuf, pTex->m_Width, pTex->m_Height, pTex->pPictureData, squishDXTType);//pTex->m_Width * pTex->m_Height * 4;\n\t\t\treturn true;\n\t\t}\n\t\tbreak;\n\t\tcase TexFmt_BC4:\n\t\tcase TexFmt_BC5:\n\t\tcase TexFmt_BC6H:\n\t\tcase TexFmt_BC7:\n\t\t\t{\n\t\t\t\tif (pTex->_pictureDataSize < (size_t)GetCompressedTextureDataSize(pTex->m_Width, pTex->m_Height, (TextureFormat)pTex->m_TextureFormat))\n\t\t\t\t{\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tImage image = {};\n\t\t\t\tTexture texture = {};\n\t\t\t\ttexture.pixels = (unsigned int*)pTex->pPictureData;\n\t\t\t\ttexture.width = pTex->m_Width;\n\t\t\t\ttexture.height = pTex->m_Height;\n\t\t\t\ttexture.extended_width = (texture.width + 3) & (~3); //4x4 block texture format\n\t\t\t\ttexture.extended_height = (texture.height + 3) & (~3);\n\t\t\t\tswitch (pTex->m_TextureFormat)\n\t\t\t\t{\n\t\t\t\tcase TexFmt_BC4:\n\t\t\t\t\ttexture.type = TEXTURE_TYPE_RGTC1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase TexFmt_BC5:\n\t\t\t\t\ttexture.type = TEXTURE_TYPE_RGTC2;\n\t\t\t\t\tbreak;\n\t\t\t\tcase TexFmt_BC6H:\n\t\t\t\t\ttexture.type = TEXTURE_TYPE_BPTC_FLOAT;\n\t\t\t\t\tbreak;\n\t\t\t\tcase TexFmt_BC7:\n\t\t\t\t\ttexture.type = TEXTURE_TYPE_BPTC;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\ttexture.info = match_texture_type(texture.type);\n\t\t\t\ttexture.bits_per_block = texture.info->bits_per_block;\n\t\t\t\ttexture.block_width = texture.info->block_width;\n\t\t\t\ttexture.block_height = texture.info->block_height;\n\t\t\t\tset_texture_decoding_function(&texture, NULL);\n\t\t\t\tconvert_texture_to_image(&texture, &image);\n\t\t\t\tif (image.pixels == NULL)\n\t\t\t\t\treturn false;\n\t\t\t\tmemset(&texture, 0, sizeof(texture));\n\t\t\t\tif (pTex->m_TextureFormat == TexFmt_BC4 || pTex->m_TextureFormat == TexFmt_BC5)\n\t\t\t\t{\n\t\t\t\t\tconvert_image_to_8_bit_format(&image, 4, 0);\n\t\t\t\t\tif (image.pixels == NULL)\n\t\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tcopy_image_to_uncompressed_texture(&image, TEXTURE_TYPE_UNCOMPRESSED_RGBA8, &texture);\n\t\t\t\tdestroy_image(&image);\n\t\t\t\tif (texture.pixels == NULL)\n\t\t\t\t\treturn false;\n\t\t\t\tmemcpy(pOutBuf, texture.pixels, pTex->m_Width * pTex->m_Height * 4);\n\t\t\t\tdestroy_texture(&texture);\n\t\t\t\treturn true;\n\t\t\t\t//option_texture_format\n\t\t\t\t//option_mipmaps\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TexFmt_YUV2: //not actually compressed but it\'s also handled\n\t\tcase TexFmt_EAC_R:\n\t\tcase TexFmt_EAC_R_SIGNED:\n\t\tcase TexFmt_EAC_RG:\n\t\tcase TexFmt_EAC_RG_SIGNED:\n\t\tcase TexFmt_ETC_RGB4:\n\t\tcase TexFmt_ETC_RGB4_3DS:\n\t\tcase TexFmt_ETC_RGBA8_3DS:\n\t\tcase TexFmt_ETC2_RGB4:\n\t\tcase TexFmt_ETC2_RGBA1:\n\t\tcase TexFmt_ETC2_RGBA8:\n\t\tcase TexFmt_PVRTC_RGB2:\n\t\tcase TexFmt_PVRTC_RGBA2:\n\t\tcase TexFmt_PVRTC_RGB4:\n\t\tcase TexFmt_PVRTC_RGBA4:\n\t\t\t{\n\t\t\t\ttypedef size_t(_cdecl *Wrap_Decompress)(uint32_t texFmt, unsigned int height, unsigned int width, unsigned int mipCount, void *pInBuf, size_t inBufLen, void *pOutBuf, size_t outBufLen);\n\t\t\t\tHMODULE hModule = LoadLibrary(TEXT("TexToolWrap.dll"));\n\t\t\t\tif (hModule)\n\t\t\t\t{\n\t\t\t\t\tWrap_Decompress Decompress = (Wrap_Decompress)GetProcAddress(hModule, "Decompress");\n\t\t\t\t\tsize_t decompSize = 0;\n\t\t\t\t\tif (Decompress)\n\t\t\t\t\t\tdecompSize = \n\t\t\t\t\t\tDecompress(pTex->m_TextureFormat,\n\t\t\t\t\t\t\tpTex->m_Height, pTex->m_Width, pTex->m_MipCount, \n\t\t\t\t\t\t\tpTex->pPictureData, pTex->_pictureDataSize, \n\t\t\t\t\t\t\tpOutBuf, 4 * pTex->m_Width * pTex->m_Height);\n\t\t\t\t\tFreeLibrary(hModule);\n\t\t\t\t\treturn decompSize == (4 * pTex->m_Width * pTex->m_Height);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TexFmt_ASTC_RGB_4x4:\n\t\tcase TexFmt_ASTC_RGB_5x5:\n\t\tcase TexFmt_ASTC_RGB_6x6:\n\t\tcase TexFmt_ASTC_RGB_8x8:\n\t\tcase TexFmt_ASTC_RGB_10x10:\n\t\tcase TexFmt_ASTC_RGB_12x12:\n\t\tcase TexFmt_ASTC_RGBA_4x4:\n\t\tcase TexFmt_ASTC_RGBA_5x5:\n\t\tcase TexFmt_ASTC_RGBA_6x6:\n\t\tcase TexFmt_ASTC_RGBA_8x8:\n\t\tcase TexFmt_ASTC_RGBA_10x10:\n\t\tcase TexFmt_ASTC_RGBA_12x12:\n\t\tcase TexFmt_ASTC_HDR_4x4:\n\t\tcase TexFmt_ASTC_HDR_5x5:\n\t\tcase TexFmt_ASTC_HDR_6x6:\n\t\tcase TexFmt_ASTC_HDR_8x8:\n\t\tcase TexFmt_ASTC_HDR_10x10:\n\t\tcase TexFmt_ASTC_HDR_12x12:\n\t\t\t{\n\t\t\t\tint blockDim = 4;\n\t\t\t\tDWORD textureFormat = pTex->m_TextureFormat;\n\t\t\t\tstatic_assert(TexFmt_ASTC_4x4 == TexFmt_ASTC_RGB_4x4, "Outdated assumption for texture format enum values");\n\t\t\t\tif (pTex->extra.textureFormatVersion >= 2\n\t\t\t\t\t&& textureFormat >= TexFmt_ASTC_4x4 && textureFormat <= TexFmt_ASTC_12x12)\n\t\t\t\t{\n\t\t\t\t\ttextureFormat = (textureFormat - TexFmt_ASTC_4x4) + TexFmt_ASTC_RGBA_4x4;\n\t\t\t\t}\n\t\t\t\tswitch (textureFormat)\n\t\t\t\t{\n\t\t\t\t\tcase TexFmt_ASTC_HDR_4x4: case TexFmt_ASTC_4x4: blockDim = 4; break;\n\t\t\t\t\tcase TexFmt_ASTC_HDR_5x5: case TexFmt_ASTC_5x5: blockDim = 5; break;\n\t\t\t\t\tcase TexFmt_ASTC_HDR_6x6: case TexFmt_ASTC_6x6: blockDim = 6; break;\n\t\t\t\t\tcase TexFmt_ASTC_HDR_8x8: case TexFmt_ASTC_8x8: blockDim = 8; break;\n\t\t\t\t\tcase TexFmt_ASTC_HDR_10x10: case TexFmt_ASTC_10x10: blockDim = 10; break;\n\t\t\t\t\tcase TexFmt_ASTC_HDR_12x12: case TexFmt_ASTC_12x12: blockDim = 12; break;\n\t\t\t\t\tdefault: assert(false);\n\t\t\t\t}\n\t\t\t\tbool isHDR = (textureFormat >= TexFmt_ASTC_HDR_4x4 && textureFormat <= TexFmt_ASTC_HDR_12x12);\n\t\t\t\tastcenc_config astcenc_cfg;\n\t\t\t\tif (astcenc_config_init(isHDR ? ASTCENC_PRF_HDR : ASTCENC_PRF_LDR,\n\t\t\t\t\tblockDim, blockDim, 1,\n\t\t\t\t\tASTCENC_PRE_FAST,\n\t\t\t\t\tASTCENC_FLG_DECOMPRESS_ONLY, &astcenc_cfg)\n\t\t\t\t\t!= ASTCENC_SUCCESS)\n\t\t\t\t\treturn false;\n\t\t\t\t//Note: May be noticably more efficient to reuse a context, as per the astcenc documentation.\n\t\t\t\tastcenc_context* pAstcencContext = nullptr;\n\t\t\t\tif (astcenc_context_alloc(&astcenc_cfg, 1, &pAstcencContext)\n\t\t\t\t\t!= ASTCENC_SUCCESS)\n\t\t\t\t\treturn false;\n\t\t\t\tastcenc_decompress_reset(pAstcencContext);\n\t\t\t\tastcenc_image image_out = {};\n\t\t\t\tvoid* dataSlices[1] = { pOutBuf }; //z size = 1\n\t\t\t\timage_out.data = &dataSlices[0];\n\t\t\t\timage_out.data_type = ASTCENC_TYPE_U8;\n\t\t\t\timage_out.dim_x = pTex->m_Width;\n\t\t\t\timage_out.dim_y = pTex->m_Height;\n\t\t\t\timage_out.dim_z = 1;\n\t\t\t\tastcenc_swizzle swizzle = {};\n\t\t\t\tswizzle.r = ASTCENC_SWZ_R; \n\t\t\t\tswizzle.g = ASTCENC_SWZ_G;\n\t\t\t\tswizzle.b = ASTCENC_SWZ_B;\n\t\t\t\tswizzle.a = ASTCENC_SWZ_A;\n\t\t\t\tauto result = astcenc_decompress_image(pAstcencContext, pTex->pPictureData, pTex->_pictureDataSize, &image_out, &swizzle, 0);\n\t\t\t\tastcenc_context_free(pAstcencContext);\n\t\t\t\tif (result != ASTCENC_SUCCESS)\n\t\t\t\t\treturn false;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tbreak;\n\t}\n\treturn false;\n}\n\nstatic int astcTexFmt_GetBlockDim(TextureFormat texFmt)\n{\n\tswitch (texFmt)\n\t{\n\tcase TexFmt_ASTC_RGB_4x4: \n\tcase TexFmt_ASTC_RGBA_4x4:\n\tcase TexFmt_ASTC_HDR_4x4:\n\t\treturn 4;\n\tcase TexFmt_ASTC_RGB_5x5:\n\tcase TexFmt_ASTC_RGBA_5x5:\n\tcase TexFmt_ASTC_HDR_5x5:\n\t\treturn 5;\n\tcase TexFmt_ASTC_RGB_6x6:\n\tcase TexFmt_ASTC_RGBA_6x6:\n\tcase TexFmt_ASTC_HDR_6x6:\n\t\treturn 6;\n\tcase TexFmt_ASTC_RGB_8x8:\n\tcase TexFmt_ASTC_RGBA_8x8:\n\tcase TexFmt_ASTC_HDR_8x8:\n\t\treturn 8;\n\tcase TexFmt_ASTC_RGB_10x10:\n\tcase TexFmt_ASTC_RGBA_10x10:\n\tcase TexFmt_ASTC_HDR_10x10:\n\t\treturn 10;\n\tcase TexFmt_ASTC_RGB_12x12:\n\tcase TexFmt_ASTC_RGBA_12x12:\n\tcase TexFmt_ASTC_HDR_12x12:\n\t\treturn 12;\n\tdefault:\n\t\tthrow std::invalid_argument("astcTexFmt_GetBlockDim expects a ASTC texture format value.");\n\t}\n}\nsize_t GetCompressedTextureDataSize(int width, int height, TextureFormat texFmt)\n{\n\tif (width < 0 || height < 0)\n\t\tthrow std::invalid_argument("negative width or height");\n\t//DXT1 : ARGB file size factor (at 4x4 pixel blocks) : 1/8\n\t//DXT5 : ARGB file size factor (at 4x4 pixel blocks) : 1/4\n\t//BC4 : ARGB file size factor (at 4x4 pixel blocks) : 1/8\n\t//BC5 : ARGB file size factor (at 4x4 pixel blocks) : 1/4\n\t//BC6H : ARGB file size factor (at 4x4 pixel blocks) : 1/4\n\t//BC7 : ARGB file size factor (at 4x4 pixel blocks) : 1/4\n\n\tswitch (texFmt)\n\t{\n\t\tcase TexFmt_DXT1:\n\t\tcase TexFmt_BC4: //same size as DXT1\n\t\t\treturn (unsigned int)squish::GetStorageRequirements(width, height, squish::kDxt1);\n\t\tcase TexFmt_DXT5:\n\t\tcase TexFmt_BC5: //same size as DXT5\n\t\tcase TexFmt_BC6H: //same size as DXT5\n\t\tcase TexFmt_BC7: //same size as DXT5\n\t\t\treturn (unsigned int)squish::GetStorageRequirements(width, height, squish::kDxt5);\n\t\tcase TexFmt_YUV2: //not actually compressed but it\'s also handled\n\t\tcase TexFmt_EAC_R:\n\t\tcase TexFmt_EAC_R_SIGNED:\n\t\tcase TexFmt_EAC_RG:\n\t\tcase TexFmt_EAC_RG_SIGNED:\n\t\tcase TexFmt_ETC_RGB4:\n\t\tcase TexFmt_ETC_RGB4_3DS:\n\t\tcase TexFmt_ETC_RGBA8_3DS:\n\t\tcase TexFmt_ETC2_RGB4:\n\t\tcase TexFmt_ETC2_RGBA1:\n\t\tcase TexFmt_ETC2_RGBA8:\n\t\tcase TexFmt_PVRTC_RGB2:\n\t\tcase TexFmt_PVRTC_RGBA2:\n\t\tcase TexFmt_PVRTC_RGB4:\n\t\tcase TexFmt_PVRTC_RGBA4:\n\t\t{\n\t\t\ttypedef unsigned int(_cdecl *Wrap_GetMaxCompressedSize)(int width, int height, uint32_t texFmt);\n\t\t\tHMODULE hModule = LoadLibrary(TEXT("TexToolWrap.dll"));\n\t\t\tif (hModule)\n\t\t\t{\n\t\t\t\tWrap_GetMaxCompressedSize GetMaxCompressedSize = (Wrap_GetMaxCompressedSize)GetProcAddress(hModule, "GetMaxCompressedSize");\n\t\t\t\tsize_t decompSize = 0;\n\t\t\t\tif (GetMaxCompressedSize)\n\t\t\t\t\tdecompSize = GetMaxCompressedSize(width, height, (uint32_t)texFmt);\n\t\t\t\tFreeLibrary(hModule);\n\t\t\t\treturn decompSize;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t\tcase TexFmt_ASTC_RGB_4x4:\n\t\tcase TexFmt_ASTC_RGB_5x5:\n\t\tcase TexFmt_ASTC_RGB_6x6:\n\t\tcase TexFmt_ASTC_RGB_8x8:\n\t\tcase TexFmt_ASTC_RGB_10x10:\n\t\tcase TexFmt_ASTC_RGB_12x12:\n\t\tcase TexFmt_ASTC_RGBA_4x4:\n\t\tcase TexFmt_ASTC_RGBA_5x5:\n\t\tcase TexFmt_ASTC_RGBA_6x6:\n\t\tcase TexFmt_ASTC_RGBA_8x8:\n\t\tcase TexFmt_ASTC_RGBA_10x10:\n\t\tcase TexFmt_ASTC_RGBA_12x12:\n\t\tcase TexFmt_ASTC_HDR_4x4:\n\t\tcase TexFmt_ASTC_HDR_5x5:\n\t\tcase TexFmt_ASTC_HDR_6x6:\n\t\tcase TexFmt_ASTC_HDR_8x8:\n\t\tcase TexFmt_ASTC_HDR_10x10:\n\t\tcase TexFmt_ASTC_HDR_12x12:\n\t\t{\n\t\t\tint blockDim = astcTexFmt_GetBlockDim(texFmt);\n\t\t\tint blocksHor = (width / blockDim) + ((width % blockDim) ? 1 : 0);\n\t\t\tint blocksVert = (height / blockDim) + ((height % blockDim) ? 1 : 0);\n\t\t\t//128 bit per block, apparently for both SDR and HDR.\n\t\t\treturn (size_t)blocksHor * (size_t)blocksVert * (128 / 8);\n\t\t}\n\t\tbreak;\n\t\tdefault:\n\t\t\treturn 0;\n\t}\n\treturn 0;\n}\n\nstatic void texgenpack_compress_callback(BlockUserData *user_data) {}\ntypedef void(__cdecl* ISPCCompressBlocksFn)(const rgba_surface* src, uint8_t* dst, void* settings);\nvoid CompressDXTBlockCallback(const rgba_surface* src, uint8_t* dst, void* settings)\n{\n\tsquish::CompressImage((squish::u8*)src->ptr, src->width, src->height, dst, reinterpret_cast<int>(settings));\n}\nstruct ISPCCompressThreadPar\n{\n\trgba_surface surface;\n\tuint8_t *outBuf;\n\tvoid *encSettings;\n\tISPCCompressBlocksFn compressFn;\n\tHANDLE threadHandle;\n};\nDWORD _stdcall ISPCCompressThreadEntry(PVOID tpar)\n{\n\tISPCCompressThreadPar *pThreadPar = (ISPCCompressThreadPar*)tpar;\n\tpThreadPar->compressFn(&pThreadPar->surface, pThreadPar->outBuf, pThreadPar->encSettings);\n\treturn 0;\n}\ninline uint32_t GetNumberOfProcessors()\n{\n\tSYSTEM_INFO sysInfo;\n\tGetSystemInfo(&sysInfo);\n\tuint32_t numThreads = sysInfo.dwNumberOfProcessors;\n\tif (!numThreads) numThreads = 1;\n\treturn numThreads;\n}\n//Input must fit in 4x4 blocks; bytesPerBlock is 8 for DXT1, 16 for DXT5/BC6H/BC7\nvoid ISPCTexCompressMt(rgba_surface *surface, uint8_t *outBuf, void *settings, ISPCCompressBlocksFn compressFn, unsigned int bytesPerBlock)\n{\n\tif (surface->height <= 0)\n\t\treturn;\n\tuint32_t numThreads = GetNumberOfProcessors();\n\tuint32_t verticalBlocks = (uint32_t)(surface->height >> 2);\n\tif (numThreads > verticalBlocks)\n\t\tnumThreads = verticalBlocks;\n\tuint32_t vBlocksPerThread = verticalBlocks / numThreads;\n\tuint32_t vBlocksUnassigned = verticalBlocks % numThreads;\n\tISPCCompressThreadPar *pThreadPars = new ISPCCompressThreadPar[numThreads];\n\tuint32_t curPixelLine = 0;\n\tfor (uint32_t i = 0; i < numThreads; i++)\n\t{\n\t\tpThreadPars[i].surface.ptr = &surface->ptr[curPixelLine*surface->stride];\n\t\tpThreadPars[i].surface.width = surface->width;\n\t\tpThreadPars[i].surface.stride = surface->stride;\n\t\tpThreadPars[i].surface.height = vBlocksPerThread << 2;\n\t\tif (vBlocksUnassigned)\n\t\t{\n\t\t\tpThreadPars[i].surface.height += 4;\n\t\t\tvBlocksUnassigned--;\n\t\t}\n\t\tpThreadPars[i].outBuf = &outBuf[(curPixelLine >> 2) * (surface->width >> 2) * bytesPerBlock];\n\t\t\t//&outBuf[curPixelLine * surface->width]; //1 byte per pixel\n\t\tpThreadPars[i].encSettings = settings;\n\t\tpThreadPars[i].compressFn = compressFn;\n\t\tcurPixelLine += pThreadPars[i].surface.height;\n\t\tpThreadPars[i].threadHandle = CreateThread(NULL, 0, ISPCCompressThreadEntry, &pThreadPars[i], 0, NULL);\n\t}\n\tfor (uint32_t i = 0; i < numThreads; i++)\n\t{\n\t\tWaitForSingleObject(pThreadPars[i].threadHandle, INFINITE);\n\t\tCloseHandle(pThreadPars[i].threadHandle);\n\t}\n\tdelete[] pThreadPars;\n}\n\n//Simple linear filter.\n//Also allows in-place generation of the next mip map level (i.e. inBuf == outBuf).\n//Updates width and height parameters for the width/height of outBuf.\n//Returns false if there is no next mip map level, in which case outBuf is untouched.\nbool MakeNextMipmapLevel_RGBA32(const void *_inBuf, void *_outBuf, unsigned int &width, unsigned int &height)\n{\n\tconst uint8_t *inBuf = (const uint8_t*)_inBuf;\n\tuint32_t *outBuf = (uint32_t*)_outBuf;\n\tif (width && height)\n\t{\n\t\tunsigned int newWidth;\n\t\tunsigned int newHeight;\n\t\tif ((width >> 1) >= 1 && (height >> 1) >= 1)\n\t\t{\n\t\t\tnewWidth = width >> 1;\n\t\t\tnewHeight = height >> 1;\n\t\t\tfor (unsigned int y = 1; y < height; y += 2)\n\t\t\t{\n\t\t\t\tfor (unsigned int x = 1; x < width; x += 2)\n\t\t\t\t{\n\t\t\t\t\tuint8_t r = ((int)(inBuf)[4*((y-1) * width + (x-1))] +\n\t\t\t\t\t\t(int)(inBuf)[4*(y * width + (x-1))] +\n\t\t\t\t\t\t(int)(inBuf)[4*((y-1) * width + x)] +\n\t\t\t\t\t\t(int)(inBuf)[4*(y * width + x)])\n\t\t\t\t\t\t>> 2;\n\t\t\t\t\tuint8_t g = ((int)inBuf[1+4*((y-1) * width + (x-1))] +\n\t\t\t\t\t\t(int)inBuf[1+4*(y * width + (x-1))] +\n\t\t\t\t\t\t(int)inBuf[1+4*((y-1) * width + x)] +\n\t\t\t\t\t\t(int)inBuf[1+4*(y * width + x)])\n\t\t\t\t\t\t>> 2;\n\t\t\t\t\tuint8_t b = ((int)inBuf[2+4*((y-1) * width + (x-1))] +\n\t\t\t\t\t\t(int)inBuf[2+4*(y * width + (x-1))] +\n\t\t\t\t\t\t(int)inBuf[2+4*((y-1) * width + x)] +\n\t\t\t\t\t\t(int)inBuf[2+4*(y * width + x)])\n\t\t\t\t\t\t>> 2;\n\t\t\t\t\tuint8_t a = ((int)inBuf[3+4*((y-1) * width + (x-1))] +\n\t\t\t\t\t\t(int)inBuf[3+4*(y * width + (x-1))] +\n\t\t\t\t\t\t(int)inBuf[3+4*((y-1) * width + x)] +\n\t\t\t\t\t\t(int)inBuf[3+4*(y * width + x)])\n\t\t\t\t\t\t>> 2;\n\t\t\t\t\toutBuf[((y-1)>>1) * newWidth + ((x-1)>>1)] = r | (g << 8) | (b << 16) | (a << 24);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tunsigned int _len;\n\t\t\tif ((width >> 1) >= 1) //=> curWidth >= 2, curHeight == 1\n\t\t\t{\n\t\t\t\t//(curHeight / 2) : ]0;1[\n\t\t\t\tnewWidth = width >> 1;\n\t\t\t\tnewHeight = 1;\n\t\t\t\t_len = width;\n\t\t\t}\n\t\t\telse if ((height >> 1) >= 1) //=> curWidth == 1, curHeight >= 2\n\t\t\t{\n\t\t\t\t//(curWidth / 2) : ]0;1[\n\t\t\t\tnewWidth = 1;\n\t\t\t\tnewHeight = height >> 1;\n\t\t\t\t_len = height;\n\t\t\t}\n\t\t\telse\n\t\t\t\treturn false;\n\t\t\tfor (unsigned int i = 1; i < _len; i += 2)\n\t\t\t{\n\t\t\t\tuint8_t r = ((int)inBuf[4*(i-1)] +\n\t\t\t\t\t(int)inBuf[4*(i)])\n\t\t\t\t\t>> 1;\n\t\t\t\tuint8_t g = ((int)inBuf[1+4*(i-1)] +\n\t\t\t\t\t(int)inBuf[1+4*(i)])\n\t\t\t\t\t>> 1;\n\t\t\t\tuint8_t b = ((int)inBuf[2+4*(i-1)] +\n\t\t\t\t\t(int)inBuf[2+4*(i)])\n\t\t\t\t\t>> 1;\n\t\t\t\tuint8_t a = ((int)inBuf[3+4*(i-1)] +\n\t\t\t\t\t(int)inBuf[3+4*(i)])\n\t\t\t\t\t>> 1;\n\t\t\t\toutBuf[(i-1)>>1] = r | (g << 8) | (b << 16) | (a << 24);\n\t\t\t}\n\t\t}\n\t\twidth = newWidth;\n\t\theight = newHeight;\n\t}\n\telse\n\t\treturn false;\n\treturn true;\n}\n\ninline rgba_surface ispc_texcomp_prepare_surface_RGBA32(void* pRGBA32Buf, unsigned int curWidth, unsigned int curHeight,\n\tstd::unique_ptr<uint8_t[]> &pExtendedBuffer, unsigned int numOutChannels=4, unsigned int channelBits=8,\n\tstd::function<void(const uint8_t, uint8_t*)> convert = {})\n{\n\tif (!convert)\n\t{\n\t\tconvert = [channelBits](const uint8_t valInU8, uint8_t* valOut)\n\t\t{\n\t\t\tfor (unsigned int iBy = 0; iBy < channelBits / 8; ++iBy)\n\t\t\t\tvalOut[iBy] = valInU8;\n\t\t};\n\t}\n\tif (numOutChannels == 0 || numOutChannels > 4)\n\t\tthrow std::invalid_argument("ispc_texcomp_prepare_surface_RGBA32: numOutChannels should be in [1,4]");\n\tif ((channelBits & 7) != 0)\n\t\tthrow std::invalid_argument("ispc_texcomp_prepare_surface_RGBA32: channelBits must be a multiple of 8");\n\tif (curWidth > (unsigned int)std::numeric_limits<int>::max()\n\t\t|| curHeight > (unsigned int)std::numeric_limits<int>::max()\n\t\t|| (curWidth * 4 * sizeof(uint8_t)) > (unsigned int)std::numeric_limits<int>::max())\n\t\tthrow std::invalid_argument("ispc_texcomp_prepare_surface_RGBA32: width or height out of range");\n\trgba_surface surface = { (uint8_t*)pRGBA32Buf, (int)curWidth, (int)curHeight, (int)(curWidth * 4 * sizeof(uint8_t)) };\n\trgba_surface surfaceOut = surface;\n\n\tunsigned int extendedWidth = (curWidth + 3) & (~3);\n\tunsigned int extendedHeight = (curHeight + 3) & (~3);\n\tif (curWidth != extendedWidth || curHeight != extendedHeight || numOutChannels != 4 || channelBits != 8)\n\t{\n\t\tpExtendedBuffer.reset(new uint8_t[extendedWidth * extendedHeight * numOutChannels * (channelBits/8)]);\n\t\t//Copy the pixels, but only the first <numOutChannels> bytes per input pixel.\n\t\tfor (unsigned int y = 0; y < curHeight; ++y)\n\t\tfor (unsigned int x = 0; x < curWidth; ++x)\n\t\t{\n\t\t\tuint8_t *pIn = &((uint8_t*)pRGBA32Buf)[(y * curWidth + x) * 4];\n\t\t\tuint8_t *pOut = &pExtendedBuffer[(y * extendedWidth + x) * numOutChannels * (channelBits/8)];\n\t\t\t//Copy the respective channel; if channelBits=16,\n\t\t\t// replicate the channel value for each output byte (e.g. 0x1F -> 0x1F1F).\n\t\t\tfor (unsigned int iCh = 0; iCh < numOutChannels; ++iCh)\n\t\t\t\tconvert(pIn[iCh], &pOut[iCh * channelBits / 8]);\n\t\t}\n\t\tsurfaceOut.width = extendedWidth;\n\t\tsurfaceOut.height = extendedHeight;\n\t\tsurfaceOut.stride = extendedWidth * numOutChannels * (channelBits / 8) * sizeof(uint8_t);\n\t\tsurfaceOut.ptr = pExtendedBuffer.get();\n\n\t\tsurface.ptr = surfaceOut.ptr;\n\t\tsurface.stride = surfaceOut.stride;\n\t\t//Padding for the extended image dimensions (replicate the border pixel).\n\t\t//Helper function by ispc_texcomp.\n\t\tReplicateBorders(&surfaceOut, &surface, 0, 0, channelBits * numOutChannels);\n\t}\n\treturn surfaceOut;\n}\n\nvoid RGBA32_ToCompressed(TextureFile *pTex, void *pOutBuf, void *pRGBA32Buf, QWORD &outputSize, int compressQuality, unsigned int curWidth, unsigned int curHeight)\n{\n\tif (pTex->m_TextureFormat == TexFmt_DXT1Crunched || pTex->m_TextureFormat == TexFmt_DXT5Crunched\n\t\t|| pTex->m_TextureFormat == TexFmt_ETC_RGB4Crunched || pTex->m_TextureFormat == TexFmt_ETC2_RGBA8Crunched)\n\t{\n\t\t(pTex->extra.textureFormatVersion >= 1 ? CrunchTextureData_RGBA32_Unity : CrunchTextureData_RGBA32_Legacy)\n\t\t\t(pTex, pRGBA32Buf, pOutBuf, outputSize, compressQuality, curWidth, curHeight);\n\t}\n\telse\n\t{\n\t\tswitch (pTex->m_TextureFormat)\n\t\t{\n\t\tcase TexFmt_DXT1:\n\t\tcase TexFmt_DXT5:\n\t\t\t{\n\t\t\t\t//GetCompressedTextureDataSize takes care of DXT block size alignment (4x4).\n\t\t\t\tsize_t texLen = GetCompressedTextureDataSize(curWidth, curHeight, (TextureFormat)pTex->m_TextureFormat);\n\t\t\t\t//int squishDXTType = ((pTex->m_TextureFormat == TexFmt_DXT1 || pTex->m_TextureFormat == TexFmt_DXT1Crunched) ? squish::kDxt1 : squish::kDxt5);\n\t\t\t\tif (outputSize >= texLen)\n\t\t\t\t{\n\t\t\t\t\tint dxtFlags = ((pTex->m_TextureFormat == TexFmt_DXT1) ? squish::kDxt1 : squish::kDxt5);\n\t\t\t\t\tbool mt = false;\n\t\t\t\t\tswitch (compressQuality)\n\t\t\t\t\t{\n\t\t\t\t\t\tcase 1: mt = true; //normal mt\n\t\t\t\t\t\tcase 0: //normal\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tdxtFlags |= squish::kColourClusterFit;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 3: mt = true; //very fast mt\n\t\t\t\t\t\tcase 2: //very fast\n\t\t\t\t\t\t\tdxtFlags |= squish::kColourRangeFit;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 5: mt = true; //slow mt\n\t\t\t\t\t\tcase 4: //slow\n\t\t\t\t\t\t\tdxtFlags |= squish::kColourIterativeClusterFit;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (mt)\n\t\t\t\t\t{\n\t\t\t\t\t\tunsigned int extendedWidth = (curWidth + 3) & (~3);\n\t\t\t\t\t\tunsigned int extendedHeight = (curHeight + 3) & (~3);\n\t\t\t\t\t\tuint8_t *pRGBAExt = new uint8_t[extendedWidth * extendedHeight * 4];\n\t\t\t\t\t\tfor (unsigned int y = 0; y < curHeight; y++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tmemcpy(&pRGBAExt[y*extendedWidth*4], &((uint8_t*)pRGBA32Buf)[y*curWidth*4], curWidth * 4);\n\t\t\t\t\t\t\tfor (unsigned int x = curWidth; x < extendedWidth; x++)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tunsigned int outIndex = (y*extendedWidth+x)*4;\n\t\t\t\t\t\t\t\tunsigned int inIndex = (y*extendedWidth+curWidth-1)*4;\n\t\t\t\t\t\t\t\tpRGBAExt[outIndex] = pRGBAExt[inIndex];\n\t\t\t\t\t\t\t\tpRGBAExt[outIndex+1] = pRGBAExt[inIndex+1];\n\t\t\t\t\t\t\t\tpRGBAExt[outIndex+2] = pRGBAExt[inIndex+2];\n\t\t\t\t\t\t\t\tpRGBAExt[outIndex+3] = pRGBAExt[inIndex+3];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor (unsigned int y = curHeight; y < extendedHeight; y++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tmemcpy(&pRGBAExt[(y*extendedWidth)*4], &pRGBAExt[((curHeight-1)*extendedWidth)*4], extendedWidth*4 * sizeof(uint8_t));\n\t\t\t\t\t\t}\n\t\t\t\t\t\trgba_surface surface;\n\t\t\t\t\t\tsurface.width = extendedWidth;\n\t\t\t\t\t\tsurface.height = extendedHeight;\n\t\t\t\t\t\tsurface.stride = extendedWidth * 4;\n\t\t\t\t\t\tsurface.ptr = pRGBAExt;\n\t\t\t\t\t\tISPCTexCompressMt(\n\t\t\t\t\t\t\t&surface, \n\t\t\t\t\t\t\t(uint8_t*)pOutBuf, \n\t\t\t\t\t\t\t(void*)dxtFlags, \n\t\t\t\t\t\t\tCompressDXTBlockCallback, \n\t\t\t\t\t\t\t(pTex->m_TextureFormat == TexFmt_DXT1) ? 8 : 16\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\tdelete[] pRGBAExt;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t\tsquish::CompressImage((squish::u8*)pRGBA32Buf, curWidth, curHeight, pOutBuf, dxtFlags);\n\t\t\t\t\toutputSize = texLen;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\toutputSize = 0;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TexFmt_BC4:\n\t\tcase TexFmt_BC5:\n\t\t\t{\n\t\t\t\tbool mt = false;\n\t\t\t\tswitch (compressQuality)\n\t\t\t\t{\n\t\t\t\tcase 5:\n\t\t\t\tcase 6:\n\t\t\t\tcase 7:\n\t\t\t\tcase 8:\n\t\t\t\tcase 9:\n\t\t\t\t\tmt = true;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tmt = false;\n\t\t\t\t}\n\t\t\t\tstd::unique_ptr<uint8_t[]> pExtendedBuffer;\n\t\t\t\t//BC4 only uses the red channel, BC5 uses red and green.\n\t\t\t\t//The compressor expects the input data to only have these channels.\n\t\t\t\trgba_surface surface = ispc_texcomp_prepare_surface_RGBA32(pRGBA32Buf, curWidth, curHeight, pExtendedBuffer, (pTex->m_TextureFormat == TexFmt_BC4) ? 1 : 2);\n\t\t\t\tsize_t texLen = GetCompressedTextureDataSize(surface.width, surface.height, (TextureFormat)pTex->m_TextureFormat);\n\t\t\t\tif (outputSize >= texLen)\n\t\t\t\t{\n\t\t\t\t\tif (pTex->m_TextureFormat == TexFmt_BC4)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (mt)\n\t\t\t\t\t\t\tISPCTexCompressMt(&surface, (uint8_t*)pOutBuf, nullptr, (ISPCCompressBlocksFn)CompressBlocksBC4, 8);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tCompressBlocksBC4(&surface, (uint8_t*)pOutBuf);\n\t\t\t\t\t}\n\t\t\t\t\telse //if (pTex->m_TextureFormat == TexFmt_BC5)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (mt)\n\t\t\t\t\t\t\tISPCTexCompressMt(&surface, (uint8_t*)pOutBuf, nullptr, (ISPCCompressBlocksFn)CompressBlocksBC5, 16);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tCompressBlocksBC5(&surface, (uint8_t*)pOutBuf);\n\t\t\t\t\t}\n\t\t\t\t\toutputSize = texLen;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\toutputSize = 0;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TexFmt_BC6H:\n\t\t\t{\n\t\t\t\tbc6h_enc_settings settings;\n\t\t\t\tbool mt = false;\n\t\t\t\tswitch (compressQuality)\n\t\t\t\t{\n\t\t\t\tcase 5: mt = true;\n\t\t\t\tcase 0:\n\t\t\t\t\tGetProfile_bc6h_veryfast(&settings);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 6: mt = true;\n\t\t\t\tcase 1:\n\t\t\t\t\tGetProfile_bc6h_fast(&settings);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 7: mt = true;\n\t\t\t\tcase 2:\n\t\t\t\tdefault:\n\t\t\t\t\tGetProfile_bc6h_basic(&settings);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 8: mt = true;\n\t\t\t\tcase 3:\n\t\t\t\t\tGetProfile_bc6h_slow(&settings);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 9: mt = true;\n\t\t\t\tcase 4:\n\t\t\t\t\tGetProfile_bc6h_veryslow(&settings);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tstd::unique_ptr<uint8_t[]> pExtendedBuffer;\n\t\t\t\t//BC6H uses r,g,b with FP16 each; the alpha channel is present in the inputs but ignored.\n\t\t\t\trgba_surface surface = ispc_texcomp_prepare_surface_RGBA32(pRGBA32Buf, curWidth, curHeight, pExtendedBuffer, 4, 16,\n\t\t\t\t\t[](uint8_t valInU8, uint8_t* valOutHalf)\n\t\t\t\t\t{\n\t\t\t\t\t\tHalfFloat result; result.toHalf((float)valInU8 / 255.0f);\n\t\t\t\t\t\t*(uint16_t*)valOutHalf = result.half;\n\t\t\t\t\t});\n\t\t\t\tsize_t texLen = GetCompressedTextureDataSize(surface.width, surface.height, (TextureFormat)pTex->m_TextureFormat);\n\t\t\t\tif (outputSize >= texLen)\n\t\t\t\t{\n\t\t\t\t\tif (mt)\n\t\t\t\t\t\tISPCTexCompressMt(&surface, (uint8_t*)pOutBuf, &settings, (ISPCCompressBlocksFn)CompressBlocksBC6H, 16);\n\t\t\t\t\telse\n\t\t\t\t\t\tCompressBlocksBC6H(&surface, (uint8_t*)pOutBuf, &settings);\n\t\t\t\t\toutputSize = texLen;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\toutputSize = 0;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TexFmt_BC7:\n\t\t\t{\n\t\t\t\tbc7_enc_settings settings;\n\t\t\t\tbool mt = false;\n\t\t\t\tswitch (compressQuality)\n\t\t\t\t{\n\t\t\t\tcase 5: mt = true;\n\t\t\t\tcase 0:\n\t\t\t\t\tGetProfile_alpha_ultrafast(&settings);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 6: mt = true;\n\t\t\t\tcase 1:\n\t\t\t\t\tGetProfile_alpha_veryfast(&settings);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 7: mt = true;\n\t\t\t\tcase 2:\n\t\t\t\t\tGetProfile_alpha_fast(&settings);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 8: mt = true;\n\t\t\t\tcase 3:\n\t\t\t\tdefault:\n\t\t\t\t\tGetProfile_alpha_basic(&settings);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 9: mt = true;\n\t\t\t\tcase 4:\n\t\t\t\t\tGetProfile_alpha_slow(&settings);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tstd::unique_ptr<uint8_t[]> pExtendedBuffer;\n\t\t\t\t//Regular RGBA 32bpp input.\n\t\t\t\trgba_surface surface = ispc_texcomp_prepare_surface_RGBA32(pRGBA32Buf, curWidth, curHeight, pExtendedBuffer, 4, 8);\n\t\t\t\tsize_t texLen = GetCompressedTextureDataSize(surface.width, surface.height, (TextureFormat)pTex->m_TextureFormat);\n\t\t\t\tif (outputSize >= texLen)\n\t\t\t\t{\n\t\t\t\t\tif (mt)\n\t\t\t\t\t\tISPCTexCompressMt(&surface, (uint8_t*)pOutBuf, &settings, (ISPCCompressBlocksFn)CompressBlocksBC7, 16);\n\t\t\t\t\telse\n\t\t\t\t\t\tCompressBlocksBC7(&surface, (uint8_t*)pOutBuf, &settings);\n\t\t\t\t\toutputSize = texLen;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\toutputSize = 0;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TexFmt_YUV2: //not actually compressed but it\'s also handled\n\t\tcase TexFmt_EAC_R:\n\t\tcase TexFmt_EAC_R_SIGNED:\n\t\tcase TexFmt_EAC_RG:\n\t\tcase TexFmt_EAC_RG_SIGNED:\n\t\tcase TexFmt_ETC_RGB4:\n\t\tcase TexFmt_ETC_RGB4_3DS:\n\t\tcase TexFmt_ETC_RGBA8_3DS:\n\t\tcase TexFmt_ETC2_RGB4:\n\t\tcase TexFmt_ETC2_RGBA1:\n\t\tcase TexFmt_ETC2_RGBA8:\n\t\tcase TexFmt_PVRTC_RGB2:\n\t\tcase TexFmt_PVRTC_RGBA2:\n\t\tcase TexFmt_PVRTC_RGB4:\n\t\tcase TexFmt_PVRTC_RGBA4:\n\t\t\t{\n\t\t\t\ttypedef size_t(_cdecl* Wrap_Compress)(uint32_t texFmt, unsigned int height, unsigned int width, unsigned int mipCount, void* pInBuf, size_t inBufLen, void* pOutBuf, size_t outBufLen, int compressQuality);\n\t\t\t\tHMODULE hModule = LoadLibrary(TEXT("TexToolWrap.dll"));\n\t\t\t\tif (hModule)\n\t\t\t\t{\n\t\t\t\t\tWrap_Compress Compress = (Wrap_Compress)GetProcAddress(hModule, "Compress");\n\t\t\t\t\tif (Compress)\n\t\t\t\t\t\toutputSize =\n\t\t\t\t\t\tCompress(pTex->m_TextureFormat,\n\t\t\t\t\t\t\tcurHeight, curWidth, 1,\n\t\t\t\t\t\t\tpRGBA32Buf, curWidth * curHeight * 4,\n\t\t\t\t\t\t\tpOutBuf, outputSize, compressQuality);\n\t\t\t\t\telse\n\t\t\t\t\t\toutputSize = 0;\n\t\t\t\t\tFreeLibrary(hModule);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TexFmt_ASTC_RGB_4x4:\n\t\tcase TexFmt_ASTC_RGB_5x5:\n\t\tcase TexFmt_ASTC_RGB_6x6:\n\t\tcase TexFmt_ASTC_RGB_8x8:\n\t\tcase TexFmt_ASTC_RGB_10x10:\n\t\tcase TexFmt_ASTC_RGB_12x12:\n\t\tcase TexFmt_ASTC_RGBA_4x4:\n\t\tcase TexFmt_ASTC_RGBA_5x5:\n\t\tcase TexFmt_ASTC_RGBA_6x6:\n\t\tcase TexFmt_ASTC_RGBA_8x8:\n\t\tcase TexFmt_ASTC_RGBA_10x10:\n\t\tcase TexFmt_ASTC_RGBA_12x12:\n\t\t\t{\n\t\t\t\tbool mt = false;\n\t\t\t\tfloat astcenc_profile = ASTCENC_PRE_FAST;\n\t\t\t\tswitch (compressQuality)\n\t\t\t\t{\n\t\t\t\tcase 5: mt = true;\n\t\t\t\tcase 0:\n\t\t\t\t\tastcenc_profile = ASTCENC_PRE_FASTEST;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 6: mt = true;\n\t\t\t\tcase 1:\n\t\t\t\t\tastcenc_profile = ASTCENC_PRE_FAST;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 7: mt = true;\n\t\t\t\tcase 2:\n\t\t\t\t\tastcenc_profile = ASTCENC_PRE_MEDIUM;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 8: mt = true;\n\t\t\t\tcase 3:\n\t\t\t\tdefault:\n\t\t\t\t\tastcenc_profile = ASTCENC_PRE_THOROUGH;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 9: mt = true;\n\t\t\t\tcase 4:\n\t\t\t\t\tastcenc_profile = ASTCENC_PRE_EXHAUSTIVE;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tint blockDim = astcTexFmt_GetBlockDim((TextureFormat)pTex->m_TextureFormat);\n\t\t\t\tbool isHDR = (pTex->m_TextureFormat >= TexFmt_ASTC_HDR_4x4 && pTex->m_TextureFormat <= TexFmt_ASTC_HDR_12x12);\n\n\t\t\t\tastcenc_config astcenc_cfg;\n\t\t\t\tif (astcenc_config_init(isHDR ? ASTCENC_PRF_HDR : ASTCENC_PRF_LDR,\n\t\t\t\t\tblockDim, blockDim, 1,\n\t\t\t\t\tastcenc_profile,\n\t\t\t\t\t0, &astcenc_cfg)\n\t\t\t\t\t!= ASTCENC_SUCCESS)\n\t\t\t\t\treturn;\n\t\t\t\t//Note: May be noticably more efficient to reuse a context, as per the astcenc documentation.\n\t\t\t\tastcenc_context* pAstcencContext = nullptr;\n\t\t\t\tunsigned int numThreads = 1;\n\t\t\t\tif (mt)\n\t\t\t\t{\n\t\t\t\t\tnumThreads = std::thread::hardware_concurrency();\n\t\t\t\t\tif (numThreads == 0) numThreads = 2;\n\t\t\t\t}\n\t\t\t\tif (astcenc_context_alloc(&astcenc_cfg, numThreads, &pAstcencContext)\n\t\t\t\t\t!= ASTCENC_SUCCESS)\n\t\t\t\t\treturn;\n\t\t\t\tastcenc_compress_reset(pAstcencContext);\n\t\t\t\tastcenc_image image_in = {};\n\t\t\t\tvoid* dataSlices[1] = { pRGBA32Buf }; //z size = 1\n\t\t\t\timage_in.data = &dataSlices[0];\n\t\t\t\timage_in.data_type = ASTCENC_TYPE_U8;\n\t\t\t\timage_in.dim_x = pTex->m_Width;\n\t\t\t\timage_in.dim_y = pTex->m_Height;\n\t\t\t\timage_in.dim_z = 1;\n\t\t\t\tastcenc_swizzle swizzle = {};\n\t\t\t\tswizzle.r = ASTCENC_SWZ_R;\n\t\t\t\tswizzle.g = ASTCENC_SWZ_G;\n\t\t\t\tswizzle.b = ASTCENC_SWZ_B;\n\t\t\t\tswizzle.a = ASTCENC_SWZ_A;\n\t\t\t\tstd::vector<std::jthread> threads(numThreads - 1);\n\t\t\t\tfor (unsigned int i = 1; i < numThreads; ++i)\n\t\t\t\t{\n\t\t\t\t\tthreads[i - 1] = std::jthread([pAstcencContext, &image_in, &swizzle, pOutBuf, outputSize, i]()\n\t\t\t\t\t{\n\t\t\t\t\t\tastcenc_compress_image(pAstcencContext, &image_in, &swizzle, (uint8_t*)pOutBuf, outputSize, i);\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\tauto result = astcenc_compress_image(pAstcencContext, &image_in, &swizzle, (uint8_t*)pOutBuf, outputSize, 0);\n\t\t\t\tthreads.clear();\n\t\t\t\tastcenc_context_free(pAstcencContext);\n\t\t\t\tif (result != ASTCENC_SUCCESS)\n\t\t\t\t\treturn;\n\t\t\t\toutputSize = GetCompressedTextureDataSize((int)pTex->m_Width, (int)pTex->m_Height, (TextureFormat)pTex->m_TextureFormat);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nASSETSTOOLS_API bool MakeTextureData(TextureFile *pTex, void *pRGBA32Buf, int compressQuality)\n{\n\tuint8_t *outPictureData = pTex->pPictureData;\n\tif (pTex->m_TextureFormat == TexFmt_DXT1Crunched || pTex->m_TextureFormat == TexFmt_DXT5Crunched\n\t\t|| pTex->m_TextureFormat == TexFmt_ETC_RGB4Crunched || pTex->m_TextureFormat == TexFmt_ETC2_RGBA8Crunched)\n\t{\n\t\tQWORD outputSize = pTex->_pictureDataSize;\n\t\t\n\t\tif ((pTex->extra.textureFormatVersion >= 1 ? CrunchTextureData_RGBA32_Unity : CrunchTextureData_RGBA32_Legacy)\n\t\t\t  (pTex, pRGBA32Buf, outPictureData, outputSize, compressQuality, pTex->m_Width, pTex->m_Height))\n\t\t{\n\t\t\tpTex->_pictureDataSize = pTex->m_CompleteImageSize = (uint32_t)outputSize;\n\t\t\treturn true;\n\t\t}\n\t\telse\n\t\t\treturn false;\n\t}\n\tint curMipCount = pTex->m_MipCount;\n\tint totalMipCount = 0;\n\tunsigned int curWidth = pTex->m_Width;\n\tunsigned int curHeight = pTex->m_Height;\n\tQWORD curOutIndex = 0;\n\tdo {\n\t\tswitch (pTex->m_TextureFormat) {\n\t\t\tcase TexFmt_ARGB32:\n\t\t\t\t{\n\t\t\t\t\tif ((curOutIndex > pTex->_pictureDataSize) || (pTex->_pictureDataSize - curOutIndex) < (curWidth * curHeight * 4))\n\t\t\t\t\t\treturn false;\n\t\t\t\t\tuint32_t pixelCount = curWidth * curHeight;\n\t\t\t\t\tfor (uint32_t i = 0; i < pixelCount; i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tuint8_t rgba[4];\n\t\t\t\t\t\t*((uint32_t*)rgba) = ((uint32_t*)pRGBA32Buf)[i];\n\t\t\t\t\t\toutPictureData[curOutIndex+i*4] = rgba[3]; //A\n\t\t\t\t\t\toutPictureData[curOutIndex+i*4+1] = rgba[0]; //R\n\t\t\t\t\t\toutPictureData[curOutIndex+i*4+2] = rgba[1]; //B\n\t\t\t\t\t\toutPictureData[curOutIndex+i*4+3] = rgba[2]; //G\n\t\t\t\t\t}\n\t\t\t\t\tcurOutIndex += (curWidth * curHeight * 4);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase TexFmt_BGRA32Old:\n\t\t\tcase TexFmt_BGRA32New:\n\t\t\t\t{\n\t\t\t\t\tif ((curOutIndex > pTex->_pictureDataSize) || (pTex->_pictureDataSize - curOutIndex) < (curWidth * curHeight * 4))\n\t\t\t\t\t\treturn false;\n\t\t\t\t\tuint32_t pixelCount = curWidth * curHeight;\n\t\t\t\t\tfor (uint32_t i = 0; i < pixelCount; i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tuint8_t rgba[4];\n\t\t\t\t\t\t*((uint32_t*)rgba) = ((uint32_t*)pRGBA32Buf)[i];\n\t\t\t\t\t\toutPictureData[curOutIndex+i*4] = rgba[2]; //B\n\t\t\t\t\t\toutPictureData[curOutIndex+i*4+1] = rgba[1]; //G\n\t\t\t\t\t\toutPictureData[curOutIndex+i*4+2] = rgba[0]; //R\n\t\t\t\t\t\toutPictureData[curOutIndex+i*4+3] = rgba[3]; //A\n\t\t\t\t\t}\n\t\t\t\t\tcurOutIndex += (curWidth * curHeight * 4);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase TexFmt_RGBA32:\n\t\t\t\tif ((curOutIndex > pTex->_pictureDataSize) || (pTex->_pictureDataSize - curOutIndex) < (curWidth * curHeight * 4))\n\t\t\t\t\treturn false;\n\t\t\t\tmemcpy(&outPictureData[curOutIndex], pRGBA32Buf, curWidth * curHeight * 4);\n\t\t\t\tcurOutIndex += (curWidth * curHeight * 4);\n\t\t\t\tbreak;\n\t\t\tcase TexFmt_RGB24:\n\t\t\t\t{\n\t\t\t\t\tif ((curOutIndex > pTex->_pictureDataSize) || (pTex->_pictureDataSize - curOutIndex) < (curWidth * curHeight * 3))\n\t\t\t\t\t\treturn false;\n\t\t\t\t\tuint32_t pixelCount = curWidth * curHeight;\n\t\t\t\t\tfor (uint32_t i = 0; i < pixelCount; i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tuint8_t rgba[4];\n\t\t\t\t\t\t*((uint32_t*)rgba) = ((uint32_t*)pRGBA32Buf)[i];\n\t\t\t\t\t\toutPictureData[curOutIndex+i*3] = rgba[0]; //R\n\t\t\t\t\t\toutPictureData[curOutIndex+i*3+1] = rgba[1]; //G\n\t\t\t\t\t\toutPictureData[curOutIndex+i*3+2] = rgba[2]; //B\n\t\t\t\t\t}\n\t\t\t\t\tcurOutIndex += (curWidth * curHeight * 3);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase TexFmt_ARGB4444:\n\t\t\t\t{\n\t\t\t\t\tif ((curOutIndex > pTex->_pictureDataSize) || (pTex->_pictureDataSize - curOutIndex) < (curWidth * curHeight * 2))\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t//G,B,A,R\n\t\t\t\t\tuint32_t pixelCount = curWidth * curHeight;\n\t\t\t\t\tfor (uint32_t i = 0; i < pixelCount; i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tuint8_t rgba[4];\n\t\t\t\t\t\t*((uint32_t*)rgba) = ((uint32_t*)pRGBA32Buf)[i];\n\t\t\t\t\t\t// >> 4 is equal to / 16 (to reduce the 8bit data to 4bit)\n\t\t\t\t\t\toutPictureData[curOutIndex+i*2] = (((rgba[1] >> 4) & 15) << 4) | ((rgba[2] >> 4) & 15); //G,B\n\t\t\t\t\t\toutPictureData[curOutIndex+i*2+1] = (((rgba[3] >> 4) & 15) << 4) | ((rgba[0] >> 4) & 15); //A,R \n\t\t\t\t\t}\n\t\t\t\t\tcurOutIndex += (curWidth * curHeight * 2);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase TexFmt_RGBA4444:\n\t\t\t\t{\n\t\t\t\t\tif ((curOutIndex > pTex->_pictureDataSize) || (pTex->_pictureDataSize - curOutIndex) < (curWidth * curHeight * 2))\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t//BARG\n\t\t\t\t\tuint32_t pixelCount = curWidth * curHeight;\n\t\t\t\t\tfor (uint32_t i = 0; i < pixelCount; i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tuint8_t rgba[4];\n\t\t\t\t\t\t*((uint32_t*)rgba) = ((uint32_t*)pRGBA32Buf)[i];\n\t\t\t\t\t\t// >> 4 is equal to / 16 (to reduce the 8bit data to 4bit)\n\t\t\t\t\t\toutPictureData[curOutIndex+i*2+1] = (((rgba[0] >> 4) & 15) << 4) | ((rgba[1] >> 4) & 15); //R,G\n\t\t\t\t\t\toutPictureData[curOutIndex+i*2] = (((rgba[2] >> 4) & 15) << 4) | ((rgba[3] >> 4) & 15); //B,A\n\t\t\t\t\t}\n\t\t\t\t\tcurOutIndex += (curWidth * curHeight * 2);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase TexFmt_RGB565:\n\t\t\t\t{\n\t\t\t\t\tif ((curOutIndex > pTex->_pictureDataSize) || (pTex->_pictureDataSize - curOutIndex) < (curWidth * curHeight * 2))\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t//g3(low)b5g3(high)r5\n\t\t\t\t\tuint32_t pixelCount = curWidth * curHeight;\n\t\t\t\t\tfor (uint32_t i = 0; i < pixelCount; i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tuint8_t rgba[4];\n\t\t\t\t\t\t*((uint32_t*)rgba) = ((uint32_t*)pRGBA32Buf)[i];\n\t\t\t\t\t\t// >> 3 is equal to / 8 (to reduce the 8bit data to 5bit)\n\t\t\t\t\t\tuint8_t r5 = (rgba[0] >> 3) & 31;\n\t\t\t\t\t\t// >> 2 is equal to / 4 (to reduce the 8bit data to 6bit)\n\t\t\t\t\t\tuint8_t g6 = (rgba[1] >> 2) & 63;\n\t\t\t\t\t\t// >> 3 is equal to / 8 (to reduce the 8bit data to 5bit)\n\t\t\t\t\t\tuint8_t b5 = (rgba[2] >> 3) & 31;\n\t\t\t\t\t\tuint16_t rgb565 = ((uint16_t)r5 << 11) | ((uint16_t)g6 << 5) | ((uint16_t)b5);\n\t\t\t\t\t\t*(uint16_t*)(&outPictureData[curOutIndex+i*2]) = rgb565;//((rgb565 & 0xFF00) >> 8) | ((rgb565 & 0x00FF) << 8);\n\t\t\t\t\t}\n\t\t\t\t\tcurOutIndex += (curWidth * curHeight * 2);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase TexFmt_Alpha8:\n\t\t\t\t{\n\t\t\t\t\tif ((curOutIndex > pTex->_pictureDataSize) || (pTex->_pictureDataSize - curOutIndex) < (curWidth * curHeight))\n\t\t\t\t\t\treturn false;\n\t\t\t\t\tuint32_t pixelCount = curWidth * curHeight;\n\t\t\t\t\tfor (uint32_t i = 0; i < pixelCount; i++)\n\t\t\t\t\t{\n\t\t\t\t\t\toutPictureData[curOutIndex+i] = ((uint8_t*)pRGBA32Buf)[i*4+3];\n\t\t\t\t\t}\n\t\t\t\t\tcurOutIndex += (curWidth * curHeight);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase TexFmt_RHalf:\n\t\t\t\t{\n\t\t\t\t\tif ((curOutIndex > pTex->_pictureDataSize) || (pTex->_pictureDataSize - curOutIndex) < (curWidth * curHeight * 2))\n\t\t\t\t\t\treturn false;\n\t\t\t\t\tuint32_t pixelCount = curWidth * curHeight;\n\t\t\t\t\tHalfFloat hf;\n\t\t\t\t\tfor (uint32_t i = 0; i < pixelCount; i++)\n\t\t\t\t\t{\n\t\t\t\t\t\thf.toHalf((float)((uint8_t*)pRGBA32Buf)[i*4] / 255.0F);\n\t\t\t\t\t\t*(uint16_t*)(&outPictureData[curOutIndex+i*2]) = hf.half;\n\t\t\t\t\t}\n\t\t\t\t\tcurOutIndex += (curWidth * curHeight * 2);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase TexFmt_RGHalf:\n\t\t\t\t{\n\t\t\t\t\tif ((curOutIndex > pTex->_pictureDataSize) || (pTex->_pictureDataSize - curOutIndex) < (curWidth * curHeight * 4))\n\t\t\t\t\t\treturn false;\n\t\t\t\t\tuint32_t pixelCount = curWidth * curHeight;\n\t\t\t\t\tHalfFloat hf;\n\t\t\t\t\tfor (uint32_t i = 0; i < pixelCount; i++)\n\t\t\t\t\t{\n\t\t\t\t\t\thf.toHalf((float)((uint8_t*)pRGBA32Buf)[i*4] / 255.0F);\n\t\t\t\t\t\t*(uint16_t*)(&outPictureData[curOutIndex+i*4]) = hf.half;\n\t\t\t\t\t\thf.toHalf((float)((uint8_t*)pRGBA32Buf)[i*4+1] / 255.0F);\n\t\t\t\t\t\t*(uint16_t*)(&outPictureData[curOutIndex+i*4+2]) = hf.half;\n\t\t\t\t\t}\n\t\t\t\t\tcurOutIndex += (curWidth * curHeight * 4);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase TexFmt_RGBAHalf:\n\t\t\t\t{\n\t\t\t\t\tif ((curOutIndex > pTex->_pictureDataSize) || (pTex->_pictureDataSize - curOutIndex) < (curWidth * curHeight * 8))\n\t\t\t\t\t\treturn false;\n\t\t\t\t\tuint32_t pixelCount = curWidth * curHeight;\n\t\t\t\t\tHalfFloat hf;\n\t\t\t\t\tfor (uint32_t i = 0; i < pixelCount; i++)\n\t\t\t\t\t{\n\t\t\t\t\t\thf.toHalf((float)((uint8_t*)pRGBA32Buf)[i*4] / 255.0F);\n\t\t\t\t\t\t*(uint16_t*)(&outPictureData[curOutIndex+i*8]) = hf.half;\n\t\t\t\t\t\thf.toHalf((float)((uint8_t*)pRGBA32Buf)[i*4+1] / 255.0F);\n\t\t\t\t\t\t*(uint16_t*)(&outPictureData[curOutIndex+i*8+2]) = hf.half;\n\t\t\t\t\t\thf.toHalf((float)((uint8_t*)pRGBA32Buf)[i*4+2] / 255.0F);\n\t\t\t\t\t\t*(uint16_t*)(&outPictureData[curOutIndex+i*8+4]) = hf.half;\n\t\t\t\t\t\thf.toHalf((float)((uint8_t*)pRGBA32Buf)[i*4+3] / 255.0F);\n\t\t\t\t\t\t*(uint16_t*)(&outPictureData[curOutIndex+i*8+6]) = hf.half;\n\t\t\t\t\t}\n\t\t\t\t\tcurOutIndex += (curWidth * curHeight * 8);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase TexFmt_RFloat:\n\t\t\t\t{\n\t\t\t\t\tif ((curOutIndex > pTex->_pictureDataSize) || (pTex->_pictureDataSize - curOutIndex) < (curWidth * curHeight * 4))\n\t\t\t\t\t\treturn false;\n\t\t\t\t\tuint32_t pixelCount = curWidth * curHeight;\n\t\t\t\t\tfor (uint32_t i = 0; i < pixelCount; i++)\n\t\t\t\t\t{\n\t\t\t\t\t\t*(float*)(&outPictureData[curOutIndex+i*4]) = (float)((uint8_t*)pRGBA32Buf)[i*4] / 255.0F;\n\t\t\t\t\t}\n\t\t\t\t\tcurOutIndex += (curWidth * curHeight * 4);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase TexFmt_RGFloat:\n\t\t\t\t{\n\t\t\t\t\tif ((curOutIndex > pTex->_pictureDataSize) || (pTex->_pictureDataSize - curOutIndex) < (curWidth * curHeight * 8))\n\t\t\t\t\t\treturn false;\n\t\t\t\t\tuint32_t pixelCount = curWidth * curHeight;\n\t\t\t\t\tfor (uint32_t i = 0; i < pixelCount; i++)\n\t\t\t\t\t{\n\t\t\t\t\t\t*(float*)(&outPictureData[curOutIndex+i*8]) = (float)((uint8_t*)pRGBA32Buf)[i*4] / 255.0F;\n\t\t\t\t\t\t*(float*)(&outPictureData[curOutIndex+i*8+4]) = (float)((uint8_t*)pRGBA32Buf)[i*4+1] / 255.0F;\n\t\t\t\t\t}\n\t\t\t\t\tcurOutIndex += (curWidth * curHeight * 8);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase TexFmt_RGBAFloat:\n\t\t\t\t{\n\t\t\t\t\tif ((curOutIndex > pTex->_pictureDataSize) || (pTex->_pictureDataSize - curOutIndex) < (curWidth * curHeight * 16))\n\t\t\t\t\t\treturn false;\n\t\t\t\t\tuint32_t pixelCount = curWidth * curHeight;\n\t\t\t\t\tfor (uint32_t i = 0; i < pixelCount; i++)\n\t\t\t\t\t{\n\t\t\t\t\t\t*(float*)(&outPictureData[curOutIndex+i*16]) = (float)((uint8_t*)pRGBA32Buf)[i*4] / 255.0F;\n\t\t\t\t\t\t*(float*)(&outPictureData[curOutIndex+i*16+4]) = (float)((uint8_t*)pRGBA32Buf)[i*4+1] / 255.0F;\n\t\t\t\t\t\t*(float*)(&outPictureData[curOutIndex+i*16+8]) = (float)((uint8_t*)pRGBA32Buf)[i*4+2] / 255.0F;\n\t\t\t\t\t\t*(float*)(&outPictureData[curOutIndex+i*16+12]) = (float)((uint8_t*)pRGBA32Buf)[i*4+3] / 255.0F;\n\t\t\t\t\t}\n\t\t\t\t\tcurOutIndex += (curWidth * curHeight * 16);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase TexFmt_RGB9e5Float:\n\t\t\t\t{\n\t\t\t\t\tif ((curOutIndex > pTex->_pictureDataSize) || (pTex->_pictureDataSize - curOutIndex) < (curWidth * curHeight * 4))\n\t\t\t\t\t\treturn false;\n\t\t\t\t\tuint32_t pixelCount = curWidth * curHeight;\n\t\t\t\t\tfor (uint32_t i = 0; i < pixelCount; i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tfloat color[3] = {\n\t\t\t\t\t\t\t(float)((uint8_t*)pRGBA32Buf)[i*4] / 255.0F, \n\t\t\t\t\t\t\t(float)((uint8_t*)pRGBA32Buf)[i*4+1] / 255.0F, \n\t\t\t\t\t\t\t(float)((uint8_t*)pRGBA32Buf)[i*4+2] / 255.0F\n\t\t\t\t\t\t};\n\t\t\t\t\t\tRGB9e5Float rgbFloat; rgbFloat.toRGB9e5(color);\n\t\t\t\t\t\t*(unsigned int*)(&outPictureData[curOutIndex+i*4]) = rgbFloat.value;\n\t\t\t\t\t}\n\t\t\t\t\tcurOutIndex += (curWidth * curHeight * 4);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase TexFmt_RG16:\n\t\t\t\t{\n\t\t\t\t\tif ((curOutIndex > pTex->_pictureDataSize) || (pTex->_pictureDataSize - curOutIndex) < (curWidth * curHeight * 2))\n\t\t\t\t\t\treturn false;\n\t\t\t\t\tuint32_t pixelCount = curWidth * curHeight;\n\t\t\t\t\tfor (uint32_t i = 0; i < pixelCount; i++)\n\t\t\t\t\t{\n\t\t\t\t\t\toutPictureData[curOutIndex+2*i] = ((uint8_t*)pRGBA32Buf)[i*4];\n\t\t\t\t\t\toutPictureData[curOutIndex+2*i+1] = ((uint8_t*)pRGBA32Buf)[i*4+1];\n\t\t\t\t\t}\n\t\t\t\t\tcurOutIndex += (curWidth * curHeight * 2);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase TexFmt_R8:\n\t\t\t\t{\n\t\t\t\t\tif ((curOutIndex > pTex->_pictureDataSize) || (pTex->_pictureDataSize - curOutIndex) < (curWidth * curHeight))\n\t\t\t\t\t\treturn false;\n\t\t\t\t\tuint32_t pixelCount = curWidth * curHeight;\n\t\t\t\t\tfor (uint32_t i = 0; i < pixelCount; i++)\n\t\t\t\t\t{\n\t\t\t\t\t\toutPictureData[curOutIndex+i] = ((uint8_t*)pRGBA32Buf)[i*4];\n\t\t\t\t\t}\n\t\t\t\t\tcurOutIndex += (curWidth * curHeight);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase TexFmt_R16:\n\t\t\t\t{\n\t\t\t\t\tif ((curOutIndex > pTex->_pictureDataSize/2) || (pTex->_pictureDataSize/2 - curOutIndex) < (curWidth * curHeight))\n\t\t\t\t\t\treturn false;\n\t\t\t\t\tuint32_t pixelCount = curWidth * curHeight;\n\t\t\t\t\tfor (uint32_t i = 0; i < pixelCount; i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tuint8_t r = ((uint8_t*)pRGBA32Buf)[i * 4];\n\t\t\t\t\t\t((uint16_t*)outPictureData)[curOutIndex + i] = ((uint16_t)r << 8) | r;\n\t\t\t\t\t}\n\t\t\t\t\tcurOutIndex += (curWidth * curHeight);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase TexFmt_RG32:\n\t\t\t\t{\n\t\t\t\t\tif ((curOutIndex > pTex->_pictureDataSize / 4) || (pTex->_pictureDataSize / 4 - curOutIndex) < (curWidth * curHeight))\n\t\t\t\t\t\treturn false;\n\t\t\t\t\tuint32_t pixelCount = curWidth * curHeight;\n\t\t\t\t\tfor (uint32_t i = 0; i < pixelCount; i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tuint8_t r = ((uint8_t*)pRGBA32Buf)[i * 4];\n\t\t\t\t\t\tuint8_t g = ((uint8_t*)pRGBA32Buf)[i * 4 + 1];\n\t\t\t\t\t\t((uint16_t*)outPictureData)[(curOutIndex + i) * 2] = ((uint16_t)r << 8) | r;\n\t\t\t\t\t\t((uint16_t*)outPictureData)[(curOutIndex + i) * 2 + 1] = ((uint16_t)g << 8) | g;\n\t\t\t\t\t}\n\t\t\t\t\tcurOutIndex += (curWidth * curHeight);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase TexFmt_RGB48:\n\t\t\t\t{\n\t\t\t\t\tif ((curOutIndex > pTex->_pictureDataSize / 6) || (pTex->_pictureDataSize / 6 - curOutIndex) < (curWidth * curHeight))\n\t\t\t\t\t\treturn false;\n\t\t\t\t\tuint32_t pixelCount = curWidth * curHeight;\n\t\t\t\t\tfor (uint32_t i = 0; i < pixelCount; i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tuint8_t r = ((uint8_t*)pRGBA32Buf)[i * 4];\n\t\t\t\t\t\tuint8_t g = ((uint8_t*)pRGBA32Buf)[i * 4 + 1];\n\t\t\t\t\t\tuint8_t b = ((uint8_t*)pRGBA32Buf)[i * 4 + 2];\n\t\t\t\t\t\t((uint16_t*)outPictureData)[(curOutIndex + i) * 3] = ((uint16_t)r << 8) | r;\n\t\t\t\t\t\t((uint16_t*)outPictureData)[(curOutIndex + i) * 3 + 1] = ((uint16_t)g << 8) | g;\n\t\t\t\t\t\t((uint16_t*)outPictureData)[(curOutIndex + i) * 3 + 2] = ((uint16_t)b << 8) | b;\n\t\t\t\t\t}\n\t\t\t\t\tcurOutIndex += (curWidth * curHeight);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase TexFmt_RGBA64:\n\t\t\t\t{\n\t\t\t\t\tif ((curOutIndex > pTex->_pictureDataSize / 8) || (pTex->_pictureDataSize / 8 - curOutIndex) < (curWidth * curHeight))\n\t\t\t\t\t\treturn false;\n\t\t\t\t\tuint32_t pixelCount = curWidth * curHeight;\n\t\t\t\t\tfor (uint32_t i = 0; i < pixelCount; i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tuint8_t r = ((uint8_t*)pRGBA32Buf)[i * 4];\n\t\t\t\t\t\tuint8_t g = ((uint8_t*)pRGBA32Buf)[i * 4 + 1];\n\t\t\t\t\t\tuint8_t b = ((uint8_t*)pRGBA32Buf)[i * 4 + 2];\n\t\t\t\t\t\tuint8_t a = ((uint8_t*)pRGBA32Buf)[i * 4 + 3];\n\t\t\t\t\t\t((uint16_t*)outPictureData)[(curOutIndex + i) * 4] = ((uint16_t)r << 8) | r;\n\t\t\t\t\t\t((uint16_t*)outPictureData)[(curOutIndex + i) * 4 + 1] = ((uint16_t)g << 8) | g;\n\t\t\t\t\t\t((uint16_t*)outPictureData)[(curOutIndex + i) * 4 + 2] = ((uint16_t)b << 8) | b;\n\t\t\t\t\t\t((uint16_t*)outPictureData)[(curOutIndex + i) * 4 + 3] = ((uint16_t)a << 8) | a;\n\t\t\t\t\t}\n\t\t\t\t\tcurOutIndex += (curWidth * curHeight);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase TexFmt_DXT1:\n\t\t\tcase TexFmt_DXT1Crunched:\n\t\t\tcase TexFmt_DXT5:\n\t\t\tcase TexFmt_DXT5Crunched:\n\t\t\tcase TexFmt_BC4:\n\t\t\tcase TexFmt_BC5:\n\t\t\tcase TexFmt_BC6H:\n\t\t\tcase TexFmt_BC7:\n\t\t\tcase TexFmt_YUV2: //not actually compressed but it\'s also handled\n\t\t\tcase TexFmt_EAC_R:\n\t\t\tcase TexFmt_EAC_R_SIGNED:\n\t\t\tcase TexFmt_EAC_RG:\n\t\t\tcase TexFmt_EAC_RG_SIGNED:\n\t\t\tcase TexFmt_ETC_RGB4:\n\t\t\tcase TexFmt_ETC_RGB4Crunched:\n\t\t\tcase TexFmt_ETC_RGB4_3DS:\n\t\t\tcase TexFmt_ETC_RGBA8_3DS:\n\t\t\tcase TexFmt_ETC2_RGB4:\n\t\t\tcase TexFmt_ETC2_RGBA1:\n\t\t\tcase TexFmt_ETC2_RGBA8:\n\t\t\tcase TexFmt_ETC2_RGBA8Crunched:\n\t\t\tcase TexFmt_PVRTC_RGB2:\n\t\t\tcase TexFmt_PVRTC_RGBA2:\n\t\t\tcase TexFmt_PVRTC_RGB4:\n\t\t\tcase TexFmt_PVRTC_RGBA4:\n\t\t\tcase TexFmt_ASTC_RGB_4x4:\n\t\t\tcase TexFmt_ASTC_RGB_5x5:\n\t\t\tcase TexFmt_ASTC_RGB_6x6:\n\t\t\tcase TexFmt_ASTC_RGB_8x8:\n\t\t\tcase TexFmt_ASTC_RGB_10x10:\n\t\t\tcase TexFmt_ASTC_RGB_12x12:\n\t\t\tcase TexFmt_ASTC_RGBA_4x4:\n\t\t\tcase TexFmt_ASTC_RGBA_5x5:\n\t\t\tcase TexFmt_ASTC_RGBA_6x6:\n\t\t\tcase TexFmt_ASTC_RGBA_8x8:\n\t\t\tcase TexFmt_ASTC_RGBA_10x10:\n\t\t\tcase TexFmt_ASTC_RGBA_12x12:\n\t\t\tcase TexFmt_ASTC_HDR_4x4:\n\t\t\tcase TexFmt_ASTC_HDR_5x5:\n\t\t\tcase TexFmt_ASTC_HDR_6x6:\n\t\t\tcase TexFmt_ASTC_HDR_8x8:\n\t\t\tcase TexFmt_ASTC_HDR_10x10:\n\t\t\tcase TexFmt_ASTC_HDR_12x12:\n\t\t\t\t{\n\t\t\t\t\tQWORD compressedSize = pTex->_pictureDataSize - curOutIndex;\n\t\t\t\t\tRGBA32_ToCompressed(pTex, &pTex->pPictureData[curOutIndex], pRGBA32Buf, compressedSize, compressQuality, curWidth, curHeight);\n\t\t\t\t\t/*pTex->_pictureDataSize = pTex->m_CompleteImageSize = (uint32_t)*/curOutIndex += compressedSize;\n\t\t\t\t\tif (compressedSize == 0 && (curWidth * curHeight) != 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tprintf("Failed converting texture format RGBA32 to %i!", pTex->m_TextureFormat);\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tprintf("Unsupported texture format %i!", pTex->m_TextureFormat);\n\t\t\t\treturn false;\n\t\t}\n\t\ttotalMipCount++;\n\t\tif ((curMipCount > 1) && MakeNextMipmapLevel_RGBA32(pRGBA32Buf, pRGBA32Buf, curWidth, curHeight))\n\t\t\tcurMipCount--;\n\t\telse\n\t\t\tbreak;\n\t} while (true);\n\tpTex->_pictureDataSize = pTex->m_CompleteImageSize = (uint32_t)curOutIndex;\n\tpTex->m_MipCount = totalMipCount;\n\t//printf("Successfully converted texture format RGBA32 to %i!", pTex->m_TextureFormat);\n\treturn true;\n}\n\nbool GetTextureData(TextureFile *pTex, void *pOutBuf)\n{\n\tswitch (pTex->m_TextureFormat) {\n\t\tcase TexFmt_Alpha8:\n        case TexFmt_RGB24:\n        case TexFmt_RGBA32:\n        case TexFmt_BGRA32Old:\n        case TexFmt_BGRA32New:\n        case TexFmt_ARGB32:\n        case TexFmt_ARGB4444:\n        case TexFmt_RGBA4444:\n        case TexFmt_RGB565:\n\t\tcase TexFmt_R16:\n\t\tcase TexFmt_RHalf:\n\t\tcase TexFmt_RGHalf:\n\t\tcase TexFmt_RGBAHalf:\n\t\tcase TexFmt_RFloat:\n\t\tcase TexFmt_RGFloat:\n\t\tcase TexFmt_RGBAFloat:\n\t\tcase TexFmt_RGB9e5Float:\n\t\tcase TexFmt_RG16:\n\t\tcase TexFmt_R8:\n\t\t\tif (!Uncompressed_ToRGBA32(pTex, pOutBuf))\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TexFmt_DXT1:\n\t\tcase TexFmt_DXT1Crunched:\n        case TexFmt_DXT5:\n        case TexFmt_DXT5Crunched:\n\t\tcase TexFmt_BC4:\n\t\tcase TexFmt_BC5:\n\t\tcase TexFmt_BC6H:\n\t\tcase TexFmt_BC7:\n\t\tcase TexFmt_YUV2: //not actually compressed but it\'s also handled\n\t\tcase TexFmt_EAC_R:\n\t\tcase TexFmt_EAC_R_SIGNED:\n\t\tcase TexFmt_EAC_RG:\n\t\tcase TexFmt_EAC_RG_SIGNED:\n\t\tcase TexFmt_ETC_RGB4:\n\t\tcase TexFmt_ETC_RGB4Crunched:\n\t\tcase TexFmt_ETC_RGB4_3DS:\n\t\tcase TexFmt_ETC_RGBA8_3DS:\n\t\tcase TexFmt_ETC2_RGB4:\n\t\tcase TexFmt_ETC2_RGBA1:\n\t\tcase TexFmt_ETC2_RGBA8:\n\t\tcase TexFmt_ETC2_RGBA8Crunched:\n\t\tcase TexFmt_PVRTC_RGB2:\n\t\tcase TexFmt_PVRTC_RGBA2:\n\t\tcase TexFmt_PVRTC_RGB4:\n\t\tcase TexFmt_PVRTC_RGBA4:\n\t\tcase TexFmt_ASTC_RGB_4x4:\n\t\tcase TexFmt_ASTC_RGB_5x5:\n\t\tcase TexFmt_ASTC_RGB_6x6:\n\t\tcase TexFmt_ASTC_RGB_8x8:\n\t\tcase TexFmt_ASTC_RGB_10x10:\n\t\tcase TexFmt_ASTC_RGB_12x12:\n\t\tcase TexFmt_ASTC_RGBA_4x4:\n\t\tcase TexFmt_ASTC_RGBA_5x5:\n\t\tcase TexFmt_ASTC_RGBA_6x6:\n\t\tcase TexFmt_ASTC_RGBA_8x8:\n\t\tcase TexFmt_ASTC_RGBA_10x10:\n\t\tcase TexFmt_ASTC_RGBA_12x12:\n\t\t\tif (!Compressed_ToRGBA32(pTex, pOutBuf))\n\t\t\t{\n\t\t\t\tprintf("Failed decompressing from texture format %i!", pTex->m_TextureFormat);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tprintf("Unsupported texture format %i!", pTex->m_TextureFormat);\n\t\t\treturn false;\n\t}\n\t//printf("Successfully converted texture format %i to RGBA32!", pTex->m_TextureFormat);\n\treturn true;\n}\n'