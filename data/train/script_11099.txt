b'{-# LANGUAGE DeriveDataTypeable, BangPatterns #-}\nmodule Test.Tasty.HUnit.Steps (testCaseSteps) where\n\nimport Control.Applicative\nimport Control.Exception\nimport Data.IORef\nimport Data.List (foldl\')\nimport Data.Typeable (Typeable)\nimport Prelude  -- Silence AMP import warnings\nimport Test.Tasty.HUnit.Orig\nimport Test.Tasty.Providers\nimport Test.Tasty.Runners (getTime)\nimport Text.Printf (printf)\n\nnewtype TestCaseSteps = TestCaseSteps ((String -> IO ()) -> Assertion)\n  deriving Typeable\n\ninstance IsTest TestCaseSteps where\n  run _ (TestCaseSteps assertionFn) _ = do\n    ref <- newIORef []\n\n    let\n      stepFn :: String -> IO ()\n      stepFn msg = do\n        tme <- getTime\n        atomicModifyIORef ref (\\l -> ((tme,msg):l, ()))\n\n    hunitResult <- (Right <$> assertionFn stepFn) `catches`\n      [ Handler (\\(HUnitFailure mbloc errMsg) -> return $ Left (prependLocation mbloc errMsg))\n      , Handler (\\(SomeException ex)          -> return $ Left (show ex))\n      ]\n\n    endTime <- getTime\n\n    maxMsgLength <- foldl\' max 0 . map (length . snd) <$> readIORef ref\n\n    let msgFormat = "%-" ++ show (min maxMsgLength 62) ++ "s (%.02fs)"\n\n    msgs <- snd . foldl\'\n      (\\(lastTime, acc) (curTime, msg) ->\n           let !duration = lastTime - curTime\n               !msg\' = if duration >= 0.01 then printf msgFormat msg duration else msg\n            in (curTime, msg\':acc))\n      (endTime, [])\n        <$> readIORef ref\n\n    return $\n      case hunitResult of\n\n        Right {} -> testPassed (unlines msgs)\n\n        Left errMsg -> testFailed $\n          if null msgs\n            then\n              errMsg\n            else\n              -- Indent the error msg w.r.t. step messages\n              unlines $\n                msgs ++ map ("  " ++) (lines errMsg)\n\n  testOptions = return []\n\n-- | Create a multi-step unit test.\n--\n-- Example:\n--\n-- >main = defaultMain $ testCaseSteps "Multi-step test" $ \\step -> do\n-- >  step "Preparing..."\n-- >  -- do something\n-- >\n-- >  step "Running part 1"\n-- >  -- do something\n-- >\n-- >  step "Running part 2"\n-- >  -- do something\n-- >  assertFailure "BAM!"\n-- >\n-- >  step "Running part 3"\n-- >  -- do something\n--\n-- The @step@ calls are mere annotations. They let you see which steps were\n-- performed successfully, and which step failed.\n--\n-- You can think of @step@\n-- as \'putStrLn\', except \'putStrLn\' would mess up the output with the\n-- console reporter and get lost with the others.\n--\n-- For the example above, the output will be\n--\n-- >Multi-step test: FAIL\n-- >  Preparing...\n-- >  Running part 1\n-- >  Running part 2\n-- >    BAM!\n-- >\n-- >1 out of 1 tests failed (0.00s)\n--\n-- Note that:\n--\n-- * Tasty still treats this as a single test, even though it consists of\n-- multiple steps.\n--\n-- * The execution stops after the first failure. When we are looking at\n-- a failed test, we know that all /displayed/ steps but the last one were\n-- successful, and the last one failed. The steps /after/ the failed one\n-- are /not displayed/, since they didn\'t run.\ntestCaseSteps :: TestName -> ((String -> IO ()) -> Assertion) -> TestTree\ntestCaseSteps name = singleTest name . TestCaseSteps\n'