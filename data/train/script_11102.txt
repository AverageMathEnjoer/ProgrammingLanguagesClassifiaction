b'package droidninja.filepicker.viewmodels\n\nimport android.app.Application\nimport android.content.ContentUris\nimport android.database.ContentObserver\nimport android.database.Cursor\nimport android.provider.BaseColumns\nimport android.provider.MediaStore\nimport android.webkit.MimeTypeMap\nimport androidx.annotation.WorkerThread\nimport androidx.lifecycle.LiveData\nimport androidx.lifecycle.MutableLiveData\nimport droidninja.filepicker.FilePickerConst\nimport droidninja.filepicker.PickerManager\nimport droidninja.filepicker.R\nimport droidninja.filepicker.models.Media\nimport droidninja.filepicker.models.PhotoDirectory\nimport droidninja.filepicker.utils.registerObserver\nimport kotlinx.coroutines.Dispatchers\nimport kotlinx.coroutines.withContext\nimport java.util.*\n\nclass VMMediaPicker(application: Application) : BaseViewModel(application) {\n\n    private val _lvMediaData = MutableLiveData<List<Media>>()\n    val lvMediaData: LiveData<List<Media>>\n        get() = _lvMediaData\n\n    private val _lvPhotoDirsData = MutableLiveData<List<PhotoDirectory>>()\n    val lvPhotoDirsData: LiveData<List<PhotoDirectory>>\n        get() = _lvPhotoDirsData\n\n    private val _lvDataChanged = MutableLiveData<Boolean>()\n    val lvDataChanged: LiveData<Boolean>\n        get() = _lvDataChanged\n\n    private var contentObserver: ContentObserver? = null\n\n    private fun registerContentObserver() {\n        if (contentObserver == null) {\n            contentObserver = getApplication<Application>().contentResolver.registerObserver(\n                    MediaStore.Images.Media.EXTERNAL_CONTENT_URI\n            ) {\n                _lvDataChanged.value = true\n            }\n        }\n    }\n\n    fun getMedia(bucketId: String? = null, mediaType: Int = FilePickerConst.MEDIA_TYPE_IMAGE, imageFileSize: Int = FilePickerConst.DEFAULT_FILE_SIZE, videoFileSize: Int = FilePickerConst.DEFAULT_FILE_SIZE) {\n        launchDataLoad {\n            val medias = mutableListOf<Media>()\n            queryImages(bucketId, mediaType, imageFileSize, videoFileSize).map { dir ->\n                medias.addAll(dir.medias)\n            }\n            medias.sortWith(Comparator { a, b -> (b.id - a.id).toInt() })\n\n            _lvMediaData.postValue(medias)\n            registerContentObserver()\n        }\n    }\n\n    fun getPhotoDirs(bucketId: String? = null, mediaType: Int = FilePickerConst.MEDIA_TYPE_IMAGE, imageFileSize: Int = FilePickerConst.DEFAULT_FILE_SIZE, videoFileSize: Int = FilePickerConst.DEFAULT_FILE_SIZE) {\n        launchDataLoad {\n            val dirs = queryImages(bucketId, mediaType, imageFileSize, videoFileSize)\n            val photoDirectory = PhotoDirectory()\n            photoDirectory.bucketId = null\n\n            when (mediaType) {\n                FilePickerConst.MEDIA_TYPE_VIDEO -> {\n                    photoDirectory.name = getApplication<Application>().applicationContext.getString(R.string.all_videos)\n                }\n                FilePickerConst.MEDIA_TYPE_IMAGE -> {\n                    photoDirectory.name = getApplication<Application>().applicationContext.getString(R.string.all_photos)\n                }\n                else -> {\n                    photoDirectory.name = getApplication<Application>().applicationContext.getString(R.string.all_files)\n                }\n            }\n\n            if (dirs.isNotEmpty() && dirs[0].medias.size > 0) {\n                photoDirectory.dateAdded = dirs[0].dateAdded\n                photoDirectory.setCoverPath(dirs[0].medias[0].path)\n            }\n\n            for (i in dirs.indices) {\n                photoDirectory.medias.addAll(dirs[i].medias)\n            }\n\n            dirs.add(0, photoDirectory)\n            _lvPhotoDirsData.postValue(dirs)\n            registerContentObserver()\n        }\n    }\n\n    @WorkerThread\n    suspend fun queryImages(bucketId: String?, mediaType: Int, imageFileSize: Int, videoFileSize: Int): MutableList<PhotoDirectory> {\n        var data = mutableListOf<PhotoDirectory>()\n        withContext(Dispatchers.IO) {\n            val projection = null\n            val uri = MediaStore.Files.getContentUri("external")\n            val sortOrder = MediaStore.Images.Media._ID + " DESC"\n            val selectionArgs = mutableListOf<String>()\n\n            var selection = (MediaStore.Files.FileColumns.MEDIA_TYPE + "="\n                    + MediaStore.Files.FileColumns.MEDIA_TYPE_IMAGE)\n\n            if (mediaType == FilePickerConst.MEDIA_TYPE_VIDEO) {\n                selection = (MediaStore.Files.FileColumns.MEDIA_TYPE + "="\n                        + MediaStore.Files.FileColumns.MEDIA_TYPE_VIDEO)\n\n                if (videoFileSize != FilePickerConst.DEFAULT_FILE_SIZE) {\n                    selection += " AND ${MediaStore.Video.Media.SIZE}<=?"\n                    selectionArgs.add("${videoFileSize * 1024 * 1024}")\n                }\n            }\n\n            if (mediaType == FilePickerConst.MEDIA_TYPE_IMAGE && imageFileSize != FilePickerConst.DEFAULT_FILE_SIZE) {\n                selection += " AND ${MediaStore.Images.Media.SIZE}<=?"\n                selectionArgs.add("${imageFileSize * 1024 * 1024}")\n            }\n\n            if (!PickerManager.isShowGif) {\n                selection += " AND " + MediaStore.Images.Media.MIME_TYPE + "!=\'" + MimeTypeMap.getSingleton().getMimeTypeFromExtension("gif") + "\'"\n            }\n\n            if (bucketId != null)\n                selection += " AND " + MediaStore.Images.Media.BUCKET_ID + "=\'" + bucketId + "\'"\n\n            val cursor = getApplication<Application>().contentResolver.query(uri, projection, selection, selectionArgs.toTypedArray(), sortOrder)\n\n            if (cursor != null) {\n                data = getPhotoDirectories(mediaType, cursor)\n                cursor.close()\n            }\n        }\n        return data\n    }\n\n    @WorkerThread\n    private fun getPhotoDirectories(fileType: Int, data: Cursor): MutableList<PhotoDirectory> {\n        val directories = mutableListOf<PhotoDirectory>()\n\n        while (data.moveToNext()) {\n\n            val imageId = data.getLong(data.getColumnIndexOrThrow(BaseColumns._ID))\n            val bucketId = data.getString(data.getColumnIndexOrThrow(MediaStore.Images.ImageColumns.BUCKET_ID))\n            val name = data.getString(data.getColumnIndexOrThrow(MediaStore.Images.ImageColumns.BUCKET_DISPLAY_NAME))\n            val fileName = data.getString(data.getColumnIndexOrThrow(MediaStore.MediaColumns.TITLE))\n            val mediaType = data.getInt(data.getColumnIndexOrThrow(MediaStore.Files.FileColumns.MEDIA_TYPE))\n\n            val photoDirectory = PhotoDirectory()\n            photoDirectory.id = imageId\n            photoDirectory.bucketId = bucketId\n            photoDirectory.name = name\n\n            var contentUri = ContentUris.withAppendedId(\n                    MediaStore.Images.Media.EXTERNAL_CONTENT_URI,\n                    imageId\n            )\n            if (fileType == FilePickerConst.MEDIA_TYPE_VIDEO) {\n                contentUri = ContentUris.withAppendedId(\n                        MediaStore.Video.Media.EXTERNAL_CONTENT_URI,\n                        imageId\n                )\n            }\n            if (!directories.contains(photoDirectory)) {\n                photoDirectory.addPhoto(imageId, fileName, contentUri, mediaType)\n                photoDirectory.dateAdded = data.getLong(data.getColumnIndexOrThrow(MediaStore.MediaColumns.DATE_ADDED))\n                directories.add(photoDirectory)\n            } else {\n                directories[directories.indexOf(photoDirectory)]\n                        .addPhoto(imageId, fileName, contentUri, mediaType)\n            }\n        }\n\n        return directories\n    }\n\n    override fun onCleared() {\n        contentObserver?.let {\n            getApplication<Application>().contentResolver.unregisterContentObserver(it)\n        }\n    }\n}'