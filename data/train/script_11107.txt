b'-- Generate appendTree<0..4> and addDigits<1..4> for Data.Sequence\nmodule Main where\n\nmain :: IO ()\nmain = putStr (compose [showAppend n | n <- [0..4]] "")\n\nshowAppend :: Int -> ShowS\nshowAppend n =\n    showChar \'\\n\' .\n    showString "appendTree" . shows n . showString " :: " .\n        showFunType\n            ([fingertree] ++ replicate n tyarg ++ [fingertree]) fingertree .\n            showString "\\n" .\n    appendTreeClause "EmptyT" "xs" (showCons (args n) (showString "xs")) .\n    appendTreeClause "xs" "EmptyT" (showSnoc (showString "xs") (args n)) .\n    appendTreeClause "(Single x)" "xs"\n        (showCons (\'x\':args n) (showString "xs")) .\n    appendTreeClause "xs" "(Single x)"\n        (showSnoc (showString "xs") (args n++"x")) .\n    appendTreeClause "(Deep s1 pr1 m1 sf1)" "(Deep s2 pr2 m2 sf2)"\n        (showString "Deep (s1" .\n         compose [showString " + size " . showChar v | v <- args n] .\n         showString " + s2) pr1 (addDigits" . shows n .\n         showString " m1 sf1" . showArgList (args n) .\n         showString " pr2 m2) sf2") .\n    showChar \'\\n\' .\n    showString "addDigits" . shows n . showString " :: " .\n        showFunType\n            ([fingertree_node, digit] ++ replicate n tyarg ++ [digit, fingertree_node])\n            fingertree_node .\n        showString "\\n" .\n    compose [addDigitsClause n1 n2 | n1 <- [1..4], n2 <- [1..4]]\n  where\n    fingertree = tyapp "FingerTree" tyarg\n    digit = tyapp "Digit" tyarg\n    fingertree_node = tyapp "FingerTree" (tyapp "Node" tyarg)\n    showFunType ts tr =\n        compose [showString t . showString " -> " | t <- ts] . showString tr\n    tyapp tc t = tc ++ " (" ++ t ++ ")"\n    tyarg\n      | n == 0 = "Elem a"\n      | otherwise = "Node a"\n    appendTreeClause t1 t2 rhs =\n        showString "appendTree" . shows n .\n            showChar \' \' . showString t1 . showArgList (args n) .\n            showChar \' \' . showString t2 .\n            showString " =\\n    " . rhs . showChar \'\\n\'\n    addDigitsClause n1 n2 =\n        showString "addDigits" . shows n .\n            showString " m1 (" . showDigit vs1 . showChar \')\' .\n            showArgList vsm .\n            showString " (" . showDigit vs2 . showString ") m2" .\n            showString " =\\n    " .\n            showString "appendTree" . shows (length ns) .\n            showString " m1" .\n            compose [showString " (" .  showNode node . showChar \')\' |\n                node <- ns] .\n            showString " m2" . showChar \'\\n\'\n      where\n        vs = args (n1+n+n2)\n        vs1 = take n1 vs\n        vsm = take n (drop n1 vs)\n        vs2 = drop (n1+n) vs\n        ns = nodes vs\n\ndata Node a = Node2 a a | Node3 a a a\n\nnodes :: [a] -> [Node a]\nnodes [a, b] = [Node2 a b]\nnodes [a, b, c] = [Node3 a b c]\nnodes [a, b, c, d] = [Node2 a b, Node2 c d]\nnodes (a:b:c:xs) = Node3 a b c : nodes xs\n\nshowNode (Node2 a b) =\n    showString "node2 " . showChar a . showChar \' \' . showChar b\nshowNode (Node3 a b c) =\n    showString "node3 " . showChar a . showChar \' \' . showChar b .\n        showChar \' \' . showChar c\n\nshowDigit vs =\n    showString (["One", "Two", "Three", "Four"]!!(length vs-1)) .\n    showArgList vs\n\nshowArgList :: [Char] -> ShowS\nshowArgList vs = compose [showChar \' \' . showChar c | c <- vs]\n\nargs :: Int -> [Char]\nargs n = take n [\'a\'..]\n\nshowCons xs sf =\n    compose [showChar x . showString " `consTree` " | x <- xs] . sf\nshowSnoc sf xs =\n    sf . compose [showString " `snocTree` " . showChar x | x <- xs]\n\ncompose :: [a -> a] -> a -> a\ncompose = flip (foldr id)\n'