b'\nimport Control.Monad.Par.Combinator \n-- import Control.Concurrent.Chan  ()\nimport GHC.Conc (numCapabilities)\nimport Control.Exception (evaluate)\n-- import System.IO.Unsafe\n-- import Data.IORef\nimport Test.HUnit        (Assertion, (@=?))\nimport Test.Framework.TH (testGroupGenerator)\n-- import Test.Framework (defaultMain, testGroup)\nimport qualified Test.Framework as TF\nimport           Test.Framework.Providers.HUnit \n-- import Test.Framework.Providers.QuickCheck2 (testProperty)\nimport System.Timeout (timeout)\n\nimport TestHelpers (assertException, prnt, _prnt, _unsafeio, waste_time, collectOutput)\n\n-- -----------------------------------------------------------------------------\n\n-- Testing\n\nthree :: Int\nthree = 3\n\npar :: (Eq a, Show a) => a -> Par a -> Assertion\npar res m = res @=? runPar m\n\n-- From https://github.com/simonmar/monad-par/pull/49\ncase_parallelFilter :: Assertion\ncase_parallelFilter = run 200 where\n  run 0 = pure ()\n  run i = do\n    par result (parfilter p xs)\n    run (i-1)\n\n  p x = x `mod` 2 == 0\n  xs = [0..10] :: [Int]\n  result = filter p xs\n\n  parfilter _ []  = pure []\n  parfilter f [x] = pure (if f x then [x] else [])\n  parfilter f xs  = do\n    let (as, bs) = halve xs\n    v1 <- spawn $ parfilter f as\n    v2 <- spawn $ parfilter f bs\n    left  <- get v1\n    right <- get v2\n    pure (left ++ right)\n\n  halve xs = splitAt (length xs `div` 2) xs\n\n-- | Make sure there\'s no problem with bringing the worker threads up and down many\n-- times.  10K runPar\'s takes about 6.3 seconds.\ncase_lotsaRunPar :: Assertion\ncase_lotsaRunPar = loop 2000\n  where \n  loop 0 = putStrLn ""\n  loop i = do\n    -- We need to do runParIO to make sure the compiler does the runPar each time.\n    runParIO (return ())\n    putStr "."\n    loop (i-1)\n    \ncase_justReturn :: Assertion\ncase_justReturn = par three (return 3)\n\ncase_oneIVar :: Assertion\ncase_oneIVar    = par three (do r <- new; put r 3; get r)\n\n\n-- [2012.01.02] Apparently observing divergences here too:\ncase_forkNFill :: Assertion\ncase_forkNFill  = par three (do r <- new; fork (put r 3); get r)\n\n-- [2012.05.02] The nested Trace implementation sometimes fails to\n-- throw this exception, so we expect either the exception or a\n-- timeout. This is reasonable since we might expect a deadlock in a\n-- non-Trace scheduler. --ACF\n-- \n-- [2013.05.17] Update, it\'s also possible to get a blocked-indefinitely error here\n--   --RRN\n--\n-- [2013.09.08] Yep, I\'m nondeterministically seeing this fail using\n-- Direct.  But this is actually a failure of the exception handling\n-- setup.  `assertException` should be catching blocked-indefinitely\n-- error and it\'s NOT always.  Running this test ALONE, I cannot trip\n-- it, but running it with others I do.  In fact, running it with\n-- through test-framework\'s "-j1" I cannot reproduce the error. It is\n-- probably just the perturbation to timing caused by this, after all,\n-- WAIT_WORKERS is not currently on for Direct.  Still, I thought that\n-- wouldn\'t matter here because the *main* thread can\'t return.\n--\n-- Also, it seems like this test can just hang indefinitely, with the\n-- timeout failing to do the trick....  \n-- \ncase_getEmpty :: IO ()\ncase_getEmpty   = do\n  -- Microseconds:\n  _ <- timeout (100 * 1000) $ assertException ["no result", "timeout", "thread blocked indefinitely"] $ \n         runPar $ do r <- new; get r\n  return ()\n\n\n-- [2012.01.02] Observed a blocked-indef-on-MVar failure here on\n-- master branch with 16 threads:\n-- \n-- | Simple diamond test.\ncase_test_diamond :: Assertion\ncase_test_diamond = 9 @=? (m :: Int)\n where \n  m = runPar $ do\n      abcd <- sequence [new,new,new,new]\n      case abcd of\n          [a,b,c,d] -> do\n              fork $ do x <- get a; put b (x+1)\n              fork $ do x <- get a; put c (x+2)\n              fork $ do x <- get b; y <- get c; put d (x+y)\n              fork $ do put a 3\n              get d\n          _ -> error "Oops"\n\n-- | Violate IVar single-assignment:\n--\n-- NOTE: presently observing termination problems here.\n-- runPar is failing to exist after the exception?\ndisabled_case_multiput :: IO ()\ndisabled_case_multiput = assertException ["multiple put"] $ \n  runPar $ do\n   a <- new\n   put a (3::Int)\n   put a (4::Int)\n   return ()\n\n\n-- disabled_test3 = assertException "multiple put" $ \n--   runPar $ do\n--    a <- new\n--    put a (3::Int)\n--    both (return 1) (return 2)\n--  where \n--   -- both a b >> c  ==   both (a >> c) (b >> c)\n--   -- Duplicate the continuation: is this useful for anything?\n--   both :: Par a -> Par a -> Par a\n--   both a b = Par $ \\c -> Fork (runCont a c) (runCont b c)\n\n\n-- | A reduction test.\ncase_test_pmrr1 :: Assertion\n-- Saw a failure here using Direct:\n--   http://tester-lin.soic.indiana.edu:8080/job/HackageReleased_monad-par/GHC_VERS=7.0.4,label=tank.cs.indiana.edu/40/console\n-- Exception inside child thread "(worker 0 of originator ThreadId 5)", ThreadId 10: thread blocked indefinitely in an MVar operation\ncase_test_pmrr1 = \n   par 5050 $ parMapReduceRangeThresh 1 (InclusiveRange 1 100)\n\t        (return) (return `bincomp` (+)) 0\n where bincomp unary bin a b = unary (bin a b)\n\n\n------------------------------------------------------------\n\n\n-- | Observe the real time ordering of events:\n--\n--   Child-stealing:       \n--      A D B <pause> C E\n--       \n--   Parent-stealing:\n--      A B D <pause> C E       \n--\n--   Sequential:\n--      A B <pause> C D E\n--       \n--   This is only for the TRACE scheduler right now.\n--\n-- This test is DISABLED because it fails unless you run with +RTS -N2\n-- or greater.\n--\ndisabled_case_async_test1 :: IO ()\ndisabled_case_async_test1 =\n  do x <- res\n     case (numCapabilities, words x) of\n       (1,["A","B","C",_,"D","E"])         -> return ()       \n       (n,["A","D","B","C",_,"E"]) | n > 1 -> return ()\n       (n,["A","B","D","C",_,"E"]) | n > 1 -> return ()       \n       _  -> error$ "Bad temporal pattern: "++ show (words x)\n where \n res = collectOutput $ \\ r -> do\n  prnt r "A"\n  evaluate$ runPar $\n    do iv <- new\n       fork $ do _prnt r "B"\n                 x <- _unsafeio$ waste_time 0.5\n\t\t _prnt r$ "C "++ show x\n--\t\t _prnt r$ "C "++ show (_waste_time awhile)\n                 put iv ()\n       _prnt r "D"\n       get iv\n  prnt r$ "E"\n  \n\n\n\n------------------------------------------------------------\n\ntests :: [TF.Test]\ntests = [ $(testGroupGenerator) ]\n\n'