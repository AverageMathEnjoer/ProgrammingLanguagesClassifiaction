b'using System;\nusing System.Diagnostics;\nusing System.Text;\n\nusing FILE = System.IO.TextWriter;\nusing i32 = System.Int32;\nusing i64 = System.Int64;\nusing u8 = System.Byte;\nusing u16 = System.UInt16;\nusing u32 = System.UInt32;\nusing u64 = System.UInt64;\n\nusing Pgno = System.UInt32;\n\nnamespace CS_SQLite3\n{\n  using Op = CSSQLite.VdbeOp;\n  using sqlite3_stmt = CSSQLite.Vdbe;\n  using sqlite3_value = CSSQLite.Mem;\n\n  public partial class CSSQLite\n  {\n    /*\n    ** 2003 September 6\n    **\n    ** The author disclaims copyright to this source code.  In place of\n    ** a legal notice, here is a blessing:\n    **\n    **    May you do good and not evil.\n    **    May you find forgiveness for yourself and forgive others.\n    **    May you share freely, never taking more than you give.\n    **\n    *************************************************************************\n    ** This file contains code used for creating, destroying, and populating\n    ** a VDBE (or an "sqlite3_stmt" as it is known to the outside world.)  Prior\n    ** to version 2.8.7, all this code was combined into the vdbe.c source file.\n    ** But that file was getting too big so this subroutines were split out.\n    **\n    ** $Id: vdbeaux.c,v 1.480 2009/08/08 18:01:08 drh Exp $\n    **\n    *************************************************************************\n    **  Included in SQLite3 port to C#-SQLite;  2008 Noah B Hart\n    **  C#-SQLite is an independent reimplementation of the SQLite software library\n    **\n    **  $Header$\n    *************************************************************************\n    */\n    //#include "sqliteInt.h"\n    //#include "vdbeInt.h"\n\n\n\n    /*\n    ** When debugging the code generator in a symbolic debugger, one can\n    ** set the sqlite3VdbeAddopTrace to 1 and all opcodes will be printed\n    ** as they are added to the instruction stream.\n    */\n#if  SQLITE_DEBUG\n    static bool sqlite3VdbeAddopTrace = false;\n#endif\n\n\n    /*\n** Create a new virtual database engine.\n*/\n    static Vdbe sqlite3VdbeCreate( sqlite3 db )\n    {\n      Vdbe p;\n      p = new Vdbe();// sqlite3DbMallocZero(db, Vdbe).Length;\n      if ( p == null ) return null;\n      p.db = db;\n      if ( db.pVdbe != null )\n      {\n        db.pVdbe.pPrev = p;\n      }\n      p.pNext = db.pVdbe;\n      p.pPrev = null;\n      db.pVdbe = p;\n      p.magic = VDBE_MAGIC_INIT;\n      return p;\n    }\n\n    /*\n    ** Remember the SQL string for a prepared statement.\n    */\n    static void sqlite3VdbeSetSql( Vdbe p, string z, int n, int isPrepareV2 )\n    {\n      if ( p == null ) return;\n#if SQLITE_OMIT_TRACE\nif( !isPrepareV2 ) return;\n#endif\n      Debug.Assert( p.zSql == "" );\n      p.zSql = z.Substring( 0, n );// sqlite3DbStrNDup(p.db, z, n);\n      p.isPrepareV2 = isPrepareV2 != 0;\n    }\n\n    /*\n    ** Return the SQL associated with a prepared statement\n    */\n    static string sqlite3_sql( sqlite3_stmt pStmt )\n    {\n      Vdbe p = (Vdbe)pStmt;\n      return ( p.isPrepareV2 ? p.zSql : "" );\n    }\n\n    /*\n    ** Swap all content between two VDBE structures.\n    */\n    static void sqlite3VdbeSwap( Vdbe pA, Vdbe pB )\n    {\n      Vdbe tmp = new Vdbe(); Vdbe pTmp = new Vdbe();\n      string zTmp;\n      pA.CopyTo( tmp );\n      pB.CopyTo( pA );\n      tmp.CopyTo( pB );\n      pTmp = pA.pNext;\n      pA.pNext = pB.pNext;\n      pB.pNext = pTmp;\n      pTmp = pA.pPrev;\n      pA.pPrev = pB.pPrev;\n      pB.pPrev = pTmp;\n      zTmp = pA.zSql;\n      pA.zSql = pB.zSql;\n      pB.zSql = zTmp;\n    }\n\n#if  SQLITE_DEBUG\n    /*\n** Turn tracing on or off\n*/\n    static void sqlite3VdbeTrace( Vdbe p, FILE trace )\n    {\n      p.trace = trace;\n    }\n#endif\n\n    /*\n** Resize the Vdbe.aOp array so that it is at least one op larger than\n** it was.\n**\n** If an out-of-memory error occurs while resizing the array, return\n** SQLITE_NOMEM. In this case Vdbe.aOp and Vdbe.nOpAlloc remain\n** unchanged (this is so that any opcodes already allocated can be\n** correctly deallocated along with the rest of the Vdbe).\n*/\n    static int growOpArray( Vdbe p )\n    {\n      //VdbeOp pNew;\n      int nNew = ( p.nOpAlloc != 0 ? p.nOpAlloc * 2 : 1024 / 4 );//(int)(1024/sizeof(Op)));\n      // pNew = sqlite3DbRealloc( p.db, p.aOp, nNew * sizeof( Op ) );\n      //if (pNew != null)\n      //{\n      //      p.nOpAlloc = sqlite3DbMallocSize(p.db, pNew)/sizeof(Op);\n      //  p.aOp = pNew;\n      //}\n      p.nOpAlloc = nNew;\n      if ( p.aOp == null ) p.aOp = new VdbeOp[nNew]; else Array.Resize( ref p.aOp, nNew );\n      return ( p.aOp != null ? SQLITE_OK : SQLITE_NOMEM ); //  return (pNew ? SQLITE_OK : SQLITE_NOMEM);\n    }\n\n    /*\n    ** Add a new instruction to the list of instructions current in the\n    ** VDBE.  Return the address of the new instruction.\n    **\n    ** Parameters:\n    **\n    **    p               Pointer to the VDBE\n    **\n    **    op              The opcode for this instruction\n    **\n    **    p1, p2, p3      Operands\n    **\n    ** Use the sqlite3VdbeResolveLabel() function to fix an address and\n    ** the sqlite3VdbeChangeP4() function to change the value of the P4\n    ** operand.\n    */\n    static int sqlite3VdbeAddOp3( Vdbe p, int op, int p1, int p2, int p3 )\n    {\n      int i;\n      VdbeOp pOp;\n\n      i = p.nOp;\n      Debug.Assert( p.magic == VDBE_MAGIC_INIT );\n      Debug.Assert( op > 0 && op < 0xff );\n      if ( p.nOpAlloc <= i )\n      {\n        if ( growOpArray( p ) != 0 )\n        {\n          return 1;\n        }\n      }\n      p.nOp++;\n      if ( p.aOp[i] == null ) p.aOp[i] = new VdbeOp();\n      pOp = p.aOp[i];\n      pOp.opcode = (u8)op;\n      pOp.p5 = 0;\n      pOp.p1 = p1;\n      pOp.p2 = p2;\n      pOp.p3 = p3;\n      pOp.p4.p = null;\n      pOp.p4type = P4_NOTUSED;\n      p.expired = false;\n      //sqlite3VdbePrintOp(null, i, p.aOp[i]);\n#if  SQLITE_DEBUG\n      pOp.zComment = null;\n      if ( sqlite3VdbeAddopTrace ) sqlite3VdbePrintOp( null, i, p.aOp[i] );\n#endif\n#if VDBE_PROFILE\npOp.cycles = 0;\npOp.cnt = 0;\n#endif\n      return i;\n    }\n    static int sqlite3VdbeAddOp0( Vdbe p, int op )\n    {\n      return sqlite3VdbeAddOp3( p, op, 0, 0, 0 );\n    }\n    static int sqlite3VdbeAddOp1( Vdbe p, int op, int p1 )\n    {\n      return sqlite3VdbeAddOp3( p, op, p1, 0, 0 );\n    }\n    static int sqlite3VdbeAddOp2( Vdbe p, int op, int p1, bool b2 )\n    {\n      return sqlite3VdbeAddOp2( p, op, p1, (int)( b2 ? 1 : 0 ) );\n    }\n\n    static int sqlite3VdbeAddOp2( Vdbe p, int op, int p1, int p2 )\n    {\n      return sqlite3VdbeAddOp3( p, op, p1, p2, 0 );\n    }\n\n\n    /*\n    ** Add an opcode that includes the p4 value as a pointer.\n    */\n    //P4_INT32\n    static int sqlite3VdbeAddOp4( Vdbe p, int op, int p1, int p2, int p3, i32 pP4, int p4type )\n    {\n      union_p4 _p4 = new union_p4(); _p4.i = pP4;\n      int addr = sqlite3VdbeAddOp3( p, op, p1, p2, p3 );\n      sqlite3VdbeChangeP4( p, addr, _p4, p4type );\n      return addr;\n    }\n\n    //char\n    static int sqlite3VdbeAddOp4( Vdbe p, int op, int p1, int p2, int p3, char pP4, int p4type )\n    {\n      union_p4 _p4 = new union_p4(); _p4.z = pP4.ToString();\n      int addr = sqlite3VdbeAddOp3( p, op, p1, p2, p3 );\n      sqlite3VdbeChangeP4( p, addr, _p4, p4type );\n      return addr;\n    }\n\n    //String\n    static int sqlite3VdbeAddOp4( Vdbe p, int op, int p1, int p2, int p3, string pP4, int p4type )\n    {\n      //      Debug.Assert( pP4 != null );\n      union_p4 _p4 = new union_p4(); _p4.z = pP4;\n      int addr = sqlite3VdbeAddOp3( p, op, p1, p2, p3 );\n      sqlite3VdbeChangeP4( p, addr, _p4, p4type );\n      return addr;\n    }\n\n    static int sqlite3VdbeAddOp4( Vdbe p, int op, int p1, int p2, int p3, byte[] pP4, int p4type )\n    {\n      Debug.Assert( op == OP_Null || pP4 != null );\n      union_p4 _p4 = new union_p4(); _p4.z = Encoding.UTF8.GetString( pP4 );\n      int addr = sqlite3VdbeAddOp3( p, op, p1, p2, p3 );\n      sqlite3VdbeChangeP4( p, addr, _p4, p4type );\n      return addr;\n    }\n\n    //P4_INTARRAY\n    static int sqlite3VdbeAddOp4( Vdbe p, int op, int p1, int p2, int p3, int[] pP4, int p4type )\n    {\n      Debug.Assert( pP4 != null );\n      union_p4 _p4 = new union_p4(); _p4.ai = pP4;\n      int addr = sqlite3VdbeAddOp3( p, op, p1, p2, p3 );\n      sqlite3VdbeChangeP4( p, addr, _p4, p4type );\n      return addr;\n    }\n    //P4_INT64\n    static int sqlite3VdbeAddOp4( Vdbe p, int op, int p1, int p2, int p3, i64 pP4, int p4type )\n    {\n      union_p4 _p4 = new union_p4(); _p4.pI64 = pP4;\n      int addr = sqlite3VdbeAddOp3( p, op, p1, p2, p3 );\n      sqlite3VdbeChangeP4( p, addr, _p4, p4type );\n      return addr;\n    }\n\n    //DOUBLE (REAL)\n    static int sqlite3VdbeAddOp4( Vdbe p, int op, int p1, int p2, int p3, double pP4, int p4type )\n    {\n      union_p4 _p4 = new union_p4(); _p4.pReal = pP4;\n      int addr = sqlite3VdbeAddOp3( p, op, p1, p2, p3 );\n      sqlite3VdbeChangeP4( p, addr, _p4, p4type );\n      return addr;\n    }\n\n    //FUNCDEF\n    static int sqlite3VdbeAddOp4( Vdbe p, int op, int p1, int p2, int p3, FuncDef pP4, int p4type )\n    {\n      union_p4 _p4 = new union_p4(); _p4.pFunc = pP4;\n      int addr = sqlite3VdbeAddOp3( p, op, p1, p2, p3 );\n      sqlite3VdbeChangeP4( p, addr, _p4, p4type );\n      return addr;\n    }\n\n    //CollSeq\n    static int sqlite3VdbeAddOp4( Vdbe p, int op, int p1, int p2, int p3, CollSeq pP4, int p4type )\n    {\n      union_p4 _p4 = new union_p4(); _p4.pColl = pP4;\n      int addr = sqlite3VdbeAddOp3( p, op, p1, p2, p3 );\n      sqlite3VdbeChangeP4( p, addr, _p4, p4type );\n      return addr;\n    }\n\n    //KeyInfo\n    static int sqlite3VdbeAddOp4( Vdbe p, int op, int p1, int p2, int p3, KeyInfo pP4, int p4type )\n    {\n      union_p4 _p4 = new union_p4(); _p4.pKeyInfo = pP4;\n      int addr = sqlite3VdbeAddOp3( p, op, p1, p2, p3 );\n      sqlite3VdbeChangeP4( p, addr, _p4, p4type );\n      return addr;\n    }\n\n    //  static int sqlite3VdbeAddOp4(\n    //  Vdbe p,               /* Add the opcode to this VM */\n    //  int op,               /* The new opcode */\n    //  int p1,               /* The P1 operand */\n    //  int p2,               /* The P2 operand */\n    //  int p3,               /* The P3 operand */\n    //  union_p4 _p4,         /* The P4 operand */\n    //  int p4type            /* P4 operand type */\n    //)\n    //  {\n    //    int addr = sqlite3VdbeAddOp3(p, op, p1, p2, p3);\n    //    sqlite3VdbeChangeP4(p, addr, _p4, p4type);\n    //    return addr;\n    //  }\n\n    /*\n    ** Create a new symbolic label for an instruction that has yet to be\n    ** coded.  The symbolic label is really just a negative number.  The\n    ** label can be used as the P2 value of an operation.  Later, when\n    ** the label is resolved to a specific address, the VDBE will scan\n    ** through its operation list and change all values of P2 which match\n    ** the label into the resolved address.\n    **\n    ** The VDBE knows that a P2 value is a label because labels are\n    ** always negative and P2 values are suppose to be non-negative.\n    ** Hence, a negative P2 value is a label that has yet to be resolved.\n    **\n    ** Zero is returned if a malloc() fails.\n    */\n    static int sqlite3VdbeMakeLabel( Vdbe p )\n    {\n      int i;\n      i = p.nLabel++;\n      Debug.Assert( p.magic == VDBE_MAGIC_INIT );\n      if ( i >= p.nLabelAlloc )\n      {\n        int n = p.nLabelAlloc * 2 + 5;\n        Array.Resize( ref p.aLabel, n );\n        //p.aLabel = sqlite3DbReallocOrFree(p.db, p.aLabel,\n        //                                       n*sizeof(p.aLabel[0]));\n        p.nLabelAlloc = p.aLabel.Length;//sqlite3DbMallocSize(p.db, p.aLabel)/sizeof(p.aLabel[0]);\n      }\n      if ( p.aLabel != null )\n      {\n        p.aLabel[i] = -1;\n      }\n      return -1 - i;\n    }\n\n    /*\n    ** Resolve label "x" to be the address of the next instruction to\n    ** be inserted.  The parameter "x" must have been obtained from\n    ** a prior call to sqlite3VdbeMakeLabel().\n    */\n    static void sqlite3VdbeResolveLabel( Vdbe p, int x )\n    {\n      int j = -1 - x;\n      Debug.Assert( p.magic == VDBE_MAGIC_INIT );\n      Debug.Assert( j >= 0 && j < p.nLabel );\n      if ( p.aLabel != null )\n      {\n        p.aLabel[j] = p.nOp;\n      }\n    }\n\n    /*\n    ** Loop through the program looking for P2 values that are negative\n    ** on jump instructions.  Each such value is a label.  Resolve the\n    ** label by setting the P2 value to its correct non-zero value.\n    **\n    ** This routine is called once after all opcodes have been inserted.\n    **\n    ** Variable pMaxFuncArgs is set to the maximum value of any P2 argument\n    ** to an OP_Function, OP_AggStep or OP_VFilter opcode. This is used by\n    ** sqlite3VdbeMakeReady() to size the Vdbe.apArg[] array.\n    **\n    ** This routine also does the following optimization:  It scans for\n    ** instructions that might cause a statement rollback.  Such instructions\n    ** are:\n    **\n    **   *  OP_Halt with P1=SQLITE_CONSTRAINT and P2=OE_Abort.\n    **   *  OP_Destroy\n    **   *  OP_VUpdate\n    **   *  OP_VRename\n    **\n    ** If no such instruction is found, then every Statement instruction\n    ** is changed to a Noop.  In this way, we avoid creating the statement\n    ** journal file unnecessarily.\n    */\n    static void resolveP2Values( Vdbe p, ref int pMaxFuncArgs )\n    {\n      int i;\n      int nMaxArgs = 0;\n      Op pOp;\n      int[] aLabel = p.aLabel;\n      bool doesStatementRollback = false;\n      bool hasStatementBegin = false;\n      p.readOnly = true;\n      p.usesStmtJournal = false;\n      for ( i = 0 ; i < p.nOp ; i++ )\n      {\n        pOp = p.aOp[i];\n        int opcode = pOp.opcode;\n\n        if ( opcode == OP_Function || opcode == OP_AggStep )\n        {\n          if ( pOp.p5 > nMaxArgs ) nMaxArgs = pOp.p5;\n        }\n        else if ( opcode == OP_VUpdate )\n        {\n          if ( pOp.p2 > nMaxArgs ) nMaxArgs = pOp.p2;\n        }\n        if ( opcode == OP_Halt )\n        {\n          if ( pOp.p1 == SQLITE_CONSTRAINT && pOp.p2 == OE_Abort )\n          {\n            doesStatementRollback = true;\n          }\n        }\n        else if ( opcode == OP_Statement )\n        {\n          hasStatementBegin = true;\n          p.usesStmtJournal = true;\n        }\n        else if ( opcode == OP_Destroy )\n        {\n          doesStatementRollback = true;\n        }\n        else if ( opcode == OP_Transaction && pOp.p2 != 0 )\n        {\n          p.readOnly = false;\n#if ! SQLITE_OMIT_VIRTUALTABLE\n}else if( opcode==OP_VUpdate || opcode==OP_VRename ){\ndoesStatementRollback = 1;\n}else if( opcode==OP_VFilter ){\nint n;\nDebug.Assert( i < p.nOp - 3 );\nDebug.Assert( pOp[-1].opcode==OP_Integer );\nn = pOp[-1].p1;\nif( n>nMaxArgs ) nMaxArgs = n;\n#endif\n        }\n\n        if ( sqlite3VdbeOpcodeHasProperty( opcode, OPFLG_JUMP ) && pOp.p2 < 0 )\n        {\n          Debug.Assert( -1 - pOp.p2 < p.nLabel );\n          pOp.p2 = aLabel[-1 - pOp.p2];\n        }\n      }\n      //sqlite3DbFree( p.db, ref p.aLabel );\n\n      pMaxFuncArgs = nMaxArgs;\n\n      /* If we never rollback a statement transaction, then statement\n      ** transactions are not needed.  So change every OP_Statement\n      ** opcode into an OP_Noop.  This avoid a call to sqlite3OsOpenExclusive()\n      ** which can be expensive on some platforms.\n      */\n      if ( hasStatementBegin && !doesStatementRollback )\n      {\n        p.usesStmtJournal = false;\n        for ( i = 0 ; i < p.nOp ; i++ )\n        {\n          pOp = p.aOp[i];\n          if ( pOp.opcode == OP_Statement )\n          {\n            pOp.opcode = OP_Noop;\n          }\n        }\n      }\n    }\n\n    /*\n    ** Return the address of the next instruction to be inserted.\n    */\n    static int sqlite3VdbeCurrentAddr( Vdbe p )\n    {\n      Debug.Assert( p.magic == VDBE_MAGIC_INIT );\n      return p.nOp;\n    }\n\n    /*\n    ** Add a whole list of operations to the operation stack.  Return the\n    ** address of the first operation added.\n    */\n    static int sqlite3VdbeAddOpList( Vdbe p, int nOp, VdbeOpList[] aOp )\n    {\n      int addr;\n      Debug.Assert( p.magic == VDBE_MAGIC_INIT );\n      if ( p.nOp + nOp > p.nOpAlloc && growOpArray( p ) != 0 )\n      {\n        return 0;\n      }\n      addr = p.nOp;\n      if ( ALWAYS( nOp > 0 ) )\n      {\n        int i;\n        VdbeOpList pIn;\n        for ( i = 0 ; i < nOp ; i++ )\n        {\n          pIn = aOp[i];\n          int p2 = pIn.p2;\n          if ( p.aOp[i + addr] == null ) p.aOp[i + addr] = new VdbeOp();\n          VdbeOp pOut = p.aOp[i + addr];\n          pOut.opcode = pIn.opcode;\n          pOut.p1 = pIn.p1;\n          if ( p2 < 0 && sqlite3VdbeOpcodeHasProperty( pOut.opcode, OPFLG_JUMP ) )\n          {\n            pOut.p2 = addr + ( -1 - p2 );// ADDR(p2);\n          }\n          else\n          {\n            pOut.p2 = p2;\n          }\n          pOut.p3 = pIn.p3;\n          pOut.p4type = P4_NOTUSED;\n          pOut.p4.p = null;\n          pOut.p5 = 0;\n#if  SQLITE_DEBUG\n          pOut.zComment = null;\n          if ( sqlite3VdbeAddopTrace )\n          {\n            sqlite3VdbePrintOp( null, i + addr, p.aOp[i + addr] );\n          }\n#endif\n        }\n        p.nOp += nOp;\n      }\n      return addr;\n    }\n\n    /*\n    ** Change the value of the P1 operand for a specific instruction.\n    ** This routine is useful when a large program is loaded from a\n    ** static array using sqlite3VdbeAddOpList but we want to make a\n    ** few minor changes to the program.\n    */\n    static void sqlite3VdbeChangeP1( Vdbe p, int addr, int val )\n    {\n      Debug.Assert( p != null );\n      Debug.Assert( addr >= 0 );\n      if ( p.nOp > addr )\n      {\n        p.aOp[addr].p1 = val;\n      }\n    }\n\n    /*\n    ** Change the value of the P2 operand for a specific instruction.\n    ** This routine is useful for setting a jump destination.\n    */\n    static void sqlite3VdbeChangeP2( Vdbe p, int addr, int val )\n    {\n      Debug.Assert( p != null );\n      Debug.Assert( addr >= 0 );\n      if ( p.nOp > addr )\n      {\n        p.aOp[addr].p2 = val;\n      }\n    }\n\n    /*\n    ** Change the value of the P3 operand for a specific instruction.\n    */\n    static void sqlite3VdbeChangeP3( Vdbe p, int addr, int val )\n    {\n      Debug.Assert( p != null );\n      Debug.Assert( addr >= 0 );\n      if ( p.nOp > addr )\n      {\n        p.aOp[addr].p3 = val;\n      }\n    }\n\n    /*\n    ** Change the value of the P5 operand for the most recently\n    ** added operation.\n    */\n    static void sqlite3VdbeChangeP5( Vdbe p, u8 val )\n    {\n      Debug.Assert( p != null );\n      if ( p.aOp != null )\n      {\n        Debug.Assert( p.nOp > 0 );\n        p.aOp[p.nOp - 1].p5 = val;\n      }\n    }\n\n    /*\n    ** Change the P2 operand of instruction addr so that it points to\n    ** the address of the next instruction to be coded.\n    */\n    static void sqlite3VdbeJumpHere( Vdbe p, int addr )\n    {\n      sqlite3VdbeChangeP2( p, addr, p.nOp );\n    }\n\n\n    /*\n    ** If the input FuncDef structure is ephemeral, then free it.  If\n    ** the FuncDef is not ephermal, then do nothing.\n    */\n    static void freeEphemeralFunction( sqlite3 db, FuncDef pDef )\n    {\n      if ( ALWAYS( pDef ) && ( pDef.flags & SQLITE_FUNC_EPHEM ) != 0 )\n      {\n        pDef = null;\n        //sqlite3DbFree( db, ref  pDef );\n      }\n    }\n\n    /*\n    ** Delete a P4 value if necessary.\n    */\n    static void freeP4( sqlite3 db, int p4type, object p4 )\n    {\n      if ( p4 != null )\n      {\n        switch ( p4type )\n        {\n          case P4_REAL:\n          case P4_INT64:\n          case P4_MPRINTF:\n          case P4_DYNAMIC:\n          case P4_KEYINFO:\n          case P4_INTARRAY:\n          case P4_KEYINFO_HANDOFF:\n            {\n              //sqlite3DbFree( db, ref p4 );\n              break;\n            }\n          case P4_VDBEFUNC:\n            {\n              VdbeFunc pVdbeFunc = (VdbeFunc)p4;\n              freeEphemeralFunction( db, pVdbeFunc.pFunc );\n              sqlite3VdbeDeleteAuxData( pVdbeFunc, 0 );\n              //sqlite3DbFree( db, ref pVdbeFunc );\n              break;\n            }\n          case P4_FUNCDEF:\n            {\n              freeEphemeralFunction( db, (FuncDef)p4 );\n              break;\n            }\n          case P4_MEM:\n            {\n              p4 = null;// sqlite3ValueFree(ref (sqlite3_value)p4);\n              break;\n            }\n          case P4_VTAB:\n            {\n              sqlite3VtabUnlock( (VTable)p4 );\n              break;\n            }\n        }\n      }\n    }\n\n\n    /*\n    ** Change N opcodes starting at addr to No-ops.\n    */\n    static void sqlite3VdbeChangeToNoop( Vdbe p, int addr, int N )\n    {\n      if ( p.aOp != null )\n      {\n        sqlite3 db = p.db;\n        while ( N-- > 0 )\n        {\n          VdbeOp pOp = p.aOp[addr + N];\n          freeP4( db, pOp.p4type, pOp.p4.p );\n          pOp = p.aOp[addr + N] = new VdbeOp();//memset(pOp, 0, sizeof(pOp[0]));\n          pOp.opcode = OP_Noop;\n          //pOp++;\n        }\n      }\n    }\n\n    /*\n    ** Change the value of the P4 operand for a specific instruction.\n    ** This routine is useful when a large program is loaded from a\n    ** static array using sqlite3VdbeAddOpList but we want to make a\n    ** few minor changes to the program.\n    **\n    ** If n>=0 then the P4 operand is dynamic, meaning that a copy of\n    ** the string is made into memory obtained from sqlite3Malloc().\n    ** A value of n==0 means copy bytes of zP4 up to and including the\n    ** first null byte.  If n>0 then copy n+1 bytes of zP4.\n    **\n    ** If n==P4_KEYINFO it means that zP4 is a pointer to a KeyInfo structure.\n    ** A copy is made of the KeyInfo structure into memory obtained from\n    ** sqlite3Malloc, to be freed when the Vdbe is finalized.\n    ** n==P4_KEYINFO_HANDOFF indicates that zP4 points to a KeyInfo structure\n    ** stored in memory that the caller has obtained from sqlite3Malloc. The\n    ** caller should not free the allocation, it will be freed when the Vdbe is\n    ** finalized.\n    **\n    ** Other values of n (P4_STATIC, P4_COLLSEQ etc.) indicate that zP4 points\n    ** to a string or structure that is guaranteed to exist for the lifetime of\n    ** the Vdbe. In these cases we can just copy the pointer.\n    **\n    ** If addr<0 then change P4 on the most recently inserted instruction.\n    */\n\n    //P4_COLLSEQ\n    static void sqlite3VdbeChangeP4( Vdbe p, int addr, CollSeq pColl, int n )\n    {\n      union_p4 _p4 = new union_p4(); _p4.pColl = pColl;\n      sqlite3VdbeChangeP4( p, addr, _p4, n );\n    }\n    //P4_FUNCDEF\n    static void sqlite3VdbeChangeP4( Vdbe p, int addr, FuncDef pFunc, int n )\n    {\n      union_p4 _p4 = new union_p4(); _p4.pFunc = pFunc;\n      sqlite3VdbeChangeP4( p, addr, _p4, n );\n    }\n    //P4_INT32\n    static void sqlite3VdbeChangeP4( Vdbe p, int addr, int i32n, int n )\n    {\n      union_p4 _p4 = new union_p4(); _p4.i = i32n;\n      sqlite3VdbeChangeP4( p, addr, _p4, n );\n    }\n\n    //P4_KEYINFO\n    static void sqlite3VdbeChangeP4( Vdbe p, int addr, KeyInfo pKeyInfo, int n )\n    {\n      union_p4 _p4 = new union_p4(); _p4.pKeyInfo = pKeyInfo;\n      sqlite3VdbeChangeP4( p, addr, _p4, n );\n    }\n    //CHAR\n    static void sqlite3VdbeChangeP4( Vdbe p, int addr, char c, int n )\n    {\n      union_p4 _p4 = new union_p4(); _p4.z = c.ToString();\n      sqlite3VdbeChangeP4( p, addr, _p4, n );\n    }\n\n    //MEM\n    static void sqlite3VdbeChangeP4( Vdbe p, int addr, Mem m, int n )\n    {\n      union_p4 _p4 = new union_p4(); _p4.pMem = m;\n      sqlite3VdbeChangeP4( p, addr, _p4, n );\n    }\n\n    //STRING\n\n    //STRING + Type\n    static void sqlite3VdbeChangeP4( Vdbe p, int addr, string z, dxDel P4_Type )\n    {\n      union_p4 _p4 = new union_p4();\n      _p4.z = z;\n      sqlite3VdbeChangeP4( p, addr, _p4, P4_DYNAMIC );\n    }\n\n    static void sqlite3VdbeChangeP4( Vdbe p, int addr, string z, int n )\n    {\n      union_p4 _p4 = new union_p4();\n      if ( n > 0 && n <= z.Length ) _p4.z = z.Substring( 0, n );\n      else _p4.z = z;\n      sqlite3VdbeChangeP4( p, addr, _p4, n );\n    }\n\n    static void sqlite3VdbeChangeP4( Vdbe p, int addr, union_p4 _p4, int n )\n    {\n      Op pOp;\n      sqlite3 db;\n      Debug.Assert( p != null );\n      db = p.db;\n      Debug.Assert( p.magic == VDBE_MAGIC_INIT );\n      if ( p.aOp == null /*|| db.mallocFailed != 0 */)\n      {\n        if ( n != P4_KEYINFO && n != P4_VTAB )\n        {\n          freeP4( db, n, _p4 );\n        }\n        return;\n      }\n      Debug.Assert( p.nOp > 0 );\n      Debug.Assert( addr < p.nOp );\n      if ( addr < 0 )\n      {\n        addr = p.nOp - 1;\n      }\n      pOp = p.aOp[addr];\n      freeP4( db, pOp.p4type, pOp.p4.p );\n      pOp.p4.p = null;\n      if ( n == P4_INT32 )\n      {\n        /* Note: this cast is safe, because the origin data point was an int\n        ** that was cast to a (const char *). */\n        pOp.p4.i = _p4.i; // SQLITE_PTR_TO_INT(zP4);\n        pOp.p4type = P4_INT32;\n      }\n      else if ( n == P4_INT64 )\n      {\n        pOp.p4.pI64 = _p4.pI64;\n        pOp.p4type = n;\n      }\n      else if ( n == P4_REAL )\n      {\n        pOp.p4.pReal = _p4.pReal;\n        pOp.p4type = n;\n      }\n      else if ( _p4 == null )\n      {\n        pOp.p4.p = null;\n        pOp.p4type = P4_NOTUSED;\n      }\n      else if ( n == P4_KEYINFO )\n      {\n        KeyInfo pKeyInfo;\n        int nField, nByte;\n\n        nField = _p4.pKeyInfo.nField;\n        //nByte = sizeof(*pKeyInfo) + (nField-1)*sizeof(pKeyInfo.aColl[0]) + nField;\n        pKeyInfo = new KeyInfo();//sqlite3Malloc( nByte );\n        pOp.p4.pKeyInfo = pKeyInfo;\n        if ( pKeyInfo != null )\n        {\n          //u8 *aSortOrder;\n          //memcpy(pKeyInfo, zP4, nByte);\n          //aSortOrder = pKeyInfo.aSortOrder;\n          //if( aSortOrder ){\n          //  pKeyInfo.aSortOrder = (unsigned char*)&pKeyInfo.aColl[nField];\n          //  memcpy(pKeyInfo.aSortOrder, aSortOrder, nField);\n          //}\n          pKeyInfo = _p4.pKeyInfo.Copy();\n          pOp.p4type = P4_KEYINFO;\n        }\n        else\n        {\n          //p.db.mallocFailed = 1;\n          pOp.p4type = P4_NOTUSED;\n        }\n        pOp.p4.pKeyInfo = _p4.pKeyInfo;\n        pOp.p4type = P4_KEYINFO;\n      }\n      else if ( n == P4_KEYINFO_HANDOFF || n == P4_KEYINFO_STATIC )\n      {\n        pOp.p4.pKeyInfo = _p4.pKeyInfo;\n        pOp.p4type = P4_KEYINFO;\n      }\n      else if ( n == P4_FUNCDEF )\n      {\n        pOp.p4.pFunc = _p4.pFunc;\n        pOp.p4type = P4_FUNCDEF;\n      }\n      else if ( n == P4_COLLSEQ )\n      {\n        pOp.p4.pColl = _p4.pColl;\n        pOp.p4type = P4_COLLSEQ;\n      }\n      else if ( n == P4_DYNAMIC || n == P4_STATIC )\n      {\n        pOp.p4.z = _p4.z;\n        pOp.p4type = P4_DYNAMIC;\n      }\n      else if ( n == P4_MEM )\n      {\n        pOp.p4.pMem = _p4.pMem;\n        pOp.p4type = P4_MEM;\n      }\n      else if ( n == P4_INTARRAY )\n      {\n        pOp.p4.ai = _p4.ai;\n        pOp.p4type = P4_INTARRAY;\n      }\n      else if ( n == P4_VTAB )\n      {\n        pOp.p4.pVtab = _p4.pVtab;\n        pOp.p4type = P4_VTAB;\n        sqlite3VtabLock( _p4.pVtab );\n        Debug.Assert( ( _p4.pVtab ).db == p.db );\n      }\n      else if ( n < 0 )\n      {\n        pOp.p4.p = _p4.p;\n        pOp.p4type = n;\n      }\n      else\n      {\n        //if (n == 0) n =  n = sqlite3Strlen30(zP4);\n        pOp.p4.z = _p4.z;// sqlite3DbStrNDup(p.db, zP4, n);\n        pOp.p4type = P4_DYNAMIC;\n      }\n    }\n\n#if !NDEBUG\n    /*\n** Change the comment on the the most recently coded instruction.  Or\n** insert a No-op and add the comment to that new instruction.  This\n** makes the code easier to read during debugging.  None of this happens\n** in a production build.\n*/\n    static void sqlite3VdbeComment( Vdbe p, string zFormat, params object[] ap )\n    {\n      //      va_list ap;\n      Debug.Assert( p.nOp > 0 || p.aOp == null );\n      Debug.Assert( p.aOp == null || p.aOp[p.nOp - 1].zComment == null /* || p.db.mallocFailed != 0 */);\n      if ( p.nOp != 0 )\n      {\n        string pz;// = p.aOp[p.nOp-1].zComment;\n        va_start( ap, zFormat );\n        //sqlite3DbFree(db,ref pz);\n        pz = sqlite3VMPrintf( p.db, zFormat, ap );\n        p.aOp[p.nOp - 1].zComment = pz;\n        va_end( ap );\n      }\n    }\n    static void sqlite3VdbeNoopComment( Vdbe p, string zFormat, params object[] ap )\n    {\n      //va_list ap;\n      sqlite3VdbeAddOp0( p, OP_Noop );\n      Debug.Assert( p.nOp > 0 || p.aOp == null );\n      Debug.Assert( p.aOp == null || p.aOp[p.nOp - 1].zComment == null /* || p.db.mallocFailed != 0 */);\n      if ( p.nOp != 0 )\n      {\n        string pz; // = p.aOp[p.nOp - 1].zComment;\n        va_start( ap, zFormat );\n        //sqlite3DbFree(db,ref pz);\n        pz = sqlite3VMPrintf( p.db, zFormat, ap );\n        p.aOp[p.nOp - 1].zComment = pz;\n        va_end( ap );\n      }\n    }\n#else\n#endif  //* NDEBUG */\n\n\n    /*\n** Return the opcode for a given address.  If the address is -1, then\n** return the most recently inserted opcode.\n**\n** If a memory allocation error has occurred prior to the calling of this\n** routine, then a pointer to a dummy VdbeOp will be returned.  That opcode\n** is readable and writable, but it has no effect.  The return of a dummy\n** opcode allows the call to continue functioning after a OOM fault without\n** having to check to see if the return from this routine is a valid pointer.\n**\n** About the #if SQLITE_OMIT_TRACE:  Normally, this routine is never called\n** unless p->nOp>0.  This is because in the absense of SQLITE_OMIT_TRACE,\n** an OP_Trace instruction is always inserted by sqlite3VdbeGet() as soon as\n** a new VDBE is created.  So we are free to set addr to p->nOp-1 without\n** having to double-check to make sure that the result is non-negative. But\n** if SQLITE_OMIT_TRACE is defined, the OP_Trace is omitted and we do need to\n** check the value of p->nOp-1 before continuing.\n*/\n    static VdbeOp sqlite3VdbeGetOp( Vdbe p, int addr )\n    {\n      Debug.Assert( p.magic == VDBE_MAGIC_INIT );\n      if ( addr < 0 )\n      {\n#if SQLITE_OMIT_TRACE\n      VdbeOp dummy = null;\nif( p.nOp==0 ) return dummy;\n#endif\n        addr = p.nOp - 1;\n      }\n      Debug.Assert( ( addr >= 0 && addr < p.nOp ) /* || p.db.mallocFailed != 0 */);\n      //if ( p.db.mallocFailed != 0 )\n      //{\n      //  return dummy;\n      //}\n      //else\n      {\n        return p.aOp[addr];\n      }\n    }\n\n#if !SQLITE_OMIT_EXPLAIN || !NDEBUG || VDBE_PROFILE || SQLITE_DEBUG\n    /*\n** Compute a string that describes the P4 parameter for an opcode.\n** Use zTemp for any required temporary buffer space.\n*/\n    static string displayP4( Op pOp, string zBuffer, int nTemp )\n    {\n      StringBuilder zTemp = new StringBuilder( 100 );\n      Debug.Assert( nTemp >= 20 );\n      switch ( pOp.p4type )\n      {\n        case P4_KEYINFO_STATIC:\n        case P4_KEYINFO:\n          {\n            int i, j;\n            KeyInfo pKeyInfo = pOp.p4.pKeyInfo;\n            sqlite3_snprintf( nTemp, ref zTemp, "keyinfo(%d", pKeyInfo.nField );\n            i = sqlite3Strlen30( zTemp );\n            for ( j = 0 ; j < pKeyInfo.nField ; j++ )\n            {\n              CollSeq pColl = pKeyInfo.aColl[j];\n              if ( pColl != null )\n              {\n                int n = sqlite3Strlen30( pColl.zName );\n                if ( i + n > nTemp )\n                {\n                  zTemp.Append( ",..." ); // memcpy( &zTemp[i], ",...", 4 );\n                  break;\n                }\n                zTemp.Append( "," );// zTemp[i++] = \',\';\n                if ( pKeyInfo.aSortOrder != null && pKeyInfo.aSortOrder[j] != 0 )\n                {\n                  zTemp.Append( "-" );// zTemp[i++] = \'-\';\n                }\n                zTemp.Append( pColl.zName );// memcpy( &zTemp[i], pColl.zName, n + 1 );\n                i += n;\n              }\n              else if ( i + 4 < nTemp )\n              {\n                zTemp.Append( ",nil" );// memcpy( &zTemp[i], ",nil", 4 );\n                i += 4;\n              }\n            }\n            zTemp.Append( ")" );// zTemp[i++] = \')\';\n            //zTemp[i] = 0;\n            Debug.Assert( i < nTemp );\n            break;\n          }\n        case P4_COLLSEQ:\n          {\n            CollSeq pColl = pOp.p4.pColl;\n            sqlite3_snprintf( nTemp, ref zTemp, "collseq(%.20s)", ( pColl != null ? pColl.zName : "null" ) );\n            break;\n          }\n        case P4_FUNCDEF:\n          {\n            FuncDef pDef = pOp.p4.pFunc;\n            sqlite3_snprintf( nTemp, ref zTemp, "%s(%d)", pDef.zName, pDef.nArg );\n            break;\n          }\n        case P4_INT64:\n          {\n            sqlite3_snprintf( nTemp, ref zTemp, "%lld", pOp.p4.pI64 );\n            break;\n          }\n        case P4_INT32:\n          {\n            sqlite3_snprintf( nTemp, ref zTemp, "%d", pOp.p4.i );\n            break;\n          }\n        case P4_REAL:\n          {\n            sqlite3_snprintf( nTemp, ref zTemp, "%.16g", pOp.p4.pReal );\n            break;\n          }\n        case P4_MEM:\n          {\n            Mem pMem = pOp.p4.pMem;\n            Debug.Assert( ( pMem.flags & MEM_Null ) == 0 );\n            if ( ( pMem.flags & MEM_Str ) != 0 )\n            {\n              zTemp.Append( pMem.z );\n            }\n            else if ( ( pMem.flags & MEM_Int ) != 0 )\n            {\n              sqlite3_snprintf( nTemp, ref zTemp, "%lld", pMem.u.i );\n            }\n            else if ( ( pMem.flags & MEM_Real ) != 0 )\n            {\n              sqlite3_snprintf( nTemp, ref zTemp, "%.16g", pMem.r );\n            }\n            break;\n          }\n#if ! SQLITE_OMIT_VIRTUALTABLE\ncase P4_VTAB: {\nsqlite3_vtab pVtab = pOp.p4.pVtab.pVtab;\nsqlite3_snprintf(nTemp, ref zTemp, "vtab:%p:%p", pVtab, pVtab.pModule);\nbreak;\n}\n#endif\n        case P4_INTARRAY:\n          {\n            sqlite3_snprintf( nTemp, ref zTemp, "intarray" );\n            break;\n          }\n        default:\n          {\n            if ( pOp.p4.z != null ) zTemp.Append( pOp.p4.z );\n            //if ( zTemp == null )\n            //{\n            //  zTemp = "";\n            //}\n            break;\n          }\n      }\n      Debug.Assert( zTemp != null );\n      return zTemp.ToString();\n    }\n#endif\n\n    /*\n** Declare to the Vdbe that the BTree object at db.aDb[i] is used.\n**\n*/\n    static void sqlite3VdbeUsesBtree( Vdbe p, int i )\n    {\n      int mask;\n      Debug.Assert( i >= 0 && i < p.db.nDb && i < sizeof( u32 ) * 8 );\n      Debug.Assert( i < sizeof( int ) * 8 );\n      mask = (int)( (u32)1 ) << i;\n      if ( ( p.btreeMask & mask ) == 0 )\n      {\n        p.btreeMask |= mask;\n        sqlite3BtreeMutexArrayInsert( p.aMutex, p.db.aDb[i].pBt );\n      }\n    }\n\n\n#if VDBE_PROFILE || SQLITE_DEBUG\n    /*\n** Print a single opcode.  This routine is used for debugging only.\n*/\n    static void sqlite3VdbePrintOp( FILE pOut, int pc, Op pOp )\n    {\n      string zP4;\n      string zPtr = null;\n      string zFormat1 = "%4d %-13s %4d %4d %4d %-4s %.2X %s\\n";\n      if ( pOut == null ) pOut = System.Console.Out;\n      zP4 = displayP4( pOp, zPtr, 50 );\n      string zOut = "";\n      sqlite3_snprintf( 999, ref zOut, zFormat1, pc,\n      sqlite3OpcodeName( pOp.opcode ), pOp.p1, pOp.p2, pOp.p3, zP4, pOp.p5,\n#if  SQLITE_DEBUG\n pOp.zComment != null ? pOp.zComment : ""\n#else\n""\n#endif\n );\n      pOut.Write( zOut );\n      //fflush(pOut);\n    }\n#endif\n\n    /*\n** Release an array of N Mem elements\n*/\n    static void releaseMemArray( Mem[] p, int N )\n    {\n      if ( p != null && p[0] != null && N != 0 )\n      {\n        Mem pEnd;\n        sqlite3 db = p[0].db;\n        //u8 malloc_failed =  db.mallocFailed;\n        for ( int i = 0 ; i < N ; i++ )//pEnd =  p[N] ; p < pEnd ; p++ )\n        {\n          pEnd = p[i];\n          Debug.Assert( //( p[1] ) == pEnd ||\n          N == 1 || p[0].db == p[1].db );\n\n          /* This block is really an inlined version of sqlite3VdbeMemRelease()\n          ** that takes advantage of the fact that the memory cell value is\n          ** being set to NULL after releasing any dynamic resources.\n          **\n          ** The justification for duplicating code is that according to\n          ** callgrind, this causes a certain test case to hit the CPU 4.7\n          ** percent less (x86 linux, gcc version 4.1.2, -O6) than if\n          ** sqlite3MemRelease() were called from here. With -O2, this jumps\n          ** to 6.6 percent. The test case is inserting 1000 rows into a table\n          ** with no indexes using a single prepared INSERT statement, bind()\n          ** and reset(). Inserts are grouped into a transaction.\n          */\n          if ( ( pEnd.flags & ( MEM_Agg | MEM_Dyn ) ) != 0 )\n          {\n            sqlite3VdbeMemRelease( pEnd );\n          }\n          //else if ( pEnd.zMalloc != null )\n          //{\n          //  //sqlite3DbFree( db, ref pEnd.zMalloc );\n          //  pEnd.zMalloc = 0;\n          //}\n          pEnd._Mem = null;\n          pEnd.z = null;\n          pEnd.n = 0;\n          pEnd.zBLOB = null;\n          pEnd.flags = MEM_Null;\n        }\n//        db.mallocFailed = malloc_failed;\n      }\n    }\n\n#if SQLITE_ENABLE_MEMORY_MANAGEMENT\nint sqlite3VdbeReleaseBuffers(Vdbe *p){\nint ii;\nint nFree = 0;\nassert( sqlite3_mutex_held(p.db.mutex) );\nfor(ii=1; ii<=p.nMem; ii++){\nMem *pMem = &p.aMem[ii];\nif( pMem.flags & MEM_RowSet ){\nsqlite3RowSetClear(pMem.u.pRowSet);\n}\nif( pMem.z && pMem.flags&MEM_Dyn ){\nassert( !pMem.xDel );\nnFree += sqlite3DbMallocSize(pMem.db, pMem.z);\nsqlite3VdbeMemRelease(pMem);\n}\n}\nreturn nFree;\n}\n#endif\n\n#if ! SQLITE_OMIT_EXPLAIN\n    /*\n** Give a listing of the program in the virtual machine.\n**\n** The interface is the same as sqlite3VdbeExec().  But instead of\n** running the code, it invokes the callback once for each instruction.\n** This feature is used to implement "EXPLAIN".\n**\n** When p.explain==1, each instruction is listed.  When\n** p.explain==2, only OP_Explain instructions are listed and these\n** are shown in a different format.  p.explain==2 is used to implement\n** EXPLAIN QUERY PLAN.\n*/\n    static int sqlite3VdbeList(\n    Vdbe p                   /* The VDBE */\n    )\n    {\n      sqlite3 db = p.db;\n      int i;\n      int rc = SQLITE_OK;\n      p.pResultSet = new Mem[p.nMem];//Mem* pMem = p.pResultSet = p.aMem[1];\n      Mem pMem;\n      Debug.Assert( p.explain != 0 );\n      Debug.Assert( p.magic == VDBE_MAGIC_RUN );\n#if SQL_DEBUG\nDebug.Assert(db.magic == SQLITE_MAGIC_BUSY);\n#endif\n      Debug.Assert( p.rc == SQLITE_OK || p.rc == SQLITE_BUSY || p.rc == SQLITE_NOMEM );\n      /* Even though this opcode does not use dynamic strings for\n      ** the result, result columns may become dynamic if the user calls\n      ** sqlite3_column_text16(), causing a translation to UTF-16 encoding.\n      */\n      releaseMemArray( p.pResultSet, p.nMem );\n\n      if ( p.rc == SQLITE_NOMEM )\n      {\n        /* This happens if a malloc() inside a call to sqlite3_column_text() or\n        ** sqlite3_column_text16() failed.  */\n////        db.mallocFailed = 1;\n        return SQLITE_ERROR;\n      }\n\n      int i_pMem = 0; if ( p.pResultSet[i_pMem] == null ) p.pResultSet[i_pMem] = new Mem();\n      pMem = p.pResultSet[i_pMem++];\n      do\n      {\n        i = p.pc++;\n      } while ( i < p.nOp && p.explain == 2 && p.aOp[i].opcode != OP_Explain );\n      if ( i >= p.nOp )\n      {\n        p.rc = SQLITE_OK;\n        rc = SQLITE_DONE;\n      }\n      else if ( db.u1.isInterrupted )\n      {\n        p.rc = SQLITE_INTERRUPT;\n        rc = SQLITE_ERROR;\n        sqlite3SetString( ref p.zErrMsg, db, sqlite3ErrStr( p.rc ) );\n      }\n      else\n      {\n        string z;\n        Op pOp = p.aOp[i];\n        if ( p.explain == 1 )\n        {\n          pMem.flags = MEM_Int;\n          pMem.type = SQLITE_INTEGER;\n          pMem.u.i = i;                                /* Program counter */\n          if ( p.pResultSet[i_pMem] == null ) p.pResultSet[i_pMem] = new Mem();\n          pMem = p.pResultSet[i_pMem++]; //pMem++;\n\n          pMem.flags = MEM_Static | MEM_Str | MEM_Term;\n          pMem.z = sqlite3OpcodeName( pOp.opcode );  /* Opcode */\n          Debug.Assert( pMem.z != null );\n          pMem.n = sqlite3Strlen30( pMem.z );\n          pMem.type = SQLITE_TEXT;\n          pMem.enc = SQLITE_UTF8;\n          if ( p.pResultSet[i_pMem] == null ) p.pResultSet[i_pMem] = new Mem();\n          pMem = p.pResultSet[i_pMem++]; //pMem++;\n        }\n\n        pMem.flags = MEM_Int;\n        pMem.u.i = pOp.p1;                          /* P1 */\n        pMem.type = SQLITE_INTEGER;\n        if ( p.pResultSet[i_pMem] == null ) p.pResultSet[i_pMem] = new Mem();\n        pMem = p.pResultSet[i_pMem++]; //pMem++;\n\n        pMem.flags = MEM_Int;\n        pMem.u.i = pOp.p2;                          /* P2 */\n        pMem.type = SQLITE_INTEGER;\n        if ( p.pResultSet[i_pMem] == null ) p.pResultSet[i_pMem] = new Mem();\n        pMem = p.pResultSet[i_pMem++]; //pMem++;\n\n        if ( p.explain == 1 )\n        {\n          pMem.flags = MEM_Int;\n          pMem.u.i = pOp.p3;                          /* P3 */\n          pMem.type = SQLITE_INTEGER;\n          if ( p.pResultSet[i_pMem] == null ) p.pResultSet[i_pMem] = new Mem();\n          pMem = p.pResultSet[i_pMem++]; //pMem++;\n        }\n\n        if ( sqlite3VdbeMemGrow( pMem, 32, 0 ) != 0 )\n        {                                                     /* P4 */\n          //Debug.Assert( p.db.mallocFailed != 0 );\n          return SQLITE_ERROR;\n        }\n        pMem.flags = MEM_Dyn | MEM_Str | MEM_Term;\n        z = displayP4( pOp, pMem.z, 32 );\n        if ( z != pMem.z )\n        {\n          sqlite3VdbeMemSetStr( pMem, z, -1, SQLITE_UTF8, null );\n        }\n        else\n        {\n          Debug.Assert( pMem.z != null );\n          pMem.n = sqlite3Strlen30( pMem.z );\n          pMem.enc = SQLITE_UTF8;\n        }\n        pMem.type = SQLITE_TEXT;\n        if ( p.pResultSet[i_pMem] == null ) p.pResultSet[i_pMem] = new Mem();\n        pMem = p.pResultSet[i_pMem++]; //pMem++;\n\n        if ( p.explain == 1 )\n        {\n          if ( sqlite3VdbeMemGrow( pMem, 4, 0 ) != 0 )\n          {\n            //Debug.Assert( p.db.mallocFailed != 0 );\n            return SQLITE_ERROR;\n          }\n          pMem.flags = MEM_Dyn | MEM_Str | MEM_Term;\n          pMem.n = 2;\n          pMem.z = pOp.p5.ToString( "x2" );  //sqlite3_snprintf( 3, pMem.z, "%.2x", pOp.p5 );   /* P5 */\n          pMem.type = SQLITE_TEXT;\n          pMem.enc = SQLITE_UTF8;\n          if ( p.pResultSet[i_pMem] == null ) p.pResultSet[i_pMem] = new Mem();\n          pMem = p.pResultSet[i_pMem++]; // pMem++;\n\n#if SQLITE_DEBUG\n          if ( pOp.zComment != null )\n          {\n            pMem.flags = MEM_Str | MEM_Term;\n            pMem.z = pOp.zComment;\n            pMem.n = pMem.z == null ? 0 : sqlite3Strlen30( pMem.z );\n            pMem.enc = SQLITE_UTF8;\n            pMem.type = SQLITE_TEXT;\n          }\n          else\n#endif\n          {\n            pMem.flags = MEM_Null;                       /* Comment */\n            pMem.type = SQLITE_NULL;\n          }\n        }\n\n        p.nResColumn = (u16)( 8 - 5 * ( p.explain - 1 ) );\n        p.rc = SQLITE_OK;\n        rc = SQLITE_ROW;\n      }\n      return rc;\n    }\n#endif // * SQLITE_OMIT_EXPLAIN */\n\n#if  SQLITE_DEBUG\n    /*\n** Print the SQL that was used to generate a VDBE program.\n*/\n    static void sqlite3VdbePrintSql( Vdbe p )\n    {\n      int nOp = p.nOp;\n      VdbeOp pOp;\n      if ( nOp < 1 ) return;\n      pOp = p.aOp[0];\n      if ( pOp.opcode == OP_Trace && pOp.p4.z != null )\n      {\n        string z = pOp.p4.z;\n        z = z.Trim();// while ( sqlite3Isspace( *(u8*)z ) ) z++;\n        Console.Write( "SQL: [%s]\\n", z );\n      }\n    }\n#endif\n\n#if !SQLITE_OMIT_TRACE && SQLITE_ENABLE_IOTRACE\n/*\n** Print an IOTRACE message showing SQL content.\n*/\nstatic void sqlite3VdbeIOTraceSql( Vdbe p )\n{\nint nOp = p.nOp;\nVdbeOp pOp;\nif ( SQLite3IoTrace == false ) return;\nif ( nOp < 1 ) return;\npOp = p.aOp[0];\nif ( pOp.opcode == OP_Trace && pOp.p4.z != null )\n{\nint i, j;\nstring z = "";//char z[1000];\nsqlite3_snprintf( 1000, ref  z, "%s", pOp.p4.z );\n//for(i=0; sqlite3Isspace(z[i]); i++){}\n//for(j=0; z[i]; i++){\n//if( sqlite3Isspace(z[i]) ){\n//if( z[i-1]!=\' \' ){\n//z[j++] = \' \';\n//}\n//}else{\n//z[j++] = z[i];\n//}\n//}\n//z[j] = 0;\n//z = z.Trim( z );\nsqlite3IoTrace( "SQL %s\\n", z.Trim() );\n}\n}\n#endif // * !SQLITE_OMIT_TRACE  && SQLITE_ENABLE_IOTRACE */\n\n    /*\n** Allocate space from a fixed size buffer.  Make *pp point to the\n** allocated space.  (Note:  pp is a char* rather than a void** to\n** work around the pointer aliasing rules of C.)  *pp should initially\n** be zero.  If *pp is not zero, that means that the space has already\n** been allocated and this routine is a noop.\n**\n** nByte is the number of bytes of space needed.\n**\n** *ppFrom point to available space and pEnd points to the end of the\n** available space.\n**\n** *pnByte is a counter of the number of bytes of space that have failed\n** to allocate.  If there is insufficient space in *ppFrom to satisfy the\n** request, then increment *pnByte by the amount of the request.\n*/\n    //static void allocSpace(\n    //ref u8[] pp,            /* IN/OUT: Set *pp to point to allocated buffer */\n    //int nByte,              /* Number of bytes to allocate */\n    //ref u8[] ppFrom,        /* IN/OUT: Allocate from *ppFrom */\n    //u8 pEnd,                /* Pointer to 1 byte past the end of *ppFrom buffer */\n    //ref int pnByte          /* If allocation cannot be made, increment *pnByte */\n    //)\n    //{\n      //assert( EIGHT_BYTE_ALIGNMENT(*ppFrom) );\n      //if ( ( *(void**)pp ) == 0 )\n      //{\n      //  nByte = ROUND8( nByte );\n      //  if( &(*ppFrom)[nByte] <= pEnd ){\n      //    *(void**)pp = (void*)*ppFrom;\n      //    *ppFrom += nByte;\n      //  }\n      //  else\n      //  {\n      //    *pnByte += nByte;\n      //  }\n      //}\n    //}\n\n    /*\n    ** Prepare a virtual machine for execution.  This involves things such\n    ** as allocating stack space and initializing the program counter.\n    ** After the VDBE has be prepped, it can be executed by one or more\n    ** calls to sqlite3VdbeExec().\n    **\n    ** This is the only way to move a VDBE from VDBE_MAGIC_INIT to\n    ** VDBE_MAGIC_RUN.\n    **\n    ** This function may be called more than once on a single virtual machine.\n    ** The first call is made while compiling the SQL statement. Subsequent\n    ** calls are made as part of the process of resetting a statement to be\n    ** re-executed (from a call to sqlite3_reset()). The nVar, nMem, nCursor\n    ** and isExplain parameters are only passed correct values the first time\n    ** the function is called. On subsequent calls, from sqlite3_reset(), nVar\n    ** is passed -1 and nMem, nCursor and isExplain are all passed zero.\n    */\n    static void sqlite3VdbeMakeReady(\n    Vdbe p,                        /* The VDBE */\n    int nVar,                      /* Number of \'?\' see in the SQL statement */\n    int nMem,                      /* Number of memory cells to allocate */\n    int nCursor,                   /* Number of cursors to allocate */\n    int isExplain                 /* True if the EXPLAIN keywords is present */\n    )\n    {\n      int n;\n      sqlite3 db = p.db;\n\n      Debug.Assert( p != null );\n      Debug.Assert( p.magic == VDBE_MAGIC_INIT );\n\n      /* There should be at least one opcode.\n      */\n      Debug.Assert( p.nOp > 0 );\n\n      /* Set the magic to VDBE_MAGIC_RUN sooner rather than later. */\n      p.magic = VDBE_MAGIC_RUN;\n\n      /* For each cursor required, also allocate a memory cell. Memory\n      ** cells (nMem+1-nCursor)..nMem, inclusive, will never be used by\n      ** the vdbe program. Instead they are used to allocate space for\n      ** VdbeCursor/BtCursor structures. The blob of memory associated with\n      ** cursor 0 is stored in memory cell nMem. Memory cell (nMem-1)\n      ** stores the blob of memory associated with cursor 1, etc.\n      **\n      ** See also: allocateCursor().\n      */\n      nMem += nCursor;\n\n      /* Allocate space for memory registers, SQL variables, VDBE cursors and\n      ** an array to marshal SQL function arguments in. This is only done the\n      ** first time this function is called for a given VDBE, not when it is\n      ** being called from sqlite3_reset() to reset the virtual machine.\n      */\n      if ( nVar >= 0 /* &&  ALWAYS(db->mallocFailed==0) */ )\n      {\n        //u8 zCsr = (u8)p.aOp[p.nOp];\n        //u8 zEnd = (u8)p.aOp[p.nOpAlloc];\n        int nByte;\n        int nArg = 0;       /* Maximum number of args passed to a user function. */\n        resolveP2Values( p, ref nArg );\n        if ( isExplain != 0 && nMem < 10 )\n        {\n          nMem = 10;\n        }\n        //memset(zCsr, 0, zEnd-zCsr);\n        //zCsr += ( zCsr - (u8*)0 ) & 7;\n        //assert( EIGHT_BYTE_ALIGNMENT( zCsr ) );\n        //\n        // C# -- Replace allocation with individual Dims\n        //\n        //do\n        //{\n        //  nByte = 0;\n        //  allocSpace( (char*)&p.aMem, nMem * sizeof( Mem ), &zCsr, zEnd, &nByte );\n        //  allocSpace( (char*)&p.aVar, nVar * sizeof( Mem ), &zCsr, zEnd, &nByte );\n        //  allocSpace( (char*)&p.apArg, nArg * sizeof( Mem* ), &zCsr, zEnd, &nByte );\n        //  allocSpace( (char*)&p.azVar, nVar * sizeof( char* ), &zCsr, zEnd, &nByte );\n        //  allocSpace( (char*)&p.apCsr,\n        //             nCursor * sizeof( VdbeCursor* ), &zCsr, zEnd, &nByte\n        //  );\n        //  if ( nByte )\n        //  {\n        //    p.pFree = sqlite3DbMallocZero( db, nByte );\n        //  }\n        //  zCsr = p.pFree;\n        //  zEnd = &zCsr[nByte];\n        //} while ( nByte && !db.mallocFailed );\n\n\n        // C# -- Replace allocation with individual Dims\n        p.aMem = new Mem[nMem + 1];\n        for ( n = 0 ; n <= nMem ; n++ )\n        { p.aMem[n] = new Mem(); }//p.aMem--;\n        /* aMem[] goes from 1..nMem */\n        p.nMem = nMem;      /*       not from 0..nMem-1 */\n        //\n        p.aVar = new Mem[nVar == 0 ? 1 : nVar]; //p.aVar = p.aMem[nMem + 1];\n        for ( n = 0 ; n < nVar ; n++ )\n        { p.aVar[n] = new Mem(); }\n        p.nVar = (u16)nVar;\n        p.okVar = 0;\n        //\n        p.apArg = new Mem[nArg == 0 ? 1 : nArg];//p.apArg = (Mem**)p.aVar[nVar];\n        //\n\n        p.azVar = new string[nArg == 0 ? 1 : nArg]; //p.azVar = (char**)p.apArg[nArg];\n        for ( n = 0 ; n < nArg ; n++ )\n        { p.azVar[n] = ""; }\n        //\n        p.apCsr = new VdbeCursor[nCursor == 0 ? 1 : nCursor];//p.apCsr = (VdbeCursor**)p.azVar[nVar];\n        p.apCsr[0] = new VdbeCursor();\n        p.nCursor = (u16)nCursor;\n        if ( p.aVar != null )\n        {\n          p.nVar = (u16)nVar;\n          //\n          for ( n = 0 ; n < nVar ; n++ )\n          {\n            p.aVar[n].flags = MEM_Null;\n            p.aVar[n].db = db;\n          }\n        }\n        if ( p.aMem != null )\n        {\n          //p.aMem--;                      /* aMem[] goes from 1..nMem */\n          p.nMem = nMem;                 /*       not from 0..nMem-1 */\n          for ( n = 0 ; n <= nMem ; n++ )\n          {\n            p.aMem[n].flags = MEM_Null;\n            p.aMem[n].n = 0;\n            p.aMem[n].z = null;\n            p.aMem[n].zBLOB = null;\n            p.aMem[n].db = db;\n          }\n        }\n      }\n\n#if  SQLITE_DEBUG\n      for ( n = 1 ; n < p.nMem ; n++ )\n      {\n        Debug.Assert( p.aMem[n].db == db );\n      }\n#endif\n\n      p.pc = -1;\n      p.rc = SQLITE_OK;\n      p.errorAction = OE_Abort;\n      p.explain |= isExplain;\n      p.magic = VDBE_MAGIC_RUN;\n      p.nChange = 0;\n      p.cacheCtr = 1;\n      p.minWriteFileFormat = 255;\n      p.iStatement = 0;\n#if  VDBE_PROFILE\n{\nint i;\nfor ( i = 0 ; i < p.nOp ; i++ )\n{\np.aOp[i].cnt = 0;\np.aOp[i].cycles = 0;\n}\n}\n#endif\n    }\n\n    /*\n    ** Close a VDBE cursor and release all the resources that cursor\n    ** happens to hold.\n    */\n    static void sqlite3VdbeFreeCursor( Vdbe p, VdbeCursor pCx )\n    {\n      if ( pCx == null )\n      {\n        return;\n      }\n\n      if ( pCx.pBt != null )\n      {\n        sqlite3BtreeClose( ref  pCx.pBt );\n        /* The pCx.pCursor will be close automatically, if it exists, by\n        ** the call above. */\n      }\n      else if ( pCx.pCursor != null )\n      {\n        sqlite3BtreeCloseCursor( pCx.pCursor );\n      }\n#if ! SQLITE_OMIT_VIRTUALTABLE\nif( pCx.pVtabCursor ){\nsqlite3_vtab_cursor pVtabCursor = pCx.pVtabCursor;\nconst sqlite3_module pModule = pCx.pModule;\np.inVtabMethod = 1;\nsqlite3SafetyOff(p.db);\npModule.xClose(pVtabCursor);\nsqlite3SafetyOn(p.db);\np.inVtabMethod = 0;\n}\n#endif\n      if ( !pCx.ephemPseudoTable )\n      {\n        //sqlite3DbFree( p.db, ref pCx.pData );\n      }\n    }\n\n    /*\n    ** Close all cursors.\n    */\n    static void closeAllCursors( Vdbe p )\n    {\n      int i;\n      if ( p.apCsr == null ) return;\n      for ( i = 0 ; i < p.nCursor ; i++ )\n      {\n        VdbeCursor pC = p.apCsr[i];\n        if ( pC != null )\n        {\n          sqlite3VdbeFreeCursor( p, pC );\n          p.apCsr[i] = null;\n        }\n      }\n    }\n\n    /*\n    ** Clean up the VM after execution.\n    **\n    ** This routine will automatically close any cursors, lists, and/or\n    ** sorters that were left open.  It also deletes the values of\n    ** variables in the aVar[] array.\n    */\n    static void Cleanup( Vdbe p )\n    {\n      int i;\n      sqlite3 db = p.db;\n      Mem pMem;\n      closeAllCursors( p );\n      for ( i = 1 ; i <= p.nMem ; i++ )\n      {\n        pMem = p.aMem[1];\n        if ( ( pMem.flags & MEM_RowSet ) != 0 )\n        {\n          sqlite3RowSetClear( pMem.u.pRowSet );\n        }\n        MemSetTypeFlag( pMem, MEM_Null );\n      }\n      releaseMemArray( p.aMem, p.nMem );\n      if ( p.contextStack != null )\n      {\n        //sqlite3DbFree( db, ref p.contextStack );\n      }\n      p.contextStack = null;\n      p.contextStackDepth = 0;\n      p.contextStackTop = 0;\n      //sqlite3DbFree( db, ref p.zErrMsg );\n      p.pResultSet = null;\n    }\n\n    /*\n    ** Set the number of result columns that will be returned by this SQL\n    ** statement. This is now set at compile time, rather than during\n    ** execution of the vdbe program so that sqlite3_column_count() can\n    ** be called on an SQL statement before sqlite3_step().\n    */\n    static void sqlite3VdbeSetNumCols( Vdbe p, int nResColumn )\n    {\n      Mem pColName;\n      int n;\n      sqlite3 db = p.db;\n\n      releaseMemArray( p.aColName, p.nResColumn * COLNAME_N );\n      //sqlite3DbFree( db, ref p.aColName );\n      n = nResColumn * COLNAME_N;\n      p.nResColumn = (u16)nResColumn;\n      p.aColName = new Mem[n];// (Mem*)sqlite3DbMallocZero(db, Mem.Length * n);\n      //if (p.aColName == 0) return;\n      while ( n-- > 0 )\n      {\n        p.aColName[n] = new Mem();\n        pColName = p.aColName[n];\n        pColName.flags = MEM_Null;\n        pColName.db = p.db;\n      }\n    }\n\n    /*\n    ** Set the name of the idx\'th column to be returned by the SQL statement.\n    ** zName must be a pointer to a nul terminated string.\n    **\n    ** This call must be made after a call to sqlite3VdbeSetNumCols().\n    **\n    ** The final parameter, xDel, must be one of SQLITE_DYNAMIC, SQLITE_STATIC\n    ** or SQLITE_TRANSIENT. If it is SQLITE_DYNAMIC, then the buffer pointed\n    ** to by zName will be freed by //sqlite3DbFree() when the vdbe is destroyed.\n    */\n\n\n    static int sqlite3VdbeSetColName(\n    Vdbe p,                 /* Vdbe being configured */\n    int idx,                /* Index of column zName applies to */\n    int var,                /* One of the COLNAME_* constants */\n    string zName,           /* Pointer to buffer containing name */\n    dxDel xDel              /* Memory management strategy for zName */\n    )\n    {\n      int rc;\n      Mem pColName;\n      Debug.Assert( idx < p.nResColumn );\n      Debug.Assert( var < COLNAME_N );\n      //if ( p.db.mallocFailed != 0 )\n      //{\n      //  Debug.Assert( null == zName || xDel != SQLITE_DYNAMIC );\n      //  return SQLITE_NOMEM;\n      //}\n      Debug.Assert( p.aColName != null );\n      pColName = p.aColName[idx + var * p.nResColumn];\n      rc = sqlite3VdbeMemSetStr( pColName, zName, -1, SQLITE_UTF8, xDel );\n      Debug.Assert( rc != 0 || null == zName || ( pColName.flags & MEM_Term ) != 0 );\n      return rc;\n    }\n\n    /*\n    ** A read or write transaction may or may not be active on database handle\n    ** db. If a transaction is active, commit it. If there is a\n    ** write-transaction spanning more than one database file, this routine\n    ** takes care of the master journal trickery.\n    */\n    static int vdbeCommit( sqlite3 db, Vdbe p )\n    {\n      int i;\n      int nTrans = 0;  /* Number of databases with an active write-transaction */\n      int rc = SQLITE_OK;\n      bool needXcommit = false;\n\n#if SQLITE_OMIT_VIRTUALTABLE\n      /* With this option, sqlite3VtabSync() is defined to be simply\n** SQLITE_OK so p is not used.\n*/\n      UNUSED_PARAMETER( p );\n#endif\n      /* Before doing anything else, call the xSync() callback for any\n** virtual module tables written in this transaction. This has to\n** be done before determining whether a master journal file is\n** required, as an xSync() callback may add an attached database\n** to the transaction.\n*/\n      rc = sqlite3VtabSync( db, p.zErrMsg );\n      if ( rc != SQLITE_OK )\n      {\n        return rc;\n      }\n\n      /* This loop determines (a) if the commit hook should be invoked and\n      ** (b) how many database files have open write transactions, not\n      ** including the temp database. (b) is important because if more than\n      ** one database file has an open write transaction, a master journal\n      ** file is required for an atomic commit.\n      */\n      for ( i = 0 ; i < db.nDb ; i++ )\n      {\n        Btree pBt = db.aDb[i].pBt;\n        if ( sqlite3BtreeIsInTrans( pBt ) )\n        {\n          needXcommit = true;\n          if ( i != 1 ) nTrans++;\n        }\n      }\n\n      /* If there are any write-transactions at all, invoke the commit hook */\n      if ( needXcommit && db.xCommitCallback != null )\n      {\n        sqlite3SafetyOff( db );\n        rc = db.xCommitCallback( db.pCommitArg );\n        sqlite3SafetyOn( db );\n        if ( rc != 0 )\n        {\n          return SQLITE_CONSTRAINT;\n        }\n      }\n\n      /* The simple case - no more than one database file (not counting the\n      ** TEMP database) has a transaction active.   There is no need for the\n      ** master-journal.\n      **\n      ** If the return value of sqlite3BtreeGetFilename() is a zero length\n      ** string, it means the main database is :memory: or a temp file.  In\n      ** that case we do not support atomic multi-file commits, so use the\n      ** simple case then too.\n      */\n      if ( 0 == sqlite3Strlen30( sqlite3BtreeGetFilename( db.aDb[0].pBt ) )\n      || nTrans <= 1 )\n      {\n        for ( i = 0 ; rc == SQLITE_OK && i < db.nDb ; i++ )\n        {\n          Btree pBt = db.aDb[i].pBt;\n          if ( pBt != null )\n          {\n            rc = sqlite3BtreeCommitPhaseOne( pBt, null );\n          }\n        }\n\n        /* Do the commit only if all databases successfully complete phase 1.\n        ** If one of the BtreeCommitPhaseOne() calls fails, this indicates an\n        ** IO error while deleting or truncating a journal file. It is unlikely,\n        ** but could happen. In this case abandon processing and return the error.\n        */\n        for ( i = 0 ; rc == SQLITE_OK && i < db.nDb ; i++ )\n        {\n          Btree pBt = db.aDb[i].pBt;\n          if ( pBt != null )\n          {\n            rc = sqlite3BtreeCommitPhaseTwo( pBt );\n          }\n        }\n        if ( rc == SQLITE_OK )\n        {\n          sqlite3VtabCommit( db );\n        }\n      }\n\n          /* The complex case - There is a multi-file write-transaction active.\n          ** This requires a master journal file to ensure the transaction is\n          ** committed atomicly.\n          */\n#if ! SQLITE_OMIT_DISKIO\n      else\n      {\n        sqlite3_vfs pVfs = db.pVfs;\n        bool needSync = false;\n        string zMaster = "";   /* File-name for the master journal */\n        string zMainFile = sqlite3BtreeGetFilename( db.aDb[0].pBt );\n        sqlite3_file pMaster = null;\n        i64 offset = 0;\n        int res = 0;\n\n        /* Select a master journal file name */\n        do\n        {\n          i64 iRandom = 0;\n          //sqlite3DbFree(db,ref zMaster);\n          sqlite3_randomness( sizeof( u32 ), ref iRandom );//random.Length\n          zMaster = sqlite3MPrintf( db, "%s-mj%08X", zMainFile, iRandom & 0x7fffffff );\n          //if (!zMaster)\n          //{\n          //  return SQLITE_NOMEM;\n          //}\n          rc = sqlite3OsAccess( pVfs, zMaster, SQLITE_ACCESS_EXISTS, ref res );\n        } while ( rc == SQLITE_OK && res == 1 );\n        if ( rc == SQLITE_OK )\n        {\n          /* Open the master journal. */\n          rc = sqlite3OsOpenMalloc( ref pVfs, zMaster, ref pMaster,\n          SQLITE_OPEN_READWRITE | SQLITE_OPEN_CREATE |\n          SQLITE_OPEN_EXCLUSIVE | SQLITE_OPEN_MASTER_JOURNAL, ref rc\n          );\n        } if ( rc != SQLITE_OK )\n        {\n          //sqlite3DbFree( db, ref zMaster );\n          return rc;\n        }\n\n        /* Write the name of each database file in the transaction into the new\n        ** master journal file. If an error occurs at this point close\n        ** and delete the master journal file. All the individual journal files\n        ** still have \'null\' as the master journal pointer, so they will roll\n        ** back independently if a failure occurs.\n        */\n        for ( i = 0 ; i < db.nDb ; i++ )\n        {\n          Btree pBt = db.aDb[i].pBt;\n          if ( i == 1 ) continue;   /* Ignore the TEMP database */\n          if ( sqlite3BtreeIsInTrans( pBt ) )\n          {\n            string zFile = sqlite3BtreeGetJournalname( pBt );\n            if ( zFile[0] == 0 ) continue;  /* Ignore :memory: databases */\n            if ( !needSync && 0 == sqlite3BtreeSyncDisabled( pBt ) )\n            {\n              needSync = true;\n            }\n            rc = sqlite3OsWrite( pMaster, Encoding.UTF8.GetBytes( zFile ), sqlite3Strlen30( zFile ), offset );\n            offset += sqlite3Strlen30( zFile );\n            if ( rc != SQLITE_OK )\n            {\n              sqlite3OsCloseFree( pMaster );\n              sqlite3OsDelete( pVfs, zMaster, 0 );\n              //sqlite3DbFree( db, ref zMaster );\n              return rc;\n            }\n          }\n        }\n\n        /* Sync the master journal file. If the IOCAP_SEQUENTIAL device\n        ** flag is set this is not required.\n        */\n        if ( needSync\n        && 0 == ( sqlite3OsDeviceCharacteristics( pMaster ) & SQLITE_IOCAP_SEQUENTIAL )\n        && SQLITE_OK != ( rc = sqlite3OsSync( pMaster, SQLITE_SYNC_NORMAL ) )\n        )\n        {\n          sqlite3OsCloseFree( pMaster );\n          sqlite3OsDelete( pVfs, zMaster, 0 );\n          //sqlite3DbFree( db, ref zMaster );\n          return rc;\n        }\n\n        /* Sync all the db files involved in the transaction. The same call\n        ** sets the master journal pointer in each individual journal. If\n        ** an error occurs here, do not delete the master journal file.\n        **\n        ** If the error occurs during the first call to\n        ** sqlite3BtreeCommitPhaseOne(), then there is a chance that the\n        ** master journal file will be orphaned. But we cannot delete it,\n        ** in case the master journal file name was written into the journal\n        ** file before the failure occurred.\n        */\n        for ( i = 0 ; rc == SQLITE_OK && i < db.nDb ; i++ )\n        {\n          Btree pBt = db.aDb[i].pBt;\n          if ( pBt != null )\n          {\n            rc = sqlite3BtreeCommitPhaseOne( pBt, zMaster );\n          }\n        }\n        sqlite3OsCloseFree( pMaster );\n        if ( rc != SQLITE_OK )\n        {\n          //sqlite3DbFree( db, ref zMaster );\n          return rc;\n        }\n\n        /* Delete the master journal file. This commits the transaction. After\n        ** doing this the directory is synced again before any individual\n        ** transaction files are deleted.\n        */\n        rc = sqlite3OsDelete( pVfs, zMaster, 1 );\n        //sqlite3DbFree( db, ref zMaster );\n        if ( rc != 0 )\n        {\n          return rc;\n        }\n\n        /* All files and directories have already been synced, so the following\n        ** calls to sqlite3BtreeCommitPhaseTwo() are only closing files and\n        ** deleting or truncating journals. If something goes wrong while\n        ** this is happening we don\'t really care. The integrity of the\n        ** transaction is already guaranteed, but some stray \'cold\' journals\n        ** may be lying around. Returning an error code won\'t help matters.\n        */\n#if SQLITE_TEST\n        disable_simulated_io_errors();\n#endif\n        sqlite3BeginBenignMalloc();\n        for ( i = 0 ; i < db.nDb ; i++ )\n        {\n          Btree pBt = db.aDb[i].pBt;\n          if ( pBt != null )\n          {\n            sqlite3BtreeCommitPhaseTwo( pBt );\n          }\n        }\n        sqlite3EndBenignMalloc();\n#if SQLITE_TEST\n        enable_simulated_io_errors();\n#endif\n        sqlite3VtabCommit( db );\n      }\n#endif\n\n      return rc;\n    }\n\n    /*\n    ** This routine checks that the sqlite3.activeVdbeCnt count variable\n    ** matches the number of vdbe\'s in the list sqlite3.pVdbe that are\n    ** currently active. An Debug.Assertion fails if the two counts do not match.\n    ** This is an internal self-check only - it is not an essential processing\n    ** step.\n    **\n    ** This is a no-op if NDEBUG is defined.\n    */\n#if !NDEBUG\n    static void checkActiveVdbeCnt( sqlite3 db )\n    {\n      Vdbe p;\n      int cnt = 0;\n      int nWrite = 0;\n      p = db.pVdbe;\n      while ( p != null )\n      {\n        if ( p.magic == VDBE_MAGIC_RUN && p.pc >= 0 )\n        {\n          cnt++;\n          if ( p.readOnly == false ) nWrite++;\n        }\n        p = p.pNext;\n      }\n      Debug.Assert( cnt == db.activeVdbeCnt );\n      Debug.Assert( nWrite == db.writeVdbeCnt );\n    }\n#else\n//#define checkActiveVdbeCnt(x)\nstatic void checkActiveVdbeCnt( sqlite3 db ){}\n#endif\n\n    /*\n** For every Btree that in database connection db which\n** has been modified, "trip" or invalidate each cursor in\n** that Btree might have been modified so that the cursor\n** can never be used again.  This happens when a rollback\n*** occurs.  We have to trip all the other cursors, even\n** cursor from other VMs in different database connections,\n** so that none of them try to use the data at which they\n** were pointing and which now may have been changed due\n** to the rollback.\n**\n** Remember that a rollback can delete tables complete and\n** reorder rootpages.  So it is not sufficient just to save\n** the state of the cursor.  We have to invalidate the cursor\n** so that it is never used again.\n*/\n    static void invalidateCursorsOnModifiedBtrees( sqlite3 db )\n    {\n      int i;\n      for ( i = 0 ; i < db.nDb ; i++ )\n      {\n        Btree p = db.aDb[i].pBt;\n        if ( p != null && sqlite3BtreeIsInTrans( p ) )\n        {\n          sqlite3BtreeTripAllCursors( p, SQLITE_ABORT );\n        }\n      }\n    }\n\n    /*\n    ** If the Vdbe passed as the first argument opened a statement-transaction,\n    ** close it now. Argument eOp must be either SAVEPOINT_ROLLBACK or\n    ** SAVEPOINT_RELEASE. If it is SAVEPOINT_ROLLBACK, then the statement\n    ** transaction is rolled back. If eOp is SAVEPOINT_RELEASE, then the\n    ** statement transaction is commtted.\n    **\n    ** If an IO error occurs, an SQLITE_IOERR_XXX error code is returned.\n    ** Otherwise SQLITE_OK.\n    */\n    static int sqlite3VdbeCloseStatement( Vdbe p, int eOp )\n    {\n      sqlite3 db = p.db;\n      int rc = SQLITE_OK;\n        /* If p->iStatement is greater than zero, then this Vdbe opened a \n        ** statement transaction that should be closed here. The only exception\n        ** is that an IO error may have occured, causing an emergency rollback.\n        ** In this case (db->nStatement==0), and there is nothing to do.\n        */\n        if ( db.nStatement !=0 && p.iStatement!=0 )\n        {\n          int i;\n        int iSavepoint = p.iStatement - 1;\n\n        Debug.Assert( eOp == SAVEPOINT_ROLLBACK || eOp == SAVEPOINT_RELEASE );\n        Debug.Assert( db.nStatement > 0 );\n        Debug.Assert( p.iStatement == ( db.nStatement + db.nSavepoint ) );\n\n        for ( i = 0 ; i < db.nDb ; i++ )\n        {\n          int rc2 = SQLITE_OK;\n          Btree pBt = db.aDb[i].pBt;\n          if ( pBt != null )\n          {\n            if ( eOp == SAVEPOINT_ROLLBACK )\n            {\n              rc2 = sqlite3BtreeSavepoint( pBt, SAVEPOINT_ROLLBACK, iSavepoint );\n            }\n            if ( rc2 == SQLITE_OK )\n            {\n              rc2 = sqlite3BtreeSavepoint( pBt, SAVEPOINT_RELEASE, iSavepoint );\n            }\n            if ( rc == SQLITE_OK )\n            {\n              rc = rc2;\n            }\n          }\n        }\n        db.nStatement--;\n        p.iStatement = 0;\n      }\n      return rc;\n    }\n\n    /*\n    ** If SQLite is compiled to support shared-cache mode and to be threadsafe,\n    ** this routine obtains the mutex associated with each BtShared structure\n    ** that may be accessed by the VM passed as an argument. In doing so it\n    ** sets the BtShared.db member of each of the BtShared structures, ensuring\n    ** that the correct busy-handler callback is invoked if required.\n    **\n    ** If SQLite is not threadsafe but does support shared-cache mode, then\n    ** sqlite3BtreeEnterAll() is invoked to set the BtShared.db variables\n    ** of all of BtShared structures accessible via the database handle\n    ** associated with the VM. Of course only a subset of these structures\n    ** will be accessed by the VM, and we could use Vdbe.btreeMask to figure\n    ** that subset out, but there is no advantage to doing so.\n    **\n    ** If SQLite is not threadsafe and does not support shared-cache mode, this\n    ** function is a no-op.\n    */\n#if !SQLITE_OMIT_SHARED_CACHE\nstatic void sqlite3VdbeMutexArrayEnter(Vdbe p){\n#if SQLITE_THREADSAFE\nsqlite3BtreeMutexArrayEnter(&p->aMutex);\n#else\nsqlite3BtreeEnterAll(p.db);\n#endif\n}\n#endif\n\n\n    /*\n** This routine is called the when a VDBE tries to halt.  If the VDBE\n** has made changes and is in autocommit mode, then commit those\n** changes.  If a rollback is needed, then do the rollback.\n**\n** This routine is the only way to move the state of a VM from\n** SQLITE_MAGIC_RUN to SQLITE_MAGIC_HALT.  It is harmless to\n** call this on a VM that is in the SQLITE_MAGIC_HALT state.\n**\n** Return an error code.  If the commit could not complete because of\n** lock contention, return SQLITE_BUSY.  If SQLITE_BUSY is returned, it\n** means the close did not happen and needs to be repeated.\n*/\n    static int sqlite3VdbeHalt( Vdbe p )\n    {\n      int rc;                         /* Used to store transient return codes */\n      sqlite3 db = p.db;\n\n      /* This function contains the logic that determines if a statement or\n      ** transaction will be committed or rolled back as a result of the\n      ** execution of this virtual machine.\n      **\n      ** If any of the following errors occur:\n      **\n      **     SQLITE_NOMEM\n      **     SQLITE_IOERR\n      **     SQLITE_FULL\n      **     SQLITE_INTERRUPT\n      **\n      ** Then the internal cache might have been left in an inconsistent\n      ** state.  We need to rollback the statement transaction, if there is\n      ** one, or the complete transaction if there is no statement transaction.\n      */\n\n      //if ( p.db.mallocFailed != 0 )\n      //{\n      //  p.rc = SQLITE_NOMEM;\n      //}\n      closeAllCursors( p );\n      if ( p.magic != VDBE_MAGIC_RUN )\n      {\n        return SQLITE_OK;\n      }\n      checkActiveVdbeCnt( db );\n\n      /* No commit or rollback needed if the program never started */\n      if ( p.pc >= 0 )\n      {\n        int mrc;   /* Primary error code from p.rc */\n        int eStatementOp = 0;\n        bool isSpecialError = false;            /* Set to true if a \'special\' error */\n\n        /* Lock all btrees used by the statement */\n        sqlite3VdbeMutexArrayEnter( p );\n        /* Check for one of the special errors */\n        mrc = p.rc & 0xff;\n        Debug.Assert( p.rc != SQLITE_IOERR_BLOCKED );  /* This error no longer exists */\n        isSpecialError = mrc == SQLITE_NOMEM || mrc == SQLITE_IOERR\n        || mrc == SQLITE_INTERRUPT || mrc == SQLITE_FULL;\n        if ( isSpecialError )\n        {\n          /* If the query was read-only, we need do no rollback at all. Otherwise,\n          ** proceed with the special handling.\n          */\n          if ( !p.readOnly || mrc != SQLITE_INTERRUPT )\n          {\n            if ( ( mrc == SQLITE_NOMEM || mrc == SQLITE_FULL ) && p.usesStmtJournal )\n            {\n              eStatementOp = SAVEPOINT_ROLLBACK;\n            }\n            else\n            {\n              /* We are forced to roll back the active transaction. Before doing\n              ** so, abort any other statements this handle currently has active.\n              */\n              invalidateCursorsOnModifiedBtrees( db );\n              sqlite3RollbackAll( db );\n              sqlite3CloseSavepoints( db );\n              db.autoCommit = 1;\n            }\n          }\n        }\n\n        /* If the auto-commit flag is set and this is the only active writer\n        ** VM, then we do either a commit or rollback of the current transaction.\n        **\n        ** Note: This block also runs if one of the special errors handled\n        ** above has occurred.\n        */\n        if ( !sqlite3VtabInSync( db )\n        && db.autoCommit != 0\n        && db.writeVdbeCnt == ( ( p.readOnly == false ) ? 1 : 0 )\n        )\n        {\n          if ( p.rc == SQLITE_OK || ( p.errorAction == OE_Fail && !isSpecialError ) )\n          {\n            /* The auto-commit flag is true, and the vdbe program was\n            ** successful or hit an \'OR FAIL\' constraint. This means a commit\n            ** is required.\n            */\n            rc = vdbeCommit( db, p );\n            if ( rc == SQLITE_BUSY )\n            {\n              sqlite3BtreeMutexArrayLeave( p.aMutex );\n              return SQLITE_BUSY;\n            }\n            else if ( rc != SQLITE_OK )\n            {\n              p.rc = rc;\n              sqlite3RollbackAll( db );\n            }\n            else\n            {\n              sqlite3CommitInternalChanges( db );\n            }\n          }\n          else\n          {\n            sqlite3RollbackAll( db );\n          }\n          db.nStatement = 0;\n        }\n        else if ( eStatementOp == 0 )\n        {\n          if ( p.rc == SQLITE_OK || p.errorAction == OE_Fail )\n          {\n            eStatementOp = SAVEPOINT_RELEASE;\n          }\n          else if ( p.errorAction == OE_Abort )\n          {\n            eStatementOp = SAVEPOINT_ROLLBACK;\n          }\n          else\n          {\n            invalidateCursorsOnModifiedBtrees( db );\n            sqlite3RollbackAll( db );\n            sqlite3CloseSavepoints( db );\n            db.autoCommit = 1;\n          }\n        }\n\n        /* If eStatementOp is non-zero, then a statement transaction needs to\n        ** be committed or rolled back. Call sqlite3VdbeCloseStatement() to\n        ** do so. If this operation returns an error, and the current statement\n        ** error code is SQLITE_OK or SQLITE_CONSTRAINT, then set the error\n        ** code to the new value.\n        */\n        if ( eStatementOp != 0 )\n        {\n          rc = sqlite3VdbeCloseStatement( p, eStatementOp );\n          if ( rc != 0 && ( p.rc == SQLITE_OK || p.rc == SQLITE_CONSTRAINT ) )\n          {\n            p.rc = rc;\n            //sqlite3DbFree(db, p.zErrMsg );\n            p.zErrMsg = null;\n          }\n        }\n\n        /* If this was an INSERT, UPDATE or DELETE and no statement transaction\n        ** has been rolled back, update the database connection change-counter.\n        */\n        if ( p.changeCntOn)\n        {\n          if ( eStatementOp != SAVEPOINT_ROLLBACK )\n          {\n            sqlite3VdbeSetChanges( db, p.nChange );\n          }\n          else\n          {\n            sqlite3VdbeSetChanges( db, 0 );\n          }\n          p.nChange = 0;\n        }\n\n        /* Rollback or commit any schema changes that occurred. */\n        if ( p.rc != SQLITE_OK && ( db.flags & SQLITE_InternChanges ) != 0 )\n        {\n          sqlite3ResetInternalSchema( db, 0 );\n          db.flags = ( db.flags | SQLITE_InternChanges );\n        }\n\n        /* Release the locks */\n        sqlite3BtreeMutexArrayLeave( p.aMutex );\n      }\n\n      /* We have successfully halted and closed the VM.  Record this fact. */\n      if ( p.pc >= 0 )\n      {\n        db.activeVdbeCnt--;\n        if ( !p.readOnly )\n        {\n          db.writeVdbeCnt--;\n        }\n        Debug.Assert( db.activeVdbeCnt >= db.writeVdbeCnt );\n      }\n      p.magic = VDBE_MAGIC_HALT;\n      checkActiveVdbeCnt( db );\n      //if ( p.db.mallocFailed != 0 )\n      //{\n      //  p.rc = SQLITE_NOMEM;\n      //}\n      /* If the auto-commit flag is set to true, then any locks that were held\n      ** by connection db have now been released. Call sqlite3ConnectionUnlocked()\n      ** to invoke any required unlock-notify callbacks.\n      */\n      if ( db.autoCommit != 0 )\n      {\n        sqlite3ConnectionUnlocked( db );\n      }\n\n      Debug.Assert( db.activeVdbeCnt > 0 || db.autoCommit == 0 || db.nStatement == 0 );\n      return SQLITE_OK;\n    }\n\n\n    /*\n    ** Each VDBE holds the result of the most recent sqlite3_step() call\n    ** in p.rc.  This routine sets that result back to SQLITE_OK.\n    */\n    static void sqlite3VdbeResetStepResult( Vdbe p )\n    {\n      p.rc = SQLITE_OK;\n    }\n\n    /*\n    ** Clean up a VDBE after execution but do not delete the VDBE just yet.\n    ** Write any error messages into pzErrMsg.  Return the result code.\n    **\n    ** After this routine is run, the VDBE should be ready to be executed\n    ** again.\n    **\n    ** To look at it another way, this routine resets the state of the\n    ** virtual machine from VDBE_MAGIC_RUN or VDBE_MAGIC_HALT back to\n    ** VDBE_MAGIC_INIT.\n    */\n    static int sqlite3VdbeReset( Vdbe p )\n    {\n      sqlite3 db;\n      db = p.db;\n\n      /* If the VM did not run to completion or if it encountered an\n      ** error, then it might not have been halted properly.  So halt\n      ** it now.\n      */\n      sqlite3SafetyOn( db );\n      sqlite3VdbeHalt( p );\n      sqlite3SafetyOff( db );\n\n      /* If the VDBE has be run even partially, then transfer the error code\n      ** and error message from the VDBE into the main database structure.  But\n      ** if the VDBE has just been set to run but has not actually executed any\n      ** instructions yet, leave the main database error information unchanged.\n      */\n      if ( p.pc >= 0 )\n      {\n        //if ( p.zErrMsg != 0 ) // Always exists under C#\n        {\n          sqlite3BeginBenignMalloc();\n          sqlite3ValueSetStr( db.pErr, -1, p.zErrMsg == null ? "" : p.zErrMsg, SQLITE_UTF8, SQLITE_TRANSIENT );\n          sqlite3EndBenignMalloc();\n          db.errCode = p.rc;\n          //sqlite3DbFree( db, ref p.zErrMsg );\n          p.zErrMsg = "";\n        }\n        //else if ( p.rc != 0 )\n        //{\n        //  sqlite3Error( db, p.rc, 0 );\n        //}\n        //else\n        //{\n        //  sqlite3Error( db, SQLITE_OK, 0 );\n        //}\n      }\n      else if ( p.rc != 0 && p.expired )\n      {\n        /* The expired flag was set on the VDBE before the first call\n        ** to sqlite3_step(). For consistency (since sqlite3_step() was\n        ** called), set the database error in this case as well.\n        */\n        sqlite3Error( db, p.rc, 0 );\n        sqlite3ValueSetStr( db.pErr, -1, p.zErrMsg, SQLITE_UTF8, SQLITE_TRANSIENT );\n        //sqlite3DbFree( db, ref p.zErrMsg );\n        p.zErrMsg = "";\n      }\n\n      /* Reclaim all memory used by the VDBE\n      */\n      Cleanup( p );\n\n      /* Save profiling information from this VDBE run.\n      */\n#if  VDBE_PROFILE && TODO\n{\nFILE *out = fopen("vdbe_profile.out", "a");\nif( out ){\nint i;\nfprintf(out, "---- ");\nfor(i=0; i<p.nOp; i++){\nfprintf(out, "%02x", p.aOp[i].opcode);\n}\nfprintf(out, "\\n");\nfor(i=0; i<p.nOp; i++){\nfprintf(out, "%6d %10lld %8lld ",\np.aOp[i].cnt,\np.aOp[i].cycles,\np.aOp[i].cnt>0 ? p.aOp[i].cycles/p.aOp[i].cnt : 0\n);\nsqlite3VdbePrintOp(out, i, p.aOp[i]);\n}\nfclose(out);\n}\n}\n#endif\n      p.magic = VDBE_MAGIC_INIT;\n      return p.rc & db.errMask;\n    }\n\n    /*\n    ** Clean up and delete a VDBE after execution.  Return an integer which is\n    ** the result code.  Write any error message text into pzErrMsg.\n    */\n    static int sqlite3VdbeFinalize( Vdbe p )\n    {\n      int rc = SQLITE_OK;\n      if ( p.magic == VDBE_MAGIC_RUN || p.magic == VDBE_MAGIC_HALT )\n      {\n        rc = sqlite3VdbeReset( p );\n        Debug.Assert( ( rc & p.db.errMask ) == rc );\n      }\n      sqlite3VdbeDelete( ref p );\n      return rc;\n    }\n\n    /*\n    ** Call the destructor for each auxdata entry in pVdbeFunc for which\n    ** the corresponding bit in mask is clear.  Auxdata entries beyond 31\n    ** are always destroyed.  To destroy all auxdata entries, call this\n    ** routine with mask==0.\n    */\n    static void sqlite3VdbeDeleteAuxData( VdbeFunc pVdbeFunc, int mask )\n    {\n      int i;\n      for ( i = 0 ; i < pVdbeFunc.nAux ; i++ )\n      {\n        AuxData pAux = pVdbeFunc.apAux[i];\n        if ( ( i > 31 || ( mask & ( ( (u32)1 ) << i ) ) == 0 && pAux.pAux != null ) )\n        {\n          if ( pAux.xDelete != null )\n          {\n            pAux.xDelete( ref pAux.pAux );\n          }\n          pAux.pAux = null;\n        }\n      }\n    }\n\n    /*\n    ** Delete an entire VDBE.\n    */\n    static void sqlite3VdbeDelete( ref Vdbe p )\n    {\n      int i;\n      sqlite3 db;\n      if (NEVER( p == null )) return;\n      Cleanup( p );\n      db = p.db;\n      if ( p.pPrev != null )\n      {\n        p.pPrev.pNext = p.pNext;\n      }\n      else\n      {\n        Debug.Assert( db.pVdbe == p );\n        db.pVdbe = p.pNext;\n      }\n      if ( p.pNext != null )\n      {\n        p.pNext.pPrev = p.pPrev;\n      }\n      if ( p.aOp != null )\n      {\n        Op pOp;\n        for ( i = 0 ; i < p.nOp ; i++ )//pOp++)\n        {\n          pOp = p.aOp[i];\n          freeP4( db, pOp.p4type, pOp.p4type == P4_VDBEFUNC ? pOp.p4.pVdbeFunc : pOp.p4.pFunc );\n#if  SQLITE_DEBUG\n          //sqlite3DbFree( db, ref pOp.zComment );\n#endif\n        }\n      }\n      releaseMemArray( p.aVar, p.nVar );\n      //sqlite3DbFree( db, ref p.aLabel );\n      releaseMemArray( p.aColName, p.nResColumn * COLNAME_N );\n      //sqlite3DbFree( db, ref p.aColName );\n      //sqlite3DbFree( db, ref p.zSql );\n      p.magic = VDBE_MAGIC_DEAD;\n      //sqlite3DbFree( db, ref p.aOp );\n      //sqlite3DbFree( db, ref  p.pFree );\n      //sqlite3DbFree( db, ref  p );\n    }\n\n    /*\n    ** Make sure the cursor p is ready to read or write the row to which it\n    ** was last positioned.  Return an error code if an OOM fault or I/O error\n    ** prevents us from positioning the cursor to its correct position.\n    **\n    ** If a MoveTo operation is pending on the given cursor, then do that\n    ** MoveTo now.  If no move is pending, check to see if the row has been\n    ** deleted out from under the cursor and if it has, mark the row as\n    ** a NULL row.\n    **\n    ** If the cursor is already pointing to the correct row and that row has\n    ** not been deleted out from under the cursor, then this routine is a no-op.\n    */\n    static int sqlite3VdbeCursorMoveto( VdbeCursor p )\n    {\n      if ( p.deferredMoveto )\n      {\n        int res = 0; int rc;\n#if  SQLITE_TEST\n        //extern int sqlite3_search_count;\n#endif\n        Debug.Assert( p.isTable );\n        rc = sqlite3BtreeMovetoUnpacked( p.pCursor, null, p.movetoTarget, 0, ref res );\n        if ( rc != 0 ) return rc;\n        p.lastRowid = p.movetoTarget;\n        p.rowidIsValid = ALWAYS( res == 0 ) ? true : false;\n        if ( NEVER( res < 0 ) )\n        {\n          rc = sqlite3BtreeNext( p.pCursor, ref res );\n          if ( rc != 0 ) return rc;\n        }\n#if  SQLITE_TEST\n        sqlite3_search_count.iValue++;\n#endif\n        p.deferredMoveto = false;\n        p.cacheStatus = CACHE_STALE;\n      }\n      else if (ALWAYS( p.pCursor != null ))\n      {\n        int hasMoved = 0;\n        int rc = sqlite3BtreeCursorHasMoved( p.pCursor, ref hasMoved );\n        if ( rc != 0 ) return rc;\n        if ( hasMoved != 0 )\n        {\n          p.cacheStatus = CACHE_STALE;\n          p.nullRow = true;\n        }\n      }\n      return SQLITE_OK;\n    }\n\n    /*\n    ** The following functions:\n    **\n    ** sqlite3VdbeSerialType()\n    ** sqlite3VdbeSerialTypeLen()\n    ** sqlite3VdbeSerialLen()\n    ** sqlite3VdbeSerialPut()\n    ** sqlite3VdbeSerialGet()\n    **\n    ** encapsulate the code that serializes values for storage in SQLite\n    ** data and index records. Each serialized value consists of a\n    ** \'serial-type\' and a blob of data. The serial type is an 8-byte unsigned\n    ** integer, stored as a varint.\n    **\n    ** In an SQLite index record, the serial type is stored directly before\n    ** the blob of data that it corresponds to. In a table record, all serial\n    ** types are stored at the start of the record, and the blobs of data at\n    ** the end. Hence these functions allow the caller to handle the\n    ** serial-type and data blob seperately.\n    **\n    ** The following table describes the various storage classes for data:\n    **\n    **   serial type        bytes of data      type\n    **   --------------     ---------------    ---------------\n    **      0                     0            NULL\n    **      1                     1            signed integer\n    **      2                     2            signed integer\n    **      3                     3            signed integer\n    **      4                     4            signed integer\n    **      5                     6            signed integer\n    **      6                     8            signed integer\n    **      7                     8            IEEE float\n    **      8                     0            Integer constant 0\n    **      9                     0            Integer constant 1\n    **     10,11                               reserved for expansion\n    **    N>=12 and even       (N-12)/2        BLOB\n    **    N>=13 and odd        (N-13)/2        text\n    **\n    ** The 8 and 9 types were added in 3.3.0, file format 4.  Prior versions\n    ** of SQLite will not understand those serial types.\n    */\n\n    /*\n    ** Return the serial-type for the value stored in pMem.\n    */\n    static u32 sqlite3VdbeSerialType( Mem pMem, int file_format )\n    {\n      int flags = pMem.flags;\n      int n;\n\n      if ( ( flags & MEM_Null ) != 0 )\n      {\n        return 0;\n      }\n      if ( ( flags & MEM_Int ) != 0 )\n      {\n        /* Figure out whether to use 1, 2, 4, 6 or 8 bytes. */\n        const i64 MAX_6BYTE = ( ( ( (i64)0x00008000 ) << 32 ) - 1 );\n        i64 i = pMem.u.i;\n        u64 u;\n        if ( file_format >= 4 && ( i & 1 ) == i )\n        {\n          return 8 + (u32)i;\n        }\n        u = (ulong)( i < 0 ? -i : i );\n        if ( u <= 127 ) return 1;\n        if ( u <= 32767 ) return 2;\n        if ( u <= 8388607 ) return 3;\n        if ( u <= 2147483647 ) return 4;\n        if ( u <= MAX_6BYTE ) return 5;\n        return 6;\n      }\n      if ( ( flags & MEM_Real ) != 0 )\n      {\n        return 7;\n      }\n      Debug.Assert( /* pMem.db.mallocFailed != 0 || */ ( flags & ( MEM_Str | MEM_Blob ) ) != 0 );\n      n = pMem.n;\n      if ((flags & MEM_Zero)!=0)\n      {\n        n += pMem.u.nZero;\n      }\n      else if ((flags & MEM_Blob) != 0)\n      {\n        n = pMem.zBLOB != null ? pMem.zBLOB.Length : pMem.z != null ? pMem.z.Length : 0;\n      }\n      else\n      {\n        if (pMem.z != null) n = Encoding.UTF8.GetByteCount(pMem.n < pMem.z.Length ? pMem.z.Substring(0, pMem.n) : pMem.z);\n        else n = pMem.zBLOB.Length;\n        pMem.n = n;\n      }\n\n      Debug.Assert( n >= 0 );\n      return (u32)( ( n * 2 ) + 12 + ( ( ( flags & MEM_Str ) != 0 ) ? 1 : 0 ) );\n    }\n\n    /*\n    ** Return the length of the data corresponding to the supplied serial-type.\n    */\n    static u32 sqlite3VdbeSerialTypeLen( u32 serial_type )\n    {\n      if ( serial_type >= 12 )\n      {\n        return (u32)( ( serial_type - 12 ) / 2 );\n      }\n      else\n      {\n        u32[] aSize = new u32[] { 0, 1, 2, 3, 4, 6, 8, 8, 0, 0, 0, 0 };\n        return aSize[serial_type];\n      }\n    }\n\n    /*\n    ** If we are on an architecture with mixed-endian floating\n    ** points (ex: ARM7) then swap the lower 4 bytes with the\n    ** upper 4 bytes.  Return the result.\n    **\n    ** For most architectures, this is a no-op.\n    **\n    ** (later):  It is reported to me that the mixed-endian problem\n    ** on ARM7 is an issue with GCC, not with the ARM7 chip.  It seems\n    ** that early versions of GCC stored the two words of a 64-bit\n    ** float in the wrong order.  And that error has been propagated\n    ** ever since.  The blame is not necessarily with GCC, though.\n    ** GCC might have just copying the problem from a prior compiler.\n    ** I am also told that newer versions of GCC that follow a different\n    ** ABI get the byte order right.\n    **\n    ** Developers using SQLite on an ARM7 should compile and run their\n    ** application using -DSQLITE_DEBUG=1 at least once.  With DEBUG\n    ** enabled, some Debug.Asserts below will ensure that the byte order of\n    ** floating point values is correct.\n    **\n    ** (2007-08-30)  Frank van Vugt has studied this problem closely\n    ** and has send his findings to the SQLite developers.  Frank\n    ** writes that some Linux kernels offer floating point hardware\n    ** emulation that uses only 32-bit mantissas instead of a full\n    ** 48-bits as required by the IEEE standard.  (This is the\n    ** CONFIG_FPE_FASTFPE option.)  On such systems, floating point\n    ** byte swapping becomes very complicated.  To avoid problems,\n    ** the necessary byte swapping is carried out using a 64-bit integer\n    ** rather than a 64-bit float.  Frank assures us that the code here\n    ** works for him.  We, the developers, have no way to independently\n    ** verify this, but Frank seems to know what he is talking about\n    ** so we trust him.\n    */\n#if  SQLITE_MIXED_ENDIAN_64BIT_FLOAT\n//static u64 floatSwap(u64 in){\n//  union {\n//    u64 r;\n//    u32 i[2];\n//  } u;\n//  u32 t;\n\n//  u.r = in;\n//  t = u.i[0];\n//  u.i[0] = u.i[1];\n//  u.i[1] = t;\n//  return u.r;\n//}\n//# define swapMixedEndianFloat(X)  X = floatSwap(X)\n#else\n    //# define swapMixedEndianFloat(X)\n#endif\n\n    /*\n** Write the serialized data blob for the value stored in pMem into\n** buf. It is assumed that the caller has allocated sufficient space.\n** Return the number of bytes written.\n**\n** nBuf is the amount of space left in buf[].  nBuf must always be\n** large enough to hold the entire field.  Except, if the field is\n** a blob with a zero-filled tail, then buf[] might be just the right\n** size to hold everything except for the zero-filled tail.  If buf[]\n** is only big enough to hold the non-zero prefix, then only write that\n** prefix into buf[].  But if buf[] is large enough to hold both the\n** prefix and the tail then write the prefix and set the tail to all\n** zeros.\n**\n** Return the number of bytes actually written into buf[].  The number\n** of bytes in the zero-filled tail is included in the return value only\n** if those bytes were zeroed in buf[].\n*/\n    static u32 sqlite3VdbeSerialPut( byte[] buf, int offset, int nBuf, Mem pMem, int file_format )\n    {\n      u32 serial_type = sqlite3VdbeSerialType( pMem, file_format );\n      u32 len;\n\n      /* Integer and Real */\n      if ( serial_type <= 7 && serial_type > 0 )\n      {\n        u64 v;\n        u32 i;\n        if ( serial_type == 7 )\n        {\n          //Debug.Assert( sizeof( v) == sizeof(pMem.r));\n          v = (ulong)BitConverter.DoubleToInt64Bits( pMem.r );// memcpy( &v, pMem.r, v ).Length;\n#if  SQLITE_MIXED_ENDIAN_64BIT_FLOAT\nswapMixedEndianFloat( v );\n#endif\n        }\n        else\n        {\n          v = (ulong)pMem.u.i;\n        }\n        len = i = sqlite3VdbeSerialTypeLen( serial_type );\n        Debug.Assert( len <= (u32)nBuf );\n        while ( i-- != 0 )\n        {\n          buf[offset + i] = (u8)( v & 0xFF );\n          v >>= 8;\n        }\n        return len;\n      }\n\n      /* String or blob */\n      if ( serial_type >= 12 )\n      {\n        Debug.Assert( pMem.n + ( ( pMem.flags & MEM_Zero ) != 0 ? pMem.u.nZero : 0 ) == (int)sqlite3VdbeSerialTypeLen( serial_type ) );\n        Debug.Assert( pMem.n <= nBuf );\n        if ( ( len = (u32)pMem.n ) != 0 )\n          if (pMem.zBLOB==null && String.IsNullOrEmpty(pMem.z)) \n          {}\n        else if ( ( pMem.flags & MEM_Blob ) != 0 || pMem.z == null )\n            Buffer.BlockCopy( pMem.zBLOB, 0, buf, offset, (int)len );//memcpy( buf, pMem.z, len );\n          else\n            Buffer.BlockCopy( Encoding.UTF8.GetBytes( pMem.z ), 0, buf, offset, (int)len );//memcpy( buf, pMem.z, len );\n        if ( ( pMem.flags & MEM_Zero ) != 0 )\n        {\n          len += (u32)pMem.u.nZero;\n          Debug.Assert( nBuf >= 0 );\n          if ( len > (u32)nBuf )\n          {\n            len = (u32)nBuf;\n          }\n          Array.Clear( buf, offset + pMem.n, (int)( len - pMem.n ) );// memset( &buf[pMem.n], 0, len - pMem.n );\n        }\n        return len;\n      }\n\n      /* NULL or constants 0 or 1 */\n      return 0;\n    }\n\n    /*\n    ** Deserialize the data blob pointed to by buf as serial type serial_type\n    ** and store the result in pMem.  Return the number of bytes read.\n    */\n    static u32 sqlite3VdbeSerialGet(\n    byte[] buf,         /* Buffer to deserialize from */\n    int offset,         /* Offset into Buffer */\n    u32 serial_type,    /* Serial type to deserialize */\n    Mem pMem            /* Memory cell to write value into */\n    )\n    {\n      switch ( serial_type )\n      {\n        case 10:   /* Reserved for future use */\n        case 11:   /* Reserved for future use */\n        case 0:\n          {  /* NULL */\n            pMem.flags = MEM_Null;\n            pMem.n = 0;\n            pMem.z = null;\n            pMem.zBLOB = null;\n            break;\n          }\n        case 1:\n          { /* 1-byte signed integer */\n            pMem.u.i = (sbyte)buf[offset + 0];\n            pMem.flags = MEM_Int;\n            return 1;\n          }\n        case 2:\n          { /* 2-byte signed integer */\n            pMem.u.i = (int)( ( ( (sbyte)buf[offset + 0] ) << 8 ) | buf[offset + 1] );\n            pMem.flags = MEM_Int;\n            return 2;\n          }\n        case 3:\n          { /* 3-byte signed integer */\n            pMem.u.i = (int)( ( ( (sbyte)buf[offset + 0] ) << 16 ) | ( buf[offset + 1] << 8 ) | buf[offset + 2] );\n            pMem.flags = MEM_Int;\n            return 3;\n          }\n        case 4:\n          { /* 4-byte signed integer */\n            pMem.u.i = (int)( ( (sbyte)buf[offset + 0] << 24 ) | ( buf[offset + 1] << 16 ) | ( buf[offset + 2] << 8 ) | buf[offset + 3] );\n            pMem.flags = MEM_Int;\n            return 4;\n          }\n        case 5:\n          { /* 6-byte signed integer */\n            u64 x = (ulong)( ( ( (sbyte)buf[offset + 0] ) << 8 ) | buf[offset + 1] );\n            u32 y = (u32)( ( buf[offset + 2] << 24 ) | ( buf[offset + 3] << 16 ) | ( buf[offset + 4] << 8 ) | buf[offset + 5] );\n            x = ( x << 32 ) | y;\n            pMem.u.i = (i64)x;\n            pMem.flags = MEM_Int;\n            return 6;\n          }\n        case 6:   /* 8-byte signed integer */\n        case 7:\n          { /* IEEE floating point */\n            u64 x;\n            u32 y;\n#if !NDEBUG && !SQLITE_OMIT_FLOATING_POINT\n            /* Verify that integers and floating point values use the same\n** byte order.  Or, that if SQLITE_MIXED_ENDIAN_64BIT_FLOAT is\n** defined that 64-bit floating point values really are mixed\n** endian.\n*/\n            const u64 t1 = ( (u64)0x3ff00000 ) << 32;\n            const double r1 = 1.0;\n            u64 t2 = t1;\n#if  SQLITE_MIXED_ENDIAN_64BIT_FLOAT\nswapMixedEndianFloat(t2);\n#endif\n            Debug.Assert( sizeof( double ) == sizeof( u64 ) && memcmp( BitConverter.GetBytes( r1 ), BitConverter.GetBytes( t2 ), sizeof( double ) ) == 0 );//Debug.Assert( sizeof(r1)==sizeof(t2) && memcmp(&r1, t2, sizeof(r1))==0 );\n#endif\n\n            x = (u64)( ( buf[offset + 0] << 24 ) | ( buf[offset + 1] << 16 ) | ( buf[offset + 2] << 8 ) | buf[offset + 3] );\n            y = (u32)( ( buf[offset + 4] << 24 ) | ( buf[offset + 5] << 16 ) | ( buf[offset + 6] << 8 ) | buf[offset + 7] );\n            x = ( x << 32 ) | y;\n            if ( serial_type == 6 )\n            {\n              pMem.u.i = (i64)x;\n              pMem.flags = MEM_Int;\n            }\n            else\n            {\n              Debug.Assert( sizeof( i64 ) == 8 && sizeof( double ) == 8 );\n#if  SQLITE_MIXED_ENDIAN_64BIT_FLOAT\nswapMixedEndianFloat(x);\n#endif\n              pMem.r = BitConverter.Int64BitsToDouble( (long)x );// memcpy(pMem.r, x, sizeof(x))\n              pMem.flags = (u16)( sqlite3IsNaN( pMem.r ) ? MEM_Null : MEM_Real );\n            }\n            return 8;\n          }\n        case 8:    /* Integer 0 */\n        case 9:\n          {  /* Integer 1 */\n            pMem.u.i = serial_type - 8;\n            pMem.flags = MEM_Int;\n            return 0;\n          }\n        default:\n          {\n            u32 len = ( serial_type - 12 ) / 2;\n            pMem.n = (int)len;\n            pMem.xDel = null;\n            if ( ( serial_type & 0x01 ) != 0 )\n            {\n              pMem.flags = MEM_Str | MEM_Ephem;\n              pMem.z = Encoding.UTF8.GetString( buf, offset, (int)len );//memcpy( buf, pMem.z, len );\n              pMem.n = pMem.z.Length;\n              pMem.zBLOB = null;\n            }\n            else\n            {\n              pMem.z = null;\n              pMem.zBLOB = new byte[len];\n              pMem.flags = MEM_Blob | MEM_Ephem;\n              Buffer.BlockCopy( buf, offset, pMem.zBLOB, 0, (int)len );//memcpy( buf, pMem.z, len );\n            }\n            return len;\n          }\n      }\n      return 0;\n    }\n\n    static int sqlite3VdbeSerialGet(\n    byte[] buf,     /* Buffer to deserialize from */\n    u32 serial_type,              /* Serial type to deserialize */\n    Mem pMem                     /* Memory cell to write value into */\n    )\n    {\n      switch ( serial_type )\n      {\n        case 10:   /* Reserved for future use */\n        case 11:   /* Reserved for future use */\n        case 0:\n          {  /* NULL */\n            pMem.flags = MEM_Null;\n            break;\n          }\n        case 1:\n          { /* 1-byte signed integer */\n            pMem.u.i = (sbyte)buf[0];\n            pMem.flags = MEM_Int;\n            return 1;\n          }\n        case 2:\n          { /* 2-byte signed integer */\n            pMem.u.i = (int)( ( ( buf[0] ) << 8 ) | buf[1] );\n            pMem.flags = MEM_Int;\n            return 2;\n          }\n        case 3:\n          { /* 3-byte signed integer */\n            pMem.u.i = (int)( ( ( buf[0] ) << 16 ) | ( buf[1] << 8 ) | buf[2] );\n            pMem.flags = MEM_Int;\n            return 3;\n          }\n        case 4:\n          { /* 4-byte signed integer */\n            pMem.u.i = (int)( ( buf[0] << 24 ) | ( buf[1] << 16 ) | ( buf[2] << 8 ) | buf[3] );\n            pMem.flags = MEM_Int;\n            return 4;\n          }\n        case 5:\n          { /* 6-byte signed integer */\n            u64 x = (ulong)( ( ( buf[0] ) << 8 ) | buf[1] );\n            u32 y = (u32)( ( buf[2] << 24 ) | ( buf[3] << 16 ) | ( buf[4] << 8 ) | buf[5] );\n            x = ( x << 32 ) | y;\n            pMem.u.i = (i64)x;\n            pMem.flags = MEM_Int;\n            return 6;\n          }\n        case 6:   /* 8-byte signed integer */\n        case 7:\n          { /* IEEE floating point */\n            u64 x;\n            u32 y;\n#if !NDEBUG && !SQLITE_OMIT_FLOATING_POINT\n            /* Verify that integers and floating point values use the same\n** byte order.  Or, that if SQLITE_MIXED_ENDIAN_64BIT_FLOAT is\n** defined that 64-bit floating point values really are mixed\n** endian.\n*/\n            const u64 t1 = ( (u64)0x3ff00000 ) << 32;\n            const double r1 = 1.0;\n            u64 t2 = t1;\n#if  SQLITE_MIXED_ENDIAN_64BIT_FLOAT\nswapMixedEndianFloat(t2);\n#endif\n            Debug.Assert( sizeof( double ) == sizeof( u64 ) && memcmp( BitConverter.GetBytes( r1 ), BitConverter.GetBytes( t2 ), sizeof( double ) ) == 0 );//Debug.Assert( sizeof(r1)==sizeof(t2) && memcmp(&r1, t2, sizeof(r1))==0 );\n#endif\n\n            x = (u64)( ( buf[0] << 24 ) | ( buf[1] << 16 ) | ( buf[2] << 8 ) | buf[3] );\n            y = (u32)( ( buf[4] << 24 ) | ( buf[5] << 16 ) | ( buf[6] << 8 ) | buf[7] );\n            x = ( x << 32 ) | y;\n            if ( serial_type == 6 )\n            {\n              pMem.u.i = (i64)x;\n              pMem.flags = MEM_Int;\n            }\n            else\n            {\n              Debug.Assert( sizeof( i64 ) == 8 && sizeof( double ) == 8 );\n#if  SQLITE_MIXED_ENDIAN_64BIT_FLOAT\nswapMixedEndianFloat(x);\n#endif\n              pMem.r = BitConverter.Int64BitsToDouble( (long)x );// memcpy(pMem.r, x, sizeof(x))\n              pMem.flags = MEM_Real;\n            }\n            return 8;\n          }\n        case 8:    /* Integer 0 */\n        case 9:\n          {  /* Integer 1 */\n            pMem.u.i = serial_type - 8;\n            pMem.flags = MEM_Int;\n            return 0;\n          }\n        default:\n          {\n            int len = (int)( ( serial_type - 12 ) / 2 );\n            pMem.xDel = null;\n            if ( ( serial_type & 0x01 ) != 0 )\n            {\n              pMem.flags = MEM_Str | MEM_Ephem;\n              pMem.z = Encoding.UTF8.GetString( buf, 0, len );//memcpy( buf, pMem.z, len );\n              pMem.n = pMem.z.Length;// len;\n              pMem.zBLOB = null;\n            }\n            else\n            {\n              pMem.flags = MEM_Blob | MEM_Ephem;\n              pMem.zBLOB = new byte[len];\n              buf.CopyTo( pMem.zBLOB, 0 );\n              pMem.n = len;// len;\n              pMem.z = null;\n            }\n            return len;\n          }\n      }\n      return 0;\n    }\n\n    /*\n    ** Given the nKey-byte encoding of a record in pKey[], parse the\n    ** record into a UnpackedRecord structure.  Return a pointer to\n    ** that structure.\n    **\n    ** The calling function might provide szSpace bytes of memory\n    ** space at pSpace.  This space can be used to hold the returned\n    ** VDbeParsedRecord structure if it is large enough.  If it is\n    ** not big enough, space is obtained from sqlite3Malloc().\n    **\n    ** The returned structure should be closed by a call to\n    ** sqlite3VdbeDeleteUnpackedRecord().\n    */\n    static UnpackedRecord sqlite3VdbeRecordUnpack(\n    KeyInfo pKeyInfo,   /* Information about the record format */\n    int nKey,           /* Size of the binary record */\n    byte[] pKey,        /* The binary record */\n    UnpackedRecord pSpace, //  char *pSpace,          /* Unaligned space available to hold the object */\n    int szSpace         /* Size of pSpace[] in bytes */\n    )\n    {\n      byte[] aKey = pKey;\n      UnpackedRecord p;     /* The unpacked record that we will return */\n      int nByte;            /* Memory space needed to hold p, in bytes */\n      int d;\n      u32 idx;\n      int u;                /* Unsigned loop counter */\n      int szHdr = 0;\n      Mem pMem;\n      int nOff;           /* Increase pSpace by this much to 8-byte align it */\n\n      /*\n      ** We want to shift the pointer pSpace up such that it is 8-byte aligned.\n      ** Thus, we need to calculate a value, nOff, between 0 and 7, to shift\n      ** it by.  If pSpace is already 8-byte aligned, nOff should be zero.\n      */\n      //nOff = ( 8 - ( SQLITE_PTR_TO_INT( pSpace ) & 7 ) ) & 7;\n      //pSpace += nOff;\n      //szSpace -= nOff;\n      //nByte = ROUND8( sizeof( UnpackedRecord ) ) + sizeof( Mem ) * ( pKeyInfo->nField + 1 );\n      //if ( nByte > szSpace)\n      //{\n      //  p = new UnpackedRecord();//sqlite3DbMallocRaw(pKeyInfo.db, nByte);\n      //  if ( p == null ) return null;\n      //  p.flags = UNPACKED_NEED_FREE | UNPACKED_NEED_DESTROY;\n      //}\n      //else\n      {\n        p = pSpace;//(UnpackedRecord*)pSpace;\n        p.flags = UNPACKED_NEED_DESTROY;\n      }\n      p.pKeyInfo = pKeyInfo;\n      p.nField = (u16)( pKeyInfo.nField + 1 );\n      //p->aMem = pMem = (Mem*)&( (char*)p )[ROUND8( sizeof( UnpackedRecord ) )];\n      //assert( EIGHT_BYTE_ALIGNMENT( pMem ) );\n      p.aMem = new Mem[p.nField + 1];\n      idx = (u32)getVarint32( aKey, 0, ref szHdr );// GetVarint( aKey, szHdr );\n      d = (int)szHdr;\n      u = 0;\n      while ( idx < (int)szHdr && u < p.nField && d <= nKey )\n      {\n        p.aMem[u] = new Mem();\n        pMem = p.aMem[u];\n        u32 serial_type = 0;\n\n        idx += (u32)getVarint32( aKey, idx, ref serial_type );// GetVarint( aKey + idx, serial_type );\n        pMem.enc = pKeyInfo.enc;\n        pMem.db = pKeyInfo.db;\n        pMem.flags = 0;\n        //pMem.zMalloc = null;\n        d += (int)sqlite3VdbeSerialGet( aKey, d, serial_type, pMem );\n        //pMem++;\n        u++;\n      }\n      Debug.Assert( u <= pKeyInfo.nField + 1 );\n      p.nField = (u16)u;\n      return p;// (void*)p;\n    }\n\n    /*\n    ** This routine destroys a UnpackedRecord object.\n    */\n    static void sqlite3VdbeDeleteUnpackedRecord( UnpackedRecord p )\n    {\n      int i;\n      Mem pMem;\n      Debug.Assert( p != null );\n      Debug.Assert( ( p.flags & UNPACKED_NEED_DESTROY ) != 0 );\n      //for ( i = 0, pMem = p->aMem ; i < p->nField ; i++, pMem++ )\n      //{\n      //  /* The unpacked record is always constructed by the\n      //  ** sqlite3VdbeUnpackRecord() function above, which makes all\n      //  ** strings and blobs static.  And none of the elements are\n      //  ** ever transformed, so there is never anything to delete.\n      //  */\n      //  if ( NEVER( pMem->zMalloc ) ) sqlite3VdbeMemRelease( pMem );\n      //}\n      if ( ( p.flags & UNPACKED_NEED_FREE ) != 0 )\n      {\n        p = null;//sqlite3DbFree( p.pKeyInfo.db, ref p );\n      }\n    }\n\n    /*\n    ** This function compares the two table rows or index records\n    ** specified by {nKey1, pKey1} and pPKey2.  It returns a negative, zero\n    ** or positive integer if key1 is less than, equal to or\n    ** greater than key2.  The {nKey1, pKey1} key must be a blob\n    ** created by th OP_MakeRecord opcode of the VDBE.  The pPKey2\n    ** key must be a parsed key such as obtained from\n    ** sqlite3VdbeParseRecord.\n    **\n    ** Key1 and Key2 do not have to contain the same number of fields.\n    ** The key with fewer fields is usually compares less than the\n    ** longer key.  However if the UNPACKED_INCRKEY flags in pPKey2 is set\n    ** and the common prefixes are equal, then key1 is less than key2.\n    ** Or if the UNPACKED_MATCH_PREFIX flag is set and the prefixes are\n    ** equal, then the keys are considered to be equal and\n    ** the parts beyond the common prefix are ignored.\n    **\n    ** If the UNPACKED_IGNORE_ROWID flag is set, then the last byte of\n    ** the header of pKey1 is ignored.  It is assumed that pKey1 is\n    ** an index key, and thus ends with a rowid value.  The last byte\n    ** of the header will therefore be the serial type of the rowid:\n    ** one of 1, 2, 3, 4, 5, 6, 8, or 9 - the integer serial types.\n    ** The serial type of the final rowid will always be a single byte.\n    ** By ignoring this last byte of the header, we force the comparison\n    ** to ignore the rowid at the end of key1.\n    */\n\n    // ALTERNATE FORM for C#\n    static int sqlite3VdbeRecordCompare(\n    int nKey1, byte[] pKey1,    /* Left key */\n    UnpackedRecord pPKey2       /* Right key */\n    )\n    {\n      return sqlite3VdbeRecordCompare( nKey1, pKey1, 0, pPKey2 );\n    }\n\n    static int sqlite3VdbeRecordCompare(\n    int nKey1, byte[] pKey1,    /* Left key */\n    int offset,\n    UnpackedRecord pPKey2       /* Right key */\n    )\n    {\n      int d1;            /* Offset into aKey[] of next data element */\n      u32 idx1;          /* Offset into aKey[] of next header element */\n      u32 szHdr1;        /* Number of bytes in header */\n      int i = 0;\n      int nField;\n      int rc = 0;\n      byte[] aKey1 = new byte[pKey1.Length - offset];\n      Buffer.BlockCopy( pKey1, offset, aKey1, 0, aKey1.Length );\n      KeyInfo pKeyInfo;\n\n      Mem mem1 = new Mem();\n      pKeyInfo = pPKey2.pKeyInfo;\n      mem1.enc = pKeyInfo.enc;\n      mem1.db = pKeyInfo.db;\n      mem1.flags = 0;\n      mem1.u.i = 0;  /* not needed, here to silence compiler warning */\n      //mem1.zMalloc = null;\n\n      idx1 = (u32)( ( szHdr1 = aKey1[0] ) <= 0x7f ? 1 : getVarint32( aKey1, 0, ref szHdr1 ) );// GetVarint( aKey1, szHdr1 );\n      d1 = (int)szHdr1;\n      if ( ( pPKey2.flags & UNPACKED_IGNORE_ROWID ) != 0 )\n      {\n        szHdr1--;\n      }\n      nField = pKeyInfo.nField;\n      while ( idx1 < szHdr1 && i < pPKey2.nField )\n      {\n        u32 serial_type1;\n\n        /* Read the serial types for the next element in each key. */\n        idx1 += (u32)( ( serial_type1 = aKey1[idx1] ) <= 0x7f ? 1 : getVarint32( aKey1, idx1, ref serial_type1 ) ); //GetVarint( aKey1 + idx1, serial_type1 );\n        if ( d1 >= nKey1 && sqlite3VdbeSerialTypeLen( serial_type1 ) > 0 ) break;\n\n        /* Extract the values to be compared.\n        */\n        d1 += (int)sqlite3VdbeSerialGet( aKey1, d1, serial_type1, mem1 );\n\n        /* Do the comparison\n        */\n        rc = sqlite3MemCompare( mem1, pPKey2.aMem[i], i < nField ? pKeyInfo.aColl[i] : null );\n        if ( rc != 0 )\n        {\n          break;\n        }\n        i++;\n      }\n      /* No memory allocation is ever used on mem1. */\n      //if ( NEVER( mem1.zMalloc ) ) sqlite3VdbeMemRelease( &mem1 );\n\n      /* If the PREFIX_SEARCH flag is set and all fields except the final\n      ** rowid field were equal, then clear the PREFIX_SEARCH flag and set\n      ** pPKey2->rowid to the value of the rowid field in (pKey1, nKey1).\n      ** This is used by the OP_IsUnique opcode.\n      */\n      if ( ( pPKey2.flags & UNPACKED_PREFIX_SEARCH ) != 0 && i == ( pPKey2.nField - 1 ) )\n      {\n        Debug.Assert( idx1 == szHdr1 && rc != 0 );\n        Debug.Assert( ( mem1.flags & MEM_Int ) != 0 );\n        pPKey2.flags = (ushort)( pPKey2.flags & ~UNPACKED_PREFIX_SEARCH );\n        pPKey2.rowid = mem1.u.i;\n      }\n\n      if ( rc == 0 )\n      {\n        /* rc==0 here means that one of the keys ran out of fields and\n        ** all the fields up to that point were equal. If the UNPACKED_INCRKEY\n        ** flag is set, then break the tie by treating key2 as larger.\n        ** If the UPACKED_PREFIX_MATCH flag is set, then keys with common prefixes\n        ** are considered to be equal.  Otherwise, the longer key is the\n        ** larger.  As it happens, the pPKey2 will always be the longer\n        ** if there is a difference.\n        */\n        if ( ( pPKey2.flags & UNPACKED_INCRKEY ) != 0 )\n        {\n          rc = -1;\n        }\n        else if ( ( pPKey2.flags & UNPACKED_PREFIX_MATCH ) != 0 )\n        {\n          /* Leave rc==0 */\n        }\n        else if ( idx1 < szHdr1 )\n        {\n          rc = 1;\n        }\n      }\n      else if ( pKeyInfo.aSortOrder != null && i < pKeyInfo.nField\n      && pKeyInfo.aSortOrder[i] != 0 )\n      {\n        rc = -rc;\n      }\n\n      return rc;\n    }\n\n    /*\n    ** pCur points at an index entry created using the OP_MakeRecord opcode.\n    ** Read the rowid (the last field in the record) and store it in *rowid.\n    ** Return SQLITE_OK if everything works, or an error code otherwise.\n    **\n    ** pCur might be pointing to text obtained from a corrupt database file.\n    ** So the content cannot be trusted.  Do appropriate checks on the content.\n    */\n    static int sqlite3VdbeIdxRowid( sqlite3 db, BtCursor pCur, ref i64 rowid )\n    {\n      i64 nCellKey = 0;\n      int rc;\n      u32 szHdr = 0;        /* Size of the header */\n      u32 typeRowid = 0;    /* Serial type of the rowid */\n      u32 lenRowid;       /* Size of the rowid */\n      Mem m = new Mem(); Mem v = new Mem();\n\n      /* Get the size of the index entry.  Only indices entries of less\n      ** than 2GiB are support - anything large must be database corruption.\n      ** Any corruption is detected in sqlite3BtreeParseCellPtr(), though, so\n      ** this code can safely assume that nCellKey is 32-bits  \n      */\n      Debug.Assert( sqlite3BtreeCursorIsValid( pCur ) );\n      rc = sqlite3BtreeKeySize( pCur, ref nCellKey );\n      Debug.Assert( rc == SQLITE_OK );     /* pCur is always valid so KeySize cannot fail */\n      Debug.Assert( ( (u32)nCellKey & SQLITE_MAX_U32 ) == (u64)nCellKey );\n\n      /* Read in the complete content of the index entry */\n      m.flags = 0;\n      m.db = db;\n      //m.zMalloc = null;\n      rc = sqlite3VdbeMemFromBtree( pCur, 0, (int)nCellKey, true, m );\n      if ( rc != 0 )\n      {\n        return rc;\n      }\n\n      /* The index entry must begin with a header size */\n      getVarint32( m.zBLOB, 0, ref szHdr );\n      testcase( szHdr == 3 );\n      testcase( szHdr == m.n );\n      if ( unlikely( szHdr < 3 || (int)szHdr > m.n ) )\n      {\n        goto idx_rowid_corruption;\n      }\n\n      /* The last field of the index should be an integer - the ROWID.\n      ** Verify that the last entry really is an integer. */\n      getVarint32( m.zBLOB, szHdr - 1, ref typeRowid );\n      testcase( typeRowid == 1 );\n      testcase( typeRowid == 2 );\n      testcase( typeRowid == 3 );\n      testcase( typeRowid == 4 );\n      testcase( typeRowid == 5 );\n      testcase( typeRowid == 6 );\n      testcase( typeRowid == 8 );\n      testcase( typeRowid == 9 );\n      if ( unlikely( typeRowid < 1 || typeRowid > 9 || typeRowid == 7 ) )\n      {\n        goto idx_rowid_corruption;\n      }\n      lenRowid = (u32)sqlite3VdbeSerialTypeLen( typeRowid );\n      testcase( (u32)m.n == szHdr + lenRowid );\n      if ( unlikely( (u32)m.n < szHdr + lenRowid ) )\n      {\n        goto idx_rowid_corruption;\n      }\n\n      /* Fetch the integer off the end of the index record */\n      sqlite3VdbeSerialGet( m.zBLOB, (int)( m.n - lenRowid ), typeRowid, v );\n      rowid = v.u.i;\n      sqlite3VdbeMemRelease( m );\n      return SQLITE_OK;\n\n      /* Jump here if database corruption is detected after m has been\n      ** allocated.  Free the m object and return SQLITE_CORRUPT. */\nidx_rowid_corruption:\n      //testcase( m.zMalloc != 0 );\n      sqlite3VdbeMemRelease( m );\n#if SQLITE_DEBUG\n      return SQLITE_CORRUPT_BKPT();\n#else\nreturn SQLITE_CORRUPT_BKPT;\n#endif\n    }\n\n    /*\n    ** Compare the key of the index entry that cursor pC is pointing to against\n    ** the key string in pUnpacked.  Write into *pRes a number\n    ** that is negative, zero, or positive if pC is less than, equal to,\n    ** or greater than pUnpacked.  Return SQLITE_OK on success.\n    **\n    ** pUnpacked is either created without a rowid or is truncated so that it\n    ** omits the rowid at the end.  The rowid at the end of the index entry\n    ** is ignored as well.  Hence, this routine only compares the prefixes \n    ** of the keys prior to the final rowid, not the entire key.\n    */\n    static int sqlite3VdbeIdxKeyCompare(\n    VdbeCursor pC,              /* The cursor to compare against */\n    UnpackedRecord pUnpacked,   /* Unpacked version of key to compare against */\n    ref int res                 /* Write the comparison result here */\n    )\n    {\n      i64 nCellKey = 0;\n      int rc;\n      BtCursor pCur = pC.pCursor;\n      Mem m = new Mem();\n\n      Debug.Assert( sqlite3BtreeCursorIsValid( pCur ) );\n      rc = sqlite3BtreeKeySize( pCur, ref nCellKey );\n      Debug.Assert( rc == SQLITE_OK );    /* pCur is always valid so KeySize cannot fail */\n      /* nCellKey will always be between 0 and 0xffffffff because of the say\n      ** that btreeParseCellPtr() and sqlite3GetVarint32() are implemented */\n      if ( nCellKey <= 0 || nCellKey > 0x7fffffff )\n      {\n        res = 0;\n        return SQLITE_CORRUPT;\n      }\n      m.flags = 0;\n      m.db = null;\n      //m.zMalloc = null;\n      rc = sqlite3VdbeMemFromBtree( pC.pCursor, 0, (int)nCellKey, true, m );\n      if ( rc != 0 )\n      {\n        return rc;\n      }\n      Debug.Assert( ( pUnpacked.flags & UNPACKED_IGNORE_ROWID ) != 0 );\n      res = sqlite3VdbeRecordCompare( m.n, m.zBLOB, pUnpacked );\n      sqlite3VdbeMemRelease( m );\n      return SQLITE_OK;\n    }\n\n    /*\n    ** This routine sets the value to be returned by subsequent calls to\n    ** sqlite3_changes() on the database handle \'db\'.\n    */\n    static void sqlite3VdbeSetChanges( sqlite3 db, int nChange )\n    {\n      Debug.Assert( sqlite3_mutex_held( db.mutex ) );\n      db.nChange = nChange;\n      db.nTotalChange += nChange;\n    }\n\n    /*\n    ** Set a flag in the vdbe to update the change counter when it is finalised\n    ** or reset.\n    */\n    static void sqlite3VdbeCountChanges( Vdbe v )\n    {\n      v.changeCntOn = true;\n    }\n\n    /*\n    ** Mark every prepared statement associated with a database connection\n    ** as expired.\n    **\n    ** An expired statement means that recompilation of the statement is\n    ** recommend.  Statements expire when things happen that make their\n    ** programs obsolete.  Removing user-defined functions or collating\n    ** sequences, or changing an authorization function are the types of\n    ** things that make prepared statements obsolete.\n    */\n    static void sqlite3ExpirePreparedStatements( sqlite3 db )\n    {\n      Vdbe p;\n      for ( p = db.pVdbe ; p != null ; p = p.pNext )\n      {\n        p.expired = true;\n      }\n    }\n\n    /*\n    ** Return the database associated with the Vdbe.\n    */\n    static sqlite3 sqlite3VdbeDb( Vdbe v )\n    {\n      return v.db;\n    }\n  }\n}\n'