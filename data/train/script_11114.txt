b'-- Part of this code is taken and adapted from:\n-- https://wiki.haskell.org/WxHaskell/Quick_start#Hello_world_in_wxHaskell\nmodule Main where\n\nimport Prelude hiding ((.))\nimport Control.Category\nimport Control.Monad\nimport Data.IORef\nimport Data.MonadicStreamFunction\nimport Data.MonadicStreamFunction.InternalCore\nimport Graphics.UI.WX\n\nmain :: IO ()\nmain = start $ do\n  f      <- frame      []\n  lenLbl <- staticText f [ text := "0" ]\n  step   <- button     f [ text := "Up" ]\n  quit   <- button     f [ text := "Quit", on command := close f ]\n\n  counter <- newIORef 0\n\n  -- Reactive network\n  let labelMSF  = labelTextSk lenLbl . arr show . ioRefSg counter\n      buttonMSF = ioRefSg counter >>> arr (+1) >>> ioRefSk counter\n\n  -- NOTE: The order here is *very* important. If you write\n  -- labelMSF &&& buttonMSF, then they will be desynced\n  -- (meaning that, at the end of one simulation step, the label\n  -- will not show the contents of the IORef).\n  let appMSF = (buttonMSF &&& labelMSF) >>> arr (const ())\n\n  hndlr <- pushReactimate_ appMSF\n  set step [ on command := hndlr ]\n\n  set f [layout := margin 10 (column 5 [ floatCentre (widget lenLbl)\n                                       , floatCentre (widget step)\n                                       , floatCentre (widget quit)\n                                       ] )]\n\n\n-- * Auxiliary definitions\n\n-- ** Adhoc Dunai-WX backend\ntextEntryTextSg :: TextCtrl a -> MStream IO String\ntextEntryTextSg entry = constM (get entry text)\n\nlabelTextSk :: StaticText a -> MSink IO String\nlabelTextSk lbl = arrM $ setJust lbl text\n  -- (\\t -> set lbl [ text := t ])\n\nioRefSg :: IORef a -> MStream IO a\nioRefSg ioref = constM (readIORef ioref)\n\nioRefSk :: IORef a -> MSink IO a\nioRefSk ioref = arrM (writeIORef ioref)\n\n-- ** MSF-related definitions and extensions\n\n-- | Run an MSF on an input sample step by step, using an IORef to store the\n-- continuation.\npushReactimate :: MSF IO a b -> IO (a -> IO b)\npushReactimate msf = do\n  msfRef <- newIORef msf\n  return $ \\a -> do\n              msf\' <- readIORef msfRef\n              (b, msf\'\') <- unMSF msf\' a\n              writeIORef msfRef msf\'\'\n              return b\n\n-- | Run one step of an MSF on () streams, internally storing the\n-- continuation.\npushReactimate_ :: MSF IO () () -> IO (IO ())\npushReactimate_ msf = do\n  f <- pushReactimate msf\n  return (void (f ()))\n\n-- ** Auxiliary WX functions\nsetJust :: widget -> Attr widget attr -> attr -> IO ()\nsetJust c p v = set c [ p := v ]\n'