b'\xef\xbb\xbf// UVa11082 Matrix Decompressing\n// Rujia Liu\n// Slower version with EdmondsKarp\n#include<cstdio>\n#include<cstring>\n#include<queue>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nconst int maxn = 50 + 5;\nconst int INF = 1000000000;\n\nstruct Edge {\n  int from, to, cap, flow;\n  Edge(int u, int v, int c, int f):from(u),to(v),cap(c),flow(f) {}\n};\n\nstruct EdmondsKarp {\n  int n, m;\n  vector<Edge> edges;    // \xe8\xbe\xb9\xe6\x95\xb0\xe7\x9a\x84\xe4\xb8\xa4\xe5\x80\x8d\n  vector<int> G[maxn];   // \xe9\x82\xbb\xe6\x8e\xa5\xe8\xa1\xa8\xef\xbc\x8cG[i][j]\xe8\xa1\xa8\xe7\xa4\xba\xe7\xbb\x93\xe7\x82\xb9i\xe7\x9a\x84\xe7\xac\xacj\xe6\x9d\xa1\xe8\xbe\xb9\xe5\x9c\xa8e\xe6\x95\xb0\xe7\xbb\x84\xe4\xb8\xad\xe7\x9a\x84\xe5\xba\x8f\xe5\x8f\xb7\n  int a[maxn];           // \xe5\xbd\x93\xe8\xb5\xb7\xe7\x82\xb9\xe5\x88\xb0i\xe7\x9a\x84\xe5\x8f\xaf\xe6\x94\xb9\xe8\xbf\x9b\xe9\x87\x8f\n  int p[maxn];           // \xe6\x9c\x80\xe7\x9f\xad\xe8\xb7\xaf\xe6\xa0\x91\xe4\xb8\x8ap\xe7\x9a\x84\xe5\x85\xa5\xe5\xbc\xa7\xe7\xbc\x96\xe5\x8f\xb7\n\n  void init(int n) {\n    for(int i = 0; i < n; i++) G[i].clear();\n    edges.clear();\n  }\n\n  void AddEdge(int from, int to, int cap) {\n    edges.push_back(Edge(from, to, cap, 0));\n    edges.push_back(Edge(to, from, 0, 0));\n    m = edges.size();\n    G[from].push_back(m-2);\n    G[to].push_back(m-1);\n  }\n\n  int Maxflow(int s, int t) {\n    int flow = 0;\n    for(;;) {\n      memset(a, 0, sizeof(a));\n      queue<int> Q;\n      Q.push(s);\n      a[s] = INF;\n      while(!Q.empty()) {\n        int x = Q.front(); Q.pop();\n        for(int i = 0; i < G[x].size(); i++) {\n          Edge& e = edges[G[x][i]];\n          if(!a[e.to] && e.cap > e.flow) {\n            p[e.to] = G[x][i];\n            a[e.to] = min(a[x], e.cap-e.flow);\n            Q.push(e.to);\n          }\n        }\n        if(a[t]) break;\n      }\n      if(!a[t]) break;\n      for(int u = t; u != s; u = edges[p[u]].from) {\n        edges[p[u]].flow += a[t];\n        edges[p[u]^1].flow -= a[t];\n      }\n      flow += a[t];\n    }\n    return flow;\n  }\n};\n\nEdmondsKarp g;\nint no[maxn][maxn];\n\nint main() {\n  int T, R, C, v, kase = 0;\n  scanf("%d", &T);\n  for(int kase = 1; kase <= T; kase++) {\n    scanf("%d%d", &R, &C);\n    g.init(R+C+2);\n    int last = 0;\n    for(int i = 1; i <= R; i++) {\n      scanf("%d", &v);\n      g.AddEdge(0, i, v - last - C); // row sum is v - last\n      last = v;\n    }\n    last = 0;\n    for(int i = 1; i <= C; i++) {\n      scanf("%d", &v);\n      g.AddEdge(R+i, R+C+1, v - last - R); // col sum is v - last\n      last = v;\n    }\n    for(int i = 1; i <= R; i++)\n      for(int j = 1; j <= C; j++) {\n        g.AddEdge(i, R+j, 19);\n        no[i][j] = g.edges.size() - 2; // no[i][j] is the index of arc for cell(i,j)\n      }\n    g.Maxflow(0, R+C+1);\n\n    printf("Matrix %d\\n", kase);\n    for(int i = 1; i <= R; i++) {\n      for(int j = 1; j <= C; j++)\n        printf("%d ", g.edges[no[i][j]].flow + 1); // we subtracted 1 from every cell\n      printf("\\n");\n    }\n    printf("\\n");\n  }\n  return 0;\n}\n'