b'package com.db.williamchart.extensions\n\nimport android.graphics.Path\nimport com.db.williamchart.data.DataPoint\nimport com.db.williamchart.data.Label\nimport com.db.williamchart.data.Scale\n\nfun List<DataPoint>.limits(): Pair<Float, Float> {\n\n    if (isEmpty())\n        Pair(0F, 1F)\n\n    val values = map { it.value }\n    return values.floatLimits()\n}\n\nfun List<DataPoint>.toScale(): Scale {\n    val limits = limits()\n    return Scale(min = limits.first, max = limits.second)\n}\n\nfun List<DataPoint>.toBarScale(): Scale {\n    val limits = limits()\n    return when {\n        limits.first > 0 -> Scale(0f, limits.second)\n        limits.second < 0 -> Scale(limits.first, 0f)\n        else -> Scale(limits.first, limits.second)\n    }\n}\n\nfun List<DataPoint>.toLabels(): List<Label> {\n    return map {\n        Label(\n            label = it.label,\n            screenPositionX = 0f,\n            screenPositionY = 0f\n        )\n    }\n}\n\nfun List<DataPoint>.toLinePath(): Path {\n    val res = Path()\n\n    res.moveTo(this.first().screenPositionX, this.first().screenPositionY)\n    for (i in 1 until this.size)\n        res.lineTo(this[i].screenPositionX, this[i].screenPositionY)\n    return res\n}\n\n/**\n * Credits: http://www.jayway.com/author/andersericsson/\n */\nfun List<DataPoint>.toSmoothLinePath(smoothFactor: Float): Path {\n\n    var thisPointX: Float\n    var thisPointY: Float\n    var nextPointX: Float\n    var nextPointY: Float\n    var startDiffX: Float\n    var startDiffY: Float\n    var endDiffX: Float\n    var endDiffY: Float\n    var firstControlX: Float\n    var firstControlY: Float\n    var secondControlX: Float\n    var secondControlY: Float\n\n    val res = Path()\n    res.moveTo(this.first().screenPositionX, this.first().screenPositionY)\n\n    for (i in 0 until this.size - 1) {\n\n        thisPointX = this[i].screenPositionX\n        thisPointY = this[i].screenPositionY\n\n        nextPointX = this[i + 1].screenPositionX\n        nextPointY = this[i + 1].screenPositionY\n\n        startDiffX = nextPointX - this[si(this.size, i - 1)].screenPositionX\n        startDiffY = nextPointY - this[si(this.size, i - 1)].screenPositionY\n\n        endDiffX = this[si(this.size, i + 2)].screenPositionX - thisPointX\n        endDiffY = this[si(this.size, i + 2)].screenPositionY - thisPointY\n\n        firstControlX = thisPointX + smoothFactor * startDiffX\n        firstControlY = thisPointY + smoothFactor * startDiffY\n\n        secondControlX = nextPointX - smoothFactor * endDiffX\n        secondControlY = nextPointY - smoothFactor * endDiffY\n\n        res.cubicTo(\n            firstControlX,\n            firstControlY,\n            secondControlX,\n            secondControlY,\n            nextPointX,\n            nextPointY\n        )\n    }\n\n    return res\n}\n\nprivate fun List<Float>.floatLimits(): Pair<Float, Float> {\n\n    val min = min() ?: 0F\n    var max = max() ?: 1F\n\n    if (min == max)\n        max += 1F\n\n    return Pair(min, max)\n}\n\n/**\n * Credits: http://www.jayway.com/author/andersericsson/\n */\nprivate fun si(setSize: Int, i: Int): Int {\n    return when {\n        i > setSize - 1 -> setSize - 1\n        i < 0 -> 0\n        else -> i\n    }\n}\n\ninternal fun List<Pair<String, Float>>.toDataPoints(): List<DataPoint> =\n    map {\n        DataPoint(\n            label = it.first,\n            value = it.second,\n            screenPositionX = 0f,\n            screenPositionY = 0f\n        )\n    }\n'