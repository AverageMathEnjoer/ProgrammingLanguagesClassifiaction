b'// UVa1375 The Best Name for Your Baby\n// Rujia Liu\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<map>\nusing namespace std;\n\nconst int maxn = 50 + 5;\nconst int maxlen = 20 + 5;\nconst int maxs = 50*20 + 52 + 5; // for a rule with right length x, we have x-1 symbols with length>1\n\nint n, L, ns;\nstring rule[maxn];\nstring sym[maxs]; // symbols\nint car[maxs], cdr[maxs]; // lisp names for "head" and "tail" 8-)\nstring dp[maxs][maxlen];\n\nbool is_all_terminal(const string& s) {\n  for(int i = 0; i < s.length(); i++)\n    if(!(s[i] >= \'a\' && s[i] <= \'z\')) return false;\n  return true;\n}\n\nstring min(const string& a, const string& b) {\n  if(a == "-") return b;\n  return a < b ? a : b;\n}\n\nstruct Node {\n  int x;\n  string s;\n  Node(int x, string s):x(x),s(s){}\n  // smaller string has higher priority, thus will be extracted earlier\n  bool operator < (const Node& rhs) const {\n    return s > rhs.s;\n  }\n};\n\nstruct Transform {\n  int target, empty;\n  Transform(int t, int e):target(t),empty(e){}\n};\n\nvector<Transform> tr[maxs];\n\nbool vis[maxs];\n// fill in other dp[?][len] reachable from existing dp[?][len] nodes via "epsilon edges"\nvoid search(int len) {\n  memset(vis, 0, sizeof(vis));\n  priority_queue<Node> q;\n  for(int i = 0; i < ns; i++)\n    if(dp[i][len] != "-") {\n      q.push(Node(i, dp[i][len]));\n    }\n\n  while(!q.empty()) {\n    Node u = q.top(); q.pop();\n    int x = u.x;\n    string s = u.s;\n    if(vis[x]) continue;\n    vis[x] = true;\n    for(int i = 0; i < tr[x].size(); i++) {\n      int target = tr[x][i].target;\n      int empty = tr[x][i].empty;\n      if(dp[empty][0] == "" && (dp[target][len] == "-" || s < dp[target][len])) {\n        dp[target][len] = s;\n        q.push(Node(target, s));\n      }\n    }\n  }\n}\n\nmap<string,int> sym2id;\n\nint ID(const string& s) {\n  if(!sym2id.count(s)) {\n    sym[ns] = s;\n    sym2id[s] = ns++;\n  }\n  return sym2id[s];\n}\n\n// S=HT, if H can be empty, S and T can be transformed to each other\n// we say h can reach s via epsilon edge t, and t can reach s via epsilon edge h\nvoid add_intermediate_symbol(const string& S) {\n  int s = ID(S);\n  if(S.length() < 2) return;\n  int h = ID(S.substr(0,1));\n  int t = ID(S.substr(1,S.length()-1));\n  tr[h].push_back(Transform(s, t));\n  tr[t].push_back(Transform(s, h));\n  car[s] = h;\n  cdr[s] = t;\n}\n\nint main() {\n  while(cin >> n >> L && n) {\n    sym2id.clear();\n    ns = 0;\n\n    ID(""); // make sure sym[0] = ""\n    for(int i = 0; i < maxs; i++) tr[i].clear();\n\n    for(int i = 0; i < n; i++) {\n      cin >> rule[i]; // for example, rule[i]="S=AbC"\n      int left = ID(rule[i].substr(0,1));\n      int right = ID(rule[i].substr(2));\n      tr[right].push_back(Transform(left, ID("")));  // AbC can be transformed to S\n      int len = rule[i].length();\n      for(int j = 2; j < len; j++) // AbC, bC, C\n        add_intermediate_symbol(rule[i].substr(j));\n    }\n\n    for(int i = 0; i < ns; i++)\n      for(int j = 0; j <= L; j++)\n        dp[i][j] = "-"; // impossible\n    dp[0][0] = ""; // dp[i][j] means the first string with len j that symbol i can be transformed into\n\n    for(int j = 0; j <= L; j++) {\n      for(int i = 0; i < ns; i++) {\n        if(sym[i].length() == j && is_all_terminal(sym[i])) dp[i][j] = sym[i];\n        if(sym[i].length() < 2) continue;\n        int s1 = car[i], s2 = cdr[i];\n        for(int k = 1; k < j; k++) {\n          if(dp[s1][k] != "-" && dp[s2][j-k] != "-")\n            dp[i][j] = min(dp[i][j], dp[s1][k] + dp[s2][j-k]);\n        }\n      }\n      search(j);\n    }\n    cout << dp[ID("S")][L] << "\\n";\n  }\n  return 0;\n}\n'