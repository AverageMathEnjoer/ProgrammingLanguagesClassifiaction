b"module Data.Conduit.ByteString where\n\nimport Conduit (MonadUnliftIO)\nimport qualified Data.ByteString as BS\nimport Data.ByteString.Internal (ByteString (PS), mallocByteString)\nimport Data.ByteString.Unsafe (unsafeIndex)\nimport Data.Conduit (ConduitT, await, yield, (.|))\nimport Foreign.ForeignPtr (ForeignPtr)\nimport Foreign.ForeignPtr.Unsafe (unsafeForeignPtrToPtr)\nimport Foreign.Storable (pokeByteOff)\nimport Protolude hiding (hash, yield)\n\ntype ChunkSize = Int\n\nminimumChunkSize :: ChunkSize\nminimumChunkSize = 5 * 1024 * 1024\n\nchunkStream :: (MonadUnliftIO m) => Maybe ChunkSize -> ConduitT ByteString (Int, ByteString) m ()\nchunkStream mChunkSize = do\n  processAndChunkOutputRaw chunkSize\n    .| enumerateConduit\n  where\n    chunkSize :: ChunkSize\n    chunkSize = maybe minimumChunkSize (max minimumChunkSize) mChunkSize\n\n    -- count from 1\n    enumerateConduit :: (Monad m) => ConduitT a (Int, a) m ()\n    enumerateConduit = loop 1\n      where\n        loop i = await >>= maybe (return ()) (go i)\n        go i x = do\n          yield (i, x)\n          loop (i + 1)\n    {-# INLINE enumerateConduit #-}\n\ndata S = S (ForeignPtr Word8) (Ptr Word8) {-# UNPACK #-} !Int\n\nnewS :: ChunkSize -> IO S\nnewS chunkSize = do\n  fptr <- mallocByteString chunkSize\n  return (S fptr (unsafeForeignPtrToPtr fptr) 0)\n\nprocessChunk :: ChunkSize -> ByteString -> S -> IO ([ByteString], S)\nprocessChunk chunkSize input =\n  loop identity 0\n  where\n    loop front idxIn s@(S fptr ptr idxOut)\n      | idxIn >= BS.length input = return (front [], s)\n      | otherwise = do\n          pokeByteOff ptr idxOut (unsafeIndex input idxIn)\n          let idxOut' = idxOut + 1\n              idxIn' = idxIn + 1\n          if idxOut' >= chunkSize\n            then do\n              let bs = PS fptr 0 idxOut'\n              s' <- newS chunkSize\n              loop (front . (bs :)) idxIn' s'\n            else loop front idxIn' (S fptr ptr idxOut')\n\nprocessAndChunkOutputRaw :: MonadIO m => ChunkSize -> ConduitT ByteString ByteString m ()\nprocessAndChunkOutputRaw chunkSize =\n  liftIO (newS chunkSize) >>= loop\n  where\n    loop s@(S fptr _ len) = do\n      mbs <- await\n      case mbs of\n        Nothing -> yield $ PS fptr 0 len\n        Just bs -> do\n          (bss, s') <- liftIO $ processChunk chunkSize bs s\n          mapM_ yield bss\n          loop s'\n"