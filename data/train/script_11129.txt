b'import Control.Applicative\nimport Test.Framework (defaultMain, testGroup)\nimport Test.Framework.Providers.API (Test)\nimport Test.Framework.Providers.QuickCheck2 (testProperty)\nimport Test.QuickCheck.Arbitrary\n\nimport Data.Vec\n\ninstance Arbitrary a => Arbitrary (Vec a) where\n  arbitrary = Vec <$> arbitrary <*> arbitrary <*> arbitrary\n\ntests :: [Test]\ntests = [\n  testProperty "addition of Vec is associative." $\n  \\u v w ->  u+(v+w) == (u+v)+ (w :: Vec Integer) ,\n  testProperty "addition of Vec is commutative." $\n  \\u v ->  u+v == v + (u :: Vec Integer),\n  testProperty "zero." $\n  \\v ->  v +0  == (v :: Vec Integer),\n  testProperty "one." $\n  \\v ->  1*v  == (v :: Vec Integer),\n  testProperty "negate." $\n  \\v ->  v - v == (0 :: Vec Integer),\n  testProperty "distributive vector." $\n  \\a u v ->  fromInteger a*(u+v)  ==fromInteger  a*u +fromInteger  a * (v :: Vec Integer),\n  testProperty "distributive scalar." $\n  \\a b v ->  fromInteger (a+b)*v  == fromInteger a*v+fromInteger b* (v :: Vec Integer),\n  testProperty "commutative scalar product." $\n  \\a b v ->  fromInteger (a*b)*v  == fromInteger a* (fromInteger b* (v :: Vec Integer)),\n  testProperty "inner product is zero for perpendicular vector." $\n  \\x y -> Vec x 0 0 \xe3\x83\xbb Vec 0 y 0 == (0::Integer),\n  testProperty "outer product is zero for parallel vector." $\n  \\x1 x2 -> Vec x1 0 0 \xc3\x97 Vec x2 0 0 == (0::Vec Integer)\n        ]\n\nmain :: IO ()\nmain = defaultMain tests\n'