b'{-# LANGUAGE OverloadedStrings #-}\n\n-- |\n-- Module      : Hoodle.ModelAction.File\n-- Copyright   : (c) 2011-2014 Ian-Woo Kim\n--\n-- License     : BSD3\n-- Maintainer  : Ian-Woo Kim <ianwookim@gmail.com>\n-- Stability   : experimental\n-- Portability : GHC\nmodule Hoodle.ModelAction.Text where\n\nimport Control.Applicative (many, (<|>))\nimport Data.Attoparsec.Text\n  ( Parser,\n    isEndOfLine,\n    manyTill,\n    notInClass,\n    parseOnly,\n    skipWhile,\n    string,\n    try,\n  )\nimport qualified Data.Attoparsec.Text as A\nimport Data.Char (isAlphaNum)\nimport qualified Data.HashMap.Strict as M\nimport qualified Data.Text as T\n\n-- |\ngetLinesFromText :: (Int, Int) -> T.Text -> T.Text\ngetLinesFromText (i, e) = T.unlines . Prelude.drop (i - 1) . Prelude.take e . T.lines\n\n{-\n-- |\ngetKeywordContent :: T.Text -- ^ keyword\n                  -> T.Text -- ^ tex file\n                  -> Maybe T.Text -- ^ subpart\ngetKeywordContent k txt = M.lookup k (getKeywordMap txt)\n-}\n\n-- |\ngetKeywordMap :: T.Text -> M.HashMap T.Text T.Text\ngetKeywordMap txt = case parseOnly (many keywordContents) txt of\n  Left _err -> M.empty\n  Right lst -> M.fromList lst\n\n-- |\nkeywordBegin :: Parser T.Text\nkeywordBegin =\n  skipWhile (notInClass "%")\n    *> ( try\n           ( string "%h%k " *> A.skipSpace\n               *> A.takeWhile1 isAlphaNum\n               <* A.skipWhile (not . isEndOfLine)\n               <* A.endOfLine\n           )\n           <|> (oneline *> keywordBegin)\n       )\n\n-- |\nkeywordEnd :: Parser ()\nkeywordEnd = string "%h%k%end" >> skipWhile (notInClass "\\r\\n") >> A.endOfLine\n\n-- |\noneline :: Parser T.Text\noneline = A.takeWhile (not . isEndOfLine) <* A.endOfLine\n\n-- |\nkeywordContents ::\n  -- | (keyword,contents)\n  Parser (T.Text, T.Text)\nkeywordContents = do\n  k <- keywordBegin\n  txt <- T.unlines <$> manyTill oneline keywordEnd\n  return (k, txt)\n\n-- |\nextractKeyword :: T.Text -> Maybe T.Text\nextractKeyword txt =\n  case T.unpack txt of\n    \'e\' : \'m\' : \'b\' : \'e\' : \'d\' : \'l\' : \'a\' : \'t\' : \'e\' : \'x\' : \':\' : \'k\' : \'e\' : \'y\' : \'w\' : \'o\' : \'r\' : \'d\' : \':\' : xs -> Just (T.pack xs)\n    _ -> Nothing\n'