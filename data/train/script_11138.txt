b'using System;\nusing System.Diagnostics;\n\nnamespace CS_SQLite3\n{\n  public partial class CSSQLite\n  {\n    /*\n    ** 2008 Jan 22\n    **\n    ** The author disclaims copyright to this source code.  In place of\n    ** a legal notice, here is a blessing:\n    **\n    **    May you do good and not evil.\n    **    May you find forgiveness for yourself and forgive others.\n    **    May you share freely, never taking more than you give.\n    **\n    *************************************************************************\n    **\n    ** $Id: fault.c,v 1.11 2008/09/02 00:52:52 drh Exp $\n    **\n    *************************************************************************\n    **  Included in SQLite3 port to C#-SQLite;  2008 Noah B Hart\n    **  C#-SQLite is an independent reimplementation of the SQLite software library\n    **\n    **  $Header$\n    *************************************************************************\n    */\n\n    /*\n    ** This file contains code to support the concept of "benign"\n    ** malloc failures (when the xMalloc() or xRealloc() method of the\n    ** sqlite3_mem_methods structure fails to allocate a block of memory\n    ** and returns 0).\n    **\n    ** Most malloc failures are non-benign. After they occur, SQLite\n    ** abandons the current operation and returns an error code (usually\n    ** SQLITE_NOMEM) to the user. However, sometimes a fault is not necessarily\n    ** fatal. For example, if a malloc fails while resizing a hash table, this\n    ** is completely recoverable simply by not carrying out the resize. The\n    ** hash table will continue to function normally.  So a malloc failure\n    ** during a hash table resize is a benign fault.\n    */\n\n    //#include "sqliteInt.h"\n\n#if !SQLITE_OMIT_BUILTIN_TEST\n    /*\n** Global variables.\n*/\n    //typedef struct BenignMallocHooks BenignMallocHooks;\n    public struct BenignMallocHooks//\n    {\n      public void_function xBenignBegin;//void (*xBenignBegin)(void);\n      public void_function xBenignEnd;    //void (*xBenignEnd)(void);\n      public BenignMallocHooks( void_function xBenignBegin, void_function xBenignEnd )\n      {\n        this.xBenignBegin = xBenignBegin;\n        this.xBenignEnd = xBenignEnd;\n      }\n    }\n    static BenignMallocHooks sqlite3Hooks = new BenignMallocHooks( null, null );\n\n    /* The "wsdHooks" macro will resolve to the appropriate BenignMallocHooks\n    ** structure.  If writable static data is unsupported on the target,\n    ** we have to locate the state vector at run-time.  In the more common\n    ** case where writable static data is supported, wsdHooks can refer directly\n    ** to the "sqlite3Hooks" state vector declared above.\n    */\n#if SQLITE_OMIT_WSD\n//# define wsdHooksInit \\\nBenignMallocHooks *x = &GLOBAL(BenignMallocHooks,sqlite3Hooks)\n//# define wsdHooks x[0]\n#else\n    //# define wsdHooksInit\n    static void wsdHooksInit() { }\n    //# define wsdHooks sqlite3Hooks\n    static BenignMallocHooks wsdHooks = sqlite3Hooks;\n#endif\n\n\n\n    /*\n** Register hooks to call when sqlite3BeginBenignMalloc() and\n** sqlite3EndBenignMalloc() are called, respectively.\n*/\n    static void sqlite3BenignMallocHooks(\n    void_function xBenignBegin, //void (*xBenignBegin)(void),\n    void_function xBenignEnd //void (*xBenignEnd)(void)\n    )\n    {\n      wsdHooksInit();\n      wsdHooks.xBenignBegin = xBenignBegin;\n      wsdHooks.xBenignEnd = xBenignEnd;\n    }\n\n    /*\n    ** This (sqlite3EndBenignMalloc()) is called by SQLite code to indicate that\n    ** subsequent malloc failures are benign. A call to sqlite3EndBenignMalloc()\n    ** indicates that subsequent malloc failures are non-benign.\n    */\n    static void sqlite3BeginBenignMalloc()\n    {\n      wsdHooksInit();\n      if ( wsdHooks.xBenignBegin != null )\n      {\n        wsdHooks.xBenignBegin();\n      }\n    }\n    static void sqlite3EndBenignMalloc()\n    {\n      wsdHooksInit();\n      if ( wsdHooks.xBenignEnd != null )\n      {\n        wsdHooks.xBenignEnd();\n      }\n    }\n#endif //* SQLITE_OMIT_BUILTIN_TEST */\n  }\n}\n'