b'// UVa1640 The Counting Problem\n// Rujia Liu\n// The meaning of f is slightly different from the book\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\n\n// cnt[i] is the number of occurrence of EVERY digit, among all i-digit numbers (leading zeros ALLOWED)\n// for examples, there are 1000 3-digit numbers, each digit 0~9 has occurred 300 times, so cnt[3] = 300\nint pow10[10], cnt[10];\n\n// how many times digit d occurred in 0~n-1\n// numbers in 0~4567 can be divided into the following patterns:\n// fewer digits   : *, n*, n** (n means non-zero digit)\n// smaller digit 0: 1***, 2***, 3***\n// smaller digit 1: 40**, 41**, 42**, 43**, 44**\n// smaller digit 2: 450*, 451*, ...\nint f(int d, int n) {\n  char s[10];\n  sprintf(s, "%d", n);\n  int len = strlen(s);\n  int ans = 0;\n\n  // fewer digits\n  for(int i = 1; i < len; i++) {\n    if(i == 1) ans++; // single digit\n    else {\n      ans += 9 * cnt[i-1];  // leading with another digit\n      if(d > 0) ans += pow10[i-1]; // leading with digit d\n    }\n  }\n\n  int pre[10]; // pre[i] is the occurrence of digit d in s[0~i]\n  for(int i = 0; i < len; i++) {\n    pre[i] = (s[i] - \'0\' == d ? 1 : 0);\n    if(i > 0) pre[i] += pre[i-1];\n  }\n\n  for(int i = 0; i < len; i++) {\n    // smaller digit i\n    int maxd = s[i] - \'0\' - 1;\n    int mind = 0;\n    if(i == 0 && len > 1) mind = 1; // no leading zeros allowed\n    for(int digit = mind; digit <= maxd; digit++) {\n      ans += cnt[len-i-1];\n      if(i > 0) ans += pre[i-1] * pow10[len-i-1];\n      if(digit == d) ans += pow10[len-i-1];\n    }\n  }\n  return ans;\n}\n\nint main() {\n  pow10[0] = 1;\n  for(int i = 1; i <= 8; i++) {\n    pow10[i] = pow10[i-1] * 10;\n    cnt[i] = pow10[i-1] * i;\n  }\n\n  int a, b;\n  while(scanf("%d%d", &a, &b) == 2 && a && b) {\n    if(a > b) swap(a, b);\n    for(int d = 0; d < 10; d++) {\n      if(d) printf(" ");\n      printf("%d", f(d, b+1) - f(d, a));\n    }\n    printf("\\n");\n  }\n  return 0;\n}\n'