b"module Hoodle.Web.Pen where\n\nimport Control.Monad.IO.Class (MonadIO (liftIO))\nimport Control.Monad.State (MonadState (get), modify')\nimport Data.Foldable (toList)\nimport Data.Hashable (hash)\nimport Data.Sequence (Seq, ViewR (..), viewr, (|>))\nimport Hoodle.Web.Default (nextevent)\nimport qualified Hoodle.Web.ForeignJS as J\nimport Hoodle.Web.Type.Coroutine (MainCoroutine)\nimport Hoodle.Web.Type.Event (UserEvent (..))\nimport Hoodle.Web.Type.State\n  ( hdlstateOverlayCanvas,\n    hdlstateOverlayOffCanvas,\n    hdlstateOverlayUpdated,\n    hdlstateSVGBox,\n    hdlstateSyncState,\n    hdlstateWebSocket,\n    syncstateQueue,\n  )\nimport Hoodle.Web.Util\n  ( sendBinary,\n    transformPathFromCanvasToSVG,\n  )\nimport Lens.Micro ((.~), (^.))\nimport Message (C2SMsg (NewStroke))\n\ndrawingMode :: Seq (Double, Double) -> MainCoroutine ()\ndrawingMode cxys = do\n  ev <- nextevent\n  case ev of\n    PointerMove cxy@(cx, cy) -> do\n      s <- get\n      let cvs = s ^. hdlstateOverlayCanvas\n          offcvs = s ^. hdlstateOverlayOffCanvas\n      case viewr cxys of\n        _ :> (cx0, cy0) -> liftIO $ J.js_overlay_point cvs offcvs cx0 cy0 cx cy\n        _ -> pure ()\n      modify' (hdlstateOverlayUpdated .~ True)\n      drawingMode (cxys |> cxy)\n    PointerUp cxy -> do\n      s <- get\n      let svg = s ^. hdlstateSVGBox\n          sock = s ^. hdlstateWebSocket\n      let cxys' = cxys |> cxy\n      path <- liftIO $ transformPathFromCanvasToSVG svg (toList cxys')\n      modify'\n        ( (hdlstateSyncState . syncstateQueue .~ [path])\n            . (hdlstateOverlayUpdated .~ True)\n        )\n      let hsh = hash path\n          msg = NewStroke (hsh, path)\n      liftIO $ sendBinary sock msg\n    _ -> drawingMode cxys\n"