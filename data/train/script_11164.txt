b'-- | Unit testing support for tasty, inspired by the HUnit package.\n--\n-- Here\'s an example (a single tasty test case consisting of three\n-- assertions):\n--\n-- >import Test.Tasty\n-- >import Test.Tasty.HUnit\n-- >\n-- >main = defaultMain $\n-- >  testCase "Example test case" $ do\n-- >    -- assertion no. 1 (passes)\n-- >    2 + 2 @?= 4\n-- >    -- assertion no. 2 (fails)\n-- >    assertBool "the list is not empty" $ null [1]\n-- >    -- assertion no. 3 (would have failed, but won\'t be executed because\n-- >    -- the previous assertion has already failed)\n-- >    "foo" @?= "bar"\n{-# LANGUAGE TypeFamilies, DeriveDataTypeable #-}\nmodule Test.Tasty.HUnit\n  (\n    -- * Constructing test cases\n    testCase\n  , testCaseInfo\n  , testCaseSteps\n    -- * Constructing assertions\n  , assertFailure\n  , assertBool\n  , assertEqual\n  , (@=?)\n  , (@?=)\n  , (@?)\n  , AssertionPredicable(..)\n    -- * Data types\n  , Assertion\n  , HUnitFailure(..)\n    -- * Accurate location for domain-specific assertion functions\n    -- | It is common to define domain-specific assertion functions based\n    -- on the standard ones, e.g.\n    --\n    -- > assertNonEmpty = assertBool "List is empty" . not . null\n    --\n    -- The problem is that if a test fails, tasty-hunit will point to the\n    -- definition site of @assertNonEmpty@ as the source of failure, not\n    -- its use site.\n    --\n    -- To correct this, add a \'HasCallStack\' constraint (re-exported from\n    -- this module) to your function:\n    --\n    -- > assertNonEmpty :: HasCallStack => [a] -> Assertion\n    -- > assertNonEmpty = assertBool "List is empty" . not . null\n    --\n    , HasCallStack\n    -- * Deprecated functions and types\n    -- | These definitions come from HUnit, but I don\'t see why one would\n    -- need them. If you have a valid use case for them, please contact me\n    -- or file an issue for tasty. Otherwise, they will eventually be\n    -- removed.\n  , assertString\n  , Assertable(..)\n  , AssertionPredicate\n  ) where\n\nimport Test.Tasty.Providers\n\nimport Test.Tasty.HUnit.Orig\nimport Test.Tasty.HUnit.Steps\n\nimport Data.Typeable\nimport Data.CallStack (HasCallStack)\nimport Control.Exception\n\n-- | Turn an \'Assertion\' into a tasty test case\ntestCase :: TestName -> Assertion -> TestTree\ntestCase name = singleTest name . TestCase . (fmap (const ""))\n\n-- | Like \'testCase\', except in case the test succeeds, the returned string\n-- will be shown as the description. If the empty string is returned, it\n-- will be ignored.\ntestCaseInfo :: TestName -> IO String -> TestTree\ntestCaseInfo name = singleTest name . TestCase\n\n-- IO String is a computation that throws an exception upon failure or\n-- returns an informational string otherwise. This allows us to unify the\n-- implementation of \'testCase\' and \'testCaseInfo\'.\n--\n-- In case of testCase, we simply make the result string empty, which makes\n-- tasty ignore it.\nnewtype TestCase = TestCase (IO String)\n    deriving Typeable\n\ninstance IsTest TestCase where\n  run _ (TestCase assertion) _ = do\n  -- The standard HUnit\'s performTestCase catches (almost) all exceptions.\n  --\n  -- This is bad for a few reasons:\n  -- - it interferes with timeout handling\n  -- - it makes exception reporting inconsistent across providers\n  -- - it doesn\'t provide enough information for ingredients such as\n  -- tasty-rerun\n  --\n  -- So we do it ourselves.\n    hunitResult <- try assertion\n    return $\n      case hunitResult of\n        Right info -> testPassed info\n        Left (HUnitFailure mbloc message) -> testFailed $ prependLocation mbloc message\n\n  testOptions = return []\n'