b'module Database.Beam.Postgres.Test.Migrate where\n\nimport Database.Beam\nimport Database.Beam.Postgres\nimport Database.Beam.Postgres.Migrate\nimport Database.Beam.Postgres.PgCrypto (PgCrypto)\nimport Database.Beam.Postgres.Test\nimport Database.Beam.Migrate\nimport Database.Beam.Migrate.Simple\n\nimport Data.ByteString (ByteString)\nimport Data.Text (Text)\n\nimport Test.Tasty\nimport Test.Tasty.HUnit\n\ntests :: IO ByteString -> TestTree\ntests postgresConn =\n    testGroup "Migration tests"\n      [ charWidthVerification postgresConn "VARCHAR" varchar\n      , charNoWidthVerification postgresConn "VARCHAR" varchar\n      , charWidthVerification postgresConn "CHAR" char\n      , charNoWidthVerification postgresConn "CHAR" char\n      , extensionVerification postgresConn\n      ]\n\ndata CharT f\n    = CharT { vcKey :: C f Text }\n      deriving (Generic, Beamable)\n\ninstance Table CharT where\n    data PrimaryKey CharT f = VcKey (C f Text)\n      deriving (Generic, Beamable)\n\n    primaryKey = VcKey . vcKey\n\ndata CharDb entity\n    = CharDb\n    { vcTbl :: entity (TableEntity CharT) }\n    deriving (Generic, Database Postgres)\n\ndata CryptoDb entity\n    = CryptoDb\n    { cryptoExtension :: entity (PgExtensionEntity PgCrypto) }\n    deriving (Generic, Database Postgres)\n\n-- | Verifies that \'verifySchema\' correctly checks the width of\n-- @VARCHAR@ or @CHAR@ columns.\ncharWidthVerification :: IO ByteString -> String -> (Maybe Word -> DataType Postgres Text) -> TestTree\ncharWidthVerification pgConn tyName charTy =\n    testCase ("verifySchema correctly checks width of " ++ tyName ++ "(n) columns (#274)") $ do\n      withTestPostgres "db_char_width" pgConn $ \\conn -> do\n        runBeamPostgres conn $ do\n          db <- executeMigration runNoReturn\n                  (CharDb <$> createTable "char_test"\n                                    (CharT (field "key" (charTy (Just 10)) notNull)))\n\n          res <- verifySchema migrationBackend db\n\n          case res of\n            VerificationSucceeded -> return ()\n            VerificationFailed failures -> fail ("Verification failed: " ++ show failures)\n\n-- | Verifies that \'verifySchema\' correctly checks the width of\n-- @VARCHAR@ or @CHAR@ columns without any max width\ncharNoWidthVerification :: IO ByteString -> String -> (Maybe Word -> DataType Postgres Text) -> TestTree\ncharNoWidthVerification pgConn tyName charTy =\n    testCase ("verifySchema correctly checks width of " ++ tyName ++ " columns (#274)") $ do\n      withTestPostgres "db_char_no_width" pgConn $ \\conn -> do\n        runBeamPostgres conn $ do\n          db <- executeMigration runNoReturn\n                  (CharDb <$> createTable "char_test"\n                                    (CharT (field "key" (charTy Nothing) notNull)))\n\n          res <- verifySchema migrationBackend db\n\n          case res of\n            VerificationSucceeded -> return ()\n            VerificationFailed failures -> fail ("Verification failed: " ++ show failures)\n\n-- | Verifies that \'verifySchema\' correctly checks enabled PgCrypto extension\nextensionVerification :: IO ByteString -> TestTree\nextensionVerification pgConn =\n    testCase "verifySchema correctly checks enabled PgCrypto extension" $\n      withTestPostgres "db_extension_pgcrypto" pgConn $ \\conn ->\n        runBeamPostgres conn $ do\n          let migration = CryptoDb <$> pgCreateExtension\n          dbBefore <- executeMigration (const $ return ()) migration\n          resBefore <- verifySchema migrationBackend dbBefore\n          case resBefore of\n            VerificationSucceeded -> fail "Verification succeeded before migration when it should have failed"\n            VerificationFailed _ -> return ()\n\n          dbAfter <- executeMigration runNoReturn migration\n          resAfter <- verifySchema migrationBackend dbAfter\n          case resAfter of\n            VerificationSucceeded -> return ()\n            VerificationFailed failures -> fail ("Verification failed: " ++ show failures)\n'