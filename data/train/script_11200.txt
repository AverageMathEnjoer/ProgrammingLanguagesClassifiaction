b"module DFS where\n\nimport           Control.Monad       (forM_)\nimport           Control.Monad.Extra (whenM)\nimport           Control.Monad.State (State, evalState, execState, get, gets, modify, put)\n\n-- void dfs(int from, int[][] g, boolean[] visited) {\n--     visited[from] = true;\n--     for (int u : g[from]) {\n--         if (!visited[u]) dfs(u, g, visitied);\n--     }\n-- }\n-- holy shh...\n\ntype Vertex = Int\ntype Graph  = [[Vertex]]\n\ndfs :: Vertex -> Vertex -> Graph -> Bool\ndfs from to graph = evalState (reach from) []\n  where\n    -- state represented as list of visited vertices\n    reach :: Vertex -> State [Vertex] Bool\n    reach v\n        | v == to   = return True\n        | otherwise = get >>= \\visited ->\n                      if v `elem` visited\n                      then return False\n                      else put (v:visited) >>\n                           or <$> mapM reach (graph !! v)\n\ndfs' :: Vertex -> Vertex -> Graph -> Bool\ndfs' from to graph = to `elem` execState (visit from) []\n  where\n    visit :: Vertex -> State [Vertex] ()\n    visit v = whenM (gets $ notElem v) $ do\n        modify (v:)\n        forM_ (graph !! v) visit\n\ng1 :: Graph\ng1 = [ [1, 2, 3]  -- 0\n     , [0, 5]     -- 1\n     , [0, 5]     -- 2\n     , [0, 4]     -- 3\n     , [3, 5]     -- 4\n     , [1, 2, 3]  -- 5\n     , [7]        -- 6\n     , [6]        -- 7\n     ]\n\ng2 :: Graph\ng2 = [[]]\n\ng3 :: Graph\ng3 = [[1], [0]]\n\ng4 :: Graph\ng4 = [[1, 2], [0], [0]]\n"