b'{-# LANGUAGE Arrows #-}\n-- |\n-- Copyright  : (c) Ivan Perez and Manuel Baerenz, 2016\n-- License    : BSD3\n-- Maintainer : ivan.perez@keera.co.uk\n--\n-- The \'Maybe\' monad is very versatile. It can stand for default arguments,\n-- for absent values, and for (nondescript) exceptions. The latter viewpoint\n-- is most natural in the context of \'MSF\'s.\nmodule Control.Monad.Trans.MSF.Maybe\n    ( module Control.Monad.Trans.MSF.Maybe\n    , module Control.Monad.Trans.Maybe\n    , maybeToExceptS\n    )\n  where\n\n-- External imports\nimport Control.Arrow             (returnA, (>>>), arr)\nimport Control.Monad.Trans.Maybe hiding (liftCallCC, liftCatch, liftListen,\n                                  liftPass)\n\n-- Internal imports\nimport Control.Monad.Trans.MSF.Except (ExceptT, exceptS, listToMSFExcept,\n                                       maybeToExceptS, reactimateExcept,\n                                       runExceptT, runMSFExcept, safe, safely,\n                                       try)\nimport Data.MonadicStreamFunction     (MSF, arrM, constM, liftTransS, morphS)\n\n-- * Throwing \'Nothing\' as an exception ("exiting")\n\n-- | Throw the exception immediately.\nexit :: Monad m => MSF (MaybeT m) a b\nexit = constM $ MaybeT $ return Nothing\n\n-- | Throw the exception when the condition becomes true on the input.\nexitWhen :: Monad m => (a -> Bool) -> MSF (MaybeT m) a a\nexitWhen condition = proc a -> do\n  _ <- exitIf -< condition a\n  returnA     -< a\n\n-- | Exit when the incoming value is \'True\'.\nexitIf :: Monad m => MSF (MaybeT m) Bool ()\nexitIf = proc condition -> if condition\n  then exit    -< ()\n  else returnA -< ()\n\n-- | @Just a@ is passed along, \'Nothing\' causes the whole \'MSF\' to exit.\nmaybeExit :: Monad m => MSF (MaybeT m) (Maybe a) a\nmaybeExit = inMaybeT\n\n-- | Embed a \'Maybe\' value in the \'MaybeT\' layer. Identical to \'maybeExit\'.\ninMaybeT :: Monad m => MSF (MaybeT m) (Maybe a) a\ninMaybeT = arrM $ MaybeT . return\n\n-- * Catching Maybe exceptions\n\n-- | Run the first @msf@ until the second one produces \'True\' from the output\n-- of the first.\nuntilMaybe :: Monad m => MSF m a b -> MSF m b Bool -> MSF (MaybeT m) a b\nuntilMaybe msf cond = proc a -> do\n  b <- liftTransS msf  -< a\n  c <- liftTransS cond -< b\n  inMaybeT -< if c then Nothing else Just b\n\n-- | When an exception occurs in the first \'msf\', the second \'msf\' is executed\n-- from there.\ncatchMaybe :: (Functor m, Monad m)\n           => MSF (MaybeT m) a b\n           -> MSF m a b\n           -> MSF m a b\ncatchMaybe msf1 msf2 = safely $ do\n  _ <- try $ maybeToExceptS msf1\n  safe msf2\n\n-- * Converting to and from \'MaybeT\'\n\n-- | Convert exceptions into `Nothing`, discarding the exception value.\nexceptToMaybeS :: (Functor m, Monad m)\n               => MSF (ExceptT e m) a b\n               -> MSF (MaybeT m) a b\nexceptToMaybeS =\n  morphS $ MaybeT . fmap (either (const Nothing) Just) . runExceptT\n\n-- | Converts a list to an \'MSF\' in \'MaybeT\', which outputs an element of the\n-- list at each step, throwing \'Nothing\' when the list ends.\nlistToMaybeS :: (Functor m, Monad m) => [b] -> MSF (MaybeT m) a b\nlistToMaybeS = exceptToMaybeS . runMSFExcept . listToMSFExcept\n\n-- * Running \'MaybeT\'\n\n-- | Remove the \'MaybeT\' layer by outputting \'Nothing\' when the exception\n-- occurs. The continuation in which the exception occurred is then tested on\n-- the next input.\nrunMaybeS :: (Functor m, Monad m) => MSF (MaybeT m) a b -> MSF m a (Maybe b)\nrunMaybeS msf = exceptS (maybeToExceptS msf) >>> arr eitherToMaybe\n  where\n    eitherToMaybe (Left ()) = Nothing\n    eitherToMaybe (Right b) = Just b\n\n-- | Reactimates an \'MSF\' in the \'MaybeT\' monad until it throws \'Nothing\'.\nreactimateMaybe :: (Functor m, Monad m)\n                => MSF (MaybeT m) () ()\n                -> m ()\nreactimateMaybe msf = reactimateExcept $ try $ maybeToExceptS msf\n\n-- | Run an \'MSF\' fed from a list, discarding results. Useful when one needs to\n-- combine effects and streams (i.e., for testing purposes).\nembed_ :: (Functor m, Monad m) => MSF m a () -> [a] -> m ()\nembed_ msf as = reactimateMaybe $ listToMaybeS as >>> liftTransS msf\n'