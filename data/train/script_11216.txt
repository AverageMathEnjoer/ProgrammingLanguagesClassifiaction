b'module FFI.Anything.TH where\n\nimport Language.Haskell.TH\n\nimport Debug.Trace\n\n\n\n\nparameters :: Type -> [Type]  -- Result list are "ground" types\nparameters t = case t of\n  AppT t1 t2 -> parameters t1 ++ parameters t2\n  ArrowT     -> []\n  ConT name  -> [ConT name]\n  -- TODO handle ListT, TupleT and so on\n  _          -> error $ "parameters: unhandled Type " ++ show t\n\n\n-- TODO better use custom data type, tuples are quite finite\nargTypesToTuple :: [Type] -> Type\nargTypesToTuple types = foldl f (TupleT n) types\n  where\n    f a next = AppT a next\n    n = length types\n\n\ndebug :: (Show a, Monad m) => a -> m ()\ndebug x = trace ("\\n" ++ show x ++ "\\n") $ return ()\n\n\nderiveCallable :: Name -> String -> Q [Dec]\nderiveCallable funName exportedName = do\n  info <- reify funName\n  case info of\n    VarI name typ _mDec -> do\n      let _nameString   = nameBase name\n          signatureList = parameters typ\n          paramTypes    = init signatureList\n          returnType    = last signatureList\n\n          typ\' = [ SigD\n                     (mkName exportedName)\n                     (AppT\n                       (AppT\n                         ArrowT\n                         (argTypesToTuple paramTypes)\n                       )\n                       returnType\n                     )\n                 ]\n\n      debug typ\'\n      debug $ pprint typ\'\n      return []\n\n    _ -> error "deriveCallable: can only derive functions"\n\n\n-- Example:\n--\n--   VarI\n--     -- Name\n--     FFI.Anything.f\n--     -- Type\n--     (AppT (AppT ArrowT (ConT GHC.Types.Int)) (AppT (AppT ArrowT (ConT GHC.Types.Double)) (ConT GHC.Base.String)))\n--     -- Maybe Dec\n--     Nothing\n--     -- Fixity\n--     (Fixity 9 InfixL)\n--\n-- Where the type "f :: Int -> Double -> String" is:\n--\n--   AppT\n--     (AppT ArrowT (ConT GHC.Types.Int))\n--     (AppT\n--       (AppT ArrowT (ConT GHC.Types.Double))\n--       (ConT GHC.Base.String)\n--     )\n--\n--\n-- The target is: runQ f_hs :: (Int, Double) -> String\n-- so e.g.:\n--\n--   runQ [d| f_hs :: (Int, Double) -> String; f_hs = f_hs |]\n--\n-- which is:\n--\n--   [ SigD  -- This is the type\n--       f_hs\n--       (AppT\n--         (AppT\n--           ArrowT\n--           (AppT\n--             (AppT (TupleT 2) (ConT GHC.Types.Int))\n--             (ConT GHC.Types.Double)\n--           )\n--         )\n--         (ConT GHC.Base.String)\n--       )\n--   , ValD  -- This is the unimportant `f_hs = f_hs` part needed for the quasiquoter to complile\n--       (VarP f_hs_2)\n--       (NormalB (VarE f_hs_2))\n--       []\n--   ]\n'