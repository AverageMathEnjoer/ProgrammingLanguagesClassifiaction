b'\xef\xbb\xbfusing System.IO;\nusing System;\nusing System.ComponentModel;\nusing System.Threading.Tasks;\nusing System.Net;\nusing System.Diagnostics;\nusing System.Threading;\n\nnamespace Aerial\n{\n    public class Caching\n    {\n        public static string TempFolder = "";\n        public static string CacheFolder = new RegSettings().CacheLocation;\n\n        public static int DelayAmount = 1000 * 10; // 10 seconds.\n        public static int NumOfCurrentDownloads = 0;\n\n\n\n        /// <summary>\n        /// Init cache. Clear partially downloaded files from temp folder.\n        /// </summary>\n        internal static void Setup()\n        {\n            // If there is no location stored in the Registry, use the default location\n            if (string.IsNullOrWhiteSpace(CacheFolder))\n            {\n                CacheFolder = Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.LocalApplicationData), "Aerial");\n            }\n            TempFolder = Path.Combine(CacheFolder, "temp");\n\n            // Ensure folders exist\n            Directory.CreateDirectory(CacheFolder);\n            Directory.CreateDirectory(TempFolder);\n\n            // Delete partial temp files if any \n            foreach (var file in Directory.CreateDirectory(TempFolder).GetFiles())\n            {\n                file.Delete();\n            }\n        }\n\n        internal static bool IsHit(string url)\n        {\n            string filename = Path.GetFileName(url);\n            return File.Exists(Path.Combine(CacheFolder, filename));\n        }\n\n        internal static bool IsCaching(string url)\n        {\n            string filename = Path.GetFileName(url);\n            return File.Exists(Path.Combine(TempFolder, filename));\n        }\n\n        internal static string Get(string url)\n        {\n            string filename = Path.GetFileName(url);\n            return Path.Combine(CacheFolder, filename);\n        }\n\n        internal static void StartDelayedCache(string url)\n        {\n            if (EnsureEnoughSpace())\n            {\n                Task.Delay(DelayAmount).ContinueWith(t =>\n                {\n                    if (!IsCaching(url))\n                    {\n                        using (WebClient client = new WebClient())\n                        {\n                            client.DownloadFileCompleted += new AsyncCompletedEventHandler(OnDownloadFileComplete);\n                            string filename = Path.GetFileName(url);\n                            client.DownloadFileAsync(new Uri(url), Path.Combine(TempFolder, filename), filename);\n                            DownloadStart();\n                        }\n                    }\n                });\n            }\n        }\n        private static void OnDownloadFileComplete(object sender, AsyncCompletedEventArgs e)\n        {\n            var filename = e.UserState.ToString();\n            var tempFullPath = Path.Combine(TempFolder, filename);\n            var cacheFullpath = Path.Combine(CacheFolder, filename);\n            if (e.Cancelled == false && e.Error == null)\n            {\n                // delete if old file exists\n                if (File.Exists(cacheFullpath))\n                    File.Delete(cacheFullpath);\n\n                Directory.Move(tempFullPath, cacheFullpath);\n            }\n            else\n            {\n                // attempt to remove partially downloaded file\n                File.Delete(tempFullPath);\n            }\n\n            DownloadEnd();\n            \n        }\n\n        internal static async void UpdateCachePath(string oldCacheDirectory, string cacheLocation)\n        {\n            if (oldCacheDirectory == cacheLocation) return;\n            CacheFolder = cacheLocation;\n\n            // Move old cache to new location if space allows\n            var currentCacheSpace = GetDirectorySize(oldCacheDirectory);\n            if (currentCacheSpace < CacheSpace() - (1000 * 1000 * 1000))\n            {\n                // Note might take a while, hanging the save dialog\n                // video blocks this command: Directory.Move(oldCacheDirectory, cacheLocation);\n                foreach (var f in Directory.GetFiles(oldCacheDirectory))\n                {\n                    var newfile = Path.Combine(cacheLocation, Path.GetFileName(f));\n                    if (!File.Exists(newfile))\n                        await Task.Factory.StartNew(() => File.Move(f, newfile));\n\n                }\n            }\n\n            DeleteCache(oldCacheDirectory);\n\n            // Delete old cache\n            try\n            {\n                await Task.Factory.StartNew(() => Directory.Delete(oldCacheDirectory, true));\n            }\n            catch (UnauthorizedAccessException)\n            {\n                // Leave dir for now.\n                // todo - windows removes all files after the video player stops using them,\n                // yet leaves the folder, we need to redo this operation in 3 mins, for example.\n            }\n        }\n\n        public static async void DeleteCache(string folder = null)\n        {\n            if (folder == null) folder = CacheFolder;\n            foreach (var f in Directory.GetFiles(folder))\n            {\n                try\n                {\n                    await Task.Factory.StartNew(() => File.Delete(f));\n                }\n                catch (UnauthorizedAccessException ex)\n                {\n                    // video may be used while deleting\n                    Trace.WriteLine("Access denied while moving cached files " + ex);\n                }\n            }\n        }\n\n        public static long CacheSpace()\n        {\n            foreach (var drive in DriveInfo.GetDrives())\n            {\n                if (CacheFolder.StartsWith(drive.Name))\n                    return drive.TotalFreeSpace;\n            }\n            return 0;\n        }\n\n        public static long GetDirectorySize(string path = null)\n        {\n            if (path == null) path = CacheFolder;\n            long size = 0;\n            if (Directory.Exists(path)) \n                foreach (string name in Directory.GetFiles(path, "*.*"))\n                    size += new FileInfo(name).Length;\n\n            return size;\n        }\n\n        /// <summary>\n        ///  Ensures the drive with user folder has more than 1 gig space left.\n        /// </summary>\n        /// <returns></returns>\n        private static bool EnsureEnoughSpace()\n        {\n            return CacheSpace() > 1000000000;\n        }\n\n        public static string TryHit(string url)\n        {\n            if (IsHit(url))\n                return Get(url);\n            return url;\n        }\n\n        private static void DownloadStart()\n        {\n            Interlocked.Increment(ref NumOfCurrentDownloads);\n        }\n\n        private static void DownloadEnd()\n        {\n            Interlocked.Decrement(ref NumOfCurrentDownloads);\n        }\n    }\n}'