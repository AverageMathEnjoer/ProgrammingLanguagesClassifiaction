b'{-# LANGUAGE GADTs #-}\n{-# LANGUAGE OverloadedStrings #-}\n{-# LANGUAGE RecordWildCards #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n{-# OPTIONS_GHC -fno-warn-incomplete-uni-patterns #-}\n\nmodule Hoodle.Coroutine.Page where\n\nimport Control.Concurrent.STM (atomically)\nimport Control.Lens (set, view, (.~), (?~), (^.))\nimport Control.Monad (when)\nimport Control.Monad.State (get, gets, liftIO, put)\nimport Control.Monad.Trans.Reader (ask)\nimport Data.Either (fromRight)\nimport qualified Data.Foldable as F\nimport Data.Function (on)\nimport Data.Hoodle.Generic\n  ( gbackground,\n    gbuffer,\n    gdimension,\n    gembeddedpdf,\n    gitems,\n    glayers,\n    gpages,\n    pdfNumPages,\n  )\nimport Data.Hoodle.Select (gselAll)\nimport Data.Hoodle.Simple (Dimension (..))\nimport Data.Hoodle.Zipper (fromNonEmptyList)\nimport qualified Data.IntMap as M\nimport Data.List (sortBy)\nimport Data.Maybe (fromMaybe)\nimport Graphics.Hoodle.Render.Type\n  ( GenCommand (BkgSmplScaled, LayerScaled),\n    LyBuf (..),\n    PDFCommand (RenderPageScaled),\n    RBackground (..),\n    RHoodle,\n    RLayer,\n    Renderer,\n    RendererState (..),\n    emptyRLayer,\n    issueGenCommandID,\n    issuePDFCommandID,\n    issueSurfaceID,\n    sendGenCommand,\n    sendPDFCommand,\n  )\nimport Hoodle.Accessor\n  ( getCurrentPageCvsId,\n    getGeometry4CurrCvs,\n    updateUhdl,\n  )\nimport Hoodle.Coroutine.Commit (commit_)\nimport Hoodle.Coroutine.Draw\n  ( callRenderer_,\n    invalidateAll,\n    invalidateAllInBBox,\n    invalidateInBBox,\n  )\nimport Hoodle.Coroutine.Scroll\n  ( adjustScrollbarWithGeometryCurrent,\n    adjustScrollbarWithGeometryCvsId,\n  )\nimport Hoodle.ModelAction.Page (relZoomRatio, setPage, updatePageAll)\nimport Hoodle.Type.Alias (EditMode, Hoodle, Page)\nimport Hoodle.Type.Canvas\n  ( CanvasId,\n    CanvasInfo (..),\n    CanvasInfoBox (CanvasContPage, CanvasSinglePage),\n    canvasId,\n    currentPageNum,\n    drawArea,\n    forBoth\',\n    pageArrangement,\n    unboxBiAct,\n    unboxLens,\n    viewInfo,\n    zoomMode,\n  )\nimport Hoodle.Type.Coroutine (MainCoroutine)\nimport Hoodle.Type.Enum\n  ( AddDirection (PageAfter, PageBefore),\n    BackgroundStyle,\n    DrawFlag (Efficient),\n    NewPageModeType (NPCycle, NPLast, NPPlain),\n    ZoomModeRel,\n    convertBackgroundStyleToByteString,\n  )\nimport Hoodle.Type.HoodleState\n  ( HoodleModeState (SelectState, ViewAppendState),\n    UnitHoodle,\n    backgroundStyle,\n    currentCanvasInfo,\n    currentUnit,\n    cvsInfoMap,\n    getCanvasInfo,\n    getCurrentCanvasId,\n    getHoodle,\n    hoodleModeState,\n    hoodleModeStateEither,\n    modifyCanvasInfo,\n    newPageMode,\n    nextPdfBkgPageNum,\n    settings,\n    unitHoodles,\n  )\nimport Hoodle.Type.PageArrangement\n  ( CanvasCoordinate (..),\n    PageCoordinate (..),\n    PageDimension (..),\n    PageNum (..),\n    ZoomMode (Zoom),\n    makeContinuousArrangement,\n    makeSingleArrangement,\n  )\nimport Hoodle.Util (maybeError\', msgShout)\nimport Hoodle.View.Coordinate\n  ( CanvasGeometry,\n    canvasDim,\n    desktop2Canvas,\n    getCvsGeomFrmCvsInfo,\n    getCvsOriginInPage,\n    makeCanvasGeometry,\n    page2Desktop,\n  )\n\n-- | change page of current canvas using a modify function\nchangePage :: (Int -> Int) -> MainCoroutine ()\nchangePage modifyfn =\n  gets (view backgroundStyle) >>= \\bsty ->\n    updateUhdl (changePageAction bsty)\n      >> adjustScrollbarWithGeometryCurrent\n      >> invalidateAllInBBox Nothing Efficient\n  where\n    changePageAction bsty uhdl =\n      unboxBiAct (fsingle bsty uhdl) (fcont bsty uhdl)\n        . (^. currentCanvasInfo)\n        $ uhdl\n    fsingle bsty uhdl cvsInfo = do\n      let xojst = view hoodleModeState uhdl\n          npgnum = modifyfn (cvsInfo ^. currentPageNum)\n          cid = view canvasId cvsInfo\n      (b, npgnum\', _, xojst\') <- changePageInHoodleModeState bsty npgnum xojst\n      uhdl\' <- liftIO $ updatePageAll xojst\' uhdl\n      ncvsInfo <- liftIO $ setPage uhdl\' (PageNum npgnum\') cid\n      let uhdlfinal = (currentCanvasInfo .~ ncvsInfo) uhdl\'\n      when b $ updateUhdl (const (return uhdlfinal)) >> commit_\n      return uhdlfinal\n    fcont bsty uhdl cvsInfo = do\n      let xojst = view hoodleModeState uhdl\n          npgnum = modifyfn (cvsInfo ^. currentPageNum)\n          cid = cvsInfo ^. canvasId\n      (b, npgnum\', _, xojst\') <- changePageInHoodleModeState bsty npgnum xojst\n      uhdl\' <- liftIO $ updatePageAll xojst\' uhdl\n      ncvsInfo <- liftIO $ setPage uhdl\' (PageNum npgnum\') cid\n      let uhdlfinal = (currentCanvasInfo .~ ncvsInfo) uhdl\'\n      when b $ updateUhdl (const (return uhdlfinal)) >> commit_\n      return uhdlfinal\n\n-- |\nchangePageInHoodleModeState ::\n  BackgroundStyle ->\n  -- | new page number\n  Int ->\n  HoodleModeState ->\n  MainCoroutine (Bool, Int, Page EditMode, HoodleModeState)\nchangePageInHoodleModeState bsty npgnum hdlmodst = do\n  let ehdl = hoodleModeStateEither hdlmodst\n      pgs = either (view gpages) (view gselAll) ehdl\n      totnumpages = M.size pgs\n      lpage = maybeError\' "changePage" (M.lookup (totnumpages - 1) pgs)\n  (isChanged, npgnum\', npage\', ehdl\') <-\n    if npgnum >= totnumpages\n      then do\n        let cbkg = view gbackground lpage\n        nbkg <- newBkg bsty cbkg\n        npage <- set gbackground nbkg <$> newPageFromOld lpage\n        geometry <- liftIO . getGeometry4CurrCvs . view (unitHoodles . currentUnit) =<< get\n        callRenderer_ $ updatePageCache geometry (PageNum (totnumpages - 1), npage)\n        let npages = M.insert totnumpages npage pgs\n        return\n          ( True,\n            totnumpages,\n            npage,\n            either (Left . set gpages npages) (Right . set gselAll npages) ehdl\n          )\n      else do\n        let npg = if npgnum < 0 then 0 else npgnum\n            pg = maybeError\' "changePage" (M.lookup npg pgs)\n        return (False, npg, pg, ehdl)\n  return (isChanged, npgnum\', npage\', either ViewAppendState SelectState ehdl\')\n\n-- |\ncanvasZoomUpdateGenRenderCvsId ::\n  MainCoroutine () ->\n  CanvasId ->\n  Maybe ZoomMode ->\n  Maybe (PageNum, PageCoordinate) ->\n  MainCoroutine ()\ncanvasZoomUpdateGenRenderCvsId renderfunc cid mzmode mcoord = do\n  updateUhdl zoomUpdateAction\n  adjustScrollbarWithGeometryCvsId cid\n  xst <- get\n  let uhdl = view (unitHoodles . currentUnit) xst\n      hdl = getHoodle uhdl\n  geometry <- liftIO (getGeometry4CurrCvs uhdl)\n  let cpn = view (unboxLens currentPageNum) . getCanvasInfo cid $ uhdl\n  let plst = sortBy (compare `on` (\\(n, _) -> abs (n - cpn))) . zip [0 ..] . F.toList $ hdl ^. gpages\n  F.forM_ plst $ \\(pn, pg) -> callRenderer_ (updatePageCache geometry (PageNum pn, pg))\n  renderfunc\n  where\n    zoomUpdateAction uhdl =\n      unboxBiAct (fsingle uhdl) (fcont uhdl) . getCanvasInfo cid $ uhdl\n    fsingle uhdl cinfo = do\n      geometry <- liftIO $ getCvsGeomFrmCvsInfo cinfo\n      page <- getCurrentPageCvsId cid\n      let zmode = fromMaybe (cinfo ^. viewInfo . zoomMode) mzmode\n          pdim = PageDimension $ page ^. gdimension\n          xy =\n            either\n              (const (0, 0))\n              (unPageCoord . snd)\n              (getCvsOriginInPage geometry)\n          cdim = canvasDim geometry\n          narr = makeSingleArrangement zmode pdim cdim xy\n          ncinfobox =\n            CanvasSinglePage\n              . (viewInfo . pageArrangement .~ narr)\n              . (viewInfo . zoomMode .~ zmode)\n              $ cinfo\n      return . modifyCanvasInfo cid (const ncinfobox) $ uhdl\n    fcont uhdl cinfo = do\n      geometry <- liftIO $ getCvsGeomFrmCvsInfo cinfo\n      let zmode = fromMaybe (view (viewInfo . zoomMode) cinfo) mzmode\n          cpn = PageNum $ view currentPageNum cinfo\n          cdim = canvasDim geometry\n          hdl = getHoodle uhdl\n          origcoord = case mcoord of\n            Just coord -> coord\n            Nothing ->\n              fromRight (cpn, PageCoord (0, 0)) (getCvsOriginInPage geometry)\n          narr = makeContinuousArrangement zmode cdim hdl origcoord\n          ncinfobox =\n            CanvasContPage\n              . (viewInfo . pageArrangement .~ narr)\n              . (viewInfo . zoomMode .~ zmode)\n              $ cinfo\n      return . modifyCanvasInfo cid (const ncinfobox) $ uhdl\n\n-- |\ncanvasZoomUpdateCvsId ::\n  CanvasId ->\n  Maybe ZoomMode ->\n  MainCoroutine ()\ncanvasZoomUpdateCvsId cid mzmode =\n  canvasZoomUpdateGenRenderCvsId invalidateAll cid mzmode Nothing\n\n-- |\ncanvasZoomUpdateBufAll :: MainCoroutine ()\ncanvasZoomUpdateBufAll = do\n  klst <- gets (M.keys . view cvsInfoMap . view (unitHoodles . currentUnit))\n  mapM_ updatefunc klst\n  where\n    updatefunc cid =\n      canvasZoomUpdateGenRenderCvsId (invalidateInBBox Nothing Efficient cid) cid Nothing Nothing\n\n-- |\ncanvasZoomUpdateAll :: MainCoroutine ()\ncanvasZoomUpdateAll = do\n  klst <- gets (M.keys . view cvsInfoMap . view (unitHoodles . currentUnit))\n  mapM_ (`canvasZoomUpdateCvsId` Nothing) klst\n\n-- |\ncanvasZoomUpdate :: Maybe ZoomMode -> MainCoroutine ()\ncanvasZoomUpdate mzmode = do\n  cid <- gets (getCurrentCanvasId . view (unitHoodles . currentUnit))\n  canvasZoomUpdateCvsId cid mzmode\n\n-- |\npageZoomChange :: ZoomMode -> MainCoroutine ()\npageZoomChange = canvasZoomUpdate . Just\n\n-- |\npageZoomChangeRel :: ZoomModeRel -> MainCoroutine ()\npageZoomChangeRel rzmode = do\n  forBoth\' unboxBiAct fsingle . view currentCanvasInfo . view (unitHoodles . currentUnit) =<< get\n  where\n    fsingle :: CanvasInfo a -> MainCoroutine ()\n    fsingle cinfo = do\n      let cpn = PageNum (cinfo ^. currentPageNum)\n          arr = cinfo ^. viewInfo . pageArrangement\n          canvas = cinfo ^. drawArea\n      geometry <- liftIO $ makeCanvasGeometry cpn arr canvas\n      let nratio = relZoomRatio geometry rzmode\n      pageZoomChange (Zoom nratio)\n\n-- |\nnewPage :: Maybe Dimension -> AddDirection -> MainCoroutine ()\nnewPage mdim dir =\n  gets (view backgroundStyle) >>= \\bsty ->\n    updateUhdl (npgBfrAct bsty)\n      >> commit_\n      >> canvasZoomUpdateAll\n      >> invalidateAll\n  where\n    npgBfrAct bsty uhdl = forBoth\' unboxBiAct (fsimple bsty uhdl) . view currentCanvasInfo $ uhdl\n    fsimple :: BackgroundStyle -> UnitHoodle -> CanvasInfo a -> MainCoroutine UnitHoodle\n    fsimple bsty uhdl cinfo = do\n      case view hoodleModeState uhdl of\n        ViewAppendState hdl -> do\n          hdl\' <- addNewPageInHoodle mdim bsty dir hdl (view currentPageNum cinfo)\n          liftIO . updatePageAll (ViewAppendState hdl\')\n            . set hoodleModeState (ViewAppendState hdl\')\n            $ uhdl\n        SelectState _ -> do\n          msgShout "newPage: not implemented yet"\n          return uhdl\n\n-- | delete current page of current canvas\ndeleteCurrentPage :: MainCoroutine ()\ndeleteCurrentPage =\n  updateUhdl delpgact\n    >> commit_\n    >> canvasZoomUpdateAll\n    >> invalidateAll\n  where\n    delpgact uhdl = forBoth\' unboxBiAct (fsimple uhdl) . view currentCanvasInfo $ uhdl\n    fsimple :: UnitHoodle -> CanvasInfo a -> MainCoroutine UnitHoodle\n    fsimple uhdl cinfo = do\n      case view hoodleModeState uhdl of\n        ViewAppendState hdl -> do\n          hdl\' <-\n            liftIO $\n              deletePageInHoodle\n                hdl\n                (PageNum (view currentPageNum cinfo))\n          liftIO . updatePageAll (ViewAppendState hdl\')\n            . set hoodleModeState (ViewAppendState hdl\')\n            $ uhdl\n        SelectState _ -> do\n          msgShout "deleteCurrentPage: not implemented yet"\n          return uhdl\n\n-- | delete designated page\ndeletePageInHoodle :: Hoodle EditMode -> PageNum -> IO (Hoodle EditMode)\ndeletePageInHoodle hdl (PageNum pgn) = do\n  let pagelst = M.elems . view gpages $ hdl\n      (pagesbefore, _cpage : pagesafter) = splitAt pgn pagelst\n      npagelst = pagesbefore ++ pagesafter\n      nhdl = set gpages (M.fromList . zip [0 ..] $ npagelst) hdl\n  return nhdl\n\n-- |\naddNewPageInHoodle ::\n  Maybe Dimension ->\n  BackgroundStyle ->\n  AddDirection ->\n  Hoodle EditMode ->\n  Int ->\n  MainCoroutine (Hoodle EditMode)\naddNewPageInHoodle mdim bsty dir hdl cpn = do\n  let pagelst = M.elems . view gpages $ hdl\n      (pagesbefore, cpage : pagesafter) = splitAt cpn pagelst\n      cbkg = view gbackground cpage\n  nbkg <- newBkg bsty cbkg\n  npage <- maybe id (set gdimension) mdim . set gbackground nbkg <$> newPageFromOld cpage\n  geometry <- liftIO . getGeometry4CurrCvs . view (unitHoodles . currentUnit) =<< get\n  callRenderer_ (updatePageCache geometry (PageNum cpn, npage))\n  let npagelst = case dir of\n        PageBefore -> pagesbefore ++ (npage : cpage : pagesafter)\n        PageAfter -> pagesbefore ++ (cpage : npage : pagesafter)\n      nhdl = set gpages (M.fromList . zip [0 ..] $ npagelst) hdl\n  return nhdl\n\nnewBkg :: BackgroundStyle -> RBackground -> MainCoroutine RBackground\nnewBkg bsty bkg = do\n  xst <- get\n  let npmode = xst ^. settings . newPageMode\n      rhdl = (getHoodle . view (unitHoodles . currentUnit)) xst\n      mtotN = pdfNumPages <$> (rhdl ^. gembeddedpdf)\n  let bstystr = convertBackgroundStyleToByteString bsty\n      defbkg = RBkgSmpl "white" bstystr <$> issueSurfaceID\n  case npmode of\n    NPPlain -> defbkg\n    NPLast -> case bkg of\n      RBkgSmpl c _ _ -> RBkgSmpl c bstystr <$> issueSurfaceID\n      RBkgPDF d f n pg _ -> RBkgPDF d f n pg <$> issueSurfaceID\n      RBkgEmbedPDF n pg _ -> RBkgEmbedPDF n pg <$> issueSurfaceID\n    NPCycle ->\n      case mtotN of\n        Nothing -> defbkg\n        Just totN -> do\n          let n1 = fromMaybe 1 (xst ^. nextPdfBkgPageNum)\n          case findPDFBkg rhdl n1 of\n            Nothing -> defbkg\n            Just bkg\' ->\n              issueSurfaceID >>= \\i -> do\n                let n\' = if n1 >= totN then 1 else n1 + 1\n                put ((nextPdfBkgPageNum ?~ n\') xst)\n                return bkg\' {rbkg_surfaceid = i}\n\nfindPDFBkg :: RHoodle -> Int -> Maybe RBackground\nfindPDFBkg rhdl n1 =\n  let bkgs = M.elems (rhdl ^. gpages)\n      pagematch n (RBkgPDF _ _ n\' _ _) = n == n\'\n      pagematch n (RBkgEmbedPDF n\' _ _) = n == n\'\n      pagematch _ _ = False\n      matched = (filter (pagematch n1) . map (^. gbackground)) bkgs\n   in case matched of\n        [] -> Nothing\n        b : _ -> Just b\n\n-- |\nnewPageFromOld :: Page EditMode -> MainCoroutine (Page EditMode)\nnewPageFromOld pg = do\n  sfcid <- issueSurfaceID\n  return . (glayers .~ fromNonEmptyList (emptyRLayer sfcid, [])) $ pg\n\nupdatePageCache :: CanvasGeometry -> (PageNum, Page EditMode) -> Renderer ()\nupdatePageCache geometry (pnum, page) = do\n  let Dim w h = page ^. gdimension\n      CvsCoord (x0, y0) =\n        (desktop2Canvas geometry . page2Desktop geometry) (pnum, PageCoord (0, 0))\n      CvsCoord (x1, y1) =\n        (desktop2Canvas geometry . page2Desktop geometry) (pnum, PageCoord (w, h))\n  updateBkgCache (Dim w h) (Dim (x1 - x0) (y1 - y0)) (page ^. gbackground)\n  mapM_ (updateLayerCache (Dim w h) (Dim (x1 - x0) (y1 - y0))) (F.toList (page ^. glayers))\n\nupdateBkgCache :: Dimension -> Dimension -> RBackground -> Renderer ()\nupdateBkgCache dimo dimv rbkg = do\n  RendererState _handler qpdf qgen _ <- ask\n  let sfcid = rbkg_surfaceid rbkg\n  case rbkg of\n    RBkgSmpl {..} -> do\n      cmdid <- issueGenCommandID\n      (liftIO . atomically) (sendGenCommand qgen cmdid (BkgSmplScaled sfcid rbkg_color rbkg_style dimo dimv))\n      return ()\n    _ -> F.forM_ (rbkg_popplerpage rbkg) $ \\pg -> do\n      cmdid <- issuePDFCommandID\n      (liftIO . atomically) (sendPDFCommand qpdf cmdid (RenderPageScaled sfcid pg dimo dimv))\n      return ()\n\nupdateLayerCache :: Dimension -> Dimension -> RLayer -> Renderer ()\nupdateLayerCache dimo dimv lyr = do\n  RendererState _ _ qgen _ <- ask\n  case view gbuffer lyr of\n    LyBuf sfcid -> do\n      cmdid <- issueGenCommandID\n      (liftIO . atomically) (sendGenCommand qgen cmdid (LayerScaled sfcid (view gitems lyr) dimo dimv))\n      return ()\n'