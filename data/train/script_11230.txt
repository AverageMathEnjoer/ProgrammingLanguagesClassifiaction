b'{-# LANGUAGE GeneralizedNewtypeDeriving, MultiParamTypeClasses #-}\n\n{- LANGUAGE RankNTypes, NamedFieldPuns, BangPatterns,\n             ExistentialQuantification, CPP, ScopedTypeVariables,\n             TypeSynonymInstances, ,\n             GeneralizedNewtypeDeriving, RecordWildCards\n\t     -}\n\n-- | This is a degenerate scheduler in which fork corresponds directly\n--   to forkIO.\n\nmodule Control.Monad.Par.Scheds.IOThreads (\n    Par, IVar(..), \n    runPar, \n    new, get, put_, fork,\n    newFull, newFull_, put,\n    spawn, spawn_, spawnP\n--                   spawn1_, \n ) where\n\nimport Control.Applicative (Applicative, (<$>))\nimport Control.Concurrent hiding (yield)\nimport qualified Control.Monad.Par.Class as PC\nimport Control.DeepSeq (NFData, deepseq)\nimport Data.IORef\nimport GHC.IO (unsafePerformIO, unsafeDupablePerformIO)\n\n--------------------------------------------------------------------------------\n-- This implementation is naturally very short:\n\nnewtype Par a = Par { unPar :: IO a }\n deriving (Monad, Functor, Applicative)\n\nnewtype IVar a = IVar (IORef (IVarContents a))\ndata IVarContents a = Full a | Empty | Blocked (MVar a) \n\nfork (Par task) = Par $ do forkIO task; return ()\n\nget (IVar ref) = Par $ do   \n  -- Optimistically, let\'s assume it\'s either full or we\'re not the first one to block:\n  x <- readIORef ref\n  case x of \n    Full v     -> return v\n    Blocked mv -> readMVar mv\n    Empty      -> do  \n      -- Ok, no luck, we need to allocate an MVar, which might be wasted:\n      mv <- newEmptyMVar\n      b <- atomicModifyIORef ref $ \\ new ->\n            case new of \n              Empty       -> (Blocked mv, Right mv)\n              -- Otherwise someone raced in and changed it!:\n              Blocked mv2 -> (new,        Right mv2)\n              Full a      -> (new,        Left  a )\n      case b of \n        Left a   -> return a\n        Right mv -> readMVar mv\n\nput_ (IVar ref) val = Par $ do\n  mmv <- atomicModifyIORef ref $ \\ old -> \n    case old of \n      Empty      -> (Full val, Nothing)\n      Full a     -> error "Multiple writes to IVar!"\n      Blocked mv -> (Full val, Just mv)\n  case mmv of   \n    Nothing -> return ()\n    Just mv -> putMVar mv val\n\nnew          = Par $ IVar <$> newIORef Empty\nnewFull_ val = Par $ IVar <$> newIORef (Full val)\n\nrunPar = unsafePerformIO . unPar\n\n--------------------------------------------------------------------------------\n-- Boilerplate and instances shared across schedulers:\n--------------------------------------------------------------------------------\n\nput iv val = deepseq val $ put_ iv val\n\nnewFull :: NFData a => a -> Par (IVar a)\nnewFull a = deepseq a (newFull a)\n\n-- Here we use the same mechanism an in Spark.hs:\nspawnP :: NFData a => a -> Par (IVar a)\nspawnP val = do mv <- new \n                fork (put mv val)                \n                return mv\n\nspawn p  = do r <- new;  fork (p >>= put r);   return r\nspawn_ p = do r <- new;  fork (p >>= put_ r);  return r\n\n\nfork   :: Par () -> Par ()\nspawn  :: NFData a => Par a -> Par (IVar a)\nspawn_ :: Par a -> Par (IVar a)\nput_   :: IVar a -> a -> Par ()\nput    :: NFData a => IVar a -> a -> Par ()\nget    :: IVar a -> Par a\nrunPar :: Par a -> a \nnewFull_ ::  a -> Par (IVar a)\n\ninstance PC.ParFuture IVar Par where\n  get    = get\n  spawn  = spawn\n  spawn_ = spawn_\n  spawnP = spawnP\n\ninstance PC.ParIVar IVar Par where\n  fork = fork\n  new  = new\n  put_ = put_\n  newFull = newFull\n  newFull_ = newFull_\n'