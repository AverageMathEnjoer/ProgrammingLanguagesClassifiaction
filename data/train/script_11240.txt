b'package com.db.williamchart.view\n\nimport android.annotation.SuppressLint\nimport android.content.Context\nimport android.content.res.TypedArray\nimport android.graphics.Canvas\nimport android.graphics.Typeface\nimport android.util.AttributeSet\nimport android.view.GestureDetector\nimport android.view.MotionEvent\nimport android.view.ViewGroup\nimport android.widget.FrameLayout\nimport androidx.core.content.res.ResourcesCompat\nimport androidx.core.view.GestureDetectorCompat\nimport androidx.core.view.doOnPreDraw\nimport com.db.williamchart.ChartContract\nimport com.db.williamchart.ExperimentalFeature\nimport com.db.williamchart.Labels\nimport com.db.williamchart.Grid\nimport com.db.williamchart.Painter\nimport com.db.williamchart.R\nimport com.db.williamchart.Tooltip\nimport com.db.williamchart.animation.ChartAnimation\nimport com.db.williamchart.animation.DefaultAnimation\nimport com.db.williamchart.data.AxisType\nimport com.db.williamchart.data.configuration.ChartConfiguration\nimport com.db.williamchart.data.DataPoint\nimport com.db.williamchart.data.Frame\nimport com.db.williamchart.data.Scale\nimport com.db.williamchart.extensions.obtainStyledAttributes\nimport com.db.williamchart.plugin.AxisGrid\nimport com.db.williamchart.plugin.AxisLabels\nimport com.db.williamchart.plugin.GridEffect\nimport com.db.williamchart.plugin.GridType\nimport com.db.williamchart.renderer.RendererConstants.Companion.notInitialized\n\n@OptIn(ExperimentalFeature::class)\nabstract class AxisChartView @JvmOverloads constructor(\n    context: Context,\n    attrs: AttributeSet? = null,\n    defStyleAttr: Int = 0\n) : FrameLayout(context, attrs, defStyleAttr) {\n\n    var labelsSize: Float = defaultLabelsSize\n\n    var labelsColor: Int = -0x1000000\n\n    var labelsFont: Typeface? = null\n\n    var axis: AxisType = AxisType.XY\n\n    var scale: Scale = Scale(notInitialized, notInitialized)\n\n    var labelsFormatter: (Float) -> String = { it.toString() }\n\n    var animation: ChartAnimation<DataPoint> = DefaultAnimation()\n\n    val labels: Labels = AxisLabels()\n\n    var tooltip: Tooltip = object : Tooltip {\n        override fun onCreateTooltip(parentView: ViewGroup) {}\n        override fun onDataPointTouch(x: Float, y: Float) {}\n        override fun onDataPointClick(x: Float, y: Float) {}\n    }\n\n    @ExperimentalFeature\n    var grid: Grid = object : Grid {\n        override fun draw(\n            canvas: Canvas,\n            innerFrame: Frame,\n            xLabelsPositions: List<Float>,\n            yLabelsPositions: List<Float>\n        ) {\n        }\n    }\n\n    @ExperimentalFeature\n    var onDataPointClickListener: (index: Int, x: Float, y: Float) -> Unit = { _, _, _ -> }\n\n    @ExperimentalFeature\n    var onDataPointTouchListener: (index: Int, x: Float, y: Float) -> Unit = { _, _, _ -> }\n\n    protected lateinit var canvas: Canvas\n\n    protected val painter: Painter = Painter(labelsFont = labelsFont)\n\n    /**\n     * Initialized in init function by chart views extending [AxisChartView] (e.g. [LineChartView])\n     */\n    protected lateinit var renderer: ChartContract.Renderer\n\n    private val gestureDetector: GestureDetectorCompat =\n        GestureDetectorCompat(\n            this.context,\n            object : GestureDetector.SimpleOnGestureListener() {\n                override fun onDown(e: MotionEvent?): Boolean = true\n                override fun onSingleTapConfirmed(e: MotionEvent?): Boolean {\n                    val (index, x, y) = renderer.processClick(e?.x, e?.y)\n                    return if (index != -1) {\n                        onDataPointClickListener(index, x, y)\n                        tooltip.onDataPointClick(x, y)\n                        true\n                    } else false\n                }\n            }\n        )\n\n    init {\n        handleAttributes(obtainStyledAttributes(attrs, R.styleable.ChartAttrs))\n        doOnPreDraw { tooltip.onCreateTooltip(this) }\n    }\n\n    override fun onAttachedToWindow() {\n        super.onAttachedToWindow()\n        this.setWillNotDraw(false)\n        // style.init()\n    }\n\n    override fun onDetachedFromWindow() {\n        super.onDetachedFromWindow()\n        // style.clean()\n    }\n\n    override fun onMeasure(widthMeasureSpec: Int, heightMeasureSpec: Int) {\n        super.onMeasure(widthMeasureSpec, heightMeasureSpec)\n\n        val widthMode = MeasureSpec.getMode(widthMeasureSpec)\n        val heightMode = MeasureSpec.getMode(heightMeasureSpec)\n\n        setMeasuredDimension(\n            if (widthMode == MeasureSpec.AT_MOST) defaultFrameWidth else widthMeasureSpec,\n            if (heightMode == MeasureSpec.AT_MOST) defaultFrameHeight else heightMeasureSpec\n        )\n    }\n\n    override fun onDraw(canvas: Canvas) {\n        super.onDraw(canvas)\n        this.canvas = canvas\n        renderer.draw()\n    }\n\n    @SuppressLint("ClickableViewAccessibility")\n    override fun onTouchEvent(event: MotionEvent?): Boolean {\n        val (index, x, y) = renderer.processTouch(event?.x, event?.y)\n        if (index != -1) {\n            onDataPointTouchListener(index, x, y)\n            tooltip.onDataPointTouch(x, y)\n        }\n        return if (gestureDetector.onTouchEvent(event)) true\n        else super.onTouchEvent(event)\n    }\n\n    abstract val chartConfiguration: ChartConfiguration\n\n    @Deprecated("New method receives a List<Pair<String, Float>> as argument.")\n    fun show(entries: LinkedHashMap<String, Float>) {\n        doOnPreDraw { renderer.preDraw(chartConfiguration) }\n        renderer.render(entries.toList())\n    }\n\n    @Deprecated("New method receives a List<Pair<String, Float>> as argument.")\n    fun animate(entries: LinkedHashMap<String, Float>) {\n        doOnPreDraw { renderer.preDraw(chartConfiguration) }\n        renderer.anim(entries.toList(), animation)\n    }\n\n    fun show(entries: List<Pair<String, Float>>) {\n        doOnPreDraw { renderer.preDraw(chartConfiguration) }\n        renderer.render(entries)\n    }\n\n    fun animate(entries: List<Pair<String, Float>>) {\n        doOnPreDraw { renderer.preDraw(chartConfiguration) }\n        renderer.anim(entries, animation)\n    }\n\n    private fun handleAttributes(typedArray: TypedArray) {\n        typedArray.apply {\n\n            // Customize Axis\n            axis = when (getString(R.styleable.ChartAttrs_chart_axis)) {\n                "0" -> AxisType.NONE\n                "1" -> AxisType.X\n                "2" -> AxisType.Y\n                else -> AxisType.XY\n            }\n\n            // Customize Labels\n            labelsSize = getDimension(R.styleable.ChartAttrs_chart_labelsSize, labelsSize)\n\n            labelsColor = getColor(R.styleable.ChartAttrs_chart_labelsColor, labelsColor)\n\n            if (hasValue(R.styleable.ChartAttrs_chart_labelsFont) && !isInEditMode) {\n                labelsFont =\n                    ResourcesCompat.getFont(\n                        context,\n                        getResourceId(R.styleable.ChartAttrs_chart_labelsFont, -1)\n                    )\n                painter.labelsFont = labelsFont\n            }\n\n            // Customize Grid\n            if (hasValue(R.styleable.ChartAttrs_chart_grid)) {\n                grid = AxisGrid().apply {\n                    this.gridType = when (getString(R.styleable.ChartAttrs_chart_grid)) {\n                        "0" -> GridType.FULL\n                        "1" -> GridType.VERTICAL\n                        "2" -> GridType.HORIZONTAL\n                        else -> GridType.FULL\n                    }\n                    this.color = getColor(R.styleable.ChartAttrs_chart_gridColor, color)\n                    this.strokeWidth =\n                        getDimension(R.styleable.ChartAttrs_chart_gridStrokeWidth, strokeWidth)\n                    this.gridEffect =\n                        when (getString(R.styleable.ChartAttrs_chart_gridEffect)) {\n                            "0" -> GridEffect.SOLID\n                            "1" -> GridEffect.DASHED\n                            "2" -> GridEffect.DOTTED\n                            else -> GridEffect.SOLID\n                        }\n                }\n            }\n\n            recycle()\n        }\n    }\n\n    protected fun handleEditMode() {\n        if (isInEditMode) {\n            show(editModeSampleData)\n        }\n    }\n\n    companion object {\n        private const val defaultFrameWidth = 200\n        private const val defaultFrameHeight = 100\n        private const val defaultLabelsSize = 60F\n        private val editModeSampleData =\n            listOf(\n                "Label1" to 1f,\n                "Label2" to 7.5f,\n                "Label3" to 4.7f,\n                "Label4" to 3.5f\n            )\n    }\n}\n'