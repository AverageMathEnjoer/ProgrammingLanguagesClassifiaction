b'{-# LANGUAGE DeriveDataTypeable, FlexibleInstances, TypeSynonymInstances #-}\n\n-- required for HasCallStack by different versions of GHC\n{-# LANGUAGE ConstraintKinds, FlexibleContexts #-}\n\n-- | This is the code copied from the original hunit package (v. 1.2.5.2).\n-- with minor modifications\nmodule Test.Tasty.HUnit.Orig where\n\nimport qualified Control.Exception as E\nimport Control.Monad\nimport Data.Typeable (Typeable)\nimport Data.CallStack\n\n-- Interfaces\n-- ----------\n\n-- | An assertion is simply an \'IO\' action. Assertion failure is indicated\n-- by throwing an exception, typically \'HUnitFailure\'.\n--\n-- Instead of throwing the exception directly, you should use\n-- functions like \'assertFailure\' and \'assertBool\'.\n--\n-- Test cases are composed of a sequence of one or more assertions.\n\ntype Assertion = IO ()\n\n-- | Unconditionally signals that a failure has occured.  All\n-- other assertions can be expressed with the form:\n--\n-- @\n--    if conditionIsMet\n--        then return ()\n--        else assertFailure msg\n-- @\n\nassertFailure\n  :: HasCallStack\n  => String -- ^ A message that is displayed with the assertion failure\n  -> IO a\nassertFailure msg = E.throwIO (HUnitFailure location msg)\n  where\n    location :: Maybe SrcLoc\n    location = case reverse callStack of\n      (_, loc) : _ -> Just loc\n      [] -> Nothing\n\n-- Conditional Assertion Functions\n-- -------------------------------\n\n-- | Asserts that the specified condition holds.\nassertBool\n  :: HasCallStack\n  => String    -- ^ The message that is displayed if the assertion fails\n  -> Bool      -- ^ The condition\n  -> Assertion\nassertBool msg b = unless b (assertFailure msg)\n\n-- | Asserts that the specified actual value is equal to the expected value.\n-- The output message will contain the prefix, the expected value, and the\n-- actual value.\n--\n-- If the prefix is the empty string (i.e., @\\"\\"@), then the prefix is omitted\n-- and only the expected and actual values are output.\nassertEqual\n  :: (Eq a, Show a, HasCallStack)\n  => String -- ^ The message prefix\n  -> a      -- ^ The expected value\n  -> a      -- ^ The actual value\n  -> Assertion\nassertEqual preface expected actual =\n  unless (actual == expected) (assertFailure msg)\n where msg = (if null preface then "" else preface ++ "\\n") ++\n             "expected: " ++ show expected ++ "\\n but got: " ++ show actual\n\ninfix  1 @?, @=?, @?=\n\n-- | Asserts that the specified actual value is equal to the expected value\n--   (with the expected value on the left-hand side).\n(@=?)\n  :: (Eq a, Show a, HasCallStack)\n  => a -- ^ The expected value\n  -> a -- ^ The actual value\n  -> Assertion\nexpected @=? actual = assertEqual "" expected actual\n\n-- | Asserts that the specified actual value is equal to the expected value\n--   (with the actual value on the left-hand side).\n(@?=)\n  :: (Eq a, Show a, HasCallStack)\n  => a -- ^ The actual value\n  -> a -- ^ The expected value\n  -> Assertion\nactual @?= expected = assertEqual "" expected actual\n\n-- | An infix and flipped version of \'assertBool\'. E.g. instead of\n--\n-- >assertBool "Non-empty list" (null [1])\n--\n-- you can write\n--\n-- >null [1] @? "Non-empty list"\n--\n-- \'@?\' is also overloaded to accept @\'IO\' \'Bool\'@ predicates, so instead\n-- of\n--\n-- > do\n-- >   e <- doesFileExist "test"\n-- >   e @? "File does not exist"\n--\n-- you can write\n--\n-- > doesFileExist "test" @? "File does not exist"\n(@?) :: (AssertionPredicable t, HasCallStack)\n  => t          -- ^ A value of which the asserted condition is predicated\n  -> String     -- ^ A message that is displayed if the assertion fails\n  -> Assertion\npredi @? msg = assertionPredicate predi >>= assertBool msg\n\n-- | An ad-hoc class used to overload the \'@?\' operator.\n--\n-- The only intended instances of this class are @\'Bool\'@ and @\'IO\' \'Bool\'@.\n--\n-- You shouldn\'t need to interact with this class directly.\nclass AssertionPredicable t\n where assertionPredicate :: t -> IO Bool\n\ninstance AssertionPredicable Bool\n where assertionPredicate = return\n\ninstance (AssertionPredicable t) => AssertionPredicable (IO t)\n where assertionPredicate = (>>= assertionPredicate)\n\n\n-- | Exception thrown by \'assertFailure\' etc.\ndata HUnitFailure = HUnitFailure (Maybe SrcLoc) String\n    deriving (Eq, Show, Typeable)\ninstance E.Exception HUnitFailure\n\nprependLocation :: Maybe SrcLoc -> String -> String\nprependLocation mbloc s =\n  case mbloc of\n    Nothing -> s\n    Just loc -> srcLocFile loc ++ ":" ++ show (srcLocStartLine loc) ++ ":\\n" ++ s\n\n----------------------------------------------------------------------\n--                          DEPRECATED CODE\n----------------------------------------------------------------------\n\n{-# DEPRECATED assertString "Why not use assertBool instead?" #-}\n{-# DEPRECATED Assertable, AssertionPredicate\n   "This class or type seems dubious. If you have a good use case for it, please create an issue for tasty. Otherwise, it may be removed in a future version." #-}\n\n-- | Signals an assertion failure if a non-empty message (i.e., a message\n-- other than @\\"\\"@) is passed.\nassertString\n  :: HasCallStack\n  => String    -- ^ The message that is displayed with the assertion failure\n  -> Assertion\nassertString s = unless (null s) (assertFailure s)\n\n-- Overloaded `assert` Function\n-- ----------------------------\n\n-- | Allows the extension of the assertion mechanism.\n--\n-- Since an \'Assertion\' can be a sequence of @Assertion@s and @IO@ actions,\n-- there is a fair amount of flexibility of what can be achieved.  As a rule,\n-- the resulting @Assertion@ should be the body of a @TestCase@ or part of\n-- a @TestCase@; it should not be used to assert multiple, independent\n-- conditions.\n--\n-- If more complex arrangements of assertions are needed, @Test@ and\n-- @Testable@ should be used.\nclass Assertable t\n where assert :: t -> Assertion\n\ninstance Assertable ()\n where assert = return\n\ninstance Assertable Bool\n where assert = assertBool ""\n\ninstance (Assertable t) => Assertable (IO t)\n where assert = (>>= assert)\n\ninstance Assertable String\n where assert = assertString\n\n\n-- Overloaded `assertionPredicate` Function\n-- ----------------------------------------\n\n-- | The result of an assertion that hasn\'t been evaluated yet.\n--\n-- Most test cases follow the following steps:\n--\n-- 1. Do some processing or an action.\n--\n-- 2. Assert certain conditions.\n--\n-- However, this flow is not always suitable.  @AssertionPredicate@ allows for\n-- additional steps to be inserted without the initial action to be affected\n-- by side effects.  Additionally, clean-up can be done before the test case\n-- has a chance to end.  A potential work flow is:\n--\n-- 1. Write data to a file.\n--\n-- 2. Read data from a file, evaluate conditions.\n--\n-- 3. Clean up the file.\n--\n-- 4. Assert that the side effects of the read operation meet certain conditions.\n--\n-- 5. Assert that the conditions evaluated in step 2 are met.\ntype AssertionPredicate = IO Bool\n\n'