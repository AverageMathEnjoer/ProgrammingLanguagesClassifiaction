b'-- K-Means sample from "Parallel and Concurrent Programming in Haskell"\n-- Simon Marlow\n-- with modifications for benchmarking: erjiang\n--\n\n{-# LANGUAGE CPP #-}\n{-# LANGUAGE DeriveDataTypeable #-}\n{-# LANGUAGE NamedFieldPuns #-}\n{-# OPTIONS_GHC -O2 -ddump-splices #-}\nimport System.IO\nimport System.IO.Unsafe\nimport Data.IORef\nimport KMeansCommon\nimport Control.Applicative\nimport Control.Monad.IO.Class (liftIO)\nimport Data.Array\nimport Text.Printf\nimport Data.Data\nimport Data.List\nimport Data.Function\nimport qualified Data.Serialize as Ser\nimport Data.Typeable\nimport qualified Data.Vector as V\nimport qualified Data.Vector.Storable as SV\nimport Data.Vector.Storable.UnsafeSerialize \nimport Debug.Trace\nimport Control.Parallel.Strategies as Strategies\nimport System.Random.MWC\nimport Control.DeepSeq\nimport System.Environment\nimport Data.Time.Clock\nimport Control.Exception\nimport Control.Monad\nimport Data.ByteString (readFile)\n\n#ifdef PARSCHED \nimport PARSCHED\n#else\nimport Control.Monad.Par\n#endif\n\nnClusters = 4\n\n-- -----------------------------------------------------------------------------\n-- K-Means: repeatedly step until convergence (sequential)\n\n-- kmeans_seq :: Int -> [Cluster] -> IO [Cluster]\n-- kmeans_seq nclusters points clusters = do\n--   let\n--       loop :: Int -> [Cluster] -> IO [Cluster]\n--       loop n clusters | n > tooMany = do printf "giving up."; return clusters\n--       loop n clusters = do\n--       --hPrintf stderr "iteration %d\\n" n\n--       --hPutStr stderr (unlines (map show clusters))\n--         let clusters\' = step nclusters clusters points\n--         if clusters\' == clusters\n--            then do\n--                printf "%d iterations\\n" n\n--                return clusters\n--            else loop (n+1) clusters\'\n--   --\n--   loop 0 clusters\n\ntooMany = 50\n\n{-# NOINLINE pointData #-}\npointData :: IORef (Maybe (V.Vector (V.Vector Point)))\npointData = unsafePerformIO $ newIORef Nothing\n\nloadPoints :: String -> IO (V.Vector (V.Vector Point))\nloadPoints filename = do\n  bin <- Data.ByteString.readFile filename\n  return $ case Ser.decode bin of\n              Left err -> error $ "Could not deserialize data: "++err\n              Right d -> V.fromList d :: V.Vector (V.Vector Point)\n\ngetChunk id = do\n  dat <- readIORef pointData\n  return $ case dat of\n    Just chunks -> chunks V.! id\n    Nothing -> error "Point data not loaded!"\n\n-- -----------------------------------------------------------------------------\n-- K-Means: repeatedly step until convergence (Par monad)\n\nsplitChunks :: (Int, Int, [Cluster]) -> Par [Cluster]\nsplitChunks (n0, nn, clusters) =\n  case nn - n0 of\n    0 -> kmeans_chunk clusters nn\n    1 -> do\n--           liftIO $ printf "local branch\\n"\n           lx <- spawn $ kmeans_chunk clusters n0\n           rx <- spawn $ kmeans_chunk clusters nn\n           l <- get lx\n           r <- get rx\n           return $ reduce nClusters [l, r]\n    otherwise -> do\n--           liftIO $ printf "longSpawn branch\\n"\n           lx <- spawn $ splitChunks (n0, (halve n0 nn), clusters)\n           rx <- spawn $ splitChunks ((halve n0 nn), nn, clusters)\n           l <- get lx\n           r <- get rx\n           return $ reduce nClusters [l, r]\n\n{-# INLINE halve #-}\nhalve :: Int -> Int -> Int\nhalve n0 nn = n0 + (div (nn - n0) 2)\n\n-- doChunks :: Int -> Int -> [Cluster] -> Par [[Cluster]]\n-- -- parMap f xs = mapM (spawnP . f) xs >>= mapM get\n-- doChunks n chunkSize clusters = mapM (spawn . return . (kmeans_chunk chunkSize clusters)) [0..(n-1)]\n--   >>= mapM get\n\n\nkmeans_chunk :: [Cluster] -> Int -> Par [Cluster]\nkmeans_chunk clusters id = do\n  let points = unsafePerformIO (getChunk id)\n  return $ step clusters points\n\n-- -----------------------------------------------------------------------------\n-- Perform one step of the K-Means algorithm\n\nreduce :: Int -> [[Cluster]] -> [Cluster]\nreduce nclusters css =\n  concatMap combine $ elems $\n     accumArray (flip (:)) [] (0,nclusters) [ (clId c, c) | c <- concat css]\n where\n  combine [] = []\n  combine (c:cs) = [foldr combineClusters c cs]\n\n{-# INLINE step #-}\nstep :: [Cluster] -> (V.Vector Point) -> [Cluster]\nstep clusters points\n   = makeNewClusters (assign clusters points)\n\n-- assign each vector to the nearest cluster centre\nassign :: [Cluster] -> (V.Vector Point) -> Array Int [Point]\nassign clusters points =\n    accumArray (flip (:)) [] (0, nclusters-1)\n       [ (clId (nearest p), p) | p <- V.toList points ]\n  where\n    nclusters = (length clusters)\n    nearest p = fst $ minimumBy (compare `on` snd)\n                          [ (c, sqDistance (clCent c) p) | c <- clusters ]\n\nmakeNewClusters :: Array Int [Point] -> [Cluster]\nmakeNewClusters arr =\n  filter ((>0) . clCount) $\n     [ makeCluster i ps | (i,ps) <- assocs arr ]\n                        -- v. important: filter out any clusters that have\n                        -- no points.  This can happen when a cluster is not\n                        -- close to any points.  If we leave these in, then\n                        -- the NaNs mess up all the future calculations.\n\nkmeans_par :: [Cluster] -> Int -> Par [Cluster]\nkmeans_par clusters nChunks = do\n  let\n      loop :: Int -> [Cluster] -> Par [Cluster]\n      loop n clusters | n > tooMany = do unsafePerformIO (printf "giving up."); return clusters\n      loop n clusters = do\n        \n     -- hPutStr stderr (unlines (map show clusters))\n        clusters\' <- trace ("iteration "++(show n)) $\n          splitChunks (0, nChunks-1, clusters)\n\n        if clusters\' == clusters\n           then return clusters\n           else loop (n+1) clusters\'\n  --\n  loop 0 clusters  \n\nmain = do\n  args <- getArgs\n  t0 <- getCurrentTime >>= newIORef\n  final_clusters <- case args of\n    [filename] -> do\n      pts <- loadPoints filename\n      writeIORef pointData (Just pts)\n      clusters <- mapM genCluster [0..nClusters-1]\n      printf "%d clusters generated\\n" (length clusters)\n      getCurrentTime >>= writeIORef t0\n      return $ runPar $ kmeans_par clusters (V.length pts)\n    other -> do\n      pts <- loadPoints "tinykmeansdata.bin"\n      writeIORef pointData (Just pts)\n      clusters <- mapM genCluster [0..3]\n      printf "%d clusters generated\\n" (length clusters)\n      return $ runPar $ kmeans_par clusters (V.length pts)\n  t1 <- getCurrentTime\n  t0t <- readIORef t0\n  print final_clusters\n  printf "SELFTIMED %.2f\\n" (realToFrac (diffUTCTime t1 t0t) :: Double)\n\n\n'