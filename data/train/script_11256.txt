b'{-# LANGUAGE OverloadedStrings, TemplateHaskell #-}\n\n\n{-\n -\n - This is probably a bit useless at the moment because the crawling is\n - untargeted, so it\'ll generate a bunch of useless links. You probably\n - want to first check whether the link leads to HTML data to get a more\n - sensible set.\n -\n - Oh, and by the way, this is nowhere near finished or polished. It\'s\n - the result of a couple of hours of hacking and then got abandoned for\n - a more fruitful, targeted (albeit manual) approach.\n -\n -}\n\nimport Control.Lens\nimport Control.Monad\nimport Data.Text (Text, unpack)\nimport Data.Text.Lazy.Encoding\nimport Data.ByteString.Lazy (ByteString)\nimport Network.Wreq\nimport Text.Taggy.Lens\nimport Network.URI\nimport Data.Maybe\nimport System.IO\nimport Data.Either\nimport Data.Set (Set)\nimport qualified Data.Set as Set\n\n\n-- Helper lenses for URI parsing\n$(makeLensesFor\n    [("uriAuthority", "uriAuthorityL")\n    ,("uriScheme", "uriSchemeL")\n    ,("uriFragment", "uriFragmentL")\n    ] \'\'URI)\n\n\n\n------------------------------------\n-- Super special fancy queue object\n-- where each element can only exist\n-- in it once ever, and it keeps track\n-- of which elements has passed\n-- through it.\n\ndata Uniqueue a =\n    Uniqueue\n        { visited :: Set a\n        , remaining :: Set a\n        }\n        deriving Show\n\nnext :: Ord a => Uniqueue a -> Maybe (a, Uniqueue a)\nnext uniqueue =\n    if Set.null (remaining uniqueue) then\n        Nothing\n    else\n        let\n            element = Set.elemAt 0 (remaining uniqueue)\n            newRemaining = Set.delete element (remaining uniqueue)\n            newVisited = Set.insert element (visited uniqueue)\n        in\n            Just (element, Uniqueue newVisited newRemaining)\n\nmember :: Ord a => a -> Uniqueue a -> Bool\nmember a uniqueue =\n    Set.member a (remaining uniqueue) || Set.member a (visited uniqueue)\n\ninsert :: Ord a => a -> Uniqueue a -> Uniqueue a\ninsert a uniqueue =\n    if member a uniqueue then\n        uniqueue\n    else\n        uniqueue { remaining = Set.insert a (remaining uniqueue) }\n\nappend :: Ord a => Set a -> Uniqueue a -> Uniqueue a\nappend aas uniqueue =\n    let\n        go aas uniqueue =\n            case aas of\n                [] -> uniqueue\n                (a:as) -> go as (insert a uniqueue)\n    in\n        go (Set.toList aas) uniqueue\n\n-- End of super fancy special queue object\n--------------------------------------------\n\n\n\n\nmain = do\n    let starting = fromJust (parseURI "http://www.sunet.se/")\n    crawled <- crawl (Uniqueue Set.empty (Set.singleton starting))\n    forM_ (visited crawled) (putStrLn . show)\n\n\n-- recursively visit all urls in the uniqueue\ncrawl :: Uniqueue URI -> IO (Uniqueue URI)\ncrawl links =\n    case next links of\n        Nothing -> return links\n        Just (link, nextUniqueue) -> do\n            putStrLn (show link)\n            newLinks <- getLinksFor link\n            crawl (append newLinks nextUniqueue)\n\n\n-- get and parse all href attributes for a page, and print errors for the\n-- unparsed ones\ngetLinksFor :: URI -> IO (Set URI)\ngetLinksFor uri = do\n    (broken, working) <- fmap (partitionEithers . extractHrefs) (get (show uri))\n    when (not (null broken)) $ do\n        hPutStrLn stderr "-----------------"\n        hPutStrLn stderr "Unparsed URIs:"\n        mapM_ (hPutStrLn stderr) broken\n        hPutStrLn stderr "-----------------"\n    return (filterInternal (fromJust (uriAuthority uri)) working)\n\n\n-- add authority to internal links, and throw out links that aren\'t internal\nfilterInternal :: URIAuth -> [URI] -> Set URI\nfilterInternal auth uris =\n    let\n        internal =\n            filter (isInternal auth) uris\n        complete =\n            internal\n                & each . uriAuthorityL .~ Just auth\n                & each . uriSchemeL .~ "http:"\n                & each . uriFragmentL .~ ""\n    in\n        Set.fromList complete\n\n-- the path and the query arguments are "the request"\ngetRequest :: URI -> String\ngetRequest uri =\n    uriPath uri ++ uriQuery uri\n\n-- If the url auth is the same as auth it\'s an internal link\nisInternal :: URIAuth -> URI -> Bool\nisInternal auth uri =\n    maybe True (== auth) (uriAuthority uri)\n\n\n-- Extract all the values of all the <a href="____"> attributes\n-- on a page and attempt to return them parsed\nextractHrefs :: Response ByteString -> [Either String URI]\nextractHrefs response =\n    let\n        document =\n            responseBody . to decodeLatin1 . html\n        hrefs =\n            allNamed (only "a") . attr "href" . _Just\n        annotateParseURI str =\n            maybe (Left str) Right (parseURIReference str)\n    in\n        response ^.. document . hrefs . to unpack . to annotateParseURI\n\n\n'