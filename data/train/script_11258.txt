b'{-# LANGUAGE CPP #-}\n{-# LANGUAGE OverloadedStrings #-}\n{-# OPTIONS_GHC -fno-warn-unused-imports -fno-warn-unused-matches #-}\n\nmodule Graphics.Hoodle.Render.Background where\n\nimport Control.Concurrent.STM\n  ( atomically,\n    newEmptyTMVarIO,\n    takeTMVar,\n  )\nimport Control.Monad (guard)\nimport Control.Monad.State (StateT, get, lift, liftIO, put)\nimport Control.Monad.Trans.Maybe (MaybeT (..))\nimport Control.Monad.Trans.Reader (ask)\nimport Data.ByteString (ByteString)\nimport Data.ByteString.Base64 (decode)\nimport qualified Data.ByteString.Char8 as C\nimport Data.Hoodle.BBox (BBox (..))\nimport Data.Hoodle.Predefined\n  ( predefinedBkgcolor,\n    predefinedRulingColor,\n    predefinedRulingGraphSpacing,\n    predefinedRulingLeftMargin,\n    predefinedRulingMarginColor,\n    predefinedRulingSpacing,\n    predefinedRulingThickness,\n    predefinedRulingTopMargin,\n  )\nimport Data.Hoodle.Simple\n  ( Background (..),\n    Dimension (..),\n  )\nimport qualified Data.Map as M\nimport Data.UUID.V4 (nextRandom)\nimport Graphics.Hoodle.Render.Type.Background\n  ( Context (..),\n    RBackground (..),\n  )\nimport Graphics.Hoodle.Render.Type.Renderer\n  ( PDFCommand (GetDocFromFile, GetPageFromDoc),\n    Renderer,\n    issuePDFCommandID,\n    issueSurfaceID,\n    rendererGenCmdQ,\n    rendererPDFCmdQ,\n    sendPDFCommand,\n  )\nimport qualified Graphics.Rendering.Cairo as Cairo\n-- import qualified Graphics.UI.Gtk.Poppler.Document as Poppler\n-- import qualified Graphics.UI.Gtk.Poppler.Page as PopplerPage\nimport System.Directory\n  ( getTemporaryDirectory,\n    removeFile,\n  )\nimport System.FilePath ((<.>), (</>))\nimport Prelude\n\n-- |\n-- popplerGetDocFromFile :: ByteString -> IO (Maybe Poppler.Document)\n-- popplerGetDocFromFile fp =\n--   Poppler.documentNewFromFile\n--     (C.unpack ("file://localhost" `mappend` fp))\n--     Nothing\n\n-- |\ngetByteStringIfEmbeddedPDF :: ByteString -> Maybe ByteString\ngetByteStringIfEmbeddedPDF bstr = do\n  guard (C.length bstr > 30)\n  let (header, dat) = C.splitAt 30 bstr\n  guard (header == "data:application/x-pdf;base64,")\n  either (const Nothing) return (decode dat)\n\n-- |\n-- popplerGetDocFromDataURI :: ByteString -> IO (Maybe Poppler.Document)\n-- popplerGetDocFromDataURI dat = do\n--   let mdecoded = getByteStringIfEmbeddedPDF dat\n--   case mdecoded of\n--     Nothing -> return Nothing\n--     Just decoded -> do\n--       uuidstr <- fmap show nextRandom\n--       tmpdir <- getTemporaryDirectory\n--       let tmpfile = tmpdir </> uuidstr <.> "pdf"\n--       C.writeFile tmpfile decoded\n--       mdoc <- popplerGetDocFromFile (C.pack tmpfile)\n--       removeFile tmpfile\n--       return mdoc\n\n-- |\n-- popplerGetPageFromDoc ::\n--   Poppler.Document ->\n--   -- | page number\n--   Int ->\n--   IO (Maybe Poppler.Page)\n-- popplerGetPageFromDoc doc pn = do\n--   n <- Poppler.documentGetNPages doc\n--   if pn > n\n--     then return Nothing\n--     else do\n--       pg <- Poppler.documentGetPage doc (pn - 1)\n--       return (Just pg)\n\n-- | draw ruling all\ndrawRuling :: Double -> Double -> ByteString -> Cairo.Render ()\ndrawRuling w h style = do\n  let drawHorizRules = do\n        let (r, g, b, a) = predefinedRulingColor\n        Cairo.setSourceRGBA r g b a\n        Cairo.setLineWidth predefinedRulingThickness\n        let drawonerule y = do\n              Cairo.moveTo 0 y\n              Cairo.lineTo w y\n              Cairo.stroke\n        mapM_\n          drawonerule\n          [ predefinedRulingTopMargin,\n            predefinedRulingTopMargin + predefinedRulingSpacing\n            .. h - 1\n          ]\n  case style of\n    "plain" -> return ()\n    "lined" -> do\n      drawHorizRules\n      let (r2, g2, b2, a2) = predefinedRulingMarginColor\n      Cairo.setSourceRGBA r2 g2 b2 a2\n      Cairo.setLineWidth predefinedRulingThickness\n      Cairo.moveTo predefinedRulingLeftMargin 0\n      Cairo.lineTo predefinedRulingLeftMargin h\n      Cairo.stroke\n    "ruled" -> drawHorizRules\n    "graph" -> do\n      let (r3, g3, b3, a3) = predefinedRulingColor\n      Cairo.setSourceRGBA r3 g3 b3 a3\n      Cairo.setLineWidth predefinedRulingThickness\n      let drawonegraphvert x = do\n            Cairo.moveTo x 0\n            Cairo.lineTo x h\n            Cairo.stroke\n      let drawonegraphhoriz y = do\n            Cairo.moveTo 0 y\n            Cairo.lineTo w y\n            Cairo.stroke\n      mapM_ drawonegraphvert [0, predefinedRulingGraphSpacing .. w - 1]\n      mapM_ drawonegraphhoriz [0, predefinedRulingGraphSpacing .. h - 1]\n    _ -> return ()\n\n-- | draw ruling  in bbox\ndrawRulingInBBox :: BBox -> Double -> Double -> ByteString -> Cairo.Render ()\ndrawRulingInBBox (BBox (x1, y1) (x2, y2)) w h style = do\n  let drawonerule y = do\n        Cairo.moveTo x1 y\n        Cairo.lineTo x2 y\n        Cairo.stroke\n  let drawonegraphvert x = do\n        Cairo.moveTo x y1\n        Cairo.lineTo x y2\n        Cairo.stroke\n  let drawonegraphhoriz y = do\n        Cairo.moveTo x1 y\n        Cairo.lineTo x2 y\n        Cairo.stroke\n      fullRuleYs =\n        [ predefinedRulingTopMargin,\n          predefinedRulingTopMargin + predefinedRulingSpacing\n          .. h - 1\n        ]\n      ruleYs = filter (\\y -> (y <= y2) && (y >= y1)) fullRuleYs\n      fullGraphXs = [0, predefinedRulingGraphSpacing .. w - 1]\n      fullGraphYs = [0, predefinedRulingGraphSpacing .. h - 1]\n      graphXs = filter (\\x -> (x <= x2) && (x >= x1)) fullGraphXs\n      graphYs = filter (\\y -> (y <= y2) && (y >= y1)) fullGraphYs\n  let drawHorizRules = do\n        let (r, g, b, a) = predefinedRulingColor\n        Cairo.setSourceRGBA r g b a\n        Cairo.setLineWidth predefinedRulingThickness\n        mapM_ drawonerule ruleYs\n  case style of\n    "plain" -> return ()\n    "lined" -> do\n      drawHorizRules\n      let (r2, g2, b2, a2) = predefinedRulingMarginColor\n      Cairo.setSourceRGBA r2 g2 b2 a2\n      Cairo.setLineWidth predefinedRulingThickness\n      Cairo.moveTo predefinedRulingLeftMargin 0\n      Cairo.lineTo predefinedRulingLeftMargin h\n      Cairo.stroke\n    "ruled" -> drawHorizRules\n    "graph" -> do\n      let (r3, g3, b3, a3) = predefinedRulingColor\n      Cairo.setSourceRGBA r3 g3 b3 a3\n      Cairo.setLineWidth predefinedRulingThickness\n      mapM_ drawonegraphvert graphXs\n      mapM_ drawonegraphhoriz graphYs\n    _ -> return ()\n\n-- | render background without any constraint\nrenderBkg :: (Background, Dimension) -> Cairo.Render ()\nrenderBkg (Background _typ col sty, Dim w h) = do\n  let c = M.lookup col predefinedBkgcolor\n  case c of\n    Just (r, g, b, _a) -> Cairo.setSourceRGB r g b\n    Nothing -> Cairo.setSourceRGB 1 1 1\n  Cairo.rectangle 0 0 w h\n  Cairo.fill\n  drawRuling w h sty\nrenderBkg (BackgroundPdf {}, Dim w h) = do\n  Cairo.setSourceRGBA 1 1 1 1\n  Cairo.rectangle 0 0 w h\n  Cairo.fill\nrenderBkg (BackgroundEmbedPdf _ _, Dim w h) = do\n  Cairo.setSourceRGBA 1 1 1 1\n  Cairo.rectangle 0 0 w h\n  Cairo.fill\n\n-- | this has some bugs. need to fix\ncnstrctRBkgStateT ::\n  Dimension ->\n  Background ->\n  StateT (Maybe Context) Renderer RBackground\ncnstrctRBkgStateT _ bkg = do\n  (qpdf, _qgen) <- ((,) <$> rendererPDFCmdQ <*> rendererGenCmdQ) <$> lift ask\n  sfcid <- issueSurfaceID\n  case bkg of\n    Background _t c s -> return (RBkgSmpl c s sfcid)\n    BackgroundPdf _t md mf pn -> do\n      r <- runMaybeT $ do\n        (_pg, rbkg) <- case (md, mf) of\n          (Just d, Just f) -> do\n            cmdiddoc <- issuePDFCommandID\n            docvar <- liftIO newEmptyTMVarIO\n            liftIO . atomically $ sendPDFCommand qpdf cmdiddoc (GetDocFromFile f docvar)\n            doc <- MaybeT . liftIO $ atomically $ takeTMVar docvar\n            lift . put $ Just (Context d f (Just doc) Nothing)\n            pg <- pdfRequest qpdf doc pn\n            return (pg, RBkgPDF md f pn (Just pg) sfcid)\n          _ -> do\n            Context oldd oldf olddoc _ <- MaybeT get\n            doc <- MaybeT . return $ olddoc\n            pg <- pdfRequest qpdf doc pn\n            return (pg, RBkgPDF (Just oldd) oldf pn (Just pg) sfcid)\n        return rbkg\n      case r of\n        Nothing -> error "error in cnstrctRBkgStateT"\n        Just x -> return x\n    BackgroundEmbedPdf _ pn -> do\n      r <- runMaybeT $ do\n        Context _ _ _ mdoc <- MaybeT get\n        doc <- (MaybeT . return) mdoc\n        pg <- pdfRequest qpdf doc pn\n        return (RBkgEmbedPDF pn (Just pg) sfcid)\n      case r of\n        Nothing -> error "error in cnstrctRBkgStateT"\n        Just x -> return x\n  where\n    pdfRequest q doc pn = do\n      cmdidpg <- issuePDFCommandID\n      pgvar <- liftIO newEmptyTMVarIO\n      liftIO . atomically $ sendPDFCommand q cmdidpg (GetPageFromDoc doc pn pgvar)\n      MaybeT . liftIO $ atomically $ takeTMVar pgvar\n\n-- | For simple hoodle background\nrenderBackgroundStateT :: Dimension -> Background -> StateT Context Cairo.Render ()\nrenderBackgroundStateT dim@(Dim w h) bkg = do\n  case bkg of\n    Background _t _c _s -> lift (renderBkg (bkg, dim))\n    BackgroundPdf _t md mf pn -> do\n      r <- runMaybeT $ do\n        case (md, mf) of\n          (Just d, Just f) -> do\n            -- doc <- (MaybeT . liftIO . popplerGetDocFromFile) f\n            let doc = ()\n            lift . put $ Context d f (Just doc) Nothing\n            -- pdfRenderDoc doc pn\n            pure ()\n          _ -> do\n            Context _oldd _oldf olddoc _ <- lift get\n            doc <- MaybeT . return $ olddoc\n            -- pdfRenderDoc doc pn\n            pure ()\n      maybe (error "renderBackgroundStateT") (const (return ())) r\n    BackgroundEmbedPdf _ pn -> do\n      r <- runMaybeT $ do\n        Context _ _ _ mdoc <- lift get\n        doc <- (MaybeT . return) mdoc\n        -- pdfRenderDoc doc pn\n        pure ()\n      maybe (error "renderBackgroundStateT") (const (return ())) r\n\n{-\n  where\n    pdfRender pg = do\n      Cairo.setSourceRGBA 1 1 1 1\n      Cairo.rectangle 0 0 w h\n      Cairo.fill\n      PopplerPage.pageRender pg\n    pdfRenderDoc doc pn =\n      (MaybeT . liftIO) (popplerGetPageFromDoc doc pn)\n        >>= lift . lift . pdfRender\n-}\n'