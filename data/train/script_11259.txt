b'-- | Test patterns\n\n{-# LANGUAGE CPP, DeriveDataTypeable #-}\n\nmodule Test.Tasty.Patterns\n  ( TestPattern(..)\n  , parseExpr\n  , parseTestPattern\n  , noPattern\n  , Path\n  , exprMatches\n  , testPatternMatches\n  ) where\n\nimport Test.Tasty.Options\nimport Test.Tasty.Patterns.Types\nimport Test.Tasty.Patterns.Parser\nimport Test.Tasty.Patterns.Eval\n\nimport Data.Char\nimport Data.Typeable\nimport Options.Applicative hiding (Success)\n#if !MIN_VERSION_base(4,11,0)\nimport Data.Monoid\n#endif\n\n-- | @since 1.0\nnewtype TestPattern =\n  -- | @since 1.1\n  TestPattern\n    (Maybe Expr)\n  deriving\n  ( Typeable\n  , Show -- ^ @since 1.1\n  , Eq   -- ^ @since 1.1\n  )\n\n-- | @since 1.0\nnoPattern :: TestPattern\nnoPattern = TestPattern Nothing\n\ninstance IsOption TestPattern where\n  defaultValue = noPattern\n  parseValue = parseTestPattern\n  optionName = return "pattern"\n  optionHelp = return "Select only tests which satisfy a pattern or awk expression"\n  optionCLParser = mkOptionCLParser (short \'p\' <> metavar "PATTERN")\n\n-- | @since 1.2\nparseExpr :: String -> Maybe Expr\nparseExpr s\n  | all (\\c -> isAlphaNum c || c `elem` "._- ") s =\n    Just $ ERE s\n  | otherwise = parseAwkExpr s\n\n-- | @since 1.0\nparseTestPattern :: String -> Maybe TestPattern\nparseTestPattern s\n  | null s = Just noPattern\n  | otherwise = TestPattern . Just <$> parseExpr s\n\n-- | @since 1.2\nexprMatches :: Expr -> Path -> Bool\nexprMatches e fields =\n  case withFields fields $ asB =<< eval e of\n    Left msg -> error msg\n    Right b -> b\n\n-- | @since 1.0\ntestPatternMatches :: TestPattern -> Path -> Bool\ntestPatternMatches pat fields =\n  case pat of\n    TestPattern Nothing -> True\n    TestPattern (Just e) -> exprMatches e fields\n'