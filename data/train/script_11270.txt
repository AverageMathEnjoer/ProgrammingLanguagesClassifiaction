b'{-# LANGUAGE RankNTypes, BangPatterns #-}\n\nmodule Main where\n\nimport Control.Monad.Par\nimport Control.Monad (forM_)\nimport Criterion.Main\nimport Criterion.Types (Benchmarkable(Benchmarkable))\n\n\n-- | Helper for benchmarking par-monad actions:\nbenchPar :: Par () -> Benchmarkable\nbenchPar par = Benchmarkable $ \\ iters -> \n  runParIO $ \n    for_  1 (fromIntegral iters) $ \\_ -> do\n       par\n{-# INLINE benchPar #-}\n\nmain = defaultMain [\n  bgroup "monad-par"\n    [ bench "NOOP" $ benchPar (return ())\n    , bench "fork" $ benchPar (fork (return ()))\n    , bench "new"  $ benchPar  (do new; return ())\n    , bench "newFull"     $ benchPar (do iv <- newFull (3::Int); return ())\n    , bench "newFull-get" $ benchPar (do iv <- newFull (3::Int); get iv; return ())\n    , bench "new-put"     $ benchPar (do iv <- new; put iv (3::Int); return ())\n    , bench "new-put-get" $ benchPar (do iv <- new; put iv (3::Int); get iv; return ())\n    , bench "new-fork-get" $ benchPar (do iv <- new; fork (put iv (3::Int)); get iv; return ())\n    ]\n  ]\n\n-- My own forM for inclusive numeric ranges (not requiring deforestation optimizations).\n{-# INLINE for_ #-}\nfor_ :: Monad m => Int -> Int -> (Int -> m ()) -> m ()\nfor_ start end _fn | start > end = error "for_: start is greater than end"\nfor_ start end fn = loop start\n  where\n   loop !i | i > end  = return ()\n\t   | otherwise = do fn i; loop (i+1)\n'