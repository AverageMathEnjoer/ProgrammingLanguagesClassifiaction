b"{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE StandaloneDeriving #-}\n{-# LANGUAGE TypeFamilies #-}\n\nmodule Data.Hoodle.BBox\n  ( BBox (..), -- re-export\n    BBoxed (..), -- re-export\n    GetBBoxable (..), -- re-export\n    MakeBBoxedable (..),\n    mkbbox,\n    mkbboxF,\n    bboxFromStroke,\n    bboxFromImage,\n    bboxFromSVG,\n    dimToBBox,\n    bboxToDim,\n    xformBBox,\n    inflate,\n    moveBBoxToOrigin,\n    moveBBoxByOffset,\n    moveBBoxULCornerTo,\n    intersectBBox,\n    unionBBox,\n    ULMaybe (..),\n    IntersectBBox (..),\n    UnionBBox (..),\n    Maybeable (..),\n    bbox4All,\n  )\nwhere\n\nimport Control.Monad (guard)\nimport Control.Monad.Identity (Identity)\nimport qualified Data.Foldable as F\nimport Data.Hoodle.Simple\n  ( Anchor (..),\n    Dimension (..),\n    Image (..),\n    Link (..),\n    SVG (..),\n    Stroke (..),\n  )\nimport Data.Hoodle.Util (fst3, snd3, trd3)\nimport Data.Kind (Type)\nimport Data.Strict.Tuple (Pair, fst, snd)\nimport Hoodle.HitTest.Type\n  ( BBox (..),\n    BBoxed (..),\n    GetBBoxable (..),\n  )\nimport Prelude hiding (fst, snd)\nimport qualified Prelude (fst, snd)\n\n-- |\nclass (Monad m) => MakeBBoxedable m a where\n  makeBBoxed :: a -> m (BBoxed a)\n\ninstance MakeBBoxedable Identity Stroke where\n  makeBBoxed strk = return (BBoxed strk (bboxFromStroke strk))\n\ninstance MakeBBoxedable Identity Image where\n  makeBBoxed img = return (BBoxed img (bboxFromImage img))\n\ninstance MakeBBoxedable Identity SVG where\n  makeBBoxed svg = return (BBoxed svg (bboxFromSVG svg))\n\ninstance MakeBBoxedable Identity Link where\n  makeBBoxed lnk = return (BBoxed lnk (bboxFromLink lnk))\n\ninstance MakeBBoxedable Identity Anchor where\n  makeBBoxed anc = return (BBoxed anc (bboxFromAnchor anc))\n\n-- |\nmkbbox :: [Pair Double Double] -> BBox\nmkbbox lst =\n  let xs = map fst lst\n      ys = map snd lst\n   in BBox\n        { bbox_upperleft = (minimum xs, minimum ys),\n          bbox_lowerright = (maximum xs, maximum ys)\n        }\n\n-- |\nmkbboxF :: (F.Foldable m, Functor m) => m (Double, Double) -> BBox\nmkbboxF lst =\n  let xs = fmap Prelude.fst lst\n      ys = fmap Prelude.snd lst\n   in BBox\n        { bbox_upperleft = (F.minimum xs, F.minimum ys),\n          bbox_lowerright = (F.maximum xs, F.maximum ys)\n        }\n\n-- |\nbboxFromStroke :: Stroke -> BBox\nbboxFromStroke (Stroke _ _ w dat) = inflate (mkbbox dat) w\nbboxFromStroke (VWStroke _ _ dat) =\n  let dat' = map ((,) <$> fst3 <*> snd3) dat\n      widthmax = F.maximum (map trd3 dat)\n   in inflate (mkbboxF dat') widthmax\n\n-- |\ndimToBBox :: Dimension -> BBox\ndimToBBox (Dim w h) = BBox (0, 0) (w, h)\n\n-- |\n-- |\nbboxToDim :: BBox -> Dimension\nbboxToDim (BBox (x1, y1) (x2, y2)) = Dim (x2 - x1) (y2 - y1)\n\n-- |\nbboxFromImage :: Image -> BBox\nbboxFromImage (Image _ (x, y) d) = moveBBoxULCornerTo (x, y) (dimToBBox d)\n\n-- |\nbboxFromSVG :: SVG -> BBox\nbboxFromSVG (SVG _ _ _ (x, y) d) = moveBBoxULCornerTo (x, y) (dimToBBox d)\n\n-- |\nbboxFromLink :: Link -> BBox\nbboxFromLink (Link _ _ _ _ _ _ (x, y) d) = moveBBoxULCornerTo (x, y) (dimToBBox d)\nbboxFromLink (LinkDocID _ _ _ _ _ _ (x, y) d) = moveBBoxULCornerTo (x, y) (dimToBBox d)\nbboxFromLink (LinkAnchor _ _ _ _ _ (x, y) d) = moveBBoxULCornerTo (x, y) (dimToBBox d)\n\n-- |\nbboxFromAnchor :: Anchor -> BBox\nbboxFromAnchor (Anchor _ _ (x, y) d) = moveBBoxULCornerTo (x, y) (dimToBBox d)\n\n-- | general transform BBox\nxformBBox :: ((Double, Double) -> (Double, Double)) -> BBox -> BBox\nxformBBox f (BBox c1 c2) = BBox (f c1) (f c2)\n\n-- | inflate bbox by amount r\ninflate :: BBox -> Double -> BBox\ninflate (BBox (x1, y1) (x2, y2)) r = BBox (x1 - r, y1 - r) (x2 + r, y2 + r)\n\n-- |\nmoveBBoxToOrigin :: BBox -> BBox\nmoveBBoxToOrigin (BBox (x0, y0) (x1, y1)) = BBox (0, 0) (x1 - x0, y1 - y0)\n\n-- |\nmoveBBoxByOffset :: (Double, Double) -> BBox -> BBox\nmoveBBoxByOffset (xoff, yoff) (BBox (x0, y0) (x1, y1)) = BBox (x0 + xoff, y0 + yoff) (x1 + xoff, y1 + yoff)\n\n-- |\nmoveBBoxULCornerTo :: (Double, Double) -> BBox -> BBox\nmoveBBoxULCornerTo (x, y) b@(BBox (x0, y0) _) = moveBBoxByOffset (x - x0, y - y0) b\n\n-- |\nintersectBBox :: BBox -> BBox -> Maybe BBox\nintersectBBox (BBox (x1, y1) (x2, y2)) (BBox (x3, y3) (x4, y4)) = do\n  guard $ (x1 <= x3 && x3 <= x2) || (x3 <= x1 && x1 <= x4)\n  guard $ (y1 <= y3 && y3 <= y2) || (y3 <= y1 && y1 <= y4)\n  let x5 = if x1 <= x3 then x3 else x1\n      y5 = if y1 <= y3 then y3 else y1\n      x6 = min x2 x4\n      y6 = min y2 y4\n  return (BBox (x5, y5) (x6, y6))\n\n-- |\nunionBBox :: BBox -> BBox -> BBox\nunionBBox (BBox (x1, y1) (x2, y2)) (BBox (x3, y3) (x4, y4)) =\n  let x5 = if x1 < x3 then x1 else x3\n      y5 = if y1 < y3 then y1 else y3\n      x6 = if x2 < x4 then x4 else x2\n      y6 = if y2 < y4 then y4 else y2\n   in BBox (x5, y5) (x6, y6)\n\n-- |\ndata ULMaybe a = Bottom | Middle a | Top\n\nderiving instance Show a => Show (ULMaybe a)\n\nderiving instance Eq a => Eq (ULMaybe a)\n\n-- |\nnewtype IntersectBBox = Intersect {unIntersect :: ULMaybe BBox}\n  deriving (Show, Eq)\n\n-- |\nnewtype UnionBBox = Union {unUnion :: ULMaybe BBox}\n  deriving (Show, Eq)\n\ninstance Semigroup IntersectBBox where\n  (Intersect Bottom) <> _ = Intersect Bottom\n  _ <> (Intersect Bottom) = Intersect Bottom\n  (Intersect Top) <> x = x\n  x <> (Intersect Top) = x\n  (Intersect (Middle x)) <> (Intersect (Middle y)) =\n    maybe (Intersect Bottom) (Intersect . Middle) (x `intersectBBox` y)\n\ninstance Monoid IntersectBBox where\n  mempty = Intersect Top\n\ninstance Semigroup UnionBBox where\n  (Union Bottom) <> x = x\n  x <> (Union Bottom) = x\n  (Union Top) <> _ = Union Top\n  _ <> (Union Top) = Union Top\n  (Union (Middle x)) <> (Union (Middle y)) = Union (Middle (x `unionBBox` y))\n\ninstance Monoid UnionBBox where\n  mempty = Union Bottom\n\n-- |\nclass Maybeable a where\n  type ElemType a :: Type\n  toMaybe :: a -> Maybe (ElemType a)\n  fromMaybe :: Maybe (ElemType a) -> a\n\ninstance Maybeable IntersectBBox where\n  type ElemType IntersectBBox = BBox\n  toMaybe (Intersect Bottom) = Nothing\n  toMaybe (Intersect Top) = Nothing\n  toMaybe (Intersect (Middle x)) = Just x\n  fromMaybe Nothing = Intersect Top\n  fromMaybe (Just x) = Intersect (Middle x)\n\ninstance Maybeable UnionBBox where\n  type ElemType UnionBBox = BBox\n  toMaybe (Union Bottom) = Nothing\n  toMaybe (Union Top) = Nothing\n  toMaybe (Union (Middle x)) = Just x\n  fromMaybe Nothing = Union Top\n  fromMaybe (Just x) = Union (Middle x)\n\n-- |\nbbox4All :: (F.Foldable t, Functor t, GetBBoxable a) => t a -> ULMaybe BBox\nbbox4All = unUnion . F.fold . fmap (Union . Middle . getBBox)\n"