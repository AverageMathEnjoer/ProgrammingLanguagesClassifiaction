b'{-# LANGUAGE NoImplicitPrelude #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n{-# LANGUAGE InstanceSigs #-}\n\nmodule Course.Functor where\n\nimport Course.Core\nimport Course.ExactlyOne\nimport Course.Optional\nimport Course.List\nimport qualified Prelude as P(fmap)\n\n-- | All instances of the `Functor` type-class must satisfy two laws. These laws\n-- are not checked by the compiler. These laws are given as:\n--\n-- * The law of identity\n--   `\xe2\x88\x80x. (id <$> x) \xe2\x89\x85 x`\n--\n-- * The law of composition\n--   `\xe2\x88\x80f g x.(f . g <$> x) \xe2\x89\x85 (f <$> (g <$> x))`\nclass Functor f where\n  -- Pronounced, eff-map.\n  (<$>) ::\n    (a -> b)\n    -> f a\n    -> f b\n\ninfixl 4 <$>\n\n-- $setup\n-- >>> :set -XOverloadedStrings\n-- >>> import Course.Core\n-- >>> import qualified Prelude as P(return, (>>))\n\n-- | Maps a function on the ExactlyOne functor.\n--\n-- >>> (+1) <$> ExactlyOne 2\n-- ExactlyOne 3\ninstance Functor ExactlyOne where\n  (<$>) ::\n    (a -> b)\n    -> ExactlyOne a\n    -> ExactlyOne b\n  (<$>) =\n    error "todo: Course.Functor (<$>)#instance ExactlyOne"\n\n-- | Maps a function on the List functor.\n--\n-- >>> (+1) <$> Nil\n-- []\n--\n-- >>> (+1) <$> (1 :. 2 :. 3 :. Nil)\n-- [2,3,4]\ninstance Functor List where\n  (<$>) ::\n    (a -> b)\n    -> List a\n    -> List b\n  (<$>) =\n    error "todo: Course.Functor (<$>)#instance List"\n\n-- | Maps a function on the Optional functor.\n--\n-- >>> (+1) <$> Empty\n-- Empty\n--\n-- >>> (+1) <$> Full 2\n-- Full 3\ninstance Functor Optional where\n  (<$>) ::\n    (a -> b)\n    -> Optional a\n    -> Optional b\n  (<$>) =\n    error "todo: Course.Functor (<$>)#instance Optional"\n\n-- | Maps a function on the reader ((->) t) functor.\n--\n-- >>> ((+1) <$> (*2)) 8\n-- 17\ninstance Functor ((->) t) where\n  (<$>) ::\n    (a -> b)\n    -> ((->) t a)\n    -> ((->) t b)\n  (<$>) =\n    error "todo: Course.Functor (<$>)#((->) t)"\n\n-- | Anonymous map. Maps a constant value on a functor.\n--\n-- >>> 7 <$ (1 :. 2 :. 3 :. Nil)\n-- [7,7,7]\n--\n-- prop> \\x a b c -> x <$ (a :. b :. c :. Nil) == (x :. x :. x :. Nil)\n--\n-- prop> \\x q -> x <$ Full q == Full x\n(<$) ::\n  Functor f =>\n  a\n  -> f b\n  -> f a\n(<$) =\n  error "todo: Course.Functor#(<$)"\n\n-- | Anonymous map producing unit value.\n--\n-- >>> void (1 :. 2 :. 3 :. Nil)\n-- [(),(),()]\n--\n-- >>> void (Full 7)\n-- Full ()\n--\n-- >>> void Empty\n-- Empty\n--\n-- >>> void (+10) 5\n-- ()\nvoid ::\n  Functor f =>\n  f a\n  -> f ()\nvoid =\n  error "todo: Course.Functor#void"\n\n-----------------------\n-- SUPPORT LIBRARIES --\n-----------------------\n\n-- | Maps a function on an IO program.\n--\n-- >>> reverse <$> (putStr "hi" P.>> P.return ("abc" :: List Char))\n-- hi"cba"\ninstance Functor IO where\n  (<$>) =\n    P.fmap\n'