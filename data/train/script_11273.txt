b'{-# LANGUAGE CPP #-}\n{-# LANGUAGE BangPatterns #-}\n\n#include "containers.h"\n\n-----------------------------------------------------------------------------\n-- |\n-- Module      :  Utils.Containers.Internal.BitQueue\n-- Copyright   :  (c) David Feuer 2016\n-- License     :  BSD-style\n-- Maintainer  :  libraries@haskell.org\n-- Portability :  portable\n--\n-- = WARNING\n--\n-- This module is considered __internal__.\n--\n-- The Package Versioning Policy __does not apply__.\n--\n-- The contents of this module may change __in any way whatsoever__\n-- and __without any warning__ between minor versions of this package.\n--\n-- Authors importing this module are expected to track development\n-- closely.\n--\n-- = Description\n--\n-- An extremely light-weight, fast, and limited representation of a string of\n-- up to (2*WORDSIZE - 2) bits. In fact, there are two representations,\n-- misleadingly named bit queue builder and bit queue. The builder supports\n-- only `emptyQB`, creating an empty builder, and `snocQB`, enqueueing a bit.\n-- The bit queue builder is then turned into a bit queue using `buildQ`, after\n-- which bits can be removed one by one using `unconsQ`. If the size limit is\n-- exceeded, further operations will silently produce nonsense.\n-----------------------------------------------------------------------------\n\nmodule Utils.Containers.Internal.BitQueue\n    ( BitQueue\n    , BitQueueB\n    , emptyQB\n    , snocQB\n    , buildQ\n    , unconsQ\n    , toListQ\n    ) where\n\nimport Utils.Containers.Internal.BitUtil (shiftLL, shiftRL, wordSize)\nimport Data.Bits ((.|.), (.&.), testBit)\nimport Data.Bits (countTrailingZeros)\n\n-- A bit queue builder. We represent a double word using two words\n-- because we don\'t currently have access to proper double words.\ndata BitQueueB = BQB {-# UNPACK #-} !Word\n                     {-# UNPACK #-} !Word\n\nnewtype BitQueue = BQ BitQueueB deriving Show\n\n-- Intended for debugging.\ninstance Show BitQueueB where\n  show (BQB hi lo) = "BQ"++\n    show (map (testBit hi) [(wordSize - 1),(wordSize - 2)..0]\n            ++ map (testBit lo) [(wordSize - 1),(wordSize - 2)..0])\n\n-- | Create an empty bit queue builder. This is represented as a single guard\n-- bit in the most significant position.\nemptyQB :: BitQueueB\nemptyQB = BQB (1 `shiftLL` (wordSize - 1)) 0\n{-# INLINE emptyQB #-}\n\n-- Shift the double word to the right by one bit.\nshiftQBR1 :: BitQueueB -> BitQueueB\nshiftQBR1 (BQB hi lo) = BQB hi\' lo\' where\n  lo\' = (lo `shiftRL` 1) .|. (hi `shiftLL` (wordSize - 1))\n  hi\' = hi `shiftRL` 1\n{-# INLINE shiftQBR1 #-}\n\n-- | Enqueue a bit. This works by shifting the queue right one bit,\n-- then setting the most significant bit as requested.\n{-# INLINE snocQB #-}\nsnocQB :: BitQueueB -> Bool -> BitQueueB\nsnocQB bq b = case shiftQBR1 bq of\n  BQB hi lo -> BQB (hi .|. (fromIntegral (fromEnum b) `shiftLL` (wordSize - 1))) lo\n\n-- | Convert a bit queue builder to a bit queue. This shifts in a new\n-- guard bit on the left, and shifts right until the old guard bit falls\n-- off.\n{-# INLINE buildQ #-}\nbuildQ :: BitQueueB -> BitQueue\nbuildQ (BQB hi 0) = BQ (BQB 0 lo\') where\n  zeros = countTrailingZeros hi\n  lo\' = ((hi `shiftRL` 1) .|. (1 `shiftLL` (wordSize - 1))) `shiftRL` zeros\nbuildQ (BQB hi lo) = BQ (BQB hi\' lo\') where\n  zeros = countTrailingZeros lo\n  lo1 = (lo `shiftRL` 1) .|. (hi `shiftLL` (wordSize - 1))\n  hi1 = (hi `shiftRL` 1) .|. (1 `shiftLL` (wordSize - 1))\n  lo\' = (lo1 `shiftRL` zeros) .|. (hi1 `shiftLL` (wordSize - zeros))\n  hi\' = hi1 `shiftRL` zeros\n\n-- Test if the queue is empty, which occurs when there\'s\n-- nothing left but a guard bit in the least significant\n-- place.\nnullQ :: BitQueue -> Bool\nnullQ (BQ (BQB 0 1)) = True\nnullQ _ = False\n{-# INLINE nullQ #-}\n\n-- | Dequeue an element, or discover the queue is empty.\nunconsQ :: BitQueue -> Maybe (Bool, BitQueue)\nunconsQ q | nullQ q = Nothing\nunconsQ (BQ bq@(BQB _ lo)) = Just (hd, BQ tl)\n  where\n    !hd = (lo .&. 1) /= 0\n    !tl = shiftQBR1 bq\n{-# INLINE unconsQ #-}\n\n-- | Convert a bit queue to a list of bits by unconsing.\n-- This is used to test that the queue functions properly.\ntoListQ :: BitQueue -> [Bool]\ntoListQ bq = case unconsQ bq of\n      Nothing -> []\n      Just (hd, tl) -> hd : toListQ tl\n'