b'#include "FileContextInfo.h"\n#include "AppContext.h"\n#include <InternalBundleReplacer.h>\n#include <assert.h>\n\nFileContextInfo::FileContextInfo(unsigned int fileID, unsigned int parentFileID)\n\t: fileID(fileID), parentFileID(parentFileID)\n{}\nFileContextInfo::~FileContextInfo()\n{}\nstd::string FileContextInfo::getFileName()\n{\n\t{\n\t\tstd::lock_guard fileNameLock(fileNameOverrideMutex);\n\t\tif (!fileNameOverride.empty())\n\t\t\treturn fileNameOverride;\n\t}\n\tif (getFileContext())\n\t\treturn getFileContext()->getFileName();\n\treturn "";\n}\nvoid FileContextInfo::setFileName(std::string name)\n{\n\tstd::lock_guard fileNameLock(fileNameOverrideMutex);\n\tfileNameOverride = std::move(name);\n}\n\nAssetsFileContextInfo::AssetsFileContextInfo(AssetsFileContext *pContext, unsigned int fileID, unsigned int parentFileID)\n\t: FileContextInfo(fileID, parentFileID), pContext(pContext), pClassDatabase(nullptr, ClassDatabaseFileDeleter_Dummy)\n{\n\tassert(pContext->getAssetsFile());\n\tif (pContext->getAssetsFile())\n\t{\n\t\treferences.resize(pContext->getAssetsFile()->dependencies.dependencyCount, 0);\n\t\tdependencies.assign(&pContext->getAssetsFile()->dependencies.pDependencies[0],\n\t\t\t&pContext->getAssetsFile()->dependencies.pDependencies[references.size()]);\n\t}\n}\nAssetsFileContextInfo::~AssetsFileContextInfo()\n{\n\tIAssetsReader *pReader = this->pContext->getReaderUnsafe();\n\tthis->pContext->Close();\n\tdelete this->pContext;\n\tthis->pContext = nullptr;\n}\nIFileContext *AssetsFileContextInfo::getFileContext()\n{\n\treturn this->pContext;\n}\nvoid AssetsFileContextInfo::getChildFileIDs(std::vector<unsigned int> &childFileIDs)\n{\n\tchildFileIDs.clear();\n}\nvoid AssetsFileContextInfo::onCloseChild(unsigned int childFileID)\n{\n}\nbool AssetsFileContextInfo::hasAnyChanges(AppContext &appContext)\n{\n\tif (permanentChangedFlag)\n\t\treturn true;\n\tif (this->getAssetsFileContext() != nullptr && this->getAssetsFileContext()->getReaderIsModified())\n\t\treturn true;\n\tthis->lockReplacersRead();\n\tbool ret = !this->pReplacersByPathID.empty();\n\tthis->unlockReplacersRead();\n\tif (ret)\n\t\treturn true;\n\tauto refLock = this->lockReferencesRead();\n\tret = this->dependenciesChanged;\n\treturn ret;\n}\nbool AssetsFileContextInfo::hasNewChanges(AppContext &appContext)\n{\n\treturn this->changedFlag;\n}\nuint64_t AssetsFileContextInfo::write(class AppContext &appContext, IAssetsWriter *pWriter, uint64_t start, bool resetChangedFlag)\n{\n\tauto refLock = this->lockReferencesRead();\n\tthis->lockReplacersRead();\n\tif (this->pContext == nullptr || this->pContext->getAssetsFile() == nullptr)\n\t{\n\t\tthis->unlockReplacersRead();\n\t\treturn 0;\n\t}\n\tstd::vector<AssetsReplacer*> replacers; replacers.reserve(this->pReplacersByPathID.size());\n\tfor (auto it = this->pReplacersByPathID.begin(); it != this->pReplacersByPathID.end(); ++it)\n\t{\n\t\tassert(it->second.pReplacer != nullptr);\n\t\treplacers.push_back(it->second.pReplacer.get());\n\t}\n\tstd::unique_ptr<AssetsDependenciesReplacer> pDependenciesReplacer_raii;\n\tif (dependenciesChanged)\n\t{\n\t\tstd::vector<AssetsFileDependency> dependencies = this->getDependenciesRead(refLock);\n\t\tpDependenciesReplacer_raii.reset(MakeAssetsDependenciesReplacer(0, std::move(dependencies)));\n\t\treplacers.push_back(pDependenciesReplacer_raii.get());\n\t}\n\tuint64_t ret = this->pContext->getAssetsFile()->Write(pWriter, start, replacers.data(), replacers.size(), (uint32_t)-1, this->pClassDatabase.get());\n\tif (resetChangedFlag && ret != 0)\n\t\tthis->changedFlag = false;\n\tthis->unlockReplacersRead();\n\treturn ret;\n}\nstd::unique_ptr<BundleReplacer> AssetsFileContextInfo::makeBundleReplacer(class AppContext &appContext, \n\tconst char *oldName, const char *newName, uint32_t bundleIndex, \n\tbool resetChangedFlag)\n{\n\tauto refLock = this->lockReferencesRead();\n\tthis->lockReplacersRead();\n\tif (this->pContext == nullptr || this->pContext->getAssetsFile() == nullptr\n\t\t|| (this->pReplacersByPathID.empty() && !dependenciesChanged))\n\t{\n\t\tthis->unlockReplacersRead();\n\t\treturn nullptr;\n\t}\n\tstd::shared_lock classDatabaseLock(this->classDatabaseMutex);\n\tClassDatabaseFile_sharedptr pClassDatabase = this->pClassDatabase;\n\tclassDatabaseLock.unlock();\n\tstd::vector<std::shared_ptr<AssetsReplacer>> pReplacers;\n\tpReplacers.reserve(this->pReplacersByPathID.size());\n\tfor (auto replacerIt = this->pReplacersByPathID.begin(); replacerIt != this->pReplacersByPathID.end(); ++replacerIt)\n\t{\n\t\tif (replacerIt->second.pReplacer != nullptr\n\t\t\t&& (replacerIt->second.pReplacer->GetFileID() == 0 || replacerIt->second.pReplacer->GetFileID() == this->getFileID()))\n\t\t\tpReplacers.push_back(replacerIt->second.pReplacer);\n\t\telse\n\t\t\tassert(false); //Replacer is nullptr, or for another file.\n\t}\n\tif (dependenciesChanged)\n\t{\n\t\tstd::vector<AssetsFileDependency> dependencies = this->getDependenciesRead(refLock);\n\t\tpReplacers.emplace_back(MakeAssetsDependenciesReplacer(0, std::move(dependencies)));\n\t}\n\tif (resetChangedFlag)\n\t\tthis->changedFlag = false;\n\tthis->unlockReplacersRead();\n\treturn MakeBundleEntryModifierFromAssets(oldName, newName, \n\t\tstd::move(pClassDatabase), std::move(pReplacers), \n\t\tthis->getFileID(), bundleIndex);\n}\n\n\nstd::vector<std::shared_ptr<AssetsReplacer>> AssetsFileContextInfo::getAllReplacers()\n{\n\tstd::vector<std::shared_ptr<AssetsReplacer>> ret;\n\tauto refLock = lockReferencesRead();\n\tlockReplacersRead();\n\tfor (auto it = this->pReplacersByPathID.begin(); it != this->pReplacersByPathID.end(); ++it)\n\t\tret.push_back(it->second.pReplacer);\n\tif (dependenciesChanged)\n\t{\n\t\tstd::vector<AssetsFileDependency> dependencies = this->getDependenciesRead(refLock);\n\t\tret.emplace_back(MakeAssetsDependenciesReplacer(0, std::move(dependencies)));\n\t}\n\tunlockReplacersRead();\n\treturn ret;\n}\nstd::shared_ptr<AssetsEntryReplacer> AssetsFileContextInfo::getReplacer(pathid_t pathID)\n{\n\tstd::shared_ptr<AssetsEntryReplacer> ret;\n\tlockReplacersRead();\n\tauto it = this->pReplacersByPathID.find(pathID);\n\tif (it != this->pReplacersByPathID.end())\n\t\tret = it->second.pReplacer;\n\tunlockReplacersRead();\n\treturn ret;\n}\nvoid AssetsFileContextInfo::addReplacer(std::shared_ptr<AssetsEntryReplacer> replacer, AppContext &appContext, bool reuseTypeMetaFromOldReplacer, bool signalMainThread) //Removes any previous replacers for that path ID.\n{\n\tassert(this->pContext && this->pContext->getAssetsFileTable());\n\tuint64_t pathID = replacer->GetPathID();\n\tbool isRemover = replacer->GetType() == AssetsReplacement_Remove;\n\tlockReplacersWrite();\n\tauto it = this->pReplacersByPathID.find((pathid_t)replacer->GetPathID());\n\tif (it != this->pReplacersByPathID.end())\n\t{\n\t\tif (!it->second.replacesExistingAsset && replacer->GetType() == AssetsReplacement_Remove)\n\t\t\tthis->pReplacersByPathID.erase(it); //The asset was created by a replacer => the remover does not need to be stored.\n\t\telse\n\t\t{\n\t\t\tif (reuseTypeMetaFromOldReplacer && replacer->GetType() != AssetsReplacement_Remove)\n\t\t\t{\n\t\t\t\tHash128 origPropertiesHash;\n\t\t\t\tif (it->second.pReplacer->GetPropertiesHash(origPropertiesHash))\n\t\t\t\t\treplacer->SetPropertiesHash(origPropertiesHash);\n\t\t\t\tHash128 origScriptIDHash;\n\t\t\t\tif (it->second.pReplacer->GetScriptIDHash(origScriptIDHash))\n\t\t\t\t\treplacer->SetScriptIDHash(origScriptIDHash);\n\t\t\t\tassert(replacer->GetMonoScriptID() == it->second.pReplacer->GetMonoScriptID());\n\n\t\t\t\tconst AssetPPtr *pPreloadList; size_t preloadListLen = 0;\n\t\t\t\tif (it->second.pReplacer->GetPreloadDependencies(pPreloadList, preloadListLen))\n\t\t\t\t\treplacer->SetPreloadDependencies(pPreloadList, preloadListLen);\n\t\t\t\t\n\t\t\t\tstd::shared_ptr<ClassDatabaseFile> pOrigClassFile;\n\t\t\t\tClassDatabaseType *pOrigClassType = nullptr;\n\t\t\t\tif (it->second.pReplacer->GetTypeInfo(pOrigClassFile, pOrigClassType))\n\t\t\t\t\treplacer->SetTypeInfo(std::move(pOrigClassFile), pOrigClassType);\n\t\t\t}\n\t\t\tit->second.pReplacer = std::move(replacer); //The previous replacer was overridden.\n\t\t}\n\t}\n\telse\n\t{\n\t\tReplacerEntry entry;\n\t\t//Insert or overwrite the replacer entry for the path ID.\n\t\tauto insertResult = this->pReplacersByPathID.insert(std::make_pair(replacer->GetPathID(), entry));\n\t\tinsertResult.first->second.replacesExistingAsset = (this->pContext->getAssetsFileTable()->getAssetInfo(replacer->GetPathID()) != nullptr);\n\t\tinsertResult.first->second.pReplacer = std::move(replacer);\n\t}\n\tthis->changedFlag = true;\n\tunlockReplacersWrite();\n\tif (signalMainThread)\n\t\tappContext.OnChangeAsset_Async(this, pathID, isRemover);\n}\n\nstd::vector<std::shared_ptr<ClassDatabaseFile>> &AssetsFileContextInfo::lockScriptDatabases()\n{\n\tthis->scriptDatabasesMutex.lock();\n\treturn this->pScriptDatabases;\n}\nvoid AssetsFileContextInfo::unlockScriptDatabases()\n{\n\tthis->scriptDatabasesMutex.unlock();\n}\n\nAssetsFileContextInfo::ContainersTask::ContainersTask(AppContext &appContext, std::shared_ptr<AssetsFileContextInfo> &pContextInfo)\n\t: appContext(appContext), pFileContextInfo(pContextInfo)\n{\n\tassert(pFileContextInfo->getAssetsFileContext() && pFileContextInfo->getAssetsFileContext()->getAssetsFile());\n\tname = "Resolve containers : " + pContextInfo->getFileName() + "";\n}\nconst std::string &AssetsFileContextInfo::ContainersTask::getName()\n{\n\treturn name;\n}\nTaskResult AssetsFileContextInfo::ContainersTask::execute(TaskProgressManager &progressManager)\n{\n\tif (!pFileContextInfo->getAssetsFileContext() || !pFileContextInfo->getAssetsFileContext()->getAssetsFile())\n\t{\n\t\tprogressManager.logMessage("Assets file not loaded!");\n\t\treturn -1;\n\t}\n\n\tprogressManager.setProgressDesc("Searching for container assets");\n\tprogressManager.setProgress(0, 0);\n\tAssetIterator iterator(this->pFileContextInfo.get());\n\tAssetIdentifier identifier;\n\tidentifier.pFile = this->pFileContextInfo;\n\n\tint32_t resmgrClassID = this->pFileContextInfo->GetClassByName("ResourceManager");\n\tif (resmgrClassID == -1) resmgrClassID = ASSETTYPE_RESOURCEMANAGER;\n\tAssetTypeTemplateField resmgrTemplateBase;\n\tbool hasResmgrTemplate = this->pFileContextInfo->MakeTemplateField(&resmgrTemplateBase, this->appContext, resmgrClassID);\n\t\n\tint32_t bundleClassID = this->pFileContextInfo->GetClassByName("AssetBundle");\n\tif (bundleClassID == -1) bundleClassID = ASSETTYPE_ASSETBUNDLE;\n\tAssetTypeTemplateField bundleTemplateBase;\n\tbool hasBundleTemplate = this->pFileContextInfo->MakeTemplateField(&bundleTemplateBase, this->appContext, bundleClassID);\n\t\n\tAssetContainerList newContainerList;\n\tTaskResult result = 0;\n\tfor (; !iterator.isEnd(); ++iterator)\n\t{\n\t\titerator.get(identifier);\n\t\tif (identifier.resolve(this->appContext))\n\t\t{\n\t\t\tint32_t curClassID = identifier.getClassID();\n\t\t\tif (curClassID == resmgrClassID)\n\t\t\t{\n\t\t\t\tResourceManagerFile resMgrFile;\n\t\t\t\tif (hasResmgrTemplate)\n\t\t\t\t{\n\t\t\t\t\tIAssetsReader_ptr pReader = identifier.makeReader();\n\t\t\t\t\tAssetTypeTemplateField *pResmgrTemplateBase = &resmgrTemplateBase;\n\t\t\t\t\tAssetTypeInstance resmgrInstance(1, &pResmgrTemplateBase, identifier.getDataSize(), pReader.get(), identifier.isBigEndian());\n\t\t\t\t\tAssetTypeValueField *pInstanceBase = resmgrInstance.GetBaseField();\n\t\t\t\t\tif (pInstanceBase)\n\t\t\t\t\t{\n\t\t\t\t\t\tresMgrFile.Read(pInstanceBase);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tprogressManager.logMessage("Unable to deserialize a ResourceManager asset!");\n\t\t\t\t\t\tresult = 1;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tuint64_t dataSize = identifier.getDataSize();\n\t\t\t\t\tif (dataSize > SIZE_MAX)\n\t\t\t\t\t{\n\t\t\t\t\t\tprogressManager.logMessage("Data size invalid!");\n\t\t\t\t\t\tresult = 2;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tstd::unique_ptr<uint8_t[]> resmgrBuf(new uint8_t[(size_t)dataSize]);\n\t\t\t\t\tif (identifier.read(dataSize, resmgrBuf.get()) != dataSize)\n\t\t\t\t\t{\n\t\t\t\t\t\tprogressManager.logMessage("Unable to lock the reader!");\n\t\t\t\t\t\tresult = 3;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tsize_t filePos = 0;\n\t\t\t\t\tresMgrFile.Read(resmgrBuf.get(), (size_t)dataSize, &filePos, pFileContextInfo->getAssetsFileContext()->getAssetsFile()->header.format, identifier.isBigEndian());\n\t\t\t\t}\n\t\t\t\tif (resMgrFile.IsRead())\n\t\t\t\t{\n\t\t\t\t\tif (!newContainerList.LoadFrom(resMgrFile))\n\t\t\t\t\t{\n\t\t\t\t\t\tprogressManager.logMessage("Unable to populate the containers list with a ResourceManager asset!");\n\t\t\t\t\t\tresult = 4;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tprogressManager.logMessage("Unable to deserialize a ResourceManager asset!");\n\t\t\t\t\tresult = 5;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (curClassID == bundleClassID)\n\t\t\t{\n\t\t\t\tAssetBundleAsset assetBundleFile;\n\n\t\t\t\tuint64_t dataSize = identifier.getDataSize();\n\t\t\t\tif (dataSize > SIZE_MAX)\n\t\t\t\t{\n\t\t\t\t\tprogressManager.logMessage("Data size invalid!");\n\t\t\t\t\tresult = 6;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tstd::unique_ptr<uint8_t[]> bundleBuf(new uint8_t[(size_t)dataSize]);\n\t\t\t\tif (identifier.read(dataSize, bundleBuf.get()) != dataSize)\n\t\t\t\t{\n\t\t\t\t\tprogressManager.logMessage("Unable to read the data!");\n\t\t\t\t\tresult = 7;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (hasBundleTemplate)\n\t\t\t\t{\n\t\t\t\t\tsize_t filePos = 0;\n\t\t\t\t\tassetBundleFile.ReadBundleFile(bundleBuf.get(), (size_t)dataSize, &filePos, &bundleTemplateBase, identifier.isBigEndian());\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tsize_t filePos = 0;\n\t\t\t\t\tassetBundleFile.ReadBundleFile(bundleBuf.get(), (size_t)dataSize, &filePos, pFileContextInfo->getAssetsFileContext()->getAssetsFile()->header.format, identifier.isBigEndian());\n\t\t\t\t}\n\t\t\t\tif (assetBundleFile.IsRead())\n\t\t\t\t{\n\t\t\t\t\tif (!newContainerList.LoadFrom(assetBundleFile))\n\t\t\t\t\t{\n\t\t\t\t\t\tprogressManager.logMessage("Unable to populate the containers list with an AssetBundle asset!");\n\t\t\t\t\t\tresult = 8;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tprogressManager.logMessage("Unable to deserialize an AssetBundle asset!");\n\t\t\t\t\tresult = 9;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\tprogressManager.logMessage("Unable to resolve an asset!");\n\t}\n\tthis->pFileContextInfo->lockContainersWrite();\n\tthis->pFileContextInfo->containers = std::move(newContainerList);\n\tthis->pFileContextInfo->unlockContainersWrite();\n\treturn result;\n}\nbool AssetsFileContextInfo::EnqueueContainersTask(AppContext &appContext, std::shared_ptr<AssetsFileContextInfo> selfPointer)\n{\n\tassert(selfPointer.get() == this);\n\tstd::shared_ptr<ContainersTask> pTask = std::make_shared<ContainersTask>(appContext, selfPointer);\n\tif (appContext.taskManager.enqueue(pTask))\n\t\treturn true;\n\treturn false;\n}\n\n\nbool AssetsFileContextInfo::_GetMonoBehaviourScriptInfo(AssetIdentifier &asset, AppContext &appContext,\n\tstd::string &fullClassName, std::string &assemblyName,\n\tstd::string &className, std::string &namespaceName,\n\tAssetIdentifier &scriptAsset)\n{\n\tif (!pContext || !pContext->getAssetsFile())\n\t\treturn false;\n\tbool ret = false;\n\t//Don\'t use class data from the .assets file (especially for bundled ones) as it might resolve MonoBehaviour to -1 or -2. \n\t//int monoBehaviourClass = -1;//pInterface->GetClassByName(pAssetsFile, "MonoBehaviour");\n\tif (asset.pathID != 0)\n\t{\n\t\tAssetTypeTemplateField behaviourBase;\n\t\tAssetTypeTemplateField *pBehaviourBase = &behaviourBase;\n\t\tstd::shared_lock classDatabaseLock(this->classDatabaseMutex);\n\t\tbool failed = true;\n\t\tif (pClassDatabase != nullptr)\n\t\t{\n\t\t\tfor (size_t i = 0; i < pClassDatabase->classes.size(); i++)\n\t\t\t{\n\t\t\t\tif (!strcmp(pClassDatabase->classes[i].name.GetString(pClassDatabase.get()), "MonoBehaviour"))\n\t\t\t\t{\n\t\t\t\t\tfailed = !pBehaviourBase->FromClassDatabase(pClassDatabase.get(), &pClassDatabase->classes[i], 0);\n\t\t\t\t\t//monoBehaviourClass = pFile->classes[i].classId;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tclassDatabaseLock.unlock();\n\t\tif (!failed)\n\t\t{\n\t\t\t//Try to find and read the script asset.\n\t\t\tIAssetsReader_ptr pReader = asset.makeReader();\n\t\t\tunsigned __int64 fileSize = asset.getDataSize();\n\t\t\tAssetTypeInstance behaviourInstance(1, &pBehaviourBase, fileSize, pReader.get(), asset.isBigEndian());\n\t\t\tpReader.reset();\n\n\t\t\tAssetTypeValueField *pBehaviourBase = behaviourInstance.GetBaseField();\n\t\t\tAssetTypeValueField *pScriptFileIDField;\n\t\t\tAssetTypeValueField *pScriptPathIDField;\n\t\t\tif ((pBehaviourBase != NULL) && \n\t\t\t\t(pScriptFileIDField = pBehaviourBase->Get("m_Script")->Get("m_FileID"))->GetValue() && \n\t\t\t\t(pScriptPathIDField = pBehaviourBase->Get("m_Script")->Get("m_PathID"))->GetValue())\n\t\t\t{\n\t\t\t\tunsigned int scriptFileID = asset.pFile->resolveRelativeFileID(pScriptFileIDField->GetValue()->AsInt());\n\t\t\t\tlong long int scriptPathID = pScriptPathIDField->GetValue()->AsInt64();\n\t\t\t\tscriptAsset = AssetIdentifier(scriptFileID, scriptPathID);\n\t\t\t\tif (scriptAsset.resolve(appContext))\n\t\t\t\t{\n\t\t\t\t\tAssetsFileContextInfo *pScriptAssetsContextInfo = scriptAsset.pFile.get();\n\t\t\t\t\tbool foundScript = false;\n\t\t\t\t\tint monoScriptClass = GetClassByName("MonoScript");\n\t\t\t\t\tAssetTypeTemplateField scriptTemplateBase;\n\t\t\t\t\tif ((monoScriptClass >= 0) && pScriptAssetsContextInfo->MakeTemplateField(&scriptTemplateBase, appContext, monoScriptClass))\n\t\t\t\t\t{\n\t\t\t\t\t\tunsigned long long curFileSize = scriptAsset.getDataSize();\n\t\t\t\t\t\tIAssetsReader_ptr pReader = scriptAsset.makeReader();\n\t\t\t\t\t\tif (pReader != nullptr)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tAssetTypeTemplateField *pScriptTemplateBase = &scriptTemplateBase;\n\t\t\t\t\t\t\tAssetTypeInstance scriptInstance(1, &pScriptTemplateBase, curFileSize, pReader.get(), scriptAsset.isBigEndian());\n\t\t\t\t\t\t\tAssetTypeValueField *pScriptBase = scriptInstance.GetBaseField();\n\t\t\t\t\t\t\tAssetTypeValueField *pScriptClassNameField; const char *scriptClassName;\n\t\t\t\t\t\t\tAssetTypeValueField *pScriptNamespaceField; const char *scriptNamespace;\n\t\t\t\t\t\t\tAssetTypeValueField *pScriptAssemblyNameField; const char *scriptAssemblyName;\n\t\t\t\t\t\t\tif ((pScriptBase != NULL) && \n\t\t\t\t\t\t\t\t(pScriptClassNameField = pScriptBase->Get("m_ClassName"))->GetValue()\n\t\t\t\t\t\t\t\t\t&& (scriptClassName = pScriptClassNameField->GetValue()->AsString()) &&\n\t\t\t\t\t\t\t\t(pScriptNamespaceField = pScriptBase->Get("m_Namespace"))->GetValue()\n\t\t\t\t\t\t\t\t\t&& (scriptNamespace = pScriptNamespaceField->GetValue()->AsString()))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif ((pScriptAssemblyNameField = pScriptBase->Get("m_AssemblyName"))->GetValue()\n\t\t\t\t\t\t\t\t\t&& (scriptAssemblyName = pScriptAssemblyNameField->GetValue()->AsString()))\n\t\t\t\t\t\t\t\t{}\n\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\tscriptAssemblyName = "";\n\t\t\t\t\t\t\t\tfullClassName = std::string(scriptNamespace);\n\t\t\t\t\t\t\t\tif (fullClassName.size() > 0)\n\t\t\t\t\t\t\t\t\tfullClassName += ".";\n\t\t\t\t\t\t\t\tfullClassName += scriptClassName;\n\t\t\t\t\t\t\t\tassemblyName = std::string(scriptAssemblyName);\n\t\t\t\t\t\t\t\tclassName = std::string(scriptClassName);\n\t\t\t\t\t\t\t\tnamespaceName = std::string(scriptNamespace);\n\t\t\t\t\t\t\t\tret = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}\nbool AssetsFileContextInfo::FindScriptClassDatabaseEntry(ClassDatabaseFile *&pClassFile, ClassDatabaseType *&pClassType, AssetIdentifier &asset, AppContext &appContext, Hash128 *pScriptID)\n{\n\tpClassFile = nullptr;\n\tpClassType = nullptr;\n\t{\n\t\t//Try to find a matching script class database entry.\n\t\tstd::string fullScriptName;\n\t\tstd::string assemblyName;\n\t\tstd::string scriptName;\n\t\tstd::string namespaceName;\n\t\tAssetIdentifier scriptAsset;\n\t\tif (_GetMonoBehaviourScriptInfo(asset, appContext, fullScriptName, assemblyName, scriptName, namespaceName, scriptAsset))\n\t\t{\n\t\t\t//Look for the script database in the .assets file where the MonoScript asset lies.\n\t\t\tauto &scriptDatabases = scriptAsset.pFile->lockScriptDatabases();\n\t\t\tbool found = false;\n\t\t\tfor (size_t i = 0; i < scriptDatabases.size(); i++)\n\t\t\t{\n\t\t\t\tstd::shared_ptr<ClassDatabaseFile> &pCurDatabase = scriptDatabases[i];\n\t\t\t\tif (!(pCurDatabase->header.flags & 1))\n\t\t\t\t\tcontinue;\n\t\t\t\tfor (size_t k = 0; k < pCurDatabase->classes.size(); k++)\n\t\t\t\t{\n\t\t\t\t\tClassDatabaseType &curType = pCurDatabase->classes[k];\n\t\t\t\t\tconst char *curAssemblyName = assemblyName.size() > 0 ? curType.assemblyFileName.GetString(pCurDatabase.get()) : "";\n\t\t\t\t\tconst char *curFullClassName = curType.name.GetString(pCurDatabase.get());\n\t\t\t\t\tif (curType.fields.size() > 1 && !stricmp(curAssemblyName, assemblyName.c_str()) && !strcmp(curFullClassName, fullScriptName.c_str()))\n\t\t\t\t\t{\n\t\t\t\t\t\tif (pScriptID)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t*pScriptID = MakeScriptID(scriptName.c_str(), namespaceName.c_str(), curType.assemblyFileName.GetString(pCurDatabase.get()));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tpClassFile = pCurDatabase.get();\n\t\t\t\t\t\tpClassType = &curType;\n\t\t\t\t\t\tscriptAsset.pFile->unlockScriptDatabases();\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tscriptAsset.pFile->unlockScriptDatabases();\n\t\t}\n\t}\n\tif (pScriptID) *pScriptID = Hash128();\n\treturn false;\n}\nbool AssetsFileContextInfo::MakeTemplateField(AssetTypeTemplateField *pTemplateBase, AppContext &appContext, int32_t classID, uint16_t scriptIndex, AssetIdentifier *pAsset,\n\tstd::optional<std::reference_wrapper<bool>> missingScriptTypeInfo)\n{\n\tif (missingScriptTypeInfo.has_value())\n\t\tmissingScriptTypeInfo->get() = false;\n\tif (!pContext || !pContext->getAssetsFile())\n\t\treturn false;\n\tpTemplateBase->Clear();\n\tif (pAsset != nullptr && pAsset->pReplacer != nullptr)\n\t{\n\t\tClassDatabaseFile_sharedptr pCldbFile; ClassDatabaseType* pCldbType = nullptr;\n\t\tif (pAsset->pReplacer->GetTypeInfo(pCldbFile, pCldbType))\n\t\t{\n\t\t\tpTemplateBase->Clear();\n\t\t\tif (pTemplateBase->FromClassDatabase(pCldbFile.get(), pCldbType, 0))\n\t\t\t\treturn true;\n\t\t}\n\t}\n\tAssetsFile *pAssetsFile = pContext->getAssetsFile();\n\n\tunion {\n\t\tType_07 *pU4TypeEntry;\n\t\tType_0D *pU5TypeEntry;\n\t} typeEntry = {NULL};\n\tif (classID < 0 && missingScriptTypeInfo.has_value())\n\t\tmissingScriptTypeInfo->get() = true;\n\tif (classID < 0 && (pAssetsFile->header.format >= 0x10))\n\t{\n\t\tint monoBehaviourClass = this->GetClassByName("MonoBehaviour");\n\t\tfor (size_t i = 0; i < pAssetsFile->typeTree.fieldCount; i++)\n\t\t{\n\t\t\tif ((pAssetsFile->typeTree.pTypes_Unity5[i].classId == monoBehaviourClass) && \n\t\t\t\tpAssetsFile->typeTree.pTypes_Unity5[i].scriptIndex == scriptIndex)\n\t\t\t{\n\t\t\t\ttypeEntry.pU5TypeEntry = &pAssetsFile->typeTree.pTypes_Unity5[i];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\telse if (pAssetsFile->header.format >= 0x0D)\n\t{\n\t\tfor (size_t i = 0; i < pAssetsFile->typeTree.fieldCount; i++)\n\t\t{\n\t\t\tType_0D &type = pAssetsFile->typeTree.pTypes_Unity5[i];\n\t\t\tif (type.classId == classID && (type.scriptIndex == 0xFFFF || scriptIndex != 0xFFFF || classID < 0))\n\t\t\t{\n\t\t\t\ttypeEntry.pU5TypeEntry = &pAssetsFile->typeTree.pTypes_Unity5[i];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t{\n\t\tfor (size_t i = 0; i < pAssetsFile->typeTree.fieldCount; i++)\n\t\t{\n\t\t\tif (pAssetsFile->typeTree.pTypes_Unity4[i].classId == classID)\n\t\t\t{\n\t\t\t\ttypeEntry.pU4TypeEntry = &pAssetsFile->typeTree.pTypes_Unity4[i];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tbool failed = false;\n\tif ((typeEntry.pU5TypeEntry != NULL) || (typeEntry.pU4TypeEntry != NULL))\n\t{\n\t\tif (missingScriptTypeInfo.has_value())\n\t\t\tmissingScriptTypeInfo->get() = false;\n\t\tif (pAssetsFile->header.format >= 0x0D)\n\t\t{\n\t\t\tif (typeEntry.pU5TypeEntry->typeFieldsExCount > 0)\n\t\t\t\tfailed = !pTemplateBase->From0D(typeEntry.pU5TypeEntry, 0);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfailed = !pTemplateBase->From07(&typeEntry.pU4TypeEntry->base);\n\t\t}\n\t\tif (failed)\n\t\t{\n\t\t\tpTemplateBase->Clear();\n\t\t\t//return false;\n\t\t}\n\t}\n\n\tif (pTemplateBase->children.size() == 0)\n\t{\n\t\tpTemplateBase->Clear();\n\t\tstd::shared_lock classDatabaseLock(classDatabaseMutex);\n\t\tif (pClassDatabase != nullptr)\n\t\t{\n\t\t\tClassDatabaseFile *pFile = pClassDatabase.get();\n\t\t\tfailed = false;\n\t\t\tfor (size_t i = 0; i < pFile->classes.size(); i++)\n\t\t\t{\n\t\t\t\tif (pFile->classes[i].classId == classID)\n\t\t\t\t{\n\t\t\t\t\tfailed = !pTemplateBase->FromClassDatabase(pFile, &pFile->classes[i], 0);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!failed && (pTemplateBase->children.size() == 0) && (classID < 0))\n\t\t\t{\n\t\t\t\tint monoBehaviourClass = this->GetClassByName("MonoBehaviour");\n\t\t\t\tif (monoBehaviourClass >= 0)\n\t\t\t\t{\n\t\t\t\t\tfailed = true;\n\t\t\t\t\tfor (size_t i = 0; i < pFile->classes.size(); i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (pFile->classes[i].classId == monoBehaviourClass)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfailed = !pTemplateBase->FromClassDatabase(pFile, &pFile->classes[i], 0);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tclassDatabaseLock.unlock();\n\t\t\t\t\tif (!failed && pAsset)\n\t\t\t\t\t{\n\t\t\t\t\t\tassert(classID == pAsset->getClassID());\n\t\t\t\t\t\tassert(scriptIndex == pAsset->getMonoScriptID());\n\n\t\t\t\t\t\tClassDatabaseFile *pScriptDatabase = nullptr;\n\t\t\t\t\t\tClassDatabaseType *pScriptType = nullptr;\n\t\t\t\t\t\t//Try to find a matching script class database entry and append the resulting template fields to the MonoBehaviour template.\n\t\t\t\t\t\tif (FindScriptClassDatabaseEntry(pScriptDatabase, pScriptType, *pAsset, appContext))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (missingScriptTypeInfo.has_value())\n\t\t\t\t\t\t\t\tmissingScriptTypeInfo->get() = false;\n\t\t\t\t\t\t\tAssetTypeTemplateField tempBase;\n\t\t\t\t\t\t\tif (tempBase.FromClassDatabase(pScriptDatabase, pScriptType, 0) && tempBase.children.size() > 0)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tuint32_t targetOffset = (uint32_t)pTemplateBase->children.size();\n\t\t\t\t\t\t\t\tpTemplateBase->AddChildren(tempBase.children.size());\n\t\t\t\t\t\t\t\tstd::copy(tempBase.children.begin(), tempBase.children.end(), pTemplateBase->children.begin() + targetOffset);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (missingScriptTypeInfo.has_value())\n\t\t\t\t\t\t\t\tmissingScriptTypeInfo->get() = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (failed)\n\t\t{\n\t\t\tpTemplateBase->Clear();\n\t\t\treturn false;\n\t\t}\n\t\tif (pTemplateBase->children.empty())\n\t\t{\n\t\t\tpTemplateBase->Clear();\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\nint32_t AssetsFileContextInfo::GetClassByName(const char *name)\n{\n\tunion {\n\t\tType_07 *pU4TypeEntry;\n\t\tType_0D *pU5TypeEntry;\n\t} typeEntry = {NULL};\n\tAssetsFile *pAssetsFile;\n\tif (!this->pContext || !(pAssetsFile = this->pContext->getAssetsFile()))\n\t\treturn -1;\n\tif (pAssetsFile->header.format >= 0x0D)\n\t{\n\t\tfor (size_t i = 0; i < pAssetsFile->typeTree.fieldCount; i++)\n\t\t{\n\t\t\tType_0D *pType = &pAssetsFile->typeTree.pTypes_Unity5[i];\n\t\t\tif (pType->typeFieldsExCount > 0 && \n\t\t\t\t!strcmp(pType->pTypeFieldsEx[0].GetTypeString(pType->pStringTable, pType->stringTableLen), name))\n\t\t\t{\n\t\t\t\treturn pType->classId;\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t{\n\t\tfor (size_t i = 0; i < pAssetsFile->typeTree.fieldCount; i++)\n\t\t{\n\t\t\tif (!strcmp(pAssetsFile->typeTree.pTypes_Unity4[i].base.type, name))\n\t\t\t{\n\t\t\t\treturn pAssetsFile->typeTree.pTypes_Unity4[i].classId;\n\t\t\t}\n\t\t}\n\t}\n\n\tstd::shared_lock classDatabaseLock(classDatabaseMutex);\n\tif (pClassDatabase != nullptr)\n\t{\n\t\tfor (size_t i = 0; i < pClassDatabase->classes.size(); i++)\n\t\t{\n\t\t\tif (!strcmp(pClassDatabase->classes[i].name.GetString(pClassDatabase.get()), name))\n\t\t\t{\n\t\t\t\treturn pClassDatabase->classes[i].classId;\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}\nstd::string AssetsFileContextInfo::GetClassName_(AppContext &appContext, int32_t classID, uint16_t scriptIndex, AssetIdentifier *pAsset)\n{\n\tunion {\n\t\tType_07 *pU4TypeEntry;\n\t\tType_0D *pU5TypeEntry;\n\t} typeEntry = {NULL};\n\tAssetsFile *pAssetsFile;\n\tif (!this->pContext || !(pAssetsFile = this->pContext->getAssetsFile()))\n\t\treturn std::string();\n\tif (classID >= 0 && scriptIndex == 0xFFFF)\n\t{\n\t\tif (pAssetsFile->header.format >= 0x0D)\n\t\t{\n\t\t\tif (pAssetsFile->typeTree.hasTypeTree)\n\t\t\t\tfor (size_t i = 0; i < pAssetsFile->typeTree.fieldCount; i++)\n\t\t\t\t{\n\t\t\t\t\tType_0D *pType = &pAssetsFile->typeTree.pTypes_Unity5[i];\n\t\t\t\t\tif (pType->typeFieldsExCount > 0 && pType->classId == classID && pType->scriptIndex == scriptIndex)\n\t\t\t\t\t{\n\t\t\t\t\t\tconst char *className = pType->pTypeFieldsEx->GetTypeString(pType->pStringTable, pType->stringTableLen);\n\t\t\t\t\t\tconst char *baseName = pType->pTypeFieldsEx->GetNameString(pType->pStringTable, pType->stringTableLen);\n\t\t\t\t\t\tif (!stricmp(baseName, "Base"))\n\t\t\t\t\t\t\treturn std::string(className);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfor (size_t i = 0; i < pAssetsFile->typeTree.fieldCount; i++)\n\t\t\t{\n\t\t\t\tType_07 *pType = &pAssetsFile->typeTree.pTypes_Unity4[i];\n\t\t\t\tif (pType->classId == classID)\n\t\t\t\t{\n\t\t\t\t\tif (!strnicmp(pType->base.name, "Base", 5))\n\t\t\t\t\t{\n\t\t\t\t\t\treturn std::string(&pType->base.type[0],\n\t\t\t\t\t\t\t&pType->base.type[strnlen(pType->base.type, sizeof(pType->base.type) / sizeof(char))]);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tstd::shared_lock classDatabaseLock(classDatabaseMutex);\n\t\tif (pClassDatabase != nullptr)\n\t\t{\n\t\t\tfor (size_t i = 0; i < pClassDatabase->classes.size(); i++)\n\t\t\t{\n\t\t\t\tif (pClassDatabase->classes[i].classId == classID)\n\t\t\t\t{\n\t\t\t\t\treturn std::string(pClassDatabase->classes[i].name.GetString(pClassDatabase.get()));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tclassDatabaseLock.unlock();\n\n\t\tconst char *typeName = NULL;\n\t\tchar sprntTmp[12];\n\t\tswitch (classID)\n\t\t{\n\t\t\tcase 0x01:\n\t\t\t\ttypeName = "GameObject";\n\t\t\t\tbreak;\n\t\t\tcase 0x04:\n\t\t\t\ttypeName = "Transform";\n\t\t\t\tbreak;\n\t\t\tcase 0x14:\n\t\t\t\ttypeName = "Camera";\n\t\t\t\tbreak;\n\t\t\tcase 0x15:\n\t\t\t\ttypeName = "Material";\n\t\t\t\tbreak;\n\t\t\tcase 0x17:\n\t\t\t\ttypeName = "MeshRenderer";\n\t\t\t\tbreak;\n\t\t\tcase 0x1C:\n\t\t\t\ttypeName = "Texture2D";\n\t\t\t\tbreak;\n\t\t\tcase 0x21:\n\t\t\t\ttypeName = "MeshFilter";\n\t\t\t\tbreak;\n\t\t\tcase 0x30:\n\t\t\t\ttypeName = "Shader";\n\t\t\t\tbreak;\n\t\t\tcase 0x31:\n\t\t\t\ttypeName = "Text";\n\t\t\t\tbreak;\n\t\t\tcase 0x41:\n\t\t\t\ttypeName = "BoxCollider";\n\t\t\t\tbreak;\n\t\t\tcase 0x53:\n\t\t\t\ttypeName = "Audio";\n\t\t\t\tbreak;\n\t\t\tcase 0x68:\n\t\t\t\ttypeName = "RenderSettings";\n\t\t\t\tbreak;\n\t\t\tcase 0x6C:\n\t\t\t\ttypeName = "Light";\n\t\t\t\tbreak;\n\t\t\tcase 0x7C:\n\t\t\t\ttypeName = "Behaviour";\n\t\t\t\tbreak;\n\t\t\tcase 0x7F:\n\t\t\t\ttypeName = "LevelGameManager";\n\t\t\t\tbreak;\n\t\t\tcase 0x87:\n\t\t\t\ttypeName = "SphereCollider";\n\t\t\t\tbreak;\n\t\t\tcase ASSETTYPE_ASSETBUNDLE:\n\t\t\t\ttypeName = "AssetBundle file table";\n\t\t\t\tbreak;\n\t\t\tcase 0x93:\n\t\t\t\ttypeName = "ResourceManager file table";\n\t\t\t\tbreak;\n\t\t\tcase 0x96:\n\t\t\t\ttypeName = "PreloadData";\n\t\t\t\tbreak;\n\t\t\tcase 0x9D:\n\t\t\t\ttypeName = "LightmapSettings";\n\t\t\t\tbreak;\n\t\t\tcase 0xD4:\n\t\t\t\ttypeName = "SpriteRenderer";\n\t\t\t\tbreak;\n\t\t\tcase 0xD5:\n\t\t\t\ttypeName = "Sprite";\n\t\t\t\tbreak;\n\t\t\tcase 0x122:\n\t\t\t\ttypeName = "AssetBundleManifest";\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tsprintf_s(sprntTmp, "0x%08X", classID);\n\t\t\t\ttypeName = sprntTmp;\n\t\t\t\tbreak;\n\t\t}\n\t\treturn std::string(typeName);\n\t}\n\telse\n\t{\n\t\tif (pAsset != NULL && classID < 0)\n\t\t{\n\t\t\tstd::string className;\n\t\t\tstd::string assemblyName;\n\t\t\tstd::string scriptName;\n\t\t\tstd::string namespaceName;\n\t\t\tAssetIdentifier scriptAsset;\n\t\t\tif (_GetMonoBehaviourScriptInfo(*pAsset, appContext, className, assemblyName, scriptName, namespaceName, scriptAsset))\n\t\t\t{\n\t\t\t\treturn std::string("MonoBehaviour : ") + className + " (" + assemblyName + ")"; \n\t\t\t}\n\t\t}\n\t\treturn std::string("MonoBehaviour");\n\t}\n\tassert(false);\n\treturn std::string();\n}\n\nstruct VersionRange\n{\n\tchar lastSeparator; //0 as a wildcard, otherwise typically \'.\', \'b\', \'f\', \'p\'.\n\tuint32_t start;\n\tuint32_t end;\n\tVersionRange(uint32_t start = 0, uint32_t end = UINT32_MAX)\n\t\t: lastSeparator(0), start(start), end(end)\n\t{}\n};\n//Supports normal engine version strings (5.4.3p1, 2019.3.13f1, ...) and range strings (5.4.*, 5.4.2+, 5.4.3p*, 5.4.3p1-5.4.4p4, etc.).\n// \'*\' matches any [uint]; value:=[uint] \'+\' matches any [uint] >= value; value:=[uint] matches only [uint] = value;\n// Separators such as \'.\',\'b\',\'f\',\'p\' must be equal, \n//  unless the current separator or a previous one in a range string of the form (from\'-\'to) differs between from and to.\n// \n//String format (char matches any non-digit including whitespace but not \'-\',\'+\',\'*\') :\n// Version: Range {char Range} (\'-\' uint {char uint})?\n// Range: uint | uint \'+\' | \'*\'\ninline bool parseRange(const std::string &versionString, size_t start, size_t &next, VersionRange &range)\n{\n\tif (versionString.size() <= start)\n\t\treturn false;\n\tif (versionString[start] == \'*\')\n\t{\n\t\tnext = start + 1;\n\t\trange.start = 0;\n\t\trange.end = (uint32_t)-1;\n\t\treturn true;\n\t}\n\tif (versionString[start] >= \'0\' && versionString[start] <= \'9\')\n\t{\n\t\tsize_t uintEnd = start + 1;\n\t\tfor (uintEnd = start + 1; uintEnd < versionString.size(); uintEnd++)\n\t\t{\n\t\t\tif (versionString[uintEnd] < \'0\' || versionString[uintEnd] > \'9\')\n\t\t\t\tbreak;\n\t\t}\n\t\tbool hasPlusSign = false;\n\t\tif (uintEnd < versionString.size() && versionString[uintEnd] == \'+\')\n\t\t{\n\t\t\thasPlusSign = true;\n\t\t\tnext = uintEnd + 1;\n\t\t}\n\t\telse\n\t\t\tnext = uintEnd;\n\t\tuint32_t uintVal = 0;\n\t\ttry {\n\t\t\tuintVal = (uint32_t)std::stoul(versionString.substr(start, uintEnd - start));\n\t\t} catch (...) { //Invalid number format, out of range, ...\n\t\t\treturn false;\n\t\t}\n\t\trange.start = uintVal;\n\t\trange.end = (hasPlusSign ? UINT32_MAX : uintVal);\n\t\treturn true;\n\t}\n\treturn false;\n}\nstatic std::vector<VersionRange> parseVersionString(std::string versionString)\n{\n\tstd::vector<VersionRange> ret;\n\tVersionRange curRange(0, UINT32_MAX);\n\tsize_t pos = 0;\n\twhile (parseRange(versionString, pos, pos, curRange))\n\t{\n\t\tret.push_back(curRange);\n\t\t//Match a char or \'-\'\n\t\tif (pos >= versionString.length())\n\t\t\treturn ret;\n\t\tif (versionString[pos] == \'+\' || versionString[pos] == \'*\'\n\t\t\t|| (versionString[pos] >= \'0\' && versionString[pos] <= \'9\'))\n\t\t\treturn ret;\n\t\tif (versionString[pos] == \'-\')\n\t\t\tbreak;\n\t\tcurRange = VersionRange();\n\t\tcurRange.lastSeparator = versionString[pos++];\n\t}\n\tif (pos < versionString.length() && versionString[pos] == \'-\')\n\t{\n\t\t//The version string has the format from\'-\'to.\n\t\t//Also match ranges here for simplicity (i.e. allowing the uint\'+\' and \'*\' cases).\n\t\tsize_t i = 0;\n\t\tbool anySeparator = false;\n\t\twhile (parseRange(versionString, pos, pos, curRange))\n\t\t{\n\t\t\tif (ret.size() > i)\n\t\t\t{\n\t\t\t\tif (curRange.lastSeparator != ret[i].lastSeparator)\n\t\t\t\t\tanySeparator = true;\n\t\t\t\tif (anySeparator)\n\t\t\t\t\tret[i].lastSeparator = 0; //wildcard\n\t\t\t\tret[i].end = curRange.end;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t//Wildcard the separator, since there is no strict order between \'f\' (final?) and \'p\' (patch) releases.\n\t\t\t\tcurRange.lastSeparator = 0; \n\t\t\t\tcurRange.start = 0;\n\t\t\t\tret.push_back(curRange);\n\t\t\t}\n\t\t\tif (pos >= versionString.length())\n\t\t\t\treturn ret;\n\t\t\t//Match a char.\n\t\t\tif (versionString[pos] == \'+\' || versionString[pos] == \'*\' || versionString[pos] == \'-\' \n\t\t\t\t|| (versionString[pos] >= \'0\' && versionString[pos] <= \'9\'))\n\t\t\t\treturn ret;\n\t\t\tcurRange = VersionRange();\n\t\t\tcurRange.lastSeparator = versionString[pos++];\n\t\t\ti++;\n\t\t}\n\t}\n\treturn ret;\n}\n\nbool versionRangesOverlap(const std::vector<VersionRange> &a, const std::vector<VersionRange> &b)\n{\n\tif (a.size() > b.size())\n\t\treturn versionRangesOverlap(b, a);\n\tfor (size_t i = 0; i < a.size(); i++)\n\t{\n\t\tif (i >= b.size())\n\t\t\treturn true;\n\t\t//Compare the separators and allow wildcards.\n\t\tif (a[i].lastSeparator && b[i].lastSeparator && a[i].lastSeparator != b[i].lastSeparator)\n\t\t\treturn false;\n\t\t//Cases :\n\t\t//Range from a starts before range from b but still overlaps\n\t\t//Range from a starts inside range from b\n\t\tif (a[i].end >= a[i].start && b[i].end >= b[i].start && (\n\t\t\t(a[i].start <= b[i].start && a[i].end >= b[i].start)\n\t\t\t|| (a[i].start >= b[i].start && a[i].start <= b[i].end)))\n\t\t{}\n\t\telse\n\t\t\treturn false;\n\t}\n\treturn true;\n}\n\nbool AssetsFileContextInfo::FindClassDatabase(ClassDatabasePackage &package)\n{\n\tAssetsFile *pAssetsFile;\n\tif (!this->pContext || !(pAssetsFile = this->pContext->getAssetsFile()))\n\t\treturn false;\n\n\t//Assuming that all Unity version strings are of the form \'Major.Minor.Hotfix<b|f|p>Build\'.\n\tstd::vector<VersionRange> targetVersion = parseVersionString(std::string(pAssetsFile->typeTree.unityVersion));\n\tif (targetVersion.size() == 4) //Safety measure against unexpected results (e.g. if parsing failed, all class databases would match).\n\t{\n\t\tfor (uint32_t k = 0; k < package.header.fileCount; k++)\n\t\t{\n\t\t\tfor (int l = 0; l < package.files[k]->header.unityVersionCount; l++)\n\t\t\t{\n\t\t\t\tchar *query = package.files[k]->header.pUnityVersions[l];\n\t\t\t\tstd::vector<VersionRange> referenceRange = parseVersionString(std::string(query));\n\n\t\t\t\tif (versionRangesOverlap(targetVersion, referenceRange))\n\t\t\t\t{\n\t\t\t\t\tstd::scoped_lock classDatabaseLock(this->classDatabaseMutex);\n\t\t\t\t\tpClassDatabase = ClassDatabaseFile_sharedptr(package.files[k], ClassDatabaseFileDeleter_Dummy);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (pClassDatabase)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (pClassDatabase)\n\t\t\treturn true; //Found a matching class database.\n\t}\n\tif (pAssetsFile->AssetCount == 0 || (pAssetsFile->typeTree.fieldCount > 0 && pAssetsFile->typeTree.hasTypeTree))\n\t\treturn true; //The type information is stored (hopefully for all types).\n\treturn false;\n}\n\nvoid AssetsFileContextInfo::SetClassDatabase(ClassDatabaseFile_sharedptr pClassDatabase)\n{\n\tstd::scoped_lock classDatabaseLock(this->classDatabaseMutex);\n\tthis->pClassDatabase = std::move(pClassDatabase);\n}\nClassDatabaseFile_sharedptr AssetsFileContextInfo::GetClassDatabase()\n{\n\tstd::shared_lock classDatabaseLock(this->classDatabaseMutex);\n\tClassDatabaseFile_sharedptr ret = this->pClassDatabase;\n\treturn ret;\n}\n\nBundleFileContextInfo::BundleFileContextInfo(BundleFileContext *pContext, unsigned int fileID, unsigned int parentFileID)\n\t: FileContextInfo(fileID, parentFileID), pContext(pContext), isDecompressed(false)\n{\n}\nBundleFileContextInfo::~BundleFileContextInfo()\n{\n\tif (this->pContext)\n\t\tCloseContext();\n}\nvoid BundleFileContextInfo::CloseContext()\n{\n\tIAssetsReader *pReader = this->pContext->getReaderUnsafe();\n\tthis->pContext->Close();\n\tdelete this->pContext;\n\tthis->pContext = nullptr;\n}\nIFileContext *BundleFileContextInfo::getFileContext()\n{\n\treturn this->pContext;\n}\nvoid BundleFileContextInfo::getChildFileIDs(std::vector<unsigned int> &childFileIDs)\n{\n\tstd::shared_lock directoryLock(this->directoryMutex);\n\tchildFileIDs.resize(directoryRefs.size());\n\tfor (size_t i = 0; i < directoryRefs.size(); ++i)\n\t\tchildFileIDs[i] = directoryRefs[i].fileID;\n}\nvoid BundleFileContextInfo::onCloseChild(unsigned int childFileID)\n{\n\tstd::scoped_lock directoryLock(this->directoryMutex);\n\tfor (size_t i = 0; i < directoryRefs.size(); i++)\n\t{\n\t\tif (directoryRefs[i].fileID == childFileID)\n\t\t\tdirectoryRefs[i].fileID = 0;\n\t}\n}\nbool BundleFileContextInfo::hasAnyChanges(AppContext &appContext)\n{\n\tif (this->getBundleFileContext() != nullptr && this->getBundleFileContext()->getReaderIsModified())\n\t\treturn true;\n\tstd::shared_lock directoryLock(this->directoryMutex);\n\tfor (size_t i = 0; i < directoryRefs.size(); i++)\n\t{\n\t\tunsigned int refFileID = directoryRefs[i].fileID;\n\t\tbool hasChanges = false;\n\t\tif (refFileID != 0)\n\t\t{\n\t\t\tFileContextInfo_ptr pContextInfo = appContext.getContextInfo(refFileID);\n\t\t\tif (pContextInfo && pContextInfo->hasAnyChanges(appContext))\n\t\t\t\thasChanges = true;\n\t\t}\n\t\telse if ((!directoryRefs[i].entryRemoved && directoryRefs[i].pOverrideReader != nullptr)\n\t\t\t|| (getBundleFileContext() != nullptr\n\t\t\t    && (directoryRefs[i].entryRemoved || (!directoryRefs[i].entryRemoved && directoryRefs[i].entryNameOverridden))\n\t\t\t\t&& i < getBundleFileContext()->getEntryCount()))\n\t\t\thasChanges = true;\n\t\tif (hasChanges)\n\t\t\treturn true;\n\t}\n\treturn false;\n}\nbool BundleFileContextInfo::hasNewChanges(AppContext &appContext)\n{\n\tstd::shared_lock directoryLock(this->directoryMutex);\n\tfor (size_t i = 0; i < directoryRefs.size(); i++)\n\t{\n\t\tunsigned int refFileID = directoryRefs[i].fileID;\n\t\tbool hasChanges = false;\n\t\tif (refFileID != 0)\n\t\t{\n\t\t\tFileContextInfo_ptr pContextInfo = appContext.getContextInfo(refFileID);\n\t\t\tif (pContextInfo && pContextInfo->hasNewChanges(appContext))\n\t\t\t\thasChanges = true;\n\t\t}\n\t\telse if (directoryRefs[i].newChangeFlag)\n\t\t\thasChanges = true;\n\t\tif (hasChanges)\n\t\t{\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\nstd::string BundleFileContextInfo::getNewEntryName(size_t index, bool acquireLock)\n{\n\t//Note: May be called while the caller has a exclusive lock on directoryLock.\n\tstd::shared_lock<std::shared_mutex> directoryLock(this->directoryMutex, std::defer_lock);\n\tif (acquireLock) directoryLock.lock();\n\tif (index < directoryRefs.size() && directoryRefs[index].entryNameOverridden)\n\t{\n\t\tstd::string ret = directoryRefs[index].newEntryName;\n\t\treturn ret;\n\t}\n\tif (acquireLock) directoryLock.unlock();\n\tif (!getBundleFileContext()) return "";\n\tauto res = getBundleFileContext()->getEntryName(index);\n\tif (res == nullptr) return "";\n\treturn res;\n}\nstd::string BundleFileContextInfo::getBundlePathName()\n{\n\tstd::string firstEntryName = getNewEntryName(0);\n\tif (firstEntryName.starts_with("BuildPlayer-") || firstEntryName.starts_with("CustomAssetBundle") || firstEntryName.starts_with("CAB"))\n\t{\n\t\tsize_t iSlash = firstEntryName.rfind(\'/\');\n\t\tif (iSlash != std::string::npos)\n\t\t\tfirstEntryName = firstEntryName.substr(iSlash + 1);\n\t\tsize_t iExtension = firstEntryName.rfind(\'.\');\n\t\tif (iExtension != std::string::npos)\n\t\t\tfirstEntryName = firstEntryName.substr(0, iExtension);\n\t\treturn firstEntryName;\n\t}\n\treturn "";\n}\n//Returns nullptr on error (e.g. index out of range, I/O error, ...), or if the entry has been deleted.\nstd::shared_ptr<IAssetsReader> BundleFileContextInfo::makeEntryReader(size_t index, bool &readerIsModified)\n{\n\treaderIsModified = false;\n\tBundleFileContext *pFileContext = this->getBundleFileContext();\n\tif (pFileContext == nullptr)\n\t\treturn nullptr;\n\tstruct CustomDeleter {\n\t\tCustomDeleter(std::shared_ptr<IAssetsReader> _parentReader)\n\t\t\t: parentReader(std::move(_parentReader))\n\t\t{}\n\t\tstd::shared_ptr<IAssetsReader> parentReader;\n\t\tvoid operator()(IAssetsReader *pReaderToFree)\n\t\t{\n\t\t\tFree_AssetsReader(pReaderToFree);\n\t\t\tparentReader.reset();\n\t\t}\n\t};\n\tstd::shared_lock directoryLock(this->directoryMutex);\n\tif (index < directoryRefs.size())\n\t{\n\t\tbool doRet = false;\n\t\tstd::shared_ptr<IAssetsReader> ret;\n\t\tif (directoryRefs[index].entryRemoved)\n\t\t\tdoRet = true;\n\t\telse if (directoryRefs[index].pOverrideReader != nullptr)\n\t\t{\n\t\t\tdoRet = true;\n\t\t\tret = std::shared_ptr<IAssetsReader>(\n\t\t\t\tdirectoryRefs[index].pOverrideReader->CreateView(),\n\t\t\t\tCustomDeleter(directoryRefs[index].pOverrideReader));\n\t\t\treaderIsModified = true;\n\t\t}\n\t\tif (doRet)\n\t\t{\n\t\t\treturn ret;\n\t\t}\n\t}\n\tdirectoryLock.unlock();\n\tif (index < pFileContext->getEntryCount())\n\t{\n\t\tstd::shared_ptr<IAssetsReader> ret = pFileContext->makeEntryReader(index);\n\t\tif (ret != nullptr)\n\t\t{\n\t\t\tIAssetsReader *retView = ret->CreateView();\n\t\t\treaderIsModified = pFileContext->getReaderIsModified();\n\t\t\treturn std::shared_ptr<IAssetsReader>(retView, CustomDeleter(std::move(ret)));\n\t\t}\n\t}\n\treturn nullptr;\n}\nstd::vector<std::unique_ptr<BundleReplacer>> BundleFileContextInfo::makeEntryReplacers(class AppContext &appContext, bool resetChangedFlag)\n{\n\tBundleFileContext *pFileContext = this->getBundleFileContext();\n\tassert(pFileContext != nullptr);\n\n\tstd::unique_lock<std::shared_mutex> directoryLockExclusive(this->directoryMutex, std::defer_lock);\n\tstd::shared_lock<std::shared_mutex> directoryLockShared(this->directoryMutex, std::defer_lock);\n\tif (resetChangedFlag)\n\t\tdirectoryLockExclusive.lock();\n\telse\n\t\tdirectoryLockShared.lock();\n\tstd::vector<std::unique_ptr<BundleReplacer>> pReplacers;\n\tuint32_t nEntries = (uint32_t)std::min<size_t>(UINT_MAX, directoryRefs.size());\n\tfor (uint32_t i = 0; i < nEntries; i++)\n\t{\n\t\tconst char *oldName = pFileContext->getEntryName(i);\n\t\tassert(oldName != nullptr || i >= pFileContext->getEntryCount());\n\t\tif (oldName == nullptr)\n\t\t{\n\t\t\tif (i < pFileContext->getEntryCount())\n\t\t\t\tcontinue;\n\t\t}\n\t\tstd::string newName = getNewEntryName(i, false);\n\t\tassert(!newName.empty() || oldName == nullptr);\n\t\tif (newName.empty()) newName.assign(oldName);\n\t\tunsigned int refFileID = directoryRefs[i].fileID;\n\t\tuint32_t bundleEntryIndex = (i < pFileContext->getEntryCount()) ? (uint32_t)i : (uint32_t)-1;\n\t\tFileContextInfo_ptr pContextInfo = (refFileID != 0) ? appContext.getContextInfo(refFileID) : nullptr;\n\t\tif (pContextInfo && pContextInfo->hasAnyChanges(appContext))\n\t\t{\n\t\t\tconst char *replacerOldName = oldName;\n\t\t\tif (pContextInfo->getFileContext())\n\t\t\t{\n\t\t\t\tIAssetsReader *pModifiedReader = nullptr;\n\t\t\t\tIFileContext *pContext = pContextInfo->getFileContext();\n\t\t\t\tswitch (pContext->getType())\n\t\t\t\t{\n\t\t\t\tcase FileContext_Assets:\n\t\t\t\t\tif (reinterpret_cast<AssetsFileContext*>(pContext)->getReaderIsModified())\n\t\t\t\t\t\tpModifiedReader = reinterpret_cast<AssetsFileContext*>(pContext)->createReaderView();\n\t\t\t\t\tbreak;\n\t\t\t\tcase FileContext_Bundle:\n\t\t\t\t\tif (reinterpret_cast<BundleFileContext*>(pContext)->getReaderIsModified())\n\t\t\t\t\t\tpModifiedReader = reinterpret_cast<BundleFileContext*>(pContext)->createReaderView();\n\t\t\t\t\tbreak;\n\t\t\t\tcase FileContext_Resources:\n\t\t\t\t\tif (reinterpret_cast<ResourcesFileContext*>(pContext)->getReaderIsModified())\n\t\t\t\t\t\tpModifiedReader = reinterpret_cast<ResourcesFileContext*>(pContext)->createReaderView();\n\t\t\t\t\tbreak;\n\t\t\t\tcase FileContext_Generic:\n\t\t\t\t\tif (reinterpret_cast<GenericFileContext*>(pContext)->getReaderIsModified())\n\t\t\t\t\t\tpModifiedReader = reinterpret_cast<GenericFileContext*>(pContext)->createReaderView();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (pModifiedReader != nullptr)\n\t\t\t\t{\n\t\t\t\t\tQWORD size = 0;\n\t\t\t\t\tif (!pModifiedReader->Seek(AssetsSeek_End, 0))\n\t\t\t\t\t\tassert(false);\n\t\t\t\t\tif (!pModifiedReader->Tell(size))\n\t\t\t\t\t\tassert(false);\n\t\t\t\t\tif (!pModifiedReader->Seek(AssetsSeek_Begin, 0))\n\t\t\t\t\t\tassert(false);\n\n\t\t\t\t\tstruct {\n\t\t\t\t\t\tstd::shared_ptr<FileContextInfo> contextInfoRef;\n\t\t\t\t\t\tvoid operator()(IAssetsReader* pReader) { Free_AssetsReader(pReader); contextInfoRef.reset(); }\n\t\t\t\t\t} fullReaderDeleter;\n\t\t\t\t\tfullReaderDeleter.contextInfoRef = pContextInfo;\n\n\t\t\t\t\tpReplacers.push_back(std::unique_ptr<BundleReplacer>(MakeBundleEntryModifier(oldName, newName.c_str(),\n\t\t\t\t\t\t(pContext->getType() == FileContext_Assets),\n\t\t\t\t\t\tstd::shared_ptr<IAssetsReader>(pModifiedReader, fullReaderDeleter), size,\n\t\t\t\t\t\t0, 0, bundleEntryIndex)));\n\t\t\t\t\treplacerOldName = newName.c_str();\n\t\t\t\t}\n\t\t\t}\n\t\t\tstd::unique_ptr<BundleReplacer> curReplacer = pContextInfo->makeBundleReplacer(appContext, replacerOldName, newName.c_str(), bundleEntryIndex, resetChangedFlag);\n\t\t\tif (curReplacer)\n\t\t\t\tpReplacers.push_back(std::move(curReplacer));\n\t\t}\n\t\telse if (directoryRefs[i].entryRemoved)\n\t\t{\n\t\t\tif (i < pFileContext->getEntryCount())\n\t\t\t\tpReplacers.push_back(std::unique_ptr<BundleReplacer>(MakeBundleEntryRemover(oldName, bundleEntryIndex)));\n\t\t}\n\t\telse if (directoryRefs[i].pOverrideReader != nullptr)\n\t\t{\n\t\t\tIAssetsReader *pReaderView = directoryRefs[i].pOverrideReader->CreateView();\n\t\t\tQWORD size = 0;\n\t\t\tif (!pReaderView->Seek(AssetsSeek_End, 0))\n\t\t\t\tassert(false);\n\t\t\tif (!pReaderView->Tell(size))\n\t\t\t\tassert(false);\n\t\t\tif (!pReaderView->Seek(AssetsSeek_Begin, 0))\n\t\t\t\tassert(false);\n\t\t\tstruct {\n\t\t\t\tstd::shared_ptr<IAssetsReader> baseReaderRef;\n\t\t\t\tvoid operator()(IAssetsReader* pReader) { Free_AssetsReader(pReader); baseReaderRef.reset(); }\n\t\t\t} fullReaderDeleter;\n\t\t\tfullReaderDeleter.baseReaderRef = directoryRefs[i].pOverrideReader;\n\t\t\tpReplacers.push_back(std::unique_ptr<BundleReplacer>(MakeBundleEntryModifier(oldName, newName.c_str(), \n\t\t\t\tdirectoryRefs[i].hasSerializedData, std::shared_ptr<IAssetsReader>(pReaderView, fullReaderDeleter),\n\t\t\t\tsize, 0, 0, bundleEntryIndex)));\n\t\t}\n\t\telse if (directoryRefs[i].entryNameOverridden && (bundleEntryIndex != (uint32_t)-1))\n\t\t{\n\t\t\tpReplacers.push_back(std::unique_ptr<BundleReplacer>(MakeBundleEntryRenamer(oldName, newName.c_str(), \n\t\t\t\tdirectoryRefs[i].hasSerializedData, bundleEntryIndex)));\n\t\t}\n\t\tif (resetChangedFlag)\n\t\t\tdirectoryRefs[i].newChangeFlag = false;\n\t}\n\treturn pReplacers;\n}\nuint64_t BundleFileContextInfo::write(class AppContext &appContext, IAssetsWriter *pWriter, uint64_t start, bool resetChangedFlag)\n{\n\tassert(this->getBundleFileContext() != nullptr);\n\tif (this->getBundleFileContext() == nullptr || this->getBundleFileContext()->getBundleFile() == nullptr)\n\t\treturn 0;\n\tBundleFileContext *pFileContext = this->getBundleFileContext();\n\tIAssetsReader *pReaderView = pFileContext->getReaderUnsafe()->CreateView();\n\tassert(pReaderView != nullptr);\n\tif (pReaderView == nullptr)\n\t\treturn 0;\n\tIAssetsWriter *pWriterOffset = Create_AssetsWriterToWriterOffset(pWriter, start);\n\n\tstd::vector<std::unique_ptr<BundleReplacer>> pReplacers = makeEntryReplacers(appContext, resetChangedFlag);\n\tstd::vector<BundleReplacer*> pReplacers_raw(pReplacers.size());\n\tfor (size_t i = 0; i < pReplacers.size(); ++i)\n\t\tpReplacers_raw[i] = pReplacers[i].get();\n\tbool written = pFileContext->getBundleFile()->Write(pReaderView, pWriter, pReplacers_raw.data(), pReplacers_raw.size());\n\n\tFree_AssetsReader(pReaderView);\n\tuint64_t endPos = 0;\n\tif (written && (!pWriterOffset->Seek(AssetsSeek_End, 0) || !pWriterOffset->Tell(endPos)))\n\t\tassert(false);\n\tFree_AssetsWriter(pWriterOffset);\n\treturn endPos;\n}\nstd::unique_ptr<BundleReplacer> BundleFileContextInfo::makeBundleReplacer(class AppContext &appContext, \n\tconst char *oldName, const char *newName, uint32_t bundleIndex, \n\tbool resetChangedFlag)\n{\n\tassert(this->getBundleFileContext() != nullptr);\n\tif (this->getBundleFileContext() == nullptr || this->getBundleFileContext()->getBundleFile() == nullptr)\n\t\treturn nullptr;\n\tstd::vector<std::unique_ptr<BundleReplacer>> pReplacers = makeEntryReplacers(appContext, resetChangedFlag);\n\tif (pReplacers.empty())\n\t\treturn nullptr;\n\treturn MakeBundleEntryModifierFromBundle(oldName, newName, std::move(pReplacers), bundleIndex);\n}\nvoid BundleFileContextInfo::onDirectoryReady(class AppContext &appContext)\n{\n\t{\n\t\tstd::scoped_lock directoryLock(this->directoryMutex);\n\t\tthis->directoryRefs.clear();\n\t\tthis->directoryRefs.resize(pContext->getEntryCount());\n\t\tfor (size_t i = 0; i < pContext->getEntryCount(); ++i)\n\t\t\tthis->directoryRefs[i].hasSerializedData = pContext->hasSerializedData(i);\n\t}\n\t\n\tfor (size_t i = 0; this->modificationsToApply && i < this->modificationsToApply->replacers.size(); ++i)\n\t{\n\t\tstd::shared_ptr<GenericReplacer> pReplacer = this->modificationsToApply->replacers[i].pReplacer;\n\t\tBundleReplacer *pBundleReplacer = reinterpret_cast<BundleReplacer*>(this->modificationsToApply->replacers[i].pReplacer.get());\n\t\tconst char *origEntryName = pBundleReplacer->GetOriginalEntryName();\n\t\tsize_t index = (size_t)-1;\n\t\tif (origEntryName != nullptr)\n\t\t{\n\t\t\tfor (size_t k = 0; k < pContext->getEntryCount(); ++k)\n\t\t\t{\n\t\t\t\tconst char *curEntryName = pContext->getEntryName(k);\n\t\t\t\tif (curEntryName != nullptr && !stricmp(curEntryName, origEntryName))\n\t\t\t\t{\n\t\t\t\t\tindex = k;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tstd::shared_lock directoryLock(this->directoryMutex);\n\t\t\tfor (size_t k = 0; k < this->directoryRefs.size(); ++k)\n\t\t\t{\n\t\t\t\tif (this->directoryRefs[k].entryNameOverridden && !this->directoryRefs[k].newEntryName.compare(origEntryName))\n\t\t\t\t{\n\t\t\t\t\tindex = k;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//std::shared_ptr<IAssetsReader> pOrigEntryReader = pContext->makeEntryReader();\n\t\tswitch (pBundleReplacer->GetType())\n\t\t{\n\t\tcase BundleReplacement_Remove:\n\t\t\tassert(index != (size_t)-1);\n\t\t\tif (index != (size_t)-1)\n\t\t\t\tthis->removeEntry(appContext, index);\n\t\t\tbreak;\n\t\tcase BundleReplacement_Rename:\n\t\t\t{\n\t\t\t\tconst char *newEntryName = pBundleReplacer->GetEntryName();\n\t\t\t\tassert(index != (size_t)-1 && newEntryName != nullptr);\n\t\t\t\tif (index != (size_t)-1 && newEntryName != nullptr)\n\t\t\t\t\tthis->renameEntry(appContext, index, newEntryName);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase BundleReplacement_AddOrModify:\n\t\t\t{\n\t\t\t\tconst char *newEntryName = pBundleReplacer->GetEntryName();\n\t\t\t\tassert(newEntryName != nullptr);\n\t\t\t\tif (!newEntryName)\n\t\t\t\t\tnewEntryName = origEntryName;\n\t\t\t\tif (auto* pResourceModifier = dynamic_cast<BundleEntryModifierByResources*>(pBundleReplacer))\n\t\t\t\t{\n\t\t\t\t\t//Generate an empty reader, and then add a new child file with the resource replacer.\n\t\t\t\t\tassert(!pResourceModifier->RequiresEntryReader());\n\t\t\t\t\tstd::shared_ptr<IAssetsReader> pReader = std::shared_ptr<IAssetsReader>(\n\t\t\t\t\t\tCreate_AssetsReaderFromMemory(nullptr, 0, false, nullptr),\n\t\t\t\t\t\tFree_AssetsReader);\n\t\t\t\t\tstd::shared_ptr<BundleReplacer> pBundleReplacer = std::reinterpret_pointer_cast<BundleReplacer>(pReplacer);\n\t\t\t\t\tthis->modificationsToApply->subFiles.emplace_back(appContext, pBundleReplacer, BundleReplacer_BundleEntryModifierByResources);\n\t\t\t\t\tif (index != (size_t)-1)\n\t\t\t\t\t{\n\t\t\t\t\t\tthis->overrideEntryReader(appContext, index, pReader, pBundleReplacer->HasSerializedData(), std::string(newEntryName));\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tthis->addEntry(appContext, pReader, pBundleReplacer->HasSerializedData(), std::string(newEntryName));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tstd::shared_ptr<IAssetsReader> pReader = MakeReaderFromBundleEntryModifier(std::shared_ptr<BundleReplacer>(pReplacer, pBundleReplacer));\n\t\t\t\t\tassert(pReader != nullptr);\n\t\t\t\t\tif (pReader != nullptr)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (index != (size_t)-1)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tthis->overrideEntryReader(appContext, index, pReader, pBundleReplacer->HasSerializedData(), std::string(newEntryName));\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tthis->addEntry(appContext, pReader, pBundleReplacer->HasSerializedData(), std::string(newEntryName));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (this->modificationsToApply)\n\t\tthis->modificationsToApply->replacers.clear();\n}\nbool BundleFileContextInfo::renameEntry(class AppContext &appContext, size_t index, std::string newEntryName)\n{\n\tbool ret = false;\n\tstd::unique_lock directoryLock(this->directoryMutex);\n\tif (index < this->directoryRefs.size() && (this->directoryRefs[index].fileID != 0 || !this->directoryRefs[index].entryRemoved))\n\t{\n\t\tthis->directoryRefs[index].newEntryName = newEntryName;\n\t\tthis->directoryRefs[index].entryNameOverridden = true;\n\t\tthis->directoryRefs[index].newChangeFlag = true;\n\t\tret = true;\n\t\tauto pChildInfo = appContext.getContextInfo(this->directoryRefs[index].fileID);\n\t\tif (pChildInfo)\n\t\t{\n\t\t\tpChildInfo->setFileName(std::move(newEntryName));\n\t\t}\n\t}\n\tdirectoryLock.unlock();\n\tappContext.OnChangeBundleEntry_Async(this, index);\n\treturn ret;\n}\nbool BundleFileContextInfo::overrideEntryReader(AppContext &appContext, size_t index, std::shared_ptr<IAssetsReader> pReader, bool hasSerializedData)\n{\n\tbool ret = false;\n\tstd::unique_lock directoryLock(this->directoryMutex);\n\tif (index < this->directoryRefs.size() && (this->directoryRefs[index].fileID != 0 || !this->directoryRefs[index].entryRemoved))\n\t{\n\t\tthis->directoryRefs[index].pOverrideReader = std::move(pReader);\n\t\tthis->directoryRefs[index].hasSerializedData = hasSerializedData;\n\t\tthis->directoryRefs[index].newChangeFlag = true;\n\t\tret = true;\n\t}\n\tdirectoryLock.unlock();\n\tappContext.OnChangeBundleEntry_Async(this, index);\n\treturn ret;\n}\nbool BundleFileContextInfo::removeEntry(class AppContext &appContext, size_t index)\n{\n\tbool ret = false;\n\tstd::unique_lock directoryLock(this->directoryMutex);\n\tif (index < this->directoryRefs.size())\n\t{\n\t\tif (!this->directoryRefs[index].entryRemoved)\n\t\t{\n\t\t\tthis->directoryRefs[index].entryRemoved = true;\n\t\t\tthis->directoryRefs[index].newChangeFlag = true;\n\t\t}\n\t\tret = true;\n\t}\n\tdirectoryLock.unlock();\n\tappContext.OnChangeBundleEntry_Async(this, index);\n\treturn ret;\n}\nsize_t BundleFileContextInfo::addEntry(class AppContext &appContext, std::shared_ptr<IAssetsReader> pReader, bool hasSerializedData, std::string entryName)\n{\n\tstd::unique_lock directoryLock(this->directoryMutex);\n\n\tthis->directoryRefs.push_back(BundleFileDirectoryInfo());\n\tsize_t index = this->directoryRefs.size() - 1;\n\tthis->directoryRefs[index].pOverrideReader = std::move(pReader);\n\tthis->directoryRefs[index].hasSerializedData = hasSerializedData;\n\tthis->directoryRefs[index].newEntryName = std::move(entryName);\n\tthis->directoryRefs[index].entryNameOverridden = true;\n\tthis->directoryRefs[index].newChangeFlag = true;\n\n\tdirectoryLock.unlock();\n\tappContext.OnChangeBundleEntry_Async(this, index);\n\treturn index;\n}\n//Checks whether an entry has been removed. Can return true even if the child file still is open.\nbool BundleFileContextInfo::entryIsRemoved(size_t index)\n{\n\tbool ret = false;\n\tstd::shared_lock directoryLock(this->directoryMutex);\n\tif (index < this->directoryRefs.size())\n\t{\n\t\tret = this->directoryRefs[index].entryRemoved;\n\t}\n\treturn ret;\n}\n//Checks whether an entry has changed (renamed, reader overridden, removed, added). Does not check for changes in the child FileContextInfo.\nbool BundleFileContextInfo::entryHasChanged(size_t index)\n{\n\tbool ret = false;\n\tstd::shared_lock directoryLock(this->directoryMutex);\n\tif (index < this->directoryRefs.size())\n\t{\n\t\tif (this->getBundleFileContext() && index >= this->getBundleFileContext()->getEntryCount())\n\t\t\tret = true;\n\t\telse if (this->directoryRefs[index].entryNameOverridden || this->directoryRefs[index].entryRemoved\n\t\t\t|| this->directoryRefs[index].pOverrideReader != nullptr)\n\t\t\tret = true;\n\t}\n\treturn ret;\n}\nsize_t BundleFileContextInfo::getEntryCount()\n{\n\tstd::shared_lock directoryLock(this->directoryMutex);\n\tsize_t ret = this->directoryRefs.size();\n\treturn ret;\n}\nBundleFileContextInfo::DecompressTask::DecompressTask(AppContext &appContext, std::shared_ptr<BundleFileContextInfo> &pContextInfo, std::string outputPath)\n\t: appContext(appContext), pFileContextInfo(pContextInfo), outputPath(outputPath),\n\tdecompressStatus(static_cast<EBundleFileDecompressStatus>(TaskResult_Canceled)), \n\treopenStatus(static_cast<EBundleFileOpenStatus>(TaskResult_Canceled))\n{\n\tassert(pFileContextInfo->getBundleFileContext() && pFileContextInfo->getBundleFileContext()->getBundleFile());\n\tname = "Decompress bundle : " + pContextInfo->getFileName() + "";\n}\nconst std::string &BundleFileContextInfo::DecompressTask::getName()\n{\n\treturn name;\n}\nTaskResult BundleFileContextInfo::DecompressTask::execute(TaskProgressManager &progressManager)\n{\n\tif (!this->pFileContextInfo->getBundleFileContext() || !this->pFileContextInfo->getBundleFileContext()->getBundleFile())\n\t{\n\t\tprogressManager.logMessage("Bundle file not loaded!");\n\t\treturn -1;\n\t}\n\tprogressManager.setProgress(0, 250);\n\tprogressManager.setProgressDesc("Decompressing the bundle file.");\n\t//Assuming that this is the first and only time DecompressSync is called.\n\tthis->decompressStatus = this->pFileContextInfo->getBundleFileContext()->DecompressSync(nullptr, this->outputPath);\n\tif (this->decompressStatus != BundleFileDecompressStatus_OK)\n\t{\n\t\tswitch (this->decompressStatus)\n\t\t{\n\t\tcase BundleFileDecompressStatus_ErrOutFileOpen:\n\t\t\tprogressManager.logMessage("Unable to open the output file for decompression!");\n\t\t\tbreak;\n\t\tcase BundleFileDecompressStatus_ErrDecompress:\n\t\t\tprogressManager.logMessage("Bundle file not loaded!");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tprogressManager.logMessage("An unknown error occured during decompression!");\n\t\t}\n\t\tprogressManager.setProgress(250, 250);\n\t\treturn -3;\n\t}\n\tstd::shared_ptr<IAssetsReader> pDecompressedReader = std::shared_ptr<IAssetsReader>(\n\t\tCreate_AssetsReaderFromFile(this->outputPath.c_str(), true, RWOpenFlags_Immediately),\n\t\tFree_AssetsReader);\n\tif (pDecompressedReader == nullptr)\n\t{\n\t\tprogressManager.logMessage("Cannot reopen the decompressed file!");\n\t\treturn -2;\n\t}\n\tprogressManager.setProgress(150, 250);\n\tprogressManager.setProgressDesc("Reopening the bundle file.");\n\n\tIFileContext *pParentFileContext = this->pFileContextInfo->getBundleFileContext()->getParent();\n\tBundleFileContext *pNewBundleContext;\n\tif (pParentFileContext)\n\t\tpNewBundleContext = new BundleFileContext(this->pFileContextInfo->getBundleFileContext()->getFilePath(), pParentFileContext, pDecompressedReader);\n\telse\n\t\tpNewBundleContext = new BundleFileContext(this->pFileContextInfo->getBundleFileContext()->getFilePath(), pDecompressedReader);\n\n\tthis->reopenStatus = pNewBundleContext->OpenInsideTask(&progressManager, 150, 250);\n\tprogressManager.setProgress(250, 250);\n\tif (this->reopenStatus >= 0 && this->reopenStatus != BundleFileOpenStatus_Pend)\n\t{\n\t\tif (this->reopenStatus == BundleFileOpenStatus_CompressedDirectory ||\n\t\t\tthis->reopenStatus == BundleFileOpenStatus_CompressedData)\n\t\t{\n\t\t\tprogressManager.logMessage("The decompressed file still appears to be compressed!");\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis->pFileContextInfo->CloseContext();\n\t\t\tthis->pFileContextInfo->pContext = pNewBundleContext;\n\t\t\tthis->pFileContextInfo->isDecompressed = true;\n\t\t\tthis->pFileContextInfo->onDirectoryReady(appContext);\n\t\t\treturn 0;\n\t\t}\n\t}\n\tdelete pNewBundleContext;\n\n\treturn -1;\n}\nstd::shared_ptr<BundleFileContextInfo::DecompressTask> BundleFileContextInfo::EnqueueDecompressTask(\n\tAppContext &appContext, std::shared_ptr<BundleFileContextInfo> &selfPointer, std::string outputPath)\n{\n\tassert(selfPointer.get() == this);\n\tstd::shared_ptr<DecompressTask> pTask = std::make_shared<DecompressTask>(appContext, selfPointer, outputPath);\n\tif (appContext.taskManager.enqueue(pTask))\n\t\treturn pTask;\n\treturn nullptr;\n}\n\n#pragma region ResourcesFileContextInfo\nResourcesFileContextInfo::ResourcesFileContextInfo(ResourcesFileContext *pContext, unsigned int fileID, unsigned int parentFileID)\n\t: FileContextInfo(fileID, parentFileID), pContext(pContext), changedFlag(false)\n{\n\tIAssetsReader* pReader = this->pContext->getReaderUnsafe();\n\tif (pReader == nullptr)\n\t\tthrow std::invalid_argument("ResourcesFileContextInfo: Context has a null reader!");\n\tIAssetsReader* pReaderView = pReader->CreateView();\n\tif (pReaderView == nullptr)\n\t\tthrow std::runtime_error("ResourcesFileContextInfo: Unable to create a reader view!");\n\tpReaderView->Seek(AssetsSeek_End, 0);\n\toriginalFileSize = 0;\n\tpReaderView->Tell(originalFileSize);\n\tFree_AssetsReader(pReaderView);\n\n\tReplacedResourceDesc placeholderDesc = {};\n\tplaceholderDesc.outRangeBegin = 0;\n\tplaceholderDesc.rangeSize = originalFileSize;\n\tplaceholderDesc.reader = nullptr;\n\tplaceholderDesc.inRangeBegin = 0;\n\tplaceholderDesc.fromOriginalFile = true;\n\tresources.push_front(placeholderDesc);\n}\nResourcesFileContextInfo::~ResourcesFileContextInfo()\n{\n\tIAssetsReader *pReader = this->pContext->getReaderUnsafe();\n\tthis->pContext->Close();\n\tdelete this->pContext;\n\tthis->pContext = nullptr;\n}\nIFileContext *ResourcesFileContextInfo::getFileContext()\n{\n\treturn this->pContext;\n}\nvoid ResourcesFileContextInfo::getChildFileIDs(std::vector<unsigned int> &childFileIDs)\n{\n\tchildFileIDs.clear();\n}\nvoid ResourcesFileContextInfo::onCloseChild(unsigned int childFileID)\n{\n}\nbool ResourcesFileContextInfo::hasNewChanges(class AppContext &appContext)\n{\n\treturn this->changedFlag;\n}\nbool ResourcesFileContextInfo::hasAnyChanges(class AppContext &appContext)\n{\n\tif (this->getResourcesFileContext() != nullptr && this->getResourcesFileContext()->getReaderIsModified())\n\t\treturn true;\n\tstd::shared_lock resourcesLock(this->resourcesMutex);\n\tuint64_t curOutRange = 0;\n\tfor (auto resourcesIt = this->resources.begin(); resourcesIt != this->resources.end(); ++resourcesIt)\n\t{\n\t\tif (resourcesIt->rangeSize > 0)\n\t\t{\n\t\t\tif (!resourcesIt->fromOriginalFile || resourcesIt->reader != nullptr)\n\t\t\t\treturn true;\n\t\t\tif (resourcesIt->inRangeBegin != resourcesIt->outRangeBegin)\n\t\t\t\treturn true;\n\t\t}\n\t\tif (resourcesIt->outRangeBegin != curOutRange)\n\t\t{\n\t\t\tassert(false);\n\t\t\treturn true;\n\t\t}\n\t\tcurOutRange += resourcesIt->rangeSize;\n\t}\n\tif (curOutRange != originalFileSize)\n\t\treturn true;\n\treturn false;\n}\nuint64_t ResourcesFileContextInfo::write(class AppContext &appContext, IAssetsWriter *pWriter, uint64_t start, bool resetChangedFlag)\n{\n\tassert(this->pContext != nullptr);\n\tif (this->pContext == nullptr)\n\t\treturn 0;\n\tIAssetsReader* pOrigReader = this->pContext->getReaderUnsafe()->CreateView();\n\tstd::vector<uint8_t> buffer(1024 * 1024); //1MiB\n\n\tstd::shared_lock resourcesLock(this->resourcesMutex);\n\tuint64_t curOutPos = 0;\n\tbool errorsOccured = false;\n\tfor (auto resourcesIt = this->resources.begin(); resourcesIt != this->resources.end(); ++resourcesIt)\n\t{\n\t\tassert(resourcesIt->outRangeBegin == curOutPos);\n\t\tIAssetsReader* pCurReader = resourcesIt->reader.get();\n\t\tif (pCurReader == nullptr && resourcesIt->fromOriginalFile)\n\t\t\tpCurReader = this->pContext->getReaderUnsafe();\n\t\tif (pCurReader == nullptr)\n\t\t{\n\t\t\t//Fill buffer with zeroes.\n\t\t\tsize_t bufSize = buffer.size();\n\t\t\tbuffer.clear();\n\t\t\tbuffer.resize(bufSize, 0);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpCurReader = pCurReader->CreateView();\n\t\t\tif (pCurReader == nullptr)\n\t\t\t{\n\t\t\t\tassert(false);\n\t\t\t\terrorsOccured = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tpCurReader->SetPosition(resourcesIt->inRangeBegin);\n\t\t}\n\t\tfor (uint64_t i = 0; i < resourcesIt->rangeSize; )\n\t\t{\n\t\t\tuint64_t curRead = 0;\n\t\t\t//Read a block of data.\n\t\t\tif (pCurReader != nullptr)\n\t\t\t\tcurRead = pCurReader->Read(std::min<uint64_t>(buffer.size(), resourcesIt->rangeSize - i), buffer.data());\n\t\t\telse\n\t\t\t\tcurRead = std::min<uint64_t>(buffer.size(), resourcesIt->rangeSize - i); //Zeroes already in the buffer.\n\t\t\tif (curRead == 0)\n\t\t\t{\n\t\t\t\tassert(false);\n\t\t\t\terrorsOccured = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t//Write the data\n\t\t\tuint64_t curWritten = pWriter->Write(start + curOutPos, curRead, buffer.data());\n\t\t\tcurOutPos += curWritten;\n\t\t\tif (curWritten != curRead)\n\t\t\t{\n\t\t\t\tassert(false);\n\t\t\t\terrorsOccured = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ti += curWritten;\n\t\t}\n\t\tif (pCurReader != nullptr)\n\t\t\tFree_AssetsReader(pCurReader);\n\t}\n\tif (!errorsOccured && resetChangedFlag)\n\t\tthis->changedFlag = false;\n\treturn curOutPos;\n}\nstd::unique_ptr<BundleReplacer> ResourcesFileContextInfo::makeBundleReplacer(class AppContext &appContext, \n\tconst char *oldName, const char *newName, uint32_t bundleIndex, \n\tbool resetChangedFlag)\n{\n\tassert(this->pContext != nullptr);\n\tif (this->pContext == nullptr)\n\t\treturn nullptr;\n\tstd::shared_lock resourcesLock(this->resourcesMutex);\n\tif (resetChangedFlag)\n\t\tthis->changedFlag = false;\n\treturn MakeBundleEntryModifierByResources(oldName, newName,\n\t\tstd::vector<ReplacedResourceDesc>(this->resources.begin(), this->resources.end()), 0, bundleIndex);\n}\nbool ResourcesFileContextInfo::setByReplacer(class AppContext& appContext, BundleReplacer* pReplacer)\n{\n\tif (BundleEntryModifierByResources* pBundleModifier = dynamic_cast<BundleEntryModifierByResources*>(pReplacer))\n\t{\n\t\tstd::shared_lock resourcesLock(this->resourcesMutex);\n\t\tresources.clear();\n\t\tconst auto& resourcesIn = pBundleModifier->getResources();\n\t\tresources.assign(resourcesIn.begin(), resourcesIn.end());\n\t\tthis->changedFlag = hasAnyChanges(appContext);\n\t\treturn true;\n\t}\n\treturn false;\n}\nvoid ResourcesFileContextInfo::addResource(std::shared_ptr<IAssetsReader> pReader, uint64_t readerOffs, uint64_t size, uint64_t &resourcesFilePos)\n{\n\tstd::unique_lock resourcesLock(this->resourcesMutex);\n\tresourcesFilePos = 0;\n\tif (!resources.empty())\n\t\tresourcesFilePos = resources.back().outRangeBegin + resources.back().rangeSize;\n\tresources.emplace_back();\n\tresources.back().outRangeBegin = resourcesFilePos;\n\tresources.back().rangeSize = size;\n\tresources.back().reader = pReader;\n\tresources.back().inRangeBegin = readerOffs;\n\tresources.back().fromOriginalFile = false;\n\tthis->changedFlag = (size > 0);\n}\nstd::shared_ptr<IAssetsReader> ResourcesFileContextInfo::getResource(std::shared_ptr<ResourcesFileContextInfo> selfRef, uint64_t offs, uint64_t size)\n{\n\tif (selfRef.get() != this)\n\t\tthrow std::invalid_argument("ResourcesFileContextInfo::getResource: selfRef does not point to this!");\n\tstd::shared_lock resourcesLock(this->resourcesMutex);\n\t//TODO: Implement a faster lookup by file position, e.g. using a map (probably not necessary for now).\n\t\n\t//Find the first resource in range (returns resources.end() if none are found).\n\tauto itFirstInRange = std::find_if(resources.begin(), resources.end(),\n\t\t[offs](const ReplacedResourceDesc& a) {return a.outRangeBegin + a.rangeSize >= offs; });\n\t//Find the last resource in range.\n\tuint64_t rangeEnd = (size < std::numeric_limits<uint64_t>::max()-offs) ? (offs + size) : std::numeric_limits<uint64_t>::max();\n\tauto itFirstOutOfRange = std::find_if(itFirstInRange, resources.end(),\n\t\t[rangeEnd](const ReplacedResourceDesc& a) {return a.outRangeBegin >= rangeEnd; });\n\n\tif (itFirstInRange == resources.end() || itFirstInRange == itFirstOutOfRange)\n\t\treturn nullptr;\n\tclass ResourcesReader : public IAssetsReader\n\t{\n\t\tstd::vector<ReplacedResourceDesc> resources;\n\t\tstd::shared_ptr<IAssetsReader> origReader;\n\n\t\tstd::unique_ptr<IAssetsReader> origReaderView;\n\t\tstd::vector<std::unique_ptr<IAssetsReader>> readerViews;\n\n\t\tstd::recursive_mutex positionMutex;\n\t\tQWORD pos = 0;\n\t\tsize_t resourceIdx = 0;\n\n\t\tvoid createViews()\n\t\t{\n\t\t\torigReaderView.reset();\n\t\t\treaderViews.clear();\n\t\t\tif (origReader)\n\t\t\t{\n\t\t\t\torigReaderView.reset(origReader->CreateView());\n\t\t\t\tif (origReaderView == nullptr)\n\t\t\t\t\tthrow std::runtime_error("Unable to open a reader view!");\n\t\t\t}\n\t\t\treaderViews.resize(resources.size());\n\t\t\tfor (size_t i = 0; i < resources.size(); ++i)\n\t\t\t{\n\t\t\t\tif (resources[i].reader != nullptr)\n\t\t\t\t{\n\t\t\t\t\treaderViews[i].reset(resources[i].reader->CreateView());\n\t\t\t\t\tif (readerViews[i] == nullptr)\n\t\t\t\t\t\tthrow std::runtime_error("Unable to open a reader view!");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tinline QWORD getSize()\n\t\t{\n\t\t\treturn resources.empty() ? 0 : (resources.back().outRangeBegin + resources.back().rangeSize);\n\t\t}\n\t\tinline IAssetsReader* getReaderViewFor(size_t resourceIdx)\n\t\t{\n\t\t\tIAssetsReader* pReader = nullptr;\n\t\t\tif (resources[resourceIdx].reader)\n\t\t\t{\n\t\t\t\t//Customized resource.\n\t\t\t\tpReader = readerViews[resourceIdx].get();\n\t\t\t\tif (pReader == nullptr)\n\t\t\t\t{\n\t\t\t\t\tassert(false);\n\t\t\t\t\treturn nullptr;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (resources[resourceIdx].fromOriginalFile)\n\t\t\t{\n\t\t\t\t//Resource from the original file.\n\t\t\t\tpReader = origReaderView.get();\n\t\t\t\tif (pReader == nullptr)\n\t\t\t\t{\n\t\t\t\t\tassert(false);\n\t\t\t\t\treturn nullptr;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn pReader;\n\t\t}\n\tpublic:\n\t\tResourcesReader(std::vector<ReplacedResourceDesc> _resources, std::shared_ptr<IAssetsReader> _origReader)\n\t\t\t: resources(std::move(_resources)), origReader(std::move(_origReader))\n\t\t{\n\t\t\tcreateViews();\n\t\t}\n\t\tResourcesReader(const ResourcesReader& other)\n\t\t{\n\t\t\t(*this) = other;\n\t\t}\n\t\tResourcesReader& operator=(const ResourcesReader& other)\n\t\t{\n\t\t\tthis->resources = other.resources;\n\t\t\tthis->origReader = other.origReader;\n\t\t\tthis->createViews();\n\t\t\treturn *this;\n\t\t}\n\n\t\tbool Reopen()\n\t\t{\n\t\t\tstd::lock_guard<decltype(positionMutex)> posLock(positionMutex);\n\t\t\tif (resourceIdx < resources.size())\n\t\t\t{\n\t\t\t\tif (readerViews[resourceIdx] != nullptr)\n\t\t\t\t\treturn readerViews[resourceIdx]->Reopen();\n\t\t\t\telse if (resources[resourceIdx].fromOriginalFile)\n\t\t\t\t\treturn origReaderView->Reopen();\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t\tbool IsOpen()\n\t\t{\n\t\t\tstd::lock_guard<decltype(positionMutex)> posLock(positionMutex);\n\t\t\tif (resourceIdx < resources.size())\n\t\t\t{\n\t\t\t\tif (readerViews[resourceIdx] != nullptr)\n\t\t\t\t\treturn readerViews[resourceIdx]->IsOpen();\n\t\t\t\telse if (resources[resourceIdx].fromOriginalFile)\n\t\t\t\t\treturn origReaderView->IsOpen();\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t\tbool Close() { return false; }\n\n\t\tAssetsRWTypes GetType() { return AssetsRWType_Reader; }\n\t\tAssetsRWClasses GetClass() { return AssetsRWClass_Unknown; }\n\t\tbool IsView() { return true; }\n\n\t\tbool Tell(QWORD& pos)\n\t\t{\n\t\t\tstd::lock_guard<decltype(positionMutex)> posLock(positionMutex);\n\t\t\tpos = this->pos;\n\t\t\treturn true;\n\t\t}\n\t\tbool Seek(AssetsSeekTypes origin, long long offset)\n\t\t{\n\t\t\tstd::lock_guard<decltype(positionMutex)> posLock(positionMutex);\n\t\t\tbool ret = false;\n\t\t\tQWORD newPos = this->pos;\n\t\t\tswitch (origin)\n\t\t\t{\n\t\t\tcase AssetsSeek_Begin:\n\t\t\t\tif (offset < 0) return false;\n\t\t\t\tnewPos = offset;\n\t\t\t\tbreak;\n\t\t\tcase AssetsSeek_Cur:\n\t\t\t\tif (offset < 0)\n\t\t\t\t{\n\t\t\t\t\toffset = -offset;\n\t\t\t\t\tif (offset < 0) return false; //INT64_MIN\n\t\t\t\t\tif ((unsigned long long)offset > newPos) return false;\n\t\t\t\t\tnewPos -= (unsigned long long)offset;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tnewPos += (unsigned long long)offset;\n\t\t\t\tbreak;\n\t\t\tcase AssetsSeek_End:\n\t\t\t\tif (offset > 0) return false;\n\t\t\t\toffset = -offset;\n\t\t\t\tif (offset < 0) return false; //INT64_MIN\n\t\t\t\tif ((unsigned long long)offset > getSize())\n\t\t\t\t\treturn false;\n\t\t\t\tnewPos = resources.empty()\n\t\t\t\t\t? 0\n\t\t\t\t\t: (resources.back().outRangeBegin + resources.back().rangeSize) - (unsigned long long)offset;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\treturn SetPosition(newPos);\n\t\t}\n\t\tbool SetPosition(QWORD pos)\n\t\t{\n\t\t\tstd::lock_guard<decltype(positionMutex)> posLock(positionMutex);\n\t\t\tif (pos > getSize())\n\t\t\t\treturn false;\n\t\t\tif (pos == getSize())\n\t\t\t{\n\t\t\t\tthis->pos = pos;\n\t\t\t\tthis->resourceIdx = resources.size();\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\t//Get the first resource with outRangeBegin + rangeSize > pos.\n\t\t\t//-> Since resources is guaranteed to be sorted by out position and without overlapping regions (and start with 0),\n\t\t\t//   this should always return the resource corresponding to pos, or resources.end() if out of range.\n\t\t\tauto itMatchingResource = std::upper_bound(resources.begin(), resources.end(), pos,\n\t\t\t\t[](QWORD pos, const ReplacedResourceDesc& resource)\n\t\t\t\t{\n\t\t\t\t\treturn pos < (resource.outRangeBegin + resource.rangeSize);\n\t\t\t\t});\n\t\t\tif (itMatchingResource == resources.end())\n\t\t\t\treturn false;\n\t\t\tif (itMatchingResource->outRangeBegin > pos)\n\t\t\t{\n\t\t\t\tassert(false); //Should not happen due to the requirements for resources.\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tthis->pos = pos;\n\t\t\tthis->resourceIdx = std::distance(resources.begin(), itMatchingResource);\n\t\t\tIAssetsReader* pReader = getReaderViewFor(resourceIdx);\n\t\t\tif (pReader != nullptr)\n\t\t\t\treturn pReader->SetPosition(itMatchingResource->inRangeBegin + (pos - itMatchingResource->outRangeBegin));\n\t\t\treturn true;\n\t\t}\n\n\t\tQWORD Read(QWORD pos, QWORD size, void* outBuffer, bool nullUnread = true)\n\t\t{\n\t\t\tstd::lock_guard<decltype(positionMutex)> posLock(positionMutex);\n\t\t\tif (pos == (QWORD)-1)\n\t\t\t\tpos = this->pos;\n\t\t\tQWORD numRead = 0;\n\t\t\tif ((pos != (QWORD)-1) && !SetPosition(pos))\n\t\t\t\tnumRead = 0;\n\t\t\telse\n\t\t\t{\n\t\t\t\tQWORD remaining = size;\n\t\t\t\twhile (remaining > 0)\n\t\t\t\t{\n\t\t\t\t\tif (resourceIdx >= resources.size())\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tReplacedResourceDesc& curResource = resources[resourceIdx];\n\t\t\t\t\tif (pos >= curResource.outRangeBegin + curResource.rangeSize)\n\t\t\t\t\t{\n\t\t\t\t\t\tresourceIdx++;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tassert(pos >= curResource.outRangeBegin);\n\t\t\t\t\tQWORD bytesToRead = std::min(remaining, curResource.rangeSize - (pos - curResource.outRangeBegin));\n\t\t\t\t\tbytesToRead = std::min<QWORD>(bytesToRead, std::numeric_limits<size_t>::max());\n\t\t\t\t\tQWORD curBytesRead = 0;\n\t\t\t\t\tIAssetsReader* pReader = getReaderViewFor(resourceIdx);\n\t\t\t\t\tif (pReader != nullptr)\n\t\t\t\t\t{\n\t\t\t\t\t\tcurBytesRead = pReader->Read(\n\t\t\t\t\t\t\tpos - curResource.outRangeBegin + curResource.inRangeBegin,\n\t\t\t\t\t\t\tbytesToRead,\n\t\t\t\t\t\t\t&((uint8_t*)outBuffer)[numRead],\n\t\t\t\t\t\t\tfalse);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t//Pseudo-resource filled with zeroes.\n\t\t\t\t\t\tmemset(&((uint8_t*)outBuffer)[numRead], 0, (size_t)bytesToRead);\n\t\t\t\t\t\tcurBytesRead = bytesToRead;\n\t\t\t\t\t}\n\t\t\t\t\tif (curBytesRead == 0)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tnumRead += curBytesRead;\n\t\t\t\t\tremaining -= curBytesRead;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (nullUnread && (numRead < size))\n\t\t\t\tmemset(&((uint8_t*)outBuffer)[numRead], 0, size - numRead);\n\t\t\tthis->pos = pos + numRead;\n\t\t\treturn numRead;\n\t\t}\n\t\tIAssetsReader *CreateView()\n\t\t{\n\t\t\treturn new ResourcesReader(*this);\n\t\t}\n\t};\n\tstd::vector<ReplacedResourceDesc> resourcesInRange(itFirstInRange, itFirstOutOfRange);\n\tif (resourcesInRange.size() > 0)\n\t{\n\t\t//Correct the offsets and resource size of the first entry to match the chosen range start.\n\t\tresourcesInRange.front().inRangeBegin += (offs - resourcesInRange.front().outRangeBegin);\n\t\tresourcesInRange.front().rangeSize -= (offs - resourcesInRange.front().outRangeBegin);\n\t\tresourcesInRange.front().outRangeBegin = offs;\n\t}\n\tif (resourcesInRange.size() > 0)\n\t{\n\t\t//Correct the resource size of the last entry to match the chosen range end position.\n\t\tif ((resourcesInRange.back().outRangeBegin - offs) + resourcesInRange.back().rangeSize > size)\n\t\t\tresourcesInRange.back().rangeSize = size - (resourcesInRange.back().outRangeBegin - offs);\n\t}\n\t//Subtract the start offset from each entry to match the reader positions.\n\tfor (ReplacedResourceDesc& resourceInRange : resourcesInRange)\n\t\tresourceInRange.outRangeBegin -= offs;\n\treturn std::make_shared<ResourcesReader>(std::move(resourcesInRange),\n\t\tstd::shared_ptr<IAssetsReader>(selfRef, this->pContext->getReaderUnsafe()));\n}\n#pragma endregion ResourcesFileContextInfo\n\n\n\n#pragma region GenericFileContextInfo\nGenericFileContextInfo::GenericFileContextInfo(GenericFileContext *pContext, unsigned int fileID, unsigned int parentFileID)\n\t: FileContextInfo(fileID, parentFileID), pContext(pContext), changedFlag(false)\n{\n}\nGenericFileContextInfo::~GenericFileContextInfo()\n{\n\tIAssetsReader *pReader = this->pContext->getReaderUnsafe();\n\tthis->pContext->Close();\n\tdelete this->pContext;\n\tthis->pContext = nullptr;\n}\nIFileContext *GenericFileContextInfo::getFileContext()\n{\n\treturn this->pContext;\n}\nvoid GenericFileContextInfo::getChildFileIDs(std::vector<unsigned int> &childFileIDs)\n{\n\tchildFileIDs.clear();\n}\nvoid GenericFileContextInfo::onCloseChild(unsigned int childFileID)\n{\n}\nbool GenericFileContextInfo::hasAnyChanges(class AppContext &appContext)\n{\n\tif (this->getGenericFileContext() != nullptr && this->getGenericFileContext()->getReaderIsModified())\n\t\treturn true;\n\tstd::scoped_lock replacementReaderLock(this->replacementReaderMutex);\n\tbool ret = (!this->replacementReaderHistory.empty());\n\treturn ret;\n}\nbool GenericFileContextInfo::hasNewChanges(class AppContext &appContext)\n{\n\treturn changedFlag;\n}\nuint64_t GenericFileContextInfo::write(class AppContext &appContext, IAssetsWriter *pWriter, uint64_t start, bool resetChangedFlag)\n{\n\tassert(this->pContext != nullptr);\n\tif (this->pContext == nullptr)\n\t\treturn 0;\n\tstd::unique_lock replacementReaderLock(this->replacementReaderMutex);\n\tIAssetsReader *pReader;\n\tif (!this->replacementReaderHistory.empty())\n\t\tpReader = this->replacementReaderHistory.back()->CreateView();\n\telse\n\t\tpReader = this->pContext->getReaderUnsafe()->CreateView();\n\treplacementReaderLock.unlock();\n\tuint64_t fileSize = 0;\n\tif (!pReader->Seek(AssetsSeek_End, 0) || !pReader->Tell(fileSize) || !pReader->Seek(AssetsSeek_Begin, 0))\n\t{\n\t\tFree_AssetsReader(pReader);\n\t\treturn 0;\n\t}\n\tstd::vector<uint8_t> buffer(1024 * 1024); //1MiB\n\tfor (uint64_t i = 0; i < fileSize; )\n\t{\n\t\tuint64_t curRead = pReader->Read(std::min<uint64_t>(buffer.size(), fileSize - i), buffer.data());\n\t\tif (curRead == 0)\n\t\t{\n\t\t\tassert(false);\n\t\t\tfileSize = i;\n\t\t\tbreak;\n\t\t}\n\t\tuint64_t curWritten = pWriter->Write(start + i, curRead, buffer.data());\n\t\tif (curWritten < curRead)\n\t\t{\n\t\t\tassert(false);\n\t\t\tfileSize = curWritten;\n\t\t\tbreak;\n\t\t}\n\t}\n\tFree_AssetsReader(pReader);\n\tif (resetChangedFlag)\n\t\tchangedFlag = false;\n\treturn fileSize;\n}\nstd::unique_ptr<BundleReplacer> GenericFileContextInfo::makeBundleReplacer(class AppContext &appContext, \n\tconst char *oldName, const char *newName, uint32_t bundleIndex, \n\tbool resetChangedFlag)\n{\n\tassert(this->pContext != nullptr);\n\tif (this->pContext == nullptr)\n\t\treturn nullptr;\n\n\tstd::unique_lock replacementReaderLock(this->replacementReaderMutex);\n\tIAssetsReader *pReader = nullptr;\n\tif (!this->replacementReaderHistory.empty())\n\t\tpReader = this->replacementReaderHistory.back()->CreateView();\n\telse\n\t\tpReader = this->pContext->getReaderUnsafe()->CreateView();\n\treplacementReaderLock.unlock();\n\n\tif (pReader == nullptr)\n\t\treturn nullptr;\n\tassert(pReader->Seek(AssetsSeek_End, 0));\n\tQWORD totalSize = 0;\n\tassert(pReader->Tell(totalSize));\n\tassert(pReader->Seek(AssetsSeek_Begin, 0));\n\tif (resetChangedFlag)\n\t\tchangedFlag = false;\n\treturn std::unique_ptr<BundleReplacer>(MakeBundleEntryModifier(oldName, newName, false, pReader, Free_AssetsReader, totalSize, 0, 0, bundleIndex));\n}\n#pragma endregion GenericFileContextInfo\n'