b'{-# OPTIONS_GHC -fno-warn-orphans #-}\n\nmodule AWK where\n\nimport Prelude hiding (LT, GT, EQ)\nimport Test.Tasty (TestTree, testGroup)\nimport Test.Tasty.Golden (goldenVsString)\nimport Test.Tasty.QuickCheck\n  (Property, testProperty, (===), Arbitrary(..), genericShrink, frequency, getNonNegative)\n\nimport System.FilePath\nimport qualified Data.ByteString.Lazy.Char8 as LBS8\nimport qualified Data.Sequence as Seq\n\nimport Test.Tasty.Patterns.Parser\nimport Test.Tasty.Patterns.Printer\nimport Test.Tasty.Patterns.Eval\nimport Test.Tasty.Patterns.Types\n\nawkTests :: IO TestTree\nawkTests = do\n  examples <- lines <$> readFile "awk/examples.awk"\n  return $ testGroup "AWK"\n    [ parserTests examples\n    , printerTests examples\n    , evalTests examples\n    , testProperty "parseprinted" parsePrintedTest\n    ]\n\nparserTests :: [String] -> TestTree\nparserTests examples = testGroup "Parsing" $ do\n  (example, n) <- zip examples [1..]\n  return $ goldenVsString\n    (show n) -- test name\n    ("awk" </> show n <.> "golden.ast") $\n      return . LBS8.pack . (++"\\n") . show $ runParser expr example\n\nprinterTests :: [String] -> TestTree\nprinterTests examples = testGroup "Printing" $ do\n  (example, n) <- zip examples [1..]\n  return $ goldenVsString\n    (show n) -- test name\n    ("awk" </> show n <.> "golden.ast") $\n      return . LBS8.pack . (++"\\n") . show $\n        case runParser expr example of\n          Success e -> runParser expr (printAwkExpr e)\n          result -> result\n\nparsePrintedTest :: Expr -> Property\nparsePrintedTest e = runParser expr (printAwkExpr e) === Success e\n\nevalTests :: [String] -> TestTree\nevalTests examples = testGroup "Evaluation" $ do\n  (example, n) <- zip examples [1..]\n  return $ goldenVsString\n    (show n) -- test name\n    ("awk" </> show n <.> "golden.value") $\n      return . LBS8.pack . (++"\\n") . show $ do\n        e <- case runParser expr example of\n          Success e -> Right e\n          Invalid -> Left "Invalid"\n          Ambiguous _ -> Left "Ambiguous"\n        withFields (Seq.fromList ["one","two","three"]) $ eval e\n\ninstance Arbitrary Expr where\n  arbitrary = frequency\n    [ (10, IntLit . getNonNegative <$> arbitrary)\n    , (5, pure NF)\n    , (1, Add <$> arbitrary <*> arbitrary)\n    , (1, Sub <$> arbitrary <*> arbitrary)\n    , (2, Neg <$> arbitrary)\n    , (2, Not <$> arbitrary)\n    , (1, And <$> arbitrary <*> arbitrary)\n    , (1, LT <$> arbitrary <*> arbitrary)\n    , (1, GT <$> arbitrary <*> arbitrary)\n    , (1, LE <$> arbitrary <*> arbitrary)\n    , (1, GE <$> arbitrary <*> arbitrary)\n    , (1, EQ <$> arbitrary <*> arbitrary)\n    , (1, NE <$> arbitrary <*> arbitrary)\n    , (1, Or <$> arbitrary <*> arbitrary)\n    , (1, Concat <$> arbitrary <*> arbitrary)\n    , (1, Match <$> arbitrary <*> arbitrary)\n    , (1, NoMatch <$> arbitrary <*> arbitrary)\n    , (2, Field <$> arbitrary)\n    , (10, StringLit <$> arbitrary)\n    , (1, If <$> arbitrary <*> arbitrary <*> arbitrary)\n    , (10, ERE <$> arbitrary)\n    , (2, ToUpperFn <$> arbitrary)\n    , (2, ToLowerFn <$> arbitrary)\n    , (2, LengthFn <$> arbitrary)\n    , (1, MatchFn <$> arbitrary <*> arbitrary)\n    , (1, SubstrFn <$> arbitrary <*> arbitrary <*> arbitrary)\n    ]\n  shrink NF = []\n  shrink e = NF : genericShrink e\n'