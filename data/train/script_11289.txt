b"{-# LANGUAGE Arrows #-}\n-- |\n-- Copyright  : (c) Ivan Perez, 2017\n-- License    : BSD3\n-- Maintainer : ivan.perez@keera.co.uk\n--\n-- Past-time LTL using MSFs.\n--\n-- This module provides ways of defining past-, discrete-time temporal\n-- predicates with MSFs.\n--\n-- There are two ways of doing so: piping the results of Boolean-carrying MSFs\n-- into other MSFs (Past-time LTL using MSFs), or wrapping MSFs into other MSFs\n-- (Past-time LTL as MSF combinators).\nmodule FRP.Dunai.LTLPast where\n\n-- External imports\nimport Control.Monad.Trans.MSF.Maybe (MaybeT, catchMaybe, inMaybeT)\nimport Data.MonadicStreamFunction    (MSF, arr, feedback, iPre, liftTransS,\n                                      returnA, (&&&), (>>>), (^>>))\n\n-- * Past-time linear temporal logic using MSFs.\n\n-- ** Propositional MSFs\n\n-- | Output True when both inputs are True.\nandSF :: Monad m => MSF m (Bool, Bool) Bool\nandSF = arr (uncurry (&&))\n\n-- | Output True when at least one input is True.\norSF :: Monad m => MSF m (Bool, Bool) Bool\norSF = arr (uncurry (||))\n\n-- | Output True when the input is False.\nnotSF :: Monad m => MSF m Bool Bool\nnotSF = arr not\n\n-- | Output True when the second input is True or the first one is False.\nimpliesSF :: Monad m => MSF m (Bool, Bool) Bool\nimpliesSF = arr $ \\(i, p) -> not i || p\n\n-- ** Temporal MSFs\n\n-- | Output True when every input up until the current time has been True.\n--\n-- This corresponds to Historically, or the past-time version of Globally or\n-- Always.\nsofarSF :: Monad m => MSF m Bool Bool\nsofarSF = feedback True $ arr $ \\(n, o) -> let n' = o && n in (n', n')\n\n-- | Output True when at least one input up until the current time has been\n-- True.\n--\n-- This corresponds to Ever, or the past-time version of Eventually.\neverSF :: Monad m => MSF m Bool Bool\neverSF = feedback False $ arr $ \\(n, o) -> let n' = o || n in (n', n')\n\n-- | Output True if the first element has always been True, or the second has\n-- been True ever since the first one became False.\nuntilSF :: (Functor m, Monad m) => MSF m (Bool, Bool) Bool\nuntilSF =\n    catchMaybe (untilMaybeB (feedback True $ arr cond))\n               (snd ^>> sofarSF)\n\n  where\n\n    untilMaybeB :: Monad m => MSF m a (b, Bool) -> MSF (MaybeT m) a b\n    untilMaybeB msf = proc a -> do\n      (b, c) <- liftTransS msf -< a\n      inMaybeT -< if c then Nothing else Just b\n\n    cond ((i, u), o) = ((n, o && u), n)\n      where\n        n = o && i\n\n-- | Output True if the input was True at the last time.\n--\n-- False at time zero.\nlastSF :: Monad m => MSF m Bool Bool\nlastSF = iPre False\n\n-- * Past-time linear temporal logic as MSF combinators.\n\n-- | A signal predicate is an MSF whose output is a Boolean value.\ntype SPred m a = MSF m a Bool\n\n-- ** Propositional MSFs\n\n-- | Output True at times when the input is False.\nnotSF' :: Monad m => SPred m a -> SPred m a\nnotSF' sf = sf >>> arr not\n\n-- | Output True at times when both inputs are True.\nandSF' :: Monad m => SPred m a -> SPred m a -> SPred m a\nandSF' sf1 sf2 = (sf1 &&& sf2) >>> arr (uncurry (&&))\n\n-- | Output True at times when at least one of the inputs is True.\norSF' :: Monad m => SPred m a -> SPred m a -> SPred m a\norSF' sf1 sf2 = (sf1 &&& sf2) >>> arr (uncurry (||))\n\n-- | Output True at times when the first input stream is False or the second\n-- one is True.\nimplySF' :: Monad m => SPred m a -> SPred m a -> SPred m a\nimplySF' sf1 sf2 = orSF' sf2 (notSF' sf1)\n\n-- ** Temporal MSFs\n\n-- | Output True at a time if the input has always been True up until that\n-- time.\n--\n-- This corresponds to Historically, or the past-time version of Globally or\n-- Always.\nhistory' :: Monad m => SPred m a -> SPred m a\nhistory' sf = feedback True $ proc (a, last) -> do\n  b <- sf -< a\n  let cur = last && b\n  returnA -< (cur, cur)\n\n-- | Output True at a time if the input has ever been True up until that time.\n--\n-- This corresponds to Ever, or the past-time version of Eventually.\never' :: Monad m => SPred m a -> SPred m a\never' sf = feedback False $ proc (a, last) -> do\n  b <- sf -< a\n  let cur = last || b\n  returnA -< (cur, cur)\n\n-- | Output True at a time if the input at the last time was True.\nprev' :: Monad m => SPred m a -> SPred m a\nprev' sf = feedback True $ proc (a, last) -> do\n  b <- sf -< a\n  returnA -< (last, b)\n"