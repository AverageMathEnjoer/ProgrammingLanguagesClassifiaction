b'\n-- | Parse content stream\n\nmodule Pdf.Content.Parser\n(\n  readNextOperator,\n  parseContent,\n)\nwhere\n\nimport Pdf.Core.Exception\nimport Pdf.Core.Parsers.Object\n\nimport Pdf.Content.Ops\n\nimport Data.Attoparsec.ByteString.Char8 (Parser)\nimport qualified Data.Attoparsec.ByteString.Char8 as Parser\nimport Control.Applicative\nimport Control.Monad\nimport Control.Exception hiding (throw)\nimport System.IO.Streams (InputStream)\nimport qualified System.IO.Streams as Streams\nimport qualified System.IO.Streams.Attoparsec as Streams\n\n-- | Read the next operator if any\nreadNextOperator :: InputStream Expr -> IO (Maybe Operator)\nreadNextOperator is = message "readNextOperator" $ go []\n  where\n  go args = do\n    expr <- Streams.read is\n      -- XXX: it should be handled by stream creator\n      `catch` \\(Streams.ParseException msg) -> throwIO (Corrupted msg [])\n    case expr of\n      Nothing -> case args of\n                   [] -> return Nothing\n                   _ -> throwIO $ Corrupted ("Args without op: " ++ show args) []\n      Just (Obj o) -> go (o : args)\n      Just (Op o) -> return $ Just (o, reverse args)\n\n-- | Parser expression in a content stream\nparseContent :: Parser (Maybe Expr)\nparseContent = do\n  skipSpace\n  (Parser.endOfInput >> return Nothing) <|>\n    fmap Just (fmap Obj parseObject <|>\n               fmap (Op . toOp) (Parser.takeWhile1 isRegularChar))\n\n-- Treat comments as spaces\nskipSpace :: Parser ()\nskipSpace = do\n  Parser.skipSpace\n  void $ many $ do\n    _ <- Parser.char \'%\'\n    Parser.skipWhile $ \\c -> c /= \'\\n\' && c /= \'\\r\'\n    Parser.skipSpace\n'