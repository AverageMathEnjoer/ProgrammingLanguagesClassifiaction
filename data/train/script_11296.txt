b'{-# LANGUAGE PolyKinds #-}\nmodule Database.Beam.Postgres.Debug where\n\nimport           Database.Beam.Query\nimport           Database.Beam.Postgres.Types (Postgres(..))\nimport           Database.Beam.Postgres.Connection\n  ( Pg\n  , liftIOWithHandle\n  , pgRenderSyntax )\nimport           Database.Beam.Postgres.Full\n  ( PgInsertReturning(..)\n  , PgUpdateReturning(..)\n  , PgDeleteReturning(..) )\nimport Database.Beam.Postgres.Syntax\n  ( PgSyntax\n  , PgSelectSyntax(..)\n  , PgInsertSyntax(..)\n  , PgUpdateSyntax(..)\n  , PgDeleteSyntax(..) )\n\nimport qualified Data.ByteString.Char8 as BC\n\nimport qualified Database.PostgreSQL.Simple as Pg\n\n-- | Type class for @Sql*@ types that can be turned into Postgres\n-- syntax, for use in the following debugging functions\n--\n-- These include\n--\n--    * \'SqlSelect\'\n--    * \'SqlInsert\'\n--    * \'SqlUpdate\'\n--    * \'SqlDelete\'\n--    * \'PgInsertReturning\'\n--    * \'PgUpdateReturning\'\n--    * \'PgDeleteReturning\'\nclass PgDebugStmt statement where\n  pgStmtSyntax :: statement -> Maybe PgSyntax\n\ninstance PgDebugStmt (SqlSelect Postgres a) where\n  pgStmtSyntax (SqlSelect (PgSelectSyntax e)) = Just e\ninstance PgDebugStmt (SqlInsert Postgres a) where\n  pgStmtSyntax SqlInsertNoRows = Nothing\n  pgStmtSyntax (SqlInsert _ (PgInsertSyntax e)) = Just e\ninstance PgDebugStmt (SqlUpdate Postgres a) where\n  pgStmtSyntax SqlIdentityUpdate = Nothing\n  pgStmtSyntax (SqlUpdate _ (PgUpdateSyntax e)) = Just e\ninstance PgDebugStmt (SqlDelete Postgres a) where\n  pgStmtSyntax (SqlDelete _ (PgDeleteSyntax e)) = Just e\ninstance PgDebugStmt (PgInsertReturning a) where\n  pgStmtSyntax PgInsertReturningEmpty = Nothing\n  pgStmtSyntax (PgInsertReturning e) = Just e\ninstance PgDebugStmt (PgUpdateReturning a) where\n  pgStmtSyntax PgUpdateReturningEmpty = Nothing\n  pgStmtSyntax (PgUpdateReturning e) = Just e\ninstance PgDebugStmt (PgDeleteReturning a) where\n  pgStmtSyntax (PgDeleteReturning e) = Just e\n\npgTraceStmtIO :: PgDebugStmt statement => Pg.Connection -> statement -> IO ()\npgTraceStmtIO conn s =\n  BC.putStrLn =<< pgTraceStmtIO\' conn s\n\npgTraceStmtIO\' :: PgDebugStmt statement => Pg.Connection -> statement -> IO BC.ByteString\npgTraceStmtIO\' conn stmt =\n  let syntax = pgStmtSyntax stmt\n  in maybe (return (BC.pack "(no statement)")) (pgRenderSyntax conn) syntax\n\npgTraceStmt :: PgDebugStmt statement => statement -> Pg ()\npgTraceStmt stmt =\n  liftIOWithHandle (flip pgTraceStmtIO stmt)\n\n'