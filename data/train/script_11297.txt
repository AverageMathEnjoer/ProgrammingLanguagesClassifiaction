b'#\' fastLink\n#\'\n#\' Run the fastLink algorithm to probabilistically match\n#\' two datasets.\n#\'\n#\' @usage fastLink(dfA, dfB, varnames, stringdist.match,\n#\' stringdist.method, numeric.match, partial.match,\n#\' cut.a, cut.p, jw.weight,\n#\' cut.a.num, cut.p.num,\n#\' priors.obj, w.lambda, w.pi,\n#\' address.field, gender.field, estimate.only, em.obj,\n#\' dedupe.matches, linprog.dedupe,\n#\' reweight.names, firstname.field, cond.indep,\n#\' n.cores, tol.em, threshold.match, return.all, return.df, verbose)\n#\'\n#\' @param dfA Dataset A - to be matched to Dataset B\n#\' @param dfB Dataset B - to be matched to Dataset A\n#\' @param varnames A vector of variable names to use for matching.\n#\' Must be present in both dfA and dfB\n#\' @param stringdist.match A vector of variable names indicating\n#\' which variables should use string distance matching. Must be a subset of\n#\' \'varnames\' and must not be present in \'numeric.match\'.\n#\' @param stringdist.method String distance method for calculating similarity, options are: "jw" Jaro-Winkler (Default), "jaro" Jaro, and "lv" Edit\n#\' @param numeric.match A vector of variable names indicating which variables should use numeric matching.\n#\' Must be a subset of \'varnames\' and must not be present in \'stringdist.match\'.\n#\' @param partial.match A vector of variable names indicating whether to include\n#\' a partial matching category for the string distances. Must be a subset of \'varnames\'\n#\' and \'stringdist.match\'.\n#\' @param cut.a Lower bound for full string-distance match, ranging between 0 and 1. Default is 0.94\n#\' @param cut.p Lower bound for partial string-distance match, ranging between 0 and 1. Default is 0.88\n#\' @param jw.weight Parameter that describes the importance of the first characters of a string (only needed if stringdist.method = "jw"). Default is .10\n#\' @param cut.a.num Lower bound for full numeric match. Default is 1\n#\' @param cut.p.num Lower bound for partial numeric match. Default is 2.5\n#\' @param priors.obj A list containing priors for auxiliary movers information,\n#\' as output from calcMoversPriors(). Default is NULL\n#\' @param w.lambda How much weight to give the prior on lambda versus the data. Must range between 0 (no weight on prior) and 1 (weight fully on prior).\n#\' Default is NULL (no prior information provided).\n#\' @param w.pi How much weight to give the prior on pi versus the data. Must range between 0 (no weight on prior) and 1 (weight fully on prior).\n#\' Default is NULL (no prior information provided).\n#\' @param address.field The name of the address field. To be used when \'pi.prior\' is included in \'priors.obj\'.\n#\' Default is NULL (no matching variables should have address prior applied). Must be present in \'varnames\'.\n#\' @param gender.field The name of the field indicating gender. If provided, the exact-matching gender prior is used in the EM algorithm.\n#\' Default is NULL (do not implement exact matching on gender). Must be present in \'varnames\'.\n#\' @param estimate.only Whether to stop running the algorithm after the EM step (omitting getting the matched indices of dataset A and dataset B).\n#\' Only the EM object will be returned. Can be used when running the match on a random sample and applying to a larger dataset, or for out-of-sample\n#\' prediction of matches. Default is FALSE.\n#\' @param em.obj An EM object from a prior run of \'fastLink\' or \'emlinkMARmov\'. Parameter estimates will be applied to the matching patterns\n#\' in \'dfA\' and \'dfB\'. If provided. \'estimate.only\' is set to FALSE. Often provided when parameters have been\n#\' estimated on a smaller sample, and the user wants to apply them to the full dataset. Default is NULL (EM will be estimated from matching patterns in \'dfA\' and \'dfB\').\n#\' @param dedupe.matches Whether to dedupe the set of matches returned by the algorithm. Default is TRUE.\n#\' @param linprog.dedupe If deduping matches, whether to use Winkler\'s linear programming solution to dedupe. Default is FALSE.\n#\' @param reweight.names Whether to reweight the posterior match probabilities by the frequency of individual first names. Default is FALSE.\n#\' @param firstname.field The name of the field indicating first name. Must be provided if reweight.names = TRUE.\n#\' @param cond.indep Estimates for the parameters of interest are obtained from the Fellegi-Sunter model under conditional independence. Default is TRUE. \n#\' If set to FALSE parameters estimates are obtained from a model that allows for dependencies across linkage fields.\n#\' @param n.cores Number of cores to parallelize over. Default is NULL.\n#\' @param tol.em Convergence tolerance for the EM Algorithm. Default is 1e-04.\n#\' @param threshold.match A number between 0 and 1 indicating either the lower bound (if only one number provided) or the range of certainty that the\n#\' user wants to declare a match. For instance, threshold.match = .85 will return all pairs with posterior probability greater than .85 as matches,\n#\' while threshold.match = c(.85, .95) will return all pairs with posterior probability between .85 and .95 as matches.\n#\' @param return.all Whether to return the most likely match for each observation in dfA and dfB. Overrides user setting of \\code{threshold.match} by setting\n#\' \\code{threshold.match} to 0.0001, and automatically dedupes all matches. Default is FALSE.\n#\' @param return.df Whether to return the entire dataframe of dfA and dfB instead of just the indices. Default is FALSE.\n#\' @param verbose Whether to print elapsed time for each step. Default is FALSE.\n#\'\n#\' @return \\code{fastLink} returns a list of class \'fastLink\' containing the following components if calculating matches:\n#\' \\item{matches}{An nmatches X 2 matrix containing the indices of the successful matches in \\code{dfA}\n#\' in the first column, and the indices of the corresponding successful matches in \\code{dfB} in the\n#\' second column.}\n#\' \\item{EM}{A list with the output of the EM algorithm, which contains the exact matching\n#\' patterns and the associated posterior probabilities of a match for each matching pattern.}\n#\' \\item{patterns}{A matrix with the observed matching patterns for each successfully matched pair.}\n#\' \\item{nobs.a}{The number of observations in dataset A.}\n#\' \\item{nobs.b}{The number of observations in dataset B.}\n#\' \\item{zeta.name}{If reweighting by name, the posterior probability of a match for each match in dataset A and B.}\n#\' \n#\' If only running the EM and not returning the matched indices, \\code{fastLink} only returns the EM object.\n#\'\n#\' @author Ted Enamorado <ted.enamorado@gmail.com>, Ben Fifield <benfifield@gmail.com>, and Kosuke Imai\n#\'\n#\' @examples\n#\' \\dontrun{\n#\' fl.out <- fastLink(dfA, dfB,\n#\' varnames = c("firstname", "lastname", "streetname", "birthyear"),\n#\' n.cores = 1)\n#\' }\n#\' @export\nfastLink <- function(dfA, dfB, varnames,\n                     stringdist.match = NULL, \n                     stringdist.method = "jw",\n                     numeric.match = NULL, \n                     partial.match = NULL,\n                     cut.a = 0.94, cut.p = 0.88,\n                     jw.weight = .10,\n                     cut.a.num = 1, cut.p.num = 2.5,\n                     priors.obj = NULL,\n                     w.lambda = NULL, w.pi = NULL, address.field = NULL,\n                     gender.field = NULL, estimate.only = FALSE, em.obj = NULL,\n                     dedupe.matches = TRUE, linprog.dedupe = FALSE,\n                     reweight.names = FALSE, firstname.field = NULL, cond.indep = TRUE,\n                     n.cores = NULL, tol.em = 1e-04, threshold.match = 0.85,\n                     return.all = FALSE, return.df = FALSE, verbose = FALSE){\n\n    cat("\\n")\n    cat(c(paste(rep("=", 20), sep = "", collapse = ""), "\\n"))\n    cat("fastLink(): Fast Probabilistic Record Linkage\\n")\n    cat(c(paste(rep("=", 20), sep = "", collapse = ""), "\\n\\n"))\n\n    ## --------------------------------------\n    ## Process inputs and stop if not correct\n    ## --------------------------------------\n    if(any(class(dfA) %in% c("tbl_df", "data.table"))){\n        dfA <- as.data.frame(dfA)\n    }\n    if(any(class(dfB) %in% c("tbl_df", "data.table"))){\n        dfB <- as.data.frame(dfB)\n    }\n    if(any(!(varnames %in% names(dfA)))){\n        stop("Some variables in varnames are not present in dfA.")\n    }\n    if(any(!(varnames %in% names(dfB)))){\n        stop("Some variables in varnames are not present in dfB.")\n    }\n    if(any(!(stringdist.match %in% varnames))){\n        stop("You have provided a variable name for stringdist.match that is not in \'varnames\'.")\n    }\n    if(any(!(numeric.match %in% varnames))){\n        stop("You have provided a variable name for numeric.match that is not in \'varnames\'.")\n    }\n    if(length(intersect(numeric.match, stringdist.match)) > 0){\n        stop("There is a variable present in both \'numeric.match\' and \'stringdist.match\'. Please select only one matching metric for each variable.")\n    }\n    if(is.null(numeric.match)) {\n      if (any(!(partial.match %in% varnames)) | any(!(partial.match %in% \n                                                      stringdist.match))) {\n        stop("You have provided a variable name for \'partial.match\' that is not present in either \'varnames\', \'numeric.match\', or \'stringdist.match\'.")\n      }\n    } else {\n      if (any(!(partial.match %in% varnames)) | any(!(partial.match %in% unique(c(stringdist.match, numeric.match))))) {\n        stop("You have provided a variable name for \'partial.match\' that is not present in either \'varnames\', \'numeric.match\', or \'stringdist.match\'.")\n      }\n    }    \n    if(!is.null(address.field)){\n        if(length(address.field) > 1 | length(gender.field) > 1){\n            stop("\'address.field\' must have at most only one variable name.")\n        }\n        if(!(address.field %in% varnames)){\n            stop("You have provided a variable name for \'address.field\' that is not in \'varnames\'.")\n        }\n    }\n    if(!is.null(gender.field)){\n        if(length(gender.field) > 1){\n            stop("\'gender.field\' must have at most one variable name.")\n        }\n        if(!(gender.field %in% varnames)){\n            stop("You have provided a variable name for \'gender.field\' that is not in \'varnames\'.")\n        }\n    }\n    if(reweight.names == TRUE & is.null(firstname.field)){\n        stop("If reweighting the match probability by first name, you must provide the name of the field representing first name.")\n    }\n    if(!is.null(firstname.field)){\n        if(length(firstname.field) > 1){\n            stop("\'firstname.field\' must have at most one variable name.")\n        }\n        if(!(firstname.field %in% varnames)){\n            stop("You have provided a variable name for \'firstname.field\' that is not in \'varnames\'.")\n        }\n    }\n    if(!is.null(em.obj)){\n        if(!("fastLink.EM" %in% class(em.obj))){\n            stop("If providing an EM object, it must be of class \'fastLink.EM\'.")\n        }\n    }\n    if(!is.null(em.obj) & estimate.only){\n        estimate.only <- FALSE\n        cat("You have provided an EM object but have set \'estimate.only\' to TRUE. Setting \'estimate.only\' to FALSE so that matched indices are returned.\\n")\n    }\n    if(!(stringdist.method %in% c("jw", "jaro", "lv"))){\n        stop("Invalid string distance method. Method should be one of \'jw\', \'jaro\', or \'lv\'.")\n    }\n    if(stringdist.method == "jw" & !is.null(jw.weight)){\n        if(jw.weight < 0 | jw.weight > 0.25){\n            stop("Invalid value provided for jw.weight. Remember, jw.weight in [0, 0.25].")\n        }\n    }\n    if(return.all){\n        threshold.match <- 0.001\n        if(!dedupe.matches){\n            cat("You have specified that all matches be returned but are not deduping the matches. The resulting object may be very large.\\n")\n        }\n    }else{\n        cat("If you set return.all to FALSE, you will not be able to calculate a confusion table as a summary statistic.\\n")\n    }\n    if(!is.null(priors.obj) & cond.indep == FALSE){\n        cat("The current implementation of fastLink can only incorporate prior information under the conditionally independent model. Ignoring prior information in estimation.")\n        priors.obj <- NULL\n        w.lambda <- NULL\n        w.pi <- NULL\n        address.field <- NULL\n        gender.field <- NULL\n    }\n\n    ## Check class of numeric indicators\n    classA <- lapply(dfA[,varnames], class)\n    classB <- lapply(dfB[,varnames], class)\n    if(any(unlist(classA)[names(classA) %in% numeric.match] != "numeric") |\n       any(unlist(classB)[names(classB) %in% numeric.match] != "numeric")){\n        stop("You have specified that a variable be compared using numeric matching, but that variable is not of class \'numeric\'. Please check your variable classes.")\n    }\n\n    ## Check if data frames are identical\n    dedupe.df <- FALSE\n    if(identical(dfA, dfB)){\n        cat("dfA and dfB are identical, assuming deduplication of a single data set.\\nSetting return.all to FALSE.\\n\\n")\n        dedupe.matches <- FALSE\n        return.all <- FALSE\n        dedupe.df <- TRUE\n    }\n\n    ## Create boolean indicators\n    sm.bool <- which(varnames %in% stringdist.match)\n    stringdist.match <- rep(FALSE, length(varnames))\n    if(length(sm.bool) > 0){\n        stringdist.match[sm.bool] <- TRUE\n    }\n\n    nm.bool <- which(varnames %in% numeric.match)\n    numeric.match <- rep(FALSE, length(varnames))\n    if(length(nm.bool) > 0){\n        numeric.match[nm.bool] <- TRUE\n    }\n\n    pm.bool <- which(varnames %in% partial.match)\n    partial.match <- rep(FALSE, length(varnames))\n    if(length(pm.bool) > 0){\n        partial.match[pm.bool] <- TRUE\n    }\n\n    af.bool <- which(varnames %in% address.field)\n    address.field <- rep(FALSE, length(varnames))\n    if(length(af.bool) > 0){\n        address.field[af.bool] <- TRUE\n    }\n\n    gf.bool <- which(varnames %in% gender.field)\n    gender.field <- rep(FALSE, length(varnames))\n    if(length(gf.bool) > 0){\n        gender.field[gf.bool] <- TRUE\n    }\n\n    fn.bool <- which(varnames %in% firstname.field)\n    firstname.field <- rep(FALSE, length(varnames))\n    if(length(fn.bool) > 0){\n        firstname.field[fn.bool] <- TRUE\n    }\n\n    ## ----------------------------\n    ## Calculate agreement patterns\n    ## ----------------------------\n    cat("Calculating matches for each variable.\\n")\n    start <- Sys.time()\n    gammalist <- vector(mode = "list", length = length(varnames))\n    for(i in 1:length(gammalist)){\n        if(verbose){\n            matchtype <- ifelse(stringdist.match[i], "string-distance", ifelse(numeric.match[i], "numeric", "exact"))\n            cat("    Matching variable", varnames[i], "using", matchtype, "matching.\\n")\n        }\n        ## Convert to character\n        if(is.factor(dfA[,varnames[i]]) | is.factor(dfB[,varnames[i]])){\n            dfA[,varnames[i]] <- as.character(dfA[,varnames[i]])\n            dfB[,varnames[i]] <- as.character(dfB[,varnames[i]])\n        }\n        ## Warn if no variation (except for gender blocking)\n        if(!gender.field[i]){\n            if(sum(is.na(dfA[,varnames[i]])) == nrow(dfA) | length(unique(dfA[,varnames[i]])) == 1){\n                cat(paste("WARNING: You have no variation in dataset A for", varnames[i], "or all observations are missing."))\n            }\n            if(sum(is.na(dfB[,varnames[i]])) == nrow(dfB) | length(unique(dfB[,varnames[i]])) == 1){\n                cat(paste("WARNING: You have no variation in dataset B for", varnames[i], "or all observations are missing."))\n            }\n        }\n        if(sum(dfA[,varnames[i]] %in% dfB[,varnames[i]]) == 0){\n            cat(paste0("WARNING: You have no exact matches for ", varnames[i], "."))\n        }\n        ## Get patterns\n        if(stringdist.match[i]){\n            if(partial.match[i]){\n                gammalist[[i]] <- gammaCKpar(\n                    dfA[,varnames[i]], dfB[,varnames[i]], cut.a = cut.a, cut.p = cut.p, method = stringdist.method, w = jw.weight, n.cores = n.cores\n                )\n            }else{\n                gammalist[[i]] <- gammaCK2par(dfA[,varnames[i]], dfB[,varnames[i]], cut.a = cut.a, method = stringdist.method, w = jw.weight, n.cores = n.cores)\n            }\n        }else if(numeric.match[i]){\n            if(partial.match[i]){\n                gammalist[[i]] <- gammaNUMCKpar(\n                    dfA[,varnames[i]], dfB[,varnames[i]], cut.a = cut.a.num, cut.p = cut.p.num, n.cores = n.cores\n                )\n            }else{\n                gammalist[[i]] <- gammaNUMCK2par(\n                    dfA[,varnames[i]], dfB[,varnames[i]], cut.a = cut.a.num, n.cores = n.cores\n                )\n            }\n        }else{\n            gammalist[[i]] <- gammaKpar(dfA[,varnames[i]], dfB[,varnames[i]], gender = gender.field[i], n.cores = n.cores)\n        }\n    }\n    end <- Sys.time()\n    if(verbose){\n        cat("Calculating matches for each variable took", round(difftime(end, start, units = "mins"), 2), "minutes.\\n\\n")\n    }\n\n    ## Get row numbers\n    nr_a <- nrow(dfA)\n    nr_b <- nrow(dfB)\n\n    ## ------------------------------\n    ## Get counts for zeta parameters\n    ## ------------------------------\n    cat("Getting counts for parameter estimation.\\n")\n    start <- Sys.time()\n    counts <- tableCounts(gammalist, nobs.a = nr_a, nobs.b = nr_b, n.cores = n.cores)\n    end <- Sys.time()\n    if(verbose){\n        cat("Getting counts for parameter estimation took", round(difftime(end, start, units = "mins"), 2), "minutes.\\n\\n")\n    }\n\n    ## ------------------------------\n    ## Run or impute the EM algorithm\n    ## ------------------------------\n    if(is.null(em.obj)){\n        ## Run EM algorithm\n        cat("Running the EM algorithm.\\n")\n        start <- Sys.time()\n        if(is.null(priors.obj)){\n            lambda.prior <- NULL\n            pi.prior <- NULL\n        }else{\n            if("lambda.prior" %in% names(priors.obj)){\n                lambda.prior <- priors.obj$lambda.prior\n            }\n            if("pi.prior" %in% names(priors.obj)){\n                if(!("lambda.prior" %in% names(priors.obj))){\n                    stop("Must specify a prior for lambda if providing a prior for pi.")\n                }\n                pi.prior <- priors.obj$pi.prior\n            }else{\n                pi.prior <- NULL\n            }\n        }\n        if(cond.indep == FALSE){\n            resultsEM <- emlinklog(patterns = counts, nobs.a = nr_a, nobs.b = nr_b,\n                                   tol = tol.em, varnames = varnames)  \n        }else{\n            resultsEM <- emlinkMARmov(patterns = counts, nobs.a = nr_a, nobs.b = nr_b,\n                                      tol = tol.em,\n                                      prior.lambda = lambda.prior, w.lambda = w.lambda,\n                                      prior.pi = pi.prior, w.pi = w.pi,\n                                      address.field = address.field, \n                                      gender.field = gender.field,\n                                      varnames = varnames)\n        }\n        end <- Sys.time()\n        if(verbose){\n            cat("Running the EM algorithm took", round(difftime(end, start, units = "secs"), 2), "seconds.\\n\\n")\n        }\n    }else{\n        cat("Imputing matching probabilities using provided EM object.\\n")\n        resultsEM <- emlinkRS(counts, em.obj, nr_a, nr_b)\n    }\n\n    if(max(resultsEM$zeta.j) < threshold.match) {\n        warning(paste0("No matches found for the threshold value used. We recommend trying a lower threshold.match value. Note that you currently have threshold.match set to ", threshold.match, "."))\n    }\n\n    ## -----------------------------------------------\n    ## Get the estimated matches, dedupe, and reweight\n    ## -----------------------------------------------\n    if(!estimate.only){\n        \n        ## Get matches\n        cat("Getting the indices of estimated matches.\\n")\n        start <- Sys.time()\n        matches <- matchesLink(gammalist, nobs.a = nr_a, nobs.b = nr_b,\n                               em = resultsEM, thresh = threshold.match,\n                               n.cores = n.cores)\n        end <- Sys.time()\n        if(verbose){\n            cat("Getting the indices of estimated matches took", round(difftime(end, start, units = "mins"), 2), "minutes.\\n\\n")\n        }\n\n        ## Get the patterns\n        patterns <- getPatterns(matchesA = dfA[matches$inds.a, ], matchesB = dfB[matches$inds.b, ],\n                                varnames = varnames, stringdist.match = stringdist.match,\n                                numeric.match = numeric.match, partial.match = partial.match,\n                                stringdist.method = stringdist.method,\n                                cut.a = cut.a, cut.p = cut.p, jw.weight = jw.weight,\n                                cut.a.num = cut.a.num, cut.p.num = cut.p.num)\n        \n        ## Run deduplication\n        if(dedupe.matches & length(matches$inds.a) > 0){\n            cat("Deduping the estimated matches.\\n")\n            start <- Sys.time()\n            ddm.out <- dedupeMatches(matchesA = dfA[matches$inds.a,], matchesB = dfB[matches$inds.b,],\n                                     EM = resultsEM, matchesLink = matches, patterns = patterns,\n                                     linprog = linprog.dedupe)\n            matches <- ddm.out$matchesLink\n            resultsEM <- ddm.out$EM\n            end <- Sys.time()\n            if(verbose){\n                cat("Deduping the estimated matches took", round(difftime(end, start, units = "mins"), 2), "minutes.\\n\\n")\n            }\n        }else if(length(matches$inds.a) > 0){\n            cat("Calculating the posterior for each pair of matched observations.\\n")\n            start <- Sys.time()\n            zeta <- getPosterior(dfA[matches$inds.a,], dfB[matches$inds.b,], EM = resultsEM,\n                                 patterns = patterns)\n            end <- Sys.time()\n            if(verbose){\n                cat("Calculating the posterior for each matched pair took", round(difftime(end, start, units = "mins"), 2), "minutes.\\n\\n")\n            }\n        }\n\n        ## Get the patterns\n        cat("Getting the match patterns for each estimated match.\\n")\n        start <- Sys.time()\n        patterns <- getPatterns(matchesA = dfA[matches$inds.a, ], matchesB = dfB[matches$inds.b, ],\n                                varnames = varnames, stringdist.match = stringdist.match,\n                                numeric.match = numeric.match, partial.match = partial.match,\n                                stringdist.method = stringdist.method,\n                                cut.a = cut.a, cut.p = cut.p, jw.weight = jw.weight,\n                                cut.a.num = cut.a.num, cut.p.num = cut.p.num)\n        end <- Sys.time()\n        if(verbose){\n            cat("Getting the match patterns for each estimated match took", round(difftime(end, start, units = "mins"), 2), "minutes.\\n\\n")\n        }\n\n        ## Reweight first names or get zeta\n        if(reweight.names & length(matches$inds.a) > 0){\n            cat("Reweighting match probabilities by frequency of occurrence.\\n")\n            start <- Sys.time()\n            rwn.out <- nameReweight(dfA, dfB, EM = resultsEM, gammalist = gammalist, matchesLink = matches,\n                                    varnames = varnames, firstname.field = firstname.field,\n                                    patterns = patterns, threshold.match = threshold.match, n.cores = n.cores)\n            end <- Sys.time()\n            if(verbose){\n                cat("Reweighting by first name took", round(difftime(end, start, units = "mins"), 2), "minutes.\\n\\n")\n            }\n        }\n\n        ## Return object\n        out <- list()\n        if(return.df){\n            out[["dfA.match"]] <- dfA[matches$inds.a,]\n            out[["dfB.match"]] <- dfB[matches$inds.b,]\n        }\n        out[["matches"]] <- matches\n        out[["EM"]] <- resultsEM\n        out[["patterns"]] <- patterns\n        if(dedupe.matches & length(matches$inds.a) > 0){\n            out[["posterior"]] <- ddm.out$max.zeta\n        }else if(length(matches$inds.a) > 0){\n            out[["posterior"]] <- zeta\n        }\n        if(reweight.names & length(matches$inds.a) > 0){\n            out[["posterior"]] <- rwn.out\n        }\n        out[["nobs.a"]] <- nr_a\n        out[["nobs.b"]] <- nr_b\n        if(return.all){\n            class(out) <- c("fastLink", "confusionTable")\n        }else{\n            class(out) <- "fastLink"\n        }\n        if(dedupe.df){\n            class(out) <- c(class(out), "fastLink.dedupe")\n        }\n    }else{\n        out <- resultsEM\n    }\n\n    return(out)\n\n}\n\n'