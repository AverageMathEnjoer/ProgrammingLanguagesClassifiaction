b'using UnityEngine;\nusing System.Collections;\n\n[ExecuteInEditMode]\n[RequireComponent(typeof(Light))]\npublic partial class LightShafts : MonoBehaviour\n{\n\tpublic void Start()\n\t{\n\t\tCheckMinRequirements();\n\n\t\tif (m_Cameras == null || m_Cameras.Length == 0)\n\t\t\tm_Cameras = new Camera[]{Camera.main};\n\n\t\tUpdateCameraDepthMode();\n\t}\n\n\tvoid UpdateShadowmap()\n\t{\n\t\tif (m_ShadowmapMode == LightShaftsShadowmapMode.Static && !m_ShadowmapDirty)\n\t\t\treturn;\n\n\t\tInitShadowmap();\n\n\t\tif (m_ShadowmapCamera == null)\n\t\t{\n\t\t\tGameObject go = new GameObject("Depth Camera");\n\t\t\tgo.AddComponent(typeof(Camera));\n\t\t\tm_ShadowmapCamera = go.GetComponent<Camera>();\n\t\t\tgo.hideFlags = HideFlags.HideAndDontSave;\n\t\t\tm_ShadowmapCamera.enabled = false;\n\t\t\tm_ShadowmapCamera.clearFlags = CameraClearFlags.SolidColor;\n\t\t}\n\t\tTransform cam = m_ShadowmapCamera.transform;\n\t\tcam.position = transform.position;\n\t\tcam.rotation = transform.rotation;\n\n\t\tif (directional)\n\t\t{\n\t\t\tm_ShadowmapCamera.orthographic = true;\n\t\t\tm_ShadowmapCamera.nearClipPlane = 0;\n\t\t\tm_ShadowmapCamera.farClipPlane = m_Size.z;\n\t\t\tm_ShadowmapCamera.orthographicSize = m_Size.y * 0.5f;\n\t\t\tm_ShadowmapCamera.aspect = m_Size.x / m_Size.y;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tm_ShadowmapCamera.orthographic = false;\n\t\t\tm_ShadowmapCamera.nearClipPlane = m_SpotNear * m_Light.range;\n\t\t\tm_ShadowmapCamera.farClipPlane = m_SpotFar * m_Light.range;\n\t\t\tm_ShadowmapCamera.fieldOfView = m_Light.spotAngle;\n\t\t\tm_ShadowmapCamera.aspect = 1.0f;\n\t\t}\n\t\tm_ShadowmapCamera.renderingPath = RenderingPath.Forward;\n\t\tm_ShadowmapCamera.targetTexture = m_Shadowmap;\n\t\tm_ShadowmapCamera.cullingMask = m_CullingMask;\n\t\tm_ShadowmapCamera.backgroundColor = Color.white;\n\n\t\tm_ShadowmapCamera.RenderWithShader(m_DepthShader, "RenderType");\n\n\t\tif (m_Colored)\n\t\t{\n\t\t\tm_ShadowmapCamera.targetTexture = m_ColorFilter;\n\t\t\tm_ShadowmapCamera.cullingMask = m_ColorFilterMask;\n\t\t\tm_ShadowmapCamera.backgroundColor = new Color(m_ColorBalance, m_ColorBalance, m_ColorBalance);\n\t\t\tm_ShadowmapCamera.RenderWithShader(m_ColorFilterShader, "");\n\t\t}\n\n\t\tm_ShadowmapDirty = false;\n\t}\n\t\n\tvoid RenderCoords(int width, int height, Vector4 lightPos)\n\t{\n\t\tSetFrustumRays(m_CoordMaterial);\n\n\t\tRenderBuffer[] buffers = {m_CoordEpi.colorBuffer, m_DepthEpi.colorBuffer};\n\t\tGraphics.SetRenderTarget(buffers, m_DepthEpi.depthBuffer);\n\t\tm_CoordMaterial.SetVector("_LightPos", lightPos);\n\t\tm_CoordMaterial.SetVector("_CoordTexDim", new Vector4(m_CoordEpi.width, m_CoordEpi.height, 1.0f / m_CoordEpi.width, 1.0f / m_CoordEpi.height));\n\t\tm_CoordMaterial.SetVector("_ScreenTexDim", new Vector4(width, height, 1.0f / width, 1.0f / height));\n\t\tm_CoordMaterial.SetPass(0);\n\t\tRenderQuad();\n\t}\n\n\tvoid RenderInterpolationTexture(Vector4 lightPos)\n\t{\n\t\tGraphics.SetRenderTarget(m_InterpolationEpi.colorBuffer, m_RaymarchedLightEpi.depthBuffer);\n\t\tif (!m_DX11Support && (Application.platform == RuntimePlatform.WindowsEditor || Application.platform == RuntimePlatform.WindowsPlayer))\n\t\t{\n\t\t\t// Looks like in dx9 stencil is not cleared properly with GL.Clear()\n\t\t\t// Edit: fixed in 4.5, so this hack can be removed\n\t\t\tm_DepthBreaksMaterial.SetPass(1);\n\t\t\tRenderQuad();\n\t\t}\n\t\telse\n\t\t{\n\t\t\tGL.Clear(true, true, new Color(0, 0, 0, 1));\n\t\t}\n\t\tm_DepthBreaksMaterial.SetFloat("_InterpolationStep", m_InterpolationStep);\n\t\tm_DepthBreaksMaterial.SetFloat("_DepthThreshold", GetDepthThresholdAdjusted());\n\t\tm_DepthBreaksMaterial.SetTexture("_DepthEpi", m_DepthEpi);\n\t\tm_DepthBreaksMaterial.SetVector("_DepthEpiTexDim", new Vector4(m_DepthEpi.width, m_DepthEpi.height, 1.0f / m_DepthEpi.width, 1.0f / m_DepthEpi.height));\n\t\tm_DepthBreaksMaterial.SetPass(0);\n\t\tRenderQuadSections(lightPos);\n\t}\n\n\tvoid InterpolateAlongRays(Vector4 lightPos)\n\t{\n\t\tGraphics.SetRenderTarget(m_InterpolateAlongRaysEpi);\n\t\tm_InterpolateAlongRaysMaterial.SetFloat("_InterpolationStep", m_InterpolationStep);\n\t\tm_InterpolateAlongRaysMaterial.SetTexture("_InterpolationEpi", m_InterpolationEpi);\n\t\tm_InterpolateAlongRaysMaterial.SetTexture("_RaymarchedLightEpi", m_RaymarchedLightEpi);\n\t\tm_InterpolateAlongRaysMaterial.SetVector("_RaymarchedLightEpiTexDim", new Vector4(m_RaymarchedLightEpi.width, m_RaymarchedLightEpi.height, 1.0f / m_RaymarchedLightEpi.width, 1.0f / m_RaymarchedLightEpi.height));\n\t\tm_InterpolateAlongRaysMaterial.SetPass(0);\n\t\tRenderQuadSections(lightPos);\n\t}\n\t\n\tvoid RenderSamplePositions(int width, int height, Vector4 lightPos)\n\t{\n\t\tInitRenderTexture (ref m_SamplePositions, width, height, 0, RenderTextureFormat.ARGB32, false);\n\t\t// Unfortunately can\'t be a temporary RT if we want random write\n\t\tm_SamplePositions.enableRandomWrite = true;\n\t\tm_SamplePositions.filterMode = FilterMode.Point;\n\t\t\t\t\n\t\tGraphics.SetRenderTarget (m_SamplePositions);\n\t\tGL.Clear (false, true, new Color(0,0,0,1));\n\t\t\n\t\tGraphics.ClearRandomWriteTargets();\n\t\tGraphics.SetRandomWriteTarget(1, m_SamplePositions);\n\t\t\n\t\t//We need a render target with m_Coord dimensions, but reading and writing\n\t\t//to the same target produces wrong read results, so using a dummy.\n\t\tGraphics.SetRenderTarget(m_RaymarchedLightEpi);\n\t\t\n\t\tm_SamplePositionsMaterial.SetVector("_OutputTexDim", new Vector4(width-1, height-1, 0, 0));\n\t\tm_SamplePositionsMaterial.SetVector("_CoordTexDim", new Vector4(m_CoordEpi.width, m_CoordEpi.height, 0, 0));\n\t\tm_SamplePositionsMaterial.SetTexture("_Coord", m_CoordEpi);\n\t\tm_SamplePositionsMaterial.SetTexture("_InterpolationEpi", m_InterpolationEpi);\n\n\t\tif (m_ShowInterpolatedSamples)\n\t\t{\n\t\t\tm_SamplePositionsMaterial.SetFloat("_SampleType", 1);\n\t\t\tm_SamplePositionsMaterial.SetVector("_Color", new Vector4(0.4f, 0.4f, 0, 0));\n\t\t\tm_SamplePositionsMaterial.SetPass(0);\n\t\t\tRenderQuad();\n\t\t}\n\n\t\tm_SamplePositionsMaterial.SetFloat("_SampleType", 0);\n\t\tm_SamplePositionsMaterial.SetVector("_Color", new Vector4(1, 0, 0, 0));\n\t\tm_SamplePositionsMaterial.SetPass(0);\n\t\tRenderQuadSections(lightPos);\n\t\t\n\t\tGraphics.ClearRandomWriteTargets();\n\t}\n\n\tvoid ShowSamples(int width, int height, Vector4 lightPos)\n\t{\n\t\tbool showSamples = m_ShowSamples && m_DX11Support && m_SamplePositionsShaderCompiles;\n\t\tSetKeyword(showSamples, "SHOW_SAMPLES_ON", "SHOW_SAMPLES_OFF");\n\t\tif (showSamples)\n\t\t\tRenderSamplePositions(width, height, lightPos);\n\n\t\tm_FinalInterpolationMaterial.SetFloat("_ShowSamplesBackgroundFade", m_ShowSamplesBackgroundFade);\n\t}\n\n\tvoid Raymarch(int width, int height, Vector4 lightPos)\n\t{\n\t\tSetFrustumRays(m_RaymarchMaterial);\n\n\t\tint shadowmapWidth = m_Shadowmap.width;\n\t\tint shadowmapHeight = m_Shadowmap.height;\n\n\t\tGraphics.SetRenderTarget(m_RaymarchedLightEpi.colorBuffer, m_RaymarchedLightEpi.depthBuffer);\n\t\tGL.Clear(false, true, new Color(0, 0, 0, 1));\n\t\tm_RaymarchMaterial.SetTexture("_Coord", m_CoordEpi);\n\t\tm_RaymarchMaterial.SetTexture("_InterpolationEpi", m_InterpolationEpi);\n\t\tm_RaymarchMaterial.SetTexture("_Shadowmap", m_Shadowmap);\n\t\tfloat brightness = m_Colored ? m_BrightnessColored/m_ColorBalance : m_Brightness;\n\t\tbrightness *= m_Light.intensity;\n\t\tm_RaymarchMaterial.SetFloat("_Brightness", brightness);\n\t\tm_RaymarchMaterial.SetFloat("_Extinction", -m_Extinction);\n\t\tm_RaymarchMaterial.SetVector("_ShadowmapDim", new Vector4(shadowmapWidth, shadowmapHeight, 1.0f / shadowmapWidth, 1.0f / shadowmapHeight));\n\t\tm_RaymarchMaterial.SetVector("_ScreenTexDim", new Vector4(width, height, 1.0f / width, 1.0f / height));\n\t\tm_RaymarchMaterial.SetVector("_LightColor", m_Light.color.linear);\n\t\tm_RaymarchMaterial.SetFloat("_MinDistFromCamera", m_MinDistFromCamera);\n\t\tSetKeyword(m_Colored, "COLORED_ON", "COLORED_OFF");\n\t\tm_RaymarchMaterial.SetTexture("_ColorFilter", m_ColorFilter);\n\t\tSetKeyword(m_AttenuationCurveOn, "ATTENUATION_CURVE_ON", "ATTENUATION_CURVE_OFF");\n\t\tm_RaymarchMaterial.SetTexture("_AttenuationCurveTex", m_AttenuationCurveTex);\n\t\tTexture cookie = m_Light.cookie;\n\t\tSetKeyword(cookie != null, "COOKIE_TEX_ON", "COOKIE_TEX_OFF");\n\t\tif (cookie != null)\n\t\t\tm_RaymarchMaterial.SetTexture("_Cookie", cookie);\n\t\tm_RaymarchMaterial.SetPass(0);\n\n\t\tRenderQuadSections(lightPos);\n\t}\n\n\tpublic void OnRenderObject ()\n\t{\n\t\tm_CurrentCamera = Camera.current;\n\t\tif (!m_MinRequirements || !CheckCamera() || !IsVisible())\n\t\t\treturn;\n\n\t\t// Prepare\n\t\tRenderBuffer depthBuffer = Graphics.activeDepthBuffer;\n\t\tRenderBuffer colorBuffer = Graphics.activeColorBuffer;\n\t\tInitResources();\n\t\tVector4 lightPos = GetLightViewportPos();\n\t\tbool lightOnScreen = lightPos.x >= -1 && lightPos.x <= 1 && lightPos.y >= -1 && lightPos.y <= 1;\n\t\tSetKeyword(lightOnScreen, "LIGHT_ON_SCREEN", "LIGHT_OFF_SCREEN");\n\t\tint width = Screen.width;\n\t\tint height = Screen.height;\n\t\t\n\t\t// Render the buffers, raymarch, interpolate along rays\n\t\tUpdateShadowmap();\n\t\tSetKeyword(directional, "DIRECTIONAL_SHAFTS", "SPOT_SHAFTS");\n\t\tRenderCoords(width, height, lightPos);\n\t\tRenderInterpolationTexture(lightPos);\n\t\tRaymarch(width, height, lightPos);\n\t\tInterpolateAlongRays(lightPos);\n\n\t\tShowSamples(width, height, lightPos);\n\n\t\t// Final interpolation and blending onto the screen\n\t\tSetFrustumRays(m_FinalInterpolationMaterial);\n\t\tm_FinalInterpolationMaterial.SetTexture("_InterpolationEpi", m_InterpolationEpi);\n\t\tm_FinalInterpolationMaterial.SetTexture("_DepthEpi", m_DepthEpi);\n\t\tm_FinalInterpolationMaterial.SetTexture("_Shadowmap", m_Shadowmap);\n\t\tm_FinalInterpolationMaterial.SetTexture("_Coord", m_CoordEpi);\n\t\tm_FinalInterpolationMaterial.SetTexture("_SamplePositions", m_SamplePositions);\n\t\tm_FinalInterpolationMaterial.SetTexture("_RaymarchedLight", m_InterpolateAlongRaysEpi);\n\t\tm_FinalInterpolationMaterial.SetVector("_CoordTexDim", new Vector4(m_CoordEpi.width, m_CoordEpi.height, 1.0f / m_CoordEpi.width, 1.0f / m_CoordEpi.height));\n\t\tm_FinalInterpolationMaterial.SetVector("_ScreenTexDim", new Vector4(width, height, 1.0f / width, 1.0f / height));\n\t\tm_FinalInterpolationMaterial.SetVector("_LightPos", lightPos);\n\t\tm_FinalInterpolationMaterial.SetFloat("_DepthThreshold", GetDepthThresholdAdjusted());\n\t\tbool renderAsQuad = directional || IntersectsNearPlane();\n\t\tm_FinalInterpolationMaterial.SetFloat("_ZTest", (float)(renderAsQuad ? UnityEngine.Rendering.CompareFunction.Always : UnityEngine.Rendering.CompareFunction.Less));\n\t\tSetKeyword(renderAsQuad, "QUAD_SHAFTS", "FRUSTUM_SHAFTS");\n\n\t\tGraphics.SetRenderTarget(colorBuffer, depthBuffer);\n\t\tm_FinalInterpolationMaterial.SetPass(0);\n\t\tif (renderAsQuad)\n\t\t\tRenderQuad();\n\t\telse\n\t\t\tRenderSpotFrustum();\n\n\t\tReleaseResources();\n\t}\n}\n'