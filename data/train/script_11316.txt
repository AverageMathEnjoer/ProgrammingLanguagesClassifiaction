b'{-# LANGUAGE ScopedTypeVariables, DeriveDataTypeable,\n             ExistentialQuantification, GADTs,\n             FlexibleInstances, UndecidableInstances,\n             TypeOperators #-}\n-- | Extensible options. They are used for provider-specific settings,\n-- ingredient-specific settings and core settings (such as the test name pattern).\n--\n-- @since 0.1\nmodule Test.Tasty.Options\n  (\n    -- * IsOption class\n    IsOption(..)\n    -- * Option sets and operations\n  , OptionSet\n  , setOption\n  , changeOption\n  , lookupOption\n  , singleOption\n  , OptionDescription(..)\n  , uniqueOptionDescriptions\n    -- * Utilities\n  , flagCLParser\n  , mkFlagCLParser\n  , mkOptionCLParser\n  , safeRead\n  , safeReadBool\n  ) where\n\nimport qualified Data.Map as Map\nimport Data.Map (Map)\nimport Data.Maybe\nimport Data.Char (toLower)\nimport Data.Tagged\nimport Data.Proxy\nimport Data.Typeable\nimport Data.Monoid\nimport Data.Foldable\nimport qualified Data.Semigroup as Sem\nimport qualified Data.Set as S\nimport Prelude hiding (mod) -- Silence FTP import warnings\nimport Options.Applicative\n\n-- | An option is a data type that inhabits the `IsOption` type class.\n--\n-- @since 0.1\nclass Typeable v => IsOption v where\n  -- | The value to use if the option was not supplied explicitly\n  defaultValue :: v\n  -- | Try to parse an option value from a string. Consider using\n  -- \'safeReadBool\' for boolean options and \'safeRead\' for numeric options.\n  parseValue :: String -> Maybe v\n  -- | The option name. It is used to form the command line option name, for\n  -- instance. Therefore, it had better not contain spaces or other fancy\n  -- characters. It is recommended to use dashes instead of spaces.\n  optionName :: Tagged v String\n  -- | The option description or help string. This can be an arbitrary\n  -- string.\n  optionHelp :: Tagged v String\n  -- | How a \'defaultValue\' should be displayed in the help string. \'Nothing\'\n  -- (the default implementation) will result in nothing being displayed, while\n  -- @\'Just\' def@ will result in @def@ being advertised as the default in the\n  -- help string.\n  --\n  -- @since 1.3\n  showDefaultValue :: v -> Maybe String\n  showDefaultValue _ = Nothing\n  -- | A command-line option parser.\n  --\n  -- It has a default implementation in terms of the other methods.\n  -- You may want to override it in some cases (e.g. add a short flag) and\n  -- \'flagCLParser\', \'mkFlagCLParser\' and \'mkOptionCLParser\' might come in\n  -- handy.\n  --\n  -- Even if you override this, you still should implement all the methods\n  -- above, to allow alternative interfaces.\n  --\n  -- Do not supply a default value (e.g., with the \'value\' function) here\n  -- for this parser! This is because if no value was provided on the command\n  -- line we may lookup the option e.g. in the environment. But if the parser\n  -- always succeeds, we have no way to tell whether the user really provided\n  -- the option on the command line.\n  --\n  -- Similarly, do not use \'showDefaultWith\' here, as it will be ignored. Use\n  -- the \'showDefaultValue\' method of \'IsOption\' instead.\n\n  -- (If we don\'t specify a default, the option becomes mandatory.\n  -- So, when we build the complete parser for OptionSet, we turn a\n  -- failing parser into an always-succeeding one that may return an empty\n  -- OptionSet.)\n  optionCLParser :: Parser v\n  optionCLParser = mkOptionCLParser mempty\n\n\ndata OptionValue = forall v . IsOption v => OptionValue v\n\n-- | A set of options. Only one option of each type can be kept.\n--\n-- If some option has not been explicitly set, the default value is used.\n--\n-- @since 0.1\nnewtype OptionSet = OptionSet (Map TypeRep OptionValue)\n\n-- | Later options override earlier ones.\n--\n-- @since 0.12.0.1\ninstance Sem.Semigroup OptionSet where\n  OptionSet a <> OptionSet b =\n    OptionSet $ Map.unionWith (flip const) a b\ninstance Monoid OptionSet where\n  mempty = OptionSet mempty\n#if !MIN_VERSION_base(4,11,0)\n  mappend = (Sem.<>)\n#endif\n\n-- | Set the option value.\n--\n-- @since 0.1\nsetOption :: IsOption v => v -> OptionSet -> OptionSet\nsetOption v (OptionSet s) =\n  OptionSet $ Map.insert (typeOf v) (OptionValue v) s\n\n-- | Query the option value.\n--\n-- @since 0.1\nlookupOption :: forall v . IsOption v => OptionSet -> v\nlookupOption (OptionSet s) =\n  case Map.lookup (typeOf (undefined :: v)) s of\n    Just (OptionValue x) | Just v <- cast x -> v\n    Just {} -> error "OptionSet: broken invariant (shouldn\'t happen)"\n    Nothing -> defaultValue\n\n-- | Change the option value.\n--\n-- @since 0.1\nchangeOption :: forall v . IsOption v => (v -> v) -> OptionSet -> OptionSet\nchangeOption f s = setOption (f $ lookupOption s) s\n\n-- | Create a singleton \'OptionSet\'.\n--\n-- @since 0.8\nsingleOption :: IsOption v => v -> OptionSet\nsingleOption v = setOption v mempty\n\n-- | The purpose of this data type is to capture the dictionary\n-- corresponding to a particular option.\n--\n-- @since 0.1\ndata OptionDescription where\n  Option :: IsOption v => Proxy v -> OptionDescription\n\n-- | Remove duplicated \'OptionDescription\', preserving existing order otherwise.\n--\n-- @since 1.4.1\nuniqueOptionDescriptions :: [OptionDescription] -> [OptionDescription]\nuniqueOptionDescriptions = go S.empty\n  where\n    go _ [] = []\n    go acc (Option o : os)\n      | typeOf o `S.member` acc = go acc os\n      | otherwise = Option o : go (S.insert (typeOf o) acc) os\n\n-- | Command-line parser to use with flags.\n--\n-- @since 0.8\nflagCLParser\n  :: forall v . IsOption v\n  => Maybe Char -- ^ optional short flag\n  -> v          -- ^ non-default value (when the flag is supplied)\n  -> Parser v\nflagCLParser mbShort = mkFlagCLParser (foldMap short mbShort)\n\n-- | Command-line flag parser that takes additional option modifiers.\n--\n-- @since 0.11.1\nmkFlagCLParser\n  :: forall v . IsOption v\n  => Mod FlagFields v -- ^ option modifier\n  -> v                -- ^ non-default value (when the flag is supplied)\n  -> Parser v\nmkFlagCLParser mod v = flag\' v\n  (  long (untag (optionName :: Tagged v String))\n  <> help (untag (optionHelp :: Tagged v String))\n  <> mod\n  )\n\n-- | Command-line option parser that takes additional option modifiers.\n--\n-- @since 0.11.1\nmkOptionCLParser :: forall v . IsOption v => Mod OptionFields v -> Parser v\nmkOptionCLParser mod =\n  option parse\n    (  long name\n    <> help (untag (optionHelp :: Tagged v String))\n    <> mod\n    )\n  where\n    name :: String\n    name = untag (optionName :: Tagged v String)\n\n    parse :: ReadM v\n    parse = do\n      s <- str\n      let err = "Could not parse: " ++ s ++ " is not a valid " ++ name\n      maybe (readerError err) pure (parseValue s)\n\n-- | Safe read function. Defined here for convenience to use for\n-- \'parseValue\'.\n--\n-- @since 0.1\nsafeRead :: Read a => String -> Maybe a\nsafeRead s\n  | [(x, "")] <- reads s = Just x\n  | otherwise = Nothing\n\n-- | Parse a \'Bool\' case-insensitively.\n--\n-- @since 1.0.1\nsafeReadBool :: String -> Maybe Bool\nsafeReadBool s =\n  case (map toLower s) of\n    "true" -> Just True\n    "false" -> Just False\n    _ -> Nothing\n'