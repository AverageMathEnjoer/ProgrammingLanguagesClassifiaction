b'{-# LANGUAGE CPP #-}\n{-# OPTIONS_GHC -XFlexibleInstances #-}\nmodule Main where\n\nimport Control.Monad\nimport Control.Monad.ST\n-- TODO: switch\n#define UNBOXED\n#ifdef UNBOXED\nimport qualified Data.Vector.Unboxed as V \nimport qualified Data.Vector.Unboxed.Mutable as MV\n#else\nimport qualified Data.Vector.Storable as V \nimport qualified Data.Vector.Storable.Mutable as MV\n#endif\n\nimport qualified Debug.Trace as DT\n\nimport System.Random\n\nimport System.Environment\nimport Control.Exception\nimport Test.QuickCheck (Arbitrary, arbitrary, sized, choose, vector)\n\nimport Data.List.Split (chunk)\nimport Data.List (intersperse)\n\nimport Data.Word (Word32)\nimport Data.Time.Clock\nimport Text.Printf\nimport Data.Vector.Algorithms.Intro (sort)\n\n#ifdef PARSCHED \nimport PARSCHED\n#else\nimport Control.Monad.Par (runPar, spawn_, get, Par)\n#endif\n\n-- Element type being sorted:\ntype ElmT = Word32\n\n-- Here we can choose safe or unsafe operations:\n#ifndef SAFE\nthawit  x     = V.unsafeThaw   x\nnewMV   x     = MV.unsafeNew   x\nreadMV  x y   = MV.unsafeRead  x y\nwriteMV x y z = MV.unsafeWrite x y z\nsliceMV x y z = MV.unsafeSlice x y z\ncopyMV  x y   = MV.unsafeCopy  x y \n#else\nthawit  x     = V.thaw   x\nnewMV   x     = MV.new   x\nreadMV  x y   = MV.read  x y\nwriteMV x y z = MV.write x y z\nsliceMV x y z = MV.slice x y z\ncopyMV  x y   = MV.copy  x y \n#endif\n{-# INLINE thawit #-}\n{-# INLINE newMV #-}\n{-# INLINE readMV #-}\n{-# INLINE writeMV #-}\n{-# INLINE sliceMV #-}\n{-# INLINE copyMV #-}\n\n\n----------------------------------------------------------------------------------------------------\n\n-- import System.Random.Mersenne\n-- import Random.MWC.Pure (seed, range_random)\n\n-- | Wrapper for sorting immutable vectors:\nseqsort :: V.Vector ElmT -> V.Vector ElmT\nseqsort v = V.create $ do \n--                mut <- thawit v\n                mut <- V.thaw v\n                -- This is the pure-haskell sort on mutable vectors\n                -- from the vector-algorithms package:\n                sort mut\n                return mut\n\n-- Merge sort for a Vector using the Par monad\n-- t is the threshold for using sequential merge (see merge)\nmergesort :: Int -> V.Vector ElmT -> Par (V.Vector ElmT)\nmergesort t vec = if V.length vec <= t\n                  then return $ seqsort vec\n                  else do\n                      let n = (V.length vec) `div` 2\n                      let (lhalf, rhalf) = V.splitAt n vec\n                      ileft <- spawn_ (mergesort t lhalf)\n                      right <-         mergesortGPU t rhalf\n                      left  <- get ileft\n                      merge t left right\n\n\nmergesortGPU :: Int -> V.Vector ElmT -> Par (V.Vector ElmT)\nmergesortGPU t vec = if V.length vec <= t\n--                  then return $ liftIO$ blockingMergsort vec \n                  then return $ spawnGPUMergsort vec >>= get\n                  else do\n                      let n = (V.length vec) `div` 2\n                      let (lhalf, rhalf) = V.splitAt n vec\n                      ileft <- spawn_ (mergesortGPU t lhalf)\n                      right <-         mergesortGPU t rhalf\n                      left  <- get ileft\n                      merge t left right\n\n\n-- If either list has length less than t, use sequential merge. Otherwise:\n--   1. Find the median of the two combined lists using findSplit\n--   2. Split the lists at the median\n--   3. Merge each of the lefts and rights\n--   4. Append the merged lefts and the merged rights\nmerge :: Int -> (V.Vector ElmT) -> (V.Vector ElmT) -> Par (V.Vector ElmT)\nmerge t left right =\n        if V.length left  < t || \n           V.length right < t\n        then return $ seqmerge left right\n        else do\n            let (splitL, splitR) = findSplit left right\n            let (llhalf, rlhalf) = V.splitAt splitL left\n            let (lrhalf, rrhalf) = V.splitAt splitR right\n            isortLeft <- spawn_ (merge t llhalf lrhalf)\n            sortRight <-         merge t rlhalf rrhalf\n            sortLeft  <- get isortLeft\n            -- NOTE: this append is where our most expensive copies\n            -- happen, in contrast, for example with the Cilk\n            -- implementation, which is fully inplace:\n            return (sortLeft V.++ sortRight)\n        \n{-\n - Given two sorted vectors, return a pair of indices such that splitting on \n - these indices results in 4 vectors in which every value in the two left \n - side vectors is smaller than all of the values in the right side vectors.\n -\n - In other words, if lIndex and rIndex are the splitting points for the\n - vectors named left and right, then every item in left, up to lIndex, is\n - smaller than every item in right from rIndex on; and every item in right,\n - up to rIndex, is smaller than every item in left from lIndex on.\n -\n - Additionally, (lIndex + rIndex) should be as close to \n - (length(left) + length(right))/2 as possible.\n -}\nfindSplit :: V.Vector ElmT -> V.Vector ElmT -> (Int, Int)\nfindSplit left right = (lIndex, rIndex)\n        where\n            (lIndex, rIndex) = split 0 (V.length left) 0 (V.length right)\n\n            split :: Int -> Int -> Int -> Int -> (Int, Int)\n            split lLow lHigh rLow rHigh = \n                let lIndex = (lLow + lHigh) `div` 2\n                    rIndex = (rLow + rHigh) `div` 2 in\n                    \n                    if (lIndex == 0)\n                    then if (right V.! (rIndex - 1)) < (left V.! lIndex)\n                         then (lIndex, rIndex)\n                         else split 0 0 rLow rIndex\n                    else if (rIndex == 0)\n                    then if (left V.! (lIndex - 1)) < (right V.! rIndex)\n                         then (lIndex, rIndex)\n                         else split lLow lIndex 0 0\n                    else if (left V.! (lIndex - 1)) < (right V.! rIndex) &&\n                            (right V.! (rIndex - 1)) < (left V.! lIndex)\n                    then (lIndex, rIndex)\n                    else if (left V.! (lIndex - 1)) < (right V.! rIndex)\n                    then split lIndex lHigh rLow rIndex\n                    else split lLow lIndex rIndex rHigh\n\n-- | Sequential merge: takes two sorted vectors and merges them in a sequential\n-- fashion.\n-- This is an imperative version using the ST monad:\nseqmerge :: V.Vector ElmT -> V.Vector ElmT -> V.Vector ElmT\nseqmerge left_ right_ = \n--    DT.trace ("seqmerge "++ show (left_, right_)) $\n    -- TODO: Should probably prevent this being called on empty vectors:\n    if V.null left_  then right_ else \n    if V.null right_ then left_  else \n    V.create $ do\n      let lenL = V.length left_\n\t  lenR = V.length right_\n\t  len  = lenL + lenR \n      left  <- thawit left_\n      right <- thawit right_\n      dest  <- newMV len      \n      -- Ideally this would be replaced with a vectorized sorting\n      -- network (e.g. a bitonic network)!\n      let \n          -- lx is the element stored in position li of `left`:\n\t  loop li lx ri rx di = \n            let di\' = di+1 in\n            if lx < rx then do \n               writeMV dest di lx\n               let li\' = li+1\n               if li\' == lenL then\n\t\t  copyOffset right dest ri di\' (lenR - ri)\n                else when (di\' < len) $ do\n                  lx\' <- readMV left li\'\n                  loop li\' lx\' ri rx di\'\n            else do \n               writeMV dest di rx\n               let ri\' = ri+1\n               if ri\' == lenR then\n\t\t  copyOffset left dest li di\' (lenL - li)\n                else when (di\' < len) $ do\n                  rx\' <- readMV right ri\'\n                  loop li lx ri\' rx\' di\'\n      fstL <- readMV left  0\n      fstR <- readMV right 0\n      loop 0 fstL 0 fstR 0\n      return dest\n\n\n-- RRN: We could also consider an FFI seqmerge!  That would be\n-- consistent with our FFI calls on the sorting leaves.\n\n----------------------------------------------------------------------------------------------------\n-- Misc Helpers:\n\n-- | Create a vector containing the numbers [0,N) in random order.\nrandomPermutation :: Int -> StdGen -> V.Vector ElmT\nrandomPermutation len rng = \n  -- Annoyingly there is no MV.generate:\n  V.create (do v <- thawit$ V.generate len fromIntegral\n               loop 0 v rng)\n  -- loop 0 (MV.generate len id)\n where \n  loop n vec g | n == len  = return vec\n\t       | otherwise = do \n    let (offset,g\') = randomR (0, len - n - 1) g\n    MV.swap vec n (n + offset)\n    loop (n+1) vec g\'\n\n-- | Format a large number with commas.\ncommaint :: (Show a, Integral a) => a -> String\ncommaint n | n < 0 = "-" ++ commaint (-n)\ncommaint n = \n   reverse $ concat $\n   intersperse "," $ \n   chunk 3 $ reverse (show n)\n\n\n-- copyOffset :: (PrimMonad m, MVector v e)\n--            => v (PrimState m) e -> v (PrimState m) e -> Int -> Int -> Int -> m ()\ncopyOffset :: MV.MVector s ElmT -> MV.MVector s ElmT -> Int -> Int -> Int -> ST s ()\ncopyOffset from to iFrom iTo len =\n  copyMV (sliceMV iTo len to)\n\t (sliceMV iFrom len from)\n{-# INLINE copyOffset #-}\n\n\n----------------------------------------------------------------------------------------------------\n\n\n-- Main, based on quicksort main\n-- Usage: ./Main [expt] [threshold]\n--   t is threshold to bottom out to sequential sort and sequential merge\n--   expt controls the length of the vector to sort (length = 2^expt)\nmain = do args <- getArgs\n          let (expt, t) = case args of\n                            -- The default size should be very small.\n                            -- Just for testing, not for benchmarking:\n                            []     -> (10, 2)\n--                            [n]    -> (read n, 1024)\n                            [n]    -> (read n, 8192)\n                            [n, t] -> (read n, read t)\n\n          g <- getStdGen\n\n          putStrLn $ "Merge sorting " ++ commaint (2^expt) ++ \n                     " elements. First generate a random permutation:"\n\n          start <- getCurrentTime\n          let rands = randomPermutation (2^expt) g\n          evaluate$ rands\n          evaluate$ rands V.! 0\n          end   <- getCurrentTime\n          printf "Creating vector took %0.3f sec.\\n"\n            ((fromRational$ toRational $ diffUTCTime end start) :: Double)\n\n          putStrLn "Executing monad-par based sort..."\n          start <- getCurrentTime\n          let sorted = runPar $ mergesort t rands\n          putStr "Beginning of sorted list:\\n  "\n          print $ V.slice 0 8 sorted\n          end   <- getCurrentTime\n          putStr "End of sorted list:\\n  "\n          print $ V.slice (V.length rands - 8) 8 sorted\n\n          -- TODO: Verify that the output is correct!  (After timing is finished.)\n\n          let runningTime = ((fromRational $ toRational $ diffUTCTime end start) :: Double)\n          printf "Sorting vector took %0.3f sec.\\n" runningTime\n          putStrLn $ "SELFTIMED " ++ show runningTime\n          when (expt <= 4) $ do\n            putStrLn$ "  Unsorted: " ++  show rands\n            putStrLn$ "  Sorted  : " ++  show sorted\n\n\n-- Needed for Par monad to work with unboxed vectors\n-- instance NFData (V.Vector Int) where\n--   rnf = rnf . V.toList\n-- \n-- RRN: This ^^ is very inefficient!  If you did want to force the\n-- evaluation, at the very worst you would want to do a fold to\n-- traverse a (boxed) vector, but with an unboxed vector the whole\n-- thing is evaluated when one element is.  It should be enough to\n-- read one element.  (It *might* be enough to just use "pseq" or\n-- "evaluate" on the vector value itself, but I\'m not sure.)\n\n\n-- Used for QuickCheck\ninstance Arbitrary (V.Vector Int) where\n    arbitrary = do\n        ls <- sized (\\n -> choose (0, n) >>= vector)\n        return (V.fromList ls)\n\n----------------------------------------------------------------------------------------------------\n-- SCRAP:\n\n-- Although vector cons is supported, it requires O(n) time. Since list cons\n-- is much faster, we\'ll build up a list of tuples and use the batch update\n-- for vectors: (//).\nseqmerge_pure :: V.Vector ElmT -> V.Vector ElmT -> V.Vector ElmT\nseqmerge_pure left right = \n    -- (left V.++ right) V.// (seqhelp 0 left right)\n    V.unsafeUpd (V.replicate len 0) (seqhelp 0 left right)\n\n    where\n        len = (V.length left) + (V.length right)\n        seqhelp :: Int -> V.Vector ElmT -> V.Vector ElmT -> [(Int, ElmT)]\n        seqhelp n left right = \n            if n >= len\n            then []\n            else if V.null left\n            then zip [n..(n + V.length right)] (V.toList right)\n            else if V.null right\n            then zip [n..(n + V.length left)]  (V.toList left)\n            else if (V.head left) < (V.head right)\n            then (n, V.head left)  : seqhelp (n+1) (V.tail left) right\n            else (n, V.head right) : seqhelp (n+1) left (V.tail right)\n'