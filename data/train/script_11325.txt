b'{-# LANGUAGE AllowAmbiguousTypes #-}\n-- | Contains a schema for beam migration tools. Used by the CLI and\n-- the managed migrations support here.\nmodule Database.Beam.Migrate.Log where\n\nimport Database.Beam\nimport Database.Beam.Backend.SQL\nimport Database.Beam.Migrate\nimport Database.Beam.Migrate.Backend\n\nimport Control.Monad (when)\n\nimport Data.Int\nimport Data.String (fromString)\nimport Data.Text (Text)\nimport Data.Time (LocalTime)\nimport Data.UUID.Types (UUID)\nimport Data.Maybe (fromMaybe)\n\nimport qualified Control.Monad.Fail as Fail\n\ndata LogEntryT f\n  = LogEntry\n  { _logEntryId       :: C f Int32\n  , _logEntryCommitId :: C f Text\n  , _logEntryDate     :: C f LocalTime\n  } deriving Generic\n\ninstance Beamable LogEntryT\ntype LogEntry = LogEntryT Identity\nderiving instance Show LogEntry\n\ninstance Table LogEntryT where\n  data PrimaryKey LogEntryT f = LogEntryKey (C f Int32)\n    deriving Generic\n  primaryKey = LogEntryKey <$> _logEntryId\n\ninstance Beamable (PrimaryKey LogEntryT)\n\ntype LogEntryKey = PrimaryKey LogEntryT Identity\nderiving instance Show LogEntryKey\n\nnewtype BeamMigrateVersionT f\n  = BeamMigrateVersion\n  { _beamMigrateVersion :: C f Int32\n  } deriving Generic\n\ninstance Beamable BeamMigrateVersionT\ntype BeamMigrateVersion = BeamMigrateVersionT Identity\nderiving instance Show BeamMigrateVersion\n\ninstance Table BeamMigrateVersionT where\n  data PrimaryKey BeamMigrateVersionT f = BeamMigrateVersionKey (C f Int32)\n    deriving Generic\n  primaryKey = BeamMigrateVersionKey <$> _beamMigrateVersion\n\ninstance Beamable (PrimaryKey BeamMigrateVersionT)\n\ntype BeamMigrateVersionKey = PrimaryKey BeamMigrateVersionT Identity\nderiving instance Show BeamMigrateVersionKey\n\n-- Database\ndata BeamMigrateDb entity\n  = BeamMigrateDb\n  { _beamMigrateVersionTbl :: entity (TableEntity BeamMigrateVersionT)\n  , _beamMigrateLogEntries :: entity (TableEntity LogEntryT)\n  } deriving Generic\n\ninstance Database be BeamMigrateDb\n\nbeamMigratableDb :: forall be m\n                  . ( BeamMigrateSqlBackend be\n                    , HasDataTypeCreatedCheck (BeamMigrateSqlBackendDataTypeSyntax be)\n                    , MonadBeam be m )\n                 => CheckedDatabaseSettings be BeamMigrateDb\nbeamMigratableDb = runMigrationSilenced $ beamMigrateDbMigration @be @m\n\nbeamMigrateDb :: forall be m\n               . ( BeamMigrateSqlBackend be\n                 , HasDataTypeCreatedCheck (BeamMigrateSqlBackendDataTypeSyntax be)\n                 , MonadBeam be m )\n               => DatabaseSettings be BeamMigrateDb\nbeamMigrateDb = unCheckDatabase $ beamMigratableDb @be @m\n\nbeamMigrateDbMigration ::  forall be m\n                        . ( BeamMigrateSqlBackend be\n                          , HasDataTypeCreatedCheck (BeamMigrateSqlBackendDataTypeSyntax be)\n                          , MonadBeam be m )\n                       => Migration be (CheckedDatabaseSettings be BeamMigrateDb)\nbeamMigrateDbMigration =\n  BeamMigrateDb <$> createTable "beam_version"\n                      (BeamMigrateVersion (field "version" int notNull))\n                <*> createTable "beam_migration"\n                      (LogEntry (field "id" int notNull) (field "commitId" (varchar Nothing) notNull)\n                                (field "date" timestamp notNull))\n\nbeamMigrateSchemaVersion :: Int32\nbeamMigrateSchemaVersion = 1\n\ngetLatestLogEntry :: forall be m\n                   . ( BeamMigrateSqlBackend be\n                     , HasDataTypeCreatedCheck (BeamMigrateSqlBackendDataTypeSyntax be)\n                     , BeamSqlBackendCanDeserialize be Int32\n                     , BeamSqlBackendCanDeserialize be LocalTime\n                     , BeamSqlBackendSupportsDataType be Text\n                     , HasQBuilder be\n                     , MonadBeam be m )\n                  => m (Maybe LogEntry)\ngetLatestLogEntry =\n  runSelectReturningOne (select $\n                         limit_ 1 $\n                         orderBy_ (desc_ . _logEntryId) $\n                         all_ (_beamMigrateLogEntries (beamMigrateDb @be @m)))\n\n\nupdateSchemaToCurrent :: forall be m\n                       . ( BeamMigrateSqlBackend be\n                         , HasDataTypeCreatedCheck (BeamMigrateSqlBackendDataTypeSyntax be)\n                         , BeamSqlBackendCanSerialize be Text\n                         , MonadBeam be m )\n                      => m ()\nupdateSchemaToCurrent =\n  runInsert (insert (_beamMigrateVersionTbl (beamMigrateDb @be @m)) (insertValues [BeamMigrateVersion beamMigrateSchemaVersion]))\n\nrecordCommit :: forall be m\n             . ( BeamMigrateSqlBackend be\n               , HasDataTypeCreatedCheck (BeamMigrateSqlBackendDataTypeSyntax be)\n               , BeamSqlBackendSupportsDataType be Text\n               , BeamSqlBackendCanDeserialize be Int32\n               , BeamSqlBackendCanDeserialize be LocalTime\n               , HasQBuilder be\n               , MonadBeam be m )\n             => UUID -> m ()\nrecordCommit commitId = do\n  let commitIdTxt = fromString (show commitId)\n\n  logEntry <- getLatestLogEntry\n  let nextLogEntryId = maybe 0 (succ . _logEntryId) logEntry\n\n  runInsert (insert (_beamMigrateLogEntries (beamMigrateDb @be @m))\n                    (insertExpressions\n                     [ LogEntry (val_ nextLogEntryId)\n                                (val_ commitIdTxt)\n                                currentTimestamp_]))\n\n-- Ensure the backend tables exist\nensureBackendTables :: forall be m\n                     . (BeamSqlBackendCanSerialize be Text, Fail.MonadFail m)\n                    => BeamMigrationBackend be m\n                    -> m ()\nensureBackendTables be@BeamMigrationBackend { backendGetDbConstraints = getCs } =\n  do backendSchemaBuilt <- checkForBackendTables be\n     if backendSchemaBuilt\n       then continueMigrate\n       else createSchema\n\n  where\n    doStep cmd = runNoReturn cmd\n\n    continueMigrate = do\n      maxVersion <-\n        runSelectReturningOne $ select $\n        aggregate_ (\\v -> max_ (_beamMigrateVersion v)) $\n        all_ (_beamMigrateVersionTbl (beamMigrateDb @be @m))\n\n      case maxVersion of\n        Nothing -> cleanAndCreateSchema\n        Just Nothing -> cleanAndCreateSchema\n        Just (Just maxVersion\')\n          | maxVersion\' > beamMigrateSchemaVersion ->\n              fail "This database is being managed by a newer version of beam-migrate"\n          | maxVersion\' < beamMigrateSchemaVersion ->\n              fail "This database is being managed by an older version of beam-migrate, but there are no older versions"\n          | otherwise -> pure ()\n\n    cleanAndCreateSchema = do\n      cs <- getCs\n      let migrationLogExists = any (== p (TableExistsPredicate (QualifiedName Nothing "beam_migration"))) cs\n\n      when migrationLogExists $ do\n        totalCnt <-\n          fmap (fromMaybe 0) $ -- Should never return \'Nothing\', but this prevents an irrefutable pattern match\n          runSelectReturningOne $ select $\n          aggregate_ (\\_ -> as_ @Int32 countAll_) $\n          all_ (_beamMigrateLogEntries (beamMigrateDb @be @m))\n        when (totalCnt > 0) (fail "beam-migrate: No versioning information, but log entries present")\n        runNoReturn (dropTableCmd (dropTableSyntax (tableName Nothing "beam_migration")))\n\n      runNoReturn (dropTableCmd (dropTableSyntax (tableName Nothing "beam_version")))\n\n      createSchema\n\n    createSchema = do\n      _ <- executeMigration doStep (beamMigrateDbMigration @be @m)\n      updateSchemaToCurrent\n\ncheckForBackendTables :: BeamMigrationBackend be m -> m Bool\ncheckForBackendTables BeamMigrationBackend { backendGetDbConstraints = getCs } =\n  do cs <- getCs\n     pure (any (== p (TableExistsPredicate (QualifiedName Nothing "beam_version"))) cs)\n'