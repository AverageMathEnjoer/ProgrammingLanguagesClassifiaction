b'module Main\r\nwhere\r\n\r\nimport Data.List\r\nimport Data.Array\r\nimport System.IO\r\nimport System.Environment   \r\n\r\ntransform :: Ord a => [a] -> ([a], Int)\r\ntransform xs = (map last xss, position xs xss)\r\n  where\r\n    xss = sort (rots xs)\r\n\r\nposition xs xss = length (takeWhile (/= xs) xss)\r\n\r\nrots :: [a] -> [[a]]\r\nrots xs = take (length xs) (iterate lrot xs)\r\n  where\r\n    lrot (x:xs) = xs ++ [x]\r\n\r\ntakeCols :: Int -> [[a]] -> [[a]]\r\ntakeCols j = map (take j)\r\n\r\nrecreate :: Ord a => Int -> [a] -> [[a]]\r\nrecreate 0 = map (const [])\r\nrecreate j = hdsort . consCol . fork (id, recreate (j - 1))\r\n\r\nrrot :: [a] -> [a]\r\nrrot xs = [last xs] ++ init xs\r\n\r\nhdsort :: Ord a => [[a]] -> [[a]]\r\nhdsort = sortBy cmp\r\n  where\r\n    cmp (x:xs) (y:ys) = compare x y\r\n\r\nconsCol :: ([a], [[a]]) -> [[a]]\r\nconsCol (xs, xss) = zipWith (:) xs xss\r\n\r\nfork :: (a -> b, a -> c) -> a -> (b, c)\r\nfork (f, g) x = (f x, g x)\r\n\r\n-- Note: in the book, it doesn\'t mention that the first argument to the first\r\n-- call of `recreate` needs to be the length of the transformed string.\r\nuntransform :: Ord a => ([a], Int) -> [a]\r\nuntransform (ys, k) = (recreate (length ys) ys) !! k\r\n\r\nt = transform "Now is the time for all good men to come to the aid of their party."\r\nu = untransform t\r\n\r\nsort\' ys = apply q ys\r\n  where\r\n    q = p ys\r\n\r\np :: Ord a => [a] -> [Int]\r\np ys = map snd (sort (zip ys [0 .. n - 1]))\r\n  where\r\n    n = length ys\r\n\r\napply :: [Int] -> [a] -> [a]\r\napply p xs = [xs !! (p !! i ) | i <- [0 .. n - 1]]\r\n  where\r\n    n = length xs\r\n\r\nrecreate\' :: Ord a => Int -> [a] -> [[a]]\r\nrecreate\' 0 ys = map (const []) ys\r\nrecreate\' j ys = (consCol . fork (apply q, apply q . (recreate\' (j - 1)))) ys\r\n  where\r\n    q = p ys\r\n\r\nuntransform\' :: Ord a => ([a], Int) -> [a]\r\nuntransform\' (ys, k) = (recreate\' (length ys) ys) !! k\r\n\r\nrecreate\'\' j ys = (transpose . (take j) . tail . iterate (apply q) ) ys\r\n  where\r\n    q = p ys\r\n\r\nuntransform\'\' :: Ord a => ([a], Int) -> [a]\r\nuntransform\'\' (ys, k) = (recreate\'\' (length ys) ys) !! k\r\n\r\nuntransform\'\'\' (ys, k) = take n (tail (map (ya!) (iterate (pa!) k)))\r\n  where\r\n    n = length ys\r\n    ya = listArray (0, n - 1) ys\r\n    pa = listArray (0, n - 1) (map snd (sort (zip ys [0 .. ])))\r\n\r\n-- Note: because of the use of \'\\0\', the type\r\n-- of this function is restricted to character arrays only.\r\n-- In GHCI:\r\n--      :t transform\'\r\n--      transform\' :: [Char] -> ([Char], Int)\r\ntransform\' xs = ([xa!(pa!i) | i <- [0 .. n - 1]], k)\r\n  where\r\n    n = length xs\r\n    tag xs = xs ++ [\'\\0\']\r\n    k = length (takeWhile (/= 0) ps)\r\n    xa = listArray (0, n - 1) (rrot xs)\r\n    pa = listArray (0, n - 1) ps\r\n    ps = map snd (sort (zip (tails (tag xs))[0 .. n - 1]))\r\n\r\n\r\nmain = do\r\n    args <- getArgs  \r\n    handle <- openFile (args!!1) ReadMode\r\n    contents <- hGetContents handle\r\n    let result = (case args!!0) of\r\n                    "1" -> untransform\r\n                    "2" -> untransform\'\r\n                    "3" -> untransform\'\'\r\n                    "4" -> untransform\'\'\'\r\n                    _   -> undefined) $ transform contents\r\n    putStrLn $ show $ length result\r\n\r\n'