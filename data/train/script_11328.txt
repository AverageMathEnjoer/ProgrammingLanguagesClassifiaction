b'module GameUtils where\n\nimport qualified Text.Parsec as P\nimport qualified Text.Parsec.Language as P\nimport qualified Text.Parsec.Token as P\nimport qualified Data.Map as M\nimport Data.List\n\nimport GameModel\n\neitherToJust :: Either a b -> Maybe b\neitherToJust = either (const Nothing) Just\n\nparseNumber :: String -> Maybe Int\nparseNumber nStr = fmap fromIntegral $\n  eitherToJust $ P.parse (P.decimal P.haskell) "" nStr\n\nneighbouringOrdinates :: Game -> Int -> [Int]\nneighbouringOrdinates (Game { gameGridSize = gridSize }) v =\n  if v == 0 then\n    [v, v + 1]\n  else if v == gridSize - 1 then\n    [v - 1, v]\n  else\n    [v - 1, v, v + 1]\n\nneighboursOfPlusSelf :: Game -> Coord -> [Coord]\nneighboursOfPlusSelf game (Coord x y) =\n    [Coord xNeigh yNeigh | xNeigh <- xNeighbours, yNeigh <- yNeighbours]\n  where\n    xNeighbours = neighbouringOrdinates game x\n    yNeighbours = neighbouringOrdinates game y\n\nneighboursOf :: Game -> Coord -> [Coord]\nneighboursOf g c = filter (\\c\' -> c\' /= c) $ neighboursOfPlusSelf g c\n\ngameToMineCounts :: Game -> M.Map Coord Int\ngameToMineCounts g@(Game _ status) =\n    M.mapWithKey countForMine nonMines\n  where\n    nonMines = M.filter (\\(CellStatus _ s) -> s == CellNotMine) status\n    isMine coord = case M.lookup coord status of\n      Just (CellStatus _ CellMine) -> True\n      _ -> False\n    countForMine coord _ = length $ filter isMine $ neighboursOf g coord\n\n-- If the are any known cells with no mine neighbours, auto-expose their neighbours\n-- to follow the standard minesweeper rule...\nexpandNotMinesWithoutNeighbours :: Game -> M.Map Coord Int -> Game\nexpandNotMinesWithoutNeighbours g mineCounts =\n    case unknownNeighboursOfZeroCandidates of\n      [] -> g\n      _ -> expandNotMinesWithoutNeighbours newGame mineCounts\n  where\n    coordsWithZeroCount = M.keys . M.filter (\\x -> x == 0) $ mineCounts\n    isKnown coord = case M.lookup coord (gameStatus g) of\n      Just (CellStatus CellKnown _) -> True\n      _ -> False\n    knownZeroCandidates = filter isKnown coordsWithZeroCount\n    unknownNeighboursOfZeroCandidates = concatMap\n      (\\coord -> filter (not . isKnown) $ neighboursOf g coord) knownZeroCandidates\n    expandOneMine status coord =\n      M.insert coord (CellStatus CellKnown CellNotMine) status\n    newGame :: Game\n    newGame = g { gameStatus =\n                  foldl\' expandOneMine (gameStatus g) unknownNeighboursOfZeroCandidates\n                }\n'