b'#\' stringSubset\n#\'\n#\' Removes as candidate matches any observations with no close matches on\n#\' string-distance measures.\n#\'\n#\' @usage stringSubset(vecA, vecB, similarity.threshold, stringdist.method,\n#\' jw.weight, n.cores)\n#\' @param vecA A character or factor vector from dataset A\n#\' @param vecB A character or factor vector from dataset B\n#\' @param similarity.threshold Lower bound on string-distance measure for being considered a possible match.\n#\' If an observation has no possible matches above this threshold, it is discarded from the match. Default is 0.8.\n#\' @param stringdist.method The method to use for calculating string-distance similarity. Possible values are\n#\' \'jaro\' (Jaro Distance), \'jw\' (Jaro-Winkler), and \'lv\' (Levenshtein). Default is \'jw\'.\n#\' @param jw.weight Parameter that describes the importance of the first characters of a string (only needed if stringdist.method = "jw"). Default is .10.\n#\' @param n.cores Number of cores to parallelize over. Default is NULL.\n#\'\n#\' @return A list of length two, where the both entries are a vector of indices to be included in the match from dataset A (entry 1) and dataset B (entry 2). \n#\'\n#\' @examples\n#\' \\dontrun{\n#\' subset_out <- stringSubset(dfA$firstname, dfB$lastname, n.cores = 1)\n#\' fl_out <- fastLink(dfA[subset_out$dfA.block == 1,], dfB[subset_out$dfB.block == 1,],\n#\' varnames = c("firstname", "lastname", "streetname", "birthyear"), n.cores = 1)\n#\' }\n#\' @export\nstringSubset <- function(vecA, vecB,\n                         similarity.threshold = .8, stringdist.method = "jw",\n                         jw.weight = .10, n.cores = NULL){\n\n    if(class(vecA) == "factor"){\n        vecA <- as.character(vecA)\n    }\n    if(class(vecB) == "factor"){\n        vecB <- as.character(vecB)\n    }\n    if(class(vecA) != "character" | class(vecB) != "character"){\n        stop("vecA and vecB must be of class factor or character.")\n    }\n    if(!(stringdist.method %in% c("jw", "jaro", "lv"))){\n        stop("Invalid string distance method. Method should be one of \'jw\', \'jaro\', or \'lv\'.")\n    }\n    if(similarity.threshold < 0 | similarity.threshold > 1){\n        stop("similarity.threshold must be between 0 and 1.")\n    }\n    if(stringdist.method == "jw" & !is.null(jw.weight)){\n        if(jw.weight < 0 | jw.weight > 0.25){\n            stop("Invalid value provided for jw.weight. Remember, jw.weight in [0, 0.25].")\n        }\n    }\n    \n    ## Remove any very unlikely matches by first name\n    gamma.out <- gammaCK2par(vecA, vecB, cut.a = similarity.threshold, method = stringdist.method, n.cores = n.cores)\n    gamma.sub <- do.call(Map, c(c, gamma.out[[1]]))\n\n    ## Get the voter file ids\n    ids.A <- unique(gamma.sub[[1]])\n    ids.B <- unique(gamma.sub[[2]])\n    out <- list(dfA.inds = ids.A[order(ids.A)], dfB.inds = ids.B[order(ids.B)])\n    class(out) <- "fastLink.block"\n    \n    return(out)\n    \n}\n\n#\' blockData\n#\'\n#\' Contains functionalities for blocking two data sets on one or more variables prior to\n#\' conducting a merge.\n#\'\n#\' @usage blockData(dfA, dfB, varnames, window.block, window.size,\n#\' kmeans.block, nclusters, iter.max, n.cores)\n#\' @param dfA Dataset A - to be matched to Dataset B\n#\' @param dfB Dataset B - to be matched to Dataset A\n#\' @param varnames A vector of variable names to use for blocking.\n#\' Must be present in both dfA and dfB\n#\' @param window.block A vector of variable names indicating that the variable should be\n#\' blocked using windowing blocking. Must be present in varnames.\n#\' @param window.size The size of the window for window blocking. Default is 1\n#\' (observations +/- 1 on the specified variable will be blocked together).\n#\' @param kmeans.block A vector of variable names indicating that the variable should be\n#\' blocked using k-means blocking. Must be present in varnames.\n#\' @param nclusters Number of clusters to create with k-means. Default value is the\n#\' number of clusters where the average cluster size is 100,000 observations.\n#\' @param iter.max Maximum number of iterations for the k-means algorithm to run. Default is 5000\n#\' @param n.cores Number of cores to parallelize over. Default is NULL.\n#\'\n#\' @return A list with an entry for each block. Each list entry contains two vectors --- one with the indices indicating the block members in dataset A,\n#\' and another containing the indices indicating the block members in dataset B.\n#\'\n#\' @examples\n#\' \\dontrun{\n#\' block_out <- blockData(dfA, dfB, varnames = c("city", "birthyear"))\n#\' }\n#\'\n#\' @export\nblockData <- function(dfA, dfB, varnames, window.block = NULL,\n                      window.size = 1,\n                      kmeans.block = NULL,\n                      nclusters = max(round(min(nrow(dfA), nrow(dfB)) / 100000, 0), 1),                      \n                      iter.max = 5000,\n                      n.cores = NULL){\n\n    cat("\\n")\n    cat(c(paste(rep("=", 20), sep = "", collapse = ""), "\\n"))\n    cat("blockData(): Blocking Methods for Record Linkage\\n")\n    cat(c(paste(rep("=", 20), sep = "", collapse = ""), "\\n\\n"))\n    \n    ## ---------------------------\n    ## Clean data and check inputs\n    ## ---------------------------\n    if(any(class(dfA) %in% c("tbl_df", "data.table"))){\n        dfA <- as.data.frame(dfA)\n    }\n    if(any(class(dfB) %in% c("tbl_df", "data.table"))){\n        dfB <- as.data.frame(dfB)\n    }\n    if(any(!(varnames %in% names(dfA)))){\n        stop("Some variables in varnames are not present in dfA.")\n    }\n    if(any(!(varnames %in% names(dfB)))){\n        stop("Some variables in varnames are not present in dfB.")\n    }\n    if(any(!(window.block %in% varnames))){\n        stop("You have provided a variable name for window.block that is not in \'varnames\'.")\n    }\n    if(any(!(kmeans.block %in% varnames))){\n        stop("You have provided a variable name for kmeans.block that is not in \'varnames\'.")\n    }\n    classA <- lapply(dfA[,varnames], class)\n    classB <- lapply(dfB[,varnames], class)\n    if(any(unlist(classA)[names(classA) %in% window.block] != "numeric") |\n       any(unlist(classB)[names(classB) %in% window.block] != "numeric")){\n        stop("You have specified that a variable be blocked using window blocking, but that variable is not of class \'numeric\'. Please check your variable classes.")\n    }\n    if(is.null(n.cores)){\n        n.cores <- detectCores() - 1\n    }\n    \n    \n    ## ----------\n    ## Block data\n    ## ----------\n    cat("Blocking variables.\\n")\n    gammalist <- vector(mode = "list", length = length(varnames))\n    for(i in 1:length(varnames)){\n        blocktype <- ifelse(varnames[i] %in% window.block, "window", ifelse(varnames[i] %in% kmeans.block, "k-means", "exact"))\n        cat("    Blocking variable", varnames[i], "using", blocktype, "blocking.\\n")\n        if(varnames[i] %in% window.block){\n            gammalist[[i]] <- gammaNUMCK2par(dfA[,varnames[i]], dfB[,varnames[i]], n.cores = n.cores, cut.a = window.size)\n        }else if(varnames[i] %in% kmeans.block){\n            gammalist[[i]] <- kmeansBlock(dfA[,varnames[i]], dfB[,varnames[i]],\n                                          nclusters = nclusters,\n                                          iter.max = iter.max,\n                                          n.cores = n.cores)\n        }else{\n            gammalist[[i]] <- gammaKpar(dfA[,varnames[i]], dfB[,varnames[i]], gender = FALSE, n.cores = n.cores)\n        }\n    }\n    cat("\\n")\n    \n    ## --------------\n    ## Combine blocks\n    ## --------------\n    cat("Combining blocked variables for final blocking assignments.\\n\\n")\n    combineblocks_out <- combineBlocks(gammalist)\n    indlist_a <- apply(combineblocks_out$dfA.block, 2, function(x){which(x == 1)})\n    indlist_a <- indlist_a[lapply(indlist_a, length) > 0]\n    indlist_b <- apply(combineblocks_out$dfB.block, 2, function(x){which(x == 1)})\n    indlist_b <- indlist_b[lapply(indlist_b, length) > 0]\n    \n    ## Clean up\n    blocklist_out <- vector(mode = "list", length = length(indlist_a))\n    for(i in 1:length(blocklist_out)){\n        blocklist_out[[i]] <- list(dfA.inds = indlist_a[[i]], dfB.inds = indlist_b[[i]])\n    }\n    names(blocklist_out) <- paste0("block.", 1:length(blocklist_out))\n    class(blocklist_out) <- "fastLink.block"\n    return(blocklist_out)\n    \n}\n\ncombineBlocks <- function(blocklist){\n    \n    blkgrps <- NULL\n    \n    ## Unpack\n    str <- ""\n    for(i in 1:length(blocklist)){\n        str <- paste0(str, "block.", i, "=1:", length(blocklist[[i]][[1]]), ",")\n    }\n    str <- paste0("blkgrps <- expand.grid(", str, "stringsAsFactors = FALSE)")\n    eval(parse(text = str))\n    \n    ## Get indices for each block\n    indsA_out <- vector(mode = "list", length = nrow(blkgrps))\n    indsB_out <- vector(mode = "list", length = nrow(blkgrps))\n    for(i in 1:nrow(blkgrps)){\n        \n        indsA <- vector(mode = "list", length = ncol(blkgrps))\n        indsB <- vector(mode = "list", length = ncol(blkgrps))\n        for(j in 1:ncol(blkgrps)){\n            indsA[[j]] <- blocklist[[j]][[1]][[blkgrps[i,j]]][[1]]\n            indsB[[j]] <- blocklist[[j]][[1]][[blkgrps[i,j]]][[2]]\n        }\n        indsA_intersect <- Reduce(intersect, indsA)\n        indsB_intersect <- Reduce(intersect, indsB)\n        if(length(indsA_intersect) > 0 & length(indsB_intersect) > 0){\n            indsA_out[[i]] <- cbind(indsA_intersect, i)\n            indsB_out[[i]] <- cbind(indsB_intersect, i)\n        }\n        \n    }\n    \n    ## Combine indices and create sparse matrix outputs\n    indsA_out <- do.call(rbind, indsA_out)\n    indsB_out <- do.call(rbind, indsB_out)\n    matA_out <- sparseMatrix(i = indsA_out[,1], j = indsA_out[,2])\n    matB_out <- sparseMatrix(i = indsB_out[,1], j = indsB_out[,2])\n    \n    out <- list(dfA.block = matA_out, dfB.block = matB_out)\n    class(out) <- "fastLink.block"\n    return(out)\n    \n}\n\nkmeansBlock <- function(vecA, vecB, nclusters, iter.max, n.cores){\n    \n    if(class(vecA) == "factor"){\n        vecA <- as.character(vecA)\n    }\n    if(class(vecB) == "factor"){\n        vecB <- as.character(vecB)\n    }\n    \n    ## Clean and combine\n    vec <- c(vecA, vecB)\n    setid <- c(rep("A", length(vecA)), rep("B", length(vecB)))\n    dims <- as.numeric(as.factor(vec))\n    \n    ## Run kmeans\n    km.out <- kmeans(na.omit(dims), centers = nclusters, iter.max = iter.max)\n    cluster <- rep(NA, length(vec))\n    cluster[which(!is.na(vec))] <- km.out$cluster\n    \n    ## Run gammaKpar\n    out <- gammaKpar(cluster[setid == "A"], cluster[setid == "B"], gender = FALSE, n.cores = n.cores)\n    return(out)\n    \n}\n'