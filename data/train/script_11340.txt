b'{-# OPTIONS_GHC -fno-warn-orphans -fno-warn-partial-type-signatures #-}\n\n{-# LANGUAGE PartialTypeSignatures #-}\n{-# LANGUAGE LambdaCase #-}\n{-# LANGUAGE ConstraintKinds #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{-# LANGUAGE DeriveFunctor #-}\n{-# LANGUAGE StandaloneDeriving #-}\n{-# LANGUAGE GADTs #-}\n{-# LANGUAGE FlexibleContexts #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE OverloadedStrings #-}\n{-# LANGUAGE CPP #-}\n\nmodule Database.Beam.Postgres.Connection\n  ( Pg(..), PgF(..)\n\n  , liftIOWithHandle\n\n  , runBeamPostgres, runBeamPostgresDebug\n\n  , pgRenderSyntax, runPgRowReader, getFields\n\n  , withPgDebug\n\n  , postgresUriSyntax ) where\n\nimport           Control.Exception (SomeException(..), throwIO)\nimport           Control.Monad.Base (MonadBase(..))\nimport           Control.Monad.Free.Church\nimport           Control.Monad.IO.Class\nimport           Control.Monad.Trans.Control (MonadBaseControl(..))\n\nimport           Database.Beam hiding (runDelete, runUpdate, runInsert, insert)\nimport           Database.Beam.Backend.SQL.BeamExtensions\nimport           Database.Beam.Backend.SQL.Row ( FromBackendRowF(..), FromBackendRowM(..)\n                                               , BeamRowReadError(..), ColumnParseError(..) )\nimport           Database.Beam.Backend.URI\nimport           Database.Beam.Schema.Tables\n\nimport           Database.Beam.Postgres.Syntax\nimport           Database.Beam.Postgres.Full\nimport           Database.Beam.Postgres.Types\n\nimport qualified Database.PostgreSQL.LibPQ as Pg hiding\n  (Connection, escapeStringConn, escapeIdentifier, escapeByteaConn, exec)\nimport qualified Database.PostgreSQL.Simple as Pg\nimport qualified Database.PostgreSQL.Simple.FromField as Pg\nimport qualified Database.PostgreSQL.Simple.Internal as Pg\n  ( Field(..), RowParser(..)\n  , escapeStringConn, escapeIdentifier, escapeByteaConn\n  , exec, throwResultError )\nimport qualified Database.PostgreSQL.Simple.Internal as PgI\nimport qualified Database.PostgreSQL.Simple.Ok as Pg\nimport qualified Database.PostgreSQL.Simple.Types as Pg (Query(..))\n\nimport           Control.Monad.Reader\nimport           Control.Monad.State\nimport qualified Control.Monad.Fail as Fail\n\nimport           Data.ByteString (ByteString)\nimport           Data.ByteString.Builder (toLazyByteString, byteString)\nimport qualified Data.ByteString.Lazy as BL\nimport           Data.Maybe (listToMaybe, fromMaybe)\nimport           Data.Proxy\nimport           Data.String\nimport qualified Data.Text as T\nimport           Data.Text.Encoding (decodeUtf8)\nimport           Data.Typeable (cast)\n#if !MIN_VERSION_base(4, 11, 0)\nimport           Data.Semigroup\n#endif\n\nimport           Foreign.C.Types\n\nimport           Network.URI (uriToString)\n\ndata PgStream a = PgStreamDone     (Either BeamRowReadError a)\n                | PgStreamContinue (Maybe PgI.Row -> IO (PgStream a))\n\n-- | \'BeamURIOpeners\' for the standard @postgresql:@ URI scheme. See the\n-- postgres documentation for more details on the formatting. See documentation\n-- for \'BeamURIOpeners\' for more information on how to use this with beam\npostgresUriSyntax :: c Postgres Pg.Connection Pg\n                  -> BeamURIOpeners c\npostgresUriSyntax =\n    mkUriOpener runBeamPostgres "postgresql:"\n        (\\uri -> do\n            let pgConnStr = fromString (uriToString id uri "")\n            hdl <- Pg.connectPostgreSQL pgConnStr\n            pure (hdl, Pg.close hdl))\n\n-- * Syntax rendering\n\npgRenderSyntax ::\n  Pg.Connection -> PgSyntax -> IO ByteString\npgRenderSyntax conn (PgSyntax mkQuery) =\n  renderBuilder <$> runF mkQuery finish step mempty\n  where\n    renderBuilder = BL.toStrict . toLazyByteString\n\n    step (EmitBuilder b next) a = next (a <> b)\n    step (EmitByteString b next) a = next (a <> byteString b)\n    step (EscapeString b next) a = do\n      res <- wrapError "EscapeString" (Pg.escapeStringConn conn b)\n      next (a <> byteString res)\n    step (EscapeBytea b next) a = do\n      res <- wrapError "EscapeBytea" (Pg.escapeByteaConn conn b)\n      next (a <> byteString res)\n    step (EscapeIdentifier b next) a = do\n      res <- wrapError "EscapeIdentifier" (Pg.escapeIdentifier conn b)\n      next (a <> byteString res)\n\n    finish _ = pure\n\n    wrapError step\' go = do\n      res <- go\n      case res of\n        Right res\' -> pure res\'\n        Left res\' -> fail (step\' <> ": " <> show res\')\n\n-- * Run row readers\n\ngetFields :: Pg.Result -> IO [Pg.Field]\ngetFields res = do\n  Pg.Col colCount <- Pg.nfields res\n\n  let getField col =\n        Pg.Field res (Pg.Col col) <$> Pg.ftype res (Pg.Col col)\n\n  mapM getField [0..colCount - 1]\n\nrunPgRowReader ::\n  Pg.Connection -> Pg.Row -> Pg.Result -> [Pg.Field] -> FromBackendRowM Postgres a -> IO (Either BeamRowReadError a)\nrunPgRowReader conn rowIdx res fields (FromBackendRowM readRow) =\n  Pg.nfields res >>= \\(Pg.Col colCount) ->\n  runF readRow finish step 0 colCount fields\n  where\n\n    step :: forall x. FromBackendRowF Postgres (CInt -> CInt -> [PgI.Field] -> IO (Either BeamRowReadError x))\n         -> CInt -> CInt -> [PgI.Field] -> IO (Either BeamRowReadError x)\n    step (ParseOneField _) curCol colCount [] = pure (Left (BeamRowReadError (Just (fromIntegral curCol)) (ColumnNotEnoughColumns (fromIntegral colCount))))\n    step (ParseOneField _) curCol colCount _\n      | curCol >= colCount = pure (Left (BeamRowReadError (Just (fromIntegral curCol)) (ColumnNotEnoughColumns (fromIntegral colCount))))\n    step (ParseOneField (next\' :: next -> _)) curCol colCount (field:remainingFields) =\n      do fieldValue <- Pg.getvalue\' res rowIdx (Pg.Col curCol)\n         res\' <- Pg.runConversion (Pg.fromField field fieldValue) conn\n         case res\' of\n           Pg.Errors errs ->\n             let err = fromMaybe (ColumnErrorInternal "Column parse failed with unknown exception") $\n                       listToMaybe $\n                       do SomeException e <- errs\n                          Just pgErr <- pure (cast e)\n                          case pgErr of\n                            Pg.ConversionFailed { Pg.errSQLType = sql\n                                                , Pg.errHaskellType = hs\n                                                , Pg.errMessage = msg } ->\n                              pure (ColumnTypeMismatch hs sql msg)\n                            Pg.Incompatible { Pg.errSQLType = sql\n                                            , Pg.errHaskellType = hs\n                                            , Pg.errMessage = msg } ->\n                              pure (ColumnTypeMismatch hs sql msg)\n                            Pg.UnexpectedNull {} ->\n                              pure ColumnUnexpectedNull\n             in pure (Left (BeamRowReadError (Just (fromIntegral curCol)) err))\n           Pg.Ok x -> next\' x (curCol + 1) colCount remainingFields\n\n    step (Alt (FromBackendRowM a) (FromBackendRowM b) next) curCol colCount cols =\n      do aRes <- runF a (\\x curCol\' colCount\' cols\' -> pure (Right (next x curCol\' colCount\' cols\'))) step curCol colCount cols\n         case aRes of\n           Right next\' -> next\'\n           Left aErr -> do\n             bRes <- runF b (\\x curCol\' colCount\' cols\' -> pure (Right (next x curCol\' colCount\' cols\'))) step curCol colCount cols\n             case bRes of\n               Right next\' -> next\'\n               Left {} -> pure (Left aErr)\n\n    step (FailParseWith err) _ _ _ =\n      pure (Left err)\n\n    finish x _ _ _ = pure (Right x)\n\nwithPgDebug :: (String -> IO ()) -> Pg.Connection -> Pg a -> IO (Either BeamRowReadError a)\nwithPgDebug dbg conn (Pg action) =\n  let finish x = pure (Right x)\n      step (PgLiftIO io next) = io >>= next\n      step (PgLiftWithHandle withConn next) = withConn dbg conn >>= next\n      step (PgFetchNext next) = next Nothing\n      step (PgRunReturning CursorBatching\n                           (PgCommandSyntax PgCommandTypeQuery syntax)\n                           (mkProcess :: Pg (Maybe x) -> Pg a\')\n                           next) =\n        do query <- pgRenderSyntax conn syntax\n           let Pg process = mkProcess (Pg (liftF (PgFetchNext id)))\n           dbg (T.unpack (decodeUtf8 query))\n           action\' <- runF process finishProcess stepProcess Nothing\n           case action\' of\n             PgStreamDone (Right x) -> Pg.execute_ conn (Pg.Query query) >> next x\n             PgStreamDone (Left err) -> pure (Left err)\n             PgStreamContinue nextStream ->\n               let finishUp (PgStreamDone (Right x)) = next x\n                   finishUp (PgStreamDone (Left err)) = pure (Left err)\n                   finishUp (PgStreamContinue next\') = next\' Nothing >>= finishUp\n\n                   columnCount = fromIntegral $ valuesNeeded (Proxy @Postgres) (Proxy @x)\n               in Pg.foldWith_ (Pg.RP (put columnCount >> ask)) conn (Pg.Query query) (PgStreamContinue nextStream) runConsumer >>= finishUp\n      step (PgRunReturning AtOnce\n                           (PgCommandSyntax PgCommandTypeQuery syntax)\n                           (mkProcess :: Pg (Maybe x) -> Pg a\')\n                           next) =\n        renderExecReturningList "No tuples returned to Postgres query" syntax mkProcess next\n      step (PgRunReturning _ (PgCommandSyntax PgCommandTypeDataUpdateReturning syntax) mkProcess next) =\n        renderExecReturningList "No tuples returned to Postgres update/insert returning" syntax mkProcess next\n      step (PgRunReturning _ (PgCommandSyntax _ syntax) mkProcess next) =\n        do query <- pgRenderSyntax conn syntax\n           dbg (T.unpack (decodeUtf8 query))\n           _ <- Pg.execute_ conn (Pg.Query query)\n\n           let Pg process = mkProcess (Pg (liftF (PgFetchNext id)))\n           runF process next stepReturningNone\n\n      renderExecReturningList :: (FromBackendRow Postgres x) => _ -> PgSyntax -> (Pg (Maybe x) -> Pg a\') -> _ -> _\n      renderExecReturningList errMsg syntax mkProcess next =\n        do query <- pgRenderSyntax conn syntax\n           dbg (T.unpack (decodeUtf8 query))\n\n           res <- Pg.exec conn query\n           sts <- Pg.resultStatus res\n           case sts of\n             Pg.TuplesOk -> do\n               let Pg process = mkProcess (Pg (liftF (PgFetchNext id)))\n               runF process (\\x _ -> Pg.unsafeFreeResult res >> next x) (stepReturningList res) 0\n             _ -> Pg.throwResultError errMsg res sts\n\n      stepReturningNone :: forall a. PgF (IO (Either BeamRowReadError a)) -> IO (Either BeamRowReadError a)\n      stepReturningNone (PgLiftIO action\' next) = action\' >>= next\n      stepReturningNone (PgLiftWithHandle withConn next) = withConn dbg conn >>= next\n      stepReturningNone (PgFetchNext next) = next Nothing\n      stepReturningNone (PgRunReturning {}) = pure (Left (BeamRowReadError Nothing (ColumnErrorInternal  "Nested queries not allowed")))\n\n      stepReturningList :: forall a. Pg.Result -> PgF (CInt -> IO (Either BeamRowReadError a)) -> CInt -> IO (Either BeamRowReadError a)\n      stepReturningList _   (PgLiftIO action\' next) rowIdx = action\' >>= \\x -> next x rowIdx\n      stepReturningList res (PgFetchNext next) rowIdx =\n        do fields <- getFields res\n           Pg.Row rowCount <- Pg.ntuples res\n           if rowIdx >= rowCount\n             then next Nothing rowIdx\n             else runPgRowReader conn (Pg.Row rowIdx) res fields fromBackendRow >>= \\case\n                    Left err -> pure (Left err)\n                    Right r -> next (Just r) (rowIdx + 1)\n      stepReturningList _   (PgRunReturning {}) _ = pure (Left (BeamRowReadError Nothing (ColumnErrorInternal "Nested queries not allowed")))\n      stepReturningList _   (PgLiftWithHandle {}) _ = pure (Left (BeamRowReadError Nothing (ColumnErrorInternal "Nested queries not allowed")))\n\n      finishProcess :: forall a. a -> Maybe PgI.Row -> IO (PgStream a)\n      finishProcess x _ = pure (PgStreamDone (Right x))\n\n      stepProcess :: forall a. PgF (Maybe PgI.Row -> IO (PgStream a)) -> Maybe PgI.Row -> IO (PgStream a)\n      stepProcess (PgLiftIO action\' next) row = action\' >>= flip next row\n      stepProcess (PgFetchNext next) Nothing =\n        pure . PgStreamContinue $ \\res ->\n        case res of\n          Nothing -> next Nothing Nothing\n          Just (PgI.Row rowIdx res\') ->\n            getFields res\' >>= \\fields ->\n            runPgRowReader conn rowIdx res\' fields fromBackendRow >>= \\case\n              Left err -> pure (PgStreamDone (Left err))\n              Right r -> next (Just r) Nothing\n      stepProcess (PgFetchNext next) (Just (PgI.Row rowIdx res)) =\n        getFields res >>= \\fields ->\n        runPgRowReader conn rowIdx res fields fromBackendRow >>= \\case\n          Left err -> pure (PgStreamDone (Left err))\n          Right r -> pure (PgStreamContinue (next (Just r)))\n      stepProcess (PgRunReturning {}) _ = pure (PgStreamDone (Left (BeamRowReadError Nothing (ColumnErrorInternal "Nested queries not allowed"))))\n      stepProcess (PgLiftWithHandle _ _) _ = pure (PgStreamDone (Left (BeamRowReadError Nothing (ColumnErrorInternal "Nested queries not allowed"))))\n\n      runConsumer :: forall a. PgStream a -> PgI.Row -> IO (PgStream a)\n      runConsumer s@(PgStreamDone {}) _ = pure s\n      runConsumer (PgStreamContinue next) row = next (Just row)\n  in runF action finish step\n\n-- * Beam Monad class\n\ndata PgF next where\n    PgLiftIO :: IO a -> (a -> next) -> PgF next\n    PgRunReturning ::\n        FromBackendRow Postgres x =>\n        FetchMode -> PgCommandSyntax -> (Pg (Maybe x) -> Pg a) -> (a -> next) -> PgF next\n    PgFetchNext ::\n        FromBackendRow Postgres x =>\n        (Maybe x -> next) -> PgF next\n    PgLiftWithHandle :: ((String -> IO ()) -> Pg.Connection -> IO a) -> (a -> next) -> PgF next\ninstance Functor PgF where\n  fmap f = \\case\n    PgLiftIO io n -> PgLiftIO io $ f . n\n    PgRunReturning mode cmd consume n -> PgRunReturning mode cmd consume $ f . n\n    PgFetchNext n -> PgFetchNext $ f . n\n    PgLiftWithHandle withConn n -> PgLiftWithHandle withConn $ f . n\n\n-- | How to fetch results.\ndata FetchMode\n    = CursorBatching -- ^ Fetch in batches of ~256 rows via cursor for SELECT.\n    | AtOnce         -- ^ Fetch all rows at once.\n\n-- | \'MonadBeam\' in which we can run Postgres commands. See the documentation\n-- for \'MonadBeam\' on examples of how to use.\n--\n-- @beam-postgres@ also provides functions that let you run queries without\n-- \'MonadBeam\'. These functions may be more efficient and offer a conduit\n-- API. See "Database.Beam.Postgres.Conduit" for more information.\nnewtype Pg a = Pg { runPg :: F PgF a }\n    deriving (Monad, Applicative, Functor, MonadFree PgF)\n\ninstance Fail.MonadFail Pg where\n    fail e =  liftIO (Fail.fail $ "Internal Error with: " <> show e)\n\ninstance MonadIO Pg where\n    liftIO x = liftF (PgLiftIO x id)\n\ninstance MonadBase IO Pg where\n    liftBase = liftIO\n\ninstance MonadBaseControl IO Pg where\n    type StM Pg a = a\n\n    liftBaseWith action =\n      liftF (PgLiftWithHandle (\\dbg conn -> action (runBeamPostgresDebug dbg conn)) id)\n\n    restoreM = pure\n\nliftIOWithHandle :: (Pg.Connection -> IO a) -> Pg a\nliftIOWithHandle f = liftF (PgLiftWithHandle (\\_ -> f) id)\n\nrunBeamPostgresDebug :: (String -> IO ()) -> Pg.Connection -> Pg a -> IO a\nrunBeamPostgresDebug dbg conn action =\n    withPgDebug dbg conn action >>= either throwIO pure\n\nrunBeamPostgres :: Pg.Connection -> Pg a -> IO a\nrunBeamPostgres = runBeamPostgresDebug (\\_ -> pure ())\n\ninstance MonadBeam Postgres Pg where\n    runReturningMany cmd consume =\n        liftF (PgRunReturning CursorBatching cmd consume id)\n\n    runReturningOne cmd =\n        liftF (PgRunReturning AtOnce cmd consume id)\n      where\n        consume next = do\n          a <- next\n          case a of\n            Nothing -> pure Nothing\n            Just x -> do\n              a\' <- next\n              case a\' of\n                Nothing -> pure (Just x)\n                Just _ -> pure Nothing\n\n    runReturningFirst cmd =\n        liftF (PgRunReturning AtOnce cmd id id)\n\n    runReturningList cmd =\n        liftF (PgRunReturning AtOnce cmd consume id)\n      where\n        consume next =\n          let collectM acc = do\n                a <- next\n                case a of\n                  Nothing -> pure (acc [])\n                  Just x -> collectM (acc . (x:))\n          in collectM id\n\ninstance MonadBeamInsertReturning Postgres Pg where\n    runInsertReturningList i = do\n        let insertReturningCmd\' = i `returning`\n              changeBeamRep (\\(Columnar\' (QExpr s) :: Columnar\' (QExpr Postgres PostgresInaccessible) ty) ->\n                Columnar\' (QExpr s) :: Columnar\' (QExpr Postgres ()) ty)\n\n        -- Make savepoint\n        case insertReturningCmd\' of\n          PgInsertReturningEmpty ->\n            pure []\n          PgInsertReturning insertReturningCmd ->\n            runReturningList (PgCommandSyntax PgCommandTypeDataUpdateReturning insertReturningCmd)\n\ninstance MonadBeamUpdateReturning Postgres Pg where\n    runUpdateReturningList u = do\n        let updateReturningCmd\' = u `returning`\n              changeBeamRep (\\(Columnar\' (QExpr s) :: Columnar\' (QExpr Postgres PostgresInaccessible) ty) ->\n                Columnar\' (QExpr s) :: Columnar\' (QExpr Postgres ()) ty)\n\n        case updateReturningCmd\' of\n          PgUpdateReturningEmpty ->\n            pure []\n          PgUpdateReturning updateReturningCmd ->\n            runReturningList (PgCommandSyntax PgCommandTypeDataUpdateReturning updateReturningCmd)\n\ninstance MonadBeamDeleteReturning Postgres Pg where\n    runDeleteReturningList d = do\n        let PgDeleteReturning deleteReturningCmd = d `returning`\n              changeBeamRep (\\(Columnar\' (QExpr s) :: Columnar\' (QExpr Postgres PostgresInaccessible) ty) ->\n                Columnar\' (QExpr s) :: Columnar\' (QExpr Postgres ()) ty)\n\n        runReturningList (PgCommandSyntax PgCommandTypeDataUpdateReturning deleteReturningCmd)\n'