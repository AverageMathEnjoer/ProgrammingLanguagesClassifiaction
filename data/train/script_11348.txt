b'{-# LANGUAGE\n    CPP\n  , ExistentialQuantification\n  , FlexibleContexts\n  , GADTs\n  , GeneralizedNewtypeDeriving\n  , NamedFieldPuns\n  , RankNTypes\n  , ScopedTypeVariables\n  , TupleSections\n  #-}\n#if MIN_VERSION_base(4,9,0)\n{-# OPTIONS_GHC -Wno-redundant-constraints #-}\n#endif\n\nmodule Rest.Driver.Routing.Internal where\n\nimport Prelude hiding (id, (.))\n\nimport Control.Applicative\nimport Control.Arrow\nimport Control.Category\nimport Control.Error.Util\nimport Control.Monad.Error.Class\nimport Control.Monad.Identity\nimport Control.Monad.Reader\nimport Control.Monad.State (MonadState, StateT, evalStateT)\nimport Control.Monad.Trans.Except\nimport Control.Monad.Trans.Maybe\nimport Data.List.Split\nimport Network.Multipart (BodyPart (..), HeaderName (..))\nimport Safe\nimport qualified Control.Monad.State       as State\nimport qualified Data.ByteString.Lazy.UTF8 as LUTF8\nimport qualified Data.HashMap.Strict       as H\nimport qualified Data.Label.Total          as L\n\nimport Network.URI.Encode (decode)\nimport Rest.Api (Some1 (..))\nimport Rest.Container\nimport Rest.Dictionary\nimport Rest.Error\nimport Rest.Handler (Env (..), GenHandler (..), Handler, ListHandler, Range (..), mkInputHandler, range)\nimport Rest.Types.Container.Resource (Resource, Resources (..))\nimport qualified Rest.Api                      as Rest\nimport qualified Rest.Resource                 as Rest\nimport qualified Rest.Schema                   as Rest\nimport qualified Rest.StringMap.HashMap.Strict as StringHashMap\nimport qualified Rest.Types.Container.Resource as R\n\nimport Rest.Driver.Perform (failureWriter, writeResponse)\nimport Rest.Driver.RestM (runRestM)\nimport Rest.Driver.Types\n\nimport qualified Rest.Driver.RestM as Rest\n\n{-# ANN module "HLint: ignore Reduce duplication" #-}\n\ntype UriParts = [String]\n\napiError :: (MonadError (Reason e) m) => Reason e -> m a\napiError = throwError\n\ndata RouterData m = RouterData { method :: Method, config :: Config m }\n\nnewtype Router m a =\n  Router { unRouter :: ReaderT (RouterData m) (StateT UriParts (ExceptT Reason_ Identity)) a }\n  deriving ( Functor\n           , Applicative\n           , Monad\n           , MonadReader (RouterData m)\n           , MonadState UriParts\n           , MonadError Reason_\n           )\n\nrunRouter :: Config m -> Method -> UriParts -> Router m (RunnableHandler m) -> Either Reason_ (RunnableHandler m)\nrunRouter cfg mtd uri = runIdentity\n                      . runExceptT\n                      . flip evalStateT uri\n                      . flip runReaderT (RouterData mtd cfg)\n                      . unRouter\n\nroute :: (Applicative m, Monad m) => Maybe Method -> UriParts -> Rest.Api m -> Either Reason_ (RunnableHandler m)\nroute = routeWith defaultConfig\n\nrouteWith :: Config m -> Maybe Method -> UriParts -> Rest.Api m -> Either Reason_ (RunnableHandler m)\nrouteWith _    Nothing   _   _   = apiError UnsupportedMethod\nrouteWith cfg (Just mtd) uri api = runRouter cfg mtd uri $\n  case api of\n    Rest.Unversioned (Some1 router) -> routeRoot router\n    Rest.Versioned   vrs            -> do\n      versionStr <- popSegment\n      case versionStr `Rest.lookupVersion` vrs of\n          Just (Some1 router) -> routeRoot router\n          _                   -> apiError UnsupportedVersion\n\nrouteRoot :: Rest.Router m s -> Router m (RunnableHandler m)\nrouteRoot router@(Rest.Embed resource _) = do\n  routeName (Rest.name resource)\n  fromMaybeT (routeRouter router) (routeMultiGet router)\n\nrouteMultiGet :: Rest.Router m s -> MaybeT (Router m) (RunnableHandler m)\nrouteMultiGet root@(Rest.Embed Rest.Resource{} _) =\n  do guardNullPath\n     guardMethod POST\n     cfg <- asks config\n     return (RunnableHandler id (mkMultiGetHandler cfg root))\n\nrouteRouter :: Rest.Router m s -> Router n (RunnableHandler m)\nrouteRouter (Rest.Embed resource@Rest.Resource { Rest.schema } subRouters) =\n  case schema of\n    (Rest.Schema mToplevel step) -> maybe (apiError UnsupportedRoute) return =<< runMaybeT\n       (  routeToplevel resource subRouters mToplevel\n      <|> routeCreate resource\n      <|> lift (routeStep resource subRouters step)\n       )\n\nrouteToplevel :: Rest.Resource m s sid mid aid\n              -> [Some1 (Rest.Router s)]\n              -> Maybe (Rest.Cardinality sid mid)\n              -> MaybeT (Router n) (RunnableHandler m)\nrouteToplevel resource@Rest.Resource { Rest.list } subRouters mToplevel =\n  hoistMaybe mToplevel >>= \\toplevel ->\n  case toplevel of\n    Rest.Single sid -> lift $ withSubresource sid resource subRouters\n    Rest.Many   mid ->\n      do guardNullPath\n         guardMethod GET\n         lift $ routeListHandler (list mid)\n\nrouteCreate :: Rest.Resource m s sid mid aid -> MaybeT (Router n) (RunnableHandler m)\nrouteCreate Rest.Resource { Rest.create } = guardNullPath >> guardMethod POST >>\n  maybe (apiError UnsupportedRoute) (return . RunnableHandler id) create\n\nrouteStep :: Rest.Resource m s sid mid aid\n          -> [Some1 (Rest.Router s)]\n          -> Rest.Step sid mid aid\n          -> Router n (RunnableHandler m)\nrouteStep resource subRouters step =\n  case step of\n    Rest.Named ns -> popSegment >>= \\seg ->\n      case lookup seg ns of\n        Nothing -> apiError UnsupportedRoute\n        Just h  -> routeNamed resource subRouters h\n    Rest.Unnamed h -> routeUnnamed resource subRouters h\n\nrouteNamed :: Rest.Resource m s sid mid aid\n           -> [Some1 (Rest.Router s)]\n           -> Rest.Endpoint sid mid aid\n           -> Router n (RunnableHandler m)\nrouteNamed resource@Rest.Resource { Rest.list, Rest.statics } subRouters h =\n  case h of\n    Left aid -> noRestPath >> hasMethod POST >> return (RunnableHandler id (statics aid))\n    Right (Rest.Single getter) -> routeGetter getter resource subRouters\n    Right (Rest.Many   getter) -> routeListGetter getter list\n\nrouteUnnamed :: Rest.Resource m s sid mid aid\n             -> [Some1 (Rest.Router s)]\n             -> Rest.Cardinality (Rest.Id sid) (Rest.Id mid)\n             -> Router n (RunnableHandler m)\nrouteUnnamed resource@Rest.Resource { Rest.list } subRouters cardinality =\n  case cardinality of\n    Rest.Single sBy -> withSegment (multi resource sBy) $\n      parseIdent sBy >=> \\sid -> withSubresource sid resource subRouters\n    Rest.Many   mBy ->\n      do seg <- popSegment\n         mid <- parseIdent mBy seg\n         noRestPath\n         hasMethod GET\n         routeListHandler (list mid)\n\nrouteGetter :: Rest.Getter sid\n            -> Rest.Resource m s sid mid aid\n            -> [Some1 (Rest.Router s)]\n            -> Router n (RunnableHandler m)\nrouteGetter getter resource subRouters =\n  case getter of\n    Rest.Singleton sid -> getOrDeep sid\n    Rest.By        sBy -> withSegment (multi resource sBy) $\n                            parseIdent sBy >=> getOrDeep\n  where\n    getOrDeep sid = withSubresource sid resource subRouters\n\nmulti :: Rest.Resource m s sid mid aid -> Rest.Id sid -> Router n (RunnableHandler m)\nmulti Rest.Resource { Rest.update, Rest.remove, Rest.enter } sBy =\n  asks method >>= \\mtd ->\n  case mtd of\n    PUT    -> handleOrNotFound update\n    DELETE -> handleOrNotFound remove\n    _      -> apiError UnsupportedMethod\n  where\n    handleOrNotFound handler =\n      maybe (apiError UnsupportedRoute)\n            (return . RunnableHandler id)\n            (handler >>= mkMultiHandler sBy enter)\n\nrouteListGetter :: Monad m\n                => Rest.Getter mid\n                -> (mid -> ListHandler m)\n                -> Router n (RunnableHandler m)\nrouteListGetter getter list = hasMethod GET >>\n  case getter of\n    Rest.Singleton mid -> noRestPath >> routeListHandler (list mid)\n    Rest.By        mBy ->\n      do seg <- popSegment\n         mid <- parseIdent mBy seg\n         noRestPath\n         routeListHandler (list mid)\n\nwithSubresource :: sid\n                -> Rest.Resource m s sid mid aid\n                -> [Some1 (Rest.Router s)]\n                -> Router n (RunnableHandler m)\nwithSubresource sid resource@Rest.Resource { Rest.enter, Rest.selects, Rest.actions } subRouters =\n  withSegment (routeSingle sid resource) $ \\seg ->\n  case lookup seg selects of\n    Just select -> noRestPath >> hasMethod GET >> return (RunnableHandler (enter sid) select)\n    Nothing -> case lookup seg actions of\n      Just action -> noRestPath >> hasMethod POST >> return (RunnableHandler (enter sid) action)\n      Nothing ->\n        case lookupRouter seg subRouters of\n          Just (Some1 subRouter) -> do\n            (RunnableHandler subRun subHandler) <- routeRouter subRouter\n            return (RunnableHandler (enter sid . subRun) subHandler)\n          Nothing -> apiError UnsupportedRoute\n\nrouteSingle :: sid -> Rest.Resource m s sid mid aid -> Router n (RunnableHandler m)\nrouteSingle sid Rest.Resource { Rest.enter, Rest.get, Rest.update, Rest.remove } =\n  asks method >>= \\mtd ->\n  case mtd of\n    GET    -> handleOrNotFound get\n    PUT    -> handleOrNotFound update\n    DELETE -> handleOrNotFound remove\n    _      -> apiError UnsupportedMethod\n  where\n    handleOrNotFound = maybe (apiError UnsupportedRoute) (return . RunnableHandler (enter sid))\n\nrouteName :: String -> Router n ()\nrouteName ident = unless (null ident) $\n  do identStr <- popSegment\n     when (identStr /= ident) $\n       apiError UnsupportedRoute\n\nrouteListHandler :: Monad m => ListHandler m -> Router n (RunnableHandler m)\nrouteListHandler list =\n      maybe (apiError UnsupportedRoute)\n            (return . RunnableHandler id)\n            (mkListHandler list)\n\nlookupRouter :: String -> [Some1 (Rest.Router s)] -> Maybe (Some1 (Rest.Router s))\nlookupRouter _    [] = Nothing\nlookupRouter name (Some1 router@(Rest.Embed resource _) : routers)\n   =  (guard (Rest.name resource == name) >> return (Some1 router))\n  <|> lookupRouter name routers\n\nparseIdent :: MonadError (Reason e) m => Rest.Id id -> String -> m id\nparseIdent (Rest.Id StringId byF) seg = return (byF seg)\nparseIdent (Rest.Id ReadId   byF) seg =\n  case readMay seg of\n    Nothing  -> throwError (IdentError (ParseError $ "Failed to parse " ++ seg))\n    Just sid -> return (byF sid)\n\nsplitUriString :: String -> UriParts\nsplitUriString = filter (/= "") . map decode . splitOn "/"\n\npopSegment :: Router n String\npopSegment =\n  do uriParts <- State.get\n     case uriParts of\n       []      -> apiError UnsupportedRoute\n       (hd:tl) -> do\n         State.put tl\n         return hd\n\nwithSegment :: Router n a -> (String -> Router n a) -> Router n a\nwithSegment noSeg withSeg =\n  do uriParts <- State.get\n     case uriParts of\n       [] -> noSeg\n       (hd:tl) -> do\n         State.put tl\n         withSeg hd\n\nnoRestPath :: Router n ()\nnoRestPath =\n  do uriParts <- State.get\n     unless (null uriParts) $\n       apiError UnsupportedRoute\n\nguardNullPath :: (MonadPlus m, MonadState UriParts m) => m ()\nguardNullPath = State.get >>= guard . null\n\nhasMethod :: Method -> Router n ()\nhasMethod wantedMethod = asks method >>= \\mtd ->\n  unless (mtd == wantedMethod) $\n    apiError UnsupportedMethod\n\nguardMethod :: (MonadPlus m, MonadReader (RouterData c) m) => Method -> m ()\nguardMethod mtd = asks method >>= guard . (== mtd)\n\nmkListHandler :: Monad m => ListHandler m -> Maybe (Handler m)\nmkListHandler (GenHandler dict act sec) =\n  do newDict <- L.traverse outputs listO . addPar range $ dict\n     return $ GenHandler newDict (mkListAction act) sec\n\nmkListAction :: Monad m\n            => (Env h p i -> ExceptT (Reason e) m [a])\n            -> Env h (Range, p) i\n            -> ExceptT (Reason e) m (List a)\nmkListAction act (Env h (Range f c, p) i) = do\n  xs <- act (Env h p i)\n  return (List f (min c (length xs)) (take c xs))\n\nmkMultiHandler :: Monad m => Rest.Id id -> (id -> Run s m) -> Handler s -> Maybe (Handler m)\nmkMultiHandler sBy run (GenHandler dict act sec) = GenHandler <$> mNewDict <*> pure newAct <*> pure sec\n  where\n    newErrDict = L.modify errors reasonE dict\n    mNewDict =  L.traverse inputs mappingI\n            <=< L.traverse outputs (mappingO <=< statusO (L.get errors newErrDict))\n             .  L.set errors defaultE\n             $  dict\n    newAct (Env hs ps vs) =\n      do bs <- lift $ forM (StringHashMap.toList vs) $ \\(k, v) -> runExceptT $\n           do i <- parseIdent sBy k\n              mapExceptT (run i) (act (Env hs ps v))\n         return . StringHashMap.fromList $ zipWith (\\(k, _) b -> (k, eitherToStatus b)) (StringHashMap.toList vs) bs\n\nmkMultiGetHandler :: forall m s. (Applicative m, Monad m) => Config m -> Rest.Router m s -> Handler m\nmkMultiGetHandler cfg root = mkInputHandler (xmlJsonI . multipartO) $ \\(Resources rs) -> runMultiResources cfg cfg root rs\n\ndefaultRunMultiResources :: (Applicative m, Monad m) => Config m -> Rest.Router m s -> [Resource] -> ExceptT Reason_ m [BodyPart]\ndefaultRunMultiResources cfg root rs = lift $ forM rs (runResource cfg root)\n\ndefaultConfig :: (Applicative m, Monad m) => Config m\ndefaultConfig = Config { runMultiResources = defaultRunMultiResources }\n\nrunResource :: (Applicative m, Monad m) => Config m -> Rest.Router m s -> Resource -> m BodyPart\nrunResource cfg root res\n  = fmap (uncurry mkBodyPart)\n  . runRestM (toRestInput res)\n  . either (failureWriter None) (writeResponse . mapHandler lift)\n  $ routeResource cfg root res\n\nrouteResource :: Config m -> Rest.Router m s -> Resource -> Either Reason_ (RunnableHandler m)\nrouteResource cfg root res = runRouter cfg (R.method res) (splitUriString $ R.uri res) (routeRoot root)\n\ntoRestInput :: Resource -> Rest.RestInput\ntoRestInput r = Rest.emptyInput\n  { Rest.headers    = H.map R.unValue . StringHashMap.toHashMap . R.headers    $ r\n  , Rest.parameters = H.map R.unValue . StringHashMap.toHashMap . R.parameters $ r\n  , Rest.body       = LUTF8.fromString (R.input r)\n  , Rest.method     = Just (R.method r)\n  , Rest.paths      = splitUriString (R.uri r)\n  }\n\nmkHeaders :: H.HashMap String d -> [(HeaderName, d)]\nmkHeaders = map (first HeaderName) . H.toList\n\nmkBodyPart :: LUTF8.ByteString -> Rest.RestOutput -> BodyPart\nmkBodyPart bdy restOutput =\n  let hdrs = (HeaderName "X-Response-Code", maybe "200" show (Rest.responseCode restOutput))\n           : mkHeaders (Rest.headersSet restOutput)\n  in BodyPart hdrs bdy\n\n-- * Utilities\n\nfromMaybeT :: Monad m => m a -> MaybeT m a -> m a\nfromMaybeT def act = runMaybeT act >>= maybe def return\n'