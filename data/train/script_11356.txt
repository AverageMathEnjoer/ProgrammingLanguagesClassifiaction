b'using System.Diagnostics;\n\nnamespace CS_SQLite3\n{\n  public partial class CSSQLite\n  {\n    /*\n    ** 2007 August 27\n    **\n    ** The author disclaims copyright to this source code.  In place of\n    ** a legal notice, here is a blessing:\n    **\n    **    May you do good and not evil.\n    **    May you find forgiveness for yourself and forgive others.\n    **    May you share freely, never taking more than you give.\n    **\n    *************************************************************************\n    **\n    ** $Id: btmutex.c,v 1.17 2009/07/20 12:33:33 drh Exp $\n    **\n    *************************************************************************\n    **  Included in SQLite3 port to C#-SQLite;  2008 Noah B Hart\n    **  C#-SQLite is an independent reimplementation of the SQLite software library\n    **\n    **  $Header$\n    *************************************************************************\n    **\n    ** This file contains code used to implement mutexes on Btree objects.\n    ** This code really belongs in btree.c.  But btree.c is getting too\n    ** big and we want to break it down some.  This packaged seemed like\n    ** a good breakout.\n    */\n    //#include "btreeInt.h"\n#if !SQLITE_OMIT_SHARED_CACHE\n#if SQLITE_THREADSAFE\n\n/*\n** Obtain the BtShared mutex associated with B-Tree handle p. Also,\n** set BtShared.db to the database handle associated with p and the\n** p->locked boolean to true.\n*/\nstatic void lockBtreeMutex(Btree *p){\nassert( p->locked==0 );\nassert( sqlite3_mutex_notheld(p->pBt->mutex) );\nassert( sqlite3_mutex_held(p->db->mutex) );\n\nsqlite3_mutex_enter(p->pBt->mutex);\np->pBt->db = p->db;\np->locked = 1;\n}\n\n/*\n** Release the BtShared mutex associated with B-Tree handle p and\n** clear the p->locked boolean.\n*/\nstatic void unlockBtreeMutex(Btree *p){\nassert( p->locked==1 );\nassert( sqlite3_mutex_held(p->pBt->mutex) );\nassert( sqlite3_mutex_held(p->db->mutex) );\nassert( p->db==p->pBt->db );\n\nsqlite3_mutex_leave(p->pBt->mutex);\np->locked = 0;\n}\n\n/*\n** Enter a mutex on the given BTree object.\n**\n** If the object is not sharable, then no mutex is ever required\n** and this routine is a no-op.  The underlying mutex is non-recursive.\n** But we keep a reference count in Btree.wantToLock so the behavior\n** of this interface is recursive.\n**\n** To avoid deadlocks, multiple Btrees are locked in the same order\n** by all database connections.  The p->pNext is a list of other\n** Btrees belonging to the same database connection as the p Btree\n** which need to be locked after p.  If we cannot get a lock on\n** p, then first unlock all of the others on p->pNext, then wait\n** for the lock to become available on p, then relock all of the\n** subsequent Btrees that desire a lock.\n*/\nvoid sqlite3BtreeEnter(Btree *p){\nBtree *pLater;\n\n/* Some basic sanity checking on the Btree.  The list of Btrees\n** connected by pNext and pPrev should be in sorted order by\n** Btree.pBt value. All elements of the list should belong to\n** the same connection. Only shared Btrees are on the list. */\nassert( p->pNext==0 || p->pNext->pBt>p->pBt );\nassert( p->pPrev==0 || p->pPrev->pBt<p->pBt );\nassert( p->pNext==0 || p->pNext->db==p->db );\nassert( p->pPrev==0 || p->pPrev->db==p->db );\nassert( p->sharable || (p->pNext==0 && p->pPrev==0) );\n\n/* Check for locking consistency */\nassert( !p->locked || p->wantToLock>0 );\nassert( p->sharable || p->wantToLock==0 );\n\n/* We should already hold a lock on the database connection */\nassert( sqlite3_mutex_held(p->db->mutex) );\n\n/* Unless the database is sharable and unlocked, then BtShared.db\n** should already be set correctly. */\nassert( (p->locked==0 && p->sharable) || p->pBt->db==p->db );\n\nif( !p->sharable ) return;\np->wantToLock++;\nif( p->locked ) return;\n\n/* In most cases, we should be able to acquire the lock we\n** want without having to go throught the ascending lock\n** procedure that follows.  Just be sure not to block.\n*/\nif( sqlite3_mutex_try(p->pBt->mutex)==SQLITE_OK ){\np->pBt->db = p->db;\np->locked = 1;\nreturn;\n}\n\n/* To avoid deadlock, first release all locks with a larger\n** BtShared address.  Then acquire our lock.  Then reacquire\n** the other BtShared locks that we used to hold in ascending\n** order.\n*/\nfor(pLater=p->pNext; pLater; pLater=pLater->pNext){\nassert( pLater->sharable );\nassert( pLater->pNext==0 || pLater->pNext->pBt>pLater->pBt );\nassert( !pLater->locked || pLater->wantToLock>0 );\nif( pLater->locked ){\nunlockBtreeMutex(pLater);\n}\n}\nlockBtreeMutex(p);\nfor(pLater=p->pNext; pLater; pLater=pLater->pNext){\nif( pLater->wantToLock ){\nlockBtreeMutex(pLater);\n}\n}\n}\n\n/*\n** Exit the recursive mutex on a Btree.\n*/\nvoid sqlite3BtreeLeave(Btree *p){\nif( p->sharable ){\nassert( p->wantToLock>0 );\np->wantToLock--;\nif( p->wantToLock==0 ){\nunlockBtreeMutex(p);\n}\n}\n}\n\n#if !NDEBUG\n/*\n** Return true if the BtShared mutex is held on the btree, or if the\n** B-Tree is not marked as sharable.\n**\n** This routine is used only from within assert() statements.\n*/\nint sqlite3BtreeHoldsMutex(Btree *p){\nassert( p->sharable==0 || p->locked==0 || p->wantToLock>0 );\nassert( p->sharable==0 || p->locked==0 || p->db==p->pBt->db );\nassert( p->sharable==0 || p->locked==0 || sqlite3_mutex_held(p->pBt->mutex) );\nassert( p->sharable==0 || p->locked==0 || sqlite3_mutex_held(p->db->mutex) );\n\nreturn (p->sharable==0 || p->locked);\n}\n#endif\n\n\n#if !SQLITE_OMIT_INCRBLOB\n/*\n** Enter and leave a mutex on a Btree given a cursor owned by that\n** Btree.  These entry points are used by incremental I/O and can be\n** omitted if that module is not used.\n*/\nvoid sqlite3BtreeEnterCursor(BtCursor *pCur){\nsqlite3BtreeEnter(pCur->pBtree);\n}\nvoid sqlite3BtreeLeaveCursor(BtCursor *pCur){\nsqlite3BtreeLeave(pCur->pBtree);\n}\n#endif //* SQLITE_OMIT_INCRBLOB */\n\n\n/*\n** Enter the mutex on every Btree associated with a database\n** connection.  This is needed (for example) prior to parsing\n** a statement since we will be comparing table and column names\n** against all schemas and we do not want those schemas being\n** reset out from under us.\n**\n** There is a corresponding leave-all procedures.\n**\n** Enter the mutexes in accending order by BtShared pointer address\n** to avoid the possibility of deadlock when two threads with\n** two or more btrees in common both try to lock all their btrees\n** at the same instant.\n*/\nvoid sqlite3BtreeEnterAll(sqlite3 *db){\nint i;\nBtree *p, *pLater;\nassert( sqlite3_mutex_held(db->mutex) );\nfor(i=0; i<db->nDb; i++){\np = db->aDb[i].pBt;\nassert( !p || (p->locked==0 && p->sharable) || p->pBt->db==p->db );\nif( p && p->sharable ){\np->wantToLock++;\nif( !p->locked ){\nassert( p->wantToLock==1 );\nwhile( p->pPrev ) p = p->pPrev;\n/* Reason for ALWAYS:  There must be at least on unlocked Btree in\n** the chain.  Otherwise the !p->locked test above would have failed */\nwhile( p->locked && ALWAYS(p->pNext) ) p = p->pNext;\nfor(pLater = p->pNext; pLater; pLater=pLater->pNext){\nif( pLater->locked ){\nunlockBtreeMutex(pLater);\n}\n}\nwhile( p ){\nlockBtreeMutex(p);\np = p->pNext;\n}\n}\n}\n}\n}\nvoid sqlite3BtreeLeaveAll(sqlite3 *db){\nint i;\nBtree *p;\nassert( sqlite3_mutex_held(db->mutex) );\nfor(i=0; i<db->nDb; i++){\np = db->aDb[i].pBt;\nif( p && p->sharable ){\nassert( p->wantToLock>0 );\np->wantToLock--;\nif( p->wantToLock==0 ){\nunlockBtreeMutex(p);\n}\n}\n}\n}\n\n#if !NDEBUG\n/*\n** Return true if the current thread holds the database connection\n** mutex and all required BtShared mutexes.\n**\n** This routine is used inside assert() statements only.\n*/\nint sqlite3BtreeHoldsAllMutexes(sqlite3 *db){\nint i;\nif( !sqlite3_mutex_held(db->mutex) ){\nreturn 0;\n}\nfor(i=0; i<db->nDb; i++){\nBtree *p;\np = db->aDb[i].pBt;\nif( p && p->sharable &&\n(p->wantToLock==0 || !sqlite3_mutex_held(p->pBt->mutex)) ){\nreturn 0;\n}\n}\nreturn 1;\n}\n#endif //* NDEBUG */\n\n/*\n** Add a new Btree pointer to a BtreeMutexArray.\n** if the pointer can possibly be shared with\n** another database connection.\n**\n** The pointers are kept in sorted order by pBtree->pBt.  That\n** way when we go to enter all the mutexes, we can enter them\n** in order without every having to backup and retry and without\n** worrying about deadlock.\n**\n** The number of shared btrees will always be small (usually 0 or 1)\n** so an insertion sort is an adequate algorithm here.\n*/\nvoid sqlite3BtreeMutexArrayInsert(BtreeMutexArray *pArray, Btree *pBtree){\nint i, j;\nBtShared *pBt;\nif( pBtree==0 || pBtree->sharable==0 ) return;\n#if !NDEBUG\n{\nfor(i=0; i<pArray->nMutex; i++){\nassert( pArray->aBtree[i]!=pBtree );\n}\n}\n#endif\nassert( pArray->nMutex>=0 );\nassert( pArray->nMutex<ArraySize(pArray->aBtree)-1 );\npBt = pBtree->pBt;\nfor(i=0; i<pArray->nMutex; i++){\nassert( pArray->aBtree[i]!=pBtree );\nif( pArray->aBtree[i]->pBt>pBt ){\nfor(j=pArray->nMutex; j>i; j--){\npArray->aBtree[j] = pArray->aBtree[j-1];\n}\npArray->aBtree[i] = pBtree;\npArray->nMutex++;\nreturn;\n}\n}\npArray->aBtree[pArray->nMutex++] = pBtree;\n}\n\n/*\n** Enter the mutex of every btree in the array.  This routine is\n** called at the beginning of sqlite3VdbeExec().  The mutexes are\n** exited at the end of the same function.\n*/\nvoid sqlite3BtreeMutexArrayEnter(BtreeMutexArray *pArray){\nint i;\nfor(i=0; i<pArray->nMutex; i++){\nBtree *p = pArray->aBtree[i];\n/* Some basic sanity checking */\nassert( i==0 || pArray->aBtree[i-1]->pBt<p->pBt );\nassert( !p->locked || p->wantToLock>0 );\n\n/* We should already hold a lock on the database connection */\nassert( sqlite3_mutex_held(p->db->mutex) );\n\n/* The Btree is sharable because only sharable Btrees are entered\n** into the array in the first place. */\nassert( p->sharable );\n\np->wantToLock++;\nif( !p->locked ){\nlockBtreeMutex(p);\n}\n}\n}\n\n/*\n** Leave the mutex of every btree in the group.\n*/\nvoid sqlite3BtreeMutexArrayLeave(BtreeMutexArray *pArray){\nint i;\nfor(i=0; i<pArray->nMutex; i++){\nBtree *p = pArray->aBtree[i];\n/* Some basic sanity checking */\nassert( i==0 || pArray->aBtree[i-1]->pBt<p->pBt );\nassert( p->locked);\nassert( p->wantToLock>0 );\n\n/* We should already hold a lock on the database connection */\nassert( sqlite3_mutex_held(p->db->mutex) );\n\np->wantToLock--;\nif( p->wantToLock==0){\nunlockBtreeMutex(p);\n}\n}\n}\n\n#else\nstatic void sqlite3BtreeEnter( Btree p )\n{\np.pBt.db = p.db;\n}\nstatic void sqlite3BtreeEnterAll( sqlite3 db )\n{\nint i;\nfor ( i = 0 ; i < db.nDb ; i++ )\n{\nBtree p = db.aDb[i].pBt;\nif ( p != null )\n{\np.pBt.db = p.db;\n}\n}\n}\n#endif //* if SQLITE_THREADSAFE */\n#endif //* ifndef SQLITE_OMIT_SHARED_CACHE */\n\n  }\n}\n'