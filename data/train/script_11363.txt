b'{-# LANGUAGE DataKinds #-}\n{-# LANGUAGE DeriveGeneric #-}\n{-# LANGUAGE DuplicateRecordFields #-}\n{-# LANGUAGE ImportQualifiedPost #-}\n{-# LANGUAGE OverloadedStrings #-}\n{-# LANGUAGE QuasiQuotes #-}\n{-# LANGUAGE RankNTypes #-}\n{-# LANGUAGE RecordWildCards #-}\n\nmodule HOAuth2ProvidersTutorial where\n\nimport Control.Monad.IO.Class (liftIO)\nimport Control.Monad.Trans.Except\nimport Data.ByteString.Lazy.Char8 qualified as BSL\nimport Data.IORef (IORef, newIORef, readIORef, writeIORef)\nimport Data.Set qualified as Set\nimport Data.Text.Encoding qualified as T\nimport Data.Text.Lazy qualified as TL\nimport Network.HTTP.Conduit (newManager, tlsManagerSettings)\nimport Network.HTTP.Types (status302)\nimport Network.OAuth.OAuth2 (\n  ExchangeToken (ExchangeToken),\n  OAuth2Token (accessToken),\n  TokenRequestError,\n )\nimport Network.OAuth2.Experiment\nimport Network.OAuth2.Provider.Auth0 (\n  Auth0,\n  Auth0User (Auth0User, email, name, sub),\n  defaultAuth0App,\n  defaultAuth0Idp,\n )\nimport Network.OAuth2.Provider.Google (\n  Google,\n  GoogleUser (GoogleUser, email, id, name),\n  defaultGoogleApp,\n  defaultGoogleIdp,\n )\nimport URI.ByteString (URI, serializeURIRef\')\nimport URI.ByteString.QQ (uri)\nimport Web.Scotty (ActionM, scotty)\nimport Web.Scotty qualified as Scotty\nimport Prelude hiding (id)\n\n------------------------------\n\n-- * Configuration\n\n------------------------------\n\ntestAuth0App :: IdpApplication \'AuthorizationCode Auth0\ntestAuth0App =\n  (defaultAuth0App testAuth0Idp)\n    { idpAppClientId = ""\n    , idpAppClientSecret = ""\n    , idpAppAuthorizeState = AuthorizeState ("auth0." <> randomStateValue)\n    , idpAppScope = Set.fromList ["openid", "email", "profile"]\n    , idpAppRedirectUri = [uri|http://localhost:9988/oauth2/callback|]\n    , idpAppName = "foo-auth0-app"\n    }\n\ntestAuth0Idp :: Idp Auth0\ntestAuth0Idp =\n  defaultAuth0Idp\n    { idpUserInfoEndpoint = [uri|https://freizl.auth0.com/userinfo|]\n    , idpAuthorizeEndpoint = [uri|https://freizl.auth0.com/authorize|]\n    , idpTokenEndpoint = [uri|https://freizl.auth0.com/oauth/token|]\n    }\n\ntestGoogleIdp :: Idp Google\ntestGoogleIdp = defaultGoogleIdp\n\ntestGoogleApp :: IdpApplication \'AuthorizationCode Google\ntestGoogleApp =\n  defaultGoogleApp\n    { idpAppClientId = ""\n    , idpAppClientSecret = ""\n    , idpAppAuthorizeState = AuthorizeState ("google." <> randomStateValue)\n    , idpAppRedirectUri = [uri|http://localhost:9988/oauth2/callback|]\n    , idpAppName = "foo-google-app"\n    , idp = testGoogleIdp\n    }\n\n-- | You\'ll need to find out an better way to create @state@\n-- which is recommended in <https://www.rfc-editor.org/rfc/rfc6749#section-10.12>\nrandomStateValue :: TL.Text\nrandomStateValue = "random-state-to-prevent-csrf"\n\n------------------------------\n\n-- * Web server\n\n------------------------------\ndata DemoUser = DemoUser\n  { name :: TL.Text\n  , email :: Maybe TL.Text\n  }\n  deriving (Eq, Show)\n\n-- | The \'scotty\' application\napp :: IO ()\napp = do\n  -- Poor man\'s solution for creating user session.\n  refUser <- newIORef Nothing\n  scotty 9988 $ do\n    Scotty.get "/" $ indexH refUser\n    Scotty.get "/login/auth0" loginAuth0H\n    Scotty.get "/login/google" loginGoogleH\n    Scotty.get "/logout" (logoutH refUser)\n    Scotty.get "/oauth2/callback" $ callbackH refUser\n\n-- | @/@ endpoint handler\nindexH :: IORef (Maybe DemoUser) -> ActionM ()\nindexH refUser = do\n  muser <- liftIO (readIORef refUser)\n\n  let info = case muser of\n        Just DemoUser {..} ->\n          [ "<h2>Hello, "\n          , name\n          , "</h2>"\n          , "<p>"\n          , TL.pack (show email)\n          , "</p>"\n          , "<a href=\'/logout\'>Logout</a>"\n          ]\n        Nothing ->\n          [ "<ul>"\n          , "<li>"\n          , "<a href=\'/login/auth0\'>Login with Auth0</a>"\n          , "</li>"\n          , "<li>"\n          , "<a href=\'/login/google\'>Login with Google</a>"\n          , "</li>"\n          , "</ul>"\n          ]\n\n  Scotty.html . mconcat $ "<h1>hoauth2 providers Tutorial</h1>" : info\n\n-- | @/login/auth0@ endpoint handler\nloginAuth0H :: ActionM ()\nloginAuth0H = do\n  Scotty.setHeader "Location" (mkAuthorizeRequest testAuth0App)\n  Scotty.status status302\n\n-- | @/login/google@ endpoint handler\nloginGoogleH :: ActionM ()\nloginGoogleH = do\n  Scotty.setHeader "Location" (mkAuthorizeRequest testGoogleApp)\n  Scotty.status status302\n\n-- | @/logout@ endpoint handler\nlogoutH :: IORef (Maybe DemoUser) -> ActionM ()\nlogoutH refUser = do\n  liftIO (writeIORef refUser Nothing)\n  Scotty.redirect "/"\n\n-- | @/oauth2/callback@ endpoint handler\ncallbackH :: IORef (Maybe DemoUser) -> ActionM ()\ncallbackH refUser = do\n  pas <- Scotty.params\n\n  excepttToActionM $ do\n    state <- ExceptT $ pure $ paramValue "state" pas\n    codeP <- ExceptT $ pure $ paramValue "code" pas\n\n    let code = ExchangeToken $ TL.toStrict codeP\n    let idpName = TL.takeWhile (\'.\' /=) state\n\n    user <- case idpName of\n      "google" -> handleGoogleCallback code\n      "auth0" -> handleAuth0Callback code\n      _ -> throwE $ "unable to find idp app of: " <> idpName\n\n    liftIO $ writeIORef refUser (Just user)\n\n  Scotty.redirect "/"\n\nhandleAuth0Callback :: ExchangeToken -> ExceptT TL.Text IO DemoUser\nhandleAuth0Callback code = do\n  let idpApp = testAuth0App\n  mgr <- liftIO $ newManager tlsManagerSettings\n  tokenResp <- withExceptT oauth2ErrorToText (conduitTokenRequest idpApp mgr code)\n  Auth0User {..} <- withExceptT bslToText $ conduitUserInfoRequest idpApp mgr (accessToken tokenResp)\n  pure (DemoUser name (Just email))\n\nhandleGoogleCallback :: ExchangeToken -> ExceptT TL.Text IO DemoUser\nhandleGoogleCallback code = do\n  let idpApp = testGoogleApp\n  mgr <- liftIO $ newManager tlsManagerSettings\n  tokenResp <- withExceptT oauth2ErrorToText (conduitTokenRequest idpApp mgr code)\n  GoogleUser {..} <- withExceptT bslToText $ conduitUserInfoRequest idpApp mgr (accessToken tokenResp)\n  pure (DemoUser name (Just email))\n\n------------------------------\n\n-- * Utilities\n\n------------------------------\n\nuriToText :: URI -> TL.Text\nuriToText = TL.fromStrict . T.decodeUtf8 . serializeURIRef\'\n\nbslToText :: BSL.ByteString -> TL.Text\nbslToText = TL.pack . BSL.unpack\n\nparamValue ::\n  -- | Parameter key\n  TL.Text ->\n  -- | All parameters\n  [Scotty.Param] ->\n  Either TL.Text TL.Text\nparamValue key params =\n  if null val\n    then Left ("No value found for param: " <> key)\n    else Right (head val)\n  where\n    val = snd <$> filter (hasParam key) params\n    hasParam :: TL.Text -> Scotty.Param -> Bool\n    hasParam t = (== t) . fst\n\n-- | Lift ExceptT to ActionM which is basically the handler Monad in Scotty.\nexcepttToActionM :: Show a => ExceptT TL.Text IO a -> ActionM a\nexcepttToActionM e = do\n  result <- liftIO $ runExceptT e\n  either Scotty.raise pure result\n\noauth2ErrorToText :: TokenRequestError -> TL.Text\noauth2ErrorToText e = TL.pack $ "Unable fetch access token. error detail: " ++ show e\n'