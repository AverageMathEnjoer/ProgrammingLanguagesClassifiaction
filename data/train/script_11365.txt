b'#include "resource.h"\n#include "defines.h"\n\n#define WIN32_LEAN_AND_MEAN\n#define NOMINMAX\n#include <Windows.h>\n#include <WindowsX.h>\n#include <tchar.h>\n#include <unordered_map>\n#include <memory>\n#include <algorithm>\n#include <chrono>\n#include "../libStringConverter/convert.h"\n#include "../UABE_Generic/FileContextInfo.h"\n#include "../UABE_Generic/CreateEmptyValueField.h"\n#include "../UABE_Win32/Win32PluginManager.h"\n#include "../UABE_Win32/Win32AppContext.h"\n#include "../UABE_Win32/Win32BatchImportDesc.h"\n#include "../UABE_Win32/BatchImportDialog.h"\n#include "../UABE_Win32/FileDialog.h"\n#include "Texture.h"\n\n#define IsPowerOfTwo(n) ((n!=0)&&!(n&(n-1)))\n\nHMODULE g_hModule;\n\nINT_PTR CALLBACK CompressQualityDlg(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)\n{\n\tUNREFERENCED_PARAMETER(lParam);\n\tswitch (message)\n\t{\n\tcase WM_INITDIALOG:\n\t{\n\t\tSetWindowLongPtr(hDlg, GWLP_USERDATA, lParam);\n\t\tTextureImportParam* pParam = (TextureImportParam*)lParam;\n\n\t\tHWND hCbQuality = GetDlgItem(hDlg, IDC_CBQUALITY);\n\t\tstd::vector<const wchar_t*> presetNames;\n\t\tsize_t defaultPresetIdx = GetQualityPresetList(pParam->batchInfo.newTextureFormat, presetNames);\n\t\tif (defaultPresetIdx >= presetNames.size() || presetNames.size() >= 0x7FFFFFFF)\n\t\t{\n\t\t\tEndDialog(hDlg, 0);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpParam->qualitySelection = GetQualityFromPresetListIdx(pParam->batchInfo.newTextureFormat, defaultPresetIdx);\n\t\t\tfor (size_t i = 0; i < presetNames.size(); i++)\n\t\t\t{\n\t\t\t\tComboBox_AddString(hCbQuality, presetNames[i]);\n\t\t\t}\n\t\t\tComboBox_SetCurSel(hCbQuality, (int)defaultPresetIdx);\n\t\t}\n\t\treturn (INT_PTR)TRUE;\n\t}\n\tcase WM_CLOSE:\n\tcase WM_DESTROY:\n\t{\n\t\tTextureImportParam* pParam = (TextureImportParam*)GetWindowLongPtr(hDlg, GWLP_USERDATA);\n\n\t\tint selection = ComboBox_GetCurSel(GetDlgItem(hDlg, IDC_CBQUALITY));\n\t\tif (selection < 0) selection = 0;\n\n\t\tECompressorQuality newQuality = GetQualityFromPresetListIdx(pParam->batchInfo.newTextureFormat, (size_t)selection);\n\t\tif (pParam->qualitySelection != newQuality)\n\t\t{\n\t\t\tpParam->qualitySelected = true;\n\t\t\tpParam->qualitySelection = newQuality;\n\t\t}\n\t}\n\tbreak;\n\tcase WM_COMMAND:\n\t{\n\t\tWORD wmId = LOWORD(wParam);\n\t\tWORD wmEvent = HIWORD(wParam);\n\t\tswitch (wmId)\n\t\t{\n\t\tcase IDOK:\n\t\tcase IDCANCEL:\n\t\t{\n\t\t\tEndDialog(hDlg, (INT_PTR)lParam);\n\t\t\treturn (INT_PTR)TRUE;\n\t\t}\n\t\tbreak;\n\t\t}\n\t}\n\t}\n\treturn (INT_PTR)FALSE;\n}\nINT_PTR CALLBACK ImportDlg(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)\n{\n\tTextureImportParam* pParam = (TextureImportParam*)GetWindowLongPtr(hDlg, GWLP_USERDATA);\n\tTCHAR tPrint[128];\n\tint wmId, wmEvent;\n\tUNREFERENCED_PARAMETER(lParam);\n\tswitch (message)\n\t{\n\tcase WM_DESTROY:\n\tbreak;\n\tcase WM_INITDIALOG:\n\t{\n\t\tSetWindowLongPtr(hDlg, GWLP_USERDATA, lParam);\n\t\tTextureImportParam* pParam = (TextureImportParam*)lParam;\n\t\tif (pParam->importTextureName.size() > 0)\n\t\t{\n\t\t\tauto tc_importTextureName = unique_MultiByteToTCHAR(pParam->importTextureName.c_str());\n\t\t\tEdit_SetText(GetDlgItem(hDlg, IDC_ENAME), tc_importTextureName.get());\n\t\t}\n\t\tHWND hCBTexFmt = GetDlgItem(hDlg, IDC_CBTEXFMT);\n\n\t\tHWND hCKMipMap = GetDlgItem(hDlg, IDC_CKMIPMAP);\n\n\t\tHWND hCKReadable = GetDlgItem(hDlg, IDC_CKREADABLE);\n\n\t\tHWND hCKReadAllowed = GetDlgItem(hDlg, IDC_CKREADALLOWED);\n\n\t\tHWND hCBFilterMode = GetDlgItem(hDlg, IDC_CBFILTERMODE);\n\t\tComboBox_AddString(hCBFilterMode, TEXT("Point"));\n\t\tComboBox_AddString(hCBFilterMode, TEXT("Bilinear"));\n\t\tComboBox_AddString(hCBFilterMode, TEXT("Trilinear"));\n\n\t\tHWND hEAniso = GetDlgItem(hDlg, IDC_EANISO);\n\n\t\tHWND hEMipBias = GetDlgItem(hDlg, IDC_EMIPBIAS);\n\n\t\tHWND hCBWrapMode = GetDlgItem(hDlg, IDC_CBWRAPMODE);\n\t\tComboBox_AddString(hCBWrapMode, TEXT("Repeat"));\n\t\tComboBox_AddString(hCBWrapMode, TEXT("Clamp"));\n\n\t\tHWND hCBWrapModeU = GetDlgItem(hDlg, IDC_CBWRAPMODEU);\n\t\tComboBox_AddString(hCBWrapModeU, TEXT("Repeat"));\n\t\tComboBox_AddString(hCBWrapModeU, TEXT("Clamp"));\n\t\tComboBox_AddString(hCBWrapModeU, TEXT("Mirror")); //2017.1\n\t\tComboBox_AddString(hCBWrapModeU, TEXT("MirrorOnce")); //2017.1\n\n\t\tHWND hCBWrapModeV = GetDlgItem(hDlg, IDC_CBWRAPMODEV);\n\t\tComboBox_AddString(hCBWrapModeV, TEXT("Repeat"));\n\t\tComboBox_AddString(hCBWrapModeV, TEXT("Clamp"));\n\t\tComboBox_AddString(hCBWrapModeV, TEXT("Mirror"));\n\t\tComboBox_AddString(hCBWrapModeV, TEXT("MirrorOnce"));\n\n\t\tHWND hELightMapFmt = GetDlgItem(hDlg, IDC_ELIGHTMAPFMT);\n\n\t\tHWND hCBClSpace = GetDlgItem(hDlg, IDC_CBCLSPACE);\n\t\tComboBox_AddString(hCBClSpace, TEXT("Gamma"));\n\t\tComboBox_AddString(hCBClSpace, TEXT("Linear"));\n\n\t\tif (!pParam->assetWasTextureFile)\n\t\t{\n\t\t\tpParam->importTextureInfo.m_ForcedFallbackFormat = 0;\n\t\t\tpParam->importTextureInfo.m_DownscaleFallback = false;\n\t\t\tpParam->importTextureInfo.m_TextureFormat = TexFmt_DXT5;\n\t\t\tpParam->importTextureInfo.m_MipMap = true;\n\t\t\tpParam->importTextureInfo.m_IsReadable = false;\n\t\t\tpParam->importTextureInfo.m_ReadAllowed = true;\n\t\t\tpParam->importTextureInfo.m_StreamingMipmaps = false;\n\t\t\tpParam->importTextureInfo.m_StreamingMipmapsPriority = 0;\n\t\t\tpParam->importTextureInfo.m_TextureSettings.m_FilterMode = 2;\n\t\t\tpParam->importTextureInfo.m_TextureSettings.m_Aniso = 2;\n\t\t\tpParam->importTextureInfo.m_TextureSettings.m_MipBias = 0.0F;\n\t\t\tpParam->importTextureInfo.m_TextureSettings.m_WrapMode = 1;\n\t\t\tpParam->importTextureInfo.m_TextureSettings.m_WrapU = 1;\n\t\t\tpParam->importTextureInfo.m_TextureSettings.m_WrapV = 1;\n\t\t\tpParam->importTextureInfo.m_TextureSettings.m_WrapW = 1;\n\t\t\tpParam->importTextureInfo.m_LightmapFormat = 0;\n\t\t\tpParam->importTextureInfo.m_ColorSpace = 1;\n\n\t\t\tpParam->importTextureInfo.m_MipCount = 1;\n\t\t\tpParam->importTextureInfo.m_StreamData.offset = 0;\n\t\t\tpParam->importTextureInfo.m_StreamData.size = 0;\n\t\t\tpParam->importTextureInfo.m_StreamData.path.clear();\n\n\t\t\t//Retrieve texture format version.\n\t\t\tSupportsTextureFormat(pParam->asset.pFile->getAssetsFileContext()->getAssetsFile(),\n\t\t\t\tTexFmt_ARGB32,\n\t\t\t\tpParam->importTextureInfo.extra.textureFormatVersion);\n\t\t}\n\t\tpParam->importTextureInfo.m_TextureDimension = 2;\n\t\tpParam->importTextureInfo.m_ImageCount = 1;\n\n\t\t{\n\t\t\tsize_t textureTypeIndex;\n\t\t\tif (pParam->batchInfo.newTextureFormat == TexFmt_BGRA32Old)\n\t\t\t\ttextureTypeIndex = GetTextureNameIDPair(TexFmt_BGRA32New, pParam->importTextureInfo.extra.textureFormatVersion);\n\t\t\telse\n\t\t\t\ttextureTypeIndex = GetTextureNameIDPair(pParam->batchInfo.newTextureFormat, pParam->importTextureInfo.extra.textureFormatVersion);\n\t\t\tif (textureTypeIndex == (size_t)-1) textureTypeIndex = 0;\n\t\t\tint cbTargetSel = 0;\n\t\t\tfor (size_t i = 0, cbIdx = 0; i < SupportedTextureNames_size; i++)\n\t\t\t{\n\t\t\t\tint texVersion = -1;\n\t\t\t\tif (SupportsTextureFormat(pParam->asset.pFile->getAssetsFileContext()->getAssetsFile(),\n\t\t\t\t\t\tSupportedTextureNames[i].textureType,\n\t\t\t\t\t\ttexVersion)\n\t\t\t\t\t&& IsTextureNameIDPairInRange(&SupportedTextureNames[i], texVersion))\n\t\t\t\t{\n\t\t\t\t\tComboBox_AddString(hCBTexFmt, SupportedTextureNames[i].name);\n\t\t\t\t\tComboBox_SetItemData(hCBTexFmt, cbIdx, i);\n\t\t\t\t\tif (textureTypeIndex == i)\n\t\t\t\t\t\tcbTargetSel = (int)cbIdx;\n\t\t\t\t\tcbIdx++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tComboBox_SetCurSel(hCBTexFmt, (int)cbTargetSel);\n\n\t\t\tif (pParam->assetWasTextureFile && IsPowerOfTwo(pParam->importTextureInfo.m_Width) && IsPowerOfTwo(pParam->importTextureInfo.m_Height))\n\t\t\t{\n\t\t\t\tButton_SetCheck(hCKMipMap, pParam->batchInfo.newMipMap);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tButton_SetCheck(hCKMipMap, FALSE);\n\t\t\t\tButton_Enable(hCKMipMap, FALSE);\n\t\t\t}\n\t\t\tButton_SetCheck(hCKReadable, pParam->batchInfo.newReadable);\n\t\t\tButton_SetCheck(hCKReadAllowed, pParam->batchInfo.newReadAllowed);\n\n\t\t\tif (pParam->importTextureInfo.m_TextureSettings.m_FilterMode > 2)\n\t\t\t\tComboBox_SetCurSel(hCBFilterMode, 2);\n\t\t\telse\n\t\t\t\tComboBox_SetCurSel(hCBFilterMode, pParam->batchInfo.newFilterMode);\n\n\t\t\t_stprintf_s(tPrint, TEXT("%u"), pParam->batchInfo.newAnisoLevel);\n\t\t\tEdit_SetText(hEAniso, tPrint);\n\n\t\t\t//Print an exact representation, using scientific notation if it\'s shorter.\n\t\t\t_stprintf_s(tPrint, TEXT("%.9g"), pParam->batchInfo.newMipBias);\n\t\t\tEdit_SetText(hEMipBias, tPrint);\n\n\t\t\tif (pParam->batchInfo.newWrapMode > 1)\n\t\t\t\tComboBox_SetCurSel(hCBWrapMode, 1);\n\t\t\telse\n\t\t\t\tComboBox_SetCurSel(hCBWrapMode, pParam->batchInfo.newWrapMode);\n\n\t\t\tif (pParam->batchInfo.newWrapModeU > 3)\n\t\t\t\tComboBox_SetCurSel(hCBWrapModeU, 3);\n\t\t\telse\n\t\t\t\tComboBox_SetCurSel(hCBWrapModeU, pParam->batchInfo.newWrapModeU);\n\n\t\t\tif (pParam->batchInfo.newWrapModeV > 3)\n\t\t\t\tComboBox_SetCurSel(hCBWrapModeV, 3);\n\t\t\telse\n\t\t\t\tComboBox_SetCurSel(hCBWrapModeV, pParam->batchInfo.newWrapModeV);\n\n\t\t\t_stprintf_s(tPrint, TEXT("0x%02X"), pParam->batchInfo.newLightmapFmt);\n\t\t\tEdit_SetText(hELightMapFmt, tPrint);\n\n\t\t\tif (pParam->batchInfo.newColorSpace > 1)\n\t\t\t\tComboBox_SetCurSel(hCBClSpace, 1);\n\t\t\telse\n\t\t\t\tComboBox_SetCurSel(hCBClSpace, pParam->batchInfo.newColorSpace);\n\t\t}\n\n\t\tInactivateDialogPairsByIdx(hDlg, pParam->hideDialogElementsList);\n\t\treturn (INT_PTR)TRUE;\n\t}\n\tcase WM_COMMAND:\n\t\twmId = LOWORD(wParam);\n\t\twmEvent = HIWORD(wParam);\n\t\tswitch (wmId)\n\t\t{\n\t\tcase IDC_BLOAD:\n\t\t{\n\t\t\tTextureImportParam* pParam = (TextureImportParam*)GetWindowLongPtr(hDlg, GWLP_USERDATA);\n\t\t\twchar_t* newTextureFilePathW = nullptr;\n\t\t\tif (SUCCEEDED(ShowFileOpenDialog(hDlg, &newTextureFilePathW, L"*.tga;*.png;*.bmp|Image file:*.*|All types:",\n\t\t\t\tnullptr, nullptr, nullptr, UABE_FILEDIALOG_EXPIMPASSET_GUID)))\n\t\t\t{\n\t\t\t\tauto newTextureFilePath = unique_WideToMultiByte(newTextureFilePathW);\n\t\t\t\tFreeCOMFilePathBuf(&newTextureFilePathW);\n\t\t\t\tif (pParam->batchInfo.isBatchEntry)\n\t\t\t\t{\n\t\t\t\t\tIAssetsReader* pImageFileReader = Create_AssetsReaderFromFile(newTextureFilePath.get(), true, RWOpenFlags_Immediately);\n\t\t\t\t\tif (pImageFileReader != NULL)\n\t\t\t\t\t{\n\t\t\t\t\t\tpParam->batchInfo.batchFilenameOverride.assign(newTextureFilePath.get());\n\t\t\t\t\t\tFree_AssetsReader(pImageFileReader);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t\tMessageBox(hDlg, TEXT("Unable to open the file!"), TEXT("ERROR"), 16);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tstd::vector<uint8_t> newTextureData;\n\t\t\t\t\tif (LoadTextureFromFile(newTextureFilePath.get(),\n\t\t\t\t\t\tnewTextureData,\n\t\t\t\t\t\tpParam->importTextureInfo.m_Width,\n\t\t\t\t\t\tpParam->importTextureInfo.m_Height))\n\t\t\t\t\t{\n\t\t\t\t\t\tpParam->importTextureData = std::move(newTextureData);\n\t\t\t\t\t\tpParam->textureDataModified = true;\n\t\t\t\t\t\tHWND hCKMipMap = GetDlgItem(hDlg, IDC_CKMIPMAP);\n\t\t\t\t\t\tif (IsPowerOfTwo(pParam->importTextureInfo.m_Width) &&\n\t\t\t\t\t\t\tIsPowerOfTwo(pParam->importTextureInfo.m_Height))\n\t\t\t\t\t\t\tButton_Enable(hCKMipMap, TRUE);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tButton_SetCheck(hCKMipMap, FALSE);\n\t\t\t\t\t\t\tButton_Enable(hCKMipMap, FALSE);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t\tMessageBox(hDlg, TEXT("Unable to open or process the file!"), TEXT("ERROR"), 16);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t\tcase IDOK:\n\t\t{\n\t\t\tTextureImportParam* pParam = (TextureImportParam*)GetWindowLongPtr(hDlg, GWLP_USERDATA);\n\t\t\tHWND hEName = GetDlgItem(hDlg, IDC_ENAME);\n\t\t\tHWND hCBTexFmt = GetDlgItem(hDlg, IDC_CBTEXFMT);\n\t\t\tHWND hCKMipMap = GetDlgItem(hDlg, IDC_CKMIPMAP);\n\t\t\tHWND hCKReadable = GetDlgItem(hDlg, IDC_CKREADABLE);\n\t\t\tHWND hCKReadAllowed = GetDlgItem(hDlg, IDC_CKREADALLOWED);\n\t\t\tHWND hCBFilterMode = GetDlgItem(hDlg, IDC_CBFILTERMODE);\n\t\t\tHWND hEAniso = GetDlgItem(hDlg, IDC_EANISO);\n\t\t\tHWND hEMipBias = GetDlgItem(hDlg, IDC_EMIPBIAS);\n\t\t\tHWND hCBWrapMode = GetDlgItem(hDlg, IDC_CBWRAPMODE);\n\t\t\tHWND hCBWrapModeU = GetDlgItem(hDlg, IDC_CBWRAPMODEU);\n\t\t\tHWND hCBWrapModeV = GetDlgItem(hDlg, IDC_CBWRAPMODEV);\n\t\t\tHWND hELightMapFmt = GetDlgItem(hDlg, IDC_ELIGHTMAPFMT);\n\t\t\tHWND hCBClSpace = GetDlgItem(hDlg, IDC_CBCLSPACE);\n\n\n\t\t\tEdit_GetText(hEName, tPrint, 128);\n\t\t\t{\n\t\t\t\tauto cNameBuffer = unique_TCHARToMultiByte(tPrint);\n\t\t\t\tpParam->batchInfo.newName.assign(cNameBuffer.get());\n\t\t\t}\n\n\t\t\tsize_t selection = (unsigned int)ComboBox_GetCurSel(hCBTexFmt);\n\t\t\tif (selection >= SupportedTextureNames_size || selection >= ComboBox_GetCount(hCBTexFmt)) selection = 0;\n\t\t\telse selection = (size_t)ComboBox_GetItemData(hCBTexFmt, selection);\n\t\t\tconst TextureNameIDPair* pTexFormatInfo = &SupportedTextureNames[selection];\n\n\t\t\tpParam->batchInfo.newTextureFormat = pTexFormatInfo->textureType;\n\t\t\t//Special case : TexFmt_BGRA32Old and TexFmt_BGRA32New.\n\t\t\tif ((pTexFormatInfo->textureType == TexFmt_BGRA32New\n\t\t\t\t  && pParam->asset.pFile->getAssetsFileContext()->getAssetsFile()->header.format < 0x0E))\n\t\t\t\tpParam->batchInfo.newTextureFormat = TexFmt_BGRA32Old;\n\n\t\t\tpParam->batchInfo.newMipMap = Button_GetCheck(hCKMipMap) ? true : false;\n\t\t\tpParam->batchInfo.newReadable = Button_GetCheck(hCKReadable) ? true : false;\n\t\t\tpParam->batchInfo.newReadAllowed = Button_GetCheck(hCKReadAllowed) ? true : false;\n\n\t\t\tTCHAR* endPtr = NULL;\n\n\t\t\tpParam->batchInfo.newFilterMode = ComboBox_GetCurSel(hCBFilterMode);\n\n\t\t\tEdit_GetText(hEAniso, tPrint, 128);\n\t\t\tint anisoLevel = (int)_tcstol(tPrint, &endPtr, 0);\n\t\t\tif (endPtr != tPrint)\n\t\t\t\tpParam->batchInfo.newAnisoLevel = anisoLevel;\n\n\t\t\tEdit_GetText(hEMipBias, tPrint, 128);\n\t\t\tfloat mipBias = (float)_tcstod(tPrint, &endPtr);\n\t\t\tif (endPtr != tPrint)\n\t\t\t\tpParam->batchInfo.newMipBias = mipBias;\n\n\t\t\tpParam->batchInfo.newWrapMode = ComboBox_GetCurSel(hCBWrapMode);\n\t\t\tpParam->batchInfo.newWrapModeU = ComboBox_GetCurSel(hCBWrapModeU);\n\t\t\tpParam->batchInfo.newWrapModeV = ComboBox_GetCurSel(hCBWrapModeV);\n\n\t\t\tEdit_GetText(hELightMapFmt, tPrint, 128);\n\t\t\tint lightMapFormat = (int)_tcstol(tPrint, &endPtr, 0);\n\t\t\tif (endPtr != tPrint)\n\t\t\t\tpParam->batchInfo.newLightmapFmt = lightMapFormat;\n\n\t\t\tpParam->batchInfo.newColorSpace = ComboBox_GetCurSel(hCBClSpace);\n\n\t\t\tif (pParam->batchInfo.isBatchEntry)\n\t\t\t{\n\t\t\t\tif (pParam->batchInfo.newName.compare(pParam->importTextureName)\n\t\t\t\t\t|| pParam->batchInfo.newTextureFormat != pParam->importTextureInfo.m_TextureFormat\n\t\t\t\t\t|| pParam->batchInfo.newMipMap != (pParam->importTextureInfo.m_MipMap || (pParam->importTextureInfo.m_MipCount > 1))\n\t\t\t\t\t|| pParam->batchInfo.newReadable != pParam->importTextureInfo.m_IsReadable\n\t\t\t\t\t|| pParam->batchInfo.newReadAllowed != pParam->importTextureInfo.m_ReadAllowed\n\t\t\t\t\t|| pParam->batchInfo.newFilterMode != pParam->importTextureInfo.m_TextureSettings.m_FilterMode\n\t\t\t\t\t|| pParam->batchInfo.newAnisoLevel != pParam->importTextureInfo.m_TextureSettings.m_Aniso\n\t\t\t\t\t|| pParam->batchInfo.newMipBias != pParam->importTextureInfo.m_TextureSettings.m_MipBias\n\t\t\t\t\t|| pParam->batchInfo.newWrapMode != pParam->importTextureInfo.m_TextureSettings.m_WrapMode\n\t\t\t\t\t|| pParam->batchInfo.newWrapModeU != pParam->importTextureInfo.m_TextureSettings.m_WrapU\n\t\t\t\t\t|| pParam->batchInfo.newWrapModeV != pParam->importTextureInfo.m_TextureSettings.m_WrapV\n\t\t\t\t\t|| pParam->batchInfo.newLightmapFmt != pParam->importTextureInfo.m_LightmapFormat\n\t\t\t\t\t|| pParam->batchInfo.newColorSpace != pParam->importTextureInfo.m_ColorSpace)\n\t\t\t\t{\n\t\t\t\t\tpParam->batchInfo.hasNewSettings = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\t/*if (pParam->batchInfo.newTextureFormat != pParam->importTextureInfo.m_TextureFormat\n\t\t\t\t|| pParam->batchInfo.batchFilenameOverride.size() > 0)*/\n\t\t\t{\n\t\t\t\tDialogBoxParam(g_hModule, MAKEINTRESOURCE(IDD_COMPQUALITY), hDlg, CompressQualityDlg, (LPARAM)pParam);\n\t\t\t}\n\t\t}\n\t\tcase IDCANCEL:\n\t\t\tEndDialog(hDlg, LOWORD(wParam));\n\t\t\treturn (INT_PTR)TRUE;\n\t\t}\n\t\tbreak;\n\t}\n\treturn (INT_PTR)FALSE;\n}\n\nvoid GetHideDialogElementsList(AssetTypeTemplateField* pTemplateBase, std::vector<size_t>& elementIndices)\n{\n\tif (!pTemplateBase->SearchChild("m_ReadAllowed"))\n\t\telementIndices.push_back(GetImportDialogPairByID(IDC_SREADALLOWED));\n\tif (!pTemplateBase->SearchChild("m_ColorSpace"))\n\t\telementIndices.push_back(GetImportDialogPairByID(IDC_SCLSPACE));\n\tAssetTypeTemplateField* pTextureSettings;\n\tif ((pTextureSettings = pTemplateBase->SearchChild("m_TextureSettings")))\n\t{\n\t\tif (!pTextureSettings->SearchChild("m_WrapMode"))\n\t\t\telementIndices.push_back(GetImportDialogPairByID(IDC_SWRAPMODE));\n\t\tif (!pTextureSettings->SearchChild("m_WrapU"))\n\t\t\telementIndices.push_back(GetImportDialogPairByID(IDC_SWRAPMODEU));\n\t\tif (!pTextureSettings->SearchChild("m_WrapV"))\n\t\t\telementIndices.push_back(GetImportDialogPairByID(IDC_SWRAPMODEV));\n\t}\n}\nvoid InitializeImportParam(TextureImportParam* pParam, AppContext& appContext)\n{\n\tpParam->batchInfo.hasNewSettings = false;\n\tAssetIdentifier& asset = pParam->asset;\n\n\tIAssetsReader_ptr pAssetReader = asset.makeReader(appContext);\n\tif (pAssetReader == nullptr)\n\t\treturn;\n\tQWORD assetSize = 0;\n\tif (!pAssetReader->Seek(AssetsSeek_End, 0) || !pAssetReader->Tell(assetSize) || !pAssetReader->Seek(AssetsSeek_Begin, 0))\n\t\treturn;\n\n\tAssetTypeTemplateField templateBase;\n\tif (!asset.pFile->MakeTemplateField(&templateBase, appContext, asset.getClassID(), asset.getMonoScriptID(), &asset))\n\t\treturn;\n\tAssetTypeTemplateField* pTemplateBase = &templateBase;\n\n\tAssetTypeInstance assetInstance(1, &pTemplateBase, assetSize, pAssetReader.get(), asset.isBigEndian());\n\tAssetTypeValueField* pBaseField = assetInstance.GetBaseField();\n\tif (pBaseField == nullptr || pBaseField->IsDummy())\n\t\treturn;\n\tpAssetReader.reset();\n\n\tGetHideDialogElementsList(pTemplateBase, pParam->hideDialogElementsList);\n\n\tTextureFile textureFile;\n\tif (!ReadTextureFile(&textureFile, pBaseField))\n\t\treturn;\n\n\t//Retrieve texture format version.\n\tSupportsTextureFormat(asset.pFile->getAssetsFileContext()->getAssetsFile(),\n\t\t(TextureFormat)textureFile.m_TextureFormat,\n\t\ttextureFile.extra.textureFormatVersion);\n\n\tpParam->importTextureName.assign(textureFile.m_Name);\n\tpParam->importTextureInfo = textureFile;\n\t//pParam->importTextureInfo.m_Name.clear();\n\n\tpParam->assignCompressedTextureData(std::vector<uint8_t>(pParam->importTextureInfo._pictureDataSize));\n\tmemcpy(pParam->importTextureInfo.pPictureData, textureFile.pPictureData, pParam->importTextureInfo._pictureDataSize);\n\n\tpParam->assetWasTextureFile = true;\n\tpParam->batchInfo.newName.assign(pParam->importTextureName);\n\tpParam->batchInfo.newTextureFormat = pParam->importTextureInfo.m_TextureFormat;\n\tpParam->batchInfo.newMipMap = pParam->importTextureInfo.m_MipMap || (pParam->importTextureInfo.m_MipCount > 1);\n\tpParam->batchInfo.newReadable = pParam->importTextureInfo.m_IsReadable;\n\tpParam->batchInfo.newReadAllowed = pParam->importTextureInfo.m_ReadAllowed;\n\tpParam->batchInfo.newFilterMode = pParam->importTextureInfo.m_TextureSettings.m_FilterMode;\n\tpParam->batchInfo.newAnisoLevel = pParam->importTextureInfo.m_TextureSettings.m_Aniso;\n\tpParam->batchInfo.newMipBias = pParam->importTextureInfo.m_TextureSettings.m_MipBias;\n\tpParam->batchInfo.newWrapMode = pParam->importTextureInfo.m_TextureSettings.m_WrapMode;\n\tpParam->batchInfo.newWrapModeU = pParam->importTextureInfo.m_TextureSettings.m_WrapU;\n\tpParam->batchInfo.newWrapModeV = pParam->importTextureInfo.m_TextureSettings.m_WrapV;\n\tpParam->batchInfo.newLightmapFmt = pParam->importTextureInfo.m_LightmapFormat;\n\tpParam->batchInfo.newColorSpace = pParam->importTextureInfo.m_ColorSpace;\n}\nvoid OpenImportDialog(HWND hParentWnd, TextureImportParam* pParam)\n{\n\tDialogBoxParam(g_hModule, MAKEINTRESOURCE(IDD_IMPORT), hParentWnd, ImportDlg, (LPARAM)pParam);\n}\n\nclass TextureBatchImportDialogDesc : public CGenericBatchImportDialogDesc, public IWin32AssetBatchImportDesc\n{\n\tWin32AppContext& appContext;\npublic:\n\tstd::vector<std::unique_ptr<TextureImportParam>> importParameters;\npublic:\n\tinline TextureBatchImportDialogDesc(Win32AppContext& appContext, std::vector<AssetUtilDesc> _elements, const std::string& extensionRegex)\n\t\t: CGenericBatchImportDialogDesc(std::move(_elements), extensionRegex),\n\t\tappContext(appContext)\n\t{\n\t\timportParameters.resize(getElements().size());\n\t}\n\tbool hasAnyChanges()\n\t{\n\t\treturn std::any_of(importParameters.begin(), importParameters.end(), [](const auto& x) {return x != nullptr; })\n\t\t\t|| std::any_of(importFilePathOverrides.begin(), importFilePathOverrides.end(), [](const auto& x) {return !x.empty(); });\n\t}\n\n\tbool ShowAssetSettings(IN size_t matchIndex, IN HWND hParentWindow)\n\t{\n\t\tif (matchIndex == (size_t)-1)\n\t\t\treturn true;\n\t\tif (matchIndex >= importParameters.size() || matchIndex >= getElements().size() || matchIndex >= importFilePathOverrides.size())\n\t\t\treturn false;\n\t\tstd::unique_ptr<TextureImportParam>& pImportParam = importParameters[matchIndex];\n\t\tif (pImportParam == nullptr)\n\t\t{\n\t\t\tpImportParam.reset(new TextureImportParam(getElements()[matchIndex].asset, false, true));\n\t\t\tInitializeImportParam(pImportParam.get(), appContext);\n\t\t}\n\n\t\tpImportParam->batchInfo.batchFilenameOverride.clear();\n\n\t\tOpenImportDialog(hParentWindow, pImportParam.get());\n\n\t\timportFilePathOverrides[matchIndex].assign(pImportParam->batchInfo.batchFilenameOverride);\n\t\tif (!pImportParam->batchInfo.hasNewSettings && !pImportParam->textureDataModified && !pImportParam->qualitySelected)\n\t\t\tpImportParam.reset();\n\t\treturn true;\n\t\treturn false; //TODO\n\t}\n};\n\nclass TextureEditTask : public ITask\n{\n\tAppContext& appContext;\n\tstd::unique_ptr<TextureBatchImportDialogDesc> pDialogDesc;\n\tstd::string taskName;\n\tTypeTemplateCache templateCache;\npublic:\n\tTextureEditTask(AppContext& appContext, std::unique_ptr<TextureBatchImportDialogDesc> _pDialogDesc)\n\t\t: appContext(appContext), pDialogDesc(std::move(_pDialogDesc)), taskName("Edit Textures")\n\t{}\n\tconst std::string& getName()\n\t{\n\t\treturn taskName;\n\t}\n\tTaskResult execute(TaskProgressManager& progressManager)\n\t{\n\t\tunsigned int progressRange = static_cast<unsigned int>(std::min<size_t>(pDialogDesc->importParameters.size(), 10000));\n\t\tsize_t assetsPerProgressStep = pDialogDesc->importParameters.size() / progressRange;\n\t\tconstexpr size_t assetsPerDescUpdate = 8;\n\t\tprogressManager.setCancelable();\n\t\tprogressManager.setProgress(0, progressRange);\n\t\tauto lastDescTime = std::chrono::high_resolution_clock::now();\n\t\tbool encounteredErrors = false;\n\t\tfor (size_t i = 0; i < pDialogDesc->importParameters.size(); ++i)\n\t\t{\n\t\t\tif (progressManager.isCanceled())\n\t\t\t\treturn TaskResult_Canceled;\n\t\t\tif ((i % assetsPerProgressStep) == 0)\n\t\t\t\tprogressManager.setProgress((unsigned int)(i / assetsPerProgressStep), progressRange);\n\t\t\tauto curTime = std::chrono::high_resolution_clock::now();\n\t\t\tif (i == 0 || std::chrono::duration_cast<std::chrono::milliseconds>(curTime - lastDescTime).count() >= 500)\n\t\t\t{\n\t\t\t\tprogressManager.setProgressDesc(std::format("Importing {}/{}", (i + 1), pDialogDesc->importParameters.size()));\n\t\t\t\tlastDescTime = curTime;\n\t\t\t}\n\t\t\tconst AssetIdentifier& asset = pDialogDesc->getElements()[i].asset;\n\t\t\tstd::unique_ptr<TextureImportParam> &pImportParam = pDialogDesc->importParameters[i];\n\t\t\tif (pImportParam == nullptr)\n\t\t\t{\n\t\t\t\tpImportParam.reset(new TextureImportParam(asset, false, true));\n\t\t\t\tInitializeImportParam(pImportParam.get(), appContext);\n\t\t\t}\n\n\t\t\tpImportParam->batchInfo.batchFilenameOverride = pDialogDesc->getImportFilePath(i);\n\t\t\ttry {\n\t\t\t\tFinalizeTextureEdit(pImportParam.get(), progressManager);\n\t\t\t}\n\t\t\tcatch (AssetUtilError err) {\n\t\t\t\tprogressManager.logMessage(std::format(\n\t\t\t\t\t"Error importing an asset (File ID {0}, Path ID {1}): {2}",\n\t\t\t\t\tasset.fileID, (int64_t)asset.pathID, err.what()));\n\t\t\t\tencounteredErrors = true;\n\t\t\t}\n\t\t\tpImportParam.reset();\n\t\t}\n\t\treturn (TaskResult)(encounteredErrors ? -2 : 0);\n\n\t}\n\n\t//Set pParam->batchInfo.batchFilenameOverride to the import file name.\n\tvoid FinalizeTextureEdit(TextureImportParam* pParam, TaskProgressManager &progressManager)\n\t{\n\t\tsize_t textureTypeIndex;\n\t\tif (pParam->batchInfo.newTextureFormat == TexFmt_BGRA32Old)\n\t\t\ttextureTypeIndex = GetTextureNameIDPair(TexFmt_BGRA32New, pParam->importTextureInfo.extra.textureFormatVersion);\n\t\telse\n\t\t\ttextureTypeIndex = GetTextureNameIDPair(pParam->batchInfo.newTextureFormat, pParam->importTextureInfo.extra.textureFormatVersion);\n\t\tif (textureTypeIndex == (size_t)-1)\n\t\t\tthrow AssetUtilError("Unable to determine the texture format.");\n\n\t\tconst TextureNameIDPair* pTexFormatInfo = &SupportedTextureNames[textureTypeIndex];\n\t\tunsigned int newWidth = pParam->importTextureInfo.m_Width;\n\t\tunsigned int newHeight = pParam->importTextureInfo.m_Height;\n\t\tstd::vector<uint8_t> &newTextureData = pParam->importTextureData;\n\t\tif (!pParam->batchInfo.batchFilenameOverride.empty())\n\t\t{\n\t\t\t//Load the given texture file.\n\t\t\tLoadTextureFromFile(pParam->batchInfo.batchFilenameOverride.c_str(), newTextureData, newWidth, newHeight);\n\t\t\tpParam->importTextureInfo.pPictureData = NULL;\n\t\t\tpParam->textureDataModified = true;\n\t\t}\n\n\t\tbool oldMipMap = pParam->importTextureInfo.m_MipMap || (pParam->importTextureInfo.m_MipCount > 1);\n\t\tbool newMipMap = pParam->batchInfo.newMipMap &&\n\t\t\tIsPowerOfTwo(newWidth) &&\n\t\t\tIsPowerOfTwo(newHeight);\n\n\t\tbool generateTextureData = pParam->textureDataModified\n\t\t\t|| (pParam->importTextureInfo.m_TextureFormat != pParam->batchInfo.newTextureFormat);\n\t\t//|| (newMipMap != oldMipMap));\n\t\tif (newMipMap && !oldMipMap)\n\t\t\tgenerateTextureData = true;\n\n\t\tsize_t newTextureDataSize = 0;\n\t\tunsigned int mipCount = pParam->importTextureInfo.m_MipCount;\n\t\tif (generateTextureData)\n\t\t{\n\t\t\tunsigned int curWidth = newWidth;\n\t\t\tunsigned int curHeight = newHeight;\n\n\t\t\tmipCount = 0;\n\t\t\tdo\n\t\t\t{\n\t\t\t\tsize_t curTextureDataSize = GetTextureDataSize(pTexFormatInfo, curWidth, curHeight);\n\n\t\t\t\tnewTextureDataSize += curTextureDataSize;\n\t\t\t\tmipCount++;\n\t\t\t\tif ((curWidth >>= 1) >= 1 || (curHeight >>= 1) >= 1)\n\t\t\t\t{\n\t\t\t\t\tif (curWidth == 0)\n\t\t\t\t\t\tcurWidth = 1;\n\t\t\t\t\telse if (curHeight == 0)\n\t\t\t\t\t\tcurHeight = 1;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tbreak;\n\t\t\t} while (newMipMap);\n\n\t\t\t//Decode the current texture data if necessary.\n\t\t\tif (newTextureDataSize > 0 && newTextureDataSize <= 0xFFFFFFFFULL\n\t\t\t\t&& (pParam->importTextureInfo.pPictureData != NULL\n\t\t\t\t\t|| (pParam->importTextureData.empty()\n\t\t\t\t\t\t&& pParam->importTextureInfo._pictureDataSize == 0\n\t\t\t\t\t\t&& pParam->importTextureInfo.m_StreamData.size > 0)))\n\t\t\t{\n\t\t\t\tif (pParam->importTextureInfo.pPictureData != pParam->importTextureData.data()\n\t\t\t\t\t|| pParam->importTextureInfo._pictureDataSize != pParam->importTextureData.size())\n\t\t\t\t\tthrow std::runtime_error("FinalizeTextureEdit: Unexpected texture data reference.");\n\t\t\t\tstd::vector<uint8_t> compressedTextureData;\n\t\t\t\tif (pParam->importTextureInfo._pictureDataSize == 0\n\t\t\t\t\t&& (pParam->importTextureInfo.m_Width * pParam->importTextureInfo.m_Height) > 0 &&\n\t\t\t\t\tpParam->importTextureInfo.m_StreamData.size > 0)\n\t\t\t\t{\n\t\t\t\t\t//Load the texture from the referred resource.\n\t\t\t\t\tpParam->importTextureInfo.pPictureData = NULL;\n\t\t\t\t\tauto pResourcesFile = FindResourcesFile(appContext, pParam->importTextureInfo.m_StreamData.path, pParam->asset, progressManager);\n\t\t\t\t\t//Non-null guaranteed by FindResourcesFile (AssetUtilError thrown otherwise).\n\n\t\t\t\t\tstd::shared_ptr<IAssetsReader> pStreamReader = pResourcesFile->getResource(pResourcesFile,\n\t\t\t\t\t\tpParam->importTextureInfo.m_StreamData.offset,\n\t\t\t\t\t\tpParam->importTextureInfo.m_StreamData.size);\n\t\t\t\t\tif (pStreamReader == nullptr)\n\t\t\t\t\t\tthrow AssetUtilError("Unable to locate the texture resource.");\n\n\t\t\t\t\tcompressedTextureData.resize(pParam->importTextureInfo.m_StreamData.size);\n\t\t\t\t\tif (pStreamReader->Read(0, pParam->importTextureInfo.m_StreamData.size, compressedTextureData.data())\n\t\t\t\t\t\t!= pParam->importTextureInfo.m_StreamData.size)\n\t\t\t\t\t\tthrow AssetUtilError("Unable to read data from the texture resource.");\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tcompressedTextureData = pParam->importTextureData;\n\t\t\t\tif (!compressedTextureData.empty())\n\t\t\t\t{\n\t\t\t\t\t//Decode the texture data.\n\t\t\t\t\tnewTextureData.resize((size_t)pParam->importTextureInfo.m_Width * pParam->importTextureInfo.m_Height * 4);\n\n\t\t\t\t\tpParam->importTextureInfo.pPictureData = compressedTextureData.data();\n\t\t\t\t\tpParam->importTextureInfo._pictureDataSize = pParam->importTextureInfo.m_StreamData.size;\n\n\t\t\t\t\t//Retrieve the texture format version.\n\t\t\t\t\tSupportsTextureFormat(pParam->asset.pFile->getAssetsFileContext()->getAssetsFile(),\n\t\t\t\t\t\t(TextureFormat)0,\n\t\t\t\t\t\tpParam->importTextureInfo.extra.textureFormatVersion);\n\t\t\t\t\tif (!GetTextureData(&pParam->importTextureInfo, newTextureData.data()))\n\t\t\t\t\t\tthrow AssetUtilError("Unable to decode the texture.");\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tthrow AssetUtilError("Unable to find the compressed texture data.");\n\t\t\t\tpParam->importTextureInfo.pPictureData = NULL;\n\t\t\t\tpParam->importTextureInfo.m_StreamData.offset = pParam->importTextureInfo.m_StreamData.size = 0;\n\t\t\t\tpParam->importTextureInfo.m_StreamData.path.clear();\n\t\t\t}\n\t\t}\n\n\t\t\n\t\tstd::unique_ptr<IAssetsWriterToMemory> pWriter(Create_AssetsWriterToMemory());\n\t\tAssetTypeTemplateField &templateBase = templateCache.getTemplateField(appContext, pParam->asset);\n\n\t\tpParam->importTextureName = pParam->batchInfo.newName;\n\t\tpParam->importTextureInfo.m_TextureFormat = pParam->batchInfo.newTextureFormat;\n\t\tpParam->importTextureInfo.m_MipMap = pParam->batchInfo.newMipMap;\n\t\tpParam->importTextureInfo.m_MipCount = mipCount;\n\t\tpParam->importTextureInfo.m_IsReadable = pParam->batchInfo.newReadable;\n\t\tpParam->importTextureInfo.m_ReadAllowed = pParam->batchInfo.newReadAllowed;\n\t\tpParam->importTextureInfo.m_TextureSettings.m_FilterMode = pParam->batchInfo.newFilterMode;\n\t\tpParam->importTextureInfo.m_TextureSettings.m_Aniso = pParam->batchInfo.newAnisoLevel;\n\t\tpParam->importTextureInfo.m_TextureSettings.m_MipBias = pParam->batchInfo.newMipBias;\n\t\tpParam->importTextureInfo.m_TextureSettings.m_WrapMode = pParam->batchInfo.newWrapMode;\n\t\tpParam->importTextureInfo.m_TextureSettings.m_WrapU = pParam->batchInfo.newWrapModeU;\n\t\tpParam->importTextureInfo.m_TextureSettings.m_WrapV = pParam->batchInfo.newWrapModeV;\n\t\tpParam->importTextureInfo.m_LightmapFormat = pParam->batchInfo.newLightmapFmt;\n\t\tpParam->importTextureInfo.m_ColorSpace = pParam->batchInfo.newColorSpace;\n\n\t\tpParam->importTextureInfo.m_Width = newWidth;\n\t\tpParam->importTextureInfo.m_Height = newHeight;\n\n\t\tstd::vector<uint8_t> recompressedTextureDataBuf;\n\t\tbool dataFormatValid = true;\n\t\tif (generateTextureData && !newTextureData.empty())\n\t\t{\n\t\t\t//Compress the texture data.\n\t\t\trecompressedTextureDataBuf.resize((newTextureDataSize + 3) & (~3), 0);\n\t\t\tpParam->importTextureInfo.pPictureData = recompressedTextureDataBuf.data();\n\t\t\tpParam->importTextureInfo._pictureDataSize = (newTextureDataSize + 3) & (~3);\n\t\t\tpParam->importTextureInfo.m_StreamData.path.clear();\n\t\t\tpParam->importTextureInfo.m_StreamData.offset = 0;\n\t\t\tpParam->importTextureInfo.m_StreamData.size = 0;\n\t\t\tif (!pParam->qualitySelected)\n\t\t\t{\n\t\t\t\tpParam->qualitySelection = ePVRTCFastest;\n\t\t\t\tstd::vector<const wchar_t*> presetNames;\n\t\t\t\tsize_t defaultPresetIdx = GetQualityPresetList(pParam->importTextureInfo.m_TextureFormat, presetNames);\n\t\t\t\tif (defaultPresetIdx < presetNames.size() && presetNames.size() < 0x7FFFFFFF)\n\t\t\t\t{\n\t\t\t\t\tpParam->qualitySelection = GetQualityFromPresetListIdx(pParam->importTextureInfo.m_TextureFormat, defaultPresetIdx);\n\t\t\t\t}\n\t\t\t}\n\t\t\t//update the texture format version\n\t\t\tSupportsTextureFormat(pParam->asset.pFile->getAssetsFileContext()->getAssetsFile(),\n\t\t\t\t(TextureFormat)0,\n\t\t\t\tpParam->importTextureInfo.extra.textureFormatVersion);\n\t\t\tdataFormatValid = MakeTextureData(&pParam->importTextureInfo, newTextureData.data(), pParam->qualitySelection);\n\t\t}\n\n\t\tif (!dataFormatValid\n\t\t\t|| (pParam->importTextureInfo.pPictureData == NULL && pParam->importTextureInfo._pictureDataSize > 0))\n\t\t\tthrow AssetUtilError("Unable to convert the texture data.");\n\t\t//Replace the texture.\n\t\tpParam->importTextureInfo.m_Name = pParam->importTextureName;\n\n\t\t{\n\t\t\tstd::vector<std::unique_ptr<uint8_t[]>> textureValueFieldMemory;\n\t\t\tAssetTypeValueField* pTextureBase = CreateEmptyValueFieldFromTemplate(&templateBase, textureValueFieldMemory);\n\t\t\tif (!WriteTextureFile(&pParam->importTextureInfo, pTextureBase, textureValueFieldMemory))\n\t\t\t\tthrow AssetUtilError("Unable to serialize the texture file. Is the class database invalid?");\n\n\t\t\tQWORD newTextureFileSize = pTextureBase->Write(pWriter.get(), 0, pParam->asset.isBigEndian());\n\t\t\tif (newTextureFileSize == 0)\n\t\t\t\tthrow AssetUtilError("Unable to write the texture file. Is the class database invalid?");\n\t\t}\n\n\t\tQWORD writerPos = 0; size_t writerSize = 0;\n\t\tvoid* pWriterBuf = NULL;\n\t\tpWriter->GetBuffer(pWriterBuf, writerSize);\n\t\tpWriter->Tell(writerPos);\n\n\t\tstd::shared_ptr<AssetsEntryReplacer> pReplacer(MakeAssetModifierFromMemory(0, pParam->asset.pathID,\n\t\t\tpParam->asset.getClassID(), pParam->asset.getMonoScriptID(),\n\t\t\tpWriterBuf, writerSize, Free_AssetsWriterToMemory_DynBuf));\n\t\tif (pReplacer == nullptr)\n\t\t\tthrow AssetUtilError("Unexpected runtime error.");\n\t\tpWriter->SetFreeBuffer(false);\n\t\tpParam->asset.pFile->addReplacer(pReplacer, appContext);\n\t}\n};\n\nclass TextureEditModifyDialog : public AssetModifyDialog\n{\n\tCBatchImportDialog batchImportDialog;\n\tstd::unique_ptr<TextureBatchImportDialogDesc> pDialogDesc;\n\tWin32AppContext &appContext;\n\tAssetListDialog &listDialog;\npublic:\n\tTextureEditModifyDialog(std::unique_ptr<TextureBatchImportDialogDesc> _pDialogDesc, std::string _basePath,\n\t\tWin32AppContext &appContext, AssetListDialog& listDialog)\n\t\t: batchImportDialog(appContext.getMainWindow().getHInstance(), _pDialogDesc.get(), _pDialogDesc.get(), std::move(_basePath)),\n\t\t  pDialogDesc(std::move(_pDialogDesc)),\n\t\t  appContext(appContext), listDialog(listDialog)\n\t{\n\t\tbatchImportDialog.SetCloseCallback([this,&listDialog,&appContext](bool apply)\n\t\t\t{\n\t\t\t\tif (apply && pDialogDesc != nullptr)\n\t\t\t\t{\n\t\t\t\t\tauto pTask = std::make_shared<TextureEditTask>(appContext, std::move(pDialogDesc));\n\t\t\t\t\tappContext.taskManager.enqueue(pTask);\n\t\t\t\t}\n\t\t\t\tbatchImportDialog.SetCloseCallback(nullptr);\n\t\t\t\tlistDialog.removeModifyDialog(this);\n\t\t\t}\n\t\t);\n\t}\n\tvirtual ~TextureEditModifyDialog() {}\n\t//Called when the user requests to close the tab.\n\t//Returns true if there are unsaved changes, false otherwise.\n\t//If the function will return true and applyable is not null,\n\t// *applyable will be set to true iff applyNow() is assumed to succeed without further interaction\n\t// (e.g. all fields in the dialog have a valid value, ...).\n\t//The caller uses this info to decide whether and how it should display a confirmation dialog before proceeding.\n\tvirtual bool hasUnappliedChanges(bool* applyable)\n\t{\n\t\tif (applyable) *applyable = false;\n\t\treturn true;\n\t}\n\t//Called when the user requests to apply the changes (e.g. selecting Apply, Save or Save All in the menu).\n\t//Returns whether the changes have been applied;\n\t// if true, the caller may continue closing the AssetModifyDialog.\n\t// if false, the caller shall stop closing the AssetModifyDialog.\n\t//Note: applyChanges() is expected to notify the user about errors (e.g. via MessageBox).\n\tvirtual bool applyChanges()\n\t{\n\t\treturn false;\n\t}\n\tvirtual std::string getTabName()\n\t{\n\t\treturn "Edit textures";\n\t}\n\tvirtual HWND getWindowHandle()\n\t{\n\t\treturn batchImportDialog.getWindowHandle();\n\t}\n\t//Called for unhandled WM_COMMAND messages. Returns true if this dialog has handled the request, false otherwise.\n\tvirtual bool onCommand(WPARAM wParam, LPARAM lParam)\n\t{\n\t\treturn false;\n\t}\n\t//message : currently only WM_KEYDOWN; keyCode : VK_F3 for instance\n\tvirtual void onHotkey(ULONG message, DWORD keyCode)\n\t{\n\t\treturn;\n\t}\n\t//Called when the dialog is to be shown. The parent window will not change before the next onHide call.\n\tvirtual void onShow(HWND hParentWnd)\n\t{\n\t\tbatchImportDialog.ShowModeless(hParentWnd);\n\t}\n\t//Called when the dialog is to be hidden, either because of a tab switch or while closing the tab.\n\tvirtual void onHide()\n\t{\n\t\tbatchImportDialog.Hide();\n\t}\n\t//Called when the tab is about to be destroyed.\n\t//Once this function is called, AssetListDialog::removeModifyDialog must not be used for this dialog.\n\tvirtual void onDestroy()\n\t{\n\t\tbatchImportDialog.SetCloseCallback(nullptr);\n\t}\n};\nclass Win32TextureEditProvider : public IAssetListTabOptionProvider\n{\npublic:\n\tclass Runner : public IOptionRunner\n\t{\n\t\tWin32AppContext& appContext;\n\t\tAssetListDialog& listDialog;\n\t\tstd::vector<AssetUtilDesc> selection;\n\tpublic:\n\t\tRunner(Win32AppContext& appContext, AssetListDialog& listDialog, std::vector<AssetUtilDesc> _selection)\n\t\t\t: appContext(appContext), listDialog(listDialog), selection(std::move(_selection))\n\t\t{}\n\t\tvoid operator()()\n\t\t{\n\t\t\tauto pDialogDesc = std::make_unique<TextureBatchImportDialogDesc>(appContext, std::move(selection), "\\\\.(?:tga|png)");\n\t\t\tif (pDialogDesc->getElements().size() > 1)\n\t\t\t{\n\t\t\t\tWCHAR* folderPathW = nullptr;\n\t\t\t\tif (!ShowFolderSelectDialog(appContext.getMainWindow().getWindow(), &folderPathW, L"Select an input directory", UABE_FILEDIALOG_EXPIMPASSET_GUID))\n\t\t\t\t\treturn;\n\t\t\t\tauto folderPath8 = unique_WideToMultiByte(folderPathW);\n\t\t\t\tFreeCOMFilePathBuf(&folderPathW);\n\n\t\t\t\tauto pModifyDialog = std::make_shared<TextureEditModifyDialog>(std::move(pDialogDesc), folderPath8.get(), appContext, listDialog);\n\t\t\t\tlistDialog.addModifyDialog(pModifyDialog);\n\t\t\t\t\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (pDialogDesc->ShowAssetSettings(0, appContext.getMainWindow().getWindow())\n\t\t\t\t\t&& pDialogDesc->hasAnyChanges())\n\t\t\t\t{\n\t\t\t\t\tauto pTask = std::make_shared<TextureEditTask>(appContext, std::move(pDialogDesc));\n\t\t\t\t\tappContext.taskManager.enqueue(pTask);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n\tEAssetOptionType getType()\n\t{\n\t\treturn EAssetOptionType::Import;\n\t}\n\tstd::unique_ptr<IOptionRunner> prepareForSelection(\n\t\tWin32AppContext& appContext, AssetListDialog& listDialog,\n\t\tstd::vector<AssetUtilDesc> selection,\n\t\tstd::string& optionName)\n\t{\n\t\tif (!PluginSupportsElements(selection))\n\t\t\treturn nullptr;\n\t\toptionName = "Edit";\n\t\treturn std::make_unique<Runner>(appContext, listDialog, std::move(selection));\n\t}\n};\n\nclass Win32TexturePluginDesc : public GenericTexturePluginDesc\n{\npublic:\n\tWin32TexturePluginDesc()\n\t\t: GenericTexturePluginDesc()\n\t{\n\t\tpProviders.push_back(std::make_shared<Win32TextureEditProvider>());\n\t}\n};\n\nIPluginDesc* GetUABEPluginDesc1(size_t sizeof_AppContext, size_t sizeof_BundleFileContextInfo)\n{\n\tif (sizeof_AppContext != sizeof(AppContext) || sizeof_BundleFileContextInfo != sizeof(BundleFileContextInfo))\n\t{\n\t\tassert(false);\n\t\treturn nullptr;\n\t}\n\treturn new Win32TexturePluginDesc();\n}\n\nBOOL APIENTRY DllMain(HMODULE hModule,\n\tDWORD  ul_reason_for_call,\n\tLPVOID lpReserved\n)\n{\n\tswitch (ul_reason_for_call)\n\t{\n\tcase DLL_PROCESS_ATTACH:\n\t\tg_hModule = hModule;\n\t\tbreak;\n\tcase DLL_THREAD_ATTACH:\n\tcase DLL_THREAD_DETACH:\n\tcase DLL_PROCESS_DETACH:\n\t\tbreak;\n\t}\n\treturn TRUE;\n}\n'