b'#include "stdafx.h"\n#include "Win32TaskStatusTracker.h"\n#include <array>\n#include "resource.h"\n#include <windowsx.h>\n#include "../libStringConverter/convert.h"\n\nstatic int GetTextExtent(HWND hListBox, const TCHAR* text)\n{\n\tHDC hListDC = GetDC(hListBox);\n\tHGDIOBJ hOrigObject = SelectObject(hListDC, GetWindowFont(hListBox));\n\tRECT textRect = {};\n\tDrawText(hListDC, text, -1, &textRect, DT_SINGLELINE | DT_CALCRECT);\n\tSelectObject(hListDC, hOrigObject);\n\tReleaseDC(hListBox, hListDC);\n\n\treturn textRect.right - textRect.left + 4;\n}\n\nstatic std::string processLogEntry(const std::string& text)\n{\n\t//Convert "\\n" (LF) line ends to "\\r\\n" (CRLF).\n\tstd::string outText;\n\tsize_t curLineEnd = SIZE_MAX; size_t prevLineEnd = 0;\n\twhile (curLineEnd = text.find_first_of(\'\\n\', curLineEnd + 1), curLineEnd != std::string::npos)\n\t{\n\t\toutText += text.substr(prevLineEnd, curLineEnd - prevLineEnd);\n\t\tif (curLineEnd == 0 || text[curLineEnd - 1] != \'\\r\')\n\t\t\toutText += \'\\r\';\n\t\tprevLineEnd = curLineEnd;\n\t}\n\toutText += text.substr(prevLineEnd);\n\treturn outText;\n}\nbool Win32TaskStatusTracker::dlgAddLogText(const std::string& text)\n{\n\tif (hDlg == NULL)\n\t\treturn false;\n\tHWND hWndStatus = GetDlgItem(hDlg, IDC_EDITSTATUS);\n\n\tint editLen = Edit_GetTextLength(hWndStatus);\n\tassert(editLen >= 0);\n\tif (editLen < 0)\n\t\treturn false;\n\tint oldSelStart = editLen;\n\tint oldSelEnd = editLen;\n\tSendMessage(hWndStatus, EM_GETSEL, (WPARAM)&oldSelStart, (LPARAM)&oldSelEnd);\n\n\tstd::string outText = processLogEntry(text);\n\tsize_t outTextTLen = 0;\n\tauto pOutTextT = unique_MultiByteToTCHAR(outText.c_str(), outTextTLen);\n\tif (outTextTLen > INT_MAX || (INT_MAX - outTextTLen) < editLen)\n\t\treturn false;\n\n\tEdit_SetSel(hWndStatus, editLen, editLen);\n\tEdit_ReplaceSel(hWndStatus, pOutTextT.get());\n\n\tif ((oldSelEnd != editLen) || (oldSelStart != oldSelEnd))\n\t\tEdit_SetSel(hWndStatus, oldSelStart, oldSelEnd);\n\telse\n\t\tEdit_SetSel(hWndStatus, -1, -1);\n\n\treturn true;\n}\nbool Win32TaskStatusTracker::dlgPutLogText(TaskStatusDesc* pDesc)\n{\n\tif (hDlg == NULL)\n\t\treturn false;\n\tHWND hWndStatus = GetDlgItem(hDlg, IDC_EDITSTATUS);\n\n\tstd::basic_string<TCHAR> fullLog;\n\tfor (const std::string& message : pDesc->messages)\n\t{\n\t\tstd::string text = processLogEntry(message);\n\t\tsize_t textTLen = 0;\n\t\tauto pTextT = unique_MultiByteToTCHAR(text.c_str(), textTLen);\n\t\tfullLog.insert(fullLog.end(), pTextT.get(), pTextT.get() + textTLen);\n\t}\n\tif (fullLog.size() >= INT_MAX)\n\t{\n\t\tEdit_SetText(hWndStatus, TEXT(""));\n\t\treturn false;\n\t}\n\tEdit_SetText(hWndStatus, fullLog.c_str());\n\tEdit_SetSel(hWndStatus, -1, -1);\n\tnumShownLogEntries = pDesc->messages.size();\n\treturn true;\n}\ninline auto getListCtrls(HWND hDlg)\n{\n\treturn std::array{ GetDlgItem(hDlg, IDC_LISTRUNNING), GetDlgItem(hDlg, IDC_LISTCOMPLETE) };\n}\nbool Win32TaskStatusTracker::dlgFindListCtrlFor(TaskStatusDesc* pDesc, HWND& hList, int& listIdx)\n{\n\tassert(pDesc != nullptr);\n\thList = NULL;\n\tlistIdx = 0;\n\tif (hDlg == NULL || pDesc == nullptr)\n\t\treturn false;\n\t\n\tauto listCtrls = getListCtrls(hDlg);\n\t\n\tfor (size_t i = 0; i < listCtrls.size(); ++i)\n\t{\n\t\tHWND hListCtrl = listCtrls[i];\n\t\tassert(hListCtrl != NULL);\n\t\tif (hListCtrl == NULL)\n\t\t\tcontinue;\n\t\tint iItem = (int)dlgGetListIdx(pDesc);\n\n\t\tint numItems = ListBox_GetCount(hListCtrl);\n\t\tif (numItems >= 0 && numItems > iItem\n\t\t\t&& (ListBox_GetItemData(hListCtrl, iItem) == (LRESULT)pDesc))\n\t\t{\n\t\t\thList = hListCtrl;\n\t\t\tlistIdx = iItem;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\nvoid Win32TaskStatusTracker::dlgSwitchShownTask(TaskStatusDesc* pDesc)\n{\n\tif (hDlg == NULL)\n\t\treturn;\n\tif (processingSelection)\n\t\treturn;\n\tHWND hListComplete = GetDlgItem(hDlg, IDC_LISTCOMPLETE);\n\tbool hasAnyCompleteItems = (ListBox_GetCount(hListComplete) > 0);\n\tEnableWindow(GetDlgItem(hDlg, IDC_CLEARALL), hasAnyCompleteItems ? TRUE : FALSE);\n\n\tauto listCtrls = getListCtrls(hDlg);\n\tif (pDesc == nullptr)\n\t{\n\t\tprocessingSelection = true;\n\t\tfor (size_t i = 0; i < listCtrls.size(); ++i)\n\t\t\tListBox_SetCurSel(listCtrls[i], -1);\n\t\tprocessingSelection = false;\n\t\tnumShownLogEntries = 0;\n\t\tShowWindow(GetDlgItem(hDlg, IDC_EDITSTATUS), SW_HIDE);\n\t\tShowWindow(GetDlgItem(hDlg, IDC_PROG), SW_HIDE);\n\t\tShowWindow(GetDlgItem(hDlg, IDC_SDESC), SW_HIDE);\n\t\tEnableWindow(GetDlgItem(hDlg, IDC_CLEAR), FALSE);\n\t\tEnableWindow(GetDlgItem(hDlg, IDC_CANCELTASK), FALSE);\n\t\treturn;\n\t}\n\tHWND hListCtrl = NULL; int listIdx = 0;\n\tif (!dlgFindListCtrlFor(pDesc, hListCtrl, listIdx))\n\t\treturn;\n\tif (hListCtrl == GetDlgItem(hDlg, IDC_LISTCOMPLETE))\n\t\tpDesc->eraseIfStale = false;\n\tprocessingSelection = true;\n\tfor (size_t i = 0; i < listCtrls.size(); ++i)\n\t{\n\t\tif (listCtrls[i] != hListCtrl)\n\t\t\tListBox_SetCurSel(listCtrls[i], -1);\n\t}\n\tListBox_SetCurSel(hListCtrl, listIdx);\n\tprocessingSelection = false;\n\tdlgPutLogText(pDesc);\n\tmainOnTaskProgressUpdate(pDesc->selfRef);\n\tmainOnTaskProgressDescUpdate(pDesc->selfRef);\n\tShowWindow(GetDlgItem(hDlg, IDC_EDITSTATUS), SW_SHOW);\n\tShowWindow(GetDlgItem(hDlg, IDC_PROG), SW_SHOW);\n\tShowWindow(GetDlgItem(hDlg, IDC_SDESC), SW_SHOW);\n\tEnableWindow(GetDlgItem(hDlg, IDC_CLEAR), (hListCtrl == hListComplete) ? TRUE : FALSE);\n\tEnableWindow(GetDlgItem(hDlg, IDC_CANCELTASK), pDesc->cancelable ? TRUE : FALSE);\n}\nstatic TaskStatusDesc* listCtrlGetItem(HWND hListCtrl, int listIdx)\n{\n\tLRESULT itemData = ListBox_GetItemData(hListCtrl, listIdx);\n\tassert(itemData != LB_ERR);\n\tif (itemData == LB_ERR)\n\t\treturn nullptr;\n\treturn reinterpret_cast<TaskStatusDesc*>(itemData);\n}\nvoid Win32TaskStatusTracker::dlgHideTask(TaskStatusDesc* pDesc, bool eraseStale)\n{\n\tHWND hListCtrl = NULL; int listIdx = 0;\n\tif (!dlgFindListCtrlFor(pDesc, hListCtrl, listIdx))\n\t\treturn;\n\tHWND hListComplete = GetDlgItem(hDlg, IDC_LISTCOMPLETE);\n\tpDesc->eraseIfStale = true;\n\tbool wasSelected = (ListBox_GetCurSel(hListCtrl) == listIdx);\n\tprocessingSelection = true;\n\n\tauto& taskNameExtents = (hListCtrl == hListComplete) ? completeTaskNameExtents : runningTaskNameExtents;\n\tassert(ListBox_GetCount(hListCtrl) == taskNameExtents.size());\n\tassert(ListBox_GetCount(hListCtrl) > listIdx);\n\tListBox_DeleteString(hListCtrl, listIdx);\n\tfor (int i = listIdx; i < ListBox_GetCount(hListCtrl); ++i)\n\t{\n\t\tTaskStatusDesc* pDesc = reinterpret_cast<TaskStatusDesc*>(ListBox_GetItemData(hListCtrl, i));\n\t\tif (pDesc == nullptr)\n\t\t\tcontinue;\n\t\tassert(pDesc->auxData == i + 1);\n\t\tpDesc->auxData = (uintptr_t)i;\n\t}\n\n\tassert(hListCtrl == hListComplete || hListCtrl == GetDlgItem(hDlg, IDC_LISTRUNNING));\n\tif (listIdx < taskNameExtents.size())\n\t\ttaskNameExtents.erase(taskNameExtents.begin() + listIdx);\n\tauto maxIt = std::max_element(taskNameExtents.begin(), taskNameExtents.end());\n\tint extent = (maxIt == taskNameExtents.end()) ? 10 : *maxIt;\n\tListBox_SetHorizontalExtent(hListComplete, extent);\n\n\tprocessingSelection = false;\n\n\tbool hasAnyCompleteItems = (ListBox_GetCount(hListComplete) > 0);\n\tEnableWindow(GetDlgItem(hDlg, IDC_CLEARALL), hasAnyCompleteItems ? TRUE : FALSE);\n\n\tif (wasSelected)\n\t{\n\t\tauto listCtrls = getListCtrls(hDlg);\n\t\tbool foundItem = false;\n\t\tfor (size_t i = 0; i < listCtrls.size(); ++i)\n\t\t{\n\t\t\tif (ListBox_GetCount(listCtrls[i]) > 0)\n\t\t\t{\n\t\t\t\tfoundItem = true;\n\t\t\t\tEnableWindow(GetDlgItem(hDlg, IDC_CLEARALL), TRUE);\n\t\t\t\tListBox_SetCurSel(listCtrls[i], 0);\n\t\t\t\tif (TaskStatusDesc* pItemDesc = listCtrlGetItem(listCtrls[i], 0))\n\t\t\t\t{\n\t\t\t\t\tthis->dlgSwitchShownTask(pItemDesc);\n\t\t\t\t\tpItemDesc->eraseIfStale = false;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tthis->dlgSwitchShownTask(nullptr);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!foundItem)\n\t\t{\n\t\t\tEnableWindow(GetDlgItem(hDlg, IDC_CLEARALL), FALSE);\n\t\t\tdlgSwitchShownTask(nullptr);\n\t\t}\n\t}\n\tif (eraseStale)\n\t\teraseStaleElements();\n}\nvoid Win32TaskStatusTracker::onResize(bool defer)\n{\n\tRECT client = {};\n\tGetClientRect(hDlg, &client);\n\tlong width = client.right - client.left;\n\tlong height = client.bottom - client.top;\n\n\tHDWP deferCtx = defer ? BeginDeferWindowPos(12) : NULL;\n\tbool retry = false;\n\tstd::vector<RECT> invalidateRects;\n\tauto doMoveWindow = [&deferCtx, &retry, &invalidateRects](HWND hWnd, int x, int y, int w, int h, bool invalidate = false)\n\t{\n\t\tif (invalidate)\n\t\t\tinvalidateRects.emplace_back((LONG)x, (LONG)y, (LONG)x + w, (LONG)y + h);\n\t\tif (deferCtx)\n\t\t{\n\t\t\tdeferCtx = DeferWindowPos(deferCtx, hWnd, HWND_TOP, x, y, w, h, SWP_NOACTIVATE | SWP_NOOWNERZORDER | SWP_NOZORDER);\n\t\t\tif (!deferCtx)\n\t\t\t\tretry = true;\n\t\t}\n\t\telse\n\t\t\tSetWindowPos(hWnd, HWND_TOP, x, y, w, h, SWP_NOACTIVATE | SWP_NOOWNERZORDER | SWP_NOZORDER);\n\t};\n\n\tlong fontHeight = 16;\n\tlong bottomDistance = 7, topDistance = 4;\n\tlong leftDistance = 7, rightDistance = 7;\n\n\tlong panelTop = topDistance;\n\tlong leftPanelLeft = leftDistance;\n\tlong leftPanelWidth = (long)(width * this->mainPanelSplitter.getLeftOrTopPanelRatio() - leftPanelLeft);\n\tlong panelHeight = height - bottomDistance - topDistance;\n\n\tlong buttonHeight = 25, progbarHeight = 25;\n\tlong buttonWidth = 80;\n\n\t{\n\t\tlong taskLabelListsHeight = (panelHeight - buttonHeight - 3);\n\t\tlong runningLabelListTop = panelTop;\n\t\tlong runningLabelListHeight = taskLabelListsHeight / 2 + (taskLabelListsHeight % 2);\n\t\tdoMoveWindow(GetDlgItem(hDlg, IDC_SRUNNINGTASKS), leftPanelLeft, runningLabelListTop, leftPanelWidth - 3, fontHeight, true);\n\t\tdoMoveWindow(GetDlgItem(hDlg, IDC_LISTRUNNING), leftPanelLeft, runningLabelListTop + fontHeight + 4, leftPanelWidth - 3, runningLabelListHeight - fontHeight - 8);\n\t\tlong completeLabelListTop = runningLabelListTop + runningLabelListHeight;\n\t\tlong completeLabelListHeight = taskLabelListsHeight / 2;\n\t\tdoMoveWindow(GetDlgItem(hDlg, IDC_SCOMPLETETASKS), leftPanelLeft, completeLabelListTop, leftPanelWidth - 3, fontHeight, true);\n\t\tdoMoveWindow(GetDlgItem(hDlg, IDC_LISTCOMPLETE), leftPanelLeft, completeLabelListTop + fontHeight + 4, leftPanelWidth - 3, completeLabelListHeight - fontHeight - 8);\n\t}\n\n\tdoMoveWindow(GetDlgItem(hDlg, IDC_CLEARALL), leftPanelLeft, height - bottomDistance - buttonHeight, buttonWidth, buttonHeight);\n\tdoMoveWindow(GetDlgItem(hDlg, IDC_CLEAR), leftPanelLeft + leftPanelWidth - 3 - buttonWidth, height - bottomDistance - buttonHeight, buttonWidth, buttonHeight, true);\n\n\tlong rightPanelLeft = leftPanelLeft + leftPanelWidth + 3;\n\tlong rightPanelWidth = width - rightDistance - rightPanelLeft;\n\n\tdoMoveWindow(GetDlgItem(hDlg, IDC_SDESC), rightPanelLeft, panelTop, rightPanelWidth, fontHeight, true);\n\tdoMoveWindow(GetDlgItem(hDlg, IDC_PROG), rightPanelLeft, panelTop + fontHeight + 4, rightPanelWidth, progbarHeight);\n\tlong editstatusTop = panelTop + fontHeight + 4 + progbarHeight + 8;\n\tlong editstatusHeight = panelHeight - (editstatusTop - panelTop) - buttonHeight - 3;\n\tdoMoveWindow(GetDlgItem(hDlg, IDC_EDITSTATUS), rightPanelLeft, editstatusTop, rightPanelWidth, editstatusHeight);\n\n\tdoMoveWindow(GetDlgItem(hDlg, IDC_CANCELTASK), rightPanelLeft, height - bottomDistance - buttonHeight, buttonWidth, buttonHeight, true);\n\tdoMoveWindow(GetDlgItem(hDlg, IDOK), std::max(rightPanelLeft, rightPanelLeft + rightPanelWidth - buttonWidth),\n\t\theight - bottomDistance - buttonHeight, buttonWidth, buttonHeight, true);\n\n\tlong contentSeparateLeft = leftPanelLeft + leftPanelWidth, contentPanelTop = panelTop;\n\tlong contentSeparateHeight = panelHeight;\n\tdoMoveWindow(GetDlgItem(hDlg, IDC_CONTENTSEPARATE), contentSeparateLeft, -2, 3, height + 2);\n\n\tif (defer)\n\t{\n\t\tif (retry || !EndDeferWindowPos(deferCtx))\n\t\t{\n\t\t\tinvalidateRects.clear();\n\t\t\tonResize(false);\n\t\t}\n\t\tdeferCtx = NULL;\n\t}\n\n\tUpdateWindow(hDlg);\n\t//Workaround for now (broken labels and buttons occur when resizing).\n\tfor (RECT &rect : invalidateRects)\n\t\tInvalidateRect(hDlg, &rect, FALSE);\n}\nINT_PTR CALLBACK Win32TaskStatusTracker::DlgHandler(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)\n{\n\tINT_PTR ret = (INT_PTR)FALSE;\n\tWin32TaskStatusTracker* pThis = (Win32TaskStatusTracker*)GetWindowLongPtr(hDlg, GWLP_USERDATA);\n\tif (pThis && pThis->mainPanelSplitter.handleWin32Message(hDlg, message, wParam, lParam))\n\t{\n\t\tif (pThis->mainPanelSplitter.shouldResize())\n\t\t\tpThis->onResize();\n\t\treturn (message == WM_SETCURSOR) ? (INT_PTR)TRUE : (INT_PTR)0;\n\t}\n\n\tswitch (message)\n\t{\n\tcase WM_DESTROY:\n\t\tbreak;\n\tcase WM_NCDESTROY:\n\t\tbreak;\n\tcase WM_CLOSE:\n\t\tif (pThis)\n\t\t\tpThis->hDlg = NULL;\n\t\tDestroyWindow(hDlg);\n\t\tret = (INT_PTR)TRUE;\n\t\tbreak;\n\tcase WM_INITDIALOG:\n\t\t{\n\t\t\tSetWindowLongPtr(hDlg, GWLP_USERDATA, lParam);\n\t\t\tpThis = (Win32TaskStatusTracker*)lParam;\n\t\t\tpThis->mainPanelSplitter.setSplitterWindow(GetDlgItem(hDlg, IDC_CONTENTSEPARATE));\n\t\t\tpThis->mainPanelSplitter.handleWin32Message(hDlg, message, wParam, lParam);\n\t\t\tpThis->hDlg = hDlg;\n\n\t\t\tpThis->processingSelection = false;\n\t\t\tpThis->numShownLogEntries = 0;\n\n\t\t\tShowWindow(GetDlgItem(hDlg, IDC_EDITSTATUS), SW_HIDE);\n\t\t\tShowWindow(GetDlgItem(hDlg, IDC_PROG), SW_HIDE);\n\t\t\tShowWindow(GetDlgItem(hDlg, IDC_SDESC), SW_HIDE);\n\t\t\tEnableWindow(GetDlgItem(hDlg, IDC_CLEARALL), FALSE);\n\t\t\tEnableWindow(GetDlgItem(hDlg, IDC_CLEAR), FALSE);\n\t\t\tEnableWindow(GetDlgItem(hDlg, IDC_CANCELTASK), FALSE);\n\t\t\tfor (auto it = pThis->taskList.begin(); it != pThis->taskList.end(); ++it)\n\t\t\t{\n\t\t\t\tif (it->hasResult)\n\t\t\t\t\tit->eraseIfStale = (it->result >= 0);\n\t\t\t\telse\n\t\t\t\t\tit->eraseIfStale = true;\n\t\t\t}\n\t\t\tpThis->eraseStaleElements();\n\t\t\tfor (auto it = pThis->taskList.begin(); it != pThis->taskList.end(); ++it)\n\t\t\t{\n\t\t\t\tif (it->hasResult)\n\t\t\t\t\tpThis->handleTaskCompletion(it, false);\n\t\t\t\telse\n\t\t\t\t\tpThis->mainOnTaskAdd(it);\n\t\t\t}\n\t\t\tHWND hListRunning = GetDlgItem(hDlg, IDC_LISTRUNNING);\n\t\t\tif (ListBox_GetCount(hListRunning) > 0)\n\t\t\t{\n\t\t\t\tif (TaskStatusDesc *pDesc = listCtrlGetItem(hListRunning, 0))\n\t\t\t\t\tpThis->dlgSwitchShownTask(pDesc);\n\t\t\t}\n\n\t\t\tShowWindow(hDlg, SW_SHOW);\n\t\t\tPostMessage(hDlg, WM_SIZE, 0, 0);\n\t\t\tret = (INT_PTR)TRUE;\n\t\t}\n\t\tbreak;\n\tcase WM_SIZE:\n\t\tif (pThis)\n\t\t{\n\t\t\tpThis->onResize();\n\t\t\tret = (INT_PTR)TRUE;\n\t\t}\n\t\tbreak;\n\tcase WM_COMMAND:\n\t\tswitch (LOWORD(wParam))\n\t\t{\n\t\tcase IDC_CLEARALL:\n\t\t\tif (pThis)\n\t\t\t{\n\t\t\t\tfor (std::list<TaskStatusDesc>::iterator staleTaskRef : pThis->staleTaskRefs)\n\t\t\t\t{\n\t\t\t\t\tstaleTaskRef->eraseIfStale = true;\n\t\t\t\t\tpThis->dlgHideTask(&*staleTaskRef, false);\n\t\t\t\t}\n\t\t\t\tpThis->eraseStaleElements();\n\t\t\t\tpThis->mainOnProgressMessageUpdate();\n\t\t\t}\n\t\t\tret = (INT_PTR)TRUE;\n\t\t\tbreak;\n\t\tcase IDC_CLEAR:\n\t\t\tif (pThis)\n\t\t\t{\n\t\t\t\tHWND hListComplete = GetDlgItem(hDlg, IDC_LISTCOMPLETE);\n\t\t\t\t\n\t\t\t\tint iItem = ListBox_GetCurSel(hListComplete);\n\t\t\t\tif (iItem != LB_ERR)\n\t\t\t\t{\n\t\t\t\t\tif (TaskStatusDesc* pDesc = listCtrlGetItem(hListComplete, iItem))\n\t\t\t\t\t\tpThis->dlgHideTask(pDesc);\n\t\t\t\t\tpThis->mainOnProgressMessageUpdate();\n\t\t\t\t}\n\t\t\t}\n\t\t\tret = (INT_PTR)TRUE;\n\t\t\tbreak;\n\t\tcase IDC_CANCELTASK:\n\t\t\tif (pThis)\n\t\t\t{\n\t\t\t\tHWND hListRunning = GetDlgItem(hDlg, IDC_LISTRUNNING);\n\t\t\t\tint iItem = ListBox_GetCurSel(hListRunning);\n\t\t\t\tif (iItem != LB_ERR)\n\t\t\t\t{\n\t\t\t\t\tTaskStatusDesc* pDesc = listCtrlGetItem(hListRunning, iItem);\n\t\t\t\t\tstd::shared_ptr<ITask> pTask;\n\t\t\t\t\tif (pDesc && (pTask = pDesc->wpTask.lock()))\n\t\t\t\t\t{\n\t\t\t\t\t\t//The cancel button will be disabled in response to the "OnCancelableChange" event.\n\t\t\t\t\t\tpThis->appContext.taskManager.cancel(pTask.get());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tret = (INT_PTR)TRUE;\n\t\t\tbreak;\n\t\tcase IDCANCEL:\n\t\tcase IDOK:\n\t\t\tSendMessage(hDlg, WM_CLOSE, 0, 0);\n\t\t\tret = (INT_PTR)TRUE;\n\t\t\tbreak;\n\t\tcase IDC_LISTRUNNING:\n\t\tcase IDC_LISTCOMPLETE:\n\t\t\t{\n\t\t\t\tHWND hList = (HWND)lParam;\n\t\t\t\tif (HIWORD(wParam) == LBN_SELCHANGE)\n\t\t\t\t{\n\t\t\t\t\tauto listCtrls = getListCtrls(hDlg);\n\t\t\t\t\tif (std::find(listCtrls.begin(), listCtrls.end(), hList) == listCtrls.end())\n\t\t\t\t\t\tbreak; //Only looking for the task list views.\n\t\t\t\t\tTaskStatusDesc* pDesc = listCtrlGetItem(hList, ListBox_GetCurSel(hList));\n\t\t\t\t\tpThis->dlgSwitchShownTask(pDesc);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\t}\n\treturn ret;\n}\n\nWin32TaskStatusTracker::Win32TaskStatusTracker(class Win32AppContext& appContext, HWND hMainWndProgress, HWND hMainWndStatusText)\n\t: TaskStatusTracker(appContext), hMainWndProgress(hMainWndProgress), hMainWndStatusText(hMainWndStatusText), mainPanelSplitter(0.3f, 0.2f, 0.8f)\n{\n\tmainOnTotalProgressUpdate();\n\tmainOnProgressMessageUpdate();\n}\nvoid Win32TaskStatusTracker::open()\n{\n\tif (hDlg != NULL)\n\t\treturn;\n\trunningTaskNameExtents.clear();\n\tcompleteTaskNameExtents.clear();\n\tWin32AppContext& appContext = reinterpret_cast<Win32AppContext&>(this->appContext);\n\thDlg = CreateDialogParam(appContext.getMainWindow().getHInstance(), MAKEINTRESOURCE(IDD_PROGRESS2),\n\t\tappContext.getMainWindow().getWindow(), DlgHandler, (LPARAM)this);\n}\nvoid Win32TaskStatusTracker::close()\n{\n\tif (hDlg == NULL)\n\t\treturn;\n\tSendMessage(hDlg, WM_CLOSE, 0, 0);\n}\n\nvoid Win32TaskStatusTracker::preEraseElement(std::list<TaskStatusDesc>::iterator listEntry)\n{\n\tdlgHideTask(&*listEntry);\n}\nvoid Win32TaskStatusTracker::mainOnTaskAdd(std::list<TaskStatusDesc>::iterator listEntry)\n{\n\tif (hDlg == NULL)\n\t\treturn;\n\tHWND hListRunning = GetDlgItem(hDlg, IDC_LISTRUNNING);\n\tauto nameT = unique_MultiByteToTCHAR(listEntry->name.c_str());\n\tint iItem = ListBox_GetCount(hListRunning);\n\tListBox_InsertString(hListRunning, iItem, nameT.get());\n\tListBox_SetItemData(hListRunning, iItem, (LPARAM)&*listEntry);\n\tlistEntry->auxData = (uintptr_t)iItem;\n\n\trunningTaskNameExtents.push_back(GetTextExtent(hListRunning, nameT.get()));\n\tassert(runningTaskNameExtents.size() == ListBox_GetCount(hListRunning));\n\tListBox_SetHorizontalExtent(hListRunning, std::max(runningTaskNameExtents.back(), ListBox_GetHorizontalExtent(hListRunning)));\n\t\n\tEnableWindow(GetDlgItem(hDlg, IDC_CLEARALL), TRUE);\n\tbool hasAnySelection = false;\n\tauto listCtrls = getListCtrls(hDlg);\n\tfor (size_t i = 0; i < listCtrls.size(); ++i)\n\t{\n\t\tif (ListBox_GetCurSel(listCtrls[i]) != LB_ERR)\n\t\t{\n\t\t\thasAnySelection = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!hasAnySelection)\n\t{\n\t\tListBox_SetCurSel(hListRunning, iItem);\n\t\tthis->dlgSwitchShownTask(&*listEntry);\n\t}\n}\nvoid Win32TaskStatusTracker::mainOnTaskProgressUpdate(std::list<TaskStatusDesc>::iterator listEntry)\n{\n\tif (hDlg == NULL)\n\t\treturn;\n\tHWND hListCtrl = NULL; int listIdx = 0;\n\tif (!dlgFindListCtrlFor(&*listEntry, hListCtrl, listIdx))\n\t\treturn;\n\tif (ListBox_GetCurSel(hListCtrl) != listIdx)\n\t\treturn;\n\tHWND hWndProgress = GetDlgItem(hDlg, IDC_PROG);\n\tint oldRange = (int)SendMessage(hWndProgress, PBM_GETRANGE, (WPARAM)FALSE, (LPARAM)NULL);\n\tint newRange = (int)std::min<unsigned int>(listEntry->range, INT_MAX);\n\tint progress = (int)std::min<unsigned int>(listEntry->progress, INT_MAX);\n\tif (listEntry->hasResult)\n\t{\n\t\tif (newRange == 0)\n\t\t\tnewRange = 1;\n\t\tprogress = newRange;\n\t}\n\tif (listEntry->hasResult && listEntry->result < 0)\n\t\tSendMessage(hWndProgress, PBM_SETSTATE, (WPARAM)PBST_ERROR, (LPARAM)0);\n\telse\n\t\tSendMessage(hWndProgress, PBM_SETSTATE, (WPARAM)PBST_NORMAL, (LPARAM)0);\n\tif (newRange == 0)\n\t{\n\t\tSetWindowLongPtr(hWndProgress, GWL_STYLE,\n\t\t\t(GetWindowLongPtr(hWndProgress, GWL_STYLE) & (~(PBS_SMOOTH | PBS_SMOOTHREVERSE))) | PBS_MARQUEE);\n\t\tSendMessage(hWndProgress, PBM_SETMARQUEE, (WPARAM)1, 0);\n\t}\n\telse\n\t{\n\t\t//Don\'t set the style if it\'s not necessary since setting the style resets the progress animation back to 0.\n\t\tLONG_PTR oldStyle = GetWindowLongPtr(hWndProgress, GWL_STYLE);\n\t\tif (oldStyle & PBS_MARQUEE || !(oldStyle & (PBS_SMOOTH | PBS_SMOOTHREVERSE)))\n\t\t{\n\t\t\tSetWindowLongPtr(hWndProgress, GWL_STYLE, (oldStyle & (~PBS_MARQUEE)) | PBS_SMOOTH | PBS_SMOOTHREVERSE);\n\t\t}\n\t\tif (oldRange != newRange)\n\t\t\tSendMessage(hWndProgress, PBM_SETRANGE32, (WPARAM)0, (LPARAM)newRange);\n\t}\n\tif (newRange > 0)\n\t{\n\t\tSendMessage(hWndProgress, PBM_SETPOS, (WPARAM)std::min<unsigned int>(progress, INT_MAX), (LPARAM)0);\n\t}\n}\nvoid Win32TaskStatusTracker::mainOnTaskProgressDescUpdate(std::list<TaskStatusDesc>::iterator listEntry)\n{\n\tif (hDlg == NULL)\n\t\treturn;\n\tHWND hListCtrl = NULL; int listIdx = 0;\n\tif (!dlgFindListCtrlFor(&*listEntry, hListCtrl, listIdx))\n\t\treturn;\n\tif (ListBox_GetCurSel(hListCtrl) == listIdx)\n\t{\n\t\tHWND hWndDesc = GetDlgItem(hDlg, IDC_SDESC);\n\t\tif (listEntry->hasResult)\n\t\t{\n\t\t\tstd::string desc;\n\t\t\tif (listEntry->result == TaskResult_Canceled)\n\t\t\t\tdesc.assign("Canceled: ");\n\t\t\telse if (listEntry->result < 0)\n\t\t\t\tdesc.assign("Failed: ");\n\t\t\telse\n\t\t\t\tdesc.assign("Succeeded: ");\n\t\t\tdesc += listEntry->name;\n\t\t\tauto pDescT = unique_MultiByteToTCHAR(desc.c_str());\n\t\t\tStatic_SetText(hWndDesc, pDescT.get());\n\t\t}\n\t\telse\n\t\t{\n\t\t\tauto pDescT = unique_MultiByteToTCHAR(listEntry->curProgressDesc.c_str());\n\t\t\tStatic_SetText(hWndDesc, pDescT.get());\n\t\t}\n\t}\n}\nvoid Win32TaskStatusTracker::mainOnTaskAddLogMessage(std::list<TaskStatusDesc>::iterator listEntry)\n{\n\tif (hDlg == NULL)\n\t\treturn;\n\tHWND hListCtrl = NULL; int listIdx = 0;\n\tif (!dlgFindListCtrlFor(&*listEntry, hListCtrl, listIdx))\n\t\treturn;\n\tif (ListBox_GetCurSel(hListCtrl) == listIdx)\n\t{\n\t\tassert(listEntry->messages.size() >= numShownLogEntries);\n\t\tif (numShownLogEntries >= listEntry->messages.size())\n\t\t\treturn;\n\t\tfor (size_t i = numShownLogEntries; i < listEntry->messages.size(); ++i)\n\t\t\tdlgAddLogText(listEntry->messages[i]);\n\t\tnumShownLogEntries = listEntry->messages.size();\n\t}\n}\nvoid Win32TaskStatusTracker::handleTaskCompletion(std::list<TaskStatusDesc>::iterator listEntry, bool eraseStaleEntries)\n{\n\tif (listEntry->hasResult && listEntry->result < 0)\n\t\tlistEntry->eraseIfStale = false;\n\tif (hDlg == NULL)\n\t\treturn;\n\tmainOnTaskProgressUpdate(listEntry);\n\tHWND hListCtrl = NULL; int listIdx = 0;\n\tbool wasSelected = false;\n\tHWND hListRunning = GetDlgItem(hDlg, IDC_LISTRUNNING);\n\tHWND hListComplete = GetDlgItem(hDlg, IDC_LISTCOMPLETE);\n\tif (dlgFindListCtrlFor(&*listEntry, hListCtrl, listIdx) && hListCtrl == hListRunning)\n\t{\n\t\tprocessingSelection = true;\n\t\twasSelected = ListBox_GetCurSel(hListCtrl) == listIdx;\n\t\tif (wasSelected)\n\t\t\tListBox_SetCurSel(hListCtrl, -1);\n\n\t\tassert(ListBox_GetCount(hListCtrl) == runningTaskNameExtents.size());\n\t\tassert(ListBox_GetCount(hListCtrl) > listIdx);\n\t\tListBox_DeleteString(hListCtrl, listIdx);\n\t\tfor (int i = listIdx; i < ListBox_GetCount(hListCtrl); ++i)\n\t\t{\n\t\t\tTaskStatusDesc *pDesc = reinterpret_cast<TaskStatusDesc*>(ListBox_GetItemData(hListCtrl, i));\n\t\t\tif (pDesc == nullptr)\n\t\t\t\tcontinue;\n\t\t\tassert(pDesc->auxData == i + 1);\n\t\t\tpDesc->auxData = (uintptr_t)i;\n\t\t}\n\t\tlistEntry->auxData = (uintptr_t)-1;\n\n\t\tassert(hListCtrl == hListRunning);\n\t\tif (listIdx < runningTaskNameExtents.size())\n\t\t\trunningTaskNameExtents.erase(runningTaskNameExtents.begin() + listIdx);\n\t\tauto maxIt = std::max_element(runningTaskNameExtents.begin(), runningTaskNameExtents.end());\n\t\tint extent = (maxIt == runningTaskNameExtents.end()) ? 10 : *maxIt;\n\t\tListBox_SetHorizontalExtent(hListRunning, extent);\n\n\t\tprocessingSelection = false;\n\t}\n\n\tprocessingSelection = true;\n\tauto nameT = unique_MultiByteToTCHAR(listEntry->name.c_str());\n\n\tint iItem = ListBox_GetCount(hListComplete);\n\tListBox_InsertString(hListComplete, iItem, nameT.get());\n\tListBox_SetItemData(hListComplete, iItem, (LPARAM)&*listEntry);\n\tlistEntry->auxData = (uintptr_t)iItem;\n\n\tcompleteTaskNameExtents.push_back(GetTextExtent(hListComplete, nameT.get()));\n\tassert(completeTaskNameExtents.size() == ListBox_GetCount(hListComplete));\n\tListBox_SetHorizontalExtent(hListComplete, std::max(completeTaskNameExtents.back(), ListBox_GetHorizontalExtent(hListComplete)));\n\n\tif (wasSelected)\n\t{\n\t\tListBox_SetCurSel(hListComplete, iItem);\n\t\tEnableWindow(GetDlgItem(hDlg, IDC_CLEARALL), TRUE);\n\t\tEnableWindow(GetDlgItem(hDlg, IDC_CLEAR), TRUE);\n\t}\n\tprocessingSelection = false;\n\tif (wasSelected && !listEntry->messages.empty())\n\t\tlistEntry->eraseIfStale = false;\n\n\tbool hasAnySelection = wasSelected;\n\tauto listCtrls = getListCtrls(hDlg);\n\tfor (size_t i = 0; i < listCtrls.size() && !hasAnySelection; ++i)\n\t{\n\t\tif (ListBox_GetCurSel(listCtrls[i]) != LB_ERR)\n\t\t{\n\t\t\thasAnySelection = true;\n\t\t}\n\t}\n\tif (!hasAnySelection)\n\t{\n\t\tif (!listEntry->messages.empty() || !listEntry->eraseIfStale)\n\t\t{\n\t\t\tListBox_SetCurSel(hListComplete, iItem);\n\t\t\tthis->dlgSwitchShownTask(&*listEntry);\n\t\t\tlistEntry->eraseIfStale = false;\n\t\t}\n\t\telse\n\t\t\tthis->dlgSwitchShownTask(nullptr);\n\t}\n\tif (eraseStaleEntries)\n\t\teraseStaleElements();\n}\nvoid Win32TaskStatusTracker::mainOnTaskCompletion(std::list<TaskStatusDesc>::iterator listEntry)\n{\n\thandleTaskCompletion(listEntry, true);\n}\nvoid Win32TaskStatusTracker::mainOnTaskCancelableChange(std::list<TaskStatusDesc>::iterator listEntry)\n{\n\tif (hDlg == NULL)\n\t\treturn;\n\tHWND hListCtrl = NULL; int listIdx = 0;\n\tif (!dlgFindListCtrlFor(&*listEntry, hListCtrl, listIdx))\n\t\treturn;\n\tif (ListBox_GetCurSel(hListCtrl) == listIdx)\n\t{\n\t\tEnableWindow(GetDlgItem(hDlg, IDC_CANCELTASK), (listEntry->cancelable) ? TRUE : FALSE);\n\t}\n}\n\nvoid Win32TaskStatusTracker::mainOnTotalProgressUpdate()\n{\n\tif (hMainWndProgress == NULL)\n\t\treturn;\n\n\t//Don\'t set the style if it\'s not necessary since setting the style resets the progress animation back to 0.\n\tLONG_PTR oldStyle = GetWindowLongPtr(hMainWndProgress, GWL_STYLE);\n\n\tsize_t numTasks = taskList.size() - staleTaskRefs.size();\n\tif (numTasks == 0)\n\t{\n\t\tSendMessage(hMainWndProgress, PBM_SETMARQUEE, (WPARAM)FALSE, (LPARAM)0);\n\t\tif (oldStyle & PBS_MARQUEE)\n\t\t{\n\t\t\tSetWindowLongPtr(hMainWndProgress, GWL_STYLE, (oldStyle & (~PBS_MARQUEE)) | PBS_SMOOTH | PBS_SMOOTHREVERSE);\n\t\t}\n\n\t\tif (lastTaskResult < 0 && lastTaskResult != TaskResult_Canceled)\n\t\t\tSendMessage(hMainWndProgress, PBM_SETSTATE, (WPARAM)PBST_ERROR, (LPARAM)0);\n\t\telse\n\t\t\tSendMessage(hMainWndProgress, PBM_SETSTATE, (WPARAM)PBST_NORMAL, (LPARAM)0);\n\t\tSendMessage(hMainWndProgress, PBM_SETRANGE32, (WPARAM)0, (LPARAM)1);\n\t\tSendMessage(hMainWndProgress, PBM_SETPOS, (WPARAM)0, (LPARAM)0);\n\t}\n\telse\n\t{\n\t\tSendMessage(hMainWndProgress, PBM_SETSTATE, (WPARAM)PBST_NORMAL, (LPARAM)0);\n\t\t\n\t\tunsigned int range = 10000;\n\t\tunsigned int progress = std::min(static_cast<unsigned int>(totalProgress * range), range);\n\t\tSendMessage(hMainWndProgress, PBM_SETMARQUEE, (WPARAM)FALSE, (LPARAM)0);\n\t\tif (oldStyle & PBS_MARQUEE)\n\t\t{\n\t\t\tSetWindowLongPtr(hMainWndProgress, GWL_STYLE, (oldStyle & (~PBS_MARQUEE)) | PBS_SMOOTH | PBS_SMOOTHREVERSE);\n\t\t}\n\n\t\tSendMessage(hMainWndProgress, PBM_SETRANGE32, (WPARAM)0, (LPARAM)range);\n\t\tSendMessage(hMainWndProgress, PBM_SETPOS, (WPARAM)progress, (LPARAM)0);\n\t}\n}\nvoid Win32TaskStatusTracker::mainOnProgressMessageUpdate()\n{\n\tif (hMainWndStatusText == NULL)\n\t\treturn;\n\n\tsize_t numTasks = taskList.size() - staleTaskRefs.size();\n\tif (numTasks == 0)\n\t{\n\t\tsize_t numFailedTasks = 0;\n\t\tfor (std::list<TaskStatusDesc>::iterator staleTaskRef : this->staleTaskRefs)\n\t\t{\n\t\t\tif (staleTaskRef->hasResult && staleTaskRef->result < 0)\n\t\t\t\t++numFailedTasks;\n\t\t}\n\t\tif (numFailedTasks == 0)\n\t\t\tStatic_SetText(hMainWndStatusText, TEXT("Ready"));\n\t\telse\n\t\t{\n\t\t\tstd::basic_string<TCHAR> failMsg = std::format(\n\t\t\t\tTEXT("Ready - {} task{} completed with errors, see the Task Progress tracker"),\n\t\t\t\tnumFailedTasks, (numFailedTasks > 1) ? TEXT("s") : TEXT(""));\n\t\t\tStatic_SetText(hMainWndStatusText, failMsg.c_str());\n\t\t}\n\t}\n\telse\n\t{\n\t\tauto numThreads = appContext.taskManager.getNumThreadsWorking();\n\t\tstd::string fullDesc = std::format("({} task{}, {} thread{} working) {}",\n\t\t\tnumTasks, (numTasks!=1) ? "s" : "",\n\t\t\tnumThreads, (numThreads!=1) ? "s" : "",\n\t\t\tlatestProgressMessage);\n\t\tauto lastTaskDescT = unique_MultiByteToTCHAR(fullDesc.c_str());\n\t\tStatic_SetText(hMainWndStatusText, lastTaskDescT.get());\n\t}\n}\n'