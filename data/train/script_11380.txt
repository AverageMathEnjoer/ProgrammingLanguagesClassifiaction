b'\xef\xbb\xbfusing System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.IO;\nusing System.Linq;\nusing System.Runtime.InteropServices;\nusing System.Security.Principal;\nusing System.Text.RegularExpressions;\nusing System.Threading;\nusing System.DirectoryServices;\nusing System.DirectoryServices.Protocols;\nusing Rubeus.lib.Interop;\n\nnamespace Rubeus\n{\n    public class Helpers\n    {\n        #region String Helpers\n\n        public static IEnumerable<string> Split(string text, int partLength)\n        {\n            // splits a string into partLength parts\n            if (text == null) { Console.WriteLine("[ERROR] Split() - singleLineString"); }\n            if (partLength < 1) { Console.WriteLine("[ERROR] Split() - \'columns\' must be greater than 0."); }\n\n            var partCount = Math.Ceiling((double)text.Length / partLength);\n            if (partCount < 2)\n            {\n                yield return text;\n            }\n\n            for (int i = 0; i < partCount; i++)\n            {\n                var index = i * partLength;\n                var lengthLeft = Math.Min(partLength, text.Length - index);\n                var line = text.Substring(index, lengthLeft);\n                yield return line;\n            }\n        }\n\n        private static Random random = new Random();\n        public static string RandomString(int length)\n        {\n            const string chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";\n            return new string(Enumerable.Repeat(chars, length)\n              .Select(s => s[random.Next(s.Length)]).ToArray());\n        }\n\n        public static bool IsBase64String(string s)\n        {\n            s = s.Trim();\n            return (s.Length % 4 == 0) && Regex.IsMatch(s, @"^[a-zA-Z0-9\\+/]*={0,3}$", RegexOptions.None);\n        }\n\n        public static byte[] StringToByteArray(string hex)\n        {\n            // converts a rc4/AES/etc. string into a byte array representation\n\n            if ((hex.Length % 16) != 0)\n            {\n                Console.WriteLine("\\r\\n[X] Hash must be 16, 32 or 64 characters in length\\r\\n");\n                System.Environment.Exit(1);\n            }\n\n            // yes I know this inefficient\n            return Enumerable.Range(0, hex.Length)\n                             .Where(x => x % 2 == 0)\n                             .Select(x => Convert.ToByte(hex.Substring(x, 2), 16))\n                             .ToArray();\n        }\n\n        //StackOverflow goodness\n        public static string ByteArrayToString(byte[] bytes) {\n            char[] c = new char[bytes.Length * 2];\n            int b;\n            for (int i = 0; i < bytes.Length; i++) {\n                b = bytes[i] >> 4;\n                c[i * 2] = (char)(55 + b + (((b - 10) >> 31) & -7));\n                b = bytes[i] & 0xF;\n                c[i * 2 + 1] = (char)(55 + b + (((b - 10) >> 31) & -7));\n            }\n            return new string(c);\n        }\n\n        public static DateTime? FutureDate(DateTime date, string increase)\n        {\n            int multiplier;\n            DateTime? returnDate = null;\n            try\n            {\n                multiplier = Int32.Parse(increase.Substring(0, increase.Length - 1));\n            }\n            catch\n            {\n                Console.WriteLine("[X] Error invalid multiplier specified {0}, skipping.", increase.Substring(0, increase.Length - 1));\n                return returnDate;\n            }\n\n            string period = increase.Substring(increase.Length - 1);\n\n            switch (period)\n            {\n                case "m":\n                    returnDate = date.AddMinutes(multiplier);\n                    break;\n                case "h":\n                    returnDate = date.AddHours(multiplier);\n                    break;\n                case "d":\n                    returnDate = date.AddDays(multiplier);\n                    break;\n                case "M":\n                    returnDate = date.AddMonths(multiplier);\n                    break;\n                case "y":\n                    returnDate = date.AddYears(multiplier);\n                    break;\n            }\n\n            return returnDate;\n        }\n\n        #endregion\n\n\n            #region Token Helpers\n\n            public static bool IsHighIntegrity()\n        {\n            // returns true if the current process is running with adminstrative privs in a high integrity context\n            WindowsIdentity identity = WindowsIdentity.GetCurrent();\n            WindowsPrincipal principal = new WindowsPrincipal(identity);\n            return principal.IsInRole(WindowsBuiltInRole.Administrator);\n        }\n\n        public static bool GetSystem()\n        {\n            // helper to elevate to SYSTEM for Kerberos ticket enumeration via token impersonation\n            if (IsHighIntegrity())\n            {\n                IntPtr hToken = IntPtr.Zero;\n\n                // Open winlogon\'s token with TOKEN_DUPLICATE accesss so ca can make a copy of the token with DuplicateToken\n                Process[] processes = Process.GetProcessesByName("winlogon");\n                IntPtr handle = processes[0].Handle;\n\n                // TOKEN_DUPLICATE = 0x0002\n                bool success = Interop.OpenProcessToken(handle, 0x0002, out hToken);\n                if (!success)\n                {\n                    Console.WriteLine("[!] GetSystem() - OpenProcessToken failed!");\n                    return false;\n                }\n\n                // make a copy of the NT AUTHORITY\\SYSTEM token from winlogon\n                // 2 == SecurityImpersonation\n                IntPtr hDupToken = IntPtr.Zero;\n                success = Interop.DuplicateToken(hToken, 2, ref hDupToken);\n                if (!success)\n                {\n                    Console.WriteLine("[!] GetSystem() - DuplicateToken failed!");\n                    return false;\n                }\n\n                success = Interop.ImpersonateLoggedOnUser(hDupToken);\n                if (!success)\n                {\n                    Console.WriteLine("[!] GetSystem() - ImpersonateLoggedOnUser failed!");\n                    return false;\n                }\n\n                // clean up the handles we created\n                Interop.CloseHandle(hToken);\n                Interop.CloseHandle(hDupToken);\n\n                if (!IsSystem())\n                {\n                    return false;\n                }\n\n                return true;\n            }\n            else\n            {\n                return false;\n            }\n        }\n\n        public static bool IsSystem()\n        {\n            // returns true if the current user is "NT AUTHORITY\\SYSTEM"\n            var currentSid = WindowsIdentity.GetCurrent().User;\n            return currentSid.IsWellKnown(WellKnownSidType.LocalSystemSid);\n        }\n\n        public static LUID GetCurrentLUID()\n        {\n            // helper that returns the current logon session ID by using GetTokenInformation w/ TOKEN_INFORMATION_CLASS\n\n            var TokenInfLength = 0;\n            var luid = new LUID();\n\n            // first call gets lenght of TokenInformation to get proper struct size\n            var Result = Interop.GetTokenInformation(WindowsIdentity.GetCurrent().Token, Interop.TOKEN_INFORMATION_CLASS.TokenStatistics, IntPtr.Zero, TokenInfLength, out TokenInfLength);\n\n            var TokenInformation = Marshal.AllocHGlobal(TokenInfLength);\n\n            // second call actually gets the information\n            Result = Interop.GetTokenInformation(WindowsIdentity.GetCurrent().Token, Interop.TOKEN_INFORMATION_CLASS.TokenStatistics, TokenInformation, TokenInfLength, out TokenInfLength);\n\n            if (Result)\n            {\n                var TokenStatistics = (Interop.TOKEN_STATISTICS)Marshal.PtrToStructure(TokenInformation, typeof(Interop.TOKEN_STATISTICS));\n                luid = new LUID(TokenStatistics.AuthenticationId);\n            }\n            else\n            {\n                var lastError = Interop.GetLastError();\n                Console.WriteLine("[X] GetTokenInformation error: {0}", lastError);\n                Marshal.FreeHGlobal(TokenInformation);\n            }\n\n            return luid;\n        }\n\n        public static LUID CreateProcessNetOnly(string commandLine, bool show = false)\n        {\n            // creates a hidden process with random /netonly credentials,\n            //  displayng the process ID and LUID, and returning the LUID\n\n            // Note: the LUID can be used with the "ptt" action\n\n            Interop.PROCESS_INFORMATION pi;\n            var si = new Interop.STARTUPINFO();\n            si.cb = Marshal.SizeOf(si);\n            if (!show)\n            {\n                // hide the window\n                si.wShowWindow = 0;\n                si.dwFlags = 0x00000001;\n            }\n            Console.WriteLine("[*] Showing process : {0}", show);\n            var luid = new LUID();\n\n            // 0x00000002 == LOGON_NETCREDENTIALS_ONLY\n            if (!Interop.CreateProcessWithLogonW(Helpers.RandomString(8), Helpers.RandomString(8), Helpers.RandomString(8), 0x00000002, commandLine, String.Empty, 0, 0, null, ref si, out pi))\n            {\n                var lastError = Interop.GetLastError();\n                Console.WriteLine("[X] CreateProcessWithLogonW error: {0}", lastError);\n                return new LUID();\n            }\n\n            Console.WriteLine("[+] Process         : \'{0}\' successfully created with LOGON_TYPE = 9", commandLine);\n            Console.WriteLine("[+] ProcessID       : {0}", pi.dwProcessId);\n\n            var hToken = IntPtr.Zero;\n            // TOKEN_QUERY == 0x0008\n            var success = Interop.OpenProcessToken(pi.hProcess, 0x0008, out hToken);\n            if (!success)\n            {\n                var lastError = Interop.GetLastError();\n                Console.WriteLine("[X] OpenProcessToken error: {0}", lastError);\n                return new LUID();\n            }\n\n            var TokenInfLength = 0;\n            bool Result;\n\n            // first call gets lenght of TokenInformation to get proper struct size\n            Result = Interop.GetTokenInformation(hToken, Interop.TOKEN_INFORMATION_CLASS.TokenStatistics, IntPtr.Zero, TokenInfLength, out TokenInfLength);\n\n            var TokenInformation = Marshal.AllocHGlobal(TokenInfLength);\n\n            // second call actually gets the information\n            Result = Interop.GetTokenInformation(hToken, Interop.TOKEN_INFORMATION_CLASS.TokenStatistics, TokenInformation, TokenInfLength, out TokenInfLength);\n\n            if (Result)\n            {\n                var TokenStats = (Interop.TOKEN_STATISTICS)Marshal.PtrToStructure(TokenInformation, typeof(Interop.TOKEN_STATISTICS));\n                luid = new LUID(TokenStats.AuthenticationId);\n                Console.WriteLine("[+] LUID            : {0}", luid);\n            }\n            else\n            {\n                var lastError = Interop.GetLastError();\n                Console.WriteLine("[X] GetTokenInformation error: {0}", lastError);\n                Marshal.FreeHGlobal(TokenInformation);\n                Interop.CloseHandle(hToken);\n                return new LUID();\n            }\n\n            Marshal.FreeHGlobal(TokenInformation);\n            Interop.CloseHandle(hToken);\n\n            return luid;\n        }\n\n        #endregion\n\n\n        #region File Helpers\n\n        static public string GetBaseFromFilename(string filename)\n        {\n            return SplitBaseAndExtension(filename)[0];\n        }\n\n        static public string GetExtensionFromFilename(string filename)\n        {\n            return SplitBaseAndExtension(filename)[1];\n        }\n\n        // Splits filename by into a basename and extension \n        // Returns an array representing [basename, extension]\n        static public string[] SplitBaseAndExtension(string filename)\n        {\n            string[] result = { filename, "" };\n            string[] splitName = filename.Split(\'.\');\n\n            if (splitName.Length > 1)\n            {\n                result[1] = $".{splitName.Last()}";\n                result[0] = filename.Substring(0, filename.Length - result[1].Length);\n            }\n\n            return result;\n        }\n\n        // Great method from http://forcewake.me/today-i-learned-sanitize-file-name-in-csharp/\n        static public string MakeValidFileName(string name)\n        {\n            string invalidChars = new string(Path.GetInvalidFileNameChars());\n            string escapedInvalidChars = Regex.Escape(invalidChars);\n            string invalidRegex = string.Format(@"([{0}]*\\.+$)|([{0}]+)", escapedInvalidChars);\n\n            return Regex.Replace(name, invalidRegex, "_");\n        }\n\n        #endregion\n\n\n        #region Misc Helpers\n\n        public static void RandomDelayWithJitter(int delay, int jitter)\n        {\n            // given delay == ms and jitter = %, sleep for that amount\n            \n            var timeToSleep = 0;\n\n            if (delay == 0)\n            {\n                timeToSleep = 0;\n            }\n            else if (jitter == 0)\n            {\n                timeToSleep = delay;\n            }\n            else\n            {\n                var rnd = new Random();\n                var percent = (int)Math.Floor((double)(jitter * (delay / 100)));\n                timeToSleep = delay + rnd.Next(-percent, percent);\n            }\n\n            if (timeToSleep != 0)\n            {\n                Thread.Sleep(timeToSleep);\n            }\n        }\n\n        static public int SearchBytePattern(byte[] pattern, byte[] bytes)\n        {\n            List<int> positions = new List<int>();\n            int patternLength = pattern.Length;\n            int totalLength = bytes.Length;\n            byte firstMatchByte = pattern[0];\n            for (int i = 0; i < totalLength; i++)\n            {\n                if (firstMatchByte == bytes[i] && totalLength - i >= patternLength)\n                {\n                    byte[] match = new byte[patternLength];\n                    Array.Copy(bytes, i, match, 0, patternLength);\n                    if (match.SequenceEqual<byte>(pattern))\n                    {\n                        return i;\n                    }\n                }\n            }\n            return 0;\n        }\n\n        static public bool WriteBytesToFile(string filename, byte[] data, bool overwrite = false)\n        {\n            bool result = true;\n            string filePath = Path.GetFullPath(filename);\n\n            try\n            {\n                if (!overwrite)\n                {\n                    if (File.Exists(filePath))\n                    {\n                        throw new Exception(String.Format("{0} already exists! Data not written to file.\\r\\n", filePath));\n                    }\n                }\n                File.WriteAllBytes(filePath, data);\n            }\n            catch (Exception e)\n            {\n                Console.WriteLine("\\r\\nException: {0}", e.Message);\n                result = false;\n            }\n\n            return result;\n        }\n\n        // variables specifying non default AD attribute types\n        private static string[] stringArrayAttributeName =\n        {\n            "serviceprincipalname",\n            "memberof"\n        };\n        private static string[] datetimeAttributes =\n        {\n            "lastlogon",\n            "lastlogoff",\n            "pwdlastset",\n            "badpasswordtime",\n            "lastlogontimestamp",\n        };\n        private static string[] dateStringAttributes =\n        {\n            "whenchanged",\n            "whencreated"\n        };\n        private static string[] intAttributes =\n        {\n            "useraccountcontrol",\n            "msds-supportedencryptiontypes"\n        };\n\n        static public List<IDictionary<string, Object>> GetADObjects(List<SearchResultEntry> searchResults)\n        {\n            var ActiveDirectoryObjects = new List<IDictionary<string, Object>>();\n\n            foreach (SearchResultEntry result in searchResults)\n            {\n                IDictionary<string, Object> ActiveDirectoryObject = new Dictionary<string, Object>();\n\n                foreach (string attribute in result.Attributes.AttributeNames)\n                {\n                    // for string arrays like serviceprincipalname\n                    if (stringArrayAttributeName.Contains(attribute))\n                    {\n                        ActiveDirectoryObject.Add(attribute, result.Attributes[attribute].GetValues(typeof(string)));\n                    }\n                    // datetime attributes\n                    else if (datetimeAttributes.Contains(attribute))\n                    {\n                        if (Int64.Parse((string)result.Attributes[attribute].GetValues(typeof(string))[0]) != 0)\n                        {\n                            ActiveDirectoryObject.Add(attribute, DateTime.FromFileTimeUtc(Int64.Parse((string)result.Attributes[attribute].GetValues(typeof(string))[0])));\n                        }\n                        else\n                        {\n                            ActiveDirectoryObject.Add(attribute, DateTime.MinValue);\n                        }\n                    }\n                    // deal with objectsid\n                    else if (attribute.Equals("objectsid"))\n                    {\n                        ActiveDirectoryObject.Add(attribute, new SecurityIdentifier((byte[])result.Attributes[attribute].GetValues(typeof(byte[]))[0], 0).Value);\n                    }\n                    // deal with ints\n                    else if (intAttributes.Contains(attribute))\n                    {\n                        ActiveDirectoryObject.Add(attribute, Int32.Parse((string)result.Attributes[attribute].GetValues(typeof(string))[0]));\n                    }\n                    // default action convert to string\n                    else\n                    {\n                        ActiveDirectoryObject.Add(attribute, result.Attributes[attribute].GetValues(typeof(string))[0]);\n                    }\n                }\n\n                ActiveDirectoryObjects.Add(ActiveDirectoryObject);\n            }\n\n            return ActiveDirectoryObjects;\n        }\n\n        static public List<IDictionary<string, Object>> GetADObjects(SearchResultCollection searchResults)\n        {\n            var ActiveDirectoryObjects = new List<IDictionary<string, Object>>();\n\n            foreach (SearchResult result in searchResults)\n            {\n                IDictionary<string, Object> ActiveDirectoryObject = new Dictionary<string, Object>();\n\n                foreach (string attribute in result.Properties.PropertyNames)\n                {\n                    // for string arrays like serviceprincipalname\n                    if (stringArrayAttributeName.Contains(attribute))\n                    {\n                        List<string> values = new List<string>();\n                        foreach (var value in result.Properties[attribute])\n                        {\n                            values.Add(value.ToString());\n                        }\n                        ActiveDirectoryObject.Add(attribute, values.ToArray());\n                    }\n                    // datetime attributes\n                    else if (datetimeAttributes.Contains(attribute))\n                    {\n                        if (Int64.Parse(result.Properties[attribute][0].ToString()) != 0)\n                        {\n                            ActiveDirectoryObject.Add(attribute, DateTime.FromFileTimeUtc((long)result.Properties[attribute][0]));\n                        }\n                        else\n                        {\n                            ActiveDirectoryObject.Add(attribute, DateTime.MinValue);\n                        }\n                    }\n                    // deal with objectsid\n                    else if (attribute.Equals("objectsid"))\n                    {\n                        ActiveDirectoryObject.Add(attribute, new SecurityIdentifier((byte[])result.Properties[attribute][0], 0).Value);\n                    }\n                    // deal with ints\n                    else if (intAttributes.Contains(attribute))\n                    {\n                        ActiveDirectoryObject.Add(attribute, result.Properties[attribute][0]);\n                    }\n                    // default action convert to string\n                    else\n                    {\n                        ActiveDirectoryObject.Add(attribute, result.Properties[attribute][0].ToString());\n                    }\n                }\n\n                ActiveDirectoryObjects.Add(ActiveDirectoryObject);\n            }\n\n            return ActiveDirectoryObjects;\n        }\n\n        #endregion\n    }\n}'