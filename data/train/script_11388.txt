b'{-# LANGUAGE GADTs #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n{-# LANGUAGE NoMonomorphismRestriction #-}\n\n----------------------------\n\n----------------------------\n\n-- | describe world object\nmodule SampleActor where\n\nimport Control.Applicative\nimport Control.Category\nimport Control.Concurrent\nimport Control.Lens\nimport Control.Monad (unless, void, when)\nimport Control.Monad.Reader\nimport Control.Monad.State\n--\nimport Control.Monad.Trans.Crtn\nimport Control.Monad.Trans.Crtn.Event\nimport Control.Monad.Trans.Crtn.Object\nimport Control.Monad.Trans.Crtn.Queue\nimport Control.Monad.Trans.Except\n--\nimport Event\n--\nimport Prelude hiding (id, (.))\n\n-- | full state of world\ndata WorldState = WorldState\n  { _isDoorOpen :: Bool,\n    _message :: String,\n    _tempLog :: String -> String,\n    _tempQueue :: Queue (Either (ActionOrder Event) Event)\n  }\n\n-- | isDoorOpen lens\nisDoorOpen :: Lens\' WorldState Bool\nisDoorOpen = lens _isDoorOpen (\\a b -> a {_isDoorOpen = b})\n\n-- | messageBoard lens\nmessage :: Lens\' WorldState String\nmessage = lens _message (\\a b -> a {_message = b})\n\n-- |\ntempLog :: Lens\' WorldState (String -> String)\ntempLog = lens _tempLog (\\a b -> a {_tempLog = b})\n\n-- |\ntempQueue :: Lens\' WorldState (Queue (Either (ActionOrder Event) Event))\ntempQueue = lens _tempQueue (\\a b -> a {_tempQueue = b})\n\n-- |\nemptyWorldState :: WorldState\nemptyWorldState = WorldState False "" id emptyQueue\n\ntype WorldObject m r = SObjT SubOp (StateT (WorldAttrib m) m) r\n\n-- | full collection of actors in world\ndata WorldActor m = WorldActor\n  { _objDoor :: WorldObject m (),\n    _objMessageBoard :: WorldObject m (),\n    _objAir :: WorldObject m ()\n  }\n\n-- | isDoorOpen lens\nobjDoor :: Lens\' (WorldActor m) (SObjT SubOp (StateT (WorldAttrib m) m) ())\nobjDoor = lens _objDoor (\\a b -> a {_objDoor = b})\n\n-- | messageBoard lens\nobjMessageBoard :: Lens\' (WorldActor m) (SObjT SubOp (StateT (WorldAttrib m) m) ())\nobjMessageBoard = lens _objMessageBoard (\\a b -> a {_objMessageBoard = b})\n\n-- | air lens\nobjAir :: Lens\' (WorldActor m) (SObjT SubOp (StateT (WorldAttrib m) m) ())\nobjAir = lens _objAir (\\a b -> a {_objAir = b})\n\n-- |\ninitWorldActor :: (Monad m) => WorldActor m\ninitWorldActor =\n  WorldActor\n    { _objDoor = door,\n      _objMessageBoard = messageBoard,\n      _objAir = air\n    }\n\n-- |\ndata WorldAttrib m = WorldAttrib\n  { _worldState :: WorldState,\n    _worldActor :: WorldActor m\n  }\n\n-- | lens\nworldState :: Lens\' (WorldAttrib m) WorldState\nworldState = lens _worldState (\\a b -> a {_worldState = b})\n\n-- | lens\nworldActor :: Lens\' (WorldAttrib m) (WorldActor m)\nworldActor = lens _worldActor (\\a b -> a {_worldActor = b})\n\n-- | initialization\ninitWorld :: (Monad m) => WorldAttrib m\ninitWorld = WorldAttrib emptyWorldState initWorldActor\n\n-- |\ndata SubOp i o where\n  GiveEventSub :: SubOp Event ()\n\n-- |\ngiveEventSub :: (Monad m) => Event -> CObjT SubOp m ()\ngiveEventSub ev = void $ request (Arg GiveEventSub ev)\n\n-- | air object\nair :: forall m. (Monad m) => SObjT SubOp (StateT (WorldAttrib m) m) ()\nair = ReaderT airW\n  where\n    airW :: Arg SubOp -> CrtnT (Res SubOp) (Arg SubOp) (StateT (WorldAttrib m) m) ()\n    airW (Arg GiveEventSub ev) = do\n      r <- case ev of\n        Sound s -> do\n          modify (worldState . tempLog %~ (. (++ "sound " ++ s ++ "\\n")))\n          let action = Left . ActionOrder $\n                \\evhandler -> do\n                  forkIO $ do\n                    threadDelay 10000000\n                    putStrLn "BAAAAAMM"\n                    evhandler (Message "HAHAHAH")\n                  putStrLn "hey"\n                  return (Message "Gombalbadak")\n          modify (worldState . tempQueue %~ enqueue action)\n          return True\n        _ -> return False\n      req <-\n        if r\n          then request (Res GiveEventSub ())\n          else request Ign\n      airW req\n\n-- | door object\ndoor :: forall m. (Monad m) => SObjT SubOp (StateT (WorldAttrib m) m) ()\ndoor = ReaderT doorW\n  where\n    doorW :: Arg SubOp -> CrtnT (Res SubOp) (Arg SubOp) (StateT (WorldAttrib m) m) ()\n    doorW (Arg GiveEventSub ev) = do\n      r <- case ev of\n        Open -> do\n          b <- gets (^. worldState . isDoorOpen)\n          unless b $ do\n            modify (worldState . isDoorOpen .~ True)\n            modify (worldState . tempLog %~ (. (++ "door opened\\n")))\n          return True\n        Close -> do\n          b <- gets (^. worldState . isDoorOpen)\n          when b $ do\n            modify (worldState . isDoorOpen .~ False)\n            modify (worldState . tempLog %~ (. (++ "door closed\\n")))\n            modify (worldState . tempQueue %~ enqueue (Right (Sound "bam!")))\n          return True\n        Render -> do\n          b <- gets (^. worldState . isDoorOpen)\n          modify (worldState . tempLog %~ (. (++ "current door state : " ++ show b ++ "\\n")))\n          return True\n        _ -> return False\n      req <-\n        if r\n          then request (Res GiveEventSub ())\n          else request Ign\n      doorW req\n\n-- |\nmessageBoard :: forall m. Monad m => SObjT SubOp (StateT (WorldAttrib m) m) ()\nmessageBoard = ReaderT msgbdW\n  where\n    msgbdW :: Arg SubOp -> CrtnT (Res SubOp) (Arg SubOp) (StateT (WorldAttrib m) m) ()\n    msgbdW (Arg GiveEventSub ev) = do\n      r <- case ev of\n        Message msg -> do\n          modify (worldState . message .~ msg)\n          return True\n        Render -> do\n          msg <- gets (^. worldState . message)\n          modify\n            ( worldState . tempLog\n                %~ (. (++ "current msg : " ++ msg ++ "\\n"))\n            )\n          return True\n        _ -> return False\n      req <-\n        if r\n          then request (Res GiveEventSub ())\n          else request Ign\n      msgbdW req\n'