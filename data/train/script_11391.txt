b'using loc = pair<int, int>;\nint dx[] = {1, -1, 0, 0};\nint dy[] = {0, 0, 1, -1};\nclass Solution {\npublic:\n    vector<vector<int>> updateMatrix(vector<vector<int>>& mat) {\n        int n = mat.size(), m = mat[0].size();\n        \n        vector<vector<int>> dis(n, vector<int>(m, INT_MAX));\n        // dis[i][j] = nearest distance (i, j) to nearest 0\n        \n        queue<loc> q;\n        for(int i = 0; i < n; i++) {\n            for(int j = 0; j < m; j++) {\n                if (mat[i][j] == 0) {\n                    q.push({i, j});\n                    dis[i][j] = 0;\n                }\n            }\n        }\n        \n        while(!q.empty()) {\n            // loc cur = q.front(); \n            // int x = cur.first, y = cur.second;\n            auto [x, y] = q.front(); // current loc in mat, structured binding in C++\n            q.pop();\n            // (2,3) -> (1, 3) up, (3, 3) down, +1 -1 on the columns as well\n            for(int k = 0; k < 4; k++) {\n                int nx = x + dx[k], ny = y + dy[k];\n                if (0 <= nx && nx < n && 0 <= ny && ny < m) {\n                    // valid neighbour\n                    if (dis[nx][ny] == INT_MAX) {\n                        dis[nx][ny] = 1 + dis[x][y];\n                        q.push({nx, ny});\n                    }\n                }\n            }\n        }\n        \n        return dis;\n    }\n};\n\n/*\n// BFS gives the shortest path in unweighted graphs\n\nn * m <--- 0s and 1s\n    \n    for every 1:\n        compute the smallest distance to 0\n            \ndis[i][j] = 0 where mat[i][j] = 0\n            \nqueue<> Q = {(i,j)} where mat[i][j] = 0;\n\ncur = Q.front();\n\nfor(nei in neighbors(cur)) {\n    dis[nei] = 1 + dis[cur] if nei is not alreaady in queue\n}\n\n*/\n\n'