b'\xef\xbb\xbfusing UnityEngine;\nusing System.Collections;\n\npublic enum LightShaftsShadowmapMode\n{\n\tDynamic = 0,\n\tStatic = 1\t\n}\n\npublic partial class LightShafts : MonoBehaviour\n{\n\tpublic bool directional {get{return m_LightType == LightType.Directional;}}\n\tpublic bool spot {get{return m_LightType == LightType.Spot;}}\n\n\tBounds GetBoundsLocal()\n\t{\n\t\tif (directional)\n\t\t\treturn new Bounds(new Vector3(0, 0, m_Size.z*0.5f), m_Size);\n\n\t\tLight l = m_Light;\n\t\tVector3 offset = new Vector3(0, 0, l.range * (m_SpotFar + m_SpotNear) * 0.5f);\n\t\tfloat height = (m_SpotFar - m_SpotNear) * l.range;\n\t\tfloat baseSize = Mathf.Tan(l.spotAngle * Mathf.Deg2Rad * 0.5f) * m_SpotFar * l.range * 2.0f;\n\t\treturn new Bounds(offset, new Vector3(baseSize, baseSize, height));\n\t}\n\n\tMatrix4x4 GetBoundsMatrix()\n\t{\n\t\tBounds bounds = GetBoundsLocal();\n\t\tTransform t = transform;\n\t\treturn Matrix4x4.TRS(t.position + t.forward * bounds.center.z, t.rotation, bounds.size);\n\t}\n\n\tfloat GetFrustumApex()\n\t{\n\t\t// Assuming the frustum is inscribed in a unit cube centered at 0\n\t\treturn - m_SpotNear/(m_SpotFar - m_SpotNear) - 0.5f;\n\t}\n\n\tvoid OnDrawGizmosSelected()\n\t{\n\t\tUpdateLightType();\n\t\t\n\t\tGizmos.color = Color.yellow;\n\t\tif (directional)\n\t\t{\n\t\t\tGizmos.matrix = GetBoundsMatrix();\n\t\t\tGizmos.DrawWireCube(Vector3.zero, Vector3.one);\n\t\t}\n\t\telse if (spot)\n\t\t{\n\t\t\tTransform t = transform;\n\t\t\tLight l = m_Light;\n\t\t\tGizmos.matrix = Matrix4x4.TRS(t.position, t.rotation, Vector3.one);\n\t\t\tGizmos.DrawFrustum(t.position, l.spotAngle, l.range * m_SpotFar, l.range * m_SpotNear, 1);\n\t\t}\n\t}\n\n\tvoid RenderQuadSections(Vector4 lightPos)\n\t{\n\t\tfor (int i = 0; i < 4; i++)\n\t\t{\n\t\t\t// Skip one or two quarters, if the light is off screen\n\t\t\tif (i == 0 && lightPos.y > 1 ||\n\t\t\t\ti == 1 && lightPos.x > 1 ||\n\t\t\t\ti == 2 && lightPos.y < -1 ||\n\t\t\t\ti == 3 && lightPos.x < -1)\n\t\t\t\tcontinue;\n\n\t\t\t// index denotes which quarter of the screen to take up,\n\t\t\t// so start at -1, -0.5, 0 or 0.5\n\t\t\tfloat top = i / 2.0f - 1.0f;\n\t\t\tfloat bottom = top + 0.5f;\n\t\t\tGL.Begin(GL.QUADS);\n\t\t\tGL.Vertex3(-1, top, 0);\n\t\t\tGL.Vertex3(1, top, 0);\n\t\t\tGL.Vertex3(1, bottom, 0);\n\t\t\tGL.Vertex3(-1, bottom, 0);\n\t\t\tGL.End();\n\t\t}\n\t}\n\n\tvoid RenderQuad()\n\t{\n\t\tGL.Begin(GL.QUADS);\n\t\tGL.TexCoord2( 0, 0);\n\t\tGL.Vertex3\t(-1,-1, 0);\n\t\tGL.TexCoord2( 0, 1);\n\t\tGL.Vertex3\t(-1, 1, 0);\n\t\tGL.TexCoord2( 1, 1);\n\t\tGL.Vertex3\t( 1, 1, 0);\n\t\tGL.TexCoord2( 1, 0);\n\t\tGL.Vertex3\t( 1,-1, 0);\n\t\tGL.End();\n\t}\n\n\tvoid RenderSpotFrustum()\n\t{\n\t\tGraphics.DrawMeshNow(m_SpotMesh, transform.position, transform.rotation);\n\t}\n\n\tVector4 GetLightViewportPos()\n\t{\n\t\tVector3 lightPos = transform.position;\n\t\tif (directional)\n\t\t\tlightPos = m_CurrentCamera.transform.position + transform.forward;\n\n\t\tVector3 lightViewportPos3 = m_CurrentCamera.WorldToViewportPoint(lightPos);\n\t\treturn new Vector4(lightViewportPos3.x*2.0f - 1.0f, lightViewportPos3.y*2.0f - 1.0f, 0, 0);\n\t}\n\n\tbool IsVisible()\n\t{\n\t\t// Intersect against spot light\'s OBB (or light frustum\'s OBB), so AABB in it\'s space\n\t\tMatrix4x4 lightToCameraProjection = m_CurrentCamera.projectionMatrix * m_CurrentCamera.worldToCameraMatrix * transform.localToWorldMatrix;\n\t\treturn GeometryUtility.TestPlanesAABB(GeometryUtility.CalculateFrustumPlanes(lightToCameraProjection), GetBoundsLocal());\n\t}\n\n\tbool IntersectsNearPlane()\n\t{\n\t\t// Lazy for now:\n\t\t// Just check if any vertex is behind the near plane.\n\t\t// TODO: same for directional\n\t\tVector3[] vertices = m_SpotMesh.vertices;\n\t\tfloat nearPlaneFudged = m_CurrentCamera.nearClipPlane - 0.001f;\n\t\tTransform t = transform;\n\t\tfor (int i = 0; i < vertices.Length; i++)\n\t\t{\n\t\t\tfloat z = m_CurrentCamera.WorldToViewportPoint(t.TransformPoint(vertices[i])).z;\n\t\t\tif (z < nearPlaneFudged)\n\t\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tvoid SetKeyword(bool firstOn, string firstKeyword, string secondKeyword)\n\t{\n\t\tShader.EnableKeyword(firstOn ? firstKeyword : secondKeyword);\n\t\tShader.DisableKeyword(firstOn ? secondKeyword : firstKeyword);\n\t}\n\n\tpublic void SetShadowmapDirty()\n\t{\n\t\tm_ShadowmapDirty = true;\n\t}\n\n\tvoid GetFrustumRays(out Matrix4x4 frustumRays, out Vector3 cameraPosLocal)\n\t{\n\t\tfloat far = m_CurrentCamera.farClipPlane;\n\t\tVector3 cameraPos = m_CurrentCamera.transform.position;\n\t\tMatrix4x4 m = GetBoundsMatrix().inverse;\n\t\tVector2[] uvs = new Vector2[] {new Vector2(0, 0), new Vector2(1, 0), new Vector2(1, 1), new Vector2(0, 1)};\n\t\tfrustumRays = new Matrix4x4();\n\n\t\tfor (int i = 0; i < 4; i++)\n\t\t{\n\t\t\tVector3 ray = m_CurrentCamera.ViewportToWorldPoint(new Vector3(uvs[i].x, uvs[i].y, far)) - cameraPos;\n\t\t\tray = m.MultiplyVector(ray);\n\t\t\tfrustumRays.SetRow(i, ray);\n\t\t}\n\n\t\tcameraPosLocal = m.MultiplyPoint3x4(cameraPos);\n\t}\n\n\tvoid SetFrustumRays(Material material)\n\t{\n\t\tMatrix4x4 frustumRays;\n\t\tVector3 cameraPosLocal;\n\t\tGetFrustumRays(out frustumRays, out cameraPosLocal);\n\t\tmaterial.SetVector("_CameraPosLocal", cameraPosLocal);\n\t\tmaterial.SetMatrix("_FrustumRays", frustumRays);\n\t\tmaterial.SetFloat("_FrustumApex", GetFrustumApex());\n\t}\n\n\tfloat GetDepthThresholdAdjusted()\n\t{\n\t\treturn m_DepthThreshold/m_CurrentCamera.farClipPlane;\n\t}\n\n\tbool CheckCamera()\n\t{\n\t\tif (m_Cameras == null)\n\t\t\treturn false;\n\n\t\tforeach (Camera cam in m_Cameras)\n\t\t\tif (cam == m_CurrentCamera)\n\t\t\t\treturn true;\n\n\t\treturn false;\n\t}\n\n\tpublic void UpdateCameraDepthMode()\n\t{\n\t\tif (m_Cameras == null)\n\t\t\treturn;\n\n\t\tforeach(Camera cam in m_Cameras)\n\t\t\tif (cam)\n\t\t\t\tcam.depthTextureMode |= DepthTextureMode.Depth;\n\t}\n}\n'