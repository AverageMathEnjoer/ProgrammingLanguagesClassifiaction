b'using System;\nusing System.Diagnostics;\nusing System.Text;\n\nnamespace CS_SQLite3\n{\n  public partial class CSSQLite\n  {\n    /*\n    ** 2001 September 15\n    **\n    ** The author disclaims copyright to this source code.  In place of\n    ** a legal notice, here is a blessing:\n    **\n    **    May you do good and not evil.\n    **    May you find forgiveness for yourself and forgive others.\n    **    May you share freely, never taking more than you give.\n    **\n    *************************************************************************\n    ** An tokenizer for SQL\n    **\n    ** This file contains C code that splits an SQL input string up into\n    ** individual tokens and sends those tokens one-by-one over to the\n    ** parser for analysis.\n    **\n    ** $Id: tokenize.c,v 1.163 2009/07/03 22:54:37 drh Exp $\n    **\n    *************************************************************************\n    **  Included in SQLite3 port to C#-SQLite;  2008 Noah B Hart\n    **  C#-SQLite is an independent reimplementation of the SQLite software library\n    **\n    **  $Header$\n    *************************************************************************\n    */\n    //#include "sqliteInt.h"\n    //#include <stdlib.h>\n\n    /*\n    ** The charMap() macro maps alphabetic characters into their\n    ** lower-case ASCII equivalent.  On ASCII machines, this is just\n    ** an upper-to-lower case map.  On EBCDIC machines we also need\n    ** to adjust the encoding.  Only alphabetic characters and underscores\n    ** need to be translated.\n    */\n#if SQLITE_ASCII\n    //# define charMap(X) sqlite3UpperToLower[(unsigned char)X]\n#endif\n#if SQLITE_EBCDIC\n//# define charMap(X) ebcdicToAscii[(unsigned char)X]\n//const unsigned char ebcdicToAscii[] = {\n/* 0   1   2   3   4   5   6   7   8   9   A   B   C   D   E   F */\n//   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  /* 0x */\n//   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  /* 1x */\n//   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  /* 2x */\n//   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  /* 3x */\n//   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  /* 4x */\n//   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  /* 5x */\n//   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 95,  0,  0,  /* 6x */\n//   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  /* 7x */\n//   0, 97, 98, 99,100,101,102,103,104,105,  0,  0,  0,  0,  0,  0,  /* 8x */\n//   0,106,107,108,109,110,111,112,113,114,  0,  0,  0,  0,  0,  0,  /* 9x */\n//   0,  0,115,116,117,118,119,120,121,122,  0,  0,  0,  0,  0,  0,  /* Ax */\n//   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  /* Bx */\n//   0, 97, 98, 99,100,101,102,103,104,105,  0,  0,  0,  0,  0,  0,  /* Cx */\n//   0,106,107,108,109,110,111,112,113,114,  0,  0,  0,  0,  0,  0,  /* Dx */\n//   0,  0,115,116,117,118,119,120,121,122,  0,  0,  0,  0,  0,  0,  /* Ex */\n//   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  /* Fx */\n//};\n#endif\n\n    /*\n** The sqlite3KeywordCode function looks up an identifier to determine if\n** it is a keyword.  If it is a keyword, the token code of that keyword is\n** returned.  If the input is not a keyword, TK_ID is returned.\n**\n** The implementation of this routine was generated by a program,\n** mkkeywordhash.h, located in the tool subdirectory of the distribution.\n** The output of the mkkeywordhash.c program is written into a file\n** named keywordhash.h and then included into this source file by\n** the #include below.\n*/\n    //#include "keywordhash.h"\n\n\n    /*\n    ** If X is a character that can be used in an identifier then\n    ** IdChar(X) will be true.  Otherwise it is false.\n    **\n    ** For ASCII, any character with the high-order bit set is\n    ** allowed in an identifier.  For 7-bit characters,\n    ** sqlite3IsIdChar[X] must be 1.\n    **\n    ** For EBCDIC, the rules are more complex but have the same\n    ** end result.\n    **\n    ** Ticket #1066.  the SQL standard does not allow \'$\' in the\n    ** middle of identfiers.  But many SQL implementations do.\n    ** SQLite will allow \'$\' in identifiers for compatibility.\n    ** But the feature is undocumented.\n    */\n#if SQLITE_ASCII\n    static bool[] sqlite3IsAsciiIdChar = {\n/* x0 x1 x2 x3 x4 x5 x6 x7 x8 x9 xA xB xC xD xE xF */\nfalse, false, false, false, true, false, false, false, false, false, false, false, false, false, false, false,  /* 2x */\ntrue, true, true, true, true, true, true, true, true, true, false, false, false, false, false, false,  /* 3x */\nfalse, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true,  /* 4x */\ntrue, true, true, true, true, true, true, true, true, true, true, false, false, false, false, true,  /* 5x */\nfalse, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true,  /* 6x */\ntrue, true, true, true, true, true, true, true, true, true, true, false, false, false, false, false,  /* 7x */\n};\n    //#define IdChar(C)  (((c=C)&0x80)!=0 || (c>0x1f && sqlite3IsAsciiIdChar[c-0x20]))\n#endif\n#if SQLITE_EBCDIC\n//const char sqlite3IsEbcdicIdChar[] = {\n/* x0 x1 x2 x3 x4 x5 x6 x7 x8 x9 xA xB xC xD xE xF */\n//    0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0,  /* 4x */\n//    0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0,  /* 5x */\n//    0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0,  /* 6x */\n//    0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0,  /* 7x */\n//    0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 0,  /* 8x */\n//    0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 0, 1, 0,  /* 9x */\n//    1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0,  /* Ax */\n//    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  /* Bx */\n//    0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1,  /* Cx */\n//    0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1,  /* Dx */\n//    0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1,  /* Ex */\n//    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 0,  /* Fx */\n//};\n//#define IdChar(C)  (((c=C)>=0x42 && sqlite3IsEbcdicIdChar[c-0x40]))\n#endif\n\n\n    /*\n** Return the length of the token that begins at z[0].\n** Store the token type in *tokenType before returning.\n*/\n    static int sqlite3GetToken( string z, int iOffset, ref int tokenType )\n    {\n      int i;\n      byte c = 0;\n      switch ( z[iOffset + 0] )\n      {\n        case \' \':\n        case \'\\t\':\n        case \'\\n\':\n        case \'\\f\':\n        case \'\\r\':\n          {\n            testcase( z[0] == \' \' );\n            testcase( z[0] == \'\\t\' );\n            testcase( z[0] == \'\\n\' );\n            testcase( z[0] == \'\\f\' );\n            testcase( z[0] == \'\\r\' );\n            for ( i = 1 ; z.Length > iOffset + i && sqlite3Isspace( z[iOffset + i] ) ; i++ ) { }\n            tokenType = TK_SPACE;\n            return i;\n          }\n        case \'-\':\n          {\n            if ( z.Length > iOffset + 1 && z[iOffset + 1] == \'-\' )\n            {\n              for ( i = 2 ; z.Length > iOffset + i && ( c = (byte)z[iOffset + i] ) != 0 && c != \'\\n\' ; i++ ) { }\n              tokenType = TK_SPACE;\n              return i;\n            }\n            tokenType = TK_MINUS;\n            return 1;\n          }\n        case \'(\':\n          {\n            tokenType = TK_LP;\n            return 1;\n          }\n        case \')\':\n          {\n            tokenType = TK_RP;\n            return 1;\n          }\n        case \';\':\n          {\n            tokenType = TK_SEMI;\n            return 1;\n          }\n        case \'+\':\n          {\n            tokenType = TK_PLUS;\n            return 1;\n          }\n        case \'*\':\n          {\n            tokenType = TK_STAR;\n            return 1;\n          }\n        case \'/\':\n          {\n            if ( iOffset + 2 >= z.Length || z[iOffset + 1] != \'*\' )\n            {\n              tokenType = TK_SLASH;\n              return 1;\n            }\n            for ( i = 3, c = (byte)z[iOffset + 2] ; iOffset + i < z.Length && ( c != \'*\' || ( z[iOffset + i] != \'/\' ) && ( c != 0 ) ) ; i++ ) { c = (byte)z[iOffset + i]; }\n            if ( iOffset + i == z.Length ) c = 0;\n            if ( c != 0 ) i++;\n            tokenType = TK_SPACE;\n            return i;\n          }\n        case \'%\':\n          {\n            tokenType = TK_REM;\n            return 1;\n          }\n        case \'=\':\n          {\n            tokenType = TK_EQ;\n            return 1 + ( z[iOffset + 1] == \'=\' ? 1 : 0 );\n          }\n        case \'<\':\n          {\n            if ( ( c = (byte)z[iOffset + 1] ) == \'=\' )\n            {\n              tokenType = TK_LE;\n              return 2;\n            }\n            else if ( c == \'>\' )\n            {\n              tokenType = TK_NE;\n              return 2;\n            }\n            else if ( c == \'<\' )\n            {\n              tokenType = TK_LSHIFT;\n              return 2;\n            }\n            else\n            {\n              tokenType = TK_LT;\n              return 1;\n            }\n          }\n        case \'>\':\n          {\n            if ( z.Length > iOffset + 1 && ( c = (byte)z[iOffset + 1] ) == \'=\' )\n            {\n              tokenType = TK_GE;\n              return 2;\n            }\n            else if ( c == \'>\' )\n            {\n              tokenType = TK_RSHIFT;\n              return 2;\n            }\n            else\n            {\n              tokenType = TK_GT;\n              return 1;\n            }\n          }\n        case \'!\':\n          {\n            if ( z[iOffset + 1] != \'=\' )\n            {\n              tokenType = TK_ILLEGAL;\n              return 2;\n            }\n            else\n            {\n              tokenType = TK_NE;\n              return 2;\n            }\n          }\n        case \'|\':\n          {\n            if ( z[iOffset + 1] != \'|\' )\n            {\n              tokenType = TK_BITOR;\n              return 1;\n            }\n            else\n            {\n              tokenType = TK_CONCAT;\n              return 2;\n            }\n          }\n        case \',\':\n          {\n            tokenType = TK_COMMA;\n            return 1;\n          }\n        case \'&\':\n          {\n            tokenType = TK_BITAND;\n            return 1;\n          }\n        case \'~\':\n          {\n            tokenType = TK_BITNOT;\n            return 1;\n          }\n        case \'`\':\n        case \'\\\'\':\n        case \'"\':\n          {\n            int delim = z[iOffset + 0];\n            testcase( delim == \'`\' );\n            testcase( delim == \'\\\'\' );\n            testcase( delim == \'"\' );\n            for ( i = 1 ; ( iOffset + i ) < z.Length && ( c = (byte)z[iOffset + i] ) != 0 ; i++ )\n            {\n              if ( c == delim )\n              {\n                if ( z.Length > iOffset + i + 1 && z[iOffset + i + 1] == delim )\n                {\n                  i++;\n                }\n                else\n                {\n                  break;\n                }\n              }\n            }\n            if ( ( iOffset + i == z.Length && c != delim ) || z[iOffset + i] != delim )\n            {\n              tokenType = TK_ILLEGAL;\n              return i + 1;\n            }\n            if ( c == \'\\\'\' )\n            {\n              tokenType = TK_STRING;\n              return i + 1;\n            }\n            else if ( c != 0 )\n            {\n              tokenType = TK_ID;\n              return i + 1;\n            }\n            else\n            {\n              tokenType = TK_ILLEGAL;\n              return i;\n            }\n          }\n        case \'.\':\n          {\n#if !SQLITE_OMIT_FLOATING_POINT\n            if ( !sqlite3Isdigit( z[iOffset + 1] ) )\n#endif\n            {\n              tokenType = TK_DOT;\n              return 1;\n            }\n            /* If the next character is a digit, this is a floating point\n            ** number that begins with ".".  Fall thru into the next case */\n            goto case \'0\';\n          }\n        case \'0\':\n        case \'1\':\n        case \'2\':\n        case \'3\':\n        case \'4\':\n        case \'5\':\n        case \'6\':\n        case \'7\':\n        case \'8\':\n        case \'9\':\n          {\n            testcase( z[0] == \'0\' ); testcase( z[0] == \'1\' ); testcase( z[0] == \'2\' );\n            testcase( z[0] == \'3\' ); testcase( z[0] == \'4\' ); testcase( z[0] == \'5\' );\n            testcase( z[0] == \'6\' ); testcase( z[0] == \'7\' ); testcase( z[0] == \'8\' );\n            testcase( z[0] == \'9\' );\n            tokenType = TK_INTEGER;\n            for ( i = 0 ; z.Length > iOffset + i && sqlite3Isdigit( z[iOffset + i] ) ; i++ ) { }\n#if !SQLITE_OMIT_FLOATING_POINT\n            if ( z.Length > iOffset + i && z[iOffset + i] == \'.\' )\n            {\n              i++;\n              while ( z.Length > iOffset + i && sqlite3Isdigit( z[iOffset + i] ) ) { i++; }\n              tokenType = TK_FLOAT;\n            }\n            if ( z.Length > iOffset + i + 1 && ( z[iOffset + i] == \'e\' || z[iOffset + i] == \'E\' ) &&\n            ( sqlite3Isdigit( z[iOffset + i + 1] )\n            || z.Length > iOffset + i + 2 && ( ( z[iOffset + i + 1] == \'+\' || z[iOffset + i + 1] == \'-\' ) && sqlite3Isdigit( z[iOffset + i + 2] ) )\n            )\n            )\n            {\n              i += 2;\n              while ( z.Length > iOffset + i && sqlite3Isdigit( z[iOffset + i] ) ) { i++; }\n              tokenType = TK_FLOAT;\n            }\n#endif\n            while ( z.Length > iOffset + i && ( ( ( c = (byte)z[iOffset + i] ) & 0x80 ) != 0 || ( c > 0x1f && sqlite3IsAsciiIdChar[c - 0x20] ) ) )\n            {// IdChar(z[iOffset+i]) ){\n              tokenType = TK_ILLEGAL;\n              i++;\n            }\n            return i;\n          }\n        case \'[\':\n          {\n            for ( i = 1, c = (byte)z[iOffset + 0] ; c != \']\' && ( iOffset + i ) < z.Length && ( c = (byte)z[iOffset + i] ) != 0 ; i++ ) { }\n            tokenType = c == \']\' ? TK_ID : TK_ILLEGAL;\n            return i;\n          }\n        case \'?\':\n          {\n            tokenType = TK_VARIABLE;\n            for ( i = 1 ; z.Length > iOffset + i && sqlite3Isdigit( z[iOffset + i] ) ; i++ ) { }\n            return i;\n          }\n        case \'#\':\n          {\n            for ( i = 1 ; z.Length > iOffset + i && sqlite3Isdigit( z[iOffset + i] ) ; i++ ) { }\n            if ( i > 1 )\n            {\n              /* Parameters of the form #NNN (where NNN is a number) are used\n              ** internally by sqlite3NestedParse.  */\n              tokenType = TK_REGISTER;\n              return i;\n            }\n            /* Fall through into the next case if the \'#\' is not followed by\n            ** a digit. Try to match #AAAA where AAAA is a parameter name. */\n            goto case \':\';\n          }\n#if !SQLITE_OMIT_TCL_VARIABLE\n        case \'$\':\n#endif\n        case \'@\':  /* For compatibility with MS SQL Server */\n        case \':\':\n          {\n            int n = 0;\n            testcase( z[0] == \'$\' ); testcase( z[0] == \'@\' ); testcase( z[0] == \':\' );\n            tokenType = TK_VARIABLE;\n            for ( i = 1 ; z.Length > iOffset + i && ( c = (byte)z[iOffset + i] ) != 0 ; i++ )\n            {\n              if ( ( ( c & 0x80 ) != 0 || ( c > 0x1f && sqlite3IsAsciiIdChar[c - 0x20] ) ) )\n              {//IdChar(c) ){\n                n++;\n#if !SQLITE_OMIT_TCL_VARIABLE\n              }\n              else if ( c == \'(\' && n > 0 )\n              {\n                do\n                {\n                  i++;\n                } while ( ( iOffset + i ) < z.Length && ( c = (byte)z[iOffset + i] ) != 0 && !sqlite3Isspace( c ) && c != \')\' );\n                if ( c == \')\' )\n                {\n                  i++;\n                }\n                else\n                {\n                  tokenType = TK_ILLEGAL;\n                }\n                break;\n              }\n              else if ( c == \':\' && z[iOffset + i + 1] == \':\' )\n              {\n                i++;\n#endif\n              }\n              else\n              {\n                break;\n              }\n            }\n            if ( n == 0 ) tokenType = TK_ILLEGAL;\n            return i;\n          }\n#if !SQLITE_OMIT_BLOB_LITERAL\n        case \'x\':\n        case \'X\':\n          {\n            testcase( z[0] == \'x\' ); testcase( z[0] == \'X\' );\n            if ( z.Length > iOffset + 1 && z[iOffset + 1] == \'\\\'\' )\n            {\n              tokenType = TK_BLOB;\n              for ( i = 2 ; z.Length > iOffset + i && ( c = (byte)z[iOffset + i] ) != 0 && c != \'\\\'\' ; i++ )\n              {\n                if ( !sqlite3Isxdigit( c ) )\n                {\n                  tokenType = TK_ILLEGAL;\n                }\n              }\n              if ( i % 2 != 0 || z.Length == iOffset + i && c != \'\\\'\' ) tokenType = TK_ILLEGAL;\n              if ( c != 0 ) i++;\n              return i;\n            }\n            goto default;\n            /* Otherwise fall through to the next case */\n          }\n#endif\n        default:\n          {\n            if ( !( ( ( c = (byte)z[iOffset + 0] ) & 0x80 ) != 0 || ( c > 0x1f && sqlite3IsAsciiIdChar[c - 0x20] ) ) )\n            {//IdChar(*z) ){\n              break;\n            }\n            for ( i = 1 ; z.Length > iOffset + i && ( ( ( c = (byte)z[iOffset + i] ) & 0x80 ) != 0 || ( c > 0x1f && sqlite3IsAsciiIdChar[c - 0x20] ) ) ; i++ ) { }//IdChar(z[iOffset+i]); i++){}\n            tokenType = keywordCode( z, iOffset, i );\n            return i;\n          }\n      }\n      tokenType = TK_ILLEGAL;\n      return 1;\n    }\n\n    /*\n    ** Run the parser on the given SQL string.  The parser structure is\n    ** passed in.  An SQLITE_ status code is returned.  If an error occurs\n    ** then an and attempt is made to write an error message into\n    ** memory obtained from sqlite3_malloc() and to make pzErrMsg point to that\n    ** error message.\n    */\n    static int sqlite3RunParser( Parse pParse, string zSql, ref string pzErrMsg )\n    {\n      int nErr = 0;                   /* Number of errors encountered */\n      int i;                          /* Loop counter */\n      yyParser pEngine;               /* The LEMON-generated LALR(1) parser */\n      int tokenType = 0;              /* type of the next token */\n      int lastTokenParsed = -1;       /* type of the previous token */\n      byte enableLookaside;           /* Saved value of db->lookaside.bEnabled */\n      sqlite3 db = pParse.db;         /* The database connection */\n      int mxSqlLen;                   /* Max length of an SQL string */\n\n\n      mxSqlLen = db.aLimit[SQLITE_LIMIT_SQL_LENGTH];\n      if ( db.activeVdbeCnt == 0 )\n      {\n        db.u1.isInterrupted = false;\n      }\n      pParse.rc = SQLITE_OK;\n      pParse.zTail = new StringBuilder( zSql );\n      i = 0;\n      Debug.Assert( pzErrMsg != null );\n      pEngine = sqlite3ParserAlloc();//sqlite3ParserAlloc((void*(*)(size_t))sqlite3Malloc);\n      if ( pEngine == null )\n      {\n////        db.mallocFailed = 1;\n        return SQLITE_NOMEM;\n      }\n      Debug.Assert( pParse.pNewTable == null );\n      Debug.Assert( pParse.pNewTrigger == null );\n      Debug.Assert( pParse.nVar == 0 );\n      Debug.Assert( pParse.nVarExpr == 0 );\n      Debug.Assert( pParse.nVarExprAlloc == 0 );\n      Debug.Assert( pParse.apVarExpr == null );\n      enableLookaside = db.lookaside.bEnabled;\n      if ( db.lookaside.pStart != 0 ) db.lookaside.bEnabled = 1;\n      while ( /*  0 == db.mallocFailed && */  i < zSql.Length )\n      {\n        Debug.Assert( i >= 0 );\n        //pParse->sLastToken.z = &zSql[i];\n        pParse.sLastToken.n = sqlite3GetToken( zSql, i, ref tokenType );\n        pParse.sLastToken.z = zSql.Substring( i );\n        i += pParse.sLastToken.n;\n        if ( i > mxSqlLen )\n        {\n          pParse.rc = SQLITE_TOOBIG;\n          break;\n        }\n        switch ( tokenType )\n        {\n          case TK_SPACE:\n            {\n              if ( db.u1.isInterrupted )\n              {\n                sqlite3ErrorMsg( pParse, "interrupt" );\n                pParse.rc = SQLITE_INTERRUPT;\n                goto abort_parse;\n              }\n              break;\n            }\n          case TK_ILLEGAL:\n            {\n              //sqlite3DbFree( db, ref pzErrMsg );\n              pzErrMsg = sqlite3MPrintf( db, "unrecognized token: \\"%T\\"",\n                (object)pParse.sLastToken );\n              nErr++;\n              goto abort_parse;\n            }\n          case TK_SEMI:\n            {\n              //pParse.zTail = new StringBuilder(zSql.Substring( i,zSql.Length-i ));\n              /* Fall thru into the default case */\n              goto default;\n            }\n          default:\n            {\n              sqlite3Parser( pEngine, tokenType, pParse.sLastToken, pParse );\n              lastTokenParsed = tokenType;\n              if ( pParse.rc != SQLITE_OK )\n              {\n                goto abort_parse;\n              }\n              break;\n            }\n        }\n      }\nabort_parse:\n      pParse.zTail = new StringBuilder( zSql.Length <= i ? "" : zSql.Substring( i, zSql.Length - i ) );\n      if ( zSql.Length >= i && nErr == 0 && pParse.rc == SQLITE_OK )\n      {\n        if ( lastTokenParsed != TK_SEMI )\n        {\n          sqlite3Parser( pEngine, TK_SEMI, pParse.sLastToken, pParse );\n        }\n        sqlite3Parser( pEngine, 0, pParse.sLastToken, pParse );\n      }\n#if YYTRACKMAXSTACKDEPTH\nsqlite3StatusSet(SQLITE_STATUS_PARSER_STACK,\nsqlite3ParserStackPeak(pEngine)\n);\n#endif //* YYDEBUG */\n      sqlite3ParserFree(pEngine, null);//sqlite3_free );\n      db.lookaside.bEnabled = enableLookaside;\n      //if ( db.mallocFailed != 0 )\n      //{\n      //  pParse.rc = SQLITE_NOMEM;\n      //}\n      if ( pParse.rc != SQLITE_OK && pParse.rc != SQLITE_DONE && pParse.zErrMsg == "" )\n      {\n        sqlite3SetString( ref pParse.zErrMsg, db, sqlite3ErrStr( pParse.rc ) );\n      }\n      //assert( pzErrMsg!=0 );\n      if ( pParse.zErrMsg != null )\n      {\n        pzErrMsg = pParse.zErrMsg;\n        pParse.zErrMsg = "";\n        nErr++;\n      }\n      if ( pParse.pVdbe != null && pParse.nErr > 0 && pParse.nested == 0 )\n      {\n        sqlite3VdbeDelete( ref pParse.pVdbe );\n        pParse.pVdbe = null;\n      }\n#if !SQLITE_OMIT_SHARED_CACHE\nif ( pParse.nested == 0 )\n{\n//sqlite3DbFree( db, ref pParse.aTableLock );\npParse.aTableLock = null;\npParse.nTableLock = 0;\n}\n#endif\n#if !SQLITE_OMIT_VIRTUALTABLE\n//sqlite3DbFree(db,pParse.apVtabLock);\n#endif\n      if ( !IN_DECLARE_VTAB )\n      {\n        /* If the pParse.declareVtab flag is set, do not delete any table\n        ** structure built up in pParse.pNewTable. The calling code (see vtab.c)\n        ** will take responsibility for freeing the Table structure.\n        */\n        sqlite3DeleteTable( ref pParse.pNewTable );\n      }\n\n#if !SQLITE_OMIT_TRIGGER\n      sqlite3DeleteTrigger( db, ref pParse.pNewTrigger );\n#endif\n      //sqlite3DbFree( db, ref pParse.apVarExpr );\n      //sqlite3DbFree( db, ref pParse.aAlias );\n      while ( pParse.pAinc != null )\n      {\n        AutoincInfo p = pParse.pAinc;\n        pParse.pAinc = p.pNext;\n        //sqlite3DbFree( db, ref p );\n      }\n      while ( pParse.pZombieTab != null )\n      {\n        Table p = pParse.pZombieTab;\n        pParse.pZombieTab = p.pNextZombie;\n        sqlite3DeleteTable( ref p );\n      }\n      if ( nErr > 0 && pParse.rc == SQLITE_OK )\n      {\n        pParse.rc = SQLITE_ERROR;\n      }\n      return nErr;\n    }\n  }\n}\n'