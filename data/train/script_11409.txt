b'// I2Cdev library collection - HMC5843 I2C device class\n// Based on Honeywell HMC5843 datasheet, 6/2010 (Form #900367)\n// 8/22/2011 by Jeff Rowberg <jeff@rowberg.net>\n// Updates should (hopefully) always be available at https://github.com/jrowberg/i2cdevlib\n//\n// Changelog:\n//     2011-08-22 - initial release\n\n/* ============================================\nI2Cdev device library code is placed under the MIT license\nCopyright (c) 2011 Jeff Rowberg\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the "Software"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n===============================================\n*/\n\n#include "HMC5843.h"\n\n/** Default constructor, uses default I2C address.\n * @see HMC5843_DEFAULT_ADDRESS\n */\nHMC5843::HMC5843() {\n    devAddr = HMC5843_DEFAULT_ADDRESS;\n}\n\n/** Specific address constructor.\n * @param address I2C address\n * @see HMC5843_DEFAULT_ADDRESS\n * @see HMC5843_ADDRESS\n */\nHMC5843::HMC5843(uint8_t address) {\n    devAddr = address;\n}\n\n/** Power on and prepare for general usage.\n * This will prepare the magnetometer with default settings, ready for single-\n * use mode (very low power requirements). Default settings include 8-sample\n * averaging, 15 Hz data output rate, normal measurement bias, a,d 1090 gain (in\n * terms of LSB/Gauss). Be sure to adjust any settings you need specifically\n * after initialization, especially the gain settings if you happen to be seeing\n * a lot of -4096 values (see the datasheet for mor information).\n */\nvoid HMC5843::initialize() {\n    // write CONFIG_A register\n    I2Cdev::writeByte(devAddr, HMC5843_RA_CONFIG_A,\n        (HMC5843_RATE_10     << (HMC5843_CRA_RATE_BIT - HMC5843_CRA_RATE_LENGTH + 1)) |\n        (HMC5843_BIAS_NORMAL << (HMC5843_CRA_BIAS_BIT - HMC5843_CRA_BIAS_LENGTH + 1)));\n\n    // write CONFIG_B register\n    setGain(HMC5843_GAIN_1300);\n    \n    // write MODE register\n    setMode(HMC5843_MODE_SINGLE);\n}\n\n/** Verify the I2C connection.\n * Make sure the device is connected and responds as expected.\n * @return True if connection is valid, false otherwise\n */\nbool HMC5843::testConnection() {\n    if (I2Cdev::readBytes(devAddr, HMC5843_RA_ID_A, 3, buffer) == 3) {\n        return (buffer[0] == \'H\' && buffer[1] == \'4\' && buffer[2] == \'3\');\n    }\n    return false;\n}\n\n// CONFIG_A register\n\n/** Get data output rate value.\n * The Table below shows all selectable output rates in continuous measurement\n * mode. All three channels shall be measured within a given output rate.\n *\n * Value | Typical Data Output Rate (Hz)\n * ------+------------------------------\n * 0     | 0.5\n * 1     | 1\n * 2     | 2\n * 3     | 5\n * 4     | 10 (Default)\n * 5     | 20\n * 6     | 50\n * 7     | Not used\n *\n * @return Current rate of data output to registers\n * @see HMC5843_RATE_10\n * @see HMC5843_RA_CONFIG_A\n * @see HMC5843_CRA_RATE_BIT\n * @see HMC5843_CRA_RATE_LENGTH\n */\nuint8_t HMC5843::getDataRate() {\n    I2Cdev::readBits(devAddr, HMC5843_RA_CONFIG_A, HMC5843_CRA_RATE_BIT, HMC5843_CRA_RATE_LENGTH, buffer);\n    return buffer[0];\n}\n/** Set data output rate value.\n * @param rate Rate of data output to registers\n * @see getDataRate()\n * @see HMC5843_RATE_10\n * @see HMC5843_RA_CONFIG_A\n * @see HMC5843_CRA_RATE_BIT\n * @see HMC5843_CRA_RATE_LENGTH\n */\nvoid HMC5843::setDataRate(uint8_t rate) {\n    I2Cdev::writeBits(devAddr, HMC5843_RA_CONFIG_A, HMC5843_CRA_RATE_BIT, HMC5843_CRA_RATE_LENGTH, rate);\n}\n/** Get measurement bias value.\n * @return Current bias value (0-2 for normal/positive/negative respectively)\n * @see HMC5843_BIAS_NORMAL\n * @see HMC5843_RA_CONFIG_A\n * @see HMC5843_CRA_BIAS_BIT\n * @see HMC5843_CRA_BIAS_LENGTH\n */\nuint8_t HMC5843::getMeasurementBias() {\n    I2Cdev::readBits(devAddr, HMC5843_RA_CONFIG_A, HMC5843_CRA_BIAS_BIT, HMC5843_CRA_BIAS_LENGTH, buffer);\n    return buffer[0];\n}\n/** Set measurement bias value.\n * @param bias New bias value (0-2 for normal/positive/negative respectively)\n * @see HMC5843_BIAS_NORMAL\n * @see HMC5843_RA_CONFIG_A\n * @see HMC5843_CRA_BIAS_BIT\n * @see HMC5843_CRA_BIAS_LENGTH\n */\nvoid HMC5843::setMeasurementBias(uint8_t bias) {\n    I2Cdev::writeBits(devAddr, HMC5843_RA_CONFIG_A, HMC5843_CRA_BIAS_BIT, HMC5843_CRA_BIAS_LENGTH, bias);\n}\n\n// CONFIG_B register\n\n/** Get magnetic field gain value.\n * The table below shows nominal gain settings. Use the Gain column to convert\n * counts to Gauss. Choose a lower gain value (higher GN#) when total field\n * strength causes overflow in one of the data output registers (saturation).\n * The data output range for all settings is 0xF800-0x07FF (-2048 - 2047).\n *\n * Value | Field Range | Gain (LSB/Gauss)\n * ------+-------------+-----------------\n * 0     | +/- 0.7 Ga  | 1620\n * 1     | +/- 1.0 Ga  | 1300 (Default)\n * 2     | +/- 1.5 Ga  | 970\n * 3     | +/- 2.0 Ga  | 780\n * 4     | +/- 3.2 Ga  | 530\n * 5     | +/- 3.8 Ga  | 460\n * 6     | +/- 4.5 Ga  | 390\n * 7     | +/- 6.5 Ga  | 280 (Not recommended)\n *\n * @return Current magnetic field gain value\n * @see HMC5843_GAIN_1300\n * @see HMC5843_RA_CONFIG_B\n * @see HMC5843_CRB_GAIN_BIT\n * @see HMC5843_CRB_GAIN_LENGTH\n */\nuint8_t HMC5843::getGain() {\n    I2Cdev::readBits(devAddr, HMC5843_RA_CONFIG_B, HMC5843_CRB_GAIN_BIT, HMC5843_CRB_GAIN_LENGTH, buffer);\n    return buffer[0];\n}\n/** Set magnetic field gain value.\n * @param gain New magnetic field gain value\n * @see getGain()\n * @see HMC5843_RA_CONFIG_B\n * @see HMC5843_CRB_GAIN_BIT\n * @see HMC5843_CRB_GAIN_LENGTH\n */\nvoid HMC5843::setGain(uint8_t gain) {\n    // use this method to guarantee that bits 4-0 are set to zero, which is a\n    // requirement specified in the datasheet; it\'s actually more efficient than\n    // using the I2Cdev.writeBits method\n    I2Cdev::writeByte(devAddr, HMC5843_RA_CONFIG_B, gain << (HMC5843_CRB_GAIN_BIT - HMC5843_CRB_GAIN_LENGTH + 1));\n}\n\n// MODE register\n\n/** Get measurement mode.\n * In continuous-measurement mode, the device continuously performs measurements\n * and places the result in the data register. RDY goes high when new data is\n * placed in all three registers. After a power-on or a write to the mode or\n * configuration register, the first measurement set is available from all three\n * data output registers after a period of 2/fDO and subsequent measurements are\n * available at a frequency of fDO, where fDO is the frequency of data output.\n *\n * When single-measurement mode (default) is selected, device performs a single\n * measurement, sets RDY high and returned to idle mode. Mode register returns\n * to idle mode bit values. The measurement remains in the data output register\n * and RDY remains high until the data output register is read or another\n * measurement is performed.\n *\n * @return Current measurement mode\n * @see HMC5843_MODE_CONTINUOUS\n * @see HMC5843_MODE_SINGLE\n * @see HMC5843_MODE_IDLE\n * @see HMC5843_MODE_SLEEP\n * @see HMC5843_RA_MODE\n * @see HMC5843_MODEREG_BIT\n * @see HMC5843_MODEREG_LENGTH\n */\nuint8_t HMC5843::getMode() {\n    I2Cdev::readBits(devAddr, HMC5843_RA_MODE, HMC5843_MODEREG_BIT, HMC5843_MODEREG_LENGTH, buffer);\n    return buffer[0];\n}\n/** Set measurement mode.\n * @param newMode New measurement mode\n * @see getMode()\n * @see HMC5843_MODE_CONTINUOUS\n * @see HMC5843_MODE_SINGLE\n * @see HMC5843_MODE_IDLE\n * @see HMC5843_MODE_SLEEP\n * @see HMC5843_RA_MODE\n * @see HMC5843_MODEREG_BIT\n * @see HMC5843_MODEREG_LENGTH\n */\nvoid HMC5843::setMode(uint8_t newMode) {\n    // use this method to guarantee that bits 7-2 are set to zero, which is a\n    // requirement specified in the datasheet; it\'s actually more efficient than\n    // using the I2Cdev.writeBits method\n    I2Cdev::writeByte(devAddr, HMC5843_RA_MODE, newMode << (HMC5843_MODEREG_BIT - HMC5843_MODEREG_LENGTH + 1));\n    mode = newMode; // track to tell if we have to clear bit 7 after a read\n}\n\n// DATA* registers\n\n/** Get 3-axis heading measurements.\n * In the event the ADC reading overflows or underflows for the given channel,\n * or if there is a math overflow during the bias measurement, this data\n * register will contain the value -4096. This register value will clear when\n * after the next valid measurement is made. Note that this method automatically\n * clears the appropriate bit in the MODE register if Single mode is active.\n * @param x 16-bit signed integer container for X-axis heading\n * @param y 16-bit signed integer container for Y-axis heading\n * @param z 16-bit signed integer container for Z-axis heading\n * @see HMC5843_RA_DATAX_H\n */\nvoid HMC5843::getHeading(int16_t *x, int16_t *y, int16_t *z) {\n    I2Cdev::readBytes(devAddr, HMC5843_RA_DATAX_H, 6, buffer);\n    if (mode == HMC5843_MODE_SINGLE) I2Cdev::writeByte(devAddr, HMC5843_RA_MODE, HMC5843_MODE_SINGLE << (HMC5843_MODEREG_BIT - HMC5843_MODEREG_LENGTH + 1));\n    *x = (((int16_t)buffer[0]) << 8) | buffer[1];\n    *y = (((int16_t)buffer[2]) << 8) | buffer[3];\n    *z = (((int16_t)buffer[4]) << 8) | buffer[5];\n}\n/** Get X-axis heading measurement.\n * @return 16-bit signed integer with X-axis heading\n * @see HMC5843_RA_DATAX_H\n */\nint16_t HMC5843::getHeadingX() {\n    // each axis read requires that ALL axis registers be read, even if only\n    // one is used; this was not done ineffiently in the code by accident\n    I2Cdev::readBytes(devAddr, HMC5843_RA_DATAX_H, 6, buffer);\n    if (mode == HMC5843_MODE_SINGLE) I2Cdev::writeByte(devAddr, HMC5843_RA_MODE, HMC5843_MODE_SINGLE << (HMC5843_MODEREG_BIT - HMC5843_MODEREG_LENGTH + 1));\n    return (((int16_t)buffer[0]) << 8) | buffer[1];\n}\n/** Get Y-axis heading measurement.\n * @return 16-bit signed integer with Y-axis heading\n * @see HMC5843_RA_DATAY_H\n */\nint16_t HMC5843::getHeadingY() {\n    // each axis read requires that ALL axis registers be read, even if only\n    // one is used; this was not done ineffiently in the code by accident\n    I2Cdev::readBytes(devAddr, HMC5843_RA_DATAX_H, 6, buffer);\n    if (mode == HMC5843_MODE_SINGLE) I2Cdev::writeByte(devAddr, HMC5843_RA_MODE, HMC5843_MODE_SINGLE << (HMC5843_MODEREG_BIT - HMC5843_MODEREG_LENGTH + 1));\n    return (((int16_t)buffer[2]) << 8) | buffer[3];\n}\n/** Get Z-axis heading measurement.\n * @return 16-bit signed integer with Z-axis heading\n * @see HMC5843_RA_DATAZ_H\n */\nint16_t HMC5843::getHeadingZ() {\n    // each axis read requires that ALL axis registers be read, even if only\n    // one is used; this was not done ineffiently in the code by accident\n    I2Cdev::readBytes(devAddr, HMC5843_RA_DATAX_H, 6, buffer);\n    if (mode == HMC5843_MODE_SINGLE) I2Cdev::writeByte(devAddr, HMC5843_RA_MODE, HMC5843_MODE_SINGLE << (HMC5843_MODEREG_BIT - HMC5843_MODEREG_LENGTH + 1));\n    return (((int16_t)buffer[4]) << 8) | buffer[5];\n}\n\n// STATUS register\n\n/** Get regulator enabled status.\n * This bit is set when the internal voltage regulator is enabled. This bit is\n * cleared when the internal regulator is disabled.\n * @return Regulator enabled status\n * @see HMC5843_RA_STATUS\n * @see HMC5843_STATUS_REN_BIT\n */\nbool HMC5843::getRegulatorEnabledStatus() {\n    I2Cdev::readBit(devAddr, HMC5843_RA_STATUS, HMC5843_STATUS_REN_BIT, buffer);\n    return buffer[0];\n}\n/** Get data output register lock status.\n * This bit is set when this some but not all for of the six data output\n * registers have been read. When this bit is set, the six data output registers\n * are locked and any new data will not be placed in these register until one of\n * three conditions are met: one, all six bytes have been read or the mode\n * changed, two, the mode is changed, or three, the measurement configuration is\n * changed.\n * @return Data output register lock status\n * @see HMC5843_RA_STATUS\n * @see HMC5843_STATUS_LOCK_BIT\n */\nbool HMC5843::getLockStatus() {\n    I2Cdev::readBit(devAddr, HMC5843_RA_STATUS, HMC5843_STATUS_LOCK_BIT, buffer);\n    return buffer[0];\n}\n/** Get data ready status.\n * This bit is set when data is written to all six data registers, and cleared\n * when the device initiates a write to the data output registers and after one\n * or more of the data output registers are written to. When RDY bit is clear it\n * shall remain cleared for 250 us. DRDY pin can be used as an alternative to\n * the status register for monitoring the device for measurement data.\n * @return Data ready status\n * @see HMC5843_RA_STATUS\n * @see HMC5843_STATUS_READY_BIT\n */\nbool HMC5843::getReadyStatus() {\n    I2Cdev::readBit(devAddr, HMC5843_RA_STATUS, HMC5843_STATUS_READY_BIT, buffer);\n    return buffer[0];\n}\n\n// ID_* registers\n\n/** Get identification byte A\n * @return ID_A byte (should be 01001000, ASCII value \'H\')\n */\nuint8_t HMC5843::getIDA() {\n    I2Cdev::readByte(devAddr, HMC5843_RA_ID_A, buffer);\n    return buffer[0];\n}\n/** Get identification byte B\n * @return ID_A byte (should be 00110100, ASCII value \'4\')\n */\nuint8_t HMC5843::getIDB() {\n    I2Cdev::readByte(devAddr, HMC5843_RA_ID_B, buffer);\n    return buffer[0];\n}\n/** Get identification byte C\n * @return ID_A byte (should be 00110011, ASCII value \'3\')\n */\nuint8_t HMC5843::getIDC() {\n    I2Cdev::readByte(devAddr, HMC5843_RA_ID_C, buffer);\n    return buffer[0];\n}\n'