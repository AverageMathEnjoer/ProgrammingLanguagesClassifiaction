b'{-# LANGUAGE FlexibleContexts #-}\n{-# LANGUAGE LambdaCase #-}\n{-# LANGUAGE OverloadedStrings #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n{-# OPTIONS_GHC -fno-warn-incomplete-uni-patterns #-}\n\nmodule Hoodle.Coroutine.ContextMenu where\n\nimport Control.Concurrent.STM (readTVarIO)\nimport Control.Lens (set, view, (.~), (^.))\nimport Control.Monad (guard, unless, void, when)\nimport Control.Monad.IO.Class (liftIO)\nimport Control.Monad.State (get, gets, put, runStateT)\nimport Control.Monad.Trans.Maybe (MaybeT (..))\nimport qualified Data.ByteString.Char8 as B\nimport qualified Data.ByteString.Lazy.Char8 as L\nimport Data.Foldable (forM_, mapM_)\nimport Data.Hoodle.BBox\n  ( BBox (..),\n    BBoxed (..),\n    ULMaybe (Middle),\n    UnionBBox (..),\n    getBBox,\n  )\nimport Data.Hoodle.Generic\n  ( GLayer (..),\n    gbuffer,\n    ghoodleID,\n    glayers,\n  )\nimport Data.Hoodle.Select (gselSelected)\nimport Data.Hoodle.Simple\n  ( Anchor (..),\n    Dimension (..),\n    Item (..),\n    Link (..),\n    SVG (..),\n    defaultHoodle,\n  )\nimport qualified Data.Hoodle.Simple as S (Image (..))\nimport qualified Data.IntMap as IM\nimport Data.List (partition)\nimport qualified Data.Text as T (splitAt, unpack)\nimport qualified Data.Text.Encoding as TE\nimport Data.UUID.V4 (nextRandom)\nimport Graphics.Hoodle.Render (renderRItem)\nimport Graphics.Hoodle.Render.Item\n  ( cnstrctRItem,\n    getByteStringIfEmbeddedPNG,\n  )\nimport Graphics.Hoodle.Render.Type\n  ( RItem (..),\n    isAnchorInRItem,\n    isLinkInRItem,\n    rItem2Item,\n    selectedLayer,\n  )\nimport Graphics.Hoodle.Render.Type.HitTest\n  ( AlterList ((:-)),\n    Hitted (..),\n    TEitherAlterHitted (..),\n  )\nimport qualified Graphics.Rendering.Cairo as Cairo\nimport qualified Graphics.UI.Gtk as Gtk\nimport Hoodle.Accessor\n  ( getCurrentPageCurr,\n    pureUpdateUhdl,\n    renderCache,\n  )\nimport Hoodle.Coroutine.Commit (commit)\nimport Hoodle.Coroutine.Dialog (fileChooser, okMessageBox)\nimport Hoodle.Coroutine.Draw\n  ( callRenderer,\n    doIOaction_,\n    invalidateAll,\n    waitSomeEvent,\n  )\nimport Hoodle.Coroutine.File (fileExtensionInvalid)\nimport Hoodle.Coroutine.Scroll\n  ( adjustScrollbarWithGeometryCvsId,\n  )\nimport Hoodle.Coroutine.Select.Clipboard\n  ( copySelection,\n    cutSelection,\n    deleteSelection,\n    updateTempHoodleSelectM,\n  )\nimport Hoodle.Coroutine.Select.ManipulateImage\n  ( cropImage,\n    rotateImage,\n  )\nimport Hoodle.Coroutine.TextInput\n  ( convertLinkFromSimpleToDocID,\n    insertItemAt,\n    laTeXInput,\n    laTeXInputKeyword,\n    laTeXInputNetwork,\n    linkInsert,\n    textInput,\n  )\nimport Hoodle.ModelAction.ContextMenu\n  ( makeSVGFromSelection,\n    menuCreateALink,\n    menuOpenALink,\n  )\nimport Hoodle.ModelAction.Page (setPage, updatePageAll)\nimport Hoodle.ModelAction.Select\n  ( getSelectedItms,\n    getSelectedItmsFromUnitHoodle,\n  )\nimport Hoodle.ModelAction.Select.Transform\n  ( rItmsInActiveLyr,\n  )\nimport Hoodle.Script.Hook\n  ( customAutosavePage,\n    customContextMenuHook,\n    customContextMenuTitle,\n    fileNameSuggestionHook,\n    lookupPathFromId,\n  )\nimport Hoodle.Type.Canvas (currentPageNum, unboxLens)\nimport Hoodle.Type.Coroutine (MainCoroutine, doIOaction)\nimport Hoodle.Type.Enum (RotateDir (CCW, CW))\nimport Hoodle.Type.Event\n  ( AllEvent (UsrEv),\n    ContextMenuEvent (..),\n    ImgType (TypPDF, TypSVG),\n    RenderEvent (GotRItem),\n    UserEvent\n      ( ContextMenuCreated,\n        GotContextMenuSignal,\n        RenderEv\n      ),\n  )\nimport Hoodle.Type.HoodleState\n  ( FileStore (LocalDir, TempDir),\n    HoodleModeState (SelectState),\n    currentCanvas,\n    currentCanvasInfo,\n    currentUnit,\n    cvsInfoMap,\n    doesUsePopUpMenu,\n    getCurrentCanvasId,\n    getHoodle,\n    hoodleFileControl,\n    hoodleFileName,\n    hoodleModeState,\n    hoodleModeStateEither,\n    hookSet,\n    renderCacheVar,\n    settings,\n    unitHoodles,\n  )\nimport Hoodle.Type.PageArrangement\n  ( PageCoordinate (..),\n    PageNum (..),\n  )\nimport Hoodle.Util (either_, msgShout, urlParse)\nimport System.Directory\n  ( createDirectory,\n    doesDirectoryExist,\n    doesFileExist,\n    getHomeDirectory,\n  )\nimport System.FilePath (takeExtension, (<.>), (</>))\nimport System.Process (createProcess, proc)\nimport Text.Hoodle.Builder (builder)\nimport qualified Text.Hoodlet.Builder as Hoodlet (builder)\n--\nimport Prelude hiding (mapM_)\n\nprocessContextMenu :: ContextMenuEvent -> MainCoroutine ()\nprocessContextMenu (CMenuSaveSelectionAs ityp) = do\n  mhititms <-\n    gets (getSelectedItmsFromUnitHoodle . view (unitHoodles . currentUnit))\n  forM_ mhititms $ \\hititms ->\n    let ulbbox = (unUnion . mconcat . fmap (Union . Middle . getBBox)) hititms\n     in case ulbbox of\n          Middle bbox ->\n            case ityp of\n              TypSVG -> exportCurrentSelectionAsSVG hititms bbox\n              TypPDF -> exportCurrentSelectionAsPDF hititms bbox\n          _ -> return ()\nprocessContextMenu CMenuCut = cutSelection\nprocessContextMenu CMenuCopy = copySelection\nprocessContextMenu CMenuDelete = deleteSelection\nprocessContextMenu (CMenuCanvasView cid pnum _x _y) = do\n  uhdl <- gets (view (unitHoodles . currentUnit))\n  let cmap = uhdl ^. cvsInfoMap\n      mcinfobox = IM.lookup cid cmap\n  case mcinfobox of\n    Nothing -> msgShout "error in processContextMenu"\n    Just _cinfobox -> do\n      cinfobox\' <- liftIO (setPage uhdl pnum cid)\n      pureUpdateUhdl (cvsInfoMap .~ IM.adjust (const cinfobox\') cid cmap)\n      adjustScrollbarWithGeometryCvsId cid\n      invalidateAll\nprocessContextMenu (CMenuRotate dir imgbbx) = rotateImage dir imgbbx\nprocessContextMenu (CMenuExport imgbbx) = exportImage (bbxed_content imgbbx)\nprocessContextMenu CMenuAutosavePage = do\n  xst <- get\n  pg <- getCurrentPageCurr\n  mapM_ liftIO $ do\n    hset <- xst ^. hookSet\n    customAutosavePage hset <*> pure pg\nprocessContextMenu (CMenuLinkConvert nlnk) =\n  either_ action . hoodleModeStateEither . (^. hoodleModeState) . view (unitHoodles . currentUnit) =<< get\n  where\n    action thdl = do\n      xst <- get\n      let uhdl = view (unitHoodles . currentUnit) xst\n          cid = getCurrentCanvasId uhdl\n      case thdl ^. gselSelected of\n        Nothing -> return ()\n        Just (n, tpg) -> do\n          let activelayer = rItmsInActiveLyr tpg\n              buf = tpg ^. (glayers . selectedLayer . gbuffer)\n          ntpg <- case activelayer of\n            Left _ -> return tpg\n            Right (a :- _b :- as) -> do\n              let nitm = ItemLink nlnk\n              callRenderer $\n                GotRItem <$> cnstrctRItem nitm\n              RenderEv (GotRItem nritm) <-\n                waitSomeEvent (\\case RenderEv (GotRItem _) -> True; _ -> False)\n              let alist\' = a :- Hitted [nritm] :- as\n                  layer\' = GLayer buf . TEitherAlterHitted . Right $ alist\'\n              return (set (glayers . selectedLayer) layer\' tpg)\n            Right _ -> error "processContextMenu: activelayer"\n          nthdl <- updateTempHoodleSelectM cid thdl ntpg n\n          uhdl\' <- liftIO $ updatePageAll (SelectState nthdl) uhdl\n          commit $ (unitHoodles . currentUnit .~ uhdl\') xst\n          invalidateAll\nprocessContextMenu CMenuCreateALink =\n  fileChooser Gtk.FileChooserActionOpen Nothing >>= mapM_ linkSelectionWithFile\nprocessContextMenu CMenuAssocWithNewFile = do\n  xst <- get\n  let msuggestedact = xst ^. hookSet >>= fileNameSuggestionHook\n  (msuggested :: Maybe String) <- maybe (return Nothing) (fmap Just . liftIO) msuggestedact\n  fileChooser Gtk.FileChooserActionSave msuggested\n    >>= mapM_\n      ( \\fp -> do\n          b <- liftIO (doesFileExist fp)\n          if b\n            then okMessageBox "The file already exist!"\n            else do\n              doIOaction_ $ do\n                nhdl <- liftIO defaultHoodle\n                (L.writeFile fp . builder) nhdl\n                createProcess (proc "hoodle" [fp])\n              linkSelectionWithFile fp\n              return ()\n      )\nprocessContextMenu (CMenuMakeLinkToAnchor anc) = do\n  xst <- get\n  uuidbstr <- liftIO $ B.pack . show <$> nextRandom\n  let uhdl = view (unitHoodles . currentUnit) xst\n      docidbstr = (view ghoodleID . getHoodle) uhdl\n      mloc = case view (hoodleFileControl . hoodleFileName) uhdl of\n        LocalDir Nothing -> Nothing\n        LocalDir (Just fp) -> Just fp\n        TempDir _ -> Nothing\n      loc = maybe "" B.pack mloc\n      lnk = LinkAnchor uuidbstr docidbstr loc (anchor_id anc) "" (0, 0) (Dim 50 50)\n  callRenderer $\n    GotRItem <$> cnstrctRItem (ItemLink lnk)\n  RenderEv (GotRItem newitem) <-\n    waitSomeEvent (\\case RenderEv (GotRItem _) -> True; _ -> False)\n  insertItemAt Nothing newitem\nprocessContextMenu (CMenuPangoConvert (x0, y0) txt) = textInput (Just (x0, y0)) txt\nprocessContextMenu (CMenuLaTeXConvert (x0, y0) txt) = laTeXInput (Just (x0, y0)) txt\nprocessContextMenu (CMenuLaTeXConvertNetwork (x0, y0) txt) = laTeXInputNetwork (Just (x0, y0)) txt\nprocessContextMenu (CMenuLaTeXUpdate (x0, y0) dim key) =\n  void $ runMaybeT (laTeXInputKeyword (x0, y0) (Just dim) key)\nprocessContextMenu (CMenuCropImage imgbbox) = cropImage imgbbox\nprocessContextMenu (CMenuExportHoodlet itm) = do\n  -- res <- handwritingRecognitionDialog\n  let res = Nothing\n  forM_ res $ \\(b, txt) -> do\n    unless b $\n      liftIO $ do\n        let str = T.unpack txt\n        homedir <- getHomeDirectory\n        let hoodled = homedir </> ".hoodle.d"\n            hoodletdir = hoodled </> "hoodlet"\n        b\' <- doesDirectoryExist hoodletdir\n        unless b\' $\n          createDirectory hoodletdir\n        let fp = hoodletdir </> str <.> "hdlt"\n        L.writeFile fp (Hoodlet.builder itm)\nprocessContextMenu (CMenuConvertSelection itm) = do\n  uhdl <- gets (view (unitHoodles . currentUnit))\n  let pgnum = view (currentCanvasInfo . unboxLens currentPageNum) uhdl\n  deleteSelection\n  callRenderer $\n    GotRItem <$> cnstrctRItem itm\n  RenderEv (GotRItem newitem) <- waitSomeEvent (\\case RenderEv (GotRItem _) -> True; _ -> False)\n  let BBox (x0, y0) _ = getBBox newitem\n  insertItemAt (Just (PageNum pgnum, PageCoord (x0, y0))) newitem\nprocessContextMenu CMenuCustom = do\n  either_ action . hoodleModeStateEither . view hoodleModeState . view (unitHoodles . currentUnit) =<< get\n  where\n    action thdl = do\n      xst <- get\n      forM_\n        (view gselSelected thdl)\n        ( \\(_, tpg) -> do\n            let hititms = (map rItem2Item . getSelectedItms) tpg\n            mapM_ liftIO $ do\n              hset <- view hookSet xst\n              customContextMenuHook hset <*> pure hititms\n        )\n\n--  |\nlinkSelectionWithFile :: FilePath -> MainCoroutine ()\nlinkSelectionWithFile fname = do\n  uhdl <- gets (view (unitHoodles . currentUnit))\n  let cid = getCurrentCanvasId uhdl\n  forM_ (getSelectedItmsFromUnitHoodle uhdl) $ \\hititms ->\n    let ulbbox = (unUnion . mconcat . fmap (Union . Middle . getBBox)) hititms\n     in case ulbbox of\n          Middle bbox -> do\n            cache <- renderCache\n            svg <- liftIO $ makeSVGFromSelection cache cid hititms bbox\n            uuid <- liftIO nextRandom\n            let uuidbstr = B.pack (show uuid)\n            deleteSelection\n            linkInsert "simple" (uuidbstr, fname) fname (svg_render svg, bbox)\n          _ -> return ()\n\n-- |\nexportCurrentSelectionAsSVG :: [RItem] -> BBox -> MainCoroutine ()\nexportCurrentSelectionAsSVG hititms bbox@(BBox (ulx, uly) (lrx, lry)) =\n  fileChooser Gtk.FileChooserActionSave Nothing >>= mapM_ action\n  where\n    action filename = do\n      (cache, cid) <-\n        (,)\n          <$> renderCache\n          <*> gets (getCurrentCanvasId . view (unitHoodles . currentUnit))\n      -- this is rather temporary not to make mistake\n      if takeExtension filename /= ".svg"\n        then\n          fileExtensionInvalid (".svg", "export")\n            >> exportCurrentSelectionAsSVG hititms bbox\n        else do\n          liftIO $\n            Cairo.withSVGSurface filename (lrx - ulx) (lry - uly) $ \\s ->\n              Cairo.renderWith s $ do\n                Cairo.translate (-ulx) (-uly)\n                mapM_ (renderRItem cache cid) hititms\n\nexportCurrentSelectionAsPDF :: [RItem] -> BBox -> MainCoroutine ()\nexportCurrentSelectionAsPDF hititms bbox@(BBox (ulx, uly) (lrx, lry)) =\n  fileChooser Gtk.FileChooserActionSave Nothing >>= mapM_ action\n  where\n    action filename = do\n      (cache, cid) <-\n        (,)\n          <$> renderCache\n          <*> gets (getCurrentCanvasId . view (unitHoodles . currentUnit))\n      -- this is rather temporary not to make mistake\n      if takeExtension filename /= ".pdf"\n        then\n          fileExtensionInvalid (".svg", "export")\n            >> exportCurrentSelectionAsPDF hititms bbox\n        else do\n          liftIO $\n            Cairo.withPDFSurface filename (lrx - ulx) (lry - uly) $ \\s ->\n              Cairo.renderWith s $ do\n                Cairo.translate (-ulx) (-uly)\n                mapM_ (renderRItem cache cid) hititms\n\n-- |\nexportImage :: S.Image -> MainCoroutine ()\nexportImage img =\n  void $\n    runMaybeT $ do\n      pngbstr <- (MaybeT . return . getByteStringIfEmbeddedPNG . S.img_src) img\n      fp <- MaybeT (fileChooser Gtk.FileChooserActionSave Nothing)\n      liftIO $ B.writeFile fp pngbstr\n\nshowContextMenu :: (PageNum, (Double, Double)) -> MainCoroutine ()\nshowContextMenu (pnum, (x, y)) = do\n  xstate <- get\n  when (view (settings . doesUsePopUpMenu) xstate) $\n    do\n      let uhdl = view (unitHoodles . currentUnit) xstate\n          cids = IM.keys . view cvsInfoMap $ uhdl\n          cid = fst . view currentCanvas $ uhdl\n          mselitms = do\n            lst <- getSelectedItmsFromUnitHoodle uhdl\n            if null lst then Nothing else Just lst\n      doIOaction (action xstate mselitms cid cids)\n      >> waitSomeEvent (\\case ContextMenuCreated -> True; _ -> False)\n      >> return ()\n  where\n    action xstate msitms cid cids evhandler = do\n      menu <- Gtk.menuNew\n      Gtk.menuSetTitle menu ("MyMenu" :: String)\n      case msitms of\n        Nothing -> return ()\n        Just sitms -> do\n          menuitem1 <- Gtk.menuItemNewWithLabel ("Make SVG" :: String)\n          menuitem2 <- Gtk.menuItemNewWithLabel ("Make PDF" :: String)\n          menuitem3 <- Gtk.menuItemNewWithLabel ("Cut" :: String)\n          menuitem4 <- Gtk.menuItemNewWithLabel ("Copy" :: String)\n          menuitem5 <- Gtk.menuItemNewWithLabel ("Delete" :: String)\n          menuitem6 <- Gtk.menuItemNewWithLabel ("New File Linked Here" :: String)\n          _ <-\n            menuitem1 `Gtk.on` Gtk.menuItemActivate $\n              evhandler (UsrEv (GotContextMenuSignal (CMenuSaveSelectionAs TypSVG)))\n          _ <-\n            menuitem2 `Gtk.on` Gtk.menuItemActivate $\n              evhandler (UsrEv (GotContextMenuSignal (CMenuSaveSelectionAs TypPDF)))\n          _ <-\n            menuitem3 `Gtk.on` Gtk.menuItemActivate $\n              evhandler (UsrEv (GotContextMenuSignal CMenuCut))\n          _ <-\n            menuitem4 `Gtk.on` Gtk.menuItemActivate $\n              evhandler (UsrEv (GotContextMenuSignal CMenuCopy))\n          _ <-\n            menuitem5 `Gtk.on` Gtk.menuItemActivate $\n              evhandler (UsrEv (GotContextMenuSignal CMenuDelete))\n          _ <-\n            menuitem6 `Gtk.on` Gtk.menuItemActivate $\n              evhandler (UsrEv (GotContextMenuSignal CMenuAssocWithNewFile))\n          Gtk.menuAttach menu menuitem1 0 1 1 2\n          Gtk.menuAttach menu menuitem2 0 1 2 3\n          Gtk.menuAttach menu menuitem3 1 2 0 1\n          Gtk.menuAttach menu menuitem4 1 2 1 2\n          Gtk.menuAttach menu menuitem5 1 2 2 3\n          Gtk.menuAttach menu menuitem6 1 2 3 4\n          mapM_ (\\mi -> Gtk.menuAttach menu mi 1 2 5 6) =<< menuCreateALink evhandler sitms\n          case sitms of\n            [sitm] -> do\n              menuhdlt <- Gtk.menuItemNewWithLabel ("Make Hoodlet" :: String)\n              _ <-\n                menuhdlt `Gtk.on` Gtk.menuItemActivate $\n                  ( evhandler . UsrEv . GotContextMenuSignal\n                      . CMenuExportHoodlet\n                      . rItem2Item\n                  )\n                    sitm\n              Gtk.menuAttach menu menuhdlt 0 1 8 9\n              case sitm of\n                RItemLink lnkbbx _msfc -> do\n                  let lnk = bbxed_content lnkbbx\n                  forM_\n                    ((urlParse . B.unpack . link_location) lnk)\n                    ( \\urlpath -> do\n                        milnk <- menuOpenALink evhandler urlpath\n                        Gtk.menuAttach menu milnk 0 1 3 4\n                    )\n                  case lnk of\n                    Link _i _typ _lstr _txt _cmd _rdr _pos _dim ->\n                      convertLinkFromSimpleToDocID lnk\n                        >>= mapM_\n                          ( \\link -> do\n                              let LinkDocID _ uuid _ _ _ _ _ _ = link\n                              menuitemcvt <- Gtk.menuItemNewWithLabel ("Convert Link With ID" ++ show uuid :: String)\n                              _ <-\n                                menuitemcvt `Gtk.on` Gtk.menuItemActivate $\n                                  ( evhandler\n                                      . UsrEv\n                                      . GotContextMenuSignal\n                                      . CMenuLinkConvert\n                                  )\n                                    link\n                              Gtk.menuAttach menu menuitemcvt 0 1 4 5\n                          )\n                    LinkDocID i lid file txt cmd rdr pos dim ->\n                      void $\n                        runMaybeT $ do\n                          hset <- (MaybeT . return . view hookSet) xstate\n                          f <- (MaybeT . return . lookupPathFromId) hset\n                          file\' <- MaybeT (f (B.unpack lid))\n                          guard (B.unpack file /= file\')\n                          let link =\n                                LinkDocID\n                                  i\n                                  lid\n                                  (B.pack file\')\n                                  txt\n                                  cmd\n                                  rdr\n                                  pos\n                                  dim\n                          menuitemcvt <-\n                            liftIO $\n                              Gtk.menuItemNewWithLabel\n                                ("Correct Path to " ++ show file\' :: String)\n                          _ <-\n                            liftIO\n                              ( menuitemcvt `Gtk.on` Gtk.menuItemActivate $\n                                  ( evhandler\n                                      . UsrEv\n                                      . GotContextMenuSignal\n                                      . CMenuLinkConvert\n                                  )\n                                    link\n                              )\n                          liftIO $ Gtk.menuAttach menu menuitemcvt 0 1 4 5\n                    LinkAnchor i lid file aid bstr pos dim ->\n                      void $\n                        runMaybeT $ do\n                          hset <- (MaybeT . return . view hookSet) xstate\n                          f <- (MaybeT . return . lookupPathFromId) hset\n                          file\' <- MaybeT (f (B.unpack lid))\n                          guard (B.unpack file /= file\')\n                          let link = LinkAnchor i lid (B.pack file\') aid bstr pos dim\n                          menuitemcvt <-\n                            liftIO $\n                              Gtk.menuItemNewWithLabel\n                                ("Correct Path to " ++ show file\' :: String)\n                          void $\n                            liftIO\n                              ( menuitemcvt `Gtk.on` Gtk.menuItemActivate $\n                                  ( evhandler\n                                      . UsrEv\n                                      . GotContextMenuSignal\n                                      . CMenuLinkConvert\n                                  )\n                                    link\n                              )\n                          liftIO $ Gtk.menuAttach menu menuitemcvt 0 1 4 5\n                RItemSVG svgbbx _msfc -> do\n                  let svg = bbxed_content svgbbx\n                      BBox (x0, y0) (x1, y1) = getBBox svgbbx\n                  forM_ ((,) <$> svg_text svg <*> svg_command svg) $ \\(btxt, cmd) -> do\n                    let txt = TE.decodeUtf8 btxt\n                    case cmd of\n                      "pango" -> do\n                        menuitemedt <- Gtk.menuItemNewWithLabel ("Edit Text" :: String)\n                        _ <- menuitemedt `Gtk.on` Gtk.menuItemActivate $ do\n                          evhandler (UsrEv (GotContextMenuSignal (CMenuPangoConvert (x0, y0) txt)))\n                        Gtk.menuAttach menu menuitemedt 0 1 4 5\n                        return ()\n                      "latex" -> do\n                        menuitemedt <- Gtk.menuItemNewWithLabel ("Edit LaTeX" :: String)\n                        _ <- menuitemedt `Gtk.on` Gtk.menuItemActivate $ do\n                          evhandler (UsrEv (GotContextMenuSignal (CMenuLaTeXConvert (x0, y0) txt)))\n                        Gtk.menuAttach menu menuitemedt 0 1 4 5\n                        --\n                        menuitemnet <- Gtk.menuItemNewWithLabel ("Edit LaTeX Network" :: String)\n                        _ <- menuitemnet `Gtk.on` Gtk.menuItemActivate $ do\n                          evhandler (UsrEv (GotContextMenuSignal (CMenuLaTeXConvertNetwork (x0, y0) txt)))\n                        Gtk.menuAttach menu menuitemnet 0 1 5 6\n                        --\n                        let (txth, txtt) = T.splitAt 19 txt\n                        when (txth == "embedlatex:keyword:") $ do\n                          menuitemup <- Gtk.menuItemNewWithLabel ("Update LaTeX" :: String)\n                          _ <- menuitemup `Gtk.on` Gtk.menuItemActivate $ do\n                            evhandler (UsrEv (GotContextMenuSignal (CMenuLaTeXUpdate (x0, y0) (Dim (x1 - x0) (y1 - y0)) txtt)))\n                          Gtk.menuAttach menu menuitemup 0 1 6 7\n                          return ()\n                      _ -> return ()\n                RItemImage imgbbx _msfc -> do\n                  menuitemcrop <- Gtk.menuItemNewWithLabel ("Crop Image" :: String)\n                  _ <- menuitemcrop `Gtk.on` Gtk.menuItemActivate $ do\n                    (evhandler . UsrEv . GotContextMenuSignal . CMenuCropImage) imgbbx\n                  menuitemrotcw <- Gtk.menuItemNewWithLabel ("Rotate Image CW" :: String)\n                  _ <- menuitemrotcw `Gtk.on` Gtk.menuItemActivate $ do\n                    (evhandler . UsrEv . GotContextMenuSignal) (CMenuRotate CW imgbbx)\n                  menuitemrotccw <- Gtk.menuItemNewWithLabel ("Rotate Image CCW" :: String)\n                  _ <- menuitemrotccw `Gtk.on` Gtk.menuItemActivate $ do\n                    (evhandler . UsrEv . GotContextMenuSignal) (CMenuRotate CCW imgbbx)\n                  menuitemexport <- Gtk.menuItemNewWithLabel ("Export Image" :: String)\n                  _ <- menuitemexport `Gtk.on` Gtk.menuItemActivate $ do\n                    (evhandler . UsrEv . GotContextMenuSignal) (CMenuExport imgbbx)\n                  --\n                  Gtk.menuAttach menu menuitemcrop 0 1 4 5\n                  Gtk.menuAttach menu menuitemrotcw 0 1 5 6\n                  Gtk.menuAttach menu menuitemrotccw 0 1 6 7\n                  Gtk.menuAttach menu menuitemexport 0 1 7 8\n                  --\n                  return ()\n                RItemAnchor ancbbx _ -> do\n                  menuitemmklnk <- Gtk.menuItemNewWithLabel ("Link to this anchor" :: String)\n                  _ <-\n                    menuitemmklnk `Gtk.on` Gtk.menuItemActivate $\n                      ( evhandler\n                          . UsrEv\n                          . GotContextMenuSignal\n                          . CMenuMakeLinkToAnchor\n                          . bbxed_content\n                      )\n                        ancbbx\n                  Gtk.menuAttach menu menuitemmklnk 0 1 4 5\n                _ -> return ()\n            _ -> do\n              let (links, others) = partition ((||) <$> isLinkInRItem <*> isAnchorInRItem) sitms\n              case links of\n                [l] -> do\n                  menuitemreplace <- Gtk.menuItemNewWithLabel ("replace link/anchor render" :: String)\n                  _ <- menuitemreplace `Gtk.on` Gtk.menuItemActivate $ do\n                    cache <- readTVarIO (xstate ^. renderCacheVar)\n                    let ulbbox = (unUnion . mconcat . fmap (Union . Middle . getBBox)) others\n                    case ulbbox of\n                      Middle bbox -> do\n                        let BBox (x0, y0) (x1, y1) = bbox\n                            dim = Dim (x1 - x0) (y1 - y0)\n                        svg <- svg_render <$> makeSVGFromSelection cache cid others bbox\n                        let mitm = case l of\n                              RItemLink lnkbbx _ -> (Just . ItemLink) ((bbxed_content lnkbbx) {link_render = svg, link_dim = dim})\n                              RItemAnchor ancbbx _ -> (Just . ItemAnchor) ((bbxed_content ancbbx) {anchor_render = svg, anchor_dim = dim})\n                              _ -> Nothing\n                        maybe (return ()) (evhandler . UsrEv . GotContextMenuSignal . CMenuConvertSelection) mitm\n                      _ -> return ()\n                  Gtk.menuAttach menu menuitemreplace 0 1 8 9\n                _ -> return ()\n      case customContextMenuTitle =<< view hookSet xstate of\n        Nothing -> return ()\n        Just ttl -> do\n          custommenu <- Gtk.menuItemNewWithLabel ttl\n          _ <-\n            custommenu `Gtk.on` Gtk.menuItemActivate $\n              evhandler (UsrEv (GotContextMenuSignal CMenuCustom))\n          Gtk.menuAttach menu custommenu 0 1 0 1\n      menuitem8 <- Gtk.menuItemNewWithLabel ("Autosave This Page Image" :: String)\n      _ <-\n        menuitem8 `Gtk.on` Gtk.menuItemActivate $\n          evhandler (UsrEv (GotContextMenuSignal CMenuAutosavePage))\n      Gtk.menuAttach menu menuitem8 1 2 4 5\n      _ <- runStateT (mapM_ (makeMenu evhandler menu cid) cids) 0\n      Gtk.widgetShowAll menu\n      Gtk.menuPopup menu Nothing\n      return (UsrEv ContextMenuCreated)\n    makeMenu evhdlr mn currcid cid = when (currcid /= cid) $ do\n      n <- get\n      mi <- liftIO $ Gtk.menuItemNewWithLabel ("Show here in cvs" ++ show cid)\n      _ <-\n        liftIO $\n          Gtk.on mi Gtk.menuItemActivate $\n            evhdlr (UsrEv (GotContextMenuSignal (CMenuCanvasView cid pnum x y)))\n      liftIO $ Gtk.menuAttach mn mi 2 3 n (n + 1)\n      put (n + 1)\n'