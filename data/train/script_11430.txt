b'-- A facade for working with secrets and their representations, without delving\n-- into cryptography libraries.\nmodule Cachix.Client.Secrets\n  ( -- * NAR signing\n    SigningKey (..),\n    parseSigningKeyLenient,\n    exportSigningKey,\n  )\nwhere\n\n-- TODO: * Auth token\nimport Crypto.Sign.Ed25519\nimport qualified Data.ByteString.Base64 as B64\nimport qualified Data.ByteString.Char8 as BC\nimport Data.Char (isSpace)\nimport Protolude hiding (toS)\nimport Protolude.Conv\n\n-- | A secret key for signing nars.\nnewtype SigningKey = SigningKey {signingSecretKey :: SecretKey}\n\nparseSigningKeyLenientBS ::\n  -- | ASCII (Base64)\n  ByteString ->\n  -- | Error message or signing key\n  Either Text SigningKey\nparseSigningKeyLenientBS raw =\n  let bcDropWhileEnd f = BC.reverse . BC.dropWhile f . BC.reverse\n      bcDropAround f = bcDropWhileEnd f . BC.dropWhile f\n      stripped = bcDropAround isSpace raw\n      nonNull = if BC.null stripped then Left "A signing key must not be empty" else pure stripped\n   in SigningKey . SecretKey . B64.decodeLenient <$> nonNull\n\nparseSigningKeyLenient ::\n  -- | Base64\n  Text ->\n  -- | Error message or signing key\n  Either Text SigningKey\nparseSigningKeyLenient = parseSigningKeyLenientBS . toSL\n\nexportSigningKeyBS ::\n  SigningKey ->\n  -- | ASCII (Base64)\n  ByteString\nexportSigningKeyBS (SigningKey (SecretKey bs)) = B64.encode bs\n\nexportSigningKey :: SigningKey -> Text\nexportSigningKey = toS . exportSigningKeyBS\n'