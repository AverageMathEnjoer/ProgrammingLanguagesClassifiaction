b'#\' Data frame Summary\n#\'\n#\' Summary of a data frame consisting of: variable names and types, labels if\n#\' any, factor levels, frequencies and/or numerical summary statistics, \n#\' barplots/histograms, and valid/missing observation counts and proportions.\n#\'\n#\' @param x A data frame.\n#\' @param round.digits Number of significant digits to display. Defaults to\n#\'   \\code{1}. Does not affect proportions, which always show \\code{1} digit. \n#\' @param varnumbers Logical. Show variable numbers in the first column.\n#\'   Defaults to \\code{TRUE}. Can be set globally with \\code{\\link{st_options}},\n#\'   option \\dQuote{dfSummary.varnumbers}.\n#\' @param labels.col Logical. If \\code{TRUE}, variable labels (as defined with\n#\'   \\pkg{rapportools}, \\pkg{Hmisc} or \\pkg{summarytools}\' \\code{label}\n#\'   functions, among others) will be displayed. \\code{TRUE} by default, but\n#\'   the \\emph{labels} column is only shown if a label exists for at least one\n#\'   column. Can be set globally with \\code{\\link{st_options}}, option\n#\'   \\dQuote{dfSummary.labels.col}.\n#\' @param valid.col Logical. Include column indicating count and proportion of\n#\'   valid (non-missing) values. \\code{TRUE} by default; can be set\n#\'   globally with \\code{\\link{st_options}}, option \\dQuote{dfSummary.valid.col}.\n#\' @param na.col Logical. Include column indicating count and proportion of\n#\'   missing (\\code{NA}) values. \\code{TRUE} by default; can be set globally\n#\'   with \\code{\\link{st_options}}, option \\dQuote{dfSummary.na.col}.\n#\' @param graph.col Logical. Display barplots/histograms column. \\code{TRUE}\n#\'   by default; can be set globally with \\code{\\link{st_options}}, \n#\'   option \\dQuote{dfSummary.graph.col}.\n#\' @param graph.magnif Numeric. Magnification factor for graphs column. Useful\n#\'   if the graphs show up too large (then use a value such as .75) or too small\n#\'   (use a value such as \\code{1.25}). Must be positive. Defaults to \\code{1}.\n#\'   Can be set globally with \\code{\\link{st_options}}, option\n#\'   \\dQuote{dfSummary.graph.magnif}.\n#\' @param style Character. Argument used by \\code{\\link[pander]{pander}}.\n#\'   Defaults to \\dQuote{multiline}. The only other valid option\n#\'   is \\dQuote{grid}. Style \\dQuote{rmarkdown} will fallback to\n#\'   \\dQuote{multiline}.\n#\' @param plain.ascii Logical. \\code{\\link[pander]{pander}} argument; when\n#\'   \\code{TRUE}, no markup characters will be used (useful when printing to\n#\'   console). Defaults to \\code{TRUE}. Set to \\code{FALSE} when in context of\n#\'   markdown rendering. To change the default value globally, see\n#\'   \\code{\\link{st_options}}.\n#\' @param justify String indicating alignment of columns; one of \\dQuote{l}\n#\'   (left) \\dQuote{c} (center), or \\dQuote{r} (right). Defaults to \\dQuote{l}.\n#\' @param col.widths Numeric or character. Vector of column widths. If numeric,\n#\'   values are assumed to be numbers of pixels. Otherwise, any CSS-supported\n#\'   units can be used. \\code{NA} by default, meaning widths are calculated\n#\'   automatically.\n#\' @param headings Logical. Set to \\code{FALSE} to omit headings. To change this\n#\'   default value globally, see \\code{\\link{st_options}}.\n#\' @param display.labels Logical. Should data frame label be displayed in the\n#\'   title section?  Default is \\code{TRUE}. To change this default value\n#\'   globally, see \\code{\\link{st_options}}.\n#\' @param max.distinct.values The maximum number of values to display\n#\'   frequencies for. If variable has more distinct values than this number, the\n#\'   remaining frequencies will be reported as a whole, along with the number of\n#\'   additional distinct values. Defaults to 10.\n#\' @param trim.strings Logical; for character variables, should leading and\n#\'   trailing white space be removed? Defaults to \\code{FALSE}. See\n#\'   \\emph{details} section.\n#\' @param max.string.width Limits the number of characters to display in the\n#\'   frequency tables. Defaults to \\code{25}.\n#\' @param split.cells A numeric argument passed to \\code{\\link[pander]{pander}}.\n#\'   It is the number of characters allowed on a line before splitting the cell.\n#\'   Defaults to \\code{40}.\n#\' @param split.tables \\pkg{pander} argument which determines the maximum width\n#\'   of a table. Keeping the default value (\\code{Inf}) is recommended.\n#\' @param tmp.img.dir Character. Directory used to store temporary images when\n#\'   rendering dfSummary() with `method = "pander"`, `plain.ascii = TRUE` and\n#\'   `style = "grid"`. See \\emph{Details}.\n#\' @param keep.grp.vars Logical. When using \\code{\\link[dplyr]{group_by}},\n#\'   keep rows corresponding to grouping variable(s) in output table.\n#\'   When \\code{FALSE} (default), variable numbers still reflect the\n#\'   the ordering in the full data frame (in other words, some numbers will\n#\'   be skipped in the variable number column).\n#\' @param silent Logical. Hide console messages. \\code{FALSE} by default. To\n#\'   change this value globally, see \\code{\\link{st_options}}.\n#\' @param \\dots Additional arguments passed to \\code{\\link[pander]{pander}}.\n#\'\n#\' @return A data frame with additional class \\code{summarytools} containing as\n#\'   many rows as there are columns in \\code{x}, with attributes to inform\n#\'   \\code{print} method. Columns in the output data frame are:\n#\'   \\describe{\n#\'     \\item{No}{Number indicating the order in which column appears in the data\n#\'      frame.}\n#\'     \\item{Variable}{Name of the variable, along with its class(es).}\n#\'     \\item{Label}{Label of the variable (if applicable).}\n#\'     \\item{Stats / Values}{For factors, a list of their values, limited by the\n#\'       \\code{max.distinct.values} parameter. For character variables, the most\n#\'        common values (in descending frequency order), also limited by\n#\'       \\code{max.distinct.values}. For numerical variables, common univariate\n#\'       statistics (mean, std. deviation, min, med, max, IQR and CV).}\n#\'     \\item{Freqs (\\% of Valid)}{For factors and character variables, the\n#\'       frequencies and proportions of the values listed in the previous\n#\'       column. For numerical vectors, number of distinct values, or frequency\n#\'       of distinct values if their number is not greater than\n#\'       \\code{max.distinct.values}.}\n#\'     \\item{Text Graph}{An ASCII histogram for numerical variables, and ASCII\n#\'       barplot for factors and character variables.} \n#\'     \\item{Graph}{An html encoded graph, either barplot or histogram.}\n#\'     \\item{Valid}{Number and\n#\'       proportion of valid values.}\n#\'     \\item{Missing}{Number and proportion of missing (NA and NAN) values.} \n#\'     }\n#\'\n#\' @details The default value \\code{plain.ascii = TRUE} is intended to\n#\'   facilitate interactive data exploration. When using the package for\n#\'   reporting with \\emph{rmarkdown}, make sure to set this option to\n#\'   \\code{FALSE}.\n#\'\n#\'   When \\code{trim.strings} is set to \\code{TRUE}, trimming is done\n#\'   \\strong{\\emph{before} calculating frequencies}, be aware that those will\n#\'   be impacted accordingly.\n#\'   \n#\'   Specifying \\code{tmp.img.dir} allows producing results consistent with\n#\'   pandoc styling while also showing \\emph{png} graphs. Due to the fact that\n#\'   in Pandoc, column widths are determined by the length of cell contents\n#\'   \\strong{even if said content is merely a link to an image}, using standard\n#\'   R temporary directory to store the images would cause columns to be\n#\'   exceedingly wide. \\strong{A shorter path is needed.} On Mac OS and Linux,\n#\'   using \\dQuote{/tmp} is a sensible choice, since this directory is cleaned\n#\'   up automatically on a regular basis. On Windows however, there is no such\n#\'   convenient directory, so the user has to choose a directory and cleanup the\n#\'   temporary images manually after the document has been rendered. Providing\n#\'   a relative path such as \\dQuote{img}, omitting \\dQuote{./}, is recommended.\n#\'   The maximum length for this parameter is set to 5 characters. It can be set\n#\'   globally with \\code{\\link{st_options}} (\\emph{e.g.:}\n#\'   \\code{st_options(tmp.img.dir = ".")}.\n#\'\n#\'   It is possible to \\strong{control which statistics are shown} in the \n#\'   \\emph{Stats / Values} column. For this, see the \\emph{Details} and\n#\'   \\emph{Examples} sections of \\code{\\link{st_options}}.\n#\'    \n#\' @note Several packages provide functions for defining \\emph{variable labels},\n#\'   \\pkg{summarytools} being one of them. Some packages (\\emph{Hmisc} in\n#\'   particular) employ special classes for labelled objects, but\n#\'   \\pkg{summarytools} doesn\'t use nor look for any such classes.\n#\'\n#\' @examples\n#\'\n#\' data("tobacco")\n#\' saved_x11_option <- st_options("use.x11")\n#\' st_options(use.x11 = FALSE)\n#\' dfSummary(tobacco)\n#\'\n#\' # Exclude some of the columns to reduce table width\n#\' dfSummary(tobacco, varnumbers = FALSE, valid.col = FALSE)\n#\'\n#\' # Limit number of categories to be displayed for categorical data\n#\' dfSummary(tobacco, max.distinct.values = 5, style = "grid")\n#\'\n#\' # Using stby()\n#\' stby(tobacco, tobacco$gender, dfSummary)\n#\'\n#\' st_options(use.x11 = saved_x11_option)\n#\'\n#\' \\dontrun{\n#\'\n#\' # Show in Viewer or browser - no capital V in view(); stview() is also\n#\' # available in case of conflicts with other packages)\n#\' view(dfSummary(iris))\n#\'\n#\' # Rmarkdown-ready\n#\' dfSummary(tobacco, style = "grid", plain.ascii = FALSE,\n#\'           varnumbers = FALSE, valid.col = FALSE, tmp.img.dir = "./img")\n#\'\n#\' # Using group_by()\n#\' tobacco %>% group_by(gender) %>% dfSummary()\n#\' }\n#\'\n#\' @seealso \\code{\\link{label}}, \\code{\\link{print.summarytools}}\n#\' \n#\' @keywords univar attribute classes category\n#\' @author Dominic Comtois, \\email{dominic.comtois@@gmail.com}\n#\' @importFrom dplyr n_distinct group_keys\n#\' @importFrom stats start end\n#\' @importFrom grDevices dev.list dev.off\n#\' @export\ndfSummary <- function(x,\n                      round.digits     = 1,\n                      varnumbers       = st_options("dfSummary.varnumbers"),\n                      labels.col       = st_options("dfSummary.labels.col"),\n                      valid.col        = st_options("dfSummary.valid.col"),\n                      na.col           = st_options("dfSummary.na.col"),\n                      graph.col        = st_options("dfSummary.graph.col"),\n                      graph.magnif     = st_options("dfSummary.graph.magnif"),\n                      style            = st_options("dfSummary.style"),\n                      plain.ascii      = st_options("plain.ascii"),\n                      justify          = "l",\n                      col.widths       = NA,\n                      headings         = st_options("headings"),\n                      display.labels   = st_options("display.labels"),\n                      max.distinct.values = 10,\n                      trim.strings     = FALSE,\n                      max.string.width = 25,\n                      split.cells      = 40,\n                      split.tables     = Inf,\n                      tmp.img.dir      = st_options(\'tmp.img.dir\'),\n                      keep.grp.vars    = FALSE,\n                      silent           = st_options(\'dfSummary.silent\'),\n                      ...) {\n\n  # Flag for elimination of unwanted graphic device in non-RStudio envirs\n  if (.Platform$GUI %in% c("Rgui", "RTerm", "X11") && is.null(dev.list())) {\n    clear_null_device <- TRUE\n  } else {\n    clear_null_device <- FALSE\n  }\n\n  # Make recursive calls when function is invoked on split-group data using\n  # dplyr::group_by()\n  if (inherits(x, "grouped_df")) {\n    \n    # Get metadata for heading section\n    parse_info <- try(\n      parse_args(sys.calls(), sys.frames(), match.call(),\n                 var_name  = FALSE, var_label = FALSE,\n                 caller = "dfSummary"),\n      silent = TRUE)\n\n    outlist <- list()\n    g_ks    <- map_groups(group_keys(x)) # map_groups is defined in helpers.R\n    g_inds  <- attr(x, "groups")$.rows   # Extract rows for current group\n    \n    # Extract grouping variable names\n    # g_vars  <- setdiff(names(attr(x, "group")), ".rows")\n    # g_vars_pos <- which(colnames(x) %in% g_vars)\n    \n    for (g in seq_along(g_ks)) {\n      outlist[[g]] <- dfSummary(x = as_tibble(x[g_inds[[g]],]),\n                                round.digits        = round.digits,\n                                varnumbers          = varnumbers,\n                                labels.col          = labels.col,\n                                valid.col           = valid.col,\n                                na.col              = na.col,\n                                graph.col           = graph.col,\n                                graph.magnif        = graph.magnif,\n                                style               = style,\n                                plain.ascii         = plain.ascii,\n                                justify             = justify,\n                                col.widths          = col.widths,\n                                headings            = headings,\n                                display.labels      = display.labels,\n                                max.distinct.values = max.distinct.values,\n                                trim.strings        = trim.strings,\n                                max.string.width    = max.string.width,\n                                split.cells         = split.cells,\n                                split.tables        = split.tables,\n                                tmp.img.dir         = tmp.img.dir,\n                                keep.grp.vars       = keep.grp.vars,\n                                silent              = silent,\n                                ...                 = ...)\n\n      if (!inherits(parse_info, "try-error")) {\n        if (!is.null(parse_info$df_name)) {\n          attr(outlist[[g]], "data_info")$Data.frame <- \n            enc2utf8(parse_info$df_name)\n        }\n        if (!is.null(parse_info$df_label)) {\n          attr(outlist[[g]], "data_info")$Data.frame.label <- \n            enc2utf8(parse_info$df_label)\n        }\n        if (!is.null(parse_info$var_name)) {\n          attr(outlist[[g]], "data_info")$Variable <-\n            enc2utf8(parse_info$var_name)\n        }\n        if (!is.null(parse_info$var_label)) {\n          attr(outlist[[g]], "data_info")$Variable.label <-\n            enc2utf8(parse_info$var_label)\n        }\n      }\n      attr(outlist[[g]], "data_info")$by_var <-\n        setdiff(colnames(attr(x, "groups")), ".rows")\n      attr(outlist[[g]], "data_info")$Group    <- g_ks[g]\n      attr(outlist[[g]], "data_info")$by_first <- g == 1\n      attr(outlist[[g]], "data_info")$by_last  <- g == length(g_ks)\n      attr(outlist[[g]], "format_info")$keep.grp.vars <- keep.grp.vars\n      \n    }\n    class(outlist) <- "stby"\n    return(outlist)\n  }\n\n  # Validate arguments ---------------------------------------------------------\n  if (is.null(x)) {\n    tmp_x_name <- deparse(substitute(x))\n    stop(tmp_x_name, " is either NULL or does not exist")\n  }\n\n  errmsg <- character()  # problems with arguments will be stored here\n\n  # Flag to replace colname when x is not a data frame\n  converted_to_df <- FALSE\n  if (!is.data.frame(x)) {\n    xnames <- substitute(x)\n    x <- try(as.data.frame(x))\n\n    if (inherits(x, "try-error")) {\n      errmsg %+=% paste(deparse(xnames), " is not coercible to a data frame")\n    } else {\n      converted_to_df <- TRUE\n      df_name <- setdiff(all.names(xnames), c("[", "[[", ":", "$"))[1]\n      if (!isTRUE(silent)) {\n        message(deparse(xnames), " was converted to a data frame")\n      }\n    }\n  }\n\n  errmsg <- c(errmsg, check_args(match.call(), list(...)))\n\n  if (length(errmsg) > 0) {\n    stop(paste(errmsg, collapse = "\\n  "))\n  }\n\n  # End of arguments validation ------------------------------------------------\n\n  # Declare number formatting function ----------------------------------\n  # Normally, formatting is handled by print() / view(), but in dfSummary,\n  # the numbers are mixed in with text in multiline cells, so it would\n  # require some more work, i.e. changing cell contents to lists that\n  # could then be handled correctly by summarytools\' print method. So what \n  # follows can be viewed as a temporary solution for a complex formatting \n  # problem.\n  dotArgs <- list(...)\n  fmtArgs <- list()\n\n  # Gather from additional arguments (...) those which will be used by format().\n  # Most format arguments are actually recognized. Formatting arguments that are\n  # neither in this list, neither recognized by pander, will be ignored.\n  for (fmt in c("big.mark", "small.mark", "decimal.mark", "scientific",\n                "small.interval", "big.interval", "nsmall", "digits")) {\n    if (fmt %in% names(dotArgs)) {\n      fmtArgs[fmt] <- dotArgs[fmt]\n    }\n  }\n\n  # Make sure fmtArgs has at least one element; digits is an arbitrary choice.\n  if (!"digits" %in% names(fmtArgs)) {\n    fmtArgs$digits <- getOption("digits")\n  }\n\n  # Check for column labels ----------------------------------------------------\n  if (isTRUE(labels.col) && length(label(x, all = TRUE)) == 0) {\n    labels.col <- FALSE\n  }\n\n  # Get metadata for x ---------------------------------------------------------\n  parse_info <- try(parse_args(sys.calls(), sys.frames(), match.call(),\n                               var_name = converted_to_df,\n                               var_label = converted_to_df,\n                               caller = "dfSummary"),\n                    silent = TRUE)\n\n  if (inherits(parse_info, "try-error")) {\n    parse_info <- list()\n  }\n\n  if (!("df_name" %in% names(parse_info)) && exists("df_name")) {\n    parse_info$df_name <- df_name\n  }\n\n  if (isTRUE(converted_to_df) && identical(colnames(x), "x")) {\n    if ("var_name" %in% names(parse_info)) {\n      colnames(x) <- parse_info$var_name\n    } else {\n      colnames(x) <- parse_info$df_name\n    }\n  }\n\n  if (isFALSE(st_options("use.x11"))) {\n    store_imgs <- FALSE\n  } else if (!isTRUE(plain.ascii) && style == "grid" && isTRUE(graph.col)) {\n    if (is.na(tmp.img.dir)) {\n      store_imgs <- FALSE\n      if (!isTRUE(silent)) {\n        png_message <- TRUE\n      }\n    } else {\n      store_imgs <- TRUE\n      dir.create(tmp.img.dir, showWarnings = FALSE)\n      if (.st_env$sysname == "Windows" || tmp.img.dir != "/tmp") {\n        if (!isTRUE(silent)) {\n          message("temporary images written to \'",\n                  normalizePath(tmp.img.dir), "\'")\n        }\n      }\n    }\n  } else {\n    store_imgs <- FALSE\n  }\n\n  # Initialize the output data frame -------------------------------------------\n\n  output <- data.frame(no               = numeric(),\n                       variable         = character(),\n                       label            = character(),\n                       stats.values     = character(),\n                       freqs.pct.valid  = character(),\n                       graph            = character(),\n                       text.graph       = character(),\n                       valid            = character(),\n                       missing          = character(),\n                       stringsAsFactors = FALSE,\n                       check.names      = FALSE)\n\n  n_tot <- nrow(x)\n\n\n  # iterate over columns of x --------------------------------------------------\n\n  for (i in seq_len(ncol(x))) {\n\n    # extract column data\n\n    column_data <- x[[i]]\n\n    # Calculate valid vs missing data info\n    n_miss <- sum(is.na(column_data))\n    n_valid <- ifelse(is.list(column_data),\n                              sum(!is.na(column_data)),\n                              n_tot - n_miss)\n    \n    \n    # Build content for first 3 columns of output data frame\n    #   Column 1: Variable number\n    #   Column 2: Variable name and class\n    #   Column 3: Label\n\n    output[i,1] <- i\n\n    output[i,2] <- paste0(names(x)[i], "\\\\\\n[",\n                          paste(class(column_data), collapse = ", "),\n                          "]")\n\n    if (!is.list(column_data)) {\n      # Check if column contains emails\n      if (is.character(column_data)) {\n        email_val <- detect_email(column_data)\n      } else {\n        email_val <- FALSE\n      }\n  \n      if (!identical(email_val, FALSE)) {\n        output[i,2] <- paste(output[i,2], trs("emails"), sep = "\\\\\\n")\n      }\n  \n      # Add UPC/EAN info if applicable\n      if (is.factor(column_data)) {\n        barcode_type <- detect_barcode(as.character(column_data))\n      } else {\n        barcode_type <- detect_barcode(column_data)\n      }\n  \n      if (is.character(barcode_type)) {\n        output[i,2] <- paste(output[i,2],\n                             paste(barcode_type, trs("codes")),\n                             sep = "\\\\\\n")\n        if (is.numeric(column_data)) {\n          column_data <- as.character(column_data)\n        }\n      }\n    }\n\n    # Add column label (if applicable)\n    if (isTRUE(labels.col)) {\n      output[i,3] <- label(x[[i]])\n      if (is.na(output[i,3]))\n        output[i,3] <- ""\n    }\n\n    # Data crunching by type starts here ---------------------------------------\n    # Column 4: Stats / Values\n    # Column 5: Freqs / % of Valid\n    # Column 6: Graph (png)\n    # Column 7: Graph (ascii)\n    # Column 8: Valid count & pct.\n    # Column 9: NA    count & pct. \n\n    # Deal with lists first -- they are treated differently, not as "deeply"\n    # analyzed, for now\n    if (is.list(column_data)) {\n      # 4th column: names of intra-objects\n      output[i, 4] <- paste0(1:length(column_data),"\\\\. ", names(column_data),\n                             collapse = "\\\\\\n")\n      # 5th column: Types and % valid of intra-objects\n      output[i, 5] <- paste0(vapply(X = column_data, \n                                    FUN = class, \n                                    FUN.VALUE = " "),\n                             "  (",\n                             format(vapply(X = column_data,\n                                    FUN = pctvalid,\n                                    FUN.VALUE = 1),\n                                    nsmall = 1\n                             ),\n                             "% ", trs("valid"),\n                             collapse = ")\\\\\\n")\n      output[i, 6] <- ""\n      output[i, 7] <- ""\n    }\n    \n    # Factors: display a column of levels and a column of frequencies ----------\n    else if (is.factor(column_data)) {\n      output[i, 4:7] <- crunch_factor(column_data)\n    }\n\n    # Character data: display frequencies whenever possible --------------------\n    else if (is.character(column_data)) {\n      output[i, 4:7] <- crunch_character(column_data, email_val)\n    }\n\n    # Logical data -------------------------------------------------------------\n    else if (is.logical(column_data)) {\n      output[i, 4:7] <- crunch_logical(column_data)\n    }\n\n    # Numeric data, display a column of descriptive stats + column of freqs ----\n    else if (is.numeric(column_data)) {\n      output[i, 4:7] <- crunch_numeric(column_data, is.character(barcode_type))\n    }\n\n    # Time/date data -----------------------------------------------------------\n    else if (inherits(column_data, c("Date", "POSIXct", "difftime"))) {\n      output[i, 4:7] <- crunch_time_date(column_data)\n    }\n\n    # Data does not fit in previous categories ---------------------------------\n    else {\n      output[i, 4:7] <- crunch_other(column_data)\n    }\n\n    # Data crunching by type ends here -----------------------------------------\n\n    # Valid (non-missing) data, frequency and proportion -----------------------\n    output[i, 8] <-\n      paste0(format_number(n_valid, round.digits = 0), "\\\\\\n(",\n             format_number(n_valid / (n_valid + n_miss) * 100, \n                           round.digits = 1, nsmall = 1),\n             "%)")\n    \n    # Missing data, frequency and proportion -----------------------------------\n    output[i, 9] <-\n      paste0(format_number(n_miss, round.digits = 0), "\\\\\\n(",\n             format_number(n_miss / (n_valid + n_miss) * 100,\n                           round.digits = 1, nsmall = 1),\n             "%)")\n  }\n\n  # Prepare output object ------------------------------------------------------\n  if (!isTRUE(varnumbers)) {\n    output$no <- NULL\n  }\n\n  if (!isTRUE(labels.col)) {\n    output$label <- NULL\n  }\n\n  if (!isTRUE(graph.col)) {\n    output$graph <- NULL\n    output$text.graph <- NULL\n  }\n\n  if (!isTRUE(valid.col)) {\n    output$valid <- NULL\n  }\n\n  if (!isTRUE(na.col)) {\n    output$missing <- NULL\n  }\n\n  # apply translations to colnames\n  for (i in seq_along(output)) {\n    if (colnames(output)[i] == "text.graph")\n      next\n    colnames(output)[i] <- trs(colnames(output)[i])\n  }\n\n  # Set output attributes\n  class(output) <- c("summarytools", class(output))\n  attr(output, "st_type") <- "dfSummary"\n  attr(output, "date") <- Sys.Date()\n  attr(output, "fn_call") <- match.call()\n\n  data_info <-\n    list(Data.frame       = parse_info$df_name,\n         Data.frame.label = ifelse("df_label" %in% names(parse_info),\n                                   parse_info$df_label, NA),\n         Dimensions       = c(n_tot, ncol(x)),\n         Duplicates       = n_tot - n_distinct(x),\n         Group            = ifelse("by_group" %in% names(parse_info),\n                                   parse_info$by_group, NA),\n         by_var           = unlist(ifelse("by_var" %in% names(parse_info),\n                                          parse_info["by_var"], NA)),\n         by_first         = ifelse("by_group" %in% names(parse_info),\n                                   parse_info$by_first, NA),\n         by_last          = ifelse("by_group" %in% names(parse_info),\n                                   parse_info$by_last , NA))\n\n  attr(output, "data_info") <- data_info[!is.na(data_info)]\n  \n  format_info <- list(style          = style,\n                      round.digits   = round.digits,\n                      plain.ascii    = plain.ascii,\n                      justify        = justify,\n                      headings       = headings,\n                      display.labels = display.labels,\n                      labels.col     = labels.col,\n                      split.cells    = split.cells,\n                      split.tables   = split.tables,\n                      col.widths     = col.widths,\n                      keep.grp.vars  = ifelse("by_var" %in% names(parse_info),\n                                              keep.grp.vars, NA))\n  \n  attr(output, "format_info") <- format_info[!is.na(format_info)]\n\n  attr(output, "user_fmt") <- list(... = ...)\n\n  attr(output, "lang") <- st_options("lang")\n\n  if (exists("png_message"))\n    attr(output, "png_message") <- TRUE\n\n  if (clear_null_device) {\n    try(dev.off(), silent = TRUE)\n  }\n  return(output)\n}\n\n#\' @keywords internal\ncrunch_factor <- function(column_data, email_val) {\n\n  outlist <- list()\n  outlist[[1]] <- ""\n  outlist[[2]] <- ""\n  outlist[[3]] <- ""\n  outlist[[4]] <- ""\n\n  column_data <- ws_to_symbol(column_data)\n\n  levels(column_data)[levels(column_data) == ""] <-\n    paste0("(", trs("empty.str"), ")")\n\n  pf <- parent.frame()\n  max.string.width    <- pf$max.string.width\n  max.distinct.values <- pf$max.distinct.values\n  graph.magnif        <- pf$graph.magnif\n  round.digits        <- pf$round.digits\n  n_valid             <- pf$n_valid\n  \n  n_levels <- nlevels(column_data)\n  counts   <- table(column_data, useNA = "no")\n  props    <- prop.table(counts)\n\n  if (n_levels == 0 && n_valid == 0) {\n    outlist[[1]] <- trs("no.levels.defined")\n    outlist[[2]] <- trs("all.nas")\n    outlist[[3]] <- ""\n    outlist[[4]] <- ""\n\n  } else if (n_valid == 0) {\n    outlist[[1]] <- paste0(1:n_levels,"\\\\. ", levels(column_data),\n                           collapse = "\\\\\\n")\n    outlist[[2]] <- trs("all.nas")\n    outlist[[3]] <- ""\n    outlist[[4]] <- ""\n\n  } else if (n_levels <= max.distinct.values + 1) {\n    outlist[[1]] <- paste0(seq_along(counts),"\\\\. ",\n                           substr(levels(column_data), 1, max.string.width),\n                           collapse = "\\\\\\n")\n    # counts_props <- align_numbers_dfs(counts, round(props, 3))\n    counts_props <- align_numbers_dfs(counts, props)\n    outlist[[2]] <- paste0("\\\\", counts_props, collapse = "\\\\\\n")\n    if (isTRUE(pf$graph.col) && any(!is.na(column_data))) {\n      if (isTRUE(st_options("use.x11"))) {\n        outlist[[3]] <- encode_graph(counts, "barplot", graph.magnif)\n      }\n      if (isTRUE(pf$store_imgs)) {\n        png_loc <- encode_graph(counts, "barplot", graph.magnif, TRUE)\n        outlist[[4]] <- paste0("![](", png_loc, ")")\n      } else {\n        outlist[[4]] <- txtbarplot(prop.table(counts))\n      }\n    }\n\n  } else {\n\n    # more levels than allowed by max.distinct.values\n    n_extra_levels <- n_levels - max.distinct.values\n\n    outlist[[1]] <-\n      paste0(1:max.distinct.values,"\\\\. ",\n             substr(levels(column_data), 1,\n                    max.string.width)[1:max.distinct.values],\n             collapse = "\\\\\\n")\n\n    outlist[[1]] <- paste(outlist[[1]],\n                          paste("[", format_number(n_extra_levels, \n                                                   round.digits = 0),\n                                trs("others"), "]"),\n                          sep = "\\\\\\n")\n\n    counts_props <- align_numbers_dfs(\n      c(counts[1:max.distinct.values],\n        sum(counts[(max.distinct.values + 1):length(counts)])),\n      c(props[1:max.distinct.values],\n        #round(sum(props[(max.distinct.values + 1):length(props)]), 3))\n        sum(props[(max.distinct.values + 1):length(props)]))\n    )\n\n    outlist[[2]] <- paste0("\\\\", counts_props, collapse = "\\\\\\n")\n\n    if (isTRUE(pf$graph.col) && any(!is.na(column_data))) {\n      # Prepare data for bar plot\n      tmp_data <- column_data\n      levels(tmp_data)[max.distinct.values + 1] <-\n        paste("[", format_number(n_extra_levels, round.digits = 0),\n              trs("others"), "]")\n      tmp_data[which(as.numeric(tmp_data) > max.distinct.values)] <-\n        paste("[", format_number(n_extra_levels, round.digits = 0),\n              trs("others"), "]")\n      levels(tmp_data)[(max.distinct.values + 2):n_levels] <- NA\n      if (isTRUE(st_options("use.x11"))) {\n        outlist[[3]] <- encode_graph(table(tmp_data), "barplot", graph.magnif)\n      }\n      if (isTRUE(pf$store_imgs)) {\n        png_loc <- encode_graph(table(tmp_data), "barplot", graph.magnif, TRUE)\n        outlist[[4]] <- paste0("![](", png_loc, ")")\n      } else {\n        outlist[[4]] <- txtbarplot(prop.table(table(tmp_data)))\n      }\n    }\n  }\n\n  outlist[[1]] <- enc2utf8(outlist[[1]])\n  outlist[[2]] <- enc2utf8(outlist[[2]])\n  outlist[[3]] <- enc2utf8(outlist[[3]])\n  return(outlist)\n}\n\n#\' @keywords internal\n#\' @importFrom dplyr n_distinct\ncrunch_character <- function(column_data, email_val) {\n\n  outlist <- list()\n  outlist[[1]] <- ""\n  outlist[[2]] <- ""\n  outlist[[3]] <- ""\n  outlist[[4]] <- ""\n\n  pf <- parent.frame()\n  max.string.width    <- pf$max.string.width\n  max.distinct.values <- pf$max.distinct.values\n  graph.magnif        <- pf$graph.magnif\n  round.digits        <- pf$round.digits\n  n_valid             <- pf$n_valid\n  \n  if (isTRUE(pf$trim.strings)) {\n    column_data <- trimws(column_data)\n  }\n\n  n_empty <- sum(column_data == "", na.rm = TRUE)\n\n  if (n_empty == pf$n_tot) {\n    outlist[[1]] <- paste0(trs("all.empty.str"), "\\n")\n  } else if (pf$n_miss == pf$n_tot) {\n    outlist[[1]] <- paste0(trs("all.nas"), "\\n") # \\n to circumvent pander bug\n  } else if (n_empty + pf$n_miss == pf$n_tot) {\n    outlist[[1]] <- paste0(trs("all.empty.str.nas"), "\\n")\n  } else if (!identical(email_val, FALSE)) {\n\n    outlist[[1]] <-\n      paste(trs("valid"), trs("invalid"), trs("duplicates"), sep = "\\\\\\n")\n\n    dups      <- n_valid - n_distinct(column_data, na.rm = TRUE)\n    \n    # TODO: Check if rounding is relevant here\n    prop.dups <- round(dups / n_valid, 3)\n\n    counts_props <- align_numbers_dfs(\n      c(email_val, dups),\n      #c(round(prop.table(email_val), 3), prop.dups)\n      c(prop.table(email_val), prop.dups)\n    )\n\n    outlist[[2]] <- paste0("\\\\", counts_props, collapse = "\\\\\\n")\n\n    if (isTRUE(pf$graph.col) && any(!is.na(column_data))) {\n      if (isTRUE(st_options("use.x11"))) {\n        outlist[[3]] <- encode_graph(c(email_val, dups), "barplot", graph.magnif,\n                                     emails = TRUE)\n      }\n      if (isTRUE(pf$store_imgs)) {\n        png_loc <- encode_graph(c(email_val, dups), "barplot", graph.magnif,\n                                pandoc = TRUE, emails = TRUE)\n        outlist[[4]] <- paste0("![](", png_loc, ")")\n      } else {\n        outlist[[4]] <- txtbarplot(c(prop.table(email_val), prop.dups),\n                                   emails = TRUE)\n      }\n    }\n\n  } else {\n\n    counts <- table(column_data, useNA = "no")\n\n    # Replace empty strings with "(Empty string)" or the corresponding\n    #  translation\n    names(counts) <- sub("^$", paste0("(", trs("empty.str"), ")"), \n                         names(counts))\n\n    # Replace white-space-only strings with as many middle-dot symbols to make\n    # them visible in the output table\n    names(counts) <- ws_to_symbol(names(counts))\n\n    props <- prop.table(counts)\n\n    if (length(counts) <= max.distinct.values + 1) {\n      # Report all frequencies when allowed by max.distinct.values\n      outlist[[1]] <- paste0(seq_along(counts), "\\\\. ",\n                             substr(names(counts), 1, max.string.width),\n                             collapse = "\\\\\\n")\n      #counts_props <- align_numbers_dfs(counts, round(props, 3))\n      counts_props <- align_numbers_dfs(counts, props)\n      outlist[[2]] <- paste0("\\\\", counts_props, collapse = "\\\\\\n")\n      if (isTRUE(pf$graph.col) &&\n          any(!is.na(column_data))) {\n        if (isTRUE(st_options("use.x11"))) {\n          outlist[[3]] <- encode_graph(counts, "barplot", graph.magnif)\n        }\n        if (isTRUE(pf$store_imgs)) {\n          png_loc <- encode_graph(counts, "barplot", graph.magnif, TRUE)\n          outlist[[4]] <- paste0("![](", png_loc, ")")\n        } else {\n          outlist[[4]] <- txtbarplot(prop.table(counts))\n        }\n      }\n    } else {\n      # more values than allowed by max.distinct.values\n      counts <- sort(counts, decreasing = TRUE)\n      props <- sort(props, decreasing = TRUE)\n      n_extra_values <- length(counts) - max.distinct.values\n      \n      # Build list of most frequent values \n      outlist[[1]] <- paste0(\n        paste0(1:max.distinct.values,"\\\\. ",\n               substr(names(counts), 1,\n                      max.string.width)[1:max.distinct.values],\n               collapse = "\\\\\\n"),\n        paste("\\\\\\n[", format_number(n_extra_values, round.digits = 0),\n              trs("others"), "]")\n      )\n      \n      # Prepare data for building frequency cell with numbers + proportions\n      counts_props <- align_numbers_dfs(\n        c(counts[1:max.distinct.values],\n          sum(counts[(max.distinct.values + 1):length(counts)])),\n        c(props[1:max.distinct.values],\n          sum(props[(max.distinct.values + 1):length(props)]))\n      )\n\n      outlist[[2]] <- paste0("\\\\", counts_props, collapse = "\\\\\\n")\n\n      if (isTRUE(pf$graph.col) &&\n          any(!is.na(column_data))) {\n        # Prepare data for bar plot\n        counts[max.distinct.values + 1] <-\n          sum(counts[(max.distinct.values + 1):length(counts)])\n        names(counts)[max.distinct.values + 1] <-\n          paste("[", n_extra_values, trs("others"),"]")\n        counts <- counts[1:(max.distinct.values + 1)]\n        if (isTRUE(st_options("use.x11"))) {\n          outlist[[3]] <- encode_graph(counts, "barplot", graph.magnif)\n        }\n        if (isTRUE(pf$store_imgs)) {\n          png_loc <- encode_graph(counts, "barplot", graph.magnif, TRUE)\n          outlist[[4]] <- paste0("![](", png_loc, ")")\n        } else {\n          outlist[[4]] <- txtbarplot(prop.table(counts))\n        }\n      }\n    }\n  }\n\n  outlist[[1]] <- enc2utf8(outlist[[1]])\n  outlist[[2]] <- enc2utf8(outlist[[2]])\n  outlist[[3]] <- enc2utf8(outlist[[3]])\n  return(outlist)\n}\n\n#\' @keywords internal\ncrunch_logical <- function(column_data) {\n\n  outlist <- list()\n  outlist[[1]] <- ""\n  outlist[[2]] <- ""\n  outlist[[3]] <- ""\n  outlist[[4]] <- ""\n\n  pf <- parent.frame()\n  graph.magnif        <- pf$graph.magnif\n  round.digits        <- pf$round.digits\n\n  if (pf$n_miss == pf$n_tot) {\n    outlist[[1]] <- paste0(trs("all.nas"), "\\n") # \\n to circumvent pander bug\n  } else {\n\n    counts <- table(column_data, useNA = "no")\n    props <- prop.table(counts)\n\n    outlist[[1]] <- paste0(seq_along(counts), "\\\\. ", names(counts),\n                           collapse = "\\\\\\n")\n    #counts_props <- align_numbers_dfs(counts, round(props, 3))\n    counts_props <- align_numbers_dfs(counts, props)\n    outlist[[2]] <- paste0("\\\\", counts_props, collapse = "\\\\\\n")\n    if (isTRUE(pf$graph.col) &&\n        any(!is.na(column_data))) {\n      if (isTRUE(st_options("use.x11"))) {\n        outlist[[3]] <- encode_graph(counts, "barplot", graph.magnif)\n      }\n      if (isTRUE(pf$store_imgs)) {\n        png_loc <- encode_graph(counts, "barplot", graph.magnif, TRUE)\n        outlist[[4]] <- paste0("![](", png_loc, ")")\n      } else {\n        outlist[[4]] <- txtbarplot(prop.table(counts))\n      }\n    }\n  }\n\n  outlist[[1]] <- enc2utf8(outlist[[1]])\n  outlist[[2]] <- enc2utf8(outlist[[2]])\n  outlist[[3]] <- enc2utf8(outlist[[3]])\n  return(outlist)\n}\n\n\n#\' @importFrom stats IQR median ftable sd\n#\' @keywords internal\ncrunch_numeric <- function(column_data, is_barcode) {\n\n  outlist <- list()\n  outlist[[1]] <- ""\n  outlist[[2]] <- ""\n  outlist[[3]] <- ""\n  outlist[[4]] <- ""\n\n  pf <- parent.frame()\n  max.distinct.values <- pf$max.distinct.values\n  graph.magnif        <- pf$graph.magnif\n  round.digits        <- pf$round.digits\n  \n  if (pf$n_miss == pf$n_tot) {\n    outlist[[1]] <- paste0(trs("all.nas"), "\\n")\n  } else {\n    counts <- table(column_data, useNA = "no")\n    min_val <- min(column_data, na.rm = TRUE)\n    max_val <- max(column_data, na.rm = TRUE)\n\n    # Stats cell\n    # Check number of distinct values & presence of bar code data\n    if (length(counts) == 1) {\n      outlist[[1]] <- paste(1, trs("distinct.value"))\n    } else {\n      if (isTRUE(is_barcode)) {\n        maxchars <- max(nchar(c(trs("min"), trs("max"), trs("mode"))))\n        outlist[[1]] <- paste0(\n          trs("min"), strrep(" ", maxchars - nchar(trs("min"))), " : ",\n          min_val, "\\\\\\n",\n          trs("mode"), strrep(" ", maxchars - nchar(trs("mode"))), " : ",\n          names(counts)[which.max(counts)][1], "\\\\\\n",\n          trs("max"), strrep(" ", maxchars - nchar(trs("max"))), " : ",\n          max_val\n        )\n      } else if (length(counts) == 2) {\n        maxchars <- max(nchar(c(trs("min"), trs("max"), trs("mean"))))\n        outlist[[1]] <- paste0(\n          trs("min"), strrep(" ", maxchars - nchar(trs("min"))), " : ",\n          round(min_val, round.digits), "\\\\\\n",\n          trs("mean"), strrep(" ", maxchars - nchar(trs("mean"))), " : ",\n          round(mean(column_data, na.rm = TRUE), round.digits), "\\\\\\n",\n          trs("max"), strrep(" ", maxchars - nchar(trs("max"))), " : ",\n          round(max_val, round.digits)\n        )\n      } else {\n        outlist[[1]] <- paste(\n          trs("mean"), paste0(" (", trs("sd"), ") : "),\n          format_number(mean(column_data, na.rm = TRUE), round.digits), " (",\n          format_number(sd(column_data, na.rm = TRUE), round.digits), ")\\\\\\n",\n          tolower(paste(trs("min"), "<", trs("med.short"), "<", trs("max"))),\n          ":\\\\\\n", format_number(min_val, round.digits),\n          " < ", format_number(median(column_data, na.rm = TRUE), round.digits),\n          " < ", format_number(max_val, round.digits),\n          if (is.expression(st_options("dfSummary.custom.1")))\n            paste0("\\\\\\n", eval(st_options("dfSummary.custom.1"))),\n          if (is.expression(st_options("dfSummary.custom.2")))\n            paste0("\\\\\\n", eval(st_options("dfSummary.custom.2"))),\n          collapse = "", sep = ""\n        )\n      }\n    }\n\n    # Frequencies cell\n\n    # Initialize variable indicating if an extra line is required, when\n    # frequencies are displayed for rounded values\n    extra_space <- FALSE\n\n    # With timeseries (ts) objects, display n distinct, start & end\n    if (inherits(column_data, "ts")) {\n      maxchars <- max(nchar(c(trs("start"), trs("end"))))\n      outlist[[2]] <-\n        paste(length(counts), trs("distinct.values"),\n              paste0("\\\\\\n", trs("start"),\n                     strrep(" ", maxchars - nchar(trs("start"))), ":"),\n              paste(sprintf("%02d", start(column_data)),\n                    collapse = "-"),\n              paste0("\\\\\\n", trs("end"),\n                     strrep(" ", maxchars - nchar(trs("end"))), ":"),\n              paste(sprintf("%02d", end(column_data)),\n                    collapse = "-"))\n    }\n\n    # Display most common values in following circumstances:\n    # 1. Number of distinct values is allowed by max.distinct.values \n    # AND one of the following is true\n    # a. All values are whole numbers\n    # b. Once rounding applied, number of unique values is unchanged\n    else if (\n      length(counts) <= max.distinct.values &&\n      (all(column_data %% 1 == 0, na.rm = TRUE) ||\n       length(counts) == length(unique(round(column_data, round.digits + 1))))\n      ) {\n\n      rounded_names <- \n        format_number(as.numeric(names(counts)), \n                      round.digits = round.digits + 1,\n                      nsmall = (round.digits + (round.digits == 1)) * \n                        !all(floor(column_data) == column_data, na.rm = TRUE)\n        )\n        # The last multiplication above causes the function to show\n        # the preferred "final" column in the frequencies cell, rather than\n        # those shown in the "rounded" column:\n        # \n        #    number  rounded   final       Actual cell\n        # --------------------------       ------------------\n        # 1.0600778   1.0600    1.06  ==>  1.06!: 160 (16.0%)\n        # 1.0500121   1.0500    1.05  ==>  1.05!: 324 (32.4%) \n        # 1.0400007   1.0400    1.04  ==>  1.04!: 249 (24.9%)\n        # 0.8600902   0.8600    0.86  ==>  0.86!: 267 (26.7%)\n        # \n        # Also, when round.digits = 1 (default), we allow an \n        # additional digit, for practical reasons. Based on\n        # experience, keeping an additional digit is preferable --\n        # this avoids having to set round.digits to 2, affecting\n        # all statistics, which is an overkill in most cases.\n\n      # Variable used for padding\n      maxchars <- max(nchar(rounded_names))\n\n      props <- prop.table(counts)\n      counts_props <- align_numbers_dfs(counts, props)\n\n      outlist[[2]] <-\n        paste(\n          paste0(rounded_names, strrep(" ", maxchars - nchar(rounded_names)),\n                 ifelse(as.numeric(names(counts)) != \n                          round(as.numeric(names(counts)), round.digits + 1),\n                        "!", " ")),\n          counts_props, sep = ": ", collapse = "\\\\\\n"\n        )\n\n      # Add "! rounded" when relevant \n      if (grepl("!", outlist[[2]])) {\n        extra_space <- TRUE\n        outlist[[2]] <- paste(outlist[[2]], paste("!", trs("rounded")),\n                              sep = "\\\\\\n")\n      }\n\n    } else {\n      # Do not display specific values - only the number of distinct values\n      outlist[[2]] <- paste(format_number(length(counts), round.digits = 0),\n                            trs("distinct.values"))\n\n      # Check for integer sequences\n      if (pf$n_miss == 0 &&\n          all(is.integer(column_data)) &&\n          length(column_data) == max_val - min_val + 1) {\n        res <- try(isTRUE(all.equal(column_data, min_val:max_val)) ||\n                     isTRUE(all.equal(column_data, max_val:min_val)),\n                   silent = TRUE)\n        if (isTRUE(res)) {\n          outlist[[2]] <- paste(outlist[[2]],\n                                paste0("(", trs("int.sequence"), ")"),\n                                sep = "\\\\\\n")\n        }\n      }\n    }\n\n    if (isTRUE(pf$graph.col)) {\n      if (length(counts) <= max.distinct.values) {\n        if (isTRUE(st_options("use.x11"))) {\n          outlist[[3]] <- encode_graph(counts, "barplot", graph.magnif)\n        }\n        if (isTRUE(pf$store_imgs)) {\n          png_loc <- encode_graph(counts, "barplot", graph.magnif, TRUE)\n          outlist[[4]] <- paste0("![](", png_loc, ")")\n        } else {\n          outlist[[4]] <- txtbarplot(prop.table(counts))\n        }\n\n        if (isTRUE(extra_space)) {\n          if (isTRUE(st_options("use.x11"))) {\n            outlist[[3]] <- paste0(outlist[[3]], "\\n\\n")\n          }\n          outlist[[4]] <- paste0(outlist[[4]], " \\\\ \\n \\\\")\n        }\n      } else {\n        if (isTRUE(st_options("use.x11"))) {\n          outlist[[3]] <- encode_graph(column_data, "histogram", graph.magnif)\n        }\n        if (isTRUE(pf$store_imgs)) {\n          png_loc <- encode_graph(column_data, "histogram", graph.magnif, TRUE)\n          outlist[[4]] <- paste0("![](", png_loc, ")")\n        } else {\n          outlist[[4]] <- txthist(column_data)\n        }\n      }\n    }\n  }\n\n  outlist[[1]] <- enc2utf8(outlist[[1]])\n  outlist[[2]] <- enc2utf8(outlist[[2]])\n  outlist[[3]] <- enc2utf8(outlist[[3]])\n  return(outlist)\n}\n\n#\' @importFrom lubridate as.period interval\n#\' @keywords internal\ncrunch_time_date <- function(column_data) {\n\n  outlist <- list()\n  outlist[[1]] <- ""\n  outlist[[2]] <- ""\n  outlist[[3]] <- ""\n  outlist[[4]] <- ""\n\n  pf <- parent.frame()\n  max.distinct.values <- pf$max.distinct.values\n  graph.magnif        <- pf$graph.magnif\n  round.digits        <- pf$round.digits\n\n  if (pf$n_miss == pf$n_tot) {\n    outlist[[1]] <- paste0(trs("all.nas"), "\\n")\n  } else {\n\n    counts <- table(column_data, useNA = "no")\n\n    # Report all frequencies when allowed by max.distinct.values\n    if (length(counts) <= max.distinct.values) {\n      outlist[[1]] <- paste0(seq_along(counts),". ", names(counts),\n                             collapse = "\\\\\\n")\n      props <- round(prop.table(counts), 3)\n      counts_props <- align_numbers_dfs(counts, props)\n      outlist[[2]] <- paste(counts_props, collapse = "\\\\\\n")\n      if (isTRUE(st_options("use.x11"))) {\n        outlist[[3]] <- encode_graph(counts, "barplot", graph.magnif)\n      }\n      if (isTRUE(pf$store_imgs)) {\n        png_loc <- encode_graph(counts, "barplot", graph.magnif, TRUE)\n        outlist[[4]] <- paste0("![](", png_loc, ")")\n      } else {\n        outlist[[4]] <- txtbarplot(prop.table(counts))\n      }\n    } else {\n\n      if (inherits(column_data, what = "difftime")) {\n\n        outlist[[1]] <- paste0(\n          tolower(trs("min")), " : ", tmin <- min(as.numeric(column_data), \n                                                  na.rm = TRUE), "\\\\\\n",\n          tolower(trs("med.short")), " : ", median(as.numeric(column_data), \n                                                   na.rm = TRUE), "\\\\\\n",\n          tolower(trs("max")), " : ", tmax <- max(as.numeric(column_data), \n                                                  na.rm = TRUE)\n        )\n\n        if ("units" %in% names(attributes(column_data))) {\n          outlist[[1]] <- paste0(outlist[[1]], "\\\\\\n", "units : ", \n                                 units(column_data))\n        }\n\n      } else {\n        outlist[[1]] <- paste0(\n          tolower(trs("min")), " : ", tmin <- min(column_data, na.rm = TRUE),\n          "\\\\\\n",\n          tolower(trs("med.short")), " : ", median(column_data, na.rm = TRUE),\n          "\\\\\\n",\n          tolower(trs("max")), " : ", tmax <- max(column_data, na.rm = TRUE), \n          "\\\\\\n",\n          "range : ", sub(pattern = " 0H 0M 0S", replacement = "",\n                          x = round(as.period(interval(tmin, tmax)), \n                                    round.digits))\n        )\n      }\n\n      outlist[[2]] <- paste(length(counts), trs("distinct.values"))\n\n      if (isTRUE(pf$graph.col)) {\n        tmp <- as.numeric(column_data)[!is.na(column_data)]\n        if (isTRUE(st_options("use.x11"))) {\n          outlist[[3]] <- encode_graph(tmp - mean(tmp), "histogram", \n                                       graph.magnif)\n        }\n        if (isTRUE(pf$store_imgs)) {\n          png_loc <- encode_graph(tmp - mean(tmp), "histogram", graph.magnif,\n                                  TRUE)\n          outlist[[4]] <- paste0("![](", png_loc, ")")\n        } else {\n          outlist[[4]] <- txthist(tmp - mean(tmp))\n        }\n      }\n    }\n  }\n  outlist\n}\n\n#\' @keywords internal\ncrunch_other <- function(column_data) {\n\n  outlist <- list()\n  outlist[[1]] <- ""\n  outlist[[2]] <- ""\n  outlist[[3]] <- ""\n  outlist[[4]] <- ""\n\n  pf <- parent.frame()\n  max.distinct.values <- pf$max.distinct.values\n  round.digits        <- pf$round.digits\n\n  if (!is.list(column_data)) {\n    counts <- table(column_data, useNA = "no")\n\n    if (pf$n_miss == pf$n_tot) {\n      outlist[[1]] <- paste0(trs("all.nas"), "\\n")\n\n    } else if (length(counts) <= max.distinct.values) {\n      props <- round(prop.table(counts), 3)\n      counts_props <- align_numbers_dfs(counts, props)\n      outlist[[2]] <- paste0(counts_props, collapse = "\\\\\\n")\n\n    } else {\n      outlist[[2]] <- paste(as.character(length(unique(column_data))),\n                            trs("distinct.values"))\n    }\n  } else {\n    # column is a list\n    if (pf$n_miss == pf$n_tot) {\n      outlist[[1]] <- paste0(trs("all.nas"), "\\n")\n    } else {\n      # Get attributes for first non-na value\n      for (v in seq_along(column_data)) {\n        if (is.na(column_data[v]))\n          next\n        # get class and length of single value\n        outlist[[1]] <- paste0("Object class(es):", "\\\\\\n",\n                               paste(class(column_data[[v]]), collapse = ", "),\n                               "\\\\\\n", "Length: ", length(column_data[[v]]))\n        tmp_distinct <- try(paste(as.character(length(unique(column_data))),\n                                  trs("distinct.values")), silent = TRUE)\n        if (!inherits(tmp_distinct, "try-error")) {\n          outlist[[2]] <- tmp_distinct\n        }\n        break\n      }\n    }\n  }\n\n  return(outlist)\n}\n\n# Utility functions ------------------------------------------------------------\n#\' format_number\n#\'\n#\' Used internally (not exported) to apply all relevant formatting. It is \n#\' documented here only because it can be used when setting the \n#\' \\code{dfSummary.custom.1} and  \\code{dfSummary.custom.1} options.\n#\'\n#\' @param x A numerical value to be formatted.\n#\' @param round.digits Numerical. Number of decimals to show. Used to define \n#\'   both \\code{digits} and \\code{nsmall} when calling \\code{\\link{format}}. \n#\' @param ... Any other formatting instruction that is compatible with \n#\'  \\code{\\link{format}}.\n#\'  \n#\' @examples \n#\' \n#\' \\dontrun{\n#\' format_number(IQR(column_data, na.rm = TRUE), round.digits)\n#\' format_number(IQR(column_data, na.rm = TRUE), decimal.mark = ",")\n#\' }\nformat_number <- function(x, round.digits, ...) {\n  \n  n <- 1\n  repeat {\n    fmtArgs <- parent.frame(n)$fmtArgs\n    if (is.null(fmtArgs) && n < sys.nframe())\n      n <- n + 1\n    else\n      break\n  }\n  \n  # Allow over-riding of formatting attributes - for now this is only to allow\n  # nsmall = 1, so that proportions always use one decimal. \n  dotArgs <- list(...)\n  for (f in names(dotArgs)) {\n    fmtArgs[f] <- dotArgs[f]\n  }\n  \n  # If we have digits + scientific = TRUE, we don\'t want to round\n  if ("digits" %in% names(fmtArgs) && isTRUE(fmtArgs$scientific)) {\n    return(do.call(format, append(fmtArgs, x = quote(x))))\n  } else {\n    x <- round(x, round.digits)\n    return(do.call(format, append(fmtArgs, x = quote(x))))\n  }\n}\n\n\n#\' @keywords internal\nalign_numbers_dfs <- function(counts, props) {\n  \n  # New version\n  counts   <- format_number(counts, round.digits = parent.frame()$round.digits)\n  props    <- format_number(props * 100, round.digits = 1, nsmall = 1)\n  pad_cnt  <- max(nchar(counts)) - nchar(counts)\n  pad_pct  <- max(nchar(props)) - nchar(props)\n  retval   <- paste(paste0(strrep(" ", pad_cnt), counts),\n                    paste0("(", strrep(" ", pad_pct), props, "%)"))\n  retval\n}\n\n#\' @importFrom base64enc base64encode\n#\' @importFrom graphics barplot hist par text plot.new\n#\' @importFrom grDevices dev.off nclass.Sturges png\n#\' @importFrom magick image_read image_trim image_border image_write\n#\'             image_transparent\n#\' @keywords internal\nencode_graph <- function(data, graph_type, graph.magnif = 1,\n                         pandoc = FALSE, emails = FALSE) {\n  devtype <- switch(.st_env$sysname,\n                    Windows = "windows",\n                    Linux   = "Xlib",\n                    Darwin  = "quartz")\n\n  if (graph_type == "histogram") {\n    rc <- try(png(png_loc <- tempfile(fileext = ".png"),\n                  width = 150 * graph.magnif,\n                  height = 110 * graph.magnif,\n                  units = "px", bg = "transparent",\n                  type = devtype, antialias = "none"), silent = TRUE)\n\n    # If it fails, fallback on default device type\n    if (!is.null(rc)) {\n      png(png_loc <- tempfile(fileext = ".png"),\n          width = 150 * graph.magnif,\n          height = 110 * graph.magnif,\n          units = "px", bg = "transparent",\n          antialias = "none")\n    }\n\n    mar <- par("mar" = c(0.03, 0.02, 0.03, 0.02)) # bottom, left, top, right\n    on.exit(par(mar), add = TRUE)\n    data <- data[!is.na(data)]\n\n    # Correction for vectors of infinitesimal range\n    # if (diff(range(data)) < 1e-301) {\n    #   e <- paste0(\'1e\',sub(".+e-(.+)", "\\\\1", min(data)))\n    #   e <- min(as.numeric(e), 1e308)\n    #   data <- data * e\n    # }\n\n    breaks_x <- pretty(range(data), n = min(nclass.Sturges(data), 250),\n                       min.n = 1)\n    cl <- try(suppressWarnings(hist(data, freq = FALSE, breaks = breaks_x,\n                                    axes = FALSE, xlab = NULL, ylab = NULL,\n                                    main = NULL, col = "grey94",\n                                    border = "grey65")),\n              silent = TRUE)\n    if (inherits(cl, "try-error")) {\n      plot.new()\n      text("Graph Not Available", x = 0.5, y = 0.5, cex = 1)\n    }\n\n    dev.off()\n    ii <- image_read(png_loc)\n    ii <- image_border(image_trim(ii), color = "white", geometry = "6x4")\n\n  } else if (graph_type == "barplot") {\n\n    rc <- try(png(png_loc <- tempfile(fileext = ".png"),\n                  width = 150 * graph.magnif,\n                  height = 25.5 * length(data) * graph.magnif,\n                  units = "px", bg = "transparent",\n                  type = devtype, antialias = "none"), silent = TRUE)\n\n    # If it fails, fallback on default device type\n    if (!is.null(rc)) {\n      png(png_loc <- tempfile(fileext = ".png"),\n          width = 150 * graph.magnif,\n          height = 25.55 * length(data) * graph.magnif,\n          units = "px", bg = "transparent",\n          antialias = "none")\n    }\n\n    mar <- par("mar" = c(0.07, 0.02, 0.07, 0.02)) # bottom, left, top, right\n    on.exit(par(mar), add = TRUE)\n    data <- rev(data)\n\n    if (isTRUE(emails)) {\n      barplot(data, names.arg = "", axes = FALSE, space = 0.22, #0.21,\n              col = c("grey30", "grey94", "grey94"), border = "grey65",\n              horiz = TRUE, xlim = c(0, sum(data[2:3])))\n    } else {\n      barplot(data, names.arg = "", axes = FALSE, space = 0.22, #0.21,\n              col = "grey94", border = "grey65", horiz = TRUE,\n              xlim = c(0, sum(data)))\n    }\n\n    dev.off()\n    ii <- image_read(png_loc)\n    ii <- image_border(image_trim(ii), color = "white", geometry = "6x4")\n  }\n\n  if (isTRUE(pandoc)) {\n    png_path <- generate_png_path(parent.frame(2)$tmp.img.dir)\n    image_write(image_transparent(ii, \'white\'),\n                path = png_path)\n    return(png_path)\n  } else {\n    image_write(image_transparent(ii, \'white\'), png_loc)\n    img_txt <- base64encode(readBin(con = png_loc, what = "raw",\n                                    n = file.info(png_loc)[["size"]]))\n    return(paste0(\'<img style="border:none;background-color:transparent;\',\n                  \'padding:0;max-width:max-content;" src="data:image/png;base64, \', img_txt, \'">\'))\n  }\n}\n\n#\' @keywords internal\ngenerate_png_path <- function(d) {\n  filelist <- dir(d, pattern = "ds\\\\d+\\\\.png", full.names = TRUE)\n  if (length(filelist) == 0) {\n    return(paste0(d, "/ds0001.png"))\n  } else {\n    max_num <- as.numeric(sub("^.+/ds(\\\\d+)\\\\.png$", "\\\\1", tail(filelist, 1)))\n    png_path <- paste0(d, "/ds", sprintf("%04d", max_num + 1), ".png")\n    return(png_path)\n  }\n}\n\n#\' @keywords internal\ntxtbarplot <- function(props, maxwidth = 20, emails = FALSE) {\n  #widths <- props / max(props) * maxwidth\n  widths <- props * maxwidth\n  outstr <- character(0)\n  for (i in seq_along(widths)) {\n    outstr <- paste(outstr,\n                    paste0(rep(x = ifelse(isTRUE(emails) && i == length(widths),\n                                          "D", "I"), times = widths[i]),\n                           collapse = ""),\n                    sep = " \\\\ \\n")\n  }\n  outstr <- sub("^ \\\\\\\\ \\\\n", "", outstr)\n  return(outstr)\n}\n\n#\' @importFrom grDevices nclass.Sturges\n#\' @keywords internal\ntxthist <- function(data) {\n  data <- data[!is.na(data)]\n  if (is.infinite(max(abs(data)))) {\n    return(\'\')\n  }\n  # Correction for vectors of infinitesimal range\n  if (diff(range(data)) < 1e-301) {\n    e <- paste0(\'1e\',sub(".+e-(.+)", "\\\\1", min(data)))\n    e <- min(as.numeric(e), 1e308)\n    data <- data * e\n  }\n\n  breaks_x <- pretty(range(data), n = nclass.Sturges(data), min.n = 1)\n  if (length(breaks_x) <= 10) {\n    counts <- hist(data, breaks = breaks_x, plot = FALSE)$counts\n  } else {\n    counts <- as.vector(table(cut(data, breaks = 10)))\n  }\n\n  # make counts top at 10\n  counts <- matrix(round(counts / max(counts) * 10), nrow = 1, byrow = TRUE)\n  graph <- matrix(data = "", nrow = 5, ncol = length(counts))\n  for (ro in 5:1) {\n    for (co in seq_along(counts)) {\n      if (counts[co] > 1) {\n        graph[ro,co] <- ": "\n      } else if (counts[co] > 0) {\n        graph[ro,co] <- ". "\n      } else {\n        if (sum(counts[1, co:length(counts)] > 0)) {\n          graph[ro,co] <- "\\\\ \\\\ "\n        }\n      }\n    }\n    counts <- matrix(apply(X = counts - 2, MARGIN = 2, FUN = max, 0),\n                     nrow = 1, byrow = TRUE)\n  }\n\n  graphlines <- character()\n  for (ro in seq_len(nrow(graph))) {\n    graphlines[ro] <-  trimws(paste(graph[ro,], collapse = ""), "right")\n  }\n  return(paste(graphlines, collapse = "\\\\\\n"))\n}\n\n\ndetect_email <- function(x) {\n\n  email_regex <- "\\\\<[A-Z0-9._%+-]+@[A-Z0-9.-]+\\\\.[A-Z]{2,}\\\\>"\n\n  if (length(x) > 200) {\n    x_sample <- na.omit(sample(x, size = 200, replace = FALSE))\n  } else {\n    x_sample <- na.omit(x)\n  }\n\n  if (length(x_sample) == 0) {\n    return(FALSE)\n  }\n\n  pct_email <- sum(grepl(email_regex, x_sample, ignore.case = TRUE)) /\n    length(x_sample)\n\n  if (pct_email >= .8) {\n    valid <- sum(grepl(email_regex, x, ignore.case = TRUE), na.rm = TRUE)\n    invalid <- parent.frame()$n_valid - valid\n    return(c(valid = valid, invalid = invalid))\n  } else {\n    return(FALSE)\n  }\n}\n\n#\' @importFrom utils head\n#\' @importFrom stats na.omit\n#\' @keywords internal\ndetect_barcode <- function(x) {\n\n  # Check that all strings contain numbers\n  # ref: https://rosettacode.org/wiki/Determine_if_a_string_is_numeric#R\n  if (!all(suppressWarnings(!is.na(as.numeric(x))))) {\n    return(FALSE)\n  }\n\n  # Check for negatives and non-integers\n  if (min(x, na.rm = TRUE) < 0 || any(floor(as.numeric(x)) != as.numeric(x),\n                                      na.rm = TRUE)) {\n    return(FALSE)\n  }\n\n  # check that all lengths are equal on a sample of 50 values, and that this \n  # length is compatible with one of the EAN/UPC/ITC specifications\n  x_samp <- na.omit(sample(x = x, size = min(length(x), 50), replace = FALSE))\n  if (length(x_samp) < 3 ||\n      (len <- nchar(min(x_samp, na.rm = TRUE))) != nchar(max(x, na.rm = TRUE)) ||\n      !len %in% c(8,12,13,14)) {\n    return(FALSE)\n  }\n\n  type <- switch(as.character(len),\n                 "8"  = "EAN-8",\n                 "12" = "UPC",\n                 "13" = "EAN-13",\n                 "14" = "ITF-14")\n\n  x_pad      <- paste0(strrep("0", 14 - len), x_samp)\n  vect_code  <- lapply(strsplit(x_pad,""), as.numeric)\n  weighted   <- lapply(vect_code, FUN = function(x) x * c(3,1))\n  sums       <- mapply(weighted, FUN = sum)\n\n  if (any(sums %% 10 != 0, na.rm = TRUE)) {\n    return(FALSE)\n  }\n\n  return(type)\n}\n'