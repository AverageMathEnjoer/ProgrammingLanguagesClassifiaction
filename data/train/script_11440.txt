b'{-# LANGUAGE NoImplicitPrelude #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n{-# LANGUAGE RebindableSyntax #-}\n\nmodule Course.MoreParser where\n\nimport Course.Core\nimport Course.Parser\nimport Course.List\nimport Course.Optional\nimport Course.Applicative\nimport Course.Monad\nimport Course.Functor\nimport Course.Traversable\n\n-- $setup\n-- >>> :set -XOverloadedStrings\n-- >>> import Course.Parser(isErrorResult, character, lower, is)\n-- >>> import Data.Char(isUpper, isLower)\n\n-- | Parses the given input and returns the result.\n-- The remaining input is ignored.\n(<.>) ::\n  Parser a\n  -> Input\n  -> Optional a\nP p <.> i =\n  case p i of\n    Result _ a -> Full a\n    _          -> Empty\n\n-- | Write a parser that will parse zero or more spaces.\n--\n-- >>> parse spaces " abc"\n-- Result >abc< " "\n--\n-- >>> parse spaces "abc"\n-- Result >abc< ""\nspaces ::\n  Parser Chars\nspaces =\n  error "todo: Course.MoreParser#spaces"\n\n-- | Write a function that applies the given parser, then parses 0 or more spaces,\n-- then produces the result of the original parser.\n--\n-- /Tip:/ Use the monad instance.\n--\n-- >>> parse (tok (is \'a\')) "a bc"\n-- Result >bc< \'a\'\n--\n-- >>> parse (tok (is \'a\')) "abc"\n-- Result >bc< \'a\'\ntok ::\n  Parser a\n  -> Parser a\ntok =\n  error "todo: Course.MoreParser#tok"\n\n-- | Write a function that parses the given char followed by 0 or more spaces.\n--\n-- >>> parse (charTok \'a\') "abc"\n-- Result >bc< \'a\'\n--\n-- >>> isErrorResult (parse (charTok \'a\') "dabc")\n-- True\n-- \n-- /Tip:/ Use `tok` and `is`.\ncharTok ::\n  Char\n  -> Parser Char\ncharTok =\n  error "todo: Course.MoreParser#charTok"\n\n-- | Write a parser that parses a comma \',\' followed by 0 or more spaces.\n--\n-- >>> parse commaTok ",123"\n-- Result >123< \',\'\n--\n-- >>> isErrorResult( parse commaTok "1,23")\n-- True\n-- \n-- /Tip:/ Use `charTok`.\ncommaTok ::\n  Parser Char\ncommaTok =\n  error "todo: Course.MoreParser#commaTok"\n\n-- | Write a parser that parses either a double-quote or a single-quote.\n--\n-- /Tip:/ Use `is` and `|||`\n--\n-- >>> parse quote "\'abc"\n-- Result >abc< \'\\\'\'\n--\n-- >>> parse quote "\\"abc"\n-- Result >abc< \'"\'\n--\n-- >>> isErrorResult (parse quote "abc")\n-- True\nquote ::\n  Parser Char\nquote =\n  error "todo: Course.MoreParser#quote"\n\n-- | Write a function that parses the given string (fails otherwise).\n--\n-- /Tip:/ Use `is` and `traverse`.\n--\n-- >>> parse (string "abc") "abcdef"\n-- Result >def< "abc"\n--\n-- >>> isErrorResult (parse (string "abc") "bcdef")\n-- True\nstring ::\n  Chars\n  -> Parser Chars\nstring =\n  error "todo: Course.MoreParser#is"\n\n-- | Write a function that parsers the given string, followed by 0 or more spaces.\n--\n-- /Tip:/ Use `tok` and `string`.\n--\n-- >>> parse (stringTok "abc") "abc  "\n-- Result >< "abc"\n--\n-- >>> isErrorResult (parse (stringTok "abc") "bc  ")\n-- True\nstringTok ::\n  Chars\n  -> Parser Chars\nstringTok =\n  error "todo: Course.MoreParser#stringTok"\n\n-- | Write a function that tries the given parser, otherwise succeeds by producing the given value.\n--\n-- /Tip:/ Use `|||`.\n--\n-- >>> parse (option \'x\' character) "abc"\n-- Result >bc< \'a\'\n--\n-- >>> parse (option \'x\' character) ""\n-- Result >< \'x\'\noption ::\n  a\n  -> Parser a\n  -> Parser a\noption =\n  error "todo: Course.MoreParser#option"\n\n-- | Write a parser that parses 1 or more digits.\n--\n-- /Tip:/ Use `list1` and `digit`.\n--\n-- >>> parse digits1 "123"\n-- Result >< "123"\n--\n-- >>> isErrorResult (parse digits1 "abc123")\n-- True\ndigits1 ::\n  Parser Chars\ndigits1 =\n  error "todo: Course.MoreParser#digits1"\n\n-- | Write a function that parses one of the characters in the given string.\n--\n-- /Tip:/ Use `satisfy` and `elem`.\n--\n-- >>> parse (oneof "abc") "bcdef"\n-- Result >cdef< \'b\'\n--\n-- >>> isErrorResult (parse (oneof "abc") "def")\n-- True\noneof ::\n  Chars\n  -> Parser Char\noneof =\n  error "todo: Course.MoreParser#oneof"\n\n-- | Write a function that parses any character, but fails if it is in the given string.\n--\n-- /Tip:/ Use `satisfy` and `notElem`.\n--\n-- >>> parse (noneof "bcd") "abc"\n-- Result >bc< \'a\'\n--\n-- >>> isErrorResult (parse (noneof "abcd") "abc")\n-- True\nnoneof ::\n  Chars\n  -> Parser Char\nnoneof =\n  error "todo: Course.MoreParser#noneof"\n\n-- | Write a function that applies the first parser, runs the third parser keeping the result,\n-- then runs the second parser and produces the obtained result.\n--\n-- /Tip:/ Use the monad instance.\n--\n-- >>> parse (between (is \'[\') (is \']\') character) "[a]"\n-- Result >< \'a\'\n--\n-- >>> isErrorResult (parse (between (is \'[\') (is \']\') character) "[abc]")\n-- True\n--\n-- >>> isErrorResult (parse (between (is \'[\') (is \']\') character) "[abc")\n-- True\n--\n-- >>> isErrorResult (parse (between (is \'[\') (is \']\') character) "abc]")\n-- True\nbetween ::\n  Parser o\n  -> Parser c\n  -> Parser a\n  -> Parser a\nbetween =\n  error "todo: Course.MoreParser#between"\n\n-- | Write a function that applies the given parser in between the two given characters.\n--\n-- /Tip:/ Use `between` and `charTok`.\n--\n-- >>> parse (betweenCharTok \'[\' \']\' character) "[a]"\n-- Result >< \'a\'\n--\n-- >>> isErrorResult (parse (betweenCharTok \'[\' \']\' character) "[abc]")\n-- True\n--\n-- >>> isErrorResult (parse (betweenCharTok \'[\' \']\' character) "[abc")\n-- True\n--\n-- >>> isErrorResult (parse (betweenCharTok \'[\' \']\' character) "abc]")\n-- True\nbetweenCharTok ::\n  Char\n  -> Char\n  -> Parser a\n  -> Parser a\nbetweenCharTok =\n  error "todo: Course.MoreParser#betweenCharTok"\n\n-- | Write a function that parses 4 hex digits and return the character value.\n--\n-- /Tip:/ Use `readHex`, `isHexDigit`, `replicateA`, `satisfy` and the monad instance.\n--\n-- >>> parse hex "0010"\n-- Result >< \'\\DLE\'\n--\n-- >>> parse hex "0a1f"\n-- Result >< \'\\2591\'\n--\n-- >>> isErrorResult (parse hex "001")\n-- True\n--\n-- >>> isErrorResult (parse hex "0axf")\n-- True\nhex ::\n  Parser Char\nhex =\n  error "todo: Course.MoreParser#hex"\n\n-- | Write a function that parses the character \'u\' followed by 4 hex digits and return the character value.\n--\n-- /Tip:/ Use `is` and `hex`.\n--\n-- >>> parse hexu "u0010"\n-- Result >< \'\\DLE\'\n--\n-- >>> parse hexu "u0a1f"\n-- Result >< \'\\2591\'\n--\n-- >>> isErrorResult (parse hexu "0010")\n-- True\n--\n-- >>> isErrorResult (parse hexu "u001")\n-- True\n--\n-- >>> isErrorResult (parse hexu "u0axf")\n-- True\nhexu ::\n  Parser Char\nhexu =\n  error "todo: Course.MoreParser#hexu"\n\n-- | Write a function that produces a non-empty list of values coming off the given parser (which must succeed at least once),\n-- separated by the second given parser.\n--\n-- /Tip:/ Use `list` and the monad instance.\n--\n-- >>> parse (sepby1 character (is \',\')) "a"\n-- Result >< "a"\n--\n-- >>> parse (sepby1 character (is \',\')) "a,b,c"\n-- Result >< "abc"\n--\n-- >>> parse (sepby1 character (is \',\')) "a,b,c,,def"\n-- Result >def< "abc,"\n--\n-- >>> isErrorResult (parse (sepby1 character (is \',\')) "")\n-- True\nsepby1 ::\n  Parser a\n  -> Parser s\n  -> Parser (List a)\nsepby1 =\n  error "todo: Course.MoreParser#sepby1"\n\n-- | Write a function that produces a list of values coming off the given parser,\n-- separated by the second given parser.\n--\n-- /Tip:/ Use `sepby1` and `|||`.\n--\n-- >>> parse (sepby character (is \',\')) ""\n-- Result >< ""\n--\n-- >>> parse (sepby character (is \',\')) "a"\n-- Result >< "a"\n--\n-- >>> parse (sepby character (is \',\')) "a,b,c"\n-- Result >< "abc"\n--\n-- >>> parse (sepby character (is \',\')) "a,b,c,,def"\n-- Result >def< "abc,"\nsepby ::\n  Parser a\n  -> Parser s\n  -> Parser (List a)\nsepby =\n  error "todo: Course.MoreParser#sepby"\n\n-- | Write a parser that asserts that there is no remaining input.\n--\n-- >>> parse eof ""\n-- Result >< ()\n--\n-- >>> isErrorResult (parse eof "abc")\n-- True\neof ::\n  Parser ()\neof =\n  error "todo: Course.MoreParser#eof"\n\n-- | Write a parser that produces a character that satisfies all of the given predicates.\n--\n-- /Tip:/ Use `sequence` and @Data.List#and@.\n--\n-- >>> parse (satisfyAll (isUpper :. (/= \'X\') :. Nil)) "ABC"\n-- Result >BC< \'A\'\n--\n-- >>> parse (satisfyAll (isUpper :. (/= \'X\') :. Nil)) "ABc"\n-- Result >Bc< \'A\'\n--\n-- >>> isErrorResult (parse (satisfyAll (isUpper :. (/= \'X\') :. Nil)) "XBc")\n-- True\n--\n-- >>> isErrorResult (parse (satisfyAll (isUpper :. (/= \'X\') :. Nil)) "")\n-- True\n--\n-- >>> isErrorResult (parse (satisfyAll (isUpper :. (/= \'X\') :. Nil)) "abc")\n-- True\nsatisfyAll ::\n  List (Char -> Bool)\n  -> Parser Char\nsatisfyAll =\n  error "todo: Course.MoreParser#satisfyAll"\n\n-- | Write a parser that produces a character that satisfies any of the given predicates.\n--\n-- /Tip:/ Use `sequence` and @Data.List#or@.\n--\n-- >>> parse (satisfyAny (isLower :. (/= \'X\') :. Nil)) "abc"\n-- Result >bc< \'a\'\n--\n-- >>> parse (satisfyAny (isLower :. (/= \'X\') :. Nil)) "ABc"\n-- Result >Bc< \'A\'\n--\n-- >>> isErrorResult (parse (satisfyAny (isLower :. (/= \'X\') :. Nil)) "XBc")\n-- True\n--\n-- >>> isErrorResult (parse (satisfyAny (isLower :. (/= \'X\') :. Nil)) "")\n-- True\nsatisfyAny ::\n  List (Char -> Bool)\n  -> Parser Char\nsatisfyAny =\n  error "todo: Course.MoreParser#satisfyAny"\n\n-- | Write a parser that parses between the two given characters, separated by a comma character \',\'.\n--\n-- /Tip:/ Use `betweenCharTok`, `sepby` and `charTok`.\n--\n-- >>> parse (betweenSepbyComma \'[\' \']\' lower) "[a]"\n-- Result >< "a"\n--\n-- >>> parse (betweenSepbyComma \'[\' \']\' lower) "[]"\n-- Result >< ""\n--\n-- >>> isErrorResult (parse (betweenSepbyComma \'[\' \']\' lower) "[A]")\n-- True\n--\n-- >>> isErrorResult (parse (betweenSepbyComma \'[\' \']\' lower) "[abc]")\n-- True\n--\n-- >>> isErrorResult (parse (betweenSepbyComma \'[\' \']\' lower) "[a")\n-- True\n--\n-- >>> isErrorResult (parse (betweenSepbyComma \'[\' \']\' lower) "a]")\n-- True\nbetweenSepbyComma ::\n  Char\n  -> Char\n  -> Parser a\n  -> Parser (List a)\nbetweenSepbyComma =\n  error "todo: Course.MoreParser#betweenSepbyComma"\n'