b'\xef\xbb\xbf//\n// Mono.Math.Prime.PrimalityTests.cs - Test for primality\n//\n// Authors:\n//\tBen Maurer\n//\n// Copyright (c) 2003 Ben Maurer. All rights reserved\n//\n\n//\n// Permission is hereby granted, free of charge, to any person obtaining\n// a copy of this software and associated documentation files (the\n// "Software"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to\n// permit persons to whom the Software is furnished to do so, subject to\n// the following conditions:\n// \n// The above copyright notice and this permission notice shall be\n// included in all copies or substantial portions of the Software.\n// \n// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,\n// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n//\n\nusing System;\n\nnamespace Mono.Math.Prime {\n\n#if INSIDE_CORLIB\n\tinternal\n#else\n\tpublic\n#endif\n\tdelegate bool PrimalityTest(BigInteger bi, ConfidenceFactor confidence);\n\n#if INSIDE_CORLIB\n\tinternal\n#else\n\tpublic\n#endif\n\tsealed class PrimalityTests {\n\n\t\tprivate PrimalityTests() {\n\t\t}\n\n\t\t#region SPP Test\n\n\t\tprivate static int GetSPPRounds(BigInteger bi, ConfidenceFactor confidence) {\n\t\t\tint bc = bi.BitCount();\n\n\t\t\tint Rounds;\n\n\t\t\t// Data from HAC, 4.49\n\t\t\tif (bc <= 100) Rounds = 27;\n\t\t\telse if (bc <= 150) Rounds = 18;\n\t\t\telse if (bc <= 200) Rounds = 15;\n\t\t\telse if (bc <= 250) Rounds = 12;\n\t\t\telse if (bc <= 300) Rounds = 9;\n\t\t\telse if (bc <= 350) Rounds = 8;\n\t\t\telse if (bc <= 400) Rounds = 7;\n\t\t\telse if (bc <= 500) Rounds = 6;\n\t\t\telse if (bc <= 600) Rounds = 5;\n\t\t\telse if (bc <= 800) Rounds = 4;\n\t\t\telse if (bc <= 1250) Rounds = 3;\n\t\t\telse Rounds = 2;\n\n\t\t\tswitch (confidence) {\n\t\t\t\tcase ConfidenceFactor.ExtraLow:\n\t\t\t\t\tRounds >>= 2;\n\t\t\t\t\treturn Rounds != 0 ? Rounds : 1;\n\t\t\t\tcase ConfidenceFactor.Low:\n\t\t\t\t\tRounds >>= 1;\n\t\t\t\t\treturn Rounds != 0 ? Rounds : 1;\n\t\t\t\tcase ConfidenceFactor.Medium:\n\t\t\t\t\treturn Rounds;\n\t\t\t\tcase ConfidenceFactor.High:\n\t\t\t\t\treturn Rounds << 1;\n\t\t\t\tcase ConfidenceFactor.ExtraHigh:\n\t\t\t\t\treturn Rounds << 2;\n\t\t\t\tcase ConfidenceFactor.Provable:\n\t\t\t\t\tthrow new Exception("The Rabin-Miller test can not be executed in a way such that its results are provable");\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new ArgumentOutOfRangeException("confidence");\n\t\t\t}\n\t\t}\n\n\t\tpublic static bool Test(BigInteger n, ConfidenceFactor confidence) {\n\t\t\t// Rabin-Miller fails with smaller primes (at least with our BigInteger code)\n\t\t\tif (n.BitCount() < 33)\n\t\t\t\treturn SmallPrimeSppTest(n, confidence);\n\t\t\telse\n\t\t\t\treturn RabinMillerTest(n, confidence);\n\t\t}\n\n\t\t/// <summary>\n\t\t///     Probabilistic prime test based on Rabin-Miller\'s test\n\t\t/// </summary>\n\t\t/// <param name="n" type="BigInteger.BigInteger">\n\t\t///     <para>\n\t\t///         The number to test.\n\t\t///     </para>\n\t\t/// </param>\n\t\t/// <param name="confidence" type="int">\n\t\t///     <para>\n\t\t///\tThe number of chosen bases. The test has at least a\n\t\t///\t1/4^confidence chance of falsely returning True.\n\t\t///     </para>\n\t\t/// </param>\n\t\t/// <returns>\n\t\t///\t<para>\n\t\t///\t\tTrue if "this" is a strong pseudoprime to randomly chosen bases.\n\t\t///\t</para>\n\t\t///\t<para>\n\t\t///\t\tFalse if "this" is definitely NOT prime.\n\t\t///\t</para>\n\t\t/// </returns>\n\t\tpublic static bool RabinMillerTest(BigInteger n, ConfidenceFactor confidence) {\n\t\t\tint bits = n.BitCount();\n\t\t\tint t = GetSPPRounds(bits, confidence);\n\n\t\t\t// n - 1 == 2^s * r, r is odd\n\t\t\tBigInteger n_minus_1 = n - 1;\n\t\t\tint s = n_minus_1.LowestSetBit();\n\t\t\tBigInteger r = n_minus_1 >> s;\n\n\t\t\tBigInteger.ModulusRing mr = new BigInteger.ModulusRing(n);\n\n\t\t\t// Applying optimization from HAC section 4.50 (base == 2)\n\t\t\t// not a really random base but an interesting (and speedy) one\n\t\t\tBigInteger y = null;\n\t\t\t// FIXME - optimization disable for small primes due to bug #81857\n\t\t\tif (n.BitCount() > 100)\n\t\t\t\ty = mr.Pow(2, r);\n\n\t\t\t// still here ? start at round 1 (round 0 was a == 2)\n\t\t\tfor (int round = 0; round < t; round++) {\n\n\t\t\t\tif ((round > 0) || (y == null)) {\n\t\t\t\t\tBigInteger a = null;\n\n\t\t\t\t\t// check for 2 <= a <= n - 2\n\t\t\t\t\t// ...but we already did a == 2 previously as an optimization\n\t\t\t\t\tdo {\n\t\t\t\t\t\ta = BigInteger.GenerateRandom(bits);\n\t\t\t\t\t} while ((a <= 2) && (a >= n_minus_1));\n\n\t\t\t\t\ty = mr.Pow(a, r);\n\t\t\t\t}\n\n\t\t\t\tif (y == 1)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tfor (int j = 0; ((j < s) && (y != n_minus_1)); j++) {\n\n\t\t\t\t\ty = mr.Pow(y, 2);\n\t\t\t\t\tif (y == 1)\n\t\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\tif (y != n_minus_1)\n\t\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\tpublic static bool SmallPrimeSppTest(BigInteger bi, ConfidenceFactor confidence) {\n\t\t\tint Rounds = GetSPPRounds(bi, confidence);\n\n\t\t\t// calculate values of s and t\n\t\t\tBigInteger p_sub1 = bi - 1;\n\t\t\tint s = p_sub1.LowestSetBit();\n\n\t\t\tBigInteger t = p_sub1 >> s;\n\n\n\t\t\tBigInteger.ModulusRing mr = new BigInteger.ModulusRing(bi);\n\n\t\t\tfor (int round = 0; round < Rounds; round++) {\n\n\t\t\t\tBigInteger b = mr.Pow(BigInteger.smallPrimes[round], t);\n\n\t\t\t\tif (b == 1) continue;              // a^t mod p = 1\n\n\t\t\t\tbool result = false;\n\t\t\t\tfor (int j = 0; j < s; j++) {\n\n\t\t\t\t\tif (b == p_sub1) {         // a^((2^j)*t) mod p = p-1 for some 0 <= j <= s-1\n\t\t\t\t\t\tresult = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tb = (b * b) % bi;\n\t\t\t\t}\n\n\t\t\t\tif (result == false)\n\t\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\t#endregion\n\n\t\t// TODO: Implement the Lucus test\n\t\t// TODO: Implement other new primality tests\n\t\t// TODO: Implement primality proving\n\t}\n}'