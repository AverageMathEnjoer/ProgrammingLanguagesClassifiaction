b'{-# LANGUAGE GADTs #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{-# LANGUAGE RecordWildCards #-}\n\nmodule Graphics.Hoodle.Render.Type.Renderer where\n\nimport Control.Concurrent.STM\n  ( STM,\n    TMVar,\n    TVar,\n    readTVar,\n    readTVarIO,\n    writeTVar,\n  )\nimport Control.Monad.IO.Class (MonadIO (liftIO))\nimport Control.Monad.Trans.Reader (ReaderT)\nimport qualified Data.ByteString.Char8 as B\nimport qualified Data.HashMap.Strict as HM\nimport Data.Hashable (Hashable (..))\nimport Data.Hoodle.Simple (Dimension (..))\nimport Data.Sequence (Seq, (|>))\nimport qualified Data.Sequence as Seq (filter)\nimport Data.UUID (UUID)\nimport Data.UUID.V4 (nextRandom)\nimport Graphics.Hoodle.Render.Type.Item (RItem)\nimport qualified Graphics.Rendering.Cairo as Cairo\n\n-- import qualified Graphics.UI.Gtk.Poppler.Document as Poppler\n\nnewtype PDFCommandID = PDFCommandID UUID deriving (Show, Eq, Ord)\n\ndata PDFCommand where\n  GetDocFromFile :: B.ByteString -> TMVar (Maybe () {- Poppler.Document -}) -> PDFCommand\n  GetDocFromDataURI :: B.ByteString -> TMVar (Maybe () {- Poppler.Document -}) -> PDFCommand\n  GetPageFromDoc :: () {- Poppler.Document -} -> !Int -> TMVar (Maybe () {- Poppler.Page -}) -> PDFCommand\n  GetNPages {- !Poppler.Document -} :: () -> TMVar Int -> PDFCommand\n  RenderPageScaled :: SurfaceID -> () {- Poppler.Page -} -> Dimension -> Dimension -> PDFCommand\n\ninstance Show PDFCommand where\n  show _ = "PDFCommand"\n\nnewtype GenCommandID = GenCommandID UUID deriving (Show, Eq, Ord)\n\ndata GenCommand where\n  BkgSmplScaled :: SurfaceID -> B.ByteString -> B.ByteString -> Dimension -> Dimension -> GenCommand\n  LayerInit :: SurfaceID -> [RItem] -> GenCommand\n  LayerRedraw :: SurfaceID -> [RItem] -> GenCommand\n  LayerScaled :: SurfaceID -> [RItem] -> Dimension -> Dimension -> GenCommand\n\ninstance Show GenCommand where\n  show (BkgSmplScaled sfcid _ _ _ _) = "BkgSmplScaled:" ++ show sfcid\n  show (LayerInit sfcid _) = "LayerInit:" ++ show sfcid\n  show (LayerRedraw sfcid _) = "LayerRedraw:" ++ show sfcid\n  show (LayerScaled sfcid _ _ _) = "LayerScaled:" ++ show sfcid\n\nnewtype SurfaceID = SurfaceID UUID deriving (Show, Eq, Ord, Hashable)\n\n-- |\ntype CanvasId = Int\n\n-- | hashmap: key = UUID, value = (original size, view size, surface)\ntype RenderCache = HM.HashMap SurfaceID (Double, Cairo.Surface)\n\n-- |\ndata RendererEvent\n  = SurfaceUpdate (SurfaceID, (Double, Cairo.Surface))\n  | FinishCommandFor SurfaceID\n\ntype PDFCommandQueue = TVar (Seq (PDFCommandID, PDFCommand))\n\ntype GenCommandQueue = TVar (Seq (GenCommandID, GenCommand))\n\ndata RendererState = RendererState\n  { rendererHandler :: RendererEvent -> IO (),\n    rendererPDFCmdQ :: PDFCommandQueue,\n    rendererGenCmdQ :: GenCommandQueue,\n    rendererCache :: TVar RenderCache\n  }\n\ngetRenderCache :: RendererState -> IO RenderCache\ngetRenderCache RendererState {..} = readTVarIO rendererCache\n\ntype Renderer = ReaderT RendererState IO\n\nissuePDFCommandID :: (Functor m, MonadIO m) => m PDFCommandID\nissuePDFCommandID = PDFCommandID <$> liftIO nextRandom\n\nissueGenCommandID :: (Functor m, MonadIO m) => m GenCommandID\nissueGenCommandID = GenCommandID <$> liftIO nextRandom\n\nissueSurfaceID :: (Functor m, MonadIO m) => m SurfaceID\nissueSurfaceID = SurfaceID <$> liftIO nextRandom\n\nsendPDFCommand ::\n  PDFCommandQueue ->\n  PDFCommandID ->\n  PDFCommand ->\n  STM ()\nsendPDFCommand queuevar cmdid cmd = do\n  queue <- readTVar queuevar\n  let queue\' = Seq.filter (not . isRemoved (cmdid, cmd)) queue\n      nqueue = queue\' |> (cmdid, cmd)\n  writeTVar queuevar nqueue\n\nisRemoved :: (PDFCommandID, PDFCommand) -> (PDFCommandID, PDFCommand) -> Bool\nisRemoved (cmdid, ncmd) (ocmdid, ocmd)\n  | cmdid == ocmdid = True\n  | otherwise = case ncmd of\n    RenderPageScaled nsfcid _ _ _ ->\n      case ocmd of\n        RenderPageScaled osfcid _ _ _ -> nsfcid == osfcid\n        _ -> False\n    _ -> False\n\nsendGenCommand ::\n  GenCommandQueue ->\n  GenCommandID ->\n  GenCommand ->\n  STM ()\nsendGenCommand queuevar cmdid cmd = do\n  queue <- readTVar queuevar\n  let queue\' = Seq.filter (not . isRemovedGen (cmdid, cmd)) queue\n      nqueue = queue\' |> (cmdid, cmd)\n  writeTVar queuevar nqueue\n\nsurfaceID :: GenCommand -> SurfaceID\nsurfaceID (BkgSmplScaled sfcid _ _ _ _) = sfcid\nsurfaceID (LayerInit sfcid _) = sfcid\nsurfaceID (LayerRedraw sfcid _) = sfcid\nsurfaceID (LayerScaled sfcid _ _ _) = sfcid\n\nisRemovedGen :: (GenCommandID, GenCommand) -> (GenCommandID, GenCommand) -> Bool\nisRemovedGen (cmdid, ncmd) (ocmdid, ocmd)\n  | cmdid == ocmdid = True\n  | otherwise = case ncmd of\n    BkgSmplScaled nsfcid _ _ _ _ -> surfaceID ocmd == nsfcid\n    LayerScaled nsfcid _ _ _ -> surfaceID ocmd == nsfcid\n    _ -> False\n'