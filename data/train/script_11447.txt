b'using System;\nusing System.Text;\nusing System.IO;\nusing System.Net;\nusing System.Collections.Generic;\nnamespace build_qqzeng_dat_65536\n{\n    public class IPSearch2Big\n    {\n        private Dictionary<int, PrefixIndex> prefDict;\n\n        private byte[] data;\n        private long prefCount;\n\n\n        /// <summary>\n        /// \xe5\x88\x9d\xe5\xa7\x8b\xe5\x8c\x96\xe4\xba\x8c\xe8\xbf\x9b\xe5\x88\xb6dat\xe6\x95\xb0\xe6\x8d\xae\n        /// </summary>\n        /// <param name="dataPath"></param>\n        public IPSearch2Big(string dataPath)\n        {\n            using (FileStream fs = new FileStream(dataPath, FileMode.Open, FileAccess.Read, FileShare.Read))\n            {\n                data = new byte[fs.Length];\n                fs.Read(data, 0, data.Length);\n            }\n\n            prefCount = Bytes2Long(data, 0, 4); //ip\xe6\xae\xb5\xe6\x95\xb0\xe9\x87\x8f\n            long ipCount = Bytes2Long(data, 4, 4);//\xe5\x89\x8d\xe7\xbc\x80\xe6\x95\xb0\xe9\x87\x8f\n            long ver = Bytes2Long(data, 8, 4);\n\n\n\n            //\xe5\x88\x9d\xe5\xa7\x8b\xe5\x8c\x96\xe5\x89\x8d\xe7\xbc\x80\xe5\xaf\xb9\xe5\xba\x94\xe7\xb4\xa2\xe5\xbc\x95\xe5\x8c\xba\xe5\x8c\xba\xe9\x97\xb4\n\n            prefDict = new Dictionary<int, PrefixIndex>();\n            for (var k = 0; k < prefCount; k++)\n            {\n                int i = k * 10 + 12;\n                int prefix = (int)Bytes2Long(data, i, 2);\n                long start_index = Bytes2Long(data, i + 2, 4);\n                long end_index = Bytes2Long(data, i + 6, 4);\n                prefDict.Add(prefix, new PrefixIndex() { prefix = prefix, start_index = start_index, end_index = end_index });\n            }\n\n        }\n\n\n\n        /// <summary>\n        /// \xe6\xa0\xb9\xe6\x8d\xaeip\xe6\x9f\xa5\xe8\xaf\xa2\xe5\xa4\x9a\xe7\xbb\xb4\xe5\xad\x97\xe6\xae\xb5\xe4\xbf\xa1\xe6\x81\xaf\n        /// </summary>\n        /// <param name="ip">ip\xe5\x9c\xb0\xe5\x9d\x80\xef\xbc\x88123.4.5.6\xef\xbc\x89</param>\n        /// <returns>\xe4\xba\x9a\xe6\xb4\xb2|\xe4\xb8\xad\xe5\x9b\xbd|\xe9\xa6\x99\xe6\xb8\xaf|\xe4\xb9\x9d\xe9\xbe\x99|\xe6\xb2\xb9\xe5\xb0\x96\xe6\x97\xba|\xe6\x96\xb0\xe4\xb8\x96\xe7\x95\x8c\xe7\x94\xb5\xe8\xae\xaf|810200|Hong Kong|HK|114.17495|22.327115</returns>\n        public string Query(string ip)\n        {\n            int pref;\n            uint intIP = IpToInt(ip, out pref);\n            long high, low;\n            if (prefDict.ContainsKey(pref))\n            {\n                low = prefDict[pref].start_index;\n                high = prefDict[pref].end_index;\n            }\n            else\n            {\n                return "";\n            }\n\n            long index = low == high ? low : BinarySearch(low, high, intIP);\n\n            long offset = 12 + prefCount * 10 + index * 13;\n            long startIp = Bytes2Long(data, offset, 4);\n            long endIp = Bytes2Long(data, 4 + offset, 4);\n\n            if ((startIp <= intIP) && (endIp >= intIP))\n            {\n                long local_offset = Bytes2Long(data, 8 + offset, 4);\n                long local_length = data[12 + offset];\n                return Encoding.UTF8.GetString(data, (int)local_offset, (int)local_length);\n            }\n            else\n            {\n                return "";\n            }\n\n        }\n\n\n\n\n\n        /// <summary>\n        /// \xe4\xba\x8c\xe5\x88\x86\xe9\x80\xbc\xe8\xbf\x91\xe7\xae\x97\xe6\xb3\x95\n        /// </summary>\n        private long BinarySearch(long low, long high, long k)\n        {\n            long M = 0;\n            while (low <= high)\n            {\n                long mid = (low + high) / 2;\n\n                long endipNum = GetEndIp(mid);\n                if (endipNum >= k)\n                {\n\n                    M = mid;\n                    if (mid == 0)\n                    {\n                        break;   //\xe9\x98\xb2\xe6\xad\xa2\xe6\xba\xa2\xe5\x87\xba\n                    }\n                    high = mid - 1;\n                }\n                else\n                    low = mid + 1;\n            }\n            return M;\n        }\n\n        /// <summary>\n        /// \xe5\x8f\xaa\xe8\x8e\xb7\xe5\x8f\x96\xe7\xbb\x93\xe6\x9d\x9fip\xe7\x9a\x84\xe6\x95\xb0\xe5\x80\xbc\n        /// </summary>\n        /// <param name="left">\xe7\xb4\xa2\xe5\xbc\x95\xe5\x8c\xba\xe7\xac\xacleft\xe4\xb8\xaa\xe7\xb4\xa2\xe5\xbc\x95</param>\n        /// <returns>\xe8\xbf\x94\xe5\x9b\x9e\xe7\xbb\x93\xe6\x9d\x9fip\xe7\x9a\x84\xe6\x95\xb0\xe5\x80\xbc</returns>\n        private long GetEndIp(long left)\n        {\n            long offset = 12 + prefCount * 10 + (left * 13);\n            return Bytes2Long(data, 4 + offset, 4);\n\n        }\n\n\n        private uint IpToInt(string ip, out int prefix)\n        {\n            byte[] bytes = IPAddress.Parse(ip).GetAddressBytes();\n            prefix = ((int)bytes[0] << 8) + (int)bytes[1];\n            return (uint)bytes[3] + (((uint)bytes[2]) << 8) + (((uint)bytes[1]) << 16) + (((uint)bytes[0]) << 24);\n        }\n\n\n\n\n        private long Bytes2Long(byte[] buffer, long offset, int count)\n        {\n            long r = 0;\n\n            for (int i = 0; i < count; i++)\n            {\n                r |= (long)buffer[offset + i] << i * 8;\n            }\n\n            return r;\n        }\n\n\n    }\n\n    /*\n    \xef\xbc\x88\xe8\xb0\x83\xe7\x94\xa8\xe4\xbe\x8b\xe5\xad\x90\xef\xbc\x89\xef\xbc\x9a\n    IPSearch2Big finder = new IPSearch2Big("qqzeng-ip-big-2.0.dat");\n    string result = finder.Query("1.2.3.4");\n   --> result="\xe4\xba\x9a\xe6\xb4\xb2|\xe4\xb8\xad\xe5\x9b\xbd|\xe9\xa6\x99\xe6\xb8\xaf|\xe4\xb9\x9d\xe9\xbe\x99|\xe6\xb2\xb9\xe5\xb0\x96\xe6\x97\xba|\xe6\x96\xb0\xe4\xb8\x96\xe7\x95\x8c\xe7\x94\xb5\xe8\xae\xaf|810200|Hong Kong|HK|114.17495|22.327115"\n    */\n}\n\n'