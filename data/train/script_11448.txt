b'\xef\xbb\xbf// \xe5\x85\xab\xe6\x95\xb0\xe7\xa0\x81\xef\xbc\x8c\xe4\xbd\xbf\xe7\x94\xa8\xe5\x85\xa8\xe6\x8e\x92\xe5\x88\x97\xe7\x9a\x84\xe7\xbc\x96\xe7\xa0\x81/\xe8\xa7\xa3\xe7\xa0\x81\xef\xbc\x88\xe6\x9c\x80\xe9\xab\x98\xe6\x95\x88\xef\xbc\x89\n// Rujia Liu\n\n#include<cstdio>\n#include<cstring>\n#include<set>\nusing namespace std;\n\ntypedef int State[9];\nconst int MAXSTATE = 1000000;\nState st[MAXSTATE], goal;\nint dist[MAXSTATE];\n\nint vis[362880], fact[9];\nvoid init_lookup_table() {\n  fact[0] = 1;\n  for(int i = 1; i < 9; i++) fact[i] = fact[i-1] * i;\n}\nint try_to_insert(int s) {\n  int code = 0;\n  for(int i = 0; i < 9; i++) {\n    int cnt = 0;\n    for(int j = i+1; j < 9; j++) if(st[s][j] < st[s][i]) cnt++;\n    code += fact[8-i] * cnt;\n  }\n  if(vis[code]) return 0;\n  return vis[code] = 1;\n}\n\nconst int dx[] = {-1, 1, 0, 0};\nconst int dy[] = {0, 0, -1, 1};\nint bfs() {\n  init_lookup_table();\n  int front = 1, rear = 2;\n  while(front < rear) {\n    State& s = st[front];\n    if(memcmp(goal, s, sizeof(s)) == 0) return front;\n    int z;\n    for(z = 0; z < 9; z++) if(!s[z]) break;\n    int x = z/3, y = z%3;\n    for(int d = 0; d < 4; d++) {\n      int newx = x + dx[d];\n      int newy = y + dy[d];\n      int newz = newx * 3 + newy;\n      if(newx >= 0 && newx < 3 && newy >= 0 && newy < 3) {\n        State& t = st[rear];\n        memcpy(&t, &s, sizeof(s));\n        t[newz] = s[z];\n        t[z] = s[newz];\n        dist[rear] = dist[front] + 1;\n        if(try_to_insert(rear)) rear++;\n      }\n    }\n    front++;\n  }\n  return 0;\n}\n\nint main() {\n  for(int i = 0; i < 9; i++)\n    scanf("%d", &st[1][i]);\n  for(int i = 0; i < 9; i++)\n    scanf("%d", &goal[i]);\n  int ans = bfs();\n  if(ans > 0) printf("%d\\n", dist[ans]);\n  else printf("-1\\n");\n  return 0;\n}\n'