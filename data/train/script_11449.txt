b'using System;\nusing System.Diagnostics;\nusing System.Text;\n\nusing i16 = System.Int16;\nusing u8 = System.Byte;\nusing u16 = System.UInt16;\n\nnamespace CS_SQLite3\n{\n  using sqlite3_value = CSSQLite.Mem;\n\n  public partial class CSSQLite\n  {\n    /*\n    ** 2005 May 23\n    **\n    ** The author disclaims copyright to this source code.  In place of\n    ** a legal notice, here is a blessing:\n    **\n    **    May you do good and not evil.\n    **    May you find forgiveness for yourself and forgive others.\n    **    May you share freely, never taking more than you give.\n    **\n    *************************************************************************\n    **\n    ** This file contains functions used to access the internal hash tables\n    ** of user defined functions and collation sequences.\n    **\n    ** $Id: callback.c,v 1.42 2009/06/17 00:35:31 drh Exp $\n    **\n    *************************************************************************\n    **  Included in SQLite3 port to C#-SQLite;  2008 Noah B Hart\n    **  C#-SQLite is an independent reimplementation of the SQLite software library\n    **\n    **  $Header$\n    *************************************************************************\n    */\n\n    //#include "sqliteInt.h"\n\n    /*\n    ** Invoke the \'collation needed\' callback to request a collation sequence\n    ** in the database text encoding of name zName, length nName.\n    ** If the collation sequence\n    */\n    static void callCollNeeded( sqlite3 db, string zName )\n    {\n      Debug.Assert( db.xCollNeeded == null || db.xCollNeeded16 == null );\n      if ( db.xCollNeeded != null )\n      {\n        string zExternal = zName;// sqlite3DbStrDup(db, zName);\n        if ( zExternal == null ) return;\n        db.xCollNeeded( db.pCollNeededArg, db, db.aDb[0].pSchema.enc, zExternal );//(int)ENC(db), zExternal);\n        //sqlite3DbFree( db, ref  zExternal );\n      }\n#if !SQLITE_OMIT_UTF16\nif( db.xCollNeeded16!=null ){\nstring zExternal;\nsqlite3_value pTmp = sqlite3ValueNew(db);\nsqlite3ValueSetStr(pTmp, -1, zName, SQLITE_UTF8, SQLITE_STATIC);\nzExternal = sqlite3ValueText(pTmp, SQLITE_UTF16NATIVE);\nif( zExternal!="" ){\ndb.xCollNeeded16( db.pCollNeededArg, db, db.aDbStatic[0].pSchema.enc, zExternal );//(int)ENC(db), zExternal);\n}\nsqlite3ValueFree(ref pTmp);\n}\n#endif\n    }\n\n    /*\n    ** This routine is called if the collation factory fails to deliver a\n    ** collation function in the best encoding but there may be other versions\n    ** of this collation function (for other text encodings) available. Use one\n    ** of these instead if they exist. Avoid a UTF-8 <. UTF-16 conversion if\n    ** possible.\n    */\n    static int synthCollSeq( sqlite3 db, CollSeq pColl )\n    {\n      CollSeq pColl2;\n      string z = pColl.zName;\n      int i;\n      byte[] aEnc = { SQLITE_UTF16BE, SQLITE_UTF16LE, SQLITE_UTF8 };\n      for ( i = 0 ; i < 3 ; i++ )\n      {\n        pColl2 = sqlite3FindCollSeq( db, aEnc[i], z, 0 );\n        if ( pColl2.xCmp != null )\n        {\n          pColl = pColl2.Copy(); //memcpy(pColl, pColl2, sizeof(CollSeq));\n          pColl.xDel = null;         /* Do not copy the destructor */\n          return SQLITE_OK;\n        }\n      }\n      return SQLITE_ERROR;\n    }\n\n    /*\n    ** This function is responsible for invoking the collation factory callback\n    ** or substituting a collation sequence of a different encoding when the\n    ** requested collation sequence is not available in the database native\n    ** encoding.\n    **\n    ** If it is not NULL, then pColl must point to the database native encoding\n    ** collation sequence with name zName, length nName.\n    **\n    ** The return value is either the collation sequence to be used in database\n    ** db for collation type name zName, length nName, or NULL, if no collation\n    ** sequence can be found.\n    **\n    ** See also: sqlite3LocateCollSeq(), sqlite3FindCollSeq()\n    */\n    static CollSeq sqlite3GetCollSeq(\n    sqlite3 db,         /* The database connection */\n    CollSeq pColl,      /* Collating sequence with native encoding, or NULL */\n    string zName        /* Collating sequence name */\n    )\n    {\n      CollSeq p;\n\n      p = pColl;\n      if ( p == null )\n      {\n        p = sqlite3FindCollSeq( db, ENC( db ), zName, 0 );\n      }\n      if ( p == null || p.xCmp == null )\n      {\n        /* No collation sequence of this type for this encoding is registered.\n        ** Call the collation factory to see if it can supply us with one.\n        */\n        callCollNeeded( db, zName );\n        p = sqlite3FindCollSeq( db, ENC( db ), zName, 0 );\n      }\n      if ( p != null && p.xCmp == null && synthCollSeq( db, p ) != 0 )\n      {\n        p = null;\n      }\n      Debug.Assert( p == null || p.xCmp != null );\n      return p;\n    }\n\n    /*\n    ** This routine is called on a collation sequence before it is used to\n    ** check that it is defined. An undefined collation sequence exists when\n    ** a database is loaded that contains references to collation sequences\n    ** that have not been defined by sqlite3_create_collation() etc.\n    **\n    ** If required, this routine calls the \'collation needed\' callback to\n    ** request a definition of the collating sequence. If this doesn\'t work,\n    ** an equivalent collating sequence that uses a text encoding different\n    ** from the main database is substituted, if one is available.\n    */\n    static int sqlite3CheckCollSeq( Parse pParse, CollSeq pColl )\n    {\n      if ( pColl != null )\n      {\n        string zName = pColl.zName;\n        CollSeq p = sqlite3GetCollSeq( pParse.db, pColl, zName );\n        if ( null == p )\n        {\n          sqlite3ErrorMsg( pParse, "no such collation sequence: %s", zName );\n          pParse.nErr++;\n          return SQLITE_ERROR;\n        }\n//\n        //Debug.Assert(p == pColl);\n        if (p != pColl) // Had to lookup appropriate sequence\n        {\n          pColl.enc = p.enc;\n          pColl.pUser= p.pUser;\n          pColl.type = p.type;\n          pColl.xCmp = p.xCmp;\n          pColl.xDel = p.xDel;\n        } \n\n      }\n      return SQLITE_OK;\n    }\n\n\n\n    /*\n    ** Locate and return an entry from the db.aCollSeq hash table. If the entry\n    ** specified by zName and nName is not found and parameter \'create\' is\n    ** true, then create a new entry. Otherwise return NULL.\n    **\n    ** Each pointer stored in the sqlite3.aCollSeq hash table contains an\n    ** array of three CollSeq structures. The first is the collation sequence\n    ** prefferred for UTF-8, the second UTF-16le, and the third UTF-16be.\n    **\n    ** Stored immediately after the three collation sequences is a copy of\n    ** the collation sequence name. A pointer to this string is stored in\n    ** each collation sequence structure.\n    */\n    static CollSeq[] findCollSeqEntry(\n    sqlite3 db,         /* Database connection */\n    string zName,       /* Name of the collating sequence */\n    int create          /* Create a new entry if true */\n    )\n    {\n      CollSeq[] pColl;\n      int nName = sqlite3Strlen30( zName );\n      pColl = (CollSeq[])sqlite3HashFind( db.aCollSeq, zName, nName );\n\n      if ( ( null == pColl ) && create != 0 )\n      {\n        pColl = new CollSeq[3]; //sqlite3DbMallocZero(db, 3*sizeof(*pColl) + nName + 1 );\n        if ( pColl != null )\n        {\n          CollSeq pDel = null;\n          pColl[0] = new CollSeq();\n          pColl[0].zName = zName;\n          pColl[0].enc = SQLITE_UTF8;\n          pColl[1] = new CollSeq();\n          pColl[1].zName = zName;\n          pColl[1].enc = SQLITE_UTF16LE;\n          pColl[2] = new CollSeq();\n          pColl[2].zName = zName;\n          pColl[2].enc = SQLITE_UTF16BE;\n          //memcpy(pColl[0].zName, zName, nName);\n          //pColl[0].zName[nName] = 0;\n          pDel = (CollSeq)sqlite3HashInsert( ref db.aCollSeq, pColl[0].zName, nName, pColl );\n\n          /* If a malloc() failure occurred in sqlite3HashInsert(), it will\n          ** return the pColl pointer to be deleted (because it wasn\'t added\n          ** to the hash table).\n          */\n          Debug.Assert( pDel == null || pDel == pColl[0] );\n          if ( pDel != null )\n          {\n    ////        db.mallocFailed = 1;\n            pDel = null; //was  //sqlite3DbFree(db,ref  pDel);\n            pColl = null;\n          }\n        }\n      }\n      return pColl;\n    }\n\n    /*\n    ** Parameter zName points to a UTF-8 encoded string nName bytes long.\n    ** Return the CollSeq* pointer for the collation sequence named zName\n    ** for the encoding \'enc\' from the database \'db\'.\n    **\n    ** If the entry specified is not found and \'create\' is true, then create a\n    ** new entry.  Otherwise return NULL.\n    **\n    ** A separate function sqlite3LocateCollSeq() is a wrapper around\n    ** this routine.  sqlite3LocateCollSeq() invokes the collation factory\n    ** if necessary and generates an error message if the collating sequence\n    ** cannot be found.\n    **\n    ** See also: sqlite3LocateCollSeq(), sqlite3GetCollSeq()\n    */\n    static CollSeq sqlite3FindCollSeq(\n    sqlite3 db,\n    u8 enc,\n    string zName,\n    u8 create\n    )\n    {\n      CollSeq[] pColl;\n      if ( zName != null )\n      {\n        pColl = findCollSeqEntry( db, zName, create );\n      }\n      else\n      {\n        pColl = new CollSeq[enc];\n        pColl[enc - 1] = db.pDfltColl;\n      }\n      Debug.Assert( SQLITE_UTF8 == 1 && SQLITE_UTF16LE == 2 && SQLITE_UTF16BE == 3 );\n      Debug.Assert( enc >= SQLITE_UTF8 && enc <= SQLITE_UTF16BE );\n      if ( pColl != null )\n      {\n        enc -= 1; // if (pColl != null) pColl += enc - 1;\n        return pColl[enc];\n      }\n      else return null;\n    }\n\n    /* During the search for the best function definition, this procedure\n    ** is called to test how well the function passed as the first argument\n    ** matches the request for a function with nArg arguments in a system\n    ** that uses encoding enc. The value returned indicates how well the\n    ** request is matched. A higher value indicates a better match.\n    **\n    ** The returned value is always between 0 and 6, as follows:\n    **\n    ** 0: Not a match, or if nArg<0 and the function is has no implementation.\n    ** 1: A variable arguments function that prefers UTF-8 when a UTF-16\n    **    encoding is requested, or vice versa.\n    ** 2: A variable arguments function that uses UTF-16BE when UTF-16LE is\n    **    requested, or vice versa.\n    ** 3: A variable arguments function using the same text encoding.\n    ** 4: A function with the exact number of arguments requested that\n    **    prefers UTF-8 when a UTF-16 encoding is requested, or vice versa.\n    ** 5: A function with the exact number of arguments requested that\n    **    prefers UTF-16LE when UTF-16BE is requested, or vice versa.\n    ** 6: An exact match.\n    **\n    */\n    static int matchQuality( FuncDef p, int nArg, int enc )\n    {\n      int match = 0;\n      if ( p.nArg == -1 || p.nArg == nArg\n      || ( nArg == -1 && ( p.xFunc != null || p.xStep != null ) )\n      )\n      {\n        match = 1;\n        if ( p.nArg == nArg || nArg == -1 )\n        {\n          match = 4;\n        }\n        if ( enc == p.iPrefEnc )\n        {\n          match += 2;\n        }\n        else if ( ( enc == SQLITE_UTF16LE && p.iPrefEnc == SQLITE_UTF16BE ) ||\n        ( enc == SQLITE_UTF16BE && p.iPrefEnc == SQLITE_UTF16LE ) )\n        {\n          match += 1;\n        }\n      }\n      return match;\n    }\n\n    /*\n    ** Search a FuncDefHash for a function with the given name.  Return\n    ** a pointer to the matching FuncDef if found, or 0 if there is no match.\n    */\n    static FuncDef functionSearch(\n    FuncDefHash pHash,  /* Hash table to search */\n    int h,              /* Hash of the name */\n    string zFunc,       /* Name of function */\n    int nFunc           /* Number of bytes in zFunc */\n    )\n    {\n      FuncDef p;\n      for ( p = pHash.a[h] ; p != null ; p = p.pHash )\n      {\n        if ( sqlite3StrNICmp( p.zName, zFunc, nFunc ) == 0 && p.zName.Length == nFunc )\n        {\n          return p;\n        }\n      }\n      return null;\n    }\n\n    /*\n    ** Insert a new FuncDef into a FuncDefHash hash table.\n    */\n    static void sqlite3FuncDefInsert(\n    FuncDefHash pHash,  /* The hash table into which to insert */\n    FuncDef pDef        /* The function definition to insert */\n    )\n    {\n      FuncDef pOther;\n      int nName = sqlite3Strlen30( pDef.zName );\n      u8 c1 = (u8)pDef.zName[0];\n      int h = ( sqlite3UpperToLower[c1] + nName ) % ArraySize( pHash.a );\n      pOther = functionSearch( pHash, h, pDef.zName, nName );\n      if ( pOther != null )\n      {\n        Debug.Assert( pOther != pDef && pOther.pNext != pDef );\n        pDef.pNext = pOther.pNext;\n        pOther.pNext = pDef;\n      }\n      else\n      {\n        pDef.pNext = null;\n        pDef.pHash = pHash.a[h];\n        pHash.a[h] = pDef;\n      }\n    }\n\n    /*\n    ** Locate a user function given a name, a number of arguments and a flag\n    ** indicating whether the function prefers UTF-16 over UTF-8.  Return a\n    ** pointer to the FuncDef structure that defines that function, or return\n    ** NULL if the function does not exist.\n    **\n    ** If the createFlag argument is true, then a new (blank) FuncDef\n    ** structure is created and liked into the "db" structure if a\n    ** no matching function previously existed.  When createFlag is true\n    ** and the nArg parameter is -1, then only a function that accepts\n    ** any number of arguments will be returned.\n    **\n    ** If createFlag is false and nArg is -1, then the first valid\n    ** function found is returned.  A function is valid if either xFunc\n    ** or xStep is non-zero.\n    **\n    ** If createFlag is false, then a function with the required name and\n    ** number of arguments may be returned even if the eTextRep flag does not\n    ** match that requested.\n    */\n\n    static FuncDef sqlite3FindFunction(\n    sqlite3 db,           /* An open database */\n    string zName,         /* Name of the function.  Not null-terminated */\n    int nName,            /* Number of characters in the name */\n    int nArg,             /* Number of arguments.  -1 means any number */\n    u8 enc,              /* Preferred text encoding */\n    u8 createFlag       /* Create new entry if true and does not otherwise exist */\n    )\n    {\n      FuncDef p;            /* Iterator variable */\n      FuncDef pBest = null; /* Best match found so far */\n      int bestScore = 0;\n      int h;              /* Hash value */\n\n      Debug.Assert( enc == SQLITE_UTF8 || enc == SQLITE_UTF16LE || enc == SQLITE_UTF16BE );\n      h = ( sqlite3UpperToLower[(u8)zName[0]] + nName ) % ArraySize( db.aFunc.a );\n\n\n      /* First search for a match amongst the application-defined functions.\n      */\n      p = functionSearch( db.aFunc, h, zName, nName );\n      while ( p != null )\n      {\n        int score = matchQuality( p, nArg, enc );\n        if ( score > bestScore )\n        {\n          pBest = p;\n          bestScore = score;\n\n        }\n        p = p.pNext;\n      }\n\n\n      /* If no match is found, search the built-in functions.\n      **\n      ** Except, if createFlag is true, that means that we are trying to\n      ** install a new function.  Whatever FuncDef structure is returned will\n      ** have fields overwritten with new information appropriate for the\n      ** new function.  But the FuncDefs for built-in functions are read-only.\n      ** So we must not search for built-ins when creating a new function.\n      */\n      if ( 0 == createFlag && pBest == null )\n      {\n#if SQLITE_OMIT_WSD\nFuncDefHash pHash = GLOBAL( FuncDefHash, sqlite3GlobalFunctions );\n#else\n        FuncDefHash pHash = sqlite3GlobalFunctions;\n#endif\n        p = functionSearch( pHash, h, zName, nName );\n        while ( p != null )\n        {\n          int score = matchQuality( p, nArg, enc );\n          if ( score > bestScore )\n          {\n            pBest = p;\n            bestScore = score;\n          }\n          p = p.pNext;\n        }\n      }\n\n      /* If the createFlag parameter is true and the search did not reveal an\n      ** exact match for the name, number of arguments and encoding, then add a\n      ** new entry to the hash table and return it.\n      */\n      if ( createFlag != 0 && ( bestScore < 6 || pBest.nArg != nArg ) &&\n      ( pBest = new FuncDef() ) != null )\n      { //sqlite3DbMallocZero(db, sizeof(*pBest)+nName+1))!=0 ){\n        //pBest.zName = (char *)&pBest[1];\n        pBest.nArg = (i16)nArg;\n        pBest.iPrefEnc = enc;\n        pBest.zName = zName; //memcpy(pBest.zName, zName, nName);\n        //pBest.zName[nName] = 0;\n        sqlite3FuncDefInsert( db.aFunc, pBest );\n      }\n\n      if ( pBest != null && ( pBest.xStep != null || pBest.xFunc != null || createFlag != 0 ) )\n      {\n        return pBest;\n      }\n      return null;\n    }\n\n    /*\n    ** Free all resources held by the schema structure. The void* argument points\n    ** at a Schema struct. This function does not call //sqlite3DbFree(db, ) on the\n    ** pointer itself, it just cleans up subsiduary resources (i.e. the contents\n    ** of the schema hash tables).\n    **\n    ** The Schema.cache_size variable is not cleared.\n    */\n    static void sqlite3SchemaFree( Schema p )\n    {\n      Hash temp1;\n      Hash temp2;\n      HashElem pElem;\n      Schema pSchema = p;\n\n      temp1 = pSchema.tblHash;\n      temp2 = pSchema.trigHash;\n      sqlite3HashInit( pSchema.trigHash );\n      sqlite3HashClear( pSchema.idxHash );\n      for ( pElem = sqliteHashFirst( temp2 ) ; pElem != null ; pElem = sqliteHashNext( pElem ) )\n      {\n        Trigger pTrigger = (Trigger)sqliteHashData( pElem );\n        sqlite3DeleteTrigger( null, ref pTrigger );\n      }\n      sqlite3HashClear( temp2 );\n      sqlite3HashInit( pSchema.trigHash );\n      for ( pElem = temp1.first ; pElem != null ; pElem = pElem.next )//sqliteHashFirst(&temp1); pElem; pElem = sqliteHashNext(pElem))\n      {\n        Table pTab = (Table)pElem.data; //sqliteHashData(pElem);\n        Debug.Assert( pTab.dbMem == null );\n        sqlite3DeleteTable( ref pTab );\n      }\n      sqlite3HashClear( temp1 );\n      pSchema.pSeqTab = null;\n      pSchema.flags = (u16)( pSchema.flags & ~DB_SchemaLoaded );\n    }\n\n    /*\n    ** Find and return the schema associated with a BTree.  Create\n    ** a new one if necessary.\n    */\n    static Schema sqlite3SchemaGet( sqlite3 db, Btree pBt )\n    {\n      Schema p;\n      if ( pBt != null )\n      {\n        p = sqlite3BtreeSchema( pBt, -1, (dxFreeSchema)sqlite3SchemaFree );//Schema.Length, sqlite3SchemaFree);\n      }\n      else\n      {\n        p = new Schema(); // (Schema*)sqlite3MallocZero(Schema).Length;\n      }\n      if ( p == null )\n      {\n////        db.mallocFailed = 1;\n      }\n      else if ( 0 == p.file_format )\n      {\n        sqlite3HashInit( p.tblHash );\n        sqlite3HashInit( p.idxHash );\n        sqlite3HashInit( p.trigHash );\n        p.enc = SQLITE_UTF8;\n      }\n      return p;\n    }\n  }\n}\n'