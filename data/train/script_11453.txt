b'using System;\nusing System.IO;\nusing System.Text;\nusing System.Threading;\n\nnamespace qqzeng_ip_dat\n{\n\n    /*\n\n    \xe9\xab\x98\xe6\x80\xa7\xe8\x83\xbdIP\xe6\x95\xb0\xe6\x8d\xae\xe5\xba\x93\xe6\xa0\xbc\xe5\xbc\x8f\xe8\xaf\xa6\xe8\xa7\xa3 qqzeng-ip.dat 2.0\xe7\x89\x88 \xe6\xaf\x8f\xe7\xa7\x92\xe8\xa7\xa3\xe6\x9e\x90900\xe5\xa4\x9a\xe4\xb8\x87ip\n    \n    \xe7\xbc\x96\xe7\xa0\x81\xef\xbc\x9aUTF8  \xe5\xad\x97\xe8\x8a\x82\xe5\xba\x8f\xef\xbc\x9aLittle-Endian  \n\n    \xe8\xbf\x94\xe5\x9b\x9e\xe5\xa4\x9a\xe4\xb8\xaa\xe5\xad\x97\xe6\xae\xb5\xe4\xbf\xa1\xe6\x81\xaf\xef\xbc\x88\xe5\xa6\x82\xef\xbc\x9a\xe4\xba\x9a\xe6\xb4\xb2|\xe4\xb8\xad\xe5\x9b\xbd|\xe9\xa6\x99\xe6\xb8\xaf|\xe4\xb9\x9d\xe9\xbe\x99|\xe6\xb2\xb9\xe5\xb0\x96\xe6\x97\xba|\xe6\x96\xb0\xe4\xb8\x96\xe7\x95\x8c\xe7\x94\xb5\xe8\xae\xaf|810200|Hong Kong|HK|114.17495|22.327115\xef\xbc\x89\n    \n    ------------------------ \xe6\x96\x87\xe4\xbb\xb6\xe7\xbb\x93\xe6\x9e\x84 2.0  -------------------------\n\n    //\xe6\x96\x87\xe4\xbb\xb6\xe5\xa4\xb4    16\xe5\xad\x97\xe8\x8a\x82(4-4-4-4)\n    [\xe7\xb4\xa2\xe5\xbc\x95\xe5\x8c\xba\xe7\xac\xac\xe4\xb8\x80\xe6\x9d\xa1\xe6\xb5\x81\xe4\xbd\x8d\xe7\xbd\xae][\xe7\xb4\xa2\xe5\xbc\x95\xe5\x8c\xba\xe6\x9c\x80\xe5\x90\x8e\xe4\xb8\x80\xe6\x9d\xa1\xe6\xb5\x81\xe4\xbd\x8d\xe7\xbd\xae][\xe5\x89\x8d\xe7\xbc\x80\xe5\x8c\xba\xe7\xac\xac\xe4\xb8\x80\xe6\x9d\xa1\xe7\x9a\x84\xe6\xb5\x81\xe4\xbd\x8d\xe7\xbd\xae][\xe5\x89\x8d\xe7\xbc\x80\xe5\x8c\xba\xe6\x9c\x80\xe5\x90\x8e\xe4\xb8\x80\xe6\x9d\xa1\xe7\x9a\x84\xe6\xb5\x81\xe4\xbd\x8d\xe7\xbd\xae] \n\n    //\xe5\x86\x85\xe5\xae\xb9\xe5\x8c\xba    \xe9\x95\xbf\xe5\xba\xa6\xe6\x97\xa0\xe9\x99\x90\xe5\x88\xb6\n    [\xe5\x9c\xb0\xe5\x8c\xba\xe4\xbf\xa1\xe6\x81\xaf][\xe5\x9c\xb0\xe5\x8c\xba\xe4\xbf\xa1\xe6\x81\xaf]\xe2\x80\xa6\xe2\x80\xa6\xe5\x94\xaf\xe4\xb8\x80\xe4\xb8\x8d\xe9\x87\x8d\xe5\xa4\x8d\n\n\n    //\xe7\xb4\xa2\xe5\xbc\x95\xe5\x8c\xba    12\xe5\xad\x97\xe8\x8a\x82(4-4-3-1)\n    [\xe8\xb5\xb7\xe5\xa7\x8bIP][\xe7\xbb\x93\xe6\x9d\x9fIP][\xe5\x9c\xb0\xe5\x8c\xba\xe6\xb5\x81\xe4\xbd\x8d\xe7\xbd\xae][\xe6\xb5\x81\xe9\x95\xbf\xe5\xba\xa6]\n\n\n    //\xe5\x89\x8d\xe7\xbc\x80\xe5\x8c\xba   9\xe5\xad\x97\xe8\x8a\x82(1-4-4)\n    [0-255][\xe7\xb4\xa2\xe5\xbc\x95\xe5\x8c\xbastart\xe7\xb4\xa2\xe5\xbc\x95][\xe7\xb4\xa2\xe5\xbc\x95\xe5\x8c\xbaend\xe7\xb4\xa2\xe5\xbc\x95]\n\n    ------------------------ \xe6\x96\x87\xe4\xbb\xb6\xe7\xbb\x93\xe6\x9e\x84 ---------------------------\n\n    \xe4\xbc\x98\xe5\x8a\xbf\xef\xbc\x9a\xe7\xb4\xa2\xe5\xbc\x95\xe5\x8c\xba\xe5\x88\x86\xe4\xb8\xba[\xe8\xb5\xb7\xe5\xa7\x8bIP][\xe7\xbb\x93\xe6\x9d\x9fIP][\xe5\x9c\xb0\xe5\x8c\xba\xe5\x81\x8f\xe7\xa7\xbb][\xe9\x95\xbf\xe5\xba\xa6],\xe5\x87\x8f\xe5\xb0\x91\xe5\xa4\x9a\xe7\xba\xa7\xe5\x81\x8f\xe7\xa7\xbb\xe8\xb7\xb3\xe8\xbd\xac\xe6\xad\xa5\xe9\xaa\xa4\xe5\x92\x8c\xe9\x95\xbf\xe5\xba\xa6\xe7\x9a\x84\xe8\xa7\xa3\xe6\x9e\x90,\xe6\x8f\x90\xe9\xab\x98\xe6\x95\x88\xe7\x8e\x87;\n         \xe6\xa0\xb9\xe6\x8d\xaeip\xe7\xac\xac\xe4\xb8\x80\xe4\xbd\x8d\xe6\x95\xb0\xe5\xad\x97\xe4\xbd\x9c\xe4\xb8\xba\xe5\x89\x8d\xe7\xbc\x80,\xe8\xa7\xa3\xe6\x9e\x90\xe5\x87\xba\xe4\xbb\xa5\xe8\xbf\x99\xe4\xb8\xaa\xe6\x95\xb0\xe5\xad\x97\xe4\xb8\xba\xe5\x89\x8d\xe7\xbc\x80\xe7\x9a\x84\xe7\xac\xac\xe4\xb8\x80\xe4\xb8\xaa\xe7\xb4\xa2\xe5\xbc\x95\xe5\x92\x8c\xe6\x9c\x80\xe5\x90\x8e\xe4\xb8\x80\xe4\xb8\xaa\xe7\xb4\xa2\xe5\xbc\x95,\xe7\xbc\xa9\xe5\xb0\x8f\xe6\x9f\xa5\xe8\xaf\xa2\xe5\x8c\xba\xe9\x97\xb4,\n         \xe7\x84\xb6\xe5\x90\x8e\xe5\x9c\xa8\xe8\xbf\x99\xe5\x8c\xba\xe9\x97\xb4\xe5\x86\x8d\xe7\x94\xa8\xe4\xba\x8c\xe5\x88\x86\xe6\x9f\xa5\xe6\x89\xbe\xe5\xbf\xab\xe9\x80\x9f\xe6\x9f\xa5\xe6\x89\xbe\xe5\x88\xb0\xe5\xaf\xb9\xe5\xba\x94\xe5\x8c\xba\xe9\x97\xb4,\xe6\x95\x88\xe7\x8e\x87\xe6\x8f\x90\xe9\xab\x98\xe5\x87\xa0\xe4\xb8\xaa\xe7\xad\x89\xe7\xba\xa7    \n\n    \xe5\x8e\x8b\xe7\xbc\xa9\xef\xbc\x9a\xe5\x8e\x9f\xe7\x89\x88txt\xe4\xb8\xba38M,\xe7\x94\x9f\xe6\x88\x90\xe8\xbf\x99\xe7\xa7\x8ddat\xe7\xbb\x93\xe6\x9e\x84\xe4\xb8\xba5.16M \n\n    \xe6\x80\xa7\xe8\x83\xbd\xef\xbc\x9a\xe6\xaf\x8f\xe7\xa7\x92\xe8\xa7\xa3\xe6\x9e\x90900\xe5\xa4\x9a\xe4\xb8\x87 (\xe7\x8e\xaf\xe5\xa2\x83\xef\xbc\x9aCPU i7-7700K  + DDR2400 16G  + win10 X64)\n\n    \xe5\xaf\xb9\xe6\xaf\x94\xef\xbc\x9a\xe7\x9b\xb8\xe6\xaf\x94\xe5\x85\xb6\xe4\xbb\x96dat\xe6\x9b\xb4\xe7\xae\x80\xe6\xb4\x81\xe6\x9b\xb4\xe9\xab\x98\xe6\x95\x88\n\n    \xe5\x88\x9b\xe5\xbb\xba\xef\xbc\x9aqqzeng-ip \xe4\xba\x8e 2015-08-01 \n    \n    \xe4\xbc\x98\xe5\x8c\x96\xef\xbc\x9aqqzeng-ip \xe4\xba\x8e 2018-04-08 \n\n    */\n\n    public class IPSearch2Fast\n    {\n        private static readonly Lazy<IPSearch2Fast> lazy = new Lazy<IPSearch2Fast>(() => new IPSearch2Fast());\n        public static IPSearch2Fast Instance { get { return lazy.Value; } }\n        private IPSearch2Fast()\n        {\n            LoadDat();\n            Watch();\n        }\n\n        private string datPath = Path.Combine(AppDomain.CurrentDomain.BaseDirectory, @"qqzeng-ip-utf8.dat");\n        private DateTime lastRead = DateTime.MinValue;\n\n        private long[,] prefmap;\n        private uint[,] ipmap;\n        private string[] addrArr;\n        private byte[] data;\n\n\n        /// <summary>\n        /// \xe5\x88\x9d\xe5\xa7\x8b\xe5\x8c\x96\xe4\xba\x8c\xe8\xbf\x9b\xe5\x88\xb6 qqzeng-ip-utf8.dat \xe6\x95\xb0\xe6\x8d\xae\n        /// </summary>\n        private void LoadDat()\n        {\n            data = File.ReadAllBytes(datPath);\n\n\n            long firstStartIpOffset = BytesToLong(data[0], data[1], data[2], data[3]);//\xe7\xb4\xa2\xe5\xbc\x95\xe5\x8c\xba\xe7\xac\xac\xe4\xb8\x80\xe6\x9d\xa1\xe6\xb5\x81\xe4\xbd\x8d\xe7\xbd\xae\n            long lastStartIpOffset = BytesToLong(data[4], data[5], data[6], data[7]);//\xe7\xb4\xa2\xe5\xbc\x95\xe5\x8c\xba\xe6\x9c\x80\xe5\x90\x8e\xe4\xb8\x80\xe6\x9d\xa1\xe6\xb5\x81\xe4\xbd\x8d\xe7\xbd\xae\n            long prefixStartOffset = BytesToLong(data[8], data[9], data[10], data[11]);//\xe5\x89\x8d\xe7\xbc\x80\xe5\x8c\xba\xe7\xac\xac\xe4\xb8\x80\xe6\x9d\xa1\xe7\x9a\x84\xe6\xb5\x81\xe4\xbd\x8d\xe7\xbd\xae\n            long prefixEndOffset = BytesToLong(data[12], data[13], data[14], data[15]);//\xe5\x89\x8d\xe7\xbc\x80\xe5\x8c\xba\xe6\x9c\x80\xe5\x90\x8e\xe4\xb8\x80\xe6\x9d\xa1\xe7\x9a\x84\xe6\xb5\x81\xe4\xbd\x8d\xe7\xbd\xae\n\n            //prefixCount \xe4\xb8\x8d\xe5\x9b\xba\xe5\xae\x9a\xe4\xb8\xba256 \xe6\x96\xb9\xe4\xbe\xbf\xe4\xbb\xa5\xe5\x90\x8e\xe8\x87\xaa\xe7\x94\xb1\xe5\xae\x9a\xe5\x88\xb6  \xe5\x85\xa8\xe7\x90\x83\xe7\x89\x88 \xe5\x9b\xbd\xe5\x86\x85\xe7\x89\x88  \xe5\x9b\xbd\xe5\xa4\x96\xe7\x89\x88 \xe6\x88\x96\xe8\x80\x85\xe6\x9f\x90\xe9\x83\xa8\xe5\x88\x86 \xe9\x83\xbd\xe5\x8f\xaf\xe4\xbb\xa5\n\n            long ipCount = (lastStartIpOffset - firstStartIpOffset) / 12 + 1; //\xe7\xb4\xa2\xe5\xbc\x95\xe5\x8c\xba\xe5\x9d\x97\xe6\xaf\x8f\xe7\xbb\x84 12\xe5\xad\x97\xe8\x8a\x82     //ip\xe6\xae\xb5\xe6\x95\xb0\xe9\x87\x8f      \n            long prefixCount = (prefixEndOffset - prefixStartOffset) / 9 + 1; //\xe5\x89\x8d\xe7\xbc\x80\xe5\x8c\xba\xe5\x9d\x97\xe6\xaf\x8f\xe7\xbb\x84 9\xe5\xad\x97\xe8\x8a\x82 //\xe5\x89\x8d\xe7\xbc\x80\xe6\x95\xb0\xe9\x87\x8f\n\n            prefmap = new long[256, 2];\n\n            //\xe5\x88\x9d\xe5\xa7\x8b\xe5\x8c\x96\xe5\x89\x8d\xe7\xbc\x80\xe5\xaf\xb9\xe5\xba\x94\xe7\xb4\xa2\xe5\xbc\x95\xe5\x8c\xba\xe5\x8c\xba\xe9\x97\xb4\n            byte[] indexBuffer = new byte[prefixCount * 9];\n            Buffer.BlockCopy(data, (int)prefixStartOffset, indexBuffer, 0, (int)prefixCount * 9);\n            int m = 0;\n            for (var k = 0; k < prefixCount; k++)\n            {\n                int i = k * 9;\n                int n = indexBuffer[i];\n                prefmap[n, 0] = BytesToLong(indexBuffer[i + 1], indexBuffer[i + 2], indexBuffer[i + 3], indexBuffer[i + 4]);\n                prefmap[n, 1] = BytesToLong(indexBuffer[i + 5], indexBuffer[i + 6], indexBuffer[i + 7], indexBuffer[i + 8]);\n                if (m < n)\n                {\n                    for (; m < n; m++)\n                    {\n                        prefmap[m, 0] = 0; prefmap[m, 1] = 0;\n                    }\n                    m++;\n                }\n                else\n                {\n                    m++;\n                }\n            }\n\n            //\xe5\x88\x9d\xe5\xa7\x8b\xe5\x8c\x96 \xe7\xb4\xa2\xe5\xbc\x95\xe5\x8c\xba\xe9\x97\xb4\n            ipmap = new uint[ipCount, 2];\n            addrArr = new string[ipCount];\n            for (int i = 0; i < ipCount; i++)\n            {\n                long p = firstStartIpOffset + (i * 12);\n                uint startip = BytesToLong(data[p], data[1 + p], data[2 + p], data[3 + p]);\n                uint endip = BytesToLong(data[4 + p], data[5 + p], data[6 + p], data[7 + p]);\n                int offset = data[8 + p] + ((data[9 + p]) << 8) + ((data[10 + p]) << 16);\n                int length = data[11 + p];\n\n                ipmap[i, 0] = startip;\n                ipmap[i, 1] = endip;\n                addrArr[i] = Encoding.UTF8.GetString(data, offset, length);\n            }\n\n        }\n\n\n        private void Watch()\n        {\n            FileInfo fi = new FileInfo(datPath);\n            FileSystemWatcher watcher = new FileSystemWatcher(fi.DirectoryName)\n            {\n                IncludeSubdirectories = false,\n                NotifyFilter = NotifyFilters.LastWrite,\n                Filter = "qqzeng-ip-utf8.dat",\n            };\n\n            watcher.Changed += (s, e) =>\n            {\n\n                var lastWriteTime = File.GetLastWriteTime(datPath);\n\n                if (lastWriteTime > lastRead)\n                {\n                    //\xe5\xbb\xb6\xe6\x97\xb6 \xe8\xa7\xa3\xe5\x86\xb3 \xe6\xad\xa3\xe7\x94\xb1\xe5\x8f\xa6\xe4\xb8\x80\xe8\xbf\x9b\xe7\xa8\x8b\xe4\xbd\xbf\xe7\x94\xa8,\xe5\x9b\xa0\xe6\xad\xa4\xe8\xaf\xa5\xe8\xbf\x9b\xe7\xa8\x8b\xe6\x97\xa0\xe6\xb3\x95\xe8\xae\xbf\xe9\x97\xae\xe6\xad\xa4\xe6\x96\x87\xe4\xbb\xb6\n                    Thread.Sleep(1000);\n\n                    LoadDat();\n                    lastRead = lastWriteTime;\n                }\n            };\n            watcher.EnableRaisingEvents = true;\n        }\n\n\n\n        /// <summary>\n        /// ip\xe5\xbf\xab\xe9\x80\x9f\xe6\x9f\xa5\xe8\xaf\xa2\xe6\x96\xb9\xe6\xb3\x95\n        /// </summary>\n        /// <param name="ip">ip\xe5\x9c\xb0\xe5\x9d\x80\xef\xbc\x881.4.5.6\xef\xbc\x89</param>\n        /// <returns>\xe4\xba\x9a\xe6\xb4\xb2|\xe4\xb8\xad\xe5\x9b\xbd|\xe9\xa6\x99\xe6\xb8\xaf|\xe4\xb9\x9d\xe9\xbe\x99|\xe6\xb2\xb9\xe5\xb0\x96\xe6\x97\xba|\xe6\x96\xb0\xe4\xb8\x96\xe7\x95\x8c\xe7\x94\xb5\xe8\xae\xaf|810200|Hong Kong|HK|114.17495|22.327115</returns>\n        public string Query(string ip)\n        {\n            long val = IpToInt(ip, out long pref);\n            long low = prefmap[pref, 0], high = prefmap[pref, 1];\n            if (high == 0)\n            {\n                return "";\n            }\n            long cur = low == high ? low : BinarySearch(low, high, val);\n            if (ipmap[cur, 0] <= val && ipmap[cur, 1] >= val)\n            {\n                return addrArr[cur];\n            }\n            else\n            {\n                return "";\n            }\n\n        }\n\n\n\n        /// <summary>\n        /// \xe4\xba\x8c\xe5\x88\x86\xe9\x80\xbc\xe8\xbf\x91\xe7\xae\x97\xe6\xb3\x95 O(logN)\n        /// </summary>\n        public long BinarySearch(long low, long high, long k)\n        {\n            long M = 0;\n            while (low <= high)\n            {\n                long mid = (low + high) / 2;\n\n                uint endipNum = ipmap[mid, 1];\n                if (endipNum >= k)\n                {\n\n                    M = mid;\n                    if (mid == 0)\n                    {\n                        break;   //\xe9\x98\xb2\xe6\xad\xa2\xe6\xba\xa2\xe5\x87\xba\n                    }\n                    high = mid - 1;\n                }\n                else\n                    low = mid + 1;\n            }\n            return M;\n        }\n\n\n\n\n        /// <summary>\n        /// \xe5\xad\x97\xe8\x8a\x82\xe8\xbd\xac\xe6\x95\xb4\xe5\xbd\xa2 \xe5\xb0\x8f\xe8\x8a\x82\xe5\xba\x8f \n        /// </summary>     \n        private uint BytesToLong(byte a, byte b, byte c, byte d)\n        {\n            return (uint)(a | (b << 8) | (c << 16) | (d << 24));\n        }\n\n\n\n        public static long IpToInt(string ipString, out long prefix)\n        {\n            //\xe6\x9c\x80\xe9\xab\x98\xe6\x80\xa7\xe8\x83\xbd\n            int end = ipString.Length;\n            unsafe\n            {\n                fixed (char* name = ipString)\n                {\n\n                    int numberBase = 10;\n                    char ch;\n                    long[] parts = new long[4];\n                    long currentValue = 0;\n                    int dotCount = 0;\n                    int current = 0;\n                    for (; current < end; current++)\n                    {\n                        ch = name[current];\n                        currentValue = 0;\n\n                        numberBase = 10;\n                        if (ch == \'0\')\n                        {\n                            numberBase = 8;\n                            current++;\n\n                            if (current < end)\n                            {\n                                ch = name[current];\n                                if (ch == \'x\' || ch == \'X\')\n                                {\n                                    numberBase = 16;\n                                    current++;\n                                }\n                            }\n                        }\n\n                        for (; current < end; current++)\n                        {\n                            ch = name[current];\n                            int digitValue;\n\n                            if ((numberBase == 10 || numberBase == 16) && \'0\' <= ch && ch <= \'9\')\n                            {\n                                digitValue = ch - \'0\';\n                            }\n                            else if (numberBase == 8 && \'0\' <= ch && ch <= \'7\')\n                            {\n                                digitValue = ch - \'0\';\n                            }\n                            else if (numberBase == 16 && \'a\' <= ch && ch <= \'f\')\n                            {\n                                digitValue = ch + 10 - \'a\';\n                            }\n                            else if (numberBase == 16 && \'A\' <= ch && ch <= \'F\')\n                            {\n                                digitValue = ch + 10 - \'A\';\n                            }\n                            else\n                            {\n                                break;\n                            }\n\n                            currentValue = (currentValue * numberBase) + digitValue;\n\n                        }\n\n                        if (current < end && name[current] == \'.\')\n                        {\n                            parts[dotCount] = currentValue;\n                            dotCount++;\n                            continue;\n                        }\n                        break;\n                    }\n                    parts[dotCount] = currentValue;\n                    prefix = parts[0];\n                    return (parts[0] << 24) | ((parts[1] & 0xff) << 16) | ((parts[2] & 0xff) << 8) | (parts[3] & 0xff);\n                }\n            }\n\n            //\xe7\xae\x80\xe6\xb4\x81\xe6\x96\xb9\xe6\xb3\x95\n            //byte[] bytes = IPAddress.Parse(ipString).GetAddressBytes();\n            //prefix = bytes[0];\n            //return (uint)(bytes[3] + ((bytes[2]) << 8) + ((bytes[1]) << 16) + ((bytes[0]) << 24));\n        }\n\n\n    }\n\n    /*\n    \xef\xbc\x88\xe8\xb0\x83\xe7\x94\xa8\xe4\xbe\x8b\xe5\xad\x90\xef\xbc\x89\xef\xbc\x9a\n    string result = IPSearch3Fast.Instance.Find("1.2.3.4");\n   --> result="\xe4\xba\x9a\xe6\xb4\xb2|\xe4\xb8\xad\xe5\x9b\xbd|\xe9\xa6\x99\xe6\xb8\xaf|\xe4\xb9\x9d\xe9\xbe\x99|\xe6\xb2\xb9\xe5\xb0\x96\xe6\x97\xba|\xe6\x96\xb0\xe4\xb8\x96\xe7\x95\x8c\xe7\x94\xb5\xe8\xae\xaf|810200|Hong Kong|HK|114.17495|22.327115"\n    */\n}\n'