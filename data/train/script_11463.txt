b'globalVariables(c(\'V2\', \'V3\', \'.\'))\n\n#\' getMatches\n#\'\n#\' Subset two data frames to the matches returned by \\code{fastLink()}\n#\' or \\code{matchesLink()}. Can also return a single deduped data frame\n#\' if dfA and dfB are identical and fl.out is of class \'fastLink.dedupe\'.\n#\'\n#\' @usage getMatches(dfA, dfB, fl.out, threshold.match, combine.dfs)\n#\' @param dfA Dataset A - matched to Dataset B by \\code{fastLink()}.\n#\' @param dfB Dataset B - matches to Dataset A by \\code{fastLink()}.\n#\' @param fl.out Either the output from \\code{fastLink()} or \\code{matchesLink()}.\n#\' @param threshold.match A number between 0 and 1 indicating the lower bound that the\n#\' user wants to declare a match. For instance, threshold.match = .85 will return all pairs with posterior probability greater than .85 as matches.\n#\' Default is 0.85.\n#\' @param combine.dfs Whether to combine the two data frames being merged into a single data frame. If FALSE, two data frames are returned in a list. Default is TRUE.\n#\'\n#\' @return \\code{getMatches()} returns a list of two data frames:\n#\' \\item{dfA.match}{A subset of \\code{dfA} subsetted down to the successful matches.}\n#\' \\item{dfB.match}{A subset of \\code{dfB} subsetted down to the successful matches.}\n#\'\n#\' @author Ben Fifield  <benfifield@gmail.com>\n#\'\n#\' @examples\n#\' \\dontrun{\n#\' fl.out <- fastLink(dfA, dfB,\n#\' varnames = c("firstname", "lastname", "streetname", "birthyear"),\n#\' n.cores = 1)\n#\' ret <- getMatches(dfA, dfB, fl.out)\n#\' }\n#\' @export\ngetMatches <- function(dfA, dfB, fl.out, threshold.match = 0.85, combine.dfs = TRUE){\n\n    ## Convert data frames\n    if(any(class(dfA) %in% c("tbl_df", "data.table"))){\n        dfA <- as.data.frame(dfA)\n    }\n    if(any(class(dfB) %in% c("tbl_df", "data.table"))){\n        dfB <- as.data.frame(dfB)\n    }\n\n    if(inherits(fl.out, "fastLink.dedupe") & !identical(dfA, dfB)){\n        stop("You have provided a fastLink object from deduping a single data frame, but dfA and dfB are not identical. Please check your inputs.")\n    }\n    if(identical(dfA, dfB) & !inherits(fl.out, "fastLink.dedupe")){\n        stop("dfA and dfB are identical, but fl.out is not of class \'fastLink.dedupe.\' Please check your inputs.")\n    }\n\n    ## Depending on class\n    if(inherits(fl.out, "matchesLink")){\n        dfA.match <- dfA[fl.out$inds.a,]\n        dfB.match <- dfB[fl.out$inds.b,]\n        if(combine.dfs){\n            names.dfB <- names(dfB.match)[!(names(dfB.match) %in% names(dfA.match))]\n            if(length(names.dfB) > 0){\n                df.match <- cbind(dfA.match, dfB.match[,names.dfB])\n            }else{\n                df.match <- dfA.match\n            }\n            out <- df.match\n        }else{\n            out <- list(dfA.match = dfA.match, dfB.match = dfB.match)\n        }\n    }else if(inherits(fl.out, "fastLink.dedupe")){\n\n        ## Get ID\n        id_tmp <- data.frame(id = 1:nrow(dfA))\n\n        ## Get matches\n        matches <- data.table(\n            cbind(\n                fl.out$matches$inds.b[fl.out$posterior >= threshold.match],\n                fl.out$matches$inds.a[fl.out$posterior >= threshold.match]\n            )\n        )\n        \n        temp0 <- 1:nrow(dfA)\n        temp1 <- which(!(temp0 %in% matches$V1))\n        \n        if(length(temp1) > 0) {\n            temp2 <- cbind(as.matrix(temp1), as.matrix(temp1))\n            matches <- rbind(matches, temp2)\n        }\n\n        pasteT <- function(x) {\n            x = sort(x) # 1,2,3 is the same as 3,2,1\n            x = paste(x, collapse = ",") \n            x\n        }\n\n        ## Dedupe\n        matches[, V3 := pasteT(V2), by = "V1"]    \n        ans <- matches[, .(id_2 = unique(V3)), by = "V1"]\n        ans$id_2 <- as.numeric(as.factor(ans$id_2))\n        colnames(ans) <- c("id", "id_2")\n\n        ## Merge and output new df\n        out_df <- merge(id_tmp, ans, by = "id")\n        dfA$dedupe.ids <- out_df$id_2\n        out <- dfA\n        \n        \n    }else{\n        dfA.match <- dfA[fl.out$matches$inds.a,]\n        dfB.match <- dfB[fl.out$matches$inds.b,]\n        if(combine.dfs){\n            names.dfB <- names(dfB.match)[!(names(dfB.match) %in% names(dfA.match))]\n            if(length(names.dfB) > 0){\n                df.match <- cbind(dfA.match, dfB.match[,names.dfB])\n            }else{\n                df.match <- dfA.match\n            }\n            df.match <- cbind(df.match, fl.out$patterns)\n            if("posterior" %in% names(fl.out)){\n                df.match$posterior <- fl.out$posterior\n                df.match <- df.match[df.match$posterior >= threshold.match,]\n            }\n            out <- df.match\n        }else{\n            dfA.match <- cbind(dfA.match, fl.out$patterns)\n            dfB.match <- cbind(dfB.match, fl.out$patterns)\n            if("posterior" %in% names(fl.out)){\n                dfA.match$posterior <- fl.out$posterior\n                dfB.match$posterior <- fl.out$posterior\n                dfA.match <- dfA.match[dfA.match$posterior >= threshold.match,]\n                dfB.match <- dfB.match[dfB.match$posterior >= threshold.match,]\n            }\n            out <- list(dfA.match = dfA.match, dfB.match = dfB.match)\n        }\n    }\n\n    return(out)\n    \n}\n\n'