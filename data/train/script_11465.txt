b'#include <stdio.h>\n#include "pico/stdlib.h"\n#include "hardware/i2c.h"\n#ifndef PICO_DEFAULT_LED_PIN // PICO w with WiFi\n#include "pico/cyw43_arch.h"\n#endif\n#include "MPU6050_6Axis_MotionApps_V6_12.h"\n\nMPU6050 mpu;\n\n//#define OUTPUT_READABLE_YAWPITCHROLL\n//#define OUTPUT_READABLE_REALACCEL\n//#define OUTPUT_READABLE_WORLDACCEL\n#define OUTPUT_READABLE_CUSTOM\n\n\nbool dmpReady = false;  // set true if DMP init was successful\nuint8_t mpuIntStatus;   // holds actual interrupt status byte from MPU\nuint8_t devStatus;      // return status after each device operation (0 = success, !0 = error)\nuint16_t packetSize;    // expected DMP packet size (default is 42 bytes)\nuint16_t fifoCount;     // count of all bytes currently in FIFO\nuint8_t fifoBuffer[64]; // FIFO storage buffer\n\nQuaternion q;           // [w, x, y, z]         quaternion container\nVectorInt16 aa;         // [x, y, z]            accel sensor measurements\nVectorInt16 gy;         // [x, y, z]            gyro sensor measurements\nVectorInt16 aaReal;     // [x, y, z]            gravity-free accel sensor measurements\nVectorInt16 aaWorld;    // [x, y, z]            world-frame accel sensor measurements\nVectorFloat gravity;    // [x, y, z]            gravity vector\nfloat euler[3];         // [psi, theta, phi]    Euler angle container\nfloat ypr[3];           // [yaw, pitch, roll]   yaw/pitch/roll container and gravity vector\nfloat yaw, pitch, roll;\n\nvolatile bool mpuInterrupt = false;     // indicates whether MPU interrupt pin has gone high\nvoid dmpDataReady() {\n    mpuInterrupt = true;\n}\n\nvoid initLED() {\n#ifndef PICO_DEFAULT_LED_PIN // PICO w with WiFi\n    printf ("we have board with wifi (pico w) \\n");\n    if (cyw43_arch_init()) {\n        printf("WiFi init failed");\n        exit(3);\n    }\n#else\n    printf ("we have board without wifi\\n");\n    gpio_init(PICO_DEFAULT_LED_PIN);\n    gpio_set_dir(PICO_DEFAULT_LED_PIN, GPIO_OUT);\n#endif // PICO_DEFAULT_LED_PIN\n\n} // initLED()\n\nvoid  waitForUsbConnect() {\n#ifdef _PICO_STDIO_USB_H // We are using PICO_STDIO_USB. Have to wait for connection.\n    \n#ifndef PICO_DEFAULT_LED_PIN\n    while (!stdio_usb_connected()) { // blink the pico\'s led until usb connection is established\n        cyw43_arch_gpio_put(CYW43_WL_GPIO_LED_PIN, 0);\n        sleep_ms(250);\n        cyw43_arch_gpio_put(CYW43_WL_GPIO_LED_PIN, 1);\n        sleep_ms(250);\n    }\n#else\n    while (!stdio_usb_connected()) { // blink the pico\'s led until usb connection is established\n        gpio_put(PICO_DEFAULT_LED_PIN, 0);\n        sleep_ms(250);\n        gpio_put(PICO_DEFAULT_LED_PIN, 1);\n        sleep_ms(250);\n    }\n#endif // PICO_DEFAULT_LED_PIN\n#endif // _PICO_STDIO_USB_H\n} //  waitForUsbConnect\n\nint main() {\n    stdio_init_all();\n    // This example will use I2C0 on the default SDA and SCL (pins 6, 7 on a Pico)\n    i2c_init(i2c_default, 400 * 1000);\n    gpio_set_function(PICO_DEFAULT_I2C_SDA_PIN, GPIO_FUNC_I2C);\n    gpio_set_function(PICO_DEFAULT_I2C_SCL_PIN, GPIO_FUNC_I2C);\n    gpio_pull_up(PICO_DEFAULT_I2C_SDA_PIN);\n    gpio_pull_up(PICO_DEFAULT_I2C_SCL_PIN);\n    // Make the I2C pins available to picotool\n    \n    // setup blink led\n    // setup blink led\n    initLED();\n    waitForUsbConnect();\n\n    // ================================================================\n    // ===                      INITIAL SETUP                       ===\n    // ================================================================\n\n    mpu.initialize();\n    devStatus = mpu.dmpInitialize();\n\n    /* --- if you have calibration data then set the sensor offsets here --- */\n    // mpu.setXAccelOffset();\n    // mpu.setYAccelOffset();\n    // mpu.setZAccelOffset();\n    // mpu.setXGyroOffset();\n    // mpu.setYGyroOffset();\n    // mpu.setZGyroOffset();\n\n    /* --- alternatively you can try this (6 loops should be enough) --- */\n    // mpu.CalibrateAccel(6);\n    // mpu.CalibrateGyro(6);\t\n\t\n    if (devStatus == 0) \n    {\n        mpu.setDMPEnabled(true);                // turn on the DMP, now that it\'s ready\n        mpuIntStatus = mpu.getIntStatus();\n        dmpReady = true;                        // set our DMP Ready flag so the main loop() function knows it\'s okay to use it\n        packetSize = mpu.dmpGetFIFOPacketSize();      // get expected DMP packet size for later comparison\n    } \n    else \n    {                                          // ERROR!        1 = initial memory load failed         2 = DMP configuration updates failed        (if it\'s going to break, usually the code will be 1)\n        printf("DMP Initialization failed (code %d)", devStatus);\n        sleep_ms(2000);\n    }\n    yaw = 0.0;\n    pitch = 0.0;\n    roll = 0.0;\n\n    // ================================================================\n    // ===                    MAIN PROGRAM LOOP                     ===\n    // ================================================================\n\n    while(1){\n\n        if (!dmpReady);                                                    // if programming failed, don\'t try to do anything\n        mpuInterrupt = true;\n        fifoCount = mpu.getFIFOCount();                                           // get current FIFO count\n        if ((mpuIntStatus & 0x10) || fifoCount == 1024)                           // check for overflow (this should never happen unless our code is too inefficient)\n        {\n            mpu.resetFIFO();                                                      // reset so we can continue cleanly\n            printf("FIFO overflow!");\n        } \n        else if (mpuIntStatus & 0x01)                                             // otherwise, check for DMP data ready interrupt (this should happen frequently)\n        {    \n            while (fifoCount < packetSize) fifoCount = mpu.getFIFOCount();        // wait for correct available data length, should be a VERY short wait\n            mpu.getFIFOBytes(fifoBuffer, packetSize);                             // read a packet from FIFO\n            fifoCount -= packetSize;                                              // track FIFO count here in case there is > 1 packet available\n            #ifdef OUTPUT_READABLE_YAWPITCHROLL                                               // display Euler angles in degrees\n                mpu.dmpGetQuaternion(&q, fifoBuffer);\n                mpu.dmpGetGravity(&gravity, &q);\n                mpu.dmpGetYawPitchRoll(ypr, &q, &gravity);\n                yaw = ypr[0] * 180 / PI;\n                pitch = ypr[1] * 180 / PI;\n                roll = ypr[2] * 180 / PI;\n                printf("ypr: %f,\\t %f,\\t %f\\n", yaw, pitch, roll);\n            #endif\n            #ifdef OUTPUT_READABLE_REALACCEL\n                // display real acceleration, adjusted to remove gravity\n                mpu.dmpGetQuaternion(&q, fifoBuffer);\n                mpu.dmpGetAccel(&aa, fifoBuffer);\n                mpu.dmpGetGravity(&gravity, &q);\n                mpu.dmpGetLinearAccel(&aaReal, &aa, &gravity);\n                printf("areal: %d,\\t %d,\\t %d\\n", aaReal.x, aaReal.y, aaReal.z);\n            #endif\n            #ifdef OUTPUT_READABLE_WORLDACCEL\n                // display initial world-frame acceleration, adjusted to remove gravity\n                // and rotated based on known orientation from quaternion\n                mpu.dmpGetQuaternion(&q, fifoBuffer);\n                mpu.dmpGetAccel(&aa, fifoBuffer);\n                mpu.dmpGetGravity(&gravity, &q);\n                mpu.dmpGetLinearAccel(&aaReal, &aa, &gravity);\n                mpu.dmpGetLinearAccelInWorld(&aaWorld, &aaReal, &q);\n                printf("aworld: %d,\\t %d,\\t %d\\n", aaWorld.x, aaWorld.y, aaWorld.z);\n            #endif\n            #ifdef OUTPUT_READABLE_CUSTOM\n                mpu.dmpGetQuaternion(&q, fifoBuffer);\n                printf("W: %f\\t X: %f\\t Y: %f\\t Z: %f\\n", q.w, q.x, q.y, q.z);\n            #endif\n        }\n    }\n\n    return 0;\n}\n'