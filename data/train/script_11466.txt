b'{-# LANGUAGE\n    CPP\n  , GeneralizedNewtypeDeriving\n  #-}\n#if MIN_VERSION_base(4,9,0)\n{-# OPTIONS_GHC -Wno-redundant-constraints #-}\n#endif\nmodule Rest.Driver.RestM\n  ( RestM\n  , runRestM\n  , runRestM_\n  , RestInput (..)\n  , emptyInput\n  , RestOutput (..)\n  ) where\n\nimport Control.Applicative\nimport Control.Monad.Reader\nimport Control.Monad.Writer (WriterT (..), tell)\nimport Data.CaseInsensitive (CI, mk)\nimport Data.HashMap.Strict (HashMap)\nimport Data.Semigroup\nimport qualified Data.ByteString.Lazy.UTF8 as UTF8\nimport qualified Data.HashMap.Strict       as H\n\nimport Rest.Driver.Perform (Rest)\nimport qualified Rest.Driver.Perform as Rest\nimport qualified Rest.Driver.Types   as Rest\n\ndata RestInput = RestInput\n  { headers    :: HashMap (CI String) String\n  , parameters :: HashMap String String\n  , body       :: UTF8.ByteString\n  , method     :: Maybe Rest.Method\n  , paths      :: [String]\n  , mimeTypes  :: HashMap String String\n  }\n\nemptyInput :: RestInput\nemptyInput = RestInput\n  { headers    = H.empty\n  , parameters = H.empty\n  , body       = mempty\n  , method     = Just Rest.GET\n  , paths      = []\n  , mimeTypes  = H.empty\n  }\n\ndata RestOutput = RestOutput\n  { headersSet   :: HashMap String String\n  , responseCode :: Maybe Int\n  } deriving Show\n\ninstance Semigroup RestOutput where\n  o1 <> o2 = RestOutput\n    { headersSet   = headersSet o2 `H.union` headersSet o1\n    , responseCode = responseCode o2 <|> responseCode o1\n    }\n\ninstance Monoid RestOutput where\n  mempty = RestOutput { headersSet = H.empty, responseCode = Nothing }\n  mappend = (<>)\n\noutputHeader :: String -> String -> RestOutput\noutputHeader h v = mempty { headersSet = H.singleton h v }\n\noutputCode :: Int -> RestOutput\noutputCode cd = mempty { responseCode = Just cd }\n\nnewtype RestM m a = RestM { unRestM :: ReaderT RestInput (WriterT RestOutput m) a }\n  deriving (Functor, Applicative, Monad)\n\ninstance MonadTrans RestM where\n  lift = RestM . lift . lift\n\nrunRestM :: RestInput -> RestM m a -> m (a, RestOutput)\nrunRestM i = runWriterT . flip runReaderT i . unRestM\n\nrunRestM_ :: Functor m => RestInput -> RestM m a -> m a\nrunRestM_ i = fmap fst . runRestM i\n\ninstance (Functor m, Applicative m, Monad m) => Rest (RestM m) where\n  getHeader    h     = RestM $ asks (H.lookup (mk h) . headers   )\n  getParameter p     = RestM $ asks (H.lookup p      . parameters)\n  getBody            = RestM $ asks body\n  getMethod          = RestM $ asks method\n  getPaths           = RestM $ asks paths\n  lookupMimeType t   = RestM $ asks (H.lookup t      . mimeTypes)\n  setHeader h v      = RestM $ tell (outputHeader h v)\n  setResponseCode cd = RestM $ tell (outputCode cd)\n'