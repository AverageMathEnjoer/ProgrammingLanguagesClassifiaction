b'\nmodule Main where\n\nimport Prelude hiding (words, drop, length, unwords, lines, null)\nimport qualified Data.List as List (null, length)\n\nimport Data.ByteString.Char8 (ByteString, breakSubstring, words, unwords, pack, unpack, lines, drop, length, null)\nimport qualified Data.ByteString.Char8 as BS (snoc, readFile)\n\nimport Data.Sequence (Seq, (<|), index)\nimport qualified Data.Sequence as Seq (null, length, fromList, empty)\n\nimport Control.Monad (liftM)\nimport System.Random (randomRIO)\n\n\n-- |choice returns a single randomly selected element out of a list.\nchoice :: Seq a -> IO a\nchoice xs = do\n  r <- randomRIO (0, Seq.length xs - 1)\n  return $ xs `index` r\n\n\n-- |nextwords searches the corpus for the string specified, and returns\n-- all the following words in a list.\nnextwords :: ByteString -> [ByteString] -> Seq ByteString -> Seq ByteString\nnextwords _ [] result = result\nnextwords searchwords (line:corpus) result =\n  let rest = snd $ breakSubstring searchwords line\n  in  if null rest\n         then nextwords searchwords corpus result\n         else let word = head . words . drop (length searchwords) $ rest\n              in  nextwords searchwords corpus (word <| result)\n\n\n-- |fill_sentence starts out with an (almost) empty sentence and puts in\n-- additional words by choosing randomly from nextwords.\nfill_sentence :: [ByteString] -> Int -> [ByteString] -> IO [ByteString]\nfill_sentence corpus pickiness sentence\n  | List.length sentence > 15 = return $ reverse sentence\n  | otherwise =\n      let appendspace bs = BS.snoc bs \' \'\n          altwords = nextwords (appendspace . unwords . reverse . take pickiness $ sentence) corpus Seq.empty\n      in  if Seq.null altwords\n          then return $ reverse sentence\n          else do\n            word <- choice altwords\n            fill_sentence corpus pickiness $ word : sentence\n\n\n-- |markov_talk sets up the beginning of a sentence and then invokes\n-- fill_sentence to fill the sentence up using randomly selected words.\nmarkov_talk :: Int -> IO String\nmarkov_talk pickiness = do\n  corpus <- liftM lines $ BS.readFile "#adun.se.log"\n  line <- choice $ Seq.fromList corpus\n  let message = words . drop 2 . snd $ breakSubstring (pack "> ") line\n  if List.null message\n     then return ""\n     else do\n         let seed = reverse . take pickiness $ message\n         sentence <- fill_sentence corpus pickiness seed\n         return . unpack . unwords $ sentence\n\n\nmain :: IO ()\nmain = do\n  markov_talk 3 >>= putStrLn\n'