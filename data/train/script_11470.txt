b'\xef\xbb\xbfusing System;\nusing System.ComponentModel;\nusing System.Runtime.InteropServices;\nusing System.Security.Cryptography;\nusing System.Security.Cryptography.X509Certificates;\nusing System.Text;\n\ninternal static class SafeNativeMethods {\n\n    //Based on code from http://www.infinitec.de/post/2010/11/22/Setting-the-PIN-of-a-smartcard-programmatically.aspx\n    public static void SetPinForPrivateKey(this X509Certificate2 certificate, string pin) {\n\n        if (certificate == null) \n            throw new ArgumentNullException("certificate");\n\n\n         if (certificate.PrivateKey is RSACryptoServiceProvider rsaCsp) {\n\n            var providerHandle = IntPtr.Zero;\n            var pinBuffer = Encoding.ASCII.GetBytes(pin);\n\n            // provider handle is implicitly released when the certificate handle is released.\n            SafeNativeMethods.Execute(() => SafeNativeMethods.CryptAcquireContext(ref providerHandle,\n                                            rsaCsp.CspKeyContainerInfo.KeyContainerName,\n                                            rsaCsp.CspKeyContainerInfo.ProviderName,\n                                            rsaCsp.CspKeyContainerInfo.ProviderType,\n                                            SafeNativeMethods.CryptContextFlags.Silent));\n            SafeNativeMethods.Execute(() => SafeNativeMethods.CryptSetProvParam(providerHandle,\n                                            SafeNativeMethods.CryptParameter.KeyExchangePin,\n                                            pinBuffer, 0));\n            SafeNativeMethods.Execute(() => SafeNativeMethods.CertSetCertificateContextProperty(\n                                            certificate.Handle,\n                                            SafeNativeMethods.CertificateProperty.CryptoProviderHandle,\n                                            0, providerHandle));\n        }\n        /* Only available in .NET 4.6+\n         else if (certificate.PrivateKey is RSACng rsaCng) {\n            // Set the PIN, an explicit null terminator is required to this Unicode/UCS-2 string.\n\n            byte[] propertyBytes;\n\n            if (pin[pin.Length - 1] == \'\\0\') {\n                propertyBytes = Encoding.Unicode.GetBytes(pin);\n            } else {\n                propertyBytes = new byte[Encoding.Unicode.GetByteCount(pin) + 2];\n                Encoding.Unicode.GetBytes(pin, 0, pin.Length, propertyBytes, 0);\n            }\n\n            const string NCRYPT_PIN_PROPERTY = "SmartCardPin";\n\n            CngProperty pinProperty = new CngProperty(\n                NCRYPT_PIN_PROPERTY,\n                propertyBytes,\n                CngPropertyOptions.None);\n\n            rsaCng.Key.SetProperty(pinProperty);\n\n        } \n        */\n    }\n\n    internal enum CryptContextFlags {\n        None = 0,\n        Silent = 0x40\n    }\n\n    internal enum CertificateProperty {\n        None = 0,\n        CryptoProviderHandle = 0x1\n    }\n\n    internal enum CryptParameter {\n        None = 0,\n        KeyExchangePin = 0x20\n    }\n\n    [DllImport("advapi32.dll", CharSet = CharSet.Auto, SetLastError = true)]\n    public static extern bool CryptAcquireContext(\n        ref IntPtr hProv,\n        string containerName,\n        string providerName,\n        int providerType,\n        CryptContextFlags flags\n        );\n\n    [DllImport("advapi32.dll", SetLastError = true, CharSet = CharSet.Auto)]\n    public static extern bool CryptSetProvParam(\n        IntPtr hProv,\n        CryptParameter dwParam,\n        [In] byte[] pbData,\n        uint dwFlags);\n\n    [DllImport("CRYPT32.DLL", SetLastError = true)]\n    internal static extern bool CertSetCertificateContextProperty(\n        IntPtr pCertContext,\n        CertificateProperty propertyId,\n        uint dwFlags,\n        IntPtr pvData\n        );\n\n    public static void Execute(Func<bool> action) {\n        if (!action()) {\n            throw new Win32Exception(Marshal.GetLastWin32Error());\n        }\n    }\n}'