b'{-# LANGUAGE NamedFieldPuns, CPP, BangPatterns #-}\n\n-- | A simple interface for logging start/end times and which processor a task runs on.\n--   TODO: This should be replaced by GHC events.\n\nmodule Control.Monad.Par.Logging\n  ( LogEntry(..), TaskSeries(..),\n    allTaskSeries,\n    unsafeNewTaskSeries,\n    timePure,\n    nameFromValue,\n    grabAllLogs, printAllLogs,\n\n    -- Timing support:\n    getTime, oneSecond,\n     -- TEMP:\n    commaint\n  )\nwhere\n\nimport Control.Monad\nimport Control.DeepSeq\nimport Control.Exception\nimport Data.IORef\nimport Data.Word\nimport Data.List\nimport Data.List.Split (chunk)\nimport Data.Function\nimport GHC.Conc\nimport System.IO.Unsafe\nimport System.Mem.StableName\nimport System.CPUTime\n\n-- Hardware cycle counter support is optional:\n#define RDTSC\n#ifdef RDTSC\nimport System.CPUTime.Rdtsc\n#endif\n\ndata LogEntry = LE { start :: {-# UNPACK #-} !Word64\n\t\t   , end   :: {-# UNPACK #-} !Word64\n\t\t   , proc  :: {-# UNPACK #-} !ThreadId\n\t\t   } \n  deriving Show\ntype Log = [LogEntry]\n\n\n-- The String identifies the task series\ndata TaskSeries = TS String (IORef Log)\n\n-- Global variable that accumulates all task series.\nallTaskSeries :: IORef [TaskSeries]\nallTaskSeries = unsafePerformIO$ newIORef []\n\n{-# NOINLINE unsafeNewTaskSeries #-}\nunsafeNewTaskSeries :: String -> TaskSeries\nunsafeNewTaskSeries name = unsafePerformIO$ \n do log <- newIORef [] \n    let ts = TS name log\n    atomicModifyIORef_ allTaskSeries (ts:)\n    return ts\n\n\n{-# NOINLINE timePure #-}\n-- Time a pure computation, fully evaluate its result.\ntimePure :: NFData a => TaskSeries -> a -> a\ntimePure (TS _ log) thnk = unsafePerformIO$\n do proc   <- myThreadId\n    start  <- rdtsc\n    evaluate (rnf thnk)\n    end    <- rdtsc\n    atomicModifyIORef_ log (LE start end proc :)\n    return thnk\n\n{-# NOINLINE nameFromValue #-}\nnameFromValue :: a -> String\nnameFromValue val = unsafePerformIO$ \n  do stbl <- makeStableName val\n     return ("Obj_" ++ show (hashStableName stbl))\n\natomicModifyIORef_ ref fn = atomicModifyIORef ref (\\x -> (fn x, ()))\n\n-- Read and reset ALL logs.\ngrabAllLogs :: IO [(String, Log)]\ngrabAllLogs = \n do series <- readIORef allTaskSeries\n    -- This is piecewise atomic.  We can\'t get a true snapshot but we\n    -- can grab it as fast as we can:\n    forM series $ \\ (TS name log) -> do\n      -- Atomic slice off whats there:\n      ls <- atomicModifyIORef log (\\x -> ([],x))\n      return (name,ls)\n    \n\nprintAllLogs :: IO ()\nprintAllLogs = \n do grab <- grabAllLogs\n    forM_ (sortBy (compare `on` fst) grab) $ \\ (name, entries) -> do\n      putStrLn ""\n      forM_ (sortBy (compare `on` start) entries) $ \\ LE{start,end,proc} -> do \n--        printf "%s %s %d %d\\n" name start end (show proc)\n        putStrLn$ name ++" "++ show proc ++" "++ show start ++" "++ show end\n\n------------------------------------------------------------\n-- Helpers and Scrap:\n\ncommaint :: (Show a, Integral a) => a -> String\ncommaint n | n < 0 = "-" ++ commaint (-n)\ncommaint n = \n   reverse $ concat $\n   intersperse "," $ \n   chunk 3 $ reverse (show n)\n\n------------------------------------------------------------\n-- Timing support:\n\n-- | Get the CPU time in unspecified units.\ngetTime :: IO Word64\n-- | How many units-per-second in getTime\'s units.\noneSecond :: Word64\n\n-- Having trouble with this:\n#ifndef RDTSC\ngetTime = getCPUTime\noneSecond = 1000000000000 -- picoseconds\n#else\ngetTime = rdtsc\noneSecond = unsafePerformIO$ measure_freq2\n\n-- This version simply busy-waits to stay on the same core:\nmeasure_freq2 :: IO Word64\nmeasure_freq2 = do \n--  let second = 1000 * 1000 * 1000 * 1000 -- picoseconds are annoying\n  let tenth = 100 * 1000 * 1000 * 1000 -- picoseconds are annoying      \n      coef = 10\n  t1 <- rdtsc \n  start <- getCPUTime\n  let loop !n !last = \n       do t2 <- rdtsc \n\t  when (t2 < last) $\n\t       putStrLn$ "WARNING, measure_freq2: COUNTERS WRAPPED "++ show (last,t2) \n\t  cput <- getCPUTime\t\t\n--\t  if (cput - start < second) \n\t  if (cput - start < tenth)\n\t   then loop (n+1) t2\n\t   else return (n,t2)\n  (n,t2) <- loop 0 t1\n  putStrLn$ "  Approx getCPUTime calls per second: "++ commaint (coef * n)\n  when (t2 < t1) $ \n    putStrLn$ "WARNING: rdtsc not monotonically increasing, first "++show t1++" then "++show t2++" on the same OS thread"\n\n  return$ coef * fromIntegral (t2 - t1)\n#endif\n\n'