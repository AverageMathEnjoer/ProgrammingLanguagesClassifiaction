b"{-# LANGUAGE AllowAmbiguousTypes #-}\n{-# LANGUAGE UndecidableInstances #-}\n-- | Some functionality is useful enough to be provided across backends, but is\n-- not standardized. For example, many RDBMS systems provide ways of fetching\n-- auto-incrementing or defaulting fields on INSERT or UPDATE.\n--\n-- Beam provides type classes that some backends instantiate that provide this\n-- support. This uses direct means on sufficiently advanced backends and is\n-- emulated on others.\nmodule Database.Beam.Backend.SQL.BeamExtensions\n  ( MonadBeamInsertReturning(..)\n  , MonadBeamUpdateReturning(..)\n  , MonadBeamDeleteReturning(..)\n  , BeamHasInsertOnConflict(..)\n\n  , SqlSerial(..)\n  , onConflictUpdateInstead\n  , onConflictUpdateAll\n  ) where\n\nimport           Database.Beam.Backend\nimport           Database.Beam.Query\nimport           Database.Beam.Query.Internal\nimport           Database.Beam.Schema\nimport           Database.Beam.Schema.Tables\n\nimport           Control.Monad.Cont\nimport           Control.Monad.Except\nimport           Control.Monad.Identity\nimport qualified Control.Monad.RWS.Lazy as Lazy\nimport qualified Control.Monad.RWS.Strict as Strict\nimport           Control.Monad.Reader\nimport qualified Control.Monad.State.Lazy as Lazy\nimport qualified Control.Monad.State.Strict as Strict\nimport qualified Control.Monad.Writer.Lazy as Lazy\nimport qualified Control.Monad.Writer.Strict as Strict\nimport           Data.Functor.Const\nimport           Data.Kind (Type)\nimport           Data.Proxy\nimport           Data.Semigroup\n\n--import GHC.Generics\n\n-- | 'MonadBeam's that support returning the newly created rows of an @INSERT@ statement.\n--   Useful for discovering the real value of a defaulted value.\nclass MonadBeam be m =>\n  MonadBeamInsertReturning be m | m -> be where\n  runInsertReturningList\n    :: ( Beamable table\n       , Projectible be (table (QExpr be ()))\n       , FromBackendRow be (table Identity) )\n    => SqlInsert be table\n    -> m [table Identity]\n\ninstance MonadBeamInsertReturning be m => MonadBeamInsertReturning be (ExceptT e m) where\n    runInsertReturningList = lift . runInsertReturningList\ninstance MonadBeamInsertReturning be m => MonadBeamInsertReturning be (ContT r m) where\n    runInsertReturningList = lift . runInsertReturningList\ninstance MonadBeamInsertReturning be m => MonadBeamInsertReturning be (ReaderT r m) where\n    runInsertReturningList = lift . runInsertReturningList\ninstance MonadBeamInsertReturning be m => MonadBeamInsertReturning be (Lazy.StateT r m) where\n    runInsertReturningList = lift . runInsertReturningList\ninstance MonadBeamInsertReturning be m => MonadBeamInsertReturning be (Strict.StateT r m) where\n    runInsertReturningList = lift . runInsertReturningList\ninstance (MonadBeamInsertReturning be m, Monoid r)\n    => MonadBeamInsertReturning be (Lazy.WriterT r m) where\n    runInsertReturningList = lift . runInsertReturningList\ninstance (MonadBeamInsertReturning be m, Monoid r)\n    => MonadBeamInsertReturning be (Strict.WriterT r m) where\n    runInsertReturningList = lift . runInsertReturningList\ninstance (MonadBeamInsertReturning be m, Monoid w)\n    => MonadBeamInsertReturning be (Lazy.RWST r w s m) where\n    runInsertReturningList = lift . runInsertReturningList\ninstance (MonadBeamInsertReturning be m, Monoid w)\n    => MonadBeamInsertReturning be (Strict.RWST r w s m) where\n    runInsertReturningList = lift . runInsertReturningList\n\n-- | 'MonadBeam's that support returning the updated rows of an @UPDATE@ statement.\n--   Useful for discovering the new values of the updated rows.\nclass MonadBeam be m =>\n  MonadBeamUpdateReturning be m | m -> be where\n  runUpdateReturningList\n    :: ( Beamable table\n       , Projectible be (table (QExpr be ()))\n       , FromBackendRow be (table Identity) )\n    => SqlUpdate be table\n    -> m [table Identity]\n\ninstance MonadBeamUpdateReturning be m => MonadBeamUpdateReturning be (ExceptT e m) where\n    runUpdateReturningList = lift . runUpdateReturningList\ninstance MonadBeamUpdateReturning be m => MonadBeamUpdateReturning be (ContT r m) where\n    runUpdateReturningList = lift . runUpdateReturningList\ninstance MonadBeamUpdateReturning be m => MonadBeamUpdateReturning be (ReaderT r m) where\n    runUpdateReturningList = lift . runUpdateReturningList\ninstance MonadBeamUpdateReturning be m => MonadBeamUpdateReturning be (Lazy.StateT r m) where\n    runUpdateReturningList = lift . runUpdateReturningList\ninstance MonadBeamUpdateReturning be m => MonadBeamUpdateReturning be (Strict.StateT r m) where\n    runUpdateReturningList = lift . runUpdateReturningList\ninstance (MonadBeamUpdateReturning be m, Monoid r)\n    => MonadBeamUpdateReturning be (Lazy.WriterT r m) where\n    runUpdateReturningList = lift . runUpdateReturningList\ninstance (MonadBeamUpdateReturning be m, Monoid r)\n    => MonadBeamUpdateReturning be (Strict.WriterT r m) where\n    runUpdateReturningList = lift . runUpdateReturningList\ninstance (MonadBeamUpdateReturning be m, Monoid w)\n    => MonadBeamUpdateReturning be (Lazy.RWST r w s m) where\n    runUpdateReturningList = lift . runUpdateReturningList\ninstance (MonadBeamUpdateReturning be m, Monoid w)\n    => MonadBeamUpdateReturning be (Strict.RWST r w s m) where\n    runUpdateReturningList = lift . runUpdateReturningList\n\n-- | 'MonadBeam's that suppert returning rows that will be deleted by the given\n-- @DELETE@ statement. Useful for deallocating resources based on the value of\n-- deleted rows.\nclass MonadBeam be m =>\n  MonadBeamDeleteReturning be m | m -> be where\n  runDeleteReturningList\n    :: ( Beamable table\n       , Projectible be (table (QExpr be ()))\n       , FromBackendRow be (table Identity) )\n    => SqlDelete be table\n    -> m [table Identity]\n\ninstance MonadBeamDeleteReturning be m => MonadBeamDeleteReturning be (ExceptT e m) where\n    runDeleteReturningList = lift . runDeleteReturningList\ninstance MonadBeamDeleteReturning be m => MonadBeamDeleteReturning be (ContT r m) where\n    runDeleteReturningList = lift . runDeleteReturningList\ninstance MonadBeamDeleteReturning be m => MonadBeamDeleteReturning be (ReaderT r m) where\n    runDeleteReturningList = lift . runDeleteReturningList\ninstance MonadBeamDeleteReturning be m => MonadBeamDeleteReturning be (Lazy.StateT r m) where\n    runDeleteReturningList = lift . runDeleteReturningList\ninstance MonadBeamDeleteReturning be m => MonadBeamDeleteReturning be (Strict.StateT r m) where\n    runDeleteReturningList = lift . runDeleteReturningList\ninstance (MonadBeamDeleteReturning be m, Monoid r)\n    => MonadBeamDeleteReturning be (Lazy.WriterT r m) where\n    runDeleteReturningList = lift . runDeleteReturningList\ninstance (MonadBeamDeleteReturning be m, Monoid r)\n    => MonadBeamDeleteReturning be (Strict.WriterT r m) where\n    runDeleteReturningList = lift . runDeleteReturningList\ninstance (MonadBeamDeleteReturning be m, Monoid w)\n    => MonadBeamDeleteReturning be (Lazy.RWST r w s m) where\n    runDeleteReturningList = lift . runDeleteReturningList\ninstance (MonadBeamDeleteReturning be m, Monoid w)\n    => MonadBeamDeleteReturning be (Strict.RWST r w s m) where\n    runDeleteReturningList = lift . runDeleteReturningList\n\nclass BeamSqlBackend be => BeamHasInsertOnConflict be where\n  -- | Specifies the kind of constraint that must be violated for the action to occur\n  data SqlConflictTarget be (table :: (Type -> Type) -> Type) :: Type\n  -- | What to do when an @INSERT@ statement inserts a row into the table @tbl@\n  -- that violates a constraint.\n  data SqlConflictAction be (table :: (Type -> Type) -> Type) :: Type\n\n  insertOnConflict\n    :: Beamable table\n    => DatabaseEntity be db (TableEntity table)\n    -> SqlInsertValues be (table (QExpr be s))\n    -> SqlConflictTarget be table\n    -> SqlConflictAction be table\n    -> SqlInsert be table\n\n  anyConflict :: SqlConflictTarget be table\n  conflictingFields\n    :: Projectible be proj\n    => (table (QExpr be QInternal) -> proj)\n    -> SqlConflictTarget be table\n  conflictingFieldsWhere\n    :: Projectible be proj\n    => (table (QExpr be QInternal) -> proj)\n    -> (forall s. table (QExpr be s) -> QExpr be s Bool)\n    -> SqlConflictTarget be table\n\n  onConflictDoNothing :: SqlConflictAction be table\n  onConflictUpdateSet\n    :: Beamable table\n    => (forall s. table (QField s) -> table (QExpr be s) -> QAssignment be s)\n    -> SqlConflictAction be table\n  onConflictUpdateSetWhere\n    :: Beamable table\n    => (forall s. table (QField s) -> table (QExpr be s) -> QAssignment be s)\n    -> (forall s. table (QField s) -> table (QExpr be s) -> QExpr be s Bool)\n    -> SqlConflictAction be table\n\nnewtype InaccessibleQAssignment be = InaccessibleQAssignment\n  { unInaccessibleQAssignment :: [(BeamSqlBackendFieldNameSyntax be, BeamSqlBackendExpressionSyntax be)]\n  } deriving (Data.Semigroup.Semigroup, Monoid)\n\nonConflictUpdateInstead\n  :: forall be table proj\n  .  ( BeamHasInsertOnConflict be\n     , Beamable table\n     , ProjectibleWithPredicate AnyType () (InaccessibleQAssignment be) proj\n     )\n  => (table (Const (InaccessibleQAssignment be)) -> proj)\n  -> SqlConflictAction be table\nonConflictUpdateInstead mkProj = onConflictUpdateSet mkAssignments\n  where\n    mkAssignments\n      :: forall s\n      .  table (QField s)\n      -> table (QExpr be s)\n      -> QAssignment be s\n    mkAssignments table excluded = QAssignment $ unInaccessibleQAssignment $\n      Strict.execWriter $ project'\n        (Proxy @AnyType)\n        (Proxy @((), InaccessibleQAssignment be))\n        (\\_ _ a -> Strict.tell a >> return a)\n        (mkProj $ runIdentity $ zipBeamFieldsM mkAssignment table excluded)\n    mkAssignment\n      :: forall s a\n      .  Columnar' (QField s) a\n      -> Columnar' (QExpr be s) a\n      -> Identity (Columnar' (Const (InaccessibleQAssignment be)) a)\n    mkAssignment (Columnar' field) (Columnar' value) =\n      Identity $ Columnar' $ Const $\n        InaccessibleQAssignment $ unQAssignment $ field <-. value\n\nonConflictUpdateAll\n  :: forall be table\n  .  ( BeamHasInsertOnConflict be\n     , Beamable table\n     )\n  => SqlConflictAction be table\nonConflictUpdateAll = onConflictUpdateInstead id\n"