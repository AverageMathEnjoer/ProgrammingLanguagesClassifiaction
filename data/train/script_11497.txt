b'{-# LANGUAGE MultiParamTypeClasses, FunctionalDependencies #-}\n-- TODO: ADD Unsafe\n\n-- | Unsafe operations.  NOT part of "Safe Haskell".\n-- \n-- These are "unsafe" (in the normal, Haskell sense) when used with a\n-- "runPar" of type `Par a -> a`.  If used with a `runParIO` that\n-- stays in the IO monad, then they are simply dangerous.\n-- \n-- For the purposes of Safe Haskell, any module that imports this\n-- module becomes untrustworthy.\n\nmodule Control.Monad.Par.Unsafe \n  (\n   ParUnsafe(..)\n  ) \nwhere\n\n-- import Control.Monad.Par.Class\n\n-- | The class of Par monads that provide unsafe functionality.\nclass ParUnsafe iv p | p -> iv where \n  -- | Peek at the current contents of an \'IVar\' in a nonblocking way.\n  unsafePeek   :: iv a -> p (Maybe a)\n\n  -- | Attempt to put a value into an \'IVar\'.  If successful, return the\n  --   value put.  If something is already there, return it instead.\n  unsafeTryPut :: iv a -> a -> p a\n\n  -- | Lift an \'IO\' operation into the Par monad.\n  unsafeParIO  :: IO a -> p a\n\n-- Aside:\n-- If the need ever arises we could also consider unsafeMultiplePut that\n-- would be able to change the current value of an IVar.  It could\n-- cause big problems in the distributed case, however.\n'