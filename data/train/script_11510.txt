b'module Hoodle.HitTest\n  ( isPointInBBox,\n    do2LinesIntersect,\n    doesLineHitStrk,\n    do2BBoxIntersect,\n    isBBox2InBBox1,\n    hltHittedByBBox,\n    hltEmbeddedByBBox,\n    hltHittedByLineRough,\n    elimHitted,\n    merge,\n    getTotalBBox,\n\n    -- * lasso selection\n    angleBAC,\n    wrappingAngle,\n    mappingDegree,\n    hitLassoPoint,\n  )\nwhere\n\nimport Control.Monad.State (MonadState (get, put), State, evalState, modify)\nimport Data.List (foldl\')\nimport Data.Sequence (Seq, ViewL (..), viewl)\nimport Hoodle.HitTest.Type\n  ( AlterList (Empty, (:-)),\n    BBox (..),\n    GetBBoxable (..),\n    Hitted (..),\n    NotHitted (..),\n  )\n\n--------------------------\n-- hit test collections --\n--------------------------\n\n-- | hit test of whether a point in a bbox\n--   previously, hitTestBBoxPoint\nisPointInBBox ::\n  BBox ->\n  -- | point\n  (Double, Double) ->\n  Bool\nisPointInBBox (BBox (ulx, uly) (lrx, lry)) (x, y) =\n  ulx <= x && x <= lrx && uly <= y && y <= lry\n\n-- | hit test of whether two lines intersect\ndo2LinesIntersect ::\n  -- | line1\n  ((Double, Double), (Double, Double)) ->\n  -- | line2\n  ((Double, Double), (Double, Double)) ->\n  Bool\ndo2LinesIntersect ((x1, y1), (x2, y2)) ((x3, y3), (x4, y4)) =\n  (x2 - xc) * (xc - x1) > 0 && (x3 - xc) * (xc - x4) > 0\n  where\n    x21 = x2 - x1\n    x43 = x4 - x3\n    y21 = y2 - y1\n    y43 = y4 - y3\n    xc = (x21 * x43 * (y3 - y1) + y21 * x43 * x1 - y43 * x21 * x3) / (y21 * x43 - y43 * x21)\n\n-- | Does a line hit a stroke (a sequence of points)?\ndoesLineHitStrk :: ((Double, Double), (Double, Double)) -> [(Double, Double)] -> Bool\ndoesLineHitStrk _ [] = False\ndoesLineHitStrk _ [_] = False\ndoesLineHitStrk line1 ((x0, y0) : (x, y) : rest) =\n  do2LinesIntersect line1 ((x0, y0), (x, y)) || doesLineHitStrk line1 ((x, y) : rest)\n\n-- | Do two bounding boxes intersect with each other?\n--   previously, hitTestBBoxBBox\ndo2BBoxIntersect :: BBox -> BBox -> Bool\ndo2BBoxIntersect (BBox (ulx1, uly1) (lrx1, lry1)) (BBox (ulx2, uly2) (lrx2, lry2)) =\n  p1 && p2\n  where\n    p1 =\n      ulx1 <= ulx2 && ulx2 <= lrx1\n        || ulx1 <= lrx2 && lrx2 <= lrx1\n        || ulx2 <= ulx1 && ulx1 <= lrx2\n        || ulx2 <= lrx1 && lrx1 <= lrx2\n    p2 =\n      uly1 <= uly2 && uly2 <= lry1\n        || uly1 <= lry2 && lry2 <= lry1\n        || uly2 <= uly1 && uly1 <= lry2\n        || uly2 <= lry1 && lry1 <= lry2\n\n-- | is the second bbox inside the first bbox?\n--   previously, hitTestInsideBBox\nisBBox2InBBox1 ::\n  -- | 1st bbox\n  BBox ->\n  -- | 2nd bbox\n  BBox ->\n  Bool\nisBBox2InBBox1 b1 (BBox (ulx2, uly2) (lrx2, lry2)) =\n  isPointInBBox b1 (ulx2, uly2) && isPointInBBox b1 (lrx2, lry2)\n\n--------------------------------------------------------\n-- item filtering functions that results in AlterList --\n--------------------------------------------------------\n\n-- |\nhltFilteredByStateT ::\n  -- | hit test condition\n  (a -> Bool) ->\n  -- | strokes to test\n  [a] ->\n  State Bool (AlterList (NotHitted a) (Hitted a))\nhltFilteredByStateT test itms = do\n  let (nhit, rest) = break test itms\n      (hit, rest\') = span test rest\n  modify (|| (not . null) hit)\n  if null rest\'\n    then return (NotHitted nhit :- Hitted hit :- NotHitted [] :- Empty)\n    else return (NotHitted nhit :- Hitted hit :- hltFilteredBy test rest\')\n\n-- | highlight strokes filtered by a condition.\n--   previously mkHitTestAL\nhltFilteredBy ::\n  -- | hit test condition\n  (a -> Bool) ->\n  -- | strokes to test\n  [a] ->\n  AlterList (NotHitted a) (Hitted a)\nhltFilteredBy test is = evalState (hltFilteredByStateT test is) False\n\n-- |\nhltHittedByBBox ::\n  (GetBBoxable a) =>\n  -- | test bounding box\n  BBox ->\n  -- | items to test\n  [a] ->\n  AlterList (NotHitted a) (Hitted a)\nhltHittedByBBox b = hltFilteredBy (do2BBoxIntersect b . getBBox)\n\n-- |\nhltEmbeddedByBBox ::\n  (GetBBoxable a) =>\n  BBox ->\n  [a] ->\n  AlterList (NotHitted a) (Hitted a)\nhltEmbeddedByBBox b = hltFilteredBy (isBBox2InBBox1 b . getBBox)\n\n-- | only check if a line and bbox of item overlapped\nhltHittedByLineRough ::\n  (GetBBoxable a) =>\n  -- | line\n  ((Double, Double), (Double, Double)) ->\n  -- | items to test\n  [a] ->\n  AlterList (NotHitted a) (Hitted a)\nhltHittedByLineRough (p1, p2) = hltFilteredBy boxhittest\n  where\n    boxhittest s =\n      isPointInBBox (getBBox s) p1\n        || isPointInBBox (getBBox s) p2\n\n-- |\nelimHitted ::\n  (GetBBoxable a) =>\n  AlterList (NotHitted a) (Hitted a) ->\n  State (Maybe BBox) [a]\nelimHitted Empty = error "something wrong in elimHitted"\nelimHitted (n :- Empty) = return (unNotHitted n)\nelimHitted (n :- h :- rest) = do\n  bbox <- get\n  let bbox2 = getTotalBBox (unHitted h)\n  put (merge bbox bbox2)\n  (unNotHitted n ++) <$> elimHitted rest\n\n-- |\nmerge :: Maybe BBox -> Maybe BBox -> Maybe BBox\nmerge Nothing Nothing = Nothing\nmerge Nothing (Just b) = Just b\nmerge (Just b) Nothing = Just b\nmerge (Just (BBox (x1, y1) (x2, y2))) (Just (BBox (x3, y3) (x4, y4))) =\n  Just (BBox (min x1 x3, min y1 y3) (max x2 x4, max y2 y4))\n\n-- |\ngetTotalBBox :: (GetBBoxable a) => [a] -> Maybe BBox\ngetTotalBBox = foldl f Nothing\n  where\n    f acc = merge acc . Just . getBBox\n\n--------------------------------------------------------\n-- Lasso selection hit test                           --\n--------------------------------------------------------\n\nangleBAC :: (Double, Double) -> (Double, Double) -> (Double, Double) -> Double\nangleBAC (bx, by) (ax, ay) (cx, cy) =\n  let theta1\n        | ax == bx && ay > by = pi / 2.0\n        | ax == bx && ay <= by = -pi / 2.0\n        | ax < bx && ay > by = atan ((ay - by) / (ax - bx)) + pi\n        | ax < bx && ay <= by = atan ((ay - by) / (ax - bx)) - pi\n        | otherwise = atan ((ay - by) / (ax - bx))\n      theta2\n        | cx == bx && cy > by = pi / 2.0\n        | cx == bx && cy <= by = -pi / 2.0\n        | cx < bx && cy > by = atan ((cy - by) / (cx - bx)) + pi\n        | cx < bx && cy <= by = atan ((cy - by) / (cx - bx)) - pi\n        | otherwise = atan ((cy - by) / (cx - bx))\n      dtheta = theta2 - theta1\n      result\n        | dtheta > pi = dtheta - 2.0 * pi\n        | dtheta < (-pi) = dtheta + 2.0 * pi\n        | otherwise = dtheta\n   in result\n\nwrappingAngle :: Seq (Double, Double) -> (Double, Double) -> Double\nwrappingAngle lst p =\n  case viewl lst of\n    EmptyL -> 0\n    x :< xs -> Prelude.snd $ foldl\' f (x, 0) xs\n  where\n    f (q\', theta) q =\n      let theta\' = angleBAC p q\' q\n       in theta\' `seq` (q, theta\' + theta)\n\nmappingDegree :: Seq (Double, Double) -> (Double, Double) -> Int\nmappingDegree lst = round . (/ (2.0 * pi)) . wrappingAngle lst\n\n-- |\nhitLassoPoint :: Seq (Double, Double) -> (Double, Double) -> Bool\nhitLassoPoint lst = odd . mappingDegree lst\n'