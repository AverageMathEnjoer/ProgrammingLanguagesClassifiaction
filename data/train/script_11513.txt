b"-- deprecated. will be removed\nmodule Graphics.Hoodle.Render.Type.HitTest\n  ( AlterList (..), -- re-export\n    NotHitted (..), -- re-export\n    Hitted (..), -- re-export\n    TAlterHitted, -- re-export\n    TEitherAlterHitted (..), -- re-export\n    getA, -- re-export\n    getB, -- re-export\n    interleave, -- re-export\n    takeHitted, -- re-export\n    isAnyHitted, -- re-export\n    StrokeHitted,\n    RItemHitted,\n    takeFirstFromHitted,\n    takeLastFromHitted,\n  )\nwhere\n\nimport Data.Hoodle.BBox (BBoxed)\nimport Data.Hoodle.Simple (Stroke)\nimport Graphics.Hoodle.Render.Type.Item (RItem)\nimport Hoodle.HitTest.Type\n  ( AlterList (..),\n    Hitted (..),\n    NotHitted (..),\n    TAlterHitted,\n    TEitherAlterHitted (..),\n    getA,\n    getB,\n    interleave,\n    isAnyHitted,\n    takeHitted,\n  )\nimport Prelude hiding (fst, snd)\n\n-- |\ntype StrokeHitted = AlterList (NotHitted (BBoxed Stroke)) (Hitted (BBoxed Stroke))\n\n-- |\ntype RItemHitted = AlterList (NotHitted RItem) (Hitted RItem)\n\n-- |\ntakeFirstFromHitted :: RItemHitted -> RItemHitted\ntakeFirstFromHitted Empty = Empty\ntakeFirstFromHitted (a :- Empty) = a :- Empty\ntakeFirstFromHitted (a :- b :- xs) =\n  let (b1, bs) = splitAt 1 (unHitted b)\n      rs = concat $ interleave unNotHitted unHitted xs\n   in a :- Hitted b1 :- NotHitted (bs ++ rs) :- Empty\n\n-- |\ntakeLastFromHitted :: RItemHitted -> RItemHitted\ntakeLastFromHitted Empty = Empty\ntakeLastFromHitted (a :- Empty) = a :- Empty\ntakeLastFromHitted (a :- b :- Empty) =\n  let b' = unHitted b\n   in if (not . null) b'\n        then\n          let (bs, b1) = (,) <$> init <*> last $ b'\n           in NotHitted (unNotHitted a ++ bs) :- Hitted [b1] :- Empty\n        else NotHitted (unNotHitted a ++ b') :- Empty\ntakeLastFromHitted (a1 :- b :- a2 :- Empty) =\n  let b' = unHitted b\n   in if (not . null) b'\n        then\n          let (bs, b1) = (,) <$> init <*> last $ b'\n           in NotHitted (unNotHitted a1 ++ bs) :- Hitted [b1] :- a2 :- Empty\n        else NotHitted (unNotHitted a1 ++ b' ++ unNotHitted a2) :- Empty\ntakeLastFromHitted (a :- b :- xs) =\n  let xs' = takeLastFromHitted xs\n   in case xs' of\n        Empty ->\n          let b' = unHitted b\n           in if (not . null) b'\n                then\n                  let (bs, b1) = (,) <$> init <*> last $ b'\n                   in NotHitted (unNotHitted a ++ bs) :- Hitted [b1] :- Empty\n                else NotHitted (unNotHitted a ++ b') :- Empty\n        a' :- Empty ->\n          let b' = unHitted b\n           in if (not . null) b'\n                then\n                  let (bs, b1) = (,) <$> init <*> last $ b'\n                   in NotHitted (unNotHitted a ++ bs) :- Hitted [b1] :- a' :- Empty\n                else NotHitted (unNotHitted a ++ b' ++ unNotHitted a') :- Empty\n        a' :- b' :- xs'' -> NotHitted (unNotHitted a ++ unHitted b ++ unNotHitted a') :- b' :- xs''\n"