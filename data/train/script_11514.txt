b'using System;\nusing System.Diagnostics;\nusing System.Text;\n\nnamespace CS_SQLite3\n{\n  using sqlite3_value = CSSQLite.Mem;\n\n  public partial class CSSQLite\n  {\n    /*\n    ** 2005 February 15\n    **\n    ** The author disclaims copyright to this source code.  In place of\n    ** a legal notice, here is a blessing:\n    **\n    **    May you do good and not evil.\n    **    May you find forgiveness for yourself and forgive others.\n    **    May you share freely, never taking more than you give.\n    **\n    *************************************************************************\n    ** This file contains C code routines that used to generate VDBE code\n    ** that implements the ALTER TABLE command.\n    **\n    ** $Id: alter.c,v 1.62 2009/07/24 17:58:53 danielk1977 Exp $\n    **\n    *************************************************************************\n    **  Included in SQLite3 port to C#-SQLite;  2008 Noah B Hart\n    **  C#-SQLite is an independent reimplementation of the SQLite software library\n    **\n    **  $Header$\n    *************************************************************************\n    */\n    //#include "sqliteInt.h"\n\n    /*\n    ** The code in this file only exists if we are not omitting the\n    ** ALTER TABLE logic from the build.\n    */\n#if !SQLITE_OMIT_ALTERTABLE\n\n\n    /*\n** This function is used by SQL generated to implement the\n** ALTER TABLE command. The first argument is the text of a CREATE TABLE or\n** CREATE INDEX command. The second is a table name. The table name in\n** the CREATE TABLE or CREATE INDEX statement is replaced with the third\n** argument and the result returned. Examples:\n**\n** sqlite_rename_table(\'CREATE TABLE abc(a, b, c)\', \'def\')\n**     . \'CREATE TABLE def(a, b, c)\'\n**\n** sqlite_rename_table(\'CREATE INDEX i ON abc(a)\', \'def\')\n**     . \'CREATE INDEX i ON def(a, b, c)\'\n*/\n    static void renameTableFunc(\n    sqlite3_context context,\n    int NotUsed,\n    sqlite3_value[] argv\n    )\n    {\n      string bResult = sqlite3_value_text( argv[0] );\n      string zSql = bResult == null ? "" : bResult;\n      string zTableName = sqlite3_value_text( argv[1] );\n\n      int token = 0;\n      Token tname = new Token();\n      int zCsr = 0;\n      int zLoc = 0;\n      int len = 0;\n      string zRet;\n\n      sqlite3 db = sqlite3_context_db_handle( context );\n\n      UNUSED_PARAMETER( NotUsed );\n\n      /* The principle used to locate the table name in the CREATE TABLE\n      ** statement is that the table name is the first non-space token that\n      ** is immediately followed by a TK_LP or TK_USING token.\n      */\n      if ( zSql != "" )\n      {\n        do\n        {\n          if ( zCsr == zSql.Length )\n          {\n            /* Ran out of input before finding an opening bracket. Return NULL. */\n            return;\n          }\n\n          /* Store the token that zCsr points to in tname. */\n          zLoc = zCsr;\n          tname.z = zSql.Substring( zCsr );//(char*)zCsr;\n          tname.n = len;\n\n          /* Advance zCsr to the next token. Store that token type in \'token\',\n          ** and its length in \'len\' (to be used next iteration of this loop).\n          */\n          do\n          {\n            zCsr += len;\n            len = ( zCsr == zSql.Length ) ? 1 : sqlite3GetToken( zSql, zCsr, ref token );\n          } while ( token == TK_SPACE );\n          Debug.Assert( len > 0 );\n        } while ( token != TK_LP && token != TK_USING );\n\n        zRet = sqlite3MPrintf( db, "%.*s\\"%w\\"%s", zLoc, zSql.Substring( 0, zLoc ),\n        zTableName, zSql.Substring( zLoc + tname.n ) );\n\n        sqlite3_result_text( context, zRet, -1, SQLITE_DYNAMIC );\n      }\n    }\n\n#if !SQLITE_OMIT_TRIGGER\n    /* This function is used by SQL generated to implement the\n** ALTER TABLE command. The first argument is the text of a CREATE TRIGGER\n** statement. The second is a table name. The table name in the CREATE\n** TRIGGER statement is replaced with the third argument and the result\n** returned. This is analagous to renameTableFunc() above, except for CREATE\n** TRIGGER, not CREATE INDEX and CREATE TABLE.\n*/\n    static void renameTriggerFunc(\n    sqlite3_context context,\n    int NotUsed,\n    sqlite3_value[] argv\n    )\n    {\n      string zSql = sqlite3_value_text( argv[0] );\n      string zTableName = sqlite3_value_text( argv[1] );\n\n      int token = 0;\n      Token tname = new Token();\n      int dist = 3;\n      int zCsr = 0;\n      int zLoc = 0;\n      int len = 1;\n      string zRet;\n\n      sqlite3 db = sqlite3_context_db_handle( context );\n\n      UNUSED_PARAMETER( NotUsed );\n\n      /* The principle used to locate the table name in the CREATE TRIGGER\n      ** statement is that the table name is the first token that is immediatedly\n      ** preceded by either TK_ON or TK_DOT and immediatedly followed by one\n      ** of TK_WHEN, TK_BEGIN or TK_FOR.\n      */\n      if ( zSql != null )\n      {\n        do\n        {\n\n          if ( zCsr == zSql.Length )\n          {\n            /* Ran out of input before finding the table name. Return NULL. */\n            return;\n          }\n\n          /* Store the token that zCsr points to in tname. */\n          zLoc = zCsr;\n          tname.z = zSql.Substring( zCsr, len );//(char*)zCsr;\n          tname.n = len;\n\n          /* Advance zCsr to the next token. Store that token type in \'token\',\n          ** and its length in \'len\' (to be used next iteration of this loop).\n          */\n          do\n          {\n            zCsr += len;\n            len = ( zCsr == zSql.Length ) ? 1 : sqlite3GetToken( zSql, zCsr, ref token );\n          } while ( token == TK_SPACE );\n          Debug.Assert( len > 0 );\n\n          /* Variable \'dist\' stores the number of tokens read since the most\n          ** recent TK_DOT or TK_ON. This means that when a WHEN, FOR or BEGIN\n          ** token is read and \'dist\' equals 2, the condition stated above\n          ** to be met.\n          **\n          ** Note that ON cannot be a database, table or column name, so\n          ** there is no need to worry about syntax like\n          ** "CREATE TRIGGER ... ON ON.ON BEGIN ..." etc.\n          */\n          dist++;\n          if ( token == TK_DOT || token == TK_ON )\n          {\n            dist = 0;\n          }\n        } while ( dist != 2 || ( token != TK_WHEN && token != TK_FOR && token != TK_BEGIN ) );\n\n        /* Variable tname now contains the token that is the old table-name\n        ** in the CREATE TRIGGER statement.\n        */\n        zRet = sqlite3MPrintf( db, "%.*s\\"%w\\"%s", zLoc, zSql.Substring( 0, zLoc ),\n        zTableName, zSql.Substring( zLoc + tname.n ) );\n        sqlite3_result_text( context, zRet, -1, SQLITE_DYNAMIC );\n      }\n    }\n#endif // * !SQLITE_OMIT_TRIGGER */\n\n    /*\n** Register built-in functions used to help implement ALTER TABLE\n*/\n    static void sqlite3AlterFunctions( sqlite3 db )\n    {\n      sqlite3CreateFunc( db, "sqlite_rename_table", 2, SQLITE_UTF8, 0,\n      renameTableFunc, null, null );\n#if !SQLITE_OMIT_TRIGGER\n      sqlite3CreateFunc( db, "sqlite_rename_trigger", 2, SQLITE_UTF8, 0,\n      renameTriggerFunc, null, null );\n#endif\n    }\n\n    /*\n    ** Generate the text of a WHERE expression which can be used to select all\n    ** temporary triggers on table pTab from the sqlite_temp_master table. If\n    ** table pTab has no temporary triggers, or is itself stored in the\n    ** temporary database, NULL is returned.\n    */\n    static string whereTempTriggers( Parse pParse, Table pTab )\n    {\n      Trigger pTrig;\n      string zWhere = "";\n      string tmp = "";\n      Schema pTempSchema = pParse.db.aDb[1].pSchema; /* Temp db schema */\n\n      /* If the table is not located in the temp.db (in which case NULL is\n      ** returned, loop through the tables list of triggers. For each trigger\n      ** that is not part of the temp.db schema, add a clause to the WHERE\n      ** expression being built up in zWhere.\n      */\n      if ( pTab.pSchema != pTempSchema )\n      {\n        sqlite3 db = pParse.db;\n        for ( pTrig = sqlite3TriggerList( pParse, pTab ) ; pTrig != null ; pTrig = pTrig.pNext )\n        {\n          if ( pTrig.pSchema == pTempSchema )\n          {\n            if ( zWhere == "" )\n            {\n              zWhere = sqlite3MPrintf( db, "name=%Q", pTrig.name );\n            }\n            else\n            {\n              tmp = zWhere;\n              zWhere = sqlite3MPrintf( db, "%s OR name=%Q", zWhere, pTrig.name );\n              //sqlite3DbFree( db, ref tmp );\n            }\n          }\n        }\n      }\n      return zWhere;\n    }\n\n    /*\n    ** Generate code to drop and reload the internal representation of table\n    ** pTab from the database, including triggers and temporary triggers.\n    ** Argument zName is the name of the table in the database schema at\n    ** the time the generated code is executed. This can be different from\n    ** pTab.zName if this function is being called to code part of an\n    ** "ALTER TABLE RENAME TO" statement.\n    */\n    static void reloadTableSchema( Parse pParse, Table pTab, string zName )\n    {\n      Vdbe v;\n      string zWhere;\n      int iDb;                   /* Index of database containing pTab */\n#if !SQLITE_OMIT_TRIGGER\n      Trigger pTrig;\n#endif\n\n      v = sqlite3GetVdbe( pParse );\n      if ( NEVER( v == null ) ) return;\n      Debug.Assert( sqlite3BtreeHoldsAllMutexes( pParse.db ) );\n      iDb = sqlite3SchemaToIndex( pParse.db, pTab.pSchema );\n      Debug.Assert( iDb >= 0 );\n\n#if !SQLITE_OMIT_TRIGGER\n      /* Drop any table triggers from the internal schema. */\n      for ( pTrig = sqlite3TriggerList( pParse, pTab ) ; pTrig != null ; pTrig = pTrig.pNext )\n      {\n        int iTrigDb = sqlite3SchemaToIndex( pParse.db, pTrig.pSchema );\n        Debug.Assert( iTrigDb == iDb || iTrigDb == 1 );\n        sqlite3VdbeAddOp4( v, OP_DropTrigger, iTrigDb, 0, 0, pTrig.name, 0 );\n      }\n#endif\n\n      /* Drop the table and index from the internal schema */\n      sqlite3VdbeAddOp4( v, OP_DropTable, iDb, 0, 0, pTab.zName, 0 );\n\n      /* Reload the table, index and permanent trigger schemas. */\n      zWhere = sqlite3MPrintf( pParse.db, "tbl_name=%Q", zName );\n      if ( zWhere == null ) return;\n      sqlite3VdbeAddOp4( v, OP_ParseSchema, iDb, 0, 0, zWhere, P4_DYNAMIC );\n\n#if !SQLITE_OMIT_TRIGGER\n      /* Now, if the table is not stored in the temp database, reload any temp\n** triggers. Don\'t use IN(...) in case SQLITE_OMIT_SUBQUERY is defined.\n*/\n      if ( ( zWhere = whereTempTriggers( pParse, pTab ) ) != "" )\n      {\n        sqlite3VdbeAddOp4( v, OP_ParseSchema, 1, 0, 0, zWhere, P4_DYNAMIC );\n      }\n#endif\n    }\n\n    /*\n    ** Generate code to implement the "ALTER TABLE xxx RENAME TO yyy"\n    ** command.\n    */\n    static void sqlite3AlterRenameTable(\n    Parse pParse,             /* Parser context. */\n    SrcList pSrc,             /* The table to rename. */\n    Token pName               /* The new table name. */\n    )\n    {\n      int iDb;                  /* Database that contains the table */\n      string zDb;               /* Name of database iDb */\n      Table pTab;               /* Table being renamed */\n      string zName = null;      /* NULL-terminated version of pName */\n      sqlite3 db = pParse.db;   /* Database connection */\n      int nTabName;             /* Number of UTF-8 characters in zTabName */\n      string zTabName;          /* Original name of the table */\n      Vdbe v;\n#if !SQLITE_OMIT_TRIGGER\n      string zWhere = "";       /* Where clause to locate temp triggers */\n#endif\n      VTable pVTab = null;         /* Non-zero if this is a v-tab with an xRename() */\n\n      //if ( NEVER( db.mallocFailed != 0 ) ) goto exit_rename_table;\n      Debug.Assert( pSrc.nSrc == 1 );\n      Debug.Assert( sqlite3BtreeHoldsAllMutexes( pParse.db ) );\n      pTab = sqlite3LocateTable( pParse, 0, pSrc.a[0].zName, pSrc.a[0].zDatabase );\n      if ( pTab == null ) goto exit_rename_table;\n      iDb = sqlite3SchemaToIndex( pParse.db, pTab.pSchema );\n      zDb = db.aDb[iDb].zName;\n\n      /* Get a NULL terminated version of the new table name. */\n      zName = sqlite3NameFromToken( db, pName );\n      if ( zName == null ) goto exit_rename_table;\n\n      /* Check that a table or index named \'zName\' does not already exist\n      ** in database iDb. If so, this is an error.\n      */\n      if ( sqlite3FindTable( db, zName, zDb ) != null || sqlite3FindIndex( db, zName, zDb ) != null )\n      {\n        sqlite3ErrorMsg( pParse,\n        "there is already another table or index with this name: %s", zName );\n        goto exit_rename_table;\n      }\n\n      /* Make sure it is not a system table being altered, or a reserved name\n      ** that the table is being renamed to.\n      */\n      if ( sqlite3Strlen30( pTab.zName ) > 6\n      && 0 == sqlite3StrNICmp( pTab.zName, "sqlite_", 7 )\n      )\n      {\n        sqlite3ErrorMsg( pParse, "table %s may not be altered", pTab.zName );\n        goto exit_rename_table;\n      }\n      if ( SQLITE_OK != sqlite3CheckObjectName( pParse, zName ) )\n      {\n        goto exit_rename_table;\n      }\n\n#if !SQLITE_OMIT_VIEW\n      if ( pTab.pSelect != null )\n      {\n        sqlite3ErrorMsg( pParse, "view %s may not be altered", pTab.zName );\n        goto exit_rename_table;\n      }\n#endif\n\n#if !SQLITE_OMIT_AUTHORIZATION\n/* Invoke the authorization callback. */\nif( sqlite3AuthCheck(pParse, SQLITE_ALTER_TABLE, zDb, pTab.zName, 0) ){\ngoto exit_rename_table;\n}\n#endif\n\n      if ( sqlite3ViewGetColumnNames( pParse, pTab ) != 0 )\n      {\n        goto exit_rename_table;\n      }\n#if !SQLITE_OMIT_VIRTUALTABLE\n  if( IsVirtual(pTab) ){\n    pVTab = sqlite3GetVTable(db, pTab);\n    if( pVTab.pVtab.pModule.xRename==null ){\n      pVTab = null;\n    }\n#endif\n      /* Begin a transaction and code the VerifyCookie for database iDb.\n** Then modify the schema cookie (since the ALTER TABLE modifies the\n** schema). Open a statement transaction if the table is a virtual\n** table.\n*/\n      v = sqlite3GetVdbe( pParse );\n      if ( v == null )\n      {\n        goto exit_rename_table;\n      }\n      sqlite3BeginWriteOperation( pParse, pVTab != null ? 1 : 0, iDb );\n      sqlite3ChangeCookie( pParse, iDb );\n\n      /* If this is a virtual table, invoke the xRename() function if\n      ** one is defined. The xRename() callback will modify the names\n      ** of any resources used by the v-table implementation (including other\n      ** SQLite tables) that are identified by the name of the virtual table.\n      */\n#if  !SQLITE_OMIT_VIRTUALTABLE\nif ( pVTab !=null)\n{\nint i = ++pParse.nMem;\nsqlite3VdbeAddOp4( v, OP_String8, 0, i, 0, zName, 0 );\nsqlite3VdbeAddOp4( v, OP_VRename, i, 0, 0, pVtab, P4_VTAB );\n}\n#endif\n\n      /* figure out how many UTF-8 characters are in zName */\n      zTabName = pTab.zName;\n      nTabName = sqlite3Utf8CharLen( zTabName, -1 );\n\n      /* Modify the sqlite_master table to use the new table name. */\n      sqlite3NestedParse( pParse,\n      "UPDATE %Q.%s SET " +\n#if SQLITE_OMIT_TRIGGER\n"sql = sqlite_rename_table(sql, %Q), "+\n#else\n "sql = CASE " +\n      "WHEN type = \'trigger\' THEN sqlite_rename_trigger(sql, %Q)" +\n      "ELSE sqlite_rename_table(sql, %Q) END, " +\n#endif\n "tbl_name = %Q, " +\n      "name = CASE " +\n      "WHEN type=\'table\' THEN %Q " +\n      "WHEN name LIKE \'sqlite_autoindex%%\' AND type=\'index\' THEN " +\n      "\'sqlite_autoindex_\' || %Q || substr(name,%d+18) " +\n      "ELSE name END " +\n      "WHERE tbl_name=%Q AND " +\n      "(type=\'table\' OR type=\'index\' OR type=\'trigger\');",\n      zDb, SCHEMA_TABLE( iDb ), zName, zName, zName,\n#if !SQLITE_OMIT_TRIGGER\n zName,\n#endif\n zName, nTabName, zTabName\n      );\n\n#if !SQLITE_OMIT_AUTOINCREMENT\n      /* If the sqlite_sequence table exists in this database, then update\n** it with the new table name.\n*/\n      if ( sqlite3FindTable( db, "sqlite_sequence", zDb ) != null )\n      {\n        sqlite3NestedParse( pParse,\n        "UPDATE \\"%w\\".sqlite_sequence set name = %Q WHERE name = %Q",\n        zDb, zName, pTab.zName\n        );\n      }\n#endif\n\n#if !SQLITE_OMIT_TRIGGER\n      /* If there are TEMP triggers on this table, modify the sqlite_temp_master\n** table. Don\'t do this if the table being ALTERed is itself located in\n** the temp database.\n*/\n      if ( ( zWhere = whereTempTriggers( pParse, pTab ) ) != "" )\n      {\n        sqlite3NestedParse( pParse,\n        "UPDATE sqlite_temp_master SET " +\n        "sql = sqlite_rename_trigger(sql, %Q), " +\n        "tbl_name = %Q " +\n        "WHERE %s;", zName, zName, zWhere );\n        //sqlite3DbFree( db, ref zWhere );\n      }\n#endif\n\n      /* Drop and reload the internal table schema. */\n      reloadTableSchema( pParse, pTab, zName );\n\nexit_rename_table:\n      sqlite3SrcListDelete( db, ref pSrc );\n      //sqlite3DbFree( db, ref zName );\n    }\n\n    /*\n    ** Generate code to make sure the file format number is at least minFormat.\n    ** The generated code will increase the file format number if necessary.\n    */\n    static void sqlite3MinimumFileFormat( Parse pParse, int iDb, int minFormat )\n    {\n      Vdbe v;\n      v = sqlite3GetVdbe( pParse );\n      /* The VDBE should have been allocated before this routine is called.\n      ** If that allocation failed, we would have quit before reaching this\n      ** point */\n      if ( ALWAYS( v ) )\n      {\n        int r1 = sqlite3GetTempReg( pParse );\n        int r2 = sqlite3GetTempReg( pParse );\n        int j1;\n        sqlite3VdbeAddOp3( v, OP_ReadCookie, iDb, r1, BTREE_FILE_FORMAT );\n        sqlite3VdbeUsesBtree( v, iDb );\n        sqlite3VdbeAddOp2( v, OP_Integer, minFormat, r2 );\n        j1 = sqlite3VdbeAddOp3( v, OP_Ge, r2, 0, r1 );\n        sqlite3VdbeAddOp3( v, OP_SetCookie, iDb, BTREE_FILE_FORMAT, r2 );\n        sqlite3VdbeJumpHere( v, j1 );\n        sqlite3ReleaseTempReg( pParse, r1 );\n        sqlite3ReleaseTempReg( pParse, r2 );\n      }\n    }\n\n    /*\n    ** This function is called after an "ALTER TABLE ... ADD" statement\n    ** has been parsed. Argument pColDef contains the text of the new\n    ** column definition.\n    **\n    ** The Table structure pParse.pNewTable was extended to include\n    ** the new column during parsing.\n    */\n    static void sqlite3AlterFinishAddColumn( Parse pParse, Token pColDef )\n    {\n      Table pNew;              /* Copy of pParse.pNewTable */\n      Table pTab;              /* Table being altered */\n      int iDb;                 /* Database number */\n      string zDb;              /* Database name */\n      string zTab;             /* Table name */\n      string zCol;             /* Null-terminated column definition */\n      Column pCol;             /* The new column */\n      Expr pDflt;              /* Default value for the new column */\n      sqlite3 db;              /* The database connection; */\n\n      db = pParse.db;\n      if ( pParse.nErr != 0 /*|| db.mallocFailed != 0 */ ) return;\n      pNew = pParse.pNewTable;\n      Debug.Assert( pNew != null );\n      Debug.Assert( sqlite3BtreeHoldsAllMutexes( db ) );\n      iDb = sqlite3SchemaToIndex( db, pNew.pSchema );\n      zDb = db.aDb[iDb].zName;\n      zTab = pNew.zName.Substring( 16 );// zTab = &pNew->zName[16]; /* Skip the "sqlite_altertab_" prefix on the name */\n      pCol = pNew.aCol[pNew.nCol - 1];\n      pDflt = pCol.pDflt;\n      pTab = sqlite3FindTable( db, zTab, zDb );\n      Debug.Assert( pTab != null );\n\n#if !SQLITE_OMIT_AUTHORIZATION\n/* Invoke the authorization callback. */\nif( sqlite3AuthCheck(pParse, SQLITE_ALTER_TABLE, zDb, pTab.zName, 0) ){\nreturn;\n}\n#endif\n\n      /* If the default value for the new column was specified with a\n** literal NULL, then set pDflt to 0. This simplifies checking\n** for an SQL NULL default below.\n*/\n      if ( pDflt != null && pDflt.op == TK_NULL )\n      {\n        pDflt = null;\n      }\n\n      /* Check that the new column is not specified as PRIMARY KEY or UNIQUE.\n      ** If there is a NOT NULL constraint, then the default value for the\n      ** column must not be NULL.\n      */\n      if ( pCol.isPrimKey != 0 )\n      {\n        sqlite3ErrorMsg( pParse, "Cannot add a PRIMARY KEY column" );\n        return;\n      }\n      if ( pNew.pIndex != null )\n      {\n        sqlite3ErrorMsg( pParse, "Cannot add a UNIQUE column" );\n        return;\n      }\n      if ( pCol.notNull != 0 && pDflt == null )\n      {\n        sqlite3ErrorMsg( pParse,\n        "Cannot add a NOT NULL column with default value NULL" );\n        return;\n      }\n\n      /* Ensure the default expression is something that sqlite3ValueFromExpr()\n      ** can handle (i.e. not CURRENT_TIME etc.)\n      */\n      if ( pDflt != null )\n      {\n        sqlite3_value pVal = null;\n        if ( sqlite3ValueFromExpr( db, pDflt, SQLITE_UTF8, SQLITE_AFF_NONE, ref pVal ) != 0 )\n        {\n  //        db.mallocFailed = 1;\n          return;\n        }\n        if ( pVal == null )\n        {\n          sqlite3ErrorMsg( pParse, "Cannot add a column with non-constant default" );\n          return;\n        }\n        sqlite3ValueFree( ref pVal );\n      }\n\n      /* Modify the CREATE TABLE statement. */\n      zCol = pColDef.z.Substring( 0, pColDef.n ).Replace( ";", " " ).Trim();//sqlite3DbStrNDup(db, (char*)pColDef.z, pColDef.n);\n      if ( zCol != null )\n      {\n        //  char zEnd = zCol[pColDef.n-1];\n        //      while( zEnd>zCol && (*zEnd==\';\' || sqlite3Isspace(*zEnd)) ){\n        //    zEnd-- = \'\\0\';\n        //  }\n        sqlite3NestedParse( pParse,\n        "UPDATE \\"%w\\".%s SET " +\n        "sql = substr(sql,1,%d) || \', \' || %Q || substr(sql,%d) " +\n        "WHERE type = \'table\' AND name = %Q",\n        zDb, SCHEMA_TABLE( iDb ), pNew.addColOffset, zCol, pNew.addColOffset + 1,\n        zTab\n        );\n        //sqlite3DbFree( db, ref zCol );\n      }\n\n      /* If the default value of the new column is NULL, then set the file\n      ** format to 2. If the default value of the new column is not NULL,\n      ** the file format becomes 3.\n      */\n      sqlite3MinimumFileFormat( pParse, iDb, pDflt != null ? 3 : 2 );\n\n      /* Reload the schema of the modified table. */\n      reloadTableSchema( pParse, pTab, pTab.zName );\n    }\n\n    /*\n    ** This function is called by the parser after the table-name in\n    ** an "ALTER TABLE <table-name> ADD" statement is parsed. Argument\n    ** pSrc is the full-name of the table being altered.\n    **\n    ** This routine makes a (partial) copy of the Table structure\n    ** for the table being altered and sets Parse.pNewTable to point\n    ** to it. Routines called by the parser as the column definition\n    ** is parsed (i.e. sqlite3AddColumn()) add the new Column data to\n    ** the copy. The copy of the Table structure is deleted by tokenize.c\n    ** after parsing is finished.\n    **\n    ** Routine sqlite3AlterFinishAddColumn() will be called to complete\n    ** coding the "ALTER TABLE ... ADD" statement.\n    */\n    static void sqlite3AlterBeginAddColumn( Parse pParse, SrcList pSrc )\n    {\n      Table pNew;\n      Table pTab;\n      Vdbe v;\n      int iDb;\n      int i;\n      int nAlloc;\n      sqlite3 db = pParse.db;\n\n      /* Look up the table being altered. */\n      Debug.Assert( pParse.pNewTable == null );\n      Debug.Assert( sqlite3BtreeHoldsAllMutexes( db ) );\n//      if ( db.mallocFailed != 0 ) goto exit_begin_add_column;\n      pTab = sqlite3LocateTable( pParse, 0, pSrc.a[0].zName, pSrc.a[0].zDatabase );\n      if ( pTab == null ) goto exit_begin_add_column;\n\n      if ( IsVirtual( pTab ) )\n      {\n        sqlite3ErrorMsg( pParse, "virtual tables may not be altered" );\n        goto exit_begin_add_column;\n      }\n\n      /* Make sure this is not an attempt to ALTER a view. */\n      if ( pTab.pSelect != null )\n      {\n        sqlite3ErrorMsg( pParse, "Cannot add a column to a view" );\n        goto exit_begin_add_column;\n      }\n\n      Debug.Assert( pTab.addColOffset > 0 );\n      iDb = sqlite3SchemaToIndex( db, pTab.pSchema );\n\n      /* Put a copy of the Table struct in Parse.pNewTable for the\n      ** sqlite3AddColumn() function and friends to modify.  But modify\n      ** the name by adding an "sqlite_altertab_" prefix.  By adding this\n      ** prefix, we insure that the name will not collide with an existing\n      ** table because user table are not allowed to have the "sqlite_"\n      ** prefix on their name.\n      */\n      pNew = new Table();// (Table*)sqlite3DbMallocZero( db, sizeof(Table))\n      if ( pNew == null ) goto exit_begin_add_column;\n      pParse.pNewTable = pNew;\n      pNew.nRef = 1;\n      pNew.dbMem = pTab.dbMem;\n      pNew.nCol = pTab.nCol;\n      Debug.Assert( pNew.nCol > 0 );\n      nAlloc = ( ( ( pNew.nCol - 1 ) / 8 ) * 8 ) + 8;\n      Debug.Assert( nAlloc >= pNew.nCol && nAlloc % 8 == 0 && nAlloc - pNew.nCol < 8 );\n      pNew.aCol = new Column[nAlloc];// (Column*)sqlite3DbMallocZero( db, sizeof(Column) * nAlloc );\n      pNew.zName = sqlite3MPrintf( db, "sqlite_altertab_%s", pTab.zName );\n      if ( pNew.aCol == null || pNew.zName == null )\n      {\n//        db.mallocFailed = 1;\n        goto exit_begin_add_column;\n      }\n      // memcpy( pNew.aCol, pTab.aCol, sizeof(Column) * pNew.nCol );\n      for ( i = 0 ; i < pNew.nCol ; i++ )\n      {\n        Column pCol = pTab.aCol[i].Copy();\n        // sqlite3DbStrDup( db, pCol.zName );\n        pCol.zColl = null;\n        pCol.zType = null;\n        pCol.pDflt = null;\n        pCol.zDflt = null;\n        pNew.aCol[i] = pCol;\n      }\n      pNew.pSchema = db.aDb[iDb].pSchema;\n      pNew.addColOffset = pTab.addColOffset;\n      pNew.nRef = 1;\n\n      /* Begin a transaction and increment the schema cookie.  */\n      sqlite3BeginWriteOperation( pParse, 0, iDb );\n      v = sqlite3GetVdbe( pParse );\n      if ( v == null ) goto exit_begin_add_column;\n      sqlite3ChangeCookie( pParse, iDb );\n\nexit_begin_add_column:\n      sqlite3SrcListDelete( db, ref pSrc );\n      return;\n    }\n#endif  // * SQLITE_ALTER_TABLE */\n  }\n}\n'