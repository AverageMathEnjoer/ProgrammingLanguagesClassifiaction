b'module Profile where\n\nimport Data.List (sort, group, transpose, unionBy, genericLength)\nimport Data.Function (on)\nimport Control.Applicative ((<$>), (<*>))\n\nimport MolSeq\n\n-- Exercise 1:\ndata Profile = Profile { profileType :: SeqType\n                       , profileName :: String\n                       , profileSeqs :: Int\n                       , getMatrix :: [[Double]]\n                       } deriving Show\n\n\ntype AssocList key value = [(key, value)]\n\nmakeProfileMatrix :: [MolSeq] -> [AssocList Char Int]\nmakeProfileMatrix [] = error "Empty sequence list"\nmakeProfileMatrix seqs = res\n  where\n    t = seqType (head seqs)\n    n = length seqs\n    -- Sets the frequency to 0 for each letter while creating an association list\n    defaults = zip (alphabet t) $ replicate (length (alphabet t)) 0\n    strs = map seqSequence seqs\n    -- Compress a list of identical values by turning it into an (element, length) pair\n    compress = (,) <$> head <*> length\n    --     For a collection of letters at position n in every sequence,\n    --       make a separate list for each character\n    --       and compress it to a list of (character, occurrences) pairs\n    -- The result is a list of the (character, occurrences) pairs for every\n    -- position in the profile.\n    tmp1 = map (map compress . group . sort) $ transpose strs\n    -- Merge two association lists by their keys, retaining the values from the last one\n    -- in case of collisions\n    merge = unionBy ((==) `on` fst)\n    -- Combine the results from the previous steps with the default value 0\n    -- for letters that didn\'t occur. Order of arguments to unionBy is important,\n    -- since otherwise the attained results would be thrown away.\n    -- Then a sort is applied so that the resulting association list is in the right order.\n    res = map sort . map (flip merge defaults) $ tmp1\n\n\n-- Exercise 2:\nfromMolSeqs :: [MolSeq] -> Profile\nfromMolSeqs seqs@(MolSeq st tn _ : _) =\n  Profile st tn (length seqs) $ normalise (makeProfileMatrix seqs)\n  where\n    -- Pick out the number from the association list and divide it by the\n    -- number of sequences to create a profile matrix of Doubles\n    normalise = map . map $ (/genericLength seqs) . fromIntegral . snd\n\n\n-- Exercise 3:\nprofileDistance :: Profile -> Profile -> Double\n-- For both arguments, get their profile matrix and flatten it. Take the difference\n-- of the matrices element-wise and then sum said differences.\nprofileDistance = sum .: zipWith difference `on` concat . getMatrix\n  where difference = abs .: subtract\n        (.:) = (.).(.)\n\n\n\n '