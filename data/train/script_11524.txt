b'#pragma once\n#include "lz4dec.h"\n#include <stddef.h>\n#include <string.h>\n\n#ifdef _MSC_VER    /* Visual Studio */\n#  include <intrin.h>\n#  pragma warning(disable : 4127)        /* disable: C4127: conditional expression is constant */\n#  pragma warning(disable : 4293)        /* disable: C4293: too large shift (32-bits) */\n#endif  /* _MSC_VER */\n\n#ifndef FORCE_INLINE\n#  ifdef _MSC_VER    /* Visual Studio */\n#    define FORCE_INLINE static __forceinline\n#  else\n#    if defined (__cplusplus) || defined (__STDC_VERSION__) && __STDC_VERSION__ >= 199901L   /* C99 */\n#      ifdef __GNUC__\n#        define FORCE_INLINE static inline __attribute__((always_inline))\n#      else\n#        define FORCE_INLINE static inline\n#      endif\n#    else\n#      define FORCE_INLINE static\n#    endif /* __STDC_VERSION__ */\n#  endif  /* _MSC_VER */\n#endif /* FORCE_INLINE */\n\n//Branch optimization stuff (expected scenario == true for likely, false for unlikely).\n#if (defined(__GNUC__) && (__GNUC__ >= 3)) || (defined(__INTEL_COMPILER) && (__INTEL_COMPILER >= 800)) || defined(__clang__)\n#  define expect(expr,value)    (__builtin_expect ((expr),(value)) )\n#else\n#  define expect(expr,value)    (expr)\n#endif\n\n#define likely(expr)     expect((expr) != 0, 1)\n#define unlikely(expr)   expect((expr) != 0, 0)\n\n\n/*-************************************\n*  Basic Types\n**************************************/\n#if defined(__cplusplus) || (defined (__STDC_VERSION__) && (__STDC_VERSION__ >= 199901L) /* C99 */)\n# include <stdint.h>\n  typedef  uint8_t BYTE;\n  typedef uint16_t U16;\n  typedef uint32_t U32;\n  typedef  int32_t S32;\n  typedef uint64_t U64;\n  typedef uintptr_t uptrval;\n#else\n  typedef unsigned char       BYTE;\n  typedef unsigned short      U16;\n  typedef unsigned int        U32;\n  typedef   signed int        S32;\n  typedef unsigned long long  U64;\n  typedef size_t              uptrval;   /* generally true, except OpenVMS-64 */\n#endif\n\n/*-************************************\n*  Common Constants\n**************************************/\n#define MINMATCH 4\n\n#define WILDCOPYLENGTH 8\n#define LASTLITERALS 5\n#define MFLIMIT (WILDCOPYLENGTH+MINMATCH)\nstatic const int LZ4_minLength = (MFLIMIT+1);\n\n#define KB *(1 <<10)\n#define MB *(1 <<20)\n#define GB *(1U<<30)\n\n#define MAXD_LOG 16\n#define MAX_DISTANCE ((1 << MAXD_LOG) - 1)\n\n#define ML_BITS  4\n#define ML_MASK  ((1U<<ML_BITS)-1)\n#define RUN_BITS (8-ML_BITS)\n#define RUN_MASK ((1U<<RUN_BITS)-1)\n\n/*-************************************\n*  Local Structures and types\n**************************************/\ntypedef enum { notLimited = 0, limitedOutput = 1 } limitedOutput_directive;\ntypedef enum { byPtr, byU32, byU16 } tableType_t;\n\ntypedef enum { noDict = 0, withPrefix64k, usingExtDict } dict_directive;\ntypedef enum { noDictIssue = 0, dictSmall } dictIssue_directive;\n\ntypedef enum { endOnOutputSize = 0, endOnInputSize = 1 } endCondition_directive;\ntypedef enum { full = 0, partial = 1 } earlyEnd_directive;\n\n/*******************************\n*  Decompression functions\n*******************************/\nstatic U16 LZ4_read16(const void* memPtr) { return *(const U16*) memPtr; }\n\nstatic unsigned LZ4_isLittleEndian(void)\n{\n    const union { U32 u; BYTE c[4]; } one = { 1 };   /* don\'t use static : performance detrimental */\n    return one.c[0];\n}\n\nstatic void LZ4_write32(void* memPtr, U32 value)\n{\n    memcpy(memPtr, &value, sizeof(value));\n}\n\nstatic U16 LZ4_readLE16(const void* memPtr)\n{\n    if (LZ4_isLittleEndian()) {\n        return LZ4_read16(memPtr);\n    } else {\n        const BYTE* p = (const BYTE*)memPtr;\n        return (U16)((U16)p[0] + (p[1]<<8));\n    }\n}\nstatic void LZ4_copy8(void* dst, const void* src)\n{\n    memcpy(dst,src,8);\n}\n/* customized variant of memcpy, which can overwrite up to 8 bytes beyond dstEnd */\nstatic void LZ4_wildCopy(void* dstPtr, const void* srcPtr, void* dstEnd)\n{\n    BYTE* d = (BYTE*)dstPtr;\n    const BYTE* s = (const BYTE*)srcPtr;\n    BYTE* const e = (BYTE*)dstEnd;\n\n    do { LZ4_copy8(d,s); d+=8; s+=8; } while (d<e);\n}\n\n//Returns the bytes read.\nstatic int LZ4e_inputBuffer(BYTE* istart, BYTE* ip, BYTE* imax, LZ4e_instream_t* inStream)\n{\n\tinStream->pos += (ip-istart);\n\treturn inStream->callback(istart, imax-istart, inStream);\n}\n//Flushes all written data and keeps the last written 64KiB (dictionary) at ostart.\n//Returns the new dictionary size (max. 64KiB), or returns omax - ostart on error.\nstatic int LZ4e_outputBuffer(BYTE* ostart, BYTE* op, BYTE* omax, BYTE* odend, LZ4e_outstream_t* outStream)\n{\n\tif (op < odend)\n\t\treturn omax - ostart;\n\tif (outStream->callback(odend, op-odend, outStream) < op-odend)\n\t\treturn omax - ostart;\n\n\tint newDictionarySize = 0;\n\tint curDataSize = op - ostart;\n\tif (curDataSize > 64 KB)\n\t{\n\t\tmemmove(ostart, op - (64 KB), 64 KB);\n\t\tnewDictionarySize = 64 KB;\n\t}\n\telse\n\t{\n\t\tnewDictionarySize = curDataSize;\n\t}\n\treturn newDictionarySize;\n}\n\nstatic int LZ4_decompress_generic(\n                 char* const sourceBuf,\n                 char* const destBuf,\n                 int inputBufSize,\n                 int outputBufSize,         /* If endOnInput==endOnInputSize, this value is the max size of Output Buffer. */\n\n                 int endOnInput,         /* endOnOutputSize, endOnInputSize */\n\n\t\t\t\t LZ4e_instream_t* inStream,\n\t\t\t\t LZ4e_outstream_t* outStream\n                 )\n{\n    /* Local Variables */\n    BYTE* const istart = (BYTE*) sourceBuf;\n    BYTE* ip = istart;\n    BYTE* iend = istart + 0;\n    BYTE* const imax = istart + inputBufSize - 8;\n\t\n    BYTE* const ostart = (BYTE*) destBuf;\n    BYTE* op = ostart;\n\tBYTE* odend = ostart + 0; //dictionary end\n    BYTE* const omax = ostart + outputBufSize - 8;\n\n    BYTE* cpy;\n    const BYTE* const lowLimit = ostart;\n\n    const unsigned dec32table[] = {0, 1, 2, 1, 4, 4, 4, 4};\n    const int dec64table[] = {0, 0, 0, -1, 0, 1, 2, 3};\n\n    const int safeDecode = (endOnInput==endOnInputSize);\n    const int checkOffset = (safeDecode);\n\n\tif (outputBufSize < (28 + 64 KB)) return -1;\n\tif (inputBufSize < 16) return -1;\n\n    /* Main Loop : decode sequences */\n    while (1) {\n        size_t length;\n        const BYTE* match;\n        size_t offset;\n\n\t\tif (unlikely(iend-ip==0))\n\t\t{\n\t\t\tiend = istart + LZ4e_inputBuffer(istart, ip, imax, inStream);\n\t\t\tip = istart;\n\t\t\tif (unlikely(iend-ip==0)) {\n\t\t\t\tgoto _output_error;  /* overflow detection */\n\t\t\t}\n\t\t}\n        /* get literal length */\n        unsigned const token = *ip++;\n        if ((length=(token>>ML_BITS)) == RUN_MASK) {\n            unsigned s;\n            do {\n\t\t\t\tif (unlikely(ip+RUN_MASK+1>=iend)) {\n\t\t\t\t\tiend = istart + LZ4e_inputBuffer(istart, ip, imax, inStream);\n\t\t\t\t\tip = istart;\n\t\t\t\t\tif (unlikely(iend==istart)) {\n\t\t\t\t\t\tgoto _output_error;\n\t\t\t\t\t}\n\t\t\t\t}\n                s = *ip++;\n                length += s;\n            } while ( likely(endOnInput ? ip<iend-RUN_MASK : 1) & (s==255) );\n            if ((safeDecode) && unlikely((uptrval)(op)+length<(uptrval)(op))) {\n\t\t\t\tgoto _output_error;   /* overflow detection */\n\t\t\t}\n            if ((safeDecode) && unlikely((uptrval)(ip)+length<(uptrval)(ip))) {\n\t\t\t\tgoto _output_error;   /* overflow detection */\n\t\t\t}\n        }\n\n        /* copy literals */\n\t\twhile (length)\n\t\t{\n\t\t\tsize_t ci = (ip+length>iend)?(iend-ip):(length);\n\t\t\tsize_t c;\n\t\t\tif (!ci) {\n\t\t\t\tiend = istart + LZ4e_inputBuffer(istart, ip, imax, inStream);\n\t\t\t\tip = istart;\n\t\t\t\tif (unlikely(iend==istart)) {\n\t\t\t\t\tgoto _output_error;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tc = (op+ci>omax)?(omax-op):(ci);\n\t\t\tif (!c) {\n\t\t\t\todend = ostart + LZ4e_outputBuffer(ostart, op, omax, odend, outStream);\n\t\t\t\top = odend;\n\t\t\t\tif (unlikely(odend==omax)) {\n\t\t\t\t\tgoto _output_error;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tLZ4_wildCopy(op, ip, op+c);\n\t\t\tip += c; op += c;\n\t\t\tlength -= c;\n\t\t}\n\n\t\t//Compressed data may end here.\n\t\tif (unlikely(ip+2>iend)) {\n\t\t\tiend = istart + LZ4e_inputBuffer(istart, ip, imax, inStream);\n\t\t\tip = istart;\n\t\t\tif ((iend-ip)<2) //(unlikely((iend-ip)<3))\n\t\t\t{\n\t\t\t\t//Only throw an error if there still are bytes to copy.\n\t\t\t\tif ((token & ML_MASK) != 0) {\n\t\t\t\t\tgoto _output_error;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (unlikely(op+20>omax)) {\n\t\t\todend = ostart + LZ4e_outputBuffer(ostart, op, omax, odend, outStream);\n\t\t\top = odend;\n\t\t\tif (unlikely(odend==omax)) {\n\t\t\t\tgoto _output_error;\n\t\t\t}\n\t\t}\n\n        /* get offset */\n        offset = LZ4_readLE16(ip); ip+=2;\n        match = op - offset;\n        if ((checkOffset) && (unlikely(match < lowLimit))) {\n\t\t\tgoto _output_error;   /* Error : offset outside buffers */\n\t\t}\n        LZ4_write32(op, (U32)offset);   /* costs ~1%; silence an msan warning when offset==0 */\n\n        /* get matchlength */\n        length = token & ML_MASK;\n        if (length == ML_MASK) {\n            unsigned s;\n            do {\n\t\t\t\tif (unlikely(ip+LASTLITERALS>iend)) {\n\t\t\t\t\tiend = istart + LZ4e_inputBuffer(istart, ip, imax, inStream);\n\t\t\t\t\tip = istart;\n\t\t\t\t\tif (unlikely(ip+LASTLITERALS>iend)) {\n\t\t\t\t\t\tgoto _output_error;\n\t\t\t\t\t}\n\t\t\t\t\t//if ((endOnInput) && (ip > iend-LASTLITERALS)) goto _output_error;\n\t\t\t\t}\n                s = *ip++;\n                length += s;\n            } while (s==255);\n            if ((safeDecode) && unlikely((uptrval)(op)+length<(uptrval)op)) {\n\t\t\t\tgoto _output_error;   /* overflow detection */\n\t\t\t}\n        }\n        length += MINMATCH;\n\t\t//As the dictionary boundaries shift with each byte written, the values copied from match can be beyond the current output pointer.\n\t\t//This is no issue since it can never exceed the output buffer location that also moves on in the same \'speed\' as the match location while copying.\n\n        /* copy match within block */\n        cpy = op + length;\n        if (unlikely(offset<8)) {\n            const int dec64 = dec64table[offset];\n            op[0] = match[0];\n            op[1] = match[1];\n            op[2] = match[2];\n            op[3] = match[3];\n            match += dec32table[offset];\n            memcpy(op+4, match, 4);\n            match -= dec64;\n        } else { LZ4_copy8(op, match); match+=8; }\n        op += 8;\n\n        {\n            LZ4_copy8(op, match); \n\t\t\top += 8; match += 8; \n\t\t\tif (length > 16)\n\t\t\t{\n\t\t\t\tlength -= 16;\n\t\t\t\twhile (length)\n\t\t\t\t{\n\t\t\t\t\tsize_t c = (op+length>omax)?(omax-op):(length);\n\t\t\t\t\tif (!c) {\n\t\t\t\t\t\tsize_t oldOffs = cpy - op;\n\t\t\t\t\t\todend = ostart + LZ4e_outputBuffer(ostart, op, omax, odend, outStream);\n\t\t\t\t\t\tif (unlikely(odend==omax)) {\n\t\t\t\t\t\t\tgoto _output_error;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmatch -= op-odend;\n\t\t\t\t\t\top = odend;\n\t\t\t\t\t\tcpy = op + oldOffs;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tLZ4_wildCopy(op, match, op+c);\n\t\t\t\t\top += c; match += c;\n\t\t\t\t\tlength -= c;\n\t\t\t\t}\n\t\t\t}\n        }\n        op=cpy;   /* correction */\n\n\n    }\n\t\n    /* end of decoding */\n    //if (endOnInput)\n    //   return (int) (((char*)op)-dest);     /* Nb of output bytes decoded */\n    //else\n    //   return (int) (((const char*)ip)-source);   /* Nb of input bytes read */\n\tinStream->pos += (ip - istart);\n\treturn LZ4e_outputBuffer(ostart, op, omax, odend, outStream) != (omax-ostart);\n    /* Overflow error detected */\n_output_error:\n    return (int) (-(((const char*)ip)-sourceBuf))-1;\n}\n\n\nint LZ4e_decompress_safe(char* sourceBuf, char* destBuf, int sourceBufSize, int destBufSize, LZ4e_instream_t* inStream, LZ4e_outstream_t* outStream)\n{\n    return LZ4_decompress_generic(sourceBuf, destBuf, sourceBufSize, destBufSize, endOnInputSize, inStream, outStream);\n}'