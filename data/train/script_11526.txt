b'// Copyright (c) 2022 Manuel Schneider\n\n#include "albert/util/timeprinter.hpp"\n#include "extensions/globalqueryhandlerprivate.h"\n#include "globalsearch.h"\n#include "query.h"\n#include <QtConcurrent>\n#include <cmath>\nusing namespace std;\nusing namespace albert;\n\nQString GlobalSearch::id() const { return "globalsearch"; }\n\nQString GlobalSearch::name() const { return {}; }\n\nQString GlobalSearch::description() const { return {}; }\n\nvoid GlobalSearch::handleTriggerQuery(TriggerQuery &query) const\n{\n    if (query.string().trimmed().isEmpty())\n        return;\n\n    mutex m;  // 6.4 Still no move semantics in QtConcurrent\n    vector<pair<Extension*,RankItem>> rank_items;\n\n    function<void(GlobalQueryHandlerPrivate*)> map =\n        [&m, &rank_items, &query](GlobalQueryHandlerPrivate *handler) {\n            TimePrinter tp(QString("TIME: %1 \xc2\xb5s [\'%2\':\'%3\']").arg("%1", handler->q->id(), query.string()));\n            auto r = handler->handleGlobalQuery(dynamic_cast<GlobalQueryHandler::GlobalQuery&>(query));\n            unique_lock lock(m);\n            rank_items.reserve(rank_items.size()+r.size());\n            for (auto &rank_item : r)\n                rank_items.emplace_back(handler->q, ::move(rank_item));\n        };\n\n    QtConcurrent::blockingMap(handlers, map);\n\n    sort(rank_items.begin(), rank_items.end(), [](const auto &a, const auto &b){ return a.second.score > b.second.score; });\n\n    auto *q = static_cast<::Query*>(&query);\n    q->matches_.add(rank_items.begin(), rank_items.end());\n\n//    auto it = rank_items.begin();\n//    for (uint e = 0; pow(10,e)-1 < (uint)rank_items.size(); ++e){\n//        auto begin = rank_items.begin()+(uint)pow(10u,e)-1;\n//        auto end = rank_items.begin()+min((uint)pow(10u,e+1)-1, (uint)rank_items.size());\n//        sort(begin, end, [](const auto &a, const auto &b){ return a.second.score > b.second.score; });\n//         TODO c++20 ranges view\n//    }\n}\n\n'