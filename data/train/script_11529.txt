b'{-# LANGUAGE DataKinds #-}\n{-# LANGUAGE OverloadedStrings #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n{-# LANGUAGE TemplateHaskell #-}\n{-# LANGUAGE TypeFamilies #-}\n{-# LANGUAGE TypeOperators #-}\n{-# OPTIONS_GHC -fno-warn-orphans #-}\n\nmodule Main where\n\nimport Control.Concurrent (forkIO, threadDelay)\nimport Control.Concurrent.STM (TVar, atomically, newTVarIO, readTVar, retry, writeTVar)\nimport Control.Monad (forever, void)\nimport Control.Monad.IO.Class (liftIO)\nimport Control.Monad.Loops (iterateM_)\nimport Control.Monad.Reader (ask)\nimport Control.Monad.State (put)\nimport Data.Acid (AcidState, Query, Update, makeAcidic, openLocalState, query, update)\nimport Data.Binary (decode, encode)\nimport Data.Foldable (toList)\nimport Data.SafeCopy (base, deriveSafeCopy)\nimport Data.Sequence (Seq, ViewR ((:>)), (|>))\nimport qualified Data.Sequence as S (empty, filter, singleton, viewr)\nimport Data.Text (Text)\nimport Message\n  ( C2SMsg (..),\n    Commit (..),\n    CommitId (..),\n    S2CMsg (..),\n    commitId,\n  )\nimport Network.WebSockets\n  ( Connection,\n    DataMessage (Binary, Text),\n    acceptRequest,\n    receiveDataMessage,\n    runServer,\n    sendDataMessage,\n    sendPing,\n  )\nimport Servant (Get, JSON, Proxy (..), Server, (:>))\nimport System.Environment (getEnv)\nimport Type (Doc (..), Stroke (..))\n\ngetLast :: Seq a -> Maybe a\ngetLast s =\n  case S.viewr s of\n    _ :> x -> Just x\n    _ -> Nothing\n\n-- orphans.\n\n$(deriveSafeCopy 0 \'base \'\'CommitId)\n\n$(deriveSafeCopy 0 \'base \'\'Commit)\n\ndata DocState = DocState\n  { _docStateCommits :: Seq Commit,\n    _docStateCurrentDoc :: Seq (CommitId, Int, [(Double, Double)])\n  }\n  deriving (Show)\n\n$(deriveSafeCopy 0 \'base \'\'DocState)\n\nwriteState :: DocState -> Update DocState ()\nwriteState = put\n\nqueryState :: Query DocState DocState\nqueryState = ask\n\n$(makeAcidic \'\'DocState [\'writeState, \'queryState])\n\nhandler ::\n  Connection ->\n  AcidState DocState ->\n  TVar DocState ->\n  IO ()\nhandler conn acid ref = forever $ do\n  dmsg <- receiveDataMessage conn\n  case dmsg of\n    Text _ _ -> pure ()\n    Binary lbs -> do\n      case decode lbs of\n        NewStroke (hsh, coords) -> do\n          s\' <-\n            atomically $ do\n              DocState commits dat <- readTVar ref\n              let (commits\', dat\') = case getLast commits of\n                    Just commitLast ->\n                      let r = commitId commitLast\n                          commit = Add (r + 1) coords\n                       in (commits |> commit, dat |> (r + 1, hsh, coords))\n                    Nothing ->\n                      let commit = Add 1 coords\n                       in (S.singleton commit, S.singleton (1, hsh, coords))\n                  s\' = DocState {_docStateCommits = commits\', _docStateCurrentDoc = dat\'}\n              writeTVar ref s\'\n              pure s\'\n          update acid $ WriteState s\'\n        DeleteStrokes is -> do\n          s\' <-\n            atomically $ do\n              DocState commits dat <- readTVar ref\n              let dat\' = S.filter (\\(i, _, _) -> not (i `elem` is)) dat\n                  commits\' = case getLast commits of\n                    Just commitLast ->\n                      let r = commitId commitLast\n                          commit = Delete (r + 1) is\n                       in commits |> commit\n                    Nothing -> S.singleton (Delete 1 is)\n                  s\' = DocState {_docStateCommits = commits\', _docStateCurrentDoc = dat\'}\n              writeTVar ref s\'\n              pure s\'\n          update acid $ WriteState s\'\n        SyncRequest (s, e) -> do\n          if s == 0\n            then do\n              -- for initializing a client\n              DocState _ currDoc <- atomically $ readTVar ref\n              let commits = toList $ fmap (\\(cid, _, strk) -> Add cid strk) currDoc\n                  msg = DataStrokes commits\n              sendDataMessage conn (Binary (encode msg))\n            else do\n              -- for updating a already-initialized client\n              DocState commits _ <- atomically $ readTVar ref\n              let commits\' =\n                    toList $\n                      S.filter (\\c -> let i = commitId c in i > s && i <= e) commits\n                  msg = DataStrokes commits\'\n              sendDataMessage conn (Binary (encode msg))\n\ntype API = "doc" :> Get \'[JSON] Doc\n\napi :: Proxy API\napi = Proxy\n\nserver :: TVar DocState -> Server API\nserver var = do\n  s <- liftIO $ atomically $ readTVar var\n  let doc =\n        Doc $\n          map (\\(i, _, xys) -> Stroke i xys) $\n            toList (_docStateCurrentDoc s)\n  pure doc\n\nsecond :: Int\nsecond = 1000000\n\npingPeriod :: Int\npingPeriod = 1 * second\n\n-- | ping-pong every pingPeriod.\nping :: Connection -> IO ()\nping conn = forever $ do\n  threadDelay pingPeriod\n  sendPing conn ("ping" :: Text)\n\nmain :: IO ()\nmain = do\n  hostAddress <- getEnv "HOSTADDRESS"\n  hostWSPort <- read <$> getEnv "WSPORT"\n  putStrLn ("HOSTADDRESS = " ++ hostAddress)\n  putStrLn ("WSPORT = " ++ show hostWSPort)\n  acid <- openLocalState (DocState S.empty S.empty)\n  s <- query acid QueryState\n  ref <- newTVarIO s\n  void $\n    runServer hostAddress hostWSPort $ \\pending -> do\n      conn <- acceptRequest pending\n      putStrLn "websocket connected"\n      void $ forkIO $ ping conn\n      -- synchronization\n      void $ forkIO $ handler conn acid ref\n      void $\n        flip iterateM_ 0 $ \\r -> do\n          r\' <-\n            atomically $ do\n              DocState commits _ <- readTVar ref\n              case getLast commits of\n                Just commit -> let r\' = commitId commit in if (r\' <= r) then retry else pure r\'\n                Nothing -> retry\n          let msg = RegisterStroke r\'\n          sendDataMessage conn (Binary (encode msg))\n          pure r\'\n'