b'{-# LANGUAGE CPP #-}\n{-# LANGUAGE GADTs #-}\n{-# LANGUAGE LambdaCase #-}\n{-# LANGUAGE MultiWayIf #-}\n{-# LANGUAGE OverloadedStrings #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n\nmodule Hoodle.Coroutine.Default where\n\nimport Control.Concurrent\n  ( forkIO,\n    forkOn,\n    newEmptyMVar,\n    putMVar,\n  )\nimport qualified Control.Exception as E\nimport Control.Lens (at, over, set, view, (.~), (?~), (^.), _2)\nimport Control.Monad (void, when)\nimport Control.Monad.State (evalStateT, get, gets, liftIO, modify, put)\nimport Control.Monad.Trans.Crtn.Driver (driver)\nimport Control.Monad.Trans.Crtn.Logger.Simple (simplelogger)\nimport Control.Monad.Trans.Crtn.Object (Arg (..))\nimport Control.Monad.Trans.Reader (ReaderT (..))\nimport qualified Data.ByteString.Char8 as B\nimport Data.Foldable (mapM_)\nimport Data.Hoodle.Generic\n  ( gbackground,\n    gdimension,\n    ghoodleID,\n    gpages,\n  )\nimport Data.Hoodle.Simple (Background (..), Dimension (..))\nimport Data.IORef (writeIORef)\nimport qualified Data.IntMap as M\nimport qualified Data.List as L\nimport Graphics.Hoodle.Render (cnstrctRBkgStateT)\nimport Graphics.Hoodle.Render.Engine\n  ( genRendererMain,\n    pdfRendererMain,\n  )\nimport Graphics.Hoodle.Render.Type (RBackground (..))\nimport qualified Graphics.UI.Gtk as Gtk hiding (get, set)\nimport Hoodle.Accessor\n  ( getHoodleFilePath,\n    getPenType,\n    lensSetToggleUIForFlag,\n    pureUpdateUhdl,\n  )\nimport Hoodle.Coroutine.Callback (eventHandler)\nimport Hoodle.Coroutine.ContextMenu (processContextMenu)\nimport Hoodle.Coroutine.Default.Menu (menuEventProcess)\nimport Hoodle.Coroutine.Draw\n  ( callRenderer,\n    callRenderer_,\n    defaultHandler,\n    doIOaction_,\n    invalidate,\n    invalidateAll,\n    invalidateInBBox,\n    nextevent,\n    waitSomeEvent,\n  )\nimport Hoodle.Coroutine.Eraser (eraserStart)\nimport Hoodle.Coroutine.File\n  ( askIfSave,\n    fileReload,\n    getFileContent,\n  )\n---------\nimport Hoodle.Coroutine.Highlighter (highlighterStart)\nimport Hoodle.Coroutine.Link\n  ( gotLink,\n    notifyLink,\n    openLinkAction,\n  )\nimport Hoodle.Coroutine.Mode\n  ( modeChange,\n    viewModeChange,\n  )\nimport Hoodle.Coroutine.Page\n  ( changePage,\n    pageZoomChange,\n  )\nimport Hoodle.Coroutine.Pen (penStart)\nimport Hoodle.Coroutine.Scroll\n  ( hscrollBarMoved,\n    vscrollBarMoved,\n    vscrollStart,\n  )\nimport Hoodle.Coroutine.Select\n  ( selectLassoStart,\n    selectPenColorChanged,\n    selectPenWidthChanged,\n    selectRectStart,\n  )\nimport Hoodle.Coroutine.TextInput (networkReceived)\nimport Hoodle.Coroutine.VerticalSpace (verticalSpaceStart)\nimport Hoodle.Coroutine.Window\n  ( closeTab,\n    doCanvasConfigure,\n    findTab,\n    paneMoveStart,\n    switchTab,\n  )\nimport Hoodle.Device\n  ( DeviceList,\n    PenButton (..),\n    dev_touch_str,\n  )\nimport Hoodle.GUI.Menu\n  ( getMenuUI,\n    int2Point,\n  )\nimport Hoodle.GUI.Reflect\n  ( reflectNewPageModeUI,\n    reflectPenColorUI,\n    reflectPenModeUI,\n    reflectPenWidthUI,\n    reflectUIToggle,\n    reflectViewModeUI,\n  )\nimport Hoodle.ModelAction.Page (getPageFromGHoodleMap)\nimport Hoodle.ModelAction.Window\n  ( constructFrame,\n    createTab,\n    eventConnect,\n  )\nimport Hoodle.Script.Hook (Hook)\nimport Hoodle.Type.Canvas\n  ( CanvasId,\n    CanvasInfoBox (CanvasSinglePage),\n    canvasWidgets,\n    currentPageNum,\n    currentTool,\n    defaultCvsInfoSinglePage,\n    penColor,\n    penType,\n    penWidth,\n    unboxLens,\n    _canvasId,\n  )\nimport Hoodle.Type.Coroutine\n  ( EventVar,\n    MainCoroutine,\n    MainOp (DoEvent),\n    doIOaction,\n    world,\n  )\nimport Hoodle.Type.Enum\n  ( DrawFlag (Efficient),\n    PenColor (..),\n    PenType (..),\n    SelectType (..),\n    convertBackgroundStyleToByteString,\n    selectType,\n  )\nimport Hoodle.Type.Event\n  ( AllEvent (..),\n    NetworkEvent (..),\n    RenderEvent (..),\n    UserEvent (..),\n  )\nimport Hoodle.Type.HoodleState\n  ( FileStore (LocalDir),\n    HoodleModeState (ViewAppendState),\n    HoodleState,\n    IsOneTimeSelectMode (YesBeforeSelect),\n    backgroundStyle,\n    callBack,\n    currentCanvasInfo,\n    currentUnit,\n    cvsInfoMap,\n    deviceList,\n    doesUseTouch,\n    doesUseVariableCursor,\n    doesUseXInput,\n    emptyHoodleState,\n    frameState,\n    genRenderQueue,\n    getCurrentCanvasId,\n    getHoodle,\n    gtkUIManager,\n    hoodleFileControl,\n    hoodleFileName,\n    hoodleModeState,\n    hoodleModeStateEither,\n    hookSet,\n    isOneTimeSelectMode,\n    isSaved,\n    newPageMode,\n    pdfRenderQueue,\n    penInfo,\n    renderCacheVar,\n    resetHoodleModeStateBuffers,\n    rootContainer,\n    rootNotebook,\n    rootOfRootWindow,\n    rootWindow,\n    selectInfo,\n    settings,\n    statusBar,\n    switchTabSignal,\n    uiComponentSignalHandler,\n    undoTable,\n    unitButton,\n    unitHoodles,\n    unitUUID,\n    updateFromCanvasInfoAsCurrentCanvas,\n  )\nimport Hoodle.Type.PageArrangement\n  ( CanvasDimension (..),\n    ZoomMode (FitWidth),\n  )\nimport Hoodle.Type.Undo (emptyUndo)\nimport Hoodle.Type.Widget\n  ( doesUseLayerWidget,\n    doesUsePanZoomWidget,\n    widgetConfig,\n  )\nimport Hoodle.Type.Window (WindowConfig (Node))\nimport Hoodle.Util (msgShout, (#))\nimport Hoodle.Widget.Dispatch (widgetCheckPen)\nimport Hoodle.Widget.PanZoom (toggleTouch, touchStart)\nimport System.Process (readProcess)\nimport Prelude hiding (mapM_)\n\n-- |\ninitCoroutine ::\n  DeviceList ->\n  Gtk.Window ->\n  Maybe Hook ->\n  -- | maxundo\n  Int ->\n  -- | (xinputbool,usepz,uselyr,varcsr)\n  (Bool, Bool, Bool, Bool) ->\n  IO (EventVar, HoodleState, Gtk.UIManager, Gtk.VBox)\ninitCoroutine devlst window mhook maxundo (xinputbool, usepz, uselyr, varcsr) = do\n  evar <- newEmptyMVar\n  putMVar evar Nothing\n  let callback = eventHandler evar\n  st0new <-\n    set deviceList devlst\n      . set rootOfRootWindow window\n      . set callBack callback\n      <$> emptyHoodleState\n  (ui, uicompsighdlr) <- getMenuUI evar\n  let st1 = set gtkUIManager ui st0new\n      initcvs =\n        set (canvasWidgets . widgetConfig . doesUsePanZoomWidget) usepz\n          . set (canvasWidgets . widgetConfig . doesUseLayerWidget) uselyr\n          $ defaultCvsInfoSinglePage {_canvasId = 1}\n      initcvsbox = CanvasSinglePage initcvs\n      st2 =\n        st1\n          # over\n            (unitHoodles . currentUnit)\n            ( set frameState (Node 1)\n                . updateFromCanvasInfoAsCurrentCanvas initcvsbox\n                . set cvsInfoMap M.empty\n            )\n      uhdl2 = view (unitHoodles . currentUnit) st2\n  (uhdl3, rtwdw, _wconf) <- constructFrame st2 uhdl2 (view frameState uhdl2)\n  (uhdl4, wconf\') <- eventConnect st2 uhdl3 (view frameState uhdl3)\n  notebook <- Gtk.notebookNew\n  statusbar <- Gtk.statusbarNew\n  let st4 = (unitHoodles . currentUnit .~ uhdl4) st2\n      st5 =\n        st4\n          # over\n            (unitHoodles . currentUnit)\n            ( set undoTable (emptyUndo maxundo)\n                . set frameState wconf\'\n                . set rootWindow rtwdw\n                . set (hoodleFileControl . hoodleFileName) (LocalDir Nothing)\n            )\n            . set (settings . doesUseXInput) xinputbool\n            . set (settings . doesUseVariableCursor) varcsr\n            . set hookSet mhook\n            . set rootNotebook notebook\n            . set uiComponentSignalHandler uicompsighdlr\n            . set statusBar (Just statusbar)\n  --\n  vbox <- Gtk.vBoxNew False 0\n  Gtk.containerAdd window vbox\n  vboxcvs <- Gtk.vBoxNew False 0\n  (_, uuid, btn) <- createTab callback notebook vboxcvs\n  Gtk.containerAdd vboxcvs (view (unitHoodles . currentUnit . rootWindow) st5)\n  --\n  sigid <- notebook `Gtk.on` Gtk.switchPage $ \\i -> callback (UsrEv (SwitchTab i))\n  let st6 =\n        ( (unitHoodles . currentUnit . unitUUID .~ uuid)\n            . (unitHoodles . currentUnit . unitButton .~ btn)\n            . (uiComponentSignalHandler . switchTabSignal ?~ sigid)\n        )\n          st5\n      startingXstate = (unitHoodles . currentUnit . rootContainer .~ Gtk.castToBox vboxcvs) st6\n      startworld = world startingXstate . ReaderT $ (\\(Arg DoEvent ev) -> guiProcess ev)\n  putMVar evar . Just $ driver simplelogger startworld\n  return (evar, startingXstate, ui, vbox)\n\n-- | initialization according to the setting\ninitialize :: Maybe (CanvasId, CanvasDimension) -> Bool -> AllEvent -> MainCoroutine (CanvasId, CanvasDimension)\ninitialize cvs isInitialized ev = do\n  case ev of\n    UsrEv (Initialized mfname) -> do\n      if isInitialized\n        then do\n          case cvs of\n            Nothing -> nextevent >>= initialize Nothing True . UsrEv\n            Just cvsi -> return cvsi\n        else do\n          -- additional initialization goes here\n          xst1 <- get\n\n          let ui = xst1 ^. gtkUIManager\n              cachevar = xst1 ^. renderCacheVar\n              tvarpdf = xst1 ^. pdfRenderQueue\n              tvargen = xst1 ^. genRenderQueue\n          doIOaction $ \\evhandler -> do\n            _ <-\n              forkOn 2 $\n                pdfRendererMain (defaultHandler evhandler) tvarpdf\n            _ <-\n              forkIO $\n                E.catch\n                  (genRendererMain cachevar (defaultHandler evhandler) tvargen)\n                  (\\e -> print (e :: E.SomeException))\n            return (UsrEv ActionOrdered)\n          _ <- waitSomeEvent (\\case ActionOrdered -> True; _ -> False)\n\n          getFileContent (LocalDir mfname)\n          --\n          xst2 <- get\n          let uhdl = view (unitHoodles . currentUnit) xst2\n              hdlst = uhdl ^. hoodleModeState\n              cid = getCurrentCanvasId uhdl\n          callRenderer_ $ resetHoodleModeStateBuffers cid hdlst\n          pureUpdateUhdl (hoodleModeState .~ hdlst)\n          liftIO $ reflectUIToggle ui "SAVEA" False\n          pureUpdateUhdl (isSaved .~ True)\n\n          case cvs of\n            Just cvsi -> return cvsi\n            Nothing -> nextevent >>= initialize Nothing True . UsrEv\n    UsrEv (CanvasConfigure cid w h) -> do\n      nextevent >>= initialize (Just (cid, CanvasDimension (Dim w h))) isInitialized . UsrEv\n    _ -> case (cvs, isInitialized) of\n      (Just cvsi, True) -> return cvsi\n      _ -> nextevent >>= initialize cvs isInitialized . UsrEv\n\n-- |\nguiProcess :: AllEvent -> MainCoroutine ()\nguiProcess ev = do\n  (cid, cdim) <- initialize Nothing False ev\n  changePage (const 0)\n  reflectViewModeUI\n  reflectPenModeUI\n  reflectPenColorUI\n  reflectPenWidthUI\n  reflectNewPageModeUI\n  viewModeChange ToContSinglePage\n  pageZoomChange FitWidth\n  doCanvasConfigure cid cdim\n  -- main loop\n  sequence_ (repeat dispatchMode)\n\n-- |\ndispatchMode :: MainCoroutine ()\ndispatchMode =\n  gets (view (unitHoodles . currentUnit))\n    >>= either (const viewAppendMode) (const selectMode) . hoodleModeStateEither . view hoodleModeState\n\n-- |\nviewAppendMode :: MainCoroutine ()\nviewAppendMode = do\n  r1 <- nextevent\n  case r1 of\n    PenDown cid pbtn pcoord ->\n      widgetCheckPen cid pcoord $ do\n        ptype <- getPenType\n        case (ptype, pbtn) of\n          (PenWork, PenButton1) -> do\n            r <- penStart cid pcoord\n            case r of\n              Just (Just Nothing) -> do\n                pureUpdateUhdl (isOneTimeSelectMode .~ YesBeforeSelect)\n                modeChange ToSelectMode\n                selectLassoStart PenButton3 cid pcoord\n              _ -> return ()\n          (PenWork, PenButton2) -> eraserStart cid pcoord\n          (PenWork, PenButton3) -> do\n            pureUpdateUhdl (isOneTimeSelectMode .~ YesBeforeSelect)\n            modeChange ToSelectMode\n            selectLassoStart PenButton3 cid pcoord\n          (PenWork, EraserButton) -> eraserStart cid pcoord\n          (PenWork, _) -> return ()\n          (EraserWork, _) -> eraserStart cid pcoord\n          (HighlighterWork, _) -> do\n            r <- highlighterStart cid pcoord\n            case r of\n              Just (Just Nothing) -> do\n                pureUpdateUhdl (isOneTimeSelectMode .~ YesBeforeSelect)\n                modeChange ToSelectMode\n                selectLassoStart PenButton3 cid pcoord\n              _ -> return ()\n          (VerticalSpaceWork, PenButton1) -> verticalSpaceStart cid pcoord\n          (VerticalSpaceWork, _) -> return ()\n    TouchDown cid pcoord -> touchStart cid pcoord\n    PenMove cid pcoord -> disableTouch >> notifyLink cid pcoord\n    _ -> defaultEventProcess r1\n\ndisableTouch :: MainCoroutine ()\ndisableTouch = do\n  xst <- get\n  let devlst = view deviceList xst\n  when (view (settings . doesUseTouch) xst) $ do\n    let nxst = set (settings . doesUseTouch) False xst\n    doIOaction_ $ do\n      _ <- lensSetToggleUIForFlag "HANDA" (settings . doesUseTouch) nxst\n      let touchstr = dev_touch_str devlst\n      -- ad hoc\n      when (touchstr /= "touch") $\n        void $ readProcess "xinput" ["disable", touchstr] ""\n    put nxst\n\n-- |\nselectMode :: MainCoroutine ()\nselectMode = do\n  r1 <- nextevent\n  case r1 of\n    PenDown cid pbtn pcoord -> do\n      ptype <- gets (view (selectInfo . selectType))\n      case ptype of\n        SelectRectangleWork -> selectRectStart pbtn cid pcoord\n        SelectLassoWork -> selectLassoStart pbtn cid pcoord\n        _ -> return ()\n    PenMove cid pcoord -> disableTouch >> notifyLink cid pcoord\n    TouchDown cid pcoord -> touchStart cid pcoord\n    PenColorChanged c -> do\n      modify (penInfo . currentTool . penColor .~ c)\n      selectPenColorChanged c\n    PenWidthChanged v -> do\n      w <- gets (flip int2Point v . view (penInfo . penType))\n      modify (penInfo . currentTool . penWidth .~ w)\n      selectPenWidthChanged w\n    _ -> defaultEventProcess r1\n\n-- |\ndefaultEventProcess :: UserEvent -> MainCoroutine ()\ndefaultEventProcess (UpdateCanvas cid) = invalidate cid\ndefaultEventProcess (UpdateCanvasEfficient cid) =\n  invalidateInBBox Nothing Efficient cid\ndefaultEventProcess (Menu m) = menuEventProcess m\ndefaultEventProcess (HScrollBarMoved cid v) = hscrollBarMoved cid v\ndefaultEventProcess (VScrollBarMoved cid v) = vscrollBarMoved cid v\ndefaultEventProcess (VScrollBarStart cid v) = vscrollStart cid v\ndefaultEventProcess PaneMoveStart = paneMoveStart\ndefaultEventProcess (CanvasConfigure cid w\' h\') =\n  doCanvasConfigure cid (CanvasDimension (Dim w\' h\'))\ndefaultEventProcess ToViewAppendMode = modeChange ToViewAppendMode\ndefaultEventProcess ToSelectMode = modeChange ToSelectMode\ndefaultEventProcess ToSinglePage = viewModeChange ToSinglePage\ndefaultEventProcess ToContSinglePage = viewModeChange ToContSinglePage\ndefaultEventProcess (AssignPenMode t) =\n  case t of\n    Left pm -> do\n      modify (penInfo . penType .~ pm)\n      modeChange ToViewAppendMode\n    Right sm -> do\n      modify (selectInfo . selectType .~ sm)\n      modeChange ToSelectMode\ndefaultEventProcess (PenColorChanged c) = do\n  modify (penInfo . currentTool . penColor .~ c)\n  reflectPenColorUI\ndefaultEventProcess (PenWidthChanged v) = do\n  st <- get\n  let ptype = view (penInfo . penType) st\n  let w = int2Point ptype v\n  let stNew = set (penInfo . currentTool . penWidth) w st\n  put stNew\n  reflectPenWidthUI\ndefaultEventProcess (BackgroundStyleChanged bsty) = do\n  modify (backgroundStyle .~ bsty)\n  uhdl <- gets (view (unitHoodles . currentUnit))\n  let pgnum = view (currentCanvasInfo . unboxLens currentPageNum) uhdl\n      hdl = getHoodle uhdl\n      pgs = view gpages hdl\n      cpage = getPageFromGHoodleMap pgnum hdl\n      cbkg = view gbackground cpage\n      bstystr = convertBackgroundStyleToByteString bsty\n      -- for the time being, I replace any background to solid background\n      dim = view gdimension cpage\n      getnbkg\' :: RBackground -> Background\n      getnbkg\' (RBkgSmpl c _ _) = Background "solid" c bstystr\n      getnbkg\' RBkgPDF {} = Background "solid" "white" bstystr\n      getnbkg\' RBkgEmbedPDF {} = Background "solid" "white" bstystr\n  --\n  liftIO $ putStrLn " defaultEventProcess: BackgroundStyleChanged HERE/ "\n\n  callRenderer $ GotRBackground <$> evalStateT (cnstrctRBkgStateT dim (getnbkg\' cbkg)) Nothing\n  RenderEv (GotRBackground nbkg) <-\n    waitSomeEvent (\\case RenderEv (GotRBackground _) -> True; _ -> False)\n\n  let npage = set gbackground nbkg cpage\n      npgs = set (at pgnum) (Just npage) pgs\n      nhdl = set gpages npgs hdl\n  modeChange ToViewAppendMode\n  pureUpdateUhdl (hoodleModeState .~ ViewAppendState nhdl)\n  invalidateAll\ndefaultEventProcess (AssignNewPageMode nmod) = modify (settings . newPageMode .~ nmod)\ndefaultEventProcess (GotContextMenuSignal ctxtmenu) = processContextMenu ctxtmenu\ndefaultEventProcess (GetHoodleFileInfo ref) = do\n  uhdl <- gets (view (unitHoodles . currentUnit))\n  let hdl = getHoodle uhdl\n      uuid = B.unpack (view ghoodleID hdl)\n  case getHoodleFilePath uhdl of\n    Nothing -> liftIO $ writeIORef ref Nothing\n    Just fp -> liftIO $ writeIORef ref (Just (uuid ++ "," ++ fp))\ndefaultEventProcess (GetHoodleFileInfoFromTab uuidtab ref) = do\n  uhdlmap <- gets (view (unitHoodles . _2))\n  let muhdl = (L.lookup uuidtab . map (\\x -> (view unitUUID x, x)) . M.elems) uhdlmap\n  case muhdl of\n    Nothing -> liftIO $ writeIORef ref Nothing\n    Just uhdl -> do\n      let hdl = getHoodle uhdl\n          uuid = B.unpack (view ghoodleID hdl)\n      case getHoodleFilePath uhdl of\n        Nothing -> liftIO $ writeIORef ref Nothing\n        Just fp -> liftIO $ writeIORef ref (Just (uuid ++ "," ++ fp))\ndefaultEventProcess (GotLink mstr (x, y)) = gotLink mstr (x, y)\ndefaultEventProcess FileReloadOrdered = fileReload\ndefaultEventProcess (CustomKeyEvent str) = do\n  if\n      | str == "[]:\\"Super_L\\"" -> do\n        xst <- gets (over (settings . doesUseTouch) not)\n        put xst\n        doIOaction_ $ lensSetToggleUIForFlag "HANDA" (settings . doesUseTouch) xst\n        toggleTouch\n      | str == "[]:\\"1\\"" -> colorfunc ColorBlack\n      | str == "[]:\\"2\\"" -> colorfunc ColorBlue\n      | str == "[]:\\"3\\"" -> colorfunc ColorRed\n      | str == "[]:\\"4\\"" -> colorfunc ColorGreen\n      | str == "[]:\\"5\\"" -> colorfunc ColorGray\n      | str == "[]:\\"6\\"" -> colorfunc ColorLightBlue\n      | str == "[]:\\"7\\"" -> colorfunc ColorLightGreen\n      | str == "[]:\\"8\\"" -> colorfunc ColorMagenta\n      | str == "[]:\\"9\\"" -> colorfunc ColorOrange\n      | str == "[]:\\"0\\"" -> colorfunc ColorYellow\n      | str == "[]:\\"minus\\"" -> colorfunc ColorWhite\n      | str == "[]:\\"a\\"" -> toolfunc PenWork\n      | str == "[]:\\"b\\"" -> toolfunc HighlighterWork\n      | str == "[]:\\"c\\"" -> toolfunc EraserWork\n      | str == "[]:\\"d\\"" -> toolfunc VerticalSpaceWork\n      | otherwise -> return ()\n  where\n    colorfunc c = doIOaction $ \\_evhandler -> return (UsrEv (PenColorChanged c))\n    toolfunc t = doIOaction $ \\_evhandler -> return (UsrEv (AssignPenMode (Left t)))\ndefaultEventProcess (SwitchTab i) = switchTab i\ndefaultEventProcess (CloseTab uuid) = findTab uuid >>= mapM_ (\\x -> switchTab x >> askIfSave closeTab)\ndefaultEventProcess (OpenLink urlpath mid) = openLinkAction urlpath mid\ndefaultEventProcess (NetworkProcess (NetworkReceived txt)) = networkReceived txt\ndefaultEventProcess ev =\n  -- for debugging\n  do\n    msgShout "--- no default ---"\n    msgShout (show ev)\n    msgShout "------------------"\n'