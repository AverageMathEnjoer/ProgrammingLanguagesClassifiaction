b'using System;\nusing System.Diagnostics;\nusing System.IO;\nusing System.Text;\n\nusing i16 = System.Int16;\nusing u8 = System.Byte;\nusing u16 = System.UInt16;\nusing u32 = System.UInt32;\n\nusing Pgno = System.UInt32;\n\nnamespace CS_SQLite3\n{\n  public partial class CSSQLite\n  {\n    /*\n    ** 2001 September 15\n    **\n    ** The author disclaims copyright to this source code.  In place of\n    ** a legal notice, here is a blessing:\n    **\n    **    May you do good and not evil.\n    **    May you find forgiveness for yourself and forgive others.\n    **    May you share freely, never taking more than you give.\n    **\n    *************************************************************************\n    ** This file contains C code routines that are called by the SQLite parser\n    ** when syntax rules are reduced.  The routines in this file handle the\n    ** following kinds of SQL syntax:\n    **\n    **     CREATE TABLE\n    **     DROP TABLE\n    **     CREATE INDEX\n    **     DROP INDEX\n    **     creating ID lists\n    **     BEGIN TRANSACTION\n    **     COMMIT\n    **     ROLLBACK\n    **\n    ** $Id: build.c,v 1.557 2009/07/24 17:58:53 danielk1977 Exp $\n    **\n    *************************************************************************\n    **  Included in SQLite3 port to C#-SQLite;  2008 Noah B Hart\n    **  C#-SQLite is an independent reimplementation of the SQLite software library\n    **\n    **  $Header$\n    *************************************************************************\n    */\n    //#include "sqliteInt.h"\n\n    /*\n    ** This routine is called when a new SQL statement is beginning to\n    ** be parsed.  Initialize the pParse structure as needed.\n    */\n    static void sqlite3BeginParse( Parse pParse, int explainFlag )\n    {\n      pParse.explain = (byte)explainFlag;\n      pParse.nVar = 0;\n    }\n\n#if !SQLITE_OMIT_SHARED_CACHE\n/*\n** The TableLock structure is only used by the sqlite3TableLock() and\n** codeTableLocks() functions.\n*/\n//struct TableLock {\n//  int iDb;             /* The database containing the table to be locked */\n//  int iTab;            /* The root page of the table to be locked */\n//  u8 isWriteLock;      /* True for write lock.  False for a read lock */\n//  string zName;   /* Name of the table */\n//};\n\npublic class TableLock\n{\npublic int iDb;         /* The database containing the table to be locked */\npublic int iTab;        /* The root page of the table to be locked */\npublic u8 isWriteLock;  /* True for write lock.  False for a read lock */\npublic string zName;    /* Name of the table */\n}\n/*\n** Record the fact that we want to lock a table at run-time.\n**\n** The table to be locked has root page iTab and is found in database iDb.\n** A read or a write lock can be taken depending on isWritelock.\n**\n** This routine just records the fact that the lock is desired.  The\n** code to make the lock occur is generated by a later call to\n** codeTableLocks() which occurs during sqlite3FinishCoding().\n*/\nstatic void sqlite3TableLock(\nParse pParse,     /* Parsing context */\nint iDb,          /* Index of the database containing the table to lock */\nint iTab,         /* Root page number of the table to be locked */\nu8 isWriteLock,   /* True for a write lock */\nstring zName      /* Name of the table to be locked */\n)\n{\nint i;\nint nBytes;\nTableLock p;\n\nDebug.Assert( iDb >= 0 );\n\nfor ( i = 0 ; i < pParse.nTableLock ; i++ )\n{\np = pParse.aTableLock[i];\nif ( p.iDb == iDb && p.iTab == iTab )\n{\np.isWriteLock = (byte)( ( p.isWriteLock != 0 || isWriteLock != 0 ) ? 1 : 0 );\nreturn;\n}\n}\n\nnBytes = ( pParse.nTableLock + 1 );//sizeof(TableLock) *\nArray.Resize( ref pParse.aTableLock, pParse.nTableLock + 1 );\n//          sqlite3DbReallocOrFree( pParse.db, pParse.aTableLock, nBytes );\nif ( pParse.aTableLock != null )\n{\npParse.aTableLock[pParse.nTableLock] = new TableLock();\np = pParse.aTableLock[pParse.nTableLock++];\np.iDb = iDb;\np.iTab = iTab;\np.isWriteLock = isWriteLock;\np.zName = zName;\n}\nelse\n{\npParse.nTableLock = 0;\npParse.db.mallocFailed = 1;\n}\n}\n\n/*\n** Code an OP_TableLock instruction for each table locked by the\n** statement (configured by calls to sqlite3TableLock()).\n*/\nstatic void codeTableLocks( Parse pParse )\n{\nint i;\nVdbe pVdbe;\n\npVdbe = sqlite3GetVdbe( pParse );\nDebug.Assert( pVdbe != null ); /* sqlite3GetVdbe cannot fail: VDBE already allocated */\n\nfor ( i = 0 ; i < pParse.nTableLock ; i++ )\n{\nTableLock p = pParse.aTableLock[i];\nint p1 = p.iDb;\nsqlite3VdbeAddOp4( pVdbe, OP_TableLock, p1, p.iTab, p.isWriteLock,\np.zName, P4_STATIC );\n}\n}\n#else\n    //  #define codeTableLocks(x)\n    static void codeTableLocks( Parse pParse ) { }\n#endif\n\n    /*\n** This routine is called after a single SQL statement has been\n** parsed and a VDBE program to execute that statement has been\n** prepared.  This routine puts the finishing touches on the\n** VDBE program and resets the pParse structure for the next\n** parse.\n**\n** Note that if an error occurred, it might be the case that\n** no VDBE code was generated.\n*/\n    static void sqlite3FinishCoding( Parse pParse )\n    {\n      sqlite3 db;\n      Vdbe v;\n\n      db = pParse.db;\n//      if ( db.mallocFailed != 0 ) return;\n      if ( pParse.nested != 0 ) return;\n      if ( pParse.nErr != 0 ) return;\n\n      /* Begin by generating some termination code at the end of the\n      ** vdbe program\n      */\n      v = sqlite3GetVdbe( pParse );\n      if ( v != null )\n      {\n        sqlite3VdbeAddOp0( v, OP_Halt );\n\n        /* The cookie mask contains one bit for each database file open.\n        ** (Bit 0 is for main, bit 1 is for temp, and so forth.)  Bits are\n        ** set for each database that is used.  Generate code to start a\n        ** transaction on each used database and to verify the schema cookie\n        ** on each used database.\n        */\n        if ( pParse.cookieGoto > 0 )\n        {\n          u32 mask;\n          int iDb;\n          sqlite3VdbeJumpHere( v, pParse.cookieGoto - 1 );\n          for ( iDb = 0, mask = 1 ; iDb < db.nDb ; mask <<= 1, iDb++ )\n          {\n            if ( ( mask & pParse.cookieMask ) == 0 ) continue;\n            sqlite3VdbeUsesBtree( v, iDb );\n            sqlite3VdbeAddOp2( v, OP_Transaction, iDb, ( mask & pParse.writeMask ) != 0 );\n            if ( db.init.busy == 0 )\n            {\n              sqlite3VdbeAddOp2( v, OP_VerifyCookie, iDb, pParse.cookieValue[iDb] );\n            }\n          }\n#if !SQLITE_OMIT_VIRTUALTABLE\n{\nint i;\nfor(i=0; i<pParse.nVtabLock; i++){\nchar *vtab = (char *)sqlite3GetVTable(db, pParse->apVtabLock[i]);\nsqlite3VdbeAddOp4(v, OP_VBegin, 0, 0, 0, vtab, P4_VTAB);\n}\npParse.nVtabLock = 0;\n}\n#endif\n\n          /* Once all the cookies have been verified and transactions opened,\n** obtain the required table-locks. This is a no-op unless the\n** shared-cache feature is enabled.\n*/\n          codeTableLocks( pParse );\n\n          /* Initialize any AUTOINCREMENT data structures required.\n          */\n          sqlite3AutoincrementBegin( pParse );\n\n          /* Finally, jump back to the beginning of the executable code. */\n          sqlite3VdbeAddOp2( v, OP_Goto, 0, pParse.cookieGoto );\n        }\n      }\n\n\n      /* Get the VDBE program ready for execution\n      */\n      if ( v != null && ALWAYS( pParse.nErr == 0 ) /* && 0 == db.mallocFailed */ )\n      {\n#if  SQLITE_DEBUG\n        TextWriter trace = ( db.flags & SQLITE_VdbeTrace ) != 0 ? Console.Out : null;\n        sqlite3VdbeTrace( v, trace );\n#endif\n        Debug.Assert( pParse.iCacheLevel == 0 );  /* Disables and re-enables match */\n        sqlite3VdbeMakeReady( v, pParse.nVar, pParse.nMem,\n        pParse.nTab, pParse.explain );\n        pParse.rc = SQLITE_DONE;\n        pParse.colNamesSet = 0;\n      }\n      else if ( pParse.rc == SQLITE_OK )\n      {\n        pParse.rc = SQLITE_ERROR;\n      }\n      pParse.nTab = 0;\n      pParse.nMem = 0;\n      pParse.nSet = 0;\n      pParse.nVar = 0;\n      pParse.cookieMask = 0;\n      pParse.cookieGoto = 0;\n    }\n\n    /*\n    ** Run the parser and code generator recursively in order to generate\n    ** code for the SQL statement given onto the end of the pParse context\n    ** currently under construction.  When the parser is run recursively\n    ** this way, the final OP_Halt is not appended and other initialization\n    ** and finalization steps are omitted because those are handling by the\n    ** outermost parser.\n    **\n    ** Not everything is nestable.  This facility is designed to permit\n    ** INSERT, UPDATE, and DELETE operations against SQLITE_MASTER.  Use\n    ** care if you decide to try to use this routine for some other purposes.\n    */\n    static void sqlite3NestedParse( Parse pParse, string zFormat, params object[] ap )\n    {\n      //  va_list ap;\n      string zSql;        //  char *zSql;\n      string zErrMsg = "";//  char* zErrMsg = 0;\n      sqlite3 db = pParse.db;\n      //# define SAVE_SZ  (Parse.Length - offsetof(Parse,nVar))\n      //  char saveBuf[SAVE_SZ];\n\n      if ( pParse.nErr != 0 ) return;\n      Debug.Assert( pParse.nested < 10 );  /* Nesting should only be of limited depth */\n      va_start( ap, zFormat );\n      zSql = sqlite3VMPrintf( db, zFormat, ap );\n      va_end( ap );\n      //if( zSql=="" ){\n      //  return;   /* A malloc must have failed */\n      //}\n      pParse.nested++;\n      pParse.SaveMembers();     //  memcpy(saveBuf, pParse.nVar, SAVE_SZ);\n      pParse.ResetMembers();    //  memset(pParse.nVar, 0, SAVE_SZ);\n      sqlite3RunParser( pParse, zSql, ref zErrMsg );\n      //sqlite3DbFree( db, ref zErrMsg );\n      //sqlite3DbFree( db, ref  zSql );\n      pParse.RestoreMembers();  //  memcpy(pParse.nVar, saveBuf, SAVE_SZ);\n      pParse.nested--;\n    }\n\n    /*\n    ** Locate the in-memory structure that describes a particular database\n    ** table given the name of that table and (optionally) the name of the\n    ** database containing the table.  Return NULL if not found.\n    **\n    ** If zDatabase is 0, all databases are searched for the table and the\n    ** first matching table is returned.  (No checking for duplicate table\n    ** names is done.)  The search order is TEMP first, then MAIN, then any\n    ** auxiliary databases added using the ATTACH command.\n    **\n    ** See also sqlite3LocateTable().\n    */\n    static Table sqlite3FindTable( sqlite3 db, string zName, string zDatabase )\n    {\n      Table p = null;\n      int i;\n      int nName;\n      Debug.Assert( zName != null );\n      nName = sqlite3Strlen30( zName );\n      for ( i = OMIT_TEMPDB ; i < db.nDb ; i++ )\n      {\n        int j = ( i < 2 ) ? i ^ 1 : i;   /* Search TEMP before MAIN */\n        if ( zDatabase != null && sqlite3StrICmp( zDatabase, db.aDb[j].zName ) != 0 ) continue;\n        p = (Table)sqlite3HashFind( db.aDb[j].pSchema.tblHash, zName, nName );\n        if ( p != null ) break;\n      }\n      return p;\n    }\n\n    /*\n    ** Locate the in-memory structure that describes a particular database\n    ** table given the name of that table and (optionally) the name of the\n    ** database containing the table.  Return NULL if not found.  Also leave an\n    ** error message in pParse.zErrMsg.\n    **\n    ** The difference between this routine and sqlite3FindTable() is that this\n    ** routine leaves an error message in pParse.zErrMsg where\n    ** sqlite3FindTable() does not.\n    */\n    static Table sqlite3LocateTable(\n    Parse pParse,     /* context in which to report errors */\n    int isView,       /* True if looking for a VIEW rather than a TABLE */\n    string zName,     /* Name of the table we are looking for */\n    string zDbase     /* Name of the database.  Might be NULL */\n    )\n    {\n      Table p;\n\n      /* Read the database schema. If an error occurs, leave an error message\n      ** and code in pParse and return NULL. */\n      if ( SQLITE_OK != sqlite3ReadSchema( pParse ) )\n      {\n        return null;\n      }\n\n      p = sqlite3FindTable( pParse.db, zName, zDbase );\n      if ( p == null )\n      {\n        string zMsg = isView != 0 ? "no such view" : "no such table";\n        if ( zDbase != null )\n        {\n          sqlite3ErrorMsg( pParse, "%s: %s.%s", zMsg, zDbase, zName );\n        }\n        else\n        {\n          sqlite3ErrorMsg( pParse, "%s: %s", zMsg, zName );\n        }\n        pParse.checkSchema = 1;\n      }\n      return p;\n    }\n\n    /*\n    ** Locate the in-memory structure that describes\n    ** a particular index given the name of that index\n    ** and the name of the database that contains the index.\n    ** Return NULL if not found.\n    **\n    ** If zDatabase is 0, all databases are searched for the\n    ** table and the first matching index is returned.  (No checking\n    ** for duplicate index names is done.)  The search order is\n    ** TEMP first, then MAIN, then any auxiliary databases added\n    ** using the ATTACH command.\n    */\n    static Index sqlite3FindIndex( sqlite3 db, string zName, string zDb )\n    {\n      Index p = null;\n      int i;\n      int nName = sqlite3Strlen30( zName );\n      for ( i = OMIT_TEMPDB ; i < db.nDb ; i++ )\n      {\n        int j = ( i < 2 ) ? i ^ 1 : i;  /* Search TEMP before MAIN */\n        Schema pSchema = db.aDb[j].pSchema;\n        Debug.Assert( pSchema != null );\n        if ( zDb != null && sqlite3StrICmp( zDb, db.aDb[j].zName ) != 0 ) continue;\n        p = (Index)sqlite3HashFind( pSchema.idxHash, zName, nName );\n        if ( p != null ) break;\n      }\n      return p;\n    }\n\n    /*\n    ** Reclaim the memory used by an index\n    */\n    static void freeIndex( ref Index p )\n    {\n      sqlite3 db = p.pTable.dbMem;\n      /* testcase( db==0 ); */\n      //sqlite3DbFree( db, ref p.zColAff );\n      //sqlite3DbFree( db, ref p );\n    }\n\n    /*\n    ** Remove the given index from the index hash table, and free\n    ** its memory structures.\n    **\n    ** The index is removed from the database hash tables but\n    ** it is not unlinked from the Table that it indexes.\n    ** Unlinking from the Table must be done by the calling function.\n    */\n    static void sqlite3DeleteIndex( Index p )\n    {\n      Index pOld;\n      string zName = p.zName;\n\n      pOld = (Index)sqlite3HashInsert( ref p.pSchema.idxHash, zName,\n      sqlite3Strlen30( zName ), null );\n      Debug.Assert( pOld == null || pOld == p );\n      freeIndex( ref p );\n    }\n\n    /*\n    ** For the index called zIdxName which is found in the database iDb,\n    ** unlike that index from its Table then remove the index from\n    ** the index hash table and free all memory structures associated\n    ** with the index.\n    */\n    static void sqlite3UnlinkAndDeleteIndex( sqlite3 db, int iDb, string zIdxName )\n    {\n      Index pIndex;\n      int len;\n      Hash pHash = db.aDb[iDb].pSchema.idxHash;\n\n      len = sqlite3Strlen30( zIdxName );\n      pIndex = (Index)sqlite3HashInsert( ref pHash, zIdxName, len, null );\n      if ( pIndex != null )\n      {\n        if ( pIndex.pTable.pIndex == pIndex )\n        {\n          pIndex.pTable.pIndex = pIndex.pNext;\n        }\n        else\n        {\n          Index p;\n          /* Justification of ALWAYS();  The index must be on the list of\n          ** indices. */\n          p = pIndex.pTable.pIndex;\n          while ( ALWAYS( p != null ) && p.pNext != pIndex ) { p = p.pNext; }\n          if ( ALWAYS( p != null && p.pNext == pIndex ) )\n          {\n            p.pNext = pIndex.pNext;\n          }\n        }\n        freeIndex( ref pIndex );\n      }\n      db.flags |= SQLITE_InternChanges;\n    }\n\n    /*\n    ** Erase all schema information from the in-memory hash tables of\n    ** a single database.  This routine is called to reclaim memory\n    ** before the database closes.  It is also called during a rollback\n    ** if there were schema changes during the transaction or if a\n    ** schema-cookie mismatch occurs.\n    **\n    ** If iDb==0 then reset the internal schema tables for all database\n    ** files.  If iDb>=1 then reset the internal schema for only the\n    ** single file indicated.\n    */\n    static void sqlite3ResetInternalSchema( sqlite3 db, int iDb )\n    {\n      int i, j;\n      Debug.Assert( iDb >= 0 && iDb < db.nDb );\n\n      if ( iDb == 0 )\n      {\n        sqlite3BtreeEnterAll( db );\n      }\n      for ( i = iDb ; i < db.nDb ; i++ )\n      {\n        Db pDb = db.aDb[i];\n        if ( pDb.pSchema != null )\n        {\n          Debug.Assert( i == 1 || ( pDb.pBt != null && sqlite3BtreeHoldsMutex( pDb.pBt ) ) );\n          Debug.Assert( i == 1 || ( pDb.pBt != null ) );\n          sqlite3SchemaFree( pDb.pSchema );\n        }\n        if ( iDb > 0 ) return;\n      }\n      Debug.Assert( iDb == 0 );\n      db.flags &= ~SQLITE_InternChanges;\n      sqlite3VtabUnlockList( db );\n      sqlite3BtreeLeaveAll( db );\n      /* If one or more of the auxiliary database files has been closed,\n      ** then remove them from the auxiliary database list.  We take the\n      ** opportunity to do this here since we have just deleted all of the\n      ** schema hash tables and therefore do not have to make any changes\n      ** to any of those tables.\n      */\n      for ( i = j = 2 ; i < db.nDb ; i++ )\n      {\n        Db pDb = db.aDb[i];\n        if ( pDb.pBt == null )\n        {\n          //sqlite3DbFree( db, ref pDb.zName );\n          continue;\n        }\n        if ( j < i )\n        {\n          db.aDb[j] = db.aDb[i];\n        }\n        j++;\n      }\n      if ( db.nDb != j ) db.aDb[j] = new Db();//memset(db.aDb[j], 0, (db.nDb-j)*sizeof(db.aDb[j]));\n      db.nDb = j;\n      if ( db.nDb <= 2 && db.aDb != db.aDbStatic )\n      {\n        Array.Copy( db.aDb, db.aDbStatic, 2 );// memcpy(db.aDbStatic, db.aDb, 2*sizeof(db.aDb[0]));\n        //sqlite3DbFree(db,ref db.aDb);\n        //db.aDb = db.aDbStatic;\n      }\n    }\n\n    /*\n    ** This routine is called when a commit occurs.\n    */\n    static void sqlite3CommitInternalChanges( sqlite3 db )\n    {\n      db.flags &= ~SQLITE_InternChanges;\n    }\n\n    /*\n    ** Clear the column names from a table or view.\n    */\n    static void sqliteResetColumnNames( Table pTable )\n    {\n      int i;\n      Column pCol;\n      sqlite3 db = pTable.dbMem;\n      testcase( db == null );\n      Debug.Assert( pTable != null );\n      for ( i = 0 ; i < pTable.nCol ; i++ )\n      {\n        pCol = pTable.aCol[i];\n        if ( pCol != null )\n        {\n          //sqlite3DbFree( db, ref pCol.zName );\n          sqlite3ExprDelete( db, ref pCol.pDflt );\n          //sqlite3DbFree( db, ref pCol.zDflt );\n          //sqlite3DbFree( db, ref pCol.zType );\n          //sqlite3DbFree( db, ref pCol.zColl );\n        }\n      }\n      pTable.aCol = null; //sqlite3DbFree( db, ref pTable.aCol );\n      pTable.nCol = 0;\n    }\n\n    /*\n    ** Remove the memory data structures associated with the given\n    ** Table.  No changes are made to disk by this routine.\n    **\n    ** This routine just deletes the data structure.  It does not unlink\n    ** the table data structure from the hash table.  But it does destroy\n    ** memory structures of the indices and foreign keys associated with\n    ** the table.\n    */\n    static void sqlite3DeleteTable( ref Table pTable )\n    {\n      Index pIndex; Index pNext;\n      FKey pFKey; FKey pNextFKey;\n      sqlite3 db;\n\n      if ( pTable == null ) return;\n      db = pTable.dbMem;\n      testcase( db == null );\n\n      /* Do not delete the table until the reference count reaches zero. */\n      pTable.nRef--;\n      if ( pTable.nRef > 0 )\n      {\n        return;\n      }\n      Debug.Assert( pTable.nRef == 0 );\n\n      /* Delete all indices associated with this table\n      */\n      for ( pIndex = pTable.pIndex ; pIndex != null ; pIndex = pNext )\n      {\n        pNext = pIndex.pNext;\n        Debug.Assert( pIndex.pSchema == pTable.pSchema );\n        sqlite3DeleteIndex( pIndex );\n      }\n\n#if !SQLITE_OMIT_FOREIGN_KEY\n      /* Delete all foreign keys associated with this table. */\n      for ( pFKey = pTable.pFKey ; pFKey != null ; pFKey = pNextFKey )\n      {\n        pNextFKey = pFKey.pNextFrom;\n        pFKey = null;// //sqlite3DbFree(db,ref pFKey);\n      }\n#endif\n\n      /* Delete the Table structure itself.\n*/\n      sqliteResetColumnNames( pTable );\n      //sqlite3DbFree( db, ref pTable.zName );\n      //sqlite3DbFree( db, ref pTable.zColAff );\n      sqlite3SelectDelete( db, ref pTable.pSelect );\n#if !SQLITE_OMIT_CHECK\n      sqlite3ExprDelete( db, ref pTable.pCheck );\n#endif\n      sqlite3VtabClear( pTable );\n      //sqlite3DbFree( db, ref pTable );\n    }\n\n    /*\n    ** Unlink the given table from the hash tables and the delete the\n    ** table structure with all its indices and foreign keys.\n    */\n    static void sqlite3UnlinkAndDeleteTable( sqlite3 db, int iDb, string zTabName )\n    {\n      Table p;\n      Db pDb;\n\n      Debug.Assert( db != null );\n      Debug.Assert( iDb >= 0 && iDb < db.nDb );\n      Debug.Assert( zTabName != null && zTabName[0] != \'\\0\' );\n      pDb = db.aDb[iDb];\n      p = (Table)sqlite3HashInsert( ref pDb.pSchema.tblHash, zTabName,\n      sqlite3Strlen30( zTabName ), null );\n      sqlite3DeleteTable( ref p );\n      db.flags |= SQLITE_InternChanges;\n    }\n\n    /*\n    ** Given a token, return a string that consists of the text of that\n    ** token.  Space to hold the returned string\n    ** is obtained from sqliteMalloc() and must be freed by the calling\n    ** function.\n    **\n    ** Any quotation marks (ex:  "name", \'name\', [name], or `name`) that\n    ** surround the body of the token are removed.\n    **\n    ** Tokens are often just pointers into the original SQL text and so\n    ** are not \\000 terminated and are not persistent.  The returned string\n    ** is \\000 terminated and is persistent.\n    */\n    static string sqlite3NameFromToken( sqlite3 db, Token pName )\n    {\n      string zName;\n      if ( pName != null && pName.z != null )\n      {\n        zName = pName.z.Substring( 0, pName.n );//sqlite3DbStrNDup(db, (char*)pName.z, pName.n);\n        sqlite3Dequote( ref zName );\n      }\n      else\n      {\n        return null;\n      }\n      return zName;\n    }\n\n    /*\n    ** Open the sqlite_master table stored in database number iDb for\n    ** writing. The table is opened using cursor 0.\n    */\n    static void sqlite3OpenMasterTable( Parse p, int iDb )\n    {\n      Vdbe v = sqlite3GetVdbe( p );\n      sqlite3TableLock( p, iDb, MASTER_ROOT, 1, SCHEMA_TABLE( iDb ) );\n      sqlite3VdbeAddOp3( v, OP_OpenWrite, 0, MASTER_ROOT, iDb );\n      sqlite3VdbeChangeP4( v, -1, (int)5, P4_INT32 );  /* 5 column table */\n      if ( p.nTab == 0 )\n      {\n        p.nTab = 1;\n      }\n    }\n\n    /*\n    ** Parameter zName points to a nul-terminated buffer containing the name\n    ** of a database ("main", "temp" or the name of an attached db). This\n    ** function returns the index of the named database in db->aDb[], or\n    ** -1 if the named db cannot be found.\n    */\n    static int sqlite3FindDbName( sqlite3 db, string zName )\n    {\n      int i = -1;    /* Database number */\n      if ( zName != null )\n      {\n        Db pDb;\n        int n = sqlite3Strlen30( zName );\n        for ( i = ( db.nDb - 1 ) ; i >= 0 ; i-- )\n        {\n          pDb = db.aDb[i];\n          if ( ( OMIT_TEMPDB == 0 || i != 1 ) && n == sqlite3Strlen30( pDb.zName ) &&\n          0 == sqlite3StrICmp( pDb.zName, zName ) )\n          {\n            break;\n          }\n        }\n      }\n      return i;\n    }\n\n    /*\n    ** The token *pName contains the name of a database (either "main" or\n    ** "temp" or the name of an attached db). This routine returns the\n    ** index of the named database in db->aDb[], or -1 if the named db\n    ** does not exist.\n    */\n    static int sqlite3FindDb( sqlite3 db, Token pName )\n    {\n      int i;                               /* Database number */\n      string zName;                         /* Name we are searching for */\n      zName = sqlite3NameFromToken( db, pName );\n      i = sqlite3FindDbName( db, zName );\n      //sqlite3DbFree( db, zName );\n      return i;\n    }\n\n    /* The table or view or trigger name is passed to this routine via tokens\n    ** pName1 and pName2. If the table name was fully qualified, for example:\n    **\n    ** CREATE TABLE xxx.yyy (...);\n    **\n    ** Then pName1 is set to "xxx" and pName2 "yyy". On the other hand if\n    ** the table name is not fully qualified, i.e.:\n    **\n    ** CREATE TABLE yyy(...);\n    **\n    ** Then pName1 is set to "yyy" and pName2 is "".\n    **\n    ** This routine sets the ppUnqual pointer to point at the token (pName1 or\n    ** pName2) that stores the unqualified table name.  The index of the\n    ** database "xxx" is returned.\n    */\n    static int sqlite3TwoPartName(\n    Parse pParse,      /* Parsing and code generating context */\n    Token pName1,      /* The "xxx" in the name "xxx.yyy" or "xxx" */\n    Token pName2,      /* The "yyy" in the name "xxx.yyy" */\n    ref Token pUnqual  /* Write the unqualified object name here */\n    )\n    {\n      int iDb;                    /* Database holding the object */\n      sqlite3 db = pParse.db;\n\n      if ( ALWAYS( pName2 != null ) && pName2.n > 0 )\n      {\n        if ( db.init.busy != 0 )\n        {\n          sqlite3ErrorMsg( pParse, "corrupt database" );\n          pParse.nErr++;\n          return -1;\n        }\n        pUnqual = pName2;\n        iDb = sqlite3FindDb( db, pName1 );\n        if ( iDb < 0 )\n        {\n          sqlite3ErrorMsg( pParse, "unknown database %T", pName1 );\n          pParse.nErr++;\n          return -1;\n        }\n      }\n      else\n      {\n        Debug.Assert( db.init.iDb == 0 || db.init.busy != 0 );\n        iDb = db.init.iDb;\n        pUnqual = pName1;\n      }\n      return iDb;\n    }\n\n    /*\n    ** This routine is used to check if the UTF-8 string zName is a legal\n    ** unqualified name for a new schema object (table, index, view or\n    ** trigger). All names are legal except those that begin with the string\n    ** "sqlite_" (in upper, lower or mixed case). This portion of the namespace\n    ** is reserved for internal use.\n    */\n    static int sqlite3CheckObjectName( Parse pParse, string zName )\n    {\n      if ( 0 == pParse.db.init.busy && pParse.nested == 0\n      && ( pParse.db.flags & SQLITE_WriteSchema ) == 0\n      && 0 == sqlite3StrNICmp( zName, "sqlite_", 7 ) )\n      {\n        sqlite3ErrorMsg( pParse, "object name reserved for internal use: %s", zName );\n        return SQLITE_ERROR;\n      }\n      return SQLITE_OK;\n    }\n\n    /*\n    ** Begin constructing a new table representation in memory.  This is\n    ** the first of several action routines that get called in response\n    ** to a CREATE TABLE statement.  In particular, this routine is called\n    ** after seeing tokens "CREATE" and "TABLE" and the table name. The isTemp\n    ** flag is true if the table should be stored in the auxiliary database\n    ** file instead of in the main database file.  This is normally the case\n    ** when the "TEMP" or "TEMPORARY" keyword occurs in between\n    ** CREATE and TABLE.\n    **\n    ** The new table record is initialized and put in pParse.pNewTable.\n    ** As more of the CREATE TABLE statement is parsed, additional action\n    ** routines will be called to add more information to this record.\n    ** At the end of the CREATE TABLE statement, the sqlite3EndTable() routine\n    ** is called to complete the construction of the new table record.\n    */\n    static void sqlite3StartTable(\n    Parse pParse,   /* Parser context */\n    Token pName1,   /* First part of the name of the table or view */\n    Token pName2,   /* Second part of the name of the table or view */\n    int isTemp,      /* True if this is a TEMP table */\n    int isView,      /* True if this is a VIEW */\n    int isVirtual,   /* True if this is a VIRTUAL table */\n    int noErr        /* Do nothing if table already exists */\n    )\n    {\n      Table pTable;\n      string zName = null; /* The name of the new table */\n      sqlite3 db = pParse.db;\n      Vdbe v;\n      int iDb;         /* Database number to create the table in */\n      Token pName = new Token();    /* Unqualified name of the table to create */\n\n      /* The table or view name to create is passed to this routine via tokens\n      ** pName1 and pName2. If the table name was fully qualified, for example:\n      **\n      ** CREATE TABLE xxx.yyy (...);\n      **\n      ** Then pName1 is set to "xxx" and pName2 "yyy". On the other hand if\n      ** the table name is not fully qualified, i.e.:\n      **\n      ** CREATE TABLE yyy(...);\n      **\n      ** Then pName1 is set to "yyy" and pName2 is "".\n      **\n      ** The call below sets the pName pointer to point at the token (pName1 or\n      ** pName2) that stores the unqualified table name. The variable iDb is\n      ** set to the index of the database that the table or view is to be\n      ** created in.\n      */\n      iDb = sqlite3TwoPartName( pParse, pName1, pName2, ref pName );\n      if ( iDb < 0 ) return;\n      if ( OMIT_TEMPDB == 0 && isTemp != 0 && iDb > 1 )\n      {\n        /* If creating a temp table, the name may not be qualified */\n        sqlite3ErrorMsg( pParse, "temporary table name must be unqualified" );\n        return;\n      }\n      if ( OMIT_TEMPDB == 0 && isTemp != 0 ) iDb = 1;\n\n      pParse.sNameToken = pName;\n      zName = sqlite3NameFromToken( db, pName );\n      if ( zName == null ) return;\n      if ( SQLITE_OK != sqlite3CheckObjectName( pParse, zName ) )\n      {\n        goto begin_table_error;\n      }\n      if ( db.init.iDb == 1 ) isTemp = 1;\n#if !SQLITE_OMIT_AUTHORIZATION\nDebug.Assert( (isTemp & 1)==isTemp );\n{\nint code;\nchar *zDb = db.aDb[iDb].zName;\nif( sqlite3AuthCheck(pParse, SQLITE_INSERT, SCHEMA_TABLE(isTemp), 0, zDb) ){\ngoto begin_table_error;\n}\nif( isView ){\nif( OMIT_TEMPDB ==0&& isTemp ){\ncode = SQLITE_CREATE_TEMP_VIEW;\n}else{\ncode = SQLITE_CREATE_VIEW;\n}\n}else{\nif( OMIT_TEMPDB ==0&& isTemp ){\ncode = SQLITE_CREATE_TEMP_TABLE;\n}else{\ncode = SQLITE_CREATE_TABLE;\n}\n}\nif( !isVirtual && sqlite3AuthCheck(pParse, code, zName, 0, zDb) ){\ngoto begin_table_error;\n}\n}\n#endif\n\n      /* Make sure the new table name does not collide with an existing\n** index or table name in the same database.  Issue an error message if\n** it does. The exception is if the statement being parsed was passed\n** to an sqlite3_declare_vtab() call. In that case only the column names\n** and types will be used, so there is no need to test for namespace\n** collisions.\n*/\n      if ( !IN_DECLARE_VTAB )\n      {\n        if ( SQLITE_OK != sqlite3ReadSchema( pParse ) )\n        {\n          goto begin_table_error;\n        }\n        pTable = sqlite3FindTable( db, zName, db.aDb[iDb].zName );\n        if ( pTable != null )\n        {\n          if ( noErr == 0 )\n          {\n            sqlite3ErrorMsg( pParse, "table %T already exists", pName );\n          }\n          goto begin_table_error;\n        }\n        if ( sqlite3FindIndex( db, zName, null ) != null && ( iDb == 0 || 0 == db.init.busy ) )\n        {\n          sqlite3ErrorMsg( pParse, "there is already an index named %s", zName );\n          goto begin_table_error;\n        }\n      }\n\n      pTable = new Table();// sqlite3DbMallocZero(db, Table).Length;\n      if ( pTable == null )\n      {\n//        db.mallocFailed = 1;\n        pParse.rc = SQLITE_NOMEM;\n        pParse.nErr++;\n        goto begin_table_error;\n      }\n      pTable.zName = zName;\n      pTable.iPKey = -1;\n      pTable.pSchema = db.aDb[iDb].pSchema;\n      pTable.nRef = 1;\n      pTable.dbMem = null;\n      Debug.Assert( pParse.pNewTable == null );\n      pParse.pNewTable = pTable;\n\n      /* If this is the magic sqlite_sequence table used by autoincrement,\n      ** then record a pointer to this table in the main database structure\n      ** so that INSERT can find the table easily.\n      */\n#if !SQLITE_OMIT_AUTOINCREMENT\n      if ( pParse.nested == 0 && zName == "sqlite_sequence" )\n      {\n        pTable.pSchema.pSeqTab = pTable;\n      }\n#endif\n\n      /* Begin generating the code that will insert the table record into\n** the SQLITE_MASTER table.  Note in particular that we must go ahead\n** and allocate the record number for the table entry now.  Before any\n** PRIMARY KEY or UNIQUE keywords are parsed.  Those keywords will cause\n** indices to be created and the table record must come before the\n** indices.  Hence, the record number for the table must be allocated\n** now.\n*/\n      if ( 0 == db.init.busy && ( v = sqlite3GetVdbe( pParse ) ) != null )\n      {\n        int j1;\n        int fileFormat;\n        int reg1, reg2, reg3;\n        sqlite3BeginWriteOperation( pParse, 0, iDb );\n\n        if ( isVirtual != 0 )\n        {\n          sqlite3VdbeAddOp0( v, OP_VBegin );\n        }\n\n        /* If the file format and encoding in the database have not been set,\n        ** set them now.\n        */\n        reg1 = pParse.regRowid = ++pParse.nMem;\n        reg2 = pParse.regRoot = ++pParse.nMem;\n        reg3 = ++pParse.nMem;\n        sqlite3VdbeAddOp3( v, OP_ReadCookie, iDb, reg3, BTREE_FILE_FORMAT );\n        sqlite3VdbeUsesBtree( v, iDb );\n        j1 = sqlite3VdbeAddOp1( v, OP_If, reg3 );\n        fileFormat = ( db.flags & SQLITE_LegacyFileFmt ) != 0 ?\n        1 : SQLITE_MAX_FILE_FORMAT;\n        sqlite3VdbeAddOp2( v, OP_Integer, fileFormat, reg3 );\n        sqlite3VdbeAddOp3( v, OP_SetCookie, iDb, BTREE_FILE_FORMAT, reg3 );\n        sqlite3VdbeAddOp2( v, OP_Integer, ENC( db ), reg3 );\n        sqlite3VdbeAddOp3( v, OP_SetCookie, iDb, BTREE_TEXT_ENCODING, reg3 );\n        sqlite3VdbeJumpHere( v, j1 );\n\n        /* This just creates a place-holder record in the sqlite_master table.\n        ** The record created does not contain anything yet.  It will be replaced\n        ** by the real entry in code generated at sqlite3EndTable().\n        **\n        ** The rowid for the new entry is left in register pParse->regRowid.\n        ** The root page number of the new table is left in reg pParse->regRoot.\n        ** The rowid and root page number values are needed by the code that\n        ** sqlite3EndTable will generate.\n        */\n        if ( isView != 0 || isVirtual != 0 )\n        {\n          sqlite3VdbeAddOp2( v, OP_Integer, 0, reg2 );\n        }\n        else\n        {\n          sqlite3VdbeAddOp2( v, OP_CreateTable, iDb, reg2 );\n        }\n        sqlite3OpenMasterTable( pParse, iDb );\n        sqlite3VdbeAddOp2( v, OP_NewRowid, 0, reg1 );\n        sqlite3VdbeAddOp2( v, OP_Null, 0, reg3 );\n        sqlite3VdbeAddOp3( v, OP_Insert, 0, reg3, reg1 );\n        sqlite3VdbeChangeP5( v, OPFLAG_APPEND );\n        sqlite3VdbeAddOp0( v, OP_Close );\n      }\n\n      /* Normal (non-error) return. */\n      return;\n\n      /* If an error occurs, we jump here */\nbegin_table_error:\n      //sqlite3DbFree( db, ref zName );\n      return;\n    }\n\n    /*\n    ** This macro is used to compare two strings in a case-insensitive manner.\n    ** It is slightly faster than calling sqlite3StrICmp() directly, but\n    ** produces larger code.\n    **\n    ** WARNING: This macro is not compatible with the strcmp() family. It\n    ** returns true if the two strings are equal, otherwise false.\n    */\n    //#define STRICMP(x, y) (\\\n    //sqlite3UpperToLower[*(unsigned char *)(x)]==   \\\n    //sqlite3UpperToLower[*(unsigned char *)(y)]     \\\n    //&& sqlite3StrICmp((x)+1,(y)+1)==0 )\n\n    /*\n    ** Add a new column to the table currently being constructed.\n    **\n    ** The parser calls this routine once for each column declaration\n    ** in a CREATE TABLE statement.  sqlite3StartTable() gets called\n    ** first to get things going.  Then this routine is called for each\n    ** column.\n    */\n    static void sqlite3AddColumn( Parse pParse, Token pName )\n    {\n      Table p;\n      int i;\n      string z;\n      Column pCol;\n      sqlite3 db = pParse.db;\n      if ( ( p = pParse.pNewTable ) == null ) return;\n#if SQLITE_MAX_COLUMN || !SQLITE_MAX_COLUMN\n      if ( p.nCol + 1 > db.aLimit[SQLITE_LIMIT_COLUMN] )\n      {\n        sqlite3ErrorMsg( pParse, "too many columns on %s", p.zName );\n        return;\n      }\n#endif\n      z = sqlite3NameFromToken( db, pName );\n      if ( z == null ) return;\n      for ( i = 0 ; i < p.nCol ; i++ )\n      {\n        if ( 0 == sqlite3StrICmp( z, p.aCol[i].zName ) )\n        {//STRICMP(z, p.aCol[i].zName) ){\n          sqlite3ErrorMsg( pParse, "duplicate column name: %s", z );\n          //sqlite3DbFree( db, ref z );\n          return;\n        }\n      }\n      if ( ( p.nCol & 0x7 ) == 0 )\n      {\n        //aNew = sqlite3DbRealloc(db,p.aCol,(p.nCol+8)*sizeof(p.aCol[0]));\n        //if( aNew==0 ){\n        //  //sqlite3DbFree(db,ref z);\n        //  return;\n        //}\n        Array.Resize( ref p.aCol, p.nCol + 8 );\n      }\n      p.aCol[p.nCol] = new Column();\n      pCol = p.aCol[p.nCol];\n      //memset(pCol, 0, sizeof(p.aCol[0]));\n      pCol.zName = z;\n\n      /* If there is no type specified, columns have the default affinity\n      ** \'NONE\'. If there is a type specified, then sqlite3AddColumnType() will\n      ** be called next to set pCol.affinity correctly.\n      */\n      pCol.affinity = SQLITE_AFF_NONE;\n      p.nCol++;\n    }\n\n    /*\n    ** This routine is called by the parser while in the middle of\n    ** parsing a CREATE TABLE statement.  A "NOT NULL" constraint has\n    ** been seen on a column.  This routine sets the notNull flag on\n    ** the column currently under construction.\n    */\n    static void sqlite3AddNotNull( Parse pParse, int onError )\n    {\n      Table p;\n      p = pParse.pNewTable;\n      if ( p == null || NEVER( p.nCol < 1 ) ) return;\n      p.aCol[p.nCol - 1].notNull = (u8)onError;\n    }\n\n    /*\n    ** Scan the column type name zType (length nType) and return the\n    ** associated affinity type.\n    **\n    ** This routine does a case-independent search of zType for the\n    ** substrings in the following table. If one of the substrings is\n    ** found, the corresponding affinity is returned. If zType contains\n    ** more than one of the substrings, entries toward the top of\n    ** the table take priority. For example, if zType is \'BLOBINT\',\n    ** SQLITE_AFF_INTEGER is returned.\n    **\n    ** Substring     | Affinity\n    ** --------------------------------\n    ** \'INT\'         | SQLITE_AFF_INTEGER\n    ** \'CHAR\'        | SQLITE_AFF_TEXT\n    ** \'CLOB\'        | SQLITE_AFF_TEXT\n    ** \'TEXT\'        | SQLITE_AFF_TEXT\n    ** \'BLOB\'        | SQLITE_AFF_NONE\n    ** \'REAL\'        | SQLITE_AFF_REAL\n    ** \'FLOA\'        | SQLITE_AFF_REAL\n    ** \'DOUB\'        | SQLITE_AFF_REAL\n    **\n    ** If none of the substrings in the above table are found,\n    ** SQLITE_AFF_NUMERIC is returned.\n    */\n    static char sqlite3AffinityType( string zIn )\n    {\n      //u32 h = 0;\n      //char aff = SQLITE_AFF_NUMERIC;\n      zIn = zIn.ToLower();\n      if ( zIn.Contains( "char" ) || zIn.Contains( "clob" ) || zIn.Contains( "text" ) ) return SQLITE_AFF_TEXT;\n      if ( zIn.Contains( "blob" ) ) return SQLITE_AFF_NONE;\n      if ( zIn.Contains( "doub" ) || zIn.Contains( "floa" ) || zIn.Contains( "real" ) ) return SQLITE_AFF_REAL;\n      if ( zIn.Contains( "int" ) ) return SQLITE_AFF_INTEGER;\n      return SQLITE_AFF_NUMERIC;\n      //      string zEnd = pType.z.Substring(pType.n);\n\n      //      while( zIn!=zEnd ){\n      //        h = (h<<8) + sqlite3UpperToLower[*zIn];\n      //        zIn++;\n      //        if( h==((\'c\'<<24)+(\'h\'<<16)+(\'a\'<<8)+\'r\') ){             /* CHAR */\n      //          aff = SQLITE_AFF_TEXT;\n      //        }else if( h==((\'c\'<<24)+(\'l\'<<16)+(\'o\'<<8)+\'b\') ){       /* CLOB */\n      //          aff = SQLITE_AFF_TEXT;\n      //        }else if( h==((\'t\'<<24)+(\'e\'<<16)+(\'x\'<<8)+\'t\') ){       /* TEXT */\n      //          aff = SQLITE_AFF_TEXT;\n      //        }else if( h==((\'b\'<<24)+(\'l\'<<16)+(\'o\'<<8)+\'b\')          /* BLOB */\n      //            && (aff==SQLITE_AFF_NUMERIC || aff==SQLITE_AFF_REAL) ){\n      //          aff = SQLITE_AFF_NONE;\n      //#if !SQLITE_OMIT_FLOATING_POINT\n      //        }else if( h==((\'r\'<<24)+(\'e\'<<16)+(\'a\'<<8)+\'l\')          /* REAL */\n      //            && aff==SQLITE_AFF_NUMERIC ){\n      //          aff = SQLITE_AFF_REAL;\n      //        }else if( h==((\'f\'<<24)+(\'l\'<<16)+(\'o\'<<8)+\'a\')          /* FLOA */\n      //            && aff==SQLITE_AFF_NUMERIC ){\n      //          aff = SQLITE_AFF_REAL;\n      //        }else if( h==((\'d\'<<24)+(\'o\'<<16)+(\'u\'<<8)+\'b\')          /* DOUB */\n      //            && aff==SQLITE_AFF_NUMERIC ){\n      //          aff = SQLITE_AFF_REAL;\n      //#endif\n      //        }else if( (h&0x00FFFFFF)==((\'i\'<<16)+(\'n\'<<8)+\'t\') ){    /* INT */\n      //          aff = SQLITE_AFF_INTEGER;\n      //          break;\n      //        }\n      //      }\n\n      //      return aff;\n    }\n\n    /*\n    ** This routine is called by the parser while in the middle of\n    ** parsing a CREATE TABLE statement.  The pFirst token is the first\n    ** token in the sequence of tokens that describe the type of the\n    ** column currently under construction.   pLast is the last token\n    ** in the sequence.  Use this information to construct a string\n    ** that contains the typename of the column and store that string\n    ** in zType.\n    */\n    static void sqlite3AddColumnType( Parse pParse, Token pType )\n    {\n      Table p;\n      Column pCol;\n\n      p = pParse.pNewTable;\n      if ( p == null || NEVER( p.nCol < 1 ) ) return;\n      pCol = p.aCol[p.nCol - 1];\n      Debug.Assert( pCol.zType == null );\n      pCol.zType = sqlite3NameFromToken( pParse.db, pType );\n      pCol.affinity = sqlite3AffinityType( pCol.zType );\n    }\n\n\n    /*\n    ** The expression is the default value for the most recently added column\n    ** of the table currently under construction.\n    **\n    ** Default value expressions must be constant.  Raise an exception if this\n    ** is not the case.\n    **\n    ** This routine is called by the parser while in the middle of\n    ** parsing a CREATE TABLE statement.\n    */\n    static void sqlite3AddDefaultValue( Parse pParse, ExprSpan pSpan )\n    {\n      Table p;\n      Column pCol;\n      sqlite3 db = pParse.db;\n      p = pParse.pNewTable;\n      if ( p != null )\n      {\n        pCol = ( p.aCol[p.nCol - 1] );\n        if ( sqlite3ExprIsConstantOrFunction( pSpan.pExpr ) == 0 )\n        {\n          sqlite3ErrorMsg( pParse, "default value of column [%s] is not constant",\n          pCol.zName );\n        }\n        else\n        {\n          /* A copy of pExpr is used instead of the original, as pExpr contains\n          ** tokens that point to volatile memory. The \'span\' of the expression\n          ** is required by pragma table_info.\n          */\n          sqlite3ExprDelete( db, ref pCol.pDflt );\n          pCol.pDflt = sqlite3ExprDup( db, pSpan.pExpr, EXPRDUP_REDUCE );\n          //sqlite3DbFree( db, pCol.zDflt );\n          pCol.zDflt = pSpan.zStart.Substring( 0, pSpan.zStart.Length - pSpan.zEnd.Length );\n          //sqlite3DbStrNDup( db, pSpan.zStart,\n          //                               (int)( pSpan.zEnd.Length - pSpan.zStart.Length ) );\n        }\n      }\n      sqlite3ExprDelete( db, ref pSpan.pExpr );\n    }\n\n    /*\n    ** Designate the PRIMARY KEY for the table.  pList is a list of names\n    ** of columns that form the primary key.  If pList is NULL, then the\n    ** most recently added column of the table is the primary key.\n    **\n    ** A table can have at most one primary key.  If the table already has\n    ** a primary key (and this is the second primary key) then create an\n    ** error.\n    **\n    ** If the PRIMARY KEY is on a single column whose datatype is INTEGER,\n    ** then we will try to use that column as the rowid.  Set the Table.iPKey\n    ** field of the table under construction to be the index of the\n    ** INTEGER PRIMARY KEY column.  Table.iPKey is set to -1 if there is\n    ** no INTEGER PRIMARY KEY.\n    **\n    ** If the key is not an INTEGER PRIMARY KEY, then create a unique\n    ** index for the key.  No index is created for INTEGER PRIMARY KEYs.\n    */\n    // OVERLOADS, so I don\'t need to rewrite parse.c\n    static void sqlite3AddPrimaryKey( Parse pParse, int null_2, int onError, int autoInc, int sortOrder )\n    { sqlite3AddPrimaryKey( pParse, null, onError, autoInc, sortOrder ); }\n    static void sqlite3AddPrimaryKey(\n    Parse pParse,    /* Parsing context */\n    ExprList pList,  /* List of field names to be indexed */\n    int onError,     /* What to do with a uniqueness conflict */\n    int autoInc,    /* True if the AUTOINCREMENT keyword is present */\n    int sortOrder   /* SQLITE_SO_ASC or SQLITE_SO_DESC */\n    )\n    {\n      Table pTab = pParse.pNewTable;\n      string zType = null;\n      int iCol = -1, i;\n      if ( pTab == null || IN_DECLARE_VTAB ) goto primary_key_exit;\n      if ( ( pTab.tabFlags & TF_HasPrimaryKey ) != 0 )\n      {\n        sqlite3ErrorMsg( pParse,\n        "table \\"%s\\" has more than one primary key", pTab.zName );\n        goto primary_key_exit;\n      }\n      pTab.tabFlags |= TF_HasPrimaryKey;\n      if ( pList == null )\n      {\n        iCol = pTab.nCol - 1;\n        pTab.aCol[iCol].isPrimKey = 1;\n      }\n      else\n      {\n        for ( i = 0 ; i < pList.nExpr ; i++ )\n        {\n          for ( iCol = 0 ; iCol < pTab.nCol ; iCol++ )\n          {\n            if ( sqlite3StrICmp( pList.a[i].zName, pTab.aCol[iCol].zName ) == 0 )\n            {\n              break;\n            }\n          }\n          if ( iCol < pTab.nCol )\n          {\n            pTab.aCol[iCol].isPrimKey = 0;\n          }\n        }\n        if ( pList.nExpr > 1 ) iCol = -1;\n      }\n      if ( iCol >= 0 && iCol < pTab.nCol )\n      {\n        zType = pTab.aCol[iCol].zType;\n      }\n      if ( zType != null && sqlite3StrICmp( zType, "INTEGER" ) == 0\n      && sortOrder == SQLITE_SO_ASC )\n      {\n        pTab.iPKey = iCol;\n        pTab.keyConf = (byte)onError;\n        Debug.Assert( autoInc == 0 || autoInc == 1 );\n        pTab.tabFlags |= (u8)( autoInc * TF_Autoincrement );\n      }\n      else if ( autoInc != 0 )\n      {\n#if !SQLITE_OMIT_AUTOINCREMENT\n        sqlite3ErrorMsg( pParse, "AUTOINCREMENT is only allowed on an " +\n        "INTEGER PRIMARY KEY" );\n#endif\n      }\n      else\n      {\n        sqlite3CreateIndex( pParse, null, null, null, pList, onError, null, null, sortOrder, 0 );\n        pList = null;\n      }\n\nprimary_key_exit:\n      sqlite3ExprListDelete( pParse.db, ref pList );\n      return;\n    }\n\n    /*\n    ** Add a new CHECK constraint to the table currently under construction.\n    */\n    static void sqlite3AddCheckConstraint(\n    Parse pParse,    /* Parsing context */\n    Expr pCheckExpr  /* The check expression */\n    )\n    {\n      sqlite3 db = pParse.db;\n#if !SQLITE_OMIT_CHECK\n      Table pTab = pParse.pNewTable;\n      if ( pTab != null && !IN_DECLARE_VTAB )\n      {\n        pTab.pCheck = sqlite3ExprAnd( db, pTab.pCheck, pCheckExpr );\n      }\n      else\n#endif\n      {\n        sqlite3ExprDelete( db, ref pCheckExpr );\n      }\n    }\n    /*\n    ** Set the collation function of the most recently parsed table column\n    ** to the CollSeq given.\n    */\n    static void sqlite3AddCollateType( Parse pParse, Token pToken )\n    {\n      Table p;\n      int i;\n      string zColl;              /* Dequoted name of collation sequence */\n      sqlite3 db;\n\n      if ( ( p = pParse.pNewTable ) == null ) return;\n      i = p.nCol - 1;\n      db = p.dbMem;\n      zColl = sqlite3NameFromToken( db, pToken );\n      if ( zColl == null ) return;\n\n      if ( sqlite3LocateCollSeq( pParse, zColl ) != null )\n      {\n        Index pIdx;\n        p.aCol[i].zColl = zColl;\n\n        /* If the column is declared as "<name> PRIMARY KEY COLLATE <type>",\n        ** then an index may have been created on this column before the\n        ** collation type was added. Correct this if it is the case.\n        */\n        for ( pIdx = p.pIndex ; pIdx != null ; pIdx = pIdx.pNext )\n        {\n          Debug.Assert( pIdx.nColumn == 1 );\n          if ( pIdx.aiColumn[0] == i )\n          {\n            pIdx.azColl[0] = p.aCol[i].zColl;\n          }\n        }\n      }\n      else\n      {\n        //sqlite3DbFree( db, ref zColl );\n      }\n    }\n\n    /*\n    ** This function returns the collation sequence for database native text\n    ** encoding identified by the string zName, length nName.\n    **\n    ** If the requested collation sequence is not available, or not available\n    ** in the database native encoding, the collation factory is invoked to\n    ** request it. If the collation factory does not supply such a sequence,\n    ** and the sequence is available in another text encoding, then that is\n    ** returned instead.\n    **\n    ** If no versions of the requested collations sequence are available, or\n    ** another error occurs, NULL is returned and an error message written into\n    ** pParse.\n    **\n    ** This routine is a wrapper around sqlite3FindCollSeq().  This routine\n    ** invokes the collation factory if the named collation cannot be found\n    ** and generates an error message.\n    **\n    ** See also: sqlite3FindCollSeq(), sqlite3GetCollSeq()\n    */\n    static CollSeq sqlite3LocateCollSeq( Parse pParse, string zName )\n    {\n      sqlite3 db = pParse.db;\n      u8 enc = db.aDb[0].pSchema.enc;// ENC(db);\n      u8 initbusy = db.init.busy;\n      CollSeq pColl;\n\n      pColl = sqlite3FindCollSeq( db, enc, zName, initbusy );\n      if ( 0 == initbusy && ( pColl == null || pColl.xCmp == null ) )\n      {\n        pColl = sqlite3GetCollSeq( db, pColl, zName );\n        if ( pColl == null )\n        {\n          sqlite3ErrorMsg( pParse, "no such collation sequence: %s", zName );\n        }\n      }\n\n      return pColl;\n    }\n\n\n    /*\n    ** Generate code that will increment the schema cookie.\n    **\n    ** The schema cookie is used to determine when the schema for the\n    ** database changes.  After each schema change, the cookie value\n    ** changes.  When a process first reads the schema it records the\n    ** cookie.  Thereafter, whenever it goes to access the database,\n    ** it checks the cookie to make sure the schema has not changed\n    ** since it was last read.\n    **\n    ** This plan is not completely bullet-proof.  It is possible for\n    ** the schema to change multiple times and for the cookie to be\n    ** set back to prior value.  But schema changes are infrequent\n    ** and the probability of hitting the same cookie value is only\n    ** 1 chance in 2^32.  So we\'re safe enough.\n    */\n    static void sqlite3ChangeCookie( Parse pParse, int iDb )\n    {\n      int r1 = sqlite3GetTempReg( pParse );\n      sqlite3 db = pParse.db;\n      Vdbe v = pParse.pVdbe;\n      sqlite3VdbeAddOp2( v, OP_Integer, db.aDb[iDb].pSchema.schema_cookie + 1, r1 );\n      sqlite3VdbeAddOp3( v, OP_SetCookie, iDb, BTREE_SCHEMA_VERSION, r1 );\n      sqlite3ReleaseTempReg( pParse, r1 );\n    }\n\n    /*\n    ** Measure the number of characters needed to output the given\n    ** identifier.  The number returned includes any quotes used\n    ** but does not include the null terminator.\n    **\n    ** The estimate is conservative.  It might be larger that what is\n    ** really needed.\n    */\n    static int identLength( string z )\n    {\n      int n;\n      for ( n = 0 ; n < z.Length ; n++ )\n      {\n        if ( z[n] == (byte)\'"\' ) { n++; }\n      }\n      return n + 2;\n    }\n\n\n    /*\n    ** The first parameter is a pointer to an output buffer. The second\n    ** parameter is a pointer to an integer that contains the offset at\n    ** which to write into the output buffer. This function copies the\n    ** nul-terminated string pointed to by the third parameter, zSignedIdent,\n    ** to the specified offset in the buffer and updates *pIdx to refer\n    ** to the first byte after the last byte written before returning.\n    **\n    ** If the string zSignedIdent consists entirely of alpha-numeric\n    ** characters, does not begin with a digit and is not an SQL keyword,\n    ** then it is copied to the output buffer exactly as it is. Otherwise,\n    ** it is quoted using double-quotes.\n    */\n    static void identPut( StringBuilder z, ref int pIdx, string zSignedIdent )\n    {\n      string zIdent = zSignedIdent;\n      int i; int j; bool needQuote;\n      i = pIdx;\n      for ( j = 0 ; j < zIdent.Length ; j++ )\n      {\n        if ( !sqlite3Isalnum( zIdent[j] ) && zIdent[j] != \'_\' ) break;\n      }\n      needQuote = sqlite3Isdigit( zIdent[0] ) || sqlite3KeywordCode( zIdent, j ) != TK_ID;\n      if ( !needQuote )\n      {\n        needQuote = ( j < zIdent.Length && zIdent[j] != 0 );\n      }\n      if ( needQuote ) { if ( i == z.Length ) z.Append( \'\\0\' ); z[i++] = \'"\'; }\n      for ( j = 0 ; j < zIdent.Length ; j++ )\n      {\n        if ( i == z.Length ) z.Append( \'\\0\' );\n        z[i++] = zIdent[j];\n        if ( zIdent[j] == \'"\' ) { if ( i == z.Length ) z.Append( \'\\0\' ); z[i++] = \'"\'; }\n      }\n      if ( needQuote ) { if ( i == z.Length ) z.Append( \'\\0\' ); z[i++] = \'"\'; }\n      //z[i] = 0;\n      pIdx = i;\n    }\n\n    /*\n    ** Generate a CREATE TABLE statement appropriate for the given\n    ** table.  Memory to hold the text of the statement is obtained\n    ** from sqliteMalloc() and must be freed by the calling function.\n    */\n    static string createTableStmt( sqlite3 db, Table p )\n    {\n      int i, k, n;\n      StringBuilder zStmt;\n      string zSep; string zSep2; string zEnd;\n      Column pCol;\n      n = 0;\n      for ( i = 0 ; i < p.nCol ; i++ )\n      {//, pCol++){\n        pCol = p.aCol[i];\n        n += identLength( pCol.zName ) + 5;\n      }\n      n += identLength( p.zName );\n      if ( n < 50 )\n      {\n        zSep = "";\n        zSep2 = ",";\n        zEnd = ")";\n      }\n      else\n      {\n        zSep = "\\n  ";\n        zSep2 = ",\\n  ";\n        zEnd = "\\n)";\n      }\n      n += 35 + 6 * p.nCol;\n      zStmt = new StringBuilder( n );\n      //zStmt = sqlite3Malloc( n );\n      //if( zStmt==0 ){\n      //  db.mallocFailed = 1;\n      //  return 0;\n      //}\n      //sqlite3_snprintf(n, zStmt,"CREATE TABLE ");\n      zStmt.Append( "CREATE TABLE " );\n      k = sqlite3Strlen30( zStmt );\n      identPut( zStmt, ref k, p.zName );\n      zStmt.Append( \'(\' );//zStmt[k++] = \'(\';\n      for ( i = 0 ; i < p.nCol ; i++ )\n      {//, pCol++){\n        pCol = p.aCol[i];\n        string[] azType = new string[]  {\n/* SQLITE_AFF_TEXT    */ " TEXT",\n/* SQLITE_AFF_NONE    */ "",\n/* SQLITE_AFF_NUMERIC */ " NUM",\n/* SQLITE_AFF_INTEGER */ " INT",\n/* SQLITE_AFF_REAL    */ " REAL"\n};\n        int len;\n        string zType;\n\n        zStmt.Append( zSep );//  sqlite3_snprintf(n-k, zStmt[k], zSep);\n        k = sqlite3Strlen30( zStmt );//  k += strlen(zStmt[k]);\n        zSep = zSep2;\n        identPut( zStmt, ref k, pCol.zName );\n        Debug.Assert( pCol.affinity - SQLITE_AFF_TEXT >= 0 );\n        Debug.Assert( pCol.affinity - SQLITE_AFF_TEXT < azType.Length );//sizeof(azType)/sizeof(azType[0]) );\n        testcase( pCol.affinity == SQLITE_AFF_TEXT );\n        testcase( pCol.affinity == SQLITE_AFF_NONE );\n        testcase( pCol.affinity == SQLITE_AFF_NUMERIC );\n        testcase( pCol.affinity == SQLITE_AFF_INTEGER );\n        testcase( pCol.affinity == SQLITE_AFF_REAL );\n\n        zType = azType[pCol.affinity - SQLITE_AFF_TEXT];\n        len = sqlite3Strlen30( zType );\n        Debug.Assert( pCol.affinity == SQLITE_AFF_NONE\n        || pCol.affinity == sqlite3AffinityType( zType ) );\n        zStmt.Append( zType );// memcpy( &zStmt[k], zType, len );\n        k += len;\n        Debug.Assert( k <= n );\n      }\n      zStmt.Append( zEnd );//sqlite3_snprintf(n-k, zStmt[k], "%s", zEnd);\n      return zStmt.ToString();\n    }\n\n    /*\n    ** This routine is called to report the final ")" that terminates\n    ** a CREATE TABLE statement.\n    **\n    ** The table structure that other action routines have been building\n    ** is added to the internal hash tables, assuming no errors have\n    ** occurred.\n    **\n    ** An entry for the table is made in the master table on disk, unless\n    ** this is a temporary table or db.init.busy==1.  When db.init.busy==1\n    ** it means we are reading the sqlite_master table because we just\n    ** connected to the database or because the sqlite_master table has\n    ** recently changed, so the entry for this table already exists in\n    ** the sqlite_master table.  We do not want to create it again.\n    **\n    ** If the pSelect argument is not NULL, it means that this routine\n    ** was called to create a table generated from a\n    ** "CREATE TABLE ... AS SELECT ..." statement.  The column names of\n    ** the new table will match the result set of the SELECT.\n    */\n    // OVERLOADS, so I don\'t need to rewrite parse.c\n    static void sqlite3EndTable( Parse pParse, Token pCons, Token pEnd, int null_4 )\n    { sqlite3EndTable( pParse, pCons, pEnd, null ); }\n    static void sqlite3EndTable( Parse pParse, int null_2, int null_3, Select pSelect )\n    { sqlite3EndTable( pParse, null, null, pSelect ); }\n\n    static void sqlite3EndTable(\n    Parse pParse,          /* Parse context */\n    Token pCons,           /* The \',\' token after the last column defn. */\n    Token pEnd,            /* The final \')\' token in the CREATE TABLE */\n    Select pSelect         /* Select from a "CREATE ... AS SELECT" */\n    )\n    {\n      Table p;\n      sqlite3 db = pParse.db;\n      int iDb;\n\n      if ( ( pEnd == null && pSelect == null ) /*|| db.mallocFailed != 0 */ )\n      {\n        return;\n      }\n      p = pParse.pNewTable;\n      if ( p == null ) return;\n\n      Debug.Assert( 0 == db.init.busy || pSelect == null );\n\n      iDb = sqlite3SchemaToIndex( db, p.pSchema );\n\n#if !SQLITE_OMIT_CHECK\n      /* Resolve names in all CHECK constraint expressions.\n*/\n      if ( p.pCheck != null )\n      {\n        SrcList sSrc;                   /* Fake SrcList for pParse.pNewTable */\n        NameContext sNC;                /* Name context for pParse.pNewTable */\n\n        sNC = new NameContext();// memset(sNC, 0, sizeof(sNC));\n        sSrc = new SrcList();// memset(sSrc, 0, sizeof(sSrc));\n        sSrc.nSrc = 1;\n        sSrc.a = new SrcList_item[1];\n        sSrc.a[0] = new SrcList_item();\n        sSrc.a[0].zName = p.zName;\n        sSrc.a[0].pTab = p;\n        sSrc.a[0].iCursor = -1;\n        sNC.pParse = pParse;\n        sNC.pSrcList = sSrc;\n        sNC.isCheck = 1;\n        if ( sqlite3ResolveExprNames( sNC, ref p.pCheck ) != 0 )\n        {\n          return;\n        }\n      }\n#endif // * !SQLITE_OMIT_CHECK) */\n\n      /* If the db.init.busy is 1 it means we are reading the SQL off the\n** "sqlite_master" or "sqlite_temp_master" table on the disk.\n** So do not write to the disk again.  Extract the root page number\n** for the table from the db.init.newTnum field.  (The page number\n** should have been put there by the sqliteOpenCb routine.)\n*/\n      if ( db.init.busy != 0 )\n      {\n        p.tnum = db.init.newTnum;\n      }\n\n      /* If not initializing, then create a record for the new table\n      ** in the SQLITE_MASTER table of the database.\n      **\n      ** If this is a TEMPORARY table, write the entry into the auxiliary\n      ** file instead of into the main database file.\n      */\n      if ( 0 == db.init.busy )\n      {\n        int n;\n        Vdbe v;\n        String zType = "";    /* "view" or "table" */\n        String zType2 = "";    /* "VIEW" or "TABLE" */\n        String zStmt = "";    /* Text of the CREATE TABLE or CREATE VIEW statement */\n\n        v = sqlite3GetVdbe( pParse );\n        if ( NEVER( v == null ) ) return;\n\n        sqlite3VdbeAddOp1( v, OP_Close, 0 );\n\n        /*\n        ** Initialize zType for the new view or table.\n        */\n        if ( p.pSelect == null )\n        {\n          /* A regular table */\n          zType = "table";\n          zType2 = "TABLE";\n#if !SQLITE_OMIT_VIEW\n        }\n        else\n        {\n          /* A view */\n          zType = "view";\n          zType2 = "VIEW";\n#endif\n        }\n\n        /* If this is a CREATE TABLE xx AS SELECT ..., execute the SELECT\n        ** statement to populate the new table. The root-page number for the\n        ** new table is in register pParse->regRoot.\n        **\n        ** Once the SELECT has been coded by sqlite3Select(), it is in a\n        ** suitable state to query for the column names and types to be used\n        ** by the new table.\n        **\n        ** A shared-cache write-lock is not required to write to the new table,\n        ** as a schema-lock must have already been obtained to create it. Since\n        ** a schema-lock excludes all other database users, the write-lock would\n        ** be redundant.\n        */\n        if ( pSelect != null )\n        {\n          SelectDest dest = new SelectDest();\n          Table pSelTab;\n\n          Debug.Assert( pParse.nTab == 1 );\n          sqlite3VdbeAddOp3( v, OP_OpenWrite, 1, pParse.regRoot, iDb );\n          sqlite3VdbeChangeP5( v, 1 );\n          pParse.nTab = 2;\n          sqlite3SelectDestInit( dest, SRT_Table, 1 );\n          sqlite3Select( pParse, pSelect, ref  dest );\n          sqlite3VdbeAddOp1( v, OP_Close, 1 );\n          if ( pParse.nErr == 0 )\n          {\n            pSelTab = sqlite3ResultSetOfSelect( pParse, pSelect );\n            if ( pSelTab == null ) return;\n            Debug.Assert( p.aCol == null );\n            p.nCol = pSelTab.nCol;\n            p.aCol = pSelTab.aCol;\n            pSelTab.nCol = 0;\n            pSelTab.aCol = null;\n            sqlite3DeleteTable( ref pSelTab );\n          }\n        }\n\n        /* Compute the complete text of the CREATE statement */\n        if ( pSelect != null )\n        {\n          zStmt = createTableStmt( db, p );\n        }\n        else\n        {\n          n = (int)( pParse.sNameToken.z.Length - pEnd.z.Length ) + 1;\n          zStmt = sqlite3MPrintf( db,\n          "CREATE %s %.*s", zType2, n, pParse.sNameToken.z\n          );\n        }\n\n        /* A slot for the record has already been allocated in the\n        ** SQLITE_MASTER table.  We just need to update that slot with all\n        ** the information we\'ve collected.\n        */\n        sqlite3NestedParse( pParse,\n        "UPDATE %Q.%s " +\n        "SET type=\'%s\', name=%Q, tbl_name=%Q, rootpage=#%d, sql=%Q " +\n        "WHERE rowid=#%d",\n        db.aDb[iDb].zName, SCHEMA_TABLE( iDb ),\n        zType,\n        p.zName,\n        p.zName,\n        pParse.regRoot,\n        zStmt,\n        pParse.regRowid\n        );\n        //sqlite3DbFree( db, ref zStmt );\n        sqlite3ChangeCookie( pParse, iDb );\n\n#if !SQLITE_OMIT_AUTOINCREMENT\n        /* Check to see if we need to create an sqlite_sequence table for\n** keeping track of autoincrement keys.\n*/\n        if ( ( p.tabFlags & TF_Autoincrement ) != 0 )\n        {\n          Db pDb = db.aDb[iDb];\n          if ( pDb.pSchema.pSeqTab == null )\n          {\n            sqlite3NestedParse( pParse,\n            "CREATE TABLE %Q.sqlite_sequence(name,seq)",\n            pDb.zName\n            );\n          }\n        }\n#endif\n\n        /* Reparse everything to update our internal data structures */\n        sqlite3VdbeAddOp4( v, OP_ParseSchema, iDb, 0, 0,\n        sqlite3MPrintf( db, "tbl_name=\'%q\'", p.zName ), P4_DYNAMIC );\n      }\n\n\n      /* Add the table to the in-memory representation of the database.\n      */\n      if ( db.init.busy != 0 )\n      {\n        Table pOld;\n        Schema pSchema = p.pSchema;\n        pOld = (Table)sqlite3HashInsert( ref pSchema.tblHash, p.zName,\n        sqlite3Strlen30( p.zName ), p );\n        if ( pOld != null )\n        {\n          Debug.Assert( p == pOld );  /* Malloc must have failed inside HashInsert() */\n  //        db.mallocFailed = 1;\n          return;\n        }\n        pParse.pNewTable = null;\n        db.nTable++;\n        db.flags |= SQLITE_InternChanges;\n\n#if !SQLITE_OMIT_ALTERTABLE\n        if ( p.pSelect == null )\n        {\n          string zName = pParse.sNameToken.z;\n          int nName;\n          Debug.Assert( pSelect == null && pCons != null && pEnd != null );\n          if ( pCons.z == null )\n          {\n            pCons = pEnd;\n          }\n          nName = zName.Length - pCons.z.Length;\n          p.addColOffset = 13 + nName; // sqlite3Utf8CharLen(zName, nName);\n        }\n#endif\n      }\n    }\n\n#if !SQLITE_OMIT_VIEW\n    /*\n** The parser calls this routine in order to create a new VIEW\n*/\n    static void sqlite3CreateView(\n    Parse pParse,     /* The parsing context */\n    Token pBegin,     /* The CREATE token that begins the statement */\n    Token pName1,     /* The token that holds the name of the view */\n    Token pName2,     /* The token that holds the name of the view */\n    Select pSelect,   /* A SELECT statement that will become the new view */\n    int isTemp,      /* TRUE for a TEMPORARY view */\n    int noErr         /* Suppress error messages if VIEW already exists */\n    )\n    {\n      Table p;\n      int n;\n      string z;//const char *z;\n      Token sEnd;\n      DbFixer sFix = new DbFixer();\n      Token pName = null;\n      int iDb;\n      sqlite3 db = pParse.db;\n\n      if ( pParse.nVar > 0 )\n      {\n        sqlite3ErrorMsg( pParse, "parameters are not allowed in views" );\n        sqlite3SelectDelete( db, ref pSelect );\n        return;\n      }\n      sqlite3StartTable( pParse, pName1, pName2, isTemp, 1, 0, noErr );\n      p = pParse.pNewTable;\n      if ( p == null )\n      {\n        sqlite3SelectDelete( db, ref pSelect );\n        return;\n      }\n      Debug.Assert( pParse.nErr == 0 ); /* If sqlite3StartTable return non-NULL then\n** there could not have been an error */\n      sqlite3TwoPartName( pParse, pName1, pName2, ref pName );\n      iDb = sqlite3SchemaToIndex( db, p.pSchema );\n      if ( sqlite3FixInit( sFix, pParse, iDb, "view", pName ) != 0\n      && sqlite3FixSelect( sFix, pSelect ) != 0\n      )\n      {\n        sqlite3SelectDelete( db, ref pSelect );\n        return;\n      }\n\n      /* Make a copy of the entire SELECT statement that defines the view.\n      ** This will force all the Expr.token.z values to be dynamically\n      ** allocated rather than point to the input string - which means that\n      ** they will persist after the current sqlite3_exec() call returns.\n      */\n      p.pSelect = sqlite3SelectDup( db, pSelect, EXPRDUP_REDUCE );\n      sqlite3SelectDelete( db, ref pSelect );\n      //if ( db.mallocFailed != 0 )\n      //{\n      //  return;\n      //}\n      if ( 0 == db.init.busy )\n      {\n        sqlite3ViewGetColumnNames( pParse, p );\n      }\n\n      /* Locate the end of the CREATE VIEW statement.  Make sEnd point to\n      ** the end.\n      */\n      sEnd = pParse.sLastToken;\n      if ( ALWAYS( sEnd.z[0] != 0 ) && sEnd.z[0] != \';\' )\n      {\n        sEnd.z = sEnd.z.Substring( sEnd.n );\n      }\n      sEnd.n = 0;\n      n = (int)( pBegin.z.Length - sEnd.z.Length );//sEnd.z - pBegin.z;\n      z = pBegin.z;\n      while ( ALWAYS( n > 0 ) && sqlite3Isspace( z[n - 1] ) ) { n--; }\n      sEnd.z = z.Substring( n - 1 );\n      sEnd.n = 1;\n\n      /* Use sqlite3EndTable() to add the view to the SQLITE_MASTER table */\n      sqlite3EndTable( pParse, null, sEnd, null );\n      return;\n    }\n#endif // * SQLITE_OMIT_VIEW */\n\n#if !SQLITE_OMIT_VIEW || !SQLITE_OMIT_VIRTUALTABLE\n    /*\n** The Table structure pTable is really a VIEW.  Fill in the names of\n** the columns of the view in the pTable structure.  Return the number\n** of errors.  If an error is seen leave an error message in pParse.zErrMsg.\n*/\n    static int sqlite3ViewGetColumnNames( Parse pParse, Table pTable )\n    {\n      Table pSelTab;    /* A fake table from which we get the result set */\n      Select pSel;      /* Copy of the SELECT that implements the view */\n      int nErr = 0;     /* Number of errors encountered */\n      int n;            /* Temporarily holds the number of cursors assigned */\n      sqlite3 db = pParse.db;  /* Database connection for malloc errors */\n      dxAuth xAuth;     //)(void*,int,const char*,const char*,const char*,const char*);\n\n      Debug.Assert( pTable != null );\n\n#if !SQLITE_OMIT_VIRTUALTABLE\nif ( sqlite3VtabCallConnect( pParse, pTable ) )\n{\nreturn SQLITE_ERROR;\n}\n#endif\n      if ( IsVirtual( pTable ) ) return 0;\n\n#if !SQLITE_OMIT_VIEW\n      /* A positive nCol means the columns names for this view are\n** already known.\n*/\n      if ( pTable.nCol > 0 ) return 0;\n\n      /* A negative nCol is a special marker meaning that we are currently\n      ** trying to compute the column names.  If we enter this routine with\n      ** a negative nCol, it means two or more views form a loop, like this:\n      **\n      **     CREATE VIEW one AS SELECT * FROM two;\n      **     CREATE VIEW two AS SELECT * FROM one;\n      **\n      ** Actually, the error above is now caught prior to reaching this point.\n      ** But the following test is still important as it does come up\n      ** in the following:\n      **\n      **     CREATE TABLE main.ex1(a);\n      **     CREATE TEMP VIEW ex1 AS SELECT a FROM ex1;\n      **     SELECT * FROM temp.ex1;\n      */\n      if ( pTable.nCol < 0 )\n      {\n        sqlite3ErrorMsg( pParse, "view %s is circularly defined", pTable.zName );\n        return 1;\n      }\n      Debug.Assert( pTable.nCol >= 0 );\n\n      /* If we get this far, it means we need to compute the table names.\n      ** Note that the call to sqlite3ResultSetOfSelect() will expand any\n      ** "*" elements in the results set of the view and will assign cursors\n      ** to the elements of the FROM clause.  But we do not want these changes\n      ** to be permanent.  So the computation is done on a copy of the SELECT\n      ** statement that defines the view.\n      */\n      Debug.Assert( pTable.pSelect != null );\n      pSel = sqlite3SelectDup( db, pTable.pSelect, 0 );\n      if ( pSel != null )\n      {\n        u8 enableLookaside = db.lookaside.bEnabled;\n        n = pParse.nTab;\n        sqlite3SrcListAssignCursors( pParse, pSel.pSrc );\n        pTable.nCol = -1;\n        db.lookaside.bEnabled = 0;\n#if !SQLITE_OMIT_AUTHORIZATION\nxAuth = db.xAuth;\ndb.xAuth = 0;\npSelTab = sqlite3ResultSetOfSelect(pParse, pSel);\ndb.xAuth = xAuth;\n#else\n        pSelTab = sqlite3ResultSetOfSelect( pParse, pSel );\n#endif\n        db.lookaside.bEnabled = enableLookaside;\n        pParse.nTab = n;\n        if ( pSelTab != null )\n        {\n          Debug.Assert( pTable.aCol == null );\n          pTable.nCol = pSelTab.nCol;\n          pTable.aCol = pSelTab.aCol;\n          pSelTab.nCol = 0;\n          pSelTab.aCol = null;\n          sqlite3DeleteTable( ref pSelTab );\n          pTable.pSchema.flags |= DB_UnresetViews;\n        }\n        else\n        {\n          pTable.nCol = 0;\n          nErr++;\n        }\n        sqlite3SelectDelete( db, ref pSel );\n      }\n      else\n      {\n        nErr++;\n      }\n#endif // * SQLITE_OMIT_VIEW */\n      return nErr;\n    }\n#endif // * !SQLITE_OMIT_VIEW) || !SQLITE_OMIT_VIRTUALTABLE) */\n\n#if !SQLITE_OMIT_VIEW\n    /*\n** Clear the column names from every VIEW in database idx.\n*/\n    static void sqliteViewResetAll( sqlite3 db, int idx )\n    {\n      HashElem i;\n      if ( !DbHasProperty( db, idx, DB_UnresetViews ) ) return;\n      //for(i=sqliteHashFirst(&db.aDb[idx].pSchema.tblHash); i;i=sqliteHashNext(i)){\n      for ( i = db.aDb[idx].pSchema.tblHash.first ; i != null ; i = i.next )\n      {\n        Table pTab = (Table)i.data;// sqliteHashData( i );\n        if ( pTab.pSelect != null )\n        {\n          sqliteResetColumnNames( pTab );\n        }\n      }\n      DbClearProperty( db, idx, DB_UnresetViews );\n    }\n#else\n//# define sqliteViewResetAll(A,B)\n#endif // * SQLITE_OMIT_VIEW */\n\n    /*\n** This function is called by the VDBE to adjust the internal schema\n** used by SQLite when the btree layer moves a table root page. The\n** root-page of a table or index in database iDb has changed from iFrom\n** to iTo.\n**\n** Ticket #1728:  The symbol table might still contain information\n** on tables and/or indices that are the process of being deleted.\n** If you are unlucky, one of those deleted indices or tables might\n** have the same rootpage number as the real table or index that is\n** being moved.  So we cannot stop searching after the first match\n** because the first match might be for one of the deleted indices\n** or tables and not the table/index that is actually being moved.\n** We must continue looping until all tables and indices with\n** rootpage==iFrom have been converted to have a rootpage of iTo\n** in order to be certain that we got the right one.\n*/\n#if !SQLITE_OMIT_AUTOVACUUM\n    static void sqlite3RootPageMoved( Db pDb, int iFrom, int iTo )\n    {\n      HashElem pElem;\n      Hash pHash;\n\n      pHash = pDb.pSchema.tblHash;\n      for ( pElem = pHash.first ; pElem != null ; pElem = pElem.next )// ( pElem = sqliteHashFirst( pHash ) ; pElem ; pElem = sqliteHashNext( pElem ) )\n      {\n        Table pTab = (Table)pElem.data;// sqliteHashData( pElem );\n        if ( pTab.tnum == iFrom )\n        {\n          pTab.tnum = iTo;\n        }\n      }\n      pHash = pDb.pSchema.idxHash;\n      for ( pElem = pHash.first ; pElem != null ; pElem = pElem.next )// ( pElem = sqliteHashFirst( pHash ) ; pElem ; pElem = sqliteHashNext( pElem ) )\n      {\n        Index pIdx = (Index)pElem.data;// sqliteHashData( pElem );\n        if ( pIdx.tnum == iFrom )\n        {\n          pIdx.tnum = iTo;\n        }\n      }\n    }\n#endif\n\n    /*\n** Write code to erase the table with root-page iTable from database iDb.\n** Also write code to modify the sqlite_master table and internal schema\n** if a root-page of another table is moved by the btree-layer whilst\n** erasing iTable (this can happen with an auto-vacuum database).\n*/\n    static void destroyRootPage( Parse pParse, int iTable, int iDb )\n    {\n      Vdbe v = sqlite3GetVdbe( pParse );\n      int r1 = sqlite3GetTempReg( pParse );\n      sqlite3VdbeAddOp3( v, OP_Destroy, iTable, r1, iDb );\n#if !SQLITE_OMIT_AUTOVACUUM\n      /* OP_Destroy stores an in integer r1. If this integer\n** is non-zero, then it is the root page number of a table moved to\n** location iTable. The following code modifies the sqlite_master table to\n** reflect this.\n**\n** The "#NNN" in the SQL is a special constant that means whatever value\n** is in register NNN.  See grammar rules associated with the TK_REGISTER\n** token for additional information.\n*/\n      sqlite3NestedParse( pParse,\n      "UPDATE %Q.%s SET rootpage=%d WHERE #%d AND rootpage=#%d",\n      pParse.db.aDb[iDb].zName, SCHEMA_TABLE( iDb ), iTable, r1, r1 );\n#endif\n      sqlite3ReleaseTempReg( pParse, r1 );\n    }\n\n    /*\n    ** Write VDBE code to erase table pTab and all associated indices on disk.\n    ** Code to update the sqlite_master tables and internal schema definitions\n    ** in case a root-page belonging to another table is moved by the btree layer\n    ** is also added (this can happen with an auto-vacuum database).\n    */\n    static void destroyTable( Parse pParse, Table pTab )\n    {\n#if  SQLITE_OMIT_AUTOVACUUM\nIndex pIdx;\nint iDb = sqlite3SchemaToIndex( pParse.db, pTab.pSchema );\ndestroyRootPage( pParse, pTab.tnum, iDb );\nfor ( pIdx = pTab.pIndex ; pIdx != null ; pIdx = pIdx.pNext )\n{\ndestroyRootPage( pParse, pIdx.tnum, iDb );\n}\n#else\n      /* If the database may be auto-vacuum capable (if SQLITE_OMIT_AUTOVACUUM\n** is not defined), then it is important to call OP_Destroy on the\n** table and index root-pages in order, starting with the numerically\n** largest root-page number. This guarantees that none of the root-pages\n** to be destroyed is relocated by an earlier OP_Destroy. i.e. if the\n** following were coded:\n**\n** OP_Destroy 4 0\n** ...\n** OP_Destroy 5 0\n**\n** and root page 5 happened to be the largest root-page number in the\n** database, then root page 5 would be moved to page 4 by the\n** "OP_Destroy 4 0" opcode. The subsequent "OP_Destroy 5 0" would hit\n** a free-list page.\n*/\n      int iTab = pTab.tnum;\n      int iDestroyed = 0;\n\n      while ( true )\n      {\n        Index pIdx;\n        int iLargest = 0;\n\n        if ( iDestroyed == 0 || iTab < iDestroyed )\n        {\n          iLargest = iTab;\n        }\n        for ( pIdx = pTab.pIndex ; pIdx != null ; pIdx = pIdx.pNext )\n        {\n          int iIdx = pIdx.tnum;\n          Debug.Assert( pIdx.pSchema == pTab.pSchema );\n          if ( ( iDestroyed == 0 || ( iIdx < iDestroyed ) ) && iIdx > iLargest )\n          {\n            iLargest = iIdx;\n          }\n        }\n        if ( iLargest == 0 )\n        {\n          return;\n        }\n        else\n        {\n          int iDb = sqlite3SchemaToIndex( pParse.db, pTab.pSchema );\n          destroyRootPage( pParse, iLargest, iDb );\n          iDestroyed = iLargest;\n        }\n      }\n#endif\n    }\n\n    /*\n    ** This routine is called to do the work of a DROP TABLE statement.\n    ** pName is the name of the table to be dropped.\n    */\n    static void sqlite3DropTable( Parse pParse, SrcList pName, int isView, int noErr )\n    {\n      Table pTab;\n      Vdbe v;\n      sqlite3 db = pParse.db;\n      int iDb;\n\n      //if ( db.mallocFailed != 0 )\n      //{\n      //  goto exit_drop_table;\n      //}\n      Debug.Assert( pParse.nErr == 0 );\n      Debug.Assert( pName.nSrc == 1 );\n      pTab = sqlite3LocateTable( pParse, isView,\n      pName.a[0].zName, pName.a[0].zDatabase );\n\n      if ( pTab == null )\n      {\n        if ( noErr != 0 )\n        {\n          sqlite3ErrorClear( pParse );\n        }\n        goto exit_drop_table;\n      }\n      iDb = sqlite3SchemaToIndex( db, pTab.pSchema );\n      Debug.Assert( iDb >= 0 && iDb < db.nDb );\n\n      /* If pTab is a virtual table, call ViewGetColumnNames() to ensure\n      ** it is initialized.\n      */\n      if ( IsVirtual( pTab ) && sqlite3ViewGetColumnNames( pParse, pTab ) != 0 )\n      {\n        goto exit_drop_table;\n      }\n#if !SQLITE_OMIT_AUTHORIZATION\n{\nint code;\nstring zTab = SCHEMA_TABLE(iDb);\nstring zDb = db.aDb[iDb].zName;\nstring zArg2 = 0;\nif( sqlite3AuthCheck(pParse, SQLITE_DELETE, zTab, 0, zDb)){\ngoto exit_drop_table;\n}\nif( isView ){\nif( OMIT_TEMPDB ==0&& iDb==1 ){\ncode = SQLITE_DROP_TEMP_VIEW;\n}else{\ncode = SQLITE_DROP_VIEW;\n}\n}else if( IsVirtual(pTab) ){\ncode = SQLITE_DROP_VTABLE;\nzArg2 = sqlite3GetVTable(db, pTab)->pMod->zName;\n}else{\nif( OMIT_TEMPDB ==0&& iDb==1 ){\ncode = SQLITE_DROP_TEMP_TABLE;\n}else{\ncode = SQLITE_DROP_TABLE;\n}\n}\nif( sqlite3AuthCheck(pParse, code, pTab.zName, zArg2, zDb) ){\ngoto exit_drop_table;\n}\nif( sqlite3AuthCheck(pParse, SQLITE_DELETE, pTab.zName, 0, zDb) ){\ngoto exit_drop_table;\n}\n}\n#endif\n      if ( sqlite3StrNICmp( pTab.zName, "sqlite_", 7 ) == 0 )\n      {\n        sqlite3ErrorMsg( pParse, "table %s may not be dropped", pTab.zName );\n        goto exit_drop_table;\n      }\n\n#if !SQLITE_OMIT_VIEW\n      /* Ensure DROP TABLE is not used on a view, and DROP VIEW is not used\n** on a table.\n*/\n      if ( isView != 0 && pTab.pSelect == null )\n      {\n        sqlite3ErrorMsg( pParse, "use DROP TABLE to delete table %s", pTab.zName );\n        goto exit_drop_table;\n      }\n      if ( 0 == isView && pTab.pSelect != null )\n      {\n        sqlite3ErrorMsg( pParse, "use DROP VIEW to delete view %s", pTab.zName );\n        goto exit_drop_table;\n      }\n#endif\n\n      /* Generate code to remove the table from the master table\n** on disk.\n*/\n      v = sqlite3GetVdbe( pParse );\n      if ( v != null )\n      {\n        Trigger pTrigger;\n        Db pDb = db.aDb[iDb];\n        sqlite3BeginWriteOperation( pParse, 1, iDb );\n\n        if ( IsVirtual( pTab ) )\n        {\n          sqlite3VdbeAddOp0( v, OP_VBegin );\n        }\n\n        /* Drop all triggers associated with the table being dropped. Code\n        ** is generated to remove entries from sqlite_master and/or\n        ** sqlite_temp_master if required.\n        */\n        pTrigger = sqlite3TriggerList( pParse, pTab );\n        while ( pTrigger != null )\n        {\n          Debug.Assert( pTrigger.pSchema == pTab.pSchema ||\n          pTrigger.pSchema == db.aDb[1].pSchema );\n          sqlite3DropTriggerPtr( pParse, pTrigger );\n          pTrigger = pTrigger.pNext;\n        }\n\n#if !SQLITE_OMIT_AUTOINCREMENT\n        /* Remove any entries of the sqlite_sequence table associated with\n** the table being dropped. This is done before the table is dropped\n** at the btree level, in case the sqlite_sequence table needs to\n** move as a result of the drop (can happen in auto-vacuum mode).\n*/\n        if ( ( pTab.tabFlags & TF_Autoincrement ) != 0 )\n        {\n          sqlite3NestedParse( pParse,\n          "DELETE FROM %s.sqlite_sequence WHERE name=%Q",\n          pDb.zName, pTab.zName\n          );\n        }\n#endif\n\n        /* Drop all SQLITE_MASTER table and index entries that refer to the\n** table. The program name loops through the master table and deletes\n** every row that refers to a table of the same name as the one being\n** dropped. Triggers are handled seperately because a trigger can be\n** created in the temp database that refers to a table in another\n** database.\n*/\n        sqlite3NestedParse( pParse,\n        "DELETE FROM %Q.%s WHERE tbl_name=%Q and type!=\'trigger\'",\n        pDb.zName, SCHEMA_TABLE( iDb ), pTab.zName );\n\n        /* Drop any statistics from the sqlite_stat1 table, if it exists */\n        if ( sqlite3FindTable( db, "sqlite_stat1", db.aDb[iDb].zName ) != null )\n        {\n          sqlite3NestedParse( pParse,\n          "DELETE FROM %Q.sqlite_stat1 WHERE tbl=%Q", pDb.zName, pTab.zName\n          );\n        }\n\n        if ( 0 == isView && !IsVirtual( pTab ) )\n        {\n          destroyTable( pParse, pTab );\n        }\n\n        /* Remove the table entry from SQLite\'s internal schema and modify\n        ** the schema cookie.\n        */\n        if ( IsVirtual( pTab ) )\n        {\n          sqlite3VdbeAddOp4( v, OP_VDestroy, iDb, 0, 0, pTab.zName, 0 );\n        }\n        sqlite3VdbeAddOp4( v, OP_DropTable, iDb, 0, 0, pTab.zName, 0 );\n        sqlite3ChangeCookie( pParse, iDb );\n      }\n      sqliteViewResetAll( db, iDb );\n\nexit_drop_table:\n      sqlite3SrcListDelete( db, ref pName );\n    }\n\n    /*\n    ** This routine is called to create a new foreign key on the table\n    ** currently under construction.  pFromCol determines which columns\n    ** in the current table point to the foreign key.  If pFromCol==0 then\n    ** connect the key to the last column inserted.  pTo is the name of\n    ** the table referred to.  pToCol is a list of tables in the other\n    ** pTo table that the foreign key points to.  flags contains all\n    ** information about the conflict resolution algorithms specified\n    ** in the ON DELETE, ON UPDATE and ON INSERT clauses.\n    **\n    ** An FKey structure is created and added to the table currently\n    ** under construction in the pParse.pNewTable field.\n    **\n    ** The foreign key is set for IMMEDIATE processing.  A subsequent call\n    ** to sqlite3DeferForeignKey() might change this to DEFERRED.\n    */\n    // OVERLOADS, so I don\'t need to rewrite parse.c\n    static void sqlite3CreateForeignKey( Parse pParse, int null_2, Token pTo, ExprList pToCol, int flags )\n    { sqlite3CreateForeignKey( pParse, null, pTo, pToCol, flags ); }\n    static void sqlite3CreateForeignKey(\n    Parse pParse,       /* Parsing context */\n    ExprList pFromCol,  /* Columns in this table that point to other table */\n    Token pTo,          /* Name of the other table */\n    ExprList pToCol,    /* Columns in the other table */\n    int flags           /* Conflict resolution algorithms. */\n    )\n    {\n      sqlite3 db = pParse.db;\n#if !SQLITE_OMIT_FOREIGN_KEY\n      FKey pFKey = null;\n      Table p = pParse.pNewTable;\n      int nByte;\n      int i;\n      int nCol;\n      //string z;\n\n      Debug.Assert( pTo != null );\n      if ( p == null || IN_DECLARE_VTAB ) goto fk_end;\n      if ( pFromCol == null )\n      {\n        int iCol = p.nCol - 1;\n        if ( NEVER( iCol < 0 ) ) goto fk_end;\n        if ( pToCol != null && pToCol.nExpr != 1 )\n        {\n          sqlite3ErrorMsg( pParse, "foreign key on %s" +\n          " should reference only one column of table %T",\n          p.aCol[iCol].zName, pTo );\n          goto fk_end;\n        }\n        nCol = 1;\n      }\n      else if ( pToCol != null && pToCol.nExpr != pFromCol.nExpr )\n      {\n        sqlite3ErrorMsg( pParse,\n        "number of columns in foreign key does not match the number of " +\n        "columns in the referenced table" );\n        goto fk_end;\n      }\n      else\n      {\n        nCol = pFromCol.nExpr;\n      }\n      //nByte = sizeof(*pFKey) + (nCol-1)*sizeof(pFKey.aCol[0]) + pTo.n + 1;\n      //if( pToCol ){\n      //  for(i=0; i<pToCol.nExpr; i++){\n      //    nByte += sqlite3Strlen30(pToCol->a[i].zName) + 1;\n      //  }\n      //}\n      pFKey = new FKey();//sqlite3DbMallocZero(db, nByte );\n      if ( pFKey == null )\n      {\n        goto fk_end;\n      }\n      pFKey.pFrom = p;\n      pFKey.pNextFrom = p.pFKey;\n      //z = pFKey.aCol[nCol].zCol;\n      pFKey.aCol = new FKey.sColMap[nCol];// z;\n      pFKey.aCol[0] = new FKey.sColMap();\n      pFKey.zTo = pTo.z.Substring( 0, pTo.n );      //memcpy( z, pTo.z, pTo.n );\n      //z[pTo.n] = 0;\n      sqlite3Dequote( ref pFKey.zTo );\n      //z += pTo.n + 1;\n      pFKey.nCol = nCol;\n      if ( pFromCol == null )\n      {\n        pFKey.aCol[0].iFrom = p.nCol - 1;\n      }\n      else\n      {\n        for ( i = 0 ; i < nCol ; i++ )\n        {\n          if ( pFKey.aCol[i] == null ) pFKey.aCol[i] = new FKey.sColMap();\n          int j;\n          for ( j = 0 ; j < p.nCol ; j++ )\n          {\n            if ( sqlite3StrICmp( p.aCol[j].zName, pFromCol.a[i].zName ) == 0 )\n            {\n              pFKey.aCol[i].iFrom = j;\n              break;\n            }\n          }\n          if ( j >= p.nCol )\n          {\n            sqlite3ErrorMsg( pParse,\n            "unknown column \\"%s\\" in foreign key definition",\n            pFromCol.a[i].zName );\n            goto fk_end;\n          }\n        }\n      }\n      if ( pToCol != null )\n      {\n        for ( i = 0 ; i < nCol ; i++ )\n        {\n          int n = sqlite3Strlen30( pToCol.a[i].zName );\n          if ( pFKey.aCol[i] == null ) pFKey.aCol[i] = new FKey.sColMap();\n          pFKey.aCol[i].zCol = pToCol.a[i].zName;\n          //memcpy( z, pToCol.a[i].zName, n );\n          //z[n] = 0;\n          //z += n + 1;\n        }\n      }\n      pFKey.isDeferred = 0;\n      pFKey.deleteConf = (u8)( flags & 0xff );\n      pFKey.updateConf = (u8)( ( flags >> 8 ) & 0xff );\n      pFKey.insertConf = (u8)( ( flags >> 16 ) & 0xff );\n\n      /* Link the foreign key to the table as the last step.\n      */\n      p.pFKey = pFKey;\n      pFKey = null;\n\nfk_end:\n      //sqlite3DbFree( db, ref pFKey );\n#endif // * !SQLITE_OMIT_FOREIGN_KEY) */\n      sqlite3ExprListDelete( db, ref pFromCol );\n      sqlite3ExprListDelete( db, ref pToCol );\n    }\n\n    /*\n    ** This routine is called when an INITIALLY IMMEDIATE or INITIALLY DEFERRED\n    ** clause is seen as part of a foreign key definition.  The isDeferred\n    ** parameter is 1 for INITIALLY DEFERRED and 0 for INITIALLY IMMEDIATE.\n    ** The behavior of the most recently created foreign key is adjusted\n    ** accordingly.\n    */\n    static void sqlite3DeferForeignKey( Parse pParse, int isDeferred )\n    {\n#if !SQLITE_OMIT_FOREIGN_KEY\n      Table pTab;\n      FKey pFKey;\n      if ( ( pTab = pParse.pNewTable ) == null || ( pFKey = pTab.pFKey ) == null ) return;\n      Debug.Assert( isDeferred == 0 || isDeferred == 1 );\n      pFKey.isDeferred = (u8)isDeferred;\n#endif\n    }\n\n    /*\n    ** Generate code that will erase and refill index pIdx.  This is\n    ** used to initialize a newly created index or to recompute the\n    ** content of an index in response to a REINDEX command.\n    **\n    ** if memRootPage is not negative, it means that the index is newly\n    ** created.  The register specified by memRootPage contains the\n    ** root page number of the index.  If memRootPage is negative, then\n    ** the index already exists and must be cleared before being refilled and\n    ** the root page number of the index is taken from pIndex.tnum.\n    */\n    static void sqlite3RefillIndex( Parse pParse, Index pIndex, int memRootPage )\n    {\n      Table pTab = pIndex.pTable;   /* The table that is indexed */\n      int iTab = pParse.nTab++;     /* Btree cursor used for pTab */\n      int iIdx = pParse.nTab++;     /* Btree cursor used for pIndex */\n      int addr1;                    /* Address of top of loop */\n      int tnum;                     /* Root page of index */\n      Vdbe v;                       /* Generate code into this virtual machine */\n      KeyInfo pKey;                 /* KeyInfo for index */\n      int regIdxKey;                /* Registers containing the index key */\n      int regRecord;                /* Register holding assemblied index record */\n      sqlite3 db = pParse.db;       /* The database connection */\n      int iDb = sqlite3SchemaToIndex( db, pIndex.pSchema );\n\n#if !SQLITE_OMIT_AUTHORIZATION\nif( sqlite3AuthCheck(pParse, SQLITE_REINDEX, pIndex.zName, 0,\ndb.aDb[iDb].zName ) ){\nreturn;\n}\n#endif\n\n      /* Require a write-lock on the table to perform this operation */\n      sqlite3TableLock( pParse, iDb, pTab.tnum, 1, pTab.zName );\n      v = sqlite3GetVdbe( pParse );\n      if ( v == null ) return;\n      if ( memRootPage >= 0 )\n      {\n        tnum = memRootPage;\n      }\n      else\n      {\n        tnum = pIndex.tnum;\n        sqlite3VdbeAddOp2( v, OP_Clear, tnum, iDb );\n      }\n      pKey = sqlite3IndexKeyinfo( pParse, pIndex );\n      sqlite3VdbeAddOp4( v, OP_OpenWrite, iIdx, tnum, iDb,\n      pKey, P4_KEYINFO_HANDOFF );\n      if ( memRootPage >= 0 )\n      {\n        sqlite3VdbeChangeP5( v, 1 );\n      }\n      sqlite3OpenTable( pParse, iTab, iDb, pTab, OP_OpenRead );\n      addr1 = sqlite3VdbeAddOp2( v, OP_Rewind, iTab, 0 );\n      regRecord = sqlite3GetTempReg( pParse );\n      regIdxKey = sqlite3GenerateIndexKey( pParse, pIndex, iTab, regRecord, true );\n      if ( pIndex.onError != OE_None )\n      {\n        int regRowid = regIdxKey + pIndex.nColumn;\n        int j2 = sqlite3VdbeCurrentAddr( v ) + 2;\n        int pRegKey = regIdxKey;// SQLITE_INT_TO_PTR( regIdxKey );\n\n        /* The registers accessed by the OP_IsUnique opcode were allocated\n        ** using sqlite3GetTempRange() inside of the sqlite3GenerateIndexKey()\n        ** call above. Just before that function was freed they were released\n        ** (made available to the compiler for reuse) using\n        ** sqlite3ReleaseTempRange(). So in some ways having the OP_IsUnique\n        ** opcode use the values stored within seems dangerous. However, since\n        ** we can be sure that no other temp registers have been allocated\n        ** since sqlite3ReleaseTempRange() was called, it is safe to do so.\n        */\n        sqlite3VdbeAddOp4( v, OP_IsUnique, iIdx, j2, regRowid, pRegKey, P4_INT32 );\n        sqlite3VdbeAddOp4( v, OP_Halt, SQLITE_CONSTRAINT, OE_Abort, 0,\n        "indexed columns are not unique", P4_STATIC );\n      }\n      sqlite3VdbeAddOp2( v, OP_IdxInsert, iIdx, regRecord );\n      sqlite3VdbeChangeP5( v, OPFLAG_USESEEKRESULT );\n      sqlite3ReleaseTempReg( pParse, regRecord );\n      sqlite3VdbeAddOp2( v, OP_Next, iTab, addr1 + 1 );\n      sqlite3VdbeJumpHere( v, addr1 );\n      sqlite3VdbeAddOp1( v, OP_Close, iTab );\n      sqlite3VdbeAddOp1( v, OP_Close, iIdx );\n    }\n\n    /*\n    ** Create a new index for an SQL table.  pName1.pName2 is the name of the index\n    ** and pTblList is the name of the table that is to be indexed.  Both will\n    ** be NULL for a primary key or an index that is created to satisfy a\n    ** UNIQUE constraint.  If pTable and pIndex are NULL, use pParse.pNewTable\n    ** as the table to be indexed.  pParse.pNewTable is a table that is\n    ** currently being constructed by a CREATE TABLE statement.\n    **\n    ** pList is a list of columns to be indexed.  pList will be NULL if this\n    ** is a primary key or unique-constraint on the most recent column added\n    ** to the table currently under construction.\n    */\n    // OVERLOADS, so I don\'t need to rewrite parse.c\n    static void sqlite3CreateIndex( Parse pParse, int null_2, int null_3, int null_4, int null_5, int onError, int null_7, int null_8, int sortOrder, int ifNotExist )\n    { sqlite3CreateIndex( pParse, null, null, null, null, onError, null, null, sortOrder, ifNotExist ); }\n    static void sqlite3CreateIndex( Parse pParse, int null_2, int null_3, int null_4, ExprList pList, int onError, int null_7, int null_8, int sortOrder, int ifNotExist )\n    { sqlite3CreateIndex( pParse, null, null, null, pList, onError, null, null, sortOrder, ifNotExist ); }\n    static void sqlite3CreateIndex(\n    Parse pParse,     /* All information about this Parse */\n    Token pName1,     /* First part of index name. May be NULL */\n    Token pName2,     /* Second part of index name. May be NULL */\n    SrcList pTblName, /* Table to index. Use pParse.pNewTable if 0 */\n    ExprList pList,   /* A list of columns to be indexed */\n    int onError,      /* OE_Abort, OE_Ignore, OE_Replace, or OE_None */\n    Token pStart,     /* The CREATE token that begins this statement */\n    Token pEnd,       /* The ")" that closes the CREATE INDEX statement */\n    int sortOrder,    /* Sort order of primary key when pList==NULL */\n    int ifNotExist    /* Omit error if index already exists */\n    )\n    {\n      Table pTab = null;            /* Table to be indexed */\n      Index pIndex = null;          /* The index to be created */\n      string zName = null;          /* Name of the index */\n      int nName;                    /* Number of characters in zName */\n      int i, j;\n      Token nullId = new Token();   /* Fake token for an empty ID list */\n      DbFixer sFix = new DbFixer(); /* For assigning database names to pTable */\n      int sortOrderMask;            /* 1 to honor DESC in index.  0 to ignore. */\n      sqlite3 db = pParse.db;\n      Db pDb;                       /* The specific table containing the indexed database */\n      int iDb;                      /* Index of the database that is being written */\n      Token pName = null;           /* Unqualified name of the index to create */\n      ExprList_item pListItem;      /* For looping over pList */\n      int nCol;\n      int nExtra = 0;\n      StringBuilder zExtra = new StringBuilder();\n\n      Debug.Assert( pStart == null || pEnd != null ); /* pEnd must be non-NULL if pStart is */\n      Debug.Assert( pParse.nErr == 0 );      /* Never called with prior errors */\n      if ( /* db.mallocFailed != 0 || */ IN_DECLARE_VTAB )\n      {\n        goto exit_create_index;\n      }\n      if ( SQLITE_OK != sqlite3ReadSchema( pParse ) )\n      {\n        goto exit_create_index;\n      }\n\n      /*\n      ** Find the table that is to be indexed.  Return early if not found.\n      */\n      if ( pTblName != null )\n      {\n\n        /* Use the two-part index name to determine the database\n        ** to search for the table. \'Fix\' the table name to this db\n        ** before looking up the table.\n        */\n        Debug.Assert( pName1 != null && pName2 != null );\n        iDb = sqlite3TwoPartName( pParse, pName1, pName2, ref  pName );\n        if ( iDb < 0 ) goto exit_create_index;\n\n#if !SQLITE_OMIT_TEMPDB\n        /* If the index name was unqualified, check if the the table\n** is a temp table. If so, set the database to 1. Do not do this\n** if initialising a database schema.\n*/\n        if ( 0 == db.init.busy )\n        {\n          pTab = sqlite3SrcListLookup( pParse, pTblName );\n          if ( pName2.n == 0 && pTab != null && pTab.pSchema == db.aDb[1].pSchema )\n          {\n            iDb = 1;\n          }\n        }\n#endif\n\n        if ( sqlite3FixInit( sFix, pParse, iDb, "index", pName ) != 0 &&\n        sqlite3FixSrcList( sFix, pTblName ) != 0\n        )\n        {\n          /* Because the parser constructs pTblName from a single identifier,\n          ** sqlite3FixSrcList can never fail. */\n          Debugger.Break();\n        }\n        pTab = sqlite3LocateTable( pParse, 0, pTblName.a[0].zName,\n        pTblName.a[0].zDatabase );\n        if ( pTab == null /*|| db.mallocFailed != 0 */ ) goto exit_create_index;\n        Debug.Assert( db.aDb[iDb].pSchema == pTab.pSchema );\n      }\n      else\n      {\n        Debug.Assert( pName == null );\n        pTab = pParse.pNewTable;\n        if ( pTab == null ) goto exit_create_index;\n        iDb = sqlite3SchemaToIndex( db, pTab.pSchema );\n      }\n      pDb = db.aDb[iDb];\n\n      Debug.Assert( pTab != null );\n      Debug.Assert( pParse.nErr == 0 );\n      if ( sqlite3StrNICmp( pTab.zName, "sqlite_", 7 ) == 0\n      && sqlite3StrNICmp( pTab.zName, 7, "altertab_", 9 ) != 0 )\n      {\n        sqlite3ErrorMsg( pParse, "table %s may not be indexed", pTab.zName );\n        goto exit_create_index;\n      }\n#if !SQLITE_OMIT_VIEW\n      if ( pTab.pSelect != null )\n      {\n        sqlite3ErrorMsg( pParse, "views may not be indexed" );\n        goto exit_create_index;\n      }\n#endif\n      if ( IsVirtual( pTab ) )\n      {\n        sqlite3ErrorMsg( pParse, "virtual tables may not be indexed" );\n        goto exit_create_index;\n      }\n\n      /*\n      ** Find the name of the index.  Make sure there is not already another\n      ** index or table with the same name.\n      **\n      ** Exception:  If we are reading the names of permanent indices from the\n      ** sqlite_master table (because some other process changed the schema) and\n      ** one of the index names collides with the name of a temporary table or\n      ** index, then we will continue to process this index.\n      **\n      ** If pName==0 it means that we are\n      ** dealing with a primary key or UNIQUE constraint.  We have to invent our\n      ** own name.\n      */\n      if ( pName != null )\n      {\n        zName = sqlite3NameFromToken( db, pName );\n        if ( zName == null ) goto exit_create_index;\n        if ( SQLITE_OK != sqlite3CheckObjectName( pParse, zName ) )\n        {\n          goto exit_create_index;\n        }\n        if ( 0 == db.init.busy )\n        {\n          if ( sqlite3FindTable( db, zName, null ) != null )\n          {\n            sqlite3ErrorMsg( pParse, "there is already a table named %s", zName );\n            goto exit_create_index;\n          }\n        }\n        if ( sqlite3FindIndex( db, zName, pDb.zName ) != null )\n        {\n          if ( ifNotExist == 0 )\n          {\n            sqlite3ErrorMsg( pParse, "index %s already exists", zName );\n          }\n          goto exit_create_index;\n        }\n      }\n      else\n      {\n        int n = 0;\n        Index pLoop;\n        for ( pLoop = pTab.pIndex, n = 1 ; pLoop != null ; pLoop = pLoop.pNext, n++ ) { }\n        zName = sqlite3MPrintf( db, "sqlite_autoindex_%s_%d", pTab.zName, n );\n        if ( zName == null )\n        {\n          goto exit_create_index;\n        }\n      }\n\n      /* Check for authorization to create an index.\n      */\n#if !SQLITE_OMIT_AUTHORIZATION\n{\nstring zDb = pDb.zName;\nif( sqlite3AuthCheck(pParse, SQLITE_INSERT, SCHEMA_TABLE(iDb), 0, zDb) ){\ngoto exit_create_index;\n}\ni = SQLITE_CREATE_INDEX;\nif( OMIT_TEMPDB ==0&& iDb==1 ) i = SQLITE_CREATE_TEMP_INDEX;\nif( sqlite3AuthCheck(pParse, i, zName, pTab.zName, zDb) ){\ngoto exit_create_index;\n}\n}\n#endif\n\n      /* If pList==0, it means this routine was called to make a primary\n** key out of the last column added to the table under construction.\n** So create a fake list to simulate this.\n*/\n      if ( pList == null )\n      {\n        nullId.z = pTab.aCol[pTab.nCol - 1].zName;\n        nullId.n = sqlite3Strlen30( nullId.z );\n        pList = sqlite3ExprListAppend( pParse, null, null );\n        if ( pList == null ) goto exit_create_index;\n        sqlite3ExprListSetName( pParse, pList, nullId, 0 );\n        pList.a[0].sortOrder = (u8)sortOrder;\n      }\n\n      /* Figure out how many bytes of space are required to store explicitly\n      ** specified collation sequence names.\n      */\n      for ( i = 0 ; i < pList.nExpr ; i++ )\n      {\n        Expr pExpr = pList.a[i].pExpr;\n        if ( pExpr != null )\n        {\n          CollSeq pColl = pExpr.pColl;\n          /* Either pColl!=0 or there was an OOM failure.  But if an OOM\n          ** failure we have quit before reaching this point. */\n          if ( ALWAYS( pColl != null ) )\n          {\n            nExtra += ( 1 + sqlite3Strlen30( pColl.zName ) );\n          }\n        }\n      }\n\n      /*\n      ** Allocate the index structure.\n      */\n      nName = sqlite3Strlen30( zName );\n      nCol = pList.nExpr;\n      pIndex = new Index();\n      // sqlite3DbMallocZero( db,\n      //    Index.Length +              /* Index structure  */\n      //    sizeof( int ) * nCol +           /* Index.aiColumn   */\n      //    sizeof( int ) * ( nCol + 1 ) +       /* Index.aiRowEst   */\n      //    sizeof( char* ) * nCol +        /* Index.azColl     */\n      //    u8.Length * nCol +            /* Index.aSortOrder */\n      //    nName + 1 +                  /* Index.zName      */\n      //    nExtra                       /* Collation sequence names */\n      //);\n      //if ( db.mallocFailed != 0 )\n      //{\n      //  goto exit_create_index;\n      //}\n      pIndex.azColl = new string[nCol];//(char**)(pIndex[1]);\n      pIndex.aiColumn = new int[nCol + 1];//(int *)(pIndex->azColl[nCol]);\n      pIndex.aiRowEst = new int[nCol + 1];//(unsigned *)(pIndex->aiColumn[nCol]);\n      pIndex.aSortOrder = new byte[nCol + 1];//(u8 *)(pIndex->aiRowEst[nCol+1]);\n      //pIndex.zName = null;// (char*)( &pIndex->aSortOrder[nCol] );\n      zExtra = new StringBuilder( nName + 1 );// (char*)( &pIndex.zName[nName + 1] );\n      if ( zName.Length == nName ) pIndex.zName = zName;\n      else { pIndex.zName = zName.Substring( 0, nName ); }// memcpy( pIndex.zName, zName, nName + 1 );\n      pIndex.pTable = pTab;\n      pIndex.nColumn = pList.nExpr;\n      pIndex.onError = (u8)onError;\n      pIndex.autoIndex = (u8)( pName == null ? 1 : 0 );\n      pIndex.pSchema = db.aDb[iDb].pSchema;\n\n      /* Check to see if we should honor DESC requests on index columns\n      */\n      if ( pDb.pSchema.file_format >= 4 )\n      {\n        sortOrderMask = 1;   /* Honor DESC */\n      }\n      else\n      {\n        sortOrderMask = 0;    /* Ignore DESC */\n      }\n\n      /* Scan the names of the columns of the table to be indexed and\n      ** load the column indices into the Index structure.  Report an error\n      ** if any column is not found.\n      **\n      ** TODO:  Add a test to make sure that the same column is not named\n      ** more than once within the same index.  Only the first instance of\n      ** the column will ever be used by the optimizer.  Note that using the\n      ** same column more than once cannot be an error because that would\n      ** break backwards compatibility - it needs to be a warning.\n      */\n      for ( i = 0 ; i < pList.nExpr ; i++ )\n      {//, pListItem++){\n        pListItem = pList.a[i];\n        string zColName = pListItem.zName;\n        Column pTabCol;\n        byte requestedSortOrder;\n        string zColl;                   /* Collation sequence name */\n\n        for ( j = 0 ; j < pTab.nCol ; j++ )\n        {//, pTabCol++){\n          pTabCol = pTab.aCol[j];\n          if ( sqlite3StrICmp( zColName, pTabCol.zName ) == 0 ) break;\n        }\n        if ( j >= pTab.nCol )\n        {\n          sqlite3ErrorMsg( pParse, "table %s has no column named %s",\n          pTab.zName, zColName );\n          goto exit_create_index;\n        }\n        pIndex.aiColumn[i] = j;\n        /* Justification of the ALWAYS(pListItem->pExpr->pColl):  Because of\n        ** the way the "idxlist" non-terminal is constructed by the parser,\n        ** if pListItem->pExpr is not null then either pListItem->pExpr->pColl\n        ** must exist or else there must have been an OOM error.  But if there\n        ** was an OOM error, we would never reach this point. */\n        if ( pListItem.pExpr != null && ALWAYS( pListItem.pExpr.pColl ) )\n        {\n          int nColl;\n          zColl = pListItem.pExpr.pColl.zName;\n          nColl = sqlite3Strlen30( zColl );\n          Debug.Assert( nExtra >= nColl );\n          zExtra = new StringBuilder( zColl.Substring( 0, nColl ) );// memcpy( zExtra, zColl, nColl );\n          zColl = zExtra.ToString();\n          //zExtra += nColl;\n          nExtra -= nColl;\n        }\n        else\n        {\n          zColl = pTab.aCol[j].zColl;\n          if ( zColl == null )\n          {\n            zColl = db.pDfltColl.zName;\n          }\n        }\n        if ( 0 == db.init.busy && sqlite3LocateCollSeq( pParse, zColl ) == null )\n        {\n          goto exit_create_index;\n        }\n        pIndex.azColl[i] = zColl;\n        requestedSortOrder = (u8)( ( pListItem.sortOrder & sortOrderMask ) != 0 ? 1 : 0 );\n        pIndex.aSortOrder[i] = (u8)requestedSortOrder;\n      }\n      sqlite3DefaultRowEst( pIndex );\n\n      if ( pTab == pParse.pNewTable )\n      {\n        /* This routine has been called to create an automatic index as a\n        ** result of a PRIMARY KEY or UNIQUE clause on a column definition, or\n        ** a PRIMARY KEY or UNIQUE clause following the column definitions.\n        ** i.e. one of:\n        **\n        ** CREATE TABLE t(x PRIMARY KEY, y);\n        ** CREATE TABLE t(x, y, UNIQUE(x, y));\n        **\n        ** Either way, check to see if the table already has such an index. If\n        ** so, don\'t bother creating this one. This only applies to\n        ** automatically created indices. Users can do as they wish with\n        ** explicit indices.\n        **\n        ** Two UNIQUE or PRIMARY KEY constraints are considered equivalent\n        ** (and thus suppressing the second one) even if they have different\n        ** sort orders.\n        **\n        ** If there are different collating sequences or if the columns of\n        ** the constraint occur in different orders, then the constraints are\n        ** considered distinct and both result in separate indices.\n        */\n        Index pIdx;\n        for ( pIdx = pTab.pIndex ; pIdx != null ; pIdx = pIdx.pNext )\n        {\n          int k;\n          Debug.Assert( pIdx.onError != OE_None );\n          Debug.Assert( pIdx.autoIndex != 0 );\n          Debug.Assert( pIndex.onError != OE_None );\n\n          if ( pIdx.nColumn != pIndex.nColumn ) continue;\n          for ( k = 0 ; k < pIdx.nColumn ; k++ )\n          {\n            string z1;\n            string z2;\n            if ( pIdx.aiColumn[k] != pIndex.aiColumn[k] ) break;\n            z1 = pIdx.azColl[k];\n            z2 = pIndex.azColl[k];\n            if ( z1 != z2 && sqlite3StrICmp( z1, z2 ) != 0 ) break;\n          }\n          if ( k == pIdx.nColumn )\n          {\n            if ( pIdx.onError != pIndex.onError )\n            {\n              /* This constraint creates the same index as a previous\n              ** constraint specified somewhere in the CREATE TABLE statement.\n              ** However the ON CONFLICT clauses are different. If both this\n              ** constraint and the previous equivalent constraint have explicit\n              ** ON CONFLICT clauses this is an error. Otherwise, use the\n              ** explicitly specified behavior for the index.\n              */\n              if ( !( pIdx.onError == OE_Default || pIndex.onError == OE_Default ) )\n              {\n                sqlite3ErrorMsg( pParse,\n                "conflicting ON CONFLICT clauses specified", 0 );\n              }\n              if ( pIdx.onError == OE_Default )\n              {\n                pIdx.onError = pIndex.onError;\n              }\n            }\n            goto exit_create_index;\n          }\n        }\n      }\n\n      /* Link the new Index structure to its table and to the other\n      ** in-memory database structures.\n      */\n      if ( db.init.busy != 0 )\n      {\n        Index p;\n        p = (Index)sqlite3HashInsert( ref pIndex.pSchema.idxHash,\n        pIndex.zName, sqlite3Strlen30( pIndex.zName ),\n        pIndex );\n        if ( p != null )\n        {\n          Debug.Assert( p == pIndex );  /* Malloc must have failed */\n  //        db.mallocFailed = 1;\n          goto exit_create_index;\n        }\n        db.flags |= SQLITE_InternChanges;\n        if ( pTblName != null )\n        {\n          pIndex.tnum = db.init.newTnum;\n        }\n      }\n\n          /* If the db.init.busy is 0 then create the index on disk.  This\n          ** involves writing the index into the master table and filling in the\n          ** index with the current table contents.\n          **\n          ** The db.init.busy is 0 when the user first enters a CREATE INDEX\n          ** command.  db.init.busy is 1 when a database is opened and\n          ** CREATE INDEX statements are read out of the master table.  In\n          ** the latter case the index already exists on disk, which is why\n          ** we don\'t want to recreate it.\n          **\n          ** If pTblName==0 it means this index is generated as a primary key\n          ** or UNIQUE constraint of a CREATE TABLE statement.  Since the table\n          ** has just been created, it contains no data and the index initialization\n          ** step can be skipped.\n          */\n      else //if ( 0 == db.init.busy )\n      {\n        Vdbe v;\n        string zStmt;\n        int iMem = ++pParse.nMem;\n\n        v = sqlite3GetVdbe( pParse );\n        if ( v == null ) goto exit_create_index;\n\n\n        /* Create the rootpage for the index\n        */\n        sqlite3BeginWriteOperation( pParse, 1, iDb );\n        sqlite3VdbeAddOp2( v, OP_CreateIndex, iDb, iMem );\n\n        /* Gather the complete text of the CREATE INDEX statement into\n        ** the zStmt variable\n        */\n        if ( pStart != null )\n        {\n          Debug.Assert( pEnd != null );\n          /* A named index with an explicit CREATE INDEX statement */\n          zStmt = sqlite3MPrintf( db, "CREATE%s INDEX %.*s",\n          onError == OE_None ? "" : " UNIQUE",\n          pName.z.Length - pEnd.z.Length + 1,\n          pName.z );\n        }\n        else\n        {\n          /* An automatic index created by a PRIMARY KEY or UNIQUE constraint */\n          /* zStmt = sqlite3MPrintf(""); */\n          zStmt = null;\n        }\n\n        /* Add an entry in sqlite_master for this index\n        */\n        sqlite3NestedParse( pParse,\n        "INSERT INTO %Q.%s VALUES(\'index\',%Q,%Q,#%d,%Q);",\n        db.aDb[iDb].zName, SCHEMA_TABLE( iDb ),\n        pIndex.zName,\n        pTab.zName,\n        iMem,\n        zStmt\n        );\n        //sqlite3DbFree( db, ref zStmt );\n\n        /* Fill the index with data and reparse the schema. Code an OP_Expire\n        ** to invalidate all pre-compiled statements.\n        */\n        if ( pTblName != null )\n        {\n          sqlite3RefillIndex( pParse, pIndex, iMem );\n          sqlite3ChangeCookie( pParse, iDb );\n          sqlite3VdbeAddOp4( v, OP_ParseSchema, iDb, 0, 0,\n          sqlite3MPrintf( db, "name=\'%q\'", pIndex.zName ), P4_DYNAMIC );\n          sqlite3VdbeAddOp1( v, OP_Expire, 0 );\n        }\n      }\n\n      /* When adding an index to the list of indices for a table, make\n      ** sure all indices labeled OE_Replace come after all those labeled\n      ** OE_Ignore.  This is necessary for the correct constraint check\n      ** processing (in sqlite3GenerateConstraintChecks()) as part of\n      ** UPDATE and INSERT statements.\n      */\n      if ( db.init.busy != 0 || pTblName == null )\n      {\n        if ( onError != OE_Replace || pTab.pIndex == null\n        || pTab.pIndex.onError == OE_Replace )\n        {\n          pIndex.pNext = pTab.pIndex;\n          pTab.pIndex = pIndex;\n        }\n        else\n        {\n          Index pOther = pTab.pIndex;\n          while ( pOther.pNext != null && pOther.pNext.onError != OE_Replace )\n          {\n            pOther = pOther.pNext;\n          }\n          pIndex.pNext = pOther.pNext;\n          pOther.pNext = pIndex;\n        }\n        pIndex = null;\n      }\n\n        /* Clean up before exiting */\nexit_create_index:\n      if ( pIndex != null )\n      {\n        //sqlite3_free( ref pIndex.zColAff );\n        //sqlite3DbFree( db, ref pIndex );\n      }\n      sqlite3ExprListDelete( db, ref pList );\n      sqlite3SrcListDelete( db, ref pTblName );\n      //sqlite3DbFree( db, ref zName );\n      return;\n    }\n\n    /*\n    ** Fill the Index.aiRowEst[] array with default information - information\n    ** to be used when we have not run the ANALYZE command.\n    **\n    ** aiRowEst[0] is suppose to contain the number of elements in the index.\n    ** Since we do not know, guess 1 million.  aiRowEst[1] is an estimate of the\n    ** number of rows in the table that match any particular value of the\n    ** first column of the index.  aiRowEst[2] is an estimate of the number\n    ** of rows that match any particular combiniation of the first 2 columns\n    ** of the index.  And so forth.  It must always be the case that\n    *\n    **           aiRowEst[N]<=aiRowEst[N-1]\n    **           aiRowEst[N]>=1\n    **\n    ** Apart from that, we have little to go on besides intuition as to\n    ** how aiRowEst[] should be initialized.  The numbers generated here\n    ** are based on typical values found in actual indices.\n    */\n    static void sqlite3DefaultRowEst( Index pIdx )\n    {\n      int[] a = pIdx.aiRowEst;\n      int i;\n      Debug.Assert( a != null );\n      a[0] = 1000000;\n      for ( i = pIdx.nColumn ; i >= 5 ; i-- )\n      {\n        a[i] = 5;\n      }\n      while ( i >= 1 )\n      {\n        a[i] = 11 - i;\n        i--;\n      }\n      if ( pIdx.onError != OE_None )\n      {\n        a[pIdx.nColumn] = 1;\n      }\n    }\n\n    /*\n    ** This routine will drop an existing named index.  This routine\n    ** implements the DROP INDEX statement.\n    */\n    static void sqlite3DropIndex( Parse pParse, SrcList pName, int ifExists )\n    {\n      Index pIndex;\n      Vdbe v;\n      sqlite3 db = pParse.db;\n      int iDb;\n\n      Debug.Assert( pParse.nErr == 0 );   /* Never called with prior errors */\n      //if ( db.mallocFailed != 0 )\n      //{\n      //  goto exit_drop_index;\n      //}\n      Debug.Assert( pName.nSrc == 1 );\n      if ( SQLITE_OK != sqlite3ReadSchema( pParse ) )\n      {\n        goto exit_drop_index;\n      }\n      pIndex = sqlite3FindIndex( db, pName.a[0].zName, pName.a[0].zDatabase );\n      if ( pIndex == null )\n      {\n        if ( ifExists == 0 )\n        {\n          sqlite3ErrorMsg( pParse, "no such index: %S", pName, 0 );\n        }\n        pParse.checkSchema = 1;\n        goto exit_drop_index;\n      }\n      if ( pIndex.autoIndex != 0 )\n      {\n        sqlite3ErrorMsg( pParse, "index associated with UNIQUE " +\n        "or PRIMARY KEY constraint cannot be dropped", 0 );\n        goto exit_drop_index;\n      }\n      iDb = sqlite3SchemaToIndex( db, pIndex.pSchema );\n#if !SQLITE_OMIT_AUTHORIZATION\n{\nint code = SQLITE_DROP_INDEX;\nTable pTab = pIndex.pTable;\nstring zDb = db.aDb[iDb].zName;\nstring zTab = SCHEMA_TABLE(iDb);\nif( sqlite3AuthCheck(pParse, SQLITE_DELETE, zTab, 0, zDb) ){\ngoto exit_drop_index;\n}\nif( OMIT_TEMPDB ==0&& iDb ) code = SQLITE_DROP_TEMP_INDEX;\nif( sqlite3AuthCheck(pParse, code, pIndex.zName, pTab.zName, zDb) ){\ngoto exit_drop_index;\n}\n}\n#endif\n\n      /* Generate code to remove the index and from the master table */\n      v = sqlite3GetVdbe( pParse );\n      if ( v != null )\n      {\n        sqlite3BeginWriteOperation( pParse, 1, iDb );\n        sqlite3NestedParse( pParse,\n        "DELETE FROM %Q.%s WHERE name=%Q",\n        db.aDb[iDb].zName, SCHEMA_TABLE( iDb ),\n        pIndex.zName\n        );\n        if ( sqlite3FindTable( db, "sqlite_stat1", db.aDb[iDb].zName ) != null )\n        {\n          sqlite3NestedParse( pParse,\n          "DELETE FROM %Q.sqlite_stat1 WHERE idx=%Q",\n          db.aDb[iDb].zName, pIndex.zName\n          );\n        }\n        sqlite3ChangeCookie( pParse, iDb );\n        destroyRootPage( pParse, pIndex.tnum, iDb );\n        sqlite3VdbeAddOp4( v, OP_DropIndex, iDb, 0, 0, pIndex.zName, 0 );\n      }\n\nexit_drop_index:\n      sqlite3SrcListDelete( db, ref pName );\n    }\n\n    /*\n    ** pArray is a pointer to an array of objects.  Each object in the\n    ** array is szEntry bytes in size.  This routine allocates a new\n    ** object on the end of the array.\n    **\n    ** pnEntry is the number of entries already in use.  pnAlloc is\n    ** the previously allocated size of the array.  initSize is the\n    ** suggested initial array size allocation.\n    **\n    ** The index of the new entry is returned in pIdx.\n    **\n    ** This routine returns a pointer to the array of objects.  This\n    ** might be the same as the pArray parameter or it might be a different\n    ** pointer if the array was resized.\n    */\n    static T[] sqlite3ArrayAllocate<T>(\n    sqlite3 db,       /* Connection to notify of malloc failures */\n    T[] pArray,    /* Array of objects.  Might be reallocated */\n    int szEntry,      /* Size of each object in the array */\n    int initSize,     /* Suggested initial allocation, in elements */\n    ref int pnEntry,      /* Number of objects currently in use */\n    ref int pnAlloc,      /* Current size of the allocation, in elements */\n    ref int pIdx      /* Write the index of a new slot here */\n    ) where T : new()\n    {\n      //char* z;\n      if ( pnEntry >= pnAlloc )\n      {\n        //void* pNew;\n        int newSize;\n        newSize = ( pnAlloc ) * 2 + initSize;\n        //pNew = sqlite3DbRealloc(db, pArray, newSize * szEntry);\n        //if (pNew == 0)\n        //{\n        //  pIdx = -1;\n        //  return pArray;\n        //}\n        pnAlloc = newSize; //sqlite3DbMallocSize(db, pNew)/szEntry;\n        //pArray = pNew;\n        Array.Resize( ref pArray, newSize );\n      }\n      pArray[pnEntry] = new T();\n      //z = (char*)pArray;\n      //memset(z[*pnEntry * szEntry], 0, szEntry);\n      pIdx = pnEntry;\n      ++pnEntry;\n      return pArray;\n    }\n\n    /*\n    ** Append a new element to the given IdList.  Create a new IdList if\n    ** need be.\n    **\n    ** A new IdList is returned, or NULL if malloc() fails.\n    */\n    // OVERLOADS, so I don\'t need to rewrite parse.c\n    static IdList sqlite3IdListAppend( sqlite3 db, int null_2, Token pToken )\n    { return sqlite3IdListAppend( db, null, pToken ); }\n    static IdList sqlite3IdListAppend( sqlite3 db, IdList pList, Token pToken )\n    {\n      int i = 0;\n      if ( pList == null )\n      {\n        pList = new IdList();//sqlite3DbMallocZero(db, sizeof(IdList));\n        if ( pList == null ) return null;\n        pList.nAlloc = 0;\n      }\n      pList.a = (IdList_item[])sqlite3ArrayAllocate(\n      db,\n      pList.a,\n      -1,//sizeof(pList.a[0]),\n      5,\n      ref pList.nId,\n      ref pList.nAlloc,\n      ref i\n      );\n      if ( i < 0 )\n      {\n        sqlite3IdListDelete( db, ref pList );\n        return null;\n      }\n      pList.a[i].zName = sqlite3NameFromToken( db, pToken );\n      return pList;\n    }\n\n    /*\n    ** Delete an IdList.\n    */\n    static void sqlite3IdListDelete( sqlite3 db, ref IdList pList )\n    {\n      int i;\n      if ( pList == null ) return;\n      for ( i = 0 ; i < pList.nId ; i++ )\n      {\n        //sqlite3DbFree( db, ref pList.a[i].zName );\n      }\n      //sqlite3DbFree( db, ref pList.a );\n      //sqlite3DbFree( db, ref pList );\n    }\n\n    /*\n    ** Return the index in pList of the identifier named zId.  Return -1\n    ** if not found.\n    */\n    static int sqlite3IdListIndex( IdList pList, string zName )\n    {\n      int i;\n      if ( pList == null ) return -1;\n      for ( i = 0 ; i < pList.nId ; i++ )\n      {\n        if ( sqlite3StrICmp( pList.a[i].zName, zName ) == 0 ) return i;\n      }\n      return -1;\n    }\n\n    /*\n    ** Expand the space allocated for the given SrcList object by\n    ** creating nExtra new slots beginning at iStart.  iStart is zero based.\n    ** New slots are zeroed.\n    **\n    ** For example, suppose a SrcList initially contains two entries: A,B.\n    ** To append 3 new entries onto the end, do this:\n    **\n    **    sqlite3SrcListEnlarge(db, pSrclist, 3, 2);\n    **\n    ** After the call above it would contain:  A, B, nil, nil, nil.\n    ** If the iStart argument had been 1 instead of 2, then the result\n    ** would have been:  A, nil, nil, nil, B.  To prepend the new slots,\n    ** the iStart value would be 0.  The result then would\n    ** be: nil, nil, nil, A, B.\n    **\n    ** If a memory allocation fails the SrcList is unchanged.  The\n    ** db.mallocFailed flag will be set to true.\n    */\n    static SrcList sqlite3SrcListEnlarge(\n    sqlite3 db,       /* Database connection to notify of OOM errors */\n    SrcList pSrc,     /* The SrcList to be enlarged */\n    int nExtra,        /* Number of new slots to add to pSrc.a[] */\n    int iStart         /* Index in pSrc.a[] of first new slot */\n    )\n    {\n      int i;\n\n      /* Sanity checking on calling parameters */\n      Debug.Assert( iStart >= 0 );\n      Debug.Assert( nExtra >= 1 );\n      Debug.Assert( pSrc != null );\n      Debug.Assert( iStart <= pSrc.nSrc );\n\n      /* Allocate additional space if needed */\n      if ( pSrc.nSrc + nExtra > pSrc.nAlloc )\n      {\n        int nAlloc = pSrc.nSrc + nExtra;\n        int nGot;\n        // sqlite3DbRealloc(db, pSrc,\n        //     sizeof(*pSrc) + (nAlloc-1)*sizeof(pSrc.a[0]) );\n        pSrc.nAlloc = (i16)nAlloc;\n        Array.Resize( ref pSrc.a, nAlloc );\n        //    nGot = (sqlite3DbMallocSize(db, pNew) - sizeof(*pSrc))/sizeof(pSrc->a[0])+1;\n        //pSrc->nAlloc = (u16)nGot;\n      }\n\n      /* Move existing slots that come after the newly inserted slots\n      ** out of the way */\n      for ( i = pSrc.nSrc - 1 ; i >= iStart ; i-- )\n      {\n        pSrc.a[i + nExtra] = pSrc.a[i];\n      }\n      pSrc.nSrc += (i16)nExtra;\n\n      /* Zero the newly allocated slots */\n      //memset(&pSrc.a[iStart], 0, sizeof(pSrc.a[0])*nExtra);\n      for ( i = iStart ; i < iStart + nExtra ; i++ )\n      {\n        pSrc.a[i] = new SrcList_item();\n        pSrc.a[i].iCursor = -1;\n      }\n\n      /* Return a pointer to the enlarged SrcList */\n      return pSrc;\n    }\n\n\n    /*\n    ** Append a new table name to the given SrcList.  Create a new SrcList if\n    ** need be.  A new entry is created in the SrcList even if pTable is NULL.\n    **\n    ** A SrcList is returned, or NULL if there is an OOM error.  The returned\n    ** SrcList might be the same as the SrcList that was input or it might be\n    ** a new one.  If an OOM error does occurs, then the prior value of pList\n    ** that is input to this routine is automatically freed.\n    **\n    ** If pDatabase is not null, it means that the table has an optional\n    ** database name prefix.  Like this:  "database.table".  The pDatabase\n    ** points to the table name and the pTable points to the database name.\n    ** The SrcList.a[].zName field is filled with the table name which might\n    ** come from pTable (if pDatabase is NULL) or from pDatabase.\n    ** SrcList.a[].zDatabase is filled with the database name from pTable,\n    ** or with NULL if no database is specified.\n    **\n    ** In other words, if call like this:\n    **\n    **         sqlite3SrcListAppend(D,A,B,0);\n    **\n    ** Then B is a table name and the database name is unspecified.  If called\n    ** like this:\n    **\n    **         sqlite3SrcListAppend(D,A,B,C);\n    **\n    ** Then C is the table name and B is the database name.  If C is defined\n    ** then so is B.  In other words, we never have a case where:\n    **\n    **         sqlite3SrcListAppend(D,A,0,C);\n    **\n    ** Both pTable and pDatabase are assumed to be quoted.  They are dequoted\n    ** before being added to the SrcList.\n    */\n    // OVERLOADS, so I don\'t need to rewrite parse.c\n    static SrcList sqlite3SrcListAppend( sqlite3 db, int null_2, Token pTable, int null_4 )\n    {\n      return sqlite3SrcListAppend( db, null, pTable, null );\n    }\n    static SrcList sqlite3SrcListAppend( sqlite3 db, int null_2, Token pTable, Token pDatabase )\n    {\n      return sqlite3SrcListAppend( db, null, pTable, pDatabase );\n    }\n    static SrcList sqlite3SrcListAppend(\n    sqlite3 db,        /* Connection to notify of malloc failures */\n    SrcList pList,     /* Append to this SrcList. NULL creates a new SrcList */\n    Token pTable,      /* Table to append */\n    Token pDatabase    /* Database of the table */\n    )\n    {\n      SrcList_item pItem;\n      Debug.Assert( pDatabase == null || pTable != null );  /* Cannot have C without B */\n      if ( pList == null )\n      {\n        pList = new SrcList();//sqlite3DbMallocZero(db, SrcList.Length );\n        //if ( pList == null ) return null;\n        pList.nAlloc = 1;\n        pList.a = new SrcList_item[1];\n      }\n      pList = sqlite3SrcListEnlarge( db, pList, 1, pList.nSrc );\n      //if ( db.mallocFailed != 0 )\n      //{\n      //  sqlite3SrcListDelete( db, ref pList );\n      //  return null;\n      //}\n      pItem = pList.a[pList.nSrc - 1];\n      if ( pDatabase != null && String.IsNullOrEmpty(pDatabase.z))\n      {\n        pDatabase = null;\n      }\n      if ( pDatabase != null )\n      {\n        Token pTemp = pDatabase;\n        pDatabase = pTable;\n        pTable = pTemp;\n      }\n      pItem.zName = sqlite3NameFromToken( db, pTable );\n      pItem.zDatabase = sqlite3NameFromToken( db, pDatabase );\n      return pList;\n    }\n\n    /*\n    ** Assign VdbeCursor index numbers to all tables in a SrcList\n    */\n    static void sqlite3SrcListAssignCursors( Parse pParse, SrcList pList )\n    {\n      int i;\n      SrcList_item pItem;\n      Debug.Assert( pList != null /* || pParse.db.mallocFailed != 0 */ );\n      if ( pList != null )\n      {\n        for ( i = 0 ; i < pList.nSrc ; i++ )\n        {\n          pItem = pList.a[i];\n          if ( pItem.iCursor >= 0 ) break;\n          pItem.iCursor = pParse.nTab++;\n          if ( pItem.pSelect != null )\n          {\n            sqlite3SrcListAssignCursors( pParse, pItem.pSelect.pSrc );\n          }\n        }\n      }\n    }\n\n    /*\n    ** Delete an entire SrcList including all its substructure.\n    */\n    static void sqlite3SrcListDelete( sqlite3 db, ref SrcList pList )\n    {\n      int i;\n      SrcList_item pItem;\n      if ( pList == null ) return;\n      for ( i = 0 ; i < pList.nSrc ; i++ )\n      {//, pItem++){\n        pItem = pList.a[i];\n        //sqlite3DbFree( db, ref pItem.zDatabase );\n        //sqlite3DbFree( db, ref pItem.zName );\n        //sqlite3DbFree( db, ref pItem.zAlias );\n        //sqlite3DbFree( db, ref pItem.zIndex );\n        sqlite3DeleteTable( ref pItem.pTab );\n        sqlite3SelectDelete( db, ref pItem.pSelect );\n        sqlite3ExprDelete( db, ref pItem.pOn );\n        sqlite3IdListDelete( db, ref pItem.pUsing );\n      }\n      //sqlite3DbFree( db, ref pList );\n    }\n\n    /*\n    ** This routine is called by the parser to add a new term to the\n    ** end of a growing FROM clause.  The "p" parameter is the part of\n    ** the FROM clause that has already been constructed.  "p" is NULL\n    ** if this is the first term of the FROM clause.  pTable and pDatabase\n    ** are the name of the table and database named in the FROM clause term.\n    ** pDatabase is NULL if the database name qualifier is missing - the\n    ** usual case.  If the term has a alias, then pAlias points to the\n    ** alias token.  If the term is a subquery, then pSubquery is the\n    ** SELECT statement that the subquery encodes.  The pTable and\n    ** pDatabase parameters are NULL for subqueries.  The pOn and pUsing\n    ** parameters are the content of the ON and USING clauses.\n    **\n    ** Return a new SrcList which encodes is the FROM with the new\n    ** term added.\n    */\n    // OVERLOADS, so I don\'t need to rewrite parse.c\n    static SrcList sqlite3SrcListAppendFromTerm( Parse pParse, SrcList p, int null_3, int null_4, Token pAlias, Select pSubquery, Expr pOn, IdList pUsing )\n    {\n      return sqlite3SrcListAppendFromTerm( pParse, p, null, null, pAlias, pSubquery, pOn, pUsing );\n    }\n    static SrcList sqlite3SrcListAppendFromTerm( Parse pParse, SrcList p, Token pTable, Token pDatabase, Token pAlias, int null_6, Expr pOn, IdList pUsing )\n    {\n      return sqlite3SrcListAppendFromTerm( pParse, p, pTable, pDatabase, pAlias, null, pOn, pUsing );\n    }\n    static SrcList sqlite3SrcListAppendFromTerm(\n    Parse pParse,          /* Parsing context */\n    SrcList p,             /* The left part of the FROM clause already seen */\n    Token pTable,          /* Name of the table to add to the FROM clause */\n    Token pDatabase,       /* Name of the database containing pTable */\n    Token pAlias,          /* The right-hand side of the AS subexpression */\n    Select pSubquery,      /* A subquery used in place of a table name */\n    Expr pOn,              /* The ON clause of a join */\n    IdList pUsing          /* The USING clause of a join */\n    )\n    {\n      SrcList_item pItem;\n      sqlite3 db = pParse.db;\n      if ( null == p && ( pOn != null || pUsing != null ) )\n      {\n        sqlite3ErrorMsg( pParse, "a JOIN clause is required before %s",\n          ( pOn != null ? "ON" : "USING" )\n        );\n        goto append_from_error;\n      }\n      p = sqlite3SrcListAppend( db, p, pTable, pDatabase );\n      //if ( p == null || NEVER( p.nSrc == 0 ) )\n      //{\n      //  goto append_from_error;\n      //}\n      pItem = p.a[p.nSrc - 1];\n      Debug.Assert( pAlias != null );\n      if ( pAlias.n != 0 )\n      {\n        pItem.zAlias = sqlite3NameFromToken( db, pAlias );\n      }\n      pItem.pSelect = pSubquery;\n      pItem.pOn = pOn;\n      pItem.pUsing = pUsing;\n      return p;\nappend_from_error:\n      Debug.Assert( p == null );\n      sqlite3ExprDelete( db, ref pOn );\n      sqlite3IdListDelete( db, ref pUsing );\n      sqlite3SelectDelete( db, ref pSubquery );\n      return null;\n    }\n\n    /*\n    ** Add an INDEXED BY or NOT INDEXED clause to the most recently added\n    ** element of the source-list passed as the second argument.\n    */\n    static void sqlite3SrcListIndexedBy( Parse pParse, SrcList p, Token pIndexedBy )\n    {\n      Debug.Assert( pIndexedBy != null );\n      if ( p != null && ALWAYS( p.nSrc > 0 ) )\n      {\n        SrcList_item pItem = p.a[p.nSrc - 1];\n        Debug.Assert( 0 == pItem.notIndexed && pItem.zIndex == null );\n        if ( pIndexedBy.n == 1 && null == pIndexedBy.z )\n        {\n          /* A "NOT INDEXED" clause was supplied. See parse.y\n          ** construct "indexed_opt" for details. */\n          pItem.notIndexed = 1;\n        }\n        else\n        {\n          pItem.zIndex = sqlite3NameFromToken( pParse.db, pIndexedBy );\n        }\n      }\n    }\n\n    /*\n    ** When building up a FROM clause in the parser, the join operator\n    ** is initially attached to the left operand.  But the code generator\n    ** expects the join operator to be on the right operand.  This routine\n    ** Shifts all join operators from left to right for an entire FROM\n    ** clause.\n    **\n    ** Example: Suppose the join is like this:\n    **\n    **           A natural cross join B\n    **\n    ** The operator is "natural cross join".  The A and B operands are stored\n    ** in p.a[0] and p.a[1], respectively.  The parser initially stores the\n    ** operator with A.  This routine shifts that operator over to B.\n    */\n    static void sqlite3SrcListShiftJoinType( SrcList p )\n    {\n      if ( p != null && p.a != null )\n      {\n        int i;\n        for ( i = p.nSrc - 1 ; i > 0 ; i-- )\n        {\n          p.a[i].jointype = p.a[i - 1].jointype;\n        }\n        p.a[0].jointype = 0;\n      }\n    }\n\n    /*\n    ** Begin a transaction\n    */\n    static void sqlite3BeginTransaction( Parse pParse, int type )\n    {\n      sqlite3 db;\n      Vdbe v;\n      int i;\n\n      Debug.Assert( pParse != null );\n      db = pParse.db;\n      Debug.Assert( db != null );\n      /*  if( db.aDb[0].pBt==0 ) return; */\n      if ( sqlite3AuthCheck( pParse, SQLITE_TRANSACTION, "BEGIN", null, null ) != 0 )\n      {\n        return;\n      }\n      v = sqlite3GetVdbe( pParse );\n      if ( v == null ) return;\n      if ( type != TK_DEFERRED )\n      {\n        for ( i = 0 ; i < db.nDb ; i++ )\n        {\n          sqlite3VdbeAddOp2( v, OP_Transaction, i, ( type == TK_EXCLUSIVE ) ? 2 : 1 );\n          sqlite3VdbeUsesBtree( v, i );\n        }\n      }\n      sqlite3VdbeAddOp2( v, OP_AutoCommit, 0, 0 );\n    }\n\n    /*\n    ** Commit a transaction\n    */\n    static void sqlite3CommitTransaction( Parse pParse )\n    {\n      sqlite3 db;\n      Vdbe v;\n\n      Debug.Assert( pParse != null );\n      db = pParse.db;\n      Debug.Assert( db != null );\n      /*  if( db.aDb[0].pBt==0 ) return; */\n      if ( sqlite3AuthCheck( pParse, SQLITE_TRANSACTION, "COMMIT", null, null ) != 0 )\n      {\n        return;\n      }\n      v = sqlite3GetVdbe( pParse );\n      if ( v != null )\n      {\n        sqlite3VdbeAddOp2( v, OP_AutoCommit, 1, 0 );\n      }\n    }\n\n    /*\n    ** Rollback a transaction\n    */\n    static void sqlite3RollbackTransaction( Parse pParse )\n    {\n      sqlite3 db;\n      Vdbe v;\n\n      Debug.Assert( pParse != null );\n      db = pParse.db;\n      Debug.Assert( db != null );\n      /*  if( db.aDb[0].pBt==0 ) return; */\n      if ( sqlite3AuthCheck( pParse, SQLITE_TRANSACTION, "ROLLBACK", null, null ) != 0 )\n      {\n        return;\n      }\n      v = sqlite3GetVdbe( pParse );\n      if ( v != null )\n      {\n        sqlite3VdbeAddOp2( v, OP_AutoCommit, 1, 1 );\n      }\n    }\n\n    /*\n    ** This function is called by the parser when it parses a command to create,\n    ** release or rollback an SQL savepoint.\n    */\n    static void sqlite3Savepoint( Parse pParse, int op, Token pName )\n    {\n      string zName = sqlite3NameFromToken( pParse.db, pName );\n      if ( zName != null )\n      {\n        Vdbe v = sqlite3GetVdbe( pParse );\n#if !SQLITE_OMIT_AUTHORIZATION\nbyte az[] = { "BEGIN", "RELEASE", "ROLLBACK" };\nDebug.Assert( !SAVEPOINT_BEGIN && SAVEPOINT_RELEASE==1 && SAVEPOINT_ROLLBACK==2 );\n#endif\n        if ( null == v\n#if !SQLITE_OMIT_AUTHORIZATION\n|| sqlite3AuthCheck(pParse, SQLITE_SAVEPOINT, az[op], zName, 0)\n#endif\n )\n        {\n          //sqlite3DbFree( pParse.db, zName );\n          return;\n        }\n        sqlite3VdbeAddOp4( v, OP_Savepoint, op, 0, 0, zName, P4_DYNAMIC );\n      }\n    }\n\n    /*\n    ** Make sure the TEMP database is open and available for use.  Return\n    ** the number of errors.  Leave any error messages in the pParse structure.\n    */\n    static int sqlite3OpenTempDatabase( Parse pParse )\n    {\n      sqlite3 db = pParse.db;\n      if ( db.aDb[1].pBt == null && pParse.explain == 0 )\n      {\n        int rc;\n        const int flags =\n        SQLITE_OPEN_READWRITE |\n        SQLITE_OPEN_CREATE |\n        SQLITE_OPEN_EXCLUSIVE |\n        SQLITE_OPEN_DELETEONCLOSE |\n        SQLITE_OPEN_TEMP_DB;\n\n        rc = sqlite3BtreeFactory( db, null, false, SQLITE_DEFAULT_CACHE_SIZE, flags,\n        ref db.aDb[1].pBt );\n        if ( rc != SQLITE_OK )\n        {\n          sqlite3ErrorMsg( pParse, "unable to open a temporary database " +\n          "file for storing temporary tables" );\n          pParse.rc = rc;\n          return 1;\n        }\n        Debug.Assert( ( db.flags & SQLITE_InTrans ) == 0 || db.autoCommit != 0 );\n        Debug.Assert( db.aDb[1].pSchema != null );\n        sqlite3PagerJournalMode( sqlite3BtreePager( db.aDb[1].pBt ),\n        db.dfltJournalMode );\n      }\n      return 0;\n    }\n\n    /*\n    ** Generate VDBE code that will verify the schema cookie and start\n    ** a read-transaction for all named database files.\n    **\n    ** It is important that all schema cookies be verified and all\n    ** read transactions be started before anything else happens in\n    ** the VDBE program.  But this routine can be called after much other\n    ** code has been generated.  So here is what we do:\n    **\n    ** The first time this routine is called, we code an OP_Goto that\n    ** will jump to a subroutine at the end of the program.  Then we\n    ** record every database that needs its schema verified in the\n    ** pParse.cookieMask field.  Later, after all other code has been\n    ** generated, the subroutine that does the cookie verifications and\n    ** starts the transactions will be coded and the OP_Goto P2 value\n    ** will be made to point to that subroutine.  The generation of the\n    ** cookie verification subroutine code happens in sqlite3FinishCoding().\n    **\n    ** If iDb<0 then code the OP_Goto only - don\'t set flag to verify the\n    ** schema on any databases.  This can be used to position the OP_Goto\n    ** early in the code, before we know if any database tables will be used.\n    */\n    static void sqlite3CodeVerifySchema( Parse pParse, int iDb )\n    {\n      sqlite3 db;\n      Vdbe v;\n      u32 mask;\n\n      v = sqlite3GetVdbe( pParse );\n      if ( v == null ) return;  /* This only happens if there was a prior error */\n      db = pParse.db;\n      if ( pParse.cookieGoto == 0 )\n      {\n        pParse.cookieGoto = sqlite3VdbeAddOp2( v, OP_Goto, 0, 0 ) + 1;\n      }\n      if ( iDb >= 0 )\n      {\n        Debug.Assert( iDb < db.nDb );\n        Debug.Assert( db.aDb[iDb].pBt != null || iDb == 1 );\n        Debug.Assert( iDb < SQLITE_MAX_ATTACHED + 2 );\n        mask = (u32)( 1 << iDb );\n        if ( ( pParse.cookieMask & mask ) == 0 )\n        {\n          pParse.cookieMask |= mask;\n          pParse.cookieValue[iDb] = db.aDb[iDb].pSchema.schema_cookie;\n          if ( OMIT_TEMPDB == 0 && iDb == 1 )\n          {\n            sqlite3OpenTempDatabase( pParse );\n          }\n        }\n      }\n    }\n\n    /*\n    ** Generate VDBE code that prepares for doing an operation that\n    ** might change the database.\n    **\n    ** This routine starts a new transaction if we are not already within\n    ** a transaction.  If we are already within a transaction, then a checkpoint\n    ** is set if the setStatement parameter is true.  A checkpoint should\n    ** be set for operations that might fail (due to a constraint) part of\n    ** the way through and which will need to undo some writes without having to\n    ** rollback the whole transaction.  For operations where all constraints\n    ** can be checked before any changes are made to the database, it is never\n    ** necessary to undo a write and the checkpoint should not be set.\n    */\n    static void sqlite3BeginWriteOperation( Parse pParse, int setStatement, int iDb )\n    {\n      sqlite3CodeVerifySchema( pParse, iDb );\n      pParse.writeMask |= (u32)( 1 << iDb );\n      if ( setStatement != 0 && pParse.nested == 0 )\n      {\n        /* Every place where this routine is called with setStatement!=0 has\n        ** already successfully created a VDBE. */\n        Debug.Assert( pParse.pVdbe != null );\n        sqlite3VdbeAddOp1( pParse.pVdbe, OP_Statement, iDb );\n      }\n    }\n\n    /*\n    ** Check to see if pIndex uses the collating sequence pColl.  Return\n    ** true if it does and false if it does not.\n    */\n#if !SQLITE_OMIT_REINDEX\n    static bool collationMatch( string zColl, Index pIndex )\n    {\n      int i;\n      Debug.Assert( zColl != null );\n      for ( i = 0 ; i < pIndex.nColumn ; i++ )\n      {\n        string z = pIndex.azColl[i];\n        Debug.Assert( z != null );\n        if ( 0 == sqlite3StrICmp( z, zColl ) )\n        {\n          return true;\n        }\n      }\n      return false;\n    }\n#endif\n\n    /*\n** Recompute all indices of pTab that use the collating sequence pColl.\n** If pColl == null then recompute all indices of pTab.\n*/\n#if !SQLITE_OMIT_REINDEX\n    static void reindexTable( Parse pParse, Table pTab, string zColl )\n    {\n      Index pIndex;              /* An index associated with pTab */\n\n      for ( pIndex = pTab.pIndex ; pIndex != null ; pIndex = pIndex.pNext )\n      {\n        if ( zColl == null || collationMatch( zColl, pIndex ) )\n        {\n          int iDb = sqlite3SchemaToIndex( pParse.db, pTab.pSchema );\n          sqlite3BeginWriteOperation( pParse, 0, iDb );\n          sqlite3RefillIndex( pParse, pIndex, -1 );\n        }\n      }\n    }\n#endif\n\n    /*\n** Recompute all indices of all tables in all databases where the\n** indices use the collating sequence pColl.  If pColl == null then recompute\n** all indices everywhere.\n*/\n#if !SQLITE_OMIT_REINDEX\n    static void reindexDatabases( Parse pParse, string zColl )\n    {\n      Db pDb;                    /* A single database */\n      int iDb;                   /* The database index number */\n      sqlite3 db = pParse.db;    /* The database connection */\n      HashElem k;                /* For looping over tables in pDb */\n      Table pTab;                /* A table in the database */\n\n      for ( iDb = 0 ; iDb < db.nDb ; iDb++ )//, pDb++ )\n      {\n        pDb = db.aDb[iDb];\n        Debug.Assert( pDb != null );\n        for ( k = pDb.pSchema.tblHash.first ; k != null ; k = k.next ) //for ( k = sqliteHashFirst( pDb.pSchema.tblHash ) ; k != null ; k = sqliteHashNext( k ) )\n        {\n          pTab = (Table)k.data;// sqliteHashData( k );\n          reindexTable( pParse, pTab, zColl );\n        }\n      }\n    }\n#endif\n\n    /*\n** Generate code for the REINDEX command.\n**\n**        REINDEX                            -- 1\n**        REINDEX  <collation>               -- 2\n**        REINDEX  ?<database>.?<tablename>  -- 3\n**        REINDEX  ?<database>.?<indexname>  -- 4\n**\n** Form 1 causes all indices in all attached databases to be rebuilt.\n** Form 2 rebuilds all indices in all databases that use the named\n** collating function.  Forms 3 and 4 rebuild the named index or all\n** indices associated with the named table.\n*/\n#if !SQLITE_OMIT_REINDEX\n    // OVERLOADS, so I don\'t need to rewrite parse.c\n    static void sqlite3Reindex( Parse pParse, int null_2, int null_3 )\n    { sqlite3Reindex( pParse, null, null ); }\n    static void sqlite3Reindex( Parse pParse, Token pName1, Token pName2 )\n    {\n      CollSeq pColl;                /* Collating sequence to be reindexed, or NULL */\n      string z;                     /* Name of a table or index */\n      string zDb;                   /* Name of the database */\n      Table pTab;                   /* A table in the database */\n      Index pIndex;                 /* An index associated with pTab */\n      int iDb;                      /* The database index number */\n      sqlite3 db = pParse.db;       /* The database connection */\n      Token pObjName = new Token();  /* Name of the table or index to be reindexed */\n\n      /* Read the database schema. If an error occurs, leave an error message\n      ** and code in pParse and return NULL. */\n      if ( SQLITE_OK != sqlite3ReadSchema( pParse ) )\n      {\n        return;\n      }\n\n      if ( pName1 == null )\n      {\n        reindexDatabases( pParse, null );\n        return;\n      }\n      else if ( NEVER( pName2 == null ) || pName2.z == null || pName2.z.Length == 0 )\n      {\n        string zColl;\n        Debug.Assert( pName1.z != null );\n        zColl = sqlite3NameFromToken( pParse.db, pName1 );\n        if ( zColl == null ) return;\n        pColl = sqlite3FindCollSeq( db, ENC( db ), zColl, 0 );\n        if ( pColl != null )\n        {\n          reindexDatabases( pParse, zColl );\n          //sqlite3DbFree( db, ref zColl );\n          return;\n        }\n        //sqlite3DbFree( db, ref zColl );\n      }\n      iDb = sqlite3TwoPartName( pParse, pName1, pName2, ref pObjName );\n      if ( iDb < 0 ) return;\n      z = sqlite3NameFromToken( db, pObjName );\n      if ( z == null ) return;\n      zDb = db.aDb[iDb].zName;\n      pTab = sqlite3FindTable( db, z, zDb );\n      if ( pTab != null )\n      {\n        reindexTable( pParse, pTab, null );\n        //sqlite3DbFree( db, ref z );\n        return;\n      }\n      pIndex = sqlite3FindIndex( db, z, zDb );\n      //sqlite3DbFree( db, ref z );\n      if ( pIndex != null )\n      {\n        sqlite3BeginWriteOperation( pParse, 0, iDb );\n        sqlite3RefillIndex( pParse, pIndex, -1 );\n        return;\n      }\n      sqlite3ErrorMsg( pParse, "unable to identify the object to be reindexed" );\n    }\n#endif\n\n    /*\n** Return a dynamicly allocated KeyInfo structure that can be used\n** with OP_OpenRead or OP_OpenWrite to access database index pIdx.\n**\n** If successful, a pointer to the new structure is returned. In this case\n** the caller is responsible for calling //sqlite3DbFree(db, ) on the returned\n** pointer. If an error occurs (out of memory or missing collation\n** sequence), NULL is returned and the state of pParse updated to reflect\n** the error.\n*/\n    static KeyInfo sqlite3IndexKeyinfo( Parse pParse, Index pIdx )\n    {\n      int i;\n      int nCol = pIdx.nColumn;\n      //int nBytes = KeyInfo.Length + (nCol - 1) * CollSeq*.Length + nCol;\n      sqlite3 db = pParse.db;\n      KeyInfo pKey = new KeyInfo();// (KeyInfo*)sqlite3DbMallocZero(db, nBytes);\n\n      if ( pKey != null )\n      {\n        pKey.db = pParse.db;\n        pKey.aSortOrder = new byte[nCol];\n        pKey.aColl = new CollSeq[nCol];// (u8*)&(pKey.aColl[nCol]);\n        //        Debug.Assert(pKey.aSortOrder[nCol] == &(((u8*)pKey)[nBytes]));\n        for ( i = 0 ; i < nCol ; i++ )\n        {\n          string zColl = pIdx.azColl[i];\n          Debug.Assert( zColl != null );\n          pKey.aColl[i] = sqlite3LocateCollSeq( pParse, zColl );\n          pKey.aSortOrder[i] = pIdx.aSortOrder[i];\n        }\n        pKey.nField = (u16)nCol;\n      }\n\n      if ( pParse.nErr != 0 )\n      {\n        pKey = null;//sqlite3DbFree( db, ref pKey );\n      }\n      return pKey;\n    }\n  }\n}\n'