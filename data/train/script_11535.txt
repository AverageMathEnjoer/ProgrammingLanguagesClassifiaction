b'#\' Extract results from a DESeq analysis\n#\'\n#\' \\code{results} extracts a result table from a DESeq analysis giving base means across samples,\n#\' log2 fold changes, standard errors, test statistics, p-values and adjusted p-values;\n#\' \\code{resultsNames} returns the names of the estimated effects (coefficents) of the model;\n#\' \\code{removeResults} returns a \\code{DESeqDataSet} object with results columns removed.\n#\'\n#\' The results table when printed will provide the information about\n#\' the comparison, e.g. "log2 fold change (MAP): condition treated vs untreated", meaning\n#\' that the estimates are of log2(treated / untreated), as would be returned by\n#\' \\code{contrast=c("condition","treated","untreated")}.\n#\' Multiple results can be returned for analyses beyond a simple two group comparison,\n#\' so \\code{results} takes arguments \\code{contrast} and \\code{name} to help\n#\' the user pick out the comparisons of interest for printing a results table.\n#\' The use of the \\code{contrast} argument is recommended for exact specification\n#\' of the levels which should be compared and their order.\n#\' \n#\' If \\code{results} is run without specifying \\code{contrast} or \\code{name},\n#\' it will return the comparison of the last level of the last variable in the\n#\' design formula over the first level of this variable. For example, for a simple two-group\n#\' comparison, this would return the log2 fold changes of the second group over the\n#\' first group (the reference level). Please see examples below and in the vignette. \n#\'\n#\' The argument \\code{contrast} can be used to generate results tables for\n#\' any comparison of interest, for example, the log2 fold change between\n#\' two levels of a factor, and its usage is described below. It can also\n#\' accomodate more complicated numeric comparisons.\n#\' Note that \\code{contrast} will set to 0 the estimated LFC in a\n#\' comparison of two groups, where all of the counts in the two groups\n#\' are equal to 0 (while other groups have positive counts), while\n#\' \\code{name} will not automatically set these LFC to 0.\n#\' The test statistic used for a contrast is:\n#\'\n#\' \\deqn{ c^t \\beta / \\sqrt{c^t \\Sigma c } }{ c\' beta / sqrt( c\' Sigma c ) }\n#\'\n#\' The argument \\code{name} can be used to generate results tables for\n#\' individual effects, which must be individual elements of \\code{resultsNames(object)}.\n#\' These individual effects could represent continuous covariates, effects\n#\' for individual levels, or individual interaction effects.\n#\' \n#\' Information on the comparison which was used to build the results table,\n#\' and the statistical test which was used for p-values (Wald test or likelihood ratio test)\n#\' is stored within the object returned by \\code{results}. This information is in\n#\' the metadata columns of the results table, which is accessible by calling \\code{mcols}\n#\' on the \\code{\\link{DESeqResults}} object returned by \\code{results}.\n#\'\n#\' On p-values:\n#\' \n#\' By default, independent filtering is performed to select a set of genes\n#\' for multiple test correction which maximizes the number of adjusted\n#\' p-values less than a given critical value \\code{alpha} (by default 0.1).\n#\' See the reference in this man page for details on independent filtering.\n#\' The filter used for maximizing the number of rejections is the mean\n#\' of normalized counts for all samples in the dataset.\n#\' Several arguments from the \\code{filtered_p} function of\n#\' the genefilter package (used within the \\code{results} function)\n#\' are provided here to control the independent filtering behavior.\n#\' (Note \\code{filtered_p} R code is now copied into DESeq2\n#\' package to avoid gfortran requirements.)\n#\' In DESeq2 version >= 1.10, the threshold that is chosen is\n#\' the lowest quantile of the filter for which the\n#\' number of rejections is close to the peak of a curve fit\n#\' to the number of rejections over the filter quantiles.\n#\' \'Close to\' is defined as within 1 residual standard deviation.\n#\' The adjusted p-values for the genes which do not pass the filter threshold\n#\' are set to \\code{NA}. \n#\' \n#\' By default, \\code{results} assigns a p-value of \\code{NA}\n#\' to genes containing count outliers, as identified using Cook\'s distance.\n#\' See the \\code{cooksCutoff} argument for control of this behavior.\n#\' Cook\'s distances for each sample are accessible as a matrix "cooks"\n#\' stored in the \\code{assays()} list. This measure is useful for identifying rows where the\n#\' observed counts might not fit to a Negative Binomial distribution.\n#\'\n#\' For analyses using the likelihood ratio test (using \\code{\\link{nbinomLRT}}),\n#\' the p-values are determined solely by the difference in deviance between\n#\' the full and reduced model formula. A single log2 fold change is printed\n#\' in the results table for consistency with other results table outputs,\n#\' however the test statistic and p-values may nevertheless involve\n#\' the testing of one or more log2 fold changes.\n#\' Which log2 fold change is printed in the results table can be controlled\n#\' using the \\code{name} argument, or by default this will be the estimated\n#\' coefficient for the last element of \\code{resultsNames(object)}.\n#\'\n#\' If \\code{useT=TRUE} was specified when running \\code{DESeq} or \\code{nbinomWaldTest},\n#\' then the p-value generated by \\code{results} will also make use of the\n#\' t distribution for the Wald statistic, using the degrees of freedom\n#\' in \\code{mcols(object)$tDegreesFreedom}.\n#\' \n#\' @references Richard Bourgon, Robert Gentleman, Wolfgang Huber: Independent\n#\' filtering increases detection power for high-throughput experiments.\n#\' PNAS (2010), \\url{http://dx.doi.org/10.1073/pnas.0914005107}\n#\' \n#\' @param object a DESeqDataSet, on which one\n#\' of the following functions has already been called:\n#\' \\code{\\link{DESeq}}, \\code{\\link{nbinomWaldTest}}, or \\code{\\link{nbinomLRT}}\n#\' @param contrast this argument specifies what comparison to extract from\n#\' the \\code{object} to build a results table. one of either:\n#\' \\itemize{\n#\'  \\item a character vector with exactly three elements:\n#\' the name of a factor in the design formula,\n#\' the name of the numerator level for the fold change,\n#\' and the name of the denominator level for the fold change\n#\' (simplest case)\n#\'  \\item a list of 2 character vectors: the names of the fold changes\n#\' for the numerator, and the names of the fold changes\n#\' for the denominator.\n#\' these names should be elements of \\code{resultsNames(object)}.\n#\' if the list is length 1, a second element is added which is the\n#\' empty character vector, \\code{character()}.\n#\' (more general case, can be to combine interaction terms and main effects)\n#\'  \\item a numeric contrast vector with one element\n#\' for each element in \\code{resultsNames(object)} (most general case)\n#\' }\n#\' If specified, the \\code{name} argument is ignored.\n#\' @param name the name of the individual effect (coefficient) for\n#\' building a results table. Use this argument rather than \\code{contrast}\n#\' for continuous variables, individual effects or for individual interaction terms.\n#\' The value provided to \\code{name} must be an element of \\code{resultsNames(object)}.\n#\' @param lfcThreshold a non-negative value which specifies a log2 fold change\n#\' threshold. The default value is 0, corresponding to a test that\n#\' the log2 fold changes are equal to zero. The user can\n#\' specify the alternative hypothesis using the \\code{altHypothesis} argument,\n#\' which defaults to testing\n#\' for log2 fold changes greater in absolute value than a given threshold.\n#\' If \\code{lfcThreshold} is specified,\n#\' the results are for Wald tests, and LRT p-values will be overwritten.\n#\' @param altHypothesis character which specifies the alternative hypothesis,\n#\' i.e. those values of log2 fold change which the user is interested in\n#\' finding. The complement of this set of values is the null hypothesis which\n#\' will be tested. If the log2 fold change specified by \\code{name}\n#\' or by \\code{contrast} is written as \\eqn{ \\beta }{ beta }, then the possible values for\n#\' \\code{altHypothesis} represent the following alternate hypotheses:\n#\' \\itemize{\n#\' \\item greaterAbs: \\eqn{|\\beta| > \\textrm{lfcThreshold} }{ |beta| > lfcThreshold },\n#\' and p-values are two-tailed\n#\' \\item lessAbs: \\eqn{ |\\beta| < \\textrm{lfcThreshold} }{ |beta| < lfcThreshold },\n#\' p-values are the maximum of the upper and lower tests.\n#\' The Wald statistic given is positive, an SE-scaled distance from the closest boundary\n#\' \\item greater: \\eqn{ \\beta > \\textrm{lfcThreshold} }{ beta > lfcThreshold }\n#\' \\item less: \\eqn{ \\beta < -\\textrm{lfcThreshold} }{ beta < -lfcThreshold }\n#\' }\n#\' @param listValues only used if a list is provided to \\code{contrast}:\n#\' a numeric of length two: the log2 fold changes in the list are multiplied by these values.\n#\' the first number should be positive and the second negative. \n#\' by default this is \\code{c(1,-1)}\n#\' @param cooksCutoff theshold on Cook\'s distance, such that if one or more\n#\' samples for a row have a distance higher, the p-value for the row is\n#\' set to NA. The default cutoff is the .99 quantile of the F(p, m-p) distribution,\n#\' where p is the number of coefficients being fitted and m is the number of samples.\n#\' Set to \\code{Inf} or \\code{FALSE} to disable the resetting of p-values to NA.\n#\' Note: this test excludes the Cook\'s distance of samples belonging to experimental\n#\' groups with only 2 samples.\n#\' @param independentFiltering logical, whether independent filtering should be\n#\' applied automatically\n#\' @param alpha the significance cutoff used for optimizing the independent\n#\' filtering (by default 0.1). If the adjusted p-value cutoff (FDR) will be a\n#\' value other than 0.1, \\code{alpha} should be set to that value.\n#\' @param filter the vector of filter statistics over which the independent\n#\' filtering will be optimized. By default the mean of normalized counts is used.\n#\' @param theta the quantiles at which to assess the number of rejections\n#\' from independent filtering\n#\' @param pAdjustMethod the method to use for adjusting p-values, see \\code{?p.adjust}\n#\' @param filterFun an optional custom function for performing independent filtering\n#\' and p-value adjustment, with arguments \\code{res} (a DESeqResults object),\n#\' \\code{filter} (the quantitity for filtering tests),\n#\' \\code{alpha} (the target FDR),\n#\' \\code{pAdjustMethod}. This function should return a DESeqResults object\n#\' with a \\code{padj} column.\n#\' @param format character, either \\code{"DataFrame"},\n#\' \\code{"GRanges"}, or \\code{"GRangesList"},\n#\' whether the results should be printed as a \\code{\\link{DESeqResults}} DataFrame,\n#\' or if the results DataFrame should be attached as metadata columns to\n#\' the \\code{GRanges} or \\code{GRangesList} \\code{rowRanges} of the \\code{DESeqDataSet}.\n#\' If the \\code{rowRanges} is a \\code{GRangesList}, and \\code{GRanges} is requested, \n#\' the range of each gene will be returned\n#\' @param saveCols character or numeric vector, the columns of\n#\' \\code{mcols(object)} to pass into the \\code{results} output\n#\' @param test this is automatically detected internally if not provided.\n#\' the one exception is after \\code{nbinomLRT} has been run, \\code{test="Wald"}\n#\' will generate Wald statistics and Wald test p-values.\n#\' @param addMLE if \\code{betaPrior=TRUE} was used (non-default),\n#\' this logical argument specifies if the "unshrunken" maximum likelihood estimates (MLE)\n#\' of log2 fold change should be added as a column to the results table (default is FALSE).\n#\' This argument is preserved for backward compatability, as now \\code{betaPrior=TRUE}\n#\' by default and the recommended pipeline is\n#\' to generate shrunken MAP estimates using \\code{\\link{lfcShrink}}.\n#\' This argument functionality is only implemented for \\code{contrast}\n#\' specified as three element character vectors.\n#\' @param tidy whether to output the results table with rownames as a first column \'row\'.\n#\' the table will also be coerced to \\code{data.frame}\n#\' @param parallel if FALSE, no parallelization. if TRUE, parallel\n#\' execution using \\code{BiocParallel}, see next argument \\code{BPPARAM}\n#\' @param BPPARAM an optional parameter object passed internally\n#\' to \\code{\\link{bplapply}} when \\code{parallel=TRUE}.\n#\' If not specified, the parameters last registered with\n#\' \\code{\\link{register}} will be used.\n#\' @param minmu lower bound on the estimated count (used when calculating contrasts)\n#\' \n#\' @return For \\code{results}: a \\code{\\link{DESeqResults}} object, which is\n#\' a simple subclass of DataFrame. This object contains the results columns:\n#\' \\code{baseMean}, \\code{log2FoldChange}, \\code{lfcSE}, \\code{stat},\n#\' \\code{pvalue} and \\code{padj},\n#\' and also includes metadata columns of variable information.\n#\' The \\code{lfcSE} gives the standard error of the \\code{log2FoldChange}.\n#\' For the Wald test, \\code{stat} is the Wald statistic: the \\code{log2FoldChange}\n#\' divided by \\code{lfcSE}, which is compared to a standard Normal distribution\n#\' to generate a two-tailed \\code{pvalue}. For the likelihood ratio test (LRT),\n#\' \\code{stat} is the difference in deviance between the reduced model and the full model,\n#\' which is compared to a chi-squared distribution to generate a \\code{pvalue}.\n#\'\n#\' For \\code{resultsNames}: the names of the columns available as results,\n#\' usually a combination of the variable name and a level\n#\'\n#\' For \\code{removeResults}: the original \\code{DESeqDataSet} with results metadata columns removed\n#\'\n#\' @seealso \\code{\\link{DESeq}}, \\code{\\link{lfcShrink}}\n#\'\n#\' @examples\n#\'\n#\' ## Example 1: two-group comparison\n#\' \n#\' dds <- makeExampleDESeqDataSet(m=4)\n#\' \n#\' dds <- DESeq(dds)\n#\' res <- results(dds, contrast=c("condition","B","A"))\n#\'\n#\' # with more than two groups, the call would look similar, e.g.:\n#\' # results(dds, contrast=c("condition","C","A"))\n#\' # etc.\n#\' \n#\' ## Example 2: two conditions, two genotypes, with an interaction term\n#\' \n#\' dds <- makeExampleDESeqDataSet(n=100,m=12)\n#\' dds$genotype <- factor(rep(rep(c("I","II"),each=3),2))\n#\' \n#\' design(dds) <- ~ genotype + condition + genotype:condition\n#\' dds <- DESeq(dds) \n#\' resultsNames(dds)\n#\'\n#\' # the condition effect for genotype I (the main effect)\n#\' results(dds, contrast=c("condition","B","A"))\n#\'\n#\' # the condition effect for genotype II\n#\' # this is, by definition, the main effect *plus* the interaction term\n#\' # (the extra condition effect in genotype II compared to genotype I).\n#\' results(dds, list( c("condition_B_vs_A","genotypeII.conditionB") ))\n#\' \n#\' # the interaction term, answering: is the condition effect *different* across genotypes?\n#\' results(dds, name="genotypeII.conditionB")\n#\'  \n#\' ## Example 3: two conditions, three genotypes\n#\'\n#\' # ~~~ Using interaction terms ~~~\n#\' \n#\' dds <- makeExampleDESeqDataSet(n=100,m=18)\n#\' dds$genotype <- factor(rep(rep(c("I","II","III"),each=3),2))\n#\' design(dds) <- ~ genotype + condition + genotype:condition\n#\' dds <- DESeq(dds)\n#\' resultsNames(dds)\n#\'\n#\' # the condition effect for genotype I (the main effect)\n#\' results(dds, contrast=c("condition","B","A"))\n#\'\n#\' # the condition effect for genotype III.\n#\' # this is the main effect *plus* the interaction term\n#\' # (the extra condition effect in genotype III compared to genotype I).\n#\' results(dds, contrast=list( c("condition_B_vs_A","genotypeIII.conditionB") ))\n#\'  \n#\' # the interaction term for condition effect in genotype III vs genotype I.\n#\' # this tests if the condition effect is different in III compared to I\n#\' results(dds, name="genotypeIII.conditionB")\n#\' \n#\' # the interaction term for condition effect in genotype III vs genotype II.\n#\' # this tests if the condition effect is different in III compared to II\n#\' results(dds, contrast=list("genotypeIII.conditionB", "genotypeII.conditionB"))\n#\'\n#\' # Note that a likelihood ratio could be used to test if there are any\n#\' # differences in the condition effect between the three genotypes.\n#\' \n#\' # ~~~ Using a grouping variable ~~~\n#\' \n#\' # This is a useful construction when users just want to compare\n#\' # specific groups which are combinations of variables.\n#\' \n#\' dds$group <- factor(paste0(dds$genotype, dds$condition))\n#\' design(dds) <- ~ group\n#\' dds <- DESeq(dds)\n#\' resultsNames(dds)\n#\'\n#\' # the condition effect for genotypeIII\n#\' results(dds, contrast=c("group", "IIIB", "IIIA"))\n#\' \n#\' @rdname results\n#\' @aliases results resultsNames removeResults\n#\' @export\nresults <- function(object, contrast, name, \n                    lfcThreshold=0,\n                    altHypothesis=c("greaterAbs","lessAbs","greater","less"),\n                    listValues=c(1,-1),\n                    cooksCutoff,\n                    independentFiltering=TRUE,\n                    alpha=0.1, filter, theta,\n                    pAdjustMethod="BH",\n                    filterFun,\n                    format=c("DataFrame","GRanges","GRangesList"),\n                    saveCols=NULL,\n                    test,\n                    addMLE=FALSE,\n                    tidy=FALSE,\n                    parallel=FALSE, BPPARAM=bpparam(), \n                    minmu=0.5) {\n\n  stopifnot(is(object, "DESeqDataSet"))\n  \n  # match args\n  format <- match.arg(format, choices=c("DataFrame", "GRanges","GRangesList"))\n  altHypothesis <- match.arg(altHypothesis, choices=c("greaterAbs","lessAbs","greater","less"))\n  if (!missing(test)) {\n    test <- match.arg(test, choices=c("Wald","LRT"))\n  }\n  \n  ### initial argument testing ###\n  \n  stopifnot(lfcThreshold >= 0)\n  stopifnot(length(lfcThreshold)==1)\n  stopifnot(length(alpha)==1)\n  stopifnot(alpha > 0 & alpha < 1)\n  stopifnot(length(pAdjustMethod)==1)\n  stopifnot(length(listValues)==2 & is.numeric(listValues))\n  stopifnot(listValues[1] > 0 & listValues[2] < 0)\n  if (!"results" %in% mcols(mcols(object))$type) {\n    stop("couldn\'t find results. you should first run DESeq()")\n  }\n  if (missing(test)) {\n    test <- attr(object, "test")\n  } else if (test == "Wald" & attr(object, "test") == "LRT") {\n    # initially test was LRT, now need to add Wald statistics and p-values\n    object <- makeWaldTest(object)\n  } else if (test == "LRT" & attr(object, "test") == "Wald") {\n    stop("the LRT requires the user run nbinomLRT or DESeq(dds,test=\'LRT\')")\n  }\n  if (lfcThreshold == 0 & altHypothesis == "lessAbs") {\n    stop("when testing altHypothesis=\'lessAbs\', set the argument lfcThreshold to a positive value")\n  }\n  \n  if (addMLE) {\n    if (!attr(object,"betaPrior")) {\n      stop("addMLE=TRUE is only for when a beta prior was used.\notherwise, the log2 fold changes are already MLE")\n    }\n    if (!missing(name) & missing(contrast)) {\n      stop("addMLE=TRUE should be used by providing character vector\nof length 3 to \'contrast\' instead of using \'name\'")\n    }\n  }\n  \n  if (format == "GRanges" & is(rowRanges(object),"GRangesList")) {\n    if (any(elementNROWS(rowRanges(object)) == 0)) {\n      stop("rowRanges is GRangesList and one or more GRanges have length 0. Use format=\'DataFrame\' or \'GRangesList\'")\n    }\n  }\n\n  if (!is.null(saveCols)) {\n    if (is(saveCols, "character"))\n      stopifnot(all(saveCols %in% colnames(mcols(object))))\n    if (is(saveCols, "numeric")) {\n      stopifnot(saveCols == round(saveCols))\n      stopifnot(min(saveCols) > 0)\n      stopifnot(max(saveCols) <= ncol(mcols(object)))\n    }\n  }\n\n  if (!missing(contrast)) {\n    if (attr(object,"modelMatrixType") == "user-supplied" & is.character(contrast)) {\n      stop("only list- and numeric-type contrasts are supported for user-supplied model matrices")\n    }\n  }\n\n  if (is(design(object), "formula")) {\n    hasIntercept <- attr(terms(design(object)),"intercept") == 1\n    isExpanded <- attr(object, "modelMatrixType") == "expanded"\n    termsOrder <- attr(terms.formula(design(object)),"order")\n    # if no intercept was used or an expanded model matrix was used, \n    # and neither \'contrast\' nor \'name\' were specified,\n    # and no interactions...\n    # then we create the result table: last / first level for last variable\n    if ((test == "Wald") & (isExpanded | !hasIntercept) & missing(contrast) & missing(name) & all(termsOrder < 2)) {\n      designVars <- all.vars(design(object))\n      lastVarName <- designVars[length(designVars)]\n      lastVar <- colData(object)[[lastVarName]]\n      if (is.factor(lastVar)) {\n        nlvls <- nlevels(lastVar)\n        contrast <- c(lastVarName, levels(lastVar)[nlvls], levels(lastVar)[1])\n      }\n    }\n  }\n  \n  if (missing(name)) {\n    name <- lastCoefName(object)\n  } else { \n    if (length(name) != 1 | !is.character(name)) {\n      stop("the argument \'name\' should be a character vector of length 1")\n    }\n  }\n\n  ### done with input argument testing ###\n  \n  WaldResults <- paste0("WaldPvalue_",name) %in% names(mcols(object))\n  LRTResults <- "LRTPvalue" %in% names(mcols(object))\n\n  # this will be used in cleanContrast, and in the lfcThreshold chunks below\n  useT <- "tDegreesFreedom" %in% names(mcols(object))\n  \n  # if performing a contrast call the function cleanContrast()\n  if (!missing(contrast)) {\n    resNames <- resultsNames(object)\n    # do some arg checking/cleaning\n    contrast <- checkContrast(contrast, resNames)\n\n    ### cleanContrast call ###   \n    # need to go back to C++ code in order to build the beta covariance matrix\n    # then this is multiplied by the numeric contrast to get the Wald statistic.\n    # with 100s of samples, this can get slow, so offer parallelization\n    if (!parallel) {\n      res <- cleanContrast(object, contrast, expanded=isExpanded, listValues=listValues,\n                           test=test, useT=useT, minmu=minmu)\n    } else if (parallel) {\n      # parallel execution\n      nworkers <- getNworkers(BPPARAM)\n      idx <- factor(sort(rep(seq_len(nworkers),length.out=nrow(object))))\n      res <- do.call(rbind, bplapply(levels(idx), function(l) {\n        cleanContrast(object[idx == l,,drop=FALSE], contrast,\n                      expanded=isExpanded, listValues=listValues,\n                      test=test, useT=useT, minmu=minmu)\n      }, BPPARAM=BPPARAM))\n    }\n\n  } else {\n    # if not performing a contrast\n    # pull relevant columns from mcols(object)\n    log2FoldChange <- getCoef(object, name)\n    lfcSE <- getCoefSE(object, name)\n    stat <- getStat(object, test, name)\n    pvalue <- getPvalue(object, test, name)\n    res <- cbind(mcols(object)["baseMean"],log2FoldChange,lfcSE,stat,pvalue)\n    names(res) <- c("baseMean","log2FoldChange","lfcSE","stat","pvalue")\n  }\n  \n  rownames(res) <- rownames(object)\n\n  # add unshrunken MLE coefficients to the results table\n  if (addMLE) {\n    if (is.numeric(contrast)) stop("addMLE only implemented for: contrast=c(\'condition\',\'B\',\'A\')")\n    if (is.list(contrast)) stop("addMLE only implemented for: contrast=c(\'condition\',\'B\',\'A\')")\n    res <- cbind(res, mleContrast(object, contrast))\n    res <- res[,c("baseMean","log2FoldChange","lfcMLE","lfcSE","stat","pvalue")]\n    # if an all zero contrast, also zero out the lfcMLE\n    res$lfcMLE[ which(res$log2FoldChange == 0 & res$stat == 0) ] <- 0\n  }\n  \n  # only if we need to generate new p-values\n  if ( !(lfcThreshold == 0 & altHypothesis == "greaterAbs") ) {\n    if (test == "LRT") {\n      stop("tests of log fold change above or below a theshold must be Wald tests.")\n    }\n    # check requirement if betaPrior was set to FALSE\n    if (altHypothesis == "lessAbs" & attr(object, "betaPrior")) {\n      stop("testing altHypothesis=\'lessAbs\' requires setting the DESeq() argument betaPrior=FALSE")\n    }\n    # easier to read\n    LFC <- res$log2FoldChange\n    SE <- res$lfcSE\n    T <- lfcThreshold\n\n    if (useT) {\n      df <- mcols(object)$tDegreesFreedom\n      pfunc <- function(q) pt(q, df=df, lower.tail=FALSE)\n    } else {\n      pfunc <- function(q) pnorm(q, lower.tail=FALSE)\n    }\n    \n    if (altHypothesis == "greaterAbs") {\n      newStat <- sign(LFC) * pmax((abs(LFC) - T)/SE, 0)\n      newPvalue <- pmin(1, 2 * pfunc((abs(LFC) - T)/SE))\n    } else if (altHypothesis == "lessAbs") {\n      newStatAbove <- pmax((T - LFC)/SE, 0)\n      pvalueAbove <- pfunc((T - LFC)/SE)\n      newStatBelow <- pmax((LFC + T)/SE, 0)\n      pvalueBelow <- pfunc((LFC + T)/SE)\n      newStat <- pmin(newStatAbove, newStatBelow)\n      newPvalue <- pmax(pvalueAbove, pvalueBelow)\n    } else if (altHypothesis == "greater") {\n      newStat <- pmax((LFC - T)/SE, 0)\n      newPvalue <- pfunc((LFC - T)/SE)\n    } else if (altHypothesis == "less") {\n      newStat <- pmin((LFC + T)/SE, 0)\n      newPvalue <- pfunc((-T - LFC)/SE)\n    }\n    res$stat <- newStat\n    res$pvalue <- newPvalue\n  }\n  \n  # calculate Cook\'s cutoff\n  m <- nrow(attr(object,"dispModelMatrix"))\n  p <- ncol(attr(object,"dispModelMatrix"))\n  \n  defaultCutoff <- qf(.99, p, m - p)\n  if (missing(cooksCutoff)) {\n    cooksCutoff <- defaultCutoff\n  }\n  stopifnot(length(cooksCutoff)==1)\n  if (is.logical(cooksCutoff) & cooksCutoff) {\n    cooksCutoff <- defaultCutoff\n  }\n  \n  # apply cutoff based on maximum Cook\'s distance\n  performCooksCutoff <- (is.numeric(cooksCutoff) | cooksCutoff) \n  if (performCooksCutoff) {\n    cooksOutlier <- mcols(object)$maxCooks > cooksCutoff\n    \n    ### BEGIN heuristic to avoid filtering genes with low count outliers\n    # as according to Cook\'s cutoff. only for two group designs.\n    # dont filter if three or more counts are larger\n    if (any(cooksOutlier,na.rm=TRUE) & is(design(object), "formula")) {\n      designVars <- all.vars(design(object))\n      if (length(designVars) == 1) {\n        var <- colData(object)[[designVars]]\n        if (is(var, "factor") && nlevels(var) == 2) {\n          dontFilter <- logical(sum(cooksOutlier,na.rm=TRUE))\n          for (i in seq_along(dontFilter)) {\n            # index along rows of object\n            ii <- which(cooksOutlier)[i] \n            # count for the outlier with max cooks\n            outCount <- counts(object)[ii,which.max(assays(object)[["cooks"]][ii,])]\n            # if three or more counts larger than the outlier\n            if (sum(counts(object)[ii,] > outCount) >= 3) {\n              # don\'t filter out the p-value for that gene\n              dontFilter[i] <- TRUE\n            }\n          }\n          # reset the outlier status for these genes\n          cooksOutlier[which(cooksOutlier)][dontFilter] <- FALSE\n        }\n      }\n    } ### END heuristic ###\n\n    res$pvalue[which(cooksOutlier)] <- NA\n  }\n\n  # if original baseMean was positive, but now zero due to replaced counts, fill in results\n  if ( sum(mcols(object)$replace, na.rm=TRUE) > 0) {\n    nowZero <- which(mcols(object)$replace & mcols(object)$baseMean == 0)\n    res$log2FoldChange[nowZero] <- 0\n    if (addMLE) { res$lfcMLE[nowZero] <- 0 }\n    res$lfcSE[nowZero] <- 0\n    res$stat[nowZero] <- 0\n    res$pvalue[nowZero] <- 1\n  }\n\n  # add prior information\n  deseq2.version <- packageVersion("DESeq2")\n  if (!attr(object,"betaPrior")) {\n    priorInfo <- list(type="none", package="DESeq2", version=deseq2.version)\n  } else {\n    betaPriorVar <- attr(object, "betaPriorVar")\n    priorInfo <- list(type="normal", package="DESeq2", version=deseq2.version,\n                      betaPriorVar=betaPriorVar)\n  }\n  \n  # make results object\n  deseqRes <- DESeqResults(res, priorInfo=priorInfo)\n  \n  # p-value adjustment\n  if (missing(filterFun)) {\n    deseqRes <- pvalueAdjustment(deseqRes, independentFiltering, filter,\n                                 theta, alpha, pAdjustMethod)\n  } else {\n    deseqRes <- filterFun(deseqRes, filter, alpha, pAdjustMethod)\n  }\n\n  # stash lfcThreshold\n  metadata(deseqRes)[["lfcThreshold"]] <- lfcThreshold\n  \n  # remove rownames and attach as a new column, \'row\'\n  if (tidy) {\n    colnms <- colnames(deseqRes)\n    deseqRes$row <- rownames(deseqRes)\n    mcols(deseqRes,use.names=TRUE)["row","type"] <- "results"\n    mcols(deseqRes,use.names=TRUE)["row","description"] <- "row names"\n    deseqRes <- deseqRes[,c("row",colnms)]\n    rownames(deseqRes) <- NULL\n    deseqRes <- as.data.frame(deseqRes)\n  }\n\n  # return DataFrame, GRanges or GRangesList\n  out <- resultsFormatSwitch(object=object, res=deseqRes, format=format, saveCols=saveCols)\n  return(out)\n}\n\n#\' @rdname results\n#\' @export\nresultsNames <- function(object) {\n  names(mcols(object))[grep("log2 fold change",mcols(mcols(object))$description)]\n}\n\n#\' @rdname results\n#\' @export\nremoveResults <- function(object) {\n  resCols <- mcols(mcols(object))$type == "results"\n  if (sum(resCols,na.rm=TRUE) > 0) {\n    mcols(object) <- mcols(object)[,-which(resCols),drop=FALSE]\n  }\n  return(object)\n}\n\n\n###########################################################\n# unexported functons \n###########################################################\n\npvalueAdjustment <- function(res, independentFiltering, filter,\n                             theta, alpha, pAdjustMethod) {\n  # perform independent filtering\n  if (independentFiltering) {\n    if (missing(filter)) {\n      filter <- res$baseMean\n    }\n    if (missing(theta)) {\n      lowerQuantile <- mean(filter == 0)\n      if (lowerQuantile < .95) upperQuantile <- .95 else upperQuantile <- 1\n      theta <- seq(lowerQuantile, upperQuantile, length=50)\n    }\n\n    # do filtering using genefilter\n    stopifnot(length(theta) > 1)\n    stopifnot(length(filter) == nrow(res))\n    filtPadj <- filtered_p(filter=filter, test=res$pvalue,\n                           theta=theta, method=pAdjustMethod) \n    numRej  <- colSums(filtPadj < alpha, na.rm = TRUE)\n    # prevent over-aggressive filtering when all genes are null,\n    # by requiring the max number of rejections is above a fitted curve.\n    # If the max number of rejection is not greater than 10, then don\'t\n    # perform independent filtering at all.\n    lo.fit <- lowess(numRej ~ theta, f=1/5)\n    if (max(numRej) <= 10) {\n      j <- 1\n    } else { \n\n      residual <- if (all(numRej==0)) {\n        0\n      } else {\n        numRej[numRej > 0] - lo.fit$y[numRej > 0]\n      }\n\n      # this usually works: find the threshold at which num rejections\n      # surpasses the root mean squared error around the fitted curve.\n      # it may not work if there is a sharp uptick in the curve at\n      # the end of the grid, and there is very little variation.\n      maxFit <- max(lo.fit$y)\n      rmse <- sqrt(mean(residual^2))\n      thresh <- maxFit - rmse\n      \n      j <- if (any(numRej > thresh)) {\n             # backup case: if low variation and uptick at end,\n             # pick the first point at which num rejections reaches\n             # 90% of the fitted curve, or 80% of the fitted curve\n             which(numRej > thresh)[1]\n           } else if (any(numRej > .9 * maxFit)) {\n             which(numRej > .9 * maxFit)[1]\n           } else if (any(numRej > .8 * maxFit)) {\n             which(numRej > .8 * maxFit)[1]\n           } else {\n             1\n           }\n    }\n    # j <- which.max(numRej) # old method, not stable\n    padj <- filtPadj[, j, drop=TRUE]\n    cutoffs <- quantile(filter, theta)\n    filterThreshold <- cutoffs[j]\n    filterNumRej <- data.frame(theta=theta, numRej=numRej)\n    filterTheta <- theta[j]\n\n    metadata(res)[["filterThreshold"]] <- filterThreshold\n    metadata(res)[["filterTheta"]] <- filterTheta\n    metadata(res)[["filterNumRej"]] <- filterNumRej\n    metadata(res)[["lo.fit"]] <- lo.fit\n    metadata(res)[["alpha"]] <- alpha\n  } else {\n    # regular p-value adjustment\n    # does not include those rows which were removed\n    # by maximum Cook\'s distance\n    padj <- p.adjust(res$pvalue,method=pAdjustMethod)  \n  }\n  res$padj <- padj\n  \n  # add metadata to padj column\n  mcols(res)$type[names(res)=="padj"] <- "results"\n  mcols(res)$description[names(res)=="padj"] <- paste(pAdjustMethod,"adjusted p-values")\n  \n  res\n}\n\n# function copied from `genefilter` package to avoid gfortran requirement\nfiltered_p <- function( filter, test, theta, data, method = "none" ) {\n  if ( is.function( filter ) )\n    U1 <- filter( data )\n  else\n    U1 <- filter\n  cutoffs <- quantile( U1, theta )\n  result <- matrix( NA_real_, length( U1 ), length( cutoffs ) )\n  colnames( result ) <- names( cutoffs )\n  for ( i in 1:length( cutoffs ) ) {    \n    use <- U1 >= cutoffs[i]\n    if( any( use ) ) {\n      if( is.function( test ) )\n        U2 <- test( data[use,] )\n      else\n        U2 <- test[use]\n      result[use,i] <- p.adjust( U2, method )\n    }\n  }\n  return( result )\n}\n\n# two low-level functions used by results() to perform contrasts\n#\n# getContrast takes a DESeqDataSet object\n# and a numeric vector specifying a contrast\n# and returns a vector of Wald statistics\n# corresponding to the contrast.\n#\n# cleanContrast checks for the validity of\n# the specified contrast (numeric or character vector)\n# and turns character vector contrast into the appropriate\n# numeric vector contrast\n#\n# results() calls cleanContrast() which calls getContrast()\n#\n# the formula used is:\n# c\' beta / sqrt( c\' sigma c)\n# where beta is the coefficient vector\n# and sigma is the covariance matrix for beta\ngetContrast <- function(object, contrast, useT=FALSE, minmu) {\n  if (missing(contrast)) {\n    stop("must provide a contrast")\n  }\n  if (is.null(attr(object,"modelMatrix"))) {\n    stop("was expecting a model matrix stored as an attribute of the DESeqDataSet")\n  }\n  modelMatrix <- attr(object, "modelMatrix")\n  \n  # only continue on the rows with non-zero row mean\n  objectNZ <- object[!mcols(object)$allZero,]\n  normalizationFactors <- getSizeOrNormFactors(objectNZ)\n  alpha_hat <- dispersions(objectNZ)\n  coefColumns <- names(mcols(objectNZ))[grep("log2 fold change",mcols(mcols(object))$description)]\n  # convert betas to log scale\n  beta_mat <- log(2) * as.matrix(mcols(objectNZ)[,coefColumns,drop=FALSE])\n  # convert beta prior variance to log scale\n  lambda = 1/(log(2)^2 * attr(object,"betaPriorVar"))\n\n  # check if DESeq() replaced outliers\n  countsMatrix <- if ("replaceCounts" %in% assayNames(object)) {\n    assays(objectNZ)[["replaceCounts"]]\n  } else {\n    counts(objectNZ)\n  }\n\n  # use weights if they are present in assays(object)\n  if ("weights" %in% assayNames(object)) {\n    useWeights <- TRUE\n    weights <- assays(object)[["weights"]]\n    stopifnot(all(weights >= 0))\n    weights <- weights / apply(weights, 1, max)\n  } else {\n    useWeights <- FALSE\n    weights <- matrix(1, nrow=nrow(object), ncol=ncol(object))\n  }\n  \n  betaRes <- fitBeta(ySEXP = countsMatrix, xSEXP = modelMatrix,\n                     nfSEXP = normalizationFactors,\n                     alpha_hatSEXP = alpha_hat,\n                     contrastSEXP = contrast,\n                     beta_matSEXP = beta_mat,\n                     lambdaSEXP = lambda,\n                     weightsSEXP = weights,\n                     useWeightsSEXP = useWeights,\n                     tolSEXP = 1e-8, maxitSEXP = 0,\n                     useQRSEXP=FALSE, # QR not relevant, fitting loop isn\'t entered\n                     minmuSEXP=minmu)\n  # convert back to log2 scale\n  contrastEstimate <- log2(exp(1)) * betaRes$contrast_num\n  contrastSE <- log2(exp(1)) * betaRes$contrast_denom\n  contrastStatistic <- contrastEstimate / contrastSE\n  if (useT) {\n    stopifnot("tDegreesFreedom" %in% names(mcols(object)))\n    df <- mcols(objectNZ)$tDegreesFreedom\n    contrastPvalue <- 2*pt(abs(contrastStatistic),df=df,lower.tail=FALSE)\n  } else {\n    contrastPvalue <- 2*pnorm(abs(contrastStatistic),lower.tail=FALSE)\n  }\n  contrastList <- list(log2FoldChange=contrastEstimate,\n                       lfcSE=contrastSE,\n                       stat=contrastStatistic,\n                       pvalue=contrastPvalue)\n  contrastResults <- buildDataFrameWithNARows(contrastList,\n                                              mcols(object)$allZero)\n  names(contrastResults) <- c("log2FoldChange","lfcSE","stat","pvalue")\n  contrastResults\n}\n\n# this function takes a desired contrast as specified by results(),\n# performs checks, and then either returns the already existing contrast\n# or generates the contrast by calling getContrast() using a numeric vector\ncleanContrast <- function(object, contrast, expanded=FALSE, listValues, test, useT, minmu) {\n  # get the names of columns in the beta matrix\n  resNames <- resultsNames(object)\n  # if possible, return pre-computed columns, which are\n  # already stored in mcols(dds). this will be the case using\n  # results() with \'name\', or if expanded model matrices were not\n  # run and the contrast contains the reference level as numerator or denominator\n\n  resReady <- FALSE\n  \n  if (is.character(contrast)) {\n    contrastFactor <- contrast[1]\n    if (!contrastFactor %in% names(colData(object))) {\n      stop(paste(contrastFactor,"should be the name of a factor in the colData of the DESeqDataSet"))\n    }\n    if (!is(colData(object)[[contrastFactor]], "factor")) {\n      stop(paste(contrastFactor,"is not a factor, see ?results"))\n    }\n    contrastNumLevel <- contrast[2]\n    contrastDenomLevel <- contrast[3]\n    contrastBaseLevel <- levels(colData(object)[,contrastFactor])[1]\n    \n    # check for intercept\n    hasIntercept <- attr(terms(design(object)),"intercept") == 1\n    firstVar <- contrastFactor == all.vars(design(object))[1]\n\n    # tricky case: if the design has no intercept, the factor is\n    # not the first variable in the design, and one of the numerator or denominator\n    # is the reference level, then the desired contrast is simply a coefficient (or -1 times)\n    noInterceptPullCoef <- !hasIntercept & !firstVar &\n      (contrastBaseLevel %in% c(contrastNumLevel, contrastDenomLevel))\n    \n    # case 1: standard model matrices: pull coef or build the appropriate contrast\n    # coefficients names are of the form  "factor_level_vs_baselevel"\n    # output: contrastNumColumn and contrastDenomColumn\n    if (!expanded & (hasIntercept | noInterceptPullCoef)) {\n      # use make.names() so the column names are\n      # the same as created by DataFrame in mcols(object).\n      contrastNumColumn <- make.names(paste0(contrastFactor,"_",contrastNumLevel,"_vs_",contrastBaseLevel))\n      contrastDenomColumn <- make.names(paste0(contrastFactor,"_",contrastDenomLevel,"_vs_",contrastBaseLevel))\n      # check that the desired contrast is already\n      # available in mcols(object), and then we can either\n      # take it directly or multiply the log fold\n      # changes and Wald stat by -1\n      if ( contrastDenomLevel == contrastBaseLevel ) {\n        cleanName <- paste(contrastFactor,contrastNumLevel,"vs",contrastDenomLevel)\n        # the results can be pulled directly from mcols(object)\n        name <- if (!noInterceptPullCoef) {\n          make.names(paste0(contrastFactor,"_",contrastNumLevel,"_vs_",contrastDenomLevel))\n        } else {\n          make.names(paste0(contrastFactor,contrastNumLevel))\n        }\n        if (!name %in% resNames) {\n          stop(paste("as",contrastDenomLevel,"is the reference level, was expecting",name,"to be present in \'resultsNames(object)\'"))\n        }\n        log2FoldChange <- getCoef(object, name)\n        lfcSE <- getCoefSE(object, name)\n        stat <- getStat(object, test, name)\n        pvalue <- getPvalue(object, test, name)\n        res <- cbind(mcols(object)["baseMean"],log2FoldChange,lfcSE,stat,pvalue)\n        names(res) <- c("baseMean","log2FoldChange","lfcSE","stat","pvalue")\n        lfcType <- if (attr(object,"betaPrior")) "MAP" else "MLE"\n        lfcDesc <- paste0("log2 fold change (",lfcType,"): ",cleanName)\n        mcols(res,use.names=TRUE)["log2FoldChange","description"] <- lfcDesc\n        resReady <- TRUE\n        \n      } else if ( contrastNumLevel == contrastBaseLevel ) {\n        # fetch the results for denom vs num \n        # and mutiply the log fold change and stat by -1\n        cleanName <- paste(contrastFactor,contrastNumLevel,"vs",contrastDenomLevel)\n        swapName <- if (!noInterceptPullCoef) {\n          make.names(paste0(contrastFactor,"_",contrastDenomLevel,"_vs_",contrastNumLevel))\n        } else {\n          make.names(paste0(contrastFactor,contrastDenomLevel))\n        }\n        if (!swapName %in% resNames) {\n          stop(paste("as",contrastNumLevel,"is the reference level, was expecting",swapName,"to be present in \'resultsNames(object)\'"))\n        }\n        log2FoldChange <- getCoef(object, swapName)\n        lfcSE <- getCoefSE(object, swapName)\n        stat <- getStat(object, test, swapName)\n        pvalue <- getPvalue(object, test, swapName)\n        res <- cbind(mcols(object)["baseMean"],log2FoldChange,lfcSE,stat,pvalue)\n        names(res) <- c("baseMean","log2FoldChange","lfcSE","stat","pvalue")\n        res$log2FoldChange <- -1 * res$log2FoldChange\n        if (test == "Wald") res$stat <- -1 * res$stat\n        lfcType <- if (attr(object,"betaPrior")) "MAP" else "MLE"\n        # rename some of the columns using the flipped contrast\n        if (test == "Wald") {\n          contrastDescriptions <- paste(c(paste0("log2 fold change (",lfcType,"):"),\n                                          "standard error:",\n                                          "Wald statistic:","Wald test p-value:"), cleanName)\n          mcols(res,use.names=TRUE)[c("log2FoldChange","lfcSE","stat","pvalue"),\n                      "description"] <- contrastDescriptions\n        } else {\n          contrastDescriptions <- paste(c(paste0("log2 fold change (",lfcType,"):"),\n                                          "standard error:"), cleanName)\n          mcols(res,use.names=TRUE)[c("log2FoldChange","lfcSE"),\n                      "description"] <- contrastDescriptions\n        }\n        resReady <- TRUE\n        \n      } else {\n        # check for the case where neither are present\n        # as comparisons against reference level\n        if ( ! (contrastNumColumn %in% resNames &\n                  contrastDenomColumn %in% resNames) ) {\n          stop(paste(contrastNumLevel,"and",contrastDenomLevel,"should be levels of",contrastFactor,"such that",contrastNumColumn,"and",contrastDenomColumn,"are contained in \'resultsNames(object)\'"))\n        }\n      }\n      # case 2: expanded model matrices or no intercept and first variable\n      # need to then build the appropriate contrast.\n      # these coefficient names have the form "factorlevel"\n      # output: contrastNumColumn and contrastDenomColumn\n    } else {\n      # we only need to check validity\n      contrastNumColumn <- make.names(paste0(contrastFactor, contrastNumLevel))\n      contrastDenomColumn <- make.names(paste0(contrastFactor, contrastDenomLevel))\n      if ( ! (contrastNumColumn %in% resNames & contrastDenomColumn %in% resNames) ) {\n        stop(paste(paste0(contrastFactor,contrastNumLevel),"and",paste0(contrastFactor,contrastDenomLevel),\n                   "are expected to be in resultsNames(object)"))\n      }\n    }\n\n    # check if both levels have all zero counts\n    # (this has to be down here to make use of error checking above)\n    contrastAllZero <- contrastAllZeroCharacter(object, contrastFactor,\n                                                contrastNumLevel, contrastDenomLevel)\n    \n  }\n\n  # if the result table not already built in the above code\n  if (!resReady) {\n    \n    # here, a numeric / list / character contrast which will be converted\n    # into a numeric contrast and run through getContrast()\n    if (is.numeric(contrast)) {\n      # make name for numeric contrast\n      signMap <- c("","","+")\n      contrastSigns <- signMap[sign(contrast)+2]\n      contrastName <- paste(paste0(contrastSigns,as.character(contrast)),collapse=",")\n    } else if (is.list(contrast)) {\n      # interpret list contrast into numeric and make a name for the contrast\n      lc1 <- length(contrast[[1]])\n      lc2 <- length(contrast[[2]])\n      # these just used for naming\n      listvalname1 <- round(listValues[1],3)\n      listvalname2 <- round(listValues[2],3)\n      if (lc1 > 0 & lc2 > 0) {\n        listvalname2 <- abs(listvalname2)\n        listvalname1 <- if (listvalname1 == 1) "" else paste0(listvalname1," ")\n        listvalname2 <- if (listvalname2 == 1) "" else paste0(listvalname2," ")\n        contrastName <- paste0(listvalname1,paste(contrast[[1]],collapse="+")," vs ",listvalname2,paste(contrast[[2]],collapse="+"))\n      } else if (lc1 > 0 & lc2 == 0) {\n        listvalname1 <- if (listvalname1 == 1) "" else paste0(listvalname1," ")\n        contrastName <- paste0(listvalname1,paste(contrast[[1]],collapse="+")," effect")\n      } else if (lc1 == 0 & lc2 > 0) {\n        contrastName <- paste(listvalname2,paste(contrast[[2]],collapse="+"),"effect")\n      }\n      contrastNumeric <- rep(0,length(resNames))\n      contrastNumeric[resNames %in% contrast[[1]]] <- listValues[1]\n      contrastNumeric[resNames %in% contrast[[2]]] <- listValues[2]\n      contrast <- contrastNumeric\n    } else if (is.character(contrast)) {\n      # interpret character contrast into numeric and make a name for the contrast\n      contrastNumeric <- rep(0,length(resNames))\n      contrastNumeric[resNames == contrastNumColumn] <- 1\n      contrastNumeric[resNames == contrastDenomColumn] <- -1\n      contrast <- contrastNumeric\n      contrastName <- paste(contrastFactor,contrastNumLevel,"vs",contrastDenomLevel)\n    }\n\n    contrastAllZero <- contrastAllZeroNumeric(object, contrast)\n\n    # now get the contrast\n    contrastResults <- getContrast(object, contrast, useT=useT, minmu)\n    lfcType <- if (attr(object,"betaPrior")) "MAP" else "MLE"\n    contrastDescriptions <- paste(c(paste0("log2 fold change (",lfcType,"):"),\n                                    "standard error:",\n                                    "Wald statistic:",\n                                    "Wald test p-value:"),\n                                  contrastName)\n    mcols(contrastResults) <- DataFrame(type=rep("results",ncol(contrastResults)),\n                                        description=contrastDescriptions)\n    res <- cbind(mcols(object)["baseMean"],\n                 contrastResults)\n\n  }\n    \n  # if the counts in all samples included in contrast are zero\n  # then zero out the LFC, Wald stat and p-value set to 1\n  contrastAllZero <- contrastAllZero & !mcols(object)$allZero\n  if (sum(contrastAllZero) > 0) {\n    res$log2FoldChange[contrastAllZero] <- 0\n    res$stat[contrastAllZero] <- 0\n    res$pvalue[contrastAllZero] <- 1\n  }\n\n  # if test is "LRT", overwrite the statistic and p-value\n  # (we only ran contrast for the coefficient)\n  if (test == "LRT") {\n    stat <- getStat(object, test, name=NULL)\n    pvalue <- getPvalue(object, test, name=NULL)\n    res <- cbind(res[c("baseMean","log2FoldChange","lfcSE")],stat,pvalue)\n    names(res) <- c("baseMean","log2FoldChange","lfcSE","stat","pvalue")\n  }\n  \n  return(res)\n}\n\n\n# convenience function to guess the name of the last coefficient\n# in the model matrix, unless specified this will be used for\n# plots and accessor functions\nlastCoefName <- function(object) {\n  resNms <- resultsNames(object)\n  resNms[length(resNms)]\n}\n\n# functions to get coef, coefSE, pvalues and padj from mcols(object)\ngetCoef <- function(object,name) {\n  if (missing(name)) {\n    name <- lastCoefName(object)\n  }\n  mcols(object)[name]\n}\ngetCoefSE <- function(object,name) {\n  if (missing(name)) {\n    name <- lastCoefName(object)\n  }\n  mcols(object)[paste0("SE_",name)]\n}\ngetStat <- function(object,test="Wald",name) {\n  if (missing(name)) {\n    name <- lastCoefName(object)\n  }\n  if (test == "Wald") {\n    return(mcols(object)[paste0("WaldStatistic_",name)])\n  } else if (test == "LRT") {\n    return(mcols(object)["LRTStatistic"])\n  } else {\n    stop("unknown test")\n  }\n}\ngetPvalue <- function(object,test="Wald",name) {\n  if (missing(name)) {\n    name <- lastCoefName(object)\n  }\n  if (test == "Wald") {\n    return(mcols(object)[paste0("WaldPvalue_",name)])\n  } else if (test == "LRT") {\n    return(mcols(object)["LRTPvalue"])\n  } else {\n    stop("unknown test")\n  }\n}\n\n# convenience function to make more descriptive names\n# for factor variables\nrenameModelMatrixColumns <- function(data, design) {\n  data <- as.data.frame(data)\n  designVars <- all.vars(design)\n  designVarsClass <- sapply(designVars, function(v) class(data[[v]]))\n  factorVars <- designVars[designVarsClass == "factor"]\n  colNamesFrom <- make.names(do.call(c,lapply(factorVars, function(v) paste0(v,levels(data[[v]])[-1]))))\n  colNamesTo <- make.names(do.call(c,lapply(factorVars, function(v) paste0(v,"_",levels(data[[v]])[-1],"_vs_",levels(data[[v]])[1]))))\n  data.frame(from=colNamesFrom,to=colNamesTo,stringsAsFactors=FALSE)\n}\n\nmakeWaldTest <- function(object) {\n  betaMatrix <- as.matrix(mcols(object)[,grep("log2 fold change",mcols(mcols(object))$description),drop=FALSE])\n  modelMatrixNames <- colnames(betaMatrix)\n  betaSE <- as.matrix(mcols(object)[,grep("standard error",mcols(mcols(object))$description),drop=FALSE])\n  WaldStatistic <- betaMatrix/betaSE\n  colnames(WaldStatistic) <- paste0("WaldStatistic_",modelMatrixNames)\n  # don\'t need to worry about t distribution here bc nbniomLRT() was run\n  WaldPvalue <- 2*pnorm(abs(WaldStatistic),lower.tail=FALSE)\n  colnames(WaldPvalue) <- paste0("WaldPvalue_",modelMatrixNames)\n  modelMatrixNamesSpaces <- gsub("_"," ",modelMatrixNames)\n  statInfo <- paste("Wald statistic:",modelMatrixNamesSpaces)\n  pvalInfo <- paste("Wald test p-value:",modelMatrixNamesSpaces)\n  WaldResults <- DataFrame(c(matrixToList(WaldStatistic), matrixToList(WaldPvalue)))\n  mcols(WaldResults) <- DataFrame(type = rep("results",ncol(WaldResults)),\n                                  description = c(statInfo, pvalInfo))\n  mcols(object) <- cbind(mcols(object),WaldResults)\n  return(object)\n}\n\nmleContrast <- function(object, contrast) {\n  contrastFactor <- contrast[1]\n  contrastNumLevel <- contrast[2]\n  contrastDenomLevel <- contrast[3]\n  contrastRefLevel <- levels(colData(object)[,contrastFactor])[1]\n  contrastNumColumn <- make.names(paste0("MLE_",contrastFactor,"_",contrastNumLevel,"_vs_",contrastRefLevel))\n  contrastDenomColumn <- make.names(paste0("MLE_",contrastFactor,"_",contrastDenomLevel,"_vs_",contrastRefLevel))\n  cleanName <- paste("log2 fold change (MLE):",contrastFactor,contrastNumLevel,"vs",contrastDenomLevel)\n  if ( contrastDenomLevel == contrastRefLevel ) {\n    name <- make.names(paste0("MLE_",contrastFactor,"_",contrastNumLevel,"_vs_",contrastDenomLevel))\n    lfcMLE <- mcols(object)[name]\n  } else if ( contrastNumLevel == contrastRefLevel ) {\n    swapName <- make.names(paste0("MLE_",contrastFactor,"_",contrastDenomLevel,"_vs_",contrastNumLevel))\n    lfcMLE <- mcols(object)[swapName]\n    lfcMLE[[1]] <- -1 * lfcMLE[[swapName]]\n  } else {\n    numMLE <- mcols(object)[[contrastNumColumn]]\n    denomMLE <- mcols(object)[[contrastDenomColumn]]\n    lfcMLE <- mcols(object)[contrastNumColumn]\n    lfcMLE[[1]] <- numMLE - denomMLE\n  }\n  names(lfcMLE) <- "lfcMLE"\n  mcols(lfcMLE)$description <- cleanName\n  lfcMLE\n}\n\ncheckContrast <- function(contrast, resNames) {\n  if (!(is.numeric(contrast) | is.character(contrast) | is.list(contrast))) {\n    stop("\'contrast\' vector should be either a character vector of length 3,\na list of length 2 containing character vectors,\nor a numeric vector, see the argument description in ?results")\n  }\n\n  # character\n  if (is.character(contrast)) {\n    if (length(contrast) != 3) {\n      stop("\'contrast\', as a character vector of length 3, should have the form:\ncontrast = c(\'factorName\',\'numeratorLevel\',\'denominatorLevel\'),\nsee the manual page of ?results for more information")\n    }\n    if (contrast[2] == contrast[3]) {\n      stop(paste(contrast[2],"and",contrast[3],"should be different level names"))\n    }\n  }\n\n  # list\n  if (is.list(contrast)) {\n    if (length(contrast) == 1) {\n      contrast <- list(contrast[[1]], character())\n    }\n    if (length(contrast) != 2) {\n      stop("\'contrast\', as a list, should have length 2, or, if length 1,\nan empty vector will be added for the second element.\nsee the manual page of ?results for more information")\n    }\n    if (!(is.character(contrast[[1]]) & is.character(contrast[[2]]))) {\n      stop("\'contrast\', as a list of length 2, should have character vectors as elements,\nsee the manual page of ?results for more information")\n    }\n    if (!all(c(contrast[[1]],contrast[[2]]) %in% resNames)) {\n      stop("all elements of the contrast as a list of length 2 should be elements of \'resultsNames(object)\'")\n    }\n    if (length(intersect(contrast[[1]], contrast[[2]])) > 0) {\n      stop("elements in the contrast list should only appear in the numerator (first element of contrast list)\nor the denominator (second element of contrast list), but not both")\n    }\n    if (length(c(contrast[[1]],contrast[[2]])) == 0) {\n      stop("one of the two elements in the list should be a character vector of non-zero length")\n    }    \n  }\n\n  # numeric\n  if (is.numeric(contrast)) {\n    if (length(contrast) != length(resNames) )\n      stop("numeric contrast vector should have one element for every element of \'resultsNames(object)\'")\n    if (all(contrast==0)) {\n      stop("numeric contrast vector cannot have all elements equal to 0")\n    }\n  }\n\n  return(contrast)\n}\n\n# function to determine output of results() and lfcShrink()\nresultsFormatSwitch <- function(object, res, format, saveCols) {\n  \n  if (format == "DataFrame") {\n    out <- res\n  } else if (format == "GRangesList") {\n    if (is(rowRanges(object), "GRanges")) warning("rowRanges is GRanges")\n    out <- rowRanges(object)\n    mcols(out) <- res\n  } else if (format == "GRanges") {\n    if (is(rowRanges(object), "GRangesList")) {\n      message("rowRanges is GRangesList, performing unlist(range(x)) on the rowRanges")\n      out <- unlist(range(rowRanges(object)))\n      mcols(out) <- res\n    } else {\n      out <- rowRanges(object)\n      mcols(out) <- res\n    }\n  }\n\n  # code to save certain columns of mcols(rowRanges) / rowData\n  if (!is.null(saveCols)) {\n    mcols2Save <- mcols(object)[,saveCols,drop=FALSE]\n    if (format == "DataFrame") {\n      out <- cbind(out, mcols2Save)\n    } else {\n      mcols(out) <- cbind(mcols(out), mcols2Save)\n    }\n  }\n\n  out\n}\n\n\ncontrastAllZeroCharacter <- function(object, contrastFactor,\n                                     contrastNumLevel, contrastDenomLevel) {\n  cts <- counts(object)\n  f <- colData(object)[[contrastFactor]]\n  cts.sub <- cts[ , f %in% c(contrastNumLevel, contrastDenomLevel), drop=FALSE ]\n  rowSums( cts.sub == 0 ) == ncol(cts.sub)\n}\n\ncontrastAllZeroNumeric <- function(object, contrast) {\n  if (is.null(attr(object,"modelMatrix"))) {\n    stop("was expecting a model matrix stored as an attribute of the DESeqDataSet")\n  }\n  modelMatrix <- attr(object, "modelMatrix")\n  # note: this extra leg-work to zero out LFC, lfcSE, and set p-value to 1\n  # for contrasts comparing groups where both groups have all zeros.\n\n  # it is only implemented for the case in which we can identify\n  # the relevant samples by multiplying the model matrix\n  # with a vector where the non-zero elements of the numeric contrast\n  # are replaced with 1.\n\n  # so, this code will not zero out in the case of standard model matrices\n  # where the user supplies a numeric contrast that pulls out a single column\n  # of the model matrix, for example.\n  \n  if (all(contrast >= 0) | all(contrast <= 0)) {\n    return( rep(FALSE, nrow(object)) )\n  }\n  \n  contrastBinary <- ifelse(contrast == 0, 0, 1)\n  whichSamples <- ifelse(modelMatrix %*% contrastBinary == 0, 0, 1)\n  zeroTest <- counts(object) %*% whichSamples\n  zeroTest == 0\n}\n'