b'{-# LANGUAGE BangPatterns #-}\n{-# LANGUAGE GADTs #-}\n{-# LANGUAGE LambdaCase #-}\n\nmodule Main where\n\nimport Control.Concurrent.MVar (newEmptyMVar, putMVar)\nimport qualified Control.Monad.Trans.Crtn.Driver as D (driver)\nimport Control.Monad.Trans.Crtn.Object (Arg (..))\nimport Control.Monad.Trans.Reader (ReaderT (..))\nimport Data.Sequence (empty, singleton)\nimport Hoodle.Web.Default (nextevent, sysevent)\nimport Hoodle.Web.Erase (erasingMode)\nimport Hoodle.Web.Handler (setupCallback)\nimport Hoodle.Web.Pen (drawingMode)\nimport Hoodle.Web.Select (lassoMode)\nimport Hoodle.Web.Type.Coroutine\n  ( EventVar,\n    MainCoroutine,\n    MainObj,\n    MainOp (DoEvent),\n    simplelogger,\n    world,\n  )\nimport Hoodle.Web.Type.Event (AllEvent (..), UserEvent (..))\n\nguiProcess :: AllEvent -> MainCoroutine ()\nguiProcess (SysEv sev) = sysevent sev >> nextevent >>= penReady\nguiProcess (UsrEv uev) = penReady uev\n\npenReady :: UserEvent -> MainCoroutine ()\npenReady ev = do\n  case ev of\n    PointerDown (cx, cy) ->\n      drawingMode (singleton (cx, cy))\n    ToEraserMode -> nextevent >>= eraserReady\n    ToSelectMode -> nextevent >>= selectReady\n    _ -> pure ()\n  nextevent >>= penReady\n\neraserReady :: UserEvent -> MainCoroutine ()\neraserReady ev = do\n  case ev of\n    ToPenMode -> nextevent >>= penReady\n    ToSelectMode -> nextevent >>= selectReady\n    PointerDown (cx0, cy0) -> erasingMode [] (singleton (cx0, cy0))\n    _ -> pure ()\n  nextevent >>= eraserReady\n\nselectReady :: UserEvent -> MainCoroutine ()\nselectReady ev = do\n  case ev of\n    ToPenMode -> nextevent >>= penReady\n    ToEraserMode -> nextevent >>= eraserReady\n    PointerDown (cx0, cy0) -> lassoMode empty (singleton (cx0, cy0))\n    _ -> pure ()\n  nextevent >>= selectReady\n\ninitmc :: MainObj ()\ninitmc = ReaderT $ (\\(Arg DoEvent ev) -> guiProcess ev)\n\nmain :: IO ()\nmain = do\n  evar <- newEmptyMVar :: IO EventVar\n  xstate <- setupCallback evar\n  putMVar evar . Just $ D.driver simplelogger (world xstate initmc)\n'