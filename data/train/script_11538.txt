b'{-# LANGUAGE NoImplicitPrelude #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n{-# LANGUAGE InstanceSigs #-}\n{-# LANGUAGE RebindableSyntax #-}\n\nmodule Course.Applicative where\n\nimport Course.Core\nimport Course.ExactlyOne\nimport Course.Functor\nimport Course.List\nimport Course.Optional\nimport qualified Prelude as P(fmap, return, (>>=))\n\n-- | All instances of the `Applicative` type-class must satisfy three laws.\n-- These laws are not checked by the compiler. These laws are given as:\n--\n-- * The law of associative composition\n--   `\xe2\x88\x80a b c. ((.) <$> a <*> b <*> c) \xe2\x89\x85 (a <*> (b <*> c))`\n--\n-- * The law of identity\n--   `\xe2\x88\x80x. pure id <*> x \xe2\x89\x85 x`\n--\n-- * The law of homomorphism\n--   `\xe2\x88\x80f x. pure f <*> pure x \xe2\x89\x85 pure (f x)`\n--\n-- * The law of composition\n--   `\xe2\x88\x80u v w. pure (.) <*> u <*> v <*> w \xe2\x89\x85 u <*> (v <*> w)`\n\nclass Functor f => Applicative f where\n  pure ::\n    a -> f a\n  (<*>) ::\n    f (a -> b)\n    -> f a\n    -> f b\n\ninfixl 4 <*>\n\n-- | Insert into ExactlyOne.\n--\n-- prop> \\x -> pure x == ExactlyOne x\n--\n-- >>> ExactlyOne (+10) <*> ExactlyOne 8\n-- ExactlyOne 18\ninstance Applicative ExactlyOne where\n  pure ::\n    a\n    -> ExactlyOne a\n  pure =\n    error "todo: Course.Applicative pure#instance ExactlyOne"\n  (<*>) :: \n    ExactlyOne (a -> b)\n    -> ExactlyOne a\n    -> ExactlyOne b\n  (<*>) =\n    error "todo: Course.Applicative (<*>)#instance ExactlyOne"\n\n-- | Insert into a List.\n--\n-- prop> \\x -> pure x == x :. Nil\n--\n-- >>> (+1) :. (*2) :. Nil <*> 1 :. 2 :. 3 :. Nil\n-- [2,3,4,2,4,6]\ninstance Applicative List where\n  pure ::\n    a\n    -> List a\n  pure =\n    error "todo: Course.Applicative pure#instance List"\n  (<*>) ::\n    List (a -> b)\n    -> List a\n    -> List b\n  (<*>) =\n    error "todo: Course.Apply (<*>)#instance List"\n\n-- | Insert into an Optional.\n--\n-- prop> \\x -> pure x == Full x\n--\n-- >>> Full (+8) <*> Full 7\n-- Full 15\n--\n-- >>> Empty <*> Full 7\n-- Empty\n--\n-- >>> Full (+8) <*> Empty\n-- Empty\ninstance Applicative Optional where\n  pure ::\n    a\n    -> Optional a\n  pure =\n    error "todo: Course.Applicative pure#instance Optional"\n  (<*>) ::\n    Optional (a -> b)\n    -> Optional a\n    -> Optional b\n  (<*>) =\n    error "todo: Course.Apply (<*>)#instance Optional"\n\n-- | Insert into a constant function.\n--\n-- >>> ((+) <*> (+10)) 3\n-- 16\n--\n-- >>> ((+) <*> (+5)) 3\n-- 11\n--\n-- >>> ((+) <*> (+5)) 1\n-- 7\n--\n-- >>> ((*) <*> (+10)) 3\n-- 39\n--\n-- >>> ((*) <*> (+2)) 3\n-- 15\n--\n-- prop> \\x y -> pure x y == x\ninstance Applicative ((->) t) where\n  pure ::\n    a\n    -> ((->) t a)\n  pure =\n    error "todo: Course.Applicative pure#((->) t)"\n  (<*>) ::\n    ((->) t (a -> b))\n    -> ((->) t a)\n    -> ((->) t b)\n  (<*>) =\n    error "todo: Course.Apply (<*>)#instance ((->) t)"\n\n\n-- | Apply a binary function in the environment.\n--\n-- >>> lift2 (+) (ExactlyOne 7) (ExactlyOne 8)\n-- ExactlyOne 15\n--\n-- >>> lift2 (+) (1 :. 2 :. 3 :. Nil) (4 :. 5 :. Nil)\n-- [5,6,6,7,7,8]\n--\n-- >>> lift2 (+) (Full 7) (Full 8)\n-- Full 15\n--\n-- >>> lift2 (+) (Full 7) Empty\n-- Empty\n--\n-- >>> lift2 (+) Empty (Full 8)\n-- Empty\n--\n-- >>> lift2 (+) length sum (listh [4,5,6])\n-- 18\nlift2 ::\n  Applicative f =>\n  (a -> b -> c)\n  -> f a\n  -> f b\n  -> f c\nlift2 =\n  error "todo: Course.Applicative#lift2"\n\n-- | Apply a ternary function in the environment.\n-- /can be written using `lift2` and `(<*>)`./\n--\n-- >>> lift3 (\\a b c -> a + b + c) (ExactlyOne 7) (ExactlyOne 8) (ExactlyOne 9)\n-- ExactlyOne 24\n--\n-- >>> lift3 (\\a b c -> a + b + c) (1 :. 2 :. 3 :. Nil) (4 :. 5 :. Nil) (6 :. 7 :. 8 :. Nil)\n-- [11,12,13,12,13,14,12,13,14,13,14,15,13,14,15,14,15,16]\n--\n-- >>> lift3 (\\a b c -> a + b + c) (Full 7) (Full 8) (Full 9)\n-- Full 24\n--\n-- >>> lift3 (\\a b c -> a + b + c) (Full 7) (Full 8) Empty\n-- Empty\n--\n-- >>> lift3 (\\a b c -> a + b + c) Empty (Full 8) (Full 9)\n-- Empty\n--\n-- >>> lift3 (\\a b c -> a + b + c) Empty Empty (Full 9)\n-- Empty\n--\n-- >>> lift3 (\\a b c -> a + b + c) length sum product (listh [4,5,6])\n-- 138\nlift3 ::\n  Applicative f =>\n  (a -> b -> c -> d)\n  -> f a\n  -> f b\n  -> f c\n  -> f d\nlift3 =\n  error "todo: Course.Applicative#lift3"\n\n-- | Apply a quaternary function in the environment.\n-- /can be written using `lift3` and `(<*>)`./\n--\n-- >>> lift4 (\\a b c d -> a + b + c + d) (ExactlyOne 7) (ExactlyOne 8) (ExactlyOne 9) (ExactlyOne 10)\n-- ExactlyOne 34\n--\n-- >>> lift4 (\\a b c d -> a + b + c + d) (1 :. 2 :. 3 :. Nil) (4 :. 5 :. Nil) (6 :. 7 :. 8 :. Nil) (9 :. 10 :. Nil)\n-- [20,21,21,22,22,23,21,22,22,23,23,24,21,22,22,23,23,24,22,23,23,24,24,25,22,23,23,24,24,25,23,24,24,25,25,26]\n--\n-- >>> lift4 (\\a b c d -> a + b + c + d) (Full 7) (Full 8) (Full 9) (Full 10)\n-- Full 34\n--\n-- >>> lift4 (\\a b c d -> a + b + c + d) (Full 7) (Full 8) Empty  (Full 10)\n-- Empty\n--\n-- >>> lift4 (\\a b c d -> a + b + c + d) Empty (Full 8) (Full 9) (Full 10)\n-- Empty\n--\n-- >>> lift4 (\\a b c d -> a + b + c + d) Empty Empty (Full 9) (Full 10)\n-- Empty\n--\n-- >>> lift4 (\\a b c d -> a + b + c + d) length sum product (sum . filter even) (listh [4,5,6])\n-- 148\nlift4 ::\n  Applicative f =>\n  (a -> b -> c -> d -> e)\n  -> f a\n  -> f b\n  -> f c\n  -> f d\n  -> f e\nlift4 =\n  error "todo: Course.Applicative#lift4"\n\n-- | Apply a nullary function in the environment.\nlift0 ::\n  Applicative f =>\n  a\n  -> f a\nlift0 =\n  error "todo: Course.Applicative#lift0"\n\n-- | Apply a unary function in the environment.\n-- /can be written using `lift0` and `(<*>)`./\n--\n-- >>> lift1 (+1) (ExactlyOne 2)\n-- ExactlyOne 3\n--\n-- >>> lift1 (+1) Nil\n-- []\n--\n-- >>> lift1 (+1) (1 :. 2 :. 3 :. Nil)\n-- [2,3,4]\nlift1 ::\n  Applicative f =>\n  (a -> b)\n  -> f a\n  -> f b\nlift1 =\n  error "todo: Course.Applicative#lift1"\n\n-- | Apply, discarding the value of the first argument.\n-- Pronounced, right apply.\n--\n-- >>> (1 :. 2 :. 3 :. Nil) *> (4 :. 5 :. 6 :. Nil)\n-- [4,5,6,4,5,6,4,5,6]\n--\n-- >>> (1 :. 2 :. Nil) *> (4 :. 5 :. 6 :. Nil)\n-- [4,5,6,4,5,6]\n--\n-- >>> (1 :. 2 :. 3 :. Nil) *> (4 :. 5 :. Nil)\n-- [4,5,4,5,4,5]\n--\n-- >>> Full 7 *> Full 8\n-- Full 8\n--\n-- prop> \\a b c x y z -> (a :. b :. c :. Nil) *> (x :. y :. z :. Nil) == (x :. y :. z :. x :. y :. z :. x :. y :. z :. Nil)\n--\n-- prop> \\x y -> Full x *> Full y == Full y\n(*>) ::\n  Applicative f =>\n  f a\n  -> f b\n  -> f b\n(*>) =\n  error "todo: Course.Applicative#(*>)"\n\n-- | Apply, discarding the value of the second argument.\n-- Pronounced, left apply.\n--\n-- >>> (1 :. 2 :. 3 :. Nil) <* (4 :. 5 :. 6 :. Nil)\n-- [1,1,1,2,2,2,3,3,3]\n--\n-- >>> (1 :. 2 :. Nil) <* (4 :. 5 :. 6 :. Nil)\n-- [1,1,1,2,2,2]\n--\n-- >>> (1 :. 2 :. 3 :. Nil) <* (4 :. 5 :. Nil)\n-- [1,1,2,2,3,3]\n--\n-- >>> Full 7 <* Full 8\n-- Full 7\n--\n-- prop> \\x y z a b c -> (x :. y :. z :. Nil) <* (a :. b :. c :. Nil) == (x :. x :. x :. y :. y :. y :. z :. z :. z :. Nil)\n--\n-- prop> \\x y -> Full x <* Full y == Full x\n(<*) ::\n  Applicative f =>\n  f b\n  -> f a\n  -> f b\n(<*) =\n  error "todo: Course.Applicative#(<*)"\n\n-- | Sequences a list of structures to a structure of list.\n--\n-- >>> sequence (ExactlyOne 7 :. ExactlyOne 8 :. ExactlyOne 9 :. Nil)\n-- ExactlyOne [7,8,9]\n--\n-- >>> sequence ((1 :. 2 :. 3 :. Nil) :. (1 :. 2 :. Nil) :. Nil)\n-- [[1,1],[1,2],[2,1],[2,2],[3,1],[3,2]]\n--\n-- >>> sequence (Full 7 :. Empty :. Nil)\n-- Empty\n--\n-- >>> sequence (Full 7 :. Full 8 :. Nil)\n-- Full [7,8]\n--\n-- >>> sequence ((*10) :. (+2) :. Nil) 6\n-- [60,8]\nsequence ::\n  Applicative f =>\n  List (f a)\n  -> f (List a)\nsequence =\n  error "todo: Course.Applicative#sequence"\n\n-- | Replicate an effect a given number of times.\n--\n-- >>> replicateA 4 (ExactlyOne "hi")\n-- ExactlyOne ["hi","hi","hi","hi"]\n--\n-- >>> replicateA 4 (Full "hi")\n-- Full ["hi","hi","hi","hi"]\n--\n-- >>> replicateA 4 Empty\n-- Empty\n--\n-- >>> replicateA 4 (*2) 5\n-- [10,10,10,10]\n--\n-- >>> replicateA 3 (\'a\' :. \'b\' :. \'c\' :. Nil)\n-- ["aaa","aab","aac","aba","abb","abc","aca","acb","acc","baa","bab","bac","bba","bbb","bbc","bca","bcb","bcc","caa","cab","cac","cba","cbb","cbc","cca","ccb","ccc"]\nreplicateA ::\n  Applicative f =>\n  Int\n  -> f a\n  -> f (List a)\nreplicateA =\n  error "todo: Course.Applicative#replicateA"\n\n-- | Filter a list with a predicate that produces an effect.\n--\n-- >>> filtering (ExactlyOne . even) (4 :. 5 :. 6 :. Nil)\n-- ExactlyOne [4,6]\n--\n-- >>> filtering (\\a -> if a > 13 then Empty else Full (a <= 7)) (4 :. 5 :. 6 :. Nil)\n-- Full [4,5,6]\n--\n-- >>> filtering (\\a -> if a > 13 then Empty else Full (a <= 7)) (4 :. 5 :. 6 :. 7 :. 8 :. 9 :. Nil)\n-- Full [4,5,6,7]\n--\n-- >>> filtering (\\a -> if a > 13 then Empty else Full (a <= 7)) (4 :. 5 :. 6 :. 13 :. 14 :. Nil)\n-- Empty\n--\n-- >>> filtering (>) (4 :. 5 :. 6 :. 7 :. 8 :. 9 :. 10 :. 11 :. 12 :. Nil) 8\n-- [9,10,11,12]\n--\n-- >>> filtering (const $ True :. True :.  Nil) (1 :. 2 :. 3 :. Nil)\n-- [[1,2,3],[1,2,3],[1,2,3],[1,2,3],[1,2,3],[1,2,3],[1,2,3],[1,2,3]]\n--\nfiltering ::\n  Applicative f =>\n  (a -> f Bool)\n  -> List a\n  -> f (List a)\nfiltering =\n  error "todo: Course.Applicative#filtering"\n\n-----------------------\n-- SUPPORT LIBRARIES --\n-----------------------\n\ninstance Applicative IO where\n  pure =\n    P.return\n  f <*> a =\n    f P.>>= \\f\' -> P.fmap f\' a\n\nreturn ::\n  Applicative f =>\n  a\n  -> f a\nreturn =\n  pure\n\nfail ::\n  Applicative f =>\n  Chars\n  -> f a\nfail =\n  error . hlist\n\n(>>) ::\n  Applicative f =>\n  f a\n  -> f b\n  -> f b\n(>>) =\n  (*>)\n'