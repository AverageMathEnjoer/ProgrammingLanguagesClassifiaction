b'{-# LANGUAGE OverloadedStrings #-}\n\nmodule Devices.System (getCPUUsage\n                      , getCPUUsageData\n                      , updateCPUUsage\n                      , setLanguageRu\n                      , setLanguageUs) where\n\nimport System.IO (hPutStr, hClose)\nimport System.Process.Typed\nimport Data.Int\nimport qualified Data.ByteString.Lazy.Char8 as L8\n\ncpuDataCommand = "grep -w cpu /proc/stat"\nsetLanguageRuCommand = "setxkbmap ru,us"\nsetLanguageUsCommand = "setxkbmap us,ru"\n\ntype CPUUsageData = (Int32, Int32, Int32)\n\ngetCPUUsage :: IO (Double, CPUUsageData)\ngetCPUUsage = do\n    (out, err) <- readProcess_ cpuDataCommand\n    let unpacked = L8.unpack out\n    let s = take (length unpacked - 1) unpacked\n    let _:as:_:bs:cs:_ = words s\n    let a = read as\n    let b = read bs\n    let c = read cs\n    let ret = fromIntegral (a + b) / fromIntegral (a + b + c)\n    return (ret, (a, b, c))\n\ngetCPUUsageData :: IO CPUUsageData\ngetCPUUsageData = do\n    (out, err) <- readProcess_ cpuDataCommand\n    let unpacked = L8.unpack out\n    let s = take (length unpacked - 1) unpacked\n    let _:a:_:b:c:_ = words s\n    return (read a, read b, read c)\n\nupdateCPUUsage :: CPUUsageData -> IO (Double, CPUUsageData)\nupdateCPUUsage (oldA, oldB, oldC) = do\n    (a, b, c) <- getCPUUsageData\n    let ret = fromIntegral (oldA + oldB - a - b) / fromIntegral (oldA + oldB + oldC - a - b - c)\n    return (ret, (a, b, c))\n\nsetLanguageRu :: IO ()\nsetLanguageRu = do\n    readProcess_ setLanguageRuCommand \n    return ()\nsetLanguageUs :: IO ()\nsetLanguageUs = do\n    readProcess_ setLanguageUsCommand \n    return ()'