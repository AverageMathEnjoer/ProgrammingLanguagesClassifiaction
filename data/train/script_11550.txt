b'{-# LANGUAGE CPP #-}\n{-# LANGUAGE BangPatterns #-}\n#if defined(__GLASGOW_HASKELL__)\n{-# LANGUAGE Trustworthy #-}\n#endif\n{-# OPTIONS_HADDOCK not-home #-}\n\n#include "containers.h"\n\n-----------------------------------------------------------------------------\n-- |\n-- Module      :  Data.Map.Strict.Internal\n-- Copyright   :  (c) Daan Leijen 2002\n--                (c) Andriy Palamarchuk 2008\n-- License     :  BSD-style\n-- Maintainer  :  libraries@haskell.org\n-- Portability :  portable\n--\n-- = WARNING\n--\n-- This module is considered __internal__.\n--\n-- The Package Versioning Policy __does not apply__.\n--\n-- The contents of this module may change __in any way whatsoever__\n-- and __without any warning__ between minor versions of this package.\n--\n-- Authors importing this module are expected to track development\n-- closely.\n--\n-- = Description\n--\n-- An efficient implementation of ordered maps from keys to values\n-- (dictionaries).\n--\n-- API of this module is strict in both the keys and the values.\n-- If you need value-lazy maps, use "Data.Map.Lazy" instead.\n-- The \'Map\' type is shared between the lazy and strict modules,\n-- meaning that the same \'Map\' value can be passed to functions in\n-- both modules (although that is rarely needed).\n--\n-- These modules are intended to be imported qualified, to avoid name\n-- clashes with Prelude functions, e.g.\n--\n-- >  import qualified Data.Map.Strict as Map\n--\n-- The implementation of \'Map\' is based on /size balanced/ binary trees (or\n-- trees of /bounded balance/) as described by:\n--\n--    * Stephen Adams, \\"/Efficient sets: a balancing act/\\",\n--     Journal of Functional Programming 3(4):553-562, October 1993,\n--     <http://www.swiss.ai.mit.edu/~adams/BB/>.\n--    * J. Nievergelt and E.M. Reingold,\n--      \\"/Binary search trees of bounded balance/\\",\n--      SIAM journal of computing 2(1), March 1973.\n--\n--  Bounds for \'union\', \'intersection\', and \'difference\' are as given\n--  by\n--\n--    * Guy Blelloch, Daniel Ferizovic, and Yihan Sun,\n--      \\"/Just Join for Parallel Ordered Sets/\\",\n--      <https://arxiv.org/abs/1602.02120v3>.\n--\n-- Note that the implementation is /left-biased/ -- the elements of a\n-- first argument are always preferred to the second, for example in\n-- \'union\' or \'insert\'.\n--\n-- /Warning/: The size of the map must not exceed @maxBound::Int@. Violation of\n-- this condition is not detected and if the size limit is exceeded, its\n-- behaviour is undefined.\n--\n-- Operation comments contain the operation time complexity in\n-- the Big-O notation (<http://en.wikipedia.org/wiki/Big_O_notation>).\n--\n-- Be aware that the \'Functor\', \'Traversable\' and \'Data.Data.Data\' instances\n-- are the same as for the "Data.Map.Lazy" module, so if they are used\n-- on strict maps, the resulting maps will be lazy.\n-----------------------------------------------------------------------------\n\n-- See the notes at the beginning of Data.Map.Internal.\n\nmodule Data.Map.Strict.Internal\n    (\n    -- * Strictness properties\n    -- $strictness\n\n    -- * Map type\n    Map(..)          -- instance Eq,Show,Read\n    , L.Size\n\n    -- * Operators\n    , (!), (!?), (\\\\)\n\n    -- * Query\n    , null\n    , size\n    , member\n    , notMember\n    , lookup\n    , findWithDefault\n    , lookupLT\n    , lookupGT\n    , lookupLE\n    , lookupGE\n\n    -- * Construction\n    , empty\n    , singleton\n\n    -- ** Insertion\n    , insert\n    , insertWith\n    , insertWithKey\n    , insertLookupWithKey\n\n    -- ** Delete\\/Update\n    , delete\n    , adjust\n    , adjustWithKey\n    , update\n    , updateWithKey\n    , updateLookupWithKey\n    , alter\n    , alterF\n\n    -- * Combine\n\n    -- ** Union\n    , union\n    , unionWith\n    , unionWithKey\n    , unions\n    , unionsWith\n\n    -- ** Difference\n    , difference\n    , differenceWith\n    , differenceWithKey\n\n    -- ** Intersection\n    , intersection\n    , intersectionWith\n    , intersectionWithKey\n\n    -- ** Disjoint\n    , disjoint\n\n    -- ** Compose\n    , compose\n\n    -- ** General combining function\n    , SimpleWhenMissing\n    , SimpleWhenMatched\n    , merge\n    , runWhenMatched\n    , runWhenMissing\n\n    -- *** @WhenMatched@ tactics\n    , zipWithMaybeMatched\n    , zipWithMatched\n\n    -- *** @WhenMissing@ tactics\n    , mapMaybeMissing\n    , dropMissing\n    , preserveMissing\n    , preserveMissing\'\n    , mapMissing\n    , filterMissing\n\n    -- ** Applicative general combining function\n    , WhenMissing (..)\n    , WhenMatched (..)\n    , mergeA\n\n    -- *** @WhenMatched@ tactics\n    -- | The tactics described for \'merge\' work for\n    -- \'mergeA\' as well. Furthermore, the following\n    -- are available.\n    , zipWithMaybeAMatched\n    , zipWithAMatched\n\n    -- *** @WhenMissing@ tactics\n    -- | The tactics described for \'merge\' work for\n    -- \'mergeA\' as well. Furthermore, the following\n    -- are available.\n    , traverseMaybeMissing\n    , traverseMissing\n    , filterAMissing\n\n    -- *** Covariant maps for tactics\n    , mapWhenMissing\n    , mapWhenMatched\n\n    -- ** Deprecated general combining function\n\n    , mergeWithKey\n\n    -- * Traversal\n    -- ** Map\n    , map\n    , mapWithKey\n    , traverseWithKey\n    , traverseMaybeWithKey\n    , mapAccum\n    , mapAccumWithKey\n    , mapAccumRWithKey\n    , mapKeys\n    , mapKeysWith\n    , mapKeysMonotonic\n\n    -- * Folds\n    , foldr\n    , foldl\n    , foldrWithKey\n    , foldlWithKey\n    , foldMapWithKey\n\n    -- ** Strict folds\n    , foldr\'\n    , foldl\'\n    , foldrWithKey\'\n    , foldlWithKey\'\n\n    -- * Conversion\n    , elems\n    , keys\n    , assocs\n    , keysSet\n    , argSet\n    , fromSet\n    , fromArgSet\n\n    -- ** Lists\n    , toList\n    , fromList\n    , fromListWith\n    , fromListWithKey\n\n    -- ** Ordered lists\n    , toAscList\n    , toDescList\n    , fromAscList\n    , fromAscListWith\n    , fromAscListWithKey\n    , fromDistinctAscList\n    , fromDescList\n    , fromDescListWith\n    , fromDescListWithKey\n    , fromDistinctDescList\n\n    -- * Filter\n    , filter\n    , filterWithKey\n    , restrictKeys\n    , withoutKeys\n    , partition\n    , partitionWithKey\n    , takeWhileAntitone\n    , dropWhileAntitone\n    , spanAntitone\n\n    , mapMaybe\n    , mapMaybeWithKey\n    , mapEither\n    , mapEitherWithKey\n\n    , split\n    , splitLookup\n    , splitRoot\n\n    -- * Submap\n    , isSubmapOf, isSubmapOfBy\n    , isProperSubmapOf, isProperSubmapOfBy\n\n    -- * Indexed\n    , lookupIndex\n    , findIndex\n    , elemAt\n    , updateAt\n    , deleteAt\n    , take\n    , drop\n    , splitAt\n\n    -- * Min\\/Max\n    , lookupMin\n    , lookupMax\n    , findMin\n    , findMax\n    , deleteMin\n    , deleteMax\n    , deleteFindMin\n    , deleteFindMax\n    , updateMin\n    , updateMax\n    , updateMinWithKey\n    , updateMaxWithKey\n    , minView\n    , maxView\n    , minViewWithKey\n    , maxViewWithKey\n\n    -- * Debugging\n#ifdef __GLASGOW_HASKELL__\n    , showTree\n    , showTreeWith\n#endif\n    , valid\n    ) where\n\nimport Prelude hiding (lookup,map,filter,foldr,foldl,null,take,drop,splitAt)\n\nimport Data.Map.Internal\n  ( Map (..)\n  , AreWeStrict (..)\n  , WhenMissing (..)\n  , WhenMatched (..)\n  , runWhenMatched\n  , runWhenMissing\n  , SimpleWhenMissing\n  , SimpleWhenMatched\n  , preserveMissing\n  , preserveMissing\'\n  , dropMissing\n  , filterMissing\n  , filterAMissing\n  , merge\n  , mergeA\n  , (!)\n  , (!?)\n  , (\\\\)\n  , argSet\n  , assocs\n  , atKeyImpl\n  , atKeyPlain\n  , balance\n  , balanceL\n  , balanceR\n  , compose\n  , elemAt\n  , elems\n  , empty\n  , delete\n  , deleteAt\n  , deleteFindMax\n  , deleteFindMin\n  , deleteMin\n  , deleteMax\n  , difference\n  , disjoint\n  , drop\n  , dropWhileAntitone\n  , filter\n  , filterWithKey\n  , findIndex\n  , findMax\n  , findMin\n  , foldl\n  , foldl\'\n  , foldlWithKey\n  , foldlWithKey\'\n  , foldMapWithKey\n  , foldr\n  , foldr\'\n  , foldrWithKey\n  , foldrWithKey\'\n  , glue\n  , insertMax\n  , intersection\n  , isProperSubmapOf\n  , isProperSubmapOfBy\n  , isSubmapOf\n  , isSubmapOfBy\n  , keys\n  , keysSet\n  , link\n  , lookup\n  , lookupGE\n  , lookupGT\n  , lookupIndex\n  , lookupLE\n  , lookupLT\n  , lookupMin\n  , lookupMax\n  , mapKeys\n  , mapKeysMonotonic\n  , maxView\n  , maxViewWithKey\n  , member\n  , link2\n  , minView\n  , minViewWithKey\n  , notMember\n  , null\n  , partition\n  , partitionWithKey\n  , restrictKeys\n  , size\n  , spanAntitone\n  , split\n  , splitAt\n  , splitLookup\n  , splitRoot\n  , take\n  , takeWhileAntitone\n  , toList\n  , toAscList\n  , toDescList\n  , union\n  , unions\n  , withoutKeys )\n\n#if defined(__GLASGOW_HASKELL__)\nimport Data.Map.Internal.DeprecatedShowTree (showTree, showTreeWith)\n#endif\nimport Data.Map.Internal.Debug (valid)\n\nimport Control.Applicative (Const (..), liftA3)\nimport Data.Semigroup (Arg (..))\nimport qualified Data.Set.Internal as Set\nimport qualified Data.Map.Internal as L\nimport Utils.Containers.Internal.StrictPair\n\nimport Data.Bits (shiftL, shiftR)\n#ifdef __GLASGOW_HASKELL__\nimport Data.Coerce\n#endif\n\n#ifdef __GLASGOW_HASKELL__\nimport Data.Functor.Identity (Identity (..))\n#endif\n\nimport qualified Data.Foldable as Foldable\n\n-- $strictness\n--\n-- This module satisfies the following strictness properties:\n--\n-- 1. Key arguments are evaluated to WHNF;\n--\n-- 2. Keys and values are evaluated to WHNF before they are stored in\n--    the map.\n--\n-- Here\'s an example illustrating the first property:\n--\n-- > delete undefined m  ==  undefined\n--\n-- Here are some examples that illustrate the second property:\n--\n-- > map (\\ v -> undefined) m  ==  undefined      -- m is not empty\n-- > mapKeys (\\ k -> undefined) m  ==  undefined  -- m is not empty\n\n-- [Note: Pointer equality for sharing]\n--\n-- We use pointer equality to enhance sharing between the arguments\n-- of some functions and their results. Notably, we use it\n-- for insert, delete, union, intersection, and difference. We do\n-- *not* use it for functions, like insertWith, unionWithKey,\n-- intersectionWith, etc., that allow the user to modify the elements.\n-- While we *could* do so, we would only get sharing under fairly\n-- narrow conditions and at a relatively high cost. It does not seem\n-- worth the price.\n\n{--------------------------------------------------------------------\n  Query\n--------------------------------------------------------------------}\n\n-- | \\(O(\\log n)\\). The expression @(\'findWithDefault\' def k map)@ returns\n-- the value at key @k@ or returns default value @def@\n-- when the key is not in the map.\n--\n-- > findWithDefault \'x\' 1 (fromList [(5,\'a\'), (3,\'b\')]) == \'x\'\n-- > findWithDefault \'x\' 5 (fromList [(5,\'a\'), (3,\'b\')]) == \'a\'\n\n-- See Map.Internal.Note: Local \'go\' functions and capturing\nfindWithDefault :: Ord k => a -> k -> Map k a -> a\nfindWithDefault def k = k `seq` go\n  where\n    go Tip = def\n    go (Bin _ kx x l r) = case compare k kx of\n      LT -> go l\n      GT -> go r\n      EQ -> x\n#if __GLASGOW_HASKELL__\n{-# INLINABLE findWithDefault #-}\n#else\n{-# INLINE findWithDefault #-}\n#endif\n\n{--------------------------------------------------------------------\n  Construction\n--------------------------------------------------------------------}\n\n-- | \\(O(1)\\). A map with a single element.\n--\n-- > singleton 1 \'a\'        == fromList [(1, \'a\')]\n-- > size (singleton 1 \'a\') == 1\n\nsingleton :: k -> a -> Map k a\nsingleton k x = x `seq` Bin 1 k x Tip Tip\n{-# INLINE singleton #-}\n\n{--------------------------------------------------------------------\n  Insertion\n--------------------------------------------------------------------}\n-- | \\(O(\\log n)\\). Insert a new key and value in the map.\n-- If the key is already present in the map, the associated value is\n-- replaced with the supplied value. \'insert\' is equivalent to\n-- @\'insertWith\' \'const\'@.\n--\n-- > insert 5 \'x\' (fromList [(5,\'a\'), (3,\'b\')]) == fromList [(3, \'b\'), (5, \'x\')]\n-- > insert 7 \'x\' (fromList [(5,\'a\'), (3,\'b\')]) == fromList [(3, \'b\'), (5, \'a\'), (7, \'x\')]\n-- > insert 5 \'x\' empty                         == singleton 5 \'x\'\n\n-- See Map.Internal.Note: Type of local \'go\' function\ninsert :: Ord k => k -> a -> Map k a -> Map k a\ninsert = go\n  where\n    go :: Ord k => k -> a -> Map k a -> Map k a\n    go !kx !x Tip = singleton kx x\n    go kx x (Bin sz ky y l r) =\n        case compare kx ky of\n            LT -> balanceL ky y (go kx x l) r\n            GT -> balanceR ky y l (go kx x r)\n            EQ -> Bin sz kx x l r\n#if __GLASGOW_HASKELL__\n{-# INLINABLE insert #-}\n#else\n{-# INLINE insert #-}\n#endif\n\n-- | \\(O(\\log n)\\). Insert with a function, combining new value and old value.\n-- @\'insertWith\' f key value mp@\n-- will insert the pair (key, value) into @mp@ if key does\n-- not exist in the map. If the key does exist, the function will\n-- insert the pair @(key, f new_value old_value)@.\n--\n-- > insertWith (++) 5 "xxx" (fromList [(5,"a"), (3,"b")]) == fromList [(3, "b"), (5, "xxxa")]\n-- > insertWith (++) 7 "xxx" (fromList [(5,"a"), (3,"b")]) == fromList [(3, "b"), (5, "a"), (7, "xxx")]\n-- > insertWith (++) 5 "xxx" empty                         == singleton 5 "xxx"\n\ninsertWith :: Ord k => (a -> a -> a) -> k -> a -> Map k a -> Map k a\ninsertWith = go\n  where\n    go :: Ord k => (a -> a -> a) -> k -> a -> Map k a -> Map k a\n    go _ !kx x Tip = singleton kx x\n    go f !kx x (Bin sy ky y l r) =\n        case compare kx ky of\n            LT -> balanceL ky y (go f kx x l) r\n            GT -> balanceR ky y l (go f kx x r)\n            EQ -> let !y\' = f x y in Bin sy kx y\' l r\n#if __GLASGOW_HASKELL__\n{-# INLINABLE insertWith #-}\n#else\n{-# INLINE insertWith #-}\n#endif\n\ninsertWithR :: Ord k => (a -> a -> a) -> k -> a -> Map k a -> Map k a\ninsertWithR = go\n  where\n    go :: Ord k => (a -> a -> a) -> k -> a -> Map k a -> Map k a\n    go _ !kx x Tip = singleton kx x\n    go f !kx x (Bin sy ky y l r) =\n        case compare kx ky of\n            LT -> balanceL ky y (go f kx x l) r\n            GT -> balanceR ky y l (go f kx x r)\n            EQ -> let !y\' = f y x in Bin sy ky y\' l r\n#if __GLASGOW_HASKELL__\n{-# INLINABLE insertWithR #-}\n#else\n{-# INLINE insertWithR #-}\n#endif\n\n-- | \\(O(\\log n)\\). Insert with a function, combining key, new value and old value.\n-- @\'insertWithKey\' f key value mp@\n-- will insert the pair (key, value) into @mp@ if key does\n-- not exist in the map. If the key does exist, the function will\n-- insert the pair @(key,f key new_value old_value)@.\n-- Note that the key passed to f is the same key passed to \'insertWithKey\'.\n--\n-- > let f key new_value old_value = (show key) ++ ":" ++ new_value ++ "|" ++ old_value\n-- > insertWithKey f 5 "xxx" (fromList [(5,"a"), (3,"b")]) == fromList [(3, "b"), (5, "5:xxx|a")]\n-- > insertWithKey f 7 "xxx" (fromList [(5,"a"), (3,"b")]) == fromList [(3, "b"), (5, "a"), (7, "xxx")]\n-- > insertWithKey f 5 "xxx" empty                         == singleton 5 "xxx"\n\n-- See Map.Internal.Note: Type of local \'go\' function\ninsertWithKey :: Ord k => (k -> a -> a -> a) -> k -> a -> Map k a -> Map k a\ninsertWithKey = go\n  where\n    go :: Ord k => (k -> a -> a -> a) -> k -> a -> Map k a -> Map k a\n    -- Forcing `kx` may look redundant, but it\'s possible `compare` will\n    -- be lazy.\n    go _ !kx x Tip = singleton kx x\n    go f kx x (Bin sy ky y l r) =\n        case compare kx ky of\n            LT -> balanceL ky y (go f kx x l) r\n            GT -> balanceR ky y l (go f kx x r)\n            EQ -> let !x\' = f kx x y\n                  in Bin sy kx x\' l r\n#if __GLASGOW_HASKELL__\n{-# INLINABLE insertWithKey #-}\n#else\n{-# INLINE insertWithKey #-}\n#endif\n\ninsertWithKeyR :: Ord k => (k -> a -> a -> a) -> k -> a -> Map k a -> Map k a\ninsertWithKeyR = go\n  where\n    go :: Ord k => (k -> a -> a -> a) -> k -> a -> Map k a -> Map k a\n    -- Forcing `kx` may look redundant, but it\'s possible `compare` will\n    -- be lazy.\n    go _ !kx x Tip = singleton kx x\n    go f kx x (Bin sy ky y l r) =\n        case compare kx ky of\n            LT -> balanceL ky y (go f kx x l) r\n            GT -> balanceR ky y l (go f kx x r)\n            EQ -> let !y\' = f ky y x\n                  in Bin sy ky y\' l r\n#if __GLASGOW_HASKELL__\n{-# INLINABLE insertWithKeyR #-}\n#else\n{-# INLINE insertWithKeyR #-}\n#endif\n\n-- | \\(O(\\log n)\\). Combines insert operation with old value retrieval.\n-- The expression (@\'insertLookupWithKey\' f k x map@)\n-- is a pair where the first element is equal to (@\'lookup\' k map@)\n-- and the second element equal to (@\'insertWithKey\' f k x map@).\n--\n-- > let f key new_value old_value = (show key) ++ ":" ++ new_value ++ "|" ++ old_value\n-- > insertLookupWithKey f 5 "xxx" (fromList [(5,"a"), (3,"b")]) == (Just "a", fromList [(3, "b"), (5, "5:xxx|a")])\n-- > insertLookupWithKey f 7 "xxx" (fromList [(5,"a"), (3,"b")]) == (Nothing,  fromList [(3, "b"), (5, "a"), (7, "xxx")])\n-- > insertLookupWithKey f 5 "xxx" empty                         == (Nothing,  singleton 5 "xxx")\n--\n-- This is how to define @insertLookup@ using @insertLookupWithKey@:\n--\n-- > let insertLookup kx x t = insertLookupWithKey (\\_ a _ -> a) kx x t\n-- > insertLookup 5 "x" (fromList [(5,"a"), (3,"b")]) == (Just "a", fromList [(3, "b"), (5, "x")])\n-- > insertLookup 7 "x" (fromList [(5,"a"), (3,"b")]) == (Nothing,  fromList [(3, "b"), (5, "a"), (7, "x")])\n\n-- See Map.Internal.Note: Type of local \'go\' function\ninsertLookupWithKey :: Ord k => (k -> a -> a -> a) -> k -> a -> Map k a\n                    -> (Maybe a, Map k a)\ninsertLookupWithKey f0 kx0 x0 t0 = toPair $ go f0 kx0 x0 t0\n  where\n    go :: Ord k => (k -> a -> a -> a) -> k -> a -> Map k a -> StrictPair (Maybe a) (Map k a)\n    go _ !kx x Tip = Nothing :*: singleton kx x\n    go f kx x (Bin sy ky y l r) =\n        case compare kx ky of\n            LT -> let (found :*: l\') = go f kx x l\n                  in found :*: balanceL ky y l\' r\n            GT -> let (found :*: r\') = go f kx x r\n                  in found :*: balanceR ky y l r\'\n            EQ -> let x\' = f kx x y\n                  in x\' `seq` (Just y :*: Bin sy kx x\' l r)\n#if __GLASGOW_HASKELL__\n{-# INLINABLE insertLookupWithKey #-}\n#else\n{-# INLINE insertLookupWithKey #-}\n#endif\n\n{--------------------------------------------------------------------\n  Deletion\n--------------------------------------------------------------------}\n\n-- | \\(O(\\log n)\\). Update a value at a specific key with the result of the provided function.\n-- When the key is not\n-- a member of the map, the original map is returned.\n--\n-- > adjust ("new " ++) 5 (fromList [(5,"a"), (3,"b")]) == fromList [(3, "b"), (5, "new a")]\n-- > adjust ("new " ++) 7 (fromList [(5,"a"), (3,"b")]) == fromList [(3, "b"), (5, "a")]\n-- > adjust ("new " ++) 7 empty                         == empty\n\nadjust :: Ord k => (a -> a) -> k -> Map k a -> Map k a\nadjust f = adjustWithKey (\\_ x -> f x)\n#if __GLASGOW_HASKELL__\n{-# INLINABLE adjust #-}\n#else\n{-# INLINE adjust #-}\n#endif\n\n-- | \\(O(\\log n)\\). Adjust a value at a specific key. When the key is not\n-- a member of the map, the original map is returned.\n--\n-- > let f key x = (show key) ++ ":new " ++ x\n-- > adjustWithKey f 5 (fromList [(5,"a"), (3,"b")]) == fromList [(3, "b"), (5, "5:new a")]\n-- > adjustWithKey f 7 (fromList [(5,"a"), (3,"b")]) == fromList [(3, "b"), (5, "a")]\n-- > adjustWithKey f 7 empty                         == empty\n\nadjustWithKey :: Ord k => (k -> a -> a) -> k -> Map k a -> Map k a\nadjustWithKey = go\n  where\n    go :: Ord k => (k -> a -> a) -> k -> Map k a -> Map k a\n    go _ !_ Tip = Tip\n    go f k (Bin sx kx x l r) =\n        case compare k kx of\n           LT -> Bin sx kx x (go f k l) r\n           GT -> Bin sx kx x l (go f k r)\n           EQ -> Bin sx kx x\' l r\n             where !x\' = f kx x\n#if __GLASGOW_HASKELL__\n{-# INLINABLE adjustWithKey #-}\n#else\n{-# INLINE adjustWithKey #-}\n#endif\n\n-- | \\(O(\\log n)\\). The expression (@\'update\' f k map@) updates the value @x@\n-- at @k@ (if it is in the map). If (@f x@) is \'Nothing\', the element is\n-- deleted. If it is (@\'Just\' y@), the key @k@ is bound to the new value @y@.\n--\n-- > let f x = if x == "a" then Just "new a" else Nothing\n-- > update f 5 (fromList [(5,"a"), (3,"b")]) == fromList [(3, "b"), (5, "new a")]\n-- > update f 7 (fromList [(5,"a"), (3,"b")]) == fromList [(3, "b"), (5, "a")]\n-- > update f 3 (fromList [(5,"a"), (3,"b")]) == singleton 5 "a"\n\nupdate :: Ord k => (a -> Maybe a) -> k -> Map k a -> Map k a\nupdate f = updateWithKey (\\_ x -> f x)\n#if __GLASGOW_HASKELL__\n{-# INLINABLE update #-}\n#else\n{-# INLINE update #-}\n#endif\n\n-- | \\(O(\\log n)\\). The expression (@\'updateWithKey\' f k map@) updates the\n-- value @x@ at @k@ (if it is in the map). If (@f k x@) is \'Nothing\',\n-- the element is deleted. If it is (@\'Just\' y@), the key @k@ is bound\n-- to the new value @y@.\n--\n-- > let f k x = if x == "a" then Just ((show k) ++ ":new a") else Nothing\n-- > updateWithKey f 5 (fromList [(5,"a"), (3,"b")]) == fromList [(3, "b"), (5, "5:new a")]\n-- > updateWithKey f 7 (fromList [(5,"a"), (3,"b")]) == fromList [(3, "b"), (5, "a")]\n-- > updateWithKey f 3 (fromList [(5,"a"), (3,"b")]) == singleton 5 "a"\n\n-- See Map.Internal.Note: Type of local \'go\' function\nupdateWithKey :: Ord k => (k -> a -> Maybe a) -> k -> Map k a -> Map k a\nupdateWithKey = go\n  where\n    go :: Ord k => (k -> a -> Maybe a) -> k -> Map k a -> Map k a\n    go _ !_ Tip = Tip\n    go f k(Bin sx kx x l r) =\n        case compare k kx of\n           LT -> balanceR kx x (go f k l) r\n           GT -> balanceL kx x l (go f k r)\n           EQ -> case f kx x of\n                   Just x\' -> x\' `seq` Bin sx kx x\' l r\n                   Nothing -> glue l r\n#if __GLASGOW_HASKELL__\n{-# INLINABLE updateWithKey #-}\n#else\n{-# INLINE updateWithKey #-}\n#endif\n\n-- | \\(O(\\log n)\\). Lookup and update. See also \'updateWithKey\'.\n-- The function returns changed value, if it is updated.\n-- Returns the original key value if the map entry is deleted.\n--\n-- > let f k x = if x == "a" then Just ((show k) ++ ":new a") else Nothing\n-- > updateLookupWithKey f 5 (fromList [(5,"a"), (3,"b")]) == (Just "5:new a", fromList [(3, "b"), (5, "5:new a")])\n-- > updateLookupWithKey f 7 (fromList [(5,"a"), (3,"b")]) == (Nothing,  fromList [(3, "b"), (5, "a")])\n-- > updateLookupWithKey f 3 (fromList [(5,"a"), (3,"b")]) == (Just "b", singleton 5 "a")\n\n-- See Map.Internal.Note: Type of local \'go\' function\nupdateLookupWithKey :: Ord k => (k -> a -> Maybe a) -> k -> Map k a -> (Maybe a,Map k a)\nupdateLookupWithKey f0 k0 t0 = toPair $ go f0 k0 t0\n where\n   go :: Ord k => (k -> a -> Maybe a) -> k -> Map k a -> StrictPair (Maybe a) (Map k a)\n   go _ !_ Tip = (Nothing :*: Tip)\n   go f k (Bin sx kx x l r) =\n          case compare k kx of\n               LT -> let (found :*: l\') = go f k l\n                     in found :*: balanceR kx x l\' r\n               GT -> let (found :*: r\') = go f k r\n                     in found :*: balanceL kx x l r\'\n               EQ -> case f kx x of\n                       Just x\' -> x\' `seq` (Just x\' :*: Bin sx kx x\' l r)\n                       Nothing -> (Just x :*: glue l r)\n#if __GLASGOW_HASKELL__\n{-# INLINABLE updateLookupWithKey #-}\n#else\n{-# INLINE updateLookupWithKey #-}\n#endif\n\n-- | \\(O(\\log n)\\). The expression (@\'alter\' f k map@) alters the value @x@ at @k@, or absence thereof.\n-- \'alter\' can be used to insert, delete, or update a value in a \'Map\'.\n-- In short : @\'lookup\' k (\'alter\' f k m) = f (\'lookup\' k m)@.\n--\n-- > let f _ = Nothing\n-- > alter f 7 (fromList [(5,"a"), (3,"b")]) == fromList [(3, "b"), (5, "a")]\n-- > alter f 5 (fromList [(5,"a"), (3,"b")]) == singleton 3 "b"\n-- >\n-- > let f _ = Just "c"\n-- > alter f 7 (fromList [(5,"a"), (3,"b")]) == fromList [(3, "b"), (5, "a"), (7, "c")]\n-- > alter f 5 (fromList [(5,"a"), (3,"b")]) == fromList [(3, "b"), (5, "c")]\n--\n-- Note that @\'adjust\' = alter . fmap@.\n\n-- See Map.Internal.Note: Type of local \'go\' function\nalter :: Ord k => (Maybe a -> Maybe a) -> k -> Map k a -> Map k a\nalter = go\n  where\n    go :: Ord k => (Maybe a -> Maybe a) -> k -> Map k a -> Map k a\n    go f !k Tip = case f Nothing of\n               Nothing -> Tip\n               Just x  -> singleton k x\n\n    go f k (Bin sx kx x l r) = case compare k kx of\n               LT -> balance kx x (go f k l) r\n               GT -> balance kx x l (go f k r)\n               EQ -> case f (Just x) of\n                       Just x\' -> x\' `seq` Bin sx kx x\' l r\n                       Nothing -> glue l r\n#if __GLASGOW_HASKELL__\n{-# INLINABLE alter #-}\n#else\n{-# INLINE alter #-}\n#endif\n\n-- | \\(O(\\log n)\\). The expression (@\'alterF\' f k map@) alters the value @x@ at @k@, or absence thereof.\n-- \'alterF\' can be used to inspect, insert, delete, or update a value in a \'Map\'.\n-- In short: @\'lookup\' k \\<$\\> \'alterF\' f k m = f (\'lookup\' k m)@.\n--\n-- Example:\n--\n-- @\n-- interactiveAlter :: Int -> Map Int String -> IO (Map Int String)\n-- interactiveAlter k m = alterF f k m where\n--   f Nothing = do\n--      putStrLn $ show k ++\n--          " was not found in the map. Would you like to add it?"\n--      getUserResponse1 :: IO (Maybe String)\n--   f (Just old) = do\n--      putStrLn $ "The key is currently bound to " ++ show old ++\n--          ". Would you like to change or delete it?"\n--      getUserResponse2 :: IO (Maybe String)\n-- @\n--\n-- \'alterF\' is the most general operation for working with an individual\n-- key that may or may not be in a given map. When used with trivial\n-- functors like \'Identity\' and \'Const\', it is often slightly slower than\n-- more specialized combinators like \'lookup\' and \'insert\'. However, when\n-- the functor is non-trivial and key comparison is not particularly cheap,\n-- it is the fastest way.\n--\n-- Note on rewrite rules:\n--\n-- This module includes GHC rewrite rules to optimize \'alterF\' for\n-- the \'Const\' and \'Identity\' functors. In general, these rules\n-- improve performance. The sole exception is that when using\n-- \'Identity\', deleting a key that is already absent takes longer\n-- than it would without the rules. If you expect this to occur\n-- a very large fraction of the time, you might consider using a\n-- private copy of the \'Identity\' type.\n--\n-- Note: \'alterF\' is a flipped version of the @at@ combinator from\n-- @Control.Lens.At@.\n--\n-- @since 0.5.8\nalterF :: (Functor f, Ord k)\n       => (Maybe a -> f (Maybe a)) -> k -> Map k a -> f (Map k a)\nalterF f k m = atKeyImpl Strict k f m\n\n#ifndef __GLASGOW_HASKELL__\n{-# INLINE alterF #-}\n#else\n{-# INLINABLE [2] alterF #-}\n\n-- We can save a little time by recognizing the special case of\n-- `Control.Applicative.Const` and just doing a lookup.\n{-# RULES\n"alterF/Const" forall k (f :: Maybe a -> Const b (Maybe a)) . alterF f k = \\m -> Const . getConst . f $ lookup k m\n"alterF/Identity" forall k f . alterF f k = atKeyIdentity k f\n #-}\n\natKeyIdentity :: Ord k => k -> (Maybe a -> Identity (Maybe a)) -> Map k a -> Identity (Map k a)\natKeyIdentity k f t = Identity $ atKeyPlain Strict k (coerce f) t\n{-# INLINABLE atKeyIdentity #-}\n#endif\n\n{--------------------------------------------------------------------\n  Indexing\n--------------------------------------------------------------------}\n\n-- | \\(O(\\log n)\\). Update the element at /index/. Calls \'error\' when an\n-- invalid index is used.\n--\n-- > updateAt (\\ _ _ -> Just "x") 0    (fromList [(5,"a"), (3,"b")]) == fromList [(3, "x"), (5, "a")]\n-- > updateAt (\\ _ _ -> Just "x") 1    (fromList [(5,"a"), (3,"b")]) == fromList [(3, "b"), (5, "x")]\n-- > updateAt (\\ _ _ -> Just "x") 2    (fromList [(5,"a"), (3,"b")])    Error: index out of range\n-- > updateAt (\\ _ _ -> Just "x") (-1) (fromList [(5,"a"), (3,"b")])    Error: index out of range\n-- > updateAt (\\_ _  -> Nothing)  0    (fromList [(5,"a"), (3,"b")]) == singleton 5 "a"\n-- > updateAt (\\_ _  -> Nothing)  1    (fromList [(5,"a"), (3,"b")]) == singleton 3 "b"\n-- > updateAt (\\_ _  -> Nothing)  2    (fromList [(5,"a"), (3,"b")])    Error: index out of range\n-- > updateAt (\\_ _  -> Nothing)  (-1) (fromList [(5,"a"), (3,"b")])    Error: index out of range\n\nupdateAt :: (k -> a -> Maybe a) -> Int -> Map k a -> Map k a\nupdateAt f i t = i `seq`\n  case t of\n    Tip -> error "Map.updateAt: index out of range"\n    Bin sx kx x l r -> case compare i sizeL of\n      LT -> balanceR kx x (updateAt f i l) r\n      GT -> balanceL kx x l (updateAt f (i-sizeL-1) r)\n      EQ -> case f kx x of\n              Just x\' -> x\' `seq` Bin sx kx x\' l r\n              Nothing -> glue l r\n      where\n        sizeL = size l\n\n{--------------------------------------------------------------------\n  Minimal, Maximal\n--------------------------------------------------------------------}\n\n-- | \\(O(\\log n)\\). Update the value at the minimal key.\n--\n-- > updateMin (\\ a -> Just ("X" ++ a)) (fromList [(5,"a"), (3,"b")]) == fromList [(3, "Xb"), (5, "a")]\n-- > updateMin (\\ _ -> Nothing)         (fromList [(5,"a"), (3,"b")]) == singleton 5 "a"\n\nupdateMin :: (a -> Maybe a) -> Map k a -> Map k a\nupdateMin f m\n  = updateMinWithKey (\\_ x -> f x) m\n\n-- | \\(O(\\log n)\\). Update the value at the maximal key.\n--\n-- > updateMax (\\ a -> Just ("X" ++ a)) (fromList [(5,"a"), (3,"b")]) == fromList [(3, "b"), (5, "Xa")]\n-- > updateMax (\\ _ -> Nothing)         (fromList [(5,"a"), (3,"b")]) == singleton 3 "b"\n\nupdateMax :: (a -> Maybe a) -> Map k a -> Map k a\nupdateMax f m\n  = updateMaxWithKey (\\_ x -> f x) m\n\n\n-- | \\(O(\\log n)\\). Update the value at the minimal key.\n--\n-- > updateMinWithKey (\\ k a -> Just ((show k) ++ ":" ++ a)) (fromList [(5,"a"), (3,"b")]) == fromList [(3,"3:b"), (5,"a")]\n-- > updateMinWithKey (\\ _ _ -> Nothing)                     (fromList [(5,"a"), (3,"b")]) == singleton 5 "a"\n\nupdateMinWithKey :: (k -> a -> Maybe a) -> Map k a -> Map k a\nupdateMinWithKey _ Tip                 = Tip\nupdateMinWithKey f (Bin sx kx x Tip r) = case f kx x of\n                                           Nothing -> r\n                                           Just x\' -> x\' `seq` Bin sx kx x\' Tip r\nupdateMinWithKey f (Bin _ kx x l r)    = balanceR kx x (updateMinWithKey f l) r\n\n-- | \\(O(\\log n)\\). Update the value at the maximal key.\n--\n-- > updateMaxWithKey (\\ k a -> Just ((show k) ++ ":" ++ a)) (fromList [(5,"a"), (3,"b")]) == fromList [(3,"b"), (5,"5:a")]\n-- > updateMaxWithKey (\\ _ _ -> Nothing)                     (fromList [(5,"a"), (3,"b")]) == singleton 3 "b"\n\nupdateMaxWithKey :: (k -> a -> Maybe a) -> Map k a -> Map k a\nupdateMaxWithKey _ Tip                 = Tip\nupdateMaxWithKey f (Bin sx kx x l Tip) = case f kx x of\n                                           Nothing -> l\n                                           Just x\' -> x\' `seq` Bin sx kx x\' l Tip\nupdateMaxWithKey f (Bin _ kx x l r)    = balanceL kx x l (updateMaxWithKey f r)\n\n{--------------------------------------------------------------------\n  Union.\n--------------------------------------------------------------------}\n\n-- | The union of a list of maps, with a combining operation:\n--   (@\'unionsWith\' f == \'Prelude.foldl\' (\'unionWith\' f) \'empty\'@).\n--\n-- > unionsWith (++) [(fromList [(5, "a"), (3, "b")]), (fromList [(5, "A"), (7, "C")]), (fromList [(5, "A3"), (3, "B3")])]\n-- >     == fromList [(3, "bB3"), (5, "aAA3"), (7, "C")]\n\nunionsWith :: (Foldable f, Ord k) => (a->a->a) -> f (Map k a) -> Map k a\nunionsWith f ts\n  = Foldable.foldl\' (unionWith f) empty ts\n#if __GLASGOW_HASKELL__\n{-# INLINABLE unionsWith #-}\n#endif\n\n{--------------------------------------------------------------------\n  Union with a combining function\n--------------------------------------------------------------------}\n-- | \\(O\\bigl(m \\log\\bigl(\\frac{n+1}{m+1}\\bigr)\\bigr), \\; m \\leq n\\). Union with a combining function.\n--\n-- > unionWith (++) (fromList [(5, "a"), (3, "b")]) (fromList [(5, "A"), (7, "C")]) == fromList [(3, "b"), (5, "aA"), (7, "C")]\n\nunionWith :: Ord k => (a -> a -> a) -> Map k a -> Map k a -> Map k a\nunionWith _f t1 Tip = t1\nunionWith f t1 (Bin _ k x Tip Tip) = insertWithR f k x t1\nunionWith f (Bin _ k x Tip Tip) t2 = insertWith f k x t2\nunionWith _f Tip t2 = t2\nunionWith f (Bin _ k1 x1 l1 r1) t2 = case splitLookup k1 t2 of\n  (l2, mb, r2) -> link k1 x1\' (unionWith f l1 l2) (unionWith f r1 r2)\n    where !x1\' = maybe x1 (f x1) mb\n#if __GLASGOW_HASKELL__\n{-# INLINABLE unionWith #-}\n#endif\n\n-- | \\(O\\bigl(m \\log\\bigl(\\frac{n+1}{m+1}\\bigr)\\bigr), \\; m \\leq n\\).\n-- Union with a combining function.\n--\n-- > let f key left_value right_value = (show key) ++ ":" ++ left_value ++ "|" ++ right_value\n-- > unionWithKey f (fromList [(5, "a"), (3, "b")]) (fromList [(5, "A"), (7, "C")]) == fromList [(3, "b"), (5, "5:a|A"), (7, "C")]\n\nunionWithKey :: Ord k => (k -> a -> a -> a) -> Map k a -> Map k a -> Map k a\nunionWithKey _f t1 Tip = t1\nunionWithKey f t1 (Bin _ k x Tip Tip) = insertWithKeyR f k x t1\nunionWithKey f (Bin _ k x Tip Tip) t2 = insertWithKey f k x t2\nunionWithKey _f Tip t2 = t2\nunionWithKey f (Bin _ k1 x1 l1 r1) t2 = case splitLookup k1 t2 of\n  (l2, mb, r2) -> link k1 x1\' (unionWithKey f l1 l2) (unionWithKey f r1 r2)\n    where !x1\' = maybe x1 (f k1 x1) mb\n#if __GLASGOW_HASKELL__\n{-# INLINABLE unionWithKey #-}\n#endif\n\n{--------------------------------------------------------------------\n  Difference\n--------------------------------------------------------------------}\n\n-- | \\(O(n+m)\\). Difference with a combining function.\n-- When two equal keys are\n-- encountered, the combining function is applied to the values of these keys.\n-- If it returns \'Nothing\', the element is discarded (proper set difference). If\n-- it returns (@\'Just\' y@), the element is updated with a new value @y@.\n--\n-- > let f al ar = if al == "b" then Just (al ++ ":" ++ ar) else Nothing\n-- > differenceWith f (fromList [(5, "a"), (3, "b")]) (fromList [(5, "A"), (3, "B"), (7, "C")])\n-- >     == singleton 3 "b:B"\n\ndifferenceWith :: Ord k => (a -> b -> Maybe a) -> Map k a -> Map k b -> Map k a\ndifferenceWith f = merge preserveMissing dropMissing (zipWithMaybeMatched $ \\_ x1 x2 -> f x1 x2)\n#if __GLASGOW_HASKELL__\n{-# INLINABLE differenceWith #-}\n#endif\n\n-- | \\(O(n+m)\\). Difference with a combining function. When two equal keys are\n-- encountered, the combining function is applied to the key and both values.\n-- If it returns \'Nothing\', the element is discarded (proper set difference). If\n-- it returns (@\'Just\' y@), the element is updated with a new value @y@.\n--\n-- > let f k al ar = if al == "b" then Just ((show k) ++ ":" ++ al ++ "|" ++ ar) else Nothing\n-- > differenceWithKey f (fromList [(5, "a"), (3, "b")]) (fromList [(5, "A"), (3, "B"), (10, "C")])\n-- >     == singleton 3 "3:b|B"\n\ndifferenceWithKey :: Ord k => (k -> a -> b -> Maybe a) -> Map k a -> Map k b -> Map k a\ndifferenceWithKey f = merge preserveMissing dropMissing (zipWithMaybeMatched f)\n#if __GLASGOW_HASKELL__\n{-# INLINABLE differenceWithKey #-}\n#endif\n\n\n{--------------------------------------------------------------------\n  Intersection\n--------------------------------------------------------------------}\n\n-- | \\(O\\bigl(m \\log\\bigl(\\frac{n+1}{m+1}\\bigr)\\bigr), \\; m \\leq n\\). Intersection with a combining function.\n--\n-- > intersectionWith (++) (fromList [(5, "a"), (3, "b")]) (fromList [(5, "A"), (7, "C")]) == singleton 5 "aA"\n\nintersectionWith :: Ord k => (a -> b -> c) -> Map k a -> Map k b -> Map k c\nintersectionWith _f Tip _ = Tip\nintersectionWith _f _ Tip = Tip\nintersectionWith f (Bin _ k x1 l1 r1) t2 = case mb of\n    Just x2 -> let !x1\' = f x1 x2 in link k x1\' l1l2 r1r2\n    Nothing -> link2 l1l2 r1r2\n  where\n    !(l2, mb, r2) = splitLookup k t2\n    !l1l2 = intersectionWith f l1 l2\n    !r1r2 = intersectionWith f r1 r2\n#if __GLASGOW_HASKELL__\n{-# INLINABLE intersectionWith #-}\n#endif\n\n-- | \\(O\\bigl(m \\log\\bigl(\\frac{n+1}{m+1}\\bigr)\\bigr), \\; m \\leq n\\). Intersection with a combining function.\n--\n-- > let f k al ar = (show k) ++ ":" ++ al ++ "|" ++ ar\n-- > intersectionWithKey f (fromList [(5, "a"), (3, "b")]) (fromList [(5, "A"), (7, "C")]) == singleton 5 "5:a|A"\n\nintersectionWithKey :: Ord k => (k -> a -> b -> c) -> Map k a -> Map k b -> Map k c\nintersectionWithKey _f Tip _ = Tip\nintersectionWithKey _f _ Tip = Tip\nintersectionWithKey f (Bin _ k x1 l1 r1) t2 = case mb of\n    Just x2 -> let !x1\' = f k x1 x2 in link k x1\' l1l2 r1r2\n    Nothing -> link2 l1l2 r1r2\n  where\n    !(l2, mb, r2) = splitLookup k t2\n    !l1l2 = intersectionWithKey f l1 l2\n    !r1r2 = intersectionWithKey f r1 r2\n#if __GLASGOW_HASKELL__\n{-# INLINABLE intersectionWithKey #-}\n#endif\n\n-- | Map covariantly over a @\'WhenMissing\' f k x@.\nmapWhenMissing :: Functor f => (a -> b) -> WhenMissing f k x a -> WhenMissing f k x b\nmapWhenMissing f q = WhenMissing\n  { missingSubtree = fmap (map f) . missingSubtree q\n  , missingKey = \\k x -> fmap (forceMaybe . fmap f) $ missingKey q k x}\n\n-- | Map covariantly over a @\'WhenMatched\' f k x y@.\nmapWhenMatched :: Functor f => (a -> b) -> WhenMatched f k x y a -> WhenMatched f k x y b\nmapWhenMatched f q = WhenMatched\n  { matchedKey = \\k x y -> fmap (forceMaybe . fmap f) $ runWhenMatched q k x y }\n\n-- | When a key is found in both maps, apply a function to the\n-- key and values and maybe use the result in the merged map.\n--\n-- @\n-- zipWithMaybeMatched :: (k -> x -> y -> Maybe z)\n--                     -> SimpleWhenMatched k x y z\n-- @\nzipWithMaybeMatched :: Applicative f\n                    => (k -> x -> y -> Maybe z)\n                    -> WhenMatched f k x y z\nzipWithMaybeMatched f = WhenMatched $\n  \\k x y -> pure $! forceMaybe $! f k x y\n{-# INLINE zipWithMaybeMatched #-}\n\n-- | When a key is found in both maps, apply a function to the\n-- key and values, perform the resulting action, and maybe use\n-- the result in the merged map.\n--\n-- This is the fundamental \'WhenMatched\' tactic.\nzipWithMaybeAMatched :: Applicative f\n                     => (k -> x -> y -> f (Maybe z))\n                     -> WhenMatched f k x y z\nzipWithMaybeAMatched f = WhenMatched $\n  \\ k x y -> forceMaybe <$> f k x y\n{-# INLINE zipWithMaybeAMatched #-}\n\n-- | When a key is found in both maps, apply a function to the\n-- key and values to produce an action and use its result in the merged map.\nzipWithAMatched :: Applicative f\n                => (k -> x -> y -> f z)\n                -> WhenMatched f k x y z\nzipWithAMatched f = WhenMatched $\n  \\ k x y -> (Just $!) <$> f k x y\n{-# INLINE zipWithAMatched #-}\n\n-- | When a key is found in both maps, apply a function to the\n-- key and values and use the result in the merged map.\n--\n-- @\n-- zipWithMatched :: (k -> x -> y -> z)\n--                -> SimpleWhenMatched k x y z\n-- @\nzipWithMatched :: Applicative f\n               => (k -> x -> y -> z) -> WhenMatched f k x y z\nzipWithMatched f = WhenMatched $\n  \\k x y -> pure $! Just $! f k x y\n{-# INLINE zipWithMatched #-}\n\n-- | Map over the entries whose keys are missing from the other map,\n-- optionally removing some. This is the most powerful \'SimpleWhenMissing\'\n-- tactic, but others are usually more efficient.\n--\n-- @\n-- mapMaybeMissing :: (k -> x -> Maybe y) -> SimpleWhenMissing k x y\n-- @\n--\n-- prop> mapMaybeMissing f = traverseMaybeMissing (\\k x -> pure (f k x))\n--\n-- but @mapMaybeMissing@ uses fewer unnecessary \'Applicative\' operations.\nmapMaybeMissing :: Applicative f => (k -> x -> Maybe y) -> WhenMissing f k x y\nmapMaybeMissing f = WhenMissing\n  { missingSubtree = \\m -> pure $! mapMaybeWithKey f m\n  , missingKey = \\k x -> pure $! forceMaybe $! f k x }\n{-# INLINE mapMaybeMissing #-}\n\n-- | Map over the entries whose keys are missing from the other map.\n--\n-- @\n-- mapMissing :: (k -> x -> y) -> SimpleWhenMissing k x y\n-- @\n--\n-- prop> mapMissing f = mapMaybeMissing (\\k x -> Just $ f k x)\n--\n-- but @mapMissing@ is somewhat faster.\nmapMissing :: Applicative f => (k -> x -> y) -> WhenMissing f k x y\nmapMissing f = WhenMissing\n  { missingSubtree = \\m -> pure $! mapWithKey f m\n  , missingKey = \\k x -> pure $! Just $! f k x }\n{-# INLINE mapMissing #-}\n\n-- | Traverse over the entries whose keys are missing from the other map,\n-- optionally producing values to put in the result.\n-- This is the most powerful \'WhenMissing\' tactic, but others are usually\n-- more efficient.\ntraverseMaybeMissing :: Applicative f\n                     => (k -> x -> f (Maybe y)) -> WhenMissing f k x y\ntraverseMaybeMissing f = WhenMissing\n  { missingSubtree = traverseMaybeWithKey f\n  , missingKey = \\k x -> forceMaybe <$> f k x }\n{-# INLINE traverseMaybeMissing #-}\n\n-- | Traverse over the entries whose keys are missing from the other map.\ntraverseMissing :: Applicative f\n                     => (k -> x -> f y) -> WhenMissing f k x y\ntraverseMissing f = WhenMissing\n  { missingSubtree = traverseWithKey f\n  , missingKey = \\k x -> (Just $!) <$> f k x }\n{-# INLINE traverseMissing #-}\n\nforceMaybe :: Maybe a -> Maybe a\nforceMaybe Nothing = Nothing\nforceMaybe m@(Just !_) = m\n{-# INLINE forceMaybe #-}\n\n{--------------------------------------------------------------------\n  MergeWithKey\n--------------------------------------------------------------------}\n\n-- | \\(O(n+m)\\). An unsafe universal combining function.\n--\n-- WARNING: This function can produce corrupt maps and its results\n-- may depend on the internal structures of its inputs. Users should\n-- prefer \'Data.Map.Merge.Strict.merge\' or\n-- \'Data.Map.Merge.Strict.mergeA\'.\n--\n-- When \'mergeWithKey\' is given three arguments, it is inlined to the call\n-- site. You should therefore use \'mergeWithKey\' only to define custom\n-- combining functions. For example, you could define \'unionWithKey\',\n-- \'differenceWithKey\' and \'intersectionWithKey\' as\n--\n-- > myUnionWithKey f m1 m2 = mergeWithKey (\\k x1 x2 -> Just (f k x1 x2)) id id m1 m2\n-- > myDifferenceWithKey f m1 m2 = mergeWithKey f id (const empty) m1 m2\n-- > myIntersectionWithKey f m1 m2 = mergeWithKey (\\k x1 x2 -> Just (f k x1 x2)) (const empty) (const empty) m1 m2\n--\n-- When calling @\'mergeWithKey\' combine only1 only2@, a function combining two\n-- \'Map\'s is created, such that\n--\n-- * if a key is present in both maps, it is passed with both corresponding\n--   values to the @combine@ function. Depending on the result, the key is either\n--   present in the result with specified value, or is left out;\n--\n-- * a nonempty subtree present only in the first map is passed to @only1@ and\n--   the output is added to the result;\n--\n-- * a nonempty subtree present only in the second map is passed to @only2@ and\n--   the output is added to the result.\n--\n-- The @only1@ and @only2@ methods /must return a map with a subset (possibly empty) of the keys of the given map/.\n-- The values can be modified arbitrarily. Most common variants of @only1@ and\n-- @only2@ are \'id\' and @\'const\' \'empty\'@, but for example @\'map\' f@ or\n-- @\'filterWithKey\' f@ could be used for any @f@.\n\nmergeWithKey :: Ord k\n             => (k -> a -> b -> Maybe c)\n             -> (Map k a -> Map k c)\n             -> (Map k b -> Map k c)\n             -> Map k a -> Map k b -> Map k c\nmergeWithKey f g1 g2 = go\n  where\n    go Tip t2 = g2 t2\n    go t1 Tip = g1 t1\n    go (Bin _ kx x l1 r1) t2 =\n      case found of\n        Nothing -> case g1 (singleton kx x) of\n                     Tip -> link2 l\' r\'\n                     (Bin _ _ x\' Tip Tip) -> link kx x\' l\' r\'\n                     _ -> error "mergeWithKey: Given function only1 does not fulfill required conditions (see documentation)"\n        Just x2 -> case f kx x x2 of\n                     Nothing -> link2 l\' r\'\n                     Just x\' -> link kx x\' l\' r\'\n      where\n        (l2, found, r2) = splitLookup kx t2\n        l\' = go l1 l2\n        r\' = go r1 r2\n{-# INLINE mergeWithKey #-}\n\n{--------------------------------------------------------------------\n  Filter and partition\n--------------------------------------------------------------------}\n\n-- | \\(O(n)\\). Map values and collect the \'Just\' results.\n--\n-- > let f x = if x == "a" then Just "new a" else Nothing\n-- > mapMaybe f (fromList [(5,"a"), (3,"b")]) == singleton 5 "new a"\n\nmapMaybe :: (a -> Maybe b) -> Map k a -> Map k b\nmapMaybe f = mapMaybeWithKey (\\_ x -> f x)\n\n-- | \\(O(n)\\). Map keys\\/values and collect the \'Just\' results.\n--\n-- > let f k _ = if k < 5 then Just ("key : " ++ (show k)) else Nothing\n-- > mapMaybeWithKey f (fromList [(5,"a"), (3,"b")]) == singleton 3 "key : 3"\n\nmapMaybeWithKey :: (k -> a -> Maybe b) -> Map k a -> Map k b\nmapMaybeWithKey _ Tip = Tip\nmapMaybeWithKey f (Bin _ kx x l r) = case f kx x of\n  Just y  -> y `seq` link kx y (mapMaybeWithKey f l) (mapMaybeWithKey f r)\n  Nothing -> link2 (mapMaybeWithKey f l) (mapMaybeWithKey f r)\n\n-- | \\(O(n)\\). Traverse keys\\/values and collect the \'Just\' results.\n--\n-- @since 0.5.8\n\ntraverseMaybeWithKey :: Applicative f\n                     => (k -> a -> f (Maybe b)) -> Map k a -> f (Map k b)\ntraverseMaybeWithKey = go\n  where\n    go _ Tip = pure Tip\n    go f (Bin _ kx x Tip Tip) = maybe Tip (\\ !x\' -> Bin 1 kx x\' Tip Tip) <$> f kx x\n    go f (Bin _ kx x l r) = liftA3 combine (go f l) (f kx x) (go f r)\n      where\n        combine !l\' mx !r\' = case mx of\n          Nothing -> link2 l\' r\'\n          Just !x\' -> link kx x\' l\' r\'\n\n-- | \\(O(n)\\). Map values and separate the \'Left\' and \'Right\' results.\n--\n-- > let f a = if a < "c" then Left a else Right a\n-- > mapEither f (fromList [(5,"a"), (3,"b"), (1,"x"), (7,"z")])\n-- >     == (fromList [(3,"b"), (5,"a")], fromList [(1,"x"), (7,"z")])\n-- >\n-- > mapEither (\\ a -> Right a) (fromList [(5,"a"), (3,"b"), (1,"x"), (7,"z")])\n-- >     == (empty, fromList [(5,"a"), (3,"b"), (1,"x"), (7,"z")])\n\nmapEither :: (a -> Either b c) -> Map k a -> (Map k b, Map k c)\nmapEither f m\n  = mapEitherWithKey (\\_ x -> f x) m\n\n-- | \\(O(n)\\). Map keys\\/values and separate the \'Left\' and \'Right\' results.\n--\n-- > let f k a = if k < 5 then Left (k * 2) else Right (a ++ a)\n-- > mapEitherWithKey f (fromList [(5,"a"), (3,"b"), (1,"x"), (7,"z")])\n-- >     == (fromList [(1,2), (3,6)], fromList [(5,"aa"), (7,"zz")])\n-- >\n-- > mapEitherWithKey (\\_ a -> Right a) (fromList [(5,"a"), (3,"b"), (1,"x"), (7,"z")])\n-- >     == (empty, fromList [(1,"x"), (3,"b"), (5,"a"), (7,"z")])\n\nmapEitherWithKey :: (k -> a -> Either b c) -> Map k a -> (Map k b, Map k c)\nmapEitherWithKey f0 t0 = toPair $ go f0 t0\n  where\n    go _ Tip = (Tip :*: Tip)\n    go f (Bin _ kx x l r) = case f kx x of\n      Left y  -> y `seq` (link kx y l1 r1 :*: link2 l2 r2)\n      Right z -> z `seq` (link2 l1 r1 :*: link kx z l2 r2)\n     where\n        (l1 :*: l2) = go f l\n        (r1 :*: r2) = go f r\n\n{--------------------------------------------------------------------\n  Mapping\n--------------------------------------------------------------------}\n-- | \\(O(n)\\). Map a function over all values in the map.\n--\n-- > map (++ "x") (fromList [(5,"a"), (3,"b")]) == fromList [(3, "bx"), (5, "ax")]\n\nmap :: (a -> b) -> Map k a -> Map k b\nmap f = go\n  where\n    go Tip = Tip\n    go (Bin sx kx x l r) = let !x\' = f x in Bin sx kx x\' (go l) (go r)\n-- We use `go` to let `map` inline. This is important if `f` is a constant\n-- function.\n\n#ifdef __GLASGOW_HASKELL__\n{-# NOINLINE [1] map #-}\n{-# RULES\n"map/map" forall f g xs . map f (map g xs) = map (\\x -> f $! g x) xs\n"map/mapL" forall f g xs . map f (L.map g xs) = map (\\x -> f (g x)) xs\n #-}\n#endif\n\n-- | \\(O(n)\\). Map a function over all values in the map.\n--\n-- > let f key x = (show key) ++ ":" ++ x\n-- > mapWithKey f (fromList [(5,"a"), (3,"b")]) == fromList [(3, "3:b"), (5, "5:a")]\n\nmapWithKey :: (k -> a -> b) -> Map k a -> Map k b\nmapWithKey _ Tip = Tip\nmapWithKey f (Bin sx kx x l r) =\n  let x\' = f kx x\n  in x\' `seq` Bin sx kx x\' (mapWithKey f l) (mapWithKey f r)\n\n#ifdef __GLASGOW_HASKELL__\n{-# NOINLINE [1] mapWithKey #-}\n{-# RULES\n"mapWithKey/mapWithKey" forall f g xs . mapWithKey f (mapWithKey g xs) =\n  mapWithKey (\\k a -> f k $! g k a) xs\n"mapWithKey/mapWithKeyL" forall f g xs . mapWithKey f (L.mapWithKey g xs) =\n  mapWithKey (\\k a -> f k (g k a)) xs\n"mapWithKey/map" forall f g xs . mapWithKey f (map g xs) =\n  mapWithKey (\\k a -> f k $! g a) xs\n"mapWithKey/mapL" forall f g xs . mapWithKey f (L.map g xs) =\n  mapWithKey (\\k a -> f k (g a)) xs\n"map/mapWithKey" forall f g xs . map f (mapWithKey g xs) =\n  mapWithKey (\\k a -> f $! g k a) xs\n"map/mapWithKeyL" forall f g xs . map f (L.mapWithKey g xs) =\n  mapWithKey (\\k a -> f (g k a)) xs\n #-}\n#endif\n\n-- | \\(O(n)\\).\n-- @\'traverseWithKey\' f m == \'fromList\' \\<$\\> \'traverse\' (\\\\(k, v) -> (\\v\' -> v\' \\`seq\\` (k,v\')) \\<$\\> f k v) (\'toList\' m)@\n-- That is, it behaves much like a regular \'traverse\' except that the traversing\n-- function also has access to the key associated with a value and the values are\n-- forced before they are installed in the result map.\n--\n-- > traverseWithKey (\\k v -> if odd k then Just (succ v) else Nothing) (fromList [(1, \'a\'), (5, \'e\')]) == Just (fromList [(1, \'b\'), (5, \'f\')])\n-- > traverseWithKey (\\k v -> if odd k then Just (succ v) else Nothing) (fromList [(2, \'c\')])           == Nothing\ntraverseWithKey :: Applicative t => (k -> a -> t b) -> Map k a -> t (Map k b)\ntraverseWithKey f = go\n  where\n    go Tip = pure Tip\n    go (Bin 1 k v _ _) = (\\ !v\' -> Bin 1 k v\' Tip Tip) <$> f k v\n    go (Bin s k v l r) = liftA3 (\\ l\' !v\' r\' -> Bin s k v\' l\' r\') (go l) (f k v) (go r)\n{-# INLINE traverseWithKey #-}\n\n-- | \\(O(n)\\). The function \'mapAccum\' threads an accumulating\n-- argument through the map in ascending order of keys.\n--\n-- > let f a b = (a ++ b, b ++ "X")\n-- > mapAccum f "Everything: " (fromList [(5,"a"), (3,"b")]) == ("Everything: ba", fromList [(3, "bX"), (5, "aX")])\n\nmapAccum :: (a -> b -> (a,c)) -> a -> Map k b -> (a,Map k c)\nmapAccum f a m\n  = mapAccumWithKey (\\a\' _ x\' -> f a\' x\') a m\n\n-- | \\(O(n)\\). The function \'mapAccumWithKey\' threads an accumulating\n-- argument through the map in ascending order of keys.\n--\n-- > let f a k b = (a ++ " " ++ (show k) ++ "-" ++ b, b ++ "X")\n-- > mapAccumWithKey f "Everything:" (fromList [(5,"a"), (3,"b")]) == ("Everything: 3-b 5-a", fromList [(3, "bX"), (5, "aX")])\n\nmapAccumWithKey :: (a -> k -> b -> (a,c)) -> a -> Map k b -> (a,Map k c)\nmapAccumWithKey f a t\n  = mapAccumL f a t\n\n-- | \\(O(n)\\). The function \'mapAccumL\' threads an accumulating\n-- argument through the map in ascending order of keys.\nmapAccumL :: (a -> k -> b -> (a,c)) -> a -> Map k b -> (a,Map k c)\nmapAccumL _ a Tip               = (a,Tip)\nmapAccumL f a (Bin sx kx x l r) =\n  let (a1,l\') = mapAccumL f a l\n      (a2,x\') = f a1 kx x\n      (a3,r\') = mapAccumL f a2 r\n  in x\' `seq` (a3,Bin sx kx x\' l\' r\')\n\n-- | \\(O(n)\\). The function \'mapAccumRWithKey\' threads an accumulating\n-- argument through the map in descending order of keys.\nmapAccumRWithKey :: (a -> k -> b -> (a,c)) -> a -> Map k b -> (a,Map k c)\nmapAccumRWithKey _ a Tip = (a,Tip)\nmapAccumRWithKey f a (Bin sx kx x l r) =\n  let (a1,r\') = mapAccumRWithKey f a r\n      (a2,x\') = f a1 kx x\n      (a3,l\') = mapAccumRWithKey f a2 l\n  in x\' `seq` (a3,Bin sx kx x\' l\' r\')\n\n-- | \\(O(n \\log n)\\).\n-- @\'mapKeysWith\' c f s@ is the map obtained by applying @f@ to each key of @s@.\n--\n-- The size of the result may be smaller if @f@ maps two or more distinct\n-- keys to the same new key.  In this case the associated values will be\n-- combined using @c@. The value at the greater of the two original keys\n-- is used as the first argument to @c@.\n--\n-- > mapKeysWith (++) (\\ _ -> 1) (fromList [(1,"b"), (2,"a"), (3,"d"), (4,"c")]) == singleton 1 "cdab"\n-- > mapKeysWith (++) (\\ _ -> 3) (fromList [(1,"b"), (2,"a"), (3,"d"), (4,"c")]) == singleton 3 "cdab"\n\nmapKeysWith :: Ord k2 => (a -> a -> a) -> (k1->k2) -> Map k1 a -> Map k2 a\nmapKeysWith c f = fromListWith c . foldrWithKey (\\k x xs -> (f k, x) : xs) []\n#if __GLASGOW_HASKELL__\n{-# INLINABLE mapKeysWith #-}\n#endif\n\n{--------------------------------------------------------------------\n  Conversions\n--------------------------------------------------------------------}\n\n-- | \\(O(n)\\). Build a map from a set of keys and a function which for each key\n-- computes its value.\n--\n-- > fromSet (\\k -> replicate k \'a\') (Data.Set.fromList [3, 5]) == fromList [(5,"aaaaa"), (3,"aaa")]\n-- > fromSet undefined Data.Set.empty == empty\n\nfromSet :: (k -> a) -> Set.Set k -> Map k a\nfromSet _ Set.Tip = Tip\nfromSet f (Set.Bin sz x l r) = case f x of v -> v `seq` Bin sz x v (fromSet f l) (fromSet f r)\n\n-- | \\(O(n)\\). Build a map from a set of elements contained inside \'Arg\'s.\n--\n-- > fromArgSet (Data.Set.fromList [Arg 3 "aaa", Arg 5 "aaaaa"]) == fromList [(5,"aaaaa"), (3,"aaa")]\n-- > fromArgSet Data.Set.empty == empty\n\nfromArgSet :: Set.Set (Arg k a) -> Map k a\nfromArgSet Set.Tip = Tip\nfromArgSet (Set.Bin sz (Arg x v) l r) = v `seq` Bin sz x v (fromArgSet l) (fromArgSet r)\n\n{--------------------------------------------------------------------\n  Lists\n--------------------------------------------------------------------}\n-- | \\(O(n \\log n)\\). Build a map from a list of key\\/value pairs. See also \'fromAscList\'.\n-- If the list contains more than one value for the same key, the last value\n-- for the key is retained.\n--\n-- If the keys of the list are ordered, linear-time implementation is used,\n-- with the performance equal to \'fromDistinctAscList\'.\n--\n-- > fromList [] == empty\n-- > fromList [(5,"a"), (3,"b"), (5, "c")] == fromList [(5,"c"), (3,"b")]\n-- > fromList [(5,"c"), (3,"b"), (5, "a")] == fromList [(5,"a"), (3,"b")]\n\n-- For some reason, when \'singleton\' is used in fromList or in\n-- create, it is not inlined, so we inline it manually.\nfromList :: Ord k => [(k,a)] -> Map k a\nfromList [] = Tip\nfromList [(kx, x)] = x `seq` Bin 1 kx x Tip Tip\nfromList ((kx0, x0) : xs0) | not_ordered kx0 xs0 = x0 `seq` fromList\' (Bin 1 kx0 x0 Tip Tip) xs0\n                           | otherwise = x0 `seq` go (1::Int) (Bin 1 kx0 x0 Tip Tip) xs0\n  where\n    not_ordered _ [] = False\n    not_ordered kx ((ky,_) : _) = kx >= ky\n    {-# INLINE not_ordered #-}\n\n    fromList\' t0 xs = Foldable.foldl\' ins t0 xs\n      where ins t (k,x) = insert k x t\n\n    go !_ t [] = t\n    go _ t [(kx, x)] = x `seq` insertMax kx x t\n    go s l xs@((kx, x) : xss) | not_ordered kx xss = fromList\' l xs\n                              | otherwise = case create s xss of\n                                  (r, ys, []) -> x `seq` go (s `shiftL` 1) (link kx x l r) ys\n                                  (r, _,  ys) -> x `seq` fromList\' (link kx x l r) ys\n\n    -- The create is returning a triple (tree, xs, ys). Both xs and ys\n    -- represent not yet processed elements and only one of them can be nonempty.\n    -- If ys is nonempty, the keys in ys are not ordered with respect to tree\n    -- and must be inserted using fromList\'. Otherwise the keys have been\n    -- ordered so far.\n    create !_ [] = (Tip, [], [])\n    create s xs@(xp : xss)\n      | s == 1 = case xp of (kx, x) | not_ordered kx xss -> x `seq` (Bin 1 kx x Tip Tip, [], xss)\n                                    | otherwise -> x `seq` (Bin 1 kx x Tip Tip, xss, [])\n      | otherwise = case create (s `shiftR` 1) xs of\n                      res@(_, [], _) -> res\n                      (l, [(ky, y)], zs) -> y `seq` (insertMax ky y l, [], zs)\n                      (l, ys@((ky, y):yss), _) | not_ordered ky yss -> (l, [], ys)\n                                               | otherwise -> case create (s `shiftR` 1) yss of\n                                                   (r, zs, ws) -> y `seq` (link ky y l r, zs, ws)\n#if __GLASGOW_HASKELL__\n{-# INLINABLE fromList #-}\n#endif\n\n-- | \\(O(n \\log n)\\). Build a map from a list of key\\/value pairs with a combining function. See also \'fromAscListWith\'.\n--\n-- > fromListWith (++) [(5,"a"), (5,"b"), (3,"b"), (3,"a"), (5,"a")] == fromList [(3, "ab"), (5, "aba")]\n-- > fromListWith (++) [] == empty\n\nfromListWith :: Ord k => (a -> a -> a) -> [(k,a)] -> Map k a\nfromListWith f xs\n  = fromListWithKey (\\_ x y -> f x y) xs\n#if __GLASGOW_HASKELL__\n{-# INLINABLE fromListWith #-}\n#endif\n\n-- | \\(O(n \\log n)\\). Build a map from a list of key\\/value pairs with a combining function. See also \'fromAscListWithKey\'.\n--\n-- > let f key new_value old_value = show key ++ ":" ++ new_value ++ "|" ++ old_value\n-- > fromListWithKey f [(5,"a"), (5,"b"), (3,"b"), (3,"a"), (5,"c")] == fromList [(3, "3:a|b"), (5, "5:c|5:b|a")]\n-- > fromListWithKey f [] == empty\n\nfromListWithKey :: Ord k => (k -> a -> a -> a) -> [(k,a)] -> Map k a\nfromListWithKey f xs\n  = Foldable.foldl\' ins empty xs\n  where\n    ins t (k,x) = insertWithKey f k x t\n#if __GLASGOW_HASKELL__\n{-# INLINABLE fromListWithKey #-}\n#endif\n\n{--------------------------------------------------------------------\n  Building trees from ascending/descending lists can be done in linear time.\n\n  Note that if [xs] is ascending then:\n    fromAscList xs       == fromList xs\n    fromAscListWith f xs == fromListWith f xs\n\n  If [xs] is descending then:\n    fromDescList xs       == fromList xs\n    fromDescListWith f xs == fromListWith f xs\n--------------------------------------------------------------------}\n\n-- | \\(O(n)\\). Build a map from an ascending list in linear time.\n-- /The precondition (input list is ascending) is not checked./\n--\n-- > fromAscList [(3,"b"), (5,"a")]          == fromList [(3, "b"), (5, "a")]\n-- > fromAscList [(3,"b"), (5,"a"), (5,"b")] == fromList [(3, "b"), (5, "b")]\n-- > valid (fromAscList [(3,"b"), (5,"a"), (5,"b")]) == True\n-- > valid (fromAscList [(5,"a"), (3,"b"), (5,"b")]) == False\nfromAscList :: Eq k => [(k,a)] -> Map k a\nfromAscList xs\n  = fromAscListWithKey (\\_ x _ -> x) xs\n#if __GLASGOW_HASKELL__\n{-# INLINABLE fromAscList #-}\n#endif\n\n-- | \\(O(n)\\). Build a map from a descending list in linear time.\n-- /The precondition (input list is descending) is not checked./\n--\n-- > fromDescList [(5,"a"), (3,"b")]          == fromList [(3, "b"), (5, "a")]\n-- > fromDescList [(5,"a"), (5,"b"), (3,"a")] == fromList [(3, "b"), (5, "b")]\n-- > valid (fromDescList [(5,"a"), (5,"b"), (3,"b")]) == True\n-- > valid (fromDescList [(5,"a"), (3,"b"), (5,"b")]) == False\nfromDescList :: Eq k => [(k,a)] -> Map k a\nfromDescList xs\n  = fromDescListWithKey (\\_ x _ -> x) xs\n#if __GLASGOW_HASKELL__\n{-# INLINABLE fromDescList #-}\n#endif\n\n-- | \\(O(n)\\). Build a map from an ascending list in linear time with a combining function for equal keys.\n-- /The precondition (input list is ascending) is not checked./\n--\n-- > fromAscListWith (++) [(3,"b"), (5,"a"), (5,"b")] == fromList [(3, "b"), (5, "ba")]\n-- > valid (fromAscListWith (++) [(3,"b"), (5,"a"), (5,"b")]) == True\n-- > valid (fromAscListWith (++) [(5,"a"), (3,"b"), (5,"b")]) == False\n\nfromAscListWith :: Eq k => (a -> a -> a) -> [(k,a)] -> Map k a\nfromAscListWith f xs\n  = fromAscListWithKey (\\_ x y -> f x y) xs\n#if __GLASGOW_HASKELL__\n{-# INLINABLE fromAscListWith #-}\n#endif\n\n-- | \\(O(n)\\). Build a map from a descending list in linear time with a combining function for equal keys.\n-- /The precondition (input list is descending) is not checked./\n--\n-- > fromDescListWith (++) [(5,"a"), (5,"b"), (3,"b")] == fromList [(3, "b"), (5, "ba")]\n-- > valid (fromDescListWith (++) [(5,"a"), (5,"b"), (3,"b")]) == True\n-- > valid (fromDescListWith (++) [(5,"a"), (3,"b"), (5,"b")]) == False\n\nfromDescListWith :: Eq k => (a -> a -> a) -> [(k,a)] -> Map k a\nfromDescListWith f xs\n  = fromDescListWithKey (\\_ x y -> f x y) xs\n#if __GLASGOW_HASKELL__\n{-# INLINABLE fromDescListWith #-}\n#endif\n\n-- | \\(O(n)\\). Build a map from an ascending list in linear time with a\n-- combining function for equal keys.\n-- /The precondition (input list is ascending) is not checked./\n--\n-- > let f k a1 a2 = (show k) ++ ":" ++ a1 ++ a2\n-- > fromAscListWithKey f [(3,"b"), (5,"a"), (5,"b"), (5,"b")] == fromList [(3, "b"), (5, "5:b5:ba")]\n-- > valid (fromAscListWithKey f [(3,"b"), (5,"a"), (5,"b"), (5,"b")]) == True\n-- > valid (fromAscListWithKey f [(5,"a"), (3,"b"), (5,"b"), (5,"b")]) == False\n\nfromAscListWithKey :: Eq k => (k -> a -> a -> a) -> [(k,a)] -> Map k a\nfromAscListWithKey f xs\n  = fromDistinctAscList (combineEq f xs)\n  where\n  -- [combineEq f xs] combines equal elements with function [f] in an ordered list [xs]\n  combineEq _ xs\'\n    = case xs\' of\n        []     -> []\n        [x]    -> [x]\n        (x:xx) -> combineEq\' x xx\n\n  combineEq\' z [] = [z]\n  combineEq\' z@(kz,zz) (x@(kx,xx):xs\')\n    | kx==kz    = let yy = f kx xx zz in yy `seq` combineEq\' (kx,yy) xs\'\n    | otherwise = z:combineEq\' x xs\'\n#if __GLASGOW_HASKELL__\n{-# INLINABLE fromAscListWithKey #-}\n#endif\n\n-- | \\(O(n)\\). Build a map from a descending list in linear time with a\n-- combining function for equal keys.\n-- /The precondition (input list is descending) is not checked./\n--\n-- > let f k a1 a2 = (show k) ++ ":" ++ a1 ++ a2\n-- > fromDescListWithKey f [(5,"a"), (5,"b"), (5,"b"), (3,"b")] == fromList [(3, "b"), (5, "5:b5:ba")]\n-- > valid (fromDescListWithKey f [(5,"a"), (5,"b"), (5,"b"), (3,"b")]) == True\n-- > valid (fromDescListWithKey f [(5,"a"), (3,"b"), (5,"b"), (5,"b")]) == False\n\nfromDescListWithKey :: Eq k => (k -> a -> a -> a) -> [(k,a)] -> Map k a\nfromDescListWithKey f xs\n  = fromDistinctDescList (combineEq f xs)\n  where\n  -- [combineEq f xs] combines equal elements with function [f] in an ordered list [xs]\n  combineEq _ xs\'\n    = case xs\' of\n        []     -> []\n        [x]    -> [x]\n        (x:xx) -> combineEq\' x xx\n\n  combineEq\' z [] = [z]\n  combineEq\' z@(kz,zz) (x@(kx,xx):xs\')\n    | kx==kz    = let yy = f kx xx zz in yy `seq` combineEq\' (kx,yy) xs\'\n    | otherwise = z:combineEq\' x xs\'\n#if __GLASGOW_HASKELL__\n{-# INLINABLE fromDescListWithKey #-}\n#endif\n\n-- | \\(O(n)\\). Build a map from an ascending list of distinct elements in linear time.\n-- /The precondition is not checked./\n--\n-- > fromDistinctAscList [(3,"b"), (5,"a")] == fromList [(3, "b"), (5, "a")]\n-- > valid (fromDistinctAscList [(3,"b"), (5,"a")])          == True\n-- > valid (fromDistinctAscList [(3,"b"), (5,"a"), (5,"b")]) == False\n\n-- For some reason, when \'singleton\' is used in fromDistinctAscList or in\n-- create, it is not inlined, so we inline it manually.\nfromDistinctAscList :: [(k,a)] -> Map k a\nfromDistinctAscList [] = Tip\nfromDistinctAscList ((kx0, x0) : xs0) = x0 `seq` go (1::Int) (Bin 1 kx0 x0 Tip Tip) xs0\n  where\n    go !_ t [] = t\n    go s l ((kx, x) : xs) =\n      case create s xs of\n        (r :*: ys) -> x `seq` let !t\' = link kx x l r\n                           in go (s `shiftL` 1) t\' ys\n\n    create !_ [] = (Tip :*: [])\n    create s xs@(x\' : xs\')\n      | s == 1 = case x\' of (kx, x) -> x `seq` (Bin 1 kx x Tip Tip :*: xs\')\n      | otherwise = case create (s `shiftR` 1) xs of\n                      res@(_ :*: []) -> res\n                      (l :*: (ky, y):ys) -> case create (s `shiftR` 1) ys of\n                        (r :*: zs) -> y `seq` (link ky y l r :*: zs)\n\n-- | \\(O(n)\\). Build a map from a descending list of distinct elements in linear time.\n-- /The precondition is not checked./\n--\n-- > fromDistinctDescList [(5,"a"), (3,"b")] == fromList [(3, "b"), (5, "a")]\n-- > valid (fromDistinctDescList [(5,"a"), (3,"b")])          == True\n-- > valid (fromDistinctDescList [(5,"a"), (3,"b"), (3,"a")]) == False\n\n-- For some reason, when \'singleton\' is used in fromDistinctDescList or in\n-- create, it is not inlined, so we inline it manually.\nfromDistinctDescList :: [(k,a)] -> Map k a\nfromDistinctDescList [] = Tip\nfromDistinctDescList ((kx0, x0) : xs0) = x0 `seq` go (1::Int) (Bin 1 kx0 x0 Tip Tip) xs0\n  where\n    go !_ t [] = t\n    go s r ((kx, x) : xs) =\n      case create s xs of\n        (l :*: ys) -> x `seq` let !t\' = link kx x l r\n                              in go (s `shiftL` 1) t\' ys\n\n    create !_ [] = (Tip :*: [])\n    create s xs@(x\' : xs\')\n      | s == 1 = case x\' of (kx, x) -> x `seq` (Bin 1 kx x Tip Tip :*: xs\')\n      | otherwise = case create (s `shiftR` 1) xs of\n                      res@(_ :*: []) -> res\n                      (r :*: (ky, y):ys) -> case create (s `shiftR` 1) ys of\n                        (l :*: zs) -> y `seq` (link ky y l r :*: zs)\n'