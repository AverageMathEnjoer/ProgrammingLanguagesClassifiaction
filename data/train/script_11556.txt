b'{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{-# LANGUAGE TupleSections #-}\n{-# LANGUAGE CPP #-}\n\n-- | Serialization and deserialization helpers for beam data types.\n--\n-- Used to read and write machine-readable schema descriptions.\n\nmodule Database.Beam.Migrate.Serialization\n       ( -- * Serialization helpers\n         -- $serialization\n         BeamSerializedDataType(..)\n       , BeamSerializedConstraintDefinition(..)\n       , BeamSerializedConstraintAttributes(..)\n       , BeamSerializedConstraint(..)\n       , BeamSerializedMatchType(..)\n       , BeamSerializedReferentialAction(..)\n       , BeamSerializedExpression(..)\n\n       , beamSerializeJSON, serializePrecAndDecimal\n\n       -- * Deserialization helpers\n       -- $deserialization\n\n       , BeamDeserializers(..)\n\n       , beamDeserialize, beamDeserializeMaybe\n       , beamDeserializer, sql92Deserializers\n       , sql99DataTypeDeserializers\n       , sql2003BinaryAndVarBinaryDataTypeDeserializers\n       , sql2008BigIntDataTypeDeserializers\n       ) where\n\nimport           Database.Beam.Backend.SQL\nimport           Database.Beam.Migrate.SQL.SQL92\nimport           Database.Beam.Migrate.SQL.Types\n\nimport           Control.Applicative\nimport           Control.Monad\n\nimport           Data.Aeson\n#if MIN_VERSION_aeson(2,0,0)\nimport qualified Data.Aeson.Key as DAK\n#endif\nimport           Data.Aeson.Types (Parser)\nimport qualified Data.Dependent.Map as D\nimport qualified Data.GADT.Compare as D\nimport           Data.Text (Text, unpack)\nimport           Data.Typeable (Typeable, (:~:)( Refl ), eqT, typeRep, typeOf)\nimport qualified Data.Vector as V\n#if !MIN_VERSION_base(4, 11, 0)\nimport           Data.Semigroup\n#endif\n\n-- * Serialization helpers\n\n-- | An \'IsSql92DataTypeSyntax\' for JSON. Supports all superclasses of\n-- `IsSql92DataTypeSyntax` declared in @beam-core@.\nnewtype BeamSerializedDataType\n  = BeamSerializedDataType { fromBeamSerializedDataType :: Value }\n  deriving (Show, Eq)\n\ninstance IsSql92DataTypeSyntax BeamSerializedDataType where\n  domainType nm = BeamSerializedDataType (object [ "domain" .= nm])\n  charType prec collation =\n    BeamSerializedDataType (object [ "char" .= object [ "prec" .= prec\n                                                      , "collation" .= collation ]])\n  varCharType prec collation =\n    BeamSerializedDataType (object [ "varchar" .= object [ "prec" .= prec\n                                                         , "collation" .= collation ]])\n  nationalCharType prec =\n    BeamSerializedDataType (object [ "national-char" .= object [ "prec" .= prec ]])\n  nationalVarCharType prec =\n    BeamSerializedDataType (object [ "national-varchar" .= object [ "prec" .= prec ]])\n\n  bitType prec =\n    BeamSerializedDataType (object [ "bit" .= object [ "prec" .= prec ]])\n  varBitType prec =\n    BeamSerializedDataType (object [ "varbit" .= object [ "prec" .= prec ]])\n\n  numericType precAndDecimal =\n    BeamSerializedDataType (object [ "numeric" .= serializePrecAndDecimal precAndDecimal ])\n  decimalType precAndDecimal =\n    BeamSerializedDataType (object [ "decimal" .= serializePrecAndDecimal precAndDecimal ])\n\n  intType = BeamSerializedDataType "int"\n  smallIntType = BeamSerializedDataType "smallint"\n  floatType prec =\n    BeamSerializedDataType (object [ "float" .= object [ "prec" .= prec ] ])\n  doubleType = BeamSerializedDataType "double"\n  realType = BeamSerializedDataType "real"\n\n  dateType = BeamSerializedDataType "date"\n  timeType prec withTz =\n    BeamSerializedDataType (object [ "time" .= object [ "prec" .= prec\n                                                      , "timezone" .= withTz ]])\n  timestampType prec withTz =\n    BeamSerializedDataType (object [ "timestamp" .= object [ "prec" .= prec\n                                                           , "timezone" .= withTz ]])\n\ninstance IsSql99DataTypeSyntax BeamSerializedDataType where\n  characterLargeObjectType = BeamSerializedDataType "clob"\n  binaryLargeObjectType = BeamSerializedDataType "blob"\n  booleanType = BeamSerializedDataType "boolean"\n  arrayType ty count = BeamSerializedDataType (object [ "array" .= object [ "of" .= ty\n                                                                          , "count" .= count ]])\n  rowType tys = BeamSerializedDataType (object [ "row" .= tys ])\n\ninstance IsSql2003BinaryAndVarBinaryDataTypeSyntax BeamSerializedDataType where\n  binaryType sz = BeamSerializedDataType (object [ "binary" .= sz ])\n  varBinaryType sz = BeamSerializedDataType (object [ "varbinary" .= sz ])\n\ninstance IsSql2008BigIntDataTypeSyntax BeamSerializedDataType where\n  bigIntType = BeamSerializedDataType "bigint"\n\ninstance ToJSON BeamSerializedDataType where\n  toJSON = fromBeamSerializedDataType\n\n-- | \'IsSql92ColumnConstraintDefinitionSyntax\' type for JSON\nnewtype BeamSerializedConstraintDefinition\n  = BeamSerializedConstraintDefinition\n  { fromBeamSerializedConstraintDefinition :: Value\n  } deriving (Show, Eq)\n\n-- | \'IsSql92ConstraintAttributesSyntax\' type for JSON\nnewtype BeamSerializedConstraintAttributes\n  = BeamSerializedConstraintAttributes\n  { fromBeamSerializedConstraintAttributes :: [ Value ]\n  } deriving (Show, Eq, Monoid, Semigroup)\n\n-- | \'IsSql92ColumnConstraintSyntax\' type for JSON\nnewtype BeamSerializedConstraint\n  = BeamSerializedConstraint\n  { fromBeamSerializedConstraint :: Value\n  } deriving (Show, Eq)\n\n-- | \'IsSql92MatchTypeSyntax\' type for JSON\nnewtype BeamSerializedMatchType\n  = BeamSerializedMatchType\n  { fromBeamSerializedMatchType :: Value\n  } deriving (Show, Eq)\n\n-- | \'IsSql92ReferentialActionSyntax\' type for JSON\nnewtype BeamSerializedReferentialAction\n  = BeamSerializedReferentialAction\n  { fromBeamSerializedReferentialAction :: Value\n  } deriving (Show, Eq)\n\n-- | \'IsSql92ExpressionSyntax\' is too complex for us to store in JSON.\n-- Additionally, many backends provide substantial amounts of extensions to the\n-- syntax that would make storing this highly unfeasible. Expressions are\n-- therefore represented as their full text rendering.\n--\n-- This means that expressions only match as equal if they match /exactly/.\n-- While this may seem overly pedantic, it\'s not much of a concern if your\n-- migrations are generated solely by @beam-migrate@. If you\'ve modified the\n-- schema yourself, you may have to use \'IsCustomSqlSyntax\' to provide an exact\n-- expression.\nnewtype BeamSerializedExpression\n  = BeamSerializedExpression\n  { fromBeamSerializedExpression :: Text\n  } deriving (Show, Eq)\n\ninstance IsSql92ColumnConstraintDefinitionSyntax BeamSerializedConstraintDefinition where\n  type Sql92ColumnConstraintDefinitionAttributesSyntax BeamSerializedConstraintDefinition =\n    BeamSerializedConstraintAttributes\n  type Sql92ColumnConstraintDefinitionConstraintSyntax BeamSerializedConstraintDefinition =\n    BeamSerializedConstraint\n\n  constraintDefinitionSyntax nm constraint attrs =\n    BeamSerializedConstraintDefinition $\n    object [ "name" .= nm\n           , "attributes" .= fmap fromBeamSerializedConstraintAttributes attrs\n           , "constraint" .= fromBeamSerializedConstraint constraint ]\n\ninstance IsSql92ColumnConstraintSyntax BeamSerializedConstraint where\n  type Sql92ColumnConstraintMatchTypeSyntax BeamSerializedConstraint =\n    BeamSerializedMatchType\n  type Sql92ColumnConstraintReferentialActionSyntax BeamSerializedConstraint =\n    BeamSerializedReferentialAction\n  type Sql92ColumnConstraintExpressionSyntax BeamSerializedConstraint =\n    BeamSerializedExpression\n\n  notNullConstraintSyntax = BeamSerializedConstraint "not-null"\n  uniqueColumnConstraintSyntax = BeamSerializedConstraint "unique"\n  primaryKeyColumnConstraintSyntax = BeamSerializedConstraint "primary-key"\n  checkColumnConstraintSyntax e = BeamSerializedConstraint (object [ "check-column" .= fromBeamSerializedExpression e])\n  referencesConstraintSyntax tbl fields matchType onUpdate onDelete =\n    BeamSerializedConstraint (object [ "references" .=\n                                         object [ "table" .= tbl, "fields" .= fields\n                                                , "match-type" .= fmap fromBeamSerializedMatchType matchType\n                                                , "on-update"  .= fmap fromBeamSerializedReferentialAction onUpdate\n                                                , "on-delete"  .= fmap fromBeamSerializedReferentialAction onDelete ] ])\n\ninstance IsSql92MatchTypeSyntax BeamSerializedMatchType where\n  fullMatchSyntax = BeamSerializedMatchType "full"\n  partialMatchSyntax = BeamSerializedMatchType "partial"\n\ninstance IsSql92ReferentialActionSyntax BeamSerializedReferentialAction where\n  referentialActionCascadeSyntax = BeamSerializedReferentialAction "cascade"\n  referentialActionSetNullSyntax = BeamSerializedReferentialAction "set-null"\n  referentialActionSetDefaultSyntax = BeamSerializedReferentialAction "set-default"\n  referentialActionNoActionSyntax = BeamSerializedReferentialAction "nothing"\n\ninstance IsSql92ConstraintAttributesSyntax BeamSerializedConstraintAttributes where\n  initiallyDeferredAttributeSyntax = BeamSerializedConstraintAttributes [ "initially-deferred" ]\n  initiallyImmediateAttributeSyntax = BeamSerializedConstraintAttributes [ "initially-immediate" ]\n  notDeferrableAttributeSyntax = BeamSerializedConstraintAttributes [ "not-deferrable" ]\n  deferrableAttributeSyntax = BeamSerializedConstraintAttributes [ "deferrable" ]\n\n-- | Some backends serialize data that can only be read by that backend. If so,\n-- they should wrap these data in \'beamSerializeJSON\', which provides a standard\n-- syntax for specifying backend specific data, as well as which backend the\n-- data are valid for.\n--\n-- The first argument is a string that is unique to a given backend\nbeamSerializeJSON :: Text -> Value -> Value\nbeamSerializeJSON backend v =\n  object [ "be-specific" .= backend\n         , "be-data" .= v ]\n\n-- | Helper for serializing the precision and decimal count parameters to\n-- \'decimalType\', etc.\nserializePrecAndDecimal :: Maybe (Word, Maybe Word) -> Value\nserializePrecAndDecimal Nothing =\n  object []\nserializePrecAndDecimal (Just (prec, Nothing)) =\n  object [ "prec" .= prec ]\nserializePrecAndDecimal (Just (prec, Just decimal)) =\n  object [ "prec" .= prec\n         , "decimal" .= decimal ]\n\n-- * Deserialization helpers\n\n-- ** Data types\n\nnewtype BeamDeserializer syntax\n  = BeamDeserializer (forall be. BeamDeserializers be -> Value -> Parser syntax)\n\n-- | Provides a collection of deserializers from aeson \'Value\'s for arbitrary\n-- types. The @cmd@ type parameter is a phantom type parameter. Notionally, all\n-- deserializers within this \'BeamDeserializers\' relate to the @cmd@ syntax.\nnewtype BeamDeserializers be\n  = BeamDeserializers\n  { beamArbitraryDeserializers :: D.DMap BeamDeserializerLabel BeamDeserializer\n  }\n\ninstance Semigroup (BeamDeserializer be) where\n  (<>) = mappend\n\ninstance Monoid (BeamDeserializer be) where\n  mempty = BeamDeserializer (const (const mzero))\n  mappend (BeamDeserializer a) (BeamDeserializer b) =\n    BeamDeserializer $ \\d o ->\n    a d o <|> b d o\n\ninstance Semigroup (BeamDeserializers be) where\n  (<>) = mappend\n\ninstance Monoid (BeamDeserializers be) where\n  mempty = BeamDeserializers mempty\n  mappend (BeamDeserializers a) (BeamDeserializers b) =\n    BeamDeserializers (D.unionWithKey (const mappend) a b)\n\n-- | Helper function to deserialize data from a \'Maybe\' \'Value\'.\n--\n-- @\n-- beamDeserializeMaybe _ Nothing = pure Nothing\n-- beamDeserializeMaybe d (Just v) = Just <$> beamDeserialize d v\n-- @\n--\nbeamDeserializeMaybe :: Typeable a\n                     => BeamDeserializers be\n                     -> Maybe Value\n                     -> Parser (Maybe a)\nbeamDeserializeMaybe _ Nothing = pure Nothing\nbeamDeserializeMaybe d (Just v) =\n  Just <$> beamDeserialize d v\n\n-- | Deserialize the requested type from the given deserializers and aeson \'Value\'.\nbeamDeserialize :: forall a be. Typeable a\n                => BeamDeserializers be -> Value\n                -> Parser a\nbeamDeserialize allD@(BeamDeserializers d) v =\n  case D.lookup (BeamDeserializerLabel :: BeamDeserializerLabel a) d of\n    Nothing -> fail ("beamDeserialize: No deserializer for " ++ show (typeOf (undefined :: a)))\n    Just (BeamDeserializer doParse) ->\n      doParse allD v\n\ndata BeamDeserializerLabel ty where\n  BeamDeserializerLabel :: Typeable ty\n                        => BeamDeserializerLabel ty\ninstance D.GEq BeamDeserializerLabel where\n  geq a b =\n    case D.gcompare a b of\n      D.GEQ -> Just Refl\n      _ -> Nothing\ninstance D.GCompare BeamDeserializerLabel where\n  gcompare a@(BeamDeserializerLabel :: BeamDeserializerLabel a)\n           b@(BeamDeserializerLabel :: BeamDeserializerLabel b) =\n    case eqT of\n      Just (Refl :: a :~: b)-> D.GEQ\n      Nothing ->\n        case compare (typeRep a) (typeRep b) of\n          LT -> D.GLT\n          GT -> D.GGT\n          EQ -> error "Impossible"\n\nbeamDeserializer :: Typeable ty\n                 => (forall be\'. BeamDeserializers be\' -> Value -> Parser ty)\n                 -> BeamDeserializers be\nbeamDeserializer parse =\n  BeamDeserializers (D.singleton BeamDeserializerLabel (BeamDeserializer parse))\n\n-- | Deserializers for SQL92 syntaxes\nsql92Deserializers :: forall be\n                    . BeamMigrateSqlBackend be\n                   => BeamDeserializers be\nsql92Deserializers = mconcat\n                   [ beamDeserializer deserializeSql92DataType\n                   , beamDeserializer deserializeSql92ConstraintDefinition\n                   , beamDeserializer deserializeSql92Constraint\n                   , beamDeserializer deserializeSql92MatchType\n                   , beamDeserializer deserializeSql92ReferentialAction\n                   , beamDeserializer deserializeSql92Attributes ]\n  where\n#if MIN_VERSION_aeson(2,0,0)\n    makeKey = DAK.fromText\n#else\n    makeKey = id\n#endif\n    parseSub nm o key parse =\n      withObject (unpack (nm <> "." <> key)) parse =<< o .: makeKey key\n\n    deserializeSql92DataType :: BeamDeserializers be\' -> Value\n                             -> Parser (BeamSqlBackendDataTypeSyntax be)\n    deserializeSql92DataType _ o =\n      deserializeSql92DataTypeObject o <|>\n      deserializeSql92DataTypeScalar o\n\n    deserializeSql92DataTypeScalar "int" = pure intType\n    deserializeSql92DataTypeScalar "smallint" = pure smallIntType\n    deserializeSql92DataTypeScalar "double" = pure dateType\n    deserializeSql92DataTypeScalar "real" = pure realType\n    deserializeSql92DataTypeScalar "date" = pure dateType\n    deserializeSql92DataTypeScalar _ = mzero\n\n    deserializeSql92DataTypeObject =\n      withObject "Sql92DataType" $ \\o ->\n      let (==>) = parseSub "Sql92DataType" o\n      in (domainType <$> o .: "domain") <|>\n         ("char" ==> \\v ->\n             charType <$> v .: "prec" <*> v .: "collation") <|>\n         ("varchar" ==> \\v ->\n             varCharType <$> v .: "prec" <*> v .: "collation") <|>\n         ("national-char" ==> \\v ->\n             nationalCharType <$> v .: "prec") <|>\n         ("national-varchar" ==> \\v ->\n             nationalVarCharType <$> v .: "prec") <|>\n         ("bit" ==> \\v ->\n             bitType <$> v .: "prec") <|>\n         ("varbit" ==> \\v ->\n             varBitType <$> v .: "prec") <|>\n         ("numeric" ==> \\v ->\n             numericType <$> deserializePrecAndDecimal v) <|>\n         ("decimal" ==> \\v ->\n             decimalType <$> deserializePrecAndDecimal v) <|>\n         ("float" ==> \\v ->\n             floatType <$> v .: "prec") <|>\n         ("time" ==> \\v ->\n             timeType <$> v .: "prec" <*> v .: "timezone") <|>\n         ("timestamp" ==> \\v ->\n             timestampType <$> v .: "prec" <*> v .: "timezone")\n\n    deserializePrecAndDecimal o =\n      Just <$> (((,) <$> o .: "prec" <*> (Just <$> o .: "decimal")) <|>\n                ((,Nothing) <$> o .: "prec")) <|>\n      pure Nothing\n\n    deserializeSql92ConstraintDefinition :: BeamDeserializers be\' -> Value\n                                         -> Parser (BeamSqlBackendColumnConstraintDefinitionSyntax be)\n    deserializeSql92ConstraintDefinition d =\n      withObject "Sql92ColumnConstraintDefinition" $ \\o ->\n      constraintDefinitionSyntax <$> o .: "name"\n                                 <*> (beamDeserialize d =<< o .: "constraint")\n                                 <*> (beamDeserializeMaybe d =<< o .: "attributes")\n\n    deserializeSql92Constraint :: BeamDeserializers be\' -> Value\n                               -> Parser (BeamSqlBackendConstraintSyntax be)\n    deserializeSql92Constraint d o =\n      case o of\n        "not-null" -> pure notNullConstraintSyntax\n        "unique" -> pure uniqueColumnConstraintSyntax\n        _ -> withObject "Sql92ColumnConstraint" parseObject o\n      where\n        parseObject v =\n          let (==>) = parseSub "Sql92ColumnConstraint" v\n          in checkColumnConstraintSyntax <$> (beamDeserialize d =<< v .: "check-column") <|>\n             ("references" ==> \\v\' ->\n                 referencesConstraintSyntax <$> v\' .: "table" <*> v\' .: "fields"\n                                            <*> (beamDeserializeMaybe d =<< v\' .: "match-type")\n                                            <*> (beamDeserializeMaybe d =<< v\' .: "on-update")\n                                            <*> (beamDeserializeMaybe d =<< v\' .: "on-delete"))\n\n    deserializeSql92MatchType :: BeamDeserializers be\' -> Value\n                              -> Parser (BeamSqlBackendMatchTypeSyntax be)\n    deserializeSql92MatchType _ v =\n      case v of\n        "full" -> pure fullMatchSyntax\n        "partial" -> pure partialMatchSyntax\n        _ -> mzero\n\n    deserializeSql92ReferentialAction :: BeamDeserializers be\' -> Value\n                                      -> Parser (BeamSqlBackendReferentialActionSyntax be)\n    deserializeSql92ReferentialAction _ v =\n      case v of\n        "cascade" -> pure referentialActionCascadeSyntax\n        "set-null" -> pure referentialActionSetNullSyntax\n        "set-default" -> pure referentialActionSetDefaultSyntax\n        "nothing" -> pure referentialActionNoActionSyntax\n        _ -> mzero\n\n    deserializeSql92Attributes :: BeamDeserializers be\' -> Value\n                               -> Parser (BeamSqlBackendConstraintAttributesSyntax be)\n    deserializeSql92Attributes _ =\n      withArray "Sql92Attributes" $ \\a ->\n      pure (foldr (\\o accum ->\n                      case o of\n                        "initially-deferred" -> initiallyDeferredAttributeSyntax <> accum\n                        "initially-immediate" -> initiallyImmediateAttributeSyntax <> accum\n                        "not-deferrable" -> notDeferrableAttributeSyntax <> accum\n                        "deferrable" -> deferrableAttributeSyntax <> accum\n                        _ -> accum\n                  ) mempty a)\n\n-- | Deserializes data types that are instances of \'IsSql99DataTypeSyntax\'\nsql99DataTypeDeserializers\n  :: forall be\n   . BeamMigrateSql99Backend be\n  => BeamDeserializers be\nsql99DataTypeDeserializers =\n  beamDeserializer $ \\d v ->\n  fmap (id @(BeamSqlBackendDataTypeSyntax be)) $\n  case v of\n    "clob" -> pure characterLargeObjectType\n    "blob" -> pure binaryLargeObjectType\n    _ -> withObject "Sql99DataType" (parseObject d) v\n  where\n    parseObject d v =\n      arrayType <$> (beamDeserialize d =<< v .: "of") <*> v .: "count" <|>\n      rowType <$> (do rowTypes <- v .: "row"\n                      let parseArray a =\n                            forM (V.toList a) $ \\a\' -> do\n                            (nm, a\'\') <- parseJSON a\'\n                            (nm,) <$> beamDeserialize d a\'\'\n                      withArray "Sql99DataType.rowType" parseArray rowTypes)\n\n-- | Deserialize data types that are instances of \'IsSql2003BinaryAndVarBinaryDataTypeSyntax\'\nsql2003BinaryAndVarBinaryDataTypeDeserializers\n  :: forall be\n   . ( BeamMigrateSqlBackend be, BeamSqlT021Backend be )\n  => BeamDeserializers be\nsql2003BinaryAndVarBinaryDataTypeDeserializers =\n  beamDeserializer $ \\_ v ->\n  fmap (id @(BeamSqlBackendDataTypeSyntax be)) $\n  withObject "Sql2003DataType"\n    (\\o -> (binaryType <$> o .: "binary") <|>\n           (varBinaryType <$> o .: "varbinary"))\n    v\n\n-- | Deserialize data types that are instance of \'IsSql2008BigIntDataTypeSyntax\'\nsql2008BigIntDataTypeDeserializers\n  :: forall be\n   . ( BeamMigrateSqlBackend be, BeamSqlT071Backend be )\n  => BeamDeserializers be\nsql2008BigIntDataTypeDeserializers =\n  beamDeserializer $ \\_ v ->\n  fmap (id @(BeamSqlBackendDataTypeSyntax be)) $\n  case v of\n    "bigint" -> pure bigIntType\n    _ -> fail "Sql2008DataType.bigint: expected \'bigint\'"\n\n-- $serialization\n--   Below we provide various instances of Beam SQL syntax types that produce an\n--   aeson \'Value\' that reflects the call tree. This allows us to read back\n--   these data types in various syntaxes.\n--\n--   Because these are formatted as standard beam syntaxes, backends can easily\n--   serialize their data to disk. For an example of what we mean by this, see\n--   the instance of \'IsSql92DataTypeSyntax\' for \'SqliteDataTypeSyntax\' in\n--   @beam-sqlite@.\n\n\n-- $deserialization\n--\n--   Deserialization requires that knowledge of every type of data we can\n--   deserialize is stored in one place. While this is not much of an issue when\n--   compiling full Haskell applications, due to the type class mechanism,\n--   beam-migrate tools load backends dynamically. This means that we need a\n--   separate way to discover deserialization instances for types we care about.\n--\n--   Values of the \'BeamDeserializers\' type represent a set of deserializers all\n--   related to one kind of command syntax. You can ask for the deserializers to\n--   deserialize any type from an aeson \'Value\'. The deserialization will\n--   succeed only if a deserializer for the requested type exists and the\n--   deserializer was able to parse the \'Value\'.\n--\n--   \'BeamDeserializers\' compose monoidally. Thus, you can extend any\n--   \'BeamDeserializers\' with your own custom deserializers, by \'mappend\'ing it\n--   with a new \'BeamDeserializers\', created by calling \'beamDeserializer\'.\n'