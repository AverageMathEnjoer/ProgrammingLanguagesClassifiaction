b'package effectivejava.chapter4.item17;\n\n// Immutable complex number class (Pages 81-82)\npublic final class Complex {\n    private final double re;\n    private final double im;\n\n    public static final Complex ZERO = new Complex(0, 0);\n    public static final Complex ONE  = new Complex(1, 0);\n    public static final Complex I    = new Complex(0, 1);\n\n    public Complex(double re, double im) {\n        this.re = re;\n        this.im = im;\n    }\n\n    public double realPart()      { return re; }\n    public double imaginaryPart() { return im; }\n\n    public Complex plus(Complex c) {\n        return new Complex(re + c.re, im + c.im);\n    }\n\n    // Static factory, used in conjunction with private constructor (Page 85)\n    public static Complex valueOf(double re, double im) {\n        return new Complex(re, im);\n    }\n\n    public Complex minus(Complex c) {\n        return new Complex(re - c.re, im - c.im);\n    }\n\n    public Complex times(Complex c) {\n        return new Complex(re * c.re - im * c.im,\n                re * c.im + im * c.re);\n    }\n\n    public Complex dividedBy(Complex c) {\n        double tmp = c.re * c.re + c.im * c.im;\n        return new Complex((re * c.re + im * c.im) / tmp,\n                (im * c.re - re * c.im) / tmp);\n    }\n\n    @Override public boolean equals(Object o) {\n        if (o == this)\n            return true;\n        if (!(o instanceof Complex))\n            return false;\n        Complex c = (Complex) o;\n\n        // See page 47 to find out why we use compare instead of ==\n        return Double.compare(c.re, re) == 0\n                && Double.compare(c.im, im) == 0;\n    }\n    @Override public int hashCode() {\n        return 31 * Double.hashCode(re) + Double.hashCode(im);\n    }\n\n    @Override public String toString() {\n        return "(" + re + " + " + im + "i)";\n    }\n}\n'