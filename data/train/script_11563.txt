b'//2d sparse table for max\n//0 based index\n//LGN = 1 + lg2(N)\n//LGM = 1 + lg2(M)\n\nconst int N = 1030;\nconst int M = 1030;\nconst int LGN = 11;\nconst int LGM = 11;\n\nint a[N][M];\nint dp[N][M][LGN][LGM];\nconst int MAXN = 2e6; //max(N, M)\nint lg2[MAXN];\nvoid pre(){\n\t//build lg2\n\tlg2[1] = log2(1);\n\tlg2[2] = log2(2);\n\tint val = 1, at = 4;\n\tint i;\n\tFo(i, 3, MAXN){\n\t\tif (i == at){\n\t\t\tat *= 2;\n\t\t\tval++;\n\t\t}\n\t\tlg2[i] = log2(i);\n\t}\n}\nvoid build(int n, int m){\n\tpre();\n\tfor(int i = 1; i <= n; ++ i) for(int j = 1; j <= m; ++ j) dp[i][j][0][0] = a[i-1][j-1];\n\tfor(int j1 = 0; (1 << j1) <= n; ++ j1) {\n\t\tfor(int j2 = 0; (1 << j2) <= m; ++ j2) if(j1 || j2) {\n\t\t\tfor(int i1 = 1; i1 + (1 << j1) - 1 <= n; ++ i1) {\n\t\t\t\tfor(int i2 = 1; i2 + (1 << j2) - 1 <= m; ++ i2) {\n\t\t\t\t\tif(j1) dp[i1][i2][j1][j2] = max(dp[i1][i2][j1 - 1][j2], dp[i1 + (1 << (j1 - 1))][i2][j1 - 1][j2]);\n\t\t\t\t\telse dp[i1][i2][j1][j2] = max(dp[i1][i2][j1][j2 - 1], dp[i1][i2 + (1 << (j2 - 1))][j1][j2 - 1]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint query(int x1, int Y1, int x2, int y2){\n\tint k1 = lg2[x2-x1+1];\n\tint k2 = lg2[y2-Y1+1];\n\treturn max(max(dp[x1][Y1][k1][k2], dp[x2 - (1 << k1) + 1][y2 - (1 << k2) + 1][k1][k2]),\n\t\t\tmax(dp[x2 - (1 << k1) + 1][Y1][k1][k2], dp[x1][y2 - (1 << k2) + 1][k1][k2]));\n}\n'