b"{-# LANGUAGE FunctionalDependencies #-}\n{-# LANGUAGE UndecidableInstances #-}\n{-# LANGUAGE CPP #-}\n\n-- | Allows the creation of custom SQL expressions from arbitrary string-like values.\n--\n--   Simply write a polymorphic function with an arbitrary number of arguments,\n--   all of the same type, and returns a value of the same type. The type will\n--   have instances of 'Monoid' and 'IsString'.\n--\n--   For example, to implement a function @MYFUNC@ that takes three arguments\n--\n-- @\n-- myFuncImpl :: (Monoid a, IsString a) => a -> a -> a -> a\n-- @\n--\n--   Then, apply 'customExpr_' to your function.  This will result in a function\n--   with the same arity, that takes in and returns 'QGenExpr's instead of\n--   generic @a@s.\n--\n--   The returned function is polymorphic in the types of SQL expressions it\n--   will accept, but you can give it a more specific signature. For example, to\n--   mandate that we receive two 'Int32's and a 'T.Text' and return a 'Bool'.\n--\n-- @\n-- myFunc_ :: QGenExpr e ctxt s Int32 -> QGenExpr e ctxt s Int32 -> QGenExpr e ctxt s T.Text -> QGenExpr e ctxt s Bool\n-- myFunc_ = customExpr_ myFuncImpl\n-- @\n--\n--   Semantically, the expression builder function (@myFuncImpl@ in this case)\n--   is called with arguments representing SQL expressions, that, when\n--   evaluated, will evaluate to the result of the expressions supplied as\n--   arguments to 'customExpr_'. See the section on\n--   <https://haskell-beam.github.io/beam/user-guide/extensibility/extensibility>\n--   in the user guide for example usage.\nmodule Database.Beam.Query.CustomSQL\n  (\n  -- * The 'customExpr_' function\n  IsCustomExprFn(..)\n\n  -- ** Type-inference help\n  , valueExpr_, agg_\n\n  -- * For backends\n  , IsCustomSqlSyntax(..) ) where\n\nimport           Database.Beam.Query.Internal\nimport           Database.Beam.Backend.SQL\nimport           Database.Beam.Backend.SQL.Builder\n\nimport           Data.ByteString (ByteString)\nimport           Data.ByteString.Builder (byteString, toLazyByteString)\nimport           Data.ByteString.Lazy (toStrict)\n\nimport           Data.Kind (Type)\nimport           Data.String\nimport qualified Data.Text as T\n\n-- | A type-class for expression syntaxes that can embed custom expressions.\nclass (Monoid (CustomSqlSyntax syntax), Semigroup (CustomSqlSyntax syntax), IsString (CustomSqlSyntax syntax)) =>\n  IsCustomSqlSyntax syntax where\n  data CustomSqlSyntax syntax :: Type\n\n  -- | Given an arbitrary string-like expression, produce a 'syntax' that represents the\n  --   'ByteString' as a SQL expression.\n  customExprSyntax :: CustomSqlSyntax syntax -> syntax\n\n  -- | Given an arbitrary 'syntax', produce a string-like value that corresponds to\n  --   how that syntax would look when rendered in the backend.\n  renderSyntax :: syntax -> CustomSqlSyntax syntax\n\ninstance IsCustomSqlSyntax SqlSyntaxBuilder where\n  newtype CustomSqlSyntax SqlSyntaxBuilder = SqlSyntaxBuilderCustom ByteString\n    deriving (IsString, Monoid, Semigroup)\n\n  customExprSyntax (SqlSyntaxBuilderCustom bs) = SqlSyntaxBuilder (byteString bs)\n  renderSyntax = SqlSyntaxBuilderCustom . toStrict . toLazyByteString . buildSql\n\nnewtype CustomSqlSnippet be = CustomSqlSnippet (T.Text -> CustomSqlSyntax (BeamSqlBackendExpressionSyntax be))\ninstance IsCustomSqlSyntax (BeamSqlBackendExpressionSyntax be) => Semigroup (CustomSqlSnippet be) where\n  CustomSqlSnippet a <> CustomSqlSnippet b =\n    CustomSqlSnippet $ \\pfx -> a pfx <> b pfx\ninstance IsCustomSqlSyntax (BeamSqlBackendExpressionSyntax be) => Monoid (CustomSqlSnippet be) where\n  mempty = CustomSqlSnippet (pure mempty)\n  mappend = (<>)\n\ninstance IsCustomSqlSyntax (BeamSqlBackendExpressionSyntax be) => IsString (CustomSqlSnippet be) where\n  fromString s = CustomSqlSnippet $ \\_ -> fromString s\n\nclass IsCustomExprFn fn res | res -> fn where\n  customExpr_ :: fn -> res\n\ntype BeamSqlBackendHasCustomSyntax be = IsCustomSqlSyntax (BeamSqlBackendExpressionSyntax be)\n\ninstance BeamSqlBackendHasCustomSyntax be => IsCustomExprFn (CustomSqlSnippet be) (QGenExpr ctxt be s res) where\n  customExpr_ (CustomSqlSnippet mkSyntax) = QExpr (customExprSyntax . mkSyntax)\n\ninstance (IsCustomExprFn a res, BeamSqlBackendHasCustomSyntax be) =>\n  IsCustomExprFn (CustomSqlSnippet be -> a) (QGenExpr ctxt be s r -> res) where\n  customExpr_ fn (QExpr e) = customExpr_ $ fn (CustomSqlSnippet (renderSyntax . e))\n\n-- | Force a 'QGenExpr' to be typed as a value expression (a 'QExpr'). Useful\n--   for getting around type-inference errors with supplying the entire type.\nvalueExpr_ :: QExpr be s a -> QExpr be s a\nvalueExpr_ = id\n\n-- | Force a 'QGenExpr' to be typed as an aggregate. Useful for defining custom\n--   aggregates for use in 'aggregate_'.\nagg_ :: QAgg be s a -> QAgg be s a\nagg_ = id\n"