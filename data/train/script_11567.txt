b'package droidninja.filepicker.views\n\nimport android.animation.ValueAnimator\nimport android.annotation.TargetApi\nimport android.content.Context\nimport android.content.res.TypedArray\nimport android.graphics.Canvas\nimport android.graphics.Color\nimport android.graphics.Paint\nimport android.graphics.Path\nimport android.graphics.Point\nimport android.os.Build\nimport android.os.Bundle\nimport android.os.Parcelable\nimport android.util.AttributeSet\nimport android.view.View\nimport android.view.animation.LinearInterpolator\nimport android.widget.Checkable\n\nimport droidninja.filepicker.R\n\n\nclass SmoothCheckBox : View, Checkable {\n\n    private var mPaint: Paint? = null\n    private var mTickPaint: Paint? = null\n    private var mFloorPaint: Paint? = null\n    private var mTickPoints: Array<Point>? = null\n    private var mCenterPoint: Point? = null\n    private var mTickPath: Path? = null\n    private var mLeftLineDistance: Float = 0.toFloat()\n    private var mRightLineDistance: Float = 0.toFloat()\n    private var mDrewDistance: Float = 0.toFloat()\n    private var mScaleVal = 1.0f\n    private var mFloorScale = 1.0f\n    private var mWidth: Int = 0\n    private var mAnimDuration: Int = 0\n    private var mStrokeWidth: Int = 0\n    private var mCheckedColor: Int = 0\n    private var mUnCheckedColor: Int = 0\n    private var mFloorColor: Int = 0\n    private var mFloorUnCheckedColor: Int = 0\n    private var mChecked: Boolean = false\n    private var mTickDrawing: Boolean = false\n    private var mListener: OnCheckedChangeListener? = null\n\n    @JvmOverloads constructor(context: Context, attrs: AttributeSet? = null, defStyleAttr: Int = 0) : super(context, attrs, defStyleAttr) {\n        init(attrs)\n    }\n\n    @TargetApi(Build.VERSION_CODES.LOLLIPOP)\n    constructor(context: Context, attrs: AttributeSet, defStyleAttr: Int, defStyleRes: Int) : super(context, attrs, defStyleAttr, defStyleRes) {\n        init(attrs)\n    }\n\n    private fun init(attrs: AttributeSet?) {\n\n        val ta = context.obtainStyledAttributes(attrs, R.styleable.SmoothCheckBox)\n        val tickColor = ta.getColor(R.styleable.SmoothCheckBox_color_tick, COLOR_TICK)\n        mAnimDuration = ta.getInt(R.styleable.SmoothCheckBox_duration, DEF_ANIM_DURATION)\n        mFloorColor = ta.getColor(R.styleable.SmoothCheckBox_color_unchecked_stroke, COLOR_FLOOR_UNCHECKED)\n        mCheckedColor = ta.getColor(R.styleable.SmoothCheckBox_color_checked, COLOR_CHECKED)\n        mUnCheckedColor = ta.getColor(R.styleable.SmoothCheckBox_color_unchecked, COLOR_UNCHECKED)\n        mStrokeWidth = ta.getDimensionPixelSize(R.styleable.SmoothCheckBox_stroke_width,\n                dp2px(context, 0f))\n        ta.recycle()\n\n        mFloorUnCheckedColor = mFloorColor\n        mTickPaint = Paint(Paint.ANTI_ALIAS_FLAG)\n        mTickPaint!!.style = Paint.Style.STROKE\n        mTickPaint!!.strokeCap = Paint.Cap.ROUND\n        mTickPaint!!.color = tickColor\n\n        mFloorPaint = Paint(Paint.ANTI_ALIAS_FLAG)\n        mFloorPaint!!.style = Paint.Style.FILL\n        mFloorPaint!!.color = mFloorColor\n\n        mPaint = Paint(Paint.ANTI_ALIAS_FLAG)\n        mPaint!!.style = Paint.Style.FILL\n        mPaint!!.color = mCheckedColor\n\n        mTickPath = Path()\n        mCenterPoint = Point()\n        mTickPoints = arrayOf(Point(),Point(),Point())\n\n        setOnClickListener {\n            toggle()\n            mTickDrawing = false\n            mDrewDistance = 0f\n            if (isChecked) {\n                startCheckedAnimation()\n            } else {\n                startUnCheckedAnimation()\n            }\n        }\n    }\n\n    override fun onSaveInstanceState(): Parcelable? {\n        val bundle = Bundle()\n        bundle.putParcelable(KEY_INSTANCE_STATE, super.onSaveInstanceState())\n        bundle.putBoolean(KEY_INSTANCE_STATE, isChecked)\n        return bundle\n    }\n\n    override fun onRestoreInstanceState(state: Parcelable) {\n        if (state is Bundle) {\n            val isChecked = state.getBoolean(KEY_INSTANCE_STATE)\n            setChecked(isChecked)\n            super.onRestoreInstanceState(state.getParcelable(KEY_INSTANCE_STATE))\n            return\n        }\n        super.onRestoreInstanceState(state)\n    }\n\n    override fun isChecked(): Boolean {\n        return mChecked\n    }\n\n    override fun toggle() {\n        this.isChecked = !isChecked\n    }\n\n    override fun setChecked(checked: Boolean) {\n        mChecked = checked\n        reset()\n        invalidate()\n        if (mListener != null) {\n            mListener!!.onCheckedChanged(this@SmoothCheckBox, mChecked)\n        }\n    }\n\n    /**\n     *\n     * checked with animation\n     * @param checked checked\n     * @param animate change with animation\n     */\n    fun setChecked(checked: Boolean, animate: Boolean) {\n        if (animate) {\n            mTickDrawing = false\n            mChecked = checked\n            mDrewDistance = 0f\n            if (checked) {\n                startCheckedAnimation()\n            } else {\n                startUnCheckedAnimation()\n            }\n            if (mListener != null) {\n                mListener!!.onCheckedChanged(this@SmoothCheckBox, mChecked)\n            }\n\n        } else {\n            this.isChecked = checked\n        }\n    }\n\n    private fun reset() {\n        mTickDrawing = true\n        mFloorScale = 1.0f\n        mScaleVal = if (isChecked) 0f else 1.0f\n        mFloorColor = if (isChecked) mCheckedColor else mFloorUnCheckedColor\n        mDrewDistance = if (isChecked) mLeftLineDistance + mRightLineDistance else 0f\n    }\n\n    private fun measureSize(measureSpec: Int): Int {\n        val defSize = dp2px(context, DEF_DRAW_SIZE.toFloat())\n        val specSize = View.MeasureSpec.getSize(measureSpec)\n        val specMode = View.MeasureSpec.getMode(measureSpec)\n\n        var result = 0\n        when (specMode) {\n            View.MeasureSpec.UNSPECIFIED, View.MeasureSpec.AT_MOST -> result = Math.min(defSize, specSize)\n            View.MeasureSpec.EXACTLY -> result = specSize\n        }\n        return result\n    }\n\n    override fun onMeasure(widthMeasureSpec: Int, heightMeasureSpec: Int) {\n        super.onMeasure(widthMeasureSpec, heightMeasureSpec)\n        setMeasuredDimension(measureSize(widthMeasureSpec), measureSize(heightMeasureSpec))\n    }\n\n    override fun onLayout(changed: Boolean, left: Int, top: Int, right: Int, bottom: Int) {\n        mWidth = measuredWidth\n        mStrokeWidth = if (mStrokeWidth == 0) measuredWidth / 10 else mStrokeWidth\n        mStrokeWidth = if (mStrokeWidth > measuredWidth / 5) measuredWidth / 5 else mStrokeWidth\n        mStrokeWidth = if (mStrokeWidth < 3) 3 else mStrokeWidth\n        mCenterPoint!!.x = mWidth / 2\n        mCenterPoint!!.y = measuredHeight / 2\n\n        mTickPoints!![0].x = Math.round(measuredWidth.toFloat() / 30 * 7)\n        mTickPoints!![0].y = Math.round(measuredHeight.toFloat() / 30 * 14)\n        mTickPoints!![1].x = Math.round(measuredWidth.toFloat() / 30 * 13)\n        mTickPoints!![1].y = Math.round(measuredHeight.toFloat() / 30 * 20)\n        mTickPoints!![2].x = Math.round(measuredWidth.toFloat() / 30 * 22)\n        mTickPoints!![2].y = Math.round(measuredHeight.toFloat() / 30 * 10)\n\n        mLeftLineDistance = Math.sqrt(Math.pow((mTickPoints!![1].x - mTickPoints!![0].x).toDouble(), 2.0) + Math.pow((mTickPoints!![1].y - mTickPoints!![0].y).toDouble(), 2.0)).toFloat()\n        mRightLineDistance = Math.sqrt(Math.pow((mTickPoints!![2].x - mTickPoints!![1].x).toDouble(), 2.0) + Math.pow((mTickPoints!![2].y - mTickPoints!![1].y).toDouble(), 2.0)).toFloat()\n        mTickPaint!!.strokeWidth = mStrokeWidth.toFloat()\n    }\n\n    override fun onDraw(canvas: Canvas) {\n        drawBorder(canvas)\n        drawCenter(canvas)\n        drawTick(canvas)\n    }\n\n    private fun drawCenter(canvas: Canvas) {\n        mPaint!!.color = mUnCheckedColor\n        val radius = (mCenterPoint!!.x - mStrokeWidth) * mScaleVal\n        canvas.drawCircle(mCenterPoint!!.x.toFloat(), mCenterPoint!!.y.toFloat(), radius, mPaint!!)\n    }\n\n    private fun drawBorder(canvas: Canvas) {\n        mFloorPaint!!.color = mFloorColor\n        val radius = mCenterPoint!!.x\n        canvas.drawCircle(mCenterPoint!!.x.toFloat(), mCenterPoint!!.y.toFloat(), radius * mFloorScale, mFloorPaint!!)\n    }\n\n    private fun drawTick(canvas: Canvas) {\n        if (mTickDrawing && isChecked) {\n            drawTickPath(canvas)\n        }\n    }\n\n    private fun drawTickPath(canvas: Canvas) {\n        mTickPath!!.reset()\n        // draw left of the tick\n        if (mDrewDistance < mLeftLineDistance) {\n            val step = if (mWidth / 20.0f < 3) 3f else mWidth / 20.0f\n            mDrewDistance += step\n            val stopX = mTickPoints!![0].x + (mTickPoints!![1].x - mTickPoints!![0].x) * mDrewDistance / mLeftLineDistance\n            val stopY = mTickPoints!![0].y + (mTickPoints!![1].y - mTickPoints!![0].y) * mDrewDistance / mLeftLineDistance\n\n            mTickPath!!.moveTo(mTickPoints!![0].x.toFloat(), mTickPoints!![0].y.toFloat())\n            mTickPath!!.lineTo(stopX, stopY)\n            canvas.drawPath(mTickPath!!, mTickPaint!!)\n\n            if (mDrewDistance > mLeftLineDistance) {\n                mDrewDistance = mLeftLineDistance\n            }\n        } else {\n\n            mTickPath!!.moveTo(mTickPoints!![0].x.toFloat(), mTickPoints!![0].y.toFloat())\n            mTickPath!!.lineTo(mTickPoints!![1].x.toFloat(), mTickPoints!![1].y.toFloat())\n            canvas.drawPath(mTickPath!!, mTickPaint!!)\n\n            // draw right of the tick\n            if (mDrewDistance < mLeftLineDistance + mRightLineDistance) {\n                val stopX = mTickPoints!![1].x + (mTickPoints!![2].x - mTickPoints!![1].x) * (mDrewDistance - mLeftLineDistance) / mRightLineDistance\n                val stopY = mTickPoints!![1].y - (mTickPoints!![1].y - mTickPoints!![2].y) * (mDrewDistance - mLeftLineDistance) / mRightLineDistance\n\n                mTickPath!!.reset()\n                mTickPath!!.moveTo(mTickPoints!![1].x.toFloat(), mTickPoints!![1].y.toFloat())\n                mTickPath!!.lineTo(stopX, stopY)\n                canvas.drawPath(mTickPath!!, mTickPaint!!)\n\n                val step = (if (mWidth / 20 < 3) 3 else mWidth / 20).toFloat()\n                mDrewDistance += step\n            } else {\n                mTickPath!!.reset()\n                mTickPath!!.moveTo(mTickPoints!![1].x.toFloat(), mTickPoints!![1].y.toFloat())\n                mTickPath!!.lineTo(mTickPoints!![2].x.toFloat(), mTickPoints!![2].y.toFloat())\n                canvas.drawPath(mTickPath!!, mTickPaint!!)\n            }\n        }\n\n        // invalidate\n        if (mDrewDistance < mLeftLineDistance + mRightLineDistance) {\n            postDelayed({ postInvalidate() }, 10)\n        }\n    }\n\n    private fun startCheckedAnimation() {\n        val animator = ValueAnimator.ofFloat(1.0f, 0f)\n        animator.duration = (mAnimDuration / 3 * 2).toLong()\n        animator.interpolator = LinearInterpolator()\n        animator.addUpdateListener { animation ->\n            mScaleVal = animation.animatedValue as Float\n            mFloorColor = getGradientColor(mUnCheckedColor, mCheckedColor, 1 - mScaleVal)\n            postInvalidate()\n        }\n        animator.start()\n\n        val floorAnimator = ValueAnimator.ofFloat(1.0f, 0.8f, 1.0f)\n        floorAnimator.duration = mAnimDuration.toLong()\n        floorAnimator.interpolator = LinearInterpolator()\n        floorAnimator.addUpdateListener { animation ->\n            mFloorScale = animation.animatedValue as Float\n            postInvalidate()\n        }\n        floorAnimator.start()\n\n        drawTickDelayed()\n    }\n\n    private fun startUnCheckedAnimation() {\n        val animator = ValueAnimator.ofFloat(0f, 1.0f)\n        animator.duration = mAnimDuration.toLong()\n        animator.interpolator = LinearInterpolator()\n        animator.addUpdateListener { animation ->\n            mScaleVal = animation.animatedValue as Float\n            mFloorColor = getGradientColor(mCheckedColor, COLOR_FLOOR_UNCHECKED, mScaleVal)\n            postInvalidate()\n        }\n        animator.start()\n\n        val floorAnimator = ValueAnimator.ofFloat(1.0f, 0.8f, 1.0f)\n        floorAnimator.duration = mAnimDuration.toLong()\n        floorAnimator.interpolator = LinearInterpolator()\n        floorAnimator.addUpdateListener { animation ->\n            mFloorScale = animation.animatedValue as Float\n            postInvalidate()\n        }\n        floorAnimator.start()\n    }\n\n    private fun drawTickDelayed() {\n        postDelayed({\n            mTickDrawing = true\n            postInvalidate()\n        }, mAnimDuration.toLong())\n    }\n\n    fun setOnCheckedChangeListener(l: OnCheckedChangeListener?) {\n        this.mListener = l\n    }\n\n    interface OnCheckedChangeListener {\n        fun onCheckedChanged(checkBox: SmoothCheckBox, isChecked: Boolean)\n    }\n\n    fun dp2px(context: Context, dipValue: Float): Int {\n        val scale = context.resources.displayMetrics.density\n        return (dipValue * scale + 0.5f).toInt()\n    }\n\n    companion object {\n        private val KEY_INSTANCE_STATE = "InstanceState"\n        private val COLOR_TICK = Color.WHITE\n        private val COLOR_UNCHECKED = Color.WHITE\n        private val COLOR_CHECKED = Color.parseColor("#FB4846")\n        private val COLOR_FLOOR_UNCHECKED = Color.parseColor("#DFDFDF")\n        private val DEF_DRAW_SIZE = 25\n        private val DEF_ANIM_DURATION = 300\n\n        private fun getGradientColor(startColor: Int, endColor: Int, percent: Float): Int {\n            val sr = startColor and 0xff0000 shr 0x10\n            val sg = startColor and 0xff00 shr 0x8\n            val sb = startColor and 0xff\n\n            val er = endColor and 0xff0000 shr 0x10\n            val eg = endColor and 0xff00 shr 0x8\n            val eb = endColor and 0xff\n\n            val cr = (sr * (1 - percent) + er * percent).toInt()\n            val cg = (sg * (1 - percent) + eg * percent).toInt()\n            val cb = (sb * (1 - percent) + eb * percent).toInt()\n            return Color.argb(0xff, cr, cg, cb)\n        }\n    }\n}'