b'// UVa1642 Magical GCD\n// Rujia Liu\n#include<cstdio>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\ntypedef long long LL;\n\nstruct Item {\n  LL g; // gcd\n  int p; // starting pos\n  Item(LL g=0, int p=0):g(g),p(p){}\n  bool operator < (const Item& rhs) const {\n    return g < rhs.g || (g == rhs.g && p < rhs.p);\n  }\n};\n\nLL gcd(LL a, LL b) { return b == 0 ? a : gcd(b, a%b); }\n\nconst int maxn = 100000 + 5;\n\nLL A[maxn];\nint n;\n\nint main() {\n  int T;\n  scanf("%d", &T);\n  while(T--) {\n    scanf("%d", &n);\n    for(int i = 0; i < n; i++) scanf("%lld", &A[i]);\n    vector<Item> items;\n    LL ans = 0;\n    for(int j = 0; j < n; j++) { // enumerate end pos\n      items.push_back(Item(0, j));\n      for(int k = 0; k < items.size(); k++)\n        items[k].g = gcd(items[k].g, A[j]); // update items\' gcd\n      sort(items.begin(), items.end());\n\n      // for each gcd, only keep smallest starting pos\n      vector<Item> newitems;\n      for(int k = 0; k < items.size(); k++)\n        if(k == 0 || items[k].g != items[k-1].g) { // different gcd\n          newitems.push_back(items[k]);\n          ans = max(ans, items[k].g * (j - items[k].p + 1));\n        }\n      items = newitems;\n    }\n    printf("%lld\\n", ans);\n  }\n  return 0;\n}\n'