b'-- | Core types and definitions\n{-# LANGUAGE DeriveGeneric #-}\n{-# LANGUAGE ExistentialQuantification #-}\n{-# LANGUAGE LambdaCase #-}\n{-# LANGUAGE RankNTypes #-}\nmodule Test.Tasty.Core\n  ( FailureReason(..)\n  , Outcome(..)\n  , Time\n  , Result(..)\n  , resultSuccessful\n  , exceptionResult\n  , Progress(..)\n  , IsTest(..)\n  , TestName\n  , ResourceSpec(..)\n  , ResourceError(..)\n  , DependencyType(..)\n  , TestTree(..)\n  , testGroup\n  , after\n  , after_\n  , TreeFold(..)\n  , trivialFold\n  , foldTestTree\n  , foldTestTree0\n  , treeOptions\n  ) where\n\nimport Control.Exception\nimport qualified Data.Map as Map\nimport qualified Data.Sequence as Seq\nimport Data.Tagged\nimport Data.Typeable\nimport GHC.Generics\nimport Test.Tasty.Options\nimport Test.Tasty.Patterns\nimport Test.Tasty.Patterns.Types\nimport Test.Tasty.Providers.ConsoleFormat\nimport Text.Printf\n\n-- | If a test failed, \'FailureReason\' describes why.\n--\n-- @since 0.8\ndata FailureReason\n  = TestFailed\n    -- ^ test provider indicated failure of the code to test, either because\n    -- the tested code returned wrong results, or raised an exception\n  | TestThrewException SomeException\n    -- ^ the test code itself raised an exception. Typical cases include missing\n    -- example input or output files.\n    --\n    -- Usually, providers do not have to implement this, as their \'run\' method\n    -- may simply raise an exception.\n  | TestTimedOut Integer\n    -- ^ test didn\'t complete in allotted time\n  | TestDepFailed -- See Note [Skipped tests]\n    -- ^ a dependency of this test failed, so this test was skipped.\n    --\n    -- @since 1.2\n  deriving Show\n\n-- | Outcome of a test run\n--\n-- Note: this is isomorphic to @\'Maybe\' \'FailureReason\'@. You can use the\n-- @generic-maybe@ package to exploit that.\n--\n-- @since 0.8\ndata Outcome\n  = Success -- ^ test succeeded\n  | Failure FailureReason -- ^ test failed because of the \'FailureReason\'\n  deriving (Show, Generic)\n\n-- | Time in seconds. Used to measure how long the tests took to run.\n--\n-- @since 0.10\ntype Time = Double\n\n-- | A test result.\n--\n-- @since 0.1\ndata Result = Result\n  { resultOutcome :: Outcome\n    -- ^ Did the test fail? If so, why?\n  , resultDescription :: String\n    -- ^\n    -- \'resultDescription\' may contain some details about the test. For\n    -- a passed test it\'s ok to leave it empty. Providers like SmallCheck and\n    -- QuickCheck use it to provide information about how many tests were\n    -- generated.\n    --\n    -- For a failed test, \'resultDescription\' should typically provide more\n    -- information about the failure.\n    --\n    -- @since 0.11\n  , resultShortDescription :: String\n    -- ^ The short description printed in the test run summary, usually @OK@ or\n    -- @FAIL@.\n    --\n    -- @since 0.10\n  , resultTime :: Time\n    -- ^ How long it took to run the test, in seconds.\n  , resultDetailsPrinter :: ResultDetailsPrinter\n    -- ^ An action that prints additional information about a test.\n    --\n    -- This is similar to \'resultDescription\' except it can produce\n    -- colorful/formatted output; see "Test.Tasty.Providers.ConsoleFormat".\n    --\n    -- This can be used instead of or in addition to \'resultDescription\'.\n    --\n    -- Usually this is set to \'noResultDetails\', which does nothing.\n    --\n    -- @since 1.3.1\n  }\n  deriving\n  ( Show -- ^ @since 1.2\n  )\n\n{- Note [Skipped tests]\n   ~~~~~~~~~~~~~~~~~~~~\n   There are two potential ways to represent the tests that are skipped\n   because of their failed dependencies:\n   1. With Outcome = Failure, and FailureReason giving the specifics (TestDepFailed)\n   2. With a dedicated Outcome = Skipped\n\n   It seems to me that (1) will lead to fewer bugs (esp. in the extension packages),\n   because most of the time skipped tests should be handled in the same way\n   as failed tests.\n   But sometimes it is not obvious what the right behavior should be. E.g.\n   should --hide-successes show or hide the skipped tests?\n\n   Perhaps we should hide them, because they aren\'t really informative.\n   Or perhaps we shouldn\'t hide them, because we are not sure that they\n   will pass, and hiding them will imply a false sense of security\n   ("there\'s at most 2 tests failing", whereas in fact there could be much more).\n\n   So I might change this in the future, but for now treating them as\n   failures seems the easiest yet reasonable approach.\n-}\n\n-- | \'True\' for a passed test, \'False\' for a failed one.\n--\n-- @since 0.8\nresultSuccessful :: Result -> Bool\nresultSuccessful r =\n  case resultOutcome r of\n    Success -> True\n    Failure {} -> False\n\n-- | Shortcut for creating a \'Result\' that indicates exception\nexceptionResult :: SomeException -> Result\nexceptionResult e = Result\n  { resultOutcome = Failure $ TestThrewException e\n  , resultDescription = "Exception: " ++ show e\n  , resultShortDescription = "FAIL"\n  , resultTime = 0\n  , resultDetailsPrinter = noResultDetails\n  }\n\n-- | Test progress information.\n--\n-- This may be used by a runner to provide some feedback to the user while\n-- a long-running test is executing.\n--\n-- @since 0.1\ndata Progress = Progress\n  { progressText :: String\n    -- ^ textual information about the test\'s progress\n  , progressPercent :: Float\n    -- ^\n    -- \'progressPercent\' should be a value between 0 and 1. If it\'s impossible\n    -- to compute the estimate, use 0.\n  }\n  deriving\n  ( Show -- ^ @since 1.2\n  )\n\n-- | The interface to be implemented by a test provider.\n--\n-- The type @t@ is the concrete representation of the test which is used by\n-- the provider.\n--\n-- @since 0.1\nclass Typeable t => IsTest t where\n  -- | Run the test\n  --\n  -- This method should cleanly catch any exceptions in the code to test, and\n  -- return them as part of the \'Result\', see \'FailureReason\' for an\n  -- explanation. It is ok for \'run\' to raise an exception if there is a\n  -- problem with the test suite code itself (for example, if a file that\n  -- should contain example data or expected output is not found).\n  run\n    :: OptionSet -- ^ options\n    -> t -- ^ the test to run\n    -> (Progress -> IO ()) -- ^ a callback to report progress.\n                           -- Note: the callback is a no-op at the moment\n                           -- and there are no plans to use it;\n                           -- feel free to ignore this argument for now.\n    -> IO Result\n\n  -- | The list of options that affect execution of tests of this type\n  testOptions :: Tagged t [OptionDescription]\n\n-- | The name of a test or a group of tests.\n--\n-- @since 0.1\ntype TestName = String\n\n-- | \'ResourceSpec\' describes how to acquire a resource (the first field)\n-- and how to release it (the second field).\n--\n-- @since 0.6\ndata ResourceSpec a = ResourceSpec (IO a) (a -> IO ())\n\n-- | A resources-related exception\ndata ResourceError\n  = NotRunningTests\n  | UnexpectedState String String\n  | UseOutsideOfTest\n  deriving Typeable\n\ninstance Show ResourceError where\n  show NotRunningTests =\n    "Unhandled resource. Probably a bug in the runner you\'re using."\n  show (UnexpectedState where_ what) =\n    printf "Unexpected state of the resource (%s) in %s. Report as a tasty bug."\n      what where_\n  show UseOutsideOfTest =\n    "It looks like you\'re attempting to use a resource outside of its test. Don\'t do that!"\n\ninstance Exception ResourceError\n\n-- | These are the two ways in which one test may depend on the others.\n--\n-- This is the same distinction as the\n-- <http://testng.org/doc/documentation-main.html#dependent-methods hard vs soft dependencies in TestNG>.\n--\n-- @since 1.2\ndata DependencyType\n  = AllSucceed\n    -- ^ The current test tree will be executed after its dependencies finish, and only\n    -- if all of the dependencies succeed.\n  | AllFinish\n    -- ^ The current test tree will be executed after its dependencies finish,\n    -- regardless of whether they succeed or not.\n  deriving (Eq, Show)\n\n-- | The main data structure defining a test suite.\n--\n-- It consists of individual test cases and properties, organized in named\n-- groups which form a tree-like hierarchy.\n--\n-- There is no generic way to create a test case. Instead, every test\n-- provider (tasty-hunit, tasty-smallcheck etc.) provides a function to\n-- turn a test case into a \'TestTree\'.\n--\n-- Groups can be created using \'testGroup\'.\n--\n-- @since 0.1\ndata TestTree\n  = forall t . IsTest t => SingleTest TestName t\n    -- ^ A single test of some particular type\n  | TestGroup TestName [TestTree]\n    -- ^ Assemble a number of tests into a cohesive group\n  | PlusTestOptions (OptionSet -> OptionSet) TestTree\n    -- ^ Add some options to child tests\n  | forall a . WithResource (ResourceSpec a) (IO a -> TestTree)\n    -- ^ Acquire the resource before the tests in the inner tree start and\n    -- release it after they finish. The tree gets an `IO` action which\n    -- yields the resource, although the resource is shared across all the\n    -- tests.\n    --\n    -- @since 0.5\n  | AskOptions (OptionSet -> TestTree)\n    -- ^ Ask for the options and customize the tests based on them.\n    --\n    -- @since 0.6\n  | After DependencyType Expr TestTree\n    -- ^ Only run after all tests that match a given pattern finish\n    -- (and, depending on the \'DependencyType\', succeed).\n    --\n    -- @since 1.2\n\n-- | Create a named group of test cases or other groups\n--\n-- @since 0.1\ntestGroup :: TestName -> [TestTree] -> TestTree\ntestGroup = TestGroup\n\n-- | Like \'after\', but accepts the pattern as a syntax tree instead\n-- of a string. Useful for generating a test tree programmatically.\n--\n-- ==== __Examples__\n--\n-- Only match on the test\'s own name, ignoring the group names:\n--\n-- @\n-- \'after_\' \'AllFinish\' (\'Test.Tasty.Patterns.Types.EQ\' (\'Field\' \'NF\') (\'StringLit\' \\"Bar\\")) $\n--    @testCase@ \\"A test that depends on Foo.Bar\\" $ ...\n-- @\n--\n-- @since 1.2\nafter_\n  :: DependencyType -- ^ whether to run the tests even if some of the dependencies fail\n  -> Expr -- ^ the pattern\n  -> TestTree -- ^ the subtree that depends on other tests\n  -> TestTree -- ^ the subtree annotated with dependency information\nafter_ = After\n\n-- | The \'after\' combinator declares dependencies between tests.\n--\n-- If a \'TestTree\' is wrapped in \'after\', the tests in this tree will not run\n-- until certain other tests (\xc2\xabdependencies\xc2\xbb) have finished. These\n-- dependencies are specified using an AWK pattern (see the \xc2\xabPatterns\xc2\xbb section\n-- in the README).\n--\n-- Moreover, if the \'DependencyType\' argument is set to \'AllSucceed\' and\n-- at least one dependency has failed, this test tree will not run at all.\n--\n-- Tasty does not check that the pattern matches any tests (let alone the\n-- correct set of tests), so it is on you to supply the right pattern.\n--\n-- ==== __Examples__\n--\n-- The following test will be executed only after all tests that contain\n-- @Foo@ anywhere in their path finish.\n--\n-- @\n-- \'after\' \'AllFinish\' \\"Foo\\" $\n--    @testCase@ \\"A test that depends on Foo.Bar\\" $ ...\n-- @\n--\n-- Note, however, that our test also happens to contain @Foo@ as part of its name,\n-- so it also matches the pattern and becomes a dependency of itself. This\n-- will result in a \'Test.Tasty.DependencyLoop\' exception. To avoid this, either\n-- change the test name so that it doesn\'t mention @Foo@ or make the\n-- pattern more specific.\n--\n-- You can use AWK patterns, for instance, to specify the full path to the dependency.\n--\n-- @\n-- \'after\' \'AllFinish\' \\"$0 == \\\\\\"Tests.Foo.Bar\\\\\\"\\" $\n--    @testCase@ \\"A test that depends on Foo.Bar\\" $ ...\n-- @\n--\n-- Or only specify the dependency\'s own name, ignoring the group names:\n--\n-- @\n-- \'after\' \'AllFinish\' \\"$NF == \\\\\\"Bar\\\\\\"\\" $\n--    @testCase@ \\"A test that depends on Foo.Bar\\" $ ...\n-- @\n--\n-- @since 1.2\nafter\n  :: DependencyType -- ^ whether to run the tests even if some of the dependencies fail\n  -> String -- ^ the pattern\n  -> TestTree -- ^ the subtree that depends on other tests\n  -> TestTree -- ^ the subtree annotated with dependency information\nafter deptype s =\n  case parseExpr s of\n    Nothing -> error $ "Could not parse pattern " ++ show s\n    Just e -> after_ deptype e\n\n-- | An algebra for folding a `TestTree`.\n--\n-- Instead of constructing fresh records, build upon `trivialFold`\n-- instead. This way your code won\'t break when new nodes/fields are\n-- indroduced.\n--\n-- @since 0.7\ndata TreeFold b = TreeFold\n  { foldSingle :: forall t . IsTest t => OptionSet -> TestName -> t -> b\n  , foldGroup :: OptionSet -> TestName -> [b] -> b\n  -- ^ @since 1.4\n  , foldResource :: forall a . OptionSet -> ResourceSpec a -> (IO a -> b) -> b\n  , foldAfter :: OptionSet -> DependencyType -> Expr -> b -> b\n  -- ^ @since 1.2\n  }\n\n-- | \'trivialFold\' can serve as the basis for custom folds. Just override\n-- the fields you need.\n--\n-- Here\'s what it does:\n--\n-- * single tests are mapped to `mempty` (you probably do want to override that)\n--\n-- * test groups are returned unmodified\n--\n-- * for a resource, an IO action that throws an exception is passed (you\n-- want to override this for runners/ingredients that execute tests)\n--\n-- @since 0.7\ntrivialFold :: Monoid b => TreeFold b\ntrivialFold = TreeFold\n  { foldSingle = \\_ _ _ -> mempty\n  , foldGroup = \\_ _ bs -> mconcat bs\n  , foldResource = \\_ _ f -> f $ throwIO NotRunningTests\n  , foldAfter = \\_ _ _ b -> b\n  }\n\n-- | Fold a test tree into a single value.\n--\n-- The fold result type should be a monoid. This is used to fold multiple\n-- results in a test group. In particular, empty groups get folded into \'mempty\'.\n--\n-- Apart from pure convenience, this function also does the following\n-- useful things:\n--\n-- 1. Keeping track of the current options (which may change due to\n-- `PlusTestOptions` nodes)\n--\n-- 2. Filtering out the tests which do not match the patterns\n--\n-- Thus, it is preferred to an explicit recursive traversal of the tree.\n--\n-- @since 0.7\nfoldTestTree\n  :: forall b . Monoid b\n  => TreeFold b\n     -- ^ the algebra (i.e. how to fold a tree)\n  -> OptionSet\n     -- ^ initial options\n  -> TestTree\n     -- ^ the tree to fold\n  -> b\nfoldTestTree = foldTestTree0 mempty\n\n-- | Like \'foldTestTree\', but with a custom (non-Monoid) empty value. Unlike\n-- \'foldTestTree\', it is not part of the public API.\nfoldTestTree0\n  :: forall b\n   . b\n     -- ^ "empty" value\n  -> TreeFold b\n     -- ^ the algebra (i.e. how to fold a tree)\n  -> OptionSet\n     -- ^ initial options\n  -> TestTree\n     -- ^ the tree to fold\n  -> b\nfoldTestTree0 empty (TreeFold fTest fGroup fResource fAfter) opts0 tree0 =\n  go (filterByPattern (evaluateOptions opts0 tree0))\n  where\n    go :: AnnTestTree OptionSet -> b\n    go = \\case\n      AnnEmptyTestTree               -> empty\n      AnnSingleTest opts name test   -> fTest opts name test\n      AnnTestGroup opts name trees   -> fGroup opts name (map go trees)\n      AnnWithResource opts res0 tree -> fResource opts res0 $ \\res -> go (tree res)\n      AnnAfter opts deptype dep tree -> fAfter opts deptype dep (go tree)\n\n-- | \'TestTree\' with arbitrary annotations, e. g., evaluated \'OptionSet\'.\ndata AnnTestTree ann\n  = AnnEmptyTestTree\n  -- ^ Just an empty test tree (e. g., when everything has been filtered out).\n  | forall t . IsTest t => AnnSingleTest ann TestName t\n  -- ^ Annotated counterpart of \'SingleTest\'.\n  | AnnTestGroup ann TestName [AnnTestTree ann]\n  -- ^ Annotated counterpart of \'TestGroup\'.\n  | forall a . AnnWithResource ann (ResourceSpec a) (IO a -> AnnTestTree ann)\n  -- ^ Annotated counterpart of \'WithResource\'.\n  | AnnAfter ann DependencyType Expr (AnnTestTree ann)\n  -- ^ Annotated counterpart of \'After\'.\n\n-- | Annotate \'TestTree\' with options, removing \'PlusTestOptions\' and \'AskOptions\' nodes.\nevaluateOptions :: OptionSet -> TestTree -> AnnTestTree OptionSet\nevaluateOptions opts = \\case\n  SingleTest name test ->\n    AnnSingleTest opts name test\n  TestGroup name trees ->\n    AnnTestGroup opts name $ map (evaluateOptions opts) trees\n  PlusTestOptions f tree ->\n    evaluateOptions (f opts) tree\n  WithResource res0 tree ->\n    AnnWithResource opts res0 $ \\res -> evaluateOptions opts (tree res)\n  AskOptions f ->\n    evaluateOptions opts (f opts)\n  After deptype dep tree ->\n    AnnAfter opts deptype dep $ evaluateOptions opts tree\n\n-- | Filter test tree by pattern, replacing leafs with \'AnnEmptyTestTree\'.\nfilterByPattern :: AnnTestTree OptionSet -> AnnTestTree OptionSet\nfilterByPattern = go mempty\n  where\n    go :: Seq.Seq TestName -> AnnTestTree OptionSet -> AnnTestTree OptionSet\n    go path = \\case\n      AnnEmptyTestTree -> AnnEmptyTestTree\n      t@(AnnSingleTest opts name _)\n        | testPatternMatches (lookupOption opts) (path Seq.|> name)\n          -> t\n        | otherwise -> AnnEmptyTestTree\n      AnnTestGroup opts name trees ->\n        AnnTestGroup opts name $ map (go (path Seq.|> name)) trees\n      AnnWithResource opts res0 tree ->\n        AnnWithResource opts res0 $ \\res -> go path (tree res)\n      AnnAfter opts deptype dep tree ->\n        AnnAfter opts deptype dep (go path tree)\n\n-- | Get the list of options that are relevant for a given test tree\ntreeOptions :: TestTree -> [OptionDescription]\ntreeOptions =\n\n  Prelude.concat .\n  Map.elems .\n\n  foldTestTree\n    trivialFold { foldSingle = \\_ _ -> getTestOptions }\n    mempty\n\n  where\n    getTestOptions\n      :: forall t . IsTest t\n      => t -> Map.Map TypeRep [OptionDescription]\n    getTestOptions t =\n      Map.singleton (typeOf t) $\n          witness testOptions t\n'