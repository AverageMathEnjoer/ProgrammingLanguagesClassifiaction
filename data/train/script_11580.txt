b'{-# LANGUAGE LambdaCase #-}\n{-# OPTIONS_GHC -fno-warn-incomplete-uni-patterns #-}\n\nmodule Hoodle.Coroutine.Select.Clipboard where\n\nimport Control.Lens (set, view, (.~))\nimport Control.Monad.State (get, liftIO)\nimport Control.Monad.Trans.Maybe (MaybeT (..))\nimport qualified Data.Foldable as F\nimport Data.Hoodle.Generic\n  ( GLayer (..),\n    gbuffer,\n    gitems,\n    glayers,\n  )\nimport Data.Hoodle.Select (gselSelected)\nimport Data.Hoodle.Simple (Item (..))\nimport Data.Maybe (fromMaybe)\nimport Graphics.Hoodle.Render (updatePageBuf)\nimport Graphics.Hoodle.Render.Item (cnstrctRItem)\nimport Graphics.Hoodle.Render.Type\n  ( hPage2RPage,\n    mkHPage,\n    rItem2Item,\n    selectedLayer,\n  )\nimport Graphics.Hoodle.Render.Type.HitTest\n  ( AlterList (Empty, (:-)),\n    Hitted (..),\n    TEitherAlterHitted (..),\n    getA,\n    interleave,\n    takeHitted,\n  )\nimport qualified Graphics.UI.Gtk as Gtk\nimport Hoodle.Accessor\n  ( getCurrentPageEitherFromHoodleModeState,\n    getGeometry4CurrCvs,\n    renderCache,\n    updateUhdl,\n    updateXState,\n  )\nimport Hoodle.Coroutine.Commit (commit, commit_)\nimport Hoodle.Coroutine.Draw\n  ( callRenderer,\n    callRenderer_,\n    invalidateAll,\n    waitSomeEvent,\n  )\nimport Hoodle.Coroutine.Mode (modeChange)\nimport Hoodle.Coroutine.Page (canvasZoomUpdateAll)\nimport Hoodle.ModelAction.Clipboard\n  ( callback4Clip,\n    updateClipboard,\n  )\nimport Hoodle.ModelAction.Page (updatePageAll)\nimport Hoodle.ModelAction.Select\n  ( adjustItemPosition4Paste,\n    toggleCutCopyDelete,\n    updateTempHoodleSelect,\n  )\nimport Hoodle.ModelAction.Select.Transform (rItmsInActiveLyr)\nimport Hoodle.Type.Alias (Hoodle, Page, SelectMode)\nimport Hoodle.Type.Canvas\n  ( CanvasId,\n    canvasId,\n    currentPageNum,\n    forBoth\',\n    unboxBiAct,\n  )\nimport Hoodle.Type.Coroutine (MainCoroutine, doIOaction)\nimport Hoodle.Type.Event\n  ( AllEvent\n      ( UsrEv\n      ),\n    RenderEvent\n      ( GotRItems\n      ),\n    UserEvent\n      ( ActionOrdered,\n        GotClipboardContent,\n        RenderEv,\n        ToSelectMode,\n        ToViewAppendMode\n      ),\n  )\nimport Hoodle.Type.HoodleState\n  ( HoodleModeState (SelectState),\n    currentCanvasInfo,\n    currentUnit,\n    getCurrentCanvasId,\n    gtkUIManager,\n    hoodleModeState,\n    unitHoodles,\n  )\nimport Hoodle.Type.PageArrangement (PageNum (..))\n\n-- |\nupdateTempHoodleSelectM ::\n  CanvasId ->\n  Hoodle SelectMode ->\n  Page SelectMode ->\n  Int ->\n  MainCoroutine (Hoodle SelectMode)\nupdateTempHoodleSelectM cid thdl tpage pagenum = do\n  let newpage = hPage2RPage tpage\n  callRenderer_ $ updatePageBuf cid newpage\n  return (updateTempHoodleSelect thdl tpage pagenum)\n\n-- |\ndeleteSelection :: MainCoroutine ()\ndeleteSelection = do\n  xst <- get\n  let uhdl = view (unitHoodles . currentUnit) xst\n      cid = getCurrentCanvasId uhdl\n  case view hoodleModeState uhdl of\n    SelectState thdl -> do\n      let Just (n, tpage) = view gselSelected thdl\n          slayer = view (glayers . selectedLayer) tpage\n      case unTEitherAlterHitted . view gitems $ slayer of\n        Left _ -> return ()\n        Right alist -> do\n          let newlayer = Left . concat . getA $ alist\n              newpage = set (glayers . selectedLayer) (GLayer (view gbuffer slayer) (TEitherAlterHitted newlayer)) tpage\n          newthdl <- updateTempHoodleSelectM cid thdl newpage n\n          newuhdl <- liftIO . updatePageAll (SelectState newthdl) $ uhdl\n          let ui = view gtkUIManager xst\n          liftIO $ toggleCutCopyDelete ui False\n          commit ((unitHoodles . currentUnit .~ newuhdl) xst)\n          modeChange ToViewAppendMode\n          invalidateAll\n    _ -> return ()\n\n-- |\ncutSelection :: MainCoroutine ()\ncutSelection = copySelection >> deleteSelection\n\n-- |\ncopySelection :: MainCoroutine ()\ncopySelection = do\n  updateXState copySelectionAction >> invalidateAll\n  where\n    copySelectionAction xst =\n      forBoth\' unboxBiAct (fsingle xst) . view (unitHoodles . currentUnit . currentCanvasInfo) $ xst\n    fsingle xst cinfo = do\n      r <- runMaybeT $ do\n        let uhdl = view (unitHoodles . currentUnit) xst\n            hdlmodst = view hoodleModeState uhdl\n            epage = getCurrentPageEitherFromHoodleModeState cinfo hdlmodst\n        pg <- (MaybeT . return . eitherMaybe) epage\n        hitted <- (MaybeT . return . eitherMaybe) (rItmsInActiveLyr pg)\n        (liftIO . updateClipboard xst . map rItem2Item . takeHitted) hitted\n      return (fromMaybe xst r)\n      where\n        eitherMaybe (Left _) = Nothing\n        eitherMaybe (Right a) = Just a\n\n-- |\ngetClipFromGtk :: MainCoroutine (Maybe [Item])\ngetClipFromGtk = do\n  doIOaction $ \\evhandler -> do\n    hdltag <- liftIO $ Gtk.atomNew "hoodle"\n    clipbd <- liftIO $ Gtk.clipboardGet hdltag\n    liftIO $ Gtk.clipboardRequestText clipbd (callback4Clip evhandler)\n    return (UsrEv ActionOrdered)\n  waitSomeEvent (\\case GotClipboardContent _ -> True; _ -> False) >>= \\(GotClipboardContent cnt\') -> return cnt\'\n\n-- |\npasteToSelection :: MainCoroutine ()\npasteToSelection = do\n  mitms <- getClipFromGtk\n  F.forM_ mitms $ \\itms -> do\n    callRenderer $ GotRItems <$> mapM cnstrctRItem itms\n    RenderEv (GotRItems ritms) <-\n      waitSomeEvent (\\case RenderEv (GotRItems _) -> True; _ -> False)\n    xst <- get\n    cache <- renderCache\n    let ui = view gtkUIManager xst\n    modeChange ToSelectMode\n    updateUhdl (pasteAction cache ui ritms)\n    commit_\n    canvasZoomUpdateAll\n    invalidateAll\n  where\n    pasteAction cache ui itms uhdl =\n      forBoth\' unboxBiAct (fsimple cache ui itms uhdl)\n        . view currentCanvasInfo\n        $ uhdl\n    fsimple _cache ui itms uhdl cinfo = do\n      geometry <- liftIO (getGeometry4CurrCvs uhdl)\n      let cid = view canvasId cinfo\n          pagenum = view currentPageNum cinfo\n          hdlmodst@(SelectState thdl) = view hoodleModeState uhdl\n          nclipitms = adjustItemPosition4Paste geometry (PageNum pagenum) itms\n          epage = getCurrentPageEitherFromHoodleModeState cinfo hdlmodst\n          tpage = either mkHPage id epage\n          layerselect = view (glayers . selectedLayer) tpage\n          gbuf = view gbuffer layerselect\n          newlayerselect = case rItmsInActiveLyr tpage of\n            Left nitms -> (GLayer gbuf . TEitherAlterHitted . Right) (nitms :- Hitted nclipitms :- Empty)\n            Right alist ->\n              (GLayer gbuf . TEitherAlterHitted . Right)\n                ( concat (interleave id unHitted alist)\n                    :- Hitted nclipitms\n                    :- Empty\n                )\n          tpage\' = set (glayers . selectedLayer) newlayerselect tpage\n      thdl\' <- updateTempHoodleSelectM cid thdl tpage\' pagenum\n      uhdl\' <- liftIO $ updatePageAll (SelectState thdl\') uhdl\n      liftIO $ toggleCutCopyDelete ui True\n      return uhdl\'\n'