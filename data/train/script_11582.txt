b'#include "../UABE_Generic/PluginManager.h"\n#include "../UABE_Generic/FileContextInfo.h"\n#include "../UABE_Generic/AppContext.h"\n#include <unordered_map>\n#include <assert.h>\n\nstatic bool SupportsElements(std::vector<AssetUtilDesc>& elements)\n{\n\tstd::unordered_map<AssetsFileContextInfo*, int32_t> textClassIDs;\n\tfor (size_t i = 0; i < elements.size(); i++)\n\t{\n\t\tif (elements[i].asset.pFile == nullptr)\n\t\t\treturn false;\n\t\tAssetsFileContextInfo* pFile = elements[i].asset.pFile.get();\n\t\tauto classIDsit = textClassIDs.find(pFile);\n\t\tint32_t textAssetClassID = -1;\n\t\tif (classIDsit == textClassIDs.end())\n\t\t{\n\t\t\ttextAssetClassID = pFile->GetClassByName("TextAsset");\n\t\t\ttextClassIDs[pFile] = textAssetClassID;\n\t\t}\n\t\telse\n\t\t\ttextAssetClassID = classIDsit->second;\n\t\tif (textAssetClassID == -1)\n\t\t\treturn false;\n\t\tint32_t classId = elements[i].asset.getClassID();\n\t\tif (classId != textAssetClassID)\n\t\t\treturn false;\n\t}\n\treturn true;\n}\n\nstatic void SubstituteTextAssetStringType(AssetTypeTemplateField& templateBase)\n{\n\tfor (uint32_t i = 0; i < templateBase.children.size(); i++)\n\t{\n\t\tif (templateBase.children[i].name == "m_Script")\n\t\t{\n\t\t\ttemplateBase.children[i].type = "_string";\n\t\t\ttemplateBase.children[i].valueType = ValueType_None;\n\t\t\tfor (uint32_t k = 0; k < templateBase.children[i].children.size(); k++)\n\t\t\t{\n\t\t\t\tif (templateBase.children[i].children[k].name == "Array")\n\t\t\t\t{\n\t\t\t\t\ttemplateBase.children[i].children[k].type = "TypelessData";\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic void FreeByteBufCallback(void* buffer)\n{\n\tif (buffer)\n\t\tdelete[](uint8_t*)buffer;\n}\n\nclass TextAssetImportTask : public AssetImportTask\n{\n\tAppContext& appContext;\n\tTypeTemplateCache templateCache;\npublic:\n\tTextAssetImportTask(AppContext& appContext,\n\t\tstd::vector<AssetUtilDesc> _assets, std::vector<std::string> _importFilePaths,\n\t\tbool stopOnError = false)\n\n\t\t: AssetImportTask(std::move(_assets), std::move(_importFilePaths), "Import TextAssets", stopOnError),\n\t\t  appContext(appContext)\n\t{}\n\n\tbool importAsset(AssetUtilDesc& desc, std::string path, std::optional<std::reference_wrapper<TaskProgressManager>> progressManager)\n\t{\n\t\tif (desc.asset.pFile == nullptr)\n\t\t\tthrow AssetUtilError("Unable to find the target .assets file.");\n\n\t\tIAssetsReader_ptr pAssetReader = desc.asset.makeReader();\n\t\tif (pAssetReader == nullptr)\n\t\t\tthrow AssetUtilError("Unable to read the asset.");\n\t\tQWORD assetSize = 0;\n\t\tif (!pAssetReader->Seek(AssetsSeek_End, 0) || !pAssetReader->Tell(assetSize) || !pAssetReader->Seek(AssetsSeek_Begin, 0))\n\t\t\tthrow AssetUtilError("Unable to read the asset.");\n\n\t\tAssetTypeTemplateField& templateBase = templateCache.getTemplateField(appContext, desc.asset, &SubstituteTextAssetStringType);\n\t\tAssetTypeTemplateField* pTemplateBase = &templateBase;\n\n\t\tAssetTypeInstance assetInstance(1, &pTemplateBase, assetSize, pAssetReader.get(), desc.asset.isBigEndian());\n\t\tAssetTypeValueField* pBaseField = assetInstance.GetBaseField();\n\t\tif (pBaseField == nullptr || pBaseField->IsDummy())\n\t\t\tthrow AssetUtilError("Unable to deserialize the asset.");\n\n\t\tAssetTypeValueField* scriptField = pBaseField->Get("m_Script");\n\t\tAssetTypeValueField* dataArrayField = scriptField->Get("Array");\n\t\tif (scriptField->IsDummy() || dataArrayField->GetValue() == nullptr || dataArrayField->GetValue()->GetType() != ValueType_ByteArray)\n\t\t\tthrow AssetUtilError("Unexpected TextAsset format.");\n\n\t\tstd::unique_ptr<IAssetsReader> pTextReader(Create_AssetsReaderFromFile(path.c_str(), true, RWOpenFlags_Immediately));// desc.asset.makeReader();\n\t\tif (pTextReader == nullptr)\n\t\t\tthrow AssetUtilError("Unable to read the text file.");\n\t\tQWORD textSize = 0;\n\t\tif (!pTextReader->Seek(AssetsSeek_End, 0) || !pTextReader->Tell(textSize) || !pTextReader->Seek(AssetsSeek_Begin, 0))\n\t\t\tthrow AssetUtilError("Unable to read the text file.");\n\t\tif (textSize >= INT32_MAX)\n\t\t\tthrow AssetUtilError("The text file is too large (should be below 2 GiB).");\n\t\tstd::unique_ptr<uint8_t[]> textBuf(new uint8_t[(size_t)textSize]);\n\t\tif (pTextReader->Read(textSize, textBuf.get()) != textSize)\n\t\t\tthrow AssetUtilError("Unable to read the text file.");\n\n\t\tAssetTypeByteArray byteArrayValue = {};\n\t\tbyteArrayValue.data = textBuf.get();\n\t\tbyteArrayValue.size = (uint32_t)textSize;\n\t\tdataArrayField->GetValue()->Set(&byteArrayValue);\n\n\t\tQWORD outSize = pBaseField->GetByteSize(0);\n\t\tif (outSize >= SIZE_MAX)\n\t\t\tthrow AssetUtilError("Import size out of range.");\n\t\tstd::unique_ptr<uint8_t[]> newDataBuf(new uint8_t[outSize]);\n\t\tstd::unique_ptr<IAssetsWriter> pTempWriter(Create_AssetsWriterToMemory(newDataBuf.get(), outSize));\n\t\tif (pTempWriter == nullptr)\n\t\t\tthrow AssetUtilError("Unexpected runtime error.");\n\t\tQWORD newByteSize = pBaseField->Write(pTempWriter.get(), 0, desc.asset.isBigEndian());\n\n\t\tstd::shared_ptr<AssetsEntryReplacer> pReplacer(MakeAssetModifierFromMemory(0, desc.asset.pathID,\n\t\t\tdesc.asset.getClassID(), desc.asset.getMonoScriptID(),\n\t\t\tnewDataBuf.release(), (size_t)newByteSize, FreeByteBufCallback));\n\t\tif (pReplacer == nullptr)\n\t\t\tthrow AssetUtilError("Unexpected runtime error.");\n\t\tdesc.asset.pFile->addReplacer(pReplacer, appContext);\n\t\treturn true;\n\t}\n};\nclass TextAssetImportProvider : public IAssetOptionProviderGeneric\n{\npublic:\n\tclass Runner : public IOptionRunner\n\t{\n\t\tAppContext& appContext;\n\t\tstd::vector<AssetUtilDesc> selection;\n\tpublic:\n\t\tRunner(AppContext& appContext, std::vector<AssetUtilDesc> _selection)\n\t\t\t: appContext(appContext), selection(std::move(_selection))\n\t\t{}\n\t\tvoid operator()()\n\t\t{\n\t\t\tstd::vector<std::string> importLocations = appContext.QueryAssetImportLocation(selection, ".txt", "\\\\.txt", "*.txt|Text file:");\n\t\t\tif (!importLocations.empty())\n\t\t\t{\n\t\t\t\tauto pTask = std::make_shared<TextAssetImportTask>(appContext, std::move(selection), std::move(importLocations));\n\t\t\t\tappContext.taskManager.enqueue(pTask);\n\t\t\t}\n\t\t}\n\t};\n\tEAssetOptionType getType()\n\t{\n\t\treturn EAssetOptionType::Import;\n\t}\n\tstd::unique_ptr<IOptionRunner> prepareForSelection(\n\t\tclass AppContext& appContext,\n\t\tstd::vector<AssetUtilDesc> selection,\n\t\tstd::string& optionName)\n\t{\n\t\tif (!SupportsElements(selection))\n\t\t\treturn nullptr;\n\t\toptionName = "Import from .txt";\n\t\treturn std::make_unique<Runner>(appContext, std::move(selection));\n\t}\n};\n\n\nclass TextAssetExportTask : public AssetExportTask\n{\n\tAppContext& appContext;\n\tTypeTemplateCache templateCache;\npublic:\n\tTextAssetExportTask(AppContext& appContext,\n\t\tstd::vector<AssetUtilDesc> _assets, std::string _baseDir,\n\t\tbool stopOnError = false)\n\n\t\t: AssetExportTask(std::move(_assets), "Export TextAssets", ".txt", std::move(_baseDir), stopOnError),\n\t\tappContext(appContext)\n\t{}\n\n\tbool exportAsset(AssetUtilDesc& desc, std::string path, std::optional<std::reference_wrapper<TaskProgressManager>> progressManager)\n\t{\n\t\tif (desc.asset.pFile == nullptr)\n\t\t\tthrow AssetUtilError("Unable to find the target .assets file.");\n\n\t\tIAssetsReader_ptr pAssetReader = desc.asset.makeReader();\n\t\tif (pAssetReader == nullptr)\n\t\t\tthrow AssetUtilError("Unable to read the asset.");\n\t\tQWORD assetSize = 0;\n\t\tif (!pAssetReader->Seek(AssetsSeek_End, 0) || !pAssetReader->Tell(assetSize) || !pAssetReader->Seek(AssetsSeek_Begin, 0))\n\t\t\tthrow AssetUtilError("Unable to read the asset.");\n\n\t\tAssetTypeTemplateField& templateBase = templateCache.getTemplateField(appContext, desc.asset, &SubstituteTextAssetStringType);\n\t\tAssetTypeTemplateField* pTemplateBase = &templateBase;\n\n\t\tAssetTypeInstance assetInstance(1, &pTemplateBase, assetSize, pAssetReader.get(), desc.asset.isBigEndian());\n\t\tAssetTypeValueField* pBaseField = assetInstance.GetBaseField();\n\t\tif (pBaseField == nullptr || pBaseField->IsDummy())\n\t\t\tthrow AssetUtilError("Unable to deserialize the asset.");\n\n\t\tAssetTypeValueField* scriptField = pBaseField->Get("m_Script");\n\t\tAssetTypeValueField* dataArrayField = scriptField->Get("Array");\n\t\tif (scriptField->IsDummy() || dataArrayField->GetValue() == nullptr || dataArrayField->GetValue()->GetType() != ValueType_ByteArray)\n\t\t\tthrow AssetUtilError("Unexpected TextAsset format.");\n\n\t\tAssetTypeByteArray* pByteArray = dataArrayField->GetValue()->AsByteArray();\n\n\t\tstd::unique_ptr<IAssetsWriter> pWriter(Create_AssetsWriterToFile(path.c_str(), true, true, RWOpenFlags_Immediately));\n\t\tif (pWriter == nullptr)\n\t\t\tthrow AssetUtilError("Unable to create the output file.");\n\n\t\tif (pWriter->Write(pByteArray->size, pByteArray->data) != pByteArray->size)\n\t\t\tthrow AssetUtilError("Unable to write the data.");\n\n\t\treturn true;\n\t}\n};\nclass TextAssetExportProvider : public IAssetOptionProviderGeneric\n{\npublic:\n\tclass Runner : public IOptionRunner\n\t{\n\t\tAppContext& appContext;\n\t\tstd::vector<AssetUtilDesc> selection;\n\tpublic:\n\t\tRunner(AppContext& appContext, std::vector<AssetUtilDesc> _selection)\n\t\t\t: appContext(appContext), selection(std::move(_selection))\n\t\t{}\n\t\tvoid operator()()\n\t\t{\n\t\t\tstd::string exportLocation = appContext.QueryAssetExportLocation(selection, ".txt", "*.txt|Text file:");\n\t\t\tif (!exportLocation.empty())\n\t\t\t{\n\t\t\t\tauto pTask = std::make_shared<TextAssetExportTask>(appContext, std::move(selection), std::move(exportLocation));\n\t\t\t\tappContext.taskManager.enqueue(pTask);\n\t\t\t}\n\t\t}\n\t};\n\tEAssetOptionType getType()\n\t{\n\t\treturn EAssetOptionType::Export;\n\t}\n\tstd::unique_ptr<IOptionRunner> prepareForSelection(\n\t\tclass AppContext& appContext,\n\t\tstd::vector<struct AssetUtilDesc> selection,\n\t\tstd::string& optionName)\n\t{\n\t\tif (!SupportsElements(selection))\n\t\t\treturn nullptr;\n\t\toptionName = "Export to .txt";\n\t\treturn std::make_unique<Runner>(appContext, std::move(selection));\n\t}\n};\n\nclass TextAssetPluginDesc : public IPluginDesc\n{\n\tstd::vector<std::shared_ptr<IOptionProvider>> pProviders;\npublic:\n\tTextAssetPluginDesc()\n\t{\n\t\tpProviders = { std::make_shared<TextAssetExportProvider>(), std::make_shared<TextAssetImportProvider>() };\n\t}\n\tstd::string getName()\n\t{\n\t\treturn "TextAsset";\n\t}\n\tstd::string getAuthor()\n\t{\n\t\treturn "";\n\t}\n\tstd::string getDescriptionText()\n\t{\n\t\treturn "Export and import the content of TextAsset assets.";\n\t}\n\t//The IPluginDesc object should keep a reference to the returned options, as the caller may keep only std::weak_ptrs.\n\t//Note: May be called early, e.g. before program UI initialization.\n\tstd::vector<std::shared_ptr<IOptionProvider>> getPluginOptions(class AppContext& appContext)\n\t{\n\t\treturn pProviders;\n\t}\n};\n\nIPluginDesc* GetUABEPluginDesc1(size_t sizeof_AppContext, size_t sizeof_BundleFileContextInfo)\n{\n\tif (sizeof_AppContext != sizeof(AppContext) || sizeof_BundleFileContextInfo != sizeof(BundleFileContextInfo))\n\t{\n\t\tassert(false);\n\t\treturn nullptr;\n\t}\n\treturn new TextAssetPluginDesc();\n}\n'