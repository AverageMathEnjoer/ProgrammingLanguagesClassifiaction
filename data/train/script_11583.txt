b'{-# LANGUAGE ScopedTypeVariables #-}\n\nimport Data.List\nimport Test.Hspec\nimport Test.Hspec.QuickCheck\n\nmain :: IO ()\nmain = hspec $ do\n    describe "my_reverse" $\n        prop "behaves like model" $ \\(xs :: [Char]) ->\n           my_reverse xs `shouldBe` reverse xs\n    describe "my_reverse_iter" $\n        prop "behaves like model" $ \\(xs :: [Char]) ->\n           my_reverse_iter xs `shouldBe` reverse xs\n    describe "my_map" $\n        prop "behaves like model" $ \\(xs :: [Integer]) ->\n           my_map (+1) xs `shouldBe` map (+1) xs\n    describe "my_map_iter" $\n        prop "behaves like model" $ \\(xs :: [Integer]) ->\n           my_map_iter (+1) xs `shouldBe` map (+1) xs\n    describe "my_filter" $\n        prop "behaves like model" $ \\(xs :: [Integer]) -> do\n           my_filter even xs `shouldBe` filter even xs\n           my_filter odd  xs `shouldBe` filter odd  xs\n           my_filter (>5) xs `shouldBe` filter (>5) xs\n    describe "my_append" $\n        prop "behaves like model" $ \\(xs :: [Char]) (ys :: [Char]) ->\n           xs `my_append` ys `shouldBe` xs ++ ys\n    describe "my_concat" $\n        prop "behaves like model" $ \\(xxs :: [[Char]]) ->\n           my_concat xxs `shouldBe` concat xxs\n    describe "my_break" $\n        prop "behaves like model" $ \\(xs :: [Integer]) -> do\n           my_break even xs `shouldBe` break even xs\n           my_break odd  xs `shouldBe` break odd  xs\n           my_break (>5) xs `shouldBe` break (>5) xs\n    describe "my_intersperse" $\n        prop "behaves like model" $ \\(xs :: [Integer]) ->\n           my_intersperse 1 xs `shouldBe` intersperse 1 xs\n    describe "my_group" $\n        prop "behaves like model" $ \\(xs :: [Bool]) ->\n           my_group xs `shouldBe` group xs\n\n----------------------------------------------------------------\n\nmy_reverse :: [a] -> [a]\nmy_reverse []     = []\nmy_reverse (x:xs) = my_reverse xs ++ [x]\n\nmy_reverse_iter :: [a] -> [a]\nmy_reverse_iter as = iter as []\n  where\n    iter :: [a] -> [a] -> [a]\n    iter []     ys = ys\n    iter (x:xs) ys = iter xs (x:ys)\n\n----------------------------------------------------------------\n\nmy_map :: (a -> b) -> [a] -> [b]\nmy_map _ []     = []\nmy_map f (x:xs) = f x : my_map f xs\n\nmy_map_iter :: (a -> b) -> [a] -> [b]\nmy_map_iter g as = reverse (iter g as [])\n  where\n    iter _ []     acc = acc\n    iter f (x:xs) acc = iter f xs (f x : acc)\n\n----------------------------------------------------------------\n\nmy_filter :: (a -> Bool) -> [a] -> [a]\nmy_filter _ []     = []\nmy_filter p (x:xs)\n  | p x            = x : my_filter p xs\n  | otherwise      = my_filter p xs\n\n----------------------------------------------------------------\n\nmy_append :: [a] -> [a] -> [a]\nmy_append []     ys = ys\nmy_append (x:xs) ys = x : my_append xs ys\n\nmy_concat :: [[a]] -> [a]\nmy_concat []       = []\nmy_concat (xs:xss) = xs `my_append` my_concat xss\n\n----------------------------------------------------------------\n\nmy_intersperse :: a -> [a] -> [a]\nmy_intersperse _ []     = []\nmy_intersperse _ [x]    = [x]\nmy_intersperse s (x:xs) = x : s : my_intersperse s xs\n\n----------------------------------------------------------------\n\nmy_break :: (a -> Bool) -> [a] -> ([a], [a])\nmy_break _ [] = ([],[])\nmy_break p (x:xs)\n  | p x       = ([],x:xs)\n  | otherwise = (x:ys, zs)\n  where\n    (ys,zs) = my_break p xs\n\n----------------------------------------------------------------\n\nmy_group :: Eq a => [a] -> [[a]]\nmy_group []     = []\nmy_group (x:xs) = (x:ys) : my_group zs\n  where\n    (ys,zs) = my_break (/= x) xs\n'