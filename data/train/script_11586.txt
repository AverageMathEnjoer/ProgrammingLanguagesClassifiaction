b'\n-- Made for someone else to show a possible way of handling things in Haskell.\n-- Generates a random pokemon battle in the style of http://viclib.com/test/wildpokeapp.html\n\n-- Completely harmless compiler extension that makes some of the code cleaner\n{-# LANGUAGE OverloadedStrings #-}\n\nmodule Main where\n\n-- Libraries for working with the API\nimport Data.Aeson\nimport Network.HTTP               (simpleHTTP, getResponseBody, getRequest)\nimport Data.ByteString.Lazy.Char8 (pack)\nimport Data.Vector                (toList)\n\n-- Imports for error handling\nimport Data.Maybe                 (fromMaybe)\nimport Control.Applicative        ((<$>),      (<*>))\nimport Control.Monad              (mzero)\n\n-- Imported to be able to wait in the program\nimport Control.Concurrent         (threadDelay)\n\n-- Libraries for working with randomness\nimport System.Random              (newStdGen,  randomRIO)\nimport System.Random.Shuffle      (shuffle\')\n\n-- Handy utility functions for doing random stuff on lists in the IO monad\nshuffleIO :: [a] -> IO [a]\nshuffleIO xs = shuffle\' xs (length xs) <$> newStdGen\nchooseIO :: [a] -> IO a\nchooseIO xs = head <$> shuffleIO xs\n\n\n\n-- We define an object for pokemon\ndata Pokemon = Pokemon {\n    name  :: String,\n    moves :: MoveList,\n    atk   :: Integer,\n    spAtk :: Integer\n}\n\n-- Decode JSON to Pokemon following this rule\ninstance FromJSON Pokemon where\n  parseJSON (Object v) = Pokemon <$> v .: "name"   <*> v .: "moves"\n                                 <*> v .: "attack" <*> v .: "sp_atk"\n  parseJSON _ = mzero\n\n\n\n-- The list of moves in a pokemon can either be a list of\n-- concrete moves, or a list of potential moves that might\n-- need to be downloaded first.\ndata MoveList = Moves [Move] | AvailableMoves [IO Move]\n\n-- Decode JSON to a list of (potential) moves according to\n-- this rule. This fetches the API URI for each move and\n-- stores a download function in the list of potential\n-- moves. When you want a move, just run the download\n-- function.\ninstance FromJSON MoveList where\n  parseJSON (Array v) = AvailableMoves <$> getterFunctions\n    where getterFunctions = map apiRequest <$> mapM uri (toList v)\n          uri (Object o) = o .: "resource_uri"\n          uri _ = mzero\n  parseJSON _ = mzero\n\n\n\n-- A type for concrete moves\ndata Move = Move { movename :: String , power :: Integer }\n\n-- Decode JSON to Moves following this rule\ninstance FromJSON Move where\n  parseJSON (Object v) = Move <$> v .: "name" <*> v .: "power"\n  parseJSON _ = mzero\n\n\n-- A short helper function for making request URIs\nmakeRequest :: String -> Int -> String\nmakeRequest kind number = "/api/v1/" ++ kind ++ "/" ++ show number ++ "/"\n\n-- Perform a request on the API and return the appropriate object\n-- (this will be a Pokemon or a Move depending on circumstances)\napiRequest :: FromJSON a => String -> IO a\napiRequest uri = do\n  let request = getRequest $ "http://viclib.com/pokemon?query=" ++ uri\n  jsondata <- getResponseBody <$> simpleHTTP request\n  either error id . eitherDecode . pack <$> jsondata\n\n\n-- Download four random moves to a pokemon from the ones that are available\ndownloadMoves :: Pokemon -> IO Pokemon\ndownloadMoves pkmn@(Pokemon { moves = AvailableMoves getters }) = do\n  moves <- sequence =<< take 4 <$> shuffleIO getters\n  return pkmn { moves = Moves moves }\n\n-- If the moves are already downloaded, do nothing.\ndownloadMoves pkmn = return pkmn\n\n\nmain :: IO ()\nmain = do\n  -- Get a random #, hit the API to get the corresponding\n  -- pokemon and download the moves for it\n  pkmn <- downloadMoves =<< apiRequest =<< makeRequest "pokemon" <$> randomRIO (1,150)\n\n  -- Enter battle\n  putStrLn $ "Wild " ++ name pkmn ++ " appeared!"\n  battle pkmn 200 0\n\n\nbattle :: Pokemon -> Int -> Int -> IO ()\nbattle pkmn hp moveCount =\n  if hp <= 0\n    then putStrLn $ name pkmn ++ " defeated you in " ++ show moveCount ++ " moves."\n    else do\n      putStrLn $ "You have " ++ show hp ++ " hp!"\n\n      -- Pick a random move\n      move <- case moves pkmn of Moves has -> chooseIO has\n      -- Decide how much damage it does\n      dmg <- randomRIO (0, floor $ fromInteger (power move * (atk pkmn + spAtk pkmn))/300)\n\n      putStrLn $ name pkmn ++ " attacked you with " ++ movename move ++ " dealing " ++ show dmg ++ " damage!"\n\n      -- Wait for a bit...\n      threadDelay 4000000\n\n      -- ...then repeat\n      battle pkmn (hp - dmg) (succ moveCount)\n\n'