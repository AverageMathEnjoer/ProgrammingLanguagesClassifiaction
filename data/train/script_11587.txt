b'class UnionFind{\n\tint n, m;\n\tint *p, *z;\n\tpublic:\n\t\tUnionFind(int no){\n\t\t\tn = no;\n\t\t\tp = new int[n+10];\n\t\t\tz = new int[n+10];\n\t\t\tint i;\n\t\t\tfo(i, n+1) \n\t\t\t\tp[i] = i, z[i] = 0;\n\t\t}\n\t\t//Returns 1 if u and v are in different regions\n\t\t//0 otherwise\n\t\tbool addEdge(int u, int v){\n\t\t\tu = get(u);\n\t\t\tv = get(v);\n\t\t\tif (u == v) return 0;\n\t\t\tif (z[u] < z[v]) p[u] = v;\n\t\t\telse if (z[u] > z[v]) p[v] = u;\n\t\t\telse p[u] = v, z[v]++;\n\t\t\treturn 1;\n\t\t}\n\t\t\n\t\tint get(int v){\n\t\t\tif (v == p[v]) return v;\n\t\t\treturn p[v] = get(p[v]);\n\t\t}\n\t\n};\nbool f(pair<int, pii> a, pair<int, pii> b){\n\treturn a.F < b.F;\n}\nclass MST{\n\tint n, m;\n\ttypedef pair<int, int> pii;\n\t#define pb push_back\n\ttypedef pair<int, pii> edge;\n\tvector<edge> Edges;\n\tUnionFind *forest;\n\tvector<edge> res;\n\tpublic:\n\t\tMST(int size){\n\t\t\tn = size;\n\t\t\tforest = new UnionFind(n);\n\t\t}\n\t\tvoid addEdge(int u, int v, int w){\n\t\t\tEdges.pb({w, {u, v}});\n\t\t}\n\t\tvoid compute(){\n\t\t\tsort(Edges.begin(), Edges.end(), f);\n\t\t\tfor(edge E:Edges){\n\t\t\t\tif (forest->addEdge(E.S.F, E.S.S))\n\t\t\t\t\tres.pb(E);\n\t\t\t}\n\t\t}\n\t\tvoid out(){\n\t\t\tint sum = 0;\n\t\t\tfor(edge E: res)\n\t\t\t\tsum += E.F;\n\t\t\tcout<<sum<<endl;\n\t\t}\n\t\n\t\n};\n'