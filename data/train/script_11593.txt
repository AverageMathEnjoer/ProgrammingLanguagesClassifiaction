b'{-# LANGUAGE OverloadedStrings #-}\n\nmodule Test.XRef\n( spec\n)\nwhere\n\nimport Pdf.Core.Object\nimport Pdf.Core.XRef\nimport Pdf.Core.Exception\nimport qualified Pdf.Core.IO.Buffer as Buffer\n\nimport qualified Data.ByteString as ByteString\nimport qualified Data.Vector as Vector\nimport qualified Data.HashMap.Strict as HashMap\nimport Control.Monad\nimport qualified System.IO.Streams as Streams\nimport Test.Hspec\n\nspec :: Spec\nspec = describe "XRef" $ do\n  describe "isTable" $ do\n    it "should return True when the stream starts from \\"xref\\\\n\\" string" $\n      (Streams.fromByteString "xref\\n" >>= isTable)\n        `shouldReturn` True\n\n    it "should return False when the stream doesn\'t start from \\"xref\\\\n\\"" $\n      (Streams.fromByteString "_xref\\n" >>= isTable)\n        `shouldReturn` False\n\n    it "should consume \\"xref\\\\n\\" prefix" $ (do\n      is <- Streams.fromByteString "xref\\nhello"\n      void $ isTable is\n      Streams.readExactly 5 is\n      ) `shouldReturn` "hello"\n\n\n  describe "readXRef" $ do\n    it "should support xref table" $ (do\n      buf <- Buffer.fromBytes "helloxref\\nworld"\n      readXRef buf 5\n      ) `shouldReturn` XRefTable 5\n\n    it "should support xref stream" $ (do\n      buf <- Buffer.fromBytes "hello1 1 obj\\n<<>>stream\\r\\ncontent"\n      readXRef buf 5\n      ) `shouldReturn` XRefStream 5 (S HashMap.empty 25)\n\n    it "should throw exception if xref not found" $ (do\n      buf <- Buffer.fromBytes "hello\\n"\n      readXRef buf 0\n      ) `shouldThrow` anyException\n\n\n  describe "lastXRef" $ do\n    it "should find the latest xref" $ (\n      Buffer.fromBytes "helloxref\\nxref\\nstartxref\\n10\\n%%EOF\\\n        \\worldstartxref\\n5\\n%%EOF"\n      >>= lastXRef\n      ) `shouldReturn` XRefTable 5\n\n    it "should throw Corrupted when xref not found" $ (\n      Buffer.fromBytes "helloxref\\n%%EOF"\n      >>= lastXRef\n      ) `shouldThrow` \\Corrupted{} -> True\n\n\n  describe "trailer" $ do\n    it "should return the dictionary for xref stream" $\n      let dict = HashMap.fromList [("Hello", String "World")]\n      in trailer undefined (XRefStream 0 (S dict 0))\n        `shouldReturn` dict\n\n    it "should parse trailer after xref table" $ (do\n      buf <- Buffer.fromBytes "helloxref\\n1 1\\n0000000001 00000 n\\r\\n\\\n        \\trailer\\n<</Hello(world)>>"\n      trailer buf (XRefTable 5)\n      ) `shouldReturn` HashMap.fromList [("Hello", String "world")]\n\n    it "should handle multisection table" $ (do\n      buf <- Buffer.fromBytes "helloxref\\n1 1\\n0000000001 00000 n\\r\\n\\\n        \\1 1\\n0000000002 00000 n\\r\\ntrailer\\n<</Hello(world)>>"\n      trailer buf (XRefTable 5)\n      ) `shouldReturn` HashMap.fromList [("Hello", String "world")]\n\n    it "should throw Corrupted exception if can\'t parse" $ (do\n      buf <- Buffer.fromBytes "helloxref\\n1 Hello(world)>>"\n      trailer buf (XRefTable 5)\n      ) `shouldThrow` \\Corrupted{} -> True\n\n\n  describe "prevXRef" $ do\n    it "should read xref located at offset from\\\n        \\ Prev entry in current trailer" $ (do\n      let dict = HashMap.fromList [("Prev", Number 5)]\n      buf <- Buffer.fromBytes "helloxref\\n"\n      prevXRef buf (XRefStream undefined (S dict undefined))\n      ) `shouldReturn` Just (XRefTable 5)\n\n    it "should return Nothing for the last xref" $ (do\n      let dict = HashMap.fromList []\n      buf <- Buffer.fromBytes "helloxref\\n"\n      prevXRef buf (XRefStream undefined (S dict undefined))\n      ) `shouldReturn` Nothing\n\n    it "should throw Corrupted when Prev is not an int" $ (do\n      let dict = HashMap.fromList [("Prev", String "hello")]\n      buf <- Buffer.fromBytes "helloxref\\n"\n      prevXRef buf (XRefStream undefined (S dict undefined))\n      ) `shouldThrow` \\Corrupted{} -> True\n\n  describe "lookupTableEntry" $ do\n    it "should look for the entry in subsections" $ (do\n      buf <- Buffer.fromBytes "helloxref\\n\\\n        \\1 2\\n\\\n        \\0000000011 00000 n\\r\\n\\\n        \\0000000022 00000 n\\r\\n\\\n        \\3 2\\n\\\n        \\0000000033 00000 n\\r\\n\\\n        \\0000000044 00000 n\\r\\n\\\n        \\trailer"\n      lookupTableEntry buf (XRefTable 5) (R 4 0)\n      ) `shouldReturn` Just (EntryUsed 44 0)\n\n    it "should return free entry" $ (do\n      buf <- Buffer.fromBytes "helloxref\\n\\\n        \\1 2\\n\\\n        \\0000000011 00000 n\\r\\n\\\n        \\0000000022 00001 f\\r\\n\\\n        \\trailer"\n      lookupTableEntry buf (XRefTable 5) (R 2 0)\n      ) `shouldReturn` Just (EntryFree 22 0)\n\n    it "should return Nothing when not found" $ (do\n      buf <- Buffer.fromBytes "helloxref\\n\\\n        \\1 2\\n\\\n        \\0000000011 00000 n\\r\\n\\\n        \\0000000022 00000 n\\r\\n\\\n        \\trailer"\n      lookupTableEntry buf (XRefTable 5) (R 4 0)\n      ) `shouldReturn` Nothing\n\n  describe "lookupStreamEntry" $ do\n    let bytes = ByteString.pack\n          [ 0,  0, 1,  2\n          , 1,  0, 2,  3\n          , 2,  0, 3,  4\n          , 0,  0, 4,  0\n          ]\n        dict = HashMap.fromList\n          [ ("Index", Array $ Vector.fromList $ map Number [3, 4])\n          , ("W", Array $ Vector.fromList $ map Number [1, 2, 1])\n          , ("Size", Number 4)\n          ]\n    it "should handle free objects" $ (do\n      is <- Streams.fromByteString bytes\n      lookupStreamEntry dict is (R 6 0)\n      ) `shouldReturn` Just (EntryFree 4 0)\n\n    it "should handle used objects" $ (do\n      is <- Streams.fromByteString bytes\n      lookupStreamEntry dict is (R 4 0)\n      ) `shouldReturn` Just (EntryUsed 2 3)\n\n    it "should handle compressed objects" $ (do\n      is <- Streams.fromByteString bytes\n      lookupStreamEntry dict is (R 5 0)\n      ) `shouldReturn` Just (EntryCompressed 3 4)\n\n    it "should return Nothing when object to found" $ (do\n      is <- Streams.fromByteString bytes\n      lookupStreamEntry dict is (R 7 0)\n      ) `shouldReturn` Nothing\n\n    it "should handle multiple sections" $ (do\n      let dict\' = HashMap.fromList\n            [ ("Index", Array $ Vector.fromList $ map Number [3, 2, 10, 2])\n            , ("W", Array $ Vector.fromList $ map Number [1, 2, 1])\n            , ("Size", Number 4)\n            ]\n      is <- Streams.fromByteString bytes\n      lookupStreamEntry dict\' is (R 11 0)\n      ) `shouldReturn` Just (EntryFree 4 0)\n'