b'{-# LANGUAGE OverloadedStrings #-}\n{-# LANGUAGE DeriveDataTypeable #-}\n\n-- | Cross reference\n\nmodule Pdf.Core.XRef\n(\n  XRef(..),\n  Entry(..),\n  readXRef,\n  lastXRef,\n  prevXRef,\n  trailer,\n  lookupTableEntry,\n  lookupStreamEntry,\n  isTable,\n  UnknownXRefStreamEntryType(..),\n)\nwhere\n\nimport Pdf.Core.Object\nimport Pdf.Core.Object.Util\nimport Pdf.Core.Parsers.XRef\nimport Pdf.Core.Stream\nimport Pdf.Core.Exception\nimport Pdf.Core.Util\nimport Pdf.Core.IO.Buffer (Buffer)\nimport qualified Pdf.Core.IO.Buffer as Buffer\n\nimport Data.Typeable\nimport Data.Int\nimport Data.ByteString (ByteString)\nimport qualified Data.ByteString as ByteString\nimport qualified Data.Vector as Vector\nimport qualified Data.HashMap.Strict as HashMap\nimport Control.Monad\nimport Control.Exception hiding (throw)\nimport System.IO.Streams (InputStream)\nimport qualified System.IO.Streams as Streams\nimport qualified System.IO.Streams.Attoparsec as Streams\n\n-- | Entry in cross reference stream\ndata Entry =\n  -- | Object number and generation\n  EntryFree Int Int |\n  -- | Object offset (in bytes from the beginning of file) and generation\n  EntryUsed Int64 Int |\n  -- | Object number of object stream and index within the object stream\n  EntryCompressed Int Int\n  deriving (Eq, Show)\n\n-- | Cross reference\ndata XRef =\n  -- | Offset\n  XRefTable Int64 |\n  -- | Offset and stream\n  XRefStream Int64 Stream\n  deriving (Eq, Show)\n\n-- | Check whether the stream starts with \\"xref\\" keyword.\n-- The keyword itself and newline after it are consumed\nisTable :: InputStream ByteString -> IO Bool\nisTable is = (Streams.parseFromStream tableXRef is >> return True)\n  `catch` \\(Streams.ParseException _) -> return False\n\n-- | Find the last cross reference\nlastXRef :: Buffer -> IO XRef\nlastXRef buf = do\n  sz <- Buffer.size buf\n  Buffer.seek buf $ max 0 (sz - 1024)\n  (Streams.parseFromStream startXRef (Buffer.toInputStream buf)\n    >>= readXRef buf\n    ) `catch` \\(Streams.ParseException msg) ->\n                  throwIO (Corrupted "lastXRef" [msg])\n\n-- | Read XRef at specified offset\nreadXRef :: Buffer -> Int64 -> IO XRef\nreadXRef buf off = do\n  Buffer.seek buf off\n  let is = Buffer.toInputStream buf\n  table <- isTable is\n  if table\n    then return (XRefTable off)\n    else do\n      s <- readStream is off\n      return (XRefStream off s)\n\n-- | Find prev cross reference\nprevXRef :: Buffer -> XRef -> IO (Maybe XRef)\nprevXRef buf xref = message "prevXRef" $ do\n  tr <- trailer buf xref\n  case HashMap.lookup "Prev" tr of\n    Just prev -> do\n      off <- sure $ intValue prev\n        `notice` "Prev in trailer should be an integer"\n      Just <$> readXRef buf (fromIntegral off)\n    _ -> return Nothing\n\n-- | Read trailer for the xref\ntrailer :: Buffer -> XRef -> IO Dict\ntrailer buf (XRefTable off) = do\n  Buffer.seek buf off\n  let is = Buffer.toInputStream buf\n  table <- isTable is\n  unless table $\n    throwIO (Unexpected "trailer" ["table not found"])\n  ( skipTable is >>\n    Streams.parseFromStream parseTrailerAfterTable is\n    ) `catch` \\(Streams.ParseException msg) ->\n                  throwIO (Corrupted "trailer" [msg])\ntrailer _ (XRefStream _ (S dict _)) = return dict\n\nskipTable :: InputStream ByteString -> IO ()\nskipTable is = message "skipTable" $\n  (subsectionHeader is\n    `catch` \\(Streams.ParseException msg) ->\n      throwIO (Corrupted msg []))\n    >>= go . snd\n  where\n  go count = nextSubsectionHeader is count >>= maybe (return ()) (go . snd)\n\nsubsectionHeader :: InputStream ByteString -> IO (Int, Int)\nsubsectionHeader = Streams.parseFromStream parseSubsectionHeader\n\nnextSubsectionHeader :: InputStream ByteString -> Int -> IO (Maybe (Int, Int))\nnextSubsectionHeader is count = message "nextSubsectionHeader" $ do\n  skipSubsection is count\n  fmap Just (subsectionHeader is)\n    `catch` \\(Streams.ParseException _) -> return Nothing\n\nskipSubsection :: InputStream ByteString -> Int -> IO ()\nskipSubsection is count = Buffer.dropExactly (count * 20) is\n\n-- | Read xref entry for the indirect object from xref table\nlookupTableEntry :: Buffer\n                 -> XRef  -- ^ should be xref table\n                 -> Ref   -- ^ indirect object to look for\n                 -> IO (Maybe Entry)\nlookupTableEntry buf (XRefTable tableOff) (R index gen)\n  = message "lookupTableEntry" $ do\n  Buffer.seek buf tableOff\n  table <- isTable (Buffer.toInputStream buf)\n  unless table $\n    throwIO $ Unexpected "Not a table" []\n  (subsectionHeader (Buffer.toInputStream buf) >>= go)\n    `catch` \\(Streams.ParseException err) -> throwIO (Corrupted err [])\n  where\n  go (start, count) = do\n    if index >= start && index < start + count\n      then do\n        -- that is our section, lets seek to the row\n        Buffer.tell buf\n          >>= Buffer.seek buf . (+ (fromIntegral $ index - start) * 20)\n        (off, gen\', free) <-\n          Streams.parseFromStream parseTableEntry (Buffer.toInputStream buf)\n            `catch` \\(Streams.ParseException msg) ->\n              throwIO (Corrupted "parseTableEntry failed" [msg])\n        unless (free || gen == gen\') $ do\n          print (index, gen, off, gen\', free)\n          throwIO $ Corrupted "Generation mismatch" []\n        let entry = if free\n              then EntryFree (fromIntegral off) gen\n              else EntryUsed off gen\n        return (Just entry)\n      else\n        -- go to the next section if any\n        nextSubsectionHeader (Buffer.toInputStream buf) count\n        >>= maybe (return Nothing) go\nlookupTableEntry _ XRefStream{} _ =\n  throwIO $ Unexpected "lookupTableEntry" ["Only xref table allowed"]\n\n-- | Read xref entry for the indirect object from xref stream\n--\n-- See pdf1.7 spec: 7.5.8 Cross-Reference Streams.\n-- May throw \'UnknownXRefStreamEntryType\'\nlookupStreamEntry\n  :: Dict                    -- ^ xref stream dictionary\n  -> InputStream ByteString  -- ^ decoded xref stream content\n  -> Ref                     -- ^ indirect object\n  -> IO (Maybe Entry)\nlookupStreamEntry dict is (R objNumber _) =\n  message "lookupStreamEntry" $ do\n\n  index <- sure $ do\n    sz <- (HashMap.lookup "Size" dict >>= intValue)\n      `notice` "Size should be an integer"\n    i <-\n      case HashMap.lookup "Index" dict of\n        Nothing           -> Right [Number 0, Number (fromIntegral sz)]\n        Just (Array arr) -> Right (Vector.toList arr)\n        _                 -> Left "Index should be an array"\n\n    let convertIndex res [] = Right (reverse res)\n        convertIndex res (x1:x2:xs) = do\n          from <- intValue x1 `notice` "from index should be an integer"\n          count <- intValue x2 `notice` "count should be an integer"\n          convertIndex ((from, count) : res) xs\n        convertIndex _ _ = Left $ "Malformed Index in xref stream: " ++ show i\n\n    convertIndex [] i\n\n  width <- sure $ do\n    ws <-\n      case HashMap.lookup "W" dict of\n        Just (Array ws) -> Right (Vector.toList ws)\n        _ -> Left "W should be an array"\n    mapM intValue ws\n      `notice` "W should contains integers"\n\n  unless (length width == 3) $\n    throwIO $ Corrupted ("Malformed With array in xref stream: "\n                        ++ show width) []\n\n  values <- do\n    let position = loop 0 index\n        totalWidth = sum width\n        loop _ [] = Nothing\n        loop pos ((from, count) : xs) =\n          if objNumber < from || objNumber >= from + count\n            then loop (pos + totalWidth * count) xs\n            else Just (pos + totalWidth * (objNumber - from))\n    case position of\n      Nothing -> return Nothing\n      Just p -> do\n        Buffer.dropExactly p is\n        Just . ByteString.unpack <$> Streams.readExactly totalWidth is\n\n  case values of\n    Nothing -> return Nothing\n    Just vs -> do\n      let vs\' = map conv $ collect [] width vs :: [Int64]\n            where\n            conv l = conv\' (length l - 1) 0 l\n            conv\' _ res [] = res\n            conv\' power res (x:xs) =\n              conv\' (power-1) (res + (fromIntegral x * 256 ^ power)) xs\n            collect res [] [] = reverse res\n            collect res (x:xs) ys = collect (take x ys : res) xs (drop x ys)\n            collect _ _ _ = error "readStreamEntry: collect: impossible"\n      (v1, v2, v3) <- case vs\' of\n        [a, b, c] -> return (a, b, c)\n        _ -> throwIO $ Corrupted "lookupStreamEntry" ["expected 3 values"]\n      case v1 of\n        0 -> return $ Just $ EntryFree (fromIntegral v2)\n                                             (fromIntegral v3)\n        1 -> return $ Just $ EntryUsed v2 (fromIntegral v3)\n        2 -> return $ Just $ EntryCompressed (fromIntegral v2)\n                                                   (fromIntegral v3)\n        _ -> throwIO $ UnknownXRefStreamEntryType (fromIntegral v1)\n\n-- | Unknown entry type should be interpreted as reference to null object\ndata UnknownXRefStreamEntryType = UnknownXRefStreamEntryType Int\n  deriving (Show, Typeable)\n\ninstance Exception UnknownXRefStreamEntryType\n'