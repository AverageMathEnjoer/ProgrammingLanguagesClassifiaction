b'\xef\xbb\xbfusing System;\nusing System.Linq;\nusing System.Collections.Generic;\nusing System.Runtime.InteropServices;\nusing System.ComponentModel;\n\nnamespace Rubeus\n{\n    public class Crypto\n    {\n        public static void ComputeAllKerberosPasswordHashes(string password, string userName = "", string domainName = "")\n        {\n            // use KerberosPasswordHash() to calculate rc4_hmac, aes128_cts_hmac_sha1, aes256_cts_hmac_sha1, and des_cbc_md5 hashes for a given password\n\n            Console.WriteLine("[*] Input password             : {0}", password);\n\n            string salt = String.Format("{0}{1}", domainName.ToUpper(), userName);\n\n            // special case for computer account salts\n            if (userName.EndsWith("$"))\n            {\n                salt = String.Format("{0}host{1}.{2}", domainName.ToUpper(), userName.TrimEnd(\'$\').ToLower(), domainName.ToLower());\n            }\n\n            if (!String.IsNullOrEmpty(userName) && !String.IsNullOrEmpty(domainName))\n            {\n                Console.WriteLine("[*] Input username             : {0}", userName);\n                Console.WriteLine("[*] Input domain               : {0}", domainName);\n                Console.WriteLine("[*] Salt                       : {0}", salt);\n            }\n\n            string rc4Hash = KerberosPasswordHash(Interop.KERB_ETYPE.rc4_hmac, password);\n            Console.WriteLine("[*]       rc4_hmac             : {0}", rc4Hash);\n\n            if (String.IsNullOrEmpty(userName) || String.IsNullOrEmpty(domainName))\n            {\n                Console.WriteLine("\\r\\n[!] /user:X and /domain:Y need to be supplied to calculate AES and DES hash types!");\n            }\n            else\n            {\n                string aes128Hash = KerberosPasswordHash(Interop.KERB_ETYPE.aes128_cts_hmac_sha1, password, salt);\n                Console.WriteLine("[*]       aes128_cts_hmac_sha1 : {0}", aes128Hash);\n\n                string aes256Hash = KerberosPasswordHash(Interop.KERB_ETYPE.aes256_cts_hmac_sha1, password, salt);\n                Console.WriteLine("[*]       aes256_cts_hmac_sha1 : {0}", aes256Hash);\n\n                string desHash = KerberosPasswordHash(Interop.KERB_ETYPE.des_cbc_md5, String.Format("{0}{1}", password, salt), salt);\n                Console.WriteLine("[*]       des_cbc_md5          : {0}", desHash);\n            }\n\n            Console.WriteLine();\n        }\n\n        public static string KerberosPasswordHash(Interop.KERB_ETYPE etype, string password, string salt = "", int count = 4096)\n        {\n            // use the internal KERB_ECRYPT HashPassword() function to calculate a password hash of a given etype\n            // adapted from @gentilkiwi\'s Mimikatz "kerberos::hash" implementation\n\n            Interop.KERB_ECRYPT pCSystem;\n            IntPtr pCSystemPtr;\n\n            // locate the crypto system for the hash type we want\n            int status = Interop.CDLocateCSystem(etype, out pCSystemPtr);\n\n            pCSystem = (Interop.KERB_ECRYPT)System.Runtime.InteropServices.Marshal.PtrToStructure(pCSystemPtr, typeof(Interop.KERB_ECRYPT));\n            if (status != 0)\n                throw new System.ComponentModel.Win32Exception(status, "Error on CDLocateCSystem");\n\n            // get the delegate for the password hash function\n            Interop.KERB_ECRYPT_HashPassword pCSystemHashPassword = (Interop.KERB_ECRYPT_HashPassword)System.Runtime.InteropServices.Marshal.GetDelegateForFunctionPointer(pCSystem.HashPassword, typeof(Interop.KERB_ECRYPT_HashPassword));\n            Interop.UNICODE_STRING passwordUnicode = new Interop.UNICODE_STRING(password);\n            Interop.UNICODE_STRING saltUnicode = new Interop.UNICODE_STRING(salt);\n\n            byte[] output = new byte[pCSystem.KeySize];\n\n            int success = pCSystemHashPassword(passwordUnicode, saltUnicode, count, output);\n\n            if (status != 0)\n                throw new Win32Exception(status);\n\n            return System.BitConverter.ToString(output).Replace("-", "");\n        }\n\n        // Adapted from Vincent LE TOUX\' "MakeMeEnterpriseAdmin"\n        public static byte[] KerberosChecksum(byte[] key, byte[] data, Interop.KERB_CHECKSUM_ALGORITHM cksumType = Interop.KERB_CHECKSUM_ALGORITHM.KERB_CHECKSUM_HMAC_MD5, int keyUsage = Interop.KRB_KEY_USAGE_KRB_NON_KERB_CKSUM_SALT)\n        {\n            Interop.KERB_CHECKSUM pCheckSum;\n            IntPtr pCheckSumPtr;\n            int status = Interop.CDLocateCheckSum(cksumType, out pCheckSumPtr);\n            pCheckSum = (Interop.KERB_CHECKSUM)Marshal.PtrToStructure(pCheckSumPtr, typeof(Interop.KERB_CHECKSUM));\n            if (status != 0)\n            {\n                throw new Win32Exception(status, "CDLocateCheckSum failed");\n            }\n\n            IntPtr Context;\n            Interop.KERB_CHECKSUM_InitializeEx pCheckSumInitializeEx = (Interop.KERB_CHECKSUM_InitializeEx)Marshal.GetDelegateForFunctionPointer(pCheckSum.InitializeEx, typeof(Interop.KERB_CHECKSUM_InitializeEx));\n            Interop.KERB_CHECKSUM_Sum pCheckSumSum = (Interop.KERB_CHECKSUM_Sum)Marshal.GetDelegateForFunctionPointer(pCheckSum.Sum, typeof(Interop.KERB_CHECKSUM_Sum));\n            Interop.KERB_CHECKSUM_Finalize pCheckSumFinalize = (Interop.KERB_CHECKSUM_Finalize)Marshal.GetDelegateForFunctionPointer(pCheckSum.Finalize, typeof(Interop.KERB_CHECKSUM_Finalize));\n            Interop.KERB_CHECKSUM_Finish pCheckSumFinish = (Interop.KERB_CHECKSUM_Finish)Marshal.GetDelegateForFunctionPointer(pCheckSum.Finish, typeof(Interop.KERB_CHECKSUM_Finish));\n\n            // initialize the checksum\n            // KERB_NON_KERB_CKSUM_SALT = 17\n            int status2 = pCheckSumInitializeEx(key, key.Length, (int)keyUsage, out Context);\n            if (status2 != 0)\n                throw new Win32Exception(status2);\n\n            // the output buffer for the checksum data\n            byte[] checksumSrv = new byte[pCheckSum.Size];\n\n            // actually checksum all the supplied data\n            pCheckSumSum(Context, data.Length, data);\n\n            // finish everything up\n            pCheckSumFinalize(Context, checksumSrv);\n            pCheckSumFinish(ref Context);\n\n            return checksumSrv;\n        }\n\n        // Adapted from Vincent LE TOUX\' "MakeMeEnterpriseAdmin"\n        //  https://github.com/vletoux/MakeMeEnterpriseAdmin/blob/master/MakeMeEnterpriseAdmin.ps1#L2235-L2262\n        public static byte[] KerberosDecrypt(Interop.KERB_ETYPE eType, int keyUsage, byte[] key, byte[] data)\n        {\n            Interop.KERB_ECRYPT pCSystem;\n            IntPtr pCSystemPtr;\n            \n            // locate the crypto system\n            int status = Interop.CDLocateCSystem(eType, out pCSystemPtr);\n            pCSystem = (Interop.KERB_ECRYPT)Marshal.PtrToStructure(pCSystemPtr, typeof(Interop.KERB_ECRYPT));\n            if (status != 0)\n                throw new Win32Exception(status, "Error on CDLocateCSystem");\n\n            // initialize everything\n            IntPtr pContext;\n            Interop.KERB_ECRYPT_Initialize pCSystemInitialize = (Interop.KERB_ECRYPT_Initialize)Marshal.GetDelegateForFunctionPointer(pCSystem.Initialize, typeof(Interop.KERB_ECRYPT_Initialize));\n            Interop.KERB_ECRYPT_Decrypt pCSystemDecrypt = (Interop.KERB_ECRYPT_Decrypt)Marshal.GetDelegateForFunctionPointer(pCSystem.Decrypt, typeof(Interop.KERB_ECRYPT_Decrypt));\n            Interop.KERB_ECRYPT_Finish pCSystemFinish = (Interop.KERB_ECRYPT_Finish)Marshal.GetDelegateForFunctionPointer(pCSystem.Finish, typeof(Interop.KERB_ECRYPT_Finish));\n            status = pCSystemInitialize(key, key.Length, keyUsage, out pContext);\n            if (status != 0)\n                throw new Win32Exception(status);\n\n            int outputSize = data.Length;\n            if (data.Length % pCSystem.BlockSize != 0)\n                outputSize += pCSystem.BlockSize - (data.Length % pCSystem.BlockSize);\n\n            string algName = Marshal.PtrToStringAuto(pCSystem.AlgName);\n\n            outputSize += pCSystem.Size;\n            byte[] output = new byte[outputSize];\n\n            // actually perform the decryption\n            status = pCSystemDecrypt(pContext, data, data.Length, output, ref outputSize);\n            pCSystemFinish(ref pContext);\n\n            return output.Take(outputSize).ToArray();\n        }\n\n        // Adapted from Vincent LE TOUX\' "MakeMeEnterpriseAdmin"\n        //  https://github.com/vletoux/MakeMeEnterpriseAdmin/blob/master/MakeMeEnterpriseAdmin.ps1#L2235-L2262\n        public static byte[] KerberosEncrypt(Interop.KERB_ETYPE eType, int keyUsage, byte[] key, byte[] data)\n        {\n            Interop.KERB_ECRYPT pCSystem;\n            IntPtr pCSystemPtr;\n\n            // locate the crypto system\n            int status = Interop.CDLocateCSystem(eType, out pCSystemPtr);\n            pCSystem = (Interop.KERB_ECRYPT)Marshal.PtrToStructure(pCSystemPtr, typeof(Interop.KERB_ECRYPT));\n            if (status != 0)\n                throw new Win32Exception(status, "Error on CDLocateCSystem");\n\n            // initialize everything\n            IntPtr pContext;\n            Interop.KERB_ECRYPT_Initialize pCSystemInitialize = (Interop.KERB_ECRYPT_Initialize)Marshal.GetDelegateForFunctionPointer(pCSystem.Initialize, typeof(Interop.KERB_ECRYPT_Initialize));\n            Interop.KERB_ECRYPT_Encrypt pCSystemEncrypt = (Interop.KERB_ECRYPT_Encrypt)Marshal.GetDelegateForFunctionPointer(pCSystem.Encrypt, typeof(Interop.KERB_ECRYPT_Encrypt));\n            Interop.KERB_ECRYPT_Finish pCSystemFinish = (Interop.KERB_ECRYPT_Finish)Marshal.GetDelegateForFunctionPointer(pCSystem.Finish, typeof(Interop.KERB_ECRYPT_Finish));\n            status = pCSystemInitialize(key, key.Length, keyUsage, out pContext);\n            if (status != 0)\n                throw new Win32Exception(status);\n\n            int outputSize = data.Length;\n            if (data.Length % pCSystem.BlockSize != 0)\n                outputSize += pCSystem.BlockSize - (data.Length % pCSystem.BlockSize);\n\n            string algName = Marshal.PtrToStringAuto(pCSystem.AlgName);\n\n            outputSize += pCSystem.Size;\n            byte[] output = new byte[outputSize];\n\n            // actually perform the decryption\n            status = pCSystemEncrypt(pContext, data, data.Length, output, ref outputSize);\n            pCSystemFinish(ref pContext);\n\n            return output;\n        }\n    }\n}'