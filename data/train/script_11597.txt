b'{-# LANGUAGE OverloadedStrings #-}\n\n-- | Process content stream operators maintaining graphics state\n--\n-- It is pretty experimental\n\nmodule Pdf.Content.Processor\n(\n  Processor(..),\n  GraphicsState(..),\n  GlyphDecoder,\n  Glyph(..),\n  Span(..),\n  initialGraphicsState,\n  mkProcessor,\n  processOp\n)\nwhere\n\nimport Pdf.Core\nimport Pdf.Core.Object.Util\nimport Pdf.Core.Util\n\nimport Pdf.Content.Ops\nimport Pdf.Content.Transform\n\nimport Data.ByteString (ByteString)\nimport Data.Text (Text)\nimport qualified Data.Scientific as Scientific\nimport qualified Data.Vector as Vector\nimport Control.Monad\n\n-- | Given font name and string, it should return list of glyphs\n-- and their widths.\n--\n-- Note: it should not try to position or scale glyphs to user space,\n-- bounding boxes should be defined in glyph space.\n--\n-- Note: glyph width is a distance between the glyph\'s origin and\n-- the next glyph\'s origin, so it generally can\'t be calculated\n-- from bounding box\n--\n-- Note: the \'Processor\' actually doesn\'t cares about glyph\'s\n-- bounding box, so you can return anything you want\ntype GlyphDecoder = Name -> ByteString -> [(Glyph, Double)]\n\n-- | Glyph\ndata Glyph = Glyph {\n  -- | The code as read from content stream\n  glyphCode :: Int,\n  -- | Top-left corner of glyph\'s bounding box\n  glyphTopLeft :: Vector Double,\n  -- | Bottom-right corner of glyph\'s bounding box\n  glyphBottomRight :: Vector Double,\n  -- | Text ectracted from the glyph\n  glyphText :: Maybe Text\n  }\n  deriving Show\n\n-- | Graphics state\ndata GraphicsState = GraphicsState {\n  gsInText :: Bool,    -- ^ Indicates that we are inside text object\n  gsCurrentTransformMatrix :: Transform Double,\n  gsFont :: Maybe Name,\n  gsFontSize :: Maybe Double,\n  gsTextMatrix :: Transform Double,      -- ^ Defined only inside text object\n  gsTextLineMatrix :: Transform Double,  -- ^ Defined only inside text object\n  gsTextLeading :: Double,\n  gsTextCharSpacing :: Double,\n  gsTextWordSpacing :: Double\n  }\n  deriving Show\n\n-- | Empty graphics state\ninitialGraphicsState :: GraphicsState\ninitialGraphicsState = GraphicsState {\n  gsInText = False,\n  gsCurrentTransformMatrix = identity,\n  gsFont = Nothing,\n  gsFontSize = Nothing,\n  gsTextMatrix = identity,\n  gsTextLineMatrix = identity,\n  gsTextLeading = 0,\n  gsTextCharSpacing = 0,\n  gsTextWordSpacing = 0\n  }\n\n-- | Glyphs drawn in one shot\ndata Span = Span\n  { spGlyphs :: [Glyph]\n  , spFontName :: Name\n  }\n\n-- | Processor maintains graphics state\ndata Processor = Processor {\n  prState :: GraphicsState,\n  prStateStack :: [GraphicsState],\n  prGlyphDecoder :: GlyphDecoder,\n  prSpans :: [Span]\n  -- ^ Each element is a list of glyphs, drawn in one shot\n  }\n\n-- | Create processor in initial state\nmkProcessor :: Processor\nmkProcessor = Processor {\n  prState = initialGraphicsState,\n  prStateStack = [],\n  prGlyphDecoder = \\_ _ -> [],\n  prSpans = mempty\n  }\n\n-- | Process one operation\nprocessOp :: Operator -> Processor -> Either String Processor\n\nprocessOp (Op_q, []) p = Right p {prStateStack = prState p : prStateStack p}\nprocessOp (Op_q, args) _ = Left ("Op_q: wrong number of arguments: "\n                                ++ show args)\n\nprocessOp (Op_Q, []) p =\n  case prStateStack p of\n    [] -> Left "Op_Q: state is empty"\n    (x:xs) -> Right p {prState = x, prStateStack = xs}\nprocessOp (Op_Q, args) _ = Left ("Op_Q: wrong number of arguments: "\n                                ++ show args)\n\nprocessOp (Op_BT, []) p = do\n  ensureInTextObject False p\n  let gstate = prState p\n  return p {prState = gstate {\n    gsInText = True,\n    gsTextMatrix = identity,\n    gsTextLineMatrix = identity\n    }}\nprocessOp (Op_BT, args) _ = Left ("Op_BT: wrong number of arguments: "\n                                  ++ show args)\n\nprocessOp (Op_ET, []) p = do\n  ensureInTextObject True p\n  let gstate = prState p\n  return p {prState = gstate {\n    gsInText = False\n    }}\nprocessOp (Op_ET, args) _ = Left ("Op_ET: wrong number of arguments: "\n                                  ++ show args)\n\nprocessOp (Op_Td, [txo, tyo]) p = do\n  ensureInTextObject True p\n  tx <- realValue txo `notice` "Td: x should be a real value"\n  ty <- realValue tyo `notice` "Td: y should be a real value"\n  let gstate = prState p\n      tm = translate tx ty $ gsTextLineMatrix gstate\n  Right p {prState = gstate {\n    gsTextMatrix = tm,\n    gsTextLineMatrix = tm\n    }}\nprocessOp (Op_Td, args) _ = Left ("Op_Td: wrong number of arguments: "\n                                  ++ show args)\n\nprocessOp (Op_TD, [txo, tyo]) p = do\n  l <- realValue tyo `notice` "TD: y should be a real value"\n  p\' <- processOp (Op_TL, [Number $ Scientific.fromFloatDigits $ negate l]) p\n  processOp (Op_Td, [txo, tyo]) p\'\nprocessOp (Op_TD, args) _ = Left ("Op_TD: wrong number of arguments: "\n                                  ++ show args)\n\nprocessOp (Op_Tm, [a\', b\', c\', d\', e\', f\']) p = do\n  ensureInTextObject True p\n  a <- realValue a\' `notice` "Tm: a should be a real value"\n  b <- realValue b\' `notice` "Tm: b should be a real value"\n  c <- realValue c\' `notice` "Tm: c should be a real value"\n  d <- realValue d\' `notice` "Tm: d should be a real value"\n  e <- realValue e\' `notice` "Tm: e should be a real value"\n  f <- realValue f\' `notice` "Tm: f should be a real value"\n  let gstate = prState p\n      tm = Transform a b c d e f\n  return p {prState = gstate {\n    gsTextMatrix = tm,\n    gsTextLineMatrix = tm\n    }}\nprocessOp (Op_Tm, args) _ = Left ("Op_Tm: wrong number of arguments: "\n                                  ++ show args)\n\nprocessOp (Op_T_star, []) p = do\n  ensureInTextObject True p\n  let gstate = prState p\n      l = gsTextLeading gstate\n  processOp (Op_TD, map (Number . Scientific.fromFloatDigits) [0, negate l]) p\nprocessOp (Op_T_star, args) _ = Left ("Op_T_star: wrong number of arguments: "\n                                      ++ show args)\n\nprocessOp (Op_TL, [lo]) p = do\n  l <- realValue lo `notice` "TL: l should be a real value"\n  let gstate = prState p\n  return p {prState = gstate {\n    gsTextLeading = l\n    }}\nprocessOp (Op_TL, args) _ = Left ("Op_TL: wrong number of arguments: "\n                                  ++ show args)\n\nprocessOp (Op_cm, [a\', b\', c\', d\', e\', f\']) p = do\n  a <- realValue a\' `notice` "cm: a should be a real value"\n  b <- realValue b\' `notice` "cm: b should be a real value"\n  c <- realValue c\' `notice` "cm: c should be a real value"\n  d <- realValue d\' `notice` "cm: d should be a real value"\n  e <- realValue e\' `notice` "cm: e should be a real value"\n  f <- realValue f\' `notice` "cm: f should be a real value"\n  let gstate = prState p\n      ctm = Transform a b c d e f `multiply` gsCurrentTransformMatrix gstate\n  return p {prState = gstate {\n    gsCurrentTransformMatrix = ctm\n    }}\nprocessOp (Op_cm, args) _ = Left ("Op_cm: wrong number of arguments: "\n                                  ++ show args)\n\nprocessOp (Op_Tf, [fontO, szO]) p = do\n  font <- nameValue fontO `notice` "Tf: font should be a name"\n  sz <- realValue szO `notice` "Tf: size should be a real value"\n  let gstate = prState p\n  return p {prState = gstate {\n    gsFont = Just font,\n    gsFontSize = Just sz\n    }}\nprocessOp (Op_Tf, args) _ = Left ("Op_Tf: wrong number of agruments: "\n                                  ++ show args)\n\nprocessOp (Op_Tj, [String str]) p = do\n  let gstate = prState p\n  fontName <-\n    case gsFont gstate of\n      Nothing -> Left "Op_Tj: font not set"\n      Just fn -> return fn\n  fontSize <-\n    case gsFontSize gstate of\n      Nothing -> Left "Op_Tj: font size not set"\n      Just fs -> return fs\n  let (tm, glyphs) = positionGlyghs\n                       fontSize\n                       (gsCurrentTransformMatrix gstate)\n                       (gsTextMatrix gstate)\n                       (gsTextCharSpacing gstate)\n                       (gsTextWordSpacing gstate)\n                       (prGlyphDecoder p fontName str)\n  let sp = Span\n        { spGlyphs = glyphs\n        , spFontName = fontName\n        }\n  return p {\n    prSpans = sp : prSpans p,\n    prState = gstate {\n      gsTextMatrix = tm\n      }\n    }\nprocessOp (Op_Tj, args) _ = Left ("Op_Tj: wrong number of agruments:"\n                                  ++ show args)\n\nprocessOp (Op_TJ, [Array array]) p = do\n  let gstate = prState p\n  fontName <-\n    case gsFont gstate of\n      Nothing -> Left "Op_Tj: font not set"\n      Just fn -> return fn\n  fontSize <-\n    case gsFontSize gstate of\n      Nothing -> Left "Op_Tj: font size not set"\n      Just fs -> return fs\n  let (textMatrix, glyphs) = loop (gsTextMatrix gstate) []\n                                  (Vector.toList array)\n        where\n        loop tm res [] = (tm, reverse res)\n        loop tm res (String str : rest) =\n          let (tm\', gs) = positionGlyghs fontSize\n                                         (gsCurrentTransformMatrix gstate)\n                                         tm\n                                         (gsTextCharSpacing gstate)\n                                         (gsTextWordSpacing gstate)\n                                         (prGlyphDecoder p fontName str)\n          in loop tm\' (gs : res) rest\n        loop tm res (Number n : rest) =\n          let d = Scientific.toRealFloat n\n          in loop (translate (-d * fontSize / 1000) 0 tm) res rest\n        loop tm res (_:rest) = loop tm res rest\n\n  let mkSpan gs = Span\n        { spGlyphs = gs\n        , spFontName = fontName\n        }\n  return p {\n    prSpans = reverse (map mkSpan glyphs) ++ prSpans p,\n    prState = gstate {\n      gsTextMatrix = textMatrix\n      }\n    }\nprocessOp (Op_TJ, args) _ = Left ("Op_TJ: wrong number of agruments:"\n                                  ++ show args)\n\nprocessOp (Op_Tc, [o]) p = do\n  spacing <- realValue o `notice` "Tc: spacing should be a real value"\n  let gstate = prState p\n  return p {\n    prState = gstate {\n      gsTextCharSpacing = spacing\n      }\n    }\nprocessOp (Op_Tc, args) _ = Left ("Op_Tc: wrong number of agruments:"\n                                  ++ show args)\n\nprocessOp (Op_Tw, [o]) p = do\n  spacing <- realValue o `notice` "Tw: spacing should be a real value"\n  let gstate = prState p\n  return p {\n    prState = gstate {\n      gsTextWordSpacing = spacing\n      }\n    }\nprocessOp (Op_Tw, args) _ = Left ("Op_Tw: wrong number of agruments:"\n                                  ++ show args)\n\nprocessOp (Op_apostrophe, [o]) p = do\n  p\' <- processOp (Op_T_star, []) p\n  processOp (Op_Tj, [o]) p\'\nprocessOp (Op_apostrophe, args) _ =\n  Left ("Op_apostrophe: wrong number of agruments:" ++ show args)\n\nprocessOp _ p = return p\n\nensureInTextObject :: Bool -> Processor -> Either String ()\nensureInTextObject inText p =\n  unless (inText == gsInText (prState p)) $\n    Left $ "ensureInTextObject: expected: " ++ show inText ++ ", found: "\n          ++ show (gsInText $ prState p)\n\npositionGlyghs :: Double\n               -> Transform Double\n               -> Transform Double\n               -> Double\n               -> Double\n               -> [(Glyph, Double)]\n               -> (Transform Double, [Glyph])\npositionGlyghs fontSize ctm textMatrix charSpacing wordSpacing\n  = go textMatrix []\n  where\n  go tm res [] = (tm, reverse res)\n  go tm res ((g, width):gs) =\n    let g\' = g {\n          glyphTopLeft = transform (multiply tm ctm) topLeft,\n          glyphBottomRight = transform (multiply tm ctm) bottomRight\n          }\n        topLeft = transform (scale fontSize fontSize) $ glyphTopLeft g\n        bottomRight = transform (scale fontSize fontSize) $ glyphBottomRight g\n        spacing = charSpacing + case glyphText g of\n                                  Just " " -> wordSpacing\n                                  _ -> 0\n        tm\' = translate (width * fontSize + spacing) 0 tm\n    in go tm\' (g\':res) gs\n'