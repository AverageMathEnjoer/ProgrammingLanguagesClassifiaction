b'{-# OPTIONS_GHC -fno-warn-orphans #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{-# LANGUAGE KindSignatures #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE ConstraintKinds #-}\n{-# LANGUAGE DataKinds #-}\n{-# LANGUAGE UndecidableInstances #-}\n{-# LANGUAGE AllowAmbiguousTypes #-}\n{-# LANGUAGE TypeApplications #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n{-# LANGUAGE PolyKinds #-}\n{-# LANGUAGE CPP #-}\n\n-- | Postgres-specific types, functions, and operators\nmodule Database.Beam.Postgres.PgSpecific\n  ( -- ** Full-text search\n    -- $full-text-search\n\n    -- *** @TSVECTOR@ data type\n    TsVectorConfig, TsVector(..)\n  , toTsVector, english\n\n    -- *** @TSQUERY@ data type\n  , TsQuery(..), (@@)\n  , toTsQuery\n\n    -- ** @JSON@ and @JSONB@ data types\n    -- $json\n  , PgJSON(..), PgJSONB(..)\n  , IsPgJSON(..)\n  , PgJSONEach(..), PgJSONKey(..), PgJSONElement(..)\n\n  , (@>), (<@), (->#), (->$)\n  , (->>#), (->>$), (#>), (#>>)\n  , (?), (?|), (?&)\n\n  , withoutKey, withoutIdx\n  , withoutKeys\n\n  , pgJsonArrayLength\n  , pgArrayToJson\n  , pgJsonbUpdate, pgJsonbSet\n  , pgJsonbPretty\n\n    -- ** @MONEY@ data type\n  , PgMoney(..), pgMoney\n\n  , pgScaleMoney_\n  , pgDivideMoney_, pgDivideMoneys_\n\n  , pgAddMoney_, pgSubtractMoney_\n  , pgSumMoneyOver_, pgAvgMoneyOver_\n  , pgSumMoney_, pgAvgMoney_\n\n    -- ** Geometry types (not PostGIS)\n  , PgPoint(..), PgLine(..), PgLineSegment(..)\n  , PgBox(..), PgPath(..), PgPolygon(..)\n  , PgCircle(..)\n\n    -- ** Regular expressions\n  , PgRegex(..), pgRegex_\n  , (~.), (~*.), (!~.), (!~*.)\n  , pgRegexpReplace_, pgRegexpMatch_\n  , pgRegexpSplitToTable, pgRegexpSplitToArray\n\n    -- ** Set-valued functions\n    -- $set-valued-funs\n  , PgSetOf, pgUnnest\n  , pgUnnestArray, pgUnnestArrayWithOrdinality\n\n    -- ** @ARRAY@ types\n    -- $arrays\n  , PgArrayValueContext, PgIsArrayContext\n\n    -- *** Building @ARRAY@s\n  , array_, arrayOf_, (++.)\n  , pgArrayAgg, pgArrayAggOver\n\n    -- *** Array operators and functions\n  , (!.), arrayDims_\n  , arrayUpper_, arrayLower_\n  , arrayUpperUnsafe_, arrayLowerUnsafe_\n  , arrayLength_, arrayLengthUnsafe_\n\n  , isSupersetOf_, isSubsetOf_\n\n    -- ** @RANGE@ types\n    -- $ranges\n  , PgRange(..), PgRangeBound(..), PgBoundType(..)\n  , PgIsRange(..)\n  , PgInt4Range, PgInt8Range, PgNumRange\n  , PgTsRange, PgTsTzRange, PgDateRange\n\n    -- *** Building ranges from expressions\n  , range_\n\n    -- *** Building @PgRangeBound@s\n  , inclusive, exclusive, unbounded\n\n    -- *** Range operators and functions\n  , (-@>-), (-@>), (-<@-), (<@-)\n  , (-&&-), (-<<-), (->>-)\n  , (-&<-), (-&>-), (--|--)\n  , (-+-), (-*-), (-.-)\n  , rLower_, rUpper_, isEmpty_\n  , lowerInc_, upperInc_, lowerInf_, upperInf_\n  , rangeMerge_\n\n    -- * Postgres @EXTRACT@ fields\n  , century_, decade_, dow_, doy_, epoch_, isodow_, isoyear_\n  , microseconds_, milliseconds_, millennium_, quarter_, week_\n\n    -- ** Postgres functions and aggregates\n  , pgBoolOr, pgBoolAnd, pgStringAgg, pgStringAggOver\n\n  , pgNubBy_\n\n  , now_, ilike_, ilike_\'\n  )\nwhere\n\nimport           Database.Beam hiding (char, double)\nimport           Database.Beam.Backend.SQL\nimport           Database.Beam.Migrate ( HasDefaultSqlDataType(..) )\nimport           Database.Beam.Postgres.Syntax\nimport           Database.Beam.Postgres.Types\nimport           Database.Beam.Query.Internal\nimport           Database.Beam.Schema.Tables\n\nimport           Control.Monad.Free\nimport           Control.Monad.State.Strict (evalState, put, get)\n\nimport           Data.Aeson\nimport           Data.Attoparsec.ByteString\nimport           Data.Attoparsec.ByteString.Char8\nimport           Data.ByteString (ByteString)\nimport           Data.ByteString.Builder\nimport qualified Data.ByteString.Char8 as BC\nimport qualified Data.ByteString.Lazy as BL\nimport           Data.Foldable\nimport           Data.Functor\nimport           Data.Hashable\nimport           Data.Int\nimport qualified Data.List.NonEmpty as NE\nimport           Data.Proxy\nimport           Data.Scientific (Scientific, formatScientific, FPFormat(Fixed))\nimport           Data.String\nimport qualified Data.Text as T\nimport           Data.Time (LocalTime, NominalDiffTime)\nimport           Data.Type.Bool\nimport qualified Data.Vector as V\n#if !MIN_VERSION_base(4, 11, 0)\nimport           Data.Semigroup\n#endif\n\nimport qualified Database.PostgreSQL.Simple.FromField as Pg\nimport qualified Database.PostgreSQL.Simple.ToField as Pg\nimport qualified Database.PostgreSQL.Simple.TypeInfo.Static as Pg\nimport qualified Database.PostgreSQL.Simple.Range as Pg\n\nimport           GHC.TypeLits\nimport           GHC.Exts hiding (toList)\n\n-- ** Postgres-specific functions\n\n-- | Postgres @NOW()@ function. Returns the server\'s timestamp\nnow_ :: QExpr Postgres s LocalTime\nnow_ = QExpr (\\_ -> PgExpressionSyntax (emit "NOW()"))\n\n-- | Postgres @ILIKE@ operator. A case-insensitive version of \'like_\'.\nilike_\n  :: BeamSqlBackendIsString Postgres text\n  => QExpr Postgres s text\n  -> QExpr Postgres s text\n  -> QExpr Postgres s Bool\nilike_ = ilike_\'\n\n-- | Postgres @ILIKE@ operator. A case-insensitive version of \'like_\'\'.\nilike_\'\n  :: ( BeamSqlBackendIsString Postgres left\n     , BeamSqlBackendIsString Postgres right\n     )\n  => QExpr Postgres s left\n  -> QExpr Postgres s right\n  -> QExpr Postgres s Bool\nilike_\' (QExpr a) (QExpr b) = QExpr (pgBinOp "ILIKE" <$> a <*> b)\n\n-- ** TsVector type\n\n-- | The type of a document preprocessed for full-text search. The contained\n-- \'ByteString\' is the Postgres representation of the @TSVECTOR@ type. Use\n-- \'toTsVector\' to construct these on-the-fly from strings.\n--\n-- When this field is embedded in a beam table, \'defaultMigratableDbSettings\'\n-- will give the column the postgres @TSVECTOR@ type.\nnewtype TsVector = TsVector ByteString\n  deriving (Show, Eq, Ord)\n\n-- | The identifier of a Postgres text search configuration.\n--\n-- Use the \'IsString\' instance to construct new values of this type\nnewtype TsVectorConfig = TsVectorConfig ByteString\n  deriving (Show, Eq, Ord, IsString)\n\ninstance Pg.FromField TsVector where\n  fromField field d =\n    if Pg.typeOid field /= Pg.typoid pgTsVectorTypeInfo\n    then Pg.returnError Pg.Incompatible field ""\n    else case d of\n           Just d\' -> pure (TsVector d\')\n           Nothing -> Pg.returnError Pg.UnexpectedNull field ""\n\ninstance Pg.ToField TsVector where\n  toField (TsVector d) =\n    Pg.Many [ Pg.Plain "($$"\n            , Pg.Plain (byteString d)\n            , Pg.Plain "$$::tsvector)" ]\n\ninstance FromBackendRow Postgres TsVector\n\ninstance HasSqlEqualityCheck Postgres TsVectorConfig\ninstance HasSqlQuantifiedEqualityCheck Postgres TsVectorConfig\n\ninstance HasSqlEqualityCheck Postgres TsVector\ninstance HasSqlQuantifiedEqualityCheck Postgres TsVector\n\n-- | A full-text search configuration with sensible defaults for english\nenglish :: TsVectorConfig\nenglish = TsVectorConfig "english"\n\n-- | The Postgres @to_tsvector@ function. Given a configuration and string,\n-- return the @TSVECTOR@ that represents the contents of the string.\ntoTsVector :: BeamSqlBackendIsString Postgres str\n           => Maybe TsVectorConfig -> QGenExpr context Postgres s str\n           -> QGenExpr context Postgres s TsVector\ntoTsVector Nothing (QExpr x) =\n  QExpr (fmap (\\(PgExpressionSyntax x\') ->\n                 PgExpressionSyntax $\n                 emit "to_tsvector(" <> x\' <> emit ")") x)\ntoTsVector (Just (TsVectorConfig configNm)) (QExpr x) =\n  QExpr (fmap (\\(PgExpressionSyntax x\') -> PgExpressionSyntax $\n                 emit "to_tsvector(\'" <> escapeString configNm <> emit "\', " <> x\' <> emit ")") x)\n\n-- | Determine if the given @TSQUERY@ matches the document represented by the\n-- @TSVECTOR@. Behaves exactly like the similarly-named operator in postgres.\n(@@) :: QGenExpr context Postgres s TsVector\n     -> QGenExpr context Postgres s TsQuery\n     -> QGenExpr context Postgres s Bool\nQExpr vec @@ QExpr q =\n  QExpr (pgBinOp "@@" <$> vec <*> q)\n\n-- ** TsQuery type\n\n-- | A query that can be run against a document contained in a \'TsVector\'.\n--\n-- When this field is embedded in a beam table, \'defaultMigratableDbSettings\'\n-- will give the column the postgres @TSVECTOR@ type\nnewtype TsQuery = TsQuery ByteString\n  deriving (Show, Eq, Ord)\n\ninstance HasSqlEqualityCheck Postgres TsQuery\ninstance HasSqlQuantifiedEqualityCheck Postgres TsQuery\n\ninstance Pg.FromField TsQuery where\n  fromField field d =\n    if Pg.typeOid field /= Pg.typoid pgTsQueryTypeInfo\n    then Pg.returnError Pg.Incompatible field ""\n    else case d of\n           Just d\' -> pure (TsQuery d\')\n           Nothing -> Pg.returnError Pg.UnexpectedNull field ""\n\ninstance FromBackendRow Postgres TsQuery\n\n-- | The Postgres @to_tsquery@ function. Given a configuration and string,\n-- return the @TSQUERY@ that represents the contents of the string.\ntoTsQuery :: BeamSqlBackendIsString Postgres str\n          => Maybe TsVectorConfig -> QGenExpr context Postgres s str\n          -> QGenExpr context Postgres s TsQuery\ntoTsQuery Nothing (QExpr x) =\n  QExpr (fmap (\\(PgExpressionSyntax x\') ->\n                 PgExpressionSyntax $\n                 emit "to_tsquery(" <> x\' <> emit ")") x)\ntoTsQuery (Just (TsVectorConfig configNm)) (QExpr x) =\n  QExpr (fmap (\\(PgExpressionSyntax x\') -> PgExpressionSyntax $\n                 emit "to_tsquery(\'" <> escapeString configNm <> emit "\', " <> x\' <> emit ")") x)\n\n-- ** Array operators\n\n-- TODO this should be robust to slices\n\n-- | Index into the given array. This translates to the @<array>[<index>]@\n-- syntax in postgres. The beam operator name has been chosen to match the\n-- \'Data.Vector.(!)\' operator.\n(!.) :: Integral ix\n     => QGenExpr context Postgres s (V.Vector a)\n     -> QGenExpr context Postgres s ix\n     -> QGenExpr context Postgres s a\nQExpr v !. QExpr ix =\n  QExpr (index <$> v <*> ix)\n  where\n    index (PgExpressionSyntax v\') (PgExpressionSyntax ix\') =\n      PgExpressionSyntax (emit "(" <> v\' <> emit ")[" <> ix\' <> emit "]")\n\n-- | Postgres @array_dims()@ function. Returns a textual representation of the\n-- dimensions of the array.\narrayDims_ :: BeamSqlBackendIsString Postgres text\n           => QGenExpr context Postgres s (V.Vector a)\n           -> QGenExpr context Postgres s text\narrayDims_ (QExpr v) = QExpr (fmap (\\(PgExpressionSyntax v\') -> PgExpressionSyntax (emit "array_dims(" <> v\' <> emit ")")) v)\n\ntype family CountDims (v :: *) :: Nat where\n  CountDims (V.Vector a) = 1 + CountDims a\n  CountDims a = 0\ntype family WithinBounds (dim :: Nat) (v :: *) :: Constraint where\n  WithinBounds dim v =\n    If ((dim <=? CountDims v) && (1 <=? dim))\n       (() :: Constraint)\n       (TypeError ( (\'Text "Dimension " \':<>: \'ShowType dim \':<>: \'Text " is out of bounds.") \':$$:\n                    (\'Text "The type " \':<>: \'ShowType v \':<>: \'Text " has " \':<>: \'ShowType (CountDims v) \':<>: \'Text " dimension(s).") \':$$:\n                    (\'Text "Hint: The dimension should be a natural between 1 and " \':<>: \'ShowType (CountDims v)) ))\n\n-- | Return the upper or lower bound of the given array at the given dimension\n--  (statically supplied as a type application on a \'GHC.TypeLits.Nat\'). Note\n--  that beam will attempt to statically determine if the dimension is in range.\n--  GHC errors will be thrown if this cannot be proved.\n--\n-- For example, to get the upper bound of the 2nd-dimension of an array:\n--\n-- @\n-- arrayUpper_ @2 vectorValuedExpression\n-- @\narrayUpper_, arrayLower_\n  :: forall (dim :: Nat) context num v s.\n     (KnownNat dim, WithinBounds dim (V.Vector v), Integral num)\n  => QGenExpr context Postgres s (V.Vector v)\n  -> QGenExpr context Postgres s num\narrayUpper_ v =\n  unsafeRetype (arrayUpperUnsafe_ v (val_ (natVal (Proxy @dim) :: Integer)) :: QGenExpr context Postgres s (Maybe Integer))\narrayLower_ v =\n  unsafeRetype (arrayLowerUnsafe_ v (val_ (natVal (Proxy @dim) :: Integer)) :: QGenExpr context Postgres s (Maybe Integer))\n\n-- | These functions can be used to find the lower and upper bounds of an array\n-- where the dimension number is not known until run-time. They are marked\n-- unsafe because they may cause query processing to fail at runtime, even if\n-- they typecheck successfully.\narrayUpperUnsafe_, arrayLowerUnsafe_\n  :: (Integral dim, Integral length)\n  => QGenExpr context Postgres s (V.Vector v)\n  -> QGenExpr context Postgres s dim\n  -> QGenExpr context Postgres s (Maybe length)\narrayUpperUnsafe_ (QExpr v) (QExpr dim) =\n  QExpr (fmap (PgExpressionSyntax . mconcat) . sequenceA $\n         [ pure (emit "array_upper(")\n         , fromPgExpression <$> v\n         , pure (emit ", ")\n         , fromPgExpression <$> dim\n         , pure (emit ")") ])\narrayLowerUnsafe_ (QExpr v) (QExpr dim) =\n  QExpr (fmap (PgExpressionSyntax . mconcat) . sequenceA $\n         [ pure (emit "array_lower(")\n         , fromPgExpression <$> v\n         , pure (emit ", ")\n         , fromPgExpression <$> dim\n         , pure (emit ")") ])\n\n-- | Get the size of the array at the given (statically known) dimension,\n-- provided as a type-level \'Nat\'. Like the \'arrayUpper_\' and \'arrayLower_\'\n-- functions,throws a compile-time error if the dimension is out of bounds.\narrayLength_\n  :: forall (dim :: Nat) ctxt num v s.\n     (KnownNat dim, WithinBounds dim (V.Vector v), Integral num)\n  => QGenExpr ctxt Postgres s (V.Vector v)\n  -> QGenExpr ctxt Postgres s num\narrayLength_ v =\n  unsafeRetype (arrayLengthUnsafe_ v (val_ (natVal (Proxy @dim) :: Integer)) :: QGenExpr ctxt Postgres s (Maybe Integer))\n\n-- | Get the size of an array at a dimension not known until run-time. Marked\n-- unsafe as this may cause runtime errors even if it type checks.\narrayLengthUnsafe_\n  :: (Integral dim, Integral num)\n  => QGenExpr ctxt Postgres s (V.Vector v)\n  -> QGenExpr ctxt Postgres s dim\n  -> QGenExpr ctxt Postgres s (Maybe num)\narrayLengthUnsafe_ (QExpr a) (QExpr dim) =\n  QExpr $ fmap (PgExpressionSyntax . mconcat) $ sequenceA $\n  [ pure (emit "array_length(")\n  , fromPgExpression <$> a\n  , pure (emit ", ")\n  , fromPgExpression <$> dim\n  , pure (emit ")") ]\n\n-- | The Postgres @&#x40;>@ operator. Returns true if every member of the second\n-- array is present in the first.\nisSupersetOf_ :: QGenExpr ctxt Postgres s (V.Vector a)\n              -> QGenExpr ctxt Postgres s (V.Vector a)\n              -> QGenExpr ctxt Postgres s Bool\nisSupersetOf_ (QExpr haystack) (QExpr needles) =\n  QExpr (pgBinOp "@>" <$> haystack <*> needles)\n\n-- | The Postgres @<&#x40;@ operator. Returns true if every member of the first\n-- array is present in the second.\nisSubsetOf_ :: QGenExpr ctxt Postgres s (V.Vector a)\n            -> QGenExpr ctxt Postgres s (V.Vector a)\n            -> QGenExpr ctxt Postgres s Bool\nisSubsetOf_ (QExpr needles) (QExpr haystack) =\n  QExpr (pgBinOp "<@" <$> needles <*> haystack)\n\n-- | Postgres @||@ operator. Concatenates two vectors and returns their result.\n(++.) :: QGenExpr ctxt Postgres s (V.Vector a)\n      -> QGenExpr ctxt Postgres s (V.Vector a)\n      -> QGenExpr ctxt Postgres s (V.Vector a)\nQExpr a ++. QExpr b =\n  QExpr (pgBinOp "||" <$> a <*> b)\n\n-- ** Array expressions\n\n-- | An expression context that determines which types of expressions can be put\n-- inside an array element. Any scalar, aggregate, or window expression can be\n-- placed within an array.\ndata PgArrayValueContext\n\n-- | If you are extending beam-postgres and provide another expression context\n-- that can be represented in an array, provide an empty instance of this class.\nclass PgIsArrayContext ctxt where\n  mkArraySyntax :: Proxy ctxt -> PgSyntax -> PgSyntax\n  mkArraySyntax _ s = emit "ARRAY" <> s\ninstance PgIsArrayContext PgArrayValueContext where\n  mkArraySyntax _ = id\ninstance PgIsArrayContext QValueContext\ninstance PgIsArrayContext QAggregateContext\ninstance PgIsArrayContext QWindowingContext\n\n-- | Build a 1-dimensional postgres array from an arbitrary \'Foldable\'\n-- containing expressions.\narray_ :: forall context f s a.\n          (PgIsArrayContext context, Foldable f)\n       => f (QGenExpr context Postgres s a)\n       -> QGenExpr context Postgres s (V.Vector a)\narray_ vs =\n  QExpr $ fmap (PgExpressionSyntax . mkArraySyntax (Proxy @context) . mconcat) $\n  sequenceA [ pure (emit "[")\n            , pgSepBy (emit ", ") <$> mapM (\\(QExpr e) -> fromPgExpression <$> e) (toList vs)\n            , pure (emit "]") ]\n\n-- | Build a 1-dimensional postgres array from a subquery\narrayOf_ :: Q Postgres db s (QExpr Postgres s a)\n         -> QGenExpr context Postgres s (V.Vector a)\narrayOf_ q =\n  let QExpr sub = subquery_ q\n  in QExpr (\\t -> let PgExpressionSyntax sub\' = sub t\n                  in PgExpressionSyntax (emit "ARRAY(" <> sub\' <> emit ")"))\n\n-- ** Ranges\n\n-- | Represents the types of bounds a range can have. A range can and often does have mis-matched\n-- bound types.\ndata PgBoundType\n  = Inclusive\n  | Exclusive\n  deriving (Eq, Show, Generic)\ninstance Hashable PgBoundType\n\nlBound :: PgBoundType -> ByteString\nlBound Inclusive = "["\nlBound Exclusive = "("\n\nuBound :: PgBoundType -> ByteString\nuBound Inclusive = "]"\nuBound Exclusive = ")"\n\n-- | Represents a single bound on a Range. A bound always has a type, but may not have a value\n-- (the absense of a value represents unbounded).\ndata PgRangeBound a = PgRangeBound PgBoundType (Maybe a) deriving (Eq, Show, Generic)\n\ninclusive :: a -> PgRangeBound a\ninclusive = PgRangeBound Inclusive . Just\n\nexclusive :: a -> PgRangeBound a\nexclusive = PgRangeBound Exclusive . Just\n\nunbounded :: PgRangeBound a\nunbounded = PgRangeBound Exclusive Nothing\n\n-- | A range of a given Haskell type (represented by @a@) stored as a given Postgres Range Type\n-- (represented by @n@).\n--\n-- A reasonable example might be @Range PgInt8Range Int64@.\n-- This represents a range of Haskell @Int64@ values stored as a range of \'bigint\' in Postgres.\ndata PgRange (n :: *) a\n  = PgEmptyRange\n  | PgRange (PgRangeBound a) (PgRangeBound a)\n  deriving (Eq, Show, Generic)\n\ninstance Hashable a => Hashable (PgRangeBound a)\n\ninstance Hashable a => Hashable (PgRange n a)\n\n-- | A class representing Postgres Range types and how to refer to them when speaking to the\n-- database.\n--\n-- For custom Range types, create an uninhabited type, and make it an instance of this class.\nclass PgIsRange n where\n  -- | The range type name in the database.\n  rangeName :: ByteString\n\ndata PgInt4Range\ninstance PgIsRange PgInt4Range where\n  rangeName = "int4range"\n\ndata PgInt8Range\ninstance PgIsRange PgInt8Range where\n  rangeName = "int8range"\n\ndata PgNumRange\ninstance PgIsRange PgNumRange where\n  rangeName = "numrange"\n\ndata PgTsRange\ninstance PgIsRange PgTsRange where\n  rangeName = "tsrange"\n\ndata PgTsTzRange\ninstance PgIsRange PgTsTzRange where\n  rangeName = "tstzrange"\n\ndata PgDateRange\ninstance PgIsRange PgDateRange where\n  rangeName = "daterange"\n\ninstance (Pg.FromField a, Typeable a, Typeable n, Ord a) => Pg.FromField (PgRange n a) where\n  fromField field d = do\n    pgR :: Pg.PGRange a <- Pg.fromField field d\n    if Pg.isEmpty pgR\n    then pure PgEmptyRange\n    else let Pg.PGRange lRange rRange = pgR\n         in pure $ PgRange (boundConv lRange) (boundConv rRange)\n\n-- According to Postgres docs, there is no such thing as an inclusive infinite bound.\n-- https://www.postgresql.org/docs/10/static/rangetypes.html#RANGETYPES-INFINITE\nboundConv :: Pg.RangeBound a -> PgRangeBound a\nboundConv Pg.NegInfinity = PgRangeBound Exclusive Nothing\nboundConv Pg.PosInfinity = PgRangeBound Exclusive Nothing\nboundConv (Pg.Inclusive a) = PgRangeBound Inclusive (Just a)\nboundConv (Pg.Exclusive a) = PgRangeBound Exclusive (Just a)\n\ninstance (Pg.ToField (Pg.PGRange a)) => Pg.ToField (PgRange n a) where\n  toField PgEmptyRange = Pg.toField (Pg.empty :: Pg.PGRange a)\n  toField (PgRange (PgRangeBound lt lb) (PgRangeBound ut ub)) = Pg.toField r\'\n    where\n      r\' = Pg.PGRange lb\' ub\'\n      lb\' = case (lt, lb) of (_, Nothing) -> Pg.NegInfinity\n                             (Inclusive, Just a) -> Pg.Inclusive a\n                             (Exclusive, Just a) -> Pg.Exclusive a\n      ub\' = case (ut, ub) of (_, Nothing) -> Pg.PosInfinity\n                             (Inclusive, Just a) -> Pg.Inclusive a\n                             (Exclusive, Just a) -> Pg.Exclusive a\n\ninstance HasSqlEqualityCheck Postgres (PgRange n a)\ninstance HasSqlQuantifiedEqualityCheck Postgres (PgRange n a)\n\ninstance (Pg.FromField a, Typeable a, Typeable n, Ord a) => FromBackendRow Postgres (PgRange n a)\ninstance (HasSqlValueSyntax PgValueSyntax a, PgIsRange n) =>\n  HasSqlValueSyntax PgValueSyntax (PgRange n a) where\n  sqlValueSyntax PgEmptyRange =\n    PgValueSyntax $\n    emit "\'empty\'::" <> escapeIdentifier (rangeName @n)\n  sqlValueSyntax (PgRange (PgRangeBound lbt mlBound) (PgRangeBound rbt muBound)) =\n    PgValueSyntax $\n    escapeIdentifier (rangeName @n) <> pgParens (pgSepBy (emit ", ") [lb, rb, bounds])\n    where\n      lb = sqlValueSyntax\' mlBound\n      rb = sqlValueSyntax\' muBound\n      bounds = emit "\'" <> emit (lBound lbt <> uBound rbt) <> emit "\'"\n      sqlValueSyntax\' = fromPgValue . sqlValueSyntax\n\n\nbinOpDefault :: ByteString\n             -> QGenExpr context Postgres s a\n             -> QGenExpr context Postgres s b\n             -> QGenExpr context Postgres s c\nbinOpDefault symbol (QExpr r1) (QExpr r2)  = QExpr (pgBinOp symbol <$> r1 <*> r2)\n\n(-@>-) :: QGenExpr context Postgres s (PgRange n a)\n      -> QGenExpr context Postgres s (PgRange n a)\n      -> QGenExpr context Postgres s Bool\n(-@>-) = binOpDefault "@>"\n\n(-@>) :: QGenExpr context Postgres s (PgRange n a)\n      -> QGenExpr context Postgres s a\n      -> QGenExpr context Postgres s Bool\n(-@>) = binOpDefault "@>"\n\n(-<@-) :: QGenExpr context Postgres s (PgRange n a)\n       -> QGenExpr context Postgres s (PgRange n a)\n       -> QGenExpr context Postgres s Bool\n(-<@-) = binOpDefault "<@"\n\n(<@-) :: QGenExpr context Postgres s a\n      -> QGenExpr context Postgres s (PgRange n a)\n      -> QGenExpr context Postgres s Bool\n(<@-) = binOpDefault "<@"\n\n(-&&-) :: QGenExpr context Postgres s (PgRange n a)\n       -> QGenExpr context Postgres s (PgRange n a)\n       -> QGenExpr context Postgres s Bool\n(-&&-) = binOpDefault "&&"\n\n(-<<-) :: QGenExpr context Postgres s (PgRange n a)\n       -> QGenExpr context Postgres s (PgRange n a)\n       -> QGenExpr context Postgres s Bool\n(-<<-) = binOpDefault "<<"\n\n(->>-) :: QGenExpr context Postgres s (PgRange n a)\n       -> QGenExpr context Postgres s (PgRange n a)\n       -> QGenExpr context Postgres s Bool\n(->>-) = binOpDefault ">>"\n\n(-&<-) :: QGenExpr context Postgres s (PgRange n a)\n       -> QGenExpr context Postgres s (PgRange n a)\n       -> QGenExpr context Postgres s Bool\n(-&<-) = binOpDefault "&<"\n\n(-&>-) :: QGenExpr context Postgres s (PgRange n a)\n       -> QGenExpr context Postgres s (PgRange n a)\n       -> QGenExpr context Postgres s Bool\n(-&>-) = binOpDefault "&>"\n\n(--|--) :: QGenExpr context Postgres s (PgRange n a)\n        -> QGenExpr context Postgres s (PgRange n a)\n        -> QGenExpr context Postgres s Bool\n(--|--) = binOpDefault "-|-"\n\n(-+-) :: QGenExpr context Postgres s (PgRange n a)\n      -> QGenExpr context Postgres s (PgRange n a)\n      -> QGenExpr context Postgres s (PgRange n a)\n(-+-) = binOpDefault "+"\n\n(-*-) :: QGenExpr context Postgres s (PgRange n a)\n      -> QGenExpr context Postgres s (PgRange n a)\n      -> QGenExpr context Postgres s (PgRange n a)\n(-*-) = binOpDefault "*"\n\n-- | The postgres range operator @-@ .\n(-.-) :: QGenExpr context Postgres s (PgRange n a)\n      -> QGenExpr context Postgres s (PgRange n a)\n      -> QGenExpr context Postgres s (PgRange n a)\n(-.-) = binOpDefault "-"\n\ndefUnaryFn :: ByteString\n           -> QGenExpr context Postgres s a\n           -> QGenExpr context Postgres s b\ndefUnaryFn fn (QExpr s) = QExpr (pgExprFrom <$> s)\n  where\n    pgExprFrom s\' = PgExpressionSyntax (emit fn <> emit "(" <> fromPgExpression s\' <> emit ")")\n\nrLower_ :: QGenExpr context Postgres s (PgRange n a)\n       -> QGenExpr context Postgres s (Maybe a)\nrLower_ = defUnaryFn "LOWER"\n\nrUpper_ :: QGenExpr context Postgres s (PgRange n a)\n       -> QGenExpr context Postgres s (Maybe a)\nrUpper_ = defUnaryFn "UPPER"\n\nisEmpty_ :: QGenExpr context Postgres s (PgRange n a)\n         -> QGenExpr context Postgres s Bool\nisEmpty_ = defUnaryFn "ISEMPTY"\n\nlowerInc_ :: QGenExpr context Postgres s (PgRange n a)\n          -> QGenExpr context Postgres s Bool\nlowerInc_ = defUnaryFn "LOWER_INC"\n\nupperInc_ :: QGenExpr context Postgres s (PgRange n a)\n          -> QGenExpr context Postgres s Bool\nupperInc_ = defUnaryFn "UPPER_INC"\n\nlowerInf_ :: QGenExpr context Postgres s (PgRange n a)\n          -> QGenExpr context Postgres s Bool\nlowerInf_ = defUnaryFn "LOWER_INF"\n\nupperInf_ :: QGenExpr context Postgres s (PgRange n a)\n          -> QGenExpr context Postgres s Bool\nupperInf_ = defUnaryFn "UPPER_INF"\n\nrangeMerge_ :: QGenExpr context Postgres s (PgRange n a)\n            -> QGenExpr context Postgres s (PgRange n a)\n            -> QGenExpr context Postgres s (PgRange n a)\nrangeMerge_ (QExpr r1) (QExpr r2) = QExpr (pgExprFrom <$> r1 <*> r2)\n  where\n    pgExprFrom r1\' r2\' =\n      PgExpressionSyntax\n      (emit "RANGE_MERGE(" <>\n       fromPgExpression r1\' <>\n       emit ", " <>\n       fromPgExpression r2\' <>\n       emit ")")\n\nrange_ :: forall n a context s. PgIsRange n\n       => PgBoundType -- ^ Lower bound type\n       -> PgBoundType -- ^ Upper bound type\n       -> QGenExpr context Postgres s (Maybe a) -- ^. Lower bound value\n       -> QGenExpr context Postgres s (Maybe a) -- ^. Upper bound value\n       -> QGenExpr context Postgres s (PgRange n a)\nrange_ lbt ubt (QExpr e1) (QExpr e2) = QExpr (pgExprFrom <$> e1 <*> e2)\n  where\n    bounds = emit "\'" <> emit (lBound lbt <> uBound ubt) <> emit "\'"\n    pgExprFrom e1\' e2\' =\n      PgExpressionSyntax\n      (escapeIdentifier (rangeName @n) <>\n       pgParens (pgSepBy (emit ", ") [fromPgExpression e1\', fromPgExpression e2\', bounds]))\n\n-- ** JSON\n\n-- | The Postgres @JSON@ type, which stores textual values that represent JSON\n-- objects. The type parameter indicates the Haskell type which the JSON\n-- encodes. This type must be a member of \'FromJSON\' and \'ToJSON\' in order for\n-- deserialization and serialization to work as expected.\n--\n-- The \'defaultMigratableDbSettings\' function automatically assigns the postgres\n-- @JSON@ type to fields with this type.\nnewtype PgJSON a = PgJSON a\n  deriving ( Show, Eq, Ord, Hashable, Monoid, Semigroup )\n\ninstance HasSqlEqualityCheck Postgres (PgJSON a)\ninstance HasSqlQuantifiedEqualityCheck Postgres (PgJSON a)\n\ninstance (Typeable x, FromJSON x) => Pg.FromField (PgJSON x) where\n  fromField field d =\n    if Pg.typeOid field /= Pg.typoid Pg.json\n    then Pg.returnError Pg.Incompatible field ""\n    else case eitherDecodeStrict <$> d of\n           Nothing -> Pg.returnError Pg.UnexpectedNull field ""\n           Just (Left e) -> Pg.returnError Pg.ConversionFailed field e\n           Just (Right d\') -> pure (PgJSON d\')\n\ninstance (Typeable a, FromJSON a) => FromBackendRow Postgres (PgJSON a)\ninstance ToJSON a => HasSqlValueSyntax PgValueSyntax (PgJSON a) where\n  sqlValueSyntax (PgJSON a) =\n    PgValueSyntax $\n    emit "\'" <> escapeString (BL.toStrict (encode a)) <> emit "\'::json"\n\n-- | The Postgres @JSONB@ type, which stores JSON-encoded data in a\n-- postgres-specific binary format. Like \'PgJSON\', the type parameter indicates\n-- the Haskell type which the JSON encodes.\n--\n-- Fields with this type are automatically given the Postgres @JSONB@ type\nnewtype PgJSONB a = PgJSONB a\n  deriving ( Show, Eq, Ord, Hashable, Monoid, Semigroup )\n\ninstance HasSqlEqualityCheck Postgres (PgJSONB a)\ninstance HasSqlQuantifiedEqualityCheck Postgres (PgJSONB a)\n\ninstance (Typeable x, FromJSON x) => Pg.FromField (PgJSONB x) where\n  fromField field d =\n    if Pg.typeOid field /= Pg.typoid Pg.jsonb\n    then Pg.returnError Pg.Incompatible field ""\n    else case eitherDecodeStrict <$> d of\n           Nothing -> Pg.returnError Pg.UnexpectedNull field ""\n           Just (Left e) -> Pg.returnError Pg.ConversionFailed field e\n           Just (Right d\') -> pure (PgJSONB d\')\n\ninstance (Typeable a, FromJSON a) => FromBackendRow Postgres (PgJSONB a)\ninstance ToJSON a => HasSqlValueSyntax PgValueSyntax (PgJSONB a) where\n  sqlValueSyntax (PgJSONB a) =\n    PgValueSyntax $\n    emit "\'" <> escapeString (BL.toStrict (encode a)) <> emit "\'::jsonb"\n\n-- | Key-value pair, used as output of \'pgJsonEachText\' and \'pgJsonEach\'\ndata PgJSONEach valType f\n  = PgJSONEach\n  { pgJsonEachKey :: C f T.Text\n  , pgJsonEachValue :: C f valType\n  } deriving Generic\ninstance Beamable (PgJSONEach valType)\n\n-- | Output row of \'pgJsonKeys\'\ndata PgJSONKey f = PgJSONKey { pgJsonKey :: C f T.Text }\n  deriving Generic\ninstance Beamable PgJSONKey\n\n-- | Output row of \'pgJsonArrayElements\' and \'pgJsonArrayElementsText\'\ndata PgJSONElement a f = PgJSONElement { pgJsonElement :: C f a }\n  deriving Generic\ninstance Beamable (PgJSONElement a)\n\n-- | Postgres provides separate @json_@ and @jsonb_@ functions. However, we know\n-- what we\'re dealing with based on the type of data, so we can be less obtuse.\n--\n-- For more information on how these functions behave, see the Postgres manual\n-- section on\n-- <https://www.postgresql.org/docs/current/static/functions-json.html JSON>.\n--\nclass IsPgJSON (json :: * -> *) where\n  -- | The @json_each@ or @jsonb_each@ function. Values returned as @json@ or\n  -- @jsonb@ respectively. Use \'pgUnnest\' to join against the result\n  pgJsonEach     :: QGenExpr ctxt Postgres s (json a)\n                 -> QGenExpr ctxt Postgres s (PgSetOf (PgJSONEach (json Value)))\n\n  -- | Like \'pgJsonEach\', but returning text values instead\n  pgJsonEachText :: QGenExpr ctxt Postgres s (json a)\n                 -> QGenExpr ctxt Postgres s (PgSetOf (PgJSONEach T.Text))\n\n  -- | The @json_object_keys@ and @jsonb_object_keys@ function. Use \'pgUnnest\'\n  -- to join against the result.\n  pgJsonKeys     :: QGenExpr ctxt Postgres s (json a)\n                 -> QGenExpr ctxt Postgres s (PgSetOf PgJSONKey)\n\n  -- | The @json_array_elements@ and @jsonb_array_elements@ function. Use\n  -- \'pgUnnest\' to join against the result\n  pgJsonArrayElements :: QGenExpr ctxt Postgres s (json a)\n                      -> QGenExpr ctxt Postgres s (PgSetOf (PgJSONElement (json Value)))\n\n  -- | Like \'pgJsonArrayElements\', but returning the values as \'T.Text\'\n  pgJsonArrayElementsText :: QGenExpr ctxt Postgres s (json a)\n                          -> QGenExpr ctxt Postgres s (PgSetOf (PgJSONElement T.Text))\n--  pgJsonToRecord\n--  pgJsonToRecordSet\n\n  -- | The @json_typeof@ or @jsonb_typeof@ function\n  pgJsonTypeOf :: QGenExpr ctxt Postgres s (json a) -> QGenExpr ctxt Postgres s T.Text\n\n  -- | The @json_strip_nulls@ or @jsonb_strip_nulls@ function.\n  pgJsonStripNulls :: QGenExpr ctxt Postgres s (json a)\n                   -> QGenExpr ctxt Postgres s (json b)\n\n  -- | The @json_agg@ or @jsonb_agg@ aggregate.\n  pgJsonAgg :: QExpr Postgres s a -> QAgg Postgres s (json a)\n\n  -- | The @json_object_agg@ or @jsonb_object_agg@. The first argument gives the\n  -- key source and the second the corresponding values.\n  pgJsonObjectAgg :: QExpr Postgres s key -> QExpr Postgres s value\n                  -> QAgg Postgres s (json a)\n\ninstance IsPgJSON PgJSON where\n  pgJsonEach (QExpr a) =\n    QExpr $ fmap (PgExpressionSyntax . mappend (emit "json_each") . pgParens . fromPgExpression) a\n\n  pgJsonEachText (QExpr a) =\n    QExpr $ fmap (PgExpressionSyntax . mappend (emit "json_each_text") . pgParens . fromPgExpression) a\n\n  pgJsonKeys (QExpr a) =\n    QExpr $ fmap (PgExpressionSyntax . mappend (emit "json_object_keys") . pgParens . fromPgExpression) a\n\n  pgJsonArrayElements (QExpr a) =\n    QExpr $ fmap (PgExpressionSyntax . mappend (emit "json_array_elements") . pgParens . fromPgExpression) a\n\n  pgJsonArrayElementsText (QExpr a) =\n    QExpr $ fmap (PgExpressionSyntax . mappend (emit "json_array_elements_text") . pgParens . fromPgExpression) a\n\n  pgJsonTypeOf (QExpr a) =\n    QExpr $ fmap (PgExpressionSyntax . mappend (emit "json_typeof") . pgParens . fromPgExpression) a\n\n  pgJsonStripNulls (QExpr a) =\n    QExpr $ fmap (PgExpressionSyntax . mappend (emit "json_strip_nulls") . pgParens . fromPgExpression) a\n\n  pgJsonAgg (QExpr a) =\n    QExpr $ fmap (PgExpressionSyntax . mappend (emit "json_agg") . pgParens . fromPgExpression) a\n\n  pgJsonObjectAgg (QExpr keys) (QExpr values) =\n    QExpr $ fmap (PgExpressionSyntax . mappend (emit "json_object_agg") . pgParens . mconcat) $\n    sequenceA $ [ fromPgExpression <$> keys, pure (emit ", ")\n                , fromPgExpression <$> values ]\n\ninstance IsPgJSON PgJSONB where\n  pgJsonEach (QExpr a) =\n    QExpr $ fmap (PgExpressionSyntax . mappend (emit "jsonb_each") . pgParens . fromPgExpression) a\n\n  pgJsonEachText (QExpr a) =\n    QExpr $ fmap (PgExpressionSyntax . mappend (emit "jsonb_each_text") . pgParens . fromPgExpression) a\n\n  pgJsonKeys (QExpr a) =\n    QExpr $ fmap (PgExpressionSyntax . mappend (emit "jsonb_object_keys") . pgParens . fromPgExpression) a\n\n  pgJsonArrayElements (QExpr a) =\n    QExpr $ fmap (PgExpressionSyntax . mappend (emit "jsonb_array_elements") . pgParens . fromPgExpression) a\n\n  pgJsonArrayElementsText (QExpr a) =\n    QExpr $ fmap (PgExpressionSyntax . mappend (emit "jsonb_array_elements_text") . pgParens . fromPgExpression) a\n\n  pgJsonTypeOf (QExpr a) =\n    QExpr $ fmap (PgExpressionSyntax . mappend (emit "jsonb_typeof") . pgParens . fromPgExpression) a\n\n  pgJsonStripNulls (QExpr a) =\n    QExpr $ fmap (PgExpressionSyntax . mappend (emit "jsonb_strip_nulls") . pgParens . fromPgExpression) a\n\n  pgJsonAgg (QExpr a) =\n    QExpr $ fmap (PgExpressionSyntax . mappend (emit "jsonb_agg") . pgParens . fromPgExpression) a\n\n  pgJsonObjectAgg (QExpr keys) (QExpr values) =\n    QExpr $ fmap (PgExpressionSyntax . mappend (emit "jsonb_object_agg") . pgParens . mconcat) $\n    sequenceA $ [ fromPgExpression <$> keys, pure (emit ", ")\n                , fromPgExpression <$> values ]\n\n-- | Postgres @&#x40;>@ and @<&#x40;@ operators for JSON. Return true if the\n-- json object pointed to by the arrow is completely contained in the other. See\n-- the Postgres documentation for more in formation on what this means.\n(@>), (<@)\n  :: QGenExpr ctxt Postgres s (PgJSONB a)\n  -> QGenExpr ctxt Postgres s (PgJSONB b)\n  -> QGenExpr ctxt Postgres s Bool\nQExpr a @> QExpr b =\n  QExpr (pgBinOp "@>" <$> a <*> b)\nQExpr a <@ QExpr b =\n  QExpr (pgBinOp "<@" <$> a <*> b)\n\n-- | Access a JSON array by index. Corresponds to the Postgres @->@ operator.\n-- See \'(->$)\' for the corresponding operator for object access.\n(->#) :: IsPgJSON json\n      => QGenExpr ctxt Postgres s (json a)\n      -> QGenExpr ctxt Postgres s Int32\n      -> QGenExpr ctxt Postgres s (json b)\nQExpr a -># QExpr b =\n  QExpr (pgBinOp "->" <$> a <*> b)\n\n-- | Acces a JSON object by key. Corresponds to the Postgres @->@ operator. See\n-- \'(->#)\' for the corresponding operator for arrays.\n(->$) :: IsPgJSON json\n      => QGenExpr ctxt Postgres s (json a)\n      -> QGenExpr ctxt Postgres s T.Text\n      -> QGenExpr ctxt Postgres s (json b)\nQExpr a ->$ QExpr b =\n  QExpr (pgBinOp "->" <$> a <*> b)\n\n-- | Access a JSON array by index, returning the embedded object as a string.\n-- Corresponds to the Postgres @->>@ operator. See \'(->>$)\' for the\n-- corresponding operator on objects.\n(->>#) :: IsPgJSON json\n       => QGenExpr ctxt Postgres s (json a)\n       -> QGenExpr ctxt Postgres s Int32\n       -> QGenExpr ctxt Postgres s T.Text\nQExpr a ->># QExpr b =\n  QExpr (pgBinOp "->>" <$> a <*> b)\n\n-- | Access a JSON object by key, returning the embedded object as a string.\n-- Corresponds to the Postgres @->>@ operator. See \'(->>#)\' for the\n-- corresponding operator on arrays.\n(->>$) :: IsPgJSON json\n       => QGenExpr ctxt Postgres s (json a)\n       -> QGenExpr ctxt Postgres s T.Text\n       -> QGenExpr ctxt Postgres s T.Text\nQExpr a ->>$ QExpr b =\n  QExpr (pgBinOp "->>" <$> a <*> b)\n\n-- | Access a deeply nested JSON object. The first argument is the JSON object\n-- to look within, the second is the path of keys from the first argument to the\n-- target. Returns the result as a new json value. Note that the postgres\n-- function allows etiher string keys or integer indices, but this function only\n-- allows string keys. PRs to improve this functionality are welcome.\n(#>) :: IsPgJSON json\n     => QGenExpr ctxt Postgres s (json a)\n     -> QGenExpr ctxt Postgres s (V.Vector T.Text)\n     -> QGenExpr ctxt Postgres s (json b)\nQExpr a #> QExpr b =\n  QExpr (pgBinOp "#>" <$> a <*> b)\n\n-- | Like \'(#>)\' but returns the result as a string.\n(#>>) :: IsPgJSON json\n      => QGenExpr ctxt Postgres s (json a)\n      -> QGenExpr ctxt Postgres s (V.Vector T.Text)\n      -> QGenExpr ctxt Postgres s T.Text\nQExpr a #>> QExpr b =\n  QExpr (pgBinOp "#>>" <$> a <*> b)\n\n-- | Postgres @?@ operator. Checks if the given string exists as top-level key\n-- of the json object.\n(?)\n  :: QGenExpr ctxt Postgres s (PgJSONB a)\n  -> QGenExpr ctxt Postgres s T.Text\n  -> QGenExpr ctxt Postgres s Bool\nQExpr a ? QExpr b =\n  QExpr (pgBinOp "?" <$> a <*> b)\n\n-- | Postgres @?|@ and @?&@ operators. Check if any or all of the given strings\n-- exist as top-level keys of the json object respectively.\n(?|), (?&)\n  :: QGenExpr ctxt Postgres s (PgJSONB a)\n  -> QGenExpr ctxt Postgres s (V.Vector T.Text)\n  -> QGenExpr ctxt Postgres s Bool\nQExpr a ?| QExpr b =\n  QExpr (pgBinOp "?|" <$> a <*> b)\nQExpr a ?& QExpr b =\n  QExpr (pgBinOp "?&" <$> a <*> b)\n\n-- | Postgres @-@ operator on json objects. Returns the supplied json object\n-- with the supplied key deleted. See \'withoutIdx\' for the corresponding\n-- operator on arrays.\nwithoutKey\n  :: QGenExpr ctxt Postgres s (PgJSONB a)\n  -> QGenExpr ctxt Postgres s T.Text\n  -> QGenExpr ctxt Postgres s (PgJSONB b)\nQExpr a `withoutKey` QExpr b =\n  QExpr (pgBinOp "-" <$> a <*> b)\n\n-- | Postgres @-@ operator on json arrays. See \'withoutKey\' for the\n-- corresponding operator on objects.\nwithoutIdx\n  :: QGenExpr ctxt Postgres s (PgJSONB a)\n  -> QGenExpr ctxt Postgres s Int32\n  -> QGenExpr ctxt Postgres s (PgJSONB b)\nQExpr a `withoutIdx` QExpr b =\n  QExpr (pgBinOp "-" <$> a <*> b)\n\n-- | Postgres @#-@ operator. Removes all the keys specificied from the JSON\n-- object and returns the result.\nwithoutKeys\n  :: QGenExpr ctxt Postgres s (PgJSONB a)\n  -> QGenExpr ctxt Postgres s (V.Vector T.Text)\n  -> QGenExpr ctxt Postgres s (PgJSONB b)\nQExpr a `withoutKeys` QExpr b =\n  QExpr (pgBinOp "#-" <$> a <*> b)\n\n-- | Postgres @json_array_length@ function. The supplied json object should be\n-- an array, but this isn\'t checked at compile-time.\npgJsonArrayLength :: IsPgJSON json => QGenExpr ctxt Postgres s (json a)\n                  -> QGenExpr ctxt Postgres s Int32\npgJsonArrayLength (QExpr a) =\n  QExpr $ \\tbl ->\n  PgExpressionSyntax (emit "json_array_length(" <> fromPgExpression (a tbl) <> emit ")")\n\n-- | Postgres @array_to_json@ function.\npgArrayToJson\n  :: QGenExpr ctxt Postgres s (V.Vector e)\n  -> QGenExpr ctxt Postgres s (PgJSON a)\npgArrayToJson (QExpr a) = QExpr $ a <&> PgExpressionSyntax .\n  mappend (emit "array_to_json") .\n  pgParens .\n  fromPgExpression\n\n-- | The postgres @jsonb_set@ function. \'pgJsonUpdate\' expects the value\n-- specified by the path in the second argument to exist. If it does not, the\n-- first argument is not modified. \'pgJsonbSet\' will create any intermediate\n-- objects necessary. This corresponds to the @create_missing@ argument of\n-- @jsonb_set@ being set to false or true respectively.\npgJsonbUpdate, pgJsonbSet\n  :: QGenExpr ctxt Postgres s (PgJSONB a)\n  -> QGenExpr ctxt Postgres s (V.Vector T.Text)\n  -> QGenExpr ctxt Postgres s (PgJSONB b)\n  -> QGenExpr ctxt Postgres s (PgJSONB a)\npgJsonbUpdate (QExpr a) (QExpr path) (QExpr newVal) =\n  QExpr $ fmap (PgExpressionSyntax . mappend (emit "jsonb_set") . pgParens . mconcat) $ sequenceA $\n  [ fromPgExpression <$> a, pure (emit ", "), fromPgExpression <$> path, pure (emit ", "), fromPgExpression <$> newVal ]\npgJsonbSet (QExpr a) (QExpr path) (QExpr newVal) =\n  QExpr $ fmap (PgExpressionSyntax . mappend (emit "jsonb_set") . pgParens . mconcat) $ sequenceA $\n  [ fromPgExpression <$> a, pure (emit ", "), fromPgExpression <$> path, pure (emit ", "), fromPgExpression <$> newVal, pure (emit ", true") ]\n\n-- | Postgres @jsonb_pretty@ function\npgJsonbPretty :: QGenExpr ctxt Postgres s (PgJSONB a)\n              -> QGenExpr ctxt Postgres s T.Text\npgJsonbPretty (QExpr a) =\n  QExpr (\\tbl -> PgExpressionSyntax (emit "jsonb_pretty" <> pgParens (fromPgExpression (a tbl))))\n\n-- ** Postgresql aggregates\n\n-- | An aggregate that adds each value to the resulting array. See \'pgArrayOver\'\n-- if you want to specify a quantifier. Corresponds to the Postgres @ARRAY_AGG@\n-- function.\npgArrayAgg :: QExpr Postgres s a\n           -> QAgg Postgres s (V.Vector a)\npgArrayAgg = pgArrayAggOver allInGroup_\n\n-- | Postgres @ARRAY_AGG@ with an explicit quantifier. Includes each row that\n-- meets the quantification criteria in the result.\npgArrayAggOver :: Maybe PgAggregationSetQuantifierSyntax\n               -> QExpr Postgres s a\n               -> QAgg Postgres s (V.Vector a)\npgArrayAggOver quantifier (QExpr a) =\n  QExpr $ \\tbl ->\n  PgExpressionSyntax $\n    emit "array_agg" <>\n    pgParens ( maybe mempty (\\q -> fromPgAggregationSetQuantifier q <> emit " ") quantifier <>\n               fromPgExpression (a tbl))\n\n-- | Postgres @bool_or@ aggregate. Returns true if any of the rows are true.\npgBoolOr :: QExpr Postgres s a\n         -> QAgg Postgres s (Maybe Bool)\npgBoolOr (QExpr a) =\n  QExpr $ \\tbl -> PgExpressionSyntax $\n  emit "bool_or" <> pgParens (fromPgExpression (a tbl))\n\n-- | Postgres @bool_and@ aggregate. Returns false unless every row is true.\npgBoolAnd :: QExpr Postgres s a\n          -> QAgg Postgres s (Maybe Bool)\npgBoolAnd (QExpr a) =\n  QExpr $ \\tbl -> PgExpressionSyntax $\n  emit "bool_and" <> pgParens (fromPgExpression (a tbl))\n\n-- *** String aggregations\n\n-- | Joins the string value in each row of the first argument, using the second\n-- argument as a delimiter. See \'pgStringAggOver\' if you want to provide\n-- explicit quantification.\npgStringAgg :: BeamSqlBackendIsString Postgres str\n            => QExpr Postgres s str\n            -> QExpr Postgres s str\n            -> QAgg Postgres s (Maybe str)\npgStringAgg = pgStringAggOver allInGroup_\n\n-- | The Postgres @string_agg@ function, with an explicit quantifier. Joins the\n-- values of the second argument using the delimiter given by the third.\npgStringAggOver :: BeamSqlBackendIsString Postgres str\n                => Maybe PgAggregationSetQuantifierSyntax\n                -> QExpr Postgres s str\n                -> QExpr Postgres s str\n                -> QAgg Postgres s (Maybe str)\npgStringAggOver quantifier (QExpr v) (QExpr delim) =\n  QExpr $ \\tbl -> PgExpressionSyntax $\n  emit "string_agg" <>\n  pgParens ( maybe mempty (\\q -> fromPgAggregationSetQuantifier q <> emit " ") quantifier <>\n             fromPgExpression (v tbl) <> emit ", " <>\n             fromPgExpression (delim tbl))\n\n-- ** Postgresql SELECT DISTINCT ON\n\n-- | Modify a query to only return rows where the supplied key function returns\n-- a unique value. This corresponds to the Postgres @DISTINCT ON@ support.\npgNubBy_ :: ( Projectible Postgres key\n            , Projectible Postgres r )\n         => (r -> key)\n         -> Q Postgres db s r\n         -> Q Postgres db s r\npgNubBy_ mkKey (Q q) =\n    Q . liftF $\n    QDistinct (\\r pfx -> pgSelectSetQuantifierDistinctOn\n                            (project (Proxy @Postgres) (mkKey r) pfx))\n              q id\n\n-- ** PostgreSql @MONEY@ data type\n\n-- | Postgres @MONEY@ data type. A simple wrapper over \'ByteString\', because\n--   Postgres money format is locale-dependent, and we don\'t handle currency\n--   symbol placement, digit grouping, or decimal separation.\n--\n--   The \'pgMoney\' function can be used to convert a number to \'PgMoney\'.\nnewtype PgMoney = PgMoney { fromPgMoney :: ByteString }\n  deriving (Show, Read, Eq, Ord)\n\ninstance Pg.FromField PgMoney where\n fromField field Nothing = Pg.returnError Pg.UnexpectedNull field ""\n fromField field (Just d) =\n   if Pg.typeOid field /= Pg.typoid Pg.money\n   then Pg.returnError Pg.Incompatible field ""\n   else pure (PgMoney d)\ninstance Pg.ToField PgMoney where\n  toField (PgMoney a) = Pg.toField a\n\ninstance HasSqlEqualityCheck Postgres PgMoney\ninstance HasSqlQuantifiedEqualityCheck Postgres PgMoney\n\ninstance FromBackendRow Postgres PgMoney\ninstance HasSqlValueSyntax PgValueSyntax PgMoney where\n  sqlValueSyntax (PgMoney a) = sqlValueSyntax a\n\n-- | Attempt to pack a floating point value as a \'PgMoney\' value, paying no\n-- attention to the locale-dependent currency symbol, digit grouping, or decimal\n-- point. This will use the @.@ symbol as the decimal separator.\npgMoney :: Real a => a -> PgMoney\npgMoney val = PgMoney (BC.pack (formatScientific Fixed Nothing exactVal))\n  where\n    exactVal = fromRational (toRational val) :: Scientific\n\n-- | Multiply a @MONEY@ value by a numeric value. Corresponds to the Postgres\n-- @*@ operator.\npgScaleMoney_ :: Num a\n              => QGenExpr context Postgres s a\n              -> QGenExpr context Postgres s PgMoney\n              -> QGenExpr context Postgres s PgMoney\npgScaleMoney_ (QExpr scale) (QExpr v) =\n  QExpr (pgBinOp "*" <$> scale <*> v)\n\n-- | Divide a @MONEY@ value by a numeric value. Corresponds to Postgres @/@\n-- where the numerator has type @MONEY@ and the denominator is a number. If you\n-- would like to divide two @MONEY@ values and have their units cancel out, use\n-- \'pgDivideMoneys_\'.\npgDivideMoney_ :: Num a\n               => QGenExpr context Postgres s PgMoney\n               -> QGenExpr context Postgres s a\n               -> QGenExpr context Postgres s PgMoney\npgDivideMoney_ (QExpr v) (QExpr scale) =\n  QExpr (pgBinOp "/" <$> v <*> scale)\n\n-- | Dividing two @MONEY@ value results in a number. Corresponds to Postgres @/@\n-- on two @MONEY@ values. If you would like to divide @MONEY@ by a scalar, use \'pgDivideMoney_\'\npgDivideMoneys_ :: Num a\n                => QGenExpr context Postgres s PgMoney\n                -> QGenExpr context Postgres s PgMoney\n                -> QGenExpr context Postgres s a\npgDivideMoneys_ (QExpr a) (QExpr b) =\n  QExpr (pgBinOp "/" <$> a <*> b)\n\n-- | Postgres @+@ and @-@ operators on money.\npgAddMoney_, pgSubtractMoney_\n  :: QGenExpr context Postgres s PgMoney\n  -> QGenExpr context Postgres s PgMoney\n  -> QGenExpr context Postgres s PgMoney\npgAddMoney_ (QExpr a) (QExpr b) =\n  QExpr (pgBinOp "+" <$> a <*> b)\npgSubtractMoney_ (QExpr a) (QExpr b) =\n  QExpr (pgBinOp "-" <$> a <*> b)\n\n-- | The Postgres @MONEY@ type can be summed or averaged in an aggregation.\n-- These functions provide the quantified aggregations. See \'pgSumMoney_\' and\n-- \'pgAvgMoney_\' for the unquantified versions.\npgSumMoneyOver_, pgAvgMoneyOver_\n  :: Maybe PgAggregationSetQuantifierSyntax\n  -> QExpr Postgres s PgMoney -> QExpr Postgres s PgMoney\npgSumMoneyOver_ q (QExpr a) = QExpr (sumE q <$> a)\npgAvgMoneyOver_ q (QExpr a) = QExpr (avgE q <$> a)\n\n-- | The Postgres @MONEY@ type can be summed or averaged in an aggregation. To\n-- provide an explicit quantification, see \'pgSumMoneyOver_\' and\n-- \'pgAvgMoneyOver_\'.\npgSumMoney_, pgAvgMoney_ :: QExpr Postgres s PgMoney\n                         -> QExpr Postgres s PgMoney\npgSumMoney_ = pgSumMoneyOver_ allInGroup_\npgAvgMoney_ = pgAvgMoneyOver_ allInGroup_\n\n-- ** Geometry types\n\ndata PgPoint = PgPoint {-# UNPACK #-} !Double {-# UNPACK #-} !Double\n  deriving (Show, Eq, Ord)\n\ndata PgLine = PgLine {-# UNPACK #-} !Double -- A\n                     {-# UNPACK #-} !Double -- B\n                     {-# UNPACK #-} !Double -- C\n  deriving (Show, Eq, Ord)\n\ndata PgLineSegment = PgLineSegment {-# UNPACK #-} !PgPoint {-# UNPACK #-} !PgPoint\n  deriving (Show, Eq, Ord)\n\ndata PgBox = PgBox {-# UNPACK #-} !PgPoint {-# UNPACK #-} !PgPoint\n  deriving (Show)\n\ninstance Eq PgBox where\n    PgBox a1 b1 == PgBox a2 b2 =\n        (a1 == a2 && b1 == b2) ||\n        (a1 == b2 && b1 == a2)\n\ndata PgPath\n  = PgPathOpen   (NE.NonEmpty PgPoint)\n  | PgPathClosed (NE.NonEmpty PgPoint)\n  deriving (Show, Eq, Ord)\n\ndata PgPolygon\n  = PgPolygon (NE.NonEmpty PgPoint)\n  deriving (Show, Eq, Ord)\n\ndata PgCircle = PgCircle {-# UNPACK #-} !PgPoint {-# UNPACK #-} !Double\n  deriving (Show, Eq, Ord)\n\nencodePgPoint :: PgPoint -> Builder\nencodePgPoint (PgPoint x y) =\n  "(" <> doubleDec x <> "," <> doubleDec y <> ")"\n\ninstance HasSqlValueSyntax PgValueSyntax PgPoint where\n  sqlValueSyntax pt =\n    PgValueSyntax $ emitBuilder ("\'" <> encodePgPoint pt <> "\'")\ninstance HasSqlValueSyntax PgValueSyntax PgLine where\n  sqlValueSyntax (PgLine a b c) =\n    PgValueSyntax $ emitBuilder ("\'{" <> doubleDec a <> "," <> doubleDec b <> "," <> doubleDec c <> "}\'")\ninstance HasSqlValueSyntax PgValueSyntax PgLineSegment where\n  sqlValueSyntax (PgLineSegment a b) =\n    PgValueSyntax $ emitBuilder ("\'(" <> encodePgPoint a <> "," <> encodePgPoint b <> ")\'")\ninstance HasSqlValueSyntax PgValueSyntax PgBox where\n  sqlValueSyntax (PgBox a b) =\n    PgValueSyntax $ emitBuilder ("\'(" <> encodePgPoint a <> "," <> encodePgPoint b <> ")\'")\n\n-- TODO Pg polygon and such\n\n-- TODO frombackendrow\n\ninstance Pg.FromField PgPoint where\n    fromField field Nothing = Pg.returnError Pg.UnexpectedNull field ""\n    fromField field (Just d) =\n        if Pg.typeOid field /= Pg.typoid Pg.point\n        then Pg.returnError Pg.Incompatible field ""\n        else case parseOnly pgPointParser d of\n               Left err -> Pg.returnError Pg.ConversionFailed field ("PgPoint: " ++ err)\n               Right pt -> pure pt\ninstance FromBackendRow Postgres PgPoint\n\npgPointParser :: Parser PgPoint\npgPointParser = PgPoint <$> (char \'(\' *> double <* char \',\')\n                        <*> (double <* char \')\')\n\ninstance Pg.FromField PgBox where\n    fromField field Nothing = Pg.returnError Pg.UnexpectedNull field ""\n    fromField field (Just d) =\n        if Pg.typeOid field /= Pg.typoid Pg.box\n        then Pg.returnError Pg.Incompatible field ""\n        else case parseOnly boxParser d of\n               Left  err -> Pg.returnError Pg.ConversionFailed field ("PgBox: " ++ err)\n               Right box -> pure box\n\n        where\n          boxParser = PgBox <$> (pgPointParser <* char \',\')\n                            <*> pgPointParser\ninstance FromBackendRow Postgres PgBox\n\n-- ** Regular expressions\n\n-- | The type of Postgres regular expressions. Only a\n-- \'HasSqlValueSyntax\' instance is supplied, because you won\'t need to\n-- be reading these back from the database.\n--\n-- If you\'re generating regexes dynamically, then use \'pgRegex_\' to\n-- convert a string expression into a regex one.\nnewtype PgRegex = PgRegex T.Text\n  deriving (Show, Eq, Ord, IsString)\n\ninstance HasSqlValueSyntax PgValueSyntax PgRegex where\n  sqlValueSyntax (PgRegex r) = sqlValueSyntax r\n\n-- | Convert a string valued expression (which could be generated\n-- dynamically) into a \'PgRegex\'-typed one.\npgRegex_ :: BeamSqlBackendIsString Postgres text => QGenExpr ctxt Postgres s text -> QGenExpr ctxt Postgres s PgRegex\npgRegex_ (QExpr e) = QExpr e\n\n-- | Match regular expression, case-sensitive\n(~.) :: BeamSqlBackendIsString Postgres text\n     => QGenExpr ctxt Postgres s text -> QGenExpr ctxt Postgres s PgRegex\n     -> QGenExpr ctxt Postgres s Bool\nQExpr t ~. QExpr re = QExpr (pgBinOp "~" <$> t <*> re)\n\n-- | Match regular expression, case-insensitive\n(~*.) :: BeamSqlBackendIsString Postgres text\n      => QGenExpr ctxt Postgres s text -> QGenExpr ctxt Postgres s PgRegex\n      -> QGenExpr ctxt Postgres s Bool\nQExpr t ~*. QExpr re = QExpr (pgBinOp "~*" <$> t <*> re)\n\n-- | Does not match regular expression, case-sensitive\n(!~.) :: BeamSqlBackendIsString Postgres text\n      => QGenExpr ctxt Postgres s text -> QGenExpr ctxt Postgres s PgRegex\n      -> QGenExpr ctxt Postgres s Bool\nQExpr t !~. QExpr re = QExpr (pgBinOp "!~" <$> t <*> re)\n\n-- | Does not match regular expression, case-insensitive\n(!~*.) :: BeamSqlBackendIsString Postgres text\n       => QGenExpr ctxt Postgres s text -> QGenExpr ctxt Postgres s PgRegex\n       -> QGenExpr ctxt Postgres s Bool\nQExpr t !~*. QExpr re = QExpr (pgBinOp "!~*" <$> t <*> re)\n\n-- | Postgres @regexp_replace@. Replaces all instances of the regex in\n-- the first argument with the third argument. The fourth argument is\n-- the postgres regex options to provide.\npgRegexpReplace_ :: BeamSqlBackendIsString Postgres text\n                 => QGenExpr ctxt Postgres s text -> QGenExpr ctxt Postgres s PgRegex\n                 -> QGenExpr ctxt Postgres s text -> QGenExpr ctxt Postgres s T.Text\n                 -> QGenExpr ctxt Postgres s txt\npgRegexpReplace_ (QExpr haystack) (QExpr needle) (QExpr replacement) (QExpr opts) =\n  QExpr (\\t -> PgExpressionSyntax $\n               emit "regexp_replace(" <> fromPgExpression (haystack t) <> emit ", "\n                                      <> fromPgExpression (needle t) <> emit ", "\n                                      <> fromPgExpression (replacement t) <> emit ", "\n                                      <> fromPgExpression (opts t) <> emit ")")\n\n-- | Postgres @regexp_match@. Matches the regular expression against\n-- the string given and returns an array where each element\n-- corresponds to a match in the string, or @NULL@ if nothing was\n-- found\npgRegexpMatch_ :: BeamSqlBackendIsString Postgres text\n               => QGenExpr ctxt Postgres s text -> QGenExpr ctxt Postgres s PgRegex\n               -> QGenExpr ctxt Postgres s (Maybe (V.Vector text))\npgRegexpMatch_ (QExpr s) (QExpr re) =\n  QExpr (\\t -> PgExpressionSyntax $\n               emit "regexp_match(" <> fromPgExpression (s t) <> emit ", "\n                                    <> fromPgExpression (re t) <> emit ")")\n\n-- | Postgres @regexp_split_to_array@. Splits the given string by the\n-- given regex and returns the result as an array.\npgRegexpSplitToArray :: BeamSqlBackendIsString Postgres text\n                     => QGenExpr ctxt Postgres s text -> QGenExpr ctxt Postgres s PgRegex\n                     -> QGenExpr ctxt Postgres s (V.Vector text)\npgRegexpSplitToArray (QExpr s) (QExpr re) =\n  QExpr (\\t -> PgExpressionSyntax $\n               emit "regexp_split_to_array(" <> fromPgExpression (s t) <> emit ", "\n                                             <> fromPgExpression (re t) <> emit ")")\n\nnewtype PgReResultT f\n  = PgReResultT { reResult :: C f T.Text }\n  deriving Generic\ninstance Beamable PgReResultT\n\n-- | Postgres @regexp_split_to_table@. Splits the given string by the\n-- given regex and return a result set that can be joined against.\npgRegexpSplitToTable :: BeamSqlBackendIsString Postgres text\n                     => QGenExpr ctxt Postgres s text -> QGenExpr ctxt Postgres s PgRegex\n\n                     -> Q Postgres db s (QExpr Postgres s T.Text)\npgRegexpSplitToTable (QExpr s) (QExpr re) =\n  fmap reResult $\n  pgUnnest\' (\\t -> emit "regexp_split_to_table(" <> fromPgExpression (s t) <> emit ", "\n                                                 <> fromPgExpression (re t) <> emit ")")\n\n-- ** Set-valued functions\n\ndata PgSetOf (tbl :: (* -> *) -> *)\n\npgUnnest\' :: forall tbl db s\n           . Beamable tbl\n          => (TablePrefix -> PgSyntax)\n          -> Q Postgres db s (QExprTable Postgres s tbl)\npgUnnest\' q =\n  Q (liftF (QAll (\\pfx alias ->\n                    PgFromSyntax . mconcat $\n                    [ q pfx, emit " "\n                    , pgQuotedIdentifier alias\n                    , pgParens (pgSepBy (emit ", ") (allBeamValues (\\(Columnar\' (TableField _ nm)) -> pgQuotedIdentifier nm) tblFields))\n                    ])\n                 (tableFieldsToExpressions tblFields)\n                 (\\_ -> Nothing) snd))\n  where\n    tblFields :: TableSettings tbl\n    tblFields =\n      evalState (zipBeamFieldsM (\\_ _ ->\n                                   do i <- get\n                                      put (i + 1)\n                                      let fieldNm = fromString ("r" ++ show i)\n                                      pure (Columnar\' (TableField (pure fieldNm) fieldNm)))\n                                tblSkeleton tblSkeleton) (0 :: Int)\n\n-- | Join the results of the given set-valued function to the query\npgUnnest :: forall tbl db s\n          . Beamable tbl\n         => QExpr Postgres s (PgSetOf tbl)\n         -> Q Postgres db s (QExprTable Postgres s tbl)\npgUnnest (QExpr q) = pgUnnest\' $ fromPgExpression . q\n\ndata PgUnnestArrayTbl a f = PgUnnestArrayTbl (C f a)\n  deriving Generic\ninstance Beamable (PgUnnestArrayTbl a)\n\n-- | Introduce each element of the array as a row\npgUnnestArray :: QExpr Postgres s (V.Vector a)\n              -> Q Postgres db s (QExpr Postgres s a)\npgUnnestArray (QExpr q) =\n  fmap (\\(PgUnnestArrayTbl x) -> x) $\n  pgUnnest\' (\\t -> emit "UNNEST" <> pgParens (fromPgExpression (q t)))\n\ndata PgUnnestArrayWithOrdinalityTbl a f = PgUnnestArrayWithOrdinalityTbl (C f Int64) (C f a)\n  deriving Generic\ninstance Beamable (PgUnnestArrayWithOrdinalityTbl a)\n\n-- | Introduce each element of the array as a row, along with the\n-- element\'s index\npgUnnestArrayWithOrdinality :: QExpr Postgres s (V.Vector a)\n                            -> Q Postgres db s (QExpr Postgres s Int64, QExpr Postgres s a)\npgUnnestArrayWithOrdinality (QExpr q) =\n  fmap (\\(PgUnnestArrayWithOrdinalityTbl i x) -> (i, x)) $\n  pgUnnest\' (\\t -> emit "UNNEST" <> pgParens (fromPgExpression (q t)) <> emit " WITH ORDINALITY")\n\ninstance HasDefaultSqlDataType Postgres PgPoint where\n  defaultSqlDataType _ _ _ = pgPointType\n\ninstance HasDefaultSqlDataType Postgres PgLine where\n  defaultSqlDataType _ _ _ = pgLineType\n\ninstance HasDefaultSqlDataType Postgres PgLineSegment where\n  defaultSqlDataType _ _ _ = pgLineSegmentType\n\ninstance HasDefaultSqlDataType Postgres PgBox where\n  defaultSqlDataType _ _ _ = pgBoxType\n\ninstance HasDefaultSqlDataType Postgres TsQuery where\n  defaultSqlDataType _ _ _ = pgTsQueryType\n\ninstance HasDefaultSqlDataType Postgres TsVector where\n  defaultSqlDataType _ _ _ = pgTsVectorType\n\ninstance HasDefaultSqlDataType Postgres (PgJSON a) where\n  defaultSqlDataType _ _ _ = pgJsonType\n\ninstance HasDefaultSqlDataType Postgres (PgJSONB a) where\n  defaultSqlDataType _ _ _ = pgJsonbType\n\ninstance HasDefaultSqlDataType Postgres PgMoney where\n  defaultSqlDataType _ _ _ = pgMoneyType\n\ninstance HasDefaultSqlDataType Postgres a\n    => HasDefaultSqlDataType Postgres (V.Vector a) where\n  defaultSqlDataType _ be embedded =\n      pgUnboundedArrayType (defaultSqlDataType (Proxy :: Proxy a) be embedded)\n\n-- ** Extract\n\ncentury_ :: HasSqlDate tgt => ExtractField Postgres tgt Int32\ncentury_ = ExtractField (PgExtractFieldSyntax (emit "CENTURY"))\n\ndecade_ :: HasSqlDate tgt => ExtractField Postgres tgt Int32\ndecade_ = ExtractField (PgExtractFieldSyntax (emit "DECADE"))\n\ndow_ :: HasSqlDate tgt => ExtractField Postgres tgt Int32\ndow_ = ExtractField (PgExtractFieldSyntax (emit "DOW"))\n\ndoy_ :: HasSqlDate tgt => ExtractField Postgres tgt Int32\ndoy_ = ExtractField (PgExtractFieldSyntax (emit "DOY"))\n\nepoch_ :: HasSqlTime tgt => ExtractField Postgres tgt NominalDiffTime\nepoch_ = ExtractField (PgExtractFieldSyntax (emit "EPOCH"))\n\nisodow_ :: HasSqlDate tgt => ExtractField Postgres tgt Int32\nisodow_ = ExtractField (PgExtractFieldSyntax (emit "ISODOW"))\n\nisoyear_ :: HasSqlDate tgt => ExtractField Postgres tgt Int32\nisoyear_ = ExtractField (PgExtractFieldSyntax (emit "ISOYEAR"))\n\nmicroseconds_ :: HasSqlTime tgt => ExtractField Postgres tgt Int32\nmicroseconds_ = ExtractField (PgExtractFieldSyntax (emit "MICROSECONDS"))\n\nmilliseconds_ :: HasSqlTime tgt => ExtractField Postgres tgt Int32\nmilliseconds_ = ExtractField (PgExtractFieldSyntax (emit "MILLISECONDS"))\n\nmillennium_ :: HasSqlDate tgt => ExtractField Postgres tgt Int32\nmillennium_ = ExtractField (PgExtractFieldSyntax (emit "MILLENNIUM"))\n\nquarter_ :: HasSqlDate tgt => ExtractField Postgres tgt Int32\nquarter_ = ExtractField (PgExtractFieldSyntax (emit "QUARTER"))\n\nweek_ :: HasSqlDate tgt => ExtractField Postgres tgt Int32\nweek_ = ExtractField (PgExtractFieldSyntax (emit "WEEK"))\n\n-- $full-text-search\n--\n-- Postgres has comprehensive, and thus complicated, support for full text\n-- search. The types and functions in this section map closely to the underlying\n-- Postgres API, which is described in the\n-- <https://www.postgresql.org/docs/current/static/textsearch-intro.html documentation>.\n--\n\n-- $arrays\n--\n-- The functions and types in this section map Postgres @ARRAY@ types to\n-- Haskell. An array is serialized and deserialized to a \'Data.Vector.Vector\'\n-- object. This type most closely matches the semantics of Postgres @ARRAY@s. In\n-- general, the names of functions in this section closely match names of the\n-- native Postgres functions they map to. As with most beam expression\n-- functions, names are suffixed with an underscore and CamelCased.\n--\n-- Note that Postgres supports arbitrary nesting of vectors. For example, two,\n-- three, or higher dimensional arrays can be expressed, manipulated, and stored\n-- in tables. Beam fully supports this use case. A two-dimensional postgres\n-- array is represented as @Vector (Vector a)@. Simply nest another \'Vector\' for\n-- higher dimensions. Some functions that return data on arrays expect a\n-- dimension number as a parameter. Since beam can check the dimension at\n-- compile time, these functions expect a type-level \'Nat\' in the expression\n-- DSL. The unsafe versions of these functions are also provided with the\n-- @Unsafe_@ suffix. The safe versions are guaranteed not to fail at run-time\n-- due to dimension mismatches, the unsafe ones may.\n--\n-- For more information on Postgres array support, refer to the postgres\n-- <https://www.postgresql.org/docs/current/static/functions-array.html manual>.\n\n-- $ranges\n--\n-- Postgres supports storing Range types in columns. There are serveral\n-- predefined Range types and users may create their own. @beam-postgres@\n-- fully supports these types, including user-defined range types. In general,\n-- the names of functions in this section closely match names of the native\n-- Postgres functions they map to. As with most beam expression functions,\n-- names are suffixed with an underscore and CamelCased. Where ambiguous,\n-- functions are prefixed with an @r@. Operators closely match their native\n-- Postgres counterparts, except they are prefixed and/or suffixed with an @-@\n-- to indicate the expression on that side is a Range. For example @-<\\@-@ maps\n-- to the native operator @<\\@@ when both arguments are Ranges, while @<\\@-@ maps\n-- to the same operator when the first argument is an element, not a range.\n--\n-- For more information on Postgres range support, refer to the postgres\n-- <https://www.postgresql.org/docs/current/static/rangetypes.html manual>.\n\n-- $json\n--\n-- Postgres supports storing JSON in columns, as either a text-based type\n-- (@JSON@) or a specialized binary encoding (@JSONB@). @beam-postgres@\n-- accordingly provides the \'PgJSON\' and \'PgJSONB\' data types. Each of these\n-- types takes a type parameter indicating the Haskell object represented by the\n-- JSON object stored in the column. In order for serialization to work, be sure\n-- to provide \'FromJSON\' and \'ToJSON\' instances for this type. If you do not\n-- know the shape of the data stored, substitute \'Value\' for this type\n-- parameter.\n--\n-- For more information on Postgres JSON support see the postgres\n-- <https://www.postgresql.org/docs/current/static/functions-json.html manual>.\n\n\n-- $set-valued-funs\n--\n-- Postgres supports functions that returns /sets/. We can join directly against\n-- these sets or arrays. @beam-postgres@ supports this feature via the\n-- \'pgUnnest\' and \'pgUnnestArray\' functions.\n--\n-- Any function that returns a set can be typed as an expression returning\n-- \'PgSetOf\'. This polymorphic type takes one argument, which is a \'Beamable\'\n-- type that represents the shape of the data in the rows. For example, the\n-- @json_each@ function returns a key and a value, so the corresponding\n-- @beam-postgres@ function (\'pgJsonEach\') returns a value of type \'PgSetOf\n-- (PgJSONEach Value)\', which represents a set containing \'PgJSONEach\'\n-- rows. \'PgJSONEach\' is a table with a column for keys (\'pgJsonEachKey\') and\n-- one for values (\'pgJsonEachValue\').\n--\n-- Any \'PgSetOf\' value can be introduced into the \'Q\' monad using the \'pgUnnest\'\n-- function.\n--\n-- Postgres arrays (represented by the \'V.Vector\' type) can also be joined\n-- against using the \'pgUnnestArray\' function. This directly corresponds to the\n-- SQL @UNNEST@ keyword. Unlike sets, arrays have a sense of order. The\n-- \'pgUnnestArrayWithOrdinality\' function allows you to join against the\n-- elements of an array along with its index. This corresponds to the\n-- @UNNEST .. WITH ORDINALITY@ clause.\n'