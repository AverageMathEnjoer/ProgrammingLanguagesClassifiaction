b'#\' gammaCKpar\n#\'\n#\' Field comparisons for string variables. Three possible agreement patterns are considered:\n#\' 0 total disagreement, 1 partial agreement, 2 agreement.\n#\' The distance between strings is calculated using a Jaro-Winkler distance.\n#\'\n#\' @usage gammaCKpar(matAp, matBp, n.cores, cut.a, cut.p, method, w)\n#\'\n#\' @param matAp vector storing the comparison field in data set 1\n#\' @param matBp vector storing the comparison field in data set 2\n#\' @param n.cores Number of cores to parallelize over. Default is NULL.\n#\' @param cut.a Lower bound for full match, ranging between 0 and 1. Default is 0.92\n#\' @param cut.p Lower bound for partial match, ranging between 0 and 1. Default is 0.88\n#\' @param method String distance method, options are: "jw" Jaro-Winkler (Default), "jaro" Jaro, and "lv" Edit\n#\' @param w Parameter that describes the importance of the first characters of a string (only needed if method = "jw"). Default is .10\n#\'\n#\' @return \\code{gammaCKpar} returns a list with the indices corresponding to each\n#\' matching pattern, which can be fed directly into \\code{tableCounts} and \\code{matchesLink}.\n#\'\n#\' @author Ted Enamorado <ted.enamorado@gmail.com>, Ben Fifield <benfifield@gmail.com>, and Kosuke Imai\n#\'\n#\' @examples\n#\' \\dontrun{\n#\' g1 <- gammaCKpar(dfA$firstname, dfB$lastname)\n#\' }\n#\'\n#\' @export\n#\' @importFrom stringdist stringdistmatrix\n## ------------------------\n## gammaCKpar: Now it takes values 0, 1, 2\n## This function applies gamma.k\n## in parallel\n## ------------------------\n\ngammaCKpar <- function(matAp, matBp, n.cores = NULL, cut.a = 0.92, cut.p = 0.88, method = "jw", w = .10) {\n\n    if(any(class(matAp) %in% c("tbl_df", "data.table"))){\n        matAp <- as.data.frame(matAp)[,1]\n    }\n    if(any(class(matBp) %in% c("tbl_df", "data.table"))){\n        matBp <- as.data.frame(matBp)[,1]\n    }\n    \n    matAp[matAp == ""] <- NA\n    matBp[matBp == ""] <- NA\n\n    if(sum(is.na(matAp)) == length(matAp) | length(unique(matAp)) == 1){\n        cat("WARNING: You have no variation in this variable, or all observations are missing in dataset A.\\n")\n    }\n    if(sum(is.na(matBp)) == length(matBp) | length(unique(matBp)) == 1){\n        cat("WARNING: You have no variation in this variable, or all observations are missing in dataset B.\\n")\n    }\n    \n    if(!(method %in% c("jw", "jaro", "lv"))){\n        stop("Invalid string distance method. Method should be one of \'jw\', \'jaro\', or \'lv\'.")\n    }\n\n    if(method == "jw" & !is.null(w)){\n        if(w < 0 | w > 0.25){\n        \tstop("Invalid value provided for w. Remember, w in [0, 0.25].")\n        }\n    }\n\n    if(is.null(n.cores)) {\n        n.cores <- detectCores() - 1\n    }\n\n    matrix.1 <- as.matrix(as.character(matAp))\n    matrix.2 <- as.matrix(as.character(matBp))\n\n    matrix.1[is.na(matrix.1)] <- "1234MF"\n    matrix.2[is.na(matrix.2)] <- "9876ES"\n\n    u.values.1 <- unique(matrix.1)\n    u.values.2 <- unique(matrix.2)\n\n    n.slices1 <- max(round(length(u.values.1)/(10000), 0), 1) \n    n.slices2 <- max(round(length(u.values.2)/(10000), 0), 1) \n\n    limit.1 <- round(quantile((0:nrow(u.values.2)), p = seq(0, 1, 1/n.slices2)), 0)\n    limit.2 <- round(quantile((0:nrow(u.values.1)), p = seq(0, 1, 1/n.slices1)), 0)\n\n    n.cores <- min(n.cores, n.slices1 * n.slices2)\n    \n    temp.1 <- temp.2 <- list()\n    \n    for(i in 1:n.slices2) {\n        temp.1[[i]] <- list(u.values.2[(limit.1[i]+1):limit.1[i+1]], limit.1[i])\n    }\n\n    for(i in 1:n.slices1) {\n        temp.2[[i]] <- list(u.values.1[(limit.2[i]+1):limit.2[i+1]], limit.2[i])\n    }\n\n    stringvec <- function(m, y, cut, strdist = method, p1 = w) {\n        x <- as.matrix(m[[1]])\n        e <- as.matrix(y[[1]])\n        \n        if(strdist == "jw") {\n        \t\tt <- 1 - stringdistmatrix(e, x, method = "jw", p = p1, nthread = 1)\n        \t\tt[ t < cut[[2]] ] <- 0\n        \t\tt <- Matrix(t, sparse = T)\n        \t}\n\n        if(strdist == "jaro") {\n        \t\tt <- 1 - stringdistmatrix(e, x, method = "jw", nthread = 1)\n        \t\tt[ t < cut[[2]] ] <- 0\n        \t\tt <- Matrix(t, sparse = T)\n        \t}\n\n        if(strdist == "lv") {\n            t <- stringdistmatrix(e, x, method = method, nthread = 1)\n            t.1 <- nchar(as.matrix(e))\n            t.2 <- nchar(as.matrix(x))\n            o <- t(apply(t.1, 1, function(w){ ifelse(w >= t.2, w, t.2)}))\n            t <- 1 - t * (1/o)\n        \t\tt[ t < cut[[2]] ] <- 0\n        \t\tt <- Matrix(t, sparse = T)\n        \t}\n        \n        t@x[t@x >= cut[1]] <- 2\n        t@x[t@x >= cut[2] & t@x < cut[1]] <- 1; gc()\n        slice.1 <- m[[2]]\n        slice.2 <- y[[2]]\n        indexes.2 <- which(t == 2, arr.ind = T)\n        indexes.2[, 1] <- indexes.2[, 1] + slice.2\n        indexes.2[, 2] <- indexes.2[, 2] + slice.1\n        indexes.1 <- which(t == 1, arr.ind = T)\n        indexes.1[, 1] <- indexes.1[, 1] + slice.2\n        indexes.1[, 2] <- indexes.1[, 2] + slice.1\n        list(indexes.2, indexes.1)\n    }\n\n    do <- expand.grid(1:n.slices2, 1:n.slices1)\n    \n    if (n.cores == 1) \'%oper%\' <- foreach::\'%do%\'\n    else { \n        \'%oper%\' <- foreach::\'%dopar%\'\n        cl <- makeCluster(n.cores)\n        registerDoParallel(cl)\n        on.exit(stopCluster(cl))\n    }\n\n    temp.f <- foreach(i = 1:nrow(do), .packages = c("stringdist", "Matrix")) %oper% { \n        r1 <- do[i, 1]\n        r2 <- do[i, 2]\n        stringvec(temp.1[[r1]], temp.2[[r2]], c(cut.a, cut.p))\n    }\n\n    gc()\n\n    reshape2 <- function(s) { s[[1]] }\n    reshape1 <- function(s) { s[[2]] }\n    temp.2 <- lapply(temp.f, reshape2)\n    temp.1 <- lapply(temp.f, reshape1)\n\n    indexes.2 <- do.call(\'rbind\', temp.2)\n    indexes.1 <- do.call(\'rbind\', temp.1)\n\n    ht1 <- new.env(hash=TRUE)\n    ht2 <- new.env(hash=TRUE)\n\n    n.values.2 <- as.matrix(cbind(u.values.1[indexes.2[, 1]], u.values.2[indexes.2[, 2]]))\n    n.values.1 <- as.matrix(cbind(u.values.1[indexes.1[, 1]], u.values.2[indexes.1[, 2]]))\n\n    if(sum(n.values.2 == "1234MF") > 0) {\n      t1 <- which(n.values.2 == "1234MF", arr.ind = T)[1]\n      n.values.2 <- n.values.2[-t1, ]; rm(t1)\n    }\n\n    if(sum(n.values.2 == "9876ES") > 0) {\n      t1 <- which(n.values.2 == "9876ES", arr.ind = T)[1]\n      n.values.2 <- n.values.2[-t1, ]; rm(t1)\n    }\n    \n    if(sum(n.values.1 == "1234MF") > 0) {\n      t1 <- which(n.values.1 == "1234MF", arr.ind = T)[1]\n      n.values.1 <- n.values.1[-t1, ]; rm(t1)\n    }\n    \n    if(sum(n.values.1 == "9876ES") > 0) {\n      t1 <- which(n.values.1 == "9876ES", arr.ind = T)[1]\n      n.values.1 <- n.values.1[-t1, ]; rm(t1)\n    }\n\n    matches.2 <- lapply(seq_len(nrow(n.values.2)), function(i) n.values.2[i, ])\n    matches.1 <- lapply(seq_len(nrow(n.values.1)), function(i) n.values.1[i, ])\n\n    if(Sys.info()[[\'sysname\']] == \'Windows\') {\n        if (n.cores == 1) \'%oper%\' <- foreach::\'%do%\'\n        else { \n            \'%oper%\' <- foreach::\'%dopar%\'\n            cl <- makeCluster(n.cores)\n            registerDoParallel(cl)\n            on.exit(stopCluster(cl))\n        }\n        if(length(matches.2) > 0) {\n            final.list2 <- foreach(i = 1:length(matches.2)) %oper% {\n            ht1 <- which(matrix.1 == matches.2[[i]][[1]]); ht2 <- which(matrix.2 == matches.2[[i]][[2]])\n            list(ht1, ht2)\n            }\n        }\n        if(length(matches.1) > 0) {\n                final.list1 <- foreach(i = 1:length(matches.1)) %oper% {\n                ht1 <- which(matrix.1 == matches.1[[i]][[1]]); ht2 <- which(matrix.2 == matches.1[[i]][[2]])\n                list(ht1, ht2)\n            }\n        }\n##        if(n.cores > 1){\n##            stopCluster(cl)\n##        }\n    } else {\n      no_cores <- n.cores\n    \tfinal.list2 <- mclapply(matches.2, function(s){\n            ht1 <- which(matrix.1 == s[1]); ht2 <- which(matrix.2 == s[2]);\n            list(ht1, ht2) }, mc.cores = getOption("mc.cores", no_cores))\n\n    \tfinal.list1 <- mclapply(matches.1, function(s){\n            ht1 <- which(matrix.1 == s[1]); ht2 <- which(matrix.2 == s[2]);\n            list(ht1, ht2) }, mc.cores = getOption("mc.cores", no_cores))\n    }\n\n    if(length(matches.2) == 0){ \n      final.list2 <- list()\n      warning("There are no identical (or nearly identical) matches. We suggest either changing the value of cut.p") \n    }\n    \n    if(length(matches.1) == 0){ \n    \tfinal.list1 <- list()\n    \twarning("There are no partial matches. We suggest either changing the value of cut.p or using gammaCK2par() instead") \n    }\n    \n    na.list <- list()\n    na.list[[1]] <- which(matrix.1 == "1234MF")\n    na.list[[2]] <- which(matrix.2 == "9876ES")\n\n    out <- list()\n    out[["matches2"]] <- final.list2\n    out[["matches1"]] <- final.list1\n    out[["nas"]] <- na.list\n    class(out) <- c("fastLink", "gammaCKpar")\n\n    return(out)\n}\n\n\n## ------------------------\n## End of gammaCKpar\n## ------------------------\n\n'