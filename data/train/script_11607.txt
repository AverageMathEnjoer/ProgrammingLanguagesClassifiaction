b'package com.codeest.geeknews.widget;\r\n\r\nimport android.content.Context;\r\nimport android.content.res.TypedArray;\r\nimport android.graphics.Bitmap;\r\nimport android.graphics.BitmapShader;\r\nimport android.graphics.Canvas;\r\nimport android.graphics.Color;\r\nimport android.graphics.Matrix;\r\nimport android.graphics.Paint;\r\nimport android.graphics.RectF;\r\nimport android.graphics.Shader;\r\nimport android.graphics.drawable.BitmapDrawable;\r\nimport android.graphics.drawable.ColorDrawable;\r\nimport android.graphics.drawable.Drawable;\r\nimport android.util.AttributeSet;\r\nimport android.widget.ImageView;\r\n\r\nimport com.codeest.geeknews.R;\r\n\r\n/**\r\n * Created by codeest on 2016/8/4.\r\n */\r\npublic class CircleImageView extends ImageView {\r\n\r\n    private static final ScaleType SCALE_TYPE = ScaleType.CENTER_CROP;\r\n\r\n    private static final Bitmap.Config BITMAP_CONFIG = Bitmap.Config.ARGB_8888;\r\n    private static final int COLORDRAWABLE_DIMENSION = 1;\r\n\r\n    private static final int DEFAULT_BORDER_WIDTH = 0;\r\n    private static final int DEFAULT_BORDER_COLOR = Color.BLACK;\r\n\r\n    private final RectF mDrawableRect = new RectF();\r\n    private final RectF mBorderRect = new RectF();\r\n\r\n    private final Matrix mShaderMatrix = new Matrix();\r\n    private final Paint mBitmapPaint = new Paint();\r\n    private final Paint mBorderPaint = new Paint();\r\n\r\n    private int mBorderColor = DEFAULT_BORDER_COLOR;\r\n    private int mBorderWidth = DEFAULT_BORDER_WIDTH;\r\n\r\n    private Bitmap mBitmap;\r\n    private BitmapShader mBitmapShader;\r\n    private int mBitmapWidth;\r\n    private int mBitmapHeight;\r\n\r\n    private float mDrawableRadius;\r\n    private float mBorderRadius;\r\n\r\n    private boolean mReady;\r\n    private boolean mSetupPending;\r\n\r\n    public CircleImageView(Context context) {\r\n        super(context);\r\n    }\r\n\r\n    public CircleImageView(Context context, AttributeSet attrs) {\r\n        this(context, attrs, 0);\r\n    }\r\n\r\n    public CircleImageView(Context context, AttributeSet attrs, int defStyle) {\r\n        super(context, attrs, defStyle);\r\n        super.setScaleType(SCALE_TYPE);\r\n\r\n        TypedArray a = context.obtainStyledAttributes(attrs, R.styleable.CircleImageView, defStyle, 0);\r\n\r\n        mBorderWidth = a.getDimensionPixelSize(R.styleable.CircleImageView_border_width, DEFAULT_BORDER_WIDTH);\r\n        mBorderColor = a.getColor(R.styleable.CircleImageView_border_color, DEFAULT_BORDER_COLOR);\r\n\r\n        a.recycle();\r\n\r\n        mReady = true;\r\n\r\n        if (mSetupPending) {\r\n            setup();\r\n            mSetupPending = false;\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public ScaleType getScaleType() {\r\n        return SCALE_TYPE;\r\n    }\r\n\r\n    @Override\r\n    public void setScaleType(ScaleType scaleType) {\r\n        if (scaleType != SCALE_TYPE) {\r\n            throw new IllegalArgumentException(String.format("ScaleType %s not supported.", scaleType));\r\n        }\r\n    }\r\n\r\n    @Override\r\n    protected void onDraw(Canvas canvas) {\r\n        if (getDrawable() == null) {\r\n            return;\r\n        }\r\n\r\n        canvas.drawCircle(getWidth() / 2, getHeight() / 2, mDrawableRadius, mBitmapPaint);\r\n        if (mBorderWidth != 0) {\r\n            canvas.drawCircle(getWidth() / 2, getHeight() / 2, mBorderRadius, mBorderPaint);\r\n        }\r\n    }\r\n\r\n    @Override\r\n    protected void onSizeChanged(int w, int h, int oldw, int oldh) {\r\n        super.onSizeChanged(w, h, oldw, oldh);\r\n        setup();\r\n    }\r\n\r\n    public int getBorderColor() {\r\n        return mBorderColor;\r\n    }\r\n\r\n    public void setBorderColor(int borderColor) {\r\n        if (borderColor == mBorderColor) {\r\n            return;\r\n        }\r\n\r\n        mBorderColor = borderColor;\r\n        mBorderPaint.setColor(mBorderColor);\r\n        invalidate();\r\n    }\r\n\r\n    public int getBorderWidth() {\r\n        return mBorderWidth;\r\n    }\r\n\r\n    public void setBorderWidth(int borderWidth) {\r\n        if (borderWidth == mBorderWidth) {\r\n            return;\r\n        }\r\n\r\n        mBorderWidth = borderWidth;\r\n        setup();\r\n    }\r\n\r\n    @Override\r\n    public void setImageBitmap(Bitmap bm) {\r\n        super.setImageBitmap(bm);\r\n        mBitmap = bm;\r\n        setup();\r\n    }\r\n\r\n    @Override\r\n    public void setImageDrawable(Drawable drawable) {\r\n        super.setImageDrawable(drawable);\r\n        mBitmap = getBitmapFromDrawable(drawable);\r\n        setup();\r\n    }\r\n\r\n    @Override\r\n    public void setImageResource(int resId) {\r\n        super.setImageResource(resId);\r\n        mBitmap = getBitmapFromDrawable(getDrawable());\r\n        setup();\r\n    }\r\n\r\n    private Bitmap getBitmapFromDrawable(Drawable drawable) {\r\n        if (drawable == null) {\r\n            return null;\r\n        }\r\n\r\n        if (drawable instanceof BitmapDrawable) {\r\n            return ((BitmapDrawable) drawable).getBitmap();\r\n        }\r\n\r\n        try {\r\n            Bitmap bitmap;\r\n\r\n            if (drawable instanceof ColorDrawable) {\r\n                bitmap = Bitmap.createBitmap(COLORDRAWABLE_DIMENSION, COLORDRAWABLE_DIMENSION, BITMAP_CONFIG);\r\n            } else {\r\n                bitmap = Bitmap.createBitmap(drawable.getIntrinsicWidth(), drawable.getIntrinsicHeight(), BITMAP_CONFIG);\r\n            }\r\n\r\n            Canvas canvas = new Canvas(bitmap);\r\n            drawable.setBounds(0, 0, canvas.getWidth(), canvas.getHeight());\r\n            drawable.draw(canvas);\r\n            return bitmap;\r\n        } catch (OutOfMemoryError e) {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    private void setup() {\r\n        if (!mReady) {\r\n            mSetupPending = true;\r\n            return;\r\n        }\r\n\r\n        if (mBitmap == null) {\r\n            return;\r\n        }\r\n\r\n        mBitmapShader = new BitmapShader(mBitmap, Shader.TileMode.CLAMP, Shader.TileMode.CLAMP);\r\n\r\n        mBitmapPaint.setAntiAlias(true);\r\n        mBitmapPaint.setShader(mBitmapShader);\r\n\r\n        mBorderPaint.setStyle(Paint.Style.STROKE);\r\n        mBorderPaint.setAntiAlias(true);\r\n        mBorderPaint.setColor(mBorderColor);\r\n        mBorderPaint.setStrokeWidth(mBorderWidth);\r\n\r\n        mBitmapHeight = mBitmap.getHeight();\r\n        mBitmapWidth = mBitmap.getWidth();\r\n\r\n        mBorderRect.set(0, 0, getWidth(), getHeight());\r\n        mBorderRadius = Math.min((mBorderRect.height() - mBorderWidth) / 2, (mBorderRect.width() - mBorderWidth) / 2);\r\n\r\n        mDrawableRect.set(mBorderWidth, mBorderWidth, mBorderRect.width() - mBorderWidth, mBorderRect.height() - mBorderWidth);\r\n        mDrawableRadius = Math.min(mDrawableRect.height() / 2, mDrawableRect.width() / 2);\r\n\r\n        updateShaderMatrix();\r\n        invalidate();\r\n    }\r\n\r\n    private void updateShaderMatrix() {\r\n        float scale;\r\n        float dx = 0;\r\n        float dy = 0;\r\n\r\n        mShaderMatrix.set(null);\r\n\r\n        if (mBitmapWidth * mDrawableRect.height() > mDrawableRect.width() * mBitmapHeight) {\r\n            scale = mDrawableRect.height() / (float) mBitmapHeight;\r\n            dx = (mDrawableRect.width() - mBitmapWidth * scale) * 0.5f;\r\n        } else {\r\n            scale = mDrawableRect.width() / (float) mBitmapWidth;\r\n            dy = (mDrawableRect.height() - mBitmapHeight * scale) * 0.5f;\r\n        }\r\n\r\n        mShaderMatrix.setScale(scale, scale);\r\n        mShaderMatrix.postTranslate((int) (dx + 0.5f) + mBorderWidth, (int) (dy + 0.5f) + mBorderWidth);\r\n\r\n        mBitmapShader.setLocalMatrix(mShaderMatrix);\r\n    }\r\n\r\n}'