b'{-# LANGUAGE LambdaCase #-}\n{-# LANGUAGE OverloadedStrings #-}\n{-# LANGUAGE TupleSections #-}\n\nmodule Hoodle.Coroutine.TextInput where\n\nimport Control.Applicative ()\nimport Control.Concurrent (killThread)\nimport qualified Control.Exception\nimport Control.Lens (view, (%~), (.~), (?~), (^.), _2, _3)\nimport Control.Monad (unless, void)\nimport Control.Monad.IO.Class (liftIO)\nimport Control.Monad.State (get, gets, modify, put)\nimport Control.Monad.Trans.Class (lift)\nimport Control.Monad.Trans.Crtn (CrtnErr (Other))\nimport Control.Monad.Trans.Crtn.Event (ActionOrder)\nimport Control.Monad.Trans.Crtn.Queue (enqueue)\nimport Control.Monad.Trans.Except (ExceptT (..), runExceptT, throwE)\nimport Control.Monad.Trans.Maybe (MaybeT (..))\nimport Data.Attoparsec.ByteString.Char8\n  ( decimal,\n    parseOnly,\n  )\nimport qualified Data.ByteString.Char8 as B\nimport Data.Foldable (forM_, mapM_)\nimport qualified Data.HashMap.Strict as M\nimport Data.Hoodle.BBox\n  ( BBox (..),\n    getBBox,\n  )\nimport Data.Hoodle.Generic\n  ( gembeddedtext,\n    gitems,\n  )\nimport Data.Hoodle.Select (gselEmbeddedText)\nimport Data.Hoodle.Simple\n  ( Anchor (..),\n    Dimension (..),\n    Image (..),\n    Item (..),\n    Link (..),\n    SVG (..),\n    dimension,\n    hoodleID,\n    items,\n    layers,\n  )\nimport Data.List (minimumBy)\nimport qualified Data.Maybe as Maybe (fromMaybe)\nimport qualified Data.Text as T\nimport qualified Data.Text.Encoding as TE\nimport qualified Data.Text.IO as TIO\nimport Data.UUID.V4 (nextRandom)\nimport Graphics.Hoodle.Render.Item (cnstrctRItem)\nimport Graphics.Hoodle.Render.Type.HitTest\n  ( AlterList (..),\n    Hitted (..),\n  )\nimport Graphics.Hoodle.Render.Type.Hoodle (rHoodle2Hoodle, rPage2Page)\nimport Graphics.Hoodle.Render.Type.Item (RItem (..))\nimport qualified Graphics.Rendering.Cairo as Cairo\nimport qualified Graphics.Rendering.Cairo.SVG as RSVG\nimport qualified Graphics.UI.Gtk as Gtk\nimport Hoodle.Accessor\n  ( getCurrentPageCurr,\n    getGeometry4CurrCvs,\n    pureUpdateUhdl,\n    updateUhdl,\n  )\nimport Hoodle.Coroutine.Commit (commit_)\nimport Hoodle.Coroutine.Dialog\n  ( fileChooser,\n    keywordDialog,\n    longTextMessageBox,\n    okMessageBox,\n  )\nimport Hoodle.Coroutine.Draw\n  ( callRenderer,\n    doIOaction_,\n    invalidateAll,\n    invalidateInBBox,\n    nextevent,\n    updateFlagFromToggleUI,\n    waitSomeEvent,\n  )\nimport Hoodle.Coroutine.LaTeX\n  ( getLaTeXComponentsFromHdl,\n    laTeXFooter,\n    laTeXHeader,\n  )\nimport Hoodle.Coroutine.Mode (modeChange)\nimport Hoodle.Coroutine.Network\n  ( networkTextInput,\n    networkTextInputBody,\n  )\nimport Hoodle.Coroutine.Page (canvasZoomUpdateAll)\nimport Hoodle.Coroutine.Select.Clipboard\n  ( deleteSelection,\n    updateTempHoodleSelectM,\n  )\nimport Hoodle.ModelAction.Layer (getCurrentLayer)\nimport Hoodle.ModelAction.Page (getPageFromGHoodleMap)\nimport Hoodle.ModelAction.Select\n  ( adjustItemPosition4Paste,\n    makePageSelectMode,\n  )\nimport Hoodle.ModelAction.Select.Transform (changeItemBy)\nimport Hoodle.ModelAction.Text\n  ( getKeywordMap,\n    getLinesFromText,\n  )\nimport Hoodle.Type.Canvas\n  ( currentPageNum,\n    unboxLens,\n  )\nimport Hoodle.Type.Coroutine (MainCoroutine, doIOaction)\nimport Hoodle.Type.Enum (DrawFlag (Efficient))\nimport Hoodle.Type.Event\n  ( AllEvent (..),\n    MultiLineEvent (..),\n    NetworkEvent (..),\n    RenderEvent (..),\n    UserEvent (..),\n    mkIOaction,\n  )\nimport Hoodle.Type.HoodleState\n  ( HoodleModeState (SelectState, ViewAppendState),\n    IsOneTimeSelectMode (YesAfterSelect),\n    currentCanvasInfo,\n    currentUnit,\n    doesUseXInput,\n    getCurrentCanvasId,\n    getHoodle,\n    hoodleModeState,\n    isOneTimeSelectMode,\n    networkEditSourceInfo,\n    settings,\n    statusBar,\n    tempQueue,\n    unitHoodles,\n  )\nimport Hoodle.Type.PageArrangement\n  ( PageCoordinate (..),\n    PageNum (..),\n  )\nimport Hoodle.Util\n  ( UrlPath (FileUrl, HttpUrl),\n    msgShout,\n    urlParse,\n  )\nimport System.Directory\n  ( doesFileExist,\n    getCurrentDirectory,\n    getTemporaryDirectory,\n    setCurrentDirectory,\n  )\nimport System.Exit (ExitCode (..))\nimport System.FilePath ((<.>), (</>))\nimport System.Process (readProcessWithExitCode)\nimport qualified Text.Hoodle.Parse.Attoparsec as PA\nimport Prelude hiding (mapM_, readFile)\n\n-- | common dialog with multiline edit input box\nmultiLineDialog :: T.Text -> (AllEvent -> IO ()) -> IO AllEvent\nmultiLineDialog str evhandler = do\n  dialog <- Gtk.dialogNew\n  upper <- fmap Gtk.castToContainer (Gtk.dialogGetContentArea dialog)\n  vbox <- Gtk.vBoxNew False 0\n  Gtk.containerAdd upper vbox\n  textbuf <- Gtk.textBufferNew Nothing\n  Gtk.textBufferSetByteString textbuf (TE.encodeUtf8 str)\n  _ <- textbuf `Gtk.on` Gtk.bufferChanged $ do\n    (s, e) <- (,) <$> Gtk.textBufferGetStartIter textbuf <*> Gtk.textBufferGetEndIter textbuf\n    contents <- Gtk.textBufferGetByteString textbuf s e False\n    (evhandler . UsrEv . MultiLine . MultiLineChanged) (TE.decodeUtf8 contents)\n  textarea <- Gtk.textViewNewWithBuffer textbuf\n  vscrbar <- Gtk.vScrollbarNew =<< Gtk.textViewGetVadjustment textarea\n  hscrbar <- Gtk.hScrollbarNew =<< Gtk.textViewGetHadjustment textarea\n  Gtk.widgetSetSizeRequest textarea 500 600\n  fdesc <- Gtk.fontDescriptionNew\n  Gtk.fontDescriptionSetFamily fdesc ("Mono" :: String)\n  Gtk.widgetModifyFont textarea (Just fdesc)\n  --\n  table <- Gtk.tableNew 2 2 False\n  Gtk.tableAttachDefaults table textarea 0 1 0 1\n  Gtk.tableAttachDefaults table vscrbar 1 2 0 1\n  Gtk.tableAttachDefaults table hscrbar 0 1 1 2\n  Gtk.boxPackStart vbox table Gtk.PackNatural 0\n  --\n  _btnOk <- Gtk.dialogAddButton dialog ("Ok" :: String) Gtk.ResponseOk\n  _btnCancel <- Gtk.dialogAddButton dialog ("Cancel" :: String) Gtk.ResponseCancel\n  _btnNetwork <- Gtk.dialogAddButton dialog ("Network" :: String) (Gtk.ResponseUser 1)\n  Gtk.widgetShowAll dialog\n  res <- Gtk.dialogRun dialog\n  Gtk.widgetDestroy dialog\n  case res of\n    Gtk.ResponseOk -> return (UsrEv (OkCancel True))\n    Gtk.ResponseCancel -> return (UsrEv (OkCancel False))\n    Gtk.ResponseUser 1 -> return (UsrEv (NetworkProcess NetworkDialog))\n    _ -> return (UsrEv (OkCancel False))\n\n-- | main event loop for multiline edit box\nmultiLineLoop :: T.Text -> MainCoroutine (Maybe T.Text)\nmultiLineLoop txt = do\n  r <- nextevent\n  case r of\n    UpdateCanvas cid ->\n      invalidateInBBox Nothing Efficient cid\n        >> multiLineLoop txt\n    OkCancel True -> (return . Just) txt\n    OkCancel False -> return Nothing\n    NetworkProcess NetworkDialog -> networkTextInput txt\n    MultiLine (MultiLineChanged txt\') -> multiLineLoop txt\'\n    _ -> multiLineLoop txt\n\n-- | insert text\ntextInput :: Maybe (Double, Double) -> T.Text -> MainCoroutine ()\ntextInput mpos str = do\n  case mpos of\n    Just (x0, y0) -> do\n      doIOaction (multiLineDialog str)\n      multiLineLoop str\n        >>= mapM_\n          ( \\result ->\n              deleteSelection\n                >> liftIO (makePangoTextSVG (x0, y0) result)\n                >>= svgInsert (result, "pango")\n          )\n    Nothing -> msgShout "textInput: not implemented"\n\n-- | insert latex\nlaTeXInput :: Maybe (Double, Double) -> T.Text -> MainCoroutine ()\nlaTeXInput mpos str = do\n  case mpos of\n    Just (x0, y0) -> do\n      doIOaction (multiLineDialog str)\n      multiLineLoop str\n        >>= mapM_\n          ( \\result ->\n              liftIO (makeLaTeXSVG (x0, y0) Nothing result) >>= \\case\n                Right r -> deleteSelection >> svgInsert (result, "latex") r\n                Left err -> okMessageBox err >> laTeXInput mpos result\n          )\n    Nothing -> do\n      modeChange ToViewAppendMode\n      autoPosText\n        >>= maybe\n          (laTeXInput (Just (100, 100)) str)\n          (\\y\' -> laTeXInput (Just (100, y\')) str)\n\nautoPosText :: MainCoroutine (Maybe Double)\nautoPosText = do\n  cpg <- rPage2Page <$> getCurrentPageCurr\n  let Dim _pgw pgh = view dimension cpg\n      mcomponents = do\n        l <- view layers cpg\n        i <- view items l\n        case i of\n          ItemSVG svg ->\n            case svg_command svg of\n              Just "latex" -> do\n                let (_, y) = svg_pos svg\n                    Dim _ h = svg_dim svg\n                return (y, y + h)\n              _ -> []\n          ItemImage img -> do\n            let (_, y) = img_pos img\n                Dim _ h = img_dim img\n            return (y, y + h)\n          _ -> []\n  if null mcomponents\n    then return Nothing\n    else do\n      let y0 = (minimumBy (flip compare) . map snd) mcomponents\n      if y0 + 10 > pgh then return Nothing else return (Just (y0 + 10))\n\n-- |\nlaTeXInputNetwork :: Maybe (Double, Double) -> T.Text -> MainCoroutine ()\nlaTeXInputNetwork mpos str =\n  case mpos of\n    Just (x0, y0) -> do\n      networkTextInput str\n        >>= mapM_\n          ( \\result ->\n              liftIO (makeLaTeXSVG (x0, y0) Nothing result)\n                >>= \\case\n                  Right r -> deleteSelection >> svgInsert (result, "latex") r\n                  Left err -> okMessageBox err >> laTeXInput mpos result\n          )\n    Nothing -> do\n      modeChange ToViewAppendMode\n      autoPosText\n        >>= maybe\n          (laTeXInputNetwork (Just (100, 100)) str)\n          (\\y\' -> laTeXInputNetwork (Just (100, y\')) str)\n\ndbusNetworkInput :: T.Text -> MainCoroutine ()\ndbusNetworkInput txt = do\n  modeChange ToViewAppendMode\n  mpos <- autoPosText\n  let pos = maybe (100, 100) (100,) mpos\n  rsvg <- liftIO (makeLaTeXSVG pos Nothing txt)\n  case rsvg of\n    Right r -> deleteSelection >> svgInsert (txt, "latex") r\n    Left err -> okMessageBox err >> laTeXInput (Just pos) txt\n\ncheck :: String -> IO (ExitCode, String) -> ExceptT String IO ()\ncheck msg act = do\n  er <- liftIO $ Control.Exception.try act\n  case er of\n    Left (Control.Exception.SomeException excp) -> throwE (show excp)\n    Right (ecode, str) ->\n      case ecode of\n        ExitSuccess -> pure ()\n        _ -> throwE (msg ++ ":" ++ str)\n\nmakeLaTeXSVG ::\n  (Double, Double) ->\n  Maybe Dimension ->\n  T.Text ->\n  IO (Either String (B.ByteString, BBox))\nmakeLaTeXSVG (x0, y0) mdim txt = do\n  cdir <- getCurrentDirectory\n  tdir <- getTemporaryDirectory\n  tfilename <- show <$> nextRandom\n  setCurrentDirectory tdir\n  B.writeFile (tfilename <.> "tex") (TE.encodeUtf8 txt)\n  r <- runExceptT $ do\n    check "error during xelatex" $ do\n      (ecode, ostr, estr) <- readProcessWithExitCode "xelatex" ["-shell-escape", tfilename <.> "tex"] ""\n      return (ecode, ostr ++ estr)\n    check "error during pdfcrop" $ do\n      (ecode, ostr, estr) <- readProcessWithExitCode "pdfcrop" [tfilename <.> "pdf", tfilename ++ "_crop" <.> "pdf"] ""\n      return (ecode, ostr ++ estr)\n    check "error during pdf2svg" $ do\n      (ecode, ostr, estr) <- readProcessWithExitCode "pdf2svg" [tfilename ++ "_crop" <.> "pdf", tfilename <.> "svg"] ""\n      return (ecode, ostr ++ estr)\n    bstr <- liftIO $ B.readFile (tfilename <.> "svg")\n    rsvg <- liftIO $ RSVG.svgNewFromString (B.unpack bstr)\n    let ow, oh :: Int\n        (ow, oh) = RSVG.svgGetSize rsvg\n        ow\', oh\' :: Double\n        (ow\', oh\') = (fromIntegral ow, fromIntegral oh)\n        w, h :: Double\n        (w, h) = maybe (ow\', oh\') (\\(Dim w\' _) -> (w\', oh\' * w\' / ow\')) mdim\n    return (bstr, BBox (x0, y0) (x0 + w, y0 + h))\n  setCurrentDirectory cdir\n  return r\n\n-- |\nsvgInsert :: (T.Text, String) -> (B.ByteString, BBox) -> MainCoroutine ()\nsvgInsert (txt, cmd) (svgbstr, BBox (x0, y0) (x1, y1)) = do\n  xst <- get\n  let uhdl = view (unitHoodles . currentUnit) xst\n      cid = getCurrentCanvasId uhdl\n      pgnum = view (unboxLens currentPageNum) . view currentCanvasInfo $ uhdl\n      hdl = getHoodle uhdl\n      currpage = getPageFromGHoodleMap pgnum hdl\n      currlayer = getCurrentLayer currpage\n  --\n  callRenderer $\n    GotRItem\n      <$> cnstrctRItem (ItemSVG (SVG (Just (TE.encodeUtf8 txt)) (Just (B.pack cmd)) svgbstr (x0, y0) (Dim (x1 - x0) (y1 - y0))))\n  RenderEv (GotRItem newitem) <-\n    waitSomeEvent (\\case RenderEv (GotRItem _) -> True; _ -> False)\n  --\n  let otheritems = view gitems currlayer\n  let ntpg =\n        makePageSelectMode\n          currpage\n          (otheritems :- Hitted [newitem] :- Empty)\n  modeChange ToSelectMode\n  updateUhdl $ \\nuhdl -> do\n    thdl <- case view hoodleModeState nuhdl of\n      SelectState thdl\' -> pure thdl\'\n      _ -> (lift . ExceptT . pure . Left . Other) "svgInsert"\n    nthdl <- updateTempHoodleSelectM cid thdl ntpg pgnum\n    return $ (hoodleModeState .~ SelectState nthdl) nuhdl\n  commit_\n  canvasZoomUpdateAll\n  invalidateAll\n\n-- |\nconvertLinkFromSimpleToDocID :: Link -> IO (Maybe Link)\nconvertLinkFromSimpleToDocID (Link i _typ lstr txt cmd rdr pos dim) = do\n  case urlParse (B.unpack lstr) of\n    Nothing -> return Nothing\n    Just (HttpUrl _url) -> return Nothing\n    Just (FileUrl file) -> do\n      b <- doesFileExist file\n      if b\n        then do\n          bstr <- B.readFile file\n          case parseOnly PA.hoodle bstr of\n            Left _str -> return Nothing\n            Right hdl -> do\n              let uuid = view hoodleID hdl\n                  link = LinkDocID i uuid (B.pack file) txt cmd rdr pos dim\n              return (Just link)\n        else return Nothing\nconvertLinkFromSimpleToDocID _ = return Nothing\n\n-- |\nlinkInsert ::\n  B.ByteString ->\n  (B.ByteString, FilePath) ->\n  String ->\n  (B.ByteString, BBox) ->\n  MainCoroutine ()\nlinkInsert _typ (uuidbstr, fname) str (svgbstr, BBox (x0, y0) (x1, y1)) = do\n  xst <- get\n  let uhdl = view (unitHoodles . currentUnit) xst\n  let pgnum = view (currentCanvasInfo . unboxLens currentPageNum) uhdl\n      lnk =\n        Link\n          uuidbstr\n          "simple"\n          (B.pack fname)\n          (Just (B.pack str))\n          Nothing\n          svgbstr\n          (x0, y0)\n          (Dim (x1 - x0) (y1 - y0))\n  nlnk <- liftIO $ convertLinkFromSimpleToDocID lnk >>= maybe (return lnk) return\n  --\n  callRenderer $\n    GotRItem <$> cnstrctRItem (ItemLink nlnk)\n  RenderEv (GotRItem newitem) <-\n    waitSomeEvent (\\case RenderEv (GotRItem _) -> True; _ -> False)\n  --\n  insertItemAt (Just (PageNum pgnum, PageCoord (x0, y0))) newitem\n\n-- | anchor\naddAnchor :: MainCoroutine ()\naddAnchor = do\n  uuid <- liftIO nextRandom\n  let uuidbstr = B.pack (show uuid)\n  let anc = Anchor uuidbstr "" (100, 100) (Dim 50 50)\n  --\n  callRenderer $\n    GotRItem <$> cnstrctRItem (ItemAnchor anc)\n  RenderEv (GotRItem nitm) <-\n    waitSomeEvent (\\case RenderEv (GotRItem _) -> True; _ -> False)\n  --\n  insertItemAt Nothing nitm\n\n-- |\nmakePangoTextSVG :: (Double, Double) -> T.Text -> IO (B.ByteString, BBox)\nmakePangoTextSVG (xo, yo) str = do\n  let pangordr = do\n        ctxt <- Gtk.cairoCreateContext Nothing\n        layout <- Gtk.layoutEmpty ctxt\n        Gtk.layoutSetWidth layout (Just 400)\n        Gtk.layoutSetWrap layout Gtk.WrapAnywhere\n        Gtk.layoutSetText layout (T.unpack str) -- this is gtk2hs pango limitation\n        (_, reclog) <- Gtk.layoutGetExtents layout\n        let Gtk.PangoRectangle x y w h = reclog\n        -- 10 is just dirty-fix\n        return (layout, BBox (x, y) (x + w + 10, y + h))\n      rdr layout = do\n        Cairo.setSourceRGBA 0 0 0 1\n        Gtk.updateLayout layout\n        Gtk.showLayout layout\n  (layout, BBox (x0, y0) (x1, y1)) <- pangordr\n  tdir <- getTemporaryDirectory\n  let tfile = tdir </> "embedded.svg"\n  Cairo.withSVGSurface tfile (x1 - x0) (y1 - y0) $ \\s ->\n    Cairo.renderWith s (rdr layout)\n  bstr <- B.readFile tfile\n  return (bstr, BBox (xo, yo) (xo + x1 - x0, yo + y1 - y0))\n\n-- | combine all LaTeX texts into a text file\ncombineLaTeXText :: MainCoroutine ()\ncombineLaTeXText = do\n  hdl <- gets (rHoodle2Hoodle . getHoodle . view (unitHoodles . currentUnit))\n  let sorted = getLaTeXComponentsFromHdl hdl\n      resulttxt = (T.intercalate "%%%%%%%%%%%%\\n\\n%%%%%%%%%%\\n" . map (view (_2 . _3))) sorted\n  mfilename <- fileChooser Gtk.FileChooserActionSave Nothing\n  forM_ mfilename (\\filename -> liftIO (TIO.writeFile filename resulttxt))\n\ninsertItemAt ::\n  Maybe (PageNum, PageCoordinate) ->\n  RItem ->\n  MainCoroutine ()\ninsertItemAt mpcoord ritm = do\n  xst <- get\n  let uhdl = view (unitHoodles . currentUnit) xst\n  geometry <- liftIO (getGeometry4CurrCvs uhdl)\n  let cid = getCurrentCanvasId uhdl\n      hdl = getHoodle uhdl\n      (pgnum, mpos) = case mpcoord of\n        Just (PageNum n, pos) -> (n, Just pos)\n        Nothing -> (view (currentCanvasInfo . unboxLens currentPageNum) uhdl, Nothing)\n      (ulx, uly) = (bbox_upperleft . getBBox) ritm\n      nitms =\n        case mpos of\n          Nothing -> adjustItemPosition4Paste geometry (PageNum pgnum) [ritm]\n          Just (PageCoord (nx, ny)) ->\n            map (changeItemBy (\\(x, y) -> (x + nx - ulx, y + ny - uly))) [ritm]\n  let pg = getPageFromGHoodleMap pgnum hdl\n      lyr = getCurrentLayer pg\n      oitms = view gitems lyr\n      ntpg = makePageSelectMode pg (oitms :- Hitted nitms :- Empty)\n  modeChange ToSelectMode\n  updateUhdl $ \\uhdl\' -> do\n    thdl <- case view hoodleModeState uhdl\' of\n      SelectState thdl\' -> return thdl\'\n      _ -> (lift . ExceptT . pure . Left . Other) "insertItemAt"\n    nthdl <- updateTempHoodleSelectM cid thdl ntpg pgnum\n    return . (hoodleModeState .~ SelectState nthdl)\n      . (isOneTimeSelectMode .~ YesAfterSelect)\n      $ uhdl\'\n  commit_\n  canvasZoomUpdateAll\n  invalidateAll\n\nembedTextSource :: MainCoroutine ()\nembedTextSource = do\n  mfilename <- fileChooser Gtk.FileChooserActionOpen Nothing\n  forM_ mfilename $ \\filename -> do\n    txt <- liftIO $ TIO.readFile filename\n    pureUpdateUhdl $ \\uhdl ->\n      let nhdlmodst = case uhdl ^. hoodleModeState of\n            ViewAppendState hdl -> ViewAppendState . (gembeddedtext ?~ txt) $ hdl\n            SelectState thdl -> SelectState . (gselEmbeddedText ?~ txt) $ thdl\n       in (hoodleModeState .~ nhdlmodst) uhdl\n    commit_\n\n-- |\neditEmbeddedTextSource :: MainCoroutine ()\neditEmbeddedTextSource = do\n  hdl <- gets (getHoodle . view (unitHoodles . currentUnit))\n  let mtxt = hdl ^. gembeddedtext\n  forM_ mtxt $ \\txt -> do\n    doIOaction (multiLineDialog txt)\n    multiLineLoop txt >>= \\case\n      Nothing -> return ()\n      Just ntxt -> do\n        pureUpdateUhdl $ \\uhdl ->\n          let nhdlmodst = case uhdl ^. hoodleModeState of\n                ViewAppendState hdl\' -> ViewAppendState . (gembeddedtext ?~ ntxt) $ hdl\'\n                SelectState thdl -> SelectState . (gselEmbeddedText ?~ ntxt) $ thdl\n           in (hoodleModeState .~ nhdlmodst) uhdl\n        commit_\n\n-- |\neditNetEmbeddedTextSource :: MainCoroutine ()\neditNetEmbeddedTextSource = do\n  hdl <- gets (getHoodle . view (unitHoodles . currentUnit))\n  let mtxt = hdl ^. gembeddedtext\n  forM_ mtxt $ \\txt -> do\n    networkTextInput txt >>= \\case\n      Nothing -> return ()\n      Just ntxt -> networkReceived ntxt\n\nnetworkReceived :: T.Text -> MainCoroutine ()\nnetworkReceived txt = do\n  pureUpdateUhdl $ \\uhdl ->\n    let nhdlmodst = case uhdl ^. hoodleModeState of\n          ViewAppendState hdl -> ViewAppendState . (gembeddedtext ?~ txt) $ hdl\n          SelectState thdl -> SelectState . (gselEmbeddedText ?~ txt) $ thdl\n     in (hoodleModeState .~ nhdlmodst) uhdl\n  commit_\n\n-- | insert text\ntextInputFromSource :: (Double, Double) -> MainCoroutine ()\ntextInputFromSource (x0, y0) =\n  void $\n    runMaybeT $ do\n      txtsrc <- MaybeT $ gets ((^. gembeddedtext) . getHoodle . view (unitHoodles . currentUnit))\n      lift $ modify (tempQueue %~ enqueue linePosDialog)\n      (l1, l2) <- MaybeT linePosLoop\n      let txt = getLinesFromText (l1, l2) txtsrc\n      lift deleteSelection\n      liftIO (makePangoTextSVG (x0, y0) txt)\n        >>= lift . svgInsert ("embedtxt:simple:L" <> T.pack (show l1) <> "," <> T.pack (show l2), "pango")\n\n-- | common dialog with line position\nlinePosDialog :: Either (ActionOrder AllEvent) AllEvent\nlinePosDialog = mkIOaction $ \\_evhandler -> do\n  dialog <- Gtk.dialogNew\n  upper <- fmap Gtk.castToContainer (Gtk.dialogGetContentArea dialog)\n  vbox <- Gtk.vBoxNew False 0\n  Gtk.containerAdd upper vbox\n  hbox <- Gtk.hBoxNew False 0\n  Gtk.boxPackStart vbox hbox Gtk.PackNatural 0\n  line1buf <- Gtk.entryBufferNew (Nothing :: Maybe String)\n  line1 <- Gtk.entryNewWithBuffer line1buf\n  Gtk.boxPackStart hbox line1 Gtk.PackNatural 2\n  line2buf <- Gtk.entryBufferNew (Nothing :: Maybe String)\n  line2 <- Gtk.entryNewWithBuffer line2buf\n  Gtk.boxPackStart hbox line2 Gtk.PackNatural 2\n  --\n  _btnOk <- Gtk.dialogAddButton dialog ("Ok" :: String) Gtk.ResponseOk\n  _btnCancel <- Gtk.dialogAddButton dialog ("Cancel" :: String) Gtk.ResponseCancel\n  Gtk.widgetShowAll dialog\n  res <- Gtk.dialogRun dialog\n  Gtk.widgetDestroy dialog\n  case res of\n    Gtk.ResponseOk -> do\n      line1str <- B.pack <$> Gtk.get line1buf Gtk.entryBufferText\n      line2str <- B.pack <$> Gtk.get line2buf Gtk.entryBufferText\n      let el1l2 =\n            (,) <$> parseOnly decimal line1str\n              <*> parseOnly decimal line2str\n      return . UsrEv . LinePosition\n        . either (const Nothing) (\\(l1, l2) -> if l1 <= l2 then Just (l1, l2) else Nothing)\n        $ el1l2\n    Gtk.ResponseCancel -> return (UsrEv (LinePosition Nothing))\n    _ -> return (UsrEv (LinePosition Nothing))\n\n-- | main event loop for line position dialog\nlinePosLoop :: MainCoroutine (Maybe (Int, Int))\nlinePosLoop = do\n  r <- nextevent\n  case r of\n    UpdateCanvas cid -> invalidateInBBox Nothing Efficient cid >> linePosLoop\n    LinePosition x -> return x\n    _ -> linePosLoop\n\n-- | insert text\nlaTeXInputKeyword ::\n  (Double, Double) ->\n  Maybe Dimension ->\n  T.Text ->\n  MaybeT MainCoroutine ()\nlaTeXInputKeyword (x0, y0) mdim keyword = do\n  txtsrc <- MaybeT $ gets ((^. gembeddedtext) . getHoodle . view (unitHoodles . currentUnit))\n  subpart <- (MaybeT . return . M.lookup keyword . getKeywordMap) txtsrc\n  let subpart\' = laTeXHeader <> "\\n" <> subpart <> laTeXFooter\n  liftIO (makeLaTeXSVG (x0, y0) mdim subpart\') >>= \\case\n    Right r -> lift $ do\n      deleteSelection\n      svgInsert ("embedlatex:keyword:" <> keyword, "latex") r\n    Left err -> lift $ do\n      longTextMessageBox err\n      -- okMessageBox err\n      return ()\n\n-- |\nlaTeXInputFromSource :: (Double, Double) -> MainCoroutine ()\nlaTeXInputFromSource (x0, y0) =\n  void . runMaybeT $ do\n    txtsrc <- MaybeT $ gets ((^. gembeddedtext) . getHoodle . view (unitHoodles . currentUnit))\n    let keylst = (map fst . M.toList . getKeywordMap) txtsrc\n    unless (null keylst) $ do\n      keyword <- MaybeT (keywordDialog keylst)\n      laTeXInputKeyword (x0, y0) Nothing keyword\n\n-- |\ntoggleNetworkEditSource :: MainCoroutine ()\ntoggleNetworkEditSource = do\n  xst <- get\n  let uhdl = view (unitHoodles . currentUnit) xst\n      hdl = getHoodle uhdl\n      mtxt = hdl ^. gembeddedtext\n  b <- updateFlagFromToggleUI "TOGGLENETSRCA" (settings . doesUseXInput)\n  forM_ (xst ^. statusBar) $ \\stbar ->\n    if b\n      then do\n        (ip, tid, _done) <- networkTextInputBody (Maybe.fromMaybe " " mtxt)\n        doIOaction_ $ do\n          let msg = "networkedit " ++ ip ++ " 4040"\n          ctxt <- Gtk.statusbarGetContextId stbar ("networkedit" :: String)\n          Gtk.statusbarPush stbar ctxt msg\n        (put . ((settings . networkEditSourceInfo) ?~ tid)) xst\n      else do\n        case xst ^. (settings . networkEditSourceInfo) of\n          Nothing -> return ()\n          Just tid -> do\n            doIOaction_ $ do\n              killThread tid\n              ctxt <- Gtk.statusbarGetContextId stbar ("networkedit" :: String)\n              Gtk.statusbarPush stbar ctxt ("Now no networkedit" :: String)\n            (put . ((settings . networkEditSourceInfo) .~ Nothing)) xst\n'