b'// Copyright (c) 2022-2023 Manuel Schneider\n\n#include "albert/albert.h"\n#include "albert/extensions/pluginprovider.h"\n#include "pluginregistry.h"\n#include "pluginwidget.h"\n#include <QAbstractTableModel>\n#include <QApplication>\n#include <QFormLayout>\n#include <QHeaderView>\n#include <QIcon>\n#include <QLabel>\n#include <QPlainTextEdit>\n#include <QSplitter>\n#include <algorithm>\n#include <map>\nusing namespace std;\nusing namespace albert;\n\n\nclass PluginModel: public QAbstractListModel\n{\npublic:\n    explicit PluginModel(PluginRegistry &plugin_registry) : plugin_registry_(plugin_registry)\n    {\n        connect(&plugin_registry, &PluginRegistry::pluginsChanged,\n                this, &PluginModel::updatePlugins);\n        updatePlugins();\n    }\n\nprivate:\n\n    QIcon getCachedIcon(const QString &url) const\n    {\n        try {\n            return icon_cache.at(url);\n        } catch (const std::out_of_range &e) {\n            return icon_cache.emplace(url, url).first->second;\n        }\n    }\n\n    int rowCount(const QModelIndex&) const override { return static_cast<int>(plugins_.size()); }\n\n    int columnCount(const QModelIndex&) const override { return 1; }\n\n    QVariant data(const QModelIndex &idx, int role) const override\n    {\n        if (!idx.isValid()\n            || idx.row() < 0 || rowCount(idx.parent()) <= idx.row()\n            || idx.column() < 0 || columnCount(idx.parent()) <= idx.column())\n            return {};\n\n        switch (const auto *p = plugins_[idx.row()]; role) {\n        case Qt::CheckStateRole:\n            if (p->metaData().user)\n                return plugin_registry_.isEnabled(p->metaData().id) ? Qt::Checked : Qt::Unchecked;\n            else\n                return {};\n            break;\n        case Qt::DisplayRole:\n            return p->metaData().name;\n        case Qt::ForegroundRole:\n            switch (p->state()) {\n                case PluginState::Loaded:\n                    return {};\n                case PluginState::Unloaded:\n                    return QColor(p->stateInfo().isEmpty() ? Qt::gray : Qt::red);\n                case PluginState::Invalid:\n                    return QColor(Qt::gray);\n            }\n                break;\n        case Qt::ToolTipRole:\n            return p->stateInfo();\n        }\n        return {};\n    }\n\n    bool setData(const QModelIndex &idx, const QVariant &value, int role) override\n    {\n        if (idx.isValid() && idx.column() == 0 && role == Qt::CheckStateRole){\n            try {\n                const auto *p = plugins_[idx.row()];\n                plugin_registry_.enable(p->metaData().id, value == Qt::Checked);\n                emit dataChanged(idx, idx);\n                return true;\n            } catch (std::out_of_range &e){}\n        }\n        return false;\n    }\n\n    Qt::ItemFlags flags(const QModelIndex &idx) const override\n    {\n        if (!idx.isValid() || idx.row() < 0 || rowCount(idx.parent()) <= idx.row())\n            return Qt::NoItemFlags;\n        else if (plugins_[idx.row()]->metaData().user)\n            return Qt::ItemIsSelectable | Qt::ItemNeverHasChildren | Qt::ItemIsEnabled | Qt::ItemIsUserCheckable;\n        else\n            return Qt::ItemIsSelectable | Qt::ItemNeverHasChildren | Qt::ItemIsEnabled;\n    }\n\n    void updatePlugins()\n    {\n        beginResetModel();\n        plugins_ = plugin_registry_.plugins();\n        ::sort(plugins_.begin(), plugins_.end(),\n               [](const auto &l, const auto &r){ return l->metaData().name < r->metaData().name; });\n        endResetModel();\n    }\n\n    PluginRegistry &plugin_registry_;\n    mutable std::map<QString, QIcon> icon_cache;\npublic:\n    std::vector<const PluginLoader*> plugins_;\n};\n\n\n\nPluginWidget::PluginWidget(PluginRegistry &plugin_registry) : model_(new PluginModel(plugin_registry))\n{\n    setObjectName("PluginWidget");\n\n    QSplitter *splitter = new QSplitter(this);\n    QHBoxLayout *horizontalLayout = new QHBoxLayout(this);\n    horizontalLayout->setContentsMargins(splitter->handleWidth(), splitter->handleWidth(),\n                                         splitter->handleWidth(), splitter->handleWidth());\n\n    horizontalLayout->addWidget(splitter);\n\n    listView_plugins = new QListView(this);\n    listView_plugins->setHorizontalScrollBarPolicy(Qt::ScrollBarAlwaysOff);\n    listView_plugins->setEditTriggers(QAbstractItemView::NoEditTriggers);\n    listView_plugins->setProperty("showDropIndicator", QVariant(false));\n    listView_plugins->setAlternatingRowColors(true);\n    listView_plugins->setSpacing(1);\n    listView_plugins->setUniformItemSizes(true);\n    listView_plugins->setModel(model_.get());\n    listView_plugins->setMaximumWidth(listView_plugins->sizeHintForColumn(0)\n                                      + qApp->style()->pixelMetric(QStyle::PM_ScrollBarExtent));\n\n    splitter->addWidget(listView_plugins);\n\n    scrollArea_info = new QScrollArea(this);\n    scrollArea_info->setFrameShape(QFrame::StyledPanel);\n    scrollArea_info->setFrameShadow(QFrame::Sunken);\n    scrollArea_info->setHorizontalScrollBarPolicy(Qt::ScrollBarAlwaysOff);\n    scrollArea_info->setWidgetResizable(true);\n    scrollArea_info->setAlignment(Qt::AlignLeading | Qt::AlignLeft | Qt::AlignTop);\n\n    splitter->addWidget(scrollArea_info);\n\n    connect(listView_plugins->selectionModel(), &QItemSelectionModel::currentChanged,\n            this, &PluginWidget::onUpdatePluginWidget);\n\n    connect(model_.get(), &PluginModel::dataChanged,\n            this, &PluginWidget::onUpdatePluginWidget);\n\n    onUpdatePluginWidget();\n}\n\nPluginWidget::~PluginWidget() = default;\n\nvoid PluginWidget::onUpdatePluginWidget()\n{\n    auto current = listView_plugins->currentIndex();\n    QLabel *l;\n\n    if (!current.isValid()){\n\n        l = new QLabel("Select a plugin");\n        l->setEnabled(false);\n        l->setAlignment(Qt::AlignCenter);\n        scrollArea_info->setWidget(l);\n        return;\n    }\n\n    auto &p = *model_->plugins_[current.row()];\n    auto *w = new QWidget;\n    auto *vb = new QVBoxLayout;\n    w->setLayout(vb);\n\n    // Title and description\n    vb->addWidget(new QLabel(\n            QString("<span style=\\"font-size:16pt;\\">%1</span><br><span style=\\"font-size:11pt;\\">%2</span>")\n                    .arg(p.metaData().name, p.metaData().description)\n    ));\n\n    // id, version, license, maintainers\n    QString maint = p.metaData().maintainers.isEmpty()\n                    ? "<span style=\\"color:#c04040;\\">This plugin is looking for a maintainer!</span>"\n                    : "Maintained by " + p.metaData().maintainers.join(", ");\n    l = new QLabel(QString("<span style=\\"font-size:9pt;font-style:italic;color:#808080;\\"><a href=\\"%1\\">%2 v%3</a> %4. %5</span>")\n                           .arg(p.metaData().url, p.metaData().id, p.metaData().version, p.metaData().license, maint));\n    l->setOpenExternalLinks(true);\n    vb->addWidget(l);\n\n\n    // Potentially long descrition\n    if (auto t = p.metaData().long_description; !t.isEmpty()){\n        l = new QLabel(p.metaData().long_description);\n        l->setTextFormat(Qt::MarkdownText);\n        l->setWordWrap(true);\n        l->setOpenExternalLinks(true);\n        vb->addWidget(l);\n    }\n\n    switch (p.state()) {\n        case PluginState::Invalid:\n            break;\n        case PluginState::Unloaded:\n            // Unloaded info\n            if (!p.stateInfo().isEmpty()){\n                l = new QLabel(p.stateInfo());\n                l->setWordWrap(true);\n                vb->addWidget(l);\n            }\n            break;\n        case PluginState::Loaded:\n            // Config widget\n            if (auto *inst = p.instance(); inst)\n                if (auto *cw = inst->buildConfigWidget())\n                    vb->addWidget(cw, 1); // Strech=1\n            break;\n    }\n\n    vb->addStretch();\n\n    auto add_meta = [&](const QString &s){\n        vb->addWidget(new QLabel(QString("<span style=\\"font-size:9pt;color:#808080;\\">%1</span>").arg(s)));\n    };\n\n    // Credits if any\n    if (!p.metaData().third_party_credits.isEmpty())\n        vb->addWidget(new QLabel(QString("<span style=\\"font-size:9pt;color:#808080;\\">Credits: %1</span>")\n                                         .arg(p.metaData().third_party_credits.join(", "))));\n\n    // Provider\n    vb->addWidget(new QLabel(QString("<span style=\\"font-size:9pt;color:#808080;\\">%1, Interface id:  %2</span>")\n                    .arg(p.provider()->name(), p.metaData().iid)));\n\n    // Requirements\n    if (!p.metaData().binary_dependencies.isEmpty())\n        add_meta(QString("Required executable(s) in PATH: %1").arg(p.metaData().binary_dependencies.join(", ")));\n    if (!p.metaData().runtime_dependencies.isEmpty())\n        add_meta(QString("Required libraries: %1").arg(p.metaData().runtime_dependencies.join(", ")));\n\n    // Path\n    add_meta(p.path);\n\n    scrollArea_info->setWidget(w);\n}\n'