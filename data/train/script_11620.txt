b'{-# LANGUAGE RecordWildCards, CPP, ScopedTypeVariables, FlexibleInstances  #-}\n\n-- Ported from CnC/C++ program by Ryan Newton\n-- Then ported again from the Haskell-CnC interface to monad-par. [2011.02.16]\n\n-- Description\n-- ===========\n\n-- The Black-Scholes equation is a differential equation that describes how,\n-- under a certain set of assumptions, the value of an option changes as the \n-- price of the underlying asset changes.\n\n-- The formula for a put option is similar. The cumulative normal distribution \n-- function, CND(x), gives the probability that normally distributed random\n-- variable will have a value less than x. There is no closed form expression for\n-- this function, and as such it must be evaluated numerically. The other \n-- parameters are as follows: S underlying asset\'s current price, \n-- X the strike price, T time to the expiration date, r risk-less rate of return,\n-- and v stock\'s volatility.\n\n-- Usage\n-- =====\n\n-- The command line is:\n\n-- blackscholes b n\n--     b  : positive integer for the size of blocks\n--     n  : positive integer for the number of options    \n-- e.g.\n-- blackscholes 100000 100 4\n\nimport Control.Seq\nimport Control.Monad\nimport Control.DeepSeq\nimport Control.Exception\n\n#ifdef PARSCHED \nimport PARSCHED\n#else\nimport Control.Monad.Par\n#endif\n\n#ifdef NEW_GENERIC\n#warning "Using new generic interface."\nimport qualified Data.Par as C\n#else\nimport qualified Control.Monad.Par.Combinator as C\n#endif\n-- import Control.Monad.Par.AList\n\nimport Data.Array\nimport Data.List\nimport qualified Data.Array.Unboxed as U\nimport System.Environment\n\n--------------------------------------------------------------------------------\n\ntype FpType = Float\n\n-- This tuple contains the inputs for one invocation of our kernel\ndata ParameterSet =  ParameterSet {\n\tsptprice   :: FpType,\n\tstrike     :: FpType,\n\trate       :: FpType,\n\tvolatility :: FpType ,\n\totime      :: FpType,\n\totype      :: Bool\n} deriving Show\n\ndata_init :: Array Int ParameterSet\n\n-- This defines some hard coded data as a big constant array:\n#include "blackscholes_data.hs"\nsize_init = let (s,e) = bounds data_init in e - s + 1\n\ninv_sqrt_2xPI = 0.39894228040143270286\n\n--------------------------------------------------------------------------------\n-- Scalar code follows:\n\ncndf :: FpType -> FpType\ncndf inputX = if sign then 1.0 - xLocal else xLocal\n  where \n    sign = inputX < 0.0\n    inputX\' = if sign then -inputX else inputX\n    \n    -- Compute NPrimeX term common to both four & six decimal accuracy calcs\n    xNPrimeofX = inv_sqrt_2xPI * exp(-0.5 * inputX * inputX);\n\n    xK2 = 1.0 / (0.2316419 * inputX + 1.0);    \n    xK2_2 = xK2   * xK2; -- Need all powers of xK2 from ^1 to ^5:\n    xK2_3 = xK2_2 * xK2;\n    xK2_4 = xK2_3 * xK2;\n    xK2_5 = xK2_4 * xK2;\n    \n    xLocal   = 1.0 - xLocal_1 * xNPrimeofX;\n    xLocal_1 = xK2   *   0.319381530  + xLocal_2;\n    xLocal_2 = xK2_2 * (-0.356563782) + xLocal_3 + xLocal_3\' + xLocal_3\'\';\n    xLocal_3   = xK2_3 * 1.781477937;\n    xLocal_3\'  = xK2_4 * (-1.821255978);\n    xLocal_3\'\' = xK2_5 * 1.330274429;\n\n\nblkSchlsEqEuroNoDiv :: FpType -> FpType -> FpType -> FpType -> FpType -> Bool -> Float -> FpType\nblkSchlsEqEuroNoDiv sptprice strike rate volatility time otype timet =\n   if not otype\n   then (sptprice * nofXd1) - (futureValueX * nofXd2)\n   else let negNofXd1 = 1.0 - nofXd1\n\t    negNofXd2 = 1.0 - nofXd2\n\tin (futureValueX * negNofXd2) - (sptprice * negNofXd1)\n where \n   logValues  = log( sptprice / strike )                \n   xPowerTerm = 0.5 * volatility * volatility\n   xDen = volatility * sqrt(time)\n   xD1  = (((rate + xPowerTerm) * time) + logValues) / xDen\n   xD2  = xD1 -  xDen\n\n   nofXd1 = cndf xD1 \n   nofXd2 = cndf xD1    \n   futureValueX = strike *  exp ( -(rate) * (time) )\n\n--------------------------------------------------------------------------------\n\n-- `t` is the index for the (starting) option we must compute\ncomputeSegment :: Int -> Int -> U.UArray Int FpType\ncomputeSegment granularity t = arr\n where \n  arr = U.listArray (0, granularity-1) $\n        Prelude.map fn [0 .. granularity-1]\n  fn i = let ParameterSet { .. } = data_init U.! ((t+i) `mod` size_init)\n\t in blkSchlsEqEuroNoDiv sptprice strike rate volatility otime otype 0\n\n--------------------------------------------------------------------------------\n\n-- No need to go deeper here because its unboxed, right?\ninstance NFData (U.UArray Int FpType) where\n\nmain = do args <- getArgs\n          -- How many [stock] options shall we run through the algorithm, and in\n          -- chunks of what granularity?\n          let (numOptions, granularity) =\n               case args of \n  \t         []      -> (10000, 1000)\n  \t         [b]     -> (10, read b)\n\t         [b,n] -> (read n, read b)\n\n          if granularity > numOptions\n\t   then error "Granularity must be smaller than numOptions!!"\n\t   else return ()\n\n\t  putStrLn$ "Running blackscholes, numOptions "++ show numOptions ++ " and block size " ++ show granularity\n\n          let numChunks = numOptions `quot` granularity\n--\t      results = runPar$ parMap (computeSegment granularity . (* granularity)) [0..numChunks-1]\n\n#if 1\n\t      results = runPar$ C.parMap (computeSegment granularity) [0, granularity .. numOptions-1]\n#else\n-- Not working right yet [2011.02.18]\n              results = toList$ runPar$ \n\t\t\tparBuild 1 0 (numChunks-1) \n\t\t\t  (computeSegment granularity . (* granularity))\n#endif\n\t      sum = foldl1\' (+) $ map (U.! 0) results\n\n\t  putStrLn$ "Final checksum: "++ show sum\n'