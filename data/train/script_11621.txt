b'{-# LANGUAGE DeriveGeneric #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{-# LANGUAGE OverloadedStrings #-}\n{-# LANGUAGE QuasiQuotes #-}\n{-# LANGUAGE RecordWildCards #-}\n\nmodule Network.OAuth.OAuth2.Internal where\n\nimport Control.Arrow (second)\nimport Control.Monad.Catch\nimport Data.Aeson\nimport Data.Aeson.Types (Parser, explicitParseFieldMaybe)\nimport Data.Binary (Binary)\nimport Data.ByteString qualified as BS\nimport Data.ByteString.Char8 qualified as BS8\nimport Data.Default\nimport Data.Maybe\nimport Data.Text (Text, unpack)\nimport Data.Version (showVersion)\nimport GHC.Generics\nimport Lens.Micro\nimport Lens.Micro.Extras\nimport Network.HTTP.Conduit as C\nimport Network.HTTP.Types qualified as H\nimport Network.HTTP.Types qualified as HT\nimport Paths_hoauth2 (version)\nimport URI.ByteString\nimport URI.ByteString.Aeson ()\nimport URI.ByteString.QQ\n\n--------------------------------------------------\n\n-- * Data Types\n\n--------------------------------------------------\n\n-- | Query Parameter Representation\ndata OAuth2 = OAuth2\n  { oauth2ClientId :: Text\n  , oauth2ClientSecret :: Text\n  , oauth2AuthorizeEndpoint :: URIRef Absolute\n  , oauth2TokenEndpoint :: URIRef Absolute\n  , oauth2RedirectUri :: URIRef Absolute\n  }\n  deriving (Show, Eq)\n\ninstance Default OAuth2 where\n  def =\n    OAuth2\n      { oauth2ClientId = ""\n      , oauth2ClientSecret = ""\n      , oauth2AuthorizeEndpoint = [uri|https://www.example.com/|]\n      , oauth2TokenEndpoint = [uri|https://www.example.com/|]\n      , oauth2RedirectUri = [uri|https://www.example.com/|]\n      }\n\nnewtype AccessToken = AccessToken {atoken :: Text} deriving (Binary, Eq, Show, FromJSON, ToJSON)\n\nnewtype RefreshToken = RefreshToken {rtoken :: Text} deriving (Binary, Eq, Show, FromJSON, ToJSON)\n\nnewtype IdToken = IdToken {idtoken :: Text} deriving (Binary, Eq, Show, FromJSON, ToJSON)\n\n-- | Authorization Code\nnewtype ExchangeToken = ExchangeToken {extoken :: Text} deriving (Show, FromJSON, ToJSON)\n\n-- | https://www.rfc-editor.org/rfc/rfc6749#section-4.1.4\ndata OAuth2Token = OAuth2Token\n  { accessToken :: AccessToken\n  , refreshToken :: Maybe RefreshToken\n  -- ^ Exists when @offline_access@ scope is in the \'authorizeUrl\' and the provider supports Refresh Access Token.\n  , expiresIn :: Maybe Int\n  , tokenType :: Maybe Text\n  -- ^ See https://www.rfc-editor.org/rfc/rfc6749#section-5.1. It\'s required per spec. But OAuth2 provider implementation are vary. Maybe will remove \'Maybe\' in future release.\n  , idToken :: Maybe IdToken\n  -- ^ Exists when @openid@ scope is in the \'authorizeUrl\' and the provider supports OpenID.\n  }\n  deriving (Eq, Show, Generic)\n\ninstance Binary OAuth2Token\n\n-- | Parse JSON data into \'OAuth2Token\'\ninstance FromJSON OAuth2Token where\n  parseJSON = withObject "OAuth2Token" $ \\v ->\n    OAuth2Token\n      <$> v\n      .: "access_token"\n      <*> v\n      .:? "refresh_token"\n      <*> explicitParseFieldMaybe parseIntFlexible v "expires_in"\n      <*> v\n      .:? "token_type"\n      <*> v\n      .:? "id_token"\n    where\n      parseIntFlexible :: Value -> Parser Int\n      parseIntFlexible (String s) = pure . read $ unpack s\n      parseIntFlexible v = parseJSON v\n\ninstance ToJSON OAuth2Token where\n  toJSON = genericToJSON defaultOptions {fieldLabelModifier = camelTo2 \'_\'}\n  toEncoding = genericToEncoding defaultOptions {fieldLabelModifier = camelTo2 \'_\'}\n\n-- | https://www.rfc-editor.org/rfc/rfc6749#section-2.3\n-- According to spec:\n--\n-- The client MUST NOT use more than one authentication method in each request.\n--\n-- Which means use Authorization header or Post body.\n--\n-- However, in reality, I always have to include authentication in the header.\n--\n-- In other words, \'ClientSecrectBasic\' is always assured. \'ClientSecretPost\' is optional.\n--\n-- Maybe consider an alternative implementation that boolean kind of data type is good enough.\ndata ClientAuthenticationMethod\n  = ClientSecretBasic\n  | ClientSecretPost\n  | ClientAssertionJwt\n  deriving (Eq, Ord)\n\n--------------------------------------------------\n\n-- * Types Synonym\n\n--------------------------------------------------\n\n-- | type synonym of post body content\ntype PostBody = [(BS.ByteString, BS.ByteString)]\n\ntype QueryParams = [(BS.ByteString, BS.ByteString)]\n\n--------------------------------------------------\n\n-- * Utilies\n\n--------------------------------------------------\n\ndefaultRequestHeaders :: [(HT.HeaderName, BS.ByteString)]\ndefaultRequestHeaders =\n  [ (HT.hUserAgent, "hoauth2-" <> BS8.pack (showVersion version))\n  , (HT.hAccept, "application/json")\n  ]\n\nappendQueryParams :: [(BS.ByteString, BS.ByteString)] -> URIRef a -> URIRef a\nappendQueryParams params =\n  over (queryL . queryPairsL) (params ++)\n\nuriToRequest :: MonadThrow m => URI -> m Request\nuriToRequest auri = do\n  ssl <- case view (uriSchemeL . schemeBSL) auri of\n    "http" -> return False\n    "https" -> return True\n    s -> throwM $ InvalidUrlException (show auri) ("Invalid scheme: " ++ show s)\n  let query = fmap (second Just) (view (queryL . queryPairsL) auri)\n      hostL = authorityL . _Just . authorityHostL . hostBSL\n      portL = authorityL . _Just . authorityPortL . _Just . portNumberL\n      defaultPort = (if ssl then 443 else 80) :: Int\n\n      req =\n        setQueryString query $\n          defaultRequest\n            { secure = ssl\n            , path = view pathL auri\n            }\n      req2 = (over hostLens . maybe id const . preview hostL) auri req\n      req3 = (over portLens . (const . fromMaybe defaultPort) . preview portL) auri req2\n  return req3\n\nrequestToUri :: Request -> URI\nrequestToUri req =\n  URI\n    ( Scheme\n        ( if secure req\n            then "https"\n            else "http"\n        )\n    )\n    (Just (Authority Nothing (Host $ host req) (Just $ Port $ port req)))\n    (path req)\n    (Query $ H.parseSimpleQuery $ queryString req)\n    Nothing\n\nhostLens :: Lens\' Request BS.ByteString\nhostLens f req = f (C.host req) <&> \\h\' -> req {C.host = h\'}\n{-# INLINE hostLens #-}\n\nportLens :: Lens\' Request Int\nportLens f req = f (C.port req) <&> \\p\' -> req {C.port = p\'}\n{-# INLINE portLens #-}\n'