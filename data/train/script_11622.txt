b'\xef\xbb\xbf// UVa12219 Common Subexpression Elimination\n// Rujia Liu\n\n#include<cstdio>\n#include<string>\n#include<map>\nusing namespace std;\n\nconst int maxn = 60000;\nint T, kase, cnt;\nchar expr[maxn*5], *p;\nint done[maxn]; // \xe8\xaf\xa5\xe7\xbb\x93\xe7\x82\xb9\xe6\x98\xaf\xe5\x90\xa6\xe5\xb7\xb2\xe8\xbe\x93\xe5\x87\xba\n\nstruct Node {\n  string s;\n  int hash, left, right;\n  bool operator < (const Node& rhs) const {\n    if(hash != rhs.hash) return hash < rhs.hash;\n    if(left != rhs.left) return left < rhs.left;\n    return right < rhs.right;\n  }\n} node[maxn];\n\nmap<Node,int> dict;\n\nint parse() {\n  int id = cnt++;\n  Node& u = node[id];\n  u.left = u.right = -1;\n  u.s = "";\n  u.hash = 0;\n  while(isalpha(*p)) {\n    u.hash = u.hash * 27 + *p - \'a\' + 1;\n    u.s.push_back(*p);\n    p++;\n  }\n  if (*p == \'(\') { // (L,R)\n    p++; u.left = parse(); p++; u.right = parse(); p++;\n  }\n  if (dict.count(u) != 0) {\n    id--; cnt--;       \n    return dict[u];\n  }\n  return dict[u] = id;\n}\n\nvoid print(int v) {\n  if(done[v] == kase)\n    printf("%d", v + 1);\n  else {      \n    done[v] = kase; // \xe5\xb8\xb8\xe8\xa7\x81\xe5\xb0\x8f\xe6\x8a\x80\xe5\xb7\xa7\xef\xbc\x8c\xe5\x8f\xaf\xe4\xbb\xa5\xe9\x81\xbf\xe5\x85\x8dmemset(done, 0, sizeof(done))\n    printf("%s", node[v].s.c_str());\n    if(node[v].left != -1) {\n      putchar(\'(\');\n      print(node[v].left);\n      putchar(\',\');\n      print(node[v].right);\n      putchar(\')\');\n    }\n  }  \n}\n\nint main() {\n  scanf("%d", &T);\n  for(kase = 1; kase <= T; kase++) {\n    dict.clear();\n    cnt = 0;\n    scanf("%s", expr);\n    p = expr;\n    print(parse());\n    putchar(\'\\n\');    \n  }\n  return 0;\n}\n'