b'-- | A helper module which takes care of parallelism\n{-# LANGUAGE DeriveDataTypeable #-}\nmodule Test.Tasty.Parallel (ActionStatus(..), Action(..), runInParallel) where\n\nimport Control.Monad\nimport Control.Concurrent\nimport Control.Concurrent.Async\nimport Control.Concurrent.STM\nimport Foreign.StablePtr\n\n-- | What to do about an \'Action\'?\ndata ActionStatus\n  = ActionReady\n    -- ^ the action is ready to be executed\n  | ActionSkip\n    -- ^ the action should be skipped\n  | ActionWait\n    -- ^ not sure what to do yet; wait\n  deriving Eq\n\ndata Action = Action\n  { actionStatus :: STM ActionStatus\n  , actionRun :: IO ()\n  , actionSkip :: STM ()\n  }\n\n-- | Take a list of actions and execute them in parallel, no more than @n@\n-- at the same time.\n--\n-- The action itself is asynchronous, ie. it returns immediately and does\n-- the work in new threads. It returns an action which aborts tests and\n-- cleans up.\nrunInParallel\n  :: Int -- ^ maximum number of parallel threads\n  -> [Action] -- ^ list of actions to execute.\n    -- The first action in the pair tells if the second action is ready to run.\n  -> IO (IO ())\n-- This implementation tries its best to ensure that exceptions are\n-- properly propagated to the caller and threads are not left running.\n--\n-- Note that exceptions inside tests are already caught by the test\n-- actions themselves. Any exceptions that reach this function or its\n-- threads are by definition unexpected.\nrunInParallel nthreads actions = do\n  callingThread <- myThreadId\n\n  -- Don\'t let the main thread be garbage-collected\n  -- Otherwise we may get a "thread blocked indefinitely in an STM\n  -- transaction" exception when a child thread is blocked and GC\'d.\n  -- (See e.g. https://github.com/UnkindPartition/tasty/issues/15)\n  -- FIXME is this still needed?\n  _ <- newStablePtr callingThread\n\n  actionsVar <- atomically $ newTMVar actions\n\n  pids <- replicateM nthreads (async $ work actionsVar)\n\n  return $ do\n    -- Tell worker threads there is no more work after their current task.\n    -- \'cancel\' below by itself is not sufficient because if an exception\n    -- is thrown in the middle of a test, the worker thread simply marks\n    -- the test as failed and moves on to their next task. We also need to\n    -- make it clear that there are no further tasks.\n    _ <- atomically $ swapTMVar actionsVar []\n    -- Cancel all the current tasks, waiting for workers to clean up.\n    -- The waiting part is important (see #249), that\'s why we use cancel\n    -- instead of killThread.\n    mapM_ cancel pids\n\nwork :: TMVar [Action] -> IO ()\nwork actionsVar = go\n  where\n    go = do\n      join . atomically $ do\n        mb_ready <- findBool =<< takeTMVar actionsVar\n        case mb_ready of\n          Nothing -> do\n            -- Nothing left to do. Put back the TMVar so that other threads\n            -- do not block on an empty TMVar (see #249) and return.\n            putTMVar actionsVar []\n            return $ return ()\n          Just (this, rest) -> do\n            putTMVar actionsVar rest\n            return $ actionRun this >> go\n\n-- | Find a ready-to-run item. Filter out the items that will never be\n-- ready to run.\n--\n-- Return the ready item and the remaining ones.\n--\n-- This action may block if no items are ready to run just yet.\n--\n-- Return \'Nothing\' if there are no runnable items left.\nfindBool :: [Action] -> STM (Maybe (Action, [Action]))\nfindBool = go []\n  where\n    go [] [] =\n      -- nothing to do\n      return Nothing\n    go _ [] =\n      -- nothing ready yet\n      retry\n    go past (this : rest) = do\n      status <- actionStatus this\n      case status of\n        ActionReady -> return $ Just (this, reverse past ++ rest)\n        ActionWait -> go (this : past) rest\n        ActionSkip -> do\n          actionSkip this\n          go past rest\n'