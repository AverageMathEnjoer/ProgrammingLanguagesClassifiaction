b'// UVa1204 Fun Game\n// Rujia Liu\n#include<cstring>\n#include<iostream>\n#include<string>\n#include<algorithm>\nusing namespace std;\n\n#define REP(i,n) for(int i = 0; i < (n); i++)\n\nconst int maxn = 16;\nconst int maxlen = 100 + 5;\n\n// the overlap length of a (left) and b (right)\nint calc_overlap(const string& a, const string& b) {\n  int n1 = a.length();\n  int n2 = b.length();\n  for(int i = 1; i < n1; i++) { // place b at position i\n    if(n2 + i <= n1) continue; // b cannot extend to the right of a\n    bool ok = true;\n    for(int j = 0; i + j < n1; j++)\n      if(a[i+j] != b[j]) { ok = false; break; }\n    if(ok) return n1 - i;\n  }\n  return 0;\n}\n\nstruct Item {\n  string s, rev;\n  bool operator < (const Item& rhs) const {\n    return s.length() < rhs.s.length();\n  }\n};\n\nint n;\nstring s[maxn][2];\nint len[maxn];\nint overlap[maxn][maxn][2][2];\n\nvoid init() {\n  // read input\n  Item tmp[maxn];\n  REP(i,n) {\n    cin >> tmp[i].s;\n    tmp[i].rev = tmp[i].s;\n    reverse(tmp[i].rev.begin(), tmp[i].rev.end());\n  }\n\n  // remove strings that are occurred in another string\n  int n2 = 0;\n  sort(tmp, tmp+n);\n  REP(i,n) {\n    bool need = true;\n    for(int j = i+1; j < n; j++) {\n      if(tmp[j].s.find(tmp[i].s) != string::npos ||\n         tmp[j].rev.find(tmp[i].s) != string::npos) { need = false; break; }\n    }\n    if(need) {\n      s[n2][0] = tmp[i].s; s[n2][1] = tmp[i].rev;\n      len[n2] = tmp[i].s.length();\n      n2++;\n    }\n  }\n  n = n2;\n\n  // calculate overlaps\n  REP(i,n) REP(j,n) REP(x,2) REP(y,2)\n    overlap[i][j][x][y] = calc_overlap(s[i][x] , s[j][y]);\n}\n\n// d[s][i][x] is the minimal total length if we used set s and the last string is s[i][x]\nint d[1<<maxn][maxn][2];\n\ninline void update(int& x, int v) {\n  if(x < 0 || v < x) x = v;\n}\n\nvoid solve() {\n  // dp\n  memset(d, -1, sizeof(d));\n  d[1][0][0] = len[0]; // always use string s[0][0] first\n  int full = (1<<n) - 1;\n  for(int s = 1; s < full; s++) {\n    REP(i,n) REP(x,2) if(d[s][i][x] >= 0)\n      for(int j = 1; j < n; j++) // place j\n        if(!(s & (1<<j)))\n          REP(y,2) update(d[s|(1<<j)][j][y], d[s][i][x]+len[j]-overlap[i][j][x][y]);\n  }\n\n  // find answer\n  int ans = -1;\n  REP(i,n) REP(x,2) {\n    if(d[full][i][x] < 0) continue;\n    update(ans, d[full][i][x]-overlap[i][0][x][0]);\n  }\n  if(ans <= 1) ans = 2; // problem said: at least two children\n\n  cout << ans << "\\n";\n}\n\nint main() {\n  while(cin >> n && n) {\n    init();\n    solve();\n  }\n  return 0;\n}\n'