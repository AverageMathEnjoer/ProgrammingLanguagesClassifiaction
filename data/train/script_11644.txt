b'{-# LANGUAGE OverloadedStrings #-}\n\n-- | Bindings Access Token and Refresh Token part of The OAuth 2.0 Authorization Framework\n-- RFC6749 <https://www.rfc-editor.org/rfc/rfc6749>\nmodule Network.OAuth.OAuth2.TokenRequest where\n\nimport Control.Monad.IO.Class (MonadIO (..))\nimport Control.Monad.Trans.Except (ExceptT (..), throwE)\nimport Data.Aeson\nimport Data.Aeson.Key qualified as Key\nimport Data.Aeson.KeyMap qualified as KeyMap\nimport Data.ByteString.Lazy.Char8 qualified as BSL\nimport Data.Text (Text)\nimport Data.Text qualified as T\nimport Data.Text.Encoding qualified as T\nimport GHC.Generics (Generic)\nimport Network.HTTP.Conduit\nimport Network.HTTP.Types qualified as HT\nimport Network.HTTP.Types.URI (parseQuery)\nimport Network.OAuth.OAuth2.Internal\nimport URI.ByteString\n\n--------------------------------------------------\n\n-- * Token Request Errors\n\n--------------------------------------------------\n\ndata TokenRequestError = TokenRequestError\n  { error :: TokenRequestErrorCode\n  , errorDescription :: Maybe Text\n  , errorUri :: Maybe (URIRef Absolute)\n  }\n  deriving (Show, Eq, Generic)\n\n-- | Token Error Responses https://tools.ietf.org/html/rfc6749#section-5.2\ndata TokenRequestErrorCode\n  = InvalidRequest\n  | InvalidClient\n  | InvalidGrant\n  | UnauthorizedClient\n  | UnsupportedGrantType\n  | InvalidScope\n  | UnknownErrorCode Text\n  deriving (Show, Eq)\n\ninstance FromJSON TokenRequestErrorCode where\n  parseJSON = withText "parseJSON TokenRequestErrorCode" $ \\t ->\n    pure $ case t of\n      "invalid_request" -> InvalidRequest\n      "invalid_client" -> InvalidClient\n      "invalid_grant" -> InvalidGrant\n      "unauthorized_client" -> UnauthorizedClient\n      "unsupported_grant_type" -> UnsupportedGrantType\n      "invalid_scope" -> InvalidScope\n      _ -> UnknownErrorCode t\n\ninstance FromJSON TokenRequestError where\n  parseJSON = genericParseJSON defaultOptions {constructorTagModifier = camelTo2 \'_\'}\n\nparseTokeRequestError :: BSL.ByteString -> TokenRequestError\nparseTokeRequestError string =\n  either (mkDecodeOAuth2Error string) id (eitherDecode string)\n  where\n    mkDecodeOAuth2Error :: BSL.ByteString -> String -> TokenRequestError\n    mkDecodeOAuth2Error response err =\n      TokenRequestError\n        (UnknownErrorCode "")\n        (Just $ T.pack $ "Decode TokenRequestError failed: " <> err <> "\\n Original Response:\\n" <> show (T.decodeUtf8 $ BSL.toStrict response))\n        Nothing\n\n--------------------------------------------------\n\n-- * URL\n\n--------------------------------------------------\n\n-- | Prepare the URL and the request body query for fetching an access token.\naccessTokenUrl ::\n  OAuth2 ->\n  -- | access code gained via authorization URL\n  ExchangeToken ->\n  -- | access token request URL plus the request body.\n  (URI, PostBody)\naccessTokenUrl oa code =\n  let uri = oauth2TokenEndpoint oa\n      body =\n        [ ("code", T.encodeUtf8 $ extoken code)\n        , ("redirect_uri", serializeURIRef\' $ oauth2RedirectUri oa)\n        , ("grant_type", "authorization_code")\n        ]\n   in (uri, body)\n\n-- | Obtain a new access token by sending a Refresh Token to the Authorization server.\nrefreshAccessTokenUrl ::\n  OAuth2 ->\n  -- | Refresh Token gained via authorization URL\n  RefreshToken ->\n  -- | Refresh Token request URL plus the request body.\n  (URI, PostBody)\nrefreshAccessTokenUrl oa token = (uri, body)\n  where\n    uri = oauth2TokenEndpoint oa\n    body =\n      [ ("grant_type", "refresh_token")\n      , ("refresh_token", T.encodeUtf8 $ rtoken token)\n      ]\n\n--------------------------------------------------\n\n-- * Token management\n\n--------------------------------------------------\n\n-- | Exchange @code@ for an Access Token with authenticate in request header.\nfetchAccessToken ::\n  (MonadIO m) =>\n  -- | HTTP connection manager\n  Manager ->\n  -- | OAuth Data\n  OAuth2 ->\n  -- | OAuth2 Code\n  ExchangeToken ->\n  -- | Access Token\n  ExceptT TokenRequestError m OAuth2Token\nfetchAccessToken = fetchAccessTokenWithAuthMethod ClientSecretBasic\n\nfetchAccessToken2 ::\n  (MonadIO m) =>\n  -- | HTTP connection manager\n  Manager ->\n  -- | OAuth Data\n  OAuth2 ->\n  -- | Authorization Code\n  ExchangeToken ->\n  -- | Access Token\n  ExceptT TokenRequestError m OAuth2Token\nfetchAccessToken2 = fetchAccessTokenWithAuthMethod ClientSecretPost\n{-# DEPRECATED fetchAccessToken2 "use \'fetchAccessTokenWithAuthMethod\'" #-}\n\nfetchAccessTokenInternal ::\n  (MonadIO m) =>\n  ClientAuthenticationMethod ->\n  -- | HTTP connection manager\n  Manager ->\n  -- | OAuth Data\n  OAuth2 ->\n  -- | Authorization Code\n  ExchangeToken ->\n  -- | Access Token\n  ExceptT TokenRequestError m OAuth2Token\nfetchAccessTokenInternal = fetchAccessTokenWithAuthMethod\n{-# DEPRECATED fetchAccessTokenInternal "use \'fetchAccessTokenWithAuthMethod\'" #-}\n\n-- | Exchange @code@ for an Access Token\n--\n-- OAuth2 spec allows credential (`client_id`, `client_secret`) to be sent\n-- either in the header (a.k.a \'ClientSecretBasic\').\n-- or as form/url params (a.k.a \'ClientSecretPost\').\n--\n-- The OAuth provider can choose to implement only one, or both.\n-- Look for API document from the OAuth provider you\'re dealing with.\n-- If you\'re uncertain, try \'fetchAccessToken\' which sends credential\n-- in authorization http header, which is common case.\n--\n-- @since 2.6.0\nfetchAccessTokenWithAuthMethod ::\n  (MonadIO m) =>\n  ClientAuthenticationMethod ->\n  -- | HTTP connection manager\n  Manager ->\n  -- | OAuth Data\n  OAuth2 ->\n  -- | Authorization Code\n  ExchangeToken ->\n  -- | Access Token\n  ExceptT TokenRequestError m OAuth2Token\nfetchAccessTokenWithAuthMethod authMethod manager oa code = do\n  let (uri, body) = accessTokenUrl oa code\n  let extraBody = if authMethod == ClientSecretPost then clientSecretPost oa else []\n  doJSONPostRequest manager oa uri (body ++ extraBody)\n\n-- | Fetch a new AccessToken using the Refresh Token with authentication in request header.\nrefreshAccessToken ::\n  (MonadIO m) =>\n  -- | HTTP connection manager.\n  Manager ->\n  -- | OAuth context\n  OAuth2 ->\n  -- | Refresh Token gained after authorization\n  RefreshToken ->\n  ExceptT TokenRequestError m OAuth2Token\nrefreshAccessToken = refreshAccessTokenWithAuthMethod ClientSecretBasic\n\nrefreshAccessToken2 ::\n  (MonadIO m) =>\n  -- | HTTP connection manager.\n  Manager ->\n  -- | OAuth context\n  OAuth2 ->\n  -- | Refresh Token gained after authorization\n  RefreshToken ->\n  ExceptT TokenRequestError m OAuth2Token\nrefreshAccessToken2 = refreshAccessTokenWithAuthMethod ClientSecretPost\n{-# DEPRECATED refreshAccessToken2 "use \'refreshAccessTokenWithAuthMethod\'" #-}\n\nrefreshAccessTokenInternal ::\n  (MonadIO m) =>\n  ClientAuthenticationMethod ->\n  -- | HTTP connection manager.\n  Manager ->\n  -- | OAuth context\n  OAuth2 ->\n  -- | Refresh Token gained after authorization\n  RefreshToken ->\n  ExceptT TokenRequestError m OAuth2Token\nrefreshAccessTokenInternal = refreshAccessTokenWithAuthMethod\n{-# DEPRECATED refreshAccessTokenInternal "use \'refreshAccessTokenWithAuthMethod\'" #-}\n\n-- | Fetch a new AccessToken using the Refresh Token.\n--\n-- OAuth2 spec allows credential (`client_id`, `client_secret`) to be sent\n-- either in the header (a.k.a \'ClientSecretBasic\').\n-- or as form/url params (a.k.a \'ClientSecretPost\').\n--\n-- The OAuth provider can choose to implement only one, or both.\n-- Look for API document from the OAuth provider you\'re dealing with.\n-- If you\'re uncertain, try \'refreshAccessToken\' which sends credential\n-- in authorization http header, which is common case.\n--\n-- @since 2.6.0\nrefreshAccessTokenWithAuthMethod ::\n  (MonadIO m) =>\n  ClientAuthenticationMethod ->\n  -- | HTTP connection manager.\n  Manager ->\n  -- | OAuth context\n  OAuth2 ->\n  -- | Refresh Token gained after authorization\n  RefreshToken ->\n  ExceptT TokenRequestError m OAuth2Token\nrefreshAccessTokenWithAuthMethod authMethod manager oa token = do\n  let (uri, body) = refreshAccessTokenUrl oa token\n  let extraBody = if authMethod == ClientSecretPost then clientSecretPost oa else []\n  doJSONPostRequest manager oa uri (body ++ extraBody)\n\n--------------------------------------------------\n\n-- * Utilies\n\n--------------------------------------------------\n\n-- | Conduct post request and return response as JSON.\ndoJSONPostRequest ::\n  (MonadIO m, FromJSON a) =>\n  -- | HTTP connection manager.\n  Manager ->\n  -- | OAuth options\n  OAuth2 ->\n  -- | The URL\n  URI ->\n  -- | request body\n  PostBody ->\n  -- | Response as JSON\n  ExceptT TokenRequestError m a\ndoJSONPostRequest manager oa uri body = do\n  resp <- doSimplePostRequest manager oa uri body\n  case parseResponseFlexible resp of\n    Right obj -> return obj\n    Left e -> throwE e\n\n-- | Conduct post request.\ndoSimplePostRequest ::\n  (MonadIO m) =>\n  -- | HTTP connection manager.\n  Manager ->\n  -- | OAuth options\n  OAuth2 ->\n  -- | URL\n  URI ->\n  -- | Request body.\n  PostBody ->\n  -- | Response as ByteString\n  ExceptT TokenRequestError m BSL.ByteString\ndoSimplePostRequest manager oa url body =\n  ExceptT . liftIO $ fmap handleOAuth2TokenResponse go\n  where\n    addBasicAuth = applyBasicAuth (T.encodeUtf8 $ oauth2ClientId oa) (T.encodeUtf8 $ oauth2ClientSecret oa)\n    go = do\n      req <- uriToRequest url\n      let req\' = (addBasicAuth . addDefaultRequestHeaders) req\n      httpLbs (urlEncodedBody body req\') manager\n\n-- | Gets response body from a @Response@ if 200 otherwise assume \'OAuth2Error\'\nhandleOAuth2TokenResponse :: Response BSL.ByteString -> Either TokenRequestError BSL.ByteString\nhandleOAuth2TokenResponse rsp =\n  if HT.statusIsSuccessful (responseStatus rsp)\n    then Right $ responseBody rsp\n    else Left $ parseTokeRequestError (responseBody rsp)\n\n-- | Try to parses response as JSON, if failed, try to parse as like query string.\nparseResponseFlexible ::\n  (FromJSON a) =>\n  BSL.ByteString ->\n  Either TokenRequestError a\nparseResponseFlexible r = case eitherDecode r of\n  Left _ -> parseResponseString r\n  Right x -> Right x\n\n-- | Parses the response that contains not JSON but a Query String\nparseResponseString ::\n  (FromJSON a) =>\n  BSL.ByteString ->\n  Either TokenRequestError a\nparseResponseString b = case parseQuery $ BSL.toStrict b of\n  [] -> Left errorMessage\n  a -> case fromJSON $ queryToValue a of\n    Error _ -> Left errorMessage\n    Success x -> Right x\n  where\n    queryToValue = Object . KeyMap.fromList . map paramToPair\n    paramToPair (k, mv) = (Key.fromText $ T.decodeUtf8 k, maybe Null (String . T.decodeUtf8) mv)\n    errorMessage = parseTokeRequestError b\n\n-- | Set several header values:\n--   + userAgennt    : `hoauth2`\n--   + accept        : `application/json`\naddDefaultRequestHeaders :: Request -> Request\naddDefaultRequestHeaders req =\n  let headers = defaultRequestHeaders ++ requestHeaders req\n   in req {requestHeaders = headers}\n\n-- | Add Credential (client_id, client_secret) to the request post body.\nclientSecretPost :: OAuth2 -> PostBody\nclientSecretPost oa =\n  [ ("client_id", T.encodeUtf8 $ oauth2ClientId oa)\n  , ("client_secret", T.encodeUtf8 $ oauth2ClientSecret oa)\n  ]\n'