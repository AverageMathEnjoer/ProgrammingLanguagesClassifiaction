b'{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{-# LANGUAGE OverloadedStrings #-}\n\n-- | Write PDF files\n--\n-- It could be used to generate new PDF file\n-- or to incrementally update the existent one\n--\n-- To generate new file, first call \'writeHeader\',\n-- then a number of \'writeObject\' and finally \'writeXRefTable\'\n-- or `writeXRefStream`.\n--\n-- To incrementally update PDF file just omit the\n-- `writeHeader` and append the result to the existent file.\n-- Make sure to use `writeXRefTable` if the original file uses xref table,\n-- or use `writeXRefStream` if it uses xref stream.\n\nmodule Pdf.Core.Writer\n( Writer\n, makeWriter\n, writeHeader\n, writeObject\n, writeStream\n, deleteObject\n, writeXRefTable\n, writeXRefStream\n)\nwhere\n\nimport Pdf.Core.Object\nimport Pdf.Core.Object.Builder\n\nimport Data.IORef\nimport Data.Int\nimport qualified Data.Vector as Vector\nimport Data.Set (Set)\nimport qualified Data.Set as Set\nimport qualified Data.HashMap.Strict as HashMap\nimport Data.ByteString (ByteString)\nimport qualified Data.ByteString.Lazy as BSL\nimport Data.ByteString.Builder\nimport Data.Function\nimport Control.Monad\nimport System.IO.Streams (OutputStream)\nimport qualified System.IO.Streams as Streams\n\nnewtype Writer = Writer {toStateRef :: IORef State}\n\nmakeWriter :: OutputStream ByteString -> IO Writer\nmakeWriter output = do\n  (out, count) <- Streams.countOutput output\n  let emptyState = State {\n        stOutput = out,\n        stObjects = Set.empty,\n        stCount = count,\n        stOffset = 0\n        }\n  Writer <$> newIORef emptyState\n\ndata Elem = Elem {\n  elemIndex :: {-# UNPACK #-} !Int,\n  elemGen :: {-# UNPACK #-} !Int,\n  elemOffset :: {-# UNPACK #-} !Int64,\n  elemFree :: !Bool\n  }\n\ninstance Eq Elem where\n  (==) = (==) `on` elemIndex\n\ninstance Ord Elem where\n  compare = compare `on` elemIndex\n\ndata State = State {\n  stOutput :: OutputStream ByteString,\n  stObjects :: !(Set Elem),\n  stCount :: IO Int64,\n  stOffset :: {-# UNPACK #-} !Int64\n  }\n\n-- | Write PDF header. Used for generating new PDF files.\n-- Should be the first call. Not used fo incremental updates\nwriteHeader :: Writer -> IO ()\nwriteHeader writer = do\n  st <- readIORef (toStateRef writer)\n  Streams.write (Just "%PDF-1.7\\n") (stOutput st)\n\n-- | Write object\nwriteObject :: Writer -> Ref -> Object -> IO ()\nwriteObject writer ref@(R index gen) obj = do\n  pos <- countWritten writer\n  st <- readIORef (toStateRef writer)\n  addElem writer $ Elem index gen pos False\n  dumpObject (stOutput st) ref obj\n\n-- | Write stream\nwriteStream :: Writer -> Ref -> Dict -> BSL.ByteString -> IO ()\nwriteStream writer ref@(R index gen) dict dat = do\n  pos <- countWritten writer\n  st <- readIORef (toStateRef writer)\n  addElem writer $ Elem index gen pos False\n  dumpStream (stOutput st) ref dict dat\n\n-- | Delete object\ndeleteObject :: Writer -> Ref -> Int64 -> IO ()\ndeleteObject writer (R index gen) nextFree =\n  addElem writer $ Elem index gen nextFree True\n\n-- | Write xref table. Should be the last call.\n-- Used for generating and incremental updates.\n--\n-- Note that when doing incremental update you should use this function\n-- only if the original PDF file has xref table. If it has xref stream,\n-- then use `writeXRefStream`.\nwriteXRefTable\n  :: Writer\n  -> Int64    -- ^ size of the original PDF file. Should be 0 for new file\n  -> Dict     -- ^ trailer\n  -> IO ()\nwriteXRefTable writer offset tr = do\n  off <- (+ offset) <$> countWritten writer\n  st <- readIORef (toStateRef writer)\n  let elems = Set.mapMonotonic (\\e -> e {elemOffset = elemOffset e + offset})\n            $ stObjects st\n      content = mconcat\n        [ byteString "xref\\n"\n        , buildXRefTable (Set.toAscList elems)\n        , byteString "trailer\\n"\n        , buildDict tr\n        , byteString "\\nstartxref\\n"\n        , int64Dec off\n        , byteString "\\n%%EOF\\n"\n        ]\n  Streams.writeLazyByteString (toLazyByteString content) (stOutput st)\n\n-- | Write xref stream. Should be the last call.\n-- Used for generating and incremental updates.\n--\n-- Note that when doing incremental update you should use this function\n-- only if the original PDF file has xref stream. If it has xref table,\n-- then use `writeXRefTable`.\n--\n-- This function will update/delete the following keys in the trailer:\n-- Type, W, Index, Filter, Length.\nwriteXRefStream\n  :: Writer\n  -> Int64    -- ^ size of the original PDF file. Should be 0 for new file\n  -> Ref\n  -> Dict     -- ^ trailer\n  -> IO ()\nwriteXRefStream writer offset ref@(R index gen) tr = do\n  pos <- countWritten writer\n  addElem writer $ Elem index gen pos False\n  st <- readIORef (toStateRef writer)\n  let elems = Set.mapMonotonic (\\e -> e {elemOffset = elemOffset e + offset})\n            $ stObjects st\n      off = pos + offset\n      content = toLazyByteString $ buildXRefStream (Set.toAscList elems)\n      dict\n        = HashMap.insert "Type" (Name "XRef")\n        . HashMap.insert "W" (Array $ Vector.fromList $ map Number [1, 8, 8])\n        . HashMap.insert "Index" (Array $ Vector.fromList $ map Number trIndex)\n        . HashMap.insert "Length" (Number $ fromIntegral $ BSL.length content)\n        . HashMap.delete "Filter"\n        $ tr\n      trIndex = concatMap sectionIndex (xrefSections (Set.toAscList elems))\n      sectionIndex [] = error "impossible"\n      sectionIndex s@(e:_) = map fromIntegral [elemIndex e, length s]\n      end = mconcat\n        [ "\\nstartxref\\n"\n        , int64Dec off\n        , "\\n%%EOF\\n"\n        ]\n  dumpStream (stOutput st) ref dict content\n  Streams.writeLazyByteString (toLazyByteString end) (stOutput st)\n\ncountWritten :: Writer -> IO Int64\ncountWritten writer = do\n  st <- readIORef (toStateRef writer)\n  c <- (stOffset st +) <$> stCount st\n  writeIORef (toStateRef writer) st{stOffset = c}\n  return $! c\n\naddElem :: Writer -> Elem -> IO ()\naddElem writer e = do\n  st <- readIORef (toStateRef writer)\n  when (Set.member e $ stObjects st) $\n    error $ "Writer: attempt to write object with the same index: " ++ show (elemIndex e)\n  writeIORef (toStateRef writer) $ st\n    { stObjects = Set.insert e $ stObjects st\n    }\n\ndumpObject :: OutputStream ByteString -> Ref -> Object -> IO ()\ndumpObject out ref o =\n  Streams.writeLazyByteString\n    (toLazyByteString $ buildIndirectObject ref o)\n    out\n\ndumpStream :: OutputStream ByteString -> Ref -> Dict -> BSL.ByteString -> IO ()\ndumpStream out ref dict dat =\n  Streams.writeLazyByteString\n    (toLazyByteString $ buildIndirectStream ref dict dat) out\n\nbuildXRefTable :: [Elem] -> Builder\nbuildXRefTable entries =\n  mconcat (map buildXRefTableSection $ xrefSections entries)\n\nxrefSections :: [Elem] -> [[Elem]]\nxrefSections [] = []\nxrefSections xs = let (s, rest) = xrefSection xs in s : xrefSections rest\n\nxrefSection :: [Elem] -> ([Elem], [Elem])\nxrefSection [] = error "impossible"\nxrefSection (x:xs) = go (elemIndex x + 1) [x] xs\n  where\n  go _ res [] = (reverse res, [])\n  go i res (y:ys) =\n    if i == elemIndex y\n      then go (i + 1) (y : res) ys\n      else (reverse res, y:ys)\n\nbuildXRefTableSection :: [Elem] -> Builder\nbuildXRefTableSection [] = error "impossible"\nbuildXRefTableSection s@(e:_) = mconcat\n  [ intDec (elemIndex e)\n  , char7 \' \'\n  , intDec (length s)\n  , char7 \'\\n\'\n  , loop s\n  ]\n  where\n  loop (x:xs) = mconcat\n    [ buildFixed 10 \'0\' (elemOffset x)\n    , char7 \' \'\n    , buildFixed 5 \'0\' (elemGen x)\n    , char7 \' \'\n    , char7 (if elemFree x then \'f\' else \'n\')\n    , string7 "\\r\\n"\n    ] `mappend` loop xs\n  loop [] = mempty\n\nbuildXRefStream :: [Elem] -> Builder\nbuildXRefStream entries =\n  mconcat (map buildXRefStreamSection $ xrefSections entries)\n\nbuildXRefStreamSection :: [Elem] -> Builder\nbuildXRefStreamSection = mconcat . map buildOne\n  where\n  buildOne e =\n    let (tp, field1, field2) = if elemFree e\n          then (0, 0, succ (elemGen e))\n          else (1, elemOffset e, elemGen e)\n    in mconcat\n      [ int8 tp\n      , int64BE field1\n      , int64BE (fromIntegral field2)\n      ]\n\nbuildFixed :: Show a => Int -> Char -> a -> Builder\nbuildFixed len c i =\n  let v = take len $ show i\n      l = length v\n  in string7 $ replicate (len - l) c ++ v\n'