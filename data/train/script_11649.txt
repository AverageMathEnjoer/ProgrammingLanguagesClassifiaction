b'\xef\xbb\xbf#load "LogisticRegression.fs"\n// replace this path with the local path where FSharpChart is located\n#r @"C:\\Users\\Mathias\\Documents\\GitHub\\Machine-Learning-In-Action\\MachineLearningInAction\\packages\\MSDN.FSharpChart.dll.0.60\\lib\\MSDN.FSharpChart.dll"\n#r "System.Windows.Forms.DataVisualization"\nopen MachineLearning.LogisticRegression\nopen System.Drawing\nopen System.Windows.Forms.DataVisualization\nopen MSDN.FSharp.Charting\n\n#time\n\n// illustration on small example\nlet testSet =\n    [ [ 0.5 ; 0.7 ];\n      [ 1.5 ; 2.3 ];\n      [ 0.8 ; 0.8 ];\n      [ 6.0 ; 9.0 ];\n      [ 9.5 ; 5.5 ];     \n      [ 6.5 ; 2.7 ];\n      [ 2.1 ; 0.1 ];\n      [ 3.2 ; 1.9 ] ]\nlet testLabels = [ 1.0 ; 1.0 ; 1.0; 1.0; 0.0 ; 0.0; 0.0; 0.0 ]\nlet dataset = Seq.zip testLabels testSet\n\n// compute weights on 10 iterations, with alpha = 0.1\nlet estimates = simpleTrain dataset 10 0.1\nlet classifier = predict estimates\n\n// display dataset, and "separating line"\nlet display (dataSet: (float * float) seq) (labels: string seq) (line: float -> float) =\n    let byLabel = Seq.zip labels dataSet |> Seq.toArray\n    let uniqueLabels = Seq.distinct labels\n    FSharpChart.Combine \n        [ // separate points by class and scatterplot them\n          for label in uniqueLabels ->\n               let data = \n                    Array.filter (fun e -> label = fst e) byLabel\n                    |> Array.map snd\n               FSharpChart.Point(data) :> ChartTypes.GenericChart\n               |> FSharpChart.WithSeries.Marker(Size=10)\n          // plot line between left- and right-most points\n          let x = Seq.map fst dataSet\n          let xMin, xMax = Seq.min x, Seq.max x           \n          let lineData = [ (xMin, line xMin); (xMax, line xMax)]\n          yield FSharpChart.Line (lineData)  :> ChartTypes.GenericChart\n        ]\n    |> FSharpChart.Create    \n\nlet xy = testSet |> Seq.map (fun e -> e.[0], e.[1])\nlet labels = testLabels |> Seq.map (fun e -> e.ToString())\nlet line x = - estimates.[0] / estimates.[2] - x * estimates.[1] / estimates.[2]\nlet show = display xy labels line\n\n// comparison of training methods on larger dataset\nlet rng = new System.Random()\nlet w0, w1, w2, w3, w4 = 1.0, 2.0, 3.0, 4.0, -10.0\nlet weights = [ w0; w1; w2; w3; w4 ] // "true" vector\nlet sampleSize = 10000\n\nlet fakeData = \n    [ for i in 1 .. sampleSize -> [ for coord in 1 .. 4 -> rng.NextDouble() * 10.0 ] ]\n\nlet inClass x = if x <= 0.5 then 0.0 else 1.0 \n\nlet cleanLabels =\n    fakeData \n    |> Seq.map (fun coords -> predict weights coords)\n    |> Seq.map inClass\n\nlet noisyLabels = \n    fakeData \n    |> Seq.map (fun coords -> \n        if rng.NextDouble() < 0.9 \n        then predict weights coords\n        else rng.NextDouble())\n    |> Seq.map inClass\n\nlet quality classifier dataset = \n    dataset\n    |> Seq.map (fun (lab, coords) -> \n        if lab = (predict classifier coords |> inClass) then 1.0 else 0.0)\n    |> Seq.average\n\nprintfn "Clean dataset"\nlet cleanSet = Seq.zip cleanLabels fakeData\nprintfn "Running simple training"\nlet clean1 = simpleTrain cleanSet 100 0.1\nprintfn "Correctly classified: %f" (quality clean1 cleanSet)\nprintfn "Running convergence-based training"\nlet clean2 = train cleanSet 0.000001\nprintfn "Correctly classified: %f" (quality clean2 cleanSet)\n\nprintfn "Noisy dataset"\nlet noisySet = Seq.zip noisyLabels fakeData\nprintfn "Running simple training"\nlet noisy1 = simpleTrain noisySet 100 0.1\nprintfn "Correctly classified: %f" (quality noisy1 noisySet)\nprintfn "Running convergence-based training"\nlet noisy2 = train noisySet 0.000001\nprintfn "Correctly classified: %f" (quality noisy2 noisySet)\n'