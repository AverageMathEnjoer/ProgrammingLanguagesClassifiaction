b'{-# LANGUAGE CPP #-}\n\nmodule Hoodle.Coroutine.VerticalSpace where\n\nimport Control.Category ((.))\nimport Control.Lens (at, set, view, (.~))\nimport Control.Monad ((>=>))\nimport Control.Monad.State (gets)\nimport Control.Monad.Trans (liftIO)\nimport Data.Bifunctor (second)\nimport Data.Foldable (concat, concatMap, mapM_)\nimport Data.Hoodle.BBox\n  ( BBox (..),\n    ULMaybe (Middle),\n    UnionBBox (..),\n    getBBox,\n    toMaybe,\n  )\nimport Data.Hoodle.Generic\n  ( gdimension,\n    gitems,\n    glayers,\n    gpages,\n  )\nimport Data.Hoodle.Simple (Dimension (..))\nimport Data.Hoodle.Zipper (SeqZipper, toSeq)\nimport Data.Time.Clock (UTCTime, getCurrentTime)\nimport Graphics.Hoodle.Render (renderRItem)\nimport Graphics.Hoodle.Render.Type\n  ( RItem (..),\n    SurfaceID,\n    emptyRLayer,\n    issueSurfaceID,\n  )\nimport Graphics.Hoodle.Render.Type.HitTest\n  ( Hitted (..),\n    NotHitted (..),\n    RItemHitted,\n    getA,\n    getB,\n    interleave,\n  )\nimport Graphics.Hoodle.Render.Util.HitTest (hltFilteredBy)\nimport qualified Graphics.Rendering.Cairo as Cairo\nimport qualified Graphics.UI.Gtk as Gtk\nimport Hoodle.Accessor\n  ( getCurrentPageCurr,\n    pureUpdateUhdl,\n    renderCache,\n    updateUhdl,\n  )\nimport Hoodle.Coroutine.Commit (commit_)\nimport Hoodle.Coroutine.Draw\n  ( invalidateAll,\n    nextevent,\n  )\nimport Hoodle.Coroutine.Page (addNewPageInHoodle, canvasZoomUpdateAll)\nimport Hoodle.Coroutine.Pen\n  ( commonPenStart,\n    penMoveAndUpOnly,\n    processWithDefTimeInterval,\n  )\nimport Hoodle.Device (PointerCoord)\nimport Hoodle.ModelAction.Page (updatePageAll)\nimport Hoodle.ModelAction.Select.Transform (changeItemBy)\nimport Hoodle.Type.Alias (EditMode, Hoodle, Page)\nimport Hoodle.Type.Canvas\n  ( CanvasId,\n    CanvasInfo (..),\n    drawArea,\n    forBoth\',\n    unboxBiAct,\n  )\nimport Hoodle.Type.Coroutine (MainCoroutine)\nimport Hoodle.Type.Enum\n  ( AddDirection (PageAfter),\n    BackgroundStyle,\n    VerticalSpaceMode (GoingDown, GoingUp, OverPage),\n  )\nimport Hoodle.Type.Event (UserEvent)\nimport Hoodle.Type.HoodleState\n  ( HoodleModeState (SelectState, ViewAppendState),\n    UnitHoodle,\n    backgroundStyle,\n    currentUnit,\n    getCanvasInfo,\n    getHoodle,\n    hoodleModeState,\n    unitHoodles,\n  )\nimport Hoodle.Type.PageArrangement\n  ( CanvasCoordinate (..),\n    PageCoordinate (..),\n    PageNum (..),\n  )\nimport Hoodle.Type.Predefined (predefinedLassoWidth)\nimport Hoodle.Util (msgShout)\nimport Hoodle.View.Coordinate\n  ( CanvasGeometry,\n    desktop2Canvas,\n    desktop2Page,\n    device2Desktop,\n    page2Desktop,\n  )\nimport Hoodle.View.Draw (cairoXform4PageCoordinate, canvas2DesktopRatio, canvasImageSurface, mkXform4Page)\n--\nimport Prelude hiding (concat, concatMap, id, mapM_, (.))\n\n-- |\nsplitPageByHLine ::\n  Double ->\n  Page EditMode ->\n  ([RItem], Page EditMode, SeqZipper RItemHitted)\nsplitPageByHLine y pg = (hitted, set glayers unhitted pg, hltedLayers)\n  where\n    alllyrs = view glayers pg\n    findHittedItmsInALyr = hltFilteredBy (bboxabove . getBBox) . view gitems\n    hltedLayers = fmap findHittedItmsInALyr alllyrs\n    unhitted =\n      fmap\n        ( \\lyr ->\n            (\\x -> set gitems x lyr) . concatMap unNotHitted\n              . getA\n              . findHittedItmsInALyr\n              $ lyr\n        )\n        alllyrs\n    hitted = concatMap (concatMap unHitted . getB . findHittedItmsInALyr) . toSeq $ alllyrs\n    bboxabove (BBox (_, y0) _) = y0 > y\n\n-- |\nverticalSpaceStart :: CanvasId -> PointerCoord -> MainCoroutine ()\nverticalSpaceStart cid = commonPenStart verticalSpaceAction cid >=> const (return ())\n  where\n    verticalSpaceAction _cinfo pnum@(PageNum n) geometry (x, y) _ = do\n      hdl <- gets (getHoodle . view (unitHoodles . currentUnit))\n      cache <- renderCache\n      cpg <- getCurrentPageCurr\n      let (itms, npg, hltedLayers) = splitPageByHLine y cpg\n          nhdl = set (gpages . at n) (Just npg) hdl\n          mbbx = (toMaybe . mconcat . fmap (Union . Middle . getBBox)) itms\n      case mbbx of\n        Nothing -> return ()\n        Just bbx -> do\n          (sfcbkg, Dim w h) <- liftIO $ canvasImageSurface cache cid Nothing geometry nhdl\n          sfcitm <-\n            liftIO $\n              Cairo.createImageSurface\n                Cairo.FormatARGB32\n                (floor w)\n                (floor h)\n          sfctot <-\n            liftIO $\n              Cairo.createImageSurface\n                Cairo.FormatARGB32\n                (floor w)\n                (floor h)\n          liftIO $\n            Cairo.renderWith sfcitm $ do\n              Cairo.identityMatrix\n              cairoXform4PageCoordinate (mkXform4Page geometry pnum)\n              mapM_ (renderRItem cache cid) itms\n          ctime <- liftIO getCurrentTime\n          verticalSpaceProcess\n            cid\n            geometry\n            (bbx, hltedLayers, pnum, cpg)\n            (x, y)\n            (sfcbkg, sfcitm, sfctot)\n            ctime\n          liftIO $ mapM_ Cairo.surfaceFinish [sfcbkg, sfcitm, sfctot]\n\n-- |\naddNewPageAndMoveBelow ::\n  (PageNum, SeqZipper RItemHitted, BBox) ->\n  MainCoroutine ()\naddNewPageAndMoveBelow (pnum, hltedLyrs, bbx) = do\n  bsty <- gets (view backgroundStyle)\n  updateUhdl (npgact bsty) >> commit_ >> canvasZoomUpdateAll >> invalidateAll\n  where\n    npgact :: BackgroundStyle -> UnitHoodle -> MainCoroutine UnitHoodle\n    npgact bsty uhdl = do\n      case view hoodleModeState uhdl of\n        ViewAppendState hdl -> do\n          hdl\' <- addNewPageInHoodle Nothing bsty PageAfter hdl (unPageNum pnum)\n          sfcid <- issueSurfaceID\n          sfcid2 <- issueSurfaceID\n          let nhdlmodst = ViewAppendState (moveBelowToNewPage (sfcid, sfcid2) (pnum, hltedLyrs, bbx) hdl\')\n          liftIO . updatePageAll nhdlmodst . (hoodleModeState .~ nhdlmodst) $ uhdl\n        SelectState _ -> do\n          msgShout "addNewPageAndMoveBelow: not implemented yet"\n          return uhdl\n\n-- |\nmoveBelowToNewPage ::\n  -- | sfcid: old page, sfcid2: new page\n  (SurfaceID, SurfaceID) ->\n  (PageNum, SeqZipper RItemHitted, BBox) ->\n  Hoodle EditMode ->\n  Hoodle EditMode\nmoveBelowToNewPage (sfcid, sfcid2) (PageNum n, hltedLayers, BBox (_, y0) _) hdl =\n  let mpg = view (gpages . at n) hdl\n      mpg2 = view (gpages . at (n + 1)) hdl\n   in case (,) <$> mpg <*> mpg2 of\n        Nothing -> hdl\n        Just (pg, pg2) ->\n          let nhlyrs =\n                -- 10 is just a predefined number\n                fmap (second (fmap (changeItemBy (\\(x\', y\') -> (x\', y\' + 10 - y0))))) hltedLayers\n              nlyrs =\n                fmap\n                  ( (\\x -> set gitems x (emptyRLayer sfcid))\n                      . concatMap unNotHitted\n                      . getA\n                  )\n                  nhlyrs\n              npg = set glayers nlyrs pg\n              nnlyrs =\n                fmap\n                  ( (\\x -> set gitems x (emptyRLayer sfcid2))\n                      . concatMap unHitted\n                      . getB\n                  )\n                  nhlyrs\n              npg2 = set glayers nnlyrs pg2\n              nhdl =\n                ( set (gpages . at (n + 1)) (Just npg2)\n                    . set (gpages . at n) (Just npg)\n                )\n                  hdl\n           in nhdl\n\n-- |\nverticalSpaceProcess ::\n  CanvasId ->\n  CanvasGeometry ->\n  (BBox, SeqZipper RItemHitted, PageNum, Page EditMode) ->\n  (Double, Double) ->\n  -- | (background, item, total)\n  (Cairo.Surface, Cairo.Surface, Cairo.Surface) ->\n  UTCTime ->\n  MainCoroutine ()\nverticalSpaceProcess\n  cid\n  geometry\n  pinfo@(bbx, hltedLayers, pnum@(PageNum n), pg)\n  (x0, y0)\n  sfcs@(sfcbkg, sfcitm, sfctot)\n  otime = do\n    r <- nextevent\n    uhdl <- gets (view (unitHoodles . currentUnit))\n    forBoth\' unboxBiAct (f r) . getCanvasInfo cid $ uhdl\n    where\n      Dim w h = view gdimension pg\n      CvsCoord (_, y0_cvs) = (desktop2Canvas geometry . page2Desktop geometry) (pnum, PageCoord (x0, y0))\n      -------------------------------------------------------------\n      f :: UserEvent -> CanvasInfo a -> MainCoroutine ()\n      f r cvsInfo = penMoveAndUpOnly r pnum geometry defact (moveact cvsInfo) upact\n      defact = verticalSpaceProcess cid geometry pinfo (x0, y0) sfcs otime\n      upact pcoord = do\n        let mpgcoord = (desktop2Page geometry . device2Desktop geometry) pcoord\n        case mpgcoord of\n          Nothing -> invalidateAll\n          Just (cpn, PageCoord (_, y)) ->\n            if cpn /= pnum\n              then invalidateAll\n              else do\n                -- add space  within this page\n                let BBox _ (_, by1) = bbx\n                if by1 + y - y0 < h\n                  then do\n                    sfcid <- issueSurfaceID\n                    pureUpdateUhdl $ \\uhdl -> do\n                      let hdl = getHoodle uhdl\n                          nhlyrs = fmap (second (fmap (changeItemBy (\\(x\', y\') -> (x\', y\' + y - y0))))) hltedLayers\n                          nlyrs =\n                            fmap\n                              ( (\\is -> set gitems is (emptyRLayer sfcid))\n                                  . concat\n                                  . interleave unNotHitted unHitted\n                              )\n                              nhlyrs\n                          npg = set glayers nlyrs pg\n                          nhdl = set (gpages . at n) (Just npg) hdl\n                          nhdlmodst = ViewAppendState nhdl\n                          nuhdl = (hoodleModeState .~ nhdlmodst) uhdl\n                       in nuhdl\n                    commit_\n                    canvasZoomUpdateAll\n                    invalidateAll\n                  else addNewPageAndMoveBelow (pnum, hltedLayers, bbx)\n      -------------------------------------------------------------\n      moveact cvsInfo (_, (x, y)) =\n        processWithDefTimeInterval\n          (verticalSpaceProcess cid geometry pinfo (x0, y0) sfcs)\n          ( \\ctime -> do\n              let CvsCoord (_, y_cvs) =\n                    (desktop2Canvas geometry . page2Desktop geometry) (pnum, PageCoord (x, y))\n                  BBox _ (_, by1) = bbx\n                  mode\n                    | by1 + y - y0 > h = OverPage\n                    | y > y0 = GoingDown\n                    | otherwise = GoingUp\n                  z = canvas2DesktopRatio geometry\n                  drawguide = do\n                    Cairo.identityMatrix\n                    cairoXform4PageCoordinate (mkXform4Page geometry pnum)\n                    Cairo.setLineWidth (predefinedLassoWidth * z)\n                    case mode of\n                      GoingUp -> Cairo.setSourceRGBA 0.1 0.8 0.1 0.4\n                      GoingDown -> Cairo.setSourceRGBA 0.1 0.1 0.8 0.4\n                      OverPage -> Cairo.setSourceRGBA 0.8 0.1 0.1 0.4\n                    Cairo.moveTo 0 y0\n                    Cairo.lineTo w y0\n                    Cairo.stroke\n                    Cairo.moveTo 0 y\n                    Cairo.lineTo w y\n                    Cairo.stroke\n                    case mode of\n                      GoingUp ->\n                        Cairo.setSourceRGBA 0.1 0.8 0.1 0.2\n                          >> Cairo.rectangle 0 y w (y0 - y)\n                      GoingDown ->\n                        Cairo.setSourceRGBA 0.1 0.1 0.8 0.2\n                          >> Cairo.rectangle 0 y0 w (y - y0)\n                      OverPage ->\n                        Cairo.setSourceRGBA 0.8 0.1 0.1 0.2\n                          >> Cairo.rectangle 0 y0 w (y - y0)\n                    Cairo.fill\n              liftIO $\n                Cairo.renderWith sfctot $ do\n                  Cairo.setSourceSurface sfcbkg 0 0\n                  Cairo.setOperator Cairo.OperatorSource\n                  Cairo.paint\n                  Cairo.setSourceSurface sfcitm 0 (y_cvs - y0_cvs)\n                  Cairo.setOperator Cairo.OperatorOver\n                  Cairo.paint\n                  drawguide\n              let canvas = view drawArea cvsInfo\n              Just win <- liftIO $ Gtk.widgetGetWindow canvas\n              liftIO $\n                Gtk.renderWithDrawWindow win $ do\n                  Cairo.setSourceSurface sfctot 0 0\n                  Cairo.setOperator Cairo.OperatorSource\n                  Cairo.paint\n              verticalSpaceProcess cid geometry pinfo (x0, y0) sfcs ctime\n          )\n          otime\n'