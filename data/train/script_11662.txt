b'{-# LANGUAGE OverloadedStrings #-}\n\nmodule Hoodle.Type.Enum where\n\nimport Control.Lens (Lens\', lens)\nimport qualified Data.ByteString.Char8 as B\nimport Data.Hoodle.Predefined\n  ( predefinedPencolor,\n    rgbaToHEX,\n  )\nimport qualified Data.Map as M\nimport Hoodle.Util (fromJustError)\n\n-- | drawing efficiency\ndata DrawFlag = Clear | BkgEfficient | Efficient\n  deriving (Eq, Ord, Show)\n\n-- | page add direction\ndata AddDirection = PageBefore | PageAfter\n  deriving (Show, Eq, Ord, Enum)\n\n-- | relative zoom mode\ndata ZoomModeRel = ZoomIn | ZoomOut\n  deriving (Show, Eq, Ord, Enum)\n\n-- | pen tool type\ndata PenType\n  = PenWork\n  | HighlighterWork\n  | EraserWork\n  | VerticalSpaceWork\n  deriving (Show, Eq, Ord)\n\n-- | predefined pen colors\ndata PenColor\n  = ColorBlack\n  | ColorBlue\n  | ColorRed\n  | ColorGreen\n  | ColorGray\n  | ColorLightBlue\n  | ColorLightGreen\n  | ColorMagenta\n  | ColorOrange\n  | ColorYellow\n  | ColorWhite\n  | ColorRGBA Double Double Double Double\n  deriving (Show, Eq, Ord)\n\n-- | predefined background styles\ndata BackgroundStyle\n  = BkgStylePlain\n  | BkgStyleLined\n  | BkgStyleRuled\n  | BkgStyleGraph\n  deriving (Show, Eq, Ord)\n\n-- | mode for vertical space adding\ndata VerticalSpaceMode = GoingUp | GoingDown | OverPage\n\n-- | select tool type\ndata SelectType\n  = SelectLassoWork\n  | SelectRectangleWork\n  | SelectHandToolWork\n  deriving (Show, Eq, Ord)\n\n-- |\nnewtype SelectInfo = SelectInfo\n  { _selectType :: SelectType\n  }\n  deriving (Show)\n\ndata RotateDir = CW | CCW deriving (Show, Ord, Eq)\n\n-- |\ndata NewPageModeType = NPPlain | NPLast | NPCycle deriving (Show, Ord, Eq)\n\n--\n-- lenses\n--\n\n-- |\nselectType :: Lens\' SelectInfo SelectType\nselectType = lens _selectType (\\f a -> f {_selectType = a})\n\n-- |\npenColorNameMap :: M.Map PenColor B.ByteString\npenColorNameMap =\n  M.fromList\n    [ (ColorBlack, "black"),\n      (ColorBlue, "blue"),\n      (ColorRed, "red"),\n      (ColorGreen, "green"),\n      (ColorGray, "gray"),\n      (ColorLightBlue, "lightblue"),\n      (ColorLightGreen, "lightgreen"),\n      (ColorMagenta, "magenta"),\n      (ColorOrange, "orange"),\n      (ColorYellow, "yellow"),\n      (ColorWhite, "white")\n    ]\n\npenColorRGBAmap :: M.Map PenColor (Double, Double, Double, Double)\npenColorRGBAmap =\n  M.fromList $\n    map (\\x -> (fst x, fromJustError "penColorRGBAmap" (M.lookup (snd x) predefinedPencolor))) $\n      M.toList penColorNameMap\n\nconvertPenColorToRGBA :: PenColor -> (Double, Double, Double, Double)\nconvertPenColorToRGBA (ColorRGBA r g b a) = (r, g, b, a)\nconvertPenColorToRGBA c = fromJustError "convertPenColorToRGBA" (M.lookup c penColorRGBAmap)\n\nconvertRGBAToHex :: (Double, Double, Double, Double) -> B.ByteString\nconvertRGBAToHex = B.pack . rgbaToHEX\n\nconvertPenColorToByteString :: PenColor -> B.ByteString\nconvertPenColorToByteString pcol =\n  let mpcolname = M.lookup pcol penColorNameMap\n      pcolname = case mpcolname of\n        Nothing -> (convertRGBAToHex . convertPenColorToRGBA) pcol\n        Just n -> n\n   in pcolname\n\nconvertBackgroundStyleToByteString :: BackgroundStyle -> B.ByteString\nconvertBackgroundStyleToByteString BkgStylePlain = "plain"\nconvertBackgroundStyleToByteString BkgStyleLined = "lined"\nconvertBackgroundStyleToByteString BkgStyleRuled = "ruled"\nconvertBackgroundStyleToByteString BkgStyleGraph = "graph"\n'