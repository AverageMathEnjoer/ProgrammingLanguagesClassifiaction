b'{-# LANGUAGE OverloadedStrings #-}\n\n-----------------------------------------------------------------------------\n\n-----------------------------------------------------------------------------\n\n-- |\n-- Module      : Text.Xournal.Parse\n-- Copyright   : (c) 2011, 2012 Ian-Woo Kim\n--\n-- License     : BSD3\n-- Maintainer  : Ian-Woo Kim <ianwookim@gmail.com>\n-- Stability   : experimental\n-- Portability : GHC\nmodule Text.Xournal.Parse (module Text.Xournal.Parse.Conduit) where\n\nimport Text.Xournal.Parse.Conduit\n\n{-\n-- from other packages by others\nimport           Control.Applicative\nimport           Data.Attoparsec\nimport           Data.Attoparsec.Char8 ( char, decimal, double, skipSpace\n                                       , isHorizontalSpace)\nimport qualified Data.ByteString.Char8 as B hiding (map)\nimport           Data.Char\nimport qualified Data.Conduit as C\nimport           Data.Conduit.Attoparsec\nimport           Data.Strict.Tuple\n-- from other hoodle packages\nimport           Data.Xournal.Simple\n-- from this package\nimport           Text.Xournal.Parse.Zlib\n--\nimport Prelude hiding (takeWhile)\n\n-- import qualified Data.Iteratee as Iter\n-- import Data.Iteratee.Char\n-- import qualified Data.Attoparsec.Iteratee as AI\n-}\n\n{-\n--  |\n\nskipSpaces :: Parser ()\nskipSpaces = satisfy isHorizontalSpace *> skipWhile isHorizontalSpace\n\n-- |\n\ntrim_starting_space :: Parser ()\ntrim_starting_space = do try endOfInput\n                         <|> takeWhile (inClass " \\n") *> return ()\n\n-- |\n\nlangle :: Parser Char\nlangle = char \'<\'\n\n-- |\n\nrangle :: Parser Char\nrangle = char \'>\'\n\n-- |\n\nxmlheader :: Parser B.ByteString\nxmlheader = string "<?" *> takeTill (inClass "?>") <* string "?>"\n\n-- |\n\nheadercontentWorker :: B.ByteString -> Parser B.ByteString\nheadercontentWorker  bstr = do\n  h <- takeWhile1 (notInClass "?>")\n  ((string "?>" >>= return . (bstr `B.append` h `B.append`))\n   <|> headercontentWorker (bstr `B.append` h))\n\n-- |\n\nheadercontent :: Parser B.ByteString\nheadercontent = headercontentWorker B.empty\n\n-- |\n\nstroketagopen :: Parser Stroke --  B.ByteString\nstroketagopen = do\n  trim\n  string "<stroke"\n  trim\n  string "tool="\n  char \'"\'\n  tool <- alphabet\n  char \'"\'\n  trim\n  string "color="\n  char \'"\'\n  color <- alphanumsharp\n  char \'"\'\n  trim\n  string "width="\n  char \'"\'\n  width <- double\n  char \'"\'\n  char \'>\'\n  return $ Stroke tool color width []\n\n-- |\n\nstroketagclose :: Parser B.ByteString\nstroketagclose = string "</stroke>"\n\n-- |\n\nonestroke :: Parser Stroke\nonestroke =  do trim\n                strokeinit <- stroketagopen\n                coordlist <- many $ do trim_starting_space\n                                       x <- double\n                                       skipSpace\n                                       y <- double\n                                       skipSpace\n                                       return (x :!: y)\n                stroketagclose\n                return $ strokeinit { stroke_data = coordlist }\n\n-- |\n\ntrim :: Parser ()\ntrim = trim_starting_space\n\n-- |\n\nparser_xournal :: Parser Xournal\nparser_xournal = do trim\n                    xmlheader <?> "xmlheader"\n                    trim\n                    xournal <?> "xournal"\n\n-- |\n\nxournal :: Parser Xournal\nxournal = do trim\n             xournalheader <?> "xournalheader"\n             trim\n             t <- title <?> "title"\n             trim\n             (try (preview >> return ())\n              <|> return ())\n             pgs <- many1 (page <?> "page")\n             trim\n             xournalclose\n             return $ Xournal  t pgs\n\n-- |\n\npage :: Parser Page\npage = do trim\n          dim <- pageheader\n          trim\n          bkg <- background <?> "background"\n          trim\n          layers <- many1 layer\n          trim\n          pageclose\n          return $ Page dim bkg layers\n\n-- |\n\nlayer :: Parser Layer\nlayer = do trim\n           layerheader\n           trim\n           strokes <- many onestroke\n           trim\n           layerclose\n           return $ Layer strokes\n\n-- |\n\ntitle :: Parser B.ByteString\ntitle = do trim\n           titleheader\n           str <- takeTill (inClass "<") -- (many . satisfy . notInClass ) "<"\n           titleclose\n           return str\n\n-- |\n\ntitleheader :: Parser B.ByteString\ntitleheader = string "<title>"\n\n-- |\n\ntitleclose :: Parser B.ByteString\ntitleclose = string "</title>"\n\n-- |\n\npreview :: Parser ()\npreview = do trim\n             previewheader\n             str <- takeTill (inClass "<")\n             previewclose\n             trim\n\n-- |\n\npreviewheader :: Parser B.ByteString\npreviewheader = string "<preview>"\n\n-- |\n\npreviewclose :: Parser B.ByteString\npreviewclose = string "</preview>"\n\n-- |\n\nxournalheader :: Parser B.ByteString\nxournalheader = xournalheaderstart *> takeTill (inClass ">") <* xournalheaderend\n\n-- |\n\nxournalheaderstart :: Parser B.ByteString\nxournalheaderstart = string "<xournal"\n\n-- |\n\nxournalheaderend :: Parser Char\nxournalheaderend = char \'>\'\n\n-- |\n\nxournalclose :: Parser B.ByteString\nxournalclose =  string "</xournal>"\n\n-- |\n\npageheader :: Parser Dimension\npageheader = do pageheaderstart\n                trim\n                string "width="\n                char \'"\'\n                w <- double\n                char \'"\'\n                trim\n                string "height="\n                char \'"\'\n                h <- double\n                char \'"\'\n                takeTill (inClass ">")\n                pageheaderend\n                return $ Dim w h\n\n-- |\n\npageheaderstart :: Parser B.ByteString\npageheaderstart = string "<page"\n\n-- |\n\npageheaderend :: Parser Char\npageheaderend = char \'>\'\n\n-- |\n\npageclose :: Parser B.ByteString\npageclose = string "</page>"\n\n-- |\n\nlayerheader :: Parser B.ByteString\nlayerheader = string "<layer>"\n\n-- |\n\nlayerclose :: Parser B.ByteString\nlayerclose = string "</layer>"\n\n-- |\n\nbackground :: Parser Background\nbackground = do\n    trim\n    backgroundheader\n    trim\n    string "type="\n    char \'"\'\n    typ <- alphabet\n    char \'"\'\n    case typ of\n      "solid" -> do\n        trim\n        string "color="\n        char \'"\'\n        col <- alphanumsharp\n        char \'"\'\n        trim\n        string "style="\n        trim\n        char \'"\'\n        sty <- alphabet\n        char \'"\'\n        trim\n        takeTill (inClass "/>") -- ( many . satisfy . notInClass ) "/>"\n        backgroundclose\n        return $ Background typ col sty\n      "pdf" -> do\n        trim <?> "trim0"\n        (mdomain,mfilename) <- (try $ do\n                                 string "domain="\n                                 char \'"\'\n                                 domain <- alphabet\n                                 char \'"\'\n                                 trim <?> "trim1"\n                                 string "filename="\n                                 trim <?> "trim2"\n                                 char \'"\'\n                                 filename <- parseFileName <?> "filename parse"\n                                 char \'"\'\n                                 return (Just domain, Just filename))\n                               <|> return (Nothing,Nothing)\n        trim <?> "trim3"\n        string "pageno="\n        trim <?> "trim4"\n        char \'"\'\n        pnum <- decimal <?> "decimal"\n        char \'"\'\n        trim\n        takeTill (inClass "/>")  <?> "here takeTill"\n        backgroundclose\n        return $ BackgroundPdf typ mdomain mfilename pnum\n\n-- |\n\nalphabet :: Parser B.ByteString\nalphabet = takeWhile1 (\\w -> (w >= 65 && w <= 90) || (w >= 97 && w <= 122))\n\n-- |\n\nalphanumsharp :: Parser B.ByteString\nalphanumsharp = takeWhile1 (\\w -> (w >= 65 && w <= 90)\n                                  || (w >= 97 && w <= 122)\n                                  || ( w >= 48 && w<= 57 )\n                                  || ( w== 35) )\n\n-- | need to be reimplemented\n\nparseFileName :: Parser B.ByteString\nparseFileName = takeTill (inClass [\'"\'])\n                -- takeWhilw1 (\\w -> (w >= 65 && w <= 90)\n                --                   || (w >= 97 && w <= 122)\n                --                   || (w >= 48 && w <= 57)\n                --                   || (w == 35)\n\n-- |\n\nbackgroundheader :: Parser B.ByteString\nbackgroundheader = string "<background"\n\n-- |\n\nbackgroundclose :: Parser B.ByteString\nbackgroundclose = string "/>"\n\n-- |\n\niter_xournal :: Sink B.ByteString IO Xournal\niter_xournal = AI.parserToIteratee parser_xournal\n\n-- |\n\nread_xournal :: String -> IO Xournal\nread_xournal str = Iter.fileDriver iter_xournal str\n\n-- |\n\nread_xojgz :: String -> IO Xournal\nread_xojgz str =  Iter.fileDriver (Iter.joinIM (ungzipXoj iter_xournal)) str\n\n-- |\n\ncat_xournalgz :: String -> IO ()\ncat_xournalgz str = Iter.fileDriver\n                      (Iter.joinIM (ungzipXoj printLinesUnterminated)) str\n\n-- |\n\nonlyresult (Done _ r) = r\n-}\n'