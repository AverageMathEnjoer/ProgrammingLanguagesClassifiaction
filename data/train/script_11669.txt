b'\xef\xbb\xbf\n#load "packages/FsLab/FsLab.fsx"\n\n#load "parseScripts.fs"\n\nopen FSharp.Data\nopen System\nopen System.IO\nopen StarWars.ParseScripts\nopen System.Text.RegularExpressions\n\n// Extract interactions between characters from the individual scripts\nlet characters = \n    let stdCharacters = File.ReadAllLines(__SOURCE_DIRECTORY__ + "/data/characters.csv") \n    let allNames =\n        [| 0 .. scriptUrls.Length-1 |]\n        |> Array.collect\n            (fun ep -> \n                Seq.append aliasesForEpisodes.[ep].Keys aliasesForEpisodes.[ep].Values \n                |> Array.ofSeq)\n    stdCharacters \n    |> Array.append allNames \n    |> set\n\n/// Create JSON network\nlet getJsonNetwork nodes links =\n    let jsonNodes = \n        nodes\n        |> Seq.map (fun (name, count) -> \n            JsonValue.Record \n                [| "name", JsonValue.String name; \n                   "value", JsonValue.Number (decimal (count+1))\n                   "colour", JsonValue.String (getCharacterColour name)|] )\n        |> Array.ofSeq\n        |> JsonValue.Array\n    // translate links from names to idxs\n    let nodeIdxs = Seq.mapi (fun i (name, count) -> name, i) nodes |> dict\n    let jsonLinks = \n        links\n        |> Seq.choose (fun ((n1, n2), value) -> \n            if nodeIdxs.ContainsKey(n1) && nodeIdxs.ContainsKey(n2) then\n              JsonValue.Record [| \n                "source", JsonValue.Number (decimal nodeIdxs.[n1]); \n                "target", JsonValue.Number (decimal nodeIdxs.[n2]);\n                "value", JsonValue.Number (decimal value)|] |> Some\n            else None)\n        |> Array.ofSeq\n        |> JsonValue.Array\n    (JsonValue.Record [| "nodes", jsonNodes  ; "links", jsonLinks |]).ToString()\n\nlet getInteractionNetwork countThreshold episodeIdx = \n    let episode, url = scriptUrls.[episodeIdx]\n    let charactersByScene = getCharactersByScene url\n\n    let namesInScenes = \n        charactersByScene\n        |> Array.map (fun names -> \n            names |> Array.filter (fun name -> \n                        characters.Contains name && \n                        characterCheck episodeIdx name ))       \n\n    // Create weighted network\n    let nodes = \n        namesInScenes \n        |> Seq.collect id\n        |> Seq.countBy id        \n        |> Seq.filter (fun (name, count) -> count >= countThreshold)\n    let nodeLookup = nodes |> Seq.map fst |> set\n\n    let links = \n        namesInScenes \n        |> Array.collect (fun names -> \n            [| for i in 0..names.Length - 1 do \n                for j in i+1..names.Length - 1 do\n                  let n1 = names.[i]\n                  let n2 = names.[j]\n                  if nodeLookup.Contains(n1) && nodeLookup.Contains(n2) then\n                     yield min n1 n2, max n1 n2 |])\n        |> Seq.countBy id\n        |> Array.ofSeq\n\n    nodes, links\n\nlet generateInteractionNetwork episodeIdx =     \n    let nodes, links = getInteractionNetwork 0 episodeIdx\n    File.WriteAllText(__SOURCE_DIRECTORY__ + "/networks/starwars-episode-" + string (episodeIdx + 1) + "-interactions.json",\n        getJsonNetwork nodes links)\n\nfor i in 0..5 do generateInteractionNetwork i\ngenerateInteractionNetwork 6\n\n// =====================================================================\n// Generate global network\n\nlet countThreshold = 0\nlet linkThreshold = 0\nlet nodes, links = \n    [0..6] |> List.map (getInteractionNetwork 0) |> List.unzip\nlet summarizeEpisodes data =\n    data \n    |> Seq.collect id \n    |> Seq.groupBy fst\n    |> Seq.map (fun (name, episodeCounts) -> name, episodeCounts |> Seq.sumBy snd)\n\nlet allNodes = \n    summarizeEpisodes nodes \n    |> Seq.filter (fun (name, count) -> count >= countThreshold)\nlet nodeLookup = allNodes |> Seq.map fst |> set\n\nlet allLinks = \n    summarizeEpisodes links\n    |> Seq.filter (fun ((n1, n2), _) -> nodeLookup.Contains(n1) && nodeLookup.Contains(n2))\n    |> Seq.filter (fun ((n1, n2), count) -> count > linkThreshold)\n\nFile.WriteAllText(__SOURCE_DIRECTORY__ + "/networks/starwars-full-interactions.json",\n    getJsonNetwork allNodes allLinks)\n\n// =====================================================================\n// Add R2-D2 and Chewbacca manually from the network of mentions\n// Adding BB-8 from Episode 7\n\n[<Literal>]\nlet sampleNetwork = __SOURCE_DIRECTORY__ + "/networks/starwars-episode-1-mentions.json"\ntype Network = JsonProvider<sampleNetwork>\n\nlet getInteractionsForMissing allMissingCharacters allSimilarCharacters (episodeIdx: int option) =\n    // load interactions and mentions\n    let mentionsNetwork, interactionNetwork = \n        match episodeIdx with\n        | Some(i) ->\n            Network.Load(\n              __SOURCE_DIRECTORY__ + "/networks/starwars-episode-" + string i + "-mentions.json"),\n            Network.Load(\n              __SOURCE_DIRECTORY__ + "/networks/starwars-episode-" + string i + "-interactions.json")\n        | None -> \n            Network.Load(__SOURCE_DIRECTORY__ + "/networks/starwars-full-mentions.json"),\n            Network.Load(__SOURCE_DIRECTORY__ + "/networks/starwars-full-interactions.json")\n\n    let mentionsLookup = mentionsNetwork.Nodes |> Seq.mapi (fun i x -> x.Name, i) |> dict\n    let mentionsLookup\' = mentionsNetwork.Nodes |> Seq.mapi (fun i x -> i, x.Name) |> dict\n    let getMentionsLinks name = \n        mentionsNetwork.Links \n        |> Array.filter (fun x -> \n            mentionsLookup.ContainsKey name && \n            (x.Source = mentionsLookup.[name] || x.Target = mentionsLookup.[name]))\n        |> Array.map (fun x -> (mentionsLookup\'.[x.Source], mentionsLookup\'.[x.Target]), x.Value)\n\n    // filter out characters that do not appear in the episode\n    let missingCharacters, similarCharacters =  \n        Array.zip allMissingCharacters allSimilarCharacters\n        |> Array.filter (fun (ch, others) -> mentionsLookup.ContainsKey ch)\n        |> Array.unzip\n\n    // interactions: translate indices to names and vice versa\n    let interactionsLookup = interactionNetwork.Nodes |> Seq.mapi (fun i x -> x.Name, i) |> dict\n    let interactionsLookup\' = interactionNetwork.Nodes |> Seq.mapi (fun i x -> i, x.Name) |> dict\n    let getInteractionsLinks name = \n        interactionNetwork.Links \n        |> Seq.filter (fun x -> \n            interactionsLookup.ContainsKey name && \n             (x.Source = interactionsLookup.[name] || x.Target = interactionsLookup.[name]))\n        |> Seq.map (fun x -> (interactionsLookup\'.[x.Source], interactionsLookup\'.[x.Target]), x.Value)\n\n    // helper functions to get nodes for interactions and mentions for specific characters\n    let getNameMentions name = mentionsNetwork.Nodes |> Seq.tryFind (fun x -> x.Name = name)\n    let getNameInteractions name = interactionNetwork.Nodes |> Seq.tryFind (fun x -> x.Name = name)\n\n    // compute link weights for each existing\n    let linkWeights =\n        interactionNetwork.Nodes\n        |> Array.map (fun node -> node.Name) \n        |> Array.map (fun node -> \n            let mentionsLinks = \n                getMentionsLinks node\n                |> Array.map (fun ((n,n\'),w) -> if n = node then n\',w else n,w)\n                |> dict\n            let interactionsLinks = getInteractionsLinks node \n            let weights = \n                [| for ((n1, n2),w) in interactionsLinks ->\n                    let name\' = if n1 = node then n2 else n1\n                    let w\' = if mentionsLinks.ContainsKey(name\') then mentionsLinks.[name\'] else 0\n                    if w\' > 0 then\n                       name\', (float w) / (float w\') \n                    else \n                       name\', (float w) |]\n            if weights.Length > 0 then\n                node, weights |> Array.averageBy snd\n            else\n                // character doesn\'t interact with any other character\n                node, 0.0 )\n        |> dict\n\n    // take all mensions links from missing characters & scale them using the link weights\n    // average link weights for links between missing characters\n    let newNodes, newLinks, interactionRates =\n        Array.zip missingCharacters similarCharacters\n        |> Array.map (fun (missingCharacter, similar) -> \n            let similarLinks = similar |> Seq.map getInteractionsLinks |> Seq.concat |> dict\n            let newLinks = \n                getMentionsLinks missingCharacter\n                |> Array.map (fun ((n1, n2), count) -> \n                    // compute link weight for the \'missing\' <--> \'other\' link\n                    let otherName = if n1 = missingCharacter then n2 else n1\n                    let newWeight = \n                        if linkWeights.ContainsKey otherName then \n                            linkWeights.[otherName] * (float count) |> floor |> int \n                        else 0\n                    (missingCharacter, otherName), newWeight)\n                |> Array.filter (fun ((missing, other), w) ->\n                    // to avoid spurious links, check if similar characters are linked with the \'other\' node\n                    let isSimilarLink = \n                        similar\n                        |> Array.fold (fun isSim ch -> \n                            isSim || similarLinks.ContainsKey(ch, other) \n                            || similarLinks.ContainsKey(other,ch)\n                            ) false\n                    let isLinked = Array.contains other similar\n                    isSimilarLink || isLinked )\n                |> Array.filter (snd >> (<) 0)\n            // add nodes for the missing characters\n            let weight = \n                let similarWeight = \n                    similar \n                    |> Array.map (fun node -> \n                        let interactionWeight = \n                            match (getNameInteractions node) with\n                            | Some n -> n.Value |> float\n                            | None -> 0.0\n                        let mentionsWeight = \n                            match (getNameMentions node) with \n                            | Some n -> n.Value |> float\n                            | None -> 0.0\n                        if mentionsWeight > 0.0 then \n                           interactionWeight/mentionsWeight\n                        else 0.0)\n                    |> Array.average    \n                match getNameMentions missingCharacter with\n                | Some n -> similarWeight * (float n.Value)\n                | None -> 0.0\n            let newNode = missingCharacter, weight |> floor |> int\n            \n            // Compute average interaction rate for the character from links\n            let avgInteractionRate = \n                let mentions = getMentionsLinks missingCharacter\n                let weightedLinks = \n                    newLinks\n                    |> Array.collect (fun ((n1, n2), interactionW) ->\n                        mentions |> Array.filter (fun ((n1\', n2\'), mentionW) -> n1\' = n2 || n2\' = n2)\n                        |> Array.map (fun (_, mentionW) -> (float interactionW)/(float mentionW)))\n                if weightedLinks.Length > 0 then \n                    Array.average weightedLinks\n                else 0.0\n            newNode, newLinks, avgInteractionRate)\n        |> Array.unzip3\n\n    // also add links between the non-speaking characters\n    let nonspeakingLinks = \n        [| for ch1 in 0..missingCharacters.Length-1 do\n            for ch2 in ch1+1..missingCharacters.Length-1 ->\n                let mentionsW = \n                    let filteredMentions = \n                        getMentionsLinks missingCharacters.[ch1] \n                        |> Array.filter (fun ((n1, n2),_) -> n1 = missingCharacters.[ch2] || n2 = missingCharacters.[ch2])\n                    if filteredMentions.Length > 0 then\n                        filteredMentions |> Array.exactlyOne |> snd |> float\n                    else 0.0\n                let newWeight = \n                    List.average [\n                        mentionsW * interactionRates.[ch1]\n                        mentionsW * interactionRates.[ch2] ]\n                    |> round |> int\n                if missingCharacters.[ch1] < missingCharacters.[ch2] then\n                    (missingCharacters.[ch1], missingCharacters.[ch2]), newWeight\n                else\n                    (missingCharacters.[ch2], missingCharacters.[ch1]), newWeight\n                |]\n\n    // update all nodes and all links\n    let updatedNodes = \n        interactionNetwork.Nodes \n        |> Array.map (fun n -> n.Name, n.Value)\n        |> Array.append newNodes\n        |> Array.groupBy fst\n        |> Array.map (fun (name, ws) -> name, ws |> Array.sumBy snd)\n        |> Array.filter (snd >> (<) 0)\n    let updatedLinks =\n        interactionNetwork.Links\n        |> Array.map (fun l -> (interactionsLookup\'.[l.Source], interactionsLookup\'.[l.Target]), l.Value)\n        |> Array.append (Array.concat newLinks |> Array.map (fun ((n1, n2),w) -> if n1 < n2 then (n1,n2),w else (n2,n1),w))\n        |> Array.append nonspeakingLinks\n        |> Array.groupBy fst\n        |> Array.map (fun ((n1, n2), ws) -> (n1, n2), ws |> Array.sumBy snd)\n        |> Array.filter (snd >> (<) 0)\n\n    updatedNodes, updatedLinks\n\nlet addSilentEncounters episodeIdx (nodes : (string*int)[] ,links) =\n    match episodeIdx with\n    | Some(7) -> \n        Array.append [| "LUKE", 1 |] nodes,\n        Array.append links [| ("LEIA", "REY"), 1; ("LUKE", "REY"), 1|]\n    | None -> nodes, Array.append links [| ("LEIA", "REY"), 1; ("LUKE", "REY"), 1|]\n    | _ -> nodes, links\n\n\nlet allMissingCharacters = [|"R2-D2"; "CHEWBACCA"; "BB-8"|]\nlet allSimilarCharacters = [| [|"C-3PO"|]; [|"HAN"|]; [| "REY"; "FINN"; "POE" |] |]\n\nlet fillInteractionNetwork episodeIdx =     \n    let nodes, links = \n        getInteractionsForMissing allMissingCharacters allSimilarCharacters (Some episodeIdx)\n        |> addSilentEncounters (Some episodeIdx)\n    File.WriteAllText(__SOURCE_DIRECTORY__ + "/networks/starwars-episode-" + string (episodeIdx) + "-interactions-allCharacters.json",\n        getJsonNetwork nodes links)\n\nfor i in 1..7 do \n    printfn "%d" i\n    fillInteractionNetwork i\n\nlet fullNodes, fullLinks = \n    getInteractionsForMissing allMissingCharacters allSimilarCharacters None\n    |> addSilentEncounters None\nFile.WriteAllText(__SOURCE_DIRECTORY__ + "/networks/starwars-full-interactions-allCharacters.json",\n    getJsonNetwork fullNodes fullLinks)\n\nlet mergeDarthVader (nodes, links) =\n    let mergedNodes = \n       ("DARTH VADER",\n        nodes |> Array.filter (fun (name, _) -> name = "ANAKIN" || name = "DARTH VADER")\n        |> Array.sumBy snd)\n    let mergedLinks = \n        links |> Array.filter (fun ((n1, n2), w) -> n1 = "ANAKIN" || n1 = "DARTH VADER" || n2 = "ANAKIN" || n2 = "DARTH VADER")\n        |> Array.map (fun ((n1, n2), w) -> if n1 = "ANAKIN" || n1 = "DARTH VADER" then n2, w else n1, w)\n        |> Array.groupBy fst\n        |> Array.choose (fun (name, ws) -> \n            if name = "DARTH VADER" then None else\n            let w = Array.sumBy snd ws\n            if name < "DARTH VADER" then \n                Some ((name, "DARTH VADER"), w)\n            else \n                Some (("DARTH VADER", name), w))\n    let nodes\' = \n        nodes \n        |> Array.filter (fun (name, _) -> name <> "ANAKIN" && name <> "DARTH VADER")\n        |> Array.append [|mergedNodes|]\n    let links\' = \n        links \n        |> Array.filter (fun ((n1, n2), w) -> n1 <> "ANAKIN" && n1 <> "DARTH VADER" && n2 <> "ANAKIN" && n2 <> "DARTH VADER")\n        |> Array.append mergedLinks\n    nodes\', links\'        \n\n// Additionally merge Anakin and Darth Vader\nlet fullNodes\', fullLinks\' = \n    getInteractionsForMissing allMissingCharacters allSimilarCharacters None\n    |> addSilentEncounters None\n    |> mergeDarthVader \nFile.WriteAllText(__SOURCE_DIRECTORY__ + "/networks/starwars-full-interactions-allCharacters-merged.json",\n    getJsonNetwork fullNodes\' fullLinks\')\n'