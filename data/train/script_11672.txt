b'{-# LANGUAGE OverloadedStrings #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n{-# OPTIONS_GHC -fno-warn-unused-local-binds -fno-warn-unused-imports #-}\n\nmodule Graphics.Hoodle.Render\n  ( -- * xform\n    Xform4Page (..),\n\n    -- * simple rendering using non-R-structure\n    renderStrk,\n    renderImg,\n    renderBkg,\n    renderItem,\n    renderLayer,\n    renderPage,\n\n    -- * simple rendering using R-structure\n    renderRBkg,\n    renderRItem,\n\n    -- * render in bbox\n    renderRLayerInBBox,\n    renderRBkgInBBox,\n\n    -- * render using buf\n    renderRBkgBuf,\n    renderRLayerInBBoxBuf,\n\n    -- * buffer update\n    updateLayerBuf,\n    updatePageBuf,\n    updateHoodleBuf,\n\n    -- * construct R-structure from non-R-structure\n    cnstrctRLayer,\n    cnstrctRBkgStateT,\n    cnstrctRPageStateT,\n    cnstrctRHoodle,\n\n    -- * some simple render with state\n    renderPageStateT,\n    initRenderContext,\n  )\nwhere\n\nimport Control.Concurrent.STM\n  ( atomically,\n    newEmptyTMVarIO,\n    takeTMVar,\n  )\nimport Control.Lens (set, view)\nimport Control.Monad (join, void)\nimport Control.Monad.Identity (runIdentity)\nimport Control.Monad.State (StateT, evalStateT)\nimport Control.Monad.Trans (lift, liftIO)\nimport Control.Monad.Trans.Reader (ask)\nimport qualified Data.ByteString.Char8 as C\nimport qualified Data.HashMap.Strict as HM\nimport Data.Hoodle.BBox\n  ( BBox (..),\n    BBoxed (..),\n    getBBox,\n    inflate,\n    makeBBoxed,\n  )\nimport Data.Hoodle.Generic\n  ( GHoodle (..),\n    GPage (..),\n    PDFData (..),\n    fromList,\n    gbuffer,\n    gitems,\n    glayers,\n    gpages,\n  )\nimport Data.Hoodle.Predefined\n  ( getPenColor,\n    predefinedHighlighterOpacity,\n  )\nimport Data.Hoodle.Simple\n  ( Anchor (..),\n    Dimension (..),\n    Hoodle (..),\n    Image (..),\n    Item (..),\n    Layer (..),\n    Link (..),\n    Page (..),\n    SVG (..),\n    Stroke (..),\n    background,\n    dimension,\n    embeddedPdf,\n    embeddedText,\n    hoodleID,\n    items,\n    layers,\n    pages,\n    revisions,\n    title,\n  )\nimport Data.Hoodle.Zipper (fromNonEmptyList)\nimport Graphics.Hoodle.Render.Background\n  ( cnstrctRBkgStateT,\n    -- popplerGetDocFromDataURI,\n    renderBackgroundStateT,\n    renderBkg,\n  )\nimport Graphics.Hoodle.Render.Item\n  ( cnstrctRItem,\n    getByteStringIfEmbeddedPNG,\n    getJPGandCreateSurface,\n    saveTempPNGToCreateSurface,\n  )\nimport Graphics.Hoodle.Render.Primitive\n  ( drawStrokeCurve,\n    drawVWStrokeCurve,\n  )\nimport Graphics.Hoodle.Render.Type\n  ( CanvasId,\n    Context (..),\n    GenCommand (LayerRedraw),\n    LyBuf (..),\n    PDFCommand (GetDocFromDataURI, GetNPages),\n    RBackground,\n    RHoodle,\n    RItem (..),\n    RLayer,\n    RPage,\n    RenderCache,\n    Renderer,\n    emptyRLayer,\n    issueGenCommandID,\n    issuePDFCommandID,\n    issueSurfaceID,\n    rbkg_surfaceid,\n    rendererGenCmdQ,\n    rendererPDFCmdQ,\n    sendGenCommand,\n    sendPDFCommand,\n  )\nimport Graphics.Hoodle.Render.Util (clipBBox)\nimport qualified Graphics.Rendering.Cairo as Cairo\nimport qualified Graphics.Rendering.Cairo.SVG as RSVG\nimport System.Directory (doesFileExist)\nimport System.FilePath (takeExtension)\n--\nimport Prelude hiding (concatMap, curry, uncurry)\n\ndata Xform4Page = Xform4Page\n  { transx :: Double,\n    transy :: Double,\n    scalex :: Double,\n    scaley :: Double\n  }\n  deriving (Show)\n\n------------\n-- simple --\n------------\n\n-- | render stroke\nrenderStrk :: Stroke -> Cairo.Render ()\nrenderStrk s@(Stroke _ _ w d) = do\n  let opacity =\n        if stroke_tool s == "highlighter"\n          then predefinedHighlighterOpacity\n          else 1.0\n  case getPenColor (stroke_color s) of\n    Just (r, g, b, a) -> Cairo.setSourceRGBA r g b (a * opacity)\n    Nothing -> Cairo.setSourceRGBA 0.5 0.5 0.5 1\n  Cairo.setLineWidth w\n  Cairo.setLineCap Cairo.LineCapRound\n  Cairo.setLineJoin Cairo.LineJoinRound\n  drawStrokeCurve d\n  Cairo.stroke\nrenderStrk s@(VWStroke _ _ d) = do\n  let opacity =\n        if stroke_tool s == "highlighter"\n          then predefinedHighlighterOpacity\n          else 1.0\n  case getPenColor (stroke_color s) of\n    Just (r, g, b, a) -> Cairo.setSourceRGBA r g b (a * opacity)\n    Nothing -> Cairo.setSourceRGBA 0.5 0.5 0.5 1\n  Cairo.setFillRule Cairo.FillRuleWinding\n  drawVWStrokeCurve d\n  Cairo.fill\n\n-- | render image : not fully implemented\nrenderImg :: Image -> Cairo.Render ()\nrenderImg img@(Image src (x, y) (Dim w h)) = do\n  let (x2, y2) = (x + w, y + h)\n      -- imgbbx = BBox (x,y) (x2,y2)\n      embed = getByteStringIfEmbeddedPNG src\n  msfc <- liftIO $ case embed of\n    Just bstr -> do\n      sfc <- saveTempPNGToCreateSurface bstr\n      return (Just sfc)\n    Nothing -> do\n      let filesrc = C.unpack (img_src img)\n          filesrcext = takeExtension filesrc\n          imgaction\n            | filesrcext == ".PNG" || filesrcext == ".png" = do\n              b <- doesFileExist filesrc\n              if b\n                then Just <$> Cairo.imageSurfaceCreateFromPNG filesrc\n                else return Nothing\n            | filesrcext == ".JPG" || filesrcext == ".jpg" = do\n              b <- doesFileExist filesrc\n              if b\n                then Just <$> getJPGandCreateSurface filesrc\n                else return Nothing\n            | otherwise = return Nothing\n      imgaction\n  case msfc of\n    Nothing -> do\n      -- fall back\n      Cairo.setSourceRGBA 0 0 0 1\n      Cairo.setLineWidth 10\n      Cairo.rectangle x y w h\n      Cairo.stroke\n    Just sfc -> do\n      ix <- fmap fromIntegral (Cairo.imageSurfaceGetWidth sfc)\n      iy <- fmap fromIntegral (Cairo.imageSurfaceGetHeight sfc)\n      Cairo.save\n      Cairo.translate x y\n      Cairo.scale ((x2 - x) / ix) ((y2 - y) / iy)\n      Cairo.setSourceSurface sfc 0 0\n      Cairo.paint\n      Cairo.restore\n\n-- | render svg\nrenderSVG :: SVG -> Cairo.Render ()\nrenderSVG svg@(SVG _ _ bstr _ _) = do\n  let str = C.unpack bstr\n  RSVG.withSvgFromString str $ \\rsvg -> do\n    let svgbbx = runIdentity (makeBBoxed svg)\n    let (x, y) = (svg_pos . bbxed_content) svgbbx\n        BBox (x1, y1) (x2, y2) = getBBox svgbbx\n        (ix\', iy\') = RSVG.svgGetSize rsvg\n        ix = fromIntegral ix\'\n        iy = fromIntegral iy\'\n    Cairo.save\n    Cairo.translate x y\n    Cairo.scale ((x2 - x1) / ix) ((y2 - y1) / iy)\n    _ <- RSVG.svgRender rsvg\n    Cairo.restore\n    return ()\n\n-- | render svg\nrenderLink :: Link -> Cairo.Render ()\nrenderLink lnk =\n  let bstr = link_render lnk\n   in if C.null bstr\n        then do\n          let lnkbbx = runIdentity (makeBBoxed lnk)\n              bbox@(BBox (x0, y0) (x1, y1)) = getBBox lnkbbx\n          clipBBox (Just bbox)\n          Cairo.setSourceRGBA 0 1 0 1\n          Cairo.rectangle x0 y0 (x1 - x0) (y1 - y0)\n          Cairo.fill\n          Cairo.resetClip\n          return ()\n        else do\n          let str = C.unpack bstr\n          RSVG.withSvgFromString str $ \\rsvg -> do\n            let lnkbbx = runIdentity (makeBBoxed lnk)\n            let (x, y) = (link_pos . bbxed_content) lnkbbx\n                BBox (x1, y1) (x2, y2) = getBBox lnkbbx\n                (ix\', iy\') = RSVG.svgGetSize rsvg\n                ix = fromIntegral ix\'\n                iy = fromIntegral iy\'\n            clipBBox (Just (getBBox lnkbbx))\n            Cairo.save\n            Cairo.translate x y\n            Cairo.scale ((x2 - x1) / ix) ((y2 - y1) / iy)\n            _ <- RSVG.svgRender rsvg\n            Cairo.restore\n            Cairo.resetClip\n            return ()\n\n-- |\nrenderAnchor :: Anchor -> Cairo.Render ()\nrenderAnchor anc =\n  let bstr = anchor_render anc\n   in if C.null bstr\n        then do\n          let ancbbx = runIdentity (makeBBoxed anc)\n              bbox@(BBox (x0, y0) (x1, y1)) = getBBox ancbbx\n          clipBBox (Just bbox)\n          Cairo.setSourceRGBA 1 0 0 1\n          Cairo.rectangle x0 y0 (x1 - x0) (y1 - y0)\n          Cairo.fill\n          Cairo.resetClip\n          return ()\n        else do\n          let str = C.unpack bstr\n          RSVG.withSvgFromString str $ \\rsvg -> do\n            let ancbbx = runIdentity (makeBBoxed anc)\n            let (x, y) = (anchor_pos . bbxed_content) ancbbx\n                BBox (x1, y1) (x2, y2) = getBBox ancbbx\n                (ix\', iy\') = RSVG.svgGetSize rsvg\n                ix = fromIntegral ix\'\n                iy = fromIntegral iy\'\n            clipBBox (Just (getBBox ancbbx))\n            Cairo.save\n            Cairo.translate x y\n            Cairo.scale ((x2 - x1) / ix) ((y2 - y1) / iy)\n            _ <- RSVG.svgRender rsvg\n            Cairo.restore\n            Cairo.resetClip\n            return ()\n\n-- | render item\nrenderItem :: Item -> Cairo.Render ()\nrenderItem (ItemStroke strk) = renderStrk strk\nrenderItem (ItemImage img) = renderImg img\nrenderItem (ItemSVG svg) = renderSVG svg\nrenderItem (ItemLink lnk) = renderLink lnk\nrenderItem (ItemAnchor anc) = renderAnchor anc\n\n-- | renderLayer\nrenderLayer :: Layer -> Cairo.Render ()\nrenderLayer = mapM_ renderItem . view items\n\n-- |\nrenderPage :: Page -> Cairo.Render ()\nrenderPage page = do\n  renderBkg (view background page, view dimension page)\n  Cairo.setLineCap Cairo.LineCapRound\n  Cairo.setLineJoin Cairo.LineJoinRound\n  mapM_ renderLayer . view layers $ page\n  Cairo.stroke\n\n-----\n-- R-structure\n----\n\ndrawFallBackBkg :: Dimension -> Cairo.Render ()\ndrawFallBackBkg (Dim w h) = do\n  Cairo.setSourceRGBA 1 1 1 1\n  Cairo.rectangle 0 0 w h\n  Cairo.fill\n\n-- |\nrenderRBkg ::\n  RenderCache ->\n  CanvasId ->\n  (RBackground, Dimension, Maybe Xform4Page) ->\n  Cairo.Render (RBackground, Dimension, Maybe Xform4Page)\nrenderRBkg = renderRBkgBuf\n\n-- |\nrenderRItem :: RenderCache -> CanvasId -> RItem -> Cairo.Render RItem\nrenderRItem _ _ itm@(RItemStroke strk) = renderStrk (bbxed_content strk) >> return itm\nrenderRItem _cache _cid itm@(RItemImage img msfc) = do\n  case msfc of\n    Nothing -> renderImg (bbxed_content img)\n    Just sfc -> do\n      let (x, y) = (img_pos . bbxed_content) img\n          BBox (x1, y1) (x2, y2) = getBBox img\n      ix <- fmap fromIntegral (Cairo.imageSurfaceGetWidth sfc)\n      iy <- fmap fromIntegral (Cairo.imageSurfaceGetHeight sfc)\n      Cairo.save\n      Cairo.translate x y\n      Cairo.scale ((x2 - x1) / ix) ((y2 - y1) / iy)\n      Cairo.setSourceSurface sfc 0 0\n      Cairo.paint\n      Cairo.restore\n  return itm\nrenderRItem _ _ itm@(RItemSVG svgbbx mrsvg) = do\n  case mrsvg of\n    Nothing -> renderSVG (bbxed_content svgbbx)\n    Just rsvg -> do\n      let (x, y) = (svg_pos . bbxed_content) svgbbx\n          BBox (x1, y1) (x2, y2) = getBBox svgbbx\n          (ix\', iy\') = RSVG.svgGetSize rsvg\n          ix = fromIntegral ix\'\n          iy = fromIntegral iy\'\n      Cairo.save\n      Cairo.translate x y\n      Cairo.scale ((x2 - x1) / ix) ((y2 - y1) / iy)\n      _ <- RSVG.svgRender rsvg\n      Cairo.restore\n      return ()\n  return itm\nrenderRItem _ _ itm@(RItemLink lnkbbx mrsvg) = do\n  case mrsvg of\n    Nothing -> renderLink (bbxed_content lnkbbx)\n    Just rsvg -> do\n      let (x, y) = (link_pos . bbxed_content) lnkbbx\n          BBox (x1, y1) (x2, y2) = getBBox lnkbbx\n          (ix\', iy\') = RSVG.svgGetSize rsvg\n          ix = fromIntegral ix\'\n          iy = fromIntegral iy\'\n      Cairo.save\n      Cairo.translate x y\n      Cairo.scale ((x2 - x1) / ix) ((y2 - y1) / iy)\n      _ <- RSVG.svgRender rsvg\n      Cairo.restore\n      return ()\n  return itm\nrenderRItem _ _ itm@(RItemAnchor ancbbx mrsvg) = do\n  case mrsvg of\n    Nothing -> renderAnchor (bbxed_content ancbbx)\n    Just rsvg -> do\n      let (x, y) = (anchor_pos . bbxed_content) ancbbx\n          BBox (x1, y1) (x2, y2) = getBBox ancbbx\n          (ix\', iy\') = RSVG.svgGetSize rsvg\n          ix = fromIntegral ix\'\n          iy = fromIntegral iy\'\n      Cairo.save\n      Cairo.translate x y\n      Cairo.scale ((x2 - x1) / ix) ((y2 - y1) / iy)\n      _ <- RSVG.svgRender rsvg\n      Cairo.restore\n      return ()\n  return itm\n\n------------\n-- InBBox --\n------------\n\n-- | background drawing in bbox\nrenderRBkgInBBox ::\n  RenderCache ->\n  CanvasId ->\n  Maybe BBox ->\n  (RBackground, Dimension, Maybe Xform4Page) ->\n  Cairo.Render (RBackground, Dimension, Maybe Xform4Page)\nrenderRBkgInBBox cache cid mbbox (b, dim, mx) = do\n  clipBBox (fmap (`inflate` 1) mbbox)\n  _ <- renderRBkgBuf cache cid (b, dim, mx)\n  Cairo.resetClip\n  return (b, dim, mx)\n\n-- | render RLayer within BBox after hittest items\nrenderRLayerInBBox ::\n  RenderCache ->\n  CanvasId ->\n  Maybe BBox ->\n  (RLayer, Dimension, Maybe Xform4Page) ->\n  Cairo.Render (RLayer, Dimension, Maybe Xform4Page)\nrenderRLayerInBBox = renderRLayerInBBoxBuf\n\n-----------------------\n-- draw using buffer --\n-----------------------\n\nadjustScale :: Double -> Maybe Xform4Page -> Cairo.Render ()\nadjustScale s mx =\n  case mx of\n    Nothing -> Cairo.scale (1 / s) (1 / s)\n    Just xform ->\n      if scalex xform / s > 0.999 && scalex xform / s < 1.001\n        then do\n          Cairo.identityMatrix\n          Cairo.translate (transx xform) (transy xform)\n        else Cairo.scale (1 / s) (1 / s)\n\n-- | Background rendering using buffer\nrenderRBkgBuf ::\n  RenderCache ->\n  CanvasId ->\n  (RBackground, Dimension, Maybe Xform4Page) ->\n  Cairo.Render (RBackground, Dimension, Maybe Xform4Page)\nrenderRBkgBuf cache _cid (b, dim, mx) = do\n  case HM.lookup (rbkg_surfaceid b) cache of\n    Nothing -> void $ drawFallBackBkg dim\n    Just (s, sfc) -> do\n      Cairo.save\n      adjustScale s mx\n      Cairo.setSourceSurface sfc 0 0\n      Cairo.paint\n      Cairo.restore\n  return (b, dim, mx)\n\n-- |\nrenderRLayerInBBoxBuf ::\n  RenderCache ->\n  CanvasId ->\n  Maybe BBox ->\n  (RLayer, Dimension, Maybe Xform4Page) ->\n  Cairo.Render (RLayer, Dimension, Maybe Xform4Page)\nrenderRLayerInBBoxBuf cache _cid mbbox (lyr, dim, mx) = do\n  case view gbuffer lyr of\n    LyBuf sfcid -> do\n      case HM.lookup sfcid cache of\n        Nothing -> return (lyr, dim, mx)\n        Just (s, sfc) -> do\n          clipBBox (fmap (`inflate` 2) mbbox)\n          Cairo.save\n          adjustScale s mx\n          Cairo.setSourceSurface sfc 0 0\n          Cairo.paint\n          Cairo.restore\n          Cairo.resetClip\n          return (lyr, dim, mx)\n\n-------------------\n-- update buffer\n-------------------\n\n-- |\nupdateLayerBuf :: CanvasId -> RLayer -> Renderer ()\nupdateLayerBuf _cid lyr = do\n  qgen <- rendererGenCmdQ <$> ask\n  case view gbuffer lyr of\n    LyBuf sfcid -> do\n      cmdid <- issueGenCommandID\n      (liftIO . atomically) (sendGenCommand qgen cmdid (LayerRedraw sfcid (view gitems lyr)))\n\n-- |\nupdatePageBuf :: CanvasId -> RPage -> Renderer ()\nupdatePageBuf cid = mapM_ (updateLayerBuf cid) . view glayers\n\n-- |\nupdateHoodleBuf :: CanvasId -> RHoodle -> Renderer ()\nupdateHoodleBuf cid = mapM_ (updatePageBuf cid) . view gpages\n\n-------\n-- smart constructor for R hoodle structures\n-------\n\n-- |\ncnstrctRHoodle :: Hoodle -> Renderer RHoodle\ncnstrctRHoodle hdl = do\n  let hid = view hoodleID hdl\n      ttl = view title hdl\n      revs = view revisions hdl\n      pgs = view pages hdl\n      pdf = view embeddedPdf hdl\n      txt = view embeddedText hdl\n  (qpdf, _qgen) <- ((,) <$> rendererPDFCmdQ <*> rendererGenCmdQ) <$> ask\n  mdoc <-\n    maybe\n      (return Nothing)\n      ( \\src -> liftIO $ do\n          cmdid <- issuePDFCommandID\n          docvar <- newEmptyTMVarIO\n          atomically $ sendPDFCommand qpdf cmdid (GetDocFromDataURI src docvar)\n          atomically $ takeTMVar docvar\n      )\n      pdf\n  let getNumPgs doc = liftIO $ do\n        cmdid <- issuePDFCommandID\n        nvar <- newEmptyTMVarIO\n        atomically $ sendPDFCommand qpdf cmdid (GetNPages doc nvar)\n        atomically $ takeTMVar nvar\n  mnumpdfpgs <- sequenceA (getNumPgs <$> mdoc)\n  -- liftIO $print mnumpdfpgs\n  npgs <-\n    evalStateT\n      (mapM cnstrctRPageStateT pgs)\n      (Just (Context "" "" Nothing mdoc))\n  return $ GHoodle hid ttl revs (PDFData <$> pdf <*> mnumpdfpgs) txt (fromList npgs)\n\n-- |\ncnstrctRPageStateT :: Page -> StateT (Maybe Context) Renderer RPage\ncnstrctRPageStateT pg = do\n  let bkg = view background pg\n      dim = view dimension pg\n      lyrs = view layers pg\n  nlyrs_lst <- lift (mapM cnstrctRLayer lyrs)\n  sfcid <- issueSurfaceID\n  let nlyrs_nonemptylst = if null nlyrs_lst then (emptyRLayer sfcid, []) else (head nlyrs_lst, tail nlyrs_lst)\n      nlyrs = fromNonEmptyList nlyrs_nonemptylst\n  nbkg <- cnstrctRBkgStateT dim bkg\n  return $ GPage dim nbkg nlyrs\n\n-- |\ncnstrctRLayer :: Layer -> Renderer RLayer\ncnstrctRLayer lyr = do\n  sfcid <- issueSurfaceID\n  nitms <- (mapM cnstrctRItem . view items) lyr\n  return (set gitems nitms (emptyRLayer sfcid))\n\n-------------------------------------------------------\n-- simple rendering with pdf (or global information) --\n-------------------------------------------------------\n\n-- |\nrenderPageStateT :: Page -> StateT Context Cairo.Render ()\nrenderPageStateT pg = do\n  let bkg = view background pg\n      dim = view dimension pg\n      lyrs = view layers pg\n  renderBackgroundStateT dim bkg\n  lift (mapM_ renderLayer lyrs)\n\n-- |\ninitRenderContext :: Hoodle -> IO Context\ninitRenderContext hdl = do\n  let pdf = view embeddedPdf hdl\n  -- mdoc <- join <$> mapM popplerGetDocFromDataURI pdf\n  let mdoc = Nothing\n  return (Context "" "" Nothing mdoc)\n'