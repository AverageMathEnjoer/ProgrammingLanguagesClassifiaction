b'{-# LANGUAGE\n    CPP\n  , FlexibleInstances\n  , OverloadedStrings\n  , UndecidableInstances\n  #-}\n\n#include "overlapping-compat.h"\n\nmodule Rest.Client.Internal\n  ( module Control.Monad\n  , module Data.String\n  , module Data.String.ToString\n  , MonadIO (..)\n  , L.ByteString\n  , intercalate\n  , URI.encode\n\n  , module Rest.Client.Base\n  , ShowUrl (..)\n  , hAccept\n  , hContentType\n\n  , ApiRequest(..)\n  , doRequest\n  , parseResult\n  , fromJSON\n  , toJSON\n  , fromXML\n  , toXML\n  , toLbs\n\n  , makeReq\n  , doReq\n  ) where\n\nimport Control.Arrow\nimport Control.Monad\nimport Control.Monad.Cont\nimport Data.Aeson.Utils (FromJSON, ToJSON, eitherDecodeV, encode)\n#if !MIN_VERSION_http_client(0,5,0)\nimport Data.Default (def)\n#endif\nimport Data.List\nimport Data.String\nimport Data.String.ToString\nimport Network.HTTP.Conduit hiding (method, responseBody, responseHeaders)\nimport Network.HTTP.Types hiding (statusCode, statusMessage)\nimport Rest.Types.Error\nimport Rest.Types.ShowUrl\nimport Text.XML.HXT.Arrow.Pickle\nimport qualified Data.ByteString.Char8     as CH\nimport qualified Data.ByteString.Lazy      as L\nimport qualified Data.ByteString.Lazy.UTF8 as L\nimport qualified Network.HTTP.Conduit      as HTTP\nimport qualified Network.HTTP.Types        as HTTP\nimport qualified Network.HTTP.Types.Header\nimport qualified Network.URI.Encode        as URI\nimport qualified Text.Xml.Pickle           as P\n\nimport Rest.Client.Base\n\n{-# ANN module ("HLint: ignore Use import/export shortcut"::String) #-}\n\ndata ApiRequest = ApiRequest\n  { method         :: String\n  , uri            :: String\n  , params         :: [(String, String)]\n  , requestHeaders :: RequestHeaders\n  , requestBody    :: L.ByteString\n  }\n\nconvertResponse :: Response (Either (Reason e) a) -> ApiResponse e a\nconvertResponse r =\n  ApiResponse\n   { statusCode      = HTTP.statusCode (responseStatus r)\n   , statusMessage   = HTTP.statusMessage (responseStatus r)\n   , httpVersion     = (httpMajor &&& httpMinor) (responseVersion r)\n   , responseHeaders = HTTP.responseHeaders r\n   , responseBody    = HTTP.responseBody r\n   }\n\n#if MIN_VERSION_http_client(0,5,0)\ndefaultTimeout :: ResponseTimeout\ndefaultTimeout = responseTimeoutMicro (1000 * 1000 * 60 * 5)\n#else\ndefaultTimeout :: Maybe Int\ndefaultTimeout = Just (1000 * 1000 * 60 * 5)\n#endif\n\nsplitHost :: String -> (String, String)\nsplitHost = break (== \'/\')\n\ndoRequest :: ApiStateC m => (L.ByteString -> Rest.Types.Error.Reason e) -> (L.ByteString -> a) -> ApiRequest -> m (ApiResponse e a)\ndoRequest a b = fmap (parseResult a b) . doReq\n\ndoReq :: ApiStateC m => ApiRequest -> m (Response L.ByteString)\ndoReq (ApiRequest m ur ps rhds bd) =\n  do mn  <- fmap manager askApiInfo\n     hst <- fmap apiHost askApiInfo\n     prt <- fmap apiPort askApiInfo\n     hds <- fmap headers askApiInfo\n     jar <- fmap cookies getApiState\n     let (h, p) = splitHost hst\n#if MIN_VERSION_http_client(0,5,0)\n         req = defaultRequest\n#else\n         req = def\n#endif\n                { HTTP.method = CH.pack m\n                , host = CH.pack h\n                , port = prt\n                , path = CH.pack (p ++ "/" ++ ur)\n                , queryString = (renderQuery False . simpleQueryToQuery . Prelude.map (CH.pack *** CH.pack)) ps\n                , HTTP.requestHeaders = rhds ++ Prelude.map (fromString *** CH.pack) hds\n                , HTTP.requestBody = RequestBodyLBS bd\n#if !MIN_VERSION_http_client(0,5,0)\n                , checkStatus = \\_ _ _ -> Nothing\n#endif\n                , redirectCount = 0\n                , responseTimeout = defaultTimeout\n                , cookieJar = Just jar\n                }\n     res <- httpLbs req mn\n     putApiState (ApiState (jar `mappend` responseCookieJar res))\n     return res\n\nparseResult :: (L.ByteString -> Reason e) -> (L.ByteString -> a) -> Response L.ByteString -> ApiResponse e a\nparseResult e c res = convertResponse $\n  case HTTP.statusCode (HTTP.responseStatus res) of\n    200 -> fmap (Right . c) res\n    _   -> fmap (Left . e) res\n\nfromJSON :: FromJSON a => L.ByteString -> a\nfromJSON v = (either err id . eitherDecodeV) v\n  where\n    err e = error (  "Error parsing JSON in api binding, this should not happen: got "\n                  ++ L.toString v\n                  ++ ", message: "\n                  ++ show e\n                  )\n\ntoJSON :: ToJSON a => a -> L.ByteString\ntoJSON = encode\n\ntoLbs :: String -> L.ByteString\ntoLbs = L.fromString\n\nclass XmlStringToType a where\n  fromXML :: L.ByteString -> a\n  toXML :: a -> L.ByteString\n\ninstance XmlStringToType String where\n  fromXML = L.toString\n  toXML = L.fromString\n\ninstance OVERLAPPABLE_ XmlPickler a => XmlStringToType a where\n  fromXML v = ( either err id\n              . P.eitherFromXML\n              . L.toString\n              ) v\n    where err = error ("Error parsing XML in api binding, this should not happen: " ++ L.toString v)\n  toXML = L.fromString . P.toXML\n\n\nmakeReq :: String -> String -> [[String]] -> [(String, String)] -> Network.HTTP.Types.Header.RequestHeaders -> L.ByteString -> ApiRequest\nmakeReq meth v ls = ApiRequest meth (intercalate "/" (v : map URI.encode (concat ls)))\n'