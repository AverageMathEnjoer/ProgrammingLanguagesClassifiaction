b'{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{- |\n   This module is an alternative version of "Control.Monad.Par" in\n   which the `Par` type provides `IO` operations, by means of `liftIO`.\n   The price paid is that only `runParIO` is available, not the pure `runPar`.\n\n   This module uses the same default scheduler as "Control.Monad.Par".\n -}\n\nmodule Control.Monad.Par.IO\n  ( ParIO, IVar, runParIO\n    -- And instances!               \n  )\n  where\n\nimport Control.Monad.Par.Scheds.Trace (Par, IVar)\nimport qualified Control.Monad.Par.Scheds.TraceInternal as Internal\n\nimport Control.Monad.Par.Class\nimport Control.Applicative\nimport Control.Monad.Trans (liftIO, MonadIO)\nimport Control.Monad.Fix (MonadFix)\n\n-- | A wrapper around an underlying Par type which allows IO.\nnewtype ParIO a = ParIO (Par a)\n  deriving (Functor, Applicative, Monad, ParFuture IVar, ParIVar IVar, MonadFix)\n\n-- | A run method which allows actual IO to occur on top of the Par\n--   monad.  Of course this means that all the normal problems of\n--   parallel IO computations are present, including nondeterminism.\n--\n--   A simple example program:\n--\n--   >  runParIO (liftIO $ putStrLn "hi" :: ParIO ())\nrunParIO :: ParIO a -> IO a\nrunParIO (ParIO p) = Internal.runParIO p\n\ninstance MonadIO ParIO where\n    liftIO io = ParIO (Internal.Par (Internal.LiftIO io))\n'