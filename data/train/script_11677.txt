b'# https://stackoverflow.com/questions/9439256/how-can-i-handle-r-cmd-check-no-visible-binding-for-global-variable-notes-when#comment20826625_12429344\n# 2012 hadley says "globalVariables is a hideous hack and I will never use it"\n# 2014 hadley updates his own answer with globalVariables as one of "two solutions"\nglobalVariables(c(\'year\', \'value\', \'Country.Name\', \'Country.Code\', \'Indicator.Name\', \'Indicator.Code\'))\n\n#\' WDI: World Development Indicators (World Bank)\n#\' \n#\' Downloads the requested data by using the World Bank\'s API, parses the\n#\' resulting XML file, and formats it in long country-year format. \n#\' \n#\' @param country Vector of countries (ISO-2 character codes, e.g. "BR", "US",\n#\'     "CA") for which the data is needed. Using the string "all" instead of\n#\'     individual iso codes pulls data for every available country.\n#\' @param indicator Character vector of indicators codes. See the WDIsearch()\n#\' function. If you supply a named vector, the indicators will be automatically\n#\' renamed: `c(\'women_private_sector\' = \'BI.PWK.PRVS.FE.ZS\')`\n#\' @param start Start date, usually a year in integer format. Must be 1960 or\n#\' greater.\n#\' @param end End date, usually a year in integer format. Must be greater than\n#\' the `start` argument. If `NULL`, the end date is set to 5 years in the future.\n#\' @param extra TRUE returns extra variables such as region, iso3c code, and\n#\'     incomeLevel. See Details.\n#\' @param cache NULL (optional) a list created by WDIcache() to be used with the extra=TRUE argument.\n#\' @param latest Integer indicating the number of most recent non-NA values to get. Default is NULL. If specified, it overrides the start and end dates.\n#\' @param language ISO-2 code in lower case indicating in which language the characters should be provided. List of languages available with `WDI::languages_supported()`. Default is English.\n#\'     \n#\'     \n#\' @details It is possible to only specify the `indicator` and the `country` arguments, in which case `WDI()` will return data from 1960 to the last year available on World Bank\'s website. It is also possible to get only the most recent non-NA values, with `latest`.\n#\' \n#\' If `extra = TRUE`, additional variables are provided:\n#\' \n#\' \\itemize{\n#\' \n#\' \\item{status: observation status, e.g is the observation a forecast?}\n#\' \\item{iso3c}\n#\' \\item{region}\n#\' \\item{capital: name of the capital city}\n#\' \\item{latitude, longitude}\n#\' \\item{income: income categories of the World Bank}\n#\' \\item{lending}\n#\' \n#\' }\n#\' \n#\' @return Data frame with country-year observations. You can extract a\n#\' data.frame with indicator names and descriptive labels by inspecting the\n#\' `label` attribute of the resulting data.frame: `attr(dat, \'label\')`\n#\' @author Vincent Arel-Bundock \\email{vincent.arel-bundock@umontreal.ca}\n#\' @export\n#\'\n#\' @examples\n#\'\n#\' \\dontrun{\n#\'\n#\' WDI(country="all", indicator=c("AG.AGR.TRAC.NO","TM.TAX.TCOM.BC.ZS"),\n#\'     start=1990, end=2000)\n#\' WDI(country=c("US","BR"), indicator="NY.GNS.ICTR.GN.ZS", start=1999, end=2000,\n#\'     extra=TRUE, cache=NULL)\n#\'\n#\' # Rename indicators on the fly\n#\' WDI(country = \'CA\', indicator = c(\'women_private_sector\' = \'BI.PWK.PRVS.FE.ZS\',\n#\'                                   \'women_public_sector\' = \'BI.PWK.PUBS.FE.ZS\'))\n#\'                                   \n#\' # Get the 5 latest non-NA values\n#\' WDI(country=c("US","BR"), indicator="NY.GNS.ICTR.GN.ZS", latest = 5)\n#\' }\n#\'\nWDI <- function(country = "all",\n                indicator = "NY.GDP.PCAP.KD",\n                start = 1960,\n                end = NULL,\n                extra = FALSE,\n                cache = NULL,\n                latest = NULL,\n                language = "en") {\n\n\n\n    # Sanity: country\n    if (!is.character(country)) {\n        stop(\'The `country` argument must be a character vector\')\n    }\n\n    country <- gsub(\'[^a-zA-Z0-9]\', \'\', country)\n    country_good <- unique(c(WDI::WDI_data$country[,\'iso3c\'], \n                             WDI::WDI_data$country[,\'iso2c\']))\n    country_good <- c(\'all\', country_good)\n    country_bad <- base::setdiff(country, country_good)\n    country <- base::intersect(country, country_good)\n\n    if (length(country) == 0) {\n        stop(\'None of the countries requested are valid. Please use ISO-2, ISO-3, or World Bank regional codes.\')\n    }\n    if (length(country_bad) > 0) {\n        warning(\'Please use ISO-2, ISO-3, or World Bank regional codes. Some of the country codes that you requested are invalid: \',  \n                paste(country_bad, collapse = \', \'))\n    }\n\n    # Sanity: start & end\n    is_integer <- function(x) is.numeric(x) && (x %% 1 == 0)\n    \n    if (is.null(end)) {\n        end <- as.integer(format(Sys.Date(), format = "%Y")) + 5\n    }\n\n    # If latest is specified then the good order of dates doesn\'t matter\n    if (!is.null(start) && !is.null(end) && is.null(latest)) {\n        if (!(start <= end)) {\n            stop("`end` must be equal to or greater than `start`.")\n        }\n        if (is_integer(start) && (start < 1960)) {\n            stop("`start` must be equal to or greater than 1960")\n        }\n    }\n    \n    # Sanity: needs dates or number of most recent values (but not both)\n    if (is.null(start) && is.null(end) && is.null(latest)) {\n      stop("Need to specify dates or number of latest values.")\n    }\n    \n    \n    # "Language" option (placed here and not in wdi.query because\n    # otherwise tryCatch doesn\'t show the expected error message)\n    # get the two first letters (iso code)\n    supported_fully <- substr(languages_supported()$fully, \n                              start = 1, \n                              stop = 2)\n    supported_locally <- substr(languages_supported()$locally, \n                                start = 1, \n                                stop = 2)\n    if (is.null(language)) {\n      language <- "en"\n    } else {\n      if (language %in% supported_locally) {\n        warning("This language is only supported partially.")\n      } else if (!(language %in% supported_locally ||  \n                   language %in% supported_fully)) {\n        stop(paste0("This language is not supported. Run ",\n                    "WDI::languages_supported() to have a list of ",\n                    "fully and partially supported languages."))\n      }\n    }\n    \n\n    # Download\n    dat <- list()\n    failed <- NULL\n\n    for (i in indicator) {\n        tmp <- tryCatch(wdi.dl(i, country, start, end, latest, language, extra), error = function(e) e)\n        if (is.null(tmp) || !inherits(tmp$data, \'data.frame\') || (nrow(tmp$data) == 0)) {\n            failed <- c(failed, i)\n        } else {\n            dat[[i]] <- tmp\n        }\n    }\n\n    # Sanity: downloaded data\n    if (length(failed) > 0) {\n\n        msg <- sprintf(\n\'The following indicators could not be downloaded: %s.\n\nPlease make sure that you are running the latest version of the `WDI` package, and that the arguments you are using in the `WDI()` function are valid.\n\nSometimes, downloads will suddenly stop working, even if nothing has changed in the R code of the WDI package. ("The same WDI package version worked yesterday!") In those cases, the problem is almost certainly related to the World Bank servers or to your internet connection.\n\nYou can check if the World Bank web API is currently serving the indicator(s) of interest by typing a URL of this form in your web browser:\n\n%s\',\npaste(failed, collapse = ", "),\nwdi.query(indicator = failed[1])[1])\n\n        if (length(failed) == length(indicator)) {\n            stop(msg)\n        } else if (length(failed) > 0) {\n            warning(msg)\n        }\n    }\n\n    # Extract labels\n    lab <- sapply(names(dat), function(x) attr(dat[[x]][["data"]], "label")[1])\n\n    # Extract data\n    dat = lapply(dat, function(x) x$data)\n    dat = Reduce(function(x,y) merge(x,y,all=TRUE), dat)\n    row.names(dat) <- NULL\n\n    # Extras\n    if(!is.null(cache)){\n        country_data = cache$country\n    }else{\n        country_data = WDI::WDI_data$country\n    }\n    if(extra==TRUE){\n\t    dat = merge(dat, country_data, all.x=TRUE)\n    }\n    countries = country[country != \'all\' & !(country %in% dat$iso2c)]\n    if(length(countries) > 0){\n    }\n\n    # Assign label attributes\n    for (n in names(lab)) {\n        attr(dat[[n]], "label") <- lab[[n]]\n    }\n\n\t# Rename columns based on indicator vector names\n\tif (!is.null(names(indicator))) {\n\t\tfor (i in seq_along(indicator)) {\n\t\t\tidx = match(indicator[i], colnames(dat))\n\t\t\tif (!is.na(idx)) {\n\t\t\t\tcolnames(dat)[idx] = names(indicator)[i]\n\t\t\t}\n\t\t}\n\t}\n\n\t# Output\n  return(dat)\n}\n\n#\' Download all the WDI indicators at once.\n#\' \n#\' @return Data frame \n#\' @author Vincent Arel-Bundock \\email{vincent.arel-bundock@umontreal.ca}\n#\' @param timeout integer maximum number of seconds to wait for download\n#\' @return a list of 6 data frames: Data, Country, Series, Country-Series,\n#\' Series-Time, FootNote\n#\' @export\nWDIbulk = function(timeout = 600) {\n\n    # store default option\n    oo <- options(timeout = timeout)\n\n    if (!\'tidyr\' %in% utils::installed.packages()[, 1]) {\n        stop(\'To use the `WDIbulk` function, you must install the `tidyr` package.\')\n    }\n\n    # download\n    temp_dir = tempdir()\n    temp_file = tempfile(tmpdir = temp_dir)\n    url = \'https://databank.worldbank.org/data/download/WDI_csv.zip\'\n    utils::download.file(url, temp_file)\n\n    # read\n    unzipped <- utils::unzip(zipfile = temp_file,\n                             exdir = temp_dir)\n\n    out = lapply(unzipped, function(x){\n        utils::read.csv(x, stringsAsFactors = FALSE)\n    })\n\n    # flush\n    unlink(temp_file)\n\n    # names\n    names(out) = c("Data", "Country", "Series",\n                   "Country-Series", "Series-Time",\n                   "FootNote")\n\n    # clean "Data" entry\n    out$Data$X = NULL\n\n    out$Data = tidyr::pivot_longer(\n        data = out$Data,\n        cols = tidyr::starts_with("X"),\n        names_to = "year",\n        names_prefix = "X",\n        values_to = "value"\n    )\n\n    # clean year column\n    out$Data$year = as.integer(out$Data$year)\n\n    # restore default option\n    on.exit(options(oo))\n\n    # output\n    return(out)\n}\n\n#\' Internal function to build API call\n#\'\n#\' @export\n#\' @keywords internal\nwdi.query = function(indicator = "NY.GDP.PCAP.CD", \n                     country = \'all\', \n                     start = NULL, \n                     end = NULL,\n                     latest = NULL,\n                     language = "en") {\n\n    country <- paste(country, collapse = \';\')\n\n    \n    # If latest is specified, dates are overridden\n    if (!is.null(latest)) {\n      latest <- paste0("&mrnev=", latest)\n      years <- NULL\n    } else {\n      years <- paste0("&date=", start, ":", end)\n    }\n    \n    # WDI only allows 32500 per_page (this seems undocumented)\n    out = paste0("https://api.worldbank.org/v2/",\n                 language, \n                 "/country/", \n                 country, "/indicator/", indicator,\n                 "?format=json",\n                 years,\n                 "&per_page=32500",\n                 "&page=", 1:10,\n                 latest)\n    return(out)\n}\n\n#\' Internal function to download data\n#\'\n#\' @export\n#\' @keywords internal\nwdi.dl = function(indicator, country, start, end, latest = NULL, language = "en", extra = FALSE){\n    get_page <- function(daturl) {\n        dat_new <- jsonlite::fromJSON(daturl)\n        meta <- dat_new[[1]]\n        dat <- dat_new[[2]]\n        dat2 <- data.frame(\n            country = dat[["country"]][["value"]],\n            iso2c = dat[["country"]][["id"]],\n            iso3c = dat[["countryiso3code"]],\n            year = dat[["date"]],\n            indicator = dat[["value"]],\n            stringsAsFactors = FALSE)\n        \n        # issue #54\n        if (any(unique(nchar(dat2$iso2c)) == 3)) {\n          dat2$iso3c <- dat2$iso2c\n          dat2$iso2c <- NULL\n        }\n        colnames(dat2)[colnames(dat2) == "indicator"] <- indicator\n        if (isTRUE(extra) && nrow(dat2) > 0 && "obs_status" %in% colnames(dat)) {\n            dat2[["status"]] <- dat[["obs_status"]]\n            dat2[["status"]] <- ifelse(dat2[["status"]] == "F", "forecast", dat2[["status"]])\n        }\n        dat <- dat2\n\n        # output\n        attr(dat, "lastupdated") <- tryCatch(meta[["lastupdated"]], error = function(e) NULL)\n        attr(dat, "label") <- dat_new[[2]]$indicator$value\n        return(dat)\n    }\n\n    pages <- wdi.query(indicator, country, start, end, latest, language)\n    lab <- attr(pages[[1]], "label")\n\n    dat <- list()\n    done <- FALSE # done when pages no longer return useable info\n    for (i in seq_along(pages)) {\n            tmp <- tryCatch(get_page(pages[i]), error = function(e) NULL)\n        if (!done) {\n            if (inherits(tmp, \'data.frame\') && (nrow(tmp) > 0)) {\n                dat[[i]] <- tmp\n            } else {\n                done <- TRUE\n            }\n        }\n    }\n    lastupdated <- attr(dat[[1]], "lastupdated")\n\n    dat <- do.call(\'rbind\', dat)\n\n    # numeric types\n    dat[[indicator]] <- as.numeric(dat[[indicator]])\n\n    # date is character for monthly/quarterly data, numeric otherwise\n    if (is.factor(dat$year)) {\n        dat$year <- as.character(dat$year)\n    }\n    if (is.character(dat$year) && !any(grepl(\'M|Q\', dat$year))) {\n        dat$year <- as.integer(dat$year)\n    }\n\n    # Bad data in WDI JSON files require me to impose this constraint\n    if (!is.null(start) && !is.null(end)) {\n      dat = dat[!is.na(dat$year) & dat$year <= end & dat$year >= start,] \n    }\n\n    # output\n    out <- list(\n        \'data\' = dat,\n        \'indicator\' = indicator,\n        \'label\' = lab)\n\n    out$data$label <- NULL\n\n    # updated column\n    if (isTRUE(extra) && !is.null(lastupdated)) {\n      out[["data"]][["lastupdated"]] <- lastupdated\n    }\n\n    return(out)\n}\n\n#\' Update the list of available WDI indicators\n#\'\n#\' Download an updated list of available WDI indicators from the World Bank website. Returns a list for use in the \\code{WDIsearch} function. \n#\' \n#\' @return Series of indicators, sources and descriptions in two lists list  \n#\' @note Downloading all series information from the World Bank website can take time.\n#\' The \\code{WDI} package ships with a local data object with information on all the series\n#\' available on 2012-06-18. You can update this database by retrieving a new list using \\code{WDIcache}, and  then\n#\' feeding the resulting object to \\code{WDIsearch} via the \\code{cache} argument. \n#\' @export\nWDIcache = function(){\n    # Series\n    series_url = \'https://api.worldbank.org/v2/indicator?per_page=25000&format=json\'\n    series_dat <- jsonlite::fromJSON(series_url)[[2]]\n    series_dat <- data.frame(\n        indicator = series_dat$id,\n        name = series_dat$name,\n        description = series_dat$sourceNote,\n        sourceDatabase = series_dat$source$value,\n        sourceOrganization = series_dat$sourceOrganization,\n        stringsAsFactors = FALSE)\n\n    # Countries\n    country_url = \'https://api.worldbank.org/v2/countries/all?per_page=25000&format=json\'\n    country_dat <- jsonlite::fromJSON(country_url)[[2]]\n    country_dat <- data.frame(\n        iso3c = country_dat$id,\n        iso2c = country_dat$iso2Code,\n        country = country_dat$name,\n        region = trimws(country_dat$region$value),\n        capital = country_dat$capitalCity,\n        longitude = country_dat$longitude,\n        latitude = country_dat$latitude,\n        income = country_dat$incomeLevel$value,\n        lending = country_dat$lendingType$value,\n        stringsAsFactors = FALSE)\n\n    out = list(\'series\'=series_dat, \'country\'=country_dat)\n    # out$series = iconv(out$series, to = \'utf8\')\n    # out$country = iconv(out$country, to = \'utf8\')\n    return(out)\n}\n\n#\' Search names and descriptions of available WDI series\n#\' \n#\' Data frame with series code, name, description, and source for the WDI series\n#\' which match the given criteria\n#\' \n#\' @param string Character string. Search for this string using \\code{grep} with\n#\'     \\code{ignore.case=TRUE}.\n#\' @param field Character string. Search this field. Admissible fields:\n#\'     \'indicator\', \'name\', \'description\', \'sourceDatabase\', \'sourceOrganization\'\n#\' @param short TRUE: Returns only the indicator\'s code and name. FALSE: Returns\n#\'     the indicator\'s code, name, description, and source.\n#\' @param cache Data list generated by the \\code{WDIcache} function. If omitted,\n#\'     \\code{WDIsearch} will search a local list of series.  \n#\' @return Data frame with code, name, source, and description of all series which\n#\'     match the criteria.  \n#\' @export\n#\' @examples\n#\' \\dontrun{\n#\' WDIsearch(string=\'gdp\', field=\'name\', cache=NULL)\n#\' WDIsearch(string=\'AG.AGR.TRAC.NO\', field=\'indicator\', cache=NULL)\n#\' }\nWDIsearch <- function(string="gdp", field="name", short=TRUE, cache=NULL){\n    if(!is.null(cache)){ \n        series = cache$series    \n    }else{\n        series = WDI::WDI_data$series\n    }\n    matches = grep(string, series[, field], ignore.case=TRUE)\n    if(short){\n        out = series[matches, c(\'indicator\', \'name\')]\n    }else{\n        out = series[matches,]\n    }\n    return(out)\n}\n\n\n#\' List of supported languages\n#\' \n#\' This prints two lists of languages, the fully supported ones and the locally supported ones:\n#\' * the languages in the category "fully" will return translated names and other info for all countries.\n#\' * the languages in the category "partially" will return translated names and other info only for the country they represent. \n#\' \n#\' For example, choosing "vi" (for Vietnamese) will translate "Vietnam" in the dataset but other country names won\'t be translated and will be empty.\n#\'\n#\'\n#\' @return A list of fully and partially supported languages.\n#\' @export\nlanguages_supported <- function() {\n  \n    fully <- c("en (English)", "es (Spanish)", "fr (French)", \n               "ar (Arabic)", "zh (Chinese)")\n    locally <- c("bg (Bulgarian)", "de (German)", "hi (Hindi)", \n                 "id (Indonesian)", "ja (Japanese)", "km (Khmer)", \n                 "ko (Korean)", "mk (Macedonian)", "mn (Mongolian)",\n                 "pl (Polish)", "pt (Portuguese)", "ro (Romanian)",\n                 "ru (Russian)", "sq (Albanian)", "th (Thai)", "tr (Turkish)",\n                 "uk (Ukrainian)", "vi (Vietnamese)")\n    \n    list(\n      fully = fully,\n      locally = locally\n    )\n    \n}\n'