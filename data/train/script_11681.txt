b'-- Time-stamp: <2009-05-06 13:55:20 simonmar>\n-----------------------------------------------------------------------------\n\nmodule Prog(prog,randomBoard,solve,solveNested) where\n\nimport Board\nimport Wins\nimport Game\nimport Tree\nimport System.Random\nimport Data.List\n\n-- First arg decaffeinates game\nprog :: Int -> String\nprog decaf = showMove (head game)\n\t       --"OXO\\n" ++\n\t       --concat (map showMove game)\n\t       where\n\t       game = if decaf == 0 \n\t                then error "Decaffination error\\n"\n\t\t\telse alternate decaf X maxE minE testBoard\n\n-- X to play: find the best move\nsolve :: Int -> Board -> String\nsolve depth board\n  = unlines\n  . map showMove\n  . take 1\n  . alternate depth X maxE minE $ board\n\nsolveNested :: Int -> Board -> String\nsolveNested depth board\n  = unlines\n  . map showMove\n  . take 1\n  . alternateNested depth X maxE minE $ board\n\ntestBoard = [[Empty,O,Empty,Empty],[Empty,X,Empty,Empty],[Empty,Empty,Empty,Empty],[Empty,Empty,Empty,Empty]]\n\nrandomBoard :: Int -> IO Board\nrandomBoard moves =  do\n  g <- newStdGen\n  let (g1,g2) = split g\n      xs = randomRs (1,boardDim) g1\n      ys = randomRs (1,boardDim) g2\n\n  let\n    play 0 _ _ board = board\n    play n (pos:poss) (p:ps) board\n     | not (empty pos board) = play n poss (p:ps) board\n     | otherwise             = play (n-1) poss ps (placePiece p board pos)\n\n  return $ play moves (zip xs ys) (cycle [X,O]) initialBoard\n\n'