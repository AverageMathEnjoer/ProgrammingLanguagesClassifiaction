b'{-# LANGUAGE ScopedTypeVariables #-}\n-- |\n-- Copyright  : (c) Ivan Perez, 2019-2022\n--              (c) Ivan Perez and Manuel Baerenz, 2016-2018\n-- License    : BSD3\n-- Maintainer : ivan.perez@keera.co.uk\n--\n-- A ListSF is a signal function that produces additional information about\n-- spawning and discarding SFs.\n--\n-- Each ListSF produces, apart from the normal output signal, two additional\n-- outputs:\n-- - A boolean signal indicating if it\'s still alive or not.\n-- - A list of new SFs that have spawned at that point.\nmodule FRP.BearRiver.List\n    ( ListSF (..)\n    , dlSwitch\n    )\n  where\n\n-- Internal imports (dunai)\nimport Data.MonadicStreamFunction.InternalCore (MSF (MSF, unMSF))\n\n-- Internal imports\nimport FRP.BearRiver (SF)\n\n-- | Signal function that produces additional information about spawning and\n-- discarding SFs.\nnewtype ListSF m a b = ListSF { listSF :: SF m a (b, Bool, [ ListSF m a b ]) }\n\n-- | Turn a list of ListSFs into a signal function that concatenates all the\n-- outputs produced by each inner ListSF, at each point, and spawns and\n-- discards ListSFs as indicated by themselves.\ndlSwitch :: Monad m\n         => [ ListSF m a b ] -> SF m a [b]\ndlSwitch = dlSwitch\' . map listSF\n\n-- | Turn a list of SFs that produce ListSFs into a signal function that\n-- concatenates all the outputs produced by each inner ListSF, at each point,\n-- and spawns and discards ListSFs as indicated by the SFs themselves.\ndlSwitch\' :: forall m a b\n          .  Monad m\n          => [ SF m a (b, Bool, [ ListSF m a b ]) ] -> SF m a [b]\ndlSwitch\' sfs = MSF $ \\a -> do\n\n  -- Results of applying the initial input to all the SFs inside the ListSF\n  --\n  -- The outputs contain the output values (bs) and the continuations (sfs),\n  -- and are labeled 0 for the initial time step.\n  bsfs0 <- mapM (\\sf -> unMSF sf a) sfs\n\n  -- Gather outputs produced by the SFs\n  let bs = fmap (\\((b, _dead, _newSFs), _) -> b) bsfs0\n\n  -- Gather old continuations produced by the SF, filtering those that\n  -- have not died.\n  let notDead = filter (\\((_b, dead, _newSFs), _contSF) -> not dead) bsfs0\n\n      oldSFs :: [ SF m a (b, Bool, [ListSF m a b]) ]\n      oldSFs = map (\\((_b, _dead, _newSFs), contSF) -> contSF) notDead\n\n  -- Gather new SFs produced in this step. According to the Yampa\n  -- implementation, the new SFs are initialized (i.e., they are ran with the\n  -- current input to obtain the continuations. This is not strictly necessary\n  -- in bearriver, but the semantics will differ if we do not do it.\n  let contListSFs = concatMap (\\((_b, _dead, newSFs), _contSF) -> newSFs) bsfs0\n      contSFs     = map listSF contListSFs\n\n  -- Run the new SFs (listSFs) with the current input to "initialize" them. We\n  -- use snd to keep only the continuation and discard the output.\n  newSFs <- fmap snd <$> mapM (\\sf -> unMSF sf a) contSFs\n\n  -- Only here to indicate the type of newSFs.\n  let constraintNSFs :: [ SF m a (b, Bool, [ListSF m a b]) ]\n      constraintNSFs = newSFs\n\n  -- Put old and new continuation together for future steps\n  let cts :: [ SF m a (b, Bool, [ListSF m a b]) ]\n      cts = oldSFs ++ newSFs\n\n  return (bs, dlSwitch\' cts)\n'