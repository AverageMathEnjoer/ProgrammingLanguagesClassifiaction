b'{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{-# LANGUAGE FlexibleContexts #-}\n\nimport Control.Monad.Reader\nimport Control.Monad.State\n\nimport Data.List (sortBy)\nimport Data.Ord (comparing)\n\n{- \xd0\xa1\xd0\xbf\xd0\xb8\xd1\x81\xd0\xbe\xd0\xba \xd0\xb4\xd0\xb5\xd0\xbb \xd0\xb8\xd0\xb7 TODO-\xd1\x81\xd0\xbf\xd0\xb8\xd1\x81\xd0\xba\xd0\xb0:\n   * \xd0\x95\xd1\x81\xd1\x82\xd1\x8c \xd1\x81\xd0\xbf\xd0\xb8\xd1\x81\xd0\xbe\xd0\xba \xd0\xb4\xd0\xb5\xd0\xbb, \xd0\xba\xd0\xbe\xd1\x82\xd0\xbe\xd1\x80\xd1\x8b\xd0\xb5 \xd0\xbd\xd0\xb0\xd0\xb4\xd0\xbe \xd1\x81\xd0\xb4\xd0\xb5\xd0\xbb\xd0\xb0\xd1\x82\xd1\x8c\n     \xd0\xad\xd0\xbb\xd0\xb5\xd0\xbc\xd0\xb5\xd0\xbd\xd1\x82 \xd1\x81\xd0\xbf\xd0\xb8\xd1\x81\xd0\xba\xd0\xb0: \xd0\xbd\xd0\xb0\xd0\xb7\xd0\xb2\xd0\xb0\xd0\xbd\xd0\xb8\xd0\xb5 \xd0\xb8 \xd1\x87\xd0\xb5\xd1\x80\xd0\xb5\xd0\xb7 \xd1\x81\xd0\xba\xd0\xbe\xd0\xbb\xd1\x8c\xd0\xba\xd0\xbe \xd0\xb4\xd0\xbd\xd0\xb5\xd0\xb9 \xd0\xb4\xd0\xb5\xd0\xb4\xd0\xbb\xd0\xb0\xd0\xb9\xd0\xbd\n   * \xd0\x9c\xd1\x8b \xd1\x85\xd0\xbe\xd1\x82\xd0\xb8\xd0\xbc \xd1\x81\xd1\x87\xd0\xb8\xd1\x82\xd0\xb0\xd1\x82\xd1\x8c \xd0\xb8\xd0\xb7 \xd0\xba\xd0\xbe\xd0\xbd\xd1\x81\xd0\xbe\xd0\xbb\xd0\xb8 \xd1\x87\xd0\xb8\xd1\x81\xd0\xbb\xd0\xbe n: \xd1\x81\xd0\xba\xd0\xbe\xd0\xbb\xd1\x8c\xd0\xba\xd0\xbe \xd0\xb4\xd0\xb5\xd0\xbb \xd0\xbc\xd1\x8b \xd0\xbc\xd0\xbe\xd0\xb6\xd0\xb5\xd0\xbc \xd0\xb2\xd1\x8b\xd0\xbf\xd0\xbe\xd0\xbb\xd0\xbd\xd0\xb8\xd1\x82\xd1\x8c\n   * \xd0\x98 \xd0\xb2\xd1\x8b\xd0\xb2\xd0\xb5\xd1\x81\xd1\x82\xd0\xb8 \xd0\xb2 \xd0\xba\xd0\xbe\xd0\xbd\xd1\x81\xd0\xbe\xd0\xbb\xd1\x8c \xd1\x81\xd0\xba\xd0\xbe\xd0\xbb\xd1\x8c\xd0\xba\xd0\xbe \xd0\xb4\xd0\xbd\xd0\xb5\xd0\xb9 \xd1\x83 \xd0\xbd\xd0\xb0\xd1\x81 \xd0\xb5\xd1\x81\xd1\x82\xd1\x8c \xd0\xb4\xd0\xbe \xd0\xbf\xd0\xbe\xd1\x81\xd0\xbb\xd0\xb5\xd0\xb4\xd0\xbd\xd0\xb5\xd0\xb3\xd0\xbe \xd0\xb4\xd0\xb5\xd0\xb4\xd0\xbb\xd0\xb0\xd0\xb9\xd0\xbd\xd0\xb0\n   * \xd0\xa1\xd0\xb4\xd0\xb5\xd0\xbb\xd0\xb0\xd1\x82\xd1\x8c \xd0\xbf\xd0\xb5\xd1\x80\xd0\xb2\xd0\xbe\xd0\xb5 \xd0\xb4\xd0\xb5\xd0\xbb\xd0\xbe\n-}\n\ndata TodoItem = TodoItem\n     { todoTitle :: String\n     , todoDeadline :: Int } -- \xd1\x81\xd0\xba\xd0\xbe\xd0\xbb\xd1\x8c\xd0\xba\xd0\xbe \xd0\xb4\xd0\xbd\xd0\xb5\xd0\xb9 \xd0\xbe\xd1\x81\xd1\x82\xd0\xb0\xd0\xbb\xd0\xbe\xd1\x81\xd1\x8c \xd0\xb4\xd0\xbe \xd0\xb4\xd0\xb5\xd0\xb4\xd0\xbb\xd0\xb0\xd0\xb9\xd0\xbd\xd0\xb0\n     deriving (Show)\n\ndata DoneItem = DoneItem\n     { doneTodoItem :: TodoItem\n     , spentDays :: Int }\n     deriving (Show)\n\n{- \xd0\xad\xd1\x84\xd1\x84\xd0\xb5\xd0\xba\xd1\x82\xd1\x8b:\n\n   1. \xd0\x9d\xd0\xb5\xd0\xb8\xd0\xb7\xd0\xbc\xd0\xb5\xd0\xbd\xd1\x8f\xd0\xb5\xd0\xbc\xd1\x8b\xd0\xb9 \xd0\xba\xd0\xbe\xd0\xbd\xd1\x82\xd0\xb5\xd0\xba\xd1\x81\xd1\x82: \xd0\xa1\xd0\xbf\xd0\xb8\xd1\x81\xd0\xbe\xd0\xba TodoItem\n      ReaderT [TodoItem] m a\n\n   2. \xd0\xa0\xd0\xb5\xd0\xb0\xd0\xbb\xd1\x8c\xd0\xbd\xd1\x8b\xd0\xb9 \xd0\xbc\xd0\xb8\xd1\x80 (\xd0\xba\xd0\xbe\xd0\xbd\xd1\x81\xd0\xbe\xd0\xbb\xd1\x8c)\n      IO a\n\n   3. \xd0\xa1\xd0\xbf\xd0\xb8\xd1\x81\xd0\xbe\xd0\xba \xd1\x81\xd0\xb4\xd0\xb5\xd0\xbb\xd0\xb0\xd0\xbd\xd0\xbd\xd1\x8b\xd1\x85 \xd0\xb4\xd0\xb5\xd0\xbb\n      StateT [DoneItem] m a\n\n   [ Needs [TodoItem], Updates [DoneItem], CONSOLE ]\n-}\n\n\nlowestTodos :: Int -> [TodoItem] -> [TodoItem]\nlowestTodos n = take n . sortBy (comparing todoDeadline)\n\nlastDeadline :: [TodoItem] -> Maybe Int\nlastDeadline [] = Nothing\nlastDeadline l  = Just $ maximum $ map todoDeadline l\n\ntopUrgent :: MonadReader [TodoItem] m \n          => Int \n          -> m (Maybe Int)\ntopUrgent n = asks (lastDeadline . lowestTodos n)\n\ndoMostUrgent :: ( MonadReader [TodoItem] m\n                , MonadState  [DoneItem] m\n                )\n             => m ()\ndoMostUrgent = do\n    mostUrgentTask <- asks (head . lowestTodos 1)\n    modify (DoneItem mostUrgentTask 1:)\n\nread\'n\'PrintNumber :: ( MonadReader [TodoItem] m\n                      , MonadState  [DoneItem] m\n                      , MonadIO                m\n                      )\n                   => m ()\nread\'n\'PrintNumber = do\n    n <- liftIO readLn\n    maybeDeadline <- topUrgent n\n    case maybeDeadline of\n        Nothing -> liftIO $ putStrLn "No tasks to do :("\n        Just d  -> do\n            liftIO $ putStrLn $ "Max deadline after: " ++ show d\n\n            doMostUrgent\n            done <- get\n            liftIO $ print done\n\nnewtype TodoCtx m a = TodoCtx \n    { runTodoCtx :: ReaderT [TodoItem] (StateT [DoneItem] m) a }\n    deriving (Functor, Applicative, Monad, MonadIO,\n              MonadReader [TodoItem], MonadState [DoneItem])\n\ninstance MonadTrans TodoCtx where\n    lift = TodoCtx . lift . lift\n\ndoTodo :: Monad m => [TodoItem] -> TodoCtx m a -> m a\ndoTodo items ctx = evalStateT (runReaderT (runTodoCtx ctx) items) []\n\nmain :: IO ()\nmain = do\n    let todos = [TodoItem "First" 3, TodoItem "Snd" 2, TodoItem "A" 5]\n    doTodo todos read\'n\'PrintNumber\n\n\n\n\n\n'