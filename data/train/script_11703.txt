b'{-# LANGUAGE BangPatterns #-}\n{-# LANGUAGE CPP          #-}\n{-# OPTIONS_GHC -fno-warn-orphans #-}\n\nmodule Main (main) where\n\nimport Test.ChasingBottoms.IsBottom\nimport Test.Tasty (TestTree, TestName, defaultMain, testGroup)\nimport Test.Tasty.HUnit\nimport Test.Tasty.QuickCheck (testProperty, Arbitrary(arbitrary), Fun)\n#if __GLASGOW_HASKELL__ >= 806\nimport Test.Tasty.QuickCheck (Property)\n#endif\nimport Test.QuickCheck.Function (apply)\n\nimport Data.Map.Strict (Map)\nimport qualified Data.Map.Strict as M\nimport qualified Data.Map as L\n\nimport Utils.IsUnit\n#if __GLASGOW_HASKELL__ >= 806\nimport Utils.NoThunks\n#endif\n\ninstance (Arbitrary k, Arbitrary v, Ord k) =>\n         Arbitrary (Map k v) where\n    arbitrary = M.fromList `fmap` arbitrary\n\napply2 :: Fun (a, b) c -> a -> b -> c\napply2 f a b = apply f (a, b)\n\napply3 :: Fun (a, b, c) d -> a -> b -> c -> d\napply3 f a b c = apply f (a, b, c)\n\n------------------------------------------------------------------------\n-- * Properties\n\n------------------------------------------------------------------------\n-- ** Strict module\n\npSingletonKeyStrict :: Int -> Bool\npSingletonKeyStrict v = isBottom $ M.singleton (bottom :: Int) v\n\npSingletonValueStrict :: Int -> Bool\npSingletonValueStrict k = isBottom $ (M.singleton k (bottom :: Int))\n\npFindWithDefaultKeyStrict :: Int -> Map Int Int -> Bool\npFindWithDefaultKeyStrict def m = isBottom $ M.findWithDefault def bottom m\n\npFindWithDefaultValueStrict :: Int -> Map Int Int -> Bool\npFindWithDefaultValueStrict k m =\n    M.member k m || (isBottom $ M.findWithDefault bottom k m)\n\npAdjustKeyStrict :: Fun Int Int -> Map Int Int -> Bool\npAdjustKeyStrict f m = isBottom $ M.adjust (apply f) bottom m\n\npAdjustValueStrict :: Int -> Map Int Int -> Bool\npAdjustValueStrict k m\n    | k `M.member` m = isBottom $ M.adjust (const bottom) k m\n    | otherwise       = case M.keys m of\n        []     -> True\n        (k\':_) -> isBottom $ M.adjust (const bottom) k\' m\n\npInsertKeyStrict :: Int -> Map Int Int -> Bool\npInsertKeyStrict v m = isBottom $ M.insert bottom v m\n\npInsertValueStrict :: Int -> Map Int Int -> Bool\npInsertValueStrict k m = isBottom $ M.insert k bottom m\n\npInsertWithKeyStrict :: Fun (Int, Int) Int -> Int -> Map Int Int -> Bool\npInsertWithKeyStrict f v m = isBottom $ M.insertWith (apply2 f) bottom v m\n\npInsertWithValueStrict :: Fun (Int, Int) Int -> Int -> Int -> Map Int Int\n                       -> Bool\npInsertWithValueStrict f k v m\n    | M.member k m = (isBottom $ M.insertWith (const2 bottom) k v m) &&\n                     not (isBottom $ M.insertWith (const2 1) k bottom m)\n    | otherwise    = isBottom $ M.insertWith (apply2 f) k bottom m\n\npInsertLookupWithKeyKeyStrict :: Fun (Int, Int, Int) Int -> Int\n                              -> Map Int Int -> Bool\npInsertLookupWithKeyKeyStrict f v m = isBottom $ M.insertLookupWithKey (apply3 f) bottom v m\n\npInsertLookupWithKeyValueStrict :: Fun (Int, Int, Int) Int -> Int -> Int\n                                -> Map Int Int -> Bool\npInsertLookupWithKeyValueStrict f k v m\n    | M.member k m = (isBottom $ M.insertLookupWithKey (const3 bottom) k v m) &&\n                     not (isBottom $ M.insertLookupWithKey (const3 1) k bottom m)\n    | otherwise    = isBottom $ M.insertLookupWithKey (apply3 f) k bottom m\n\n#if __GLASGOW_HASKELL__ >= 806\npStrictFoldr\' :: Map Int Int -> Property\npStrictFoldr\' m = whnfHasNoThunks (M.foldr\' (:) [] m)\n#endif\n\n#if __GLASGOW_HASKELL__ >= 806\npStrictFoldl\' :: Map Int Int -> Property\npStrictFoldl\' m = whnfHasNoThunks (M.foldl\' (flip (:)) [] m)\n#endif\n\n#if __GLASGOW_HASKELL__ >= 806\npStrictFoldrWithKey\' :: Map Int Int -> Property\npStrictFoldrWithKey\' m = whnfHasNoThunks (M.foldrWithKey\' (\\_ a as -> a : as) [] m)\n#endif\n\n#if __GLASGOW_HASKELL__ >= 806\npStrictFoldlWithKey\' :: Map Int Int -> Property\npStrictFoldlWithKey\' m = whnfHasNoThunks (M.foldlWithKey\' (\\as _ a -> a : as) [] m)\n#endif\n\n------------------------------------------------------------------------\n-- check for extra thunks\n--\n-- These tests distinguish between `()`, a fully evaluated value, and\n-- things like `id ()` which are extra thunks that should be avoided\n-- in most cases. An exception is `L.fromListWith const`, which cannot\n-- evaluate the `const` calls.\n\ntExtraThunksM :: TestTree\ntExtraThunksM = testGroup "Map.Strict - extra thunks" $\n    if not isUnitSupported then [] else\n    -- for strict maps, all the values should be evaluated to ()\n    [ check "singleton"           $ m0\n    , check "insert"              $ M.insert 42 () m0\n    , check "insertWith"          $ M.insertWith const 42 () m0\n    , check "fromList"            $ M.fromList [(42,()),(42,())]\n    , check "fromListWith"        $ M.fromListWith const [(42,()),(42,())]\n    , check "fromAscList"         $ M.fromAscList [(42,()),(42,())]\n    , check "fromAscListWith"     $ M.fromAscListWith const [(42,()),(42,())]\n    , check "fromDistinctAscList" $ M.fromAscList [(42,())]\n    ]\n  where\n    m0 = M.singleton 42 ()\n    check :: TestName -> M.Map Int () -> TestTree\n    check n m = testCase n $ case M.lookup 42 m of\n        Just v -> assertBool msg (isUnit v)\n        _      -> assertBool "key not found" False\n      where\n        msg = "too lazy -- expected fully evaluated ()"\n\ntExtraThunksL :: TestTree\ntExtraThunksL = testGroup "Map.Lazy - extra thunks" $\n    if not isUnitSupported then [] else\n    -- for lazy maps, the *With functions should leave `const () ()` thunks,\n    -- but the other functions should produce fully evaluated ().\n    [ check "singleton"       True  $ m0\n    , check "insert"          True  $ L.insert 42 () m0\n    , check "insertWith"      False $ L.insertWith const 42 () m0\n    , check "fromList"        True  $ L.fromList [(42,()),(42,())]\n    , check "fromListWith"    False $ L.fromListWith const [(42,()),(42,())]\n    , check "fromAscList"     True  $ L.fromAscList [(42,()),(42,())]\n    , check "fromAscListWith" False $ L.fromAscListWith const [(42,()),(42,())]\n    , check "fromDistinctAscList" True $ L.fromAscList [(42,())]\n    ]\n  where\n    m0 = L.singleton 42 ()\n    check :: TestName -> Bool -> L.Map Int () -> TestTree\n    check n e m = testCase n $ case L.lookup 42 m of\n        Just v -> assertBool msg (e == isUnit v)\n        _      -> assertBool "key not found" False\n      where\n        msg | e         = "too lazy -- expected fully evaluated ()"\n            | otherwise = "too strict -- expected a thunk"\n\n------------------------------------------------------------------------\n-- * Test list\n\ntests :: [TestTree]\ntests =\n    [\n    -- Basic interface\n      testGroup "Map.Strict"\n      [ testProperty "singleton is key-strict" pSingletonKeyStrict\n      , testProperty "singleton is value-strict" pSingletonValueStrict\n      , testProperty "member is key-strict" $ keyStrict M.member\n      , testProperty "lookup is key-strict" $ keyStrict M.lookup\n      , testProperty "findWithDefault is key-strict" pFindWithDefaultKeyStrict\n      , testProperty "findWithDefault is value-strict" pFindWithDefaultValueStrict\n      , testProperty "! is key-strict" $ keyStrict (flip (M.!))\n      , testProperty "delete is key-strict" $ keyStrict M.delete\n      , testProperty "adjust is key-strict" pAdjustKeyStrict\n      , testProperty "adjust is value-strict" pAdjustValueStrict\n      , testProperty "insert is key-strict" pInsertKeyStrict\n      , testProperty "insert is value-strict" pInsertValueStrict\n      , testProperty "insertWith is key-strict" pInsertWithKeyStrict\n      , testProperty "insertWith is value-strict" pInsertWithValueStrict\n      , testProperty "insertLookupWithKey is key-strict"\n        pInsertLookupWithKeyKeyStrict\n      , testProperty "insertLookupWithKey is value-strict"\n        pInsertLookupWithKeyValueStrict\n#if __GLASGOW_HASKELL__ >= 806\n      , testProperty "strict foldr\'" pStrictFoldr\'\n      , testProperty "strict foldl\'" pStrictFoldl\'\n      , testProperty "strict foldrWithKey\'" pStrictFoldrWithKey\'\n      , testProperty "strict foldlWithKey\'" pStrictFoldlWithKey\'\n#endif\n      ]\n      , tExtraThunksM\n      , tExtraThunksL\n    ]\n\n------------------------------------------------------------------------\n-- * Test harness\n\nmain :: IO ()\nmain = defaultMain $ testGroup "map-strictness" tests\n\n------------------------------------------------------------------------\n-- * Utilities\n\nkeyStrict :: (Int -> Map Int Int -> a) -> Map Int Int -> Bool\nkeyStrict f m = isBottom $ f bottom m\n\nconst2 :: a -> b -> c -> a\nconst2 x _ _ = x\n\nconst3 :: a -> b -> c -> d -> a\nconst3 x _ _ _ = x\n\n'