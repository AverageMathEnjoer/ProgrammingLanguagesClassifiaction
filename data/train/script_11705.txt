b'module Timeouts where\n\nimport Test.Tasty\nimport Test.Tasty.Runners\nimport Test.Tasty.HUnit\nimport Control.Concurrent\nimport Utils\n\n-- this is a dummy tree we use for testing\ntestTree :: TestTree\ntestTree =\n  localOption (mkTimeout $ 2 * ds) $\n  testGroup "timeout test"\n    [ testCase "fast" $ threadDelay ds\n    , testCase "slow" $ threadDelay (3 * ds)\n    , testCase "infinite loop" $ do -- see #280\n        let x :: Int; x = x\n        [1, 2, 3, x] @?= [3, 2, 1]\n    ]\n  where\n    ds :: Integral a => a\n    ds = 10^5\n\ntestTimeouts :: TestTree\ntestTimeouts = testCase "Timeouts" $ do\n  launchTestTree mempty testTree $ \\smap -> do\n    [fast, slow, inf_loop] <- runSMap smap\n    case fast of\n      Result { resultOutcome = Success } -> return ()\n      _ -> assertFailure $ "Fast test failed: " ++ resultDescription fast\n\n    assertTimeoutFailure "slow" slow\n    assertTimeoutFailure "infinite loop" inf_loop\n\n    return $ const $ return ()\n\nassertTimeoutFailure :: TestName -> Result -> Assertion\nassertTimeoutFailure name r =\n  case r of\n    Result { resultOutcome = Success } -> assertFailure $ "Test " ++ name ++ " passed"\n    Result { resultOutcome = Failure (TestTimedOut _) } -> return ()\n    _ -> assertFailure $ "Test " ++ name ++\n      " failed for the wrong reason: " ++ resultDescription r\n'