b'module Main where\n\nimport Control.Applicative\nimport Control.DeepSeq (rnf)\nimport Control.Exception (evaluate)\nimport Control.Monad.Trans.State.Strict\nimport Test.Tasty.Bench (bench, bgroup, defaultMain, nf)\nimport Data.Foldable (foldl\', foldr\')\nimport qualified Data.Sequence as S\nimport qualified Data.Foldable\nimport Data.Traversable (traverse, sequenceA)\nimport System.Random (mkStdGen, randoms)\n\nmain = do\n    let s10 = S.fromList [1..10] :: S.Seq Int\n        s100 = S.fromList [1..100] :: S.Seq Int\n        s1000 = S.fromList [1..1000] :: S.Seq Int\n        s10000 = S.fromList [1..10000] :: S.Seq Int\n    evaluate $ rnf [s10, s100, s1000, s10000]\n    let g = mkStdGen 1\n    let rlist n = map (`mod` (n+1)) (take 10000 (randoms g)) :: [Int]\n        r10 = rlist 10\n        r100 = rlist 100\n        r1000 = rlist 1000\n        r10000 = rlist 10000\n    evaluate $ rnf [r10, r100, r1000, r10000]\n    let rs10 = S.fromList r10\n        rs100 = S.fromList r100\n        rs1000 = S.fromList r1000\n        rs10000 = S.fromList r10000\n    evaluate $ rnf [rs10, rs100, rs1000, rs10000]\n    let u10 = S.replicate 10 () :: S.Seq ()\n        u100 = S.replicate 100 () :: S.Seq ()\n        u1000 = S.replicate 1000 () :: S.Seq ()\n        u10000 = S.replicate 10000 () :: S.Seq ()\n    evaluate $ rnf [u10, u100, u1000, u10000]\n    defaultMain\n      [ bgroup "splitAt/append"\n         [ bench "10" $ nf (shuffle r10) s10\n         , bench "100" $ nf (shuffle r100) s100\n         , bench "1000" $ nf (shuffle r1000) s1000\n         ]\n      , bgroup "fromList"\n         [ bench "10" $ nf S.fromList [(0 :: Int)..9]\n         , bench "100" $ nf S.fromList [(0 :: Int)..99]\n         , bench "1000" $ nf S.fromList [(0 :: Int)..999]\n         , bench "10000" $ nf S.fromList [(0 :: Int)..9999]\n         , bench "100000" $ nf S.fromList [(0 :: Int)..99999]\n         ]\n      , bgroup "partition"\n         [ bench "10" $ nf (S.partition even) s10\n         , bench "100" $ nf (S.partition even) s100\n         , bench "1000" $ nf (S.partition even) s1000\n         , bench "10000" $ nf (S.partition even) s10000\n         ]\n      , bgroup "foldl\'"\n         [ bench "10" $ nf (foldl\' (+) 0) s10\n         , bench "100" $ nf (foldl\' (+) 0) s100\n         , bench "1000" $ nf (foldl\' (+) 0) s1000\n         , bench "10000" $ nf (foldl\' (+) 0) s10000\n         ]\n      , bgroup "foldr\'"\n         [ bench "10" $ nf (foldr\' (+) 0) s10\n         , bench "100" $ nf (foldr\' (+) 0) s100\n         , bench "1000" $ nf (foldr\' (+) 0) s1000\n         , bench "10000" $ nf (foldr\' (+) 0) s10000\n         ]\n      , bgroup "update"\n         [ bench "10" $ nf (updatePoints r10 10) s10\n         , bench "100" $ nf (updatePoints r100 10) s100\n         , bench "1000" $ nf (updatePoints r1000 10) s1000\n         ]\n      , bgroup "adjust"\n         [ bench "10" $ nf (adjustPoints r10 (+10)) s10\n         , bench "100" $ nf (adjustPoints r100 (+10)) s100\n         , bench "1000" $ nf (adjustPoints r1000 (+10)) s1000\n         ]\n      , bgroup "deleteAt"\n         [ bench "10" $ nf (deleteAtPoints r10) s10\n         , bench "100" $ nf (deleteAtPoints r100) s100\n         , bench "1000" $ nf (deleteAtPoints r1000) s1000\n         ]\n      , bgroup "insertAt"\n         [ bench "10" $ nf (insertAtPoints r10 10) s10\n         , bench "100" $ nf (insertAtPoints r100 10) s100\n         , bench "1000" $ nf (insertAtPoints r1000 10) s1000\n         ]\n      , bgroup "traverseWithIndex/State"\n         [ bench "10" $ nf multiplyDown s10\n         , bench "100" $ nf multiplyDown s100\n         , bench "1000" $ nf multiplyDown s1000\n         ]\n      , bgroup "sequenceA.mapWithIndex/State"\n         [ bench "10" $ nf multiplyDownMap s10\n         , bench "100" $ nf multiplyDownMap s100\n         , bench "1000" $ nf multiplyDownMap s1000\n         ]\n      , bgroup "traverse/State"\n         [ bench "10" $ nf multiplyUp s10\n         , bench "100" $ nf multiplyUp s100\n         , bench "1000" $ nf multiplyUp s1000\n         ]\n      , bgroup "replicateA/State"\n         [ bench "10" $ nf stateReplicate 10\n         , bench "100" $ nf stateReplicate 100\n         , bench "1000" $ nf stateReplicate 1000\n         ]\n      , bgroup "zip"\n         [ bench "ix10000/5000" $ nf (\\(xs,ys) -> S.zip xs ys `S.index` 5000) (s10000, u10000)\n         , bench "nf100" $ nf (uncurry S.zip) (s100, u100)\n         , bench "nf10000" $ nf (uncurry S.zip) (s10000, u10000)\n         ]\n      , bgroup "fromFunction"\n         [ bench "ix10000/5000" $ nf (\\s -> S.fromFunction s (+1) `S.index` (s `div` 2)) 10000\n         , bench "nf10" $ nf (\\s -> S.fromFunction s (+1)) 10\n         , bench "nf100" $ nf (\\s -> S.fromFunction s (+1)) 100\n         , bench "nf1000" $ nf (\\s -> S.fromFunction s (+1)) 1000\n         , bench "nf10000" $ nf (\\s -> S.fromFunction s (+1)) 10000\n         ]\n      , bgroup "<*>"\n         [ bench "ix500/1000^2" $\n              nf (\\s -> ((+) <$> s <*> s) `S.index` (S.length s `div` 2)) (S.fromFunction 1000 (+1))\n         , bench "ix500000/1000^2" $\n              nf (\\s -> ((+) <$> s <*> s) `S.index` (S.length s * S.length s `div` 2)) (S.fromFunction 1000 (+1))\n         , bench "ixBIG" $\n              nf (\\s -> ((+) <$> s <*> s) `S.index` (S.length s * S.length s `div` 2))\n                 (S.fromFunction (floor (sqrt $ fromIntegral (maxBound::Int))-10) (+1))\n         , bench "nf100/2500/rep" $\n              nf (\\(s,t) -> (,) <$> S.replicate s () <*> S.replicate t ()) (100,2500)\n         , bench "nf100/2500/ff" $\n              nf (\\(s,t) -> (,) <$> S.fromFunction s (+1) <*> S.fromFunction t (*2)) (100,2500)\n         , bench "nf500/500/rep" $\n              nf (\\(s,t) -> (,) <$> S.replicate s () <*> S.replicate t ()) (500,500)\n         , bench "nf500/500/ff" $\n              nf (\\(s,t) -> (,) <$> S.fromFunction s (+1) <*> S.fromFunction t (*2)) (500,500)\n         , bench "nf2500/100/rep" $\n              nf (\\(s,t) -> (,) <$> S.replicate s () <*> S.replicate t ()) (2500,100)\n         , bench "nf2500/100/ff" $\n              nf (\\(s,t) -> (,) <$> S.fromFunction s (+1) <*> S.fromFunction t (*2)) (2500,100)\n         ]\n      , bgroup "sort"\n         [ bgroup "already sorted"\n            [ bench "10" $ nf S.sort s10\n            , bench "100" $ nf S.sort s100\n            , bench "1000" $ nf S.sort s1000\n            , bench "10000" $ nf S.sort s10000]\n         , bgroup "random"\n            [ bench "10" $ nf S.sort rs10\n            , bench "100" $ nf S.sort rs100\n            , bench "1000" $ nf S.sort rs1000\n            , bench "10000" $ nf S.sort rs10000]\n         ]\n      , bgroup "unstableSort"\n         [ bgroup "already sorted"\n            [ bench "10" $ nf S.unstableSort s10\n            , bench "100" $ nf S.unstableSort s100\n            , bench "1000" $ nf S.unstableSort s1000\n            , bench "10000" $ nf S.unstableSort s10000]\n         , bgroup "random"\n            [ bench "10" $ nf S.unstableSort rs10\n            , bench "100" $ nf S.unstableSort rs100\n            , bench "1000" $ nf S.unstableSort rs1000\n            , bench "10000" $ nf S.unstableSort rs10000]\n         ]\n      , bgroup "unstableSortOn"\n         [ bgroup "already sorted"\n            [ bench "10"    $ nf (S.unstableSortOn id) s10\n            , bench "100"   $ nf (S.unstableSortOn id) s100\n            , bench "1000"  $ nf (S.unstableSortOn id) s1000\n            , bench "10000" $ nf (S.unstableSortOn id) s10000]\n         , bgroup "random"\n            [ bench "10"    $ nf (S.unstableSortOn id) rs10\n            , bench "100"   $ nf (S.unstableSortOn id) rs100\n            , bench "1000"  $ nf (S.unstableSortOn id) rs1000\n            , bench "10000" $ nf (S.unstableSortOn id) rs10000]\n         ]\n      ]\n\n{-\n-- This is around 4.6 times as slow as insertAt\nfakeInsertAt :: Int -> a -> S.Seq a -> S.Seq a\nfakeInsertAt i x xs = case S.splitAt i xs of\n  (before, after) -> before S.>< x S.<| after\n-}\n\nadjustPoints :: [Int] -> (a -> a) -> S.Seq a -> S.Seq a\nadjustPoints points f xs =\n  foldl\' (\\acc k -> S.adjust f k acc) xs points\n\ninsertAtPoints :: [Int] -> a -> S.Seq a -> S.Seq a\ninsertAtPoints points x xs =\n  foldl\' (\\acc k -> S.insertAt k x acc) xs points\n\nupdatePoints :: [Int] -> a -> S.Seq a -> S.Seq a\nupdatePoints points x xs =\n  foldl\' (\\acc k -> S.update k x acc) xs points\n\n{-\n-- For comparison. Using the old implementation of update,\n-- which this simulates, can cause thunks to build up in the leaves.\nfakeupdatePoints :: [Int] -> a -> S.Seq a -> S.Seq a\nfakeupdatePoints points x xs =\n  foldl\' (\\acc k -> S.adjust (const x) k acc) xs points\n-}\n\ndeleteAtPoints :: [Int] -> S.Seq a -> S.Seq a\ndeleteAtPoints points xs =\n  foldl\' (\\acc k -> S.deleteAt k acc) xs points\n\n{-\nfakedeleteAtPoints :: [Int] -> S.Seq a -> S.Seq a\nfakedeleteAtPoints points xs =\n  foldl\' (\\acc k -> fakeDeleteAt k acc) xs points\n-- For comparison with deleteAt. deleteAt is several\n-- times faster for long sequences.\nfakeDeleteAt :: Int -> S.Seq a -> S.Seq a\nfakeDeleteAt i xs\n  | 0 < i && i < S.length xs = case S.splitAt i xs of\n                               (before, after) -> before S.>< S.drop 1 after\n  | otherwise = xs\n-}\n\n-- splitAt+append: repeatedly cut the sequence at a random point\n-- and rejoin the pieces in the opposite order.\n-- Finally getting the middle element forces the whole spine.\nshuffle :: [Int] -> S.Seq Int -> Int\nshuffle ps s = case S.viewl (S.drop (S.length s `div` 2) (foldl\' cut s ps)) of\n    x S.:< _ -> x\n  where cut xs p = let (front, back) = S.splitAt p xs in back S.>< front\n\nstateReplicate :: Int -> S.Seq Char\nstateReplicate n = flip evalState 0 . S.replicateA n $ do\n  old <- get\n  if old > (10 :: Int) then put 0 else put (old + 1)\n  return $ toEnum old\n\nmultiplyUp :: S.Seq Int -> S.Seq Int\nmultiplyUp = flip evalState 0 . traverse go where\n  go x = do\n    s <- get\n    put (s + 1)\n    return (s * x)\n\nmultiplyDown :: S.Seq Int -> S.Seq Int\nmultiplyDown = flip evalState 0 . S.traverseWithIndex go where\n  go i x = do\n    s <- get\n    put (s - 1)\n    return (s * i * x)\n\nmultiplyDownMap :: S.Seq Int -> S.Seq Int\nmultiplyDownMap = flip evalState 0 . sequenceA . S.mapWithIndex go where\n  go i x = do\n    s <- get\n    put (s - 1)\n    return (s * i * x)\n'