b'{-# LANGUAGE BangPatterns #-}\nmodule Main where\n\nimport Control.DeepSeq (rnf)\nimport Control.Exception (evaluate)\nimport Test.Tasty.Bench (bench, defaultMain, nf)\nimport Data.List (foldl\')\nimport qualified Data.IntMap as M\nimport qualified LookupGE_IntMap as M\nimport Data.Maybe (fromMaybe)\nimport Prelude hiding (lookup)\n\nmain :: IO ()\nmain = do\n    evaluate $ rnf [m_even, m_odd, m_large]\n    defaultMain [b f | b <- benches, f <- funs1]\n  where\n    m_even = M.fromAscList elems_even :: M.IntMap Int\n    m_odd  = M.fromAscList elems_odd :: M.IntMap Int\n    m_large = M.fromAscList elems_large :: M.IntMap Int\n    bound = 2^12\n    elems_even  = zip evens evens\n    elems_odd   = zip odds odds\n    elems_large = zip large large\n    evens = [2,4..bound]\n    odds  = [1,3..bound]\n    large = [1,100..50*bound]\n    benches =\n          [ \\(n,fun) -> bench (n++" present")  $ nf (fge fun evens) m_even\n          , \\(n,fun) -> bench (n++" absent")   $ nf (fge fun evens) m_odd\n          , \\(n,fun) -> bench (n++" far")      $ nf (fge fun odds)  m_large\n          , \\(n,fun) -> bench (n++" !present") $ nf (fge2 fun evens) m_even\n          , \\(n,fun) -> bench (n++" !absent")  $ nf (fge2 fun evens) m_odd\n          , \\(n,fun) -> bench (n++" !far")     $ nf (fge2 fun odds)  m_large\n          ]\n    funs1 = [ ("GE split", M.lookupGE1)\n            , ("GE Craig", M.lookupGE2)\n            , ("GE Twan", M.lookupGE3)\n            , ("GE Milan", M.lookupGE4) ]\n\nfge :: (Int -> M.IntMap Int -> Maybe (Int,Int)) -> [Int] -> M.IntMap Int -> (Int,Int)\nfge fun xs m = foldl\' (\\n k -> fromMaybe n (fun k m)) (0,0) xs\n\n-- forcing values inside tuples!\nfge2 :: (Int -> M.IntMap Int -> Maybe (Int,Int)) -> [Int] -> M.IntMap Int -> (Int,Int)\nfge2 fun xs m = foldl\' (\\n@(!_, !_) k -> fromMaybe n (fun k m)) (0,0) xs\n\n'