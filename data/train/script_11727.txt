b'//https://www.codechef.com/OCT16/problems/POWSUMS\n//linear recurrence -> https://discuss.codechef.com/questions/49614/linear-recurrence-using-cayley-hamilton-theorem\n\n#include <bits/stdc++.h>\nusing namespace std;\n#define gc getchar_unlocked\n#define fo(i,n) for(i=0;i<n;i++)\n#define Fo(i,k,n) for(i=k;k<n?i<n:i>n;k<n?i+=1:i-=1)\n#define ll long long\n#define si(x)\tscanf("%d",&x)\n#define sl(x)\tscanf("%lld",&x)\n#define ss(s)\tscanf("%s",s)\n#define pi(x)\tprintf("%d\\n",x)\n#define pl(x)\tprintf("%lld\\n",x)\n#define ps(s)\tprintf("%s\\n",s)\n#define pb push_back\n#define mp make_pair\n#define F first\n#define S second\n#define all(x) x.begin(), x.end()\n#define clr(x) memset(x, 0, sizeof(x))\n#define sortall(x) sort(all(x))\n#define tr(it, a) for(auto it = a.begin(); it != a.end(); it++)\n#define PI 3.1415926535897932384626\ntypedef pair<int, int>\tpii;\ntypedef pair<ll, ll>\tpl;\ntypedef vector<int>\t\tvi;\ntypedef vector<ll>\t\tvl;\ntypedef vector<pii>\t\tvpii;\ntypedef vector<pl>\t\tvpl;\ntypedef vector<vi>\t\tvvi;\ntypedef vector<vl>\t\tvvl;\nconst int mod = 1e9+7;\nconst int N = 315;\nvi g[N];\nint n;\nll p[N], e[N], a[N];\nll tem[N][N], hold[N][N];\n//BEGINS\nconst int MOD = 1e9 + 7;\nconst long long MOD2 = static_cast<long long>(MOD) * MOD;\nconst int MAX_K = 50;\nvector<vl> C;\nvector<vl> M;\nll A[N*2];\nstruct coef\n{\n    vl  mat;\n    int  n_cols;\n\n    coef() {}\n\n    coef(vl values): mat(values), n_cols(values.size()){}\n    \n    static coef identity_coef(int n){\n        vl res(n, 0);\n        res[0] = 1;\n        return coef(res);\n    }\n    coef operator*(const coef &other) const\n    {\n        int n = other.n_cols, i, j;\n        fo(i, 2*n) A[i] = 0;\n        fo(i, n)\n        fo(j, n){\n            ll &ans = A[i+j];\n            ans += (mat[i] * other.mat[j])%mod;\n            if (ans < 0) ans += mod;\n            if (ans >= mod) ans -= mod;\n        }\n        vl res(n, 0);\n        fo(i, n) {\n            res[i] += A[i];\n            if (res[i] < 0) res[i] += mod;\n            if (res[i] >= mod) res[i] -= mod;\n        }\n        Fo(i, n, 2*n-1){\n            ll mul = A[i];\n            if (mul){\n                fo(j, n){\n                    res[j] += (mul*C[i][j])%mod;\n                    if (res[j] < 0) res[j] += mod;\n                    if (res[j] >= mod) res[j] -= mod;\n                }\n            }\n        }\n        return coef(res);\n    }\n};\n\n// M_powers[i] is M, raised to 2^i-th power\ncoef M_powers[67];\n\nvoid precalc_powers()\n{\n    M_powers[0] = coef(C[1]);\n    for(int i = 1; i < 67; i++)\n        M_powers[i] = M_powers[i - 1] * M_powers[i - 1];\n}\n\ncoef mat_pow(ll power)\n{\n    coef result = coef::identity_coef(M_powers[0].mat.size());\n    int pointer = 0;\n    while(power) {\n        if(power & 1)\n            result = result * M_powers[pointer];\n        pointer++;\n        power >>= 1;\n    }\n    return result;\n}\n\n\n\n//ENDS\nint mpow(int base, int exp) {\n\tbase %= mod;\n\tint result = 1;\n\twhile (exp > 0) {\n\tif (exp & 1) result = ((ll)result * base) % mod;\n\tbase = ((ll)base * base) % mod;\n\texp >>= 1;\n\t}\n\treturn result;\n}\n\nint main()\n{\n\tios_base::sync_with_stdio(false);\n\tcin.tie(NULL);\n\tint i,k,j,q;\n\tll val,x ;\n\tint sign;\n\tint t;\n\tcin>>t;\n\twhile(t--){\n\t\te[0] = 1;\n\t\tcin>>n>>q;\n\t\t// fo(i, n) cin>>a[i];\n\t\tfo(i, n) cin>>p[i+1];\n\t\te[1] = p[1];\n\t\tFo(i, 2, n+1){\n\t\t\t val = 0;\n\t\t\t sign = 1;\n\t\t\tFo(j, 1, i+1){\n\t\t\t\tval += (sign*p[j]*e[i-j])%mod;\n\t\t\t\tif (val < 0) val += mod;\n\t\t\t\tif (val >= mod) val -= mod;\n\t\t\t\tsign *= -1;\n\t\t\t}\n\t\t\tval *= mpow(i, mod-2);\n\t\t\tval %= mod;\n\t\t\te[i] = val;\n\t\t}\n\t\tM.resize(n, vl(n, 0));\n\t\tC.resize(2*n-1, vl(n, 0));\n\t\t//build matrix\n\t\tsign = 1;\n\t\t//construct 1st row of M\n\t\tM[0][0] = 1;\n\t\tfo(i, n)\n\t\t\t// M[1][i] = a[i];\n\t\t\tM[1][i] = sign*e[i+1], sign *= -1;\n        //construct rows of M^2, M^3, .. M^{n-1}\n\t\tFo(i, 2, n){\n            fo(j, n){\n                //M[i][j] = ?\n                int pre = 0;\n                if(j!=n-1) pre = M[i-1][j+1];\n                ll &ans = M[i][j];\n                ans = (M[i-1][0]*M[1][j] + pre)%mod;\n                if (ans < 0) ans += mod;\n            }\n\t\t}\n\t\t//find coefficients of M^i as C[i][0...n-1]  M^i = sum(C[i][j]*M^j)\n\t\t//i from [0, n)\n\t\tfo(i, n) fo(j, n) C[i][j] = 0;\n\t\tfo(i, n) C[i][i] = 1;\n\t\t//set for M^n -> use characteristic\n\t\tfo(i, n)\n            C[n][n-1-i] = (mod+M[1][i])%mod;\n\t\t\n\t\t//i from [n+1, 2n-2]\n\t\tFo(i, n+1, 2*n-1){\n            C[i][0] = (C[i-1][n-1]*C[n][0])%mod;\n            if(C[i][0] < 0) C[i][0] += mod;\n            Fo(j, 1, n){\n                ll &ans = C[i][j];\n                ans = (C[i-1][n-1]*C[n][j] + C[i-1][j-1])%mod;\n                if (ans < 0) ans += mod;\n            }\n\t\t}\n\t\t\n\t\t//matrix M(mat);\n\t\tprecalc_powers();\n\t\t//answer queries\n\t\tll mx = 0;\n\t\twhile(q--) {\n\t\t\tcin>>x;\n\t\t\tx -= n;\n\t\t\t\n\t\t\t//mat^x\n\t\t\t// fo(i, n) fo(j, n) M[i][j] = mat[i][j];\n\t\t\tcoef res = mat_pow(x);\n\t\t\t// fo(i, n) cout<<res.mat[n-1-i]<<" ";\n\t\t\t// cout<<endl;\n\t\t\tval = 0;\n\t\t\tfo(i, n) A[i] = 0;\n\t\t\tfo(i, n){\n\t\t\t    ll mul = res.mat[i];\n\t\t\t    if (mul){\n                    fo(j, n){\n                        A[j] += (M[i][j]*mul)%mod;\n                        if (A[j] >= mod) A[j] -= mod;\n                        if (A[j] < 0) A[j] += mod;\n                    }\n\t\t\t    }\n\t\t\t}\n\t\t\t//A[i] * p[n-i]\n\t\t\tfo(i, n) {\n                val += (A[i]*p[n-i])%mod;\n                if (val >= mod) val -= mod;\n                if (val < 0) val += mod;\n\t\t\t}\n\t\t\tcout<<val<<" ";\n\t\t}\n\t\tfo(i, n+1) e[i] = 0;\n\t\tcout<<endl;\n\t}\n\n\treturn 0;\n}\n\n'