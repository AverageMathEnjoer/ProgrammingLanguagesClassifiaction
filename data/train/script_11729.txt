b'{-# LANGUAGE CPP #-}\n{-# LANGUAGE LambdaCase #-}\n{-# OPTIONS_GHC -fno-warn-incomplete-uni-patterns #-}\n\nmodule Hoodle.Coroutine.Dialog where\n\nimport Control.Lens (view)\nimport Control.Monad (unless)\nimport Control.Monad.IO.Class (liftIO)\nimport Control.Monad.Loops (whileM_)\nimport Control.Monad.State (get)\nimport qualified Data.Foldable as F\nimport Data.Functor ((<&>))\nimport qualified Data.Text as T\nimport qualified Graphics.UI.Gtk as Gtk\nimport Hoodle.Coroutine.Draw\n  ( invalidateInBBox,\n    nextevent,\n    waitSomeEvent,\n  )\nimport qualified Hoodle.Script.Coroutine as S\nimport Hoodle.Type.Coroutine (MainCoroutine, doIOaction)\nimport Hoodle.Type.Enum (DrawFlag (Efficient))\nimport Hoodle.Type.Event\n  ( AllEvent (UsrEv),\n    UserEvent\n      ( FileChosen,\n        GotOk,\n        Keyword,\n        OkCancel,\n        TextInput,\n        UpdateCanvas\n      ),\n  )\nimport Hoodle.Type.HoodleState (rootOfRootWindow)\nimport System.Directory (getCurrentDirectory)\n\n-- |\nokMessageBox :: String -> MainCoroutine ()\nokMessageBox msg = action >> waitSomeEvent (\\case GotOk -> True; _ -> False) >> return ()\n  where\n    action = doIOaction $\n      \\_evhandler -> do\n        dialog <-\n          Gtk.messageDialogNew\n            Nothing\n            [Gtk.DialogModal]\n            Gtk.MessageQuestion\n            Gtk.ButtonsOk\n            msg\n        _res <- Gtk.dialogRun dialog\n        Gtk.widgetDestroy dialog\n        return (UsrEv GotOk)\n\n-- |\nokCancelMessageBox :: String -> MainCoroutine Bool\nokCancelMessageBox msg = (action >> waitSomeEvent p) <&> q\n  where\n    p (OkCancel _) = True\n    p _ = False\n    q (OkCancel b) = b\n    q _ = False\n    action = doIOaction $\n      \\_evhandler -> do\n        dialog <-\n          Gtk.messageDialogNew\n            Nothing\n            [Gtk.DialogModal]\n            Gtk.MessageQuestion\n            Gtk.ButtonsOkCancel\n            msg\n        res <- Gtk.dialogRun dialog\n        let b = case res of\n              Gtk.ResponseOk -> True\n              _ -> False\n        Gtk.widgetDestroy dialog\n        return (UsrEv (OkCancel b))\n\n-- | single line text input : almost abandoned now\ntextInputDialog :: String -> MainCoroutine (Maybe String)\ntextInputDialog msg = do\n  doIOaction $ \\_evhandler -> do\n    dialog <-\n      Gtk.messageDialogNew\n        Nothing\n        [Gtk.DialogModal]\n        Gtk.MessageQuestion\n        Gtk.ButtonsOkCancel\n        msg\n    vbox <- fmap Gtk.castToContainer (Gtk.dialogGetContentArea dialog)\n    txtvw <- Gtk.textViewNew\n    Gtk.containerAdd vbox txtvw\n    Gtk.widgetShowAll dialog\n    res <- Gtk.dialogRun dialog\n    case res of\n      Gtk.ResponseOk -> do\n        buf <- Gtk.textViewGetBuffer txtvw\n        (istart, iend) <-\n          (,) <$> Gtk.textBufferGetStartIter buf\n            <*> Gtk.textBufferGetEndIter buf\n        l <- Gtk.textBufferGetText buf istart iend True\n        Gtk.widgetDestroy dialog\n        return (UsrEv (TextInput (Just l)))\n      _ -> do\n        Gtk.widgetDestroy dialog\n        return (UsrEv (TextInput Nothing))\n  TextInput input <- waitSomeEvent (\\case TextInput _ -> True; _ -> False)\n  return input\n\n-- |\nkeywordDialog :: [T.Text] -> MainCoroutine (Maybe T.Text)\nkeywordDialog keylst = do\n  doIOaction (keywordDialog\' keylst)\n  keywordLoop\n\n-- |\nkeywordDialog\' :: [T.Text] -> (AllEvent -> IO ()) -> IO AllEvent\nkeywordDialog\' keys _evhandler = do\n  dialog <- Gtk.dialogNew\n  upper <- fmap Gtk.castToContainer (Gtk.dialogGetContentArea dialog)\n  vbox <- Gtk.vBoxNew False 0\n  Gtk.containerAdd upper vbox\n  hbox <- Gtk.hBoxNew False 0\n  Gtk.boxPackStart vbox hbox Gtk.PackNatural 0\n  _btnOk <- Gtk.dialogAddButton dialog ("Ok" :: String) Gtk.ResponseOk\n  _btnCancel <- Gtk.dialogAddButton dialog ("Cancel" :: String) Gtk.ResponseCancel\n  cbx <- Gtk.comboBoxNewText\n  klst <- mapM (Gtk.comboBoxAppendText cbx) keys\n  unless (null klst) $\n    Gtk.comboBoxSetActive cbx (head klst)\n  Gtk.boxPackStart hbox cbx Gtk.PackGrow 2\n  Gtk.widgetShowAll dialog\n  res <- Gtk.dialogRun dialog\n  Gtk.widgetDestroy dialog\n  case res of\n    Gtk.ResponseOk -> do\n      keystr <- Gtk.comboBoxGetActiveText cbx\n      (return . UsrEv . Keyword) keystr\n    Gtk.ResponseCancel -> return (UsrEv (Keyword Nothing))\n    _ -> return (UsrEv (Keyword Nothing))\n\n-- | main event loop for keyword dialog\nkeywordLoop :: MainCoroutine (Maybe T.Text)\nkeywordLoop = waitSomeEvent (\\case Keyword _ -> True; _ -> False) >>= \\(Keyword x) -> return x\n\n-- |\nlongTextMessageBox :: String -> MainCoroutine ()\nlongTextMessageBox msg =\n  action\n    >> waitSomeEvent (\\case GotOk -> True; _ -> False)\n    >> return ()\n  where\n    action = doIOaction $\n      \\_evhandler -> do\n        dialog <- Gtk.dialogNew\n        upper <- fmap Gtk.castToContainer (Gtk.dialogGetContentArea dialog)\n        vbox <- Gtk.vBoxNew False 0\n        Gtk.containerAdd upper vbox\n        hbox <- Gtk.hBoxNew False 0\n        txtbuf <- Gtk.textBufferNew Nothing\n        Gtk.textBufferSetText txtbuf msg\n        txtview <- Gtk.textViewNewWithBuffer txtbuf\n        vadj <- Gtk.textViewGetVadjustment txtview\n        vscr <- Gtk.vScrollbarNew vadj\n        Gtk.widgetSetSizeRequest txtview 400 700\n        Gtk.boxPackEnd hbox vscr Gtk.PackNatural 0\n        Gtk.boxPackStart hbox txtview Gtk.PackGrow 0\n        Gtk.boxPackStart vbox hbox Gtk.PackGrow 0\n        _btnOk <- Gtk.dialogAddButton dialog ("Ok" :: String) Gtk.ResponseOk\n        Gtk.widgetShowAll dialog\n        _res <- Gtk.dialogRun dialog\n        Gtk.widgetDestroy dialog\n        return (UsrEv GotOk)\n\n-- |\nfileChooser :: Gtk.FileChooserAction -> Maybe String -> MainCoroutine (Maybe FilePath)\nfileChooser choosertyp mfname = do\n  mrecentfolder <- S.recentFolderHook\n  xst <- get\n  let rtrwin = view rootOfRootWindow xst\n  liftIO $ Gtk.widgetQueueDraw rtrwin\n  doIOaction (action rtrwin mrecentfolder) >> go\n  where\n    go = do\n      r <- nextevent\n      case r of\n        FileChosen b -> return b\n        UpdateCanvas cid ->\n          -- this is temporary\n          invalidateInBBox Nothing Efficient cid >> go\n        _ -> go\n    action win mrf _evhandler = do\n      dialog <-\n        Gtk.fileChooserDialogNew\n          Nothing\n          (Just win)\n          choosertyp\n          [ ("OK", Gtk.ResponseOk),\n            ("Cancel", Gtk.ResponseCancel)\n          ]\n      _ <- case mrf of\n        Just rf -> Gtk.fileChooserSetCurrentFolder dialog rf\n        Nothing -> getCurrentDirectory >>= Gtk.fileChooserSetCurrentFolder dialog\n      F.mapM_ (Gtk.fileChooserSetCurrentName dialog) mfname\n      --   !!!!!! really hackish solution !!!!!!\n      whileM_ (fmap (> 0) Gtk.eventsPending) (Gtk.mainIterationDo False)\n\n      res <- Gtk.dialogRun dialog\n      mr <- case res of\n        Gtk.ResponseDeleteEvent -> return Nothing\n        Gtk.ResponseOk -> Gtk.fileChooserGetFilename dialog\n        Gtk.ResponseCancel -> return Nothing\n        _ -> putStrLn "??? in fileOpen" >> return Nothing\n      Gtk.widgetDestroy dialog\n      return (UsrEv (FileChosen mr))\n'