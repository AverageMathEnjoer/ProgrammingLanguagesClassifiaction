b'#include "FileContext.h"\n#include "../libStringConverter/convert.h"\n\n#define WIN32_LEAN_AND_MEAN\n#define NOMINMAX\n#include <Windows.h>\n#include <shlwapi.h>\n#include <assert.h>\n\nIFileOpenCallback::IFileOpenCallback()\n{}\nIFileOpenCallback::~IFileOpenCallback()\n{}\n\nIFileContext::IFileContext(const std::string &filePath, IFileContext *pParent)\n{\n\tthis->filePath.assign(filePath);\n\tif (pParent != nullptr)\n\t\tthis->fileName.assign(filePath);\n\telse\n\t{\n\t\tconst char *fullPathC = this->filePath.c_str();\n\t\tsize_t fileNameIndex;\n\t\tfor (fileNameIndex = this->filePath.size(); fileNameIndex > 0; fileNameIndex--)\n\t\t{\n\t\t\tif (fullPathC[fileNameIndex-1] == \'/\' || fullPathC[fileNameIndex-1] == \'\\\\\')\n\t\t\t\tbreak;\n\t\t}\n\t\tthis->fileName.assign(this->filePath.substr(fileNameIndex));\n\t}\n\tthis->pParent = pParent;\n}\nIFileContext::~IFileContext()\n{}\n\nconst std::string &IFileContext::getFileName()\n{\n\treturn this->fileName;\n}\nconst std::string &IFileContext::getFilePath()\n{\n\treturn this->filePath;\n}\nstd::string IFileContext::getFileDirectoryPath()\n{\n\tsize_t slash = std::string::npos; size_t slashA = this->filePath.rfind(\'/\'); size_t slashB = this->filePath.rfind(\'\\\\\');\n\tif (slashA != std::string::npos && (slashB == std::string::npos || slashB <= slashA))\n\t\tslash = slashA;\n\telse if (slashB != std::string::npos)\n\t\tslash = slashB;\n\treturn this->filePath.substr(0, slash);\n}\nIFileContext *IFileContext::getParent()\n{\n\treturn this->pParent;\n}\n\n#pragma region BundleFileContext\nBundleFileContext::OpenTaskCallback::OpenTaskCallback(BundleFileContext *pContext)\n\t: pContext(pContext)\n{}\nvoid BundleFileContext::OpenTaskCallback::OnCompletion(std::shared_ptr<ITask> &pTask, TaskResult result)\n{\n\tif (result >= 0)\n\t\tthis->pContext->openState.OnCompletion();\n\telse\n\t\tthis->pContext->openState.OnFailure();\n\tif (this->pContext->pOpenCallback)\n\t\tthis->pContext->pOpenCallback->OnFileOpenResult(this->pContext, result);\n}\n\nBundleFileContext::OpenTask::OpenTask(BundleFileContext *pContext)\n\t: pContext(pContext)\n{\n\tname = "Open bundle : " + pContext->fileName;\n}\nconst std::string &BundleFileContext::OpenTask::getName()\n{\n\treturn name;\n}\nTaskResult BundleFileContext::OpenTask::execute(TaskProgressManager &progressManager)\n{\n\treturn pContext->OpenSync(&progressManager);\n}\n\nBundleFileContext::BundleFileContext(const std::string &filePath, std::shared_ptr<IAssetsReader> _pReader, bool readerIsModified)\n\t: IFileContext(filePath, nullptr),\n\topenTask(this), openTaskCallback(this),\n\tpOpenCallback(nullptr), pDecompressCallback(nullptr),\n\tpReader(std::move(_pReader)), inheritReader(pReader != nullptr), readerIsModified(pReader != nullptr && readerIsModified),\n\tlastOpenStatus(BundleFileOpenStatus_OK), lastDecompressStatus(BundleFileDecompressStatus_OK)\n{\n}\nBundleFileContext::BundleFileContext(const std::string &filePath, IFileContext *pParent, std::shared_ptr<IAssetsReader> _pReader, bool readerIsModified)\n\t: IFileContext(filePath, pParent),\n\topenTask(this), openTaskCallback(this),\n\tpOpenCallback(nullptr), pDecompressCallback(nullptr),\n\tpReader(std::move(_pReader)), inheritReader(true), readerIsModified(pReader != nullptr && readerIsModified),\n\tlastOpenStatus(BundleFileOpenStatus_OK), lastDecompressStatus(BundleFileDecompressStatus_OK)\n{\n\tassert(pParent && this->pReader);\n}\nBundleFileContext::~BundleFileContext()\n{\n\tthis->Close();\n}\n\nEBundleFileOpenStatus BundleFileContext::OpenSync(TaskProgressManager *pProgressManager, unsigned int initProgress, unsigned int progressScale)\n{\n\tif (pProgressManager) pProgressManager->setProgress(initProgress, progressScale);\n\tif (!this->inheritReader)\n\t{\n\t\tIAssetsReader *pReader = Create_AssetsReaderFromFile(this->filePath.c_str(), true, RWOpenFlags_Immediately);\n\t\tif (pReader == nullptr)\n\t\t{\n\t\t\tif (pProgressManager) pProgressManager->setProgress(initProgress + 100, progressScale);\n\t\t\tif (pProgressManager) pProgressManager->logMessage("[ERROR] Unable to open the bundle file.");\n\t\t\treturn BundleFileOpenStatus_ErrFileOpen;\n\t\t}\n\t\tthis->pReader = std::shared_ptr<IAssetsReader>(pReader, Free_AssetsReader);\n\t}\n\telse\n\t\tassert(this->pReader != nullptr);\n\tif (pProgressManager) pProgressManager->setProgress(initProgress + 25, progressScale);\n\tif (pProgressManager) pProgressManager->setProgressDesc("Processing bundle file");\n\tif (!this->bundle.Read(pReader.get(), nullptr, true))\n\t{\n\t\tif (pProgressManager) pProgressManager->setProgress(initProgress + 100, progressScale);\n\t\tif (pProgressManager) pProgressManager->logMessage("Open as bundle: [ERROR] Unable to process the bundle file header or lists.");\n\t\tthis->pReader.reset();\n\t\treturn BundleFileOpenStatus_ErrInvalid;\n\t}\n\tif (pProgressManager) pProgressManager->setProgressDesc("Processing bundle directory");\n\tif (this->bundle.bundleHeader3.fileVersion >= 6)\n\t{\n\t\tif (!this->bundle.bundleInf6)\n\t\t{\n\t\t\tif (pProgressManager) pProgressManager->setProgress(initProgress + 100, progressScale);\n\t\t\tif ((this->bundle.bundleHeader6.flags & 0x3F) != 0)\n\t\t\t\treturn BundleFileOpenStatus_CompressedDirectory;\n\t\t\tif (pProgressManager) pProgressManager->logMessage("[ERROR] Unable to process the bundle directory.");\n\t\t\tthis->bundle.Close();\n\t\t\tthis->pReader.reset();\n\t\t\treturn BundleFileOpenStatus_ErrInvalid;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfor (DWORD i = 0; i < this->bundle.bundleInf6->blockCount; i++)\n\t\t\t{\n\t\t\t\tif ((this->bundle.bundleInf6->blockInf[i].flags & 0x3F) != 0)\n\t\t\t\t{\n\t\t\t\t\tif (pProgressManager) pProgressManager->setProgress(initProgress + 100, progressScale);\n\t\t\t\t\treturn BundleFileOpenStatus_CompressedData;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (pProgressManager) pProgressManager->setProgress(initProgress + 100, progressScale);\n\t\t\treturn BundleFileOpenStatus_OK;\n\t\t}\n\t}\n\telse if (this->bundle.bundleHeader3.fileVersion == 3)\n\t{\n\t\tif (pProgressManager) pProgressManager->setProgress(initProgress + 100, progressScale);\n\t\tif (!strcmp(this->bundle.bundleHeader3.signature, "UnityWeb"))\n\t\t\treturn BundleFileOpenStatus_CompressedDirectory;\n\t\telse if (!this->bundle.assetsLists3)\n\t\t{\n\t\t\tif (pProgressManager) pProgressManager->logMessage("[ERROR] Unable to process the bundle directory.");\n\t\t\tthis->bundle.Close();\n\t\t\tthis->pReader.reset();\n\t\t\treturn BundleFileOpenStatus_ErrInvalid;\n\t\t}\n\t\telse\n\t\t\treturn BundleFileOpenStatus_OK;\n\t}\n\telse\n\t{\n\t\tif (pProgressManager) pProgressManager->setProgress(initProgress + 100, progressScale);\n\t\tif (pProgressManager) pProgressManager->logMessage("Open as bundle: [ERROR] Unknown bundle file version.");\n\t\tthis->bundle.Close();\n\t\tthis->pReader.reset();\n\t\treturn BundleFileOpenStatus_ErrUnknownVersion;\n\t}\n}\n\nEBundleFileOpenStatus BundleFileContext::Open()\n{\n\tif (this->openState.Start())\n\t{\n\t\tEBundleFileOpenStatus ret = OpenSync(nullptr);\n\t\tif (ret >= 0)\n\t\t\tthis->openState.OnCompletion();\n\t\telse\n\t\t\tthis->openState.OnFailure();\n\t\treturn ret;\n\t}\n\tif (this->openState.isReady())\n\t\treturn lastOpenStatus;\n\treturn BundleFileOpenStatus_Pend;\n}\nEBundleFileOpenStatus BundleFileContext::OpenInsideTask(TaskProgressManager *pProgressManager, unsigned int initProgress, unsigned int progressScale)\n{\n\tif (this->openState.Start())\n\t{\n\t\tEBundleFileOpenStatus ret = OpenSync(pProgressManager, initProgress, progressScale);\n\t\tif (ret >= 0)\n\t\t\tthis->openState.OnCompletion();\n\t\telse\n\t\t\tthis->openState.OnFailure();\n\t\treturn ret;\n\t}\n\tif (this->openState.isReady())\n\t\treturn lastOpenStatus;\n\treturn BundleFileOpenStatus_Pend;\n}\n\nvoid BundleFileContext::Close()\n{\n\tthis->decompressState.Close();\n\tif (this->openState.Close())\n\t{\n\t\tbundle.Close();\n\t\tpReader.reset();\n\t\t//TODO: Free any open resources.\n\t}\n}\n\nEBundleFileDecompressStatus BundleFileContext::DecompressSync(TaskProgressManager *pProgressManager, const std::string &outPath)\n{\n\tif (!this->openState.isReady())\n\t\treturn BundleFileDecompressStatus_ErrBundleNotOpened;\n\tIAssetsWriter *pWriter = Create_AssetsWriterToFile(outPath.c_str(), true, true, RWOpenFlags_Immediately);\n\tif (!pWriter)\n\t\treturn BundleFileDecompressStatus_ErrOutFileOpen;\n\tEBundleFileDecompressStatus ret = BundleFileDecompressStatus_OK;\n\tif (!bundle.Unpack(this->pReader.get(), pWriter))\n\t\tret = BundleFileDecompressStatus_ErrDecompress;\n\tFree_AssetsWriter(pWriter);\n\treturn ret;\n}\n\nIAssetsReader *BundleFileContext::getReaderUnsafe(bool *isInherited)\n{\n\tif (isInherited)\n\t\t*isInherited = this->inheritReader;\n\tif (this->openState.isReady())\n\t\treturn this->pReader.get();\n\treturn nullptr;\n}\nAssetBundleFile *BundleFileContext::getBundleFile()\n{\n\tif (this->openState.isReady())\n\t\treturn &this->bundle;\n\treturn nullptr;\n}\n//For v3 bundles: Returns false. For v6 bundles: Returns the directory flag "has serialized data".\n//-> If true, the file is supposed to be an .assets file.\nbool BundleFileContext::hasSerializedData(size_t index)\n{\n\tif (this->openState.isReady())\n\t{\n\t\tif (index >= getEntryCount())\n\t\t\treturn false;\n\t\tif (this->bundle.bundleHeader6.fileVersion >= 6)\n\t\t\treturn (this->bundle.bundleInf6->dirInf[index].flags & 4) != 0;\n\t}\n\treturn false;\n}\nstd::shared_ptr<IAssetsReader> BundleFileContext::makeEntryReader(size_t index)\n{\n\tif (this->openState.isReady())\n\t{\n\t\tif (index >= getEntryCount())\n\t\t\treturn nullptr;\n\t\tif (this->bundle.bundleHeader6.fileVersion >= 6)\n\t\t\treturn std::shared_ptr<IAssetsReader>(\n\t\t\t\tthis->bundle.MakeAssetsFileReader(this->pReader.get(), &this->bundle.bundleInf6->dirInf[index]),\n\t\t\t\tFreeAssetBundle_FileReader);\n\t\telse if (this->bundle.bundleHeader6.fileVersion == 3)\n\t\t\treturn std::shared_ptr<IAssetsReader>(\n\t\t\t\tthis->bundle.MakeAssetsFileReader(this->pReader.get(), this->bundle.assetsLists3->ppEntries[index]),\n\t\t\t\tFreeAssetBundle_FileReader);\n\t}\n\treturn nullptr;\n}\nconst char *BundleFileContext::getEntryName(size_t index)\n{\n\tif (this->openState.isReady())\n\t{\n\t\tif (index >= getEntryCount())\n\t\t\treturn nullptr;\n\t\tif (this->bundle.bundleHeader6.fileVersion >= 6)\n\t\t\treturn this->bundle.bundleInf6->dirInf[index].name;\n\t\telse if (this->bundle.bundleHeader6.fileVersion == 3)\n\t\t\treturn this->bundle.assetsLists3->ppEntries[index]->name;\n\t}\n\treturn nullptr;\n}\nsize_t BundleFileContext::getEntryCount()\n{\n\tif (this->openState.isReady())\n\t{\n\t\tif (this->bundle.bundleHeader6.fileVersion >= 6 && this->bundle.bundleInf6 != nullptr)\n\t\t\treturn this->bundle.bundleInf6->directoryCount;\n\t\telse if (this->bundle.bundleHeader6.fileVersion == 3 && this->bundle.assetsLists3 != nullptr)\n\t\t\treturn this->bundle.assetsLists3->count;\n\t}\n\treturn 0;\n}\n\nEFileContextType BundleFileContext::getType()\n{\n\treturn FileContext_Bundle;\n}\n#pragma endregion BundleFileContext\n\n#pragma region AssetsFileContext\nAssetsFileContext::OpenTaskCallback::OpenTaskCallback(AssetsFileContext *pContext)\n\t: pContext(pContext)\n{}\nvoid AssetsFileContext::OpenTaskCallback::OnCompletion(std::shared_ptr<ITask> &pTask, TaskResult result)\n{\n\tif (result >= 0)\n\t\tthis->pContext->openState.OnCompletion();\n\telse\n\t\tthis->pContext->openState.OnFailure();\n\tif (this->pContext->pOpenCallback)\n\t\tthis->pContext->pOpenCallback->OnFileOpenResult(this->pContext, result);\n}\n\nAssetsFileContext::OpenTask::OpenTask(AssetsFileContext *pContext)\n\t: pContext(pContext)\n{\n\tname = "Open .assets : " + pContext->fileName;\n}\nconst std::string &AssetsFileContext::OpenTask::getName()\n{\n\treturn name;\n}\nTaskResult AssetsFileContext::OpenTask::execute(TaskProgressManager &progressManager)\n{\n\treturn pContext->OpenSync(&progressManager, pContext->doMakeBinaryTable, 0, pContext->getProgressScale());\n}\n\nAssetsFileContext::AssetsFileContext(const std::string &filePath, std::shared_ptr<IAssetsReader> _pReader, bool readerIsModified)\n\t: IFileContext(filePath, nullptr),\n\topenTask(this), openTaskCallback(this), pOpenCallback(nullptr),\n\tpReader(std::move(_pReader)), inheritReader(pReader != nullptr), readerIsModified(pReader != nullptr && readerIsModified),\n\tlastOpenStatus(AssetsFileOpenStatus_OK), pAssetsFile(nullptr), pAssetsFileTable(nullptr)\n{}\nAssetsFileContext::AssetsFileContext(const std::string &filePath, IFileContext *pParent, std::shared_ptr<IAssetsReader> _pReader, bool readerIsModified)\n\t: IFileContext(filePath, pParent),\n\topenTask(this), openTaskCallback(this), pOpenCallback(nullptr),\n\tpReader(std::move(_pReader)), inheritReader(true), readerIsModified(pReader != nullptr && readerIsModified),\n\tlastOpenStatus(AssetsFileOpenStatus_OK), pAssetsFile(nullptr), pAssetsFileTable(nullptr)\n{\n\tassert(pParent && this->pReader);\n}\nAssetsFileContext::~AssetsFileContext()\n{\n\tthis->Close();\n}\n\nint AssetsFileContext::getProgressScale()\n{\n\treturn 100;\n}\nEAssetsFileOpenStatus AssetsFileContext::OpenSync(TaskProgressManager *pProgressManager, bool makeBinaryTable, unsigned int initProgress, unsigned int progressScale)\n{\n\tif (pProgressManager) pProgressManager->setProgress(initProgress, progressScale);\n\tif (!this->inheritReader)\n\t{\n\t\tIAssetsReader *pReader = Create_AssetsReaderFromFile(this->filePath.c_str(), true, RWOpenFlags_Immediately);\n\t\tif (pReader == nullptr)\n\t\t{\n\t\t\tif (pProgressManager) pProgressManager->setProgress(initProgress + 100, progressScale);\n\t\t\tif (pProgressManager) pProgressManager->logMessage("[ERROR] Unable to open the .assets file.");\n\t\t\treturn AssetsFileOpenStatus_ErrFileOpen;\n\t\t}\n\t\tthis->pReader = std::shared_ptr<IAssetsReader>(pReader, Free_AssetsReader);\n\t}\n\telse\n\t\tassert(this->pReader != nullptr);\n\tif (pProgressManager) pProgressManager->setProgress(initProgress + (makeBinaryTable ? 15 : 25), progressScale);\n\tif (pProgressManager) pProgressManager->setProgressDesc("Processing .assets file");\n\tAssetsFile *pAssetsFile = new AssetsFile(this->pReader.get());\n\tif (!pAssetsFile->VerifyAssetsFile())\n\t{\n\t\tdelete pAssetsFile;\n\t\tthis->pReader.reset();\n\t\tif (pProgressManager) pProgressManager->setProgress(initProgress + 100, progressScale);\n\t\tif (pProgressManager) pProgressManager->logMessage("Open as .assets: [ERROR] .assets file is invalid or unsupported.");\n\t\treturn AssetsFileOpenStatus_ErrInvalidOrUnsupported;\n\t}\n\tthis->pAssetsFile = pAssetsFile;\n\tif (pProgressManager) pProgressManager->setProgress(initProgress + (makeBinaryTable ? 25 : 50), progressScale);\n\tif (pProgressManager) pProgressManager->setProgressDesc("Processing asset list");\n\t\n\tthis->pAssetsFileTable = new AssetsFileTable(pAssetsFile);\n\tif (makeBinaryTable)\n\t{\n\t\tif (pProgressManager) pProgressManager->setProgress(initProgress + 50, progressScale);\n\t\tif (pProgressManager) pProgressManager->setProgressDesc("Generating asset lookup tree");\n\t\tif (!this->pAssetsFileTable->GenerateQuickLookupTree())\n\t\t{\n\t\t\tif (pProgressManager) pProgressManager->logMessage("[WARNING] Failed to generate the asset quick lookup tree.");\n\t\t}\n\t}\n\t\n\tif (pProgressManager) pProgressManager->setProgress(initProgress + 100, progressScale);\n\treturn AssetsFileOpenStatus_OK;\n}\n\nEAssetsFileOpenStatus AssetsFileContext::Open(bool makeBinaryTable)\n{\n\tif (this->openState.Start())\n\t{\n\t\tEAssetsFileOpenStatus ret = OpenSync(nullptr, makeBinaryTable, 0, this->getProgressScale());\n\t\tif (ret >= 0)\n\t\t\tthis->openState.OnCompletion();\n\t\telse\n\t\t\tthis->openState.OnFailure();\n\t\treturn ret;\n\t}\n\tif (this->openState.isReady())\n\t\treturn lastOpenStatus;\n\treturn AssetsFileOpenStatus_Pend;\n}\nEAssetsFileOpenStatus AssetsFileContext::OpenInsideTask(TaskProgressManager *pProgressManager, bool makeBinaryTable, unsigned int initProgress, unsigned int progressScale)\n{\n\tif (this->openState.Start())\n\t{\n\t\tEAssetsFileOpenStatus ret = OpenSync(pProgressManager, makeBinaryTable, initProgress, progressScale);\n\t\tif (ret >= 0)\n\t\t\tthis->openState.OnCompletion();\n\t\telse\n\t\t\tthis->openState.OnFailure();\n\t\treturn ret;\n\t}\n\tif (this->openState.isReady())\n\t\treturn lastOpenStatus;\n\treturn AssetsFileOpenStatus_Pend;\n}\nvoid AssetsFileContext::Close()\n{\n\tif (this->openState.Close())\n\t{\n\t\tdelete this->pAssetsFile;\n\t\tdelete this->pAssetsFileTable;\n\t\tthis->pAssetsFile = nullptr;\n\t\tthis->pAssetsFileTable = nullptr;\n\t\tthis->pReader.reset();\n\t}\n}\nIAssetsReader *AssetsFileContext::getReaderUnsafe(bool *isInherited)\n{\n\tif (isInherited)\n\t\t*isInherited = this->inheritReader;\n\tif (this->openState.isReady())\n\t\treturn this->pReader.get();\n\treturn nullptr;\n}\nIAssetsReader *AssetsFileContext::createReaderView(bool *isInherited)\n{\n\tIAssetsReader *pReader = getReaderUnsafe(isInherited);\n\tif (pReader)\n\t\treturn pReader->CreateView();\n\treturn nullptr;\n}\nAssetsFile *AssetsFileContext::getAssetsFile()\n{\n\tif (this->openState.isReady())\n\t\treturn this->pAssetsFile;\n\treturn nullptr;\n}\nAssetsFileTable *AssetsFileContext::getAssetsFileTable()\n{\n\tif (this->openState.isReady())\n\t\treturn this->pAssetsFileTable;\n\treturn nullptr;\n}\n\nEFileContextType AssetsFileContext::getType()\n{\n\treturn FileContext_Assets;\n}\n#pragma endregion AssetsFileContext\n\n#pragma region ResourcesFileContext\nResourcesFileContext::ResourcesFileContext(const std::string &filePath, std::shared_ptr<IAssetsReader> _pReader, bool readerIsModified)\n\t: IFileContext(filePath, nullptr),\n\tpReader(std::move(_pReader)), inheritReader(pReader != nullptr), readerIsModified(pReader != nullptr && readerIsModified)\n{\n}\nResourcesFileContext::ResourcesFileContext(const std::string &filePath, IFileContext *pParent, std::shared_ptr<IAssetsReader> _pReader, bool readerIsModified)\n\t: IFileContext(filePath, pParent),\n\tpReader(std::move(_pReader)), inheritReader(true), readerIsModified(pReader != nullptr && readerIsModified)\n{\n\tassert(pParent && this->pReader);\n}\nResourcesFileContext::~ResourcesFileContext()\n{\n\tthis->Close();\n}\nEResourcesFileOpenStatus ResourcesFileContext::Open()\n{\n\tif (!this->inheritReader)\n\t{\n\t\tIAssetsReader *pReader = Create_AssetsReaderFromFile(this->filePath.c_str(), true, RWOpenFlags_Immediately);\n\t\tif (pReader == nullptr)\n\t\t{\n\t\t\treturn ResourcesFileOpenStatus_ErrFileOpen;\n\t\t}\n\t\tthis->pReader = std::shared_ptr<IAssetsReader>(pReader, Free_AssetsReader);\n\t}\n\telse\n\t\tassert(this->pReader != nullptr);\n\treturn ResourcesFileOpenStatus_OK;\n}\nvoid ResourcesFileContext::Close()\n{\n\tthis->pReader.reset();\n}\nIAssetsReader *ResourcesFileContext::getReaderUnsafe(bool *isInherited)\n{\n\tif (isInherited)\n\t\t*isInherited = this->inheritReader;\n\treturn this->pReader.get();\n}\nEFileContextType ResourcesFileContext::getType()\n{\n\treturn FileContext_Resources;\n}\n#pragma endregion ResourcesFileContext\n\n\n\n#pragma region GenericFileContext\nGenericFileContext::GenericFileContext(const std::string &filePath, std::shared_ptr<IAssetsReader> _pReader, bool readerIsModified)\n\t: IFileContext(filePath, nullptr),\n\tpReader(std::move(_pReader)), inheritReader(pReader != nullptr), readerIsModified(pReader != nullptr && readerIsModified)\n{\n}\nGenericFileContext::GenericFileContext(const std::string &filePath, IFileContext *pParent, std::shared_ptr<IAssetsReader> _pReader, bool readerIsModified)\n\t: IFileContext(filePath, pParent),\n\tpReader(std::move(_pReader)), inheritReader(true), readerIsModified(pReader != nullptr && readerIsModified)\n{\n\tassert(pParent && this->pReader);\n}\nGenericFileContext::~GenericFileContext()\n{\n\tthis->Close();\n}\nEGenericFileOpenStatus GenericFileContext::Open()\n{\n\tif (!this->inheritReader)\n\t{\n\t\tIAssetsReader *pReader = Create_AssetsReaderFromFile(this->filePath.c_str(), true, RWOpenFlags_Immediately);\n\t\tif (pReader == nullptr)\n\t\t{\n\t\t\treturn GenericFileOpenStatus_ErrFileOpen;\n\t\t}\n\t\tthis->pReader = std::shared_ptr<IAssetsReader>(pReader, Free_AssetsReader);\n\t}\n\telse\n\t\tassert(this->pReader != nullptr);\n\treturn GenericFileOpenStatus_OK;\n}\nvoid GenericFileContext::Close()\n{\n\tthis->pReader.reset();\n}\nIAssetsReader *GenericFileContext::getReaderUnsafe(bool *isInherited)\n{\n\tif (isInherited)\n\t\t*isInherited = this->inheritReader;\n\treturn this->pReader.get();\n}\nEFileContextType GenericFileContext::getType()\n{\n\treturn FileContext_Generic;\n}\n#pragma endregion GenericFileContext\n\n#pragma region AsyncOperationState\nAsyncOperationState::AsyncOperationState()\n{\n\tthis->state.val = 0;\n\tthis->hOperationCompleteEvent = CreateEvent(NULL, TRUE, FALSE, NULL);\n}\nAsyncOperationState::~AsyncOperationState()\n{\n\tCloseHandle(this->hOperationCompleteEvent);\n}\n//Sets the isWorking flag if neither isWorking nor isReady is set, and returns true. Returns false otherwise.\nbool AsyncOperationState::Start()\n{\n\tState oldState; oldState.val = this->state.val;\n\tif (!oldState.isWorking && !oldState.isReady)\n\t{\n\t\tState newState = {};\n\t\tnewState.isReady = false; newState.isWorking = true;\n\t\toldState.val = InterlockedExchange(&this->state.val, newState.val);\n\t\tif (oldState.isWorking || oldState.isReady)\n\t\t{\n\t\t\toldState.val = InterlockedExchange(&this->state.val, oldState.val);\n\t\t\tif (oldState.isReady)\n\t\t\t{\n\t\t\t\tthis->state.isReady = true;\n\t\t\t\tstd::atomic_thread_fence(std::memory_order::seq_cst);\n\t\t\t\tthis->state.isWorking = false;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n//Waits for completion if it is in the working state. Resets the ready flag if necessary, returns true if any open resources should be freed.\nbool AsyncOperationState::Close()\n{\n\tif (this->state.isWorking)\n\t\tWaitForSingleObject(this->hOperationCompleteEvent, INFINITE);\n\tif (this->state.isReady)\n\t{\n\t\tthis->state.isReady = false;\n\t\tResetEvent(this->hOperationCompleteEvent);\n\t\treturn true;\n\t}\n\treturn false;\n}\nvoid AsyncOperationState::OnCompletion()\n{\n\tthis->state.isReady = true;\n\tstd::atomic_thread_fence(std::memory_order::seq_cst);\n\tthis->state.isWorking = false;\n\tSetEvent(this->hOperationCompleteEvent);\n}\nvoid AsyncOperationState::OnFailure()\n{\n\tthis->state.isWorking = false;\n\tSetEvent(this->hOperationCompleteEvent);\n}\n#pragma endregion AsyncOperationState'