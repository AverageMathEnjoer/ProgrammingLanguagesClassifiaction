b'context("dispersions")\ntest_that("expected errors thrown during dispersion estimation", {\n  dds <- makeExampleDESeqDataSet(n=100, m=2)\n  dds <- estimateSizeFactors(dds)\n  expect_error(estimateDispersionsGeneEst(dds))\n\n  set.seed(1)\n  dds <- makeExampleDESeqDataSet(n=100, m=4, dispMeanRel=function(x) 0.001 + x/1e3, interceptMean=8, interceptSD=2)\n  dds <- estimateSizeFactors(dds)\n  mcols(dds)$dispGeneEst <- rep(1e-7, 100)\n  expect_error(estimateDispersionsFit(dds))\n  dds <- estimateDispersionsGeneEst(dds)\n  expect_message(estimateDispersionsFit(dds))\n\n  dds <- makeExampleDESeqDataSet(n=100, m=4)\n  dds <- estimateSizeFactors(dds)\n  mcols(dds)$dispGeneEst <- rep(1e-7, 100)\n  dispersionFunction(dds) <- function(x) 1e-6\n  expect_warning(estimateDispersionsMAP(dds))\n\n  dds <- makeExampleDESeqDataSet(n=100, m=4)\n  dds <- estimateSizeFactors(dds)\n  levels(dds$condition) <- c("A","B","C")\n  expect_error(estimateDispersions(dds))\n  dds$condition <- droplevels(dds$condition)\n  dds$group <- dds$condition\n  design(dds) <- ~ group + condition\n  expect_error(estimateDispersions(dds))\n\n  dds <- makeExampleDESeqDataSet(n=100, m=2)\n  expect_error({ dds <- DESeq(dds) })\n  \n})\n\ntest_that("the fitting of dispersion gives expected values using various methods", {\n  # test the optimization of the logarithm of dispersion (alpha)\n  # parameter with Cox-Reid adjustment and prior distribution.\n  # also test the derivatives of the log posterior w.r.t. log alpha\n  m <- 10\n  set.seed(1)\n  y <- rpois(m,20)\n  sf <- rep(1,m)\n  condition <- factor(rep(0:1,each=m/2))\n  x <- cbind(rep(1,m),rep(0:1,each=m/2))\n  colnames(x) <- c("Intercept","condition")\n\n  lambda <- 2\n  alpha <- .5\n\n  # make a DESeqDataSet but don\'t use the design formula\n  # instead we supply a model matrix below\n  dds <- DESeqDataSetFromMatrix(matrix(y,nrow=1),\n                                colData=DataFrame(condition),\n                                design= ~ condition)\n  sizeFactors(dds) <- sf\n  dispersions(dds) <- alpha\n  mcols(dds)$baseMean <- mean(y)\n\n  # for testing we convert beta to the naturual log scale:\n  # convert lambda from log to log2 scale by multiplying by log(2)^2\n  # then convert beta back from log2 to log scale by multiplying by log(2)\n  betaDESeq <- log(2)*DESeq2:::fitNbinomGLMs(dds, lambda=c(0,lambda*log(2)^2),modelMatrix=x)$betaMatrix\n  log_alpha_prior_mean <- .5\n  log_alpha_prior_sigmasq <- 1\n  mu.hat <- as.numeric(exp(x %*% t(betaDESeq)))\n  \n  dispRes <- DESeq2:::fitDisp(ySEXP = matrix(y,nrow=1), xSEXP = x,\n                              mu_hatSEXP = matrix(mu.hat,nrow=1), log_alphaSEXP = 0,\n                              log_alpha_prior_meanSEXP = log_alpha_prior_mean,\n                              log_alpha_prior_sigmasqSEXP = log_alpha_prior_sigmasq,\n                              min_log_alphaSEXP = log(1e-8), kappa_0SEXP = 1,\n                              tolSEXP = 1e-16, maxitSEXP = 100, usePriorSEXP = TRUE,\n                              weightsSEXP=matrix(1,nrow=1,ncol=length(y)),\n                              useWeightsSEXP=FALSE,\n                              weightThresholdSEXP=1e-2,\n                              useCRSEXP=TRUE)\n  \n  # maximum a posteriori (MAP) estimate from DESeq\n  dispDESeq <- dispRes$log_alpha\n  \n  # MAP estimate using optim\n  logPost <- function(log.alpha) {\n    alpha <- exp(log.alpha)\n    w <- diag(1/(1/mu.hat^2 * ( mu.hat + alpha * mu.hat^2 )))\n    logLike <- sum(dnbinom(y, mu=mu.hat, size=1/alpha, log=TRUE))\n    coxReid <- -.5*(log(det(t(x) %*% w %*% x)))\n    logPrior <- dnorm(log.alpha, log_alpha_prior_mean, sqrt(log_alpha_prior_sigmasq), log=TRUE)\n    (logLike + coxReid + logPrior)\n  }\n  \n  dispOptim <- optim(0, function(p) -1*logPost(p), control=list(reltol=1e-16), method="Brent", lower=-10, upper=10)$par\n                     \n  expect_equal(dispDESeq, dispOptim, tolerance=1e-6)\n  \n  # check derivatives:\n  \n  # from Ted Harding https://stat.ethz.ch/pipermail/r-help/2007-September/140013.html\n  num.deriv <- function(f,x,h=0.001) (f(x + h/2) - f(x-h/2))/h\n  num.2nd.deriv <- function(f,x,h=0.001) (f(x + h) - 2*f(x) + f(x - h))/h^2\n\n  # first derivative of log posterior w.r.t log alpha at start\n  dispDerivDESeq <- dispRes$initial_dlp\n  dispDerivNum <- num.deriv(logPost,0)\n\n  expect_equal(dispDerivDESeq, dispDerivNum, tolerance=1e-6)\n\n  # second derivative at finish\n  dispD2DESeq <- dispRes$last_d2lp\n  dispD2Num <- num.2nd.deriv(logPost, dispRes$log_alpha)\n\n  expect_equal(dispD2DESeq, dispD2Num, tolerance=1e-6)\n\n\n  # test fit alternative\n  dds <- makeExampleDESeqDataSet()\n  dds <- estimateSizeFactors(dds)\n  ddsLocal <- estimateDispersions(dds, fitType="local")\n  ddsMean <- estimateDispersions(dds, fitType="mean")\n  ddsMed <- estimateDispersionsGeneEst(dds)\n  useForMedian <- mcols(ddsMed)$dispGeneEst > 1e-7\n  medianDisp <- median(mcols(ddsMed)$dispGeneEst[useForMedian],na.rm=TRUE)\n  dispersionFunction(ddsMed) <- function(mu) medianDisp\n  ddsMed <- estimateDispersionsMAP(ddsMed)  \n\n\n  # test iterative\n  set.seed(1)\n  dds <- makeExampleDESeqDataSet(m=50,n=100,betaSD=1,interceptMean=8)\n  dds <- estimateSizeFactors(dds)\n  dds <- estimateDispersionsGeneEst(dds, niter=5)\n  with(mcols(dds)[!mcols(dds)$allZero,],\n       expect_equal(log(trueDisp), log(dispGeneEst),tol=0.2))\n\n})\n\n## test_that("Expected variance of log dispersions for df <= 3", {\n##   sds <- rep(seq(from=.5, to=2.5, by=.25), each=2)\n##   ests <- numeric(length(sds))\n##   for (i in seq_along(sds)) {\n##     cat(i)\n##     dds <- makeExampleDESeqDataSet(n=1000, m=4, interceptMean=8, interceptSD=1,\n##                                    dispMeanRel=function(x) exp(rnorm(1000,log(0.05),sds[i])))\n##     sizeFactors(dds) <- rep(1,4)\n##     dds <- estimateDispersions(dds, fitType="mean", quiet=TRUE)\n##     ests[i] <- attr(dispersionFunction(dds), "dispPriorVar")\n##   }\n##   plot(sds^2, ests); abline(0,1)\n## })\n'