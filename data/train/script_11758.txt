b'/*\n * Copyright (C) 2012 Andrew Neal\n * Copyright (C) 2014 The CyanogenMod Project\n * Copyright (C) 2015 Naman Dwivedi\n *\n * Licensed under the Apache License, Version 2.0\n * (the "License"); you may not use this file except in compliance with the\n * License. You may obtain a copy of the License at\n * http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law\n * or agreed to in writing, software distributed under the License is\n * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\npackage com.naman14.timber;\n\nimport android.Manifest;\nimport android.annotation.SuppressLint;\nimport android.annotation.TargetApi;\nimport android.app.AlarmManager;\nimport android.app.Notification;\nimport android.app.NotificationChannel;\nimport android.app.NotificationManager;\nimport android.app.PendingIntent;\nimport android.app.Service;\nimport android.content.BroadcastReceiver;\nimport android.content.ComponentName;\nimport android.content.ContentResolver;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.IntentFilter;\nimport android.content.SharedPreferences;\nimport android.database.ContentObserver;\nimport android.database.Cursor;\nimport android.database.MatrixCursor;\nimport android.graphics.Bitmap;\nimport android.graphics.Color;\nimport android.media.AudioManager;\nimport android.media.AudioManager.OnAudioFocusChangeListener;\nimport android.media.MediaMetadataEditor;\nimport android.media.MediaMetadataRetriever;\nimport android.media.MediaPlayer;\nimport android.media.RemoteControlClient;\nimport android.media.audiofx.AudioEffect;\nimport android.net.Uri;\nimport android.os.Build;\nimport android.os.Bundle;\nimport android.os.Handler;\nimport android.os.HandlerThread;\nimport android.os.IBinder;\nimport android.os.Looper;\nimport android.os.Message;\nimport android.os.PowerManager;\nimport android.os.PowerManager.WakeLock;\nimport android.os.RemoteException;\nimport android.os.SystemClock;\nimport android.provider.MediaStore;\nimport android.provider.MediaStore.Audio.AlbumColumns;\nimport android.provider.MediaStore.Audio.AudioColumns;\nimport androidx.core.app.NotificationManagerCompat;\nimport android.support.v4.media.MediaMetadataCompat;\nimport android.support.v4.media.session.MediaSessionCompat;\nimport android.support.v4.media.session.PlaybackStateCompat;\n\nimport androidx.media.app.NotificationCompat;\nimport androidx.palette.graphics.Palette;\nimport android.text.TextUtils;\nimport android.util.Log;\n\nimport com.naman14.timber.helpers.MediaButtonIntentReceiver;\nimport com.naman14.timber.helpers.MusicPlaybackTrack;\nimport com.naman14.timber.lastfmapi.LastFmClient;\nimport com.naman14.timber.lastfmapi.models.LastfmUserSession;\nimport com.naman14.timber.lastfmapi.models.ScrobbleQuery;\nimport com.naman14.timber.permissions.Nammu;\nimport com.naman14.timber.provider.MusicPlaybackState;\nimport com.naman14.timber.provider.RecentStore;\nimport com.naman14.timber.provider.SongPlayCount;\nimport com.naman14.timber.utils.NavigationUtils;\nimport com.naman14.timber.utils.PreferencesUtility;\nimport com.naman14.timber.utils.TimberUtils;\nimport com.naman14.timber.utils.TimberUtils.IdType;\nimport com.nostra13.universalimageloader.core.ImageLoader;\n\nimport java.io.IOException;\nimport java.lang.ref.WeakReference;\nimport java.util.ArrayList;\nimport java.util.LinkedList;\nimport java.util.ListIterator;\nimport java.util.Random;\nimport java.util.TreeSet;\n\nimport de.Maxr1998.trackselectorlib.ModNotInstalledException;\nimport de.Maxr1998.trackselectorlib.NotificationHelper;\nimport de.Maxr1998.trackselectorlib.TrackItem;\n\n@SuppressLint("NewApi")\npublic class MusicService extends Service {\n    public static final String PLAYSTATE_CHANGED = "com.naman14.timber.playstatechanged";\n    public static final String POSITION_CHANGED = "com.naman14.timber.positionchanged";\n    public static final String META_CHANGED = "com.naman14.timber.metachanged";\n    public static final String QUEUE_CHANGED = "com.naman14.timber.queuechanged";\n    public static final String PLAYLIST_CHANGED = "com.naman14.timber.playlistchanged";\n    public static final String REPEATMODE_CHANGED = "com.naman14.timber.repeatmodechanged";\n    public static final String SHUFFLEMODE_CHANGED = "com.naman14.timber.shufflemodechanged";\n    public static final String TRACK_ERROR = "com.naman14.timber.trackerror";\n    public static final String TIMBER_PACKAGE_NAME = "com.naman14.timber";\n    public static final String MUSIC_PACKAGE_NAME = "com.android.music";\n    public static final String SERVICECMD = "com.naman14.timber.musicservicecommand";\n    public static final String TOGGLEPAUSE_ACTION = "com.naman14.timber.togglepause";\n    public static final String PAUSE_ACTION = "com.naman14.timber.pause";\n    public static final String STOP_ACTION = "com.naman14.timber.stop";\n    public static final String PREVIOUS_ACTION = "com.naman14.timber.previous";\n    public static final String PREVIOUS_FORCE_ACTION = "com.naman14.timber.previous.force";\n    public static final String NEXT_ACTION = "fcom.naman14.timber.next";\n    public static final String REPEAT_ACTION = "com.naman14.timber.repeat";\n    public static final String SHUFFLE_ACTION = "com.naman14.timber.shuffle";\n    public static final String FROM_MEDIA_BUTTON = "frommediabutton";\n    public static final String REFRESH = "com.naman14.timber.refresh";\n    public static final String UPDATE_LOCKSCREEN = "com.naman14.timber.updatelockscreen";\n    public static final String CMDNAME = "command";\n    public static final String CMDTOGGLEPAUSE = "togglepause";\n    public static final String CMDSTOP = "stop";\n    public static final String CMDPAUSE = "pause";\n    public static final String CMDPLAY = "play";\n    public static final String CMDPREVIOUS = "previous";\n    public static final String CMDNEXT = "next";\n    public static final String CMDNOTIF = "buttonId";\n    public static final String UPDATE_PREFERENCES = "updatepreferences";\n    public static final String CHANNEL_ID = "timber_channel_01";\n    public static final int NEXT = 2;\n    public static final int LAST = 3;\n    public static final int SHUFFLE_NONE = 0;\n    public static final int SHUFFLE_NORMAL = 1;\n    public static final int SHUFFLE_AUTO = 2;\n    public static final int REPEAT_NONE = 0;\n    public static final int REPEAT_CURRENT = 1;\n    public static final int REPEAT_ALL = 2;\n    public static final int MAX_HISTORY_SIZE = 1000;\n    private static final String TAG = "MusicPlaybackService";\n    private static final boolean D = false;\n    private static final String SHUTDOWN = "com.naman14.timber.shutdown";\n    private static final int IDCOLIDX = 0;\n    private static final int TRACK_ENDED = 1;\n    private static final int TRACK_WENT_TO_NEXT = 2;\n    private static final int RELEASE_WAKELOCK = 3;\n    private static final int SERVER_DIED = 4;\n    private static final int FOCUSCHANGE = 5;\n    private static final int FADEDOWN = 6;\n    private static final int FADEUP = 7;\n    private static final int IDLE_DELAY = 5 * 60 * 1000;\n    private static final long REWIND_INSTEAD_PREVIOUS_THRESHOLD = 3000;\n    private static final String[] PROJECTION = new String[]{\n            "audio._id AS _id", MediaStore.Audio.Media.ARTIST, MediaStore.Audio.Media.ALBUM,\n            MediaStore.Audio.Media.TITLE, MediaStore.Audio.Media.DATA,\n            MediaStore.Audio.Media.MIME_TYPE, MediaStore.Audio.Media.ALBUM_ID,\n            MediaStore.Audio.Media.ARTIST_ID\n    };\n    private static final String[] ALBUM_PROJECTION = new String[]{\n            MediaStore.Audio.Albums.ALBUM, MediaStore.Audio.Albums.ARTIST,\n            MediaStore.Audio.Albums.LAST_YEAR\n    };\n    private static final String[] NOTIFICATION_PROJECTION = new String[]{\n            "audio._id AS _id", AudioColumns.ALBUM_ID, AudioColumns.TITLE,\n            AudioColumns.ARTIST, AudioColumns.DURATION\n    };\n    private static final Shuffler mShuffler = new Shuffler();\n    private static final int NOTIFY_MODE_NONE = 0;\n    private static final int NOTIFY_MODE_FOREGROUND = 1;\n    private static final int NOTIFY_MODE_BACKGROUND = 2;\n    private static final String[] PROJECTION_MATRIX = new String[]{\n            "_id", MediaStore.Audio.Media.ARTIST, MediaStore.Audio.Media.ALBUM,\n            MediaStore.Audio.Media.TITLE, MediaStore.Audio.Media.DATA,\n            MediaStore.Audio.Media.MIME_TYPE, MediaStore.Audio.Media.ALBUM_ID,\n            MediaStore.Audio.Media.ARTIST_ID\n    };\n    private static LinkedList<Integer> mHistory = new LinkedList<>();\n    private final IBinder mBinder = new ServiceStub(this);\n    private MultiPlayer mPlayer;\n    private String mFileToPlay;\n    private WakeLock mWakeLock;\n    private AlarmManager mAlarmManager;\n    private PendingIntent mShutdownIntent;\n    private boolean mShutdownScheduled;\n    private NotificationManagerCompat mNotificationManager;\n    private Cursor mCursor;\n    private Cursor mAlbumCursor;\n    private AudioManager mAudioManager;\n    private SharedPreferences mPreferences;\n    private boolean mServiceInUse = false;\n    private boolean mIsSupposedToBePlaying = false;\n    private long mLastPlayedTime;\n    private int mNotifyMode = NOTIFY_MODE_NONE;\n    private long mNotificationPostTime = 0;\n    private boolean mQueueIsSaveable = true;\n    private boolean mPausedByTransientLossOfFocus = false;\n\n    private MediaSessionCompat mSession;\n    @SuppressWarnings("deprecation")\n    private RemoteControlClient mRemoteControlClient;\n\n    private ComponentName mMediaButtonReceiverComponent;\n\n    private int mCardId;\n\n    private int mPlayPos = -1;\n\n    private int mNextPlayPos = -1;\n\n    private int mOpenFailedCounter = 0;\n\n    private int mMediaMountedCount = 0;\n\n    private int mShuffleMode = SHUFFLE_NONE;\n\n    private int mRepeatMode = REPEAT_NONE;\n\n    private int mServiceStartId = -1;\n\n    private ArrayList<MusicPlaybackTrack> mPlaylist = new ArrayList<MusicPlaybackTrack>(100);\n\n    private long[] mAutoShuffleList = null;\n\n    private MusicPlayerHandler mPlayerHandler;\n    private final OnAudioFocusChangeListener mAudioFocusListener = new OnAudioFocusChangeListener() {\n\n        @Override\n        public void onAudioFocusChange(final int focusChange) {\n            mPlayerHandler.obtainMessage(FOCUSCHANGE, focusChange, 0).sendToTarget();\n        }\n    };\n    private HandlerThread mHandlerThread;\n    private BroadcastReceiver mUnmountReceiver = null;\n    private MusicPlaybackState mPlaybackStateStore;\n    private boolean mShowAlbumArtOnLockscreen;\n    private boolean mActivateXTrackSelector;\n    private SongPlayCount mSongPlayCount;\n    private RecentStore mRecentStore;\n    private final BroadcastReceiver mIntentReceiver = new BroadcastReceiver() {\n\n        @Override\n        public void onReceive(final Context context, final Intent intent) {\n            final String command = intent.getStringExtra(CMDNAME);\n\n\n            handleCommandIntent(intent);\n\n        }\n    };\n    private ContentObserver mMediaStoreObserver;\n\n    @Override\n    public IBinder onBind(final Intent intent) {\n        if (D) Log.d(TAG, "Service bound, intent = " + intent);\n        cancelShutdown();\n        mServiceInUse = true;\n        return mBinder;\n    }\n\n    @Override\n    public boolean onUnbind(final Intent intent) {\n        if (D) Log.d(TAG, "Service unbound");\n        mServiceInUse = false;\n        saveQueue(true);\n\n        if (mIsSupposedToBePlaying || mPausedByTransientLossOfFocus) {\n\n            return true;\n\n        } else if (mPlaylist.size() > 0 || mPlayerHandler.hasMessages(TRACK_ENDED)) {\n            scheduleDelayedShutdown();\n            return true;\n        }\n        stopSelf(mServiceStartId);\n\n        return true;\n    }\n\n    @Override\n    public void onRebind(final Intent intent) {\n        cancelShutdown();\n        mServiceInUse = true;\n    }\n\n    @Override\n    public void onCreate() {\n        if (D) Log.d(TAG, "Creating service");\n        super.onCreate();\n\n        mNotificationManager = NotificationManagerCompat.from(this);\n        createNotificationChannel();\n\n        // gets a pointer to the playback state store\n        mPlaybackStateStore = MusicPlaybackState.getInstance(this);\n        mSongPlayCount = SongPlayCount.getInstance(this);\n        mRecentStore = RecentStore.getInstance(this);\n\n\n        mHandlerThread = new HandlerThread("MusicPlayerHandler",\n                android.os.Process.THREAD_PRIORITY_BACKGROUND);\n        mHandlerThread.start();\n\n\n        mPlayerHandler = new MusicPlayerHandler(this, mHandlerThread.getLooper());\n\n\n        mAudioManager = (AudioManager) getSystemService(Context.AUDIO_SERVICE);\n        mMediaButtonReceiverComponent = new ComponentName(getPackageName(),\n                MediaButtonIntentReceiver.class.getName());\n        mAudioManager.registerMediaButtonEventReceiver(mMediaButtonReceiverComponent);\n\n        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP)\n            setUpMediaSession();\n        else if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.ICE_CREAM_SANDWICH)\n            setUpRemoteControlClient();\n\n        mPreferences = getSharedPreferences("Service", 0);\n        mCardId = getCardId();\n\n        registerExternalStorageListener();\n\n        mPlayer = new MultiPlayer(this);\n        mPlayer.setHandler(mPlayerHandler);\n\n        // Initialize the intent filter and each action\n        final IntentFilter filter = new IntentFilter();\n        filter.addAction(SERVICECMD);\n        filter.addAction(TOGGLEPAUSE_ACTION);\n        filter.addAction(PAUSE_ACTION);\n        filter.addAction(STOP_ACTION);\n        filter.addAction(NEXT_ACTION);\n        filter.addAction(PREVIOUS_ACTION);\n        filter.addAction(PREVIOUS_FORCE_ACTION);\n        filter.addAction(REPEAT_ACTION);\n        filter.addAction(SHUFFLE_ACTION);\n        filter.addAction(AudioManager.ACTION_AUDIO_BECOMING_NOISY);\n        filter.addAction(Intent.ACTION_SCREEN_ON);\n        // Attach the broadcast listener\n        registerReceiver(mIntentReceiver, filter);\n\n        mMediaStoreObserver = new MediaStoreObserver(mPlayerHandler);\n        getContentResolver().registerContentObserver(\n                MediaStore.Audio.Media.INTERNAL_CONTENT_URI, true, mMediaStoreObserver);\n        getContentResolver().registerContentObserver(\n                MediaStore.Audio.Media.EXTERNAL_CONTENT_URI, true, mMediaStoreObserver);\n\n        // Initialize the wake lock\n        final PowerManager powerManager = (PowerManager) getSystemService(Context.POWER_SERVICE);\n        mWakeLock = powerManager.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, getClass().getName());\n        mWakeLock.setReferenceCounted(false);\n\n\n        final Intent shutdownIntent = new Intent(this, MusicService.class);\n        shutdownIntent.setAction(SHUTDOWN);\n\n        mAlarmManager = (AlarmManager) getSystemService(Context.ALARM_SERVICE);\n        mShutdownIntent = PendingIntent.getService(this, 0, shutdownIntent, 0);\n\n        scheduleDelayedShutdown();\n\n        reloadQueueAfterPermissionCheck();\n        notifyChange(QUEUE_CHANGED);\n        notifyChange(META_CHANGED);\n        //Try to push LastFMCache\n        if (LastfmUserSession.getSession(this) != null) {\n            LastFmClient.getInstance(this).Scrobble(null);\n        }\n        PreferencesUtility pref = PreferencesUtility.getInstance(this);\n        mShowAlbumArtOnLockscreen = pref.getSetAlbumartLockscreen();\n        mActivateXTrackSelector = pref.getXPosedTrackselectorEnabled();\n    }\n\n    @SuppressWarnings("deprecation")\n    @TargetApi(Build.VERSION_CODES.ICE_CREAM_SANDWICH)\n    private void setUpRemoteControlClient() {\n        //Legacy for ICS\n        if (mRemoteControlClient == null) {\n            Intent mediaButtonIntent = new Intent(Intent.ACTION_MEDIA_BUTTON);\n            mediaButtonIntent.setComponent(mMediaButtonReceiverComponent);\n            PendingIntent mediaPendingIntent = PendingIntent.getBroadcast(this, 0, mediaButtonIntent, 0);\n\n            // create and register the remote control client\n            mRemoteControlClient = new RemoteControlClient(mediaPendingIntent);\n            mAudioManager.registerRemoteControlClient(mRemoteControlClient);\n        }\n\n        mRemoteControlClient.setTransportControlFlags(\n                RemoteControlClient.FLAG_KEY_MEDIA_PLAY |\n                        RemoteControlClient.FLAG_KEY_MEDIA_PAUSE |\n                        RemoteControlClient.FLAG_KEY_MEDIA_PREVIOUS |\n                        RemoteControlClient.FLAG_KEY_MEDIA_NEXT |\n                        RemoteControlClient.FLAG_KEY_MEDIA_STOP);\n    }\n\n    private void setUpMediaSession() {\n        mSession = new MediaSessionCompat(this, "Timber");\n        mSession.setCallback(new MediaSessionCompat.Callback() {\n            @Override\n            public void onPause() {\n                pause();\n                mPausedByTransientLossOfFocus = false;\n            }\n\n            @Override\n            public void onPlay() {\n                play();\n            }\n\n            @Override\n            public void onSeekTo(long pos) {\n                seek(pos);\n            }\n\n            @Override\n            public void onSkipToNext() {\n                gotoNext(true);\n            }\n\n            @Override\n            public void onSkipToPrevious() {\n                prev(false);\n            }\n\n            @Override\n            public void onStop() {\n                pause();\n                mPausedByTransientLossOfFocus = false;\n                seek(0);\n                releaseServiceUiAndStop();\n            }\n        });\n        mSession.setFlags(MediaSessionCompat.FLAG_HANDLES_TRANSPORT_CONTROLS\n                          | MediaSessionCompat.FLAG_HANDLES_MEDIA_BUTTONS);\n    }\n\n    @Override\n    public void onDestroy() {\n        if (D) Log.d(TAG, "Destroying service");\n        super.onDestroy();\n        //Try to push LastFMCache\n        if (LastfmUserSession.getSession(this).isLogedin()) {\n            LastFmClient.getInstance(this).Scrobble(null);\n        }\n        // Remove any sound effects\n        final Intent audioEffectsIntent = new Intent(\n                AudioEffect.ACTION_CLOSE_AUDIO_EFFECT_CONTROL_SESSION);\n        audioEffectsIntent.putExtra(AudioEffect.EXTRA_AUDIO_SESSION, getAudioSessionId());\n        audioEffectsIntent.putExtra(AudioEffect.EXTRA_PACKAGE_NAME, getPackageName());\n        sendBroadcast(audioEffectsIntent);\n\n\n        mAlarmManager.cancel(mShutdownIntent);\n\n        mPlayerHandler.removeCallbacksAndMessages(null);\n\n        if (TimberUtils.isJellyBeanMR2())\n            mHandlerThread.quitSafely();\n        else mHandlerThread.quit();\n\n        mPlayer.release();\n        mPlayer = null;\n\n        mAudioManager.abandonAudioFocus(mAudioFocusListener);\n        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP)\n            mSession.release();\n\n        getContentResolver().unregisterContentObserver(mMediaStoreObserver);\n\n        closeCursor();\n\n        unregisterReceiver(mIntentReceiver);\n        if (mUnmountReceiver != null) {\n            unregisterReceiver(mUnmountReceiver);\n            mUnmountReceiver = null;\n        }\n\n        mWakeLock.release();\n    }\n\n    @Override\n    public int onStartCommand(final Intent intent, final int flags, final int startId) {\n        if (D) Log.d(TAG, "Got new intent " + intent + ", startId = " + startId);\n        mServiceStartId = startId;\n\n        if (intent != null) {\n            final String action = intent.getAction();\n\n            if (SHUTDOWN.equals(action)) {\n                mShutdownScheduled = false;\n                releaseServiceUiAndStop();\n                return START_NOT_STICKY;\n            }\n\n            handleCommandIntent(intent);\n        }\n\n        scheduleDelayedShutdown();\n\n        if (intent != null && intent.getBooleanExtra(FROM_MEDIA_BUTTON, false)) {\n            MediaButtonIntentReceiver.completeWakefulIntent(intent);\n        }\n\n        return START_NOT_STICKY; //no sense to use START_STICKY with using startForeground\n    }\n\n    void scrobble() {\n        if (LastfmUserSession.getSession(this).isLogedin()) {\n            Log.d("Scrobble", "to LastFM");\n            String trackname = getTrackName();\n            if (trackname != null)\n                LastFmClient.getInstance(this).Scrobble(new ScrobbleQuery(getArtistName(), trackname, System.currentTimeMillis() / 1000));\n        }\n    }\n\n    private void releaseServiceUiAndStop() {\n        if (isPlaying()\n                || mPausedByTransientLossOfFocus\n                || mPlayerHandler.hasMessages(TRACK_ENDED)) {\n            return;\n        }\n\n        if (D) Log.d(TAG, "Nothing is playing anymore, releasing notification");\n        cancelNotification();\n        mAudioManager.abandonAudioFocus(mAudioFocusListener);\n        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP)\n            mSession.setActive(false);\n\n        if (!mServiceInUse) {\n            saveQueue(true);\n            stopSelf(mServiceStartId);\n        }\n    }\n\n    private void handleCommandIntent(Intent intent) {\n        final String action = intent.getAction();\n        final String command = SERVICECMD.equals(action) ? intent.getStringExtra(CMDNAME) : null;\n\n        if (D) Log.d(TAG, "handleCommandIntent: action = " + action + ", command = " + command);\n\n        if (NotificationHelper.checkIntent(intent)) {\n            goToPosition(mPlayPos + NotificationHelper.getPosition(intent));\n            return;\n        }\n\n        if (CMDNEXT.equals(command) || NEXT_ACTION.equals(action)) {\n            gotoNext(true);\n        } else if (CMDPREVIOUS.equals(command) || PREVIOUS_ACTION.equals(action)\n                || PREVIOUS_FORCE_ACTION.equals(action)) {\n            prev(PREVIOUS_FORCE_ACTION.equals(action));\n        } else if (CMDTOGGLEPAUSE.equals(command) || TOGGLEPAUSE_ACTION.equals(action)) {\n            if (isPlaying()) {\n                pause();\n                mPausedByTransientLossOfFocus = false;\n            } else {\n                play();\n            }\n        } else if (CMDPAUSE.equals(command) || PAUSE_ACTION.equals(action)) {\n            pause();\n            mPausedByTransientLossOfFocus = false;\n        } else if (CMDPLAY.equals(command)) {\n            play();\n        } else if (CMDSTOP.equals(command) || STOP_ACTION.equals(action)) {\n            pause();\n            mPausedByTransientLossOfFocus = false;\n            seek(0);\n            releaseServiceUiAndStop();\n        } else if (REPEAT_ACTION.equals(action)) {\n            cycleRepeat();\n        } else if (SHUFFLE_ACTION.equals(action)) {\n            cycleShuffle();\n        } else if (UPDATE_PREFERENCES.equals(action)) {\n            onPreferencesUpdate(intent.getExtras());\n        }\n        else if (AudioManager.ACTION_AUDIO_BECOMING_NOISY.equals(action)) {\n            if (PreferencesUtility.getInstance(getApplicationContext()).pauseEnabledOnDetach()) {\n                pause();\n            }\n        }\n    }\n\n    private void onPreferencesUpdate(Bundle extras) {\n        mShowAlbumArtOnLockscreen = extras.getBoolean("lockscreen", mShowAlbumArtOnLockscreen);\n        mActivateXTrackSelector = extras.getBoolean("xtrack",mActivateXTrackSelector);\n        LastfmUserSession session = LastfmUserSession.getSession(this);\n        session.mToken = extras.getString("lf_token", session.mToken);\n        session.mUsername = extras.getString("lf_user", session.mUsername);\n        if ("logout".equals(session.mToken)) {\n            session.mToken = null;\n            session.mUsername = null;\n        }\n        notifyChange(META_CHANGED);\n\n    }\n\n    private void updateNotification() {\n        final int newNotifyMode;\n        if (isPlaying()) {\n            newNotifyMode = NOTIFY_MODE_FOREGROUND;\n        } else if (recentlyPlayed()) {\n            newNotifyMode = NOTIFY_MODE_BACKGROUND;\n        } else {\n            newNotifyMode = NOTIFY_MODE_NONE;\n        }\n\n        int notificationId = hashCode();\n        if (mNotifyMode != newNotifyMode) {\n            if (mNotifyMode == NOTIFY_MODE_FOREGROUND) {\n                if (TimberUtils.isLollipop())\n                    stopForeground(newNotifyMode == NOTIFY_MODE_NONE);\n                else\n                    stopForeground(newNotifyMode == NOTIFY_MODE_NONE || newNotifyMode == NOTIFY_MODE_BACKGROUND);\n            } else if (newNotifyMode == NOTIFY_MODE_NONE) {\n                mNotificationManager.cancel(notificationId);\n                mNotificationPostTime = 0;\n            }\n        }\n\n        if (newNotifyMode == NOTIFY_MODE_FOREGROUND) {\n            startForeground(notificationId, buildNotification());\n        } else if (newNotifyMode == NOTIFY_MODE_BACKGROUND) {\n            mNotificationManager.notify(notificationId, buildNotification());\n        }\n\n        mNotifyMode = newNotifyMode;\n    }\n\n    private void cancelNotification() {\n        stopForeground(true);\n        mNotificationManager.cancel(hashCode());\n        mNotificationPostTime = 0;\n        mNotifyMode = NOTIFY_MODE_NONE;\n    }\n\n    private int getCardId() {\n        if (TimberUtils.isMarshmallow()) {\n            if (Nammu.checkPermission(Manifest.permission.READ_EXTERNAL_STORAGE)) {\n                return getmCardId();\n            } else return 0;\n        } else {\n            return getmCardId();\n        }\n    }\n\n    private int getmCardId() {\n        final ContentResolver resolver = getContentResolver();\n        Cursor cursor = resolver.query(Uri.parse("content://media/external/fs_id"), null, null,\n                null, null);\n        int mCardId = -1;\n        if (cursor != null && cursor.moveToFirst()) {\n            mCardId = cursor.getInt(0);\n            cursor.close();\n            cursor = null;\n        }\n        return mCardId;\n    }\n\n    public void closeExternalStorageFiles(final String storagePath) {\n        stop(true);\n        notifyChange(QUEUE_CHANGED);\n        notifyChange(META_CHANGED);\n    }\n\n    public void registerExternalStorageListener() {\n        if (mUnmountReceiver == null) {\n            mUnmountReceiver = new BroadcastReceiver() {\n\n\n                @Override\n                public void onReceive(final Context context, final Intent intent) {\n                    final String action = intent.getAction();\n                    if (action.equals(Intent.ACTION_MEDIA_EJECT)) {\n                        saveQueue(true);\n                        mQueueIsSaveable = false;\n                        closeExternalStorageFiles(intent.getData().getPath());\n                    } else if (action.equals(Intent.ACTION_MEDIA_MOUNTED)) {\n                        mMediaMountedCount++;\n                        mCardId = getCardId();\n                        reloadQueueAfterPermissionCheck();\n                        mQueueIsSaveable = true;\n                        notifyChange(QUEUE_CHANGED);\n                        notifyChange(META_CHANGED);\n                    }\n                }\n            };\n            final IntentFilter filter = new IntentFilter();\n            filter.addAction(Intent.ACTION_MEDIA_EJECT);\n            filter.addAction(Intent.ACTION_MEDIA_MOUNTED);\n            filter.addDataScheme("file");\n            registerReceiver(mUnmountReceiver, filter);\n        }\n    }\n\n    private void scheduleDelayedShutdown() {\n        if (D) Log.v(TAG, "Scheduling shutdown in " + IDLE_DELAY + " ms");\n        mAlarmManager.set(AlarmManager.ELAPSED_REALTIME_WAKEUP,\n                SystemClock.elapsedRealtime() + IDLE_DELAY, mShutdownIntent);\n        mShutdownScheduled = true;\n    }\n\n    private void cancelShutdown() {\n        if (D) Log.d(TAG, "Cancelling delayed shutdown, scheduled = " + mShutdownScheduled);\n        if (mShutdownScheduled) {\n            mAlarmManager.cancel(mShutdownIntent);\n            mShutdownScheduled = false;\n        }\n    }\n\n    private void stop(final boolean goToIdle) {\n        if (D) Log.d(TAG, "Stopping playback, goToIdle = " + goToIdle);\n        long duration = this.duration();\n        long position = this.position();\n        if (duration > 30000 && (position >= duration / 2) || position > 240000) {\n            scrobble();\n        }\n\n        if (mPlayer.isInitialized()) {\n            mPlayer.stop();\n        }\n        mFileToPlay = null;\n        closeCursor();\n        if (goToIdle) {\n            setIsSupposedToBePlaying(false, false);\n        } else {\n            if (TimberUtils.isLollipop())\n                stopForeground(false);\n            else stopForeground(true);\n        }\n    }\n\n    private int removeTracksInternal(int first, int last) {\n        synchronized (this) {\n            if (last < first) {\n                return 0;\n            } else if (first < 0) {\n                first = 0;\n            } else if (last >= mPlaylist.size()) {\n                last = mPlaylist.size() - 1;\n            }\n\n            boolean gotonext = false;\n            if (first <= mPlayPos && mPlayPos <= last) {\n                mPlayPos = first;\n                gotonext = true;\n            } else if (mPlayPos > last) {\n                mPlayPos -= last - first + 1;\n            }\n            final int numToRemove = last - first + 1;\n\n            if (first == 0 && last == mPlaylist.size() - 1) {\n                mPlayPos = -1;\n                mNextPlayPos = -1;\n                mPlaylist.clear();\n                mHistory.clear();\n            } else {\n                for (int i = 0; i < numToRemove; i++) {\n                    mPlaylist.remove(first);\n                }\n\n                ListIterator<Integer> positionIterator = mHistory.listIterator();\n                while (positionIterator.hasNext()) {\n                    int pos = positionIterator.next();\n                    if (pos >= first && pos <= last) {\n                        positionIterator.remove();\n                    } else if (pos > last) {\n                        positionIterator.set(pos - numToRemove);\n                    }\n                }\n            }\n            if (gotonext) {\n                if (mPlaylist.size() == 0) {\n                    stop(true);\n                    mPlayPos = -1;\n                    closeCursor();\n                } else {\n                    if (mShuffleMode != SHUFFLE_NONE) {\n                        mPlayPos = getNextPosition(true);\n                    } else if (mPlayPos >= mPlaylist.size()) {\n                        mPlayPos = 0;\n                    }\n                    final boolean wasPlaying = isPlaying();\n                    stop(false);\n                    openCurrentAndNext();\n                    if (wasPlaying) {\n                        play();\n                    }\n                }\n                notifyChange(META_CHANGED);\n            }\n            return last - first + 1;\n        }\n    }\n\n    private void addToPlayList(final long[] list, int position, long sourceId, TimberUtils.IdType sourceType) {\n        final int addlen = list.length;\n        if (position < 0) {\n            mPlaylist.clear();\n            position = 0;\n        }\n\n        mPlaylist.ensureCapacity(mPlaylist.size() + addlen);\n        if (position > mPlaylist.size()) {\n            position = mPlaylist.size();\n        }\n\n        final ArrayList<MusicPlaybackTrack> arrayList = new ArrayList<MusicPlaybackTrack>(addlen);\n        for (int i = 0; i < list.length; i++) {\n            arrayList.add(new MusicPlaybackTrack(list[i], sourceId, sourceType, i));\n        }\n\n        mPlaylist.addAll(position, arrayList);\n\n        if (mPlaylist.size() == 0) {\n            closeCursor();\n            notifyChange(META_CHANGED);\n        }\n    }\n\n    private void updateCursor(final long trackId) {\n        updateCursor("_id=" + trackId, null);\n    }\n\n    private void updateCursor(final String selection, final String[] selectionArgs) {\n        synchronized (this) {\n            closeCursor();\n            mCursor = openCursorAndGoToFirst(MediaStore.Audio.Media.EXTERNAL_CONTENT_URI,\n                    PROJECTION, selection, selectionArgs);\n        }\n        updateAlbumCursor();\n    }\n\n    private void updateCursor(final Uri uri) {\n        synchronized (this) {\n            closeCursor();\n            mCursor = openCursorAndGoToFirst(uri, PROJECTION, null, null);\n        }\n        updateAlbumCursor();\n    }\n\n    private void updateAlbumCursor() {\n        long albumId = getAlbumId();\n        if (albumId >= 0) {\n            mAlbumCursor = openCursorAndGoToFirst(MediaStore.Audio.Albums.EXTERNAL_CONTENT_URI,\n                    ALBUM_PROJECTION, "_id=" + albumId, null);\n        } else {\n            mAlbumCursor = null;\n        }\n    }\n\n    private Cursor openCursorAndGoToFirst(Uri uri, String[] projection,\n                                          String selection, String[] selectionArgs) {\n        Cursor c = getContentResolver().query(uri, projection,\n                selection, selectionArgs, null);\n        if (c == null) {\n            return null;\n        }\n        if (!c.moveToFirst()) {\n            c.close();\n            return null;\n        }\n        return c;\n    }\n\n    private synchronized void closeCursor() {\n        if (mCursor != null) {\n            mCursor.close();\n            mCursor = null;\n        }\n        if (mAlbumCursor != null) {\n            mAlbumCursor.close();\n            mAlbumCursor = null;\n        }\n    }\n\n    private void openCurrentAndNext() {\n        openCurrentAndMaybeNext(true);\n    }\n\n    private void openCurrentAndMaybeNext(final boolean openNext) {\n        synchronized (this) {\n            closeCursor();\n\n            if (mPlaylist.size() == 0) {\n                return;\n            }\n            stop(false);\n\n            boolean shutdown = false;\n\n            updateCursor(mPlaylist.get(mPlayPos).mId);\n            while (true) {\n                if (mCursor != null\n                        && openFile(MediaStore.Audio.Media.EXTERNAL_CONTENT_URI + "/"\n                        + mCursor.getLong(IDCOLIDX))) {\n                    break;\n                }\n\n                closeCursor();\n                if (mOpenFailedCounter++ < 10 && mPlaylist.size() > 1) {\n                    final int pos = getNextPosition(false);\n                    if (pos < 0) {\n                        shutdown = true;\n                        break;\n                    }\n                    mPlayPos = pos;\n                    stop(false);\n                    mPlayPos = pos;\n                    updateCursor(mPlaylist.get(mPlayPos).mId);\n                } else {\n                    mOpenFailedCounter = 0;\n                    Log.w(TAG, "Failed to open file for playback");\n                    shutdown = true;\n                    break;\n                }\n            }\n\n            if (shutdown) {\n                scheduleDelayedShutdown();\n                if (mIsSupposedToBePlaying) {\n                    mIsSupposedToBePlaying = false;\n                    notifyChange(PLAYSTATE_CHANGED);\n                }\n            } else if (openNext) {\n                setNextTrack();\n            }\n        }\n    }\n\n    private void sendErrorMessage(final String trackName) {\n        final Intent i = new Intent(TRACK_ERROR);\n        i.putExtra(TrackErrorExtra.TRACK_NAME, trackName);\n        sendBroadcast(i);\n    }\n\n    private int getNextPosition(final boolean force) {\n        if (mPlaylist == null || mPlaylist.isEmpty()) {\n            return -1;\n        }\n        if (!force && mRepeatMode == REPEAT_CURRENT) {\n            if (mPlayPos < 0) {\n                return 0;\n            }\n            return mPlayPos;\n        } else if (mShuffleMode == SHUFFLE_NORMAL) {\n            final int numTracks = mPlaylist.size();\n\n\n            final int[] trackNumPlays = new int[numTracks];\n            for (int i = 0; i < numTracks; i++) {\n                trackNumPlays[i] = 0;\n            }\n\n\n            final int numHistory = mHistory.size();\n            for (int i = 0; i < numHistory; i++) {\n                final int idx = mHistory.get(i).intValue();\n                if (idx >= 0 && idx < numTracks) {\n                    trackNumPlays[idx]++;\n                }\n            }\n\n            if (mPlayPos >= 0 && mPlayPos < numTracks) {\n                trackNumPlays[mPlayPos]++;\n            }\n\n            int minNumPlays = Integer.MAX_VALUE;\n            int numTracksWithMinNumPlays = 0;\n            for (int i = 0; i < trackNumPlays.length; i++) {\n                if (trackNumPlays[i] < minNumPlays) {\n                    minNumPlays = trackNumPlays[i];\n                    numTracksWithMinNumPlays = 1;\n                } else if (trackNumPlays[i] == minNumPlays) {\n                    numTracksWithMinNumPlays++;\n                }\n            }\n\n\n            if (minNumPlays > 0 && numTracksWithMinNumPlays == numTracks\n                    && mRepeatMode != REPEAT_ALL && !force) {\n                return -1;\n            }\n\n\n            int skip = mShuffler.nextInt(numTracksWithMinNumPlays);\n            for (int i = 0; i < trackNumPlays.length; i++) {\n                if (trackNumPlays[i] == minNumPlays) {\n                    if (skip == 0) {\n                        return i;\n                    } else {\n                        skip--;\n                    }\n                }\n            }\n\n            if (D)\n                Log.e(TAG, "Getting the next position resulted did not get a result when it should have");\n            return -1;\n        } else if (mShuffleMode == SHUFFLE_AUTO) {\n            doAutoShuffleUpdate();\n            return mPlayPos + 1;\n        } else {\n            if (mPlayPos >= mPlaylist.size() - 1) {\n                if (mRepeatMode == REPEAT_NONE && !force) {\n                    return -1;\n                } else if (mRepeatMode == REPEAT_ALL || force) {\n                    return 0;\n                }\n                return -1;\n            } else {\n                return mPlayPos + 1;\n            }\n        }\n    }\n\n    private void setNextTrack() {\n        setNextTrack(getNextPosition(false));\n    }\n\n    private void setNextTrack(int position) {\n        mNextPlayPos = position;\n        if (D) Log.d(TAG, "setNextTrack: next play position = " + mNextPlayPos);\n        if (mNextPlayPos >= 0 && mPlaylist != null && mNextPlayPos < mPlaylist.size()) {\n            final long id = mPlaylist.get(mNextPlayPos).mId;\n            mPlayer.setNextDataSource(MediaStore.Audio.Media.EXTERNAL_CONTENT_URI + "/" + id);\n        } else {\n            mPlayer.setNextDataSource(null);\n        }\n    }\n\n    private boolean makeAutoShuffleList() {\n        Cursor cursor = null;\n        try {\n            cursor = getContentResolver().query(MediaStore.Audio.Media.EXTERNAL_CONTENT_URI,\n                    new String[]{\n                            MediaStore.Audio.Media._ID\n                    }, MediaStore.Audio.Media.IS_MUSIC + "=1", null, null);\n            if (cursor == null || cursor.getCount() == 0) {\n                return false;\n            }\n            final int len = cursor.getCount();\n            final long[] list = new long[len];\n            for (int i = 0; i < len; i++) {\n                cursor.moveToNext();\n                list[i] = cursor.getLong(0);\n            }\n            mAutoShuffleList = list;\n            return true;\n        } catch (final RuntimeException e) {\n        } finally {\n            if (cursor != null) {\n                cursor.close();\n                cursor = null;\n            }\n        }\n        return false;\n    }\n\n    private void doAutoShuffleUpdate() {\n        boolean notify = false;\n        if (mPlayPos > 10) {\n            removeTracks(0, mPlayPos - 9);\n            notify = true;\n        }\n        final int toAdd = 7 - (mPlaylist.size() - (mPlayPos < 0 ? -1 : mPlayPos));\n        for (int i = 0; i < toAdd; i++) {\n            int lookback = mHistory.size();\n            int idx = -1;\n            while (true) {\n                idx = mShuffler.nextInt(mAutoShuffleList.length);\n                if (!wasRecentlyUsed(idx, lookback)) {\n                    break;\n                }\n                lookback /= 2;\n            }\n            mHistory.add(idx);\n            if (mHistory.size() > MAX_HISTORY_SIZE) {\n                mHistory.remove(0);\n            }\n            mPlaylist.add(new MusicPlaybackTrack(mAutoShuffleList[idx], -1, TimberUtils.IdType.NA, -1));\n            notify = true;\n        }\n        if (notify) {\n            notifyChange(QUEUE_CHANGED);\n        }\n    }\n\n    private boolean wasRecentlyUsed(final int idx, int lookbacksize) {\n        if (lookbacksize == 0) {\n            return false;\n        }\n        final int histsize = mHistory.size();\n        if (histsize < lookbacksize) {\n            lookbacksize = histsize;\n        }\n        final int maxidx = histsize - 1;\n        for (int i = 0; i < lookbacksize; i++) {\n            final long entry = mHistory.get(maxidx - i);\n            if (entry == idx) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    private void notifyChange(final String what) {\n        if (D) Log.d(TAG, "notifyChange: what = " + what);\n\n        // Update the lockscreen controls\n        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP)\n            updateMediaSession(what);\n        else if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.ICE_CREAM_SANDWICH)\n            updateRemoteControlClient(what);\n\n        if (what.equals(POSITION_CHANGED)) {\n            return;\n        }\n\n        final Intent intent = new Intent(what);\n        intent.putExtra("id", getAudioId());\n        intent.putExtra("artist", getArtistName());\n        intent.putExtra("album", getAlbumName());\n        intent.putExtra("albumid", getAlbumId());\n        intent.putExtra("track", getTrackName());\n        intent.putExtra("playing", isPlaying());\n\n        sendStickyBroadcast(intent);\n\n        final Intent musicIntent = new Intent(intent);\n        musicIntent.setAction(what.replace(TIMBER_PACKAGE_NAME, MUSIC_PACKAGE_NAME));\n        sendStickyBroadcast(musicIntent);\n\n        if (what.equals(META_CHANGED)) {\n\n            mRecentStore.addSongId(getAudioId());\n            mSongPlayCount.bumpSongCount(getAudioId());\n\n        } else if (what.equals(QUEUE_CHANGED)) {\n            saveQueue(true);\n            if (isPlaying()) {\n\n                if (mNextPlayPos >= 0 && mNextPlayPos < mPlaylist.size()\n                        && getShuffleMode() != SHUFFLE_NONE) {\n                    setNextTrack(mNextPlayPos);\n                } else {\n                    setNextTrack();\n                }\n            }\n        } else {\n            saveQueue(false);\n        }\n\n        if (what.equals(PLAYSTATE_CHANGED)) {\n            updateNotification();\n        }\n\n    }\n\n    @SuppressWarnings("deprecation")\n    @TargetApi(Build.VERSION_CODES.ICE_CREAM_SANDWICH)\n    private void updateRemoteControlClient(final String what) {\n        //Legacy for ICS\n        if (mRemoteControlClient != null) {\n            int playState = mIsSupposedToBePlaying\n                    ? RemoteControlClient.PLAYSTATE_PLAYING\n                    : RemoteControlClient.PLAYSTATE_PAUSED;\n            if (what.equals(META_CHANGED) || what.equals(QUEUE_CHANGED)) {\n                Bitmap albumArt = null;\n                if (mShowAlbumArtOnLockscreen) {\n                    albumArt = ImageLoader.getInstance().loadImageSync(TimberUtils.getAlbumArtUri(getAlbumId()).toString());\n                    if (albumArt != null) {\n\n                        Bitmap.Config config = albumArt.getConfig();\n                        if (config == null) {\n                            config = Bitmap.Config.ARGB_8888;\n                        }\n                        albumArt = albumArt.copy(config, false);\n                    }\n                }\n\n                RemoteControlClient.MetadataEditor editor = mRemoteControlClient.editMetadata(true);\n                editor.putString(MediaMetadataRetriever.METADATA_KEY_ALBUM, getAlbumName());\n                editor.putString(MediaMetadataRetriever.METADATA_KEY_ARTIST, getArtistName());\n                editor.putString(MediaMetadataRetriever.METADATA_KEY_TITLE, getTrackName());\n                editor.putLong(MediaMetadataRetriever.METADATA_KEY_DURATION, duration());\n                editor.putBitmap(MediaMetadataEditor.BITMAP_KEY_ARTWORK, albumArt);\n                editor.apply();\n\n            }\n            mRemoteControlClient.setPlaybackState(playState);\n        }\n    }\n\n\n    private void updateMediaSession(final String what) {\n        int playState = mIsSupposedToBePlaying\n                ? PlaybackStateCompat.STATE_PLAYING\n                : PlaybackStateCompat.STATE_PAUSED;\n\n        if (what.equals(PLAYSTATE_CHANGED) || what.equals(POSITION_CHANGED)) {\n            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {\n                mSession.setPlaybackState(new PlaybackStateCompat.Builder()\n                        .setState(playState, position(), 1.0f)\n                        .setActions(PlaybackStateCompat.ACTION_PLAY | PlaybackStateCompat.ACTION_PAUSE | PlaybackStateCompat.ACTION_PLAY_PAUSE |\n                                PlaybackStateCompat.ACTION_SKIP_TO_NEXT | PlaybackStateCompat.ACTION_SKIP_TO_PREVIOUS)\n                        .build());\n            }\n        } else if (what.equals(META_CHANGED) || what.equals(QUEUE_CHANGED)) {\n            Bitmap albumArt = null;\n            if (mShowAlbumArtOnLockscreen) {\n                albumArt = ImageLoader.getInstance().loadImageSync(TimberUtils.getAlbumArtUri(getAlbumId()).toString());\n                if (albumArt != null) {\n\n                    Bitmap.Config config = albumArt.getConfig();\n                    if (config == null) {\n                        config = Bitmap.Config.ARGB_8888;\n                    }\n                    albumArt = albumArt.copy(config, false);\n                }\n            }\n            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {\n                mSession.setMetadata(new MediaMetadataCompat.Builder()\n                        .putString(MediaMetadataCompat.METADATA_KEY_ARTIST, getArtistName())\n                        .putString(MediaMetadataCompat.METADATA_KEY_ALBUM_ARTIST, getAlbumArtistName())\n                        .putString(MediaMetadataCompat.METADATA_KEY_ALBUM, getAlbumName())\n                        .putString(MediaMetadataCompat.METADATA_KEY_TITLE, getTrackName())\n                        .putLong(MediaMetadataCompat.METADATA_KEY_DURATION, duration())\n                        .putLong(MediaMetadataCompat.METADATA_KEY_TRACK_NUMBER, getQueuePosition() + 1)\n                        .putLong(MediaMetadataCompat.METADATA_KEY_NUM_TRACKS, getQueue().length)\n                        .putString(MediaMetadataCompat.METADATA_KEY_GENRE, getGenreName())\n                        .putBitmap(MediaMetadataCompat.METADATA_KEY_ALBUM_ART, albumArt)\n                        .build());\n\n                mSession.setPlaybackState(new PlaybackStateCompat.Builder()\n                        .setState(playState, position(), 1.0f)\n                        .setActions(PlaybackStateCompat.ACTION_PLAY | PlaybackStateCompat.ACTION_PAUSE | PlaybackStateCompat.ACTION_PLAY_PAUSE |\n                                PlaybackStateCompat.ACTION_SKIP_TO_NEXT | PlaybackStateCompat.ACTION_SKIP_TO_PREVIOUS)\n                        .build());\n            }\n        }\n    }\n\n    private void createNotificationChannel() {\n        if (TimberUtils.isOreo()) {\n            CharSequence name = "Timber";\n            int importance = NotificationManager.IMPORTANCE_LOW;\n            NotificationManager manager = (NotificationManager) getSystemService(Context.NOTIFICATION_SERVICE);\n            NotificationChannel mChannel = new NotificationChannel(CHANNEL_ID, name, importance);\n            manager.createNotificationChannel(mChannel);\n        }\n    }\n\n    private Notification buildNotification() {\n        final String albumName = getAlbumName();\n        final String artistName = getArtistName();\n        final boolean isPlaying = isPlaying();\n        String text = TextUtils.isEmpty(albumName)\n                ? artistName : artistName + " - " + albumName;\n\n        int playButtonResId = isPlaying\n                ? R.drawable.ic_pause_white_36dp : R.drawable.ic_play_white_36dp;\n\n        Intent nowPlayingIntent = NavigationUtils.getNowPlayingIntent(this);\n        PendingIntent clickIntent = PendingIntent.getActivity(this, 0, nowPlayingIntent, PendingIntent.FLAG_UPDATE_CURRENT);\n        Bitmap artwork;\n        artwork = ImageLoader.getInstance().loadImageSync(TimberUtils.getAlbumArtUri(getAlbumId()).toString());\n\n        if (artwork == null) {\n            artwork = ImageLoader.getInstance().loadImageSync("drawable://" + R.drawable.ic_empty_music2);\n        }\n\n        if (mNotificationPostTime == 0) {\n            mNotificationPostTime = System.currentTimeMillis();\n        }\n\n        androidx.core.app.NotificationCompat.Builder builder = new androidx.core.app.NotificationCompat.Builder(this, CHANNEL_ID)\n                .setSmallIcon(R.drawable.ic_notification)\n                .setLargeIcon(artwork)\n                .setContentIntent(clickIntent)\n                .setContentTitle(getTrackName())\n                .setContentText(text)\n                .setWhen(mNotificationPostTime)\n                .addAction(R.drawable.ic_skip_previous_white_36dp,\n                        "",\n                        retrievePlaybackAction(PREVIOUS_ACTION))\n                .addAction(playButtonResId, "",\n                        retrievePlaybackAction(TOGGLEPAUSE_ACTION))\n                .addAction(R.drawable.ic_skip_next_white_36dp,\n                        "",\n                        retrievePlaybackAction(NEXT_ACTION));\n\n        if (TimberUtils.isJellyBeanMR1()) {\n            builder.setShowWhen(false);\n        }\n\n        if (TimberUtils.isLollipop()) {\n            builder.setVisibility(Notification.VISIBILITY_PUBLIC);\n            NotificationCompat.MediaStyle style = new NotificationCompat.MediaStyle()\n                    .setMediaSession(mSession.getSessionToken())\n                    .setShowActionsInCompactView(0, 1, 2, 3);\n            builder.setStyle(style);\n        }\n        if (artwork != null && TimberUtils.isLollipop()) {\n            builder.setColor(Palette.from(artwork).generate().getVibrantColor(Color.parseColor("#403f4d")));\n        }\n\n        if (TimberUtils.isOreo()) {\n            builder.setColorized(true);\n        }\n\n        Notification n = builder.build();\n\n        if (mActivateXTrackSelector) {\n            addXTrackSelector(n);\n        }\n\n        return n;\n    }\n\n    private void addXTrackSelector(Notification n) {\n        if (NotificationHelper.isSupported(n)) {\n            StringBuilder selection = new StringBuilder();\n            StringBuilder order = new StringBuilder().append("CASE _id \\n");\n            for (int i = 0; i < mPlaylist.size(); i++) {\n                selection.append("_id=").append(mPlaylist.get(i).mId).append(" OR ");\n                order.append("WHEN ").append(mPlaylist.get(i).mId).append(" THEN ").append(i).append("\\n");\n            }\n            order.append("END");\n            Cursor c = getContentResolver().query(MediaStore.Audio.Media.EXTERNAL_CONTENT_URI, NOTIFICATION_PROJECTION, selection.substring(0, selection.length() - 3), null, order.toString());\n            if (c != null && c.getCount() != 0) {\n                c.moveToFirst();\n                ArrayList<Bundle> list = new ArrayList<>();\n                do {\n                    TrackItem t = new TrackItem()\n                            .setArt(TimberUtils.getAlbumArtUri(c.getLong(c.getColumnIndexOrThrow(AudioColumns.ALBUM_ID))))\n                            .setTitle(c.getString(c.getColumnIndexOrThrow(AudioColumns.TITLE)))\n                            .setArtist(c.getString(c.getColumnIndexOrThrow(AudioColumns.ARTIST)))\n                            .setDuration(TimberUtils.makeShortTimeString(this, c.getInt(c.getColumnIndexOrThrow(AudioColumns.DURATION)) / 1000));\n                    list.add(t.get());\n                } while (c.moveToNext());\n                try {\n                    NotificationHelper.insertToNotification(n, list, this, getQueuePosition());\n                } catch (ModNotInstalledException e) {\n                    e.printStackTrace();\n                }\n                c.close();\n            }\n        }\n    }\n\n    private final PendingIntent retrievePlaybackAction(final String action) {\n        final ComponentName serviceName = new ComponentName(this, MusicService.class);\n        Intent intent = new Intent(action);\n        intent.setComponent(serviceName);\n\n        return PendingIntent.getService(this, 0, intent, 0);\n    }\n\n    private void saveQueue(final boolean full) {\n        if (!mQueueIsSaveable) {\n            return;\n        }\n\n        final SharedPreferences.Editor editor = mPreferences.edit();\n        if (full) {\n            mPlaybackStateStore.saveState(mPlaylist,\n                    mShuffleMode != SHUFFLE_NONE ? mHistory : null);\n            editor.putInt("cardid", mCardId);\n        }\n        editor.putInt("curpos", mPlayPos);\n        if (mPlayer.isInitialized()) {\n            editor.putLong("seekpos", mPlayer.position());\n        }\n        editor.putInt("repeatmode", mRepeatMode);\n        editor.putInt("shufflemode", mShuffleMode);\n        editor.apply();\n    }\n\n    private void reloadQueueAfterPermissionCheck() {\n        if (TimberUtils.isMarshmallow()) {\n            if (Nammu.checkPermission(Manifest.permission.READ_EXTERNAL_STORAGE)) {\n                reloadQueue();\n            }\n        } else {\n            reloadQueue();\n        }\n    }\n\n    private void reloadQueue() {\n        int id = mCardId;\n        if (mPreferences.contains("cardid")) {\n            id = mPreferences.getInt("cardid", ~mCardId);\n        }\n        if (id == mCardId) {\n            mPlaylist = mPlaybackStateStore.getQueue();\n        }\n        if (mPlaylist.size() > 0) {\n            final int pos = mPreferences.getInt("curpos", 0);\n            if (pos < 0 || pos >= mPlaylist.size()) {\n                mPlaylist.clear();\n                return;\n            }\n            mPlayPos = pos;\n            updateCursor(mPlaylist.get(mPlayPos).mId);\n            if (mCursor == null) {\n                SystemClock.sleep(3000);\n                updateCursor(mPlaylist.get(mPlayPos).mId);\n            }\n            synchronized (this) {\n                closeCursor();\n                mOpenFailedCounter = 20;\n                openCurrentAndNext();\n            }\n            if (!mPlayer.isInitialized()) {\n                mPlaylist.clear();\n                return;\n            }\n\n            final long seekpos = mPreferences.getLong("seekpos", 0);\n            seek(seekpos >= 0 && seekpos < duration() ? seekpos : 0);\n\n            if (D) {\n                Log.d(TAG, "restored queue, currently at position "\n                        + position() + "/" + duration()\n                        + " (requested " + seekpos + ")");\n            }\n\n            int repmode = mPreferences.getInt("repeatmode", REPEAT_NONE);\n            if (repmode != REPEAT_ALL && repmode != REPEAT_CURRENT) {\n                repmode = REPEAT_NONE;\n            }\n            mRepeatMode = repmode;\n\n            int shufmode = mPreferences.getInt("shufflemode", SHUFFLE_NONE);\n            if (shufmode != SHUFFLE_AUTO && shufmode != SHUFFLE_NORMAL) {\n                shufmode = SHUFFLE_NONE;\n            }\n            if (shufmode != SHUFFLE_NONE) {\n                mHistory = mPlaybackStateStore.getHistory(mPlaylist.size());\n            }\n            if (shufmode == SHUFFLE_AUTO) {\n                if (!makeAutoShuffleList()) {\n                    shufmode = SHUFFLE_NONE;\n                }\n            }\n            mShuffleMode = shufmode;\n        }\n    }\n\n    public boolean openFile(final String path) {\n        if (D) Log.d(TAG, "openFile: path = " + path);\n        synchronized (this) {\n            if (path == null) {\n                return false;\n            }\n\n            if (mCursor == null) {\n                Uri uri = Uri.parse(path);\n                boolean shouldAddToPlaylist = true;\n                long id = -1;\n                try {\n                    id = Long.valueOf(uri.getLastPathSegment());\n                } catch (NumberFormatException ex) {\n                    // Ignore\n                }\n\n                if (id != -1 && path.startsWith(\n                        MediaStore.Audio.Media.EXTERNAL_CONTENT_URI.toString())) {\n                    updateCursor(uri);\n\n                } else if (id != -1 && path.startsWith(\n                        MediaStore.Files.getContentUri("external").toString())) {\n                    updateCursor(id);\n\n                } else if (path.startsWith("content://downloads/")) {\n\n                    String mpUri = getValueForDownloadedFile(this, uri, "mediaprovider_uri");\n                    if (D) Log.i(TAG, "Downloaded file\'s MP uri : " + mpUri);\n                    if (!TextUtils.isEmpty(mpUri)) {\n                        if (openFile(mpUri)) {\n                            notifyChange(META_CHANGED);\n                            return true;\n                        } else {\n                            return false;\n                        }\n                    } else {\n                        updateCursorForDownloadedFile(this, uri);\n                        shouldAddToPlaylist = false;\n                    }\n\n                } else {\n                    String where = MediaStore.Audio.Media.DATA + "=?";\n                    String[] selectionArgs = new String[]{path};\n                    updateCursor(where, selectionArgs);\n                }\n                try {\n                    if (mCursor != null && shouldAddToPlaylist) {\n                        mPlaylist.clear();\n                        mPlaylist.add(new MusicPlaybackTrack(\n                                mCursor.getLong(IDCOLIDX), -1, TimberUtils.IdType.NA, -1));\n                        notifyChange(QUEUE_CHANGED);\n                        mPlayPos = 0;\n                        mHistory.clear();\n                    }\n                } catch (final UnsupportedOperationException ex) {\n                    // Ignore\n                }\n            }\n\n            mFileToPlay = path;\n            mPlayer.setDataSource(mFileToPlay);\n            if (mPlayer.isInitialized()) {\n                mOpenFailedCounter = 0;\n                return true;\n            }\n\n            String trackName = getTrackName();\n            if (TextUtils.isEmpty(trackName)) {\n                trackName = path;\n            }\n            sendErrorMessage(trackName);\n\n            stop(true);\n            return false;\n        }\n    }\n\n    private void updateCursorForDownloadedFile(Context context, Uri uri) {\n        synchronized (this) {\n            closeCursor();\n            MatrixCursor cursor = new MatrixCursor(PROJECTION_MATRIX);\n            String title = getValueForDownloadedFile(this, uri, "title");\n            cursor.addRow(new Object[]{\n                    null,\n                    null,\n                    null,\n                    title,\n                    null,\n                    null,\n                    null,\n                    null\n            });\n            mCursor = cursor;\n            mCursor.moveToFirst();\n        }\n    }\n\n    private String getValueForDownloadedFile(Context context, Uri uri, String column) {\n\n        Cursor cursor = null;\n        final String[] projection = {\n                column\n        };\n\n        try {\n            cursor = context.getContentResolver().query(uri, projection, null, null, null);\n            if (cursor != null && cursor.moveToFirst()) {\n                return cursor.getString(0);\n            }\n        } finally {\n            if (cursor != null) {\n                cursor.close();\n            }\n        }\n        return null;\n    }\n\n    public int getAudioSessionId() {\n        synchronized (this) {\n            return mPlayer.getAudioSessionId();\n        }\n    }\n\n    public int getMediaMountedCount() {\n        return mMediaMountedCount;\n    }\n\n    public int getShuffleMode() {\n        return mShuffleMode;\n    }\n\n    public void setShuffleMode(final int shufflemode) {\n        synchronized (this) {\n            if (mShuffleMode == shufflemode && mPlaylist.size() > 0) {\n                return;\n            }\n\n            mShuffleMode = shufflemode;\n            if (mShuffleMode == SHUFFLE_AUTO) {\n                if (makeAutoShuffleList()) {\n                    mPlaylist.clear();\n                    doAutoShuffleUpdate();\n                    mPlayPos = 0;\n                    openCurrentAndNext();\n                    play();\n                    notifyChange(META_CHANGED);\n                    return;\n                } else {\n                    mShuffleMode = SHUFFLE_NONE;\n                }\n            } else {\n                setNextTrack();\n            }\n            saveQueue(false);\n            notifyChange(SHUFFLEMODE_CHANGED);\n        }\n    }\n\n    public int getRepeatMode() {\n        return mRepeatMode;\n    }\n\n    public void setRepeatMode(final int repeatmode) {\n        synchronized (this) {\n            mRepeatMode = repeatmode;\n            setNextTrack();\n            saveQueue(false);\n            notifyChange(REPEATMODE_CHANGED);\n        }\n    }\n\n    public int removeTrack(final long id) {\n        int numremoved = 0;\n        synchronized (this) {\n            for (int i = 0; i < mPlaylist.size(); i++) {\n                if (mPlaylist.get(i).mId == id) {\n                    numremoved += removeTracksInternal(i, i);\n                    i--;\n                }\n            }\n        }\n        if (numremoved > 0) {\n            notifyChange(QUEUE_CHANGED);\n        }\n        return numremoved;\n    }\n\n    public boolean removeTrackAtPosition(final long id, final int position) {\n        synchronized (this) {\n            if (position >= 0 &&\n                    position < mPlaylist.size() &&\n                    mPlaylist.get(position).mId == id) {\n\n                return removeTracks(position, position) > 0;\n            }\n        }\n        return false;\n    }\n\n    public int removeTracks(final int first, final int last) {\n        final int numremoved = removeTracksInternal(first, last);\n        if (numremoved > 0) {\n            notifyChange(QUEUE_CHANGED);\n        }\n        return numremoved;\n    }\n\n    public int getQueuePosition() {\n        synchronized (this) {\n            return mPlayPos;\n        }\n    }\n\n    public void setQueuePosition(final int index) {\n        synchronized (this) {\n            stop(false);\n            mPlayPos = index;\n            openCurrentAndNext();\n            play();\n            notifyChange(META_CHANGED);\n            if (mShuffleMode == SHUFFLE_AUTO) {\n                doAutoShuffleUpdate();\n            }\n        }\n    }\n\n    public int getQueueHistorySize() {\n        synchronized (this) {\n            return mHistory.size();\n        }\n    }\n\n    public int getQueueHistoryPosition(int position) {\n        synchronized (this) {\n            if (position >= 0 && position < mHistory.size()) {\n                return mHistory.get(position);\n            }\n        }\n\n        return -1;\n    }\n\n    public int[] getQueueHistoryList() {\n        synchronized (this) {\n            int[] history = new int[mHistory.size()];\n            for (int i = 0; i < mHistory.size(); i++) {\n                history[i] = mHistory.get(i);\n            }\n\n            return history;\n        }\n    }\n\n    public String getPath() {\n        synchronized (this) {\n            if (mCursor == null) {\n                return null;\n            }\n            return mCursor.getString(mCursor.getColumnIndexOrThrow(AudioColumns.DATA));\n        }\n    }\n\n    public String getAlbumName() {\n        synchronized (this) {\n            if (mCursor == null) {\n                return null;\n            }\n            return mCursor.getString(mCursor.getColumnIndexOrThrow(AudioColumns.ALBUM));\n        }\n    }\n\n    public String getTrackName() {\n        synchronized (this) {\n            if (mCursor == null) {\n                return null;\n            }\n            return mCursor.getString(mCursor.getColumnIndexOrThrow(AudioColumns.TITLE));\n        }\n    }\n\n    public String getGenreName() {\n        synchronized (this) {\n            if (mCursor == null || mPlayPos < 0 || mPlayPos >= mPlaylist.size()) {\n                return null;\n            }\n            String[] genreProjection = {MediaStore.Audio.Genres.NAME};\n            Uri genreUri = MediaStore.Audio.Genres.getContentUriForAudioId("external",\n                    (int) mPlaylist.get(mPlayPos).mId);\n            Cursor genreCursor = getContentResolver().query(genreUri, genreProjection,\n                    null, null, null);\n            if (genreCursor != null) {\n                try {\n                    if (genreCursor.moveToFirst()) {\n                        return genreCursor.getString(\n                                genreCursor.getColumnIndexOrThrow(MediaStore.Audio.Genres.NAME));\n                    }\n                } finally {\n                    genreCursor.close();\n                }\n            }\n            return null;\n        }\n    }\n\n    public String getArtistName() {\n        synchronized (this) {\n            if (mCursor == null) {\n                return null;\n            }\n            return mCursor.getString(mCursor.getColumnIndexOrThrow(AudioColumns.ARTIST));\n        }\n    }\n\n    public String getAlbumArtistName() {\n        synchronized (this) {\n            if (mAlbumCursor == null) {\n                return null;\n            }\n            return mAlbumCursor.getString(mAlbumCursor.getColumnIndexOrThrow(AlbumColumns.ARTIST));\n        }\n    }\n\n    public long getAlbumId() {\n        synchronized (this) {\n            if (mCursor == null) {\n                return -1;\n            }\n            return mCursor.getLong(mCursor.getColumnIndexOrThrow(AudioColumns.ALBUM_ID));\n        }\n    }\n\n    public long getArtistId() {\n        synchronized (this) {\n            if (mCursor == null) {\n                return -1;\n            }\n            return mCursor.getLong(mCursor.getColumnIndexOrThrow(AudioColumns.ARTIST_ID));\n        }\n    }\n\n    public long getAudioId() {\n        MusicPlaybackTrack track = getCurrentTrack();\n        if (track != null) {\n            return track.mId;\n        }\n\n        return -1;\n    }\n\n    public MusicPlaybackTrack getCurrentTrack() {\n        return getTrack(mPlayPos);\n    }\n\n    public synchronized MusicPlaybackTrack getTrack(int index) {\n        if (index >= 0 && index < mPlaylist.size() && mPlayer.isInitialized()) {\n            return mPlaylist.get(index);\n        }\n\n        return null;\n    }\n\n    public long getNextAudioId() {\n        synchronized (this) {\n            if (mNextPlayPos >= 0 && mNextPlayPos < mPlaylist.size() && mPlayer.isInitialized()) {\n                return mPlaylist.get(mNextPlayPos).mId;\n            }\n        }\n        return -1;\n    }\n\n    public long getPreviousAudioId() {\n        synchronized (this) {\n            if (mPlayer.isInitialized()) {\n                int pos = getPreviousPlayPosition(false);\n                if (pos >= 0 && pos < mPlaylist.size()) {\n                    return mPlaylist.get(pos).mId;\n                }\n            }\n        }\n        return -1;\n    }\n\n    public long seek(long position) {\n        if (mPlayer.isInitialized()) {\n            if (position < 0) {\n                position = 0;\n            } else if (position > mPlayer.duration()) {\n                position = mPlayer.duration();\n            }\n            long result = mPlayer.seek(position);\n            notifyChange(POSITION_CHANGED);\n            return result;\n        }\n        return -1;\n    }\n\n    public void seekRelative(long deltaInMs) {\n        synchronized (this) {\n            if (mPlayer.isInitialized()) {\n                final long newPos = position() + deltaInMs;\n                final long duration = duration();\n                if (newPos < 0) {\n                    prev(true);\n                    // seek to the new duration + the leftover position\n                    seek(duration() + newPos);\n                } else if (newPos >= duration) {\n                    gotoNext(true);\n                    // seek to the leftover duration\n                    seek(newPos - duration);\n                } else {\n                    seek(newPos);\n                }\n            }\n        }\n    }\n\n    public long position() {\n        if (mPlayer.isInitialized()) {\n            return mPlayer.position();\n        }\n        return -1;\n    }\n\n    public long duration() {\n        if (mPlayer.isInitialized()) {\n            return mPlayer.duration();\n        }\n        return -1;\n    }\n\n    public long[] getQueue() {\n        synchronized (this) {\n            final int len = mPlaylist.size();\n            final long[] list = new long[len];\n            for (int i = 0; i < len; i++) {\n                list[i] = mPlaylist.get(i).mId;\n            }\n            return list;\n        }\n    }\n\n    public long getQueueItemAtPosition(int position) {\n        synchronized (this) {\n            if (position >= 0 && position < mPlaylist.size()) {\n                return mPlaylist.get(position).mId;\n            }\n        }\n\n        return -1;\n    }\n\n    public int getQueueSize() {\n        synchronized (this) {\n            return mPlaylist.size();\n        }\n    }\n\n    public boolean isPlaying() {\n        return mIsSupposedToBePlaying;\n    }\n\n    private void setIsSupposedToBePlaying(boolean value, boolean notify) {\n        if (mIsSupposedToBePlaying != value) {\n            mIsSupposedToBePlaying = value;\n\n\n            if (!mIsSupposedToBePlaying) {\n                scheduleDelayedShutdown();\n                mLastPlayedTime = System.currentTimeMillis();\n            }\n\n            if (notify) {\n                notifyChange(PLAYSTATE_CHANGED);\n            }\n        }\n    }\n\n    private boolean recentlyPlayed() {\n        return isPlaying() || System.currentTimeMillis() - mLastPlayedTime < IDLE_DELAY;\n    }\n\n    public void open(final long[] list, final int position, long sourceId, TimberUtils.IdType sourceType) {\n        synchronized (this) {\n            if (mShuffleMode == SHUFFLE_AUTO) {\n                mShuffleMode = SHUFFLE_NORMAL;\n            }\n            final long oldId = getAudioId();\n            final int listlength = list.length;\n            boolean newlist = true;\n            if (mPlaylist.size() == listlength) {\n                newlist = false;\n                for (int i = 0; i < listlength; i++) {\n                    if (list[i] != mPlaylist.get(i).mId) {\n                        newlist = true;\n                        break;\n                    }\n                }\n            }\n            if (newlist) {\n                addToPlayList(list, -1, sourceId, sourceType);\n                notifyChange(QUEUE_CHANGED);\n            }\n            if (position >= 0) {\n                mPlayPos = position;\n            } else {\n                mPlayPos = mShuffler.nextInt(mPlaylist.size());\n            }\n            mHistory.clear();\n            openCurrentAndNext();\n            if (oldId != getAudioId()) {\n                notifyChange(META_CHANGED);\n            }\n        }\n    }\n\n    public void stop() {\n        stop(true);\n    }\n\n    public void play() {\n        play(true);\n    }\n\n    public void play(boolean createNewNextTrack) {\n        int status = mAudioManager.requestAudioFocus(mAudioFocusListener,\n                AudioManager.STREAM_MUSIC, AudioManager.AUDIOFOCUS_GAIN);\n\n        if (D) Log.d(TAG, "Starting playback: audio focus request status = " + status);\n\n        if (status != AudioManager.AUDIOFOCUS_REQUEST_GRANTED) {\n            return;\n        }\n\n        final Intent intent = new Intent(AudioEffect.ACTION_OPEN_AUDIO_EFFECT_CONTROL_SESSION);\n        intent.putExtra(AudioEffect.EXTRA_AUDIO_SESSION, getAudioSessionId());\n        intent.putExtra(AudioEffect.EXTRA_PACKAGE_NAME, getPackageName());\n        sendBroadcast(intent);\n\n        mAudioManager.registerMediaButtonEventReceiver(new ComponentName(getPackageName(),\n                MediaButtonIntentReceiver.class.getName()));\n        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP)\n            mSession.setActive(true);\n\n        if (createNewNextTrack) {\n            setNextTrack();\n        } else {\n            setNextTrack(mNextPlayPos);\n        }\n\n        if (mPlayer.isInitialized()) {\n            final long duration = mPlayer.duration();\n            if (mRepeatMode != REPEAT_CURRENT && duration > 2000\n                    && mPlayer.position() >= duration - 2000) {\n                gotoNext(true);\n            }\n\n            mPlayer.start();\n            mPlayerHandler.removeMessages(FADEDOWN);\n            mPlayerHandler.sendEmptyMessage(FADEUP);\n\n            setIsSupposedToBePlaying(true, true);\n\n            cancelShutdown();\n            updateNotification();\n            notifyChange(META_CHANGED);\n        } else if (mPlaylist.size() <= 0) {\n            setShuffleMode(SHUFFLE_AUTO);\n        }\n    }\n\n    public void pause() {\n        if (D) Log.d(TAG, "Pausing playback");\n        synchronized (this) {\n            mPlayerHandler.removeMessages(FADEUP);\n            if (mIsSupposedToBePlaying) {\n                final Intent intent = new Intent(\n                        AudioEffect.ACTION_CLOSE_AUDIO_EFFECT_CONTROL_SESSION);\n                intent.putExtra(AudioEffect.EXTRA_AUDIO_SESSION, getAudioSessionId());\n                intent.putExtra(AudioEffect.EXTRA_PACKAGE_NAME, getPackageName());\n                sendBroadcast(intent);\n\n                mPlayer.pause();\n                notifyChange(META_CHANGED);\n                setIsSupposedToBePlaying(false, true);\n            }\n        }\n    }\n\n    public void gotoNext(final boolean force) {\n        if (D) Log.d(TAG, "Going to next track");\n        synchronized (this) {\n            if (mPlaylist.size() <= 0) {\n                if (D) Log.d(TAG, "No play queue");\n                scheduleDelayedShutdown();\n                return;\n            }\n            int pos = mNextPlayPos;\n            if (pos < 0) {\n                pos = getNextPosition(force);\n            }\n\n            if (pos < 0) {\n                setIsSupposedToBePlaying(false, true);\n                return;\n            }\n\n            stop(false);\n            setAndRecordPlayPos(pos);\n            openCurrentAndNext();\n            play();\n            notifyChange(META_CHANGED);\n        }\n    }\n\n    public void goToPosition(int pos) {\n        synchronized (this) {\n            if (mPlaylist.size() <= 0) {\n                if (D) Log.d(TAG, "No play queue");\n                scheduleDelayedShutdown();\n                return;\n            }\n            if (pos < 0) {\n                return;\n            }\n            if (pos == mPlayPos) {\n                if (!isPlaying()) {\n                    play();\n                }\n                return;\n            }\n            stop(false);\n            setAndRecordPlayPos(pos);\n            openCurrentAndNext();\n            play();\n            notifyChange(META_CHANGED);\n        }\n    }\n\n    public void setAndRecordPlayPos(int nextPos) {\n        synchronized (this) {\n\n            if (mShuffleMode != SHUFFLE_NONE) {\n                mHistory.add(mPlayPos);\n                if (mHistory.size() > MAX_HISTORY_SIZE) {\n                    mHistory.remove(0);\n                }\n            }\n\n            mPlayPos = nextPos;\n        }\n    }\n\n    public void prev(boolean forcePrevious) {\n        synchronized (this) {\n            boolean goPrevious = getRepeatMode() != REPEAT_CURRENT &&\n                    (position() < REWIND_INSTEAD_PREVIOUS_THRESHOLD || forcePrevious);\n\n            if (goPrevious) {\n                if (D) Log.d(TAG, "Going to previous track");\n                int pos = getPreviousPlayPosition(true);\n\n                if (pos < 0) {\n                    return;\n                }\n                mNextPlayPos = mPlayPos;\n                mPlayPos = pos;\n                stop(false);\n                openCurrent();\n                play(false);\n                notifyChange(META_CHANGED);\n            } else {\n                if (D) Log.d(TAG, "Going to beginning of track");\n                seek(0);\n                play(false);\n            }\n        }\n    }\n\n    public int getPreviousPlayPosition(boolean removeFromHistory) {\n        synchronized (this) {\n            if (mShuffleMode == SHUFFLE_NORMAL) {\n\n                final int histsize = mHistory.size();\n                if (histsize == 0) {\n                    return -1;\n                }\n                final Integer pos = mHistory.get(histsize - 1);\n                if (removeFromHistory) {\n                    mHistory.remove(histsize - 1);\n                }\n                return pos.intValue();\n            } else {\n                if (mPlayPos > 0) {\n                    return mPlayPos - 1;\n                } else {\n                    return mPlaylist.size() - 1;\n                }\n            }\n        }\n    }\n\n    private void openCurrent() {\n        openCurrentAndMaybeNext(false);\n    }\n\n    public void moveQueueItem(int index1, int index2) {\n        synchronized (this) {\n            if (index1 >= mPlaylist.size()) {\n                index1 = mPlaylist.size() - 1;\n            }\n            if (index2 >= mPlaylist.size()) {\n                index2 = mPlaylist.size() - 1;\n            }\n\n            if (index1 == index2) {\n                return;\n            }\n\n            final MusicPlaybackTrack track = mPlaylist.remove(index1);\n            if (index1 < index2) {\n                mPlaylist.add(index2, track);\n                if (mPlayPos == index1) {\n                    mPlayPos = index2;\n                } else if (mPlayPos >= index1 && mPlayPos <= index2) {\n                    mPlayPos--;\n                }\n            } else if (index2 < index1) {\n                mPlaylist.add(index2, track);\n                if (mPlayPos == index1) {\n                    mPlayPos = index2;\n                } else if (mPlayPos >= index2 && mPlayPos <= index1) {\n                    mPlayPos++;\n                }\n            }\n            notifyChange(QUEUE_CHANGED);\n        }\n    }\n\n    public void enqueue(final long[] list, final int action, long sourceId, IdType sourceType) {\n        synchronized (this) {\n            if (action == NEXT && mPlayPos + 1 < mPlaylist.size()) {\n                addToPlayList(list, mPlayPos + 1, sourceId, sourceType);\n                mNextPlayPos = mPlayPos + 1;\n                notifyChange(QUEUE_CHANGED);\n            } else {\n                addToPlayList(list, Integer.MAX_VALUE, sourceId, sourceType);\n                notifyChange(QUEUE_CHANGED);\n            }\n\n            if (mPlayPos < 0) {\n                mPlayPos = 0;\n                openCurrentAndNext();\n                play();\n                notifyChange(META_CHANGED);\n            }\n        }\n    }\n\n    private void cycleRepeat() {\n        if (mRepeatMode == REPEAT_NONE) {\n            setRepeatMode(REPEAT_CURRENT);\n            if (mShuffleMode != SHUFFLE_NONE) {\n                setShuffleMode(SHUFFLE_NONE);\n            }\n        } else {\n            setRepeatMode(REPEAT_NONE);\n        }\n    }\n\n    private void cycleShuffle() {\n        if (mShuffleMode == SHUFFLE_NONE) {\n            setShuffleMode(SHUFFLE_NORMAL);\n//            if (mRepeatMode == REPEAT_CURRENT) {\n//                setRepeatMode(REPEAT_ALL);\n//            }\n        } else if (mShuffleMode == SHUFFLE_NORMAL || mShuffleMode == SHUFFLE_AUTO) {\n            setShuffleMode(SHUFFLE_NONE);\n        }\n    }\n\n    public void refresh() {\n        notifyChange(REFRESH);\n    }\n\n    public void playlistChanged() {\n        notifyChange(PLAYLIST_CHANGED);\n    }\n\n    public interface TrackErrorExtra {\n\n        String TRACK_NAME = "trackname";\n    }\n\n    private static final class MusicPlayerHandler extends Handler {\n        private final WeakReference<MusicService> mService;\n        private float mCurrentVolume = 1.0f;\n\n\n        public MusicPlayerHandler(final MusicService service, final Looper looper) {\n            super(looper);\n            mService = new WeakReference<MusicService>(service);\n        }\n\n\n        @Override\n        public void handleMessage(final Message msg) {\n            final MusicService service = mService.get();\n            if (service == null) {\n                return;\n            }\n\n            synchronized (service) {\n                switch (msg.what) {\n                    case FADEDOWN:\n                        mCurrentVolume -= .05f;\n                        if (mCurrentVolume > .2f) {\n                            sendEmptyMessageDelayed(FADEDOWN, 10);\n                        } else {\n                            mCurrentVolume = .2f;\n                        }\n                        service.mPlayer.setVolume(mCurrentVolume);\n                        break;\n                    case FADEUP:\n                        mCurrentVolume += .01f;\n                        if (mCurrentVolume < 1.0f) {\n                            sendEmptyMessageDelayed(FADEUP, 10);\n                        } else {\n                            mCurrentVolume = 1.0f;\n                        }\n                        service.mPlayer.setVolume(mCurrentVolume);\n                        break;\n                    case SERVER_DIED:\n                        if (service.isPlaying()) {\n                            final TrackErrorInfo info = (TrackErrorInfo) msg.obj;\n                            service.sendErrorMessage(info.mTrackName);\n\n\n                            service.removeTrack(info.mId);\n                        } else {\n                            service.openCurrentAndNext();\n                        }\n                        break;\n                    case TRACK_WENT_TO_NEXT:\n                        mService.get().scrobble();\n                        service.setAndRecordPlayPos(service.mNextPlayPos);\n                        service.setNextTrack();\n                        if (service.mCursor != null) {\n                            service.mCursor.close();\n                            service.mCursor = null;\n                        }\n                        service.updateCursor(service.mPlaylist.get(service.mPlayPos).mId);\n                        service.notifyChange(META_CHANGED);\n                        service.updateNotification();\n                        break;\n                    case TRACK_ENDED:\n                        if (service.mRepeatMode == REPEAT_CURRENT) {\n                            service.seek(0);\n                            service.play();\n                        } else {\n                            service.gotoNext(false);\n                        }\n                        break;\n                    case RELEASE_WAKELOCK:\n                        service.mWakeLock.release();\n                        break;\n                    case FOCUSCHANGE:\n                        if (D) Log.d(TAG, "Received audio focus change event " + msg.arg1);\n                        switch (msg.arg1) {\n                            case AudioManager.AUDIOFOCUS_LOSS:\n                            case AudioManager.AUDIOFOCUS_LOSS_TRANSIENT:\n                                if (service.isPlaying()) {\n                                    service.mPausedByTransientLossOfFocus =\n                                            msg.arg1 == AudioManager.AUDIOFOCUS_LOSS_TRANSIENT;\n                                }\n                                service.pause();\n                                break;\n                            case AudioManager.AUDIOFOCUS_LOSS_TRANSIENT_CAN_DUCK:\n                                removeMessages(FADEUP);\n                                sendEmptyMessage(FADEDOWN);\n                                break;\n                            case AudioManager.AUDIOFOCUS_GAIN:\n                                if (!service.isPlaying()\n                                        && service.mPausedByTransientLossOfFocus) {\n                                    service.mPausedByTransientLossOfFocus = false;\n                                    mCurrentVolume = 0f;\n                                    service.mPlayer.setVolume(mCurrentVolume);\n                                    service.play();\n                                } else {\n                                    removeMessages(FADEDOWN);\n                                    sendEmptyMessage(FADEUP);\n                                }\n                                break;\n                            default:\n                        }\n                        break;\n                    default:\n                        break;\n                }\n            }\n        }\n    }\n\n    private static final class Shuffler {\n\n        private final LinkedList<Integer> mHistoryOfNumbers = new LinkedList<Integer>();\n\n        private final TreeSet<Integer> mPreviousNumbers = new TreeSet<Integer>();\n\n        private final Random mRandom = new Random();\n\n        private int mPrevious;\n\n\n        public Shuffler() {\n            super();\n        }\n\n\n        public int nextInt(final int interval) {\n            int next;\n            do {\n                next = mRandom.nextInt(interval);\n            } while (next == mPrevious && interval > 1\n                    && !mPreviousNumbers.contains(Integer.valueOf(next)));\n            mPrevious = next;\n            mHistoryOfNumbers.add(mPrevious);\n            mPreviousNumbers.add(mPrevious);\n            cleanUpHistory();\n            return next;\n        }\n\n\n        private void cleanUpHistory() {\n            if (!mHistoryOfNumbers.isEmpty() && mHistoryOfNumbers.size() >= MAX_HISTORY_SIZE) {\n                for (int i = 0; i < Math.max(1, MAX_HISTORY_SIZE / 2); i++) {\n                    mPreviousNumbers.remove(mHistoryOfNumbers.removeFirst());\n                }\n            }\n        }\n    }\n\n    private static final class TrackErrorInfo {\n        public long mId;\n        public String mTrackName;\n\n        public TrackErrorInfo(long id, String trackName) {\n            mId = id;\n            mTrackName = trackName;\n        }\n    }\n\n    private static final class MultiPlayer implements MediaPlayer.OnErrorListener,\n            MediaPlayer.OnCompletionListener {\n\n        private final WeakReference<MusicService> mService;\n\n        private MediaPlayer mCurrentMediaPlayer = new MediaPlayer();\n\n        private MediaPlayer mNextMediaPlayer;\n\n        private Handler mHandler;\n\n        private boolean mIsInitialized = false;\n\n        private String mNextMediaPath;\n\n\n        public MultiPlayer(final MusicService service) {\n            mService = new WeakReference<MusicService>(service);\n            mCurrentMediaPlayer.setWakeMode(mService.get(), PowerManager.PARTIAL_WAKE_LOCK);\n\n        }\n\n\n        public void setDataSource(final String path) {\n            try {\n                mIsInitialized = setDataSourceImpl(mCurrentMediaPlayer, path);\n                if (mIsInitialized) {\n                    setNextDataSource(null);\n                }\n            } catch (IllegalStateException e) {\n                e.printStackTrace();\n            }\n        }\n\n\n        private boolean setDataSourceImpl(final MediaPlayer player, final String path) {\n            try {\n                player.reset();\n                player.setOnPreparedListener(null);\n                if (path.startsWith("content://")) {\n                    player.setDataSource(mService.get(), Uri.parse(path));\n                } else {\n                    player.setDataSource(path);\n                }\n                player.setAudioStreamType(AudioManager.STREAM_MUSIC);\n\n                player.prepare();\n            } catch (final IOException todo) {\n\n                return false;\n            } catch (final IllegalArgumentException todo) {\n\n                return false;\n            }\n            player.setOnCompletionListener(this);\n            player.setOnErrorListener(this);\n            return true;\n        }\n\n\n        public void setNextDataSource(final String path) {\n            mNextMediaPath = null;\n            try {\n                mCurrentMediaPlayer.setNextMediaPlayer(null);\n            } catch (IllegalArgumentException e) {\n                Log.i(TAG, "Next media player is current one, continuing");\n            } catch (IllegalStateException e) {\n                Log.e(TAG, "Media player not initialized!");\n                return;\n            }\n            if (mNextMediaPlayer != null) {\n                mNextMediaPlayer.release();\n                mNextMediaPlayer = null;\n            }\n            if (path == null) {\n                return;\n            }\n            mNextMediaPlayer = new MediaPlayer();\n            mNextMediaPlayer.setWakeMode(mService.get(), PowerManager.PARTIAL_WAKE_LOCK);\n            mNextMediaPlayer.setAudioSessionId(getAudioSessionId());\n            try {\n                if (setDataSourceImpl(mNextMediaPlayer, path)) {\n                    mNextMediaPath = path;\n                    mCurrentMediaPlayer.setNextMediaPlayer(mNextMediaPlayer);\n                } else {\n                    if (mNextMediaPlayer != null) {\n                        mNextMediaPlayer.release();\n                        mNextMediaPlayer = null;\n                    }\n                }\n            } catch (IllegalStateException e) {\n                e.printStackTrace();\n            }\n        }\n\n\n        public void setHandler(final Handler handler) {\n            mHandler = handler;\n        }\n\n\n        public boolean isInitialized() {\n            return mIsInitialized;\n        }\n\n\n        public void start() {\n            mCurrentMediaPlayer.start();\n        }\n\n\n        public void stop() {\n            mCurrentMediaPlayer.reset();\n            mIsInitialized = false;\n        }\n\n\n        public void release() {\n            mCurrentMediaPlayer.release();\n        }\n\n\n        public void pause() {\n            mCurrentMediaPlayer.pause();\n        }\n\n\n        public long duration() {\n            return mCurrentMediaPlayer.getDuration();\n        }\n\n\n        public long position() {\n            return mCurrentMediaPlayer.getCurrentPosition();\n        }\n\n\n        public long seek(final long whereto) {\n            mCurrentMediaPlayer.seekTo((int) whereto);\n            return whereto;\n        }\n\n\n        public void setVolume(final float vol) {\n            try {\n                mCurrentMediaPlayer.setVolume(vol, vol);\n            } catch (IllegalStateException e) {\n                e.printStackTrace();\n            }\n        }\n\n        public int getAudioSessionId() {\n            return mCurrentMediaPlayer.getAudioSessionId();\n        }\n\n        public void setAudioSessionId(final int sessionId) {\n            mCurrentMediaPlayer.setAudioSessionId(sessionId);\n        }\n\n        @Override\n        public boolean onError(final MediaPlayer mp, final int what, final int extra) {\n            Log.w(TAG, "Music Server Error what: " + what + " extra: " + extra);\n            switch (what) {\n                case MediaPlayer.MEDIA_ERROR_SERVER_DIED:\n                    final MusicService service = mService.get();\n                    final TrackErrorInfo errorInfo = new TrackErrorInfo(service.getAudioId(),\n                            service.getTrackName());\n\n                    mIsInitialized = false;\n                    mCurrentMediaPlayer.release();\n                    mCurrentMediaPlayer = new MediaPlayer();\n                    mCurrentMediaPlayer.setWakeMode(service, PowerManager.PARTIAL_WAKE_LOCK);\n                    Message msg = mHandler.obtainMessage(SERVER_DIED, errorInfo);\n                    mHandler.sendMessageDelayed(msg, 2000);\n                    return true;\n                default:\n                    break;\n            }\n            return false;\n        }\n\n\n        @Override\n        public void onCompletion(final MediaPlayer mp) {\n            if (mp == mCurrentMediaPlayer && mNextMediaPlayer != null) {\n                mCurrentMediaPlayer.release();\n                mCurrentMediaPlayer = mNextMediaPlayer;\n                mNextMediaPath = null;\n                mNextMediaPlayer = null;\n                mHandler.sendEmptyMessage(TRACK_WENT_TO_NEXT);\n            } else {\n                mService.get().mWakeLock.acquire(30000);\n                mHandler.sendEmptyMessage(TRACK_ENDED);\n                mHandler.sendEmptyMessage(RELEASE_WAKELOCK);\n            }\n        }\n    }\n\n    private static final class ServiceStub extends ITimberService.Stub {\n\n        private final WeakReference<MusicService> mService;\n\n        private ServiceStub(final MusicService service) {\n            mService = new WeakReference<MusicService>(service);\n        }\n\n\n        @Override\n        public void openFile(final String path) throws RemoteException {\n            mService.get().openFile(path);\n        }\n\n        @Override\n        public void open(final long[] list, final int position, long sourceId, int sourceType)\n                throws RemoteException {\n            mService.get().open(list, position, sourceId, IdType.getTypeById(sourceType));\n        }\n\n        @Override\n        public void stop() throws RemoteException {\n            mService.get().stop();\n        }\n\n        @Override\n        public void pause() throws RemoteException {\n            mService.get().pause();\n        }\n\n\n        @Override\n        public void play() throws RemoteException {\n            mService.get().play();\n        }\n\n        @Override\n        public void prev(boolean forcePrevious) throws RemoteException {\n            mService.get().prev(forcePrevious);\n        }\n\n        @Override\n        public void next() throws RemoteException {\n            mService.get().gotoNext(true);\n        }\n\n        @Override\n        public void enqueue(final long[] list, final int action, long sourceId, int sourceType)\n                throws RemoteException {\n            mService.get().enqueue(list, action, sourceId, IdType.getTypeById(sourceType));\n        }\n\n        @Override\n        public void moveQueueItem(final int from, final int to) throws RemoteException {\n            mService.get().moveQueueItem(from, to);\n        }\n\n        @Override\n        public void refresh() throws RemoteException {\n            mService.get().refresh();\n        }\n\n        @Override\n        public void playlistChanged() throws RemoteException {\n            mService.get().playlistChanged();\n        }\n\n        @Override\n        public boolean isPlaying() throws RemoteException {\n            return mService.get().isPlaying();\n        }\n\n        @Override\n        public long[] getQueue() throws RemoteException {\n            return mService.get().getQueue();\n        }\n\n        @Override\n        public long getQueueItemAtPosition(int position) throws RemoteException {\n            return mService.get().getQueueItemAtPosition(position);\n        }\n\n        @Override\n        public int getQueueSize() throws RemoteException {\n            return mService.get().getQueueSize();\n        }\n\n        @Override\n        public int getQueueHistoryPosition(int position) throws RemoteException {\n            return mService.get().getQueueHistoryPosition(position);\n        }\n\n        @Override\n        public int getQueueHistorySize() throws RemoteException {\n            return mService.get().getQueueHistorySize();\n        }\n\n        @Override\n        public int[] getQueueHistoryList() throws RemoteException {\n            return mService.get().getQueueHistoryList();\n        }\n\n        @Override\n        public long duration() throws RemoteException {\n            return mService.get().duration();\n        }\n\n        @Override\n        public long position() throws RemoteException {\n            return mService.get().position();\n        }\n\n        @Override\n        public long seek(final long position) throws RemoteException {\n            return mService.get().seek(position);\n        }\n\n        @Override\n        public void seekRelative(final long deltaInMs) throws RemoteException {\n            mService.get().seekRelative(deltaInMs);\n        }\n\n        @Override\n        public long getAudioId() throws RemoteException {\n            return mService.get().getAudioId();\n        }\n\n        @Override\n        public MusicPlaybackTrack getCurrentTrack() throws RemoteException {\n            return mService.get().getCurrentTrack();\n        }\n\n        @Override\n        public MusicPlaybackTrack getTrack(int index) throws RemoteException {\n            return mService.get().getTrack(index);\n        }\n\n        @Override\n        public long getNextAudioId() throws RemoteException {\n            return mService.get().getNextAudioId();\n        }\n\n        @Override\n        public long getPreviousAudioId() throws RemoteException {\n            return mService.get().getPreviousAudioId();\n        }\n\n        @Override\n        public long getArtistId() throws RemoteException {\n            return mService.get().getArtistId();\n        }\n\n        @Override\n        public long getAlbumId() throws RemoteException {\n            return mService.get().getAlbumId();\n        }\n\n        @Override\n        public String getArtistName() throws RemoteException {\n            return mService.get().getArtistName();\n        }\n\n        @Override\n        public String getTrackName() throws RemoteException {\n            return mService.get().getTrackName();\n        }\n\n        @Override\n        public String getAlbumName() throws RemoteException {\n            return mService.get().getAlbumName();\n        }\n\n        @Override\n        public String getPath() throws RemoteException {\n            return mService.get().getPath();\n        }\n\n        @Override\n        public int getQueuePosition() throws RemoteException {\n            return mService.get().getQueuePosition();\n        }\n\n        @Override\n        public void setQueuePosition(final int index) throws RemoteException {\n            mService.get().setQueuePosition(index);\n        }\n\n        @Override\n        public int getShuffleMode() throws RemoteException {\n            return mService.get().getShuffleMode();\n        }\n\n        @Override\n        public void setShuffleMode(final int shufflemode) throws RemoteException {\n            mService.get().setShuffleMode(shufflemode);\n        }\n\n        @Override\n        public int getRepeatMode() throws RemoteException {\n            return mService.get().getRepeatMode();\n        }\n\n        @Override\n        public void setRepeatMode(final int repeatmode) throws RemoteException {\n            mService.get().setRepeatMode(repeatmode);\n        }\n\n        @Override\n        public int removeTracks(final int first, final int last) throws RemoteException {\n            return mService.get().removeTracks(first, last);\n        }\n\n\n        @Override\n        public int removeTrack(final long id) throws RemoteException {\n            return mService.get().removeTrack(id);\n        }\n\n\n        @Override\n        public boolean removeTrackAtPosition(final long id, final int position)\n                throws RemoteException {\n            return mService.get().removeTrackAtPosition(id, position);\n        }\n\n\n        @Override\n        public int getMediaMountedCount() throws RemoteException {\n            return mService.get().getMediaMountedCount();\n        }\n\n\n        @Override\n        public int getAudioSessionId() throws RemoteException {\n            return mService.get().getAudioSessionId();\n        }\n\n    }\n\n    private class MediaStoreObserver extends ContentObserver implements Runnable {\n\n        private static final long REFRESH_DELAY = 500;\n        private Handler mHandler;\n\n        public MediaStoreObserver(Handler handler) {\n            super(handler);\n            mHandler = handler;\n        }\n\n        @Override\n        public void onChange(boolean selfChange) {\n\n\n            mHandler.removeCallbacks(this);\n            mHandler.postDelayed(this, REFRESH_DELAY);\n        }\n\n        @Override\n        public void run() {\n\n            Log.e("ELEVEN", "calling refresh!");\n            refresh();\n        }\n    }\n}\n'