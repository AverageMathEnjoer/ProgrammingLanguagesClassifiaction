b'#include "stdafx.h"\n#include "resource.h"\n#include "MainWindow2.h"\n#include "Win32AppContext.h"\n#include "AssetListDialog.h"\n#include "AssetViewModifyDialog.h"\n#include "FileDialog.h"\n#include "ProgressDialog.h"\n#include <tchar.h>\n#include <Windows.h>\n#include <WindowsX.h>\n#include "Win32PluginManager.h"\n#include "../libStringConverter/convert.h"\n#include <format> //Note: For compiler support troubles, check out fmtlib https://github.com/fmtlib/fmt as a drop-in replacement.\n\nAssetModifyDialog::AssetModifyDialog()\n{}\nAssetModifyDialog::~AssetModifyDialog()\n{}\n\nAssetListDialog::FileEntryCache::FileEntryCache(FileEntryUIInfo *pUIInfo, Win32AppContext *pContext)\n\t: pContext(pContext), pUIInfo(pUIInfo), nUsers(0), lastUseTime(0)\n{\n\tpContext->getMainWindow().addDisposableCacheElement(pUIInfo, this);\n\teventHandlerHandle = pContext->getMainWindow().registerEventHandler(this);\n}\nAssetListDialog::FileEntryCache::~FileEntryCache()\n{\n\tpContext->getMainWindow().unregisterEventHandler(eventHandlerHandle);\n}\nsize_t AssetListDialog::FileEntryCache::approxMemory()\n{\n\t//Roughly approximate the memory usage.\n\tsize_t i = 0;\n\tsize_t ret = 0;\n\t//Retrieve the size of the first four cache elements (chosen \'randomly\' by iterating through the unordered map).\n\tfor (auto cacheIt = assetCache.begin(); cacheIt != assetCache.end(); ++cacheIt)\n\t{\n\t\tif (++i == 4)\n\t\t\tbreak;\n\t\tret += cacheIt->second.getSize();\n\t}\n\tret *= ((assetCache.size() + 3) & ~size_t(3)) / 4;\n\tret += sizeof(FileEntryCache);\n\treturn ret;\n}\ntime_t AssetListDialog::FileEntryCache::getLastUseTime()\n{\n\treturn lastUseTime;\n}\nbool AssetListDialog::FileEntryCache::isInUse()\n{\n\treturn nUsers > 0;\n}\nvoid AssetListDialog::FileEntryCache::onUpdateContainers(AssetsFileContextInfo *pFile)\n{\n\tif (pFile == pUIInfo->getContextInfoPtr())\n\t{\n\t\t//Invalidate all cache entries.\n\t\tstd::unordered_map<pathid_t, AssetInfo> tmp;\n\t\tassetCache.swap(tmp);\n\t}\n}\nvoid AssetListDialog::FileEntryCache::onChangeAsset(AssetsFileContextInfo *pFile, pathid_t pathID, bool wasRemoved)\n{\n\tFileContextInfo *pContextInfo = pUIInfo->getContextInfoPtr();\n\tif (pContextInfo == nullptr)\n\t{\n\t\t//Any cached element is invalid\n\t\tstd::unordered_map<pathid_t, AssetInfo> tmp;\n\t\tassetCache.swap(tmp);\n\t}\n\telse if (pFile->getFileID() == pContextInfo->getFileID())\n\t{\n\t\tauto cacheIt = assetCache.find(pathID);\n\t\tif (cacheIt != assetCache.end())\n\t\t{\n\t\t\tassetCache.erase(cacheIt); //Cache entry needs an update\n\t\t}\n\t}\n}\n\nAssetListDialog::~AssetListDialog()\n{\n\tpContext->getMainWindow().unregisterEventHandler(eventHandlerHandle);\n}\nAssetListDialog::AssetListDialog(class Win32AppContext *pContext, HWND hParentWnd)\n\t: pContext(pContext), hParentWnd(hParentWnd), hDialog(NULL),\n\tcachedListEntryCount(0), cachedListEntryStartIdx(0), maxEntriesPerTick(100), ticksUntilCacheFreqUpdate(0)\n{\n\teventHandlerHandle = pContext->getMainWindow().registerEventHandler(this);\n\tsorted = false;\n\tsortOrderAscending = false;\n\tiSortColumn = 0;\n\tiFocusedItem = -1;\n\tiLastTopItem = -1;\n\tqpfrequency.QuadPart = 1;\n}\nEFileManipulateDialogType AssetListDialog::getType()\n{\n\treturn FileManipulateDialog_AssetList;\n}\nvoid AssetListDialog::addFileContext(const std::pair<FileEntryUIInfo*,uintptr_t> &fileContext)\n{\n\tFileContextInfo *pContextInfo = fileContext.first->getContextInfoPtr();\n\tif (AssetsFileContextInfo *pAssetsInfo = dynamic_cast<AssetsFileContextInfo*>(pContextInfo))\n\t{\n\t\tunsigned int fileID = pAssetsInfo->getFileID();\n\t\tauto entryIt = fileEntries.find(fileID);\n\t\tassert(entryIt == fileEntries.end());\n\t\tif (entryIt == fileEntries.end())\n\t\t{\n\t\t\tFileEntryCacheRef cachedRef = pContext->getMainWindow().findDisposableCacheElement<FileEntryCache>(fileContext.first);\n\t\t\tif (cachedRef.get() != nullptr)\n\t\t\t{\n\t\t\t\tcachedRef->nUsers++;\n\t\t\t\tassert(cachedRef->nUsers >= 1);\n\t\t\t\tfileEntries[fileID] = std::move(cachedRef);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tFileEntryCache *pNewCache = new FileEntryCache(fileContext.first, pContext);\n\t\t\t\tpNewCache->nUsers++;\n\t\t\t\tassert(pNewCache->nUsers >= 1);\n\t\t\t\tfileEntries[fileID] = FileEntryCacheRef(pNewCache);\n\t\t\t}\n\t\t\tAssetIdentifier identifier;\n\t\t\tsize_t start = listEntries.size();\n\t\t\tfor (AssetIterator iter(pAssetsInfo); !iter.isEnd(); ++iter)\n\t\t\t{\n\t\t\t\titer.get(identifier);\n\t\t\t\tlistEntries.push_back(ListEntry(fileID, identifier.pathID));\n\t\t\t}\n\t\t\tif (hDialog)\n\t\t\t\tListView_SetItemCount(GetDlgItem(hDialog, IDC_ASSETLIST), (int)std::min<size_t>(listEntries.size(), INT_MAX));\n\t\t\tif (sorted)\n\t\t\t\tresort();\n\t\t\tif (!entryCachingScheduled)\n\t\t\t{\n\t\t\t\tentryCachingScheduled = true;\n\t\t\t\tSetTimer(hDialog, (uintptr_t)1, 16, NULL);\n\t\t\t}\n\t\t}\n\t}\n}\nvoid AssetListDialog::removeFileContext(FileEntryUIInfo *pEntryInfo)\n{\n\t//No need to update the sort order.\n\tunsigned int fileID = 0;\n\tauto entryIt = fileEntries.end();\n\tif (pEntryInfo->pContextInfo != nullptr)\n\t{\n\t\tentryIt = fileEntries.find(pEntryInfo->pContextInfo->getFileID());\n\t}\n\telse\n\t{\n\t\tfor (auto curEntryIt = fileEntries.begin(); curEntryIt != fileEntries.end(); ++curEntryIt)\n\t\t{\n\t\t\tif (curEntryIt->second->pUIInfo == pEntryInfo)\n\t\t\t{\n\t\t\t\tentryIt = curEntryIt;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif (entryIt != fileEntries.end())\n\t{\n\t\tfileID = entryIt->first;\n\t\tentryIt->second->lastUseTime = time(nullptr);\n\t\tassert(entryIt->second->nUsers >= 1);\n\t\tentryIt->second->nUsers--;\n\t\tfileEntries.erase(entryIt);\n\t}\n\tHWND hAssetListView = NULL;\n\tif (hDialog)\n\t\thAssetListView = GetDlgItem(hDialog, IDC_ASSETLIST);\n\tif (fileID != 0)\n\t{\n\t\t{\n\t\t\tauto deferredChangesIt = deferredChangesByFileID.find(fileID);\n\t\t\tif (deferredChangesIt != deferredChangesByFileID.end())\n\t\t\t\tdeferredChangesByFileID.erase(deferredChangesIt);\n\t\t}\n\t\t//Delete the list entries for this file.\n\t\t//Assuming that listEntries only consists of trivially destructible types (allowed : std::tuple<void*,int>, not allowed : std::vector<int>).\n\t\tsize_t moveOffset = 0;\n\t\tif (hAssetListView)\n\t\t\tListView_SetItemCount(hAssetListView, 0);\n\t\t\t//ListView_DeleteAllItems(hAssetListView);\n\t\tfor (size_t i = 0; i < listEntries.size() - moveOffset; i++)\n\t\t{\n\t\t\twhile ((i + moveOffset) < listEntries.size() && listEntries[i + moveOffset].fileID == fileID)\n\t\t\t{\n\t\t\t\t//if (hAssetListView && (i + moveOffset) <= INT_MAX)\n\t\t\t\t//\tListView_DeleteItem(hAssetListView, (i + moveOffset));\n\t\t\t\tmoveOffset++;\n\t\t\t}\n\t\t\tif (moveOffset > 0 && (i + moveOffset) < listEntries.size())\n\t\t\t\tlistEntries[i] = std::move(listEntries[i + moveOffset]);\n\t\t}\n\t\tif (moveOffset > 0)\n\t\t{\n\t\t\tlistEntries.erase(listEntries.begin() + (listEntries.size() - moveOffset), listEntries.end());\n\t\t}\n\t\tif (cachedListEntryCount >= moveOffset)\n\t\t\tcachedListEntryCount -= moveOffset;\n\t\telse\n\t\t\tcachedListEntryCount = 0;\n\t}\n\tif (hAssetListView)\n\t\tListView_SetItemCount(hAssetListView, static_cast<int>(std::min<size_t>(listEntries.size(), INT_MAX)));\n\n\tif (fileEntries.empty())\n\t\tthis->pContext->getMainWindow().hideManipulateDialog(this);\n}\nHWND AssetListDialog::getWindowHandle()\n{\n\treturn hDialog;\n}\n//Called for unhandled WM_COMMAND messages. Returns true if this dialog has handled the request, false otherwise.\nbool AssetListDialog::onCommand(WPARAM wParam, LPARAM lParam)\n{\n\tint wmId = LOWORD(wParam);\n\tif (wmId == IDM_FILE_SAVEALL || !this->hDialog)\n\t{\n\t\tbool applyAll = (wmId == IDM_FILE_SAVEALL);\n\t\tif (wmId == IDM_FILE_SAVEALL)\n\t\t\twmId = IDM_FILE_APPLY;\n\t\tbool ret = false;\n\t\tfor (auto dialogIt = this->modifyDialogs.begin(); dialogIt != this->modifyDialogs.end(); ++dialogIt)\n\t\t{\n\t\t\tif (*dialogIt)\n\t\t\t{\n\t\t\t\tif (applyAll)\n\t\t\t\t{\n\t\t\t\t\t(*dialogIt)->applyChanges();\n\t\t\t\t\tret = true;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tret = ret || (*dialogIt)->onCommand(wParam, lParam);\n\t\t\t}\n\t\t}\n\t\tif (hDialog)\n\t\t\tret = ret || (AssetListProc(hDialog, WM_COMMAND, wParam, lParam) == (INT_PTR)TRUE);\n\t\treturn ret;\n\t}\n\telse\n\t{\n\t\tHWND hTabsControl = GetDlgItem(this->hDialog, IDC_ASSETLISTMODIFYTABS);\n\t\tint curTab = (int)SendMessage(hTabsControl, MC_MTM_GETCURSEL, 0, 0);\n\t\tif (curTab != -1)\n\t\t{\n\t\t\tMC_MTITEM item = {};\n\t\t\titem.dwMask = MC_MTIF_PARAM;\n\t\t\tif (SendMessage(hTabsControl, MC_MTM_GETITEM, (WPARAM)curTab, (LPARAM)&item) == TRUE)\n\t\t\t{\n\t\t\t\tif (item.lParam != 0)\n\t\t\t\t{\n\t\t\t\t\tAssetModifyDialog *pModifyDlg = reinterpret_cast<AssetModifyDialog*>(item.lParam);\n\t\t\t\t\tif (wmId == IDM_FILE_APPLY)\n\t\t\t\t\t{\n\t\t\t\t\t\tpModifyDlg->applyChanges();\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t\treturn pModifyDlg->onCommand(wParam, lParam);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\treturn AssetListProc(hDialog, WM_COMMAND, wParam, lParam) == (INT_PTR)TRUE;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n//message : currently only WM_KEYDOWN; keyCode : VK_F3 for instance\nvoid AssetListDialog::onHotkey(ULONG message, DWORD keyCode)\n{\n\tif (message == WM_KEYDOWN && keyCode == VK_F3)\n\t{\n\t\tthis->searchNext();\n\t}\n}\n\nvoid AssetListDialog::onUpdateContainers(AssetsFileContextInfo *pFile)\n{\n\tunsigned int fileID = pFile->getFileID();\n\tauto entryIt = fileEntries.find(pFile->getFileID());\n\tif (entryIt != fileEntries.end())\n\t{\n\t\tFileEntryCache &entryCache = *entryIt->second.get();\n\t\tif (entryCache.assetCache.size() > 0 && entryCache.assetCache.size() <= cachedListEntryCount)\n\t\t\tcachedListEntryCount -= entryCache.assetCache.size();\n\t\telse\n\t\t{\n\t\t\t//The amount of discarded cache elements is unknown, since the FileEntryCache may have cleared itself already.\n\t\t\tcachedListEntryCount = 0; \n\t\t}\n\t\tif (hDialog)\n\t\t{\n\t\t\tPostMessage(GetDlgItem(hDialog, IDC_ASSETLIST), LVM_REDRAWITEMS, 0, (LPARAM)(int)std::min<size_t>(listEntries.size(), INT_MAX));\n\t\t\t//ListView_RedrawItems(GetDlgItem(hDialog, IDC_ASSETLIST), 0, (int)std::min<size_t>(listEntries.size(), INT_MAX));\n\t\t\tif (!windowUpdateScheduled)\n\t\t\t{\n\t\t\t\twindowUpdateScheduled = true;\n\t\t\t\tSetTimer(hDialog, (uintptr_t)0, 50, NULL);\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid AssetListDialog::applyDeferredChanges()\n{\n\tauto deferredChangesByFileID = std::move(this->deferredChangesByFileID);\n\tsize_t totalChanges = 0;\n\tfor (auto& changesVal : deferredChangesByFileID)\n\t\ttotalChanges += changesVal.second.size();\n\tif (totalChanges == 0)\n\t\treturn;\n\t//Generate a hash table that lists all changes,\n\t// since about listEntries.size()*3 steps are much less than O(listEntries.size()^2) steps\n\t// which would occur if a change notification was posted for every single entry.\n\t// (Could be even worse in theory, if several change notifications per asset occured between two calls).\n\tauto hasher = [](const std::pair<unsigned int/*fileID*/, pathid_t>& entry)\n\t{\n\t\tstatic std::hash<decltype(entry.first)> fidHasher;\n\t\tstatic std::hash<decltype(entry.second)> pidHasher;\n\t\tsize_t fidHash = fidHasher(entry.first);\n\t\tsize_t pidHash = pidHasher(entry.second);\n\t\treturn (fidHash << 1) ^ pidHash;\n\t};\n\tstd::unordered_map<std::pair<unsigned int/*fileID*/, pathid_t>, bool/*wasRemoved*/, decltype(hasher)> changesLookup(totalChanges);\n\tfor (auto changesForFileIDIt = deferredChangesByFileID.begin(); changesForFileIDIt != deferredChangesByFileID.end(); ++changesForFileIDIt)\n\t{\n\t\tunsigned int fileID = changesForFileIDIt->first;\n\t\tfor (DeferredChangeDesc& changeDesc : changesForFileIDIt->second)\n\t\t\tchangesLookup.insert({ {fileID, changeDesc.pathID}, changeDesc.wasRemoved });\n\t}\n\n\tstd::vector<ListEntry> newListEntries;\n\tnewListEntries.reserve(this->listEntries.size());\n\n\tsize_t iChangedFirst = SIZE_MAX;\n\n\tstd::vector<std::pair<ListEntry, size_t/*outIndexHint*/>> entriesToSort;\n\tsize_t numEntriesToSortWithOldIdx = 0;\n\tsize_t iCurOutIndexIfUnsorted = 0;\n\t//First, fill newListEntries with all unchanged entries from this->listEntries. \n\tfor (size_t i = 0; i < this->listEntries.size(); i++)\n\t{\n\t\tbool keepEntry = true;\n\t\tauto lookupEntryIt = changesLookup.find({ this->listEntries[i].fileID, this->listEntries[i].pathID });\n\t\tif (lookupEntryIt != changesLookup.end())\n\t\t{\n\t\t\tif (lookupEntryIt->second) //wasRemoved\n\t\t\t{\n\t\t\t\tkeepEntry = false;\n\t\t\t\tif (cachedListEntryCount > i)\n\t\t\t\t\tcachedListEntryCount--;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tkeepEntry = false;\n\t\t\t\tentriesToSort.push_back({ this->listEntries[i], iCurOutIndexIfUnsorted });\n\t\t\t\tiCurOutIndexIfUnsorted++;\n\t\t\t\tnumEntriesToSortWithOldIdx++;\n\t\t\t}\n\t\t\tchangesLookup.erase(lookupEntryIt);\n\t\t}\n\t\tif (keepEntry)\n\t\t{\n\t\t\tnewListEntries.push_back(this->listEntries[i]);\n\t\t\tiCurOutIndexIfUnsorted++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (iChangedFirst == SIZE_MAX)\n\t\t\t\tiChangedFirst = i;\n\t\t}\n\t}\n\tfor (auto& newAssetLookupEntry : changesLookup)\n\t\tentriesToSort.push_back({ ListEntry(newAssetLookupEntry.first.first, newAssetLookupEntry.first.second), SIZE_MAX });\n\tthis->listEntries = std::move(newListEntries);\n\tif (hDialog)\n\t\tListView_SetItemCount(GetDlgItem(hDialog, IDC_ASSETLIST), (int)std::min<size_t>(listEntries.size(), INT_MAX));\n\tif (entriesToSort.size() > 100) \n\t{\n\t\t//Since inserting many items into a vector at random locations is slow (O(nlogn+n^2)),\n\t\t// insert all at the end and then sort the whole vector if needed (O(n+nlogn)).\n\t\t//Crude check to limit the worst case time overhead.\n\t\tfor (std::pair<ListEntry, size_t/*outIndexHint*/>& listEntryToInsert : entriesToSort)\n\t\t\tlistEntries.push_back(listEntryToInsert.first);\n\t\tif (hDialog)\n\t\t\tListView_SetItemCount(GetDlgItem(hDialog, IDC_ASSETLIST), (int)std::min<size_t>(listEntries.size(), INT_MAX));\n\t\tif (sorted)\n\t\t\tresort();\n\t}\n\telse\n\t{\n\t\t//More user-friendly insertion method (more stable entry locations),\n\t\t// but slower depending on the size of listEntries.\n\t\t//Note: Each listEntryInsertSorted may also invoke ListView_RedrawItems.\n\t\tfor (std::pair<ListEntry, size_t/*outIndexHint*/>& listEntryToInsert : entriesToSort)\n\t\t{\n\t\t\tlistEntryInsertSorted(listEntryToInsert.first, listEntryToInsert.second);\n\t\t}\n\t}\n\tif (hDialog)\n\t\tListView_SetItemCount(GetDlgItem(hDialog, IDC_ASSETLIST), (int)std::min<size_t>(listEntries.size(), INT_MAX));\n\tif (hDialog && iChangedFirst < INT_MAX)\n\t\tListView_RedrawItems(GetDlgItem(hDialog, IDC_ASSETLIST), iChangedFirst, (int)std::min<size_t>(listEntries.size(), INT_MAX));\n}\nvoid AssetListDialog::onChangeAsset(AssetsFileContextInfo *pFile, pathid_t pathID, bool wasRemoved)\n{\n\t//Called whenever a replacer was added, even if the dialog is hidden (as long as it has the file context).\n\tunsigned int fileID = pFile->getFileID();\n\tthis->deferredChangesByFileID[fileID].push_back(DeferredChangeDesc{ pathID, wasRemoved });\n\t//static_cast<AssetsFileContext*>(pFile->getFileContext())->getAssetsFileTable()->getAssetInfo(pathID)\n\tif (hDialog && !windowUpdateScheduled)\n\t{\n\t\twindowUpdateScheduled = true;\n\t\tSetTimer(hDialog, (uintptr_t)0, 50, NULL);\n\t}\n\tif (hDialog && !selectionUpdateScheduled)\n\t{\n\t\tselectionUpdateScheduled = true;\n\t\tSetTimer(hDialog, (uintptr_t)2, 50, NULL);\n\t}\n}\nvoid AssetListDialog::onHide()\n{\n\tif (pActiveModifyDialog) pActiveModifyDialog->onHide();\n\tEnableMenuItem(pContext->getMainWindow().getMenu(), IDM_VIEW_ADDASSET, MF_GRAYED);\n\tEnableMenuItem(pContext->getMainWindow().getMenu(), IDM_FILE_APPLY, MF_GRAYED);\n\tEnableMenuItem(pContext->getMainWindow().getMenu(), IDM_VIEW_SEARCHBYNAME, MF_GRAYED);\n\tEnableMenuItem(pContext->getMainWindow().getMenu(), IDM_VIEW_CONTINUESEARCH, MF_GRAYED);\n\tEnableMenuItem(pContext->getMainWindow().getMenu(), IDM_VIEW_GOTOASSET, MF_GRAYED);\n\t//EnableMenuItem(pContext->getMainWindow().getMenu(), IDM_MODMAKER_CREATESTANDALONE, MF_GRAYED);\n\t//EnableMenuItem(pContext->getMainWindow().getMenu(), IDM_MODMAKER_CREATEPACKAGE, MF_GRAYED);\n\tif (this->hDialog)\n\t{\n\t\tif (this->hCurPopupMenu != NULL)\n\t\t{\n\t\t\tDestroyMenu(this->hCurPopupMenu);\n\t\t\tthis->hCurPopupMenu = NULL;\n\t\t}\n\t\tif (windowUpdateScheduled)\n\t\t\tKillTimer(this->hDialog, (uintptr_t)0);\n\t\tif (entryCachingScheduled)\n\t\t\tKillTimer(this->hDialog, (uintptr_t)1);\n\t\tif (selectionUpdateScheduled)\n\t\t\tKillTimer(this->hDialog, (uintptr_t)2);\n\t\twindowUpdateScheduled = false;\n\t\tentryCachingScheduled = false;\n\t\tselectionUpdateScheduled = false;\n\t\t\n\t\tHWND hTabsControl = GetDlgItem(this->hDialog, IDC_ASSETLISTMODIFYTABS);\n\t\tint curTab = (int)SendMessage(hTabsControl, MC_MTM_GETCURSEL, 0, 0);\n\t\tif (curTab != -1)\n\t\t{\n\t\t\tMC_MTITEM item = {};\n\t\t\titem.dwMask = MC_MTIF_PARAM;\n\t\t\tif (SendMessage(hTabsControl, MC_MTM_GETITEM, (WPARAM)curTab, (LPARAM)&item) == TRUE)\n\t\t\t{\n\t\t\t\tif (item.lParam != 0)\n\t\t\t\t\treinterpret_cast<AssetModifyDialog*>(item.lParam)->onHide();\n\t\t\t}\n\t\t}\n\n\t\tHWND hAssetList = GetDlgItem(this->hDialog, IDC_ASSETLIST);\n\t\tthis->iLastTopItem = ListView_GetTopIndex(hAssetList);\n\n\t\tSendMessage(this->hDialog, WM_CLOSE, 0, 0);\n\t}\n}\nvoid AssetListDialog::onShow()\n{\n\tif (!this->hDialog)\n\t\tthis->hDialog = CreateDialogParam(pContext->getMainWindow().getHInstance(), MAKEINTRESOURCE(IDD_ASSETSINFO), hParentWnd, AssetListProc, (LPARAM)this);\n\n\tEnableMenuItem(pContext->getMainWindow().getMenu(), IDM_VIEW_ADDASSET, MF_ENABLED);\n\tEnableMenuItem(pContext->getMainWindow().getMenu(), IDM_FILE_APPLY, MF_ENABLED);\n\tEnableMenuItem(pContext->getMainWindow().getMenu(), IDM_VIEW_SEARCHBYNAME, MF_ENABLED);\n\tEnableMenuItem(pContext->getMainWindow().getMenu(), IDM_VIEW_CONTINUESEARCH, \n\t\tthis->searchQuery.empty() ? MF_GRAYED : MF_ENABLED);\n\tEnableMenuItem(pContext->getMainWindow().getMenu(), IDM_VIEW_GOTOASSET, MF_ENABLED);\n\t\n\tif (this->hDialog)\n\t{\n\t\tthis->selectionUpdateScheduled = true;\n\t\tSetTimer(this->hDialog, (uintptr_t)2, 16, NULL);\n\t}\n\t//EnableMenuItem(pContext->getMainWindow().getMenu(), IDM_MODMAKER_CREATESTANDALONE, MF_ENABLED);\n\t//EnableMenuItem(pContext->getMainWindow().getMenu(), IDM_MODMAKER_CREATEPACKAGE, MF_ENABLED);\n}\nbool AssetListDialog::hasUnappliedChanges(bool *applyable)\n{\n\tbool ret = false;\n\t//Only the modify dialogs can have unapplied changes; AssetListDialog doesn\'t store any relevant saveable state.\n\tfor (auto modifyDialogPtrIt = this->modifyDialogs.begin(); modifyDialogPtrIt != this->modifyDialogs.end(); ++modifyDialogPtrIt)\n\t{\n\t\tAssetModifyDialog *pDialog = modifyDialogPtrIt->get();\n\t\tbool curApplyable = false;\n\t\tif (pDialog && pDialog->hasUnappliedChanges(&curApplyable))\n\t\t{\n\t\t\tif (!applyable)\n\t\t\t\treturn true;\n\t\t\tret = true;\n\t\t\tif (curApplyable)\n\t\t\t{\n\t\t\t\tif (applyable) *applyable = true;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}\nbool AssetListDialog::applyChanges()\n{\n\tbool ret = true;\n\tfor (auto modifyDialogPtrIt = this->modifyDialogs.begin(); modifyDialogPtrIt != this->modifyDialogs.end(); ++modifyDialogPtrIt)\n\t{\n\t\tAssetModifyDialog *pDialog = modifyDialogPtrIt->get();\n\t\tif (pDialog && !pDialog->applyChanges())\n\t\t\tret = false; //Still apply changes of any other open dialog. Need to check whether this is good behavior, or if it could .\n\t}\n\treturn ret;\n}\nbool AssetListDialog::doesPreferNoAutoclose()\n{\n\t//Do not autoclose when:\n\t//1. At least one modify dialog is open.\n\tif (!this->modifyDialogs.empty()) return true;\n\t//2. More than one asset is selected.\n\tif (this->lastNumSelections > 1) return true;\n\treturn false;\n}\n\nstruct SortPred_Base\n{\n\tAssetListDialog *pDlg;\n\tbool smallerThan; //ascending\n\tinline SortPred_Base(AssetListDialog *pDlg, bool smallerThan) : pDlg(pDlg), smallerThan(smallerThan) {}\n};\nstruct SortPred_Name : SortPred_Base\n{\n\tinline SortPred_Name(AssetListDialog *pDlg, bool smallerThan) : SortPred_Base(pDlg, smallerThan) {}\n\tbool operator()(const AssetListDialog::ListEntry &a, const AssetListDialog::ListEntry &b) const\n\t{\n\t\tstd::string *pNameA = pDlg->getName(a.fileID, a.pathID);\n\t\tstd::string *pNameB = pDlg->getName(b.fileID, b.pathID);\n\t\tassert(pNameA && pNameB); //Should always be the case. \n\t\treturn (smallerThan ? ((*pNameA) < (*pNameB)) : ((*pNameA) > (*pNameB)));\n\t}\n};\nstruct SortPred_ContainerName : SortPred_Base\n{\n\tinline SortPred_ContainerName(AssetListDialog *pDlg, bool smallerThan) : SortPred_Base(pDlg, smallerThan) {}\n\tbool operator()(const AssetListDialog::ListEntry &a, const AssetListDialog::ListEntry &b) const\n\t{\n\t\tstd::string *pNameA = pDlg->getContainerName(a.fileID, a.pathID);\n\t\tstd::string *pNameB = pDlg->getContainerName(b.fileID, b.pathID);\n\t\tassert(pNameA && pNameB); //Should always be the case. \n\t\treturn (smallerThan ? ((*pNameA) < (*pNameB)) : ((*pNameA) > (*pNameB)));\n\t}\n};\nstruct SortPred_TypeName : SortPred_Base\n{\n\tinline SortPred_TypeName(AssetListDialog *pDlg, bool smallerThan) : SortPred_Base(pDlg, smallerThan) {}\n\tbool operator()(const AssetListDialog::ListEntry &a, const AssetListDialog::ListEntry &b) const\n\t{\n\t\tstd::string *pNameA = pDlg->getTypeName(a.fileID, a.pathID);\n\t\tstd::string *pNameB = pDlg->getTypeName(b.fileID, b.pathID);\n\t\tassert(pNameA && pNameB); //Should always be the case. \n\t\treturn (smallerThan ? ((*pNameA) < (*pNameB)) : ((*pNameA) > (*pNameB)));\n\t}\n};\nstruct SortPred_FileID\n{\n\tbool smallerThan;\n\tinline SortPred_FileID(bool smallerThan) : smallerThan(smallerThan) {}\n\tbool operator()(const AssetListDialog::ListEntry &a, const AssetListDialog::ListEntry &b) const\n\t{\n\t\treturn (smallerThan ? (a.fileID < b.fileID) : (a.fileID > b.fileID));\n\t}\n};\nstruct SortPred_PathID\n{\n\tbool smallerThan;\n\tinline SortPred_PathID(bool smallerThan) : smallerThan(smallerThan) {}\n\tbool operator()(const AssetListDialog::ListEntry &a, const AssetListDialog::ListEntry &b) const\n\t{\n\t\treturn (smallerThan ? ((int64_t)a.pathID < (int64_t)b.pathID) : ((int64_t)a.pathID > (int64_t)b.pathID));\n\t}\n};\nstruct SortPred_Size : SortPred_Base\n{\n\tinline SortPred_Size(AssetListDialog *pDlg, bool smallerThan) : SortPred_Base(pDlg, smallerThan) {}\n\tbool operator()(const AssetListDialog::ListEntry &a, const AssetListDialog::ListEntry &b) const\n\t{\n\t\tauto sizeA = pDlg->getSize(a.fileID, a.pathID);\n\t\tauto sizeB = pDlg->getSize(b.fileID, b.pathID);\n\t\treturn (smallerThan ? (sizeA < sizeB) : (sizeA > sizeB));\n\t}\n};\nstruct SortPred_Modified : SortPred_Base\n{\n\tinline SortPred_Modified(AssetListDialog *pDlg, bool smallerThan) : SortPred_Base(pDlg, smallerThan) {}\n\tbool operator()(const AssetListDialog::ListEntry &a, const AssetListDialog::ListEntry &b) const\n\t{\n\t\tbool modA = pDlg->getIsModified(a.fileID, a.pathID);\n\t\tbool modB = pDlg->getIsModified(b.fileID, b.pathID);\n\t\treturn (smallerThan ? (!modA && modB) : (modA && !modB));\n\t}\n};\n\ntemplate <class It, class Ty, class Pred>\nstatic It upper_bound_or_target(It begin, It end, It target, const Ty& val, Pred pred)\n{\n\tif (target != end)\n\t{\n\t\tif (!pred(*target, val) && !pred(val, *target)) //if (*target compares equal to val)\n\t\t\treturn target;\n\t}\n\treturn std::upper_bound(begin, end, val, pred);\n}\nbool AssetListDialog::cacheAllAndShowProgress(bool allowCancel)\n{\n\tapplyDeferredChanges();\n\tbool ret = true;\n\tAssetInfo* tmp;\n\tsize_t start = 0;\n\tauto pProgressIndicator = std::make_shared<CProgressIndicator>(this->pContext->getMainWindow().getHInstance());\n\tbool indicatorStarted = false;\n\twhile (start < listEntries.size())\n\t{\n\t\tif (pProgressIndicator && allowCancel && pProgressIndicator->IsCancelled())\n\t\t{\n\t\t\tret = false;\n\t\t\tbreak;\n\t\t}\n\t\tif (start != 0 && pProgressIndicator)\n\t\t{\n\t\t\tif (!indicatorStarted)\n\t\t\t{\n\t\t\t\tif (!pProgressIndicator->Start(this->hDialog, pProgressIndicator, 2000))\n\t\t\t\t{\n\t\t\t\t\tpProgressIndicator.reset();\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tpProgressIndicator->SetStepRange(0, (unsigned int)std::min<size_t>(INT_MAX, listEntries.size()));\n\t\t\t\tpProgressIndicator->SetCancellable(allowCancel);\n\t\t\t\tpProgressIndicator->SetTitle("Processing asset entries");\n\t\t\t}\n\t\t\tpProgressIndicator->SetDescription(std::format("Processing asset {} / {}", start + 1, listEntries.size()));\n\t\t\tpProgressIndicator->SetStepStatus((unsigned int)std::min<size_t>(INT_MAX, start));\n\t\t}\n\t\tcachedListEntryCount += cacheEntries(start, listEntries.size(), tmp, 431, &start);\n\t}\n\tif (pProgressIndicator != nullptr)\n\t{\n\t\tpProgressIndicator->End();\n\t\tpProgressIndicator->Free();\n\t}\n\treturn ret;\n}\nvoid AssetListDialog::listEntryInsertSorted(ListEntry newEntry, size_t targetIdx)\n{\n\tif (targetIdx == (size_t)-1 || targetIdx > listEntries.size())\n\t\ttargetIdx = listEntries.size();\n\tsize_t newEntryIndex = listEntries.size();\n\tif (sorted)\n\t{\n\t\tif (iSortColumn != 3 && iSortColumn != 4) //Most predicates require cached info, FileID and PathID being the exceptions.\n\t\t{\n\t\t\t//Generate the cache info for the new entry before inserting it at the right place.\n\t\t\tlistEntries.push_back(newEntry);\n\t\t\tthis->cacheAllAndShowProgress(false);\n\t\t\tlistEntries.erase(listEntries.begin() + newEntryIndex);\n\t\t}\n\t\tauto targetIt = listEntries.begin() + targetIdx;\n\t\tswitch (iSortColumn)\n\t\t{\n\t\t\tcase 0: //Name\n\t\t\t\tnewEntryIndex = std::distance(listEntries.begin(), \n\t\t\t\t\tupper_bound_or_target(listEntries.begin(), listEntries.end(), targetIt, newEntry, SortPred_Name(this, sortOrderAscending)));\n\t\t\t\tbreak;\n\t\t\tcase 1: //Container\n\t\t\t\tnewEntryIndex = std::distance(listEntries.begin(), \n\t\t\t\t\tupper_bound_or_target(listEntries.begin(), listEntries.end(), targetIt, newEntry, SortPred_ContainerName(this, sortOrderAscending)));\n\t\t\t\tbreak;\n\t\t\tcase 2: //Type\n\t\t\t\tnewEntryIndex = std::distance(listEntries.begin(), \n\t\t\t\t\tupper_bound_or_target(listEntries.begin(), listEntries.end(), targetIt, newEntry, SortPred_TypeName(this, sortOrderAscending)));\n\t\t\t\tbreak;\n\t\t\tcase 3: //File ID\n\t\t\t\tnewEntryIndex = std::distance(listEntries.begin(), \n\t\t\t\t\tupper_bound_or_target(listEntries.begin(), listEntries.end(), targetIt, newEntry, SortPred_FileID(sortOrderAscending)));\n\t\t\t\tbreak;\n\t\t\tcase 4: //Path ID\n\t\t\t\tnewEntryIndex = std::distance(listEntries.begin(), \n\t\t\t\t\tupper_bound_or_target(listEntries.begin(), listEntries.end(), targetIt, newEntry, SortPred_PathID(sortOrderAscending)));\n\t\t\t\tbreak;\n\t\t\tcase 5: //Size (Bytes)\n\t\t\t\tnewEntryIndex = std::distance(listEntries.begin(), \n\t\t\t\t\tupper_bound_or_target(listEntries.begin(), listEntries.end(), targetIt, newEntry, SortPred_Size(this, sortOrderAscending)));\n\t\t\t\tbreak;\n\t\t\tcase 6: //Modified\n\t\t\t\tnewEntryIndex = std::distance(listEntries.begin(), \n\t\t\t\t\tupper_bound_or_target(listEntries.begin(), listEntries.end(), targetIt, newEntry, SortPred_Modified(this, sortOrderAscending)));\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tsorted = false;\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tlistEntries.insert(listEntries.begin() + newEntryIndex, std::move(newEntry));\n\tif (iFocusedItem >= 0 && (size_t)iFocusedItem >= newEntryIndex && iFocusedItem < INT_MAX)\n\t{\n\t\tiFocusedItem++;\n\t}\n\tif (hDialog && newEntryIndex <= INT_MAX)\n\t{\n\t\tHWND hAssetList = GetDlgItem(hDialog, IDC_ASSETLIST);\n\t\tif (iFocusedItem != -1)\n\t\t\tListView_SetItemState(hAssetList, iFocusedItem, LVIS_FOCUSED, LVIS_FOCUSED);\n\t\tListView_RedrawItems(hAssetList, (int)newEntryIndex, (int)std::min<size_t>(listEntries.size(), INT_MAX));\n\t\tif (!windowUpdateScheduled)\n\t\t{\n\t\t\twindowUpdateScheduled = true;\n\t\t\tSetTimer(hDialog, (uintptr_t)0, 50, NULL);\n\t\t}\n\t}\n}\nvoid AssetListDialog::resort()\n{\n\tunsigned int focusTarget_FileID = 0; pathid_t focusTarget_PathID = 0;\n\tif (iFocusedItem >= 0 && (size_t)iFocusedItem < listEntries.size())\n\t{\n\t\tfocusTarget_FileID = listEntries[iFocusedItem].fileID;\n\t\tfocusTarget_PathID = listEntries[iFocusedItem].pathID;\n\t}\n\tif (iSortColumn != 3 && iSortColumn != 4) //Most predicates require cached info, FileID and PathID being the exceptions.\n\t{\n\t\tif (!this->cacheAllAndShowProgress(true))\n\t\t{\n\t\t\tsorted = false;\n\t\t\treturn;\n\t\t}\n\t}\n\tauto pProgressIndicator = std::make_shared<CProgressIndicator>(this->pContext->getMainWindow().getHInstance());\n\tif (pProgressIndicator->Start(this->hDialog, pProgressIndicator, 2000))\n\t{\n\t\tpProgressIndicator->SetStepRange(0, 0);\n\t\tpProgressIndicator->SetCancellable(false);\n\t\tpProgressIndicator->SetTitle("Sorting the asset list");\n\t}\n\telse\n\t\tpProgressIndicator.reset();\n\tbool noChanges = false;\n\tswitch (iSortColumn)\n\t{\n\t\tcase 0: //Name\n\t\t\tstd::stable_sort(listEntries.begin(), listEntries.end(), SortPred_Name(this, sortOrderAscending));\n\t\t\tbreak;\n\t\tcase 1: //Container\n\t\t\tstd::stable_sort(listEntries.begin(), listEntries.end(), SortPred_ContainerName(this, sortOrderAscending));\n\t\t\tbreak;\n\t\tcase 2: //Type\n\t\t\tstd::stable_sort(listEntries.begin(), listEntries.end(), SortPred_TypeName(this, sortOrderAscending));\n\t\t\tbreak;\n\t\tcase 3: //File ID\n\t\t\tstd::stable_sort(listEntries.begin(), listEntries.end(), SortPred_FileID(sortOrderAscending));\n\t\t\tbreak;\n\t\tcase 4: //Path ID\n\t\t\tstd::stable_sort(listEntries.begin(), listEntries.end(), SortPred_PathID(sortOrderAscending));\n\t\t\tbreak;\n\t\tcase 5: //Size (Bytes)\n\t\t\tstd::stable_sort(listEntries.begin(), listEntries.end(), SortPred_Size(this, sortOrderAscending));\n\t\t\tbreak;\n\t\tcase 6: //Modified\n\t\t\tstd::stable_sort(listEntries.begin(), listEntries.end(), SortPred_Modified(this, sortOrderAscending));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tnoChanges = true;\n\t\t\tbreak;\n\t}\n\tif (pProgressIndicator != nullptr)\n\t{\n\t\tpProgressIndicator->End();\n\t\tpProgressIndicator->Free();\n\t\tpProgressIndicator.reset();\n\t}\n\tif (noChanges)\n\t\treturn;\n\n\tif (focusTarget_FileID != 0)\n\t{\n\t\tiFocusedItem = -1;\n\t\tfor (size_t i = 0; i < listEntries.size() && i <= INT_MAX; i++)\n\t\t{\n\t\t\tif (listEntries[i].fileID == focusTarget_FileID && listEntries[i].pathID == focusTarget_PathID)\n\t\t\t{\n\t\t\t\tiFocusedItem = (int)i;\n\t\t\t}\n\t\t}\n\t\tassert(iFocusedItem != -1);\n\t}\n\tif (hDialog)\n\t{\n\t\tHWND hAssetList = GetDlgItem(hDialog, IDC_ASSETLIST);\n\t\tif (iFocusedItem != -1)\n\t\t{\n\t\t\tListView_SetItemState(hAssetList, iFocusedItem, LVIS_FOCUSED, LVIS_FOCUSED);\n\t\t\tListView_EnsureVisible(hAssetList, iFocusedItem, FALSE);\n\t\t}\n\t\tListView_RedrawItems(hAssetList, 0, (int)std::min<size_t>(listEntries.size(), INT_MAX));\n\t\tif (!windowUpdateScheduled)\n\t\t{\n\t\t\twindowUpdateScheduled = true;\n\t\t\tSetTimer(hDialog, (uintptr_t)0, 50, NULL);\n\t\t}\n\t}\n\tsorted = true;\n}\n\nvoid AssetListDialog::getContainerInfo(AssetsFileContextInfo *pContextInfo, pathid_t pathID,\n\t\tOUT std::string &baseName, OUT std::string &containerListName)\n{\n\tunsigned int fileID = pContextInfo->getFileID();\n\tbool hasContainerBase = false;\n\tuint64_t baseCount = 0;\n\tuint64_t dependantCount = 0;\n\tbaseName.clear();\n\tcontainerListName.clear();\n\tstd::string exampleContainerName;\n\t{\n\t\tAssetContainerList *pMainContainersList = pContextInfo->tryLockContainersRead();\n\t\tif (pMainContainersList)\n\t\t{\n\t\t\tstd::vector<const ContainerEntry*> mainContainers = pMainContainersList->getContainers(0, pathID);\n\t\t\tif (mainContainers.size() > 0)\n\t\t\t{\n\t\t\t\thasContainerBase = true;\n\t\t\t\texampleContainerName = mainContainers[0]->name;\n\t\t\t\tbaseCount += mainContainers.size();\n\t\t\t}\n\t\t\tstd::vector<const ContainerEntry*> parentContainers = pMainContainersList->getParentContainers(0, pathID);\n\t\t\tif (parentContainers.size() > 0)\n\t\t\t{\n\t\t\t\tdependantCount += parentContainers.size();\n\t\t\t\tif (exampleContainerName.empty())\n\t\t\t\t\texampleContainerName = parentContainers[0]->name;\n\t\t\t}\n\t\t\tpContextInfo->unlockContainersRead();\n\t\t}\n\t}\n\tfor (size_t i = 0; i < pContextInfo->getContainerSources().size(); i++)\n\t{\n\t\tFileContextInfo_ptr pDepContextInfo = this->pContext->getContextInfo(pContextInfo->getContainerSources()[i]);\n\t\tif (pDepContextInfo != nullptr &&\n\t\t\tpDepContextInfo->getFileContext() &&\n\t\t\tpDepContextInfo->getFileContext()->getType() == FileContext_Assets)\n\t\t{\n\t\t\tAssetsFileContextInfo *pDepContextInfo_Assets = static_cast<AssetsFileContextInfo*>(pDepContextInfo.get());\n\t\t\tconst std::vector<unsigned int> referenceFileIDs = pDepContextInfo_Assets->getReferences();\n\t\t\tauto ownIDIt = std::find(referenceFileIDs.begin(), referenceFileIDs.end(), fileID);\n\t\t\tif (ownIDIt != referenceFileIDs.end())\n\t\t\t{\n\t\t\t\tsize_t relFileID = std::distance(referenceFileIDs.begin(), ownIDIt) + 1;\n\t\t\t\tassert(relFileID < UINT_MAX);\n\t\t\t\t\n\t\t\t\tAssetContainerList *pDepContainersList = pDepContextInfo_Assets->tryLockContainersRead();\n\t\t\t\tif (pDepContainersList)\n\t\t\t\t{\n\t\t\t\t\tstd::vector<const ContainerEntry*> mainContainers = pDepContainersList->getContainers((unsigned int)relFileID, pathID);\n\t\t\t\t\tif (mainContainers.size() > 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (!hasContainerBase || exampleContainerName.empty())\n\t\t\t\t\t\t\texampleContainerName = mainContainers[0]->name;\n\t\t\t\t\t\thasContainerBase = true;\n\t\t\t\t\t\tbaseCount += mainContainers.size();\n\t\t\t\t\t}\n\t\t\t\t\tstd::vector<const ContainerEntry*> parentContainers = pDepContainersList->getParentContainers((unsigned int)relFileID, pathID);\n\t\t\t\t\tif (parentContainers.size() > 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tdependantCount += parentContainers.size();\n\t\t\t\t\t\tif (exampleContainerName.empty())\n\t\t\t\t\t\t\texampleContainerName = parentContainers[0]->name;\n\t\t\t\t\t}\n\t\t\t\t\tpDepContextInfo_Assets->unlockContainersRead();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tchar nameExt[128]; nameExt[0] = 0;\n\tif (hasContainerBase)\n\t{\n\t\tif (baseCount > 1)\n\t\t\tsprintf_s(nameExt, " (Base, %llu other base containers, %llu dependants)", baseCount - 1, dependantCount);\n\t\telse\n\t\t\tsprintf_s(nameExt, " (Base, %llu dependants)", dependantCount);\n\t}\n\telse if (!exampleContainerName.empty())\n\t{\n\t\tif (dependantCount > 1)\n\t\t\tsprintf_s(nameExt, " (and %llu other dependant containers)", dependantCount - 1);\n\t\telse\n\t\t\tstrcpy_s(nameExt, " (dependant container)");\n\t}\n\tif (hasContainerBase)\n\t{\n\t\tauto slashIt = std::find(exampleContainerName.rbegin(), exampleContainerName.rend(), \'/\');\n\t\tif (slashIt != exampleContainerName.rend() && slashIt != exampleContainerName.rbegin())\n\t\t\tbaseName.assign(slashIt.base(), exampleContainerName.end()); //<reverse_iterator>.base() returns a forward iterator for the next item (in forward direction).\n\t\telse\n\t\t\tbaseName = exampleContainerName;\n\t}\n\tcontainerListName = std::move(exampleContainerName);\n\tif (nameExt[0] != 0)\n\t\tcontainerListName += nameExt;\n}\nbool AssetListDialog::TryRetrieveAssetNameField(AssetsFileContextInfo *pContextInfo, AssetIdentifier &identifier, std::string &nameOut,\n\tstd::unordered_map<NameTypeCacheKey, NameTypeCacheValue> &nameTypesCache)\n{\n\tif (identifier.pAssetInfo && !identifier.pReplacer)\n\t{\n\t\tIAssetsReader_ptr pReader(pContextInfo->getAssetsFileContext()->createReaderView(), Free_AssetsReader);\n\n\t\tif (identifier.pAssetInfo->ReadName(pContextInfo->getAssetsFileContext()->getAssetsFile(), nameOut, pReader.get()))\n\t\t\treturn true;\n\t}\n\tbool ret = false;\n\t{\n\t\tNameTypeCacheValue *pNameTypeValue = nullptr;\n\t\tNameTypeCacheKey key(pContextInfo->getFileID(), identifier.getClassID(), identifier.getMonoScriptID());\n\t\tauto typeFileCacheIt = nameTypesCache.find(key);\n\t\tif (typeFileCacheIt != nameTypesCache.end())\n\t\t\tpNameTypeValue = &typeFileCacheIt->second;\n\t\telse\n\t\t{\n\t\t\tNameTypeCacheValue newValue;\n\t\t\tnewValue.hasName = false;\n\t\t\tnewValue.nameChildIdx = 0;\n\t\t\tif (pContextInfo->MakeTemplateField(&newValue.templateBase, *this->pContext, identifier.getClassID(), identifier.getMonoScriptID(), &identifier))\n\t\t\t{\n\t\t\t\tAssetTypeTemplateField &templateBase = newValue.templateBase;\n\t\t\t\tfor (DWORD i = 0; i < templateBase.children.size(); i++)\n\t\t\t\t{\n\t\t\t\t\tif (templateBase.children[i].name == "m_Name"\n\t\t\t\t\t\t&& (templateBase.children[i].valueType == ValueType_String))\n\t\t\t\t\t{\n\t\t\t\t\t\tnewValue.hasName = true;\n\t\t\t\t\t\tnewValue.nameChildIdx = i;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tpNameTypeValue = &(nameTypesCache[key] = std::move(newValue));\n\t\t}\n\t\tif (pNameTypeValue->hasName)\n\t\t{\n\t\t\tIAssetsReader_ptr pReader = identifier.makeReader();\n\t\t\tif (pReader)\n\t\t\t{\n\t\t\t\tAssetTypeTemplateField *pTemplateBase = &pNameTypeValue->templateBase;\n\t\t\t\tAssetTypeValueField *pBase;\n\n\t\t\t\tuint32_t origChildCount = (uint32_t)pNameTypeValue->templateBase.children.size();\n\t\t\t\tstd::vector<AssetTypeTemplateField> childrenTmp = std::move(pNameTypeValue->templateBase.children);\n\t\t\t\tpNameTypeValue->templateBase.children.assign(childrenTmp.begin(), childrenTmp.begin() + (pNameTypeValue->nameChildIdx + 1));\n\t\t\t\tbool bigEndian = false;\n\t\t\t\tpContextInfo->getEndianness(bigEndian);\n\t\t\t\tAssetTypeInstance instance(1, &pTemplateBase, identifier.getDataSize(), pReader.get(), bigEndian);\n\t\t\t\tpBase = instance.GetBaseField();\n\t\t\t\tif (pBase)\n\t\t\t\t{\n\t\t\t\t\tAssetTypeValueField *pNameField = pBase->Get("m_Name");\n\t\t\t\t\tif (!pNameField->IsDummy() && pNameField->GetValue())\n\t\t\t\t\t{\n\t\t\t\t\t\tnameOut.assign(pNameField->GetValue()->AsString());\n\t\t\t\t\t\tret = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tpNameTypeValue->templateBase.children = std::move(childrenTmp);\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}\nsize_t AssetListDialog::cacheEntries(size_t start, size_t end, AssetInfo *&pFirstEntry, size_t nMax, size_t *maxVisitedIndex)\n{\n\tapplyDeferredChanges();\n\tstd::unordered_map<NameTypeCacheKey, NameTypeCacheValue> nameTypesCache;\n\tpFirstEntry = nullptr;\n\tif (maxVisitedIndex) *maxVisitedIndex = start;\n\tsize_t newCachedEntries = 0;\n\tif (start < listEntries.size())\n\t{\n\t\tif (end > listEntries.size())\n\t\t\tend = listEntries.size();\n\t\tsize_t i;\n\t\tfor (i = start; i < end && nMax > 0; i++)\n\t\t{\n\t\t\tunsigned int fileID = listEntries[i].fileID;\n\t\t\tpathid_t pathID = listEntries[i].pathID;\n\t\t\tauto fileEntryIt = fileEntries.find(fileID);\n\t\t\tif (fileEntryIt != fileEntries.end())\n\t\t\t{\n\t\t\t\tauto cacheEntryIt = fileEntryIt->second->assetCache.find(pathID);\n\t\t\t\tif (cacheEntryIt == fileEntryIt->second->assetCache.end())\n\t\t\t\t{\n\t\t\t\t\tFileEntryUIInfo *pUIInfo = fileEntryIt->second->pUIInfo;\n\t\t\t\t\tAssetsFileContextInfo *pContextInfo = static_cast<AssetsFileContextInfo*>(pUIInfo->getContextInfoPtr());\n\t\t\t\t\tAssetIdentifier identifier(std::static_pointer_cast<AssetsFileContextInfo,FileContextInfo>(pUIInfo->pContextInfo), pathID);\n\t\t\t\t\tif (identifier.resolve(*this->pContext))\n\t\t\t\t\t{\n\t\t\t\t\t\tAssetInfo info;\n\t\t\t\t\t\tinfo.typeID = identifier.getClassID();\n\t\t\t\t\t\tinfo.monoScriptID = identifier.getMonoScriptID();\n\t\t\t\t\t\tinfo.isModified = (identifier.pReplacer != nullptr);\n\t\t\t\t\t\tinfo.size = identifier.getDataSize();\n\t\t\t\t\t\tgetContainerInfo(pContextInfo, pathID, info.name, info.containerName);\n\t\t\t\t\t\tinfo.typeName = pContextInfo->GetClassName_(*this->pContext, info.typeID, info.monoScriptID, &identifier);\n\t\t\t\t\t\tif (info.name.empty())\n\t\t\t\t\t\t\tTryRetrieveAssetNameField(pContextInfo, identifier, info.name, nameTypesCache);\n\t\t\t\t\t\tif (info.typeName.empty())\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tchar sprntTmp[20];\n\t\t\t\t\t\t\tsprintf_s(sprntTmp, "0x%08X", info.typeID);\n\t\t\t\t\t\t\tinfo.typeName.assign(sprntTmp);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tauto newCacheEntryIt = fileEntryIt->second->assetCache.insert(\n\t\t\t\t\t\t\tfileEntryIt->second->assetCache.begin(), \n\t\t\t\t\t\t\tstd::make_pair(pathID, std::move(info)));\n\t\t\t\t\t\tif (!pFirstEntry)\n\t\t\t\t\t\t\tpFirstEntry = &newCacheEntryIt->second;\n\t\t\t\t\t\tnewCachedEntries++;\n\t\t\t\t\t\tnMax--;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (!pFirstEntry)\n\t\t\t\t\tpFirstEntry = &cacheEntryIt->second;\n\t\t\t}\n\t\t}\n\t\tif (maxVisitedIndex) *maxVisitedIndex = i;\n\t}\n\treturn newCachedEntries;\n}\nvoid AssetListDialog::getEntryText(int iItem, int iSubItem, AssetInfo &entry, OUT std::unique_ptr<TCHAR[]> &newTextBuf)\n{\n\tnewTextBuf.reset();\n\tTCHAR sprntTmp[64];\n\tint sprntSize = 0;\n\tnewTextBuf = nullptr;\n\tswitch (iSubItem)\n\t{\n\t\tcase 0: //Name\n\t\t\t{\n\t\t\t\tif (entry.name.empty())\n\t\t\t\t\tsprntSize = _stprintf_s(sprntTmp, TEXT("%s"), TEXT("Unnamed asset"));\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tsize_t nameLenT;\n\t\t\t\t\tTCHAR *pNameT = _MultiByteToTCHAR(entry.name.c_str(), nameLenT);\n\t\t\t\t\tif (pNameT)\n\t\t\t\t\t{\n\t\t\t\t\t\tnewTextBuf.reset(new TCHAR[nameLenT + 1]);\n\t\t\t\t\t\tmemcpy(newTextBuf.get(), pNameT, (nameLenT + 1) * sizeof(TCHAR));\n\t\t\t\t\t\t_FreeTCHAR(pNameT);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 1: //Container\n\t\t\t{\n\t\t\t\tsize_t nameLenT;\n\t\t\t\tTCHAR *pNameT = _MultiByteToTCHAR(entry.containerName.c_str(), nameLenT);\n\t\t\t\tif (pNameT)\n\t\t\t\t{\n\t\t\t\t\tnewTextBuf.reset(new TCHAR[nameLenT + 1]);\n\t\t\t\t\tmemcpy(newTextBuf.get(), pNameT, (nameLenT + 1) * sizeof(TCHAR));\n\t\t\t\t\t_FreeTCHAR(pNameT);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 2: //Type\n\t\t\t{\n\t\t\t\tsize_t nameLenT;\n\t\t\t\tTCHAR *pNameT = _MultiByteToTCHAR(entry.typeName.c_str(), nameLenT);\n\t\t\t\tif (pNameT)\n\t\t\t\t{\n\t\t\t\t\tnewTextBuf.reset(new TCHAR[nameLenT + 1]);\n\t\t\t\t\tmemcpy(newTextBuf.get(), pNameT, (nameLenT + 1) * sizeof(TCHAR));\n\t\t\t\t\t_FreeTCHAR(pNameT);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 128: //Type (plus Hex typeID)\n\t\t\t{\n\t\t\t\tsize_t nameLenT;\n\t\t\t\tTCHAR *pNameT = _MultiByteToTCHAR(entry.typeName.c_str(), nameLenT);\n\t\t\t\tif (pNameT)\n\t\t\t\t{\n\t\t\t\t\tint curSprntSize = _stprintf_s(sprntTmp, TEXT(" (0x%08X)"), entry.typeID);\n\t\t\t\t\tif (curSprntSize < 0) curSprntSize = 0;\n\t\t\t\t\tnewTextBuf.reset(new TCHAR[nameLenT + curSprntSize + 1]);\n\t\t\t\t\tmemcpy(newTextBuf.get(), pNameT, (nameLenT + 1) * sizeof(TCHAR));\n\t\t\t\t\tmemcpy(newTextBuf.get() + nameLenT, sprntTmp, (curSprntSize + 1) * sizeof(TCHAR));\n\t\t\t\t\t_FreeTCHAR(pNameT);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 3: //File ID\n\t\t\tsprntSize = _stprintf_s(sprntTmp, TEXT("%u"), this->listEntries[iItem].fileID);\n\t\t\tbreak;\n\t\tcase 4: //Path ID\n\t\t\tsprntSize = _stprintf_s(sprntTmp, TEXT("%lld"), (int64_t)this->listEntries[iItem].pathID);\n\t\t\tbreak;\n\t\tcase 5: //Size (Bytes)\n\t\t\tsprntSize = _stprintf_s(sprntTmp, TEXT("%llu"), entry.size);\n\t\t\tbreak;\n\t\tcase 6: //Modified\n\t\t\tsprntTmp[0] = (entry.isModified ? TEXT(\'*\') : 0);\n\t\t\tsprntTmp[1] = 0;\n\t\t\tsprntSize = (entry.isModified ? 1 : 0);\n\t\t\tbreak;\n\t}\n\tif (sprntSize > 0)\n\t{\n\t\tnewTextBuf.reset(new TCHAR[sprntSize + 1]);\n\t\tmemcpy(newTextBuf.get(), sprntTmp, (sprntSize + 1) * sizeof(TCHAR));\n\t}\n}\n\nvoid AssetListDialog::updateSelectionDesc()\n{\n\tsize_t firstSelection = SIZE_MAX;\n\tsize_t lastSelection = SIZE_MAX;\n\tsize_t nSelections = 0;\n\tfor (size_t i = 0; i < this->listEntries.size(); i++)\n\t{\n\t\tif (this->listEntries[i].isSelected)\n\t\t{\n\t\t\tlastSelection = i;\n\t\t\tnSelections++;\n\t\t}\n\t}\n\tif (nSelections <= 1)\n\t{\n\t\tif (this->pActiveModifyDialog == nullptr)\n\t\t{\n\t\t\tShowWindow(GetDlgItem(hDialog, IDC_NAMESTATIC), SW_SHOW);\n\t\t\tShowWindow(GetDlgItem(hDialog, IDC_EDITASSETNAME), SW_SHOW);\n\n\t\t\tShowWindow(GetDlgItem(hDialog, IDC_PATHIDSTATIC), SW_SHOW);\n\t\t\tShowWindow(GetDlgItem(hDialog, IDC_EDITASSETPATHID), SW_SHOW);\n\n\t\t\tShowWindow(GetDlgItem(hDialog, IDC_FILEIDSTATIC), SW_SHOW);\n\t\t\tShowWindow(GetDlgItem(hDialog, IDC_EDITASSETFILEID), SW_SHOW);\n\n\t\t\tShowWindow(GetDlgItem(hDialog, IDC_TYPESTATIC), SW_SHOW);\n\t\t\tShowWindow(GetDlgItem(hDialog, IDC_EDITASSETTYPE), SW_SHOW);\n\n\t\t\tShowWindow(GetDlgItem(hDialog, IDC_NUMSELSTATIC), SW_HIDE);\n\t\t}\n\n\t\tif (lastSelection > INT_MAX)\n\t\t\tnSelections = 0;\n\t\tif (nSelections == 1)\n\t\t{\n\t\t\tAssetInfo *pEntry = nullptr;\n\t\t\tthis->cacheEntry(lastSelection, pEntry);\n\t\t\tif (pEntry == nullptr)\n\t\t\t\tnSelections = 0;\n\t\t\telse\n\t\t\t{\n\t\t\t\tstd::unique_ptr<TCHAR[]> namePtr;\n\t\t\t\tthis->getEntryText(static_cast<int>(lastSelection), 0, *pEntry, namePtr); //Name\n\t\t\t\tEdit_SetText(GetDlgItem(hDialog, IDC_EDITASSETNAME), namePtr ? namePtr.get() : TEXT(""));\n\t\t\t\tthis->getEntryText(static_cast<int>(lastSelection), 4, *pEntry, namePtr); //Path ID\n\t\t\t\tEdit_SetText(GetDlgItem(hDialog, IDC_EDITASSETPATHID), namePtr ? namePtr.get() : TEXT(""));\n\t\t\t\tthis->getEntryText(static_cast<int>(lastSelection), 3, *pEntry, namePtr); //File ID\n\t\t\t\tEdit_SetText(GetDlgItem(hDialog, IDC_EDITASSETFILEID), namePtr ? namePtr.get() : TEXT(""));\n\t\t\t\tthis->getEntryText(static_cast<int>(lastSelection), 128, *pEntry, namePtr); //Type Name + Hex ID\n\t\t\t\tEdit_SetText(GetDlgItem(hDialog, IDC_EDITASSETTYPE), namePtr ? namePtr.get() : TEXT(""));\n\t\t\t}\n\t\t}\n\t\tif (nSelections == 0)\n\t\t{\n\t\t\tEdit_SetText(GetDlgItem(hDialog, IDC_EDITASSETNAME), TEXT(""));\n\t\t\tEdit_SetText(GetDlgItem(hDialog, IDC_EDITASSETPATHID), TEXT(""));\n\t\t\tEdit_SetText(GetDlgItem(hDialog, IDC_EDITASSETFILEID), TEXT(""));\n\t\t\tEdit_SetText(GetDlgItem(hDialog, IDC_EDITASSETTYPE), TEXT(""));\n\t\t}\n\t}\n\telse //if (nSelections > 1)\n\t{\n\t\tif (this->pActiveModifyDialog == nullptr)\n\t\t{\n\t\t\tShowWindow(GetDlgItem(hDialog, IDC_NAMESTATIC), SW_HIDE);\n\t\t\tShowWindow(GetDlgItem(hDialog, IDC_EDITASSETNAME), SW_HIDE);\n\n\t\t\tShowWindow(GetDlgItem(hDialog, IDC_PATHIDSTATIC), SW_HIDE);\n\t\t\tShowWindow(GetDlgItem(hDialog, IDC_EDITASSETPATHID), SW_HIDE);\n\n\t\t\tShowWindow(GetDlgItem(hDialog, IDC_FILEIDSTATIC), SW_HIDE);\n\t\t\tShowWindow(GetDlgItem(hDialog, IDC_EDITASSETFILEID), SW_HIDE);\n\n\t\t\tShowWindow(GetDlgItem(hDialog, IDC_TYPESTATIC), SW_HIDE);\n\t\t\tShowWindow(GetDlgItem(hDialog, IDC_EDITASSETTYPE), SW_HIDE);\n\n\t\t\tShowWindow(GetDlgItem(hDialog, IDC_NUMSELSTATIC), SW_SHOW);\n\t\t}\n\n\t\tTCHAR sprntTmp[64];\n\t\t_stprintf_s(sprntTmp, TEXT("%llu selected assets"), (uint64_t)nSelections);\n\t\tEdit_SetText(GetDlgItem(hDialog, IDC_NUMSELSTATIC), sprntTmp);\n\t}\n\tthis->lastNumSelections = nSelections;\n}\n\nvoid AssetListDialog::requestRemoveSelectedAssets()\n{\n\tstd::vector<size_t> selections;\n\tfor (size_t i = 0; i < this->listEntries.size(); i++)\n\t{\n\t\tif (this->listEntries[i].isSelected)\n\t\t{\n\t\t\tselections.push_back(i);\n\t\t}\n\t}\n\tif (selections.size() > 0 &&\n\t\tMessageBox(\n\t\t\thDialog, \n\t\t\tTEXT("Are you sure you want to remove the selected asset(s)?\\nThis will break any reference to the selection."), \n\t\t\tTEXT("Warning"), \n\t\t\tMB_YESNO)\n\t\t\t== IDYES)\n\t{\n\t\tauto pProgressIndicator = std::make_shared<CProgressIndicator>(this->pContext->getMainWindow().getHInstance());\n\t\tif (pProgressIndicator->Start(this->hDialog, pProgressIndicator, 2000))\n\t\t{\n\t\t\tpProgressIndicator->SetStepRange(0, (unsigned int)std::min<size_t>(INT_MAX, listEntries.size()));\n\t\t\tpProgressIndicator->SetCancellable(true);\n\t\t\tpProgressIndicator->SetTitle("Removing assets");\n\t\t}\n\t\telse\n\t\t\tpProgressIndicator.reset();\n\t\tsize_t _progressUpdateCounter = 431;\n\t\tfor (size_t i = 0; i < selections.size(); ++i)\n\t\t{\n\t\t\tif (pProgressIndicator && pProgressIndicator->IsCancelled())\n\t\t\t\tbreak;\n\t\t\tif (pProgressIndicator && (_progressUpdateCounter++) == 431)\n\t\t\t{\n\t\t\t\t_progressUpdateCounter = 0;\n\t\t\t\tpProgressIndicator->SetDescription(std::format("Removing asset {} / {}", i + 1, listEntries.size()));\n\t\t\t\tpProgressIndicator->SetStepStatus((unsigned int)std::min<size_t>(INT_MAX, i));\n\t\t\t}\n\t\t\tsize_t nListEntriesPre = this->listEntries.size();\n\t\t\tunsigned int fileID = this->listEntries[selections[i]].fileID;\n\t\t\tpathid_t pathID = this->listEntries[selections[i]].pathID;\n\t\t\tFileContextInfo_ptr pContextInfo = this->pContext->getContextInfo(fileID);\n\t\t\tif (pContextInfo->getFileContext() != nullptr && pContextInfo->getFileContext()->getType() == FileContext_Assets)\n\t\t\t{\n\t\t\t\tAssetsFileContextInfo *pAssetsInfo = reinterpret_cast<AssetsFileContextInfo*>(pContextInfo.get());\n\t\t\t\tAssetIdentifier identifier(std::shared_ptr<AssetsFileContextInfo>(pContextInfo, pAssetsInfo), pathID);\n\t\t\t\tif (identifier.resolve(*this->pContext))\n\t\t\t\t\tpAssetsInfo->addReplacer(std::shared_ptr<AssetsEntryReplacer>(\n\t\t\t\t\t\tMakeAssetRemover(fileID, pathID, identifier.getClassID(), identifier.getMonoScriptID()), FreeAssetsReplacer),\n\t\t\t\t\t\t*this->pContext);\n\t\t\t}\n\t\t\t//Check the assumption that the \'change asset\' callbacks are not applied recursively (i.e. PostMessage, not SendMessage).\n\t\t\tassert(this->listEntries.size() == nListEntriesPre);\n\t\t}\n\t\tif (pProgressIndicator != nullptr)\n\t\t{\n\t\t\tpProgressIndicator->End();\n\t\t\tpProgressIndicator->Free();\n\t\t}\n\t\tListView_SetItemCount(GetDlgItem(hDialog, IDC_ASSETLIST), (int)std::min<size_t>(listEntries.size(), INT_MAX));\n\t}\n}\n\ninline void doMoveWindow(HDWP &deferCtx, bool &retry, HWND hWnd, int x, int y, int w, int h)\n{\n\tif (deferCtx)\n\t{\n\t\tdeferCtx = DeferWindowPos(deferCtx, hWnd, HWND_TOP, x, y, w, h, SWP_NOACTIVATE | SWP_NOOWNERZORDER | SWP_NOZORDER);\n\t\tif (!deferCtx)\n\t\t\tretry = true;\n\t}\n\telse\n\t\tSetWindowPos(hWnd, HWND_TOP, x, y, w, h, SWP_NOACTIVATE | SWP_NOOWNERZORDER | SWP_NOZORDER);\n}\nstatic void onResize(HWND hDlg, HWND hActiveTabWnd, bool defer = true)\n{\n\tbool showTabs = false;\n\tLONG tabY = 10;\n\tif (SendMessage(GetDlgItem(hDlg, IDC_ASSETLISTMODIFYTABS), MC_MTM_GETITEMCOUNT, 0, 0) > 1)\n\t{\n\t\tshowTabs = true;\n\t\ttabY = 35;\n\t}\n\n\t{\n\t\tbool showAssetList = true;\n\t\tShowWindow(GetDlgItem(hDlg, IDC_ASSETLISTMODIFYTABS), showTabs ? SW_SHOW : SW_HIDE);\n\t\tif (hActiveTabWnd != NULL)\n\t\t{\n\t\t\tShowWindow(hActiveTabWnd, SW_SHOW);\n\t\t\tshowAssetList = false;\n\t\t}\n\t\tShowWindow(GetDlgItem(hDlg, IDC_ASSETSSTATIC),        showAssetList ? SW_SHOW : SW_HIDE);\n\t\tShowWindow(GetDlgItem(hDlg, IDC_ASSETLIST),           showAssetList ? SW_SHOW : SW_HIDE);\n\t\tShowWindow(GetDlgItem(hDlg, IDC_VIEWDATA),            showAssetList ? SW_SHOW : SW_HIDE);\n\t\tShowWindow(GetDlgItem(hDlg, IDC_EXPORTRAW),           showAssetList ? SW_SHOW : SW_HIDE);\n\t\tShowWindow(GetDlgItem(hDlg, IDC_DUMPDATA),            showAssetList ? SW_SHOW : SW_HIDE);\n\t\tShowWindow(GetDlgItem(hDlg, IDC_PLUGINS),             showAssetList ? SW_SHOW : SW_HIDE);\n\t\tShowWindow(GetDlgItem(hDlg, IDC_IMPORTRAW),           showAssetList ? SW_SHOW : SW_HIDE);\n\t\tShowWindow(GetDlgItem(hDlg, IDC_IMPORTDUMP),          showAssetList ? SW_SHOW : SW_HIDE);\n\t\tShowWindow(GetDlgItem(hDlg, IDC_REMOVEASSET),         showAssetList ? SW_SHOW : SW_HIDE);\n\t\tif (!showAssetList)\n\t\t{\n\t\t\tShowWindow(GetDlgItem(hDlg, IDC_NAMESTATIC), SW_HIDE);\n\t\t\tShowWindow(GetDlgItem(hDlg, IDC_EDITASSETNAME), SW_HIDE);\n\n\t\t\tShowWindow(GetDlgItem(hDlg, IDC_PATHIDSTATIC), SW_HIDE);\n\t\t\tShowWindow(GetDlgItem(hDlg, IDC_EDITASSETPATHID), SW_HIDE);\n\n\t\t\tShowWindow(GetDlgItem(hDlg, IDC_FILEIDSTATIC), SW_HIDE);\n\t\t\tShowWindow(GetDlgItem(hDlg, IDC_EDITASSETFILEID), SW_HIDE);\n\n\t\t\tShowWindow(GetDlgItem(hDlg, IDC_TYPESTATIC), SW_HIDE);\n\t\t\tShowWindow(GetDlgItem(hDlg, IDC_EDITASSETTYPE), SW_HIDE);\n\n\t\t\tShowWindow(GetDlgItem(hDlg, IDC_NUMSELSTATIC), SW_HIDE);\n\t\t}\n\t}\n\n\n\tHDWP deferCtx = defer ? BeginDeferWindowPos(12) : NULL;\n\tbool retry = false;\n\n\tRECT client = {};\n\tGetClientRect(hDlg, &client);\n\tLONG clientWidth = client.right-client.left;\n\tLONG clientHeight = client.bottom-client.top;\n\tLONG rightPanelSize = std::min<LONG>(200, (clientWidth / 3) - 56);\n\tLONG rightPanelStart = clientWidth - (rightPanelSize + 16);\n\tLONG leftPanelStart = 19;\n\tLONG leftPanelSize = rightPanelStart - 7 - leftPanelStart;\n\t//LONG rightPanelSize = std::min<LONG>(200, clientWidth - ((2*clientWidth / 3) + 40));\n\tdoMoveWindow(deferCtx, retry, GetDlgItem(hDlg, IDC_ASSETLISTMODIFYTABS), 0, 0,  clientWidth, 25);\n\tif (hActiveTabWnd != NULL)\n\t\tdoMoveWindow(deferCtx, retry, hActiveTabWnd, leftPanelStart, tabY, rightPanelStart + rightPanelSize - leftPanelStart, clientHeight - tabY);\n\tdoMoveWindow(deferCtx, retry, GetDlgItem(hDlg, IDC_ASSETSSTATIC),        leftPanelStart + 2, tabY + 0,   leftPanelSize - 2, 15);\n\tdoMoveWindow(deferCtx, retry, GetDlgItem(hDlg, IDC_ASSETLIST),           leftPanelStart,     tabY + 20,  leftPanelSize,     clientHeight - tabY - 20 - 7);\n\tdoMoveWindow(deferCtx, retry, GetDlgItem(hDlg, IDC_NUMSELSTATIC),        rightPanelStart,    tabY + 20,  rightPanelSize,    15);\n\tdoMoveWindow(deferCtx, retry, GetDlgItem(hDlg, IDC_NAMESTATIC),          rightPanelStart,    tabY + 20,  50, 15);\n\tdoMoveWindow(deferCtx, retry, GetDlgItem(hDlg, IDC_EDITASSETNAME),       rightPanelStart,    tabY + 35,  rightPanelSize,    20);\n\tdoMoveWindow(deferCtx, retry, GetDlgItem(hDlg, IDC_PATHIDSTATIC),        rightPanelStart,    tabY + 59,  50, 15);\n\tdoMoveWindow(deferCtx, retry, GetDlgItem(hDlg, IDC_EDITASSETPATHID),     rightPanelStart,    tabY + 74,  rightPanelSize,    20);\n\tdoMoveWindow(deferCtx, retry, GetDlgItem(hDlg, IDC_FILEIDSTATIC),        rightPanelStart,    tabY + 98,  50, 15);\n\tdoMoveWindow(deferCtx, retry, GetDlgItem(hDlg, IDC_EDITASSETFILEID),     rightPanelStart,    tabY + 113, rightPanelSize,    20);\n\tdoMoveWindow(deferCtx, retry, GetDlgItem(hDlg, IDC_TYPESTATIC),          rightPanelStart,    tabY + 137, 50, 15);\n\tdoMoveWindow(deferCtx, retry, GetDlgItem(hDlg, IDC_EDITASSETTYPE),       rightPanelStart,    tabY + 152, rightPanelSize,    20);\n\tdoMoveWindow(deferCtx, retry, GetDlgItem(hDlg, IDC_VIEWDATA),            rightPanelStart,    tabY + 191, rightPanelSize,    25);\n\tdoMoveWindow(deferCtx, retry, GetDlgItem(hDlg, IDC_EXPORTRAW),           rightPanelStart,    tabY + 235, rightPanelSize,    25);\n\tdoMoveWindow(deferCtx, retry, GetDlgItem(hDlg, IDC_DUMPDATA),            rightPanelStart,    tabY + 279, rightPanelSize,    25);\n\tdoMoveWindow(deferCtx, retry, GetDlgItem(hDlg, IDC_PLUGINS),             rightPanelStart,    tabY + 323, rightPanelSize,    25);\n\tdoMoveWindow(deferCtx, retry, GetDlgItem(hDlg, IDC_IMPORTRAW),           rightPanelStart,    tabY + 367, rightPanelSize,    25);\n\tdoMoveWindow(deferCtx, retry, GetDlgItem(hDlg, IDC_IMPORTDUMP),          rightPanelStart,    tabY + 411, rightPanelSize,    25);\n\tdoMoveWindow(deferCtx, retry, GetDlgItem(hDlg, IDC_REMOVEASSET),         rightPanelStart,    tabY + 460, rightPanelSize,    25);\n\t//doMoveWindow(deferCtx, retry, GetDlgItem(hDlg, IDOK), (clientWidth / 2) - 38, clientHeight - 33, 76, 26);\n\n\tif (defer)\n\t{\n\t\tif (retry || !EndDeferWindowPos(deferCtx))\n\t\t\tonResize(hDlg, hActiveTabWnd, false);\n\t\telse\n\t\t\tUpdateWindow(hDlg);\n\t\tdeferCtx = NULL;\n\t}\n\telse\n\t\tUpdateWindow(hDlg);\n\n}\nvoid AssetListDialog::onCacheUpdateTick()\n{\n\tKillTimer(hDialog, (uintptr_t)1);\n\tapplyDeferredChanges();\n\tif (!entryCachingScheduled || cachedListEntryCount >= listEntries.size())\n\t{\n\t\tentryCachingScheduled = false;\n\t}\n\telse\n\t{\n\t\tbool updateTickFrequency = false;\n\t\tif (ticksUntilCacheFreqUpdate-- == 0)\n\t\t{\n\t\t\tupdateTickFrequency = true;\n\t\t\tticksUntilCacheFreqUpdate = 10;\n\t\t}\n\t\tLARGE_INTEGER preTimer;\n\t\tif (updateTickFrequency) QueryPerformanceCounter(&preTimer);\n\n\t\tif (cachedListEntryStartIdx > listEntries.size()) cachedListEntryStartIdx = 0;\n\t\tAssetInfo *tmp;\n\t\tsize_t newEntries = cacheEntries(cachedListEntryStartIdx, listEntries.size(), tmp, maxEntriesPerTick, &cachedListEntryStartIdx);\n\t\tif (newEntries < std::min(maxEntriesPerTick, listEntries.size() - cachedListEntryCount))\n\t\t{\n\t\t\t//The list probably was sorted after starting auto caching, or another dialog worked on the same file cache.\n\t\t\tnewEntries += cacheEntries(0, listEntries.size(), tmp, maxEntriesPerTick - newEntries, &cachedListEntryStartIdx);\n\t\t\tcachedListEntryCount = cachedListEntryStartIdx;\n\t\t}\n\t\telse\n\t\t\tcachedListEntryCount += newEntries;\n\t\tif (newEntries == 0 && maxEntriesPerTick > 0)\n\t\t\tcachedListEntryCount = listEntries.size();\n\t\tif (cachedListEntryCount > listEntries.size())\n\t\t{\n\t\t\tassert(false); //cachedListEntryCount is inconsistent with listEntries\n\t\t\tcachedListEntryCount = listEntries.size();\n\t\t}\n\t\tif (updateTickFrequency)\n\t\t{\n\t\t\tLARGE_INTEGER postTimer;\n\t\t\tQueryPerformanceCounter(&postTimer);\n\t\t\tQWORD deltaMicro = ((postTimer.QuadPart - preTimer.QuadPart) * 1000000) / qpfrequency.QuadPart;\n\t\t\tif (deltaMicro < 9000)\n\t\t\t{\n\t\t\t\tif (maxEntriesPerTick >= deltaMicro / 4)\n\t\t\t\t{\n\t\t\t\t\t//Calculating the "optimal" amount of ticks would run\n\t\t\t\t\t// into precision issues and potentially division by zero.\n\t\t\t\t\t//Controlled cultivation should be a healthy choice.\n\t\t\t\t\tif (deltaMicro < 6500)\n\t\t\t\t\t\tmaxEntriesPerTick *= 2;\n\t\t\t\t\telse\n\t\t\t\t\t\tmaxEntriesPerTick = (maxEntriesPerTick / 4) * 5;\n\t\t\t\t\tif (maxEntriesPerTick < 10) \n\t\t\t\t\t\tmaxEntriesPerTick = 10;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t//Try to approach the target of 10ms/tick by increasing the amount of entries per tick.\n\t\t\t\t\tsize_t targetMaxEntries = std::max<size_t>(16, 10000 / (deltaMicro / maxEntriesPerTick));\n\t\t\t\t\tif (targetMaxEntries < maxEntriesPerTick) targetMaxEntries = maxEntriesPerTick + 8;\n\t\t\t\t\tsize_t delta = targetMaxEntries - maxEntriesPerTick;\n\t\t\t\t\t//Contain the spread by limiting the growth rate.\n\t\t\t\t\tmaxEntriesPerTick += (delta / 4) * 3;\n\t\t\t\t}\n\t\t\t}\n\t\t\t//else if (deltaMicro >= 9000 && deltaMicro < 13000)\n\t\t\t//{growth rate near 1 for now}\n\t\t\telse if (deltaMicro >= 13000)\n\t\t\t{\n\t\t\t\tif (maxEntriesPerTick <= 10) \n\t\t\t\t{\n\t\t\t\t\t//Probably some bottleneck in traversing the list if it was sorted after starting caching.\n\t\t\t\t\t//Just disable auto caching in that case, since reducing the amount of entries further likely won\'t help.\n\t\t\t\t\tentryCachingScheduled = false;\n\t\t\t\t}\n\t\t\t\telse if (maxEntriesPerTick >= deltaMicro / 4)\n\t\t\t\t{\n\t\t\t\t\t//Calculating the "optimal" amount of ticks would run\n\t\t\t\t\t// into precision issues and potentially division by zero.\n\t\t\t\t\t//Some numeric distancing should be a reasonable choice in this case.\n\t\t\t\t\tmaxEntriesPerTick = deltaMicro / 8;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t//Try to approach the target of 10ms/tick by decreasing the amount of entries per tick.\n\t\t\t\t\tsize_t targetMaxEntries = std::max<size_t>(10, 10000 / (deltaMicro / maxEntriesPerTick));\n\t\t\t\t\tif (targetMaxEntries >= maxEntriesPerTick) targetMaxEntries = maxEntriesPerTick - 8;\n\t\t\t\t\tsize_t delta = maxEntriesPerTick - targetMaxEntries;\n\t\t\t\t\tif (delta < 4)\n\t\t\t\t\t{\n\t\t\t\t\t\tswitch (delta)\n\t\t\t\t\t\t{\n\t\t\t\t\t\tcase 1: break;\n\t\t\t\t\t\tcase 2: maxEntriesPerTick--; break;\n\t\t\t\t\t\tcase 3: maxEntriesPerTick--; break;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t\tmaxEntriesPerTick -= (delta / 4) * 3;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (entryCachingScheduled)\n\t\t\tSetTimer(hDialog, (uintptr_t)1, 16, NULL);\n\t}\n}\nLRESULT CALLBACK AssetListDialog::ListViewSubclassProc(HWND hWnd, UINT message, \n\t\tWPARAM wParam, LPARAM lParam, \n\t\tuintptr_t uIdSubclass, DWORD_PTR dwRefData)\n{\n\tAssetListDialog *pThis = (AssetListDialog*)dwRefData;\n\t//switch (message)\n\t//{\n\t//}\n    return DefSubclassProc(hWnd, message, wParam, lParam);\n}\nvoid AssetListDialog::searchNext()\n{\n\tif (searchQuery.empty())\n\t\treturn;\n\tsize_t iCur = (this->searchDirectionUp) ? this->listEntries.size() : 0;\n\tListEntrySelectionIterator selectionIter(*this);\n\tif (!selectionIter.isEnd())\n\t{\n\t\tiCur = (*selectionIter) + 1;\n\t}\n\tauto checkEntry = [this](size_t iCur)\n\t{\n\t\tif (this->listEntries[iCur].isSelected)\n\t\t\treturn false;\n\t\tunsigned int fileID = this->listEntries[iCur].fileID;\n\t\tpathid_t pathID = this->listEntries[iCur].pathID;\n\t\tAssetInfo* pEntry = nullptr;\n\t\tauto fileEntryIt = fileEntries.find(fileID);\n\t\tif (fileEntryIt != fileEntries.end())\n\t\t{\n\t\t\tauto cacheEntryIt = fileEntryIt->second->assetCache.find(pathID);\n\t\t\tif (cacheEntryIt != fileEntryIt->second->assetCache.end())\n\t\t\t\tpEntry = &cacheEntryIt->second;\n\t\t}\n\t\tif (pEntry == nullptr)\n\t\t{\n\t\t\tthis->cacheEntries(\n\t\t\t\tiCur,\n\t\t\t\t(iCur < SIZE_MAX - 10) ? std::min(iCur + 10, this->listEntries.size()) : (iCur + 1),\n\t\t\t\tpEntry);\n\t\t\tif (pEntry == nullptr)\n\t\t\t\treturn false;\n\t\t}\n\t\tif (std::regex_search(pEntry->name, this->searchRegex) || std::regex_search(pEntry->containerName, this->searchRegex))\n\t\t{\n\t\t\tthis->selectAsset(fileID, pathID);\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t};\n\n\tauto pProgressIndicator = std::make_shared<CProgressIndicator>(this->pContext->getMainWindow().getHInstance());\n\tif (pProgressIndicator->Start(this->hDialog, pProgressIndicator, 2000))\n\t{\n\t\tpProgressIndicator->SetCancellable(true);\n\t\tpProgressIndicator->SetTitle("Searching for asset");\n\t}\n\telse\n\t\tpProgressIndicator.reset();\n\n\tsize_t _progressUpdateCounter = 431;\n\tbool requestCancel = false;\n\tauto updateProgress = [&pProgressIndicator, &_progressUpdateCounter, &requestCancel](size_t progress, size_t total)\n\t{\n\t\tif (pProgressIndicator && (_progressUpdateCounter++) == 431)\n\t\t{\n\t\t\t_progressUpdateCounter = 0;\n\t\t\tpProgressIndicator->SetDescription(std::format("Processing asset {} / {}", progress + 1, total));\n\t\t\tpProgressIndicator->SetStepStatus((unsigned int)std::min<size_t>(INT_MAX, progress));\n\t\t}\n\t\tif (pProgressIndicator && pProgressIndicator->IsCancelled())\n\t\t\trequestCancel = true;\n\t};\n\n\tif (this->searchDirectionUp)\n\t{\n\t\tsize_t iStart = iCur;\n\t\tsize_t total = iCur;\n\t\tif (pProgressIndicator)\n\t\t\tpProgressIndicator->SetStepRange(0, (unsigned int)std::min<size_t>(INT_MAX, total));\n\t\tfor (; !requestCancel && iCur > 0 && !checkEntry(iCur - 1); --iCur)\n\t\t\tupdateProgress(iStart - iCur, total);\n\t}\n\telse\n\t{\n\t\tsize_t iStart = iCur;\n\t\tsize_t total = this->listEntries.size() - iCur;\n\t\tif (pProgressIndicator)\n\t\t\tpProgressIndicator->SetStepRange(0, (unsigned int)std::min<size_t>(INT_MAX, total));\n\t\tfor (; !requestCancel && iCur < this->listEntries.size() && !checkEntry(iCur); ++iCur)\n\t\t\tupdateProgress(iCur - iStart, total);\n\t}\n\tif (pProgressIndicator != nullptr)\n\t{\n\t\tpProgressIndicator->End();\n\t\tpProgressIndicator->Free();\n\t}\n\t//TODO: Add some indication if no result was found.\n}\nINT_PTR CALLBACK AssetListDialog::GotoDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)\n{\n\tAssetListDialog* pThis = (AssetListDialog*)GetWindowLongPtr(hDlg, GWLP_USERDATA);\n\tint wmId, wmEvent;\n\tUNREFERENCED_PARAMETER(lParam);\n\tswitch (message)\n\t{\n\tcase WM_CLOSE:\n\tcase WM_DESTROY:\n\t\tbreak;\n\tcase WM_INITDIALOG:\n\t{\n\t\tSetWindowLongPtr(hDlg, GWLP_USERDATA, lParam);\n\t\tpThis = (AssetListDialog*)lParam;\n\n\t\tunsigned int selectedFileID = 0;\n\t\tpathid_t selectedPathID = 0;\n\t\tListEntrySelectionIterator selectionIter(*pThis);\n\t\tif (!selectionIter.isEnd())\n\t\t{\n\t\t\tsize_t iSelection = *selectionIter;\n\t\t\tselectedFileID = pThis->listEntries[iSelection].fileID;\n\t\t\tselectedPathID = pThis->listEntries[iSelection].pathID;\n\t\t}\n\n\t\tHWND hComboAssets = GetDlgItem(hDlg, IDC_COMBOASSETS);\n\t\tpThis->gotoDlg_uiToFileIDMapping.clear();\n\t\t//Iterating through an unordered_map is not the most efficient, but good enough here.\n\t\tfor (std::pair<const unsigned int, FileEntryCacheRef>& entryRef : pThis->fileEntries)\n\t\t{\n\t\t\tunsigned int fileID = entryRef.first;\n\t\t\tpThis->gotoDlg_uiToFileIDMapping.push_back(fileID);\n\t\t}\n\t\tstd::sort(pThis->gotoDlg_uiToFileIDMapping.begin(), pThis->gotoDlg_uiToFileIDMapping.end());\n\t\tint cbSelection = -1;\n\t\tfor (size_t i = 0; i < pThis->gotoDlg_uiToFileIDMapping.size(); ++i)\n\t\t{\n\t\t\tunsigned int fileID = pThis->gotoDlg_uiToFileIDMapping[i];\n\t\t\tauto pAssetsInfo = std::dynamic_pointer_cast<AssetsFileContextInfo>(\n\t\t\t\tpThis->pContext->getContextInfo(fileID));\n\t\t\tassert(pAssetsInfo != nullptr);\n\t\t\tstd::string desc = std::format("{} - {}",\n\t\t\t\tfileID,\n\t\t\t\t(pAssetsInfo != nullptr) ? pAssetsInfo->getFileName() : std::string(""));\n\t\t\tauto tCbEntryText = unique_MultiByteToTCHAR(desc.c_str());\n\t\t\tComboBox_AddString(hComboAssets, tCbEntryText.get());\n\t\t\tif (fileID == selectedFileID && i < std::numeric_limits<int>::max())\n\t\t\t\tcbSelection = (int)i;\n\t\t}\n\t\tif (cbSelection != -1)\n\t\t{\n\t\t\tComboBox_SetCurSel(hComboAssets, cbSelection);\n\t\t\tstd::basic_string<TCHAR> pathIDText = std::to_wstring((int64_t)selectedPathID);\n\t\t\tEdit_SetText(GetDlgItem(hDlg, IDC_EDITPATHID), pathIDText.c_str());\n\t\t}\n\t\treturn (INT_PTR)TRUE;\n\t}\n\tcase WM_COMMAND:\n\t\twmId = LOWORD(wParam);\n\t\twmEvent = HIWORD(wParam);\n\t\tswitch (wmId)\n\t\t{\n\t\tcase IDOK:\n\t\t{\n\t\t\tchar numberTmp[25];\n\t\t\tGetWindowTextA(GetDlgItem(hDlg, IDC_EDITPATHID), numberTmp, 25);\n\t\t\tnumberTmp[24] = 0;\n\t\t\t__int64 pathID;\n\t\t\tif (numberTmp[0] == \'-\')\n\t\t\t\tpathID = _strtoi64(numberTmp, NULL, 0);\n\t\t\telse\n\t\t\t\tpathID = (__int64)_strtoui64(numberTmp, NULL, 0);\n\n\t\t\tint fileIDSel = ComboBox_GetCurSel(GetDlgItem(hDlg, IDC_COMBOASSETS));\n\t\t\tif (fileIDSel < 0 || (unsigned int)fileIDSel >= pThis->gotoDlg_uiToFileIDMapping.size())\n\t\t\t\treturn (INT_PTR)TRUE;\n\n\t\t\tunsigned int fileID = pThis->gotoDlg_uiToFileIDMapping[(unsigned int)fileIDSel];\n\n\t\t\tpThis->selectAsset(fileID, (pathid_t)pathID);\n\t\t}\n\t\tcase IDCANCEL:\n\t\t\tEndDialog(hDlg, LOWORD(wParam));\n\t\t\treturn (INT_PTR)TRUE;\n\t\t}\n\t\tbreak;\n\t}\n\treturn (INT_PTR)FALSE;\n}\nINT_PTR CALLBACK AssetListDialog::SearchDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)\n{\n\tAssetListDialog* pThis = (AssetListDialog*)GetWindowLongPtr(hDlg, GWLP_USERDATA);\n\tint wmId, wmEvent;\n\tUNREFERENCED_PARAMETER(lParam);\n\tswitch (message)\n\t{\n\tcase WM_CLOSE:\n\tcase WM_DESTROY:\n\t\tbreak;\n\tcase WM_INITDIALOG:\n\t{\n\t\tSetWindowLongPtr(hDlg, GWLP_USERDATA, lParam);\n\t\tpThis = (AssetListDialog*)lParam;\n\t\tauto tQuery = unique_MultiByteToTCHAR(pThis->searchQuery.c_str());\n\t\tSetWindowText(GetDlgItem(hDlg, IDC_EDITQUERY), tQuery.get());\n\t\tButton_SetCheck(GetDlgItem(hDlg, IDC_CKCASESENS), pThis->searchCaseSensitive ? TRUE : FALSE);\n\t\tButton_SetCheck(GetDlgItem(hDlg, pThis->searchDirectionUp ? IDC_RBUP : IDC_RBDOWN), TRUE);\n\t\treturn (INT_PTR)TRUE;\n\t}\n\tcase WM_COMMAND:\n\t\twmId = LOWORD(wParam);\n\t\twmEvent = HIWORD(wParam);\n\t\tswitch (wmId)\n\t\t{\n\t\tcase IDC_RBUP:\n\t\t{\n\t\t\tif (Button_GetCheck(GetDlgItem(hDlg, IDC_RBUP)) == BST_CHECKED)\n\t\t\t\tButton_SetCheck(GetDlgItem(hDlg, IDC_RBDOWN), BST_UNCHECKED);\n\t\t\telse if (Button_GetCheck(GetDlgItem(hDlg, IDC_RBDOWN)) != BST_CHECKED)\n\t\t\t\tButton_SetCheck(GetDlgItem(hDlg, IDC_RBDOWN), BST_CHECKED);\n\t\t\tbreak;\n\t\t}\n\t\tcase IDC_RBDOWN:\n\t\t{\n\t\t\tif (Button_GetCheck(GetDlgItem(hDlg, IDC_RBDOWN)) == BST_CHECKED)\n\t\t\t\tButton_SetCheck(GetDlgItem(hDlg, IDC_RBUP), BST_UNCHECKED);\n\t\t\telse if (Button_GetCheck(GetDlgItem(hDlg, IDC_RBUP)) != BST_CHECKED)\n\t\t\t\tButton_SetCheck(GetDlgItem(hDlg, IDC_RBUP), BST_CHECKED);\n\t\t\tbreak;\n\t\t}\n\t\tcase IDOK:\n\t\t{\n\t\t\tHWND hEditQuery = GetDlgItem(hDlg, IDC_EDITQUERY);\n\t\t\tDWORD textLen = Edit_GetTextLength(hEditQuery);\n\t\t\tif (textLen >= (DWORD)std::numeric_limits<int>::max())\n\t\t\t\tbreak;\n\t\t\tstd::vector<wchar_t> textBuf(textLen + 1);\n\t\t\tGetWindowText(GetDlgItem(hDlg, IDC_EDITQUERY), textBuf.data(), (int)textBuf.size());\n\t\t\ttextBuf.back() = 0;\n\t\t\tauto queryU8 = unique_TCHARToMultiByte(textBuf.data());\n\t\t\tpThis->searchQuery.assign(queryU8.get());\n\n\t\t\tpThis->searchCaseSensitive =\n\t\t\t\tButton_GetCheck(GetDlgItem(hDlg, IDC_CKCASESENS)) ? true : false;\n\t\t\tpThis->searchDirectionUp =\n\t\t\t\t(Button_GetCheck(GetDlgItem(hDlg, IDC_RBUP)) == BST_CHECKED);\n\n\t\t\tstd::string regexStr = "";\n\t\t\tfor (size_t iChar = 0; iChar < pThis->searchQuery.size(); ++iChar)\n\t\t\t{\n\t\t\t\tswitch (pThis->searchQuery[iChar])\n\t\t\t\t{\n\t\t\t\tcase \'*\':\n\t\t\t\t\tregexStr += ".*";\n\t\t\t\t\tbreak;\n\t\t\t\tcase \'(\': case \'[\': case \']\': case \')\':\n\t\t\t\tcase \'{\': case \'}\':\n\t\t\t\tcase \'\\\\\': case \'^\': case \'$\':\n\t\t\t\tcase \'.\': case \'|\': case \'?\': case \'+\':\n\t\t\t\t\tregexStr += \'\\\\\';\n\t\t\t\tdefault:\n\t\t\t\t\tregexStr += pThis->searchQuery[iChar];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tstd::regex_constants::syntax_option_type regexOptions = std::regex_constants::optimize;\n\t\t\tif (pThis->searchCaseSensitive)\n\t\t\t\tregexOptions |= std::regex_constants::icase;\n\t\t\tpThis->searchRegex = std::regex(regexStr, regexOptions);\n\n\t\t\tEndDialog(hDlg, 1);\n\t\t\treturn (INT_PTR)TRUE;\n\t\t}\n\t\tbreak;\n\t\tcase IDCANCEL:\n\t\t\tEndDialog(hDlg, 0);\n\t\t\treturn (INT_PTR)TRUE;\n\t\t}\n\t\tbreak;\n\t}\n\treturn (INT_PTR)FALSE;\n}\nINT_PTR CALLBACK AssetListDialog::AssetListProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)\n{\n\tint wmId, wmEvent;\n\tUNREFERENCED_PARAMETER(lParam);\n\tINT_PTR ret = (INT_PTR)FALSE;\n\tAssetListDialog *pThis = (AssetListDialog*)GetWindowLongPtr(hDlg, GWLP_USERDATA);\n\tswitch (message)\n\t{\n\tcase WM_CLOSE:\n\t\tif (pThis)\n\t\t\tpThis->hDialog = NULL;\n\t\tDestroyWindow(hDlg);\n\t\tret = (INT_PTR)TRUE;\n\t\tbreak;\n\tcase WM_INITDIALOG:\n\t\t{\n\t\t\tSetWindowLongPtr(hDlg, GWLP_USERDATA, lParam);\n\t\t\tpThis = (AssetListDialog*)lParam;\n\t\t\tpThis->hDialog = hDlg;\n\t\t\t//pMainWindow->assetsInfoDialog.hHotkeyHook = SetWindowsHookEx(WH_GETMESSAGE, AssetsInfoKeyboardHookProc, NULL, GetCurrentThreadId());\n\n\t\t\tpThis->selectionUpdateScheduled = false;\n\t\t\tpThis->windowUpdateScheduled = false;\n\t\t\tpThis->entryCachingScheduled = false;\n\t\t\tHWND hAssetListView = GetDlgItem(hDlg, IDC_ASSETLIST);\n\t\t\t//SetWindowSubclass(hAssetListView, ListViewSubclassProc, 0, reinterpret_cast<DWORD_PTR>(pThis));\n\t\t\tShowWindow(hAssetListView, SW_HIDE);\n\n\t\t\tShowWindow(hAssetListView, SW_SHOW);\n\t\t\tListView_SetItemCount(GetDlgItem(hDlg, IDC_ASSETLIST), (int)std::min<size_t>(pThis->listEntries.size(), INT_MAX));\n\n\t\t\tLVCOLUMN column;\n\t\t\tZeroMemory(&column, sizeof(LVCOLUMN));\n\t\t\tcolumn.mask = LVCF_TEXT | LVCF_WIDTH | LVCF_SUBITEM;\n\t\t\tcolumn.cx = 150;\n\t\t\tcolumn.pszText = const_cast<TCHAR*>(TEXT("Name"));\n\t\t\tcolumn.iSubItem = 0;\n\t\t\tListView_InsertColumn(hAssetListView, 0, &column);\n\t\t\tcolumn.cx = 150;\n\t\t\tcolumn.pszText = const_cast<TCHAR*>(TEXT("Container"));\n\t\t\t//column.iSubItem = 1;\n\t\t\tListView_InsertColumn(hAssetListView, 1, &column);\n\t\t\tcolumn.cx = 60;\n\t\t\tcolumn.pszText = const_cast<TCHAR*>(TEXT("Type"));\n\t\t\t//column.iSubItem = 2;\n\t\t\tListView_InsertColumn(hAssetListView, 2, &column);\n\t\t\tcolumn.cx = 50;\n\t\t\tcolumn.pszText = const_cast<TCHAR*>(TEXT("File ID"));\n\t\t\t//column.iSubItem = 3;\n\t\t\tListView_InsertColumn(hAssetListView, 3, &column);\n\t\t\tcolumn.cx = 60;\n\t\t\tcolumn.pszText = const_cast<TCHAR*>(TEXT("Path ID"));\n\t\t\t//column.iSubItem = 4;\n\t\t\tListView_InsertColumn(hAssetListView, 4, &column);\n\t\t\tcolumn.mask |= LVCF_FMT;\n\t\t\tcolumn.cx = 70;\n\t\t\tcolumn.fmt = LVCFMT_RIGHT;\n\t\t\tcolumn.pszText = const_cast<TCHAR*>(TEXT("Size (bytes)"));\n\t\t\t//column.iSubItem = 5;\n\t\t\tListView_InsertColumn(hAssetListView, 5, &column);\n\t\t\tcolumn.fmt = LVCFMT_LEFT;\n\t\t\tcolumn.cx = 60;\n\t\t\tcolumn.pszText = const_cast<TCHAR*>(TEXT("Modified"));\n\t\t\tListView_InsertColumn(hAssetListView, 6, &column);\n\n\t\t\tListView_SetCallbackMask(hAssetListView, LVIS_SELECTED);\n\n\t\t\t{\n\t\t\t\tHWND hTabsControl = GetDlgItem(hDlg, IDC_ASSETLISTMODIFYTABS);\n\t\t\t\tMC_MTITEMWIDTH widths;\n\t\t\t\twidths.dwDefWidth = 0;\n\t\t\t\twidths.dwMinWidth = 90;\n\t\t\t\tSendMessage(hTabsControl, MC_MTM_SETITEMWIDTH, 0, (LPARAM) &widths);\n\t\t\t\t\n\t\t\t\tstd::shared_ptr<AssetModifyDialog> modifyDialogToSelect = pThis->pActiveModifyDialog;\n\n\t\t\t\tMC_MTITEM newItem = {};\n\t\t\t\tnewItem.dwMask = MC_MTIF_TEXT | MC_MTIF_PARAM | MC_MTIF_CLOSEFLAG;\n\t\t\t\tnewItem.pszText = const_cast<TCHAR*>(TEXT("Asset list"));\n\t\t\t\tnewItem.lParam = 0;\n\t\t\t\tnewItem.bDisableClose = TRUE;\n\t\t\t\tSendMessage(hTabsControl, MC_MTM_INSERTITEM, (WPARAM)0, (LPARAM)&newItem);\n\t\t\t\tif (!pThis->modifyDialogs.empty())\n\t\t\t\t{\n\t\t\t\t\tShowWindow(hTabsControl, SW_SHOW);\n\t\t\t\t\tsize_t newTabIdx = 1;\n\n\t\t\t\t\tsize_t tabIdxToSelect = 0;\n\t\t\t\t\tfor (auto dialogIt = pThis->modifyDialogs.begin(); dialogIt != pThis->modifyDialogs.end(); ++dialogIt)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (modifyDialogToSelect != nullptr && dialogIt->get() == modifyDialogToSelect.get())\n\t\t\t\t\t\t\ttabIdxToSelect = newTabIdx;\n\t\t\t\t\t\tstd::string tabName8 = (*dialogIt != nullptr) ? dialogIt->get()->getTabName() : "-";\n\t\t\t\t\t\tauto upTabNameT = unique_MultiByteToTCHAR(tabName8.c_str());\n\n\t\t\t\t\t\tnewItem.dwMask = MC_MTIF_TEXT | MC_MTIF_PARAM;\n\t\t\t\t\t\tnewItem.pszText = upTabNameT.get();\n\t\t\t\t\t\tnewItem.lParam = (LPARAM)dialogIt->get();\n\t\t\t\t\t\tSendMessage(hTabsControl, MC_MTM_INSERTITEM, (WPARAM)newTabIdx, (LPARAM)&newItem);\n\n\t\t\t\t\t\tnewTabIdx++;\n\t\t\t\t\t}\n\n\t\t\t\t\tSendMessage(hTabsControl, MC_MTM_SETCURSEL, (WPARAM)tabIdxToSelect, 0); //Also sends a SELCHANGE notification.\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t\n\t\t\tif (pThis->iLastTopItem >= 0 && pThis->iLastTopItem < pThis->listEntries.size())\n\t\t\t{\n\t\t\t\tListView_EnsureVisible(hAssetListView, pThis->iLastTopItem, FALSE);\n\t\t\t}\n\n\t\t\t//Tooltip style for item text; Double buffering to prevent flickering while scrolling, resizing, etc.\n\t\t\tListView_SetExtendedListViewStyle(hAssetListView, LVS_EX_INFOTIP | LVS_EX_LABELTIP | LVS_EX_DOUBLEBUFFER | LVS_EX_ONECLICKACTIVATE | LVS_EX_UNDERLINEHOT);\n\t\t\t\n\t\t\tpThis->iFocusedItem = -1;\n\n\t\t\tif (pThis->listEntries.size() > 0)\n\t\t\t{\n\t\t\t\tpThis->entryCachingScheduled = true;\n\t\t\t\tSetTimer(hDlg, (uintptr_t)1, 16, NULL);\n\t\t\t}\n\n\t\t\t//Will not fail (on Win >= XP) according to MS docs.\n\t\t\tQueryPerformanceFrequency(&pThis->qpfrequency);\n\t\t\tpThis->ticksUntilCacheFreqUpdate = 1;\n\n\t\t\tShowWindow(hDlg, SW_SHOW);\n\t\t\tPostMessage(hDlg, WM_SIZE, 0, 0);\n\t\t\tret = (INT_PTR)TRUE;\n\t\t}\n\t\tbreak;\n\tcase WM_TIMER:\n\t\t{\n\t\t\tif (wParam == (uintptr_t)0 && pThis && pThis->windowUpdateScheduled)\n\t\t\t{\n\t\t\t\tpThis->windowUpdateScheduled = false;\n\t\t\t\tKillTimer(hDlg, wParam);\n\t\t\t\tUpdateWindow(GetDlgItem(hDlg, IDC_ASSETLIST));\n\t\t\t}\n\t\t\tif (wParam == (uintptr_t)1 && pThis)\n\t\t\t{\n\t\t\t\tpThis->onCacheUpdateTick();\n\t\t\t}\n\t\t\tif (wParam == (uintptr_t)2 && pThis->selectionUpdateScheduled)\n\t\t\t{\n\t\t\t\tpThis->selectionUpdateScheduled = false;\n\t\t\t\tKillTimer(hDlg, wParam);\n\t\t\t\tpThis->applyDeferredChanges();\n\t\t\t\tpThis->updateSelectionDesc();\n\t\t\t}\n\t\t}\n\t\tret = 0;\n\t\tbreak;\n\tcase WM_NOTIFY:\n\t\t{\n\t\t\tNMLISTVIEW *pNotifyLV = (NMLISTVIEW*)lParam;\n\t\t\tswitch (pNotifyLV->hdr.code)\n\t\t\t{\n\t\t\t\tcase LVN_ITEMCHANGED:\n\t\t\t\t\t{\n\t\t\t\t\t\tNMLISTVIEW *pInfo = (NMLISTVIEW*)lParam;\n\t\t\t\t\t\tif (pThis)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif ((pInfo->uOldState ^ pInfo->uNewState) & LVIS_SELECTED)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tbool isSelected = (pInfo->uNewState & LVIS_SELECTED) ? true : false;\n\t\t\t\t\t\t\t\tint iItem = pInfo->iItem;\n\t\t\t\t\t\t\t\tif (iItem == -1)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tfor (size_t i = 0; i < pThis->listEntries.size(); i++)\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tpThis->listEntries[i].isSelected = isSelected;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse if (iItem >= 0 && iItem < pThis->listEntries.size())\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tpThis->listEntries[iItem].isSelected = isSelected;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (pInfo->uNewState & LVIS_FOCUSED)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tpThis->iFocusedItem = pInfo->iItem;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tpThis->updateSelectionDesc();\n\t\t\t\t\tbreak;\n\t\t\t\tcase LVN_ODSTATECHANGED:\n\t\t\t\t\t{\n\t\t\t\t\t\tNMLVODSTATECHANGE *pInfo = (NMLVODSTATECHANGE*)lParam;\n\t\t\t\t\t\tif (pThis)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tint from = pInfo->iFrom; \n\t\t\t\t\t\t\tif (from < 0)\n\t\t\t\t\t\t\t\tfrom = 0;\n\t\t\t\t\t\t\tint to = pInfo->iTo; \n\t\t\t\t\t\t\tif (to < 0 || to >= pThis->listEntries.size()) \n\t\t\t\t\t\t\t\tto = (pThis->listEntries.size() > INT_MAX) ? INT_MAX : (int)(pThis->listEntries.size() - 1);\n\n\t\t\t\t\t\t\tif ((pInfo->uOldState ^ pInfo->uNewState) & LVIS_SELECTED)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tbool isSelected = (pInfo->uNewState & LVIS_SELECTED) ? true : false;\n\t\t\t\t\t\t\t\tfor (int i = from; i <= to; i++)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tpThis->listEntries[i].isSelected = isSelected;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (pInfo->uNewState & LVIS_FOCUSED)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tpThis->iFocusedItem = pInfo->iFrom;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tpThis->updateSelectionDesc();\n\t\t\t\t\tbreak;\n\t\t\t\tcase LVN_GETINFOTIP:\n\t\t\t\t\t{\n\t\t\t\t\t\tNMLVGETINFOTIP *pInfo = (NMLVGETINFOTIP*)lParam;\n\t\t\t\t\t\tint iItem = pInfo->iItem;\n\t\t\t\t\t\tif (pThis && iItem >= 0 && iItem < pThis->listEntries.size())\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tAssetInfo *pEntry = nullptr;\n\t\t\t\t\t\t\tpThis->cacheEntry(iItem, pEntry);\n\t\t\t\t\t\t\tif (pEntry)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tassert(pThis->lvStringBuf_Tooltip.size() >= 2);\n\t\t\t\t\t\t\t\t//Shift the string buffer list (removing the oldest if needed).\n\t\t\t\t\t\t\t\tfor (size_t i = pThis->lvStringBuf_Tooltip.size() - 1; i > 0; i--)\n\t\t\t\t\t\t\t\t\tpThis->lvStringBuf_Tooltip[i] = std::move(pThis->lvStringBuf_Tooltip[i-1]);\n\t\t\t\t\t\t\t\tpThis->lvStringBuf_Tooltip[0].reset();\n\t\t\t\t\t\t\t\tpInfo->cchTextMax = 0;\n\t\t\t\t\t\t\t\tpInfo->pszText = const_cast<TCHAR*>(TEXT(""));\n\t\t\t\t\t\t\t\t//Retrieve the entry text and store the string buffer.\n\t\t\t\t\t\t\t\tstd::unique_ptr<TCHAR[]> newTextBuf;\n\t\t\t\t\t\t\t\tpThis->getEntryText(iItem, pInfo->iSubItem, *pEntry, newTextBuf);\n\t\t\t\t\t\t\t\tpThis->lvStringBuf_Tooltip[0].swap(newTextBuf);\n\t\t\t\t\t\t\t\tif (pThis->lvStringBuf_Tooltip[0] != nullptr)\n\t\t\t\t\t\t\t\t\tpInfo->pszText = pThis->lvStringBuf_Tooltip[0].get();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase LVN_GETDISPINFO:\n\t\t\t\t\t{\n\t\t\t\t\t\tNMLVDISPINFO *pInfo = (NMLVDISPINFO*)lParam;\n\t\t\t\t\t\tint iItem = pInfo->item.iItem;\n\t\t\t\t\t\tif (pThis && iItem >= 0 && iItem < pThis->listEntries.size())\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tAssetInfo *pEntry = nullptr;\n\t\t\t\t\t\t\tpThis->cacheEntry(iItem, pEntry);\n\t\t\t\t\t\t\tif (pEntry)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tUINT newMask = 0;\n\t\t\t\t\t\t\t\tpInfo->item.lParam = (LPARAM)iItem;\n\t\t\t\t\t\t\t\tnewMask |= LVIF_PARAM;\n\t\t\t\t\t\t\t\tpInfo->item.stateMask = LVIS_SELECTED;\n\t\t\t\t\t\t\t\tif (pInfo->item.iSubItem == 0)\n\t\t\t\t\t\t\t\t\tpInfo->item.state = (pThis->listEntries[iItem].isSelected ? LVIS_SELECTED : 0);\n\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\tpInfo->item.state = 0;\n\t\t\t\t\t\t\t\tnewMask |= LVIF_STATE;\n\t\t\t\t\t\t\t\tif (pInfo->item.mask & LVIF_TEXT)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tnewMask |= LVIF_TEXT;\n\t\t\t\t\t\t\t\t\tassert(pThis->lvStringBuf_Ownerdata.size() >= 2);\n\t\t\t\t\t\t\t\t\t//Shift the string buffer list (removing the oldest if needed).\n\t\t\t\t\t\t\t\t\tfor (size_t i = pThis->lvStringBuf_Ownerdata.size() - 1; i > 0; i--)\n\t\t\t\t\t\t\t\t\t\tpThis->lvStringBuf_Ownerdata[i] = std::move(pThis->lvStringBuf_Ownerdata[i-1]);\n\t\t\t\t\t\t\t\t\tpThis->lvStringBuf_Ownerdata[0].reset();\n\t\t\t\t\t\t\t\t\t//Retrieve the entry text and store the string buffer.\n\t\t\t\t\t\t\t\t\tpInfo->item.cchTextMax = 0;\n\t\t\t\t\t\t\t\t\tpInfo->item.pszText = const_cast<TCHAR*>(TEXT(""));\n\t\t\t\t\t\t\t\t\tstd::unique_ptr<TCHAR[]> newTextBuf = nullptr;\n\t\t\t\t\t\t\t\t\tpThis->getEntryText(iItem, pInfo->item.iSubItem, *pEntry, newTextBuf);\n\t\t\t\t\t\t\t\t\tpThis->lvStringBuf_Ownerdata[0].swap(newTextBuf);\n\t\t\t\t\t\t\t\t\tif (pThis->lvStringBuf_Ownerdata[0] != nullptr)\n\t\t\t\t\t\t\t\t\t\tpInfo->item.pszText = pThis->lvStringBuf_Ownerdata[0].get();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tpInfo->item.mask = newMask;\n\n\t\t\t\t\t\t\t\tbool isSelected = pThis->listEntries[iItem].isSelected;\n\t\t\t\t\t\t\t\tbool isFocused = (iItem == pThis->iFocusedItem);\n\t\t\t\t\t\t\t\t//Workaround in case the ListView\'s selection states are not in sync.\n\t\t\t\t\t\t\t\t//The GetDispInfo selection status is only used for visual purposes and does not touch the item state.\n\t\t\t\t\t\t\t\tListView_SetItemState(pInfo->hdr.hwndFrom, iItem, \n\t\t\t\t\t\t\t\t\t((isSelected) ? LVIS_SELECTED : 0) | ((isFocused) ? LVIS_FOCUSED : 0), //state\n\t\t\t\t\t\t\t\t\tLVIS_SELECTED | ((isFocused) ? LVIS_FOCUSED : 0)); //mask; Only set LVIS_FOCUSED, don\'t reset.\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tret = (INT_PTR)TRUE;\n\t\t\t\t\tbreak;\n\t\t\t\tcase LVN_SETDISPINFO:\n\t\t\t\t\t{\n\t\t\t\t\t\tNMLVDISPINFO *pInfo = (NMLVDISPINFO*)lParam;\n\t\t\t\t\t\tint iItem = pInfo->item.iItem;\n\t\t\t\t\t\tif (pThis && iItem >= 0 && iItem < pThis->listEntries.size())\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (pInfo->item.mask & LVIF_STATE)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif ((pInfo->item.stateMask & LVIS_FOCUSED) && (pInfo->item.state & LVIS_FOCUSED))\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tpThis->iFocusedItem = iItem;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (pInfo->item.stateMask & LVIS_SELECTED)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tbool isSelected = (pInfo->item.state & LVIS_SELECTED) ? true : false;\n\t\t\t\t\t\t\t\t\tif (isSelected != pThis->listEntries[iItem].isSelected)\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tpThis->listEntries[iItem].isSelected = isSelected;\n\t\t\t\t\t\t\t\t\t\tpThis->updateSelectionDesc();\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase LVN_ODCACHEHINT:\n\t\t\t\t\t{\n\t\t\t\t\t\tNMLVCACHEHINT *pInfo = (NMLVCACHEHINT*)lParam;\n\t\t\t\t\t\tif (pThis && pInfo->iFrom >= 0 && pInfo->iTo >= pInfo->iFrom)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tAssetInfo *pEntry = nullptr;\n\t\t\t\t\t\t\tpThis->cachedListEntryCount += pThis->cacheEntries(pInfo->iFrom, pInfo->iTo + 1, pEntry);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tret = (INT_PTR)TRUE;\n\t\t\t\t\tbreak;\n\t\t\t\tcase LVN_ODFINDITEM:\n\t\t\t\t\t{\n\t\t\t\t\t\tLVFINDINFO *pInfo = (LVFINDINFO*)lParam;\n\t\t\t\t\t\t//TODO\n\t\t\t\t\t}\n\t\t\t\t\tSetWindowLongPtr(hDlg, DWLP_MSGRESULT, -1); \n\t\t\t\t\tret = (INT_PTR)TRUE;\n\t\t\t\t\tbreak;\n\t\t\t\tcase LVN_COLUMNCLICK:\n\t\t\t\t\t{\n\t\t\t\t\t\tNMLISTVIEW *pInfo = (NMLISTVIEW*)lParam;\n\t\t\t\t\t\tif (pThis)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tpThis->sortOrderAscending ^= (pThis->sorted && pThis->iSortColumn == pInfo->iSubItem);\n\t\t\t\t\t\t\tpThis->iSortColumn = pInfo->iSubItem;\n\t\t\t\t\t\t\tpThis->sorted = false;\n\t\t\t\t\t\t\tpThis->resort();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase LVN_ITEMACTIVATE:\n\t\t\t\t\t{\n\t\t\t\t\t\tNMITEMACTIVATE *pInfo = (NMITEMACTIVATE*)lParam;\n\t\t\t\t\t\tif (pThis)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif ((pInfo->iItem >= 0 && pInfo->iItem < pThis->listEntries.size() && pThis->listEntries[pInfo->iItem].isSelected)\n\t\t\t\t\t\t\t\t&& !(pInfo->uKeyFlags & (LVKF_CONTROL | LVKF_SHIFT)))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tint topIdx = ListView_GetTopIndex(pInfo->hdr.hwndFrom);\n\t\t\t\t\t\t\t\tint bottomIdx = topIdx + ListView_GetCountPerPage(pInfo->hdr.hwndFrom) + 1;\n\n\t\t\t\t\t\t\t\t//Deselect all. Required when the Win32 dialog is closed and reopened and there are still selected items.\n\t\t\t\t\t\t\t\t//Otherwise, the old selection would stay even when just clicking an item.\n\t\t\t\t\t\t\t\tListView_SetItemState(pInfo->hdr.hwndFrom, -1, 0, LVIS_SELECTED);\n\t\t\t\t\t\t\t\tListView_SetItemState(pInfo->hdr.hwndFrom, pInfo->iItem, LVIS_SELECTED, LVIS_SELECTED);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase MC_MTN_CLOSEITEM:\n\t\t\t\t\tif (((NMHDR*)lParam)->hwndFrom == GetDlgItem(hDlg, IDC_ASSETLISTMODIFYTABS))\n\t\t\t\t\t{\n\t\t\t\t\t\tMC_NMMTCLOSEITEM *pNotification = (MC_NMMTCLOSEITEM*)lParam;\n\t\t\t\t\t\tif (!pThis->preDeleteTab(pNotification))\n\t\t\t\t\t\t\tSetWindowLongPtr(hDlg, DWLP_MSGRESULT, TRUE);\n\t\t\t\t\t\treturn (INT_PTR)TRUE; //Prevent tab deletion.\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase MC_MTN_DELETEITEM:\n\t\t\t\t\tif (((NMHDR*)lParam)->hwndFrom == GetDlgItem(hDlg, IDC_ASSETLISTMODIFYTABS))\n\t\t\t\t\t{\n\t\t\t\t\t\tMC_NMMTDELETEITEM *pNotification = (MC_NMMTDELETEITEM*)lParam;\n\t\t\t\t\t\tpThis->onDeleteTab(pNotification);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase MC_MTN_SELCHANGE:\n\t\t\t\t\tif (((NMHDR*)lParam)->hwndFrom == GetDlgItem(hDlg, IDC_ASSETLISTMODIFYTABS))\n\t\t\t\t\t{\n\t\t\t\t\t\tMC_NMMTSELCHANGE *pNotification = (MC_NMMTSELCHANGE*)lParam;\n\t\t\t\t\t\tpThis->onSwitchTabs(pNotification);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase MC_MTN_DELETEALLITEMS:\n\t\t\t\t\tif (((NMHDR*)lParam)->hwndFrom == GetDlgItem(hDlg, IDC_ASSETLISTMODIFYTABS))\n\t\t\t\t\t{\n\t\t\t\t\t\tSetWindowLongPtr(hDlg, DWLP_MSGRESULT, TRUE);\n\t\t\t\t\t\treturn (INT_PTR)TRUE; //When the dialog closes due to a <onHide> call, keep the internal tabs.\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase WM_COMMAND:\n\t\twmId    = LOWORD(wParam);\n\t\twmEvent = HIWORD(wParam);\n\t\tswitch (wmId)\n\t\t{\n\t\t\tcase IDM_FILE_CLOSE:\n\t\t\t\t//if (AskSaveAssetsInfo(pMainWindow, hDlg))\n\t\t\t\t{\n\t\t\t\t\tif (pThis)\n\t\t\t\t\t\tpThis->pContext->getMainWindow().hideManipulateDialog(pThis);\n\t\t\t\t\telse\n\t\t\t\t\t\tSendMessage(hDlg, WM_CLOSE, 0, 0);\n\t\t\t\t}\n\t\t\t\treturn (INT_PTR)TRUE;\n\t\t\tcase IDM_FILE_APPLY:\n\t\t\t\t//Already handled in onCommand\n\t\t\t\tbreak;\n\t\t\tcase IDM_VIEW_CONTINUESEARCH:\n\t\t\t\tpThis->searchNext();\n\t\t\t\tbreak;\n\t\t\tcase IDM_VIEW_SEARCHBYNAME:\n\t\t\t\t{\n\t\t\t\t\tstd::shared_ptr<IFileManipulateDialog> pSelfRef = pThis->selfPtr.lock();\n\t\t\t\t\tif (!pSelfRef) { assert(false); break; }\n\t\t\t\t\tif (DialogBoxParam(pThis->pContext->getMainWindow().getHInstance(),\n\t\t\t\t\t\tMAKEINTRESOURCE(IDD_SEARCHASSET),\n\t\t\t\t\t\tpThis->hParentWnd ? pThis->hParentWnd : hDlg,\n\t\t\t\t\t\tSearchDlgProc,\n\t\t\t\t\t\t(LPARAM)pThis)\n\t\t\t\t\t\t== 1)\n\t\t\t\t\t{\n\t\t\t\t\t\tpThis->searchNext();\n\t\t\t\t\t\tEnableMenuItem(pThis->pContext->getMainWindow().getMenu(), IDM_VIEW_CONTINUESEARCH, MF_ENABLED);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase IDM_VIEW_GOTOASSET:\n\t\t\t\t{\n\t\t\t\t\tstd::shared_ptr<IFileManipulateDialog> pSelfRef = pThis->selfPtr.lock();\n\t\t\t\t\tif (!pSelfRef) { assert(false); break; }\n\t\t\t\t\tDialogBoxParam(pThis->pContext->getMainWindow().getHInstance(),\n\t\t\t\t\t\tMAKEINTRESOURCE(IDD_GOTOASSET),\n\t\t\t\t\t\tpThis->hParentWnd ? pThis->hParentWnd : hDlg,\n\t\t\t\t\t\tGotoDlgProc,\n\t\t\t\t\t\t(LPARAM)pThis);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase IDM_VIEW_CONTAINERS:\n\t\t\t\t/*if (pMainWindow->assetsInfoDialog.hContainersDlg)\n\t\t\t\t{\n\t\t\t\t\tSetWindowPos(pMainWindow->assetsInfoDialog.hContainersDlg, hDlg, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tpMainWindow->assetsInfoDialog.hContainersDlg = CreateDialogParam(hInst, MAKEINTRESOURCE(IDD_VIEWCONTAINERS), NULL, ViewContainers, NULL);\n\t\t\t\t\tif (pMainWindow->assetsInfoDialog.hContainersDlg)\n\t\t\t\t\t{\n\t\t\t\t\t\t//https://stackoverflow.com/questions/812686/can-a-window-be-always-on-top-of-just-one-other-window\n\t\t\t\t\t\tSetWindowLongPtr(pMainWindow->assetsInfoDialog.hContainersDlg, GWLP_HWNDPARENT, (LONG_PTR)hDlg);\n\t\t\t\t\t\tRECT targetRect = {};\n\t\t\t\t\t\tGetWindowRect(hDlg, &targetRect);\n\t\t\t\t\t\tSetWindowPos(pMainWindow->assetsInfoDialog.hContainersDlg, hDlg, targetRect.left, targetRect.top, 0, 0, SWP_NOSIZE);\n\t\t\t\t\t}\n\t\t\t\t}*/\n\t\t\t\tbreak;\n\t\t\tcase IDC_VIEWDATA:\n\t\t\t\tpThis->openViewDataTab();\n\t\t\t\tbreak;\n\t\t\tcase IDC_DUMPDATA:\n\t\t\t\tpThis->onExportDumpButton();\n\t\t\t\tbreak;\n\t\t\tcase IDC_EXPORTRAW:\n\t\t\t\tpThis->exportAssetsRaw(pThis->getSelectedAssets());\n\t\t\t\tbreak;\n\t\t\tcase IDC_PLUGINS:\n\t\t\t\tpThis->onPluginButton();\n\t\t\t\tbreak;\n\t\t\tcase IDC_IMPORTRAW:\n\t\t\t\tpThis->importAssetsRaw(pThis->getSelectedAssets());\n\t\t\t\tbreak;\n\t\t\tcase IDC_IMPORTDUMP:\n\t\t\t\tpThis->importAssetsDump(pThis->getSelectedAssets());\n\t\t\t\tbreak;\n\t\t\tcase IDC_REMOVEASSET:\n\t\t\t\tpThis->requestRemoveSelectedAssets();\n\t\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase WM_SIZE:\n\t\t{\n\t\t\tHWND hTabsControl = GetDlgItem(hDlg, IDC_ASSETLISTMODIFYTABS);\n\t\t\tHWND hActiveTabWnd = NULL;\n\t\t\tint curTab = (int)SendMessage(hTabsControl, MC_MTM_GETCURSEL, 0, 0);\n\t\t\tif (curTab != -1)\n\t\t\t{\n\t\t\t\tMC_MTITEM item = {};\n\t\t\t\titem.dwMask = MC_MTIF_PARAM;\n\t\t\t\tif (SendMessage(hTabsControl, MC_MTM_GETITEM, (WPARAM)curTab, (LPARAM)&item) == TRUE)\n\t\t\t\t{\n\t\t\t\t\tif (item.lParam != 0)\n\t\t\t\t\t\thActiveTabWnd = reinterpret_cast<AssetModifyDialog*>(item.lParam)->getWindowHandle();\n\t\t\t\t}\n\t\t\t}\n\t\t\tonResize(hDlg, hActiveTabWnd);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn ret;\n}\n\nvoid AssetListDialog::switchToListTab()\n{\n\tHWND hTabsControl = GetDlgItem(this->hDialog, IDC_ASSETLISTMODIFYTABS);\n\tint itemCount = static_cast<int>(SendMessage(hTabsControl, MC_MTM_GETITEMCOUNT, 0, 0));\n\tfor (int i = 0; i < itemCount; i++)\n\t{\n\t\tMC_MTITEM item;\n\t\titem.dwMask = MC_MTIF_PARAM;\n\t\titem.lParam = 0;\n\t\tif (SendMessage(hTabsControl, MC_MTM_GETITEM, static_cast<WPARAM>(i), reinterpret_cast<LPARAM>(&item))\n\t\t\t&& item.lParam == 0)\n\t\t{\n\t\t\tSendMessage(hTabsControl, MC_MTM_SETCURSEL, static_cast<WPARAM>(i), 0);\n\t\t\tHWND hAssetList = GetDlgItem(hDialog, IDC_ASSETLIST);\n\t\t\tSetFocus(hAssetList);\n\t\t\tbreak;\n\t\t}\n\t}\n}\nbool AssetListDialog::openViewDataTab(unsigned int fileID, pathid_t pathID)\n{\n\tauto fileIDEntry = fileEntries.find(fileID);\n\tif (fileIDEntry == fileEntries.end())\n\t{\n\t\t//Try to add the file context to the list dialog.\n\t\tthis->pContext->getMainWindow().selectFileContext(fileID, true);\n\t\t//If a proper dialog type was found for the file context, it should now be added via addFileContext(..).\n\t\tfileIDEntry = fileEntries.find(fileID);\n\t\tif (fileIDEntry == fileEntries.end())\n\t\t\treturn false;\n\t}\n\tfor (size_t i = 0; i < this->listEntries.size(); i++)\n\t{\n\t\tif (this->listEntries[i].fileID == fileID && this->listEntries[i].pathID == pathID)\n\t\t{\n\t\t\tthis->openViewDataTab(i);\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\nbool AssetListDialog::selectAsset(unsigned int fileID, pathid_t pathID)\n{\n\tHWND hAssetList = GetDlgItem(hDialog, IDC_ASSETLIST);\n\tauto fileIDEntry = fileEntries.find(fileID);\n\tif (fileIDEntry == fileEntries.end())\n\t{\n\t\t//Try to add the file context to the list dialog.\n\t\tthis->pContext->getMainWindow().selectFileContext(fileID, true);\n\t\t//If a proper dialog type was found for the file context, it should now be added via addFileContext(..).\n\t\tfileIDEntry = fileEntries.find(fileID);\n\t\tif (fileIDEntry == fileEntries.end())\n\t\t\treturn false;\n\t}\n\tsize_t targetIndex = SIZE_MAX;\n\tfor (size_t i = 0; i < this->listEntries.size() && i < INT_MAX; i++)\n\t{\n\t\tif (this->listEntries[i].fileID == fileID && this->listEntries[i].pathID == pathID)\n\t\t{\n\t\t\ttargetIndex = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (targetIndex == SIZE_MAX)\n\t\treturn false;\n\t\n\tListView_SetItemState(hAssetList, -1, 0, LVIS_FOCUSED | LVIS_SELECTED);\n\tListView_SetItemState(hAssetList, static_cast<int>(targetIndex), LVIS_FOCUSED | LVIS_SELECTED, LVIS_FOCUSED | LVIS_SELECTED);\n\tListView_EnsureVisible(hAssetList, static_cast<int>(targetIndex), FALSE);\n\treturn true;\n}\n\nvoid AssetListDialog::addModifyDialog(std::shared_ptr<AssetModifyDialog> dialogTmp)\n{\n\tHWND hTabsControl = GetDlgItem(this->hDialog, IDC_ASSETLISTMODIFYTABS);\n\tAssetModifyDialog *pDialog = dialogTmp.get();\n\n\tsize_t newTabIdx = this->modifyDialogs.size() + 1;\n\tpDialog->selfHandle = this->modifyDialogs.insert(this->modifyDialogs.end(), std::move(dialogTmp));\n\t\n\tstd::string tabName8 = pDialog->getTabName();\n\tauto upTabNameT = unique_MultiByteToTCHAR(tabName8.c_str());\n\tMC_MTITEM newItem = {};\n\tnewItem.dwMask = MC_MTIF_TEXT | MC_MTIF_PARAM;\n\tnewItem.pszText = upTabNameT.get();\n\tnewItem.lParam = (LPARAM)pDialog;\n\tSendMessage(hTabsControl, MC_MTM_INSERTITEM, (WPARAM)newTabIdx, (LPARAM)&newItem);\n\tSendMessage(hTabsControl, MC_MTM_SETCURSEL, (WPARAM)newTabIdx, 0); //Also sends a SELCHANGE notification.\n}\nvoid AssetListDialog::removeModifyDialog(AssetModifyDialog *pModifyDialog)\n{\n\tHWND hTabsControl = (this->hDialog == NULL) ? NULL : GetDlgItem(this->hDialog, IDC_ASSETLISTMODIFYTABS);\n\tif (this->hDialog == NULL || hTabsControl == NULL)\n\t{\n\t\tpModifyDialog->onDestroy();\n\t\tauto dialogSelfHandle = pModifyDialog->selfHandle;\n\t\tpModifyDialog->selfHandle = this->modifyDialogs.end();\n\t\tthis->modifyDialogs.erase(dialogSelfHandle);\n\t\treturn;\n\t}\n\t//Find the tab index in the control, since the user may have changed it by dragging.\n\tint nTabs = (int)SendMessage(hTabsControl, MC_MTM_GETITEMCOUNT, 0, 0);\n\tMC_MTITEM item = {};\n\tfor (int i = 0; i < nTabs; i++)\n\t{\n\t\titem.dwMask = MC_MTIF_PARAM;\n\t\tif (SendMessage(hTabsControl, MC_MTM_GETITEM, (WPARAM)i, (LPARAM)&item) == TRUE)\n\t\t{\n\t\t\tif (item.lParam == (LPARAM)pModifyDialog)\n\t\t\t{\n\t\t\t\tSendMessage(hTabsControl, MC_MTM_DELETEITEM, (WPARAM)i, 0);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\nstd::shared_ptr<AssetModifyDialog> AssetListDialog::getModifyDialogRef(AssetModifyDialog *pDialog)\n{\n\tif (pDialog->selfHandle == this->modifyDialogs.end())\n\t\treturn std::shared_ptr<AssetModifyDialog>();\n\treturn *pDialog->selfHandle;\n}\n\nbool AssetListDialog::preDeleteTab(MC_NMMTCLOSEITEM *pNotification)\n{\n\tif (pNotification->lParam == 0) //Asset list tab\n\t\treturn false;\n\tAssetModifyDialog *pModifyDialog = reinterpret_cast<AssetModifyDialog*>(pNotification->lParam);\n\tbool changesApplyable = false;\n\tif (pModifyDialog->hasUnappliedChanges(&changesApplyable))\n\t{\n\t\tSendMessage(pNotification->hdr.hwndFrom, MC_MTM_SETCURSEL, (WPARAM)pNotification->iItem, 0);\n\t\tif (changesApplyable)\n\t\t{\n\t\t\tswitch (MessageBox(this->hDialog, \n\t\t\t\tTEXT("This tab has unsaved changes.\\nDo you want to apply the changes before closing the tab?"), \n\t\t\t\tTEXT("Asset Bundle Extractor"), \n\t\t\t\tMB_YESNOCANCEL | MB_ICONWARNING | MB_DEFBUTTON3))\n\t\t\t{\n\t\t\tcase IDYES:\n\t\t\t\tif (pModifyDialog->applyChanges())\n\t\t\t\t\treturn true; //Close tab (changes applied).\n\t\t\t\treturn false; //Don\'t close tab (changes not applied).\n\t\t\tcase IDNO:\n\t\t\t\treturn true; //Close tab without saving.\n\t\t\tcase IDCANCEL:\n\t\t\t\treturn false; //Don\'t close tab.\n\t\t\t}\n\t\t}\n\t\telse if (IDYES == MessageBox(this->hDialog, \n\t\t\tTEXT("This tab has unsaved changes.\\nDo you want to close the tab anyway and discard any unsaved changes?"), \n\t\t\tTEXT("Asset Bundle Extractor"), \n\t\t\tMB_YESNO | MB_ICONWARNING | MB_DEFBUTTON2))\n\t\t{\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\treturn true;\n}\nvoid AssetListDialog::onDeleteTab(MC_NMMTDELETEITEM *pNotification)\n{\n\tif (pNotification->lParam != 0)\n\t{\n\t\tAssetModifyDialog *pModifyDialog = reinterpret_cast<AssetModifyDialog*>(pNotification->lParam);\n\t\tpModifyDialog->onHide();\n\t\tpModifyDialog->onDestroy();\n\t\tif (pModifyDialog == pActiveModifyDialog.get())\n\t\t\tpActiveModifyDialog.reset();\n\n\t\tauto dialogSelfHandle = pModifyDialog->selfHandle;\n\t\tpModifyDialog->selfHandle = this->modifyDialogs.end();\n\t\tthis->modifyDialogs.erase(dialogSelfHandle);\n\n\t\tif (this->modifyDialogs.empty())\n\t\t{\n\t\t\t//Hide the tab control.\n\t\t\tPostMessage(this->hDialog, WM_SIZE, 0, 0);\n\t\t}\n\t}\n}\nvoid AssetListDialog::onSwitchTabs(MC_NMMTSELCHANGE *pNotification)\n{\n\tHWND newDialogHandle = NULL;\n\tbool runResize = false;\n\tif (pNotification->lParamNew != pNotification->lParamOld)\n\t{\n\t\trunResize = true;\n\t\tif (pNotification->lParamOld != 0)\n\t\t{\n\t\t\tAssetModifyDialog *pOldModifyDialog = reinterpret_cast<AssetModifyDialog*>(pNotification->lParamOld);\n\t\t\tHWND oldDialogHandle = pOldModifyDialog->getWindowHandle();\n\t\t\tif (oldDialogHandle != NULL)\n\t\t\t\tShowWindow(oldDialogHandle, SW_HIDE);\n\t\t\tpOldModifyDialog->onHide();\n\t\t}\n\t\tif (pNotification->lParamNew != 0)\n\t\t{\n\t\t\tAssetModifyDialog *pNewModifyDialog = reinterpret_cast<AssetModifyDialog*>(pNotification->lParamNew);\n\t\t\tfor (auto tabListIt = modifyDialogs.begin(); tabListIt != modifyDialogs.end(); ++tabListIt)\n\t\t\t{\n\t\t\t\tif (tabListIt->get() == pNewModifyDialog)\n\t\t\t\t\tpActiveModifyDialog = *tabListIt;\n\t\t\t}\n\t\t\tpNewModifyDialog->onShow(this->hDialog);\n\t\t\tnewDialogHandle = pNewModifyDialog->getWindowHandle();\n\t\t\tif (newDialogHandle != NULL)\n\t\t\t\tShowWindow(newDialogHandle, SW_SHOW);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpActiveModifyDialog = nullptr;\n\t\t\tupdateSelectionDesc();\n\t\t}\n\t}\n\tif (runResize)\n\t\tonResize(this->hDialog, newDialogHandle);\n}\n\nvoid AssetListDialog::onExportDumpButton()\n{\n\tif (this->hCurPopupMenu != NULL)\n\t{\n\t\tDestroyMenu(this->hCurPopupMenu);\n\t\tthis->hCurPopupMenu = NULL;\n\t}\n\tstd::vector<AssetUtilDesc> selection = getSelectedAssets();\n\tif (selection.empty())\n\t\treturn;\n\n\tUINT popupMenuFlags = TPM_RETURNCMD | TPM_NONOTIFY;\n\tif (GetSystemMetrics(SM_MENUDROPALIGNMENT) != 0)\n\t\tpopupMenuFlags |= TPM_RIGHTALIGN | TPM_HORNEGANIMATION;\n\telse\n\t\tpopupMenuFlags |= TPM_HORPOSANIMATION;\n\n\tthis->hCurPopupMenu = CreatePopupMenu();\n\tif (this->hCurPopupMenu == NULL)\n\t\treturn;\n\tAppendMenu(this->hCurPopupMenu, MF_STRING, 9000, TEXT("Dump as text file"));\n\tAppendMenu(this->hCurPopupMenu, MF_STRING, 9001, TEXT("Dump as json file"));\n\tPOINT popupPos = {};\n\tRECT btnRect = {};\n\tif (GetWindowRect(GetDlgItem(this->hDialog, IDC_DUMPDATA), &btnRect))\n\t{\n\t\tpopupPos.x = btnRect.left;\n\t\tpopupPos.y = btnRect.bottom;\n\t}\n\telse\n\t\tGetCursorPos(&popupPos);\n\tuintptr_t selectedId = static_cast<uintptr_t>(TrackPopupMenuEx(this->hCurPopupMenu, popupMenuFlags, popupPos.x, popupPos.y, this->hDialog, NULL));\n\tswitch (selectedId)\n\t{\n\tcase 9000:\n\t\tthis->exportAssetsTextDump(std::move(selection));\n\t\tbreak;\n\tcase 9001:\n\t\tthis->exportAssetsJSONDump(std::move(selection));\n\t\tbreak;\n\t}\n}\nvoid AssetListDialog::onPluginButton()\n{\n\tif (this->hCurPopupMenu != NULL)\n\t{\n\t\tDestroyMenu(this->hCurPopupMenu);\n\t\tthis->hCurPopupMenu = NULL;\n\t}\n\n\tstd::vector<AssetUtilDesc> selection = getSelectedAssets();\n\tif (selection.empty())\n\t\treturn;\n\n\tconst PluginMapping& plugins = this->pContext->getPlugins();\n\tauto citer = plugins.options.cbegin();\n\tstd::shared_ptr<IOptionProvider> pCurProvider;\n\tstd::vector<std::pair<std::string, std::unique_ptr<IOptionRunner>>> viableOptions;\n\twhile (citer = plugins.getNextOptionProvider(citer, pCurProvider), pCurProvider != nullptr)\n\t{\n\t\tstd::string optionName;\n\t\tstd::unique_ptr<IOptionRunner> pRunner;\n\t\tif (auto* pAssetListProvider = dynamic_cast<IAssetListTabOptionProvider*>(pCurProvider.get()))\n\t\t{\n\t\t\tpRunner = pAssetListProvider->prepareForSelection(*this->pContext, *this, selection, optionName);\n\t\t}\n\t\telse if (auto* pAssetGenericProvider = dynamic_cast<IAssetOptionProviderGeneric*>(pCurProvider.get()))\n\t\t{\n\t\t\tpRunner = pAssetGenericProvider->prepareForSelection(*this->pContext, selection, optionName);\n\t\t}\n\t\tif (pRunner != nullptr)\n\t\t{\n\t\t\tviableOptions.push_back({ std::move(optionName), std::move(pRunner) });\n\t\t}\n\t}\n\n\tUINT popupMenuFlags = TPM_RETURNCMD | TPM_NONOTIFY;\n\tif (GetSystemMetrics(SM_MENUDROPALIGNMENT) != 0)\n\t\tpopupMenuFlags |= TPM_RIGHTALIGN | TPM_HORNEGANIMATION;\n\telse\n\t\tpopupMenuFlags |= TPM_HORPOSANIMATION;\n\n\tPOINT popupPos = {};\n\tRECT btnRect = {};\n\tif (GetWindowRect(GetDlgItem(this->hDialog, IDC_PLUGINS), &btnRect))\n\t{\n\t\tpopupPos.x = btnRect.left;\n\t\tpopupPos.y = btnRect.bottom;\n\t}\n\telse\n\t\tGetCursorPos(&popupPos);\n\n\tif (viableOptions.empty())\n\t{\n\t\tthis->hCurPopupMenu = CreatePopupMenu();\n\t\tif (this->hCurPopupMenu != NULL)\n\t\t{\n\t\t\tAppendMenu(this->hCurPopupMenu, MF_STRING | MF_GRAYED, 102, TEXT("(no options found)"));\n\t\t\tTrackPopupMenuEx(this->hCurPopupMenu, popupMenuFlags, popupPos.x, popupPos.y, this->hDialog, NULL);\n\t\t\tDestroyMenu(this->hCurPopupMenu);\n\t\t\tthis->hCurPopupMenu = NULL;\n\t\t}\n\t\treturn;\n\t}\n\n\tsize_t sel = ShowContextMenu(viableOptions.size(), [&viableOptions](size_t i) {return viableOptions[i].first.c_str(); },\n\t\tpopupMenuFlags, popupPos.x, popupPos.y, this->hDialog,\n\t\tthis->hCurPopupMenu);\n\tif (sel != (size_t)-1)\n\t\t(*viableOptions[sel].second)(); //Let the plugin perform the action.\n}\n\nvoid AssetListDialog::openViewDataTab(size_t selection)\n{\n\tif (selection == SIZE_MAX)\n\t{\n\t\tfor (size_t i = 0; i < this->listEntries.size(); i++)\n\t\t{\n\t\t\tif (this->listEntries[i].isSelected)\n\t\t\t{\n\t\t\t\tselection = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (selection == SIZE_MAX)\n\t\t\treturn;\n\t}\n\tAssetIdentifier identifier(this->listEntries[selection].fileID, this->listEntries[selection].pathID);\n\tif (!identifier.resolve(*pContext))\n\t{\n\t\tMessageBox(this->hDialog, TEXT("Unable to find the selected asset!"), TEXT("Asset Bundle Extractor"), MB_ICONERROR);\n\t\treturn;\n\t}\n\tAssetInfo *pFirstEntry = nullptr;\n\tthis->cacheEntry(selection, pFirstEntry);\n\tstd::shared_ptr<AssetViewModifyDialog> pSubDialog = \n\t\tstd::make_shared<AssetViewModifyDialog>(*this, *pContext, std::move(identifier), pFirstEntry ? pFirstEntry->name : std::string());\n\tif (pSubDialog->init(pSubDialog, this->hDialog))\n\t\taddModifyDialog(pSubDialog);\n}\n\nAssetUtilDesc AssetListDialog::makeExportDescForSelection(size_t selection) {\n\tAssetUtilDesc ret;\n\tunsigned int fileID = this->listEntries[selection].fileID;\n\tpathid_t pathID = this->listEntries[selection].pathID;\n\n\tauto fileIt = fileEntries.find(fileID);\n\tif (fileIt != fileEntries.end())\n\t{\n\t\tFileEntryCache& cache = *fileIt->second.get();\n\t\tFileContextInfo_ptr pContextInfo = cache.pUIInfo->getContextInfo();\n\t\tif (pContextInfo->getFileContext() && pContextInfo->getFileContext()->getType() == FileContext_Assets)\n\t\t{\n\t\t\tret.assetsFileName = pContextInfo->getFileName();\n\t\t\tAssetInfo* pEntry = nullptr;\n\t\t\tcacheEntry(selection, pEntry);\n\t\t\tif (pEntry != nullptr)\n\t\t\t\tret.assetName = pEntry->name;\n\t\t\tret.asset = AssetIdentifier(std::reinterpret_pointer_cast<AssetsFileContextInfo>(pContextInfo), pathID);\n\t\t\tif (!ret.asset.resolve(*this->pContext))\n\t\t\t\tret.asset = AssetIdentifier();\n\t\t}\n\t}\n\treturn ret;\n}\n\nAssetListDialog::ListEntrySelectionIterator::ListEntrySelectionIterator(AssetListDialog& dialog)\n\t: dialog(dialog), selection(SIZE_MAX), nextSelection(SIZE_MAX)\n{\n\tfor (size_t i = 0; i < dialog.listEntries.size() && nextSelection == SIZE_MAX; i++)\n\t{\n\t\tif (dialog.listEntries[i].isSelected)\n\t\t{\n\t\t\tif (selection == SIZE_MAX)\n\t\t\t\tselection = i;\n\t\t\telse\n\t\t\t\tnextSelection = i;\n\t\t}\n\t}\n}\nAssetListDialog::ListEntrySelectionIterator& AssetListDialog::ListEntrySelectionIterator::operator++()\n{\n\tselection = nextSelection;\n\tnextSelection = SIZE_MAX;\n\tif (selection != SIZE_MAX)\n\t{\n\t\tfor (size_t i = selection + 1; i < dialog.listEntries.size() && nextSelection == SIZE_MAX; i++)\n\t\t{\n\t\t\tif (dialog.listEntries[i].isSelected)\n\t\t\t{\n\t\t\t\tnextSelection = i;\n\t\t\t}\n\t\t}\n\t}\n\treturn *this;\n}\n\n\nstd::vector<AssetUtilDesc> AssetListDialog::getSelectedAssets()\n{\n\tListEntrySelectionIterator selectionIter(*this);\n\tstd::vector<AssetUtilDesc> selectedAssets;\n\twhile (!selectionIter.isEnd())\n\t{\n\t\tselectedAssets.push_back(makeExportDescForSelection(*selectionIter));\n\t\t++selectionIter;\n\t}\n\treturn selectedAssets;\n}\n\ntemplate <class TaskGenerator>\nrequires std::invocable<const TaskGenerator&, std::vector<AssetUtilDesc>, std::vector<std::string>>\n\t&& std::convertible_to<std::invoke_result_t<const TaskGenerator&, std::vector<AssetUtilDesc>, std::vector<std::string>>,\n\t\tstd::shared_ptr<AssetImportTask>>\nvoid AssetListDialog::importAssetsBy(std::vector<AssetUtilDesc> assets,\n\tconst TaskGenerator& taskGenerator, std::string _extension, std::string _extensionRegex, std::string _extensionFilter)\n{\n\tstd::vector<std::string> _importFilePaths = this->pContext->QueryAssetImportLocation(\n\t\tassets, std::move(_extension), std::move(_extensionRegex), std::move(_extensionFilter));\n\tif (_importFilePaths.size() == assets.size())\n\t{\n\t\tstd::shared_ptr<AssetImportTask> pTask = taskGenerator(std::move(assets), std::move(_importFilePaths));\n\t\tthis->pContext->taskManager.enqueue(pTask);\n\t}\n}\n\ntemplate <class TaskGenerator>\nrequires std::invocable<const TaskGenerator&, std::vector<AssetUtilDesc>, std::string>\n&& std::convertible_to<std::invoke_result_t<const TaskGenerator&, std::vector<AssetUtilDesc>, std::string>, std::shared_ptr<AssetExportTask>>\nvoid AssetListDialog::exportAssetsBy(std::vector<AssetUtilDesc> assets, \n\tconst TaskGenerator& taskGenerator, std::string _extension, std::string _extensionFilter)\n{\n\tstd::string exportPath = this->pContext->QueryAssetExportLocation(assets, std::move(_extension), std::move(_extensionFilter));\n\tif (exportPath.empty())\n\t\treturn;\n\tstd::shared_ptr<AssetExportTask> pTask = taskGenerator(std::move(assets), std::move(exportPath));\n\tthis->pContext->taskManager.enqueue(pTask);\n}\n\nvoid AssetListDialog::exportAssetsTextDump(std::vector<AssetUtilDesc> assets, bool stopOnError)\n{\n\treturn exportAssetsBy<AssetExportTextDumpTask>(std::move(assets), *this->pContext, ".txt", "*.txt|Text files:", "Export text dump", stopOnError);\n}\nvoid AssetListDialog::exportAssetsJSONDump(std::vector<AssetUtilDesc> assets, bool stopOnError)\n{\n\treturn exportAssetsBy<AssetExportJSONDumpTask>(std::move(assets), *this->pContext, ".json", "*.json|JSON text files:", "Export JSON dump", stopOnError);\n}\n\nvoid AssetListDialog::importAssetsRaw(std::vector<AssetUtilDesc> assets, bool stopOnError)\n{\n\treturn importAssetsBy<AssetImportRawTask>(std::move(assets), *this->pContext, ".dat", "(?:\\\\.dat)?", "*.*|Raw Unity asset:",\n\t\t"Import raw assets", stopOnError);\n}\nvoid AssetListDialog::importAssetsDump(std::vector<AssetUtilDesc> assets, bool stopOnError)\n{\n\treturn importAssetsBy<AssetImportDumpTask>(std::move(assets), *this->pContext, ".json", "\\\\.(?:json|txt)", "*.txt|UABE text dump:*.json|UABE json dump:",\n\t\t"Import asset dumps", stopOnError);\n}\n'