b'{-# LANGUAGE CPP #-}\n{-# LANGUAGE BangPatterns #-}\n{-# LANGUAGE PatternGuards #-}\n#if !defined(TESTING) && defined(__GLASGOW_HASKELL__)\n{-# LANGUAGE Trustworthy #-}\n#endif\n#ifdef __GLASGOW_HASKELL__\n{-# LANGUAGE DeriveLift #-}\n{-# LANGUAGE RoleAnnotations #-}\n{-# LANGUAGE StandaloneDeriving #-}\n{-# LANGUAGE TypeFamilies #-}\n#endif\n\n{-# OPTIONS_HADDOCK not-home #-}\n\n#include "containers.h"\n\n-----------------------------------------------------------------------------\n-- |\n-- Module      :  Data.Set.Internal\n-- Copyright   :  (c) Daan Leijen 2002\n-- License     :  BSD-style\n-- Maintainer  :  libraries@haskell.org\n-- Portability :  portable\n--\n-- = WARNING\n--\n-- This module is considered __internal__.\n--\n-- The Package Versioning Policy __does not apply__.\n--\n-- The contents of this module may change __in any way whatsoever__\n-- and __without any warning__ between minor versions of this package.\n--\n-- Authors importing this module are expected to track development\n-- closely.\n--\n-- = Description\n--\n-- An efficient implementation of sets.\n--\n-- These modules are intended to be imported qualified, to avoid name\n-- clashes with Prelude functions, e.g.\n--\n-- >  import Data.Set (Set)\n-- >  import qualified Data.Set as Set\n--\n-- The implementation of \'Set\' is based on /size balanced/ binary trees (or\n-- trees of /bounded balance/) as described by:\n--\n--    * Stephen Adams, \\"/Efficient sets: a balancing act/\\",\n--      Journal of Functional Programming 3(4):553-562, October 1993,\n--      <http://www.swiss.ai.mit.edu/~adams/BB/>.\n--    * J. Nievergelt and E.M. Reingold,\n--      \\"/Binary search trees of bounded balance/\\",\n--      SIAM journal of computing 2(1), March 1973.\n--\n--  Bounds for \'union\', \'intersection\', and \'difference\' are as given\n--  by\n--\n--    * Guy Blelloch, Daniel Ferizovic, and Yihan Sun,\n--      \\"/Just Join for Parallel Ordered Sets/\\",\n--      <https://arxiv.org/abs/1602.02120v3>.\n--\n-- Note that the implementation is /left-biased/ -- the elements of a\n-- first argument are always preferred to the second, for example in\n-- \'union\' or \'insert\'.  Of course, left-biasing can only be observed\n-- when equality is an equivalence relation instead of structural\n-- equality.\n--\n-- /Warning/: The size of the set must not exceed @maxBound::Int@. Violation of\n-- this condition is not detected and if the size limit is exceeded, the\n-- behavior of the set is completely undefined.\n--\n-- @since 0.5.9\n-----------------------------------------------------------------------------\n\n-- [Note: Using INLINABLE]\n-- ~~~~~~~~~~~~~~~~~~~~~~~\n-- It is crucial to the performance that the functions specialize on the Ord\n-- type when possible. GHC 7.0 and higher does this by itself when it sees th\n-- unfolding of a function -- that is why all public functions are marked\n-- INLINABLE (that exposes the unfolding).\n\n\n-- [Note: Using INLINE]\n-- ~~~~~~~~~~~~~~~~~~~~\n-- For other compilers and GHC pre 7.0, we mark some of the functions INLINE.\n-- We mark the functions that just navigate down the tree (lookup, insert,\n-- delete and similar). That navigation code gets inlined and thus specialized\n-- when possible. There is a price to pay -- code growth. The code INLINED is\n-- therefore only the tree navigation, all the real work (rebalancing) is not\n-- INLINED by using a NOINLINE.\n--\n-- All methods marked INLINE have to be nonrecursive -- a \'go\' function doing\n-- the real work is provided.\n\n\n-- [Note: Type of local \'go\' function]\n-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n-- If the local \'go\' function uses an Ord class, it sometimes heap-allocates\n-- the Ord dictionary when the \'go\' function does not have explicit type.\n-- In that case we give \'go\' explicit type. But this slightly decrease\n-- performance, as the resulting \'go\' function can float out to top level.\n\n\n-- [Note: Local \'go\' functions and capturing]\n-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n-- As opposed to IntSet, when \'go\' function captures an argument, increased\n-- heap-allocation can occur: sometimes in a polymorphic function, the \'go\'\n-- floats out of its enclosing function and then it heap-allocates the\n-- dictionary and the argument. Maybe it floats out too late and strictness\n-- analyzer cannot see that these could be passed on stack.\n\n-- [Note: Order of constructors]\n-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n-- The order of constructors of Set matters when considering performance.\n-- Currently in GHC 7.0, when type has 2 constructors, a forward conditional\n-- jump is made when successfully matching second constructor. Successful match\n-- of first constructor results in the forward jump not taken.\n-- On GHC 7.0, reordering constructors from Tip | Bin to Bin | Tip\n-- improves the benchmark by up to 10% on x86.\n\nmodule Data.Set.Internal (\n            -- * Set type\n              Set(..)       -- instance Eq,Ord,Show,Read,Data\n            , Size\n\n            -- * Operators\n            , (\\\\)\n\n            -- * Query\n            , null\n            , size\n            , member\n            , notMember\n            , lookupLT\n            , lookupGT\n            , lookupLE\n            , lookupGE\n            , isSubsetOf\n            , isProperSubsetOf\n            , disjoint\n\n            -- * Construction\n            , empty\n            , singleton\n            , insert\n            , delete\n            , alterF\n            , powerSet\n\n            -- * Combine\n            , union\n            , unions\n            , difference\n            , intersection\n            , intersections\n            , cartesianProduct\n            , disjointUnion\n            , Intersection(..)\n\n\n            -- * Filter\n            , filter\n            , takeWhileAntitone\n            , dropWhileAntitone\n            , spanAntitone\n            , partition\n            , split\n            , splitMember\n            , splitRoot\n\n            -- * Indexed\n            , lookupIndex\n            , findIndex\n            , elemAt\n            , deleteAt\n            , take\n            , drop\n            , splitAt\n\n            -- * Map\n            , map\n            , mapMonotonic\n\n            -- * Folds\n            , foldr\n            , foldl\n            -- ** Strict folds\n            , foldr\'\n            , foldl\'\n            -- ** Legacy folds\n            , fold\n\n            -- * Min\\/Max\n            , lookupMin\n            , lookupMax\n            , findMin\n            , findMax\n            , deleteMin\n            , deleteMax\n            , deleteFindMin\n            , deleteFindMax\n            , maxView\n            , minView\n\n            -- * Conversion\n\n            -- ** List\n            , elems\n            , toList\n            , fromList\n\n            -- ** Ordered list\n            , toAscList\n            , toDescList\n            , fromAscList\n            , fromDistinctAscList\n            , fromDescList\n            , fromDistinctDescList\n\n            -- * Debugging\n            , showTree\n            , showTreeWith\n            , valid\n\n            -- Internals (for testing)\n            , bin\n            , balanced\n            , link\n            , merge\n            ) where\n\nimport Utils.Containers.Internal.Prelude hiding\n  (filter,foldl,foldr,null,map,take,drop,splitAt)\nimport Prelude ()\nimport Control.Applicative (Const(..))\nimport qualified Data.List as List\nimport Data.Bits (shiftL, shiftR)\nimport Data.Semigroup (Semigroup(stimes))\nimport Data.List.NonEmpty (NonEmpty(..))\n#if !(MIN_VERSION_base(4,11,0))\nimport Data.Semigroup (Semigroup((<>)))\n#endif\nimport Data.Semigroup (stimesIdempotentMonoid, stimesIdempotent)\nimport Data.Functor.Classes\nimport Data.Functor.Identity (Identity)\nimport qualified Data.Foldable as Foldable\nimport Control.DeepSeq (NFData(rnf))\n\nimport Utils.Containers.Internal.StrictPair\nimport Utils.Containers.Internal.PtrEquality\n\n#if __GLASGOW_HASKELL__\nimport GHC.Exts ( build, lazy )\nimport qualified GHC.Exts as GHCExts\nimport Text.Read ( readPrec, Read (..), Lexeme (..), parens, prec\n                 , lexP, readListPrecDefault )\nimport Data.Data\nimport Language.Haskell.TH.Syntax (Lift)\n-- See Note [ Template Haskell Dependencies ]\nimport Language.Haskell.TH ()\n#endif\n\n\n{--------------------------------------------------------------------\n  Operators\n--------------------------------------------------------------------}\ninfixl 9 \\\\ --\n\n-- | \\(O\\bigl(m \\log\\bigl(\\frac{n+1}{m+1}\\bigr)\\bigr), \\; m \\leq n\\). See \'difference\'.\n(\\\\) :: Ord a => Set a -> Set a -> Set a\nm1 \\\\ m2 = difference m1 m2\n#if __GLASGOW_HASKELL__\n{-# INLINABLE (\\\\) #-}\n#endif\n\n{--------------------------------------------------------------------\n  Sets are size balanced trees\n--------------------------------------------------------------------}\n-- | A set of values @a@.\n\n-- See Note: Order of constructors\ndata Set a    = Bin {-# UNPACK #-} !Size !a !(Set a) !(Set a)\n              | Tip\n\ntype Size     = Int\n\n#ifdef __GLASGOW_HASKELL__\ntype role Set nominal\n#endif\n\n-- | @since 0.6.6\nderiving instance Lift a => Lift (Set a)\n\ninstance Ord a => Monoid (Set a) where\n    mempty  = empty\n    mconcat = unions\n    mappend = (<>)\n\n-- | @since 0.5.7\ninstance Ord a => Semigroup (Set a) where\n    (<>)    = union\n    stimes  = stimesIdempotentMonoid\n\n-- | Folds in order of increasing key.\ninstance Foldable.Foldable Set where\n    fold = go\n      where go Tip = mempty\n            go (Bin 1 k _ _) = k\n            go (Bin _ k l r) = go l `mappend` (k `mappend` go r)\n    {-# INLINABLE fold #-}\n    foldr = foldr\n    {-# INLINE foldr #-}\n    foldl = foldl\n    {-# INLINE foldl #-}\n    foldMap f t = go t\n      where go Tip = mempty\n            go (Bin 1 k _ _) = f k\n            go (Bin _ k l r) = go l `mappend` (f k `mappend` go r)\n    {-# INLINE foldMap #-}\n    foldl\' = foldl\'\n    {-# INLINE foldl\' #-}\n    foldr\' = foldr\'\n    {-# INLINE foldr\' #-}\n    length = size\n    {-# INLINE length #-}\n    null   = null\n    {-# INLINE null #-}\n    toList = toList\n    {-# INLINE toList #-}\n    elem = go\n      where go !_ Tip = False\n            go x (Bin _ y l r) = x == y || go x l || go x r\n    {-# INLINABLE elem #-}\n    minimum = findMin\n    {-# INLINE minimum #-}\n    maximum = findMax\n    {-# INLINE maximum #-}\n    sum = foldl\' (+) 0\n    {-# INLINABLE sum #-}\n    product = foldl\' (*) 1\n    {-# INLINABLE product #-}\n\n#if __GLASGOW_HASKELL__\n\n{--------------------------------------------------------------------\n  A Data instance\n--------------------------------------------------------------------}\n\n-- This instance preserves data abstraction at the cost of inefficiency.\n-- We provide limited reflection services for the sake of data abstraction.\n\ninstance (Data a, Ord a) => Data (Set a) where\n  gfoldl f z set = z fromList `f` (toList set)\n  toConstr _     = fromListConstr\n  gunfold k z c  = case constrIndex c of\n    1 -> k (z fromList)\n    _ -> error "gunfold"\n  dataTypeOf _   = setDataType\n  dataCast1 f    = gcast1 f\n\nfromListConstr :: Constr\nfromListConstr = mkConstr setDataType "fromList" [] Prefix\n\nsetDataType :: DataType\nsetDataType = mkDataType "Data.Set.Internal.Set" [fromListConstr]\n\n#endif\n\n{--------------------------------------------------------------------\n  Query\n--------------------------------------------------------------------}\n-- | \\(O(1)\\). Is this the empty set?\nnull :: Set a -> Bool\nnull Tip      = True\nnull (Bin {}) = False\n{-# INLINE null #-}\n\n-- | \\(O(1)\\). The number of elements in the set.\nsize :: Set a -> Int\nsize Tip = 0\nsize (Bin sz _ _ _) = sz\n{-# INLINE size #-}\n\n-- | \\(O(\\log n)\\). Is the element in the set?\nmember :: Ord a => a -> Set a -> Bool\nmember = go\n  where\n    go !_ Tip = False\n    go x (Bin _ y l r) = case compare x y of\n      LT -> go x l\n      GT -> go x r\n      EQ -> True\n#if __GLASGOW_HASKELL__\n{-# INLINABLE member #-}\n#else\n{-# INLINE member #-}\n#endif\n\n-- | \\(O(\\log n)\\). Is the element not in the set?\nnotMember :: Ord a => a -> Set a -> Bool\nnotMember a t = not $ member a t\n#if __GLASGOW_HASKELL__\n{-# INLINABLE notMember #-}\n#else\n{-# INLINE notMember #-}\n#endif\n\n-- | \\(O(\\log n)\\). Find largest element smaller than the given one.\n--\n-- > lookupLT 3 (fromList [3, 5]) == Nothing\n-- > lookupLT 5 (fromList [3, 5]) == Just 3\nlookupLT :: Ord a => a -> Set a -> Maybe a\nlookupLT = goNothing\n  where\n    goNothing !_ Tip = Nothing\n    goNothing x (Bin _ y l r) | x <= y = goNothing x l\n                              | otherwise = goJust x y r\n\n    goJust !_ best Tip = Just best\n    goJust x best (Bin _ y l r) | x <= y = goJust x best l\n                                | otherwise = goJust x y r\n#if __GLASGOW_HASKELL__\n{-# INLINABLE lookupLT #-}\n#else\n{-# INLINE lookupLT #-}\n#endif\n\n-- | \\(O(\\log n)\\). Find smallest element greater than the given one.\n--\n-- > lookupGT 4 (fromList [3, 5]) == Just 5\n-- > lookupGT 5 (fromList [3, 5]) == Nothing\nlookupGT :: Ord a => a -> Set a -> Maybe a\nlookupGT = goNothing\n  where\n    goNothing !_ Tip = Nothing\n    goNothing x (Bin _ y l r) | x < y = goJust x y l\n                              | otherwise = goNothing x r\n\n    goJust !_ best Tip = Just best\n    goJust x best (Bin _ y l r) | x < y = goJust x y l\n                                | otherwise = goJust x best r\n#if __GLASGOW_HASKELL__\n{-# INLINABLE lookupGT #-}\n#else\n{-# INLINE lookupGT #-}\n#endif\n\n-- | \\(O(\\log n)\\). Find largest element smaller or equal to the given one.\n--\n-- > lookupLE 2 (fromList [3, 5]) == Nothing\n-- > lookupLE 4 (fromList [3, 5]) == Just 3\n-- > lookupLE 5 (fromList [3, 5]) == Just 5\nlookupLE :: Ord a => a -> Set a -> Maybe a\nlookupLE = goNothing\n  where\n    goNothing !_ Tip = Nothing\n    goNothing x (Bin _ y l r) = case compare x y of LT -> goNothing x l\n                                                    EQ -> Just y\n                                                    GT -> goJust x y r\n\n    goJust !_ best Tip = Just best\n    goJust x best (Bin _ y l r) = case compare x y of LT -> goJust x best l\n                                                      EQ -> Just y\n                                                      GT -> goJust x y r\n#if __GLASGOW_HASKELL__\n{-# INLINABLE lookupLE #-}\n#else\n{-# INLINE lookupLE #-}\n#endif\n\n-- | \\(O(\\log n)\\). Find smallest element greater or equal to the given one.\n--\n-- > lookupGE 3 (fromList [3, 5]) == Just 3\n-- > lookupGE 4 (fromList [3, 5]) == Just 5\n-- > lookupGE 6 (fromList [3, 5]) == Nothing\nlookupGE :: Ord a => a -> Set a -> Maybe a\nlookupGE = goNothing\n  where\n    goNothing !_ Tip = Nothing\n    goNothing x (Bin _ y l r) = case compare x y of LT -> goJust x y l\n                                                    EQ -> Just y\n                                                    GT -> goNothing x r\n\n    goJust !_ best Tip = Just best\n    goJust x best (Bin _ y l r) = case compare x y of LT -> goJust x y l\n                                                      EQ -> Just y\n                                                      GT -> goJust x best r\n#if __GLASGOW_HASKELL__\n{-# INLINABLE lookupGE #-}\n#else\n{-# INLINE lookupGE #-}\n#endif\n\n{--------------------------------------------------------------------\n  Construction\n--------------------------------------------------------------------}\n-- | \\(O(1)\\). The empty set.\nempty  :: Set a\nempty = Tip\n{-# INLINE empty #-}\n\n-- | \\(O(1)\\). Create a singleton set.\nsingleton :: a -> Set a\nsingleton x = Bin 1 x Tip Tip\n{-# INLINE singleton #-}\n\n{--------------------------------------------------------------------\n  Insertion, Deletion\n--------------------------------------------------------------------}\n-- | \\(O(\\log n)\\). Insert an element in a set.\n-- If the set already contains an element equal to the given value,\n-- it is replaced with the new value.\n\n-- See Note: Type of local \'go\' function\n-- See Note: Avoiding worker/wrapper (in Data.Map.Internal)\ninsert :: Ord a => a -> Set a -> Set a\ninsert x0 = go x0 x0\n  where\n    go :: Ord a => a -> a -> Set a -> Set a\n    go orig !_ Tip = singleton (lazy orig)\n    go orig !x t@(Bin sz y l r) = case compare x y of\n        LT | l\' `ptrEq` l -> t\n           | otherwise -> balanceL y l\' r\n           where !l\' = go orig x l\n        GT | r\' `ptrEq` r -> t\n           | otherwise -> balanceR y l r\'\n           where !r\' = go orig x r\n        EQ | lazy orig `seq` (orig `ptrEq` y) -> t\n           | otherwise -> Bin sz (lazy orig) l r\n#if __GLASGOW_HASKELL__\n{-# INLINABLE insert #-}\n#else\n{-# INLINE insert #-}\n#endif\n\n#ifndef __GLASGOW_HASKELL__\nlazy :: a -> a\nlazy a = a\n#endif\n\n-- Insert an element to the set only if it is not in the set.\n-- Used by `union`.\n\n-- See Note: Type of local \'go\' function\n-- See Note: Avoiding worker/wrapper (in Data.Map.Internal)\ninsertR :: Ord a => a -> Set a -> Set a\ninsertR x0 = go x0 x0\n  where\n    go :: Ord a => a -> a -> Set a -> Set a\n    go orig !_ Tip = singleton (lazy orig)\n    go orig !x t@(Bin _ y l r) = case compare x y of\n        LT | l\' `ptrEq` l -> t\n           | otherwise -> balanceL y l\' r\n           where !l\' = go orig x l\n        GT | r\' `ptrEq` r -> t\n           | otherwise -> balanceR y l r\'\n           where !r\' = go orig x r\n        EQ -> t\n#if __GLASGOW_HASKELL__\n{-# INLINABLE insertR #-}\n#else\n{-# INLINE insertR #-}\n#endif\n\n-- | \\(O(\\log n)\\). Delete an element from a set.\n\n-- See Note: Type of local \'go\' function\ndelete :: Ord a => a -> Set a -> Set a\ndelete = go\n  where\n    go :: Ord a => a -> Set a -> Set a\n    go !_ Tip = Tip\n    go x t@(Bin _ y l r) = case compare x y of\n        LT | l\' `ptrEq` l -> t\n           | otherwise -> balanceR y l\' r\n           where !l\' = go x l\n        GT | r\' `ptrEq` r -> t\n           | otherwise -> balanceL y l r\'\n           where !r\' = go x r\n        EQ -> glue l r\n#if __GLASGOW_HASKELL__\n{-# INLINABLE delete #-}\n#else\n{-# INLINE delete #-}\n#endif\n\n-- | \\(O(\\log n)\\) @(\'alterF\' f x s)@ can delete or insert @x@ in @s@ depending on\n-- whether an equal element is found in @s@.\n--\n-- In short:\n--\n-- @\n-- \'member\' x \\<$\\> \'alterF\' f x s = f (\'member\' x s)\n-- @\n--\n-- Note that unlike \'insert\', \'alterF\' will /not/ replace an element equal to\n-- the given value.\n--\n-- Note: \'alterF\' is a variant of the @at@ combinator from "Control.Lens.At".\n--\n-- @since 0.6.3.1\nalterF :: (Ord a, Functor f) => (Bool -> f Bool) -> a -> Set a -> f (Set a)\nalterF f k s = fmap choose (f member_)\n  where\n    (member_, inserted, deleted) = case alteredSet k s of\n        Deleted d           -> (True , s, d)\n        Inserted i          -> (False, i, s)\n\n    choose True  = inserted\n    choose False = deleted\n#ifndef __GLASGOW_HASKELL__\n{-# INLINE alterF #-}\n#else\n{-# INLINABLE [2] alterF #-}\n\n{-# RULES\n"alterF/Const" forall k (f :: Bool -> Const a Bool) . alterF f k = \\s -> Const . getConst . f $ member k s\n #-}\n#endif\n\n{-# SPECIALIZE alterF :: Ord a => (Bool -> Identity Bool) -> a -> Set a -> Identity (Set a) #-}\n\ndata AlteredSet a\n      -- | The needle is present in the original set.\n      -- We return the set where the needle is deleted.\n    = Deleted !(Set a)\n\n      -- | The needle is not present in the original set.\n      -- We return the set with the needle inserted.\n    | Inserted !(Set a)\n\nalteredSet :: Ord a => a -> Set a -> AlteredSet a\nalteredSet x0 s0 = go x0 s0\n  where\n    go :: Ord a => a -> Set a -> AlteredSet a\n    go x Tip           = Inserted (singleton x)\n    go x (Bin _ y l r) = case compare x y of\n        LT -> case go x l of\n            Deleted d           -> Deleted (balanceR y d r)\n            Inserted i          -> Inserted (balanceL y i r)\n        GT -> case go x r of\n            Deleted d           -> Deleted (balanceL y l d)\n            Inserted i          -> Inserted (balanceR y l i)\n        EQ -> Deleted (glue l r)\n#if __GLASGOW_HASKELL__\n{-# INLINABLE alteredSet #-}\n#else\n{-# INLINE alteredSet #-}\n#endif\n\n{--------------------------------------------------------------------\n  Subset\n--------------------------------------------------------------------}\n-- | \\(O\\bigl(m \\log\\bigl(\\frac{n+1}{m+1}\\bigr)\\bigr), \\; m \\leq n\\).\n-- @(s1 \\`isProperSubsetOf\\` s2)@ indicates whether @s1@ is a\n-- proper subset of @s2@.\n--\n-- @\n-- s1 \\`isProperSubsetOf\\` s2 = s1 ``isSubsetOf`` s2 && s1 /= s2\n-- @\nisProperSubsetOf :: Ord a => Set a -> Set a -> Bool\nisProperSubsetOf s1 s2\n    = size s1 < size s2 && isSubsetOfX s1 s2\n#if __GLASGOW_HASKELL__\n{-# INLINABLE isProperSubsetOf #-}\n#endif\n\n\n-- | \\(O\\bigl(m \\log\\bigl(\\frac{n+1}{m+1}\\bigr)\\bigr), \\; m \\leq n\\).\n-- @(s1 \\`isSubsetOf\\` s2)@ indicates whether @s1@ is a subset of @s2@.\n--\n-- @\n-- s1 \\`isSubsetOf\\` s2 = all (``member`` s2) s1\n-- s1 \\`isSubsetOf\\` s2 = null (s1 ``difference`` s2)\n-- s1 \\`isSubsetOf\\` s2 = s1 ``union`` s2 == s2\n-- s1 \\`isSubsetOf\\` s2 = s1 ``intersection`` s2 == s1\n-- @\nisSubsetOf :: Ord a => Set a -> Set a -> Bool\nisSubsetOf t1 t2\n  = size t1 <= size t2 && isSubsetOfX t1 t2\n#if __GLASGOW_HASKELL__\n{-# INLINABLE isSubsetOf #-}\n#endif\n\n-- Test whether a set is a subset of another without the *initial*\n-- size test.\n--\n-- This function is structured very much like `difference`, `union`,\n-- and `intersection`. Whereas the bounds proofs for those in Blelloch\n-- et al needed to account for both "split work" and "merge work", we\n-- only have to worry about split work here, which is the same as in\n-- those functions.\nisSubsetOfX :: Ord a => Set a -> Set a -> Bool\nisSubsetOfX Tip _ = True\nisSubsetOfX _ Tip = False\n-- Skip the final split when we hit a singleton.\nisSubsetOfX (Bin 1 x _ _) t = member x t\nisSubsetOfX (Bin _ x l r) t\n  = found &&\n    -- Cheap size checks can sometimes save expensive recursive calls when the\n    -- result will be False. Suppose we check whether [1..10] (with root 4) is\n    -- a subset of [0..9]. After the first split, we have to check if [1..3] is\n    -- a subset of [0..3] and if [5..10] is a subset of [5..9]. But we can bail\n    -- immediately because size [5..10] > size [5..9].\n    --\n    -- Why not just call `isSubsetOf` on each side to do the size checks?\n    -- Because that could make a recursive call on the left even though the\n    -- size check would fail on the right. In principle, we could take this to\n    -- extremes by maintaining a queue of pairs of sets to be checked, working\n    -- through the tree level-wise. But that would impose higher administrative\n    -- costs without obvious benefits. It might be worth considering if we find\n    -- a way to use it to tighten the bounds in some useful/comprehensible way.\n    size l <= size lt && size r <= size gt &&\n    isSubsetOfX l lt && isSubsetOfX r gt\n  where\n    (lt,found,gt) = splitMember x t\n#if __GLASGOW_HASKELL__\n{-# INLINABLE isSubsetOfX #-}\n#endif\n\n{--------------------------------------------------------------------\n  Disjoint\n--------------------------------------------------------------------}\n-- | \\(O\\bigl(m \\log\\bigl(\\frac{n+1}{m+1}\\bigr)\\bigr), \\; m \\leq n\\). Check whether two sets are disjoint\n-- (i.e., their intersection is empty).\n--\n-- > disjoint (fromList [2,4,6])   (fromList [1,3])     == True\n-- > disjoint (fromList [2,4,6,8]) (fromList [2,3,5,7]) == False\n-- > disjoint (fromList [1,2])     (fromList [1,2,3,4]) == False\n-- > disjoint (fromList [])        (fromList [])        == True\n--\n-- @\n-- xs ``disjoint`` ys = null (xs ``intersection`` ys)\n-- @\n--\n-- @since 0.5.11\n\ndisjoint :: Ord a => Set a -> Set a -> Bool\ndisjoint Tip _ = True\ndisjoint _ Tip = True\n-- Avoid a split for the singleton case.\ndisjoint (Bin 1 x _ _) t = x `notMember` t\ndisjoint (Bin _ x l r) t\n  -- Analogous implementation to `subsetOfX`\n  = not found && disjoint l lt && disjoint r gt\n  where\n    (lt,found,gt) = splitMember x t\n\n{--------------------------------------------------------------------\n  Minimal, Maximal\n--------------------------------------------------------------------}\n\n-- We perform call-pattern specialization manually on lookupMin\n-- and lookupMax. Otherwise, GHC doesn\'t seem to do it, which is\n-- unfortunate if, for example, someone uses findMin or findMax.\n\nlookupMinSure :: a -> Set a -> a\nlookupMinSure x Tip = x\nlookupMinSure _ (Bin _ x l _) = lookupMinSure x l\n\n-- | \\(O(\\log n)\\). The minimal element of a set.\n--\n-- @since 0.5.9\n\nlookupMin :: Set a -> Maybe a\nlookupMin Tip = Nothing\nlookupMin (Bin _ x l _) = Just $! lookupMinSure x l\n\n-- | \\(O(\\log n)\\). The minimal element of a set.\nfindMin :: Set a -> a\nfindMin t\n  | Just r <- lookupMin t = r\n  | otherwise = error "Set.findMin: empty set has no minimal element"\n\nlookupMaxSure :: a -> Set a -> a\nlookupMaxSure x Tip = x\nlookupMaxSure _ (Bin _ x _ r) = lookupMaxSure x r\n\n-- | \\(O(\\log n)\\). The maximal element of a set.\n--\n-- @since 0.5.9\n\nlookupMax :: Set a -> Maybe a\nlookupMax Tip = Nothing\nlookupMax (Bin _ x _ r) = Just $! lookupMaxSure x r\n\n-- | \\(O(\\log n)\\). The maximal element of a set.\nfindMax :: Set a -> a\nfindMax t\n  | Just r <- lookupMax t = r\n  | otherwise = error "Set.findMax: empty set has no maximal element"\n\n-- | \\(O(\\log n)\\). Delete the minimal element. Returns an empty set if the set is empty.\ndeleteMin :: Set a -> Set a\ndeleteMin (Bin _ _ Tip r) = r\ndeleteMin (Bin _ x l r)   = balanceR x (deleteMin l) r\ndeleteMin Tip             = Tip\n\n-- | \\(O(\\log n)\\). Delete the maximal element. Returns an empty set if the set is empty.\ndeleteMax :: Set a -> Set a\ndeleteMax (Bin _ _ l Tip) = l\ndeleteMax (Bin _ x l r)   = balanceL x l (deleteMax r)\ndeleteMax Tip             = Tip\n\n{--------------------------------------------------------------------\n  Union.\n--------------------------------------------------------------------}\n-- | The union of the sets in a Foldable structure : (@\'unions\' == \'foldl\' \'union\' \'empty\'@).\nunions :: (Foldable f, Ord a) => f (Set a) -> Set a\nunions = Foldable.foldl\' union empty\n#if __GLASGOW_HASKELL__\n{-# INLINABLE unions #-}\n#endif\n\n-- | \\(O\\bigl(m \\log\\bigl(\\frac{n+1}{m+1}\\bigr)\\bigr), \\; m \\leq n\\). The union of two sets, preferring the first set when\n-- equal elements are encountered.\nunion :: Ord a => Set a -> Set a -> Set a\nunion t1 Tip  = t1\nunion t1 (Bin 1 x _ _) = insertR x t1\nunion (Bin 1 x _ _) t2 = insert x t2\nunion Tip t2  = t2\nunion t1@(Bin _ x l1 r1) t2 = case splitS x t2 of\n  (l2 :*: r2)\n    | l1l2 `ptrEq` l1 && r1r2 `ptrEq` r1 -> t1\n    | otherwise -> link x l1l2 r1r2\n    where !l1l2 = union l1 l2\n          !r1r2 = union r1 r2\n#if __GLASGOW_HASKELL__\n{-# INLINABLE union #-}\n#endif\n\n{--------------------------------------------------------------------\n  Difference\n--------------------------------------------------------------------}\n-- | \\(O\\bigl(m \\log\\bigl(\\frac{n+1}{m+1}\\bigr)\\bigr), \\; m \\leq n\\). Difference of two sets.\n--\n-- Return elements of the first set not existing in the second set.\n--\n-- > difference (fromList [5, 3]) (fromList [5, 7]) == singleton 3\ndifference :: Ord a => Set a -> Set a -> Set a\ndifference Tip _   = Tip\ndifference t1 Tip  = t1\ndifference t1 (Bin _ x l2 r2) = case split x t1 of\n   (l1, r1)\n     | size l1l2 + size r1r2 == size t1 -> t1\n     | otherwise -> merge l1l2 r1r2\n     where !l1l2 = difference l1 l2\n           !r1r2 = difference r1 r2\n#if __GLASGOW_HASKELL__\n{-# INLINABLE difference #-}\n#endif\n\n{--------------------------------------------------------------------\n  Intersection\n--------------------------------------------------------------------}\n-- | \\(O\\bigl(m \\log\\bigl(\\frac{n+1}{m+1}\\bigr)\\bigr), \\; m \\leq n\\). The intersection of two sets.\n-- Elements of the result come from the first set, so for example\n--\n-- > import qualified Data.Set as S\n-- > data AB = A | B deriving Show\n-- > instance Ord AB where compare _ _ = EQ\n-- > instance Eq AB where _ == _ = True\n-- > main = print (S.singleton A `S.intersection` S.singleton B,\n-- >               S.singleton B `S.intersection` S.singleton A)\n--\n-- prints @(fromList [A],fromList [B])@.\nintersection :: Ord a => Set a -> Set a -> Set a\nintersection Tip _ = Tip\nintersection _ Tip = Tip\nintersection t1@(Bin _ x l1 r1) t2\n  | b = if l1l2 `ptrEq` l1 && r1r2 `ptrEq` r1\n        then t1\n        else link x l1l2 r1r2\n  | otherwise = merge l1l2 r1r2\n  where\n    !(l2, b, r2) = splitMember x t2\n    !l1l2 = intersection l1 l2\n    !r1r2 = intersection r1 r2\n#if __GLASGOW_HASKELL__\n{-# INLINABLE intersection #-}\n#endif\n\n-- | The intersection of a series of sets. Intersections are performed left-to-right.\nintersections :: Ord a => NonEmpty (Set a) -> Set a\nintersections (s0 :| ss) = List.foldr go id ss s0\n    where\n      go s r acc\n          | null acc = empty\n          | otherwise = r (intersection acc s)\n\n-- | Sets form a \'Semigroup\' under \'intersection\'.\nnewtype Intersection a = Intersection { getIntersection :: Set a }\n    deriving (Show, Eq, Ord)\n\ninstance (Ord a) => Semigroup (Intersection a) where\n    (Intersection a) <> (Intersection b) = Intersection $ intersection a b\n    stimes = stimesIdempotent\n\n{--------------------------------------------------------------------\n  Filter and partition\n--------------------------------------------------------------------}\n-- | \\(O(n)\\). Filter all elements that satisfy the predicate.\nfilter :: (a -> Bool) -> Set a -> Set a\nfilter _ Tip = Tip\nfilter p t@(Bin _ x l r)\n    | p x = if l `ptrEq` l\' && r `ptrEq` r\'\n            then t\n            else link x l\' r\'\n    | otherwise = merge l\' r\'\n    where\n      !l\' = filter p l\n      !r\' = filter p r\n\n-- | \\(O(n)\\). Partition the set into two sets, one with all elements that satisfy\n-- the predicate and one with all elements that don\'t satisfy the predicate.\n-- See also \'split\'.\npartition :: (a -> Bool) -> Set a -> (Set a,Set a)\npartition p0 t0 = toPair $ go p0 t0\n  where\n    go _ Tip = (Tip :*: Tip)\n    go p t@(Bin _ x l r) = case (go p l, go p r) of\n      ((l1 :*: l2), (r1 :*: r2))\n        | p x       -> (if l1 `ptrEq` l && r1 `ptrEq` r\n                        then t\n                        else link x l1 r1) :*: merge l2 r2\n        | otherwise -> merge l1 r1 :*:\n                       (if l2 `ptrEq` l && r2 `ptrEq` r\n                        then t\n                        else link x l2 r2)\n\n{----------------------------------------------------------------------\n  Map\n----------------------------------------------------------------------}\n\n-- | \\(O(n \\log n)\\).\n-- @\'map\' f s@ is the set obtained by applying @f@ to each element of @s@.\n--\n-- It\'s worth noting that the size of the result may be smaller if,\n-- for some @(x,y)@, @x \\/= y && f x == f y@\n\nmap :: Ord b => (a->b) -> Set a -> Set b\nmap f = fromList . List.map f . toList\n#if __GLASGOW_HASKELL__\n{-# INLINABLE map #-}\n#endif\n\n-- | \\(O(n)\\). The\n--\n-- @\'mapMonotonic\' f s == \'map\' f s@, but works only when @f@ is strictly increasing.\n-- /The precondition is not checked./\n-- Semi-formally, we have:\n--\n-- > and [x < y ==> f x < f y | x <- ls, y <- ls]\n-- >                     ==> mapMonotonic f s == map f s\n-- >     where ls = toList s\n\nmapMonotonic :: (a->b) -> Set a -> Set b\nmapMonotonic _ Tip = Tip\nmapMonotonic f (Bin sz x l r) = Bin sz (f x) (mapMonotonic f l) (mapMonotonic f r)\n\n{--------------------------------------------------------------------\n  Fold\n--------------------------------------------------------------------}\n-- | \\(O(n)\\). Fold the elements in the set using the given right-associative\n-- binary operator. This function is an equivalent of \'foldr\' and is present\n-- for compatibility only.\n--\n-- /Please note that fold will be deprecated in the future and removed./\nfold :: (a -> b -> b) -> b -> Set a -> b\nfold = foldr\n{-# INLINE fold #-}\n\n-- | \\(O(n)\\). Fold the elements in the set using the given right-associative\n-- binary operator, such that @\'foldr\' f z == \'Prelude.foldr\' f z . \'toAscList\'@.\n--\n-- For example,\n--\n-- > toAscList set = foldr (:) [] set\nfoldr :: (a -> b -> b) -> b -> Set a -> b\nfoldr f z = go z\n  where\n    go z\' Tip           = z\'\n    go z\' (Bin _ x l r) = go (f x (go z\' r)) l\n{-# INLINE foldr #-}\n\n-- | \\(O(n)\\). A strict version of \'foldr\'. Each application of the operator is\n-- evaluated before using the result in the next application. This\n-- function is strict in the starting value.\nfoldr\' :: (a -> b -> b) -> b -> Set a -> b\nfoldr\' f z = go z\n  where\n    go !z\' Tip           = z\'\n    go z\' (Bin _ x l r) = go (f x $! go z\' r) l\n{-# INLINE foldr\' #-}\n\n-- | \\(O(n)\\). Fold the elements in the set using the given left-associative\n-- binary operator, such that @\'foldl\' f z == \'Prelude.foldl\' f z . \'toAscList\'@.\n--\n-- For example,\n--\n-- > toDescList set = foldl (flip (:)) [] set\nfoldl :: (a -> b -> a) -> a -> Set b -> a\nfoldl f z = go z\n  where\n    go z\' Tip           = z\'\n    go z\' (Bin _ x l r) = go (f (go z\' l) x) r\n{-# INLINE foldl #-}\n\n-- | \\(O(n)\\). A strict version of \'foldl\'. Each application of the operator is\n-- evaluated before using the result in the next application. This\n-- function is strict in the starting value.\nfoldl\' :: (a -> b -> a) -> a -> Set b -> a\nfoldl\' f z = go z\n  where\n    go !z\' Tip           = z\'\n    go z\' (Bin _ x l r) =\n      let !z\'\' = go z\' l\n      in go (f z\'\' x) r\n{-# INLINE foldl\' #-}\n\n{--------------------------------------------------------------------\n  List variations\n--------------------------------------------------------------------}\n-- | \\(O(n)\\). An alias of \'toAscList\'. The elements of a set in ascending order.\n-- Subject to list fusion.\nelems :: Set a -> [a]\nelems = toAscList\n\n{--------------------------------------------------------------------\n  Lists\n--------------------------------------------------------------------}\n\n#ifdef __GLASGOW_HASKELL__\n-- | @since 0.5.6.2\ninstance (Ord a) => GHCExts.IsList (Set a) where\n  type Item (Set a) = a\n  fromList = fromList\n  toList   = toList\n#endif\n\n-- | \\(O(n)\\). Convert the set to a list of elements. Subject to list fusion.\ntoList :: Set a -> [a]\ntoList = toAscList\n\n-- | \\(O(n)\\). Convert the set to an ascending list of elements. Subject to list fusion.\ntoAscList :: Set a -> [a]\ntoAscList = foldr (:) []\n\n-- | \\(O(n)\\). Convert the set to a descending list of elements. Subject to list\n-- fusion.\ntoDescList :: Set a -> [a]\ntoDescList = foldl (flip (:)) []\n\n-- List fusion for the list generating functions.\n#if __GLASGOW_HASKELL__\n-- The foldrFB and foldlFB are foldr and foldl equivalents, used for list fusion.\n-- They are important to convert unfused to{Asc,Desc}List back, see mapFB in prelude.\nfoldrFB :: (a -> b -> b) -> b -> Set a -> b\nfoldrFB = foldr\n{-# INLINE[0] foldrFB #-}\nfoldlFB :: (a -> b -> a) -> a -> Set b -> a\nfoldlFB = foldl\n{-# INLINE[0] foldlFB #-}\n\n-- Inline elems and toList, so that we need to fuse only toAscList.\n{-# INLINE elems #-}\n{-# INLINE toList #-}\n\n-- The fusion is enabled up to phase 2 included. If it does not succeed,\n-- convert in phase 1 the expanded to{Asc,Desc}List calls back to\n-- to{Asc,Desc}List.  In phase 0, we inline fold{lr}FB (which were used in\n-- a list fusion, otherwise it would go away in phase 1), and let compiler do\n-- whatever it wants with to{Asc,Desc}List -- it was forbidden to inline it\n-- before phase 0, otherwise the fusion rules would not fire at all.\n{-# NOINLINE[0] toAscList #-}\n{-# NOINLINE[0] toDescList #-}\n{-# RULES "Set.toAscList" [~1] forall s . toAscList s = build (\\c n -> foldrFB c n s) #-}\n{-# RULES "Set.toAscListBack" [1] foldrFB (:) [] = toAscList #-}\n{-# RULES "Set.toDescList" [~1] forall s . toDescList s = build (\\c n -> foldlFB (\\xs x -> c x xs) n s) #-}\n{-# RULES "Set.toDescListBack" [1] foldlFB (\\xs x -> x : xs) [] = toDescList #-}\n#endif\n\n-- | \\(O(n \\log n)\\). Create a set from a list of elements.\n--\n-- If the elements are ordered, a linear-time implementation is used,\n-- with the performance equal to \'fromDistinctAscList\'.\n\n-- For some reason, when \'singleton\' is used in fromList or in\n-- create, it is not inlined, so we inline it manually.\nfromList :: Ord a => [a] -> Set a\nfromList [] = Tip\nfromList [x] = Bin 1 x Tip Tip\nfromList (x0 : xs0) | not_ordered x0 xs0 = fromList\' (Bin 1 x0 Tip Tip) xs0\n                    | otherwise = go (1::Int) (Bin 1 x0 Tip Tip) xs0\n  where\n    not_ordered _ [] = False\n    not_ordered x (y : _) = x >= y\n    {-# INLINE not_ordered #-}\n\n    fromList\' t0 xs = Foldable.foldl\' ins t0 xs\n      where ins t x = insert x t\n\n    go !_ t [] = t\n    go _ t [x] = insertMax x t\n    go s l xs@(x : xss) | not_ordered x xss = fromList\' l xs\n                        | otherwise = case create s xss of\n                            (r, ys, []) -> go (s `shiftL` 1) (link x l r) ys\n                            (r, _,  ys) -> fromList\' (link x l r) ys\n\n    -- The create is returning a triple (tree, xs, ys). Both xs and ys\n    -- represent not yet processed elements and only one of them can be nonempty.\n    -- If ys is nonempty, the keys in ys are not ordered with respect to tree\n    -- and must be inserted using fromList\'. Otherwise the keys have been\n    -- ordered so far.\n    create !_ [] = (Tip, [], [])\n    create s xs@(x : xss)\n      | s == 1 = if not_ordered x xss then (Bin 1 x Tip Tip, [], xss)\n                                      else (Bin 1 x Tip Tip, xss, [])\n      | otherwise = case create (s `shiftR` 1) xs of\n                      res@(_, [], _) -> res\n                      (l, [y], zs) -> (insertMax y l, [], zs)\n                      (l, ys@(y:yss), _) | not_ordered y yss -> (l, [], ys)\n                                         | otherwise -> case create (s `shiftR` 1) yss of\n                                                   (r, zs, ws) -> (link y l r, zs, ws)\n#if __GLASGOW_HASKELL__\n{-# INLINABLE fromList #-}\n#endif\n\n{--------------------------------------------------------------------\n  Building trees from ascending/descending lists can be done in linear time.\n\n  Note that if [xs] is ascending that:\n    fromAscList xs == fromList xs\n--------------------------------------------------------------------}\n-- | \\(O(n)\\). Build a set from an ascending list in linear time.\n-- /The precondition (input list is ascending) is not checked./\nfromAscList :: Eq a => [a] -> Set a\nfromAscList xs = fromDistinctAscList (combineEq xs)\n#if __GLASGOW_HASKELL__\n{-# INLINABLE fromAscList #-}\n#endif\n\n-- | \\(O(n)\\). Build a set from a descending list in linear time.\n-- /The precondition (input list is descending) is not checked./\n--\n-- @since 0.5.8\nfromDescList :: Eq a => [a] -> Set a\nfromDescList xs = fromDistinctDescList (combineEq xs)\n#if __GLASGOW_HASKELL__\n{-# INLINABLE fromDescList #-}\n#endif\n\n-- [combineEq xs] combines equal elements with [const] in an ordered list [xs]\n--\n-- TODO: combineEq allocates an intermediate list. It *should* be better to\n-- make fromAscListBy and fromDescListBy the fundamental operations, and to\n-- implement the rest using those.\ncombineEq :: Eq a => [a] -> [a]\ncombineEq [] = []\ncombineEq (x : xs) = combineEq\' x xs\n  where\n    combineEq\' z [] = [z]\n    combineEq\' z (y:ys)\n      | z == y = combineEq\' z ys\n      | otherwise = z : combineEq\' y ys\n\n-- | \\(O(n)\\). Build a set from an ascending list of distinct elements in linear time.\n-- /The precondition (input list is strictly ascending) is not checked./\n\n-- For some reason, when \'singleton\' is used in fromDistinctAscList or in\n-- create, it is not inlined, so we inline it manually.\nfromDistinctAscList :: [a] -> Set a\nfromDistinctAscList [] = Tip\nfromDistinctAscList (x0 : xs0) = go (1::Int) (Bin 1 x0 Tip Tip) xs0\n  where\n    go !_ t [] = t\n    go s l (x : xs) = case create s xs of\n                        (r :*: ys) -> let !t\' = link x l r\n                                      in go (s `shiftL` 1) t\' ys\n\n    create !_ [] = (Tip :*: [])\n    create s xs@(x : xs\')\n      | s == 1 = (Bin 1 x Tip Tip :*: xs\')\n      | otherwise = case create (s `shiftR` 1) xs of\n                      res@(_ :*: []) -> res\n                      (l :*: (y:ys)) -> case create (s `shiftR` 1) ys of\n                        (r :*: zs) -> (link y l r :*: zs)\n\n-- | \\(O(n)\\). Build a set from a descending list of distinct elements in linear time.\n-- /The precondition (input list is strictly descending) is not checked./\n\n-- For some reason, when \'singleton\' is used in fromDistinctDescList or in\n-- create, it is not inlined, so we inline it manually.\n--\n-- @since 0.5.8\nfromDistinctDescList :: [a] -> Set a\nfromDistinctDescList [] = Tip\nfromDistinctDescList (x0 : xs0) = go (1::Int) (Bin 1 x0 Tip Tip) xs0\n  where\n    go !_ t [] = t\n    go s r (x : xs) = case create s xs of\n                        (l :*: ys) -> let !t\' = link x l r\n                                      in go (s `shiftL` 1) t\' ys\n\n    create !_ [] = (Tip :*: [])\n    create s xs@(x : xs\')\n      | s == 1 = (Bin 1 x Tip Tip :*: xs\')\n      | otherwise = case create (s `shiftR` 1) xs of\n                      res@(_ :*: []) -> res\n                      (r :*: (y:ys)) -> case create (s `shiftR` 1) ys of\n                        (l :*: zs) -> (link y l r :*: zs)\n\n{--------------------------------------------------------------------\n  Eq converts the set to a list. In a lazy setting, this\n  actually seems one of the faster methods to compare two trees\n  and it is certainly the simplest :-)\n--------------------------------------------------------------------}\ninstance Eq a => Eq (Set a) where\n  t1 == t2  = (size t1 == size t2) && (toAscList t1 == toAscList t2)\n\n{--------------------------------------------------------------------\n  Ord\n--------------------------------------------------------------------}\n\ninstance Ord a => Ord (Set a) where\n    compare s1 s2 = compare (toAscList s1) (toAscList s2)\n\n{--------------------------------------------------------------------\n  Show\n--------------------------------------------------------------------}\ninstance Show a => Show (Set a) where\n  showsPrec p xs = showParen (p > 10) $\n    showString "fromList " . shows (toList xs)\n\n-- | @since 0.5.9\ninstance Eq1 Set where\n    liftEq eq m n =\n        size m == size n && liftEq eq (toList m) (toList n)\n\n-- | @since 0.5.9\ninstance Ord1 Set where\n    liftCompare cmp m n =\n        liftCompare cmp (toList m) (toList n)\n\n-- | @since 0.5.9\ninstance Show1 Set where\n    liftShowsPrec sp sl d m =\n        showsUnaryWith (liftShowsPrec sp sl) "fromList" d (toList m)\n\n{--------------------------------------------------------------------\n  Read\n--------------------------------------------------------------------}\ninstance (Read a, Ord a) => Read (Set a) where\n#ifdef __GLASGOW_HASKELL__\n  readPrec = parens $ prec 10 $ do\n    Ident "fromList" <- lexP\n    xs <- readPrec\n    return (fromList xs)\n\n  readListPrec = readListPrecDefault\n#else\n  readsPrec p = readParen (p > 10) $ \\ r -> do\n    ("fromList",s) <- lex r\n    (xs,t) <- reads s\n    return (fromList xs,t)\n#endif\n\n{--------------------------------------------------------------------\n  NFData\n--------------------------------------------------------------------}\n\ninstance NFData a => NFData (Set a) where\n    rnf Tip           = ()\n    rnf (Bin _ y l r) = rnf y `seq` rnf l `seq` rnf r\n\n{--------------------------------------------------------------------\n  Split\n--------------------------------------------------------------------}\n-- | \\(O(\\log n)\\). The expression (@\'split\' x set@) is a pair @(set1,set2)@\n-- where @set1@ comprises the elements of @set@ less than @x@ and @set2@\n-- comprises the elements of @set@ greater than @x@.\nsplit :: Ord a => a -> Set a -> (Set a,Set a)\nsplit x t = toPair $ splitS x t\n{-# INLINABLE split #-}\n\nsplitS :: Ord a => a -> Set a -> StrictPair (Set a) (Set a)\nsplitS _ Tip = (Tip :*: Tip)\nsplitS x (Bin _ y l r)\n      = case compare x y of\n          LT -> let (lt :*: gt) = splitS x l in (lt :*: link y gt r)\n          GT -> let (lt :*: gt) = splitS x r in (link y l lt :*: gt)\n          EQ -> (l :*: r)\n{-# INLINABLE splitS #-}\n\n-- | \\(O(\\log n)\\). Performs a \'split\' but also returns whether the pivot\n-- element was found in the original set.\nsplitMember :: Ord a => a -> Set a -> (Set a,Bool,Set a)\nsplitMember _ Tip = (Tip, False, Tip)\nsplitMember x (Bin _ y l r)\n   = case compare x y of\n       LT -> let (lt, found, gt) = splitMember x l\n                 !gt\' = link y gt r\n             in (lt, found, gt\')\n       GT -> let (lt, found, gt) = splitMember x r\n                 !lt\' = link y l lt\n             in (lt\', found, gt)\n       EQ -> (l, True, r)\n#if __GLASGOW_HASKELL__\n{-# INLINABLE splitMember #-}\n#endif\n\n{--------------------------------------------------------------------\n  Indexing\n--------------------------------------------------------------------}\n\n-- | \\(O(\\log n)\\). Return the /index/ of an element, which is its zero-based\n-- index in the sorted sequence of elements. The index is a number from /0/ up\n-- to, but not including, the \'size\' of the set. Calls \'error\' when the element\n-- is not a \'member\' of the set.\n--\n-- > findIndex 2 (fromList [5,3])    Error: element is not in the set\n-- > findIndex 3 (fromList [5,3]) == 0\n-- > findIndex 5 (fromList [5,3]) == 1\n-- > findIndex 6 (fromList [5,3])    Error: element is not in the set\n--\n-- @since 0.5.4\n\n-- See Note: Type of local \'go\' function\nfindIndex :: Ord a => a -> Set a -> Int\nfindIndex = go 0\n  where\n    go :: Ord a => Int -> a -> Set a -> Int\n    go !_ !_ Tip  = error "Set.findIndex: element is not in the set"\n    go idx x (Bin _ kx l r) = case compare x kx of\n      LT -> go idx x l\n      GT -> go (idx + size l + 1) x r\n      EQ -> idx + size l\n#if __GLASGOW_HASKELL__\n{-# INLINABLE findIndex #-}\n#endif\n\n-- | \\(O(\\log n)\\). Lookup the /index/ of an element, which is its zero-based index in\n-- the sorted sequence of elements. The index is a number from /0/ up to, but not\n-- including, the \'size\' of the set.\n--\n-- > isJust   (lookupIndex 2 (fromList [5,3])) == False\n-- > fromJust (lookupIndex 3 (fromList [5,3])) == 0\n-- > fromJust (lookupIndex 5 (fromList [5,3])) == 1\n-- > isJust   (lookupIndex 6 (fromList [5,3])) == False\n--\n-- @since 0.5.4\n\n-- See Note: Type of local \'go\' function\nlookupIndex :: Ord a => a -> Set a -> Maybe Int\nlookupIndex = go 0\n  where\n    go :: Ord a => Int -> a -> Set a -> Maybe Int\n    go !_ !_ Tip  = Nothing\n    go idx x (Bin _ kx l r) = case compare x kx of\n      LT -> go idx x l\n      GT -> go (idx + size l + 1) x r\n      EQ -> Just $! idx + size l\n#if __GLASGOW_HASKELL__\n{-# INLINABLE lookupIndex #-}\n#endif\n\n-- | \\(O(\\log n)\\). Retrieve an element by its /index/, i.e. by its zero-based\n-- index in the sorted sequence of elements. If the /index/ is out of range (less\n-- than zero, greater or equal to \'size\' of the set), \'error\' is called.\n--\n-- > elemAt 0 (fromList [5,3]) == 3\n-- > elemAt 1 (fromList [5,3]) == 5\n-- > elemAt 2 (fromList [5,3])    Error: index out of range\n--\n-- @since 0.5.4\n\nelemAt :: Int -> Set a -> a\nelemAt !_ Tip = error "Set.elemAt: index out of range"\nelemAt i (Bin _ x l r)\n  = case compare i sizeL of\n      LT -> elemAt i l\n      GT -> elemAt (i-sizeL-1) r\n      EQ -> x\n  where\n    sizeL = size l\n\n-- | \\(O(\\log n)\\). Delete the element at /index/, i.e. by its zero-based index in\n-- the sorted sequence of elements. If the /index/ is out of range (less than zero,\n-- greater or equal to \'size\' of the set), \'error\' is called.\n--\n-- > deleteAt 0    (fromList [5,3]) == singleton 5\n-- > deleteAt 1    (fromList [5,3]) == singleton 3\n-- > deleteAt 2    (fromList [5,3])    Error: index out of range\n-- > deleteAt (-1) (fromList [5,3])    Error: index out of range\n--\n-- @since 0.5.4\n\ndeleteAt :: Int -> Set a -> Set a\ndeleteAt !i t =\n  case t of\n    Tip -> error "Set.deleteAt: index out of range"\n    Bin _ x l r -> case compare i sizeL of\n      LT -> balanceR x (deleteAt i l) r\n      GT -> balanceL x l (deleteAt (i-sizeL-1) r)\n      EQ -> glue l r\n      where\n        sizeL = size l\n\n-- | \\(O(\\log n)\\). Take a given number of elements in order, beginning\n-- with the smallest ones.\n--\n-- @\n-- take n = \'fromDistinctAscList\' . \'Prelude.take\' n . \'toAscList\'\n-- @\n--\n-- @since 0.5.8\ntake :: Int -> Set a -> Set a\ntake i m | i >= size m = m\ntake i0 m0 = go i0 m0\n  where\n    go i !_ | i <= 0 = Tip\n    go !_ Tip = Tip\n    go i (Bin _ x l r) =\n      case compare i sizeL of\n        LT -> go i l\n        GT -> link x l (go (i - sizeL - 1) r)\n        EQ -> l\n      where sizeL = size l\n\n-- | \\(O(\\log n)\\). Drop a given number of elements in order, beginning\n-- with the smallest ones.\n--\n-- @\n-- drop n = \'fromDistinctAscList\' . \'Prelude.drop\' n . \'toAscList\'\n-- @\n--\n-- @since 0.5.8\ndrop :: Int -> Set a -> Set a\ndrop i m | i >= size m = Tip\ndrop i0 m0 = go i0 m0\n  where\n    go i m | i <= 0 = m\n    go !_ Tip = Tip\n    go i (Bin _ x l r) =\n      case compare i sizeL of\n        LT -> link x (go i l) r\n        GT -> go (i - sizeL - 1) r\n        EQ -> insertMin x r\n      where sizeL = size l\n\n-- | \\(O(\\log n)\\). Split a set at a particular index.\n--\n-- @\n-- splitAt !n !xs = (\'take\' n xs, \'drop\' n xs)\n-- @\nsplitAt :: Int -> Set a -> (Set a, Set a)\nsplitAt i0 m0\n  | i0 >= size m0 = (m0, Tip)\n  | otherwise = toPair $ go i0 m0\n  where\n    go i m | i <= 0 = Tip :*: m\n    go !_ Tip = Tip :*: Tip\n    go i (Bin _ x l r)\n      = case compare i sizeL of\n          LT -> case go i l of\n                  ll :*: lr -> ll :*: link x lr r\n          GT -> case go (i - sizeL - 1) r of\n                  rl :*: rr -> link x l rl :*: rr\n          EQ -> l :*: insertMin x r\n      where sizeL = size l\n\n-- | \\(O(\\log n)\\). Take while a predicate on the elements holds.\n-- The user is responsible for ensuring that for all elements @j@ and @k@ in the set,\n-- @j \\< k ==\\> p j \\>= p k@. See note at \'spanAntitone\'.\n--\n-- @\n-- takeWhileAntitone p = \'fromDistinctAscList\' . \'Data.List.takeWhile\' p . \'toList\'\n-- takeWhileAntitone p = \'filter\' p\n-- @\n--\n-- @since 0.5.8\n\ntakeWhileAntitone :: (a -> Bool) -> Set a -> Set a\ntakeWhileAntitone _ Tip = Tip\ntakeWhileAntitone p (Bin _ x l r)\n  | p x = link x l (takeWhileAntitone p r)\n  | otherwise = takeWhileAntitone p l\n\n-- | \\(O(\\log n)\\). Drop while a predicate on the elements holds.\n-- The user is responsible for ensuring that for all elements @j@ and @k@ in the set,\n-- @j \\< k ==\\> p j \\>= p k@. See note at \'spanAntitone\'.\n--\n-- @\n-- dropWhileAntitone p = \'fromDistinctAscList\' . \'Data.List.dropWhile\' p . \'toList\'\n-- dropWhileAntitone p = \'filter\' (not . p)\n-- @\n--\n-- @since 0.5.8\n\ndropWhileAntitone :: (a -> Bool) -> Set a -> Set a\ndropWhileAntitone _ Tip = Tip\ndropWhileAntitone p (Bin _ x l r)\n  | p x = dropWhileAntitone p r\n  | otherwise = link x (dropWhileAntitone p l) r\n\n-- | \\(O(\\log n)\\). Divide a set at the point where a predicate on the elements stops holding.\n-- The user is responsible for ensuring that for all elements @j@ and @k@ in the set,\n-- @j \\< k ==\\> p j \\>= p k@.\n--\n-- @\n-- spanAntitone p xs = (\'takeWhileAntitone\' p xs, \'dropWhileAntitone\' p xs)\n-- spanAntitone p xs = partition p xs\n-- @\n--\n-- Note: if @p@ is not actually antitone, then @spanAntitone@ will split the set\n-- at some /unspecified/ point where the predicate switches from holding to not\n-- holding (where the predicate is seen to hold before the first element and to fail\n-- after the last element).\n--\n-- @since 0.5.8\n\nspanAntitone :: (a -> Bool) -> Set a -> (Set a, Set a)\nspanAntitone p0 m = toPair (go p0 m)\n  where\n    go _ Tip = Tip :*: Tip\n    go p (Bin _ x l r)\n      | p x = let u :*: v = go p r in link x l u :*: v\n      | otherwise = let u :*: v = go p l in u :*: link x v r\n\n\n{--------------------------------------------------------------------\n  Utility functions that maintain the balance properties of the tree.\n  All constructors assume that all values in [l] < [x] and all values\n  in [r] > [x], and that [l] and [r] are valid trees.\n\n  In order of sophistication:\n    [Bin sz x l r]    The type constructor.\n    [bin x l r]       Maintains the correct size, assumes that both [l]\n                      and [r] are balanced with respect to each other.\n    [balance x l r]   Restores the balance and size.\n                      Assumes that the original tree was balanced and\n                      that [l] or [r] has changed by at most one element.\n    [link x l r]      Restores balance and size.\n\n  Furthermore, we can construct a new tree from two trees. Both operations\n  assume that all values in [l] < all values in [r] and that [l] and [r]\n  are valid:\n    [glue l r]        Glues [l] and [r] together. Assumes that [l] and\n                      [r] are already balanced with respect to each other.\n    [merge l r]       Merges two trees and restores balance.\n--------------------------------------------------------------------}\n\n{--------------------------------------------------------------------\n  Link\n--------------------------------------------------------------------}\nlink :: a -> Set a -> Set a -> Set a\nlink x Tip r  = insertMin x r\nlink x l Tip  = insertMax x l\nlink x l@(Bin sizeL y ly ry) r@(Bin sizeR z lz rz)\n  | delta*sizeL < sizeR  = balanceL z (link x l lz) rz\n  | delta*sizeR < sizeL  = balanceR y ly (link x ry r)\n  | otherwise            = bin x l r\n\n\n-- insertMin and insertMax don\'t perform potentially expensive comparisons.\ninsertMax,insertMin :: a -> Set a -> Set a\ninsertMax x t\n  = case t of\n      Tip -> singleton x\n      Bin _ y l r\n          -> balanceR y l (insertMax x r)\n\ninsertMin x t\n  = case t of\n      Tip -> singleton x\n      Bin _ y l r\n          -> balanceL y (insertMin x l) r\n\n{--------------------------------------------------------------------\n  [merge l r]: merges two trees.\n--------------------------------------------------------------------}\nmerge :: Set a -> Set a -> Set a\nmerge Tip r   = r\nmerge l Tip   = l\nmerge l@(Bin sizeL x lx rx) r@(Bin sizeR y ly ry)\n  | delta*sizeL < sizeR = balanceL y (merge l ly) ry\n  | delta*sizeR < sizeL = balanceR x lx (merge rx r)\n  | otherwise           = glue l r\n\n{--------------------------------------------------------------------\n  [glue l r]: glues two trees together.\n  Assumes that [l] and [r] are already balanced with respect to each other.\n--------------------------------------------------------------------}\nglue :: Set a -> Set a -> Set a\nglue Tip r = r\nglue l Tip = l\nglue l@(Bin sl xl ll lr) r@(Bin sr xr rl rr)\n  | sl > sr = let !(m :*: l\') = maxViewSure xl ll lr in balanceR m l\' r\n  | otherwise = let !(m :*: r\') = minViewSure xr rl rr in balanceL m l r\'\n\n-- | \\(O(\\log n)\\). Delete and find the minimal element.\n--\n-- > deleteFindMin set = (findMin set, deleteMin set)\n\ndeleteFindMin :: Set a -> (a,Set a)\ndeleteFindMin t\n  | Just r <- minView t = r\n  | otherwise = (error "Set.deleteFindMin: can not return the minimal element of an empty set", Tip)\n\n-- | \\(O(\\log n)\\). Delete and find the maximal element.\n--\n-- > deleteFindMax set = (findMax set, deleteMax set)\ndeleteFindMax :: Set a -> (a,Set a)\ndeleteFindMax t\n  | Just r <- maxView t = r\n  | otherwise = (error "Set.deleteFindMax: can not return the maximal element of an empty set", Tip)\n\nminViewSure :: a -> Set a -> Set a -> StrictPair a (Set a)\nminViewSure = go\n  where\n    go x Tip r = x :*: r\n    go x (Bin _ xl ll lr) r =\n      case go xl ll lr of\n        xm :*: l\' -> xm :*: balanceR x l\' r\n\n-- | \\(O(\\log n)\\). Retrieves the minimal key of the set, and the set\n-- stripped of that element, or \'Nothing\' if passed an empty set.\nminView :: Set a -> Maybe (a, Set a)\nminView Tip = Nothing\nminView (Bin _ x l r) = Just $! toPair $ minViewSure x l r\n\nmaxViewSure :: a -> Set a -> Set a -> StrictPair a (Set a)\nmaxViewSure = go\n  where\n    go x l Tip = x :*: l\n    go x l (Bin _ xr rl rr) =\n      case go xr rl rr of\n        xm :*: r\' -> xm :*: balanceL x l r\'\n\n-- | \\(O(\\log n)\\). Retrieves the maximal key of the set, and the set\n-- stripped of that element, or \'Nothing\' if passed an empty set.\nmaxView :: Set a -> Maybe (a, Set a)\nmaxView Tip = Nothing\nmaxView (Bin _ x l r) = Just $! toPair $ maxViewSure x l r\n\n{--------------------------------------------------------------------\n  [balance x l r] balances two trees with value x.\n  The sizes of the trees should balance after decreasing the\n  size of one of them. (a rotation).\n\n  [delta] is the maximal relative difference between the sizes of\n          two trees, it corresponds with the [w] in Adams\' paper.\n  [ratio] is the ratio between an outer and inner sibling of the\n          heavier subtree in an unbalanced setting. It determines\n          whether a double or single rotation should be performed\n          to restore balance. It is corresponds with the inverse\n          of $\\alpha$ in Adam\'s article.\n\n  Note that according to the Adam\'s paper:\n  - [delta] should be larger than 4.646 with a [ratio] of 2.\n  - [delta] should be larger than 3.745 with a [ratio] of 1.534.\n\n  But the Adam\'s paper is erroneous:\n  - it can be proved that for delta=2 and delta>=5 there does\n    not exist any ratio that would work\n  - delta=4.5 and ratio=2 does not work\n\n  That leaves two reasonable variants, delta=3 and delta=4,\n  both with ratio=2.\n\n  - A lower [delta] leads to a more \'perfectly\' balanced tree.\n  - A higher [delta] performs less rebalancing.\n\n  In the benchmarks, delta=3 is faster on insert operations,\n  and delta=4 has slightly better deletes. As the insert speedup\n  is larger, we currently use delta=3.\n\n--------------------------------------------------------------------}\ndelta,ratio :: Int\ndelta = 3\nratio = 2\n\n-- The balance function is equivalent to the following:\n--\n--   balance :: a -> Set a -> Set a -> Set a\n--   balance x l r\n--     | sizeL + sizeR <= 1   = Bin sizeX x l r\n--     | sizeR > delta*sizeL  = rotateL x l r\n--     | sizeL > delta*sizeR  = rotateR x l r\n--     | otherwise            = Bin sizeX x l r\n--     where\n--       sizeL = size l\n--       sizeR = size r\n--       sizeX = sizeL + sizeR + 1\n--\n--   rotateL :: a -> Set a -> Set a -> Set a\n--   rotateL x l r@(Bin _ _ ly ry) | size ly < ratio*size ry = singleL x l r\n--                                 | otherwise               = doubleL x l r\n--   rotateR :: a -> Set a -> Set a -> Set a\n--   rotateR x l@(Bin _ _ ly ry) r | size ry < ratio*size ly = singleR x l r\n--                                 | otherwise               = doubleR x l r\n--\n--   singleL, singleR :: a -> Set a -> Set a -> Set a\n--   singleL x1 t1 (Bin _ x2 t2 t3)  = bin x2 (bin x1 t1 t2) t3\n--   singleR x1 (Bin _ x2 t1 t2) t3  = bin x2 t1 (bin x1 t2 t3)\n--\n--   doubleL, doubleR :: a -> Set a -> Set a -> Set a\n--   doubleL x1 t1 (Bin _ x2 (Bin _ x3 t2 t3) t4) = bin x3 (bin x1 t1 t2) (bin x2 t3 t4)\n--   doubleR x1 (Bin _ x2 t1 (Bin _ x3 t2 t3)) t4 = bin x3 (bin x2 t1 t2) (bin x1 t3 t4)\n--\n-- It is only written in such a way that every node is pattern-matched only once.\n--\n-- Only balanceL and balanceR are needed at the moment, so balance is not here anymore.\n-- In case it is needed, it can be found in Data.Map.\n\n-- Functions balanceL and balanceR are specialised versions of balance.\n-- balanceL only checks whether the left subtree is too big,\n-- balanceR only checks whether the right subtree is too big.\n\n-- balanceL is called when left subtree might have been inserted to or when\n-- right subtree might have been deleted from.\nbalanceL :: a -> Set a -> Set a -> Set a\nbalanceL x l r = case r of\n  Tip -> case l of\n           Tip -> Bin 1 x Tip Tip\n           (Bin _ _ Tip Tip) -> Bin 2 x l Tip\n           (Bin _ lx Tip (Bin _ lrx _ _)) -> Bin 3 lrx (Bin 1 lx Tip Tip) (Bin 1 x Tip Tip)\n           (Bin _ lx ll@(Bin _ _ _ _) Tip) -> Bin 3 lx ll (Bin 1 x Tip Tip)\n           (Bin ls lx ll@(Bin lls _ _ _) lr@(Bin lrs lrx lrl lrr))\n             | lrs < ratio*lls -> Bin (1+ls) lx ll (Bin (1+lrs) x lr Tip)\n             | otherwise -> Bin (1+ls) lrx (Bin (1+lls+size lrl) lx ll lrl) (Bin (1+size lrr) x lrr Tip)\n\n  (Bin rs _ _ _) -> case l of\n           Tip -> Bin (1+rs) x Tip r\n\n           (Bin ls lx ll lr)\n              | ls > delta*rs  -> case (ll, lr) of\n                   (Bin lls _ _ _, Bin lrs lrx lrl lrr)\n                     | lrs < ratio*lls -> Bin (1+ls+rs) lx ll (Bin (1+rs+lrs) x lr r)\n                     | otherwise -> Bin (1+ls+rs) lrx (Bin (1+lls+size lrl) lx ll lrl) (Bin (1+rs+size lrr) x lrr r)\n                   (_, _) -> error "Failure in Data.Set.balanceL"\n              | otherwise -> Bin (1+ls+rs) x l r\n{-# NOINLINE balanceL #-}\n\n-- balanceR is called when right subtree might have been inserted to or when\n-- left subtree might have been deleted from.\nbalanceR :: a -> Set a -> Set a -> Set a\nbalanceR x l r = case l of\n  Tip -> case r of\n           Tip -> Bin 1 x Tip Tip\n           (Bin _ _ Tip Tip) -> Bin 2 x Tip r\n           (Bin _ rx Tip rr@(Bin _ _ _ _)) -> Bin 3 rx (Bin 1 x Tip Tip) rr\n           (Bin _ rx (Bin _ rlx _ _) Tip) -> Bin 3 rlx (Bin 1 x Tip Tip) (Bin 1 rx Tip Tip)\n           (Bin rs rx rl@(Bin rls rlx rll rlr) rr@(Bin rrs _ _ _))\n             | rls < ratio*rrs -> Bin (1+rs) rx (Bin (1+rls) x Tip rl) rr\n             | otherwise -> Bin (1+rs) rlx (Bin (1+size rll) x Tip rll) (Bin (1+rrs+size rlr) rx rlr rr)\n\n  (Bin ls _ _ _) -> case r of\n           Tip -> Bin (1+ls) x l Tip\n\n           (Bin rs rx rl rr)\n              | rs > delta*ls  -> case (rl, rr) of\n                   (Bin rls rlx rll rlr, Bin rrs _ _ _)\n                     | rls < ratio*rrs -> Bin (1+ls+rs) rx (Bin (1+ls+rls) x l rl) rr\n                     | otherwise -> Bin (1+ls+rs) rlx (Bin (1+ls+size rll) x l rll) (Bin (1+rrs+size rlr) rx rlr rr)\n                   (_, _) -> error "Failure in Data.Set.balanceR"\n              | otherwise -> Bin (1+ls+rs) x l r\n{-# NOINLINE balanceR #-}\n\n{--------------------------------------------------------------------\n  The bin constructor maintains the size of the tree\n--------------------------------------------------------------------}\nbin :: a -> Set a -> Set a -> Set a\nbin x l r\n  = Bin (size l + size r + 1) x l r\n{-# INLINE bin #-}\n\n\n{--------------------------------------------------------------------\n  Utilities\n--------------------------------------------------------------------}\n\n-- | \\(O(1)\\).  Decompose a set into pieces based on the structure of the underlying\n-- tree.  This function is useful for consuming a set in parallel.\n--\n-- No guarantee is made as to the sizes of the pieces; an internal, but\n-- deterministic process determines this.  However, it is guaranteed that the pieces\n-- returned will be in ascending order (all elements in the first subset less than all\n-- elements in the second, and so on).\n--\n-- Examples:\n--\n-- > splitRoot (fromList [1..6]) ==\n-- >   [fromList [1,2,3],fromList [4],fromList [5,6]]\n--\n-- > splitRoot empty == []\n--\n--  Note that the current implementation does not return more than three subsets,\n--  but you should not depend on this behaviour because it can change in the\n--  future without notice.\n--\n-- @since 0.5.4\nsplitRoot :: Set a -> [Set a]\nsplitRoot orig =\n  case orig of\n    Tip           -> []\n    Bin _ v l r -> [l, singleton v, r]\n{-# INLINE splitRoot #-}\n\n\n-- | \\(O(2^n \\log n)\\). Calculate the power set of a set: the set of all its subsets.\n--\n-- @\n-- t ``member`` powerSet s == t ``isSubsetOf`` s\n-- @\n--\n-- Example:\n--\n-- @\n-- powerSet (fromList [1,2,3]) =\n--   fromList $ map fromList [[],[1],[1,2],[1,2,3],[1,3],[2],[2,3],[3]]\n-- @\n--\n-- @since 0.5.11\n\n-- Proof of complexity: step executes n times. At the ith step,\n-- "insertMin x `mapMonotonic` pxs" takes O(2^i log i) time since pxs has size\n-- 2^i - 1 and we insertMin into its elements which are sets of size <= i.\n-- "insertMin (singleton x)" and "`glue` pxs" are cheaper operations that both\n-- take O(i) time. Over n steps, we have a total cost of\n--\n--   O(\\sum_{i=1}^{n-1} 2^i log i)\n-- = O(log n * \\sum_{i=1}^{n-1} 2^i)\n-- = O(2^n log n)\n\npowerSet :: Set a -> Set (Set a)\npowerSet xs0 = insertMin empty (foldr\' step Tip xs0) where\n  step x pxs = insertMin (singleton x) (insertMin x `mapMonotonic` pxs) `glue` pxs\n\n-- | \\(O(nm)\\). Calculate the Cartesian product of two sets.\n--\n-- @\n-- cartesianProduct xs ys = fromList $ liftA2 (,) (toList xs) (toList ys)\n-- @\n--\n-- Example:\n--\n-- @\n-- cartesianProduct (fromList [1,2]) (fromList [\\\'a\\\',\\\'b\\\']) =\n--   fromList [(1,\\\'a\\\'), (1,\\\'b\\\'), (2,\\\'a\\\'), (2,\\\'b\\\')]\n-- @\n--\n-- @since 0.5.11\ncartesianProduct :: Set a -> Set b -> Set (a, b)\n-- The obvious big-O optimal (O(nm)) implementation would be\n--\n--   cartesianProduct _as Tip = Tip\n--   cartesianProduct as bs = fromDistinctAscList\n--     [(a,b) | a <- toList as, b <- toList bs]\n--\n-- Unfortunately, this is much slower in practice, at least when the sets are\n-- constructed from ascending lists. I tried doing the same thing using a\n-- known-length (perfect balancing) variant of fromDistinctAscList, but it\n-- still didn\'t come close to the performance of the implementation we use in my\n-- very informal tests.\n--\n-- The implementation we use (slightly modified from one that Edward Kmett\n-- hacked together) is also optimal but performs better in practice. We map\n-- each element a in as to a set made up of (a,b) for every element b in bs,\n-- taking O(nm) overall. Then we merge these sets up the tree of as, which takes\n-- O(n log m). A brief sketch of proof for the latter:\n--\n-- Consider all nodes in the tree at the same distance from the root to be at\n-- the same "level". The nodes farthest from the root are at level 0, with\n-- levels increasing by 1 towards the root. Being a balanced tree, there are\n-- O(n/2^i) nodes at level i. At every node at level i, we merge the merged left\n-- set, current set, and merged right set into a set of size O(2^i*m) in\n-- O(log (2^i*m)) = O(i + log m) time. Over all levels, we do a total work of\n--\n--   O(\\sum_{i=0}^{root_level} n * (i + log m) / 2^i)\n-- = O(  \\sum_{i=0}^{root_level} n * i / 2^i\n--     + \\sum_{i=0}^{root_level} n * log m / 2^i)\n-- = O(  n * \\sum_{i=0}^{root_level} i/2^i\n--     + n * log m * \\sum_{i=0}^{root_level} 1/2^i)\n-- = O(  n * \\sum_{i=0}^{inf} i/2^i\n--     + n * log m * \\sum_{i=0}^{inf} 1/2^i)\n--\n-- The sum terms converge, and we get O(n log m).\n\n-- When the second argument has at most one element, we can be a little\n-- clever.\ncartesianProduct !_as Tip = Tip\ncartesianProduct as (Bin 1 b _ _) = mapMonotonic (flip (,) b) as\ncartesianProduct as bs =\n  getMergeSet $ foldMap (\\a -> MergeSet $ mapMonotonic ((,) a) bs) as\n\n-- A version of Set with peculiar Semigroup and Monoid instances.\n-- The result of xs <> ys will only be a valid set if the greatest\n-- element of xs is strictly less than the least element of ys.\n-- This is used to define cartesianProduct.\nnewtype MergeSet a = MergeSet { getMergeSet :: Set a }\n\ninstance Semigroup (MergeSet a) where\n  MergeSet xs <> MergeSet ys = MergeSet (merge xs ys)\n\ninstance Monoid (MergeSet a) where\n  mempty = MergeSet empty\n\n  mappend = (<>)\n\n-- | \\(O(n+m)\\). Calculate the disjoint union of two sets.\n--\n-- @ disjointUnion xs ys = map Left xs ``union`` map Right ys @\n--\n-- Example:\n--\n-- @\n-- disjointUnion (fromList [1,2]) (fromList ["hi", "bye"]) =\n--   fromList [Left 1, Left 2, Right "hi", Right "bye"]\n-- @\n--\n-- @since 0.5.11\ndisjointUnion :: Set a -> Set b -> Set (Either a b)\ndisjointUnion as bs = merge (mapMonotonic Left as) (mapMonotonic Right bs)\n\n{--------------------------------------------------------------------\n  Debugging\n--------------------------------------------------------------------}\n-- | \\(O(n \\log n)\\). Show the tree that implements the set. The tree is shown\n-- in a compressed, hanging format.\nshowTree :: Show a => Set a -> String\nshowTree s\n  = showTreeWith True False s\n\n\n{- | \\(O(n \\log n)\\). The expression (@showTreeWith hang wide map@) shows\n the tree that implements the set. If @hang@ is\n @True@, a /hanging/ tree is shown otherwise a rotated tree is shown. If\n @wide@ is \'True\', an extra wide version is shown.\n\n> Set> putStrLn $ showTreeWith True False $ fromDistinctAscList [1..5]\n> 4\n> +--2\n> |  +--1\n> |  +--3\n> +--5\n>\n> Set> putStrLn $ showTreeWith True True $ fromDistinctAscList [1..5]\n> 4\n> |\n> +--2\n> |  |\n> |  +--1\n> |  |\n> |  +--3\n> |\n> +--5\n>\n> Set> putStrLn $ showTreeWith False True $ fromDistinctAscList [1..5]\n> +--5\n> |\n> 4\n> |\n> |  +--3\n> |  |\n> +--2\n>    |\n>    +--1\n\n-}\nshowTreeWith :: Show a => Bool -> Bool -> Set a -> String\nshowTreeWith hang wide t\n  | hang      = (showsTreeHang wide [] t) ""\n  | otherwise = (showsTree wide [] [] t) ""\n\nshowsTree :: Show a => Bool -> [String] -> [String] -> Set a -> ShowS\nshowsTree wide lbars rbars t\n  = case t of\n      Tip -> showsBars lbars . showString "|\\n"\n      Bin _ x Tip Tip\n          -> showsBars lbars . shows x . showString "\\n"\n      Bin _ x l r\n          -> showsTree wide (withBar rbars) (withEmpty rbars) r .\n             showWide wide rbars .\n             showsBars lbars . shows x . showString "\\n" .\n             showWide wide lbars .\n             showsTree wide (withEmpty lbars) (withBar lbars) l\n\nshowsTreeHang :: Show a => Bool -> [String] -> Set a -> ShowS\nshowsTreeHang wide bars t\n  = case t of\n      Tip -> showsBars bars . showString "|\\n"\n      Bin _ x Tip Tip\n          -> showsBars bars . shows x . showString "\\n"\n      Bin _ x l r\n          -> showsBars bars . shows x . showString "\\n" .\n             showWide wide bars .\n             showsTreeHang wide (withBar bars) l .\n             showWide wide bars .\n             showsTreeHang wide (withEmpty bars) r\n\nshowWide :: Bool -> [String] -> String -> String\nshowWide wide bars\n  | wide      = showString (concat (reverse bars)) . showString "|\\n"\n  | otherwise = id\n\nshowsBars :: [String] -> ShowS\nshowsBars bars\n  = case bars of\n      [] -> id\n      _ : tl -> showString (concat (reverse tl)) . showString node\n\nnode :: String\nnode           = "+--"\n\nwithBar, withEmpty :: [String] -> [String]\nwithBar bars   = "|  ":bars\nwithEmpty bars = "   ":bars\n\n{--------------------------------------------------------------------\n  Assertions\n--------------------------------------------------------------------}\n-- | \\(O(n)\\). Test if the internal set structure is valid.\nvalid :: Ord a => Set a -> Bool\nvalid t\n  = balanced t && ordered t && validsize t\n\nordered :: Ord a => Set a -> Bool\nordered t\n  = bounded (const True) (const True) t\n  where\n    bounded lo hi t\'\n      = case t\' of\n          Tip         -> True\n          Bin _ x l r -> (lo x) && (hi x) && bounded lo (<x) l && bounded (>x) hi r\n\nbalanced :: Set a -> Bool\nbalanced t\n  = case t of\n      Tip         -> True\n      Bin _ _ l r -> (size l + size r <= 1 || (size l <= delta*size r && size r <= delta*size l)) &&\n                     balanced l && balanced r\n\nvalidsize :: Set a -> Bool\nvalidsize t\n  = (realsize t == Just (size t))\n  where\n    realsize t\'\n      = case t\' of\n          Tip          -> Just 0\n          Bin sz _ l r -> case (realsize l,realsize r) of\n                            (Just n,Just m)  | n+m+1 == sz  -> Just sz\n                            _                -> Nothing\n'