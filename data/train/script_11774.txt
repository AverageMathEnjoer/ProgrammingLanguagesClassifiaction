b'// UVa1336 Fixing the Great Wall\n// Rujia Liu\n#include<cstdio>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\n#include<cassert>\nusing namespace std;\n\nconst int maxn = 1000 + 5;\nconst double INF = 1e30;\n\nstruct Section {\n  double x, c, dt;\n  bool operator < (const Section& rhs) const {\n    return x < rhs.x;\n  }\n} s[maxn];\n\nint kase, n;\nint vis[maxn][maxn][2];\ndouble v, x, d[maxn][maxn][2];\ndouble psdt[maxn]; // prefix sum of dt\n\n// cost accumulated when walking from x1 and x2.\n// section[i~j] are already finished\ndouble cost(double x1, double x2, int i, int j) {\n  double finished_dt = 0;\n  assert(i <= j);\n  if(i >= 0 && j >= 0) finished_dt += psdt[j] - psdt[i-1];\n  return (psdt[n] - finished_dt) * fabs(x2 - x1) / v;\n}\n\ndouble dp(int i, int j, int p) {\n  if(i == 1 && j == n) return 0;\n  double& ans = d[i][j][p];\n  if(vis[i][j][p] == kase) return ans;\n  vis[i][j][p] = kase;\n\n  ans = INF;\n  double x = (p == 0 ? s[i].x : s[j].x);\n  if(i > 1) ans = min(ans, dp(i-1, j, 0) + cost(x, s[i-1].x, i, j));\n  if(j < n) ans = min(ans, dp(i, j+1, 1) + cost(x, s[j+1].x, i, j));\n  return ans;\n}\n\nint main() {\n  memset(vis, 0, sizeof(vis));\n  while(scanf("%d%lf%lf", &n, &v, &x) == 3 && n) {\n    ++kase;\n    double sumc = 0;\n    for(int i = 1; i <= n; i++) {\n      scanf("%lf%lf%lf", &s[i].x, &s[i].c, &s[i].dt);\n      sumc += s[i].c;\n    }\n    sort(s+1, s+n+1); // in increasing order of position\n\n    psdt[0] = 0;\n    for(int i = 1; i <= n; i++)\n      psdt[i] = psdt[i-1] + s[i].dt;\n\n    s[0].x = -INF;\n    s[n+1].x = INF;\n    double ans = INF;\n    for(int i = 1; i <= n+1; i++)\n      if(x > s[i-1].x && x < s[i].x) {\n        if(i > 1) ans = min(ans, dp(i-1, i-1, 0) + cost(x, s[i-1].x, -1, -1)); // move left\n        if(i <= n) ans = min(ans, dp(i, i, 0) + cost(x, s[i].x, -1, -1)); // move right\n        break;\n      }\n    printf("%.0lf\\n", floor(ans + sumc));\n  }\n  return 0;\n}\n'