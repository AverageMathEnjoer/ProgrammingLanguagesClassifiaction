b'{-# LANGUAGE NoImplicitPrelude #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n{-# LANGUAGE InstanceSigs #-}\n{-# LANGUAGE RebindableSyntax #-}\n\nmodule Course.Monad where\n\nimport Course.Applicative\nimport Course.Core\nimport Course.ExactlyOne\nimport Course.Functor\nimport Course.List\nimport Course.Optional\nimport qualified Prelude as P((=<<))\n\n-- | All instances of the `Monad` type-class must satisfy one law. This law\n-- is not checked by the compiler. This law is given as:\n--\n-- * The law of associativity\n--   `\xe2\x88\x80f g x. g =<< (f =<< x) \xe2\x89\x85 ((g =<<) . f) =<< x`\nclass Applicative f => Monad f where\n  -- Pronounced, bind.\n  (=<<) ::\n    (a -> f b)\n    -> f a\n    -> f b\n\ninfixr 1 =<<\n\n-- | Binds a function on the ExactlyOne monad.\n--\n-- >>> (\\x -> ExactlyOne(x+1)) =<< ExactlyOne 2\n-- ExactlyOne 3\ninstance Monad ExactlyOne where\n  (=<<) ::\n    (a -> ExactlyOne b)\n    -> ExactlyOne a\n    -> ExactlyOne b\n  (=<<) =\n    error "todo: Course.Monad (=<<)#instance ExactlyOne"\n\n-- | Binds a function on a List.\n--\n-- >>> (\\n -> n :. n :. Nil) =<< (1 :. 2 :. 3 :. Nil)\n-- [1,1,2,2,3,3]\ninstance Monad List where\n  (=<<) ::\n    (a -> List b)\n    -> List a\n    -> List b\n  (=<<) =\n    error "todo: Course.Monad (=<<)#instance List"\n\n-- | Binds a function on an Optional.\n--\n-- >>> (\\n -> Full (n + n)) =<< Full 7\n-- Full 14\ninstance Monad Optional where\n  (=<<) ::\n    (a -> Optional b)\n    -> Optional a\n    -> Optional b\n  (=<<) =\n    error "todo: Course.Monad (=<<)#instance Optional"\n\n-- | Binds a function on the reader ((->) t).\n--\n-- >>> ((*) =<< (+10)) 7\n-- 119\ninstance Monad ((->) t) where\n  (=<<) ::\n    (a -> ((->) t b))\n    -> ((->) t a)\n    -> ((->) t b)\n  (=<<) =\n    error "todo: Course.Monad (=<<)#instance ((->) t)"\n\n-- | Witness that all things with (=<<) and (<$>) also have (<*>).\n--\n-- >>> ExactlyOne (+10) <**> ExactlyOne 8\n-- ExactlyOne 18\n--\n-- >>> (+1) :. (*2) :. Nil <**> 1 :. 2 :. 3 :. Nil\n-- [2,3,4,2,4,6]\n--\n-- >>> Full (+8) <**> Full 7\n-- Full 15\n--\n-- >>> Empty <**> Full 7\n-- Empty\n--\n-- >>> Full (+8) <**> Empty\n-- Empty\n--\n-- >>> ((+) <**> (+10)) 3\n-- 16\n--\n-- >>> ((+) <**> (+5)) 3\n-- 11\n--\n-- >>> ((+) <**> (+5)) 1\n-- 7\n--\n-- >>> ((*) <**> (+10)) 3\n-- 39\n--\n-- >>> ((*) <**> (+2)) 3\n-- 15\n(<**>) ::\n  Monad f =>\n  f (a -> b)\n  -> f a\n  -> f b\n(<**>) =\n  error "todo: Course.Monad#(<**>)"\n\ninfixl 4 <**>\n\n-- | Flattens a combined structure to a single structure.\n--\n-- >>> join ((1 :. 2 :. 3 :. Nil) :. (1 :. 2 :. Nil) :. Nil)\n-- [1,2,3,1,2]\n--\n-- >>> join (Full Empty)\n-- Empty\n--\n-- >>> join (Full (Full 7))\n-- Full 7\n--\n-- >>> join (+) 7\n-- 14\njoin ::\n  Monad f =>\n  f (f a)\n  -> f a\njoin =\n  error "todo: Course.Monad#join"\n\n-- | Implement a flipped version of @(=<<)@, however, use only\n-- @join@ and @(<$>)@.\n-- Pronounced, bind flipped.\n--\n-- >>> ((+10) >>= (*)) 7\n-- 119\n(>>=) ::\n  Monad f =>\n  f a\n  -> (a -> f b)\n  -> f b\n(>>=) =\n  error "todo: Course.Monad#(>>=)"\n\ninfixl 1 >>=\n\n-- | Implement composition within the @Monad@ environment.\n-- Pronounced, kleisli composition.\n--\n-- >>> ((\\n -> n :. n :. Nil) <=< (\\n -> n+1 :. n+2 :. Nil)) 1\n-- [2,2,3,3]\n(<=<) ::\n  Monad f =>\n  (b -> f c)\n  -> (a -> f b)\n  -> a\n  -> f c\n(<=<) =\n  error "todo: Course.Monad#(<=<)"\n\ninfixr 1 <=<\n\n-----------------------\n-- SUPPORT LIBRARIES --\n-----------------------\n\ninstance Monad IO where\n  (=<<) =\n    (P.=<<)\n'