b'/*\n * Copyright 2013 - 2016 Mario Arias\n *\n * Licensed under the Apache License, Version 2.0 (the "License");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * \thttp://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an "AS IS" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.funktionale.playground.lz\n\nimport org.funktionale.collections.prependTo\nimport org.funktionale.memoization.memoize\nimport org.funktionale.option.Option\n\n/**\n * Created by IntelliJ IDEA.\n * @author Mario Arias\n * Date: 19/11/16\n * Time: 3:46 PM\n */\n\nfun <T> if2(cond: Boolean, onTrue: () -> T, onFalse: () -> T): T = if (cond) onTrue() else onFalse()\n\nfun main(args: Array<String>) {\n    val stream = Stream(*(1..1000).toList().toTypedArray())\n    val toList = timeElapsed {\n        stream.toList().forEach(::println)\n    }\n    val toFastList = timeElapsed {\n            stream.toFastList().forEach(::println)\n        }\n    println("toList = $toList")\n    println("toFastList = $toFastList")\n}\n\nfun timeElapsed(body: () -> Unit): Long {\n    val start = System.currentTimeMillis()\n    body()\n    val end = System.currentTimeMillis()\n    return end - start\n}\n\nsealed class Stream<out T : Any> {\n\n    fun headOption(): Option<T> = when (this) {\n        is Stream.Empty -> Option.None\n        is Stream.Cons -> Option.Some(head())\n    }\n\n    fun toList(): List<T> {\n        fun go(s: Stream<T>, acc: List<T>): List<T> = when (s) {\n            is Stream.Empty -> acc\n            is Stream.Cons -> go(s.tail(), s.head() prependTo acc)\n        }\n\n        return go(this, listOf()).reversed()\n    }\n\n    fun toFastList(): List<T>{\n        val buf = arrayListOf<T>()\n        fun go(s:Stream<T>):List<T> = when(s){\n            is Stream.Empty -> buf\n            is Stream.Cons -> {\n                buf.add(s.head())\n                go(s.tail())\n            }\n        }\n        return go(this)\n    }\n\n    class Empty : Stream<Nothing>()\n    class Cons<out T : Any>(val head: () -> T, val tail: () -> Stream<T>) : Stream<T>()\n    companion object {\n        fun <T : Any> empty(): Stream<T> = Empty()\n        fun <T : Any> cons(head: () -> T, tail: () -> Stream<T>): Stream<T> = Cons(head.memoize(), tail.memoize())\n        operator fun <T : Any> invoke(vararg t: T): Stream<T> {\n            return if (t.isEmpty()) {\n                empty()\n            } else {\n                cons({ t.first() }) { invoke(t.drop(1)) }\n            }\n        }\n\n        operator fun <T : Any> invoke(t: List<T>): Stream<T> {\n            return if (t.isEmpty()) {\n                empty()\n            } else {\n                cons({ t.first() }) { invoke(t.drop(1)) }\n            }\n        }\n\n    }\n}'