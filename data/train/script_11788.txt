b'{-# LANGUAGE BangPatterns #-}\n{-# LANGUAGE FlexibleContexts #-}\n\n-- UNFINISHED:\n\n-- This file represents rebecca\'s attempt to port the IPDPS\'09\n-- mergesort algorithm to Accelerate.\n\n--------------------------------------------------------------------------------\n\nimport Data.Array.Accelerate as Acc\nimport Data.Array.Accelerate.Interpreter (run)\nimport Prelude           hiding (zip, map, scanl, scanr, zipWith, fst, scanl1)\nimport Data.Array.IArray hiding ((!))\nimport Data.Array.Unboxed       (UArray, IArray)\nimport Data.Array.IO            (MArray, IOUArray)\nimport qualified Data.Array.MArray as M\n\n--import Control.Monad.Par.Meta.SharedMemoryAccelerate\n\nimport Control.Exception  (evaluate)\nimport System.Environment (getArgs)\nimport System.Random ()\nimport System.Random.MWC  (uniformR, withSystemRandom, Variate, GenIO)\n\n--------------------------------------------------------------------------------\n\n{-\nmain :: IO ()\nmain = withSystemRandom $ \\gen -> do\n    args <- getArgs\n    let n = case args of\n              []  -> 10000 :: Int\n              [n] -> read n\n              _   -> error "usage: mergesort_acc.exe [size]"\n\n    vec <- randomUArrayR (minBound,maxBound) gen n\n    vec\' <- convertUArray vec\n    print $ run $ sortAcc vec\'\n-}\n    {-\n    print $ run_par vec\' ()\n    where\n        run_par xs () = sortAcc xs\n        run_par xs () = runPar $ do\n            ans <- spawnAcc $ run_acc (xs :: Vector Int) ()\n            get ans\n        run_acc xs () = sortAcc xs\n        -}\n\n\n-- Generate a random, uniformly distributed vector of specified size over the\n-- range. From Hackage documentation on uniformR: For integral types the range is \n-- inclusive. For floating point numbers, the range (a,b] is used, if one ignores \n-- rounding errors.\nrandomUArrayR :: (Int, Int) -> GenIO -> Int -> IO (UArray Int Int)\nrandomUArrayR lim gen n = do\n    mu <- M.newArray_ (0,n-1) :: MArray IOUArray e IO => IO (IOUArray Int e)\n    let go !i | i < n     = uniformR lim gen >>= M.writeArray mu i >> go (i+1)\n              | otherwise = M.unsafeFreeze mu\n    go 0\n\n-- Convert an Unboxed Data.Array to an Accelerate Array\nconvertUArray :: UArray Int Int -> IO (Acc.Vector Int)\nconvertUArray v = \n    let arr = Acc.fromIArray v in\n        evaluate (arr `Acc.indexArray` (Z:.0)) >> return arr\n\n{- \n - Broad overview:\n -   1. Split data into k blocks\n -   2. Sort each block in parallel with bitonic sort\n -   3. Perform log k steps of pairwise merging\n -      a. To merge two blocks, sample several every 256th element from each \n -         block\n -      b. Compute the ranks of each sample in each array being merged:\n -          i.  the rank in its own array is just its index\n -          ii. the rank in the other array is found by binary search, which \n -              can be bounded using knowledge about samples chosen from that \n -              array\n -      c. These ranks define the boundaries of the sub-blocks of the final \n -         result\n -      d. Using this, compute the rank of each element, which will be the sum \n -         of its ranks in the two sub-blocks being merged\n -          i.  the rank in its own array is its index\n -          ii. the rank in the other array is found by binary search (using \n -              map)\n -      e. Scatter: each thread (from the previous step) writes out its \n -         element to the correct position. \n -\n - NOTE: The bin-searching can be expensive, so make sure it\'s done in on-chip \n -       shared memory (hence, the 256-element limit).\n -}\n-- reduce = foldl\n--sortAcc :: Elt a => Vector a -> Acc (Vector a)\n--sortAcc k arr = \n    \n--checkSorted :: Elt a => Acc (Vector a) -> Acc \ncheckSorted arr = Acc.fold (&&*) (lift True) $ Acc.zipWith (<=*) arr\' arr \n    where arr\' = Acc.prescanl (\\x -> id) (arr ! (index1 0)) arr\n\n{- Do a quicksort\n -}\nseqSort :: Acc (Vector a) -> Acc (Vector a)\nseqSort arr = undefined\n    where\n        -- copy pivot across with scanl\n        pivots = scanl const (arr ! 0) arr\n        -- array of 0s/1s, where 0 means < pivot, and 1 means >= pivot\n        flags = zipWith (\\x y -> (x <* y) ? (0,1)) arr pivots\n        -- use split to arrange numbers < pivot at the beginning, before\n        -- numbers >= pivot\n        pivotSort = split arr flags\n\nseqSort\' arr flags = undefined\n    where\n        -- array of pivot values copied across to their resp. segments\n        pivotArr = fstA pairPivotsFlags\n        -- set flags to 0 or 1, based on comparison to pivots in pivotArr\n        flags = zipWith (\\x y -> (x <* y) ? (0,1)) arr pivotArr\n        pairArrFlags   = zip arr flags\n        pairPivotsFlags = scanl1 f pairArrFlags\n        -- (Int, flag) -> (Int, flag) -> (Int, flag)\n        -- copy first value with a 1 flag across all 0 flags\n        -- when a new 1 flag is found, copy that value (flags are unchanged)\n        f = \\prev next -> let (a, flag) = unlift next\n                              (pa, pflag) = unlift prev in\n                            if flag ==* 0\n                            then (pa, flag)\n                            else (a, flag)\n        \n\n-- sort arr based on flags, where flags is an array of 0\'s and 1\'s, and\n-- numbers in arr will be sorted (stably) so that 0\'s will be at the beginning\n-- and 1\'s at the end\nsplit :: Acc (Vector a) -> Acc (Vector Bool) -> Acc (Vector a)\nsplit arr flags = permute const arr (\\i -> index1 (newInds ! i)) arr\n    where\n        -- choose from iup and idown, depending on whether flag is 0 or 1\n        choose f x = let (a,b) = unlift x in (f ==* 0) ? (a,b)\n        -- n = array size\n        n     = constant $ (arraySize $ arrayShape arr) - 1\n        -- indices for 0\'s (numbers < pivot)\n        idown = prescanl (+) 0 . map (xor 1) $ flags\n        -- indices for 1\'s (numbers >= pivot)\n        iup   = map (n -) . prescanr (+) 0   $ flags\n        -- calculate new indices, based on 0\'s and 1\'s\n        newInds = zipWith choose flags (zip idown iup) \n\nxor 1 1 = 0\nxor 0 1 = 1\nxor 1 0 = 1\nxor 0 0 = 0 \n\n-- Scatter: takes an array of elements and an array of their destination \n--   indices. Uses Acc.permute to move each element from the original array to \n--   the specified index.\nscatter :: Elt a => Acc (Vector Int) -> Acc (Vector a) -> Acc (Vector a)\nscatter ind orig = Acc.permute const orig fetchInd orig\n    where fetchInd x = index1 (ind ! x)\n\n\n{-\n-- I think we need Acc -> Acc type here, not Vec -> Acc because it\'s recursive\nmergesort :: Acc (Vector Int) -> Acc (Vector Int)\nmergesort xs = \n-}\n\n\n-- Simple Accelerate example, not used at all\n-- fold and zipWith are from Data.Array.Accelerate, not Prelude\ndotp :: Vector Float -> Vector Float -> Acc (Scalar Float)\ndotp xs ys = let xs\' = use xs\n                 ys\' = use ys in\n             fold (+) 0 (zipWith (*) xs\' ys\')\n\n\n'