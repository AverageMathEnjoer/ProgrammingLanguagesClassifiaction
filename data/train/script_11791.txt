b'{-# LANGUAGE OverloadedLists #-}\n\nmodule Dependencies (testDependencies) where\n\nimport Test.Tasty\nimport Test.Tasty.Runners\nimport Test.Tasty.Options\nimport Test.Tasty.HUnit\nimport Control.Concurrent\nimport Control.Concurrent.STM\nimport Text.Printf\nimport qualified Data.IntMap as IntMap\nimport Control.Monad\nimport Control.Exception\nimport Data.List (intercalate)\n\ntestDependencies :: TestTree\ntestDependencies = testGroup "Dependencies" $\n  generalDependencyTests ++\n  [circDepShow] ++\n  circDepTests ++\n  [resourceDependenciesTest]\n\n-- this is a dummy tree we use for testing\ntestTree :: DependencyType -> Bool -> TestTree\ntestTree deptype succeed =\n  testGroup "dependency test"\n    [ after deptype "Three" $ testCase "One" $ threadDelay 1e6\n    , testCase "Two" $ threadDelay 1e6\n    , testCase "Three" $ threadDelay 1e6 >> assertBool "fail" succeed\n    ]\n\ncircDepShow :: TestTree\ncircDepShow = testCase "show DependencyLoop" $\n  assertEqual\n    "dependency cycles should be shown on separate lines"\n    (show (DependencyLoop [[["a", "foo"], ["b"]], [["c"], ["d", "bar"]]]))\n    (intercalate "\\n"\n      [ "Test dependencies have cycles:"\n      , "- a.foo, b, a.foo"\n      , "- c, d.bar, c"\n      ])\n\n-- an example of a tree with circular dependencies\ncircDepTree1 :: TestTree\ncircDepTree1 = after AllSucceed "One" $ testCase "One" $ return ()\n\n-- another example of a tree with circular dependencies\ncircDepTree2 :: TestTree\ncircDepTree2 = testGroup "dependency test"\n  [ after AllFinish  "Three" $ testCase "One"   $ return ()\n  , after AllSucceed "One"   $ testCase "Two"   $ return ()\n  , after AllFinish  "Two"   $ testCase "Three" $ return ()\n  ]\n\ncircDepTests :: [TestTree]\ncircDepTests = do\n  (i, expectedCycles, tree) <-\n    zip3\n      [1,2]\n      [circDeps1, circDeps2]\n      [circDepTree1, circDepTree2]\n\n  return $ testCase ("Circular dependencies " ++ show i) $ do\n    r <- try $ launchTestTree mempty tree $ \\_ -> return $ \\_ -> return ()\n    case r of\n      Left (DependencyLoop cycles) ->\n        assertEqual "Unexpected cycles" expectedCycles cycles\n      _ -> assertFailure $ show r\n  where\n    circDeps1 = [[["One"]]]\n    circDeps2 = [[\n        ["dependency test", "One"]\n      , ["dependency test", "Three"]\n      , ["dependency test", "Two"]\n      ]]\n\n-- | Check the semantics of dependencies\ngeneralDependencyTests :: [TestTree]\ngeneralDependencyTests = do\n  succeed <- [True, False]\n  deptype <- [AllSucceed, AllFinish]\n  return $ testCase (printf "%-5s %s" (show succeed) (show deptype)) $ do\n    launchTestTree (singleOption $ NumThreads 2) (testTree deptype succeed) $ \\smap -> do\n      let all_tests@[one, two, three] = IntMap.elems smap\n      -- at first, no tests have finished yet\n      threadDelay 2e5\n      forM_ all_tests $ \\tv -> do\n        st <- atomically $ readTVar tv\n        assertBool (show st) $\n          case st of\n            Done {} -> False\n            _ -> True\n\n      -- after \xe2\x89\x88 1 second, the second and third tests will have finished;\n      -- the first will have not unless it is skipped because the first one\n      -- failed\n      threadDelay 11e5\n      st <- atomically $ readTVar three\n      assertBool (show st) $\n        case st of\n          Done r -> resultSuccessful r == succeed\n          _ -> False\n      st <- atomically $ readTVar two\n      assertBool (show st) $\n        case st of\n          Done r -> resultSuccessful r == True\n          _ -> False\n      st <- atomically $ readTVar one\n      assertBool (show st) $\n        case st of\n          Done _ | succeed || deptype == AllFinish -> False\n          _ -> True\n\n      -- after \xe2\x89\x88 2 seconds, the third test will have finished as well\n      threadDelay 1e6\n      st <- atomically $ readTVar one\n      assertBool (show st) $\n        case st of\n          Done r\n            | succeed || deptype == AllFinish -> resultSuccessful r\n            | otherwise ->\n                case resultOutcome r of\n                  Failure TestDepFailed -> True\n                  _ -> False\n          _ -> False\n\n      return $ const $ return ()\n\n-- | A regression test for the bug uncovered by Martijn Bastiaan.\nresourceDependenciesTest :: TestTree\nresourceDependenciesTest = testCase "Resource+dependencies interaction" $ do\n  launchTestTree (singleOption $ NumThreads 2) resDepTree $ \\smap -> do\n    let all_tests@[one, two] = IntMap.elems smap\n    -- at first, no tests have finished yet\n    threadDelay 2e5\n    forM_ all_tests $ \\tv -> do\n      st <- atomically $ readTVar tv\n      assertBool (show st) $\n        case st of\n          Done {} -> False\n          _ -> True\n\n    -- after 1 second, only the first test should be finished even though\n    -- we\'re running in 2 threads, as the second should have waited for the\n    -- first one.\n    threadDelay 1e6\n    st <- atomically $ readTVar one\n    assertBool (show st) $\n      case st of\n        Done r -> resultSuccessful r == True\n        _ -> False\n    st <- atomically $ readTVar two\n    assertBool (show st) $\n      case st of\n        Done _ -> False\n        _ -> True\n\n    return $ const $ return ()\n\n-- An example with resources and dependencies, from\n-- https://github.com/UnkindPartition/tasty/issues/48#issuecomment-430541146\nresDepTree :: TestTree\nresDepTree = testGroup "L1"\n  [ withResource (return ()) (const $ return ()) $ const $ testGroup "L2"\n    [ testCase "L2A" (threadDelay 1000000)\n    , after AllFinish "($(NF-0) == \\"L2A\\") && ($(NF-1) == \\"L2\\") && ($(NF-2) == \\"L1\\")" $\n        testCase "L2B" (threadDelay 1000000)\n    ]\n  ]\n'