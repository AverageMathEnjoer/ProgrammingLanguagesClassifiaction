b'{-# LANGUAGE CPP #-}\n{-# OPTIONS_GHC -O2 #-}\n\n-- Note: this is really a test/microbenchmark, not an example.  Should\n-- move it.\n\nimport Data.Int\nimport System.Environment\nimport GHC.Conc\nimport System.Random\nimport Control.Monad.Par.RNG\nimport Control.Monad.Par.Class as PC\nimport qualified Control.Monad.Trans.State.Strict as TS\n-- import qualified Control.Monad.Par.RNG_direct as Old\n\n#ifdef PARSCHED \nimport PARSCHED\n#else\n-- import Control.Monad.Par\n--import Control.Monad.Par.Scheds.ContFree\nimport Control.Monad.Par.Scheds.Direct\n#endif\n\n-- Define a RNG layer on top of whatever Par implementation was imported above:\ntype MyPar a = TS.StateT StdGen Par a\n\n-- type FibType = Int64\n\n-- Same recursion pattern as parfib but with extra cost at fork points\n-- to split the RNG.\nparRand :: Int -> MyPar Int\nparRand n | n < 2 = randInt\nparRand n = do \n    xf <- PC.spawn_$ parRand (n-1)\n    y  <-            parRand (n-2)\n    x  <- PC.get xf\n    return (x+y)\n\n-- This generates randoms on the way down as well as the leaves.\nparRand2 :: Int -> MyPar Int\nparRand2 n | n < 2 = randInt\nparRand2 n = do \n    extra <- randInt\n    xf <- PC.spawn_$ parRand2 (n-1)\n    y  <-            parRand2 (n-2)\n    x  <- PC.get xf\n    return (x+y+extra)\n\n\n-- parRand3 :: Int -> Old.Par Int\n-- parRand3 n | n < 2 = Old.randInt\n-- parRand3 n = do \n--     extra <- Old.randInt\n--     xf <- Old.spawn_$ parRand3 (n-1)\n--     y  <-             parRand3 (n-2)\n--     x  <- Old.get xf\n--     return (x+y+extra)\n\n\n-- This version maintains RNG state but doesn\'t actually generate randoms.\nparConst :: Int -> MyPar Int\nparConst n | n < 2 = return 1\nparConst n = do \n    xf <- PC.spawn_$ parConst (n-1)\n    y  <-            parConst (n-2)\n    x  <- PC.get xf\n    return (x+y)\n\nmain = do \n    args <- getArgs\n    let (version,size) = case args of \n            []      -> ("rand",20)\n            [n]     -> ("rand",read n)\n\t    [ver,n] -> (ver   ,read n)\n\n--    runParRNG$ parRand size \n    sum <- case version of \n            "const" -> runParRand runPar $ parConst size \n            "rand"  -> runParRand runPar $ parRand  size \n            "rand2" -> runParRand runPar $ parRand2 size \n--            "rand3" -> do g <- newStdGen\n--                          return (Old.runParRNG g $ parRand3 size)\n\n    putStrLn$ "Sum of ~2^"++show size++" random ints: "++ show sum\n\n\n{-\n\n[2011.11.29]\n\nTiming RNG.hs:\n On a 3.1ghz 4 core intel westmere:\n\n  threads input time-parRand time-parfib\n    1 34  8.3s   1.78s\n    2 34  4.4s   0.96s\n    4 34  2.4s   0.55s\n\nAnd the Const version:\n\n    1 34  6.2s\n    2 34  3.3s\n    4 34  1.7s\n\nAnd the Rand2 version:\n\n    1 34  10.0\n    2 34  5.3s\n    4 34  2.8s\n\nFor arguments sake I tested the old version as well (rand3):\n\n    1 34  8.3\n    2 34  4.8\n    4 34  2.6s\n    \n  (That was based on Trace, with Direct its a smidge better: 2.49s.)\n\nSo we\'re seeing about 5X overhead for splitting RNGs and for actually\ngenerating randoms (with not-super-efficient inefficient default\nSystem.Random).\n\nBUT, we haven\'t made the RNG state strict yet.\n\nDoing that yields a very slight improvement.  Using mode "rand":\n\n    1 34  7.99s\n    2 34  4.23s\n    4 34  2.27s\n\nHOWEVER - that\'s getting 37% productivity on only 4 threads!!!!\n\n -}\n'