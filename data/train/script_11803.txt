b'-- | Running tests\n{-# LANGUAGE ScopedTypeVariables, ExistentialQuantification, RankNTypes,\n             FlexibleContexts, CPP, DeriveDataTypeable, LambdaCase,\n             RecordWildCards #-}\nmodule Test.Tasty.Run\n  ( Status(..)\n  , StatusMap\n  , launchTestTree\n  , DependencyException(..)\n  ) where\n\nimport qualified Data.IntMap as IntMap\nimport qualified Data.Sequence as Seq\nimport qualified Data.Foldable as F\nimport Data.Int (Int64)\nimport Data.Maybe\nimport Data.List (intercalate)\nimport Data.Graph (SCC(..), stronglyConnComp)\nimport Data.Sequence (Seq, (|>), (<|))\nimport Data.Typeable\nimport Control.Monad (forever, guard, join, liftM)\nimport Control.Monad.IO.Class (liftIO)\nimport Control.Monad.Trans.Reader (ReaderT(..), local, ask)\nimport Control.Monad.Trans.Writer (execWriterT, tell)\nimport Control.Concurrent\nimport Control.Concurrent.STM\nimport Control.Concurrent.Async\nimport Control.Exception as E\nimport Control.Applicative\nimport Control.Arrow\nimport Data.Monoid (First(..))\nimport GHC.Conc (labelThread)\nimport Prelude  -- Silence AMP and FTP import warnings\n\n#ifdef MIN_VERSION_unbounded_delays\nimport Control.Concurrent.Timeout (timeout)\n#else\nimport System.Timeout (timeout)\n#endif\n\nimport Test.Tasty.Core\nimport Test.Tasty.Parallel\nimport Test.Tasty.Patterns\nimport Test.Tasty.Patterns.Types\nimport Test.Tasty.Options\nimport Test.Tasty.Options.Core\nimport Test.Tasty.Runners.Reducers\nimport Test.Tasty.Runners.Utils (timed, forceElements)\nimport Test.Tasty.Providers.ConsoleFormat (noResultDetails)\n\n-- | Current status of a test.\n--\n-- @since 0.1\ndata Status\n  = NotStarted\n    -- ^ test has not started running yet\n  | Executing Progress\n    -- ^ test is being run\n  | Done Result\n    -- ^ test finished with a given result\n  deriving\n  ( Show -- ^ @since 1.2\n  )\n\n-- | Mapping from test numbers (starting from 0) to their status variables.\n--\n-- This is what an ingredient uses to analyse and display progress, and to\n-- detect when tests finish.\n--\n-- @since 0.1\ntype StatusMap = IntMap.IntMap (TVar Status)\n\ndata Resource r\n  = NotCreated\n  | BeingCreated\n  | FailedToCreate SomeException\n  | Created r\n  | BeingDestroyed\n  | Destroyed\n\ninstance Show (Resource r) where\n  show r = case r of\n    NotCreated -> "NotCreated"\n    BeingCreated -> "BeingCreated"\n    FailedToCreate exn -> "FailedToCreate " ++ show exn\n    Created {} -> "Created"\n    BeingDestroyed -> "BeingDestroyed"\n    Destroyed -> "Destroyed"\n\ndata Initializer\n  = forall res . Initializer\n      (IO res)\n      (TVar (Resource res))\ndata Finalizer\n  = forall res . Finalizer\n      (res -> IO ())\n      (TVar (Resource res))\n      (TVar Int)\n\n-- | Execute a test taking care of resources\nexecuteTest\n  :: ((Progress -> IO ()) -> IO Result)\n    -- ^ the action to execute the test, which takes a progress callback as\n    -- a parameter\n  -> TVar Status -- ^ variable to write status to\n  -> Timeout -- ^ optional timeout to apply\n  -> Seq Initializer -- ^ initializers (to be executed in this order)\n  -> Seq Finalizer -- ^ finalizers (to be executed in this order)\n  -> IO ()\nexecuteTest action statusVar timeoutOpt inits fins = mask $ \\restore -> do\n  resultOrExn <- try $ restore $ do\n    -- N.B. this can (re-)throw an exception. It\'s okay. By design, the\n    -- actual test will not be run, then. We still run all the\n    -- finalizers.\n    --\n    -- There\'s no point to transform these exceptions to something like\n    -- EitherT, because an async exception (cancellation) can strike\n    -- anyway.\n    initResources\n\n    -- If all initializers ran successfully, actually run the test.\n    -- We run it in a separate thread, so that the test\'s exception\n    -- handler doesn\'t interfere with our timeout.\n    withAsync (action yieldProgress) $ \\asy -> do\n      labelThread (asyncThreadId asy) "tasty_test_execution_thread"\n      timed $ applyTimeout timeoutOpt $ do\n        r <- wait asy\n        -- Not only wait for the result to be returned, but make sure to\n        -- evalute it inside applyTimeout; see #280.\n        evaluate $\n          resultOutcome r `seq`\n          forceElements (resultDescription r) `seq`\n          forceElements (resultShortDescription r)\n        return r\n\n  -- no matter what, try to run each finalizer\n  mbExn <- destroyResources restore\n\n  atomically . writeTVar statusVar $ Done $\n    case resultOrExn <* maybe (Right ()) Left mbExn of\n      Left ex -> exceptionResult ex\n      Right (t,r) -> r { resultTime = t }\n\n  where\n    initResources :: IO ()\n    initResources =\n      F.forM_ inits $ \\(Initializer doInit initVar) -> do\n        join $ atomically $ do\n          resStatus <- readTVar initVar\n          case resStatus of\n            NotCreated -> do\n              -- signal to others that we\'re taking care of the resource\n              -- initialization\n              writeTVar initVar BeingCreated\n              return $\n                (do\n                  res <- doInit\n                  atomically $ writeTVar initVar $ Created res\n                 ) `E.catch` \\exn -> do\n                  atomically $ writeTVar initVar $ FailedToCreate exn\n                  throwIO exn\n            BeingCreated -> retry\n            Created {} -> return $ return ()\n            FailedToCreate exn -> return $ throwIO exn\n            -- If the resource is destroyed or being destroyed\n            -- while we\'re starting a test, the test suite is probably\n            -- shutting down. We are about to be killed.\n            -- (In fact we are probably killed already, so these cases are\n            -- unlikely to occur.)\n            -- In any case, the most sensible thing to do is to go to\n            -- sleep, awaiting our fate.\n            Destroyed      -> return $ sleepIndefinitely\n            BeingDestroyed -> return $ sleepIndefinitely\n\n    applyTimeout :: Timeout -> IO Result -> IO Result\n    applyTimeout NoTimeout a = a\n    applyTimeout (Timeout t tstr) a = do\n      let\n        timeoutResult =\n          Result\n            { resultOutcome = Failure $ TestTimedOut t\n            , resultDescription =\n                "Timed out after " ++ tstr\n            , resultShortDescription = "TIMEOUT"\n            , resultTime = fromIntegral t\n            , resultDetailsPrinter = noResultDetails\n            }\n      -- If compiled with unbounded-delays then t\' :: Integer, otherwise t\' :: Int\n      let t\' = fromInteger (min (max 0 t) (toInteger (maxBound :: Int64)))\n      fromMaybe timeoutResult <$> timeout t\' a\n\n    -- destroyResources should not be interrupted by an exception\n    -- Here\'s how we ensure this:\n    --\n    -- * the finalizer is wrapped in \'try\'\n    -- * async exceptions are masked by the caller\n    -- * we don\'t use any interruptible operations here (outside of \'try\')\n    destroyResources :: (forall a . IO a -> IO a) -> IO (Maybe SomeException)\n    destroyResources restore = do\n      -- remember the first exception that occurred\n      liftM getFirst . execWriterT . getTraversal $\n        flip F.foldMap fins $ \\fin@(Finalizer _ _ finishVar) ->\n          Traversal $ do\n            iAmLast <- liftIO $ atomically $ do\n              nUsers <- readTVar finishVar\n              let nUsers\' = nUsers - 1\n              writeTVar finishVar nUsers\'\n              return $ nUsers\' == 0\n\n            mbExcn <- liftIO $\n              if iAmLast\n              then destroyResource restore fin\n              else return Nothing\n\n            tell $ First mbExcn\n\n    -- The callback\n    -- Since this is not used yet anyway, disable for now.\n    -- I\'m not sure whether we should get rid of this altogether. For most\n    -- providers this is either difficult to implement or doesn\'t make\n    -- sense at all.\n    -- See also https://github.com/UnkindPartition/tasty/issues/33\n    yieldProgress _ = return ()\n\n-- | Dependencies of a test\ntype Dep = (DependencyType, Expr)\n\n-- | Traversal type used in \'createTestActions\'\ntype Tr = ReaderT (Path, [Dep]) IO (TestActionTree UnresolvedAction)\n\n-- | Exceptions related to dependencies between tests.\n--\n-- @since 1.2\nnewtype DependencyException\n  = DependencyLoop [[Path]]\n    -- ^ Test dependencies form cycles. In other words, test A cannot start\n    -- until test B finishes, and test B cannot start until test\n    -- A finishes. Field lists detected cycles.\n    --\n    -- @since 1.5\n  deriving (Typeable)\n\ninstance Show DependencyException where\n  show (DependencyLoop css) = "Test dependencies have cycles:\\n" ++ showCycles css\n    where\n      showCycles = intercalate "\\n" . map showCycle\n      showPath = intercalate "." . F.toList\n\n      -- For clarity in the error message, the first element is repeated at the end\n      showCycle []     = "- <empty cycle>"\n      showCycle (x:xs) = "- " ++ intercalate ", " (map showPath (x:xs ++ [x]))\n\ninstance Exception DependencyException\n\n-- | An action with meta information\ndata TestAction act = TestAction\n  { testAction :: act\n    -- ^ Some action, typically \'UnresolvedAction\', \'ResolvedAction\', or \'Action\'.\n  , testPath :: Path\n    -- ^ Path pointing to this action (a series of group names + a test name)\n  , testDeps :: [Dep]\n    -- ^ Dependencies introduced by AWK-like patterns\n  , testStatus :: TVar Status\n    -- ^ Status var that can be used to monitor test progress\n  }\n\n-- | A test that still needs to be given its resource initializers and finalizers\ntype UnresolvedAction = Seq Initializer -> Seq Finalizer -> IO ()\n\n-- | A test that, unlike \'UnresolvedAction\', has been given its initializers and\n-- finalizers.\ntype ResolvedAction = IO ()\n\n-- | Number of \'TAction\' leafs in a \'TestActionTree\'. Used to prevent repeated\n-- size calculations.\ntype Size = Int\n\n-- | Simplified version of \'TestTree\' that only includes the tests to be run (as\n-- a \'TestAction\') and the resources needed to run them (as \'Initializer\'s and\n-- \'Finalizer\'s).\ndata TestActionTree act\n  = TResource Initializer Finalizer (TestActionTree act)\n  | TGroup Size [TestActionTree act]\n  -- ^ Note the \'Size\' field of this constructor: it stores how many \'TAction\'s\n  -- are present in the tree. Functions using constructing this constructor\n  -- should take care, or use \'tGroup\' instead. If this constructor is ever\n  -- exported, we should probably move it to its own module and expose only a\n  -- smart constructor using pattern synonyms. For now, this seems more trouble\n  -- than it\'s worth, given the number of types it needs defined in this module.\n  | TAction (TestAction act)\n\n-- | Smart constructor for \'TGroup\'. Fills in \'Size\' field by summing the size\n-- of the given test trees.\ntGroup :: [TestActionTree act] -> TestActionTree act\ntGroup trees = TGroup (sum (map testActionTreeSize trees)) trees\n\n-- | Size of a \'TestActionTree\', i.e. the number of \'TAction\'s it contains.\ntestActionTreeSize :: TestActionTree act -> Int\ntestActionTreeSize = \\case\n  TResource _ _ tree -> testActionTreeSize tree\n  TGroup size _ -> size\n  TAction _ -> 1\n\n-- | Collect initializers and finalizers introduced by \'TResource\' and apply them\n-- to each action.\nresolveTestActions :: TestActionTree UnresolvedAction -> TestActionTree ResolvedAction\nresolveTestActions = go Seq.empty Seq.empty\n where\n  go inits fins = \\case\n    TResource ini fin tree ->\n      TResource ini fin $ go (inits |> ini) (fin <| fins) tree\n    TGroup size trees ->\n      TGroup size $ map (go inits fins) trees\n    TAction (TestAction {..})->\n      TAction $ TestAction { testAction = testAction inits fins, .. }\n\n-- | Turn a test tree into a list of actions to run tests coupled with\n-- variables to watch them. Additionally, a collection of finalizers is\n-- returned that can be used to clean up resources in case of unexpected\n-- events.\ncreateTestActions\n  :: OptionSet\n  -> TestTree\n  -> IO ([TestAction Action], Seq Finalizer)\ncreateTestActions opts0 tree = do\n  -- Folding the test tree reduces it to a \'TestActionTree\', which is a simplified\n  -- version of \'TestTree\' that only includes the tests to be run, resources needed\n  -- to run them, and meta information needed to watch test progress and calculate\n  -- dependencies in \'resolveDeps\'.\n  unresolvedTestTree :: TestActionTree UnresolvedAction <-\n    flip runReaderT (mempty :: (Path, [Dep])) $\n      foldTestTree0 (pure (tGroup [])) (TreeFold { .. }) opts0 tree\n\n  let\n    finalizers :: Seq Finalizer\n    finalizers = collectFinalizers unresolvedTestTree\n\n    tests :: [TestAction ResolvedAction]\n    tests = collectTests (resolveTestActions unresolvedTestTree)\n\n  case resolveDeps tests of\n    Right tests\' -> return (tests\', finalizers)\n    Left cycles  -> throwIO (DependencyLoop cycles)\n\n  where\n    -- * Functions used in \'TreeFold\'\n    foldSingle :: IsTest t => OptionSet -> TestName -> t -> Tr\n    foldSingle opts name test = do\n      testStatus <- liftIO $ newTVarIO NotStarted\n      (parentPath, testDeps) <- ask\n      let\n        testPath = parentPath |> name\n        testAction = executeTest (run opts test) testStatus (lookupOption opts)\n      pure $ TAction (TestAction {..})\n\n    foldResource :: OptionSet -> ResourceSpec a -> (IO a -> Tr) -> Tr\n    foldResource _opts (ResourceSpec doInit doRelease) a = do\n      initVar <- liftIO $ newTVarIO NotCreated\n      testTree <- a (getResource initVar)\n      finishVar <- liftIO $ newTVarIO (testActionTreeSize testTree)\n      let\n        ini = Initializer doInit initVar\n        fin = Finalizer doRelease initVar finishVar\n      pure $ TResource ini fin testTree\n\n    foldAfter :: OptionSet -> DependencyType -> Expr -> Tr -> Tr\n    foldAfter _opts depType pat = local (second ((depType, pat):))\n\n    foldGroup :: OptionSet -> TestName -> [Tr] -> Tr\n    foldGroup _opts name trees = tGroup <$> local (first (|> name)) (sequence trees)\n\n    -- * Utility functions\n    collectTests :: TestActionTree act -> [TestAction act]\n    collectTests = \\case\n      TResource _ _ t -> collectTests t\n      TGroup _ trees  -> concatMap collectTests trees\n      TAction action  -> [action]\n\n    collectFinalizers :: TestActionTree act -> Seq Finalizer\n    collectFinalizers = \\case\n      TResource _ fin t -> collectFinalizers t |> fin\n      TGroup _ trees    -> mconcat (map collectFinalizers trees)\n      TAction _         -> mempty\n\n-- | Take care of the dependencies.\n--\n-- Return \'Left\' if there is a dependency cycle, containing the detected cycles.\nresolveDeps\n  :: [TestAction ResolvedAction]\n  -> Either [[Path]] [TestAction Action]\nresolveDeps tests = checkCycles $ do\n  TestAction { testAction=run_test, .. } <- tests\n\n  let\n    -- Note: Duplicate dependencies may arise if the same test name matches\n    -- multiple patterns. It\'s not clear that removing them is worth the\n    -- trouble; might consider this in the future.\n    deps\' :: [(DependencyType, TVar Status, Path)]\n    deps\' = do\n      (deptype, depexpr) <- testDeps\n      TestAction { testStatus = testStatus1, testPath = testPath1 } <- tests\n      guard $ exprMatches depexpr testPath1\n      return (deptype, testStatus1, testPath1)\n\n    getStatus :: STM ActionStatus\n    getStatus = foldr\n      (\\(deptype, statusvar, _) k -> do\n        status <- readTVar statusvar\n        case status of\n          Done result\n            | deptype == AllFinish || resultSuccessful result -> k\n            | otherwise -> return ActionSkip\n          _ -> return ActionWait\n      )\n      (return ActionReady)\n      deps\'\n  let\n    dep_paths = map (\\(_, _, path) -> path) deps\'\n    action = Action\n      { actionStatus = getStatus\n      , actionRun = run_test\n      , actionSkip = writeTVar testStatus $ Done $ Result\n          -- See Note [Skipped tests]\n          { resultOutcome = Failure TestDepFailed\n          , resultDescription = ""\n          , resultShortDescription = "SKIP"\n          , resultTime = 0\n          , resultDetailsPrinter = noResultDetails\n          }\n      }\n  return (TestAction { testAction = action, .. }, (testPath, dep_paths))\n\ncheckCycles :: Ord b => [(a, (b, [b]))] -> Either [[b]] [a]\ncheckCycles tests = do\n  let\n    result = fst <$> tests\n    graph = [ (v, v, vs) | (v, vs) <- snd <$> tests ]\n    sccs = stronglyConnComp graph\n    cycles =\n      flip mapMaybe sccs $ \\case\n        AcyclicSCC{} -> Nothing\n        CyclicSCC vs -> Just vs\n\n  case cycles of\n    [] -> Right result\n    _  -> Left cycles\n\n-- | Used to create the IO action which is passed in a WithResource node\ngetResource :: TVar (Resource r) -> IO r\ngetResource var =\n  atomically $ do\n    rState <- readTVar var\n    case rState of\n      Created r -> return r\n      Destroyed -> throwSTM UseOutsideOfTest\n      _ -> throwSTM $ unexpectedState "getResource" rState\n\n-- | Run a resource finalizer.\n--\n-- This function is called from two different places:\n--\n-- 1. A test thread, which is the last one to use the resource.\n-- 2. The main thread, if an exception (e.g. Ctrl-C) is received.\n--\n-- Therefore, it is possible that this function is called multiple\n-- times concurrently on the same finalizer.\n--\n-- This function should be run with async exceptions masked,\n-- and the restore function should be passed as an argument.\ndestroyResource :: (forall a . IO a -> IO a) -> Finalizer -> IO (Maybe SomeException)\ndestroyResource restore (Finalizer doRelease stateVar _) = join . atomically $ do\n  rState <- readTVar stateVar\n  case rState of\n    Created res -> do\n      writeTVar stateVar BeingDestroyed\n      return $\n        (either Just (const Nothing)\n          <$> try (restore $ doRelease res))\n          <* atomically (writeTVar stateVar Destroyed)\n    BeingCreated   -> retry\n    -- If the resource is being destroyed, wait until it is destroyed.\n    -- This is so that we don\'t start destroying the next resource out of\n    -- order.\n    BeingDestroyed -> retry\n    NotCreated -> do\n      -- prevent the resource from being created by a competing thread\n      writeTVar stateVar Destroyed\n      return $ return Nothing\n    FailedToCreate {} -> return $ return Nothing\n    Destroyed         -> return $ return Nothing\n\n-- | Start running the tests (in background, in parallel) and pass control\n-- to the callback.\n--\n-- Once the callback returns, stop running the tests.\n--\n-- The number of test running threads is determined by the \'NumThreads\'\n-- option.\n--\n-- @since 0.10\nlaunchTestTree\n  :: OptionSet\n  -> TestTree\n  -> (StatusMap -> IO (Time -> IO a))\n    -- ^ A callback. First, it receives the \'StatusMap\' through which it\n    -- can observe the execution of tests in real time. Typically (but not\n    -- necessarily), it waits until all the tests are finished.\n    --\n    -- After this callback returns, the test-running threads (if any) are\n    -- terminated and all resources acquired by tests are released.\n    --\n    -- The callback must return another callback (of type @\'Time\' -> \'IO\'\n    -- a@) which additionally can report and/or record the total time\n    -- taken by the test suite. This time includes the time taken to run\n    -- all resource initializers and finalizers, which is why it is more\n    -- accurate than what could be measured from inside the first callback.\n  -> IO a\nlaunchTestTree opts tree k0 = do\n  (testActions, fins) <- createTestActions opts tree\n  let NumThreads numTheads = lookupOption opts\n  (t,k1) <- timed $ do\n     abortTests <- runInParallel numTheads (testAction <$> testActions)\n     (do let smap = IntMap.fromList $ zip [0..] (testStatus <$> testActions)\n         k0 smap)\n      `finallyRestore` \\restore -> do\n         -- Tell all running tests to wrap up.\n         abortTests\n         -- Destroy all allocated resources in the case they didn\'t get\n         -- destroyed by their tests. (See #75.)\n         F.mapM_ (destroyResource restore) fins\n         -- Wait until all resources are destroyed. (Specifically, those\n         -- that were being destroyed by their tests, not those that were\n         -- destroyed by destroyResource above.)\n         restore $ waitForResources fins\n  k1 t\n  where\n    alive :: Resource r -> Bool\n    alive r = case r of\n      NotCreated -> False\n      BeingCreated -> True\n      FailedToCreate {} -> False\n      Created {} -> True\n      BeingDestroyed -> True\n      Destroyed -> False\n\n    waitForResources fins = atomically $\n      F.forM_ fins $ \\(Finalizer _ rvar _) -> do\n        res <- readTVar rvar\n        check $ not $ alive res\n\nunexpectedState :: String -> Resource r -> SomeException\nunexpectedState where_ r = toException $ UnexpectedState where_ (show r)\n\nsleepIndefinitely :: IO ()\nsleepIndefinitely = forever $ threadDelay (10^(7::Int))\n\n-- | Like \'finally\' (which also masks its finalizers), but pass the restore\n-- action to the finalizer.\nfinallyRestore\n  :: IO a\n    -- ^ computation to run first\n  -> ((forall c . IO c -> IO c) -> IO b)\n    -- ^ computation to run afterward (even if an exception was raised)\n  -> IO a\n    -- ^ returns the value from the first computation\na `finallyRestore` sequel =\n  mask $ \\restore -> do\n    r <- restore a `onException` sequel restore\n    _ <- sequel restore\n    return r\n'