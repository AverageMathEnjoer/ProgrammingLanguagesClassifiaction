b'/*\n    SPDX-FileCopyrightText: 2017-2019 Milian Wolff <mail@milianw.de>\n\n    SPDX-License-Identifier: LGPL-2.1-or-later\n*/\n\n#include "util.h"\n\n#include <QString>\n\n#include <resultdata.h>\n\n#include <KFormat>\n#include <KLocalizedString>\n\nnamespace {\nconst KFormat& format()\n{\n    static const KFormat format;\n    return format;\n}\n}\n\nQString Util::basename(const QString& path)\n{\n    int idx = path.lastIndexOf(QLatin1Char(\'/\'));\n    return path.mid(idx + 1);\n}\n\nQString Util::formatString(const QString& input)\n{\n    return input.isEmpty() ? i18n("??") : input;\n}\n\nQString Util::formatTime(qint64 ms)\n{\n    auto format = [](quint64 fragment, int precision) -> QString {\n        return QString::number(fragment).rightJustified(precision, QLatin1Char(\'0\'));\n    };\n\n    if (std::abs(ms) < 1000) {\n        QString ret = QString::number(ms) + QLatin1String("ms");\n    }\n\n    const auto isNegative = ms < 0;\n    if (isNegative)\n        ms = -ms;\n    qint64 totalSeconds = ms / 1000;\n    ms = ms % 1000;\n    qint64 days = totalSeconds / 60 / 60 / 24;\n    qint64 hours = (totalSeconds / 60 / 60) % 24;\n    qint64 minutes = (totalSeconds / 60) % 60;\n    qint64 seconds = totalSeconds % 60;\n\n    auto optional = [](quint64 fragment, const char* unit) -> QString {\n        if (fragment > 0)\n            return QString::number(fragment) + QLatin1String(unit);\n        return QString();\n    };\n\n    QString ret = optional(days, "d") + optional(hours, "h") + optional(minutes, "min");\n    const auto showMs = ret.isEmpty();\n    ret += format(seconds, 2);\n    if (showMs)\n        ret += QLatin1Char(\'.\') + format(showMs ? ms : 0, 3);\n    ret += QLatin1Char(\'s\');\n    if (isNegative)\n        ret.prepend(QLatin1Char(\'-\'));\n    return ret;\n}\n\nQString Util::formatBytes(qint64 bytes)\n{\n    auto ret = format().formatByteSize(bytes, 1, KFormat::MetricBinaryDialect);\n    // remove spaces, otherwise HTML might break between the unit and the cost\n    // note that we also don\'t add a space before our time units above\n    ret.remove(QLatin1Char(\' \'));\n    return ret;\n}\n\nQString Util::formatCostRelative(qint64 selfCost, qint64 totalCost, bool addPercentSign)\n{\n    if (!totalCost) {\n        return QString();\n    }\n\n    auto ret = QString::number(static_cast<double>(selfCost) * 100. / totalCost, \'g\', 3);\n    if (addPercentSign) {\n        ret.append(QLatin1Char(\'%\'));\n    }\n    return ret;\n}\n\nQString Util::formatTooltip(const Symbol& symbol, const AllocationData& costs, const ResultData& resultData)\n{\n    const auto& totalCosts = resultData.totalCosts();\n\n    auto toolTip = Util::toString(symbol, resultData, Util::Long);\n\n    auto formatCost = [&](const QString& label, int64_t AllocationData::*member) -> QString {\n        const auto cost = costs.*member;\n        const auto total = totalCosts.*member;\n        if (!total) {\n            return QString();\n        }\n\n        return QLatin1String("<hr/>")\n            + i18n("%1: %2<br/>&nbsp;&nbsp;%4% out of %3 total", label, cost, total,\n                   Util::formatCostRelative(cost, total));\n    };\n\n    toolTip += formatCost(i18n("Peak"), &AllocationData::peak);\n    toolTip += formatCost(i18n("Leaked"), &AllocationData::leaked);\n    toolTip += formatCost(i18n("Allocations"), &AllocationData::allocations);\n    toolTip += formatCost(i18n("Temporary Allocations"), &AllocationData::temporary);\n    return QString(QLatin1String("<qt>") + toolTip + QLatin1String("</qt>"));\n}\n\nQString Util::formatTooltip(const Symbol& symbol, const AllocationData& selfCosts, const AllocationData& inclusiveCosts,\n                            const ResultData& resultData)\n{\n    const auto& totalCosts = resultData.totalCosts();\n    auto toolTip = Util::toString(symbol, resultData, Util::Long);\n\n    auto formatCost = [&](const QString& label, int64_t AllocationData::*member) -> QString {\n        const auto selfCost = selfCosts.*member;\n        const auto inclusiveCost = inclusiveCosts.*member;\n        const auto total = totalCosts.*member;\n        if (!total) {\n            return QString();\n        }\n\n        return QLatin1String("<hr/>")\n            + i18n("%1 (self): %2<br/>&nbsp;&nbsp;%4% out of %3 total", label, selfCost, total,\n                   Util::formatCostRelative(selfCost, total))\n            + QLatin1String("<br/>")\n            + i18n("%1 (inclusive): %2<br/>&nbsp;&nbsp;%4% out of %3 total", label, inclusiveCost, total,\n                   Util::formatCostRelative(inclusiveCost, total));\n    };\n\n    toolTip += formatCost(i18n("Peak"), &AllocationData::peak);\n    toolTip += formatCost(i18n("Leaked"), &AllocationData::leaked);\n    toolTip += formatCost(i18n("Allocations"), &AllocationData::allocations);\n    toolTip += formatCost(i18n("Temporary Allocations"), &AllocationData::temporary);\n    return QString(QLatin1String("<qt>") + toolTip + QLatin1String("</qt>"));\n}\n\nQString Util::formatTooltip(const FileLine& location, const AllocationData& selfCosts,\n                            const AllocationData& inclusiveCosts, const ResultData& resultData)\n{\n    QString toolTip = toString(location, resultData, Util::Long).toHtmlEscaped();\n    const auto& totalCosts = resultData.totalCosts();\n\n    auto formatCost = [&](const QString& label, int64_t AllocationData::*member) -> QString {\n        const auto selfCost = selfCosts.*member;\n        const auto inclusiveCost = inclusiveCosts.*member;\n        const auto total = totalCosts.*member;\n        if (!total) {\n            return QString();\n        }\n\n        return QLatin1String("<hr/>")\n            + i18n("%1 (self): %2<br/>&nbsp;&nbsp;%4% out of %3 total", label, selfCost, total,\n                   Util::formatCostRelative(selfCost, total))\n            + QLatin1String("<br/>")\n            + i18n("%1 (inclusive): %2<br/>&nbsp;&nbsp;%4% out of %3 total", label, inclusiveCost, total,\n                   Util::formatCostRelative(inclusiveCost, total));\n    };\n\n    toolTip += formatCost(i18n("Peak"), &AllocationData::peak);\n    toolTip += formatCost(i18n("Leaked"), &AllocationData::leaked);\n    toolTip += formatCost(i18n("Allocations"), &AllocationData::allocations);\n    toolTip += formatCost(i18n("Temporary Allocations"), &AllocationData::temporary);\n    return QString(QLatin1String("<qt>") + toolTip + QLatin1String("</qt>"));\n}\n\nQString Util::toString(const Symbol& symbol, const ResultData& resultData, FormatType formatType)\n{\n    const auto& binaryPath = resultData.string(symbol.moduleId);\n    const auto binaryName = Util::basename(binaryPath);\n    switch (formatType) {\n    case Long:\n        return i18n("symbol: <tt>%1</tt><br/>binary: <tt>%2 (%3)</tt>",\n                    resultData.string(symbol.functionId).toHtmlEscaped(), binaryName.toHtmlEscaped(),\n                    binaryPath.toHtmlEscaped());\n    case Short:\n        return i18nc("%1: function name, %2: binary basename", "%1 in %2", resultData.string(symbol.functionId),\n                     Util::basename(resultData.string(symbol.moduleId)));\n    }\n    Q_UNREACHABLE();\n}\n\nQString Util::toString(const FileLine& location, const ResultData& resultData, FormatType formatType)\n{\n    auto file = resultData.string(location.fileId);\n    switch (formatType) {\n    case Long:\n        break;\n    case Short:\n        file = Util::basename(file);\n        break;\n    }\n\n    return file.isEmpty() ? QStringLiteral("??") : (file + QLatin1Char(\':\') + QString::number(location.line));\n}\n\nconst QString& Util::unresolvedFunctionName()\n{\n    static QString msg = i18n("<unresolved function>");\n    return msg;\n}\n'