b'{-# LANGUAGE CPP #-}\n\n-- What is the overhead of spawning a single operation on the GPU?\n-- In this microbenchmark we measure it.\n\nimport Control.Monad.Par.Accelerate\nimport Control.Monad.Par.Meta.AccSMP (runPar, get)\n\n-- import System.Random.MWC\nimport Data.Array.Unboxed\nimport qualified Data.Array.Accelerate as A\nimport Data.Array.Accelerate (Z, (:.))\n\nimport qualified Data.Array.Accelerate.IO as IO\n\nimport Data.Time.Clock.POSIX (getPOSIXTime)\nimport Control.Exception (evaluate)\n\n#ifdef USECUDA\n#warning USING REAL CUDA\nimport Foreign.CUDA.Driver.Device (initialise)\nimport qualified Data.Array.Accelerate.CUDA        as Run\n#else\nimport qualified Data.Array.Accelerate.Interpreter as Run\n#endif\n\n--------------------------------------------------------------------------------\n-- Helpers:\n\n\n--------------------------------------------------------------------------------\n\n-- Dot product\n-- -----------\ndotpAcc :: A.Vector Float -> A.Vector Float -> A.Acc (A.Scalar Float)\ndotpAcc xs ys\n  = let\n      xs\' = A.use xs\n      ys\' = A.use ys\n    in\n    A.fold (+) 0 (A.zipWith (*) xs\' ys\')\n\nmain = do \n  putStrLn "Measuring one roundtrip through the GPU:"\n  \n#ifdef USECUDA\n  start <- getPOSIXTime\n  initialise []\n  end <- getPOSIXTime\n  putStrLn$ "GPU Initialization took "++show (end-start)\n#endif\n\n  let \n      v1 = A.fromList (A.Z A.:. (5::Int)) [1..5::Float]\n      v2 = A.fromList (A.Z A.:. (5::Int)) [6..10::Float]\n      acc = dotpAcc v1 v2    \n      \n      runone = do     \n        start <- getPOSIXTime\n        x <- evaluate$ runPar $ runAccWith Run.run acc \n        putStrLn$ "Result "++show x\n        end <- getPOSIXTime\n        return (end-start)\n\n  x<-runone; putStrLn$ "First execution took: "++show x\n\n  ls <- sequence (replicate 10 runone)\n  putStrLn$ "Next ten took: "++show (sum ls)\n'