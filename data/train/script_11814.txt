b'// I2Cdev library collection - L3G4200D I2C device class\n// Based on STMicroelectronics L3G4200D datasheet rev. 3, 12/2010\n// 7/31/2013 by Jonathan Arnett <j3rn@j3rn.com>\n// Updates should (hopefully) always be available at https://github.com/jrowberg/i2cdevlib\n//\n// Changelog:\n//     2013-07-31 - initial release\n\n/* ============================================\nI2Cdev device library code is placed under the MIT license\nCopyright (c) 2011 Jonathan Arnett, Jeff Rowberg\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the "Software"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n===============================================\n*/\n\n#include "L3G4200D.h"\n\n/** Default constructor, uses default I2C address.\n * @see L3G4200D_DEFAULT_ADDRESS\n */\nL3G4200D::L3G4200D() {\n    devAddr = L3G4200D_DEFAULT_ADDRESS;\n}\n\n/** Specific address constructor.\n * @param address I2C address\n * @see L3G4200D_DEFAULT_ADDRESS\n * @see L3G4200D_ADDRESS\n */\nL3G4200D::L3G4200D(uint8_t address) {\n    devAddr = address;\n}\n\n/** Power on and prepare for general usage.\n * All values are defaults except for the power on bit in CTRL_REG_1\n * @see L3G4200D_RA_CTRL_REG1\n * @see L3G4200D_RA_CTRL_REG2\n * @see L3G4200D_RA_CTRL_REG3\n * @see L3G4200D_RA_CTRL_REG4\n * @see L3G4200D_RA_CTRL_REG5\n */\nvoid L3G4200D::initialize() {\n\tI2Cdev::writeByte(devAddr, L3G4200D_RA_CTRL_REG1, 0b00001111);\n    I2Cdev::writeByte(devAddr, L3G4200D_RA_CTRL_REG2, 0b00000000);\n    I2Cdev::writeByte(devAddr, L3G4200D_RA_CTRL_REG3, 0b00000000);\n    I2Cdev::writeByte(devAddr, L3G4200D_RA_CTRL_REG4, 0b00000000);\n    I2Cdev::writeByte(devAddr, L3G4200D_RA_CTRL_REG5, 0b00000000);\n}\n\n/** Verify the I2C connection.\n * Make sure the device is connected and responds as expected.\n * @return True if connection is valid, false otherwise\n */\nbool L3G4200D::testConnection() {\n    return getDeviceID() == 0b11010011;\n}\n\n// WHO_AM_I register, read-only\n\n/** Get the Device ID.\n * The WHO_AM_I register holds the device\'s id\n * @return Device ID (should be 0b11010011, 109, 0x69)\n * @see L3G4200D_RA_WHO_AM_I\n */\nuint8_t L3G4200D::getDeviceID() {\n    I2Cdev::readByte(devAddr, L3G4200D_RA_WHO_AM_I, buffer);\n    return buffer[0];\n}\n\n// CTRL_REG1 register, r/w\n\n/** Set the output data rate\n * @param rate The new data output rate (can be 100, 200, 400, or 800)\n * @see L3G4200D_RA_CTRL_REG1\n * @see L3G4200D_ODR_BIT\n * @see L3G4200D_ODR_LENGTH\n * @see L3G4200D_RATE_100\n * @see L3G4200D_RATE_200\n * @see L3G4200D_RATE_400\n * @see L3G4200D_RATE_800\n */\nvoid L3G4200D::setOutputDataRate(uint16_t rate) {\n\tuint8_t writeVal;\n\t\n\tif (rate == 100) {\n\t\twriteVal = L3G4200D_RATE_100;\n\t} else if (rate == 200) {\n\t\twriteVal = L3G4200D_RATE_200;\n\t} else if (rate == 400) {\n\t\twriteVal = L3G4200D_RATE_400;\n\t} else {\n\t\twriteVal = L3G4200D_RATE_800;\n\t}\n\t\n\tI2Cdev::writeBits(devAddr, L3G4200D_RA_CTRL_REG1, L3G4200D_ODR_BIT,\n\t\tL3G4200D_ODR_LENGTH, writeVal); \n}\n\n/** Get the current output data rate\n * @return Current data output rate\n * @see L3G4200D_RA_CTRL_REG1\n * @see L3G4200D_ODR_BIT\n * @see L3G4200D_ODR_LENGTH\n * @see L3G4200D_RATE_100\n * @see L3G4200D_RATE_200\n * @see L3G4200D_RATE_400\n * @see L3G4200D_RATE_800\n */\nuint16_t L3G4200D::getOutputDataRate() {\n\tI2Cdev::readBits(devAddr, L3G4200D_RA_CTRL_REG1, L3G4200D_ODR_BIT, \n\t\tL3G4200D_ODR_LENGTH, buffer);\n\tuint8_t rate = buffer[0];\n\n\tif (rate == L3G4200D_RATE_100) {\n\t\treturn 100;\n\t} else if (rate == L3G4200D_RATE_200) {\n\t\treturn 200;\n\t} else if (rate == L3G4200D_RATE_400) {\n\t\treturn 400;\n\t}\n\treturn 800;\n}\n\n/** Set the bandwidth cut-off mode\n * @param mode The new bandwidth cut-off mode\n * @see L3G4200D_RA_CTRL_REG1\n * @see L3G4200D_BW_BIT\n * @see L3G4200D_BW_LENGTH\n * @see L3G4200D_BW_LOW\n * @see L3G4200D_BW_MED_LOW\n * @see L3G4200D_BW_MED_HIGH\n * @see L3G4200D_BW_HIGH\n */\nvoid L3G4200D::setBandwidthCutOffMode(uint8_t mode) {\n\tI2Cdev::writeBits(devAddr, L3G4200D_RA_CTRL_REG1, L3G4200D_BW_BIT, \n\t\tL3G4200D_BW_LENGTH, mode);\n}\n\n/** Get the current bandwidth cut-off mode\n * @return Current bandwidth cut off mode\n * @see L3G4200D_RA_CTRL_REG1\n * @see L3G4200D_BW_BIT\n * @see L3G4200D_BW_LENGTH\n * @see L3G4200D_BW_LOW\n * @see L3G4200D_BW_MED_LOW\n * @see L3G4200D_BW_MED_HIGH\n * @see L3G4200D_BW_HIGH\n */\nuint8_t L3G4200D::getBandwidthCutOffMode() {\n\tI2Cdev::readBits(devAddr, L3G4200D_RA_CTRL_REG1, L3G4200D_BW_BIT, \n\t\tL3G4200D_BW_LENGTH, buffer);\n\treturn buffer[0];\n}\n\n/** Gets the current bandwidth cutoff based on ODR and BW\n * @return Float value of the bandwidth cut off\n * @see L3G4200D_RA_CTRL_REG1\n * @see L3G4200D_ODR_BIT\n * @see L3G4200D_ODR_LENGTH\n * @see L3G4200D_RATE_100\n * @see L3G4200D_RATE_200\n * @see L3G4200D_RATE_400\n * @see L3G4200D_RATE_800\n * @see L3G4200D_BW_BIT\n * @see L3G4200D_BW_LENGTH\n * @see L3G4200D_BW_LOW\n * @see L3G4200D_BW_MED_LOW\n * @see L3G4200D_BW_MED_HIGH\n * @see L3G4200D_BW_HIGH\n */\nfloat L3G4200D::getBandwidthCutOff() {\n\tuint16_t dataRate = getOutputDataRate();\n\tuint8_t bandwidthMode = getBandwidthCutOffMode();\n\n\tif (dataRate == 100) {\n\t\tif (bandwidthMode == L3G4200D_BW_LOW) {\n\t\t\treturn 12.5;\n\t\t} else {\n\t\t\treturn 25.0;\n\t\t}\n\t} else if (dataRate == 200) {\n\t\tif (bandwidthMode == L3G4200D_BW_LOW) {\n\t\t\treturn 12.5;\n\t\t} else if (bandwidthMode == L3G4200D_BW_MED_LOW) {\n\t\t\treturn 25.0;\n\t\t} else if (bandwidthMode == L3G4200D_BW_MED_HIGH) {\n\t\t\treturn 50.0;\n\t\t} else {\n\t\t\treturn 70.0;\n\t\t}\n\t} else if (dataRate == 400) {\n\t\tif (bandwidthMode == L3G4200D_BW_LOW) {\n\t\t\treturn 20.0;\n\t\t} else if (bandwidthMode == L3G4200D_BW_MED_LOW) {\n\t\t\treturn 25.0;\n\t\t} else if (bandwidthMode == L3G4200D_BW_MED_HIGH) {\n\t\t\treturn 50.0;\n\t\t} else {\n\t\t\treturn 110.0;\n\t\t}\n\t} else {\n\t\tif (bandwidthMode == L3G4200D_BW_LOW) {\n\t\t\treturn 30.0;\n\t\t} else if (bandwidthMode == L3G4200D_BW_MED_LOW) {\n\t\t\treturn 35.0;\n\t\t} else if (bandwidthMode == L3G4200D_BW_MED_HIGH) {\n\t\t\treturn 50.0;\n\t\t} else {\n\t\t\treturn 110.0;\n\t\t}\n\t}\n}\n\n/** Set power on or off\n * @param enabled The new power setting (true for on, false for off)\n * @see L3G4200D_RA_CTRL_REG1\n * @see L3G4200D_PD_BIT\n */\nvoid L3G4200D::setPowerOn(bool on) {\n\tI2Cdev::writeBit(devAddr, L3G4200D_RA_CTRL_REG1, L3G4200D_PD_BIT, on);\n}\n\n/** Get the current power state\n * @return Powered on state (true for on, false for off)\n * @see L3G4200D_RA_CTRL_REG1\n * @see L3G4200D_PD_BIT\n */\nbool L3G4200D::getPowerOn() {\n\tI2Cdev::readBit(devAddr, L3G4200D_RA_CTRL_REG1, L3G4200D_PD_BIT, buffer);\n\treturn buffer[0];\n}\n\n/** Enables or disables the ability to get Z data\n * @param enabled The new enabled state of the Z axis\n * @see L3G4200D_RA_CTRL_REG1\n * @see L3G4200D_ZEN_BIT\n */\nvoid L3G4200D::setZEnabled(bool enabled) {\n\tI2Cdev::writeBit(devAddr, L3G4200D_RA_CTRL_REG1, L3G4200D_ZEN_BIT, enabled);\n}\n\n/** Get whether Z axis data is enabled\n * @return True if the Z axis is enabled, false otherwise\n * @see L3G4200D_RA_CTRL_REG1\n * @see L3G4200D_ZEN_BIT\n */\nbool L3G4200D::getZEnabled() {\n\tI2Cdev::readBit(devAddr, L3G4200D_RA_CTRL_REG1, L3G4200D_ZEN_BIT, buffer);\n\treturn buffer[0];\n}\n\n/** Enables or disables the ability to get Y data\n * @param enabled The new enabled state of the Y axis\n * @see L3G4200D_RA_CTRL_REG1\n * @see L3G4200D_YEN_BIT\n */\nvoid L3G4200D::setYEnabled(bool enabled) {\n\tI2Cdev::writeBit(devAddr, L3G4200D_RA_CTRL_REG1, L3G4200D_YEN_BIT, enabled);\n}\n\n/** Get whether Y axis data is enabled\n * @return True if the Y axis is enabled, false otherwise\n * @see L3G4200D_RA_CTRL_REG1\n * @see L3G4200D_YEN_BIT\n */\nbool L3G4200D::getYEnabled() {\n\tI2Cdev::readBit(devAddr, L3G4200D_RA_CTRL_REG1, L3G4200D_YEN_BIT, buffer);\n\treturn buffer[0];\n}\n\n/** Enables or disables the ability to get X data\n * @param enabled The new enabled state of the X axis\n * @see L3G4200D_RA_CTRL_REG1\n * @see L3G4200D_XEN_BIT\n */\nvoid L3G4200D::setXEnabled(bool enabled) {\n\tI2Cdev::writeBit(devAddr, L3G4200D_RA_CTRL_REG1, L3G4200D_XEN_BIT, enabled);\n}\n\n/** Get whether X axis data is enabled\n * @return True if the X axis is enabled, false otherwise\n * @see L3G4200D_RA_CTRL_REG1\n * @see L3G4200D_XEN_BIT\n */\nbool L3G4200D::getXEnabled() {\n\tI2Cdev::readBit(devAddr, L3G4200D_RA_CTRL_REG1, L3G4200D_XEN_BIT, buffer);\n\treturn buffer[0];\n}\n\n// CTRL_REG2 register, r/w\n\n/** Set the high pass mode\n * @param mode The new high pass mode\n * @see L3G4200D_RA_CTRL_REG2\n * @see L3G4200D_HPM_BIT\n * @see L3G4200D_HPM_LENGTH\n * @see L3G4200D_HPM_HRF\n * @see L3G4200D_HPM_REFERENCE\n * @see L3G4200D_HPM_NORMAL\n * @see L3G4200D_HPM_AUTORESET\n */\nvoid L3G4200D::setHighPassMode(uint8_t mode) {\n\tI2Cdev::writeBits(devAddr, L3G4200D_RA_CTRL_REG2, L3G4200D_HPM_BIT, \n\t\tL3G4200D_HPM_LENGTH, mode);\n}\n\n/** Get the high pass mode\n * @return High pass mode\n * @see L3G4200D_RA_CTRL_REG2\n * @see L3G4200D_HPM_BIT\n * @see L3G4200D_HPM_LENGTH\n * @see L3G4200D_HPM_HRF\n * @see L3G4200D_HPM_REFERENCE\n * @see L3G4200D_HPM_NORMAL\n * @see L3G4200D_HPM_AUTORESET\n */\nuint8_t L3G4200D::getHighPassMode() {\n\tI2Cdev::readBits(devAddr, L3G4200D_RA_CTRL_REG2, L3G4200D_HPM_BIT, \n\t\tL3G4200D_HPM_LENGTH, buffer);\n\treturn buffer[0];\n}\n\n/** Set the high pass filter cut off frequency level (1 - 10)\n * @param level The new level for the hpcf, using one of the defined levels\n * @see L3G4200D_RA_CTRL_REG2\n * @see L3G4200D_HPCF_BIT\n * @see L3G4200D_HPCF_LENGTH\n * @see L3G4200D_HPCF1\n * @see L3G4200D_HPCF2\n * @see L3G4200D_HPCF3\n * @see L3G4200D_HPCF4\n * @see L3G4200D_HPCF5\n * @see L3G4200D_HPCF6\n * @see L3G4200D_HPCF7\n * @see L3G4200D_HPCF8\n * @see L3G4200D_HPCF9\n * @see L3G4200D_HPCF10\n */\nvoid L3G4200D::setHighPassFilterCutOffFrequencyLevel(uint8_t level) {\n\tI2Cdev::writeBits(devAddr, L3G4200D_RA_CTRL_REG2, L3G4200D_HPCF_BIT, \n\t\tL3G4200D_HPCF_LENGTH, level);\n}\n\n/** Get the high pass filter cut off frequency level (1 - 10)\n * @return High pass filter cut off frequency level\n * @see L3G4200D_RA_CTRL_REG2\n * @see L3G4200D_HPCF_BIT\n * @see L3G4200D_HPCF_LENGTH\n * @see L3G4200D_HPCF1\n * @see L3G4200D_HPCF2\n * @see L3G4200D_HPCF3\n * @see L3G4200D_HPCF4\n * @see L3G4200D_HPCF5\n * @see L3G4200D_HPCF6\n * @see L3G4200D_HPCF7\n * @see L3G4200D_HPCF8\n * @see L3G4200D_HPCF9\n * @see L3G4200D_HPCF10\n */\nuint8_t L3G4200D::getHighPassFilterCutOffFrequencyLevel() {\n\tI2Cdev::readBits(devAddr, L3G4200D_RA_CTRL_REG2, L3G4200D_HPCF_BIT, \n\t\tL3G4200D_HPCF_LENGTH, buffer);\n\treturn buffer[0];\n}\n\n// CTRL_REG3 register, r/w\n\n/** Set the INT1 interrupt enabled state\n * @param enabled New enabled state for the INT1 interrupt\n * @see L3G4200D_RA_CTRL_REG3\n * @see L3G4200D_I1_INT1_BIT\n */\nvoid L3G4200D::setINT1InterruptEnabled(bool enabled) {\n\tI2Cdev::writeBit(devAddr, L3G4200D_RA_CTRL_REG3, L3G4200D_I1_INT1_BIT, \n\t\tenabled);\n}\n\n/** Get the INT1 interrupt enabled state\n * @return True if the INT1 interrupt is enabled, false otherwise\n * @see L3G4200D_RA_CTRL_REG3\n * @see L3G4200D_I1_INT1_BIT\n */\nbool L3G4200D::getINT1InterruptEnabled() {\n\tI2Cdev::readBit(devAddr, L3G4200D_RA_CTRL_REG3, L3G4200D_I1_INT1_BIT, \n\t\tbuffer);\n\treturn buffer[0];\n}\n\n/** Set the INT1 boot status enabled state\n * @param enabled New enabled state for the INT1 boot status\n * @see L3G4200D_RA_CTRL_REG3\n * @see L3G4200D_I1_BOOT_BIT\n */\nvoid L3G4200D::setINT1BootStatusEnabled(bool enabled) {\n\tI2Cdev::writeBit(devAddr, L3G4200D_RA_CTRL_REG3, L3G4200D_I1_BOOT_BIT, \n\t\tenabled);\n}\n\n/** Get the INT1 boot status enabled state\n * @return INT1 boot status status\n * @see L3G4200D_RA_CTRL_REG3\n * @see L3G4200D_I1_BOOT_BIT\n */\nbool L3G4200D::getINT1BootStatusEnabled() {\n\tI2Cdev::readBit(devAddr, L3G4200D_RA_CTRL_REG3, L3G4200D_I1_BOOT_BIT, \n\t\tbuffer);\n\treturn buffer[0];\n}\n\n/** Interrupts the active INT1 configuration\n * @see L3G4200D_RA_CTRL_REG3\n * @see L3G4200D_H_LACTIVE_BIT\n */\nvoid L3G4200D::interruptActiveINT1Config() {\n\tI2Cdev::writeBit(devAddr, L3G4200D_RA_CTRL_REG3, L3G4200D_H_LACTIVE_BIT, 1);\n}\n\n/** Set output mode to push-pull or open-drain\n * @param mode New output mode\n * @see L3G4200D_RA_CTRL_REG3\n * @see L3G4200D_PP_OD_BIT\n * @see L3G4200D_PUSH_PULL\n * @see L3G4200D_OPEN_DRAIN\n */\nvoid L3G4200D::setOutputMode(bool mode) {\n\tI2Cdev::writeBit(devAddr, L3G4200D_RA_CTRL_REG3, L3G4200D_PP_OD_BIT, \n\t\tmode);\n}\n\n/** Get whether mode is push-pull or open drain\n * @return Output mode (TRUE for push-pull, FALSE for open-drain)\n * @see L3G4200D_RA_CTRL_REG3\n * @see L3G4200D_PP_OD_BIT\n * @see L3G4200D_PUSH_PULL\n * @see L3G4200D_OPEN_DRAIN\n */\nbool L3G4200D::getOutputMode() {\n\tI2Cdev::readBit(devAddr, L3G4200D_RA_CTRL_REG3, L3G4200D_PP_OD_BIT, \n\t\tbuffer);\n\treturn buffer[0];\n}\n\n/** Set data ready interrupt enabled state on INT2 pin\n * @param enabled New INT2 data ready interrupt enabled state\n * @see L3G4200D_RA_CTRL_REG3\n * @see L3G4200D_I2_DRDY_BIT\n */\nvoid L3G4200D::setINT2DataReadyEnabled(bool enabled) {\n\tI2Cdev::writeBit(devAddr, L3G4200D_RA_CTRL_REG3, L3G4200D_I2_DRDY_BIT, \n\t\tenabled);\n}\n\n/** Get whether the data ready interrupt is enabled on the INT2 pin\n * @return True if the INT2 data ready interrupt is enabled, false otherwise\n * @see L3G4200D_RA_CTRL_REG3\n * @see L3G4200D_I2_DRDY_BIT\n */\nbool L3G4200D::getINT2DataReadyEnabled() {\n\tI2Cdev::readBit(devAddr, L3G4200D_RA_CTRL_REG3, L3G4200D_I2_DRDY_BIT, \n\t\tbuffer);\n\treturn buffer[0];\n}\n\n/** Set whether the INT2 FIFO watermark interrupt is enabled\n * The sensor contains a 32-slot FIFO buffer for storing data so that it may be \n * read later. If enabled, the sensor will generate an interrupt on the \n * INT2/DRDY pin when the watermark has been reached. The watermark can be \n * configured through the setFIFOWatermark function.\n * @param enabled New enabled state of the INT2 FIFO watermark\n * @see L3G4200D_RA_CTRL_REG3\n * @see L3G4200D_I2_WTM_BIT\n */\nvoid L3G4200D::setINT2FIFOWatermarkInterruptEnabled(bool enabled) {\n\tI2Cdev::writeBit(devAddr, L3G4200D_RA_CTRL_REG3, L3G4200D_I2_WTM_BIT, \n\t\tenabled);\n}\n\n/** Get the INT2 FIFO watermark interrupt enabled state\n * @return true if the FIFO watermark is enabled, false otherwise\n * @see L3G4200D_RA_CTRL_REG3\n * @see L3G4200D_I2_WTM_BIT\n */ \nbool L3G4200D::getINT2FIFOWatermarkInterruptEnabled() {\n\tI2Cdev::readBit(devAddr, L3G4200D_RA_CTRL_REG3, L3G4200D_I2_WTM_BIT, \n\t\tbuffer);\n\treturn buffer[0];\n}\n\n/** Set whether an interrupt is triggered on INT2 when the FIFO is overrun\n * @param enabled New FIFO overrun interrupt enabled state\n * @see L3G4200D_RA_CTRL_REG3\n * @see L3G4200D_I2_ORUN_BIT\n */\nvoid L3G4200D::setINT2FIFOOverrunInterruptEnabled(bool enabled) {\n\tI2Cdev::writeBit(devAddr, L3G4200D_RA_CTRL_REG3, L3G4200D_I2_ORUN_BIT, \n\t\tenabled);\n}\n\n/** Get whether an interrupt is triggered on INT2 when the FIFO is overrun\n * @return True if the INT2 FIFO overrun interrupt is enabled, false otherwise\n * @see L3G4200D_RA_CTRL_REG3\n * @see L3G4200D_I2_ORUN_BIT\n */\nbool L3G4200D::getINT2FIFOOverrunInterruptEnabled() {\n\tI2Cdev::readBit(devAddr, L3G4200D_RA_CTRL_REG3, L3G4200D_I2_ORUN_BIT,\n\t\tbuffer);\n\treturn buffer[0];\n}\n\n/** Set whether an interrupt is triggered on INT2 when the FIFO buffer is empty\n * @param enabled New INT2 FIFO empty interrupt state\n * @see L3G4200D_RA_CTRL_REG3\n * @see L3G4200D_I2_EMPTY_BIT\n */\nvoid L3G4200D::setINT2FIFOEmptyInterruptEnabled(bool enabled) {\n\tI2Cdev::writeBit(devAddr, L3G4200D_RA_CTRL_REG3, L3G4200D_I2_EMPTY_BIT, \n\t\tenabled);\n}\n\n/** Get whether the INT2 FIFO empty interrupt is enabled\n * @returns Trur if the INT2 FIFO empty interrupt is enabled, false otherwise\n * @see L3G4200D_RA_CTRL_REG3\n * @see L3G4200D_I2_EMPTY_BIT\n */\nbool L3G4200D::getINT2FIFOEmptyInterruptEnabled() {\n\tI2Cdev::readBit(devAddr, L3G4200D_RA_CTRL_REG3, L3G4200D_I2_EMPTY_BIT, \n\t\tbuffer);\n\treturn buffer[0];\n}\n\n// CTRL_REG4 register, r/w\n\n/** Set the Block Data Update (BDU) enabled state\n * @param enabled New BDU enabled state\n * @see L3G4200D_RA_CTRL_REG4\n * @see L3G4200D_BDU_BIT\n */\nvoid L3G4200D::setBlockDataUpdateEnabled(bool enabled) {\n\tI2Cdev::writeBit(devAddr, L3G4200D_RA_CTRL_REG4, L3G4200D_BDU_BIT, enabled);\n}\n\n/** Get the BDU enabled state\n * @return True if Block Data Update is enabled, false otherwise\n * @see L3G4200D_RA_CTRL_REG4\n * @see L3G4200D_BDU_BIT\n */\nbool L3G4200D::getBlockDataUpdateEnabled() {\n\tI2Cdev::readBit(devAddr, L3G4200D_RA_CTRL_REG4, L3G4200D_BDU_BIT, buffer);\n\treturn buffer[0];\n}\n\n/** Set the data endian modes\n * In Big Endian mode, the Most Significat Byte (MSB) is on the lower address, \n * and the Least Significant Byte (LSB) is on the higher address. Little Endian \n * mode reverses this order. Little Endian is the default mode.\n * @param endianness New endian mode\n * @see L3G4200D_RA_CTRL_REG4\n * @see L3G4200D_BLE_BIT\n * @see L3G4200D_BIG_ENDIAN\n * @see L3G4200D_LITTLE_ENDIAN\n */\nvoid L3G4200D::setEndianMode(bool endianness) {\n\tI2Cdev::writeBit(devAddr, L3G4200D_RA_CTRL_REG4, L3G4200D_BLE_BIT, \n\t\tendianness);\n}\n\n/** Get the data endian mode\n * @return Current endian mode\n * @see L3G4200D_RA_CTRL_REG4\n * @see L3G4200D_BLE_BIT\n * @see L3G4200D_BIG_ENDIAN\n * @see L3G4200D_LITTLE_ENDIAN\n */\nbool L3G4200D::getEndianMode() {\n\tI2Cdev::readBit(devAddr, L3G4200D_RA_CTRL_REG4, L3G4200D_BLE_BIT,\n\t\tbuffer);\n\treturn buffer[0];\n}\n\n/** Set the full scale of the data output (in dps)\n * @param scale The new scale of the data output (250, 500, 2000)\n * @see L3G4200D_RA_CTRL_REG4\n * @see L3G4200D_FS_BIT\n * @see L3G4200D_FS_LENGTH\n * @see L3G4200D_FS_250\n * @see L3G4200D_FS_500\n * @see L3G4200D_FS_2000\n */\nvoid L3G4200D::setFullScale(uint16_t scale) {\n\tuint8_t writeBits;\n\t\n\tif (scale == 250) {\n\t\twriteBits = L3G4200D_FS_250;\n\t} else if (scale == 500) {\n\t\twriteBits = L3G4200D_FS_500;\n\t} else {\n\t\twriteBits = L3G4200D_FS_2000;\n\t}\n\n\tI2Cdev::writeBits(devAddr, L3G4200D_RA_CTRL_REG4, L3G4200D_FS_BIT, \n\t\tL3G4200D_FS_LENGTH, writeBits);\n}\n\n/** Get the current full scale of the output data (in dps)\n * @return Current scale of the output data\n * @see L3G4200D_RA_CTRL_REG4\n * @see L3G4200D_FS_BIT\n * @see L3G4200D_FS_LENGTH\n * @see L3G4200D_FS_250\n * @see L3G4200D_FS_500\n * @see L3G4200D_FS_2000\n */\nuint16_t L3G4200D::getFullScale() {\n\tI2Cdev::readBits(devAddr, L3G4200D_RA_CTRL_REG4, \n\t\tL3G4200D_FS_BIT, L3G4200D_FS_LENGTH, buffer);\n\tuint8_t readBits = buffer[0];\n\t\n\tif (readBits == L3G4200D_FS_250) {\n\t\treturn 250;\n\t} else if (readBits == L3G4200D_FS_500) {\n\t\treturn 500;\n\t} else {\n\t\treturn 2000;\n\t}\n}\n\n/** Set the self test mode\n * @param mode New self test mode (Normal, 0, 1)\n * @see L3G4200D_RA_CTRL_REG4\n * @see L3G4200D_ST_BIT\n * @see L3G4200D_ST_LENGTH\n * @see L3G4200D_SELF_TEST_NORMAL\n * @see L3G4200D_SELF_TEST_0\n * @see L3G4200D_SELF_TEST_1\n */\nvoid L3G4200D::setSelfTestMode(uint8_t mode) {\n\tI2Cdev::writeBits(devAddr, L3G4200D_RA_CTRL_REG4, L3G4200D_ST_BIT, \n\t\tL3G4200D_ST_LENGTH, mode);\n}\n\n/** Get the current self test mode\n * @return Current self test mode\n * @see L3G4200D_RA_CTRL_REG4\n * @see L3G4200D_ST_BIT\n * @see L3G4200D_ST_LENGTH\n * @see L3G4200D_SELF_TEST_NORMAL\n * @see L3G4200D_SELF_TEST_0\n * @see L3G4200D_SELF_TEST_1\n */\nuint8_t L3G4200D::getSelfTestMode() {\n\tI2Cdev::readBits(devAddr, L3G4200D_RA_CTRL_REG4, L3G4200D_ST_BIT, \n\t\tL3G4200D_ST_LENGTH, buffer);\n\treturn buffer[0];\n}\n\n/** Set the SPI mode\n * @param mode New SPI mode\n * @see L3G4200D_RA_CTRL_REG4\n * @see L3G4200D_SIM_BIT\n * @see L3G4200D_SPI_4_WIRE\n * @see L3G4200D_SPI_3_WIRE\n */\nvoid L3G4200D::setSPIMode(bool mode) {\n\tI2Cdev::writeBit(devAddr, L3G4200D_RA_CTRL_REG4, L3G4200D_SIM_BIT, mode);\n}\n\n/** Get the SPI mode\n * @return Current SPI mode\n * @see L3G4200D_RA_CTRL_REG4\n * @see L3G4200D_SIM_BIT\n * @see L3G4200D_SPI_4_WIRE\n * @see L3G4200D_SPI_3_WIRE\n */\nbool L3G4200D::getSPIMode() {\n\tI2Cdev::readBit(devAddr, L3G4200D_RA_CTRL_REG4, L3G4200D_SIM_BIT, \n\t\tbuffer);\n \treturn buffer[0];\n}\n\n// CTRL_REG5 register, r/w\n\n/** Reboots the FIFO memory content\n * @see L3G4200D_RA_CTRL_REG5\n * @see L3G4200D_BOOT_BIT\n */\nvoid L3G4200D::rebootMemoryContent() {\n\tI2Cdev::writeBit(devAddr, L3G4200D_RA_CTRL_REG5, L3G4200D_BOOT_BIT, true);\n}\n\n/** Set whether the FIFO buffer is enabled\n * @param enabled New enabled state of the FIFO buffer\n * @see L3G4200D_RA_CTRL_REG5\n * @see L3G4200D_FIFO_EN_BIT\n */\nvoid L3G4200D::setFIFOEnabled(bool enabled) {\n\tI2Cdev::writeBit(devAddr, L3G4200D_RA_CTRL_REG5, L3G4200D_FIFO_EN_BIT, \n\t\tenabled);\n}\n\n/** Get whether the FIFO buffer is enabled\n * @return True if the FIFO buffer is enabled, false otherwise\n * @see L3G4200D_RA_CTRL_REG5\n * @see L3G4200D_FIFO_EN_BIT\n */\nbool L3G4200D::getFIFOEnabled() {\n\tI2Cdev::readBit(devAddr, L3G4200D_RA_CTRL_REG5, L3G4200D_FIFO_EN_BIT, \n\t\tbuffer);\n\treturn buffer[0];\n}\n\n/** Set the high pass filter enabled state\n * @param enabled New high pass filter enabled state\n * @see L3G4200D_RA_CTRL_REG5\n * @see L3G4200D_HPEN_BIT\n */\nvoid L3G4200D::setHighPassFilterEnabled(bool enabled) {\n\tI2Cdev::writeBit(devAddr, L3G4200D_RA_CTRL_REG5, L3G4200D_HPEN_BIT, \n\t\tenabled);\n}\n\n/** Get whether the high pass filter is enabled\n * @return True if the high pass filter is enabled, false otherwise\n * @see L3G4200D_RA_CTRL_REG5\n * @see L3G4200D_HPEN_BIT\n */\nbool L3G4200D::getHighPassFilterEnabled() {\n\tI2Cdev::readBit(devAddr, L3G4200D_RA_CTRL_REG5, L3G4200D_HPEN_BIT,\n\t\tbuffer);\n\treturn buffer[0];\n}\n\n/** Sets the filter mode to one of the four provided.\n * This function also uses the setHighPassFilterEnabled function in order to set\n * the mode. That function does not haved to be called in addition to this one. \n * In addition to setting the filter for the data in the FIFO buffer \n * (controlled by the bits written to OUT_SEL), this function also sets the\n * filter used for interrupt generation (the bits written to INT1_SEL) to be the\n * same as the filter used for the FIFO buffer.\n * @param filter New method to be used when filtering data\n * @see L3G4200D_RA_CTRL_REG5\n * @see L3G4200D_INT1_SEL_BIT\n * @see L3G4200D_INT1_SEL_LENGTH\n * @see L3G4200D_OUT_SEL_BIT\n * @see L3G4200D_OUT_SEL_LENGTH\n * @see L3G4200D_NON_HIGH_PASS\n * @see L3G4200D_HIGH_PASS\n * @see L3G4200D_LOW_PASS\n * @see L3G4200D_LOW_HIGH_PASS\n */\nvoid L3G4200D::setDataFilter(uint8_t filter) {\n\tif (filter == L3G4200D_HIGH_PASS || filter == L3G4200D_LOW_HIGH_PASS) {\n\t\tsetHighPassFilterEnabled(true);\n\t} else {\n\t\tsetHighPassFilterEnabled(false);\n\t}\n\t\n\tI2Cdev::writeBits(devAddr, L3G4200D_RA_CTRL_REG5, L3G4200D_OUT_SEL_BIT, \n\t\tL3G4200D_OUT_SEL_LENGTH, filter);\n\tI2Cdev::writeBits(devAddr, L3G4200D_RA_CTRL_REG5, L3G4200D_INT1_SEL_BIT, \n\t\tL3G4200D_INT1_SEL_LENGTH, filter);\n}\n\n/** Gets the data filter currently in use\n * @return Defined value that represents the filter in use\n * @see L3G4200D_RA_CTRL_REG5\n * @see L3G4200D_OUT_SEL_BIT\n * @see L3G4200D_OUT_SEL_LENGTH\n * @see L3G4200D_NON_HIGH_PASS\n * @see L3G4200D_HIGH_PASS\n * @see L3G4200D_LOW_PASS\n * @see L3G4200D_LOW_HIGH_PASS\n */\nuint8_t L3G4200D::getDataFilter() {\n\tI2Cdev::readBits(devAddr, L3G4200D_RA_CTRL_REG5, L3G4200D_OUT_SEL_BIT, \n\t\tL3G4200D_OUT_SEL_LENGTH, buffer);\n\tuint8_t outBits = buffer[0];\n\n\tif (outBits == L3G4200D_NON_HIGH_PASS || outBits == L3G4200D_HIGH_PASS) {\n\t\treturn outBits;\n\t}\n\n\tif (getHighPassFilterEnabled()) {\n\t\treturn L3G4200D_LOW_HIGH_PASS;\n\t} else {\n\t\treturn L3G4200D_LOW_PASS;\n\t}\n}\n\n// REFERENCE/DATACAPTURE register, r/w\n\n/** Set the reference value for interrupt generation\n * @param reference New reference value for interrupt generation\n * @see L3G4200D_RA_REFERENCE\n */\nvoid L3G4200D::setInterruptReference(uint8_t reference) {\n\tI2Cdev::writeByte(devAddr, L3G4200D_RA_REFERENCE, reference);\n}\n\n/** Get the 8-bit reference value for interrupt generation\n * @return 8-bit reference value for interrupt generation\n * @see L3G4200D_RA_REFERENCE\n */\nuint8_t L3G4200D::getInterruptReference() {\n\tI2Cdev::readByte(devAddr, L3G4200D_RA_REFERENCE, buffer);\n\treturn buffer[0];\n}\n\n// OUT_TEMP register, read-only\n\n/** Gets the current temperature reading from the sensor\n * @return Current temperature\n * @see L3G4200D_RA_OUT_TEMP\n */\nuint8_t L3G4200D::getTemperature() {\n\tI2Cdev::readByte(devAddr, L3G4200D_RA_OUT_TEMP, buffer);\n\treturn buffer[0];\n}\n\n// STATUS register, read-only\n\n/** Get whether new data overwrote the last set of data before it was read\n * @return True if the last set of data was overwritten before being read, false\n * otherwise\n * @see L3G4200D_RA_STATUS\n * @see L3G4200D_ZYXOR_BIT\n */\nbool L3G4200D::getXYZOverrun() {\n\tI2Cdev::readBit(devAddr, L3G4200D_RA_STATUS, L3G4200D_ZYXOR_BIT, \n\t\tbuffer);\n\treturn buffer[0];\n}\n\n/** Get whether new Z data overwrote the last set of data before it was read\n * @return True if the last set of Z data was overwritten before being read,\n * false otherwise\n * @see L3G4200D_RA_STATUS\n * @see L3G4200D_ZOR_BIT\n */\nbool L3G4200D::getZOverrun() {\n\tI2Cdev::readBit(devAddr, L3G4200D_RA_STATUS, L3G4200D_ZOR_BIT, \n\t\tbuffer);\n\treturn buffer[0];\n}\n\n/** Get whether new Y data overwrote the last set of data before it was read\n * @return True if the last set of Y data was overwritten before being read, \n * false otherwise\n * @see L3G4200D_RA_STATUS\n * @see L3G4200D_YOR_BIT\n */\nbool L3G4200D::getYOverrun() {\n\tI2Cdev::readBit(devAddr, L3G4200D_RA_STATUS, L3G4200D_YOR_BIT, \n\t\tbuffer);\n\treturn buffer[0];\n}\n\n/** Get whether new X data overwrote the last set of data before it was read\n * @return True if the last set of X data was overwritten before being read, \n * false otherwise\n * @see L3G4200D_RA_STATUS\n * @see L3G4200D_XOR_BIT\n */\nbool L3G4200D::getXOverrun() {\n\tI2Cdev::readBit(devAddr, L3G4200D_RA_STATUS, L3G4200D_XOR_BIT, \n\t\tbuffer);\n\treturn buffer[0];\n}\n\n/** Get whether there is new data avaialable\n * @return True if there is new data available, false otherwise\n * @see L3G4200D_RA_STATUS\n * @see L3G4200D_ZYXDA_BIT\n */\nbool L3G4200D::getXYZDataAvailable() {\n\tI2Cdev::readBit(devAddr, L3G4200D_RA_STATUS, L3G4200D_ZYXDA_BIT, \n\t\tbuffer);\n\treturn buffer[0];\n}\n\n/** Get whether there is new Z data avaialable\n * @return True if there is new Z data available, false otherwise\n * @see L3G4200D_RA_STATUS\n * @see L3G4200D_ZDA_BIT\n */\nbool L3G4200D::getZDataAvailable() {\n\tI2Cdev::readBit(devAddr, L3G4200D_RA_STATUS, L3G4200D_ZDA_BIT, \n\t\tbuffer);\n\treturn buffer[0];\n}\n\n/** Get whether there is new Y data avaialable\n * @return True if there is new Y data available, false otherwise\n * @see L3G4200D_RA_STATUS\n * @see L3G4200D_YDA_BIT\n */\nbool L3G4200D::getYDataAvailable() {\n\tI2Cdev::readBit(devAddr, L3G4200D_RA_STATUS, L3G4200D_YDA_BIT, \n\t\tbuffer);\n\treturn buffer[0];\n}\n\n/** Get whether there is new X data avaialable\n * @return True if there is new X data available, false otherwise\n * @see L3G4200D_RA_STATUS\n * @see L3G4200D_XDA_BIT\n */\nbool L3G4200D::getXDataAvailable() {\n\tI2Cdev::readBit(devAddr, L3G4200D_RA_STATUS, L3G4200D_XDA_BIT, \n\t\tbuffer);\n\treturn buffer[0];\n}\n\n// OUT_* registers, read-only\n\n/** Get the angular velocity for all 3 axes\n * Due to the fact that this device supports two difference Endian modes, both \n * must be accounted for when reading data. In Little Endian mode, the first \n * byte (lowest address) is the least significant and in Big Endian mode the \n * first byte is the most significant.\n * @param x 16-bit integer container for the X-axis angular velocity\n * @param y 16-bit integer container for the Y-axis angular velocity\n * @param z 16-bit integer container for the Z-axis angular velocity\n */\nvoid L3G4200D::getAngularVelocity(int16_t* x, int16_t* y, int16_t* z) {\n\t*x = getAngularVelocityX();\n\t*y = getAngularVelocityY();\n\t*z = getAngularVelocityZ();\n}\n\n/** Get the angular velocity about the X-axis\n * @return Angular velocity about the X-axis\n * @see L3G4200D_RA_OUT_X_L\n * @see L3G4200D_RA_OUT_X_H\n */\nint16_t L3G4200D::getAngularVelocityX() {\n\tuint8_t bufferL[6];\n\tuint8_t bufferH[6];\n\tI2Cdev::readBytes(devAddr, L3G4200D_RA_OUT_X_L, 1, bufferL);\n\tI2Cdev::readBytes(devAddr, L3G4200D_RA_OUT_X_H, 1, bufferH);\n\tif (getEndianMode() == L3G4200D_BIG_ENDIAN) {\n\t\treturn (((int16_t) bufferL[0]) << 8) | bufferH[0];\n\t} else {\n\t\treturn (((int16_t) bufferH[0]) << 8) | bufferL[0];\n\t}\n}\n\t\n/** Get the angular velocity about the Y-axis\n * @return Angular velocity about the Y-axis\n * @see L3G4200D_RA_OUT_Y_L\n * @see L3G4200D_RA_OUT_Y_H\n */\nint16_t L3G4200D::getAngularVelocityY() {\n\tuint8_t bufferL[6];\n\tuint8_t bufferH[6];\n\tI2Cdev::readBytes(devAddr, L3G4200D_RA_OUT_Y_L, 1, bufferL);\n\tI2Cdev::readBytes(devAddr, L3G4200D_RA_OUT_Y_H, 1, bufferH);\n\tif (getEndianMode() == L3G4200D_BIG_ENDIAN) {\n\t\treturn (((int16_t) bufferL[0]) << 8) | bufferH[0];\n\t} else {\n\t\treturn (((int16_t) bufferH[0]) << 8) | bufferL[0];\n\t}\n}\n\n/** Get the angular velocity about the Z-axis\n * @return Angular velocity about the Z-axis\n * @see L3G4200D_RA_OUT_Z_L\n * @see L3G4200D_RA_OUT_Z_H\n */\nint16_t L3G4200D::getAngularVelocityZ() {\n\tuint8_t bufferL[6];\n\tuint8_t bufferH[6];\n\tI2Cdev::readBytes(devAddr, L3G4200D_RA_OUT_Z_L, 1, bufferL);\n\tI2Cdev::readBytes(devAddr, L3G4200D_RA_OUT_Z_H, 1, bufferH);\n\tif (getEndianMode() == L3G4200D_BIG_ENDIAN) {\n\t\treturn (((int16_t) bufferL[0]) << 8) | bufferH[0];\n\t} else {\n\t\treturn (((int16_t) bufferH[0]) << 8) | bufferL[0];\n\t}\n}\n\n// FIFO_CTRL register, r/w\n\n/** Set the FIFO mode to one of the defined modes\n * @param mode New FIFO mode\n * @see L3G4200D_RA_FIFO_CTRL\n * @see L3G4200D_FIFO_MODE_BIT\n * @see L3G4200D_FIFO_MODE_LENGTH\n * @see L3G4200D_FM_BYPASS\n * @see L3G4200D_FM_FIFO\n * @see L3G4200D_FM_STREAM\n * @see L3G4200D_FM_STREAM_FIFO\n * @see L3G4200D_FM_BYPASS_STREAM\n */\nvoid L3G4200D::setFIFOMode(uint8_t mode) {\n\tI2Cdev::writeBits(devAddr, L3G4200D_RA_FIFO_CTRL, L3G4200D_FIFO_MODE_BIT, \n\t\tL3G4200D_FIFO_MODE_LENGTH, mode);\n}\n\n/** Get the FIFO mode to one of the defined modes\n * @return Current FIFO mode\n * @see L3G4200D_RA_FIFO_CTRL\n * @see L3G4200D_FIFO_MODE_BIT\n * @see L3G4200D_FIFO_MODE_LENGTH\n * @see L3G4200D_FM_BYPASS\n * @see L3G4200D_FM_FIFO\n * @see L3G4200D_FM_STREAM\n * @see L3G4200D_FM_STREAM_FIFO\n * @see L3G4200D_FM_BYPASS_STREAM\n */\nuint8_t L3G4200D::getFIFOMode() {\n\tI2Cdev::readBits(devAddr, L3G4200D_RA_FIFO_CTRL, \n\t\tL3G4200D_FIFO_MODE_BIT, L3G4200D_FIFO_MODE_LENGTH, buffer);\n\treturn buffer[0];\n}\n\n/** Set the FIFO watermark threshold\n * @param wtm New FIFO watermark threshold\n * @see L3G4200D_RA_FIFO_CTRL\n * @see L3G4200D_FIFO_WTM_BIT\n * @see L3G4200D_FIFO_WTM_LENGTH\n */\nvoid L3G4200D::setFIFOThreshold(uint8_t wtm) {\n    I2Cdev::writeBits(devAddr, L3G4200D_RA_FIFO_CTRL, L3G4200D_FIFO_WTM_BIT, \n        L3G4200D_FIFO_WTM_LENGTH, wtm);\n}\n\n/** Get the FIFO watermark threshold\n * @return FIFO watermark threshold\n * @see L3G4200D_RA_FIFO_CTRL\n * @see L3G4200D_FIFO_WTM_BIT\n * @see L3G4200D_FIFO_WTM_LENGTH\n */\nuint8_t L3G4200D::getFIFOThreshold() {\n    I2Cdev::readBits(devAddr, L3G4200D_RA_FIFO_CTRL, L3G4200D_FIFO_WTM_BIT,\n        L3G4200D_FIFO_WTM_LENGTH, buffer);\n    return buffer[0];\n}\n\n// FIFO_SRC register, read-only\n\n/** Get whether the number of data sets in the FIFO buffer is less than the \n * watermark\n * @return True if the number of data sets in the FIFO buffer is more than or \n * equal to the watermark, false otherwise.\n * @see L3G4200D_RA_FIFO_SRC\n * @see L3G4200D_FIFO_STATUS_BIT\n */\nbool L3G4200D::getFIFOAtWatermark() {\n   \tI2Cdev::readBit(devAddr, L3G4200D_RA_FIFO_SRC, L3G4200D_FIFO_STATUS_BIT, \n        buffer);\n   \treturn buffer[0];\n}\n\n/** Get whether the FIFO buffer is full\n * @return True if the FIFO buffer is full, false otherwise\n * @see L3G4200D_RA_FIFO_SRC\n * @see L3G4200D_FIFO_OVRN_BIT\n */\nbool L3G4200D::getFIFOOverrun() {\n    I2Cdev::readBit(devAddr, L3G4200D_RA_FIFO_SRC, \n        L3G4200D_FIFO_OVRN_BIT, buffer);\n    return buffer[0];\n}\n\n/** Get whether the FIFO buffer is empty\n * @return True if the FIFO buffer is empty, false otherwise\n * @see L3G4200D_RA_FIFO_SRC\n * @see L3G4200D_FIFO_EMPTY_BIT\n */\nbool L3G4200D::getFIFOEmpty() {\n    I2Cdev::readBit(devAddr, L3G4200D_RA_FIFO_SRC,\n        L3G4200D_FIFO_EMPTY_BIT, buffer);\n    return buffer[0];\n}\n\n/** Get the number of filled FIFO buffer slots\n * @return Number of filled slots in the FIFO buffer\n * @see L3G4200D_RA_FIFO_SRC\n * @see L3G4200D_FIFO_FSS_BIT\n * @see L3G4200D_FIFO_FSS_LENGTH\n */ \nuint8_t L3G4200D::getFIFOStoredDataLevel() {\n    I2Cdev::readBits(devAddr, L3G4200D_RA_FIFO_SRC, \n        L3G4200D_FIFO_FSS_BIT, L3G4200D_FIFO_FSS_LENGTH, buffer);\n    return buffer[0];\n}\n\n// INT1_CFG register, r/w\n\n/** Set the combination mode for interrupt events\n * @param combination New combination mode for interrupt events. \n * L3G4200D_INT1_OR for OR and L3G4200D_INT1_AND for AND\n * @see L3G4200D_RA_INT1_CFG\n * @see L3G4200D_INT1_AND_OR_BIT\n * @see L3G4200D_INT1_OR\n * @see L3G4200D_INT1_AND\n */\nvoid L3G4200D::setInterruptCombination(bool combination) {\n    I2Cdev::writeBit(devAddr, L3G4200D_RA_INT1_CFG, L3G4200D_INT1_AND_OR_BIT,\n        combination);\n}\n\n/** Get the combination mode for interrupt events\n * @return Combination mode for interrupt events. L3G4200D_INT1_OR for OR and \n * L3G4200D_INT1_AND for AND\n * @see L3G4200D_RA_INT1_CFG\n * @see L3G4200D_INT1_AND_OR_BIT\n * @see L3G4200D_INT1_OR\n * @see L3G4200D_INT1_AND\n */\nbool L3G4200D::getInterruptCombination() {\n    I2Cdev::readBit(devAddr, L3G4200D_RA_INT1_CFG, L3G4200D_INT1_AND_OR_BIT,\n        buffer);\n    return buffer[0];\n}\n\n/** Set whether an interrupt request is latched\n * This bit is cleared when the INT1_SRC register is read\n * @param latched New status of the latched request\n * @see L3G4200D_RA_INT1_CFG\n * @see L3G4200D_INT1_LIR_BIT\n */\nvoid L3G4200D::setInterruptRequestLatched(bool latched) {\n    I2Cdev::writeBit(devAddr, L3G4200D_RA_INT1_CFG, L3G4200D_INT1_LIR_BIT, latched);\n}\n\n/** Get whether an interrupt request is latched\n * @return True if an interrupt request is latched, false otherwise\n * @see L3G4200D_RA_INT1_CFG\n * @see L3G4200D_INT1_LIR_BIT\n */\nbool L3G4200D::getInterruptRequestLatched() {\n    I2Cdev::readBit(devAddr, L3G4200D_RA_INT1_CFG, L3G4200D_INT1_LIR_BIT, \n        buffer); \n    return buffer[0];\n};\n\n/** Set whether the interrupt for Z high is enabled\n * @param enabled New enabled state for Z high interrupt.\n * @see L3G4200D_INT1_CFG\n * @see L3G4200D_ZHIE_BIT\n */\nvoid L3G4200D::setZHighInterruptEnabled(bool enabled) {\n    I2Cdev::writeBit(devAddr, L3G4200D_RA_INT1_CFG, L3G4200D_ZHIE_BIT, enabled);\n}\n\n/** Get whether the interrupt for Z high is enabled\n * @return True if the interrupt for Z high is enabled, false otherwise \n * @see L3G4200D_INT1_CFG\n * @see L3G4200D_ZHIE_BIT\n */\nbool L3G4200D::getZHighInterruptEnabled() {\n    I2Cdev::readBit(devAddr, L3G4200D_RA_INT1_CFG, L3G4200D_ZHIE_BIT, \n        buffer);\n    return buffer[0];\n}\n\n/** Set whether the interrupt for Z low is enabled\n * @param enabled New enabled state for Z low interrupt.\n * @see L3G4200D_INT1_CFG\n * @see L3G4200D_ZLIE_BIT\n */\nvoid L3G4200D::setZLowInterruptEnabled(bool enabled) {\n    I2Cdev::writeBit(devAddr, L3G4200D_RA_INT1_CFG, L3G4200D_ZLIE_BIT, enabled);\n}\n\n/** Get whether the interrupt for Z low is enabled\n * @return True if the interrupt for Z low is enabled, false otherwise\n * @see L3G4200D_INT1_CFG\n * @see L3G4200D_ZLIE_BIT\n */\nbool L3G4200D::getZLowInterruptEnabled() {\n    I2Cdev::readBit(devAddr, L3G4200D_RA_INT1_CFG, L3G4200D_ZLIE_BIT, \n        buffer);\n    return buffer[0];\n}\n\n/** Set whether the interrupt for Y high is enabled\n * @param enabled New enabled state for Y high interrupt.\n * @see L3G4200D_INT1_CFG\n * @see L3G4200D_YHIE_BIT\n */\nvoid L3G4200D::setYHighInterruptEnabled(bool enabled) {\n    I2Cdev::writeBit(devAddr, L3G4200D_RA_INT1_CFG, L3G4200D_YHIE_BIT, enabled);\n}\n\n/** Get whether the interrupt for Y high is enabled\n * @return True if the interrupt for Y high is enabled, false otherwise\n * @see L3G4200D_INT1_CFG\n * @see L3G4200D_YHIE_BIT\n */\nbool L3G4200D::getYHighInterruptEnabled() {\n    I2Cdev::readBit(devAddr, L3G4200D_RA_INT1_CFG, L3G4200D_YHIE_BIT, \n        buffer);\n    return buffer[0];\n}\n\n/** Set whether the interrupt for Y low is enabled\n * @param enabled New enabled state for Y low interrupt.\n * @see L3G4200D_INT1_CFG\n * @see L3G4200D_YLIE_BIT\n */\nvoid L3G4200D::setYLowInterruptEnabled(bool enabled) {\n    I2Cdev::writeBit(devAddr, L3G4200D_RA_INT1_CFG, L3G4200D_YLIE_BIT, enabled);\n}\n\n/** Get whether the interrupt for Y low is enabled\n * @return True if the interrupt for Y low is enabled, false otherwise \n * @see L3G4200D_INT1_CFG\n * @see L3G4200D_YLIE_BIT\n */\nbool L3G4200D::getYLowInterruptEnabled() {\n    I2Cdev::readBit(devAddr, L3G4200D_RA_INT1_CFG, L3G4200D_YLIE_BIT, \n        buffer);\n    return buffer[0];\n}\n\n/** Set whether the interrupt for X high is enabled\n * @param enabled New enabled state for X high interrupt.\n * @see L3G4200D_INT1_CFG\n * @see L3G4200D_XHIE_BIT\n */\nvoid L3G4200D::setXHighInterruptEnabled(bool enabled) {\n    I2Cdev::writeBit(devAddr, L3G4200D_RA_INT1_CFG, L3G4200D_XHIE_BIT, enabled);\n}\n\n/** Get whether the interrupt for X high is enabled\n * @return True if the interrupt for X high is enabled, false otherwise\n * @see L3G4200D_INT1_CFG\n * @see L3G4200D_XHIE_BIT\n */\nbool L3G4200D::getXHighInterruptEnabled() {\n    I2Cdev::readBit(devAddr, L3G4200D_RA_INT1_CFG, L3G4200D_XHIE_BIT, \n        buffer);\n    return buffer[0];\n}\n\n/** Set whether the interrupt for X low is enabled\n * @param enabled New enabled state for X low interrupt.\n * @see L3G4200D_INT1_CFG\n * @see L3G4200D_XLIE_BIT\n */\nvoid L3G4200D::setXLowInterruptEnabled(bool enabled) {\n    I2Cdev::writeBit(devAddr, L3G4200D_RA_INT1_CFG, L3G4200D_XLIE_BIT, enabled);\n}\n\n/** Get whether the interrupt for X low is enabled\n * @return True if the interrupt for X low is enabled, false otherwise\n * @see L3G4200D_INT1_CFG\n * @see L3G4200D_XLIE_BIT\n */\nbool L3G4200D::getXLowInterruptEnabled() {\n    I2Cdev::readBit(devAddr, L3G4200D_RA_INT1_CFG, L3G4200D_XLIE_BIT, \n        buffer);\n    return buffer[0];\n}\n\n// INT1_SRC register, read-only\n\n/** Get whether an interrupt has been generated\n * @return True if one or more interrupts has been generated, false otherwise\n * @see L3G4200D_RA_INT1_SRC\n * @see L3G4200D_INT1_IA_BIT\n */\nbool L3G4200D::getInterruptActive() {\n    I2Cdev::readBit(devAddr, L3G4200D_RA_INT1_SRC, L3G4200D_INT1_IA_BIT,\n        buffer);\n    return buffer[0];\n}\n\n/** Get whether a Z high event has occurred\n * @return True if a Z high event has occurred, false otherwise\n * @see L3G4200D_RA_INT1_SRC\n * @see L3G4200D_INT1_ZH_BIT\n */\nbool L3G4200D::getZHigh() {\n    I2Cdev::readBit(devAddr, L3G4200D_RA_INT1_SRC, L3G4200D_INT1_ZH_BIT,\n        buffer);\n    return buffer[0];\n}\n\n/** Get whether a Z low event has occurred\n * @return True if a Z low event has occurred, false otherwise\n * @see L3G4200D_RA_INT1_SRC\n * @see L3G4200D_INT1_ZL_BIT\n */\nbool L3G4200D::getZLow() {\n    I2Cdev::readBit(devAddr, L3G4200D_RA_INT1_SRC, L3G4200D_INT1_ZL_BIT,\n        buffer);\n    return buffer[0];\n}\n\n/** Get whether a Y high event has occurred\n * @return True if a Y high event has occurred, false otherwise\n * @see L3G4200D_RA_INT1_SRC\n * @see L3G4200D_INT1_YH_BIT\n */\nbool L3G4200D::getYHigh() {\n    I2Cdev::readBit(devAddr, L3G4200D_RA_INT1_SRC, L3G4200D_INT1_YH_BIT,\n        buffer);\n    return buffer[0];\n}\n\n/** Get whether a Y low event has occurred\n * @return True if a Y low event has occurred, false otherwise\n * @see L3G4200D_RA_INT1_SRC\n * @see L3G4200D_INT1_YL_BIT\n */\nbool L3G4200D::getYLow() {\n   \tI2Cdev::readBit(devAddr, L3G4200D_RA_INT1_SRC, L3G4200D_INT1_YL_BIT,\n        buffer);\n    return buffer[0];\n}\n\n/** Get whether a X high event has occurred\n * @return True if a X high event has occurred, false otherwise\n * @see L3G4200D_RA_INT1_SRC\n * @see L3G4200D_INT1_XH_BIT\n */\nbool L3G4200D::getXHigh() {\n    I2Cdev::readBit(devAddr, L3G4200D_RA_INT1_SRC, L3G4200D_INT1_XH_BIT,\n        buffer);\n    return buffer[0];\n}\n\n/** Get whether a X low event has occurred\n * @return True if a X low event has occurred, false otherwise\n * @see L3G4200D_RA_INT1_SRC\n * @see L3G4200D_INT1_XL_BIT\n */\nbool L3G4200D::getXLow() {\n    I2Cdev::readBit(devAddr, L3G4200D_RA_INT1_SRC, L3G4200D_INT1_XL_BIT,\n        buffer);\n    return buffer[0];\n}\n\n// INT1_THS_* registers, r/w\n\n/** Set the threshold for a high interrupt on the X axis\n * @param threshold New threshold for a high interrupt on the X axis\n * @see L3G4200D_INT1_THS_XH\n */\nvoid L3G4200D::setXHighThreshold(uint8_t threshold) {\n    I2Cdev::writeByte(devAddr, L3G4200D_RA_INT1_THS_XH, threshold);\n}\n\n/** Retrieve the threshold for a high interrupt on the X axis\n * @return X high interrupt threshold\n * @see L3G4200D_INT1_THS_XH\n */\nuint8_t L3G4200D::getXHighThreshold() {\n\tI2Cdev::readByte(devAddr, L3G4200D_RA_INT1_THS_XH, buffer);\n\treturn buffer[0];\n}\n\n/** Set the threshold for a low interrupt on the X axis\n * @param threshold New threshold for a low interrupt on the X axis\n * @see L3G4200D_INT1_THS_XL\n */\nvoid L3G4200D::setXLowThreshold(uint8_t threshold) {\n    I2Cdev::writeByte(devAddr, L3G4200D_RA_INT1_THS_XL, threshold);\n}\n\n/** Retrieve the threshold for a low interrupt on the X axis\n * @return X low interrupt threshold\n * @see L3G4200D_INT1_THS_XL\n */\nuint8_t L3G4200D::getXLowThreshold() {\n\tI2Cdev::readByte(devAddr, L3G4200D_RA_INT1_THS_XL, buffer);\n\treturn buffer[0];\n}\n\n/** Set the threshold for a high interrupt on the Y axis\n * @param threshold New threshold for a high interrupt on the Y axis\n * @see L3G4200D_INT1_THS_YH\n */\nvoid L3G4200D::setYHighThreshold(uint8_t threshold) {\n    I2Cdev::writeByte(devAddr, L3G4200D_RA_INT1_THS_YH, threshold);\n}\n\n/** Retrieve the threshold for a high interrupt on the Y axis\n * @return Y high interrupt threshold\n * @see L3G4200D_INT1_THS_YH\n */\nuint8_t L3G4200D::getYHighThreshold() {\n\tI2Cdev::readByte(devAddr, L3G4200D_RA_INT1_THS_YH, buffer);\n\treturn buffer[0];\n}\n\n/** Set the threshold for a low interrupt on the Y axis\n * @param threshold New threshold for a low interrupt on the Y axis\n * @see L3G4200D_INT1_THS_YL\n */\nvoid L3G4200D::setYLowThreshold(uint8_t threshold) {\n    I2Cdev::writeByte(devAddr, L3G4200D_RA_INT1_THS_YL, threshold);\n}\n\n/** Retrieve the threshold for a low interrupt on the Y axis\n * @return Y low interrupt threshold\n * @see L3G4200D_INT1_THS_YL\n */\nuint8_t L3G4200D::getYLowThreshold() {\n\tI2Cdev::readByte(devAddr, L3G4200D_RA_INT1_THS_YL, buffer);\n\treturn buffer[0];\n}\n\n/** Set the threshold for a high interrupt on the Z axis\n * @param threshold New threshold for a high interrupt on the Z axis\n * @see L3G4200D_INT1_THS_ZH\n */\nvoid L3G4200D::setZHighThreshold(uint8_t threshold) {\n    I2Cdev::writeByte(devAddr, L3G4200D_RA_INT1_THS_ZH, threshold);\n}\n\n/** Retrieve the threshold for a high interrupt on the Z axis\n * @return Z high interrupt threshold\n * @see L3G4200D_INT1_THS_ZH\n */\nuint8_t L3G4200D::getZHighThreshold() {\n\tI2Cdev::readByte(devAddr, L3G4200D_RA_INT1_THS_ZH, buffer);\n\treturn buffer[0];\n}\n\n/** Set the threshold for a low interrupt on the Z axis\n * @param threshold New threshold for a low interrupt on the Z axis\n * @see L3G4200D_RA_INT1_THS_ZL\n */\nvoid L3G4200D::setZLowThreshold(uint8_t threshold) {\n    I2Cdev::writeByte(devAddr, L3G4200D_RA_INT1_THS_ZL, threshold);\n}\n\n/** Retrieve the threshold for a low interrupt on the Z axis\n * @return Z low interrupt threshold\n * @see L3G4200D_INT1_THS_ZL\n */\nuint8_t L3G4200D::getZLowThreshold() {\n\tI2Cdev::readByte(devAddr, L3G4200D_RA_INT1_THS_ZL, buffer);\n\treturn buffer[0];\n}\n\n// INT1_DURATION register, r/w\n\n/* Set the minimum duration for an interrupt event to be recognized\n * This depends on the chosen output data rate\n * @param duration New duration necessary for an interrupt event to be \n * recognized\n * @see L3G4200D_RA_INT1_DURATION\n * @see L3G4200D_INT1_DUR_BIT\n * @see L3G4200D_INT1_DUR_LENGTH\n */\nvoid L3G4200D::setDuration(uint8_t duration) {\n\tI2Cdev::writeBits(devAddr, L3G4200D_RA_INT1_DURATION, L3G4200D_INT1_DUR_BIT,\n\t\tL3G4200D_INT1_DUR_LENGTH, duration);\n}\n\n/** Get the minimum duration for an interrupt event to be recognized\n * @return Duration necessary for an interrupt event to be recognized\n * @see L3G4200D_RA_INT1_DURATION\n * @see L3G4200D_INT1_DUR_BIT\n * @see L3G4200D_INT1_DUR_LENGTH\n */\nuint8_t L3G4200D::getDuration() {\n\tI2Cdev::readBits(devAddr, L3G4200D_RA_INT1_DURATION, \n\t\tL3G4200D_INT1_DUR_BIT, L3G4200D_INT1_DUR_LENGTH, buffer);\n\treturn buffer[0];\n}\n\n/** Set whether the interrupt wait feature is enabled\n * If false, the interrupt falls immediately if signal crosses the selected \n * threshold. Otherwise, if signal crosses the selected threshold, the interrupt\n * falls only after the duration has counted number of samples at the selected \n * data rate, written into the duration counter register.\n * @param enabled New enabled state of the interrupt wait\n * @see L3G4200D_RA_INT1_DURATION\n * @see L3G4200D_INT1_WAIT_BIT\n */\nvoid L3G4200D::setWaitEnabled(bool enabled) {\n\tI2Cdev::writeBit(devAddr, L3G4200D_RA_INT1_DURATION, L3G4200D_INT1_WAIT_BIT,\n\t\tenabled);\n}\n\n/** Get whether the interrupt wait feature is enabled\n * @return True if the wait feature is enabled, false otherwise\n * @see L3G4200D_RA_INT1_DURATION\n * @see L3G4200D_INT1_WAIT_BIT\n */\nbool L3G4200D::getWaitEnabled() {\n\tI2Cdev::readBit(devAddr, L3G4200D_RA_INT1_DURATION, \n\t\tL3G4200D_INT1_WAIT_BIT, buffer);\n\treturn buffer[0];\n}\n'