b'# function to split up DESeqDataSet by rows during easily parallelizable steps\n\n# TODO: recombining the resulting DESeqDataSets using rbind() is a bit wasteful,\n# as the count matrix and GRanges from the original object are unchanged\n\nDESeqParallel <- function(object, test, fitType, betaPrior, full, reduced,\n                          quiet, modelMatrix, useT, minmu, BPPARAM) {\n\n  nworkers <- getNworkers(BPPARAM)\n  idx <- factor(sort(rep(seq_len(nworkers),length.out=nrow(object))))\n\n  checkForExperimentalReplicates(object, modelMatrix)\n  \n  # first parallel execution: gene-wise dispersion estimates\n  if (!quiet) message("estimating dispersions")\n  if (!quiet) message(paste("gene-wise dispersion estimates:",nworkers,"workers"))\n\n  object <- do.call(rbind, bplapply(levels(idx), function(l) {\n    estimateDispersionsGeneEst(object[idx == l,], quiet=TRUE, modelMatrix=modelMatrix, minmu=minmu)\n  }, BPPARAM=BPPARAM))\n\n  # this is needed bc rbind on SummarizedExperiment will proliferate metadata lists\n  metadata(object) <- metadata(object)[unique(names(metadata(object)))]\n\n  # the dispersion fit and dispersion prior are estimated over all rows\n  if (!quiet) message("mean-dispersion relationship") \n  object <- estimateDispersionsFit(object, fitType=fitType)\n  dispPriorVar <- estimateDispersionsPriorVar(object, modelMatrix=modelMatrix)\n\n  # need to condition on whether a beta prior needs to be fit\n  if (betaPrior) {\n    # second parallel execution: fit the final dispersion estimates and MLE betas \n    if (!quiet) message(paste("final dispersion estimates, MLE betas:",nworkers,"workers"))\n    object <- do.call(rbind, bplapply(levels(idx), function(l) {\n      objectSub <- estimateDispersionsMAP(object[idx == l,],\n                                          dispPriorVar=dispPriorVar, quiet=TRUE)\n      estimateMLEForBetaPriorVar(objectSub)\n    }, BPPARAM=BPPARAM))\n    # the beta prior is estimated over all rows\n    betaPriorVar <- estimateBetaPriorVar(object)\n    # the third parallel execution: the final GLM and statistics\n    if (!quiet) message(paste("fitting model and testing:",nworkers,"workers"))\n    object <- do.call(rbind, bplapply(levels(idx), function(l) {\n      nbinomWaldTest(object[idx == l,],\n                     betaPrior=TRUE,\n                     betaPriorVar=betaPriorVar,\n                     quiet=TRUE, useT=useT, minmu=minmu)\n    }, BPPARAM=BPPARAM))\n  } else {\n    # or, if no beta prior to fit,\n    # second parallel execution: fit the final dispersion estimates and the final GLM and statistics\n    if (!quiet) message(paste("final dispersion estimates, fitting model and testing:",nworkers,"workers"))\n    if (test == "Wald") {\n      object <- do.call(rbind, bplapply(levels(idx), function(l) {\n        objectSub <- estimateDispersionsMAP(object[idx == l,],\n                                            dispPriorVar=dispPriorVar, quiet=TRUE, modelMatrix=modelMatrix)\n        nbinomWaldTest(objectSub, betaPrior=FALSE,\n                       quiet=TRUE, modelMatrix=modelMatrix,\n                       useT=useT, minmu=minmu)\n      }, BPPARAM=BPPARAM))\n    } else if (test == "LRT") {\n      object <- do.call(rbind, bplapply(levels(idx), function(l) {\n        objectSub <- estimateDispersionsMAP(object[idx == l,],\n                                            dispPriorVar=dispPriorVar, quiet=TRUE, modelMatrix=modelMatrix)\n        nbinomLRT(objectSub, full=full, reduced=reduced, quiet=TRUE, minmu=minmu)\n      }, BPPARAM=BPPARAM))\n    } \n  }\n\n  # this is needed bc rbind on SummarizedExperiment will proliferate metadata lists\n  metadata(object) <- metadata(object)[unique(names(metadata(object)))]\n  \n  object\n}\n\ngetNworkers <- function(BPPARAM) {\n  nworkers <- bpworkers(BPPARAM)\n  if (!nworkers[[1]]) {\n    nworkers <- 1 # serial param gives a list with the element FALSE\n  }\n  nworkers\n}\n'