b"{-# LANGUAGE Arrows #-}\n{-# LANGUAGE CPP    #-}\n-- |\n-- Copyright  : (c) Ivan Perez and Manuel Baerenz, 2016\n-- License    : BSD3\n-- Maintainer : ivan.perez@keera.co.uk\n--\n-- Useful auxiliary functions and definitions.\nmodule Data.MonadicStreamFunction.Util where\n\n-- External imports\nimport Control.Arrow    (arr, returnA, (&&&), (<<<), (>>>))\nimport Control.Category (id, (.))\nimport Control.Monad    (when)\nimport Data.VectorSpace (VectorSpace, zeroVector, (^+^))\nimport Prelude          hiding (id, (.))\n\n#if !MIN_VERSION_base(4,8,0)\nimport Data.Monoid (Monoid, mempty, mappend)\n#endif\n\n-- Internal imports\nimport Data.MonadicStreamFunction.Core                  (MSF, arrM, feedback)\nimport Data.MonadicStreamFunction.Instances.ArrowChoice ()\n\n-- * Streams and sinks\n\n-- | A stream is an 'MSF' that produces outputs, while ignoring the input. It\n-- can obtain the values from a monadic context.\ntype MStream m a = MSF m () a\n\n-- | A sink is an 'MSF' that consumes inputs, while producing no output. It\n-- can consume the values with side effects.\ntype MSink m a = MSF m a ()\n\n-- * Analogues of 'map' and 'fmap'\n\n-- | Apply an 'MSF' to every input. Freezes temporarily if the input is\n-- 'Nothing', and continues as soon as a 'Just' is received.\nmapMaybeS :: Monad m => MSF m a b -> MSF m (Maybe a) (Maybe b)\nmapMaybeS msf = proc maybeA -> case maybeA of\n  Just a  -> arr Just <<< msf -< a\n  Nothing -> returnA          -< Nothing\n\n-- * Adding side effects\n\n-- | Applies a function to produce an additional side effect and passes the\n-- input unchanged.\nwithSideEffect :: Monad m => (a -> m b) -> MSF m a a\nwithSideEffect method = (id &&& arrM method) >>> arr fst\n\n-- | Produces an additional side effect and passes the input unchanged.\nwithSideEffect_ :: Monad m => m b -> MSF m a a\nwithSideEffect_ method = withSideEffect $ const method\n\n-- * Delays\n\n-- | Delay a signal by one sample.\niPre :: Monad m\n     => a         -- ^ First output\n     -> MSF m a a\niPre firsta = feedback firsta $ arr swap\n  where\n    swap (a, b) = (b, a)\n\n-- | Preprends a fixed output to an 'MSF'. The first input is completely\n-- ignored.\niPost :: Monad m => b -> MSF m a b -> MSF m a b\niPost b sf = sf >>> (feedback (Just b) $ arr $ \\(c, ac) -> case ac of\n  Nothing -> (c, Nothing)\n  Just b' -> (b', Nothing))\n\n-- | Preprends a fixed output to an 'MSF', shifting the output.\nnext :: Monad m => b -> MSF m a b -> MSF m a b\nnext b sf = sf >>> iPre b\n\n-- | Buffers and returns the elements in FIFO order, returning 'Nothing'\n-- whenever the buffer is empty.\nfifo :: Monad m => MSF m [a] (Maybe a)\nfifo = feedback [] (arr (safeSnoc . uncurry fifoAppend))\n  where\n    -- | Append a new list to an accumulator in FIFO order.\n    fifoAppend :: [x] -> [x] -> [x]\n    fifoAppend as accum = accum ++ as\n\n    -- | Split a list into the head and the tail.\n    safeSnoc :: [x] -> (Maybe x, [x])\n    safeSnoc []     = (Nothing, [])\n    safeSnoc (x:xs) = (Just x, xs)\n\n-- * Folding\n\n-- ** Folding for 'VectorSpace' instances\n\n-- | Count the number of simulation steps. Produces 1, 2, 3,...\ncount :: (Num n, Monad m) => MSF m a n\ncount = arr (const 1) >>> accumulateWith (+) 0\n\n-- | Sums the inputs, starting from zero.\nsumS :: (VectorSpace v s, Monad m) => MSF m v v\nsumS = sumFrom zeroVector\n\n-- | Sums the inputs, starting from an initial vector.\nsumFrom :: (VectorSpace v s, Monad m) => v -> MSF m v v\nsumFrom = accumulateWith (^+^)\n\n-- ** Folding for monoids\n\n-- | Accumulate the inputs, starting from 'mempty'.\nmappendS :: (Monoid n, Monad m) => MSF m n n\nmappendS = mappendFrom mempty\n{-# INLINE mappendS #-}\n\n-- | Accumulate the inputs, starting from an initial monoid value.\nmappendFrom :: (Monoid n, Monad m) => n -> MSF m n n\nmappendFrom = accumulateWith mappend\n\n-- ** Generic folding \\/ accumulation\n\n-- | Applies a function to the input and an accumulator, outputting the updated\n-- accumulator. Equal to @\\f s0 -> feedback s0 $ arr (uncurry f >>> dup)@.\naccumulateWith :: Monad m => (a -> s -> s) -> s -> MSF m a s\naccumulateWith f s0 = feedback s0 $ arr g\n  where\n    g (a, s) = let s' = f a s in (s', s')\n\n-- | Applies a transfer function to the input and an accumulator, returning the\n-- updated accumulator and output.\nmealy :: Monad m => (a -> s -> (b, s)) -> s -> MSF m a b\nmealy f s0 = feedback s0 $ arr $ uncurry f\n\n-- * Unfolding\n\n-- | Generate outputs using a step-wise generation function and an initial\n-- value.\nunfold :: Monad m => (a -> (b, a)) -> a -> MSF m () b\nunfold f a = feedback a (arr (snd >>> f))\n\n-- | Generate outputs using a step-wise generation function and an initial\n-- value. Version of 'unfold' in which the output and the new accumulator are\n-- the same. Should be equal to @\\f a -> unfold (f >>> dup) a@.\nrepeatedly :: Monad m => (a -> a) -> a -> MSF m () a\nrepeatedly f = unfold $ f >>> dup\n  where\n    dup a = (a, a)\n\n-- * Debugging\n\n-- | Outputs every input sample, with a given message prefix.\ntrace :: Show a => String -> MSF IO a a\ntrace = traceWith putStrLn\n\n-- | Outputs every input sample, with a given message prefix, using an\n-- auxiliary printing function.\ntraceWith :: (Monad m, Show a) => (String -> m ()) -> String -> MSF m a a\ntraceWith method msg =\n  withSideEffect (method . (msg ++) . show)\n\n-- | Outputs every input sample, with a given message prefix, using an\n-- auxiliary printing function, when a condition is met.\ntraceWhen :: (Monad m, Show a)\n          => (a -> Bool)\n          -> (String -> m ())\n          -> String\n          -> MSF m a a\ntraceWhen cond method msg = withSideEffect $ \\a ->\n  when (cond a) $ method $ msg ++ show a\n\n-- | Outputs every input sample, with a given message prefix, when a condition\n-- is met, and waits for some input \\/ enter to continue.\npauseOn :: Show a => (a -> Bool) -> String -> MSF IO a a\npauseOn cond = traceWhen cond $ \\s -> print s >> getLine >> return ()\n"