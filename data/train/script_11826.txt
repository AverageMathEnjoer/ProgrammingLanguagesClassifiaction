b'type Expression = [Term]\ntype Term = [Factor] \ntype Factor = [Digit] \ntype Digit = Int\n\ndigits :: Factor\ndigits = [1 .. 9]\n\nvalExpr :: Expression -> Int \nvalExpr = sum . map valTerm\n\nvalTerm :: Term -> Int\nvalTerm = product . map valFact \n\nvalFact :: Factor -> Int\nvalFact = foldl1 (\\n d -> 10 * n + d)\n\nexpressions :: [Digit] -> [Expression] \nexpressions = concatMap partitions . partitions\n\npartitions [] = [[]]\npartitions (x:xs) = [[x]:p | p <- partitions xs]\n                 ++ [(x:ys):yss | (ys:yss) <- partitions xs]\n\ngood :: Int -> Bool\ngood v = v == 100\n\ngoodOnes :: [Digit] -> [Expression]\ngoodOnes = filter (good . valExpr) . expressions\n\n'