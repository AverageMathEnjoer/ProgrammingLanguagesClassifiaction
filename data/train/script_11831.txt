b'#\' Convert Summarytools Objects into Tibbles\n#\'\n#\' Make a tidy dataset out of freq() or descr() outputs\n#\'\n#\' @param x a freq() or descr() output object.\n#\' @param order Integer. Useful for grouped results produced with\n#\'  \\code{\\link{stby}} or \\code{dplyr::group_by}. When set to \\code{1}\n#\'   (default), the ordering is done using the grouping variables first. When\n#\'   set to \\code{2}, the ordering is first determined by the \\code{variable}\n#\'   column for \\code{\\link{descr}} or the column displaying the variable\n#\'   values for \\code{\\link{freq}}. When set to \\code{3}, the same ordering\n#\'   as with \\code{2} is used, but columns are rearranged to reflect this\n#\'   sort order.\n#\' @param na.rm Logical. For \\code{\\link{freq}} objects, remove \\code{<NA>} rows\n#\'   (or \\code{(Missing)} rows if \\code{NA} values were made explicit with\n#\'   \\code{forcats::fct_explicit_na()}. Has no effect on \\code{\\link{descr}}\n#\'   objects.\n#\' @param drop.var.col Logical. For \\code{\\link{descr}} objects, drop the\n#\'   \\code{variable} column. This is possible only when statistics are\n#\'   produced for a single variable; for multiple variables, this argument\n#\'   is ignored. \\code{FALSE} by default.\n#\'\n#\' @return A \\code{\\link[tibble]{tibble}} which is constructed following the\n#\' \\emph{tidy} principles.\n#\'\n#\' @examples\n#\'\n#\' tb(freq(iris$Species))\n#\' tb(descr(iris))\n#\'\n#\' data("tobacco")\n#\' tb(stby(tobacco, tobacco$gender, descr))\n#\'\n#\' @importFrom tibble tibble as_tibble\n#\' @importFrom dplyr bind_rows bind_cols\n#\' @export\ntb <- function(x, order = 1, na.rm = FALSE, drop.var.col = FALSE) {\n\n  if (!inherits(x, c("summarytools", "stby"))) {\n    stop("x must be an object of class \'summarytools\' or \'stby\'")\n  }\n\n  errmsg <- check_args_tb(match.call())\n\n  if (length(errmsg) > 0) {\n    stop(paste(errmsg, collapse = "\\n  "))\n  }\n\n  if (inherits(x, "stby")) {\n\n    grp_stats <- lapply(x, tb, na.rm = na.rm, drop.var.col = FALSE)\n\n    if ("groups" %in% names(attributes(x))) {\n      left_part <- as_tibble(\n        merge(grp_stats[[1]][,1], attr(x, "groups"), all = TRUE)[,-1]\n      )\n      \n      if (identical(colnames(left_part), "value")) {\n        # for special case of descr\n        colnames(left_part) <- colnames(attr(x, "group"))\n      }\n      grp_values <- attr(x, "groups")\n    \n    } else {\n      \n      null_grs     <- which(vapply(x, is.null, TRUE))\n      non_null_grs <- setdiff(seq_along(x), null_grs)\n      grp_values   <- as_tibble(expand.grid(attr(x, "dimnames")))[non_null_grs,]\n      if (length(intersect(colnames(grp_values),\n                           colnames(grp_stats[[non_null_grs[1]]][,1])))) {\n        stop(colnames(grp_stats[[non_null_grs[1]]][,1]), " is both a grouping ",\n             "variable and an analysis variable; tidy table impossible to ",\n             "generate")\n      }\n\n      left_part <- as_tibble(merge(grp_stats[[non_null_grs[1]]][,1],\n                                   grp_values, all = TRUE))[,-1]\n    }\n\n    nb_gr_var  <- ncol(left_part)\n    right_part <- bind_rows(grp_stats)\n\n    if (attr(x[[1]], "st_type") == "descr" &&\n        all(right_part$variable == "value") && length(names(grp_values)) == 1) {\n      right_part$variable <- attr(x[[1]], "data_info")$Variable\n    }\n    output <- bind_cols(left_part, right_part)\n\n    colnames(output)[1:ncol(left_part)] <-\n      sub("(.+)\\\\$(.+)", "\\\\2", colnames(output)[1:ncol(left_part)])\n    if (order == 1) {\n    } else if (order %in% 2:3) {\n      output <- \n        output[do.call(what = "order",\n                       args = unname(output[ ,c(nb_gr_var + 1, 1:nb_gr_var)])), ]\n      if (order == 3) {\n        output <- output[ ,c(nb_gr_var + 1,\n                             1:(nb_gr_var),\n                             (nb_gr_var + 2):ncol(output))]\n      }\n    }\n\n    if (attr(x[[1]], "st_type") == "freq") {\n\n      if ("pct_valid" %in% colnames(output)) {\n        output$pct_valid <- output$pct_valid / nrow(grp_values)\n        output$pct_tot   <- output$pct_tot   / nrow(grp_values)\n      } else {\n        output$pct <- output$pct / nrow(grp_values)\n      }\n\n      if ("pct_valid_cum" %in% colnames(output)) {\n        tmp_nomiss <- output$pct_valid\n        tmp_nomiss[is.na(tmp_nomiss)] <- 0\n        output$pct_valid_cum <- cumsum(tmp_nomiss)\n        output$pct_tot_cum <- cumsum(output$pct_tot)\n      }\n\n      if ("pct_cum" %in% colnames(output)) {\n        output$pct_cum <- cumsum(output$pct)\n      }\n\n    }\n\n    return(output)\n  }\n\n  if (!is.null(x) && attr(x, "st_type") == "freq") {\n\n    output <- as_tibble(cbind(rownames(x), as.data.frame(x)))\n    varname <- na.omit(c(attr(x, "data_info")$Variable, "value"))[1]\n    names(output) <-\n      c(varname, "freq", "pct_valid", "pct_valid_cum", "pct_tot", "pct_tot_cum")\n\n    # remove totals row\n    output <- output[1:(nrow(output) - 1), ]\n\n    # remove na info when appropriate\n    if (!isTRUE(attr(x, "format_info")[["report.nas"]]) || isTRUE(na.rm)) {\n      output <- output[1:(nrow(output) - 1),\n                       -grep("^pct_(tot|tot_cum)$", names(output))]\n      names(output)[3:4] <- c("pct", "pct_cum")\n    }\n\n    # remove cumulative columns when appropriate\n    if (!isTRUE(attr(x, "format_info")[["cumul"]])) {\n      output <- output[ , -grep("_cum", names(output))]\n    }\n\n    output[[varname]] <- factor(output[[varname]], levels = output[[varname]])\n    return(output)\n\n  } else if (!is.null(x) && attr(x, "st_type") == "descr") {\n\n    if (!isTRUE(attr(x, "data_info")$transposed)) {\n      output <- as_tibble(t(as.data.frame(x)), rownames = "variable")\n      names(output) <- c("variable", attr(x, "stats"))\n    } else {\n      output <- as_tibble(as.data.frame(x), rownames = "variable")\n      names(output) <- c("variable", attr(x, "stats"))\n    }\n\n    if (isTRUE(drop.var.col) && length(unique(output$variable)) == 1) {\n      output$variable <- NULL\n    }\n\n    return(output)\n\n  } else if (is.null(x)) {\n    return(list())\n  } else {\n    stop("tb() supports summarytools freq() and descr() objects only")\n  }\n}\n'