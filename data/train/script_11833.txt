b'{-# LANGUAGE CPP #-}\n#if !defined(TESTING) && defined(__GLASGOW_HASKELL__)\n{-# LANGUAGE Safe #-}\n#endif\n\n#include "containers.h"\n\n-----------------------------------------------------------------------------\n-- |\n-- Module      :  Data.IntMap.Lazy\n-- Copyright   :  (c) Daan Leijen 2002\n--                (c) Andriy Palamarchuk 2008\n-- License     :  BSD-style\n-- Maintainer  :  libraries@haskell.org\n-- Portability :  portable\n--\n--\n-- = Finite Int Maps (lazy interface)\n--\n-- The @\'IntMap\' v@ type represents a finite map (sometimes called a dictionary)\n-- from keys of type @Int@ to values of type @v@.\n--\n-- The functions in "Data.IntMap.Strict" are careful to force values before\n-- installing them in an \'IntMap\'. This is usually more efficient in cases where\n-- laziness is not essential. The functions in this module do not do so.\n--\n-- For a walkthrough of the most commonly used functions see the\n-- <https://haskell-containers.readthedocs.io/en/latest/map.html maps introduction>.\n--\n-- This module is intended to be imported qualified, to avoid name clashes with\n-- Prelude functions:\n--\n-- > import Data.IntMap.Lazy (IntMap)\n-- > import qualified Data.IntMap.Lazy as IntMap\n--\n-- Note that the implementation is generally /left-biased/. Functions that take\n-- two maps as arguments and combine them, such as `union` and `intersection`,\n-- prefer the values in the first argument to those in the second.\n--\n--\n-- == Detailed performance information\n--\n-- The amortized running time is given for each operation, with \\(n\\) referring to\n-- the number of entries in the map and \\(W\\) referring to the number of bits in\n-- an \'Int\' (32 or 64).\n--\n-- Benchmarks comparing "Data.IntMap.Lazy" with other dictionary\n-- implementations can be found at https://github.com/haskell-perf/dictionaries.\n--\n--\n-- == Implementation\n--\n-- The implementation is based on /big-endian patricia trees/.  This data\n-- structure performs especially well on binary operations like \'union\' and\n-- \'intersection\'. Additionally, benchmarks show that it is also (much) faster\n-- on insertions and deletions when compared to a generic size-balanced map\n-- implementation (see "Data.Map").\n--\n--    * Chris Okasaki and Andy Gill,  \\"/Fast Mergeable Integer Maps/\\",\n--      Workshop on ML, September 1998, pages 77-86,\n--      <http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.37.5452>\n--\n--    * D.R. Morrison, \\"/PATRICIA -- Practical Algorithm To Retrieve Information Coded In Alphanumeric/\\",\n--      Journal of the ACM, 15(4), October 1968, pages 514-534.\n--\n-----------------------------------------------------------------------------\n\nmodule Data.IntMap.Lazy (\n    -- * Map type\n#if !defined(TESTING)\n    IntMap, Key          -- instance Eq,Show\n#else\n    IntMap(..), Key          -- instance Eq,Show\n#endif\n\n    -- * Construction\n    , empty\n    , singleton\n    , fromSet\n\n    -- ** From Unordered Lists\n    , fromList\n    , fromListWith\n    , fromListWithKey\n\n    -- ** From Ascending Lists\n    , fromAscList\n    , fromAscListWith\n    , fromAscListWithKey\n    , fromDistinctAscList\n\n    -- * Insertion\n    , insert\n    , insertWith\n    , insertWithKey\n    , insertLookupWithKey\n\n    -- * Deletion\\/Update\n    , delete\n    , adjust\n    , adjustWithKey\n    , update\n    , updateWithKey\n    , updateLookupWithKey\n    , alter\n    , alterF\n\n    -- * Query\n    -- ** Lookup\n    , IM.lookup\n    , (!?)\n    , (!)\n    , findWithDefault\n    , member\n    , notMember\n    , lookupLT\n    , lookupGT\n    , lookupLE\n    , lookupGE\n\n    -- ** Size\n    , IM.null\n    , size\n\n    -- * Combine\n\n    -- ** Union\n    , union\n    , unionWith\n    , unionWithKey\n    , unions\n    , unionsWith\n\n    -- ** Difference\n    , difference\n    , (\\\\)\n    , differenceWith\n    , differenceWithKey\n\n    -- ** Intersection\n    , intersection\n    , intersectionWith\n    , intersectionWithKey\n\n    -- ** Disjoint\n    , disjoint\n\n    -- ** Compose\n    , compose\n\n    -- ** Universal combining function\n    , mergeWithKey\n\n    -- * Traversal\n    -- ** Map\n    , IM.map\n    , mapWithKey\n    , traverseWithKey\n    , traverseMaybeWithKey\n    , mapAccum\n    , mapAccumWithKey\n    , mapAccumRWithKey\n    , mapKeys\n    , mapKeysWith\n    , mapKeysMonotonic\n\n    -- * Folds\n    , IM.foldr\n    , IM.foldl\n    , foldrWithKey\n    , foldlWithKey\n    , foldMapWithKey\n\n    -- ** Strict folds\n    , foldr\'\n    , foldl\'\n    , foldrWithKey\'\n    , foldlWithKey\'\n\n    -- * Conversion\n    , elems\n    , keys\n    , assocs\n    , keysSet\n\n    -- ** Lists\n    , toList\n\n    -- ** Ordered lists\n    , toAscList\n    , toDescList\n\n    -- * Filter\n    , IM.filter\n    , filterWithKey\n    , restrictKeys\n    , withoutKeys\n    , partition\n    , partitionWithKey\n\n    , takeWhileAntitone\n    , dropWhileAntitone\n    , spanAntitone\n\n    , mapMaybe\n    , mapMaybeWithKey\n    , mapEither\n    , mapEitherWithKey\n\n    , split\n    , splitLookup\n    , splitRoot\n\n    -- * Submap\n    , isSubmapOf, isSubmapOfBy\n    , isProperSubmapOf, isProperSubmapOfBy\n\n    -- * Min\\/Max\n    , lookupMin\n    , lookupMax\n    , findMin\n    , findMax\n    , deleteMin\n    , deleteMax\n    , deleteFindMin\n    , deleteFindMax\n    , updateMin\n    , updateMax\n    , updateMinWithKey\n    , updateMaxWithKey\n    , minView\n    , maxView\n    , minViewWithKey\n    , maxViewWithKey\n\n#ifdef __GLASGOW_HASKELL__\n    -- * Debugging\n    , showTree\n    , showTreeWith\n#endif\n    ) where\n\nimport Data.IntMap.Internal as IM hiding (showTree, showTreeWith)\n#ifdef __GLASGOW_HASKELL__\nimport Data.IntMap.Internal.DeprecatedDebug\n#endif\n'