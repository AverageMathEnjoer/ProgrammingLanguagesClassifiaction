b'#\' Cross-Tabulation\n#\'\n#\' Cross-tabulation for a pair of categorical variables with either\n#\' row, column, or total proportions, as well as marginal sums. Works with\n#\' numeric, character, as well as factor variables.\n#\'\n#\' @param x First categorical variable - values will appear as row names.\n#\' @param y Second categorical variable - values will appear as column names.\n#\' @param prop Character. Indicates which proportions to show: \\dQuote{r} \n#\'   (rows, default), \\dQuote{c} (columns), \\dQuote{t} (total), or \\dQuote{n}\n#\'   (none). Default value can be changed using \\code{\\link{st_options}},\n#\'   option \\code{ctable.prop}.  \n#\' @param useNA Character. One of \\dQuote{ifany} (default), \\dQuote{no}, or \n#\'   \\dQuote{always}. This argument is passed on \\sQuote{as is} to \n#\'   \\code{\\link[base]{table}}, or adapted for \\code{\\link[stats]{xtabs}} when\n#\'   weights are used.\n#\' @param totals Logical. Show row and column totals. Defaults to\n#\'   \\code{TRUE} but can be set globally with \\code{\\link{st_options}}, option \n#\'   \\code{ctable.totals}.\n#\' @param style Character. Style to be used by \\code{\\link[pander]{pander}}. One\n#\'   of \\dQuote{simple} (default), \\dQuote{grid}, \\dQuote{rmarkdown}, or\n#\'   \\dQuote{jira}. Can be set globally with \\code{\\link{st_options}}.\n#\' @param round.digits Numeric. Number of significant digits to keep. Defaults\n#\'   to \\code{1}. To change this default value, use \\code{\\link{st_options}},\n#\'   option \\code{ctable.round.digits}.\n#\' @param justify Character. Horizontal alignment; one of \\dQuote{l} (left),\n#\'   \\dQuote{c} (center), or \\dQuote{r} (right, default).\n#\' @param plain.ascii Logical. Used by \\code{\\link[pander]{pander}}; when\n#\'   \\code{TRUE}, no markup characters are generated (useful when printing\n#\'   to console). Defaults to \\code{TRUE} unless \\code{style = \'rmarkdown\'},\n#\'   in which case it is set to \\code{FALSE} automatically. To change the \n#\'   default value globally, use \\code{\\link{st_options}}.\n#\' @param headings Logical. Show heading section. \\code{TRUE} by default; can be\n#\'   set globally with \\code{\\link{st_options}}.\n#\' @param display.labels Logical. Display data frame label in the heading \n#\'   section. \\code{TRUE} by default, can be changed globally with\n#\'   \\code{\\link{st_options}}.\n#\' @param split.tables Numeric. \\code{\\link[pander]{pander}} argument that \n#\'   specifies how many characters wide a table can be. \\code{Inf} by default.\n#\' @param dnn Character vector. Variable names to be used in output table. In\n#\'   most cases, setting this parameter is not required as the names are \n#\'   automatically generated.\n#\' @param chisq Logical. Display chi-square statistic along with p-value.\n#\' @param OR Logical or numeric. Set to \\code{TRUE} to show odds ratio with 95%\n#\'   confidence interval, or specify confidence level explicitly (\\emph{e.g.},\n#\'   \\code{.90}). CI\'s are calculated using Wald\'s method of normal approximation.\n#\' @param RR Logical or numeric. Set to \\code{TRUE} to show risk ratio (also\n#\'   called \\emph{relative risk} with 95% confidence interval, or specify\n#\'   confidence level explicitly (\\emph{e.g.} \\code{.90}). CI\'s are \n#\'   calculated using Wald\'s method of normal approximation.\n#\' @param weights Numeric. Vector of weights; must have the same length as\n#\'   \\code{x}.\n#\' @param rescale.weights Logical. When \\code{TRUE}, a global constant is\n#\'   applied so that the sum of counts equals \\code{nrow(x)}. \\code{FALSE} by\n#\'   default.\n#\' @param \\dots Additional arguments passed to \\code{\\link[pander]{pander}} or\n#\'   \\code{\\link[base]{format}}.\n#\'\n#\' @return A list containing two matrices, \\emph{cross_table} and \n#\'   \\emph{proportions}. The \\emph{print} method takes care of assembling \n#\'   figures from those matrices into a single table. The returned object is\n#\'   of classes \\dQuote{\\emph{summarytools}} and \\dQuote{\\emph{list}}, unless \n#\'   \\code{\\link[summarytools]{stby}} is used, in which case we have an\n#\'   object of class \\dQuote{\\emph{stby}}. \n#\'   \n#\' @note Markdown does not fully support multi-header tables;\n#\'   until such support is available, the recommended way to display \n#\'   cross-tables in .Rmd documents is to use `method=render`. See package\n#\'   vignettes for examples.\n#\'\n#\' @examples\n#\' data("tobacco")\n#\' ctable(tobacco$gender, tobacco$smoker)\n#\' \n#\' # Use with() to simplify syntax\n#\' with(tobacco, ctable(smoker, diseased))\n#\'\n#\' # Show column proportions, without totals\n#\' with(tobacco, ctable(smoker, diseased, prop = "c", totals = FALSE))\n#\' \n#\' # Simple 2 x 2 table with odds ratio and risk ratio\n#\' with(tobacco, ctable(gender, smoker, totals = FALSE, headings = FALSE, prop = "n",\n#\'                      OR = TRUE, RR = TRUE))\n#\' \n#\' # Grouped cross-tabulations\n#\' with(tobacco, stby(data = list(x = smoker, y = diseased), \n#\'                    INDICES = gender, FUN = ctable))\n#\'\n#\'\n#\' \\dontrun{\n#\' ct <- ctable(tobacco$gender, tobacco$smoker)\n#\' \n#\' # Show html results in browser\n#\' print(ct, method = "browser")\n#\' \n#\' # Save results to html file\n#\' print(ct, file = "ct_gender_smoker.html")\n#\' \n#\' # Save results to text file\n#\' print(ct, file = "ct_gender_smoker.txt")\n#\' }\n#\' @seealso \\code{\\link[base]{table}}, \\code{\\link[stats]{xtabs}}\n#\'\n#\' @keywords classes category\n#\' @author Dominic Comtois, \\email{dominic.comtois@@gmail.com}\n#\' @export\n#\' @importFrom stats addmargins na.omit chisq.test qnorm\nctable <- function(x, \n                   y,\n                   prop            = st_options("ctable.prop"),\n                   useNA           = "ifany",\n                   totals          = st_options("ctable.totals"),\n                   style           = st_options("style"),\n                   round.digits    = st_options("ctable.round.digits"),\n                   justify         = "right",\n                   plain.ascii     = st_options("plain.ascii"),\n                   headings        = st_options("headings"),\n                   display.labels  = st_options("display.labels"),\n                   split.tables    = Inf,\n                   dnn             = c(substitute(x), substitute(y)),\n                   chisq           = FALSE,\n                   OR              = FALSE,\n                   RR              = FALSE,\n                   weights         = NA,\n                   rescale.weights = FALSE,\n                   ...) {\n\n  # Check for group_by()\n  if (any(grepl("group_by(", deparse(sys.calls()[[1]]), fixed = TRUE))) {\n    stop("ctable() doesn\'t support group_by(); use stby() instead")\n  }\n\n  # Support for by()\n  if (length(dim(x)) == 2) {\n    x_tmp <- x[[1]]\n    y <- x[[2]]\n    x <- x_tmp\n    flag_by <- TRUE\n  } else {\n    flag_by <- FALSE\n  }\n  \n  # Convert 1-column data frames into vectors\n  if (inherits(x, "data.frame") && ncol(x) == 1) {\n    x <- x[[1]]\n  }\n  \n  if (inherits(y, "data.frame") && ncol(y) == 1) {\n    y <- y[[1]]\n  }\n  \n  # Validate arguments ---------------------------------------------------------\n  errmsg <- character()  # problems with arguments will be stored here\n  \n  if (!is.factor(x) && !is.atomic(x)) {\n    x <- try(as.vector(x), silent = TRUE)\n    if (inherits(x, "try-error")) {\n      errmsg %+=% "\'x\' must be a factor or an object coercible to a vector"\n    }\n  }\n\n  if (!is.factor(y) && !is.atomic(x)) {\n    y <- try(as.vector(y), silent = TRUE)\n    if (inherits(y, "try-error")) {\n      errmsg %+=% "\'y\' must be a factor or an object coercible to a vector"\n    }\n  }\n\n  errmsg <- c(errmsg, check_args(match.call(), list(...)))\n  \n  if (length(errmsg) > 0) {\n    stop(paste(errmsg, collapse = "\\n  "))\n  }\n  \n  # When style is rmarkdown, make plain.ascii FALSE unless specified explicitly\n  if (style == "rmarkdown" && isTRUE(plain.ascii) && \n      (!"plain.ascii" %in% (names(match.call())))) {\n    plain.ascii <- FALSE\n  }\n\n  # Replace NaN\'s by NA\'s (This simplifies matters a lot)\n  if (NaN %in% x) {\n    message(paste(sum(is.nan(x)), "NaN value(s) converted to NA in x\\n"))\n    x[is.nan(x)] <- NA\n  }\n\n  if (NaN %in% y) {\n    message(paste(sum(is.nan(y)), "NaN value(s) converted to NA in y\\n"))\n    y[is.nan(y)] <- NA\n  }\n\n  # Get x & y metadata from parsing function\n  if (isTRUE(flag_by)) {\n    parse_info_x <- try(\n      parse_args(sys.calls(), sys.frames(), match.call(), \n                 var = c("x", "y"), silent = "dnn" %in% names(match.call()),\n                 var_label = FALSE, caller = "ctable"),\n      silent = TRUE)\n    \n    if (inherits(parse_info_x, "try-error")) {\n      parse_info_x <- list()\n    } else {\n      if (!is.null(parse_info_x$df_name)) {\n        df_name <- parse_info_x$df_name\n      }\n      if (!is.null(parse_info_x$df_label)) {\n        df_label <- parse_info_x$df_label\n      }\n    }\n  } else {\n    parse_info_x <- try(\n      parse_args(sys.calls(), sys.frames(), match.call(), \n                 var = "x", silent = "dnn" %in% names(match.call()),\n                 var_label = FALSE, caller = "ctable"),\n      silent = TRUE)\n    \n    if (inherits(parse_info_x, "try-error")) {\n      parse_info_x <- list()\n    }\n    \n    parse_info_y <- try(\n      parse_args(sys.calls(), sys.frames(), match.call(), \n                 var = "y", silent = "dnn" %in% names(match.call()),\n                 var_label = FALSE, caller = "ctable"),\n      silent = TRUE)\n    \n    if (inherits(parse_info_y, "try-error")) {\n      parse_info_y <- list()\n    }\n    \n    if (length(parse_info_x$df_name) == 1 &&\n        length(parse_info_y$df_name) == 1 &&\n        isTRUE(parse_info_x$df_name == parse_info_y$df_name)) {\n      df_name <- parse_info_x$df_name\n    }\n  \n    if (length(parse_info_x$df_label) == 1) {\n      df_label <- parse_info_x$df_label\n    }\n  }\n  \n  if ("dnn" %in% names(match.call())) {\n    x_name <- dnn[1]\n    y_name <- dnn[2]\n  } else if (!isTRUE(flag_by)) {\n    x_name <- na.omit(c(parse_info_x$var_name, deparse(dnn[[1]])))[1]\n    y_name <- na.omit(c(parse_info_y$var_name, deparse(dnn[[2]])))[1]\n  } else {\n    x_name <- na.omit(c(parse_info_x$var_name[1], deparse(dnn[[1]])))[1]\n    y_name <- na.omit(c(parse_info_x$var_name[2], deparse(dnn[[2]])))[1]\n  }\n\n  # Create xfreq table ---------------------------------------------------------\n  if (identical(NA, weights)) {\n    freq_table <- table(x, y, useNA = useNA)\n    # Generate minimal table for calculation of chi-square, OR and RR\n    freq_table_min <- table(x, y, useNA = "no")\n  } else {\n    # Weights are used\n    weights_string <- deparse(substitute(weights))\n    \n    # Subset weights when called from by()/stby() to match current data subset\n    if (isTRUE(flag_by)) {\n      pf <- parent.frame(2)\n      weights <- weights[pf$X[[pf$i]]]\n    }\n    \n    if (sum(is.na(weights)) > 0) {\n      warning("missing values on weight variable have been detected and were ",\n              "treated as zeroes")\n      weights[is.na(weights)] <- 0\n    }\n    \n    if (isTRUE(rescale.weights)) {\n      weights <- weights / sum(weights) * length(x)\n    }\n    \n    if (useNA == "no") {\n      freq_table <- xtabs(weights ~ x + y, addNA = FALSE)\n      freq_table_min <- freq_table\n    } else {\n      freq_table <- xtabs(weights ~ x + y, addNA = TRUE)\n      freq_table_min <- xtabs(weights ~ x + y, addNA = FALSE)\n    }\n  }\n  \n  names(dimnames(freq_table)) <- c(x_name, y_name)\n\n  prop_table <- switch(prop,\n                       t = prop.table(freq_table),\n                       r = prop.table(freq_table, 1),\n                       c = prop.table(freq_table, 2),\n                       n = NULL)\n\n  # Add totals\n  freq_table <- addmargins(freq_table)\n  rownames(freq_table)[nrow(freq_table)] <- trs("total")\n  colnames(freq_table)[ncol(freq_table)] <- trs("total")\n  \n  if (!is.null(prop_table)) {\n    prop_table[is.nan(prop_table)] <- 0\n    if (prop == "t") {\n      prop_table <- addmargins(prop_table)\n    } else if (prop == "r") {\n      prop_table <- addmargins(prop_table, 2)\n      sum_props <- c(prop.table(freq_table[nrow(freq_table),\n                                           -ncol(freq_table)]),\n                     Total = 1)\n      prop_table <- rbind(prop_table, sum_props)\n    } else if (prop == "c") {\n      prop_table <- addmargins(prop_table, 1)\n      sum_props <- c(prop.table(freq_table[-nrow(freq_table), \n                                           ncol(freq_table)]),\n                     Total = 1)\n      prop_table <- cbind(prop_table, sum_props)\n    }\n    rownames(prop_table)[nrow(prop_table)] <- trs("total")\n    colnames(prop_table)[ncol(prop_table)] <- trs("total")\n  }\n\n  # Change name of NA items to avoid potential problems when echoing to console\n  if (NA %in% rownames(freq_table)) {\n    row.names(freq_table)[is.na(row.names(freq_table))] <- "<NA>"\n    if (prop != "n") {\n      row.names(prop_table)[is.na(row.names(prop_table))] <- "<NA>"\n    }\n  }\n\n  if (NA %in% colnames(freq_table)) {\n    colnames(freq_table)[is.na(colnames(freq_table))] <- "<NA>"\n    if (prop != "n") {\n      colnames(prop_table)[is.na(colnames(prop_table))] <- "<NA>"\n    }\n  }\n\n  # Create output object -------------------------------------------------------\n  \n  output <- list(cross_table = freq_table, \n                 proportions = prop_table)\n  \n  # Set output object\'s attributes\n  class(output) <- c("summarytools", class(output))\n  attr(output, "st_type") <- "ctable"\n  attr(output, "fn_call") <- match.call()\n  attr(output, "date") <- Sys.Date()\n\n  if (isTRUE(chisq)) {\n    tmp.chisq <- chisq.test(freq_table_min)\n    tmp.chisq <- c(Chi.squared = round(tmp.chisq$statistic[[1]], 4), \n                   tmp.chisq$parameter, \n                   p.value = round(tmp.chisq$p.value, 4))\n    attr(output, "chisq") <- tmp.chisq\n  }\n  \n  if (!isFALSE(OR) || !isFALSE(RR)) {\n    if (identical(as.numeric(dim(freq_table_min)), c(2,2))) {\n      if (!isFALSE(OR)) {\n        or <- prod(freq_table_min[c(1,4)]) / prod(freq_table_min[c(2,3)])\n        se <- sqrt(sum(1/freq_table_min))\n        attr(output, "OR") <- c(or,\n                                exp(log(or) - qnorm(p = 1 - ((1 - OR)/2)) * se),\n                                exp(log(or) + qnorm(p = 1 - ((1 - OR)/2)) * se))\n        names(attr(output, "OR")) <- c("Odds Ratio", paste0("Lo - ", OR * 100, "%"),\n                                       paste0("Hi - ", OR * 100, "%"))\n        attr(output, "OR-level") <- OR\n      }\n      \n      if (!isFALSE(RR)) {\n        rr <- (freq_table_min[1] / sum(freq_table_min[c(1,3)])) / \n          (freq_table_min[2] / sum(freq_table_min[c(2,4)]))\n        se <- sqrt(sum(1/freq_table_min[1], \n                       1/freq_table_min[2],\n                       -1/sum(freq_table_min[c(1,3)]), \n                       -1/sum(freq_table_min[c(2,4)])))\n        attr(output, "RR") <- c(rr,\n                                exp(log(rr) - qnorm(p = 1 - ((1 - RR)/2)) * se),\n                                exp(log(rr) + qnorm(p = 1 - ((1 - RR)/2)) * se))\n        names(attr(output, "RR")) <- c("Risk Ratio", paste0("Lo - ", RR * 100, "%"), \n                                       paste0("Hi - ", RR * 100, "%"))\n        attr(output, "RR-level") <- RR\n      }\n    } else {\n      message("OR and RR can only be used with 2 x 2 tables; parameter(s) ignored")\n    }\n  }  \n\n  # Determine data "type" for x, in a non-strict way\n  if (all(c("ordered", "factor") %in% class(x))) {\n    Data.type.x <- trs("factor.ordered")\n  } else if ("factor" %in% class(x)) {\n    Data.type.x <- trs("factor")\n  } else if (all(c("POSIXct", "POSIXt") %in% class(x))) { \n    Data.type.x <- trs("datetime")\n  } else if ("Date" %in% class(x)) {\n    Data.type.x <- trs("date")\n  } else if ("logical" %in% class(x)) {\n    Data.type.x <- trs("logical")\n  } else if ("character" %in% class(x)) {\n    Data.type.x <- trs("character")\n  } else if ("integer" %in% class(x)) {\n    Data.type.x <- trs("integer")\n  } else if ("numeric" %in% class(x)) {\n    Data.type.x <- trs("numeric")\n  } else {\n    Data.type.x <- ifelse(mode(x) %in% rownames(.keywords_context),\n                          trs(mode(x)), mode(x))\n  }  \n  \n  \n\n  # Determine data "type" for y, in a non-strict way\n  if (all(c("ordered", "factor") %in% class(y))) {\n    Data.type.y <- trs("factor.ordered")\n  } else if ("factor" %in% class(y)) {\n    Data.type.y <- trs("factor")\n  } else if (all(c("POSIXct", "POSIXt") %in% class(y))) { \n    Data.type.y <- trs("datetime")\n  } else if ("Date" %in% class(y)) {\n    Data.type.y <- trs("date")\n  } else if ("logical" %in% class(y)) {\n    Data.type.y <- trs("logical")\n  } else if ("character" %in% class(y)) {\n    Data.type.y <- trs("character")\n  } else if ("integer" %in% class(y)) {\n    Data.type.y <- trs("integer")\n  } else if ("numeric" %in% class(y)) {\n    Data.type.y <- trs("numeric")\n  } else {\n    Data.type.y <- ifelse(mode(y) %in% rownames(.keywords_context),\n                          trs(mode(y)), mode(y))\n  }  \n  \n  # Store dataframe name in a variable since this will be used in\n  # several places in next step\n  dfn <- ifelse(exists("df_name", inherits = FALSE), df_name, NA)\n  \n  # Prepare metadata to be stored as the data_info attribute\n  data_info <-\n    list(Data.frame          = ifelse(exists("df_name", inherits = FALSE), \n                                      df_name, NA),\n         Data.frame.label    = ifelse(exists("df_label", inherits = FALSE),\n                                      df_label, NA),\n         Row.variable        = x_name,\n         Row.variable.label  = ifelse(!is.na(label(x)), label(x), NA),\n         Col.variable        = y_name,\n         Col.variable.label  = ifelse(!is.na(label(y)), label(y), NA),\n         Row.x.Col           = paste(x_name, y_name, sep = " * "),\n         Proportions         = switch(prop,\n                                      r = "Row",\n                                      c = "Column",\n                                      t = "Total",\n                                      n = "None"),\n         Data.type.x         = Data.type.x,\n         Data.type.y         = Data.type.y,\n         Weights             = ifelse(identical(weights, NA), NA,\n                                      ifelse(is.na(dfn), \n                                             weights_string,\n                                             sub(pattern = paste0(dfn, "$"), \n                                                 replacement = "",\n                                                 x = weights_string,\n                                                 fixed = TRUE))),\n         Group            = ifelse("by_group" %in% names(parse_info_x),\n                                   parse_info_x$by_group, NA),\n         by_first         = ifelse("by_group" %in% names(parse_info_x), \n                                   parse_info_x$by_first, NA),\n         by_last          = ifelse("by_group" %in% names(parse_info_x), \n                                   parse_info_x$by_last , NA))\n\n  attr(output, "data_info") <-  data_info[!is.na(data_info)]\n\n  attr(output, "format_info") <-  list(style          = style,\n                                       round.digits   = round.digits,\n                                       plain.ascii    = plain.ascii,\n                                       justify        = justify,\n                                       totals         = totals,\n                                       split.tables   = split.tables,\n                                       headings       = headings,\n                                       display.labels = display.labels)\n  \n  attr(output, "user_fmt") <- list(... = ...)\n\n  attr(output, "lang") <- st_options("lang")\n  \n  return(output)\n}\n'