b'// NOTE : This problem requres implementation of Standard convex hull trick which I have copied from :\n// http://codeforces.com/blog/entry/11339 \n\n// SOURCE : http://codeforces.com/blog/entry/11339 \n\n/*\n * Dynamic version of data structure\n * to be used in dynamic programming optimisation\n * called "Convex Hull trick"\n * \'Dynamic\' means that there is no restriction on adding lines order\n */\nclass ConvexHullDynamic\n{\n    typedef long long coef_t;\n    typedef long long coord_t;\n    typedef long long val_t;\n \n    /*\n     * Line \'y=a*x+b\' represented by 2 coefficients \'a\' and \'b\'\n     * and \'xLeft\' which is intersection with previous line in hull(first line has -INF)\n     */\nprivate:\n    struct Line\n    {\n        coef_t a, b;\n        double xLeft;\n \n        enum Type {line, maxQuery, minQuery} type;\n        coord_t val;\n \n        explicit Line(coef_t aa=0, coef_t bb=0) : a(aa), b(bb), xLeft(-INFINITY), type(Type::line), val(0) {}\n        val_t valueAt(coord_t x) const { return a*x+b; }\n        friend bool areParallel(const Line& l1, const Line& l2) { return l1.a==l2.a; }\n        friend double intersectX(const Line& l1, const Line& l2) { return areParallel(l1,l2)?INFINITY:1.0*(l2.b-l1.b)/(l1.a-l2.a); }\n        bool operator<(const Line& l2) const\n        {\n            if (l2.type == line)\n                return this->a     < l2.a;\n            if (l2.type == maxQuery)\n                return this->xLeft < l2.val;\n            if (l2.type == minQuery)\n                return this->xLeft > l2.val;\n        }\n    };\n \nprivate:\n    bool            isMax; //whether or not saved envelope is top(search of max value)\n    std::set<Line>  hull;  //envelope itself\n \nprivate:\n    /*\n     * INFO:        Check position in hull by iterator\n     * COMPLEXITY:  O(1)\n     */\n    bool hasPrev(std::set<Line>::iterator it) { return it!=hull.begin(); }\n    bool hasNext(std::set<Line>::iterator it) { return it!=hull.end() && std::next(it)!=hull.end(); }\n \n    /*\n     * INFO:        Check whether line l2 is irrelevant\n     * NOTE:        Following positioning in hull must be true\n     *              l1 is next left to l2\n     *              l2 is right between l1 and l3\n     *              l3 is next right to l2\n     * COMPLEXITY:  O(1)\n     */\n    bool irrelevant(const Line& l1, const Line& l2, const Line& l3) { return intersectX(l1,l3) <= intersectX(l1,l2); }\n    bool irrelevant(std::set<Line>::iterator it)\n    {\n        return hasPrev(it) && hasNext(it)\n               && (    isMax && irrelevant(*std::prev(it), *it, *std::next(it))\n                       || !isMax && irrelevant(*std::next(it), *it, *std::prev(it)) );\n    }\n \n    /*\n     * INFO:        Updates \'xValue\' of line pointed by iterator \'it\'\n     * COMPLEXITY:  O(1)\n     */\n    std::set<Line>::iterator updateLeftBorder(std::set<Line>::iterator it)\n    {\n        if (isMax && !hasPrev(it) || !isMax && !hasNext(it))\n            return it;\n \n        double val = intersectX(*it, isMax?*std::prev(it):*std::next(it));\n        Line buf(*it);\n        it = hull.erase(it);\n        buf.xLeft = val;\n        it = hull.insert(it, buf);\n        return it;\n    }\n \npublic:\n    explicit ConvexHullDynamic(bool isMax): isMax(isMax) {}\n    \n    /*\n     * INFO:        Adding line to the envelope\n     *              Line is of type \'y=a*x+b\' represented by 2 coefficients \'a\' and \'b\'\n     * COMPLEXITY:  Adding N lines(N calls of function) takes O(N*log N) time\n     */\n    void addLine(coef_t a, coef_t b)\n    {\n        //find the place where line will be inserted in set\n        Line l3 = Line(a, b);\n        auto it = hull.lower_bound(l3);\n \n        //if parallel line is already in set, one of them becomes irrelevant\n        if (it!=hull.end() && areParallel(*it, l3))\n        {\n            if (isMax && it->b < b || !isMax && it->b > b)\n                it = hull.erase(it);\n            else\n                return;\n        }\n \n        //try to insert\n        it = hull.insert(it, l3);\n        if (irrelevant(it)) { hull.erase(it); return; }\n \n        //remove lines which became irrelevant after inserting line\n        while (hasPrev(it) && irrelevant(std::prev(it))) hull.erase(std::prev(it));\n        while (hasNext(it) && irrelevant(std::next(it))) hull.erase(std::next(it));\n \n        //refresh \'xLine\'\n        it = updateLeftBorder(it);\n        if (hasPrev(it))\n            updateLeftBorder(std::prev(it));\n        if (hasNext(it))\n            updateLeftBorder(std::next(it));\n    }\n    /*\n     * INFO:        Query, which returns max/min(depends on hull type - see more info above) value in point with abscissa \'x\'\n     * COMPLEXITY:  O(log N), N-amount of lines in hull\n     */\n    val_t getBest(coord_t x) const\n    {\n        Line q;\n        q.val = x;\n        q.type = isMax ? Line::Type::maxQuery : Line::Type::minQuery;\n \n        auto bestLine = hull.lower_bound(q);\n        if (isMax) --bestLine;\n        return bestLine->valueAt(x);\n    }\n};\n'