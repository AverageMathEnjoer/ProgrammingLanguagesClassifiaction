b'{-# LANGUAGE CPP, DeriveDataTypeable #-}\n{-# OPTIONS_GHC -Wall -fno-warn-name-shadowing -fwarn-unused-imports #-}\n\n-- | This module defines the \'AList\' type, a list that supports\n-- constant-time append, and is therefore ideal for building the\n-- result of tree-shaped parallel computations.\n\nmodule Control.Monad.Par.AList\n{-# DEPRECATED "This structure does not perform well, and will be removed in future versions" #-}\n (\n  -- * The \'AList\' type and operations\n  AList(..),\n  empty, singleton, cons, head, tail, length, null, append,\n  toList, fromList, fromListBalanced,\n\n  -- * Regular (non-parallel) Combinators\n  filter, map, partition,\n\n  -- * Operations to build \'AList\'s in the \'Par\' monad\n  parBuildThresh, parBuildThreshM,\n  parBuild, parBuildM,\n\n  -- * Inspect and modify the internal structure of an AList tree\n  depth, balance\n )\nwhere\n\nimport Control.DeepSeq\nimport Prelude hiding (length,head,tail,null,map,filter)\nimport qualified Prelude as P\nimport qualified Data.List as L\nimport qualified Control.Monad.Par.Combinator as C\nimport Control.Monad.Par.Class\nimport Data.Typeable\nimport qualified Data.Serialize as S\n\n----------------------------------------------------------------------------------------------------\n\n-- | List that support constant-time append (sometimes called\n-- join-lists).\ndata AList a = ANil | ASing a | Append (AList a) (AList a) | AList [a]\n deriving (Typeable)\n\n-- TODO -- Add vectors.\n\ninstance NFData a => NFData (AList a) where\n rnf ANil         = ()\n rnf (ASing a)    = rnf a\n rnf (Append l r) = rnf l `seq` rnf r\n rnf (AList  l)   = rnf l\n\ninstance Show a => Show (AList a) where\n  show al = "fromList "++ show (toList al)\n\n-- TODO: Better Serialization\ninstance S.Serialize a => S.Serialize (AList a) where\n  put al = S.put (toList al)\n  get = do x <- S.get\n           return (fromList x)\n\n\n\n----------------------------------------------------------------------------------------------------\n\n{-# INLINE append #-}\n-- | /O(1)/ Append two \'AList\'s\nappend :: AList a -> AList a -> AList a\nappend ANil r = r\nappend l ANil = l\nappend l r    = Append l r\n\n{-# INLINE empty #-}\n-- | /O(1)/ an empty \'AList\'\nempty :: AList a\nempty = ANil\n\n{-# INLINE singleton #-}\n-- | /O(1)/ a singleton \'AList\'\nsingleton :: a -> AList a\nsingleton = ASing\n\n{-# INLINE fromList #-}\n-- | /O(1)/ convert an ordinary list to an \'AList\'\nfromList :: [a] -> AList a\nfromList  = AList\n\n-- | Convert an ordinary list, but do so using \'Append\' and\n-- \'ASing\' rather than \'AList\'\nfromListBalanced :: [a] -> AList a\nfromListBalanced xs = go xs (P.length xs)\n  where\n   go _  0 = ANil\n   go ls 1 = case ls of\n               (h:_) -> ASing h\n               []    -> error "the impossible happened"\n   go ls n =\n     let (q,r) = quotRem n 2 in\n     Append (go ls q)\n            (go (drop q ls) (q+r))\n\n\n-- | Balance the tree representation of an AList.\nbalance :: AList a -> AList a\nbalance = fromListBalanced . toList\n-- This would be much better if ALists tracked their size.\n\n{-# INLINE cons #-}\n-- | /O(1)/ prepend an element\ncons :: a -> AList a -> AList a\ncons x ANil = ASing x\ncons x al   = Append (ASing x) al\n-- If we tracked length perhaps this could make an effort at balance.\n\n-- | /O(n)/ take the head element of an \'AList\'\n--\n-- NB. linear-time, because the list might look like this:\n--\n-- > (((... `append` a) `append` b) `append` c)\n--\nhead :: AList a -> a\nhead al =\n  case loop al of\n    Just x -> x\n    Nothing -> error "cannot take head of an empty AList"\n where\n  -- Alas there are an infinite number of representations for null:\n  loop al =\n   case al of\n     Append l r -> case loop l of\n                     x@(Just _) -> x\n                     Nothing    -> loop r\n     ASing x     -> Just x\n     AList (h:_) -> Just h\n     AList []    -> Nothing\n     ANil        -> Nothing\n\n-- | /O(n)/ take the tail element of an \'AList\'\ntail :: AList a -> AList a\ntail al =\n  case loop al of\n    Just x -> x\n    Nothing -> error "cannot take tail of an empty AList"\n where\n  loop al =\n   case al of\n     Append l r -> case loop l of\n                     (Just x) -> Just (Append x r)\n                     Nothing  -> loop r\n\n     ASing _     -> Just ANil\n     AList (_:t) -> Just (AList t)\n     AList []    -> Nothing\n     ANil        -> Nothing\n\n-- | /O(n)/ find the length of an \'AList\'\nlength :: AList a -> Int\nlength ANil         = 0\nlength (ASing _)    = 1\nlength (Append l r) = length l + length r\nlength (AList  l)   = P.length l\n\n{-# INLINE null #-}\n-- | /O(n)/ returns \'True\' if the \'AList\' is empty\nnull :: AList a -> Bool\nnull = (==0) . length\n\n-- | /O(n)/ converts an \'AList\' to an ordinary list\ntoList :: AList a -> [a]\ntoList a = go a []\n where go ANil         rest = rest\n       go (ASing a)    rest = a : rest\n       go (Append l r) rest = go l $! go r rest\n       go (AList xs)   rest = xs ++ rest\n\npartition :: (a -> Bool) -> AList a -> (AList a, AList a)\npartition p a = go a (ANil, ANil)\n  where go ANil      acc = acc\n        go (ASing a) (ys, ns) | p a = (a `cons` ys, ns)\n        go (ASing a) (ys, ns) | otherwise = (ys, a `cons` ns)\n        go (Append l r) acc = go l $! go r acc\n        go (AList xs) (ys, ns) = (AList ys\' `append` ys, AList ns\' `append` ns)\n          where\n            (ys\', ns\') = L.partition p xs\n\ndepth :: AList a -> Int\ndepth ANil      = 0\ndepth (ASing _) = 1\ndepth (AList _) = 1\ndepth (Append l r) = 1 + max (depth l) (depth r)\n\n\n-- The filter operation compacts dead space in the tree that would be\n-- left by ANil nodes.\nfilter :: (a -> Bool) -> AList a -> AList a\nfilter p l = loop l\n where\n  loop ANil         = ANil\n  loop o@(ASing x)  = if p x then o else ANil\n  loop   (AList ls) = AList$ P.filter p ls\n  loop (Append x y) =\n     let l = loop x\n         r = loop y in\n     case (l,r) of\n       (ANil,ANil) -> ANil\n       (ANil,y)    -> y\n       (x,ANil)    -> x\n       (x,y)       -> Append x y\n\n-- | The usual `map` operation.\nmap :: (a -> b) -> AList a -> AList b\nmap _  ANil = ANil\nmap f (ASing x) = ASing (f x)\nmap f (AList l) = AList (P.map f l)\nmap f (Append x y) = Append (map f x) (map f y)\n\n\n--------------------------------------------------------------------------------\n-- * Combinators built on top of a Par monad.\n\n-- | A parMap over an AList can result in more balanced parallelism than\n--   the default parMap over Traversable data types.\n-- parMap :: NFData b => (a -> b) -> AList a -> Par (AList b)\n\n-- | Build a balanced \'AList\' in parallel, constructing each element as a\n--   function of its index.  The threshold argument provides control\n--   over the degree of parallelism.  It indicates under what number\n--   of elements the build process should switch from parallel to\n--   serial.\nparBuildThresh :: (NFData a, ParFuture f p) => Int -> C.InclusiveRange -> (Int -> a) -> p (AList a)\nparBuildThresh threshold range fn =\n  C.parMapReduceRangeThresh threshold range\n                          (return . singleton . fn) appendM empty\n\n-- | Variant of \'parBuildThresh\' in which the element-construction function is itself a \'Par\' computation.\nparBuildThreshM :: (NFData a, ParFuture f p) => Int -> C.InclusiveRange -> (Int -> p a) -> p (AList a)\nparBuildThreshM threshold range fn =\n  C.parMapReduceRangeThresh threshold range\n                          (\\x -> fn x >>= return . singleton) appendM empty\n\n-- | \\"Auto-partitioning\\" version of \'parBuildThresh\' that chooses the threshold based on\n--    the size of the range and the number of processors..\nparBuild :: (NFData a, ParFuture f p) => C.InclusiveRange -> (Int -> a) -> p (AList a)\nparBuild range fn =\n  C.parMapReduceRange range (return . singleton . fn) appendM empty\n\n-- | like \'parBuild\', but the construction function is monadic\nparBuildM :: (NFData a, ParFuture f p) => C.InclusiveRange -> (Int -> p a) -> p (AList a)\nparBuildM range fn =\n  C.parMapReduceRange range (\\x -> fn x >>= return . singleton) appendM empty\n\n--------------------------------------------------------------------------------\n\n-- TODO: Provide a strategy for @par@-based maps:\n\n-- TODO: tryHead -- returns Maybe\n\n-- TODO: headTail -- returns head and tail,\n--    i.e. if we\'re doing O(N) work, don\'t do it twice.\n\n-- FIXME: Could be more efficient:\ninstance Eq a => Eq (AList a) where\n a == b = toList a == toList b\n\n-- TODO: Finish me:\n-- instance F.Foldable AList where\n--  foldr fn init al =\n--   case al of\n--    ANil    ->\n\n-- instance Functor AList where\n--  fmap = undefined\n\n-- -- Walk the data structure without introducing any additional data-parallelism.\n-- instance Traversable AList where\n--   traverse f al =\n--     case al of\n--       ANil    -> pure ANil\n--       ASing x -> ASing <$> f x\n\n\n--------------------------------------------------------------------------------\n-- Internal helpers:\n\nappendM :: ParFuture f p => AList a -> AList a -> p (AList a)\nappendM x y = return (append x y)\n'