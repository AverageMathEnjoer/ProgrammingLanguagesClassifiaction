b'\xef\xbb\xbf//\n// NGmp.Math.Prime.Generator.SequentialSearchPrimeGeneratorBase.cs - Prime Generator\n//\n// Authors:\n//\tBen Maurer\n//\n// Copyright (c) 2003 Ben Maurer. All rights reserved\n//\n\n//\n// Copyright (C) 2004 Novell, Inc (http://www.novell.com)\n//\n// Permission is hereby granted, free of charge, to any person obtaining\n// a copy of this software and associated documentation files (the\n// "Software"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to\n// permit persons to whom the Software is furnished to do so, subject to\n// the following conditions:\n// \n// The above copyright notice and this permission notice shall be\n// included in all copies or substantial portions of the Software.\n// \n// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,\n// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n//\n\nusing System;\n\nnamespace Mono.Math.Prime.Generator {\n\n#if INSIDE_CORLIB\n\tinternal\n#else\n\tpublic\n#endif\n\tclass SequentialSearchPrimeGeneratorBase : PrimeGeneratorBase {\n\n\t\tprotected virtual BigInteger GenerateSearchBase(int bits, object context) {\n\t\t\tBigInteger ret = BigInteger.GenerateRandom(bits);\n\t\t\tret.SetBit(0);\n\t\t\treturn ret;\n\t\t}\n\n\n\t\tpublic override BigInteger GenerateNewPrime(int bits) {\n\t\t\treturn GenerateNewPrime(bits, null);\n\t\t}\n\n\n\t\tpublic virtual BigInteger GenerateNewPrime(int bits, object context) {\n\t\t\t//\n\t\t\t// STEP 1. Find a place to do a sequential search\n\t\t\t//\n\t\t\tBigInteger curVal = GenerateSearchBase(bits, context);\n\n\t\t\tconst uint primeProd1 = 3u * 5u * 7u * 11u * 13u * 17u * 19u * 23u * 29u;\n\n\t\t\tuint pMod1 = curVal % primeProd1;\n\n\t\t\tint DivisionBound = TrialDivisionBounds;\n\t\t\tuint[] SmallPrimes = BigInteger.smallPrimes;\n\t\t\tPrimalityTest PostTrialDivisionTest = this.PrimalityTest;\n\t\t\t//\n\t\t\t// STEP 2. Search for primes\n\t\t\t//\n\t\t\twhile (true) {\n\n\t\t\t\t//\n\t\t\t\t// STEP 2.1 Sieve out numbers divisible by the first 9 primes\n\t\t\t\t//\n\t\t\t\tif (pMod1 % 3 == 0) goto biNotPrime;\n\t\t\t\tif (pMod1 % 5 == 0) goto biNotPrime;\n\t\t\t\tif (pMod1 % 7 == 0) goto biNotPrime;\n\t\t\t\tif (pMod1 % 11 == 0) goto biNotPrime;\n\t\t\t\tif (pMod1 % 13 == 0) goto biNotPrime;\n\t\t\t\tif (pMod1 % 17 == 0) goto biNotPrime;\n\t\t\t\tif (pMod1 % 19 == 0) goto biNotPrime;\n\t\t\t\tif (pMod1 % 23 == 0) goto biNotPrime;\n\t\t\t\tif (pMod1 % 29 == 0) goto biNotPrime;\n\n\t\t\t\t//\n\t\t\t\t// STEP 2.2 Sieve out all numbers divisible by the primes <= DivisionBound\n\t\t\t\t//\n\t\t\t\tfor (int p = 10; p < SmallPrimes.Length && SmallPrimes[p] <= DivisionBound; p++) {\n\t\t\t\t\tif (curVal % SmallPrimes[p] == 0)\n\t\t\t\t\t\tgoto biNotPrime;\n\t\t\t\t}\n\n\t\t\t\t//\n\t\t\t\t// STEP 2.3 Is the potential prime acceptable?\n\t\t\t\t//\n\t\t\t\tif (!IsPrimeAcceptable(curVal, context))\n\t\t\t\t\tgoto biNotPrime;\n\n\t\t\t\t//\n\t\t\t\t// STEP 2.4 Filter out all primes that pass this step with a primality test\n\t\t\t\t//\n\t\t\t\tif (PrimalityTest(curVal, Confidence))\n\t\t\t\t\treturn curVal;\n\n\t\t\t\t//\n\t\t\t\t// STEP 2.4\n\t\t\t\t//\n\t\t\t\tbiNotPrime:\n\t\t\t\tpMod1 += 2;\n\t\t\t\tif (pMod1 >= primeProd1)\n\t\t\t\t\tpMod1 -= primeProd1;\n\t\t\t\tcurVal.Incr2();\n\t\t\t}\n\t\t}\n\n\t\tprotected virtual bool IsPrimeAcceptable(BigInteger bi, object context) {\n\t\t\treturn true;\n\t\t}\n\t}\n}'