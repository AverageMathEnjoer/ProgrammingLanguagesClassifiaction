b'{-# LANGUAGE ScopedTypeVariables #-}\n\nimport Data.List\nimport Test.Hspec\nimport Test.Hspec.QuickCheck\n\n----------------------------------------------------------------\n\nmain :: IO ()\nmain = hspec $ do\n    describe "my_preorder" $\n        prop "behaves like model" $ \\(es :: [Int]) -> do\n            let t = my_from_list es\n            my_preorder t `shouldBe` my_preorder_slow t\n    describe "my_inorder" $\n        prop "behaves like model" $ \\(es :: [Int]) -> do\n            let t = my_from_list es\n            my_inorder t `shouldBe` my_inorder_slow t\n    describe "my_postorder" $\n        prop "behaves like model" $ \\(es :: [Int]) -> do\n            let t = my_from_list es\n            my_postorder t `shouldBe` my_postorder_slow t\n    describe "my_delete" $ do\n        prop "returns a right tree" $ \\(es :: [Int]) -> do\n            let t = my_from_list es\n                e = if null es then 0 else head es\n                t\' = my_delete e t\n                es\' = delete e (nub es)\n            prop_ordered t\' es\'\n        prop "returns an empty tree if applied to all members" $ \\(es :: [Int]) -> do\n            let t = my_from_list es\n                t\' = foldl (flip my_delete) t es\n            t\' `shouldBe` Leaf\n\nprop_ordered :: Tree Int -> [Int] -> Expectation\nprop_ordered t es = my_inorder t `shouldBe` nub (sort es)\n\n----------------------------------------------------------------\n\ndata Tree a = Leaf | Node (Tree a) a (Tree a) deriving (Eq,Show)\n\n----------------------------------------------------------------\n\nmy_insert :: Ord a => a -> Tree a -> Tree a\nmy_insert e Leaf = Node Leaf e Leaf\nmy_insert e (Node l x r) = case compare e x of\n    LT -> Node (my_insert e l) x r\n    EQ -> Node l e r\n    GT -> Node l x (my_insert e r)\n\n----------------------------------------------------------------\n\nmy_from_list :: Ord a => [a] -> Tree a\nmy_from_list es = foldl ins Leaf es\n  where\n    ins t e = my_insert e t\n\n----------------------------------------------------------------\n\nmy_preorder_slow :: Tree a -> [a]\nmy_preorder_slow Leaf         = []\nmy_preorder_slow (Node l x r) =\n    [x] ++ my_preorder_slow l ++ my_preorder_slow r\n\nmy_inorder_slow :: Tree a -> [a]\nmy_inorder_slow Leaf         = []\nmy_inorder_slow (Node l x r) =\n    my_inorder_slow l ++ [x] ++ my_inorder_slow r\n\nmy_postorder_slow :: Tree a -> [a]\nmy_postorder_slow Leaf         = []\nmy_postorder_slow (Node l x r) =\n    my_postorder_slow l ++ my_postorder_slow r ++ [x]\n\n----------------------------------------------------------------\n\nmy_preorder :: Tree a -> [a]\nmy_preorder t = my_preorder\' t []\n\nmy_preorder\' :: Tree a -> [a] -> [a]\nmy_preorder\' Leaf         es = es\nmy_preorder\' (Node l x r) es = x : (my_preorder\' l (my_preorder\' r es))\n\nmy_inorder :: Tree a -> [a]\nmy_inorder t = my_inorder\' t []\n\nmy_inorder\' :: Tree a -> [a] -> [a]\nmy_inorder\' Leaf         es = es\nmy_inorder\' (Node l x r) es = my_inorder\' l (x : (my_inorder\' r es))\n\nmy_postorder :: Tree a -> [a]\nmy_postorder t = my_postorder\' t []\n\nmy_postorder\' :: Tree a -> [a] -> [a]\nmy_postorder\' Leaf         es = es\nmy_postorder\' (Node l x r) es = my_postorder\' l (my_postorder\' r (x:es))\n\n----------------------------------------------------------------\n\nmy_delete_min :: Ord a => Tree a -> (a, Tree a)\nmy_delete_min Leaf            = error "my_delete_min"\nmy_delete_min (Node Leaf x r) = (x, r)\nmy_delete_min (Node l x r)    = (m, Node l\' x r)\n  where\n    (m,l\') = my_delete_min l\n\n----------------------------------------------------------------\n\nmy_delete :: Ord a => a -> Tree a -> Tree a\nmy_delete _ Leaf = Leaf\nmy_delete e (Node l x r) = case compare e x of\n    LT -> Node (my_delete e l) x r\n    EQ -> my_glue l r\n    GT -> Node l x (my_delete e r)\n\nmy_glue :: Ord a => Tree a -> Tree a -> Tree a\nmy_glue Leaf r = r\nmy_glue l Leaf = l\nmy_glue l r    = Node l m r\'\n  where\n    (m,r\') = my_delete_min r\n'