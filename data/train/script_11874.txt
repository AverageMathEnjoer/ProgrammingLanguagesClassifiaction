b'{-# LANGUAGE UndecidableInstances #-}\nmodule Database.Beam.Query.DataTypes where\n\nimport Database.Beam.Backend.SQL\nimport Database.Beam.Query.Internal\n\nimport Data.Text (Text)\nimport Data.Time (LocalTime, Day, TimeOfDay)\nimport Data.Scientific (Scientific)\nimport Data.Typeable (Typeable)\nimport Data.Vector (Vector)\n\n-- | A data type in a given \'IsSql92DataTypeSyntax\' which describes a SQL type\n-- mapping to the Haskell type @a@\nnewtype DataType be a = DataType (BeamSqlBackendCastTargetSyntax be)\n\ninstance Sql92DisplaySyntax (BeamSqlBackendCastTargetSyntax be) => Show (DataType be a) where\n  show (DataType syntax) = "DataType (" ++ displaySyntax syntax ++ ")"\nderiving instance Eq (BeamSqlBackendCastTargetSyntax be) => Eq (DataType be a)\n\n-- | Cast a value to a specific data type, specified using \'DataType\'.\n--\n-- Note: this may fail at run-time if the cast is invalid for a particular value\ncast_ :: BeamSqlBackend be => QGenExpr ctxt be s a -> DataType be b -> QGenExpr ctxt be s b\ncast_ (QExpr e) (DataType dt) = QExpr (castE <$> e <*> pure dt)\n\n-- ** Data types\n\n-- | SQL92 @INTEGER@ data type\nint :: (BeamSqlBackend be, Integral a) => DataType be a\nint = DataType intType\n\n-- | SQL92 @SMALLINT@ data type\nsmallint :: (BeamSqlBackend be, Integral a) => DataType be a\nsmallint = DataType smallIntType\n\n-- | SQL2008 Optional @BIGINT@ data type\nbigint :: ( BeamSqlBackend be, BeamSqlT071Backend be, Integral a )\n       => DataType be a\nbigint = DataType bigIntType\n\n-- TODO is Integer the right type to use here?\n-- | SQL2003 Optional @BINARY@ data type\nbinary :: ( BeamSqlBackend be, BeamSqlT021Backend be )\n       => Maybe Word -> DataType be Integer\nbinary prec = DataType (binaryType prec)\n\n-- | SQL2003 Optional @VARBINARY@ data type\nvarbinary :: ( BeamSqlBackend be, BeamSqlT021Backend be )\n          => Maybe Word -> DataType be Integer\nvarbinary prec = DataType (varBinaryType prec)\n\n-- TODO should this be Day or something?\n-- | SQL92 @DATE@ data type\ndate :: BeamSqlBackend be => DataType be Day\ndate = DataType dateType\n\n-- | SQL92 @CHAR@ data type\nchar :: BeamSqlBackend be => Maybe Word -> DataType be Text\nchar prec = DataType (charType prec Nothing)\n\n-- | SQL92 @VARCHAR@ data type\nvarchar :: BeamSqlBackend be => Maybe Word -> DataType be Text\nvarchar prec = DataType (varCharType prec Nothing)\n\n-- | SQL92 @NATIONAL CHARACTER VARYING@ data type\nnationalVarchar :: BeamSqlBackend be => Maybe Word -> DataType be Text\nnationalVarchar prec = DataType (nationalVarCharType prec)\n\n-- | SQL92 @NATIONAL CHARACTER@ data type\nnationalChar :: BeamSqlBackend be => Maybe Word -> DataType be Text\nnationalChar prec = DataType (nationalCharType prec)\n\n-- | SQL92 @DOUBLE@ data type\ndouble :: BeamSqlBackend be => DataType be Double\ndouble = DataType doubleType\n\n-- | SQL92 @NUMERIC@ data type\nnumeric :: BeamSqlBackend be => Maybe (Word, Maybe Word) -> DataType be Scientific\nnumeric x = DataType (numericType x)\n\n-- | SQL92 @TIMESTAMP WITH TIME ZONE@ data type\ntimestamptz :: BeamSqlBackend be => DataType be LocalTime\ntimestamptz = DataType (timestampType Nothing True)\n\n-- | SQL92 @TIMESTAMP WITHOUT TIME ZONE@ data type\ntimestamp :: BeamSqlBackend be => DataType be LocalTime\ntimestamp = DataType (timestampType Nothing False)\n\n-- | SQL92 @TIME@ data type\ntime :: BeamSqlBackend be => Maybe Word -> DataType be TimeOfDay\ntime prec = DataType (timeType prec False)\n\n-- | SQL99 @BOOLEAN@ data type\nboolean :: BeamSql99DataTypeBackend be => DataType be Bool\nboolean = DataType booleanType\n\n-- | SQL99 @CLOB@ data type\ncharacterLargeObject :: BeamSql99DataTypeBackend be => DataType be Text\ncharacterLargeObject = DataType characterLargeObjectType\n\n-- | SQL99 @BLOB@ data type\nbinaryLargeObject :: BeamSql99DataTypeBackend be => DataType be Text\nbinaryLargeObject = DataType binaryLargeObjectType\n\n-- | SQL99 array data types\narray :: (Typeable a, BeamSql99DataTypeBackend be)\n      => DataType be a -> Int\n      -> DataType be (Vector a)\narray (DataType ty) sz = DataType (arrayType ty sz)\n\n-- | Haskell requires \'DataType\'s to match exactly. Use this function to convert\n-- a \'DataType\' that expects a concrete value to one expecting a \'Maybe\'\nmaybeType :: DataType be a -> DataType be (Maybe a)\nmaybeType (DataType sqlTy) = DataType sqlTy\n'