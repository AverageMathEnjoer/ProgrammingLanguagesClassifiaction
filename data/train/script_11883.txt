b'module Data.TicTacToe where\n\nimport           Prelude hiding (any, all, mapM, concat)\nimport qualified GHC.OldList as L\nimport           Test.QuickCheck\nimport           Data.Map (Map, singleton)\nimport qualified Data.Map as M\nimport           Data.Traversable\nimport           Data.Foldable hiding (foldr)\nimport           Data.List(intercalate)\n\n\ndata Player =\n    Naught\n  | Cross\n  deriving (Ord, Eq)\n\ninstance Show Player where\n  show Naught =\n    "O"\n  show Cross =\n    "X"\n\ndata EmptyBoard =\n  EmptyBoard\n  deriving (Eq, Show)\n\ndata Board =\n  Board (Map Position Player) [(Position, Player)]\n  deriving Eq\n\ndata FinishedBoard =\n  FinishedBoard (Maybe Player) Board\n  deriving Eq\n\ninstance Show FinishedBoard where\n  show (FinishedBoard Nothing b) =\n    show b ++ "\\nDraw"\n  show (FinishedBoard (Just p) b) =\n    show b ++ "\\n" ++ show p ++ " wins"\n\ndata Position =\n  N | E | S | W | NE | NW | SE | SW | C\n  deriving (Ord, Eq, Show)\n\ndata Outcome =\n    InvalidMove\n  | Inplay Board\n  | Done FinishedBoard\n  deriving Eq\n\ninstance Show Outcome where\n  show InvalidMove =\n    "?"\n  show (Inplay b) =\n    show b\n  show (Done b) =\n    show b\n\n\ninstance Show Board where\n  show (Board m _) =\n    let p x = case M.lookup x m of\n                Nothing -> \' \'\n                Just Naught -> \'O\'\n                Just Cross -> \'X\'\n        line a b c =\n          concat\n             [\n               "| "\n             , [p a]\n             , " | "\n             , [p b]\n             , " | "\n             , [p c]\n             , " |"\n             ]\n        blank = ".===.===.===."\n    in intercalate "\\n"\n         [\n           blank\n         , line NW N NE\n         , blank\n         , line W C E\n         , blank\n         , line SW S SE\n         , blank\n         ]\n\nstart ::\n  Position\n  -> Board\nstart p =\n  Board (singleton p Naught) [(p, Naught)]\n\nmove\'\' ::\n  Outcome\n  -> Position\n  -> Outcome\nmove\'\' InvalidMove _ =\n  InvalidMove\nmove\'\' (Inplay b) p =\n  move b p\nmove\'\' (Done b) _ =\n  Done b\n\ndata TakenBack =\n  BoardBack Board\n  | EmptyBack\n  deriving (Eq, Show)\n\ntakeBack\' ::\n  FinishedBoard\n  -> Board\ntakeBack\' =\n  undefined\n\ntakeBack ::\n  Board\n  -> TakenBack\ntakeBack =\n  undefined\n\nmove ::\n  Board\n  -> Position\n  -> Outcome\nmove board@(Board m h) p =\n  if p `M.member` m\n    then\n      InvalidMove\n    else\n      let m\' = M.insert p player m\n          wins =\n              [\n                (NW, N, NE)\n              , (N,  C, S)\n              , (NE, E, SE)\n              , (NW, N, NE)\n              , (W, C, E)\n              , (SW, S, SE)\n              , (NW, C, SE)\n              , (SW, C, NE)\n              ]\n          allEqual (a:b:t) = a == b && allEqual (b:t)\n          allEqual _ = True\n          isDraw = M.size m\' >= 9\n          isWin = any (\\(a, b, c) -> any allEqual $ mapM (`M.lookup` m\') [a, b, c]) wins\n          player = whoseTurn board\n          b\' = Board m\' ((p, player):h)\n      in\n        if isWin\n          then Done (FinishedBoard (Just player) b\')\n          else\n            if isDraw\n              then Done (FinishedBoard Nothing b\')\n              else Inplay b\'\n\nswitch :: Player -> Player\nswitch Cross = Naught\nswitch Naught = Cross\n\nwhoseTurn :: Board -> Player\nwhoseTurn (Board _ ((_, p):_)) =\n  switch p\nwhoseTurn (Board _ []) =\n  error "broke it"\n\n-- cabal install QuickCheck\ninstance Arbitrary Position where\n  arbitrary = elements [N, NE, NW, S, SE, SW, E, W, C]\n\ninstance Arbitrary Player where\n  arbitrary = elements [Naught, Cross]\n\ninstance Arbitrary Board where\n  arbitrary = do\n    p <- arbitrary\n    ps <- arbitrary\n    return $ L.foldr propell (start p) ps\n\npropell :: Position -> Board -> Board\npropell p b =\n  case move b p of\n    InvalidMove -> b\n    Done _ -> b\n    Inplay b\' -> b\'\n\ndata Blah = Blah Player Position Int\n\ninstance Arbitrary Blah where\n  arbitrary = do\n    player <- arbitrary\n    position <- arbitrary\n    n <- choose (1, 9)\n    return $ Blah player position n\n\nprop_eqp :: Position -> Bool\nprop_eqp n = n == n\n\nprop_eq :: Int -> Bool\nprop_eq n = n == n\n\nprop_switch :: Player -> Bool\nprop_switch p = switch p /=  p\n\nmain :: IO ()\nmain = do\n  quickCheck prop_eqp\n  quickCheck prop_eq\n  quickCheck prop_switch\n'