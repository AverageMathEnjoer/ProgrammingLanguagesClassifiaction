b'{-# LANGUAGE DeriveGeneric #-}\n{-# LANGUAGE ImportQualifiedPost #-}\n{-# LANGUAGE OverloadedStrings #-}\n{-# LANGUAGE QuasiQuotes #-}\n\n-- | If you\'re hurry, go check source code directly.\n--\n-- = Configure your OAuth2 provider\n--\n-- Pick which OAuth2 provider you\'d to use, e.g. Google, Github, Auth0 etc.\n-- Pretty much all standard OAuth2 provider has developer portal to guide developer to use oauth2 flow.\n-- So read it through if you\'re unfamiliar OAuth2 before.\n-- Often time, those documents will guide you how to create an Application which has credentials\n-- (e.g. @client_id@ and @client_secret@ for a web application), which will be used to authenticate your\n-- service (replying party) with server.\n--\n-- For some OIDC providers, you may even be able to find out those URLs from a well-known endpoint.\n--\n-- @\n-- https:\\/\\/BASE_DOMAIN\\/.well-known\\/openid-configuration\n-- @\n--\n-- In this tutorial, I choose Auth0, which is one of existing OAuth2/OIDC Providers in the market.\n-- This is the API Docs <https://auth0.com/docs/api>\n--\n-- = Generate Authorization URL.\n--\n-- OAuth2 starts with [authorization](https://www.rfc-editor.org/rfc/rfc6749#section-4).\n--\n-- To generate an authorization URL, call method \'authorizationUrl\', then call \'appendQueryParams\' to\n-- append additional query parameters, e.g. @state@, @scope@ etc.\n--\n-- That method will also automatically append following query parameter to the authorization url.\n--\n-- @\n-- client_id = \'xxx\'        -- client id of your Application credential you got previously\n-- response_type = \'code\'   -- must be for authorization request\n-- redirect_uri = \'xxx\'     -- where does the server (provider) send back the authorization code.\n--                        -- You have to config this when creating Application at previous step.\n-- @\n--\n-- The generated URL looks like\n--\n-- @\n-- https://DOMAIN/path/to/authorize?client_id=xxx&response_type=code&redirect_uri=xxx&state=xxx&scope=xxx&..\n-- @\n--\n-- /Notes/: As of today, @hoauth2@ only supports @Code Grant@.\n--\n-- = Redirect user to the Authorization URL\n--\n-- Now you need to have your user to navigate to that URL to kick off OAuth flow.\n--\n-- There are different ways to redirect user to the \'authorizeUrl\'.\n--\n-- e.g.\n--\n--   1. Display as anchor link directly at UI so that user can click it.\n--\n--   2. Create your own login endpoint, e.g. @/login@, which then 302 to the \'authorizeUrl\'.\n--\n-- In this tutorial, I choose the second option. For instance this is how \'indexH\' is implemented.\n--\n-- >>> setHeader "Location" (uriToText authorizeUrl)\n-- >>> status status302\n--\n-- = Obtain Access Token\n--\n-- When user navigates to \'authorizeUrl\', user will be prompt for login against the OAuth provider.\n--\n-- After an successful login there, user will be redirect back to your Application\'s @redirect_uri@\n-- with @code@ in the query parameter.\n--\n-- With this @code@, we could exchange for an Access Token.\n--\n-- Also you\'d better to validate the @state@ is exactly what you pass in the \'authorizeUrl\'.\n-- OAuth2 provider expects to send the exact @state@ back in the redirect request.\n--\n-- To obtain an Access Token, you could call \'fetchAccessToken\',\n-- which essentially takes the authorization @code@, make request to OAuth2 provider\'s @/token@ endpoint\n-- to get an Access Token, plus some other information (see details at \'OAuth2Token\').\n--\n-- \'fetchAccessToken\' returns @ExceptT (OAuth2Error Errors) m OAuth2Token@\n-- However Scotty, which is web framework I used to build this tutorial,\n-- requires error as Text hence the transform with \'oauth2ErrorToText\'\n--\n-- Once we got the \'OAuth2Token\' (which actually deserves an better name like @TokenResponse@),\n-- we could get the actual \'accessToken\' of out it, use which to make API requests to resource server (often time same as the authorization server)\n--\n-- "Network.OAuth.OAuth2.HttpClient" provides a few handy method to send such API request.\n-- For instance,\n--\n-- @\n-- authGetJSON   -- Makes GET request and decode response as JSON, with access token appended in Authorization http header.\n-- authPostJSON  -- Similar but does POST request\n-- @\n--\n-- In this tutorial, it makes request to \'auth0UserInfoUri\' to fetch Auth0 user information\n-- so application knows who did the authorize.\n--\n-- = The end\n--\n-- That\'s it! Congratulations make thus far!\n--\n-- If you\'re interested more of OAuth2, keep reading on <https://www.oauth.com/>,\n-- which provides a nice guide regarding what is OAuth2 and various use cases.\nmodule HOAuth2Tutorial where\n\nimport Control.Monad (void)\nimport Control.Monad.IO.Class (liftIO)\nimport Control.Monad.Trans.Except\nimport Data.Aeson (FromJSON)\nimport Data.ByteString.Char8 qualified as BS\nimport Data.ByteString.Lazy.Char8 qualified as BSL\nimport Data.IORef (IORef, newIORef, readIORef, writeIORef)\nimport Data.Text.Encoding qualified as T\nimport Data.Text.Lazy qualified as TL\nimport GHC.Generics (Generic)\nimport Network.HTTP.Conduit (newManager, tlsManagerSettings)\nimport Network.HTTP.Types (status302)\nimport Network.OAuth.OAuth2 (\n  ExchangeToken (ExchangeToken),\n  OAuth2 (..),\n  OAuth2Token (accessToken),\n  TokenRequestError,\n  appendQueryParams,\n  authGetJSON,\n  authorizationUrl,\n  fetchAccessToken,\n )\nimport URI.ByteString (URI, serializeURIRef\')\nimport URI.ByteString.QQ (uri)\nimport Web.Scotty (ActionM, scotty)\nimport Web.Scotty qualified as Scotty\n\n------------------------------\n\n-- * Configuration\n\n------------------------------\n\nauth0 :: OAuth2\nauth0 =\n  OAuth2\n    { oauth2ClientId = "TZlmNRtLY9duT8M4ztgFBLsFA66aEoGs"\n    , oauth2ClientSecret = ""\n    , oauth2AuthorizeEndpoint = [uri|https://freizl.auth0.com/authorize|]\n    , oauth2TokenEndpoint = [uri|https://freizl.auth0.com/oauth/token|]\n    , oauth2RedirectUri = [uri|http://localhost:9988/oauth2/callback|]\n    }\n\nauthorizeUrl :: URI\nauthorizeUrl =\n  appendQueryParams\n    [ ("scope", "openid profile email")\n    , ("state", randomStateValue)\n    ]\n    $ authorizationUrl auth0\n\n-- | You\'ll need to find out an better way to create @state@\n-- which is recommended in <https://www.rfc-editor.org/rfc/rfc6749#section-10.12>\nrandomStateValue :: BS.ByteString\nrandomStateValue = "random-state-to-prevent-csrf"\n\n-- | Endpoint for fetching user profile using access token\nauth0UserInfoUri :: URI\nauth0UserInfoUri = [uri|https://freizl.auth0.com/userinfo|]\n\n-- | Auth0 user\n-- https://auth0.com/docs/api/authentication#get-user-info\ndata Auth0User = Auth0User\n  { name :: TL.Text\n  , email :: TL.Text\n  , sub :: TL.Text\n  }\n  deriving (Show, Generic)\n\ninstance FromJSON Auth0User\n\n------------------------------\n\n-- * Web server\n\n------------------------------\n\n-- | The \'scotty\' application\napp :: IO ()\napp = do\n  -- Poor man\'s solution for creating user session.\n  refUser <- newIORef Nothing\n  scotty 9988 $ do\n    Scotty.get "/" $ indexH refUser\n    Scotty.get "/login" loginH\n    Scotty.get "/logout" (logoutH refUser)\n    Scotty.get "/oauth2/callback" $ callbackH refUser\n\n-- | @/@ endpoint handler\nindexH :: IORef (Maybe Auth0User) -> ActionM ()\nindexH refUser = do\n  muser <- liftIO (readIORef refUser)\n\n  let info = case muser of\n        Just user ->\n          [ "<p>Hello, " `TL.append` name user `TL.append` "</p>"\n          , "<a href=\'/logout\'>Logout</a>"\n          ]\n        Nothing -> ["<a href=\'/login\'>Login</a>"]\n\n  Scotty.html . mconcat $ "<h1>hoauth2 Tutorial</h1>" : info\n\n-- | @/login@ endpoint handler\nloginH :: ActionM ()\nloginH = do\n  Scotty.setHeader "Location" (uriToText authorizeUrl)\n  Scotty.status status302\n\n-- | @/logout@ endpoint handler\nlogoutH :: IORef (Maybe Auth0User) -> ActionM ()\nlogoutH refUser = do\n  liftIO (writeIORef refUser Nothing)\n  Scotty.redirect "/"\n\n-- | @/oauth2/callback@ endpoint handler\ncallbackH :: IORef (Maybe Auth0User) -> ActionM ()\ncallbackH refUser = do\n  pas <- Scotty.params\n\n  excepttToActionM $ do\n    void $ ExceptT $ pure $ paramValue "state" pas\n    codeP <- ExceptT $ pure $ paramValue "code" pas\n\n    mgr <- liftIO $ newManager tlsManagerSettings\n\n    -- Exchange authorization code for Access Token\n    -- \'oauth2ErrorToText\' turns (OAuth2 error) to Text which is the default way\n    -- Scotty represents error message\n    let code = ExchangeToken $ TL.toStrict codeP\n    tokenResp <- withExceptT oauth2ErrorToText (fetchAccessToken mgr auth0 code)\n\n    -- Call API to resource server with Access Token being authentication code.\n    -- \'bslToText\' exists for similar reason as \'oauth2ErrorToText\'\n    let at = accessToken tokenResp\n    user <- withExceptT bslToText (authGetJSON mgr at auth0UserInfoUri)\n\n    -- Now we need to find way to set authentication status for this application\n    -- that indicates user has been authenticated successfully.\n    -- For simplicity in this tutorial, I choose an \'IORef\'.\n    liftIO $ writeIORef refUser (Just user)\n\n  -- Where to navigate to after login page successfully.\n  Scotty.redirect "/"\n\n------------------------------\n\n-- * Utilities\n\n------------------------------\n\nuriToText :: URI -> TL.Text\nuriToText = TL.fromStrict . T.decodeUtf8 . serializeURIRef\'\n\nbslToText :: BSL.ByteString -> TL.Text\nbslToText = TL.pack . BSL.unpack\n\nparamValue ::\n  -- | Parameter key\n  TL.Text ->\n  -- | All parameters\n  [Scotty.Param] ->\n  Either TL.Text TL.Text\nparamValue key params =\n  if null val\n    then Left ("No value found for param: " <> key)\n    else Right (head val)\n  where\n    val = snd <$> filter (hasParam key) params\n    hasParam :: TL.Text -> Scotty.Param -> Bool\n    hasParam t = (== t) . fst\n\n-- | Lift ExceptT to ActionM which is basically the handler Monad in Scotty.\nexcepttToActionM :: Show a => ExceptT TL.Text IO a -> ActionM a\nexcepttToActionM e = do\n  result <- liftIO $ runExceptT e\n  either Scotty.raise pure result\n\noauth2ErrorToText :: TokenRequestError -> TL.Text\noauth2ErrorToText e = TL.pack $ "Unable fetch access token. error detail: " ++ show e\n'