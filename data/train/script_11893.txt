b'// UVa12265 Selling Land\n// Rujia Liu\n// This code implements the algorithm described in the book\n// Another way is: still use a stack to maintain the "staircase" shape\n// But don\'t eliminate non-optimal rectangles in the stairecase.\n// instead, let maxp[c] be the maximal half-perimeter whose rightmost column is c, which can be calculated with dp.\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\n\nconst int maxn = 1000 + 10;\n\nchar s[maxn][maxn];\nint height[maxn], ans[maxn*2];\n\nstruct Rect {\n  int c, h;\n  Rect(int c=0, int h=0):c(c),h(h){}\n};\n\nRect rect[maxn]; // stack\n\nint main() {\n  int n, m, T;\n  scanf("%d", &T);\n  while(T--) {\n    scanf("%d%d", &n, &m);\n    for(int i = 0; i < n; i ++) scanf("%s", s[i]);\n\n    memset(height, 0, sizeof(height));\n    memset(ans, 0, sizeof(ans));\n    for(int i = 0; i < n; i ++) {\n      int top = -1;\n      for(int j = 0; j < m; j ++) {\n        if(s[i][j] == \'#\') {\n          height[j] = 0;\n          top = -1; // clear stack\n        } else {\n          height[j]++;\n          Rect r(j, height[j]);\n          if(top < 0) rect[++top] = r;\n          else {\n            while(top >= 0 && r.h <= rect[top].h) r.c = rect[top--].c;\n            if(top < 0 || r.h - r.c > rect[top].h - rect[top].c) rect[++top] = r;\n          }\n          ans[j-rect[top].c+rect[top].h+1]++;\n        }\n      }\n    }\n    for(int i = 1; i <= n + m; i++)\n      if(ans[i]) printf("%d x %d\\n", ans[i], i*2);\n  }\n  return 0;\n}\n'