b'// I2Cdev library collection - AT30TSE75x I2C device class\n// Based on ATMEL AT30TSE75x datasheet, 2013 Rev. Atmel-8751F-DTS-AT30TSE752-754-758-Datasheet_092013\n// 2014-02-16 by Bartosz Kryza <bkryza@gmail.com>\n// Updates should (hopefully) always be available at https://github.com/jrowberg/i2cdevlib\n//\n// Changelog:\n//     2014-02-16 - initial release\n\n/* ============================================\nI2Cdev device library code is placed under the MIT license\nCopyright (c) 2014 Bartosz Kryza, Jeff Rowberg\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the "Software"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n===============================================\n*/\n\n#include "AT30TSE75x.h"\n\n/** Default constructor, uses default I2C address. Assumes the device is \n *  AT30TSE752 and A2-A0 pins are connected to ground.\n */\nAT30TSE75x::AT30TSE75x() {\n    devAddr = 0x00;\n    devType = AT30TSE75x_752;\n}\n\n/** Specific address constructor.\n * @param address 3 least significat bits of the address should be provided here\n * depending on the A2-A0 connection\n * @deviceType The type of device (AT30TSE75x_752, AT30TSE75x_754, AT30TSE75x_758)\n */\nAT30TSE75x::AT30TSE75x(uint8_t address, uint8_t deviceType) {\n    // Here we only need the least significant 3 bits\n    devAddr = 0x07 & address;\n    devType = deviceType;\n}\n\n/** Power on and prepare for general usage.\n */\nvoid AT30TSE75x::initialize() {\n  // Nothing to do here\n}\n\n/** Verify the I2C connection.\n * Make sure the device is connected and responds as expected.\n * @return True if connection is valid, false otherwise\n */\nbool AT30TSE75x::testConnection() {\n  \n    if (I2Cdev::readWord(devAddr, AT30TSE75x_RA_TEMPERATURE, buffer) == 1) {\n        return true;\n    }\n    return false;\n\n}\n\n/** Get the current reading of temperature in Celcius degrees\n * @return Current temperature measurement in Celcius degrees\n */\nfloat AT30TSE75x::getTemperatureCelcius() {\n\n    uint16_t rawTemperature = getTemperatureRaw();\n\n    float celciusTemperature = 0.0;\n\n    if((rawTemperature & 0x8000) == 0) {\n      celciusTemperature = (rawTemperature>>8) + ((rawTemperature&0x00F0)>>4)*AT30TSE75x_STEP_12BIT;\n    }\n    else {\n      uint16_t twosComplement = (~rawTemperature) + 1;\n      celciusTemperature = - (twosComplement>>8) - ((twosComplement & 0x00F0)>>4)*AT30TSE75x_STEP_12BIT;\n    }\n\n    return celciusTemperature;\n\n}\n\n/** Get the current reading of temperature in Fahrenheit degrees\n * @return Current temperature measurement in Fahrenheit degrees\n */\nfloat AT30TSE75x::getTemperatureFahrenheit() {\n\n  return (getTemperatureCelcius()*9.0)/5.0 + 32.0;\n  \n}\n\n/** Get the current contents of devices temperature register\n * @return Current temperature register content\n */\nuint16_t AT30TSE75x::getTemperatureRaw() {\n    \n    uint16_t temperatureValue = 0x0000;\n    I2Cdev::readWord(AT30TSE75x_ADDRESS_TEMP_SENSOR | devAddr, \n                                    AT30TSE75x_RA_TEMPERATURE, \n                                    &temperatureValue);\n    return temperatureValue;\n\n}\n\n/** Get the current configuration register content\n * @return Current configuration register content\n */\nuint16_t AT30TSE75x::getConfiguration() {\n  uint16_t config = 0x0000;\n  I2Cdev::readWord(AT30TSE75x_ADDRESS_TEMP_SENSOR | devAddr, AT30TSE75x_RA_CONFIGURATION, &config);\n  return config;\n}\n\n/** Get the status of Non-volatile Busy flag (Read-only)\n * @return Status of Non-volatile Busy flag\n */\nbool AT30TSE75x::getNVRBusy() {\n    uint16_t config = getConfiguration();\n    return (config>>AT30TSE75x_CONFIG_NVRBSY_BIT)&(0x0001);\n}\n\n/** Get the status of shutdown mode flag\n * @return Status of shutdown mode\n */\nbool AT30TSE75x::getShutdownMode() {\n    uint16_t config = getConfiguration();\n    return (config>>AT30TSE75x_CONFIG_SD_BIT)&(0x0001);\n}\n\n/** Set the device shutdown mode\n * @param true - shutdown active, false - normal operation\n */\nvoid AT30TSE75x::setShutdownMode(bool shutdownMode) {\n  uint16_t config = getConfiguration()&(~(0x01<<AT30TSE75x_CONFIG_SD_BIT));\n  I2Cdev::writeWord(AT30TSE75x_ADDRESS_TEMP_SENSOR | devAddr, \n                    AT30TSE75x_RA_CONFIGURATION, \n                    config|(shutdownMode<<AT30TSE75x_CONFIG_SD_BIT));\n}\n\n/** Get the status of comparator/interrupt mode flag\n * @return Status of comparator/interrupt flag\n */\nbool AT30TSE75x::getComparatorInterruptMode() {\n    uint16_t config = getConfiguration();\n    return (config>>AT30TSE75x_CONFIG_CMPINT_BIT)&(0x0001);\n}\n\n/** Set the device shutdown mode\n * @param false - comparator mode, true - interrupt mode\n */\nvoid AT30TSE75x::setComparatorInterruptMode(bool comparatorOrInterrup) {\n  uint16_t config = getConfiguration()&(~(0x01<<AT30TSE75x_CONFIG_CMPINT_BIT));\n  I2Cdev::writeWord(AT30TSE75x_ADDRESS_TEMP_SENSOR | devAddr, \n                    AT30TSE75x_RA_CONFIGURATION, \n                    config|(comparatorOrInterrup<<AT30TSE75x_CONFIG_CMPINT_BIT));\n}\n\n/** Get the status of alert polarity flag\n * @return Status of alert polarity\n */\nbool AT30TSE75x::getAlertPolarity() {\n    uint16_t config = getConfiguration();\n    return (config>>AT30TSE75x_CONFIG_POL_BIT)&(0x0001);\n}\n\n/** Set the alert polarity\n * @param false - alert polarity low, true - alert polarity high\n */\nvoid AT30TSE75x::setAlertPolarity(bool alertPolarity) {\n  uint16_t config = getConfiguration()&(~(0x01<<AT30TSE75x_CONFIG_POL_BIT));\n  I2Cdev::writeWord(AT30TSE75x_ADDRESS_TEMP_SENSOR | devAddr, \n                    AT30TSE75x_RA_CONFIGURATION, \n                    config|(alertPolarity<<AT30TSE75x_CONFIG_POL_BIT));\n}\n\n/** Get the value of fault tolerance queue setting\n * @return Fault tolerance queue setting \n * @see AT30TSE75x_FAULT_COUNT_1\n * @see AT30TSE75x_FAULT_COUNT_2\n * @see AT30TSE75x_FAULT_COUNT_4\n * @see AT30TSE75x_FAULT_COUNT_6\n */\nuint8_t AT30TSE75x::getFaultToleranceQueue() {\n    uint16_t config = getConfiguration();\n    return (config>>AT30TSE75x_CONFIG_FT_BIT)&(0x0003);\n}\n\n/** Set the value of alert fault count\n * @return Value of alert fault count\n * @see AT30TSE75x_FAULT_COUNT_1\n * @see AT30TSE75x_FAULT_COUNT_2\n * @see AT30TSE75x_FAULT_COUNT_4\n * @see AT30TSE75x_FAULT_COUNT_6\n */\nvoid AT30TSE75x::setFaultToleranceQueue(uint8_t faultCount) {\n  uint16_t config = getConfiguration()&(~(0x03<<AT30TSE75x_CONFIG_FT_BIT));\n  I2Cdev::writeWord(AT30TSE75x_ADDRESS_TEMP_SENSOR | devAddr, \n                    AT30TSE75x_RA_CONFIGURATION, \n                    config|(faultCount<<AT30TSE75x_CONFIG_FT_BIT));\n}\n\n/** Get the conversion resolution \n * @return Conversion resolution setting\n * @see AT30TSE75x_RES_9BIT\n * @see AT30TSE75x_RES_10BIT\n * @see AT30TSE75x_RES_11BIT\n * @see AT30TSE75x_RES_12BIT\n */\nuint8_t AT30TSE75x::getConversionResolution() {\n    uint16_t config = getConfiguration();\n    return (config>>AT30TSE75x_CONFIG_RES_BIT)&(0x0003);\n}\n\n/** Set the conversion resolution\n * @param conversionResolution Value of the resolution\n * @see AT30TSE75x_RES_9BIT\n * @see AT30TSE75x_RES_10BIT\n * @see AT30TSE75x_RES_11BIT\n * @see AT30TSE75x_RES_12BIT\n */\nvoid AT30TSE75x::setConversionResolution(uint8_t conversionResolution) {\n  uint16_t config = getConfiguration()&(~(0x03<<AT30TSE75x_CONFIG_RES_BIT));\n  I2Cdev::writeWord(AT30TSE75x_ADDRESS_TEMP_SENSOR | devAddr, \n                    AT30TSE75x_RA_CONFIGURATION, \n                    config|(conversionResolution<<AT30TSE75x_CONFIG_RES_BIT));\n}\n\n/** Get the status of device one shot mode\n * @return false - one shot mode disabled, true - one shot mode enabled\n */\nbool AT30TSE75x::getOneShotMode() {\n    uint16_t config = getConfiguration();\n    return (config>>AT30TSE75x_CONFIG_FT_BIT)&(0x0001);\n}\n\n/** Set the status of device one shot mode\n * @param oneShotMode false - one shot mode disabled, true - one shot mode enabled\n */\nvoid AT30TSE75x::setOneShotMode(bool oneShotMode) {\n  uint16_t config = getConfiguration()&(~(0x01<<AT30TSE75x_CONFIG_FT_BIT));\n  I2Cdev::writeWord(AT30TSE75x_ADDRESS_TEMP_SENSOR | devAddr, \n                    AT30TSE75x_RA_CONFIGURATION, \n                    config|(oneShotMode<<AT30TSE75x_CONFIG_FT_BIT));\n}\n\n\n/** Set the value of alert low temperature limit\n * @param lowLimit Low temperature limit\n */\nvoid AT30TSE75x::setTempLowLimit(uint16_t lowLimit) {\n  I2Cdev::writeWord(AT30TSE75x_ADDRESS_TEMP_SENSOR | devAddr, \n                    AT30TSE75x_RA_TLOW_LIMIT, \n                    lowLimit);\n}\n\n/** Get the value of alert low temperature limit\n * @return Low temperature limit\n */\nuint16_t AT30TSE75x::getTempLowLimit() {\n  uint16_t lowLimit = 0x0000;\n  I2Cdev::readWord(AT30TSE75x_ADDRESS_TEMP_SENSOR | devAddr, \n                                AT30TSE75x_RA_TLOW_LIMIT, \n                                &lowLimit);\n  return lowLimit;\n}\n        \n        \n/** Set the value of alert high temperature limit\n * @param High temperature limit\n */\nvoid AT30TSE75x::setTempHighLimit(uint16_t highLimit) {\n  I2Cdev::writeWord(AT30TSE75x_ADDRESS_TEMP_SENSOR | devAddr, \n                AT30TSE75x_RA_THIGH_LIMIT, \n                highLimit);\n}\n\n/** Get the value of alert high temperature limit\n * @return High temperature limit\n */\nuint16_t AT30TSE75x::getTempHighLimit() {\n  uint16_t highLimit = 0x0000;\n  I2Cdev::readWord(AT30TSE75x_ADDRESS_TEMP_SENSOR | devAddr, \n                                AT30TSE75x_RA_THIGH_LIMIT, \n                                &highLimit);\n  return highLimit;\n}\n\n\n\n/** Get the current non-volatile configuration register content\n * @return Current non-volatile configuration register content\n */\nuint16_t AT30TSE75x::getNVConfiguration() {\n  uint16_t config = 0x0000;\n  I2Cdev::readWord(AT30TSE75x_ADDRESS_TEMP_SENSOR | devAddr, \n                   AT30TSE75x_RA_NV_CONFIGURATION, \n                   &config);\n  return config;\n}\n\n/** Get the status of comparator/interrupt mode from non-volatile configuration register\n * @return false - comparator mode, true - interrupt mode\n */\nbool AT30TSE75x::getNVComparatorInterruptMode() {\n  uint16_t config = getNVConfiguration();\n  return (config>>AT30TSE75x_NVCONFIG_NVCMPINT_BIT)&(0x0001);\n}\n\n/** Set the status of comparator/interrupt mode in non-volatile configuration register\n * @param comparatorOrInterrupt false - comparator mode, true - interrupt mode\n */\nvoid AT30TSE75x::setNVComparatorInterruptMode(bool comparatorOrInterrupt) {\n  uint16_t config = getNVConfiguration()&(~(0x01<<AT30TSE75x_NVCONFIG_NVCMPINT_BIT));\n  I2Cdev::writeWord(AT30TSE75x_ADDRESS_TEMP_SENSOR | devAddr, \n                    AT30TSE75x_RA_NV_CONFIGURATION, \n                    config|(comparatorOrInterrupt<<AT30TSE75x_NVCONFIG_NVCMPINT_BIT));  \n}\n\n/** Get the status of register lock from non-volatile configuration register\n * @return false - register locked, true - register unlocked\n */\nbool AT30TSE75x::getNVRegisterLock() {\n  uint16_t config = getNVConfiguration();\n  return (config>>AT30TSE75x_NVCONFIG_RLCK_BIT)&(0x0001);\n}\n\n/** Set the status of comparator/interrupt mode in non-volatile configuration register\n * @param comparatorOrInterrupt false - comparator mode, true - interrupt mode\n */\nvoid AT30TSE75x::setNVRegisterLock(bool registerLock) {\n  uint16_t config = getNVConfiguration()&(~(0x01<<AT30TSE75x_NVCONFIG_RLCK_BIT));\n  I2Cdev::writeWord(AT30TSE75x_ADDRESS_TEMP_SENSOR | devAddr, \n                    AT30TSE75x_RA_NV_CONFIGURATION, \n                    config|(registerLock<<AT30TSE75x_NVCONFIG_RLCK_BIT));    \n}\n\n/** Get the status of register lockdown from non-volatile configuration register.\n * @return false - register locked, true - register unlocked\n */\nbool AT30TSE75x::getNVRegisterLockdown() {\n  uint16_t config = getNVConfiguration();\n  return (config>>AT30TSE75x_NVCONFIG_RLCKDWN_BIT)&(0x0001);\n}\n\n/** Set the status of comparator/interrupt mode in non-volatile configuration register\n * Warning! Calling this method with true param disables any further modifications of any registers.\n * @param registerLockdown false - registers lockdown reset, true - registers lockdown set\n */\nvoid AT30TSE75x::setNVRegisterLockdown(bool registerLockdown) {\n  uint16_t config = getNVConfiguration()&(~(0x01<<AT30TSE75x_NVCONFIG_RLCKDWN_BIT));\n  I2Cdev::writeWord(AT30TSE75x_ADDRESS_TEMP_SENSOR | devAddr, \n                    AT30TSE75x_RA_NV_CONFIGURATION, \n                    config|(registerLockdown<<AT30TSE75x_NVCONFIG_RLCKDWN_BIT));\n}\n\n/** Get the status of device shutdown mode from non-volatile configuration register.\n * @return false - device shutdown unset, true - device shutdown set\n */\nbool AT30TSE75x::getNVShutdownMode() {\n  uint16_t config = getNVConfiguration();\n  return (config>>AT30TSE75x_NVCONFIG_NVSD_BIT)&(0x0001);\n}\n\n/** Set the status of device shutdown mode from non-volatile configuration register.\n * @param shutdownMode false - device shutdown unset, true - device shutdown set\n */\nvoid AT30TSE75x::setNVShutdownMode(bool shutdownMode) {  \n  uint16_t config = getNVConfiguration()&(~(0x01<<AT30TSE75x_NVCONFIG_NVSD_BIT));\n  I2Cdev::writeWord(AT30TSE75x_ADDRESS_TEMP_SENSOR | devAddr, \n                    AT30TSE75x_RA_NV_CONFIGURATION, \n                    config|(shutdownMode<<AT30TSE75x_NVCONFIG_NVSD_BIT));\n}\n\n/** Get the alert polarity from non-volatile configuration register.\n * @return false - alert polarity low, true - alert polarity high\n */\nbool AT30TSE75x::getNVAlertPolarity() {\n    uint16_t config = getNVConfiguration();\n    return (config>>AT30TSE75x_NVCONFIG_NVPOL_BIT)&(0x0001);\n}\n\n/** Set the alert polarity from non-volatile configuration register.\n * @param alertPolarity false - alert polarity low, true - alert polarity high\n */\nvoid AT30TSE75x::setNVAlertPolarity(bool alertPolarity) {\n  uint16_t config = getNVConfiguration()&(~(0x01<<AT30TSE75x_NVCONFIG_NVPOL_BIT));\n  I2Cdev::writeWord(AT30TSE75x_ADDRESS_TEMP_SENSOR | devAddr, \n                    AT30TSE75x_RA_NV_CONFIGURATION, \n                    config|(alertPolarity<<AT30TSE75x_NVCONFIG_NVPOL_BIT));  \n}\n \n/** Get the value of fault tolerance from non-volatile configuration register.\n * @see AT30TSE75x_FAULT_COUNT_1\n * @see AT30TSE75x_FAULT_COUNT_2\n * @see AT30TSE75x_FAULT_COUNT_4\n * @see AT30TSE75x_FAULT_COUNT_6\n * @return false - alert polarity low, true - alert polarity high\n */ \nuint8_t AT30TSE75x::getNVFaultToleranceQueue() {\n    uint16_t config = getNVConfiguration();\n    return (config>>AT30TSE75x_NVCONFIG_NVFT_BIT)&(0x0003);\n}\n\n\n/** Set the value of fault tolerance from non-volatile configuration register.\n * @param comparatorOrInterrupt false - comparator mode, true - interrupt mode\n * @see AT30TSE75x_FAULT_COUNT_1\n * @see AT30TSE75x_FAULT_COUNT_2\n * @see AT30TSE75x_FAULT_COUNT_4\n * @see AT30TSE75x_FAULT_COUNT_6\n */\nvoid AT30TSE75x::setNVFaultToleranceQueue(uint8_t faultCount) {\n  uint16_t config = getNVConfiguration()&(~(0x03<<AT30TSE75x_NVCONFIG_NVFT_BIT));\n  I2Cdev::writeWord(AT30TSE75x_ADDRESS_TEMP_SENSOR | devAddr, \n                    AT30TSE75x_RA_NV_CONFIGURATION, \n                    config|(faultCount<<AT30TSE75x_NVCONFIG_NVFT_BIT));      \n}\n\n/** Get the conversion resolution from non-volatile configuration register\n * @return Conversion resolution setting\n * @see AT30TSE75x_RES_9BIT\n * @see AT30TSE75x_RES_10BIT\n * @see AT30TSE75x_RES_11BIT\n * @see AT30TSE75x_RES_12BIT\n */\nuint8_t AT30TSE75x::geNVConversionResolution() {\n    uint16_t config = getNVConfiguration();\n    return (config>>AT30TSE75x_NVCONFIG_NVR_BIT)&(0x0003);\n}\n\n/** Set the conversion resolution from non-volatile configuration register\n * @param conversionResolution Conversion resolution setting\n * @see AT30TSE75x_RES_9BIT\n * @see AT30TSE75x_RES_10BIT\n * @see AT30TSE75x_RES_11BIT\n * @see AT30TSE75x_RES_12BIT\n */\nvoid AT30TSE75x::setNVConversionResolution(uint8_t conversionResolution) {\n  uint16_t config = getNVConfiguration()&(~(0x03<<AT30TSE75x_NVCONFIG_NVR_BIT));\n  I2Cdev::writeWord(AT30TSE75x_ADDRESS_TEMP_SENSOR | devAddr, \n                    AT30TSE75x_RA_NV_CONFIGURATION, \n                    config|(conversionResolution<<AT30TSE75x_NVCONFIG_NVR_BIT));    \n}\n \n \n// Temperature alert low limit non-volatile register\nvoid AT30TSE75x::setNVTempLowLimit(uint16_t lowLimit) {\n  I2Cdev::writeWord(AT30TSE75x_ADDRESS_TEMP_SENSOR | devAddr, \n                AT30TSE75x_RA_NV_TLOW_LIMIT, \n                lowLimit);\n}\n\nuint16_t AT30TSE75x::getNVTempLowLimit() {\n  uint16_t lowLimit = 0x0000;\n  I2Cdev::readWord(AT30TSE75x_ADDRESS_TEMP_SENSOR | devAddr, \n                                AT30TSE75x_RA_NV_TLOW_LIMIT, \n                                &lowLimit);\n  return lowLimit;\n}\n\n\n\n/** Set the value of alert high temperature limit in non-volatile configuration register\n * @param highLimit High temperature limit\n */\nvoid AT30TSE75x::setNVTempHighLimit(uint16_t highLimit) {\n  I2Cdev::writeWord(AT30TSE75x_ADDRESS_TEMP_SENSOR | devAddr, \n                AT30TSE75x_RA_NV_THIGH_LIMIT, \n                highLimit);\n}\n\n/** Get the value of alert high temperature limit in non-volatile configuration register\n * @return High temperature limit\n */\nuint16_t AT30TSE75x::getNVTempHighLimit() {\n  uint16_t highLimit = 0x0000;\n  I2Cdev::readWord(AT30TSE75x_ADDRESS_TEMP_SENSOR | devAddr, \n                                AT30TSE75x_RA_NV_THIGH_LIMIT, \n                                &highLimit);\n  return highLimit;\n}\n\n\n/** Reads a single EEPROM byte at given address.\n * @param address The address in the form (pageNumber*16) + byteInPage. Depending on the device the number of pages can be 16, 32, 64.\n * @return The value of the byte read from the EEPROM\n */\nuint8_t AT30TSE75x::readEEPROMByte(uint16_t address) {\n  \n  uint8_t eepromDeviceAddress = 0x00;\n  uint8_t byteAddress = 0x00;\n  \n  if(devType == AT30TSE75x_752) {\n    eepromDeviceAddress = AT30TSE75x_ADDRESS_SERIAL_EEPROM | devAddr;\n  }\n  else if(devType == AT30TSE75x_754) {\n    eepromDeviceAddress = AT30TSE75x_ADDRESS_SERIAL_EEPROM | ((devAddr&(~0x01))|((address>>8)&0x01));\n  }\n  else {\n    eepromDeviceAddress = AT30TSE75x_ADDRESS_SERIAL_EEPROM | ((devAddr&(~0x03))|((address>>8)&0x03));\n  }\n  \n  byteAddress = 0x00FF&address;\n  \n  uint8_t result = 0x00;\n  \n  I2Cdev::readByte(eepromDeviceAddress, byteAddress, &result);\n  \n  return result;\n  \n}\n\n/** Write single byte to EEPROM\n * @param address Address of byte in EEPROM\n * @param value Value to be stored at address\n */\nvoid AT30TSE75x::writeEEPROMByte(uint16_t address, uint8_t value) {\n  \n  uint8_t eepromDeviceAddress = 0x00;\n  uint8_t byteAddress = 0x00;\n  \n  if(devType == AT30TSE75x_752) {\n    eepromDeviceAddress = AT30TSE75x_ADDRESS_SERIAL_EEPROM | devAddr;\n  }\n  else if(devType == AT30TSE75x_754) {\n    eepromDeviceAddress = AT30TSE75x_ADDRESS_SERIAL_EEPROM | ( (devAddr&(~0x01))|((address>>8)&0x01) );\n  }\n  else {\n    eepromDeviceAddress = AT30TSE75x_ADDRESS_SERIAL_EEPROM | ( (devAddr&(~0x03))|((address>>8)&0x03) );\n  }\n  \n  byteAddress = 0x00FF&address;\n  \n  I2Cdev::writeByte(eepromDeviceAddress, byteAddress, value);\n  \n}\n\n/** Read entire page from EEPROM\n * @param address Address of page in EEPROM (must be aligned to 0 byte in the requested page)\n * @param value Pointer to where the data should be stored (must be at least 16 byte array)\n */\nvoid AT30TSE75x::readEEPROMPage(uint16_t address, uint8_t* page) {\n  \n  uint8_t eepromDeviceAddress = 0x00;\n  uint8_t byteAddress = 0x00;\n  \n  if(devType == AT30TSE75x_752) {\n    eepromDeviceAddress = AT30TSE75x_ADDRESS_SERIAL_EEPROM | devAddr;\n  }\n  else if(devType == AT30TSE75x_754) {\n    eepromDeviceAddress = AT30TSE75x_ADDRESS_SERIAL_EEPROM | ((devAddr&(~0x01))|((address>>8)&0x01));\n  }\n  else {\n    eepromDeviceAddress = AT30TSE75x_ADDRESS_SERIAL_EEPROM | ((devAddr&(~0x03))|((address>>8)&0x03));\n  }\n  \n  byteAddress = 0x00FF&address;\n  \n  bool status = I2Cdev::readBytes(eepromDeviceAddress, byteAddress, 16, page);\n\n}\n\n/** Write entire page (16 bytes) to EEPROM\n * After writing it is good to sleep for 5-10 ms as the bytes are buffered\n * by the device before writing them to EEPROM.\n * @param address Address of page in EEPROM (must be aligned to required pages\' 0 byte)\n * @param page Pointer to array of 16 bytes of data\n */\nvoid AT30TSE75x::writeEEPROMPage(uint16_t address, uint8_t* page) {\n  \n  uint8_t eepromDeviceAddress = 0x00;\n  uint8_t byteAddress = 0x00;\n  \n  if(devType == AT30TSE75x_752) {\n    eepromDeviceAddress = AT30TSE75x_ADDRESS_SERIAL_EEPROM | devAddr;\n  }\n  else if(devType == AT30TSE75x_754) {\n    eepromDeviceAddress = AT30TSE75x_ADDRESS_SERIAL_EEPROM | ((devAddr&(~0x01))|((address>>8)&0x01));\n  }\n  else {\n    Serial.println("Writing EEPROM page");\n    eepromDeviceAddress = AT30TSE75x_ADDRESS_SERIAL_EEPROM | ((devAddr&(~0x03))|((address>>8)&0x03));\n  }\n  \n  byteAddress = 0x00FF&address;\n  \n  I2Cdev::writeBytes(eepromDeviceAddress, byteAddress, 16, page);\n\n}\n\n\n/** Sets the reversible software write protection\n *  Please note that the A2-A0 pins must be set to A2=GND, A1=GND, A0=HV(7V~10V)\n */\nvoid AT30TSE75x::setReversibleSoftwareWriteProtect() {\n  I2Cdev::writeByte(AT30TSE75x_ADDRESS_WRITE_PROTECT|0x1, 0x00, 0x00);\n}\n\n/** Clears the reversible software write protection\n *  Please note that the A2-A0 pins must be set to A2=GND, A1=VCC, A0=HV(7V~10V)\n */\nvoid AT30TSE75x::clearReversibleSoftwareWriteProtect() {\n  I2Cdev::writeByte(AT30TSE75x_ADDRESS_WRITE_PROTECT|0x3, 0x00, 0x00);  \n}\n\n/** Reset the configuration register and temperature alert limits to default values. \n * It won\'t change the non-volatile register.\n */\nvoid AT30TSE75x::reset() {\n   setShutdownMode(false);\n   setComparatorInterruptMode(false);\n   setAlertPolarity(false);\n   setFaultToleranceQueue(AT30TSE75x_FAULT_COUNT_1);\n   setConversionResolution(AT30TSE75x_RES_9BIT);\n   setOneShotMode(false);\n   setTempLowLimit(0x4B00);\n   setTempHighLimit(0x5000);\n}\n\n'