b'{-# LANGUAGE FlexibleContexts #-}\n{-# LANGUAGE OverloadedStrings #-}\n{-# LANGUAGE RecordWildCards #-}\n{-# LANGUAGE TypeFamilies #-}\n{-# OPTIONS_GHC -fno-warn-orphans #-}\n\nmodule Data.Hoodle.Simple.V0_2_2 where\n\nimport Data.ByteString.Char8 (ByteString, pack)\nimport Data.Hoodle.Util (fst3, snd3)\nimport qualified Data.Serialize as SE\nimport Data.Strict.Tuple (Pair (..))\nimport Data.UUID.V4 (nextRandom)\nimport Lens.Micro (Lens\', lens, set)\nimport Prelude hiding (curry, fst, putStrLn, snd, uncurry)\n\n-- |\ntype Title = ByteString\n\n-- | wrapper of object embeddable in Layer\ndata Item\n  = ItemStroke Stroke\n  | ItemImage Image\n  | ItemSVG SVG\n  | ItemLink Link\n  deriving (Show, Eq, Ord)\n\n-- | Pen stroke item\ndata Stroke\n  = Stroke\n      { stroke_tool :: !ByteString,\n        stroke_color :: !ByteString,\n        stroke_width :: !Double,\n        stroke_data :: ![Pair Double Double]\n      }\n  | VWStroke\n      { stroke_tool :: ByteString,\n        stroke_color :: ByteString,\n        stroke_vwdata :: [(Double, Double, Double)]\n      }\n  deriving (Show, Eq, Ord)\n\n-- | Image item\ndata Image = Image\n  { img_src :: ByteString,\n    img_pos :: (Double, Double),\n    img_dim :: !Dimension\n  }\n  deriving (Show, Eq, Ord)\n\ndata SVG = SVG\n  { svg_text :: Maybe ByteString,\n    svg_command :: Maybe ByteString,\n    svg_render :: ByteString,\n    svg_pos :: (Double, Double),\n    svg_dim :: !Dimension\n  }\n  deriving (Show, Eq, Ord)\n\ndata Link\n  = Link\n      { link_id :: ByteString,\n        link_type :: ByteString,\n        link_location :: ByteString,\n        link_text :: Maybe ByteString,\n        link_command :: Maybe ByteString,\n        link_render :: ByteString,\n        link_pos :: (Double, Double),\n        link_dim :: !Dimension\n      }\n  | LinkDocID\n      { link_id :: ByteString,\n        link_linkeddocid :: ByteString,\n        link_location :: ByteString,\n        link_text :: Maybe ByteString,\n        link_command :: Maybe ByteString,\n        link_render :: ByteString,\n        link_pos :: (Double, Double),\n        link_dim :: !Dimension\n      }\n  deriving (Show, Eq, Ord)\n\n-- |\ninstance SE.Serialize Stroke where\n  put Stroke {..} =\n    SE.putWord8 0\n      >> SE.put stroke_tool\n      >> SE.put stroke_color\n      >> SE.put stroke_width\n      >> SE.put stroke_data\n  put VWStroke {..} =\n    SE.putWord8 1\n      >> SE.put stroke_tool\n      >> SE.put stroke_color\n      >> SE.put stroke_vwdata\n  get = do\n    tag <- SE.getWord8\n    case tag of\n      0 -> Stroke <$> SE.get <*> SE.get <*> SE.get <*> SE.get\n      1 -> VWStroke <$> SE.get <*> SE.get <*> SE.get\n      _ -> fail "err in Stroke parsing"\n\n-- |\ninstance SE.Serialize Image where\n  put Image {..} =\n    SE.put img_src\n      >> SE.put img_pos\n      >> SE.put img_dim\n  get = Image <$> SE.get <*> SE.get <*> SE.get\n\n-- |\ninstance SE.Serialize SVG where\n  put SVG {..} =\n    SE.put svg_text\n      >> SE.put svg_command\n      >> SE.put svg_render\n      >> SE.put svg_pos\n      >> SE.put svg_dim\n  get = SVG <$> SE.get <*> SE.get <*> SE.get <*> SE.get <*> SE.get\n\n-- |\ninstance SE.Serialize Link where\n  put Link {..} =\n    SE.putWord8 0\n      >> SE.put link_id\n      >> SE.put link_type\n      >> SE.put link_location\n      >> SE.put link_text\n      >> SE.put link_command\n      >> SE.put link_render\n      >> SE.put link_pos\n      >> SE.put link_dim\n  put LinkDocID {..} =\n    SE.putWord8 1\n      >> SE.put link_id\n      >> SE.put link_linkeddocid\n      >> SE.put link_location\n      >> SE.put link_text\n      >> SE.put link_command\n      >> SE.put link_render\n      >> SE.put link_pos\n      >> SE.put link_dim\n\n  get = do\n    tag <- SE.getWord8\n    case tag of\n      0 ->\n        Link <$> SE.get <*> SE.get <*> SE.get <*> SE.get <*> SE.get\n          <*> SE.get\n          <*> SE.get\n          <*> SE.get\n      1 ->\n        LinkDocID <$> SE.get <*> SE.get <*> SE.get <*> SE.get <*> SE.get\n          <*> SE.get\n          <*> SE.get\n          <*> SE.get\n      _ -> fail "err in Link parsing"\n\n-- |\ninstance SE.Serialize Item where\n  put (ItemStroke str) =\n    SE.putWord8 0\n      >> SE.put str\n  put (ItemImage img) =\n    SE.putWord8 1\n      >> SE.put img\n  put (ItemSVG svg) =\n    SE.putWord8 2\n      >> SE.put svg\n  put (ItemLink lnk) =\n    SE.putWord8 3\n      >> SE.put lnk\n  get = do\n    tag <- SE.getWord8\n    case tag of\n      0 -> ItemStroke <$> SE.get\n      1 -> ItemImage <$> SE.get\n      2 -> ItemSVG <$> SE.get\n      3 -> ItemLink <$> SE.get\n      _ -> fail "err in Item parsing"\n\n-- | Orphan instance for Pair\ninstance (SE.Serialize a, SE.Serialize b) => SE.Serialize (Pair a b) where\n  put (x :!: y) =\n    SE.put x\n      >> SE.put y\n  get = (:!:) <$> SE.get <*> SE.get\n\n-- |\ndata Dimension = Dim {dim_width :: !Double, dim_height :: !Double}\n  deriving (Show, Eq, Ord)\n\n-- |\ninstance SE.Serialize Dimension where\n  put (Dim w h) = SE.put w >> SE.put h\n  get = Dim <$> SE.get <*> SE.get\n\n-- |\ndata Background\n  = Background\n      { bkg_type :: !ByteString,\n        bkg_color :: !ByteString,\n        bkg_style :: !ByteString\n      }\n  | BackgroundPdf\n      { bkg_type :: ByteString,\n        bkg_domain :: Maybe ByteString,\n        bkg_filename :: Maybe ByteString,\n        bkg_pageno :: Int\n      }\n  | BackgroundEmbedPdf\n      { bkg_type :: ByteString,\n        bkg_pageno :: Int\n      }\n  deriving (Show)\n\n-- |\ndata Revision\n  = Revision\n      { _revmd5 :: !ByteString,\n        _revtxt :: !ByteString\n      }\n  | RevisionInk\n      { _revmd5 :: !ByteString,\n        _revink :: [Stroke]\n      }\n  deriving (Show)\n\n-- |\ndata Hoodle = Hoodle\n  { hoodle_id :: ByteString,\n    hoodle_title :: !Title,\n    hoodle_revisions :: [Revision],\n    hoodle_embeddedpdf :: Maybe ByteString,\n    hoodle_pages :: ![Page]\n  }\n  deriving (Show)\n\n-- |\ndata Page = Page\n  { page_dim :: !Dimension,\n    page_bkg :: !Background,\n    page_layers :: ![Layer]\n  }\n  deriving (Show)\n\n-- |\nnewtype Layer = Layer {layer_items :: [Item]}\n  deriving (Show)\n\n-- |\ngetXYtuples :: Stroke -> [(Double, Double)]\ngetXYtuples (Stroke _t _c _w d) = map (\\(x :!: y) -> (x, y)) d\ngetXYtuples (VWStroke _t _c d) = map ((,) <$> fst3 <*> snd3) d\n\n----------------------------\n-- Lenses\n----------------------------\n\n-- |\ntool :: Lens\' Stroke ByteString\ntool = lens stroke_tool (\\f a -> f {stroke_tool = a})\n\n-- |\ncolor :: Lens\' Stroke ByteString\ncolor = lens stroke_color (\\f a -> f {stroke_color = a})\n\n-- |\nhoodleID :: Lens\' Hoodle ByteString\nhoodleID = lens hoodle_id (\\f a -> f {hoodle_id = a})\n\n-- |\ntitle :: Lens\' Hoodle Title\ntitle = lens hoodle_title (\\f a -> f {hoodle_title = a})\n\n-- |\nrevisions :: Lens\' Hoodle [Revision]\nrevisions = lens hoodle_revisions (\\f a -> f {hoodle_revisions = a})\n\n-- |\nrevmd5 :: Lens\' Revision ByteString\nrevmd5 = lens _revmd5 (\\f a -> f {_revmd5 = a})\n\n-- |\nembeddedPdf :: Lens\' Hoodle (Maybe ByteString)\nembeddedPdf = lens hoodle_embeddedpdf (\\f a -> f {hoodle_embeddedpdf = a})\n\n-- |\npages :: Lens\' Hoodle [Page]\npages = lens hoodle_pages (\\f a -> f {hoodle_pages = a})\n\n-- |\ndimension :: Lens\' Page Dimension\ndimension = lens page_dim (\\f a -> f {page_dim = a})\n\n-- |\nbackground :: Lens\' Page Background\nbackground = lens page_bkg (\\f a -> f {page_bkg = a})\n\n-- |\nlayers :: Lens\' Page [Layer]\nlayers = lens page_layers (\\f a -> f {page_layers = a})\n\n-- |\nitems :: Lens\' Layer [Item]\nitems = lens layer_items (\\f a -> f {layer_items = a})\n\n--------------------------\n-- empty objects\n--------------------------\n\n-- |\nemptyHoodle :: IO Hoodle\nemptyHoodle = do\n  uuid <- nextRandom\n  return $ Hoodle ((pack . show) uuid) "" [] Nothing []\n\n-- |\nemptyLayer :: Layer\nemptyLayer = Layer {layer_items = []}\n\n-- |\nemptyStroke :: Stroke\nemptyStroke = Stroke "pen" "black" 1.4 []\n\n-- |\ndefaultBackground :: Background\ndefaultBackground =\n  Background\n    { bkg_type = "solid",\n      bkg_color = "white",\n      bkg_style = "lined"\n    }\n\n-- |\ndefaultPage :: Page\ndefaultPage =\n  Page\n    { page_dim = Dim 612.0 792.0,\n      page_bkg = defaultBackground,\n      page_layers = [emptyLayer]\n    }\n\n-- |\ndefaultHoodle :: IO Hoodle\ndefaultHoodle =\n  set title "untitled" . set embeddedPdf Nothing . set pages [defaultPage]\n    <$> emptyHoodle\n\n-- |\nnewPageFromOld :: Page -> Page\nnewPageFromOld page =\n  Page\n    { page_dim = page_dim page,\n      page_bkg = page_bkg page,\n      page_layers = [emptyLayer]\n    }\n'