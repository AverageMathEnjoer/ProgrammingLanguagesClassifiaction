b'{-# LANGUAGE DeriveFunctor #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n\n{- (Very limited) parser, rendered and modifier of nix.conf\n\nSupports subset of nix.conf given Nix 2.0 or Nix 1.0\n\nWhen reading config files, it normalizes Nix 1.0/2.0 names to unified naming,\nthen when it writes the config back, it uses naming depending what given Nix\nversion considers as recommended.\n\n-}\nmodule Cachix.Client.NixConf\n  ( NixConf,\n    NixConfG (..),\n    NixConfLine (..),\n    NixConfLoc (..),\n    render,\n    add,\n    read,\n    update,\n    write,\n    getFilename,\n    parser,\n    parse,\n    readLines,\n    writeLines,\n    isTrustedUsers,\n    defaultPublicURI,\n    defaultSigningKey,\n    setNetRC,\n  )\nwhere\n\nimport qualified Cachix.Types.BinaryCache as BinaryCache\nimport Data.Char (isSpace)\nimport Data.List (nub)\nimport qualified Data.Text as T\nimport Protolude\nimport System.Directory\n  ( XdgDirectory (..),\n    createDirectoryIfMissing,\n    doesFileExist,\n    getXdgDirectory,\n  )\nimport System.FilePath.Posix (takeDirectory)\nimport qualified Text.Megaparsec as Mega\nimport Text.Megaparsec.Char\n\ndata NixConfLine\n  = Substituters [Text]\n  | TrustedUsers [Text]\n  | TrustedPublicKeys [Text]\n  | NetRcFile Text\n  | Other Text\n  deriving (Show, Eq)\n\nnewtype NixConfG a = NixConf a\n  deriving (Show, Eq, Functor)\n\ntype NixConf = NixConfG [NixConfLine]\n\nreadLines :: [NixConf] -> (NixConfLine -> Maybe [Text]) -> [Text]\nreadLines nixconfs predicate = concatMap f nixconfs\n  where\n    f (NixConf xs) = foldl foldIt [] xs\n    foldIt :: [Text] -> NixConfLine -> [Text]\n    foldIt prev new = prev <> fromMaybe [] (predicate new)\n\nwriteLines :: (NixConfLine -> Maybe [Text]) -> NixConfLine -> NixConf -> NixConf\nwriteLines predicate addition = fmap f\n  where\n    f x = filter (isNothing . predicate) x <> [addition]\n\nisSubstituter :: NixConfLine -> Maybe [Text]\nisSubstituter (Substituters xs) = Just xs\nisSubstituter _ = Nothing\n\nisPublicKey :: NixConfLine -> Maybe [Text]\nisPublicKey (TrustedPublicKeys xs) = Just xs\nisPublicKey _ = Nothing\n\nisTrustedUsers :: NixConfLine -> Maybe [Text]\nisTrustedUsers (TrustedUsers xs) = Just xs\nisTrustedUsers _ = Nothing\n\n-- | Pure version of addIO\nadd :: BinaryCache.BinaryCache -> [NixConf] -> NixConf -> NixConf\nadd bc toRead toWrite =\n  writeLines isPublicKey (TrustedPublicKeys $ nub publicKeys) $\n    writeLines isSubstituter (Substituters $ nub substituters) toWrite\n  where\n    -- Note: some defaults are always appended since overriding some setttings in nix.conf overrides defaults otherwise\n    substituters = (defaultPublicURI : readLines toRead isSubstituter) <> [BinaryCache.uri bc]\n    publicKeys = (defaultSigningKey : readLines toRead isPublicKey) <> BinaryCache.publicSigningKeys bc\n\ndefaultPublicURI :: Text\ndefaultPublicURI = "https://cache.nixos.org"\n\ndefaultSigningKey :: Text\ndefaultSigningKey = "cache.nixos.org-1:6NCHdD59X431o0gWypbMrAURkbJ16ZPMQFGspcDShjY="\n\nrender :: NixConf -> Text\nrender (NixConf nixconflines) = T.unlines $ fmap go nixconflines\n  where\n    go :: NixConfLine -> Text\n    go (Substituters xs) = "substituters" <> " = " <> T.unwords xs\n    go (TrustedUsers xs) = "trusted-users = " <> T.unwords xs\n    go (TrustedPublicKeys xs) = "trusted-public-keys" <> " = " <> T.unwords xs\n    go (NetRcFile filename) = "netrc-file = " <> filename\n    go (Other line) = line\n\nwrite :: NixConfLoc -> NixConf -> IO ()\nwrite ncl nc = do\n  filename <- getFilename ncl\n  createDirectoryIfMissing True (takeDirectory filename)\n  writeFile filename $ render nc\n\nread :: NixConfLoc -> IO (Maybe NixConf)\nread ncl = do\n  filename <- getFilename ncl\n  doesExist <- doesFileExist filename\n  if not doesExist\n    then return Nothing\n    else do\n      result <- parse <$> readFile filename\n      case result of\n        Left err -> do\n          putStrLn (Mega.errorBundlePretty err)\n          panic $ toS filename <> " failed to parse, please copy the above error and contents of nix.conf and open an issue at https://github.com/cachix/cachix"\n        Right conf -> return $ Just conf\n\nupdate :: NixConfLoc -> (Maybe NixConf -> NixConf) -> IO ()\nupdate ncl f = do\n  nc <- f <$> read ncl\n  write ncl nc\n\nsetNetRC :: Text -> NixConf -> NixConf\nsetNetRC netrc (NixConf nc) = NixConf $ filter noNetRc nc ++ [NetRcFile netrc]\n  where\n    noNetRc (NetRcFile _) = False\n    noNetRc _ = True\n\ndata NixConfLoc = Global | Local | Custom FilePath\n  deriving (Show, Eq)\n\ngetFilename :: NixConfLoc -> IO FilePath\ngetFilename ncl = do\n  dir <-\n    case ncl of\n      Global -> return "/etc/nix"\n      Local -> getXdgDirectory XdgConfig "nix"\n      Custom filepath -> return filepath\n  return $ dir <> "/nix.conf"\n\n-- nix.conf Parser\ntype Parser = Mega.Parsec Void Text\n\n-- TODO: handle comments\nparseLine :: ([Text] -> NixConfLine) -> Text -> Parser NixConfLine\nparseLine constr name = Mega.try $ do\n  _ <- optional (some (char \' \'))\n  _ <- string name\n  _ <- many (char \' \')\n  _ <- char \'=\'\n  _ <- many (char \' \')\n  values <- Mega.sepBy1 (many (Mega.satisfy (not . isSpace))) (some (char \' \'))\n  _ <- many spaceChar\n  return $ constr (fmap toS values)\n\nparseOther :: Parser NixConfLine\nparseOther = Mega.try $ Other . toS <$> Mega.someTill Mega.anySingle (void eol <|> Mega.eof)\n\nparseAltLine :: Parser NixConfLine\nparseAltLine =\n  (Other "" <$ eol)\n    <|> parseLine Substituters "substituters"\n    <|> parseLine TrustedPublicKeys "trusted-public-keys"\n    <|> parseLine TrustedUsers "trusted-users"\n    <|> parseLine TrustedPublicKeys "binary-cache-public-keys"\n    <|> parseLine Substituters "binary-caches"\n    -- NB: assume that space in this option means space in filename\n    <|> parseLine (NetRcFile . T.concat) "netrc-file"\n    <|> parseOther\n\nparser :: Parser NixConf\nparser = NixConf <$> many parseAltLine\n\nparse :: Text -> Either (Mega.ParseErrorBundle Text Void) NixConf\nparse = Mega.parse parser "nix.conf"\n'