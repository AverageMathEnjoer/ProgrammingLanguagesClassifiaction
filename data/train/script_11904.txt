b'module Database.Beam.Migrate.Tool.Schema where\n\nimport           Prelude hiding (pred)\n\nimport           Database.Beam (Database)\nimport           Database.Beam.Migrate.Tool.Backend\nimport           Database.Beam.Migrate.Tool.CmdLine\nimport           Database.Beam.Migrate.Tool.Diff\nimport           Database.Beam.Migrate.Tool.Registry\nimport           Database.Beam.Migrate.Log\n\nimport           Database.Beam.Backend.SQL\n\nimport           Database.Beam.Migrate ( SomeDatabasePredicate(..)\n                                       , DatabasePredicate(..)\n                                       , PredicateSpecificity(..)\n                                       , MigrationCommand(..)\n                                       , CheckedDatabaseSettings\n                                       , collectChecks )\nimport           Database.Beam.Migrate.Actions\nimport           Database.Beam.Migrate.Backend\n\nimport           Database.Beam.Haskell.Syntax\n\nimport           Control.Exception\nimport           Control.Monad\nimport           Control.Monad.Loops\nimport           Control.Monad.State\n\nimport qualified Data.ByteString.Char8 as BS\nimport qualified Data.HashMap.Strict as Map\nimport qualified Data.HashSet as HS\nimport           Data.Maybe\n#if !MIN_VERSION_base(4, 11, 0)\nimport           Data.List\nimport           Data.Monoid\n#endif\nimport           Data.Proxy\nimport           Data.String (fromString)\nimport           Data.Text (Text)\nimport qualified Data.Text as T\nimport qualified Data.Text.Encoding as TE\nimport           Data.Time\nimport           Data.Typeable\nimport           Data.UUID (UUID)\nimport qualified Data.UUID as UUID (nil)\nimport qualified Data.Yaml as Yaml\n\nimport           Language.Haskell.Interpreter hiding (ModuleName, get, set)\nimport qualified Language.Haskell.Interpreter as GHCI\nimport qualified Language.Haskell.Exts as Hs\n\nimport           System.Directory\nimport           System.FilePath\nimport           System.IO\n\nimport           Text.Editor\n\nmodifyM :: Functor m => (s -> m s) -> StateT s m ()\nmodifyM f = StateT $ fmap ((),) . f\n\nwithRegistry :: Monad m => (MigrationRegistry -> StateT MigrationRegistry m a) -> StateT MigrationRegistry m a\nwithRegistry f = get >>= f\n\nimportDb :: MigrateCmdLine -> DatabaseName -> Maybe Text -> Bool -> Bool -> IO ()\nimportDb cmdLine dbName@(DatabaseName dbNameStr) branchName doDbCommit autoCreateMigration =\n  updatingRegistry cmdLine . runStateT $ do\n  branchName\' <- case branchName of\n                   Nothing -> do\n                     regHead <- gets migrationRegistryHead\n                     case regHead of\n                       MigrationHeadDetached {} -> fail "Cannot import into detached HEAD"\n                       MigrationHeadBranch nm -> pure nm\n                   Just nm -> pure nm\n\n  (db, backendMigFmt, backend) <- withRegistry $ \\registry -> lift $ loadBackend cmdLine registry dbName\n\n  case backend of\n    SomeBeamMigrationBackend be@(BeamMigrationBackend { backendConvertToHaskell = HaskellPredicateConverter convDbPred\n                                                      , backendTransact = transact\n                                                      , backendActionProvider = actionProvider }) -> do\n      newCommit <- withRegistry $ \\registry -> lift (registryNewCommitId registry)\n      let backendHash = newCommit\n          hsHash = newCommit\n\n      (_, cs) <- withRegistry $ \\registry -> liftIO (getPredicatesFromSpec cmdLine registry (PredicateFetchSourceDbHead db Nothing))\n\n      when autoCreateMigration $ do\n        registry <- get\n        oldPreds <- liftIO ((Just <$> getPredicatesFromSpec cmdLine registry\n                                        (PredicateFetchSourceDbHead db (Just 0)))\n                             `catch` (\\NoRecordedSchemas -> pure Nothing))\n\n        -- Generate haskell and backend migration\n        case oldPreds of\n          Nothing -> liftIO $ putStrLn "Skipping migration generation, since this is an initial import"\n          Just (Nothing, _) -> fail "No commit for DB^"\n          Just (Just oldCommitId, oldPreds\') ->\n            let solver = heuristicSolver actionProvider oldPreds\' cs\n            in case finalSolution solver of\n                 Candidates {} -> fail "Could not find migration in backend"\n                 Solved [] -> fail "Schemas are equivalent, not importing"\n                 Solved cmds\' -> do\n                   let cmds = fmap migrationCommand cmds\'\n                   liftIO . void $ writeMigration cmdLine registry be oldCommitId newCommit cmds\n                   modifyM (newMigration oldCommitId hsHash [MigrationFormatHaskell, backendMigFmt])\n\n      -- TODO factor out\n      let schema = Schema (map (\\pred@(SomeDatabasePredicate (_ :: pred)) -> ( HS.singleton (predicateSpecificity (Proxy @pred)), pred)) cs)\n\n      liftIO $ putStrLn "Exporting migration for backend..."\n      backendFileName <- withRegistry $ \\registry -> liftIO (writeSchema cmdLine registry backendHash be cs)\n      liftIO (putStrLn ("Exported migration as " ++ backendFileName))\n\n      cs\' <- lift . fmap catMaybes .\n             forM cs $ \\c -> do\n               let c\' = convDbPred c\n               case c\' of\n                 Nothing -> putStrLn ("Tossing constraint " ++ show c)\n                 Just {} -> pure ()\n               pure c\'\n\n      liftIO $ putStrLn "Exporting haskell schema..."\n      hsFileName <- withRegistry $ \\registry -> liftIO $ writeHsSchema cmdLine registry hsHash cs\' schema [ backendMigFmt ]\n      liftIO $ putStrLn ("Exported haskell migration as " ++ hsFileName)\n\n      liftIO $ putStrLn "Import complete"\n\n      let msg = "Initial import of " <> fromString dbNameStr\n\n      when doDbCommit $\n        liftIO $ reportDdlErrors $ transact (migrationDbConnString db) $ recordCommit newCommit\n\n      modifyM (newSchema hsHash [MigrationFormatHaskell, backendMigFmt] msg)\n\n      modifyM (\\registry ->\n                 case lookupBranch registry branchName\' of\n                   Nothing ->\n                     newBaseBranch branchName\' hsHash registry\n                   Just branch ->\n                     updateBranch branchName\' (branch { migrationBranchCommit = hsHash }) registry)\n\ndumpSchema :: MigrateCmdLine\n           -> ModuleName\n           -> String\n           -> IO ()\ndumpSchema cmdLine backend connStr = do\n  backend\' <- loadBackend\' cmdLine backend\n  case backend\' of\n    SomeBeamMigrationBackend (BeamMigrationBackend { backendGetDbConstraints = getConstraints\n                                                   , backendTransact = transact }) -> do\n      cs <- transact connStr getConstraints\n      case cs of\n        Left err -> fail ("Error getting constraints: " ++ show err)\n        Right cs\' ->\n          let sch = Schema (map (\\c -> (HS.singleton predSrc, c)) cs\')\n              predSrc = PredicateSpecificityOnlyBackend (unModuleName backend)\n          in BS.putStrLn (Yaml.encode sch)\n\nshowSimpleSchema :: MigrateCmdLine\n                 -> ModuleName\n                 -> String\n                 -> SchemaKind\n                 -> IO ()\nshowSimpleSchema cmdLine backend connStr schemaKind = do\n  backend\' <- loadBackend\' cmdLine backend\n  case backend\' of\n    SomeBeamMigrationBackend (BeamMigrationBackend { backendGetDbConstraints = getConstraints\n                                                   , backendConvertToHaskell = HaskellPredicateConverter convDbPred\n                                                   , backendTransact = transact\n                                                   , backendActionProvider = actionProvs\n                                                   , backendRenderSyntax = renderSyntax }) -> do\n      cs <- transact connStr getConstraints\n      case cs of\n        Left err -> fail ("Error getting constraints: " ++ show err)\n        Right cs\' ->\n          case schemaKind of\n            YamlSchema ->\n              let sch = Schema (map (\\c -> (HS.singleton predSrc, c)) cs\')\n                  predSrc = PredicateSpecificityOnlyBackend (unModuleName backend)\n              in BS.putStrLn (Yaml.encode sch)\n            BackendSchema -> do\n              case finalSolution $ heuristicSolver actionProvs [] cs\' of\n                Candidates {} -> fail "Could not form native schema"\n                Solved actions ->\n                    putStrLn (unlines (map renderSyntax (fmap migrationCommand actions)))\n            HsSchema -> do\n              cs\'\' <- fmap catMaybes .\n                     forM cs\' $ \\c -> do\n                       let c\' = convDbPred c\n                       case c\' of\n                         Nothing -> putStrLn ("Tossing constraint " ++ show c)\n                         Just {} -> pure ()\n                       pure c\'\n              case finalSolution $ heuristicSolver (defaultActionProvider @HsMigrateBackend) [] cs\'\' of\n                Candidates {} -> fail "Could not form haskell schema"\n                Solved actions ->\n                  case renderHsSchema (hsActionsToModule "Schema" (fmap migrationCommand actions)) of\n                    Left err -> fail ("Could not render schema: " ++ err)\n                    Right sch -> putStrLn sch\n\nwriteSchema :: MigrateCmdLine -> MigrationRegistry\n             -> UUID -> BeamMigrationBackend be m\n             -> [SomeDatabasePredicate]\n             -> IO FilePath\nwriteSchema cmdLine registry commitId be cs = do\n  case finalSolution $ heuristicSolver (backendActionProvider be) [] cs of\n    Candidates {} -> fail "Could not form backend schema"\n    Solved actions ->\n      writeSchemaFile cmdLine registry (backendFileExtension be) (schemaScriptName commitId) $\n       unlines (map (backendRenderSyntax be) (fmap migrationCommand actions))\n\nwriteHsSchema :: MigrateCmdLine -> MigrationRegistry\n              -> UUID\n              -> [SomeDatabasePredicate]\n              -> Schema\n              -> [MigrationFormat] -> IO FilePath\nwriteHsSchema cmdLine registry commitId cs dbSchema fmts =\n  case finalSolution $ heuristicSolver (defaultActionProvider @HsMigrateBackend) [] cs of\n    Candidates [] -> fail "Could not form haskell schema"\n    Candidates (x:_) ->\n      let allSolved = dbStateCurrentState x\n          allDesired = Map.fromList (map (,()) cs)\n          left = allDesired `Map.difference` allSolved\n      in putStrLn "Left" >> mapM_ (putStrLn . show . fst) (Map.toList left) >> fail ("Some predicates left ")\n    Solved actions -> do\n      metadata <- SchemaMetaData <$> pure commitId <*> pure fmts <*> getCurrentTime <*> pure dbSchema\n      writeHsSchemaFile cmdLine registry commitId metadata $\n        let modName = unModuleName (migrationRegistrySchemaModule registry) <> "." <> schemaModuleName commitId\n        in case renderHsSchema (hsActionsToModule modName (fmap migrationCommand actions)) of\n             Left err -> error ("Could not render schema: " ++ err)\n             Right sch -> sch ++ "\\n\\n" ++\n                          metadataComment "--" metadata\n\nwriteHsSchemaFile :: MigrateCmdLine -> MigrationRegistry -> UUID\n                  -> SchemaMetaData -> String -> IO FilePath\nwriteHsSchemaFile cmdLine registry commitId metadata modStr =\n    writeSchemaFile cmdLine registry "hs" (schemaModuleName commitId)\n                    (modStr ++ "\\n\\n" ++ metadataComment "--" metadata)\n\nwriteMigration :: MigrateCmdLine -> MigrationRegistry\n               -> BeamMigrationBackend be m\n               -> UUID -> UUID\n               -> [ BeamSqlBackendSyntax be ]\n               -> IO FilePath\nwriteMigration cmdLine reg be fromId toId cmds =\n  case be of\n    BeamMigrationBackend { backendRenderSyntax = renderCmd\n                         , backendFileExtension = fileExtension } ->\n      writeSchemaFile cmdLine reg fileExtension (migrationScriptName fromId toId) $\n      unlines (map renderCmd cmds)\n\n-- * Schema new command\n\nrenamedSchemaModule :: FilePath -> String -> String -> IO String\nrenamedSchemaModule srcFile modName modSrc = do\n  let parseMode = Hs.defaultParseMode { Hs.parseFilename = srcFile\n                                      , Hs.extensions = map Hs.EnableExtension $\n                                        [ Hs.ExplicitNamespaces, Hs.StandaloneDeriving\n                                        , Hs.TypeFamilies, Hs.ExplicitForAll\n                                        , Hs.MultiParamTypeClasses, Hs.TypeApplications ] }\n  case Hs.parseModuleWithComments parseMode modSrc of\n    Hs.ParseFailed loc err -> do\n      hPutStrLn stderr (show loc ++ ": " ++ err)\n      fail "Could not parse schema module"\n    Hs.ParseOk (srcMod, comments) ->\n      let srcMod\' = renameModule modName srcMod\n          modStr = Hs.exactPrint srcMod\' comments\n      in pure modStr\n\nrenameModule :: String -> Hs.Module a -> Hs.Module a\nrenameModule modName (Hs.Module l (Just (Hs.ModuleHead l\' (Hs.ModuleName l\'\' _) warning exports))\n                                  pragmas imports decls) =\n  Hs.Module l (Just (Hs.ModuleHead l\' (Hs.ModuleName l\'\' modName) warning exports))\n            pragmas imports decls\nrenameModule _ _ = error "Could not rename module"\n\nbeginNewSchema :: MigrateCmdLine -> Text -> FilePath -> IO ()\nbeginNewSchema cmdLine tmplSrc tmpFile = do\n  updatingRegistry cmdLine $ \\reg -> do\n    assertRegistryReady reg\n\n    tmpFileExists <- doesFileExist tmpFile\n    when tmpFileExists (fail (tmpFile ++ ": already exists... aborting"))\n\n    predSrc <- parsePredicateFetchSourceSpec cmdLine reg tmplSrc\n    src <- case predSrc of\n             PredicateFetchSourceDbHead {} -> fail "Cannot base schema off database. Import the database first"\n             PredicateFetchSourceCommit _ schema -> pure (Just schema)\n             PredicateFetchSourceEmpty -> pure Nothing\n\n    let modName = unModuleName (migrationRegistrySchemaModule reg) <> "." <>\n                  schemaModuleName UUID.nil\n\n    hsModSrc <-\n      case src of\n        Nothing ->\n          case renderHsSchema (hsActionsToModule modName []) of\n            Left err -> fail ("Could not render empty schema: " ++ err)\n            Right sch -> pure (BS.pack sch)\n        Just srcSchema ->\n          case lookupSchema srcSchema [MigrationFormatHaskell] reg of\n            Nothing -> fail "Specified schema does not exist"\n            Just {} -> do\n              let srcSchemaFilePath = migrationRegistrySrcDir reg </> schemaModuleName srcSchema <.> "hs"\n              schemaExists <- doesFileExist srcSchemaFilePath\n              when (not schemaExists) (fail (show srcSchemaFilePath ++ ": could not find haskell source"))\n\n              -- read schema module\n              BS.readFile srcSchemaFilePath\n\n    let noMetadata = BS.unpack (BS.unlines (withoutMetadata (BS.lines hsModSrc)))\n\n    modStr <- renamedSchemaModule tmpFile modName noMetadata\n    let hash = sha256 modStr\n\n    putStrLn ("Writing temporary schema based off of commit " ++ show src ++ "...")\n    writeFile tmpFile modStr\n\n    putStrLn ("You can now edit the schema at " ++ tmpFile)\n    putStrLn "When you are done, run \'beam-migrate schema commit\' to commit the schema to the registry."\n\n    pure ((), reg { migrationRegistryMode = BeamMigrateCreatingSchema tmpFile src hash })\n\n\nloadSchema :: forall be m a\n            . ModuleName -> BeamMigrationBackend be m\n           -> MigrateCmdLine -> MigrationRegistry -> FilePath\n           -> (forall be\' db. Database be\' db => CheckedDatabaseSettings be\' db -> IO a)\n           -> IO a\nloadSchema backendModule (BeamMigrationBackend {}) cmdLine reg modPath withDb = do\n  putStrLn ("Loading module " ++ unModuleName backendModule)\n  res <- runBeamInterpreter cmdLine $ do\n           loadModules [ modPath ]\n           setImportsQ [ ("Database.Beam.Migrate", Just "BeamMigrate")\n                       , ("Database.Beam.Migrate.Backend", Nothing)\n                       , (unModuleName backendModule, Just "BeamBackend") ]\n\n           let beName = tyConName (typeRepTyCon (typeRep (Proxy @be)))\n\n           setTopLevelModules [ unModuleName (migrationRegistrySchemaModule reg) <> "." <> schemaModuleName UUID.nil ]\n           GHCI.set [ languageExtensions := [ TypeApplications ] ]\n           interpret ("SomeCheckedDatabaseSettings (BeamMigrate.runMigrationSilenced (migration @BeamBackend." <> beName <> "))") (undefined :: SomeCheckedDatabaseSettings)\n\n  case res of\n    Left e -> reportHintError e\n    Right (SomeCheckedDatabaseSettings db) ->\n      withDb db\n\nensureCommitMsg :: Maybe Text -> IO Text\nensureCommitMsg Nothing = do\n  time <- getCurrentTime\n  T.strip . TE.decodeUtf8 <$> runUserEditorDWIM txtTemplate (fromString ("New schema created at " <> show time))\nensureCommitMsg (Just msg) = pure msg\n\nnormalizePredicates :: (SomeBeamMigrationBackend, ModuleName, HS.HashSet SomeDatabasePredicate)\n                    -> Map.HashMap SomeDatabasePredicate PredicateSpecificity\nnormalizePredicates (SomeBeamMigrationBackend be, _, preds) =\n    let predList = HS.toList preds\n        bestPreds =\n            fmap (\\pred@(SomeDatabasePredicate (p :: p)) ->\n                      case predicateSpecificity (Proxy :: Proxy p) of\n                        PredicateSpecificityAllBackends ->\n                            case be of\n                              BeamMigrationBackend { backendConvertToHaskell = HaskellPredicateConverter conv2Hs } ->\n                                  fromMaybe (pred, PredicateSpecificityAllBackends) $\n                                  do pred\'@(SomeDatabasePredicate p\') <- conv2Hs pred\n                                     guard (serializePredicate p == serializePredicate p\')\n                                     pure (pred\', PredicateSpecificityAllBackends)\n                        spec@(PredicateSpecificityOnlyBackend _) -> (pred, spec)) predList\n   in Map.fromList bestPreds\n\ncommitSchema :: MigrateCmdLine -> Bool -> Bool -> Maybe Text -> IO ()\ncommitSchema cmdLine force overwrite commitMsg =\n  updatingRegistry cmdLine $ \\reg -> do\n    case migrationRegistryMode reg of\n      BeamMigrateCreatingSchema tmpFile src initialHash -> do\n        contents <- readFile tmpFile\n        let curHash = sha256 contents\n\n        if curHash == initialHash\n           then do\n             putStrLn "No changes were made to schema, so no commit is being made"\n             putStrLn ("We are still at " ++ show (registryHeadCommit reg))\n\n             abortEdits\' True reg\n\n           else do\n             -- Validate the schema by attempting to load it in hint, and collecting the checks.\n             -- Then, diff the checks with the current schema.\n             -- If they are the same, output a warning message, but don\'t do anything\n             -- If they are different, then commit the schema to the current branch and make it the HEAD of the current branch\n\n\n             let allBackends = fmap ModuleName . HS.toList $\n                               foldMap (\\MigrationDatabase { migrationDbBackend = ModuleName nm } ->\n                                            HS.singleton nm) $\n                               migrationRegistryDatabases reg\n\n                 predsInBackend backendModule = do\n                     someBe@(SomeBeamMigrationBackend be) <- loadBackend\' cmdLine backendModule\n                     destinationPreds <- loadSchema backendModule be cmdLine reg tmpFile\n                                           (\\schema -> pure (collectChecks schema))\n                     pure (someBe, backendModule, HS.fromList destinationPreds)\n\n             predsInBackends <- mapM predsInBackend allBackends\n\n             let predsDifferentForBackend src\' (SomeBeamMigrationBackend be, backendModule, destinationPreds) = do\n                     initialPreds <- predsForBackend be . schemaPredicates . schemaMetaDataSchema <$>\n                                     readSchemaMetaData reg be src\'\n\n                     pure (HS.fromList initialPreds /= destinationPreds)\n\n                 finishSchemaCommit =\n                     case migrationRegistryHead reg of\n                       MigrationHeadDetached _ ->\n                           fail "Cannot commit atop detached branch. Please check out a branch and then commit"\n                       MigrationHeadBranch branchNm ->\n                           case lookupBranch reg branchNm of\n                             Nothing -> fail ("Cannot commit atop non-existent branch: " ++ T.unpack branchNm)\n                             Just branch -> do\n                               let schemaPreds = foldr (Map.unionWith mappend) mempty $\n                                                 fmap (fmap HS.singleton . normalizePredicates) $\n                                                 predsInBackends\n\n                                   schemaDesc = Schema $\n                                                fmap (\\(pred, spec) -> (spec, pred)) $\n                                                Map.toList $ schemaPreds\n\n                               commitMsg\' <- ensureCommitMsg commitMsg\n\n                               -- Add the schema\n                               newSchemaId <- registryNewCommitId reg\n                               curTime <- getCurrentTime\n                               let newModFullName = unModuleName (migrationRegistrySchemaModule reg) <> "." <> newModName\n                                   newModName = schemaModuleName newSchemaId\n\n                                   schemaMetaData = SchemaMetaData newSchemaId [ MigrationFormatHaskell ] curTime schemaDesc\n\n                               newSchemaModStr <- renamedSchemaModule tmpFile newModFullName\n                                                    (unlines (withoutMetadata (lines contents)))\n\n                               _ <- writeHsSchemaFile cmdLine reg newSchemaId schemaMetaData newSchemaModStr\n\n                               reg\' <- newSchema newSchemaId [MigrationFormatHaskell] commitMsg\' reg\n                               reg\'\' <- updateBranch branchNm (branch { migrationBranchCommit = newSchemaId }) reg\'\n                               abortEdits\' True reg\'\'\n\n             schemaChangedSignificantly <-\n                 maybe (pure True)\n                       (\\src\' -> anyM (predsDifferentForBackend src\') predsInBackends)\n                       src\n             if not schemaChangedSignificantly && not force\n               then if overwrite\n                    then finishSchemaCommit\n                    else do\n                      putStrLn (unlines [ "The schema was edited, but the new schema is identical to the last."\n                                        , "beam-migrate has decided to do nothing. Here is what you can do:"\n                                        , ""\n                                        , "  1. If you intend to update the schema, edit the schema file so that it "\n                                        , "     is different than the original."\n                                        , ""\n                                        , "  2. If you no longer want to add a new schema, use \'beam-migrate abort\'."\n                                        , ""\n                                        , "  3. If you want to commit this schema as a new schema anyway, add the "\n                                        , "     \'--force\' option to the commit command."\n                                        , ""\n                                        , "  4. If you want to *overwrite* the schema in the given database, add the "\n                                        , "    \'--overwrite\' option to the commit command. This can be dangerous."\n                                        , ""\n                                        , "For now, the registry is left in-tact, you can still edit the file at"\n                                        , "   " ++ tmpFile\n                                        , "to make changes."\n                                        ])\n\n                      pure ((), reg)\n               else finishSchemaCommit\n\n      _ -> fail (mconcat [ "There is no schema to commit. "\n                         , "Run \'beam-migrate schema new\' to start working on a new schema" ])\n'