b'#include <bits/stdc++.h>\nusing namespace std;\n#define gc getchar_unlocked\n#define fo(i,n) for(i=0;i<n;i++)\n#define Fo(i,k,n) for(i=k;i<n;i++)\n#define ll long long\n#define si(x)\tscanf("%d",&x)\n#define sl(x)\tscanf("%I64d",&x)\n#define ss(s)\tscanf("%s",s)\n#define pb push_back\n#define mp make_pair\n#define F first\n#define S second\n#define clr(x) memset(x, 0, sizeof(x))\n#define tr(it, a) for(auto it = a.begin(); it != a.end(); it++)\n#define PI 3.1415926535897932384626\ntypedef pair<int, int>\tpii;\ntypedef pair<ll, ll>\tpll;\ntypedef vector<int>\t\tvi;\ntypedef vector<ll>\t\tvl;\ntypedef vector<pii>\t\tvpii;\ntypedef vector<pll>\t\tvpll;\ntypedef vector<vi>\t\tvvi;\ntypedef vector<vl>\t\tvvl;\nconst int mod = 1000000007;\nconst int N = 2e5;\nvi g[N];\nint a[N];\n\nint mpow(int base, int exp);\nvoid ipgraph(int n, int m);\nvoid dfs(int u, int par);\n//http://codeforces.com/problemset/problem/545/E\n//Begins\n//Works for 0/1 based index\n//Stores the edges used in shortest paths\n\nstruct f{\n    bool operator()(pair<ll, pii> a, pair<ll, pii> b){\n        if (a.F != b.F) return a.F > b.F;\n        if (a.S.S != b.S.S) return W[a.S.S] > W[b.S.S];\n        return a.S.F < b.S.F;\n\n    }\n};\nclass Dijkstra{\n    int n, m;\n    vi *G;\n    set<int> res;\n    int *vis, *U, *V;\n    int *W;\n    ll *dis;\n\n    typedef pair<ll, pii> node;\n    public:\n        void init(int no, int edges){\n            n = no;\n            m = edges;\n            U = new int[m+3];\n            V = new int[m+3];\n            W = new int[m+3];\n\t    dis = new ll[m+3];\n            G = new vi[n+3];\n            vis = new int[n+3];\n            int i;\n            fo(i, n+1) vis[i] = 0;\n            clr(vis);\n        }\n\n        int adj(int u, int e){\n            return u == U[e]? V[e]:U[e];\n        }\n        void addEdge(int pos, int u, int v, int w){\n            U[pos] = u;\n            V[pos] = v;\n            W[pos] = w;\n            G[u].pb(pos);\n            G[v].pb(pos);\n        }\n        void compute(int source){\n            priority_queue< node, vector<node>, f > Q;\n            Q.push({0, {source, -1}});\n\n            while(!Q.empty()){\n                node cur = Q.top(); Q.pop();\n                if (vis[cur.S.F]) continue;\n                vis[cur.S.F] = 1;\n                dis[cur.S.F] = cur.F;\n                res.insert(cur.S.S);\n                for(int e: G[cur.S.F]){\n                    int to = adj(cur.S.F, e);\n                    int w = W[e];\n                    Q.push({cur.F+w, {to, e}});\n                }\n            }\n            res.erase(-1);\n            ll sum = 0;\n            tr(it, res) sum += W[*it];\n            cout<<sum<<endl;\n            tr(it, res) cout<<*it<<" ";\n\n        }\n};\n//END\nint main()\n{\n\tios_base::sync_with_stdio(false);\n\tcin.tie(NULL);\n\tint i,n, m;\n    Dijkstra A;\n    cin>>n>>m;\n    A.init(n, m);\n    fo(i, m){\n        int u, v, w;\n        cin>>u>>v>>w;\n        A.addEdge(i+1, u, v, w);\n    }\n\tint u;\n\tcin>>u;\n\tA.compute(u);\n\treturn 0;\n}\n\nint mpow(int base, int exp) {\n  base %= mod;\n  int result = 1;\n  while (exp > 0) {\n    if (exp & 1) result = ((ll)result * base) % mod;\n    base = ((ll)base * base) % mod;\n    exp >>= 1;\n  }\n  return result;\n}\n\nvoid ipgraph(int n, int m){\n\tint i, u, v;\n\twhile(m--){\n\t\tcin>>u>>v;\n\t\tg[u-1].pb(v-1);\n\t\tg[v-1].pb(u-1);\n\t}\n}\n\nvoid dfs(int u, int par){\n\tfor(int v:g[u]){\n\t\tif (v == par) continue;\n\t\tdfs(v, u);\n\t}\n}\n\n'