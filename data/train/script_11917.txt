b'-- |\n-- Copyright   :  \xc2\xa9 2015\xe2\x80\x932018 Megaparsec contributors\n--                \xc2\xa9 2007 Paolo Martini\n--                \xc2\xa9 1999\xe2\x80\x932001 Daan Leijen\n--\n--\n-- Code adapted from from megaparsec under the BSD license.\nmodule Test.Tasty.Patterns.Expr\n  ( Operator (..)\n  , makeExprParser )\nwhere\n\nimport Control.Monad\n\nchoice :: MonadPlus m => [m a] -> m a\nchoice = msum\n\noption :: MonadPlus m => a -> m a -> m a\noption x p = p `mplus` return x\n\n-- | This data type specifies operators that work on values of type @a@. An\n-- operator is either binary infix or unary prefix or postfix. A binary\n-- operator has also an associated associativity.\n\ndata Operator m a\n  = InfixN  (m (a -> a -> a)) -- ^ Non-associative infix\n  | InfixL  (m (a -> a -> a)) -- ^ Left-associative infix\n  | InfixR  (m (a -> a -> a)) -- ^ Right-associative infix\n  | Prefix  (m (a -> a))      -- ^ Prefix\n  | Postfix (m (a -> a))      -- ^ Postfix\n  | TernR   (m (m (a -> a -> a -> a)))\n    -- ^ Right-associative ternary. Right-associative means that\n    -- @a ? b : d ? e : f@ parsed as\n    -- @a ? b : (d ? e : f)@ and not as @(a ? b : d) ? e : f@.\n\n-- | @\'makeExprParser\' term table@ builds an expression parser for terms\n-- @term@ with operators from @table@, taking the associativity and\n-- precedence specified in the @table@ into account.\n--\n-- @table@ is a list of @[Operator m a]@ lists. The list is ordered in\n-- descending precedence. All operators in one list have the same precedence\n-- (but may have different associativity).\n--\n-- Prefix and postfix operators of the same precedence associate to the left\n-- (i.e. if @++@ is postfix increment, than @-2++@ equals @-1@, not @-3@).\n--\n-- Unary operators of the same precedence can only occur once (i.e. @--2@ is\n-- not allowed if @-@ is prefix negate). If you need to parse several prefix\n-- or postfix operators in a row, (like C pointers\xe2\x80\x94@**i@) you can use this\n-- approach:\n--\n-- > manyUnaryOp = foldr1 (.) <$> some singleUnaryOp\n--\n-- This is not done by default because in some cases allowing repeating\n-- prefix or postfix operators is not desirable.\n--\n-- If you want to have an operator that is a prefix of another operator in\n-- the table, use the following (or similar) wrapper instead of plain\n-- \'Text.Megaparsec.Char.Lexer.symbol\':\n--\n-- > op n = (lexeme . try) (string n <* notFollowedBy punctuationChar)\n--\n-- \'makeExprParser\' takes care of all the complexity involved in building an\n-- expression parser. Here is an example of an expression parser that\n-- handles prefix signs, postfix increment and basic arithmetic:\n--\n-- > expr = makeExprParser term table <?> "expression"\n-- >\n-- > term = parens expr <|> integer <?> "term"\n-- >\n-- > table = [ [ prefix  "-"  negate\n-- >           , prefix  "+"  id ]\n-- >         , [ postfix "++" (+1) ]\n-- >         , [ binary  "*"  (*)\n-- >           , binary  "/"  div  ]\n-- >         , [ binary  "+"  (+)\n-- >           , binary  "-"  (-)  ] ]\n-- >\n-- > binary  name f = InfixL  (f <$ symbol name)\n-- > prefix  name f = Prefix  (f <$ symbol name)\n-- > postfix name f = Postfix (f <$ symbol name)\n\nmakeExprParser :: MonadPlus m\n  => m a               -- ^ Term parser\n  -> [[Operator m a]]  -- ^ Operator table, see \'Operator\'\n  -> m a               -- ^ Resulting expression parser\nmakeExprParser = foldl addPrecLevel\n{-# INLINEABLE makeExprParser #-}\n\n-- | @addPrecLevel p ops@ adds the ability to parse operators in table @ops@\n-- to parser @p@.\n\naddPrecLevel :: MonadPlus m => m a -> [Operator m a] -> m a\naddPrecLevel term ops =\n  term\' >>= \\x -> choice [ras\' x, las\' x, nas\' x, tern\' x, return x]\n  where (ras, las, nas, prefix, postfix, tern) = foldr splitOp ([],[],[],[],[],[]) ops\n        term\' = pTerm (choice prefix) term (choice postfix)\n        ras\'  = pInfixR (choice ras) term\'\n        las\'  = pInfixL (choice las) term\'\n        nas\'  = pInfixN (choice nas) term\'\n        tern\' = pTernR   (choice tern) term\'\n\n-- | @pTerm prefix term postfix@ parses a @term@ surrounded by optional\n-- prefix and postfix unary operators. Parsers @prefix@ and @postfix@ are\n-- allowed to fail, in this case \'id\' is used.\n\npTerm :: MonadPlus m => m (a -> a) -> m a -> m (a -> a) -> m a\npTerm prefix term postfix = do\n  pre  <- option id prefix\n  x    <- term\n  post <- option id postfix\n  return . post . pre $ x\n\n-- | @pInfixN op p x@ parses non-associative infix operator @op@, then term\n-- with parser @p@, then returns result of the operator application on @x@\n-- and the term.\n\npInfixN :: MonadPlus m => m (a -> a -> a) -> m a -> a -> m a\npInfixN op p x = do\n  f <- op\n  y <- p\n  return $ f x y\n\n-- | @pInfixL op p x@ parses left-associative infix operator @op@, then term\n-- with parser @p@, then returns result of the operator application on @x@\n-- and the term.\n\npInfixL :: MonadPlus m => m (a -> a -> a) -> m a -> a -> m a\npInfixL op p x = do\n  f <- op\n  y <- p\n  let r = f x y\n  pInfixL op p r `mplus` return r\n\n-- | @pInfixR op p x@ parses right-associative infix operator @op@, then\n-- term with parser @p@, then returns result of the operator application on\n-- @x@ and the term.\n\npInfixR :: MonadPlus m => m (a -> a -> a) -> m a -> a -> m a\npInfixR op p x = do\n  f <- op\n  y <- p >>= \\r -> pInfixR op p r `mplus` return r\n  return $ f x y\n\n-- | Parse the first separator of a ternary operator\n\npTernR :: MonadPlus m => m (m (a -> a -> a -> a)) -> m a -> a -> m a\npTernR sep1 p x = do\n  sep2 <- sep1\n  y <- p >>= \\r -> pTernR sep1 p r `mplus` return r\n  f <- sep2\n  z <- p >>= \\r -> pTernR sep1 p r `mplus` return r\n  return $ f x y z\n\ntype Batch m a =\n  ( [m (a -> a -> a)]\n  , [m (a -> a -> a)]\n  , [m (a -> a -> a)]\n  , [m (a -> a)]\n  , [m (a -> a)]\n  , [m (m (a -> a -> a -> a))]\n  )\n\n-- | A helper to separate various operators (binary, unary, and according to\n-- associativity) and return them in a tuple.\n\nsplitOp :: Operator m a -> Batch m a -> Batch m a\nsplitOp (InfixR  op) (r, l, n, pre, post, tern) = (op:r, l, n, pre, post, tern)\nsplitOp (InfixL  op) (r, l, n, pre, post, tern) = (r, op:l, n, pre, post, tern)\nsplitOp (InfixN  op) (r, l, n, pre, post, tern) = (r, l, op:n, pre, post, tern)\nsplitOp (Prefix  op) (r, l, n, pre, post, tern) = (r, l, n, op:pre, post, tern)\nsplitOp (Postfix op) (r, l, n, pre, post, tern) = (r, l, n, pre, op:post, tern)\nsplitOp (TernR   op) (r, l, n, pre, post, tern) = (r, l, n, pre, post, op:tern)\n'