b'/*\n * Copyright 2013 - 2016 Mario Arias\n *\n * Licensed under the Apache License, Version 2.0 (the "License");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * \thttp://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an "AS IS" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.funktionale.either\n\nimport org.funktionale.collections.prependTo\nimport org.funktionale.option.Option\nimport org.funktionale.utils.hashCodeForNullable\nimport java.util.*\n\nsealed class Disjunction<out L, out R> : EitherLike {\n\n    companion object {\n        fun <L> left(left: L): Left<L, Nothing> = Left(left)\n        fun <R> right(right: R): Right<Nothing, R> = Right(right)\n    }\n\n    operator abstract fun component1(): L?\n    operator abstract fun component2(): R?\n\n    fun swap(): Disjunction<R, L> = when (this) {\n        is Right -> Left(value)\n        is Left -> Right(value)\n    }\n\n    fun <X> fold(fl: (L) -> X, fr: (R) -> X): X = when (this) {\n        is Right -> fr(value)\n        is Left -> fl(value)\n    }\n\n    fun get(): R = when (this) {\n        is Right -> value\n        is Left -> throw NoSuchElementException("Disjunction.Left")\n    }\n\n    fun forEach(f: (R) -> Unit) {\n        when (this) {\n            is Right -> f(value)\n        }\n    }\n\n    fun exists(predicate: (R) -> Boolean): Boolean = when (this) {\n        is Right -> predicate(value)\n        is Left -> false\n    }\n\n    fun <X> map(f: (R) -> X): Disjunction<L, X> = when (this) {\n        is Right -> Right(f(value))\n        is Left -> Left(value)\n    }\n\n\n    fun filter(predicate: (R) -> Boolean): Option<Disjunction<L, R>> = when (this) {\n        is Right -> if (predicate(value)) {\n            Option.Some(this)\n        } else {\n            Option.None\n        }\n        is Left -> Option.None\n    }\n\n    fun toList(): List<R> = when (this) {\n        is Right -> listOf(value)\n        is Left -> listOf()\n    }\n\n    fun toOption(): Option<R> = when (this) {\n        is Right -> Option.Some(value)\n        is Left -> Option.None\n    }\n\n    fun toEither(): Either<L, R> = when (this) {\n        is Right -> Either.Right(value)\n        is Left -> Either.Left(value)\n    }\n\n    class Left<out L, out R>(val value: L) : Disjunction<L, R>(), LeftLike {\n        override fun component1(): L = value\n        override fun component2(): R? = null\n        override fun equals(other: Any?): Boolean = when (other) {\n            is Left<*, *> -> value == other.value\n            else -> false\n        }\n\n        override fun hashCode(): Int = value.hashCodeForNullable(43) { a, b -> a * b }\n\n        override fun toString(): String = "Disjunction.Left($value)"\n\n\n    }\n\n    class Right<out L, out R>(val value: R) : Disjunction<L, R>(), RightLike {\n        override fun component1(): L? = null\n        override fun component2(): R = value\n\n        override fun equals(other: Any?): Boolean = when (other) {\n            is Right<*, *> -> value == other.value\n            else -> false\n        }\n\n        override fun hashCode(): Int = value.hashCodeForNullable(43) { a, b -> a * b }\n\n        override fun toString(): String = "Disjunction.Right($value)"\n\n\n    }\n}\n\ninline fun <T> disjunctionTry(body: () -> T): Disjunction<Throwable, T> = try {\n    Disjunction.Right(body())\n} catch (t: Throwable) {\n    Disjunction.Left(t)\n}\n\nfun <T> Disjunction<T, T>.merge(): T = when (this) {\n    is Disjunction.Right -> value\n    is Disjunction.Left -> value\n}\n\nfun <L, R> Disjunction<L, R>.getOrElse(default: () -> R): R = when (this) {\n    is Disjunction.Right -> value\n    is Disjunction.Left -> default()\n}\n\nfun <X, L, R> Disjunction<L, R>.flatMap(f: (R) -> Disjunction<L, X>): Disjunction<L, X> = when (this) {\n    is Disjunction.Right -> f(value)\n    is Disjunction.Left -> Disjunction.Left(value)\n}\n\nfun <L, R, X, Y> Disjunction<L, R>.map(x: Disjunction<L, X>, f: (R, X) -> Y): Disjunction<L, Y> = flatMap { r -> x.map { xx -> f(r, xx) } }\n\nfun <T, L, R> List<T>.disjuntionTraverse(f: (T) -> Disjunction<L, R>): Disjunction<L, List<R>> = foldRight(Disjunction.Right(emptyList())) { i: T, accumulator: Disjunction<L, List<R>> ->\n    val disjunction = f(i)\n    when (disjunction) {\n        is Disjunction.Right -> disjunction.map(accumulator) { head: R, tail: List<R> ->\n            head prependTo tail\n        }\n        is Disjunction.Left -> Disjunction.Left(disjunction.value)\n    }\n}\n\nfun <L, R> List<Disjunction<L, R>>.disjunctionSequential(): Disjunction<L, List<R>> = disjuntionTraverse { it }\n\ninline fun <X, T> Option<T>.toDisjunctionRight(left: () -> X): Disjunction<X, T> = toEitherRight(left).toDisjunction()\n\ninline fun <X, T> Option<T>.toDisjunctionLeft(right: () -> X): Disjunction<T, X> = toEitherLeft(right).toDisjunction()'