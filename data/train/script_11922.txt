b'{-# LANGUAGE CPP #-}\n{-# LANGUAGE GADTs #-}\n{-# LANGUAGE OverloadedStrings #-}\n{-# OPTIONS_GHC -fno-warn-unused-imports -fno-warn-unused-matches #-}\n\n-- |\n-- Module      : Hoodle.ModelAction.File\n-- Copyright   : (c) 2011-2015 Ian-Woo Kim\n--\n-- License     : BSD3\n-- Maintainer  : Ian-Woo Kim <ianwookim@gmail.com>\n-- Stability   : experimental\n-- Portability : GHC\nmodule Hoodle.ModelAction.File where\n\nimport Control.Lens (set, view)\nimport Data.Attoparsec.ByteString.Char8 (parseOnly)\nimport Data.ByteString.Base64 (encode)\nimport qualified Data.ByteString.Char8 as C\nimport qualified Data.ByteString.Lazy.Char8 as L\nimport Data.Hoodle.Simple\n  ( Background (..),\n    Dimension (..),\n    Hoodle,\n    Image (..),\n    Item (..),\n    Page (..),\n    embeddedPdf,\n    emptyHoodle,\n    emptyLayer,\n    pages,\n    title,\n  )\nimport Data.Maybe (listToMaybe, mapMaybe)\nimport Data.Time.Clock (getCurrentTime)\nimport qualified Data.Traversable as T\nimport Graphics.GD.ByteString\n  ( imageSize,\n    loadJpegFile,\n    loadPngFile,\n    savePngByteString,\n  )\n-- import Graphics.Hoodle.Render.Background (popplerGetDocFromFile)\nimport Graphics.Hoodle.Render.Type.Hoodle (rHoodle2Hoodle)\n-- import qualified Graphics.UI.Gtk.Poppler.Document as Poppler\n-- import qualified Graphics.UI.Gtk.Poppler.Page as PopplerPage\nimport Hoodle.Type.HoodleState\n  ( FileStore (LocalDir, TempDir),\n    UnitHoodle,\n    getHoodle,\n    hoodleFileControl,\n    hoodleFileName,\n    isSaved,\n    lastSavedTime,\n  )\nimport Hoodle.Util (mkTmpFile)\nimport System.Directory (canonicalizePath)\nimport System.FilePath (takeExtension)\nimport System.IO (IOMode (..), hClose, hFileSize, openFile)\nimport System.Process (readProcess)\nimport Text.Hoodle.Builder (builder)\nimport qualified Text.Hoodle.Migrate.V0_2_2_to_V0_3 as MV\nimport qualified Text.Hoodle.Migrate.V0_3_to_HEAD as MVHEAD\nimport qualified Text.Hoodle.Parse.Attoparsec as PA\n\n-- | check hoodle version and migrate if necessary\ncheckVersionAndMigrate :: C.ByteString -> IO (Either String Hoodle)\ncheckVersionAndMigrate bstr = do\n  case parseOnly PA.checkHoodleVersion bstr of\n    Left str -> error str\n    Right v -> do\n      if v <= "0.2.2"\n        then T.traverse MVHEAD.hoodle2Hoodle =<< MV.migrate bstr\n        else return (parseOnly PA.hoodle bstr)\n\n-- | this is very temporary, need to be changed.\nfindFirstPDFFile :: [Page] -> Maybe C.ByteString\nfindFirstPDFFile xs =\n  let ys = mapMaybe f xs\n   in listToMaybe ys\n  where\n    f :: Page -> Maybe C.ByteString\n    f p = case page_bkg p of\n      BackgroundPdf _ _ fi _ -> fi\n      _ -> Nothing\n\nfindAllPDFPages :: [Page] -> [Int]\nfindAllPDFPages = mapMaybe f\n  where\n    f p = case page_bkg p of\n      BackgroundPdf _ _ _ n -> Just n\n      _ -> Nothing\n\nreplacePDFPages :: [Page] -> [Page]\nreplacePDFPages = map f\n  where\n    f p =\n      let bkg = page_bkg p\n       in case bkg of\n            BackgroundPdf typ _ _ pdfn -> p {page_bkg = BackgroundEmbedPdf typ pdfn}\n            _ -> p\n\n-- |\nembedPDFInHoodle :: Hoodle -> IO Hoodle -- RHoodle -> IO RHoodle\nembedPDFInHoodle hdl = putStrLn "embedPDFInHoodle is now bugful. I do not do anything here " >> return hdl\n\n{-    let pgsWnum = zip [0..] (hoodle_pages hdl)\n        mfn = findFirstPDFFile (hoodle_pages hdl)\n        allpdfpg = findAllPDFPages pgs\n    case mfn of\n      Nothing -> return hdl\n      Just fn -> do\n        let fnstr = C.unpack fn\n            pglst = map show allpdfpg\n            cmdargs =  [fnstr, "cat"] ++ pglst ++ ["output", "-"]\n        -- print cmdargs\n        (_,Just hout,_,_) <- createProcess (proc "pdftk" cmdargs) { std_out = CreatePipe }\n        bstr <- C.hGetContents hout\n        let ebdsrc = makeEmbeddedPdfSrcString bstr\n            npgs = (IM.fromAscList . replacePDFPages pgs\n\n            nhdl0 = rHoodle2Hoodle . (gpages .~ npgs) $ hdl\n            nhdl1 = nhdl0 { hoodle_embeddedpdf = Just ebdsrc }\n        cnstrctRHoodle nhdl1\n-}\n{-\n    let pgs = (IM.toAscList . view gpages) hdl\n        mfn = findFirstPDFFile pgs\n        allpdfpg = findAllPDFPages pgs\n\n    case mfn of\n      Nothing -> return hdl\n      Just fn -> do\n        let fnstr = C.unpack fn\n            pglst = map show allpdfpg\n            cmdargs =  [fnstr, "cat"] ++ pglst ++ ["output", "-"]\n        print cmdargs\n        (_,Just hout,_,_) <- createProcess (proc "pdftk" cmdargs) { std_out = CreatePipe }\n        bstr <- C.hGetContents hout\n        let ebdsrc = makeEmbeddedPdfSrcString bstr\n            npgs = (IM.fromAscList . replacePDFPages) pgs\n        (return . set gembeddedpdf (Just ebdsrc) . set gpages npgs) hdl\n-}\n\nmakeEmbeddedPdfSrcString :: C.ByteString -> C.ByteString\nmakeEmbeddedPdfSrcString = ("data:application/x-pdf;base64," <>) . encode\n\n-- |\nmakeNewHoodleWithPDF ::\n  -- | doesEmbedPDF\n  Bool ->\n  -- | pdf file\n  FilePath ->\n  IO (Maybe Hoodle)\nmakeNewHoodleWithPDF doesembed ofp = do\n  ocanonicalfp <- canonicalizePath ofp\n  let ofname = C.pack ocanonicalfp\n  let sizelimit = 10000000\n  siz <- do\n    h <- openFile ofp ReadMode\n    s <- hFileSize h\n    hClose h\n    return s\n  (nfp, nfname) <-\n    if siz > sizelimit\n      then do\n        putStrLn $ "size is " ++ show siz ++ ", which is larger than " ++ show sizelimit\n        nfp\' <- mkTmpFile "pdf"\n        let nfname\' = C.pack nfp\'\n        _ <-\n          readProcess\n            "gs"\n            [ "-q",\n              "-dNOPAUSE",\n              "-dBATCH",\n              "-dSAFER",\n              "-sDEVICE=pdfwrite",\n              "-dCompatibilityLevel=1.3",\n              "-dPDFSETTINGS=/screen",\n              "-dEmbedAllFonts=true",\n              "-dSubsetFonts=true",\n              "-dColorImageDownsampleType=/Bicubic",\n              "-dColorImageResolution=72",\n              "-dGrayImageDownsampleType=/Bicubic",\n              "-dGrayImageResolution=72",\n              "-dMonoImageDownsampleType=/Bicubic",\n              "-dMonoImageResolution=72",\n              "-sOutputFile=" ++ nfp\',\n              ofp\n            ]\n            ""\n        return (nfp\', nfname\')\n      else return (ocanonicalfp, ofname)\n\n  -- mdoc <- popplerGetDocFromFile nfname\n  let mdoc = Nothing\n  case mdoc of\n    Nothing -> do\n      putStrLn $ "no such file " ++ nfp\n      pure Nothing\n    Just doc -> do\n      pure Nothing\n\n{-      n <- Poppler.documentGetNPages doc\n\n      let createPageAct i = do\n            pg <- Poppler.documentGetPage doc (i - 1)\n            (w, h) <- PopplerPage.pageGetSize pg\n            let dim = Dim w h\n            return (createPage doesembed dim nfname i)\n      pgs <- mapM createPageAct [1 .. n]\n      hdl <- set title nfname . set pages pgs <$> emptyHoodle\n      nhdl <-\n        if doesembed\n          then do\n            bstr <- C.readFile nfp\n            let ebdsrc = makeEmbeddedPdfSrcString bstr\n            return (set embeddedPdf (Just ebdsrc) hdl)\n          else return hdl\n      return (Just nhdl)\n-}\n\n-- |\ncreatePage ::\n  -- | does embed pdf?\n  Bool ->\n  Dimension ->\n  C.ByteString ->\n  Int ->\n  Page\ncreatePage doesembed dim fn n =\n  let bkg\n        | not doesembed && n == 1 =\n          BackgroundPdf "pdf" (Just "absolute") (Just fn) n\n        | not doesembed && n /= 1 =\n          BackgroundPdf "pdf" Nothing Nothing n\n        | otherwise -- doesembed\n          =\n          BackgroundEmbedPdf "embedpdf" n\n   in Page dim bkg [emptyLayer]\n\n-- |\nsaveHoodle :: UnitHoodle -> IO UnitHoodle\nsaveHoodle uhdl = do\n  let hdl = (rHoodle2Hoodle . getHoodle) uhdl\n  case view (hoodleFileControl . hoodleFileName) uhdl of\n    LocalDir Nothing -> return uhdl\n    LocalDir (Just filename) -> action hdl filename\n    TempDir filename -> action hdl filename\n  where\n    action hdl filename = do\n      L.writeFile filename . builder $ hdl\n      ctime <- getCurrentTime\n      return (set isSaved True . set (hoodleFileControl . lastSavedTime) (Just ctime) $ uhdl)\n\n-- |\nmakeNewItemImage ::\n  -- | isEmbedded?\n  Bool ->\n  FilePath ->\n  IO Item\nmakeNewItemImage isembedded filename =\n  if isembedded\n    then\n      let fileext = takeExtension filename\n          imgaction\n            | fileext == ".PNG" || fileext == ".png" = loadpng\n            | fileext == ".JPG" || fileext == ".jpg" = loadjpg\n            | otherwise = loadsrc\n       in imgaction\n    else loadsrc\n  where\n    loadsrc = (return . ItemImage) (Image (C.pack filename) (100, 100) (Dim 300 300))\n    loadpng = do\n      img <- loadPngFile filename\n      (w, h) <- imageSize img\n      let dim\n            | w < 612 && h < 792 = Dim (fromIntegral w) (fromIntegral h)\n            | w < 765 && h < 990 =\n              Dim\n                (fromIntegral w * 72 / 90)\n                (fromIntegral h * 72 / 90)\n            | w >= h = Dim 300 (fromIntegral h * 300 / fromIntegral w)\n            | otherwise = Dim (fromIntegral w * 300 / fromIntegral h) 300\n      bstr <- C.readFile filename\n      let b64str = encode bstr\n          ebdsrc = "data:image/png;base64," <> b64str\n      return . ItemImage $ Image ebdsrc (50, 100) dim\n    loadjpg = do\n      img <- loadJpegFile filename\n      (w, h) <- imageSize img\n      let dim\n            | w < 612 && h < 792 = Dim (fromIntegral w) (fromIntegral h)\n            | w < 765 && h < 990 =\n              Dim\n                (fromIntegral w * 72 / 90)\n                (fromIntegral h * 72 / 90)\n            | w >= h = Dim 300 (fromIntegral h * 300 / fromIntegral w)\n            | otherwise = Dim (fromIntegral w * 300 / fromIntegral h) 300\n      bstr <- savePngByteString img\n      let b64str = encode bstr\n          ebdsrc = "data:image/png;base64," <> b64str\n      return . ItemImage $ Image ebdsrc (50, 100) dim\n'