b"{-# LANGUAGE CPP #-}\n-- |\n-- Copyright  : (c) Ivan Perez and Manuel Baerenz, 2016\n-- License    : BSD3\n-- Maintainer : ivan.perez@keera.co.uk\n--\n-- 'MSF's with a 'State' monadic layer.\n--\n-- This module contains functions to work with 'MSF's that include a 'State'\n-- monadic layer. This includes functions to create new 'MSF's that include an\n-- additional layer, and functions to flatten that layer out of the 'MSF`'s\n-- transformer stack.\n--\n-- It is based on the _strict_ state monad 'Control.Monad.Trans.State.Strict',\n-- so when combining it with other modules such as @mtl@'s,\n-- the strict version has to be included, i.e. 'Control.Monad.State.Strict'\n-- instead of 'Control.Monad.State' or 'Control.Monad.State.Lazy'.\nmodule Control.Monad.Trans.MSF.State\n    ( module Control.Monad.Trans.State.Strict\n    -- * 'State' 'MSF' running and wrapping\n    , stateS\n    , runStateS\n    , runStateS_\n    , runStateS__\n    )\n  where\n\n-- External imports\n#if !MIN_VERSION_base(4,8,0)\nimport Control.Applicative ((<$>))\n#endif\n\nimport Control.Arrow                    (arr, (>>>))\nimport Control.Monad.Trans.State.Strict hiding (liftCallCC, liftCatch,\n                                         liftListen, liftPass)\nimport Data.Tuple                       (swap)\n\n-- Internal imports\nimport Data.MonadicStreamFunction.Core (MSF, morphGS, feedback)\n\n-- * 'State' 'MSF' running and wrapping\n\n-- | Build an 'MSF' in the 'State' monad from one that takes the state as an\n-- extra input. This is the opposite of 'runStateS'.\nstateS :: (Functor m, Monad m) => MSF m (s, a) (s, b) -> MSF (StateT s m) a b\nstateS = morphGS $ \\f a -> StateT $ \\s -> (\\((s', b), c) -> ((b, c), s'))\n     <$> f (s, a)\n\n-- | Build an 'MSF' that takes a state as an extra input from one on the\n-- 'State' monad. This is the opposite of 'stateS'.\nrunStateS :: (Functor m, Monad m) => MSF (StateT s m) a b -> MSF m (s, a) (s, b)\nrunStateS = morphGS $ \\f (s, a) -> (\\((b, c), s') -> ((s', b), c))\n        <$> runStateT (f a) s\n\n-- | Build an 'MSF' /function/ that takes a fixed state as additional input,\n-- from an 'MSF' in the 'State' monad, and outputs the new state with every\n-- transformation step.\nrunStateS_ :: (Functor m, Monad m)\n           => MSF (StateT s m) a b\n           -> s\n           -> MSF m a (s, b)\nrunStateS_ msf s =\n  feedback s $\n    arr swap >>> runStateS msf >>> arr (\\(s', b) -> ((s', b), s'))\n\n-- | Build an 'MSF' /function/ that takes a fixed state as additional input,\n-- from an 'MSF' in the 'State' monad.\nrunStateS__ :: (Functor m, Monad m) => MSF (StateT s m) a b -> s -> MSF m a b\nrunStateS__ msf s = runStateS_ msf s >>> arr snd\n"