b'// ModInstaller.cpp : Definiert die exportierten Funktionen f\xfcr die DLL-Anwendung.\n//\n\n#include "stdafx.h"\n#include <stdio.h>\n#include <tchar.h>\n#include "../libStringConverter/convert.h"\n#include "../AssetsTools/AssetsFileReader.h"\n#include "../AssetsTools/InternalBundleReplacer.h"\n#include "InstallerDataFormat.h"\n#include "ModInstaller.h"\n#include "InstallDialog.h"\n#include <string>\n#include <assert.h>\n\nHMODULE DelayResolveImport(HMODULE hModule, PIMAGE_IMPORT_DESCRIPTOR pDescriptor)\n{\n\tif (!pDescriptor->Name || !pDescriptor->FirstThunk)\n\t\treturn NULL;\n\tHMODULE hNewLibrary = LoadLibraryA((LPCSTR) &((uint8_t*)hModule)[pDescriptor->Name]);\n\tif (!hNewLibrary)\n\t\treturn NULL;\n\tPIMAGE_THUNK_DATA pThunks = (PIMAGE_THUNK_DATA) &((uint8_t*)hModule)[pDescriptor->FirstThunk];\n\tfor (size_t i = 0; pThunks[i].u1.Function != 0; i++)\n\t{\n\t\tPVOID proc = NULL;\n\t\tif (IMAGE_SNAP_BY_ORDINAL(pThunks[i].u1.Ordinal))\n\t\t{\n\t\t\tproc = GetProcAddress(hNewLibrary, (LPCSTR) IMAGE_ORDINAL(pThunks[i].u1.Ordinal));\n\t\t\tif (!proc)\n\t\t\t{\n\t\t\t\tFreeLibrary(hNewLibrary);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tPIMAGE_IMPORT_BY_NAME pImport = (PIMAGE_IMPORT_BY_NAME) &((uint8_t*)hModule)[pThunks[i].u1.AddressOfData];\n\t\t\tproc = GetProcAddress(hNewLibrary, (LPCSTR)&pImport->Name[0]);\n\t\t\tif (!proc)\n\t\t\t{\n\t\t\t\tFreeLibrary(hNewLibrary);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t}\n\t\tDWORD dwOldProt;\n\t\tVirtualProtect(&pThunks[i].u1.Function, sizeof(ULONG_PTR), PAGE_EXECUTE_READWRITE, &dwOldProt);\n\t\tpThunks[i].u1.Function = (ULONG_PTR)proc;\n\t\tVirtualProtect(&pThunks[i].u1.Function, sizeof(ULONG_PTR), dwOldProt, &dwOldProt);\n\t}\n\treturn hNewLibrary;\n}\n\nstatic std::string getModulePath(HINSTANCE hInstance)\n{\n\tstd::vector<TCHAR> modulePathT;\n\tsize_t ownPathLen = MAX_PATH;\n\twhile (true)\n\t{\n\t\tmodulePathT.resize(ownPathLen + 1, 0);\n\t\tSetLastError(0);\n\t\tDWORD result = GetModuleFileName(hInstance, modulePathT.data(), (DWORD)ownPathLen);\n\t\tif (result == 0)\n\t\t{\n\t\t\tmodulePathT.clear();\n\t\t\tbreak;\n\t\t}\n\t\telse if (result == ownPathLen && GetLastError() == ERROR_INSUFFICIENT_BUFFER)\n\t\t\townPathLen += MAX_PATH;\n\t\telse\n\t\t\tbreak;\n\t}\n\n\tsize_t outLen = 0;\n\tchar *modulePath8 = _TCHARToMultiByte(modulePathT.data(), outLen);\n\tstd::string modulePath(modulePath8);\n\t_FreeCHAR(modulePath8);\n\treturn modulePath;\n}\n\n//Also checks that all section headers are in bounds.\nsize_t GetPEOverlayOffset(IAssetsReader *pReader)\n{\n\tIMAGE_DOS_HEADER dosHeader = {};\n\tif (pReader->Read(0, sizeof(IMAGE_DOS_HEADER), &dosHeader) != sizeof(IMAGE_DOS_HEADER))\n\t\treturn 0;\n\tQWORD fileHeaderPos = dosHeader.e_lfanew + sizeof(IMAGE_NT_SIGNATURE);\n\tIMAGE_FILE_HEADER fileHeader = {};\n\tif (pReader->Read(fileHeaderPos, sizeof(IMAGE_FILE_HEADER), &fileHeader) != sizeof(IMAGE_FILE_HEADER))\n\t\treturn 0;\n\tstd::vector<uint8_t> optHeaderBuf(fileHeader.SizeOfOptionalHeader);\n\tif (pReader->Read(fileHeaderPos + sizeof(IMAGE_FILE_HEADER), fileHeader.SizeOfOptionalHeader, optHeaderBuf.data()) != fileHeader.SizeOfOptionalHeader)\n\t\treturn 0;\n\tDWORD fileAlignment = 1;\n\tif (fileHeader.Machine == 0x014C) //is i386 / 32bit\n\t\tfileAlignment = ((IMAGE_OPTIONAL_HEADER32*)optHeaderBuf.data())->FileAlignment;\n\telse if (fileHeader.Machine == 0x8664) //is AMD64 / 64bit\n\t\tfileAlignment = ((IMAGE_OPTIONAL_HEADER64*)optHeaderBuf.data())->FileAlignment;\n\telse\n\t\treturn 0;\n\tif (fileAlignment == 0 || fileAlignment >= 0x7FFFFFFF\n\t\t|| ((fileAlignment + (fileAlignment - 1)) & ~(fileAlignment - 1)) != fileAlignment\n\t\t|| ((2*fileAlignment) & ~(fileAlignment - 1)) != 2*fileAlignment)\n\t\treturn 0; //Rudimentary check that fileAlignment is a power of two (may not be fully precise), just in case. \n\tQWORD sectionHeadersPos = fileHeaderPos + sizeof(IMAGE_FILE_HEADER) + fileHeader.SizeOfOptionalHeader;\n\tstd::vector<IMAGE_SECTION_HEADER> sectionHeaders(fileHeader.NumberOfSections);\n\tif (pReader->Read(sectionHeadersPos, sizeof(IMAGE_SECTION_HEADER) * sectionHeaders.size(), sectionHeaders.data())\n\t\t!= sizeof(IMAGE_SECTION_HEADER) * sectionHeaders.size())\n\t\treturn 0;\n\n\tDWORD rawEndAddressMax = 0;\n\tfor (size_t _i = sectionHeaders.size(); _i > 0; --_i)\n\t{\n\t\tsize_t i = _i - 1;\n\t\tif (sectionHeaders[i].SizeOfRawData > 0)\n\t\t{\n\t\t\tDWORD downAlignedRawPtr = sectionHeaders[i].PointerToRawData & ~511;\n\t\t\tDWORD endOfRaw = sectionHeaders[i].PointerToRawData + sectionHeaders[i].SizeOfRawData;\n\t\t\tendOfRaw = (endOfRaw + (fileAlignment - 1)) & ~(fileAlignment - 1);\n\n\t\t\tDWORD actualSize = (sectionHeaders[i].Misc.VirtualSize != 0)\n\t\t\t\t? std::min(sectionHeaders[i].Misc.VirtualSize, endOfRaw - downAlignedRawPtr)\n\t\t\t\t: (endOfRaw - downAlignedRawPtr);\n\t\t\tactualSize = (actualSize + 511) & ~511;\n\n\t\t\tDWORD selfEndAddress = downAlignedRawPtr + actualSize;\n\t\t\tif (selfEndAddress < sectionHeaders[i].PointerToRawData)\n\t\t\t\tassert(false);\n\t\t\trawEndAddressMax = std::max(rawEndAddressMax, selfEndAddress);\n\t\t}\n\t}\n\treturn rawEndAddressMax;\n}\n\nvoid RunModInstaller(HINSTANCE hInstance);\nextern "C" BOOL WINAPI _CRT_INIT(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpReserved);\nextern "C"\n{\n\t//Initialize to 1 instead of 0 to make sure this field is not stripped from the .dll file as uninitialized data\n\t__declspec(dllexport) DWORD delayResolveImportRVAs[32] = {1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1}; //if one is null or 1, it\'s not imported\n\t__declspec(dllexport) int APIENTRY _WinMain();\n}\nint APIENTRY _WinMain()\n{\n#ifdef _DEBUG\n\tMessageBox(NULL, \n\t\tTEXT("Installer says hello!"),\n\t\tTEXT("UABE Mod installer"), 0);\n#endif\n\tHINSTANCE hInstance = GetModuleHandle(NULL);\n\tfor (DWORD i = 0; i < sizeof(delayResolveImportRVAs) / sizeof(DWORD); i++)\n\t{\n\t\tif (delayResolveImportRVAs[i] > 1)\n\t\t{\n\t\t\tif (!DelayResolveImport(hInstance, (PIMAGE_IMPORT_DESCRIPTOR)( &((uint8_t*)hInstance)[delayResolveImportRVAs[i]] )))\n\t\t\t{\n\t\t\t\tMessageBox(NULL, \n\t\t\t\t\tTEXT("Unable to find the MSVC++ 2022 redistributable!\\nMake sure the 32bit and 64bit versions are installed."),\n\t\t\t\t\tTEXT("UABE Mod installer"), 16);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\t_CRT_INIT(hInstance, DLL_PROCESS_ATTACH, NULL);\n\tHeapSetInformation(GetProcessHeap(), HeapEnableTerminationOnCorruption, NULL, 0);\n\n\tRunModInstaller(hInstance);\n\n\texit(0);\n\t_CRT_INIT(hInstance, DLL_PROCESS_DETACH, NULL);\n\treturn 0;\n}\n\nstatic void RunModInstaller(HINSTANCE hInstance)\n{\n\tstd::string selfPath = getModulePath(hInstance);\n\tstd::unique_ptr<IAssetsReader> pSelfReader(Create_AssetsReaderFromFile(selfPath.c_str(), true, RWOpenFlags_Immediately));\n\tQWORD selfFileEnd = 0;\n\tsize_t overlayOffset = 0;\n\tif (pSelfReader != nullptr)\n\t{\n\t\tpSelfReader->Seek(AssetsSeek_End, 0);\n\t\tpSelfReader->Tell(selfFileEnd);\n\t}\n\tif (pSelfReader == nullptr || (overlayOffset = GetPEOverlayOffset(pSelfReader.get())) == 0 || selfFileEnd <= overlayOffset)\n\t{\n\t\tMessageBox(NULL, \n\t\t\tTEXT("Unable to locate the installer data. Make sure the installer executable is readable, or try moving the installer to another directory."),\n\t\t\tTEXT("UABE Mod installer"), 0);\n\t\treturn;\n\t}\n\tstd::unique_ptr<InstallDialogsData> pInstallDialogs(InitInstallDialogs(hInstance));\n\tif (pInstallDialogs == nullptr)\n\t{\n\t\tMessageBox(NULL, \n\t\t\tTEXT("Unable to create the installer window. I have no idea why this happened."),\n\t\t\tTEXT("UABE Mod installer"), 0);\n\t\treturn;\n\t}\n\tDialogController_Prepare *pPrepDlgController = dynamic_cast<DialogController_Prepare*>(pInstallDialogs->pControllers[InstallDialog_Prepare]);\n\t\n\tpPrepDlgController->SetStatus(InstallDialogPrepareStatus_LoadInstData, InstallPrepareStatus_Active);\n\n\tstd::unique_ptr<IAssetsReader> pPackageReader(\n\t\tCreate_AssetsReaderFromReaderRange(pSelfReader.get(), overlayOffset, selfFileEnd - overlayOffset));\n\t//AssetsReaderFromSplitResourceWrapper readerWrapper(readerPar);\n\n\tInstallerPackageFile packageFile;\n\tQWORD filePos = 0;\n\tbool readPackage = packageFile.Read(filePos, pPackageReader.get());\n\tif (!readPackage)\n\t{\n\t\tpPrepDlgController->SetStatus(InstallDialogPrepareStatus_LoadInstData, InstallPrepareStatus_Error);\n\t\tMessageBox(NULL, \n\t\t\tTEXT("Unable to load the installer data. Either the installer is invalid, or the system is out of memory."),\n\t\t\tTEXT("UABE Mod installer"), 0);\n\t\tCloseDialogThread(pInstallDialogs.get());\n\t\treturn;\n\t}\n\tSanitizePackageFile(packageFile);\n\n\tpPrepDlgController->SetStatus(InstallDialogPrepareStatus_LoadInstData, InstallPrepareStatus_Completed);\n\tif (!ShowInstallDialog(pInstallDialogs.get(), InstallDialog_Introduction))\n\t{\n\t\tCloseDialogThread(pInstallDialogs.get());\n\t\treturn;\n\t}\n\tfor (int i = 0; i < InstallDialog_COUNT; i++)\n\t{\n\t\tDialogControllerTitled *titledController =\n\t\t\tdynamic_cast<DialogControllerTitled*>(pInstallDialogs->pControllers[i]);\n\t\tif (titledController)\n\t\t\ttitledController->SetModName(packageFile.modName.c_str());\n\t}\n\tDialogController_Description *pDescController = \n\t\tdynamic_cast<DialogController_Description*>(pInstallDialogs->pControllers[InstallDialog_Description]);\n\tpDescController->SetAuthors(packageFile.modCreators.c_str());\n\tpDescController->SetDescription(packageFile.modDescription.c_str());\n\tDialogController_PathSelect *pPathController = \n\t\tdynamic_cast<DialogController_PathSelect*>(pInstallDialogs->pControllers[InstallDialog_PathSelect]);\n\tDialogController_Progress *pProgressController = \n\t\tdynamic_cast<DialogController_Progress*>(pInstallDialogs->pControllers[InstallDialog_Progress]);\n\tDialogController_Complete *pCompleteController = \n\t\tdynamic_cast<DialogController_Complete*>(pInstallDialogs->pControllers[InstallDialog_Complete]);\n\t{\n\t\tDWORD curDirLen = GetCurrentDirectory(0, NULL);\n\t\t//curDirLen includes the null-char but it could also be 0 if there\'s an error\n\t\tTCHAR *curDir = new TCHAR[curDirLen + 1];\n\t\tGetCurrentDirectory(curDirLen, curDir);\n\t\tcurDir[curDirLen] = 0;\n\t\tpPathController->SetPath(curDir);\n\t\tdelete[] curDir;\n\t}\n\tpPathController->FillModsTree(&packageFile);\n\tsize_t selPathLen = 0; TCHAR *selPath = NULL;\n\twhile (true)\n\t{\n\t\tWaitInstall_Loop:\n\t\tEInstallDialogs newDialogType = WaitForDialogChanged(pInstallDialogs.get());\n\t\tif (newDialogType == (EInstallDialogs)-1)\n\t\t{\n\t\t\tCloseDialogThread(pInstallDialogs.get());\n\t\t\treturn;\n\t\t}\n\t\tif (newDialogType == InstallDialog_Progress)\n\t\t{\n\t\t\tselPath = pPathController->GetPath(selPathLen);\n\t\t\tif (!SetCurrentDirectory(selPath))\n\t\t\t{\n\t\t\t\tDWORD msgResult = MessageBox(pInstallDialogs->hWindow, \n\t\t\t\t\tTEXT("Unable to switch to the path entered, most likely it\'s invalid.\\n")\\\n\t\t\t\t\tTEXT("Press OK to ignore and continue, press Cancel to retry."),\n\t\t\t\t\tTEXT("UABE Mod Installer"),\n\t\t\t\t\tMB_OKCANCEL | MB_ICONWARNING);\n\t\t\t\tif (msgResult == IDCANCEL)\n\t\t\t\t{\n\t\t\t\t\tShowInstallDialog(pInstallDialogs.get(), InstallDialog_PathSelect);\n\t\t\t\t\tgoto WaitInstall_Loop;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (size_t i = 0; i < packageFile.affectedAssets.size(); i++)\n\t\t\t{\n\t\t\t\tTCHAR *_MultiByteToTCHAR(const char *mb, size_t &len);\n\t\t\t\tvoid _FreeTCHAR(TCHAR *tc);\n\t\t\t\tsize_t pathLenT;\n\t\t\t\tTCHAR *pathT = _MultiByteToTCHAR(packageFile.affectedAssets[i].path.c_str(), pathLenT);\n\t\t\t\tFILE *testFile = _tfopen(pathT, TEXT("rb"));\n\t\t\t\tif (!testFile)\n\t\t\t\t{\n\t\t\t\t\tTCHAR *sprntTmp = new TCHAR[pathLenT + 164];\n\t\t\t\t\t_stprintf_s(sprntTmp, pathLenT + 164, \n\t\t\t\t\t\tTEXT("Unable to open %s! Likely it\'s not in the path entered or it\'s locked.")\\\n\t\t\t\t\t\tTEXT("Press abort to select another path, retry to retry or ignore to continue."), pathT);\n\t\t\t\t\tDWORD msgResult = MessageBox(pInstallDialogs->hWindow,\n\t\t\t\t\t\tsprntTmp,\n\t\t\t\t\t\tTEXT("UABE Mod Installer"),\n\t\t\t\t\t\tMB_ABORTRETRYIGNORE | MB_ICONWARNING);\n\t\t\t\t\tdelete[] sprntTmp;\n\t\t\t\t\tif (msgResult == IDABORT)\n\t\t\t\t\t{\n\t\t\t\t\t\t_FreeTCHAR(pathT);\n\t\t\t\t\t\tShowInstallDialog(pInstallDialogs.get(), InstallDialog_PathSelect);\n\t\t\t\t\t\tgoto WaitInstall_Loop;\n\t\t\t\t\t}\n\t\t\t\t\tif (msgResult == IDRETRY)\n\t\t\t\t\t\ti--;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tfclose(testFile);\n\t\t\t\t_FreeTCHAR(pathT);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\t\t\t\n\tInstall(packageFile, NULL, pProgressController, pCompleteController);\n\n\t//FreeAssetsReaderFromSplitResource(readerPar);\n\twhile (true)\n\t{\n\t\tEInstallDialogs newDialogType = WaitForDialogChanged(pInstallDialogs.get());\n\t\tif (newDialogType == (EInstallDialogs)-1)\n\t\t{\n\t\t\tCloseDialogThread(pInstallDialogs.get());\n\t\t\treturn;\n\t\t}\n\t}\n}\n\n\n\nvoid SanitizePackageFile(InstallerPackageFile &packageFile)\n{\n\tfor (size_t i = 0; i < packageFile.affectedAssets.size(); i++)\n\t{\n\t\tInstallerPackageAssetsDesc &assetsDesc = packageFile.affectedAssets[i];\n\t\tfor (size_t k = 0; k < assetsDesc.replacers.size(); k++)\n\t\t{\n\t\t\tif (assetsDesc.replacers[k] == NULL)\n\t\t\t{\n\t\t\t\tassetsDesc.replacers.erase(assetsDesc.replacers.begin() + k);\n\t\t\t\tk--;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t}\n}\n\ntypedef void(_cdecl *LogCallback)(const char *message);\nstatic void LogToBoth(const char *message, DialogController_Progress *pProgressController, LogCallback log)\n{\n\tif (pProgressController)\n\t\tpProgressController->AddToLog(message);\n\tif (log)\n\t\tlog(message);\n}\nstatic void LogToBoth(const wchar_t *message, DialogController_Progress *pProgressController, LogCallback log)\n{\n\tif (pProgressController)\n\t\tpProgressController->AddToLog(message);\n\tif (log)\n\t{\n\t\tsize_t mbLen = 0;\n\t\tchar *mbMessage = _WideToMultiByte(message, mbLen);\n\t\tlog(mbMessage);\n\t\t_FreeCHAR(mbMessage);\n\t}\n}\nint Install(InstallerPackageFile &packageFile, LogCallback log, \n\tDialogController_Progress *pProgressController, DialogController_Complete *pCompleteController)\n{\n\tbool errorsOccured = false;\n\tdouble curFileLenProgress = (double)0.99F / (double)packageFile.affectedAssets.size();\n\tstruct InstallFileDesc\n\t{\n\t\tstd::basic_string<TCHAR> tOrigFilePath;\n\t\tbool originalFileExists = false;\n\t};\n\tstd::vector<InstallFileDesc> fileDescs(packageFile.affectedAssets.size());\n\tfor (size_t i = 0; i < packageFile.affectedAssets.size(); i++)\n\t{\n\t\tif (pProgressController && pProgressController->GetCancelled())\n\t\t\tbreak;\n\t\tInstallerPackageAssetsDesc &affectedDesc = packageFile.affectedAssets[i];\n\n\t\tdouble curFileBeginProgress = (double)i * (double)0.99F / (double)packageFile.affectedAssets.size();\n\t\tif (pProgressController)\n\t\t\tpProgressController->SetProgress((float)(curFileBeginProgress * 100.0), affectedDesc.path.c_str());\n\n\t\tbool needsOriginalFile = true;\n\t\tif (affectedDesc.type == InstallerPackageAssetsType::Resources)\n\t\t{\n\t\t\tif (affectedDesc.replacers.size() == 1 &&\n\t\t\t\tdynamic_cast<BundleEntryModifierByResources*>(\n\t\t\t\t\treinterpret_cast<BundleReplacer*>(affectedDesc.replacers[0].get())\n\t\t\t\t\t) != nullptr)\n\t\t\t{\n\t\t\t\tneedsOriginalFile = \n\t\t\t\t\treinterpret_cast<BundleEntryModifierByResources*>(affectedDesc.replacers[0].get())\n\t\t\t\t\t->RequiresEntryReader();\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\terrorsOccured = true;\n\t\t\t\tLogToBoth("ERROR: Unexpected resource file replacer!\\r\\n", pProgressController, log);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tsize_t pathLenT;\n\t\tauto pathT = unique_MultiByteToTCHAR(affectedDesc.path.c_str(), pathLenT);\n\t\tstd::unique_ptr<IAssetsReader> pCurReader;\n\t\tif (needsOriginalFile)\n\t\t{\n\t\t\tLogToBoth("Opening file ", pProgressController, log);\n\t\t\tLogToBoth(pathT.get(), pProgressController, log);\n\t\t\tpCurReader.reset(Create_AssetsReaderFromFile(pathT.get(), true, RWOpenFlags_Immediately));\n\t\t\t//FILE *curFile = _tfopen(pathT, TEXT("rb"));\n\t\t\tif (!pCurReader)\n\t\t\t{\n\t\t\t\terrorsOccured = true;\n\t\t\t\tLogToBoth(" [FAILURE]\\r\\n", pProgressController, log);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tLogToBoth(" [SUCCESS]\\r\\n", pProgressController, log);\n\t\t\tfileDescs[i].originalFileExists = true;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tstd::unique_ptr<IAssetsReader> tmpReader(Create_AssetsReaderFromFile(pathT.get(), true, RWOpenFlags_Immediately));\n\t\t\tfileDescs[i].originalFileExists = (tmpReader != nullptr);\n\t\t}\n\t\tbool curFileModded = false;\n\t\tstd::basic_string<TCHAR> decompFileName;\n\t\tswitch (affectedDesc.type)\n\t\t{\n\t\tcase InstallerPackageAssetsType::Assets:\n\t\t{\n\t\t\tLogToBoth("Opening assets", pProgressController, log);\n\t\t\tAssetsFile assetsFile = AssetsFile(pCurReader.get());\n\t\t\tif (!assetsFile.VerifyAssetsFile())\n\t\t\t{\n\t\t\t\terrorsOccured = true;\n\t\t\t\tLogToBoth(" [FAILURE]\\r\\n", pProgressController, log);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tLogToBoth(" [SUCCESS]\\r\\n", pProgressController, log);\n\t\t\tif (pProgressController)\n\t\t\t\tpProgressController->SetProgress((float)((curFileBeginProgress + (curFileLenProgress * 0.05F)) * 100.0), affectedDesc.path.c_str());\n\t\t\tstd::basic_string<TCHAR> modFileName = pathT.get();\n\t\t\tmodFileName += TEXT(".mod");\n\t\t\tstd::unique_ptr<IAssetsWriter> pModWriter(Create_AssetsWriterToFile(modFileName.c_str(), true, true, RWOpenFlags_Immediately));\n\t\t\t//FILE *pModFile = _tfopen(modFileName, TEXT("wb"));\n\t\t\tLogToBoth("Modifying and writing assets to ", pProgressController, log);\n\t\t\tLogToBoth(modFileName.c_str(), pProgressController, log);\n\t\t\tif (!pModWriter)\n\t\t\t{\n\t\t\t\terrorsOccured = true;\n\t\t\t\tLogToBoth(" [FAILURE]\\r\\n", pProgressController, log);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (pProgressController)\n\t\t\t\tpProgressController->SetProgress((float)((curFileBeginProgress + (curFileLenProgress * 0.1F)) * 100.0), affectedDesc.path.c_str());\n\t\t\tstd::vector<AssetsReplacer*> pReplacers(affectedDesc.replacers.size());\n\t\t\tfor (size_t i = 0; i < affectedDesc.replacers.size(); ++i)\n\t\t\t\tpReplacers[i] = reinterpret_cast<AssetsReplacer*>(affectedDesc.replacers[i].get());\n\t\t\tif (!assetsFile.Write(pModWriter.get(), 0, pReplacers.data(), pReplacers.size(), 0, &packageFile.addedTypes))\n\t\t\t{\n\t\t\t\terrorsOccured = true;\n\t\t\t\tLogToBoth(" [FAILURE]\\r\\n", pProgressController, log);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tpModWriter.reset();\n\t\t\tLogToBoth(" [SUCCESS]\\r\\n", pProgressController, log);\n\t\t\tcurFileModded = true;\n\t\t}\n\t\tbreak;\n\t\tcase InstallerPackageAssetsType::Bundle:\n\t\t{\n\t\t\tLogToBoth("Opening bundle", pProgressController, log);\n\t\t\tAssetBundleFile bundleFile;\n\t\t\tif (!bundleFile.Read(pCurReader.get(), NULL, true))\n\t\t\t{\n\t\t\t\terrorsOccured = true;\n\t\t\t\tLogToBoth(" [FAILURE]\\r\\n", pProgressController, log);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tLogToBoth(" [SUCCESS]\\r\\n", pProgressController, log);\n\t\t\tif (pProgressController)\n\t\t\t\tpProgressController->SetProgress((float)((curFileBeginProgress + (curFileLenProgress * 0.1F)) * 100.0), affectedDesc.path.c_str());\n\t\t\tbool iscompressed = (bundleFile.IsCompressed() || bundleFile.bundleHeader6.fileVersion >= 6 && (bundleFile.bundleHeader6.flags & 0x3F) != 0);\n\t\t\tif (iscompressed)\n\t\t\t{\n\t\t\t\tdecompFileName.assign(pathT.get());\n\t\t\t\tdecompFileName += TEXT(".decomp");\n\t\t\t\tstd::unique_ptr<IAssetsWriter> pDecompWriter(Create_AssetsWriterToFile(decompFileName.c_str(), true, true, RWOpenFlags_Immediately));\n\t\t\t\t//FILE *pDecompFile = _tfopen(decompFileName, TEXT("wb"));\n\t\t\t\tLogToBoth("Decompressing bundle to ", pProgressController, log);\n\t\t\t\tLogToBoth(decompFileName.c_str(), pProgressController, log);\n\t\t\t\tif (!pDecompWriter)\n\t\t\t\t{\n\t\t\t\t\terrorsOccured = true;\n\t\t\t\t\tLogToBoth(" [FAILURE]\\r\\n", pProgressController, log);\n\t\t\t\t\tbundleFile.Close();\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (!bundleFile.Unpack(pCurReader.get(), pDecompWriter.get()))\n\t\t\t\t{\n\t\t\t\t\terrorsOccured = true;\n\t\t\t\t\tLogToBoth(" [FAILURE]\\r\\n", pProgressController, log);\n\t\t\t\t\tbundleFile.Close();\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tbundleFile.Close();\n\t\t\t\tpDecompWriter.reset();\n\t\t\t\tpCurReader.reset(Create_AssetsReaderFromFile(decompFileName.c_str(), true, RWOpenFlags_Immediately));\n\t\t\t\t//curFile = _tfopen(decompFileName, TEXT("rb"));\n\t\t\t\tif (!pCurReader || !bundleFile.Read(pCurReader.get(), NULL, false))\n\t\t\t\t{\n\t\t\t\t\terrorsOccured = true;\n\t\t\t\t\tLogToBoth(" [FAILURE]\\r\\n", pProgressController, log);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tLogToBoth(" [SUCCESS]\\r\\n", pProgressController, log);\n\t\t\t\tif (pProgressController)\n\t\t\t\t\tpProgressController->SetProgress((float)((curFileBeginProgress + (curFileLenProgress * 0.5F)) * 100.0), affectedDesc.path.c_str());\n\t\t\t}\n\t\t\tstd::basic_string<TCHAR> modFileName = pathT.get();\n\t\t\tmodFileName += TEXT(".mod");\n\t\t\tstd::unique_ptr<IAssetsWriter> pModWriter(Create_AssetsWriterToFile(modFileName.c_str(), true, true, RWOpenFlags_Immediately));\n\t\t\t//FILE *pModFile = _tfopen(modFileName, TEXT("wb"));\n\t\t\tLogToBoth("Modifying and writing bundle to ", pProgressController, log);\n\t\t\tLogToBoth(modFileName.c_str(), pProgressController, log);\n\t\t\tif (!pModWriter)\n\t\t\t{\n\t\t\t\terrorsOccured = true;\n\t\t\t\tLogToBoth(" [FAILURE]\\r\\n", pProgressController, log);\n\t\t\t\tbundleFile.Close();\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tstd::vector<BundleReplacer*> pReplacers(affectedDesc.replacers.size());\n\t\t\tfor (size_t i = 0; i < affectedDesc.replacers.size(); ++i)\n\t\t\t\tpReplacers[i] = reinterpret_cast<BundleReplacer*>(affectedDesc.replacers[i].get());\n\t\t\tif (!bundleFile.Write(pCurReader.get(), pModWriter.get(), pReplacers.data(), pReplacers.size(),\n\t\t\t\tlog, &packageFile.addedTypes))\n\t\t\t{\n\t\t\t\terrorsOccured = true;\n\t\t\t\tLogToBoth(" [FAILURE]\\r\\n", pProgressController, log);\n\t\t\t\tbundleFile.Close();\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbundleFile.Close();\n\t\t\tpModWriter.reset();\n\t\t\tLogToBoth(" [SUCCESS]\\r\\n", pProgressController, log);\n\t\t\tcurFileModded = true;\n\t\t}\n\t\tbreak;\n\t\tcase InstallerPackageAssetsType::Resources:\n\t\t{\n\t\t\tstd::basic_string<TCHAR> modFileName = pathT.get();\n\t\t\tmodFileName += TEXT(".mod");\n\t\t\tstd::unique_ptr<IAssetsWriter> pModWriter(Create_AssetsWriterToFile(modFileName.c_str(), true, true, RWOpenFlags_Immediately));\n\t\t\tLogToBoth(needsOriginalFile ? "Writing resources to " : "Modifying and writing resources to ", pProgressController, log);\n\t\t\tLogToBoth(modFileName.c_str(), pProgressController, log);\n\t\t\tif (!pModWriter)\n\t\t\t{\n\t\t\t\terrorsOccured = true;\n\t\t\t\tLogToBoth(" [FAILURE]\\r\\n", pProgressController, log);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tauto* pEntryModifier = reinterpret_cast<BundleEntryModifierByResources*>(affectedDesc.replacers[0].get());\n\t\t\tif (needsOriginalFile)\n\t\t\t\tpEntryModifier->Init(nullptr, pCurReader.get(), 0, std::numeric_limits<QWORD>::max());\n\t\t\tQWORD newSize = pEntryModifier->Write(0, pModWriter.get());\n\t\t\tif (pEntryModifier->getSize() != newSize)\n\t\t\t{\n\t\t\t\terrorsOccured = true;\n\t\t\t\tLogToBoth(" [INCOMPLETE]\\r\\n", pProgressController, log);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tLogToBoth(" [SUCCESS]\\r\\n", pProgressController, log);\n\t\t\t}\n\t\t\tpEntryModifier->Uninit();\n\t\t}\n\t\tbreak;\n\t\t}\n\t\t\n\t\tif (curFileModded)\n\t\t\tfileDescs[i].tOrigFilePath = pathT.get();\n\t\tpCurReader.reset();\n\t\tif (!decompFileName.empty())\n\t\t{\n\t\t\tLogToBoth("Deleting decompressed unmodded file", pProgressController, log);\n\t\t\tif (DeleteFile(decompFileName.c_str()))\n\t\t\t\tLogToBoth(" [SUCCESS]\\r\\n", pProgressController, log);\n\t\t\telse\n\t\t\t\tLogToBoth(" [FAILURE]\\r\\n", pProgressController, log);\n\t\t}\n\t}\n\tint ret = 0;\n\tif (pProgressController)\n\t\tpProgressController->DisableCancel();\n\tif (pProgressController && pProgressController->GetCancelled())\n\t{\n\t\tfor (size_t _i = packageFile.affectedAssets.size(); _i > 0; _i--)\n\t\t{\n\t\t\tsize_t i = _i - 1;\n\t\t\tdouble curFileBeginProgress = (double)(i + 1) * (double)0.99F / (double)packageFile.affectedAssets.size();\n\t\t\tpProgressController->SetProgress((float)(curFileBeginProgress * 100.0), "");\n\t\t\tif (fileDescs[i].tOrigFilePath.empty())\n\t\t\t\tcontinue;\n\t\t\tLogToBoth("Removing modded file of ", pProgressController, log);\n\t\t\tLogToBoth(fileDescs[i].tOrigFilePath.c_str(), pProgressController, log);\n\t\t\tstd::basic_string<TCHAR> modFileName = fileDescs[i].tOrigFilePath + TEXT(".mod");\n\t\t\tif (DeleteFile(modFileName.c_str()))\n\t\t\t\tLogToBoth(" [SUCCESS]\\r\\n", pProgressController, log);\n\t\t\telse\n\t\t\t\tLogToBoth(" [FAILURE]\\r\\n", pProgressController, log);\n\t\t}\n\t\tpProgressController->SetProgress(0.0F, "");\n\t\tif (pCompleteController)\n\t\t\tpCompleteController->SetCompleteText(\n\t\t\t\tTEXT("The mod installation is cancelled. ")\\\n\t\t\t\tTEXT("No changes have been applied to the files. All temporary files have been removed.\\r\\n")\\\n\t\t\t\tTEXT(""));\n\t\tret = MI_CANCEL;\n\t}\n\telse\n\t{\n\t\tif (pProgressController)\n\t\t\tpProgressController->SetProgress(99.0F, "");\n\t\tif (errorsOccured)\n\t\t{\n\t\t\tif (pCompleteController)\n\t\t\t\tpCompleteController->SetCompleteText(\n\t\t\t\t\tTEXT("At least one error occured while installing the mod.\\r\\n")\\\n\t\t\t\t\tTEXT("Successfully modified files (if there are any) are saved as .mod files.\\r\\n")\\\n\t\t\t\t\tTEXT("Press back and see the log for more details.\\r\\n"));\n\t\t\tret = MI_INCOMPLETE;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tbool allFilesMoved = true;\n\t\t\tfor (size_t i = 0; i < packageFile.affectedAssets.size(); i++)\n\t\t\t{\n\t\t\t\tdouble curFileProgress = (double)0.99F + \n\t\t\t\t\t((double)i * (double)0.01F) / (double)packageFile.affectedAssets.size();\n\t\t\t\tif (pProgressController)\n\t\t\t\t\tpProgressController->SetProgress((float)(curFileProgress * 100.0), packageFile.affectedAssets[i].path.c_str());\n\t\t\t\tif (fileDescs[i].tOrigFilePath.empty())\n\t\t\t\t\tcontinue;\n\t\t\t\tbool doRenameModdedFile = true;\n\t\t\t\tconst std::basic_string<TCHAR>& filePath = fileDescs[i].tOrigFilePath;\n\t\t\t\tstd::vector<TCHAR> backupFilePath;\n\t\t\t\tif (fileDescs[i].originalFileExists)\n\t\t\t\t{\n\t\t\t\t\tLogToBoth("Swapping original and mod of ", pProgressController, log);\n\t\t\t\t\tLogToBoth(fileDescs[i].tOrigFilePath.c_str(), pProgressController, log);\n\t\t\t\t\tbackupFilePath.assign(filePath.begin(), filePath.end());\n\t\t\t\t\t//http://stackoverflow.com/a/6218957\n\t\t\t\t\tint backupIndex = -1;\n\t\t\t\t\tfor (int k = 0; k < 10000; k++)\n\t\t\t\t\t{\n\t\t\t\t\t\tbackupFilePath.resize(filePath.size());\n\t\t\t\t\t\tTCHAR sprntTmp[32];\n\t\t\t\t\t\t_stprintf_s(sprntTmp, TEXT(".bak%04d"), k);\n\t\t\t\t\t\tbackupFilePath.insert(backupFilePath.end(), sprntTmp, sprntTmp + _tcslen(sprntTmp) + 1);\n\t\t\t\t\t\tif (GetFileAttributes(backupFilePath.data()) == INVALID_FILE_ATTRIBUTES)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tbackupIndex = k;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbackupFilePath.push_back(0); //Should not be necessary.\n\t\t\t\t\tif (backupIndex == -1)\n\t\t\t\t\t{\n\t\t\t\t\t\tallFilesMoved = false;\n\t\t\t\t\t\tdoRenameModdedFile = false;\n\t\t\t\t\t\tLogToBoth(" [FAILURE]\\r\\nIt seems like you already have 10000 backups?!?\\r\\n", pProgressController, log);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tif (!MoveFile(filePath.c_str(), backupFilePath.data()))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tallFilesMoved = false;\n\t\t\t\t\t\t\tdoRenameModdedFile = false;\n\t\t\t\t\t\t\tLogToBoth(" [FAILURE]\\r\\nUnable to rename the original file.\\r\\n", pProgressController, log);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (doRenameModdedFile)\n\t\t\t\t{\n\t\t\t\t\tstd::basic_string<TCHAR> modFilePath = filePath + TEXT(".mod");\n\t\t\t\t\tif (!MoveFile(modFilePath.c_str(), filePath.c_str()))\n\t\t\t\t\t{\n\t\t\t\t\t\tallFilesMoved = false;\n\t\t\t\t\t\tLogToBoth(" [FAILURE]\\r\\nUnable to rename the modded file.\\r\\n", pProgressController, log);\n\t\t\t\t\t\tif (!backupFilePath.empty())\n\t\t\t\t\t\t\tMoveFile(backupFilePath.data(), filePath.c_str());\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t\tLogToBoth(" [SUCCESS]\\r\\n", pProgressController, log);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (allFilesMoved)\n\t\t\t{\n\t\t\t\tif (pCompleteController)\n\t\t\t\t\tpCompleteController->SetCompleteText(\n\t\t\t\t\t\tTEXT("The mod has been installed successfully and should now be usable. ")\\\n\t\t\t\t\t\tTEXT("The old files are preserved with .bak + number file names.\\r\\n")\\\n\t\t\t\t\t\tTEXT(""));\n\t\t\t\tret = 0;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (pCompleteController)\n\t\t\t\t\tpCompleteController->SetCompleteText(\n\t\t\t\t\t\tTEXT("The mod is not completely installed. ")\\\n\t\t\t\t\t\tTEXT("Not all original files were moved to backup files (.bak + number) and swapped with modded ones. ")\\\n\t\t\t\t\t\tTEXT("Some modified files still have a .mod file name.\\r\\n")\\\n\t\t\t\t\t\tTEXT("See the log for more details.\\r\\n")\\\n\t\t\t\t\t\tTEXT(""));\n\t\t\t\tret = MI_MOVEFILEFAIL;\n\t\t\t}\n\t\t}\n\t\tif (pProgressController)\n\t\t\tpProgressController->SetProgress(100.0F, "");\n\t}\n\tif (pCompleteController)\n\t\tpCompleteController->SetAuthors(packageFile.modCreators.c_str());\n\tif (pProgressController)\n\t\tpProgressController->EnableContinue();\n\treturn ret;\n}\nint Install(InstallerPackageFile &packageFile, LogCallback log)\n{\n\treturn Install(packageFile, log, NULL, NULL);\n}'