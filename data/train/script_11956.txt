b'{-# LANGUAGE AllowAmbiguousTypes #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n-- | Utility functions for common use cases\nmodule Database.Beam.Migrate.Simple\n  ( autoMigrate\n  , simpleSchema\n  , simpleMigration\n  , runSimpleMigration\n  , backendMigrationScript\n\n  , VerificationResult(..)\n  , verifySchema\n\n  , IgnorePredicates(..)\n  , CheckResult(..)\n  , ignoreTables\n  , ignoreAll\n  , checkSchema\n\n  , createSchema\n\n  , BringUpToDateHooks(..)\n  , defaultUpToDateHooks\n  , bringUpToDate, bringUpToDateWithHooks\n\n  , haskellSchema\n\n  , module Database.Beam.Migrate.Actions\n  , module Database.Beam.Migrate.Types ) where\n\nimport           Prelude hiding (log)\n\nimport           Database.Beam\nimport           Database.Beam.Backend\nimport           Database.Beam.Haskell.Syntax\nimport           Database.Beam.Migrate.Actions\nimport           Database.Beam.Migrate.Backend\nimport           Database.Beam.Migrate.Checks (HasDataTypeCreatedCheck, TableExistsPredicate(..))\nimport           Database.Beam.Migrate.Log\nimport           Database.Beam.Migrate.SQL (BeamMigrateSqlBackendDataTypeSyntax)\nimport           Database.Beam.Migrate.Types\n\nimport           Control.Monad.Cont\nimport           Control.Monad.Writer\nimport           Control.Monad.State\n\nimport qualified Data.HashSet as HS\nimport           Data.Semigroup (Max(..))\nimport           Data.Typeable\nimport           Data.Functor\nimport qualified Data.Text as T\n\nimport qualified Control.Monad.Fail as Fail\n\ndata BringUpToDateHooks m\n  = BringUpToDateHooks\n  { runIrreversibleHook :: m Bool\n    -- ^ Called before we\'re about to run an irreversible migration step. Return\n    -- \'True\' to run the step, or \'False\' to abort immediately.\n  , startStepHook       :: Int -> T.Text -> m ()\n    -- ^ Called at the beginning of each step with the step index and description\n  , endStepHook         :: Int -> T.Text -> m ()\n    -- ^ Called at the end of each step with the step index and description\n  , runCommandHook      :: Int -> String -> m ()\n    -- ^ Called before a command is about to run. The first argument is the step\n    -- index and the second is a string representing the command about to be run.\n\n  , queryFailedHook     :: m ()\n    -- ^ Called when a query fails\n  , discontinuousMigrationsHook\n                        :: Int -> m ()\n    -- ^ Called when the migration log has a discontinuity at the supplied index\n  , logMismatchHook     :: Int -> T.Text -> T.Text -> m ()\n    -- ^ The migration log at the given index is not what was expected. The\n    -- first text is the actual commit id, the second, the expected\n  , databaseAheadHook   :: Int -> m ()\n    -- ^ The database is ahead of the given migrations. The parameter supplies\n    -- the number of entries passed the given migrations the database has.\n  }\n\n-- | Default set of \'BringUpToDateHooks\'. Refuses to run irreversible\n-- migrations, and fails in case of error, using \'fail\'.\ndefaultUpToDateHooks :: Fail.MonadFail m => BringUpToDateHooks m\ndefaultUpToDateHooks =\n  BringUpToDateHooks\n  { runIrreversibleHook = pure False\n  , startStepHook       = \\_ _ -> pure ()\n  , endStepHook         = \\_ _ -> pure ()\n  , runCommandHook      = \\_ _ -> pure ()\n  , queryFailedHook     = Fail.fail "Log entry query fails"\n  , discontinuousMigrationsHook =\n      \\ix -> Fail.fail ("Discontinuous migration log: missing migration at " ++ show ix)\n  , logMismatchHook =\n      \\ix actual expected ->\n        Fail.fail ("Log mismatch at index " ++ show ix ++ ":\\n" ++\n              "  expected: " ++ T.unpack expected ++ "\\n" ++\n              "  actual  : " ++ T.unpack actual)\n  , databaseAheadHook =\n      \\aheadBy ->\n        Fail.fail ("The database is ahead of the known schema by " ++ show aheadBy ++ " migration(s)")\n  }\n\n-- | Equivalent to calling \'bringUpToDateWithHooks\' with \'defaultUpToDateHooks\'.\n--\n-- Tries to bring the database up to date, using the database log and the given\n-- \'MigrationSteps\'. Fails if the migration is irreversible, or an error occurs.\nbringUpToDate :: ( Database be db, Fail.MonadFail m\n                 , HasDataTypeCreatedCheck (BeamMigrateSqlBackendDataTypeSyntax be) )\n              => BeamMigrationBackend be m\n              -> MigrationSteps be () (CheckedDatabaseSettings be db)\n              -> m (Maybe (CheckedDatabaseSettings be db))\nbringUpToDate be@BeamMigrationBackend {} =\n  bringUpToDateWithHooks defaultUpToDateHooks be\n\n-- | Check for the beam-migrate log. If it exists, use it and the supplied\n-- migrations to bring the database up-to-date. Otherwise, create the log and\n-- run all migrations.\n--\n-- Accepts a set of hooks that can be used to customize behavior. See the\n-- documentation for \'BringUpToDateHooks\' for more information. Calling this\n-- with \'defaultUpToDateHooks\' is the same as using \'bringUpToDate\'.\nbringUpToDateWithHooks :: forall db be m\n                        . ( Database be db, Fail.MonadFail m\n                          , HasDataTypeCreatedCheck (BeamMigrateSqlBackendDataTypeSyntax be) )\n                       => BringUpToDateHooks m\n                       -> BeamMigrationBackend be m\n                       -> MigrationSteps be () (CheckedDatabaseSettings be db)\n                       -> m (Maybe (CheckedDatabaseSettings be db))\nbringUpToDateWithHooks hooks be@(BeamMigrationBackend { backendRenderSyntax = renderSyntax\' }) steps = do\n  ensureBackendTables be\n\n  entries <- runSelectReturningList $ select $ orderBy_ (asc_ . _logEntryId) $\n             all_ (_beamMigrateLogEntries (beamMigrateDb @be @m))\n  let verifyMigration :: Int -> T.Text -> Migration be a -> StateT [LogEntry] (WriterT (Max Int) m) a\n      verifyMigration stepIx stepNm step =\n        do log <- get\n           case log of\n             [] -> pure ()\n             LogEntry actId actStepNm _:log\'\n               | fromIntegral actId == stepIx && actStepNm == stepNm ->\n                   tell (Max stepIx) >> put log\'\n               | fromIntegral actId /= stepIx ->\n                   lift . lift $ discontinuousMigrationsHook hooks stepIx\n               | otherwise ->\n                   lift . lift $ logMismatchHook hooks stepIx actStepNm stepNm\n           executeMigration (\\_ -> pure ()) step\n\n  (futureEntries, Max lastCommit) <-\n    runWriterT (execStateT (runMigrationSteps 0 Nothing steps verifyMigration) entries <*\n                tell (Max (-1)))\n\n  case futureEntries of\n    _:_ -> databaseAheadHook hooks (length futureEntries)\n    [] -> pure ()\n\n  -- Check data loss\n  shouldRunMigration <-\n    flip runContT (\\_ -> pure True) $\n    runMigrationSteps (lastCommit + 1) Nothing steps\n      (\\_ _ step -> do\n          case migrationDataLoss step of\n            MigrationLosesData ->\n              ContT $ \\_ -> runIrreversibleHook hooks\n            MigrationKeepsData ->\n              executeMigration (\\_ -> pure ()) step)\n\n  if shouldRunMigration\n    then Just <$>\n         runMigrationSteps (lastCommit + 1) Nothing steps\n           (\\stepIx stepName step ->\n              do startStepHook hooks stepIx stepName\n                 ret <-\n                   executeMigration\n                     (\\cmd -> do\n                         runCommandHook hooks stepIx (renderSyntax\' cmd)\n                         runNoReturn cmd)\n                     step\n\n                 runInsert $ insert (_beamMigrateLogEntries (beamMigrateDb @be @m)) $\n                   insertExpressions [ LogEntry (val_ $ fromIntegral stepIx) (val_ stepName) currentTimestamp_ ]\n                 endStepHook hooks stepIx stepName\n\n                 return ret)\n    else pure Nothing\n\n-- | Attempt to find a SQL schema given an \'ActionProvider\' and a checked\n-- database. Returns \'Nothing\' if no schema could be found, which usually means\n-- you have chosen the wrong \'ActionProvider\', or the backend you\'re using is\n-- buggy.\nsimpleSchema :: Database be db\n             => ActionProvider be\n             -> CheckedDatabaseSettings be db\n             -> Maybe [BeamSqlBackendSyntax be]\nsimpleSchema provider settings =\n  let allChecks = collectChecks settings\n      solver    = heuristicSolver provider [] allChecks\n  in case finalSolution solver of\n       Solved cmds -> Just (fmap migrationCommand cmds)\n       Candidates {} -> Nothing\n\n-- | Given a \'CheckedDatabaseSettings\' and a \'BeamMigrationBackend\',\n-- attempt to create the schema from scratch in the current database.\n--\n-- May \'fail\' if we cannot find a schema\ncreateSchema :: (Database be db, Fail.MonadFail m)\n             => BeamMigrationBackend be m\n             -> CheckedDatabaseSettings be db\n             -> m ()\ncreateSchema BeamMigrationBackend { backendActionProvider = actions } db =\n  case simpleSchema actions db of\n    Nothing -> Fail.fail "createSchema: Could not determine schema"\n    Just cmds ->\n        mapM_ runNoReturn cmds\n\n-- | Given a \'BeamMigrationBackend\', attempt to automatically bring the current\n-- database up-to-date with the given \'CheckedDatabaseSettings\'. Fails (via\n-- \'fail\') if this involves an irreversible migration (one that may result in\n-- data loss).\nautoMigrate :: (Database be db, Fail.MonadFail m)\n            => BeamMigrationBackend be m\n            -> CheckedDatabaseSettings be db\n            -> m ()\nautoMigrate BeamMigrationBackend { backendActionProvider = actions\n                                 , backendGetDbConstraints = getCs }\n            db =\n  do actual <- getCs\n     let expected = collectChecks db\n     case finalSolution (heuristicSolver actions actual expected) of\n       Candidates {} -> Fail.fail "autoMigrate: Could not determine migration"\n       Solved cmds ->\n         -- Check if any of the commands are irreversible\n         case foldMap migrationCommandDataLossPossible cmds of\n           MigrationKeepsData -> mapM_ (runNoReturn . migrationCommand) cmds\n           _ -> Fail.fail "autoMigrate: Not performing automatic migration due to data loss"\n\n-- | Given a migration backend, a handle to a database, and a checked database,\n-- attempt to find a schema. This should always return \'Just\', unless the\n-- backend has incomplete migrations support.\n--\n-- \'BeamMigrationBackend\'s can usually be found in a module named\n-- @Database.Beam.<Backend>.Migrate@ with the name@migrationBackend@\nsimpleMigration :: ( MonadBeam be m\n                 ,   Database be db )\n                => (forall a. handle -> m a -> IO a)\n                -> BeamMigrationBackend be m\n                -> handle\n                -> CheckedDatabaseSettings be db\n                -> IO (Maybe [BeamSqlBackendSyntax be])\nsimpleMigration runner BeamMigrationBackend { backendGetDbConstraints = getCs\n                                            , backendActionProvider = action } hdl db = do\n  pre <- runner hdl getCs\n\n  let post = collectChecks db\n      solver = heuristicSolver action pre post\n\n  case finalSolution solver of\n    Solved cmds -> pure (Just (fmap migrationCommand cmds))\n    Candidates {} -> pure Nothing\n\n-- | Result type for \'verifySchema\'\ndata VerificationResult\n  = VerificationSucceeded\n  | VerificationFailed [SomeDatabasePredicate]\n  deriving Show\n\n-- | Verify that the given, beam database matches the actual\n-- schema. On success, returns \'VerificationSucceeded\', on failure,\n-- returns \'VerificationFailed\' and a list of missing predicates.\nverifySchema :: ( Database be db, MonadBeam be m )\n             => BeamMigrationBackend be m\n             -> CheckedDatabaseSettings be db\n             -> m VerificationResult\nverifySchema backend db = do\n  result <- checkSchema backend db ignoreAll\n  if HS.null $ missingPredicates result\n    then pure VerificationSucceeded\n    else pure $ VerificationFailed $ HS.toList $ missingPredicates result\n\n-- | Result type for \'checkSchema\'\ndata CheckResult = CheckResult\n  { -- | Expected predicates from the \'CheckedDatabaseSettings\' which were not\n    -- found in the live database\n    missingPredicates :: HS.HashSet SomeDatabasePredicate\n  , -- | Predicates found in the live database which are not present in the\n    -- \'CheckedDatabaseSettings\' and are not ignored\n    unexpectedPredicates :: HS.HashSet SomeDatabasePredicate\n  } deriving (Eq, Show)\n\n-- | Selects a class of predicates to ignore if detected (e.g. metadata tables\n-- for migrations, other schemas, etc.).\nnewtype IgnorePredicates = IgnorePredicates\n  { unIgnorePredicates :: SomeDatabasePredicate -> Any\n  } deriving (Semigroup, Monoid)\n\n-- | Ignore predicates relating to tables matching the given name predicate.\nignoreTables :: (QualifiedName -> Bool) -> IgnorePredicates\nignoreTables shouldIgnore = IgnorePredicates $ \\(SomeDatabasePredicate dp) ->\n  case cast dp of\n    Just (TableExistsPredicate name) -> Any $ shouldIgnore name\n    Nothing -> Any False\n\n-- | Ignore any unknown predicates. This probably only makes sense to use if\n-- you are only querying and not writing to the database.\nignoreAll :: IgnorePredicates\nignoreAll = IgnorePredicates $ const $ Any True\n\n-- | Checks the given database settings against the live database. This is\n-- similar to \'verifySchema\', but detects and returns unknown predicates that\n-- are true about the live database (e.g. unknown tables, fields, etc.).\ncheckSchema\n  :: (Database be db, Monad m)\n  => BeamMigrationBackend be m\n  -> CheckedDatabaseSettings be db\n  -> IgnorePredicates\n  -> m CheckResult\ncheckSchema backend db (IgnorePredicates ignore) = do\n  actual <- HS.fromList <$> backendGetDbConstraints backend\n  let expected = HS.fromList $ collectChecks db\n      missing = expected `HS.difference` actual\n      extra = actual `HS.difference` expected\n      ignored = HS.filter (getAny . ignore) extra\n      unexpected = flip HS.filter extra $ \\sdp@(SomeDatabasePredicate dp) ->\n        not $ or\n          [ sdp `HS.member` ignored\n          , or $ HS.toList ignored <&> \\(SomeDatabasePredicate ignoredDp) ->\n              dp `predicateCascadesDropOn` ignoredDp\n          ]\n\n  return $ CheckResult\n    { missingPredicates = missing\n    , unexpectedPredicates = unexpected\n    }\n\n-- | Run a sequence of commands on a database\nrunSimpleMigration :: MonadBeam be m\n                   => (forall a. hdl -> m a -> IO a)\n                   -> hdl -> [BeamSqlBackendSyntax be] -> IO ()\nrunSimpleMigration runner hdl =\n  runner hdl . mapM_ runNoReturn\n\n-- | Given a function to convert a command to a \'String\', produce a script that\n-- will execute the given migration. Usually, the function you provide\n-- eventually calls \'displaySyntax\' to rendere the command.\nbackendMigrationScript :: BeamSqlBackend be\n                       => (BeamSqlBackendSyntax be -> String)\n                       -> Migration be a\n                       -> String\nbackendMigrationScript render mig =\n  migrateScript ((++"\\n") . T.unpack) ((++"\\n") . render) (migrationStep "Migration Script" (\\() -> mig))\n\n-- | Given a \'BeamMigrationBackend\', get a string representing a Haskell module\n-- that would be a good starting point for further development.\n--\n-- For example, for a postgres database named @chinook@\n--\n-- > import Database.Beam.Migrate.Simple\n-- > import Database.Beam.Postgres (runBeamPostgres)\n-- > import Database.Beam.Postgres.Migrate (migrationBackend)\n-- > import Database.PostgreSQL.Simple\n-- >\n-- > getSchema :: IO String\n-- > getSchema = do pg <- connectPostgreSQL\n-- >                runBeamPostgres pg (haskellSchema migrationBackend)\n--\n-- Backends that have a migration backend typically export it under the module\n-- name @Database.Beam./Backend/.Migrate@.\nhaskellSchema :: (MonadBeam be m, Fail.MonadFail m)\n              => BeamMigrationBackend be m\n              -> m String\nhaskellSchema BeamMigrationBackend { backendGetDbConstraints = getCs\n                                   , backendConvertToHaskell = HaskellPredicateConverter conv2Hs } = do\n  constraints <- getCs\n  let hsConstraints = [ hsConstraint | c <- constraints, Just hsConstraint <- [ conv2Hs c ] ]\n\n      solver = heuristicSolver (defaultActionProvider @HsMigrateBackend) [] hsConstraints\n\n  case finalSolution solver of\n    Solved cmds   ->\n      let hsModule = hsActionsToModule "NewBeamSchema" (map migrationCommand cmds)\n      in case renderHsSchema hsModule of\n           Left err -> Fail.fail ("Error writing Haskell schema: " ++ err)\n           Right modStr -> pure modStr\n    Candidates {} -> Fail.fail "Could not form Haskell schema"\n'