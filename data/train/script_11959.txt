b'{-# LANGUAGE CPP #-}\n\n-- | Convenience methods for constructing backend-agnostic applications\nmodule Database.Beam.Backend.URI where\n\nimport           Control.Exception\n\nimport qualified Data.Map as M\n\nimport           Network.URI\n\ndata BeamResourceNotFound = BeamResourceNotFound deriving Show\ninstance Exception BeamResourceNotFound\n\ndata BeamOpenURIInvalid = BeamOpenURIInvalid deriving Show\ninstance Exception BeamOpenURIInvalid\n\ndata BeamOpenURIUnsupportedScheme = BeamOpenURIUnsupportedScheme String deriving Show\ninstance Exception BeamOpenURIUnsupportedScheme\n\ndata BeamURIOpener c where\n  BeamURIOpener :: c be hdl m\n                -> (forall a. hdl -> m a -> IO a)\n                -> (URI -> IO (hdl, IO ()))\n                -> BeamURIOpener c\nnewtype BeamURIOpeners c where\n  BeamURIOpeners :: M.Map String (BeamURIOpener c) -> BeamURIOpeners c\n\ninstance Semigroup (BeamURIOpeners c) where\n  BeamURIOpeners a <> BeamURIOpeners b =\n    BeamURIOpeners (a <> b)\n\ninstance Monoid (BeamURIOpeners c) where\n  mempty = BeamURIOpeners mempty\n  mappend = (<>)\n\ndata OpenedBeamConnection c where\n  OpenedBeamConnection\n    :: { beamRunner          :: (forall a. hdl -> m a -> IO a)\n       , openedBeamDatabase  :: c be hdl m\n       , openedBeamHandle    :: hdl\n       , closeBeamConnection :: IO ()\n     } -> OpenedBeamConnection c\n\nmkUriOpener :: (forall a. hdl -> m a -> IO a)\n            -> String\n            -> (URI -> IO (hdl, IO ()))\n            -> c be hdl m\n            -> BeamURIOpeners c\nmkUriOpener runner schemeNm opener c = BeamURIOpeners (M.singleton schemeNm (BeamURIOpener c runner opener))\n\nwithDbFromUri :: forall c a\n               . BeamURIOpeners c\n              -> String\n              -> (forall be hdl m. (forall r. hdl -> m r -> IO r) -> c be hdl m -> m a)\n              -> IO a\nwithDbFromUri protos uri actionWithDb =\n  withDbConnection protos uri (\\runner c hdl -> runner hdl (actionWithDb runner c))\n\nwithDbConnection :: forall c a\n                  . BeamURIOpeners c\n                 -> String\n                 -> (forall be hdl m. (forall r. hdl -> m r -> IO r) ->\n                      c be hdl m -> hdl -> IO a)\n                 -> IO a\nwithDbConnection protos uri actionWithDb =\n  bracket (openDbConnection protos uri) closeBeamConnection $\n  \\(OpenedBeamConnection runner c hdl _) -> actionWithDb runner c hdl\n\nopenDbConnection :: forall c\n                  . BeamURIOpeners c\n                 -> String\n                 -> IO (OpenedBeamConnection c)\nopenDbConnection protos uri = do\n  (parsedUri, BeamURIOpener c runner openURI) <- findURIOpener protos uri\n  (hdl, closeHdl) <- openURI parsedUri\n  pure (OpenedBeamConnection runner c hdl closeHdl)\n\nfindURIOpener :: BeamURIOpeners c -> String -> IO (URI, BeamURIOpener c)\nfindURIOpener (BeamURIOpeners protos) uri =\n  case parseURI uri of\n    Nothing -> throwIO BeamOpenURIInvalid\n    Just parsedUri ->\n      case M.lookup (uriScheme parsedUri) protos of\n        Nothing -> throwIO (BeamOpenURIUnsupportedScheme (uriScheme parsedUri))\n        Just opener -> pure (parsedUri, opener)\n'