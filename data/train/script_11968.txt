b'-- While Haskell syntax might look complicated, it is really a lot\n-- simpler than it looks at first glance. Excerpt from A History\n-- of Haskell:\n--\n-- | Haskell has 21 reserved keywords that cannot be used as names\n-- | for values or types. This is a relatively low number (Erlang\n-- | has 28, OCaml has 48, Java has 50, C++ has 63---and Miranda has\n-- | only 10)\n--\n-- This is an indication of the Haskell syntax really being fairly\n-- small. The reason the people think Haskell has complex syntax is\n-- that when they read other peoples Haskell programs, those people\n-- have defined (or used other peoples definitions of) many very,\n-- very clever functions which do amazing things with minimal code.\n--\n-- Defining such functions is not possible in all languages, so\n-- people coming from less powerful languages are used to functions\n-- doing pretty ordinary stuff, and leaving the amazing things to\n-- the built-in syntax. In Haskell, the amazing things often have\n-- nothing at all to do with the built-in syntax, and if you are\n-- clever enough, you can write those things yourself as a function.\n--\n-- Yes, these clever functions take time to master, but they are\n-- not vital parts of Haskell, and most of all -- they are not\n-- syntax! The syntax of Haskell is rather minimal and can be\n-- learnt quickly.\n-- \n-- This is meant as a sort of informal summary of the basic\n-- syntactic elements you need to get started with writing Haskell\n-- programs. Many (if not most) of the amazing things people do can\n-- be expressed with this minimal subset of Haskell syntax.\n--\n-- Because Lisp people are the ones commonly complaining about the\n-- complicated syntax of Haskell, this is somewhat aimed at Lisp\n-- people, but I think others might benefit from it too.\n--\n-- ~kqr, 2012-12-24\n--\n--\n--\n-- Expressions\n--\n-- There are two "kinds" of expressions: function calls and operator\n-- applications. Function calls are written with the function name\n-- followed by the arguments, separated by spaces.\n--\n-- arg1 and arg2 can of course be other expressions!\n--\n-- Function calls look like this, when wrapped with parentheses. Does\n-- it look familiar? Normally, not all expressions are written with\n-- parentheses, because there does exist some rules of precendence,\n-- but you can of course throw them out of the window and just go\n-- by parentheses!\n--\n-- Function evaluation:\n\n(functionName arg1 arg2 ...)\n\n-- Operators can only have two arguments, one on either side of\n-- the operator. Here, too, can arg1 and arg2 of course be\n-- expressions themselves.\n--\n-- Operators are really the same thing as functions, only with\n-- name consisting of symbols and written infix.\n--\n-- Operator application:\n\n(arg1 * arg2)\n\n\n-- Function definition\n--\n-- arg1 and arg2 are names of parameters that can be used in the\n-- function body, which in turn consists of a single expression.\n--\n-- arg1 and arg2 can, for the purpose of simplicity, *not* be\n-- expressions here, but have to be names of parameters.\n\nfunctionName arg1 arg2 ... = expression\n\n\n-- Variable assignment\n--\n-- var1 and var2 are variables that will evaluate to the value\n-- of their respective expressions. Only a single expression per\n-- variable is allowed, which makes sense. The whole assignment\n-- block (from let to expression) is considered a single expression\n-- itself.\n\n(let var1 = expression1\n     var2 = expression2\n     ...\n in  expression)\n\n\n-- If expressions\n--\n-- The whole if expression is considered a single expression.\n-- condition is an expression evaluating to either True or\n-- False. If condition is True, the if expression will\n-- evaluate to the same thing as expression1, otherwise\n-- to the same thing as expression2.\n--\n-- Once again, these parentheses are not always required, but\n-- neither are they prohibited.\n\n(if condition\n    then expression1\n    else expression2)\n\n\n-- Common operators\n--\n-- Multiplication\n(3 * 4)\n\n-- Addition\n(2 + 3)\n\n-- Subtraction\n(9 - 5)\n\n-- Create a list from a first element and a tail (create a cons cell, to the lispers)\n-- (This example will evaluate to [3, 4, 5, 6])\n(3 : [4, 5, 6])\n\n-- Equality check\n(3 == 3)\n\n-- Inequality check\n(3 /= 4)\n\n-- Larger than/less than/larger than or equal to/less than or equal to:\n(4 > 3)\n(6 < 7)\n(5 >= 5)\n(6 <= 12)\n\n\n-- Common functions\n--\n-- Checks if a list is empty\n-- (Note: This is accomplishes the same thing as\n-- (list == []) but looks more lispy.)\n(null list)\n\n-- Returns the first element of a list\n(first list)\n\n-- Returns the rest of a list\n(tail list)\n\n-- Returns the length of a list\n(length list)\n\n\n-- Common conversions between types\n--\n-- Integer to float\n(fromIntegral 4)\n\n-- Float to integer\n(floor 3.75)\n\n-- Integer to char (This requires importing Data.Char)\n(chr 43)\n\n-- Char to integer (This requires importing Data.Char)\n(ord \'z\')'