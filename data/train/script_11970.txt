b'{-# LANGUAGE OverloadedStrings #-}\n\n-- An example how to merge PDF files into one big file.\n--\n-- Usage:\n--      ./merge-pdf-files in1.pdf in2.pdf ... > out.pdf\n--\n-- TODO: Encrypted files are not supported\n-- TODO: Annotations, media box\n-- TODO: Inherited resources\n-- TODO: Resources (fonts, etc) are written a number of times, check for dublicates\n\nmodule Main\n(\n  main,\n)\nwhere\n\nimport Pdf.Core.Object\nimport Pdf.Core.Writer\nimport Pdf.Document\nimport Pdf.Document.Internal.Types\n\nimport Data.IORef\nimport qualified Data.ByteString.Lazy as Lazy.ByteString\nimport qualified Data.Vector as Vector\nimport qualified Data.HashMap.Strict as HashMap\nimport Control.Monad\nimport qualified System.IO.Streams as Streams\nimport System.Environment\n\ndata AppState = AppState {\n  stNextFree :: Int,\n  stPageRefs :: [Ref],\n  stRootNode :: Ref\n  }\n\ninitialAppState :: AppState\ninitialAppState = AppState {\n  stNextFree = 1,\n  stPageRefs = [],\n  stRootNode = error "stRootNode"\n  }\n\nnextFreeIndex :: IORef AppState -> IO Int\nnextFreeIndex stateRef = do\n  st <- readIORef stateRef\n  let index = stNextFree st\n  writeIORef stateRef $ st {stNextFree = index + 1}\n  return index\n\nputPageRef :: IORef AppState -> Ref -> IO ()\nputPageRef stateRef ref =\n  modifyIORef stateRef $ \\st -> st {stPageRefs = ref : stPageRefs st}\n\nmain :: IO ()\nmain = do\n  files <- getArgs\n  writer <- makeWriter Streams.stdout\n  writeHeader writer\n  deleteObject writer (R 0 65535) 0\n  stateRef <- newIORef initialAppState\n  index <- nextFreeIndex stateRef\n  modifyIORef stateRef $ \\st -> st {stRootNode = R index 0}\n  forM_ files $\n    writePdfFile writer stateRef\n  writeTrailer writer stateRef\n\nwritePdfFile :: Writer -> IORef AppState -> FilePath -> IO ()\nwritePdfFile writer stateRef path = withPdfFile path $ \\pdf -> do\n  encrypted <- isEncrypted pdf\n  when encrypted $ do\n    ok <- setUserPassword pdf defaultUserPassword\n    unless ok $\n      error "Wrong password"\n\n  root <- document pdf >>= documentCatalog >>= catalogPageNode\n  count <- pageNodeNKids root\n  forM_ [0..count-1] $ \\i -> do\n    page <- pageNodePageByNum root i\n    writePdfPage writer stateRef page\n\n  {-\n  handle <- openBinaryFile path ReadMode\n\n  pdf <- do\n    pdf <- pdfWithHandle handle\n\n    encrypted <- isEncrypted pdf\n    when encrypted $ do\n      ok <- setUserPassword pdf defaultUserPassword\n      unless ok $\n        error "Wrong password"\n    return pdf\n\n  root <- document pdf >>= documentCatalog >>= catalogPageNode\n  count <- pageNodeNKids root\n  forM_ [0..count-1] $ \\i -> do\n    page <- pageNodePageByNum root i\n    writePdfPage writer stateRef page\n\n  hClose handle\n  -}\n\nwritePdfPage :: Writer -> IORef AppState -> Page -> IO ()\nwritePdfPage writer stateRef page@(Page pdf _ pageDict) = do\n  parentRef <- stRootNode <$> readIORef stateRef\n  pageIndex <- nextFreeIndex stateRef\n  let pageRef = R pageIndex 0\n  putPageRef stateRef pageRef\n  contentRefs <- pageContents page\n  contentRefs\' <- forM contentRefs $ \\r -> do\n    o <- lookupObject pdf r\n    case o of\n      Stream s -> writeStream\' writer stateRef pdf r s\n      _ -> error "stream expected"\n\n  resources <- do\n    case HashMap.lookup "Resources" pageDict of\n      Nothing -> error "No resources"\n      Just v -> do\n        o <- deref pdf v\n        writeObjectChildren writer stateRef pdf o\n  writeObject writer pageRef $ Dict $ HashMap.fromList [\n    ("Type", Name "Page"),\n    ("Contents", Array $ Vector.fromList $ map Ref contentRefs\'),\n    ("Resources", resources),\n    ("Parent", Ref parentRef)\n    ]\n\nwriteTrailer :: Writer -> IORef AppState -> IO ()\nwriteTrailer writer stateRef = do\n  pageRefs <- stPageRefs <$> readIORef stateRef\n\n  rootRef <- stRootNode <$> readIORef stateRef\n  writeObject writer rootRef $ Dict $ HashMap.fromList [\n    ("Type", Name "Pages"),\n    ("Count", Number $ fromIntegral $ length pageRefs),\n    ("Kids", Array $ Vector.fromList $ map Ref $ reverse pageRefs)\n    ]\n\n  catalogIndex <- nextFreeIndex stateRef\n  let catalogRef = R catalogIndex 0\n  writeObject writer catalogRef $ Dict $ HashMap.fromList\n    [ ("Type", Name "Catalog")\n    , ("Pages", Ref rootRef)\n    ]\n\n  count <- stNextFree <$> readIORef stateRef\n  writeXRefTable writer 0 (HashMap.fromList\n    [ ("Size", Number $ fromIntegral $ count - 1)\n    , ("Root", Ref catalogRef)\n    ])\n\nwriteStream\' :: Writer -> IORef AppState -> Pdf -> Ref -> Stream -> IO Ref\nwriteStream\' writer stateRef pdf ref s@(S dict _) = do\n  cont <- do\n    is <- rawStreamContent pdf ref s\n    Lazy.ByteString.fromChunks <$> Streams.toList is\n\n  Dict dict\' <- writeObjectChildren writer stateRef pdf (Dict dict)\n\n  index <- nextFreeIndex stateRef\n  let r = R index 0\n  writeStream writer r dict\' cont\n  return r\n\nwriteObjectChildren :: Writer -> IORef AppState -> Pdf -> Object -> IO Object\nwriteObjectChildren writer stateRef pdf (Ref r) = do\n  o <- lookupObject pdf r\n  case o of\n    Stream s -> do\n      ref <- writeStream\' writer stateRef pdf r s\n      return $ Ref ref\n    _ -> do\n      o\' <- writeObjectChildren writer stateRef pdf o\n      index <- nextFreeIndex stateRef\n      let ref = R index 0\n      writeObject writer ref o\'\n      return $ Ref ref\nwriteObjectChildren writer stateRef pdf (Dict vals) = do\n  vals\' <- forM (HashMap.toList vals) $ \\(key, val) -> do\n    val\' <- writeObjectChildren writer stateRef pdf val\n    return (key, val\')\n  return $ Dict $ HashMap.fromList vals\'\nwriteObjectChildren writer stateRef pdf (Array vals) = do\n  vals\' <- Vector.forM vals (writeObjectChildren writer stateRef pdf)\n  return $ Array vals\'\nwriteObjectChildren _ _ _ o = return o\n'