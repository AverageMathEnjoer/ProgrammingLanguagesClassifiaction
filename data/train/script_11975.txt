b'{-# LANGUAGE LambdaCase #-}\n{-# LANGUAGE OverloadedStrings #-}\n\nmodule Hoodle.Coroutine.Select.ManipulateImage where\n\nimport Control.Lens (set, view, (.~), _2)\nimport Control.Monad (when)\nimport Control.Monad.State (get)\nimport Control.Monad.Trans (liftIO)\nimport Data.ByteString.Base64 (encode)\nimport Data.Foldable (forM_)\nimport Data.Hoodle.BBox\n  ( BBox (..),\n    BBoxed (..),\n    getBBox,\n  )\nimport Data.Hoodle.Simple\n  ( Dimension (..),\n    Image (..),\n    Item (..),\n  )\nimport Data.Time (UTCTime, getCurrentTime)\nimport qualified Graphics.GD.ByteString as G\nimport Graphics.Hoodle.Render.Item (cnstrctRItem, getByteStringIfEmbeddedPNG)\nimport Graphics.Hoodle.Render.Util.HitTest (isBBox2InBBox1)\nimport qualified Graphics.Rendering.Cairo as Cairo\nimport Hoodle.Accessor\n  ( getCurrentPageEitherFromHoodleModeState,\n    getGeometry4CurrCvs,\n  )\nimport Hoodle.Coroutine.Commit (commit)\nimport Hoodle.Coroutine.Draw\n  ( callRenderer,\n    invalidateAllInBBox,\n    invalidateTemp,\n    nextevent,\n    waitSomeEvent,\n  )\nimport Hoodle.Coroutine.Pen (createTempRender, penMoveAndUpOnly)\nimport Hoodle.Coroutine.Select.Clipboard (updateTempHoodleSelectM)\nimport Hoodle.Device (PointerCoord)\nimport Hoodle.ModelAction.Page (updatePageAll)\nimport Hoodle.ModelAction.Pen (TempRender (..))\nimport Hoodle.ModelAction.Select (getNewCoordTime)\nimport Hoodle.ModelAction.Select.Transform (replaceSelection)\nimport qualified Hoodle.Type.Alias as A\nimport Hoodle.Type.Canvas\n  ( CanvasId,\n    currentPageNum,\n    forBoth\',\n    unboxBiAct,\n  )\nimport Hoodle.Type.Coroutine (MainCoroutine)\nimport Hoodle.Type.Enum\n  ( DrawFlag (Efficient),\n    RotateDir (CCW, CW),\n  )\nimport Hoodle.Type.Event\n  ( RenderEvent (..),\n    UserEvent (..),\n  )\nimport Hoodle.Type.HoodleState\n  ( HoodleModeState (SelectState, ViewAppendState),\n    currentCanvas,\n    currentUnit,\n    getCurrentCanvasId,\n    hoodleModeState,\n    unitHoodles,\n  )\nimport Hoodle.Type.PageArrangement\n  ( PageCoordinate (..),\n    PageNum (..),\n  )\nimport Hoodle.View.Coordinate\n  ( CanvasGeometry,\n    desktop2Page,\n    device2Desktop,\n  )\nimport Hoodle.View.Draw (renderBoxSelection)\n\ncropImage :: BBoxed Image -> MainCoroutine ()\ncropImage imgbbx = do\n  xst <- get\n  let uhdl = view (unitHoodles . currentUnit) xst\n      (cid, cinfobox) = view currentCanvas uhdl\n      hdlmodst = view hoodleModeState uhdl\n      epage = forBoth\' unboxBiAct (`getCurrentPageEitherFromHoodleModeState` hdlmodst) cinfobox\n  case hdlmodst of\n    ViewAppendState _ -> return ()\n    SelectState thdl -> do\n      case epage of\n        Left _ -> return ()\n        Right tpage -> initCropImage cid (thdl, tpage)\n  where\n    initCropImage cid (thdl, tpage) = do\n      r <- waitSomeEvent (\\case PenDown {} -> True; _ -> False)\n      case r of\n        PenDown cid\' _pbtn pcoord ->\n          when (cid == cid\') $\n            startCropRect cid imgbbx (thdl, tpage) pcoord\n        _ -> return ()\n\nstartCropRect ::\n  CanvasId ->\n  BBoxed Image ->\n  (A.Hoodle A.SelectMode, A.Page A.SelectMode) ->\n  PointerCoord ->\n  MainCoroutine ()\nstartCropRect cid imgbbx (thdl, tpage) pcoord0 = do\n  xst <- get\n  let uhdl = view (unitHoodles . currentUnit) xst\n  geometry <- liftIO $ getGeometry4CurrCvs uhdl\n  forM_ ((desktop2Page geometry . device2Desktop geometry) pcoord0) $ \\(p0, c0) -> do\n    tsel <- createTempRender geometry (p0, BBox (unPageCoord c0) (unPageCoord c0))\n    ctime <- liftIO getCurrentTime\n    nbbox <- newCropRect cid geometry tsel (unPageCoord c0) (unPageCoord c0, ctime)\n    Cairo.surfaceFinish (tempSurfaceSrc tsel)\n    Cairo.surfaceFinish (tempSurfaceTgt tsel)\n    let pnum = (fst . tempInfo) tsel\n        img = bbxed_content imgbbx\n        obbox = getBBox imgbbx\n        cvsid = getCurrentCanvasId uhdl\n    when (isBBox2InBBox1 obbox nbbox) $ do\n      mimg\' <- liftIO $ createCroppedImage img obbox nbbox\n      forM_ mimg\' $ \\img\' -> do\n        --\n        callRenderer $\n          GotRItem <$> cnstrctRItem (ItemImage img\')\n        RenderEv (GotRItem rimg\') <-\n          waitSomeEvent (\\case RenderEv (GotRItem _) -> True; _ -> False)\n        --\n        let ntpage = replaceSelection rimg\' tpage\n        nthdl <- updateTempHoodleSelectM cvsid thdl ntpage (unPageNum pnum)\n        uhdl\' <- liftIO (updatePageAll (SelectState nthdl) uhdl)\n        commit $ (unitHoodles . currentUnit .~ uhdl\') xst\n    invalidateAllInBBox Nothing Efficient\n    return ()\n\n-- | start making a new crop rectangle\nnewCropRect ::\n  CanvasId ->\n  CanvasGeometry ->\n  TempRender (PageNum, BBox) ->\n  (Double, Double) ->\n  ((Double, Double), UTCTime) ->\n  MainCoroutine BBox\nnewCropRect cid geometry tsel orig (prev, otime) = do\n  let pnum = (fst . tempInfo) tsel\n  r <- nextevent\n  penMoveAndUpOnly r pnum geometry defact moveact upact\n  where\n    defact = newCropRect cid geometry tsel orig (prev, otime)\n    --\n    moveact (_pcoord, (x, y)) = do\n      (willUpdate, (ncoord, ntime)) <- liftIO $ getNewCoordTime (prev, otime) (x, y)\n      if willUpdate\n        then do\n          let oinfo@(_, BBox xy0 _) = tempInfo tsel\n              nbbox = BBox xy0 (x, y)\n              ninfo = set _2 nbbox oinfo\n          invalidateTemp cid (tempSurfaceSrc tsel) (renderBoxSelection nbbox)\n          newCropRect cid geometry tsel {tempInfo = ninfo} orig (ncoord, ntime)\n        else defact\n    --\n    upact _pcoord = (return . snd . tempInfo) tsel\n\ncreateCroppedImage :: Image -> BBox -> BBox -> IO (Maybe Image)\ncreateCroppedImage img (BBox (xo0, yo0) (xo1, yo1)) (BBox (xn0, yn0) (xn1, yn1)) = do\n  let src = img_src img\n      embed = getByteStringIfEmbeddedPNG src\n  case embed of\n    Nothing -> return Nothing\n    Just bstr -> do\n      gdimg <- G.loadPngByteString bstr\n      (w, h) <- G.imageSize gdimg\n      let w\' = floor $ fromIntegral w * (xn1 - xn0) / (xo1 - xo0)\n          h\' = floor $ fromIntegral h * (yn1 - yn0) / (yo1 - yo0)\n          x1 = floor $ fromIntegral w * (xn0 - xo0) / (xo1 - xo0)\n          y1 = floor $ fromIntegral h * (yn0 - yo0) / (yo1 - yo0)\n      ngdimg <- G.newImage (w\', h\')\n      G.copyRegion (x1, y1) (w\', h\') gdimg (0, 0) ngdimg\n      nbstr <- G.savePngByteString ngdimg\n      let nb64str = encode nbstr\n          nebdsrc = "data:image/png;base64," <> nb64str\n      return . Just $ Image nebdsrc (xn0, yn0) (Dim (xn1 - xn0) (yn1 - yn0))\n\nrotateImage :: RotateDir -> BBoxed Image -> MainCoroutine ()\nrotateImage dir imgbbx = do\n  xst <- get\n  let uhdl = view (unitHoodles . currentUnit) xst\n  let (cid, cinfobox) = view currentCanvas uhdl\n      hdlmodst = view hoodleModeState uhdl\n      pnum = (PageNum . forBoth\' unboxBiAct (view currentPageNum)) cinfobox\n      epage = forBoth\' unboxBiAct (`getCurrentPageEitherFromHoodleModeState` hdlmodst) cinfobox\n  case hdlmodst of\n    ViewAppendState _ -> return ()\n    SelectState thdl -> do\n      case epage of\n        Left _ -> return ()\n        Right tpage -> do\n          let img = bbxed_content imgbbx\n          mimg\' <- liftIO (createRotatedImage dir img (getBBox imgbbx))\n          forM_ mimg\' $ \\img\' -> do\n            callRenderer $\n              GotRItem <$> cnstrctRItem (ItemImage img\')\n            RenderEv (GotRItem rimg\') <-\n              waitSomeEvent (\\case RenderEv (GotRItem _) -> True; _ -> False)\n            let ntpage = replaceSelection rimg\' tpage\n            nthdl <- updateTempHoodleSelectM cid thdl ntpage (unPageNum pnum)\n            uhdl\' <- liftIO (updatePageAll (SelectState nthdl) uhdl)\n            commit $ (unitHoodles . currentUnit .~ uhdl\') xst\n          invalidateAllInBBox Nothing Efficient\n          return ()\n\ncreateRotatedImage :: RotateDir -> Image -> BBox -> IO (Maybe Image)\ncreateRotatedImage dir img (BBox (x0, y0) (x1, y1)) = do\n  let src = img_src img\n      embed = getByteStringIfEmbeddedPNG src\n  case embed of\n    Nothing -> return Nothing\n    Just bstr -> do\n      gdimg <- G.loadPngByteString bstr\n      ngdimg <- G.rotateImage (case dir of CW -> 3; CCW -> 1) gdimg\n      nbstr <- G.savePngByteString ngdimg\n      let nb64str = encode nbstr\n          nebdsrc = "data:image/png;base64," <> nb64str\n      return . Just $ Image nebdsrc (x0, y0) (Dim (y1 - y0) (x1 - x0))\n'