b'// Copyright (c) 2022-2023 Manuel Schneider\n\n#include "albert/extensions/pluginprovider.h"\n#include "albert/logging.h"\n#include "albert/util/standarditem.h"\n#include "pluginregistry.h"\n#include <QCoreApplication>\n#include <QSettings>\n#include <chrono>\nusing namespace std;\nusing namespace albert;\nusing chrono::duration_cast;\nusing chrono::milliseconds;\nusing chrono::system_clock;\n\nPluginRegistry::PluginRegistry(ExtensionRegistry &er) : ExtensionWatcher<PluginProvider>(er)\n{\n}\n\nvector<const PluginLoader*> PluginRegistry::plugins() const\n{\n    vector<const PluginLoader*> plugins;\n    for (const auto &[id, loader] : plugins_)\n        plugins.emplace_back(loader);\n    return plugins;\n}\n\nbool PluginRegistry::isEnabled(const QString &id) const\n{\n    return QSettings(qApp->applicationName()).value(QString("%1/enabled").arg(id), false).toBool();\n}\n\nvoid PluginRegistry::enable(const QString &id, bool enable)\n{\n    if (plugins_.contains(id)){\n        if (isEnabled(id) != enable){\n            QSettings(qApp->applicationName()).setValue(QString("%1/enabled").arg(id), enable);\n            load(id, enable);\n        }\n    } else\n        WARN << "En-/Disabled nonexistent id:" << id;\n}\n\nvoid PluginRegistry::load(const QString &id, bool load)\n{\n    try {\n        auto *loader = plugins_.at(id);\n        switch (loader->state()) {\n        case PluginState::Invalid:\n            WARN << "Tried to" << (load ? "load" : "unload") << "invalid plugin" << id;\n            break;\n        case PluginState::Loaded:\n            if (!load) {\n                DEBG << "Unloading plugin" << loader->metaData().id;\n                auto start = system_clock::now();\n                loader->unload();\n                auto duration = duration_cast<milliseconds>(system_clock::now()-start).count();\n                if (loader->state() == PluginState::Unloaded){\n                    DEBG << QString("[%1ms] Successfully unloaded \'%2\'")\n                                .arg(duration).arg(loader->metaData().id);\n                    emit pluginStateChanged(id);\n                } else\n                    WARN << QString("[%1ms] Failed unloading \'%2\': %3")\n                                .arg(duration).arg(loader->metaData().id, loader->stateInfo());\n            } else\n                WARN << "Plugin is already loaded:" << id ;\n            break;\n        case PluginState::Unloaded:\n            if (load){\n                INFO << "Loading plugin" << loader->metaData().id;\n                auto start = system_clock::now();\n                loader->load();\n                auto duration = duration_cast<milliseconds>(system_clock::now()-start).count();\n                if (loader->state() == PluginState::Loaded){\n                    DEBG << QString("[%1ms] Successfully loaded \'%2\'")\n                                .arg(duration).arg(loader->metaData().id);\n                    emit pluginStateChanged(id);\n                } else\n                    WARN << QString("[%1ms] Failed loading \'%2\': %3")\n                                .arg(duration).arg(loader->metaData().id, loader->stateInfo());\n            } else\n                WARN << "Plugin is already unloaded:" << id ;\n            break;\n        }\n    } catch (const exception &e) {\n        WARN << QString("Error while (un-)loading plugin \'%1\': %2").arg(id, e.what());\n    }\n}\n\nQString PluginRegistry::id() const { return "pluginregistry"; }\n\nQString PluginRegistry::name() const { return "Plugins"; }\n\nQString PluginRegistry::description() const { return "Manage plugins"; }\n\nQString PluginRegistry::defaultTrigger() const { return QStringLiteral("plug "); }\n\nvoid PluginRegistry::onAdd(PluginProvider *pp)\n{\n    for (auto *loader : pp->plugins()){\n        if (loader->state() == PluginState::Invalid)\n            continue;\n        const auto &id = loader->metaData().id;\n        if (const auto &[it, success] = plugins_.emplace(id, loader); success){\n            if (loader->metaData().user && isEnabled(id))\n                load(id);\n        } else\n            INFO << "Plugin" << id << "shadowed:" << loader->path;\n    }\n    emit pluginsChanged();\n}\n\nvoid PluginRegistry::onRem(PluginProvider *pp)\n{\n    for (auto it = plugins_.begin(); it != plugins_.end();){\n        const auto &[id, loader] = *it;\n        if (loader->provider() == pp){\n            if (loader->state() == PluginState::Loaded)\n                loader->unload();\n            it = plugins_.erase(it);\n        } else ++it;\n    }\n    emit pluginsChanged();\n}\n\nvoid PluginRegistry::handleTriggerQuery(TriggerQuery &query) const\n{\n    for (const auto &[id, loader] : plugins_){  // these should all be valid\n\n        if (!id.startsWith(query.string(), Qt::CaseInsensitive))\n            continue;\n\n        Actions actions;\n        QString info;\n\n        auto mutable_this = const_cast<PluginRegistry*>(this);\n\n        if (loader->metaData().user){\n            if (isEnabled(id))\n                actions.emplace_back(\n                    "disable", "Disable plugin",\n                    [mutable_this, id=id]() { mutable_this->enable(id, false); }\n                );\n            else\n                actions.emplace_back(\n                    "enable", "Enable plugin",\n                    [mutable_this, id=id](){ mutable_this->enable(id); }\n                    );\n\n            if (loader->state() == PluginState::Loaded){\n                actions.emplace_back(\n                    "unload", "Unload plugin",\n                    [mutable_this, id=id](){ mutable_this->load(id, false); }\n                );\n                actions.emplace_back(\n                    "reload", "Reload plugin",\n                    [mutable_this, id=id](){ mutable_this->load(id, false); mutable_this->load(id, true); }\n                );\n            }\n            else  // by contract only unloaded\n                actions.emplace_back(\n                    "load", "Load plugin",\n                    [mutable_this, id=id](){ mutable_this->load(id); }\n                );\n\n            QString enabled = isEnabled(id) ? "Enabled" : "Disabled";\n            QString state;\n            if (loader->state() == PluginState::Loaded)\n                state = "Loaded";\n            else if (loader->stateInfo().isEmpty())\n                state = "Unloaded";\n            else\n                state = QString("Error: %1").arg(loader->stateInfo());\n            info = QString("[%1, %2] ").arg(enabled, state);\n        }\n        info.append(loader->metaData().description);\n\n        query.add(\n            StandardItem::make(\n                id,\n                loader->metaData().name,\n                info,\n                {":app_icon"},\n                actions\n            )\n        );\n    }\n\n}\n\n'