b"{-# LANGUAGE\n    CPP\n  , NoImplicitPrelude\n  , RankNTypes\n  #-}\n#if MIN_VERSION_base(4,9,0)\n{-# OPTIONS_GHC -Wno-redundant-constraints #-}\n#endif\nmodule Rest.Run\n  ( apiToHandler\n  , apiToHandler'\n  , apiToHandlerWith\n  , Config (..)\n  ) where\n\nimport Prelude.Compat\n\nimport qualified Data.ByteString.Lazy.UTF8 as UTF8\n\nimport Rest.Api (Api)\nimport Rest.Dictionary (Dicts (..))\nimport Rest.Driver.Perform\nimport Rest.Driver.Types\nimport qualified Rest.Driver.Routing.Internal as I\n\napiToHandler :: (Applicative m, Monad m) => Rest m => Api m -> m UTF8.ByteString\napiToHandler = apiToHandler' id\n\napiToHandler' :: (Applicative m, Monad m) => Rest n => Run m n -> Api m -> n UTF8.ByteString\napiToHandler' = apiToHandlerWith I.defaultConfig\n\napiToHandlerWith :: Config m -> Rest n => Run m n -> Api m -> n UTF8.ByteString\napiToHandlerWith cfg run api = do\n  method <- getMethod\n  paths  <- getPaths\n  case I.routeWith cfg method paths api of\n    Left  e -> failureWriter None e\n    Right h -> writeResponse (mapHandler run h)\n"