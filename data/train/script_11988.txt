b'using System;\nusing System.Diagnostics;\nusing System.Text;\n\nusing Bitmask = System.UInt64;\nusing u8 = System.Byte;\nusing u16 = System.UInt16;\nusing u32 = System.UInt32;\n\nnamespace CS_SQLite3\n{\n  public partial class CSSQLite\n  {\n    /*\n    ** 2001 September 15\n    **\n    ** The author disclaims copyright to this source code.  In place of\n    ** a legal notice, here is a blessing:\n    **\n    **    May you do good and not evil.\n    **    May you find forgiveness for yourself and forgive others.\n    **    May you share freely, never taking more than you give.\n    **\n    *************************************************************************\n    ** This module contains C code that generates VDBE code used to process\n    ** the WHERE clause of SQL statements.  This module is responsible for\n    ** generating the code that loops through a table looking for applicable\n    ** rows.  Indices are selected and used to speed the search when doing\n    ** so is applicable.  Because this module is responsible for selecting\n    ** indices, you might also think of this module as the "query optimizer".\n    **\n    ** $Id: where.c,v 1.411 2009/07/31 06:14:52 danielk1977 Exp $\n    **\n    *************************************************************************\n    *************************************************************************\n    **  Included in SQLite3 port to C#-SQLite;  2008 Noah B Hart\n    **  C#-SQLite is an independent reimplementation of the SQLite software library\n    **\n    **  $Header$\n    *************************************************************************\n    *************************************************************************\n    */\n    //#include "sqliteInt.h"\n\n    /*\n    ** Trace output macros\n    */\n#if  (SQLITE_TEST) && (SQLITE_DEBUG)\n    static bool sqlite3WhereTrace = false;\n#endif\n#if  (SQLITE_TEST) && (SQLITE_DEBUG) && TRACE\n    //# define WHERETRACE(X)  if(sqlite3WhereTrace) sqlite3DebugPrintf X\n    static void WHERETRACE( string X, params object[] ap ) { if ( sqlite3WhereTrace ) sqlite3DebugPrintf( X, ap ); }\n#else\n//# define WHERETRACE(X)\nstatic void WHERETRACE( string X, params object[] ap ) { }\n#endif\n\n    /* Forward reference\n*/\n    //typedef struct WhereClause WhereClause;\n    //typedef struct WhereMaskSet WhereMaskSet;\n    //typedef struct WhereOrInfo WhereOrInfo;\n    //typedef struct WhereAndInfo WhereAndInfo;\n    //typedef struct WhereCost WhereCost;\n\n    /*\n    ** The query generator uses an array of instances of this structure to\n    ** help it analyze the subexpressions of the WHERE clause.  Each WHERE\n    ** clause subexpression is separated from the others by AND operators,\n    ** usually, or sometimes subexpressions separated by OR.\n    **\n    ** All WhereTerms are collected into a single WhereClause structure.\n    ** The following identity holds:\n    **\n    **        WhereTerm.pWC.a[WhereTerm.idx] == WhereTerm\n    **\n    ** When a term is of the form:\n    **\n    **              X <op> <expr>\n    **\n    ** where X is a column name and <op> is one of certain operators,\n    ** then WhereTerm.leftCursor and WhereTerm.u.leftColumn record the\n    ** cursor number and column number for X.  WhereTerm.eOperator records\n    ** the <op> using a bitmask encoding defined by WO_xxx below.  The\n    ** use of a bitmask encoding for the operator allows us to search\n    ** quickly for terms that match any of several different operators.\n    **\n    ** A WhereTerm might also be two or more subterms connected by OR:\n    **\n    **         (t1.X <op> <expr>) OR (t1.Y <op> <expr>) OR ....\n    **\n    ** In this second case, wtFlag as the TERM_ORINFO set and eOperator==WO_OR\n    ** and the WhereTerm.u.pOrInfo field points to auxiliary information that\n    ** is collected about the\n    **\n    ** If a term in the WHERE clause does not match either of the two previous\n    ** categories, then eOperator==0.  The WhereTerm.pExpr field is still set\n    ** to the original subexpression content and wtFlags is set up appropriately\n    ** but no other fields in the WhereTerm object are meaningful.\n    **\n    ** When eOperator!=0, prereqRight and prereqAll record sets of cursor numbers,\n    ** but they do so indirectly.  A single WhereMaskSet structure translates\n    ** cursor number into bits and the translated bit is stored in the prereq\n    ** fields.  The translation is used in order to maximize the number of\n    ** bits that will fit in a Bitmask.  The VDBE cursor numbers might be\n    ** spread out over the non-negative integers.  For example, the cursor\n    ** numbers might be 3, 8, 9, 10, 20, 23, 41, and 45.  The WhereMaskSet\n    ** translates these sparse cursor numbers into consecutive integers\n    ** beginning with 0 in order to make the best possible use of the available\n    ** bits in the Bitmask.  So, in the example above, the cursor numbers\n    ** would be mapped into integers 0 through 7.\n    **\n    ** The number of terms in a join is limited by the number of bits\n    ** in prereqRight and prereqAll.  The default is 64 bits, hence SQLite\n    ** is only able to process joins with 64 or fewer tables.\n    */\n    //typedef struct WhereTerm WhereTerm;\n    public class WhereTerm\n    {\n      public Expr pExpr;              /* Pointer to the subexpression that is this term */\n      public int iParent;             /* Disable pWC.a[iParent] when this term disabled */\n      public int leftCursor;          /* Cursor number of X in "X <op> <expr>" */\n      public class _u\n      {\n        public int leftColumn;        /* Column number of X in "X <op> <expr>" */\n        public WhereOrInfo pOrInfo;   /* Extra information if eOperator==WO_OR */\n        public WhereAndInfo pAndInfo; /* Extra information if eOperator==WO_AND */\n      }\n      public _u u = new _u();\n      public u16 eOperator;          /* A WO_xx value describing <op> */\n      public u8 wtFlags;             /* TERM_xxx bit flags.  See below */\n      public u8 nChild;              /* Number of children that must disable us */\n      public WhereClause pWC;        /* The clause this term is part of */\n      public Bitmask prereqRight;    /* Bitmask of tables used by pExpr.pRight */\n      public Bitmask prereqAll;      /* Bitmask of tables referenced by pExpr */\n    };\n\n    /*\n    ** Allowed values of WhereTerm.wtFlags\n    */\n    //#define TERM_DYNAMIC    0x01   /* Need to call sqlite3ExprDelete(db, ref pExpr) */\n    //#define TERM_VIRTUAL    0x02   /* Added by the optimizer.  Do not code */\n    //#define TERM_CODED      0x04   /* This term is already coded */\n    //#define TERM_COPIED     0x08   /* Has a child */\n    //#define TERM_ORINFO     0x10   /* Need to free the WhereTerm.u.pOrInfo object */\n    //#define TERM_ANDINFO    0x20   /* Need to free the WhereTerm.u.pAndInfo obj */\n    //#define TERM_OR_OK      0x40   /* Used during OR-clause processing */\n    const int TERM_DYNAMIC = 0x01; /* Need to call sqlite3ExprDelete(db, ref pExpr) */\n    const int TERM_VIRTUAL = 0x02; /* Added by the optimizer.  Do not code */\n    const int TERM_CODED = 0x04; /* This term is already coded */\n    const int TERM_COPIED = 0x08; /* Has a child */\n    const int TERM_ORINFO = 0x10; /* Need to free the WhereTerm.u.pOrInfo object */\n    const int TERM_ANDINFO = 0x20; /* Need to free the WhereTerm.u.pAndInfo obj */\n    const int TERM_OR_OK = 0x40; /* Used during OR-clause processing */\n    /*\n    ** An instance of the following structure holds all information about a\n    ** WHERE clause.  Mostly this is a container for one or more WhereTerms.\n    */\n    public class WhereClause\n    {\n      public Parse pParse;                              /* The parser context */\n      public WhereMaskSet pMaskSet;                     /* Mapping of table cursor numbers to bitmasks */\n      public Bitmask vmask;                             /* Bitmask identifying virtual table cursors */\n      public u8 op;                                     /* Split operator.  TK_AND or TK_OR */\n      public int nTerm;                                 /* Number of terms */\n      public int nSlot;                                 /* Number of entries in a[] */\n      public WhereTerm[] a;                             /* Each a[] describes a term of the WHERE cluase */\n#if (SQLITE_SMALL_STACK)\npublic WhereTerm[] aStatic = new WhereTerm[1];    /* Initial static space for a[] */\n#else\n      public WhereTerm[] aStatic = new WhereTerm[8];    /* Initial static space for a[] */\n#endif\n\n      public void CopyTo( WhereClause wc )\n      {\n        wc.pParse = this.pParse;\n        wc.pMaskSet = new WhereMaskSet();\n        this.pMaskSet.CopyTo( wc.pMaskSet );\n        wc.op = this.op;\n        wc.nTerm = this.nTerm;\n        wc.nSlot = this.nSlot;\n        wc.a = (WhereTerm[])this.a.Clone();\n        wc.aStatic = (WhereTerm[])this.aStatic.Clone();\n      }\n    };\n\n    /*\n    ** A WhereTerm with eOperator==WO_OR has its u.pOrInfo pointer set to\n    ** a dynamically allocated instance of the following structure.\n    */\n    public class WhereOrInfo\n    {\n      public WhereClause wc = new WhereClause();/* Decomposition into subterms */\n      public Bitmask indexable;                 /* Bitmask of all indexable tables in the clause */\n    };\n\n    /*\n    ** A WhereTerm with eOperator==WO_AND has its u.pAndInfo pointer set to\n    ** a dynamically allocated instance of the following structure.\n    */\n    public class WhereAndInfo\n    {\n      public WhereClause wc = new WhereClause();          /* The subexpression broken out */\n    };\n\n    /*\n    ** An instance of the following structure keeps track of a mapping\n    ** between VDBE cursor numbers and bits of the bitmasks in WhereTerm.\n    **\n    ** The VDBE cursor numbers are small integers contained in\n    ** SrcList_item.iCursor and Expr.iTable fields.  For any given WHERE\n    ** clause, the cursor numbers might not begin with 0 and they might\n    ** contain gaps in the numbering sequence.  But we want to make maximum\n    ** use of the bits in our bitmasks.  This structure provides a mapping\n    ** from the sparse cursor numbers into consecutive integers beginning\n    ** with 0.\n    **\n    ** If WhereMaskSet.ix[A]==B it means that The A-th bit of a Bitmask\n    ** corresponds VDBE cursor number B.  The A-th bit of a bitmask is 1<<A.\n    **\n    ** For example, if the WHERE clause expression used these VDBE\n    ** cursors:  4, 5, 8, 29, 57, 73.  Then the  WhereMaskSet structure\n    ** would map those cursor numbers into bits 0 through 5.\n    **\n    ** Note that the mapping is not necessarily ordered.  In the example\n    ** above, the mapping might go like this:  4.3, 5.1, 8.2, 29.0,\n    ** 57.5, 73.4.  Or one of 719 other combinations might be used. It\n    ** does not really matter.  What is important is that sparse cursor\n    ** numbers all get mapped into bit numbers that begin with 0 and contain\n    ** no gaps.\n    */\n    public class WhereMaskSet\n    {\n      public int n;                        /* Number of Debug.Assigned cursor values */\n      public int[] ix = new int[BMS];       /* Cursor Debug.Assigned to each bit */\n\n      public void CopyTo( WhereMaskSet wms )\n      {\n        wms.n = this.n;\n        wms.ix = (int[])this.ix.Clone();\n      }\n    }\n\n    /*\n    ** A WhereCost object records a lookup strategy and the estimated\n    ** cost of pursuing that strategy.\n    */\n    public class WhereCost\n    {\n      public WherePlan plan = new WherePlan();/* The lookup strategy */\n      public double rCost;                    /* Overall cost of pursuing this search strategy */\n      public double nRow;                     /* Estimated number of output rows */\n    };\n\n    /*\n    ** Bitmasks for the operators that indices are able to exploit.  An\n    ** OR-ed combination of these values can be used when searching for\n    ** terms in the where clause.\n    */\n    //#define WO_IN     0x001\n    //#define WO_EQ     0x002\n    //#define WO_LT     (WO_EQ<<(TK_LT-TK_EQ))\n    //#define WO_LE     (WO_EQ<<(TK_LE-TK_EQ))\n    //#define WO_GT     (WO_EQ<<(TK_GT-TK_EQ))\n    //#define WO_GE     (WO_EQ<<(TK_GE-TK_EQ))\n    //#define WO_MATCH  0x040\n    //#define WO_ISNULL 0x080\n    //#define WO_OR     0x100       /* Two or more OR-connected terms */\n    //#define WO_AND    0x200       /* Two or more AND-connected terms */\n\n    //#define WO_ALL    0xfff       /* Mask of all possible WO_* values */\n    //#define WO_SINGLE 0x0ff       /* Mask of all non-compound WO_* values */\n    const int WO_IN = 0x001;\n    const int WO_EQ = 0x002;\n    const int WO_LT = ( WO_EQ << ( TK_LT - TK_EQ ) );\n    const int WO_LE = ( WO_EQ << ( TK_LE - TK_EQ ) );\n    const int WO_GT = ( WO_EQ << ( TK_GT - TK_EQ ) );\n    const int WO_GE = ( WO_EQ << ( TK_GE - TK_EQ ) );\n    const int WO_MATCH = 0x040;\n    const int WO_ISNULL = 0x080;\n    const int WO_OR = 0x100;       /* Two or more OR-connected terms */\n    const int WO_AND = 0x200;       /* Two or more AND-connected terms */\n\n    const int WO_ALL = 0xfff;       /* Mask of all possible WO_* values */\n    const int WO_SINGLE = 0x0ff;       /* Mask of all non-compound WO_* values */\n    /*\n    ** Value for wsFlags returned by bestIndex() and stored in\n    ** WhereLevel.wsFlags.  These flags determine which search\n    ** strategies are appropriate.\n    **\n    ** The least significant 12 bits is reserved as a mask for WO_ values above.\n    ** The WhereLevel.wsFlags field is usually set to WO_IN|WO_EQ|WO_ISNULL.\n    ** But if the table is the right table of a left join, WhereLevel.wsFlags\n    ** is set to WO_IN|WO_EQ.  The WhereLevel.wsFlags field can then be used as\n    ** the "op" parameter to findTerm when we are resolving equality constraints.\n    ** ISNULL constraints will then not be used on the right table of a left\n    ** join.  Tickets #2177 and #2189.\n    */\n    //#define WHERE_ROWID_EQ     0x00001000  /* rowid=EXPR or rowid IN (...) */\n    //#define WHERE_ROWID_RANGE  0x00002000  /* rowid<EXPR and/or rowid>EXPR */\n    //#define WHERE_COLUMN_EQ    0x00010000  /* x=EXPR or x IN (...) or x IS NULL */\n    //#define WHERE_COLUMN_RANGE 0x00020000  /* x<EXPR and/or x>EXPR */\n    //#define WHERE_COLUMN_IN    0x00040000  /* x IN (...) */\n    //#define WHERE_COLUMN_NULL  0x00080000  /* x IS NULL */\n    //#define WHERE_INDEXED      0x000f0000  /* Anything that uses an index */\n    //#define WHERE_IN_ABLE      0x000f1000  /* Able to support an IN operator */\n    //#define WHERE_TOP_LIMIT    0x00100000  /* x<EXPR or x<=EXPR constraint */\n    //#define WHERE_BTM_LIMIT    0x00200000  /* x>EXPR or x>=EXPR constraint */\n    //#define WHERE_IDX_ONLY     0x00800000  /* Use index only - omit table */\n    //#define WHERE_ORDERBY      0x01000000  /* Output will appear in correct order */\n    //#define WHERE_REVERSE      0x02000000  /* Scan in reverse order */\n    //#define WHERE_UNIQUE       0x04000000  /* Selects no more than one row */\n    //#define WHERE_VIRTUALTABLE 0x08000000  /* Use virtual-table processing */\n    //#define WHERE_MULTI_OR     0x10000000  /* OR using multiple indices */\n    const int WHERE_ROWID_EQ = 0x00001000; /* rowid=EXPR or rowid IN (...) */\n    const int WHERE_ROWID_RANGE = 0x00002000; /* rowid<EXPR and/or rowid>EXPR */\n    const int WHERE_COLUMN_EQ = 0x00010000; /* x=EXPR or x IN (...) */\n    const int WHERE_COLUMN_RANGE = 0x00020000; /* x<EXPR and/or x>EXPR */\n    const int WHERE_COLUMN_IN = 0x00040000; /* x IN (...) */\n    const int WHERE_COLUMN_NULL = 0x00080000; /* x IS NULL */\n    const int WHERE_INDEXED = 0x000f0000; /* Anything that uses an index */\n    const int WHERE_IN_ABLE = 0x000f1000; /* Able to support an IN operator */\n    const int WHERE_TOP_LIMIT = 0x00100000; /* x<EXPR or x<=EXPR constraint */\n    const int WHERE_BTM_LIMIT = 0x00200000; /* x>EXPR or x>=EXPR constraint */\n    const int WHERE_IDX_ONLY = 0x00800000; /* Use index only - omit table */\n    const int WHERE_ORDERBY = 0x01000000; /* Output will appear in correct order */\n    const int WHERE_REVERSE = 0x02000000; /* Scan in reverse order */\n    const int WHERE_UNIQUE = 0x04000000; /* Selects no more than one row */\n    const int WHERE_VIRTUALTABLE = 0x08000000; /* Use virtual-table processing */\n    const int WHERE_MULTI_OR = 0x10000000; /* OR using multiple indices */\n\n    /*\n    ** Initialize a preallocated WhereClause structure.\n    */\n    static void whereClauseInit(\n    WhereClause pWC,        /* The WhereClause to be initialized */\n    Parse pParse,           /* The parsing context */\n    WhereMaskSet pMaskSet   /* Mapping from table cursor numbers to bitmasks */\n    )\n    {\n      pWC.pParse = pParse;\n      pWC.pMaskSet = pMaskSet;\n      pWC.nTerm = 0;\n      pWC.nSlot = ArraySize( pWC.aStatic ) - 1;\n      pWC.a = pWC.aStatic;\n      pWC.vmask = 0;\n    }\n\n    /* Forward reference */\n    //static void whereClauseClear(WhereClause);\n\n    /*\n    ** Deallocate all memory Debug.Associated with a WhereOrInfo object.\n    */\n    static void whereOrInfoDelete( sqlite3 db, WhereOrInfo p )\n    {\n      whereClauseClear( p.wc );\n      //sqlite3DbFree( db, p );\n    }\n\n    /*\n    ** Deallocate all memory Debug.Associated with a WhereAndInfo object.\n    */\n    static void whereAndInfoDelete( sqlite3 db, WhereAndInfo p )\n    {\n      whereClauseClear( p.wc );\n      //sqlite3DbFree( db, p );\n    }\n\n    /*\n    ** Deallocate a WhereClause structure.  The WhereClause structure\n    ** itself is not freed.  This routine is the inverse of whereClauseInit().\n    */\n    static void whereClauseClear( WhereClause pWC )\n    {\n      int i;\n      WhereTerm a;\n      sqlite3 db = pWC.pParse.db;\n      for ( i = pWC.nTerm - 1 ; i >= 0 ; i-- )//, a++)\n      {\n        a = pWC.a[i];\n        if ( ( a.wtFlags & TERM_DYNAMIC ) != 0 )\n        {\n          sqlite3ExprDelete( db, ref a.pExpr );\n        }\n        if ( ( a.wtFlags & TERM_ORINFO ) != 0 )\n        {\n          whereOrInfoDelete( db, a.u.pOrInfo );\n        }\n        else if ( ( a.wtFlags & TERM_ANDINFO ) != 0 )\n        {\n          whereAndInfoDelete( db, a.u.pAndInfo );\n        }\n      }\n      if ( pWC.a != pWC.aStatic )\n      {\n        //sqlite3DbFree( db, ref pWC.a );\n      }\n    }\n\n    /*\n    ** Add a single new WhereTerm entry to the WhereClause object pWC.\n    ** The new WhereTerm object is constructed from Expr p and with wtFlags.\n    ** The index in pWC.a[] of the new WhereTerm is returned on success.\n    ** 0 is returned if the new WhereTerm could not be added due to a memory\n    ** allocation error.  The memory allocation failure will be recorded in\n    ** the db.mallocFailed flag so that higher-level functions can detect it.\n    **\n    ** This routine will increase the size of the pWC.a[] array as necessary.\n    **\n    ** If the wtFlags argument includes TERM_DYNAMIC, then responsibility\n    ** for freeing the expression p is Debug.Assumed by the WhereClause object pWC.\n    ** This is true even if this routine fails to allocate a new WhereTerm.\n    **\n    ** WARNING:  This routine might reallocate the space used to store\n    ** WhereTerms.  All pointers to WhereTerms should be invalidated after\n    ** calling this routine.  Such pointers may be reinitialized by referencing\n    ** the pWC.a[] array.\n    */\n    static int whereClauseInsert( WhereClause pWC, Expr p, u8 wtFlags )\n    {\n      WhereTerm pTerm;\n      int idx;\n      if ( pWC.nTerm >= pWC.nSlot )\n      {\n        //WhereTerm pOld = pWC.a;\n        sqlite3 db = pWC.pParse.db;\n        Array.Resize( ref pWC.a, pWC.nSlot * 2 );\n        //pWC.a = sqlite3DbMallocRaw(db, sizeof(pWC.a[0])*pWC.nSlot*2 );\n        //if( pWC.a==null ){\n        //  if( wtFlags & TERM_DYNAMIC ){\n        //    sqlite3ExprDelete(db, ref p);\n        //  }\n        //  pWC.a = pOld;\n        //  return 0;\n        //}\n        //memcpy(pWC.a, pOld, sizeof(pWC.a[0])*pWC.nTerm);\n        //if( pOld!=pWC.aStatic ){\n        //  //sqlite3DbFree(db, pOld);\n        //}\n        //pWC.nSlot = sqlite3DbMallocSize(db, pWC.a)/sizeof(pWC.a[0]);\n        pWC.nSlot = pWC.a.Length - 1;\n      }\n      pWC.a[idx = pWC.nTerm++] = new WhereTerm();\n      pTerm = pWC.a[idx];\n      pTerm.pExpr = p;\n      pTerm.wtFlags = wtFlags;\n      pTerm.pWC = pWC;\n      pTerm.iParent = -1;\n      return idx;\n    }\n\n    /*\n    ** This routine identifies subexpressions in the WHERE clause where\n    ** each subexpression is separated by the AND operator or some other\n    ** operator specified in the op parameter.  The WhereClause structure\n    ** is filled with pointers to subexpressions.  For example:\n    **\n    **    WHERE  a==\'hello\' AND coalesce(b,11)<10 AND (c+12!=d OR c==22)\n    **           \\________/     \\_______________/     \\________________/\n    **            slot[0]            slot[1]               slot[2]\n    **\n    ** The original WHERE clause in pExpr is unaltered.  All this routine\n    ** does is make slot[] entries point to substructure within pExpr.\n    **\n    ** In the previous sentence and in the diagram, "slot[]" refers to\n    ** the WhereClause.a[] array.  The slot[] array grows as needed to contain\n    ** all terms of the WHERE clause.\n    */\n    static void whereSplit( WhereClause pWC, Expr pExpr, int op )\n    {\n      pWC.op = (u8)op;\n      if ( pExpr == null ) return;\n      if ( pExpr.op != op )\n      {\n        whereClauseInsert( pWC, pExpr, 0 );\n      }\n      else\n      {\n        whereSplit( pWC, pExpr.pLeft, op );\n        whereSplit( pWC, pExpr.pRight, op );\n      }\n    }\n\n    /*\n    ** Initialize an expression mask set (a WhereMaskSet object)\n    */\n    //#define initMaskSet(P)  memset(P, 0, sizeof(*P))\n\n    /*\n    ** Return the bitmask for the given cursor number.  Return 0 if\n    ** iCursor is not in the set.\n    */\n    static Bitmask getMask( WhereMaskSet pMaskSet, int iCursor )\n    {\n      int i;\n      Debug.Assert( pMaskSet.n <= sizeof( Bitmask ) * 8 );\n      for ( i = 0 ; i < pMaskSet.n ; i++ )\n      {\n        if ( pMaskSet.ix[i] == iCursor )\n        {\n          return ( (Bitmask)1 ) << i;\n        }\n      }\n      return 0;\n    }\n\n    /*\n    ** Create a new mask for cursor iCursor.\n    **\n    ** There is one cursor per table in the FROM clause.  The number of\n    ** tables in the FROM clause is limited by a test early in the\n    ** sqlite3WhereBegin() routine.  So we know that the pMaskSet.ix[]\n    ** array will never overflow.\n    */\n    static void createMask( WhereMaskSet pMaskSet, int iCursor )\n    {\n      Debug.Assert( pMaskSet.n < ArraySize( pMaskSet.ix ) );\n      pMaskSet.ix[pMaskSet.n++] = iCursor;\n    }\n\n    /*\n    ** This routine walks (recursively) an expression tree and generates\n    ** a bitmask indicating which tables are used in that expression\n    ** tree.\n    **\n    ** In order for this routine to work, the calling function must have\n    ** previously invoked sqlite3ResolveExprNames() on the expression.  See\n    ** the header comment on that routine for additional information.\n    ** The sqlite3ResolveExprNames() routines looks for column names and\n    ** sets their opcodes to TK_COLUMN and their Expr.iTable fields to\n    ** the VDBE cursor number of the table.  This routine just has to\n    ** translate the cursor numbers into bitmask values and OR all\n    ** the bitmasks together.\n    */\n    //static Bitmask exprListTableUsage(WhereMaskSet*, ExprList);\n    //static Bitmask exprSelectTableUsage(WhereMaskSet*, Select);\n    static Bitmask exprTableUsage( WhereMaskSet pMaskSet, Expr p )\n    {\n      Bitmask mask = 0;\n      if ( p == null ) return 0;\n      if ( p.op == TK_COLUMN )\n      {\n        mask = getMask( pMaskSet, p.iTable );\n        return mask;\n      }\n      mask = exprTableUsage( pMaskSet, p.pRight );\n      mask |= exprTableUsage( pMaskSet, p.pLeft );\n      if ( ExprHasProperty( p, EP_xIsSelect ) )\n      {\n        mask |= exprSelectTableUsage( pMaskSet, p.x.pSelect );\n      }\n      else\n      {\n        mask |= exprListTableUsage( pMaskSet, p.x.pList );\n      }\n      return mask;\n    }\n    static Bitmask exprListTableUsage( WhereMaskSet pMaskSet, ExprList pList )\n    {\n      int i;\n      Bitmask mask = 0;\n      if ( pList != null )\n      {\n        for ( i = 0 ; i < pList.nExpr ; i++ )\n        {\n          mask |= exprTableUsage( pMaskSet, pList.a[i].pExpr );\n        }\n      }\n      return mask;\n    }\n    static Bitmask exprSelectTableUsage( WhereMaskSet pMaskSet, Select pS )\n    {\n      Bitmask mask = 0;\n      while ( pS != null )\n      {\n        mask |= exprListTableUsage( pMaskSet, pS.pEList );\n        mask |= exprListTableUsage( pMaskSet, pS.pGroupBy );\n        mask |= exprListTableUsage( pMaskSet, pS.pOrderBy );\n        mask |= exprTableUsage( pMaskSet, pS.pWhere );\n        mask |= exprTableUsage( pMaskSet, pS.pHaving );\n        pS = pS.pPrior;\n      }\n      return mask;\n    }\n\n    /*\n    ** Return TRUE if the given operator is one of the operators that is\n    ** allowed for an indexable WHERE clause term.  The allowed operators are\n    ** "=", "<", ">", "<=", ">=", and "IN".\n    */\n    static bool allowedOp( int op )\n    {\n      Debug.Assert( TK_GT > TK_EQ && TK_GT < TK_GE );\n      Debug.Assert( TK_LT > TK_EQ && TK_LT < TK_GE );\n      Debug.Assert( TK_LE > TK_EQ && TK_LE < TK_GE );\n      Debug.Assert( TK_GE == TK_EQ + 4 );\n      return op == TK_IN || ( op >= TK_EQ && op <= TK_GE ) || op == TK_ISNULL;\n    }\n\n    /*\n    ** Swap two objects of type TYPE.\n    */\n    //#define SWAP(TYPE,A,B) {TYPE t=A; A=B; B=t;}\n\n    /*\n    ** Commute a comparison operator.  Expressions of the form "X op Y"\n    ** are converted into "Y op X".\n    **\n    ** If a collation sequence is Debug.Associated with either the left or right\n    ** side of the comparison, it remains Debug.Associated with the same side after\n    ** the commutation. So "Y collate NOCASE op X" becomes\n    ** "X collate NOCASE op Y". This is because any collation sequence on\n    ** the left hand side of a comparison overrides any collation sequence\n    ** attached to the right. For the same reason the EP_ExpCollate flag\n    ** is not commuted.\n    */\n    static void exprCommute( Parse pParse, Expr pExpr )\n    {\n      u16 expRight = (u16)( pExpr.pRight.flags & EP_ExpCollate );\n      u16 expLeft = (u16)( pExpr.pLeft.flags & EP_ExpCollate );\n      Debug.Assert( allowedOp( pExpr.op ) && pExpr.op != TK_IN );\n      pExpr.pRight.pColl = sqlite3ExprCollSeq( pParse, pExpr.pRight );\n      pExpr.pLeft.pColl = sqlite3ExprCollSeq( pParse, pExpr.pLeft );\n      SWAP( ref pExpr.pRight.pColl, ref pExpr.pLeft.pColl );\n      pExpr.pRight.flags = (u16)( ( pExpr.pRight.flags & ~EP_ExpCollate ) | expLeft );\n      pExpr.pLeft.flags = (u16)( ( pExpr.pLeft.flags & ~EP_ExpCollate ) | expRight );\n      SWAP( ref pExpr.pRight, ref pExpr.pLeft );\n      if ( pExpr.op >= TK_GT )\n      {\n        Debug.Assert( TK_LT == TK_GT + 2 );\n        Debug.Assert( TK_GE == TK_LE + 2 );\n        Debug.Assert( TK_GT > TK_EQ );\n        Debug.Assert( TK_GT < TK_LE );\n        Debug.Assert( pExpr.op >= TK_GT && pExpr.op <= TK_GE );\n        pExpr.op = (u8)( ( ( pExpr.op - TK_GT ) ^ 2 ) + TK_GT );\n      }\n    }\n\n    /*\n    ** Translate from TK_xx operator to WO_xx bitmask.\n    */\n    static u16 operatorMask( int op )\n    {\n      u16 c;\n      Debug.Assert( allowedOp( op ) );\n      if ( op == TK_IN )\n      {\n        c = WO_IN;\n      }\n      else if ( op == TK_ISNULL )\n      {\n        c = WO_ISNULL;\n      }\n      else\n      {\n        Debug.Assert( ( WO_EQ << ( op - TK_EQ ) ) < 0x7fff );\n        c = (u16)( WO_EQ << ( op - TK_EQ ) );\n      }\n      Debug.Assert( op != TK_ISNULL || c == WO_ISNULL );\n      Debug.Assert( op != TK_IN || c == WO_IN );\n      Debug.Assert( op != TK_EQ || c == WO_EQ );\n      Debug.Assert( op != TK_LT || c == WO_LT );\n      Debug.Assert( op != TK_LE || c == WO_LE );\n      Debug.Assert( op != TK_GT || c == WO_GT );\n      Debug.Assert( op != TK_GE || c == WO_GE );\n      return c;\n    }\n\n    /*\n    ** Search for a term in the WHERE clause that is of the form "X <op> <expr>"\n    ** where X is a reference to the iColumn of table iCur and <op> is one of\n    ** the WO_xx operator codes specified by the op parameter.\n    ** Return a pointer to the term.  Return 0 if not found.\n    */\n    static WhereTerm findTerm(\n    WhereClause pWC,     /* The WHERE clause to be searched */\n    int iCur,             /* Cursor number of LHS */\n    int iColumn,          /* Column number of LHS */\n    Bitmask notReady,     /* RHS must not overlap with this mask */\n    u32 op,               /* Mask of WO_xx values describing operator */\n    Index pIdx           /* Must be compatible with this index, if not NULL */\n    )\n    {\n      WhereTerm pTerm;\n      int k;\n      Debug.Assert( iCur >= 0 );\n      op &= WO_ALL;\n      for ( k = pWC.nTerm ; k != 0 ; k-- )//, pTerm++)\n      {\n        pTerm = pWC.a[pWC.nTerm - k];\n        if ( pTerm.leftCursor == iCur\n        && ( pTerm.prereqRight & notReady ) == 0\n        && pTerm.u.leftColumn == iColumn\n        && ( pTerm.eOperator & op ) != 0\n        )\n        {\n          if ( pIdx != null && pTerm.eOperator != WO_ISNULL )\n          {\n            Expr pX = pTerm.pExpr;\n            CollSeq pColl;\n            char idxaff;\n            int j;\n            Parse pParse = pWC.pParse;\n\n            idxaff = pIdx.pTable.aCol[iColumn].affinity;\n            if ( !sqlite3IndexAffinityOk( pX, idxaff ) ) continue;\n\n            /* Figure out the collation sequence required from an index for\n            ** it to be useful for optimising expression pX. Store this\n            ** value in variable pColl.\n            */\n            Debug.Assert( pX.pLeft != null );\n            pColl = sqlite3BinaryCompareCollSeq( pParse, pX.pLeft, pX.pRight );\n            Debug.Assert( pColl != null || pParse.nErr != 0 );\n\n            for ( j = 0 ; pIdx.aiColumn[j] != iColumn ; j++ )\n            {\n              if ( NEVER( j >= pIdx.nColumn ) ) return null;\n            }\n            if ( pColl != null && sqlite3StrICmp( pColl.zName, pIdx.azColl[j] ) != 0 ) continue;\n          }\n          return pTerm;\n        }\n      }\n      return null;\n    }\n\n    /* Forward reference */\n    //static void exprAnalyze(SrcList*, WhereClause*, int);\n\n    /*\n    ** Call exprAnalyze on all terms in a WHERE clause.\n    **\n    **\n    */\n    static void exprAnalyzeAll(\n    SrcList pTabList,       /* the FROM clause */\n    WhereClause pWC         /* the WHERE clause to be analyzed */\n    )\n    {\n      int i;\n      for ( i = pWC.nTerm - 1 ; i >= 0 ; i-- )\n      {\n        exprAnalyze( pTabList, pWC, i );\n      }\n    }\n\n#if  !SQLITE_OMIT_LIKE_OPTIMIZATION\n    /*\n** Check to see if the given expression is a LIKE or GLOB operator that\n** can be optimized using inequality constraints.  Return TRUE if it is\n** so and false if not.\n**\n** In order for the operator to be optimizible, the RHS must be a string\n** literal that does not begin with a wildcard.\n*/\n    static int isLikeOrGlob(\n    Parse pParse,         /* Parsing and code generating context */\n    Expr pExpr,           /* Test this expression */\n    ref int pnPattern,    /* Number of non-wildcard prefix characters */\n    ref bool pisComplete, /* True if the only wildcard is % in the last character */\n    ref bool pnoCase      /* True if uppercase is equivalent to lowercase */\n    )\n    {\n      string z;                  /* String on RHS of LIKE operator */\n      Expr pRight, pLeft;        /* Right and left size of LIKE operator */\n      ExprList pList;            /* List of operands to the LIKE operator */\n      int c = 0;                 /* One character in z[] */\n      int cnt;                   /* Number of non-wildcard prefix characters */\n      char[] wc = new char[3];   /* Wildcard characters */\n      CollSeq pColl;             /* Collating sequence for LHS */\n      sqlite3 db = pParse.db;    /* Data_base connection */\n\n      if ( !sqlite3IsLikeFunction( db, pExpr, ref pnoCase, wc ) )\n      {\n        return 0;\n      }\n#if SQLITE_EBCDIC\nif( pnoCase ) return 0;\n#endif\n      pList = pExpr.x.pList;\n      pRight = pList.a[0].pExpr;\n      if ( pRight.op != TK_STRING )\n      {\n        return 0;\n      }\n      pLeft = pList.a[1].pExpr;\n      if ( pLeft.op != TK_COLUMN )\n      {\n        return 0;\n      }\n      pColl = sqlite3ExprCollSeq( pParse, pLeft );\n      Debug.Assert( pColl != null || pLeft.iColumn == -1 );\n      if ( pColl == null ) return 0;\n      if ( ( pColl.type != SQLITE_COLL_BINARY || pnoCase ) &&\n      ( pColl.type != SQLITE_COLL_NOCASE || !pnoCase ) )\n      {\n        return 0;\n      }\n      if ( sqlite3ExprAffinity( pLeft ) != SQLITE_AFF_TEXT ) return 0;\n      z = pRight.u.zToken;\n      if ( ALWAYS( !String.IsNullOrEmpty( z ) ) )\n      {\n        cnt = 0;\n        while ( cnt < z.Length && ( c = z[cnt] ) != 0 && c != wc[0] && c != wc[1] && c != wc[2] )\n        {\n          cnt++;\n        }\n        if ( cnt != 0 && c != 0 && 255 != (u8)z[cnt - 1] )\n        {\n          pisComplete = cnt >= z.Length - 1 ? true : z[cnt] == wc[0] && z[cnt + 1] == 0;\n          pnPattern = cnt;\n          return 1;\n        }\n      }\n      return 0;\n    }\n#endif //* SQLITE_OMIT_LIKE_OPTIMIZATION */\n\n\n#if  !SQLITE_OMIT_VIRTUALTABLE\n/*\n** Check to see if the given expression is of the form\n**\n**         column MATCH expr\n**\n** If it is then return TRUE.  If not, return FALSE.\n*/\nstatic int isMatchOfColumn(\nExpr pExpr      /* Test this expression */\n){\nExprList pList;\n\nif( pExpr.op!=TK_FUNCTION ){\nreturn 0;\n}\nif(sqlite3StrICmp(pExpr->u.zToken,"match")!=0 ){\nreturn 0;\n}\npList = pExpr.x.pList;\nif( pList.nExpr!=2 ){\nreturn 0;\n}\nif( pList.a[1].pExpr.op != TK_COLUMN ){\nreturn 0;\n}\nreturn 1;\n}\n#endif //* SQLITE_OMIT_VIRTUALTABLE */\n\n    /*\n** If the pBase expression originated in the ON or USING clause of\n** a join, then transfer the appropriate markings over to derived.\n*/\n    static void transferJoinMarkings( Expr pDerived, Expr pBase )\n    {\n      pDerived.flags = (u16)( pDerived.flags | pBase.flags & EP_FromJoin );\n      pDerived.iRightJoinTable = pBase.iRightJoinTable;\n    }\n\n#if  !(SQLITE_OMIT_OR_OPTIMIZATION) && !(SQLITE_OMIT_SUBQUERY)\n    /*\n** Analyze a term that consists of two or more OR-connected\n** subterms.  So in:\n**\n**     ... WHERE  (a=5) AND (b=7 OR c=9 OR d=13) AND (d=13)\n**                          ^^^^^^^^^^^^^^^^^^^^\n**\n** This routine analyzes terms such as the middle term in the above example.\n** A WhereOrTerm object is computed and attached to the term under\n** analysis, regardless of the outcome of the analysis.  Hence:\n**\n**     WhereTerm.wtFlags   |=  TERM_ORINFO\n**     WhereTerm.u.pOrInfo  =  a dynamically allocated WhereOrTerm object\n**\n** The term being analyzed must have two or more of OR-connected subterms.\n** A single subterm might be a set of AND-connected sub-subterms.\n** Examples of terms under analysis:\n**\n**     (A)     t1.x=t2.y OR t1.x=t2.z OR t1.y=15 OR t1.z=t3.a+5\n**     (B)     x=expr1 OR expr2=x OR x=expr3\n**     (C)     t1.x=t2.y OR (t1.x=t2.z AND t1.y=15)\n**     (D)     x=expr1 OR (y>11 AND y<22 AND z LIKE \'*hello*\')\n**     (E)     (p.a=1 AND q.b=2 AND r.c=3) OR (p.x=4 AND q.y=5 AND r.z=6)\n**\n** CASE 1:\n**\n** If all subterms are of the form T.C=expr for some single column of C\n** a single table T (as shown in example B above) then create a new virtual\n** term that is an equivalent IN expression.  In other words, if the term\n** being analyzed is:\n**\n**      x = expr1  OR  expr2 = x  OR  x = expr3\n**\n** then create a new virtual term like this:\n**\n**      x IN (expr1,expr2,expr3)\n**\n** CASE 2:\n**\n** If all subterms are indexable by a single table T, then set\n**\n**     WhereTerm.eOperator              =  WO_OR\n**     WhereTerm.u.pOrInfo.indexable  |=  the cursor number for table T\n**\n** A subterm is "indexable" if it is of the form\n** "T.C <op> <expr>" where C is any column of table T and\n** <op> is one of "=", "<", "<=", ">", ">=", "IS NULL", or "IN".\n** A subterm is also indexable if it is an AND of two or more\n** subsubterms at least one of which is indexable.  Indexable AND\n** subterms have their eOperator set to WO_AND and they have\n** u.pAndInfo set to a dynamically allocated WhereAndTerm object.\n**\n** From another point of view, "indexable" means that the subterm could\n** potentially be used with an index if an appropriate index exists.\n** This analysis does not consider whether or not the index exists; that\n** is something the bestIndex() routine will determine.  This analysis\n** only looks at whether subterms appropriate for indexing exist.\n**\n** All examples A through E above all satisfy case 2.  But if a term\n** also statisfies case 1 (such as B) we know that the optimizer will\n** always prefer case 1, so in that case we pretend that case 2 is not\n** satisfied.\n**\n** It might be the case that multiple tables are indexable.  For example,\n** (E) above is indexable on tables P, Q, and R.\n**\n** Terms that satisfy case 2 are candidates for lookup by using\n** separate indices to find rowids for each subterm and composing\n** the union of all rowids using a RowSet object.  This is similar\n** to "bitmap indices" in other data_base engines.\n**\n** OTHERWISE:\n**\n** If neither case 1 nor case 2 apply, then leave the eOperator set to\n** zero.  This term is not useful for search.\n*/\n    static void exprAnalyzeOrTerm(\n    SrcList pSrc,            /* the FROM clause */\n    WhereClause pWC,         /* the complete WHERE clause */\n    int idxTerm               /* Index of the OR-term to be analyzed */\n    )\n    {\n      Parse pParse = pWC.pParse;            /* Parser context */\n      sqlite3 db = pParse.db;               /* Data_base connection */\n      WhereTerm pTerm = pWC.a[idxTerm];    /* The term to be analyzed */\n      Expr pExpr = pTerm.pExpr;             /* The expression of the term */\n      WhereMaskSet pMaskSet = pWC.pMaskSet; /* Table use masks */\n      int i;                                  /* Loop counters */\n      WhereClause pOrWc;        /* Breakup of pTerm into subterms */\n      WhereTerm pOrTerm;        /* A Sub-term within the pOrWc */\n      WhereOrInfo pOrInfo;      /* Additional information Debug.Associated with pTerm */\n      Bitmask chngToIN;         /* Tables that might satisfy case 1 */\n      Bitmask indexable;        /* Tables that are indexable, satisfying case 2 */\n\n      /*\n      ** Break the OR clause into its separate subterms.  The subterms are\n      ** stored in a WhereClause structure containing within the WhereOrInfo\n      ** object that is attached to the original OR clause term.\n      */\n      Debug.Assert( ( pTerm.wtFlags & ( TERM_DYNAMIC | TERM_ORINFO | TERM_ANDINFO ) ) == 0 );\n      Debug.Assert( pExpr.op == TK_OR );\n      pTerm.u.pOrInfo = pOrInfo = new WhereOrInfo();//sqlite3DbMallocZero(db, sizeof(*pOrInfo));\n      if ( pOrInfo == null ) return;\n      pTerm.wtFlags |= TERM_ORINFO;\n      pOrWc = pOrInfo.wc;\n      whereClauseInit( pOrWc, pWC.pParse, pMaskSet );\n      whereSplit( pOrWc, pExpr, TK_OR );\n      exprAnalyzeAll( pSrc, pOrWc );\n//      if ( db.mallocFailed != 0 ) return;\n      Debug.Assert( pOrWc.nTerm >= 2 );\n\n      /*\n      ** Compute the set of tables that might satisfy cases 1 or 2.\n      */\n      indexable = ~(Bitmask)0;\n      chngToIN = ~( pWC.vmask );\n      for ( i = pOrWc.nTerm - 1 ; i >= 0 && indexable != 0 ; i-- )//, pOrTerm++ )\n      {\n        pOrTerm = pOrWc.a[i];\n        if ( ( pOrTerm.eOperator & WO_SINGLE ) == 0 )\n        {\n          WhereAndInfo pAndInfo;\n          Debug.Assert( pOrTerm.eOperator == 0 );\n          Debug.Assert( ( pOrTerm.wtFlags & ( TERM_ANDINFO | TERM_ORINFO ) ) == 0 );\n          chngToIN = 0;\n          pAndInfo = new WhereAndInfo();//sqlite3DbMallocRaw(db, sizeof(*pAndInfo));\n          if ( pAndInfo != null )\n          {\n            WhereClause pAndWC;\n            WhereTerm pAndTerm;\n            int j;\n            Bitmask b = 0;\n            pOrTerm.u.pAndInfo = pAndInfo;\n            pOrTerm.wtFlags |= TERM_ANDINFO;\n            pOrTerm.eOperator = WO_AND;\n            pAndWC = pAndInfo.wc;\n            whereClauseInit( pAndWC, pWC.pParse, pMaskSet );\n            whereSplit( pAndWC, pOrTerm.pExpr, TK_AND );\n            exprAnalyzeAll( pSrc, pAndWC );\n            //testcase( db.mallocFailed );\n            ////if ( 0 == db.mallocFailed )\n            {\n              for ( j = 0 ; j < pAndWC.nTerm ; j++ )//, pAndTerm++ )\n              {\n                pAndTerm = pAndWC.a[j];\n                Debug.Assert( pAndTerm.pExpr != null );\n                if ( allowedOp( pAndTerm.pExpr.op ) )\n                {\n                  b |= getMask( pMaskSet, pAndTerm.leftCursor );\n                }\n              }\n            }\n            indexable &= b;\n          }\n        }\n        else if ( ( pOrTerm.wtFlags & TERM_COPIED ) != 0 )\n        {\n          /* Skip this term for now.  We revisit it when we process the\n          ** corresponding TERM_VIRTUAL term */\n        }\n        else\n        {\n          Bitmask b;\n          b = getMask( pMaskSet, pOrTerm.leftCursor );\n          if ( ( pOrTerm.wtFlags & TERM_VIRTUAL ) != 0 )\n          {\n            WhereTerm pOther = pOrWc.a[pOrTerm.iParent];\n            b |= getMask( pMaskSet, pOther.leftCursor );\n          }\n          indexable &= b;\n          if ( pOrTerm.eOperator != WO_EQ )\n          {\n            chngToIN = 0;\n          }\n          else\n          {\n            chngToIN &= b;\n          }\n        }\n      }\n\n      /*\n      ** Record the set of tables that satisfy case 2.  The set might be\n      ** empty.\n      */\n      pOrInfo.indexable = indexable;\n      pTerm.eOperator = (u16)( indexable == 0 ? 0 : WO_OR );\n\n      /*\n      ** chngToIN holds a set of tables that *might* satisfy case 1.  But\n      ** we have to do some additional checking to see if case 1 really\n      ** is satisfied.\n      **\n      ** chngToIN will hold either 0, 1, or 2 bits.  The 0-bit case means\n      ** that there is no possibility of transforming the OR clause into an\n      ** IN operator because one or more terms in the OR clause contain\n      ** something other than == on a column in the single table.  The 1-bit\n      ** case means that every term of the OR clause is of the form\n      ** "table.column=expr" for some single table.  The one bit that is set\n      ** will correspond to the common table.  We still need to check to make\n      ** sure the same column is used on all terms.  The 2-bit case is when\n      ** the all terms are of the form "table1.column=table2.column".  It\n      ** might be possible to form an IN operator with either table1.column\n      ** or table2.column as the LHS if either is common to every term of\n      ** the OR clause.\n      **\n      ** Note that terms of the form "table.column1=table.column2" (the\n      ** same table on both sizes of the ==) cannot be optimized.\n      */\n      if ( chngToIN != 0 )\n      {\n        int okToChngToIN = 0;     /* True if the conversion to IN is valid */\n        int iColumn = -1;         /* Column index on lhs of IN operator */\n        int iCursor = -1;         /* Table cursor common to all terms */\n        int j = 0;                /* Loop counter */\n\n        /* Search for a table and column that appears on one side or the\n        ** other of the == operator in every subterm.  That table and column\n        ** will be recorded in iCursor and iColumn.  There might not be any\n        ** such table and column.  Set okToChngToIN if an appropriate table\n        ** and column is found but leave okToChngToIN false if not found.\n        */\n        for ( j = 0 ; j < 2 && 0 == okToChngToIN ; j++ )\n        {\n          //pOrTerm = pOrWc.a;\n          for ( i = pOrWc.nTerm - 1 ; i >= 0 ; i-- )//, pOrTerm++)\n          {\n            pOrTerm = pOrWc.a[pOrWc.nTerm - 1 - i];\n            Debug.Assert( pOrTerm.eOperator == WO_EQ );\n            pOrTerm.wtFlags = (u8)( pOrTerm.wtFlags & ~TERM_OR_OK );\n            if ( pOrTerm.leftCursor == iCursor )\n            {\n              /* This is the 2-bit case and we are on the second iteration and\n              ** current term is from the first iteration.  So skip this term. */\n              Debug.Assert( j == 1 );\n              continue;\n            }\n            if ( ( chngToIN & getMask( pMaskSet, pOrTerm.leftCursor ) ) == 0 )\n            {\n              /* This term must be of the form t1.a==t2.b where t2 is in the\n              ** chngToIN set but t1 is not.  This term will be either preceeded\n              ** or follwed by an inverted copy (t2.b==t1.a).  Skip this term\n              ** and use its inversion. */\n              testcase( pOrTerm.wtFlags & TERM_COPIED );\n              testcase( pOrTerm.wtFlags & TERM_VIRTUAL );\n              Debug.Assert( ( pOrTerm.wtFlags & ( TERM_COPIED | TERM_VIRTUAL ) ) != 0 );\n              continue;\n            }\n            iColumn = pOrTerm.u.leftColumn;\n            iCursor = pOrTerm.leftCursor;\n            break;\n          }\n          if ( i < 0 )\n          {\n            /* No candidate table+column was found.  This can only occur\n            ** on the second iteration */\n            Debug.Assert( j == 1 );\n            Debug.Assert( ( chngToIN & ( chngToIN - 1 ) ) == 0 );\n            Debug.Assert( chngToIN == getMask( pMaskSet, iCursor ) );\n            break;\n          }\n          testcase( j == 1 );\n\n          /* We have found a candidate table and column.  Check to see if that\n          ** table and column is common to every term in the OR clause */\n          okToChngToIN = 1;\n          for ( ; i >= 0 && okToChngToIN != 0 ; i-- )//, pOrTerm++)\n          {\n            pOrTerm = pOrWc.a[pOrWc.nTerm - 1 - i];\n            Debug.Assert( pOrTerm.eOperator == WO_EQ );\n            if ( pOrTerm.leftCursor != iCursor )\n            {\n              pOrTerm.wtFlags = (u8)( pOrTerm.wtFlags & ~TERM_OR_OK );\n            }\n            else if ( pOrTerm.u.leftColumn != iColumn )\n            {\n              okToChngToIN = 0;\n            }\n            else\n            {\n              int affLeft, affRight;\n              /* If the right-hand side is also a column, then the affinities\n              ** of both right and left sides must be such that no type\n              ** conversions are required on the right.  (Ticket #2249)\n              */\n              affRight = sqlite3ExprAffinity( pOrTerm.pExpr.pRight );\n              affLeft = sqlite3ExprAffinity( pOrTerm.pExpr.pLeft );\n              if ( affRight != 0 && affRight != affLeft )\n              {\n                okToChngToIN = 0;\n              }\n              else\n              {\n                pOrTerm.wtFlags |= TERM_OR_OK;\n              }\n            }\n          }\n        }\n\n        /* At this point, okToChngToIN is true if original pTerm satisfies\n        ** case 1.  In that case, construct a new virtual term that is\n        ** pTerm converted into an IN operator.\n        */\n        if ( okToChngToIN != 0 )\n        {\n          Expr pDup;            /* A transient duplicate expression */\n          ExprList pList = null;   /* The RHS of the IN operator */\n          Expr pLeft = null;       /* The LHS of the IN operator */\n          Expr pNew;            /* The complete IN operator */\n\n          for ( i = pOrWc.nTerm - 1 ; i >= 0 ; i-- )//, pOrTerm++)\n          {\n            pOrTerm = pOrWc.a[pOrWc.nTerm - 1 - i];\n            if ( ( pOrTerm.wtFlags & TERM_OR_OK ) == 0 ) continue;\n            Debug.Assert( pOrTerm.eOperator == WO_EQ );\n            Debug.Assert( pOrTerm.leftCursor == iCursor );\n            Debug.Assert( pOrTerm.u.leftColumn == iColumn );\n            pDup = sqlite3ExprDup( db, pOrTerm.pExpr.pRight, 0 );\n            pList = sqlite3ExprListAppend( pWC.pParse, pList, pDup );\n            pLeft = pOrTerm.pExpr.pLeft;\n          }\n          Debug.Assert( pLeft != null );\n          pDup = sqlite3ExprDup( db, pLeft, 0 );\n          pNew = sqlite3PExpr( pParse, TK_IN, pDup, null, null );\n          if ( pNew != null )\n          {\n            int idxNew;\n            transferJoinMarkings( pNew, pExpr );\n            Debug.Assert( !ExprHasProperty( pNew, EP_xIsSelect ) );\n            pNew.x.pList = pList;\n            idxNew = whereClauseInsert( pWC, pNew, TERM_VIRTUAL | TERM_DYNAMIC );\n            testcase( idxNew == 0 );\n            exprAnalyze( pSrc, pWC, idxNew );\n            pTerm = pWC.a[idxTerm];\n            pWC.a[idxNew].iParent = idxTerm;\n            pTerm.nChild = 1;\n          }\n          else\n          {\n            sqlite3ExprListDelete( db, ref pList );\n          }\n          pTerm.eOperator = 0;  /* case 1 trumps case 2 */\n        }\n      }\n    }\n#endif //* !SQLITE_OMIT_OR_OPTIMIZATION && !SQLITE_OMIT_SUBQUERY */\n\n\n    /*\n** The input to this routine is an WhereTerm structure with only the\n** "pExpr" field filled in.  The job of this routine is to analyze the\n** subexpression and populate all the other fields of the WhereTerm\n** structure.\n**\n** If the expression is of the form "<expr> <op> X" it gets commuted\n** to the standard form of "X <op> <expr>".\n**\n** If the expression is of the form "X <op> Y" where both X and Y are\n** columns, then the original expression is unchanged and a new virtual\n** term of the form "Y <op> X" is added to the WHERE clause and\n** analyzed separately.  The original term is marked with TERM_COPIED\n** and the new term is marked with TERM_DYNAMIC (because it\'s pExpr\n** needs to be freed with the WhereClause) and TERM_VIRTUAL (because it\n** is a commuted copy of a prior term.)  The original term has nChild=1\n** and the copy has idxParent set to the index of the original term.\n*/\n    static void exprAnalyze(\n    SrcList pSrc,            /* the FROM clause */\n    WhereClause pWC,         /* the WHERE clause */\n    int idxTerm               /* Index of the term to be analyzed */\n    )\n    {\n      WhereTerm pTerm;                /* The term to be analyzed */\n      WhereMaskSet pMaskSet;          /* Set of table index masks */\n      Expr pExpr;                     /* The expression to be analyzed */\n      Bitmask prereqLeft;              /* Prerequesites of the pExpr.pLeft */\n      Bitmask prereqAll;               /* Prerequesites of pExpr */\n      Bitmask extraRight = 0;\n      int nPattern = 0;\n      bool isComplete = false;\n      bool noCase = false;\n      int op;                          /* Top-level operator.  pExpr.op */\n      Parse pParse = pWC.pParse;     /* Parsing context */\n      sqlite3 db = pParse.db;        /* Data_base connection */\n\n      //if ( db.mallocFailed != 0 )\n      //{\n      //  return;\n      //}\n      pTerm = pWC.a[idxTerm];\n      pMaskSet = pWC.pMaskSet;\n      pExpr = pTerm.pExpr;\n      prereqLeft = exprTableUsage( pMaskSet, pExpr.pLeft );\n      op = pExpr.op;\n      if ( op == TK_IN )\n      {\n        Debug.Assert( pExpr.pRight == null );\n        if ( ExprHasProperty( pExpr, EP_xIsSelect ) )\n        {\n          pTerm.prereqRight = exprSelectTableUsage( pMaskSet, pExpr.x.pSelect );\n        }\n        else\n        {\n          pTerm.prereqRight = exprListTableUsage( pMaskSet, pExpr.x.pList );\n        }\n      }\n      else if ( op == TK_ISNULL )\n      {\n        pTerm.prereqRight = 0;\n      }\n      else\n      {\n        pTerm.prereqRight = exprTableUsage( pMaskSet, pExpr.pRight );\n      }\n      prereqAll = exprTableUsage( pMaskSet, pExpr );\n      if ( ExprHasProperty( pExpr, EP_FromJoin ) )\n      {\n        Bitmask x = getMask( pMaskSet, pExpr.iRightJoinTable );\n        prereqAll |= x;\n        extraRight = x - 1;  /* ON clause terms may not be used with an index\n** on left table of a LEFT JOIN.  Ticket #3015 */\n      }\n      pTerm.prereqAll = prereqAll;\n      pTerm.leftCursor = -1;\n      pTerm.iParent = -1;\n      pTerm.eOperator = 0;\n      if ( allowedOp( op ) && ( pTerm.prereqRight & prereqLeft ) == 0 )\n      {\n        Expr pLeft = pExpr.pLeft;\n        Expr pRight = pExpr.pRight;\n        if ( pLeft.op == TK_COLUMN )\n        {\n          pTerm.leftCursor = pLeft.iTable;\n          pTerm.u.leftColumn = pLeft.iColumn;\n          pTerm.eOperator = operatorMask( op );\n        }\n        if ( pRight != null && pRight.op == TK_COLUMN )\n        {\n          WhereTerm pNew;\n          Expr pDup;\n          if ( pTerm.leftCursor >= 0 )\n          {\n            int idxNew;\n            pDup = sqlite3ExprDup( db, pExpr, 0 );\n            //if ( db.mallocFailed != 0 )\n            //{\n            //  sqlite3ExprDelete( db, ref pDup );\n            //  return;\n            //}\n            idxNew = whereClauseInsert( pWC, pDup, TERM_VIRTUAL | TERM_DYNAMIC );\n            if ( idxNew == 0 ) return;\n            pNew = pWC.a[idxNew];\n            pNew.iParent = idxTerm;\n            pTerm = pWC.a[idxTerm];\n            pTerm.nChild = 1;\n            pTerm.wtFlags |= TERM_COPIED;\n          }\n          else\n          {\n            pDup = pExpr;\n            pNew = pTerm;\n          }\n          exprCommute( pParse, pDup );\n          pLeft = pDup.pLeft;\n          pNew.leftCursor = pLeft.iTable;\n          pNew.u.leftColumn = pLeft.iColumn;\n          pNew.prereqRight = prereqLeft;\n          pNew.prereqAll = prereqAll;\n          pNew.eOperator = operatorMask( pDup.op );\n        }\n      }\n\n#if  !SQLITE_OMIT_BETWEEN_OPTIMIZATION\n      /* If a term is the BETWEEN operator, create two new virtual terms\n** that define the range that the BETWEEN implements.  For example:\n**\n**      a BETWEEN b AND c\n**\n** is converted into:\n**\n**      (a BETWEEN b AND c) AND (a>=b) AND (a<=c)\n**\n** The two new terms are added onto the end of the WhereClause object.\n** The new terms are "dynamic" and are children of the original BETWEEN\n** term.  That means that if the BETWEEN term is coded, the children are\n** skipped.  Or, if the children are satisfied by an index, the original\n** BETWEEN term is skipped.\n*/\n      else if ( pExpr.op == TK_BETWEEN && pWC.op == TK_AND )\n      {\n        ExprList pList = pExpr.x.pList;\n        int i;\n        u8[] ops = new u8[] { TK_GE, TK_LE };\n        Debug.Assert( pList != null );\n        Debug.Assert( pList.nExpr == 2 );\n        for ( i = 0 ; i < 2 ; i++ )\n        {\n          Expr pNewExpr;\n          int idxNew;\n          pNewExpr = sqlite3PExpr( pParse, ops[i],\n                     sqlite3ExprDup( db, pExpr.pLeft, 0 ),\n          sqlite3ExprDup( db, pList.a[i].pExpr, 0 ), null );\n          idxNew = whereClauseInsert( pWC, pNewExpr, TERM_VIRTUAL | TERM_DYNAMIC );\n          testcase( idxNew == 0 );\n          exprAnalyze( pSrc, pWC, idxNew );\n          pTerm = pWC.a[idxTerm];\n          pWC.a[idxNew].iParent = idxTerm;\n        }\n        pTerm.nChild = 2;\n      }\n#endif //* SQLITE_OMIT_BETWEEN_OPTIMIZATION */\n\n#if  !(SQLITE_OMIT_OR_OPTIMIZATION) && !(SQLITE_OMIT_SUBQUERY)\n      /* Analyze a term that is composed of two or more subterms connected by\n** an OR operator.\n*/\n      else if ( pExpr.op == TK_OR )\n      {\n        Debug.Assert( pWC.op == TK_AND );\n        exprAnalyzeOrTerm( pSrc, pWC, idxTerm );\n\t  pTerm = pWC.a[idxTerm];\n      }\n#endif //* SQLITE_OMIT_OR_OPTIMIZATION */\n\n#if  !SQLITE_OMIT_LIKE_OPTIMIZATION\n      /* Add constraints to reduce the search space on a LIKE or GLOB\n** operator.\n**\n** A like pattern of the form "x LIKE \'abc%\'" is changed into constraints\n**\n**          x>=\'abc\' AND x<\'abd\' AND x LIKE \'abc%\'\n**\n** The last character of the prefix "abc" is incremented to form the\n** termination condition "abd".\n*/\n      if ( isLikeOrGlob( pParse, pExpr, ref nPattern, ref isComplete, ref noCase ) != 0\n      && pWC.op == TK_AND )\n      {\n        Expr pLeft, pRight;\n        Expr pStr1, pStr2;\n        Expr pNewExpr1, pNewExpr2;\n        int idxNew1, idxNew2;\n\n        pLeft = pExpr.x.pList.a[1].pExpr;\n        pRight = pExpr.x.pList.a[0].pExpr;\n        pStr1 = sqlite3Expr( db, TK_STRING, pRight.u.zToken );\n        if ( pStr1 != null ) pStr1.u.zToken = pStr1.u.zToken.Substring( 0, nPattern );\n\n        pStr2 = sqlite3ExprDup( db, pStr1, 0 );\n        ////if ( 0 == db.mallocFailed )\n        {\n          int c, pC;    /* Last character before the first wildcard */\n          pC = pStr2.u.zToken[nPattern - 1];// (u8*)&pStr2->token.z[nPattern-1];\n          c = pC;\n          if ( noCase )\n          {\n            /* The point is to increment the last character before the first\n            ** wildcard.  But if we increment \'@\', that will push it into the\n            ** alphabetic range where case conversions will mess up the\n            ** inequality.  To avoid this, make sure to also run the full\n            ** LIKE on all candidate expressions by clearing the isComplete flag\n            */\n            if ( c == \'A\' - 1 ) isComplete = false;\n            c = sqlite3UpperToLower[c];\n          }\n          pStr2.u.zToken = pStr2.u.zToken.Substring( 0, nPattern - 1 ) + (char)( c + 1 );// pC = c + 1;\n        }\n        pNewExpr1 = sqlite3PExpr( pParse, TK_GE, sqlite3ExprDup( db, pLeft, 0 ), pStr1, null );\n        idxNew1 = whereClauseInsert( pWC, pNewExpr1, TERM_VIRTUAL | TERM_DYNAMIC );\n        testcase( idxNew1 == 0 );\n        exprAnalyze( pSrc, pWC, idxNew1 );\n        pNewExpr2 = sqlite3PExpr( pParse, TK_LT, sqlite3ExprDup( db, pLeft, 0 ), pStr2, null );\n        idxNew2 = whereClauseInsert( pWC, pNewExpr2, TERM_VIRTUAL | TERM_DYNAMIC );\n        testcase( idxNew2 == 0 );\n        exprAnalyze( pSrc, pWC, idxNew2 );\n        pTerm = pWC.a[idxTerm];\n        if ( isComplete )\n        {\n          pWC.a[idxNew1].iParent = idxTerm;\n          pWC.a[idxNew2].iParent = idxTerm;\n          pTerm.nChild = 2;\n        }\n      }\n#endif //* SQLITE_OMIT_LIKE_OPTIMIZATION */\n\n#if  !SQLITE_OMIT_VIRTUALTABLE\n/* Add a WO_MATCH auxiliary term to the constraint set if the\n** current expression is of the form:  column MATCH expr.\n** This information is used by the xBestIndex methods of\n** virtual tables.  The native query optimizer does not attempt\n** to do anything with MATCH functions.\n*/\nif ( isMatchOfColumn( pExpr ) )\n{\nint idxNew;\nExpr pRight, pLeft;\nWhereTerm pNewTerm;\nBitmask prereqColumn, prereqExpr;\n\npRight = pExpr.x.pList.a[0].pExpr;\npLeft = pExpr.x.pList.a[1].pExpr;\nprereqExpr = exprTableUsage( pMaskSet, pRight );\nprereqColumn = exprTableUsage( pMaskSet, pLeft );\nif ( ( prereqExpr & prereqColumn ) == null )\n{\nExpr pNewExpr;\npNewExpr = sqlite3PExpr(pParse, TK_MATCH,\n0, sqlite3ExprDup(db, pRight, 0), 0);\nidxNew = whereClauseInsert( pWC, pNewExpr, TERM_VIRTUAL | TERM_DYNAMIC );\ntestcase( idxNew == 0 );\npNewTerm = pWC.a[idxNew];\npNewTerm.prereqRight = prereqExpr;\npNewTerm.leftCursor = pLeft.iTable;\npNewTerm.u.leftColumn = pLeft.iColumn;\npNewTerm.eOperator = WO_MATCH;\npNewTerm.iParent = idxTerm;\npTerm = pWC.a[idxTerm];\npTerm.nChild = 1;\npTerm.wtFlags |= TERM_COPIED;\npNewTerm.prereqAll = pTerm.prereqAll;\n}\n}\n#endif //* SQLITE_OMIT_VIRTUALTABLE */\n\n      /* Prevent ON clause terms of a LEFT JOIN from being used to drive\n** an index for tables to the left of the join.\n*/\n      pTerm.prereqRight |= extraRight;\n    }\n\n    /*\n    ** Return TRUE if any of the expressions in pList.a[iFirst...] contain\n    ** a reference to any table other than the iBase table.\n    */\n    static bool referencesOtherTables(\n    ExprList pList,          /* Search expressions in ths list */\n    WhereMaskSet pMaskSet,   /* Mapping from tables to bitmaps */\n    int iFirst,               /* Be searching with the iFirst-th expression */\n    int iBase                 /* Ignore references to this table */\n    )\n    {\n      Bitmask allowed = ~getMask( pMaskSet, iBase );\n      while ( iFirst < pList.nExpr )\n      {\n        if ( ( exprTableUsage( pMaskSet, pList.a[iFirst++].pExpr ) & allowed ) != 0 )\n        {\n          return true;\n        }\n      }\n      return false;\n    }\n\n\n    /*\n    ** This routine decides if pIdx can be used to satisfy the ORDER BY\n    ** clause.  If it can, it returns 1.  If pIdx cannot satisfy the\n    ** ORDER BY clause, this routine returns 0.\n    **\n    ** pOrderBy is an ORDER BY clause from a SELECT statement.  pTab is the\n    ** left-most table in the FROM clause of that same SELECT statement and\n    ** the table has a cursor number of "_base".  pIdx is an index on pTab.\n    **\n    ** nEqCol is the number of columns of pIdx that are used as equality\n    ** constraints.  Any of these columns may be missing from the ORDER BY\n    ** clause and the match can still be a success.\n    **\n    ** All terms of the ORDER BY that match against the index must be either\n    ** ASC or DESC.  (Terms of the ORDER BY clause past the end of a UNIQUE\n    ** index do not need to satisfy this constraint.)  The pbRev value is\n    ** set to 1 if the ORDER BY clause is all DESC and it is set to 0 if\n    ** the ORDER BY clause is all ASC.\n    */\n    static bool isSortingIndex(\n    Parse pParse,          /* Parsing context */\n    WhereMaskSet pMaskSet, /* Mapping from table cursor numbers to bitmaps */\n    Index pIdx,            /* The index we are testing */\n    int _base,             /* Cursor number for the table to be sorted */\n    ExprList pOrderBy,     /* The ORDER BY clause */\n    int nEqCol,            /* Number of index columns with == constraints */\n    ref int pbRev          /* Set to 1 if ORDER BY is DESC */\n    )\n    {\n      int i, j;                       /* Loop counters */\n      int sortOrder = 0;              /* XOR of index and ORDER BY sort direction */\n      int nTerm;                      /* Number of ORDER BY terms */\n      ExprList_item pTerm;    /* A term of the ORDER BY clause */\n      sqlite3 db = pParse.db;\n\n      Debug.Assert( pOrderBy != null );\n      nTerm = pOrderBy.nExpr;\n      Debug.Assert( nTerm > 0 );\n\n      /* Match terms of the ORDER BY clause against columns of\n      ** the index.\n      **\n      ** Note that indices have pIdx.nColumn regular columns plus\n      ** one additional column containing the rowid.  The rowid column\n      ** of the index is also allowed to match against the ORDER BY\n      ** clause.\n      */\n      for ( i = j = 0 ; j < nTerm && i <= pIdx.nColumn ; i++ )\n      {\n        pTerm = pOrderBy.a[j];\n        Expr pExpr;        /* The expression of the ORDER BY pTerm */\n        CollSeq pColl;     /* The collating sequence of pExpr */\n        int termSortOrder; /* Sort order for this term */\n        int iColumn;       /* The i-th column of the index.  -1 for rowid */\n        int iSortOrder;    /* 1 for DESC, 0 for ASC on the i-th index term */\n        string zColl;      /* Name of the collating sequence for i-th index term */\n\n        pExpr = pTerm.pExpr;\n        if ( pExpr.op != TK_COLUMN || pExpr.iTable != _base )\n        {\n          /* Can not use an index sort on anything that is not a column in the\n          ** left-most table of the FROM clause */\n          break;\n        }\n        pColl = sqlite3ExprCollSeq( pParse, pExpr );\n        if ( null == pColl )\n        {\n          pColl = db.pDfltColl;\n        }\n        if ( i < pIdx.nColumn )\n        {\n          iColumn = pIdx.aiColumn[i];\n          if ( iColumn == pIdx.pTable.iPKey )\n          {\n            iColumn = -1;\n          }\n          iSortOrder = pIdx.aSortOrder[i];\n          zColl = pIdx.azColl[i];\n        }\n        else\n        {\n          iColumn = -1;\n          iSortOrder = 0;\n          zColl = pColl.zName;\n        }\n        if ( pExpr.iColumn != iColumn || sqlite3StrICmp( pColl.zName, zColl ) != 0 )\n        {\n          /* Term j of the ORDER BY clause does not match column i of the index */\n          if ( i < nEqCol )\n          {\n            /* If an index column that is constrained by == fails to match an\n            ** ORDER BY term, that is OK.  Just ignore that column of the index\n            */\n            continue;\n          }\n          else if ( i == pIdx.nColumn )\n          {\n            /* Index column i is the rowid.  All other terms match. */\n            break;\n          }\n          else\n          {\n            /* If an index column fails to match and is not constrained by ==\n            ** then the index cannot satisfy the ORDER BY constraint.\n            */\n            return false;\n          }\n        }\n        Debug.Assert( pIdx.aSortOrder != null );\n        Debug.Assert( pTerm.sortOrder == 0 || pTerm.sortOrder == 1 );\n        Debug.Assert( iSortOrder == 0 || iSortOrder == 1 );\n        termSortOrder = iSortOrder ^ pTerm.sortOrder;\n        if ( i > nEqCol )\n        {\n          if ( termSortOrder != sortOrder )\n          {\n            /* Indices can only be used if all ORDER BY terms past the\n            ** equality constraints are all either DESC or ASC. */\n            return false;\n          }\n        }\n        else\n        {\n          sortOrder = termSortOrder;\n        }\n        j++;\n        //pTerm++;\n        if ( iColumn < 0 && !referencesOtherTables( pOrderBy, pMaskSet, j, _base ) )\n        {\n          /* If the indexed column is the primary key and everything matches\n          ** so far and none of the ORDER BY terms to the right reference other\n          ** tables in the join, then we are Debug.Assured that the index can be used\n          ** to sort because the primary key is unique and so none of the other\n          ** columns will make any difference\n          */\n          j = nTerm;\n        }\n      }\n\n      pbRev = sortOrder != 0 ? 1 : 0;\n      if ( j >= nTerm )\n      {\n        /* All terms of the ORDER BY clause are covered by this index so\n        ** this index can be used for sorting. */\n        return true;\n      }\n      if ( pIdx.onError != OE_None && i == pIdx.nColumn\n      && !referencesOtherTables( pOrderBy, pMaskSet, j, _base ) )\n      {\n        /* All terms of this index match some prefix of the ORDER BY clause\n        ** and the index is UNIQUE and no terms on the tail of the ORDER BY\n        ** clause reference other tables in a join.  If this is all true then\n        ** the order by clause is superfluous. */\n        return true;\n      }\n      return false;\n    }\n\n    /*\n    ** Check table to see if the ORDER BY clause in pOrderBy can be satisfied\n    ** by sorting in order of ROWID.  Return true if so and set pbRev to be\n    ** true for reverse ROWID and false for forward ROWID order.\n    */\n    static bool sortableByRowid(\n    int _base,             /* Cursor number for table to be sorted */\n    ExprList pOrderBy,     /* The ORDER BY clause */\n    WhereMaskSet pMaskSet, /* Mapping from table cursors to bitmaps */\n    ref int pbRev          /* Set to 1 if ORDER BY is DESC */\n    )\n    {\n      Expr p;\n\n      Debug.Assert( pOrderBy != null );\n      Debug.Assert( pOrderBy.nExpr > 0 );\n      p = pOrderBy.a[0].pExpr;\n      if ( p.op == TK_COLUMN && p.iTable == _base && p.iColumn == -1\n      && !referencesOtherTables( pOrderBy, pMaskSet, 1, _base ) )\n      {\n        pbRev = pOrderBy.a[0].sortOrder;\n        return true;\n      }\n      return false;\n    }\n\n    /*\n    ** Prepare a crude estimate of the logarithm of the input value.\n    ** The results need not be exact.  This is only used for estimating\n    ** the total cost of performing operations with O(logN) or O(NlogN)\n    ** complexity.  Because N is just a guess, it is no great tragedy if\n    ** logN is a little off.\n    */\n    static double estLog( double N )\n    {\n      double logN = 1;\n      double x = 10;\n      while ( N > x )\n      {\n        logN += 1;\n        x *= 10;\n      }\n      return logN;\n    }\n\n    /*\n    ** Two routines for printing the content of an sqlite3_index_info\n    ** structure.  Used for testing and debugging only.  If neither\n    ** SQLITE_TEST or SQLITE_DEBUG are defined, then these routines\n    ** are no-ops.\n    */\n#if  !(SQLITE_OMIT_VIRTUALTABLE) && (SQLITE_DEBUG)\nstatic void TRACE_IDX_INPUTS( sqlite3_index_info p )\n{\nint i;\nif ( !sqlite3WhereTrace ) return;\nfor ( i = 0 ; i < p.nConstraint ; i++ )\n{\nsqlite3DebugPrintf( "  constraint[%d]: col=%d termid=%d op=%d usabled=%d\\n",\ni,\np.aConstraint[i].iColumn,\np.aConstraint[i].iTermOffset,\np.aConstraint[i].op,\np.aConstraint[i].usable );\n}\nfor ( i = 0 ; i < p.nOrderBy ; i++ )\n{\nsqlite3DebugPrintf( "  orderby[%d]: col=%d desc=%d\\n",\ni,\np.aOrderBy[i].iColumn,\np.aOrderBy[i].desc );\n}\n}\nstatic void TRACE_IDX_OUTPUTS( sqlite3_index_info p )\n{\nint i;\nif ( !sqlite3WhereTrace ) return;\nfor ( i = 0 ; i < p.nConstraint ; i++ )\n{\nsqlite3DebugPrintf( "  usage[%d]: argvIdx=%d omit=%d\\n",\ni,\np.aConstraintUsage[i].argvIndex,\np.aConstraintUsage[i].omit );\n}\nsqlite3DebugPrintf( "  idxNum=%d\\n", p.idxNum );\nsqlite3DebugPrintf( "  idxStr=%s\\n", p.idxStr );\nsqlite3DebugPrintf( "  orderByConsumed=%d\\n", p.orderByConsumed );\nsqlite3DebugPrintf( "  estimatedCost=%g\\n", p.estimatedCost );\n}\n#else\n    //#define TRACE_IDX_INPUTS(A)\n    //#define TRACE_IDX_OUTPUTS(A)\n#endif\n\n    /*\n** Required because bestIndex() is called by bestOrClauseIndex()\n*/\n    //static void bestIndex(\n    //Parse*, WhereClause*, struct SrcList_item*, Bitmask, ExprList*, WhereCost*);\n\n    /*\n    ** This routine attempts to find an scanning strategy that can be used\n    ** to optimize an \'OR\' expression that is part of a WHERE clause.\n    **\n    ** The table associated with FROM clause term pSrc may be either a\n    ** regular B-Tree table or a virtual table.\n    */\n    static void bestOrClauseIndex(\n    Parse pParse,               /* The parsing context */\n    WhereClause pWC,            /* The WHERE clause */\n    SrcList_item pSrc,         /* The FROM clause term to search */\n    Bitmask notReady,           /* Mask of cursors that are not available */\n    ExprList pOrderBy,          /* The ORDER BY clause */\n    WhereCost pCost             /* Lowest cost query plan */\n    )\n    {\n#if !SQLITE_OMIT_OR_OPTIMIZATION\n      int iCur = pSrc.iCursor;   /* The cursor of the table to be accessed */\n      Bitmask maskSrc = getMask( pWC.pMaskSet, iCur );  /* Bitmask for pSrc */\n      WhereTerm pWCEnd = pWC.a[pWC.nTerm];        /* End of pWC.a[] */\n      WhereTerm pTerm;                 /* A single term of the WHERE clause */\n\n      /* Search the WHERE clause terms for a usable WO_OR term. */\n      for ( int _pt = 0 ; _pt < pWC.nTerm ; _pt++ )//<pWCEnd; pTerm++)\n      {\n        pTerm = pWC.a[_pt];\n        if ( pTerm.eOperator == WO_OR\n        && ( ( pTerm.prereqAll & ~maskSrc ) & notReady ) == 0\n        && ( pTerm.u.pOrInfo.indexable & maskSrc ) != 0\n        )\n        {\n          WhereClause pOrWC = pTerm.u.pOrInfo.wc;\n          WhereTerm pOrWCEnd = pOrWC.a[pOrWC.nTerm];\n          WhereTerm pOrTerm;\n          int flags = WHERE_MULTI_OR;\n          double rTotal = 0;\n          double nRow = 0;\n\n          for ( int _pOrWC = 0 ; _pOrWC < pOrWC.nTerm ; _pOrWC++ )//pOrTerm = pOrWC.a ; pOrTerm < pOrWCEnd ; pOrTerm++ )\n          {\n            pOrTerm = pOrWC.a[_pOrWC];\n            WhereCost sTermCost = null;\n#if  (SQLITE_TEST) && (SQLITE_DEBUG)\n            WHERETRACE( "... Multi-index OR testing for term %d of %d....\\n",\n            _pOrWC, pOrWC.nTerm - _pOrWC//( pOrTerm - pOrWC.a ), ( pTerm - pWC.a )\n            );\n#endif\n            if ( pOrTerm.eOperator == WO_AND )\n            {\n              WhereClause pAndWC = pOrTerm.u.pAndInfo.wc;\n              bestIndex( pParse, pAndWC, pSrc, notReady, null, ref sTermCost );\n            }\n            else if ( pOrTerm.leftCursor == iCur )\n            {\n              WhereClause tempWC = new WhereClause();\n              tempWC.pParse = pWC.pParse;\n              tempWC.pMaskSet = pWC.pMaskSet;\n              tempWC.op = TK_AND;\n              tempWC.a = new WhereTerm[2];\n              tempWC.a[0] = pOrTerm;\n              tempWC.nTerm = 1;\n              bestIndex( pParse, tempWC, pSrc, notReady, null, ref sTermCost );\n            }\n            else\n            {\n              continue;\n            }\n            rTotal += sTermCost.rCost;\n            nRow += sTermCost.nRow;\n            if ( rTotal >= pCost.rCost ) break;\n          }\n\n          /* If there is an ORDER BY clause, increase the scan cost to account\n          ** for the cost of the sort. */\n          if ( pOrderBy != null )\n          {\n            rTotal += nRow * estLog( nRow );\n#if  (SQLITE_TEST) && (SQLITE_DEBUG)\n            WHERETRACE( "... sorting increases OR cost to %.9g\\n", rTotal );\n#endif\n          }\n\n          /* If the cost of scanning using this OR term for optimization is\n          ** less than the current cost stored in pCost, replace the contents\n          ** of pCost. */\n#if  (SQLITE_TEST) && (SQLITE_DEBUG)\n          WHERETRACE( "... multi-index OR cost=%.9g nrow=%.9g\\n", rTotal, nRow );\n#endif\n          if ( rTotal < pCost.rCost )\n          {\n            pCost.rCost = rTotal;\n            pCost.nRow = nRow;\n            pCost.plan.wsFlags = (uint)flags;\n            pCost.plan.u.pTerm = pTerm;\n          }\n        }\n      }\n#endif //* SQLITE_OMIT_OR_OPTIMIZATION */\n    }\n\n#if !SQLITE_OMIT_VIRTUALTABLE\n/*\n** Allocate and populate an sqlite3_index_info structure. It is the\n** responsibility of the caller to eventually release the structure\n** by passing the pointer returned by this function to //sqlite3_free().\n*/\nstatic sqlite3_index_info *allocateIndexInfo(\nParse *pParse,\nWhereClause *pWC,\nstruct SrcList_item *pSrc,\nExprList *pOrderBy\n){\nint i, j;\nint nTerm;\nstruct sqlite3_index_constraint *pIdxCons;\nstruct sqlite3_index_orderby *pIdxOrderBy;\nstruct sqlite3_index_constraint_usage *pUsage;\nWhereTerm *pTerm;\nint nOrderBy;\nsqlite3_index_info *pIdxInfo;\n\nWHERETRACE("Recomputing index info for %s...\\n", pSrc.pTab.zName);\n\n/* Count the number of possible WHERE clause constraints referring\n** to this virtual table */\nfor(i=nTerm=0, pTerm=pWC.a; i<pWC.nTerm; i++, pTerm++){\nif( pTerm.leftCursor != pSrc.iCursor ) continue;\nDebug.Assert( (pTerm.eOperator&(pTerm.eOperator-1))==null );\ntestcase( pTerm.eOperator==WO_IN );\ntestcase( pTerm.eOperator==WO_ISNULL );\nif( pTerm.eOperator & (WO_IN|WO_ISNULL) ) continue;\nnTerm++;\n}\n\n/* If the ORDER BY clause contains only columns in the current\n** virtual table then allocate space for the aOrderBy part of\n** the sqlite3_index_info structure.\n*/\nnOrderBy = 0;\nif( pOrderBy ){\nfor(i=0; i<pOrderBy.nExpr; i++){\nExpr pExpr = pOrderBy.a[i].pExpr;\nif( pExpr.op!=TK_COLUMN || pExpr.iTable!=pSrc.iCursor ) break;\n}\nif( i==pOrderBy.nExpr ){\nnOrderBy = pOrderBy.nExpr;\n}\n}\n\n/* Allocate the sqlite3_index_info structure\n*/\npIdxInfo = new sqlite3_index_info();\n//sqlite3DbMallocZero(pParse.db, sizeof(*pIdxInfo)\n//+ (sizeof(*pIdxCons) + sizeof(*pUsage))*nTerm\n//+ sizeof(*pIdxOrderBy)*nOrderBy );\nif( pIdxInfo==null ){\nsqlite3ErrorMsg(pParse, "out of memory");\n/* (double)0 In case of SQLITE_OMIT_FLOATING_POINT... */\nreturn 0;\n}\n\n/* Initialize the structure.  The sqlite3_index_info structure contains\n** many fields that are declared "const" to prevent xBestIndex from\n** changing them.  We have to do some funky casting in order to\n** initialize those fields.\n*/\npIdxCons = (sqlite3_index_constraint)pIdxInfo[1];\npIdxOrderBy = (sqlite3_index_orderby)pIdxCons[nTerm];\npUsage = (sqlite3_index_constraint_usage)pIdxOrderBy[nOrderBy];\npIdxInfo.nConstraint = nTerm;\npIdxInfo.nOrderBy = nOrderBy;\npIdxInfo.aConstraint = pIdxCons;\npIdxInfo.aOrderBy = pIdxOrderBy;\npIdxInfo.aConstraintUsage =\npUsage;\n\nfor(i=j=0, pTerm=pWC.a; i<pWC.nTerm; i++, pTerm++){\nif( pTerm.leftCursor != pSrc.iCursor ) continue;\nDebug.Assert( (pTerm.eOperator&(pTerm.eOperator-1))==null );\ntestcase( pTerm.eOperator==WO_IN );\ntestcase( pTerm.eOperator==WO_ISNULL );\nif( pTerm.eOperator & (WO_IN|WO_ISNULL) ) continue;\npIdxCons[j].iColumn = pTerm.u.leftColumn;\npIdxCons[j].iTermOffset = i;\npIdxCons[j].op = (u8)pTerm.eOperator;\n/* The direct Debug.Assignment in the previous line is possible only because\n** the WO_ and SQLITE_INDEX_CONSTRAINT_ codes are identical.  The\n** following Debug.Asserts verify this fact. */\nDebug.Assert( WO_EQ==SQLITE_INDEX_CONSTRAINT_EQ );\nDebug.Assert( WO_LT==SQLITE_INDEX_CONSTRAINT_LT );\nDebug.Assert( WO_LE==SQLITE_INDEX_CONSTRAINT_LE );\nDebug.Assert( WO_GT==SQLITE_INDEX_CONSTRAINT_GT );\nDebug.Assert( WO_GE==SQLITE_INDEX_CONSTRAINT_GE );\nDebug.Assert( WO_MATCH==SQLITE_INDEX_CONSTRAINT_MATCH );\nDebug.Assert( pTerm.eOperator & (WO_EQ|WO_LT|WO_LE|WO_GT|WO_GE|WO_MATCH) );\nj++;\n}\nfor(i=0; i<nOrderBy; i++){\nExpr pExpr = pOrderBy.a[i].pExpr;\npIdxOrderBy[i].iColumn = pExpr.iColumn;\npIdxOrderBy[i].desc = pOrderBy.a[i].sortOrder;\n}\n\nreturn pIdxInfo;\n}\n\n/*\n** The table object reference passed as the second argument to this function\n** must represent a virtual table. This function invokes the xBestIndex()\n** method of the virtual table with the sqlite3_index_info pointer passed\n** as the argument.\n**\n** If an error occurs, pParse is populated with an error message and a\n** non-zero value is returned. Otherwise, 0 is returned and the output\n** part of the sqlite3_index_info structure is left populated.\n**\n** Whether or not an error is returned, it is the responsibility of the\n** caller to eventually free p.idxStr if p.needToFreeIdxStr indicates\n** that this is required.\n*/\nstatic int vtabBestIndex(Parse *pParse, Table *pTab, sqlite3_index_info *p){\nsqlite3_vtab *pVtab = sqlite3GetVTable(pParse->db, pTab)->pVtab;\nint i;\nint rc;\n\n(void)sqlite3SafetyOff(pParse.db);\nWHERETRACE("xBestIndex for %s\\n", pTab.zName);\nTRACE_IDX_INPUTS(p);\nrc = pVtab.pModule.xBestIndex(pVtab, p);\nTRACE_IDX_OUTPUTS(p);\n(void)sqlite3SafetyOn(pParse.db);\n\nif( rc!=SQLITE_OK ){\nif( rc==SQLITE_NOMEM ){\npParse.db.mallocFailed = 1;\n}else if( !pVtab.zErrMsg ){\nsqlite3ErrorMsg(pParse, "%s", sqlite3ErrStr(rc));\n}else{\nsqlite3ErrorMsg(pParse, "%s", pVtab.zErrMsg);\n}\n}\n//sqlite3DbFree(pParse.db, pVtab.zErrMsg);\npVtab.zErrMsg = 0;\n\nfor(i=0; i<p.nConstraint; i++){\nif( !p.aConstraint[i].usable && p.aConstraintUsage[i].argvIndex>0 ){\nsqlite3ErrorMsg(pParse,\n"table %s: xBestIndex returned an invalid plan", pTab.zName);\n}\n}\n\nreturn pParse.nErr;\n}\n\n\n/*\n** Compute the best index for a virtual table.\n**\n** The best index is computed by the xBestIndex method of the virtual\n** table module.  This routine is really just a wrapper that sets up\n** the sqlite3_index_info structure that is used to communicate with\n** xBestIndex.\n**\n** In a join, this routine might be called multiple times for the\n** same virtual table.  The sqlite3_index_info structure is created\n** and initialized on the first invocation and reused on all subsequent\n** invocations.  The sqlite3_index_info structure is also used when\n** code is generated to access the virtual table.  The whereInfoDelete()\n** routine takes care of freeing the sqlite3_index_info structure after\n** everybody has finished with it.\n*/\nstatic void bestVirtualIndex(\nParse *pParse,                  /* The parsing context */\nWhereClause *pWC,               /* The WHERE clause */\nstruct SrcList_item *pSrc,      /* The FROM clause term to search */\nBitmask notReady,               /* Mask of cursors that are not available */\nExprList *pOrderBy,             /* The order by clause */\nWhereCost *pCost,               /* Lowest cost query plan */\nsqlite3_index_info **ppIdxInfo  /* Index information passed to xBestIndex */\n){\nTable *pTab = pSrc.pTab;\nsqlite3_index_info *pIdxInfo;\nstruct sqlite3_index_constraint *pIdxCons;\nstruct sqlite3_index_constraint_usage *pUsage;\nWhereTerm *pTerm;\nint i, j;\nint nOrderBy;\n\n/* Make sure wsFlags is initialized to some sane value. Otherwise, if the\n** malloc in allocateIndexInfo() fails and this function returns leaving\n** wsFlags in an uninitialized state, the caller may behave unpredictably.\n*/\nmemset(pCost, 0, sizeof(*pCost));\npCost.plan.wsFlags = WHERE_VIRTUALTABLE;\n\n/* If the sqlite3_index_info structure has not been previously\n** allocated and initialized, then allocate and initialize it now.\n*/\npIdxInfo = *ppIdxInfo;\nif( pIdxInfo==0 ){\n*ppIdxInfo = pIdxInfo = allocateIndexInfo(pParse, pWC, pSrc, pOrderBy);\n}\nif( pIdxInfo==0 ){\nreturn;\n}\n\n/* At this point, the sqlite3_index_info structure that pIdxInfo points\n** to will have been initialized, either during the current invocation or\n** during some prior invocation.  Now we just have to customize the\n** details of pIdxInfo for the current invocation and pDebug.Ass it to\n** xBestIndex.\n*/\n\n/* The module name must be defined. Also, by this point there must\n** be a pointer to an sqlite3_vtab structure. Otherwise\n** sqlite3ViewGetColumnNames() would have picked up the error.\n*/\nDebug.Assert( pTab.azModuleArg && pTab.azModuleArg[0] );\nDebug.Assert( sqlite3GetVTable(pParse.db, pTab) );\n\n/* Set the aConstraint[].usable fields and initialize all\n** output variables to zero.\n**\n** aConstraint[].usable is true for constraints where the right-hand\n** side contains only references to tables to the left of the current\n** table.  In other words, if the constraint is of the form:\n**\n**           column = expr\n**\n** and we are evaluating a join, then the constraint on column is\n** only valid if all tables referenced in expr occur to the left\n** of the table containing column.\n**\n** The aConstraints[] array contains entries for all constraints\n** on the current table.  That way we only have to compute it once\n** even though we might try to pick the best index multiple times.\n** For each attempt at picking an index, the order of tables in the\n** join might be different so we have to recompute the usable flag\n** each time.\n*/\npIdxCons = pIdxInfo.aConstraint;\npUsage = pIdxInfo.aConstraintUsage;\nfor(i=0; i<pIdxInfo.nConstraint; i++, pIdxCons++){\nj = pIdxCons.iTermOffset;\npTerm = pWC.a[j];\npIdxCons.usable =  (pTerm.prereqRight & notReady)==null ?1:0;\npUsage[i] = new sqlite3_index_constraint_usage();\n}\n// memset(pUsage, 0, sizeof(pUsage[0])*pIdxInfo.nConstraint);\nif( pIdxInfo.needToFreeIdxStr ){\n//sqlite3_free(pIdxInfo.idxStr);\n}\npIdxInfo.idxStr = 0;\npIdxInfo.idxNum = 0;\npIdxInfo.needToFreeIdxStr = 0;\npIdxInfo.orderByConsumed = 0;\n/* ((double)2) In case of SQLITE_OMIT_FLOATING_POINT... */\npIdxInfo.estimatedCost = SQLITE_BIG_DBL / ((double)2);\nnOrderBy = pIdxInfo.nOrderBy;\nif( !pOrderBy ){\npIdxInfo.nOrderBy = 0;\n}\n\nif( vtabBestIndex(pParse, pTab, pIdxInfo) ){\nreturn;\n}\n\n/* The cost is not allowed to be larger than SQLITE_BIG_DBL (the\n** inital value of lowestCost in this loop. If it is, then the\n** (cost<lowestCost) test below will never be true.\n**\n** Use "(double)2" instead of "2.0" in case OMIT_FLOATING_POINT\n** is defined.\n*/\nif( (SQLITE_BIG_DBL/((double)2))<pIdxInfo.estimatedCost ){\npCost.rCost = (SQLITE_BIG_DBL/((double)2));\n}else{\npCost.rCost = pIdxInfo.estimatedCost;\n}\npCost.plan.u.pVtabIdx = pIdxInfo;\nif( pIdxInfo->orderByConsumed ){\npCost.plan.wsFlags |= WHERE_ORDERBY;\n}\npCost.plan.nEq = 0;\npIdxInfo.nOrderBy = nOrderBy;\n\n/* Try to find a more efficient access pattern by using multiple indexes\n** to optimize an OR expression within the WHERE clause.\n*/\nbestOrClauseIndex(pParse, pWC, pSrc, notReady, pOrderBy, pCost);\n}\n#endif //* SQLITE_OMIT_VIRTUALTABLE */\n\n    /*\n** Find the query plan for accessing a particular table.  Write the\n** best query plan and its cost into the WhereCost object supplied as the\n** last parameter.\n**\n** The lowest cost plan wins.  The cost is an estimate of the amount of\n** CPU and disk I/O need to process the request using the selected plan.\n** Factors that influence cost include:\n**\n**    *  The estimated number of rows that will be retrieved.  (The\n**       fewer the better.)\n**\n**    *  Whether or not sorting must occur.\n**\n**    *  Whether or not there must be separate lookups in the\n**       index and in the main table.\n**\n** If there was an INDEXED BY clause (pSrc.pIndex) attached to the table in\n** the SQL statement, then this function only considers plans using the\n** named index. If no such plan is found, then the returned cost is\n** SQLITE_BIG_DBL. If a plan is found that uses the named index,\n** then the cost is calculated in the usual way.\n**\n** If a NOT INDEXED clause (pSrc.notIndexed!=0) was attached to the table\n** in the SELECT statement, then no indexes are considered. However, the\n** selected plan may still take advantage of the tables built-in rowid\n** index.\n*/\n    static void bestBtreeIndex(\n    Parse pParse,              /* The parsing context */\n    WhereClause pWC,           /* The WHERE clause */\n    SrcList_item pSrc,         /* The FROM clause term to search */\n    Bitmask notReady,          /* Mask of cursors that are not available */\n    ExprList pOrderBy,         /* The ORDER BY clause */\n    ref WhereCost pCost            /* Lowest cost query plan */\n    )\n    {\n      WhereTerm pTerm;           /* A single term of the WHERE clause */\n      int iCur = pSrc.iCursor;   /* The cursor of the table to be accessed */\n      Index pProbe;              /* An index we are evaluating */\n      int rev = 0;                 /* True to scan in reverse order */\n      u32 wsFlags;               /* Flags Debug.Associated with pProbe */\n      int nEq;                   /* Number of == or IN constraints */\n      u32 eqTermMask;            /* Mask of valid equality operators */\n      double cost;               /* Cost of using pProbe */\n      double nRow;               /* Estimated number of rows in result set */\n      int i;                     /* Loop counter */\n\n      WHERETRACE( "bestIndex: tbl=%s notReady=%llx\\n", pSrc.pTab.zName, notReady );\n      pProbe = pSrc.pTab.pIndex;\n      if ( pSrc.notIndexed != 0 )\n      {\n        pProbe = null;\n      }\n\n      /* If the table has no indices and there are no terms in the where\n      ** clause that refer to the ROWID, then we will never be able to do\n      ** anything other than a full table scan on this table.  We might as\n      ** well put it first in the join order.  That way, perhaps it can be\n      ** referenced by other tables in the join.\n      */\n      pCost = new WhereCost();//memset(pCost, 0, sizeof(*pCost));\n      if ( pProbe == null &&\n      findTerm( pWC, iCur, -1, 0, WO_EQ | WO_IN | WO_LT | WO_LE | WO_GT | WO_GE, null ) == null &&\n      ( pOrderBy == null || !sortableByRowid( iCur, pOrderBy, pWC.pMaskSet, ref rev ) ) )\n      {\n        if ( ( pParse.db.flags & SQLITE_ReverseOrder ) != 0 )\n        {\n          /* For application testing, randomly reverse the output order for\n          ** SELECT statements that omit the ORDER BY clause.  This will help\n          ** to find cases where\n          */\n          pCost.plan.wsFlags |= WHERE_REVERSE;\n        }\n        return;\n      }\n      pCost.rCost = SQLITE_BIG_DBL;\n\n      /* Check for a rowid=EXPR or rowid IN (...) constraints. If there was\n      ** an INDEXED BY clause attached to this table, skip this step.\n      */\n      if ( null == pSrc.pIndex )\n      {\n        pTerm = findTerm( pWC, iCur, -1, notReady, WO_EQ | WO_IN, null );\n        if ( pTerm != null )\n        {\n          Expr pExpr;\n          pCost.plan.wsFlags = WHERE_ROWID_EQ;\n          if ( ( pTerm.eOperator & WO_EQ ) != 0 )\n          {\n            /* Rowid== is always the best pick.  Look no further.  Because only\n            ** a single row is generated, output is always in sorted order */\n            pCost.plan.wsFlags = WHERE_ROWID_EQ | WHERE_UNIQUE;\n            pCost.plan.nEq = 1;\n            WHERETRACE( "... best is rowid\\n" );\n            pCost.rCost = 0;\n            pCost.nRow = 1;\n            return;\n          }\n          else if ( !ExprHasProperty( ( pExpr = pTerm.pExpr ), EP_xIsSelect )\n          && pExpr.x.pList != null\n          )\n          {\n            /* Rowid IN (LIST): cost is NlogN where N is the number of list\n            ** elements.  */\n            pCost.rCost = pCost.nRow = pExpr.x.pList.nExpr;\n            pCost.rCost *= estLog( pCost.rCost );\n          }\n          else\n          {\n            /* Rowid IN (SELECT): cost is NlogN where N is the number of rows\n            ** in the result of the inner select.  We have no way to estimate\n            ** that value so make a wild guess. */\n            pCost.nRow = 100;\n            pCost.rCost = 200;\n          }\n          WHERETRACE( "... rowid IN cost: %.9g\\n", pCost.rCost );\n        }\n\n        /* Estimate the cost of a table scan.  If we do not know how many\n        ** entries are in the table, use 1 million as a guess.\n        */\n        cost = pProbe != null ? pProbe.aiRowEst[0] : 1000000;\n        WHERETRACE( "... table scan _base cost: %.9g\\n", cost );\n        wsFlags = WHERE_ROWID_RANGE;\n\n        /* Check for constraints on a range of rowids in a table scan.\n        */\n        pTerm = findTerm( pWC, iCur, -1, notReady, WO_LT | WO_LE | WO_GT | WO_GE, null );\n        if ( pTerm != null )\n        {\n          if ( findTerm( pWC, iCur, -1, notReady, WO_LT | WO_LE, null ) != null )\n          {\n            wsFlags |= WHERE_TOP_LIMIT;\n            cost /= 3;  /* Guess that rowid<EXPR eliminates two-thirds of rows */\n          }\n          if ( findTerm( pWC, iCur, -1, notReady, WO_GT | WO_GE, null ) != null )\n          {\n            wsFlags |= WHERE_BTM_LIMIT;\n            cost /= 3;  /* Guess that rowid>EXPR eliminates two-thirds of rows */\n          }\n          WHERETRACE( "... rowid range reduces cost to %.9g\\n", cost );\n        }\n        else\n        {\n          wsFlags = 0;\n        }\n        nRow = cost;\n\n        /* If the table scan does not satisfy the ORDER BY clause, increase\n        ** the cost by NlogN to cover the expense of sorting. */\n        if ( pOrderBy != null )\n        {\n          if ( sortableByRowid( iCur, pOrderBy, pWC.pMaskSet, ref rev ) )\n          {\n            wsFlags |= WHERE_ORDERBY | WHERE_ROWID_RANGE;\n            if ( rev != 0 )\n            {\n              wsFlags |= WHERE_REVERSE;\n            }\n          }\n          else\n          {\n            cost += cost * estLog( cost );\n            WHERETRACE( "... sorting increases cost to %.9g\\n", cost );\n          }\n        }\n        else if ( ( pParse.db.flags & SQLITE_ReverseOrder ) != 0 )\n        {\n          /* For application testing, randomly reverse the output order for\n          ** SELECT statements that omit the ORDER BY clause.  This will help\n          ** to find cases where\n          */\n          wsFlags |= WHERE_REVERSE;\n        }\n        /* Remember this case if it is the best so far */\n        if ( cost < pCost.rCost )\n        {\n          pCost.rCost = cost;\n          pCost.nRow = nRow;\n          pCost.plan.wsFlags = wsFlags;\n        }\n      }\n\n      bestOrClauseIndex( pParse, pWC, pSrc, notReady, pOrderBy, pCost );\n\n      /* If the pSrc table is the right table of a LEFT JOIN then we may not\n      ** use an index to satisfy IS NULL constraints on that table.  This is\n      ** because columns might end up being NULL if the table does not match -\n      ** a circumstance which the index cannot help us discover.  Ticket #2177.\n      */\n      if ( ( pSrc.jointype & JT_LEFT ) != 0 )\n      {\n        eqTermMask = WO_EQ | WO_IN;\n      }\n      else\n      {\n        eqTermMask = WO_EQ | WO_IN | WO_ISNULL;\n      }\n\n      /* Look at each index.\n      */\n      if ( pSrc.pIndex != null )\n      {\n        pProbe = pSrc.pIndex;\n      }\n      for ( ; pProbe != null ; pProbe = ( pSrc.pIndex != null ? null : pProbe.pNext ) )\n      {\n        double inMultiplier = 1;  /* Number of equality look-ups needed */\n        int inMultIsEst = 0;      /* True if inMultiplier is an estimate */\n\n#if (SQLITE_TEST) && (SQLITE_DEBUG)\n        WHERETRACE( "... index %s:\\n", pProbe.zName );\n#endif\n\n        /* Count the number of columns in the index that are satisfied\n** by x=EXPR or x IS NULL constraints or x IN (...) constraints.\n** For a term of the form x=EXPR or x IS NULL we only have to do\n** a single binary search.  But for x IN (...) we have to do a\n** number of binary searched\n** equal to the number of entries on the RHS of the IN operator.\n** The inMultipler variable with try to estimate the number of\n** binary searches needed.\n*/\n        wsFlags = 0;\n        for ( i = 0 ; i < pProbe.nColumn ; i++ )\n        {\n          int j = pProbe.aiColumn[i];\n          pTerm = findTerm( pWC, iCur, j, notReady, (uint)eqTermMask, pProbe );\n          if ( pTerm == null ) break;\n          wsFlags |= WHERE_COLUMN_EQ;\n          if ( ( pTerm.eOperator & WO_IN ) != 0 )\n          {\n            Expr pExpr = pTerm.pExpr;\n            wsFlags |= WHERE_COLUMN_IN;\n            if ( ExprHasProperty( pExpr, EP_xIsSelect ) )\n            {\n              inMultiplier *= 25;\n              inMultIsEst = 1;\n            }\n            else if ( pExpr.x.pList != null )\n            {\n              inMultiplier *= pExpr.x.pList.nExpr + 1;\n            }\n          }\n          else if ( ( pTerm.eOperator & WO_ISNULL ) != 0 )\n          {\n            wsFlags |= WHERE_COLUMN_NULL;\n          }\n        }\n        nRow = pProbe.aiRowEst[i] * inMultiplier;\n        /* If inMultiplier is an estimate and that estimate results in an\n        ** nRow it that is more than half number of rows in the table,\n        ** then reduce inMultipler */\n        if ( inMultIsEst != 0 && nRow * 2 > pProbe.aiRowEst[0] )\n        {\n          nRow = pProbe.aiRowEst[0] / 2;\n          inMultiplier = nRow / pProbe.aiRowEst[i];\n        }\n        cost = nRow + inMultiplier * estLog( pProbe.aiRowEst[0] );\n        nEq = i;\n        if ( pProbe.onError != OE_None && nEq == pProbe.nColumn )\n        {\n          testcase( wsFlags & WHERE_COLUMN_IN );\n          testcase( wsFlags & WHERE_COLUMN_NULL );\n          if ( ( wsFlags & ( WHERE_COLUMN_IN | WHERE_COLUMN_NULL ) ) == 0 )\n          {\n            wsFlags |= WHERE_UNIQUE;\n          }\n        }\n#if (SQLITE_TEST) && (SQLITE_DEBUG)\n        WHERETRACE( "...... nEq=%d inMult=%.9g nRow=%.9g cost=%.9g\\n",\n        nEq, inMultiplier, nRow, cost );\n#endif\n\n        /* Look for range constraints.  Assume that each range constraint\n** makes the search space 1/3rd smaller.\n*/\n        if ( nEq < pProbe.nColumn )\n        {\n          int j = pProbe.aiColumn[nEq];\n          pTerm = findTerm( pWC, iCur, j, notReady, WO_LT | WO_LE | WO_GT | WO_GE, pProbe );\n          if ( pTerm != null )\n          {\n            wsFlags |= WHERE_COLUMN_RANGE;\n            if ( findTerm( pWC, iCur, j, notReady, WO_LT | WO_LE, pProbe ) != null )\n            {\n              wsFlags |= WHERE_TOP_LIMIT;\n              cost /= 3;\n              nRow /= 3;\n            }\n            if ( findTerm( pWC, iCur, j, notReady, WO_GT | WO_GE, pProbe ) != null )\n            {\n              wsFlags |= WHERE_BTM_LIMIT;\n              cost /= 3;\n              nRow /= 3;\n            }\n#if (SQLITE_TEST) && (SQLITE_DEBUG)\n            WHERETRACE( "...... range reduces nRow to %.9g and cost to %.9g\\n",\n            nRow, cost );\n#endif\n          }\n        }\n\n        /* Add the additional cost of sorting if that is a factor.\n        */\n        if ( pOrderBy != null )\n        {\n          if ( ( wsFlags & ( WHERE_COLUMN_IN | WHERE_COLUMN_NULL ) ) == 0\n          && isSortingIndex( pParse, pWC.pMaskSet, pProbe, iCur, pOrderBy, nEq, ref rev )\n          )\n          {\n            if ( wsFlags == 0 )\n            {\n              wsFlags = WHERE_COLUMN_RANGE;\n            }\n            wsFlags |= WHERE_ORDERBY;\n            if ( rev != 0 )\n            {\n              wsFlags |= WHERE_REVERSE;\n            }\n          }\n          else\n          {\n            cost += cost * estLog( cost );\n#if (SQLITE_TEST) && (SQLITE_DEBUG)\n            WHERETRACE( "...... orderby increases cost to %.9g\\n", cost );\n#endif\n          }\n        }\n        else if ( wsFlags != 0 && ( pParse.db.flags & SQLITE_ReverseOrder ) != 0 )\n        {\n          /* For application testing, randomly reverse the output order for\n          ** SELECT statements that omit the ORDER BY clause.  This will help\n          ** to find cases where\n          */\n          wsFlags |= WHERE_REVERSE;\n        }\n\n        /* Check to see if we can get away with using just the index without\n        ** ever reading the table.  If that is the case, then halve the\n        ** cost of this index.\n        */\n        if ( wsFlags != 0 && pSrc.colUsed < ( ( (Bitmask)1 ) << ( BMS - 1 ) ) )\n        {\n          Bitmask m = pSrc.colUsed;\n          int j;\n          for ( j = 0 ; j < pProbe.nColumn ; j++ )\n          {\n            int x = pProbe.aiColumn[j];\n            if ( x < BMS - 1 )\n            {\n              m &= ~( ( (Bitmask)1 ) << x );\n            }\n          }\n          if ( m == 0 )\n          {\n            wsFlags |= WHERE_IDX_ONLY;\n            cost /= 2;\n            WHERETRACE( "...... idx-only reduces cost to %.9g\\n", cost );\n          }\n        }\n\n        /* If this index has achieved the lowest cost so far, then use it.\n        */\n        if ( wsFlags != 0 && cost < pCost.rCost )\n        {\n          pCost.rCost = cost;\n          pCost.nRow = nRow;\n          pCost.plan.wsFlags = wsFlags;\n          pCost.plan.nEq = (u32)nEq;\n          Debug.Assert( ( pCost.plan.wsFlags & WHERE_INDEXED ) != 0 );\n          pCost.plan.u.pIdx = pProbe;\n        }\n      }\n\n      /* Report the best result\n      */\n      pCost.plan.wsFlags = (u32)( pCost.plan.wsFlags | eqTermMask );\n      WHERETRACE( "best index is %s, nrow=%.9g, cost=%.9g, wsFlags=%x, nEq=%d\\n",\n      ( pCost.plan.wsFlags & WHERE_INDEXED ) != 0 ?\n      pCost.plan.u.pIdx.zName : "(none)", pCost.nRow,\n      pCost.rCost, pCost.plan.wsFlags, pCost.plan.nEq );\n    }\n\n    /*\n    ** Find the query plan for accessing table pSrc.pTab. Write the\n    ** best query plan and its cost into the WhereCost object supplied\n    ** as the last parameter. This function may calculate the cost of\n    ** both real and virtual table scans.\n    */\n    static void bestIndex(\n    Parse pParse,               /* The parsing context */\n    WhereClause pWC,            /* The WHERE clause */\n    SrcList_item pSrc,          /* The FROM clause term to search */\n    Bitmask notReady,           /* Mask of cursors that are not available */\n    ExprList pOrderBy,          /* The ORDER BY clause */\n    ref WhereCost pCost         /* Lowest cost query plan */\n    )\n    {\n#if !SQLITE_OMIT_VIRTUALTABLE\nif ( IsVirtual( pSrc.pTab ) )\n{\nsqlite3_index_info p = null;\nbestVirtualIndex(pParse, pWC, pSrc, notReady, pOrderBy, pCost, p);\nif( p.needToFreeIdxStr !=0){\n//sqlite3_free(ref p.idxStr);\n}\n//sqlite3DbFree(pParse.db, p);\n}\nelse\n#endif\n      {\n        bestBtreeIndex( pParse, pWC, pSrc, notReady, pOrderBy, ref pCost );\n      }\n    }\n\n    /*\n    ** Disable a term in the WHERE clause.  Except, do not disable the term\n    ** if it controls a LEFT OUTER JOIN and it did not originate in the ON\n    ** or USING clause of that join.\n    **\n    ** Consider the term t2.z=\'ok\' in the following queries:\n    **\n    **   (1)  SELECT * FROM t1 LEFT JOIN t2 ON t1.a=t2.x WHERE t2.z=\'ok\'\n    **   (2)  SELECT * FROM t1 LEFT JOIN t2 ON t1.a=t2.x AND t2.z=\'ok\'\n    **   (3)  SELECT * FROM t1, t2 WHERE t1.a=t2.x AND t2.z=\'ok\'\n    **\n    ** The t2.z=\'ok\' is disabled in the in (2) because it originates\n    ** in the ON clause.  The term is disabled in (3) because it is not part\n    ** of a LEFT OUTER JOIN.  In (1), the term is not disabled.\n    **\n    ** Disabling a term causes that term to not be tested in the inner loop\n    ** of the join.  Disabling is an optimization.  When terms are satisfied\n    ** by indices, we disable them to prevent redundant tests in the inner\n    ** loop.  We would get the correct results if nothing were ever disabled,\n    ** but joins might run a little slower.  The trick is to disable as much\n    ** as we can without disabling too much.  If we disabled in (1), we\'d get\n    ** the wrong answer.  See ticket #813.\n    */\n    static void disableTerm( WhereLevel pLevel, WhereTerm pTerm )\n    {\n      if ( pTerm != null\n      && ALWAYS( ( pTerm.wtFlags & TERM_CODED ) == 0 )\n      && ( pLevel.iLeftJoin == 0 || ExprHasProperty( pTerm.pExpr, EP_FromJoin ) ) )\n      {\n        pTerm.wtFlags |= TERM_CODED;\n        if ( pTerm.iParent >= 0 )\n        {\n          WhereTerm pOther = pTerm.pWC.a[pTerm.iParent];\n          if ( ( --pOther.nChild ) == 0 )\n          {\n            disableTerm( pLevel, pOther );\n          }\n        }\n      }\n    }\n\n    /*\n    ** Apply the affinities Debug.Associated with the first n columns of index\n    ** pIdx to the values in the n registers starting at _base.\n    */\n    static void codeApplyAffinity( Parse pParse, int _base, int n, Index pIdx )\n    {\n      if ( n > 0 )\n      {\n        Vdbe v = pParse.pVdbe;\n        Debug.Assert( v != null );\n        sqlite3VdbeAddOp2( v, OP_Affinity, _base, n );\n        sqlite3IndexAffinityStr( v, pIdx );\n        sqlite3ExprCacheAffinityChange( pParse, _base, n );\n      }\n    }\n\n\n    /*\n    ** Generate code for a single equality term of the WHERE clause.  An equality\n    ** term can be either X=expr or X IN (...).   pTerm is the term to be\n    ** coded.\n    **\n    ** The current value for the constraint is left in register iReg.\n    **\n    ** For a constraint of the form X=expr, the expression is evaluated and its\n    ** result is left on the stack.  For constraints of the form X IN (...)\n    ** this routine sets up a loop that will iterate over all values of X.\n    */\n    static int codeEqualityTerm(\n    Parse pParse,      /* The parsing context */\n    WhereTerm pTerm,   /* The term of the WHERE clause to be coded */\n    WhereLevel pLevel, /* When level of the FROM clause we are working on */\n    int iTarget         /* Attempt to leave results in this register */\n    )\n    {\n      Expr pX = pTerm.pExpr;\n      Vdbe v = pParse.pVdbe;\n      int iReg;                  /* Register holding results */\n\n      Debug.Assert( iTarget > 0 );\n      if ( pX.op == TK_EQ )\n      {\n        iReg = sqlite3ExprCodeTarget( pParse, pX.pRight, iTarget );\n      }\n      else if ( pX.op == TK_ISNULL )\n      {\n        iReg = iTarget;\n        sqlite3VdbeAddOp2( v, OP_Null, 0, iReg );\n#if  !SQLITE_OMIT_SUBQUERY\n      }\n      else\n      {\n        int eType;\n        int iTab;\n        InLoop pIn;\n\n        Debug.Assert( pX.op == TK_IN );\n        iReg = iTarget;\n        int iDummy = -1; eType = sqlite3FindInIndex( pParse, pX, ref iDummy );\n        iTab = pX.iTable;\n        sqlite3VdbeAddOp2( v, OP_Rewind, iTab, 0 );\n        Debug.Assert( ( pLevel.plan.wsFlags & WHERE_IN_ABLE ) != 0 );\n        if ( pLevel.u._in.nIn == 0 )\n        {\n          pLevel.addrNxt = sqlite3VdbeMakeLabel( v );\n        }\n        pLevel.u._in.nIn++;\n        if ( pLevel.u._in.aInLoop == null ) pLevel.u._in.aInLoop = new InLoop[pLevel.u._in.nIn];\n        else Array.Resize( ref pLevel.u._in.aInLoop, pLevel.u._in.nIn );\n        //sqlite3DbReallocOrFree(pParse.db, pLevel.u._in.aInLoop,\n        //                       sizeof(pLevel.u._in.aInLoop[0])*pLevel.u._in.nIn);\n        //pIn = pLevel.u._in.aInLoop;\n        if ( pLevel.u._in.aInLoop != null )//(pIn )\n        {\n          pLevel.u._in.aInLoop[pLevel.u._in.nIn - 1] = new InLoop();\n          pIn = pLevel.u._in.aInLoop[pLevel.u._in.nIn - 1];//pIn++\n          pIn.iCur = iTab;\n          if ( eType == IN_INDEX_ROWID )\n          {\n            pIn.addrInTop = sqlite3VdbeAddOp2( v, OP_Rowid, iTab, iReg );\n          }\n          else\n          {\n            pIn.addrInTop = sqlite3VdbeAddOp3( v, OP_Column, iTab, 0, iReg );\n          }\n          sqlite3VdbeAddOp1( v, OP_IsNull, iReg );\n        }\n        else\n        {\n          pLevel.u._in.nIn = 0;\n        }\n#endif\n      }\n      disableTerm( pLevel, pTerm );\n      return iReg;\n    }\n\n    /*\n    ** Generate code that will evaluate all == and IN constraints for an\n    ** index.  The values for all constraints are left on the stack.\n    **\n    ** For example, consider table t1(a,b,c,d,e,f) with index i1(a,b,c).\n    ** Suppose the WHERE clause is this:  a==5 AND b IN (1,2,3) AND c>5 AND c<10\n    ** The index has as many as three equality constraints, but in this\n    ** example, the third "c" value is an inequality.  So only two\n    ** constraints are coded.  This routine will generate code to evaluate\n    ** a==5 and b IN (1,2,3).  The current values for a and b will be stored\n    ** in consecutive registers and the index of the first register is returned.\n    **\n    ** In the example above nEq==2.  But this subroutine works for any value\n    ** of nEq including 0.  If nEq==null, this routine is nearly a no-op.\n    ** The only thing it does is allocate the pLevel.iMem memory cell.\n    **\n    ** This routine always allocates at least one memory cell and returns\n    ** the index of that memory cell. The code that\n    ** calls this routine will use that memory cell to store the termination\n    ** key value of the loop.  If one or more IN operators appear, then\n    ** this routine allocates an additional nEq memory cells for internal\n    ** use.\n    */\n    static int codeAllEqualityTerms(\n    Parse pParse,        /* Parsing context */\n    WhereLevel pLevel,   /* Which nested loop of the FROM we are coding */\n    WhereClause pWC,     /* The WHERE clause */\n    Bitmask notReady,     /* Which parts of FROM have not yet been coded */\n    int nExtraReg         /* Number of extra registers to allocate */\n    )\n    {\n      int nEq = (int)pLevel.plan.nEq;   /* The number of == or IN constraints to code */\n      Vdbe v = pParse.pVdbe;      /* The vm under construction */\n      Index pIdx;                  /* The index being used for this loop */\n      int iCur = pLevel.iTabCur;   /* The cursor of the table */\n      WhereTerm pTerm;             /* A single constraint term */\n      int j;                        /* Loop counter */\n      int regBase;                  /* Base register */\n      int nReg;                     /* Number of registers to allocate */\n\n      /* This module is only called on query plans that use an index. */\n      Debug.Assert( ( pLevel.plan.wsFlags & WHERE_INDEXED ) != 0 );\n      pIdx = pLevel.plan.u.pIdx;\n\n      /* Figure out how many memory cells we will need then allocate them.\n      */\n      regBase = pParse.nMem + 1;\n      nReg = (int)( pLevel.plan.nEq + nExtraReg );\n      pParse.nMem += nReg;\n\n      /* Evaluate the equality constraints\n      */\n      Debug.Assert( pIdx.nColumn >= nEq );\n      for ( j = 0 ; j < nEq ; j++ )\n      {\n        int r1;\n        int k = pIdx.aiColumn[j];\n        pTerm = findTerm( pWC, iCur, k, notReady, pLevel.plan.wsFlags, pIdx );\n        if ( NEVER( pTerm == null ) ) break;\n        Debug.Assert( ( pTerm.wtFlags & TERM_CODED ) == 0 );\n        r1 = codeEqualityTerm( pParse, pTerm, pLevel, regBase + j );\n        if ( r1 != regBase + j )\n        {\n          if ( nReg == 1 )\n          {\n            sqlite3ReleaseTempReg( pParse, regBase );\n            regBase = r1;\n          }\n          else\n          {\n            sqlite3VdbeAddOp2( v, OP_SCopy, r1, regBase + j );\n          }\n        }\n        testcase( pTerm.eOperator & WO_ISNULL );\n        testcase( pTerm.eOperator & WO_IN );\n        if ( ( pTerm.eOperator & ( WO_ISNULL | WO_IN ) ) == 0 )\n        {\n          sqlite3VdbeAddOp2( v, OP_IsNull, regBase + j, pLevel.addrBrk );\n        }\n      }\n      return regBase;\n    }\n\n    /*\n    ** Generate code for the start of the iLevel-th loop in the WHERE clause\n    ** implementation described by pWInfo.\n    */\n    static Bitmask codeOneLoopStart(\n    WhereInfo pWInfo,     /* Complete information about the WHERE clause */\n    int iLevel,           /* Which level of pWInfo.a[] should be coded */\n    u16 wctrlFlags,       /* One of the WHERE_* flags defined in sqliteInt.h */\n    Bitmask notReady      /* Which tables are currently available */\n    )\n    {\n      int j, k;                 /* Loop counters */\n      int iCur;                 /* The VDBE cursor for the table */\n      int addrNxt;              /* Where to jump to continue with the next IN case */\n      int omitTable;            /* True if we use the index only */\n      int bRev;                 /* True if we need to scan in reverse order */\n      WhereLevel pLevel;        /* The where level to be coded */\n      WhereClause pWC;          /* Decomposition of the entire WHERE clause */\n      WhereTerm pTerm;          /* A WHERE clause term */\n      Parse pParse;             /* Parsing context */\n      Vdbe v;                   /* The prepared stmt under constructions */\n      SrcList_item pTabItem;    /* FROM clause term being coded */\n      int addrBrk;              /* Jump here to break out of the loop */\n      int addrCont;             /* Jump here to continue with next cycle */\n      int iRowidReg = 0;        /* Rowid is stored in this register, if not zero */\n      int iReleaseReg = 0;      /* Temp register to free before returning */\n\n      pParse = pWInfo.pParse;\n      v = pParse.pVdbe;\n      pWC = pWInfo.pWC;\n      pLevel = pWInfo.a[iLevel];\n      pTabItem = pWInfo.pTabList.a[pLevel.iFrom];\n      iCur = pTabItem.iCursor;\n      bRev = ( pLevel.plan.wsFlags & WHERE_REVERSE ) != 0 ? 1 : 0;\n      omitTable = ( ( pLevel.plan.wsFlags & WHERE_IDX_ONLY ) != 0\n      && ( wctrlFlags & WHERE_FORCE_TABLE ) == 0 ) ? 1 : 0;\n\n      /* Create labels for the "break" and "continue" instructions\n      ** for the current loop.  Jump to addrBrk to break out of a loop.\n      ** Jump to cont to go immediately to the next iteration of the\n      ** loop.\n      **\n      ** When there is an IN operator, we also have a "addrNxt" label that\n      ** means to continue with the next IN value combination.  When\n      ** there are no IN operators in the constraints, the "addrNxt" label\n      ** is the same as "addrBrk".\n      */\n      addrBrk = pLevel.addrBrk = pLevel.addrNxt = sqlite3VdbeMakeLabel( v );\n      addrCont = pLevel.addrCont = sqlite3VdbeMakeLabel( v );\n\n      /* If this is the right table of a LEFT OUTER JOIN, allocate and\n      ** initialize a memory cell that records if this table matches any\n      ** row of the left table of the join.\n      */\n      if ( pLevel.iFrom > 0 && ( pTabItem.jointype & JT_LEFT ) != 0 )// Check value of pTabItem[0].jointype\n      {\n        pLevel.iLeftJoin = ++pParse.nMem;\n        sqlite3VdbeAddOp2( v, OP_Integer, 0, pLevel.iLeftJoin );\n#if SQLITE_DEBUG\n        VdbeComment( v, "init LEFT JOIN no-match flag" );\n#endif\n      }\n\n#if  !SQLITE_OMIT_VIRTUALTABLE\nif ( ( pLevel.plan.wsFlags & WHERE_VIRTUALTABLE ) != null )\n{\n/* Case 0:  The table is a virtual-table.  Use the VFilter and VNext\n**          to access the data.\n*/\nint iReg;   /* P3 Value for OP_VFilter */\nsqlite3_index_info pVtabIdx = pLevel.plan.u.pVtabIdx;\nint nConstraint = pVtabIdx.nConstraint;\nsqlite3_index_constraint_usage* aUsage =\npVtabIdx.aConstraintUsage;\nconst sqlite3_index_constraint* aConstraint =\npVtabIdx.aConstraint;\n\niReg = sqlite3GetTempRange( pParse, nConstraint + 2 );\nfor ( j = 1 ; j <= nConstraint ; j++ )\n{\nfor ( k = 0 ; k < nConstraint ; k++ )\n{\nif ( aUsage[k].argvIndex == j )\n{\nint iTerm = aConstraint[k].iTermOffset;\nsqlite3ExprCode( pParse, pWC.a[iTerm].pExpr.pRight, iReg + j + 1 );\nbreak;\n}\n}\nif ( k == nConstraint ) break;\n}\nsqlite3VdbeAddOp2( v, OP_Integer, pVtabIdx.idxNum, iReg );\nsqlite3VdbeAddOp2( v, OP_Integer, j - 1, iReg + 1 );\nsqlite3VdbeAddOp4( v, OP_VFilter, iCur, addrBrk, iReg, pVtabIdx.idxStr,\npVtabIdx.needToFreeIdxStr ? P4_MPRINTF : P4_STATIC );\npVtabIdx.needToFreeIdxStr = 0;\nfor ( j = 0 ; j < nConstraint ; j++ )\n{\nif ( aUsage[j].omit )\n{\nint iTerm = aConstraint[j].iTermOffset;\ndisableTerm( pLevel, &pWC.a[iTerm] );\n}\n}\npLevel.op = OP_VNext;\npLevel.p1 = iCur;\npLevel.p2 = sqlite3VdbeCurrentAddr( v );\nsqlite3ReleaseTempRange( pParse, iReg, nConstraint + 2 );\n}\nelse\n#endif //* SQLITE_OMIT_VIRTUALTABLE */\n\n      if ( ( pLevel.plan.wsFlags & WHERE_ROWID_EQ ) != 0 )\n      {\n        /* Case 1:  We can directly reference a single row using an\n        **          equality comparison against the ROWID field.  Or\n        **          we reference multiple rows using a "rowid IN (...)"\n        **          construct.\n        */\n        iReleaseReg = sqlite3GetTempReg( pParse );\n        pTerm = findTerm( pWC, iCur, -1, notReady, WO_EQ | WO_IN, null );\n        Debug.Assert( pTerm != null );\n        Debug.Assert( pTerm.pExpr != null );\n        Debug.Assert( pTerm.leftCursor == iCur );\n        Debug.Assert( omitTable == 0 );\n        iRowidReg = codeEqualityTerm( pParse, pTerm, pLevel, iReleaseReg );\n        addrNxt = pLevel.addrNxt;\n        sqlite3VdbeAddOp2( v, OP_MustBeInt, iRowidReg, addrNxt );\n        sqlite3VdbeAddOp3( v, OP_NotExists, iCur, addrNxt, iRowidReg );\n        sqlite3ExprCacheStore( pParse, iCur, -1, iRowidReg );\n#if SQLITE_DEBUG\n        VdbeComment( v, "pk" );\n#endif\n        pLevel.op = OP_Noop;\n      }\n      else if ( ( pLevel.plan.wsFlags & WHERE_ROWID_RANGE ) != 0 )\n      {\n        /* Case 2:  We have an inequality comparison against the ROWID field.\n        */\n        int testOp = OP_Noop;\n        int start;\n        int memEndValue = 0;\n        WhereTerm pStart, pEnd;\n\n        Debug.Assert( omitTable == 0 );\n        pStart = findTerm( pWC, iCur, -1, notReady, WO_GT | WO_GE, null );\n        pEnd = findTerm( pWC, iCur, -1, notReady, WO_LT | WO_LE, null );\n        if ( bRev != 0 )\n        {\n          pTerm = pStart;\n          pStart = pEnd;\n          pEnd = pTerm;\n        }\n        if ( pStart != null )\n        {\n          Expr pX;             /* The expression that defines the start bound */\n          int r1, rTemp = 0;        /* Registers for holding the start boundary */\n\n          /* The following constant maps TK_xx codes into corresponding\n          ** seek opcodes.  It depends on a particular ordering of TK_xx\n          */\n          u8[] aMoveOp = new u8[]{\n/* TK_GT */  OP_SeekGt,\n/* TK_LE */  OP_SeekLe,\n/* TK_LT */  OP_SeekLt,\n/* TK_GE */  OP_SeekGe\n};\n          Debug.Assert( TK_LE == TK_GT + 1 );      /* Make sure the ordering.. */\n          Debug.Assert( TK_LT == TK_GT + 2 );      /*  ... of the TK_xx values... */\n          Debug.Assert( TK_GE == TK_GT + 3 );      /*  ... is correcct. */\n\n          pX = pStart.pExpr;\n          Debug.Assert( pX != null );\n          Debug.Assert( pStart.leftCursor == iCur );\n          r1 = sqlite3ExprCodeTemp( pParse, pX.pRight, ref rTemp );\n          sqlite3VdbeAddOp3( v, aMoveOp[pX.op - TK_GT], iCur, addrBrk, r1 );\n#if SQLITE_DEBUG\n          VdbeComment( v, "pk" );\n#endif\n          sqlite3ExprCacheAffinityChange( pParse, r1, 1 );\n          sqlite3ReleaseTempReg( pParse, rTemp );\n          disableTerm( pLevel, pStart );\n        }\n        else\n        {\n          sqlite3VdbeAddOp2( v, bRev != 0 ? OP_Last : OP_Rewind, iCur, addrBrk );\n        }\n        if ( pEnd != null )\n        {\n          Expr pX;\n          pX = pEnd.pExpr;\n          Debug.Assert( pX != null );\n          Debug.Assert( pEnd.leftCursor == iCur );\n          memEndValue = ++pParse.nMem;\n          sqlite3ExprCode( pParse, pX.pRight, memEndValue );\n          if ( pX.op == TK_LT || pX.op == TK_GT )\n          {\n            testOp = bRev != 0 ? OP_Le : OP_Ge;\n          }\n          else\n          {\n            testOp = bRev != 0 ? OP_Lt : OP_Gt;\n          }\n          disableTerm( pLevel, pEnd );\n        }\n        start = sqlite3VdbeCurrentAddr( v );\n        pLevel.op = (u8)( bRev != 0 ? OP_Prev : OP_Next );\n        pLevel.p1 = iCur;\n        pLevel.p2 = start;\n        pLevel.p5 = (u8)( ( pStart == null && pEnd == null ) ? 1 : 0 );\n        if ( testOp != OP_Noop )\n        {\n          iRowidReg = iReleaseReg = sqlite3GetTempReg( pParse );\n          sqlite3VdbeAddOp2( v, OP_Rowid, iCur, iRowidReg );\n          sqlite3ExprCacheStore( pParse, iCur, -1, iRowidReg );\n          sqlite3VdbeAddOp3( v, testOp, memEndValue, addrBrk, iRowidReg );\n          sqlite3VdbeChangeP5( v, SQLITE_AFF_NUMERIC | SQLITE_JUMPIFNULL );\n        }\n      }\n      else if ( ( pLevel.plan.wsFlags & ( WHERE_COLUMN_RANGE | WHERE_COLUMN_EQ ) ) != 0 )\n      {\n        /* Case 3: A scan using an index.\n        **\n        **         The WHERE clause may contain zero or more equality\n        **         terms ("==" or "IN" operators) that refer to the N\n        **         left-most columns of the index. It may also contain\n        **         inequality constraints (>, <, >= or <=) on the indexed\n        **         column that immediately follows the N equalities. Only\n        **         the right-most column can be an inequality - the rest must\n        **         use the "==" and "IN" operators. For example, if the\n        **         index is on (x,y,z), then the following clauses are all\n        **         optimized:\n        **\n        **            x=5\n        **            x=5 AND y=10\n        **            x=5 AND y<10\n        **            x=5 AND y>5 AND y<10\n        **            x=5 AND y=5 AND z<=10\n        **\n        **         The z<10 term of the following cannot be used, only\n        **         the x=5 term:\n        **\n        **            x=5 AND z<10\n        **\n        **         N may be zero if there are inequality constraints.\n        **         If there are no inequality constraints, then N is at\n        **         least one.\n        **\n        **         This case is also used when there are no WHERE clause\n        **         constraints but an index is selected anyway, in order\n        **         to force the output order to conform to an ORDER BY.\n        */\n        int[] aStartOp = new int[]  {\n0,\n0,\nOP_Rewind,           /* 2: (!start_constraints && startEq &&  !bRev) */\nOP_Last,             /* 3: (!start_constraints && startEq &&   bRev) */\nOP_SeekGt,           /* 4: (start_constraints  && !startEq && !bRev) */\nOP_SeekLt,           /* 5: (start_constraints  && !startEq &&  bRev) */\nOP_SeekGe,           /* 6: (start_constraints  &&  startEq && !bRev) */\nOP_SeekLe            /* 7: (start_constraints  &&  startEq &&  bRev) */\n};\n        int[] aEndOp = new int[]  {\nOP_Noop,             /* 0: (!end_constraints) */\nOP_IdxGE,            /* 1: (end_constraints && !bRev) */\nOP_IdxLT             /* 2: (end_constraints && bRev) */\n};\n        int nEq = (int)pLevel.plan.nEq;\n        int isMinQuery = 0;          /* If this is an optimized SELECT min(x).. */\n        int regBase;                 /* Base register holding constraint values */\n        int r1;                      /* Temp register */\n        WhereTerm pRangeStart = null;  /* Inequality constraint at range start */\n        WhereTerm pRangeEnd = null;    /* Inequality constraint at range end */\n        int startEq;                 /* True if range start uses ==, >= or <= */\n        int endEq;                   /* True if range end uses ==, >= or <= */\n        int start_constraints;       /* Start of range is constrained */\n        int nConstraint;             /* Number of constraint terms */\n        Index pIdx;         /* The index we will be using */\n        int iIdxCur;         /* The VDBE cursor for the index */\n        int nExtraReg = 0;   /* Number of extra registers needed */\n        int op;              /* Instruction opcode */\n\n        pIdx = pLevel.plan.u.pIdx;\n        iIdxCur = pLevel.iIdxCur;\n        k = pIdx.aiColumn[nEq];     /* Column for inequality constraints */\n\n        /* If this loop satisfies a sort order (pOrderBy) request that\n        ** was pDebug.Assed to this function to implement a "SELECT min(x) ..."\n        ** query, then the caller will only allow the loop to run for\n        ** a single iteration. This means that the first row returned\n        ** should not have a NULL value stored in \'x\'. If column \'x\' is\n        ** the first one after the nEq equality constraints in the index,\n        ** this requires some special handling.\n        */\n        if ( ( wctrlFlags & WHERE_ORDERBY_MIN ) != 0\n        && ( ( pLevel.plan.wsFlags & WHERE_ORDERBY ) != 0 )\n        && ( pIdx.nColumn > nEq )\n        )\n        {\n          /* Debug.Assert( pOrderBy.nExpr==1 ); */\n          /* Debug.Assert( pOrderBy.a[0].pExpr.iColumn==pIdx.aiColumn[nEq] ); */\n          isMinQuery = 1;\n          nExtraReg = 1;\n        }\n\n        /* Find any inequality constraint terms for the start and end\n        ** of the range.\n        */\n        if ( ( pLevel.plan.wsFlags & WHERE_TOP_LIMIT ) != 0 )\n        {\n          pRangeEnd = findTerm( pWC, iCur, k, notReady, ( WO_LT | WO_LE ), pIdx );\n          nExtraReg = 1;\n        }\n        if ( ( pLevel.plan.wsFlags & WHERE_BTM_LIMIT ) != 0 )\n        {\n          pRangeStart = findTerm( pWC, iCur, k, notReady, ( WO_GT | WO_GE ), pIdx );\n          nExtraReg = 1;\n        }\n\n        /* Generate code to evaluate all constraint terms using == or IN\n        ** and store the values of those terms in an array of registers\n        ** starting at regBase.\n        */\n        regBase = codeAllEqualityTerms( pParse, pLevel, pWC, notReady, nExtraReg );\n        addrNxt = pLevel.addrNxt;\n\n\n        /* If we are doing a reverse order scan on an ascending index, or\n        ** a forward order scan on a descending index, interchange the\n        ** start and end terms (pRangeStart and pRangeEnd).\n        */\n        if ( bRev == ( ( pIdx.aSortOrder[nEq] == SQLITE_SO_ASC ) ? 1 : 0 ) )\n        {\n          SWAP( ref pRangeEnd, ref pRangeStart );\n        }\n\n        testcase( pRangeStart != null && ( pRangeStart.eOperator & WO_LE ) != 0 );\n        testcase( pRangeStart != null && ( pRangeStart.eOperator & WO_GE ) != 0 );\n        testcase( pRangeEnd != null && ( pRangeEnd.eOperator & WO_LE ) != 0 );\n        testcase( pRangeEnd != null && ( pRangeEnd.eOperator & WO_GE ) != 0 );\n        startEq = ( null == pRangeStart || ( pRangeStart.eOperator & ( WO_LE | WO_GE ) ) != 0 ) ? 1 : 0;\n        endEq = ( null == pRangeEnd || ( pRangeEnd.eOperator & ( WO_LE | WO_GE ) ) != 0 ) ? 1 : 0;\n        start_constraints = ( pRangeStart != null || nEq > 0 ) ? 1 : 0;\n\n        /* Seek the index cursor to the start of the range. */\n        nConstraint = nEq;\n        if ( pRangeStart != null )\n        {\n          sqlite3ExprCode( pParse, pRangeStart.pExpr.pRight, regBase + nEq );\n          sqlite3VdbeAddOp2( v, OP_IsNull, regBase + nEq, addrNxt );\n          nConstraint++;\n        }\n        else if ( isMinQuery != 0 )\n        {\n          sqlite3VdbeAddOp2( v, OP_Null, 0, regBase + nEq );\n          nConstraint++;\n          startEq = 0;\n          start_constraints = 1;\n        }\n        codeApplyAffinity( pParse, regBase, nConstraint, pIdx );\n        op = aStartOp[( start_constraints << 2 ) + ( startEq << 1 ) + bRev];\n        Debug.Assert( op != 0 );\n        testcase( op == OP_Rewind );\n        testcase( op == OP_Last );\n        testcase( op == OP_SeekGt );\n        testcase( op == OP_SeekGe );\n        testcase( op == OP_SeekLe );\n        testcase( op == OP_SeekLt );\n        sqlite3VdbeAddOp4( v, op, iIdxCur, addrNxt, regBase,\n        ( nConstraint ), P4_INT32 );//    SQLITE_INT_TO_PTR(nConstraint)\n\n        /* Load the value for the inequality constraint at the end of the\n        ** range (if any).\n        */\n        nConstraint = nEq;\n        if ( pRangeEnd != null )\n        {\n          sqlite3ExprCacheRemove( pParse, regBase + nEq );\n          sqlite3ExprCode( pParse, pRangeEnd.pExpr.pRight, regBase + nEq );\n          sqlite3VdbeAddOp2( v, OP_IsNull, regBase + nEq, addrNxt );\n          codeApplyAffinity( pParse, regBase, nEq + 1, pIdx );\n          nConstraint++;\n        }\n\n        /* Top of the loop body */\n        pLevel.p2 = sqlite3VdbeCurrentAddr( v );\n\n        /* Check if the index cursor is past the end of the range. */\n        op = aEndOp[( ( pRangeEnd != null || nEq != 0 ) ? 1 : 0 ) * ( 1 + bRev )];\n        testcase( op == OP_Noop );\n        testcase( op == OP_IdxGE );\n        testcase( op == OP_IdxLT );\n        if ( op != OP_Noop )\n        {\n          sqlite3VdbeAddOp4( v, op, iIdxCur, addrNxt, regBase,\n          ( nConstraint ), P4_INT32 );//    SQLITE_INT_TO_PTR(nConstraint)\n          sqlite3VdbeChangeP5( v, (u8)( endEq != bRev ? 1 : 0 ) );\n        }\n\n        /* If there are inequality constraints, check that the value\n        ** of the table column that the inequality contrains is not NULL.\n        ** If it is, jump to the next iteration of the loop.\n        */\n        r1 = sqlite3GetTempReg( pParse );\n        testcase( pLevel.plan.wsFlags & WHERE_BTM_LIMIT );\n        testcase( pLevel.plan.wsFlags & WHERE_TOP_LIMIT );\n        if ( ( pLevel.plan.wsFlags & ( WHERE_BTM_LIMIT | WHERE_TOP_LIMIT ) ) != 0 )\n        {\n          sqlite3VdbeAddOp3( v, OP_Column, iIdxCur, nEq, r1 );\n          sqlite3VdbeAddOp2( v, OP_IsNull, r1, addrCont );\n        }\n        sqlite3ReleaseTempReg( pParse, r1 );\n\n        /* Seek the table cursor, if required */\n        disableTerm( pLevel, pRangeStart );\n        disableTerm( pLevel, pRangeEnd );\n        if ( 0 == omitTable )\n        {\n          iRowidReg = iReleaseReg = sqlite3GetTempReg( pParse );\n          sqlite3VdbeAddOp2( v, OP_IdxRowid, iIdxCur, iRowidReg );\n          sqlite3ExprCacheStore( pParse, iCur, -1, iRowidReg );\n          sqlite3VdbeAddOp2( v, OP_Seek, iCur, iRowidReg );  /* Deferred seek */\n        }\n\n        /* Record the instruction used to terminate the loop. Disable\n        ** WHERE clause terms made redundant by the index range scan.\n        */\n        pLevel.op = (u8)( bRev != 0 ? OP_Prev : OP_Next );\n        pLevel.p1 = iIdxCur;\n      }\n      else\n\n#if  !SQLITE_OMIT_OR_OPTIMIZATION\n        if ( ( pLevel.plan.wsFlags & WHERE_MULTI_OR ) != 0 )\n        {\n          /* Case 4:  Two or more separately indexed terms connected by OR\n          **\n          ** Example:\n          **\n          **   CREATE TABLE t1(a,b,c,d);\n          **   CREATE INDEX i1 ON t1(a);\n          **   CREATE INDEX i2 ON t1(b);\n          **   CREATE INDEX i3 ON t1(c);\n          **\n          **   SELECT * FROM t1 WHERE a=5 OR b=7 OR (c=11 AND d=13)\n          **\n          ** In the example, there are three indexed terms connected by OR.\n          ** The top of the loop looks like this:\n          **\n          **          Null       1                # Zero the rowset in reg 1\n          **\n          ** Then, for each indexed term, the following. The arguments to\n          ** RowSetTest are such that the rowid of the current row is inserted\n          ** into the RowSet. If it is already present, control skips the\n          ** Gosub opcode and jumps straight to the code generated by WhereEnd().\n          **\n          **        sqlite3WhereBegin(<term>)\n          **          RowSetTest                  # Insert rowid into rowset\n          **          Gosub      2 A\n          **        sqlite3WhereEnd()\n          **\n          ** Following the above, code to terminate the loop. Label A, the target\n          ** of the Gosub above, jumps to the instruction right after the Goto.\n          **\n          **          Null       1                # Zero the rowset in reg 1\n          **          Goto       B                # The loop is finished.\n          **\n          **       A: <loop body>                 # Return data, whatever.\n          **\n          **          Return     2                # Jump back to the Gosub\n          **\n          **       B: <after the loop>\n          **\n          */\n          WhereClause pOrWc;    /* The OR-clause broken out into subterms */\n          WhereTerm pFinal;    /* Final subterm within the OR-clause. */\n          SrcList oneTab = new SrcList();        /* Shortened table list */\n\n          int regReturn = ++pParse.nMem;           /* Register used with OP_Gosub */\n          int regRowset = 0;                       /* Register for RowSet object */\n          int regRowid = 0;                        /* Register holding rowid */\n          int iLoopBody = sqlite3VdbeMakeLabel( v );  /* Start of loop body */\n          int iRetInit;                             /* Address of regReturn init */\n          int ii;\n          pTerm = pLevel.plan.u.pTerm;\n          Debug.Assert( pTerm != null );\n          Debug.Assert( pTerm.eOperator == WO_OR );\n          Debug.Assert( ( pTerm.wtFlags & TERM_ORINFO ) != 0 );\n          pOrWc = pTerm.u.pOrInfo.wc;\n          pFinal = pOrWc.a[pOrWc.nTerm - 1];\n          /* Set up a SrcList containing just the table being scanned by this loop. */\n          oneTab.nSrc = 1;\n          oneTab.nAlloc = 1;\n          oneTab.a = new SrcList_item[1];\n          oneTab.a[0] = pTabItem;\n          /* Initialize the rowset register to contain NULL. An SQL NULL is\n          ** equivalent to an empty rowset.\n          **\n          ** Also initialize regReturn to contain the address of the instruction\n          ** immediately following the OP_Return at the bottom of the loop. This\n          ** is required in a few obscure LEFT JOIN cases where control jumps\n          ** over the top of the loop into the body of it. In this case the\n          ** correct response for the end-of-loop code (the OP_Return) is to\n          ** fall through to the next instruction, just as an OP_Next does if\n          ** called on an uninitialized cursor.\n          */\n          if ( ( wctrlFlags & WHERE_DUPLICATES_OK ) == 0 )\n          {\n            regRowset = ++pParse.nMem;\n            regRowid = ++pParse.nMem;\n            sqlite3VdbeAddOp2( v, OP_Null, 0, regRowset );\n          }\n          iRetInit = sqlite3VdbeAddOp2( v, OP_Integer, 0, regReturn );\n\n          for ( ii = 0 ; ii < pOrWc.nTerm ; ii++ )\n          {\n            WhereTerm pOrTerm = pOrWc.a[ii];\n            if ( pOrTerm.leftCursor == iCur || pOrTerm.eOperator == WO_AND )\n            {\n              WhereInfo pSubWInfo;          /* Info for single OR-term scan */\n\n              /* Loop through table entries that match term pOrTerm. */\n              ExprList elDummy = null;\n              pSubWInfo = sqlite3WhereBegin( pParse, oneTab, pOrTerm.pExpr, ref elDummy,\n              WHERE_OMIT_OPEN | WHERE_OMIT_CLOSE | WHERE_FORCE_TABLE );\n              if ( pSubWInfo != null )\n              {\n                if ( ( wctrlFlags & WHERE_DUPLICATES_OK ) == 0 )\n                {\n                  int iSet = ( ( ii == pOrWc.nTerm - 1 ) ? -1 : ii );\n                  int r;\n                  r = sqlite3ExprCodeGetColumn( pParse, pTabItem.pTab, -1, iCur,\n                  regRowid, false );\n                  sqlite3VdbeAddOp4( v, OP_RowSetTest, regRowset,\n                  sqlite3VdbeCurrentAddr( v ) + 2,\n                  r, iSet, P4_INT32 );//SQLITE_INT_TO_PTR(iSet), P4_INT32);\n                }\n                sqlite3VdbeAddOp2( v, OP_Gosub, regReturn, iLoopBody );\n\n                /* Finish the loop through table entries that match term pOrTerm. */\n                sqlite3WhereEnd( pSubWInfo );\n              }\n            }\n          }\n          sqlite3VdbeChangeP1( v, iRetInit, sqlite3VdbeCurrentAddr( v ) );\n          /* sqlite3VdbeAddOp2(v, OP_Null, 0, regRowset); */\n          sqlite3VdbeAddOp2( v, OP_Goto, 0, pLevel.addrBrk );\n          sqlite3VdbeResolveLabel( v, iLoopBody );\n\n          pLevel.op = OP_Return;\n          pLevel.p1 = regReturn;\n          disableTerm( pLevel, pTerm );\n        }\n        else\n#endif //* SQLITE_OMIT_OR_OPTIMIZATION */\n\n        {\n          /* Case 5:  There is no usable index.  We must do a complete\n          **          scan of the entire table.\n          */\n          u8[] aStep = new u8[] { OP_Next, OP_Prev };\n          u8[] aStart = new u8[] { OP_Rewind, OP_Last };\n          Debug.Assert( bRev == 0 || bRev == 1 );\n          Debug.Assert( omitTable == 0 );\n          pLevel.op = aStep[bRev];\n          pLevel.p1 = iCur;\n          pLevel.p2 = 1 + sqlite3VdbeAddOp2( v, aStart[bRev], iCur, addrBrk );\n          pLevel.p5 = SQLITE_STMTSTATUS_FULLSCAN_STEP;\n        }\n      notReady &= ~getMask( pWC.pMaskSet, iCur );\n\n      /* Insert code to test every subexpression that can be completely\n      ** computed using the current set of tables.\n      */\n      k = 0;\n      for ( j = pWC.nTerm ; j > 0 ; j-- )//, pTerm++)\n      {\n        pTerm = pWC.a[pWC.nTerm - j];\n        Expr pE;\n        testcase( pTerm.wtFlags & TERM_VIRTUAL );\n        testcase( pTerm.wtFlags & TERM_CODED );\n        if ( ( pTerm.wtFlags & ( TERM_VIRTUAL | TERM_CODED ) ) != 0 ) continue;\n        if ( ( pTerm.prereqAll & notReady ) != 0 ) continue;\n        pE = pTerm.pExpr;\n        Debug.Assert( pE != null );\n        if ( pLevel.iLeftJoin != 0 && !( ( pE.flags & EP_FromJoin ) == EP_FromJoin ) )// !ExprHasProperty(pE, EP_FromJoin) ){\n        {\n          continue;\n        }\n        sqlite3ExprIfFalse( pParse, pE, addrCont, SQLITE_JUMPIFNULL );\n        k = 1;\n        pTerm.wtFlags |= TERM_CODED;\n      }\n\n      /* For a LEFT OUTER JOIN, generate code that will record the fact that\n      ** at least one row of the right table has matched the left table.\n      */\n      if ( pLevel.iLeftJoin != 0 )\n      {\n        pLevel.addrFirst = sqlite3VdbeCurrentAddr( v );\n        sqlite3VdbeAddOp2( v, OP_Integer, 1, pLevel.iLeftJoin );\n#if SQLITE_DEBUG\n        VdbeComment( v, "record LEFT JOIN hit" );\n#endif\n        sqlite3ExprCacheClear( pParse );\n        for ( j = 0 ; j < pWC.nTerm ; j++ )//, pTerm++)\n        {\n          pTerm = pWC.a[j];\n          testcase( pTerm.wtFlags & TERM_VIRTUAL );\n          testcase( pTerm.wtFlags & TERM_CODED );\n          if ( ( pTerm.wtFlags & ( TERM_VIRTUAL | TERM_CODED ) ) != 0 ) continue;\n          if ( ( pTerm.prereqAll & notReady ) != 0 ) continue;\n          Debug.Assert( pTerm.pExpr != null );\n          sqlite3ExprIfFalse( pParse, pTerm.pExpr, addrCont, SQLITE_JUMPIFNULL );\n          pTerm.wtFlags |= TERM_CODED;\n        }\n      }\n\n      sqlite3ReleaseTempReg( pParse, iReleaseReg );\n      return notReady;\n    }\n\n#if  (SQLITE_TEST)\n    /*\n** The following variable holds a text description of query plan generated\n** by the most recent call to sqlite3WhereBegin().  Each call to WhereBegin\n** overwrites the previous.  This information is used for testing and\n** analysis only.\n*/\n    //char sqlite3_query_plan[BMS*2*40];  /* Text of the join */\n    static int nQPlan = 0;              /* Next free slow in _query_plan[] */\n\n#endif //* SQLITE_TEST */\n\n\n    /*\n** Free a WhereInfo structure\n*/\n    static void whereInfoFree( sqlite3 db, WhereInfo pWInfo )\n    {\n      if ( pWInfo != null )\n      {\n        int i;\n        for ( i = 0 ; i < pWInfo.nLevel ; i++ )\n        {\n          sqlite3_index_info pInfo = pWInfo.a[i].pIdxInfo;\n          if ( pInfo != null )\n          {\n            /* Debug.Assert( pInfo.needToFreeIdxStr==0 || db.mallocFailed ); */\n            if ( pInfo.needToFreeIdxStr != 0 )\n            {\n              //sqlite3_free( ref pInfo.idxStr );\n            }\n            //sqlite3DbFree( db, pInfo );\n          }\n        }\n        whereClauseClear( pWInfo.pWC );\n        //sqlite3DbFree( db, pWInfo );\n      }\n    }\n\n\n    /*\n    ** Generate the beginning of the loop used for WHERE clause processing.\n    ** The return value is a pointer to an opaque structure that contains\n    ** information needed to terminate the loop.  Later, the calling routine\n    ** should invoke sqlite3WhereEnd() with the return value of this function\n    ** in order to complete the WHERE clause processing.\n    **\n    ** If an error occurs, this routine returns NULL.\n    **\n    ** The basic idea is to do a nested loop, one loop for each table in\n    ** the FROM clause of a select.  (INSERT and UPDATE statements are the\n    ** same as a SELECT with only a single table in the FROM clause.)  For\n    ** example, if the SQL is this:\n    **\n    **       SELECT * FROM t1, t2, t3 WHERE ...;\n    **\n    ** Then the code generated is conceptually like the following:\n    **\n    **      foreach row1 in t1 do       \\    Code generated\n    **        foreach row2 in t2 do      |-- by sqlite3WhereBegin()\n    **          foreach row3 in t3 do   /\n    **            ...\n    **          end                     \\    Code generated\n    **        end                        |-- by sqlite3WhereEnd()\n    **      end                         /\n    **\n    ** Note that the loops might not be nested in the order in which they\n    ** appear in the FROM clause if a different order is better able to make\n    ** use of indices.  Note also that when the IN operator appears in\n    ** the WHERE clause, it might result in additional nested loops for\n    ** scanning through all values on the right-hand side of the IN.\n    **\n    ** There are Btree cursors Debug.Associated with each table.  t1 uses cursor\n    ** number pTabList.a[0].iCursor.  t2 uses the cursor pTabList.a[1].iCursor.\n    ** And so forth.  This routine generates code to open those VDBE cursors\n    ** and sqlite3WhereEnd() generates the code to close them.\n    **\n    ** The code that sqlite3WhereBegin() generates leaves the cursors named\n    ** in pTabList pointing at their appropriate entries.  The [...] code\n    ** can use OP_Column and OP_Rowid opcodes on these cursors to extract\n    ** data from the various tables of the loop.\n    **\n    ** If the WHERE clause is empty, the foreach loops must each scan their\n    ** entire tables.  Thus a three-way join is an O(N^3) operation.  But if\n    ** the tables have indices and there are terms in the WHERE clause that\n    ** refer to those indices, a complete table scan can be avoided and the\n    ** code will run much faster.  Most of the work of this routine is checking\n    ** to see if there are indices that can be used to speed up the loop.\n    **\n    ** Terms of the WHERE clause are also used to limit which rows actually\n    ** make it to the "..." in the middle of the loop.  After each "foreach",\n    ** terms of the WHERE clause that use only terms in that loop and outer\n    ** loops are evaluated and if false a jump is made around all subsequent\n    ** inner loops (or around the "..." if the test occurs within the inner-\n    ** most loop)\n    **\n    ** OUTER JOINS\n    **\n    ** An outer join of tables t1 and t2 is conceptally coded as follows:\n    **\n    **    foreach row1 in t1 do\n    **      flag = 0\n    **      foreach row2 in t2 do\n    **        start:\n    **          ...\n    **          flag = 1\n    **      end\n    **      if flag==null then\n    **        move the row2 cursor to a null row\n    **        goto start\n    **      fi\n    **    end\n    **\n    ** ORDER BY CLAUSE PROCESSING\n    **\n    ** ppOrderBy is a pointer to the ORDER BY clause of a SELECT statement,\n    ** if there is one.  If there is no ORDER BY clause or if this routine\n    ** is called from an UPDATE or DELETE statement, then ppOrderBy is NULL.\n    **\n    ** If an index can be used so that the natural output order of the table\n    ** scan is correct for the ORDER BY clause, then that index is used and\n    ** ppOrderBy is set to NULL.  This is an optimization that prevents an\n    ** unnecessary sort of the result set if an index appropriate for the\n    ** ORDER BY clause already exists.\n    **\n    ** If the where clause loops cannot be arranged to provide the correct\n    ** output order, then the ppOrderBy is unchanged.\n    */\n    static WhereInfo sqlite3WhereBegin(\n    Parse pParse,           /* The parser context */\n    SrcList pTabList,       /* A list of all tables to be scanned */\n    Expr pWhere,            /* The WHERE clause */\n    ref ExprList ppOrderBy, /* An ORDER BY clause, or NULL */\n    u16 wctrlFlags          /* One of the WHERE_* flags defined in sqliteInt.h */\n    )\n    {\n      int i;                     /* Loop counter */\n      int nByteWInfo;            /* Num. bytes allocated for WhereInfo struct */\n      WhereInfo pWInfo;          /* Will become the return value of this function */\n      Vdbe v = pParse.pVdbe;     /* The virtual data_base engine */\n      Bitmask notReady;          /* Cursors that are not yet positioned */\n      WhereMaskSet pMaskSet;     /* The expression mask set */\n      WhereClause pWC = new WhereClause();               /* Decomposition of the WHERE clause */\n      SrcList_item pTabItem;     /* A single entry from pTabList */\n      WhereLevel pLevel;         /* A single level in the pWInfo list */\n      int iFrom;                 /* First unused FROM clause element */\n      int andFlags;              /* AND-ed combination of all pWC.a[].wtFlags */\n      sqlite3 db;                /* Data_base connection */\n\n      /* The number of tables in the FROM clause is limited by the number of\n      ** bits in a Bitmask\n      */\n      if ( pTabList.nSrc > BMS )\n      {\n        sqlite3ErrorMsg( pParse, "at most %d tables in a join", BMS );\n        return null;\n      }\n\n      /* Allocate and initialize the WhereInfo structure that will become the\n      ** return value. A single allocation is used to store the WhereInfo\n      ** struct, the contents of WhereInfo.a[], the WhereClause structure\n      ** and the WhereMaskSet structure. Since WhereClause contains an 8-byte\n      ** field (type Bitmask) it must be aligned on an 8-byte boundary on\n      ** some architectures. Hence the ROUND8() below.\n      */\n      db = pParse.db;\n      pWInfo = new WhereInfo();\n      //nByteWInfo = ROUND8( sizeof( WhereInfo ) + ( pTabList.nSrc - 1 ) * sizeof( WhereLevel ) );\n      //pWInfo = sqlite3DbMallocZero( db,\n      //    nByteWInfo +\n      //    sizeof( WhereClause ) +\n      //    sizeof( WhereMaskSet )\n      //);\n      pWInfo.a = new WhereLevel[pTabList.nSrc];\n      //if ( db.mallocFailed != 0 )\n      //{\n      //  goto whereBeginError;\n      //}\n      pWInfo.nLevel = pTabList.nSrc;\n      pWInfo.pParse = pParse;\n      pWInfo.pTabList = pTabList;\n      pWInfo.iBreak = sqlite3VdbeMakeLabel( v );\n      pWInfo.pWC = pWC = new WhereClause();// (WhereClause )((u8 )pWInfo)[nByteWInfo];\n      pWInfo.wctrlFlags = wctrlFlags;\n      //pMaskSet = (WhereMaskSet)pWC[1];\n\n      /* Split the WHERE clause into separate subexpressions where each\n      ** subexpression is separated by an AND operator.\n      */\n      pMaskSet = new WhereMaskSet();//initMaskSet(pMaskSet);\n      whereClauseInit( pWC, pParse, pMaskSet );\n      sqlite3ExprCodeConstants( pParse, pWhere );\n      whereSplit( pWC, pWhere, TK_AND );\n\n      /* Special case: a WHERE clause that is constant.  Evaluate the\n      ** expression and either jump over all of the code or fall thru.\n      */\n      if ( pWhere != null && ( pTabList.nSrc == 0 || sqlite3ExprIsConstantNotJoin( pWhere ) != 0 ) )\n      {\n        sqlite3ExprIfFalse( pParse, pWhere, pWInfo.iBreak, SQLITE_JUMPIFNULL );\n        pWhere = null;\n      }\n\n      /* Assign a bit from the bitmask to every term in the FROM clause.\n      **\n      ** When assigning bitmask values to FROM clause cursors, it must be\n      ** the case that if X is the bitmask for the N-th FROM clause term then\n      ** the bitmask for all FROM clause terms to the left of the N-th term\n      ** is (X-1).   An expression from the ON clause of a LEFT JOIN can use\n      ** its Expr.iRightJoinTable value to find the bitmask of the right table\n      ** of the join.  Subtracting one from the right table bitmask gives a\n      ** bitmask for all tables to the left of the join.  Knowing the bitmask\n      ** for all tables to the left of a left join is important.  Ticket #3015.\n      **\n      ** Configure the WhereClause.vmask variable so that bits that correspond\n      ** to virtual table cursors are set. This is used to selectively disable\n      ** the OR-to-IN transformation in exprAnalyzeOrTerm(). It is not helpful\n      ** with virtual tables.\n      */\n      Debug.Assert( pWC.vmask == 0 && pMaskSet.n == 0 );\n      for ( i = 0 ; i < pTabList.nSrc ; i++ )\n      {\n        createMask( pMaskSet, pTabList.a[i].iCursor );\n#if !SQLITE_OMIT_VIRTUALTABLE\nif ( ALWAYS( pTabList.a[i].pTab ) && IsVirtual( pTabList.a[i].pTab ) )\n{\npWC.vmask |= ( (Bitmask)1 << i );\n}\n#endif\n      }\n#if  !NDEBUG\n      {\n        Bitmask toTheLeft = 0;\n        for ( i = 0 ; i < pTabList.nSrc ; i++ )\n        {\n          Bitmask m = getMask( pMaskSet, pTabList.a[i].iCursor );\n          Debug.Assert( ( m - 1 ) == toTheLeft );\n          toTheLeft |= m;\n        }\n      }\n#endif\n\n      /* Analyze all of the subexpressions.  Note that exprAnalyze() might\n** add new virtual terms onto the end of the WHERE clause.  We do not\n** want to analyze these virtual terms, so start analyzing at the end\n** and work forward so that the added virtual terms are never processed.\n*/\n      exprAnalyzeAll( pTabList, pWC );\n      //if ( db.mallocFailed != 0 )\n      //{\n      //  goto whereBeginError;\n      //}\n\n      /* Chose the best index to use for each table in the FROM clause.\n      **\n      ** This loop fills in the following fields:\n      **\n      **   pWInfo.a[].pIdx      The index to use for this level of the loop.\n      **   pWInfo.a[].wsFlags   WHERE_xxx flags Debug.Associated with pIdx\n      **   pWInfo.a[].nEq       The number of == and IN constraints\n      **   pWInfo.a[].iFrom     Which term of the FROM clause is being coded\n      **   pWInfo.a[].iTabCur   The VDBE cursor for the data_base table\n      **   pWInfo.a[].iIdxCur   The VDBE cursor for the index\n      **   pWInfo.a[].pTerm     When wsFlags==WO_OR, the OR-clause term\n      **\n      ** This loop also figures out the nesting order of tables in the FROM\n      ** clause.\n      */\n      notReady = ~(Bitmask)0;\n      pTabItem = pTabList.a != null ? pTabList.a[0] : null; //pTabItem = pTabList.a;\n      //pLevel = pWInfo.a;\n      andFlags = ~0;\n#if (SQLITE_TEST) && (SQLITE_DEBUG)\n      WHERETRACE( "*** Optimizer Start ***\\n" );\n#endif\n      for ( i = iFrom = 0 ; i < pTabList.nSrc ; i++ )//, pLevel++ )\n      {\n        pWInfo.a[i] = new WhereLevel();\n        pLevel = pWInfo.a[i];\n        WhereCost bestPlan;         /* Most efficient plan seen so far */\n        Index pIdx;                /* Index for FROM table at pTabItem */\n        int j;                      /* For looping over FROM tables */\n        int bestJ = 0;              /* The value of j */\n        Bitmask m;                  /* Bitmask value for j or bestJ */\n        int once = 0;               /* True when first table is seen */\n\n        bestPlan = new WhereCost();// memset( &bestPlan, 0, sizeof( bestPlan ) );\n        bestPlan.rCost = SQLITE_BIG_DBL;\n        for ( j = iFrom ; j < pTabList.nSrc ; j++ )//, pTabItem++)\n        {\n          pTabItem = pTabList.a[j];\n          int doNotReorder;       /* True if this table should not be reordered */\n          WhereCost sCost = null; /* Cost information from best[Virtual]Index() */\n          ExprList pOrderBy;      /* ORDER BY clause for index to optimize */\n\n          doNotReorder = ( pTabItem.jointype & ( JT_LEFT | JT_CROSS ) ) != 0 ? 1 : 0;\n          if ( ( once != 0 && doNotReorder != 0 ) ) break;\n          m = getMask( pMaskSet, pTabItem.iCursor );\n          if ( ( m & notReady ) == 0 )\n          {\n            if ( j == iFrom ) iFrom++;\n            continue;\n          }\n          pOrderBy = ( ( i == 0 && ppOrderBy != null ) ? ppOrderBy : null );\n          Debug.Assert( pTabItem.pTab != null );\n#if  !SQLITE_OMIT_VIRTUALTABLE\nif( IsVirtual(pTabItem.pTab) ){\nsqlite3_index_info **pp = &pWInfo.a[j].pIdxInfo;\nbestVirtualIndex(pParse, pWC, pTabItem, notReady, pOrderBy, &sCost, pp);\n}else\n#endif\n          {\n            bestBtreeIndex( pParse, pWC, pTabItem, notReady, pOrderBy, ref sCost );\n          }\n          if ( once == 0 || sCost.rCost < bestPlan.rCost )\n          {\n            once = 1;\n            bestPlan = sCost;\n            bestJ = j;\n          }\n          if ( doNotReorder != 0 ) break;\n        }\n        Debug.Assert( once != 0 );\n        Debug.Assert( ( notReady & getMask( pMaskSet, pTabList.a[bestJ].iCursor ) ) != 0 );\n#if (SQLITE_TEST) && (SQLITE_DEBUG)\n        WHERETRACE( "*** Optimizer selects table %d for loop %d\\n", bestJ,\n        i );//pLevel - pWInfo.a );\n#endif\n        if ( ( bestPlan.plan.wsFlags & WHERE_ORDERBY ) != 0 )\n        {\n          ppOrderBy = null;\n        }\n        andFlags = (int)( andFlags & bestPlan.plan.wsFlags );\n        pLevel.plan = bestPlan.plan;\n        if ( ( bestPlan.plan.wsFlags & WHERE_INDEXED ) != 0 )\n        {\n          pLevel.iIdxCur = pParse.nTab++;\n        }\n        else\n        {\n          pLevel.iIdxCur = -1;\n        }\n        notReady &= ~getMask( pMaskSet, pTabList.a[bestJ].iCursor );\n        pLevel.iFrom = (u8)bestJ;\n\n        /* Check that if the table scanned by this loop iteration had an\n        ** INDEXED BY clause attached to it, that the named index is being\n        ** used for the scan. If not, then query compilation has failed.\n        ** Return an error.\n        */\n        pIdx = pTabList.a[bestJ].pIndex;\n        if ( pIdx != null )\n        {\n          if ( ( bestPlan.plan.wsFlags & WHERE_INDEXED ) == 0 )\n          {\n            sqlite3ErrorMsg( pParse, "cannot use index: %s", pIdx.zName );\n            goto whereBeginError;\n          }\n          else\n          {\n            /* If an INDEXED BY clause is used, the bestIndex() function is\n            ** guaranteed to find the index specified in the INDEXED BY clause\n            ** if it find an index at all. */\n            Debug.Assert( bestPlan.plan.u.pIdx == pIdx );\n          }\n        }\n      }\n#if (SQLITE_TEST) && (SQLITE_DEBUG)\n      WHERETRACE( "*** Optimizer Finished ***\\n" );\n#endif\n      if ( pParse.nErr != 0 /*|| db.mallocFailed != 0 */ )\n      {\n        goto whereBeginError;\n      }\n\n      /* If the total query only selects a single row, then the ORDER BY\n      ** clause is irrelevant.\n      */\n      if ( ( andFlags & WHERE_UNIQUE ) != 0 && ppOrderBy != null )\n      {\n        ppOrderBy = null;\n      }\n\n      /* If the caller is an UPDATE or DELETE statement that is requesting\n      ** to use a one-pDebug.Ass algorithm, determine if this is appropriate.\n      ** The one-pDebug.Ass algorithm only works if the WHERE clause constraints\n      ** the statement to update a single row.\n      */\n      Debug.Assert( ( wctrlFlags & WHERE_ONEPASS_DESIRED ) == 0 || pWInfo.nLevel == 1 );\n      if ( ( wctrlFlags & WHERE_ONEPASS_DESIRED ) != 0 && ( andFlags & WHERE_UNIQUE ) != 0 )\n      {\n        pWInfo.okOnePass = 1;\n        pWInfo.a[0].plan.wsFlags = (u32)( pWInfo.a[0].plan.wsFlags & ~WHERE_IDX_ONLY );\n      }\n\n      /* Open all tables in the pTabList and any indices selected for\n      ** searching those tables.\n      */\n      sqlite3CodeVerifySchema( pParse, -1 ); /* Insert the cookie verifier Goto */\n      for ( i = 0 ; i < pTabList.nSrc ; i++ )//, pLevel++ )\n      {\n        pLevel = pWInfo.a[i];\n        Table pTab;     /* Table to open */\n        int iDb;         /* Index of data_base containing table/index */\n\n#if  !SQLITE_OMIT_EXPLAIN\n        if ( pParse.explain == 2 )\n        {\n          string zMsg;\n          SrcList_item pItem = pTabList.a[pLevel.iFrom];\n          zMsg = sqlite3MPrintf( db, "TABLE %s", pItem.zName );\n          if ( pItem.zAlias != null )\n          {\n            zMsg = sqlite3MAppendf( db, zMsg, "%s AS %s", zMsg, pItem.zAlias );\n          }\n          if ( ( pLevel.plan.wsFlags & WHERE_INDEXED ) != 0 )\n          {\n            zMsg = sqlite3MAppendf( db, zMsg, "%s WITH INDEX %s",\n            zMsg, pLevel.plan.u.pIdx.zName );\n          }\n          else if ( ( pLevel.plan.wsFlags & WHERE_MULTI_OR ) != 0 )\n          {\n            zMsg = sqlite3MAppendf( db, zMsg, "%s VIA MULTI-INDEX UNION", zMsg );\n          }\n          else if ( ( pLevel.plan.wsFlags & ( WHERE_ROWID_EQ | WHERE_ROWID_RANGE ) ) != 0 )\n          {\n            zMsg = sqlite3MAppendf( db, zMsg, "%s USING PRIMARY KEY", zMsg );\n          }\n#if  !SQLITE_OMIT_VIRTUALTABLE\nelse if( (pLevel.plan.wsFlags & WHERE_VIRTUALTABLE)!=null ){\nsqlite3_index_info pVtabIdx = pLevel.plan.u.pVtabIdx;\nzMsg = sqlite3MAppendf(db, zMsg, "%s VIRTUAL TABLE INDEX %d:%s", zMsg,\npVtabIdx.idxNum, pVtabIdx.idxStr);\n}\n#endif\n          if ( ( pLevel.plan.wsFlags & WHERE_ORDERBY ) != 0 )\n          {\n            zMsg = sqlite3MAppendf( db, zMsg, "%s ORDER BY", zMsg );\n          }\n          sqlite3VdbeAddOp4( v, OP_Explain, i, pLevel.iFrom, 0, zMsg, P4_DYNAMIC );\n        }\n#endif //* SQLITE_OMIT_EXPLAIN */\n        pTabItem = pTabList.a[pLevel.iFrom];\n        pTab = pTabItem.pTab;\n        iDb = sqlite3SchemaToIndex( db, pTab.pSchema );\n        if ( ( pTab.tabFlags & TF_Ephemeral ) != 0 || pTab.pSelect != null ) continue;\n#if  !SQLITE_OMIT_VIRTUALTABLE\nif( (pLevel.plan.wsFlags & WHERE_VIRTUALTABLE)!=null ){\n VTable pVTab = sqlite3GetVTable(db, pTab);\nint iCur = pTabItem.iCursor;\nsqlite3VdbeAddOp4(v, OP_VOpen, iCur, 0, 0,\npVTab, P4_VTAB);\n}else\n#endif\n        if ( ( pLevel.plan.wsFlags & WHERE_IDX_ONLY ) == 0\n        && ( wctrlFlags & WHERE_OMIT_OPEN ) == 0 )\n        {\n          int op = pWInfo.okOnePass != 0 ? OP_OpenWrite : OP_OpenRead;\n          sqlite3OpenTable( pParse, pTabItem.iCursor, iDb, pTab, op );\n          if ( 0 == pWInfo.okOnePass && pTab.nCol < BMS )\n          {\n            Bitmask b = pTabItem.colUsed;\n            int n = 0;\n            for ( ; b != 0 ; b = b >> 1, n++ ) { }\n            sqlite3VdbeChangeP4( v, sqlite3VdbeCurrentAddr( v ) - 1, n, P4_INT32 );\n            Debug.Assert( n <= pTab.nCol );\n          }\n        }\n        else\n        {\n          sqlite3TableLock( pParse, iDb, pTab.tnum, 0, pTab.zName );\n        }\n        pLevel.iTabCur = pTabItem.iCursor;\n        if ( ( pLevel.plan.wsFlags & WHERE_INDEXED ) != 0 )\n        {\n          Index pIx = pLevel.plan.u.pIdx;\n          KeyInfo pKey = sqlite3IndexKeyinfo( pParse, pIx );\n          int iIdxCur = pLevel.iIdxCur;\n          Debug.Assert( pIx.pSchema == pTab.pSchema );\n          Debug.Assert( iIdxCur >= 0 );\n          sqlite3VdbeAddOp4( v, OP_OpenRead, iIdxCur, pIx.tnum, iDb,\n          pKey, P4_KEYINFO_HANDOFF );\n#if SQLITE_DEBUG\n          VdbeComment( v, "%s", pIx.zName );\n#endif\n        }\n        sqlite3CodeVerifySchema( pParse, iDb );\n      }\n      pWInfo.iTop = sqlite3VdbeCurrentAddr( v );\n\n      /* Generate the code to do the search.  Each iteration of the for\n      ** loop below generates code for a single nested loop of the VM\n      ** program.\n      */\n      notReady = ~(Bitmask)0;\n      for ( i = 0 ; i < pTabList.nSrc ; i++ )\n      {\n        notReady = codeOneLoopStart( pWInfo, i, wctrlFlags, notReady );\n        pWInfo.iContinue = pWInfo.a[i].addrCont;\n      }\n\n#if SQLITE_TEST  //* For testing and debugging use only */\n      /* Record in the query plan information about the current table\n** and the index used to access it (if any).  If the table itself\n** is not used, its name is just \'{}\'.  If no index is used\n** the index is listed as "{}".  If the primary key is used the\n** index name is \'*\'.\n*/\n      sqlite3_query_plan.sValue = "";\n      for ( i = 0 ; i < pTabList.nSrc ; i++ )\n      {\n        string z;\n        int n;\n        pLevel = pWInfo.a[i];\n        pTabItem = pTabList.a[pLevel.iFrom];\n        z = pTabItem.zAlias;\n        if ( z == null ) z = pTabItem.pTab.zName;\n        n = sqlite3Strlen30( z );\n        if ( true ) //n+nQPlan < sizeof(sqlite3_query_plan)-10 )\n        {\n          if ( ( pLevel.plan.wsFlags & WHERE_IDX_ONLY ) != 0 )\n          {\n            sqlite3_query_plan.Append( "{}" ); //memcpy( &sqlite3_query_plan[nQPlan], "{}", 2 );\n            nQPlan += 2;\n          }\n          else\n          {\n            sqlite3_query_plan.Append( z ); //memcpy( &sqlite3_query_plan[nQPlan], z, n );\n            nQPlan += n;\n          }\n          sqlite3_query_plan.Append( " " ); nQPlan++; //sqlite3_query_plan[nQPlan++] = \' \';\n        }\n        testcase( pLevel.plan.wsFlags & WHERE_ROWID_EQ );\n        testcase( pLevel.plan.wsFlags & WHERE_ROWID_RANGE );\n        if ( ( pLevel.plan.wsFlags & ( WHERE_ROWID_EQ | WHERE_ROWID_RANGE ) ) != 0 )\n        {\n          sqlite3_query_plan.Append( "* " ); //memcpy(&sqlite3_query_plan[nQPlan], "* ", 2);\n          nQPlan += 2;\n        }\n        else if ( ( pLevel.plan.wsFlags & WHERE_INDEXED ) != 0 )\n        {\n          n = sqlite3Strlen30( pLevel.plan.u.pIdx.zName );\n          if ( true ) //n+nQPlan < sizeof(sqlite3_query_plan)-2 )//if( n+nQPlan < sizeof(sqlite3_query_plan)-2 )\n          {\n            sqlite3_query_plan.Append( pLevel.plan.u.pIdx.zName ); //memcpy(&sqlite3_query_plan[nQPlan], pLevel.plan.u.pIdx.zName, n);\n            nQPlan += n;\n            sqlite3_query_plan.Append( " " ); //sqlite3_query_plan[nQPlan++] = \' \';\n          }\n        }\n        else\n        {\n          sqlite3_query_plan.Append( "{} " ); //memcpy( &sqlite3_query_plan[nQPlan], "{} ", 3 );\n          nQPlan += 3;\n        }\n      }\n      //while( nQPlan>0 && sqlite3_query_plan[nQPlan-1]==\' \' ){\n      //  sqlite3_query_plan[--nQPlan] = 0;\n      //}\n      //sqlite3_query_plan[nQPlan] = 0;\n      sqlite3_query_plan.Trim();\n      nQPlan = 0;\n#endif //* SQLITE_TEST // Testing and debugging use only */\n\n      /* Record the continuation address in the WhereInfo structure.  Then\n** clean up and return.\n*/\n      return pWInfo;\n\n      /* Jump here if malloc fails */\nwhereBeginError:\n      whereInfoFree( db, pWInfo );\n      return null;\n    }\n\n    /*\n    ** Generate the end of the WHERE loop.  See comments on\n    ** sqlite3WhereBegin() for additional information.\n    */\n    static void sqlite3WhereEnd( WhereInfo pWInfo )\n    {\n      Parse pParse = pWInfo.pParse;\n      Vdbe v = pParse.pVdbe;\n      int i;\n      WhereLevel pLevel;\n      SrcList pTabList = pWInfo.pTabList;\n      sqlite3 db = pParse.db;\n\n      /* Generate loop termination code.\n      */\n      sqlite3ExprCacheClear( pParse );\n      for ( i = pTabList.nSrc - 1 ; i >= 0 ; i-- )\n      {\n        pLevel = pWInfo.a[i];\n        sqlite3VdbeResolveLabel( v, pLevel.addrCont );\n        if ( pLevel.op != OP_Noop )\n        {\n          sqlite3VdbeAddOp2( v, pLevel.op, pLevel.p1, pLevel.p2 );\n          sqlite3VdbeChangeP5( v, pLevel.p5 );\n        }\n        if ( ( pLevel.plan.wsFlags & WHERE_IN_ABLE ) != 0 && pLevel.u._in.nIn > 0 )\n        {\n          InLoop pIn;\n          int j;\n          sqlite3VdbeResolveLabel( v, pLevel.addrNxt );\n          for ( j = pLevel.u._in.nIn ; j > 0 ; j-- )//, pIn--)\n          {\n            pIn = pLevel.u._in.aInLoop[j - 1];\n            sqlite3VdbeJumpHere( v, pIn.addrInTop + 1 );\n            sqlite3VdbeAddOp2( v, OP_Next, pIn.iCur, pIn.addrInTop );\n            sqlite3VdbeJumpHere( v, pIn.addrInTop - 1 );\n          }\n          //sqlite3DbFree( db, pLevel.u._in.aInLoop );\n        }\n        sqlite3VdbeResolveLabel( v, pLevel.addrBrk );\n        if ( pLevel.iLeftJoin != 0 )\n        {\n          int addr;\n          addr = sqlite3VdbeAddOp1( v, OP_IfPos, pLevel.iLeftJoin );\n          sqlite3VdbeAddOp1( v, OP_NullRow, pTabList.a[i].iCursor );\n          if ( pLevel.iIdxCur >= 0 )\n          {\n            sqlite3VdbeAddOp1( v, OP_NullRow, pLevel.iIdxCur );\n          }\n          if ( pLevel.op == OP_Return )\n          {\n            sqlite3VdbeAddOp2( v, OP_Gosub, pLevel.p1, pLevel.addrFirst );\n          }\n          else\n          {\n            sqlite3VdbeAddOp2( v, OP_Goto, 0, pLevel.addrFirst );\n          }\n          sqlite3VdbeJumpHere( v, addr );\n        }\n      }\n\n      /* The "break" point is here, just past the end of the outer loop.\n      ** Set it.\n      */\n      sqlite3VdbeResolveLabel( v, pWInfo.iBreak );\n\n      /* Close all of the cursors that were opened by sqlite3WhereBegin.\n      */\n      for ( i = 0 ; i < pTabList.nSrc ; i++ )//, pLevel++)\n      {\n        pLevel = pWInfo.a[i];\n        SrcList_item pTabItem = pTabList.a[pLevel.iFrom];\n        Table pTab = pTabItem.pTab;\n        Debug.Assert( pTab != null );\n        if ( ( pTab.tabFlags & TF_Ephemeral ) != 0 || pTab.pSelect != null ) continue;\n        if ( ( pWInfo.wctrlFlags & WHERE_OMIT_CLOSE ) == 0 )\n        {\n          if ( 0 == pWInfo.okOnePass && ( pLevel.plan.wsFlags & WHERE_IDX_ONLY ) == 0 )\n          {\n            sqlite3VdbeAddOp1( v, OP_Close, pTabItem.iCursor );\n          }\n          if ( ( pLevel.plan.wsFlags & WHERE_INDEXED ) != 0 )\n          {\n            sqlite3VdbeAddOp1( v, OP_Close, pLevel.iIdxCur );\n          }\n        }\n\n        /* If this scan uses an index, make code substitutions to read data\n        ** from the index in preference to the table. Sometimes, this means\n        ** the table need never be read from. This is a performance boost,\n        ** as the vdbe level waits until the table is read before actually\n        ** seeking the table cursor to the record corresponding to the current\n        ** position in the index.\n        **\n        ** Calls to the code generator in between sqlite3WhereBegin and\n        ** sqlite3WhereEnd will have created code that references the table\n        ** directly.  This loop scans all that code looking for opcodes\n        ** that reference the table and converts them into opcodes that\n        ** reference the index.\n        */\n        if ( ( pLevel.plan.wsFlags & WHERE_INDEXED ) != 0 )///* && 0 == db.mallocFailed */ )\n        {\n          int k, j, last;\n          VdbeOp pOp;\n          Index pIdx = pLevel.plan.u.pIdx;\n          int useIndexOnly = ( pLevel.plan.wsFlags & WHERE_IDX_ONLY ) != 0 ? 1 : 0;\n\n          Debug.Assert( pIdx != null );\n          //pOp = sqlite3VdbeGetOp( v, pWInfo.iTop );\n          last = sqlite3VdbeCurrentAddr( v );\n          for ( k = pWInfo.iTop ; k < last ; k++ )//, pOp++ )\n          {\n            pOp = sqlite3VdbeGetOp( v, k );\n            if ( pOp.p1 != pLevel.iTabCur ) continue;\n            if ( pOp.opcode == OP_Column )\n            {\n              for ( j = 0 ; j < pIdx.nColumn ; j++ )\n              {\n                if ( pOp.p2 == pIdx.aiColumn[j] )\n                {\n                  pOp.p2 = j;\n                  pOp.p1 = pLevel.iIdxCur;\n                  break;\n                }\n              }\n              Debug.Assert( 0 == useIndexOnly || j < pIdx.nColumn );\n            }\n            else if ( pOp.opcode == OP_Rowid )\n            {\n              pOp.p1 = pLevel.iIdxCur;\n              pOp.opcode = OP_IdxRowid;\n            }\n            else if ( pOp.opcode == OP_NullRow && useIndexOnly != 0 )\n            {\n              pOp.opcode = OP_Noop;\n            }\n          }\n        }\n      }\n\n      /* Final cleanup\n      */\n      whereInfoFree( db, pWInfo );\n      return;\n    }\n  }\n}\n'