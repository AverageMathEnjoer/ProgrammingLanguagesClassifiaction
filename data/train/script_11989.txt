b"import Data.Array\n\ntestData :: [Int]\ntestData = [51, 38, 29, 51, 63, 38]\n\nranking1 :: [Int]\nranking1 = [3, 1, 3, 0, 1] \n\nranking2 :: [Int]\nranking2 = [2, 0, 3, 4, 0]\n\nshiftBy :: Int -> [Int] -> [Int]\nshiftBy k rs = map (+ k) (drop k rs) ++ [k - 1, k - 2 .. 0]\n\napplyUntil :: (a -> Bool) -> [a -> a] -> a -> a\napplyUntil p (f:fs) x = if p x then x else applyUntil p fs (f x)\n\npsort :: Ord b => [(a, b)] -> [[a]]\npsort xys = pass xys []\n\npass [] xss = xss\npass (e@(x , y):xys) xss = step xys [] [x] [] xss\n    where\n        step [] as bs cs xss = pass as (bs : pass cs xss)\n        step (e@(x, y'):xys) as bs cs xss \n            | y' < y    = step xys (e:as) bs cs xss\n            | y' == y   = step xys as (x:bs) cs xss\n            | y' > y    = step xys as bs (e:cs) xss\n\n\nlabel :: [[a]] -> [[(a, Int)]]\nlabel xss = zipWith tag xss (scanl (+) 0 (map length xss))\n\ntag :: [a] -> b -> [(a, b)]\ntag xs k = [(x, k) | x <- xs]\n\nresort :: [(Int, Int)] -> [Int]\nresort ijs = elems (array (0, length ijs - 1) ijs)\n\npartition :: Ord a => [a] -> [[Int]]\npartition = psort . zip [0..]\n\nranktails :: Ord a => [a] -> [Int]\nranktails = resort . concat . label . \n                applyUntil (all single) repartitions . partition\n\nrepartitions :: [[[Int]] -> [[Int]]]\nrepartitions = map repartition (iterate (* 2) 1)\n\nrepartition :: Int -> [[Int]] -> [[Int]]\nrepartition k iss = partition(zip rs (shiftBy k rs))\n                    where rs = resort (concat (label iss))\n\nsingle :: [a] -> Bool\nsingle xs = length xs == 1\n\n"