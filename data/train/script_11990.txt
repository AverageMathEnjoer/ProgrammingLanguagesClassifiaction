b'{-# LANGUAGE CPP #-}\n{-# LANGUAGE BangPatterns #-}\n{-# LANGUAGE PatternGuards #-}\n#ifdef __GLASGOW_HASKELL__\n{-# LANGUAGE DeriveLift #-}\n{-# LANGUAGE MagicHash #-}\n{-# LANGUAGE StandaloneDeriving #-}\n{-# LANGUAGE TypeFamilies #-}\n#endif\n#if !defined(TESTING) && defined(__GLASGOW_HASKELL__)\n{-# LANGUAGE Trustworthy #-}\n#endif\n\n{-# OPTIONS_HADDOCK not-home #-}\n\n#include "containers.h"\n\n-----------------------------------------------------------------------------\n-- |\n-- Module      :  Data.IntSet.Internal\n-- Copyright   :  (c) Daan Leijen 2002\n--                (c) Joachim Breitner 2011\n-- License     :  BSD-style\n-- Maintainer  :  libraries@haskell.org\n-- Portability :  portable\n--\n-- = WARNING\n--\n-- This module is considered __internal__.\n--\n-- The Package Versioning Policy __does not apply__.\n--\n-- The contents of this module may change __in any way whatsoever__\n-- and __without any warning__ between minor versions of this package.\n--\n-- Authors importing this module are expected to track development\n-- closely.\n--\n-- = Description\n--\n-- An efficient implementation of integer sets.\n--\n-- These modules are intended to be imported qualified, to avoid name\n-- clashes with Prelude functions, e.g.\n--\n-- >  import Data.IntSet (IntSet)\n-- >  import qualified Data.IntSet as IntSet\n--\n-- The implementation is based on /big-endian patricia trees/.  This data\n-- structure performs especially well on binary operations like \'union\'\n-- and \'intersection\'.  However, my benchmarks show that it is also\n-- (much) faster on insertions and deletions when compared to a generic\n-- size-balanced set implementation (see "Data.Set").\n--\n--    * Chris Okasaki and Andy Gill,  \\"/Fast Mergeable Integer Maps/\\",\n--      Workshop on ML, September 1998, pages 77-86,\n--      <http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.37.5452>\n--\n--    * D.R. Morrison, \\"/PATRICIA -- Practical Algorithm To Retrieve Information Coded In Alphanumeric/\\",\n--      Journal of the ACM, 15(4), October 1968, pages 514-534.\n--\n-- Additionally, this implementation places bitmaps in the leaves of the tree.\n-- Their size is the natural size of a machine word (32 or 64 bits) and greatly\n-- reduce memory footprint and execution times for dense sets, e.g. sets where\n-- it is likely that many values lie close to each other. The asymptotics are\n-- not affected by this optimization.\n--\n-- Many operations have a worst-case complexity of \\(O(\\min(n,W))\\).\n-- This means that the operation can become linear in the number of\n-- elements with a maximum of \\(W\\) -- the number of bits in an \'Int\'\n-- (32 or 64).\n--\n-- @since 0.5.9\n-----------------------------------------------------------------------------\n\n-- [Note: INLINE bit fiddling]\n-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~\n-- It is essential that the bit fiddling functions like mask, zero, branchMask\n-- etc are inlined. If they do not, the memory allocation skyrockets. The GHC\n-- usually gets it right, but it is disastrous if it does not. Therefore we\n-- explicitly mark these functions INLINE.\n\n\n-- [Note: Local \'go\' functions and capturing]\n-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n-- Care must be taken when using \'go\' function which captures an argument.\n-- Sometimes (for example when the argument is passed to a data constructor,\n-- as in insert), GHC heap-allocates more than necessary. Therefore C-- code\n-- must be checked for increased allocation when creating and modifying such\n-- functions.\n\n\n-- [Note: Order of constructors]\n-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n-- The order of constructors of IntSet matters when considering performance.\n-- Currently in GHC 7.0, when type has 3 constructors, they are matched from\n-- the first to the last -- the best performance is achieved when the\n-- constructors are ordered by frequency.\n-- On GHC 7.0, reordering constructors from Nil | Tip | Bin to Bin | Tip | Nil\n-- improves the benchmark by circa 10%.\n\nmodule Data.IntSet.Internal (\n    -- * Set type\n      IntSet(..), Key -- instance Eq,Show\n    , Prefix, Mask, BitMap\n\n    -- * Operators\n    , (\\\\)\n\n    -- * Query\n    , null\n    , size\n    , member\n    , notMember\n    , lookupLT\n    , lookupGT\n    , lookupLE\n    , lookupGE\n    , isSubsetOf\n    , isProperSubsetOf\n    , disjoint\n\n    -- * Construction\n    , empty\n    , singleton\n    , insert\n    , delete\n    , alterF\n\n    -- * Combine\n    , union\n    , unions\n    , difference\n    , intersection\n\n    -- * Filter\n    , filter\n    , partition\n\n    , takeWhileAntitone\n    , dropWhileAntitone\n    , spanAntitone\n\n    , split\n    , splitMember\n    , splitRoot\n\n    -- * Map\n    , map\n    , mapMonotonic\n\n    -- * Folds\n    , foldr\n    , foldl\n    -- ** Strict folds\n    , foldr\'\n    , foldl\'\n    -- ** Legacy folds\n    , fold\n\n    -- * Min\\/Max\n    , findMin\n    , findMax\n    , deleteMin\n    , deleteMax\n    , deleteFindMin\n    , deleteFindMax\n    , maxView\n    , minView\n\n    -- * Conversion\n\n    -- ** List\n    , elems\n    , toList\n    , fromList\n\n    -- ** Ordered list\n    , toAscList\n    , toDescList\n    , fromAscList\n    , fromDistinctAscList\n\n    -- * Debugging\n    , showTree\n    , showTreeWith\n\n    -- * Internals\n    , match\n    , suffixBitMask\n    , prefixBitMask\n    , bitmapOf\n    , zero\n    ) where\n\nimport Control.Applicative (Const(..))\nimport Control.DeepSeq (NFData(rnf))\nimport Data.Bits\nimport qualified Data.List as List\nimport Data.Maybe (fromMaybe)\nimport Data.Semigroup (Semigroup(stimes))\n#if !(MIN_VERSION_base(4,11,0))\nimport Data.Semigroup (Semigroup((<>)))\n#endif\nimport Data.Semigroup (stimesIdempotentMonoid)\nimport Utils.Containers.Internal.Prelude hiding\n  (filter, foldr, foldl, null, map)\nimport Prelude ()\n\nimport Utils.Containers.Internal.BitUtil\nimport Utils.Containers.Internal.StrictPair\n\n#if __GLASGOW_HASKELL__\nimport Data.Data (Data(..), Constr, mkConstr, constrIndex, DataType, mkDataType)\nimport qualified Data.Data\nimport Text.Read\n#endif\n\n#if __GLASGOW_HASKELL__\nimport qualified GHC.Exts\n#  if !(WORD_SIZE_IN_BITS==64)\nimport qualified GHC.Int\n#  endif\nimport Language.Haskell.TH.Syntax (Lift)\n-- See Note [ Template Haskell Dependencies ]\nimport Language.Haskell.TH ()\n#endif\n\nimport qualified Data.Foldable as Foldable\nimport Data.Functor.Identity (Identity(..))\n\ninfixl 9 \\\\{-This comment teaches CPP correct behaviour -}\n\n-- A "Nat" is a natural machine word (an unsigned Int)\ntype Nat = Word\n\nnatFromInt :: Int -> Nat\nnatFromInt i = fromIntegral i\n{-# INLINE natFromInt #-}\n\nintFromNat :: Nat -> Int\nintFromNat w = fromIntegral w\n{-# INLINE intFromNat #-}\n\n{--------------------------------------------------------------------\n  Operators\n--------------------------------------------------------------------}\n-- | \\(O(n+m)\\). See \'difference\'.\n(\\\\) :: IntSet -> IntSet -> IntSet\nm1 \\\\ m2 = difference m1 m2\n\n{--------------------------------------------------------------------\n  Types\n--------------------------------------------------------------------}\n\n-- | A set of integers.\n\n-- See Note: Order of constructors\ndata IntSet = Bin {-# UNPACK #-} !Prefix {-# UNPACK #-} !Mask !IntSet !IntSet\n-- Invariant: Nil is never found as a child of Bin.\n-- Invariant: The Mask is a power of 2.  It is the largest bit position at which\n--            two elements of the set differ.\n-- Invariant: Prefix is the common high-order bits that all elements share to\n--            the left of the Mask bit.\n-- Invariant: In Bin prefix mask left right, left consists of the elements that\n--            don\'t have the mask bit set; right is all the elements that do.\n            | Tip {-# UNPACK #-} !Prefix {-# UNPACK #-} !BitMap\n-- Invariant: The Prefix is zero for the last 5 (on 32 bit arches) or 6 bits\n--            (on 64 bit arches). The values of the set represented by a tip\n--            are the prefix plus the indices of the set bits in the bit map.\n            | Nil\n\n-- A number stored in a set is stored as\n-- * Prefix (all but last 5-6 bits) and\n-- * BitMap (last 5-6 bits stored as a bitmask)\n--   Last 5-6 bits are called a Suffix.\n\ntype Prefix = Int\ntype Mask   = Int\ntype BitMap = Word\ntype Key    = Int\n\n#ifdef __GLASGOW_HASKELL__\n-- | @since 0.6.6\nderiving instance Lift IntSet\n#endif\n\ninstance Monoid IntSet where\n    mempty  = empty\n    mconcat = unions\n    mappend = (<>)\n\n-- | @since 0.5.7\ninstance Semigroup IntSet where\n    (<>)    = union\n    stimes  = stimesIdempotentMonoid\n\n#if __GLASGOW_HASKELL__\n\n{--------------------------------------------------------------------\n  A Data instance\n--------------------------------------------------------------------}\n\n-- This instance preserves data abstraction at the cost of inefficiency.\n-- We provide limited reflection services for the sake of data abstraction.\n\ninstance Data IntSet where\n  gfoldl f z is = z fromList `f` (toList is)\n  toConstr _     = fromListConstr\n  gunfold k z c  = case constrIndex c of\n    1 -> k (z fromList)\n    _ -> error "gunfold"\n  dataTypeOf _   = intSetDataType\n\nfromListConstr :: Constr\nfromListConstr = mkConstr intSetDataType "fromList" [] Data.Data.Prefix\n\nintSetDataType :: DataType\nintSetDataType = mkDataType "Data.IntSet.Internal.IntSet" [fromListConstr]\n\n#endif\n\n{--------------------------------------------------------------------\n  Query\n--------------------------------------------------------------------}\n-- | \\(O(1)\\). Is the set empty?\nnull :: IntSet -> Bool\nnull Nil = True\nnull _   = False\n{-# INLINE null #-}\n\n-- | \\(O(n)\\). Cardinality of the set.\nsize :: IntSet -> Int\nsize = go 0\n  where\n    go !acc (Bin _ _ l r) = go (go acc l) r\n    go acc (Tip _ bm) = acc + bitcount 0 bm\n    go acc Nil = acc\n\n-- | \\(O(\\min(n,W))\\). Is the value a member of the set?\n\n-- See Note: Local \'go\' functions and capturing.\nmember :: Key -> IntSet -> Bool\nmember !x = go\n  where\n    go (Bin p m l r)\n      | nomatch x p m = False\n      | zero x m      = go l\n      | otherwise     = go r\n    go (Tip y bm) = prefixOf x == y && bitmapOf x .&. bm /= 0\n    go Nil = False\n\n-- | \\(O(\\min(n,W))\\). Is the element not in the set?\nnotMember :: Key -> IntSet -> Bool\nnotMember k = not . member k\n\n-- | \\(O(\\min(n,W))\\). Find largest element smaller than the given one.\n--\n-- > lookupLT 3 (fromList [3, 5]) == Nothing\n-- > lookupLT 5 (fromList [3, 5]) == Just 3\n\n-- See Note: Local \'go\' functions and capturing.\nlookupLT :: Key -> IntSet -> Maybe Key\nlookupLT !x t = case t of\n    Bin _ m l r | m < 0 -> if x >= 0 then go r l else go Nil r\n    _ -> go Nil t\n  where\n    go def (Bin p m l r) | nomatch x p m = if x < p then unsafeFindMax def else unsafeFindMax r\n                         | zero x m  = go def l\n                         | otherwise = go l r\n    go def (Tip kx bm) | prefixOf x > kx = Just $ kx + highestBitSet bm\n                       | prefixOf x == kx && maskLT /= 0 = Just $ kx + highestBitSet maskLT\n                       | otherwise = unsafeFindMax def\n                       where maskLT = (bitmapOf x - 1) .&. bm\n    go def Nil = unsafeFindMax def\n\n\n-- | \\(O(\\min(n,W))\\). Find smallest element greater than the given one.\n--\n-- > lookupGT 4 (fromList [3, 5]) == Just 5\n-- > lookupGT 5 (fromList [3, 5]) == Nothing\n\n-- See Note: Local \'go\' functions and capturing.\nlookupGT :: Key -> IntSet -> Maybe Key\nlookupGT !x t = case t of\n    Bin _ m l r | m < 0 -> if x >= 0 then go Nil l else go l r\n    _ -> go Nil t\n  where\n    go def (Bin p m l r) | nomatch x p m = if x < p then unsafeFindMin l else unsafeFindMin def\n                         | zero x m  = go r l\n                         | otherwise = go def r\n    go def (Tip kx bm) | prefixOf x < kx = Just $ kx + lowestBitSet bm\n                       | prefixOf x == kx && maskGT /= 0 = Just $ kx + lowestBitSet maskGT\n                       | otherwise = unsafeFindMin def\n                       where maskGT = (- ((bitmapOf x) `shiftLL` 1)) .&. bm\n    go def Nil = unsafeFindMin def\n\n\n-- | \\(O(\\min(n,W))\\). Find largest element smaller or equal to the given one.\n--\n-- > lookupLE 2 (fromList [3, 5]) == Nothing\n-- > lookupLE 4 (fromList [3, 5]) == Just 3\n-- > lookupLE 5 (fromList [3, 5]) == Just 5\n\n-- See Note: Local \'go\' functions and capturing.\nlookupLE :: Key -> IntSet -> Maybe Key\nlookupLE !x t = case t of\n    Bin _ m l r | m < 0 -> if x >= 0 then go r l else go Nil r\n    _ -> go Nil t\n  where\n    go def (Bin p m l r) | nomatch x p m = if x < p then unsafeFindMax def else unsafeFindMax r\n                         | zero x m  = go def l\n                         | otherwise = go l r\n    go def (Tip kx bm) | prefixOf x > kx = Just $ kx + highestBitSet bm\n                       | prefixOf x == kx && maskLE /= 0 = Just $ kx + highestBitSet maskLE\n                       | otherwise = unsafeFindMax def\n                       where maskLE = (((bitmapOf x) `shiftLL` 1) - 1) .&. bm\n    go def Nil = unsafeFindMax def\n\n\n-- | \\(O(\\min(n,W))\\). Find smallest element greater or equal to the given one.\n--\n-- > lookupGE 3 (fromList [3, 5]) == Just 3\n-- > lookupGE 4 (fromList [3, 5]) == Just 5\n-- > lookupGE 6 (fromList [3, 5]) == Nothing\n\n-- See Note: Local \'go\' functions and capturing.\nlookupGE :: Key -> IntSet -> Maybe Key\nlookupGE !x t = case t of\n    Bin _ m l r | m < 0 -> if x >= 0 then go Nil l else go l r\n    _ -> go Nil t\n  where\n    go def (Bin p m l r) | nomatch x p m = if x < p then unsafeFindMin l else unsafeFindMin def\n                         | zero x m  = go r l\n                         | otherwise = go def r\n    go def (Tip kx bm) | prefixOf x < kx = Just $ kx + lowestBitSet bm\n                       | prefixOf x == kx && maskGE /= 0 = Just $ kx + lowestBitSet maskGE\n                       | otherwise = unsafeFindMin def\n                       where maskGE = (- (bitmapOf x)) .&. bm\n    go def Nil = unsafeFindMin def\n\n\n\n-- Helper function for lookupGE and lookupGT. It assumes that if a Bin node is\n-- given, it has m > 0.\nunsafeFindMin :: IntSet -> Maybe Key\nunsafeFindMin Nil = Nothing\nunsafeFindMin (Tip kx bm) = Just $ kx + lowestBitSet bm\nunsafeFindMin (Bin _ _ l _) = unsafeFindMin l\n\n-- Helper function for lookupLE and lookupLT. It assumes that if a Bin node is\n-- given, it has m > 0.\nunsafeFindMax :: IntSet -> Maybe Key\nunsafeFindMax Nil = Nothing\nunsafeFindMax (Tip kx bm) = Just $ kx + highestBitSet bm\nunsafeFindMax (Bin _ _ _ r) = unsafeFindMax r\n\n{--------------------------------------------------------------------\n  Construction\n--------------------------------------------------------------------}\n-- | \\(O(1)\\). The empty set.\nempty :: IntSet\nempty\n  = Nil\n{-# INLINE empty #-}\n\n-- | \\(O(1)\\). A set of one element.\nsingleton :: Key -> IntSet\nsingleton x\n  = Tip (prefixOf x) (bitmapOf x)\n{-# INLINE singleton #-}\n\n{--------------------------------------------------------------------\n  Insert\n--------------------------------------------------------------------}\n-- | \\(O(\\min(n,W))\\). Add a value to the set. There is no left- or right bias for\n-- IntSets.\ninsert :: Key -> IntSet -> IntSet\ninsert !x = insertBM (prefixOf x) (bitmapOf x)\n\n-- Helper function for insert and union.\ninsertBM :: Prefix -> BitMap -> IntSet -> IntSet\ninsertBM !kx !bm t@(Bin p m l r)\n  | nomatch kx p m = link kx (Tip kx bm) p t\n  | zero kx m      = Bin p m (insertBM kx bm l) r\n  | otherwise      = Bin p m l (insertBM kx bm r)\ninsertBM kx bm t@(Tip kx\' bm\')\n  | kx\' == kx = Tip kx\' (bm .|. bm\')\n  | otherwise = link kx (Tip kx bm) kx\' t\ninsertBM kx bm Nil = Tip kx bm\n\n-- | \\(O(\\min(n,W))\\). Delete a value in the set. Returns the\n-- original set when the value was not present.\ndelete :: Key -> IntSet -> IntSet\ndelete !x = deleteBM (prefixOf x) (bitmapOf x)\n\n-- Deletes all values mentioned in the BitMap from the set.\n-- Helper function for delete and difference.\ndeleteBM :: Prefix -> BitMap -> IntSet -> IntSet\ndeleteBM !kx !bm t@(Bin p m l r)\n  | nomatch kx p m = t\n  | zero kx m      = bin p m (deleteBM kx bm l) r\n  | otherwise      = bin p m l (deleteBM kx bm r)\ndeleteBM kx bm t@(Tip kx\' bm\')\n  | kx\' == kx = tip kx (bm\' .&. complement bm)\n  | otherwise = t\ndeleteBM _ _ Nil = Nil\n\n-- | \\(O(\\min(n,W))\\). @(\'alterF\' f x s)@ can delete or insert @x@ in @s@ depending\n-- on whether it is already present in @s@.\n--\n-- In short:\n--\n-- @\n-- \'member\' x \\<$\\> \'alterF\' f x s = f (\'member\' x s)\n-- @\n--\n-- Note: \'alterF\' is a variant of the @at@ combinator from "Control.Lens.At".\n--\n-- @since 0.6.3.1\nalterF :: Functor f => (Bool -> f Bool) -> Key -> IntSet -> f IntSet\nalterF f k s = fmap choose (f member_)\n  where\n    member_ = member k s\n\n    (inserted, deleted)\n      | member_   = (s         , delete k s)\n      | otherwise = (insert k s, s         )\n\n    choose True  = inserted\n    choose False = deleted\n#ifndef __GLASGOW_HASKELL__\n{-# INLINE alterF #-}\n#else\n{-# INLINABLE [2] alterF #-}\n\n{-# RULES\n"alterF/Const" forall k (f :: Bool -> Const a Bool) . alterF f k = \\s -> Const . getConst . f $ member k s\n #-}\n#endif\n\n{-# SPECIALIZE alterF :: (Bool -> Identity Bool) -> Key -> IntSet -> Identity IntSet #-}\n\n{--------------------------------------------------------------------\n  Union\n--------------------------------------------------------------------}\n-- | The union of a list of sets.\nunions :: Foldable f => f IntSet -> IntSet\nunions xs\n  = Foldable.foldl\' union empty xs\n\n\n-- | \\(O(n+m)\\). The union of two sets.\nunion :: IntSet -> IntSet -> IntSet\nunion t1@(Bin p1 m1 l1 r1) t2@(Bin p2 m2 l2 r2)\n  | shorter m1 m2  = union1\n  | shorter m2 m1  = union2\n  | p1 == p2       = Bin p1 m1 (union l1 l2) (union r1 r2)\n  | otherwise      = link p1 t1 p2 t2\n  where\n    union1  | nomatch p2 p1 m1  = link p1 t1 p2 t2\n            | zero p2 m1        = Bin p1 m1 (union l1 t2) r1\n            | otherwise         = Bin p1 m1 l1 (union r1 t2)\n\n    union2  | nomatch p1 p2 m2  = link p1 t1 p2 t2\n            | zero p1 m2        = Bin p2 m2 (union t1 l2) r2\n            | otherwise         = Bin p2 m2 l2 (union t1 r2)\n\nunion t@(Bin _ _ _ _) (Tip kx bm) = insertBM kx bm t\nunion t@(Bin _ _ _ _) Nil = t\nunion (Tip kx bm) t = insertBM kx bm t\nunion Nil t = t\n\n\n{--------------------------------------------------------------------\n  Difference\n--------------------------------------------------------------------}\n-- | \\(O(n+m)\\). Difference between two sets.\ndifference :: IntSet -> IntSet -> IntSet\ndifference t1@(Bin p1 m1 l1 r1) t2@(Bin p2 m2 l2 r2)\n  | shorter m1 m2  = difference1\n  | shorter m2 m1  = difference2\n  | p1 == p2       = bin p1 m1 (difference l1 l2) (difference r1 r2)\n  | otherwise      = t1\n  where\n    difference1 | nomatch p2 p1 m1  = t1\n                | zero p2 m1        = bin p1 m1 (difference l1 t2) r1\n                | otherwise         = bin p1 m1 l1 (difference r1 t2)\n\n    difference2 | nomatch p1 p2 m2  = t1\n                | zero p1 m2        = difference t1 l2\n                | otherwise         = difference t1 r2\n\ndifference t@(Bin _ _ _ _) (Tip kx bm) = deleteBM kx bm t\ndifference t@(Bin _ _ _ _) Nil = t\n\ndifference t1@(Tip kx bm) t2 = differenceTip t2\n  where differenceTip (Bin p2 m2 l2 r2) | nomatch kx p2 m2 = t1\n                                        | zero kx m2 = differenceTip l2\n                                        | otherwise = differenceTip r2\n        differenceTip (Tip kx2 bm2) | kx == kx2 = tip kx (bm .&. complement bm2)\n                                    | otherwise = t1\n        differenceTip Nil = t1\n\ndifference Nil _     = Nil\n\n\n\n{--------------------------------------------------------------------\n  Intersection\n--------------------------------------------------------------------}\n-- | \\(O(n+m)\\). The intersection of two sets.\nintersection :: IntSet -> IntSet -> IntSet\nintersection t1@(Bin p1 m1 l1 r1) t2@(Bin p2 m2 l2 r2)\n  | shorter m1 m2  = intersection1\n  | shorter m2 m1  = intersection2\n  | p1 == p2       = bin p1 m1 (intersection l1 l2) (intersection r1 r2)\n  | otherwise      = Nil\n  where\n    intersection1 | nomatch p2 p1 m1  = Nil\n                  | zero p2 m1        = intersection l1 t2\n                  | otherwise         = intersection r1 t2\n\n    intersection2 | nomatch p1 p2 m2  = Nil\n                  | zero p1 m2        = intersection t1 l2\n                  | otherwise         = intersection t1 r2\n\nintersection t1@(Bin _ _ _ _) (Tip kx2 bm2) = intersectBM t1\n  where intersectBM (Bin p1 m1 l1 r1) | nomatch kx2 p1 m1 = Nil\n                                      | zero kx2 m1       = intersectBM l1\n                                      | otherwise         = intersectBM r1\n        intersectBM (Tip kx1 bm1) | kx1 == kx2 = tip kx1 (bm1 .&. bm2)\n                                  | otherwise = Nil\n        intersectBM Nil = Nil\n\nintersection (Bin _ _ _ _) Nil = Nil\n\nintersection (Tip kx1 bm1) t2 = intersectBM t2\n  where intersectBM (Bin p2 m2 l2 r2) | nomatch kx1 p2 m2 = Nil\n                                      | zero kx1 m2       = intersectBM l2\n                                      | otherwise         = intersectBM r2\n        intersectBM (Tip kx2 bm2) | kx1 == kx2 = tip kx1 (bm1 .&. bm2)\n                                  | otherwise = Nil\n        intersectBM Nil = Nil\n\nintersection Nil _ = Nil\n\n{--------------------------------------------------------------------\n  Subset\n--------------------------------------------------------------------}\n-- | \\(O(n+m)\\). Is this a proper subset? (ie. a subset but not equal).\nisProperSubsetOf :: IntSet -> IntSet -> Bool\nisProperSubsetOf t1 t2\n  = case subsetCmp t1 t2 of\n      LT -> True\n      _  -> False\n\nsubsetCmp :: IntSet -> IntSet -> Ordering\nsubsetCmp t1@(Bin p1 m1 l1 r1) (Bin p2 m2 l2 r2)\n  | shorter m1 m2  = GT\n  | shorter m2 m1  = case subsetCmpLt of\n                       GT -> GT\n                       _  -> LT\n  | p1 == p2       = subsetCmpEq\n  | otherwise      = GT  -- disjoint\n  where\n    subsetCmpLt | nomatch p1 p2 m2  = GT\n                | zero p1 m2        = subsetCmp t1 l2\n                | otherwise         = subsetCmp t1 r2\n    subsetCmpEq = case (subsetCmp l1 l2, subsetCmp r1 r2) of\n                    (GT,_ ) -> GT\n                    (_ ,GT) -> GT\n                    (EQ,EQ) -> EQ\n                    _       -> LT\n\nsubsetCmp (Bin _ _ _ _) _  = GT\nsubsetCmp (Tip kx1 bm1) (Tip kx2 bm2)\n  | kx1 /= kx2                  = GT -- disjoint\n  | bm1 == bm2                  = EQ\n  | bm1 .&. complement bm2 == 0 = LT\n  | otherwise                   = GT\nsubsetCmp t1@(Tip kx _) (Bin p m l r)\n  | nomatch kx p m = GT\n  | zero kx m      = case subsetCmp t1 l of GT -> GT ; _ -> LT\n  | otherwise      = case subsetCmp t1 r of GT -> GT ; _ -> LT\nsubsetCmp (Tip _ _) Nil = GT -- disjoint\nsubsetCmp Nil Nil = EQ\nsubsetCmp Nil _   = LT\n\n-- | \\(O(n+m)\\). Is this a subset?\n-- @(s1 \\`isSubsetOf\\` s2)@ tells whether @s1@ is a subset of @s2@.\n\nisSubsetOf :: IntSet -> IntSet -> Bool\nisSubsetOf t1@(Bin p1 m1 l1 r1) (Bin p2 m2 l2 r2)\n  | shorter m1 m2  = False\n  | shorter m2 m1  = match p1 p2 m2 && (if zero p1 m2 then isSubsetOf t1 l2\n                                                      else isSubsetOf t1 r2)\n  | otherwise      = (p1==p2) && isSubsetOf l1 l2 && isSubsetOf r1 r2\nisSubsetOf (Bin _ _ _ _) _  = False\nisSubsetOf (Tip kx1 bm1) (Tip kx2 bm2) = kx1 == kx2 && bm1 .&. complement bm2 == 0\nisSubsetOf t1@(Tip kx _) (Bin p m l r)\n  | nomatch kx p m = False\n  | zero kx m      = isSubsetOf t1 l\n  | otherwise      = isSubsetOf t1 r\nisSubsetOf (Tip _ _) Nil = False\nisSubsetOf Nil _         = True\n\n\n{--------------------------------------------------------------------\n  Disjoint\n--------------------------------------------------------------------}\n-- | \\(O(n+m)\\). Check whether two sets are disjoint (i.e. their intersection\n--   is empty).\n--\n-- > disjoint (fromList [2,4,6])   (fromList [1,3])     == True\n-- > disjoint (fromList [2,4,6,8]) (fromList [2,3,5,7]) == False\n-- > disjoint (fromList [1,2])     (fromList [1,2,3,4]) == False\n-- > disjoint (fromList [])        (fromList [])        == True\n--\n-- @since 0.5.11\ndisjoint :: IntSet -> IntSet -> Bool\ndisjoint t1@(Bin p1 m1 l1 r1) t2@(Bin p2 m2 l2 r2)\n  | shorter m1 m2  = disjoint1\n  | shorter m2 m1  = disjoint2\n  | p1 == p2       = disjoint l1 l2 && disjoint r1 r2\n  | otherwise      = True\n  where\n    disjoint1 | nomatch p2 p1 m1  = True\n              | zero p2 m1        = disjoint l1 t2\n              | otherwise         = disjoint r1 t2\n\n    disjoint2 | nomatch p1 p2 m2  = True\n              | zero p1 m2        = disjoint t1 l2\n              | otherwise         = disjoint t1 r2\n\ndisjoint t1@(Bin _ _ _ _) (Tip kx2 bm2) = disjointBM t1\n  where disjointBM (Bin p1 m1 l1 r1) | nomatch kx2 p1 m1 = True\n                                     | zero kx2 m1       = disjointBM l1\n                                     | otherwise         = disjointBM r1\n        disjointBM (Tip kx1 bm1) | kx1 == kx2 = (bm1 .&. bm2) == 0\n                                 | otherwise = True\n        disjointBM Nil = True\n\ndisjoint (Bin _ _ _ _) Nil = True\n\ndisjoint (Tip kx1 bm1) t2 = disjointBM t2\n  where disjointBM (Bin p2 m2 l2 r2) | nomatch kx1 p2 m2 = True\n                                     | zero kx1 m2       = disjointBM l2\n                                     | otherwise         = disjointBM r2\n        disjointBM (Tip kx2 bm2) | kx1 == kx2 = (bm1 .&. bm2) == 0\n                                 | otherwise = True\n        disjointBM Nil = True\n\ndisjoint Nil _ = True\n\n\n{--------------------------------------------------------------------\n  Filter\n--------------------------------------------------------------------}\n-- | \\(O(n)\\). Filter all elements that satisfy some predicate.\nfilter :: (Key -> Bool) -> IntSet -> IntSet\nfilter predicate t\n  = case t of\n      Bin p m l r\n        -> bin p m (filter predicate l) (filter predicate r)\n      Tip kx bm\n        -> tip kx (foldl\'Bits 0 (bitPred kx) 0 bm)\n      Nil -> Nil\n  where bitPred kx bm bi | predicate (kx + bi) = bm .|. bitmapOfSuffix bi\n                         | otherwise           = bm\n        {-# INLINE bitPred #-}\n\n-- | \\(O(n)\\). partition the set according to some predicate.\npartition :: (Key -> Bool) -> IntSet -> (IntSet,IntSet)\npartition predicate0 t0 = toPair $ go predicate0 t0\n  where\n    go predicate t\n      = case t of\n          Bin p m l r\n            -> let (l1 :*: l2) = go predicate l\n                   (r1 :*: r2) = go predicate r\n               in bin p m l1 r1 :*: bin p m l2 r2\n          Tip kx bm\n            -> let bm1 = foldl\'Bits 0 (bitPred kx) 0 bm\n               in  tip kx bm1 :*: tip kx (bm `xor` bm1)\n          Nil -> (Nil :*: Nil)\n      where bitPred kx bm bi | predicate (kx + bi) = bm .|. bitmapOfSuffix bi\n                             | otherwise           = bm\n            {-# INLINE bitPred #-}\n\n-- | \\(O(\\min(n,W))\\). Take while a predicate on the elements holds.\n-- The user is responsible for ensuring that for all @Int@s, @j \\< k ==\\> p j \\>= p k@.\n-- See note at \'spanAntitone\'.\n--\n-- @\n-- takeWhileAntitone p = \'fromDistinctAscList\' . \'Data.List.takeWhile\' p . \'toList\'\n-- takeWhileAntitone p = \'filter\' p\n-- @\n--\n-- @since 0.6.7\ntakeWhileAntitone :: (Key -> Bool) -> IntSet -> IntSet\ntakeWhileAntitone predicate t =\n  case t of\n    Bin p m l r\n      | m < 0 ->\n        if predicate 0 -- handle negative numbers.\n        then bin p m (go predicate l) r\n        else go predicate r\n    _ -> go predicate t\n  where\n    go predicate\' (Bin p m l r)\n      | predicate\' $! p+m = bin p m l (go predicate\' r)\n      | otherwise         = go predicate\' l\n    go predicate\' (Tip kx bm) = tip kx (takeWhileAntitoneBits kx predicate\' bm)\n    go _ Nil = Nil\n\n-- | \\(O(\\min(n,W))\\). Drop while a predicate on the elements holds.\n-- The user is responsible for ensuring that for all @Int@s, @j \\< k ==\\> p j \\>= p k@.\n-- See note at \'spanAntitone\'.\n--\n-- @\n-- dropWhileAntitone p = \'fromDistinctAscList\' . \'Data.List.dropWhile\' p . \'toList\'\n-- dropWhileAntitone p = \'filter\' (not . p)\n-- @\n--\n-- @since 0.6.7\ndropWhileAntitone :: (Key -> Bool) -> IntSet -> IntSet\ndropWhileAntitone predicate t =\n  case t of\n    Bin p m l r\n      | m < 0 ->\n        if predicate 0 -- handle negative numbers.\n        then go predicate l\n        else bin p m l (go predicate r)\n    _ -> go predicate t\n  where\n    go predicate\' (Bin p m l r)\n      | predicate\' $! p+m = go predicate\' r\n      | otherwise         = bin p m (go predicate\' l) r\n    go predicate\' (Tip kx bm) = tip kx (bm `xor` takeWhileAntitoneBits kx predicate\' bm)\n    go _ Nil = Nil\n\n-- | \\(O(\\min(n,W))\\). Divide a set at the point where a predicate on the elements stops holding.\n-- The user is responsible for ensuring that for all @Int@s, @j \\< k ==\\> p j \\>= p k@.\n--\n-- @\n-- spanAntitone p xs = (\'takeWhileAntitone\' p xs, \'dropWhileAntitone\' p xs)\n-- spanAntitone p xs = \'partition\' p xs\n-- @\n--\n-- Note: if @p@ is not actually antitone, then @spanAntitone@ will split the set\n-- at some /unspecified/ point.\n--\n-- @since 0.6.7\nspanAntitone :: (Key -> Bool) -> IntSet -> (IntSet, IntSet)\nspanAntitone predicate t =\n  case t of\n    Bin p m l r\n      | m < 0 ->\n        if predicate 0 -- handle negative numbers.\n        then\n          case go predicate l of\n            (lt :*: gt) ->\n              let !lt\' = bin p m lt r\n              in (lt\', gt)\n        else\n          case go predicate r of\n            (lt :*: gt) ->\n              let !gt\' = bin p m l gt\n              in (lt, gt\')\n    _ -> case go predicate t of\n          (lt :*: gt) -> (lt, gt)\n  where\n    go predicate\' (Bin p m l r)\n      | predicate\' $! p+m = case go predicate\' r of (lt :*: gt) -> bin p m l lt :*: gt\n      | otherwise         = case go predicate\' l of (lt :*: gt) -> lt :*: bin p m gt r\n    go predicate\' (Tip kx bm) = let bm\' = takeWhileAntitoneBits kx predicate\' bm\n                                in (tip kx bm\' :*: tip kx (bm `xor` bm\'))\n    go _ Nil = (Nil :*: Nil)\n\n-- | \\(O(\\min(n,W))\\). The expression (@\'split\' x set@) is a pair @(set1,set2)@\n-- where @set1@ comprises the elements of @set@ less than @x@ and @set2@\n-- comprises the elements of @set@ greater than @x@.\n--\n-- > split 3 (fromList [1..5]) == (fromList [1,2], fromList [4,5])\nsplit :: Key -> IntSet -> (IntSet,IntSet)\nsplit x t =\n  case t of\n    Bin p m l r\n      | m < 0 ->\n        if x >= 0  -- handle negative numbers.\n        then\n          case go x l of\n            (lt :*: gt) ->\n              let !lt\' = bin p m lt r\n              in (lt\', gt)\n        else\n          case go x r of\n            (lt :*: gt) ->\n              let !gt\' = bin p m l gt\n              in (lt, gt\')\n    _ -> case go x t of\n          (lt :*: gt) -> (lt, gt)\n  where\n    go !x\' t\'@(Bin p m l r)\n        | nomatch x\' p m = if x\' < p then (Nil :*: t\') else (t\' :*: Nil)\n        | zero x\' m      = case go x\' l of (lt :*: gt) -> lt :*: bin p m gt r\n        | otherwise      = case go x\' r of (lt :*: gt) -> bin p m l lt :*: gt\n    go x\' t\'@(Tip kx\' bm)\n        | kx\' > x\'          = (Nil :*: t\')\n          -- equivalent to kx\' > prefixOf x\'\n        | kx\' < prefixOf x\' = (t\' :*: Nil)\n        | otherwise = tip kx\' (bm .&. lowerBitmap) :*: tip kx\' (bm .&. higherBitmap)\n            where lowerBitmap = bitmapOf x\' - 1\n                  higherBitmap = complement (lowerBitmap + bitmapOf x\')\n    go _ Nil = (Nil :*: Nil)\n\n-- | \\(O(\\min(n,W))\\). Performs a \'split\' but also returns whether the pivot\n-- element was found in the original set.\nsplitMember :: Key -> IntSet -> (IntSet,Bool,IntSet)\nsplitMember x t =\n  case t of\n    Bin p m l r\n      | m < 0 ->\n        if x >= 0 -- handle negative numbers.\n        then\n          case go x l of\n            (lt, fnd, gt) ->\n              let !lt\' = bin p m lt r\n              in (lt\', fnd, gt)\n        else\n          case go x r of\n            (lt, fnd, gt) ->\n              let !gt\' = bin p m l gt\n              in (lt, fnd, gt\')\n    _ -> go x t\n  where\n    go x\' t\'@(Bin p m l r)\n        | nomatch x\' p m = if x\' < p then (Nil, False, t\') else (t\', False, Nil)\n        | zero x\' m =\n          case go x\' l of\n            (lt, fnd, gt) ->\n              let !gt\' = bin p m gt r\n              in (lt, fnd, gt\')\n        | otherwise =\n          case go x\' r of\n            (lt, fnd, gt) ->\n              let !lt\' = bin p m l lt\n              in (lt\', fnd, gt)\n    go x\' t\'@(Tip kx\' bm)\n        | kx\' > x\'          = (Nil, False, t\')\n          -- equivalent to kx\' > prefixOf x\'\n        | kx\' < prefixOf x\' = (t\', False, Nil)\n        | otherwise = let !lt = tip kx\' (bm .&. lowerBitmap)\n                          !found = (bm .&. bitmapOfx\') /= 0\n                          !gt = tip kx\' (bm .&. higherBitmap)\n                      in (lt, found, gt)\n            where bitmapOfx\' = bitmapOf x\'\n                  lowerBitmap = bitmapOfx\' - 1\n                  higherBitmap = complement (lowerBitmap + bitmapOfx\')\n    go _ Nil = (Nil, False, Nil)\n\n{----------------------------------------------------------------------\n  Min/Max\n----------------------------------------------------------------------}\n\n-- | \\(O(\\min(n,W))\\). Retrieves the maximal key of the set, and the set\n-- stripped of that element, or \'Nothing\' if passed an empty set.\nmaxView :: IntSet -> Maybe (Key, IntSet)\nmaxView t =\n  case t of Nil -> Nothing\n            Bin p m l r | m < 0 -> case go l of (result, l\') -> Just (result, bin p m l\' r)\n            _ -> Just (go t)\n  where\n    go (Bin p m l r) = case go r of (result, r\') -> (result, bin p m l r\')\n    go (Tip kx bm) = case highestBitSet bm of bi -> (kx + bi, tip kx (bm .&. complement (bitmapOfSuffix bi)))\n    go Nil = error "maxView Nil"\n\n-- | \\(O(\\min(n,W))\\). Retrieves the minimal key of the set, and the set\n-- stripped of that element, or \'Nothing\' if passed an empty set.\nminView :: IntSet -> Maybe (Key, IntSet)\nminView t =\n  case t of Nil -> Nothing\n            Bin p m l r | m < 0 -> case go r of (result, r\') -> Just (result, bin p m l r\')\n            _ -> Just (go t)\n  where\n    go (Bin p m l r) = case go l of (result, l\') -> (result, bin p m l\' r)\n    go (Tip kx bm) = case lowestBitSet bm of bi -> (kx + bi, tip kx (bm .&. complement (bitmapOfSuffix bi)))\n    go Nil = error "minView Nil"\n\n-- | \\(O(\\min(n,W))\\). Delete and find the minimal element.\n--\n-- > deleteFindMin set = (findMin set, deleteMin set)\ndeleteFindMin :: IntSet -> (Key, IntSet)\ndeleteFindMin = fromMaybe (error "deleteFindMin: empty set has no minimal element") . minView\n\n-- | \\(O(\\min(n,W))\\). Delete and find the maximal element.\n--\n-- > deleteFindMax set = (findMax set, deleteMax set)\ndeleteFindMax :: IntSet -> (Key, IntSet)\ndeleteFindMax = fromMaybe (error "deleteFindMax: empty set has no maximal element") . maxView\n\n\n-- | \\(O(\\min(n,W))\\). The minimal element of the set.\nfindMin :: IntSet -> Key\nfindMin Nil = error "findMin: empty set has no minimal element"\nfindMin (Tip kx bm) = kx + lowestBitSet bm\nfindMin (Bin _ m l r)\n  |   m < 0   = find r\n  | otherwise = find l\n    where find (Tip kx bm) = kx + lowestBitSet bm\n          find (Bin _ _ l\' _) = find l\'\n          find Nil            = error "findMin Nil"\n\n-- | \\(O(\\min(n,W))\\). The maximal element of a set.\nfindMax :: IntSet -> Key\nfindMax Nil = error "findMax: empty set has no maximal element"\nfindMax (Tip kx bm) = kx + highestBitSet bm\nfindMax (Bin _ m l r)\n  |   m < 0   = find l\n  | otherwise = find r\n    where find (Tip kx bm) = kx + highestBitSet bm\n          find (Bin _ _ _ r\') = find r\'\n          find Nil            = error "findMax Nil"\n\n\n-- | \\(O(\\min(n,W))\\). Delete the minimal element. Returns an empty set if the set is empty.\n--\n-- Note that this is a change of behaviour for consistency with \'Data.Set.Set\' &#8211;\n-- versions prior to 0.5 threw an error if the \'IntSet\' was already empty.\ndeleteMin :: IntSet -> IntSet\ndeleteMin = maybe Nil snd . minView\n\n-- | \\(O(\\min(n,W))\\). Delete the maximal element. Returns an empty set if the set is empty.\n--\n-- Note that this is a change of behaviour for consistency with \'Data.Set.Set\' &#8211;\n-- versions prior to 0.5 threw an error if the \'IntSet\' was already empty.\ndeleteMax :: IntSet -> IntSet\ndeleteMax = maybe Nil snd . maxView\n\n{----------------------------------------------------------------------\n  Map\n----------------------------------------------------------------------}\n\n-- | \\(O(n \\min(n,W))\\).\n-- @\'map\' f s@ is the set obtained by applying @f@ to each element of @s@.\n--\n-- It\'s worth noting that the size of the result may be smaller if,\n-- for some @(x,y)@, @x \\/= y && f x == f y@\n\nmap :: (Key -> Key) -> IntSet -> IntSet\nmap f = fromList . List.map f . toList\n\n-- | \\(O(n)\\). The\n--\n-- @\'mapMonotonic\' f s == \'map\' f s@, but works only when @f@ is strictly increasing.\n-- /The precondition is not checked./\n-- Semi-formally, we have:\n--\n-- > and [x < y ==> f x < f y | x <- ls, y <- ls]\n-- >                     ==> mapMonotonic f s == map f s\n-- >     where ls = toList s\n--\n-- @since 0.6.3.1\n\n-- Note that for now the test is insufficient to support any fancier implementation.\nmapMonotonic :: (Key -> Key) -> IntSet -> IntSet\nmapMonotonic f = fromDistinctAscList . List.map f . toAscList\n\n\n{--------------------------------------------------------------------\n  Fold\n--------------------------------------------------------------------}\n-- | \\(O(n)\\). Fold the elements in the set using the given right-associative\n-- binary operator. This function is an equivalent of \'foldr\' and is present\n-- for compatibility only.\n--\n-- /Please note that fold will be deprecated in the future and removed./\nfold :: (Key -> b -> b) -> b -> IntSet -> b\nfold = foldr\n{-# INLINE fold #-}\n\n-- | \\(O(n)\\). Fold the elements in the set using the given right-associative\n-- binary operator, such that @\'foldr\' f z == \'Prelude.foldr\' f z . \'toAscList\'@.\n--\n-- For example,\n--\n-- > toAscList set = foldr (:) [] set\nfoldr :: (Key -> b -> b) -> b -> IntSet -> b\nfoldr f z = \\t ->      -- Use lambda t to be inlinable with two arguments only.\n  case t of Bin _ m l r | m < 0 -> go (go z l) r -- put negative numbers before\n                        | otherwise -> go (go z r) l\n            _ -> go z t\n  where\n    go z\' Nil           = z\'\n    go z\' (Tip kx bm)   = foldrBits kx f z\' bm\n    go z\' (Bin _ _ l r) = go (go z\' r) l\n{-# INLINE foldr #-}\n\n-- | \\(O(n)\\). A strict version of \'foldr\'. Each application of the operator is\n-- evaluated before using the result in the next application. This\n-- function is strict in the starting value.\nfoldr\' :: (Key -> b -> b) -> b -> IntSet -> b\nfoldr\' f z = \\t ->      -- Use lambda t to be inlinable with two arguments only.\n  case t of Bin _ m l r | m < 0 -> go (go z l) r -- put negative numbers before\n                        | otherwise -> go (go z r) l\n            _ -> go z t\n  where\n    go !z\' Nil           = z\'\n    go z\' (Tip kx bm)   = foldr\'Bits kx f z\' bm\n    go z\' (Bin _ _ l r) = go (go z\' r) l\n{-# INLINE foldr\' #-}\n\n-- | \\(O(n)\\). Fold the elements in the set using the given left-associative\n-- binary operator, such that @\'foldl\' f z == \'Prelude.foldl\' f z . \'toAscList\'@.\n--\n-- For example,\n--\n-- > toDescList set = foldl (flip (:)) [] set\nfoldl :: (a -> Key -> a) -> a -> IntSet -> a\nfoldl f z = \\t ->      -- Use lambda t to be inlinable with two arguments only.\n  case t of Bin _ m l r | m < 0 -> go (go z r) l -- put negative numbers before\n                        | otherwise -> go (go z l) r\n            _ -> go z t\n  where\n    go z\' Nil           = z\'\n    go z\' (Tip kx bm)   = foldlBits kx f z\' bm\n    go z\' (Bin _ _ l r) = go (go z\' l) r\n{-# INLINE foldl #-}\n\n-- | \\(O(n)\\). A strict version of \'foldl\'. Each application of the operator is\n-- evaluated before using the result in the next application. This\n-- function is strict in the starting value.\nfoldl\' :: (a -> Key -> a) -> a -> IntSet -> a\nfoldl\' f z = \\t ->      -- Use lambda t to be inlinable with two arguments only.\n  case t of Bin _ m l r | m < 0 -> go (go z r) l -- put negative numbers before\n                        | otherwise -> go (go z l) r\n            _ -> go z t\n  where\n    go !z\' Nil           = z\'\n    go z\' (Tip kx bm)   = foldl\'Bits kx f z\' bm\n    go z\' (Bin _ _ l r) = go (go z\' l) r\n{-# INLINE foldl\' #-}\n\n{--------------------------------------------------------------------\n  List variations\n--------------------------------------------------------------------}\n-- | \\(O(n)\\). An alias of \'toAscList\'. The elements of a set in ascending order.\n-- Subject to list fusion.\nelems :: IntSet -> [Key]\nelems\n  = toAscList\n\n{--------------------------------------------------------------------\n  Lists\n--------------------------------------------------------------------}\n\n#ifdef __GLASGOW_HASKELL__\n-- | @since 0.5.6.2\ninstance GHC.Exts.IsList IntSet where\n  type Item IntSet = Key\n  fromList = fromList\n  toList   = toList\n#endif\n\n-- | \\(O(n)\\). Convert the set to a list of elements. Subject to list fusion.\ntoList :: IntSet -> [Key]\ntoList\n  = toAscList\n\n-- | \\(O(n)\\). Convert the set to an ascending list of elements. Subject to list\n-- fusion.\ntoAscList :: IntSet -> [Key]\ntoAscList = foldr (:) []\n\n-- | \\(O(n)\\). Convert the set to a descending list of elements. Subject to list\n-- fusion.\ntoDescList :: IntSet -> [Key]\ntoDescList = foldl (flip (:)) []\n\n-- List fusion for the list generating functions.\n#if __GLASGOW_HASKELL__\n-- The foldrFB and foldlFB are foldr and foldl equivalents, used for list fusion.\n-- They are important to convert unfused to{Asc,Desc}List back, see mapFB in prelude.\nfoldrFB :: (Key -> b -> b) -> b -> IntSet -> b\nfoldrFB = foldr\n{-# INLINE[0] foldrFB #-}\nfoldlFB :: (a -> Key -> a) -> a -> IntSet -> a\nfoldlFB = foldl\n{-# INLINE[0] foldlFB #-}\n\n-- Inline elems and toList, so that we need to fuse only toAscList.\n{-# INLINE elems #-}\n{-# INLINE toList #-}\n\n-- The fusion is enabled up to phase 2 included. If it does not succeed,\n-- convert in phase 1 the expanded to{Asc,Desc}List calls back to\n-- to{Asc,Desc}List.  In phase 0, we inline fold{lr}FB (which were used in\n-- a list fusion, otherwise it would go away in phase 1), and let compiler do\n-- whatever it wants with to{Asc,Desc}List -- it was forbidden to inline it\n-- before phase 0, otherwise the fusion rules would not fire at all.\n{-# NOINLINE[0] toAscList #-}\n{-# NOINLINE[0] toDescList #-}\n{-# RULES "IntSet.toAscList" [~1] forall s . toAscList s = GHC.Exts.build (\\c n -> foldrFB c n s) #-}\n{-# RULES "IntSet.toAscListBack" [1] foldrFB (:) [] = toAscList #-}\n{-# RULES "IntSet.toDescList" [~1] forall s . toDescList s = GHC.Exts.build (\\c n -> foldlFB (\\xs x -> c x xs) n s) #-}\n{-# RULES "IntSet.toDescListBack" [1] foldlFB (\\xs x -> x : xs) [] = toDescList #-}\n#endif\n\n\n-- | \\(O(n \\min(n,W))\\). Create a set from a list of integers.\nfromList :: [Key] -> IntSet\nfromList xs\n  = Foldable.foldl\' ins empty xs\n  where\n    ins t x  = insert x t\n\n-- | \\(O(n)\\). Build a set from an ascending list of elements.\n-- /The precondition (input list is ascending) is not checked./\nfromAscList :: [Key] -> IntSet\nfromAscList = fromMonoList\n{-# NOINLINE fromAscList #-}\n\n-- | \\(O(n)\\). Build a set from an ascending list of distinct elements.\n-- /The precondition (input list is strictly ascending) is not checked./\nfromDistinctAscList :: [Key] -> IntSet\nfromDistinctAscList = fromAscList\n{-# INLINE fromDistinctAscList #-}\n\n-- | \\(O(n)\\). Build a set from a monotonic list of elements.\n--\n-- The precise conditions under which this function works are subtle:\n-- For any branch mask, keys with the same prefix w.r.t. the branch\n-- mask must occur consecutively in the list.\nfromMonoList :: [Key] -> IntSet\nfromMonoList []         = Nil\nfromMonoList (kx : zs1) = addAll\' (prefixOf kx) (bitmapOf kx) zs1\n  where\n    -- `addAll\'` collects all keys with the prefix `px` into a single\n    -- bitmap, and then proceeds with `addAll`.\n    addAll\' !px !bm []\n        = Tip px bm\n    addAll\' !px !bm (ky : zs)\n        | px == prefixOf ky\n        = addAll\' px (bm .|. bitmapOf ky) zs\n        -- inlined: | otherwise = addAll px (Tip px bm) (ky : zs)\n        | py <- prefixOf ky\n        , m <- branchMask px py\n        , Inserted ty zs\' <- addMany\' m py (bitmapOf ky) zs\n        = addAll px (linkWithMask m py ty {-px-} (Tip px bm)) zs\'\n\n    -- for `addAll` and `addMany`, px is /a/ prefix inside the tree `tx`\n    -- `addAll` consumes the rest of the list, adding to the tree `tx`\n    addAll !_px !tx []\n        = tx\n    addAll !px !tx (ky : zs)\n        | py <- prefixOf ky\n        , m <- branchMask px py\n        , Inserted ty zs\' <- addMany\' m py (bitmapOf ky) zs\n        = addAll px (linkWithMask m py ty {-px-} tx) zs\'\n\n    -- `addMany\'` is similar to `addAll\'`, but proceeds with `addMany\'`.\n    addMany\' !_m !px !bm []\n        = Inserted (Tip px bm) []\n    addMany\' !m !px !bm zs0@(ky : zs)\n        | px == prefixOf ky\n        = addMany\' m px (bm .|. bitmapOf ky) zs\n        -- inlined: | otherwise = addMany m px (Tip px bm) (ky : zs)\n        | mask px m /= mask ky m\n        = Inserted (Tip (prefixOf px) bm) zs0\n        | py <- prefixOf ky\n        , mxy <- branchMask px py\n        , Inserted ty zs\' <- addMany\' mxy py (bitmapOf ky) zs\n        = addMany m px (linkWithMask mxy py ty {-px-} (Tip px bm)) zs\'\n\n    -- `addAll` adds to `tx` all keys whose prefix w.r.t. `m` agrees with `px`.\n    addMany !_m !_px tx []\n        = Inserted tx []\n    addMany !m !px tx zs0@(ky : zs)\n        | mask px m /= mask ky m\n        = Inserted tx zs0\n        | py <- prefixOf ky\n        , mxy <- branchMask px py\n        , Inserted ty zs\' <- addMany\' mxy py (bitmapOf ky) zs\n        = addMany m px (linkWithMask mxy py ty {-px-} tx) zs\'\n{-# INLINE fromMonoList #-}\n\ndata Inserted = Inserted !IntSet ![Key]\n\n{--------------------------------------------------------------------\n  Eq\n--------------------------------------------------------------------}\ninstance Eq IntSet where\n  t1 == t2  = equal t1 t2\n  t1 /= t2  = nequal t1 t2\n\nequal :: IntSet -> IntSet -> Bool\nequal (Bin p1 m1 l1 r1) (Bin p2 m2 l2 r2)\n  = (m1 == m2) && (p1 == p2) && (equal l1 l2) && (equal r1 r2)\nequal (Tip kx1 bm1) (Tip kx2 bm2)\n  = kx1 == kx2 && bm1 == bm2\nequal Nil Nil = True\nequal _   _   = False\n\nnequal :: IntSet -> IntSet -> Bool\nnequal (Bin p1 m1 l1 r1) (Bin p2 m2 l2 r2)\n  = (m1 /= m2) || (p1 /= p2) || (nequal l1 l2) || (nequal r1 r2)\nnequal (Tip kx1 bm1) (Tip kx2 bm2)\n  = kx1 /= kx2 || bm1 /= bm2\nnequal Nil Nil = False\nnequal _   _   = True\n\n{--------------------------------------------------------------------\n  Ord\n--------------------------------------------------------------------}\n\ninstance Ord IntSet where\n    compare s1 s2 = compare (toAscList s1) (toAscList s2)\n    -- tentative implementation. See if more efficient exists.\n\n{--------------------------------------------------------------------\n  Show\n--------------------------------------------------------------------}\ninstance Show IntSet where\n  showsPrec p xs = showParen (p > 10) $\n    showString "fromList " . shows (toList xs)\n\n{--------------------------------------------------------------------\n  Read\n--------------------------------------------------------------------}\ninstance Read IntSet where\n#ifdef __GLASGOW_HASKELL__\n  readPrec = parens $ prec 10 $ do\n    Ident "fromList" <- lexP\n    xs <- readPrec\n    return (fromList xs)\n\n  readListPrec = readListPrecDefault\n#else\n  readsPrec p = readParen (p > 10) $ \\ r -> do\n    ("fromList",s) <- lex r\n    (xs,t) <- reads s\n    return (fromList xs,t)\n#endif\n\n{--------------------------------------------------------------------\n  NFData\n--------------------------------------------------------------------}\n\n-- The IntSet constructors consist only of strict fields of Ints and\n-- IntSets, thus the default NFData instance which evaluates to whnf\n-- should suffice\ninstance NFData IntSet where rnf x = seq x ()\n\n{--------------------------------------------------------------------\n  Debugging\n--------------------------------------------------------------------}\n-- | \\(O(n \\min(n,W))\\). Show the tree that implements the set. The tree is shown\n-- in a compressed, hanging format.\nshowTree :: IntSet -> String\nshowTree s\n  = showTreeWith True False s\n\n\n{- | \\(O(n \\min(n,W))\\). The expression (@\'showTreeWith\' hang wide map@) shows\n the tree that implements the set. If @hang@ is\n \'True\', a /hanging/ tree is shown otherwise a rotated tree is shown. If\n @wide@ is \'True\', an extra wide version is shown.\n-}\nshowTreeWith :: Bool -> Bool -> IntSet -> String\nshowTreeWith hang wide t\n  | hang      = (showsTreeHang wide [] t) ""\n  | otherwise = (showsTree wide [] [] t) ""\n\nshowsTree :: Bool -> [String] -> [String] -> IntSet -> ShowS\nshowsTree wide lbars rbars t\n  = case t of\n      Bin p m l r\n          -> showsTree wide (withBar rbars) (withEmpty rbars) r .\n             showWide wide rbars .\n             showsBars lbars . showString (showBin p m) . showString "\\n" .\n             showWide wide lbars .\n             showsTree wide (withEmpty lbars) (withBar lbars) l\n      Tip kx bm\n          -> showsBars lbars . showString " " . shows kx . showString " + " .\n                                                showsBitMap bm . showString "\\n"\n      Nil -> showsBars lbars . showString "|\\n"\n\nshowsTreeHang :: Bool -> [String] -> IntSet -> ShowS\nshowsTreeHang wide bars t\n  = case t of\n      Bin p m l r\n          -> showsBars bars . showString (showBin p m) . showString "\\n" .\n             showWide wide bars .\n             showsTreeHang wide (withBar bars) l .\n             showWide wide bars .\n             showsTreeHang wide (withEmpty bars) r\n      Tip kx bm\n          -> showsBars bars . showString " " . shows kx . showString " + " .\n                                               showsBitMap bm . showString "\\n"\n      Nil -> showsBars bars . showString "|\\n"\n\nshowBin :: Prefix -> Mask -> String\nshowBin _ _\n  = "*" -- ++ show (p,m)\n\nshowWide :: Bool -> [String] -> String -> String\nshowWide wide bars\n  | wide      = showString (concat (reverse bars)) . showString "|\\n"\n  | otherwise = id\n\nshowsBars :: [String] -> ShowS\nshowsBars [] = id\nshowsBars (_ : tl) = showString (concat (reverse tl)) . showString node\n\nshowsBitMap :: Word -> ShowS\nshowsBitMap = showString . showBitMap\n\nshowBitMap :: Word -> String\nshowBitMap w = show $ foldrBits 0 (:) [] w\n\nnode :: String\nnode           = "+--"\n\nwithBar, withEmpty :: [String] -> [String]\nwithBar bars   = "|  ":bars\nwithEmpty bars = "   ":bars\n\n\n{--------------------------------------------------------------------\n  Helpers\n--------------------------------------------------------------------}\n{--------------------------------------------------------------------\n  Link\n--------------------------------------------------------------------}\nlink :: Prefix -> IntSet -> Prefix -> IntSet -> IntSet\nlink p1 t1 p2 t2 = linkWithMask (branchMask p1 p2) p1 t1 {-p2-} t2\n{-# INLINE link #-}\n\n-- `linkWithMask` is useful when the `branchMask` has already been computed\nlinkWithMask :: Mask -> Prefix -> IntSet -> IntSet -> IntSet\nlinkWithMask m p1 t1 {-p2-} t2\n  | zero p1 m = Bin p m t1 t2\n  | otherwise = Bin p m t2 t1\n  where\n    p = mask p1 m\n{-# INLINE linkWithMask #-}\n\n{--------------------------------------------------------------------\n  @bin@ assures that we never have empty trees within a tree.\n--------------------------------------------------------------------}\nbin :: Prefix -> Mask -> IntSet -> IntSet -> IntSet\nbin _ _ l Nil = l\nbin _ _ Nil r = r\nbin p m l r   = Bin p m l r\n{-# INLINE bin #-}\n\n{--------------------------------------------------------------------\n  @tip@ assures that we never have empty bitmaps within a tree.\n--------------------------------------------------------------------}\ntip :: Prefix -> BitMap -> IntSet\ntip _ 0 = Nil\ntip kx bm = Tip kx bm\n{-# INLINE tip #-}\n\n\n{----------------------------------------------------------------------\n  Functions that generate Prefix and BitMap of a Key or a Suffix.\n----------------------------------------------------------------------}\n\nsuffixBitMask :: Int\nsuffixBitMask = finiteBitSize (undefined::Word) - 1\n{-# INLINE suffixBitMask #-}\n\nprefixBitMask :: Int\nprefixBitMask = complement suffixBitMask\n{-# INLINE prefixBitMask #-}\n\nprefixOf :: Int -> Prefix\nprefixOf x = x .&. prefixBitMask\n{-# INLINE prefixOf #-}\n\nsuffixOf :: Int -> Int\nsuffixOf x = x .&. suffixBitMask\n{-# INLINE suffixOf #-}\n\nbitmapOfSuffix :: Int -> BitMap\nbitmapOfSuffix s = 1 `shiftLL` s\n{-# INLINE bitmapOfSuffix #-}\n\nbitmapOf :: Int -> BitMap\nbitmapOf x = bitmapOfSuffix (suffixOf x)\n{-# INLINE bitmapOf #-}\n\n\n{--------------------------------------------------------------------\n  Endian independent bit twiddling\n--------------------------------------------------------------------}\n-- Returns True iff the bits set in i and the Mask m are disjoint.\nzero :: Int -> Mask -> Bool\nzero i m\n  = (natFromInt i) .&. (natFromInt m) == 0\n{-# INLINE zero #-}\n\nnomatch,match :: Int -> Prefix -> Mask -> Bool\nnomatch i p m\n  = (mask i m) /= p\n{-# INLINE nomatch #-}\n\nmatch i p m\n  = (mask i m) == p\n{-# INLINE match #-}\n\n-- Suppose a is largest such that 2^a divides 2*m.\n-- Then mask i m is i with the low a bits zeroed out.\nmask :: Int -> Mask -> Prefix\nmask i m\n  = maskW (natFromInt i) (natFromInt m)\n{-# INLINE mask #-}\n\n{--------------------------------------------------------------------\n  Big endian operations\n--------------------------------------------------------------------}\nmaskW :: Nat -> Nat -> Prefix\nmaskW i m\n  = intFromNat (i .&. (complement (m-1) `xor` m))\n{-# INLINE maskW #-}\n\nshorter :: Mask -> Mask -> Bool\nshorter m1 m2\n  = (natFromInt m1) > (natFromInt m2)\n{-# INLINE shorter #-}\n\nbranchMask :: Prefix -> Prefix -> Mask\nbranchMask p1 p2\n  = intFromNat (highestBitMask (natFromInt p1 `xor` natFromInt p2))\n{-# INLINE branchMask #-}\n\n{----------------------------------------------------------------------\n  To get best performance, we provide fast implementations of\n  lowestBitSet, highestBitSet and fold[lr][l]Bits for GHC.\n  If the intel bsf and bsr instructions ever become GHC primops,\n  this code should be reimplemented using these.\n\n  Performance of this code is crucial for folds, toList, filter, partition.\n\n  The signatures of methods in question are placed after this comment.\n----------------------------------------------------------------------}\n\nlowestBitSet :: Nat -> Int\nhighestBitSet :: Nat -> Int\nfoldlBits :: Int -> (a -> Int -> a) -> a -> Nat -> a\nfoldl\'Bits :: Int -> (a -> Int -> a) -> a -> Nat -> a\nfoldrBits :: Int -> (Int -> a -> a) -> a -> Nat -> a\nfoldr\'Bits :: Int -> (Int -> a -> a) -> a -> Nat -> a\ntakeWhileAntitoneBits :: Int -> (Int -> Bool) -> Nat -> Nat\n\n{-# INLINE lowestBitSet #-}\n{-# INLINE highestBitSet #-}\n{-# INLINE foldlBits #-}\n{-# INLINE foldl\'Bits #-}\n{-# INLINE foldrBits #-}\n{-# INLINE foldr\'Bits #-}\n{-# INLINE takeWhileAntitoneBits #-}\n\n#if defined(__GLASGOW_HASKELL__) && (WORD_SIZE_IN_BITS==32 || WORD_SIZE_IN_BITS==64)\nindexOfTheOnlyBit :: Nat -> Int\n{-# INLINE indexOfTheOnlyBit #-}\n#if WORD_SIZE_IN_BITS==64\nindexOfTheOnlyBit bitmask = countTrailingZeros bitmask\n\nlowestBitSet x = countTrailingZeros x\n\nhighestBitSet x = WORD_SIZE_IN_BITS - 1 - countLeadingZeros x\n\n#else\n{----------------------------------------------------------------------\n  For lowestBitSet we use wordsize-dependant implementation based on\n  multiplication and DeBrujn indeces, which was proposed by Edward Kmett\n  <http://haskell.org/pipermail/libraries/2011-September/016749.html>\n\n  The core of this implementation is fast indexOfTheOnlyBit,\n  which is given a Nat with exactly one bit set, and returns\n  its index.\n\n  Lot of effort was put in these implementations, please benchmark carefully\n  before changing this code.\n----------------------------------------------------------------------}\n\nindexOfTheOnlyBit bitmask =\n  fromIntegral (GHC.Int.I8# (lsbArray `GHC.Exts.indexInt8OffAddr#` unboxInt (intFromNat ((bitmask * magic) `shiftRL` offset))))\n  where unboxInt (GHC.Exts.I# i) = i\n#if WORD_SIZE_IN_BITS==32\n        magic = 0x077CB531\n        offset = 27\n        !lsbArray = "\\0\\1\\28\\2\\29\\14\\24\\3\\30\\22\\20\\15\\25\\17\\4\\8\\31\\27\\13\\23\\21\\19\\16\\7\\26\\12\\18\\6\\11\\5\\10\\9"#\n#else\n        magic = 0x07EDD5E59A4E28C2\n        offset = 58\n        !lsbArray = "\\63\\0\\58\\1\\59\\47\\53\\2\\60\\39\\48\\27\\54\\33\\42\\3\\61\\51\\37\\40\\49\\18\\28\\20\\55\\30\\34\\11\\43\\14\\22\\4\\62\\57\\46\\52\\38\\26\\32\\41\\50\\36\\17\\19\\29\\10\\13\\21\\56\\45\\25\\31\\35\\16\\9\\12\\44\\24\\15\\8\\23\\7\\6\\5"#\n#endif\n-- The lsbArray gets inlined to every call site of indexOfTheOnlyBit.\n-- That cannot be easily avoided, as GHC forbids top-level Addr# literal.\n-- One could go around that by supplying getLsbArray :: () -> Addr# marked\n-- as NOINLINE. But the code size of calling it and processing the result\n-- is 48B on 32-bit and 56B on 64-bit architectures -- so the 32B and 64B array\n-- is actually improvement on 32-bit and only a 8B size increase on 64-bit.\n\nlowestBitSet x = indexOfTheOnlyBit (lowestBitMask x)\n\nhighestBitSet x = indexOfTheOnlyBit (highestBitMask x)\n\n#endif\n\nlowestBitMask :: Nat -> Nat\nlowestBitMask x = x .&. negate x\n{-# INLINE lowestBitMask #-}\n\n-- Reverse the order of bits in the Nat.\nrevNat :: Nat -> Nat\n#if WORD_SIZE_IN_BITS==32\nrevNat x1 = case ((x1 `shiftRL` 1) .&. 0x55555555) .|. ((x1 .&. 0x55555555) `shiftLL` 1) of\n              x2 -> case ((x2 `shiftRL` 2) .&. 0x33333333) .|. ((x2 .&. 0x33333333) `shiftLL` 2) of\n                 x3 -> case ((x3 `shiftRL` 4) .&. 0x0F0F0F0F) .|. ((x3 .&. 0x0F0F0F0F) `shiftLL` 4) of\n                   x4 -> case ((x4 `shiftRL` 8) .&. 0x00FF00FF) .|. ((x4 .&. 0x00FF00FF) `shiftLL` 8) of\n                     x5 -> ( x5 `shiftRL` 16             ) .|. ( x5               `shiftLL` 16);\n#else\nrevNat x1 = case ((x1 `shiftRL` 1) .&. 0x5555555555555555) .|. ((x1 .&. 0x5555555555555555) `shiftLL` 1) of\n              x2 -> case ((x2 `shiftRL` 2) .&. 0x3333333333333333) .|. ((x2 .&. 0x3333333333333333) `shiftLL` 2) of\n                 x3 -> case ((x3 `shiftRL` 4) .&. 0x0F0F0F0F0F0F0F0F) .|. ((x3 .&. 0x0F0F0F0F0F0F0F0F) `shiftLL` 4) of\n                   x4 -> case ((x4 `shiftRL` 8) .&. 0x00FF00FF00FF00FF) .|. ((x4 .&. 0x00FF00FF00FF00FF) `shiftLL` 8) of\n                     x5 -> case ((x5 `shiftRL` 16) .&. 0x0000FFFF0000FFFF) .|. ((x5 .&. 0x0000FFFF0000FFFF) `shiftLL` 16) of\n                       x6 -> ( x6 `shiftRL` 32             ) .|. ( x6               `shiftLL` 32);\n#endif\n\nfoldlBits prefix f z bitmap = go bitmap z\n  where go 0 acc = acc\n        go bm acc = go (bm `xor` bitmask) ((f acc) $! (prefix+bi))\n          where\n            !bitmask = lowestBitMask bm\n            !bi = indexOfTheOnlyBit bitmask\n\nfoldl\'Bits prefix f z bitmap = go bitmap z\n  where go 0 acc = acc\n        go bm !acc = go (bm `xor` bitmask) ((f acc) $! (prefix+bi))\n          where !bitmask = lowestBitMask bm\n                !bi = indexOfTheOnlyBit bitmask\n\nfoldrBits prefix f z bitmap = go (revNat bitmap) z\n  where go 0 acc = acc\n        go bm acc = go (bm `xor` bitmask) ((f $! (prefix+(WORD_SIZE_IN_BITS-1)-bi)) acc)\n          where !bitmask = lowestBitMask bm\n                !bi = indexOfTheOnlyBit bitmask\n\n\nfoldr\'Bits prefix f z bitmap = go (revNat bitmap) z\n  where go 0 acc = acc\n        go bm !acc = go (bm `xor` bitmask) ((f $! (prefix+(WORD_SIZE_IN_BITS-1)-bi)) acc)\n          where !bitmask = lowestBitMask bm\n                !bi = indexOfTheOnlyBit bitmask\n\ntakeWhileAntitoneBits prefix predicate bitmap =\n  -- Binary search for the first index where the predicate returns false, but skip a predicate\n  -- call if the high half of the current range is empty. This ensures\n  -- min (log2 WORD_SIZE_IN_BITS + 1) (popcount bitmap) predicate calls.\n  let next d h (n\',b\') =\n        if n\' .&. h /= 0 && (predicate $! prefix+b\'+d) then (n\' `shiftRL` d, b\'+d) else (n\',b\')\n      {-# INLINE next #-}\n      (_,b) = next 1  0x2 $\n              next 2  0xC $\n              next 4  0xF0 $\n              next 8  0xFF00 $\n              next 16 0xFFFF0000 $\n#if WORD_SIZE_IN_BITS==64\n              next 32 0xFFFFFFFF00000000 $\n#endif\n              (bitmap,0)\n      m = if b /= 0 || (bitmap .&. 0x1 /= 0 && predicate prefix)\n          then ((2 `shiftLL` b) - 1)\n          else ((1 `shiftLL` b) - 1)\n  in bitmap .&. m\n\n#else\n{----------------------------------------------------------------------\n  In general case we use logarithmic implementation of\n  lowestBitSet and highestBitSet, which works up to bit sizes of 64.\n\n  Folds are linear scans.\n----------------------------------------------------------------------}\n\nlowestBitSet n0 =\n    let (n1,b1) = if n0 .&. 0xFFFFFFFF /= 0 then (n0,0)  else (n0 `shiftRL` 32, 32)\n        (n2,b2) = if n1 .&. 0xFFFF /= 0     then (n1,b1) else (n1 `shiftRL` 16, 16+b1)\n        (n3,b3) = if n2 .&. 0xFF /= 0       then (n2,b2) else (n2 `shiftRL` 8,  8+b2)\n        (n4,b4) = if n3 .&. 0xF /= 0        then (n3,b3) else (n3 `shiftRL` 4,  4+b3)\n        (n5,b5) = if n4 .&. 0x3 /= 0        then (n4,b4) else (n4 `shiftRL` 2,  2+b4)\n        b6      = if n5 .&. 0x1 /= 0        then     b5  else                   1+b5\n    in b6\n\nhighestBitSet n0 =\n    let (n1,b1) = if n0 .&. 0xFFFFFFFF00000000 /= 0 then (n0 `shiftRL` 32, 32)    else (n0,0)\n        (n2,b2) = if n1 .&. 0xFFFF0000 /= 0         then (n1 `shiftRL` 16, 16+b1) else (n1,b1)\n        (n3,b3) = if n2 .&. 0xFF00 /= 0             then (n2 `shiftRL` 8,  8+b2)  else (n2,b2)\n        (n4,b4) = if n3 .&. 0xF0 /= 0               then (n3 `shiftRL` 4,  4+b3)  else (n3,b3)\n        (n5,b5) = if n4 .&. 0xC /= 0                then (n4 `shiftRL` 2,  2+b4)  else (n4,b4)\n        b6      = if n5 .&. 0x2 /= 0                then                   1+b5   else     b5\n    in b6\n\nfoldlBits prefix f z bm = let lb = lowestBitSet bm\n                          in  go (prefix+lb) z (bm `shiftRL` lb)\n  where go !_ acc 0 = acc\n        go bi acc n | n `testBit` 0 = go (bi + 1) (f acc bi) (n `shiftRL` 1)\n                    | otherwise     = go (bi + 1)    acc     (n `shiftRL` 1)\n\nfoldl\'Bits prefix f z bm = let lb = lowestBitSet bm\n                           in  go (prefix+lb) z (bm `shiftRL` lb)\n  where go !_ !acc 0 = acc\n        go bi acc n | n `testBit` 0 = go (bi + 1) (f acc bi) (n `shiftRL` 1)\n                    | otherwise     = go (bi + 1)    acc     (n `shiftRL` 1)\n\nfoldrBits prefix f z bm = let lb = lowestBitSet bm\n                          in  go (prefix+lb) (bm `shiftRL` lb)\n  where go !_ 0 = z\n        go bi n | n `testBit` 0 = f bi (go (bi + 1) (n `shiftRL` 1))\n                | otherwise     =       go (bi + 1) (n `shiftRL` 1)\n\nfoldr\'Bits prefix f z bm = let lb = lowestBitSet bm\n                           in  go (prefix+lb) (bm `shiftRL` lb)\n  where\n        go !_ 0 = z\n        go bi n | n `testBit` 0 = f bi $! go (bi + 1) (n `shiftRL` 1)\n                | otherwise     =         go (bi + 1) (n `shiftRL` 1)\n\ntakeWhileAntitoneBits prefix predicate = foldl\'Bits prefix f 0 -- Does not use antitone property\n  where\n    f acc bi | predicate bi = acc .|. bitmapOf bi\n             | otherwise    = acc\n\n#endif\n\n\n{--------------------------------------------------------------------\n  Utilities\n--------------------------------------------------------------------}\n\n-- | \\(O(1)\\).  Decompose a set into pieces based on the structure of the underlying\n-- tree.  This function is useful for consuming a set in parallel.\n--\n-- No guarantee is made as to the sizes of the pieces; an internal, but\n-- deterministic process determines this.  However, it is guaranteed that the\n-- pieces returned will be in ascending order (all elements in the first submap\n-- less than all elements in the second, and so on).\n--\n-- Examples:\n--\n-- > splitRoot (fromList [1..120]) == [fromList [1..63],fromList [64..120]]\n-- > splitRoot empty == []\n--\n--  Note that the current implementation does not return more than two subsets,\n--  but you should not depend on this behaviour because it can change in the\n--  future without notice. Also, the current version does not continue\n--  splitting all the way to individual singleton sets -- it stops at some\n--  point.\nsplitRoot :: IntSet -> [IntSet]\nsplitRoot Nil = []\n-- NOTE: we don\'t currently split below Tip, but we could.\nsplitRoot x@(Tip _ _) = [x]\nsplitRoot (Bin _ m l r) | m < 0 = [r, l]\n                        | otherwise = [l, r]\n{-# INLINE splitRoot #-}\n'