b'\xef\xbb\xbfusing Microsoft.Extensions.DependencyInjection;\nusing System.Diagnostics;\nusing System.IO.Compression;\nusing System.Net;\nusing System.Net.Http.Headers;\nusing System.Net.Security;\nusing System.Net.Sockets;\nusing System.Security.Authentication;\nusing System.Security.Cryptography.X509Certificates;\nusing System.Text;\nusing System.Text.Encodings.Web;\nusing System.Text.RegularExpressions;\n\nnamespace XboxDownload\n{\n    internal class ClassWeb\n    {\n        public static string language = Thread.CurrentThread.CurrentCulture.Name;\n        public static string userAgent = "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/111.0.0.0 Safari/537.36";\n        private static IHttpClientFactory? httpClientFactory;\n\n        public static void HttpClientFactory()\n        {\n            ServiceCollection services = new();\n            services.AddHttpClient("default").ConfigureHttpClient(httpClient =>\n            {\n                httpClient.DefaultRequestHeaders.Add("User-Agent", userAgent);\n            }).ConfigurePrimaryHttpMessageHandler(() => new HttpClientHandler\n            {\n                ServerCertificateCustomValidationCallback = (message, cert, chain, errors) => { return true; },\n                AutomaticDecompression = DecompressionMethods.All\n            });\n            services.AddHttpClient("XboxDownload").ConfigureHttpClient(httpClient =>\n            {\n                httpClient.DefaultRequestHeaders.Add("X-Organization", "XboxDownload");\n                httpClient.DefaultRequestHeaders.Add("X-Author", "Devil");\n            }).ConfigurePrimaryHttpMessageHandler(() => new HttpClientHandler\n            {\n                AutomaticDecompression = DecompressionMethods.All\n            });\n            services.AddHttpClient("Nothing").ConfigurePrimaryHttpMessageHandler(() => new HttpClientHandler\n            {\n                AutomaticDecompression = DecompressionMethods.All\n            });\n            httpClientFactory = services.BuildServiceProvider().GetRequiredService<IHttpClientFactory>();\n        }\n\n        public static string HttpResponseContent(string url, string method = "GET", string? postData = null, string? contentType = null, Dictionary<string, string>? headers = null, int timeOut = 30000, string? name = null, CancellationToken? cts = null, string? charset = null)\n        {\n            using HttpResponseMessage? response = HttpResponseMessage(url, method, postData, contentType, headers, timeOut, name, cts);\n            if (response != null && response.IsSuccessStatusCode)\n            {\n                if (charset == null)\n                {\n                    return response.Content.ReadAsStringAsync().Result;\n                }\n                else\n                {\n                    return Encoding.GetEncoding(charset).GetString(response.Content.ReadAsByteArrayAsync().Result);\n                }\n            }\n            else\n            {\n                return string.Empty;\n            }\n        }\n\n        public static HttpResponseMessage? HttpResponseMessage(string url, string method = "GET", string? postData = null, string? contentType = null, Dictionary<string, string>? headers = null, int timeOut = 30000, string? name = null, CancellationToken? cts = null)\n        {\n            HttpResponseMessage? response = null;\n            var client = httpClientFactory?.CreateClient(name ?? "default");\n            if (client != null)\n            {\n                client.Timeout = TimeSpan.FromMilliseconds(timeOut);\n                if (headers != null)\n                {\n                    foreach (var header in headers)\n                    {\n                        if (string.IsNullOrEmpty(header.Value)) continue;\n                        switch (header.Key)\n                        {\n                            case "Host":\n                                client.DefaultRequestHeaders.Host = header.Value;\n                                break;\n                            case "Range":\n                                {\n                                    Match result = Regex.Match(header.Value, @"^(\\d+)-(\\d+)$");\n                                    if (result.Success)\n                                        client.DefaultRequestHeaders.Range = new RangeHeaderValue(long.Parse(result.Groups[1].Value), long.Parse(result.Groups[2].Value));\n                                }\n                                break;\n                            default:\n                                client.DefaultRequestHeaders.Add(header.Key, header.Value);\n                                break;\n                        }\n                    }\n                }\n                HttpRequestMessage httpRequestMessage = new()\n                {\n                    Method = new HttpMethod(method),\n                    RequestUri = new Uri(url)\n                };\n                if (postData != null && httpRequestMessage.Method == HttpMethod.Post)\n                    httpRequestMessage.Content = new StringContent(postData, Encoding.UTF8, contentType ?? "application/x-www-form-urlencoded");\n                try\n                {\n                    if (cts == null)\n                        response = client.SendAsync(httpRequestMessage).Result;\n                    else\n                        response = client.SendAsync(httpRequestMessage, (CancellationToken)cts).Result;\n                }\n                catch (Exception ex)\n                {\n                    response = new HttpResponseMessage(HttpStatusCode.ServiceUnavailable)\n                    {\n                        ReasonPhrase = ex.Message\n                    };\n                    Debug.WriteLine(ex.Message + " " + httpRequestMessage.RequestUri);\n                }\n            }\n            return response;\n        }\n\n        public static async Task DownloadFile(string url, FileInfo fi)\n        {\n            var client = httpClientFactory?.CreateClient("default");\n            if (client != null)\n            {\n                using var response = await client.GetAsync(url);\n                if (response != null && response.IsSuccessStatusCode)\n                {\n                    using var stream = await response.Content.ReadAsStreamAsync();\n                    if (stream.Length > 0)\n                    {\n                        try\n                        {\n                            if (fi.DirectoryName != null && !Directory.Exists(fi.DirectoryName))\n                                Directory.CreateDirectory(fi.DirectoryName);\n                            using var fileStream = fi.Create();\n                            await stream.CopyToAsync(fileStream);\n                            fi.Refresh();\n                        }\n                        catch (Exception ex)\n                        {\n                            Debug.WriteLine(ex.Message);\n                        }\n                    }\n                }\n            }\n        }\n\n        public static String UrlEncode(string str)\n        {\n            if (String.IsNullOrEmpty(str)) return string.Empty;\n            return UrlEncoder.Default.Encode(str);\n        }\n\n        public static string GetMimeMapping(string path)\n        {\n            ClassFileContentType.TryGetContentType(path, out string? contentType);\n            return contentType ?? "application/octet-stream";\n        }\n\n        public static SocketPackage TcpRequest(Uri uri, Byte[] send, String? host = null, Boolean decode = false, String? charset = null, Int32 timeout = 30000, CancellationTokenSource? cts = null)\n        {\n            SocketPackage socketPackage = new()\n            {\n                Uri = uri\n            };\n            String contentencoding = string.Empty;\n            List<Byte> list = new();\n            DateTime endtime = DateTime.Now.AddMilliseconds(timeout);\n            using (Socket mySocket = new(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp))\n            {\n                mySocket.SetSocketOption(SocketOptionLevel.Socket, SocketOptionName.SendTimeout, true);\n                mySocket.SetSocketOption(SocketOptionLevel.Socket, SocketOptionName.ReceiveTimeout, true);\n                mySocket.SendTimeout = 6000;\n                mySocket.ReceiveTimeout = 6000;\n                try\n                {\n                    if (host == null)\n                        mySocket.Connect(uri.Host, uri.Port);\n                    else\n                        mySocket.Connect(host, uri.Port);\n                }\n                catch (Exception ex)\n                {\n                    socketPackage.Err = ex.Message;\n                }\n                if (mySocket.Connected)\n                {\n                    Byte[] bReceive = new Byte[4096];\n                    Int32 len = -1;\n                    long ContentLength = -1;\n                    String TransferEncoding = "";\n                    mySocket.Send(send, 0, send.Length, SocketFlags.None, out SocketError errorCode);\n                    while ((len = mySocket.Receive(bReceive, 0, bReceive.Length, SocketFlags.None, out errorCode)) > 0)\n                    {\n                        if (len == bReceive.Length) list.AddRange(bReceive);\n                        else\n                        {\n                            Byte[] dest = new Byte[len];\n                            Buffer.BlockCopy(bReceive, 0, dest, 0, len);\n                            list.AddRange(dest);\n                        }\n                        if (String.IsNullOrEmpty(socketPackage.Headers))\n                        {\n                            Byte[] bytes = list.ToArray();\n                            for (int i = 1; i <= bytes.Length - 4; i++)\n                            {\n                                if (BitConverter.ToString(bytes, i, 4) == "0D-0A-0D-0A")\n                                {\n                                    list.Clear();\n                                    Byte[] dest = new Byte[bytes.Length - i - 4];\n                                    Buffer.BlockCopy(bytes, i + 4, dest, 0, dest.Length);\n                                    list.AddRange(dest);\n\n                                    socketPackage.Headers = Encoding.ASCII.GetString(bytes, 0, i + 4);\n                                    Match result = Regex.Match(socketPackage.Headers, @"Content-Length:\\s*(?<ContentLength>\\d+)", RegexOptions.IgnoreCase);\n                                    if (result.Success)\n                                    {\n                                        ContentLength = Convert.ToInt32(result.Groups["ContentLength"].Value);\n                                    }\n                                    result = Regex.Match(socketPackage.Headers, @"Transfer-Encoding:\\s*(?<TransferEncoding>.+)", RegexOptions.IgnoreCase);\n                                    if (result.Success)\n                                    {\n                                        TransferEncoding = result.Groups["TransferEncoding"].Value.Trim();\n                                    }\n                                    result = Regex.Match(socketPackage.Headers, @"Content-Encoding:\\s*(?<ContentEncoding>.+)", RegexOptions.IgnoreCase);\n                                    if (result.Success)\n                                    {\n                                        contentencoding = result.Groups["ContentEncoding"].Value.Trim().ToLower();\n                                    }\n                                    if (decode && String.IsNullOrEmpty(charset))\n                                    {\n                                        result = Regex.Match(socketPackage.Headers, @"Content-Type:.*charset=(?<charset>.+)", RegexOptions.IgnoreCase);\n                                        if (result.Success)\n                                        {\n                                            charset = result.Groups["charset"].Value.Trim();\n                                        }\n                                    }\n                                    break;\n                                }\n                            }\n                        }\n                        if (!String.IsNullOrEmpty(socketPackage.Headers))\n                        {\n                            if (TransferEncoding == "chunked")\n                            {\n                                Byte[] bytes = list.ToArray();\n                                if (bytes.Length >= 5 && BitConverter.ToString(bytes, bytes.Length - 5) == "30-0D-0A-0D-0A")\n                                {\n                                    list.Clear();\n                                    int step = 0;\n                                    for (int i = 1; i < bytes.Length - 1; i++)\n                                    {\n                                        if (BitConverter.ToString(bytes, i, 2) == "0D-0A")\n                                        {\n                                            Int32.TryParse(Encoding.ASCII.GetString(bytes, step, i - step), System.Globalization.NumberStyles.HexNumber, null, out int chunk);\n                                            if (chunk == 0) break;\n\n                                            Byte[] dest = new Byte[chunk];\n                                            Buffer.BlockCopy(bytes, i + 2, dest, 0, dest.Length);\n                                            list.AddRange(dest);\n\n                                            i = step = i + 2 + chunk;\n                                        }\n                                    }\n                                    break;\n                                }\n                            }\n                            else if (ContentLength >= 0)\n                            {\n                                if (list.Count == ContentLength) break;\n                            }\n                            else break;\n                        }\n                        if ((cts != null && cts.IsCancellationRequested) || DateTime.Compare(endtime, DateTime.Now) < 0) break;\n                    }\n                    if (errorCode.ToString() != "Success")\n                        socketPackage.Err = errorCode.ToString();\n                }\n                if (mySocket.Connected)\n                {\n                    try\n                    {\n                        mySocket.Shutdown(SocketShutdown.Both);\n                    }\n                    finally\n                    {\n                        mySocket.Close();\n                    }\n                }\n                mySocket.Dispose();\n            }\n            socketPackage.Buffer = ClassWeb.DeCompress(list.ToArray(), contentencoding);\n            if (decode)\n            {\n                if (String.IsNullOrEmpty(charset)) charset = "utf-8";\n                socketPackage.Html = Encoding.GetEncoding(charset).GetString(socketPackage.Buffer);\n            }\n            return socketPackage;\n        }\n\n        public static SocketPackage TlsRequest(Uri uri, Byte[] send, String? host = null, Boolean decode = false, String? charset = null, Int32 timeout = 30000, CancellationTokenSource? cts = null)\n        {\n            SocketPackage socketPackage = new()\n            {\n                Uri = uri\n            };\n            String contentencoding = string.Empty;\n            List<Byte> list = new();\n            DateTime endtime = DateTime.Now.AddMilliseconds(timeout);\n            using (Socket mySocket = new(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp))\n            {\n                mySocket.SetSocketOption(SocketOptionLevel.Socket, SocketOptionName.SendTimeout, true);\n                mySocket.SetSocketOption(SocketOptionLevel.Socket, SocketOptionName.ReceiveTimeout, true);\n                mySocket.SendTimeout = 6000;\n                mySocket.ReceiveTimeout = 6000;\n                try\n                {\n                    if (host == null)\n                        mySocket.Connect(uri.Host, uri.Port);\n                    else\n                        mySocket.Connect(host, uri.Port);\n                }\n                catch (Exception ex)\n                {\n                    socketPackage.Err = ex.Message;\n                }\n                if (mySocket.Connected)\n                {\n                    using SslStream ssl = new(new NetworkStream(mySocket), false, new RemoteCertificateValidationCallback(delegate (object sender, X509Certificate? certificate, X509Chain? chain, SslPolicyErrors sslPolicyErrors) { return true; }), null);\n                    ssl.WriteTimeout = timeout;\n                    ssl.ReadTimeout = timeout;\n                    try\n                    {\n                        ssl.AuthenticateAsClient(uri.Host, null, SslProtocols.Tls13 | SslProtocols.Tls12 | SslProtocols.Tls11 | SslProtocols.Tls, false);\n                        if (ssl.IsAuthenticated)\n                        {\n                            Byte[] bReceive = new Byte[4096];\n                            Int32 len = -1;\n                            long ContentLength = -1;\n                            String TransferEncoding = "";\n                            ssl.Write(send);\n                            ssl.Flush();\n                            while ((len = ssl.Read(bReceive, 0, bReceive.Length)) > 0)\n                            {\n                                if (len == bReceive.Length) list.AddRange(bReceive);\n                                else\n                                {\n                                    Byte[] dest = new Byte[len];\n                                    Buffer.BlockCopy(bReceive, 0, dest, 0, len);\n                                    list.AddRange(dest);\n                                }\n                                if (String.IsNullOrEmpty(socketPackage.Headers))\n                                {\n                                    Byte[] bytes = list.ToArray();\n                                    for (int i = 1; i <= bytes.Length - 4; i++)\n                                    {\n                                        if (BitConverter.ToString(bytes, i, 4) == "0D-0A-0D-0A")\n                                        {\n                                            list.Clear();\n                                            Byte[] dest = new Byte[bytes.Length - i - 4];\n                                            Buffer.BlockCopy(bytes, i + 4, dest, 0, dest.Length);\n                                            list.AddRange(dest);\n\n                                            socketPackage.Headers = Encoding.ASCII.GetString(bytes, 0, i + 4);\n                                            Match result = Regex.Match(socketPackage.Headers, @"Content-Length:\\s*(?<ContentLength>\\d+)", RegexOptions.IgnoreCase);\n                                            if (result.Success)\n                                            {\n                                                ContentLength = Convert.ToInt32(result.Groups["ContentLength"].Value);\n                                            }\n                                            result = Regex.Match(socketPackage.Headers, @"Transfer-Encoding:\\s*(?<TransferEncoding>.+)", RegexOptions.IgnoreCase);\n                                            if (result.Success)\n                                            {\n                                                TransferEncoding = result.Groups["TransferEncoding"].Value.Trim();\n                                            }\n                                            result = Regex.Match(socketPackage.Headers, @"Content-Encoding:\\s*(?<ContentEncoding>.+)", RegexOptions.IgnoreCase);\n                                            if (result.Success)\n                                            {\n                                                contentencoding = result.Groups["ContentEncoding"].Value.Trim().ToLower();\n                                            }\n                                            if (decode && String.IsNullOrEmpty(charset))\n                                            {\n                                                result = Regex.Match(socketPackage.Headers, @"Content-Type:.*charset=(?<charset>.+)", RegexOptions.IgnoreCase);\n                                                if (result.Success)\n                                                {\n                                                    charset = result.Groups["charset"].Value.Trim();\n                                                }\n                                            }\n                                            break;\n                                        }\n                                    }\n                                }\n                                if (!String.IsNullOrEmpty(socketPackage.Headers))\n                                {\n                                    if (TransferEncoding == "chunked")\n                                    {\n                                        Byte[] bytes = list.ToArray();\n                                        if (bytes.Length >= 5 && BitConverter.ToString(bytes, bytes.Length - 5) == "30-0D-0A-0D-0A")\n                                        {\n                                            list.Clear();\n                                            int step = 0;\n                                            for (int i = 1; i < bytes.Length - 1; i++)\n                                            {\n                                                if (BitConverter.ToString(bytes, i, 2) == "0D-0A")\n                                                {\n                                                    Int32.TryParse(Encoding.ASCII.GetString(bytes, step, i - step), System.Globalization.NumberStyles.HexNumber, null, out int chunk);\n                                                    if (chunk == 0) break;\n\n                                                    Byte[] dest = new Byte[chunk];\n                                                    Buffer.BlockCopy(bytes, i + 2, dest, 0, dest.Length);\n                                                    list.AddRange(dest);\n\n                                                    i = step = i + 2 + chunk;\n                                                }\n                                            }\n                                            break;\n                                        }\n                                    }\n                                    else if (ContentLength >= 0)\n                                    {\n                                        if (list.Count == ContentLength) break;\n                                    }\n                                    else break;\n                                }\n                                if ((cts != null && cts.IsCancellationRequested) || DateTime.Compare(endtime, DateTime.Now) < 0) break;\n                            }\n                        }\n                    }\n                    catch (Exception ex)\n                    {\n                        socketPackage.Err = ex.Message;\n                    }\n                    finally\n                    {\n                        ssl.Close();\n                    }\n                }\n                if (mySocket.Connected)\n                {\n                    try\n                    {\n                        mySocket.Shutdown(SocketShutdown.Both);\n                    }\n                    finally\n                    {\n                        mySocket.Close();\n                    }\n                }\n                mySocket.Dispose();\n            }\n            socketPackage.Buffer = DeCompress(list.ToArray(), contentencoding);\n            if (decode)\n            {\n                if (String.IsNullOrEmpty(charset)) charset = "utf-8";\n                socketPackage.Html = Encoding.GetEncoding(charset).GetString(socketPackage.Buffer);\n            }\n            return socketPackage;\n        }\n\n        public static bool ConnectTest(Uri uri, IPAddress ip, out string errMsg)\n        {\n            bool verified = false;\n            errMsg = "";\n            using (Socket mySocket = new(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp))\n            {\n                mySocket.SetSocketOption(SocketOptionLevel.Socket, SocketOptionName.SendTimeout, true);\n                mySocket.SetSocketOption(SocketOptionLevel.Socket, SocketOptionName.ReceiveTimeout, true);\n                mySocket.SendTimeout = 6000;\n                mySocket.ReceiveTimeout = 6000;\n                try\n                {\n                    mySocket.Connect(ip, uri.Port);\n                }\n                catch (Exception ex)\n                {\n                    errMsg = ex.Message;\n                }\n                if (mySocket.Connected)\n                {\n                    using SslStream ssl = new(new NetworkStream(mySocket), false, new RemoteCertificateValidationCallback(delegate (object sender, X509Certificate? certificate, X509Chain? chain, SslPolicyErrors sslPolicyErrors) { return sslPolicyErrors == SslPolicyErrors.None; }), null);\n                    try\n                    {\n                        ssl.AuthenticateAsClient(uri.Host, null, SslProtocols.Tls13 | SslProtocols.Tls12 | SslProtocols.Tls11 | SslProtocols.Tls, true);\n                        if (ssl.IsAuthenticated)\n                        {\n                            verified = true;\n                        }\n                    }\n                    catch (Exception ex)\n                    {\n                        errMsg = ex.Message;\n                    }\n                    finally\n                    {\n                        ssl.Close();\n                    }\n                }\n                mySocket.Close();\n                mySocket.Dispose();\n            }\n            return verified;\n        }\n\n        public static Byte[] DeCompress(Byte[] buffer, String contentencoding)\n        {\n            switch (contentencoding)\n            {\n                case "gzip":\n                    using (MemoryStream memoryStream = new(buffer))\n                    {\n                        using GZipStream zipStream = new(memoryStream, CompressionMode.Decompress);\n                        using MemoryStream outputStream = new();\n                        try\n                        {\n                            zipStream.CopyTo(outputStream);\n                        }\n                        catch { }\n                        return outputStream.ToArray();\n                    }\n                case "deflate":\n                    using (MemoryStream memoryStream = new(buffer))\n                    {\n                        using DeflateStream zipStream = new(memoryStream, CompressionMode.Decompress);\n                        using MemoryStream outputStream = new();\n                        try\n                        {\n                            zipStream.CopyTo(outputStream);\n                        }\n                        catch { }\n                        return outputStream.ToArray();\n                    }\n                case "br":\n                    using (MemoryStream memoryStream = new(buffer))\n                    {\n                        using BrotliStream zipStream = new(memoryStream, CompressionMode.Decompress);\n                        using MemoryStream outputStream = new();\n                        try\n                        {\n                            zipStream.CopyTo(outputStream);\n                        }\n                        catch { }\n                        return outputStream.ToArray();\n                    }\n                default:\n                    return buffer;\n            }\n        }\n\n        internal static Object docLock = new();\n        internal static WebBrowser? webb = null;\n        internal static HtmlDocument? doc = null;\n\n        public static void SetHtmlDocument(string strHtml, bool executeScript)\n        {\n            if (Application.OpenForms[0].InvokeRequired)\n            {\n                Application.OpenForms[0].Invoke(new MethodInvoker(() => { SetHtmlDocument(strHtml, executeScript); }));\n                return;\n            }\n            if (!executeScript)\n            {\n                strHtml = Regex.Replace(strHtml, "<script", "<!--<script", RegexOptions.IgnoreCase);\n                strHtml = Regex.Replace(strHtml, "</script>", "</script>!-->", RegexOptions.IgnoreCase);\n            }\n            webb = new WebBrowser() { ScriptErrorsSuppressed = true };\n            webb.Navigate("about:blank");\n            doc = webb.Document.OpenNew(true);\n            doc.Write(strHtml);\n        }\n\n        public static void ObjectDisposed()\n        {\n            if (Application.OpenForms[0].InvokeRequired)\n            {\n                Application.OpenForms[0].Invoke(new MethodInvoker(() => { ObjectDisposed(); }));\n                return;\n            }\n            doc = null;\n            webb?.Dispose();\n            webb = null;\n        }\n    }\n\n    internal class SocketPackage\n    {\n        public Uri? Uri;\n        public String Err = "", Headers = "", Html = "";\n        public Byte[] Buffer = Array.Empty<Byte>();\n\n        public String All\n        {\n            get { return "==========Uri==========\\r\\n" + this.Uri + "\\r\\n==========Err==========\\r\\n" + this.Err + "\\r\\n==========Headers==========\\r\\n" + this.Headers + "\\r\\n==========Html==========\\r\\n" + this.Html; }\n        }\n    }\n}\n'