b'/* \n * Fast QR Code generator library\n * \n * Copyright (c) Project Nayuki. (MIT License)\n * https://www.nayuki.io/page/fast-qr-code-generator-library\n * \n * Permission is hereby granted, free of charge, to any person obtaining a copy of\n * this software and associated documentation files (the "Software"), to deal in\n * the Software without restriction, including without limitation the rights to\n * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of\n * the Software, and to permit persons to whom the Software is furnished to do so,\n * subject to the following conditions:\n * - The above copyright notice and this permission notice shall be included in\n *   all copies or substantial portions of the Software.\n * - The Software is provided "as is", without warranty of any kind, express or\n *   implied, including but not limited to the warranties of merchantability,\n *   fitness for a particular purpose and noninfringement. In no event shall the\n *   authors or copyright holders be liable for any claim, damages or other\n *   liability, whether in an action of contract, tort or otherwise, arising from,\n *   out of or in connection with the Software or the use or other dealings in the\n *   Software.\n */\n\npackage io.nayuki.fastqrcodegen;\n\nimport java.lang.ref.SoftReference;\nimport java.util.HashSet;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.function.Function;\n\n\n// A thread-safe cache based on soft references.\nfinal class Memoizer<T,R> {\n\t\n\tprivate final Function<T,R> function;\n\tMap<T,SoftReference<R>> cache = new ConcurrentHashMap<>();\n\tprivate Set<T> pending = new HashSet<>();\n\t\n\t\n\t// Creates a memoizer based on the given function that takes one input to compute an output.\n\tpublic Memoizer(Function<T,R> func) {\n\t\tfunction = func;\n\t}\n\t\n\t\n\t// Computes function.apply(arg) or returns a cached copy of a previous call.\n\tpublic R get(T arg) {\n\t\t// Non-blocking fast path\n\t\t{\n\t\t\tSoftReference<R> ref = cache.get(arg);\n\t\t\tif (ref != null) {\n\t\t\t\tR result = ref.get();\n\t\t\t\tif (result != null)\n\t\t\t\t\treturn result;\n\t\t\t}\n\t\t}\n\t\t\n\t\t// Sequential slow path\n\t\twhile (true) {\n\t\t\tsynchronized(this) {\n\t\t\t\tSoftReference<R> ref = cache.get(arg);\n\t\t\t\tif (ref != null) {\n\t\t\t\t\tR result = ref.get();\n\t\t\t\t\tif (result != null)\n\t\t\t\t\t\treturn result;\n\t\t\t\t\tcache.remove(arg);\n\t\t\t\t}\n\t\t\t\tassert !cache.containsKey(arg);\n\t\t\t\t\n\t\t\t\tif (pending.add(arg))\n\t\t\t\t\tbreak;\n\t\t\t\t\n\t\t\t\ttry {\n\t\t\t\t\tthis.wait();\n\t\t\t\t} catch (InterruptedException e) {\n\t\t\t\t\tthrow new RuntimeException(e);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\ttry {\n\t\t\tR result = function.apply(arg);\n\t\t\tcache.put(arg, new SoftReference<>(result));\n\t\t\treturn result;\n\t\t} finally {\n\t\t\tsynchronized(this) {\n\t\t\t\tpending.remove(arg);\n\t\t\t\tthis.notifyAll();\n\t\t\t}\n\t\t}\n\t}\n\t\n}\n'