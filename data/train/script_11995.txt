b'using System;\nusing System.Diagnostics;\nusing System.Text;\n\nnamespace CS_SQLite3\n{\n  using sqlite3_value = CSSQLite.Mem;\n\n  public partial class CSSQLite\n  {\n    /*\n    ** 2003 January 11\n    **\n    ** The author disclaims copyright to this source code.  In place of\n    ** a legal notice, here is a blessing:\n    **\n    **    May you do good and not evil.\n    **    May you find forgiveness for yourself and forgive others.\n    **    May you share freely, never taking more than you give.\n    **\n    *************************************************************************\n    ** This file contains code used to implement the sqlite3_set_authorizer()\n    ** API.  This facility is an optional feature of the library.  Embedded\n    ** systems that do not need this facility may omit it by recompiling\n    ** the library with -DSQLITE_OMIT_AUTHORIZATION=1\n    **\n    ** $Id: auth.c,v 1.32 2009/07/02 18:40:35 danielk1977 Exp $\n    **\n    *************************************************************************\n    **  Included in SQLite3 port to C#-SQLite;  2008 Noah B Hart\n    **  C#-SQLite is an independent reimplementation of the SQLite software library\n    **\n    **  $Header$\n    *************************************************************************\n    */\n    //#include "sqliteInt.h"\n\n    /*\n    ** All of the code in this file may be omitted by defining a single\n    ** macro.\n    */\n#if !SQLITE_OMIT_AUTHORIZATION\n\n/*\n** Set or clear the access authorization function.\n**\n** The access authorization function is be called during the compilation\n** phase to verify that the user has read and/or write access permission on\n** various fields of the database.  The first argument to the auth function\n** is a copy of the 3rd argument to this routine.  The second argument\n** to the auth function is one of these constants:\n**\n**       SQLITE_CREATE_INDEX\n**       SQLITE_CREATE_TABLE\n**       SQLITE_CREATE_TEMP_INDEX\n**       SQLITE_CREATE_TEMP_TABLE\n**       SQLITE_CREATE_TEMP_TRIGGER\n**       SQLITE_CREATE_TEMP_VIEW\n**       SQLITE_CREATE_TRIGGER\n**       SQLITE_CREATE_VIEW\n**       SQLITE_DELETE\n**       SQLITE_DROP_INDEX\n**       SQLITE_DROP_TABLE\n**       SQLITE_DROP_TEMP_INDEX\n**       SQLITE_DROP_TEMP_TABLE\n**       SQLITE_DROP_TEMP_TRIGGER\n**       SQLITE_DROP_TEMP_VIEW\n**       SQLITE_DROP_TRIGGER\n**       SQLITE_DROP_VIEW\n**       SQLITE_INSERT\n**       SQLITE_PRAGMA\n**       SQLITE_READ\n**       SQLITE_SELECT\n**       SQLITE_TRANSACTION\n**       SQLITE_UPDATE\n**\n** The third and fourth arguments to the auth function are the name of\n** the table and the column that are being accessed.  The auth function\n** should return either SQLITE_OK, SQLITE_DENY, or SQLITE_IGNORE.  If\n** SQLITE_OK is returned, it means that access is allowed.  SQLITE_DENY\n** means that the SQL statement will never-run - the sqlite3_exec() call\n** will return with an error.  SQLITE_IGNORE means that the SQL statement\n** should run but attempts to read the specified column will return NULL\n** and attempts to write the column will be ignored.\n**\n** Setting the auth function to NULL disables this hook.  The default\n** setting of the auth function is NULL.\n*/\nint sqlite3_set_authorizer(\nsqlite3 *db,\nint (*xAuth)(void*,int,const char*,const char*,const char*,const char*),\nvoid *pArg\n){\nsqlite3_mutex_enter(db->mutex);\ndb->xAuth = xAuth;\ndb->pAuthArg = pArg;\nsqlite3ExpirePreparedStatements(db);\nsqlite3_mutex_leave(db->mutex);\nreturn SQLITE_OK;\n}\n\n/*\n** Write an error message into pParse->zErrMsg that explains that the\n** user-supplied authorization function returned an illegal value.\n*/\nstatic void sqliteAuthBadReturnCode(Parse *pParse){\nsqlite3ErrorMsg(pParse, "authorizer malfunction");\npParse->rc = SQLITE_ERROR;\n}\n\n/*\n** The pExpr should be a TK_COLUMN expression.  The table referred to\n** is in pTabList or else it is the NEW or OLD table of a trigger.\n** Check to see if it is OK to read this particular column.\n**\n** If the auth function returns SQLITE_IGNORE, change the TK_COLUMN\n** instruction into a TK_NULL.  If the auth function returns SQLITE_DENY,\n** then generate an error.\n*/\nvoid sqlite3AuthRead(\nParse *pParse,        /* The parser context */\nExpr *pExpr,          /* The expression to check authorization on */\nSchema *pSchema,      /* The schema of the expression */\nSrcList *pTabList     /* All table that pExpr might refer to */\n){\nsqlite3 *db = pParse->db;\nint rc;\nTable *pTab = 0;      /* The table being read */\nconst char *zCol;     /* Name of the column of the table */\nint iSrc;             /* Index in pTabList->a[] of table being read */\nconst char *zDBase;   /* Name of database being accessed */\nint iDb;              /* The index of the database the expression refers to */\n\nif( db->xAuth==0 ) return;\nassert( pExpr->op==TK_COLUMN );\niDb = sqlite3SchemaToIndex(pParse->db, pSchema);\nif( iDb<0 ){\n/* An attempt to read a column out of a subquery or other\n** temporary table. */\nreturn;\n}\nif( pTabList ){\n    for(iSrc=0; iSrc<pTabList->nSrc; iSrc++){\n      if( pExpr->iTable==pTabList->a[iSrc].iCursor ){\n        pTab = pTabList->a[iSrc].pTab;\n\tbreak;\n      }\n    }\n  }\n  if( !pTab ){\n    TriggerStack *pStack = pParse->trigStack;\nif( ALWAYS(pStack) ){\n/* This must be an attempt to read the NEW or OLD pseudo-tables\n** of a trigger. */\nassert( pExpr->iTable==pStack->newIdx || pExpr->iTable==pStack->oldIdx );\npTab = pStack->pTab;\n}\n}\nif( NEVER(pTab==0) ) return;\nif( pExpr->iColumn>=0 ){\nassert( pExpr->iColumn<pTab->nCol );\nzCol = pTab->aCol[pExpr->iColumn].zName;\n}else if( pTab->iPKey>=0 ){\nassert( pTab->iPKey<pTab->nCol );\nzCol = pTab->aCol[pTab->iPKey].zName;\n}else{\nzCol = "ROWID";\n}\nassert( iDb>=0 && iDb<db->nDb );\nzDBase = db->aDb[iDb].zName;\nrc = db->xAuth(db->pAuthArg, SQLITE_READ, pTab->zName, zCol, zDBase,\npParse->zAuthContext);\nif( rc==SQLITE_IGNORE ){\npExpr->op = TK_NULL;\n}else if( rc==SQLITE_DENY ){\nif( db->nDb>2 || iDb!=0 ){\nsqlite3ErrorMsg(pParse, "access to %s.%s.%s is prohibited",\nzDBase, pTab->zName, zCol);\n}else{\nsqlite3ErrorMsg(pParse, "access to %s.%s is prohibited",pTab->zName,zCol);\n}\npParse->rc = SQLITE_AUTH;\n}else if( rc!=SQLITE_OK ){\nsqliteAuthBadReturnCode(pParse);\n}\n}\n\n/*\n** Do an authorization check using the code and arguments given.  Return\n** either SQLITE_OK (zero) or SQLITE_IGNORE or SQLITE_DENY.  If SQLITE_DENY\n** is returned, then the error count and error message in pParse are\n** modified appropriately.\n*/\nint sqlite3AuthCheck(\nParse *pParse,\nint code,\nconst char *zArg1,\nconst char *zArg2,\nconst char *zArg3\n){\nsqlite3 *db = pParse->db;\nint rc;\n\n/* Don\'t do any authorization checks if the database is initialising\n** or if the parser is being invoked from within sqlite3_declare_vtab.\n*/\nif( db->init.busy || IN_DECLARE_VTAB ){\nreturn SQLITE_OK;\n}\n\nif( db->xAuth==0 ){\nreturn SQLITE_OK;\n}\nrc = db->xAuth(db->pAuthArg, code, zArg1, zArg2, zArg3, pParse->zAuthContext);\nif( rc==SQLITE_DENY ){\nsqlite3ErrorMsg(pParse, "not authorized");\npParse->rc = SQLITE_AUTH;\n}else if( rc!=SQLITE_OK && rc!=SQLITE_IGNORE ){\nrc = SQLITE_DENY;\nsqliteAuthBadReturnCode(pParse);\n}\nreturn rc;\n}\n\n/*\n** Push an authorization context.  After this routine is called, the\n** zArg3 argument to authorization callbacks will be zContext until\n** popped.  Or if pParse==0, this routine is a no-op.\n*/\nvoid sqlite3AuthContextPush(\nParse *pParse,\nAuthContext *pContext,\nconst char *zContext\n){\nassert( pParse );\npContext->pParse = pParse;\npContext->zAuthContext = pParse->zAuthContext;\npParse->zAuthContext = zContext;\n}\n\n/*\n** Pop an authorization context that was previously pushed\n** by sqlite3AuthContextPush\n*/\nvoid sqlite3AuthContextPop(AuthContext *pContext){\nif( pContext->pParse ){\npContext->pParse->zAuthContext = pContext->zAuthContext;\npContext->pParse = 0;\n}\n}\n\n#endif //* SQLITE_OMIT_AUTHORIZATION */\n  }\n}\n'