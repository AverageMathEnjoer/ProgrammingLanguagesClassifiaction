b'{-# LANGUAGE BangPatterns #-}\n{-# LANGUAGE PatternGuards #-}\n{-# LANGUAGE CPP #-}\n#if __GLASGOW_HASKELL__\n{-# LANGUAGE DeriveDataTypeable #-}\n{-# LANGUAGE DeriveGeneric #-}\n{-# LANGUAGE DeriveLift #-}\n{-# LANGUAGE Trustworthy #-}\n#endif\n\n#include "containers.h"\n\n-----------------------------------------------------------------------------\n-- |\n-- Module      :  Data.Tree\n-- Copyright   :  (c) The University of Glasgow 2002\n-- License     :  BSD-style (see the file libraries/base/LICENSE)\n--\n-- Maintainer  :  libraries@haskell.org\n-- Portability :  portable\n--\n-- = Multi-way Trees and Forests\n--\n-- The @\'Tree\' a@ type represents a lazy, possibly infinite, multi-way tree\n-- (also known as a /rose tree/).\n--\n-- The @\'Forest\' a@ type represents a forest of @\'Tree\' a@s.\n--\n-----------------------------------------------------------------------------\n\nmodule Data.Tree(\n\n    -- * Trees and Forests\n      Tree(..)\n    , Forest\n\n    -- * Construction\n    , unfoldTree\n    , unfoldForest\n    , unfoldTreeM\n    , unfoldForestM\n    , unfoldTreeM_BF\n    , unfoldForestM_BF\n\n    -- * Elimination\n    , foldTree\n    , flatten\n    , levels\n\n    -- * Ascii Drawings\n    , drawTree\n    , drawForest\n\n    ) where\n\nimport Utils.Containers.Internal.Prelude as Prelude\nimport Prelude ()\nimport Data.Foldable (fold, foldl\', toList)\nimport Data.Traversable (foldMapDefault)\nimport Control.Monad (liftM)\nimport Control.Monad.Fix (MonadFix (..), fix)\nimport Data.Sequence (Seq, empty, singleton, (<|), (|>), fromList,\n            ViewL(..), ViewR(..), viewl, viewr)\nimport Control.DeepSeq (NFData(rnf))\n\n#ifdef __GLASGOW_HASKELL__\nimport Data.Data (Data)\nimport GHC.Generics (Generic, Generic1)\nimport Language.Haskell.TH.Syntax (Lift)\n-- See Note [ Template Haskell Dependencies ]\nimport Language.Haskell.TH ()\n#endif\n\nimport Control.Monad.Zip (MonadZip (..))\n\nimport Data.Coerce\n\nimport Data.Functor.Classes\n\n#if !MIN_VERSION_base(4,11,0)\nimport Data.Semigroup (Semigroup (..))\n#endif\n\n#if MIN_VERSION_base(4,18,0)\nimport qualified Data.Foldable1 as Foldable1\nimport Data.List.NonEmpty (NonEmpty(..))\n#endif\n\n-- | Non-empty, possibly infinite, multi-way trees; also known as /rose trees/.\ndata Tree a = Node {\n        rootLabel :: a,         -- ^ label value\n        subForest :: [Tree a]   -- ^ zero or more child trees\n    }\n#ifdef __GLASGOW_HASKELL__\n  deriving ( Eq\n           , Ord -- ^ @since 0.6.5\n           , Read\n           , Show\n           , Data\n           , Generic  -- ^ @since 0.5.8\n           , Generic1 -- ^ @since 0.5.8\n           , Lift -- ^ @since 0.6.6\n           )\n#else\n  deriving (Eq, Ord, Read, Show)\n#endif\n\n-- | This type synonym exists primarily for historical\n-- reasons.\ntype Forest a = [Tree a]\n\n-- | @since 0.5.9\ninstance Eq1 Tree where\n  liftEq eq = leq\n    where\n      leq (Node a fr) (Node a\' fr\') = eq a a\' && liftEq leq fr fr\'\n\n-- | @since 0.5.9\ninstance Ord1 Tree where\n  liftCompare cmp = lcomp\n    where\n      lcomp (Node a fr) (Node a\' fr\') = cmp a a\' <> liftCompare lcomp fr fr\'\n\n-- | @since 0.5.9\ninstance Show1 Tree where\n  liftShowsPrec shw shwl p (Node a fr) = showParen (p > 10) $\n        showString "Node {rootLabel = " . shw 0 a . showString ", " .\n          showString "subForest = " . liftShowList shw shwl fr .\n          showString "}"\n\n-- | @since 0.5.9\ninstance Read1 Tree where\n  liftReadsPrec rd rdl p = readParen (p > 10) $\n    \\s -> do\n      ("Node", s1) <- lex s\n      ("{", s2) <- lex s1\n      ("rootLabel", s3) <- lex s2\n      ("=", s4) <- lex s3\n      (a, s5) <- rd 0 s4\n      (",", s6) <- lex s5\n      ("subForest", s7) <- lex s6\n      ("=", s8) <- lex s7\n      (fr, s9) <- liftReadList rd rdl s8\n      ("}", s10) <- lex s9\n      pure (Node a fr, s10)\n\ninstance Functor Tree where\n    fmap = fmapTree\n    x <$ Node _ ts = Node x (map (x <$) ts)\n\nfmapTree :: (a -> b) -> Tree a -> Tree b\nfmapTree f (Node x ts) = Node (f x) (map (fmapTree f) ts)\n\n#ifdef __GLASGOW_HASKELL__\n{-# NOINLINE [1] fmapTree #-}\n{-# RULES\n"fmapTree/coerce" fmapTree coerce = coerce\n #-}\n#endif\n\ninstance Applicative Tree where\n    pure x = Node x []\n    Node f tfs <*> tx@(Node x txs) =\n        Node (f x) (map (f <$>) txs ++ map (<*> tx) tfs)\n#if MIN_VERSION_base(4,10,0)\n    liftA2 f (Node x txs) ty@(Node y tys) =\n        Node (f x y) (map (f x <$>) tys ++ map (\\tx -> liftA2 f tx ty) txs)\n#endif\n    Node x txs <* ty@(Node _ tys) =\n        Node x (map (x <$) tys ++ map (<* ty) txs)\n    Node _ txs *> ty@(Node y tys) =\n        Node y (tys ++ map (*> ty) txs)\n\ninstance Monad Tree where\n    return = pure\n    Node x ts >>= f = case f x of\n        Node x\' ts\' -> Node x\' (ts\' ++ map (>>= f) ts)\n\n-- | @since 0.5.11\ninstance MonadFix Tree where\n  mfix = mfixTree\n\nmfixTree :: (a -> Tree a) -> Tree a\nmfixTree f\n  | Node a children <- fix (f . rootLabel)\n  = Node a (zipWith (\\i _ -> mfixTree ((!! i) . subForest . f))\n                    [0..] children)\n\ninstance Traversable Tree where\n  traverse f = go\n    where go (Node x ts) = liftA2 Node (f x) (traverse go ts)\n  {-# INLINE traverse #-}\n\n-- | Folds in preorder\n\n-- See Note [Implemented Foldable Tree functions]\ninstance Foldable Tree where\n    fold = foldMap id\n    {-# INLINABLE fold #-}\n\n    foldMap = foldMapDefault\n    {-# INLINE foldMap #-}\n\n    foldr f z = \\t -> go t z  -- Use a lambda to allow inlining with two arguments\n      where\n        go (Node x ts) = f x . foldr (\\t k -> go t . k) id ts\n        -- This is equivalent to the following simpler definition, but has been found to optimize\n        -- better in benchmarks:\n        -- go (Node x ts) z\' = f x (foldr go z\' ts)\n    {-# INLINE foldr #-}\n\n    foldl\' f = go\n      where go !z (Node x ts) = foldl\' go (f z x) ts\n    {-# INLINE foldl\' #-}\n\n    foldr1 = foldrMap1 id\n\n    foldl1 = foldlMap1 id\n\n    null _ = False\n    {-# INLINE null #-}\n\n    elem = any . (==)\n    {-# INLINABLE elem #-}\n\n    maximum = foldlMap1\' id max\n    {-# INLINABLE maximum #-}\n\n    minimum = foldlMap1\' id min\n    {-# INLINABLE minimum #-}\n\n    sum = foldlMap1\' id (+)\n    {-# INLINABLE sum #-}\n\n    product = foldlMap1\' id (*)\n    {-# INLINABLE product #-}\n\n#if MIN_VERSION_base(4,18,0)\n-- | Folds in preorder\n--\n-- @since 0.6.7\n\n-- See Note [Implemented Foldable1 Tree functions]\ninstance Foldable1.Foldable1 Tree where\n  foldMap1 f = go\n    where\n      -- We\'d like to write\n      --\n      -- go (Node x (t : ts)) = f x <> Foldable1.foldMap1 go (t :| ts)\n      --\n      -- but foldMap1 for NonEmpty isn\'t very good, so we don\'t. See\n      -- https://github.com/haskell/containers/pull/921#issuecomment-1410398618\n      go (Node x []) = f x\n      go (Node x (t : ts)) =\n        f x <> Foldable1.foldrMap1 go (\\t\' z -> go t\' <> z) (t :| ts)\n  {-# INLINABLE foldMap1 #-}\n\n  foldMap1\' f = foldlMap1\' f (\\z x -> z <> f x)\n  {-# INLINABLE foldMap1\' #-}\n\n  toNonEmpty (Node x ts) = x :| concatMap toList ts\n\n  maximum = maximum\n  {-# INLINABLE maximum #-}\n\n  minimum = minimum\n  {-# INLINABLE minimum #-}\n\n  foldrMap1 = foldrMap1\n\n  foldlMap1\' = foldlMap1\'\n\n  foldlMap1 = foldlMap1\n#endif\n\nfoldrMap1 :: (a -> b) -> (a -> b -> b) -> Tree a -> b\nfoldrMap1 f g = go\n  where\n    go (Node x [])     = f x\n    go (Node x (t:ts)) = g x (foldrMap1NE go (\\t\' z -> foldr g z t\') t ts)\n{-# INLINE foldrMap1 #-}\n\n-- This is foldrMap1 for Data.List.NonEmpty, but is not available before\n-- base 4.18.\nfoldrMap1NE :: (a -> b) -> (a -> b -> b) -> a -> [a] -> b\nfoldrMap1NE f g = go\n  where\n    go x []      = f x\n    go x (x\':xs) = g x (go x\' xs)\n{-# INLINE foldrMap1NE #-}\n\nfoldlMap1\' :: (a -> b) -> (b -> a -> b) -> Tree a -> b\nfoldlMap1\' f g =  -- Use a lambda to allow inlining with two arguments\n  \\(Node x ts) -> foldl\' (foldl\' g) (f x) ts\n{-# INLINE foldlMap1\' #-}\n\nfoldlMap1 :: (a -> b) -> (b -> a -> b) -> Tree a -> b\nfoldlMap1 f g =  -- Use a lambda to allow inlining with two arguments\n  \\(Node x ts) -> foldl (foldl g) (f x) ts\n{-# INLINE foldlMap1 #-}\n\ninstance NFData a => NFData (Tree a) where\n    rnf (Node x ts) = rnf x `seq` rnf ts\n\n-- | @since 0.5.10.1\ninstance MonadZip Tree where\n  mzipWith f (Node a as) (Node b bs)\n    = Node (f a b) (mzipWith (mzipWith f) as bs)\n\n  munzip (Node (a, b) ts) = (Node a as, Node b bs)\n    where (as, bs) = munzip (map munzip ts)\n\n-- | 2-dimensional ASCII drawing of a tree.\n--\n-- ==== __Examples__\n--\n-- > putStr $ drawTree $ fmap show (Node 1 [Node 2 [], Node 3 []])\n--\n-- @\n-- 1\n-- |\n-- +- 2\n-- |\n-- `- 3\n-- @\n--\ndrawTree :: Tree String -> String\ndrawTree  = unlines . draw\n\n-- | 2-dimensional ASCII drawing of a forest.\n--\n-- ==== __Examples__\n--\n-- > putStr $ drawForest $ map (fmap show) [(Node 1 [Node 2 [], Node 3 []]), (Node 10 [Node 20 []])]\n--\n-- @\n-- 1\n-- |\n-- +- 2\n-- |\n-- `- 3\n--\n-- 10\n-- |\n-- `- 20\n-- @\n--\ndrawForest :: [Tree String] -> String\ndrawForest  = unlines . map drawTree\n\ndraw :: Tree String -> [String]\ndraw (Node x ts0) = lines x ++ drawSubTrees ts0\n  where\n    drawSubTrees [] = []\n    drawSubTrees [t] =\n        "|" : shift "`- " "   " (draw t)\n    drawSubTrees (t:ts) =\n        "|" : shift "+- " "|  " (draw t) ++ drawSubTrees ts\n\n    shift first other = zipWith (++) (first : repeat other)\n\n-- | Returns the elements of a tree in pre-order.\n--\n-- @\n--\n--   a\n--  / \\\\    => [a,b,c]\n-- b   c\n-- @\n--\n-- ==== __Examples__\n--\n-- > flatten (Node 1 [Node 2 [], Node 3 []]) == [1,2,3]\nflatten :: Tree a -> [a]\nflatten = toList\n\n-- | Returns the list of nodes at each level of the tree.\n--\n-- @\n--\n--   a\n--  / \\\\    => [[a], [b,c]]\n-- b   c\n-- @\n--\n-- ==== __Examples__\n--\n-- > levels (Node 1 [Node 2 [], Node 3 []]) == [[1],[2,3]]\n--\nlevels :: Tree a -> [[a]]\nlevels t =\n    map (map rootLabel) $\n        takeWhile (not . null) $\n        iterate (concatMap subForest) [t]\n\n-- | Fold a tree into a "summary" value in depth-first order.\n--\n-- For each node in the tree, apply @f@ to the @rootLabel@ and the result\n-- of applying @f@ to each @subForest@.\n--\n-- This is also known as the catamorphism on trees.\n--\n-- ==== __Examples__\n--\n-- Sum the values in a tree:\n--\n-- > foldTree (\\x xs -> sum (x:xs)) (Node 1 [Node 2 [], Node 3 []]) == 6\n--\n-- Find the maximum value in the tree:\n--\n-- > foldTree (\\x xs -> maximum (x:xs)) (Node 1 [Node 2 [], Node 3 []]) == 3\n--\n-- Count the number of leaves in the tree:\n--\n-- > foldTree (\\_ xs -> if null xs then 1 else sum xs) (Node 1 [Node 2 [], Node 3 []]) == 2\n--\n-- Find depth of the tree; i.e. the number of branches from the root of the tree to the furthest leaf:\n--\n-- > foldTree (\\_ xs -> if null xs then 0 else 1 + maximum xs) (Node 1 [Node 2 [], Node 3 []]) == 1\n--\n-- You can even implement traverse using foldTree:\n--\n-- > traverse\' f = foldTree (\\x xs -> liftA2 Node (f x) (sequenceA xs))\n--\n--\n-- @since 0.5.8\nfoldTree :: (a -> [b] -> b) -> Tree a -> b\nfoldTree f = go where\n    go (Node x ts) = f x (map go ts)\n\n-- | Build a (possibly infinite) tree from a seed value in breadth-first order.\n--\n-- @unfoldTree f b@ constructs a tree by starting with the tree\n-- @Node { rootLabel=b, subForest=[] }@ and repeatedly applying @f@ to each\n-- \'rootLabel\' value in the tree\'s leaves to generate its \'subForest\'.\n--\n-- For a monadic version see \'unfoldTreeM_BF\'.\n--\n-- ==== __Examples__\n--\n-- Construct the tree of @Integer@s where each node has two children:\n-- @left = 2*x@ and @right = 2*x + 1@, where @x@ is the \'rootLabel\' of the node.\n-- Stop when the values exceed 7.\n--\n-- > let buildNode x = if 2*x + 1 > 7 then (x, []) else (x, [2*x, 2*x+1])\n-- > putStr $ drawTree $ fmap show $ unfoldTree buildNode 1\n--\n-- @\n--\n-- 1\n-- |\n-- +- 2\n-- |  |\n-- |  +- 4\n-- |  |\n-- |  `- 5\n-- |\n-- `- 3\n--    |\n--    +- 6\n--    |\n--    `- 7\n-- @\n--\nunfoldTree :: (b -> (a, [b])) -> b -> Tree a\nunfoldTree f b = let (a, bs) = f b in Node a (unfoldForest f bs)\n\n-- | Build a (possibly infinite) forest from a list of seed values in\n-- breadth-first order.\n--\n-- @unfoldForest f seeds@ invokes \'unfoldTree\' on each seed value.\n--\n-- For a monadic version see \'unfoldForestM_BF\'.\n--\nunfoldForest :: (b -> (a, [b])) -> [b] -> [Tree a]\nunfoldForest f = map (unfoldTree f)\n\n-- | Monadic tree builder, in depth-first order.\nunfoldTreeM :: Monad m => (b -> m (a, [b])) -> b -> m (Tree a)\nunfoldTreeM f b = do\n    (a, bs) <- f b\n    ts <- unfoldForestM f bs\n    return (Node a ts)\n\n-- | Monadic forest builder, in depth-first order\nunfoldForestM :: Monad m => (b -> m (a, [b])) -> [b] -> m ([Tree a])\nunfoldForestM f = Prelude.mapM (unfoldTreeM f)\n\n-- | Monadic tree builder, in breadth-first order.\n--\n-- See \'unfoldTree\' for more info.\n--\n-- Implemented using an algorithm adapted from\n-- /Breadth-First Numbering: Lessons from a Small Exercise in Algorithm Design/,\n-- by Chris Okasaki, /ICFP\'00/.\nunfoldTreeM_BF :: Monad m => (b -> m (a, [b])) -> b -> m (Tree a)\nunfoldTreeM_BF f b = liftM getElement $ unfoldForestQ f (singleton b)\n  where\n    getElement xs = case viewl xs of\n        x :< _ -> x\n        EmptyL -> error "unfoldTreeM_BF"\n\n-- | Monadic forest builder, in breadth-first order\n--\n-- See \'unfoldForest\' for more info.\n--\n-- Implemented using an algorithm adapted from\n-- /Breadth-First Numbering: Lessons from a Small Exercise in Algorithm Design/,\n-- by Chris Okasaki, /ICFP\'00/.\nunfoldForestM_BF :: Monad m => (b -> m (a, [b])) -> [b] -> m ([Tree a])\nunfoldForestM_BF f = liftM toList . unfoldForestQ f . fromList\n\n-- Takes a sequence (queue) of seeds and produces a sequence (reversed queue) of\n-- trees of the same length.\nunfoldForestQ :: Monad m => (b -> m (a, [b])) -> Seq b -> m (Seq (Tree a))\nunfoldForestQ f aQ = case viewl aQ of\n    EmptyL -> return empty\n    a :< aQ\' -> do\n        (b, as) <- f a\n        tQ <- unfoldForestQ f (Prelude.foldl (|>) aQ\' as)\n        let (tQ\', ts) = splitOnto [] as tQ\n        return (Node b ts <| tQ\')\n  where\n    splitOnto :: [a\'] -> [b\'] -> Seq a\' -> (Seq a\', [a\'])\n    splitOnto as [] q = (q, as)\n    splitOnto as (_:bs) q = case viewr q of\n        q\' :> a -> splitOnto (a:as) bs q\'\n        EmptyR -> error "unfoldForestQ"\n\n--------------------------------------------------------------------------------\n\n-- Note [Implemented Foldable Tree functions]\n-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n--\n-- Implemented:\n--\n-- foldMap, foldr, foldl\': Basic functions.\n-- fold, elem: Implemented same as the default definition, but INLINABLE to\n-- allow specialization.\n-- foldr1, foldl1, null, maximum, minimum: Implemented more efficiently than\n-- defaults since trees are non-empty.\n-- sum, product: Implemented as strict left folds. Defaults use the lazy foldMap\n-- before base 4.15.1.\n--\n-- Not implemented:\n--\n-- foldMap\', toList, length: Defaults perform well.\n-- foldr\', foldl: Unlikely to be used.\n\n-- Note [Implemented Foldable1 Tree functions]\n-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n--\n-- Implemented:\n--\n-- foldrMap1, foldlMap1\': Basic functions\n-- foldMap, foldMap1\': Implemented same as the default definition, but\n-- INLINABLE to allow specialization.\n-- toNonEmpty, foldlMap1: Implemented more efficiently than default.\n-- maximum, minimum: Uses Foldable\'s implementation.\n--\n-- Not implemented:\n--\n-- fold1, head: Defaults perform well.\n-- foldrMap1\': Unlikely to be used.\n'