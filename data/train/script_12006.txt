b'-- |\n-- Copyright  : (c) Ivan Perez and Manuel Baerenz, 2016\n-- License    : BSD3\n-- Maintainer : ivan.perez@keera.co.uk\n--\n-- This module contains operations on monadic streams that are asynchronous,\n-- i.e. that change the speed at which data enters or leaves the \'MSF\'.\nmodule Data.MonadicStreamFunction.Async where\n\n-- Internal imports\nimport Data.MonadicStreamFunction.InternalCore (MSF(MSF, unMSF))\nimport Data.MonadicStreamFunction.Util         (MStream)\n\n-- |\n-- Concatenates a monadic stream of lists to a monadic stream.\n-- The stream of lists will be called exactly when new data is needed.\n--\n-- Example:\n--\n-- >>> let intstream = constS $ putStrLn "Enter a list of Ints:" >> readLn :: MStream IO [Int]\n-- >>> reactimate $ concatS intstream >>> arrM print\n-- Enter a list of Ints:\n-- [1, 2, 33]\n-- 1\n-- 2\n-- 33\n-- Enter a list of Ints:\n-- []\n-- Enter a list of Ints:\n-- []\n-- Enter a list of Ints:\n-- [1, 2]\n-- 1\n-- 2\n-- Enter a list of Ints:\n-- ...\n--\n-- Beware that @concatS msf@ becomes unproductive when @msf@ starts outputting\n-- empty lists forever. This is ok:\n--\n-- >>> let boolToList b = if b then ["Yes"] else []\n-- >>> let everyOddEmpty = count >>> arr (even >>> boolToList)\n-- >>> reactimate $ concatS everyOddEmpty >>> arrM print\n-- "Yes"\n-- "Yes"\n-- "Yes"\n-- "Yes"\n-- "Yes"\n-- ...\n--\n-- But this will be caught in a loop:\n--\n-- >>> let after3Empty = count >>> arr ((<= 3) >>> boolToList)\n-- >>> reactimate $ concatS after3Empty  >>> arrM print\n-- "Yes"\n-- "Yes"\n-- "Yes"\n-- ^CInterrupted.\nconcatS :: Monad m => MStream m [b] -> MStream m b\nconcatS msf = MSF $ \\_ -> tick msf []\n  where\n    tick msf\' (b:bs) = return (b, MSF $ \\_ -> tick msf\' bs)\n    tick msf\' []     = do\n      (bs, msf\'\') <- unMSF msf\' ()\n      tick msf\'\' bs\n'