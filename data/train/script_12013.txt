b'\n-- | An associative data structure with a single assignment property similar to IVars (per-key).\n\nmodule Control.Monad.Par.IMap\n (\n  --| Create an empty IMap.\n  newImap, \n  --| Publish a value at a specific key, once put the `(key,value)`\n  --  binding is permanent and can neither be changed nor removed.\n  putKey,\n  --| Get the value associated with a key.  `getKey` is a blocking\n  --  operation.  If there is not yet an association for the key, it\n  --  will wait until one becomes available.\n  getKey\n )\n where \n\nimport Control.Monad.Par.Class\nimport Control.Monad.Par.Unsafe\nimport Control.Concurrent.QSem\nimport qualified Data.HashTable.IO as H\n-- import qualified Data.HashTable.ST.Basic as H  -- from hashtables package\n\ntype HashTable k v = H.BasicHashTable k v\n\n-- We begin with a hashtable and a lock.  We could diffuse contention\n-- by a constant factor by splitting this into, say, a vector of hashtables.\n-- Further we should probably be using a spinlock.\nnewtype IMap k iv v = IMap (HashTable k (iv v))\n\nnewImap :: (ParUnsafe p iv) => p (IMap k iv v)\nnewImap = H.new\n\nputKey :: (ParUnsafe p iv) => p ()\nputKey = undefined\n\ngetKey :: (ParUnsafe p iv) => p ()\ngetKey = undefined\n\n'