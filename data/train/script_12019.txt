b'\xef\xbb\xbfusing System;\nusing Asn1;\nusing System.Text;\nusing System.Collections.Generic;\nusing System.Runtime.InteropServices;\nusing Rubeus.lib.Interop;\n\n\nnamespace Rubeus\n{\n    public class Interop\n    {\n        // constants\n\n        // From https://github.com/gentilkiwi/kekeo/blob/master/modules/asn1/kull_m_kerberos_asn1.h#L61\n        public const int KRB_KEY_USAGE_AS_REQ_PA_ENC_TIMESTAMP = 1;\n        public const int KRB_KEY_USAGE_AS_REP_TGS_REP = 2;\n        public const int KRB_KEY_USAGE_AS_REP_EP_SESSION_KEY = 3;\n        public const int KRB_KEY_USAGE_TGS_REQ_ENC_AUTHOIRZATION_DATA = 4;\n        public const int KRB_KEY_USAGE_TGS_REQ_PA_AUTHENTICATOR = 7;\n        public const int KRB_KEY_USAGE_TGS_REP_EP_SESSION_KEY = 8;\n        public const int KRB_KEY_USAGE_AP_REQ_AUTHENTICATOR = 11;\n        public const int KRB_KEY_USAGE_KRB_PRIV_ENCRYPTED_PART = 13;\n        public const int KRB_KEY_USAGE_KRB_CRED_ENCRYPTED_PART = 14;\n        public const int KRB_KEY_USAGE_KRB_NON_KERB_SALT = 16;\n        public const int KRB_KEY_USAGE_KRB_NON_KERB_CKSUM_SALT = 17;\n        public const int KRB_KEY_USAGE_PA_S4U_X509_USER = 26;\n\n        // Enums\n\n        [Flags]\n        public enum TicketFlags : UInt32\n        {\n            reserved = 2147483648,\n            forwardable = 0x40000000,\n            forwarded = 0x20000000,\n            proxiable = 0x10000000,\n            proxy = 0x08000000,\n            may_postdate = 0x04000000,\n            postdated = 0x02000000,\n            invalid = 0x01000000,\n            renewable = 0x00800000,\n            initial = 0x00400000,\n            pre_authent = 0x00200000,\n            hw_authent = 0x00100000,\n            ok_as_delegate = 0x00040000,\n            anonymous = 0x00020000,\n            name_canonicalize = 0x00010000,\n            //cname_in_pa_data = 0x00040000,\n            enc_pa_rep = 0x00010000,\n            reserved1 = 0x00000001,\n            empty = 0x00000000\n            // TODO: constrained delegation?\n        }\n\n        // TODO: order flipped? https://github.com/gentilkiwi/kekeo/blob/master/modules/asn1/KerberosV5Spec2.asn#L167-L190\n        // Correcting some of these from here, which packet captures suggest is correct: https://github.com/dotnet/Kerberos.NET/blob/develop/Kerberos.NET/Entities/Krb/KdcOptions.cs\n        [Flags]\n        public enum KdcOptions : uint\n        {\n            VALIDATE = 0x00000001,\n            RENEW = 0x00000002,\n            UNUSED29 = 0x00000004,\n            ENCTKTINSKEY = 0x00000008,\n            RENEWABLEOK = 0x00000010,\n            DISABLETRANSITEDCHECK = 0x00000020,\n            UNUSED16 = 0x0000FFC0,\n            CONSTRAINED_DELEGATION = 0x00020000,\n            CANONICALIZE = 0x00010000,\n            CNAMEINADDLTKT = 0x00004000,\n            OK_AS_DELEGATE = 0x00040000,\n            REQUEST_ANONYMOUS = 0x00008000,\n            UNUSED12 = 0x00080000,\n            OPTHARDWAREAUTH = 0x00100000,\n            PREAUTHENT = 0x00200000,\n            INITIAL = 0x00400000,\n            RENEWABLE = 0x00800000,\n            UNUSED7 = 0x01000000,\n            POSTDATED = 0x02000000,\n            ALLOWPOSTDATE = 0x04000000,\n            PROXY = 0x08000000,\n            PROXIABLE = 0x10000000,\n            FORWARDED = 0x20000000,\n            FORWARDABLE = 0x40000000,\n            RESERVED = 0x80000000\n        }\n\n        // from https://tools.ietf.org/html/rfc4120#section-7.5.7\n        public enum KERB_MESSAGE_TYPE : long\n        {\n            AS_REQ = 10,\n            AS_REP = 11,\n            TGS_REQ = 12,\n            TGS_REP = 13,\n            AP_REQ = 14,\n            AP_REP = 15,\n            TGT_REQ = 16, // KRB-TGT-REQUEST for U2U\n            TGT_REP = 17, // KRB-TGT-REPLY for U2U\n            SAFE = 20,\n            PRIV = 21,\n            CRED = 22,\n            ERROR = 30\n        }\n\n        // from https://tools.ietf.org/html/rfc3961\n        public enum KERB_ETYPE : Int32\n        {\n            des_cbc_crc = 1,\n            des_cbc_md4 = 2,\n            des_cbc_md5 = 3,\n            des3_cbc_md5 = 5,\n            des3_cbc_sha1 = 7,\n            dsaWithSHA1_CmsOID = 9,\n            md5WithRSAEncryption_CmsOID = 10,\n            sha1WithRSAEncryption_CmsOID = 11,\n            rc2CBC_EnvOID = 12,\n            rsaEncryption_EnvOID = 13,\n            rsaES_OAEP_ENV_OID = 14,\n            des_ede3_cbc_Env_OID = 15,\n            des3_cbc_sha1_kd = 16,\n            aes128_cts_hmac_sha1 = 17,\n            aes256_cts_hmac_sha1 = 18,\n            rc4_hmac = 23,\n            rc4_hmac_exp = 24,\n            subkey_keymaterial = 65,\n            old_exp = -135\n        }\n\n        [Flags]\n        public enum SUPPORTED_ETYPE : Int32\n        {\n            RC4_HMAC_DEFAULT = 0x0,\n            DES_CBC_CRC = 0x1,\n            DES_CBC_MD5 = 0x2,\n            RC4_HMAC = 0x4,\n            AES128_CTS_HMAC_SHA1_96 = 0x08,\n            AES256_CTS_HMAC_SHA1_96 = 0x10\n        }\n\n        public enum KADMIN_PASSWD_ERR : UInt32\n        {\n            KRB5_KPASSWD_SUCCESS = 0,\n            KRB5_KPASSWD_MALFORMED = 1,\n            KRB5_KPASSWD_HARDERROR = 2,\n            KRB5_KPASSWD_AUTHERROR = 3,\n            KRB5_KPASSWD_SOFTERROR = 4,\n            KRB5_KPASSWD_ACCESSDENIED = 5,\n            KRB5_KPASSWD_BAD_VERSION = 6,\n            KRB5_KPASSWD_INITIAL_FLAG_NEEDED = 7\n        }\n\n        public enum KERB_CHECKSUM_ALGORITHM\n        {\n            KERB_CHECKSUM_NONE = 0,\n            KERB_CHECKSUM_RSA_MD4 = 2,\n            KERB_CHECKSUM_RSA_MD5 = 7,\n            KERB_CHECKSUM_HMAC_SHA1_96_AES128 = 15,\n            KERB_CHECKSUM_HMAC_SHA1_96_AES256 = 16,\n            KERB_CHECKSUM_DES_MAC = -133,\n            KERB_CHECKSUM_HMAC_MD5 = -138,\n        }\n\n        [StructLayout(LayoutKind.Sequential)]\n        public struct KERB_CHECKSUM\n        {\n            public int Type;\n            public int Size;\n            public int Flag;\n            public IntPtr Initialize;\n            public IntPtr Sum;\n            public IntPtr Finalize;\n            public IntPtr Finish;\n            public IntPtr InitializeEx;\n            public IntPtr unk0_null;\n        }\n\n        // from https://tools.ietf.org/html/rfc4120#section-6.2\n        public enum PRINCIPAL_TYPE : long\n        {\n            NT_UNKNOWN = 0,\n            NT_PRINCIPAL = 1,\n            NT_SRV_INST = 2,\n            NT_SRV_HST = 3,\n            NT_SRV_XHST = 4,\n            NT_UID = 5,\n            NT_X500_PRINCIPAL = 6,\n            NT_SMTP_NAME = 7,\n            NT_ENTERPRISE = 10\n        }\n\n        // from https://github.com/ps4dev/freebsd-include-mirror/blob/master/krb5_asn1.h\n        public enum PADATA_TYPE : UInt32\n        {\n            NONE = 0,\n            TGS_REQ = 1,\n            AP_REQ = 1,\n            ENC_TIMESTAMP = 2,\n            PW_SALT = 3,\n            ENC_UNIX_TIME = 5,\n            SANDIA_SECUREID = 6,\n            SESAME = 7,\n            OSF_DCE = 8,\n            CYBERSAFE_SECUREID = 9,\n            AFS3_SALT = 10,\n            ETYPE_INFO = 11,\n            SAM_CHALLENGE = 12,\n            SAM_RESPONSE = 13,\n            PK_AS_REQ_19 = 14,\n            PK_AS_REP_19 = 15,\n            PK_AS_REQ_WIN = 15,\n            PK_AS_REQ = 16,\n            PK_AS_REP = 17,\n            PA_PK_OCSP_RESPONSE = 18,\n            ETYPE_INFO2 = 19,\n            USE_SPECIFIED_KVNO = 20,\n            SVR_REFERRAL_INFO = 20,\n            SAM_REDIRECT = 21,\n            GET_FROM_TYPED_DATA = 22,\n            SAM_ETYPE_INFO = 23,\n            SERVER_REFERRAL = 25,\n            TD_KRB_PRINCIPAL = 102,\n            PK_TD_TRUSTED_CERTIFIERS = 104,\n            PK_TD_CERTIFICATE_INDEX = 105,\n            TD_APP_DEFINED_ERROR = 106,\n            TD_REQ_NONCE = 107,\n            TD_REQ_SEQ = 108,\n            PA_PAC_REQUEST = 128,\n            S4U2SELF = 129,\n            PA_S4U_X509_USER = 130,\n            PA_PAC_OPTIONS = 167,\n            PK_AS_09_BINDING = 132,\n            CLIENT_CANONICALIZED = 133\n        }\n\n        // from https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-sfu/cd9d5ca7-ce20-4693-872b-2f5dd41cbff6\n        public enum PA_S4U_X509_USER_OPTIONS : Int32\n        {\n            CHECK_LOGON_RESTRICTIONS = 0x40000000,\n            SIGN_REPLY = 0x20000000\n        }\n\n        // adapted from https://github.com/skelsec/minikerberos/blob/master/minikerberos/kerberoserror.py#L18-L76\n        public enum KERBEROS_ERROR : UInt32\n        {\n            KDC_ERR_NONE = 0x0, //No error\n            KDC_ERR_NAME_EXP = 0x1, //Client\'s entry in KDC database has expired\n            KDC_ERR_SERVICE_EXP = 0x2, //Server\'s entry in KDC database has expired\n            KDC_ERR_BAD_PVNO = 0x3, //Requested Kerberos version number not supported\n            KDC_ERR_C_OLD_MAST_KVNO = 0x4, //Client\'s key encrypted in old master key\n            KDC_ERR_S_OLD_MAST_KVNO = 0x5, //Server\'s key encrypted in old master key\n            KDC_ERR_C_PRINCIPAL_UNKNOWN = 0x6, //Client not found in Kerberos database\n            KDC_ERR_S_PRINCIPAL_UNKNOWN = 0x7, //Server not found in Kerberos database\n            KDC_ERR_PRINCIPAL_NOT_UNIQUE = 0x8, //Multiple principal entries in KDC database\n            KDC_ERR_NULL_KEY = 0x9, //The client or server has a null key (master key)\n            KDC_ERR_CANNOT_POSTDATE = 0xA, // Ticket (TGT) not eligible for postdating\n            KDC_ERR_NEVER_VALID = 0xB, // Requested start time is later than end time\n            KDC_ERR_POLICY = 0xC, //Requested start time is later than end time\n            KDC_ERR_BADOPTION = 0xD, //KDC cannot accommodate requested option\n            KDC_ERR_ETYPE_NOTSUPP = 0xE, // KDC has no support for encryption type\n            KDC_ERR_SUMTYPE_NOSUPP = 0xF, // KDC has no support for checksum type\n            KDC_ERR_PADATA_TYPE_NOSUPP = 0x10, //KDC has no support for PADATA type (pre-authentication data)\n            KDC_ERR_TRTYPE_NO_SUPP = 0x11, //KDC has no support for transited type\n            KDC_ERR_CLIENT_REVOKED = 0x12, // Client\xe2\x80\x99s credentials have been revoked\n            KDC_ERR_SERVICE_REVOKED = 0x13, //Credentials for server have been revoked\n            KDC_ERR_TGT_REVOKED = 0x14, //TGT has been revoked\n            KDC_ERR_CLIENT_NOTYET = 0x15, // Client not yet valid\xe2\x80\x94try again later\n            KDC_ERR_SERVICE_NOTYET = 0x16, //Server not yet valid\xe2\x80\x94try again later\n            KDC_ERR_KEY_EXPIRED = 0x17, // Password has expired\xe2\x80\x94change password to reset\n            KDC_ERR_PREAUTH_FAILED = 0x18, //Pre-authentication information was invalid\n            KDC_ERR_PREAUTH_REQUIRED = 0x19, // Additional preauthentication required\n            KDC_ERR_SERVER_NOMATCH = 0x1A, //KDC does not know about the requested server\n            KDC_ERR_SVC_UNAVAILABLE = 0x1B, // KDC is unavailable\n            KRB_AP_ERR_BAD_INTEGRITY = 0x1F, // Integrity check on decrypted field failed\n            KRB_AP_ERR_TKT_EXPIRED = 0x20, // The ticket has expired\n            KRB_AP_ERR_TKT_NYV = 0x21, //The ticket is not yet valid\n            KRB_AP_ERR_REPEAT = 0x22, // The request is a replay\n            KRB_AP_ERR_NOT_US = 0x23, //The ticket is not for us\n            KRB_AP_ERR_BADMATCH = 0x24, //The ticket and authenticator do not match\n            KRB_AP_ERR_SKEW = 0x25, // The clock skew is too great\n            KRB_AP_ERR_BADADDR = 0x26, // Network address in network layer header doesn\'t match address inside ticket\n            KRB_AP_ERR_BADVERSION = 0x27, // Protocol version numbers don\'t match (PVNO)\n            KRB_AP_ERR_MSG_TYPE = 0x28, // Message type is unsupported\n            KRB_AP_ERR_MODIFIED = 0x29, // Message stream modified and checksum didn\'t match\n            KRB_AP_ERR_BADORDER = 0x2A, // Message out of order (possible tampering)\n            KRB_AP_ERR_BADKEYVER = 0x2C, // Specified version of key is not available\n            KRB_AP_ERR_NOKEY = 0x2D, // Service key not available\n            KRB_AP_ERR_MUT_FAIL = 0x2E, // Mutual authentication failed\n            KRB_AP_ERR_BADDIRECTION = 0x2F, // Incorrect message direction\n            KRB_AP_ERR_METHOD = 0x30, // Alternative authentication method required\n            KRB_AP_ERR_BADSEQ = 0x31, // Incorrect sequence number in message\n            KRB_AP_ERR_INAPP_CKSUM = 0x32, // Inappropriate type of checksum in message (checksum may be unsupported)\n            KRB_AP_PATH_NOT_ACCEPTED = 0x33, // Desired path is unreachable\n            KRB_ERR_RESPONSE_TOO_BIG = 0x34, // Too much data\n            KRB_ERR_GENERIC = 0x3C, // Generic error; the description is in the e-data field\n            KRB_ERR_FIELD_TOOLONG = 0x3D, // Field is too long for this implementation\n            KDC_ERR_CLIENT_NOT_TRUSTED = 0x3E, // The client trust failed or is not implemented\n            KDC_ERR_KDC_NOT_TRUSTED = 0x3F, // The KDC server trust failed or could not be verified\n            KDC_ERR_INVALID_SIG = 0x40, // The signature is invalid\n            KDC_ERR_KEY_TOO_WEAK = 0x41, //A higher encryption level is needed\n            KRB_AP_ERR_USER_TO_USER_REQUIRED = 0x42, // User-to-user authorization is required\n            KRB_AP_ERR_NO_TGT = 0x43, // No TGT was presented or available\n            KDC_ERR_WRONG_REALM = 0x44, //Incorrect domain or principal\n            KDC_ERR_CANT_VERIFY_CERTIFICATE = 0x46,\n            KDC_ERR_INVALID_CERTIFICATE = 0x47,\n            KDC_ERR_REVOKED_CERTIFICATE = 0x48,\n            KDC_ERR_REVOCATION_STATUS_UNKNOWN = 0x49,\n            KDC_ERR_CLIENT_NAME_MISMATCH = 0x4B,\n            KDC_ERR_INCONSISTENT_KEY_PURPOSE = 0x4D,\n            KDC_ERR_DIGEST_IN_CERT_NOT_ACCEPTED = 0x4E,\n            KDC_ERR_PA_CHECKSUM_MUST_BE_INCLUDED = 0x4F,\n            KDC_ERR_DIGEST_IN_SIGNED_DATA_NOT_ACCEPTED = 0x50,\n            KDC_ERR_PUBLIC_KEY_ENCRYPTION_NOT_SUPPORTED = 0x51,\n        }\n\n        [Flags]\n        public enum DSGETDCNAME_FLAGS : uint\n        {\n            DS_FORCE_REDISCOVERY = 0x00000001,\n            DS_DIRECTORY_SERVICE_REQUIRED = 0x00000010,\n            DS_DIRECTORY_SERVICE_PREFERRED = 0x00000020,\n            DS_GC_SERVER_REQUIRED = 0x00000040,\n            DS_PDC_REQUIRED = 0x00000080,\n            DS_BACKGROUND_ONLY = 0x00000100,\n            DS_IP_REQUIRED = 0x00000200,\n            DS_KDC_REQUIRED = 0x00000400,\n            DS_TIMESERV_REQUIRED = 0x00000800,\n            DS_WRITABLE_REQUIRED = 0x00001000,\n            DS_GOOD_TIMESERV_PREFERRED = 0x00002000,\n            DS_AVOID_SELF = 0x00004000,\n            DS_ONLY_LDAP_NEEDED = 0x00008000,\n            DS_IS_FLAT_NAME = 0x00010000,\n            DS_IS_DNS_NAME = 0x00020000,\n            DS_RETURN_DNS_NAME = 0x40000000,\n            DS_RETURN_FLAT_NAME = 0x80000000\n        }\n\n        public enum TOKEN_INFORMATION_CLASS\n        {\n            /// <summary>\n            /// The buffer receives a TOKEN_USER structure that contains the user account of the token.\n            /// </summary>\n            TokenUser = 1,\n\n            /// <summary>\n            /// The buffer receives a TOKEN_GROUPS structure that contains the group accounts associated with the token.\n            /// </summary>\n            TokenGroups,\n\n            /// <summary>\n            /// The buffer receives a TOKEN_PRIVILEGES structure that contains the privileges of the token.\n            /// </summary>\n            TokenPrivileges,\n\n            /// <summary>\n            /// The buffer receives a TOKEN_OWNER structure that contains the default owner security identifier (SID) for newly created objects.\n            /// </summary>\n            TokenOwner,\n\n            /// <summary>\n            /// The buffer receives a TOKEN_PRIMARY_GROUP structure that contains the default primary group SID for newly created objects.\n            /// </summary>\n            TokenPrimaryGroup,\n\n            /// <summary>\n            /// The buffer receives a TOKEN_DEFAULT_DACL structure that contains the default DACL for newly created objects.\n            /// </summary>\n            TokenDefaultDacl,\n\n            /// <summary>\n            /// The buffer receives a TOKEN_SOURCE structure that contains the source of the token. TOKEN_QUERY_SOURCE access is needed to retrieve this information.\n            /// </summary>\n            TokenSource,\n\n            /// <summary>\n            /// The buffer receives a TOKEN_TYPE value that indicates whether the token is a primary or impersonation token.\n            /// </summary>\n            TokenType,\n\n            /// <summary>\n            /// The buffer receives a SECURITY_IMPERSONATION_LEVEL value that indicates the impersonation level of the token. If the access token is not an impersonation token, the function fails.\n            /// </summary>\n            TokenImpersonationLevel,\n\n            /// <summary>\n            /// The buffer receives a TOKEN_STATISTICS structure that contains various token statistics.\n            /// </summary>\n            TokenStatistics,\n\n            /// <summary>\n            /// The buffer receives a TOKEN_GROUPS structure that contains the list of restricting SIDs in a restricted token.\n            /// </summary>\n            TokenRestrictedSids,\n\n            /// <summary>\n            /// The buffer receives a DWORD value that indicates the Terminal Services session identifier that is associated with the token. \n            /// </summary>\n            TokenSessionId,\n\n            /// <summary>\n            /// The buffer receives a TOKEN_GROUPS_AND_PRIVILEGES structure that contains the user SID, the group accounts, the restricted SIDs, and the authentication ID associated with the token.\n            /// </summary>\n            TokenGroupsAndPrivileges,\n\n            /// <summary>\n            /// Reserved.\n            /// </summary>\n            TokenSessionReference,\n\n            /// <summary>\n            /// The buffer receives a DWORD value that is nonzero if the token includes the SANDBOX_INERT flag.\n            /// </summary>\n            TokenSandBoxInert,\n\n            /// <summary>\n            /// Reserved.\n            /// </summary>\n            TokenAuditPolicy,\n\n            /// <summary>\n            /// The buffer receives a TOKEN_ORIGIN value. \n            /// </summary>\n            TokenOrigin,\n\n            /// <summary>\n            /// The buffer receives a TOKEN_ELEVATION_TYPE value that specifies the elevation level of the token.\n            /// </summary>\n            TokenElevationType,\n\n            /// <summary>\n            /// The buffer receives a TOKEN_LINKED_TOKEN structure that contains a handle to another token that is linked to this token.\n            /// </summary>\n            TokenLinkedToken,\n\n            /// <summary>\n            /// The buffer receives a TOKEN_ELEVATION structure that specifies whether the token is elevated.\n            /// </summary>\n            TokenElevation,\n\n            /// <summary>\n            /// The buffer receives a DWORD value that is nonzero if the token has ever been filtered.\n            /// </summary>\n            TokenHasRestrictions,\n\n            /// <summary>\n            /// The buffer receives a TOKEN_ACCESS_INFORMATION structure that specifies security information contained in the token.\n            /// </summary>\n            TokenAccessInformation,\n\n            /// <summary>\n            /// The buffer receives a DWORD value that is nonzero if virtualization is allowed for the token.\n            /// </summary>\n            TokenVirtualizationAllowed,\n\n            /// <summary>\n            /// The buffer receives a DWORD value that is nonzero if virtualization is enabled for the token.\n            /// </summary>\n            TokenVirtualizationEnabled,\n\n            /// <summary>\n            /// The buffer receives a TOKEN_MANDATORY_LABEL structure that specifies the token\'s integrity level. \n            /// </summary>\n            TokenIntegrityLevel,\n\n            /// <summary>\n            /// The buffer receives a DWORD value that is nonzero if the token has the UIAccess flag set.\n            /// </summary>\n            TokenUIAccess,\n\n            /// <summary>\n            /// The buffer receives a TOKEN_MANDATORY_POLICY structure that specifies the token\'s mandatory integrity policy.\n            /// </summary>\n            TokenMandatoryPolicy,\n\n            /// <summary>\n            /// The buffer receives the token\'s logon security identifier (SID).\n            /// </summary>\n            TokenLogonSid,\n\n            /// <summary>\n            /// The maximum value for this enumeration\n            /// </summary>\n            MaxTokenInfoClass\n        }\n\n        [Flags]\n        public enum KERB_CACHE_OPTIONS : UInt64\n        {\n            KERB_RETRIEVE_TICKET_DEFAULT = 0x0,\n            KERB_RETRIEVE_TICKET_DONT_USE_CACHE = 0x1,\n            KERB_RETRIEVE_TICKET_USE_CACHE_ONLY = 0x2,\n            KERB_RETRIEVE_TICKET_USE_CREDHANDLE = 0x4,\n            KERB_RETRIEVE_TICKET_AS_KERB_CRED = 0x8,\n            KERB_RETRIEVE_TICKET_WITH_SEC_CRED = 0x10,\n            KERB_RETRIEVE_TICKET_CACHE_TICKET = 0x20,\n            KERB_RETRIEVE_TICKET_MAX_LIFETIME = 0x40,\n        }\n\n        public enum KERB_PROTOCOL_MESSAGE_TYPE : UInt32\n        {\n            KerbDebugRequestMessage = 0,\n            KerbQueryTicketCacheMessage = 1,\n            KerbChangeMachinePasswordMessage = 2,\n            KerbVerifyPacMessage = 3,\n            KerbRetrieveTicketMessage = 4,\n            KerbUpdateAddressesMessage = 5,\n            KerbPurgeTicketCacheMessage = 6,\n            KerbChangePasswordMessage = 7,\n            KerbRetrieveEncodedTicketMessage = 8,\n            KerbDecryptDataMessage = 9,\n            KerbAddBindingCacheEntryMessage = 10,\n            KerbSetPasswordMessage = 11,\n            KerbSetPasswordExMessage = 12,\n            KerbVerifyCredentialsMessage = 13,\n            KerbQueryTicketCacheExMessage = 14,\n            KerbPurgeTicketCacheExMessage = 15,\n            KerbRefreshSmartcardCredentialsMessage = 16,\n            KerbAddExtraCredentialsMessage = 17,\n            KerbQuerySupplementalCredentialsMessage = 18,\n            KerbTransferCredentialsMessage = 19,\n            KerbQueryTicketCacheEx2Message = 20,\n            KerbSubmitTicketMessage = 21,\n            KerbAddExtraCredentialsExMessage = 22,\n            KerbQueryKdcProxyCacheMessage = 23,\n            KerbPurgeKdcProxyCacheMessage = 24,\n            KerbQueryTicketCacheEx3Message = 25,\n            KerbCleanupMachinePkinitCredsMessage = 26,\n            KerbAddBindingCacheEntryExMessage = 27,\n            KerbQueryBindingCacheMessage = 28,\n            KerbPurgeBindingCacheMessage = 29,\n            KerbQueryDomainExtendedPoliciesMessage = 30,\n            KerbQueryS4U2ProxyCacheMessage = 31\n        }\n\n        public enum LogonType : uint\n        {\n            Interactive = 2,        // logging on interactively.\n            Network,                // logging using a network.\n            Batch,                  // logon for a batch process.\n            Service,                // logon for a service account.\n            Proxy,                  // Not supported.\n            Unlock,                 // Tattempt to unlock a workstation.\n            NetworkCleartext,       // network logon with cleartext credentials\n            NewCredentials,         // caller can clone its current token and specify new credentials for outbound connections\n            RemoteInteractive,      // terminal server session that is both remote and interactive\n            CachedInteractive,      // attempt to use the cached credentials without going out across the network\n            CachedRemoteInteractive,// same as RemoteInteractive, except used internally for auditing purposes\n            CachedUnlock            // attempt to unlock a workstation\n        }\n\n        public enum LOGON_PROVIDER\n        {\n            LOGON32_PROVIDER_DEFAULT,\n            LOGON32_PROVIDER_WINNT35,\n            LOGON32_PROVIDER_WINNT40,\n            LOGON32_PROVIDER_WINNT50\n        }\n\n        // from https://github.com/alexbrainman/sspi/blob/master/syscall.go#L113-L129\n        [Flags]\n        public enum ISC_REQ : int\n        {\n            DELEGATE = 1,\n            MUTUAL_AUTH = 2,\n            REPLAY_DETECT = 4,\n            SEQUENCE_DETECT = 8,\n            CONFIDENTIALITY = 16,\n            USE_SESSION_KEY = 32,\n            PROMPT_FOR_CREDS = 64,\n            USE_SUPPLIED_CREDS = 128,\n            ALLOCATE_MEMORY = 256,\n            USE_DCE_STYLE = 512,\n            DATAGRAM = 1024,\n            CONNECTION = 2048,\n            EXTENDED_ERROR = 16384,\n            STREAM = 32768,\n            INTEGRITY = 65536,\n            MANUAL_CRED_VALIDATION = 524288,\n            HTTP = 268435456\n        }\n\n        public enum SecBufferType\n        {\n            SECBUFFER_VERSION = 0,\n            SECBUFFER_EMPTY = 0,\n            SECBUFFER_DATA = 1,\n            SECBUFFER_TOKEN = 2\n        }\n\n        // from https://directory.apache.org/apacheds/gen-docs/2.0.0-M15/apidocs/src-html/org/apache/directory/shared/kerberos/codec/types/HostAddrType.html\n        public enum HostAddressType : long\n        {\n            NULL = 0,\n            ADDRTYPE_UNIX = 1,\n            ADDRTYPE_INET = 2,\n            ADDRTYPE_IMPLINK = 3,\n            ADDRTYPE_PUP = 4,\n            ADDRTYPE_CHAOS = 5,\n            ADDRTYPE_XNS = 6,\n            ADDRTYPE_IPX = 6,\n            ADDRTYPE_OSI = 7,\n            ADDRTYPE_ECMA = 8,\n            ADDRTYPE_DATAKIT = 9,\n            ADDRTYPE_CCITT = 10,\n            ADDRTYPE_SNA = 11,\n            ADDRTYPE_DECNET = 12,\n            ADDRTYPE_DLI = 13,\n            ADDRTYPE_LAT = 14,\n            ADDRTYPE_HYLINK = 15,\n            ADDRTYPE_APPLETALK = 16,\n            ADDRTYPE_VOICEVIEW = 18,\n            ADDRTYPE_FIREFOX = 19,\n            ADDRTYPE_NETBIOS = 20,\n            ADDRTYPE_BAN = 21,\n            ADDRTYPE_ATM = 22,\n            ADDRTYPE_INET6 = 24\n        }\n\n        // from https://tools.ietf.org/html/rfc4120#section-5.2.6\n        // and https://github.com/apache/directory-kerby/blob/trunk/kerby-kerb/kerb-core/src/main/java/org/apache/kerby/kerberos/kerb/type/ad/AuthorizationType.java\n        public enum AuthorizationDataType : long\n        {\n            AD_IF_RELEVANT = 1,\n            AD_INTENDED_FOR_SERVER = 2,\n            AD_INTENDED_FOR_APPLICATION_CLASS = 3,\n            AD_KDCISSUED = 4,\n            AD_AND_OR = 5,\n            AD_MANDATORY_TICKET_EXTENSIONS = 6,\n            AD_IN_TICKET_EXTENSIONS = 7,\n            AD_MANDATORY_FOR_KDC = 8,\n            AD_INITIAL_VERIFIED_CAS = 9,\n            OSF_DCE = 64,\n            SESAME = 65,\n            AD_OSF_DCE_PKI_CERTID = 66,\n            AD_CAMMAC = 96,\n            AD_AUTHENTICATION_INDICATOR = 97,\n            AD_WIN2K_PAC = 128,\n            AD_ETYPE_NEGOTIATION = 129,\n            KERB_AUTH_DATA_TOKEN_RESTRICTIONS = 141,\n            KERB_LOCAL = 142,\n            AD_AUTH_DATA_AP_OPTIONS = 143,\n            AD_TOKEN = 256\n\n        }\n\n        public enum TransitedEncodingType : long\n        {\n            NULL = 0,\n            DOMAIN_X500_COMPRESS = 1\n        }\n\n        // from https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-kile/ec551137-c5e5-476a-9c89-e0029473c41b\n        public enum LSAP_TOKEN_INFO_INTEGRITY_FLAGS : UInt32\n        {\n            FULL = 0,\n            UAC_RESTRICTED = 1\n        }\n\n        public enum LSAP_TOKEN_INFO_INTEGRITY_TOKENIL : UInt32\n        {\n            UNTRUSTED = 0,\n            LOW = 4096,\n            MEDIUM = 8192,\n            HIGH = 12288,\n            SYSTEM = 16384,\n            PROTECTED = 20480\n        }\n\n        // from https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-samr/4df07fab-1bbc-452f-8e92-7853a3c7e380 section 2.2.1.12\n        [Flags]\n        public enum PacUserAccountControl : Int32\n        {\n            EMPTY = 0,\n            ACCOUNTDISABLE = 1,\n            HOMEDIR_REQUIRED = 2,\n            PASSWD_NOTREQD = 4,\n            TEMP_DUPLICATE_ACCOUNT = 8,\n            NORMAL_ACCOUNT = 16,\n            MNS_LOGON_ACCOUNT = 32,\n            INTERDOMAIN_TRUST_ACCOUNT = 64,\n            WORKSTATION_TRUST_ACCOUNT = 128,\n            SERVER_TRUST_ACCOUNT = 256,\n            DONT_EXPIRE_PASSWORD = 512,\n            ACCOUNT_AUTO_LOCKED = 1024,\n            ENCRYPTED_TEXT_PASSWORD_ALLOWED = 2048,\n            SMARTCARD_REQUIRED = 4096,\n            TRUSTED_FOR_DELEGATION = 8192,\n            NOT_DELEGATED = 16384,\n            USE_DES_KEY_ONLY = 32768,\n            DONT_REQ_PREAUTH = 65536,\n            PASSWORD_EXPIRED = 131072,\n            TRUSTED_TO_AUTH_FOR_DELEGATION = 262144,\n            NO_AUTH_DATA_REQUIRED = 524288,\n            PARTIAL_SECRETS_ACCOUNT = 1048576,\n            USE_AES_KEYS = 2097152\n        }\n\n        // from https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-pac/69e86ccc-85e3-41b9-b514-7d969cd0ed73\n        [Flags]\n        public enum PacUserFlags : Int32\n        {\n            EXTRA_SIDS = 32,\n            RESOURCE_GROUPS = 512\n        }\n\n        // from https://download.samba.org/pub/samba/patches/security/samba-4.15.1-security-2021-11-09.patch\n        [Flags]\n        public enum PacAttribute : Int32\n        {\n            PAC_NOT_REQUESTED = 0x00000000,\n            PAC_WAS_REQUESTED = 0x00000001,\n            PAC_WAS_GIVEN_IMPLICITLY = 0x00000002\n        }\n\n        [Flags]\n        public enum LDAPUserAccountControl : Int32\n        {\n            SCRIPT = 1,\n            ACCOUNTDISABLE = 2,\n            HOMEDIR_REQUIRED = 8,\n            LOCKOUT = 16,\n            PASSWD_NOTREQD = 32,\n            PASSWD_CANT_CHANGE = 64,\n            ENCRYPTED_TEXT_PWD_ALLOWED = 128,\n            TEMP_DUPLICATE_ACCOUNT = 256,\n            NORMAL_ACCOUNT = 512,\n            INTERDOMAIN_TRUST_ACCOUNT = 2048,\n            WORKSTATION_TRUST_ACCOUNT = 4096,\n            SERVER_TRUST_ACCOUNT = 8192,\n            DONT_EXPIRE_PASSWORD = 65536,\n            MNS_LOGON_ACCOUNT = 131072,\n            SMARTCARD_REQUIRED = 262144,\n            TRUSTED_FOR_DELEGATION = 524288,\n            NOT_DELEGATED = 1048576,\n            USE_DES_KEY_ONLY = 2097152,\n            DONT_REQ_PREAUTH = 4194304,\n            PASSWORD_EXPIRED = 8388608,\n            TRUSTED_TO_AUTH_FOR_DELEGATION = 16777216,\n            NO_AUTH_DATA_REQUIRED = 33554432,\n            PARTIAL_SECRETS_ACCOUNT = 67108864\n        }\n\n        // taken from https://github.com/tevora-threat/SharpView\n        public enum ResourceScope : int\n        {\n            Connected = 1,\n            GlobalNetwork,\n            Remembered,\n            Recent,\n            Context\n        };\n\n        public enum ResourceType : int\n        {\n            Any = 0,\n            Disk = 1,\n            Print = 2,\n            Reserved = 8,\n        }\n\n        public enum ResourceDisplaytype : int\n        {\n            Generic = 0x0,\n            Domain = 0x01,\n            Server = 0x02,\n            Share = 0x03,\n            File = 0x04,\n            Group = 0x05,\n            Network = 0x06,\n            Root = 0x07,\n            Shareadmin = 0x08,\n            Directory = 0x09,\n            Tree = 0x0a,\n            Ndscontainer = 0x0b\n        }\n\n        // from https://docs.microsoft.com/en-us/windows/win32/debug/system-error-codes\n        public enum SystemErrorCodes : int\n        {\n            ERROR_SUCCESS = 0,\n            ERROR_ACCESS_DENIED = 5,\n            ERROR_ALREADY_ASSIGNED = 85,\n            ERROR_BAD_DEV_TYPE = 66,\n            ERROR_BAD_DEVICE_PATH = 330,\n            ERROR_BAD_DEVICE = 1200,\n            ERROR_BAD_NETPATH = 53,\n            ERROR_BAD_NET_NAME = 67,\n            ERROR_BAD_PROFILE = 1206,\n            ERROR_BAD_PROVIDER = 1204,\n            ERROR_BAD_USERNAME = 2202,\n            ERROR_BUSY_DRIVE = 142,\n            ERROR_BUSY = 170,\n            ERROR_CANCELLED = 1223,\n            ERROR_CANNOT_OPEN_PROFILE = 1205,\n            ERROR_DEVICE_ALREADY_REMEMBERED = 1202,\n            ERROR_EXTENDED_ERROR = 1208,\n            ERROR_INVALID_ADDRESS = 487,\n            ERROR_INVALID_PARAMETER = 87,\n            ERROR_INVALID_PASSWORD = 86,\n            ERROR_INVALID_PASSWORDNAME = 1216,\n            ERROR_LOGON_FAILURE = 1326,\n            ERROR_NO_NET_OR_BAD_PATH = 1203,\n            ERROR_NO_NETWORK = 1222,\n        }\n\n\n\n        // structs\n\n        // // typedef struct _LSAP_TOKEN_INFO_INTEGRITY {\n        //    unsigned long Flags;\n        //    unsigned long TokenIL;\n        //    unsigned char MachineID[32];  # KILE implements a 32-byte binary random string machine ID\n        // }\n        // LSAP_TOKEN_INFO_INTEGRITY,\n        //   *PLSAP_TOKEN_INFO_INTEGRITY;\n        public struct LSAP_TOKEN_INFO_INTEGRITY\n        {\n            public LSAP_TOKEN_INFO_INTEGRITY_FLAGS Flags;\n            public LSAP_TOKEN_INFO_INTEGRITY_TOKENIL TokenIL;\n            public byte[] machineID;\n        }\n\n        // From Vincent LE TOUX\' "MakeMeEnterpriseAdmin"\n        //  https://github.com/vletoux/MakeMeEnterpriseAdmin/blob/master/MakeMeEnterpriseAdmin.ps1#L1773-L1794\n        [StructLayout(LayoutKind.Sequential)]\n        public struct KERB_ECRYPT\n        {\n            int Type0;\n            public int BlockSize;\n            int Type1;\n            public int KeySize;\n            public int Size;\n            int unk2;\n            int unk3;\n            public IntPtr AlgName;\n            public IntPtr Initialize;\n            public IntPtr Encrypt;\n            public IntPtr Decrypt;\n            public IntPtr Finish;\n            public IntPtr HashPassword;\n            IntPtr RandomKey;\n            IntPtr Control;\n            IntPtr unk0_null;\n            IntPtr unk1_null;\n            IntPtr unk2_null;\n        }\n\n        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]\n        public struct DOMAIN_CONTROLLER_INFO\n        {\n            [MarshalAs(UnmanagedType.LPTStr)]\n            public string DomainControllerName;\n            [MarshalAs(UnmanagedType.LPTStr)]\n            public string DomainControllerAddress;\n            public uint DomainControllerAddressType;\n            public Guid DomainGuid;\n            [MarshalAs(UnmanagedType.LPTStr)]\n            public string DomainName;\n            [MarshalAs(UnmanagedType.LPTStr)]\n            public string DnsForestName;\n            public uint Flags;\n            [MarshalAs(UnmanagedType.LPTStr)]\n            public string DcSiteName;\n            [MarshalAs(UnmanagedType.LPTStr)]\n            public string ClientSiteName;\n        }\n\n        public struct SYSTEMTIME\n        {\n            public ushort wYear, wMonth, wDayOfWeek, wDay,\n               wHour, wMinute, wSecond, wMilliseconds;\n        }\n\n\n        // LSA structures\n\n        [StructLayout(LayoutKind.Sequential)]\n        public struct KERB_SUBMIT_TKT_REQUEST\n        {\n            public KERB_PROTOCOL_MESSAGE_TYPE MessageType;\n            public LUID LogonId;\n            public int Flags;\n            public KERB_CRYPTO_KEY32 Key; // key to decrypt KERB_CRED\n            public int KerbCredSize;\n            public int KerbCredOffset;\n        }\n\n        [StructLayout(LayoutKind.Sequential)]\n        public struct KERB_PURGE_TKT_CACHE_REQUEST\n        {\n            public KERB_PROTOCOL_MESSAGE_TYPE MessageType;\n            public LUID LogonId;\n            LSA_STRING_IN ServerName;\n            LSA_STRING_IN RealmName;\n        }\n\n        [StructLayout(LayoutKind.Sequential)]\n        public struct KERB_CRYPTO_KEY32\n        {\n            public int KeyType;\n            public int Length;\n            public int Offset;\n        }\n\n        [StructLayout(LayoutKind.Sequential)]\n        public struct LSA_STRING_IN\n        {\n            public UInt16 Length;\n            public UInt16 MaximumLength;\n            public string Buffer;\n        }\n\n        [StructLayout(LayoutKind.Sequential)]\n        public struct LSA_STRING_OUT\n        {\n            public UInt16 Length;\n            public UInt16 MaximumLength;\n            public IntPtr Buffer;\n        }\n\n        [StructLayout(LayoutKind.Sequential)]\n        public struct LSA_STRING\n        {\n            public UInt16 Length;\n            public UInt16 MaximumLength;\n            public String Buffer;\n        }\n\n        [StructLayout(LayoutKind.Sequential)]\n        public struct UNICODE_STRING : IDisposable\n        {\n            public ushort Length;\n            public ushort MaximumLength;\n            public IntPtr buffer;\n\n            public UNICODE_STRING(string s)\n            {\n                Length = (ushort)(s.Length * 2);\n                MaximumLength = (ushort)(Length + 2);\n                buffer = Marshal.StringToHGlobalUni(s);\n            }\n\n            public void Dispose()\n            {\n                Marshal.FreeHGlobal(buffer);\n                buffer = IntPtr.Zero;\n            }\n\n            public override string ToString()\n            {\n                return Marshal.PtrToStringUni(buffer);\n            }\n        }\n\n        [StructLayout(LayoutKind.Sequential)]\n        public struct KERB_RETRIEVE_TKT_RESPONSE\n        {\n            public KERB_EXTERNAL_TICKET Ticket;\n        }\n\n        [StructLayout(LayoutKind.Sequential)]\n        public struct KERB_EXTERNAL_TICKET\n        {\n            public IntPtr ServiceName;\n            public IntPtr TargetName;\n            public IntPtr ClientName;\n            public LSA_STRING_OUT DomainName;\n            public LSA_STRING_OUT TargetDomainName;\n            public LSA_STRING_OUT AltTargetDomainName;\n            public KERB_CRYPTO_KEY SessionKey;\n            public UInt32 TicketFlags;\n            public UInt32 Flags;\n            public Int64 KeyExpirationTime;\n            public Int64 StartTime;\n            public Int64 EndTime;\n            public Int64 RenewUntil;\n            public Int64 TimeSkew;\n            public Int32 EncodedTicketSize;\n            public IntPtr EncodedTicket;\n        }\n\n        [StructLayout(LayoutKind.Sequential)]\n        public struct KERB_CRYPTO_KEY\n        {\n            public Int32 KeyType;\n            public Int32 Length;\n            public IntPtr Value;\n        }\n\n        [StructLayout(LayoutKind.Sequential)]\n        public struct KERB_RETRIEVE_TKT_REQUEST\n        {\n            public KERB_PROTOCOL_MESSAGE_TYPE MessageType;\n            public LUID LogonId;\n            public UNICODE_STRING TargetName;\n            public UInt32 TicketFlags;\n            public UInt32 CacheOptions;\n            public Int32 EncryptionType;\n            public SECURITY_HANDLE CredentialsHandle;\n        }\n\n        [StructLayout(LayoutKind.Sequential)]\n        public struct KERB_QUERY_TKT_CACHE_REQUEST\n        {\n            public KERB_PROTOCOL_MESSAGE_TYPE MessageType;\n            public LUID LogonId;\n        }\n\n        [StructLayout(LayoutKind.Sequential)]\n        public struct KERB_QUERY_TKT_CACHE_RESPONSE\n        {\n            public KERB_PROTOCOL_MESSAGE_TYPE MessageType;\n            public int CountOfTickets;\n            public IntPtr Tickets;\n        }\n\n        [StructLayout(LayoutKind.Sequential)]\n        public struct KERB_TICKET_CACHE_INFO\n        {\n            public LSA_STRING_OUT ServerName;\n            public LSA_STRING_OUT RealmName;\n            public Int64 StartTime;\n            public Int64 EndTime;\n            public Int64 RenewTime;\n            public Int32 EncryptionType;\n            public UInt32 TicketFlags;\n        }\n\n        [StructLayout(LayoutKind.Sequential)]\n        public struct KERB_TICKET_CACHE_INFO_EX\n        {\n            public LSA_STRING_OUT ClientName;\n            public LSA_STRING_OUT ClientRealm;\n            public LSA_STRING_OUT ServerName;\n            public LSA_STRING_OUT ServerRealm;\n            public Int64 StartTime;\n            public Int64 EndTime;\n            public Int64 RenewTime;\n            public Int32 EncryptionType;\n            public UInt32 TicketFlags;\n        }\n\n        [StructLayout(LayoutKind.Sequential)]\n        public struct KERB_TICKET_CACHE_INFO_EX2\n        {\n            public LSA_STRING_OUT ClientName;\n            public LSA_STRING_OUT ClientRealm;\n            public LSA_STRING_OUT ServerName;\n            public LSA_STRING_OUT ServerRealm;\n            public Int64 StartTime;\n            public Int64 EndTime;\n            public Int64 RenewTime;\n            public Int32 EncryptionType;\n            public UInt32 TicketFlags;\n\n            public UInt32 SessionKeyType;\n            public UInt32 BranchId;\n        }\n\n        [StructLayout(LayoutKind.Sequential)]\n        public struct KERB_TICKET_CACHE_INFO_EX3\n        {\n            public LSA_STRING_OUT ClientName;\n            public LSA_STRING_OUT ClientRealm;\n            public LSA_STRING_OUT ServerName;\n            public LSA_STRING_OUT ServerRealm;\n            public Int64 StartTime;\n            public Int64 EndTime;\n            public Int64 RenewTime;\n            public Int32 EncryptionType;\n            public UInt32 TicketFlags;\n\n            public UInt32 SessionKeyType;\n            public UInt32 BranchId;\n\n            public UInt32 CacheFlags;\n            public LSA_STRING_OUT KdcCalled;\n        }\n\n        [StructLayout(LayoutKind.Sequential)]\n        public struct KERB_EXTERNAL_NAME\n        {\n            public Int16 NameType;\n            public UInt16 NameCount;\n\n            [MarshalAs(UnmanagedType.ByValArray,\n                SizeConst = 3)]\n            public LSA_STRING_OUT[] Names;\n            //public LSA_STRING_OUT[] Names;\n        }\n\n        [StructLayout(LayoutKind.Sequential)]\n        public struct SECURITY_LOGON_SESSION_DATA\n        {\n            public UInt32 Size;\n            public LUID LoginID;\n            public LSA_STRING_OUT Username;\n            public LSA_STRING_OUT LoginDomain;\n            public LSA_STRING_OUT AuthenticationPackage;\n            public UInt32 LogonType;\n            public UInt32 Session;\n            public IntPtr PSiD;\n            public UInt64 LoginTime;\n            public LSA_STRING_OUT LogonServer;\n            public LSA_STRING_OUT DnsDomainName;\n            public LSA_STRING_OUT Upn;\n        }\n\n        [StructLayout(LayoutKind.Sequential)]\n        public struct SECURITY_ATTRIBUTES\n        {\n            public int Length;\n            public IntPtr lpSecurityDescriptor;\n            public bool bInheritHandle;\n        }\n\n        [StructLayout(LayoutKind.Sequential)]\n        public struct PROCESS_INFORMATION\n        {\n            public IntPtr hProcess;\n            public IntPtr hThread;\n            public int dwProcessId;\n            public int dwThreadId;\n        }\n\n        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]\n        public struct STARTUPINFO\n        {\n            public Int32 cb;\n            public string lpReserved;\n            public string lpDesktop;\n            public string lpTitle;\n            public Int32 dwX;\n            public Int32 dwY;\n            public Int32 dwXSize;\n            public Int32 dwYSize;\n            public Int32 dwXCountChars;\n            public Int32 dwYCountChars;\n            public Int32 dwFillAttribute;\n            public Int32 dwFlags;\n            public Int16 wShowWindow;\n            public Int16 cbReserved2;\n            public IntPtr lpReserved2;\n            public IntPtr hStdInput;\n            public IntPtr hStdOutput;\n            public IntPtr hStdError;\n        }\n\n        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]\n        public struct TOKEN_STATISTICS\n        {\n            public LUID TokenId;\n            public LUID AuthenticationId;\n            public long ExpirationTime;\n            public uint TokenType;\n            public uint ImpersonationLevel;\n            public uint DynamicCharged;\n            public uint DynamicAvailable;\n            public uint GroupCount;\n            public uint PrivilegeCount;\n            public LUID ModifiedId;\n        }\n\n        [StructLayout(LayoutKind.Sequential)]\n        public struct TOKEN_ORIGIN\n        {\n            public LUID OriginatingLogonSession;\n        }\n\n        // the following are adapted from https://www.pinvoke.net/default.aspx/secur32.InitializeSecurityContext\n        [StructLayout(LayoutKind.Sequential)]\n        public struct SecHandle //=PCtxtHandle\n        {\n            IntPtr dwLower; // ULONG_PTR translates to IntPtr not to uint\n            IntPtr dwUpper; // this is crucial for 64-Bit Platforms\n        }\n\n        [StructLayout(LayoutKind.Sequential)]\n        public struct SecBuffer : IDisposable\n        {\n            public int cbBuffer;\n            public int BufferType;\n            public IntPtr pvBuffer;\n\n\n            public SecBuffer(int bufferSize)\n            {\n                cbBuffer = bufferSize;\n                BufferType = (int)SecBufferType.SECBUFFER_TOKEN;\n                pvBuffer = Marshal.AllocHGlobal(bufferSize);\n            }\n\n            public SecBuffer(byte[] secBufferBytes)\n            {\n                cbBuffer = secBufferBytes.Length;\n                BufferType = (int)SecBufferType.SECBUFFER_TOKEN;\n                pvBuffer = Marshal.AllocHGlobal(cbBuffer);\n                Marshal.Copy(secBufferBytes, 0, pvBuffer, cbBuffer);\n            }\n\n            public SecBuffer(byte[] secBufferBytes, SecBufferType bufferType)\n            {\n                cbBuffer = secBufferBytes.Length;\n                BufferType = (int)bufferType;\n                pvBuffer = Marshal.AllocHGlobal(cbBuffer);\n                Marshal.Copy(secBufferBytes, 0, pvBuffer, cbBuffer);\n            }\n\n            public void Dispose()\n            {\n                if (pvBuffer != IntPtr.Zero)\n                {\n                    Marshal.FreeHGlobal(pvBuffer);\n                    pvBuffer = IntPtr.Zero;\n                }\n            }\n        }\n\n        public struct MultipleSecBufferHelper\n        {\n            public byte[] Buffer;\n            public SecBufferType BufferType;\n\n            public MultipleSecBufferHelper(byte[] buffer, SecBufferType bufferType)\n            {\n                if (buffer == null || buffer.Length == 0)\n                {\n                    throw new ArgumentException("buffer cannot be null or 0 length");\n                }\n\n                Buffer = buffer;\n                BufferType = bufferType;\n            }\n        };\n\n        [StructLayout(LayoutKind.Sequential)]\n        public struct SecBufferDesc : IDisposable\n        {\n\n            public int ulVersion;\n            public int cBuffers;\n            public IntPtr pBuffers; //Point to SecBuffer\n\n            public SecBufferDesc(int bufferSize)\n            {\n                ulVersion = (int)SecBufferType.SECBUFFER_VERSION;\n                cBuffers = 1;\n                SecBuffer ThisSecBuffer = new SecBuffer(bufferSize);\n                pBuffers = Marshal.AllocHGlobal(Marshal.SizeOf(ThisSecBuffer));\n                Marshal.StructureToPtr(ThisSecBuffer, pBuffers, false);\n            }\n\n            public SecBufferDesc(byte[] secBufferBytes)\n            {\n                ulVersion = (int)SecBufferType.SECBUFFER_VERSION;\n                cBuffers = 1;\n                SecBuffer ThisSecBuffer = new SecBuffer(secBufferBytes);\n                pBuffers = Marshal.AllocHGlobal(Marshal.SizeOf(ThisSecBuffer));\n                Marshal.StructureToPtr(ThisSecBuffer, pBuffers, false);\n            }\n\n            public SecBufferDesc(MultipleSecBufferHelper[] secBufferBytesArray)\n            {\n                if (secBufferBytesArray == null || secBufferBytesArray.Length == 0)\n                {\n                    throw new ArgumentException("secBufferBytesArray cannot be null or 0 length");\n                }\n\n                ulVersion = (int)SecBufferType.SECBUFFER_VERSION;\n                cBuffers = secBufferBytesArray.Length;\n\n                //Allocate memory for SecBuffer Array....\n                pBuffers = Marshal.AllocHGlobal(Marshal.SizeOf(typeof(SecBuffer)) * cBuffers);\n\n                for (int Index = 0; Index < secBufferBytesArray.Length; Index++)\n                {\n                    //Super hack: Now allocate memory for the individual SecBuffers\n                    //and just copy the bit values to the SecBuffer array!!!\n                    SecBuffer ThisSecBuffer = new SecBuffer(secBufferBytesArray[Index].Buffer, secBufferBytesArray[Index].BufferType);\n\n                    //We will write out bits in the following order:\n                    //int cbBuffer;\n                    //int BufferType;\n                    //pvBuffer;\n                    //Note that we won\'t be releasing the memory allocated by ThisSecBuffer until we\n                    //are disposed...\n                    int CurrentOffset = Index * Marshal.SizeOf(typeof(SecBuffer));\n                    Marshal.WriteInt32(pBuffers, CurrentOffset, ThisSecBuffer.cbBuffer);\n                    Marshal.WriteInt32(pBuffers, CurrentOffset + Marshal.SizeOf(ThisSecBuffer.cbBuffer), ThisSecBuffer.BufferType);\n                    Marshal.WriteIntPtr(pBuffers, CurrentOffset + Marshal.SizeOf(ThisSecBuffer.cbBuffer) + Marshal.SizeOf(ThisSecBuffer.BufferType), ThisSecBuffer.pvBuffer);\n                }\n            }\n\n            public void Dispose()\n            {\n                if (pBuffers != IntPtr.Zero)\n                {\n                    if (cBuffers == 1)\n                    {\n                        SecBuffer ThisSecBuffer = (SecBuffer)Marshal.PtrToStructure(pBuffers, typeof(SecBuffer));\n                        ThisSecBuffer.Dispose();\n                    }\n                    else\n                    {\n                        for (int Index = 0; Index < cBuffers; Index++)\n                        {\n                            //The bits were written out the following order:\n                            //int cbBuffer;\n                            //int BufferType;\n                            //pvBuffer;\n                            //What we need to do here is to grab a hold of the pvBuffer allocate by the individual\n                            //SecBuffer and release it...\n                            int CurrentOffset = Index * Marshal.SizeOf(typeof(SecBuffer));\n                            IntPtr SecBufferpvBuffer = Marshal.ReadIntPtr(pBuffers, CurrentOffset + Marshal.SizeOf(typeof(int)) + Marshal.SizeOf(typeof(int)));\n                            Marshal.FreeHGlobal(SecBufferpvBuffer);\n                        }\n                    }\n\n                    Marshal.FreeHGlobal(pBuffers);\n                    pBuffers = IntPtr.Zero;\n                }\n            }\n\n            public byte[] GetSecBufferByteArray()\n            {\n                byte[] Buffer = null;\n\n                if (pBuffers == IntPtr.Zero)\n                {\n                    throw new InvalidOperationException("Object has already been disposed!!!");\n                }\n\n                if (cBuffers == 1)\n                {\n                    SecBuffer ThisSecBuffer = (SecBuffer)Marshal.PtrToStructure(pBuffers, typeof(SecBuffer));\n\n                    if (ThisSecBuffer.cbBuffer > 0)\n                    {\n                        Buffer = new byte[ThisSecBuffer.cbBuffer];\n                        Marshal.Copy(ThisSecBuffer.pvBuffer, Buffer, 0, ThisSecBuffer.cbBuffer);\n                    }\n                }\n                else\n                {\n                    int BytesToAllocate = 0;\n\n                    for (int Index = 0; Index < cBuffers; Index++)\n                    {\n                        //The bits were written out the following order:\n                        //int cbBuffer;\n                        //int BufferType;\n                        //pvBuffer;\n                        //What we need to do here calculate the total number of bytes we need to copy...\n                        int CurrentOffset = Index * Marshal.SizeOf(typeof(SecBuffer));\n                        BytesToAllocate += Marshal.ReadInt32(pBuffers, CurrentOffset);\n                    }\n\n                    Buffer = new byte[BytesToAllocate];\n\n                    for (int Index = 0, BufferIndex = 0; Index < cBuffers; Index++)\n                    {\n                        //The bits were written out the following order:\n                        //int cbBuffer;\n                        //int BufferType;\n                        //pvBuffer;\n                        //Now iterate over the individual buffers and put them together into a\n                        //byte array...\n                        int CurrentOffset = Index * Marshal.SizeOf(typeof(SecBuffer));\n                        int BytesToCopy = Marshal.ReadInt32(pBuffers, CurrentOffset);\n                        IntPtr SecBufferpvBuffer = Marshal.ReadIntPtr(pBuffers, CurrentOffset + Marshal.SizeOf(typeof(int)) + Marshal.SizeOf(typeof(int)));\n                        Marshal.Copy(SecBufferpvBuffer, Buffer, BufferIndex, BytesToCopy);\n                        BufferIndex += BytesToCopy;\n                    }\n                }\n\n                return (Buffer);\n            }\n        }\n\n        [StructLayout(LayoutKind.Sequential)]\n        public struct SECURITY_INTEGER\n        {\n            public uint LowPart;\n            public int HighPart;\n            public SECURITY_INTEGER(int dummy)\n            {\n                LowPart = 0;\n                HighPart = 0;\n            }\n        };\n\n        [StructLayout(LayoutKind.Sequential)]\n        public struct SECURITY_HANDLE\n        {\n            public IntPtr LowPart;\n            public IntPtr HighPart;\n            public SECURITY_HANDLE(int dummy)\n            {\n                LowPart = HighPart = IntPtr.Zero;\n            }\n        };\n\n        [StructLayout(LayoutKind.Sequential)]\n        public struct SecPkgContext_Sizes\n        {\n            public uint cbMaxToken;\n            public uint cbMaxSignature;\n            public uint cbBlockSize;\n            public uint cbSecurityTrailer;\n        };\n\n        // taken from https://github.com/tevora-threat/SharpView\n        [StructLayout(LayoutKind.Sequential)]\n        public class NetResource\n        {\n            public ResourceScope Scope;\n            public ResourceType ResourceType;\n            public ResourceDisplaytype DisplayType;\n            public int Usage;\n            public string LocalName;\n            public string RemoteName;\n            public string Comment;\n            public string Provider;\n        }\n\n        \n\n\n\n        // functions\n        // Adapted from Vincent LE TOUX\' "MakeMeEnterpriseAdmin"\n        [DllImport("cryptdll.Dll", CharSet = CharSet.Auto, SetLastError = false)]\n        public static extern int CDLocateCSystem(KERB_ETYPE type, out IntPtr pCheckSum);\n\n        [DllImport("cryptdll.Dll", CharSet = CharSet.Auto, SetLastError = false)]\n        public static extern int CDLocateCheckSum(KERB_CHECKSUM_ALGORITHM type, out IntPtr pCheckSum);\n\n        //  https://github.com/vletoux/MakeMeEnterpriseAdmin/blob/master/MakeMeEnterpriseAdmin.ps1#L1753-L1767\n        public delegate int KERB_ECRYPT_Initialize(byte[] Key, int KeySize, int KeyUsage, out IntPtr pContext);\n        public delegate int KERB_ECRYPT_Encrypt(IntPtr pContext, byte[] data, int dataSize, byte[] output, ref int outputSize);\n        public delegate int KERB_ECRYPT_Decrypt(IntPtr pContext, byte[] data, int dataSize, byte[] output, ref int outputSize);\n        public delegate int KERB_ECRYPT_Finish(ref IntPtr pContext);\n\n        public delegate int KERB_ECRYPT_HashPassword(UNICODE_STRING Password, UNICODE_STRING Salt, int count, byte[] output);\n\n        //https://github.com/vletoux/MakeMeEnterpriseAdmin/blob/master/MakeMeEnterpriseAdmin.ps1#L1760-L1767\n        public delegate int KERB_CHECKSUM_Initialize(int unk0, out IntPtr pContext);\n        public delegate int KERB_CHECKSUM_Sum(IntPtr pContext, int Size, byte[] Buffer);\n        public delegate int KERB_CHECKSUM_Finalize(IntPtr pContext, byte[] Buffer);\n        public delegate int KERB_CHECKSUM_Finish(ref IntPtr pContext);\n        public delegate int KERB_CHECKSUM_InitializeEx(byte[] Key, int KeySize, int KeyUsage, out IntPtr pContext);\n\n\n        [DllImport("Netapi32.dll", CharSet = CharSet.Auto, SetLastError = true)]\n        public static extern int DsGetDcName(\n            [MarshalAs(UnmanagedType.LPTStr)] string ComputerName,\n            [MarshalAs(UnmanagedType.LPTStr)] string DomainName,\n            [In] int DomainGuid,\n            [MarshalAs(UnmanagedType.LPTStr)] string SiteName,\n            [MarshalAs(UnmanagedType.U4)] DSGETDCNAME_FLAGS flags,\n            out IntPtr pDOMAIN_CONTROLLER_INFO);\n\n        [DllImport("Netapi32.dll", SetLastError = true)]\n        public static extern int NetApiBufferFree(IntPtr Buffer);\n\n        [DllImport("kernel32.dll")]\n        public extern static void GetSystemTime(ref SYSTEMTIME lpSystemTime);\n\n        // LSA functions\n\n        [DllImport("secur32.dll", SetLastError = false)]\n        public static extern int LsaConnectUntrusted(\n            [Out] out IntPtr LsaHandle\n        );\n\n        [DllImport("secur32.dll", SetLastError = false)]\n        public static extern int LsaLookupAuthenticationPackage(\n            [In] IntPtr LsaHandle,\n            [In] ref LSA_STRING_IN PackageName,\n            [Out] out int AuthenticationPackage\n        );\n\n        [DllImport("kernel32.dll")]\n        public static extern IntPtr LocalAlloc(\n            uint uFlags,\n            uint uBytes\n        );\n\n        [DllImport("advapi32.dll", SetLastError = true)]\n        public static extern uint LsaNtStatusToWinError(\n            uint status\n        );\n\n        [DllImport("advapi32.dll", SetLastError = true, PreserveSig = true)]\n        public static extern uint LsaFreeMemory(\n            IntPtr buffer\n        );\n\n        [DllImport("kernel32.dll", EntryPoint = "CopyMemory", SetLastError = false)]\n        public static extern void CopyMemory(\n            IntPtr dest,\n            IntPtr src,\n            uint count\n        );\n\n        [DllImport("secur32.dll", SetLastError = false)]\n        public static extern int LsaCallAuthenticationPackage(\n            IntPtr LsaHandle,\n            int AuthenticationPackage,\n            IntPtr ProtocolSubmitBuffer,\n            int SubmitBufferLength,\n            out IntPtr ProtocolReturnBuffer,\n            out int ReturnBufferLength,\n            out int ProtocolStatus\n        );\n\n        [DllImport("secur32.dll", SetLastError = false)]\n        public static extern int LsaDeregisterLogonProcess(\n            [In] IntPtr LsaHandle\n        );\n\n        [DllImport("secur32.dll", SetLastError = true)]\n        public static extern int LsaRegisterLogonProcess(\n            LSA_STRING_IN LogonProcessName,\n            out IntPtr LsaHandle,\n            out ulong SecurityMode\n        );\n\n        // for GetSystem()\n        [DllImport("advapi32.dll", SetLastError = true)]\n        [return: MarshalAs(UnmanagedType.Bool)]\n        public static extern bool OpenProcessToken(\n            IntPtr ProcessHandle,\n            UInt32 DesiredAccess,\n            out IntPtr TokenHandle);\n\n        [DllImport("advapi32.dll")]\n        public static extern bool DuplicateToken(\n            IntPtr ExistingTokenHandle,\n            int SECURITY_IMPERSONATION_LEVEL,\n            ref IntPtr DuplicateTokenHandle);\n\n        [DllImport("advapi32.dll", SetLastError = true)]\n        public static extern bool ImpersonateLoggedOnUser(\n            IntPtr hToken);\n\n        [DllImport("advapi32.dll", SetLastError = true)]\n        public static extern bool RevertToSelf();\n\n        [DllImport("kernel32.dll")]\n        public static extern uint GetLastError();\n\n        [DllImport("advapi32.dll", SetLastError = true)]\n        public static extern bool GetTokenInformation(\n            IntPtr TokenHandle,\n            TOKEN_INFORMATION_CLASS TokenInformationClass,\n            IntPtr TokenInformation,\n            int TokenInformationLength,\n            out int ReturnLength);\n\n        [DllImport("advapi32.dll", SetLastError = true, CharSet = CharSet.Unicode)]\n        public static extern bool CreateProcessWithLogonW(\n            String userName,\n            String domain,\n            String password,\n            UInt32 logonFlags,\n            String applicationName,\n            String commandLine,\n            UInt32 creationFlags,\n            UInt32 environment,\n            String currentDirectory,\n            ref STARTUPINFO startupInfo,\n            out PROCESS_INFORMATION processInformation);\n\n        [DllImport("kernel32.dll", SetLastError = true)]\n        [return: MarshalAs(UnmanagedType.Bool)]\n        public static extern bool CloseHandle(\n            IntPtr hObject\n        );\n\n        [DllImport("Secur32.dll", SetLastError = false)]\n        public static extern int LsaEnumerateLogonSessions(\n            out UInt64 LogonSessionCount,\n            out IntPtr LogonSessionList\n        );\n\n        [DllImport("Secur32.dll", SetLastError = false)]\n        public static extern uint LsaGetLogonSessionData(\n            IntPtr luid,\n            out IntPtr ppLogonSessionData\n        );\n\n        [DllImport("secur32.dll", SetLastError = false)]\n        public static extern uint LsaFreeReturnBuffer(\n            IntPtr buffer\n        );\n\n        // adapted from https://www.pinvoke.net/default.aspx/secur32.InitializeSecurityContext\n        [DllImport("secur32.dll", CharSet = CharSet.Auto, SetLastError = true)]\n        public static extern int AcquireCredentialsHandle(\n            string pszPrincipal, //SEC_CHAR*\n            string pszPackage, //SEC_CHAR* //"Kerberos","NTLM","Negotiative"\n            int fCredentialUse,\n            IntPtr PAuthenticationID,//_LUID AuthenticationID,//pvLogonID,//PLUID\n            IntPtr pAuthData,//PVOID\n            int pGetKeyFn, //SEC_GET_KEY_FN\n            IntPtr pvGetKeyArgument, //PVOID\n            ref SECURITY_HANDLE phCredential, //SecHandle //PCtxtHandle ref\n            ref SECURITY_INTEGER ptsExpiry  //PTimeStamp //TimeStamp ref\n        );\n\n        [DllImport("secur32.dll", SetLastError = true)]\n        public static extern int InitializeSecurityContext(\n            ref SECURITY_HANDLE phCredential,//PCredHandle\n            IntPtr phContext, //PCtxtHandle\n            string pszTargetName,\n            int fContextReq,\n            int Reserved1,\n            int TargetDataRep,\n            IntPtr pInput, //PSecBufferDesc SecBufferDesc\n            int Reserved2,\n            out SECURITY_HANDLE phNewContext, //PCtxtHandle\n            out SecBufferDesc pOutput, //PSecBufferDesc SecBufferDesc\n            out uint pfContextAttr, //managed ulong == 64 bits!!!\n            out SECURITY_INTEGER ptsExpiry  //PTimeStamp\n        );\n\n        [DllImport("secur32.dll")]\n        public static extern int DeleteSecurityContext(\n            ref SECURITY_HANDLE phContext\n        );\n\n        [DllImport("secur32.dll", CharSet = CharSet.Auto)]\n        public static extern int FreeCredentialsHandle(\n            [In] ref SECURITY_HANDLE phCredential\n        );\n\n        [DllImport("Secur32.dll")]\n        public static extern int FreeContextBuffer(\n            ref IntPtr pvContextBuffer\n        );\n\n        // taken from https://github.com/tevora-threat/SharpView\n        [DllImport("mpr.dll")]\n        public static extern int WNetAddConnection2(NetResource netResource,\n            string password, string username, int flags);\n\n        [DllImport("mpr.dll")]\n        public static extern int WNetCancelConnection2(string name, int flags,\n            bool force);\n    }\n}'