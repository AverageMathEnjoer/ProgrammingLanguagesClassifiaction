b'using System.Diagnostics;\n\nnamespace CS_SQLite3\n{\n  using sqlite3_stmt = CSSQLite.Vdbe;\n\n  public partial class CSSQLite\n  {\n    /*\n    ** 2007 May 1\n    **\n    ** The author disclaims copyright to this source code.  In place of\n    ** a legal notice, here is a blessing:\n    **\n    **    May you do good and not evil.\n    **    May you find forgiveness for yourself and forgive others.\n    **    May you share freely, never taking more than you give.\n    **\n    *************************************************************************\n    **\n    ** This file contains code used to implement incremental BLOB I/O.\n    **\n    ** $Id: vdbeblob.c,v 1.35 2009/07/02 07:47:33 danielk1977 Exp $\n    **\n    *************************************************************************\n    **  Included in SQLite3 port to C#-SQLite;  2008 Noah B Hart\n    **  C#-SQLite is an independent reimplementation of the SQLite software library\n    **\n    **  $Header$\n    *************************************************************************\n    */\n\n    //#include "sqliteInt.h"\n    //#include "vdbeInt.h"\n\n#if !SQLITE_OMIT_INCRBLOB\n\n/*\n** Valid sqlite3_blob* handles point to Incrblob structures.\n*/\n//typedef struct Incrblob Incrblob;\npublic struct Incrblob\n{\nint flags;              /* Copy of "flags" passed to sqlite3_blob_open() */\nint nByte;              /* Size of open blob, in bytes */\nint iOffset;            /* Byte offset of blob in cursor data */\nBtCursor pCsr;         /* Cursor pointing at blob row */\nsqlite3_stmt pStmt;    /* Statement holding cursor open */\nsqlite3 db;            /* The associated database */\n};\n\n/*\n** Open a blob handle.\n*/\n//int sqlite3_blob_open(\n//  sqlite3* db,            /* The database connection */\n//  const char *zDb,        /* The attached database containing the blob */\n//  const char *zTable,     /* The table containing the blob */\n//  const char *zColumn,    /* The column containing the blob */\n//  sqlite_int64 iRow,      /* The row containing the glob */\n//  int flags,              /* True . read/write access, false . read-only */\n//  sqlite3_blob **ppBlob   /* Handle for accessing the blob returned here */\n//){\n//  int nAttempt = 0;\n//  int iCol;               /* Index of zColumn in row-record */\n\n//  /* This VDBE program seeks a btree cursor to the identified\n//  ** db/table/row entry. The reason for using a vdbe program instead\n//  ** of writing code to use the b-tree layer directly is that the\n//  ** vdbe program will take advantage of the various transaction,\n//  ** locking and error handling infrastructure built into the vdbe.\n//  **\n//  ** After seeking the cursor, the vdbe executes an OP_ResultRow.\n//  ** Code external to the Vdbe then "borrows" the b-tree cursor and\n//  ** uses it to implement the blob_read(), blob_write() and\n//  ** blob_bytes() functions.\n//  **\n//  ** The sqlite3_blob_close() function finalizes the vdbe program,\n//  ** which closes the b-tree cursor and (possibly) commits the\n//  ** transaction.\n//  */\n//  static const VdbeOpList openBlob[] = {\n//    {OP_Transaction, 0, 0, 0},     /* 0: Start a transaction */\n//    {OP_VerifyCookie, 0, 0, 0},    /* 1: Check the schema cookie */\n\n//    /* One of the following two instructions is replaced by an OP_Noop. */\n//    {OP_OpenRead, 0, 0, 0},        /* 3: Open cursor 0 for reading */\n//    {OP_OpenWrite, 0, 0, 0},       /* 4: Open cursor 0 for read/write */\n//\n//    {OP_Variable, 1, 1, 1},        /* 5: Push the rowid to the stack */\n//    {OP_NotExists, 0, 9, 1},       /* 6: Seek the cursor */\n//    {OP_Column, 0, 0, 1},          /* 7  */\n//    {OP_ResultRow, 1, 0, 0},       /* 8  */\n//    {OP_Close, 0, 0, 0},           /* 9  */\n//    {OP_Halt, 0, 0, 0},            /* 10 */\n//  };\n\n//  Vdbe *v = 0;\n//  int rc = SQLITE_OK;\n//  char *zErr = 0;\n//  Table *pTab;\n//  Parse *pParse;\n\n//  *ppBlob = 0;\n//  sqlite3_mutex_enter(db.mutex);\n//  pParse = sqlite3StackAllocRaw(db, sizeof(*pParse));\n//  if( pParse==0 ){\n//    rc = SQLITE_NOMEM;\n//    goto blob_open_out;\n//  }\n//  do {\n//    memset(pParse, 0, sizeof(Parse));\n//    pParse->db = db;\n//if( sqlite3SafetyOn(db) ){\n//      sqlite3DbFree(db, zErr);\n//      sqlite3StackFree(db, pParse);\n//  sqlite3_mutex_leave(db.mutex);\n//  return SQLITE_MISUSE;\n//}\n\n//    sqlite3BtreeEnterAll(db);\n//    pTab = sqlite3LocateTable(pParse, 0, zTable, zDb);\n//    if( pTab && IsVirtual(pTab) ){\n//      pTab = 0;\n//      sqlite3ErrorMsg(pParse, "cannot open virtual table: %s", zTable);\n//    }\n//#if !SQLITE_OMIT_VIEW\n//    if( pTab && pTab.pSelect ){\n//      pTab = 0;\n//      sqlite3ErrorMsg(pParse, "cannot open view: %s", zTable);\n//    }\n//#endif\n//    if( null==pTab ){\n//      if( sParse.zErrMsg ){\n//        sqlite3_snprintf(sizeof(zErr), zErr, "%s", sParse.zErrMsg);\n//      if( pParse->zErrMsg ){\n//        //sqlite3DbFree(db, zErr);\n//        zErr = pParse->zErrMsg;\n//        pParse->zErrMsg = 0;\n//      }\n//      rc = SQLITE_ERROR;\n//      (void)sqlite3SafetyOff(db);\n//      sqlite3BtreeLeaveAll(db);\n//      goto blob_open_out;\n//    }\n\n//    /* Now search pTab for the exact column. */\n//    for(iCol=0; iCol < pTab.nCol; iCol++) {\n//      if( sqlite3StrICmp(pTab.aCol[iCol].zName, zColumn)==0 ){\n//        break;\n//      }\n//    }\n//    if( iCol==pTab.nCol ){\n//      sqlite3DbFree(db, zErr);\n//      zErr = sqlite3MPrintf(db, "no such column: \\"%s\\"", zColumn);\n//      rc = SQLITE_ERROR;\n//      (void)sqlite3SafetyOff(db);\n//      sqlite3BtreeLeaveAll(db);\n//      goto blob_open_out;\n//    }\n\n//    /* If the value is being opened for writing, check that the\n//    ** column is not indexed. It is against the rules to open an\n//    ** indexed column for writing.\n//    */\n//    if( flags ){\n//      Index pIdx;\n//      for(pIdx=pTab.pIndex; pIdx; pIdx=pIdx.pNext){\n//        int j;\n//        for(j=0; j<pIdx.nColumn; j++){\n//          if( pIdx.aiColumn[j]==iCol ){\n//            sqlite3DbFree(db, zErr);\n//            zErr = sqlite3MPrintf(db,\n//                             "cannot open indexed column for writing");\n//            rc = SQLITE_ERROR;\n//            (void)sqlite3SafetyOff(db);\n//            sqlite3BtreeLeaveAll(db);\n//            goto blob_open_out;\n//          }\n//        }\n//      }\n//    }\n\n//    v = sqlite3VdbeCreate(db);\n//    if( v ){\n//      int iDb = sqlite3SchemaToIndex(db, pTab.pSchema);\n//      sqlite3VdbeAddOpList(v, sizeof(openBlob)/sizeof(VdbeOpList), openBlob);\n//      flags = !!flags;                 /* flags = (flags ? 1 : 0); */\n\n//      /* Configure the OP_Transaction */\n//      sqlite3VdbeChangeP1(v, 0, iDb);\n//      sqlite3VdbeChangeP2(v, 0, flags);\n\n//      /* Configure the OP_VerifyCookie */\n//      sqlite3VdbeChangeP1(v, 1, iDb);\n//      sqlite3VdbeChangeP2(v, 1, pTab.pSchema.schema_cookie);\n\n//      /* Make sure a mutex is held on the table to be accessed */\n//      sqlite3VdbeUsesBtree(v, iDb);\n\n//      /* Configure the OP_TableLock instruction */\n//      sqlite3VdbeChangeP1(v, 2, iDb);\n//      sqlite3VdbeChangeP2(v, 2, pTab->tnum);\n//      sqlite3VdbeChangeP3(v, 2, flags);\n//      sqlite3VdbeChangeP4(v, 2, pTab->zName, P4_TRANSIENT);\n\n//      /* Remove either the OP_OpenWrite or OpenRead. Set the P2\n//      ** parameter of the other to pTab->tnum.  */\n//      sqlite3VdbeChangeToNoop(v, 4 - flags, 1);\n//      sqlite3VdbeChangeP2(v, 3 + flags, pTab->tnum);\n//      sqlite3VdbeChangeP3(v, 3 + flags, iDb);\n\n//  /* Configure the number of columns. Configure the cursor to\n//  ** think that the table has one more column than it really\n//  ** does. An OP_Column to retrieve this imaginary column will\n//  ** always return an SQL NULL. This is useful because it means\n//  ** we can invoke OP_Column to fill in the vdbe cursors type\n//  ** and offset cache without causing any IO.\n//  */\n//      sqlite3VdbeChangeP4(v, 3+flags, SQLITE_INT_TO_PTR(pTab->nCol+1),P4_INT32);\n//      sqlite3VdbeChangeP2(v, 7, pTab->nCol);\n//  if( !db->mallocFailed ){\n//    sqlite3VdbeMakeReady(v, 1, 1, 1, 0);\n//  }\n//}\n\n//    sqlite3BtreeLeaveAll(db);\n//    rc = sqlite3SafetyOff(db);\n//    if( NEVER(rc!=SQLITE_OK) /* || db.mallocFailed !=0 */ ){\n//      goto blob_open_out;\n//    }\n\n//    sqlite3_bind_int64((sqlite3_stmt *)v, 1, iRow);\n//    rc = sqlite3_step((sqlite3_stmt *)v);\n//    if( rc!=SQLITE_ROW ){\n//      nAttempt++;\n//      rc = sqlite3_finalize((sqlite3_stmt *)v);\n//      sqlite3DbFree(db, zErr);\n//      zErr = sqlite3MPrintf(db, sqlite3_errmsg(db));\n//      v = 0;\n//    }\n//  } while( nAttempt<5 && rc==SQLITE_SCHEMA );\n\n//  if( rc==SQLITE_ROW ){\n//    /* The row-record has been opened successfully. Check that the\n//    ** column in question contains text or a blob. If it contains\n//    ** text, it is up to the caller to get the encoding right.\n//    */\n//    Incrblob pBlob;\n//    u32 type = v.apCsr[0].aType[iCol];\n\n//    if( type<12 ){\n//      sqlite3DbFree(db, zErr);\n//      zErr = sqlite3MPrintf(db, "cannot open value of type %s",\n//          type==0?"null": type==7?"real": "integer"\n//      );\n//      rc = SQLITE_ERROR;\n//      goto blob_open_out;\n//    }\n//    pBlob = (Incrblob *)sqlite3DbMallocZero(db, sizeof(Incrblob));\n//    if( db.mallocFailed !=0{\n//      //sqlite3DbFree(db,pBlob);\n//      goto blob_open_out;\n//    }\n//    pBlob.flags = flags;\n//    pBlob.pCsr =  v.apCsr[0].pCursor;\n//    sqlite3BtreeEnterCursor(pBlob.pCsr);\n//    sqlite3BtreeCacheOverflow(pBlob.pCsr);\n//    sqlite3BtreeLeaveCursor(pBlob.pCsr);\n//    pBlob.pStmt = (sqlite3_stmt *)v;\n//    pBlob.iOffset = v.apCsr[0].aOffset[iCol];\n//    pBlob.nByte = sqlite3VdbeSerialTypeLen(type);\n//    pBlob.db = db;\n//    ppBlob = (sqlite3_blob *)pBlob;\n//    rc = SQLITE_OK;\n//  }else if( rc==SQLITE_OK ){\n//    sqlite3DbFree(db, zErr);\n//    zErr = sqlite3MPrintf(db, "no such rowid: %lld", iRow);\n//    rc = SQLITE_ERROR;\n//  }\n\n//blob_open_out:\n//  if( v && (rc!=SQLITE_OK || db->mallocFailed) ){\n//    sqlite3VdbeFinalize(v);\n//  }\n//  sqlite3Error(db, rc, zErr);\n//  sqlite3DbFree(db, zErr);\n//  sqlite3StackFree(db, pParse);\n//  rc = sqlite3ApiExit(db, rc);\n//  sqlite3_mutex_leave(db->mutex);\n//  return rc;\n//}\n\n///*\n//** Close a blob handle that was previously created using\n//** sqlite3_blob_open().\n//*/\n//int sqlite3_blob_close(sqlite3_blob *pBlob){\n//  Incrblob *p = (Incrblob *)pBlob;\n//  int rc;\n//  sqlite3 *db;\n\n//  if( p ){\n//    db = p->db;\n//    sqlite3_mutex_enter(db->mutex);\n//    rc = sqlite3_finalize(p->pStmt);\n//    sqlite3DbFree(db, p);\n//    sqlite3_mutex_leave(db->mutex);\n//  }else{\n//    rc = SQLITE_OK;\n//  }\n//  return rc;\n//}\n\n/*\n** Perform a read or write operation on a blob\n*/\n//static int blobReadWrite(\n//  sqlite3_blob pBlob,\n//  void *z,\n//  int n,\n//  int iOffset,\n//  int (*xCall)(BtCursor*, u32, u32, void*)\n//){\n//  int rc;\n//  Incrblob p = (Incrblob *)pBlob;\n//  Vdbe *v;\n//  sqlite3 db;\n\n//  if( p==0 ) return SQLITE_MISUSE;\n//  db = p->db;\n//  sqlite3_mutex_enter(db.mutex);\n//    v = (Vdbe*)p->pStmt;\n\n//if( n<0 || iOffset<0 || (iOffset+n)>p->nByte ){\n//  /* Request is out of range. Return a transient error. */\n//  rc = SQLITE_ERROR;\n//  sqlite3Error(db, SQLITE_ERROR, 0);\n//} else if( v==0 ){\n\n//  /* If there is no statement handle, then the blob-handle has\n//  ** already been invalidated. Return SQLITE_ABORT in this case.\n//  */\n//    rc = SQLITE_ABORT;\n//  }else{\n//    /* Call either BtreeData() or BtreePutData(). If SQLITE_ABORT is\n//    ** returned, clean-up the statement handle.\n//    */\n//    Debug.Assert( db == v.db );\n//    sqlite3BtreeEnterCursor(p.pCsr);\n//    rc = xCall(p.pCsr, iOffset+p.iOffset, n, z);\n//    sqlite3BtreeLeaveCursor(p.pCsr);\n//    if( rc==SQLITE_ABORT ){\n//      sqlite3VdbeFinalize(v);\n//      p.pStmt = null;\n//    }else{\n//      db.errCode = rc;\n//      v.rc = rc;\n//    }\n//  }\n//  rc = sqlite3ApiExit(db, rc);\n//  sqlite3_mutex_leave(db.mutex);\n//  return rc;\n//}\n\n/*\n** Read data from a blob handle.\n*/\n//int sqlite3_blob_read(sqlite3_blob pBlob, void *z, int n, int iOffset){\n//  return blobReadWrite(pBlob, z, n, iOffset, sqlite3BtreeData);\n//}\n\n/*\n** Write data to a blob handle.\n*/\n//int sqlite3_blob_write(sqlite3_blob pBlob, const void *z, int n, int iOffset){\n//  return blobReadWrite(pBlob, (void *)z, n, iOffset, sqlite3BtreePutData);\n//}\n\n/*\n** Query a blob handle for the size of the data.\n**\n** The Incrblob.nByte field is fixed for the lifetime of the Incrblob\n** so no mutex is required for access.\n*/\n//int sqlite3_blob_bytes(sqlite3_blob pBlob){\n//  Incrblob p = (Incrblob *)pBlob;\n//  return p ? p->nByte : 0;\n//}\n\n#endif // * #if !SQLITE_OMIT_INCRBLOB */\n  }\n}\n'