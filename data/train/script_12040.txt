b'/*\n * Copyright (C) 2015 Naman Dwivedi\n *\n * Licensed under the GNU General Public License v3\n *\n * This is free software: you can redistribute it and/or modify it\n * under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or (at your option) any later version.\n *\n * This software is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n * See the GNU General Public License for more details.\n */\n\npackage com.naman14.timber.transition;\n\nimport android.animation.Animator;\nimport android.animation.AnimatorListenerAdapter;\nimport android.animation.AnimatorSet;\nimport android.animation.ObjectAnimator;\nimport android.animation.TimeInterpolator;\nimport android.annotation.TargetApi;\nimport android.content.Context;\nimport android.content.res.TypedArray;\nimport android.graphics.Bitmap;\nimport android.graphics.Canvas;\nimport android.graphics.Color;\nimport android.graphics.Path;\nimport android.graphics.Rect;\nimport android.graphics.drawable.BitmapDrawable;\nimport android.graphics.drawable.ColorDrawable;\nimport android.graphics.drawable.Drawable;\nimport android.graphics.drawable.ShapeDrawable;\nimport android.graphics.drawable.shapes.OvalShape;\nimport android.transition.Transition;\nimport android.transition.TransitionValues;\nimport android.util.ArrayMap;\nimport android.util.AttributeSet;\nimport android.view.View;\nimport android.view.ViewAnimationUtils;\nimport android.view.ViewGroup;\n\nimport com.naman14.timber.R;\n\nimport java.util.ArrayList;\n\n@TargetApi(21)\npublic class PlayTransition extends Transition {\n    private static final String PROPERTY_BOUNDS = "circleTransition:bounds";\n    private static final String PROPERTY_POSITION = "circleTransition:position";\n    private static final String PROPERTY_IMAGE = "circleTransition:image";\n    private static final String[] TRANSITION_PROPERTIES = {\n            PROPERTY_BOUNDS,\n            PROPERTY_POSITION,\n    };\n\n    private int mColor = Color.parseColor("#6c1622");\n\n    public PlayTransition() {\n    }\n\n    public PlayTransition(Context context, AttributeSet attrs) {\n        super(context, attrs);\n        TypedArray a = context.obtainStyledAttributes(attrs, R.styleable.PlayTransition);\n        setColor(a.getColor(R.styleable.PlayTransition_colorCT, getColor()));\n        a.recycle();\n    }\n\n    public void setColor(int color) {\n        mColor = color;\n    }\n\n    public int getColor() {\n        return mColor;\n    }\n\n    @Override\n    public String[] getTransitionProperties() {\n        return TRANSITION_PROPERTIES;\n    }\n\n    private void captureValues(TransitionValues transitionValues) {\n        final View view = transitionValues.view;\n        transitionValues.values.put(PROPERTY_BOUNDS, new Rect(\n                view.getLeft(), view.getTop(), view.getRight(), view.getBottom()\n        ));\n        int[] position = new int[2];\n        transitionValues.view.getLocationInWindow(position);\n        transitionValues.values.put(PROPERTY_POSITION, position);\n    }\n\n    @Override\n    public void captureEndValues(TransitionValues transitionValues) {\n        final View view = transitionValues.view;\n        if (view.getWidth() <= 0 || view.getHeight() <= 0) {\n            return;\n        }\n        captureValues(transitionValues);\n    }\n\n    @Override\n    public void captureStartValues(TransitionValues transitionValues) {\n        final View view = transitionValues.view;\n        if (view.getWidth() <= 0 || view.getHeight() <= 0) {\n            return;\n        }\n        captureValues(transitionValues);\n        Bitmap bitmap = Bitmap.createBitmap(view.getWidth(), view.getHeight(),\n                Bitmap.Config.ARGB_8888);\n        Canvas canvas = new Canvas(bitmap);\n        view.draw(canvas);\n        transitionValues.values.put(PROPERTY_IMAGE, bitmap);\n    }\n\n    @Override\n    public Animator createAnimator(final ViewGroup sceneRoot, TransitionValues startValues,\n                                   final TransitionValues endValues) {\n        if (startValues == null || endValues == null) {\n            return null;\n        }\n        Rect startBounds = (Rect) startValues.values.get(PROPERTY_BOUNDS);\n        Rect endBounds = (Rect) endValues.values.get(PROPERTY_BOUNDS);\n        if (startBounds == null || endBounds == null || startBounds.equals(endBounds)) {\n            return null;\n        }\n        Bitmap startImage = (Bitmap) startValues.values.get(PROPERTY_IMAGE);\n        Drawable startBackground = new BitmapDrawable(sceneRoot.getContext().getResources(), startImage);\n        final View startView = addViewToOverlay(sceneRoot, startImage.getWidth(),\n                startImage.getHeight(), startBackground);\n        Drawable shrinkingBackground = new ColorDrawable(mColor);\n        final View shrinkingView = addViewToOverlay(sceneRoot, startImage.getWidth(),\n                startImage.getHeight(), shrinkingBackground);\n\n        int[] sceneRootLoc = new int[2];\n        sceneRoot.getLocationInWindow(sceneRootLoc);\n        int[] startLoc = (int[]) startValues.values.get(PROPERTY_POSITION);\n        int startTranslationX = startLoc[0] - sceneRootLoc[0];\n        int startTranslationY = startLoc[1] - sceneRootLoc[1];\n\n        startView.setTranslationX(startTranslationX);\n        startView.setTranslationY(startTranslationY);\n        shrinkingView.setTranslationX(startTranslationX);\n        shrinkingView.setTranslationY(startTranslationY);\n\n        final View endView = endValues.view;\n        float startRadius = calculateMaxRadius(shrinkingView);\n        int minRadius = Math.min(calculateMinRadius(shrinkingView), calculateMinRadius(endView));\n\n        ShapeDrawable circleBackground = new ShapeDrawable(new OvalShape());\n        circleBackground.getPaint().setColor(mColor);\n        final View circleView = addViewToOverlay(sceneRoot, minRadius * 2, minRadius * 2,\n                circleBackground);\n        float circleStartX = startLoc[0] - sceneRootLoc[0] +\n                ((startView.getWidth() - circleView.getWidth()) / 2);\n        float circleStartY = startLoc[1] - sceneRootLoc[1] +\n                ((startView.getHeight() - circleView.getHeight()) / 2);\n        circleView.setTranslationX(circleStartX);\n        circleView.setTranslationY(circleStartY);\n\n        circleView.setVisibility(View.INVISIBLE);\n        shrinkingView.setAlpha(0f);\n        endView.setAlpha(0f);\n\n        Animator shrinkingAnimator = createCircularReveal(shrinkingView, startRadius, minRadius);\n        shrinkingAnimator.addListener(new AnimatorListenerAdapter() {\n\n            @Override\n            public void onAnimationEnd(Animator animation) {\n                shrinkingView.setVisibility(View.INVISIBLE);\n                startView.setVisibility(View.INVISIBLE);\n                circleView.setVisibility(View.VISIBLE);\n            }\n        });\n\n        Animator startAnimator = createCircularReveal(startView, startRadius, minRadius);\n        Animator fadeInAnimator = ObjectAnimator.ofFloat(shrinkingView, View.ALPHA, 0, 1);\n\n        AnimatorSet shrinkFadeSet = new AnimatorSet();\n        shrinkFadeSet.playTogether(shrinkingAnimator, startAnimator,\n                fadeInAnimator);\n\n        int[] endLoc = (int[]) endValues.values.get(PROPERTY_POSITION);\n        float circleEndX = endLoc[0] - sceneRootLoc[0] +\n                ((endView.getWidth() - circleView.getWidth()) / 2);\n        float circleEndY = endLoc[1] - sceneRootLoc[1] +\n                ((endView.getHeight() - circleView.getHeight()) / 2);\n        Path circlePath = getPathMotion().getPath(circleStartX, circleStartY, circleEndX,\n                circleEndY);\n        Animator circleAnimator = ObjectAnimator.ofFloat(circleView, View.TRANSLATION_X,\n                View.TRANSLATION_Y, circlePath);\n\n        final View growingView = addViewToOverlay(sceneRoot, endView.getWidth(),\n                endView.getHeight(), shrinkingBackground);\n        growingView.setVisibility(View.INVISIBLE);\n        float endTranslationX = endLoc[0] - sceneRootLoc[0];\n        float endTranslationY = endLoc[1] - sceneRootLoc[1];\n        growingView.setTranslationX(endTranslationX);\n        growingView.setTranslationY(endTranslationY);\n\n        float endRadius = calculateMaxRadius(endView);\n\n        circleAnimator.addListener(new AnimatorListenerAdapter() {\n            @Override\n            public void onAnimationEnd(Animator animation) {\n                circleView.setVisibility(View.INVISIBLE);\n                growingView.setVisibility(View.VISIBLE);\n                endView.setAlpha(1f);\n            }\n        });\n\n        Animator fadeOutAnimator = ObjectAnimator.ofFloat(growingView, View.ALPHA, 1, 0);\n        Animator endAnimator = createCircularReveal(endView, minRadius, endRadius);\n        Animator growingAnimator = createCircularReveal(growingView, minRadius, endRadius);\n\n        growingAnimator.addListener(new AnimatorListenerAdapter() {\n            @Override\n            public void onAnimationEnd(Animator animation) {\n                sceneRoot.getOverlay().remove(startView);\n                sceneRoot.getOverlay().remove(shrinkingView);\n                sceneRoot.getOverlay().remove(circleView);\n                sceneRoot.getOverlay().remove(growingView);\n            }\n        });\n        AnimatorSet growingFadeSet = new AnimatorSet();\n        growingFadeSet.playTogether(fadeOutAnimator, endAnimator, growingAnimator);\n\n        AnimatorSet animatorSet = new AnimatorSet();\n        animatorSet.playSequentially(shrinkFadeSet, circleAnimator, growingFadeSet);\n        return animatorSet;\n    }\n\n    private View addViewToOverlay(ViewGroup sceneRoot, int width, int height, Drawable background) {\n        View view = new NoOverlapView(sceneRoot.getContext());\n        view.setBackground(background);\n        int widthSpec = View.MeasureSpec.makeMeasureSpec(width, View.MeasureSpec.EXACTLY);\n        int heightSpec = View.MeasureSpec.makeMeasureSpec(height, View.MeasureSpec.EXACTLY);\n        view.measure(widthSpec, heightSpec);\n        view.layout(0, 0, width, height);\n        sceneRoot.getOverlay().add(view);\n        return view;\n    }\n\n    private Animator createCircularReveal(View view, float startRadius, float endRadius) {\n        int centerX = view.getWidth() / 2;\n        int centerY = view.getHeight() / 2;\n\n        Animator reveal = ViewAnimationUtils.createCircularReveal(view, centerX, centerY,\n                startRadius, endRadius);\n        return new NoPauseAnimator(reveal);\n    }\n\n    static float calculateMaxRadius(View view) {\n        float widthSquared = view.getWidth() * view.getWidth();\n        float heightSquared = view.getHeight() * view.getHeight();\n        float radius = (float) Math.sqrt(widthSquared + heightSquared) / 2;\n        return radius;\n    }\n\n    static int calculateMinRadius(View view) {\n        return Math.min(view.getWidth() / 2, view.getHeight() / 2);\n    }\n\n    private static class NoPauseAnimator extends Animator {\n        private final Animator mAnimator;\n        private final ArrayMap<AnimatorListener, AnimatorListener> mListeners =\n                new ArrayMap<AnimatorListener, AnimatorListener>();\n\n        public NoPauseAnimator(Animator animator) {\n            mAnimator = animator;\n        }\n\n        @Override\n        public void addListener(AnimatorListener listener) {\n            AnimatorListener wrapper = new AnimatorListenerWrapper(this, listener);\n            if (!mListeners.containsKey(listener)) {\n                mListeners.put(listener, wrapper);\n                mAnimator.addListener(wrapper);\n            }\n        }\n\n        @Override\n        public void cancel() {\n            mAnimator.cancel();\n        }\n\n        @Override\n        public void end() {\n            mAnimator.end();\n        }\n\n        @Override\n        public long getDuration() {\n            return mAnimator.getDuration();\n        }\n\n        @Override\n        public TimeInterpolator getInterpolator() {\n            return mAnimator.getInterpolator();\n        }\n\n        @Override\n        public ArrayList<AnimatorListener> getListeners() {\n            return new ArrayList<AnimatorListener>(mListeners.keySet());\n        }\n\n        @Override\n        public long getStartDelay() {\n            return mAnimator.getStartDelay();\n        }\n\n        @Override\n        public boolean isPaused() {\n            return mAnimator.isPaused();\n        }\n\n        @Override\n        public boolean isRunning() {\n            return mAnimator.isRunning();\n        }\n\n        @Override\n        public boolean isStarted() {\n            return mAnimator.isStarted();\n        }\n\n        @Override\n        public void removeAllListeners() {\n            mListeners.clear();\n            mAnimator.removeAllListeners();\n        }\n\n        @Override\n        public void removeListener(AnimatorListener listener) {\n            AnimatorListener wrapper = mListeners.get(listener);\n            if (wrapper != null) {\n                mListeners.remove(listener);\n                mAnimator.removeListener(wrapper);\n            }\n        }\n\n        @Override\n        public Animator setDuration(long durationMS) {\n            mAnimator.setDuration(durationMS);\n            return this;\n        }\n\n        @Override\n        public void setInterpolator(TimeInterpolator timeInterpolator) {\n            mAnimator.setInterpolator(timeInterpolator);\n        }\n\n        @Override\n        public void setStartDelay(long delayMS) {\n            mAnimator.setStartDelay(delayMS);\n        }\n\n        @Override\n        public void setTarget(Object target) {\n            mAnimator.setTarget(target);\n        }\n\n        @Override\n        public void setupEndValues() {\n            mAnimator.setupEndValues();\n        }\n\n        @Override\n        public void setupStartValues() {\n            mAnimator.setupStartValues();\n        }\n\n        @Override\n        public void start() {\n            mAnimator.start();\n        }\n    }\n\n    private static class AnimatorListenerWrapper implements Animator.AnimatorListener {\n        private final Animator mAnimator;\n        private final Animator.AnimatorListener mListener;\n\n        public AnimatorListenerWrapper(Animator animator, Animator.AnimatorListener listener) {\n            mAnimator = animator;\n            mListener = listener;\n        }\n\n        @Override\n        public void onAnimationStart(Animator animator) {\n            mListener.onAnimationStart(mAnimator);\n        }\n\n        @Override\n        public void onAnimationEnd(Animator animator) {\n            mListener.onAnimationEnd(mAnimator);\n        }\n\n        @Override\n        public void onAnimationCancel(Animator animator) {\n            mListener.onAnimationCancel(mAnimator);\n        }\n\n        @Override\n        public void onAnimationRepeat(Animator animator) {\n            mListener.onAnimationRepeat(mAnimator);\n        }\n    }\n\n    private static class NoOverlapView extends View {\n        public NoOverlapView(Context context) {\n            super(context);\n        }\n\n        @Override\n        public boolean hasOverlappingRendering() {\n            return false;\n        }\n    }\n}'