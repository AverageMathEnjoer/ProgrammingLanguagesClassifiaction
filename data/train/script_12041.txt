b'#include "lz4enc.h"\n\n#ifdef _DEBUG\n#define LZ4_DEBUG 3//16\n#else\n#define LZ4_DEBUG 2\n#endif\n\n#define LZ4_HEAPMODE 1\n\n#pragma region Copied from lz4.h\n#ifndef LZ4_MEMORY_USAGE\n# define LZ4_MEMORY_USAGE 14\n#endif\n\ntypedef union LZ4_stream_u LZ4_stream_t; /* incomplete type (defined later) */\ntypedef struct LZ4_stream_t_internal LZ4_stream_t_internal;\n\n#define LZ4_HASHLOG   (LZ4_MEMORY_USAGE-2)\n#define LZ4_HASH_SIZE_U32 (1 << LZ4_HASHLOG) /* required as macro for static allocation */\n\nstruct LZ4_stream_t_internal {\n    uint32_t hashTable[LZ4_HASH_SIZE_U32];\n    uint32_t currentOffset;\n    uint16_t initCheck;\n    uint16_t tableType;\n    const uint8_t* dictionary;\n    const LZ4_stream_t_internal* dictCtx;\n    uint32_t dictSize;\n};\n\n/*!\n * LZ4_stream_t :\n * information structure to track an LZ4 stream.\n * init this structure before first use.\n * note : only use in association with static linking !\n *        this definition is not API/ABI safe,\n *        it may change in a future version !\n */\n#define LZ4_STREAMSIZE_U64 ((1 << (LZ4_MEMORY_USAGE-3)) + 4)\n#define LZ4_STREAMSIZE     (LZ4_STREAMSIZE_U64 * sizeof(unsigned long long))\nunion LZ4_stream_u {\n    unsigned long long table[LZ4_STREAMSIZE_U64];\n    LZ4_stream_t_internal internal_donotuse;\n};\n\n/*-************************************\n*  Advanced Functions\n**************************************/\n#define LZ4_MAX_INPUT_SIZE        0x7E000000   /* 2 113 929 216 bytes */\n#define LZ4_COMPRESSBOUND(isize) ((unsigned)(isize) > (unsigned)LZ4_MAX_INPUT_SIZE ? 0 : (isize) + ((isize)/255) + 16)\n\n#pragma endregion Copied from lz4.h\n\n#pragma region Misc\n\n#define ACCELERATION_DEFAULT 1\n\n/*-************************************\n*  Compiler Options\n**************************************/\n#ifdef _MSC_VER    /* Visual Studio */\n#  include <intrin.h>\n#  pragma warning(disable : 4127)        /* disable: C4127: conditional expression is constant */\n#  pragma warning(disable : 4293)        /* disable: C4293: too large shift (32-bits) */\n#endif  /* _MSC_VER */\n\n#ifndef LZ4_FORCE_INLINE\n#  ifdef _MSC_VER    /* Visual Studio */\n#    define LZ4_FORCE_INLINE static __forceinline\n#  else\n#    if defined (__cplusplus) || defined (__STDC_VERSION__) && __STDC_VERSION__ >= 199901L   /* C99 */\n#      ifdef __GNUC__\n#        define LZ4_FORCE_INLINE static inline __attribute__((always_inline))\n#      else\n#        define LZ4_FORCE_INLINE static inline\n#      endif\n#    else\n#      define LZ4_FORCE_INLINE static\n#    endif /* __STDC_VERSION__ */\n#  endif  /* _MSC_VER */\n#endif /* LZ4_FORCE_INLINE */\n\n#if defined(__PPC64__) && defined(__LITTLE_ENDIAN__) && defined(__GNUC__)\n#  define LZ4_FORCE_O2_GCC_PPC64LE __attribute__((optimize("O2")))\n#  define LZ4_FORCE_O2_INLINE_GCC_PPC64LE __attribute__((optimize("O2"))) LZ4_FORCE_INLINE\n#else\n#  define LZ4_FORCE_O2_GCC_PPC64LE\n#  define LZ4_FORCE_O2_INLINE_GCC_PPC64LE static\n#endif\n\n/*-************************************\n*  Basic Types\n**************************************/\n#if defined(__cplusplus) || (defined (__STDC_VERSION__) && (__STDC_VERSION__ >= 199901L) /* C99 */)\n# include <stdint.h>\n  typedef  uint8_t BYTE;\n  typedef uint16_t U16;\n  typedef uint32_t U32;\n  typedef  int32_t S32;\n  typedef uint64_t U64;\n  typedef uintptr_t uptrval;\n#else\n  typedef unsigned char       BYTE;\n  typedef unsigned short      U16;\n  typedef unsigned int        U32;\n  typedef   signed int        S32;\n  typedef unsigned long long  U64;\n  typedef size_t              uptrval;   /* generally true, except OpenVMS-64 */\n#endif\n\n/*-************************************\n*  Error detection\n**************************************/\n#if defined(LZ4_DEBUG) && (LZ4_DEBUG>=3) //>=1\n#  include <assert.h>\n#else\n#  ifndef assert\n#    define assert(condition) ((void)0)\n#  endif\n#endif\n\n#define LZ4_STATIC_ASSERT(c)   { enum { LZ4_static_assert = 1/(int)(!!(c)) }; }   /* use after variable declarations */\n\n#if defined(LZ4_DEBUG) && (LZ4_DEBUG>=2)\n#  include <stdio.h>\nstatic int g_debuglog_enable = 1;\n#  define DEBUGLOG(l, ...) {                                  \\\n                if ((g_debuglog_enable) && (l<=LZ4_DEBUG)) {  \\\n                    fprintf(stderr, __FILE__ ": ");           \\\n                    fprintf(stderr, __VA_ARGS__);             \\\n                    fprintf(stderr, " \\n");                   \\\n            }   }\n#else\n#  define DEBUGLOG(l, ...)      {}    /* disabled */\n#endif\n  \n#if (defined(__GNUC__) && (__GNUC__ >= 3)) || (defined(__INTEL_COMPILER) && (__INTEL_COMPILER >= 800)) || defined(__clang__)\n#  define expect(expr,value)    (__builtin_expect ((expr),(value)) )\n#else\n#  define expect(expr,value)    (expr)\n#endif\n\n#ifndef likely\n#define likely(expr)     expect((expr) != 0, 1)\n#endif\n#ifndef unlikely\n#define unlikely(expr)   expect((expr) != 0, 0)\n#endif\n\n/*-************************************\n*  Memory routines\n**************************************/\n#include <stdlib.h>   /* malloc, calloc, free */\n#define ALLOC(s)          malloc(s)\n#define ALLOC_AND_ZERO(s) calloc(1,s)\n#define FREEMEM(p)        free(p)\n#include <string.h>   /* memset, memcpy */\n#define MEM_INIT(p,v,s) memset((p),(v),(s))\n\n/*-************************************\n*  Common Constants\n**************************************/\n#define MINMATCH 4\n#define WILDCOPYLENGTH 8\n#define LASTLITERALS 5\n#define MFLIMIT (WILDCOPYLENGTH+MINMATCH)\nstatic const int LZ4_minLength = (MFLIMIT+1);\n#define KB *(1 <<10)\n#define MB *(1 <<20)\n#define GB *(1U<<30)\n#define MAXD_LOG 16\n#define MAX_DISTANCE ((1 << MAXD_LOG) - 1)\n#define ML_BITS  4\n#define ML_MASK  ((1U<<ML_BITS)-1)\n#define RUN_BITS (8-ML_BITS)\n#define RUN_MASK ((1U<<RUN_BITS)-1)\nstatic const int LZ4_64Klimit = ((64 KB) + (MFLIMIT-1));\nstatic const U32 LZ4_skipTrigger = 6; /* Increase this value ==> compression run slower on incompressible data */\n\ntypedef enum { noDict = 0, withPrefix64k, usingExtDict, usingDictCtx } dict_directive;\ntypedef enum { noDictIssue = 0, dictSmall } dictIssue_directive;\n\ntypedef enum { notLimited = 0, limitedOutput = 1, fillOutput = 2 } limitedOutput_directive;\ntypedef enum { clearedTable = 0, byPtr, byU32, byU16 } tableType_t;\n\n#if defined(__x86_64__)\n  typedef U64    reg_t;   /* 64-bits in x32 mode */\n#else\n  typedef size_t reg_t;   /* 32-bits in x32 mode */\n#endif\n\nstatic unsigned LZ4_isLittleEndian(void)\n{\n    const union { U32 u; BYTE c[4]; } one = { 1 };   /* don\'t use static : performance detrimental */\n    return one.c[0];\n}\n#pragma endregion Misc\n\nvoid LZ4_resetStream (LZ4_stream_t* LZ4_stream)\n{\n    DEBUGLOG(5, "LZ4_resetStream (ctx:%p)", LZ4_stream);\n    MEM_INIT(LZ4_stream, 0, sizeof(LZ4_stream_t));\n}\n\nstatic unsigned LZ4_NbCommonBytes (reg_t val)\n{\n    if (LZ4_isLittleEndian()) {\n        if (sizeof(val)==8) {\n#       if defined(_MSC_VER) && defined(_WIN64) && !defined(LZ4_FORCE_SW_BITCOUNT)\n            unsigned long r = 0;\n            _BitScanForward64( &r, (U64)val );\n            return (int)(r>>3);\n#       elif (defined(__clang__) || (defined(__GNUC__) && (__GNUC__>=3))) && !defined(LZ4_FORCE_SW_BITCOUNT)\n            return (__builtin_ctzll((U64)val) >> 3);\n#       else\n            static const int DeBruijnBytePos[64] = { 0, 0, 0, 0, 0, 1, 1, 2,\n                                                     0, 3, 1, 3, 1, 4, 2, 7,\n                                                     0, 2, 3, 6, 1, 5, 3, 5,\n                                                     1, 3, 4, 4, 2, 5, 6, 7,\n                                                     7, 0, 1, 2, 3, 3, 4, 6,\n                                                     2, 6, 5, 5, 3, 4, 5, 6,\n                                                     7, 1, 2, 4, 6, 4, 4, 5,\n                                                     7, 2, 6, 5, 7, 6, 7, 7 };\n            return DeBruijnBytePos[((U64)((val & -(long long)val) * 0x0218A392CDABBD3FULL)) >> 58];\n#       endif\n        } else /* 32 bits */ {\n#       if defined(_MSC_VER) && !defined(LZ4_FORCE_SW_BITCOUNT)\n            unsigned long r;\n            _BitScanForward( &r, (U32)val );\n            return (int)(r>>3);\n#       elif (defined(__clang__) || (defined(__GNUC__) && (__GNUC__>=3))) && !defined(LZ4_FORCE_SW_BITCOUNT)\n            return (__builtin_ctz((U32)val) >> 3);\n#       else\n            static const int DeBruijnBytePos[32] = { 0, 0, 3, 0, 3, 1, 3, 0,\n                                                     3, 2, 2, 1, 3, 2, 0, 1,\n                                                     3, 3, 1, 2, 2, 2, 2, 0,\n                                                     3, 1, 2, 0, 1, 0, 1, 1 };\n            return DeBruijnBytePos[((U32)((val & -(S32)val) * 0x077CB531U)) >> 27];\n#       endif\n        }\n    } else   /* Big Endian CPU */ {\n        if (sizeof(val)==8) {   /* 64-bits */\n#       if defined(_MSC_VER) && defined(_WIN64) && !defined(LZ4_FORCE_SW_BITCOUNT)\n            unsigned long r = 0;\n            _BitScanReverse64( &r, val );\n            return (unsigned)(r>>3);\n#       elif (defined(__clang__) || (defined(__GNUC__) && (__GNUC__>=3))) && !defined(LZ4_FORCE_SW_BITCOUNT)\n            return (__builtin_clzll((U64)val) >> 3);\n#       else\n            static const U32 by32 = sizeof(val)*4;  /* 32 on 64 bits (goal), 16 on 32 bits.\n                Just to avoid some static analyzer complaining about shift by 32 on 32-bits target.\n                Note that this code path is never triggered in 32-bits mode. */\n            unsigned r;\n            if (!(val>>by32)) { r=4; } else { r=0; val>>=by32; }\n            if (!(val>>16)) { r+=2; val>>=8; } else { val>>=24; }\n            r += (!val);\n            return r;\n#       endif\n        } else /* 32 bits */ {\n#       if defined(_MSC_VER) && !defined(LZ4_FORCE_SW_BITCOUNT)\n            unsigned long r = 0;\n            _BitScanReverse( &r, (unsigned long)val );\n            return (unsigned)(r>>3);\n#       elif (defined(__clang__) || (defined(__GNUC__) && (__GNUC__>=3))) && !defined(LZ4_FORCE_SW_BITCOUNT)\n            return (__builtin_clz((U32)val) >> 3);\n#       else\n            unsigned r;\n            if (!(val>>16)) { r=2; val>>=8; } else { r=0; val>>=24; }\n            r += (!val);\n            return r;\n#       endif\n        }\n    }\n}\n\nstatic U16 LZ4_read16(const void* memPtr) { return *(const U16*) memPtr; }\nstatic U32 LZ4_read32(const void* memPtr) { return *(const U32*) memPtr; }\nstatic reg_t LZ4_read_ARCH(const void* memPtr) { return *(const reg_t*) memPtr; }\nstatic U32 LZ4_hash4(U32 sequence, tableType_t const tableType)\n{\n    if (tableType == byU16)\n        return ((sequence * 2654435761U) >> ((MINMATCH*8)-(LZ4_HASHLOG+1)));\n    else\n        return ((sequence * 2654435761U) >> ((MINMATCH*8)-LZ4_HASHLOG));\n}\n\nstatic U32 LZ4_hash5(U64 sequence, tableType_t const tableType)\n{\n    static const U64 prime5bytes = 889523592379ULL;\n    static const U64 prime8bytes = 11400714785074694791ULL;\n    const U32 hashLog = (tableType == byU16) ? LZ4_HASHLOG+1 : LZ4_HASHLOG;\n    if (LZ4_isLittleEndian())\n        return (U32)(((sequence << 24) * prime5bytes) >> (64 - hashLog));\n    else\n        return (U32)(((sequence >> 24) * prime8bytes) >> (64 - hashLog));\n}\nLZ4_FORCE_INLINE U32 LZ4_hashPosition(const void* const p, tableType_t const tableType)\n{\n    if ((sizeof(reg_t)==8) && (tableType != byU16)) return LZ4_hash5(LZ4_read_ARCH(p), tableType);\n    return LZ4_hash4(LZ4_read32(p), tableType);\n}\nstatic void LZ4_putPositionOnHash(U32 offset, U32 h,\n                                  void* tableBase, tableType_t const tableType)\n{\n    switch (tableType)\n    {\n    default: /* fallthrough */\n    case clearedTable: /* fallthrough */\n    case byPtr: { /* illegal! */ assert(0); return; }\n    case byU32: { U32* hashTable = (U32*) tableBase; hashTable[h] = (U32)(offset); return; }\n    case byU16: { U16* hashTable = (U16*) tableBase; assert(offset < 65536); hashTable[h] = (U16)(offset); return; }\n    }\n}\n\nstatic void LZ4_putIndexOnHash(U32 idx, U32 h, void* tableBase, tableType_t const tableType)\n{\n    switch (tableType)\n    {\n    default: /* fallthrough */\n    case clearedTable: /* fallthrough */\n    case byPtr: { /* illegal! */ assert(0); return; }\n    case byU32: { U32* hashTable = (U32*) tableBase; hashTable[h] = idx; return; }\n    case byU16: { U16* hashTable = (U16*) tableBase; assert(idx < 65536); hashTable[h] = (U16)idx; return; }\n    }\n}\n\nLZ4_FORCE_INLINE void LZ4_putPosition(const void* const p, U32 offset, void* tableBase, tableType_t tableType)\n{\n    U32 const h = LZ4_hashPosition(p, tableType);\n    LZ4_putPositionOnHash(offset, h, tableBase, tableType);\n}\n\nstatic U32 LZ4_getIndexOnHash(U32 h, const void* tableBase, tableType_t tableType)\n{\n    LZ4_STATIC_ASSERT(LZ4_MEMORY_USAGE > 2);\n    if (tableType == byU32) {\n        const U32* const hashTable = (const U32*) tableBase;\n        assert(h < (1U << (LZ4_MEMORY_USAGE-2)));\n        return hashTable[h];\n    }\n    if (tableType == byU16) {\n        const U16* const hashTable = (const U16*) tableBase;\n        assert(h < (1U << (LZ4_MEMORY_USAGE-1)));\n        return hashTable[h];\n    }\n    assert(0); return 0;  /* forbidden case */\n}\n\n//Returns the bytes read.\nstatic int LZ4e_inputBuffer(BYTE* istart, BYTE*& ip, BYTE* imax, LZ4e_instream_t* inStream)\n{\n\t//Keep enough bytes for the dictionary.\n\tuint64_t absIPOffset = ip-istart + inStream->pos;\n\tint baseOffset = (imax - istart) / 2; \n\tif (baseOffset > LZ4_64Klimit) baseOffset = LZ4_64Klimit;\n\tif (baseOffset > absIPOffset) baseOffset = absIPOffset;\n\n\tinStream->pos = absIPOffset - baseOffset;\n\tint len = inStream->callback(istart, imax-istart, inStream);\n\n\tassert(len >= baseOffset);\n\tif (unlikely(len < baseOffset))\n\t\tip = istart + len; //safety\n\telse\n\t\tip = istart + baseOffset;\n\n\treturn len;\n}\n//Returns the bytes written.\nstatic int LZ4e_outputBuffer(BYTE* ostart, BYTE*& op, BYTE* omax, LZ4e_outstream_t* outStream)\n{\n\tint len = outStream->callback(ostart, op-ostart, outStream);\n\tassert(len == op-ostart);\n\top = ostart;\n\treturn len;\n}\nstatic U32 LZ4e_Read32Stream(unsigned int pos, LZ4e_instream_t* inStream, int *error)\n{\n\tuint64_t oldPos = inStream->pos;\n\tinStream->pos = pos;\n\tU32 result = 0;\n\tint size = inStream->callback(&result, 4, inStream);\n\tinStream->pos = oldPos;\n\t*error = size != 4;\n\treturn result;\n}\nstatic uint8_t LZ4e_Read8Stream(unsigned int pos, LZ4e_instream_t* inStream, int *error)\n{\n\tuint64_t oldPos = inStream->pos;\n\tinStream->pos = pos;\n\tU32 result = 0;\n\tint size = inStream->callback(&result, 1, inStream);\n\tinStream->pos = oldPos;\n\t*error = size != 1;\n\treturn result;\n}\nstatic int LZ4e_ReadStreamTemp(unsigned int pos, void *buf, unsigned int len, LZ4e_instream_t* inStream)\n{\n\tuint64_t oldPos = inStream->pos;\n\tinStream->pos = pos;\n\tint size = inStream->callback(buf, len, inStream);\n\tinStream->pos = oldPos;\n\treturn size;\n}\n\n/* customized variant of memcpy, which can overwrite up to 8 bytes beyond dstEnd */\nLZ4_FORCE_O2_INLINE_GCC_PPC64LE\nvoid LZ4_wildCopy(void* dstPtr, const void* srcPtr, void* dstEnd)\n{\n    BYTE* d = (BYTE*)dstPtr;\n    const BYTE* s = (const BYTE*)srcPtr;\n    BYTE* const e = (BYTE*)dstEnd;\n\n    do { memcpy(d,s,8); d+=8; s+=8; } while (d<e);\n}\nstatic void LZ4_write16(void* memPtr, U16 value) { *(U16*)memPtr = value; }\nstatic void LZ4_writeLE16(void* memPtr, U16 value)\n{\n    if (LZ4_isLittleEndian()) {\n        LZ4_write16(memPtr, value);\n    } else {\n        BYTE* p = (BYTE*)memPtr;\n        p[0] = (BYTE) value;\n        p[1] = (BYTE)(value>>8);\n    }\n}\nstatic void LZ4_write32(void* memPtr, U32 value)\n{\n    memcpy(memPtr, &value, sizeof(value));\n}\n#define STEPSIZE sizeof(reg_t)\n//bufBase : pointer to buffer with length 2*bufLen\nLZ4_FORCE_INLINE\nunsigned LZ4e_count(U32 inOffs, U32 matchOffs, \n\tBYTE* const bufBase, const U32 bufLen, \n\tconst BYTE* const inBufBase, const U32 inBufLen, const U32 inBufOffs,\n\tLZ4e_instream_t *pInStream)\n{\n\tBYTE* const inBuf = bufBase;\n\tBYTE* const matchBuf = bufBase + bufLen;\n\tunsigned totalCount = 0;\n\tint inDataLen = 0;\n\tint matchDataLen = 0;\n\tconst BYTE* pInLimit = NULL;\n\tconst BYTE* pIn = NULL;\n\tconst BYTE* pMatch = NULL;\n\tif (inOffs >= inBufOffs && inOffs + LASTLITERALS < inBufOffs + inBufLen)\n\t{\n\t\tpIn = inBufBase + (inOffs - inBufOffs);\n\t\tinDataLen = inBufLen - LASTLITERALS - (inOffs - inBufOffs);\n\t\tpInLimit = inBufBase + inBufLen - LASTLITERALS;\n\t}\n\telse\n\t{\n\t\tinDataLen = LZ4e_ReadStreamTemp(inOffs, inBuf, bufLen, pInStream);\n\t\tpIn = inBuf;\n\t}\n\tif (matchOffs >= inBufOffs && matchOffs < inBufOffs + inBufLen)\n\t{\n\t\tpMatch = inBufBase + (matchOffs - inBufOffs);\n\t\tmatchDataLen = inBufLen - (matchOffs - inBufOffs);\n\t}\n\telse\n\t{\n\t\tmatchDataLen = LZ4e_ReadStreamTemp(matchOffs, matchBuf, bufLen, pInStream);\n\t\tpMatch = matchBuf;\n\t}\n\twhile (true)\n\t{\n\t\tconst BYTE* const pInBase = pIn;\n\n\t\tif (unlikely(inDataLen <= LASTLITERALS || matchDataLen <= 0))\n\t\t\tbreak;\n\t\tif (unlikely(inDataLen - LASTLITERALS > matchDataLen))\n\t\t\tinDataLen = matchDataLen + LASTLITERALS;\n\n\t\tif (likely(pIn < pInLimit-(STEPSIZE-1))) {\n\t\t\treg_t const diff = LZ4_read_ARCH(pMatch) ^ LZ4_read_ARCH(pIn);\n\t\t\tif (!diff) {\n\t\t\t\tpIn+=STEPSIZE; pMatch+=STEPSIZE;\n\t\t\t} else {\n\t\t\t\treturn totalCount + LZ4_NbCommonBytes(diff);\n\t\t}   }\n\n\t\twhile (likely(pIn < pInLimit-(STEPSIZE-1))) {\n\t\t\treg_t const diff = LZ4_read_ARCH(pMatch) ^ LZ4_read_ARCH(pIn);\n\t\t\tif (!diff) { pIn+=STEPSIZE; pMatch+=STEPSIZE; continue; }\n\t\t\treturn totalCount + (pIn-pInBase) + LZ4_NbCommonBytes(diff);\n\t\t}\n\n\t\tif ((STEPSIZE==8) && (pIn<(pInLimit-3)) && (LZ4_read32(pMatch) == LZ4_read32(pIn))) {pIn+=4; pMatch+=4;}\n\t\tif ((pIn<(pInLimit-1)) && (LZ4_read16(pMatch) == LZ4_read16(pIn))) {pIn+=2; pMatch+=2;}\n\t\tif ((pIn<pInLimit) && (*pMatch == *pIn)) pIn++;\n\n\t\tif ((pIn-pInBase) == 0)\n\t\t\tbreak;\n\n\t\ttotalCount += pIn-pInBase;\n\t\tinOffs += pIn-pInBase;\n\t\tmatchOffs += pIn-pInBase;\n\n\t\tinDataLen = LZ4e_ReadStreamTemp(inOffs, inBuf, bufLen, pInStream);\n\t\tmatchDataLen = LZ4e_ReadStreamTemp(matchOffs, matchBuf, bufLen, pInStream);\n\t\t//if (unlikely(inDataLen < bufLen || matchDataLen < bufLen))\n\t\t//\tbreak;\n\n\t\tpInLimit = inBuf + inDataLen - LASTLITERALS;\n\t\tpIn = inBuf;\n\t\tpMatch = matchBuf;\n\t}\n    return totalCount;\n}\n\nLZ4_FORCE_O2_GCC_PPC64LE\nLZ4_FORCE_INLINE unsigned int LZ4_compress_generic(\n                 LZ4_stream_t_internal* const cctx,\n                 LZ4e_instream_t* const ssource,\n                 LZ4e_outstream_t* const sdest,\n\t\t\t\t void* const streamBuf,\n\t\t\t\t unsigned int streamBufSize,\n                 const tableType_t tableType,\n                 const U32 acceleration)\n{\n\tunsigned int totalInputSize = 0;\n\tunsigned int totalOutputSize = 0;\n    BYTE* ipb = (BYTE*)streamBuf;\n\n    BYTE* const baseb = (BYTE*)streamBuf;\n    const BYTE* lowLimitb;\n\n    const LZ4_stream_t_internal* dictCtx = (const LZ4_stream_t_internal*) cctx->dictCtx;\n    const BYTE* const dictionary = cctx->dictionary;\n    const U32 dictSize = cctx->dictSize;\n    const U32 dictDelta = 0;   /* make indexes in dictCtx comparable with index in current context */\n\n    const BYTE* const dictEnd = dictionary + dictSize;\n\tunsigned int anchor = 0;\n    BYTE* const iendb = ipb + streamBufSize;\n\n    /* the dictCtx currentOffset is indexed on the start of the dictionary,\n     * while a dictionary in the current context precedes the currentOffset */\n    const BYTE* dictBase = dictionary + dictSize;\n\n\tBYTE* const opbaseb = (BYTE*)streamBuf + streamBufSize * 2;\n    BYTE* opb = (BYTE*)streamBuf + streamBufSize * 2;\n    BYTE* const olimitb = (BYTE*)streamBuf + streamBufSize * 3;\n\n\tBYTE* const tempbase = (BYTE*)streamBuf + streamBufSize;\n\tBYTE* const templimit = (BYTE*)streamBuf + streamBufSize * 2;\n\tU32 outputOffset = 0;\n\n    U32 offset = 0;\n    U32 forwardH;\n\n    DEBUGLOG(5, "LZ4_compress_generic: streamBufSize=%u, tableType=%u", streamBufSize, tableType);\n\tif (streamBufSize < LZ4_64Klimit) return 0;\n    /* Init conditions */\n    //if (outputLimited == fillOutput && maxOutputSize < 1) return 0; /* Impossible to store anything */\n    //if ((U32)inputSize > (U32)LZ4_MAX_INPUT_SIZE) return 0;   /* Unsupported inputSize, too large (or negative) */\n    //if ((tableType == byU16) && (inputSize>=LZ4_64Klimit)) return 0;  /* Size too large (not within 64K limit) */\n    if (tableType==byPtr) return 0;//assert(dictDirective==noDict);      /* only supported use case with byPtr */\n    assert(acceleration >= 1);\n\n    lowLimitb = (const BYTE*)streamBuf;\n\n\tint curSize = LZ4e_inputBuffer(baseb, ipb, iendb, ssource);\n\tunsigned int curOffset = 0;\n    if (curSize<LZ4_minLength) goto _last_literals;        /* Input too small, no compression (all literals) */\n\n\n    /* First Byte */\n    LZ4_putPosition(ipb, curOffset, cctx->hashTable, tableType);\n    ipb++; curOffset++; forwardH = LZ4_hashPosition(ipb, tableType);\n\n    /* Main Loop */\n    for ( ; ; ) {\n        BYTE* token;\n\t\tU32 matchIndex;\n\n        /* Find a match */\n        {   /* byU32, byU16 */\n\n            BYTE* forwardIp = ipb;\n            unsigned step = 1;\n            unsigned searchMatchNb = acceleration << LZ4_skipTrigger;\n            do {\n                U32 const h = forwardH;\n                U32 const current = curOffset + (forwardIp - ipb);//(U32)(forwardIp - base);\n                matchIndex = LZ4_getIndexOnHash(h, cctx->hashTable, tableType);\n                assert(matchIndex <= current);\n\t\t\t\tassert(current < (ptrdiff_t)(2 GB - 1));\n                //assert(forwardIp - base < (ptrdiff_t)(2 GB - 1));\n\t\t\t\tcurOffset += (forwardIp - ipb);\n\t\t\t\tassert(forwardIp >= ipb);\n                ipb = forwardIp;\n                forwardIp += step;\n                step = (searchMatchNb++ >> LZ4_skipTrigger);\n\n\t\t\t\tif (unlikely(forwardIp-baseb >= (curSize - MFLIMIT + 1)))\n\t\t\t\t{\n\t\t\t\t\tif (likely(curSize == streamBufSize))\n\t\t\t\t\t{\n\t\t\t\t\t\tcurSize = LZ4e_inputBuffer(baseb, ipb, iendb, ssource);\n\t\t\t\t\t\tforwardIp = ipb + step;\n\t\t\t\t\t\tif (unlikely(forwardIp-baseb + MFLIMIT >= (curSize + 1)))\n\t\t\t\t\t\t\tgoto _last_literals; //still not enough read\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t\tgoto _last_literals; //nothing left to read\n\t\t\t\t}\n                //if (unlikely(forwardIp > mflimitPlusOne)) goto _last_literals;\n                //assert(ip < mflimitPlusOne);\n\t\t\t\tassert(ipb-baseb < (curSize - MFLIMIT + 1));\n\n                forwardH = LZ4_hashPosition(forwardIp, tableType);\n                LZ4_putIndexOnHash(current, h, cctx->hashTable, tableType);\n\n                assert(matchIndex < current);\n                if ((tableType != byU16) && (matchIndex+MAX_DISTANCE < current)) continue;  /* too far */\n                if (tableType == byU16) assert((current - matchIndex) <= MAX_DISTANCE);     /* too_far presumed impossible with byU16 */\n\t\t\t\t\n\t\t\t\tint error;\n\t\t\t\tif (likely((curOffset - matchIndex) <= (ipb-baseb)))\n\t\t\t\t{\n\t\t\t\t\tif (LZ4_read32(ipb - (curOffset - matchIndex)) == LZ4_read32(ipb)) {\n\t\t\t\t\t\toffset = current - matchIndex;\n\t\t\t\t\t\tbreak; //match index is inside the read buffer\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (LZ4e_Read32Stream(matchIndex, ssource, &error) == LZ4_read32(ipb) && likely(!error)) {\n\t\t\t\t\toffset = current - matchIndex;\n                    //if (maybe_extMem) offset = current - matchIndex;\n                    break;   /* match found */\n                }\n\t\t\t\telse if (unlikely(error))\n\t\t\t\t{\n\t\t\t\t\tDEBUGLOG(1, "break 15");\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n            } while(1);\n        }\n\n        /* Catch up */\n\t\t{\n\t\t\tunsigned int startOffset = curOffset - (ipb - baseb);\n\t\t\tunsigned int tempStartOffset = 0, tempLen = 0;\n\t\t\twhile ((curOffset>anchor) & (matchIndex > 0))\n\t\t\t{\n\t\t\t\tBYTE match, ip;\n\t\t\t\tif (matchIndex <= startOffset)\n\t\t\t\t{\n\t\t\t\t\tif (unlikely(tempLen == 0 || matchIndex <= tempStartOffset))\n\t\t\t\t\t{\n\t\t\t\t\t\ttempStartOffset = (matchIndex < streamBufSize) ? 0 : (matchIndex - streamBufSize);\n\t\t\t\t\t\ttempLen = LZ4e_ReadStreamTemp(tempStartOffset, tempbase, streamBufSize, ssource);\n\t\t\t\t\t\tif (unlikely((tempStartOffset + tempLen) < matchIndex))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tDEBUGLOG(1, "break 14");\n\t\t\t\t\t\t\treturn 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tmatch = tempbase[matchIndex - tempStartOffset - 1];\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tmatch = baseb[matchIndex - startOffset - 1];\n\t\t\t\tif (unlikely(ipb == baseb))\n\t\t\t\t{\n\t\t\t\t\tint error;\n\t\t\t\t\tip = LZ4e_Read8Stream(startOffset - 1, ssource, &error);\n\t\t\t\t\tif (unlikely(error))\n\t\t\t\t\t{\n\t\t\t\t\t\tDEBUGLOG(1, "break 13");\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t\tif (unlikely(match == ip))\n\t\t\t\t\t{\n\t\t\t\t\t\tunsigned int offset = (curOffset < 16) ? curOffset : 16;\n\t\t\t\t\t\tunsigned int movesize = streamBufSize - offset;\n\t\t\t\t\t\tif (movesize > curSize)\n\t\t\t\t\t\t\tmovesize = curSize;\n\t\t\t\t\t\tmemmove(&baseb[offset], baseb, movesize);\n\n\t\t\t\t\t\tssource->pos = startOffset - offset;\n\t\t\t\t\t\tif (unlikely(ssource->callback(baseb, offset, ssource) != offset))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tDEBUGLOG(1, "break 12");\n\t\t\t\t\t\t\treturn 0;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tipb += offset;\n\t\t\t\t\t\tcurSize = movesize + offset;\n\t\t\t\t\t\tstartOffset -= offset;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tip = ipb[-1];\n\t\t\t\tif (unlikely(match == ip))\n\t\t\t\t{\n\t\t\t\t\tipb--; curOffset--;\n\t\t\t\t\tmatchIndex--;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n        \n\t\t/*if (likely((curOffset - matchIndex) <= (ipb-baseb)))\n\t\t{\n\t\t\tDEBUGLOG(6, "match for %x (0x%x) found at %x (0x%x), anchor %x", curOffset, LZ4_read32(ipb), matchIndex, LZ4_read32(ipb - (curOffset - matchIndex)), anchor);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tint error;\n\t\t\tDEBUGLOG(6, "match for %x (0x%x) found at %x (0x%x), anchor %x", curOffset, LZ4_read32(ipb), matchIndex, LZ4e_Read32Stream(matchIndex, ssource, &error), anchor);\n\t\t}*/\n        //while (((curOffset>anchor) & (matchIndex > 0)) && (unlikely(ip[-1]==match[-1]))) { ip--; match--; }\n\t\tunsigned litLength = (unsigned)(curOffset - anchor);//(ip - anchor);\n        /* Encode Literals */\n        {   \n\t\t\tif (unlikely((2 + 1 + LASTLITERALS) + (litLength/255) + 2 > streamBufSize - (opb - opbaseb)))\n\t\t\t{\n\t\t\t\tif (unlikely((2 + 1 + LASTLITERALS) + (litLength/255) > streamBufSize))\n\t\t\t\t{\n\t\t\t\t\tDEBUGLOG(1, "break 11");\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tunsigned const expectedLen = opb-opbaseb;\n\t\t\t\tif (expectedLen != LZ4e_outputBuffer(opbaseb, opb, olimitb, sdest))\n\t\t\t\t{\n\t\t\t\t\tDEBUGLOG(1, "break 10");\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\ttotalOutputSize += expectedLen;\n\t\t\t}\n            token = opb++;\n            if (litLength >= RUN_MASK) {\n                int len = (int)litLength-RUN_MASK;\n                *token = (RUN_MASK<<ML_BITS);\n                for(; len >= 255 ; len-=255) *opb++ = 255;\n                *opb++ = (BYTE)len;\n            }\n            else *token = (BYTE)(litLength<<ML_BITS);\n\t\t\t//Copy the literals after the match length has been determined, \n\t\t\t//since the token at the beginning of the block has to be updated for the match length.written before the literals has to be still accessible at that point.\n            DEBUGLOG(6, "seq.start:%x, literals=%x, match.start:%x",\n                        (int)(anchor), litLength, (int)(curOffset));\n        }\n\n_next_match:\n        /* at this stage, the following variables must be correctly set :\n         * - ip : at start of LZ operation\n         * - match : at start of previous pattern occurence; can be within current prefix, or within extDict\n         * - offset : if maybe_ext_memSegment==1 (constant)\n         * - lowLimit : must be == dictionary to mean "match is within extDict"; must be == source otherwise\n         * - token and *token : position to write 4-bits for match length; higher 4-bits for literal length supposed already written\n         */\n\n\n        /* Encode MatchLength */\n\t\tunsigned matchCode;\n        {  \n\t\t\tmatchCode = LZ4e_count(curOffset+MINMATCH, matchIndex+MINMATCH, tempbase, streamBufSize/2, baseb, curSize, curOffset - (ipb-baseb), ssource);\n\t\t\t//The token needs to be updated before flushing the output buffer (which contains the token field).\n\t\t\tif (matchCode >= ML_MASK)\n\t\t\t\t*token += ML_MASK;\n\t\t\telse\n\t\t\t\t*token += (BYTE)(matchCode);\n\t\t}\n\t\t/* Write Literals (if any) */\n\t\t{\n\t\t\tU32 readOffs = 0;\n\t\t\twhile (litLength > 0)\n\t\t\t{\n\t\t\t\tBYTE* pAnchor; U32 readLength;\n\t\t\t\tif (unlikely(anchor+readOffs < (curOffset - (ipb-baseb)) || anchor+readOffs+litLength+8 > curOffset+(baseb+curSize-ipb)))\n\t\t\t\t{\n\t\t\t\t\tif (litLength < streamBufSize) readLength = litLength;\n\t\t\t\t\telse readLength = streamBufSize;\n\t\t\t\t\tif ((readLength = LZ4e_ReadStreamTemp(anchor+readOffs, tempbase, readLength, ssource)) <= 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tDEBUGLOG(1, "break 9");\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t\tif (readLength > litLength) readLength = litLength;\n\t\t\t\t\tpAnchor = tempbase;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tpAnchor = &baseb[anchor+readOffs - (curOffset - (ipb-baseb))];\n\t\t\t\t\treadLength = (baseb + curSize) - pAnchor;\n\t\t\t\t\tif (readLength > litLength) readLength = litLength;\n\t\t\t\t}\n\t\t\t\tif (readLength+8 > streamBufSize - (opb-opbaseb))\n\t\t\t\t{\n\t\t\t\t\tunsigned const expectedLen = opb-opbaseb;\n\t\t\t\t\tif (expectedLen != LZ4e_outputBuffer(opbaseb, opb, olimitb, sdest))\n\t\t\t\t\t{\n\t\t\t\t\t\tDEBUGLOG(1, "break 8");\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t\ttotalOutputSize += expectedLen;\n\t\t\t\t}\n\t\t\t\tU32 outputCount = readLength;\n\t\t\t\tif (readLength > streamBufSize - (opb-opbaseb) - 8)\n\t\t\t\t\toutputCount = streamBufSize - (opb-opbaseb) - 8;\n\t\t\t\t/* Copy Literals */\n\t\t\t\tLZ4_wildCopy(opb, pAnchor, opb+outputCount);\n\t\t\t\topb+=outputCount;\n\t\t\t\tlitLength-=outputCount;\n\t\t\t\treadOffs+=outputCount;\n\t\t\t}\n\t\t}\n        LZ4_writeLE16(opb, (U16)offset); opb+=2;\n\t\t{\n            //matchCode = LZ4_count(ip+MINMATCH, match+MINMATCH, matchlimit);\n            ipb += MINMATCH + matchCode;\n\t\t\tcurOffset += MINMATCH + matchCode;\n            DEBUGLOG(6, "             with matchLength=%x and match.source=%x", matchCode+MINMATCH, matchIndex);\n\t\t\tif (unlikely((1 + LASTLITERALS) + (matchCode>>8) > streamBufSize-(opb-opbaseb)))\n\t\t\t{\n\t\t\t\tif (unlikely((1 + LASTLITERALS) + (matchCode>>8) > streamBufSize))\n\t\t\t\t{\n\t\t\t\t\tDEBUGLOG(1, "break 7");\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tunsigned const expectedLen = opb-opbaseb;\n\t\t\t\tif (expectedLen != LZ4e_outputBuffer(opbaseb, opb, olimitb, sdest))\n\t\t\t\t{\n\t\t\t\t\tDEBUGLOG(1, "break 6");\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\ttotalOutputSize += expectedLen;\n\t\t\t}\n            if (matchCode >= ML_MASK) {\n                //*token += ML_MASK;\n                matchCode -= ML_MASK;\n                LZ4_write32(opb, 0xFFFFFFFF);\n                while (matchCode >= 4*255) {\n                    opb+=4;\n                    LZ4_write32(opb, 0xFFFFFFFF);\n                    matchCode -= 4*255;\n                }\n                opb += matchCode / 255;\n                *opb++ = (BYTE)(matchCode % 255);\n            } //else\n            //    *token += (BYTE)(matchCode);\n        }\n\n        //anchor = ip;\n\t\tanchor = curOffset;\n\n        /* Test end of chunk */\n\t\tif (ipb >= baseb + curSize - MFLIMIT + 1)\n\t\t{\n\t\t\tif (curSize < streamBufSize) break;\n\t\t\tcurSize = LZ4e_inputBuffer(baseb, ipb, iendb, ssource);\n\t\t\tif (ipb >= baseb + curSize - MFLIMIT + 1) break;\n\t\t}\n        //if (ip >= mflimitPlusOne) break;\n\n        /* Fill table */\n\t\t//Since LZ4e_inputBuffer keeps previous data (up to 64K), there should always be 2 bytes behind ipb at this place.\n\t\tLZ4_putPosition(ipb-2, curOffset-2, cctx->hashTable, tableType); \n        //LZ4_putPosition(ip-2, cctx->hashTable, tableType, base);\n\n        /* Test next position */\n\t\t{   /* byU32, byU16 */\n\t\t\tU32 const h = LZ4_hashPosition(ipb, tableType);\n            U32 const current = curOffset;//(U32)(ip-base);\n            matchIndex = LZ4_getIndexOnHash(h, cctx->hashTable, tableType);\n            assert(matchIndex < current);\n\n            LZ4_putIndexOnHash(current, h, cctx->hashTable, tableType);\n            assert(matchIndex < current);\n            if ( ((tableType==byU16) ? 1 : (matchIndex+MAX_DISTANCE >= current)) )\n\t\t\t{\n\t\t\t\tint error = 0;\n\t\t\t\tif (likely((curOffset - matchIndex) <= (ipb-baseb)) \n\t\t\t\t\t\t? (LZ4_read32(ipb - (curOffset - matchIndex)) == LZ4_read32(ipb))\n\t\t\t\t\t\t: (LZ4e_Read32Stream(matchIndex, ssource, &error) == LZ4_read32(ipb))) {\n\t\t\t\t\tif (unlikely(error))\n\t\t\t\t\t{\n\t\t\t\t\t\tDEBUGLOG(1, "break 5");\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t\ttoken=opb++;\n\t\t\t\t\t*token=0;\n\t\t\t\t\t//if (maybe_extMem) offset = current - matchIndex;\n\t\t\t\t\toffset = current - matchIndex;\n\t\t\t\t\tDEBUGLOG(6, "seq.start:%x, literals=%u, match.start:%x",\n\t\t\t\t\t\t\t\t(int)(anchor), 0, (int)(curOffset));\n\t\t\t\t\tgoto _next_match;\n\t\t\t\t}\n            }\n        }\n\n        /* Prepare next loop */\n        forwardH = LZ4_hashPosition(++ipb, tableType);\n\t\t++curOffset;\n    }\n\n_last_literals:\n    /* Encode Last Literals */\n\t{ \n\t\tsize_t lastRun = curOffset + (baseb+curSize-ipb) - anchor;\n\t\tint curSizeTemp = curSize; unsigned int curTempOffset = curOffset + (baseb+curSize-ipb);\n\t\twhile (curSizeTemp == streamBufSize)\n\t\t{\n\t\t\tcurSizeTemp = LZ4e_ReadStreamTemp(curTempOffset, tempbase, streamBufSize, ssource);\n\t\t\t//if (curSizeTemp >= 0)\n\t\t\t{\n\t\t\t\tlastRun += (size_t)curSizeTemp;\n\t\t\t\tcurTempOffset += (unsigned int)curSizeTemp;\n\t\t\t}\n\t\t}\n\t\tunsigned const expectedLen = opb-opbaseb;\n\t\tif (expectedLen != LZ4e_outputBuffer(opbaseb, opb, olimitb, sdest))\n\t\t{\n\t\t\tDEBUGLOG(1, "break 4");\n\t\t\treturn 0;\n\t\t}\n\t\ttotalOutputSize += expectedLen;\n\t\tif (1 + ((lastRun+255-RUN_MASK)/255) > streamBufSize)\n\t\t{\n\t\t\tDEBUGLOG(1, "break 3");\n\t\t\treturn 0;\n\t\t}\n        if (lastRun >= RUN_MASK) {\n            size_t accumulator = lastRun - RUN_MASK;\n            *opb++ = RUN_MASK << ML_BITS;\n            for(; accumulator >= 255 ; accumulator-=255) *opb++ = 255;\n            *opb++ = (BYTE) accumulator;\n        } else {\n            *opb++ = (BYTE)(lastRun<<ML_BITS);\n        }\n\t\tcurTempOffset = anchor;\n\t\twhile (lastRun > 0) {\n\t\t\tunsigned int batchSize = streamBufSize;\n\t\t\tif (batchSize > lastRun)\n\t\t\t\tbatchSize = (unsigned int)lastRun;\n\t\t\tcurSizeTemp = LZ4e_ReadStreamTemp(curTempOffset, tempbase, batchSize, ssource);\n\t\t\tif (curSizeTemp != batchSize)\n\t\t\t{\n\t\t\t\tDEBUGLOG(1, "break 2");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tunsigned const expectedLen = opb-opbaseb;\n\t\t\tif (expectedLen != LZ4e_outputBuffer(opbaseb, opb, olimitb, sdest))\n\t\t\t{\n\t\t\t\tDEBUGLOG(1, "break 1");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\ttotalOutputSize += expectedLen;\n\t\t\tmemcpy(opb, tempbase, batchSize);\n\t\t\tcurTempOffset += batchSize;\n\t\t\topb += batchSize;\n\t\t\tlastRun -= batchSize;\n\t\t}\n\t\tssource->pos = curTempOffset;\n\t}\n\t\n    cctx->dictSize += (U32)totalInputSize;\n    cctx->currentOffset += (U32)totalInputSize;\n\tunsigned const expectedLen = opb-opbaseb;\n\tif (expectedLen != LZ4e_outputBuffer(opbaseb, opb, olimitb, sdest))\n\t{\n\t\tDEBUGLOG(1, "break 0");\n\t\treturn 0;\n\t}\n\ttotalOutputSize += expectedLen;\n    DEBUGLOG(5, "LZ4_compress_generic: compressed %llu bytes into %i bytes", ssource->pos, totalOutputSize);\n    return totalOutputSize;//(int)(((char*)op) - dest);\n}\n\nunsigned int LZ4_compress_fast_extState(void* state, LZ4e_instream_t* source, LZ4e_outstream_t* dest, void *streamBuf, int acceleration, unsigned int totalSize, unsigned int streamBufSize)\n{\n    LZ4_stream_t_internal* ctx = &((LZ4_stream_t*)state)->internal_donotuse;\n    if (acceleration < 1) acceleration = ACCELERATION_DEFAULT;\n    LZ4_resetStream((LZ4_stream_t*)state);\n    if (totalSize < LZ4_64Klimit) {\n        return LZ4_compress_generic(ctx, source, dest, streamBuf, streamBufSize, byU16, acceleration);\n    } else {\n        return LZ4_compress_generic(ctx, source, dest, streamBuf, streamBufSize, byU32, acceleration);\n    }\n}\n\nunsigned int LZ4e_compress_fast(LZ4e_instream_t* source, LZ4e_outstream_t* dest, int acceleration, unsigned int totalSize, unsigned int streamBufSize)\n{\n    unsigned int result;\n#if (LZ4_HEAPMODE)\n    LZ4_stream_t* ctxPtr = (LZ4_stream_t*)ALLOC(sizeof(LZ4_stream_t));   /* malloc-calloc always properly aligned */\n    if (ctxPtr == NULL) return 0;\n\tif (streamBufSize < LZ4_64Klimit)\n\t\tstreamBufSize = LZ4_64Klimit;\n\tvoid* streamBuf = ALLOC(streamBufSize * 3);\n\tif (streamBuf == NULL)\n\t{\n\t\tFREEMEM(ctxPtr);\n\t\treturn 0;\n\t}\n#else\n    LZ4_stream_t ctx;\n    LZ4_stream_t* const ctxPtr = &ctx;\n\tstreamBufSize = LZ4_64Klimit;\n\tBYTE streamBuf[LZ4_64Klimit * 3];\n#endif\n    result = LZ4_compress_fast_extState(ctxPtr, source, dest, streamBuf, acceleration, totalSize, streamBufSize);\n\n#if (LZ4_HEAPMODE)\n    FREEMEM(streamBuf);\n    FREEMEM(ctxPtr);\n#endif\n    return result;\n}'