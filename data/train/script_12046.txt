b'\xef\xbb\xbf//  Copyright 2018 Google Inc. All Rights Reserved.\n//\n//  Licensed under the Apache License, Version 2.0 (the "License");\n//  you may not use this file except in compliance with the License.\n//  You may obtain a copy of the License at\n//\n//  http://www.apache.org/licenses/LICENSE-2.0\n//\n//  Unless required by applicable law or agreed to in writing, software\n//  distributed under the License is distributed on an "AS IS" BASIS,\n//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n//  See the License for the specific language governing permissions and\n//  limitations under the License.\n\nusing Rubeus.Utilities.Memory;\nusing System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Runtime.InteropServices;\n\nnamespace Rubeus.Ndr\n{\n    internal static class NdrNativeUtils\n    {\n        internal static byte[] ReadAll(this BinaryReader reader, int length)\n        {\n            byte[] ret = reader.ReadBytes(length);\n            if (ret.Length != length)\n            {\n                throw new EndOfStreamException();\n            }\n            return ret;\n        }\n\n        internal static Guid ReadComGuid(this IMemoryReader reader, IntPtr p)\n        {\n            if (p == IntPtr.Zero)\n            {\n                return IID_IUnknown;\n            }\n            return new Guid(reader.ReadBytes(p, 16));\n        }\n\n        internal static T[] EnumeratePointerList<T>(this IMemoryReader reader, IntPtr p, Func<IntPtr, T> load_type)\n        {\n            List<T> ret = new List<T>();\n\n            if (p == IntPtr.Zero)\n            {\n                return new T[0];\n            }\n\n            IntPtr curr = p;\n            IntPtr value = IntPtr.Zero;\n            while ((value = reader.ReadIntPtr(curr)) != IntPtr.Zero)\n            {\n                ret.Add(load_type(value));\n                curr += reader.PointerSize;\n            }\n            return ret.ToArray();\n        }\n\n        internal static T[] EnumeratePointerList<T>(this IMemoryReader reader, IntPtr p) where T : struct\n        {\n            return EnumeratePointerList(reader, p, i => reader.ReadStruct<T>(i));\n        }\n\n        internal static T[] ReadPointerArray<T>(this IMemoryReader reader, IntPtr p, int count, Func<IntPtr, T> load_type)\n        {\n            T[] ret = new T[count];\n            if (p == IntPtr.Zero)\n            {\n                return ret;\n            }\n\n            for (int i = 0; i < count; ++i)\n            {\n                IntPtr curr = reader.ReadIntPtr(p + i * reader.PointerSize);\n                if (curr == IntPtr.Zero)\n                {\n                    ret[i] = default;\n                }\n                else\n                {\n                    ret[i] = load_type(curr);\n                }\n            }\n            return ret;\n        }\n\n        internal static T[] ReadPointerArray<T>(this IMemoryReader reader, IntPtr p, int count) where T : struct\n        {\n            return ReadPointerArray(reader, p, count, i => reader.ReadStruct<T>(i));\n        }\n\n        internal static RPC_VERSION ToRpcVersion(this Version version)\n        {\n            return new RPC_VERSION() { MajorVersion = (ushort)version.Major, MinorVersion = (ushort)version.Minor };\n        }\n\n        internal static int GetPrimitiveTypeSize<T>() where T : struct\n        {\n            if (!typeof(T).IsPrimitive)\n            {\n                throw new ArgumentException($"Type {typeof(T)} not primitive");\n            }\n\n            // The "native" size of a char is 1 due to defaulting to ANSI!\n            if (typeof(T) == typeof(char))\n            {\n                return 2;\n            }\n\n            return System.Runtime.InteropServices.Marshal.SizeOf(typeof(T));\n        }\n\n        internal static int CalculateAlignment(int offset, int alignment)\n        {\n            int result = alignment - (offset % alignment);\n            if (result < alignment)\n            {\n                return result;\n            }\n            return 0;\n        }\n\n        internal static U[] Cast<T, U>(this T[] array)\n        {\n            return (U[])(Array)array;\n        }\n\n        internal static readonly Guid IID_IUnknown = new Guid("00000000-0000-0000-C000-000000000046");\n        internal static readonly Guid IID_IDispatch = new Guid("00020400-0000-0000-C000-000000000046");\n        internal static readonly Guid IID_IPSFactoryBuffer = new Guid("D5F569D0-593B-101A-B569-08002B2DBF7A");\n        internal static readonly Guid DCE_TransferSyntax = new Guid("8A885D04-1CEB-11C9-9FE8-08002B104860");\n        internal static readonly Guid NDR64_TransferSyntax = new Guid("71710533-BEBA-4937-8319-B5DBEF9CCC36");\n        internal static readonly Guid FakeNDR64_TransferSyntax = new Guid("B4537DA9-3D03-4F6B-B594-52B2874EE9D0");\n    }\n\n    [StructLayout(LayoutKind.Sequential)]\n    struct ProxyFileInfo32 : IConvertToNative<ProxyFileInfo>\n    {\n        public IntPtr32 pProxyVtblList;\n        public IntPtr32 pStubVtblList;\n        public IntPtr32 pNamesArray;\n        public IntPtr32 pDelegatedIIDs;\n        public IntPtr32 pIIDLookupRtn;\n        public ushort TableSize;\n        public ushort TableVersion;\n\n        public ProxyFileInfo Convert()\n        {\n            ProxyFileInfo ret = new ProxyFileInfo\n            {\n                pProxyVtblList = pProxyVtblList.Convert(),\n                pStubVtblList = pStubVtblList.Convert(),\n                pNamesArray = pNamesArray.Convert(),\n                pDelegatedIIDs = pDelegatedIIDs.Convert(),\n                pIIDLookupRtn = pIIDLookupRtn.Convert(),\n                TableSize = TableSize,\n                TableVersion = TableVersion\n            };\n            return ret;\n        }\n    }\n\n    [StructLayout(LayoutKind.Sequential), CrossBitnessType(typeof(ProxyFileInfo32))]\n    struct ProxyFileInfo\n    {\n        public IntPtr pProxyVtblList;\n        public IntPtr pStubVtblList;\n        public IntPtr pNamesArray;\n        public IntPtr pDelegatedIIDs;\n        public IntPtr pIIDLookupRtn;\n        public ushort TableSize;\n        public ushort TableVersion;\n\n        public string[] GetNames(IMemoryReader reader)\n        {\n            return reader.ReadPointerArray(pNamesArray, TableSize, i => reader.ReadAnsiStringZ(i));\n        }\n\n        public Guid[] GetBaseIids(IMemoryReader reader)\n        {\n            return reader.ReadPointerArray(pDelegatedIIDs, TableSize, i => reader.ReadComGuid(i));\n        }\n\n        public CInterfaceStubHeader[] GetStubs(IMemoryReader reader)\n        {\n            return reader.ReadPointerArray<CInterfaceStubHeader>(pStubVtblList, TableSize);\n        }\n    }\n\n    [StructLayout(LayoutKind.Sequential)]\n    struct CInterfaceStubHeader32 : IConvertToNative<CInterfaceStubHeader>\n    {\n        public IntPtr32 piid;\n        public IntPtr32 pServerInfo;\n        public int DispatchTableCount;\n        public IntPtr32 pDispatchTable;\n\n        public CInterfaceStubHeader Convert()\n        {\n            CInterfaceStubHeader ret = new CInterfaceStubHeader\n            {\n                piid = piid.Convert(),\n                pServerInfo = pServerInfo.Convert(),\n                DispatchTableCount = DispatchTableCount,\n                pDispatchTable = pDispatchTable.Convert()\n            };\n            return ret;\n        }\n    }\n\n    [StructLayout(LayoutKind.Sequential), CrossBitnessType(typeof(CInterfaceStubHeader32))]\n    struct CInterfaceStubHeader\n    {\n        public IntPtr piid;\n        public IntPtr pServerInfo;\n        public int DispatchTableCount;\n        public IntPtr pDispatchTable;\n\n        public Guid GetIid(IMemoryReader reader)\n        {\n            return reader.ReadComGuid(piid);\n        }\n    }\n\n    [StructLayout(LayoutKind.Sequential)]\n    internal struct MIDL_STUB_DESC32 : IConvertToNative<MIDL_STUB_DESC>\n    {\n        public IntPtr32 RpcInterfaceInformation;\n        public IntPtr32 pfnAllocate;\n        public IntPtr32 pfnFree;\n        public IntPtr32 pGenericBindingInfo;\n        public IntPtr32 apfnNdrRundownRoutines;\n        public IntPtr32 aGenericBindingRoutinePairs;\n        public IntPtr32 apfnExprEval;\n        public IntPtr32 aXmitQuintuple;\n        public IntPtr32 pFormatTypes;\n        public int fCheckBounds;\n        public int Version;\n        public IntPtr32 pMallocFreeStruct;\n        public int MIDLVersion;\n        public IntPtr32 CommFaultOffsets;\n        public IntPtr32 aUserMarshalQuadruple;\n        public IntPtr32 NotifyRoutineTable;\n        public IntPtr32 mFlags;\n        public IntPtr32 CsRoutineTables;\n        public IntPtr32 ProxyServerInfo;\n        public IntPtr32 pExprInfo;\n        public MIDL_STUB_DESC Convert()\n        {\n            MIDL_STUB_DESC ret = new MIDL_STUB_DESC\n            {\n                RpcInterfaceInformation = RpcInterfaceInformation.Convert(),\n                pfnAllocate = pfnAllocate.Convert(),\n                pfnFree = pfnFree.Convert(),\n                pGenericBindingInfo = pGenericBindingInfo.Convert(),\n                apfnNdrRundownRoutines = apfnNdrRundownRoutines.Convert(),\n                aGenericBindingRoutinePairs = aGenericBindingRoutinePairs.Convert(),\n                apfnExprEval = apfnExprEval.Convert(),\n                aXmitQuintuple = aXmitQuintuple.Convert(),\n                pFormatTypes = pFormatTypes.Convert(),\n                fCheckBounds = fCheckBounds,\n                Version = Version,\n                pMallocFreeStruct = pMallocFreeStruct.Convert(),\n                MIDLVersion = MIDLVersion,\n                CommFaultOffsets = CommFaultOffsets.Convert(),\n                aUserMarshalQuadruple = aUserMarshalQuadruple.Convert(),\n                NotifyRoutineTable = NotifyRoutineTable.Convert(),\n                mFlags = mFlags.Convert(),\n                CsRoutineTables = CsRoutineTables.Convert(),\n                ProxyServerInfo = ProxyServerInfo.Convert(),\n                pExprInfo = pExprInfo.Convert()\n            };\n            return ret;\n        }\n    }\n\n    [StructLayout(LayoutKind.Sequential)]\n    internal struct MIDL_SERVER_INFO32 : IConvertToNative<MIDL_SERVER_INFO>\n    {\n        public IntPtr32 pStubDesc;\n        public IntPtr32 DispatchTable;\n        public IntPtr32 ProcString;\n        public IntPtr32 FmtStringOffset;\n        public IntPtr32 ThunkTable;\n        public IntPtr32 pTransferSyntax;\n        public IntPtr32 nCount;\n        public IntPtr32 pSyntaxInfo;\n        public MIDL_SERVER_INFO Convert()\n        {\n            MIDL_SERVER_INFO ret = new MIDL_SERVER_INFO\n            {\n                pStubDesc = pStubDesc.Convert(),\n                DispatchTable = DispatchTable.Convert(),\n                ProcString = ProcString.Convert(),\n                FmtStringOffset = FmtStringOffset.Convert(),\n                ThunkTable = ThunkTable.Convert(),\n                pTransferSyntax = pTransferSyntax.Convert(),\n                nCount = nCount.Convert(),\n                pSyntaxInfo = pSyntaxInfo.Convert()\n            };\n            return ret;\n        }\n    }\n\n    [StructLayout(LayoutKind.Sequential)]\n    internal struct RPC_DISPATCH_TABLE32 : IConvertToNative<RPC_DISPATCH_TABLE>\n    {\n        public int DispatchTableCount;\n        public IntPtr32 DispatchTable;\n        public IntPtr32 Reserved;\n        public RPC_DISPATCH_TABLE Convert()\n        {\n            RPC_DISPATCH_TABLE ret = new RPC_DISPATCH_TABLE\n            {\n                DispatchTableCount = DispatchTableCount,\n                DispatchTable = DispatchTable.Convert(),\n                Reserved = Reserved.Convert()\n            };\n            return ret;\n        }\n    }\n\n    [StructLayout(LayoutKind.Sequential)]\n    internal struct RPC_SERVER_INTERFACE32 : IConvertToNative<RPC_SERVER_INTERFACE>\n    {\n        public int Length;\n        public RPC_SYNTAX_IDENTIFIER InterfaceId;\n        public RPC_SYNTAX_IDENTIFIER TransferSyntax;\n        public IntPtr32 DispatchTable;\n        public int RpcProtseqEndpointCount;\n        public IntPtr32 RpcProtseqEndpoint;\n        public IntPtr32 DefaultManagerEpv;\n        public IntPtr32 InterpreterInfo;\n        public int Flags;\n        public RPC_SERVER_INTERFACE Convert()\n        {\n            RPC_SERVER_INTERFACE ret = new RPC_SERVER_INTERFACE\n            {\n                Length = Length,\n                InterfaceId = InterfaceId,\n                TransferSyntax = TransferSyntax,\n                DispatchTable = DispatchTable.Convert(),\n                RpcProtseqEndpointCount = RpcProtseqEndpointCount,\n                RpcProtseqEndpoint = RpcProtseqEndpoint.Convert(),\n                DefaultManagerEpv = DefaultManagerEpv.Convert(),\n                InterpreterInfo = InterpreterInfo.Convert(),\n                Flags = Flags\n            };\n            return ret;\n        }\n    }\n\n    [StructLayout(LayoutKind.Sequential)]\n    internal struct MIDL_SYNTAX_INFO32 : IConvertToNative<MIDL_SYNTAX_INFO>\n    {\n        public RPC_SYNTAX_IDENTIFIER TransferSyntax;\n        public IntPtr32 DispatchTable; // RPC_DISPATCH_TABLE\n        public IntPtr32 ProcString; // PFORMAT_STRING \n        public IntPtr32 FmtStringOffset; // const unsigned short* \n        public IntPtr32 TypeString; // PFORMAT_STRING \n        public IntPtr32 aUserMarshalQuadruple; // const void* \n        public IntPtr32 pMethodProperties; // const MIDL_INTERFACE_METHOD_PROPERTIES* \n        public IntPtr32 pReserved2;\n\n        public MIDL_SYNTAX_INFO Convert()\n        {\n            MIDL_SYNTAX_INFO ret = new MIDL_SYNTAX_INFO\n            {\n                TransferSyntax = TransferSyntax,\n                DispatchTable = DispatchTable.Convert(),\n                ProcString = ProcString.Convert(),\n                FmtStringOffset = ProcString.Convert(),\n                TypeString = TypeString.Convert(),\n                aUserMarshalQuadruple = aUserMarshalQuadruple.Convert(),\n                pMethodProperties = pMethodProperties.Convert(),\n                pReserved2 = pReserved2.Convert()\n            };\n            return ret;\n        }\n    }\n\n    [StructLayout(LayoutKind.Sequential), CrossBitnessType(typeof(MIDL_SYNTAX_INFO32))]\n    internal struct MIDL_SYNTAX_INFO\n    {\n        public RPC_SYNTAX_IDENTIFIER TransferSyntax;\n        public IntPtr DispatchTable; // RPC_DISPATCH_TABLE\n        public IntPtr ProcString; // PFORMAT_STRING \n        public IntPtr FmtStringOffset; // const unsigned short* \n        public IntPtr TypeString; // PFORMAT_STRING \n        public IntPtr aUserMarshalQuadruple; // const void* \n        public IntPtr pMethodProperties; // const MIDL_INTERFACE_METHOD_PROPERTIES* \n        public IntPtr pReserved2;\n    }\n\n    [Flags]\n    internal enum RpcFlags : uint\n    {\n        HasPipes = 0x0001,\n        Message = 0x01000000,\n        AutoComplete = 0x08000000,\n        LocalCall = 0x10000000,\n        InputSynchronous = 0x20000000,\n        Asynchronous = 0x40000000,\n        NonNdr = 0x80000000,\n        HasMultiSyntaxes = 0x02000000,\n        HasCallback = 0x04000000,\n    }\n\n    [StructLayout(LayoutKind.Sequential), CrossBitnessType(typeof(MIDL_STUB_DESC32))]\n    internal struct MIDL_STUB_DESC\n    {\n        public IntPtr RpcInterfaceInformation;\n        public IntPtr pfnAllocate;\n        public IntPtr pfnFree;\n        public IntPtr pGenericBindingInfo;\n        public IntPtr apfnNdrRundownRoutines;\n        public IntPtr aGenericBindingRoutinePairs;\n        public IntPtr apfnExprEval;\n        public IntPtr aXmitQuintuple;\n        public IntPtr pFormatTypes;\n        public int fCheckBounds;\n        /* Ndr library version. */\n        public int Version;\n        public IntPtr pMallocFreeStruct;\n        public int MIDLVersion;\n        public IntPtr CommFaultOffsets;\n        // New fields for version 3.0+\n        public IntPtr aUserMarshalQuadruple;\n        // Notify routines - added for NT5, MIDL 5.0\n        public IntPtr NotifyRoutineTable;\n        public IntPtr mFlags;\n        // International support routines - added for 64bit post NT5\n        public IntPtr CsRoutineTables;\n        public IntPtr ProxyServerInfo;\n        public IntPtr pExprInfo;\n\n        public NDR_EXPR_DESC GetExprDesc(IMemoryReader reader)\n        {\n            if (pExprInfo != IntPtr.Zero)\n            {\n                return reader.ReadStruct<NDR_EXPR_DESC>(pExprInfo);\n            }\n            return new NDR_EXPR_DESC();\n        }\n\n        public RpcFlags GetFlags()\n        {\n            return (RpcFlags)(uint)mFlags.ToInt32();\n        }\n    }\n\n    [StructLayout(LayoutKind.Sequential), CrossBitnessType(typeof(MIDL_SERVER_INFO32))]\n    internal struct MIDL_SERVER_INFO\n    {\n        public IntPtr pStubDesc;\n        public IntPtr DispatchTable;\n        public IntPtr ProcString;\n        public IntPtr FmtStringOffset;\n        public IntPtr ThunkTable;\n        public IntPtr pTransferSyntax;\n        public IntPtr nCount;\n        public IntPtr pSyntaxInfo;\n\n        public MIDL_STUB_DESC GetStubDesc(IMemoryReader reader)\n        {\n            if (pStubDesc == IntPtr.Zero)\n            {\n                return new MIDL_STUB_DESC();\n            }\n            return reader.ReadStruct<MIDL_STUB_DESC>(pStubDesc);\n        }\n\n        public IntPtr[] GetDispatchTable(IMemoryReader reader, int dispatch_count)\n        {\n            if (DispatchTable == IntPtr.Zero)\n            {\n                return new IntPtr[dispatch_count];\n            }\n            return reader.ReadArray<IntPtr>(DispatchTable, dispatch_count);\n        }\n\n        public RPC_SYNTAX_IDENTIFIER GetTransferSyntax(IMemoryReader reader)\n        {\n            if (pTransferSyntax == IntPtr.Zero)\n            {\n                return new RPC_SYNTAX_IDENTIFIER() { SyntaxGUID = NdrNativeUtils.DCE_TransferSyntax };\n            }\n            return reader.ReadStruct<RPC_SYNTAX_IDENTIFIER>(pTransferSyntax);\n        }\n\n        public MIDL_SYNTAX_INFO[] GetSyntaxInfo(IMemoryReader reader)\n        {\n            if (nCount == IntPtr.Zero || pSyntaxInfo == IntPtr.Zero)\n            {\n                return new MIDL_SYNTAX_INFO[0];\n            }\n            return reader.ReadArray<MIDL_SYNTAX_INFO>(pSyntaxInfo, nCount.ToInt32());\n        }\n    }\n\n    [StructLayout(LayoutKind.Sequential)]\n    internal struct RPC_VERSION\n    {\n        public ushort MajorVersion;\n        public ushort MinorVersion;\n    }\n\n    [StructLayout(LayoutKind.Sequential)]\n    internal struct RPC_SYNTAX_IDENTIFIER\n    {\n        public Guid SyntaxGUID;\n        public RPC_VERSION SyntaxVersion;\n\n        public RPC_SYNTAX_IDENTIFIER(Guid guid, ushort major, ushort minor)\n        {\n            SyntaxGUID = guid;\n            SyntaxVersion = new RPC_VERSION() { MajorVersion = major, MinorVersion = minor };\n        }\n    }\n\n    [StructLayout(LayoutKind.Sequential), CrossBitnessType(typeof(RPC_DISPATCH_TABLE32))]\n    internal struct RPC_DISPATCH_TABLE\n    {\n        public int DispatchTableCount;\n        public IntPtr DispatchTable; // RPC_DISPATCH_FUNCTION*\n        public IntPtr Reserved;\n\n        public IntPtr[] GetDispatchTable(IMemoryReader reader)\n        {\n            return reader.ReadArray<IntPtr>(DispatchTable, DispatchTableCount);\n        }\n    }\n\n    [StructLayout(LayoutKind.Sequential)]\n    internal struct RPC_PROTSEQ_ENDPOINT32 : IConvertToNative<RPC_PROTSEQ_ENDPOINT>\n    {\n        public IntPtr32 RpcProtocolSequence;\n        public IntPtr32 Endpoint;\n\n        public RPC_PROTSEQ_ENDPOINT Convert()\n        {\n            RPC_PROTSEQ_ENDPOINT ret = new RPC_PROTSEQ_ENDPOINT();\n            ret.RpcProtocolSequence = RpcProtocolSequence.Convert();\n            ret.Endpoint = Endpoint.Convert();\n            return ret;\n        }\n    }\n\n    [StructLayout(LayoutKind.Sequential), CrossBitnessType(typeof(RPC_PROTSEQ_ENDPOINT32))]\n    internal struct RPC_PROTSEQ_ENDPOINT\n    {\n        public IntPtr RpcProtocolSequence;\n        public IntPtr Endpoint;\n\n        public string GetRpcProtocolSequence(IMemoryReader reader)\n        {\n            if (RpcProtocolSequence == IntPtr.Zero)\n            {\n                return string.Empty;\n            }\n            return reader.ReadAnsiStringZ(RpcProtocolSequence);\n        }\n\n        public string GetEndpoint(IMemoryReader reader)\n        {\n            if (Endpoint == IntPtr.Zero)\n            {\n                return string.Empty;\n            }\n            return reader.ReadAnsiStringZ(Endpoint);\n        }\n    }\n\n    [StructLayout(LayoutKind.Sequential), CrossBitnessType(typeof(RPC_SERVER_INTERFACE32))]\n    internal struct RPC_SERVER_INTERFACE\n    {\n        public int Length;\n        public RPC_SYNTAX_IDENTIFIER InterfaceId;\n        public RPC_SYNTAX_IDENTIFIER TransferSyntax;\n        public IntPtr DispatchTable; // PRPC_DISPATCH_TABLE\n        public int RpcProtseqEndpointCount;\n        public IntPtr RpcProtseqEndpoint; // PRPC_PROTSEQ_ENDPOINT \n        public IntPtr DefaultManagerEpv;\n        public IntPtr InterpreterInfo;    // MIDL_SERVER_INFO\n        public int Flags;\n\n        public RPC_DISPATCH_TABLE GetDispatchTable(IMemoryReader reader)\n        {\n            if (DispatchTable == IntPtr.Zero)\n            {\n                return new RPC_DISPATCH_TABLE();\n            }\n\n            return reader.ReadStruct<RPC_DISPATCH_TABLE>(DispatchTable);\n        }\n\n        public MIDL_SERVER_INFO GetServerInfo(IMemoryReader reader)\n        {\n            if (InterpreterInfo == IntPtr.Zero)\n            {\n                return new MIDL_SERVER_INFO();\n            }\n            return reader.ReadStruct<MIDL_SERVER_INFO>(InterpreterInfo);\n        }\n\n        public RPC_PROTSEQ_ENDPOINT[] GetProtSeq(IMemoryReader reader)\n        {\n            if (RpcProtseqEndpoint == IntPtr.Zero || RpcProtseqEndpointCount == 0)\n            {\n                return new RPC_PROTSEQ_ENDPOINT[0];\n            }\n            return reader.ReadArray<RPC_PROTSEQ_ENDPOINT>(RpcProtseqEndpoint, RpcProtseqEndpointCount);\n        }\n    }\n\n    [StructLayout(LayoutKind.Sequential)]\n    internal struct NDR_EXPR_DESC32 : IConvertToNative<NDR_EXPR_DESC>\n    {\n        public IntPtr32 pOffset;\n        public IntPtr32 pFormatExpr;\n\n        public NDR_EXPR_DESC Convert()\n        {\n            NDR_EXPR_DESC ret = new NDR_EXPR_DESC();\n            ret.pOffset = pOffset.Convert();\n            ret.pFormatExpr = pFormatExpr.Convert();\n            return ret;\n        }\n    }\n\n    [StructLayout(LayoutKind.Sequential), CrossBitnessType(typeof(NDR_EXPR_DESC32))]\n    internal struct NDR_EXPR_DESC\n    {\n        public IntPtr pOffset;\n        public IntPtr pFormatExpr;\n    }\n\n    [Flags]\n    internal enum MidlTypePicklingInfoFlags\n    {\n        None = 0,\n        NewCorrDesc = 0x1,\n        Oicf = 0x2,\n    }\n\n    [StructLayout(LayoutKind.Sequential)]\n    internal struct MIDL_TYPE_PICKLING_INFO\n    {\n        public int Version;\n        public MidlTypePicklingInfoFlags Flags;\n        // UINT_PTR Reserved[3];\n    }\n\n    [Flags]\n    enum NdrInterpreterFlags : byte\n    {\n        FullPtrUsed = 0x01,\n        RpcSsAllocUsed = 0x02,\n        ObjectProc = 0x04,\n        HasRpcFlags = 0x08,\n        IgnoreObjectException = 0x10,\n        HasCommOrFault = 0x20,\n        UseNewInitRoutines = 0x40,\n    }\n\n    [StructLayout(LayoutKind.Sequential)]\n    struct NdrProcHeaderExts\n    {\n        public byte Size;\n        public NdrInterpreterOptFlags2 Flags2;\n        public ushort ClientCorrHint;\n        public ushort ServerCorrHint;\n        public ushort NotifyIndex;\n    }\n\n    [StructLayout(LayoutKind.Sequential)]\n    struct NdrProcHeaderExts64\n    {\n        public byte Size;\n        public NdrInterpreterOptFlags2 Flags2;\n        public ushort ClientCorrHint;\n        public ushort ServerCorrHint;\n        public ushort NotifyIndex;\n        public ushort FloatArgMask;\n    }\n}\n'