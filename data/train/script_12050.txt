b"module Database.Beam.Query.Operator\n  ( SqlBool\n\n    -- ** General-purpose operators\n  , (&&.), (||.), not_, div_, mod_\n  , (&&?.), (||?.), sqlNot_\n\n  , like_, similarTo_\n  , like_', similarTo_'\n\n  , concat_\n  ) where\n\nimport           Database.Beam.Backend.SQL\n\nimport           Database.Beam.Query.Internal\n\nimport           Control.Applicative\n\nimport qualified Data.Text as T\n\n-- | Phantom type representing a SQL /Tri-state/ boolean -- true, false, and unknown\n--\n-- This type has no values because it cannot be sent to or retrieved\n-- from the database directly. Use 'isTrue_', 'isFalse_',\n-- 'isNotTrue_', 'isNotFalse_', 'isUnknown_', 'isNotUnknown_', and\n-- `unknownAs_` to retrieve the corresponding 'Bool' value.\ndata SqlBool\n\n-- | SQL @AND@ operator\n(&&.) :: BeamSqlBackend be\n      => QGenExpr context be s Bool\n      -> QGenExpr context be s Bool\n      -> QGenExpr context be s Bool\n(&&.) = qBinOpE andE\n\n-- | SQL @OR@ operator\n(||.) :: BeamSqlBackend be\n      => QGenExpr context be s Bool\n      -> QGenExpr context be s Bool\n      -> QGenExpr context be\n      s Bool\n(||.) = qBinOpE orE\n\n-- | SQL @AND@ operator for 'SqlBool'\n(&&?.) :: BeamSqlBackend be\n       => QGenExpr context be s SqlBool\n       -> QGenExpr context be s SqlBool\n       -> QGenExpr context be s SqlBool\n(&&?.) = qBinOpE andE\n\n-- | SQL @OR@ operator\n(||?.) :: BeamSqlBackend be\n       => QGenExpr context be s SqlBool\n       -> QGenExpr context be s SqlBool\n       -> QGenExpr context be s SqlBool\n(||?.) = qBinOpE orE\n\ninfixr 3 &&., &&?.\ninfixr 2 ||., ||?.\n\n-- | SQL @LIKE@ operator\nlike_\n  :: (BeamSqlBackendIsString be text, BeamSqlBackend be)\n  => QGenExpr ctxt be s text\n  -> QGenExpr ctxt be s text\n  -> QGenExpr ctxt be s Bool\nlike_ = like_'\n\n-- | SQL @LIKE@ operator but heterogeneous over the text type\nlike_'\n  :: ( BeamSqlBackendIsString be left\n     , BeamSqlBackendIsString be right\n     , BeamSqlBackend be\n     )\n  => QGenExpr ctxt be s left\n  -> QGenExpr ctxt be s right\n  -> QGenExpr ctxt be s Bool\nlike_' (QExpr scrutinee) (QExpr search) =\n  QExpr (liftA2 likeE scrutinee search)\n\n-- | SQL99 @SIMILAR TO@ operator\nsimilarTo_\n  :: (BeamSqlBackendIsString be text, BeamSql99ExpressionBackend be)\n  => QGenExpr ctxt be s text\n  -> QGenExpr ctxt be s text\n  -> QGenExpr ctxt be s text\nsimilarTo_ = similarTo_'\n\n-- | SQL99 @SIMILAR TO@ operator but heterogeneous over the text type\nsimilarTo_'\n  :: ( BeamSqlBackendIsString be left\n     , BeamSqlBackendIsString be right\n     , BeamSql99ExpressionBackend be\n     )\n  => QGenExpr ctxt be s left\n  -> QGenExpr ctxt be s right\n  -> QGenExpr ctxt be s left\nsimilarTo_' (QExpr scrutinee) (QExpr search) =\n  QExpr (liftA2 similarToE scrutinee search)\n\ninfix 4 `like_`, `similarTo_`\n\n-- | SQL @NOT@ operator\nnot_ :: forall be context s\n      . BeamSqlBackend be\n     => QGenExpr context be s Bool\n     -> QGenExpr context be s Bool\nnot_ (QExpr a) = QExpr (fmap notE a)\n\n-- | SQL @NOT@ operator, but operating on 'SqlBool' instead\nsqlNot_ :: forall be context s\n         . BeamSqlBackend be\n        => QGenExpr context be s SqlBool\n        -> QGenExpr context be s SqlBool\nsqlNot_ (QExpr a) = QExpr (fmap notE a)\n\n-- | SQL @/@ operator\ndiv_ :: (Integral a, BeamSqlBackend be)\n     => QGenExpr context be s a -> QGenExpr context be s a\n     -> QGenExpr context be s a\ndiv_ = qBinOpE divE\n\ninfixl 7 `div_`, `mod_`\n\n-- | SQL @%@ operator\nmod_ :: (Integral a, BeamSqlBackend be)\n     => QGenExpr context be s a -> QGenExpr context be s a\n     -> QGenExpr context be s a\nmod_ = qBinOpE modE\n\n-- | SQL @CONCAT@ function\nconcat_ :: BeamSql99ConcatExpressionBackend be\n        => [ QGenExpr context be s T.Text ] -> QGenExpr context be s T.Text\nconcat_ es = QExpr (concatE <$> mapM (\\(QExpr e) -> e) es)\n"