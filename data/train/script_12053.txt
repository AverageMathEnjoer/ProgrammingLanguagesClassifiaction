b'package com.rd;\n\nimport android.annotation.SuppressLint;\nimport android.annotation.TargetApi;\nimport android.content.Context;\nimport android.database.DataSetObserver;\nimport android.graphics.Canvas;\nimport android.os.Build;\nimport android.os.Handler;\nimport android.os.Looper;\nimport android.os.Parcelable;\nimport androidx.annotation.NonNull;\nimport androidx.annotation.Nullable;\nimport androidx.core.text.TextUtilsCompat;\nimport androidx.viewpager.widget.PagerAdapter;\nimport androidx.core.view.ViewCompat;\nimport androidx.viewpager.widget.ViewPager;\nimport android.util.AttributeSet;\nimport android.util.Pair;\nimport android.view.MotionEvent;\nimport android.view.View;\nimport android.view.ViewGroup;\nimport android.view.ViewParent;\nimport com.rd.animation.type.*;\nimport com.rd.draw.controller.DrawController;\nimport com.rd.draw.data.Indicator;\nimport com.rd.draw.data.Orientation;\nimport com.rd.draw.data.PositionSavedState;\nimport com.rd.draw.data.RtlMode;\nimport com.rd.utils.CoordinatesUtils;\nimport com.rd.utils.DensityUtils;\nimport com.rd.utils.IdUtils;\n\npublic class PageIndicatorView extends View implements ViewPager.OnPageChangeListener, IndicatorManager.Listener, ViewPager.OnAdapterChangeListener, View.OnTouchListener {\n\n    private static final Handler HANDLER = new Handler(Looper.getMainLooper());\n\n    private IndicatorManager manager;\n    private DataSetObserver setObserver;\n    private ViewPager viewPager;\n    private boolean isInteractionEnabled;\n\n    public PageIndicatorView(Context context) {\n        super(context);\n        init(null);\n    }\n\n    public PageIndicatorView(Context context, AttributeSet attrs) {\n        super(context, attrs);\n        init(attrs);\n    }\n\n    public PageIndicatorView(Context context, AttributeSet attrs, int defStyleAttr) {\n        super(context, attrs, defStyleAttr);\n        init(attrs);\n    }\n\n    @TargetApi(Build.VERSION_CODES.LOLLIPOP)\n    public PageIndicatorView(Context context, AttributeSet attrs, int defStyleAttr, int defStyleRes) {\n        super(context, attrs, defStyleAttr, defStyleRes);\n        init(attrs);\n    }\n\n    @Override\n    protected void onAttachedToWindow() {\n        super.onAttachedToWindow();\n        findViewPager(getParent());\n    }\n\n    @Override\n    protected void onDetachedFromWindow() {\n        unRegisterSetObserver();\n        super.onDetachedFromWindow();\n    }\n\n    @Override\n    public Parcelable onSaveInstanceState() {\n        Indicator indicator = manager.indicator();\n        PositionSavedState positionSavedState = new PositionSavedState(super.onSaveInstanceState());\n        positionSavedState.setSelectedPosition(indicator.getSelectedPosition());\n        positionSavedState.setSelectingPosition(indicator.getSelectingPosition());\n        positionSavedState.setLastSelectedPosition(indicator.getLastSelectedPosition());\n\n        return positionSavedState;\n    }\n\n    @Override\n    public void onRestoreInstanceState(Parcelable state) {\n        if (state instanceof PositionSavedState) {\n            Indicator indicator = manager.indicator();\n            PositionSavedState positionSavedState = (PositionSavedState) state;\n            indicator.setSelectedPosition(positionSavedState.getSelectedPosition());\n            indicator.setSelectingPosition(positionSavedState.getSelectingPosition());\n            indicator.setLastSelectedPosition(positionSavedState.getLastSelectedPosition());\n            super.onRestoreInstanceState(positionSavedState.getSuperState());\n\n        } else {\n            super.onRestoreInstanceState(state);\n        }\n    }\n\n    @Override\n    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {\n        Pair<Integer, Integer> pair = manager.drawer().measureViewSize(widthMeasureSpec, heightMeasureSpec);\n        setMeasuredDimension(pair.first, pair.second);\n    }\n\n    @Override\n    protected void onDraw(Canvas canvas) {\n        manager.drawer().draw(canvas);\n    }\n\n    @SuppressLint("ClickableViewAccessibility")\n    @Override\n    public boolean onTouchEvent(MotionEvent event) {\n        manager.drawer().touch(event);\n        return true;\n    }\n\n    @Override\n    public boolean onTouch(View v, MotionEvent event) {\n        if (!manager.indicator().isFadeOnIdle()) return false;\n\n        switch (event.getAction()) {\n            case MotionEvent.ACTION_DOWN:\n                stopIdleRunnable();\n                break;\n\n            case MotionEvent.ACTION_UP:\n                startIdleRunnable();\n                break;\n        }\n        return false;\n    }\n\n    @Override\n    public void onIndicatorUpdated() {\n        invalidate();\n    }\n\n    @Override\n    public void onPageScrolled(int position, float positionOffset, int positionOffsetPixels) {\n        onPageScroll(position, positionOffset);\n    }\n\n    @Override\n    public void onPageSelected(int position) {\n        onPageSelect(position);\n    }\n\n    @Override\n    public void onPageScrollStateChanged(int state) {\n        if (state == ViewPager.SCROLL_STATE_IDLE) {\n            manager.indicator().setInteractiveAnimation(isInteractionEnabled);\n        }\n    }\n\n    @Override\n    public void onAdapterChanged(@NonNull ViewPager viewPager, @Nullable PagerAdapter oldAdapter, @Nullable PagerAdapter newAdapter) {\n        if (manager.indicator().isDynamicCount()) {\n            if (oldAdapter != null && setObserver != null) {\n                oldAdapter.unregisterDataSetObserver(setObserver);\n                setObserver = null;\n            }\n            registerSetObserver();\n        }\n        updateState();\n    }\n\n    /**\n     * Set static number of circle indicators to be displayed.\n     *\n     * @param count total count of indicators.\n     */\n    public void setCount(int count) {\n        if (count >= 0 && manager.indicator().getCount() != count) {\n            manager.indicator().setCount(count);\n            updateVisibility();\n            requestLayout();\n        }\n    }\n\n    /**\n     * Return number of circle indicators\n     */\n    public int getCount() {\n        return manager.indicator().getCount();\n    }\n\n    /**\n     * Dynamic count will automatically update number of circle indicators\n     * if {@link ViewPager} page count updates on run-time. If new count will be bigger than current count,\n     * selected circle will stay as it is, otherwise it will be set to last one.\n     * Note: works if {@link ViewPager} set and already have it\'s adapter. See {@link #setViewPager(ViewPager)}.\n     *\n     * @param dynamicCount boolean value to add/remove indicators dynamically.\n     */\n    public void setDynamicCount(boolean dynamicCount) {\n        manager.indicator().setDynamicCount(dynamicCount);\n\n        if (dynamicCount) {\n            registerSetObserver();\n        } else {\n            unRegisterSetObserver();\n        }\n    }\n\n    /**\n     * Fade on idle will make {@link PageIndicatorView} {@link View#INVISIBLE} if {@link ViewPager} is not interacted\n     * in time equal to {@link Indicator#idleDuration}. Take care when setting {@link PageIndicatorView} alpha\n     * manually if this is true. Alpha is used to manage fading and appearance of {@link PageIndicatorView} and value you provide\n     * will be overridden when {@link PageIndicatorView} enters or leaves idle state.\n     *\n     * @param fadeOnIdle boolean value to hide {@link PageIndicatorView} when {@link ViewPager} is idle\n     */\n    public void setFadeOnIdle(boolean fadeOnIdle) {\n        manager.indicator().setFadeOnIdle(fadeOnIdle);\n        if (fadeOnIdle) {\n            startIdleRunnable();\n        } else {\n            stopIdleRunnable();\n        }\n    }\n\n    /**\n     * Set radius in dp of each circle indicator. Default value is {@link Indicator#DEFAULT_RADIUS_DP}.\n     * Note: make sure you set circle Radius, not a Diameter.\n     *\n     * @param radiusDp radius of circle in dp.\n     */\n    public void setRadius(int radiusDp) {\n        if (radiusDp < 0) {\n            radiusDp = 0;\n        }\n\n        int radiusPx = DensityUtils.dpToPx(radiusDp);\n        manager.indicator().setRadius(radiusPx);\n        invalidate();\n    }\n\n    /**\n     * Set radius in px of each circle indicator. Default value is {@link Indicator#DEFAULT_RADIUS_DP}.\n     * Note: make sure you set circle Radius, not a Diameter.\n     *\n     * @param radiusPx radius of circle in px.\n     */\n    public void setRadius(float radiusPx) {\n        if (radiusPx < 0) {\n            radiusPx = 0;\n        }\n\n        manager.indicator().setRadius((int) radiusPx);\n        invalidate();\n    }\n\n    /**\n     * Return radius of each circle indicators in px. If custom radius is not set, return\n     * default value {@link Indicator#DEFAULT_RADIUS_DP}.\n     */\n    public int getRadius() {\n        return manager.indicator().getRadius();\n    }\n\n    /**\n     * Set padding in dp between each circle indicator. Default value is {@link Indicator#DEFAULT_PADDING_DP}.\n     *\n     * @param paddingDp padding between circles in dp.\n     */\n    public void setPadding(int paddingDp) {\n        if (paddingDp < 0) {\n            paddingDp = 0;\n        }\n\n        int paddingPx = DensityUtils.dpToPx(paddingDp);\n        manager.indicator().setPadding(paddingPx);\n        invalidate();\n    }\n\n    /**\n     * Set padding in px between each circle indicator. Default value is {@link Indicator#DEFAULT_PADDING_DP}.\n     *\n     * @param paddingPx padding between circles in px.\n     */\n    public void setPadding(float paddingPx) {\n        if (paddingPx < 0) {\n            paddingPx = 0;\n        }\n\n        manager.indicator().setPadding((int) paddingPx);\n        invalidate();\n    }\n\n    /**\n     * Return padding in px between each circle indicator. If custom padding is not set,\n     * return default value {@link Indicator#DEFAULT_PADDING_DP}.\n     */\n    public int getPadding() {\n        return manager.indicator().getPadding();\n    }\n\n    /**\n     * Set scale factor used in {@link AnimationType#SCALE} animation.\n     * Defines size of unselected indicator circles in comparing to selected one.\n     * Minimum and maximum values are {@link ScaleAnimation#MAX_SCALE_FACTOR} and {@link ScaleAnimation#MIN_SCALE_FACTOR}.\n     * See also {@link ScaleAnimation#DEFAULT_SCALE_FACTOR}.\n     *\n     * @param factor float value in range between 0 and 1.\n     */\n    public void setScaleFactor(float factor) {\n        if (factor > ScaleAnimation.MAX_SCALE_FACTOR) {\n            factor = ScaleAnimation.MAX_SCALE_FACTOR;\n\n        } else if (factor < ScaleAnimation.MIN_SCALE_FACTOR) {\n            factor = ScaleAnimation.MIN_SCALE_FACTOR;\n        }\n\n        manager.indicator().setScaleFactor(factor);\n    }\n\n    /**\n     * Returns scale factor values used in {@link AnimationType#SCALE} animation.\n     * Defines size of unselected indicator circles in comparing to selected one.\n     * Minimum and maximum values are {@link ScaleAnimation#MAX_SCALE_FACTOR} and {@link ScaleAnimation#MIN_SCALE_FACTOR}.\n     * See also {@link ScaleAnimation#DEFAULT_SCALE_FACTOR}.\n     *\n     * @return float value that indicate scale factor.\n     */\n    public float getScaleFactor() {\n        return manager.indicator().getScaleFactor();\n    }\n\n    /**\n     * Set stroke width in px to set while {@link AnimationType#FILL} is selected.\n     * Default value is {@link FillAnimation#DEFAULT_STROKE_DP}\n     *\n     * @param strokePx stroke width in px.\n     */\n    public void setStrokeWidth(float strokePx) {\n        int radiusPx = manager.indicator().getRadius();\n\n        if (strokePx < 0) {\n            strokePx = 0;\n\n        } else if (strokePx > radiusPx) {\n            strokePx = radiusPx;\n        }\n\n        manager.indicator().setStroke((int) strokePx);\n        invalidate();\n    }\n\n    /**\n     * Set stroke width in dp to set while {@link AnimationType#FILL} is selected.\n     * Default value is {@link FillAnimation#DEFAULT_STROKE_DP}\n     *\n     * @param strokeDp stroke width in dp.\n     */\n\n    public void setStrokeWidth(int strokeDp) {\n        int strokePx = DensityUtils.dpToPx(strokeDp);\n        int radiusPx = manager.indicator().getRadius();\n\n        if (strokePx < 0) {\n            strokePx = 0;\n\n        } else if (strokePx > radiusPx) {\n            strokePx = radiusPx;\n        }\n\n        manager.indicator().setStroke(strokePx);\n        invalidate();\n    }\n\n    /**\n     * Return stroke width in px if {@link AnimationType#FILL} is selected, 0 otherwise.\n     */\n    public int getStrokeWidth() {\n        return manager.indicator().getStroke();\n    }\n\n    /**\n     * Set color of selected state to circle indicator. Default color is {@link ColorAnimation#DEFAULT_SELECTED_COLOR}.\n     *\n     * @param color color selected circle.\n     */\n    public void setSelectedColor(int color) {\n        manager.indicator().setSelectedColor(color);\n        invalidate();\n    }\n\n    /**\n     * Return color of selected circle indicator. If custom unselected color\n     * is not set, return default color {@link ColorAnimation#DEFAULT_SELECTED_COLOR}.\n     */\n    public int getSelectedColor() {\n        return manager.indicator().getSelectedColor();\n    }\n\n    /**\n     * Set color of unselected state to each circle indicator. Default color {@link ColorAnimation#DEFAULT_UNSELECTED_COLOR}.\n     *\n     * @param color color of each unselected circle.\n     */\n    public void setUnselectedColor(int color) {\n        manager.indicator().setUnselectedColor(color);\n        invalidate();\n    }\n\n    /**\n     * Return color of unselected state of each circle indicator. If custom unselected color\n     * is not set, return default color {@link ColorAnimation#DEFAULT_UNSELECTED_COLOR}.\n     */\n    public int getUnselectedColor() {\n        return manager.indicator().getUnselectedColor();\n    }\n\n    /**\n     * Automatically hide (View.INVISIBLE) PageIndicatorView while indicator count is <= 1.\n     * Default is true.\n     *\n     * @param autoVisibility auto hide indicators.\n     */\n    public void setAutoVisibility(boolean autoVisibility) {\n        if (!autoVisibility) {\n            setVisibility(VISIBLE);\n        }\n\n        manager.indicator().setAutoVisibility(autoVisibility);\n        updateVisibility();\n    }\n\n    /**\n     * Set orientation for indicator, one of HORIZONTAL or VERTICAL.\n     * Default is HORIZONTAL.\n     *\n     * @param orientation an orientation to display page indicators.\n     */\n    public void setOrientation(@Nullable Orientation orientation) {\n        if (orientation != null) {\n            manager.indicator().setOrientation(orientation);\n            requestLayout();\n        }\n    }\n\n    /**\n     * Set animation duration time in millisecond. Default animation duration time is {@link BaseAnimation#DEFAULT_ANIMATION_TIME}.\n     * (Won\'t affect on anything unless {@link #setAnimationType(AnimationType type)} is specified\n     * and {@link #setInteractiveAnimation(boolean isInteractive)} is false).\n     *\n     * @param duration animation duration time.\n     */\n    public void setAnimationDuration(long duration) {\n        manager.indicator().setAnimationDuration(duration);\n    }\n\n    /**\n     * Sets time in millis after which {@link ViewPager} is considered idle.\n     * If {@link Indicator#fadeOnIdle} is true, {@link PageIndicatorView} will\n     * fade away after entering idle state and appear when it is left.\n     *\n     * @param duration time in millis after which {@link ViewPager} is considered idle\n     */\n    public void setIdleDuration(long duration) {\n        manager.indicator().setIdleDuration(duration);\n        if (manager.indicator().isFadeOnIdle()) {\n            startIdleRunnable();\n        } else {\n            stopIdleRunnable();\n        }\n    }\n\n    /**\n     * Return animation duration time in milliseconds. If custom duration is not set,\n     * return default duration time {@link BaseAnimation#DEFAULT_ANIMATION_TIME}.\n     */\n    public long getAnimationDuration() {\n        return manager.indicator().getAnimationDuration();\n    }\n\n    /**\n     * Set animation type to perform while selecting new circle indicator.\n     * Default animation type is {@link AnimationType#NONE}.\n     *\n     * @param type type of animation, one of {@link AnimationType}\n     */\n    public void setAnimationType(@Nullable AnimationType type) {\n        manager.onValueUpdated(null);\n\n        if (type != null) {\n            manager.indicator().setAnimationType(type);\n        } else {\n            manager.indicator().setAnimationType(AnimationType.NONE);\n        }\n        invalidate();\n    }\n\n    /**\n     * Interactive animation will animate indicator smoothly\n     * from position to position based on user\'s current swipe progress.\n     * (Won\'t affect on anything unless {@link #setViewPager(ViewPager)} is specified).\n     *\n     * @param isInteractive value of animation to be interactive or not.\n     */\n    public void setInteractiveAnimation(boolean isInteractive) {\n        manager.indicator().setInteractiveAnimation(isInteractive);\n        this.isInteractionEnabled = isInteractive;\n    }\n\n    /**\n     * Set {@link ViewPager} to add {@link ViewPager.OnPageChangeListener} and automatically\n     * handle selecting new indicators (and interactive animation effect if it is enabled).\n     *\n     * @param pager instance of {@link ViewPager} to work with\n     */\n    @SuppressLint("ClickableViewAccessibility")\n    public void setViewPager(@Nullable ViewPager pager) {\n        releaseViewPager();\n        if (pager == null) {\n            return;\n        }\n\n        viewPager = pager;\n        viewPager.addOnPageChangeListener(this);\n        viewPager.addOnAdapterChangeListener(this);\n        viewPager.setOnTouchListener(this);\n        manager.indicator().setViewPagerId(viewPager.getId());\n\n        setDynamicCount(manager.indicator().isDynamicCount());\n        updateState();\n    }\n\n    /**\n     * Release {@link ViewPager} and stop handling events of {@link ViewPager.OnPageChangeListener}.\n     */\n    public void releaseViewPager() {\n        if (viewPager != null) {\n            viewPager.removeOnPageChangeListener(this);\n            viewPager.removeOnAdapterChangeListener(this);\n            viewPager = null;\n        }\n    }\n\n    /**\n     * Specify to display PageIndicatorView with Right to left layout or not.\n     * One of {@link RtlMode}: Off (Left to right), On (Right to left)\n     * or Auto (handle this mode automatically based on users language preferences).\n     * Default is Off.\n     *\n     * @param mode instance of {@link RtlMode}\n     */\n    public void setRtlMode(@Nullable RtlMode mode) {\n        Indicator indicator = manager.indicator();\n        if (mode == null) {\n            indicator.setRtlMode(RtlMode.Off);\n        } else {\n            indicator.setRtlMode(mode);\n        }\n\n        if (viewPager == null) {\n            return;\n        }\n\n        int selectedPosition = indicator.getSelectedPosition();\n        int position = selectedPosition;\n\n        if (isRtl()) {\n            position = (indicator.getCount() - 1) - selectedPosition;\n\n        } else if (viewPager != null) {\n            position = viewPager.getCurrentItem();\n        }\n\n        indicator.setLastSelectedPosition(position);\n        indicator.setSelectingPosition(position);\n        indicator.setSelectedPosition(position);\n        invalidate();\n    }\n\n    /**\n     * Return position of currently selected circle indicator.\n     */\n    public int getSelection() {\n        return manager.indicator().getSelectedPosition();\n    }\n\n    /**\n     * Set specific circle indicator position to be selected. If position < or > total count,\n     * accordingly first or last circle indicator will be selected.\n     *\n     * @param position position of indicator to select.\n     */\n    public void setSelection(int position) {\n        Indicator indicator = manager.indicator();\n        position = adjustPosition(position);\n\n        if (position == indicator.getSelectedPosition() || position == indicator.getSelectingPosition()) {\n            return;\n        }\n\n        indicator.setInteractiveAnimation(false);\n        indicator.setLastSelectedPosition(indicator.getSelectedPosition());\n        indicator.setSelectingPosition(position);\n        indicator.setSelectedPosition(position);\n        manager.animate().basic();\n    }\n\n    /**\n     * Set specific circle indicator position to be selected without any kind of animation. If position < or > total count,\n     * accordingly first or last circle indicator will be selected.\n     *\n     * @param position position of indicator to select.\n     */\n    public void setSelected(int position) {\n        Indicator indicator = manager.indicator();\n        AnimationType animationType = indicator.getAnimationType();\n        indicator.setAnimationType(AnimationType.NONE);\n\n        setSelection(position);\n        indicator.setAnimationType(animationType);\n    }\n\n    /**\n     * Clears selection of all indicators\n     */\n    public void clearSelection() {\n        //TODO check\n        Indicator indicator = manager.indicator();\n        indicator.setInteractiveAnimation(false);\n        indicator.setLastSelectedPosition(Indicator.COUNT_NONE);\n        indicator.setSelectingPosition(Indicator.COUNT_NONE);\n        indicator.setSelectedPosition(Indicator.COUNT_NONE);\n        manager.animate().basic();\n    }\n\n    /**\n     * Set progress value in range [0 - 1] to specify state of animation while selecting new circle indicator.\n     *\n     * @param selectingPosition selecting position with specific progress value.\n     * @param progress          float value of progress.\n     */\n    public void setProgress(int selectingPosition, float progress) {\n        Indicator indicator = manager.indicator();\n        if (!indicator.isInteractiveAnimation()) {\n            return;\n        }\n\n        int count = indicator.getCount();\n        if (count <= 0 || selectingPosition < 0) {\n            selectingPosition = 0;\n\n        } else if (selectingPosition > count - 1) {\n            selectingPosition = count - 1;\n        }\n\n        if (progress < 0) {\n            progress = 0;\n\n        } else if (progress > 1) {\n            progress = 1;\n        }\n\n        if (progress == 1) {\n            indicator.setLastSelectedPosition(indicator.getSelectedPosition());\n            indicator.setSelectedPosition(selectingPosition);\n        }\n\n        indicator.setSelectingPosition(selectingPosition);\n        manager.animate().interactive(progress);\n    }\n\n    public void setClickListener(@Nullable DrawController.ClickListener listener) {\n        manager.drawer().setClickListener(listener);\n    }\n\n    private void init(@Nullable AttributeSet attrs) {\n        setupId();\n        initIndicatorManager(attrs);\n\n        if (manager.indicator().isFadeOnIdle()) {\n            startIdleRunnable();\n        }\n    }\n\n    private void setupId() {\n        if (getId() == NO_ID) {\n            setId(IdUtils.generateViewId());\n        }\n    }\n\n    private void initIndicatorManager(@Nullable AttributeSet attrs) {\n        manager = new IndicatorManager(this);\n        manager.drawer().initAttributes(getContext(), attrs);\n\n        Indicator indicator = manager.indicator();\n        indicator.setPaddingLeft(getPaddingLeft());\n        indicator.setPaddingTop(getPaddingTop());\n        indicator.setPaddingRight(getPaddingRight());\n        indicator.setPaddingBottom(getPaddingBottom());\n        isInteractionEnabled = indicator.isInteractiveAnimation();\n    }\n\n    private void registerSetObserver() {\n        if (setObserver != null || viewPager == null || viewPager.getAdapter() == null) {\n            return;\n        }\n\n        setObserver = new DataSetObserver() {\n            @Override\n            public void onChanged() {\n                updateState();\n            }\n        };\n\n        try {\n            viewPager.getAdapter().registerDataSetObserver(setObserver);\n        } catch (IllegalStateException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private void unRegisterSetObserver() {\n        if (setObserver == null || viewPager == null || viewPager.getAdapter() == null) {\n            return;\n        }\n\n        try {\n            viewPager.getAdapter().unregisterDataSetObserver(setObserver);\n            setObserver = null;\n        } catch (IllegalStateException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private void updateState() {\n        if (viewPager == null || viewPager.getAdapter() == null) {\n            return;\n        }\n\n        int count = viewPager.getAdapter().getCount();\n        int selectedPos = isRtl() ? (count - 1) - viewPager.getCurrentItem() : viewPager.getCurrentItem();\n\n        manager.indicator().setSelectedPosition(selectedPos);\n        manager.indicator().setSelectingPosition(selectedPos);\n        manager.indicator().setLastSelectedPosition(selectedPos);\n        manager.indicator().setCount(count);\n        manager.animate().end();\n\n        updateVisibility();\n        requestLayout();\n    }\n\n    private void updateVisibility() {\n        if (!manager.indicator().isAutoVisibility()) {\n            return;\n        }\n\n        int count = manager.indicator().getCount();\n        int visibility = getVisibility();\n\n        if (visibility != VISIBLE && count > Indicator.MIN_COUNT) {\n            setVisibility(VISIBLE);\n\n        } else if (visibility != INVISIBLE && count <= Indicator.MIN_COUNT) {\n            setVisibility(View.INVISIBLE);\n        }\n    }\n\n    private void onPageSelect(int position) {\n        Indicator indicator = manager.indicator();\n        boolean canSelectIndicator = isViewMeasured();\n        int count = indicator.getCount();\n\n        if (canSelectIndicator) {\n            if (isRtl()) {\n                position = (count - 1) - position;\n            }\n\n            setSelection(position);\n        }\n    }\n\n    private void onPageScroll(int position, float positionOffset) {\n        Indicator indicator = manager.indicator();\n        AnimationType animationType = indicator.getAnimationType();\n        boolean interactiveAnimation = indicator.isInteractiveAnimation();\n        boolean canSelectIndicator = isViewMeasured() && interactiveAnimation && animationType != AnimationType.NONE;\n\n        if (!canSelectIndicator) {\n            return;\n        }\n\n        Pair<Integer, Float> progressPair = CoordinatesUtils.getProgress(indicator, position, positionOffset, isRtl());\n        int selectingPosition = progressPair.first;\n        float selectingProgress = progressPair.second;\n        setProgress(selectingPosition, selectingProgress);\n    }\n\n    private boolean isRtl() {\n        switch (manager.indicator().getRtlMode()) {\n            case On:\n                return true;\n\n            case Off:\n                return false;\n\n            case Auto:\n                return TextUtilsCompat.getLayoutDirectionFromLocale(getContext().getResources().getConfiguration().locale) == ViewCompat.LAYOUT_DIRECTION_RTL;\n        }\n\n        return false;\n    }\n\n    private boolean isViewMeasured() {\n        return getMeasuredHeight() != 0 || getMeasuredWidth() != 0;\n    }\n\n    private void findViewPager(@Nullable ViewParent viewParent) {\n        boolean isValidParent = viewParent != null &&\n                viewParent instanceof ViewGroup &&\n                ((ViewGroup) viewParent).getChildCount() > 0;\n\n        if (!isValidParent) {\n            return;\n        }\n\n        int viewPagerId = manager.indicator().getViewPagerId();\n        ViewPager viewPager = findViewPager((ViewGroup) viewParent, viewPagerId);\n\n        if (viewPager != null) {\n            setViewPager(viewPager);\n        } else {\n            findViewPager(viewParent.getParent());\n        }\n    }\n\n    @Nullable\n    private ViewPager findViewPager(@NonNull ViewGroup viewGroup, int id) {\n        if (viewGroup.getChildCount() <= 0) {\n            return null;\n        }\n\n        View view = viewGroup.findViewById(id);\n        if (view != null && view instanceof ViewPager) {\n            return (ViewPager) view;\n        } else {\n            return null;\n        }\n    }\n\n    private int adjustPosition(int position) {\n        Indicator indicator = manager.indicator();\n        int count = indicator.getCount();\n        int lastPosition = count - 1;\n\n        if (position < 0) {\n            position = 0;\n\n        } else if (position > lastPosition) {\n            position = lastPosition;\n        }\n\n        return position;\n    }\n\n    private void displayWithAnimation() {\n        animate().cancel();\n        animate().alpha(1.0f).setDuration(Indicator.IDLE_ANIMATION_DURATION);\n    }\n\n    private void hideWithAnimation() {\n        animate().cancel();\n        animate().alpha(0f).setDuration(Indicator.IDLE_ANIMATION_DURATION);\n    }\n\n    private void startIdleRunnable() {\n        HANDLER.removeCallbacks(idleRunnable);\n        HANDLER.postDelayed(idleRunnable, manager.indicator().getIdleDuration());\n    }\n\n    private void stopIdleRunnable() {\n        HANDLER.removeCallbacks(idleRunnable);\n        displayWithAnimation();\n    }\n\n    private Runnable idleRunnable = new Runnable() {\n        @Override\n        public void run() {\n            manager.indicator().setIdle(true);\n            hideWithAnimation();\n        }\n    };\n}\n'