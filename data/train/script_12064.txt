b'#\' emlinkMARmov\n#\'\n#\' Expectation-Maximization algorithm for Record Linkage under the\n#\' Missing at Random (MAR) assumption.\n#\'\n#\' @usage emlinkMARmov(patterns, nobs.a, nobs.b, p.m, iter.max,\n#\' tol, p.gamma.k.m, p.gamma.k.u, prior.lambda, w.lambda,\n#\' prior.pi, w.pi, address.field, gender.field, varnames)\n#\'\n#\' @param patterns table that holds the counts for each unique agreement\n#\' pattern. This object is produced by the function: tableCounts.\n#\' @param nobs.a Number of observations in dataset A\n#\' @param nobs.b Number of observations in dataset B\n#\' @param p.m probability of finding a match. Default is 0.1\n#\' @param iter.max Max number of iterations. Default is 5000\n#\' @param tol Convergence tolerance. Default is 1e-05\n#\' @param p.gamma.k.m probability that conditional of being in the matched set we observed a specific agreement value for field k.\n#\' @param p.gamma.k.u probability that conditional of being in the non-matched set we observed a specific agreement value for field k.\n#\' @param prior.lambda The prior probability of finding a match, derived from auxiliary data.\n#\' @param w.lambda How much weight to give the prior on lambda versus the data. Must range between 0 (no weight on prior) and 1 (weight fully on prior)\n#\' @param prior.pi The prior probability of the address field not matching, conditional on being in the matched set. To be used when the\n#\' share of movers in the population is known with some certainty.\n#\' @param w.pi How much weight to give the prior on pi versus the data. Must range between 0 (no weight on prior) and 1 (weight fully on prior)\n#\' @param address.field Boolean indicators for whether a given field is an address field. Default is NULL (FALSE for all fields).\n#\' Address fields should be set to TRUE while non-address fields are set to FALSE if provided.\n#\' @param gender.field Boolean indicators for whether a given field is for gender. If so, exact match is conducted on gender.\n#\' Default is NULL (FALSE for all fields). The one gender field should be set to TRUE while all other fields are set to FALSE if provided.\n#\' @param varnames The vector of variable names used for matching. Automatically provided if using \\code{fastLink()} wrapper. Used for\n#\' clean visualization of EM results in summary functions.\n#\'\n#\' @return \\code{emlinkMARmov} returns a list with the following components:\n#\' \\item{zeta.j}{The posterior match probabilities for each unique pattern.}\n#\' \\item{p.m}{The probability of a pair matching.}\n#\' \\item{p.u}{The probability of a pair not matching.}\n#\' \\item{p.gamma.k.m}{The matching probability for a specific matching field.}\n#\' \\item{p.gamma.k.u}{The non-matching probability for a specific matching field.}\n#\' \\item{p.gamma.j.m}{The probability that a pair is in the matched set given a particular agreement pattern.}\n#\' \\item{p.gamma.j.u}{The probability that a pair is in the unmatched set given a particular agreement pattern.}\n#\' \\item{patterns.w}{Counts of the agreement patterns observed, along with the Felligi-Sunter Weights.}\n#\' \\item{iter.converge}{The number of iterations it took the EM algorithm to converge.}\n#\' \\item{nobs.a}{The number of observations in dataset A.}\n#\' \\item{nobs.b}{The number of observations in dataset B.}\n#\'\n#\' @author Ted Enamorado <ted.enamorado@gmail.com> and Kosuke Imai\n#\'\n#\' @examples\n#\' \\dontrun{\n#\' ## Calculate gammas\n#\' g1 <- gammaCKpar(dfA$firstname, dfB$firstname)\n#\' g2 <- gammaCKpar(dfA$middlename, dfB$middlename)\n#\' g3 <- gammaCKpar(dfA$lastname, dfB$lastname)\n#\' g4 <- gammaKpar(dfA$birthyear, dfB$birthyear)\n#\'\n#\' ## Run tableCounts\n#\' tc <- tableCounts(list(g1, g2, g3, g4), nobs.a = nrow(dfA), nobs.b = nrow(dfB))\n#\'\n#\' ## Run EM\n#\' em <- emlinkMARmov(tc, nobs.a = nrow(dfA), nobs.b = nrow(dfB))\n#\' }\n#\'\n#\' @export\n#\' @importFrom gtools rdirichlet\nemlinkMARmov <- function(patterns, nobs.a, nobs.b,\n                         p.m = 0.1, iter.max = 5000, tol = 1e-5, p.gamma.k.m = NULL, p.gamma.k.u = NULL,\n                         prior.lambda = NULL, w.lambda = NULL, \n                         prior.pi = NULL, w.pi = NULL, address.field = NULL,\n                         gender.field = NULL, varnames = NULL) {\n\n    options(digits=16)\n\n    ## EM Algorithm for a Fellegi-Sunter model that accounts for missing data (under MAR)\n    ##\n    ## Args:\n    ##   patterns:\n    ##   p.m:\n    ##   p.gamma.k.m:\n    ##   p.gamma.k.u:\n    ##   tol:\n    ##\n    ## Returns:\n    ##   The p.m, p.gamma.k.m, p.gamma.k.u, p.gamma.k.m, p.gamma.k.m, p.gamma.k.m, that\n    ##   maximize the observed data log-likelihood of the agreement patterns\n\n    ## Edge case\n    if(is.null(nrow(patterns))){\n        patterns <- as.data.frame(t(as.matrix(patterns)))\n    }\n    \n    ## Number of fields\n    nfeatures <- ncol(patterns) - 1\n\n    ## Patterns:\n    gamma.j.k <- as.matrix(patterns[, 1:nfeatures])\n\n    ## Patterns counts:\n    n.j <- as.matrix(patterns[, (nfeatures + 1)]) # Counts\n\n    ## Number of unique patterns:\n    N <- nrow(gamma.j.k)\n\n    ## Starting values if not provided by the user\n    ## mu, psi\n    if(!is.null(prior.lambda)){\n        if(is.null(w.lambda)){\n            stop("If providing a prior for lambda, please specify the weight using `w.lambda`.")\n        }\n        if(w.lambda < 0 | w.lambda > 1){\n            stop("w.lambda must be between 0 and 1.")\n        }\n        if(w.lambda == 1){\n            w.lambda <- 1 - 1e-05\n        }\n        c.lambda <- w.lambda / (1 - w.lambda)\n\n        ## Optimal hyperparameters for lambda\n        mu <- prior.lambda * c.lambda * nobs.a * nobs.b + 1\n        psi <- (1 - prior.lambda) * mu / prior.lambda\n        \n        if(w.lambda == 0){\n            psi <- 1\n            mu <- 1\n        }\n    }else{\n        psi <- 1\n        mu <- 1\n    }\n\n    ## alpha0, alpha1\n    if(!is.null(prior.pi)){\n        if(is.null(prior.lambda)){\n            stop("If providing a prior on pi, you must specify a prior for lambda as well.") \n        }\n        if(is.null(w.pi)){\n            stop("If providing a prior for pi, please specify the weight using `w.pi`.")\n        }\n        if(w.pi < 0 | w.pi > 1){\n            stop("w.pi must be between 0 and 1.")\n        }\n        if(w.pi == 1){\n            w.pi <- 1 - 1e-05\n        }\n        c.pi <- w.pi / (1 - w.pi)\n        exp.match <- prior.lambda * nobs.a * nobs.b\n\n        ## Optimal hyperparameters for pi\n        alpha0 <- c.pi * prior.pi * exp.match + 1\n        alpha1 <- alpha0 * (1 - prior.pi) / prior.pi\n\n        if(w.pi == 0){\n            alpha0 <- 1\n            alpha1 <- 1\n        }\n    }else{\n        alpha0 <- 1\n        alpha1 <- 1\n        address.field <- rep(FALSE, nfeatures)\n    }\n\n    ## Gender match\n    if(!is.null(gender.field) & sum(gender.field) == 0){\n        gender.field <- NULL\n    }\n    if(!is.null(gender.field)){\n        if(is.null(prior.lambda)){\n            stop("If exact-matching on gender, you must specify a prior for lambda.") \n        }\n        prior.gen <- 1 - 1e-05\n        w.gen <- 1 - 1e-05\n        c.gen <- w.gen / (1 - w.gen)\n        exp.match <- prior.lambda * nobs.a * nobs.b\n\n        ## Optimal hyperparameters for pi.gender\n        alpha1g <- c.gen * prior.gen * exp.match + 1\n        alpha0g <- alpha1g * (1 - prior.gen) / (prior.gen)\n        \n    }else{\n        alpha1g <- 1\n        alpha0g <- 1\n        gender.field <- rep(FALSE, nfeatures)\n    }\n\n    ## Overall Prob of finding a Match\n    p.u <- 1 - p.m\n\n    ## Field specific probability of observing gamma.k conditional on M\n    if (is.null(p.gamma.k.m)) {\n        p.gamma.k.m <- list()\n        for (i in 1:nfeatures) {\n        \tl.m <- length(unique(na.omit(gamma.j.k[, i])))\n        \tc.m <- seq(from = 1, to = 50 * l.m, by = 50)\n            p.gamma.k.m[[i]] <- sort(rdirichlet(1, c.m), decreasing = FALSE)\n        }\n    }\n\n    ## Field specific probability of observing gamma.k conditional on U\n    if (is.null(p.gamma.k.u)) {\n        p.gamma.k.u <- list()\n        for (i in 1:nfeatures) {\n        \tl.u <- length(unique(na.omit(gamma.j.k[, i])))\n        \tc.u <- seq(from = 1, to = 50 * l.u, by = 50)\n\t        p.gamma.k.u[[i]] <- sort(rdirichlet(1, c.u), decreasing = TRUE)\n        }\n    }\n\n    p.gamma.k.j.m <- matrix(rep(NA, N * nfeatures), nrow = nfeatures, ncol = N)\n    p.gamma.k.j.u <- matrix(rep(NA, N * nfeatures), nrow = nfeatures, ncol = N)\n\n    p.gamma.j.m <- matrix(rep(NA, N), nrow = N, ncol = 1)\n    p.gamma.j.u <- matrix(rep(NA, N), nrow = N, ncol = 1)\n\n    delta <- 1\n    count <- 1\n    warn.once <- 1\n\n    ## The EM Algorithm presented in the paper starts here:\n    while (abs(delta) >= tol) {\n\n        if((count %% 100) == 0) {\n            cat("Iteration number", count, "\\n")\n            cat("Maximum difference in log-likelihood =", round(delta, 4), "\\n")\n        }\n\n        ## Old Paramters\n        p.old <- c(p.m, p.u, unlist(p.gamma.k.m), unlist(p.gamma.k.u))\n\n        for (i in 1:nfeatures) {\n            temp.01 <- temp.02 <- gamma.j.k[, i]\n            temp.1 <- unique(na.omit(temp.01))\n            temp.2 <- p.gamma.k.m[[i]]\n            temp.3 <- p.gamma.k.u[[i]]\n            for (j in 1:length(temp.1)) {\n                temp.01[temp.01 == temp.1[j]] <- temp.2[j]\n                temp.02[temp.02 == temp.1[j]] <- temp.3[j]\n            }\n            p.gamma.k.j.m[i, ] <- temp.01\n            p.gamma.k.j.u[i, ] <- temp.02\n        }\n\n        sumlog <- function(x) { sum(log(x), na.rm = T) }\n\n        p.gamma.j.m <- as.matrix((apply(p.gamma.k.j.m, 2, sumlog)))\n        p.gamma.j.m <- exp(p.gamma.j.m)\n\n        p.gamma.j.u <- as.matrix((apply(p.gamma.k.j.u, 2, sumlog)))\n        p.gamma.j.u <- exp(p.gamma.j.u)\n\n        ## ------\n        ## E-Step:\n        ## ------\n        log.prod <- log(p.gamma.j.m) + log(p.m)\n\n        logxpy <- function(lx,ly) {\n            temp <- cbind(lx, ly)\n            apply(temp, 1, max) + log1p(exp(-abs(lx-ly)))\n        }\n\n        log.sum <- logxpy(log(p.gamma.j.m) + log(p.m), log(p.gamma.j.u) + log(p.u))\n        zeta.j <- exp(log.prod - log.sum)\n        \n        ## --------\n        ## M-step :\n        ## --------\n        num.prod <- exp(log(n.j) + log(zeta.j))\n        l.p.m <- log(sum(num.prod) + mu - 1) - log(psi - mu + sum(n.j))\n        p.m <- exp(l.p.m)\n        p.u <- 1 - p.m\n\n        for (i in 1:nfeatures) {\n            temp.01 <- temp.02 <- gamma.j.k[, i]\n            temp.1 <- unique(na.omit(temp.01))\n            \n            temp.2 <- rep(alpha1, (length(temp.1) - 1))\n            temp.3 <- c(alpha0, temp.2)\n\n            temp.2g <- rep(alpha0g, (length(temp.1) - 1))\n            temp.3g <- c(temp.2g, alpha1g)\n            for (l in 1:length(temp.1)) {\n                p.gamma.k.m[[i]][l] <- (\n                    sum(num.prod * ifelse(is.na(gamma.j.k[, i]), 0, 1) * ifelse(is.na(gamma.j.k[, i]), 0, ifelse(gamma.j.k[, i] == temp.1[l], 1, 0))) +\n                    address.field[i] * (temp.3[l] - 1) + gender.field[i] * (temp.3g[l] - 1)\n                ) / (\n                    sum(num.prod * ifelse(is.na(gamma.j.k[, i]), 0, 1)) + (address.field[i] * sum(temp.3 - 1)) + gender.field[i] * sum(temp.3g - 1)\n                )\n                p.gamma.k.u[[i]][l] <- (\n                    sum((n.j - num.prod) * ifelse(is.na(gamma.j.k[, i]), 0, 1) * ifelse(is.na(gamma.j.k[, i]), 0, ifelse(gamma.j.k[, i] == temp.1[l], 1, 0)))\n                ) / (\n                    sum((n.j - num.prod) * ifelse(is.na(gamma.j.k[, i]), 0, 1))\n                )\n            }\n        }\n\n        for (i in 1:nfeatures) {\n            p.gamma.k.m[[i]] <- sort(p.gamma.k.m[[i]], decreasing = F)\n            p.gamma.k.u[[i]] <- sort(p.gamma.k.u[[i]], decreasing = T)\n        }\n\n        ## Updated parameters:\n        p.new <- c(p.m, p.u, unlist(p.gamma.k.m), unlist(p.gamma.k.u))\n\t\t\n\t\tif(p.m < 1e-13 & warn.once == 1) {\n\t\t\twarning("The overall probability of finding a match is too small. Increasing the amount of overlap between the datasets might help, see e.g., clusterMatch()")\n\t\t\twarn.once <- 0\n\t\t}\n\t\t\n        ## Max difference between the updated and old parameters:\n        delta <- max(abs(p.new - p.old))\n        count <- count + 1\n\n        if(count > iter.max) {\n            warning("The EM algorithm has run for the specified number of iterations but has not converged yet.")\n            break\n        }\n    }\n\n    weights <- log(p.gamma.j.m) - log(p.gamma.j.u)\n    \n    p.gamma.j.m <- p.gamma.j.m/sum(p.gamma.j.m)\n    p.gamma.j.u <- p.gamma.j.u/sum(p.gamma.j.u)\n\n    data.w <- cbind(patterns, weights, p.gamma.j.m, p.gamma.j.u)\n    nc <- ncol(data.w)\n    colnames(data.w)[nc-2] <- "weights"\n    colnames(data.w)[nc-1] <- "p.gamma.j.m"\n    colnames(data.w)[nc] <- "p.gamma.j.u"\n\n    inf <- which(data.w == Inf, arr.ind = T)\n    ninf <- which(data.w == -Inf, arr.ind = T)\n    \n    data.w[inf[, 1], unique(inf[, 2])] <- 150\n    data.w[ninf[, 1], unique(ninf[, 2])] <- -150\n    \n    if(!is.null(varnames)){\n        output <- list("zeta.j"= zeta.j,"p.m"= p.m, "p.u" = p.u, "p.gamma.k.m" = p.gamma.k.m, "p.gamma.k.u" = p.gamma.k.u,\n                       "p.gamma.j.m" = p.gamma.j.m, "p.gamma.j.u" = p.gamma.j.u, "patterns.w" = data.w, "iter.converge" = count,\n                       "nobs.a" = nobs.a, "nobs.b" = nobs.b, "varnames" = varnames)\n    }else{\n        output <- list("zeta.j"= zeta.j,"p.m"= p.m, "p.u" = p.u, "p.gamma.k.m" = p.gamma.k.m, "p.gamma.k.u" = p.gamma.k.u,\n                       "p.gamma.j.m" = p.gamma.j.m, "p.gamma.j.u" = p.gamma.j.u, "patterns.w" = data.w, "iter.converge" = count,\n                       "nobs.a" = nobs.a, "nobs.b" = nobs.b, "varnames" = paste0("gamma.", 1:nfeatures))\n    }\n\n    class(output) <- c("fastLink", "fastLink.EM")\n    \n    return(output)\n}\n\n#\' emlinkRS\n#\'\n#\' Calculates Felligi-Sunter weights and posterior zeta probabilities\n#\' for matching patterns observed in a larger population that are\n#\' not present in a sub-sample used to estimate the EM.\n#\'\n#\' @usage emlinkRS(patterns.out, em.out, nobs.a, nobs.b)\n#\'\n#\' @param patterns.out The output from `tableCounts()` or `emlinkMARmov()` (run on full dataset),\n#\' containing all observed matching patterns in the full sample and the number of times that pattern\n#\' is observed.\n#\' @param em.out The output from `emlinkMARmov()`, an EM object estimated\n#\' on a smaller random sample to apply to counts from a larger sample\n#\' @param nobs.a Total number of observations in dataset A\n#\' @param nobs.b Total number of observations in dataset B\n#\'\n#\' @return \\code{emlinkMARmov} returns a list with the following components:\n#\' \\item{zeta.j}{The posterior match probabilities for each unique pattern.}\n#\' \\item{p.m}{The posterior probability of a pair matching.}\n#\' \\item{p.u}{The posterior probability of a pair not matching.}\n#\' \\item{p.gamma.k.m}{The posterior of the matching probability for a specific matching field.}\n#\' \\item{p.gamma.k.u}{The posterior of the non-matching probability for a specific matching field.}\n#\' \\item{p.gamma.j.m}{The posterior probability that a pair is in the matched set given a particular agreement pattern.}\n#\' \\item{p.gamma.j.u}{The posterior probability that a pair is in the unmatched set given a particular agreement pattern.}\n#\' \\item{patterns.w}{Counts of the agreement patterns observed, along with the Felligi-Sunter Weights.}\n#\' \\item{iter.converge}{The number of iterations it took the EM algorithm to converge.}\n#\' \\item{nobs.a}{The number of observations in dataset A.}\n#\' \\item{nobs.b}{The number of observations in dataset B.}\n#\'\n#\' @author Ted Enamorado <ted.enamorado@gmail.com> and Ben Fifield <benfifield@gmail.com>\n#\'\n#\' @examples\n#\' \\dontrun{\n#\' ## -------------\n#\' ## Run on subset\n#\' ## -------------\n#\' dfA.s <- dfA[sample(1:nrow(dfA), 50),]; dfB.s <- dfB[sample(1:nrow(dfB), 50),]\n#\' \n#\' ## Calculate gammas\n#\' g1 <- gammaCKpar(dfA.s$firstname, dfB.s$firstname)\n#\' g2 <- gammaCKpar(dfA.s$middlename, dfB.s$middlename)\n#\' g3 <- gammaCKpar(dfA.s$lastname, dfB.s$lastname)\n#\' g4 <- gammaKpar(dfA.s$birthyear, dfB.s$birthyear)\n#\'\n#\' ## Run tableCounts\n#\' tc <- tableCounts(list(g1, g2, g3, g4), nobs.a = nrow(dfA.s), nobs.b = nrow(dfB.s))\n#\'\n#\' ## Run EM\n#\' em <- emlinkMAR(tc, nobs.a = nrow(dfA.s), nobs.b = nrow(dfB.s))\n#\'\n#\' ## ------------------\n#\' ## Apply to full data\n#\' ## ------------------\n#\'\n#\' ## Calculate gammas\n#\' g1 <- gammaCKpar(dfA$firstname, dfB$firstname)\n#\' g2 <- gammaCKpar(dfA$middlename, dfB$middlename)\n#\' g3 <- gammaCKpar(dfA$lastname, dfB$lastname)\n#\' g4 <- gammaKpar(dfA$birthyear, dfB$birthyear)\n#\'\n#\' ## Run tableCounts\n#\' tc <- tableCounts(list(g1, g2, g3, g4), nobs.a = nrow(dfA), nobs.b = nrow(dfB))\n#\'\n#\' em.full <- emlinkRS(tc, em, nrow(dfA), nrow(dfB)\n#\' }\n#\'\n#\' @export\nemlinkRS <- function(patterns.out, em.out, nobs.a, nobs.b){\n    if("tableCounts" %in% class(patterns.out)){\n        patterns.out <- patterns.out\n    }else if("fastLink.EM" %in% class(patterns.out)){\n        patterns.out <- patterns.out$patterns.w\n        inds <- grep("gamma.[[:digit:]]", colnames(patterns.out))\n        inds <- c(inds, max(inds)+1)\n        patterns.out <- patterns.out[,inds]\n    }else{\n        stop("Your `patterns.out` object is not a valid tableCounts or emlinkMARmov object.")\n    }\n    if(!("fastLink.EM" %in% class(em.out))){\n        stop("Your `em.out` object is not a valid emlinkMARmov object.")\n    }\n    options(digits = 16)\n\n    ## Edge case\n    if(is.null(nrow(patterns.out))){\n        patterns.out <- as.data.frame(t(as.matrix(patterns.out)))\n    }\n    nfeatures <- ncol(patterns.out) - 1\n    gamma.j.k <- as.matrix(patterns.out[, 1:nfeatures])\n    N <- nrow(gamma.j.k)\n    \n    p.m <- em.out$p.m\n    p.u <- 1 - p.m\n\n    p.gamma.k.m <- em.out$p.gamma.k.m\n    p.gamma.k.u <- em.out$p.gamma.k.u\n\n    p.gamma.k.j.m <- matrix(rep(NA, N * nfeatures), nrow = nfeatures, \n                            ncol = N)\n    p.gamma.k.j.u <- matrix(rep(NA, N * nfeatures), nrow = nfeatures, \n                            ncol = N)\n    p.gamma.j.m <- matrix(rep(NA, N), nrow = N, ncol = 1)\n    p.gamma.j.u <- matrix(rep(NA, N), nrow = N, ncol = 1)\n\n    for (i in 1:nfeatures) {\n        temp.01 <- temp.02 <- gamma.j.k[, i]\n        temp.1 <- unique(na.omit(temp.01))\n        temp.2 <- p.gamma.k.m[[i]]\n        temp.3 <- p.gamma.k.u[[i]]\n        for (j in 1:length(temp.1)) {\n            temp.01[temp.01 == temp.1[j]] <- temp.2[j]\n            temp.02[temp.02 == temp.1[j]] <- temp.3[j]\n        }\n        p.gamma.k.j.m[i, ] <- temp.01\n        p.gamma.k.j.u[i, ] <- temp.02\n    }\n    \n    sumlog <- function(x) {\n        sum(log(x), na.rm = T)\n    }\n    \n    p.gamma.j.m <- as.matrix((apply(p.gamma.k.j.m, 2, sumlog)))\n    p.gamma.j.m <- exp(p.gamma.j.m)\n    p.gamma.j.u <- as.matrix((apply(p.gamma.k.j.u, 2, sumlog)))\n    p.gamma.j.u <- exp(p.gamma.j.u)\n    log.prod <- log(p.gamma.j.m) + log(p.m)\n    logxpy <- function(lx, ly) {\n        temp <- cbind(lx, ly)\n        apply(temp, 1, max) + log1p(exp(-abs(lx - ly)))\n    }\n    log.sum <- logxpy(log(p.gamma.j.m) + log(p.m), log(p.gamma.j.u) + \n                                                   log(p.u))\n    zeta.j <- exp(log.prod - log.sum)\n\n    weights <- log(p.gamma.j.m) - log(p.gamma.j.u)\n    \n    ## Renormalize\n    p.gamma.j.m <- p.gamma.j.m/sum(p.gamma.j.m)\n    p.gamma.j.u <- p.gamma.j.u/sum(p.gamma.j.u)\n    \n    data.w <- cbind(patterns.out, weights, p.gamma.j.m, p.gamma.j.u)\n    nc <- ncol(data.w)\n    colnames(data.w)[nc - 3] <- "counts"\n    colnames(data.w)[nc - 2] <- "weights"\n    colnames(data.w)[nc - 1] <- "p.gamma.j.m"  \n    colnames(data.w)[nc] <- "p.gamma.j.u"\n    \n    inf <- which(data.w == Inf, arr.ind = T)\n    ninf <- which(data.w == -Inf, arr.ind = T)\n    \n    data.w[inf[, 1], unique(inf[, 2])] <- 150\n    data.w[ninf[, 1], unique(ninf[, 2])] <- -150\n\t\t\n    output <- list("zeta.j" = zeta.j, "p.m" = em.out$p.m, "p.u" = em.out$p.u, "p.gamma.k.m" = em.out$p.gamma.k.m, "p.gamma.k.u" = em.out$p.gamma.k.u,\n                   "p.gamma.j.m" = p.gamma.j.m, "p.gamma.j.u" = p.gamma.j.u, "patterns.w" = data.w, "iter.converge" = em.out$iter.converge,\n                   "nobs.a" = nobs.a, "nobs.b" = nobs.b, "varnames" = em.out$varnames)\n    class(output) <- c("fastLink", "fastLink.EM")\n    \n    return(output)\n}\n'