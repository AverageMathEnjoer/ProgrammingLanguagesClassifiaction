b'using System;\nusing System.Diagnostics;\nusing System.Text;\n\nusing Bitmask = System.UInt64;\nusing u32 = System.UInt32;\n\nnamespace CS_SQLite3\n{\n  public partial class CSSQLite\n  {\n    /*\n    ** 2008 August 16\n    **\n    ** The author disclaims copyright to this source code.  In place of\n    ** a legal notice, here is a blessing:\n    **\n    **    May you do good and not evil.\n    **    May you find forgiveness for yourself and forgive others.\n    **    May you share freely, never taking more than you give.\n    **\n    *************************************************************************\n    ** This file contains routines used for walking the parser tree for\n    ** an SQL statement.\n    **\n    ** $Id: walker.c,v 1.7 2009/06/15 23:15:59 drh Exp $\n    **\n    *************************************************************************\n    **  Included in SQLite3 port to C#-SQLite;  2008 Noah B Hart\n    **  C#-SQLite is an independent reimplementation of the SQLite software library\n    **\n    **  $Header$\n    *************************************************************************\n    */\n    //#include "sqliteInt.h"\n    //#include <stdlib.h>\n    //#include <string.h>\n\n\n    /*\n    ** Walk an expression tree.  Invoke the callback once for each node\n    ** of the expression, while decending.  (In other words, the callback\n    ** is invoked before visiting children.)\n    **\n    ** The return value from the callback should be one of the WRC_*\n    ** constants to specify how to proceed with the walk.\n    **\n    **    WRC_Continue      Continue descending down the tree.\n    **\n    **    WRC_Prune         Do not descend into child nodes.  But allow\n    **                      the walk to continue with sibling nodes.\n    **\n    **    WRC_Abort         Do no more callbacks.  Unwind the stack and\n    **                      return the top-level walk call.\n    **\n    ** The return value from this routine is WRC_Abort to abandon the tree walk\n    ** and WRC_Continue to continue.\n    */\n    static int sqlite3WalkExpr( Walker pWalker, ref Expr pExpr )\n    {\n      int rc;\n      if ( pExpr == null ) return WRC_Continue;\n      testcase( ExprHasProperty( pExpr, EP_TokenOnly ) );\n      testcase( ExprHasProperty( pExpr, EP_Reduced ) );\n      rc = pWalker.xExprCallback( pWalker, ref pExpr );\n      if ( rc == WRC_Continue\n      && !ExprHasAnyProperty( pExpr, EP_TokenOnly ) )\n      {\n        if ( sqlite3WalkExpr( pWalker, ref pExpr.pLeft ) != 0 ) return WRC_Abort;\n        if ( sqlite3WalkExpr( pWalker, ref pExpr.pRight ) != 0 ) return WRC_Abort;\n        if ( ExprHasProperty( pExpr, EP_xIsSelect ) )\n        {\n          if ( sqlite3WalkSelect( pWalker, pExpr.x.pSelect ) != 0 ) return WRC_Abort;\n        }\n        else\n        {\n          if ( sqlite3WalkExprList( pWalker, pExpr.x.pList ) != 0 ) return WRC_Abort;\n        }\n      }\n      return rc & WRC_Abort;\n    }\n\n    /*\n    ** Call sqlite3WalkExpr() for every expression in list p or until\n    ** an abort request is seen.\n    */\n    static int sqlite3WalkExprList( Walker pWalker, ExprList p )\n    {\n      int i;\n      ExprList_item pItem;\n      if ( p != null )\n      {\n        for ( i = p.nExpr ; i > 0 ; i-- )\n        {//, pItem++){\n          pItem = p.a[p.nExpr - i];\n          if ( sqlite3WalkExpr( pWalker, ref pItem.pExpr ) != 0 ) return WRC_Abort;\n        }\n      }\n      return WRC_Continue;\n    }\n\n    /*\n    ** Walk all expressions associated with SELECT statement p.  Do\n    ** not invoke the SELECT callback on p, but do (of course) invoke\n    ** any expr callbacks and SELECT callbacks that come from subqueries.\n    ** Return WRC_Abort or WRC_Continue.\n    */\n    static int sqlite3WalkSelectExpr( Walker pWalker, Select p )\n    {\n      if ( sqlite3WalkExprList( pWalker, p.pEList ) != 0 ) return WRC_Abort;\n      if ( sqlite3WalkExpr( pWalker, ref p.pWhere ) != 0 ) return WRC_Abort;\n      if ( sqlite3WalkExprList( pWalker, p.pGroupBy ) != 0 ) return WRC_Abort;\n      if ( sqlite3WalkExpr( pWalker, ref p.pHaving ) != 0 ) return WRC_Abort;\n      if ( sqlite3WalkExprList( pWalker, p.pOrderBy ) != 0 ) return WRC_Abort;\n      if ( sqlite3WalkExpr( pWalker, ref p.pLimit ) != 0 ) return WRC_Abort;\n      if ( sqlite3WalkExpr( pWalker, ref p.pOffset ) != 0 ) return WRC_Abort;\n      return WRC_Continue;\n    }\n\n    /*\n    ** Walk the parse trees associated with all subqueries in the\n    ** FROM clause of SELECT statement p.  Do not invoke the select\n    ** callback on p, but do invoke it on each FROM clause subquery\n    ** and on any subqueries further down in the tree.  Return\n    ** WRC_Abort or WRC_Continue;\n    */\n    static int sqlite3WalkSelectFrom( Walker pWalker, Select p )\n    {\n      SrcList pSrc;\n      int i;\n      SrcList_item pItem;\n\n      pSrc = p.pSrc;\n      if ( ALWAYS( pSrc ) )\n      {\n        for ( i = pSrc.nSrc ; i > 0 ; i-- )// pItem++ )\n        {\n          pItem = pSrc.a[pSrc.nSrc - i];\n          if ( sqlite3WalkSelect( pWalker, pItem.pSelect ) != 0 )\n          {\n            return WRC_Abort;\n          }\n        }\n      }\n      return WRC_Continue;\n    }\n\n    /*\n    ** Call sqlite3WalkExpr() for every expression in Select statement p.\n    ** Invoke sqlite3WalkSelect() for subqueries in the FROM clause and\n    ** on the compound select chain, p.pPrior.\n    **\n    ** Return WRC_Continue under normal conditions.  Return WRC_Abort if\n    ** there is an abort request.\n    **\n    ** If the Walker does not have an xSelectCallback() then this routine\n    ** is a no-op returning WRC_Continue.\n    */\n    static int sqlite3WalkSelect( Walker pWalker, Select p )\n    {\n      int rc;\n      if ( p == null || pWalker.xSelectCallback == null ) return WRC_Continue;\n      rc = WRC_Continue;\n      while ( p != null )\n      {\n        rc = pWalker.xSelectCallback( pWalker, p );\n        if ( rc != 0 ) break;\n        if ( sqlite3WalkSelectExpr( pWalker, p ) != 0 ) return WRC_Abort;\n        if ( sqlite3WalkSelectFrom( pWalker, p ) != 0 ) return WRC_Abort;\n        p = p.pPrior;\n      }\n      return rc & WRC_Abort;\n    }\n  }\n}\n'