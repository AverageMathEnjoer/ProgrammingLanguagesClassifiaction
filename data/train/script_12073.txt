b'#include <bits/stdc++.h>\nusing namespace std;\n#define gc getchar_unlocked\n#define fo(i,n) for(i=0;i<n;i++)\n#define Fo(i,k,n) for(i=k;i<n;i++)\n#define ll long long\n#define si(x)\tscanf("%d",&x)\n#define sl(x)\tscanf("%I64d",&x)\n#define ss(s)\tscanf("%s",s)\n#define pb push_back\n#define mp make_pair\n#define F first\n#define S second\n#define clr(x) memset(x, 0, sizeof(x))\n#define tr(it, a) for(auto it = a.begin(); it != a.end(); it++)\n#define PI 3.1415926535897932384626\ntypedef pair<int, int>\tpii;\ntypedef pair<ll, ll>\tpll;\ntypedef vector<int>\t\tvi;\ntypedef vector<ll>\t\tvl;\ntypedef vector<pii>\t\tvpii;\ntypedef vector<pll>\t\tvpll;\ntypedef vector<vi>\t\tvvi;\ntypedef vector<vl>\t\tvvl;\nconst int mod = 1000000007;\nconst int N = 2e5;\nvi g[N];\nint a[N];\n//http://codeforces.com/problemset/problem/237/E\n\n// min-cost max-flow ... SOURCE: Unknown\n// Not tested for multi edges, negative edge weight\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef long long L;\ntypedef vector<L> VL;\ntypedef vector<VL> VVL;\ntypedef pair<int, int> PII;\ntypedef vector<PII> VPII;\n\nconst L INF = numeric_limits<L>::max() / 4;\n\nstruct MinCostMaxFlow {\n  int N;\n  VVL cap, flow, cost;\n  VI found;\n  VL dist, pi, width;\n  VPII dad;\n\n  MinCostMaxFlow(int N) : \n    N(N), cap(N, VL(N)), flow(N, VL(N)), cost(N, VL(N)), \n    found(N), dist(N), pi(N), width(N), dad(N) {}\n  \n  // 0 based indexing\n  void AddEdge(int from, int to, L cap, L cost) {\n    this->cap[from][to] = cap;\n    this->cost[from][to] = cost;\n  }\n  \n  void Relax(int s, int k, L cap, L cost, int dir) {\n    L val = dist[s] + pi[s] - pi[k] + cost;\n    if (cap && val < dist[k]) {\n      dist[k] = val;\n      dad[k] = make_pair(s, dir);\n      width[k] = min(cap, width[s]);\n    }\n  }\n\n  L Dijkstra(int s, int t) {\n    fill(found.begin(), found.end(), false);\n    fill(dist.begin(), dist.end(), INF);\n    fill(width.begin(), width.end(), 0);\n    dist[s] = 0;\n    width[s] = INF;\n    \n    while (s != -1) {\n      int best = -1;\n      found[s] = true;\n      for (int k = 0; k < N; k++) {\n        if (found[k]) continue;\n        Relax(s, k, cap[s][k] - flow[s][k], cost[s][k], 1);\n        Relax(s, k, flow[k][s], -cost[k][s], -1);\n        if (best == -1 || dist[k] < dist[best]) best = k;\n      }\n      s = best;\n    }\n\n    for (int k = 0; k < N; k++)\n      pi[k] = min(pi[k] + dist[k], INF);\n    return width[t];\n  }\n\n  pair<L, L> GetMaxFlow(int s, int t) {\n    L totflow = 0, totcost = 0;\n    while (L amt = Dijkstra(s, t)) {\n      totflow += amt;\n      for (int x = t; x != s; x = dad[x].first) {\n        if (dad[x].second == 1) {\n          flow[dad[x].first][x] += amt;\n          totcost += amt * cost[dad[x].first][x];\n        } else {\n          flow[x][dad[x].first] -= amt;\n          totcost -= amt * cost[x][dad[x].first];\n        }\n      }\n    }\n    return make_pair(totflow, totcost);\n  }\n};\n// END\nint cnt[28];\nint main()\n{\n\tint i,n,j;\n\tstring t;\n\tcin>>t;\n\tint lenT = t.length();\n\tclr(cnt);\n\tfo(i, lenT)cnt[t[i]-\'a\']++;\n\tcin>>n;\n\tMinCostMaxFlow A(n+28);\n\tint source = n+26 , sink = n+27;\n\tfo(i, 26) A.AddEdge(n+i, sink, cnt[i], 0);\n\tfo(i, n){\n\t\tstring s;\n\t\tcin>>s;\n\t\tint v;\n\t\tcin>>v;\n\t\tclr(cnt);\n\t\tfo(j, s.size()) cnt[s[j]-\'a\']++;\n\t\tfo(j, 26) \n\t\t\tA.AddEdge(i, n+j, cnt[j], 0);\n\t\tA.AddEdge(source, i, v, i+1);\n\t}\n\tpair<ll, ll> res = A.GetMaxFlow(source, sink);\n\tif (res.F != lenT)cout<<-1;\n\telse cout<<res.S<<endl;\n\n\t\n\treturn 0;\n} \n\n\n'