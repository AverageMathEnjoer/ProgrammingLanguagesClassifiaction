b'{-# LANGUAGE CPP #-}\n{-# LANGUAGE GADTs #-}\n{-# LANGUAGE TupleSections #-}\n\n-- |\n-- Module      : Hoodle.View.Coordinate\n-- Copyright   : (c) 2012-2014 Ian-Woo Kim\n--\n-- License     : BSD3\n-- Maintainer  : Ian-Woo Kim <ianwookim@gmail.com>\n-- Stability   : experimental\n-- Portability : GHC\nmodule Hoodle.View.Coordinate where\n\nimport Control.Lens (view)\nimport Data.Foldable (toList)\nimport Data.Hoodle.BBox\n  ( BBox (..),\n    IntersectBBox (Intersect),\n    ULMaybe (Bottom, Middle),\n  )\nimport Data.Hoodle.Generic\n  ( gdimension,\n    gpages,\n  )\nimport Data.Hoodle.Simple (Dimension (..))\nimport qualified Data.IntMap as M\nimport Data.Maybe (catMaybes, isJust)\nimport qualified Graphics.UI.Gtk as Gtk\nimport Hoodle.Device\n  ( PointerCoord (..),\n    PointerType (Core, Eraser, Stylus, Touch),\n  )\nimport Hoodle.Type.Alias (EditMode, Hoodle)\nimport Hoodle.Type.Canvas\n  ( CanvasInfo,\n    currentPageNum,\n    drawArea,\n    pageArrangement,\n    viewInfo,\n  )\nimport Hoodle.Type.PageArrangement\n  ( CanvasCoordinate (..),\n    CanvasDimension (..),\n    CanvasOrigin (..),\n    DesktopCoordinate (..),\n    DesktopDimension (..),\n    PageArrangement (..),\n    PageCoordinate (..),\n    PageDimension (..),\n    PageNum (..),\n    PageOrigin (..),\n    ScreenCoordinate (..),\n    ScreenDimension (..),\n    ViewPortBBox (..),\n    canvasDimension,\n  )\n\n-- | data structure for transformation among screen, canvas, desktop and page coordinates\ndata CanvasGeometry = CanvasGeometry\n  { screenDim :: ScreenDimension,\n    canvasDim :: CanvasDimension,\n    desktopDim :: DesktopDimension,\n    -- | in desktop coordinate\n    canvasViewPort :: ViewPortBBox,\n    screen2Canvas :: ScreenCoordinate -> CanvasCoordinate,\n    canvas2Screen :: CanvasCoordinate -> ScreenCoordinate,\n    canvas2Desktop :: CanvasCoordinate -> DesktopCoordinate,\n    desktop2Canvas :: DesktopCoordinate -> CanvasCoordinate,\n    desktop2Page :: DesktopCoordinate -> Maybe (PageNum, PageCoordinate),\n    page2Desktop :: (PageNum, PageCoordinate) -> DesktopCoordinate\n  }\n\n-- | make a canvas geometry data structure from current status\nmakeCanvasGeometry ::\n  PageNum ->\n  PageArrangement vm ->\n  Gtk.DrawingArea ->\n  IO CanvasGeometry\nmakeCanvasGeometry cpn arr canvas = do\n  Just win <- Gtk.widgetGetWindow canvas\n  let cdim@(CanvasDimension (Dim w\' h\')) = view canvasDimension arr\n  screen <- Gtk.widgetGetScreen canvas\n  (ws, hs) <-\n    (,) <$> (fromIntegral <$> Gtk.screenGetWidth screen)\n      <*> (fromIntegral <$> Gtk.screenGetHeight screen)\n  (x0, y0) <- ((,) <$> fromIntegral . fst <*> fromIntegral . snd) <$> Gtk.drawWindowGetOrigin win\n  let corig = CanvasOrigin (x0, y0)\n      (deskdim, cvsvbbox, p2d, d2p) =\n        case arr of\n          SingleArrangement _ pdim vbbox ->\n            ( DesktopDimension . unPageDimension $ pdim,\n              vbbox,\n              DeskCoord . unPageCoord . snd,\n              \\(DeskCoord coord) -> Just (cpn, PageCoord coord)\n            )\n          ContinuousArrangement _ ddim pfunc vbbox ->\n            (ddim, vbbox, makePage2Desktop pfunc, makeDesktop2Page pfunc)\n  let s2c = xformScreen2Canvas corig\n      c2s = xformCanvas2Screen corig\n      c2d = xformCanvas2Desk cdim cvsvbbox\n      d2c = xformDesk2Canvas cdim cvsvbbox\n  return $\n    CanvasGeometry\n      (ScreenDimension (Dim ws hs))\n      (CanvasDimension (Dim w\' h\'))\n      deskdim\n      cvsvbbox\n      s2c\n      c2s\n      c2d\n      d2c\n      d2p\n      p2d\n\n-- |\nmakePage2Desktop ::\n  (PageNum -> Maybe (PageOrigin, PageDimension)) ->\n  (PageNum, PageCoordinate) ->\n  DesktopCoordinate\nmakePage2Desktop pfunc (pnum, PageCoord (x, y)) =\n  maybe\n    (DeskCoord (-100, -100)) -- temporary\n    (\\(PageOrigin (x0, y0), _) -> DeskCoord (x0 + x, y0 + y))\n    (pfunc pnum)\n\n-- |\nmakeDesktop2Page ::\n  (PageNum -> Maybe (PageOrigin, PageDimension)) ->\n  DesktopCoordinate ->\n  Maybe (PageNum, PageCoordinate)\nmakeDesktop2Page pfunc (DeskCoord (x, y)) =\n  if null matched\n    then Nothing\n    else\n      let (pagenum, (PageOrigin (x0, y0), _)) = head matched\n       in Just (pagenum, PageCoord (x - x0, y - y0))\n  where\n    condition (_, (PageOrigin (x0, y0), PageDimension (Dim w h))) =\n      x >= x0 && x < x0 + w && y >= y0 && y < y0 + h\n    matched =\n      filter condition\n        . catMaybes\n        . takeWhile isJust\n        . map ((\\x\' -> fmap (x\',) (pfunc x\')) . PageNum)\n        $ [0 ..]\n\n-- |\nxformScreen2Canvas :: CanvasOrigin -> ScreenCoordinate -> CanvasCoordinate\nxformScreen2Canvas (CanvasOrigin (x0, y0)) (ScrCoord (sx, sy)) = CvsCoord (sx - x0, sy - y0)\n\n-- |\nxformCanvas2Screen :: CanvasOrigin -> CanvasCoordinate -> ScreenCoordinate\nxformCanvas2Screen (CanvasOrigin (x0, y0)) (CvsCoord (cx, cy)) = ScrCoord (cx + x0, cy + y0)\n\n-- |\nxformCanvas2Desk ::\n  CanvasDimension ->\n  ViewPortBBox ->\n  CanvasCoordinate ->\n  DesktopCoordinate\nxformCanvas2Desk\n  (CanvasDimension (Dim w h))\n  (ViewPortBBox (BBox (x1, y1) (x2, y2)))\n  (CvsCoord (cx, cy)) = DeskCoord (cx * (x2 - x1) / w + x1, cy * (y2 - y1) / h + y1)\n\n-- |\nxformDesk2Canvas ::\n  CanvasDimension ->\n  ViewPortBBox ->\n  DesktopCoordinate ->\n  CanvasCoordinate\nxformDesk2Canvas\n  (CanvasDimension (Dim w h))\n  (ViewPortBBox (BBox (x1, y1) (x2, y2)))\n  (DeskCoord (dx, dy)) = CvsCoord ((dx - x1) * w / (x2 - x1), (dy - y1) * h / (y2 - y1))\n\n-- |\nscreen2Desktop :: CanvasGeometry -> ScreenCoordinate -> DesktopCoordinate\nscreen2Desktop geometry = canvas2Desktop geometry . screen2Canvas geometry\n\n-- |\ndesktop2Screen :: CanvasGeometry -> DesktopCoordinate -> ScreenCoordinate\ndesktop2Screen geometry = canvas2Screen geometry . desktop2Canvas geometry\n\n-- |\ncore2Desktop :: CanvasGeometry -> (Double, Double) -> DesktopCoordinate\ncore2Desktop geometry = canvas2Desktop geometry . CvsCoord\n\n-- |\nwacom2Desktop :: CanvasGeometry -> (Double, Double) -> DesktopCoordinate\nwacom2Desktop geometry (x, y) =\n  let Dim w h = unScreenDimension (screenDim geometry)\n   in screen2Desktop geometry . ScrCoord $ (w * x, h * y)\n\ntouch2Desktop :: CanvasGeometry -> (Double, Double) -> DesktopCoordinate\ntouch2Desktop = wacom2Desktop\n\n-- |\nwacom2Canvas :: CanvasGeometry -> (Double, Double) -> CanvasCoordinate\nwacom2Canvas geometry (x, y) =\n  let Dim w h = unScreenDimension (screenDim geometry)\n   in screen2Canvas geometry . ScrCoord $ (w * x, h * y)\n\n-- |\ndevice2Desktop :: CanvasGeometry -> PointerCoord -> DesktopCoordinate\ndevice2Desktop geometry (PointerCoord typ x y _z) =\n  case typ of\n    Core -> core2Desktop geometry (x, y)\n    Stylus -> wacom2Desktop geometry (x, y)\n    Eraser -> wacom2Desktop geometry (x, y)\n    Touch -> touch2Desktop geometry (x, y)\ndevice2Desktop _geometry NoPointerCoord = error "NoPointerCoordinate device2Desktop"\n\n-- |\ngetPagesInRange :: CanvasGeometry -> ViewPortBBox -> Hoodle EditMode -> [PageNum]\ngetPagesInRange geometry (ViewPortBBox bbox) hdl =\n  let ivbbox = Intersect (Middle bbox)\n      pagemap = view gpages hdl\n      pnums = map PageNum [0 .. (length . toList $ pagemap) - 1]\n      pgcheck n pg =\n        let Dim w h = view gdimension pg\n            DeskCoord ul = page2Desktop geometry (PageNum n, PageCoord (0, 0))\n            DeskCoord lr = page2Desktop geometry (PageNum n, PageCoord (w, h))\n            inbbox = Intersect (Middle (BBox ul lr))\n            result = ivbbox `mappend` inbbox\n         in case result of\n              Intersect Bottom -> False\n              _ -> True\n      f (PageNum n) = maybe False (pgcheck n) . M.lookup n $ pagemap\n   in filter f pnums\n\n-- |\ngetPagesInViewPortRange :: CanvasGeometry -> Hoodle EditMode -> [PageNum]\ngetPagesInViewPortRange geometry hdl =\n  let vport = canvasViewPort geometry\n   in getPagesInRange geometry vport hdl\n\n-- |\ngetCvsGeomFrmCvsInfo :: CanvasInfo a -> IO CanvasGeometry\ngetCvsGeomFrmCvsInfo cinfo = do\n  let cpn = PageNum . view currentPageNum $ cinfo\n      canvas = view drawArea cinfo\n      arr = view (viewInfo . pageArrangement) cinfo\n  makeCanvasGeometry cpn arr canvas\n\n-- | Get Canvas Origin in Page Coordinate : Right is successful case,\n--   Left is unsuccessful case, then return in DesktopCoordinate\ngetCvsOriginInPage ::\n  CanvasGeometry ->\n  Either DesktopCoordinate (PageNum, PageCoordinate)\ngetCvsOriginInPage geometry =\n  let ViewPortBBox (BBox (x0, y0) (_, _)) = canvasViewPort geometry\n   in case desktop2Page geometry (DeskCoord (x0, y0)) of\n        Nothing -> Left (DeskCoord (x0, y0))\n        Just (pgn, pxy) -> Right (pgn, pxy)\n'