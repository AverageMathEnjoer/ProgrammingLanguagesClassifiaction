b"{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE StandaloneDeriving #-}\n{-# LANGUAGE UndecidableInstances #-}\n\nmodule Control.Monad.Trans.Crtn where\n\nimport Control.Monad.Reader (ReaderT (..))\nimport Control.Monad.State (StateT (..))\nimport Control.Monad.Trans.Free (FreeF (Free, Pure), FreeT (..), wrap)\n\n---------------------------\n-- general generator\n---------------------------\n\n-- | yield command functor\ndata Yld o x = Yld o x\n\ninstance Functor (Yld o) where\n  fmap f (Yld o x) = Yld o (f x)\n\n-- | Generator type is single-sided coroutine which only gives an output\n--   without getting any request.\ntype GenT o = FreeT (Yld o)\n\n-- | primitive coroutine action yielding an output\nyield :: (Monad m) => o -> GenT o m ()\nyield o = wrap (Yld o (return ()))\n\n---------------------------\n-- general consumer\n---------------------------\n\n-- | await command functor for consumer coroutine\nnewtype Awt a x = Awt (a -> x)\n\n-- |\ninstance Functor (Awt g) where\n  fmap f (Awt g) = Awt (f . g)\n\n-- | Consumer type is a single-sided coroutine which only gets an input\n--   without producing output.\ntype CnsmT a = FreeT (Awt a)\n\n-- | primitive coroutine action awaiting an input\nawait :: (Monad m) => CnsmT a m a\nawait = wrap (Awt return)\n\n----------------------------\n-- general coroutine\n----------------------------\n\n-- | command functor of general bidirectional coroutine\ndata Rqst req ans x = Rqst req (ans -> x)\n\ninstance Functor (Rqst req ans) where\n  fmap f (Rqst req g) = Rqst req (f . g)\n\n-- | general symmetric bidirectional coroutine\ntype CrtnT req ans = FreeT (Rqst req ans)\n\n-- | primitive request coroutine\nrequest :: Monad m => req -> CrtnT req ans m ans\nrequest r = wrap (Rqst r return)\n\n-------------------------------\n-- server/client model\n------------------------------\n\n-- | Server type\ntype SrvT req ans m = ReaderT req (CrtnT ans req m)\n\n-- | Coroutine type is regarded as a Client type\n--   which can be paired with Server type with opposite request\n--   and answer type.\ntype CliT req ans = CrtnT req ans\n\n-- | type for coroutine status after execution\ndata CrtnErr\n  = ServerFinished\n  | Other String\n\n-- |\nderiving instance Show CrtnErr\n\n-----------------------------\n-- communication combinator\n-------------------------------\n\n-- | connecting server and client in error monad\n(<==|) ::\n  Monad m =>\n  -- | server coroutine\n  SrvT req ans m r' ->\n  -- | client coroutine\n  CliT req ans m r ->\n  m (Either CrtnErr (SrvT req ans m r', r))\ns <==| c = do\n  y <- runFreeT c\n  case y of\n    Pure r -> return (Right (s, r))\n    Free (Rqst rq af) -> do\n      x <- runFreeT (runReaderT s rq)\n      case x of\n        Pure _r' -> return (Left ServerFinished)\n        Free (Rqst ans rf) -> ReaderT rf <==| af ans\n\n----------------------\n-- some utility\n------------------------\n\n-- | combine state and free monad with base state monad transformer\n--   with a base monad m to free monad with the base monad m\n--   Think this as fusing down the state monad\nmapStateDown ::\n  (Monad m, Functor f) =>\n  s ->\n  FreeT f (StateT s m) a ->\n  FreeT f m a\nmapStateDown st m =\n  FreeT $ do\n    x <- flip runStateT st $ runFreeT m\n    case x of\n      (Pure r, _) -> return (Pure r)\n      (Free f, st') ->\n        return . Free . fmap (mapStateDown st') $ f\n"