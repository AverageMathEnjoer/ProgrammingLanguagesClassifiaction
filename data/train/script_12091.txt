b'\xef\xbb\xbf//  Copyright 2020 Google Inc. All Rights Reserved.\n//\n//  Licensed under the Apache License, Version 2.0 (the "License");\n//  you may not use this file except in compliance with the License.\n//  You may obtain a copy of the License at\n//\n//  http://www.apache.org/licenses/LICENSE-2.0\n//\n//  Unless required by applicable law or agreed to in writing, software\n//  distributed under the License is distributed on an "AS IS" BASIS,\n//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n//  See the License for the specific language governing permissions and\n//  limitations under the License.\n\nusing System;\nusing System.IO;\nusing System.Runtime.InteropServices;\nusing System.Text;\n\nnamespace Rubeus.Utilities.Text\n{\n    /// <summary>\n    /// Class to build a hex dump from a stream of bytes.\n    /// </summary>\n    public sealed class HexDumpBuilder\n    {\n        private readonly Stream _data = null;\n        private readonly bool _can_write;\n        private readonly StringBuilder _builder = new StringBuilder();\n        private readonly bool _print_address;\n        private readonly bool _print_ascii;\n        private readonly bool _hide_repeating;\n        private readonly long _address_offset;\n        private const int CHUNK_LIMIT = 256;\n        private byte[] _last_line = null;\n        private int _repeat_count = 0;\n\n        private int GetDataLeft()\n        {\n            return (int)(_data.Length - _data.Position);\n        }\n\n        private bool IsRepeatingLine(byte[] line)\n        {\n            if (!_hide_repeating)\n                return false;\n            byte[] last_line = _last_line;\n            _last_line = line;\n            if (last_line == null)\n            {\n                return false;\n            }\n            if (last_line.Length != line.Length)\n            {\n                return false;\n            }\n\n            for (int i = 0; i < last_line.Length; ++i)\n            {\n                if (last_line[i] != line[i])\n                    return false;\n            }\n            return true;\n        }\n\n        private void AppendChunks()\n        {\n            while (GetDataLeft() >= 16)\n            {\n                long curr_pos = _data.Position + _address_offset;\n                byte[] line = new byte[16];\n                _data.Read(line, 0, 16);\n\n                if (IsRepeatingLine(line))\n                {\n                    _repeat_count++;\n                    continue;\n                }\n                else if(_repeat_count > 0)\n                {\n                    _builder.AppendLine($"-> REPEATED {_repeat_count} LINES");\n                    _repeat_count = 0;\n                }\n\n                if (_print_address)\n                {\n                    if (curr_pos < uint.MaxValue)\n                    {\n                        _builder.AppendFormat("{0:X08}: ", curr_pos);\n                    }\n                    else\n                    {\n                        _builder.AppendFormat("{0:X016}: ", curr_pos);\n                    }\n                }\n                for (int j = 0; j < 16; ++j)\n                {\n                    _builder.AppendFormat("{0:X02} ", line[j]);\n                }\n\n                if (_print_ascii)\n                {\n                    _builder.Append(" - ");\n                    for (int j = 0; j < 16; ++j)\n                    {\n                        byte b = line[j];\n                        char c = b >= 32 && b < 127 ? (char)b : \'.\';\n                        _builder.Append(c);\n                    }\n                }\n                _builder.AppendLine();\n            }\n        }\n\n        private void AppendTrailing()\n        {\n            int line_length = GetDataLeft();\n            System.Diagnostics.Debug.Assert(line_length < 16);\n            if (line_length == 0)\n            {\n                return;\n            }\n\n            if (_repeat_count > 0)\n            {\n                _builder.AppendLine($"-> REPEATED {_repeat_count} LINES");\n            }\n\n            int j = 0;\n            if (_print_address)\n            {\n                long address = _data.Position + _address_offset;\n                if (address < uint.MaxValue)\n                {\n                    _builder.AppendFormat("{0:X08}: ", address);\n                }\n                else\n                {\n                    _builder.AppendFormat("{0:X016}: ", address);\n                }\n            }\n\n            byte[] line = new byte[line_length];\n            _data.Read(line, 0, line.Length);\n\n            for (; j < line_length; ++j)\n            {\n                _builder.AppendFormat("{0:X02} ", line[j]);\n            }\n            for (; j < 16; ++j)\n            {\n                _builder.Append("   ");\n            }\n            if (_print_ascii)\n            {\n                _builder.Append(" - ");\n                for (j = 0; j < line_length; ++j)\n                {\n                    byte b = line[j];\n                    char c = b >= 32 && b < 127 ? (char)b : \'.\';\n                    _builder.Append(c);\n                }\n            }\n            _builder.AppendLine();\n        }\n\n        /// <summary>\n        /// Append an array of bytes to the hex dump.\n        /// </summary>\n        /// <param name="ba">The byte array.</param>\n        public void Append(byte[] ba)\n        {\n            if (!_can_write)\n                throw new InvalidOperationException();\n            long curr_pos = _data.Position;\n            _data.Position = _data.Length;\n            _data.Write(ba, 0, ba.Length);\n            _data.Position = curr_pos;\n            if (GetDataLeft() >= CHUNK_LIMIT)\n            {\n                AppendChunks();\n            }\n        }\n\n        /// <summary>\n        /// Complete the hex dump string.\n        /// </summary>\n        public void Complete()\n        {\n            AppendChunks();\n            AppendTrailing();\n        }\n\n        /// <summary>\n        /// Finish builder and convert to a string.\n        /// </summary>\n        /// <returns>The hex dump.</returns>\n        public override string ToString()\n        {\n            return _builder.ToString();\n        }\n\n        /// <summary>\n        /// Constructor.\n        /// </summary>\n        /// <param name="print_header">Print a header.</param>\n        /// <param name="print_address">Print the address.</param>\n        /// <param name="print_ascii">Print the ASCII text.</param>\n        /// <param name="hide_repeating">Hide repeating lines.</param>\n        /// <param name="address_offset">Offset for address printing.</param>\n        public HexDumpBuilder(bool print_header, bool print_address, bool print_ascii, bool hide_repeating, long address_offset) \n            : this(new MemoryStream(), print_header, print_address, print_ascii, hide_repeating, address_offset)\n        {\n        }\n\n        /// <summary>\n        /// Constructor.\n        /// </summary>\n        /// <param name="buffer">The safe buffer to print.</param>\n        /// <param name="length">The length to display.</param>\n        /// <param name="offset">The offset into the buffer to display.</param>\n        /// <param name="print_header">Print a header.</param>\n        /// <param name="print_address">Print the address.</param>\n        /// <param name="print_ascii">Print the ASCII text.</param>\n        /// <param name="hide_repeating">Hide repeating lines.</param>\n        public HexDumpBuilder(SafeBuffer buffer, long offset, long length, bool print_header, bool print_address, bool print_ascii, bool hide_repeating)\n            : this(new UnmanagedMemoryStream(buffer, offset, length == 0 ? (long)buffer.ByteLength : length), \n                  print_header, print_address, print_ascii, hide_repeating, buffer.DangerousGetHandle().ToInt64())\n        {\n            _address_offset = buffer.DangerousGetHandle().ToInt64();\n        }\n\n        /// <summary>\n        /// Constructor.\n        /// </summary>\n        /// <param name="buffer">The safe buffer to print.</param>\n        /// <param name="print_header">Print a header.</param>\n        /// <param name="print_address">Print the address.</param>\n        /// <param name="print_ascii">Print the ASCII text.</param>\n        /// <param name="hide_repeating">Hide repeating lines.</param>\n        public HexDumpBuilder(SafeBuffer buffer, bool print_header, bool print_address, bool print_ascii, bool hide_repeating)\n            : this(buffer, 0, (long)buffer.ByteLength, print_header, print_address, print_ascii, hide_repeating)\n        {\n        }\n\n        /// <summary>\n        /// Constructor.\n        /// </summary>\n        /// <param name="stm">The stream to print.</param>\n        /// <param name="print_header">Print a header.</param>\n        /// <param name="print_address">Print the address.</param>\n        /// <param name="print_ascii">Print the ASCII text.</param>\n        /// <param name="hide_repeating">Hide repeating lines.</param>\n        /// <param name="address_offset">Offset for address printing.</param>\n        public HexDumpBuilder(Stream stm, bool print_header, bool print_address, bool print_ascii, bool hide_repeating, long address_offset)\n        {\n            _address_offset = address_offset;\n            _data = stm;\n            _can_write = _data.CanSeek && _data.CanWrite;\n            _print_address = print_address;\n            _print_ascii = print_ascii;\n            _hide_repeating = hide_repeating;\n            if (print_header)\n            {\n                if (print_address)\n                {\n                    if (address_offset > uint.MaxValue)\n                    {\n                        _builder.Append(\' \', 18);\n                    }\n                    else\n                    {\n                        _builder.Append(\' \', 10);\n                    }\n                }\n\n                _builder.Append("00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F ");\n                if (print_ascii)\n                {\n                    _builder.AppendLine(" - 0123456789ABCDEF");\n                }\n                else\n                {\n                    _builder.AppendLine();\n                }\n                int dash_count = 48;\n                if (print_address)\n                {\n                    if (address_offset > uint.MaxValue)\n                    {\n                        dash_count += 18;\n                    }\n                    else\n                    {\n                        dash_count += 10;\n                    }\n                }\n                if (print_ascii)\n                {\n                    dash_count += 19;\n                }\n                _builder.Append(\'-\', dash_count);\n                _builder.AppendLine();\n            }\n        }\n\n        /// <summary>\n        /// Constructor.\n        /// </summary>\n        public HexDumpBuilder() \n            : this(false, false, false, false, 0)\n        {\n        }\n    }\n}\n'