b'{-# LANGUAGE CPP #-}\n\n-- | Common \'DatabasePredicate\'s used for defining schemas\nmodule Database.Beam.Migrate.Types.Predicates where\n\nimport Database.Beam\nimport Database.Beam.Backend.SQL.SQL92 (IsSql92TableNameSyntax(..))\nimport Database.Beam.Schema.Tables\n\nimport Control.DeepSeq\n\nimport Data.Aeson\nimport Data.Text (Text)\nimport Data.Hashable\nimport Data.Typeable\n\n#if !MIN_VERSION_base(4, 11, 0)\nimport           Data.Semigroup\n#endif\n\nimport Lens.Micro ((^.))\n\n-- * Predicates\n\n-- | A predicate is a type that describes some condition that the database\n-- schema must meet. Beam represents database schemas as the set of all\n-- predicates that apply to a database schema. The \'Hashable\' and \'Eq\' instances\n-- allow us to build \'HashSet\'s of predicates to represent schemas in this way.\nclass (Typeable p, Hashable p, Eq p) => DatabasePredicate p where\n  -- | An english language description of this predicate. For example, "There is\n  -- a table named \'TableName\'"\n  englishDescription :: p -> String\n\n  -- | Whether or not this predicate applies to all backends or only one\n  -- backend. This is used when attempting to translate schemas between\n  -- backends. If you are unsure, provide \'PredicateSpecificityOnlyBackend\'\n  -- along with an identifier unique to your backend.\n  predicateSpecificity :: proxy p -> PredicateSpecificity\n\n  -- | Serialize a predicate to a JSON \'Value\'.\n  serializePredicate :: p -> Value\n\n  -- | Some predicates require other predicates to be true. For example, in\n  -- order for a table to have a column, that table must exist. This function\n  -- takes in the current predicate and another arbitrary database predicate. It\n  -- should return \'True\' if this predicate needs the other predicate to be true\n  -- in order to exist.\n  --\n  -- By default, this simply returns \'False\', which makes sense for many\n  -- predicates.\n  predicateCascadesDropOn :: DatabasePredicate p\' => p -> p\' -> Bool\n  predicateCascadesDropOn _ _ = False\n\n-- | A Database predicate is a value of any type which satisfies\n-- \'DatabasePredicate\'. We often want to store these in lists and sets, so we\n-- need a monomorphic container that can store these polymorphic values.\ndata SomeDatabasePredicate where\n  SomeDatabasePredicate :: DatabasePredicate p\n                        => p -> SomeDatabasePredicate\n\ninstance NFData SomeDatabasePredicate where\n  rnf p\' = p\' `seq` ()\n\ninstance Show SomeDatabasePredicate where\n  showsPrec _ (SomeDatabasePredicate p\') =\n    (\'(\':) . shows (typeOf p\') . (": " ++) . (englishDescription p\' ++) . (\')\':)\ninstance Eq SomeDatabasePredicate where\n  SomeDatabasePredicate a == SomeDatabasePredicate b =\n    case cast a of\n      Nothing -> False\n      Just a\' -> a\' == b\ninstance Hashable SomeDatabasePredicate where\n  hashWithSalt salt (SomeDatabasePredicate p\') = hashWithSalt salt (typeOf p\', p\')\n\n-- | Some predicates make sense in any backend. Others only make sense in one.\n-- This denotes the difference.\ndata PredicateSpecificity\n  = PredicateSpecificityOnlyBackend String\n  | PredicateSpecificityAllBackends\n  deriving (Show, Eq, Generic)\ninstance Hashable PredicateSpecificity\n\ninstance ToJSON PredicateSpecificity where\n  toJSON PredicateSpecificityAllBackends = "all"\n  toJSON (PredicateSpecificityOnlyBackend s)  = object [ "backend" .= toJSON s ]\ninstance FromJSON PredicateSpecificity where\n  parseJSON "all" = pure PredicateSpecificityAllBackends\n  parseJSON (Object o) = PredicateSpecificityOnlyBackend <$> o .: "backend"\n  parseJSON _ = fail "PredicateSource"\n\n-- | Convenience synonym for \'SomeDatabasePredicate\'\np :: DatabasePredicate p => p -> SomeDatabasePredicate\np = SomeDatabasePredicate\n\n-- * Entity checks\n--\n--   When building checked database schemas, oftentimes the names of entities\n--   may change. For example, a \'defaulMigratableDbSettings\' object can have its\n--   tables renamed. The checks need to update in order to reflect these name\n--   changes. The following types represent predicates whose names have not yet\n--   been determined.\n\n-- | A name in a schema\ndata QualifiedName = QualifiedName (Maybe Text) Text\n  deriving (Show, Eq, Ord)\n\ninstance ToJSON QualifiedName where\n  toJSON (QualifiedName Nothing t) = toJSON t\n  toJSON (QualifiedName (Just s) t) = object [ "schema" .= s, "name" .= t ]\n\ninstance FromJSON QualifiedName where\n  parseJSON s@(String {}) = QualifiedName Nothing <$> parseJSON s\n  parseJSON (Object o) = QualifiedName <$> o .: "schema" <*> o .: "name"\n  parseJSON _ = fail "QualifiedName: expects either string or {schema: ..., name: ...}"\n\ninstance Hashable QualifiedName where\n  hashWithSalt s (QualifiedName sch t) =\n    hashWithSalt s (sch, t)\n\nqname :: IsDatabaseEntity be entity => DatabaseEntityDescriptor be entity -> QualifiedName\nqname e = QualifiedName (e ^. dbEntitySchema) (e ^. dbEntityName)\n\nqnameAsText :: QualifiedName -> Text\nqnameAsText (QualifiedName Nothing tbl) = tbl\nqnameAsText (QualifiedName (Just sch) tbl) = sch <> "." <> tbl\n\nqnameAsTableName :: IsSql92TableNameSyntax syntax => QualifiedName -> syntax\nqnameAsTableName (QualifiedName sch t) = tableName sch t\n\n-- | An optional predicate that depends on the name of a table as well as its fields\nnewtype TableCheck = TableCheck (forall tbl. Table tbl => QualifiedName -> tbl (TableField tbl) -> Maybe SomeDatabasePredicate)\n\n-- | A predicate that depends on the name of a domain type\nnewtype DomainCheck = DomainCheck (QualifiedName -> SomeDatabasePredicate)\n\n-- | A predicate that depends on the name of a table and one of its fields\nnewtype FieldCheck = FieldCheck (QualifiedName -> Text -> SomeDatabasePredicate)\n'