b'{-# LANGUAGE NoImplicitPrelude #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n{-# LANGUAGE OverloadedStrings #-}\n{-# LANGUAGE FlexibleInstances #-}\n\n-- + Complete the 10 exercises below by filling out the function bodies.\n--   Replace the function bodies (error "todo: ...") with an appropriate\n--   solution.\n-- + These exercises may be done in any order, however:\n--   Exercises are generally increasing in difficulty, though some people may find later exercise easier.\n-- + Bonus for using the provided functions or for using one exercise solution to help solve another.\n-- + Approach with your best available intuition; just dive in and do what you can!\n\nmodule Course.List where\n\nimport qualified Control.Applicative as A\nimport qualified Control.Monad as M\nimport Course.Core\nimport Course.Optional\nimport qualified System.Environment as E\nimport qualified Prelude as P\nimport qualified Numeric as N\n\n\n-- $setup\n-- >>> import Test.QuickCheck\n-- >>> import Course.Core(even, id, const)\n-- >>> import qualified Prelude as P(fmap, foldr)\n-- >>> instance Arbitrary a => Arbitrary (List a) where arbitrary = P.fmap ((P.foldr (:.) Nil) :: ([a] -> List a)) arbitrary\n\n-- BEGIN Helper functions and data types\n\n-- The custom list type\ndata List t =\n  Nil\n  | t :. List t\n  deriving (Eq, Ord)\n\n-- Right-associative\ninfixr 5 :.\n\ninstance Show t => Show (List t) where\n  show = show . foldRight (:) []\n\n-- The list of integers from zero to infinity.\ninfinity ::\n  List Integer\ninfinity =\n  let inf x = x :. inf (x+1)\n  in inf 0\n\n-- functions over List that you may consider using\nfoldRight :: (a -> b -> b) -> b -> List a -> b\nfoldRight _ b Nil      = b\nfoldRight f b (h :. t) = f h (foldRight f b t)\n\nfoldLeft :: (b -> a -> b) -> b -> List a -> b\nfoldLeft _ b Nil      = b\nfoldLeft f b (h :. t) = let b\' = f b h in b\' `seq` foldLeft f b\' t\n\n-- END Helper functions and data types\n\n-- | Returns the head of the list or the given default.\n--\n-- >>> headOr 3 (1 :. 2 :. Nil)\n-- 1\n--\n-- >>> headOr 3 Nil\n-- 3\n--\n-- prop> \\x -> x `headOr` infinity == 0\n--\n-- prop> \\x -> x `headOr` Nil == x\nheadOr ::\n  a\n  -> List a\n  -> a\nheadOr =\n  error "todo: Course.List#headOr"\n\n-- | The product of the elements of a list.\n--\n-- >>> product Nil\n-- 1\n--\n-- >>> product (1 :. 2 :. 3 :. Nil)\n-- 6\n--\n-- >>> product (1 :. 2 :. 3 :. 4 :. Nil)\n-- 24\nproduct ::\n  List Int\n  -> Int\nproduct =\n  error "todo: Course.List#product"\n\n-- | Sum the elements of the list.\n--\n-- >>> sum (1 :. 2 :. 3 :. Nil)\n-- 6\n--\n-- >>> sum (1 :. 2 :. 3 :. 4 :. Nil)\n-- 10\n--\n-- prop> \\x -> foldLeft (-) (sum x) x == 0\nsum ::\n  List Int\n  -> Int\nsum =\n  error "todo: Course.List#sum"\n\n-- | Return the length of the list.\n--\n-- >>> length (1 :. 2 :. 3 :. Nil)\n-- 3\n--\n-- prop> \\x -> sum (map (const 1) x) == length x\nlength ::\n  List a\n  -> Int\nlength =\n  error "todo: Course.List#length"\n\n-- | Map the given function on each element of the list.\n--\n-- >>> map (+10) (1 :. 2 :. 3 :. Nil)\n-- [11,12,13]\n--\n-- prop> \\x -> headOr x (map (+1) infinity) == 1\n--\n-- prop> \\x -> map id x == x\nmap ::\n  (a -> b)\n  -> List a\n  -> List b\nmap =\n  error "todo: Course.List#map"\n\n-- | Return elements satisfying the given predicate.\n--\n-- >>> filter even (1 :. 2 :. 3 :. 4 :. 5 :. Nil)\n-- [2,4]\n--\n-- prop> \\x -> headOr x (filter (const True) infinity) == 0\n--\n-- prop> \\x -> filter (const True) x == x\n--\n-- prop> \\x -> filter (const False) x == Nil\nfilter ::\n  (a -> Bool)\n  -> List a\n  -> List a\nfilter =\n  error "todo: Course.List#filter"\n\n-- | Append two lists to a new list.\n--\n-- >>> (1 :. 2 :. 3 :. Nil) ++ (4 :. 5 :. 6 :. Nil)\n-- [1,2,3,4,5,6]\n--\n-- prop> \\x -> headOr x (Nil ++ infinity) == 0\n--\n-- prop> \\x -> headOr x (y ++ infinity) == headOr 0 y\n--\n-- prop> \\x -> (x ++ y) ++ z == x ++ (y ++ z)\n--\n-- prop> \\x -> x ++ Nil == x\n(++) ::\n  List a\n  -> List a\n  -> List a\n(++) =\n  error "todo: Course.List#(++)"\n\ninfixr 5 ++\n\n-- | Flatten a list of lists to a list.\n--\n-- >>> flatten ((1 :. 2 :. 3 :. Nil) :. (4 :. 5 :. 6 :. Nil) :. (7 :. 8 :. 9 :. Nil) :. Nil)\n-- [1,2,3,4,5,6,7,8,9]\n--\n-- prop> \\x -> headOr x (flatten (infinity :. y :. Nil)) == 0\n--\n-- prop> \\x -> headOr x (flatten (y :. infinity :. Nil)) == headOr 0 y\n--\n-- prop> \\x -> sum (map length x) == length (flatten x)\nflatten ::\n  List (List a)\n  -> List a\nflatten =\n  error "todo: Course.List#flatten"\n\n-- | Map a function then flatten to a list.\n--\n-- >>> flatMap (\\x -> x :. x + 1 :. x + 2 :. Nil) (1 :. 2 :. 3 :. Nil)\n-- [1,2,3,2,3,4,3,4,5]\n--\n-- prop> \\x -> headOr x (flatMap id (infinity :. y :. Nil)) == 0\n--\n-- prop> \\x -> headOr x (flatMap id (y :. infinity :. Nil)) == headOr 0 y\n--\n-- prop> \\x -> flatMap id (x :: List (List Int)) == flatten x\nflatMap ::\n  (a -> List b)\n  -> List a\n  -> List b\nflatMap =\n  error "todo: Course.List#flatMap"\n\n-- | Flatten a list of lists to a list (again).\n-- HOWEVER, this time use the /flatMap/ function that you just wrote.\n--\n-- prop> \\x -> let types = x :: List (List Int) in flatten x == flattenAgain x\nflattenAgain ::\n  List (List a)\n  -> List a\nflattenAgain =\n  error "todo: Course.List#flattenAgain"\n\n-- | Convert a list of optional values to an optional list of values.\n--\n-- * If the list contains all `Full` values, \n-- then return `Full` list of values.\n--\n-- * If the list contains one or more `Empty` values,\n-- then return `Empty`.\n--\n-- * The only time `Empty` is returned is\n-- when the list contains one or more `Empty` values.\n--\n-- >>> seqOptional (Full 1 :. Full 10 :. Nil)\n-- Full [1,10]\n--\n-- >>> seqOptional Nil\n-- Full []\n--\n-- >>> seqOptional (Full 1 :. Full 10 :. Empty :. Nil)\n-- Empty\n--\n-- >>> seqOptional (Empty :. map Full infinity)\n-- Empty\nseqOptional ::\n  List (Optional a)\n  -> Optional (List a)\nseqOptional =\n  error "todo: Course.List#seqOptional"\n\n-- | Find the first element in the list matching the predicate.\n--\n-- >>> find even (1 :. 3 :. 5 :. Nil)\n-- Empty\n--\n-- >>> find even Nil\n-- Empty\n--\n-- >>> find even (1 :. 2 :. 3 :. 5 :. Nil)\n-- Full 2\n--\n-- >>> find even (1 :. 2 :. 3 :. 4 :. 5 :. Nil)\n-- Full 2\n--\n-- >>> find (const True) infinity\n-- Full 0\nfind ::\n  (a -> Bool)\n  -> List a\n  -> Optional a\nfind =\n  error "todo: Course.List#find"\n\n-- | Determine if the length of the given list is greater than 4.\n--\n-- >>> lengthGT4 (1 :. 3 :. 5 :. Nil)\n-- False\n--\n-- >>> lengthGT4 Nil\n-- False\n--\n-- >>> lengthGT4 (1 :. 2 :. 3 :. 4 :. 5 :. Nil)\n-- True\n--\n-- >>> lengthGT4 infinity\n-- True\nlengthGT4 ::\n  List a\n  -> Bool\nlengthGT4 =\n  error "todo: Course.List#lengthGT4"\n\n-- | Reverse a list.\n--\n-- >>> reverse Nil\n-- []\n--\n-- >>> take 1 (reverse (reverse largeList))\n-- [1]\n--\n-- prop> \\x -> let types = x :: List Int in reverse x ++ reverse y == reverse (y ++ x)\n--\n-- prop> \\x -> let types = x :: Int in reverse (x :. Nil) == x :. Nil\nreverse ::\n  List a\n  -> List a\nreverse =\n  error "todo: Course.List#reverse"\n\n-- | Produce an infinite `List` that seeds with the given value at its head,\n-- then runs the given function for subsequent elements\n--\n-- >>> let (x:.y:.z:.w:._) = produce (+1) 0 in [x,y,z,w]\n-- [0,1,2,3]\n--\n-- >>> let (x:.y:.z:.w:._) = produce (*2) 1 in [x,y,z,w]\n-- [1,2,4,8]\nproduce ::\n  (a -> a)\n  -> a\n  -> List a\nproduce f x = x :. produce f (f x)\n\n-- | Do anything other than reverse a list.\n-- Is it even possible?\n--\n-- >>> notReverse Nil\n-- []\n--\n-- prop> \\x -> let types = x :: List Int in notReverse x ++ notReverse y == notReverse (y ++ x)\n--\n-- prop> \\x -> let types = x :: Int in notReverse (x :. Nil) == x :. Nil\nnotReverse ::\n  List a\n  -> List a\nnotReverse =\n  error "todo: Is it even possible?"\n\n---- End of list exercises\n\nlargeList ::\n  List Int\nlargeList =\n  listh [1..50000]\n\nhlist ::\n  List a\n  -> [a]\nhlist =\n  foldRight (:) []\n\nlisth ::\n  [a]\n  -> List a\nlisth =\n  P.foldr (:.) Nil\n\nputStr ::\n  Chars\n  -> IO ()\nputStr =\n  P.putStr . hlist\n\nputStrLn ::\n  Chars\n  -> IO ()\nputStrLn =\n  P.putStrLn . hlist\n\nreadFile ::\n  FilePath\n  -> IO Chars\nreadFile =\n  P.fmap listh . P.readFile . hlist\n\nwriteFile ::\n  FilePath\n  -> Chars\n  -> IO ()\nwriteFile n s =\n  P.writeFile (hlist n) (hlist s)\n\ngetLine ::\n  IO Chars\ngetLine =\n  P.fmap listh P.getLine\n\ngetArgs ::\n  IO (List Chars)\ngetArgs =\n  P.fmap (listh . P.fmap listh) E.getArgs\n\nisPrefixOf ::\n  Eq a =>\n  List a\n  -> List a\n  -> Bool\nisPrefixOf Nil _ =\n  True\nisPrefixOf _  Nil =\n  False\nisPrefixOf (x:.xs) (y:.ys) =\n  x == y && isPrefixOf xs ys\n\nisEmpty ::\n  List a\n  -> Bool\nisEmpty Nil =\n  True\nisEmpty (_:._) =\n  False\n\nspan ::\n  (a -> Bool)\n  -> List a\n  -> (List a, List a)\nspan p x =\n  (takeWhile p x, dropWhile p x)\n\nbreak ::\n  (a -> Bool)\n  -> List a\n  -> (List a, List a)\nbreak p =\n  span (not . p)\n\ndropWhile ::\n  (a -> Bool)\n  -> List a\n  -> List a\ndropWhile _ Nil =\n  Nil\ndropWhile p xs@(x:.xs\') =\n  if p x\n    then\n      dropWhile p xs\'\n    else\n      xs\n\ntakeWhile ::\n  (a -> Bool)\n  -> List a\n  -> List a\ntakeWhile _ Nil =\n  Nil\ntakeWhile p (x:.xs) =\n  if p x\n    then\n      x :. takeWhile p xs\n    else\n      Nil\n\nzip ::\n  List a\n  -> List b\n  -> List (a, b)\nzip =\n  zipWith (,)\n\nzipWith ::\n  (a -> b -> c)\n  -> List a\n  -> List b\n  -> List c\nzipWith f (a:.as) (b:.bs) =\n  f a b :. zipWith f as bs\nzipWith _ _  _ =\n  Nil\n\nunfoldr ::\n  (a -> Optional (b, a))\n  -> a\n  -> List b\nunfoldr f b  =\n  case f b of\n    Full (a, z) -> a :. unfoldr f z\n    Empty -> Nil\n\nlines ::\n  Chars\n  -> List Chars\nlines =\n  listh . P.fmap listh . P.lines . hlist\n\nunlines ::\n  List Chars\n  -> Chars\nunlines =\n  listh . P.unlines . hlist . map hlist\n\nwords ::\n  Chars\n  -> List Chars\nwords =\n  listh . P.fmap listh . P.words . hlist\n\nunwords ::\n  List Chars\n  -> Chars\nunwords =\n  listh . P.unwords . hlist . map hlist\n\nlistOptional ::\n  (a -> Optional b)\n  -> List a\n  -> List b\nlistOptional _ Nil =\n  Nil\nlistOptional f (h:.t) =\n  let r = listOptional f t\n  in case f h of\n       Empty -> r\n       Full q -> q :. r\n\nany ::\n  (a -> Bool)\n  -> List a\n  -> Bool\nany p =\n  foldRight ((||) . p) False\n\nall ::\n  (a -> Bool)\n  -> List a\n  -> Bool\nall p =\n  foldRight ((&&) . p) True\n\nor ::\n  List Bool\n  -> Bool\nor =\n  any id\n\nand ::\n  List Bool\n  -> Bool\nand =\n  all id\n\nelem ::\n  Eq a =>\n  a\n  -> List a\n  -> Bool\nelem x =\n  any (== x)\n\nnotElem ::\n  Eq a =>\n  a\n  -> List a\n  -> Bool\nnotElem x =\n  all (/= x)\n\npermutations\n  :: List a -> List (List a)\npermutations xs0 =\n  let perms Nil _ =\n        Nil\n      perms (t:.ts) is =\n        let interleave\' _ Nil r =\n              (ts, r)\n            interleave\' f (y:.ys) r =\n               let (us,zs) = interleave\' (f . (y:.)) ys r\n               in  (y:.us, f (t:.y:.us):.zs)\n        in foldRight (\\xs -> snd . interleave\' id xs) (perms ts (t:.is)) (permutations is)\n  in xs0 :. perms xs0 Nil\n\nintersectBy ::\n  (a -> b -> Bool)\n  -> List a\n  -> List b\n  -> List a\nintersectBy e xs ys =\n  filter (\\x -> any (e x) ys) xs\n\ntake ::\n  (Num n, Ord n) =>\n  n\n  -> List a\n  -> List a\ntake n _  | n <= 0 =\n  Nil\ntake _ Nil =\n  Nil\ntake n (x:.xs) =\n  x :. take (n - 1) xs\n\ndrop ::\n  (Num n, Ord n) =>\n  n\n  -> List a\n  -> List a\ndrop n xs | n <= 0 =\n  xs\ndrop _ Nil =\n  Nil\ndrop n (_:.xs) =\n  drop (n-1) xs\n\nrepeat ::\n  a\n  -> List a\nrepeat x =\n  x :. repeat x\n\nreplicate ::\n  (Num n, Ord n) =>\n  n\n  -> a\n  -> List a\nreplicate n x =\n  take n (repeat x)\n\nreads ::\n  P.Read a =>\n  Chars\n  -> Optional (a, Chars)\nreads s =\n  case P.reads (hlist s) of\n    [] -> Empty\n    ((a, q):_) -> Full (a, listh q)\n\nread ::\n  P.Read a =>\n  Chars\n  -> Optional a\nread =\n  mapOptional fst . reads\n\nreadHexs ::\n  (Eq a, Num a) =>\n  Chars\n  -> Optional (a, Chars)\nreadHexs s =\n  case N.readHex (hlist s) of\n    [] -> Empty\n    ((a, q):_) -> Full (a, listh q)\n\nreadHex ::\n  (Eq a, Num a) =>\n  Chars\n  -> Optional a\nreadHex =\n  mapOptional fst . readHexs\n\nreadFloats ::\n  (RealFrac a) =>\n  Chars\n  -> Optional (a, Chars)\nreadFloats s =\n  case N.readSigned N.readFloat (hlist s) of\n    [] -> Empty\n    ((a, q):_) -> Full (a, listh q)\n\nreadFloat ::\n  (RealFrac a) =>\n  Chars\n  -> Optional a\nreadFloat =\n  mapOptional fst . readFloats\n\ninstance IsString (List Char) where\n  fromString =\n    listh\n\ntype Chars =\n  List Char\n\ntype FilePath =\n  List Char\n\nstrconcat ::\n  [Chars]\n  -> P.String\nstrconcat =\n  P.concatMap hlist\n\nstringconcat ::\n  [P.String]\n  -> P.String\nstringconcat =\n  P.concat\n\nshow\' ::\n  Show a =>\n  a\n  -> List Char\nshow\' =\n  listh . show\n\ninstance P.Functor List where\n  fmap f =\n    listh . P.fmap f . hlist\n\ninstance A.Applicative List where\n  (<*>) =\n    M.ap\n  pure =\n    (:. Nil)\n\ninstance P.Monad List where\n  (>>=) =\n    flip flatMap\n  return =\n    (:. Nil)\n'