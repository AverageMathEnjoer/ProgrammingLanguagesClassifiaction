b'{-# LANGUAGE CPP #-}\n{-# LANGUAGE BangPatterns #-}\n#if !defined(TESTING) && defined(__GLASGOW_HASKELL__)\n{-# LANGUAGE Trustworthy #-}\n#endif\n\n#include "containers.h"\n\n-----------------------------------------------------------------------------\n-- |\n-- Module      :  Data.IntMap.Merge.Strict\n-- Copyright   :  (c) wren romano 2016\n-- License     :  BSD-style\n-- Maintainer  :  libraries@haskell.org\n-- Portability :  portable\n--\n-- This module defines an API for writing functions that merge two\n-- maps. The key functions are \'merge\' and \'mergeA\'.\n-- Each of these can be used with several different \\"merge tactics\\".\n--\n-- The \'merge\' and \'mergeA\' functions are shared by\n-- the lazy and strict modules. Only the choice of merge tactics\n-- determines strictness. If you use \'Data.Map.Merge.Strict.mapMissing\'\n-- from this module then the results will be forced before they are\n-- inserted. If you use \'Data.Map.Merge.Lazy.mapMissing\' from\n-- "Data.Map.Merge.Lazy" then they will not.\n--\n-- == Efficiency note\n--\n-- The \'Control.Category.Category\', \'Applicative\', and \'Monad\' instances for\n-- \'WhenMissing\' tactics are included because they are valid. However, they are\n-- inefficient in many cases and should usually be avoided. The instances\n-- for \'WhenMatched\' tactics should not pose any major efficiency problems.\n--\n-- @since 0.5.9\n\nmodule Data.IntMap.Merge.Strict (\n    -- ** Simple merge tactic types\n      SimpleWhenMissing\n    , SimpleWhenMatched\n\n    -- ** General combining function\n    , merge\n\n    -- *** @WhenMatched@ tactics\n    , zipWithMaybeMatched\n    , zipWithMatched\n\n    -- *** @WhenMissing@ tactics\n    , mapMaybeMissing\n    , dropMissing\n    , preserveMissing\n    , mapMissing\n    , filterMissing\n\n    -- ** Applicative merge tactic types\n    , WhenMissing\n    , WhenMatched\n\n    -- ** Applicative general combining function\n    , mergeA\n\n    -- *** @WhenMatched@ tactics\n    -- | The tactics described for \'merge\' work for\n    -- \'mergeA\' as well. Furthermore, the following\n    -- are available.\n    , zipWithMaybeAMatched\n    , zipWithAMatched\n\n    -- *** @WhenMissing@ tactics\n    -- | The tactics described for \'merge\' work for\n    -- \'mergeA\' as well. Furthermore, the following\n    -- are available.\n    , traverseMaybeMissing\n    , traverseMissing\n    , filterAMissing\n\n    -- ** Covariant maps for tactics\n    , mapWhenMissing\n    , mapWhenMatched\n\n    -- ** Miscellaneous functions on tactics\n\n    , runWhenMatched\n    , runWhenMissing\n    ) where\n\nimport Data.IntMap.Internal\n  ( SimpleWhenMissing\n  , SimpleWhenMatched\n  , merge\n  , dropMissing\n  , preserveMissing\n  , filterMissing\n  , WhenMissing (..)\n  , WhenMatched (..)\n  , mergeA\n  , filterAMissing\n  , runWhenMatched\n  , runWhenMissing\n  )\nimport Data.IntMap.Strict.Internal\nimport Prelude hiding (filter, map, foldl, foldr)\n\n-- | Map covariantly over a @\'WhenMissing\' f k x@.\nmapWhenMissing :: Functor f => (a -> b) -> WhenMissing f x a -> WhenMissing f x b\nmapWhenMissing f q = WhenMissing\n  { missingSubtree = fmap (map f) . missingSubtree q\n  , missingKey = \\k x -> fmap (forceMaybe . fmap f) $ missingKey q k x}\n\n-- | Map covariantly over a @\'WhenMatched\' f k x y@.\nmapWhenMatched :: Functor f => (a -> b) -> WhenMatched f x y a -> WhenMatched f x y b\nmapWhenMatched f q = WhenMatched\n  { matchedKey = \\k x y -> fmap (forceMaybe . fmap f) $ runWhenMatched q k x y }\n\n-- | When a key is found in both maps, apply a function to the\n-- key and values and maybe use the result in the merged map.\n--\n-- @\n-- zipWithMaybeMatched :: (k -> x -> y -> Maybe z)\n--                     -> SimpleWhenMatched k x y z\n-- @\nzipWithMaybeMatched :: Applicative f\n                    => (Key -> x -> y -> Maybe z)\n                    -> WhenMatched f x y z\nzipWithMaybeMatched f = WhenMatched $\n  \\k x y -> pure $! forceMaybe $! f k x y\n{-# INLINE zipWithMaybeMatched #-}\n\n-- | When a key is found in both maps, apply a function to the\n-- key and values, perform the resulting action, and maybe use\n-- the result in the merged map.\n--\n-- This is the fundamental \'WhenMatched\' tactic.\nzipWithMaybeAMatched :: Applicative f\n                     => (Key -> x -> y -> f (Maybe z))\n                     -> WhenMatched f x y z\nzipWithMaybeAMatched f = WhenMatched $\n  \\ k x y -> forceMaybe <$> f k x y\n{-# INLINE zipWithMaybeAMatched #-}\n\n-- | When a key is found in both maps, apply a function to the\n-- key and values to produce an action and use its result in the merged map.\nzipWithAMatched :: Applicative f\n                => (Key -> x -> y -> f z)\n                -> WhenMatched f x y z\nzipWithAMatched f = WhenMatched $\n  \\ k x y -> (Just $!) <$> f k x y\n{-# INLINE zipWithAMatched #-}\n\n-- | When a key is found in both maps, apply a function to the\n-- key and values and use the result in the merged map.\n--\n-- @\n-- zipWithMatched :: (k -> x -> y -> z)\n--                -> SimpleWhenMatched k x y z\n-- @\nzipWithMatched :: Applicative f\n               => (Key -> x -> y -> z) -> WhenMatched f x y z\nzipWithMatched f = WhenMatched $\n  \\k x y -> pure $! Just $! f k x y\n{-# INLINE zipWithMatched #-}\n\n-- | Map over the entries whose keys are missing from the other map,\n-- optionally removing some. This is the most powerful \'SimpleWhenMissing\'\n-- tactic, but others are usually more efficient.\n--\n-- @\n-- mapMaybeMissing :: (k -> x -> Maybe y) -> SimpleWhenMissing k x y\n-- @\n--\n-- prop> mapMaybeMissing f = traverseMaybeMissing (\\k x -> pure (f k x))\n--\n-- but @mapMaybeMissing@ uses fewer unnecessary \'Applicative\' operations.\nmapMaybeMissing :: Applicative f => (Key -> x -> Maybe y) -> WhenMissing f x y\nmapMaybeMissing f = WhenMissing\n  { missingSubtree = \\m -> pure $! mapMaybeWithKey f m\n  , missingKey = \\k x -> pure $! forceMaybe $! f k x }\n{-# INLINE mapMaybeMissing #-}\n\n-- | Map over the entries whose keys are missing from the other map.\n--\n-- @\n-- mapMissing :: (k -> x -> y) -> SimpleWhenMissing k x y\n-- @\n--\n-- prop> mapMissing f = mapMaybeMissing (\\k x -> Just $ f k x)\n--\n-- but @mapMissing@ is somewhat faster.\nmapMissing :: Applicative f => (Key -> x -> y) -> WhenMissing f x y\nmapMissing f = WhenMissing\n  { missingSubtree = \\m -> pure $! mapWithKey f m\n  , missingKey = \\k x -> pure $! Just $! f k x }\n{-# INLINE mapMissing #-}\n\n-- | Traverse over the entries whose keys are missing from the other map,\n-- optionally producing values to put in the result.\n-- This is the most powerful \'WhenMissing\' tactic, but others are usually\n-- more efficient.\ntraverseMaybeMissing :: Applicative f\n                     => (Key -> x -> f (Maybe y)) -> WhenMissing f x y\ntraverseMaybeMissing f = WhenMissing\n  { missingSubtree = traverseMaybeWithKey f\n  , missingKey = \\k x -> forceMaybe <$> f k x }\n{-# INLINE traverseMaybeMissing #-}\n\n-- | Traverse over the entries whose keys are missing from the other map.\ntraverseMissing :: Applicative f\n                     => (Key -> x -> f y) -> WhenMissing f x y\ntraverseMissing f = WhenMissing\n  { missingSubtree = traverseWithKey f\n  , missingKey = \\k x -> (Just $!) <$> f k x }\n{-# INLINE traverseMissing #-}\n\nforceMaybe :: Maybe a -> Maybe a\nforceMaybe Nothing = Nothing\nforceMaybe m@(Just !_) = m\n{-# INLINE forceMaybe #-}\n'