b'#include <bits/stdc++.h>\n// http://www.spoj.com/problems/HORRIBLE/\nusing namespace std;\n#define gc getchar_unlocked\n#define fo(i,n) for(i=0;i<n;i++)\n#define Fo(i,k,n) for(i=k;k<n?i<n:i>n;k<n?i+=1:i-=1)\n#define ll long long\n#define si(x)\tscanf("%d",&x)\n#define sl(x)\tscanf("%lld",&x)\n#define ss(s)\tscanf("%s",s)\n#define pi(x)\tprintf("%d\\n",x)\n#define pl(x)\tprintf("%lld\\n",x)\n#define ps(s)\tprintf("%s\\n",s)\n#define deb(x) cout << #x << "=" << x << endl\n#define deb2(x, y) cout << #x << "=" << x << "," << #y << "=" << y << endl\n#define pb push_back\n#define mp make_pair\n#define F first\n#define S second\n#define all(x) x.begin(), x.end()\n#define clr(x) memset(x, 0, sizeof(x))\n#define sortall(x) sort(all(x))\n#define tr(it, a) for(auto it = a.begin(); it != a.end(); it++)\n#define PI 3.1415926535897932384626\ntypedef pair<int, int>\tpii;\ntypedef pair<ll, ll>\tpl;\ntypedef vector<int>\t\tvi;\ntypedef vector<ll>\t\tvl;\ntypedef vector<pii>\t\tvpii;\ntypedef vector<pl>\t\tvpl;\ntypedef vector<vi>\t\tvvi;\ntypedef vector<vl>\t\tvvl;\nint mpow(int base, int exp); \nvoid ipgraph(int m);\nvoid dfs(int u, int par);\nconst int mod = 1000000007;\nconst int N = 3e5, M = N;\n#define pnode node*\nstruct node{\n\tint key;\n\tll val;\n\tll sum;\n\tll lazy;\n\tint prior;\n\tint size;\n\tpnode l;\n\tpnode r;\n};\npnode init(int val){\n\tpnode res = new node;\n\tres->prior = rand();\n\tres->l = res->r = NULL;\n\tres->val = val;\n\tres->sum = val;\n\tres->size = 1;\n\tres->lazy = 0;\n\treturn res;\n}\nll sm(pnode t){\n\tif(!t) return 0;\n\treturn t->sum;\n}\nint sz(pnode t){\n\tif(t == NULL) return 0;\n\telse return t->size;\n}\nvoid reform(pnode t){\n\tif(!t)return;\n\tt->sum = sm(t->l) + sm(t->r) + t->val;\n}\nvoid push(pnode t){\n\tif(!t) return;\n\tif(t->lazy){\n\t\tll ex = t->lazy;\n\t\tif(t->l){\n\t\t\tt->l->val += ex;\n\t\t\tt->l->sum += ex * sz(t->l);\n\t\t\tt->l->lazy += ex;\n\t\t}\n\t\tif(t->r){\n\t\t\tt->r->val += ex;\n\t\t\tt->r->sum += ex * sz(t->r);\n\t\t\tt->r->lazy += ex;\n\t\t}\n\t\tt->lazy = 0;\n\t}\n}\nvoid upd_sz(pnode t){\n\tif(t) t->size = sz(t->l) + 1 + sz(t->r);\n}\nvoid split(pnode t, pnode &l, pnode &r, int pos){\n\tif(t == NULL) {l=r=NULL; return ;}\n\tpush(t);\n\tint tot = sz(t->l);\n\tif(tot >= pos) split(t->l, l, t->l, pos), r = t;\n\telse split(t->r, t->r, r, pos-tot-1), l = t;\n\tupd_sz(t);\n\treform(t);\n}\nvoid merge(pnode &t, pnode l, pnode r){\n\tpush(l);\n\tpush(r);\n\tif(!l or !r) t = l?l:r;\n\telse if(l->prior >= r->prior) merge(l->r, l->r, r), t = l;\n\telse merge(r->l, l, r->l), t = r;\n\tupd_sz(t);\n\treform(t);\n}\nvoid range_update(pnode &t, int x, int y, int val){\n\tpnode L;\n\tpnode mid;\n\tpnode R;\n\tsplit(t, L, mid, x-1);\n\tsplit(mid, t, R, y-x+1);\n\tt->val += val;\n\tt->sum += val * sz(t);\n\tt->lazy += val;\n\tmerge(mid, t, R);\n\tmerge(t, L, mid);\n}\nll range_query(pnode &t, int x, int y){\n\tpnode L;\n\tpnode mid;\n\tpnode R;\n\tsplit(t, L, mid, x-1);\n\tsplit(mid, t, R, y-x+1);\n\tll ans = t->sum;\n\tmerge(mid, t, R);\n\tmerge(t, L, mid);\n\treturn ans;\n}\n// void insert_at(pnode &t, int pos, int val){\n// \tpnode L;\n// \tpnode mid;\n// \tpnode R;\n// \tsplit(t, L, mid, pos-1);\n// \tsplit(mid, t, R, 1);\n// \tt->val = val;\n// \tmerge(mid, t, R);\n// \tmerge(t, L, mid);\n// }\n// void print(pnode t){\n// \tif(!t)return;\n// \tprint(t->l);\n// \tcout << t->val << " ";\n// \tprint(t->r);\n// }\n// int delete_at(pnode &t, int pos){\n// \tnode *L, *mid, *R;\n// \tsplit(t, L, mid, pos-1);\n// \tsplit(mid, t, R, 1);\n// \tnode *tem = t;\n// \tint val = t->val;\n// \tmerge(t, L, R);\n// \tfree(tem);\n// \treturn val;\n// }\nvoid clear(pnode &t){\n\tif(t == NULL)return;\n\tclear(t->l);\n\tclear(t->r);\n\tfree(t);\n}\n//=======================\n\nvi g[N];\nint a[N];\n\nint main()\n{\n\tios_base::sync_with_stdio(false);\n\tcin.tie(NULL);\n\tsrand(time(NULL));\n\tint i,n,k,j,q,x,y;\n\tcin >> k;\n\tpnode t;\n\tint v;\n\twhile(k--){\n\t\tcin >> n >> q;\n\t\t// clear(t);\n\t\tt = init(0);\n\t\tfo(i, n-1) merge(t, t, init(0));\n\t\tx = 2, y = 3;\n\t\tv = 1;\n\t\twhile(q--){\n\t\t\tint ty;\n\t\t\tcin >> ty >> x >> y;\n\t\t\tif(ty == 0){\n\t\t\t\tcin >> v;\n\t\t\t\trange_update(t, x, y, v);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tcout << range_query(t, x, y) << endl;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n} \n\n'