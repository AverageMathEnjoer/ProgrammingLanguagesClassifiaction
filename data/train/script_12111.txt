b'{-# OPTIONS_GHC -fno-warn-orphans #-}\n{-# LANGUAGE TupleSections #-}\n{-# LANGUAGE BangPatterns #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE DeriveGeneric #-}\n{-# LANGUAGE RecordWildCards #-}\n{-# LANGUAGE CPP #-}\n{-# LANGUAGE UndecidableInstances #-}\n\n-- | Data types and functions to discover sequences of DDL commands to go from\n-- one database state to another. Used for migration generation.\n--\n-- For our purposes, a database state is fully specified by the set of\n-- predicates that apply to that database.\n--\n-- Migration generation is approached as a graph search problem over the\n-- infinite graph of databases /G/. The nodes of /G/ are database states, which\n-- (as said above) are simply sets of predicates (see \'DatabaseState\' for the\n-- realization of this concept in code). For two vertices /S1/ and /S2/ in /G/,\n-- there is an edge between the two if and only if there is a DDL command that\n-- can take a database at /S1/ to /S2/.\n--\n-- We generate migrations by exploring this graph, starting at the source state\n-- and ending at the destination state. By default we use an optimizing solver\n-- that weights each edge by the complexity of the particular command, and we\n-- attempt to find the shortest path using Dijkstra\'s algorithm, although a user\n-- may override this behavior and provide a custom edge selection mechanism (or\n-- even defer this choice to the user).\n--\n-- In order to conduct the breadth-first search, we must know which edges lead\n-- out of whichever vertex we\'re currently visiting. The solving algorithm thus\n-- takes a set of \'ActionProvider\'s, which are means of discovering edges that\n-- are incident to the current database state.\n--\n-- Conceptually, an \'ActionProvider\' is a function of type \'ActionProviderFn\',\n-- which takes the current database state and produces a list of edges in the\n-- form of \'PotentialAction\' objects. For optimization purposes,\n-- \'ActionProvider\'s also take in the desired destination state, which it can\n-- use to select only edges that make sense. This does not affect the result,\n-- just the amount of time it may take to get there.\n--\n-- Note that because the graph of database states is infinite, a breadth-first\n-- search may easily end up continuing to explore when there is no chance of\n-- reaching our goal. This would result in non-termination and is highly\n-- undesirable. In order to prevent this, we limit ourselves to only exploring\n-- edges that take us /closer/ to the destination state. Here, we measure\n-- distance between two states as the number of elements in the symmetric\n-- difference of two database states. Thus, every action we take must either\n-- remove a predicate that doesn\'t exist in the destination state, or add a\n-- predicate that does. If a potential action only adds predicates that do not\n-- exist in the final state or removes predicates that do not exist in the\n-- first, then we never explore that edge.\n--\n-- == A note on speed\n--\n-- There are some issues with this approach. Namely, if there is no solution, we\n-- can end up exploring the entire action space, which may be quite a lot. While\n-- @beam-migrate@ can solve all databases that can be made up of predicates in\n-- this module, other beam backends may not make such strict guarantees\n-- (although in practice, all do). Nevertheless, if you\'re hacking on this\n-- module and notice what seems like an infinite loop, you may have accidentally\n-- removed code that exposed the edge that leads to a solution to the migration.\n--\n--\nmodule Database.Beam.Migrate.Actions\n  (\n  -- * Database state\n    DatabaseStateSource(..)\n  , DatabaseState(..)\n\n  -- * Action generation\n  , PotentialAction(..)\n\n  , ActionProvider(..)\n  , ActionProviderFn\n\n  , ensuringNot_\n  , justOne_\n\n  , createTableActionProvider\n  , dropTableActionProvider\n  , addColumnProvider\n  , addColumnNullProvider\n  , dropColumnNullProvider\n  , defaultActionProvider\n\n  -- * Solver\n  , Solver(..), FinalSolution(..)\n  , finalSolution\n  , heuristicSolver\n  ) where\n\nimport           Database.Beam.Backend.SQL\nimport           Database.Beam.Migrate.Checks\nimport           Database.Beam.Migrate.SQL\nimport           Database.Beam.Migrate.Types\nimport           Database.Beam.Migrate.Types.Predicates (qnameAsText, qnameAsTableName)\n\nimport           Control.Applicative\nimport           Control.DeepSeq\nimport           Control.Monad\nimport           Control.Parallel.Strategies\n\nimport           Data.Foldable\n\nimport qualified Data.HashMap.Strict as HM\nimport qualified Data.HashSet as HS\nimport qualified Data.PQueue.Min as PQ\nimport qualified Data.Sequence as Seq\nimport           Data.Text (Text)\nimport qualified Data.Text as T\nimport           Data.Typeable\n#if !MIN_VERSION_base(4, 11, 0)\nimport           Data.Semigroup\n#endif\n\nimport           GHC.Generics\n\n-- | Used to indicate whether a particular predicate is from the initial\n-- database state, or due to a sequence of actions we\'ve committed too. Used to\n-- prevent runaway action generation based off of derived states.\ndata DatabaseStateSource\n  = DatabaseStateSourceOriginal -- ^ Predicate is from the original set given by the user\n  | DatabaseStateSourceDerived  -- ^ Predicate is from an action we\'ve committed to in this action chain\n  deriving (Show, Eq, Ord, Enum, Bounded, Generic)\ninstance NFData DatabaseStateSource\n\n-- | Represents the state of a database as a migration is being generated\ndata DatabaseState be\n  = DatabaseState\n  { dbStateCurrentState       :: !(HM.HashMap SomeDatabasePredicate DatabaseStateSource)\n    -- ^ The current set of predicates that apply to this database as well as\n    -- their source (user or from previous actions)\n  , dbStateKey                :: !(HS.HashSet SomeDatabasePredicate)\n    -- ^ HS.fromMap of \'dbStateCurrentState\', for maximal sharing\n  , dbStateCmdSequence        :: !(Seq.Seq (MigrationCommand be))\n    -- ^ The current sequence of commands we\'ve committed to in this state\n  }\nderiving instance Show (BeamSqlBackendSyntax be) => Show (DatabaseState be)\n\ninstance NFData (DatabaseState cmd) where\n  rnf d@DatabaseState{} = d `seq` ()\n\n-- | Wrapper for \'DatabaseState\' that keeps track of the command sequence length\n-- and goal distance. Used for sorting states when conducting the search.\ndata MeasuredDatabaseState be\n  = MeasuredDatabaseState {-# UNPACK #-} !Int {-# UNPACK #-} !Int (DatabaseState be)\n  deriving Generic\nderiving instance Show (BeamSqlBackendSyntax be) => Show (MeasuredDatabaseState be)\ninstance NFData (MeasuredDatabaseState cmd)\ninstance Eq (MeasuredDatabaseState cmd) where\n  a == b = measure a == measure b\ninstance Ord (MeasuredDatabaseState cmd) where\n  compare a b = compare (measure a) (measure b)\n\nmeasure :: MeasuredDatabaseState cmd -> Int\nmeasure (MeasuredDatabaseState cmdLength estGoalDistance _) = cmdLength + 100 * estGoalDistance\n\nmeasuredDbState :: MeasuredDatabaseState cmd -> DatabaseState cmd\nmeasuredDbState (MeasuredDatabaseState _ _ s) = s\n\nmeasureDb\' :: HS.HashSet SomeDatabasePredicate\n           -> HS.HashSet SomeDatabasePredicate\n           -> Int\n           -> DatabaseState cmd\n           -> MeasuredDatabaseState cmd\nmeasureDb\' _ post cmdLength st@(DatabaseState _ repr _) =\n  MeasuredDatabaseState cmdLength distToGoal st\n  where\n\n    distToGoal = HS.size ((repr `HS.difference` post) `HS.union`\n                          (post `HS.difference` repr))\n\n-- | Represents an edge (or a path) in the database graph.\n--\n-- Given a particular starting point, the destination database is the database\n-- where each predicate in \'actionPreConditions\' has been removed and each\n-- predicate in \'actionPostConditions\' has been added.\ndata PotentialAction be\n  = PotentialAction\n  { actionPreConditions  :: !(HS.HashSet SomeDatabasePredicate)\n    -- ^ Preconditions that will no longer apply\n  , actionPostConditions :: !(HS.HashSet SomeDatabasePredicate)\n    -- ^ Conditions that will apply after we\'re done\n  , actionCommands :: !(Seq.Seq (MigrationCommand be))\n    -- ^ The sequence of commands that accomplish this movement in the database\n    -- graph. For an edge, \'actionCommands\' contains one command; for a path, it\n    -- will contain more.\n  , actionEnglish  :: !Text\n    -- ^ An english description of the movement\n  , actionScore    :: {-# UNPACK #-} !Int\n    -- ^ A heuristic notion of complexity or weight; used to find the "easiest"\n    -- path through the graph.\n  }\n\ninstance Semigroup (PotentialAction be) where\n  (<>) = mappend\n\n-- | \'PotentialAction\'s can represent edges or paths. Monadically combining two\n-- \'PotentialAction\'s results in the path between the source of the first and\n-- the destination of the second. \'mempty\' here returns the action that does\n-- nothing (i.e., the edge going back to the same database state)\ninstance Monoid (PotentialAction be) where\n  mempty = PotentialAction mempty mempty mempty  "" 0\n  mappend a b =\n    PotentialAction (actionPreConditions a <> actionPreConditions b)\n                    (actionPostConditions a <> actionPostConditions b)\n                    (actionCommands a <> actionCommands b)\n                    (if T.null (actionEnglish a) then actionEnglish b\n                      else if T.null (actionEnglish b) then actionEnglish a\n                           else actionEnglish a <> "; " <> actionEnglish b)\n                    (actionScore a + actionScore b)\n\n-- | See \'ActionProvider\'\ntype ActionProviderFn be =\n     (forall preCondition.  Typeable preCondition  => [ preCondition ])             {- The list of preconditions -}\n  -> (forall postCondition. Typeable postCondition => [ postCondition ])            {- The list of postconditions (used for guiding action selection) -}\n  -> [ PotentialAction be ]  {- A list of actions that we could perform -}\n\n-- | Edge discovery mechanism. A newtype wrapper over \'ActionProviderFn\'.\n--\n-- An \'ActionProviderFn\' takes two arguments. The first is the set of predicates\n-- that exist in the current database.\n--\n-- The function should a set of edges from the database specified in the first\n-- argument to possible destination databases. For optimization purposes, the\n-- second argument is the set of predicates that ought to exist in the\n-- destination database. This can be used to eliminate edges that will not lead\n-- to a solution.\n--\n-- This second argument is just an optimization and doesn\'t change the final\n-- result, although it can significantly impact the time it takes to get there.\n--\n-- Both the current database set and the destination database set are given as\n-- polymorphic lists of predicates. When you instantiate the type, the current\n-- database predicate set is queried for predicates of that type.\n--\n-- For example, \'dropTableActionProvider\' provides a @DROP TABLE@ action edge\n-- whenever it encounters a table that exists. In order to do this, it attempts\n-- to find all \'TableExistsPredicate\' that do not exist in the destination\n-- database. Its \'ActionProviderFn\' may be implemented like such:\n--\n-- > dropTableActionProvider preConditions postConditions = do\n-- >     TableExistsPredicate srcTblNm <- preConditions\n-- >     ensuringNot_ $ $\n-- >       do TableExistsPredicate destTblNm <- postConditions\n-- >          guard (srcTblNm == destTblNm)\n--\n-- \'ensuringNot_\' is a function that causes the action provider to return no\n-- results if there are any elements in the provided list. In this case, it\'s\n-- used to stop @DROP TABLE@ action generation for tables which must be present\n-- in the final database.\nnewtype ActionProvider be\n  = ActionProvider { getPotentialActions :: ActionProviderFn be }\n\ninstance Semigroup (ActionProvider be) where\n  (<>) = mappend\n\ninstance Monoid (ActionProvider be) where\n  mempty = ActionProvider (\\_ _ -> [])\n  mappend (ActionProvider a) (ActionProvider b) =\n    ActionProvider $ \\pre post ->\n    let aRes = a pre post\n        bRes = b pre post\n\n    in withStrategy (rparWith (parList rseq)) aRes `seq`\n       withStrategy (rparWith (parList rseq)) bRes `seq`\n       aRes ++ bRes\n\ncreateTableWeight, dropTableWeight, addColumnWeight, dropColumnWeight :: Int\ncreateTableWeight = 500\ndropTableWeight = 100\naddColumnWeight = 1\ndropColumnWeight = 1\n\n-- | Proceeds only if no predicate matches the given pattern. See the\n-- implementation of \'dropTableActionProvider\' for an example of usage.\nensuringNot_ :: Alternative m => [ a ] -> m ()\nensuringNot_ [] = pure ()\nensuringNot_ _  = empty\n\n-- | Used to ensure that only one predicate matches the given pattern. See the\n-- implementation of \'createTableActionProvider\' for an example of usage.\njustOne_ :: [ a ] -> [ a ]\njustOne_ [x] = [x]\njustOne_ _ = []\n\n-- | Action provider for SQL92 @CREATE TABLE@ actions.\ncreateTableActionProvider :: forall be\n                           . ( Typeable be, BeamMigrateOnlySqlBackend be )\n                          => ActionProvider be\ncreateTableActionProvider =\n  ActionProvider provider\n  where\n    provider :: ActionProviderFn be\n    provider findPreConditions findPostConditions =\n      do tblP@(TableExistsPredicate postTblNm) <- findPostConditions\n         -- Make sure there\'s no corresponding predicate in the precondition\n         ensuringNot_ $\n           do TableExistsPredicate preTblNm <- findPreConditions\n              guard (preTblNm == postTblNm)\n\n         (columnsP, columns) <- pure . unzip $\n           do columnP@(TableHasColumn tblNm colNm schema :: TableHasColumn be) <-\n                findPostConditions\n              guard (tblNm == postTblNm && dataTypeHasBeenCreated schema findPreConditions)\n\n              (constraintsP, constraints) <-\n                pure . unzip $ do\n                constraintP@(TableColumnHasConstraint tblNm\' colNm\' c :: TableColumnHasConstraint be) <-\n                  findPostConditions\n                guard (postTblNm == tblNm\')\n                guard (colNm == colNm\')\n\n                pure (p constraintP, c)\n\n              pure (p columnP:constraintsP, (colNm, schema, constraints))\n         (primaryKeyP, primaryKey) <- justOne_ $ do\n           primaryKeyP@(TableHasPrimaryKey tblNm primaryKey) <-\n             findPostConditions\n           guard (tblNm == postTblNm)\n           pure (primaryKeyP, primaryKey)\n\n         let postConditions = [ p tblP, p primaryKeyP ] ++ concat columnsP\n             cmd = createTableCmd (createTableSyntax Nothing (qnameAsTableName postTblNm) colsSyntax tblConstraints)\n             tblConstraints = if null primaryKey then [] else [ primaryKeyConstraintSyntax primaryKey ]\n             colsSyntax = map (\\(colNm, type_, cs) -> (colNm, columnSchemaSyntax type_ Nothing cs Nothing)) columns\n         pure (PotentialAction mempty (HS.fromList postConditions)\n                               (Seq.singleton (MigrationCommand cmd MigrationKeepsData))\n                               ("Create the table " <> qnameAsText postTblNm) createTableWeight)\n\n-- | Action provider for SQL92 @DROP TABLE@ actions\ndropTableActionProvider :: forall be\n                         . BeamMigrateOnlySqlBackend be\n                        => ActionProvider be\ndropTableActionProvider =\n ActionProvider provider\n where\n   -- Look for tables that exist as a precondition but not a post condition\n   provider :: ActionProviderFn be\n   provider findPreConditions findPostConditions =\n     do tblP@(TableExistsPredicate preTblNm) <- findPreConditions\n        ensuringNot_ $\n          do TableExistsPredicate postTblNm <- findPostConditions\n             guard (preTblNm == postTblNm)\n\n        relatedPreds <-\n          pure $ do p\'@(SomeDatabasePredicate pred\') <- findPreConditions\n                    guard (pred\' `predicateCascadesDropOn` tblP)\n                    pure p\'\n\n        -- Now, collect all preconditions that may be related to the dropped table\n        let cmd = dropTableCmd (dropTableSyntax (qnameAsTableName preTblNm))\n        pure ({-trace ("Dropping table " <> show preTblNm <> " would drop " <> show relatedPreds) $ -}\n              PotentialAction (HS.fromList (SomeDatabasePredicate tblP:relatedPreds)) mempty\n                              (Seq.singleton (MigrationCommand cmd MigrationLosesData))\n                              ("Drop table " <> qnameAsText preTblNm) dropTableWeight)\n\n-- | Action provider for SQL92 @ALTER TABLE ... ADD COLUMN ...@ actions\naddColumnProvider :: forall be\n                   . ( Typeable be, BeamMigrateOnlySqlBackend be )\n                  => ActionProvider be\naddColumnProvider =\n  ActionProvider provider\n  where\n    provider :: ActionProviderFn be\n    provider findPreConditions findPostConditions =\n      do colP@(TableHasColumn tblNm colNm colType :: TableHasColumn be)\n           <- findPostConditions\n         TableExistsPredicate tblNm\' <- findPreConditions\n         guard (tblNm\'  == tblNm && dataTypeHasBeenCreated colType findPreConditions)\n         ensuringNot_ $ do\n           TableHasColumn tblNm\'\' colNm\' _ :: TableHasColumn be <-\n             findPreConditions\n           guard (tblNm\'\' == tblNm && colNm == colNm\') -- This column exists as a different type\n\n         (constraintsP, constraints) <-\n           pure . unzip $ do\n           constraintP@(TableColumnHasConstraint tblNm\'\' colNm\' c :: TableColumnHasConstraint be) <-\n             findPostConditions\n           guard (tblNm == tblNm\'\')\n           guard (colNm == colNm\')\n\n           pure (p constraintP, c)\n\n         let cmd = alterTableCmd (alterTableSyntax (qnameAsTableName tblNm) (addColumnSyntax colNm schema))\n             schema = columnSchemaSyntax colType Nothing constraints Nothing\n         pure (PotentialAction mempty (HS.fromList ([SomeDatabasePredicate colP] ++ constraintsP))\n                               (Seq.singleton (MigrationCommand cmd MigrationKeepsData))\n                               ("Add column " <> colNm <> " to " <> qnameAsText tblNm)\n                (addColumnWeight + fromIntegral (T.length (qnameAsText tblNm) + T.length colNm)))\n\n-- | Action provider for SQL92 @ALTER TABLE ... DROP COLUMN ...@ actions\ndropColumnProvider :: forall be\n                    . ( Typeable be, BeamMigrateOnlySqlBackend be )\n                   => ActionProvider be\ndropColumnProvider = ActionProvider provider\n  where\n    provider :: ActionProviderFn be\n    provider findPreConditions _ =\n      do colP@(TableHasColumn tblNm colNm _ :: TableHasColumn be)\n           <- findPreConditions\n\n--         TableExistsPredicate tblNm\' <- trace ("COnsider drop " <> show tblNm <> " " <> show colNm)  findPreConditions\n--         guard (any (\\(TableExistsPredicate tblNm\') -> tblNm\' == tblNm) findPreConditions) --tblNm\' == tblNm)\n--         ensuringNot_ $ do\n--           TableHasColumn tblNm\' colNm\' colType\' :: TableHasColumn (Sql92DdlCommandColumnSchemaSyntax cmd) <-\n--             findPostConditions\n--           guard (tblNm\' == tblNm && colNm == colNm\' && colType == colType\') -- This column exists as a different type\n\n         relatedPreds <- --pure []\n           pure $ do p\'@(SomeDatabasePredicate pred\') <- findPreConditions\n                     guard (pred\' `predicateCascadesDropOn` colP)\n                     pure p\'\n\n         let cmd = alterTableCmd (alterTableSyntax (qnameAsTableName tblNm) (dropColumnSyntax colNm))\n         pure (PotentialAction (HS.fromList (SomeDatabasePredicate colP:relatedPreds)) mempty\n                               (Seq.singleton (MigrationCommand cmd MigrationLosesData))\n                               ("Drop column " <> colNm <> " from " <> qnameAsText tblNm)\n                (dropColumnWeight + fromIntegral (T.length (qnameAsText tblNm) + T.length colNm)))\n\n-- | Action provider for SQL92 @ALTER TABLE ... ALTER COLUMN ... SET NULL@\naddColumnNullProvider :: forall be\n                       . ( Typeable be, BeamMigrateOnlySqlBackend be )\n                      => ActionProvider be\naddColumnNullProvider = ActionProvider provider\n  where\n    provider :: ActionProviderFn be\n    provider findPreConditions findPostConditions =\n      do colP@(TableColumnHasConstraint tblNm colNm _ :: TableColumnHasConstraint be)\n           <- findPostConditions\n-- TODO         guard (c == notNullConstraintSyntax)\n\n         TableExistsPredicate tblNm\' <- findPreConditions\n         guard (tblNm == tblNm\')\n\n         TableHasColumn tblNm\'\' colNm\' _ :: TableHasColumn be <-\n           findPreConditions\n         guard (tblNm == tblNm\'\' && colNm == colNm\')\n\n         let cmd = alterTableCmd (alterTableSyntax (qnameAsTableName tblNm) (alterColumnSyntax colNm setNotNullSyntax))\n         pure (PotentialAction mempty (HS.fromList [SomeDatabasePredicate colP])\n                               (Seq.singleton (MigrationCommand cmd MigrationKeepsData))\n                               ("Add not null constraint to " <> colNm <> " on " <> qnameAsText tblNm) 100)\n\n-- | Action provider for SQL92 @ALTER TABLE ... ALTER COLUMN ... SET  NOT NULL@\ndropColumnNullProvider :: forall be\n                        . ( Typeable be, BeamMigrateOnlySqlBackend be )\n                       => ActionProvider be\ndropColumnNullProvider = ActionProvider provider\n  where\n    provider :: ActionProviderFn be\n    provider findPreConditions _ =\n      do colP@(TableColumnHasConstraint tblNm colNm _ :: TableColumnHasConstraint be)\n           <- findPreConditions\n-- TODO         guard (c == notNullConstraintSyntax)\n\n         TableExistsPredicate tblNm\' <- findPreConditions\n         guard (tblNm == tblNm\')\n\n         TableHasColumn tblNm\'\' colNm\' _ :: TableHasColumn be <-\n           findPreConditions\n         guard (tblNm == tblNm\'\' && colNm == colNm\')\n\n         let cmd = alterTableCmd (alterTableSyntax (qnameAsTableName tblNm) (alterColumnSyntax colNm setNullSyntax))\n         pure (PotentialAction (HS.fromList [SomeDatabasePredicate colP]) mempty\n                               (Seq.singleton (MigrationCommand cmd MigrationKeepsData))\n                               ("Drop not null constraint for " <> colNm <> " on " <> qnameAsText tblNm) 100)\n\n-- | Default action providers for any SQL92 compliant syntax.\n--\n-- In particular, this provides edges consisting of the following statements:\n--\n--  * CREATE TABLE\n--  * DROP TABLE\n--  * ALTER TABLE ... ADD COLUMN ...\n--  * ALTER TABLE ... DROP COLUMN ...\n--  * ALTER TABLE ... ALTER COLUMN ... SET [NOT] NULL\ndefaultActionProvider :: ( Typeable be\n                         , BeamMigrateOnlySqlBackend be )\n                      => ActionProvider be\ndefaultActionProvider =\n  mconcat\n  [ createTableActionProvider\n  , dropTableActionProvider\n\n  , addColumnProvider\n  , dropColumnProvider\n\n  , addColumnNullProvider\n  , dropColumnNullProvider ]\n\n-- | Represents current state of a database graph search.\n--\n-- If \'ProvideSolution\', the destination database has been reached, and the\n-- given list of commands provides the path from the source database to the\n-- destination.\n--\n-- If \'SearchFailed\', the search has failed. The provided \'DatabaseState\'s\n-- represent the closest we could make it to the destination database. By\n-- default, only the best 10 are kept around (to avoid unbounded memory growth).\n--\n-- If \'ChooseActions\', we are still searching. The caller is provided with the\n-- current state as well as a list of actions, provided as an opaque type @f@.\n-- The \'getPotentialActionChoice\' function can be used to get the\n-- \'PotentialAction\' corresponding to any given @f@. The caller is free to cull\n-- the set of potential actions according however they\'d like (for example, by\n-- prompting the user). The selected actions to explore should be passed to the\n-- \'continueSearch\' function.\n--\n-- Use of the @f@ existential type may seem obtuse, but it prevents the caller\n-- from injecting arbitrary actions. Instead the caller is limited to choosing\n-- only valid actions as provided by the suppled \'ActionProvider\'.\ndata Solver cmd where\n  ProvideSolution :: [ MigrationCommand cmd ] -> Solver cmd\n  SearchFailed    :: [ DatabaseState cmd ] -> Solver cmd\n  ChooseActions   :: { choosingActionsAtState :: !(DatabaseState cmd)\n                       -- ^ The current node we\'re searching at\n                     , getPotentialActionChoice :: f -> PotentialAction cmd\n                       -- ^ Convert the opaque @f@ type to a \'PotentialAction\'.\n                       -- This can be used to present the actions to the user or\n                       -- to inspect the action to make a more informed choice\n                       -- on exploration strategies.\n                     , potentialActionChoices :: [ f ]\n                       -- ^ The possible actions that we can take, presented as\n                       -- an opaque list. Use the \'getPotentialActionChoice\'\n                       -- function to get the corresponding \'PotentialAction\'.\n                     , continueSearch :: [ f ] -> Solver cmd\n                       -- ^ Continue the search and get the next \'Solver\'\n                     } -> Solver cmd\n\n-- | Represents the final results of a search\ndata FinalSolution be\n  = Solved [ MigrationCommand be ]\n    -- ^ The search found a path from the source to the destination database,\n    -- and has provided a set of commands that would work\n  | Candidates [ DatabaseState be ]\n    -- ^ The search failed, but provided a set of \'DatbaseState\'s it encountered\n    -- that were the closest to the destination database. By default, only 10\n    -- candidates are provided.\nderiving instance Show (BeamSqlBackendSyntax be) => Show (FinalSolution be)\n\n-- | Returns \'True\' if the state has been solved\nsolvedState :: HS.HashSet SomeDatabasePredicate -> DatabaseState be -> Bool\nsolvedState goal (DatabaseState _ cur _) = goal == cur\n\n-- | An exhaustive solving strategy that simply continues the search, while\n-- exploring every possible action. If there is a solution, this will find it.\nfinalSolution :: Solver be -> FinalSolution be\nfinalSolution (SearchFailed sts)     = Candidates sts\nfinalSolution (ProvideSolution cmds) = Solved cmds\nfinalSolution (ChooseActions _ _ actions next) =\n  finalSolution (next actions)\n\n{-# INLINE heuristicSolver #-}\n-- | Conduct a breadth-first search of the database graph to find a path from\n-- the source database to the destination database, using the given\n-- \'ActionProvider\' to discovere "edges" (i.e., DDL commands) between the\n-- databases.\n--\n-- See the documentation on \'Solver\' for more information on how to consume the\n-- result.\nheuristicSolver :: ActionProvider be         -- ^ Edge discovery function\n                -> [ SomeDatabasePredicate ] -- ^ Source database state\n                -> [ SomeDatabasePredicate ] -- ^ Destination database state\n                -> Solver be\nheuristicSolver provider preConditionsL postConditionsL =\n\n  heuristicSolver\' initQueue mempty PQ.empty\n\n  where\n    -- Number of failed action chains to keep\n    rejectedCount = 10\n\n    postConditions = HS.fromList postConditionsL\n    preConditions = HS.fromList preConditionsL\n    allToFalsify = preConditions `HS.difference` postConditions\n    measureDb = measureDb\' allToFalsify postConditions\n\n    initQueue = PQ.singleton (measureDb 0 initDbState)\n    initDbState = DatabaseState (DatabaseStateSourceOriginal <$ HS.toMap preConditions)\n                                preConditions\n                                mempty\n\n    findPredicate :: forall predicate. Typeable predicate\n                   => SomeDatabasePredicate\n                   -> [ predicate ] -> [ predicate ]\n    findPredicate\n      | Just (Refl :: predicate :~: SomeDatabasePredicate) <- eqT =\n          (:)\n      | otherwise =\n          \\(SomeDatabasePredicate pred\') ps ->\n              maybe ps (:ps) (cast pred\')\n\n    findPredicates :: forall predicate f. (Typeable predicate, Foldable f)\n                   => f SomeDatabasePredicate -> [ predicate ]\n    findPredicates = foldr findPredicate []\n\n    heuristicSolver\' !q !visited !bestRejected =\n      case PQ.minView q of\n        Nothing -> SearchFailed (measuredDbState <$> PQ.toList bestRejected)\n        Just (mdbState@(MeasuredDatabaseState _ _ dbState), q\')\n          | dbStateKey dbState `HS.member` visited -> heuristicSolver\' q\' visited bestRejected\n          | solvedState postConditions (measuredDbState mdbState) ->\n              ProvideSolution (toList (dbStateCmdSequence dbState))\n          | otherwise ->\n              let steps = getPotentialActions\n                              provider\n                              (findPredicates (dbStateKey dbState))\n                              (findPredicates postConditionsL)\n\n                  steps\' = filter (not . (`HS.member` visited) . dbStateKey . measuredDbState . snd) $\n                           withStrategy (parList rseq) $\n                           map (\\step -> let dbState\' = applyStep step mdbState\n                                         in dbState\' `seq` (step, dbState\')) steps\n\n                  applyStep step (MeasuredDatabaseState score _ dbState\') =\n                    let dbState\'\' = dbStateAfterAction dbState\' step\n                    in measureDb (score + 1) dbState\'\'\n\n              in case steps\' of\n                   -- Since no steps were generated, this is a dead end. Add to the rejected queue\n                   [] -> heuristicSolver\' q\' visited (reject mdbState bestRejected)\n                   _ -> ChooseActions dbState fst steps\' $ \\chosenSteps ->\n                            let q\'\' = foldr (\\(_, dbState\') -> PQ.insert dbState\') q\' chosenSteps\n                                visited\' = HS.insert (dbStateKey dbState) visited\n                            in withStrategy (rparWith rseq) q\'\' `seq` heuristicSolver\' q\'\' visited\' bestRejected\n\n    reject :: MeasuredDatabaseState cmd -> PQ.MinQueue (MeasuredDatabaseState cmd)\n           -> PQ.MinQueue (MeasuredDatabaseState cmd)\n    reject mdbState q =\n      let q\' = PQ.insert mdbState q\n      in PQ.fromAscList (PQ.take rejectedCount q\')\n\n    dbStateAfterAction (DatabaseState curState _ cmds) action =\n      let curState\' = ((curState `HM.difference` HS.toMap (actionPreConditions action))\n                     `HM.union` (DatabaseStateSourceDerived <$ HS.toMap (actionPostConditions action)))\n      in DatabaseState curState\' (HS.fromMap (() <$ curState\'))\n                       (cmds <> actionCommands action)\n'