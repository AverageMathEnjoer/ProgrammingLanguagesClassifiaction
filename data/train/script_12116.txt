b'{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE RankNTypes #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n{-# LANGUAGE OverloadedStrings #-}\n{-# LANGUAGE DataKinds #-}\n{-# LANGUAGE UndecidableInstances #-}\n{-# LANGUAGE CPP #-}\n{-# OPTIONS_GHC -fno-warn-orphans -fno-warn-type-defaults #-}\n\n-- | Migrations support for beam-postgres. See "Database.Beam.Migrate" for more\n-- information on beam migrations.\nmodule Database.Beam.Postgres.Migrate\n  ( PgCommandSyntax, migrationBackend\n  , postgresDataTypeDeserializers\n  , pgPredConverter\n  , getDbConstraints\n  , getDbConstraintsForSchemas\n  , pgTypeToHs\n  , migrateScript\n  , writeMigrationScript\n  , pgDataTypeFromAtt\n\n    -- * Postgres data types\n  , tsquery, tsvector, text, bytea\n  , unboundedArray, uuid, money\n  , json, jsonb\n  , smallserial, serial, bigserial\n  , point, line, lineSegment, box\n  ) where\n\nimport           Database.Beam.Backend.SQL\nimport           Database.Beam.Migrate.Actions (defaultActionProvider)\nimport qualified Database.Beam.Migrate.Backend as Tool\nimport qualified Database.Beam.Migrate.Checks as Db\nimport qualified Database.Beam.Migrate.SQL as Db\nimport           Database.Beam.Migrate.SQL.BeamExtensions\nimport qualified Database.Beam.Migrate.Serialization as Db\nimport qualified Database.Beam.Migrate.Types as Db\nimport qualified Database.Beam.Query.DataTypes as Db\n\nimport           Database.Beam.Postgres.Connection\nimport           Database.Beam.Postgres.CustomTypes\nimport           Database.Beam.Postgres.Extensions\nimport           Database.Beam.Postgres.PgSpecific\nimport           Database.Beam.Postgres.Syntax\nimport           Database.Beam.Postgres.Types\n\nimport           Database.Beam.Haskell.Syntax\n\nimport qualified Database.PostgreSQL.Simple as Pg\nimport qualified Database.PostgreSQL.Simple.Types as Pg\nimport qualified Database.PostgreSQL.Simple.TypeInfo.Static as Pg\n\nimport           Control.Applicative ((<|>))\nimport           Control.Arrow\nimport           Control.Exception (bracket)\nimport           Control.Monad\n\nimport           Data.Aeson hiding (json)\nimport           Data.Bits\nimport           Data.ByteString (ByteString)\nimport qualified Data.ByteString.Lazy as BL\nimport qualified Data.ByteString.Lazy.Char8 as BCL\nimport qualified Data.HashMap.Strict as HM\nimport           Data.Int\nimport           Data.Maybe\nimport           Data.String\nimport qualified Data.Text as T\nimport qualified Data.Text.Encoding as TE\nimport           Data.Typeable\nimport           Data.UUID.Types (UUID)\nimport qualified Data.Vector as V\n#if !MIN_VERSION_base(4, 11, 0)\nimport           Data.Semigroup\n#else\nimport           Data.Monoid (Endo(..))\n#endif\nimport           Data.Word (Word64)\n\n-- | Top-level migration backend for use by @beam-migrate@ tools\nmigrationBackend :: Tool.BeamMigrationBackend Postgres Pg\nmigrationBackend = Tool.BeamMigrationBackend\n                        "postgres"\n                        (unlines [ "For beam-postgres, this is a libpq connection string which can either be a list of key value pairs or a URI"\n                                 , ""\n                                 , "For example, \'host=localhost port=5432 dbname=mydb connect_timeout=10\' or \'dbname=mydb\'"\n                                 , ""\n                                 , "Or use URIs, for which the general form is:"\n                                 , "  postgresql://[user[:password]@][netloc][:port][/dbname][?param1=value1&...]"\n                                 , ""\n                                 , "See <https://www.postgresql.org/docs/9.5/static/libpq-connect.html#LIBPQ-CONNSTRING> for more information" ])\n                        (liftIOWithHandle getDbConstraints)\n                        (Db.sql92Deserializers <> Db.sql99DataTypeDeserializers <>\n                         Db.sql2008BigIntDataTypeDeserializers <>\n                         postgresDataTypeDeserializers <>\n                         Db.beamCheckDeserializers)\n                        (BCL.unpack . (<> ";") . pgRenderSyntaxScript . fromPgCommand) "postgres.sql"\n                        pgPredConverter (defaultActionProvider <> pgExtensionActionProvider <>\n                                         pgCustomEnumActionProvider)\n                        (\\options action ->\n                            bracket (Pg.connectPostgreSQL (fromString options)) Pg.close $ \\conn ->\n                              left show <$> withPgDebug (\\_ -> pure ()) conn action)\n\n-- | \'BeamDeserializers\' for postgres-specific types:\n--\n--    * \'bytea\'\n--    * \'smallserial\'\n--    * \'serial\'\n--    * \'bigserial\'\n--    * \'tsvector\'\n--    * \'tsquery\'\n--    * \'text\'\n--    * \'json\'\n--    * \'jsonb\'\n--    * \'uuid\'\n--    * \'money\'\n--\npostgresDataTypeDeserializers\n  :: Db.BeamDeserializers Postgres\npostgresDataTypeDeserializers =\n  Db.beamDeserializer $ \\_ v ->\n  case v of\n    "bytea"       -> pure pgByteaType\n    "smallserial" -> pure pgSmallSerialType\n    "serial"      -> pure pgSerialType\n    "bigserial"   -> pure pgBigSerialType\n    "tsquery"     -> pure pgTsQueryType\n    "tsvector"    -> pure pgTsVectorType\n    "text"        -> pure pgTextType\n    "json"        -> pure pgJsonType\n    "jsonb"       -> pure pgJsonbType\n    "uuid"        -> pure pgUuidType\n    "money"       -> pure pgMoneyType\n    "point"       -> pure pgPointType\n    "line"        -> pure pgLineType\n    "lseg"        -> pure pgLineSegmentType\n    "box"         -> pure pgBoxType\n    _             -> fail "Postgres data type"\n\n-- | Converts postgres \'DatabasePredicate\'s to \'DatabasePredicate\'s in the\n-- Haskell syntax. Allows automatic generation of Haskell schemas from postgres\n-- constraints.\npgPredConverter :: Tool.HaskellPredicateConverter\npgPredConverter = Tool.sql92HsPredicateConverters @Postgres pgTypeToHs <>\n                  Tool.hsPredicateConverter pgHasColumnConstraint\n  where\n    pgHasColumnConstraint (Db.TableColumnHasConstraint tblNm colNm c :: Db.TableColumnHasConstraint Postgres)\n      | c == Db.constraintDefinitionSyntax Nothing Db.notNullConstraintSyntax Nothing =\n          Just (Db.SomeDatabasePredicate (Db.TableColumnHasConstraint tblNm colNm (Db.constraintDefinitionSyntax Nothing Db.notNullConstraintSyntax Nothing) :: Db.TableColumnHasConstraint HsMigrateBackend))\n      | otherwise = Nothing\n\n-- | Turn a \'PgDataTypeSyntax\' into the corresponding \'HsDataType\'. This is a\n-- best effort guess, and may fail on more exotic types. Feel free to send PRs\n-- to make this function more robust!\npgTypeToHs :: PgDataTypeSyntax -> Maybe HsDataType\npgTypeToHs (PgDataTypeSyntax tyDescr _ _) =\n  case tyDescr of\n    PgDataTypeDescrOid oid width\n      | Pg.typoid Pg.int2    == oid -> Just smallIntType\n      | Pg.typoid Pg.int4    == oid -> Just intType\n      | Pg.typoid Pg.int8    == oid -> Just bigIntType\n\n      | Pg.typoid Pg.bpchar  == oid -> Just (charType (fromIntegral <$> width) Nothing)\n      | Pg.typoid Pg.varchar == oid -> Just (varCharType (fromIntegral <$> width) Nothing)\n      | Pg.typoid Pg.bit     == oid -> Just (bitType (fromIntegral <$> width))\n      | Pg.typoid Pg.varbit  == oid -> Just (varBitType (fromIntegral <$> width))\n\n      | Pg.typoid Pg.numeric == oid ->\n          let decimals = fromMaybe 0 width .&. 0xFFFF\n              prec     = (fromMaybe 0 width `shiftR` 16) .&. 0xFFFF\n          in Just (numericType (Just (fromIntegral prec, Just (fromIntegral decimals))))\n\n      | Pg.typoid Pg.float4  == oid -> Just (floatType (fromIntegral <$> width))\n      | Pg.typoid Pg.float8  == oid -> Just doubleType\n\n      | Pg.typoid Pg.date    == oid -> Just dateType\n\n      -- We prefer using the standard beam names\n      | Pg.typoid Pg.text    == oid -> Just characterLargeObjectType\n      | Pg.typoid Pg.bytea   == oid -> Just binaryLargeObjectType\n      | Pg.typoid Pg.bool    == oid -> Just booleanType\n\n      -- TODO timestamp prec\n      | Pg.typoid Pg.time        == oid -> Just (timeType Nothing False)\n      | Pg.typoid Pg.timestamp   == oid -> Just (timestampType Nothing False)\n      | Pg.typoid Pg.timestamptz == oid -> Just (timestampType Nothing True)\n\n      -- Postgres specific datatypes, haskell versions\n      | Pg.typoid Pg.uuid        == oid ->\n          Just $ HsDataType (hsVarFrom "uuid" "Database.Beam.Postgres")\n                            (HsType (tyConNamed "UUID")\n                                    (importSome "Data.UUID.Types" [importTyNamed "UUID"]))\n                            (pgDataTypeSerialized pgUuidType)\n      | Pg.typoid Pg.money       == oid ->\n          Just $ HsDataType (hsVarFrom "money" "Database.Beam.Postgres")\n                            (HsType (tyConNamed "PgMoney")\n                                    (importSome "Database.Beam.Postgres" [importTyNamed "PgMoney"]))\n                            (pgDataTypeSerialized pgMoneyType)\n      | Pg.typoid Pg.json        == oid ->\n          Just $ HsDataType (hsVarFrom "json" "Database.Beam.Postgres")\n                            (HsType (tyApp (tyConNamed "PgJSON") [ tyConNamed "Value" ])\n                                    (importSome "Data.Aeson" [importTyNamed "Value"] <>\n                                     importSome "Database.Beam.Postgres" [importTyNamed "PgJSON"]))\n                            (pgDataTypeSerialized pgJsonType)\n      | Pg.typoid Pg.jsonb       == oid ->\n          Just $ HsDataType (hsVarFrom "jsonb" "Database.Beam.Postgres")\n                            (HsType (tyApp (tyConNamed "PgJSONB") [ tyConNamed "Value" ])\n                                    (importSome "Data.Aeson" [importTyNamed "Value"] <>\n                                     importSome "Database.Beam.Postgres" [importTyNamed "PgJSONB"]))\n                            (pgDataTypeSerialized pgJsonType)\n      | Pg.typoid pgTsVectorTypeInfo == oid ->\n          Just $ HsDataType (hsVarFrom "tsvector" "Database.Beam.Postgres")\n                            (HsType (tyConNamed "TsVector")\n                                    (importSome "Database.Beam.Postgres" [importTyNamed "TsVector"]))\n                            (pgDataTypeSerialized pgTsVectorType)\n      | Pg.typoid pgTsQueryTypeInfo == oid ->\n          Just $ HsDataType (hsVarFrom "tsquery" "Database.Beam.Postgres")\n                            (HsType (tyConNamed "TsQuery")\n                                    (importSome "Database.Beam.Postgres" [importTyNamed "TsQuery"]))\n                            (pgDataTypeSerialized pgTsQueryType)\n\n      | Pg.typoid Pg.point   == oid ->\n          Just $ HsDataType (hsVarFrom "point" "Database.Beam.Postgres")\n                            (HsType (tyConNamed "PgPoint")\n                                    (importSome "Database.Beam.Postgres" [ importTyNamed "PgPoint" ]))\n                            (pgDataTypeSerialized pgPointType)\n      | Pg.typoid Pg.line    == oid ->\n          Just $ HsDataType (hsVarFrom "line" "Database.Beam.Postgres")\n                            (HsType (tyConNamed "PgLine")\n                                    (importSome "Database.Beam.Postgres" [ importTyNamed "PgLine" ]))\n                            (pgDataTypeSerialized pgLineType)\n      | Pg.typoid Pg.lseg    == oid ->\n          Just $ HsDataType (hsVarFrom "lineSegment" "Database.Beam.Postgres")\n                            (HsType (tyConNamed "PgLineSegment")\n                                    (importSome "Database.Beam.Postgres" [ importTyNamed "PgLineSegment" ]))\n                            (pgDataTypeSerialized pgLineSegmentType)\n      | Pg.typoid Pg.box     == oid ->\n          Just $ HsDataType (hsVarFrom "box" "Database.Beam.Postgres")\n                            (HsType (tyConNamed "PgBox")\n                                    (importSome "Database.Beam.Postgres" [ importTyNamed "PgBox" ]))\n                            (pgDataTypeSerialized pgBoxType)\n\n    _ -> Just (hsErrorType ("PG type " ++ show tyDescr))\n\n-- | Turn a series of \'Db.MigrationSteps\' into a line-by-line array of\n-- \'BL.ByteString\'s suitable for writing to a script.\nmigrateScript :: Db.MigrationSteps Postgres () a\' -> [BL.ByteString]\nmigrateScript steps =\n  "-- CAUTION: beam-postgres currently escapes postgres string literals somewhat\\n"                 :\n  "--          haphazardly when generating scripts (but not when generating commands)\\n"            :\n  "--          This is due to technical limitations in libPq that require a Postgres\\n"             :\n  "--          Connection in order to correctly escape strings. Please verify that the\\n"           :\n  "--          generated migration script is correct before running it on your database.\\n"         :\n  "--          If you feel so called, please contribute better escaping support to beam-postgres\\n" :\n  "\\n"                                                                                              :\n  "-- Set connection encoding to UTF-8\\n"                                                           :\n  "SET client_encoding = \'UTF8\';\\n"                                                                 :\n  "SET standard_conforming_strings = off;\\n\\n"                                                      :\n  appEndo (Db.migrateScript renderHeader renderCommand steps) []\n  where\n    renderHeader nm =\n      Endo (("-- " <> BL.fromStrict (TE.encodeUtf8 nm) <> "\\n"):)\n    renderCommand command =\n      Endo ((pgRenderSyntaxScript (fromPgCommand command) <> ";\\n"):)\n\n-- | Write the migration given by the \'Db.MigrationSteps\' to a file.\nwriteMigrationScript :: FilePath -> Db.MigrationSteps Postgres () a -> IO ()\nwriteMigrationScript fp steps =\n  let stepBs = migrateScript steps\n  in BL.writeFile fp (BL.concat stepBs)\n\npgExpandDataType :: Db.DataType Postgres a -> PgDataTypeSyntax\npgExpandDataType (Db.DataType pg) = pg\n\npgCharLength :: Maybe Int32 -> Maybe Word\npgCharLength Nothing = Nothing\npgCharLength (Just (-1)) = Nothing\npgCharLength (Just x) = Just (fromIntegral x)\n\npgDataTypeFromAtt :: ByteString -> Pg.Oid -> Maybe Int32 -> Maybe PgDataTypeSyntax\npgDataTypeFromAtt _ oid pgMod\n  | Pg.typoid Pg.bool == oid        = Just $ pgExpandDataType Db.boolean\n  | Pg.typoid Pg.bytea == oid       = Just $ pgExpandDataType Db.binaryLargeObject\n  | Pg.typoid Pg.char == oid        = Just $ pgExpandDataType (Db.char (pgCharLength pgMod))\n  -- TODO Pg.name\n  | Pg.typoid Pg.int8 == oid        = Just $ pgExpandDataType (Db.bigint :: Db.DataType Postgres Int64)\n  | Pg.typoid Pg.int4 == oid        = Just $ pgExpandDataType (Db.int :: Db.DataType Postgres Int32)\n  | Pg.typoid Pg.int2 == oid        = Just $ pgExpandDataType (Db.smallint :: Db.DataType Postgres Int16)\n  | Pg.typoid Pg.varchar == oid     = Just $ pgExpandDataType (Db.varchar (pgCharLength pgMod))\n  | Pg.typoid Pg.timestamp == oid   = Just $ pgExpandDataType Db.timestamp\n  | Pg.typoid Pg.timestamptz == oid = Just $ pgExpandDataType Db.timestamptz\n  | Pg.typoid Pg.float8 == oid      = Just $ pgExpandDataType Db.double\n  | Pg.typoid Pg.text  == oid       = Just $ pgTextType\n  | Pg.typoid Pg.json  == oid       = Just $ pgJsonType\n  | Pg.typoid Pg.jsonb == oid       = Just $ pgJsonbType\n  | Pg.typoid Pg.uuid  == oid       = Just $ pgUuidType\n  | Pg.typoid Pg.point == oid       = Just $ pgPointType\n  | Pg.typoid Pg.line  == oid       = Just $ pgLineType\n  | Pg.typoid Pg.lseg  == oid       = Just $ pgLineSegmentType\n  | Pg.typoid Pg.box   == oid       = Just $ pgBoxType\n  | Pg.typoid Pg.numeric == oid =\n      let precAndDecimal =\n            case pgMod of\n              Nothing -> Nothing\n              Just pgMod\' ->\n                let prec = fromIntegral (pgMod\' `shiftR` 16)\n                    dec = fromIntegral (pgMod\' .&. 0xFFFF)\n                in Just (prec, if dec == 0 then Nothing else Just dec)\n      in Just $ pgExpandDataType (Db.numeric precAndDecimal)\n  | otherwise = Nothing\n\npgEnumerationTypeFromAtt :: [ (T.Text, Pg.Oid, V.Vector T.Text) ] -> ByteString -> Pg.Oid -> Maybe Int32 -> Maybe PgDataTypeSyntax\npgEnumerationTypeFromAtt enumData =\n  let enumDataMap = HM.fromList [ (fromIntegral oid\' :: Word64, -- Get around lack of Hashable for CUInt\n                                   PgDataTypeSyntax (PgDataTypeDescrDomain nm) (emit (TE.encodeUtf8 nm))\n                                          (pgDataTypeJSON (object [ "customType" .= nm ]))) | (nm, (Pg.Oid oid\'), _) <- enumData ]\n  in \\_ (Pg.Oid oid) _ -> HM.lookup (fromIntegral oid) enumDataMap\n\npgUnknownDataType :: Pg.Oid -> Maybe Int32 -> PgDataTypeSyntax\npgUnknownDataType oid@(Pg.Oid oid\') pgMod =\n  PgDataTypeSyntax (PgDataTypeDescrOid oid pgMod) (emit "{- UNKNOWN -}")\n                   (pgDataTypeJSON (object [ "oid" .= (fromIntegral oid\' :: Word), "mod" .= pgMod ]))\n\n-- * Create constraints from a connection\n\ngetDbConstraints :: Pg.Connection -> IO [ Db.SomeDatabasePredicate ]\ngetDbConstraints = getDbConstraintsForSchemas Nothing\n\ngetDbConstraintsForSchemas :: Maybe [String] -> Pg.Connection -> IO [ Db.SomeDatabasePredicate ]\ngetDbConstraintsForSchemas subschemas conn =\n  do tbls <- case subschemas of\n        Nothing -> Pg.query_ conn "SELECT cl.oid, relname FROM pg_catalog.pg_class \\"cl\\" join pg_catalog.pg_namespace \\"ns\\" on (ns.oid = relnamespace) where nspname = any (current_schemas(false)) and relkind=\'r\'"\n        Just ss -> Pg.query  conn "SELECT cl.oid, relname FROM pg_catalog.pg_class \\"cl\\" join pg_catalog.pg_namespace \\"ns\\" on (ns.oid = relnamespace) where nspname IN ? and relkind=\'r\'" (Pg.Only (Pg.In ss))\n     let tblsExist = map (\\(_, tbl) -> Db.SomeDatabasePredicate (Db.TableExistsPredicate (Db.QualifiedName Nothing tbl))) tbls\n\n     enumerationData <-\n       Pg.query_ conn\n         (fromString (unlines\n                      [ "SELECT t.typname, t.oid, array_agg(e.enumlabel ORDER BY e.enumsortorder)"\n                      , "FROM pg_enum e JOIN pg_type t ON t.oid = e.enumtypid"\n                      , "GROUP BY t.typname, t.oid" ]))\n\n     columnChecks <-\n       fmap mconcat . forM tbls $ \\(oid, tbl) ->\n       do columns <- Pg.query conn "SELECT attname, atttypid, atttypmod, attnotnull, pg_catalog.format_type(atttypid, atttypmod) FROM pg_catalog.pg_attribute att WHERE att.attrelid=? AND att.attnum>0 AND att.attisdropped=\'f\'"\n                       (Pg.Only (oid :: Pg.Oid))\n          let columnChecks = map (\\(nm, typId :: Pg.Oid, typmod, _, typ :: ByteString) ->\n                                    let typmod\' = if typmod == -1 then Nothing else Just (typmod - 4)\n\n                                        pgDataType = fromMaybe (pgUnknownDataType typId typmod\') $\n                                                     pgDataTypeFromAtt typ typId typmod\' <|>\n                                                     pgEnumerationTypeFromAtt enumerationData typ typId typmod\'\n\n                                    in Db.SomeDatabasePredicate (Db.TableHasColumn (Db.QualifiedName Nothing tbl) nm pgDataType :: Db.TableHasColumn Postgres)) columns\n              notNullChecks = concatMap (\\(nm, _, _, isNotNull, _) ->\n                                           if isNotNull then\n                                            [Db.SomeDatabasePredicate (Db.TableColumnHasConstraint (Db.QualifiedName Nothing tbl) nm (Db.constraintDefinitionSyntax Nothing Db.notNullConstraintSyntax Nothing)\n                                              :: Db.TableColumnHasConstraint Postgres)]\n                                           else [] ) columns\n\n          pure (columnChecks ++ notNullChecks)\n\n     primaryKeys <-\n       map (\\(relnm, cols) -> Db.SomeDatabasePredicate (Db.TableHasPrimaryKey (Db.QualifiedName Nothing relnm) (V.toList cols))) <$>\n       Pg.query_ conn (fromString (unlines [ "SELECT c.relname, array_agg(a.attname ORDER BY k.n ASC)"\n                                           , "FROM pg_index i"\n                                           , "CROSS JOIN unnest(i.indkey) WITH ORDINALITY k(attid, n)"\n                                           , "JOIN pg_attribute a ON a.attnum=k.attid AND a.attrelid=i.indrelid"\n                                           , "JOIN pg_class c ON c.oid=i.indrelid"\n                                           , "JOIN pg_namespace ns ON ns.oid=c.relnamespace"\n                                           , "WHERE ns.nspname = any (current_schemas(false)) AND c.relkind=\'r\' AND i.indisprimary GROUP BY relname, i.indrelid" ]))\n\n     let enumerations =\n           map (\\(enumNm, _, options) -> Db.SomeDatabasePredicate (PgHasEnum enumNm (V.toList options))) enumerationData\n\n     extensions <-\n       map (\\(Pg.Only extname) -> Db.SomeDatabasePredicate (PgHasExtension extname)) <$>\n       Pg.query_ conn "SELECT extname from pg_extension"\n\n     pure (tblsExist ++ columnChecks ++ primaryKeys ++ enumerations ++ extensions)\n\n-- * Postgres-specific data types\n\n-- | \'Db.DataType\' for @tsquery@. See \'TsQuery\' for more information\ntsquery :: Db.DataType Postgres TsQuery\ntsquery = Db.DataType pgTsQueryType\n\n-- | \'Db.DataType\' for @tsvector@. See \'TsVector\' for more information\ntsvector :: Db.DataType Postgres TsVector\ntsvector = Db.DataType pgTsVectorType\n\n-- | \'Db.DataType\' for Postgres @TEXT@. \'characterLargeObject\' is also mapped to\n-- this data type\ntext :: Db.DataType Postgres T.Text\ntext = Db.DataType pgTextType\n\n-- | \'Db.DataType\' for Postgres @BYTEA@. \'binaryLargeObject\' is also mapped to\n-- this data type\nbytea :: Db.DataType Postgres ByteString\nbytea = Db.DataType pgByteaType\n\n-- | \'Db.DataType\' for a Postgres array without any bounds.\n--\n-- Note that array support in @beam-migrate@ is still incomplete.\nunboundedArray :: forall a. Typeable a\n               => Db.DataType Postgres a\n               -> Db.DataType Postgres (V.Vector a)\nunboundedArray (Db.DataType elTy) =\n  Db.DataType (pgUnboundedArrayType elTy)\n\n-- | \'Db.DataType\' for @JSON@. See \'PgJSON\' for more information\njson :: (ToJSON a, FromJSON a) => Db.DataType Postgres (PgJSON a)\njson = Db.DataType pgJsonType\n\n-- | \'Db.DataType\' for @JSONB@. See \'PgJSON\' for more information\njsonb :: (ToJSON a, FromJSON a) => Db.DataType Postgres (PgJSONB a)\njsonb = Db.DataType pgJsonbType\n\n-- | \'Db.DataType\' for @UUID@ columns. The \'pgCryptoGenRandomUUID\' function in\n-- the \'PgCrypto\' extension can be used to generate UUIDs at random.\nuuid :: Db.DataType Postgres UUID\nuuid = Db.DataType pgUuidType\n\n-- | \'Db.DataType\' for @MONEY@ columns.\nmoney :: Db.DataType Postgres PgMoney\nmoney = Db.DataType pgMoneyType\n\npoint :: Db.DataType Postgres PgPoint\npoint = Db.DataType pgPointType\n\nline :: Db.DataType Postgres PgLine\nline = Db.DataType pgLineType\n\nlineSegment :: Db.DataType Postgres PgLineSegment\nlineSegment = Db.DataType pgLineSegmentType\n\nbox :: Db.DataType Postgres PgBox\nbox = Db.DataType pgBoxType\n\n-- * Pseudo-data types\n\n-- | Postgres @SERIAL@ data types. Automatically generates an appropriate\n-- @DEFAULT@ clause and sequence\nsmallserial, serial, bigserial :: Integral a => Db.DataType Postgres (SqlSerial a)\nsmallserial = Db.DataType pgSmallSerialType\nserial = Db.DataType pgSerialType\nbigserial = Db.DataType pgBigSerialType\n\ndata PgHasDefault = PgHasDefault\ninstance Db.FieldReturnType \'True \'False Postgres resTy a =>\n         Db.FieldReturnType \'False \'False Postgres resTy (PgHasDefault -> a) where\n  field\' _ _ nm ty _ collation constraints PgHasDefault =\n    Db.field\' (Proxy @\'True) (Proxy @\'False) nm ty Nothing collation constraints\n\ninstance BeamSqlBackendHasSerial Postgres where\n  genericSerial nm = Db.field nm serial PgHasDefault\n'