b'package com.naman14.timber.widgets;\n\nimport android.graphics.Bitmap;\nimport android.graphics.Canvas;\nimport android.graphics.Paint;\nimport android.graphics.Rect;\nimport android.graphics.drawable.BitmapDrawable;\nimport androidx.annotation.Nullable;\nimport androidx.recyclerview.widget.RecyclerView;\nimport android.util.Log;\nimport android.view.MotionEvent;\nimport android.view.View;\n\n\npublic class DragSortRecycler extends RecyclerView.ItemDecoration implements RecyclerView.OnItemTouchListener {\n\n    final String TAG = "DragSortRecycler";\n\n    final boolean DEBUG = false;\n    OnItemMovedListener moveInterface;\n    @Nullable\n    OnDragStateChangedListener dragStateChangedListener;\n    Paint bgColor = new Paint();\n    private int dragHandleWidth = 0;\n    private int selectedDragItemPos = -1;\n    private int fingerAnchorY;\n    RecyclerView.OnScrollListener scrollListener = new RecyclerView.OnScrollListener() {\n        @Override\n        public void onScrollStateChanged(RecyclerView recyclerView, int newState) {\n            super.onScrollStateChanged(recyclerView, newState);\n        }\n\n        @Override\n        public void onScrolled(RecyclerView recyclerView, int dx, int dy) {\n            super.onScrolled(recyclerView, dx, dy);\n            debugLog("Scrolled: " + dx + " " + dy);\n            fingerAnchorY -= dy;\n        }\n    };\n    private int fingerY;\n    private int fingerOffsetInViewY;\n    private float autoScrollWindow = 0.1f;\n    private float autoScrollSpeed = 0.5f;\n    private BitmapDrawable floatingItem;\n    private Rect floatingItemStatingBounds;\n    private Rect floatingItemBounds;\n    private float floatingItemAlpha = 0.5f;\n    private int floatingItemBgColor = 0;\n    private int viewHandleId = -1;\n    private boolean isDragging;\n\n    private void debugLog(String log) {\n        if (DEBUG)\n            Log.d(TAG, log);\n    }\n\n    public RecyclerView.OnScrollListener getScrollListener() {\n        return scrollListener;\n    }\n\n    /*\n     * Set the item move interface\n     */\n    public void setOnItemMovedListener(OnItemMovedListener swif) {\n        moveInterface = swif;\n    }\n\n    public void setViewHandleId(int id) {\n        viewHandleId = id;\n    }\n\n    public void setLeftDragArea(int w) {\n        dragHandleWidth = w;\n    }\n\n    public void setFloatingAlpha(float a) {\n        floatingItemAlpha = a;\n    }\n\n    public void setFloatingBgColor(int c) {\n        floatingItemBgColor = c;\n    }\n\n    /*\n     Set the window at top and bottom of list, must be between 0 and 0.5\n     For example 0.1 uses the top and bottom 10% of the lists for scrolling\n     */\n    public void setAutoScrollWindow(float w) {\n        autoScrollWindow = w;\n    }\n\n    /*\n    Set the autoscroll speed, default is 0.5\n     */\n    public void setAutoScrollSpeed(float speed) {\n        autoScrollSpeed = speed;\n    }\n\n    @Override\n    public void getItemOffsets(Rect outRect, View view, RecyclerView rv, RecyclerView.State state) {\n        super.getItemOffsets(outRect, view, rv, state);\n\n        debugLog("getItemOffsets");\n\n        debugLog("View top = " + view.getTop());\n        if (selectedDragItemPos != -1) {\n            int itemPos = rv.getChildLayoutPosition(view);\n            debugLog("itemPos =" + itemPos);\n\n            if (!canDragOver(itemPos)) {\n                return;\n            }\n\n            //Movement of finger\n            float totalMovement = fingerY - fingerAnchorY;\n\n            if (itemPos == selectedDragItemPos) {\n                view.setVisibility(View.INVISIBLE);\n            } else {\n                //Make view visible incase invisible\n                view.setVisibility(View.VISIBLE);\n\n                //Find middle of the floatingItem\n                float floatMiddleY = floatingItemBounds.top + floatingItemBounds.height() / 2;\n\n                //Moving down the list\n                //These will auto-animate if the device continually sends touch motion events\n                // if (totalMovment>0)\n                {\n                    if ((itemPos > selectedDragItemPos) && (view.getTop() < floatMiddleY)) {\n                        float amountUp = (floatMiddleY - view.getTop()) / (float) view.getHeight();\n                        //  amountUp *= 0.5f;\n                        if (amountUp > 1)\n                            amountUp = 1;\n\n                        outRect.top = -(int) (floatingItemBounds.height() * amountUp);\n                        outRect.bottom = (int) (floatingItemBounds.height() * amountUp);\n                    }\n\n                }//Moving up the list\n                // else if (totalMovment < 0)\n                {\n                    if ((itemPos < selectedDragItemPos) && (view.getBottom() > floatMiddleY)) {\n                        float amountDown = ((float) view.getBottom() - floatMiddleY) / (float) view.getHeight();\n                        //  amountDown *= 0.5f;\n                        if (amountDown > 1)\n                            amountDown = 1;\n\n                        outRect.top = (int) (floatingItemBounds.height() * amountDown);\n                        outRect.bottom = -(int) (floatingItemBounds.height() * amountDown);\n                    }\n                }\n            }\n        } else {\n            outRect.top = 0;\n            outRect.bottom = 0;\n            //Make view visible incase invisible\n            view.setVisibility(View.VISIBLE);\n        }\n    }\n\n    /**\n     * Find the new position by scanning through the items on\n     * screen and finding the positional relationship.\n     * This *seems* to work, another method would be to use\n     * getItemOffsets, but I think that could miss items?..\n     */\n    private int getNewPostion(RecyclerView rv) {\n        int itemsOnScreen = rv.getLayoutManager().getChildCount();\n\n        float floatMiddleY = floatingItemBounds.top + floatingItemBounds.height() / 2;\n\n        int above = 0;\n        int below = Integer.MAX_VALUE;\n        for (int n = 0; n < itemsOnScreen; n++) //Scan though items on screen, however they may not\n        {                                   // be in order!\n\n            View view = rv.getLayoutManager().getChildAt(n);\n\n            if (view.getVisibility() != View.VISIBLE)\n                continue;\n\n            int itemPos = rv.getChildLayoutPosition(view);\n\n            if (itemPos == selectedDragItemPos) //Don\'t check against itself!\n                continue;\n\n            float viewMiddleY = view.getTop() + view.getHeight() / 2;\n            if (floatMiddleY > viewMiddleY) //Is above this item\n            {\n                if (itemPos > above)\n                    above = itemPos;\n            } else if (floatMiddleY <= viewMiddleY) //Is below this item\n            {\n                if (itemPos < below)\n                    below = itemPos;\n            }\n        }\n        debugLog("above = " + above + " below = " + below);\n\n        if (below != Integer.MAX_VALUE) {\n            if (below < selectedDragItemPos) //Need to count itself\n                below++;\n            return below - 1;\n        } else {\n            if (above < selectedDragItemPos)\n                above++;\n\n            return above;\n        }\n    }\n\n\n    @Override\n    public boolean onInterceptTouchEvent(RecyclerView rv, MotionEvent e) {\n        debugLog("onInterceptTouchEvent");\n\n        //if (e.getAction() == MotionEvent.ACTION_DOWN)\n        {\n            View itemView = rv.findChildViewUnder(e.getX(), e.getY());\n\n            if (itemView == null)\n                return false;\n\n            boolean dragging = false;\n\n            if ((dragHandleWidth > 0) && (e.getX() < dragHandleWidth)) {\n                dragging = true;\n            } else if (viewHandleId != -1) {\n                //Find the handle in the list item\n                View handleView = itemView.findViewById(viewHandleId);\n\n                if (handleView == null) {\n                    Log.e(TAG, "The view ID " + viewHandleId + " was not found in the RecycleView item");\n                    return false;\n                }\n\n                //View should be visible to drag\n                if (handleView.getVisibility() != View.VISIBLE) {\n                    return false;\n                }\n\n                //We need to find the relative position of the handle to the parent view\n                //Then we can work out if the touch is within the handle\n                int[] parentItemPos = new int[2];\n                itemView.getLocationInWindow(parentItemPos);\n\n                int[] handlePos = new int[2];\n                handleView.getLocationInWindow(handlePos);\n\n                int xRel = handlePos[0] - parentItemPos[0];\n                int yRel = handlePos[1] - parentItemPos[1];\n\n                Rect touchBounds = new Rect(itemView.getLeft() + xRel, itemView.getTop() + yRel,\n                        itemView.getLeft() + xRel + handleView.getWidth(),\n                        itemView.getTop() + yRel + handleView.getHeight()\n                );\n\n                if (touchBounds.contains((int) e.getX(), (int) e.getY()))\n                    dragging = true;\n\n                debugLog("parentItemPos = " + parentItemPos[0] + " " + parentItemPos[1]);\n                debugLog("handlePos = " + handlePos[0] + " " + handlePos[1]);\n            }\n\n\n            if (dragging) {\n                debugLog("Started Drag");\n\n                setIsDragging(true);\n\n                floatingItem = createFloatingBitmap(itemView);\n\n                fingerAnchorY = (int) e.getY();\n                fingerOffsetInViewY = fingerAnchorY - itemView.getTop();\n                fingerY = fingerAnchorY;\n\n                selectedDragItemPos = rv.getChildLayoutPosition(itemView);\n                debugLog("selectedDragItemPos = " + selectedDragItemPos);\n\n                return true;\n            }\n        }\n        return false;\n    }\n\n    @Override\n    public void onRequestDisallowInterceptTouchEvent(boolean b) {\n\n    }\n\n    @Override\n    public void onTouchEvent(RecyclerView rv, MotionEvent e) {\n        debugLog("onTouchEvent");\n\n        if ((e.getAction() == MotionEvent.ACTION_UP) ||\n                (e.getAction() == MotionEvent.ACTION_CANCEL)) {\n            if ((e.getAction() == MotionEvent.ACTION_UP) && selectedDragItemPos != -1) {\n                int newPos = getNewPostion(rv);\n                if (moveInterface != null)\n                    moveInterface.onItemMoved(selectedDragItemPos, newPos);\n            }\n\n            setIsDragging(false);\n            selectedDragItemPos = -1;\n            floatingItem = null;\n            rv.invalidateItemDecorations();\n            return;\n        }\n\n\n        fingerY = (int) e.getY();\n\n        if (floatingItem != null) {\n            floatingItemBounds.top = fingerY - fingerOffsetInViewY;\n\n            if (floatingItemBounds.top < -floatingItemStatingBounds.height() / 2) //Allow half the view out the top\n                floatingItemBounds.top = -floatingItemStatingBounds.height() / 2;\n\n            floatingItemBounds.bottom = floatingItemBounds.top + floatingItemStatingBounds.height();\n\n            floatingItem.setBounds(floatingItemBounds);\n        }\n\n        //Do auto scrolling at end of list\n        float scrollAmount = 0;\n        if (fingerY > (rv.getHeight() * (1 - autoScrollWindow))) {\n            scrollAmount = (fingerY - (rv.getHeight() * (1 - autoScrollWindow)));\n        } else if (fingerY < (rv.getHeight() * autoScrollWindow)) {\n            scrollAmount = (fingerY - (rv.getHeight() * autoScrollWindow));\n        }\n        debugLog("Scroll: " + scrollAmount);\n\n        scrollAmount *= autoScrollSpeed;\n        rv.scrollBy(0, (int) scrollAmount);\n\n        rv.invalidateItemDecorations();// Redraw\n    }\n\n    private void setIsDragging(final boolean dragging) {\n        if (dragging != isDragging) {\n            isDragging = dragging;\n            if (dragStateChangedListener != null) {\n                if (isDragging) {\n                    dragStateChangedListener.onDragStart();\n                } else {\n                    dragStateChangedListener.onDragStop();\n                }\n            }\n        }\n    }\n\n    public void setOnDragStateChangedListener(final OnDragStateChangedListener dragStateChangedListener) {\n        this.dragStateChangedListener = dragStateChangedListener;\n    }\n\n    @Override\n    public void onDrawOver(Canvas c, RecyclerView parent, RecyclerView.State state) {\n        if (floatingItem != null) {\n            floatingItem.setAlpha((int) (255 * floatingItemAlpha));\n            bgColor.setColor(floatingItemBgColor);\n            c.drawRect(floatingItemBounds, bgColor);\n            floatingItem.draw(c);\n        }\n    }\n\n    /**\n     * @param position\n     * @return True if we can drag the item over this position, False if not.\n     */\n    protected boolean canDragOver(int position) {\n        return true;\n    }\n\n    private BitmapDrawable createFloatingBitmap(View v) {\n        floatingItemStatingBounds = new Rect(v.getLeft(), v.getTop(), v.getRight(), v.getBottom());\n        floatingItemBounds = new Rect(floatingItemStatingBounds);\n\n        Bitmap bitmap = Bitmap.createBitmap(floatingItemStatingBounds.width(),\n                floatingItemStatingBounds.height(), Bitmap.Config.ARGB_8888);\n        Canvas canvas = new Canvas(bitmap);\n        v.draw(canvas);\n\n        BitmapDrawable retDrawable = new BitmapDrawable(v.getResources(), bitmap);\n        retDrawable.setBounds(floatingItemBounds);\n\n        return retDrawable;\n    }\n\n    public interface OnItemMovedListener {\n        void onItemMoved(int from, int to);\n    }\n\n\n    public interface OnDragStateChangedListener {\n        void onDragStart();\n\n        void onDragStop();\n    }\n}'