b'/*\n * Copyright (C) 2012 Andrew Neal\n * Copyright (C) 2014 The CyanogenMod Project\n * Copyright (C) 2015 Naman Dwivedi\n *\n * Licensed under the Apache License, Version 2.0\n * (the "License"); you may not use this file except in compliance with the\n * License. You may obtain a copy of the License at\n * http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law\n * or agreed to in writing, software distributed under the License is\n * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\npackage com.naman14.timber;\n\nimport android.app.Activity;\nimport android.content.ComponentName;\nimport android.content.ContentResolver;\nimport android.content.ContentUris;\nimport android.content.ContentValues;\nimport android.content.Context;\nimport android.content.ContextWrapper;\nimport android.content.Intent;\nimport android.content.ServiceConnection;\nimport android.database.Cursor;\nimport android.net.Uri;\nimport android.os.IBinder;\nimport android.os.RemoteException;\nimport android.provider.BaseColumns;\nimport android.provider.MediaStore;\nimport android.widget.Toast;\n\nimport com.naman14.timber.dataloaders.SongLoader;\nimport com.naman14.timber.helpers.MusicPlaybackTrack;\nimport com.naman14.timber.utils.TimberUtils.IdType;\n\nimport java.util.Arrays;\nimport java.util.WeakHashMap;\n\npublic class MusicPlayer {\n\n    private static final WeakHashMap<Context, ServiceBinder> mConnectionMap;\n    private static final long[] sEmptyList;\n    public static ITimberService mService = null;\n    private static ContentValues[] mContentValuesCache = null;\n\n    static {\n        mConnectionMap = new WeakHashMap<Context, ServiceBinder>();\n        sEmptyList = new long[0];\n    }\n\n    public static final ServiceToken bindToService(final Context context,\n                                                   final ServiceConnection callback) {\n\n        Activity realActivity = ((Activity) context).getParent();\n        if (realActivity == null) {\n            realActivity = (Activity) context;\n        }\n        final ContextWrapper contextWrapper = new ContextWrapper(realActivity);\n        contextWrapper.startService(new Intent(contextWrapper, MusicService.class));\n        final ServiceBinder binder = new ServiceBinder(callback,\n                contextWrapper.getApplicationContext());\n        if (contextWrapper.bindService(\n                new Intent().setClass(contextWrapper, MusicService.class), binder, 0)) {\n            mConnectionMap.put(contextWrapper, binder);\n            return new ServiceToken(contextWrapper);\n        }\n        return null;\n    }\n\n    public static void unbindFromService(final ServiceToken token) {\n        if (token == null) {\n            return;\n        }\n        final ContextWrapper mContextWrapper = token.mWrappedContext;\n        final ServiceBinder mBinder = mConnectionMap.remove(mContextWrapper);\n        if (mBinder == null) {\n            return;\n        }\n        mContextWrapper.unbindService(mBinder);\n        if (mConnectionMap.isEmpty()) {\n            mService = null;\n        }\n    }\n\n    public static final boolean isPlaybackServiceConnected() {\n        return mService != null;\n    }\n\n    public static void next() {\n        try {\n            if (mService != null) {\n                mService.next();\n            }\n        } catch (final RemoteException ignored) {\n        }\n    }\n\n    public static void initPlaybackServiceWithSettings(final Context context) {\n\n    }\n\n    public static void asyncNext(final Context context) {\n        final Intent previous = new Intent(context, MusicService.class);\n        previous.setAction(MusicService.NEXT_ACTION);\n        context.startService(previous);\n    }\n\n    public static void previous(final Context context, final boolean force) {\n        final Intent previous = new Intent(context, MusicService.class);\n        if (force) {\n            previous.setAction(MusicService.PREVIOUS_FORCE_ACTION);\n        } else {\n            previous.setAction(MusicService.PREVIOUS_ACTION);\n        }\n        context.startService(previous);\n    }\n\n    public static void playOrPause() {\n        try {\n            if (mService != null) {\n                if (mService.isPlaying()) {\n                    mService.pause();\n                } else {\n                    mService.play();\n                }\n            }\n        } catch (final Exception ignored) {\n        }\n    }\n\n    public static void cycleRepeat() {\n        try {\n            if (mService != null) {\n                switch (mService.getRepeatMode()) {\n                    case MusicService.REPEAT_NONE:\n                        mService.setRepeatMode(MusicService.REPEAT_ALL);\n                        break;\n                    case MusicService.REPEAT_ALL:\n                        mService.setRepeatMode(MusicService.REPEAT_CURRENT);\n                        if (mService.getShuffleMode() != MusicService.SHUFFLE_NONE) {\n                            mService.setShuffleMode(MusicService.SHUFFLE_NONE);\n                        }\n                        break;\n                    default:\n                        mService.setRepeatMode(MusicService.REPEAT_NONE);\n                        break;\n                }\n            }\n        } catch (final RemoteException ignored) {\n        }\n    }\n\n    public static void cycleShuffle() {\n        try {\n            if (mService != null) {\n                switch (mService.getShuffleMode()) {\n                    case MusicService.SHUFFLE_NONE:\n                        mService.setShuffleMode(MusicService.SHUFFLE_NORMAL);\n                        if (mService.getRepeatMode() == MusicService.REPEAT_CURRENT) {\n                            mService.setRepeatMode(MusicService.REPEAT_ALL);\n                        }\n                        break;\n                    case MusicService.SHUFFLE_NORMAL:\n                        mService.setShuffleMode(MusicService.SHUFFLE_NONE);\n                        break;\n                    case MusicService.SHUFFLE_AUTO:\n                        mService.setShuffleMode(MusicService.SHUFFLE_NONE);\n                        break;\n                    default:\n                        break;\n                }\n            }\n        } catch (final RemoteException ignored) {\n        }\n    }\n\n    public static final boolean isPlaying() {\n        if (mService != null) {\n            try {\n                return mService.isPlaying();\n            } catch (final RemoteException ignored) {\n            }\n        }\n        return false;\n    }\n\n    public static final int getShuffleMode() {\n        if (mService != null) {\n            try {\n                return mService.getShuffleMode();\n            } catch (final RemoteException ignored) {\n            }\n        }\n        return 0;\n    }\n\n    public static void setShuffleMode(int mode) {\n        try {\n            if (mService != null) {\n                mService.setShuffleMode(mode);\n            }\n        } catch (RemoteException ignored) {\n\n        }\n    }\n\n    public static final int getRepeatMode() {\n        if (mService != null) {\n            try {\n                return mService.getRepeatMode();\n            } catch (final RemoteException ignored) {\n            }\n        }\n        return 0;\n    }\n\n    public static final String getTrackName() {\n        if (mService != null) {\n            try {\n                return mService.getTrackName();\n            } catch (final RemoteException ignored) {\n            }\n        }\n        return null;\n    }\n\n    public static final String getArtistName() {\n        if (mService != null) {\n            try {\n                return mService.getArtistName();\n            } catch (final RemoteException ignored) {\n            }\n        }\n        return null;\n    }\n\n    public static final String getAlbumName() {\n        if (mService != null) {\n            try {\n                return mService.getAlbumName();\n            } catch (final RemoteException ignored) {\n            }\n        }\n        return null;\n    }\n\n    public static final long getCurrentAlbumId() {\n        if (mService != null) {\n            try {\n                return mService.getAlbumId();\n            } catch (final RemoteException ignored) {\n            }\n        }\n        return -1;\n    }\n\n    public static final long getCurrentAudioId() {\n        if (mService != null) {\n            try {\n                return mService.getAudioId();\n            } catch (final RemoteException ignored) {\n            }\n        }\n        return -1;\n    }\n\n    public static final MusicPlaybackTrack getCurrentTrack() {\n        if (mService != null) {\n            try {\n                return mService.getCurrentTrack();\n            } catch (final RemoteException ignored) {\n            }\n        }\n        return null;\n    }\n\n    public static final MusicPlaybackTrack getTrack(int index) {\n        if (mService != null) {\n            try {\n                return mService.getTrack(index);\n            } catch (final RemoteException ignored) {\n            }\n        }\n        return null;\n    }\n\n    public static final long getNextAudioId() {\n        if (mService != null) {\n            try {\n                return mService.getNextAudioId();\n            } catch (final RemoteException ignored) {\n            }\n        }\n        return -1;\n    }\n\n    public static final long getPreviousAudioId() {\n        if (mService != null) {\n            try {\n                return mService.getPreviousAudioId();\n            } catch (final RemoteException ignored) {\n            }\n        }\n        return -1;\n    }\n\n    public static final long getCurrentArtistId() {\n        if (mService != null) {\n            try {\n                return mService.getArtistId();\n            } catch (final RemoteException ignored) {\n            }\n        }\n        return -1;\n    }\n\n    public static final int getAudioSessionId() {\n        if (mService != null) {\n            try {\n                return mService.getAudioSessionId();\n            } catch (final RemoteException ignored) {\n            }\n        }\n        return -1;\n    }\n\n    public static final long[] getQueue() {\n        try {\n            if (mService != null) {\n                return mService.getQueue();\n            } else {\n            }\n        } catch (final RemoteException ignored) {\n        }\n        return sEmptyList;\n    }\n\n    public static final long getQueueItemAtPosition(int position) {\n        try {\n            if (mService != null) {\n                return mService.getQueueItemAtPosition(position);\n            } else {\n            }\n        } catch (final RemoteException ignored) {\n        }\n        return -1;\n    }\n\n    public static final int getQueueSize() {\n        try {\n            if (mService != null) {\n                return mService.getQueueSize();\n            } else {\n            }\n        } catch (final RemoteException ignored) {\n        }\n        return 0;\n    }\n\n    public static final int getQueuePosition() {\n        try {\n            if (mService != null) {\n                return mService.getQueuePosition();\n            }\n        } catch (final RemoteException ignored) {\n        }\n        return 0;\n    }\n\n    public static void setQueuePosition(final int position) {\n        if (mService != null) {\n            try {\n                mService.setQueuePosition(position);\n            } catch (final RemoteException ignored) {\n            }\n        }\n    }\n\n    public static void refresh() {\n        try {\n            if (mService != null) {\n                mService.refresh();\n            }\n        } catch (final RemoteException ignored) {\n        }\n    }\n\n    public static final int getQueueHistorySize() {\n        if (mService != null) {\n            try {\n                return mService.getQueueHistorySize();\n            } catch (final RemoteException ignored) {\n            }\n        }\n        return 0;\n    }\n\n    public static final int getQueueHistoryPosition(int position) {\n        if (mService != null) {\n            try {\n                return mService.getQueueHistoryPosition(position);\n            } catch (final RemoteException ignored) {\n            }\n        }\n        return -1;\n    }\n\n    public static final int[] getQueueHistoryList() {\n        if (mService != null) {\n            try {\n                return mService.getQueueHistoryList();\n            } catch (final RemoteException ignored) {\n            }\n        }\n        return null;\n    }\n\n    public static final int removeTrack(final long id) {\n        try {\n            if (mService != null) {\n                return mService.removeTrack(id);\n            }\n        } catch (final RemoteException ingored) {\n        }\n        return 0;\n    }\n\n    public static final boolean removeTrackAtPosition(final long id, final int position) {\n        try {\n            if (mService != null) {\n                return mService.removeTrackAtPosition(id, position);\n            }\n        } catch (final RemoteException ingored) {\n        }\n        return false;\n    }\n\n    public static void moveQueueItem(final int from, final int to) {\n        try {\n            if (mService != null) {\n                mService.moveQueueItem(from, to);\n            } else {\n            }\n        } catch (final RemoteException ignored) {\n        }\n    }\n\n    public static void playArtist(final Context context, final long artistId, int position, boolean shuffle) {\n        final long[] artistList = getSongListForArtist(context, artistId);\n        if (artistList != null) {\n            playAll(context, artistList, position, artistId, IdType.Artist, shuffle);\n        }\n    }\n\n    public static void playAlbum(final Context context, final long albumId, int position, boolean shuffle) {\n        final long[] albumList = getSongListForAlbum(context, albumId);\n        if (albumList != null) {\n            playAll(context, albumList, position, albumId, IdType.Album, shuffle);\n        }\n    }\n\n    public static void playAll(final Context context, final long[] list, int position,\n                               final long sourceId, final IdType sourceType,\n                               final boolean forceShuffle) {\n        if (list == null || list.length == 0 || mService == null) {\n            return;\n        }\n        try {\n            if (forceShuffle) {\n                mService.setShuffleMode(MusicService.SHUFFLE_NORMAL);\n            }\n            final long currentId = mService.getAudioId();\n            final int currentQueuePosition = getQueuePosition();\n            if (position != -1 && currentQueuePosition == position && currentId == list[position]) {\n                final long[] playlist = getQueue();\n                if (Arrays.equals(list, playlist)) {\n                    mService.play();\n                    return;\n                }\n            }\n            if (position < 0) {\n                position = 0;\n            }\n            mService.open(list, forceShuffle ? -1 : position, sourceId, sourceType.mId);\n            mService.play();\n        } catch (final RemoteException ignored) {\n        } catch (IllegalStateException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public static void playNext(Context context, final long[] list, final long sourceId, final IdType sourceType) {\n        if (mService == null) {\n            return;\n        }\n        try {\n            mService.enqueue(list, MusicService.NEXT, sourceId, sourceType.mId);\n            final String message = makeLabel(context, R.plurals.NNNtrackstoqueue, list.length);\n            Toast.makeText(context, message, Toast.LENGTH_SHORT).show();\n        } catch (final RemoteException ignored) {\n        }\n    }\n\n    public static void shuffleAll(final Context context) {\n        Cursor cursor = SongLoader.makeSongCursor(context, null, null);\n        final long[] trackList = SongLoader.getSongListForCursor(cursor);\n        if (trackList.length == 0 || mService == null) {\n            return;\n        }\n        try {\n            mService.setShuffleMode(MusicService.SHUFFLE_NORMAL);\n            if (getQueuePosition() == 0 && mService.getAudioId() == trackList[0] && Arrays.equals(trackList, getQueue())) {\n                    mService.play();\n                    return;\n            }\n            mService.open(trackList, -1, -1, IdType.NA.mId);\n            mService.play();\n            cursor.close();\n        } catch (final RemoteException ignored) {\n        }\n    }\n\n    public static final long[] getSongListForArtist(final Context context, final long id) {\n        final String[] projection = new String[]{\n                BaseColumns._ID\n        };\n        final String selection = MediaStore.Audio.AudioColumns.ARTIST_ID + "=" + id + " AND "\n                + MediaStore.Audio.AudioColumns.IS_MUSIC + "=1";\n        Cursor cursor = context.getContentResolver().query(\n                MediaStore.Audio.Media.EXTERNAL_CONTENT_URI, projection, selection, null,\n                MediaStore.Audio.AudioColumns.ALBUM_KEY + "," + MediaStore.Audio.AudioColumns.TRACK);\n        if (cursor != null) {\n            final long[] mList = SongLoader.getSongListForCursor(cursor);\n            cursor.close();\n            cursor = null;\n            return mList;\n        }\n        return sEmptyList;\n    }\n\n    public static final long[] getSongListForAlbum(final Context context, final long id) {\n        final String[] projection = new String[]{\n                BaseColumns._ID\n        };\n        final String selection = MediaStore.Audio.AudioColumns.ALBUM_ID + "=" + id + " AND " + MediaStore.Audio.AudioColumns.IS_MUSIC\n                + "=1";\n        Cursor cursor = context.getContentResolver().query(\n                MediaStore.Audio.Media.EXTERNAL_CONTENT_URI, projection, selection, null,\n                MediaStore.Audio.AudioColumns.TRACK + ", " + MediaStore.Audio.Media.DEFAULT_SORT_ORDER);\n        if (cursor != null) {\n            final long[] mList = SongLoader.getSongListForCursor(cursor);\n            cursor.close();\n            cursor = null;\n            return mList;\n        }\n        return sEmptyList;\n    }\n\n    public static final int getSongCountForAlbumInt(final Context context, final long id) {\n        int songCount = 0;\n        if (id == -1) {\n            return songCount;\n        }\n\n        Uri uri = ContentUris.withAppendedId(MediaStore.Audio.Albums.EXTERNAL_CONTENT_URI, id);\n        Cursor cursor = context.getContentResolver().query(uri,\n                new String[]{MediaStore.Audio.AlbumColumns.NUMBER_OF_SONGS}, null, null, null);\n        if (cursor != null) {\n            cursor.moveToFirst();\n            if (!cursor.isAfterLast()) {\n                if (!cursor.isNull(0)) {\n                    songCount = cursor.getInt(0);\n                }\n            }\n            cursor.close();\n            cursor = null;\n        }\n\n        return songCount;\n    }\n\n    public static final String getReleaseDateForAlbum(final Context context, final long id) {\n        if (id == -1) {\n            return null;\n        }\n        Uri uri = ContentUris.withAppendedId(MediaStore.Audio.Albums.EXTERNAL_CONTENT_URI, id);\n        Cursor cursor = context.getContentResolver().query(uri, new String[]{\n                MediaStore.Audio.AlbumColumns.FIRST_YEAR\n        }, null, null, null);\n        String releaseDate = null;\n        if (cursor != null) {\n            cursor.moveToFirst();\n            if (!cursor.isAfterLast()) {\n                releaseDate = cursor.getString(0);\n            }\n            cursor.close();\n            cursor = null;\n        }\n        return releaseDate;\n    }\n\n    public static void seek(final long position) {\n        if (mService != null) {\n            try {\n                mService.seek(position);\n            } catch (final RemoteException ignored) {\n            } catch (IllegalStateException ignored) {\n\n            }\n        }\n    }\n\n    public static void seekRelative(final long deltaInMs) {\n        if (mService != null) {\n            try {\n                mService.seekRelative(deltaInMs);\n            } catch (final RemoteException ignored) {\n            } catch (final IllegalStateException ignored) {\n\n            }\n        }\n    }\n\n    public static final long position() {\n        if (mService != null) {\n            try {\n                return mService.position();\n            } catch (final RemoteException ignored) {\n            } catch (final IllegalStateException ex) {\n\n            }\n        }\n        return 0;\n    }\n\n    public static final long duration() {\n        if (mService != null) {\n            try {\n                return mService.duration();\n            } catch (final RemoteException ignored) {\n            } catch (final IllegalStateException ignored) {\n\n            }\n        }\n        return 0;\n    }\n\n    public static void clearQueue() {\n        if (mService!=null) {\n            try {\n                mService.removeTracks(0, Integer.MAX_VALUE);\n            } catch (final RemoteException ignored) {\n            }\n        }\n    }\n\n    public static void addToQueue(final Context context, final long[] list, long sourceId,\n                                  IdType sourceType) {\n        if (mService == null) {\n            return;\n        }\n        try {\n            mService.enqueue(list, MusicService.LAST, sourceId, sourceType.mId);\n            final String message = makeLabel(context, R.plurals.NNNtrackstoqueue, list.length);\n            Toast.makeText(context, message, Toast.LENGTH_SHORT).show();\n        } catch (final RemoteException ignored) {\n        }\n    }\n\n    public static final String makeLabel(final Context context, final int pluralInt,\n                                         final int number) {\n        return context.getResources().getQuantityString(pluralInt, number, number);\n    }\n\n    public static void addToPlaylist(final Context context, final long[] ids, final long playlistid) {\n        final int size = ids.length;\n        final ContentResolver resolver = context.getContentResolver();\n        final String[] projection = new String[]{\n                "max(" + "play_order" + ")",\n        };\n        final Uri uri = MediaStore.Audio.Playlists.Members.getContentUri("external", playlistid);\n        Cursor cursor = null;\n        int base = 0;\n\n        try {\n            cursor = resolver.query(uri, projection, null, null, null);\n\n            if (cursor != null && cursor.moveToFirst()) {\n                base = cursor.getInt(0) + 1;\n            }\n        } finally {\n            if (cursor != null) {\n                cursor.close();\n                cursor = null;\n            }\n        }\n\n        int numinserted = 0;\n        for (int offSet = 0; offSet < size; offSet += 1000) {\n            makeInsertItems(ids, offSet, 1000, base);\n            numinserted += resolver.bulkInsert(uri, mContentValuesCache);\n        }\n        final String message = context.getResources().getQuantityString(\n                R.plurals.NNNtrackstoplaylist, numinserted, numinserted);\n        Toast.makeText(context, message, Toast.LENGTH_SHORT).show();\n    }\n\n    public static void makeInsertItems(final long[] ids, final int offset, int len, final int base) {\n        if (offset + len > ids.length) {\n            len = ids.length - offset;\n        }\n\n        if (mContentValuesCache == null || mContentValuesCache.length != len) {\n            mContentValuesCache = new ContentValues[len];\n        }\n        for (int i = 0; i < len; i++) {\n            if (mContentValuesCache[i] == null) {\n                mContentValuesCache[i] = new ContentValues();\n            }\n            mContentValuesCache[i].put(MediaStore.Audio.Playlists.Members.PLAY_ORDER, base + offset + i);\n            mContentValuesCache[i].put(MediaStore.Audio.Playlists.Members.AUDIO_ID, ids[offset + i]);\n        }\n    }\n\n    public static final long createPlaylist(final Context context, final String name) {\n        if (name != null && name.length() > 0) {\n            final ContentResolver resolver = context.getContentResolver();\n            final String[] projection = new String[]{\n                    MediaStore.Audio.PlaylistsColumns.NAME\n            };\n            final String selection = MediaStore.Audio.PlaylistsColumns.NAME + " = \'" + name + "\'";\n            Cursor cursor = resolver.query(MediaStore.Audio.Playlists.EXTERNAL_CONTENT_URI,\n                    projection, selection, null, null);\n            if (cursor.getCount() <= 0) {\n                final ContentValues values = new ContentValues(1);\n                values.put(MediaStore.Audio.PlaylistsColumns.NAME, name);\n                final Uri uri = resolver.insert(MediaStore.Audio.Playlists.EXTERNAL_CONTENT_URI,\n                        values);\n                return Long.parseLong(uri.getLastPathSegment());\n            }\n            if (cursor != null) {\n                cursor.close();\n                cursor = null;\n            }\n            return -1;\n        }\n        return -1;\n    }\n\n    public static final void openFile(final String path) {\n        if (mService != null) {\n            try {\n                mService.openFile(path);\n            } catch (final RemoteException ignored) {\n            }\n        }\n    }\n\n    public static final class ServiceBinder implements ServiceConnection {\n        private final ServiceConnection mCallback;\n        private final Context mContext;\n\n\n        public ServiceBinder(final ServiceConnection callback, final Context context) {\n            mCallback = callback;\n            mContext = context;\n        }\n\n        @Override\n        public void onServiceConnected(final ComponentName className, final IBinder service) {\n            mService = ITimberService.Stub.asInterface(service);\n            if (mCallback != null) {\n                mCallback.onServiceConnected(className, service);\n            }\n            initPlaybackServiceWithSettings(mContext);\n        }\n\n        @Override\n        public void onServiceDisconnected(final ComponentName className) {\n            if (mCallback != null) {\n                mCallback.onServiceDisconnected(className);\n            }\n            mService = null;\n        }\n    }\n\n    public static final class ServiceToken {\n        public ContextWrapper mWrappedContext;\n\n        public ServiceToken(final ContextWrapper context) {\n            mWrappedContext = context;\n        }\n    }\n}\n'