b'{-# OPTIONS_GHC -fno-warn-type-defaults #-}\n{-# LANGUAGE NoImplicitPrelude #-}\n{-# LANGUAGE OverloadedStrings #-}\n\nmodule Course.JsonParserSpec where\n\nimport           Data.Ratio        ((%))\nimport           Test.Hspec               (Spec, describe, it, shouldBe)\n\nimport           Course.Core\nimport           Course.JsonParser (jsonArray, jsonFalse, jsonNull, jsonNumber,\n                                    jsonObject, jsonString, jsonTrue, jsonValue)\nimport           Course.JsonValue  (JsonValue (..))\nimport           Course.List       (List (..))\nimport           Course.Parser     (ParseResult (..), isErrorResult, parse)\n\nspec :: Spec\nspec = do\n  describe "jsonString" $ do\n    it "parse whole ASCII input" $\n      parse jsonString "\\" abc\\"" `shouldBe` Result "" " abc"\n    it "parse only the first string of input" $\n      parse jsonString "\\"abc\\"def" `shouldBe` Result "def" "abc"\n    it "parse back slash (\\\\)" $\n      parse jsonString "\\"\\\\babc\\"def" `shouldBe` Result "def" "\\babc"\n    it "parse unicode (\\\\u00abc)" $\n      parse jsonString "\\"\\\\u00abc\\"def" `shouldBe` Result "def" "\xc2\xabc"\n    it "parse unicode (\\\\u00ff)" $\n      parse jsonString "\\"\\\\u00ffabc\\"def" `shouldBe` Result "def" "\xc3\xbfabc"\n    it "parse unicode (\\\\u00fa)" $\n      parse jsonString "\\"\\\\u00faabc\\"def" `shouldBe` Result "def" "\xc3\xbaabc"\n    it "parsing string without quotes is an error" $\n      isErrorResult (parse jsonString "abc") `shouldBe` True\n    it "parsing string containing \\\\a is an error - \\\\a isn\'t a special character" $\n      isErrorResult (parse jsonString "\\"\\\\abc\\"def") `shouldBe` True\n\n  describe "jsonNumber" $ do\n    it "positive whole" $ parse jsonNumber "234" `shouldBe` Result "" (234 % 1)\n    it "negative whole" $ parse jsonNumber "-234" `shouldBe` Result "" ((-234) % 1)\n    it "positive decimal" $ parse jsonNumber "123.45" `shouldBe` Result "" (2469 % 20)\n    it "negative whole (2)" $ parse jsonNumber "-123" `shouldBe` Result "" ((-123) % 1)\n    it "negative decimal" $ parse jsonNumber "-123.45" `shouldBe` Result "" ((-2469) % 20)\n    it "negative sign on its own is error" $ isErrorResult (parse jsonNumber "-") `shouldBe` True\n    it "alphabetic characters is error" $ isErrorResult (parse jsonNumber "abc") `shouldBe` True\n\n  describe "jsonTrue" $ do\n    it "parses true" $ parse jsonTrue "true" `shouldBe` Result "" "true"\n    it "TRUE (caps) is an error" $ isErrorResult (parse jsonTrue "TRUE") `shouldBe` True\n\n  describe "jsonFalse" $ do\n    it "parses false" $ parse jsonFalse "false" `shouldBe` Result "" "false"\n    it "FALSE (caps) is an error" $ isErrorResult (parse jsonFalse "FALSE") `shouldBe` True\n\n  describe "jsonNull" $ do\n    it "parses null" $ parse jsonNull "null" `shouldBe` Result "" "null"\n    it "NULL (caps) is an error" $ isErrorResult (parse jsonNull "NULL") `shouldBe` True\n\n  describe "jsonArray" $ do\n    it "[]" $\n      parse jsonArray "[]"\n        `shouldBe`\n          Result "" Nil\n    it "[true]" $\n      parse jsonArray "[true]"\n        `shouldBe`\n          Result "" (JsonTrue :. Nil)\n    it "[true, \\"abc\\"]" $\n      parse jsonArray "[true, \\"abc\\"]"\n        `shouldBe`\n          Result "" (JsonTrue :. JsonString "abc" :. Nil)\n    it "[true, \\"abc\\", []]" $\n      parse jsonArray "[true, \\"abc\\", []]"\n        `shouldBe`\n          Result "" (JsonTrue :. JsonString "abc" :. JsonArray Nil :. Nil)\n    it "[true, \\"abc\\", [false]]" $ do\n      let\n        result =\n          Result ""\n            (  JsonTrue\n            :. JsonString "abc"\n            :. JsonArray (JsonFalse :. Nil)\n            :. Nil\n            )\n      parse jsonArray "[true, \\"abc\\", [false]]" `shouldBe` result\n\n  describe "jsonObject" $ do\n    it "empty" $\n      parse jsonObject "{}"\n        `shouldBe`\n          Result "" Nil\n    it "one key" $\n      parse jsonObject "{ \\"key1\\" : true }"\n        `shouldBe`\n          Result "" (("key1",JsonTrue) :. Nil)\n    it "two keys" $\n      parse jsonObject "{ \\"key1\\" : true , \\"key2\\" : false }"\n        `shouldBe`\n          Result "" (("key1",JsonTrue):.("key2",JsonFalse):.Nil)\n    it "two keys and left over input" $ do\n      let\n        result =\n          Result "xyz" (("key1",JsonTrue):.("key2",JsonFalse):.Nil)\n      parse jsonObject "{ \\"key1\\" : true , \\"key2\\" : false } xyz" `shouldBe` result\n\n  describe "jsonValue" $ do\n    it "true" $\n      parse jsonValue "true"\n        `shouldBe`\n          Result "" JsonTrue\n    it "object" $ do\n      let\n        result =\n          Result ""\n            (  ("key1",JsonTrue)\n            :. ("key2",JsonArray (JsonRational (7 % 1) :. JsonFalse:.Nil))\n            :. Nil\n            )\n      parse jsonObject "{ \\"key1\\" : true , \\"key2\\" : [7, false] }"\n        `shouldBe`\n          result\n    it "nested object" $ do\n      let\n        result =\n          Result ""\n            (  ("key1",JsonTrue)\n            :. ("key2",JsonArray (JsonRational (7 % 1) :. JsonFalse :. Nil))\n            :. ("key3",JsonObject (("key4",JsonNull) :. Nil))\n            :. Nil\n            )\n        input =\n          "{ \\"key1\\" : true , \\"key2\\" : [7, false] , \\"key3\\" : { \\"key4\\" : null } }"\n      parse jsonObject input `shouldBe` result\n'