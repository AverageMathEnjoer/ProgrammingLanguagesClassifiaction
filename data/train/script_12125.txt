b'package com.rd.animation.type;\n\nimport android.animation.Animator;\nimport android.animation.AnimatorSet;\nimport android.animation.ValueAnimator;\nimport androidx.annotation.NonNull;\nimport android.view.animation.AccelerateDecelerateInterpolator;\nimport com.rd.animation.controller.ValueController;\nimport com.rd.animation.data.type.WormAnimationValue;\n\npublic class WormAnimation extends BaseAnimation<AnimatorSet> {\n\n    int coordinateStart;\n    int coordinateEnd;\n\n    int radius;\n    boolean isRightSide;\n\n    int rectLeftEdge;\n    int rectRightEdge;\n\n    private WormAnimationValue value;\n\n    public WormAnimation(@NonNull ValueController.UpdateListener listener) {\n        super(listener);\n        value = new WormAnimationValue();\n    }\n\n    @NonNull\n    @Override\n    public AnimatorSet createAnimator() {\n        AnimatorSet animator = new AnimatorSet();\n        animator.setInterpolator(new AccelerateDecelerateInterpolator());\n\n        return animator;\n    }\n\n    @Override\n    public WormAnimation duration(long duration) {\n        super.duration(duration);\n        return this;\n    }\n\n    public WormAnimation with(int coordinateStart, int coordinateEnd, int radius, boolean isRightSide) {\n        if (hasChanges(coordinateStart, coordinateEnd, radius, isRightSide)) {\n            animator = createAnimator();\n\n            this.coordinateStart = coordinateStart;\n            this.coordinateEnd = coordinateEnd;\n\n            this.radius = radius;\n            this.isRightSide = isRightSide;\n\n            rectLeftEdge = coordinateStart - radius;\n            rectRightEdge = coordinateStart + radius;\n\n            value.setRectStart(rectLeftEdge);\n            value.setRectEnd(rectRightEdge);\n\n            RectValues rect = createRectValues(isRightSide);\n            long duration = animationDuration / 2;\n\n            ValueAnimator straightAnimator = createWormAnimator(rect.fromX, rect.toX, duration, false, value);\n            ValueAnimator reverseAnimator = createWormAnimator(rect.reverseFromX, rect.reverseToX, duration, true, value);\n            animator.playSequentially(straightAnimator, reverseAnimator);\n        }\n        return this;\n    }\n\n    @Override\n    public WormAnimation progress(float progress) {\n        if (animator == null) {\n            return this;\n        }\n\n        long progressDuration = (long) (progress * animationDuration);\n        for (Animator anim : animator.getChildAnimations()) {\n            ValueAnimator animator = (ValueAnimator) anim;\n            long duration = animator.getDuration();\n            long setDuration = progressDuration;\n\n            if (setDuration > duration) {\n                setDuration = duration;\n            }\n\n            animator.setCurrentPlayTime(setDuration);\n            progressDuration -= setDuration;\n        }\n\n        return this;\n    }\n\n    ValueAnimator createWormAnimator(\n            int fromValue,\n            int toValue,\n            long duration,\n            final boolean isReverse,\n            final WormAnimationValue value) {\n\n        ValueAnimator anim = ValueAnimator.ofInt(fromValue, toValue);\n        anim.setInterpolator(new AccelerateDecelerateInterpolator());\n        anim.setDuration(duration);\n        anim.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {\n            @Override\n            public void onAnimationUpdate(ValueAnimator animation) {\n                onAnimateUpdated(value, animation, isReverse);\n            }\n        });\n\n        return anim;\n    }\n\n    private void onAnimateUpdated(@NonNull WormAnimationValue value, @NonNull ValueAnimator animation, final boolean isReverse) {\n        int rectEdge = (int) animation.getAnimatedValue();\n\n        if (isRightSide) {\n            if (!isReverse) {\n                value.setRectEnd(rectEdge);\n            } else {\n                value.setRectStart(rectEdge);\n            }\n\n        } else {\n            if (!isReverse) {\n                value.setRectStart(rectEdge);\n            } else {\n                value.setRectEnd(rectEdge);\n            }\n        }\n\n        if (listener != null) {\n            listener.onValueUpdated(value);\n        }\n    }\n\n    @SuppressWarnings("RedundantIfStatement")\n    boolean hasChanges(int coordinateStart, int coordinateEnd, int radius, boolean isRightSide) {\n        if (this.coordinateStart != coordinateStart) {\n            return true;\n        }\n\n        if (this.coordinateEnd != coordinateEnd) {\n            return true;\n        }\n\n        if (this.radius != radius) {\n            return true;\n        }\n\n        if (this.isRightSide != isRightSide) {\n            return true;\n        }\n\n        return false;\n    }\n\n    @NonNull\n    RectValues createRectValues(boolean isRightSide) {\n        int fromX;\n        int toX;\n\n        int reverseFromX;\n        int reverseToX;\n\n        if (isRightSide) {\n            fromX = coordinateStart + radius;\n            toX = coordinateEnd + radius;\n\n            reverseFromX = coordinateStart - radius;\n            reverseToX = coordinateEnd - radius;\n\n        } else {\n            fromX = coordinateStart - radius;\n            toX = coordinateEnd - radius;\n\n            reverseFromX = coordinateStart + radius;\n            reverseToX = coordinateEnd + radius;\n        }\n\n        return new RectValues(fromX, toX, reverseFromX, reverseToX);\n    }\n\n    class RectValues {\n\n        final int fromX;\n        final int toX;\n\n        final int reverseFromX;\n        final int reverseToX;\n\n        RectValues(int fromX, int toX, int reverseFromX, int reverseToX) {\n            this.fromX = fromX;\n            this.toX = toX;\n\n            this.reverseFromX = reverseFromX;\n            this.reverseToX = reverseToX;\n        }\n    }\n}\n'