b'{-# OPTIONS_GHC -fno-warn-type-defaults #-}\n{-# LANGUAGE NoImplicitPrelude   #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n\nmodule Course.StateSpec where\n\nimport           Data.List                (nub)\nimport qualified Prelude                  as P ((++))\n\nimport           Test.Hspec               (Spec, describe, it, shouldBe)\nimport           Test.Hspec.QuickCheck    (prop)\nimport           Test.QuickCheck.Function (Fun (..))\n\nimport           Course.Applicative       (pure, (<*>))\nimport           Course.Core\nimport           Course.Functor           ((<$>))\nimport           Course.Gens              (forAllLists)\nimport           Course.List              (List (..), filter, flatMap, hlist,\n                                           length, listh, span, (++))\nimport           Course.Monad\nimport           Course.Optional          (Optional (..))\nimport           Course.State             (State (..), distinct, eval, exec,\n                                           findM, firstRepeat, get, isHappy,\n                                           put, runState)\n\nspec :: Spec\nspec = do\n  describe "State methods" $ do\n    prop "exec" $\n      \\(Fun _ f :: Fun Integer (Integer, Integer)) s -> exec (State f) s == snd (runState (State f) s)\n\n    prop "eval" $\n      \\(Fun _ f :: Fun Integer (Integer, Integer)) s -> eval (State f) s == fst (runState (State f) s)\n\n    it "get" $ runState get 0 `shouldBe` (0,0)\n\n    it "put" $ runState (put 1) 0 `shouldBe` ((),1)\n\n    it "(<$>)" $\n      runState ((+1) <$> State (\\s -> (9, s * 2))) 3 `shouldBe` (10,6)\n\n  describe "Applicative" $ do\n    it "pure" $ runState (pure 2) 0 `shouldBe` (2,0)\n    it "<*>" $ runState (pure (+1) <*> pure 0) 0 `shouldBe` (1,0)\n    it "complicated <*>" $\n      let state = State (\\s -> ((+3), s P.++ ["apple"])) <*> State (\\s -> (7, s P.++ ["banana"]))\n       in runState state [] `shouldBe` (10,["apple","banana"])\n\n  describe "Monad" $ do\n    it "(=<<)" $\n      runState ((const $ put 2) =<< put 1) 0 `shouldBe` ((),2)\n    it "(>>=)" $\n      let modify f = State (\\s -> ((), f s))\n       in runState (modify (+1) >>= \\() -> modify (*2)) 7  `shouldBe` ((),16)\n\n  describe "findM" $ do\n    it "find \'c\' in \'a\'..\'h\'" $\n      let p x = (\\s -> (const $ pure (x == \'c\')) =<< put (1+s)) =<< get\n       in runState (findM p $ listh [\'a\'..\'h\']) 0 `shouldBe` (Full \'c\',3)\n    it "find \'i\' in \'a\'..\'h\'" $\n      let p x = (\\s -> (const $ pure (x == \'i\')) =<< put (1+s)) =<< get\n       in runState (findM p $ listh [\'a\'..\'h\']) 0 `shouldBe` (Empty,8)\n\n  describe "firstRepeat" $ do\n    prop "finds repeats" $ forAllLists $ \\xs ->\n      case firstRepeat xs of\n        Empty ->\n          let xs\' = hlist xs\n           in nub xs\' == xs\'\n        Full x -> length (filter (== x) xs) > 1\n    prop "" $ forAllLists $ \\xs ->\n      case firstRepeat xs of\n        Empty -> True\n        Full x ->\n          let\n            (l, (rx :. rs)) = span (/= x) xs\n            (l2, _) = span (/= x) rs\n            l3 = hlist (l ++ (rx :. Nil) ++ l2)\n          in\n            nub l3 == l3\n\n  describe "distinct" $ do\n    prop "No repeats after distinct" $\n      forAllLists (\\xs -> firstRepeat (distinct xs) == Empty)\n    prop "" $\n      forAllLists (\\xs -> distinct xs == distinct (flatMap (\\x -> x :. x :. Nil) xs))\n\n  describe "isHappy" $ do\n    it "4" $ isHappy 4 `shouldBe` False\n    it "7" $ isHappy 7 `shouldBe` True\n    it "42" $ isHappy 42 `shouldBe`  False\n    it "44" $ isHappy 44 `shouldBe`  True\n'