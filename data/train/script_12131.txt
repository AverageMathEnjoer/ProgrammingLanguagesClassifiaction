b'/**\n * MIT License\n *\n * Copyright (c) 2017 Thibaut Goetghebuer-Planchon <tessil@gmx.com>\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the "Software"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n#define BOOST_TEST_DYN_LINK\n\n#include <tsl/robin_map.h>\n\n#include <boost/mpl/list.hpp>\n#include <boost/test/unit_test.hpp>\n#include <cstddef>\n#include <cstdint>\n#include <functional>\n#include <iterator>\n#include <memory>\n#include <stdexcept>\n#include <string>\n#include <tuple>\n#include <type_traits>\n#include <utility>\n#include <vector>\n\n#include "utils.h"\n\nBOOST_AUTO_TEST_SUITE(test_robin_map)\n\nusing test_types = boost::mpl::list<\n    tsl::robin_map<std::int64_t, std::int64_t>, tsl::robin_map<std::string, std::string>,\n    // Test with hash having a lot of collisions\n    tsl::robin_map<std::int64_t, std::int64_t, mod_hash<9>>, tsl::robin_map<std::string, std::string, mod_hash<9>>,\n    tsl::robin_map<move_only_test, move_only_test, mod_hash<9>>,\n    tsl::robin_map<copy_only_test, copy_only_test, mod_hash<9>>,\n    tsl::robin_map<self_reference_member_test, self_reference_member_test, mod_hash<9>>,\n\n    // other GrowthPolicy\n    tsl::robin_map<move_only_test, move_only_test, mod_hash<9>, std::equal_to<move_only_test>,\n                   std::allocator<std::pair<move_only_test, move_only_test>>, true,\n                   tsl::rh::power_of_two_growth_policy<4>>,\n    tsl::robin_pg_map<move_only_test, move_only_test, mod_hash<9>>,\n    tsl::robin_map<move_only_test, move_only_test, mod_hash<9>, std::equal_to<move_only_test>,\n                   std::allocator<std::pair<move_only_test, move_only_test>>, false, tsl::rh::mod_growth_policy<>>,\n\n    tsl::robin_map<copy_only_test, copy_only_test, mod_hash<9>, std::equal_to<copy_only_test>,\n                   std::allocator<std::pair<copy_only_test, copy_only_test>>, false,\n                   tsl::rh::power_of_two_growth_policy<4>>,\n    tsl::robin_pg_map<copy_only_test, copy_only_test, mod_hash<9>>,\n    tsl::robin_map<copy_only_test, copy_only_test, mod_hash<9>, std::equal_to<copy_only_test>,\n                   std::allocator<std::pair<copy_only_test, copy_only_test>>, true, tsl::rh::mod_growth_policy<>>>;\n\n/**\n * insert\n */\nBOOST_AUTO_TEST_CASE_TEMPLATE(test_insert, HMap, test_types)\n{\n    // insert x values, insert them again, check values\n    using key_t = typename HMap::key_type;\n    using value_t = typename HMap::mapped_type;\n\n    const std::size_t nb_values = 1000;\n    HMap map(0);\n    BOOST_CHECK_EQUAL(map.bucket_count(), 0);\n\n    typename HMap::iterator it;\n    bool inserted;\n\n    for (std::size_t i = 0; i < nb_values; i++) {\n        std::tie(it, inserted) = map.insert({utils::get_key<key_t>(i), utils::get_value<value_t>(i)});\n\n        BOOST_CHECK_EQUAL(it->first, utils::get_key<key_t>(i));\n        BOOST_CHECK_EQUAL(it->second, utils::get_value<value_t>(i));\n        BOOST_CHECK(inserted);\n    }\n    BOOST_CHECK_EQUAL(map.size(), nb_values);\n\n    for (std::size_t i = 0; i < nb_values; i++) {\n        std::tie(it, inserted) = map.insert({utils::get_key<key_t>(i), utils::get_value<value_t>(i + 1)});\n\n        BOOST_CHECK_EQUAL(it->first, utils::get_key<key_t>(i));\n        BOOST_CHECK_EQUAL(it->second, utils::get_value<value_t>(i));\n        BOOST_CHECK(!inserted);\n    }\n\n    for (std::size_t i = 0; i < nb_values; i++) {\n        it = map.find(utils::get_key<key_t>(i));\n\n        BOOST_CHECK_EQUAL(it->first, utils::get_key<key_t>(i));\n        BOOST_CHECK_EQUAL(it->second, utils::get_value<value_t>(i));\n    }\n}\n\nBOOST_AUTO_TEST_CASE(test_range_insert)\n{\n    // create a vector<std::pair> of values to insert, insert part of them in the\n    // map, check values\n    const int nb_values = 1000;\n    std::vector<std::pair<int, int>> values_to_insert(nb_values);\n    for (int i = 0; i < nb_values; i++) {\n        values_to_insert[i] = std::make_pair(i, i + 1);\n    }\n\n    tsl::robin_map<int, int> map = {{-1, 1}, {-2, 2}};\n    map.insert(std::next(values_to_insert.begin(), 10), values_to_insert.end() - 5);\n\n    BOOST_CHECK_EQUAL(map.size(), 987);\n\n    BOOST_CHECK_EQUAL(map.at(-1), 1);\n    BOOST_CHECK_EQUAL(map.at(-2), 2);\n\n    for (int i = 10; i < nb_values - 5; i++) {\n        BOOST_CHECK_EQUAL(map.at(i), i + 1);\n    }\n}\n\nBOOST_AUTO_TEST_CASE(test_insert_with_hint)\n{\n    tsl::robin_map<int, int> map {{1, 0}, {2, 1}, {3, 2}};\n\n    // Wrong hint\n    BOOST_CHECK(map.insert(map.find(2), std::make_pair(3, 4)) == map.find(3));\n\n    // Good hint\n    BOOST_CHECK(map.insert(map.find(2), std::make_pair(2, 4)) == map.find(2));\n\n    // end() hint\n    BOOST_CHECK(map.insert(map.find(10), std::make_pair(2, 4)) == map.find(2));\n\n    BOOST_CHECK_EQUAL(map.size(), 3);\n\n    // end() hint, new value\n    BOOST_CHECK_EQUAL(map.insert(map.find(10), std::make_pair(4, 3))->first, 4);\n\n    // Wrong hint, new value\n    BOOST_CHECK_EQUAL(map.insert(map.find(2), std::make_pair(5, 4))->first, 5);\n\n    BOOST_CHECK_EQUAL(map.size(), 5);\n}\n\n/**\n * emplace_hint\n */\nBOOST_AUTO_TEST_CASE(test_emplace_hint)\n{\n    tsl::robin_map<int, int> map {{1, 0}, {2, 1}, {3, 2}};\n\n    // Wrong hint\n    BOOST_CHECK(\n        map.emplace_hint(map.find(2), std::piecewise_construct, std::forward_as_tuple(3), std::forward_as_tuple(4))\n        == map.find(3));\n\n    // Good hint\n    BOOST_CHECK(\n        map.emplace_hint(map.find(2), std::piecewise_construct, std::forward_as_tuple(2), std::forward_as_tuple(4))\n        == map.find(2));\n\n    // end() hint\n    BOOST_CHECK(\n        map.emplace_hint(map.find(10), std::piecewise_construct, std::forward_as_tuple(2), std::forward_as_tuple(4))\n        == map.find(2));\n\n    BOOST_CHECK_EQUAL(map.size(), 3);\n\n    // end() hint, new value\n    BOOST_CHECK_EQUAL(\n        map.emplace_hint(map.find(10), std::piecewise_construct, std::forward_as_tuple(4), std::forward_as_tuple(3))\n            ->first,\n        4);\n\n    // Wrong hint, new value\n    BOOST_CHECK_EQUAL(\n        map.emplace_hint(map.find(2), std::piecewise_construct, std::forward_as_tuple(5), std::forward_as_tuple(4))\n            ->first,\n        5);\n\n    BOOST_CHECK_EQUAL(map.size(), 5);\n}\n\n/**\n * emplace\n */\nBOOST_AUTO_TEST_CASE(test_emplace)\n{\n    tsl::robin_map<std::int64_t, move_only_test> map;\n    tsl::robin_map<std::int64_t, move_only_test>::iterator it;\n    bool inserted;\n\n    std::tie(it, inserted) = map.emplace(std::piecewise_construct, std::forward_as_tuple(10), std::forward_as_tuple(1));\n    BOOST_CHECK_EQUAL(it->first, 10);\n    BOOST_CHECK_EQUAL(it->second, move_only_test(1));\n    BOOST_CHECK(inserted);\n\n    std::tie(it, inserted) = map.emplace(std::piecewise_construct, std::forward_as_tuple(10), std::forward_as_tuple(3));\n    BOOST_CHECK_EQUAL(it->first, 10);\n    BOOST_CHECK_EQUAL(it->second, move_only_test(1));\n    BOOST_CHECK(!inserted);\n}\n\n/**\n * try_emplace\n */\nBOOST_AUTO_TEST_CASE(test_try_emplace)\n{\n    tsl::robin_map<std::int64_t, move_only_test> map;\n    tsl::robin_map<std::int64_t, move_only_test>::iterator it;\n    bool inserted;\n\n    std::tie(it, inserted) = map.try_emplace(10, 1);\n    BOOST_CHECK_EQUAL(it->first, 10);\n    BOOST_CHECK_EQUAL(it->second, move_only_test(1));\n    BOOST_CHECK(inserted);\n\n    std::tie(it, inserted) = map.try_emplace(10, 3);\n    BOOST_CHECK_EQUAL(it->first, 10);\n    BOOST_CHECK_EQUAL(it->second, move_only_test(1));\n    BOOST_CHECK(!inserted);\n}\n\nBOOST_AUTO_TEST_CASE(test_try_emplace_2)\n{\n    // Insert x values with try_emplace, insert them again, check with find.\n    tsl::robin_map<std::string, move_only_test> map;\n    tsl::robin_map<std::string, move_only_test>::iterator it;\n    bool inserted;\n\n    const std::size_t nb_values = 1000;\n    for (std::size_t i = 0; i < nb_values; i++) {\n        std::tie(it, inserted) = map.try_emplace(utils::get_key<std::string>(i), i);\n\n        BOOST_CHECK_EQUAL(it->first, utils::get_key<std::string>(i));\n        BOOST_CHECK_EQUAL(it->second, move_only_test(i));\n        BOOST_CHECK(inserted);\n    }\n    BOOST_CHECK_EQUAL(map.size(), nb_values);\n\n    for (std::size_t i = 0; i < nb_values; i++) {\n        std::tie(it, inserted) = map.try_emplace(utils::get_key<std::string>(i), i + 1);\n\n        BOOST_CHECK_EQUAL(it->first, utils::get_key<std::string>(i));\n        BOOST_CHECK_EQUAL(it->second, move_only_test(i));\n        BOOST_CHECK(!inserted);\n    }\n\n    for (std::size_t i = 0; i < nb_values; i++) {\n        it = map.find(utils::get_key<std::string>(i));\n\n        BOOST_CHECK_EQUAL(it->first, utils::get_key<std::string>(i));\n        BOOST_CHECK_EQUAL(it->second, move_only_test(i));\n    }\n}\n\nBOOST_AUTO_TEST_CASE(test_try_emplace_hint)\n{\n    tsl::robin_map<std::int64_t, move_only_test> map(0);\n\n    // end() hint, new value\n    auto it = map.try_emplace(map.find(10), 10, 1);\n    BOOST_CHECK_EQUAL(it->first, 10);\n    BOOST_CHECK_EQUAL(it->second, move_only_test(1));\n\n    // Good hint\n    it = map.try_emplace(map.find(10), 10, 3);\n    BOOST_CHECK_EQUAL(it->first, 10);\n    BOOST_CHECK_EQUAL(it->second, move_only_test(1));\n\n    // Wrong hint, new value\n    it = map.try_emplace(map.find(10), 1, 3);\n    BOOST_CHECK_EQUAL(it->first, 1);\n    BOOST_CHECK_EQUAL(it->second, move_only_test(3));\n}\n\n/**\n * insert_or_assign\n */\nBOOST_AUTO_TEST_CASE(test_insert_or_assign)\n{\n    tsl::robin_map<std::int64_t, move_only_test> map;\n    tsl::robin_map<std::int64_t, move_only_test>::iterator it;\n    bool inserted;\n\n    std::tie(it, inserted) = map.insert_or_assign(10, move_only_test(1));\n    BOOST_CHECK_EQUAL(it->first, 10);\n    BOOST_CHECK_EQUAL(it->second, move_only_test(1));\n    BOOST_CHECK(inserted);\n\n    std::tie(it, inserted) = map.insert_or_assign(10, move_only_test(3));\n    BOOST_CHECK_EQUAL(it->first, 10);\n    BOOST_CHECK_EQUAL(it->second, move_only_test(3));\n    BOOST_CHECK(!inserted);\n}\n\nBOOST_AUTO_TEST_CASE(test_insert_or_assign_hint)\n{\n    tsl::robin_map<std::int64_t, move_only_test> map(0);\n\n    // end() hint, new value\n    auto it = map.insert_or_assign(map.find(10), 10, move_only_test(1));\n    BOOST_CHECK_EQUAL(it->first, 10);\n    BOOST_CHECK_EQUAL(it->second, move_only_test(1));\n\n    // Good hint\n    it = map.insert_or_assign(map.find(10), 10, move_only_test(3));\n    BOOST_CHECK_EQUAL(it->first, 10);\n    BOOST_CHECK_EQUAL(it->second, move_only_test(3));\n\n    // Bad hint, new value\n    it = map.insert_or_assign(map.find(10), 1, move_only_test(3));\n    BOOST_CHECK_EQUAL(it->first, 1);\n    BOOST_CHECK_EQUAL(it->second, move_only_test(3));\n}\n\n/**\n * erase\n */\nBOOST_AUTO_TEST_CASE(test_range_erase_all)\n{\n    // insert x values, delete all with iterators\n    using HMap = tsl::robin_map<std::string, std::int64_t>;\n\n    const std::size_t nb_values = 1000;\n    HMap map = utils::get_filled_hash_map<HMap>(nb_values);\n\n    auto it = map.erase(map.begin(), map.end());\n    BOOST_CHECK(it == map.end());\n    BOOST_CHECK(map.empty());\n}\n\nBOOST_AUTO_TEST_CASE(test_range_erase)\n{\n    // insert x values, delete all with iterators except 10 first and 780 last\n    // values\n    using HMap = tsl::robin_map<std::string, std::int64_t>;\n\n    const std::size_t nb_values = 1000;\n    HMap map = utils::get_filled_hash_map<HMap>(nb_values);\n\n    auto it_first = std::next(map.begin(), 10);\n    auto it_last = std::next(map.begin(), 220);\n\n    auto it = map.erase(it_first, it_last);\n    BOOST_CHECK_EQUAL(std::distance(it, map.end()), 780);\n    BOOST_CHECK_EQUAL(map.size(), 790);\n    BOOST_CHECK_EQUAL(std::distance(map.begin(), map.end()), 790);\n\n    for (auto& val : map) {\n        BOOST_CHECK_EQUAL(map.count(val.first), 1);\n    }\n}\n\nBOOST_AUTO_TEST_CASE_TEMPLATE(test_erase_loop, HMap, test_types)\n{\n    // insert x values, delete all one by one with iterator\n    std::size_t nb_values = 1000;\n\n    HMap map = utils::get_filled_hash_map<HMap>(nb_values);\n    HMap map2 = utils::get_filled_hash_map<HMap>(nb_values);\n\n    auto it = map.begin();\n    // Use second map to check for key after delete as we may not copy the key\n    // with move-only types.\n    auto it2 = map2.begin();\n    while (it != map.end()) {\n        it = map.erase(it);\n        --nb_values;\n\n        BOOST_CHECK_EQUAL(map.count(it2->first), 0);\n        BOOST_CHECK_EQUAL(map.size(), nb_values);\n        ++it2;\n    }\n\n    BOOST_CHECK(map.empty());\n}\n\nBOOST_AUTO_TEST_CASE_TEMPLATE(test_erase_loop_range, HMap, test_types)\n{\n    // insert x values, delete all five by five with iterators\n    const std::size_t hop = 5;\n    std::size_t nb_values = 1000;\n\n    BOOST_REQUIRE_EQUAL(nb_values % hop, 0);\n\n    HMap map = utils::get_filled_hash_map<HMap>(nb_values);\n\n    auto it = map.begin();\n    while (it != map.end()) {\n        it = map.erase(it, std::next(it, hop));\n        nb_values -= hop;\n\n        BOOST_CHECK_EQUAL(map.size(), nb_values);\n    }\n\n    BOOST_CHECK(map.empty());\n}\n\nBOOST_AUTO_TEST_CASE_TEMPLATE(test_insert_erase_insert, HMap, test_types)\n{\n    // insert x/2 values, delete x/4 values, insert x/2 values, find each value\n    using key_t = typename HMap::key_type;\n    using value_t = typename HMap::mapped_type;\n\n    const std::size_t nb_values = 2000;\n    HMap map(10);\n    typename HMap::iterator it;\n    bool inserted;\n\n    // Insert nb_values/2\n    for (std::size_t i = 0; i < nb_values / 2; i++) {\n        std::tie(it, inserted) = map.insert({utils::get_key<key_t>(i), utils::get_value<value_t>(i)});\n\n        BOOST_CHECK_EQUAL(it->first, utils::get_key<key_t>(i));\n        BOOST_CHECK_EQUAL(it->second, utils::get_value<value_t>(i));\n        BOOST_CHECK(inserted);\n    }\n    BOOST_CHECK_EQUAL(map.size(), nb_values / 2);\n\n    // Delete nb_values/4\n    for (std::size_t i = 0; i < nb_values / 2; i++) {\n        if (i % 2 == 0) {\n            BOOST_CHECK_EQUAL(map.erase(utils::get_key<key_t>(i)), 1);\n        }\n    }\n    BOOST_CHECK_EQUAL(map.size(), nb_values / 4);\n\n    // Insert nb_values/2\n    for (std::size_t i = nb_values / 2; i < nb_values; i++) {\n        std::tie(it, inserted) = map.insert({utils::get_key<key_t>(i), utils::get_value<value_t>(i)});\n\n        BOOST_CHECK_EQUAL(it->first, utils::get_key<key_t>(i));\n        BOOST_CHECK_EQUAL(it->second, utils::get_value<value_t>(i));\n        BOOST_CHECK(inserted);\n    }\n    BOOST_CHECK_EQUAL(map.size(), nb_values - nb_values / 4);\n\n    // Find\n    for (std::size_t i = 0; i < nb_values; i++) {\n        if (i % 2 == 0 && i < nb_values / 2) {\n            it = map.find(utils::get_key<key_t>(i));\n\n            BOOST_CHECK(it == map.end());\n        } else {\n            it = map.find(utils::get_key<key_t>(i));\n\n            BOOST_REQUIRE(it != map.end());\n            BOOST_CHECK_EQUAL(it->first, utils::get_key<key_t>(i));\n            BOOST_CHECK_EQUAL(it->second, utils::get_value<value_t>(i));\n        }\n    }\n}\n\nBOOST_AUTO_TEST_CASE(test_range_erase_same_iterators)\n{\n    // insert x values, test erase with same iterator as each parameter, check if\n    // returned mutable iterator is valid.\n    const std::size_t nb_values = 100;\n    auto map = utils::get_filled_hash_map<tsl::robin_map<std::int64_t, std::int64_t>>(nb_values);\n\n    tsl::robin_map<std::int64_t, std::int64_t>::const_iterator it_const = map.cbegin();\n    std::advance(it_const, 10);\n\n    tsl::robin_map<std::int64_t, std::int64_t>::iterator it_mutable = map.erase(it_const, it_const);\n    BOOST_CHECK(it_const == it_mutable);\n    BOOST_CHECK(map.mutable_iterator(it_const) == it_mutable);\n    BOOST_CHECK_EQUAL(map.size(), 100);\n\n    it_mutable.value() = -100;\n    BOOST_CHECK_EQUAL(it_const.value(), -100);\n}\n\n/**\n * max_load_factor\n */\nBOOST_AUTO_TEST_CASE(test_max_load_factor_extreme_factors)\n{\n    tsl::robin_map<std::int64_t, std::int64_t> map;\n\n    map.max_load_factor(0.0f);\n    BOOST_CHECK_GT(map.max_load_factor(), 0.0f);\n\n    map.max_load_factor(10.0f);\n    BOOST_CHECK_LT(map.max_load_factor(), 1.0f);\n}\n\n/**\n * min_load_factor\n */\nBOOST_AUTO_TEST_CASE(test_min_load_factor_extreme_factors)\n{\n    tsl::robin_map<std::int64_t, std::int64_t> map;\n\n    BOOST_CHECK_EQUAL(map.min_load_factor(), 0.0f);\n    BOOST_CHECK_LT(map.min_load_factor(), map.max_load_factor());\n\n    map.min_load_factor(-10.0f);\n    BOOST_CHECK_EQUAL(map.min_load_factor(), 0.0f);\n\n    map.min_load_factor(0.9f);\n    map.max_load_factor(0.1f);\n\n    // max_load_factor should always be > min_load_factor.\n    // Factors should have been clamped.\n    BOOST_CHECK_LT(map.min_load_factor(), map.max_load_factor());\n}\n\nBOOST_AUTO_TEST_CASE(test_min_load_factor)\n{\n    // set min_load_factor to 0.15 and max_load_factor to 0.5.\n    // rehash to 100 buckets, insert 50 elements, erase until load_factor() <\n    // min_load_factor(), insert an element, check if map has shrinked.\n    const std::size_t nb_values = 50;\n    tsl::robin_map<std::int64_t, std::int64_t> map;\n\n    map.min_load_factor(0.15f);\n    BOOST_CHECK_EQUAL(map.min_load_factor(), 0.15f);\n\n    map.max_load_factor(0.5f);\n    BOOST_CHECK_EQUAL(map.max_load_factor(), 0.5f);\n\n    map.rehash(nb_values * 2);\n    for (std::size_t i = 0; i < nb_values; i++) {\n        map.insert({utils::get_key<std::int64_t>(i), utils::get_value<std::int64_t>(i)});\n    }\n    BOOST_CHECK_GT(map.load_factor(), map.min_load_factor());\n\n    while (map.load_factor() >= map.min_load_factor()) {\n        map.erase(map.begin());\n    }\n\n    // Shrink is done on insert.\n    map.insert({utils::get_key<std::int64_t>(map.bucket_count()), utils::get_value<std::int64_t>(map.bucket_count())});\n    BOOST_CHECK_GT(map.load_factor(), map.min_load_factor());\n}\n\nBOOST_AUTO_TEST_CASE(test_min_load_factor_range_erase)\n{\n    // set min_load_factor to 0.15 and max_load_factor to 0.5.\n    // rehash to 100 buckets, insert 50 elements, erase 40 with range erase,\n    // insert an element, check if map has shrinked.\n    const std::size_t nb_values = 50;\n    const std::size_t nb_values_erase = 40;\n    tsl::robin_map<std::int64_t, std::int64_t> map;\n\n    map.min_load_factor(0.15f);\n    BOOST_CHECK_EQUAL(map.min_load_factor(), 0.15f);\n\n    map.max_load_factor(0.5f);\n    BOOST_CHECK_EQUAL(map.max_load_factor(), 0.5f);\n\n    map.rehash(nb_values * 2);\n    for (std::size_t i = 0; i < nb_values; i++) {\n        map.insert({utils::get_key<std::int64_t>(i), utils::get_value<std::int64_t>(i)});\n    }\n    BOOST_CHECK_GT(map.load_factor(), map.min_load_factor());\n\n    map.erase(std::next(map.begin(), nb_values - nb_values_erase), map.end());\n\n    // Shrink is done on insert.\n    map.insert({utils::get_key<std::int64_t>(map.bucket_count()), utils::get_value<std::int64_t>(map.bucket_count())});\n    BOOST_CHECK_GT(map.load_factor(), map.min_load_factor());\n    BOOST_CHECK_LT(map.bucket_count(), nb_values * 2);\n}\n\n/**\n * rehash\n */\nBOOST_AUTO_TEST_CASE(test_rehash_empty)\n{\n    // test rehash(0), test find/erase/insert on map.\n    const std::size_t nb_values = 100;\n    auto map = utils::get_filled_hash_map<tsl::robin_map<std::int64_t, std::int64_t>>(nb_values);\n\n    const std::size_t bucket_count = map.bucket_count();\n    BOOST_CHECK(bucket_count >= nb_values);\n\n    map.clear();\n    BOOST_CHECK_EQUAL(map.bucket_count(), bucket_count);\n    BOOST_CHECK(map.empty());\n\n    map.rehash(0);\n    BOOST_CHECK_EQUAL(map.bucket_count(), 0);\n    BOOST_CHECK(map.empty());\n\n    BOOST_CHECK(map.find(1) == map.end());\n    BOOST_CHECK_EQUAL(map.erase(1), 0);\n    BOOST_CHECK(map.insert({1, 10}).second);\n    BOOST_CHECK_EQUAL(map.at(1), 10);\n}\n\n/**\n * operator== and operator!=\n */\nBOOST_AUTO_TEST_CASE(test_compare)\n{\n    const tsl::robin_map<std::string, std::int64_t> map1 = {{"a", 1}, {"e", 5}, {"d", 4}, {"c", 3}, {"b", 2}};\n    const tsl::robin_map<std::string, std::int64_t> map1_copy = {{"e", 5}, {"c", 3}, {"b", 2}, {"a", 1}, {"d", 4}};\n    const tsl::robin_map<std::string, std::int64_t> map2 = {{"e", 5}, {"c", 3}, {"b", 2}, {"a", 1}, {"d", 4}, {"f", 6}};\n    const tsl::robin_map<std::string, std::int64_t> map3 = {{"e", 5}, {"c", 3}, {"b", 2}, {"a", 1}};\n    const tsl::robin_map<std::string, std::int64_t> map4 = {{"a", 1}, {"e", 5}, {"d", 4}, {"c", 3}, {"b", 26}};\n    const tsl::robin_map<std::string, std::int64_t> map5 = {{"a", 1}, {"e", 5}, {"d", 4}, {"c", 3}, {"z", 2}};\n\n    BOOST_CHECK(map1 == map1_copy);\n    BOOST_CHECK(map1_copy == map1);\n\n    BOOST_CHECK(map1 != map2);\n    BOOST_CHECK(map2 != map1);\n\n    BOOST_CHECK(map1 != map3);\n    BOOST_CHECK(map3 != map1);\n\n    BOOST_CHECK(map1 != map4);\n    BOOST_CHECK(map4 != map1);\n\n    BOOST_CHECK(map1 != map5);\n    BOOST_CHECK(map5 != map1);\n\n    BOOST_CHECK(map2 != map3);\n    BOOST_CHECK(map3 != map2);\n\n    BOOST_CHECK(map2 != map4);\n    BOOST_CHECK(map4 != map2);\n\n    BOOST_CHECK(map2 != map5);\n    BOOST_CHECK(map5 != map2);\n\n    BOOST_CHECK(map3 != map4);\n    BOOST_CHECK(map4 != map3);\n\n    BOOST_CHECK(map3 != map5);\n    BOOST_CHECK(map5 != map3);\n\n    BOOST_CHECK(map4 != map5);\n    BOOST_CHECK(map5 != map4);\n}\n\n/**\n * clear\n */\nBOOST_AUTO_TEST_CASE(test_clear)\n{\n    // insert x values, clear map, test insert\n    using HMap = tsl::robin_map<std::int64_t, std::int64_t>;\n\n    const std::size_t nb_values = 1000;\n    auto map = utils::get_filled_hash_map<HMap>(nb_values);\n\n    map.clear();\n    BOOST_CHECK_EQUAL(map.size(), 0);\n    BOOST_CHECK_EQUAL(std::distance(map.begin(), map.end()), 0);\n\n    map.insert({5, -5});\n    map.insert({{1, -1}, {2, -1}, {4, -4}, {3, -3}});\n\n    BOOST_CHECK(map == (HMap({{5, -5}, {1, -1}, {2, -1}, {4, -4}, {3, -3}})));\n}\n\nBOOST_AUTO_TEST_CASE(test_clear_with_min_load_factor)\n{\n    // insert x values, clear map, test insert\n    using HMap = tsl::robin_map<std::int64_t, std::int64_t>;\n\n    const std::size_t nb_values = 1000;\n    auto map = utils::get_filled_hash_map<HMap>(nb_values);\n    map.min_load_factor(0.1f);\n\n    map.clear();\n    BOOST_CHECK_EQUAL(map.bucket_count(), 0);\n    BOOST_CHECK_EQUAL(map.size(), 0);\n    BOOST_CHECK_EQUAL(std::distance(map.begin(), map.end()), 0);\n\n    map.insert({5, -5});\n    map.insert({{1, -1}, {2, -1}, {4, -4}, {3, -3}});\n\n    BOOST_CHECK(map == (HMap({{5, -5}, {1, -1}, {2, -1}, {4, -4}, {3, -3}})));\n}\n\n/**\n * iterator.value()\n */\nBOOST_AUTO_TEST_CASE(test_modify_value_through_iterator)\n{\n    // insert x values, modify value of even keys with iterators, check values\n    const std::size_t nb_values = 100;\n    auto map = utils::get_filled_hash_map<tsl::robin_map<std::int64_t, std::int64_t>>(nb_values);\n\n    for (auto it = map.begin(); it != map.end(); it++) {\n        if (it.key() % 2 == 0) {\n            it.value() = -1;\n        }\n    }\n\n    for (auto& val : map) {\n        if (val.first % 2 == 0) {\n            BOOST_CHECK_EQUAL(val.second, -1);\n        } else {\n            BOOST_CHECK_NE(val.second, -1);\n        }\n    }\n}\n\nBOOST_AUTO_TEST_CASE(test_modify_value_through_iterator_with_const_qualifier)\n{\n    tsl::robin_map<int, int> map = {{0, 1}};\n    const auto it = map.begin();\n\n    BOOST_CHECK_EQUAL(it->second, 1);\n    it.value() += 10;\n    BOOST_CHECK_EQUAL(it->second, 11);\n}\n\n/**\n * constructor\n */\nBOOST_AUTO_TEST_CASE(test_extreme_bucket_count_value_construction)\n{\n    TSL_RH_CHECK_THROW(\n        (tsl::robin_map<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<int, int>>, false,\n                        tsl::rh::power_of_two_growth_policy<2>>(std::numeric_limits<std::size_t>::max())),\n        std::length_error);\n\n    TSL_RH_CHECK_THROW(\n        (tsl::robin_map<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<int, int>>, false,\n                        tsl::rh::power_of_two_growth_policy<2>>(std::numeric_limits<std::size_t>::max() / 2 + 1)),\n        std::length_error);\n\n    TSL_RH_CHECK_THROW(\n        (tsl::robin_map<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<int, int>>, false,\n                        tsl::rh::prime_growth_policy>(std::numeric_limits<std::size_t>::max())),\n        std::length_error);\n\n    TSL_RH_CHECK_THROW(\n        (tsl::robin_map<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<int, int>>, false,\n                        tsl::rh::prime_growth_policy>(std::numeric_limits<std::size_t>::max() / 2)),\n        std::length_error);\n\n    TSL_RH_CHECK_THROW(\n        (tsl::robin_map<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<int, int>>, false,\n                        tsl::rh::mod_growth_policy<>>(std::numeric_limits<std::size_t>::max())),\n        std::length_error);\n}\n\nBOOST_AUTO_TEST_CASE(test_range_construct)\n{\n    tsl::robin_map<int, int> map = {{2, 1}, {1, 0}, {3, 2}};\n\n    tsl::robin_map<int, int> map2(map.begin(), map.end());\n    tsl::robin_map<int, int> map3(map.cbegin(), map.cend());\n}\n\n/**\n * operator=(std::initializer_list)\n */\nBOOST_AUTO_TEST_CASE(test_assign_operator)\n{\n    tsl::robin_map<std::int64_t, std::int64_t> map = {{0, 10}, {-2, 20}};\n    BOOST_CHECK_EQUAL(map.size(), 2);\n\n    map = {{1, 3}, {2, 4}};\n    BOOST_CHECK_EQUAL(map.size(), 2);\n    BOOST_CHECK_EQUAL(map.at(1), 3);\n    BOOST_CHECK_EQUAL(map.at(2), 4);\n    BOOST_CHECK(map.find(0) == map.end());\n\n    map = {};\n    BOOST_CHECK(map.empty());\n}\n\n/**\n * move/copy constructor/operator\n */\nBOOST_AUTO_TEST_CASE(test_move_constructor)\n{\n    // insert x values in map, move map into map_move with move constructor, check\n    // map and map_move, insert additional values in map_move, check map_move\n    using HMap = tsl::robin_map<std::string, move_only_test>;\n\n    const std::size_t nb_values = 100;\n    HMap map = utils::get_filled_hash_map<HMap>(nb_values);\n    HMap map_move(std::move(map));\n\n    BOOST_CHECK(map_move == utils::get_filled_hash_map<HMap>(nb_values));\n    BOOST_CHECK(map == (HMap()));\n\n    for (std::size_t i = nb_values; i < nb_values * 2; i++) {\n        map_move.insert({utils::get_key<std::string>(i), utils::get_value<move_only_test>(i)});\n    }\n\n    BOOST_CHECK_EQUAL(map_move.size(), nb_values * 2);\n    BOOST_CHECK(map_move == utils::get_filled_hash_map<HMap>(nb_values * 2));\n}\n\nBOOST_AUTO_TEST_CASE(test_move_constructor_empty)\n{\n    tsl::robin_map<std::string, move_only_test> map(0);\n    tsl::robin_map<std::string, move_only_test> map_move(std::move(map));\n\n    BOOST_CHECK(map.empty());\n    BOOST_CHECK(map_move.empty());\n\n    BOOST_CHECK(map.find("") == map.end());\n    BOOST_CHECK(map_move.find("") == map_move.end());\n}\n\nBOOST_AUTO_TEST_CASE(test_move_operator)\n{\n    // insert x values in map, move map into map_move with move operator, check\n    // map and map_move, insert additional values in map_move, check map_move\n    using HMap = tsl::robin_map<std::string, move_only_test>;\n\n    const std::size_t nb_values = 100;\n    HMap map = utils::get_filled_hash_map<HMap>(nb_values);\n    HMap map_move = utils::get_filled_hash_map<HMap>(1);\n    map_move = std::move(map);\n\n    BOOST_CHECK(map_move == utils::get_filled_hash_map<HMap>(nb_values));\n    BOOST_CHECK(map == (HMap()));\n\n    for (std::size_t i = nb_values; i < nb_values * 2; i++) {\n        map_move.insert({utils::get_key<std::string>(i), utils::get_value<move_only_test>(i)});\n    }\n\n    BOOST_CHECK_EQUAL(map_move.size(), nb_values * 2);\n    BOOST_CHECK(map_move == utils::get_filled_hash_map<HMap>(nb_values * 2));\n}\n\nBOOST_AUTO_TEST_CASE(test_move_operator_empty)\n{\n    tsl::robin_map<std::string, move_only_test> map(0);\n    tsl::robin_map<std::string, move_only_test> map_move;\n    map_move = (std::move(map));\n\n    BOOST_CHECK(map.empty());\n    BOOST_CHECK(map_move.empty());\n\n    BOOST_CHECK(map.find("") == map.end());\n    BOOST_CHECK(map_move.find("") == map_move.end());\n}\n\nBOOST_AUTO_TEST_CASE(test_reassign_moved_object_move_constructor)\n{\n    using HMap = tsl::robin_map<std::string, std::string>;\n\n    HMap map = {{"Key1", "Value1"}, {"Key2", "Value2"}, {"Key3", "Value3"}};\n    HMap map_move(std::move(map));\n\n    BOOST_CHECK_EQUAL(map_move.size(), 3);\n    BOOST_CHECK_EQUAL(map.size(), 0);\n\n    map = {{"Key4", "Value4"}, {"Key5", "Value5"}};\n    BOOST_CHECK(map == (HMap({{"Key4", "Value4"}, {"Key5", "Value5"}})));\n}\n\nBOOST_AUTO_TEST_CASE(test_reassign_moved_object_move_operator)\n{\n    using HMap = tsl::robin_map<std::string, std::string>;\n\n    HMap map = {{"Key1", "Value1"}, {"Key2", "Value2"}, {"Key3", "Value3"}};\n    HMap map_move = std::move(map);\n\n    BOOST_CHECK_EQUAL(map_move.size(), 3);\n    BOOST_CHECK_EQUAL(map.size(), 0);\n\n    map = {{"Key4", "Value4"}, {"Key5", "Value5"}};\n    BOOST_CHECK(map == (HMap({{"Key4", "Value4"}, {"Key5", "Value5"}})));\n}\n\nBOOST_AUTO_TEST_CASE(test_use_after_move_constructor)\n{\n    using HMap = tsl::robin_map<std::string, move_only_test>;\n\n    const std::size_t nb_values = 100;\n    HMap map = utils::get_filled_hash_map<HMap>(nb_values);\n    HMap map_move(std::move(map));\n\n    BOOST_CHECK(map == (HMap()));\n    BOOST_CHECK_EQUAL(map.size(), 0);\n    BOOST_CHECK_EQUAL(map.bucket_count(), 0);\n    BOOST_CHECK_EQUAL(map.erase("a"), 0);\n    BOOST_CHECK(map.find("a") == map.end());\n\n    for (std::size_t i = 0; i < nb_values; i++) {\n        map.insert({utils::get_key<std::string>(i), utils::get_value<move_only_test>(i)});\n    }\n\n    BOOST_CHECK_EQUAL(map.size(), nb_values);\n    BOOST_CHECK(map == map_move);\n}\n\nBOOST_AUTO_TEST_CASE(test_use_after_move_operator)\n{\n    using HMap = tsl::robin_map<std::string, move_only_test>;\n\n    const std::size_t nb_values = 100;\n    HMap map = utils::get_filled_hash_map<HMap>(nb_values);\n    HMap map_move(0);\n    map_move = std::move(map);\n\n    BOOST_CHECK(map == (HMap()));\n    BOOST_CHECK_EQUAL(map.size(), 0);\n    BOOST_CHECK_EQUAL(map.bucket_count(), 0);\n    BOOST_CHECK_EQUAL(map.erase("a"), 0);\n    BOOST_CHECK(map.find("a") == map.end());\n\n    for (std::size_t i = 0; i < nb_values; i++) {\n        map.insert({utils::get_key<std::string>(i), utils::get_value<move_only_test>(i)});\n    }\n\n    BOOST_CHECK_EQUAL(map.size(), nb_values);\n    BOOST_CHECK(map == map_move);\n}\n\nBOOST_AUTO_TEST_CASE(test_copy_constructor_and_operator)\n{\n    using HMap = tsl::robin_map<std::string, std::string, mod_hash<9>>;\n\n    const std::size_t nb_values = 100;\n    HMap map = utils::get_filled_hash_map<HMap>(nb_values);\n\n    HMap map_copy = map;\n    HMap map_copy2(map);\n    HMap map_copy3 = utils::get_filled_hash_map<HMap>(1);\n    map_copy3 = map;\n\n    BOOST_CHECK(map == map_copy);\n    map.clear();\n\n    BOOST_CHECK(map_copy == map_copy2);\n    BOOST_CHECK(map_copy == map_copy3);\n}\n\nBOOST_AUTO_TEST_CASE(test_copy_constructor_empty)\n{\n    tsl::robin_map<std::string, int> map(0);\n    tsl::robin_map<std::string, int> map_copy(map);\n\n    BOOST_CHECK(map.empty());\n    BOOST_CHECK(map_copy.empty());\n\n    BOOST_CHECK(map.find("") == map.end());\n    BOOST_CHECK(map_copy.find("") == map_copy.end());\n}\n\nBOOST_AUTO_TEST_CASE(test_copy_operator_empty)\n{\n    tsl::robin_map<std::string, int> map(0);\n    tsl::robin_map<std::string, int> map_copy(16);\n    map_copy = map;\n\n    BOOST_CHECK(map.empty());\n    BOOST_CHECK(map_copy.empty());\n\n    BOOST_CHECK(map.find("") == map.end());\n    BOOST_CHECK(map_copy.find("") == map_copy.end());\n}\n\n/**\n * at\n */\nBOOST_AUTO_TEST_CASE(test_at)\n{\n    // insert x values, use at for known and unknown values.\n    const tsl::robin_map<std::int64_t, std::int64_t> map = {{0, 10}, {-2, 20}};\n\n    BOOST_CHECK_EQUAL(map.at(0), 10);\n    BOOST_CHECK_EQUAL(map.at(-2), 20);\n    TSL_RH_CHECK_THROW(map.at(1), std::out_of_range);\n}\n\n/**\n * contains\n */\nBOOST_AUTO_TEST_CASE(test_contains)\n{\n    tsl::robin_map<std::int64_t, std::int64_t> map = {{0, 10}, {-2, 20}};\n\n    BOOST_CHECK(map.contains(0));\n    BOOST_CHECK(map.contains(-2));\n    BOOST_CHECK(!map.contains(-3));\n}\n\n/**\n * equal_range\n */\nBOOST_AUTO_TEST_CASE(test_equal_range)\n{\n    const tsl::robin_map<std::int64_t, std::int64_t> map = {{0, 10}, {-2, 20}};\n\n    auto it_pair = map.equal_range(0);\n    BOOST_REQUIRE_EQUAL(std::distance(it_pair.first, it_pair.second), 1);\n    BOOST_CHECK_EQUAL(it_pair.first->second, 10);\n\n    it_pair = map.equal_range(1);\n    BOOST_CHECK(it_pair.first == it_pair.second);\n    BOOST_CHECK(it_pair.first == map.end());\n}\n\n/**\n * operator[]\n */\nBOOST_AUTO_TEST_CASE(test_access_operator)\n{\n    // insert x values, use at for known and unknown values.\n    tsl::robin_map<std::int64_t, std::int64_t> map = {{0, 10}, {-2, 20}};\n\n    BOOST_CHECK_EQUAL(map[0], 10);\n    BOOST_CHECK_EQUAL(map[-2], 20);\n    BOOST_CHECK_EQUAL(map[2], std::int64_t());\n\n    BOOST_CHECK_EQUAL(map.size(), 3);\n}\n\n/**\n * swap\n */\nBOOST_AUTO_TEST_CASE(test_swap)\n{\n    tsl::robin_map<std::int64_t, std::int64_t> map = {{1, 10}, {8, 80}, {3, 30}};\n    tsl::robin_map<std::int64_t, std::int64_t> map2 = {{4, 40}, {5, 50}};\n\n    using std::swap;\n    swap(map, map2);\n\n    BOOST_CHECK(map == (tsl::robin_map<std::int64_t, std::int64_t> {{4, 40}, {5, 50}}));\n    BOOST_CHECK(map2 == (tsl::robin_map<std::int64_t, std::int64_t> {{1, 10}, {8, 80}, {3, 30}}));\n\n    map.insert({6, 60});\n    map2.insert({4, 40});\n\n    BOOST_CHECK(map == (tsl::robin_map<std::int64_t, std::int64_t> {{4, 40}, {5, 50}, {6, 60}}));\n    BOOST_CHECK(map2 == (tsl::robin_map<std::int64_t, std::int64_t> {{1, 10}, {8, 80}, {3, 30}, {4, 40}}));\n}\n\nBOOST_AUTO_TEST_CASE(test_swap_empty)\n{\n    tsl::robin_map<std::int64_t, std::int64_t> map = {{1, 10}, {8, 80}, {3, 30}};\n    tsl::robin_map<std::int64_t, std::int64_t> map2;\n\n    using std::swap;\n    swap(map, map2);\n\n    BOOST_CHECK(map == (tsl::robin_map<std::int64_t, std::int64_t> {}));\n    BOOST_CHECK(map2 == (tsl::robin_map<std::int64_t, std::int64_t> {{1, 10}, {8, 80}, {3, 30}}));\n\n    map.insert({6, 60});\n    map2.insert({4, 40});\n\n    BOOST_CHECK(map == (tsl::robin_map<std::int64_t, std::int64_t> {{6, 60}}));\n    BOOST_CHECK(map2 == (tsl::robin_map<std::int64_t, std::int64_t> {{1, 10}, {8, 80}, {3, 30}, {4, 40}}));\n}\n\n/**\n * serialize and deserialize\n */\nBOOST_AUTO_TEST_CASE(test_serialize_desearialize_empty)\n{\n    // serialize empty map; deserialize in new map; check equal.\n    // for deserialization, test it with and without hash compatibility.\n    const tsl::robin_map<std::string, move_only_test> empty_map(0);\n\n    serializer serial;\n    empty_map.serialize(serial);\n\n    deserializer dserial(serial.str());\n    auto empty_map_deserialized = decltype(empty_map)::deserialize(dserial, true);\n    BOOST_CHECK(empty_map_deserialized == empty_map);\n\n    deserializer dserial2(serial.str());\n    empty_map_deserialized = decltype(empty_map)::deserialize(dserial2, false);\n    BOOST_CHECK(empty_map_deserialized == empty_map);\n}\n\nBOOST_AUTO_TEST_CASE(test_serialize_desearialize)\n{\n    // insert x values; delete some values; serialize map; deserialize in new map;\n    // check equal. for deserialization, test it with and without hash\n    // compatibility.\n    const std::size_t nb_values = 1000;\n\n    tsl::robin_map<std::int32_t, move_only_test> map;\n    for (std::size_t i = 0; i < nb_values + 40; i++) {\n        map.insert({utils::get_key<std::int32_t>(i), utils::get_value<move_only_test>(i)});\n    }\n\n    for (std::size_t i = nb_values; i < nb_values + 40; i++) {\n        map.erase(utils::get_key<std::int32_t>(i));\n    }\n    BOOST_CHECK_EQUAL(map.size(), nb_values);\n\n    serializer serial;\n    map.serialize(serial);\n\n    deserializer dserial(serial.str());\n    auto map_deserialized = decltype(map)::deserialize(dserial, true);\n    BOOST_CHECK(map == map_deserialized);\n\n    deserializer dserial2(serial.str());\n    map_deserialized = decltype(map)::deserialize(dserial2, false);\n    BOOST_CHECK(map_deserialized == map);\n\n    // Deserializing a map with StoreHash=true from a map serialized with\n    // StoreHash=false with hash_compatible=true should throw an exception.\n    deserializer dserial3(serial.str());\n    TSL_RH_CHECK_THROW(\n        (tsl::robin_map<std::int32_t, move_only_test, std::hash<std::int32_t>, std::equal_to<std::int32_t>,\n                        std::allocator<std::pair<std::int32_t, move_only_test>>, true>::deserialize(dserial3, true)),\n        std::runtime_error);\n}\n\nBOOST_AUTO_TEST_CASE(test_serialize_desearialize_with_store_hash)\n{\n    // insert x values; delete some values; serialize map; deserialize in new map;\n    // check equal. for deserialization, test it with and without hash\n    // compatibility.\n    const std::size_t nb_values = 1000;\n\n    tsl::robin_map<std::int32_t, move_only_test, std::hash<std::int32_t>, std::equal_to<std::int32_t>,\n                   std::allocator<std::pair<std::int32_t, move_only_test>>, true>\n        map;\n    for (std::size_t i = 0; i < nb_values + 40; i++) {\n        map.insert({utils::get_key<std::int32_t>(i), utils::get_value<move_only_test>(i)});\n    }\n\n    for (std::size_t i = nb_values; i < nb_values + 40; i++) {\n        map.erase(utils::get_key<std::int32_t>(i));\n    }\n    BOOST_CHECK_EQUAL(map.size(), nb_values);\n\n    serializer serial;\n    map.serialize(serial);\n\n    deserializer dserial(serial.str());\n    auto map_deserialized = decltype(map)::deserialize(dserial, true);\n    BOOST_CHECK(map == map_deserialized);\n\n    deserializer dserial2(serial.str());\n    map_deserialized = decltype(map)::deserialize(dserial2, false);\n    BOOST_CHECK(map_deserialized == map);\n\n    // Deserializing a map with StoreHash=false from a map serialized with\n    // StoreHash=true with hash_compatible=true should throw an exception.\n    deserializer dserial3(serial.str());\n    TSL_RH_CHECK_THROW((tsl::robin_map<std::int32_t, move_only_test>::deserialize(dserial3, true)), std::runtime_error);\n}\n\nBOOST_AUTO_TEST_CASE(test_serialize_desearialize_with_different_hash)\n{\n    // insert x values; serialize map; deserialize in new map which has a\n    // different hash; check equal\n    struct hash_str_diff\n    {\n        std::size_t operator()(const std::string& str) const\n        {\n            return std::hash<std::string>()(str) + 123;\n        }\n    };\n\n    const std::size_t nb_values = 1000;\n\n    tsl::robin_map<std::string, move_only_test> map;\n    for (std::size_t i = 0; i < nb_values; i++) {\n        map.insert({utils::get_key<std::string>(i), utils::get_value<move_only_test>(i)});\n    }\n    BOOST_CHECK_EQUAL(map.size(), nb_values);\n\n    serializer serial;\n    map.serialize(serial);\n\n    deserializer dserial(serial.str());\n    auto map_deserialized = tsl::robin_map<std::string, move_only_test, hash_str_diff>::deserialize(dserial, false);\n\n    BOOST_CHECK_EQUAL(map_deserialized.size(), map.size());\n    for (const auto& val : map) {\n        BOOST_CHECK(map_deserialized.find(val.first) != map_deserialized.end());\n    }\n}\n\n/**\n * KeyEqual\n */\nBOOST_AUTO_TEST_CASE(test_key_equal)\n{\n    // Use a KeyEqual and Hash where any odd unsigned number \'x\' is equal to\n    // \'x-1\'. Make sure that KeyEqual is called (and not ==).\n    struct hash\n    {\n        std::size_t operator()(std::uint64_t v) const\n        {\n            if (v % 2u == 1u) {\n                return std::hash<std::uint64_t>()(v - 1);\n            } else {\n                return std::hash<std::uint64_t>()(v);\n            }\n        }\n    };\n\n    struct key_equal\n    {\n        bool operator()(std::uint64_t lhs, std::uint64_t rhs) const\n        {\n            if (lhs % 2u == 1u) {\n                lhs--;\n            }\n\n            if (rhs % 2u == 1u) {\n                rhs--;\n            }\n\n            return lhs == rhs;\n        }\n    };\n\n    tsl::robin_map<std::uint64_t, std::uint64_t, hash, key_equal> map;\n    BOOST_CHECK(map.insert({2, 10}).second);\n    BOOST_CHECK_EQUAL(map.at(2), 10);\n    BOOST_CHECK_EQUAL(map.at(3), 10);\n    BOOST_CHECK(!map.insert({3, 10}).second);\n\n    BOOST_CHECK_EQUAL(map.size(), 1);\n}\n\n/**\n * other\n */\nBOOST_AUTO_TEST_CASE(test_heterogeneous_lookups)\n{\n    struct hash_ptr\n    {\n        std::size_t operator()(const std::unique_ptr<int>& p) const\n        {\n            return std::hash<std::uintptr_t>()(reinterpret_cast<std::uintptr_t>(p.get()));\n        }\n\n        std::size_t operator()(std::uintptr_t p) const\n        {\n            return std::hash<std::uintptr_t>()(p);\n        }\n\n        std::size_t operator()(const int* const& p) const\n        {\n            return std::hash<std::uintptr_t>()(reinterpret_cast<std::uintptr_t>(p));\n        }\n    };\n\n    struct equal_to_ptr\n    {\n        using is_transparent = std::true_type;\n\n        bool operator()(const std::unique_ptr<int>& p1, const std::unique_ptr<int>& p2) const\n        {\n            return p1 == p2;\n        }\n\n        bool operator()(const std::unique_ptr<int>& p1, std::uintptr_t p2) const\n        {\n            return reinterpret_cast<std::uintptr_t>(p1.get()) == p2;\n        }\n\n        bool operator()(std::uintptr_t p1, const std::unique_ptr<int>& p2) const\n        {\n            return p1 == reinterpret_cast<std::uintptr_t>(p2.get());\n        }\n\n        bool operator()(const std::unique_ptr<int>& p1, const int* const& p2) const\n        {\n            return p1.get() == p2;\n        }\n\n        bool operator()(const int* const& p1, const std::unique_ptr<int>& p2) const\n        {\n            return p1 == p2.get();\n        }\n    };\n\n    std::unique_ptr<int> ptr1(new int(1));\n    std::unique_ptr<int> ptr2(new int(2));\n    std::unique_ptr<int> ptr3(new int(3));\n    int other = -1;\n\n    const std::uintptr_t addr1 = reinterpret_cast<std::uintptr_t>(ptr1.get());\n    const int* const addr2 = ptr2.get();\n    const int* const addr_unknown = &other;\n\n    tsl::robin_map<std::unique_ptr<int>, int, hash_ptr, equal_to_ptr> map;\n    map.insert({std::move(ptr1), 4});\n    map.insert({std::move(ptr2), 5});\n    map.insert({std::move(ptr3), 6});\n\n    BOOST_CHECK_EQUAL(map.size(), 3);\n\n    BOOST_CHECK_EQUAL(map.at(addr1), 4);\n    BOOST_CHECK_EQUAL(map.at(addr2), 5);\n    TSL_RH_CHECK_THROW(map.at(addr_unknown), std::out_of_range);\n\n    BOOST_REQUIRE(map.find(addr1) != map.end());\n    BOOST_CHECK_EQUAL(*map.find(addr1)->first, 1);\n\n    BOOST_REQUIRE(map.find(addr2) != map.end());\n    BOOST_CHECK_EQUAL(*map.find(addr2)->first, 2);\n\n    BOOST_CHECK(map.find(addr_unknown) == map.end());\n\n    BOOST_CHECK_EQUAL(map.count(addr1), 1);\n    BOOST_CHECK_EQUAL(map.count(addr2), 1);\n    BOOST_CHECK_EQUAL(map.count(addr_unknown), 0);\n\n    BOOST_CHECK_EQUAL(map.erase(addr1), 1);\n    BOOST_CHECK_EQUAL(map.erase(addr2), 1);\n    BOOST_CHECK_EQUAL(map.erase(addr_unknown), 0);\n\n    BOOST_CHECK_EQUAL(map.size(), 1);\n}\n\n/**\n * Various operations on empty map\n */\nBOOST_AUTO_TEST_CASE(test_empty_map)\n{\n    tsl::robin_map<std::string, int> map(0);\n\n    BOOST_CHECK_EQUAL(map.bucket_count(), 0);\n    BOOST_CHECK_EQUAL(map.size(), 0);\n    BOOST_CHECK_EQUAL(map.load_factor(), 0);\n    BOOST_CHECK(map.empty());\n\n    BOOST_CHECK(map.begin() == map.end());\n    BOOST_CHECK(map.begin() == map.cend());\n    BOOST_CHECK(map.cbegin() == map.cend());\n\n    BOOST_CHECK(map.find("") == map.end());\n    BOOST_CHECK(map.find("test") == map.end());\n\n    BOOST_CHECK_EQUAL(map.count(""), 0);\n    BOOST_CHECK_EQUAL(map.count("test"), 0);\n\n    BOOST_CHECK(!map.contains(""));\n    BOOST_CHECK(!map.contains("test"));\n\n    TSL_RH_CHECK_THROW(map.at(""), std::out_of_range);\n    TSL_RH_CHECK_THROW(map.at("test"), std::out_of_range);\n\n    auto range = map.equal_range("test");\n    BOOST_CHECK(range.first == range.second);\n\n    BOOST_CHECK_EQUAL(map.erase("test"), 0);\n    BOOST_CHECK(map.erase(map.begin(), map.end()) == map.end());\n\n    BOOST_CHECK_EQUAL(map["new value"], int {});\n}\n\n/**\n * Test precalculated hash\n */\nBOOST_AUTO_TEST_CASE(test_precalculated_hash)\n{\n    tsl::robin_map<int, int, identity_hash<int>> map = {{1, -1}, {2, -2}, {3, -3}, {4, -4}, {5, -5}, {6, -6}};\n    const tsl::robin_map<int, int, identity_hash<int>> map_const = map;\n\n    /**\n     * find\n     */\n    BOOST_REQUIRE(map.find(3, map.hash_function()(3)) != map.end());\n    BOOST_CHECK_EQUAL(map.find(3, map.hash_function()(3))->second, -3);\n\n    BOOST_REQUIRE(map_const.find(3, map_const.hash_function()(3)) != map_const.end());\n    BOOST_CHECK_EQUAL(map_const.find(3, map_const.hash_function()(3))->second, -3);\n\n    BOOST_REQUIRE_NE(map.hash_function()(2), map.hash_function()(3));\n    BOOST_CHECK(map.find(3, map.hash_function()(2)) == map.end());\n\n    /**\n     * at\n     */\n    BOOST_CHECK_EQUAL(map.at(3, map.hash_function()(3)), -3);\n    BOOST_CHECK_EQUAL(map_const.at(3, map_const.hash_function()(3)), -3);\n\n    BOOST_REQUIRE_NE(map.hash_function()(2), map.hash_function()(3));\n    TSL_RH_CHECK_THROW(map.at(3, map.hash_function()(2)), std::out_of_range);\n\n    /**\n     * contains\n     */\n    BOOST_CHECK(map.contains(3, map.hash_function()(3)));\n    BOOST_CHECK(map_const.contains(3, map_const.hash_function()(3)));\n\n    BOOST_REQUIRE_NE(map.hash_function()(2), map.hash_function()(3));\n    BOOST_CHECK(!map.contains(3, map.hash_function()(2)));\n\n    /**\n     * count\n     */\n    BOOST_CHECK_EQUAL(map.count(3, map.hash_function()(3)), 1);\n    BOOST_CHECK_EQUAL(map_const.count(3, map_const.hash_function()(3)), 1);\n\n    BOOST_REQUIRE_NE(map.hash_function()(2), map.hash_function()(3));\n    BOOST_CHECK_EQUAL(map.count(3, map.hash_function()(2)), 0);\n\n    /**\n     * equal_range\n     */\n    auto it_range = map.equal_range(3, map.hash_function()(3));\n    BOOST_REQUIRE_EQUAL(std::distance(it_range.first, it_range.second), 1);\n    BOOST_CHECK_EQUAL(it_range.first->second, -3);\n\n    auto it_range_const = map_const.equal_range(3, map_const.hash_function()(3));\n    BOOST_REQUIRE_EQUAL(std::distance(it_range_const.first, it_range_const.second), 1);\n    BOOST_CHECK_EQUAL(it_range_const.first->second, -3);\n\n    it_range = map.equal_range(3, map.hash_function()(2));\n    BOOST_REQUIRE_NE(map.hash_function()(2), map.hash_function()(3));\n    BOOST_CHECK_EQUAL(std::distance(it_range.first, it_range.second), 0);\n\n    /**\n     * erase\n     */\n    BOOST_CHECK_EQUAL(map.erase(3, map.hash_function()(3)), 1);\n\n    BOOST_REQUIRE_NE(map.hash_function()(2), map.hash_function()(4));\n    BOOST_CHECK_EQUAL(map.erase(4, map.hash_function()(2)), 0);\n}\n\nBOOST_AUTO_TEST_SUITE_END()\n'