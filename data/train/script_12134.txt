b'module GameCreation (doNewCommand) where\n\nimport qualified Data.Map as M\nimport GameModel\nimport GameUtils\nimport GameIO\nimport GameDisplay\nimport IdrisGen\nimport Control.Monad.Random.Strict\n\nplaceMines :: Int -> Game -> Rand StdGen Game\nplaceMines 0 game = return game\nplaceMines n (Game { gameGridSize = gridSize, gameStatus = status }) = do\n  let nonMines = filter (\\(_, CellStatus _ cellStatus) -> cellStatus == CellNotMine) $\n                   M.toList status\n  mineIdx <- fmap (\\v -> v `mod` (length nonMines)) getRandom\n  let (mineCoord, _) = nonMines !! mineIdx\n  let newGameStatus = status\n  placeMines (n-1) (Game gridSize (\n                       M.insert mineCoord\n                         (CellStatus CellUnknown CellMine)\n                         newGameStatus))\n\nmineRatio :: Double\nmineRatio = 0.25\n\ngenerateGame :: Int -> Rand StdGen Game\ngenerateGame gridSize =\n    placeMines nMines (Game { gameGridSize = gridSize, gameStatus = blankGrid })\n  where\n    nMines = ceiling $ fromIntegral (gridSize * gridSize) * mineRatio\n    blankGrid = M.fromList [(Coord x y, CellStatus CellUnknown CellNotMine) |\n                            x <- [0..(gridSize - 1)], y <- [0..(gridSize - 1)]]\n\nfirstClick :: Game -> Rand StdGen Game\nfirstClick game = do\n  let\n    mineCounts :: M.Map Coord Int\n    mineCounts = gameToMineCounts game\n    minMineCounts :: Int\n    minMineCounts = minimum (M.elems mineCounts)\n  \n  let clickOptions = filter (\\(coord, st) ->\n                              M.lookup coord mineCounts == Just minMineCounts &&\n                              st == CellStatus CellUnknown CellNotMine) $\n                      M.toList (gameStatus game)\n  mineIdx <- fmap (\\v -> v `mod` (length clickOptions)) getRandom\n  let (mineCoord, _) = clickOptions !! mineIdx\n  return $ game { gameStatus = M.insert mineCoord (CellStatus CellKnown CellNotMine) (gameStatus game) }\n\ndoNewCommand :: String -> IO ()\ndoNewCommand nStr =\n  case parseNumber nStr of\n    Nothing -> putStrLn "Expected number after new"\n    Just n | n <= 1 || n > 20 -> putStrLn "Number after new must be 2-20"\n    Just n -> do\n      rng <- newStdGen\n      let initialGame = evalRand (generateGame n >>= firstClick) rng\n      let mineCounts = gameToMineCounts initialGame\n      let game = expandNotMinesWithoutNeighbours initialGame mineCounts\n      saveGame game\n      saveIdrisGame game mineCounts\n      putStrLn $ displayGame game mineCounts\n      return ()\n'