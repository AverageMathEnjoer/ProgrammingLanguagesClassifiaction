b'type Expression = [Term]\ntype Term = [Factor] \ntype Factor = [Digit] \ntype Digit = Int\n\ndigits :: Factor\ndigits = [1 .. 9]\n\npi_digits :: Factor\npi_digits = [3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5, 8, 9, 7]\n\nvalExpr :: Expression -> Int \nvalExpr = sum . map valTerm\n\nvalTerm :: Term -> Int\nvalTerm = product . map valFact \n\nvalFact :: Factor -> Int\nvalFact = foldl1 (\\n d -> 10 * n + d)\n\nexpressions :: [Digit] -> [Expression] \nexpressions = concatMap partitions . partitions\n\npartitions [] = [[]]\npartitions (x:xs) = [[x]:p | p <- partitions xs]\n                 ++ [(x:ys):yss | (ys:yss) <- partitions xs]\n\ngood :: Int -> Bool\ngood v = v == 1000\n\ngoodOnes :: [Digit] -> [Expression]\ngoodOnes = filter (good . valExpr) . expressions\n\nmain = putStrLn $ "Number of solutions found: " ++ (show $ length $ goodOnes pi_digits)\n'