b'{-# LANGUAGE CPP #-}\nimport qualified Data.IntSet as IntSet\nimport Data.List (nub,sort)\nimport qualified Data.List as List\nimport Data.Monoid (mempty)\nimport Data.Maybe\nimport Data.Set\nimport Prelude hiding (lookup, null, map, filter, foldr, foldl, all, take, drop, splitAt)\nimport Test.Tasty\nimport Test.Tasty.HUnit\nimport Test.Tasty.QuickCheck\nimport Test.QuickCheck.Function (apply)\nimport Control.Monad.Trans.State.Strict\nimport Control.Monad.Trans.Class\nimport Control.Monad (liftM, liftM3)\nimport Data.Functor.Identity\nimport Data.Foldable (all)\nimport Control.Applicative (liftA2)\n\n#if __GLASGOW_HASKELL__ >= 806\nimport Utils.NoThunks (whnfHasNoThunks)\n#endif\n\nmain :: IO ()\nmain = defaultMain $ testGroup "set-properties"\n                   [ testCase "lookupLT" test_lookupLT\n                   , testCase "lookupGT" test_lookupGT\n                   , testCase "lookupLE" test_lookupLE\n                   , testCase "lookupGE" test_lookupGE\n                   , testCase "lookupIndex" test_lookupIndex\n                   , testCase "findIndex" test_findIndex\n                   , testCase "elemAt" test_elemAt\n                   , testCase "deleteAt" test_deleteAt\n                   , testProperty "prop_Valid" prop_Valid\n                   , testProperty "prop_Single" prop_Single\n                   , testProperty "prop_Member" prop_Member\n                   , testProperty "prop_NotMember" prop_NotMember\n                   , testProperty "prop_LookupLT" prop_LookupLT\n                   , testProperty "prop_LookupGT" prop_LookupGT\n                   , testProperty "prop_LookupLE" prop_LookupLE\n                   , testProperty "prop_LookupGE" prop_LookupGE\n                   , testProperty "prop_InsertValid" prop_InsertValid\n                   , testProperty "prop_InsertDelete" prop_InsertDelete\n                   , testProperty "prop_InsertBiased" prop_InsertBiased\n                   , testProperty "prop_DeleteValid" prop_DeleteValid\n                   , testProperty "alterF" prop_alterF\n                   , testProperty "alterF/delete" prop_alterF_delete\n                   , testProperty "alterF/insert" prop_alterF_insert\n                   , testProperty "alterF/member" prop_alterF_member\n                   , testProperty "alterF/four" prop_alterF_four\n                   , testProperty "alterF/valid" prop_alterF_valid\n                   , testProperty "prop_Link" prop_Link\n                   , testProperty "prop_Merge" prop_Merge\n                   , testProperty "prop_UnionValid" prop_UnionValid\n                   , testProperty "prop_UnionInsert" prop_UnionInsert\n                   , testProperty "prop_UnionAssoc" prop_UnionAssoc\n                   , testProperty "prop_UnionComm" prop_UnionComm\n                   , testProperty "prop_UnionBiased" prop_UnionBiased\n                   , testProperty "prop_DiffValid" prop_DiffValid\n                   , testProperty "prop_Diff" prop_Diff\n                   , testProperty "prop_IntValid" prop_IntValid\n                   , testProperty "prop_Int" prop_Int\n                   , testProperty "prop_IntBiased" prop_IntBiased\n                   , testProperty "prop_Ordered" prop_Ordered\n                   , testProperty "prop_DescendingOrdered" prop_DescendingOrdered\n                   , testProperty "prop_List" prop_List\n                   , testProperty "prop_DescList" prop_DescList\n                   , testProperty "prop_AscDescList" prop_AscDescList\n                   , testProperty "prop_fromList" prop_fromList\n                   , testProperty "prop_fromListDesc" prop_fromListDesc\n                   , testProperty "prop_isProperSubsetOf" prop_isProperSubsetOf\n                   , testProperty "prop_isProperSubsetOf2" prop_isProperSubsetOf2\n                   , testProperty "prop_isSubsetOf" prop_isSubsetOf\n                   , testProperty "prop_isSubsetOf2" prop_isSubsetOf2\n                   , testProperty "prop_disjoint" prop_disjoint\n                   , testProperty "prop_size" prop_size\n                   , testProperty "prop_lookupMax" prop_lookupMax\n                   , testProperty "prop_lookupMin" prop_lookupMin\n                   , testProperty "prop_findMax" prop_findMax\n                   , testProperty "prop_findMin" prop_findMin\n                   , testProperty "prop_ord" prop_ord\n                   , testProperty "prop_readShow" prop_readShow\n                   , testProperty "prop_foldR" prop_foldR\n                   , testProperty "prop_foldR\'" prop_foldR\'\n                   , testProperty "prop_foldL" prop_foldL\n                   , testProperty "prop_foldL\'" prop_foldL\'\n                   , testProperty "prop_map" prop_map\n                   , testProperty "prop_map2" prop_map2\n                   , testProperty "prop_mapMonotonic" prop_mapMonotonic\n                   , testProperty "prop_maxView" prop_maxView\n                   , testProperty "prop_minView" prop_minView\n                   , testProperty "prop_split" prop_split\n                   , testProperty "prop_splitMember" prop_splitMember\n                   , testProperty "prop_splitRoot" prop_splitRoot\n                   , testProperty "prop_partition" prop_partition\n                   , testProperty "prop_filter" prop_filter\n                   , testProperty "takeWhileAntitone"    prop_takeWhileAntitone\n                   , testProperty "dropWhileAntitone"    prop_dropWhileAntitone\n                   , testProperty "spanAntitone"         prop_spanAntitone\n                   , testProperty "take"                 prop_take\n                   , testProperty "drop"                 prop_drop\n                   , testProperty "splitAt"              prop_splitAt\n                   , testProperty "powerSet"             prop_powerSet\n                   , testProperty "cartesianProduct"     prop_cartesianProduct\n                   , testProperty "disjointUnion"        prop_disjointUnion\n#if __GLASGOW_HASKELL__ >= 806\n                   , testProperty "strict foldr"         prop_strictFoldr\'\n                   , testProperty "strict foldl"         prop_strictFoldl\'\n#endif\n                   ]\n\n-- A type with a peculiar Eq instance designed to make sure keys\n-- come from where they\'re supposed to.\ndata OddEq a = OddEq a Bool deriving (Show)\n\ngetOddEq :: OddEq a -> (a, Bool)\ngetOddEq (OddEq b a) = (b, a)\ninstance Arbitrary a => Arbitrary (OddEq a) where\n  arbitrary = OddEq <$> arbitrary <*> arbitrary\ninstance Eq a => Eq (OddEq a) where\n  OddEq x _ == OddEq y _ = x == y\ninstance Ord a => Ord (OddEq a) where\n  OddEq x _ `compare` OddEq y _ = x `compare` y\n\n----------------------------------------------------------------\n-- Unit tests\n----------------------------------------------------------------\n\ntest_lookupLT :: Assertion\ntest_lookupLT = do\n    lookupLT 3 (fromList [3, 5]) @?= Nothing\n    lookupLT 5 (fromList [3, 5]) @?= Just 3\n\ntest_lookupGT :: Assertion\ntest_lookupGT = do\n   lookupGT 4 (fromList [3, 5]) @?= Just 5\n   lookupGT 5 (fromList [3, 5]) @?= Nothing\n\ntest_lookupLE :: Assertion\ntest_lookupLE = do\n   lookupLE 2 (fromList [3, 5]) @?= Nothing\n   lookupLE 4 (fromList [3, 5]) @?= Just 3\n   lookupLE 5 (fromList [3, 5]) @?= Just 5\n\ntest_lookupGE :: Assertion\ntest_lookupGE = do\n   lookupGE 3 (fromList [3, 5]) @?= Just 3\n   lookupGE 4 (fromList [3, 5]) @?= Just 5\n   lookupGE 6 (fromList [3, 5]) @?= Nothing\n\n{--------------------------------------------------------------------\n  Indexed\n--------------------------------------------------------------------}\n\ntest_lookupIndex :: Assertion\ntest_lookupIndex = do\n    isJust   (lookupIndex 2 (fromList [5,3])) @?= False\n    fromJust (lookupIndex 3 (fromList [5,3])) @?= 0\n    fromJust (lookupIndex 5 (fromList [5,3])) @?= 1\n    isJust   (lookupIndex 6 (fromList [5,3])) @?= False\n\ntest_findIndex :: Assertion\ntest_findIndex = do\n    findIndex 3 (fromList [5,3]) @?= 0\n    findIndex 5 (fromList [5,3]) @?= 1\n\ntest_elemAt :: Assertion\ntest_elemAt = do\n    elemAt 0 (fromList [5,3]) @?= 3\n    elemAt 1 (fromList [5,3]) @?= 5\n\ntest_deleteAt :: Assertion\ntest_deleteAt = do\n    deleteAt 0 (fromList [5,3]) @?= singleton 5\n    deleteAt 1 (fromList [5,3]) @?= singleton 3\n\n{--------------------------------------------------------------------\n  Arbitrary, reasonably balanced trees\n--------------------------------------------------------------------}\n\n-- | The IsInt class lets us constrain a type variable to be Int in an entirely\n-- standard way. The constraint @ IsInt a @ is essentially equivalent to the\n-- GHC-only constraint @ a ~ Int @, but @ IsInt @ requires manual intervention\n-- to use. If ~ is ever standardized, we should certainly use it instead.\n-- Earlier versions used an Enum constraint, but this is confusing because\n-- not all Enum instances will work properly for the Arbitrary instance here.\nclass (Show a, Read a, Integral a, Arbitrary a) => IsInt a where\n  fromIntF :: f Int -> f a\n\ninstance IsInt Int where\n  fromIntF = id\n\n-- | Convert an Int to any instance of IsInt\nfromInt :: IsInt a => Int -> a\nfromInt = runIdentity . fromIntF . Identity\n\n{- We don\'t actually need this, but we can add it if we ever do\ntoIntF :: IsInt a => g a -> g Int\ntoIntF = unf . fromIntF . F $ id\n\nnewtype F g a b = F {unf :: g b -> a}\n\ntoInt :: IsInt a => a -> Int\ntoInt = runIdentity . toIntF . Identity -}\n\n\n-- How much the minimum value of an arbitrary set should vary\npositionFactor :: Int\npositionFactor = 1\n\n-- How much the gap between consecutive elements in an arbitrary\n-- set should vary\ngapRange :: Int\ngapRange = 5\n\ninstance IsInt a => Arbitrary (Set a) where\n  arbitrary = sized (\\sz0 -> do\n        sz <- choose (0, sz0)\n        middle <- choose (-positionFactor * (sz + 1), positionFactor * (sz + 1))\n        let shift = (sz * (gapRange) + 1) `quot` 2\n            start = middle - shift\n        t <- evalStateT (mkArb step sz) start\n        if valid t then pure t else error "Test generated invalid tree!")\n    where\n      step = do\n        i <- get\n        diff <- lift $ choose (1, gapRange)\n        let i\' = i + diff\n        put i\'\n        pure (fromInt i\')\n\nclass Monad m => MonadGen m where\n  liftGen :: Gen a -> m a\ninstance MonadGen Gen where\n  liftGen = id\ninstance MonadGen m => MonadGen (StateT s m) where\n  liftGen = lift . liftGen\n\n-- | Given an action that produces successively larger elements and\n-- a size, produce a set of arbitrary shape with exactly that size.\nmkArb :: MonadGen m => m a -> Int -> m (Set a)\nmkArb step n\n  | n <= 0 = return Tip\n  | n == 1 = singleton `liftM` step\n  | n == 2 = do\n     dir <- liftGen arbitrary\n     p <- step\n     q <- step\n     if dir\n       then return (Bin 2 q (singleton p) Tip)\n       else return (Bin 2 p Tip (singleton q))\n  | otherwise = do\n      -- This assumes a balance factor of delta = 3\n      let upper = (3*(n - 1)) `quot` 4\n      let lower = (n + 2) `quot` 4\n      ln <- liftGen $ choose (lower, upper)\n      let rn = n - ln - 1\n      liftM3 (\\lt x rt -> Bin n x lt rt) (mkArb step ln) step (mkArb step rn)\n\n-- | Given a strictly increasing list of elements, produce an arbitrarily\n-- shaped set with exactly those elements.\nsetFromList :: [a] -> Gen (Set a)\nsetFromList xs = flip evalStateT xs $ mkArb step (length xs)\n  where\n    step = do\n      xxs <- get\n      case xxs of\n        x : xs -> do\n          put xs\n          pure x\n        [] -> error "setFromList"\n\ndata TwoSets = TwoSets (Set Int) (Set Int) deriving (Show)\n\ndata TwoLists a = TwoLists [a] [a]\n\ndata Options2 = One2 | Two2 | Both2 deriving (Bounded, Enum)\ninstance Arbitrary Options2 where\n  arbitrary = arbitraryBoundedEnum\n\n-- We produce two lists from a simple "universe". This instance\n-- is intended to give good results when the two lists are then\n-- combined with each other; if other elements are used with them,\n-- they may or may not behave particularly well.\ninstance IsInt a => Arbitrary (TwoLists a) where\n  arbitrary = sized $ \\sz0 -> do\n    sz <- choose (0, sz0)\n    let universe = [0,3..3*(fromInt sz - 1)]\n    divide2Gen universe\n\ninstance Arbitrary TwoSets where\n  arbitrary = do\n    TwoLists l r <- arbitrary\n    TwoSets <$> setFromList l <*> setFromList r\n\ndivide2Gen :: [a] -> Gen (TwoLists a)\ndivide2Gen [] = pure (TwoLists [] [])\ndivide2Gen (x : xs) = do\n  way <- arbitrary\n  TwoLists ls rs <- divide2Gen xs\n  case way of\n    One2 -> pure (TwoLists (x : ls) rs)\n    Two2 -> pure (TwoLists ls (x : rs))\n    Both2 -> pure (TwoLists (x : ls) (x : rs))\n\n{--------------------------------------------------------------------\n  Valid trees\n--------------------------------------------------------------------}\nforValid :: (IsInt a,Testable b) => (Set a -> b) -> Property\nforValid f = forAll arbitrary $ \\t ->\n    classify (size t == 0) "empty" $\n    classify (size t > 0  && size t <= 10) "small" $\n    classify (size t > 10 && size t <= 64) "medium" $\n    classify (size t > 64) "large" $ f t\n\nforValidUnitTree :: Testable a => (Set Int -> a) -> Property\nforValidUnitTree f = forValid f\n\nprop_Valid :: Property\nprop_Valid = forValidUnitTree $ \\t -> valid t\n\n{--------------------------------------------------------------------\n  Single, Member, Insert, Delete\n--------------------------------------------------------------------}\nprop_Single :: Int -> Bool\nprop_Single x = (insert x empty == singleton x)\n\nprop_Member :: [Int] -> Int -> Bool\nprop_Member xs n =\n  let m  = fromList xs\n  in all (\\k -> k `member` m == (k `elem` xs)) (n : xs)\n\nprop_NotMember :: [Int] -> Int -> Bool\nprop_NotMember xs n =\n  let m  = fromList xs\n  in all (\\k -> k `notMember` m == (k `notElem` xs)) (n : xs)\n\ntest_LookupSomething :: (Int -> Set Int -> Maybe Int) -> (Int -> Int -> Bool) -> [Int] -> Bool\ntest_LookupSomething lookup\' cmp xs =\n  let odd_sorted_xs = filter_odd $ nub $ sort xs\n      t = fromList odd_sorted_xs\n      test x = case List.filter (`cmp` x) odd_sorted_xs of\n                 []             -> lookup\' x t == Nothing\n                 cs | 0 `cmp` 1 -> lookup\' x t == Just (last cs) -- we want largest such element\n                    | otherwise -> lookup\' x t == Just (head cs) -- we want smallest such element\n  in all test xs\n\n  where filter_odd [] = []\n        filter_odd [_] = []\n        filter_odd (_ : o : xs) = o : filter_odd xs\n\nprop_LookupLT :: [Int] -> Bool\nprop_LookupLT = test_LookupSomething lookupLT (<)\n\nprop_LookupGT :: [Int] -> Bool\nprop_LookupGT = test_LookupSomething lookupGT (>)\n\nprop_LookupLE :: [Int] -> Bool\nprop_LookupLE = test_LookupSomething lookupLE (<=)\n\nprop_LookupGE :: [Int] -> Bool\nprop_LookupGE = test_LookupSomething lookupGE (>=)\n\nprop_InsertValid :: Int -> Property\nprop_InsertValid k = forValidUnitTree $ \\t -> valid (insert k t)\n\nprop_InsertDelete :: Int -> Set Int -> Property\nprop_InsertDelete k t = not (member k t) ==> delete k (insert k t) == t\n\nprop_InsertBiased :: Int -> Set Int -> Bool\nprop_InsertBiased k t = (k, True) `member` kt\n  where\n    t\' = mapMonotonic (`OddEq` False) t\n    kt\' = insert (OddEq k True) t\'\n    kt = mapMonotonic getOddEq kt\'\n\nprop_DeleteValid :: Int -> Property\nprop_DeleteValid k = forValidUnitTree $ \\t -> valid (delete k (insert k t))\n\n{--------------------------------------------------------------------\n  alterF\n--------------------------------------------------------------------}\n\nnewtype Ident a = Ident { runIdent :: a }\ninstance Functor Ident where\n  fmap f (Ident a) = Ident (f a)\n\nnewtype Consty a b = Consty { getConsty :: a}\ninstance Functor (Consty a) where\n  fmap _ (Consty a) = Consty a\n\ndata Four a = Four a a a a\n  deriving (Eq, Show)\ninstance Functor Four where\n  fmap f (Four a b c d) = Four (f a) (f b) (f c) (f d)\n\nfour :: Bool -> Four Bool\n               -- insert  delete  id     toggle\nfour True  = Four True    False   True   False\nfour False = Four True    False   False  True\n\ntoggle :: Ord a => a -> Set a -> Set a\ntoggle k s =\n    if member k s\n        then delete k s\n        else insert k s\n\nprop_alterF :: Fun Bool [Bool] -> Int -> Set Int -> Property\nprop_alterF f k s = fmap (member k) (alterF (apply f) k s) === apply f (member k s)\n\nprop_alterF_insert :: Int -> Set Int -> Property\nprop_alterF_insert k s = runIdent (alterF (const (Ident True)) k s) === insert k s\n\nprop_alterF_delete :: Int -> Set Int -> Property\nprop_alterF_delete k s = runIdent (alterF (const (Ident False)) k s) === delete k s\n\nprop_alterF_member :: Int -> Set Int -> Property\nprop_alterF_member k s = getConsty (alterF (\\b -> Consty b) k s) === member k s\n\nprop_alterF_four :: Int -> Set Int -> Property\nprop_alterF_four k s = alterF four k s === Four (insert k s) (delete k s) s (toggle k s)\n\nprop_alterF_valid :: Int -> Set Int -> Property\nprop_alterF_valid k s = fmap valid (alterF four k s) === Four True True True True\n\n{--------------------------------------------------------------------\n  Balance\n--------------------------------------------------------------------}\nprop_Link :: Int -> Property\nprop_Link x = forValidUnitTree $ \\t ->\n    let (l,r) = split x t\n    in valid (link x l r)\n\nprop_Merge :: Int -> Property\nprop_Merge x = forValidUnitTree $ \\t ->\n    let (l,r) = split x t\n    in valid (merge l r)\n\n{--------------------------------------------------------------------\n  Union\n--------------------------------------------------------------------}\nprop_UnionValid :: Property\nprop_UnionValid\n  = forValidUnitTree $ \\t1 ->\n    forValidUnitTree $ \\t2 ->\n    valid (union t1 t2)\n\nprop_UnionInsert :: Int -> Set Int -> Bool\nprop_UnionInsert x t = union t (singleton x) == insert x t\n\nprop_UnionAssoc :: Set Int -> Set Int -> Set Int -> Bool\nprop_UnionAssoc t1 t2 t3 = union t1 (union t2 t3) == union (union t1 t2) t3\n\nprop_UnionComm :: TwoSets -> Bool\nprop_UnionComm (TwoSets t1 t2) = (union t1 t2 == union t2 t1)\n\nprop_UnionBiased :: TwoSets -> Property\nprop_UnionBiased (TwoSets l r) = union l\' r\' === union l\' (difference r\' l\')\n  where\n    l\' = mapMonotonic (`OddEq` False) l\n    r\' = mapMonotonic (`OddEq` True) r\n\nprop_IntBiased :: TwoSets -> Bool\nprop_IntBiased (TwoSets l r) = all (\\(OddEq _ b) -> not b) l\'r\'\n  where\n    l\' = mapMonotonic (`OddEq` False) l\n    r\' = mapMonotonic (`OddEq` True) r\n    l\'r\' = intersection l\' r\'\n\nprop_DiffValid :: Property\nprop_DiffValid = forValidUnitTree $ \\t1 ->\n    forValidUnitTree $ \\t2 ->\n    valid (difference t1 t2)\n\nprop_Diff :: [Int] -> [Int] -> Bool\nprop_Diff xs ys = toAscList (difference (fromList xs) (fromList ys))\n                  == List.sort ((List.\\\\) (nub xs)  (nub ys))\n\nprop_IntValid :: Property\nprop_IntValid = forValidUnitTree $ \\t1 ->\n    forValidUnitTree $ \\t2 ->\n    valid (intersection t1 t2)\n\nprop_Int :: [Int] -> [Int] -> Bool\nprop_Int xs ys = toAscList (intersection (fromList xs) (fromList ys))\n                 == List.sort (nub ((List.intersect) (xs)  (ys)))\n\nprop_disjoint :: Set Int -> Set Int -> Bool\nprop_disjoint a b = a `disjoint` b == null (a `intersection` b)\n\n{--------------------------------------------------------------------\n  Lists\n--------------------------------------------------------------------}\nprop_Ordered :: Property\nprop_Ordered = forAll (choose (5,100)) $ \\n ->\n    let xs = [0..n::Int]\n    in fromAscList xs === fromList xs\n\nprop_DescendingOrdered :: Property\nprop_DescendingOrdered = forAll (choose (5,100)) $ \\n ->\n    let xs = [n,n-1..0::Int]\n    in fromDescList xs === fromList xs\n\nprop_List :: [Int] -> Bool\nprop_List xs = (sort (nub xs) == toList (fromList xs))\n\nprop_DescList :: [Int] -> Bool\nprop_DescList xs = (reverse (sort (nub xs)) == toDescList (fromList xs))\n\nprop_AscDescList :: [Int] -> Bool\nprop_AscDescList xs = toAscList s == reverse (toDescList s)\n  where s = fromList xs\n\nprop_fromList :: [Int] -> Property\nprop_fromList xs =\n           t === fromAscList sort_xs .&&.\n           t === fromDistinctAscList nub_sort_xs .&&.\n           t === List.foldr insert empty xs\n  where t = fromList xs\n        sort_xs = sort xs\n        nub_sort_xs = List.map List.head $ List.group sort_xs\n\nprop_fromListDesc :: [Int] -> Property\nprop_fromListDesc xs =\n           t === fromDescList sort_xs .&&.\n           t === fromDistinctDescList nub_sort_xs .&&.\n           t === List.foldr insert empty xs\n  where t = fromList xs\n        sort_xs = reverse (sort xs)\n        nub_sort_xs = List.map List.head $ List.group sort_xs\n\n{--------------------------------------------------------------------\n  Set operations are like IntSet operations\n--------------------------------------------------------------------}\ntoIntSet :: Set Int -> IntSet.IntSet\ntoIntSet = IntSet.fromList . toList\n\n-- Check that Set Int.isProperSubsetOf is the same as Set.isProperSubsetOf.\nprop_isProperSubsetOf :: TwoSets -> Bool\nprop_isProperSubsetOf (TwoSets a b) = isProperSubsetOf a b == IntSet.isProperSubsetOf (toIntSet a) (toIntSet b)\n\n-- In the above test, isProperSubsetOf almost always returns False (since a\n-- random set is almost never a subset of another random set).  So this second\n-- test checks the True case.\nprop_isProperSubsetOf2 :: TwoSets -> Bool\nprop_isProperSubsetOf2 (TwoSets a b) = isProperSubsetOf a c == (a /= c) where\n  c = union a b\n\nprop_isSubsetOf :: TwoSets -> Bool\nprop_isSubsetOf (TwoSets a b) = isSubsetOf a b == IntSet.isSubsetOf (toIntSet a) (toIntSet b)\n\nprop_isSubsetOf2 :: TwoSets -> Bool\nprop_isSubsetOf2 (TwoSets a b) = isSubsetOf a (union a b)\n\nprop_size :: Set Int -> Bool\nprop_size s = size s == List.length (toList s)\n\nprop_findMax :: Set Int -> Property\nprop_findMax s = not (null s) ==> findMax s == maximum (toList s)\n\nprop_findMin :: Set Int -> Property\nprop_findMin s = not (null s) ==> findMin s == minimum (toList s)\n\nprop_lookupMin :: Set Int -> Property\nprop_lookupMin m = lookupMin m === (fst <$> minView m)\n\nprop_lookupMax :: Set Int -> Property\nprop_lookupMax m = lookupMax m === (fst <$> maxView m)\n\nprop_ord :: TwoSets -> Bool\nprop_ord (TwoSets s1 s2) = s1 `compare` s2 == toList s1 `compare` toList s2\n\nprop_readShow :: Set Int -> Bool\nprop_readShow s = s == read (show s)\n\nprop_foldR :: Set Int -> Bool\nprop_foldR s = foldr (:) [] s == toList s\n\nprop_foldR\' :: Set Int -> Bool\nprop_foldR\' s = foldr\' (:) [] s == toList s\n\nprop_foldL :: Set Int -> Bool\nprop_foldL s = foldl (flip (:)) [] s == List.foldl (flip (:)) [] (toList s)\n\nprop_foldL\' :: Set Int -> Bool\nprop_foldL\' s = foldl\' (flip (:)) [] s == List.foldl\' (flip (:)) [] (toList s)\n\nprop_map :: Set Int -> Bool\nprop_map s = map id s == s\n\nprop_map2 :: Fun Int Int -> Fun Int Int -> Set Int -> Property\nprop_map2 f g s = map (apply f) (map (apply g) s) === map (apply f . apply g) s\n\nprop_mapMonotonic :: Set Int -> Property\nprop_mapMonotonic s = mapMonotonic id s === s\n\nprop_maxView :: Set Int -> Bool\nprop_maxView s = case maxView s of\n    Nothing -> null s\n    Just (m,s\') -> m == maximum (toList s) && s == insert m s\' && m `notMember` s\'\n\nprop_minView :: Set Int -> Bool\nprop_minView s = case minView s of\n    Nothing -> null s\n    Just (m,s\') -> m == minimum (toList s) && s == insert m s\' && m `notMember` s\'\n\nprop_split :: Set Int -> Int -> Bool\nprop_split s i = case split i s of\n    (s1,s2) -> all (<i) (toList s1) && all (>i) (toList s2) && i `delete` s == union s1 s2\n\nprop_splitMember :: Set Int -> Int -> Bool\nprop_splitMember s i = case splitMember i s of\n    (s1,t,s2) -> all (<i) (toList s1) && all (>i) (toList s2) && t == i `member` s && i `delete` s == union s1 s2\n\nprop_splitRoot :: Set Int -> Bool\nprop_splitRoot s = loop ls && (s == unions ls)\n where\n  ls = splitRoot s\n  loop [] = True\n  loop (s1:rst) = List.null\n                  [ (x,y) | x <- toList s1\n                          , y <- toList (unions rst)\n                          , x > y ]\n\nprop_partition :: Set Int -> Int -> Bool\nprop_partition s i = case partition odd s of\n    (s1,s2) -> all odd (toList s1) && all even (toList s2) && s == s1 `union` s2\n\nprop_filter :: Set Int -> Int -> Bool\nprop_filter s i = partition odd s == (filter odd s, filter even s)\n\nprop_take :: Int -> Set Int -> Property\nprop_take n xs = valid taken .&&.\n                 taken === fromDistinctAscList (List.take n (toList xs))\n  where\n    taken = take n xs\n\nprop_drop :: Int -> Set Int -> Property\nprop_drop n xs = valid dropped .&&.\n                 dropped === fromDistinctAscList (List.drop n (toList xs))\n  where\n    dropped = drop n xs\n\nprop_splitAt :: Int -> Set Int -> Property\nprop_splitAt n xs = valid taken .&&.\n                    valid dropped .&&.\n                    taken === take n xs .&&.\n                    dropped === drop n xs\n  where\n    (taken, dropped) = splitAt n xs\n\nprop_takeWhileAntitone :: [Either Int Int] -> Property\nprop_takeWhileAntitone xs\' = valid tw .&&. tw === filter isLeft xs\n  where\n    xs = fromList xs\'\n    tw = takeWhileAntitone isLeft xs\n\nprop_dropWhileAntitone :: [Either Int Int] -> Property\nprop_dropWhileAntitone xs\' = valid tw .&&. tw === filter (not . isLeft) xs\n  where\n    xs = fromList xs\'\n    tw = dropWhileAntitone isLeft xs\n\nprop_spanAntitone :: [Either Int Int] -> Property\nprop_spanAntitone xs\' = valid tw .&&. valid dw\n                        .&&. tw === takeWhileAntitone isLeft xs\n                        .&&. dw === dropWhileAntitone isLeft xs\n  where\n    xs = fromList xs\'\n    (tw, dw) = spanAntitone isLeft xs\n\nprop_powerSet :: Property\nprop_powerSet = forAll (resize 10 arbitrary :: Gen (Set Int)) $ \\xs ->\n   -- We don\'t actually have to check on the values directly, because the power\n   -- set is the *only* one that can be produced by a function with the type of\n   -- `powerSet` and satisfy the criteria below. In particular, the `valid ps`\n   -- test ensures that we haven\'t duplicated any subsets, while the size test\n   -- ensures that we haven\'t omitted any. Parametricity ensures that we\n   -- haven\'t produced any elements out of thin air.\n   let ps = powerSet xs\n   in valid ps .&&. all valid ps .&&. size ps === 2^size xs\n\nprop_cartesianProduct :: Set Int -> Set Int -> Property\nprop_cartesianProduct xs ys =\n  valid cp .&&. toList cp === liftA2 (,) (toList xs) (toList ys)\n  where cp = cartesianProduct xs ys\n\nprop_disjointUnion :: Set Int -> Set Int -> Property\nprop_disjointUnion xs ys =\n  valid du .&&. du === union (mapMonotonic Left xs) (mapMonotonic Right ys)\n  where du = disjointUnion xs ys\n\nisLeft :: Either a b -> Bool\nisLeft (Left _) = True\nisLeft _ = False\n\n#if __GLASGOW_HASKELL__ >= 806\nprop_strictFoldr\' :: Set Int -> Property\nprop_strictFoldr\' m = whnfHasNoThunks (foldr\' (:) [] m)\n#endif\n\n#if __GLASGOW_HASKELL__ >= 806\nprop_strictFoldl\' :: Set Int -> Property\nprop_strictFoldl\' m = whnfHasNoThunks (foldl\' (flip (:)) [] m)\n#endif\n'