b'using System;\nusing System.IO;\nusing System.Text;\nusing System.Threading;\n\nnamespace qqzeng_ip_dat\n{\n   \n\n    public class IPSearch3Fast\n    {\n        private static readonly Lazy<IPSearch3Fast> lazy = new Lazy<IPSearch3Fast>(() => new IPSearch3Fast());\n        public static IPSearch3Fast Instance { get { return lazy.Value; } }\n        private IPSearch3Fast()\n        {\n            LoadDat();\n            Watch();\n        }\n\n        private string datPath = Path.Combine(AppDomain.CurrentDomain.BaseDirectory, @"qqzeng-ip-ultimate.dat");\n        private DateTime lastRead = DateTime.MinValue;\n\n        private long[,] prefmap = new long[256, 2];\n        private uint[] endArr;\n        private string[] addrArr;\n        private byte[] data;\n\n\n\n        /// <summary>\n        /// \xe5\x88\x9d\xe5\xa7\x8b\xe5\x8c\x96\xe4\xba\x8c\xe8\xbf\x9b\xe5\x88\xb6 qqzeng-ip-ultimate.dat \xe6\x95\xb0\xe6\x8d\xae\n        /// </summary>\n\n        private void LoadDat()\n        {\n            data = File.ReadAllBytes(datPath);\n\n            for (int k = 0; k < 256; k++)\n            {\n                int i = k * 8 + 4;\n                int prefix = k;\n                long startIndex = ReadLittleEndian32(data[i], data[i + 1], data[i + 2], data[i + 3]);\n                long endIndex = ReadLittleEndian32(data[i + 4], data[i + 5], data[i + 6], data[i + 7]);\n                prefmap[k, 0] = startIndex; prefmap[k, 1] = endIndex;\n            }\n\n            uint RecordSize = ReadLittleEndian32(data[0], data[1], data[2], data[3]);\n            endArr = new uint[RecordSize];\n            addrArr = new string[RecordSize];\n            for (int i = 0; i < RecordSize; i++)\n            {\n                long p = 2052 + (i * 8);\n                uint endipnum = ReadLittleEndian32(data[p], data[1 + p], data[2 + p], data[3 + p]);\n\n                int offset = data[4 + p] + ((data[5 + p]) << 8) + ((data[6 + p]) << 16);\n                int length = data[7 + p];\n\n                endArr[i] = endipnum;\n                addrArr[i] = Encoding.UTF8.GetString(data, offset, length);\n            }\n\n\n\n        }\n        private void Watch()\n        {\n            FileInfo fi = new FileInfo(datPath);\n            FileSystemWatcher watcher = new FileSystemWatcher(fi.DirectoryName)\n            {\n                IncludeSubdirectories = false,\n                NotifyFilter = NotifyFilters.LastWrite,\n                Filter = "qqzeng-ip-ultimate.dat",\n            };\n\n            watcher.Changed += (s, e) =>\n            {\n\n                var lastWriteTime = File.GetLastWriteTime(datPath);\n\n                if (lastWriteTime > lastRead)\n                {                   \n                    //\xe5\xbb\xb6\xe6\x97\xb6 \xe8\xa7\xa3\xe5\x86\xb3 \xe6\xad\xa3\xe7\x94\xb1\xe5\x8f\xa6\xe4\xb8\x80\xe8\xbf\x9b\xe7\xa8\x8b\xe4\xbd\xbf\xe7\x94\xa8,\xe5\x9b\xa0\xe6\xad\xa4\xe8\xaf\xa5\xe8\xbf\x9b\xe7\xa8\x8b\xe6\x97\xa0\xe6\xb3\x95\xe8\xae\xbf\xe9\x97\xae\xe6\xad\xa4\xe6\x96\x87\xe4\xbb\xb6\n                    Thread.Sleep(1000);\n\n                    LoadDat();\n                    lastRead = lastWriteTime;\n                }\n            };\n            watcher.EnableRaisingEvents = true;\n        }\n\n\n\n\n\n        /// <summary>\n        /// ip\xe5\xbf\xab\xe9\x80\x9f\xe6\x9f\xa5\xe8\xaf\xa2\xe6\x96\xb9\xe6\xb3\x95\n        /// </summary>\n        /// <param name="ip">1.1.1.1</param>\n        /// <returns></returns>\n        public string Find(string ip)\n        {\n            long val = IpToInt(ip, out long pref);\n            long low = prefmap[pref, 0], high = prefmap[pref, 1];\n            long cur = low == high ? low : BinarySearch(low, high, val);\n            // cur==-1 \xe7\x9b\xb8\xe5\xbd\x93\xe6\x89\xbe\xe4\xb8\x8d\xe5\x88\xb0\xe6\x95\xb0\xe6\x8d\xae\n            return cur>-1? addrArr[cur]: "||||||||||";\n        }\n\n\n       \n\n\n\n\n        // \xe4\xba\x8c\xe5\x88\x86\xe9\x80\xbc\xe8\xbf\x91 O(logN)\n        private long BinarySearch(long low, long high, long k)\n        {\n            long M = -1, mid = 0;\n            while (low <= high)\n            {\n                mid = (low + high) / 2;\n                uint endipnum = endArr[mid];\n                if (endipnum >= k)\n                {\n                    M = mid;\n                    if (mid == 0)\n                    {\n                        break;   //\xe9\x98\xb2\xe6\xad\xa2\xe6\xba\xa2\xe5\x87\xba\n                    }\n                    high = mid - 1;\n                }\n                else\n                    low = mid + 1;\n            }\n            return M;\n        }\n\n\n       \n        private long IpToInt(string ipString, out long prefix)\n        {\n            //\xe9\xab\x98\xe6\x80\xa7\xe8\x83\xbd\n            int end = ipString.Length;\n            unsafe\n            {\n                fixed (char* name = ipString)\n                {\n\n                    int numberBase = 10;\n                    char ch;\n                    long[] parts = new long[4];\n                    long currentValue = 0;\n                    int dotCount = 0;\n                    int current = 0;\n                    for (; current < end; current++)\n                    {\n                        ch = name[current];\n                        currentValue = 0;\n\n                        numberBase = 10;\n                        if (ch == \'0\')\n                        {\n                            numberBase = 8;\n                            current++;\n\n                            if (current < end)\n                            {\n                                ch = name[current];\n                                if (ch == \'x\' || ch == \'X\')\n                                {\n                                    numberBase = 16;\n                                    current++;\n                                }\n                            }\n                        }\n\n                        for (; current < end; current++)\n                        {\n                            ch = name[current];\n                            int digitValue;\n\n                            if ((numberBase == 10 || numberBase == 16) && \'0\' <= ch && ch <= \'9\')\n                            {\n                                digitValue = ch - \'0\';\n                            }\n                            else if (numberBase == 8 && \'0\' <= ch && ch <= \'7\')\n                            {\n                                digitValue = ch - \'0\';\n                            }\n                            else if (numberBase == 16 && \'a\' <= ch && ch <= \'f\')\n                            {\n                                digitValue = ch + 10 - \'a\';\n                            }\n                            else if (numberBase == 16 && \'A\' <= ch && ch <= \'F\')\n                            {\n                                digitValue = ch + 10 - \'A\';\n                            }\n                            else\n                            {\n                                break;\n                            }\n\n                            currentValue = (currentValue * numberBase) + digitValue;\n\n                        }\n\n                        if (current < end && name[current] == \'.\')\n                        {\n                            parts[dotCount] = currentValue;\n                            dotCount++;\n                            continue;\n                        }\n                        break;\n                    }\n                    parts[dotCount] = currentValue;\n                    prefix = parts[0];\n                    return (parts[0] << 24) | ((parts[1] & 0xff) << 16) | ((parts[2] & 0xff) << 8) | (parts[3] & 0xff);\n                }\n            }\n\n            //\xe7\xae\x80\xe6\xb4\x81\xe7\x9a\x84 \xe6\x99\xae\xe9\x80\x9a \n\n            //byte[] b = IPAddress.Parse(ip).GetAddressBytes();\n            //prefix = b[0];  \n            // return ReadBigEndian32(b[0], b[1], b[2], b[3]);\n        }\n\n\n        private uint ReadBigEndian32(byte a, byte b, byte c, byte d)\n        {\n            return (uint)((a << 24) | (b << 16) | (c << 8) | d);\n        }\n\n\n        private uint ReadLittleEndian32(byte a, byte b, byte c, byte d)\n        {\n            return (uint)(a | (b << 8) | (c << 16) | (d << 24));\n        }\n\n\n\n\n\n    }\n\n    /*\n    \xef\xbc\x88\xe8\xb0\x83\xe7\x94\xa8\xe4\xbe\x8b\xe5\xad\x90\xef\xbc\x89\xef\xbc\x9a   \n    string result = IPSearch3Fast.Instance.Find("1.2.3.4");\n   --> result="\xe4\xba\x9a\xe6\xb4\xb2|\xe4\xb8\xad\xe5\x9b\xbd|\xe9\xa6\x99\xe6\xb8\xaf|\xe4\xb9\x9d\xe9\xbe\x99|\xe6\xb2\xb9\xe5\xb0\x96\xe6\x97\xba|\xe6\x96\xb0\xe4\xb8\x96\xe7\x95\x8c\xe7\x94\xb5\xe8\xae\xaf|810200|Hong Kong|HK|114.17495|22.327115" \n    */\n}\n'