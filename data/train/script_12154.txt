b'/* \n * QR Code generator library (Java)\n * \n * Copyright (c) Project Nayuki. (MIT License)\n * https://www.nayuki.io/page/qr-code-generator-library\n * \n * Permission is hereby granted, free of charge, to any person obtaining a copy of\n * this software and associated documentation files (the "Software"), to deal in\n * the Software without restriction, including without limitation the rights to\n * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of\n * the Software, and to permit persons to whom the Software is furnished to do so,\n * subject to the following conditions:\n * - The above copyright notice and this permission notice shall be included in\n *   all copies or substantial portions of the Software.\n * - The Software is provided "as is", without warranty of any kind, express or\n *   implied, including but not limited to the warranties of merchantability,\n *   fitness for a particular purpose and noninfringement. In no event shall the\n *   authors or copyright holders be liable for any claim, damages or other\n *   liability, whether in an action of contract, tort or otherwise, arising from,\n *   out of or in connection with the Software or the use or other dealings in the\n *   Software.\n */\n\npackage io.nayuki.qrcodegen;\n\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Objects;\n\n\n/**\n * A QR Code symbol, which is a type of two-dimension barcode.\n * Invented by Denso Wave and described in the ISO/IEC 18004 standard.\n * <p>Instances of this class represent an immutable square grid of dark and light cells.\n * The class provides static factory functions to create a QR Code from text or binary data.\n * The class covers the QR Code Model 2 specification, supporting all versions (sizes)\n * from 1 to 40, all 4 error correction levels, and 4 character encoding modes.</p>\n * <p>Ways to create a QR Code object:</p>\n * <ul>\n *   <li><p>High level: Take the payload data and call {@link QrCode#encodeText(CharSequence,Ecc)}\n *     or {@link QrCode#encodeBinary(byte[],Ecc)}.</p></li>\n *   <li><p>Mid level: Custom-make the list of {@link QrSegment segments}\n *     and call {@link QrCode#encodeSegments(List,Ecc)} or\n *     {@link QrCode#encodeSegments(List,Ecc,int,int,int,boolean)}</p></li>\n *   <li><p>Low level: Custom-make the array of data codeword bytes (including segment headers and\n *     final padding, excluding error correction codewords), supply the appropriate version number,\n *     and call the {@link QrCode#QrCode(int,Ecc,byte[],int) constructor}.</p></li>\n * </ul>\n * <p>(Note that all ways require supplying the desired error correction level.)</p>\n * @see QrSegment\n */\npublic final class QrCode {\n\t\n\t/*---- Static factory functions (high level) ----*/\n\t\n\t/**\n\t * Returns a QR Code representing the specified Unicode text string at the specified error correction level.\n\t * As a conservative upper bound, this function is guaranteed to succeed for strings that have 738 or fewer\n\t * Unicode code points (not UTF-16 code units) if the low error correction level is used. The smallest possible\n\t * QR Code version is automatically chosen for the output. The ECC level of the result may be higher than the\n\t * ecl argument if it can be done without increasing the version.\n\t * @param text the text to be encoded (not {@code null}), which can be any Unicode string\n\t * @param ecl the error correction level to use (not {@code null}) (boostable)\n\t * @return a QR Code (not {@code null}) representing the text\n\t * @throws NullPointerException if the text or error correction level is {@code null}\n\t * @throws DataTooLongException if the text fails to fit in the\n\t * largest version QR Code at the ECL, which means it is too long\n\t */\n\tpublic static QrCode encodeText(CharSequence text, Ecc ecl) {\n\t\tObjects.requireNonNull(text);\n\t\tObjects.requireNonNull(ecl);\n\t\tList<QrSegment> segs = QrSegment.makeSegments(text);\n\t\treturn encodeSegments(segs, ecl);\n\t}\n\t\n\t\n\t/**\n\t * Returns a QR Code representing the specified binary data at the specified error correction level.\n\t * This function always encodes using the binary segment mode, not any text mode. The maximum number of\n\t * bytes allowed is 2953. The smallest possible QR Code version is automatically chosen for the output.\n\t * The ECC level of the result may be higher than the ecl argument if it can be done without increasing the version.\n\t * @param data the binary data to encode (not {@code null})\n\t * @param ecl the error correction level to use (not {@code null}) (boostable)\n\t * @return a QR Code (not {@code null}) representing the data\n\t * @throws NullPointerException if the data or error correction level is {@code null}\n\t * @throws DataTooLongException if the data fails to fit in the\n\t * largest version QR Code at the ECL, which means it is too long\n\t */\n\tpublic static QrCode encodeBinary(byte[] data, Ecc ecl) {\n\t\tObjects.requireNonNull(data);\n\t\tObjects.requireNonNull(ecl);\n\t\tQrSegment seg = QrSegment.makeBytes(data);\n\t\treturn encodeSegments(Arrays.asList(seg), ecl);\n\t}\n\t\n\t\n\t/*---- Static factory functions (mid level) ----*/\n\t\n\t/**\n\t * Returns a QR Code representing the specified segments at the specified error correction\n\t * level. The smallest possible QR Code version is automatically chosen for the output. The ECC level\n\t * of the result may be higher than the ecl argument if it can be done without increasing the version.\n\t * <p>This function allows the user to create a custom sequence of segments that switches\n\t * between modes (such as alphanumeric and byte) to encode text in less space.\n\t * This is a mid-level API; the high-level API is {@link #encodeText(CharSequence,Ecc)}\n\t * and {@link #encodeBinary(byte[],Ecc)}.</p>\n\t * @param segs the segments to encode\n\t * @param ecl the error correction level to use (not {@code null}) (boostable)\n\t * @return a QR Code (not {@code null}) representing the segments\n\t * @throws NullPointerException if the list of segments, any segment, or the error correction level is {@code null}\n\t * @throws DataTooLongException if the segments fail to fit in the\n\t * largest version QR Code at the ECL, which means they are too long\n\t */\n\tpublic static QrCode encodeSegments(List<QrSegment> segs, Ecc ecl) {\n\t\treturn encodeSegments(segs, ecl, MIN_VERSION, MAX_VERSION, -1, true);\n\t}\n\t\n\t\n\t/**\n\t * Returns a QR Code representing the specified segments with the specified encoding parameters.\n\t * The smallest possible QR Code version within the specified range is automatically\n\t * chosen for the output. Iff boostEcl is {@code true}, then the ECC level of the\n\t * result may be higher than the ecl argument if it can be done without increasing\n\t * the version. The mask number is either between 0 to 7 (inclusive) to force that\n\t * mask, or &#x2212;1 to automatically choose an appropriate mask (which may be slow).\n\t * <p>This function allows the user to create a custom sequence of segments that switches\n\t * between modes (such as alphanumeric and byte) to encode text in less space.\n\t * This is a mid-level API; the high-level API is {@link #encodeText(CharSequence,Ecc)}\n\t * and {@link #encodeBinary(byte[],Ecc)}.</p>\n\t * @param segs the segments to encode\n\t * @param ecl the error correction level to use (not {@code null}) (boostable)\n\t * @param minVersion the minimum allowed version of the QR Code (at least 1)\n\t * @param maxVersion the maximum allowed version of the QR Code (at most 40)\n\t * @param mask the mask number to use (between 0 and 7 (inclusive)), or &#x2212;1 for automatic mask\n\t * @param boostEcl increases the ECC level as long as it doesn\'t increase the version number\n\t * @return a QR Code (not {@code null}) representing the segments\n\t * @throws NullPointerException if the list of segments, any segment, or the error correction level is {@code null}\n\t * @throws IllegalArgumentException if 1 &#x2264; minVersion &#x2264; maxVersion &#x2264; 40\n\t * or &#x2212;1 &#x2264; mask &#x2264; 7 is violated\n\t * @throws DataTooLongException if the segments fail to fit in\n\t * the maxVersion QR Code at the ECL, which means they are too long\n\t */\n\tpublic static QrCode encodeSegments(List<QrSegment> segs, Ecc ecl, int minVersion, int maxVersion, int mask, boolean boostEcl) {\n\t\tObjects.requireNonNull(segs);\n\t\tObjects.requireNonNull(ecl);\n\t\tif (!(MIN_VERSION <= minVersion && minVersion <= maxVersion && maxVersion <= MAX_VERSION) || mask < -1 || mask > 7)\n\t\t\tthrow new IllegalArgumentException("Invalid value");\n\t\t\n\t\t// Find the minimal version number to use\n\t\tint version, dataUsedBits;\n\t\tfor (version = minVersion; ; version++) {\n\t\t\tint dataCapacityBits = getNumDataCodewords(version, ecl) * 8;  // Number of data bits available\n\t\t\tdataUsedBits = QrSegment.getTotalBits(segs, version);\n\t\t\tif (dataUsedBits != -1 && dataUsedBits <= dataCapacityBits)\n\t\t\t\tbreak;  // This version number is found to be suitable\n\t\t\tif (version >= maxVersion) {  // All versions in the range could not fit the given data\n\t\t\t\tString msg = "Segment too long";\n\t\t\t\tif (dataUsedBits != -1)\n\t\t\t\t\tmsg = String.format("Data length = %d bits, Max capacity = %d bits", dataUsedBits, dataCapacityBits);\n\t\t\t\tthrow new DataTooLongException(msg);\n\t\t\t}\n\t\t}\n\t\tassert dataUsedBits != -1;\n\t\t\n\t\t// Increase the error correction level while the data still fits in the current version number\n\t\tfor (Ecc newEcl : Ecc.values()) {  // From low to high\n\t\t\tif (boostEcl && dataUsedBits <= getNumDataCodewords(version, newEcl) * 8)\n\t\t\t\tecl = newEcl;\n\t\t}\n\t\t\n\t\t// Concatenate all segments to create the data bit string\n\t\tBitBuffer bb = new BitBuffer();\n\t\tfor (QrSegment seg : segs) {\n\t\t\tbb.appendBits(seg.mode.modeBits, 4);\n\t\t\tbb.appendBits(seg.numChars, seg.mode.numCharCountBits(version));\n\t\t\tbb.appendData(seg.data);\n\t\t}\n\t\tassert bb.bitLength() == dataUsedBits;\n\t\t\n\t\t// Add terminator and pad up to a byte if applicable\n\t\tint dataCapacityBits = getNumDataCodewords(version, ecl) * 8;\n\t\tassert bb.bitLength() <= dataCapacityBits;\n\t\tbb.appendBits(0, Math.min(4, dataCapacityBits - bb.bitLength()));\n\t\tbb.appendBits(0, (8 - bb.bitLength() % 8) % 8);\n\t\tassert bb.bitLength() % 8 == 0;\n\t\t\n\t\t// Pad with alternating bytes until data capacity is reached\n\t\tfor (int padByte = 0xEC; bb.bitLength() < dataCapacityBits; padByte ^= 0xEC ^ 0x11)\n\t\t\tbb.appendBits(padByte, 8);\n\t\t\n\t\t// Pack bits into bytes in big endian\n\t\tbyte[] dataCodewords = new byte[bb.bitLength() / 8];\n\t\tfor (int i = 0; i < bb.bitLength(); i++)\n\t\t\tdataCodewords[i >>> 3] |= bb.getBit(i) << (7 - (i & 7));\n\t\t\n\t\t// Create the QR Code object\n\t\treturn new QrCode(version, ecl, dataCodewords, mask);\n\t}\n\t\n\t\n\t\n\t/*---- Instance fields ----*/\n\t\n\t// Public immutable scalar parameters:\n\t\n\t/** The version number of this QR Code, which is between 1 and 40 (inclusive).\n\t * This determines the size of this barcode. */\n\tpublic final int version;\n\t\n\t/** The width and height of this QR Code, measured in modules, between\n\t * 21 and 177 (inclusive). This is equal to version &#xD7; 4 + 17. */\n\tpublic final int size;\n\t\n\t/** The error correction level used in this QR Code, which is not {@code null}. */\n\tpublic final Ecc errorCorrectionLevel;\n\t\n\t/** The index of the mask pattern used in this QR Code, which is between 0 and 7 (inclusive).\n\t * <p>Even if a QR Code is created with automatic masking requested (mask =\n\t * &#x2212;1), the resulting object still has a mask value between 0 and 7. */\n\tpublic final int mask;\n\t\n\t// Private grids of modules/pixels, with dimensions of size*size:\n\t\n\t// The modules of this QR Code (false = light, true = dark).\n\t// Immutable after constructor finishes. Accessed through getModule().\n\tprivate boolean[][] modules;\n\t\n\t// Indicates function modules that are not subjected to masking. Discarded when constructor finishes.\n\tprivate boolean[][] isFunction;\n\t\n\t\n\t\n\t/*---- Constructor (low level) ----*/\n\t\n\t/**\n\t * Constructs a QR Code with the specified version number,\n\t * error correction level, data codeword bytes, and mask number.\n\t * <p>This is a low-level API that most users should not use directly. A mid-level\n\t * API is the {@link #encodeSegments(List,Ecc,int,int,int,boolean)} function.</p>\n\t * @param ver the version number to use, which must be in the range 1 to 40 (inclusive)\n\t * @param ecl the error correction level to use\n\t * @param dataCodewords the bytes representing segments to encode (without ECC)\n\t * @param msk the mask pattern to use, which is either &#x2212;1 for automatic choice or from 0 to 7 for fixed choice\n\t * @throws NullPointerException if the byte array or error correction level is {@code null}\n\t * @throws IllegalArgumentException if the version or mask value is out of range,\n\t * or if the data is the wrong length for the specified version and error correction level\n\t */\n\tpublic QrCode(int ver, Ecc ecl, byte[] dataCodewords, int msk) {\n\t\t// Check arguments and initialize fields\n\t\tif (ver < MIN_VERSION || ver > MAX_VERSION)\n\t\t\tthrow new IllegalArgumentException("Version value out of range");\n\t\tif (msk < -1 || msk > 7)\n\t\t\tthrow new IllegalArgumentException("Mask value out of range");\n\t\tversion = ver;\n\t\tsize = ver * 4 + 17;\n\t\terrorCorrectionLevel = Objects.requireNonNull(ecl);\n\t\tObjects.requireNonNull(dataCodewords);\n\t\tmodules    = new boolean[size][size];  // Initially all light\n\t\tisFunction = new boolean[size][size];\n\t\t\n\t\t// Compute ECC, draw modules, do masking\n\t\tdrawFunctionPatterns();\n\t\tbyte[] allCodewords = addEccAndInterleave(dataCodewords);\n\t\tdrawCodewords(allCodewords);\n\t\t\n\t\t// Do masking\n\t\tif (msk == -1) {  // Automatically choose best mask\n\t\t\tint minPenalty = Integer.MAX_VALUE;\n\t\t\tfor (int i = 0; i < 8; i++) {\n\t\t\t\tapplyMask(i);\n\t\t\t\tdrawFormatBits(i);\n\t\t\t\tint penalty = getPenaltyScore();\n\t\t\t\tif (penalty < minPenalty) {\n\t\t\t\t\tmsk = i;\n\t\t\t\t\tminPenalty = penalty;\n\t\t\t\t}\n\t\t\t\tapplyMask(i);  // Undoes the mask due to XOR\n\t\t\t}\n\t\t}\n\t\tassert 0 <= msk && msk <= 7;\n\t\tmask = msk;\n\t\tapplyMask(msk);  // Apply the final choice of mask\n\t\tdrawFormatBits(msk);  // Overwrite old format bits\n\t\t\n\t\tisFunction = null;\n\t}\n\t\n\t\n\t\n\t/*---- Public instance methods ----*/\n\t\n\t/**\n\t * Returns the color of the module (pixel) at the specified coordinates, which is {@code false}\n\t * for light or {@code true} for dark. The top left corner has the coordinates (x=0, y=0).\n\t * If the specified coordinates are out of bounds, then {@code false} (light) is returned.\n\t * @param x the x coordinate, where 0 is the left edge and size&#x2212;1 is the right edge\n\t * @param y the y coordinate, where 0 is the top edge and size&#x2212;1 is the bottom edge\n\t * @return {@code true} if the coordinates are in bounds and the module\n\t * at that location is dark, or {@code false} (light) otherwise\n\t */\n\tpublic boolean getModule(int x, int y) {\n\t\treturn 0 <= x && x < size && 0 <= y && y < size && modules[y][x];\n\t}\n\t\n\t\n\t\n\t/*---- Private helper methods for constructor: Drawing function modules ----*/\n\t\n\t// Reads this object\'s version field, and draws and marks all function modules.\n\tprivate void drawFunctionPatterns() {\n\t\t// Draw horizontal and vertical timing patterns\n\t\tfor (int i = 0; i < size; i++) {\n\t\t\tsetFunctionModule(6, i, i % 2 == 0);\n\t\t\tsetFunctionModule(i, 6, i % 2 == 0);\n\t\t}\n\t\t\n\t\t// Draw 3 finder patterns (all corners except bottom right; overwrites some timing modules)\n\t\tdrawFinderPattern(3, 3);\n\t\tdrawFinderPattern(size - 4, 3);\n\t\tdrawFinderPattern(3, size - 4);\n\t\t\n\t\t// Draw numerous alignment patterns\n\t\tint[] alignPatPos = getAlignmentPatternPositions();\n\t\tint numAlign = alignPatPos.length;\n\t\tfor (int i = 0; i < numAlign; i++) {\n\t\t\tfor (int j = 0; j < numAlign; j++) {\n\t\t\t\t// Don\'t draw on the three finder corners\n\t\t\t\tif (!(i == 0 && j == 0 || i == 0 && j == numAlign - 1 || i == numAlign - 1 && j == 0))\n\t\t\t\t\tdrawAlignmentPattern(alignPatPos[i], alignPatPos[j]);\n\t\t\t}\n\t\t}\n\t\t\n\t\t// Draw configuration data\n\t\tdrawFormatBits(0);  // Dummy mask value; overwritten later in the constructor\n\t\tdrawVersion();\n\t}\n\t\n\t\n\t// Draws two copies of the format bits (with its own error correction code)\n\t// based on the given mask and this object\'s error correction level field.\n\tprivate void drawFormatBits(int msk) {\n\t\t// Calculate error correction code and pack bits\n\t\tint data = errorCorrectionLevel.formatBits << 3 | msk;  // errCorrLvl is uint2, mask is uint3\n\t\tint rem = data;\n\t\tfor (int i = 0; i < 10; i++)\n\t\t\trem = (rem << 1) ^ ((rem >>> 9) * 0x537);\n\t\tint bits = (data << 10 | rem) ^ 0x5412;  // uint15\n\t\tassert bits >>> 15 == 0;\n\t\t\n\t\t// Draw first copy\n\t\tfor (int i = 0; i <= 5; i++)\n\t\t\tsetFunctionModule(8, i, getBit(bits, i));\n\t\tsetFunctionModule(8, 7, getBit(bits, 6));\n\t\tsetFunctionModule(8, 8, getBit(bits, 7));\n\t\tsetFunctionModule(7, 8, getBit(bits, 8));\n\t\tfor (int i = 9; i < 15; i++)\n\t\t\tsetFunctionModule(14 - i, 8, getBit(bits, i));\n\t\t\n\t\t// Draw second copy\n\t\tfor (int i = 0; i < 8; i++)\n\t\t\tsetFunctionModule(size - 1 - i, 8, getBit(bits, i));\n\t\tfor (int i = 8; i < 15; i++)\n\t\t\tsetFunctionModule(8, size - 15 + i, getBit(bits, i));\n\t\tsetFunctionModule(8, size - 8, true);  // Always dark\n\t}\n\t\n\t\n\t// Draws two copies of the version bits (with its own error correction code),\n\t// based on this object\'s version field, iff 7 <= version <= 40.\n\tprivate void drawVersion() {\n\t\tif (version < 7)\n\t\t\treturn;\n\t\t\n\t\t// Calculate error correction code and pack bits\n\t\tint rem = version;  // version is uint6, in the range [7, 40]\n\t\tfor (int i = 0; i < 12; i++)\n\t\t\trem = (rem << 1) ^ ((rem >>> 11) * 0x1F25);\n\t\tint bits = version << 12 | rem;  // uint18\n\t\tassert bits >>> 18 == 0;\n\t\t\n\t\t// Draw two copies\n\t\tfor (int i = 0; i < 18; i++) {\n\t\t\tboolean bit = getBit(bits, i);\n\t\t\tint a = size - 11 + i % 3;\n\t\t\tint b = i / 3;\n\t\t\tsetFunctionModule(a, b, bit);\n\t\t\tsetFunctionModule(b, a, bit);\n\t\t}\n\t}\n\t\n\t\n\t// Draws a 9*9 finder pattern including the border separator,\n\t// with the center module at (x, y). Modules can be out of bounds.\n\tprivate void drawFinderPattern(int x, int y) {\n\t\tfor (int dy = -4; dy <= 4; dy++) {\n\t\t\tfor (int dx = -4; dx <= 4; dx++) {\n\t\t\t\tint dist = Math.max(Math.abs(dx), Math.abs(dy));  // Chebyshev/infinity norm\n\t\t\t\tint xx = x + dx, yy = y + dy;\n\t\t\t\tif (0 <= xx && xx < size && 0 <= yy && yy < size)\n\t\t\t\t\tsetFunctionModule(xx, yy, dist != 2 && dist != 4);\n\t\t\t}\n\t\t}\n\t}\n\t\n\t\n\t// Draws a 5*5 alignment pattern, with the center module\n\t// at (x, y). All modules must be in bounds.\n\tprivate void drawAlignmentPattern(int x, int y) {\n\t\tfor (int dy = -2; dy <= 2; dy++) {\n\t\t\tfor (int dx = -2; dx <= 2; dx++)\n\t\t\t\tsetFunctionModule(x + dx, y + dy, Math.max(Math.abs(dx), Math.abs(dy)) != 1);\n\t\t}\n\t}\n\t\n\t\n\t// Sets the color of a module and marks it as a function module.\n\t// Only used by the constructor. Coordinates must be in bounds.\n\tprivate void setFunctionModule(int x, int y, boolean isDark) {\n\t\tmodules[y][x] = isDark;\n\t\tisFunction[y][x] = true;\n\t}\n\t\n\t\n\t/*---- Private helper methods for constructor: Codewords and masking ----*/\n\t\n\t// Returns a new byte string representing the given data with the appropriate error correction\n\t// codewords appended to it, based on this object\'s version and error correction level.\n\tprivate byte[] addEccAndInterleave(byte[] data) {\n\t\tObjects.requireNonNull(data);\n\t\tif (data.length != getNumDataCodewords(version, errorCorrectionLevel))\n\t\t\tthrow new IllegalArgumentException();\n\t\t\n\t\t// Calculate parameter numbers\n\t\tint numBlocks = NUM_ERROR_CORRECTION_BLOCKS[errorCorrectionLevel.ordinal()][version];\n\t\tint blockEccLen = ECC_CODEWORDS_PER_BLOCK  [errorCorrectionLevel.ordinal()][version];\n\t\tint rawCodewords = getNumRawDataModules(version) / 8;\n\t\tint numShortBlocks = numBlocks - rawCodewords % numBlocks;\n\t\tint shortBlockLen = rawCodewords / numBlocks;\n\t\t\n\t\t// Split data into blocks and append ECC to each block\n\t\tbyte[][] blocks = new byte[numBlocks][];\n\t\tbyte[] rsDiv = reedSolomonComputeDivisor(blockEccLen);\n\t\tfor (int i = 0, k = 0; i < numBlocks; i++) {\n\t\t\tbyte[] dat = Arrays.copyOfRange(data, k, k + shortBlockLen - blockEccLen + (i < numShortBlocks ? 0 : 1));\n\t\t\tk += dat.length;\n\t\t\tbyte[] block = Arrays.copyOf(dat, shortBlockLen + 1);\n\t\t\tbyte[] ecc = reedSolomonComputeRemainder(dat, rsDiv);\n\t\t\tSystem.arraycopy(ecc, 0, block, block.length - blockEccLen, ecc.length);\n\t\t\tblocks[i] = block;\n\t\t}\n\t\t\n\t\t// Interleave (not concatenate) the bytes from every block into a single sequence\n\t\tbyte[] result = new byte[rawCodewords];\n\t\tfor (int i = 0, k = 0; i < blocks[0].length; i++) {\n\t\t\tfor (int j = 0; j < blocks.length; j++) {\n\t\t\t\t// Skip the padding byte in short blocks\n\t\t\t\tif (i != shortBlockLen - blockEccLen || j >= numShortBlocks) {\n\t\t\t\t\tresult[k] = blocks[j][i];\n\t\t\t\t\tk++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\t\n\t\n\t// Draws the given sequence of 8-bit codewords (data and error correction) onto the entire\n\t// data area of this QR Code. Function modules need to be marked off before this is called.\n\tprivate void drawCodewords(byte[] data) {\n\t\tObjects.requireNonNull(data);\n\t\tif (data.length != getNumRawDataModules(version) / 8)\n\t\t\tthrow new IllegalArgumentException();\n\t\t\n\t\tint i = 0;  // Bit index into the data\n\t\t// Do the funny zigzag scan\n\t\tfor (int right = size - 1; right >= 1; right -= 2) {  // Index of right column in each column pair\n\t\t\tif (right == 6)\n\t\t\t\tright = 5;\n\t\t\tfor (int vert = 0; vert < size; vert++) {  // Vertical counter\n\t\t\t\tfor (int j = 0; j < 2; j++) {\n\t\t\t\t\tint x = right - j;  // Actual x coordinate\n\t\t\t\t\tboolean upward = ((right + 1) & 2) == 0;\n\t\t\t\t\tint y = upward ? size - 1 - vert : vert;  // Actual y coordinate\n\t\t\t\t\tif (!isFunction[y][x] && i < data.length * 8) {\n\t\t\t\t\t\tmodules[y][x] = getBit(data[i >>> 3], 7 - (i & 7));\n\t\t\t\t\t\ti++;\n\t\t\t\t\t}\n\t\t\t\t\t// If this QR Code has any remainder bits (0 to 7), they were assigned as\n\t\t\t\t\t// 0/false/light by the constructor and are left unchanged by this method\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tassert i == data.length * 8;\n\t}\n\t\n\t\n\t// XORs the codeword modules in this QR Code with the given mask pattern.\n\t// The function modules must be marked and the codeword bits must be drawn\n\t// before masking. Due to the arithmetic of XOR, calling applyMask() with\n\t// the same mask value a second time will undo the mask. A final well-formed\n\t// QR Code needs exactly one (not zero, two, etc.) mask applied.\n\tprivate void applyMask(int msk) {\n\t\tif (msk < 0 || msk > 7)\n\t\t\tthrow new IllegalArgumentException("Mask value out of range");\n\t\tfor (int y = 0; y < size; y++) {\n\t\t\tfor (int x = 0; x < size; x++) {\n\t\t\t\tboolean invert;\n\t\t\t\tswitch (msk) {\n\t\t\t\t\tcase 0:  invert = (x + y) % 2 == 0;                    break;\n\t\t\t\t\tcase 1:  invert = y % 2 == 0;                          break;\n\t\t\t\t\tcase 2:  invert = x % 3 == 0;                          break;\n\t\t\t\t\tcase 3:  invert = (x + y) % 3 == 0;                    break;\n\t\t\t\t\tcase 4:  invert = (x / 3 + y / 2) % 2 == 0;            break;\n\t\t\t\t\tcase 5:  invert = x * y % 2 + x * y % 3 == 0;          break;\n\t\t\t\t\tcase 6:  invert = (x * y % 2 + x * y % 3) % 2 == 0;    break;\n\t\t\t\t\tcase 7:  invert = ((x + y) % 2 + x * y % 3) % 2 == 0;  break;\n\t\t\t\t\tdefault:  throw new AssertionError();\n\t\t\t\t}\n\t\t\t\tmodules[y][x] ^= invert & !isFunction[y][x];\n\t\t\t}\n\t\t}\n\t}\n\t\n\t\n\t// Calculates and returns the penalty score based on state of this QR Code\'s current modules.\n\t// This is used by the automatic mask choice algorithm to find the mask pattern that yields the lowest score.\n\tprivate int getPenaltyScore() {\n\t\tint result = 0;\n\t\t\n\t\t// Adjacent modules in row having same color, and finder-like patterns\n\t\tfor (int y = 0; y < size; y++) {\n\t\t\tboolean runColor = false;\n\t\t\tint runX = 0;\n\t\t\tint[] runHistory = new int[7];\n\t\t\tfor (int x = 0; x < size; x++) {\n\t\t\t\tif (modules[y][x] == runColor) {\n\t\t\t\t\trunX++;\n\t\t\t\t\tif (runX == 5)\n\t\t\t\t\t\tresult += PENALTY_N1;\n\t\t\t\t\telse if (runX > 5)\n\t\t\t\t\t\tresult++;\n\t\t\t\t} else {\n\t\t\t\t\tfinderPenaltyAddHistory(runX, runHistory);\n\t\t\t\t\tif (!runColor)\n\t\t\t\t\t\tresult += finderPenaltyCountPatterns(runHistory) * PENALTY_N3;\n\t\t\t\t\trunColor = modules[y][x];\n\t\t\t\t\trunX = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tresult += finderPenaltyTerminateAndCount(runColor, runX, runHistory) * PENALTY_N3;\n\t\t}\n\t\t// Adjacent modules in column having same color, and finder-like patterns\n\t\tfor (int x = 0; x < size; x++) {\n\t\t\tboolean runColor = false;\n\t\t\tint runY = 0;\n\t\t\tint[] runHistory = new int[7];\n\t\t\tfor (int y = 0; y < size; y++) {\n\t\t\t\tif (modules[y][x] == runColor) {\n\t\t\t\t\trunY++;\n\t\t\t\t\tif (runY == 5)\n\t\t\t\t\t\tresult += PENALTY_N1;\n\t\t\t\t\telse if (runY > 5)\n\t\t\t\t\t\tresult++;\n\t\t\t\t} else {\n\t\t\t\t\tfinderPenaltyAddHistory(runY, runHistory);\n\t\t\t\t\tif (!runColor)\n\t\t\t\t\t\tresult += finderPenaltyCountPatterns(runHistory) * PENALTY_N3;\n\t\t\t\t\trunColor = modules[y][x];\n\t\t\t\t\trunY = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tresult += finderPenaltyTerminateAndCount(runColor, runY, runHistory) * PENALTY_N3;\n\t\t}\n\t\t\n\t\t// 2*2 blocks of modules having same color\n\t\tfor (int y = 0; y < size - 1; y++) {\n\t\t\tfor (int x = 0; x < size - 1; x++) {\n\t\t\t\tboolean color = modules[y][x];\n\t\t\t\tif (  color == modules[y][x + 1] &&\n\t\t\t\t      color == modules[y + 1][x] &&\n\t\t\t\t      color == modules[y + 1][x + 1])\n\t\t\t\t\tresult += PENALTY_N2;\n\t\t\t}\n\t\t}\n\t\t\n\t\t// Balance of dark and light modules\n\t\tint dark = 0;\n\t\tfor (boolean[] row : modules) {\n\t\t\tfor (boolean color : row) {\n\t\t\t\tif (color)\n\t\t\t\t\tdark++;\n\t\t\t}\n\t\t}\n\t\tint total = size * size;  // Note that size is odd, so dark/total != 1/2\n\t\t// Compute the smallest integer k >= 0 such that (45-5k)% <= dark/total <= (55+5k)%\n\t\tint k = (Math.abs(dark * 20 - total * 10) + total - 1) / total - 1;\n\t\tassert 0 <= k && k <= 9;\n\t\tresult += k * PENALTY_N4;\n\t\tassert 0 <= result && result <= 2568888;  // Non-tight upper bound based on default values of PENALTY_N1, ..., N4\n\t\treturn result;\n\t}\n\t\n\t\n\t\n\t/*---- Private helper functions ----*/\n\t\n\t// Returns an ascending list of positions of alignment patterns for this version number.\n\t// Each position is in the range [0,177), and are used on both the x and y axes.\n\t// This could be implemented as lookup table of 40 variable-length lists of unsigned bytes.\n\tprivate int[] getAlignmentPatternPositions() {\n\t\tif (version == 1)\n\t\t\treturn new int[]{};\n\t\telse {\n\t\t\tint numAlign = version / 7 + 2;\n\t\t\tint step;\n\t\t\tif (version == 32)  // Special snowflake\n\t\t\t\tstep = 26;\n\t\t\telse  // step = ceil[(size - 13) / (numAlign * 2 - 2)] * 2\n\t\t\t\tstep = (version * 4 + numAlign * 2 + 1) / (numAlign * 2 - 2) * 2;\n\t\t\tint[] result = new int[numAlign];\n\t\t\tresult[0] = 6;\n\t\t\tfor (int i = result.length - 1, pos = size - 7; i >= 1; i--, pos -= step)\n\t\t\t\tresult[i] = pos;\n\t\t\treturn result;\n\t\t}\n\t}\n\t\n\t\n\t// Returns the number of data bits that can be stored in a QR Code of the given version number, after\n\t// all function modules are excluded. This includes remainder bits, so it might not be a multiple of 8.\n\t// The result is in the range [208, 29648]. This could be implemented as a 40-entry lookup table.\n\tprivate static int getNumRawDataModules(int ver) {\n\t\tif (ver < MIN_VERSION || ver > MAX_VERSION)\n\t\t\tthrow new IllegalArgumentException("Version number out of range");\n\t\t\n\t\tint size = ver * 4 + 17;\n\t\tint result = size * size;   // Number of modules in the whole QR Code square\n\t\tresult -= 8 * 8 * 3;        // Subtract the three finders with separators\n\t\tresult -= 15 * 2 + 1;       // Subtract the format information and dark module\n\t\tresult -= (size - 16) * 2;  // Subtract the timing patterns (excluding finders)\n\t\t// The five lines above are equivalent to: int result = (16 * ver + 128) * ver + 64;\n\t\tif (ver >= 2) {\n\t\t\tint numAlign = ver / 7 + 2;\n\t\t\tresult -= (numAlign - 1) * (numAlign - 1) * 25;  // Subtract alignment patterns not overlapping with timing patterns\n\t\t\tresult -= (numAlign - 2) * 2 * 20;  // Subtract alignment patterns that overlap with timing patterns\n\t\t\t// The two lines above are equivalent to: result -= (25 * numAlign - 10) * numAlign - 55;\n\t\t\tif (ver >= 7)\n\t\t\t\tresult -= 6 * 3 * 2;  // Subtract version information\n\t\t}\n\t\tassert 208 <= result && result <= 29648;\n\t\treturn result;\n\t}\n\t\n\t\n\t// Returns a Reed-Solomon ECC generator polynomial for the given degree. This could be\n\t// implemented as a lookup table over all possible parameter values, instead of as an algorithm.\n\tprivate static byte[] reedSolomonComputeDivisor(int degree) {\n\t\tif (degree < 1 || degree > 255)\n\t\t\tthrow new IllegalArgumentException("Degree out of range");\n\t\t// Polynomial coefficients are stored from highest to lowest power, excluding the leading term which is always 1.\n\t\t// For example the polynomial x^3 + 255x^2 + 8x + 93 is stored as the uint8 array {255, 8, 93}.\n\t\tbyte[] result = new byte[degree];\n\t\tresult[degree - 1] = 1;  // Start off with the monomial x^0\n\t\t\n\t\t// Compute the product polynomial (x - r^0) * (x - r^1) * (x - r^2) * ... * (x - r^{degree-1}),\n\t\t// and drop the highest monomial term which is always 1x^degree.\n\t\t// Note that r = 0x02, which is a generator element of this field GF(2^8/0x11D).\n\t\tint root = 1;\n\t\tfor (int i = 0; i < degree; i++) {\n\t\t\t// Multiply the current product by (x - r^i)\n\t\t\tfor (int j = 0; j < result.length; j++) {\n\t\t\t\tresult[j] = (byte)reedSolomonMultiply(result[j] & 0xFF, root);\n\t\t\t\tif (j + 1 < result.length)\n\t\t\t\t\tresult[j] ^= result[j + 1];\n\t\t\t}\n\t\t\troot = reedSolomonMultiply(root, 0x02);\n\t\t}\n\t\treturn result;\n\t}\n\t\n\t\n\t// Returns the Reed-Solomon error correction codeword for the given data and divisor polynomials.\n\tprivate static byte[] reedSolomonComputeRemainder(byte[] data, byte[] divisor) {\n\t\tObjects.requireNonNull(data);\n\t\tObjects.requireNonNull(divisor);\n\t\tbyte[] result = new byte[divisor.length];\n\t\tfor (byte b : data) {  // Polynomial division\n\t\t\tint factor = (b ^ result[0]) & 0xFF;\n\t\t\tSystem.arraycopy(result, 1, result, 0, result.length - 1);\n\t\t\tresult[result.length - 1] = 0;\n\t\t\tfor (int i = 0; i < result.length; i++)\n\t\t\t\tresult[i] ^= reedSolomonMultiply(divisor[i] & 0xFF, factor);\n\t\t}\n\t\treturn result;\n\t}\n\t\n\t\n\t// Returns the product of the two given field elements modulo GF(2^8/0x11D). The arguments and result\n\t// are unsigned 8-bit integers. This could be implemented as a lookup table of 256*256 entries of uint8.\n\tprivate static int reedSolomonMultiply(int x, int y) {\n\t\tassert x >> 8 == 0 && y >> 8 == 0;\n\t\t// Russian peasant multiplication\n\t\tint z = 0;\n\t\tfor (int i = 7; i >= 0; i--) {\n\t\t\tz = (z << 1) ^ ((z >>> 7) * 0x11D);\n\t\t\tz ^= ((y >>> i) & 1) * x;\n\t\t}\n\t\tassert z >>> 8 == 0;\n\t\treturn z;\n\t}\n\t\n\t\n\t// Returns the number of 8-bit data (i.e. not error correction) codewords contained in any\n\t// QR Code of the given version number and error correction level, with remainder bits discarded.\n\t// This stateless pure function could be implemented as a (40*4)-cell lookup table.\n\tstatic int getNumDataCodewords(int ver, Ecc ecl) {\n\t\treturn getNumRawDataModules(ver) / 8\n\t\t\t- ECC_CODEWORDS_PER_BLOCK    [ecl.ordinal()][ver]\n\t\t\t* NUM_ERROR_CORRECTION_BLOCKS[ecl.ordinal()][ver];\n\t}\n\t\n\t\n\t// Can only be called immediately after a light run is added, and\n\t// returns either 0, 1, or 2. A helper function for getPenaltyScore().\n\tprivate int finderPenaltyCountPatterns(int[] runHistory) {\n\t\tint n = runHistory[1];\n\t\tassert n <= size * 3;\n\t\tboolean core = n > 0 && runHistory[2] == n && runHistory[3] == n * 3 && runHistory[4] == n && runHistory[5] == n;\n\t\treturn (core && runHistory[0] >= n * 4 && runHistory[6] >= n ? 1 : 0)\n\t\t     + (core && runHistory[6] >= n * 4 && runHistory[0] >= n ? 1 : 0);\n\t}\n\t\n\t\n\t// Must be called at the end of a line (row or column) of modules. A helper function for getPenaltyScore().\n\tprivate int finderPenaltyTerminateAndCount(boolean currentRunColor, int currentRunLength, int[] runHistory) {\n\t\tif (currentRunColor) {  // Terminate dark run\n\t\t\tfinderPenaltyAddHistory(currentRunLength, runHistory);\n\t\t\tcurrentRunLength = 0;\n\t\t}\n\t\tcurrentRunLength += size;  // Add light border to final run\n\t\tfinderPenaltyAddHistory(currentRunLength, runHistory);\n\t\treturn finderPenaltyCountPatterns(runHistory);\n\t}\n\t\n\t\n\t// Pushes the given value to the front and drops the last value. A helper function for getPenaltyScore().\n\tprivate void finderPenaltyAddHistory(int currentRunLength, int[] runHistory) {\n\t\tif (runHistory[0] == 0)\n\t\t\tcurrentRunLength += size;  // Add light border to initial run\n\t\tSystem.arraycopy(runHistory, 0, runHistory, 1, runHistory.length - 1);\n\t\trunHistory[0] = currentRunLength;\n\t}\n\t\n\t\n\t// Returns true iff the i\'th bit of x is set to 1.\n\tstatic boolean getBit(int x, int i) {\n\t\treturn ((x >>> i) & 1) != 0;\n\t}\n\t\n\t\n\t/*---- Constants and tables ----*/\n\t\n\t/** The minimum version number  (1) supported in the QR Code Model 2 standard. */\n\tpublic static final int MIN_VERSION =  1;\n\t\n\t/** The maximum version number (40) supported in the QR Code Model 2 standard. */\n\tpublic static final int MAX_VERSION = 40;\n\t\n\t\n\t// For use in getPenaltyScore(), when evaluating which mask is best.\n\tprivate static final int PENALTY_N1 =  3;\n\tprivate static final int PENALTY_N2 =  3;\n\tprivate static final int PENALTY_N3 = 40;\n\tprivate static final int PENALTY_N4 = 10;\n\t\n\t\n\tprivate static final byte[][] ECC_CODEWORDS_PER_BLOCK = {\n\t\t// Version: (note that index 0 is for padding, and is set to an illegal value)\n\t\t//0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40    Error correction level\n\t\t{-1,  7, 10, 15, 20, 26, 18, 20, 24, 30, 18, 20, 24, 26, 30, 22, 24, 28, 30, 28, 28, 28, 28, 30, 30, 26, 28, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30},  // Low\n\t\t{-1, 10, 16, 26, 18, 24, 16, 18, 22, 22, 26, 30, 22, 22, 24, 24, 28, 28, 26, 26, 26, 26, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28},  // Medium\n\t\t{-1, 13, 22, 18, 26, 18, 24, 18, 22, 20, 24, 28, 26, 24, 20, 30, 24, 28, 28, 26, 30, 28, 30, 30, 30, 30, 28, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30},  // Quartile\n\t\t{-1, 17, 28, 22, 16, 22, 28, 26, 26, 24, 28, 24, 28, 22, 24, 24, 30, 28, 28, 26, 28, 30, 24, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30},  // High\n\t};\n\t\n\tprivate static final byte[][] NUM_ERROR_CORRECTION_BLOCKS = {\n\t\t// Version: (note that index 0 is for padding, and is set to an illegal value)\n\t\t//0, 1, 2, 3, 4, 5, 6, 7, 8, 9,10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40    Error correction level\n\t\t{-1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 4,  4,  4,  4,  4,  6,  6,  6,  6,  7,  8,  8,  9,  9, 10, 12, 12, 12, 13, 14, 15, 16, 17, 18, 19, 19, 20, 21, 22, 24, 25},  // Low\n\t\t{-1, 1, 1, 1, 2, 2, 4, 4, 4, 5, 5,  5,  8,  9,  9, 10, 10, 11, 13, 14, 16, 17, 17, 18, 20, 21, 23, 25, 26, 28, 29, 31, 33, 35, 37, 38, 40, 43, 45, 47, 49},  // Medium\n\t\t{-1, 1, 1, 2, 2, 4, 4, 6, 6, 8, 8,  8, 10, 12, 16, 12, 17, 16, 18, 21, 20, 23, 23, 25, 27, 29, 34, 34, 35, 38, 40, 43, 45, 48, 51, 53, 56, 59, 62, 65, 68},  // Quartile\n\t\t{-1, 1, 1, 2, 4, 4, 4, 5, 6, 8, 8, 11, 11, 16, 16, 18, 16, 19, 21, 25, 25, 25, 34, 30, 32, 35, 37, 40, 42, 45, 48, 51, 54, 57, 60, 63, 66, 70, 74, 77, 81},  // High\n\t};\n\t\n\t\n\t\n\t/*---- Public helper enumeration ----*/\n\t\n\t/**\n\t * The error correction level in a QR Code symbol.\n\t */\n\tpublic enum Ecc {\n\t\t// Must be declared in ascending order of error protection\n\t\t// so that the implicit ordinal() and values() work properly\n\t\t/** The QR Code can tolerate about  7% erroneous codewords. */ LOW(1),\n\t\t/** The QR Code can tolerate about 15% erroneous codewords. */ MEDIUM(0),\n\t\t/** The QR Code can tolerate about 25% erroneous codewords. */ QUARTILE(3),\n\t\t/** The QR Code can tolerate about 30% erroneous codewords. */ HIGH(2);\n\t\t\n\t\t// In the range 0 to 3 (unsigned 2-bit integer).\n\t\tfinal int formatBits;\n\t\t\n\t\t// Constructor.\n\t\tprivate Ecc(int fb) {\n\t\t\tformatBits = fb;\n\t\t}\n\t}\n\t\n}\n'