b'{-# OPTIONS_GHC -fno-warn-orphans #-}\n{-# LANGUAGE CPP #-}\n{-# LANGUAGE UndecidableInstances #-}\n{-# LANGUAGE FunctionalDependencies #-}\n{-# LANGUAGE ConstraintKinds #-}\n{-# LANGUAGE LambdaCase #-}\n{-# LANGUAGE PolyKinds #-}\n\nmodule Database.Beam.Backend.SQL.Row\n  ( FromBackendRowF(..), FromBackendRowM(..)\n  , parseOneField, peekField\n\n  , ColumnParseError(..), BeamRowReadError(..)\n\n  , FromBackendRow(..)\n  ) where\n\nimport           Database.Beam.Backend.SQL.Types\nimport           Database.Beam.Backend.Types\n\nimport           Control.Applicative\nimport           Control.Exception (Exception)\nimport           Control.Monad.Free.Church\nimport           Control.Monad.Identity\nimport           Data.Kind (Type)\nimport           Data.Tagged\nimport           Data.Typeable\nimport           Data.Vector.Sized (Vector)\nimport qualified Data.Vector.Sized as Vector\n\nimport qualified Control.Monad.Fail as Fail\n\nimport           GHC.Generics\nimport           GHC.TypeLits\n\n-- | The exact error encountered\ndata ColumnParseError\n  = ColumnUnexpectedNull\n  | ColumnNotEnoughColumns !Int\n  | ColumnTypeMismatch\n  { ctmHaskellType :: String\n  , ctmSQLType     :: String\n  , ctmMessage     :: String\n  }\n  | ColumnErrorInternal String\n  deriving (Show, Eq, Ord)\n\n-- | An error that may occur when parsing a row. Contains an optional\n-- annotation of which column was being parsed (if available).\ndata BeamRowReadError\n  = BeamRowReadError\n  { brreColumn :: !(Maybe Int)\n  , brreError  :: !ColumnParseError\n  } deriving (Show, Eq, Ord)\ninstance Exception BeamRowReadError\n\ndata FromBackendRowF be f where\n  ParseOneField :: (BackendFromField be a, Typeable a) => (a -> f) -> FromBackendRowF be f\n  Alt :: FromBackendRowM be a -> FromBackendRowM be a -> (a -> f) -> FromBackendRowF be f\n  FailParseWith :: BeamRowReadError -> FromBackendRowF be f\ninstance Functor (FromBackendRowF be) where\n  fmap f = \\case\n    ParseOneField p -> ParseOneField $ f . p\n    Alt a b p -> Alt a b $ f . p\n    FailParseWith e -> FailParseWith e\nnewtype FromBackendRowM be a = FromBackendRowM (F (FromBackendRowF be) a)\n  deriving (Functor, Applicative)\n\ninstance Monad (FromBackendRowM be) where\n  return = pure\n  FromBackendRowM a >>= b =\n    FromBackendRowM $\n    a >>= (\\x -> let FromBackendRowM b\' = b x in b\')\n\ninstance Fail.MonadFail (FromBackendRowM be) where\n  fail = FromBackendRowM . liftF . FailParseWith .\n         BeamRowReadError Nothing . ColumnErrorInternal\n\ninstance Alternative (FromBackendRowM be) where\n  empty   = Fail.fail "empty"\n  a <|> b =\n    FromBackendRowM (liftF (Alt a b id))\n\nparseOneField :: (BackendFromField be a, Typeable a) => FromBackendRowM be a\nparseOneField = do\n  x <- FromBackendRowM (liftF (ParseOneField id))\n  pure x\n\npeekField :: (Typeable a, BackendFromField be a) => FromBackendRowM be (Maybe a)\npeekField = fmap Just (FromBackendRowM (liftF (ParseOneField id))) <|> pure Nothing\n\n-- BeamBackend instead of BeamSqlBackend to prevent circular super class\nclass BeamBackend be => FromBackendRow be a where\n  -- | Parses a beam row. This should not fail, except in the case of\n  -- an internal bug in beam deserialization code. If it does fail,\n  -- this should throw a \'BeamRowParseError\'.\n  fromBackendRow :: FromBackendRowM be a\n  default fromBackendRow :: (Typeable a, BackendFromField be a) => FromBackendRowM be a\n  fromBackendRow = parseOneField\n\n  valuesNeeded :: Proxy be -> Proxy a -> Int\n  valuesNeeded _ _ = 1\n\nclass GFromBackendRow be (exposed :: Type -> Type) rep where\n  gFromBackendRow :: Proxy exposed -> FromBackendRowM be (rep ())\n  gValuesNeeded :: Proxy be -> Proxy exposed -> Proxy rep -> Int\ninstance GFromBackendRow be e p => GFromBackendRow be (M1 t f e) (M1 t f p) where\n  gFromBackendRow _ = M1 <$> gFromBackendRow (Proxy @e)\n  gValuesNeeded be _ _ = gValuesNeeded be (Proxy @e) (Proxy @p)\ninstance GFromBackendRow be e U1 where\n  gFromBackendRow _ = pure U1\n  gValuesNeeded _ _ _ = 0\ninstance (GFromBackendRow be aExp a, GFromBackendRow be bExp b) => GFromBackendRow be (aExp :*: bExp) (a :*: b) where\n  gFromBackendRow _ = (:*:) <$> gFromBackendRow (Proxy @aExp) <*> gFromBackendRow (Proxy @bExp)\n  gValuesNeeded be _ _ = gValuesNeeded be (Proxy @aExp) (Proxy @a) + gValuesNeeded be (Proxy @bExp) (Proxy @b)\ninstance FromBackendRow be x => GFromBackendRow be (K1 R (Exposed x)) (K1 R x) where\n  gFromBackendRow _ = K1 <$> fromBackendRow\n  gValuesNeeded be _ _ = valuesNeeded be (Proxy @x)\ninstance FromBackendRow be (t Identity) => GFromBackendRow be (K1 R (t Exposed)) (K1 R (t Identity)) where\n    gFromBackendRow _ = K1 <$> fromBackendRow\n    gValuesNeeded be _ _ = valuesNeeded be (Proxy @(t Identity))\ninstance FromBackendRow be (t (Nullable Identity)) => GFromBackendRow be (K1 R (t (Nullable Exposed))) (K1 R (t (Nullable Identity))) where\n    gFromBackendRow _ = K1 <$> fromBackendRow\n    gValuesNeeded be _ _ = valuesNeeded be (Proxy @(t (Nullable Identity)))\ninstance BeamBackend be => FromBackendRow be () where\n  fromBackendRow = to <$> gFromBackendRow (Proxy @(Rep ()))\n  valuesNeeded _ _ = 0\n\ninstance ( BeamBackend be, KnownNat n, FromBackendRow be a ) => FromBackendRow be (Vector n a) where\n  fromBackendRow = Vector.replicateM fromBackendRow\n  valuesNeeded _ _ = fromIntegral (natVal (Proxy @n))\n\ninstance ( BeamBackend be, FromBackendRow be a, FromBackendRow be b ) =>\n  FromBackendRow be (a, b) where\n  fromBackendRow = to <$> gFromBackendRow (Proxy @(Rep (Exposed a, Exposed b)))\n  valuesNeeded be _ = valuesNeeded be (Proxy @a) + valuesNeeded be (Proxy @b)\ninstance ( BeamBackend be, FromBackendRow be a, FromBackendRow be b, FromBackendRow be c ) =>\n  FromBackendRow be (a, b, c) where\n  fromBackendRow = to <$> gFromBackendRow (Proxy @(Rep (Exposed a, Exposed b, Exposed c)))\n  valuesNeeded be _ = valuesNeeded be (Proxy @a) + valuesNeeded be (Proxy @b) + valuesNeeded be (Proxy @c)\ninstance ( BeamBackend be\n         , FromBackendRow be a, FromBackendRow be b, FromBackendRow be c\n         , FromBackendRow be d ) =>\n  FromBackendRow be (a, b, c, d) where\n  fromBackendRow = to <$> gFromBackendRow (Proxy @(Rep (Exposed a, Exposed b, Exposed c, Exposed d)))\n  valuesNeeded be _ = valuesNeeded be (Proxy @a) + valuesNeeded be (Proxy @b) + valuesNeeded be (Proxy @c) + valuesNeeded be (Proxy @d)\ninstance ( BeamBackend be\n         , FromBackendRow be a, FromBackendRow be b, FromBackendRow be c\n         , FromBackendRow be d, FromBackendRow be e ) =>\n  FromBackendRow be (a, b, c, d, e) where\n  fromBackendRow = to <$> gFromBackendRow (Proxy @(Rep (Exposed a, Exposed b, Exposed c, Exposed d, Exposed e)))\n  valuesNeeded be _ = valuesNeeded be (Proxy @a) + valuesNeeded be (Proxy @b) + valuesNeeded be (Proxy @c) + valuesNeeded be (Proxy @d) +\n                      valuesNeeded be (Proxy @e)\ninstance ( BeamBackend be\n         , FromBackendRow be a, FromBackendRow be b, FromBackendRow be c\n         , FromBackendRow be d, FromBackendRow be e, FromBackendRow be f ) =>\n  FromBackendRow be (a, b, c, d, e, f) where\n  fromBackendRow = to <$> gFromBackendRow (Proxy @(Rep (Exposed a, Exposed b, Exposed c, Exposed d, Exposed e, Exposed f)))\n  valuesNeeded be _ = valuesNeeded be (Proxy @a) + valuesNeeded be (Proxy @b) + valuesNeeded be (Proxy @c) + valuesNeeded be (Proxy @d) +\n                      valuesNeeded be (Proxy @e) + valuesNeeded be (Proxy @f)\ninstance ( BeamBackend be\n         , FromBackendRow be a, FromBackendRow be b, FromBackendRow be c\n         , FromBackendRow be d, FromBackendRow be e, FromBackendRow be f\n         , FromBackendRow be g ) =>\n  FromBackendRow be (a, b, c, d, e, f, g) where\n  fromBackendRow = to <$> gFromBackendRow (Proxy @(Rep (Exposed a, Exposed b, Exposed c, Exposed d, Exposed e, Exposed f, Exposed g)))\n  valuesNeeded be _ = valuesNeeded be (Proxy @a) + valuesNeeded be (Proxy @b) + valuesNeeded be (Proxy @c) + valuesNeeded be (Proxy @d) +\n                      valuesNeeded be (Proxy @e) + valuesNeeded be (Proxy @f) + valuesNeeded be (Proxy @g)\ninstance ( BeamBackend be\n         , FromBackendRow be a, FromBackendRow be b, FromBackendRow be c\n         , FromBackendRow be d, FromBackendRow be e, FromBackendRow be f\n         , FromBackendRow be g, FromBackendRow be h ) =>\n  FromBackendRow be (a, b, c, d, e, f, g, h) where\n  fromBackendRow = to <$> gFromBackendRow (Proxy @(Rep (Exposed a, Exposed b, Exposed c, Exposed d, Exposed e, Exposed f, Exposed g, Exposed h)))\n  valuesNeeded be _ = valuesNeeded be (Proxy @a) + valuesNeeded be (Proxy @b) + valuesNeeded be (Proxy @c) + valuesNeeded be (Proxy @d) +\n                      valuesNeeded be (Proxy @e) + valuesNeeded be (Proxy @f) + valuesNeeded be (Proxy @g) + valuesNeeded be (Proxy @h)\n\ninstance ( BeamBackend be, Generic (tbl Identity), Generic (tbl Exposed)\n         , GFromBackendRow be (Rep (tbl Exposed)) (Rep (tbl Identity))) =>\n\n    FromBackendRow be (tbl Identity) where\n  fromBackendRow = to <$> gFromBackendRow (Proxy @(Rep (tbl Exposed)))\n  valuesNeeded be _ = gValuesNeeded be (Proxy @(Rep (tbl Exposed))) (Proxy @(Rep (tbl Identity)))\ninstance ( BeamBackend be, Generic (tbl (Nullable Identity)), Generic (tbl (Nullable Exposed))\n         , GFromBackendRow be (Rep (tbl (Nullable Exposed))) (Rep (tbl (Nullable Identity)))) =>\n\n    FromBackendRow be (tbl (Nullable Identity)) where\n  fromBackendRow = to <$> gFromBackendRow (Proxy @(Rep (tbl (Nullable Exposed))))\n  valuesNeeded be _ = gValuesNeeded be (Proxy @(Rep (tbl (Nullable Exposed)))) (Proxy @(Rep (tbl (Nullable Identity))))\n\ninstance (FromBackendRow be x, FromBackendRow be SqlNull) => FromBackendRow be (Maybe x) where\n  fromBackendRow =\n    (Just <$> fromBackendRow) <|>\n    (Nothing <$\n      replicateM_ (valuesNeeded (Proxy @be) (Proxy @(Maybe x)))\n                  (do SqlNull <- fromBackendRow\n                      pure ()))\n  valuesNeeded be _ = valuesNeeded be (Proxy @x)\n\n#if !MIN_VERSION_base(4, 16, 0)\nderiving instance Generic (a, b, c, d, e, f, g, h)\n#endif\n\ninstance (BeamBackend be, FromBackendRow be t) => FromBackendRow be (Tagged tag t) where\n  fromBackendRow = Tagged <$> fromBackendRow\n\ninstance FromBackendRow be x => FromBackendRow be (SqlSerial x) where\n  fromBackendRow = SqlSerial <$> fromBackendRow\n'