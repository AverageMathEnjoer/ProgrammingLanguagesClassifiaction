b'/* \n * Fast QR Code generator library\n * \n * Copyright (c) Project Nayuki. (MIT License)\n * https://www.nayuki.io/page/fast-qr-code-generator-library\n * \n * Permission is hereby granted, free of charge, to any person obtaining a copy of\n * this software and associated documentation files (the "Software"), to deal in\n * the Software without restriction, including without limitation the rights to\n * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of\n * the Software, and to permit persons to whom the Software is furnished to do so,\n * subject to the following conditions:\n * - The above copyright notice and this permission notice shall be included in\n *   all copies or substantial portions of the Software.\n * - The Software is provided "as is", without warranty of any kind, express or\n *   implied, including but not limited to the warranties of merchantability,\n *   fitness for a particular purpose and noninfringement. In no event shall the\n *   authors or copyright holders be liable for any claim, damages or other\n *   liability, whether in an action of contract, tort or otherwise, arising from,\n *   out of or in connection with the Software or the use or other dealings in the\n *   Software.\n */\n\npackage io.nayuki.fastqrcodegen;\n\n\n// Stores the parts of a QR Code that depend only on the version number,\n// and does not depend on the data or error correction level or mask.\nfinal class QrTemplate {\n\t\n\t// Use this memoizer to get instances of this class.\n\tpublic static final Memoizer<Integer,QrTemplate> MEMOIZER\n\t\t= new Memoizer<>(QrTemplate::new);\n\t\n\t\n\tprivate final int version;  // In the range [1, 40].\n\tprivate final int size;  // Derived from version.\n\t\n\tfinal int[] template;  // Length and values depend on version.\n\tfinal int[][] masks;  // masks.length == 8, and masks[i].length == template.length.\n\tfinal int[] dataOutputBitIndexes;  // Length and values depend on version.\n\t\n\t// Indicates function modules that are not subjected to masking. Discarded when constructor finishes.\n\t// Otherwise when the constructor is running, isFunction.length == template.length.\n\tprivate int[] isFunction;\n\t\n\t\n\t// Creates a QR Code template for the given version number.\n\tprivate QrTemplate(int ver) {\n\t\tif (ver < QrCode.MIN_VERSION || ver > QrCode.MAX_VERSION)\n\t\t\tthrow new IllegalArgumentException("Version out of range");\n\t\tversion = ver;\n\t\tsize = version * 4 + 17;\n\t\ttemplate = new int[(size * size + 31) / 32];\n\t\tisFunction = new int[template.length];\n\t\t\n\t\tdrawFunctionPatterns();  // Reads and writes fields\n\t\tmasks = generateMasks();  // Reads fields, returns array\n\t\tdataOutputBitIndexes = generateZigzagScan();  // Reads fields, returns array\n\t\tisFunction = null;\n\t}\n\t\n\t\n\t// Reads this object\'s version field, and draws and marks all function modules.\n\tprivate void drawFunctionPatterns() {\n\t\t// Draw horizontal and vertical timing patterns\n\t\tfor (int i = 0; i < size; i++) {\n\t\t\tdarkenFunctionModule(6, i, ~i & 1);\n\t\t\tdarkenFunctionModule(i, 6, ~i & 1);\n\t\t}\n\t\t\n\t\t// Draw 3 finder patterns (all corners except bottom right; overwrites some timing modules)\n\t\tdrawFinderPattern(3, 3);\n\t\tdrawFinderPattern(size - 4, 3);\n\t\tdrawFinderPattern(3, size - 4);\n\t\t\n\t\t// Draw numerous alignment patterns\n\t\tint[] alignPatPos = getAlignmentPatternPositions();\n\t\tint numAlign = alignPatPos.length;\n\t\tfor (int i = 0; i < numAlign; i++) {\n\t\t\tfor (int j = 0; j < numAlign; j++) {\n\t\t\t\t// Don\'t draw on the three finder corners\n\t\t\t\tif (!(i == 0 && j == 0 || i == 0 && j == numAlign - 1 || i == numAlign - 1 && j == 0))\n\t\t\t\t\tdrawAlignmentPattern(alignPatPos[i], alignPatPos[j]);\n\t\t\t}\n\t\t}\n\t\t\n\t\t// Draw configuration data\n\t\tdrawDummyFormatBits();\n\t\tdrawVersion();\n\t}\n\t\n\t\n\t// Draws two blank copies of the format bits.\n\tprivate void drawDummyFormatBits() {\n\t\t// Draw first copy\n\t\tfor (int i = 0; i <= 5; i++)\n\t\t\tdarkenFunctionModule(8, i, 0);\n\t\tdarkenFunctionModule(8, 7, 0);\n\t\tdarkenFunctionModule(8, 8, 0);\n\t\tdarkenFunctionModule(7, 8, 0);\n\t\tfor (int i = 9; i < 15; i++)\n\t\t\tdarkenFunctionModule(14 - i, 8, 0);\n\t\t\n\t\t// Draw second copy\n\t\tfor (int i = 0; i < 8; i++)\n\t\t\tdarkenFunctionModule(size - 1 - i, 8, 0);\n\t\tfor (int i = 8; i < 15; i++)\n\t\t\tdarkenFunctionModule(8, size - 15 + i, 0);\n\t\tdarkenFunctionModule(8, size - 8, 1);  // Always dark\n\t}\n\t\n\t\n\t// Draws two copies of the version bits (with its own error correction code),\n\t// based on this object\'s version field, iff 7 <= version <= 40.\n\tprivate void drawVersion() {\n\t\tif (version < 7)\n\t\t\treturn;\n\t\t\n\t\t// Calculate error correction code and pack bits\n\t\tint rem = version;  // version is uint6, in the range [7, 40]\n\t\tfor (int i = 0; i < 12; i++)\n\t\t\trem = (rem << 1) ^ ((rem >>> 11) * 0x1F25);\n\t\tint bits = version << 12 | rem;  // uint18\n\t\tassert bits >>> 18 == 0;\n\t\t\n\t\t// Draw two copies\n\t\tfor (int i = 0; i < 18; i++) {\n\t\t\tint bit = QrCode.getBit(bits, i);\n\t\t\tint a = size - 11 + i % 3;\n\t\t\tint b = i / 3;\n\t\t\tdarkenFunctionModule(a, b, bit);\n\t\t\tdarkenFunctionModule(b, a, bit);\n\t\t}\n\t}\n\t\n\t\n\t// Draws a 9*9 finder pattern including the border separator,\n\t// with the center module at (x, y). Modules can be out of bounds.\n\tprivate void drawFinderPattern(int x, int y) {\n\t\tfor (int dy = -4; dy <= 4; dy++) {\n\t\t\tfor (int dx = -4; dx <= 4; dx++) {\n\t\t\t\tint dist = Math.max(Math.abs(dx), Math.abs(dy));  // Chebyshev/infinity norm\n\t\t\t\tint xx = x + dx, yy = y + dy;\n\t\t\t\tif (0 <= xx && xx < size && 0 <= yy && yy < size)\n\t\t\t\t\tdarkenFunctionModule(xx, yy, (dist != 2 && dist != 4) ? 1 : 0);\n\t\t\t}\n\t\t}\n\t}\n\t\n\t\n\t// Draws a 5*5 alignment pattern, with the center module\n\t// at (x, y). All modules must be in bounds.\n\tprivate void drawAlignmentPattern(int x, int y) {\n\t\tfor (int dy = -2; dy <= 2; dy++) {\n\t\t\tfor (int dx = -2; dx <= 2; dx++)\n\t\t\t\tdarkenFunctionModule(x + dx, y + dy, Math.abs(Math.max(Math.abs(dx), Math.abs(dy)) - 1));\n\t\t}\n\t}\n\t\n\t\n\t// Computes and returns a new array of masks, based on this object\'s various fields.\n\tprivate int[][] generateMasks() {\n\t\tint[][] result = new int[8][template.length];\n\t\tfor (int mask = 0; mask < result.length; mask++) {\n\t\t\tint[] maskModules = result[mask];\n\t\t\tfor (int y = 0, i = 0; y < size; y++) {\n\t\t\t\tfor (int x = 0; x < size; x++, i++) {\n\t\t\t\t\tboolean invert;\n\t\t\t\t\tswitch (mask) {\n\t\t\t\t\t\tcase 0:  invert = (x + y) % 2 == 0;                    break;\n\t\t\t\t\t\tcase 1:  invert = y % 2 == 0;                          break;\n\t\t\t\t\t\tcase 2:  invert = x % 3 == 0;                          break;\n\t\t\t\t\t\tcase 3:  invert = (x + y) % 3 == 0;                    break;\n\t\t\t\t\t\tcase 4:  invert = (x / 3 + y / 2) % 2 == 0;            break;\n\t\t\t\t\t\tcase 5:  invert = x * y % 2 + x * y % 3 == 0;          break;\n\t\t\t\t\t\tcase 6:  invert = (x * y % 2 + x * y % 3) % 2 == 0;    break;\n\t\t\t\t\t\tcase 7:  invert = ((x + y) % 2 + x * y % 3) % 2 == 0;  break;\n\t\t\t\t\t\tdefault:  throw new AssertionError();\n\t\t\t\t\t}\n\t\t\t\t\tint bit = (invert ? 1 : 0) & ~getModule(isFunction, x, y);\n\t\t\t\t\tmaskModules[i >>> 5] |= bit << i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\t\n\t\n\t// Computes and returns an array of bit indexes, based on this object\'s various fields.\n\tprivate int[] generateZigzagScan() {\n\t\tint[] result = new int[getNumRawDataModules(version) / 8 * 8];\n\t\tint i = 0;  // Bit index into the data\n\t\tfor (int right = size - 1; right >= 1; right -= 2) {  // Index of right column in each column pair\n\t\t\tif (right == 6)\n\t\t\t\tright = 5;\n\t\t\tfor (int vert = 0; vert < size; vert++) {  // Vertical counter\n\t\t\t\tfor (int j = 0; j < 2; j++) {\n\t\t\t\t\tint x = right - j;  // Actual x coordinate\n\t\t\t\t\tboolean upward = ((right + 1) & 2) == 0;\n\t\t\t\t\tint y = upward ? size - 1 - vert : vert;  // Actual y coordinate\n\t\t\t\t\tif (getModule(isFunction, x, y) == 0 && i < result.length) {\n\t\t\t\t\t\tresult[i] = y * size + x;\n\t\t\t\t\t\ti++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tassert i == result.length;\n\t\treturn result;\n\t}\n\t\n\t\n\t// Returns the value of the bit at the given coordinates in the given grid.\n\tprivate int getModule(int[] grid, int x, int y) {\n\t\tassert 0 <= x && x < size;\n\t\tassert 0 <= y && y < size;\n\t\tint i = y * size + x;\n\t\treturn QrCode.getBit(grid[i >>> 5], i);\n\t}\n\t\n\t\n\t// Marks the module at the given coordinates as a function module.\n\t// Also either sets that module dark or keeps its color unchanged.\n\tprivate void darkenFunctionModule(int x, int y, int enable) {\n\t\tassert 0 <= x && x < size;\n\t\tassert 0 <= y && y < size;\n\t\tassert enable == 0 || enable == 1;\n\t\tint i = y * size + x;\n\t\ttemplate[i >>> 5] |= enable << i;\n\t\tisFunction[i >>> 5] |= 1 << i;\n\t}\n\t\n\t\n\t// Returns an ascending list of positions of alignment patterns for this version number.\n\t// Each position is in the range [0,177), and are used on both the x and y axes.\n\t// This could be implemented as lookup table of 40 variable-length lists of unsigned bytes.\n\tprivate int[] getAlignmentPatternPositions() {\n\t\tif (version == 1)\n\t\t\treturn new int[]{};\n\t\telse {\n\t\t\tint numAlign = version / 7 + 2;\n\t\t\tint step = (version == 32) ? 26 :\n\t\t\t\t(version * 4 + numAlign * 2 + 1) / (numAlign * 2 - 2) * 2;\n\t\t\tint[] result = new int[numAlign];\n\t\t\tresult[0] = 6;\n\t\t\tfor (int i = result.length - 1, pos = size - 7; i >= 1; i--, pos -= step)\n\t\t\t\tresult[i] = pos;\n\t\t\treturn result;\n\t\t}\n\t}\n\t\n\t\n\t// Returns the number of data bits that can be stored in a QR Code of the given version number, after\n\t// all function modules are excluded. This includes remainder bits, so it might not be a multiple of 8.\n\t// The result is in the range [208, 29648]. This could be implemented as a 40-entry lookup table.\n\tstatic int getNumRawDataModules(int ver) {\n\t\tif (ver < QrCode.MIN_VERSION || ver > QrCode.MAX_VERSION)\n\t\t\tthrow new IllegalArgumentException("Version number out of range");\n\t\tint result = (16 * ver + 128) * ver + 64;\n\t\tif (ver >= 2) {\n\t\t\tint numAlign = ver / 7 + 2;\n\t\t\tresult -= (25 * numAlign - 10) * numAlign - 55;\n\t\t\tif (ver >= 7)\n\t\t\t\tresult -= 36;\n\t\t}\n\t\treturn result;\n\t}\n\t\n}\n'