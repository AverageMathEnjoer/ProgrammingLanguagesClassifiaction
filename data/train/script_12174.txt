b'#include <bits/stdc++.h>\nusing namespace std;\n#define gc getchar_unlocked\n#define fo(i,n) for(i=0;i<n;i++)\n#define Fo(i,k,n) for(i=k;i<n;i++)\n#define ll long long\n#define si(x)\tscanf("%d",&x)\n#define sl(x)\tscanf("%I64d",&x)\n#define ss(s)\tscanf("%s",s)\n#define pb push_back\n#define mp make_pair\n#define F first\n#define S second\n#define clr(x) memset(x, 0, sizeof(x))\n#define tr(it, a) for(auto it = a.begin(); it != a.end(); it++)\n#define PI 3.1415926535897932384626\ntypedef pair<int, int>\tpii;\ntypedef pair<ll, ll>\tpll;\ntypedef vector<int>\t\tvi;\ntypedef vector<ll>\t\tvl;\ntypedef vector<pii>\t\tvpii;\ntypedef vector<pll>\t\tvpll;\ntypedef vector<vi>\t\tvvi;\ntypedef vector<vl>\t\tvvl;\nconst int mod = 1000000007;\nconst int N = 2e5;\nvi g[N];\nconst int LG = 20;\n#define red 1\n#define blue 0\nint a[N], col[N], lvl[N], P[N][LG], sz[N];\nll in[N], out[N];\nvoid dfs(int u, int par){\n    sz[u] = 1;\n    lvl[u] = 1+lvl[par];\n    P[u][0] = par;\n    in[u] = col[u]==blue?0:mod;\n\tfor(int v:g[u]){\n\t\tif (v == par) continue;\n\t\tdfs(v, u);\n\t\tin[u] = min(in[u], 1+in[v]);\n\t\tsz[u] += sz[v];\n\t}\n}\nvoid dfs1(int u, int par){\n\tif (par == 0) out[u] = mod;\n\telse out[u] = 1 + out[par];\n    ll F, S; F = S = mod;\n\tfor(int v:g[u]){\n\t\tif (v == par) continue;\n\t\tif (F >= in[v]){\n            S = F;\n            F = in[v];\n\t\t}\n\t\telse if ( in[v] < S) S = in[v];\n\t}\n\tfor(int v: g[u]){\n        if (v == par) continue;\n        ll use = F;\n        if (F == in[v]) use = S;\n\t\tdfs1(v, u);\n        out[v] = min(out[v], 2+use);\n\t}\n}\n//lvl[u] > lvl[v]\nint lca(int u, int v){\n    int i, lg;\n    for(lg = 0; (1<<lg) <= lvl[u]; lg++);\n    lg--;\n    for(i=lg; i>=0; i--){\n        if (lvl[u] - (1<<i) >= lvl[v])\n            u = P[u][i];\n    }\n    if (u == v) return u;\n    for(i=lg; i>=0; i--){\n        if (P[u][i] != -1 and P[u][i] != P[v][i])\n            u = P[u][i], v = P[v][i];\n    }\n    return P[u][0];\n}\nint get(int u, int dis){\n    dis = lvl[u] - dis;\n    int i, lg = 0;\n    for(; (1<<lg) <= lvl[u]; lg++); lg--;\n    for(i=lg; i>=0; i--){\n        if (lvl[u] - (1<<i) >= dis)\n            u = P[u][i];\n    }\n    return u;\n}\nint dis(int u, int v){\n    if (lvl[u] < lvl[v]) swap(u, v);\n    int w = lca(u, v);\n    return lvl[u] + lvl[v] - 2*lvl[w];\n}\nint main()\n{\n\tios_base::sync_with_stdio(false);\n\tcin.tie(NULL);\n\tint i,n,q, m, j;\n    int u, v;\n    cin>>n>>m;\n\tfo(i, n-1){\n        cin>>u>>v;\n        g[u].pb(v);\n        g[v].pb(u);\n\t}\n\tfo(i, LG) fo(j, n+1) P[j][i] = -1;\n\tlvl[0] = -1;\n\tdfs(1, 0);\n\tdfs1(1, 0);\n\tfor(i=1; i<LG; i++){\n        Fo(j, 1, n+1)\n            if (P[j][i-1] != -1)\n                P[j][i] = P[P[j][i-1]][i-1];\n\t}\n    fo(i,n) col[i+1] = blue;\n    col[1] = red;\n    int rtm = sqrt(m);\n    vi redd;\n    fo(i, m){\n        if (i%rtm == 0){\n            lvl[0] = -1;\n            dfs(1, 0);\n            dfs1(1, 0);\n            redd.clear();\n        }\n        int ty;\n        cin>>ty>>u;\n        if (ty == 1) col[u]= red, redd.pb(u);\n        else {\n            int ans = mod;\n            ans = min(in[u], out[u]);\n            for(int x: redd) ans = min(ans, dis(u, x));\n            cout<<ans<<endl;\n        }\n    }\n\n\n\n\n\treturn 0;\n}\n\n'