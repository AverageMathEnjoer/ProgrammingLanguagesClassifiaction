b"{-# LANGUAGE ConstraintKinds #-}\n{-# LANGUAGE UndecidableInstances #-}\n\n-- | Support for defaulting checked tables\nmodule Database.Beam.Migrate.Generics.Tables\n  ( -- * Field data type defaulting\n    HasDefaultSqlDataType(..)\n\n  -- * Internal\n  , GMigratableTableSettings(..)\n\n  , HasNullableConstraint, NullableStatus\n  ) where\n\nimport Database.Beam\nimport Database.Beam.Backend.Internal.Compat\nimport Database.Beam.Backend.SQL\n\nimport Database.Beam.Migrate.Types.Predicates\nimport Database.Beam.Migrate.SQL.Types\nimport Database.Beam.Migrate.SQL.SQL92\nimport Database.Beam.Migrate.Checks\n\nimport Control.Applicative (Const(..))\n\nimport Data.Proxy\nimport Data.Text (Text)\nimport Data.Scientific (Scientific)\nimport Data.Time.Calendar (Day)\nimport Data.Time (TimeOfDay)\nimport Data.Int\nimport Data.Word\n\nimport GHC.Generics\nimport GHC.TypeLits\n\nclass BeamMigrateSqlBackend be => GMigratableTableSettings be (i :: * -> *) fieldCheck where\n  gDefaultTblSettingsChecks :: Proxy be -> Proxy i -> Bool -> fieldCheck ()\n\ninstance (BeamMigrateSqlBackend be, GMigratableTableSettings be xId fieldCheckId) =>\n  GMigratableTableSettings be (M1 t s xId) (M1 t s fieldCheckId) where\n  gDefaultTblSettingsChecks be Proxy embedded =\n    M1 (gDefaultTblSettingsChecks be (Proxy @xId) embedded)\n\ninstance ( BeamMigrateSqlBackend be\n         , GMigratableTableSettings be aId aFieldCheck\n         , GMigratableTableSettings be bId bFieldCheck ) =>\n  GMigratableTableSettings be (aId :*: bId) (aFieldCheck :*: bFieldCheck) where\n  gDefaultTblSettingsChecks be Proxy embedded =\n    gDefaultTblSettingsChecks be (Proxy @aId) embedded :*:\n    gDefaultTblSettingsChecks be (Proxy @bId) embedded\n\ninstance ( HasDefaultSqlDataType be haskTy\n         , HasNullableConstraint (NullableStatus haskTy) be\n\n         , HasDataTypeCreatedCheck (BeamMigrateSqlBackendDataTypeSyntax be)\n         , Typeable be, BeamMigrateSqlBackend be ) =>\n  GMigratableTableSettings be (Rec0 haskTy) (Rec0 (Const [FieldCheck] haskTy)) where\n\n  gDefaultTblSettingsChecks _ _ embedded =\n    K1 (Const (nullableConstraint (Proxy @(NullableStatus haskTy)) (Proxy @be) ++\n               defaultSqlDataTypeConstraints (Proxy @haskTy) (Proxy @be) embedded ++\n               [ FieldCheck (\\tblNm nm -> p (TableHasColumn tblNm nm (defaultSqlDataType (Proxy @haskTy) (Proxy @be) embedded)\n                                              :: TableHasColumn be )) ]))\n\ninstance ( Generic (embeddedTbl (Const [FieldCheck]))\n         , BeamMigrateSqlBackend be\n         , GMigratableTableSettings be (Rep (embeddedTbl Identity)) (Rep (embeddedTbl (Const [FieldCheck]))) ) =>\n  GMigratableTableSettings be (Rec0 (embeddedTbl Identity)) (Rec0 (embeddedTbl (Const [FieldCheck]))) where\n\n  gDefaultTblSettingsChecks be _ _ =\n    K1 (to (gDefaultTblSettingsChecks be (Proxy :: Proxy (Rep (embeddedTbl Identity))) True))\n\ninstance ( Generic (embeddedTbl (Nullable (Const [FieldCheck])))\n         , BeamMigrateSqlBackend be\n         , GMigratableTableSettings be (Rep (embeddedTbl (Nullable Identity))) (Rep (embeddedTbl (Nullable (Const [FieldCheck])))) ) =>\n  GMigratableTableSettings be (Rec0 (embeddedTbl (Nullable Identity))) (Rec0 (embeddedTbl (Nullable (Const [FieldCheck])))) where\n\n  gDefaultTblSettingsChecks be _ _ =\n    K1 (to (gDefaultTblSettingsChecks be (Proxy :: Proxy (Rep (embeddedTbl (Nullable Identity)))) True))\n\n-- * Nullability check\n\ntype family NullableStatus (x :: *) :: Bool where\n  NullableStatus (Maybe x) = 'True\n  NullableStatus x = 'False\n\nclass BeamMigrateSqlBackend be => HasNullableConstraint (x :: Bool) be where\n  nullableConstraint :: Proxy x -> Proxy be -> [ FieldCheck ]\n\ninstance ( Typeable be, BeamMigrateSqlBackend be ) =>\n  HasNullableConstraint 'False be where\n  nullableConstraint _ _ =\n    let c = constraintDefinitionSyntax Nothing notNullConstraintSyntax Nothing\n    in [ FieldCheck $ \\tblNm colNm -> p (TableColumnHasConstraint tblNm colNm c :: TableColumnHasConstraint be) ]\ninstance BeamMigrateSqlBackend be =>\n  HasNullableConstraint 'True be where\n  nullableConstraint _ _ = []\n\n-- * Default data types\n\n-- | Used to define a default SQL data type for a haskell type in a particular\n-- backend, as well as any constraints that are needed\n--\n-- Beam defines instances for several standard SQL types, which are\n-- polymorphic over any standard data type syntax. Backends or\n-- extensions which provide custom types should instantiate instances\n-- of this class for any types they provide for which they would like\n-- checked schema migrations\nclass BeamMigrateSqlBackend be => HasDefaultSqlDataType be ty where\n\n  -- | Provide a data type for the given type\n  defaultSqlDataType :: Proxy ty       -- ^ Concrete representation of the type\n                     -> Proxy be       -- ^ Concrete representation of the backend\n                     -> Bool           -- ^ 'True' if this field is in an embedded\n                                       --   key or table, 'False' otherwise\n                     -> BeamSqlBackendDataTypeSyntax be\n\n  -- | Provide arbitrary constraints on a field of the requested type. See\n  -- 'FieldCheck' for more information on the formatting of constraints.\n  defaultSqlDataTypeConstraints\n    :: Proxy ty -- ^ Concrete representation of the type\n    -> Proxy be -- ^ Concrete representation of the backend\n    -> Bool     -- ^ 'True' if this field is embedded in a\n                --   foreign key, 'False' otherwise. For\n                --   example, @SERIAL@ types in postgres get a\n                --   @DEFAULT@ constraint, but @SERIAL@ types in\n                --   a foreign key do not.\n    -> [ FieldCheck ]\n  defaultSqlDataTypeConstraints _ _ _ = []\n\ninstance (BeamMigrateSqlBackend be, HasDefaultSqlDataType be ty) =>\n  HasDefaultSqlDataType be (Maybe ty) where\n  defaultSqlDataType _ = defaultSqlDataType (Proxy @ty)\n  defaultSqlDataTypeConstraints _ = defaultSqlDataTypeConstraints (Proxy @ty)\n\n-- TODO Not sure if individual databases will want to customize these types\n\ninstance BeamMigrateSqlBackend be => HasDefaultSqlDataType be Int32 where\n  defaultSqlDataType _ _ _ = intType\ninstance BeamMigrateSqlBackend be => HasDefaultSqlDataType be Int16 where\n  defaultSqlDataType _ _ _ = smallIntType\ninstance ( BeamMigrateSqlBackend be, BeamSqlT071Backend be ) => HasDefaultSqlDataType be Int64 where\n    defaultSqlDataType _ _ _ = bigIntType\n\ninstance BeamMigrateSqlBackend be => HasDefaultSqlDataType be Word16 where\n  defaultSqlDataType _ _ _ = numericType (Just (5, Nothing))\ninstance BeamMigrateSqlBackend be => HasDefaultSqlDataType be Word32 where\n  defaultSqlDataType _ _ _ = numericType (Just (10, Nothing))\ninstance BeamMigrateSqlBackend be => HasDefaultSqlDataType be Word64 where\n  defaultSqlDataType _ _ _ = numericType (Just (20, Nothing))\n\ninstance BeamMigrateSqlBackend be => HasDefaultSqlDataType be Text where\n  defaultSqlDataType _ _ _ = varCharType Nothing Nothing\ninstance BeamMigrateSqlBackend be => HasDefaultSqlDataType be SqlBitString where\n  defaultSqlDataType _ _ _ = varBitType Nothing\n\ninstance BeamMigrateSqlBackend be => HasDefaultSqlDataType be Double where\n  defaultSqlDataType _ _ _ = doubleType\n\ninstance BeamMigrateSqlBackend be => HasDefaultSqlDataType be Scientific where\n  defaultSqlDataType _ _ _ = numericType (Just (20, Just 10))\n\ninstance BeamMigrateSqlBackend be => HasDefaultSqlDataType be Day where\n  defaultSqlDataType _ _ _ = dateType\n\ninstance BeamMigrateSqlBackend be => HasDefaultSqlDataType be TimeOfDay where\n  defaultSqlDataType _ _ _ = timeType Nothing False\n\ninstance BeamMigrateSql99Backend be => HasDefaultSqlDataType be Bool where\n  defaultSqlDataType _ _ _ = booleanType\n\ninstance (TypeError (PreferExplicitSize Int Int32), BeamMigrateSqlBackend be) => HasDefaultSqlDataType be Int where\n  defaultSqlDataType _ = defaultSqlDataType (Proxy @Int32)\n\ninstance (TypeError (PreferExplicitSize Word Word32), BeamMigrateSqlBackend be) => HasDefaultSqlDataType be Word where\n  defaultSqlDataType _ _ _ = numericType (Just (10, Nothing))\n"