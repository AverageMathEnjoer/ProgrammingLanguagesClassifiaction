b'{-# LANGUAGE CPP #-}\n{-# LANGUAGE UndecidableInstances #-}\n{-# LANGUAGE ConstraintKinds #-}\n{-# LANGUAGE TypeApplications #-}\n{-# LANGUAGE KindSignatures #-}\n{-# LANGUAGE FunctionalDependencies #-}\n{-# LANGUAGE DataKinds #-}\n{-# LANGUAGE InstanceSigs #-}\n\n-- | Defines a generic schema type that can be used to define schemas for Beam tables\nmodule Database.Beam.Schema.Tables\n    (\n    -- * Database Types\n      Database\n    , zipTables\n\n    , DatabaseSettings\n    , IsDatabaseEntity(..)\n    , DatabaseEntityDescriptor(..)\n    , DatabaseEntity(..), TableEntity, ViewEntity, DomainTypeEntity\n    , dbEntityDescriptor\n    , DatabaseModification, EntityModification(..)\n    , FieldModification(..)\n    , dbModification, tableModification, withDbModification\n    , withTableModification, modifyTable, modifyEntityName\n    , setEntityName, modifyTableFields, fieldNamed\n    , modifyEntitySchema, setEntitySchema\n    , defaultDbSettings\n\n    , RenamableWithRule(..), RenamableField(..)\n    , FieldRenamer(..)\n\n    , Lenses, LensFor(..)\n\n    -- * Columnar and Column Tags\n    , Columnar, C, Columnar\'(..)\n    , ComposeColumnar(..)\n    , Nullable, TableField(..)\n    , Exposed\n    , fieldName, fieldPath\n\n    , TableSettings, HaskellTable\n    , TableSkeleton, Ignored(..)\n    , GFieldsFulfillConstraint(..), FieldsFulfillConstraint\n    , FieldsFulfillConstraintNullable\n    , WithConstraint(..)\n    , HasConstraint(..)\n    , TagReducesTo(..), ReplaceBaseTag\n    , withConstrainedFields, withConstraints\n    , withNullableConstrainedFields, withNullableConstraints\n\n    -- * Tables\n    , Table(..), Beamable(..)\n    , Retaggable(..), (:*:)(..) -- Reexported for use with \'alongsideTable\'\n    , defTblFieldSettings\n    , tableValuesNeeded\n    , pk\n    , allBeamValues, changeBeamRep\n    , alongsideTable\n    , defaultFieldName )\n    where\n\nimport           Database.Beam.Backend.Types\n\nimport           Control.Applicative (liftA2)\nimport           Control.Arrow (first)\nimport           Control.Monad.Identity\nimport           Control.Monad.Writer hiding ((<>))\n\nimport           Data.Char (isUpper, toLower)\nimport           Data.Foldable (fold)\nimport qualified Data.List.NonEmpty as NE\nimport           Data.Proxy\nimport           Data.String (IsString(..))\nimport           Data.Text (Text)\nimport qualified Data.Text as T\nimport           Data.Typeable\n\nimport qualified GHC.Generics as Generic\nimport           GHC.Generics hiding (R, C)\nimport           GHC.TypeLits\nimport           GHC.Types\n\nimport           Lens.Micro hiding (to)\nimport qualified Lens.Micro as Lens\n\n-- | Allows introspection into database types.\n--\n--   All database types must be of kind \'(Type -> Type) -> Type\'. If\n--   the type parameter is named \'f\', each field must be of the type\n--   of \'f\' applied to some type for which an \'IsDatabaseEntity\'\n--   instance exists.\n--\n--   The \'be\' type parameter is necessary so that the compiler can\n--   ensure that backend-specific entities only work on the proper\n--   backend.\n--\n--   Entities are documented under [the corresponding\n--   section](Database.Beam.Schema#entities) and in the\n--   [manual](https://haskell-beam.github.io/beam/user-guide/databases/)\nclass Database be db where\n\n    -- | Default derived function. Do not implement this yourself.\n    --\n    --   The idea is that, for any two databases over particular entity tags \'f\'\n    --   and \'g\', if we can take any entity in \'f\' and \'g\' to the corresponding\n    --   entity in \'h\' (in the possibly effectful applicative functor \'m\'), then we can\n    --   transform the two databases over \'f\' and \'g\' to a database in \'h\',\n    --   within \'m\'.\n    --\n    --   If that doesn\'t make sense, don\'t worry. This is mostly beam internal\n    zipTables :: Applicative m\n              => Proxy be\n              -> (forall tbl. (IsDatabaseEntity be tbl, DatabaseEntityRegularRequirements be tbl) =>\n                  f tbl -> g tbl -> m (h tbl))\n              -> db f -> db g -> m (db h)\n    default zipTables :: ( Generic (db f), Generic (db g), Generic (db h)\n                         , Applicative m\n                         , GZipDatabase be f g h\n                                        (Rep (db f)) (Rep (db g)) (Rep (db h)) ) =>\n                         Proxy be ->\n                         (forall tbl. (IsDatabaseEntity be tbl, DatabaseEntityRegularRequirements be tbl) => f tbl -> g tbl -> m (h tbl)) ->\n                         db f -> db g -> m (db h)\n    -- We need the pattern type signature on \'combine\' to get around a type checking bug in GHC 8.0.1. In future releases,\n    -- we will switch to the standard forall.\n    zipTables be combine (f :: db f) (g :: db g) =\n      refl $ \\h ->\n        to <$> gZipDatabase (Proxy @f, Proxy @g, h, be) combine (from f) (from g)\n      where\n        -- For GHC 8.0.1 renamer bug\n        refl :: (Proxy h -> m (db h)) -> m (db h)\n        refl fn = fn Proxy\n\n-- | Automatically provide names for tables, and descriptions for tables (using\n--   \'defTblFieldSettings\'). Your database must implement \'Generic\', and must be\n--   auto-derivable. For more information on name generation, see the\n--   [manual](https://haskell-beam.github.io/beam/user-guide/models)\ndefaultDbSettings :: ( Generic (DatabaseSettings be db)\n                     , GAutoDbSettings (Rep (DatabaseSettings be db) ()) ) =>\n                     DatabaseSettings be db\ndefaultDbSettings = to\' autoDbSettings\'\n\n-- | A helper data type that lets you modify a database schema. Converts all\n-- entities in the database into functions from that entity to itself.\ntype DatabaseModification f be db = db (EntityModification f be)\n-- | A newtype wrapper around \'f e -> f e\' (i.e., an endomorphism between entity\n--   types in \'f\'). You usually want to use \'modifyTable\' or another function to\n--   contstruct these for you.\nnewtype EntityModification f be e = EntityModification (Endo (f e))\n  deriving (Monoid, Semigroup)\n-- | A newtype wrapper around \'Columnar f a -> Columnar f a\' (i.e., an\n--   endomorphism between \'Columnar\'s over \'f\'). You usually want to use\n--   \'fieldNamed\' or the \'IsString\' instance to rename the field, when \'f ~\n--   TableField\'\nnewtype FieldModification f a\n  = FieldModification (Columnar f a -> Columnar f a)\n\n-- | Return a \'DatabaseModification\' that does nothing. This is useful if you\n--   only want to rename one table. You can do\n--\n-- > dbModification { tbl1 = modifyTable (\\oldNm -> "NewTableName") tableModification }\ndbModification :: forall f be db. Database be db => DatabaseModification f be db\ndbModification = runIdentity $\n                 zipTables (Proxy @be) (\\_ _ -> pure mempty) (undefined :: DatabaseModification f be db) (undefined :: DatabaseModification f be db)\n\n-- | Return a table modification (for use with \'modifyTable\') that does nothing.\n--   Useful if you only want to change the table name, or if you only want to\n--   modify a few fields.\n--\n--   For example,\n--\n-- > tableModification { field1 = "Column1" }\n--\n--   is a table modification (where \'f ~ TableField tbl\') that changes the\n--   column name of \'field1\' to "Column1".\ntableModification :: forall f tbl. Beamable tbl => tbl (FieldModification f)\ntableModification = runIdentity $\n                    zipBeamFieldsM (\\(Columnar\' _ :: Columnar\' Ignored x) (Columnar\' _ :: Columnar\' Ignored x) ->\n                                      pure (Columnar\' (FieldModification id :: FieldModification f x))) (undefined :: TableSkeleton tbl) (undefined :: TableSkeleton tbl)\n\n-- | Modify a database according to a given modification. Most useful for\n--   \'DatabaseSettings\' to change the name mappings of tables and fields. For\n--   example, you can use this to modify the default names of a table\n--\n-- > db :: DatabaseSettings MyDb\n-- > db = defaultDbSettings `withDbModification`\n-- >      dbModification {\n-- >        -- Change default name "table1" to "Table_1". Change the name of "table1Field1" to "first_name"\n-- >        table1 = modifyTable (\\_ -> "Table_1") (tableModification { table1Field1 = "first_name" }\n-- >      }\nwithDbModification :: forall db be entity\n                    . Database be db\n                   => db (entity be db)\n                   -> DatabaseModification (entity be db) be db\n                   -> db (entity be db)\nwithDbModification db mods =\n  runIdentity $ zipTables (Proxy @be) (\\tbl (EntityModification entityFn) -> pure (appEndo entityFn tbl)) db mods\n\n-- | Modify a table according to the given field modifications. Invoked by\n--   \'modifyTable\' to apply the modification in the database. Not used as often in\n--   user code, but provided for completeness.\nwithTableModification :: Beamable tbl => tbl (FieldModification f) -> tbl f -> tbl f\nwithTableModification mods tbl =\n  runIdentity $ zipBeamFieldsM (\\(Columnar\' field :: Columnar\' f a) (Columnar\' (FieldModification fieldFn :: FieldModification f a)) ->\n                                  pure (Columnar\' (fieldFn field))) tbl mods\n\n\n-- | Provide an \'EntityModification\' for \'TableEntity\'s. Allows you to modify\n--   the name of the table and provide a modification for each field in the\n--   table. See the examples for \'withDbModification\' for more.\nmodifyTable :: (Beamable tbl, Table tbl)\n            => (Text -> Text)\n            -> tbl (FieldModification (TableField tbl))\n            -> EntityModification (DatabaseEntity be db) be (TableEntity tbl)\nmodifyTable modTblNm modFields = modifyEntityName modTblNm <> modifyTableFields modFields\n{-# DEPRECATED modifyTable "Instead of \'modifyTable fTblNm fFields\', use \'modifyEntityName _ <> modifyTableFields _\'" #-}\n\n-- | Construct an \'EntityModification\' to rename any database entity\nmodifyEntityName :: IsDatabaseEntity be entity => (Text -> Text) -> EntityModification (DatabaseEntity be db) be entity\nmodifyEntityName modTblNm = EntityModification (Endo (\\(DatabaseEntity tbl) -> DatabaseEntity (tbl & dbEntityName %~ modTblNm)))\n\n-- | Construct an \'EntityModification\' to set the schema of a database entity\nmodifyEntitySchema :: IsDatabaseEntity be entity => (Maybe Text -> Maybe Text) -> EntityModification (DatabaseEntity be db) be entity\nmodifyEntitySchema modSchema = EntityModification (Endo (\\(DatabaseEntity tbl) -> DatabaseEntity (tbl & dbEntitySchema %~ modSchema)))\n\n-- | Change the entity name without consulting the beam-assigned one\nsetEntityName :: IsDatabaseEntity be entity => Text -> EntityModification (DatabaseEntity be db) be entity\nsetEntityName nm = modifyEntityName (\\_ -> nm)\n\nsetEntitySchema :: IsDatabaseEntity be entity => Maybe Text -> EntityModification (DatabaseEntity be db) be entity\nsetEntitySchema nm = modifyEntitySchema (\\_ -> nm)\n\n-- | Construct an \'EntityModification\' to rename the fields of a \'TableEntity\'\nmodifyTableFields :: tbl (FieldModification (TableField tbl)) -> EntityModification (DatabaseEntity be db) be (TableEntity tbl)\nmodifyTableFields modFields = EntityModification (Endo (\\(DatabaseEntity tbl@(DatabaseTable {})) -> DatabaseEntity tbl { dbTableSettings = withTableModification modFields (dbTableSettings tbl) }))\n\n-- | A field modification to rename the field. Also offered under the \'IsString\'\n--   instance for \'FieldModification (TableField tbl) a\' for convenience.\nfieldNamed :: Text -> FieldModification (TableField tbl) a\nfieldNamed newName = FieldModification (fieldName .~ newName)\n\nnewtype FieldRenamer entity = FieldRenamer { withFieldRenamer :: entity -> entity }\n\nclass RenamableField f where\n  renameField :: Proxy f -> Proxy a -> (NE.NonEmpty Text -> Text) -> Columnar f a -> Columnar f a\ninstance RenamableField (TableField tbl) where\n  renameField _ _ f (TableField path _) = TableField path (f path)\n\nclass RenamableWithRule mod where\n  renamingFields :: (NE.NonEmpty Text -> Text) -> mod\ninstance Database be db => RenamableWithRule (db (EntityModification (DatabaseEntity be db) be)) where\n  renamingFields renamer =\n    runIdentity $\n    zipTables (Proxy @be) (\\_ _ -> pure (renamingFields renamer))\n              (undefined :: DatabaseModification f be db)\n              (undefined :: DatabaseModification f be db)\ninstance IsDatabaseEntity be entity => RenamableWithRule (EntityModification (DatabaseEntity be db) be entity) where\n  renamingFields renamer =\n    EntityModification (Endo (\\(DatabaseEntity tbl) -> DatabaseEntity (withFieldRenamer (renamingFields renamer) tbl)))\ninstance (Beamable tbl, RenamableField f) => RenamableWithRule (tbl (FieldModification f)) where\n  renamingFields renamer =\n    runIdentity $\n    zipBeamFieldsM (\\(Columnar\' _ :: Columnar\' Ignored x) (Columnar\' _ :: Columnar\' Ignored x) ->\n                       pure (Columnar\' (FieldModification (renameField (Proxy @f) (Proxy @x) renamer) :: FieldModification f x) ::\n                               Columnar\' (FieldModification f) x))\n                   (undefined :: TableSkeleton tbl) (undefined :: TableSkeleton tbl)\n\ninstance IsString (FieldModification (TableField tbl) a) where\n  fromString = fieldNamed . fromString\n\n-- * Database entity types\n\n-- | An entity tag for tables. See the documentation for \'Table\' or consult the\n--   [manual](https://haskell-beam.github.io/beam/user-guide/models) for more.\ndata TableEntity (tbl :: (Type -> Type) -> Type)\ndata ViewEntity (view :: (Type -> Type) -> Type)\n--data UniqueConstraint (tbl :: (* -> *) -> *) (c :: (* -> *) -> *)\ndata DomainTypeEntity (ty :: Type)\n--data CharacterSetEntity\n--data CollationEntity\n--data TranslationEntity\n--data AssertionEntity\n\nclass RenamableWithRule (FieldRenamer (DatabaseEntityDescriptor be entityType)) =>\n    IsDatabaseEntity be entityType where\n  data DatabaseEntityDescriptor be entityType :: Type\n  type DatabaseEntityDefaultRequirements be entityType :: Constraint\n  type DatabaseEntityRegularRequirements be entityType :: Constraint\n\n  dbEntityName :: Lens\' (DatabaseEntityDescriptor be entityType) Text\n  dbEntitySchema :: Traversal\' (DatabaseEntityDescriptor be entityType) (Maybe Text)\n\n  dbEntityAuto :: DatabaseEntityDefaultRequirements be entityType =>\n                  Text -> DatabaseEntityDescriptor be entityType\n\ninstance Beamable tbl => RenamableWithRule (FieldRenamer (DatabaseEntityDescriptor be (TableEntity tbl))) where\n  renamingFields renamer =\n    FieldRenamer $ \\tbl ->\n      tbl { dbTableSettings =\n              changeBeamRep (\\(Columnar\' tblField :: Columnar\' (TableField tbl) a) ->\n                               Columnar\' (renameField (Proxy @(TableField tbl))\n                                                      (Proxy @a)\n                                                      renamer tblField)\n                                 :: Columnar\' (TableField tbl) a) $\n              dbTableSettings tbl }\n\ninstance Beamable tbl => IsDatabaseEntity be (TableEntity tbl) where\n  data DatabaseEntityDescriptor be (TableEntity tbl) where\n    DatabaseTable\n      :: Table tbl =>\n       { dbTableSchema      :: Maybe Text\n       , dbTableOrigName    :: Text\n       , dbTableCurrentName :: Text\n       , dbTableSettings    :: TableSettings tbl }\n      -> DatabaseEntityDescriptor be (TableEntity tbl)\n  type DatabaseEntityDefaultRequirements be (TableEntity tbl) =\n    ( GDefaultTableFieldSettings (Rep (TableSettings tbl) ())\n    , Generic (TableSettings tbl), Table tbl, Beamable tbl )\n  type DatabaseEntityRegularRequirements be (TableEntity tbl) =\n    ( Table tbl, Beamable tbl )\n\n  dbEntityName f tbl = fmap (\\t\' -> tbl { dbTableCurrentName = t\' }) (f (dbTableCurrentName tbl))\n  dbEntitySchema f tbl = fmap (\\s\' -> tbl { dbTableSchema = s\'}) (f (dbTableSchema tbl))\n  dbEntityAuto nm =\n    DatabaseTable Nothing nm (unCamelCaseSel nm) defTblFieldSettings\n\ninstance Beamable tbl => RenamableWithRule (FieldRenamer (DatabaseEntityDescriptor be (ViewEntity tbl))) where\n  renamingFields renamer =\n    FieldRenamer $ \\vw ->\n      vw { dbViewSettings =\n             changeBeamRep (\\(Columnar\' tblField :: Columnar\' (TableField tbl) a) ->\n                              Columnar\' (renameField (Proxy @(TableField tbl))\n                                                     (Proxy @a)\n                                                     renamer tblField)\n                                :: Columnar\' (TableField tbl) a) $\n             dbViewSettings vw }\n\ninstance Beamable tbl => IsDatabaseEntity be (ViewEntity tbl) where\n  data DatabaseEntityDescriptor be (ViewEntity tbl) where\n    DatabaseView\n      :: { dbViewSchema :: Maybe Text\n         , dbViewOrigName :: Text\n         , dbViewCurrentName :: Text\n         , dbViewSettings :: TableSettings tbl }\n      -> DatabaseEntityDescriptor be (ViewEntity tbl)\n  type DatabaseEntityDefaultRequirements be (ViewEntity tbl) =\n    ( GDefaultTableFieldSettings (Rep (TableSettings tbl) ())\n    , Generic (TableSettings tbl), Beamable tbl )\n  type DatabaseEntityRegularRequirements be (ViewEntity tbl) =\n    (  Beamable tbl )\n\n  dbEntityName f vw = fmap (\\t\' -> vw { dbViewCurrentName = t\' }) (f (dbViewCurrentName vw))\n  dbEntitySchema f vw = fmap (\\s\' -> vw { dbViewSchema = s\' }) (f (dbViewSchema vw))\n  dbEntityAuto nm =\n    DatabaseView Nothing nm (unCamelCaseSel nm) defTblFieldSettings\n\ninstance RenamableWithRule (FieldRenamer (DatabaseEntityDescriptor be (DomainTypeEntity ty))) where\n  renamingFields _ = FieldRenamer id\n\ninstance IsDatabaseEntity be (DomainTypeEntity ty) where\n  data DatabaseEntityDescriptor be (DomainTypeEntity ty)\n    = DatabaseDomainType !(Maybe Text) !Text\n  type DatabaseEntityDefaultRequirements be (DomainTypeEntity ty) = ()\n  type DatabaseEntityRegularRequirements be (DomainTypeEntity ty) = ()\n\n  dbEntityName f (DatabaseDomainType s t) = DatabaseDomainType s <$> f t\n  dbEntitySchema f (DatabaseDomainType s t) = DatabaseDomainType <$> f s <*> pure t\n  dbEntityAuto = DatabaseDomainType Nothing\n\n-- | Represents a meta-description of a particular entityType. Mostly, a wrapper\n--   around \'DatabaseEntityDescriptor be entityType\', but carries around the\n--   \'IsDatabaseEntity\' dictionary.\ndata DatabaseEntity be (db :: (Type -> Type) -> Type) entityType  where\n    DatabaseEntity ::\n      IsDatabaseEntity be entityType =>\n      DatabaseEntityDescriptor be entityType ->  DatabaseEntity be db entityType\n\ndbEntityDescriptor :: SimpleGetter (DatabaseEntity be db entityType) (DatabaseEntityDescriptor be entityType)\ndbEntityDescriptor = Lens.to (\\(DatabaseEntity e) -> e)\n\n-- | When parameterized by this entity tag, a database type will hold\n--   meta-information on the Haskell mappings of database entities. Under the\n--   hood, each entity type is transformed into its \'DatabaseEntityDescriptor\'\n--   type. For tables this includes the table name as well as the corresponding\n--   \'TableSettings\', which provides names for each column.\ntype DatabaseSettings be db = db (DatabaseEntity be db)\n\nclass GAutoDbSettings x where\n    autoDbSettings\' :: x\ninstance GAutoDbSettings (x p) => GAutoDbSettings (D1 f x p) where\n    autoDbSettings\' = M1 autoDbSettings\'\ninstance GAutoDbSettings (x p) => GAutoDbSettings (C1 f x p) where\n    autoDbSettings\' = M1 autoDbSettings\'\ninstance (GAutoDbSettings (x p), GAutoDbSettings (y p)) => GAutoDbSettings ((x :*: y) p) where\n    autoDbSettings\' = autoDbSettings\' :*: autoDbSettings\'\ninstance ( Selector f, IsDatabaseEntity be x, DatabaseEntityDefaultRequirements be x ) =>\n  GAutoDbSettings (S1 f (K1 Generic.R (DatabaseEntity be db x)) p) where\n  autoDbSettings\' = M1 (K1 (DatabaseEntity (dbEntityAuto name)))\n    where name = T.pack (selName (undefined :: S1 f (K1 Generic.R (DatabaseEntity be db x)) p))\n\nclass GZipDatabase be f g h x y z where\n  gZipDatabase :: Applicative m =>\n                  (Proxy f, Proxy g, Proxy h, Proxy be)\n               -> (forall tbl. (IsDatabaseEntity be tbl, DatabaseEntityRegularRequirements be tbl) => f tbl -> g tbl -> m (h tbl))\n               -> x () -> y () -> m (z ())\ninstance GZipDatabase be f g h x y z =>\n  GZipDatabase be f g h (M1 a b x) (M1 a b y) (M1 a b z) where\n  gZipDatabase p combine ~(M1 f) ~(M1 g) = M1 <$> gZipDatabase p combine f g\ninstance ( GZipDatabase be f g h ax ay az\n         , GZipDatabase be f g h bx by bz ) =>\n  GZipDatabase be f g h (ax :*: bx) (ay :*: by) (az :*: bz) where\n  gZipDatabase p combine ~(ax :*: bx) ~(ay :*: by) =\n    liftA2 (:*:) (gZipDatabase p combine ax ay) (gZipDatabase p combine bx by)\ninstance (IsDatabaseEntity be tbl, DatabaseEntityRegularRequirements be tbl) =>\n  GZipDatabase be f g h (K1 Generic.R (f tbl)) (K1 Generic.R (g tbl)) (K1 Generic.R (h tbl)) where\n\n  gZipDatabase _ combine ~(K1 x) ~(K1 y) =\n    K1 <$> combine x y\n\ndata Lenses (t :: (Type -> Type) -> Type) (f :: Type -> Type) x\ndata LensFor t x where\n    LensFor :: Generic t => Lens\' t x -> LensFor t x\n\n-- | A type family that we use to "tag" columns in our table datatypes.\n--\n--   This is what allows us to use the same table type to hold table data, describe table settings,\n--   derive lenses, and provide expressions.\n--\n--   The basic rules are\n--\n-- > Columnar Identity x = x\n--\n--   Thus, any Beam table applied to \'Identity\' will yield a simplified version of the data type, that contains\n--   just what you\'d expect.\n--\n--   The \'Nullable\' type is used when referencing \'PrimaryKey\'s that we want to include optionally.\n--   For example, if we have a table with a \'PrimaryKey\', like the following\n--\n-- > data BeamTableT f = BeamTableT\n-- >                   { _refToAnotherTable :: PrimaryKey AnotherTableT f\n-- >                   , ... }\n--\n--   we would typically be required to provide values for the \'PrimaryKey\' embedded into \'BeamTableT\'. We can use\n--   \'Nullable\' to lift this constraint.\n--\n-- > data BeamTableT f = BeamTableT\n-- >                   { _refToAnotherTable :: PrimaryKey AnotherTableT (Nullable f)\n-- >                   , ... }\n--\n--   Now we can use \'just_\' and \'nothing_\' to refer to this table optionally. The embedded \'PrimaryKey\' in \'_refToAnotherTable\'\n--   automatically has its fields converted into \'Maybe\' using \'Nullable\'.\n--\n--   The last \'Columnar\' rule is\n--\n-- > Columnar f x = f x\n--\n--   Use this rule if you\'d like to parameterize your table type over any other functor. For example, this is used\n--   in the query modules to write expressions such as \'TableT QExpr\', which returns a table whose fields have been\n--   turned into query expressions.\n--\n--   The other rules are used within Beam to provide lenses and to expose the inner structure of the data type.\ntype family Columnar (f :: Type -> Type) x where\n    Columnar Exposed x = Exposed x\n\n    Columnar Identity x = x\n\n    Columnar (Lenses t f) x = LensFor (t f) (Columnar f x)\n--    Columnar (Lenses t f) x = LensFor (t f) (f x)\n\n    Columnar (Nullable c) x = Columnar c (Maybe x)\n\n    Columnar f x = f x\n\n-- | A short type-alias for \'Columnar\'. May shorten your schema definitions\ntype C f a = Columnar f a\n\n-- | If you declare a function \'Columnar f a -> b\' and try to constrain your\n--   function by a type class for \'f\', GHC will complain, because \'f\' is\n--   ambiguous in \'Columnar f a\'. For example, \'Columnar Identity (Maybe a) ~\n--   Maybe a\' and \'Columnar (Nullable Identity) a ~ Maybe a\', so given a type\n--   \'Columnar f a\', we cannot know the type of \'f\'.\n--\n--   Thus, if you need to know \'f\', you can instead use \'Columnar\'\'. Since its a\n--   newtype, it carries around the \'f\' paramater unambiguously. Internally, it\n--   simply wraps \'Columnar f a\'\nnewtype Columnar\' f a = Columnar\' (Columnar f a)\n\n-- | Like \'Data.Functor.Compose\', but with an intermediate \'Columnar\'\nnewtype ComposeColumnar f g a = ComposeColumnar (f (Columnar g a))\n\n-- | Metadata for a field of type \'ty\' in \'table\'.\n--\n--   Essentially a wrapper over the field name, but with a phantom type\n--   parameter, so that it forms an appropriate column tag.\n--\n--   Usually you use the \'defaultDbSettings\' function to generate an appropriate\n--   naming convention for you, and then modify it with \'withDbModification\' if\n--   necessary. Under this scheme, the field n be renamed using the \'IsString\'\n--   instance for \'TableField\', or the \'fieldNamed\' function.\ndata TableField (table :: (Type -> Type) -> Type) ty\n  = TableField\n  { _fieldPath :: NE.NonEmpty T.Text\n    -- ^ The path that led to this field. Each element is the haskell\n    -- name of the record field in which this table is stored.\n  , _fieldName :: Text  -- ^ The field name\n  } deriving (Show, Eq)\n\n-- | Van Laarhoven lens to retrieve or set the field name from a \'TableField\'.\nfieldName :: Lens\' (TableField table ty) Text\nfieldName f (TableField path name) = TableField path <$> f name\n\nfieldPath :: Traversal\' (TableField table ty) Text\nfieldPath f (TableField orig name) = TableField <$> traverse f orig <*> pure name\n\n-- | Represents a table that contains metadata on its fields. In particular,\n--   each field of type \'Columnar f a\' is transformed into \'TableField table a\'.\n--   You can get or update the name of each field by using the \'fieldName\' lens.\ntype TableSettings table = table (TableField table)\n\n-- | The regular Haskell version of the table. Equivalent to \'tbl Identity\'\ntype HaskellTable table = table Identity\n\n-- | Column tag that ignores the type.\ndata Ignored x = Ignored\n-- | A form of \'table\' all fields \'Ignored\'. Useful as a parameter to\n--   \'zipTables\' when you only care about one table.\ntype TableSkeleton table = table Ignored\n\nfrom\' :: Generic x => x -> Rep x ()\nfrom\' = from\n\nto\' :: Generic x => Rep x () -> x\nto\' = to\n\ntype HasBeamFields table f g h = ( GZipTables f g h (Rep (table Exposed))\n                                                    (Rep (table f))\n                                                    (Rep (table g))\n                                                    (Rep (table h))\n\n                                 , Generic (table f)\n                                 , Generic (table g)\n                                 , Generic (table h)\n                                 )\n\n-- | The big Kahuna! All beam tables implement this class.\n--\n--   The kind of all table types is \'(Type -> Type) -> Type\'. This is\n--   because all table types are actually /table type constructors/.\n--   Every table type takes in another type constructor, called the\n--   /column tag/, and uses that constructor to instantiate the column\n--   types.  See the documentation for \'Columnar\'.\n--\n--   This class is mostly Generic-derivable. You need only specify a\n--   type for the table\'s primary key and a method to extract the\n--   primary key given the table.\n--\n--   An example table:\n--\n-- > data BlogPostT f = BlogPost\n-- >                  { _blogPostSlug    :: Columnar f Text\n-- >                  , _blogPostBody    :: Columnar f Text\n-- >                  , _blogPostDate    :: Columnar f UTCTime\n-- >                  , _blogPostAuthor  :: PrimaryKey AuthorT f\n-- >                  , _blogPostTagline :: Columnar f (Maybe Text)\n-- >                  , _blogPostImageGallery :: PrimaryKey ImageGalleryT (Nullable f) }\n-- >                    deriving Generic\n-- > instance Beamable BlogPostT\n-- > instance Table BlogPostT where\n-- >    data PrimaryKey BlogPostT f = BlogPostId (Columnar f Text) deriving Generic\n-- >    primaryKey = BlogPostId . _blogPostSlug\n-- > instance Beamable (PrimaryKey BlogPostT)\n--\n--   We can interpret this as follows:\n--\n--     * The `_blogPostSlug`, `_blogPostBody`, `_blogPostDate`, and `_blogPostTagline` fields are of types \'Text\', \'Text\', \'UTCTime\', and \'Maybe Text\' respectfully.\n--     * Since `_blogPostSlug`, `_blogPostBody`, `_blogPostDate`, `_blogPostAuthor` must be provided (i.e, they cannot contain \'Nothing\'), they will be given SQL NOT NULL constraints.\n--       `_blogPostTagline` is declared \'Maybe\' so \'Nothing\' will be stored as NULL in the database. `_blogPostImageGallery` will be allowed to be empty because it uses the \'Nullable\' tag modifier.\n--     * `blogPostAuthor` references the `AuthorT` table (not given here) and is required.\n--     * `blogPostImageGallery` references the `ImageGalleryT` table (not given here), but this relation is not required (i.e., it may be \'Nothing\'. See \'Nullable\').\nclass (Typeable table, Beamable table, Beamable (PrimaryKey table)) => Table (table :: (Type -> Type) -> Type) where\n\n    -- | A data type representing the types of primary keys for this table.\n    --   In order to play nicely with the default deriving mechanism, this type must be an instance of \'Generic\'.\n    data PrimaryKey table (column :: Type -> Type) :: Type\n\n    -- | Given a table, this should return the PrimaryKey from the table. By keeping this polymorphic over column,\n    --   we ensure that the primary key values come directly from the table (i.e., they can\'t be arbitrary constants)\n    primaryKey :: table column -> PrimaryKey table column\n\n-- | Provides a number of introspection routines for the beam library. Allows us\n--   to "zip" tables with different column tags together. Always instantiate an\n--   empty \'Beamable\' instance for tables, primary keys, and any type that you\n--   would like to embed within either. See the\n--   [manual](https://haskell-beam.github.io/beam/user-guide/models) for more\n--   information on embedding.\nclass Beamable table where\n    zipBeamFieldsM :: Applicative m =>\n                      (forall a. Columnar\' f a -> Columnar\' g a -> m (Columnar\' h a)) -> table f -> table g -> m (table h)\n\n    default zipBeamFieldsM :: ( HasBeamFields table f g h\n                              , Applicative m\n\n                              ) => (forall a. Columnar\' f a -> Columnar\' g a -> m (Columnar\' h a))\n                                -> table f\n                                -> table g\n                                -> m (table h)\n\n    zipBeamFieldsM combine (f :: table f) g =\n        to\' <$> gZipTables (Proxy :: Proxy (Rep (table Exposed))) combine (from\' f) (from\' g)\n\n    tblSkeleton :: TableSkeleton table\n\n    default tblSkeleton :: ( Generic (TableSkeleton table)\n                           , GTableSkeleton (Rep (TableSkeleton table))\n                           ) => TableSkeleton table\n\n    tblSkeleton = withProxy $ \\proxy -> to\' (gTblSkeleton proxy)\n        where withProxy :: (Proxy (Rep (TableSkeleton table)) -> TableSkeleton table) -> TableSkeleton table\n              withProxy f = f Proxy\n\ntableValuesNeeded :: Beamable table => Proxy table -> Int\ntableValuesNeeded (Proxy :: Proxy table) = length (allBeamValues (const ()) (tblSkeleton :: TableSkeleton table))\n\nallBeamValues :: Beamable table => (forall a. Columnar\' f a -> b) -> table f -> [b]\nallBeamValues (f :: forall a. Columnar\' f a -> b) (tbl :: table f) =\n    execWriter (zipBeamFieldsM combine tbl tbl)\n    where combine :: Columnar\' f a -> Columnar\' f a -> Writer [b] (Columnar\' f a)\n          combine x _ = do tell [f x]\n                           return x\n\nchangeBeamRep :: Beamable table => (forall a. Columnar\' f a -> Columnar\' g a) -> table f -> table g\nchangeBeamRep f tbl = runIdentity (zipBeamFieldsM (\\x _ -> return (f x)) tbl tbl)\n\nalongsideTable :: Beamable tbl => tbl f -> tbl g -> tbl (Columnar\' f :*: Columnar\' g)\nalongsideTable a b =\n  runIdentity $\n  zipBeamFieldsM (\\x y -> pure (Columnar\' (x :*: y))) a b\n\nclass Retaggable f x | x -> f where\n  type Retag (tag :: (Type -> Type) -> Type -> Type) x :: Type\n\n  retag :: (forall a. Columnar\' f a -> Columnar\' (tag f) a) -> x\n        -> Retag tag x\n\ninstance Beamable tbl => Retaggable f (tbl (f :: Type -> Type)) where\n  type Retag tag (tbl f) = tbl (tag f)\n\n  retag = changeBeamRep\n\ninstance (Retaggable f a, Retaggable f b) => Retaggable f (a, b) where\n  type Retag tag (a, b) = (Retag tag a, Retag tag b)\n\n  retag transform (a, b) = (retag transform a, retag transform b)\n\ninstance (Retaggable f a, Retaggable f b, Retaggable f c) =>\n  Retaggable f (a, b, c) where\n  type Retag tag (a, b, c) = (Retag tag a, Retag tag b, Retag tag c)\n\n  retag transform (a, b, c) = (retag transform a, retag transform b, retag transform c)\n\ninstance (Retaggable f a, Retaggable f b, Retaggable f c, Retaggable f d) =>\n  Retaggable f (a, b, c, d) where\n  type Retag tag (a, b, c, d) =\n    (Retag tag a, Retag tag b, Retag tag c, Retag tag d)\n\n  retag transform (a, b, c, d) =\n    (retag transform a, retag transform b, retag transform c, retag transform d)\n\ninstance ( Retaggable f a, Retaggable f b, Retaggable f c, Retaggable f d\n         , Retaggable f e ) =>\n  Retaggable f (a, b, c, d, e) where\n  type Retag tag (a, b, c, d, e) =\n    (Retag tag a, Retag tag b, Retag tag c, Retag tag d, Retag tag e)\n\n  retag transform (a, b, c, d, e) =\n    ( retag transform a, retag transform b, retag transform c, retag transform d\n    , retag transform e)\n\ninstance ( Retaggable f\' a, Retaggable f\' b, Retaggable f\' c, Retaggable f\' d\n         , Retaggable f\' e, Retaggable f\' f ) =>\n  Retaggable f\' (a, b, c, d, e, f) where\n  type Retag tag (a, b, c, d, e, f) =\n    ( Retag tag a, Retag tag b, Retag tag c, Retag tag d\n    , Retag tag e, Retag tag f)\n\n  retag transform (a, b, c, d, e, f) =\n    ( retag transform a, retag transform b, retag transform c, retag transform d\n    , retag transform e, retag transform f )\n\ninstance ( Retaggable f\' a, Retaggable f\' b, Retaggable f\' c, Retaggable f\' d\n         , Retaggable f\' e, Retaggable f\' f, Retaggable f\' g ) =>\n  Retaggable f\' (a, b, c, d, e, f, g) where\n  type Retag tag (a, b, c, d, e, f, g) =\n    ( Retag tag a, Retag tag b, Retag tag c, Retag tag d\n    , Retag tag e, Retag tag f, Retag tag g )\n\n  retag transform (a, b, c, d, e, f, g) =\n    ( retag transform a, retag transform b, retag transform c, retag transform d\n    , retag transform e, retag transform f, retag transform g )\n\ninstance ( Retaggable f\' a, Retaggable f\' b, Retaggable f\' c, Retaggable f\' d\n         , Retaggable f\' e, Retaggable f\' f, Retaggable f\' g, Retaggable f\' h ) =>\n  Retaggable f\' (a, b, c, d, e, f, g, h) where\n  type Retag tag (a, b, c, d, e, f, g, h) =\n    ( Retag tag a, Retag tag b, Retag tag c, Retag tag d\n    , Retag tag e, Retag tag f, Retag tag g, Retag tag h )\n\n  retag transform (a, b, c, d, e, f, g, h) =\n    ( retag transform a, retag transform b, retag transform c, retag transform d\n    , retag transform e, retag transform f, retag transform g, retag transform h )\n\n-- | Carry a constraint instance and the value it applies to.\ndata WithConstraint (c :: Type -> Constraint) x where\n  WithConstraint :: c x => x -> WithConstraint c x\n\n-- | Carry a constraint instance.\ndata HasConstraint (c :: Type -> Constraint) x where\n  HasConstraint :: c x => HasConstraint c x\n\nclass GFieldsFulfillConstraint (c :: Type -> Constraint) (exposed :: Type -> Type) withconstraint where\n  gWithConstrainedFields :: Proxy c -> Proxy exposed -> withconstraint ()\ninstance GFieldsFulfillConstraint c exposed withconstraint =>\n    GFieldsFulfillConstraint c (M1 s m exposed) (M1 s m withconstraint) where\n  gWithConstrainedFields c _ = M1 (gWithConstrainedFields c (Proxy @exposed))\ninstance GFieldsFulfillConstraint c U1 U1 where\n  gWithConstrainedFields _ _ = U1\ninstance (GFieldsFulfillConstraint c aExp aC, GFieldsFulfillConstraint c bExp bC) =>\n  GFieldsFulfillConstraint c (aExp :*: bExp) (aC :*: bC) where\n  gWithConstrainedFields be _ = gWithConstrainedFields be (Proxy @aExp) :*: gWithConstrainedFields be (Proxy @bExp)\ninstance (c x) => GFieldsFulfillConstraint c (K1 Generic.R (Exposed x)) (K1 Generic.R (HasConstraint c x)) where\n  gWithConstrainedFields _ _ = K1 HasConstraint\ninstance FieldsFulfillConstraint c t =>\n    GFieldsFulfillConstraint c (K1 Generic.R (t Exposed)) (K1 Generic.R (t (HasConstraint c))) where\n  gWithConstrainedFields _ _ = K1 (to (gWithConstrainedFields (Proxy @c) (Proxy @(Rep (t Exposed)))))\ninstance FieldsFulfillConstraintNullable c t =>\n    GFieldsFulfillConstraint c (K1 Generic.R (t (Nullable Exposed))) (K1 Generic.R (t (Nullable (HasConstraint c)))) where\n  gWithConstrainedFields _ _ = K1 (to (gWithConstrainedFields (Proxy @c) (Proxy @(Rep (t (Nullable Exposed))))))\n\nwithConstrainedFields :: forall c tbl\n                       . (FieldsFulfillConstraint c tbl, Beamable tbl) => tbl Identity -> tbl (WithConstraint c)\nwithConstrainedFields = runIdentity . zipBeamFieldsM f (withConstraints @c @tbl)\n  where f :: forall a. Columnar\' (HasConstraint c) a -> Columnar\' Identity a -> Identity (Columnar\' (WithConstraint c) a)\n        f (Columnar\' HasConstraint) (Columnar\' a) = Identity $ Columnar\' $ WithConstraint a\n\nwithConstraints :: forall c tbl. (Beamable tbl, FieldsFulfillConstraint c tbl) => tbl (HasConstraint c)\nwithConstraints = to $ gWithConstrainedFields (Proxy @c) (Proxy @(Rep (tbl Exposed)))\n\nwithNullableConstrainedFields :: forall c tbl\n                               . (FieldsFulfillConstraintNullable c tbl, Beamable tbl) => tbl (Nullable Identity) -> tbl (Nullable (WithConstraint c))\nwithNullableConstrainedFields = runIdentity . zipBeamFieldsM f (withNullableConstraints @c @tbl)\n  where f :: forall a. Columnar\' (Nullable (HasConstraint c)) a -> Columnar\' (Nullable Identity) a -> Identity (Columnar\' (Nullable (WithConstraint c)) a)\n        f (Columnar\' HasConstraint) (Columnar\' a) = Identity $ Columnar\' $ WithConstraint a\n\nwithNullableConstraints ::  forall c tbl. (Beamable tbl, FieldsFulfillConstraintNullable c tbl) => tbl (Nullable (HasConstraint c))\nwithNullableConstraints = to $ gWithConstrainedFields (Proxy @c) (Proxy @(Rep (tbl (Nullable Exposed))))\n\ntype FieldsFulfillConstraint (c :: Type -> Constraint) t =\n  ( Generic (t (HasConstraint c)), Generic (t Identity), Generic (t Exposed)\n  , GFieldsFulfillConstraint c (Rep (t Exposed)) (Rep (t (HasConstraint c))))\n\ntype FieldsFulfillConstraintNullable (c :: Type -> Constraint) t =\n  ( Generic (t (Nullable (HasConstraint c))), Generic (t (Nullable Identity)), Generic (t (Nullable Exposed))\n  , GFieldsFulfillConstraint c (Rep (t (Nullable Exposed))) (Rep (t (Nullable (HasConstraint c)))))\n\n-- | Synonym for \'primaryKey\'\npk :: Table t => t f -> PrimaryKey t f\npk = primaryKey\n\n-- | Return a \'TableSettings\' for the appropriate \'table\' type where each column\n--   has been given its default name. See the\n--   [manual](https://haskell-beam.github.io/beam/user-guide/models) for\n--   information on the default naming convention.\ndefTblFieldSettings :: ( Generic (TableSettings table)\n                       , GDefaultTableFieldSettings (Rep (TableSettings table) ())) =>\n                       TableSettings table\ndefTblFieldSettings = withProxy $ \\proxy -> to\' (gDefTblFieldSettings proxy)\n    where withProxy :: (Proxy (Rep (TableSettings table) ()) -> TableSettings table) -> TableSettings table\n          withProxy f = f Proxy\n\nclass GZipTables f g h (exposedRep :: Type -> Type) fRep gRep hRep where\n    gZipTables :: Applicative m => Proxy exposedRep\n                                -> (forall a. Columnar\' f a -> Columnar\' g a -> m (Columnar\' h a))\n                                -> fRep ()\n                                -> gRep ()\n                                -> m (hRep ())\n\ninstance ( GZipTables f g h exp1 f1 g1 h1\n         , GZipTables f g h exp2 f2 g2 h2\n         ) => GZipTables f g h (exp1 :*: exp2) (f1 :*: f2) (g1 :*: g2) (h1 :*: h2)\n   where\n\n        gZipTables _ combine ~(f1 :*: f2) ~(g1 :*: g2) =\n            (:*:) <$> gZipTables (Proxy :: Proxy exp1) combine f1 g1\n                  <*> gZipTables (Proxy :: Proxy exp2) combine f2 g2\n\ninstance GZipTables f g h exp fRep gRep hRep =>\n    GZipTables f g h (M1 x y exp) (M1 x y fRep) (M1 x y gRep) (M1 x y hRep) where\n        gZipTables _ combine ~(M1 f) ~(M1 g) = M1 <$> gZipTables (Proxy :: Proxy exp) combine f g\n\ninstance ( fa ~ Columnar f a\n         , ga ~ Columnar g a\n         , ha ~ Columnar h a\n         , ha ~ Columnar h a) =>\n    GZipTables f g h (K1 Generic.R (Exposed a)) (K1 Generic.R fa) (K1 Generic.R ga) (K1 Generic.R ha) where\n        gZipTables _ combine ~(K1 f) ~(K1 g) = (\\(Columnar\' h) -> K1 h) <$> combine (Columnar\' f :: Columnar\' f a) (Columnar\' g :: Columnar\' g a)\n\ninstance ( Beamable tbl\n         ) => GZipTables f g h (K1 Generic.R (tbl Exposed)) (K1 Generic.R (tbl f))\n                                                            (K1 Generic.R (tbl g))\n                                                            (K1 Generic.R (tbl h))\n   where\n    gZipTables _ combine ~(K1 f) ~(K1 g) = K1 <$> zipBeamFieldsM combine f g\n\n\ninstance GZipTables f g h U1 U1 U1 U1 where\n  gZipTables _ _ _ _ = pure U1\n\ninstance  ( Beamable tbl\n          ) => GZipTables f g h (K1 Generic.R (tbl (Nullable Exposed)))\n                                (K1 Generic.R (tbl (Nullable f)))\n                                (K1 Generic.R (tbl (Nullable g)))\n                                (K1 Generic.R (tbl (Nullable h)))\n   where\n\n    gZipTables _ combine ~(K1 f) ~(K1 g) =  K1 <$> zipBeamFieldsM (adapt combine) f g\n      where\n        adapt :: Applicative m => (forall a . Columnar\' f a            -> Columnar\' g a            -> m (Columnar\' h a)           )\n                               -> (forall a . Columnar\' (Nullable f) a -> Columnar\' (Nullable g) a -> m (Columnar\' (Nullable h) a))\n        adapt func x y = toNullable <$> func ( fromNullable x ) ( fromNullable y )\n\n        fromNullable :: Columnar\' (Nullable w) a -> Columnar\' w (Maybe a)\n        fromNullable ~(Columnar\' x) = Columnar\' x\n\n        toNullable   :: Columnar\' w (Maybe a) -> Columnar\' (Nullable w) a\n        toNullable ~(Columnar\' x) = Columnar\' x\n\nclass GDefaultTableFieldSettings x where\n    gDefTblFieldSettings :: Proxy x -> x\ninstance GDefaultTableFieldSettings (p x) => GDefaultTableFieldSettings (D1 f p x) where\n    gDefTblFieldSettings (_ :: Proxy (D1 f p x)) = M1 $ gDefTblFieldSettings (Proxy :: Proxy (p x))\ninstance GDefaultTableFieldSettings (p x) => GDefaultTableFieldSettings (C1 f p x) where\n    gDefTblFieldSettings (_ :: Proxy (C1 f p x)) = M1 $ gDefTblFieldSettings (Proxy :: Proxy (p x))\ninstance (GDefaultTableFieldSettings (a p), GDefaultTableFieldSettings (b p)) => GDefaultTableFieldSettings ((a :*: b) p) where\n    gDefTblFieldSettings (_ :: Proxy ((a :*: b) p)) = gDefTblFieldSettings (Proxy :: Proxy (a p)) :*: gDefTblFieldSettings (Proxy :: Proxy (b p))\n\ninstance Selector f  =>\n    GDefaultTableFieldSettings (S1 f (K1 Generic.R (TableField table field)) p) where\n    gDefTblFieldSettings (_ :: Proxy (S1 f (K1 Generic.R (TableField table field)) p)) = M1 (K1 s)\n        where s = TableField (pure rawSelName) name\n              name = unCamelCaseSel rawSelName\n              rawSelName = T.pack (selName (undefined :: S1 f (K1 Generic.R (TableField table field)) ()))\n\ninstance ( TypeError (\'Text "All Beamable types must be record types, so appropriate names can be given to columns")) => GDefaultTableFieldSettings (K1 r f p) where\n  gDefTblFieldSettings _ = error "impossible"\n\n-- | Type-level representation of the naming strategy to use for defaulting\n--   Needed because primary keys should be named after the default naming of\n--   their corresponding table, not the names of the record selectors in the\n--   primary key (if any).\ndata SubTableStrategy\n  = PrimaryKeyStrategy\n  | BeamableStrategy\n  | RecursiveKeyStrategy\n\ntype family ChooseSubTableStrategy (tbl :: (Type -> Type) -> Type) (sub :: (Type -> Type) -> Type) :: SubTableStrategy where\n  ChooseSubTableStrategy tbl (PrimaryKey tbl) = \'RecursiveKeyStrategy\n  ChooseSubTableStrategy tbl (PrimaryKey rel) = \'PrimaryKeyStrategy\n  ChooseSubTableStrategy tbl sub = \'BeamableStrategy\n\n-- TODO is this necessary\ntype family CheckNullable (f :: Type -> Type) :: Constraint where\n  CheckNullable (Nullable f) = ()\n  CheckNullable f = TypeError (\'Text "Recursive references without Nullable constraint form an infinite loop." \':$$:\n                               \'Text "Hint: Only embed nullable \'PrimaryKey tbl\' within the definition of \'tbl\'." \':$$:\n                               \'Text "      For example, replace \'PrimaryKey tbl f\' with \'PrimaryKey tbl (Nullable f)\'")\n\n\nclass SubTableStrategyImpl (strategy :: SubTableStrategy) (f :: Type -> Type) sub where\n  namedSubTable :: Proxy strategy -> sub f\n\n-- The defaulting with @TableField rel@ is necessary to avoid infinite loops\ninstance ( Table rel, Generic (rel (TableField rel))\n         , TagReducesTo f (TableField tbl)\n         , GDefaultTableFieldSettings (Rep (rel (TableField rel)) ()) ) =>\n  SubTableStrategyImpl \'PrimaryKeyStrategy f (PrimaryKey rel) where\n  namedSubTable _ = primaryKey tbl\n    where tbl = changeBeamRep (\\(Columnar\' (TableField path nm) :: Columnar\' (TableField rel) a) ->\n                                  let c = Columnar\' (TableField path nm) :: Columnar\' (TableField tbl) a\n                                  in runIdentity (reduceTag (\\_ -> pure c) undefined)) $\n                to\' $ gDefTblFieldSettings (Proxy @(Rep (rel (TableField rel)) ()))\ninstance ( Generic (sub f)\n         , GDefaultTableFieldSettings (Rep (sub f) ()) ) =>\n         SubTableStrategyImpl \'BeamableStrategy f sub where\n  namedSubTable _ = to\' $ gDefTblFieldSettings (Proxy @(Rep (sub f) ()))\ninstance ( CheckNullable f, SubTableStrategyImpl \'PrimaryKeyStrategy f (PrimaryKey rel) ) =>\n         SubTableStrategyImpl \'RecursiveKeyStrategy f (PrimaryKey rel) where\n  namedSubTable _ = namedSubTable (Proxy @\'PrimaryKeyStrategy)\n\ninstance {-# OVERLAPPING #-}\n         ( Selector f\'\n         , ChooseSubTableStrategy tbl sub ~ strategy\n         , SubTableStrategyImpl strategy f sub\n         , TagReducesTo f (TableField tbl)\n         , Beamable sub ) =>\n         GDefaultTableFieldSettings (S1 f\' (K1 Generic.R (sub f)) p) where\n  gDefTblFieldSettings _ = M1 . K1 $ settings\'\n    where tbl :: sub f\n          tbl = namedSubTable (Proxy @strategy)\n\n          origSelName = T.pack (selName (undefined :: S1 f\' (K1 Generic.R (sub f)) p))\n          relName = unCamelCaseSel origSelName\n\n          settings\' :: sub f\n          settings\' = changeBeamRep (reduceTag %~ \\(Columnar\' (TableField path nm)) -> Columnar\' (TableField (pure origSelName <> path) (relName <> "__" <> nm))) tbl\n\ntype family ReplaceBaseTag tag f where\n  ReplaceBaseTag tag (Nullable f) = Nullable (ReplaceBaseTag tag f)\n  ReplaceBaseTag tag x = tag\n\n-- | Class to automatically unwrap nested Nullables\nclass TagReducesTo f f\' | f -> f\' where\n  reduceTag :: Functor m =>\n               (Columnar\' f\' a\' -> m (Columnar\' f\' a\'))\n            -> Columnar\' f a -> m (Columnar\' f a)\ninstance TagReducesTo (TableField tbl) (TableField tbl) where\n  reduceTag f ~(Columnar\' (TableField path nm)) =\n    (\\(Columnar\' (TableField path\' nm\')) -> Columnar\' (TableField path\' nm\')) <$>\n    f (Columnar\' (TableField path nm))\ninstance TagReducesTo f f\' => TagReducesTo (Nullable f) f\' where\n  reduceTag fn ~(Columnar\' x :: Columnar\' (Nullable f) a) =\n    (\\(Columnar\' x\' :: Columnar\' f (Maybe a\')) -> Columnar\' x\') <$>\n          reduceTag fn (Columnar\' x :: Columnar\' f (Maybe a))\n\nclass GTableSkeleton x where\n    gTblSkeleton :: Proxy x -> x ()\n\ninstance GTableSkeleton p => GTableSkeleton (M1 t f p) where\n    gTblSkeleton (_ :: Proxy (M1 t f p)) = M1 (gTblSkeleton (Proxy :: Proxy p))\n\ninstance GTableSkeleton U1 where\n    gTblSkeleton _ = U1\n\ninstance (GTableSkeleton a, GTableSkeleton b) =>\n    GTableSkeleton (a :*: b) where\n        gTblSkeleton _ = gTblSkeleton (Proxy :: Proxy a) :*: gTblSkeleton (Proxy :: Proxy b)\n\ninstance GTableSkeleton (K1 Generic.R (Ignored field)) where\n    gTblSkeleton _ = K1 Ignored\n\ninstance ( Beamable tbl\n         ) => GTableSkeleton (K1 Generic.R (tbl Ignored))\n   where\n    gTblSkeleton _ = K1 (tblSkeleton :: TableSkeleton tbl)\n\ninstance ( Beamable tbl\n         ) => GTableSkeleton (K1 Generic.R (tbl (Nullable Ignored)))\n   where\n    gTblSkeleton _ = K1 . runIdentity\n                   $ zipBeamFieldsM transform\n                                    (tblSkeleton :: TableSkeleton tbl)\n                                    (tblSkeleton :: TableSkeleton tbl)\n        where\n          transform :: Columnar\' Ignored a\n                    -> Columnar\' Ignored a\n                    -> Identity (Columnar\' (Nullable Ignored) a)\n          transform _ _ = Identity (Columnar\' Ignored)\n\n\n-- * Internal functions\n\nunCamelCase :: T.Text -> [T.Text]\nunCamelCase "" = []\nunCamelCase s\n    | (comp, next) <- T.break isUpper s, not (T.null comp) =\n          let next\' = maybe mempty (uncurry T.cons . first toLower) (T.uncons next)\n          in T.toLower comp:unCamelCase next\'\n    | otherwise =\n          let (comp, next) = T.span isUpper s\n              next\' = maybe mempty (uncurry T.cons . first toLower) (T.uncons next)\n          in T.toLower comp:unCamelCase next\'\n\n-- | Camel casing magic for standard beam record field names.\n--\n--   All leading underscores are ignored. If what remains is camel-cased beam\n--   will convert it to use underscores instead. If there are any underscores in\n--   what remains, then the entire name (minus the leading underscares). If the\n--   field name is solely underscores, beam will assume you know what you\'re\n--   doing and include the full original name as the field name\nunCamelCaseSel :: Text -> Text\nunCamelCaseSel original =\n  let symbolLeft = T.dropWhile (==\'_\') original\n  in if T.null symbolLeft\n     then original\n     else if T.any (==\'_\') symbolLeft\n          then symbolLeft\n          else case unCamelCase symbolLeft of\n                 [] -> symbolLeft\n                 [xs] -> xs\n                 _:xs -> T.intercalate "_" xs\n\n-- | Produce the beam default field name for the given path\ndefaultFieldName :: NE.NonEmpty Text -> Text\ndefaultFieldName comps = fold (NE.intersperse (T.pack "__") (unCamelCaseSel <$> comps))\n'