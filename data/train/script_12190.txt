b'module Queue\r\nwhere\r\n\r\ndata Queue a = Q !Int [a] !Int [a]\r\n               deriving Show\r\n\r\nempty :: Queue a\r\nempty = Q 0 [] 0 []\r\n\r\nhead :: Queue a -> a\r\nhead (Q lf (f:fs) lb bs) = f\r\nhead (Q _ [] _ _) = error "empty queue"\r\n\r\ntail :: Queue a -> Queue a\r\ntail (Q lf (f:fs) lb bs) = makeQ (lf - 1) fs lb bs\r\ntail (Q _ [] _ _) = error "empty queue"\r\n\r\nsnoc :: a -> Queue a -> Queue a\r\nsnoc x (Q lf fs lb bs) = makeQ lf fs (lb + 1) (x:bs)\r\n\r\nmakeQ :: Int -> [a] -> Int -> [a] -> Queue a\r\nmakeQ lf fs lb bs\r\n    | lf > lb       = Q lf fs lb bs\r\n    | otherwise     = Q (lf + lb) (fs ++ reverse bs) 0 []\r\n\r\nelemsQueue :: Queue a -> [a]\r\nelemsQueue (Q lf fs lb bs) = fs ++ (reverse bs)\r\n\r\ninsert = flip snoc\r\n\r\nremove :: Queue a -> (a, Queue a)\r\nremove (Q lf (f:fs) lb bs) = (f, makeQ (lf - 1) fs lb bs)\r\nremove (Q _ [] _ _) = error "empty queue"\r\n\r\n'