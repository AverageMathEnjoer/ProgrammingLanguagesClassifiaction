b'-- Conforms to\n-- (0x44 or 0x22) and (0x32 or (not 0x39)) ==> 102\n\nmodule Main where\nimport Data.Bits\nimport Text.Parsec\nimport Text.Parsec.String\nimport Control.Applicative ((<$>))\nimport Numeric (readHex)\n\n\ntype Operator = Expression -> Expression -> Expression\ndata Expression = Literal Int\n                | Not Expression\n                | And Expression Expression\n                | Or Expression Expression\n                | Xor Expression Expression\n                deriving Show\n\n\ncompute :: Expression -> Int\ncompute exp = case exp of\n  (Literal n) -> n\n  (Not exp1) -> complement $ compute exp1\n  (And exp1 exp2) -> compute exp1 .&. compute exp2\n  (Or exp1 exp2) -> compute exp1 .|. compute exp2\n  (Xor exp1 exp2) -> compute exp1 `xor` compute exp2\n\n\nliteral = string "0x" >> many1 hexDigit >>= return . Literal . fst . (!!0) . readHex\nnegation = string "not" >> spaces >> hardExpression >>= return . Not\n\nbinary = do\n  exp1 <- hardExpression\n  spaces\n  op <- string "and" <|> string "or" <|> string "xor"\n  spaces\n  exp2 <- hardExpression\n  return $ case op of\n    "and" -> And exp1 exp2\n    "or" -> Or exp1 exp2\n    "xor" -> Xor exp1 exp2\n\nparenthetical = do\n  char \'(\'\n  expr <- expression\n  char \')\'\n  return expr\n\nhardExpression = literal <|> parenthetical\n\nexpression :: Parser Expression\nexpression = try binary <|> negation <|> hardExpression\n\nmain = do\n  str <- getLine\n  putStrLn $\n    case parse expression "" str of\n      Right expr -> show $ compute expr\n      Left err -> show err\n '