b'{-# LANGUAGE CPP #-}\n#if !defined(TESTING) && defined(__GLASGOW_HASKELL__)\n{-# LANGUAGE Safe #-}\n#endif\n\n#ifdef __GLASGOW_HASKELL__\n{-# LANGUAGE DataKinds, FlexibleContexts, MonoLocalBinds #-}\n#endif\n\n#include "containers.h"\n\n-----------------------------------------------------------------------------\n-- |\n-- Module      :  Data.Map\n-- Copyright   :  (c) Daan Leijen 2002\n--                (c) Andriy Palamarchuk 2008\n-- License     :  BSD-style\n-- Maintainer  :  libraries@haskell.org\n-- Portability :  portable\n--\n-- /Note:/ You should use "Data.Map.Strict" instead of this module if:\n--\n-- * You will eventually need all the values stored.\n--\n-- * The stored values don\'t represent large virtual data structures\n-- to be lazily computed.\n--\n-- An efficient implementation of ordered maps from keys to values\n-- (dictionaries).\n--\n-- These modules are intended to be imported qualified, to avoid name\n-- clashes with Prelude functions, e.g.\n--\n-- >  import qualified Data.Map as Map\n--\n-- The implementation of \'Map\' is based on /size balanced/ binary trees (or\n-- trees of /bounded balance/) as described by:\n--\n--    * Stephen Adams, \\"/Efficient sets: a balancing act/\\",\n--     Journal of Functional Programming 3(4):553-562, October 1993,\n--     <http://www.swiss.ai.mit.edu/~adams/BB/>.\n--    * J. Nievergelt and E.M. Reingold,\n--      \\"/Binary search trees of bounded balance/\\",\n--      SIAM journal of computing 2(1), March 1973.\n--\n--  Bounds for \'union\', \'intersection\', and \'difference\' are as given\n--  by\n--\n--    * Guy Blelloch, Daniel Ferizovic, and Yihan Sun,\n--      \\"/Just Join for Parallel Ordered Sets/\\",\n--      <https://arxiv.org/abs/1602.02120v3>.\n--\n-- Note that the implementation is /left-biased/ -- the elements of a\n-- first argument are always preferred to the second, for example in\n-- \'union\' or \'insert\'.\n--\n-- /Warning/: The size of the map must not exceed @maxBound::Int@. Violation of\n-- this condition is not detected and if the size limit is exceeded, its\n-- behaviour is undefined.\n--\n-- Operation comments contain the operation time complexity in\n-- the Big-O notation (<http://en.wikipedia.org/wiki/Big_O_notation>).\n-----------------------------------------------------------------------------\n\nmodule Data.Map\n    ( module Data.Map.Lazy\n#ifdef __GLASGOW_HASKELL__\n    , insertWith\'\n    , insertWithKey\'\n    , insertLookupWithKey\'\n    , fold\n    , foldWithKey\n#endif\n    ) where\n\nimport Data.Map.Lazy\n\n#ifdef __GLASGOW_HASKELL__\nimport Utils.Containers.Internal.TypeError\n\n-- | This function is being removed and is no longer usable.\n-- Use \'Data.Map.Strict.insertWith\'.\ninsertWith\' :: Whoops "Data.Map.insertWith\' is gone. Use Data.Map.Strict.insertWith."\n            => (a -> a -> a) -> k -> a -> Map k a -> Map k a\ninsertWith\' _ _ _ _ = undefined\n\n-- | This function is being removed and is no longer usable.\n-- Use \'Data.Map.Strict.insertWithKey\'.\ninsertWithKey\' :: Whoops "Data.Map.insertWithKey\' is gone. Use Data.Map.Strict.insertWithKey."\n               => (k -> a -> a -> a) -> k -> a -> Map k a -> Map k a\ninsertWithKey\' _ _ _ _ = undefined\n\n-- | This function is being removed and is no longer usable.\n-- Use \'Data.Map.Strict.insertLookupWithKey\'.\ninsertLookupWithKey\' :: Whoops "Data.Map.insertLookupWithKey\' is gone. Use Data.Map.Strict.insertLookupWithKey."\n                     => (k -> a -> a -> a) -> k -> a -> Map k a\n                     -> (Maybe a, Map k a)\ninsertLookupWithKey\' _ _ _ _ = undefined\n\n-- | This function is being removed and is no longer usable.\n-- Use \'Data.Map.Strict.foldr\'.\nfold :: Whoops "Data.Map.fold is gone. Use foldr."\n     => (a -> b -> b) -> b -> Map k a -> b\nfold _ _ _ = undefined\n\n-- | This function is being removed and is no longer usable.\n-- Use \'foldrWithKey\'.\nfoldWithKey :: Whoops "Data.Map.foldWithKey is gone. Use foldrWithKey."\n            => (k -> a -> b -> b) -> b -> Map k a -> b\nfoldWithKey _ _ _ = undefined\n#endif\n'