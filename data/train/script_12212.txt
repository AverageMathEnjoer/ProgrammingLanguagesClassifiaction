b'\xef\xbb\xbf//  Copyright 2019 Google Inc. All Rights Reserved.\n//\n//  Licensed under the Apache License, Version 2.0 (the "License");\n//  you may not use this file except in compliance with the License.\n//  You may obtain a copy of the License at\n//\n//  http://www.apache.org/licenses/LICENSE-2.0\n//\n//  Unless required by applicable law or agreed to in writing, software\n//  distributed under the License is distributed on an "AS IS" BASIS,\n//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n//  See the License for the specific language governing permissions and\n//  limitations under the License.\n\nusing Rubeus.Utilities.Text;\nusing System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Text;\n\nnamespace Rubeus.Ndr.Marshal\n{\n#pragma warning disable 1591\n    /// <summary>\n    /// A buffer to marshal NDR data to.\n    /// </summary>\n    /// <remarks>This class is primarily for internal use only.</remarks>\n    public class NdrMarshalBuffer\n    {\n        #region Private Members\n        private readonly MemoryStream _stm;\n        private readonly BinaryWriter _writer;\n        private NdrDeferralStack _deferred_writes;\n        private int _referent;\n        private long? _conformance_position;\n\n        private bool WriteReferent<T>(T obj) where T : class\n        {\n            if (obj == null)\n            {\n                WriteInt32(0);\n                return false;\n            }\n            else\n            {\n                WriteInt32(_referent);\n                _referent += 4;\n                return true;\n            }\n        }\n\n        private bool WriteReferent<T>(T? obj) where T : struct\n        {\n            if (!obj.HasValue)\n            {\n                WriteInt32(0);\n                return false;\n            }\n            else\n            {\n                WriteInt32(_referent);\n                _referent += 4;\n                return true;\n            }\n        }\n\n        private void WriteEmbeddedPointer<T>(NdrEmbeddedPointer<T> pointer, Action writer)\n        {\n            if (WriteReferent(pointer))\n            {\n                _deferred_writes.Add(writer);\n            }\n        }\n\n        private void WriteStringArray(string[] array, Action<string> writer, int count)\n        {\n            if (array == null)\n            {\n                array = new string[0];\n            }\n\n            for (int i = 0; i < count; ++i)\n            {\n                string value = i < array.Length ? array[i] : string.Empty;\n                WriteReferent(value);\n                _deferred_writes.Add(() => writer(value));\n            }\n        }\n\n        private void WriteConformance(params int[] conformance)\n        {\n            if (_conformance_position.HasValue)\n            {\n                long current_position = _stm.Position;\n                _stm.Position = _conformance_position.Value;\n                byte[] data = new byte[conformance.Length * 4];\n                Buffer.BlockCopy(conformance, 0, data, 0, data.Length);\n                _stm.Write(data, 0, data.Length);\n                _stm.Position = current_position;\n                _conformance_position = null;\n            }\n            else\n            {\n                foreach (var i in conformance)\n                {\n                    WriteInt32(i);\n                }\n            }\n        }\n\n        private bool SetupConformance(int dimensions)\n        {\n            if (dimensions == 0 || _conformance_position.HasValue)\n            {\n                return false;\n            }\n\n            for (int i = 0; i < dimensions; ++i)\n            {\n                WriteInt32(0x77777777);\n            }\n\n            _conformance_position = _stm.Position - (dimensions * 4);\n\n            return true;\n        }\n\n        private void WriteStructInternal(INdrStructure structure)\n        {\n            Align(structure.GetAlignment());\n            structure.Marshal(this);\n        }\n\n        private void WriteUnionInternal(INdrNonEncapsulatedUnion union, long selector)\n        {\n            Align(union.GetAlignment());\n            union.Marshal(this, selector);\n        }\n\n        private void Align(int alignment)\n        {\n            byte[] buffer = new byte[NdrNativeUtils.CalculateAlignment((int)_stm.Length, alignment)];\n            _stm.Write(buffer, 0, buffer.Length);\n        }\n\n        #endregion\n\n        #region Constructors\n        public NdrMarshalBuffer() : this(new NdrDataRepresentation()\n        {\n            CharacterRepresentation = NdrCharacterRepresentation.ASCII,\n            FloatingPointRepresentation = NdrFloatingPointRepresentation.IEEE,\n            IntegerRepresentation = NdrIntegerRepresentation.LittleEndian\n        })\n        {\n        }\n\n        public NdrMarshalBuffer(NdrDataRepresentation data_representation)\n        {\n            _stm = new MemoryStream();\n            _writer = new BinaryWriter(_stm, Encoding.Unicode);\n            _referent = 0x20000;\n            _deferred_writes = new NdrDeferralStack();\n            NdrUnmarshalBuffer.CheckDataRepresentation(data_representation);\n            DataRepresentation = data_representation;\n        }\n\n        #endregion\n\n        #region Misc Methods\n\n        public void WriteUnsupported(NdrUnsupported type, string name)\n        {\n            throw new NotImplementedException($"Writing type {name} is unsupported");\n        }\n\n        public void WriteEmpty(NdrEmpty empty)\n        {\n            // Do nothing.\n        }\n\n        public void WriteInterfacePointer(NdrInterfacePointer intf)\n        {\n            WriteStruct(intf);\n        }\n\n        public void WritePipe<T>(NdrPipe<T> pipe) where T : struct\n        {\n            throw new NotImplementedException("Pipe support is not implemented");\n        }\n\n        public byte[] ToArray()\n        {\n            byte[] ret = _stm.ToArray();\n            int alignment = NdrNativeUtils.CalculateAlignment(ret.Length, 8);\n            if (alignment > 0)\n            {\n                Array.Resize(ref ret, ret.Length + alignment);\n            }\n\n            return ret;\n        }\n\n        public NdrPickledType ToPickledType()\n        {\n            return new NdrPickledType(ToArray(), DataRepresentation);\n        }\n\n        #endregion\n\n        #region Primitive Types\n        public void WriteByte(byte b)\n        {\n            _writer.Write(b);\n        }\n\n        public void WriteByte(byte? b)\n        {\n            if (b.HasValue)\n            {\n                WriteByte(b.Value);\n            }\n        }\n\n        public void WriteSByte(sbyte b)\n        {\n            _writer.Write(b);\n        }\n\n        public void WriteSByte(sbyte? b)\n        {\n            if (b.HasValue)\n            {\n                WriteSByte(b.Value);\n            }\n        }\n\n        public void WriteInt16(short s)\n        {\n            Align(2);\n            _writer.Write(s);\n        }\n\n        public void WriteInt16(short? s)\n        {\n            if (s.HasValue)\n            {\n                WriteInt16(s.Value);\n            }\n        }\n\n        public void WriteUInt16(ushort s)\n        {\n            Align(2);\n            _writer.Write(s);\n        }\n\n        public void WriteUInt16(ushort? s)\n        {\n            if (s.HasValue)\n            {\n                WriteUInt16(s.Value);\n            }\n        }\n\n        public void WriteInt32(int i)\n        {\n            Align(4);\n            _writer.Write(i);\n        }\n\n        public void WriteInt32(int? i)\n        {\n            if (i.HasValue)\n            {\n                WriteInt32(i.Value);\n            }\n        }\n\n        public void WriteUInt32(uint i)\n        {\n            Align(4);\n            _writer.Write(i);\n        }\n\n        public void WriteUInt32(uint? i)\n        {\n            if (i.HasValue)\n            {\n                WriteUInt32(i.Value);\n            }\n        }\n\n        public void WriteInt64(long l)\n        {\n            Align(8);\n            _writer.Write(l);\n        }\n\n        public void WriteInt64(long? l)\n        {\n            if (l.HasValue)\n            {\n                WriteInt64(l.Value);\n            }\n        }\n\n        public void WriteUInt64(ulong l)\n        {\n            Align(8);\n            _writer.Write(l);\n        }\n\n        public void WriteUInt64(ulong? l)\n        {\n            if (l.HasValue)\n            {\n                WriteUInt64(l.Value);\n            }\n        }\n\n        public void WriteFloat(float f)\n        {\n            Align(4);\n            _writer.Write(f);\n        }\n\n        public void WriteFloat(float? f)\n        {\n            if (f.HasValue)\n            {\n                WriteFloat(f.Value);\n            }\n        }\n\n        public void WriteDouble(double d)\n        {\n            Align(8);\n            _writer.Write(d);\n        }\n\n        public void WriteDouble(double? d)\n        {\n            if (d.HasValue)\n            {\n                WriteDouble(d.Value);\n            }\n        }\n\n        public void WriteChar(char c)\n        {\n            Align(2);\n            _writer.Write(c);\n        }\n\n        public void WriteChar(char? c)\n        {\n            if (c.HasValue)\n            {\n                WriteChar(c.Value);\n            }\n        }\n\n        public void WriteInt3264(NdrInt3264 p)\n        {\n            WriteInt32(p.Value);\n        }\n\n        public void WriteInt3264(NdrInt3264? p)\n        {\n            if (p.HasValue)\n            {\n                WriteInt3264(p.Value);\n            }\n        }\n\n        public void WriteUInt3264(NdrUInt3264 p)\n        {\n            WriteUInt32(p.Value);\n        }\n\n        public void WriteUInt3264(NdrUInt3264? p)\n        {\n            if (p.HasValue)\n            {\n                WriteUInt3264(p.Value);\n            }\n        }\n\n        public void WriteEnum16(NdrEnum16 e)\n        {\n            WriteInt16((short)e.Value);\n        }\n\n        public void WriteEnum16(NdrEnum16? p)\n        {\n            if (p.HasValue)\n            {\n                WriteEnum16(p.Value);\n            }\n        }\n\n        #endregion\n\n        #region String Types\n\n        public void WriteTerminatedString(string str)\n        {\n            WriteConformantVaryingString(str, -1);\n        }\n\n        public void WriteTerminatedAnsiString(string str)\n        {\n            WriteConformantVaryingAnsiString(str, -1);\n        }\n\n        public void WriteConformantVaryingString(string str, long conformance)\n        {\n            if (str == null)\n            {\n                return;\n            }\n\n            char[] values = (str + \'\\0\').ToCharArray();\n            if (conformance < 0)\n            {\n                conformance = values.Length;\n            }\n\n            // Maximum count.\n            WriteConformance((int)conformance);\n            // Offset.\n            WriteInt32(0);\n            // Actual count.\n            WriteInt32(values.Length);\n            WriteChars(values);\n        }\n\n        public void WriteConformantVaryingAnsiString(string str, long conformance)\n        {\n            if (str == null)\n            {\n                return;\n            }\n\n            byte[] values = BinaryEncoding.Instance.GetBytes(str + \'\\0\');\n            if (conformance < 0)\n            {\n                conformance = values.Length;\n            }\n\n            // Maximum count.\n            WriteConformance((int)conformance);\n            // Offset.\n            WriteInt32(0);\n            // Actual count.\n            WriteInt32(values.Length);\n            WriteBytes(values);\n        }\n\n        public void WriteFixedString(string str, int fixed_count)\n        {\n            WriteFixedChars(str.ToCharArray(), fixed_count);\n        }\n\n        public void WriteFixedAnsiString(string str, int fixed_count)\n        {\n            WriteFixedByteArray(BinaryEncoding.Instance.GetBytes(str), fixed_count);\n        }\n\n        public void WriteVaryingString(string str)\n        {\n            if (str == null)\n            {\n                return;\n            }\n\n            char[] values = (str + \'\\0\').ToCharArray();\n            // Offset.\n            WriteInt32(0);\n            // Actual count.\n            WriteInt32(values.Length);\n            WriteChars(values);\n        }\n\n        public void WriteVaryingAnsiString(string str)\n        {\n            if (str == null)\n            {\n                return;\n            }\n\n            byte[] values = BinaryEncoding.Instance.GetBytes(str + \'\\0\');\n            // Offset.\n            WriteInt32(0);\n            // Actual count.\n            WriteInt32(values.Length);\n            WriteBytes(values);\n        }\n\n        #endregion\n\n        #region Structure Types\n\n        public void WriteGuid(Guid guid)\n        {\n            Align(4);\n            WriteBytes(guid.ToByteArray());\n        }\n\n        public void WriteGuid(Guid? guid)\n        {\n            if (guid.HasValue)\n            {\n                WriteGuid(guid.Value);\n            }\n        }\n\n        public void WriteStruct<T>(T? structure) where T : struct, INdrStructure\n        {\n            if (structure.HasValue)\n            {\n                WriteStruct(structure.Value);\n            }\n        }\n\n        public void WriteStruct<T>(T structure) where T : struct, INdrStructure\n        {\n            WriteStruct((INdrStructure)structure);\n        }\n\n        public void WriteStruct(INdrStructure structure)\n        {\n            bool conformant = false;\n            if (structure is INdrConformantStructure conformant_structure)\n            {\n                conformant = SetupConformance(conformant_structure.GetConformantDimensions());\n                System.Diagnostics.Debug.Assert(_conformance_position.HasValue);\n            }\n\n            using (var queue = _deferred_writes.Push())\n            {\n                WriteStructInternal(structure);\n            }\n\n            if (conformant)\n            {\n                System.Diagnostics.Debug.Assert(!_conformance_position.HasValue);\n            }\n        }\n\n        public void WriteUnion<T>(T? union, long selector) where T : struct, INdrNonEncapsulatedUnion\n        {\n            if (union.HasValue)\n            {\n                WriteUnion((INdrNonEncapsulatedUnion)union.Value, selector);\n            }\n        }\n\n        public void WriteUnion<T>(T union, long selector) where T : struct, INdrNonEncapsulatedUnion\n        {\n            WriteUnion((INdrNonEncapsulatedUnion)union, selector);\n        }\n\n        public void WriteUnion(INdrNonEncapsulatedUnion union, long selector)\n        {\n            WriteUnionInternal(union, selector);\n        }\n\n        public void WriteContextHandle(NdrContextHandle handle)\n        {\n            WriteInt32(handle.Attributes);\n            WriteGuid(handle.Uuid);\n        }\n\n        #endregion\n\n        #region Pointer Types\n        public void WriteEmbeddedPointer<T>(NdrEmbeddedPointer<T> pointer, Action<T> writer)\n        {\n             WriteEmbeddedPointer(pointer, () => writer(pointer));\n        }\n\n        public void WriteEmbeddedPointer<T, U>(NdrEmbeddedPointer<T> pointer, Action<T, U> writer, U arg)\n        {\n            WriteEmbeddedPointer(pointer, () => writer(pointer, arg));\n        }\n\n        public void WriteEmbeddedPointer<T, U, V>(NdrEmbeddedPointer<T> pointer, Action<T, U, V> writer, U arg, V arg2)\n        {\n            WriteEmbeddedPointer(pointer, () => writer(pointer, arg, arg2));\n        }\n\n        public void WriteReferent<T>(T obj, Action<T> writer) where T : class\n        {\n            if (WriteReferent(obj))\n            {\n                writer(obj);\n            }\n        }\n\n        public void WriteReferent<T, U>(T obj, Action<T, U> writer, U arg) where T : class\n        {\n            if (WriteReferent(obj))\n            {\n                writer(obj, arg);\n            }\n        }\n\n        public void WriteReferent<T, U, V>(T obj, Action<T, U, V> writer, U arg, V arg2) where T : class\n        {\n            if (WriteReferent(obj))\n            {\n                writer(obj, arg, arg2);\n            }\n        }\n\n        public void WriteReferent<T>(T? obj, Action<T> writer) where T : struct\n        {\n            if (WriteReferent(obj))\n            {\n                writer(obj.Value);\n            }\n        }\n\n        public void WriteReferent<T, U>(T? obj, Action<T, U> writer, U arg) where T : struct\n        {\n            if (WriteReferent(obj))\n            {\n                writer(obj.Value, arg);\n            }\n        }\n\n        public void WriteReferent<T, U, V>(T? obj, Action<T, U, V> writer, U arg, V arg2) where T : struct\n        {\n            if (WriteReferent(obj))\n            {\n                writer(obj.Value, arg, arg2);\n            }\n        }\n\n        #endregion\n\n        #region Fixed Array Types\n        public void WriteBytes(byte[] array)\n        {\n            _writer.Write(array);\n        }\n\n        public void WriteChars(char[] chars)\n        {\n            Align(2);\n            _writer.Write(chars);\n        }\n\n        public void WriteFixedByteArray(byte[] array, int actual_count)\n        {\n            if (array.Length != actual_count)\n            {\n                array = (byte[])array.Clone();\n                Array.Resize(ref array, actual_count);\n            }\n            _writer.Write(array);\n        }\n\n        public void WriteFixedChars(char[] chars, int fixed_count)\n        {\n            Align(2);\n            if (chars.Length != fixed_count)\n            {\n                chars = (char[])chars.Clone();\n                Array.Resize(ref chars, fixed_count);\n            }\n            _writer.Write(chars);\n        }\n\n        public void WriteFixedPrimitiveArray<T>(T[] array, int fixed_count) where T : struct\n        {\n            int size = NdrNativeUtils.GetPrimitiveTypeSize<T>();\n            int actual_size = array.Length * size;\n            byte[] total_buffer = new byte[size * fixed_count];\n            Buffer.BlockCopy(array, 0, total_buffer, 0, Math.Min(actual_size, total_buffer.Length));\n            Align(size);\n            WriteFixedByteArray(total_buffer, total_buffer.Length);\n        }\n\n        public void WriteFixedStructArray<T>(T[] arr, int actual_count) where T : INdrStructure, new()\n        {\n            using (var queue = _deferred_writes.Push())\n            {\n                for (int i = 0; i < actual_count; ++i)\n                {\n                    if (i < arr.Length)\n                    {\n                        WriteStructInternal(arr[i]);\n                    }\n                    else\n                    {\n                        WriteStructInternal(new T());\n                    }\n                }\n            }\n        }\n\n        #endregion\n\n        #region Varying Array Types\n\n        public void WriteVaryingByteArray(byte[] array, long variance)\n        {\n            // Offset.\n            WriteInt32(0);\n            int var_int = (int)variance;\n            if (var_int < 0)\n            {\n                var_int = array.Length;\n            }\n            // Actual Count\n            WriteInt32(var_int);\n            Array.Resize(ref array, var_int);\n            WriteBytes(array);\n        }\n\n        public void WriteVaryingCharArray(char[] array, long variance)\n        {\n            // Offset.\n            WriteInt32(0);\n            int var_int = (int)variance;\n            if (var_int < 0)\n            {\n                var_int = array.Length;\n            }\n            // Actual Count\n            WriteInt32(var_int);\n            Array.Resize(ref array, var_int);\n            WriteChars(array);\n        }\n\n        public void WriteVaryingPrimitiveArray<T>(T[] array, long variance) where T : struct\n        {\n            WriteInt32(0);\n            int var_int = (int)variance;\n            if (var_int < 0)\n            {\n                var_int = array.Length;\n            }\n            // Actual Count\n            WriteInt32(var_int);\n            WriteFixedPrimitiveArray<T>(array, var_int);\n        }\n    \n        public void WriteVaryingStructArray<T>(T[] array, long variance) where T : struct, INdrStructure\n        {\n            using (var queue = _deferred_writes.Push())\n            {\n                WriteVaryingArrayCallback(array, t => WriteStructInternal(t), variance);\n            }\n        }\n\n        public void WriteVaryingArray<T>(T[] array, long variance) where T : struct\n        {\n            if (typeof(T) == typeof(byte))\n            {\n                WriteVaryingByteArray(array.Cast<T, byte>(), variance);\n            }\n            else if (typeof(T) == typeof(char))\n            {\n                WriteVaryingCharArray(array.Cast<T, char>(), variance);\n            }\n            else if (typeof(T) == typeof(INdrStructure))\n            {\n                using (var queue = _deferred_writes.Push())\n                {\n                    WriteVaryingArrayCallback(array, p => WriteStructInternal((INdrStructure)p), variance);\n                }\n            }\n            else if (typeof(T).IsPrimitive)\n            {\n                WriteVaryingPrimitiveArray(array, variance);\n            }\n            else\n            {\n                throw new ArgumentException($"Invalid type {typeof(T)} for {nameof(WriteVaryingArray)}");\n            }\n        }\n\n        public void WriteVaryingArrayCallback<T>(T[] array, Action<T> writer, long variance)\n        {\n            // Offset.\n            WriteInt32(0);\n            if (array == null)\n            {\n                array = new T[0];\n            }\n            int var_int = (int)variance;\n            if (var_int < 0)\n            {\n                var_int = array.Length;\n            }\n            // Actual Count\n            WriteInt32(var_int);\n            for (int i = 0; i < var_int; ++i)\n            {\n                if (i < array.Length)\n                {\n                    writer(array[i]);\n                }\n                else\n                {\n                    writer(default);\n                }\n            }\n        }\n\n        public void WriteVaryingStringArray(string[] array, Action<string> writer, long variance)\n        {\n            // Offset.\n            WriteInt32(0);\n            // Actual Count\n            int var_int = (int)variance;\n            if (var_int < 0)\n            {\n                var_int = array.Length;\n            }\n            WriteInt32(var_int);\n            using (var queue = _deferred_writes.Push())\n            {\n                WriteStringArray(array, writer, (int)variance);\n            }\n        }\n\n        #endregion\n\n        #region Conformant Array Types\n\n        public void WriteConformantByteArray(byte[] array, long conformance)\n        {\n            int var_int = (int)conformance;\n            if (var_int < 0)\n            {\n                var_int = array.Length;\n            }\n            // Max Count\n            WriteConformance(var_int);\n            Array.Resize(ref array, var_int);\n            WriteBytes(array);\n        }\n\n        public void WriteConformantCharArray(char[] array, long conformance)\n        {\n            int var_int = (int)conformance;\n            if (var_int < 0)\n            {\n                var_int = array.Length;\n            }\n            // Max Count\n            WriteConformance(var_int);\n            Array.Resize(ref array, var_int);\n            WriteChars(array);\n        }\n\n        public void WriteConformantPrimitiveArray<T>(T[] array, long conformance) where T : struct\n        {\n            int var_int = (int)conformance;\n            if (var_int < 0)\n            {\n                var_int = array.Length;\n            }\n            // Max Count\n            WriteConformance(var_int);\n            WriteFixedPrimitiveArray<T>(array, var_int);\n        }\n\n        public void WriteConformantStructArray<T>(T[] array, long conformance) where T : struct, INdrStructure\n        {\n            using (var queue = _deferred_writes.Push())\n            {\n                WriteConformantArrayCallback(array, t => WriteStructInternal(t), conformance);\n            }\n        }\n\n        public void WriteConformantStringArray(string[] array, Action<string> writer, long conformance)\n        {\n            int var_int = (int)conformance;\n            if (var_int < 0)\n            {\n                var_int = array.Length;\n            }\n            // Max Count\n            WriteConformance(var_int);\n            using (var queue = _deferred_writes.Push())\n            {\n                WriteStringArray(array, writer, var_int);\n            }\n        }\n\n        public void WriteConformantArrayCallback<T>(T[] array, Action<T> writer, long conformance)\n        {\n            // Max Count\n            if (array == null)\n            {\n                array = new T[0];\n            }\n            int var_int = (int)conformance;\n            if (var_int < 0)\n            {\n                var_int = array.Length;\n            }\n            WriteConformance(var_int);\n\n            for (int i = 0; i < var_int; ++i)\n            {\n                if (i < array.Length)\n                {\n                    writer(array[i]);\n                }\n                else\n                {\n                    writer(default);\n                }\n            }\n        }\n\n        public void WriteConformantArray<T>(T[] array, long conformance) where T : struct\n        {\n            if (typeof(T) == typeof(byte))\n            {\n                WriteConformantByteArray(array.Cast<T, byte>(), conformance);\n            }\n            else if (typeof(T) == typeof(char))\n            {\n                WriteConformantCharArray(array.Cast<T, char>(), conformance);\n            }\n            else if (typeof(T) == typeof(INdrStructure))\n            {\n                using (var queue = _deferred_writes.Push())\n                {\n                    WriteConformantArrayCallback(array, p => WriteStructInternal((INdrStructure)p), conformance);\n                }\n            }\n            else if (typeof(T).IsPrimitive)\n            {\n                WriteConformantPrimitiveArray(array, conformance);\n            }\n            else\n            {\n                throw new ArgumentException($"Invalid type {typeof(T)} for {nameof(WriteConformantArray)}");\n            }\n        }\n\n        #endregion\n\n        #region Conformant Varying Array Types\n\n        public void WriteConformantVaryingByteArray(byte[] array, long conformance, long variance)\n        {\n            // Max Count\n            int con_int = (int)conformance;\n            if (con_int < 0)\n            {\n                con_int = array.Length;\n            }\n            WriteConformance(con_int);\n            WriteVaryingByteArray(array, variance);\n        }\n\n        public void WriteConformantVaryingCharArray(char[] array, long conformance, long variance)\n        {\n            // Max Count\n            int con_int = (int)conformance;\n            if (con_int < 0)\n            {\n                con_int = array.Length;\n            }\n            WriteConformance(con_int);\n            WriteVaryingCharArray(array, variance);\n        }\n\n        public void WriteConformantVaryingPrimitiveArray<T>(T[] array, long conformance, long variance) where T : struct\n        {\n            // Max Count\n            int con_int = (int)conformance;\n            if (con_int < 0)\n            {\n                con_int = array.Length;\n            }\n            WriteConformance(con_int);\n            WriteVaryingPrimitiveArray(array, variance);\n        }\n\n        public void WriteConformantVaryingStructArray<T>(T[] array, long conformance, long variance) where T : struct, INdrStructure\n        {\n            using (var queue = _deferred_writes.Push())\n            {\n                WriteVaryingArrayCallback(array, t => WriteStructInternal(t), variance);\n            }\n        }\n\n        public void WriteConformantVaryingStringArray(string[] array, Action<string> writer, long conformance, long variance)\n        {\n            // Max Count\n            int con_int = (int)conformance;\n            if (con_int < 0)\n            {\n                con_int = array.Length;\n            }\n            WriteConformance(con_int);\n            using (var queue = _deferred_writes.Push())\n            {\n                WriteVaryingStringArray(array, writer, (int)variance);\n            }\n        }\n\n        public void WriteConformantVaryingArrayCallback<T>(T[] array, Action<T> writer, long conformance, long variance)\n        {\n            // Max Count\n            int con_int = (int)conformance;\n            if (con_int < 0)\n            {\n                con_int = array.Length;\n            }\n            WriteConformance(con_int);\n            WriteVaryingArrayCallback(array, writer, variance);\n        }\n\n        public void WriteConformantVaryingArray<T>(T[] array, long conformance, long variance) where T : struct\n        {\n            if (typeof(T) == typeof(byte))\n            {\n                WriteConformantVaryingByteArray(array.Cast<T, byte>(), conformance, variance);\n            }\n            else if (typeof(T) == typeof(char))\n            {\n                WriteConformantVaryingCharArray(array.Cast<T, char>(), conformance, variance);\n            }\n            else if (typeof(T) == typeof(INdrStructure))\n            {\n                using (var queue = _deferred_writes.Push())\n                {\n                    WriteConformantVaryingArrayCallback(array, p => WriteStructInternal((INdrStructure)p), conformance, variance);\n                }\n            }\n            else if (typeof(T).IsPrimitive)\n            {\n                WriteConformantVaryingPrimitiveArray(array, conformance, variance);\n            }\n            else\n            {\n                throw new ArgumentException($"Invalid type {typeof(T)} for {nameof(WriteConformantVaryingArray)}");\n            }\n        }\n\n        #endregion\n\n        #region Public Properties\n\n        public NdrDataRepresentation DataRepresentation { get; }\n\n        #endregion\n    }\n#pragma warning restore 1591\n}\n'