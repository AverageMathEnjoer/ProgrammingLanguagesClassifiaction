b'#include <bits/stdc++.h>\nusing namespace std;\n#define gc getchar_unlocked\n#define fo(i,n) for(i=0;i<n;i++)\n#define Fo(i,k,n) for(i=k;i<n;i++)\n#define ll long long\n#define si(x)\tscanf("%d",&x)\n#define sl(x)\tscanf("%I64d",&x)\n#define ss(s)\tscanf("%s",s)\n#define pb push_back\n#define mp make_pair\n#define F first\n#define S second\n#define clr(x) memset(x, 0, sizeof(x))\n#define tr(it, a) for(auto it = a.begin(); it != a.end(); it++)\n#define PI 3.1415926535897932384626\ntypedef pair<int, int>\tpii;\ntypedef pair<ll, ll>\tpll;\ntypedef vector<int>\t\tvi;\ntypedef vector<ll>\t\tvl;\ntypedef vector<pii>\t\tvpii;\ntypedef vector<pll>\t\tvpll;\ntypedef vector<vi>\t\tvvi;\ntypedef vector<vl>\t\tvvl;\nconst int mod = 1000000007;\nconst int N = 2e5;\nvi g[N];\nconst int LG = 20;\n//LCA begins\n//1 based index\nint a[N], lvl[N], P[N][LG];\nvoid dfs(int u, int par){\n    lvl[u] = 1+lvl[par];\n    P[u][0] = par;\n\tfor(int v:g[u]){\n\t\tif (v == par) continue;\n\t\tdfs(v, u);\n\t}\n}\n\nint lca(int u, int v){\n    int i, lg;\n    if (lvl[u] < lvl[v]) swap(u, v);\n\n    for(lg = 0; (1<<lg) <= lvl[u]; lg++);\n    lg--;\n\n    for(i=lg; i>=0; i--){\n        if (lvl[u] - (1<<i) >= lvl[v])\n            u = P[u][i];\n    }\n\n    if (u == v) \n    \treturn u;\n\n    for(i=lg; i>=0; i--){\n        if (P[u][i] != -1 and P[u][i] != P[v][i])\n            u = P[u][i], v = P[v][i];\n    }\n\n    return P[u][0];\n}\n\n//Get the ancestor of node "u"\n//which is "dis" distance above.\nint getAncestor(int u, int dis){\n    dis = lvl[u] - dis;\n    int i, lg = 0;\n    for(; (1<<lg) <= lvl[u]; lg++); lg--;\n\n    for(i=lg; i>=0; i--){\n        if (lvl[u] - (1<<i) >= dis)\n            u = P[u][i];\n    }\n\n    return u;\n}\n\n//returns the distance between\n//two nodes "u" and "v".\nint dis(int u, int v){\n    if (lvl[u] < lvl[v]) swap(u, v);\n    int w = lca(u, v);\n    return lvl[u] + lvl[v] - 2*lvl[w];\n}\n\nint main()\n{\n\tios_base::sync_with_stdio(false);\n\tcin.tie(NULL);\n\tint i, n, q, m, j;\n\tint u, v;\n\tcin >> n >> m;\n\tfo(i, n-1){\n            cin>>u>>v;\n            g[u].pb(v);\n            g[v].pb(u);\n\t}\n\n\tfo(i, LG) fo(j, n+1) P[j][i] = -1;\n\tlvl[0] = -1;\n\n\tdfs(1, 0);\n\n\tfor(i=1; i<LG; i++){\n        Fo(j, 1, n+1)\n            if (P[j][i-1] != -1)\n                P[j][i] = P[P[j][i-1]][i-1];\n\t}\n\n\treturn 0;\n}\n\n'