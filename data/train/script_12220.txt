b'{-# LANGUAGE CPP #-}\nmodule LookupGE_IntMap where\n\nimport Prelude hiding (null)\nimport Data.IntMap.Internal\n\nlookupGE1 :: Key -> IntMap a -> Maybe (Key,a)\nlookupGE1 k m =\n    case splitLookup k m of\n        (_,Just v,_)  -> Just (k,v)\n        (_,Nothing,r) -> findMinMaybe r\n\nlookupGE2 :: Key -> IntMap a -> Maybe (Key,a)\nlookupGE2 k t = case t of\n    Bin _ m l r | m < 0 -> if k >= 0\n      then go l\n      else case go r of\n        Nothing -> Just $ findMin l\n        justx -> justx\n    _ -> go t\n  where\n    go (Bin p m l r)\n      | nomatch k p m = if k < p\n        then Just $ findMin l\n        else Nothing\n      | zero k m = case go l of\n        Nothing -> Just $ findMin r\n        justx -> justx\n      | otherwise = go r\n    go (Tip ky y)\n      | k > ky = Nothing\n      | otherwise = Just (ky, y)\n    go Nil = Nothing\n\nlookupGE3 :: Key -> IntMap a -> Maybe (Key,a)\nlookupGE3 k t = k `seq` case t of\n    Bin _ m l r | m < 0 -> if k >= 0\n      then go Nothing l\n      else go (Just (findMin l)) r\n    _ -> go Nothing t\n  where\n    go def (Bin p m l r)\n      | nomatch k p m = if k < p then Just $ findMin l else def\n      | zero k m  = go (Just $ findMin r) l\n      | otherwise = go def r\n    go def (Tip ky y)\n      | k > ky    = def\n      | otherwise = Just (ky, y)\n    go def Nil  = def\n\nlookupGE4 :: Key -> IntMap a -> Maybe (Key,a)\nlookupGE4 k t = k `seq` case t of\n    Bin _ m l r | m < 0 -> if k >= 0 then go Nil l\n                                     else go l r\n    _ -> go Nil t\n  where\n    go def (Bin p m l r)\n      | nomatch k p m = if k < p then fMin l else fMin def\n      | zero k m  = go r l\n      | otherwise = go def r\n    go def (Tip ky y)\n      | k > ky    = fMin def\n      | otherwise = Just (ky, y)\n    go def Nil  = fMin def\n\n    fMin :: IntMap a -> Maybe (Key, a)\n    fMin Nil = Nothing\n    fMin (Tip ky y) = Just (ky, y)\n    fMin (Bin _ _ l _) = fMin l\n\n-------------------------------------------------------------------------------\n-- Utilities\n-------------------------------------------------------------------------------\n\n-- | \\(O(\\log n)\\). The minimal key of the map.\nfindMinMaybe :: IntMap a -> Maybe (Key, a)\nfindMinMaybe m\n  | null m = Nothing\n  | otherwise = Just (findMin m)\n\n#ifdef TESTING\n-------------------------------------------------------------------------------\n-- Properties:\n-------------------------------------------------------------------------------\n\nprop_lookupGE12 :: Int -> [Int] -> Bool\nprop_lookupGE12 x xs = case fromList $ zip xs xs of m -> lookupGE1 x m == lookupGE2 x m\n\nprop_lookupGE13 :: Int -> [Int] -> Bool\nprop_lookupGE13 x xs = case fromList $ zip xs xs of m -> lookupGE1 x m == lookupGE3 x m\n\nprop_lookupGE14 :: Int -> [Int] -> Bool\nprop_lookupGE14 x xs = case fromList $ zip xs xs of m -> lookupGE1 x m == lookupGE4 x m\n#endif\n'