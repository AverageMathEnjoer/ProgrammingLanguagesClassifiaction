b'{-# LANGUAGE ScopedTypeVariables #-}\n\nmodule Hoodle.Coroutine.Layer where\n\nimport Control.Category (id, (.))\nimport Control.Lens (set, view)\nimport Control.Monad.State (get, liftIO, modify)\nimport Data.Hoodle.Generic (glayers)\nimport Data.Hoodle.Zipper\n  ( appendGoLast,\n    currIndex,\n    deleteCurrent,\n    lengthSZ,\n    moveLeft,\n    moveRight,\n    moveTo,\n  )\nimport Data.IORef (newIORef, readIORef)\nimport qualified Data.IntMap as M\nimport Graphics.Hoodle.Render.Type\n  ( emptyRLayer,\n    hPage2RPage,\n    issueSurfaceID,\n  )\nimport qualified Graphics.UI.Gtk as Gtk\nimport Hoodle.Accessor (getCurrentPageEitherFromHoodleModeState)\nimport Hoodle.Coroutine.Commit (commit)\nimport Hoodle.Coroutine.Draw (invalidateAll)\nimport Hoodle.ModelAction.Layer (layerChooseDialog)\nimport Hoodle.ModelAction.Page (getPageMap, setPageMap, updatePageAll)\nimport Hoodle.Type.Alias (EditMode, Page)\nimport Hoodle.Type.Canvas\n  ( currentPageNum,\n    forBoth\',\n    unboxBiAct,\n  )\nimport Hoodle.Type.Coroutine (MainCoroutine)\nimport Hoodle.Type.HoodleState\n  ( HoodleModeState,\n    UnitHoodle,\n    currentCanvasInfo,\n    currentUnit,\n    hoodleModeState,\n    unitHoodles,\n  )\n--\nimport Prelude hiding (id, (.))\n\nlayerAction ::\n  (HoodleModeState -> Int -> Page EditMode -> MainCoroutine HoodleModeState) ->\n  MainCoroutine UnitHoodle\nlayerAction action = do\n  xst <- get\n  forBoth\' unboxBiAct (fsingle xst) . view (unitHoodles . currentUnit . currentCanvasInfo) $ xst\n  where\n    fsingle xstate cvsInfo = do\n      let uhdl = view (unitHoodles . currentUnit) xstate\n          epage = getCurrentPageEitherFromHoodleModeState cvsInfo hdlmodst\n          cpn = view currentPageNum cvsInfo\n          hdlmodst = view hoodleModeState uhdl\n      newhdlmodst <- either (action hdlmodst cpn) (action hdlmodst cpn . hPage2RPage) epage\n      liftIO (updatePageAll newhdlmodst . set hoodleModeState newhdlmodst $ uhdl)\n\n-- |\nmakeNewLayer :: MainCoroutine ()\nmakeNewLayer = do\n  xst <- get\n  commit . flip (set (unitHoodles . currentUnit)) xst =<< layerAction newlayeraction\n  invalidateAll\n  where\n    newlayeraction hdlmodst cpn page = do\n      sfcid <- issueSurfaceID\n      let lyrzipper = view glayers page\n          emptylyr = emptyRLayer sfcid\n          nlyrzipper = appendGoLast lyrzipper emptylyr\n          npage = set glayers nlyrzipper page\n      return . setPageMap (M.adjust (const npage) cpn . getPageMap $ hdlmodst) $ hdlmodst\n\ngotoNextLayer :: MainCoroutine ()\ngotoNextLayer = do\n  modify . set (unitHoodles . currentUnit) =<< layerAction nextlayeraction\n  invalidateAll\n  where\n    nextlayeraction hdlmodst cpn page = do\n      let lyrzipper = view glayers page\n          mlyrzipper = moveRight lyrzipper\n          npage = maybe page (\\x -> set glayers x page) mlyrzipper\n      return . setPageMap (M.adjust (const npage) cpn . getPageMap $ hdlmodst) $ hdlmodst\n\ngotoPrevLayer :: MainCoroutine ()\ngotoPrevLayer = do\n  modify . set (unitHoodles . currentUnit) =<< layerAction prevlayeraction\n  invalidateAll\n  where\n    prevlayeraction hdlmodst cpn page = do\n      let lyrzipper = view glayers page\n          mlyrzipper = moveLeft lyrzipper\n          npage = maybe page (\\x -> set glayers x page) mlyrzipper\n      return . setPageMap (M.adjust (const npage) cpn . getPageMap $ hdlmodst) $ hdlmodst\n\ngotoLayerAt :: Int -> MainCoroutine ()\ngotoLayerAt n = do\n  modify . set (unitHoodles . currentUnit) =<< layerAction gotoaction\n  invalidateAll\n  where\n    gotoaction hdlmodst cpn page = do\n      let lyrzipper = view glayers page\n          mlyrzipper = moveTo n lyrzipper\n          npage = maybe page (\\x -> set glayers x page) mlyrzipper\n      return . setPageMap (M.adjust (const npage) cpn . getPageMap $ hdlmodst) $ hdlmodst\n\ndeleteCurrentLayer :: MainCoroutine ()\ndeleteCurrentLayer = do\n  xst <- get\n  commit . flip (set (unitHoodles . currentUnit)) xst =<< layerAction deletelayeraction\n  invalidateAll\n  where\n    deletelayeraction hdlmodst cpn page = do\n      let lyrzipper = view glayers page\n          mlyrzipper = deleteCurrent lyrzipper\n          npage = maybe page (\\x -> set glayers x page) mlyrzipper\n      return . setPageMap (M.adjust (const npage) cpn . getPageMap $ hdlmodst) $ hdlmodst\n\nstartGotoLayerAt :: MainCoroutine ()\nstartGotoLayerAt =\n  forBoth\' unboxBiAct fsingle . view (unitHoodles . currentUnit . currentCanvasInfo) =<< get\n  where\n    fsingle cvsInfo = do\n      xstate <- get\n      let uhdl = view (unitHoodles . currentUnit) xstate\n          hdlmodst = view hoodleModeState uhdl\n          epage = getCurrentPageEitherFromHoodleModeState cvsInfo hdlmodst\n          page = either id hPage2RPage epage\n          lyrzipper = view glayers page\n          cidx = currIndex lyrzipper\n          len = lengthSZ lyrzipper\n      lref <- liftIO $ newIORef cidx\n      dialog <- liftIO (layerChooseDialog lref cidx len)\n      res <- liftIO $ Gtk.dialogRun dialog\n      case res of\n        Gtk.ResponseDeleteEvent -> liftIO $ Gtk.widgetDestroy dialog\n        Gtk.ResponseOk -> do\n          liftIO $ Gtk.widgetDestroy dialog\n          newnum <- liftIO (readIORef lref)\n          gotoLayerAt newnum\n        Gtk.ResponseCancel -> liftIO $ Gtk.widgetDestroy dialog\n        _ -> error "??? in fileOpen "\n      return ()\n'