b'-- % cabal install memoize\n-- % cabal install hspec\n-- % runghc <this_file>\n\nimport Data.Function.Memoize\nimport Test.Hspec\n\n----------------------------------------------------------------\n\nmain :: IO ()\nmain = hspec $ do\n    describe "my_fib_memo" $\n        it "calculates the same results of model" $ do\n            let xs = [1..100]\n            map my_fib_memo xs `shouldBe` map fibModel xs\n    describe "my_catalan_memo" $\n        it "calculates the same results of formula" $ do\n            let xs = [1..100]\n            map my_catalan_memo xs `shouldBe` map catalanFormula xs\n    describe "my_catalan2_memo" $\n        it "calculates the same results of formula" $ do\n            let xs = [1..100]\n            map my_catalan2_memo xs `shouldBe` map catalanFormula xs\n    describe "my_coin_memo" $ do\n        it "calculates the same results of America coins " $ do\n            let xs = [1..10000]\n            map (`my_coin_memo` [1,5,10,25,50]) xs `shouldBe` map usCoinMemo xs\n        it "calculates the same results of Japanese coins " $ do\n            let xs = [1..10000]\n            map (`my_coin_memo` [1,5,10,50,100,500]) xs `shouldBe` map jaCoinMemo xs\n----------------------------------------------------------------\n\nfibModel :: Integer -> Integer\nfibModel n = fibs !! fromInteger n\n\nfibs :: [Integer]\nfibs = 0 : 1 : zipWith (+) fibs (tail fibs)\n\ncatalanFormula :: Integer -> Integer\ncatalanFormula n = bang (2 * n) `div` bang (n + 1) `div` bang n\n  where\n    bang x = product [1..x]\n\n----------------------------------------------------------------\n\nusCoinMemo :: Integer -> Integer\nusCoinMemo = usCoinMemoE\n\nusCoinMemoA :: Integer -> Integer\nusCoinMemoA _ = 1\nusCoinMemoB :: Integer -> Integer\nusCoinMemoB = memoize g\n  where\n    g n | n < 0     = 0\n        | otherwise = usCoinMemoA n + usCoinMemoB (n-5)\nusCoinMemoC :: Integer -> Integer\nusCoinMemoC  = memoize g\n  where\n    g n | n < 0     = 0\n        | otherwise = usCoinMemoB n + usCoinMemoC (n-10)\nusCoinMemoD :: Integer -> Integer\nusCoinMemoD  = memoize g\n  where\n    g n | n < 0     = 0\n        | otherwise = usCoinMemoC n + usCoinMemoD (n-25)\nusCoinMemoE :: Integer -> Integer\nusCoinMemoE  = memoize g\n  where\n    g n | n < 0     = 0\n        | otherwise = usCoinMemoD n + usCoinMemoE (n-50)\n\n----------------------------------------------------------------\n\njaCoinMemo :: Integer -> Integer\njaCoinMemo = jaCoinMemoF\n\njaCoinMemoA :: Integer -> Integer\njaCoinMemoA _ = 1\njaCoinMemoB :: Integer -> Integer\njaCoinMemoB = memoize g\n  where\n    g n | n < 0     = 0\n        | otherwise = jaCoinMemoA n + jaCoinMemoB (n-5)\njaCoinMemoC :: Integer -> Integer\njaCoinMemoC  = memoize g\n  where\n    g n | n < 0     = 0\n        | otherwise = jaCoinMemoB n + jaCoinMemoC (n-10)\njaCoinMemoD :: Integer -> Integer\njaCoinMemoD  = memoize g\n  where\n    g n | n < 0     = 0\n        | otherwise = jaCoinMemoC n + jaCoinMemoD (n-50)\njaCoinMemoE :: Integer -> Integer\njaCoinMemoE  = memoize g\n  where\n    g n | n < 0     = 0\n        | otherwise = jaCoinMemoD n + jaCoinMemoE (n-100)\n\njaCoinMemoF :: Integer -> Integer\njaCoinMemoF  = memoize g\n  where\n    g n | n < 0     = 0\n        | otherwise = jaCoinMemoE n + jaCoinMemoF (n-500)\n\n----------------------------------------------------------------\n\nmy_fib_memo :: Integer -> Integer\nmy_fib_memo = memoize my_fib\n\nmy_fib :: Integer -> Integer\nmy_fib 0 = 0\nmy_fib 1 = 1\nmy_fib n = my_fib_memo (n - 2) + my_fib_memo (n - 1)\n\n----------------------------------------------------------------\n\n{-\nmy_catalan :: Integer -> Integer\nmy_catalan x = my_cat x x\n\nmy_cat :: Integer -> Integer -> Integer\nmy_cat _ 0 = 1\nmy_cat m n\n  | m == n    = my_cat m (n - 1)\n  | otherwise = my_cat m (n - 1) + my_cat (m - 1) n\n-}\n\nmy_catalan_memo :: Integer -> Integer\nmy_catalan_memo n = my_cat_memo n n\n\nmy_cat_memo :: Integer -> Integer -> Integer\nmy_cat_memo = undefined\n\nmy_cat :: Integer -> Integer -> Integer\nmy_cat = undefined\n\n----------------------------------------------------------------\n\n{-\nmy_catalan2 :: Integer -> Integer\nmy_catalan2 0 = 1\nmy_catalan2 n = sum (zipWith (*) xs ys)\n  where\n    xs = map my_catalan2 [0 .. n - 1]\n    ys = map my_catalan2 [n - 1, n - 2 .. 0]\n-}\n\nmy_catalan2_memo :: Integer -> Integer\nmy_catalan2_memo = undefined\n\nmy_catalan2 :: Integer -> Integer\nmy_catalan2 = undefined\n\n----------------------------------------------------------------\n\n{-\nmy_coin :: Integer -> [Integer] -> Integer\nmy_coin 0 _   = 1\nmy_coin _ []  = 0\nmy_coin n (c:cs)\n  | n < 0     = 0\n  | otherwise = my_coin n cs + my_coin (n - c) (c:cs)\n-}\n\nmy_coin_memo :: Integer -> [Integer] -> Integer\nmy_coin_memo = undefined\n\nmy_coin :: Integer -> [Integer] -> Integer\nmy_coin = undefined\n'