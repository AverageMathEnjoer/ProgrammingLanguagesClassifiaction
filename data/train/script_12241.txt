b'using System;\nusing System.ComponentModel;\nusing System.DirectoryServices;\nusing System.DirectoryServices.Protocols;\nusing System.Runtime.InteropServices;\nusing System.Text.RegularExpressions;\nusing System.Collections.Generic;\nusing System.Threading;\nusing SearchScope = System.DirectoryServices.Protocols.SearchScope;\nusing System.IO;\nusing System.Linq;\n\nnamespace Rubeus\n{\n    public class Networking\n    {\n        public static string GetDCName(string domainName = "")\n        {\n            // retrieves the current domain controller name\n\n            // adapted from https://www.pinvoke.net/default.aspx/netapi32.dsgetdcname\n            Interop.DOMAIN_CONTROLLER_INFO domainInfo;\n            const int ERROR_SUCCESS = 0;\n            IntPtr pDCI = IntPtr.Zero;\n\n            int val = Interop.DsGetDcName("", domainName, 0, "",\n                Interop.DSGETDCNAME_FLAGS.DS_DIRECTORY_SERVICE_REQUIRED |\n                Interop.DSGETDCNAME_FLAGS.DS_RETURN_DNS_NAME |\n                Interop.DSGETDCNAME_FLAGS.DS_IP_REQUIRED, out pDCI);\n\n            if (ERROR_SUCCESS == val) {\n                domainInfo = (Interop.DOMAIN_CONTROLLER_INFO)Marshal.PtrToStructure(pDCI, typeof(Interop.DOMAIN_CONTROLLER_INFO));\n                string dcName = domainInfo.DomainControllerName;\n                Interop.NetApiBufferFree(pDCI);\n                return dcName.Trim(\'\\\\\');\n            }\n            else {\n                try {\n                    string pdc = System.DirectoryServices.ActiveDirectory.Domain.GetCurrentDomain().PdcRoleOwner.Name;\n                    return pdc;\n                }\n                catch {\n                    string errorMessage = new Win32Exception((int)val).Message;\n                    Console.WriteLine("\\r\\n [X] Error {0} retrieving domain controller : {1}", val, errorMessage);\n                    Interop.NetApiBufferFree(pDCI);\n                    return "";\n                }\n            }\n        }\n\n        public static string GetDCIP(string DCName, bool display = true, string domainName = "")\n        {\n            if (String.IsNullOrEmpty(DCName))\n            {\n                DCName = GetDCName(domainName);\n            }\n            Match match = Regex.Match(DCName, @"([0-9A-Fa-f]{1,4}:){7}[0-9A-Fa-f]{1,4}|(\\d{1,3}\\.){3}\\d{1,3}");\n            if (match.Success)\n            {\n                if (display)\n                {\n                    Console.WriteLine("[*] Using domain controller: {0}", DCName);\n                }\n                return DCName;\n            }\n            else\n            {\n                try\n                {\n                    // If we call GetHostAddresses with an empty string, it will return IP addresses for localhost instead of DC\n                    if (String.IsNullOrEmpty(DCName)) \n                    {\n                        Console.WriteLine("[X] Error: No domain controller could be located");\n                        return null;\n                    }\n                    System.Net.IPAddress[] dcIPs = System.Net.Dns.GetHostAddresses(DCName);\n\n                    foreach (System.Net.IPAddress dcIP in dcIPs)\n                    {\n                        if (dcIP.AddressFamily == System.Net.Sockets.AddressFamily.InterNetwork || dcIP.AddressFamily == System.Net.Sockets.AddressFamily.InterNetworkV6)\n                        {\n                            if (display)\n                            {\n                                Console.WriteLine("[*] Using domain controller: {0} ({1})", DCName, dcIP);\n                            }\n                            return String.Format("{0}", dcIP);\n                        }\n                    }\n                    Console.WriteLine("[X] Error resolving hostname \'{0}\' to an IP address: no IPv4 or IPv6 address found", DCName);\n                    return null;\n                }\n                catch (Exception e)\n                {\n                    Console.WriteLine("[X] Error resolving hostname \'{0}\' to an IP address: {1}", DCName, e.Message);\n                    return null;\n                }\n            }\n        }\n\n        public static string GetDCNameFromIP(string IP)\n        {\n            Match match = Regex.Match(IP, @"([0-9A-Fa-f]{1,4}:){7}[0-9A-Fa-f]{1,4}|(\\d{1,3}\\.){3}\\d{1,3}");\n            if (match.Success)\n            {\n                try\n                {\n                    System.Net.IPHostEntry DC = System.Net.Dns.GetHostEntry(IP);\n                    return DC.HostName;\n                }\n                catch (Exception e)\n                {\n                    Console.WriteLine("[X] Error resolving IP address \'{0}\' to a name: {1}", IP, e.Message);\n                    return null;\n                }\n            }\n            return IP;\n        }\n\n        public static byte[] SendBytes(string server, int port, byte[] data)\n        {\n            var ipEndPoint = new System.Net.IPEndPoint(System.Net.IPAddress.Parse(server), port);\n            try\n            {\n                using (System.Net.Sockets.TcpClient client = new System.Net.Sockets.TcpClient(ipEndPoint.AddressFamily)) {\n\n                    // connect to the server over The specified port\n                    client.Client.Ttl = 128;\n                    client.Connect(ipEndPoint);\n                    BinaryReader socketReader = new BinaryReader(client.GetStream());\n                    BinaryWriter socketWriter = new BinaryWriter(client.GetStream());\n                    \n                    socketWriter.Write(System.Net.IPAddress.HostToNetworkOrder(data.Length));                   \n                    socketWriter.Write(data);\n\n                    int recordMark = System.Net.IPAddress.NetworkToHostOrder(socketReader.ReadInt32());\n                    int recordSize = recordMark & 0x7fffffff;\n\n                    if((recordMark & 0x80000000) > 0) {\n                        Console.WriteLine("[X] Unexpected reserved bit set on response record mark from Domain Controller {0}:{1}, aborting", server, port);\n                        return null;\n                    }\n                    \n                    byte[] responseRecord = socketReader.ReadBytes(recordSize);\n\n                    if(responseRecord.Length != recordSize) {\n                        Console.WriteLine("[X] Incomplete record received from Domain Controller {0}:{1}, aborting", server, port);\n                        return null;\n                    }\n\n                    return responseRecord;\n                }\n            }\n            catch (System.Net.Sockets.SocketException e)\n            {\n                if (e.SocketErrorCode == System.Net.Sockets.SocketError.TimedOut) {\n                    Console.WriteLine("[X] Error connecting to {0}:{1} : {2}", server, port, e.Message);\n                } else {\n                    Console.WriteLine("[X] Failed to get response from Domain Controller {0}:{1} : {2}", server, port, e.Message);\n                }\n\n            }catch(FormatException fe) {\n                Console.WriteLine("[X] Error parsing IP address {0} : {1}", server, fe.Message);                \n            }\n\n            return null;\n        }\n\n        public static DirectoryEntry GetLdapSearchRoot(System.Net.NetworkCredential cred, string OUName, string domainController, string domain)\n        {\n            DirectoryEntry directoryObject = null;\n            string ldapPrefix = "";\n            string ldapOu = "";\n\n            //If we have a DC then use that instead of the domain name so that this works if user doesn\'t have\n            //name resolution working but specified the IP of a DC\n            if (!String.IsNullOrEmpty(domainController))\n            {\n                ldapPrefix = domainController;\n            }\n            else if (!String.IsNullOrEmpty(domain)) //If we don\'t have a DC then use the domain name (if we have one)\n            {\n                ldapPrefix = domain;\n            }\n            else if (cred != null) //If we don\'t have a DC or a domain name but have credentials, get domain name from them\n            {\n                ldapPrefix = cred.Domain;\n            }\n\n            if (!String.IsNullOrEmpty(OUName))\n            {\n                ldapOu = OUName.Replace("ldap", "LDAP").Replace("LDAP://", "");\n            }\n            else if (!String.IsNullOrEmpty(domain))\n            {\n                ldapOu = String.Format("DC={0}", domain.Replace(".", ",DC="));\n            }\n\n            //If no DC, domain, credentials, or OU were specified\n            if (String.IsNullOrEmpty(ldapPrefix) && String.IsNullOrEmpty(ldapOu))\n            {\n                directoryObject = new DirectoryEntry();\n                \n            }\n            else //If we have a prefix (DC or domain), an OU path, or both\n            {\n                string bindPath = "";\n                if (!String.IsNullOrEmpty(ldapPrefix))\n                {\n                    bindPath = String.Format("LDAP://{0}", ldapPrefix);\n                }\n                if (!String.IsNullOrEmpty(ldapOu))\n                {\n                    if (!String.IsNullOrEmpty(bindPath))\n                    {\n                        bindPath = String.Format("{0}/{1}", bindPath, ldapOu);\n                    }\n                    else\n                    {\n                        bindPath = String.Format("LDAP://{0}", ldapOu);\n                    }\n                }\n\n                directoryObject = new DirectoryEntry(bindPath);\n            }\n            \n            if (cred != null)\n            {\n                // if we\'re using alternate credentials for the connection\n                string userDomain = String.Format("{0}\\\\{1}", cred.Domain, cred.UserName);\n                directoryObject.Username = userDomain;\n                directoryObject.Password = cred.Password;\n             \n                // Removed credential validation check because it just caused problems and doesn\'t gain us anything (if invalid\n                // credentials are specified, the LDAP search will fail with "Logon failure: bad username or password" anyway)\n\n                //string contextTarget = "";\n                //if (!string.IsNullOrEmpty(domainController))\n                //{\n                //    contextTarget = domainController;\n                //}\n                //else\n                //{\n                //    contextTarget = cred.Domain;\n                //}\n\n                //using (PrincipalContext pc = new PrincipalContext(ContextType.Domain, contextTarget))\n                //{\n                //    if (!pc.ValidateCredentials(cred.UserName, cred.Password))\n                //    {\n                //        throw new Exception(String.Format("\\r\\n[X] Credentials supplied for \'{0}\' are invalid!", userDomain));\n                //    }\n                //    else\n                //    {\n                //        Console.WriteLine("[*] Using alternate creds  : {0}", userDomain);\n                //    }\n                //}\n            }\n            return directoryObject;\n        }\n\n        public static List<IDictionary<string, Object>> GetLdapQuery(System.Net.NetworkCredential cred, string OUName, string domainController, string domain, string filter, bool ldaps = false)\n        {\n            var ActiveDirectoryObjects = new List<IDictionary<string, Object>>();\n            if (String.IsNullOrEmpty(domainController))\n            {\n                domainController = Networking.GetDCName(domain); //if domain is null, this will try to find a DC in current user\'s domain\n            }\n            if (String.IsNullOrEmpty(domainController))\n            {\n                Console.WriteLine("[X] Unable to retrieve the domain information, try again with \'/domain\'.");\n                return null;\n            }\n\n            if (ldaps)\n            {\n                LdapConnection ldapConnection = null;\n                SearchResponse response = null;\n                List<SearchResultEntry> result = new List<SearchResultEntry>();\n                // perhaps make this dynamic?\n                int maxResultsToRequest = 1000;\n\n                try\n                {\n                    var serverId = new LdapDirectoryIdentifier(domainController, 636);\n                    ldapConnection = new LdapConnection(serverId, cred);\n                    ldapConnection.SessionOptions.SecureSocketLayer = true;\n                    ldapConnection.SessionOptions.VerifyServerCertificate += delegate { return true; };\n                    ldapConnection.Bind();\n                }\n                catch (Exception ex)\n                {\n                    if (ex.InnerException != null)\n                    {\n                        Console.WriteLine("[X] Error binding to LDAP server: {0}", ex.InnerException.Message);\n                    }\n                    else\n                    {\n                        Console.WriteLine("[X] Error binding to LDAP server: {0}", ex.Message);\n                    }\n                    return null;\n                }\n\n                if (String.IsNullOrEmpty(OUName))\n                {\n                    OUName = String.Format("DC={0}", domain.Replace(".", ",DC="));\n                }\n\n                try\n                {\n                    Console.WriteLine("[*] Searching path \'{0}\' for \'{1}\'", OUName, filter);\n                    PageResultRequestControl pageRequestControl = new PageResultRequestControl(maxResultsToRequest);\n                    PageResultResponseControl pageResponseControl;\n                    SearchRequest request = new SearchRequest(OUName, filter, SearchScope.Subtree, null);\n                    request.Controls.Add(pageRequestControl);\n                    while (true)\n                    {\n                        response = (SearchResponse)ldapConnection.SendRequest(request);\n                        foreach (SearchResultEntry entry in response.Entries)\n                        {\n                            result.Add(entry);\n                        }\n                        pageResponseControl = (PageResultResponseControl)response.Controls[0];\n                        if (pageResponseControl.Cookie.Length == 0)\n                            break;\n                        pageRequestControl.Cookie = pageResponseControl.Cookie;\n                    }\n                }\n                catch (Exception ex)\n                {\n                    Console.WriteLine("[X] Error executing LDAP query: {0}", ex.Message);\n                }\n\n                if (response.ResultCode == ResultCode.Success)\n                {\n                    ActiveDirectoryObjects = Helpers.GetADObjects(result);\n                }\n            }\n            else\n            {\n                DirectoryEntry directoryObject = null;\n                DirectorySearcher searcher = null;\n                try\n                {\n                    directoryObject = Networking.GetLdapSearchRoot(cred, OUName, domainController, domain);\n                    searcher = new DirectorySearcher(directoryObject);\n                    // enable LDAP paged search to get all results, by pages of 1000 items\n                    searcher.PageSize = 1000;\n                }\n                catch (Exception ex)\n                {\n                    if (ex.InnerException != null)\n                    {\n                        Console.WriteLine("[X] Error creating the domain searcher: {0}", ex.InnerException.Message);\n                    }\n                    else\n                    {\n                        Console.WriteLine("[X] Error creating the domain searcher: {0}", ex.Message);\n                    }\n                    return null;\n                }\n\n                // check to ensure that the bind worked correctly\n                try\n                {\n                    string dirPath = directoryObject.Path;\n                    if (String.IsNullOrEmpty(dirPath))\n                    {\n                        Console.WriteLine("[*] Searching the current domain for \'{0}\'", filter);\n                    }\n                    else\n                    {\n                        Console.WriteLine("[*] Searching path \'{0}\' for \'{1}\'", dirPath, filter);\n                    }\n                }\n                catch (DirectoryServicesCOMException ex)\n                {\n                    if (!String.IsNullOrEmpty(OUName))\n                    {\n                        Console.WriteLine("\\r\\n[X] Error validating the domain searcher for bind path \\"{0}\\" : {1}", OUName, ex.Message);\n                    }\n                    else\n                    {\n                        Console.WriteLine("\\r\\n[X] Error validating the domain searcher: {0}", ex.Message);\n                    }\n                    return null;\n                }\n\n                try\n                {\n                    searcher.Filter = filter;\n                }\n                catch (Exception ex)\n                {\n                    Console.WriteLine("[X] Error settings the domain searcher filter: {0}", ex.InnerException.Message);\n                    return null;\n                }\n\n                SearchResultCollection results = null;\n\n                try\n                {\n                    results = searcher.FindAll();\n\n                    if (results.Count == 0)\n                    {\n                        Console.WriteLine("[X] No results returned by LDAP!");\n                        return null;\n                    }\n                }\n                catch (Exception ex)\n                {\n                    if (ex.InnerException != null)\n                    {\n                        Console.WriteLine("[X] Error executing the domain searcher: {0}", ex.InnerException.Message);\n                    }\n                    else\n                    {\n                        Console.WriteLine("[X] Error executing the domain searcher: {0}", ex.Message);\n                    }\n                    return null;\n                }\n                ActiveDirectoryObjects = Helpers.GetADObjects(results);\n            }\n\n            return ActiveDirectoryObjects;\n        }\n\n        // implementation adapted from https://github.com/tevora-threat/SharpView\n        public static Dictionary<string, Dictionary<string, Object>> GetGptTmplContent(string path, string user = null, string password = null)\n        {\n            Dictionary<string, Dictionary<string, Object>> IniObject = new Dictionary<string, Dictionary<string, Object>>();\n            string sysvolPath = String.Format("\\\\\\\\{0}\\\\SYSVOL", (new System.Uri(path).Host));\n\n            int result = AddRemoteConnection(null, sysvolPath, user, password);\n            if (result != (int)Interop.SystemErrorCodes.ERROR_SUCCESS)\n            {\n                return null;\n            }\n\n            if (System.IO.File.Exists(path))\n            {\n                var content = File.ReadAllLines(path);\n                var CommentCount = 0;\n                var Section = "";\n                foreach (var line in content)\n                {\n                    if (Regex.IsMatch(line, @"^\\[(.+)\\]"))\n                    {\n                        Section = Regex.Split(line, @"^\\[(.+)\\]")[1].Trim();\n                        Section = Regex.Replace(Section, @"\\s+", "");\n                        IniObject[Section] = new Dictionary<string, object>();\n                        CommentCount = 0;\n                    }\n                    else if (Regex.IsMatch(line, @"^(;.*)$"))\n                    {\n                        var Value = Regex.Split(line, @"^(;.*)$")[1].Trim();\n                        CommentCount = CommentCount + 1;\n                        var Name = @"Comment" + CommentCount;\n                        IniObject[Section][Name] = Value;\n                    }\n                    else if (Regex.IsMatch(line, @"(.+?)\\s*=(.*)"))\n                    {\n                        var matches = Regex.Split(line, @"=");\n                        var Name = Regex.Replace(matches[0].Trim(), @"\\s+", "");\n                        var Value = Regex.Replace(matches[1].Trim(), @"\\s+", "");\n                        // var Values = Value.Split(\',\').Select(x => x.Trim());\n\n                        // if ($Values -isnot [System.Array]) { $Values = @($Values) }\n\n                        IniObject[Section][Name] = Value;\n                    }\n                }\n            }\n\n            result = RemoveRemoteConnection(null, sysvolPath);\n\n            return IniObject;\n        }\n\n        public static int AddRemoteConnection(string host = null, string path = null, string user = null, string password = null)\n        {\n            var NetResourceInstance = Activator.CreateInstance(typeof(Interop.NetResource)) as Interop.NetResource;\n            List<string> paths = new List<string>();\n            int returnResult = 0;\n\n            if (host != null)\n            {\n                string targetComputerName = host.Trim(\'\\\\\');\n                paths.Add(String.Format("\\\\\\\\{0}\\\\IPC$", targetComputerName));\n            }\n            else\n            {\n                paths.Add(path);\n            }\n\n            foreach (string targetPath in paths)\n            {\n                NetResourceInstance.RemoteName = targetPath;\n                NetResourceInstance.ResourceType = Interop.ResourceType.Disk;\n\n                NetResourceInstance.RemoteName = targetPath;\n\n                Console.WriteLine("[*] Attempting to mount: {0}", targetPath);\n\n\n                int result = Interop.WNetAddConnection2(NetResourceInstance, password, user, 4);\n\n                if (result == (int)Interop.SystemErrorCodes.ERROR_SUCCESS)\n                {\n                    Console.WriteLine("[*] {0} successfully mounted", targetPath);\n                }\n                else\n                {\n                    Console.WriteLine("[X] Error mounting {0} error code {1} ({2})", targetPath, (Interop.SystemErrorCodes)result, result);\n                    returnResult = result;\n                }\n            }\n            return returnResult;\n        }\n\n        public static int RemoveRemoteConnection(string host = null, string path = null)\n        {\n\n            List<string> paths = new List<string>();\n            int returnResult = 0;\n\n            if (host != null)\n            {\n                string targetComputerName = host.Trim(\'\\\\\');\n                paths.Add(String.Format("\\\\\\\\{0}\\\\IPC$", targetComputerName));\n            }\n            else\n            {\n                paths.Add(path);\n            }\n\n            foreach (string targetPath in paths)\n            {\n                Console.WriteLine("[*] Attempting to unmount: {0}", targetPath);\n                int result = Interop.WNetCancelConnection2(targetPath, 0, true);\n\n                if (result == 0)\n                {\n                    Console.WriteLine("[*] {0} successfully unmounted", targetPath);\n                }\n                else\n                {\n                    Console.WriteLine("[X] Error unmounting {0}", targetPath);\n                    returnResult = result;\n                }\n            }\n            return returnResult;\n        }\n    }\n}\n\n'