b'module IdrisGen (saveIdrisGame) where\nimport GameModel\nimport qualified Data.Map as M\nimport Data.Maybe\n\nisKnown :: (Coord, CellStatus) -> Bool\nisKnown (_, CellStatus CellKnown _) = True\nisKnown _ = False\n\ngenMineFact :: M.Map Coord Int -> (Coord, CellStatus) -> String\ngenMineFact _ (Coord x y, CellStatus _ CellMine) =\n  "  MineAt" ++ (show x) ++ "_" ++ (show y) ++ " : MineFact (MkCoord " ++ (show x) ++ " " ++ (show y) ++ ") IsMine\\n"\ngenMineFact counts (c@(Coord x y), CellStatus _ CellNotMine) =\n  "  NoMineAt" ++ (show x) ++ "_" ++ (show y) ++ " : MineFact (MkCoord " ++ (show x) ++ " " ++ (show y) ++ ") (KnownNotMine " ++ (show $ fromMaybe 0 $ M.lookup c counts) ++ ")\\n"\n\ngenMineFacts :: M.Map Coord Int -> M.Map Coord CellStatus -> String\ngenMineFacts counts status = concatMap (genMineFact counts) $ filter isKnown $ M.toList status\n\ngameToIdris :: Game -> M.Map Coord Int -> String\ngameToIdris (Game { gameGridSize = gridSize, gameStatus = status }) counts =\n  "-- Generated source - do not edit!\\n\\\n  \\-- This contains the axioms for the current state of the game.\\n\\\n  \\module ProofSweeperKnown\\n\\\n  \\\\n\\\n  \\import ProofSweeperBase\\n\\\n  \\\\n\\\n  \\%access public export\\n\\\n  \\%default total\\n\\\n  \\\\n\\\n  \\gridSize : Nat\\n\\\n  \\gridSize = " ++ show gridSize ++ "\\n\\\n  \\\\n\\\n  \\mineNeighboursForSize : Coord -> List Coord\\n\\\n  \\mineNeighboursForSize = mineNeighbours gridSize\\n\\\n  \\\\n\\\n  \\data MineFact : Coord -> MineProp -> Type where\\n\\\n  \\  KnownNotMineIsNotMine : MineFact c (KnownNotMine _) -> MineFact c IsNotMine\\n\\\n  \\  AllMinesAccountedFor :\\n\\\n  \\       (c : Coord)\\n\\\n  \\    -> (cNonMine : Coord)\\n\\\n  \\    -> (prfCIsNotMine : MineFact c (KnownNotMine cnt))\\n\\\n  \\    -> (knownMines : List Coord)\\n\\\n  \\    -> (prfEnoughKnownMines : distinctCount knownMines = cnt)\\n\\\n  \\    -> (prfKnownMinesAreMines : (cNeigh : Coord)\\n\\\n  \\           -> elem cNeigh knownMines = True\\n\\\n  \\           -> MineFact cNeigh IsMine)\\n\\\n  \\    -> (prfKnownMinesAreNeighbours : (cNeigh : Coord)\\n\\\n  \\           -> elem cNeigh knownMines = True\\n\\\n  \\           -> elem cNeigh (mineNeighboursForSize c) = True)\\n\\\n  \\    -> (prfNonMineIsNeighbour : elem cNonMine (mineNeighboursForSize c) = True)\\n\\\n  \\    -> (prfNonMineNotInKnownMines : elem cNonMine knownMines = False)\\n\\\n  \\    -> MineFact cNonMine IsNotMine\\n\\\n  \\  AllNonMinesAccountedFor :\\n\\\n  \\       (c : Coord)\\n\\\n  \\    -> (cMine : Coord)\\n\\\n  \\    -> (prfCIsNotMine : MineFact c (KnownNotMine cnt))\\n\\\n  \\    -> (knownNonMines : List Coord)\\n\\\n  \\    -> (prfEnoughKnownNonMines : distinctCount knownNonMines + cnt = length (mineNeighboursForSize c))\\n\\\n  \\    -> (prfKnownNonMinesAreNotMines : (cNeigh : Coord)\\n\\\n  \\           -> elem cNeigh knownNonMines = True\\n\\\n  \\           -> MineFact cNeigh IsNotMine)\\n\\\n  \\    -> (prfKnownNonMinesAreNeighbours : (cNeigh : Coord)\\n\\\n  \\           -> elem cNeigh knownNonMines = True\\n\\\n  \\           -> elem cNeigh (mineNeighboursForSize c) = True)\\n\\\n  \\    -> (prfNonMineIsNeighbour : elem cMine (mineNeighboursForSize c) = True)\\n\\\n  \\    -> (prfMineNotInKnownNonMines : elem cMine knownNonMines = False)\\n\\\n  \\    -> MineFact cMine IsMine\\n\\\n  \\  NotMineImpliesNonMine :\\n\\\n  \\       Not (MineFact c IsMine)\\n\\\n  \\    -> MineFact c IsNotMine\\n"\n    ++ genMineFacts counts status ++ "\\n\\\n  \\\\n\\\n  \\nonMineImpliesNotMine : MineFact c IsNotMine -> Not (MineFact c IsMine)\\n\\\n  \\nonMineImpliesNotMine v = believe_me v\\n\\\n  \\mineOrNot :\\n\\\n  \\       (c : Coord)\\n\\\n  \\    -> Either (MineFact c IsMine) (MineFact c IsNotMine)\\n\\\n  \\mineOrNot v = believe_me v\\n"\n  \nsaveIdrisGame :: Game -> M.Map Coord Int -> IO ()\nsaveIdrisGame g facts = do\n  let idrisFile = gameToIdris g facts\n  writeFile "ProofSweeperKnown.idr" idrisFile\n'