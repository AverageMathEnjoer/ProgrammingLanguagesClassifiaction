b'{-# LANGUAGE FlexibleInstances, MultiParamTypeClasses,\n             UndecidableInstances, TypeSynonymInstances, ScopedTypeVariables,\n\t           EmptyDataDecls, CPP #-}\n{-|\n\nUNFINISHED\n\n    This module provides a basic implementation of channels that is\n    usable with any monad satisfying ParIVar.\n -}\n\n\nmodule Control.Monad.Par.Chan\n (\n   ParC,\n--    runParRNG, fork,\n--    IVar, new, newFull, newFull_, get, put, put_,\n--    spawn, spawn_\n )\n where\n\nimport qualified  Control.Monad.Par.Class as PC\nimport Control.Monad.Trans\nimport qualified Control.Monad.Trans.State as S\nimport Control.Monad.ST\nimport Control.Monad.Par.OpenList as L\nimport Control.DeepSeq\nimport Control.Parallel (pseq)\n-- import qualified Data.Vector.Unboxed as U\nimport Data.Vector as V\nimport Data.Int\nimport Data.BitList\n\n--------------------------------------------------------------------------------\n-- Make Par computations with state work.\n-- (TODO: move these instances to a different module.)\n\n-- | The @SplittableState@ class models state that can be split along\n--   with a Par monad\'s control flow.  It would be possible to simply\n--   duplicate the state irrespective of its type, but this interface\n--   allows the definition of custom (non-duplication) splitting\n--   behaviors, such as splitting a random number generator.\nclass SplittableState a where\n  splitState :: a -> (a,a)\n\n-- include "Scheds/par_instance_boilerplate.hs"\n\n-- Allow State to be added to any ParFuture monad:\n-- This could be used for RNG.\ninstance (SplittableState s, PC.ParFuture iv p)\n      =>  PC.ParFuture iv (S.StateT s p) where\n  get   = lift . PC.get\n  spawn_ (task :: S.StateT s p a) =\n\t\t  do s <- S.get\n\t\t     let (s1,s2) = splitState s\n\t\t     S.put s2\n\t\t     let x  :: p (a,s) = S.runStateT task s1\n                         x\' :: p a     = do (x,_) <- x; return x\n\t\t     lift$ PC.spawn_ x\'\n  spawn p = PC.spawn_ (do p\' <- p; pseq (rnf p\') return p\' )\n\n  spawnP = error "unimplemented"\n\n--  spawn = spawn\n--  spawn p  = do r <- new;  fork (p >>= put r);   return r\n--  spawn_ p = do r <- new;  fork (p >>= put_ r);  return r\n\ninstance (SplittableState s, PC.ParIVar iv p)\n      =>  PC.ParIVar iv (S.StateT s p)\n where\n  fork     = fork\n  new      = new\n  put_     = put_\n  newFull_ = lift . PC.newFull_\n  newFull  = lift . PC.newFull\n\nnew :: PC.ParIVar iv p => S.StateT s p (iv a)\nnew      = lift  PC.new\n\nput  v x = lift$ PC.put  v x\nput_ v x = lift$ PC.put_ v x\n\nfork :: (SplittableState s, PC.ParIVar iv p)\n     => S.StateT s p () -> S.StateT s p ()\nfork task =\n\t\tdo s <- S.get\n\t\t   let (s1,s2) = splitState s\n\t\t   S.put s2\n\t\t   lift$ PC.fork $ do\n\t\t     S.runStateT task s1\n\t\t     return ()\n\t\t   return ()\n\n\n\n--------------------------------------------------------------------------------\n\n-- Unique keys for strings:\n-- Two options:\n--   * unsafely generate unique values, e.g. Data.Unique\n--      (unsafePerformIO or a non-standard ST monad tranfsormer)\n--   * use a counter + the tree-index in the fork-tree\n\n-- unsafeGensym\n\n\n-- Let\'s do the safe one first:\n\ntype Key = (Int, BitList)\n-- genKey :: Monad m => ParC m Key\ngenKey = undefined\n\n--------------------------------------------------------------------------------\n\n-- A Par monad with stream support can be built from any other Par monad:\ntype ParC p = S.StateT (CursorMap Magic) p\n\n-- newtype CursorMap a = CursorMap (Vector (Cursor a))\n--data Cursor    a = Cursor Int (OpenList a)\n--newtype RecvPtr a = RecvPtr Int\nnewtype CursorMap a = CursorMap (Vector (OpenList Magic))\n--newtype RecvPtr a = RecvPtr (Int, OpenList a)\nnewtype RecvPtr a = RecvPtr (Int, a)\n\ndata Magic\n\ninstance SplittableState (CursorMap a) where\n  splitState x = (x,x)\n\n-- type SendPort v a = ()\n-- type RecvPort v a = ()\ndata SendPort a = SendPort a\ndata RecvPort a = RecvPort a\n\ninstance PC.ParIVar v m => PC.ParChan (ParC m) SendPort RecvPtr where\n\n  -- A new channel coins a unique key that can be used to lookup the stream.\n  newChan = undefined\n  send    = undefined\n\n  -- Advance the cursor:\n  recv (RecvPtr (i,_::elt)) =\n    -- The RecvPtr essentially carries the type, but no value for the stream.\n    do CursorMap vec <- S.get\n       let ol = unsafeIndex vec i\n           hd = L.head ol\n--       tl <- lift$ L.tail ol\n--       V.modify (\\v -> write v i tl) vec\n\n--       return hd\n       return undefined\n'