b'{-# LANGUAGE ExplicitForAll #-}\n{-# LANGUAGE FlexibleContexts #-}\n{-# LANGUAGE OverloadedStrings #-}\n\n-- | Bindings for The OAuth 2.0 Authorization Framework: Bearer Token Usage\n-- RFC6750 <https://www.rfc-editor.org/rfc/rfc6750>\nmodule Network.OAuth.OAuth2.HttpClient (\n  -- * AUTH requests\n  authGetJSON,\n  authGetBS,\n  authGetBS2,\n  authGetJSONWithAuthMethod,\n  authGetJSONInternal,\n  authGetBSWithAuthMethod,\n  authGetBSInternal,\n  authPostJSON,\n  authPostBS,\n  authPostBS2,\n  authPostBS3,\n  authPostJSONWithAuthMethod,\n  authPostJSONInternal,\n  authPostBSWithAuthMethod,\n  authPostBSInternal,\n\n  -- * Types\n  APIAuthenticationMethod (..),\n) where\n\nimport Control.Monad.IO.Class (MonadIO (..))\nimport Control.Monad.Trans.Except (ExceptT (..), throwE)\nimport Data.Aeson (FromJSON, eitherDecode)\nimport Data.ByteString.Char8 qualified as BS\nimport Data.ByteString.Lazy.Char8 qualified as BSL\nimport Data.Maybe (fromJust, isJust)\nimport Data.Text.Encoding qualified as T\nimport Lens.Micro (over)\nimport Network.HTTP.Conduit\nimport Network.HTTP.Types qualified as HT\nimport Network.OAuth.OAuth2.Internal\nimport URI.ByteString (URI, URIRef, queryL, queryPairsL)\n\n--------------------------------------------------\n\n-- * AUTH requests\n\n-- Making request with Access Token appended to Header, Request body or query string.\n--\n--------------------------------------------------\n\n-- | Conduct an authorized GET request and return response as JSON.\n--   Inject Access Token to Authorization Header.\nauthGetJSON ::\n  (FromJSON a, MonadIO m) =>\n  -- | HTTP connection manager.\n  Manager ->\n  AccessToken ->\n  URI ->\n  -- | Response as JSON\n  ExceptT BSL.ByteString m a\nauthGetJSON = authGetJSONWithAuthMethod AuthInRequestHeader\n\nauthGetJSONInternal ::\n  (FromJSON a, MonadIO m) =>\n  APIAuthenticationMethod ->\n  -- | HTTP connection manager.\n  Manager ->\n  AccessToken ->\n  URI ->\n  -- | Response as JSON\n  ExceptT BSL.ByteString m a\nauthGetJSONInternal = authGetJSONWithAuthMethod\n{-# DEPRECATED authGetJSONInternal "use authGetJSONWithAuthMethod" #-}\n\n-- | Conduct an authorized GET request and return response as JSON.\n--   Allow to specify how to append AccessToken.\n--\n-- @since 2.6.0\nauthGetJSONWithAuthMethod ::\n  (MonadIO m, FromJSON a) =>\n  APIAuthenticationMethod ->\n  -- | HTTP connection manager.\n  Manager ->\n  AccessToken ->\n  URI ->\n  -- | Response as JSON\n  ExceptT BSL.ByteString m a\nauthGetJSONWithAuthMethod authTypes manager t uri = do\n  resp <- authGetBSWithAuthMethod authTypes manager t uri\n  either (throwE . BSL.pack) return (eitherDecode resp)\n\n-- | Conduct an authorized GET request.\n--   Inject Access Token to Authorization Header.\nauthGetBS ::\n  (MonadIO m) =>\n  -- | HTTP connection manager.\n  Manager ->\n  AccessToken ->\n  URI ->\n  -- | Response as ByteString\n  ExceptT BSL.ByteString m BSL.ByteString\nauthGetBS = authGetBSWithAuthMethod AuthInRequestHeader\n\n-- | Same to \'authGetBS\' but set access token to query parameter rather than header\nauthGetBS2 ::\n  (MonadIO m) =>\n  -- | HTTP connection manager.\n  Manager ->\n  AccessToken ->\n  URI ->\n  -- | Response as ByteString\n  ExceptT BSL.ByteString m BSL.ByteString\nauthGetBS2 = authGetBSWithAuthMethod AuthInRequestQuery\n{-# DEPRECATED authGetBS2 "use authGetBSWithAuthMethod" #-}\n\nauthGetBSInternal ::\n  (MonadIO m) =>\n  APIAuthenticationMethod ->\n  -- | HTTP connection manager.\n  Manager ->\n  AccessToken ->\n  URI ->\n  -- | Response as ByteString\n  ExceptT BSL.ByteString m BSL.ByteString\nauthGetBSInternal = authGetBSWithAuthMethod\n{-# DEPRECATED authGetBSInternal "use authGetBSWithAuthMethod" #-}\n\n-- | Conduct an authorized GET request and return response as ByteString.\n--   Allow to specify how to append AccessToken.\n--\n-- @since 2.6.0\nauthGetBSWithAuthMethod ::\n  (MonadIO m) =>\n  -- | Specify the way that how to append the \'AccessToken\' in the request\n  APIAuthenticationMethod ->\n  -- | HTTP connection manager.\n  Manager ->\n  AccessToken ->\n  URI ->\n  -- | Response as ByteString\n  ExceptT BSL.ByteString m BSL.ByteString\nauthGetBSWithAuthMethod authTypes manager token url = do\n  let appendToUrl = AuthInRequestQuery == authTypes\n  let appendToHeader = AuthInRequestHeader == authTypes\n  let uri = if appendToUrl then url `appendAccessToken` token else url\n  let upReq = updateRequestHeaders (if appendToHeader then Just token else Nothing) . setMethod HT.GET\n  req <- liftIO $ uriToRequest uri\n  authRequest req upReq manager\n\n-- | Conduct POST request and return response as JSON.\n--   Inject Access Token to Authorization Header.\nauthPostJSON ::\n  (FromJSON a, MonadIO m) =>\n  -- | HTTP connection manager.\n  Manager ->\n  AccessToken ->\n  URI ->\n  PostBody ->\n  -- | Response as JSON\n  ExceptT BSL.ByteString m a\nauthPostJSON = authPostJSONWithAuthMethod AuthInRequestHeader\n\nauthPostJSONInternal ::\n  (FromJSON a, MonadIO m) =>\n  APIAuthenticationMethod ->\n  -- | HTTP connection manager.\n  Manager ->\n  AccessToken ->\n  URI ->\n  PostBody ->\n  -- | Response as ByteString\n  ExceptT BSL.ByteString m a\nauthPostJSONInternal = authPostJSONWithAuthMethod\n{-# DEPRECATED authPostJSONInternal "use \'authPostJSONWithAuthMethod\'" #-}\n\n-- | Conduct POST request and return response as JSON.\n--   Allow to specify how to append AccessToken.\n--\n-- @since 2.6.0\nauthPostJSONWithAuthMethod ::\n  (FromJSON a, MonadIO m) =>\n  APIAuthenticationMethod ->\n  -- | HTTP connection manager.\n  Manager ->\n  AccessToken ->\n  URI ->\n  PostBody ->\n  -- | Response as ByteString\n  ExceptT BSL.ByteString m a\nauthPostJSONWithAuthMethod authTypes manager token url body = do\n  resp <- authPostBSWithAuthMethod authTypes manager token url body\n  either (throwE . BSL.pack) return (eitherDecode resp)\n\n-- | Conduct POST request.\n--   Inject Access Token to http header (Authorization)\nauthPostBS ::\n  (MonadIO m) =>\n  -- | HTTP connection manager.\n  Manager ->\n  AccessToken ->\n  URI ->\n  PostBody ->\n  -- | Response as ByteString\n  ExceptT BSL.ByteString m BSL.ByteString\nauthPostBS = authPostBSWithAuthMethod AuthInRequestHeader\n\n-- | Conduct POST request with access token only in the request body but header.\nauthPostBS2 ::\n  (MonadIO m) =>\n  -- | HTTP connection manager.\n  Manager ->\n  AccessToken ->\n  URI ->\n  PostBody ->\n  -- | Response as ByteString\n  ExceptT BSL.ByteString m BSL.ByteString\nauthPostBS2 = authPostBSWithAuthMethod AuthInRequestBody\n{-# DEPRECATED authPostBS2 "use \'authPostBSWithAuthMethod\'" #-}\n\n-- | Conduct POST request with access token only in the header and not in body\nauthPostBS3 ::\n  (MonadIO m) =>\n  -- | HTTP connection manager.\n  Manager ->\n  AccessToken ->\n  URI ->\n  PostBody ->\n  -- | Response as ByteString\n  ExceptT BSL.ByteString m BSL.ByteString\nauthPostBS3 = authPostBSWithAuthMethod AuthInRequestHeader\n{-# DEPRECATED authPostBS3 "use \'authPostBSWithAuthMethod\'" #-}\n\nauthPostBSInternal ::\n  (MonadIO m) =>\n  APIAuthenticationMethod ->\n  -- | HTTP connection manager.\n  Manager ->\n  AccessToken ->\n  URI ->\n  PostBody ->\n  -- | Response as ByteString\n  ExceptT BSL.ByteString m BSL.ByteString\nauthPostBSInternal = authPostBSWithAuthMethod\n{-# DEPRECATED authPostBSInternal "use \'authPostBSWithAuthMethod\'" #-}\n\n-- | Conduct POST request and return response as ByteString.\n--   Allow to specify how to append AccessToken.\n--\n-- @since 2.6.0\nauthPostBSWithAuthMethod ::\n  (MonadIO m) =>\n  APIAuthenticationMethod ->\n  -- | HTTP connection manager.\n  Manager ->\n  AccessToken ->\n  URI ->\n  PostBody ->\n  -- | Response as ByteString\n  ExceptT BSL.ByteString m BSL.ByteString\nauthPostBSWithAuthMethod authTypes manager token url body = do\n  let appendToBody = AuthInRequestBody == authTypes\n  let appendToHeader = AuthInRequestHeader == authTypes\n  let reqBody = if appendToBody then body ++ accessTokenToParam token else body\n  -- TODO: urlEncodedBody send request as \'application/x-www-form-urlencoded\'\n  -- seems shall go with application/json which is more common?\n  let upBody = if null reqBody then id else urlEncodedBody reqBody\n  let upHeaders = updateRequestHeaders (if appendToHeader then Just token else Nothing) . setMethod HT.POST\n  let upReq = upHeaders . upBody\n\n  req <- liftIO $ uriToRequest url\n  authRequest req upReq manager\n\n--------------------------------------------------\n\n-- * Types\n\n--------------------------------------------------\n\n-- | https://www.rfc-editor.org/rfc/rfc6750#section-2\ndata APIAuthenticationMethod\n  = -- | Provides in Authorization header\n    AuthInRequestHeader\n  | -- | Provides in request body\n    AuthInRequestBody\n  | -- | Provides in request query parameter\n    AuthInRequestQuery\n  deriving (Eq, Ord)\n\n--------------------------------------------------\n\n-- * Utilities\n\n--------------------------------------------------\n\n-- | Send an HTTP request.\nauthRequest ::\n  (MonadIO m) =>\n  -- | Request to perform\n  Request ->\n  -- | Modify request before sending\n  (Request -> Request) ->\n  -- | HTTP connection manager.\n  Manager ->\n  ExceptT BSL.ByteString m BSL.ByteString\nauthRequest req upReq manage = ExceptT $ do\n  resp <- httpLbs (upReq req) manage\n  pure (handleResponse resp)\n\n-- | Get response body out of a @Response@\nhandleResponse :: Response BSL.ByteString -> Either BSL.ByteString BSL.ByteString\nhandleResponse rsp\n  | HT.statusIsSuccessful (responseStatus rsp) = Right (responseBody rsp)\n  -- FIXME: better to surface up entire resp so that client can decide what to do when error happens.\n  -- e.g. when 404, the response body could be empty hence library user has no idea what\'s happening.\n  -- Which will be breaking changes.\n  -- The current work around is surface up entire response as string.\n  | BSL.null (responseBody rsp) = Left (BSL.pack $ show rsp)\n  | otherwise = Left (responseBody rsp)\n\n-- | Set several header values:\n--   + userAgennt    : `hoauth2`\n--   + accept        : `application/json`\n--   + authorization : \'Bearer\' `xxxxx` if \'AccessToken\' provided.\nupdateRequestHeaders :: Maybe AccessToken -> Request -> Request\nupdateRequestHeaders t req =\n  let bearer = [(HT.hAuthorization, "Bearer " `BS.append` T.encodeUtf8 (atoken (fromJust t))) | isJust t]\n      headers = bearer ++ defaultRequestHeaders ++ requestHeaders req\n   in req {requestHeaders = headers}\n\n-- | Set the HTTP method to use.\nsetMethod :: HT.StdMethod -> Request -> Request\nsetMethod m req = req {method = HT.renderStdMethod m}\n\n-- | For `GET` method API.\nappendAccessToken ::\n  -- | Base URI\n  URIRef a ->\n  -- | Authorized Access Token\n  AccessToken ->\n  -- | Combined Result\n  URIRef a\nappendAccessToken uri t = over (queryL . queryPairsL) (\\query -> query ++ accessTokenToParam t) uri\n\n-- | Create \'QueryParams\' with given access token value.\naccessTokenToParam :: AccessToken -> [(BS.ByteString, BS.ByteString)]\naccessTokenToParam t = [("access_token", T.encodeUtf8 $ atoken t)]\n'