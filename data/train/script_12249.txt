b"{-# LANGUAGE TupleSections #-}\n-- | As described by Winograd-Court in his PhD thesis,\n-- a wormhole consists of a data sink and a data source which are linked\n-- by a synchronisation mechanism.\n-- The aim of this technique is to abstract from the particular mechanism\n-- of synchronisation and supply an interface\n-- that is free of deadlocks and race conditions.\n--\n-- Often, an external reactive framework may have several parallel loops,\n-- for example, OpenGL with a display callback,\n-- an idle callback and a keyboard callback.\n-- In such cases, one would like to let the different parts communicate.\n-- This is done through a wormhole, which is a shared mutable variable\n-- that can be written from one part and read from the other.\n--\n-- An example implementation is given for 'IORefs'.\n-- Usually, the implementation is straightforward\n-- for other synchronisation methods.\n-- A word of caution has to be said though,\n-- against using _blocking_ synchronisation mechanisms,\n-- such as 'MVar's, for wormholes. In typical use cases,\n-- the side effects of the sink and the source\n-- have to be assumed to be non-blocking, ruling e.g. 'MVar's out.\n\nmodule Data.MonadicStreamFunction.Wormhole where\n\n-- External\nimport Control.Monad.IO.Class\nimport Control.Concurrent\nimport Data.IORef\nimport Data.Monoid\n\n-- Internal\nimport Data.MonadicStreamFunction\n\n-- | A wormhole consists of two monadic stream functions,\n-- a sink and a source. It should satisfy the following properties:\n--\n-- * The data sent into the sink is transferred to the source\n--   by means of side effects in @m@.\n-- * In case of 'IO', sink and source are non-blocking.\ndata Wormhole m a b = Wormhole\n  { sink   :: MSF m a ()\n  , source :: MSF m () b\n  }\n\n-- | Creates a wormhole that encapsulates an initialised 'IORef'.\n-- No synchronisation guarantee is made,\n-- so the 'IORef' could be updated several times, or not at all,\n-- before it is read again.\nnewWormholeIORef :: MonadIO m => a -> m (Wormhole m a a)\nnewWormholeIORef a = liftIO $ do\n  ref <- newIORef a\n  return $ Wormhole\n    { sink   = arrM  $ liftIO . writeIORef ref\n    , source = constM $ liftIO $ readIORef  ref\n    }\n\n-- | Create a wormhole encapsulating an initialised 'IORef'.\n-- Incoming data modifies the stored value atomically and strictly.\nnewWormholeModifyIORef\n  :: MonadIO m\n  => b              -- ^ The initial value\n  -> (a -> b -> b)  -- ^ This function modifies the stored value for every input\n  -> m (Wormhole m a b)\nnewWormholeModifyIORef b f = liftIO $ do\n  ref <- newIORef b\n  return $ Wormhole\n    { sink   = arrM $ \\a -> liftIO $ atomicModifyIORef' ref $ (, ()) . f a\n    , source = constM $ liftIO $ readIORef ref\n    }\n\n-- | Create a wormhole encapsulating an 'IORef' storing a 'Monoid'.\n-- Every input is (atomically and strictly) 'mappend'ed to the stored value,\n-- and whenever output is requested, the stored value is retrieved\n-- (atomically and strictly) and replaced by 'mempty'.\nnewWormholeMonoidIORef :: (Monoid a, MonadIO m) => m (Wormhole m a a)\nnewWormholeMonoidIORef = liftIO $ do\n  ref <- newIORef mempty\n  return $ Wormhole\n    { sink   = arrM $ \\a -> liftIO $ atomicModifyIORef' ref $ (, ()) . mappend a\n    , source = constM $ liftIO $ atomicModifyIORef' ref $ \\a -> (mempty, a)\n    }\n\n-- | Creates two wormholes with 'IORef's at each end of the stream function\n-- and runs the inner stream function in a separate thread.\n-- It returns the outer stream function, which can be used\n-- to send and receive data\n-- from the other thread, and a method to kill the thread.\n-- As for 'newWormholeIORef', there is no synchronisation guarantee.\nconcurrently :: MSF IO a b -> a -> b -> IO (MSF IO a b, IO ())\nconcurrently msf a b = do\n  input    <- newWormholeIORef a\n  output   <- newWormholeIORef b\n  threadId <- forkIO $ reactimate $ source input >>> msf >>> sink output\n  return (sink input >>> source output, killThread threadId)\n\n-- | Creates two ends of a synchronisation wormhole.\n--\n-- Often, the external framework may have several parallel loops,\n-- for example, OpenGL with a display callback, an idle callback and a keyboard callback.\n-- In such cases, one would like to let the different parts communicate.\n-- This is done through a wormhole, which is a shared mutable variable\n-- that can be written from one part and read from the other.\n-- In this implementation, an 'IORef' is used.\ncreateWormhole :: MonadIO m => a -> m (MSF m a (), MSF m () a)\ncreateWormhole a = liftIO $ do\n  ref <- newIORef a\n  return (arrM $ liftIO . writeIORef ref, constM $ liftIO $ readIORef ref)\n"