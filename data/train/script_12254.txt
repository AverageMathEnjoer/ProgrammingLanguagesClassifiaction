b'\xef\xbb\xbf#load "SupportVectorMachine.fs"\n#r @"..\\..\\MachineLearningInAction\\packages\\MSDN.FSharpChart.dll.0.60\\lib\\MSDN.FSharpChart.dll"\n#r "System.Windows.Forms.DataVisualization"\n\nopen MachineLearning.SupportVectorMachine\nopen System\nopen System.Drawing\nopen System.Windows.Forms.DataVisualization\nopen MSDN.FSharp.Charting\n \n// ******** Evaluation utilities ********\n\n// create an X,Y scatterplot, with different formatting for each label \nlet scatterplot (dataSet: (float * float) seq) (labels: \'a seq) =\n    let byLabel = Seq.zip labels dataSet |> Seq.toArray\n    let uniqueLabels = Seq.distinct labels\n    FSharpChart.Combine \n        [ // separate points by class and scatterplot them\n          for label in uniqueLabels ->\n               let data = \n                    Array.filter (fun e -> label = fst e) byLabel\n                    |> Array.map snd\n               FSharpChart.Point(data) :> ChartTypes.GenericChart\n               |> FSharpChart.WithSeries.Marker(Size=10)\n        ]\n    |> FSharpChart.Create\n\n// Visualize support vectors selected from dataset\nlet visualizeSupports (data: float list []) (labels: float []) estimator =\n    let labels = \n        estimator \n        |> (fst) \n        |> Seq.map (fun row -> \n            if row.Alpha > 0.0 then 0\n            elif row.Label < 0.0 then 1\n            else 2)\n    let data = \n        estimator \n        |> (fst) \n        |> Seq.map (fun row -> (row.Data.[0], row.Data.[1]))\n    scatterplot data labels\n\n// display dataset, and "separating line"\nlet separator (dataSet: (float * float) seq) (labels: \'a seq) (line: float -> float) =\n    let byLabel = Seq.zip labels dataSet |> Seq.toArray\n    let uniqueLabels = Seq.distinct labels\n    FSharpChart.Combine \n        [ // separate points by class and scatterplot them\n          for label in uniqueLabels ->\n               let data = \n                    Array.filter (fun e -> label = fst e) byLabel\n                    |> Array.map snd\n               FSharpChart.Point(data) :> ChartTypes.GenericChart\n               |> FSharpChart.WithSeries.Marker(Size=10)\n          // plot line between left- and right-most points\n          let x = Seq.map fst dataSet\n          let xMin, xMax = Seq.min x, Seq.max x           \n          let lineData = [ (xMin, line xMin); (xMax, line xMax)]\n          yield FSharpChart.Line (lineData)  :> ChartTypes.GenericChart\n        ]\n    |> FSharpChart.Create \n\nlet visualizeSeparatingLine (data: float list []) (labels: float []) estimator =\n    let w = weights (fst estimator)\n    let b = snd estimator\n    let line x = - b / w.[1] - x * w.[0] / w.[1]\n    separator (data |> Seq.map (fun e -> e.[0], e.[1])) labels line\n\n// Proportion of correctly classified\nlet quality (data: float list []) (labels: float []) classify =\n    let performance = \n        data\n        |> Array.map (fun row -> classify row)\n        |> Array.zip labels\n        |> Array.map (fun (a, b) -> if a * b > 0.0 then 1.0 else 0.0)\n        |> Array.average\n    printfn "Proportion correctly classified: %f" performance\n\n// ***************** Test datasets *********************\n\nlet rng = new Random()\n\n// tight dataset, linearly separable: there is no margin between 2 groups\nlet tightData = \n    [| for i in 1 .. 200 -> [ rng.NextDouble() * 100.0; rng.NextDouble() * 100.0 ] |]\nlet tightLabels = \n    tightData |> Array.map (fun el -> \n        if (el |> List.sum >= 100.0) then 1.0 else -1.0)\n\n// loose dataset, linearly separable: there is empty "gap" between 2 groups\nlet looseData = \n    tightData \n    |> Array.filter (fun e -> \n        let tot = List.sum e\n        tot > 110.0 || tot < 90.0)\nlet looseLabels = \n    looseData |> Array.map (fun el -> \n        if (el |> List.sum >= 100.0) then 1.0 else -1.0)\n\n// larger linearly separable dataset (1000 observations, 10 dimensions)\nlet largeData = \n    [| for i in 1 .. 5000 -> [ for d in 1 .. 10 -> rng.NextDouble() * 100.0 ] |]\nlet largeLabels = \n    largeData |> Array.map (fun x -> \n        if (x |> List.sum >= 500.0) then 1.0 else -1.0)\n\n// Non-linearly separable dataset (discus of radius 30, centered on (40, 60))\nlet circleData = \n    [| for i in 1 .. 1000 -> [ rng.NextDouble() * 100.0; rng.NextDouble() * 100.0 ] |]\nlet center = [ 40.0; 60.0 ]\nlet dist (coord1: float list) coord2 = \n    List.map2 (fun c1 c2 -> (c1-c2)*(c1-c2)) coord1 coord2\n    |> List.sum\n    |> sqrt\nlet circleLabels = \n    circleData \n        |> Array.map (fun data -> dist data center)\n        |> Array.map (fun dist -> if dist >= 30.0 then 1.0 else -1.0)\n\n// Validate on samples\n\n// plot raw datasets\n\n// identify support vectors\n\nlet parameters = { C = 0.6; Tolerance = 0.001; Depth = 50 }\nlet linearKernel = dot\n\n// tight dataset\nprintfn "Tight dataset"\nscatterplot (tightData |> Array.map (fun e -> e.[0], e.[1])) tightLabels\nlet tightEstimator = smo tightData tightLabels linearKernel parameters\nvisualizeSupports tightData tightLabels tightEstimator\nvisualizeSeparatingLine tightData tightLabels tightEstimator\nlet tightClassifier = classifier linearKernel tightEstimator\nquality tightData tightLabels tightClassifier\n\n// loose dataset\nprintfn "Loose dataset"\nscatterplot (looseData |> Array.map (fun e -> e.[0], e.[1])) looseLabels\nlet looseEstimator = smo looseData looseLabels linearKernel parameters\nvisualizeSupports looseData looseLabels looseEstimator\nvisualizeSeparatingLine looseData looseLabels looseEstimator\nlet looseClassifier = classifier linearKernel looseEstimator\nquality looseData looseLabels looseClassifier\n\n// circular dataset\nlet biasKernel = radialBias 30.0\n\nprintfn "Circular dataset"\nscatterplot (circleData |> Array.map (fun data -> data.[0], data.[1])) circleLabels\nlet circleEstimator = smo circleData circleLabels biasKernel parameters\nvisualizeSupports circleData circleLabels circleEstimator\nlet circleClassifier = classifier biasKernel circleEstimator\nquality circleData circleLabels circleClassifier\n\n// large dataset\nprintfn "Large dataset"\nlet largeEstimator = smo largeData largeLabels linearKernel parameters\nlet largeClassifier = classifier linearKernel largeEstimator\nquality largeData largeLabels largeClassifier\n\n// noisy dataset: a percentage of observations is mis-labeled\n// Commented out: the classifier seems to really struggle with this.\n//let misclassified = 0.05\n//let noisyData = tightData\n//let noisyLabels = \n//    tightLabels |> Array.map (fun l -> \n//        if (rng.NextDouble() > 1.0 - misclassified) then -l else l)\n//\n//scatterplot (noisyData |> Array.map (fun e -> e.[0], e.[1])) noisyLabels\n//plot noisyData noisyLabels parameters\n//test noisyData noisyLabels parameters\n//plotLine noisyData noisyLabels parameters\n\n'